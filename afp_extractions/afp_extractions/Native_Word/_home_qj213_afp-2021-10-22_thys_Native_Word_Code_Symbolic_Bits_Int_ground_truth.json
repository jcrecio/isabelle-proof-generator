{"file_name": "/home/qj213/afp-2021-10-22/thys/Native_Word/Code_Symbolic_Bits_Int.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Native_Word", "problem_names": ["lemma test_bit_int_code [code]:\n  \"bit (0::int)          n = False\"\n  \"bit (Int.Neg num.One) n = True\"\n  \"bit (Int.Pos num.One)      0 = True\"\n  \"bit (Int.Pos (num.Bit0 m)) 0 = False\"\n  \"bit (Int.Pos (num.Bit1 m)) 0 = True\"\n  \"bit (Int.Neg (num.Bit0 m)) 0 = False\"\n  \"bit (Int.Neg (num.Bit1 m)) 0 = True\"\n  \"bit (Int.Pos num.One)      (Suc n) = False\"\n  \"bit (Int.Pos (num.Bit0 m)) (Suc n) = bit (Int.Pos m) n\"\n  \"bit (Int.Pos (num.Bit1 m)) (Suc n) = bit (Int.Pos m) n\"\n  \"bit (Int.Neg (num.Bit0 m)) (Suc n) = bit (Int.Neg m) n\"\n  \"bit (Int.Neg (num.Bit1 m)) (Suc n) = bit (Int.Neg (Num.inc m)) n\"", "lemma int_not_code [code]:\n  \"NOT (0 :: int) = -1\"\n  \"NOT (Int.Pos n) = Int.Neg (Num.inc n)\"\n  \"NOT (Int.Neg n) = Num.sub n num.One\"", "lemma int_and_code [code]: fixes i j :: int shows\n  \"0 AND j = 0\"\n  \"i AND 0 = 0\"\n  \"Int.Pos n AND Int.Pos m = (case bitAND_num n m of None \\<Rightarrow> 0 | Some n' \\<Rightarrow> Int.Pos n')\"\n  \"Int.Neg n AND Int.Neg m = NOT (Num.sub n num.One OR Num.sub m num.One)\"\n  \"Int.Pos n AND Int.Neg num.One = Int.Pos n\"\n  \"Int.Pos n AND Int.Neg (num.Bit0 m) = Num.sub (bitORN_num (Num.BitM m) n) num.One\"\n  \"Int.Pos n AND Int.Neg (num.Bit1 m) = Num.sub (bitORN_num (num.Bit0 m) n) num.One\"\n  \"Int.Neg num.One AND Int.Pos m = Int.Pos m\"\n  \"Int.Neg (num.Bit0 n) AND Int.Pos m = Num.sub (bitORN_num (Num.BitM n) m) num.One\"\n  \"Int.Neg (num.Bit1 n) AND Int.Pos m = Num.sub (bitORN_num (num.Bit0 n) m) num.One\"", "lemma int_or_code [code]: fixes i j :: int shows\n  \"0 OR j = j\"\n  \"i OR 0 = i\"\n  \"Int.Pos n OR Int.Pos m = Int.Pos (bitOR_num n m)\"\n  \"Int.Neg n OR Int.Neg m = NOT (Num.sub n num.One AND Num.sub m num.One)\"\n  \"Int.Pos n OR Int.Neg num.One = Int.Neg num.One\"\n  \"Int.Pos n OR Int.Neg (num.Bit0 m) = (case bitANDN_num (Num.BitM m) n of None \\<Rightarrow> -1 | Some n' \\<Rightarrow> Int.Neg (Num.inc n'))\"\n  \"Int.Pos n OR Int.Neg (num.Bit1 m) = (case bitANDN_num (num.Bit0 m) n of None \\<Rightarrow> -1 | Some n' \\<Rightarrow> Int.Neg (Num.inc n'))\"\n  \"Int.Neg num.One OR Int.Pos m = Int.Neg num.One\"\n  \"Int.Neg (num.Bit0 n) OR Int.Pos m = (case bitANDN_num (Num.BitM n) m of None \\<Rightarrow> -1 | Some n' \\<Rightarrow> Int.Neg (Num.inc n'))\"\n  \"Int.Neg (num.Bit1 n) OR Int.Pos m = (case bitANDN_num (num.Bit0 n) m of None \\<Rightarrow> -1 | Some n' \\<Rightarrow> Int.Neg (Num.inc n'))\"", "lemma int_xor_code [code]: fixes i j :: int shows\n  \"0 XOR j = j\"\n  \"i XOR 0 = i\"\n  \"Int.Pos n XOR Int.Pos m = (case bitXOR_num n m of None \\<Rightarrow> 0 | Some n' \\<Rightarrow> Int.Pos n')\"\n  \"Int.Neg n XOR Int.Neg m = Num.sub n num.One XOR Num.sub m num.One\"\n  \"Int.Neg n XOR Int.Pos m = NOT (Num.sub n num.One XOR Int.Pos m)\"\n  \"Int.Pos n XOR Int.Neg m = NOT (Int.Pos n XOR Num.sub m num.One)\"", "lemma bin_rest_code: \"bin_rest i = i >> 1\"", "lemma set_bits_code [code]: \n  \"set_bits = Code.abort (STR ''set_bits is unsupported on type int'') (\\<lambda>_. set_bits :: _ \\<Rightarrow> int)\"", "lemma fixes i :: int \n  shows int_set_bit_True_conv_OR [code]: \"set_bit i n True = i OR (1 << n)\"\n  and int_set_bit_False_conv_NAND [code]: \"set_bit i n False = i AND NOT (1 << n)\"\n  and int_set_bit_conv_ops: \"set_bit i n b = (if b then i OR (1 << n) else i AND NOT (1 << n))\"", "lemma drop_bit_int_code [code]: fixes i :: int shows\n  \"drop_bit 0 i = i\"\n  \"drop_bit (Suc n) 0 = (0 :: int)\"\n  \"drop_bit (Suc n) (Int.Pos num.One) = 0\"\n  \"drop_bit (Suc n) (Int.Pos (num.Bit0 m)) = drop_bit n (Int.Pos m)\"\n  \"drop_bit (Suc n) (Int.Pos (num.Bit1 m)) = drop_bit n (Int.Pos m)\"\n  \"drop_bit (Suc n) (Int.Neg num.One) = - 1\"\n  \"drop_bit (Suc n) (Int.Neg (num.Bit0 m)) = drop_bit n (Int.Neg m)\"\n  \"drop_bit (Suc n) (Int.Neg (num.Bit1 m)) = drop_bit n (Int.Neg (Num.inc m))\"", "lemma push_bit_int_code [code]:\n  \"push_bit 0 i = i\"\n  \"push_bit (Suc n) i = push_bit n (Int.dup i)\"", "lemma int_lsb_code [code]:\n  \"lsb (0 :: int) = False\"\n  \"lsb (Int.Pos num.One) = True\"\n  \"lsb (Int.Pos (num.Bit0 w)) = False\"\n  \"lsb (Int.Pos (num.Bit1 w)) = True\"\n  \"lsb (Int.Neg num.One) = True\"\n  \"lsb (Int.Neg (num.Bit0 w)) = False\"\n  \"lsb (Int.Neg (num.Bit1 w)) = True\""], "translations": [["", "lemma test_bit_int_code [code]:\n  \"bit (0::int)          n = False\"\n  \"bit (Int.Neg num.One) n = True\"\n  \"bit (Int.Pos num.One)      0 = True\"\n  \"bit (Int.Pos (num.Bit0 m)) 0 = False\"\n  \"bit (Int.Pos (num.Bit1 m)) 0 = True\"\n  \"bit (Int.Neg (num.Bit0 m)) 0 = False\"\n  \"bit (Int.Neg (num.Bit1 m)) 0 = True\"\n  \"bit (Int.Pos num.One)      (Suc n) = False\"\n  \"bit (Int.Pos (num.Bit0 m)) (Suc n) = bit (Int.Pos m) n\"\n  \"bit (Int.Pos (num.Bit1 m)) (Suc n) = bit (Int.Pos m) n\"\n  \"bit (Int.Neg (num.Bit0 m)) (Suc n) = bit (Int.Neg m) n\"\n  \"bit (Int.Neg (num.Bit1 m)) (Suc n) = bit (Int.Neg (Num.inc m)) n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((bit 0 n = False &&&\n      bit (Int.Neg num.One) n = True &&& bit (Int.Pos num.One) 0 = True) &&&\n     bit (Int.Pos (num.Bit0 m)) 0 = False &&&\n     bit (Int.Pos (num.Bit1 m)) 0 = True &&&\n     bit (Int.Neg (num.Bit0 m)) 0 = False) &&&\n    (bit (Int.Neg (num.Bit1 m)) 0 = True &&&\n     bit (Int.Pos num.One) (Suc n) = False &&&\n     bit (Int.Pos (num.Bit0 m)) (Suc n) = bit (Int.Pos m) n) &&&\n    bit (Int.Pos (num.Bit1 m)) (Suc n) = bit (Int.Pos m) n &&&\n    bit (Int.Neg (num.Bit0 m)) (Suc n) = bit (Int.Neg m) n &&&\n    bit (Int.Neg (num.Bit1 m)) (Suc n) = bit (Int.Neg (Num.inc m)) n", "by (simp_all add: Num.add_One bit_Suc)"], ["", "lemma int_not_code [code]:\n  \"NOT (0 :: int) = -1\"\n  \"NOT (Int.Pos n) = Int.Neg (Num.inc n)\"\n  \"NOT (Int.Neg n) = Num.sub n num.One\""], ["proof (prove)\ngoal (1 subgoal):\n 1. NOT 0 = - 1 &&&\n    NOT (Int.Pos n) = Int.Neg (Num.inc n) &&&\n    NOT (Int.Neg n) = neg_numeral_class.sub n num.One", "by(simp_all add: Num.add_One int_not_def)"], ["", "lemma int_and_code [code]: fixes i j :: int shows\n  \"0 AND j = 0\"\n  \"i AND 0 = 0\"\n  \"Int.Pos n AND Int.Pos m = (case bitAND_num n m of None \\<Rightarrow> 0 | Some n' \\<Rightarrow> Int.Pos n')\"\n  \"Int.Neg n AND Int.Neg m = NOT (Num.sub n num.One OR Num.sub m num.One)\"\n  \"Int.Pos n AND Int.Neg num.One = Int.Pos n\"\n  \"Int.Pos n AND Int.Neg (num.Bit0 m) = Num.sub (bitORN_num (Num.BitM m) n) num.One\"\n  \"Int.Pos n AND Int.Neg (num.Bit1 m) = Num.sub (bitORN_num (num.Bit0 m) n) num.One\"\n  \"Int.Neg num.One AND Int.Pos m = Int.Pos m\"\n  \"Int.Neg (num.Bit0 n) AND Int.Pos m = Num.sub (bitORN_num (Num.BitM n) m) num.One\"\n  \"Int.Neg (num.Bit1 n) AND Int.Pos m = Num.sub (bitORN_num (num.Bit0 n) m) num.One\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((0 AND j = 0 &&& i AND 0 = 0) &&&\n     Int.Pos n AND Int.Pos m =\n     (case bitAND_num n m of None \\<Rightarrow> 0\n      | Some n' \\<Rightarrow> Int.Pos n') &&&\n     Int.Neg n AND Int.Neg m =\n     NOT (neg_numeral_class.sub n num.One OR\n          neg_numeral_class.sub m num.One) &&&\n     Int.Pos n AND Int.Neg num.One = Int.Pos n) &&&\n    (Int.Pos n AND Int.Neg (num.Bit0 m) =\n     neg_numeral_class.sub (bitORN_num (Num.BitM m) n) num.One &&&\n     Int.Pos n AND Int.Neg (num.Bit1 m) =\n     neg_numeral_class.sub (bitORN_num (num.Bit0 m) n) num.One) &&&\n    Int.Neg num.One AND Int.Pos m = Int.Pos m &&&\n    Int.Neg (num.Bit0 n) AND Int.Pos m =\n    neg_numeral_class.sub (bitORN_num (Num.BitM n) m) num.One &&&\n    Int.Neg (num.Bit1 n) AND Int.Pos m =\n    neg_numeral_class.sub (bitORN_num (num.Bit0 n) m) num.One", "apply (simp_all add: int_numeral_bitAND_num Num.add_One\n              sub_inc_One_eq inc_BitM_eq not_minus_numeral_inc_eq\n              flip: int_not_neg_numeral int_or_not_bitORN_num split: option.split)"], ["proof (prove)\ngoal (2 subgoals):\n 1. numeral n AND - numeral (num.Bit0 m) =\n    - numeral (num.Bit0 m) AND numeral n\n 2. numeral n AND - numeral (num.Bit1 m) =\n    - numeral (num.Bit1 m) AND numeral n", "apply (simp_all add: ac_simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma int_or_code [code]: fixes i j :: int shows\n  \"0 OR j = j\"\n  \"i OR 0 = i\"\n  \"Int.Pos n OR Int.Pos m = Int.Pos (bitOR_num n m)\"\n  \"Int.Neg n OR Int.Neg m = NOT (Num.sub n num.One AND Num.sub m num.One)\"\n  \"Int.Pos n OR Int.Neg num.One = Int.Neg num.One\"\n  \"Int.Pos n OR Int.Neg (num.Bit0 m) = (case bitANDN_num (Num.BitM m) n of None \\<Rightarrow> -1 | Some n' \\<Rightarrow> Int.Neg (Num.inc n'))\"\n  \"Int.Pos n OR Int.Neg (num.Bit1 m) = (case bitANDN_num (num.Bit0 m) n of None \\<Rightarrow> -1 | Some n' \\<Rightarrow> Int.Neg (Num.inc n'))\"\n  \"Int.Neg num.One OR Int.Pos m = Int.Neg num.One\"\n  \"Int.Neg (num.Bit0 n) OR Int.Pos m = (case bitANDN_num (Num.BitM n) m of None \\<Rightarrow> -1 | Some n' \\<Rightarrow> Int.Neg (Num.inc n'))\"\n  \"Int.Neg (num.Bit1 n) OR Int.Pos m = (case bitANDN_num (num.Bit0 n) m of None \\<Rightarrow> -1 | Some n' \\<Rightarrow> Int.Neg (Num.inc n'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((0 OR j = j &&& i OR 0 = i) &&&\n     Int.Pos n OR Int.Pos m = Int.Pos (bitOR_num n m) &&&\n     Int.Neg n OR Int.Neg m =\n     NOT (neg_numeral_class.sub n num.One AND\n          neg_numeral_class.sub m num.One) &&&\n     Int.Pos n OR Int.Neg num.One = Int.Neg num.One) &&&\n    (Int.Pos n OR Int.Neg (num.Bit0 m) =\n     (case bitANDN_num (Num.BitM m) n of None \\<Rightarrow> - 1\n      | Some n' \\<Rightarrow> Int.Neg (Num.inc n')) &&&\n     Int.Pos n OR Int.Neg (num.Bit1 m) =\n     (case bitANDN_num (num.Bit0 m) n of None \\<Rightarrow> - 1\n      | Some n' \\<Rightarrow> Int.Neg (Num.inc n'))) &&&\n    Int.Neg num.One OR Int.Pos m = Int.Neg num.One &&&\n    Int.Neg (num.Bit0 n) OR Int.Pos m =\n    (case bitANDN_num (Num.BitM n) m of None \\<Rightarrow> - 1\n     | Some n' \\<Rightarrow> Int.Neg (Num.inc n')) &&&\n    Int.Neg (num.Bit1 n) OR Int.Pos m =\n    (case bitANDN_num (num.Bit0 n) m of None \\<Rightarrow> - 1\n     | Some n' \\<Rightarrow> Int.Neg (Num.inc n'))", "apply (simp_all add: int_numeral_bitOR_num flip: int_not_neg_numeral)"], ["proof (prove)\ngoal (4 subgoals):\n 1. numeral n OR - numeral (num.Bit0 m) =\n    (case bitANDN_num (Num.BitM m) n of None \\<Rightarrow> - 1\n     | Some n' \\<Rightarrow> Int.Neg (Num.inc n'))\n 2. numeral n OR - numeral (num.Bit1 m) =\n    (case bitANDN_num (num.Bit0 m) n of None \\<Rightarrow> - 1\n     | Some n' \\<Rightarrow> Int.Neg (Num.inc n'))\n 3. - numeral (num.Bit0 n) OR numeral m =\n    (case bitANDN_num (Num.BitM n) m of None \\<Rightarrow> - 1\n     | Some n' \\<Rightarrow> Int.Neg (Num.inc n'))\n 4. - numeral (num.Bit1 n) OR numeral m =\n    (case bitANDN_num (num.Bit0 n) m of None \\<Rightarrow> - 1\n     | Some n' \\<Rightarrow> Int.Neg (Num.inc n'))", "apply (simp_all add: or_int_def int_and_comm int_not_and_bitANDN_num del: int_not_simps(4) split: option.split)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<forall>x2.\n       bitANDN_num (Num.BitM m) n = Some x2 \\<longrightarrow>\n       NOT (numeral x2) = - numeral (Num.inc x2)\n 2. \\<forall>x2.\n       bitANDN_num (num.Bit0 m) n = Some x2 \\<longrightarrow>\n       NOT (numeral x2) = - numeral (Num.inc x2)\n 3. \\<forall>x2.\n       bitANDN_num (Num.BitM n) m = Some x2 \\<longrightarrow>\n       NOT (numeral x2) = - numeral (Num.inc x2)\n 4. \\<forall>x2.\n       bitANDN_num (num.Bit0 n) m = Some x2 \\<longrightarrow>\n       NOT (numeral x2) = - numeral (Num.inc x2)", "apply (simp_all add: Num.add_One)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma int_xor_code [code]: fixes i j :: int shows\n  \"0 XOR j = j\"\n  \"i XOR 0 = i\"\n  \"Int.Pos n XOR Int.Pos m = (case bitXOR_num n m of None \\<Rightarrow> 0 | Some n' \\<Rightarrow> Int.Pos n')\"\n  \"Int.Neg n XOR Int.Neg m = Num.sub n num.One XOR Num.sub m num.One\"\n  \"Int.Neg n XOR Int.Pos m = NOT (Num.sub n num.One XOR Int.Pos m)\"\n  \"Int.Pos n XOR Int.Neg m = NOT (Int.Pos n XOR Num.sub m num.One)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0 XOR j = j &&&\n     i XOR 0 = i &&&\n     Int.Pos n XOR Int.Pos m =\n     (case bitXOR_num n m of None \\<Rightarrow> 0\n      | Some n' \\<Rightarrow> Int.Pos n')) &&&\n    Int.Neg n XOR Int.Neg m =\n    neg_numeral_class.sub n num.One XOR neg_numeral_class.sub m num.One &&&\n    Int.Neg n XOR Int.Pos m =\n    NOT (neg_numeral_class.sub n num.One XOR Int.Pos m) &&&\n    Int.Pos n XOR Int.Neg m =\n    NOT (Int.Pos n XOR neg_numeral_class.sub m num.One)", "by(fold int_not_neg_numeral)(simp_all add: int_numeral_bitXOR_num int_xor_not cong: option.case_cong)"], ["", "lemma bin_rest_code: \"bin_rest i = i >> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i div 2 = i >> 1", "by (simp add: shiftr_int_def)"], ["", "lemma set_bits_code [code]: \n  \"set_bits = Code.abort (STR ''set_bits is unsupported on type int'') (\\<lambda>_. set_bits :: _ \\<Rightarrow> int)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_bits =\n    Code.abort STR ''set_bits is unsupported on type int''\n     (\\<lambda>_. set_bits)", "by simp"], ["", "lemma fixes i :: int \n  shows int_set_bit_True_conv_OR [code]: \"set_bit i n True = i OR (1 << n)\"\n  and int_set_bit_False_conv_NAND [code]: \"set_bit i n False = i AND NOT (1 << n)\"\n  and int_set_bit_conv_ops: \"set_bit i n b = (if b then i OR (1 << n) else i AND NOT (1 << n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_bit_class.set_bit i n True = i OR (1 << n) &&&\n    set_bit_class.set_bit i n False = i AND NOT (1 << n) &&&\n    set_bit_class.set_bit i n b =\n    (if b then i OR (1 << n) else i AND NOT (1 << n))", "by(simp_all add: set_bit_int_def bin_set_conv_OR bin_clr_conv_NAND)"], ["", "declare [[code drop: \\<open>drop_bit :: nat \\<Rightarrow> int \\<Rightarrow> int\\<close>]]"], ["", "lemma drop_bit_int_code [code]: fixes i :: int shows\n  \"drop_bit 0 i = i\"\n  \"drop_bit (Suc n) 0 = (0 :: int)\"\n  \"drop_bit (Suc n) (Int.Pos num.One) = 0\"\n  \"drop_bit (Suc n) (Int.Pos (num.Bit0 m)) = drop_bit n (Int.Pos m)\"\n  \"drop_bit (Suc n) (Int.Pos (num.Bit1 m)) = drop_bit n (Int.Pos m)\"\n  \"drop_bit (Suc n) (Int.Neg num.One) = - 1\"\n  \"drop_bit (Suc n) (Int.Neg (num.Bit0 m)) = drop_bit n (Int.Neg m)\"\n  \"drop_bit (Suc n) (Int.Neg (num.Bit1 m)) = drop_bit n (Int.Neg (Num.inc m))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((drop_bit 0 i = i &&& drop_bit (Suc n) 0 = 0) &&&\n     drop_bit (Suc n) (Int.Pos num.One) = 0 &&&\n     drop_bit (Suc n) (Int.Pos (num.Bit0 m)) = drop_bit n (Int.Pos m)) &&&\n    (drop_bit (Suc n) (Int.Pos (num.Bit1 m)) = drop_bit n (Int.Pos m) &&&\n     drop_bit (Suc n) (Int.Neg num.One) = - 1) &&&\n    drop_bit (Suc n) (Int.Neg (num.Bit0 m)) = drop_bit n (Int.Neg m) &&&\n    drop_bit (Suc n) (Int.Neg (num.Bit1 m)) =\n    drop_bit n (Int.Neg (Num.inc m))", "by (simp_all add: shiftr_eq_drop_bit drop_bit_Suc add_One)"], ["", "declare [[code drop: \\<open>push_bit :: nat \\<Rightarrow> int \\<Rightarrow> int\\<close>]]"], ["", "lemma push_bit_int_code [code]:\n  \"push_bit 0 i = i\"\n  \"push_bit (Suc n) i = push_bit n (Int.dup i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. push_bit 0 i = i &&& push_bit (Suc n) i = push_bit n (Int.dup i)", "by (simp_all add: ac_simps)"], ["", "lemma int_lsb_code [code]:\n  \"lsb (0 :: int) = False\"\n  \"lsb (Int.Pos num.One) = True\"\n  \"lsb (Int.Pos (num.Bit0 w)) = False\"\n  \"lsb (Int.Pos (num.Bit1 w)) = True\"\n  \"lsb (Int.Neg num.One) = True\"\n  \"lsb (Int.Neg (num.Bit0 w)) = False\"\n  \"lsb (Int.Neg (num.Bit1 w)) = True\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (lsb 0 = False &&&\n     lsb (Int.Pos num.One) = True &&&\n     lsb (Int.Pos (num.Bit0 w)) = False) &&&\n    (lsb (Int.Pos (num.Bit1 w)) = True &&& lsb (Int.Neg num.One) = True) &&&\n    lsb (Int.Neg (num.Bit0 w)) = False &&& lsb (Int.Neg (num.Bit1 w)) = True", "by simp_all"], ["", "end"]]}