{"file_name": "/home/qj213/afp-2021-10-22/thys/Native_Word/Uint8.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Native_Word", "problem_names": ["lemmas [code] = less_uint8.rep_eq less_eq_uint8.rep_eq", "lemma [transfer_rule]:\n  \"((=) ===> cr_uint8) of_bool of_bool\"", "lemma transfer_rule_numeral_uint [transfer_rule]:\n  \"((=) ===> cr_uint8) numeral numeral\"", "lemma [transfer_rule]:\n  \\<open>(cr_uint8 ===> (\\<longleftrightarrow>)) even ((dvd) 2 :: uint8 \\<Rightarrow> bool)\\<close>", "lemma [code]:\n  \\<open>take_bit n a = a AND mask n\\<close> for a :: uint8", "lemma [code]:\n  \\<open>mask (Suc n) = push_bit n (1 :: uint8) OR mask n\\<close>\n  \\<open>mask 0 = (0 :: uint8)\\<close>", "lemma test_bit_uint8_transfer [transfer_rule]:\n  \\<open>(cr_uint8 ===> (=)) bit (!!)\\<close>", "lemma shiftl_uint8_transfer [transfer_rule]:\n  \\<open>(cr_uint8 ===> (=) ===> cr_uint8) (\\<lambda>k n. push_bit n k) (<<)\\<close>", "lemma shiftr_uint8_transfer [transfer_rule]:\n  \\<open>(cr_uint8 ===> (=) ===> cr_uint8) (\\<lambda>k n. drop_bit n k) (>>)\\<close>", "lemmas [code] = bit_uint8.rep_eq lsb_uint8.rep_eq msb_uint8.rep_eq", "lemmas [code] = equal_uint8.rep_eq", "lemmas [code] = size_uint8.rep_eq", "lemma Rep_uint8_numeral [simp]: \"Rep_uint8 (numeral n) = numeral n\"", "lemma numeral_uint8_transfer [transfer_rule]:\n  \"(rel_fun (=) cr_uint8) numeral numeral\"", "lemma numeral_uint8 [code_unfold]: \"numeral n = Uint8 (numeral n)\"", "lemma Rep_uint8_neg_numeral [simp]: \"Rep_uint8 (- numeral n) = - numeral n\"", "lemma neg_numeral_uint8 [code_unfold]: \"- numeral n = Uint8 (- numeral n)\"", "lemma Abs_uint8_numeral [code_post]: \"Abs_uint8 (numeral n) = numeral n\"", "lemma Abs_uint8_0 [code_post]: \"Abs_uint8 0 = 0\"", "lemma Abs_uint8_1 [code_post]: \"Abs_uint8 1 = 1\"", "lemma Rep_uint8'_transfer [transfer_rule]:\n  \"rel_fun cr_uint8 (=) (\\<lambda>x. x) Rep_uint8'\"", "lemma Rep_uint8'_code [code]: \"Rep_uint8' x = (BITS n. bit x n)\"", "lemma Abs_uint8'_code [code]: \"Abs_uint8' x = Uint8 (integer_of_int (uint x))\"", "lemma term_of_uint8_code [code]:\n  defines \"TR \\<equiv> typerep.Typerep\" and \"bit0 \\<equiv> STR ''Numeral_Type.bit0''\" shows\n  \"term_of_class.term_of x = \n   Code_Evaluation.App (Code_Evaluation.Const (STR ''Uint8.uint8.Abs_uint8'') (TR (STR ''fun'') [TR (STR ''Word.word'') [TR bit0 [TR bit0 [TR bit0 [TR (STR ''Numeral_Type.num1'') []]]]], TR (STR ''Uint8.uint8'') []]))\n       (term_of_class.term_of (Rep_uint8' x))\"", "lemma Uin8_code [code abstract]: \"Rep_uint8 (Uint8 i) = word_of_int (int_of_integer_symbolic i)\"", "lemma div_uint8_code [code]: \"x div y = (if y = 0 then 0 else uint8_div x y)\"", "lemma mod_uint8_code [code]: \"x mod y = (if y = 0 then x else uint8_mod x y)\"", "lemma uint8_divmod_code [code]:\n  \"uint8_divmod x y =\n  (if 0x80 \\<le> y then if x < y then (0, x) else (1, x - y)\n   else if y = 0 then (div0_uint8 x, mod0_uint8 x)\n   else let q = (uint8_sdiv (x >> 1) y) << 1;\n            r = x - q * y\n        in if r \\<ge> y then (q + 1, r - y) else (q, r))\"", "lemma uint8_sdiv_code [code abstract]:\n  \"Rep_uint8 (uint8_sdiv x y) =\n   (if y = 0 then Rep_uint8 (undefined ((div) :: uint8 \\<Rightarrow> _) x (0 :: uint8))\n    else Rep_uint8 x sdiv Rep_uint8 y)\"", "lemma bit_uint8_code [code]:\n  \"bit x n \\<longleftrightarrow> n < 8 \\<and> uint8_test_bit x (integer_of_nat n)\"", "lemma uint8_test_bit_code [code]:\n  \"uint8_test_bit w n =\n  (if n < 0 \\<or> 7 < n then undefined (test_bit :: uint8 \\<Rightarrow> _) w n else Rep_uint8 w !! nat_of_integer n)\"", "lemma set_bit_uint8_code [code]:\n  \"set_bit x n b = (if n < 8 then uint8_set_bit x (integer_of_nat n) b else x)\"", "lemma uint8_set_bit_code [code abstract]:\n  \"Rep_uint8 (uint8_set_bit w n b) = \n  (if n < 0 \\<or> 7 < n then Rep_uint8 (undefined (set_bit :: uint8 \\<Rightarrow> _) w n b)\n   else set_bit (Rep_uint8 w) (nat_of_integer n) b)\"", "lemma uint8_set_bits_code [code]:\n  \"uint8_set_bits f w n =\n  (if n = 0 then w \n   else let n' = n - 1 in uint8_set_bits f (push_bit 1 w OR (if f n' then 1 else 0)) n')\"", "lemma set_bits_uint8 [code]:\n  \"(BITS n. f n) = uint8_set_bits f 0 8\"", "lemma lsb_code [code]: fixes x :: uint8 shows \"lsb x = x !! 0\"", "lemma shiftl_uint8_code [code]:\n  \"push_bit n x = (if n < 8 then uint8_shiftl x (integer_of_nat n) else 0)\"", "lemma uint8_shiftl_code [code abstract]:\n  \"Rep_uint8 (uint8_shiftl w n) =\n  (if n < 0 \\<or> 8 \\<le> n then Rep_uint8 (undefined (push_bit :: nat \\<Rightarrow> uint8 \\<Rightarrow> _) w n)\n   else push_bit (nat_of_integer n) (Rep_uint8 w))\"", "lemma shiftr_uint8_code [code]:\n  \"drop_bit n x = (if n < 8 then uint8_shiftr x (integer_of_nat n) else 0)\"", "lemma uint8_shiftr_code [code abstract]:\n  \"Rep_uint8 (uint8_shiftr w n) =\n  (if n < 0 \\<or> 8 \\<le> n then Rep_uint8 (undefined (shiftr :: uint8 \\<Rightarrow> _) w n) \n   else drop_bit (nat_of_integer n) (Rep_uint8 w))\"", "lemma sshiftr_uint8_code [code]:\n  \"x >>> n = \n  (if n < 8 then uint8_sshiftr x (integer_of_nat n) else if x !! 7 then -1 else 0)\"", "lemma uint8_sshiftr_code [code abstract]:\n  \"Rep_uint8 (uint8_sshiftr w n) =\n  (if n < 0 \\<or> 8 \\<le> n then Rep_uint8 (undefined sshiftr_uint8 w n)\n   else signed_drop_bit (nat_of_integer n) (Rep_uint8 w))\"", "lemma uint8_msb_test_bit: \"msb x \\<longleftrightarrow> (x :: uint8) !! 7\"", "lemma msb_uint16_code [code]: \"msb x \\<longleftrightarrow> uint8_test_bit x 7\"", "lemma uint8_of_int_code [code]: \"uint8_of_int i = Uint8 (integer_of_int i)\"", "lemma int_of_uint8_code [code]:\n  \"int_of_uint8 x = int_of_integer (integer_of_uint8 x)\"", "lemma nat_of_uint8_code [code]:\n  \"nat_of_uint8 x = nat_of_integer (integer_of_uint8 x)\"", "lemma integer_of_uint8_signed_code [code]:\n  \"integer_of_uint8_signed n =\n  (if bit n 7 then undefined integer_of_uint8 n else integer_of_int (uint (Rep_uint8' n)))\"", "lemma integer_of_uint8_code [code]:\n  \"integer_of_uint8 n =\n  (if bit n 7 then integer_of_uint8_signed (n AND 0x7F) OR 0x80 else integer_of_uint8_signed n)\"", "lemmas partial_term_of_uint8 [code] = partial_term_of_code"], "translations": [["", "lemmas [code] = less_uint8.rep_eq less_eq_uint8.rep_eq"], ["", "context\n  includes lifting_syntax\n  notes\n    transfer_rule_of_bool [transfer_rule]\n    transfer_rule_numeral [transfer_rule]\nbegin"], ["", "lemma [transfer_rule]:\n  \"((=) ===> cr_uint8) of_bool of_bool\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((=) ===> cr_uint8) of_bool of_bool", "by transfer_prover"], ["", "lemma transfer_rule_numeral_uint [transfer_rule]:\n  \"((=) ===> cr_uint8) numeral numeral\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((=) ===> cr_uint8) numeral numeral", "by transfer_prover"], ["", "lemma [transfer_rule]:\n  \\<open>(cr_uint8 ===> (\\<longleftrightarrow>)) even ((dvd) 2 :: uint8 \\<Rightarrow> bool)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (cr_uint8 ===> (=)) even ((dvd) 2)", "by (unfold dvd_def) transfer_prover"], ["", "end"], ["", "instantiation uint8 :: semiring_bits\nbegin"], ["", "lift_definition bit_uint8 :: \\<open>uint8 \\<Rightarrow> nat \\<Rightarrow> bool\\<close> is bit"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(uint8, semiring_bits_class)", "by (standard; transfer)\n    (fact bit_iff_odd even_iff_mod_2_eq_zero odd_iff_mod_2_eq_one odd_one bits_induct\n       bits_div_0 bits_div_by_1 bits_mod_div_trivial even_succ_div_2\n       even_mask_div_iff exp_div_exp_eq div_exp_eq mod_exp_eq mult_exp_mod_exp_eq\n       div_exp_mod_exp_eq even_mult_exp_div_exp_iff)+"], ["", "end"], ["", "instantiation uint8 :: semiring_bit_shifts\nbegin"], ["", "lift_definition push_bit_uint8 :: \\<open>nat \\<Rightarrow> uint8 \\<Rightarrow> uint8\\<close> is push_bit"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition drop_bit_uint8 :: \\<open>nat \\<Rightarrow> uint8 \\<Rightarrow> uint8\\<close> is drop_bit"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition take_bit_uint8 :: \\<open>nat \\<Rightarrow> uint8 \\<Rightarrow> uint8\\<close> is take_bit"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(uint8, semiring_bit_shifts_class)", "by (standard; transfer)\n  (fact push_bit_eq_mult drop_bit_eq_div take_bit_eq_mod)+"], ["", "end"], ["", "instantiation uint8 :: ring_bit_operations\nbegin"], ["", "lift_definition not_uint8 :: \\<open>uint8 \\<Rightarrow> uint8\\<close> is NOT"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition and_uint8 :: \\<open>uint8 \\<Rightarrow> uint8 \\<Rightarrow> uint8\\<close> is \\<open>(AND)\\<close>"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition or_uint8 :: \\<open>uint8 \\<Rightarrow> uint8 \\<Rightarrow> uint8\\<close> is \\<open>(OR)\\<close>"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition xor_uint8 :: \\<open>uint8 \\<Rightarrow> uint8 \\<Rightarrow> uint8\\<close> is \\<open>(XOR)\\<close>"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition mask_uint8 :: \\<open>nat \\<Rightarrow> uint8\\<close> is mask"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(uint8, ring_bit_operations_class)", "by (standard; transfer)\n  (simp_all add: bit_and_iff bit_or_iff bit_xor_iff bit_not_iff minus_eq_not_minus_1 mask_eq_decr_exp)"], ["", "end"], ["", "lemma [code]:\n  \\<open>take_bit n a = a AND mask n\\<close> for a :: uint8"], ["proof (prove)\ngoal (1 subgoal):\n 1. take_bit n a = a AND mask n", "by (fact take_bit_eq_mask)"], ["", "lemma [code]:\n  \\<open>mask (Suc n) = push_bit n (1 :: uint8) OR mask n\\<close>\n  \\<open>mask 0 = (0 :: uint8)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. mask (Suc n) = push_bit n 1 OR mask n &&& mask 0 = 0", "by (simp_all add: mask_Suc_exp push_bit_of_1)"], ["", "instance uint8 :: semiring_bit_syntax"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(uint8, semiring_bit_syntax_class)", ".."], ["", "context\n  includes lifting_syntax\nbegin"], ["", "lemma test_bit_uint8_transfer [transfer_rule]:\n  \\<open>(cr_uint8 ===> (=)) bit (!!)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (cr_uint8 ===> (=)) bit (!!)", "unfolding test_bit_eq_bit"], ["proof (prove)\ngoal (1 subgoal):\n 1. (cr_uint8 ===> (=)) bit bit", "by transfer_prover"], ["", "lemma shiftl_uint8_transfer [transfer_rule]:\n  \\<open>(cr_uint8 ===> (=) ===> cr_uint8) (\\<lambda>k n. push_bit n k) (<<)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (cr_uint8 ===> (=) ===> cr_uint8) (\\<lambda>k n. push_bit n k) (<<)", "unfolding shiftl_eq_push_bit"], ["proof (prove)\ngoal (1 subgoal):\n 1. (cr_uint8 ===> (=) ===> cr_uint8) (\\<lambda>k n. push_bit n k)\n     (\\<lambda>a n. push_bit n a)", "by transfer_prover"], ["", "lemma shiftr_uint8_transfer [transfer_rule]:\n  \\<open>(cr_uint8 ===> (=) ===> cr_uint8) (\\<lambda>k n. drop_bit n k) (>>)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (cr_uint8 ===> (=) ===> cr_uint8) (\\<lambda>k n. drop_bit n k) (>>)", "unfolding shiftr_eq_drop_bit"], ["proof (prove)\ngoal (1 subgoal):\n 1. (cr_uint8 ===> (=) ===> cr_uint8) (\\<lambda>k n. drop_bit n k)\n     (\\<lambda>a n. drop_bit n a)", "by transfer_prover"], ["", "end"], ["", "instantiation uint8 :: lsb\nbegin"], ["", "lift_definition lsb_uint8 :: \\<open>uint8 \\<Rightarrow> bool\\<close> is lsb"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(uint8, lsb_class)", "by (standard; transfer)\n  (fact lsb_odd)"], ["", "end"], ["", "instantiation uint8 :: msb\nbegin"], ["", "lift_definition msb_uint8 :: \\<open>uint8 \\<Rightarrow> bool\\<close> is msb"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(uint8, msb_class)", ".."], ["", "end"], ["", "instantiation uint8 :: set_bit\nbegin"], ["", "lift_definition set_bit_uint8 :: \\<open>uint8 \\<Rightarrow> nat \\<Rightarrow> bool \\<Rightarrow> uint8\\<close> is set_bit"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(uint8, set_bit_class)", "apply standard"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a m b n.\n       bit (set_bit_class.set_bit a m b) n =\n       ((if m = n then b else bit a n) \\<and> 2 ^ n \\<noteq> 0)", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a m b n.\n       bit (set_bit_class.set_bit a m b) n =\n       ((if m = n then b else bit a n) \\<and> 2 ^ n \\<noteq> 0)", "apply (simp add: bit_simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "instantiation uint8 :: bit_comprehension begin"], ["", "lift_definition set_bits_uint8 :: \"(nat \\<Rightarrow> bool) \\<Rightarrow> uint8\" is \"set_bits\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(uint8, bit_comprehension_class)", "by (standard; transfer) (fact set_bits_bit_eq)"], ["", "end"], ["", "lemmas [code] = bit_uint8.rep_eq lsb_uint8.rep_eq msb_uint8.rep_eq"], ["", "instantiation uint8 :: equal begin"], ["", "lift_definition equal_uint8 :: \"uint8 \\<Rightarrow> uint8 \\<Rightarrow> bool\" is \"equal_class.equal\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(uint8, equal_class)", "by standard (transfer, simp add: equal_eq)"], ["", "end"], ["", "lemmas [code] = equal_uint8.rep_eq"], ["", "instantiation uint8 :: size begin"], ["", "lift_definition size_uint8 :: \"uint8 \\<Rightarrow> nat\" is \"size\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(uint8, size_class)", ".."], ["", "end"], ["", "lemmas [code] = size_uint8.rep_eq"], ["", "lift_definition sshiftr_uint8 :: \"uint8 \\<Rightarrow> nat \\<Rightarrow> uint8\" (infixl \">>>\" 55) is \\<open>\\<lambda>w n. signed_drop_bit n w\\<close>"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition uint8_of_int :: \"int \\<Rightarrow> uint8\" is \"word_of_int\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "definition uint8_of_nat :: \"nat \\<Rightarrow> uint8\"\nwhere \"uint8_of_nat = uint8_of_int \\<circ> int\""], ["", "lift_definition int_of_uint8 :: \"uint8 \\<Rightarrow> int\" is \"uint\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition nat_of_uint8 :: \"uint8 \\<Rightarrow> nat\" is \"unat\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "definition integer_of_uint8 :: \"uint8 \\<Rightarrow> integer\"\nwhere \"integer_of_uint8 = integer_of_int o int_of_uint8\""], ["", "text \\<open>Use pretty numerals from integer for pretty printing\\<close>"], ["", "context includes integer.lifting begin"], ["", "lift_definition Uint8 :: \"integer \\<Rightarrow> uint8\" is \"word_of_int\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma Rep_uint8_numeral [simp]: \"Rep_uint8 (numeral n) = numeral n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_uint8 (numeral n) = numeral n", "by(induction n)(simp_all add: one_uint8_def Abs_uint8_inverse numeral.simps plus_uint8_def)"], ["", "lemma numeral_uint8_transfer [transfer_rule]:\n  \"(rel_fun (=) cr_uint8) numeral numeral\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_fun (=) cr_uint8 numeral numeral", "by(auto simp add: cr_uint8_def)"], ["", "lemma numeral_uint8 [code_unfold]: \"numeral n = Uint8 (numeral n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. numeral n = Uint8 (numeral n)", "by transfer simp"], ["", "lemma Rep_uint8_neg_numeral [simp]: \"Rep_uint8 (- numeral n) = - numeral n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_uint8 (- numeral n) = - numeral n", "by(simp only: uminus_uint8_def)(simp add: Abs_uint8_inverse)"], ["", "lemma neg_numeral_uint8 [code_unfold]: \"- numeral n = Uint8 (- numeral n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - numeral n = Uint8 (- numeral n)", "by transfer(simp add: cr_uint8_def)"], ["", "end"], ["", "lemma Abs_uint8_numeral [code_post]: \"Abs_uint8 (numeral n) = numeral n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_uint8 (numeral n) = numeral n", "by(induction n)(simp_all add: one_uint8_def numeral.simps plus_uint8_def Abs_uint8_inverse)"], ["", "lemma Abs_uint8_0 [code_post]: \"Abs_uint8 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_uint8 0 = 0", "by(simp add: zero_uint8_def)"], ["", "lemma Abs_uint8_1 [code_post]: \"Abs_uint8 1 = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_uint8 1 = 1", "by(simp add: one_uint8_def)"], ["", "section \\<open>Code setup\\<close>"], ["", "code_printing code_module Uint8 \\<rightharpoonup> (SML)\n\\<open>(* Test that words can handle numbers between 0 and 3 *)\nval _ = if 3 <= Word.wordSize then () else raise (Fail (\"wordSize less than 3\"));\n\nstructure Uint8 : sig\n  val set_bit : Word8.word -> IntInf.int -> bool -> Word8.word\n  val shiftl : Word8.word -> IntInf.int -> Word8.word\n  val shiftr : Word8.word -> IntInf.int -> Word8.word\n  val shiftr_signed : Word8.word -> IntInf.int -> Word8.word\n  val test_bit : Word8.word -> IntInf.int -> bool\nend = struct\n\nfun set_bit x n b =\n  let val mask = Word8.<< (0wx1, Word.fromLargeInt (IntInf.toLarge n))\n  in if b then Word8.orb (x, mask)\n     else Word8.andb (x, Word8.notb mask)\n  end\n\nfun shiftl x n =\n  Word8.<< (x, Word.fromLargeInt (IntInf.toLarge n))\n\nfun shiftr x n =\n  Word8.>> (x, Word.fromLargeInt (IntInf.toLarge n))\n\nfun shiftr_signed x n =\n  Word8.~>> (x, Word.fromLargeInt (IntInf.toLarge n))\n\nfun test_bit x n =\n  Word8.andb (x, Word8.<< (0wx1, Word.fromLargeInt (IntInf.toLarge n))) <> Word8.fromInt 0\n\nend; (* struct Uint8 *)\\<close>"], ["", "code_reserved SML Uint8"], ["", "code_printing code_module Uint8 \\<rightharpoonup> (Haskell)\n \\<open>module Uint8(Int8, Word8) where\n\n  import Data.Int(Int8)\n  import Data.Word(Word8)\\<close>"], ["", "code_reserved Haskell Uint8"], ["", "text \\<open>\n  Scala provides only signed 8bit numbers, so we use these and \n  implement sign-sensitive operations like comparisons manually.\n\\<close>"], ["", "code_printing code_module Uint8 \\<rightharpoonup> (Scala)\n\\<open>object Uint8 {\n\ndef less(x: Byte, y: Byte) : Boolean =\n  if (x < 0) y < 0 && x < y\n  else y < 0 || x < y\n\ndef less_eq(x: Byte, y: Byte) : Boolean =\n  if (x < 0) y < 0 && x <= y\n  else y < 0 || x <= y\n\ndef set_bit(x: Byte, n: BigInt, b: Boolean) : Byte =\n  if (b)\n    (x | (1 << n.intValue)).toByte\n  else\n    (x & (1 << n.intValue).unary_~).toByte\n\ndef shiftl(x: Byte, n: BigInt) : Byte = (x << n.intValue).toByte\n\ndef shiftr(x: Byte, n: BigInt) : Byte = ((x & 255) >>> n.intValue).toByte\n\ndef shiftr_signed(x: Byte, n: BigInt) : Byte = (x >> n.intValue).toByte\n\ndef test_bit(x: Byte, n: BigInt) : Boolean =\n  (x & (1 << n.intValue)) != 0\n\n} /* object Uint8 */\\<close>"], ["", "code_reserved Scala Uint8"], ["", "text \\<open>\n  Avoid @{term Abs_uint8} in generated code, use @{term Rep_uint8'} instead. \n  The symbolic implementations for code\\_simp use @{term Rep_uint8}.\n\n  The new destructor @{term Rep_uint8'} is executable.\n  As the simplifier is given the [code abstract] equations literally, \n  we cannot implement @{term Rep_uint8} directly, because that makes code\\_simp loop.\n\n  If code generation raises Match, some equation probably contains @{term Rep_uint8} \n  ([code abstract] equations for @{typ uint8} may use @{term Rep_uint8} because\n  these instances will be folded away.)\n\n  To convert @{typ \"8 word\"} values into @{typ uint8}, use @{term \"Abs_uint8'\"}.\n\\<close>"], ["", "definition Rep_uint8' where [simp]: \"Rep_uint8' = Rep_uint8\""], ["", "lemma Rep_uint8'_transfer [transfer_rule]:\n  \"rel_fun cr_uint8 (=) (\\<lambda>x. x) Rep_uint8'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_fun cr_uint8 (=) (\\<lambda>x. x) Rep_uint8'", "unfolding Rep_uint8'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_fun cr_uint8 (=) (\\<lambda>x. x) Rep_uint8", "by(rule uint8.rep_transfer)"], ["", "lemma Rep_uint8'_code [code]: \"Rep_uint8' x = (BITS n. bit x n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_uint8' x = (BITS n. bit x n)", "by transfer (simp add: set_bits_bit_eq)"], ["", "lift_definition Abs_uint8' :: \"8 word \\<Rightarrow> uint8\" is \"\\<lambda>x :: 8 word. x\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma Abs_uint8'_code [code]: \"Abs_uint8' x = Uint8 (integer_of_int (uint x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_uint8' x = Uint8 (integer_of_int (uint x))", "including integer.lifting"], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_uint8' x = Uint8 (integer_of_int (uint x))", "by transfer simp"], ["", "declare [[code drop: \"term_of_class.term_of :: uint8 \\<Rightarrow> _\"]]"], ["", "lemma term_of_uint8_code [code]:\n  defines \"TR \\<equiv> typerep.Typerep\" and \"bit0 \\<equiv> STR ''Numeral_Type.bit0''\" shows\n  \"term_of_class.term_of x = \n   Code_Evaluation.App (Code_Evaluation.Const (STR ''Uint8.uint8.Abs_uint8'') (TR (STR ''fun'') [TR (STR ''Word.word'') [TR bit0 [TR bit0 [TR bit0 [TR (STR ''Numeral_Type.num1'') []]]]], TR (STR ''Uint8.uint8'') []]))\n       (term_of_class.term_of (Rep_uint8' x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. term_of_class.term_of x =\n    Code_Evaluation.App\n     (Code_Evaluation.Const STR ''Uint8.uint8.Abs_uint8''\n       (TR STR ''fun''\n         [TR STR ''Word.word''\n           [TR bit0 [TR bit0 [TR bit0 [TR STR ''Numeral_Type.num1'' []]]]],\n          TR STR ''Uint8.uint8'' []]))\n     (term_of_class.term_of (Rep_uint8' x))", "by(simp add: term_of_anything)"], ["", "lemma Uin8_code [code abstract]: \"Rep_uint8 (Uint8 i) = word_of_int (int_of_integer_symbolic i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_uint8 (Uint8 i) = word_of_int (int_of_integer_symbolic i)", "unfolding Uint8_def int_of_integer_symbolic_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_uint8 (map_fun int_of_integer Abs_uint8 word_of_int i) =\n    word_of_int (int_of_integer i)", "by(simp add: Abs_uint8_inverse)"], ["", "code_printing type_constructor uint8 \\<rightharpoonup>\n  (SML) \"Word8.word\" and\n  (Haskell) \"Uint8.Word8\" and\n  (Scala) \"Byte\"\n| constant Uint8 \\<rightharpoonup> \n  (SML) \"Word8.fromLargeInt (IntInf.toLarge _)\" and\n  (Haskell) \"(Prelude.fromInteger _ :: Uint8.Word8)\" and\n  (Haskell_Quickcheck) \"(Prelude.fromInteger (Prelude.toInteger _) :: Uint8.Word8)\" and\n  (Scala) \"_.byteValue\"\n| constant \"0 :: uint8\" \\<rightharpoonup>\n  (SML) \"(Word8.fromInt 0)\" and\n  (Haskell) \"(0 :: Uint8.Word8)\" and\n  (Scala) \"0.toByte\"\n| constant \"1 :: uint8\" \\<rightharpoonup>\n  (SML) \"(Word8.fromInt 1)\" and\n  (Haskell) \"(1 :: Uint8.Word8)\" and\n  (Scala) \"1.toByte\"\n| constant \"plus :: uint8 \\<Rightarrow> _ \\<Rightarrow> _\" \\<rightharpoonup>\n  (SML) \"Word8.+ ((_), (_))\" and\n  (Haskell) infixl 6 \"+\" and\n  (Scala) \"(_ +/ _).toByte\"\n| constant \"uminus :: uint8 \\<Rightarrow> _\" \\<rightharpoonup>\n  (SML) \"Word8.~\" and\n  (Haskell) \"negate\" and\n  (Scala) \"(- _).toByte\"\n| constant \"minus :: uint8 \\<Rightarrow> _\" \\<rightharpoonup>\n  (SML) \"Word8.- ((_), (_))\" and\n  (Haskell) infixl 6 \"-\" and\n  (Scala) \"(_ -/ _).toByte\"\n| constant \"times :: uint8 \\<Rightarrow> _ \\<Rightarrow> _\" \\<rightharpoonup>\n  (SML) \"Word8.* ((_), (_))\" and\n  (Haskell) infixl 7 \"*\" and\n  (Scala) \"(_ */ _).toByte\"\n| constant \"HOL.equal :: uint8 \\<Rightarrow> _ \\<Rightarrow> bool\" \\<rightharpoonup>\n  (SML) \"!((_ : Word8.word) = _)\" and\n  (Haskell) infix 4 \"==\" and\n  (Scala) infixl 5 \"==\"\n| class_instance uint8 :: equal \\<rightharpoonup> (Haskell) -\n| constant \"less_eq :: uint8 \\<Rightarrow> _ \\<Rightarrow> bool\" \\<rightharpoonup>\n  (SML) \"Word8.<= ((_), (_))\" and\n  (Haskell) infix 4 \"<=\" and\n  (Scala) \"Uint8.less'_eq\"\n| constant \"less :: uint8 \\<Rightarrow> _ \\<Rightarrow> bool\" \\<rightharpoonup>\n  (SML) \"Word8.< ((_), (_))\" and\n  (Haskell) infix 4 \"<\" and\n  (Scala) \"Uint8.less\"\n| constant \"NOT :: uint8 \\<Rightarrow> _\" \\<rightharpoonup>\n  (SML) \"Word8.notb\" and\n  (Haskell) \"Data'_Bits.complement\" and\n  (Scala) \"_.unary'_~.toByte\"\n| constant \"(AND) :: uint8 \\<Rightarrow> _\" \\<rightharpoonup>\n  (SML) \"Word8.andb ((_),/ (_))\" and\n  (Haskell) infixl 7 \"Data_Bits..&.\" and\n  (Scala) \"(_ & _).toByte\"\n| constant \"(OR) :: uint8 \\<Rightarrow> _\" \\<rightharpoonup>\n  (SML) \"Word8.orb ((_),/ (_))\" and\n  (Haskell) infixl 5 \"Data_Bits..|.\" and\n  (Scala) \"(_ | _).toByte\"\n| constant \"(XOR) :: uint8 \\<Rightarrow> _\" \\<rightharpoonup>\n  (SML) \"Word8.xorb ((_),/ (_))\" and\n  (Haskell) \"Data'_Bits.xor\" and\n  (Scala) \"(_ ^ _).toByte\""], ["", "definition uint8_divmod :: \"uint8 \\<Rightarrow> uint8 \\<Rightarrow> uint8 \\<times> uint8\" where\n  \"uint8_divmod x y = \n  (if y = 0 then (undefined ((div) :: uint8 \\<Rightarrow> _) x (0 :: uint8), undefined ((mod) :: uint8 \\<Rightarrow> _) x (0 :: uint8)) \n  else (x div y, x mod y))\""], ["", "definition uint8_div :: \"uint8 \\<Rightarrow> uint8 \\<Rightarrow> uint8\" \nwhere \"uint8_div x y = fst (uint8_divmod x y)\""], ["", "definition uint8_mod :: \"uint8 \\<Rightarrow> uint8 \\<Rightarrow> uint8\" \nwhere \"uint8_mod x y = snd (uint8_divmod x y)\""], ["", "lemma div_uint8_code [code]: \"x div y = (if y = 0 then 0 else uint8_div x y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x div y = (if y = 0 then 0 else uint8_div x y)", "including undefined_transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. x div y = (if y = 0 then 0 else uint8_div x y)", "unfolding uint8_divmod_def uint8_div_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. x div y =\n    (if y = 0 then 0\n     else fst (if y = 0 then (undefined (div) x 0, undefined (mod) x 0)\n               else (x div y, x mod y)))", "by transfer (simp add: word_div_def)"], ["", "lemma mod_uint8_code [code]: \"x mod y = (if y = 0 then x else uint8_mod x y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x mod y = (if y = 0 then x else uint8_mod x y)", "including undefined_transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. x mod y = (if y = 0 then x else uint8_mod x y)", "unfolding uint8_mod_def uint8_divmod_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. x mod y =\n    (if y = 0 then x\n     else snd (if y = 0 then (undefined (div) x 0, undefined (mod) x 0)\n               else (x div y, x mod y)))", "by transfer (simp add: word_mod_def)"], ["", "definition uint8_sdiv :: \"uint8 \\<Rightarrow> uint8 \\<Rightarrow> uint8\"\nwhere\n  \"uint8_sdiv x y =\n   (if y = 0 then undefined ((div) :: uint8 \\<Rightarrow> _) x (0 :: uint8)\n    else Abs_uint8 (Rep_uint8 x sdiv Rep_uint8 y))\""], ["", "definition div0_uint8 :: \"uint8 \\<Rightarrow> uint8\"\nwhere [code del]: \"div0_uint8 x = undefined ((div) :: uint8 \\<Rightarrow> _) x (0 :: uint8)\""], ["", "declare [[code abort: div0_uint8]]"], ["", "definition mod0_uint8 :: \"uint8 \\<Rightarrow> uint8\"\nwhere [code del]: \"mod0_uint8 x = undefined ((mod) :: uint8 \\<Rightarrow> _) x (0 :: uint8)\""], ["", "declare [[code abort: mod0_uint8]]"], ["", "lemma uint8_divmod_code [code]:\n  \"uint8_divmod x y =\n  (if 0x80 \\<le> y then if x < y then (0, x) else (1, x - y)\n   else if y = 0 then (div0_uint8 x, mod0_uint8 x)\n   else let q = (uint8_sdiv (x >> 1) y) << 1;\n            r = x - q * y\n        in if r \\<ge> y then (q + 1, r - y) else (q, r))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. uint8_divmod x y =\n    (if 128 \\<le> y then if x < y then (0, x) else (1, x - y)\n     else if y = 0 then (div0_uint8 x, mod0_uint8 x)\n          else let q = uint8_sdiv (x >> 1) y << 1; r = x - q * y\n               in if y \\<le> r then (q + 1, r - y) else (q, r))", "including undefined_transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. uint8_divmod x y =\n    (if 128 \\<le> y then if x < y then (0, x) else (1, x - y)\n     else if y = 0 then (div0_uint8 x, mod0_uint8 x)\n          else let q = uint8_sdiv (x >> 1) y << 1; r = x - q * y\n               in if y \\<le> r then (q + 1, r - y) else (q, r))", "unfolding uint8_divmod_def uint8_sdiv_def div0_uint8_def mod0_uint8_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if y = 0 then (undefined (div) x 0, undefined (mod) x 0)\n     else (x div y, x mod y)) =\n    (if 128 \\<le> y then if x < y then (0, x) else (1, x - y)\n     else if y = 0 then (undefined (div) x 0, undefined (mod) x 0)\n          else let q = (if y = 0 then undefined (div) (x >> 1) 0\n                        else Abs_uint8\n                              (Rep_uint8 (x >> 1) sdiv Rep_uint8 y)) <<\n                       1;\n                   r = x - q * y\n               in if y \\<le> r then (q + 1, r - y) else (q, r))", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y x.\n       (if y = 0\n        then (map_fun (map_fun Rep_uint8 (map_fun Rep_uint8 Abs_uint8))\n               (map_fun Abs_uint8 (map_fun Abs_uint8 Rep_uint8)) undefined\n               (div) x 0,\n              map_fun (map_fun Rep_uint8 (map_fun Rep_uint8 Abs_uint8))\n               (map_fun Abs_uint8 (map_fun Abs_uint8 Rep_uint8)) undefined\n               (mod) x 0)\n        else (x div y, x mod y)) =\n       (if 128 \\<le> y then if x < y then (0, x) else (1, x - y)\n        else if y = 0\n             then (map_fun (map_fun Rep_uint8 (map_fun Rep_uint8 Abs_uint8))\n                    (map_fun Abs_uint8 (map_fun Abs_uint8 Rep_uint8))\n                    undefined (div) x 0,\n                   map_fun (map_fun Rep_uint8 (map_fun Rep_uint8 Abs_uint8))\n                    (map_fun Abs_uint8 (map_fun Abs_uint8 Rep_uint8))\n                    undefined (mod) x 0)\n             else let q = push_bit 1\n                           (if y = 0\n                            then map_fun\n                                  (map_fun Rep_uint8\n                                    (map_fun Rep_uint8 Abs_uint8))\n                                  (map_fun Abs_uint8\n                                    (map_fun Abs_uint8 Rep_uint8))\n                                  undefined (div) (drop_bit 1 x) 0\n                            else drop_bit 1 x sdiv y);\n                      r = x - q * y\n                  in if y \\<le> r then (q + 1, r - y) else (q, r))", "apply (simp add: divmod_via_sdivmod)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y x.\n       y \\<noteq> 0 \\<longrightarrow>\n       \\<not> 128 \\<le> y \\<longrightarrow>\n       (let q = (x >> Suc 0) sdiv y << Suc 0; r = x - q * y\n        in if y \\<le> r then (q + 1, r - y) else (q, r)) =\n       (let q = drop_bit (Suc 0) x sdiv y * 2; r = x - q * y\n        in if y \\<le> r then (q + 1, r - y) else (q, r))", "apply (simp add: shiftl_eq_push_bit shiftr_eq_drop_bit)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma uint8_sdiv_code [code abstract]:\n  \"Rep_uint8 (uint8_sdiv x y) =\n   (if y = 0 then Rep_uint8 (undefined ((div) :: uint8 \\<Rightarrow> _) x (0 :: uint8))\n    else Rep_uint8 x sdiv Rep_uint8 y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_uint8 (uint8_sdiv x y) =\n    (if y = 0 then Rep_uint8 (undefined (div) x 0)\n     else Rep_uint8 x sdiv Rep_uint8 y)", "unfolding uint8_sdiv_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_uint8\n     (if y = 0 then undefined (div) x 0\n      else Abs_uint8 (Rep_uint8 x sdiv Rep_uint8 y)) =\n    (if y = 0 then Rep_uint8 (undefined (div) x 0)\n     else Rep_uint8 x sdiv Rep_uint8 y)", "by(simp add: Abs_uint8_inverse)"], ["", "text \\<open>\n  Note that we only need a translation for signed division, but not for the remainder\n  because @{thm uint8_divmod_code} computes both with division only.\n\\<close>"], ["", "code_printing\n  constant uint8_div \\<rightharpoonup>\n  (SML) \"Word8.div ((_), (_))\" and\n  (Haskell) \"Prelude.div\"\n| constant uint8_mod \\<rightharpoonup>\n  (SML) \"Word8.mod ((_), (_))\" and\n  (Haskell) \"Prelude.mod\"\n| constant uint8_divmod \\<rightharpoonup>\n  (Haskell) \"divmod\"\n| constant uint8_sdiv \\<rightharpoonup>\n  (Scala) \"(_ '/ _).toByte\""], ["", "definition uint8_test_bit :: \"uint8 \\<Rightarrow> integer \\<Rightarrow> bool\"\nwhere [code del]:\n  \"uint8_test_bit x n =\n  (if n < 0 \\<or> 7 < n then undefined (test_bit :: uint8 \\<Rightarrow> _) x n\n   else x !! (nat_of_integer n))\""], ["", "lemma bit_uint8_code [code]:\n  \"bit x n \\<longleftrightarrow> n < 8 \\<and> uint8_test_bit x (integer_of_nat n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bit x n = (n < 8 \\<and> uint8_test_bit x (integer_of_nat n))", "including undefined_transfer integer.lifting"], ["proof (prove)\ngoal (1 subgoal):\n 1. bit x n = (n < 8 \\<and> uint8_test_bit x (integer_of_nat n))", "unfolding uint8_test_bit_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. bit x n =\n    (n < 8 \\<and>\n     (if integer_of_nat n < 0 \\<or> 7 < integer_of_nat n\n      then undefined (!!) x (integer_of_nat n)\n      else x !! nat_of_integer (integer_of_nat n)))", "by (transfer, simp, transfer, simp)"], ["", "lemma uint8_test_bit_code [code]:\n  \"uint8_test_bit w n =\n  (if n < 0 \\<or> 7 < n then undefined (test_bit :: uint8 \\<Rightarrow> _) w n else Rep_uint8 w !! nat_of_integer n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. uint8_test_bit w n =\n    (if n < 0 \\<or> 7 < n then undefined (!!) w n\n     else Rep_uint8 w !! nat_of_integer n)", "unfolding uint8_test_bit_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if n < 0 \\<or> 7 < n then undefined (!!) w n\n     else w !! nat_of_integer n) =\n    (if n < 0 \\<or> 7 < n then undefined (!!) w n\n     else Rep_uint8 w !! nat_of_integer n)", "by (simp add: bit_uint8.rep_eq test_bit_eq_bit)"], ["", "code_printing constant uint8_test_bit \\<rightharpoonup>\n  (SML) \"Uint8.test'_bit\" and\n  (Haskell) \"Data'_Bits.testBitBounded\" and\n  (Scala) \"Uint8.test'_bit\" and\n  (Eval) \"(fn x => fn i => if i < 0 orelse i >= 8 then raise (Fail \\\"argument to uint8'_test'_bit out of bounds\\\") else Uint8.test'_bit x i)\""], ["", "definition uint8_set_bit :: \"uint8 \\<Rightarrow> integer \\<Rightarrow> bool \\<Rightarrow> uint8\"\nwhere [code del]:\n  \"uint8_set_bit x n b =\n  (if n < 0 \\<or> 7 < n then undefined (set_bit :: uint8 \\<Rightarrow> _) x n b\n   else set_bit x (nat_of_integer n) b)\""], ["", "lemma set_bit_uint8_code [code]:\n  \"set_bit x n b = (if n < 8 then uint8_set_bit x (integer_of_nat n) b else x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_bit_class.set_bit x n b =\n    (if n < 8 then uint8_set_bit x (integer_of_nat n) b else x)", "including undefined_transfer integer.lifting"], ["proof (prove)\ngoal (1 subgoal):\n 1. set_bit_class.set_bit x n b =\n    (if n < 8 then uint8_set_bit x (integer_of_nat n) b else x)", "unfolding uint8_set_bit_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. set_bit_class.set_bit x n b =\n    (if n < 8\n     then if integer_of_nat n < 0 \\<or> 7 < integer_of_nat n\n          then undefined set_bit_class.set_bit x (integer_of_nat n) b\n          else set_bit_class.set_bit x (nat_of_integer (integer_of_nat n)) b\n     else x)", "by(transfer)(auto cong: conj_cong simp add: not_less set_bit_beyond word_size)"], ["", "lemma uint8_set_bit_code [code abstract]:\n  \"Rep_uint8 (uint8_set_bit w n b) = \n  (if n < 0 \\<or> 7 < n then Rep_uint8 (undefined (set_bit :: uint8 \\<Rightarrow> _) w n b)\n   else set_bit (Rep_uint8 w) (nat_of_integer n) b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_uint8 (uint8_set_bit w n b) =\n    (if n < 0 \\<or> 7 < n\n     then Rep_uint8 (undefined set_bit_class.set_bit w n b)\n     else set_bit_class.set_bit (Rep_uint8 w) (nat_of_integer n) b)", "including undefined_transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_uint8 (uint8_set_bit w n b) =\n    (if n < 0 \\<or> 7 < n\n     then Rep_uint8 (undefined set_bit_class.set_bit w n b)\n     else set_bit_class.set_bit (Rep_uint8 w) (nat_of_integer n) b)", "unfolding uint8_set_bit_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_uint8\n     (if n < 0 \\<or> 7 < n then undefined set_bit_class.set_bit w n b\n      else set_bit_class.set_bit w (nat_of_integer n) b) =\n    (if n < 0 \\<or> 7 < n\n     then Rep_uint8 (undefined set_bit_class.set_bit w n b)\n     else set_bit_class.set_bit (Rep_uint8 w) (nat_of_integer n) b)", "by transfer simp"], ["", "code_printing constant uint8_set_bit \\<rightharpoonup>\n  (SML) \"Uint8.set'_bit\" and\n  (Haskell) \"Data'_Bits.setBitBounded\" and\n  (Scala) \"Uint8.set'_bit\" and\n  (Eval) \"(fn x => fn i => fn b => if i < 0 orelse i >= 8 then raise (Fail \\\"argument to uint8'_set'_bit out of bounds\\\") else Uint8.set'_bit x i b)\""], ["", "lift_definition uint8_set_bits :: \"(nat \\<Rightarrow> bool) \\<Rightarrow> uint8 \\<Rightarrow> nat \\<Rightarrow> uint8\" is set_bits_aux"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma uint8_set_bits_code [code]:\n  \"uint8_set_bits f w n =\n  (if n = 0 then w \n   else let n' = n - 1 in uint8_set_bits f (push_bit 1 w OR (if f n' then 1 else 0)) n')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. uint8_set_bits f w n =\n    (if n = 0 then w\n     else let n' = n - 1\n          in uint8_set_bits f (push_bit 1 w OR (if f n' then 1 else 0)) n')", "apply (transfer fixing: n)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f w.\n       set_bits_aux f w n =\n       (if n = 0 then w\n        else let n' = n - 1\n             in set_bits_aux f (push_bit 1 w OR (if f n' then 1 else 0)) n')", "apply (cases n)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>f w.\n       n = 0 \\<Longrightarrow>\n       set_bits_aux f w n =\n       (if n = 0 then w\n        else let n' = n - 1\n             in set_bits_aux f (push_bit 1 w OR (if f n' then 1 else 0)) n')\n 2. \\<And>f w nat.\n       n = Suc nat \\<Longrightarrow>\n       set_bits_aux f w n =\n       (if n = 0 then w\n        else let n' = n - 1\n             in set_bits_aux f (push_bit 1 w OR (if f n' then 1 else 0)) n')", "apply (simp_all add: shiftl_eq_push_bit)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma set_bits_uint8 [code]:\n  \"(BITS n. f n) = uint8_set_bits f 0 8\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (BITS n. f n) = uint8_set_bits f 0 8", "by transfer(simp add: set_bits_conv_set_bits_aux)"], ["", "lemma lsb_code [code]: fixes x :: uint8 shows \"lsb x = x !! 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lsb x = x !! 0", "by transfer (simp add: lsb_odd)"], ["", "definition uint8_shiftl :: \"uint8 \\<Rightarrow> integer \\<Rightarrow> uint8\"\nwhere [code del]:\n  \"uint8_shiftl x n = (if n < 0 \\<or> 8 \\<le> n then undefined (push_bit :: nat \\<Rightarrow> uint8 \\<Rightarrow> _) x n else push_bit (nat_of_integer n) x)\""], ["", "lemma shiftl_uint8_code [code]:\n  \"push_bit n x = (if n < 8 then uint8_shiftl x (integer_of_nat n) else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. push_bit n x = (if n < 8 then uint8_shiftl x (integer_of_nat n) else 0)", "including undefined_transfer integer.lifting"], ["proof (prove)\ngoal (1 subgoal):\n 1. push_bit n x = (if n < 8 then uint8_shiftl x (integer_of_nat n) else 0)", "unfolding uint8_shiftl_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. push_bit n x =\n    (if n < 8\n     then if integer_of_nat n < 0 \\<or> 8 \\<le> integer_of_nat n\n          then undefined push_bit x (integer_of_nat n)\n          else push_bit (nat_of_integer (integer_of_nat n)) x\n     else 0)", "by transfer simp"], ["", "lemma uint8_shiftl_code [code abstract]:\n  \"Rep_uint8 (uint8_shiftl w n) =\n  (if n < 0 \\<or> 8 \\<le> n then Rep_uint8 (undefined (push_bit :: nat \\<Rightarrow> uint8 \\<Rightarrow> _) w n)\n   else push_bit (nat_of_integer n) (Rep_uint8 w))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_uint8 (uint8_shiftl w n) =\n    (if n < 0 \\<or> 8 \\<le> n then Rep_uint8 (undefined push_bit w n)\n     else push_bit (nat_of_integer n) (Rep_uint8 w))", "including undefined_transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_uint8 (uint8_shiftl w n) =\n    (if n < 0 \\<or> 8 \\<le> n then Rep_uint8 (undefined push_bit w n)\n     else push_bit (nat_of_integer n) (Rep_uint8 w))", "unfolding uint8_shiftl_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_uint8\n     (if n < 0 \\<or> 8 \\<le> n then undefined push_bit w n\n      else push_bit (nat_of_integer n) w) =\n    (if n < 0 \\<or> 8 \\<le> n then Rep_uint8 (undefined push_bit w n)\n     else push_bit (nat_of_integer n) (Rep_uint8 w))", "by transfer simp"], ["", "code_printing constant uint8_shiftl \\<rightharpoonup>\n  (SML) \"Uint8.shiftl\" and\n  (Haskell) \"Data'_Bits.shiftlBounded\" and\n  (Scala) \"Uint8.shiftl\" and\n  (Eval) \"(fn x => fn i => if i < 0 orelse i >= 8 then raise (Fail \\\"argument to uint8'_shiftl out of bounds\\\") else Uint8.shiftl x i)\""], ["", "definition uint8_shiftr :: \"uint8 \\<Rightarrow> integer \\<Rightarrow> uint8\"\nwhere [code del]:\n  \"uint8_shiftr x n = (if n < 0 \\<or> 8 \\<le> n then undefined (shiftr :: uint8 \\<Rightarrow> _) x n else x >> (nat_of_integer n))\""], ["", "lemma shiftr_uint8_code [code]:\n  \"drop_bit n x = (if n < 8 then uint8_shiftr x (integer_of_nat n) else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. drop_bit n x = (if n < 8 then uint8_shiftr x (integer_of_nat n) else 0)", "including undefined_transfer integer.lifting"], ["proof (prove)\ngoal (1 subgoal):\n 1. drop_bit n x = (if n < 8 then uint8_shiftr x (integer_of_nat n) else 0)", "unfolding uint8_shiftr_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. drop_bit n x =\n    (if n < 8\n     then if integer_of_nat n < 0 \\<or> 8 \\<le> integer_of_nat n\n          then undefined (>>) x (integer_of_nat n)\n          else x >> nat_of_integer (integer_of_nat n)\n     else 0)", "by transfer simp"], ["", "lemma uint8_shiftr_code [code abstract]:\n  \"Rep_uint8 (uint8_shiftr w n) =\n  (if n < 0 \\<or> 8 \\<le> n then Rep_uint8 (undefined (shiftr :: uint8 \\<Rightarrow> _) w n) \n   else drop_bit (nat_of_integer n) (Rep_uint8 w))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_uint8 (uint8_shiftr w n) =\n    (if n < 0 \\<or> 8 \\<le> n then Rep_uint8 (undefined (>>) w n)\n     else drop_bit (nat_of_integer n) (Rep_uint8 w))", "including undefined_transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_uint8 (uint8_shiftr w n) =\n    (if n < 0 \\<or> 8 \\<le> n then Rep_uint8 (undefined (>>) w n)\n     else drop_bit (nat_of_integer n) (Rep_uint8 w))", "unfolding uint8_shiftr_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_uint8\n     (if n < 0 \\<or> 8 \\<le> n then undefined (>>) w n\n      else w >> nat_of_integer n) =\n    (if n < 0 \\<or> 8 \\<le> n then Rep_uint8 (undefined (>>) w n)\n     else drop_bit (nat_of_integer n) (Rep_uint8 w))", "by transfer simp"], ["", "code_printing constant uint8_shiftr \\<rightharpoonup>\n  (SML) \"Uint8.shiftr\" and\n  (Haskell) \"Data'_Bits.shiftrBounded\" and\n  (Scala) \"Uint8.shiftr\" and\n  (Eval) \"(fn x => fn i => if i < 0 orelse i >= 8 then raise (Fail \\\"argument to uint8'_shiftr out of bounds\\\") else Uint8.shiftr x i)\""], ["", "definition uint8_sshiftr :: \"uint8 \\<Rightarrow> integer \\<Rightarrow> uint8\"\nwhere [code del]:\n  \"uint8_sshiftr x n =\n  (if n < 0 \\<or> 8 \\<le> n then undefined sshiftr_uint8 x n else sshiftr_uint8 x (nat_of_integer n))\""], ["", "lemma sshiftr_uint8_code [code]:\n  \"x >>> n = \n  (if n < 8 then uint8_sshiftr x (integer_of_nat n) else if x !! 7 then -1 else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x >>> n =\n    (if n < 8 then uint8_sshiftr x (integer_of_nat n)\n     else if x !! 7 then - 1 else 0)", "including undefined_transfer integer.lifting"], ["proof (prove)\ngoal (1 subgoal):\n 1. x >>> n =\n    (if n < 8 then uint8_sshiftr x (integer_of_nat n)\n     else if x !! 7 then - 1 else 0)", "unfolding uint8_sshiftr_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. x >>> n =\n    (if n < 8\n     then if integer_of_nat n < 0 \\<or> 8 \\<le> integer_of_nat n\n          then undefined (>>>) x (integer_of_nat n)\n          else x >>> nat_of_integer (integer_of_nat n)\n     else if x !! 7 then - 1 else 0)", "by transfer (simp add: not_less signed_drop_bit_beyond word_size)"], ["", "lemma uint8_sshiftr_code [code abstract]:\n  \"Rep_uint8 (uint8_sshiftr w n) =\n  (if n < 0 \\<or> 8 \\<le> n then Rep_uint8 (undefined sshiftr_uint8 w n)\n   else signed_drop_bit (nat_of_integer n) (Rep_uint8 w))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_uint8 (uint8_sshiftr w n) =\n    (if n < 0 \\<or> 8 \\<le> n then Rep_uint8 (undefined (>>>) w n)\n     else signed_drop_bit (nat_of_integer n) (Rep_uint8 w))", "including undefined_transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_uint8 (uint8_sshiftr w n) =\n    (if n < 0 \\<or> 8 \\<le> n then Rep_uint8 (undefined (>>>) w n)\n     else signed_drop_bit (nat_of_integer n) (Rep_uint8 w))", "unfolding uint8_sshiftr_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_uint8\n     (if n < 0 \\<or> 8 \\<le> n then undefined (>>>) w n\n      else w >>> nat_of_integer n) =\n    (if n < 0 \\<or> 8 \\<le> n then Rep_uint8 (undefined (>>>) w n)\n     else signed_drop_bit (nat_of_integer n) (Rep_uint8 w))", "by transfer simp"], ["", "code_printing constant uint8_sshiftr \\<rightharpoonup>\n  (SML) \"Uint8.shiftr'_signed\" and\n  (Haskell) \n    \"(Prelude.fromInteger (Prelude.toInteger (Data'_Bits.shiftrBounded (Prelude.fromInteger (Prelude.toInteger _) :: Uint8.Int8) _)) :: Uint8.Word8)\" and\n  (Scala) \"Uint8.shiftr'_signed\" and\n  (Eval) \"(fn x => fn i => if i < 0 orelse i >= 8 then raise (Fail \\\"argument to uint8'_sshiftr out of bounds\\\") else Uint8.shiftr'_signed x i)\""], ["", "lemma uint8_msb_test_bit: \"msb x \\<longleftrightarrow> (x :: uint8) !! 7\""], ["proof (prove)\ngoal (1 subgoal):\n 1. msb x = x !! 7", "by transfer (simp add: msb_word_iff_bit)"], ["", "lemma msb_uint16_code [code]: \"msb x \\<longleftrightarrow> uint8_test_bit x 7\""], ["proof (prove)\ngoal (1 subgoal):\n 1. msb x = uint8_test_bit x 7", "by (simp add: uint8_test_bit_def uint8_msb_test_bit)"], ["", "lemma uint8_of_int_code [code]: \"uint8_of_int i = Uint8 (integer_of_int i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. uint8_of_int i = Uint8 (integer_of_int i)", "including integer.lifting"], ["proof (prove)\ngoal (1 subgoal):\n 1. uint8_of_int i = Uint8 (integer_of_int i)", "by transfer simp"], ["", "lemma int_of_uint8_code [code]:\n  \"int_of_uint8 x = int_of_integer (integer_of_uint8 x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int_of_uint8 x = int_of_integer (integer_of_uint8 x)", "by(simp add: integer_of_uint8_def)"], ["", "lemma nat_of_uint8_code [code]:\n  \"nat_of_uint8 x = nat_of_integer (integer_of_uint8 x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nat_of_uint8 x = nat_of_integer (integer_of_uint8 x)", "unfolding integer_of_uint8_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. nat_of_uint8 x =\n    nat_of_integer ((integer_of_int \\<circ> int_of_uint8) x)", "including integer.lifting"], ["proof (prove)\ngoal (1 subgoal):\n 1. nat_of_uint8 x =\n    nat_of_integer ((integer_of_int \\<circ> int_of_uint8) x)", "by transfer simp"], ["", "definition integer_of_uint8_signed :: \"uint8 \\<Rightarrow> integer\"\nwhere\n  \"integer_of_uint8_signed n = (if n !! 7 then undefined integer_of_uint8 n else integer_of_uint8 n)\""], ["", "lemma integer_of_uint8_signed_code [code]:\n  \"integer_of_uint8_signed n =\n  (if bit n 7 then undefined integer_of_uint8 n else integer_of_int (uint (Rep_uint8' n)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. integer_of_uint8_signed n =\n    (if bit n 7 then undefined integer_of_uint8 n\n     else integer_of_int (uint (Rep_uint8' n)))", "unfolding integer_of_uint8_signed_def integer_of_uint8_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if n !! 7 then undefined (integer_of_int \\<circ> int_of_uint8) n\n     else (integer_of_int \\<circ> int_of_uint8) n) =\n    (if bit n 7 then undefined (integer_of_int \\<circ> int_of_uint8) n\n     else integer_of_int (uint (Rep_uint8' n)))", "including undefined_transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if n !! 7 then undefined (integer_of_int \\<circ> int_of_uint8) n\n     else (integer_of_int \\<circ> int_of_uint8) n) =\n    (if bit n 7 then undefined (integer_of_int \\<circ> int_of_uint8) n\n     else integer_of_int (uint (Rep_uint8' n)))", "by transfer simp"], ["", "lemma integer_of_uint8_code [code]:\n  \"integer_of_uint8 n =\n  (if bit n 7 then integer_of_uint8_signed (n AND 0x7F) OR 0x80 else integer_of_uint8_signed n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. integer_of_uint8 n =\n    (if bit n 7 then integer_of_uint8_signed (n AND 127) OR 128\n     else integer_of_uint8_signed n)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. integer_of_uint8 n =\n    (if bit n 7 then integer_of_uint8_signed (n AND 127) OR 128\n     else integer_of_uint8_signed n)", "have \\<open>(0x7F :: uint8) = mask 7\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. 127 = mask 7", "by (simp add: mask_eq_exp_minus_1)"], ["proof (state)\nthis:\n  127 = mask 7\n\ngoal (1 subgoal):\n 1. integer_of_uint8 n =\n    (if bit n 7 then integer_of_uint8_signed (n AND 127) OR 128\n     else integer_of_uint8_signed n)", "then"], ["proof (chain)\npicking this:\n  127 = mask 7", "have *: \\<open>n AND 0x7F = take_bit 7 n\\<close>"], ["proof (prove)\nusing this:\n  127 = mask 7\n\ngoal (1 subgoal):\n 1. n AND 127 = take_bit 7 n", "by (simp only: take_bit_eq_mask)"], ["proof (state)\nthis:\n  n AND 127 = take_bit 7 n\n\ngoal (1 subgoal):\n 1. integer_of_uint8 n =\n    (if bit n 7 then integer_of_uint8_signed (n AND 127) OR 128\n     else integer_of_uint8_signed n)", "have **: \\<open>(0x80 :: int) = 2 ^ 7\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. 128 = 2 ^ 7", "by simp"], ["proof (state)\nthis:\n  128 = 2 ^ 7\n\ngoal (1 subgoal):\n 1. integer_of_uint8 n =\n    (if bit n 7 then integer_of_uint8_signed (n AND 127) OR 128\n     else integer_of_uint8_signed n)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. integer_of_uint8 n =\n    (if bit n 7 then integer_of_uint8_signed (n AND 127) OR 128\n     else integer_of_uint8_signed n)", "unfolding integer_of_uint8_def integer_of_uint8_signed_def o_def *"], ["proof (prove)\ngoal (1 subgoal):\n 1. integer_of_int (int_of_uint8 n) =\n    (if bit n 7\n     then (if take_bit 7 n !! 7\n           then undefined (\\<lambda>x. integer_of_int (int_of_uint8 x))\n                 (take_bit 7 n)\n           else integer_of_int (int_of_uint8 (take_bit 7 n))) OR\n          128\n     else if n !! 7\n          then undefined (\\<lambda>x. integer_of_int (int_of_uint8 x)) n\n          else integer_of_int (int_of_uint8 n))", "including undefined_transfer integer.lifting"], ["proof (prove)\ngoal (1 subgoal):\n 1. integer_of_int (int_of_uint8 n) =\n    (if bit n 7\n     then (if take_bit 7 n !! 7\n           then undefined (\\<lambda>x. integer_of_int (int_of_uint8 x))\n                 (take_bit 7 n)\n           else integer_of_int (int_of_uint8 (take_bit 7 n))) OR\n          128\n     else if n !! 7\n          then undefined (\\<lambda>x. integer_of_int (int_of_uint8 x)) n\n          else integer_of_int (int_of_uint8 n))", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       uint n =\n       (if bit n 7\n        then (if bit (take_bit 7 n) 7\n              then map_fun (map_fun Rep_uint8 integer_of_int)\n                    (map_fun Abs_uint8 int_of_integer) undefined uint\n                    (take_bit 7 n)\n              else uint (take_bit 7 n)) OR\n             128\n        else if bit n 7\n             then map_fun (map_fun Rep_uint8 integer_of_int)\n                   (map_fun Abs_uint8 int_of_integer) undefined uint n\n             else uint n)", "apply (auto simp add: bit_take_bit_iff uint_take_bit_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n. bit n 7 \\<Longrightarrow> uint n = take_bit 7 (uint n) OR 128", "apply (rule bit_eqI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n na.\n       \\<lbrakk>bit n 7; 2 ^ na \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> bit (uint n) na =\n                         bit (take_bit 7 (uint n) OR 128) na", "apply (simp add: bit_uint_iff bit_or_iff bit_take_bit_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n na.\n       bit n 7 \\<Longrightarrow>\n       (na < 8 \\<and> bit n na) =\n       (na < 7 \\<and> na < 8 \\<and> bit n na \\<or> bit 128 na)", "apply (simp only: ** bit_exp_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n na.\n       bit n 7 \\<Longrightarrow>\n       (na < 8 \\<and> bit n na) =\n       (na < 7 \\<and> na < 8 \\<and> bit n na \\<or>\n        2 ^ 7 \\<noteq> 0 \\<and> 7 = na)", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  integer_of_uint8 n =\n  (if bit n 7 then integer_of_uint8_signed (n AND 127) OR 128\n   else integer_of_uint8_signed n)\n\ngoal:\nNo subgoals!", "qed"], ["", "code_printing\n  constant \"integer_of_uint8\" \\<rightharpoonup>\n  (SML) \"IntInf.fromLarge (Word8.toLargeInt _)\" and\n  (Haskell) \"Prelude.toInteger\"\n| constant \"integer_of_uint8_signed\" \\<rightharpoonup>\n  (Scala) \"BigInt\""], ["", "section \\<open>Quickcheck setup\\<close>"], ["", "definition uint8_of_natural :: \"natural \\<Rightarrow> uint8\"\nwhere \"uint8_of_natural x \\<equiv> Uint8 (integer_of_natural x)\""], ["", "instantiation uint8 :: \"{random, exhaustive, full_exhaustive}\" begin"], ["", "definition \"random_uint8 \\<equiv> qc_random_cnv uint8_of_natural\""], ["", "definition \"exhaustive_uint8 \\<equiv> qc_exhaustive_cnv uint8_of_natural\""], ["", "definition \"full_exhaustive_uint8 \\<equiv> qc_full_exhaustive_cnv uint8_of_natural\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(uint8, exhaustive_class) &&&\n    OFCLASS(uint8, full_exhaustive_class) &&& OFCLASS(uint8, random_class)", ".."], ["", "end"], ["", "instantiation uint8 :: narrowing begin"], ["", "interpretation quickcheck_narrowing_samples\n  \"\\<lambda>i. let x = Uint8 i in (x, 0xFF - x)\" \"0\"\n  \"Typerep.Typerep (STR ''Uint8.uint8'') []\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "definition \"narrowing_uint8 d = qc_narrowing_drawn_from (narrowing_samples d) d\""], ["", "declare [[code drop: \"partial_term_of :: uint8 itself \\<Rightarrow> _\"]]"], ["", "lemmas partial_term_of_uint8 [code] = partial_term_of_code"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(uint8, narrowing_class)", ".."], ["", "end"], ["", "no_notation sshiftr_uint8 (infixl \">>>\" 55)"], ["", "end"]]}