{"file_name": "/home/qj213/afp-2021-10-22/thys/Native_Word/Native_Cast.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Native_Word", "problem_names": ["lemma integer_of_char_char_of_integer [simp]:\n  \"integer_of_char (char_of_integer x) = x mod 256\"", "lemma char_of_integer_integer_of_char [simp]:\n  \"char_of_integer (integer_of_char x) = x\"", "lemma int_lt_numeral [simp]: \"int x < numeral n \\<longleftrightarrow> x < numeral n\"", "lemma int_of_integer_ge_0: \"0 \\<le> int_of_integer x \\<longleftrightarrow> 0 \\<le> x\"", "lemma integer_of_char_ge_0 [simp]: \"0 \\<le> integer_of_char x\"", "lemma uint8_of_uint16_code [code]:\n  \"uint8_of_uint16 x = Abs_uint8' (ucast (Rep_uint16' x))\"", "lemma uint8_of_uint32_code [code]:\n  \"uint8_of_uint32 x = Abs_uint8' (ucast (Rep_uint32' x))\"", "lemma uint8_of_uint64_code [code]:\n  \"uint8_of_uint64 x = Abs_uint8' (ucast (Rep_uint64' x))\"", "lemma uint16_of_uint8_code [code]:\n  \"uint16_of_uint8 x = Abs_uint16' (ucast (Rep_uint8' x))\"", "lemma uint16_of_uint32_code [code]:\n  \"uint16_of_uint32 x = Abs_uint16' (ucast (Rep_uint32' x))\"", "lemma uint16_of_uint64_code [code]:\n  \"uint16_of_uint64 x = Abs_uint16' (ucast (Rep_uint64' x))\"", "lemma uint32_of_uint8_code [code]:\n  \"uint32_of_uint8 x = Abs_uint32' (ucast (Rep_uint8' x))\"", "lemma uint32_of_uint16_code [code]:\n  \"uint32_of_uint16 x = Abs_uint32' (ucast (Rep_uint16' x))\"", "lemma uint32_of_uint64_code [code]:\n  \"uint32_of_uint64 x = Abs_uint32' (ucast (Rep_uint64' x))\"", "lemma uint64_of_uint8_code [code]:\n  \"uint64_of_uint8 x = Abs_uint64' (ucast (Rep_uint8' x))\"", "lemma uint64_of_uint16_code [code]:\n  \"uint64_of_uint16 x = Abs_uint64' (ucast (Rep_uint16' x))\"", "lemma uint64_of_uint32_code [code]:\n  \"uint64_of_uint32 x = Abs_uint64' (ucast (Rep_uint32' x))\""], "translations": [["", "lemma integer_of_char_char_of_integer [simp]:\n  \"integer_of_char (char_of_integer x) = x mod 256\""], ["proof (prove)\ngoal (1 subgoal):\n 1. integer_of_char (char_of_integer x) = x mod 256", "by (simp add: integer_of_char_def char_of_integer_def)"], ["", "lemma char_of_integer_integer_of_char [simp]:\n  \"char_of_integer (integer_of_char x) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. char_of_integer (integer_of_char x) = x", "by (simp add: integer_of_char_def char_of_integer_def)"], ["", "lemma int_lt_numeral [simp]: \"int x < numeral n \\<longleftrightarrow> x < numeral n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (int x < numeral n) = (x < numeral n)", "by (metis nat_numeral zless_nat_eq_int_zless)"], ["", "lemma int_of_integer_ge_0: \"0 \\<le> int_of_integer x \\<longleftrightarrow> 0 \\<le> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0 \\<le> int_of_integer x) = (0 \\<le> x)", "including integer.lifting"], ["proof (prove)\ngoal (1 subgoal):\n 1. (0 \\<le> int_of_integer x) = (0 \\<le> x)", "by transfer simp"], ["", "lemma integer_of_char_ge_0 [simp]: \"0 \\<le> integer_of_char x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> integer_of_char x", "including integer.lifting"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> integer_of_char x", "unfolding integer_of_char_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> of_char x", "by transfer (simp add: of_char_def)"], ["", "section \\<open>Conversion between native words\\<close>"], ["", "lift_definition uint8_of_uint16 :: \"uint16 \\<Rightarrow> uint8\" is ucast"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition uint8_of_uint32 :: \"uint32 \\<Rightarrow> uint8\" is ucast"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition uint8_of_uint64 :: \"uint64 \\<Rightarrow> uint8\" is ucast"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition uint16_of_uint8 :: \"uint8 \\<Rightarrow> uint16\" is ucast"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition uint16_of_uint32 :: \"uint32 \\<Rightarrow> uint16\" is ucast"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition uint16_of_uint64 :: \"uint64 \\<Rightarrow> uint16\" is ucast"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition uint32_of_uint8 :: \"uint8 \\<Rightarrow> uint32\" is ucast"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition uint32_of_uint16 :: \"uint16 \\<Rightarrow> uint32\" is ucast"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition uint32_of_uint64 :: \"uint64 \\<Rightarrow> uint32\" is ucast"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition uint64_of_uint8 :: \"uint8 \\<Rightarrow> uint64\" is ucast"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition uint64_of_uint16 :: \"uint16 \\<Rightarrow> uint64\" is ucast"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition uint64_of_uint32 :: \"uint32 \\<Rightarrow> uint64\" is ucast"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "context\nbegin"], ["", "qualified"], ["", "definition mask :: integer\n  where \\<open>mask = (0xFFFFFFFF :: integer)\\<close>"], ["", "end"], ["", "code_printing\n  constant uint8_of_uint16 \\<rightharpoonup>\n  (SML_word) \"Word8.fromLarge (Word16.toLarge _)\" and\n  (Haskell) \"(Prelude.fromIntegral _ :: Uint8.Word8)\" and\n  (Scala) \"_.toByte\"\n| constant uint8_of_uint32 \\<rightharpoonup>\n  (SML) \"Word8.fromLarge (Word32.toLarge _)\" and\n  (Haskell) \"(Prelude.fromIntegral _ :: Uint8.Word8)\" and\n  (Scala) \"_.toByte\"\n| constant uint8_of_uint64 \\<rightharpoonup>\n  (SML) \"Word8.fromLarge (Uint64.toLarge _)\" and\n  (Haskell) \"(Prelude.fromIntegral _ :: Uint8.Word8)\" and\n  (Scala) \"_.toByte\"\n| constant uint16_of_uint8 \\<rightharpoonup>\n  (SML_word) \"Word16.fromLarge (Word8.toLarge _)\" and\n  (Haskell) \"(Prelude.fromIntegral _ :: Uint16.Word16)\" and\n  (Scala) \"((_).toInt & 0xFF).toChar\"\n| constant uint16_of_uint32 \\<rightharpoonup>\n  (SML_word) \"Word16.fromLarge (Word32.toLarge _)\" and\n  (Haskell) \"(Prelude.fromIntegral _ :: Uint16.Word16)\" and\n  (Scala) \"_.toChar\"\n| constant uint16_of_uint64 \\<rightharpoonup>\n  (SML_word) \"Word16.fromLarge (Uint64.toLarge _)\" and\n  (Haskell) \"(Prelude.fromIntegral _ :: Uint16.Word16)\" and\n  (Scala) \"_.toChar\"\n| constant uint32_of_uint8 \\<rightharpoonup>\n  (SML) \"Word32.fromLarge (Word8.toLarge _)\" and\n  (Haskell) \"(Prelude.fromIntegral _ :: Uint32.Word32)\" and\n  (Scala) \"((_).toInt & 0xFF)\"\n| constant uint32_of_uint16 \\<rightharpoonup>\n  (SML_word) \"Word32.fromLarge (Word16.toLarge _)\" and\n  (Haskell) \"(Prelude.fromIntegral _ :: Uint32.Word32)\" and\n  (Scala) \"(_).toInt\"\n| constant uint32_of_uint64 \\<rightharpoonup>\n  (SML_word) \"Word32.fromLarge (Uint64.toLarge _)\" and\n  (Haskell) \"(Prelude.fromIntegral _ :: Uint32.Word32)\" and\n  (Scala) \"(_).toInt\" and\n  (OCaml) \"Int64.to'_int32\"\n| constant uint64_of_uint8 \\<rightharpoonup>\n  (SML_word) \"Word64.fromLarge (Word8.toLarge _)\" and\n  (Haskell) \"(Prelude.fromIntegral _ :: Uint64.Word64)\" and\n  (Scala) \"((_).toLong & 0xFF)\"\n| constant uint64_of_uint16 \\<rightharpoonup>\n  (SML_word) \"Word64.fromLarge (Word16.toLarge _)\" and\n  (Haskell) \"(Prelude.fromIntegral _ :: Uint64.Word64)\" and\n  (Scala) \"_.toLong\"\n| constant uint64_of_uint32 \\<rightharpoonup>\n  (SML_word) \"Word64.fromLarge (Word32.toLarge _)\" and\n  (Haskell) \"(Prelude.fromIntegral _ :: Uint64.Word64)\" and\n  (Scala) \"((_).toLong & 0xFFFFFFFFL)\" and\n  (OCaml) \"Int64.logand (Int64.of'_int32 _) (Int64.of'_string \\\"4294967295\\\")\""], ["", "text \\<open>\n  Use @{const Abs_uint8'} etc. instead of @{const Rep_uint8} in code equations\n  for conversion functions to avoid exceptions during code generation when the\n  target language provides only some of the uint types.\n\\<close>"], ["", "lemma uint8_of_uint16_code [code]:\n  \"uint8_of_uint16 x = Abs_uint8' (ucast (Rep_uint16' x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. uint8_of_uint16 x = Abs_uint8' (ucast (Rep_uint16' x))", "by transfer simp"], ["", "lemma uint8_of_uint32_code [code]:\n  \"uint8_of_uint32 x = Abs_uint8' (ucast (Rep_uint32' x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. uint8_of_uint32 x = Abs_uint8' (ucast (Rep_uint32' x))", "by transfer simp"], ["", "lemma uint8_of_uint64_code [code]:\n  \"uint8_of_uint64 x = Abs_uint8' (ucast (Rep_uint64' x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. uint8_of_uint64 x = Abs_uint8' (ucast (Rep_uint64' x))", "by transfer simp"], ["", "lemma uint16_of_uint8_code [code]:\n  \"uint16_of_uint8 x = Abs_uint16' (ucast (Rep_uint8' x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. uint16_of_uint8 x = Abs_uint16' (ucast (Rep_uint8' x))", "by transfer simp"], ["", "lemma uint16_of_uint32_code [code]:\n  \"uint16_of_uint32 x = Abs_uint16' (ucast (Rep_uint32' x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. uint16_of_uint32 x = Abs_uint16' (ucast (Rep_uint32' x))", "by transfer simp"], ["", "lemma uint16_of_uint64_code [code]:\n  \"uint16_of_uint64 x = Abs_uint16' (ucast (Rep_uint64' x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. uint16_of_uint64 x = Abs_uint16' (ucast (Rep_uint64' x))", "by transfer simp"], ["", "lemma uint32_of_uint8_code [code]:\n  \"uint32_of_uint8 x = Abs_uint32' (ucast (Rep_uint8' x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. uint32_of_uint8 x = Abs_uint32' (ucast (Rep_uint8' x))", "by transfer simp"], ["", "lemma uint32_of_uint16_code [code]:\n  \"uint32_of_uint16 x = Abs_uint32' (ucast (Rep_uint16' x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. uint32_of_uint16 x = Abs_uint32' (ucast (Rep_uint16' x))", "by transfer simp"], ["", "lemma uint32_of_uint64_code [code]:\n  \"uint32_of_uint64 x = Abs_uint32' (ucast (Rep_uint64' x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. uint32_of_uint64 x = Abs_uint32' (ucast (Rep_uint64' x))", "by transfer simp"], ["", "lemma uint64_of_uint8_code [code]:\n  \"uint64_of_uint8 x = Abs_uint64' (ucast (Rep_uint8' x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. uint64_of_uint8 x = Abs_uint64' (ucast (Rep_uint8' x))", "by transfer simp"], ["", "lemma uint64_of_uint16_code [code]:\n  \"uint64_of_uint16 x = Abs_uint64' (ucast (Rep_uint16' x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. uint64_of_uint16 x = Abs_uint64' (ucast (Rep_uint16' x))", "by transfer simp"], ["", "lemma uint64_of_uint32_code [code]:\n  \"uint64_of_uint32 x = Abs_uint64' (ucast (Rep_uint32' x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. uint64_of_uint32 x = Abs_uint64' (ucast (Rep_uint32' x))", "by transfer simp"], ["", "end"]]}