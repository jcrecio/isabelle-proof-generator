{"file_name": "/home/qj213/afp-2021-10-22/thys/Native_Word/Uint_Userguide.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Native_Word", "problem_names": ["lemmas [Transfer.transferred, code] =\n  gen_sum_squares.simps\n  sum_squares_def\n  sum_squares_int_def", "lemmas [code, simp] = val.case [Transfer.transferred]", "lemma case_val'_cert:\n  fixes bool word' b w\n  assumes \"CASE \\<equiv> case_val' bool word'\"\n  shows \"(CASE (Bool b) \\<equiv> bool b) &&& (CASE (Word' w) \\<equiv> word' w)\"", "lemmas [code] = \n  val.eq.simps[THEN meta_eq_to_obj_eq, Transfer.transferred, THEN eq_reflection]\n  eval.simps[Transfer.transferred]\n  step.equation[Transfer.transferred]", "lemma double_code [code]: \"double n = n + n\""], "translations": [["", "lemmas [Transfer.transferred, code] =\n  gen_sum_squares.simps\n  sum_squares_def\n  sum_squares_int_def"], ["", "text \\<open>\n  Finally, we export the code to standard ML.  We use the target\n  \\<open>SML_word\\<close> instead of \\<open>SML\\<close> to have the operations\n  on @{typ uint16} mapped to the Standard Basis Library. As PolyML\n  does not provide a Word16 type, the mapping for @{typ uint16} is only\n  active in the refined target \\<open>SML_word\\<close>.\n\\<close>"], ["", "export_code sum_squares_int_uint in SML_word"], ["", "text \\<open>\n  Nevertheless, we can still evaluate terms with @{term \"uint16\"} within \n  Isabelle, i.e., PolyML, but this will be translated to @{typ \"16 word\"}\n  and therefore less efficient.\n\\<close>"], ["", "value \"sum_squares_int_uint 40\""], ["", "section \\<open>Storing native words in datatypes\\<close>"], ["", "text \\<open>\n  The above lifting is necessary for all functions whose type mentions\n  the word type. Fortunately, we do not have to duplicate functions that\n  merely operate on datatypes that contain words. Nevertheless, we have\n  to tell the code generator that these functions should call the new ones,\n  which operate on machine words. This section shows how to achieve this\n  with data refinement.\n\\<close>"], ["", "subsection \\<open>Example: expressions and two semantics\\<close>"], ["", "text \\<open>\n  As the running example, we consider a language of expressions (literal values, less-than comparisions and conditional) where values are either booleans or 32-bit words.\n  The original specification uses the type @{typ \"32 word\"}.\n\\<close>"], ["", "datatype val = Bool bool | Word \"32 word\""], ["", "datatype expr = Lit val | LT expr expr | IF expr expr expr"], ["", "abbreviation (input) word :: \"32 word \\<Rightarrow> expr\" where \"word i \\<equiv> Lit (Word i)\""], ["", "abbreviation (input) bool :: \"bool \\<Rightarrow> expr\" where \"bool i \\<equiv> Lit (Bool i)\"\n\n\\<comment> \\<open>Denotational semantics of expressions, @{term None} denotes a type error\\<close>"], ["", "fun eval :: \"expr \\<Rightarrow> val option\" where\n  \"eval (Lit v) = Some v\"\n| \"eval (LT e\\<^sub>1 e\\<^sub>2) = \n  (case (eval e\\<^sub>1, eval e\\<^sub>2) \n   of (Some (Word i\\<^sub>1), Some (Word i\\<^sub>2)) \\<Rightarrow> Some (Bool (i\\<^sub>1 < i\\<^sub>2))\n   | _ \\<Rightarrow> None)\"\n| \"eval (IF e\\<^sub>1 e\\<^sub>2 e\\<^sub>3) =\n  (case eval e\\<^sub>1 of Some (Bool b) \\<Rightarrow> if b then eval e\\<^sub>2 else eval e\\<^sub>3\n   | _ \\<Rightarrow> None)\"\n\n\\<comment> \\<open>Small-step semantics of expressions, it gets stuck upon type errors.\\<close>"], ["", "inductive step :: \"expr \\<Rightarrow> expr \\<Rightarrow> bool\" (\"_ \\<rightarrow> _\" [50, 50] 60) where\n  \"e \\<rightarrow> e' \\<Longrightarrow> LT e e\\<^sub>2 \\<rightarrow> LT e' e\\<^sub>2\"\n| \"e \\<rightarrow> e' \\<Longrightarrow> LT (word i) e \\<rightarrow> LT (word i) e'\"\n| \"LT (word i\\<^sub>1) (word i\\<^sub>2) \\<rightarrow> bool (i\\<^sub>1 < i\\<^sub>2)\"\n| \"e \\<rightarrow> e' \\<Longrightarrow> IF e e\\<^sub>1 e\\<^sub>2 \\<rightarrow> IF e' e\\<^sub>1 e\\<^sub>2\"\n| \"IF (bool True) e\\<^sub>1 e\\<^sub>2 \\<rightarrow> e\\<^sub>1\"\n| \"IF (bool False) e\\<^sub>1 e\\<^sub>2 \\<rightarrow> e\\<^sub>2\"\n\n\\<comment> \\<open>Compile the inductive definition with the predicate compiler\\<close>"], ["", "code_pred (modes: i \\<Rightarrow> o \\<Rightarrow> bool as reduce, i \\<Rightarrow> i \\<Rightarrow> bool as step') step"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "subsection \\<open>Change the datatype to use machine words\\<close>"], ["", "text \\<open>\n  Now, we want to use @{typ uint32} instead of @{typ \"32 word\"}.\n  The goal is to make the code generator use the new type without\n  duplicating any of the types (@{typ val}, @{typ expr}) or the\n  functions (@{term eval}, @{term reduce}) on such types.\n\n  The constructor @{term Word} has @{typ \"32 word\"} in its type, so\n  we have to lift it to \\<open>Word'\\<close>, and the same holds for the\n  case combinator @{term case_val}, which @{term case_val'} replaces.%\n  \\footnote{%\n    Note that we should not declare a case translation for the new\n    case combinator because this will break parsing case expressions\n    with old case combinator.\n  }\n  Next, we set up the code generator accordingly:\n  @{term Bool} and @{term Word'} are the new constructors for @{typ val},\n  and @{term case_val'} is the new case combinator with an appropriate \n  case certificate.%\n  \\footnote{%\n    Case certificates tell the code generator to replace the HOL\n    case combinator for a datatype with the case combinator of the\n    target language.  Without a case certificate, the code generator\n    generates a function that re-implements the case combinator; \n    in a strict languages like ML or Scala, this means that the code\n    evaluates all possible cases before it decides which one is taken.\n\n    Case certificates are described in Haftmann's PhD thesis\n    \\cite[Def.\\ 27]{Haftmann2009PhD}. For a datatype \\<open>dt\\<close>\n    with constructors \\<open>C\\<^sub>1\\<close> to \\<open>C\\<^sub>n\\<close>\n    where each constructor \\<open>C\\<^sub>i\\<close> takes \\<open>k\\<^sub>i\\<close> parameters,\n    the certificate for the case combinator \\<open>case_dt\\<close>\n    looks as follows:\n\n    {\n      \\isamarkuptrue\\isacommand{lemma}\\isamarkupfalse\\isanewline%\n      \\ \\ \\isakeyword{assumes}\\ {\\isachardoublequoteopen}CASE\\ {\\isasymequiv}\\ dt{\\isacharunderscore}case\\ c\\isactrlsub {\\isadigit{1}}\\ c\\isactrlsub {\\isadigit{2}}\\ \\ldots\\ c\\isactrlsub{n}{\\isachardoublequoteclose}\\isanewline\n      \\ \\ \\isakeyword{shows}\\ {\\isachardoublequoteopen}{\\isacharparenleft}CASE\\ {\\isacharparenleft}C\\isactrlsub {\\isadigit{1}}\\ a\\isactrlsub {\\isadigit{1}}\\isactrlsub {\\isadigit{1}}\\ a\\isactrlsub {\\isadigit{1}}\\isactrlsub {\\isadigit{2}}\\ \\ldots\\ a\\isactrlsub {\\isadigit{1}}\\isactrlsub {k\\ensuremath{{}_1}}{\\isacharparenright}\\ {\\isasymequiv}\\ c\\isactrlsub {\\isadigit{1}}\\ a\\isactrlsub {\\isadigit{1}}\\isactrlsub {\\isadigit{1}}\\ a\\isactrlsub {\\isadigit{1}}\\isactrlsub {\\isadigit{2}}\\ \\ldots\\ a\\isactrlsub {\\isadigit{1}}\\isactrlsub {k\\ensuremath{{}_1}}{\\isacharparenright}\\isanewline\n      \\ \\ \\ \\ {\\isacharampersand}{\\isacharampersand}{\\isacharampersand}\\ {\\isacharparenleft}CASE\\ {\\isacharparenleft}C\\isactrlsub {\\isadigit{2}}\\ a\\isactrlsub {\\isadigit{2}}\\isactrlsub {\\isadigit{1}}\\ a\\isactrlsub {\\isadigit{2}}\\isactrlsub {\\isadigit{2}}\\ \\ldots\\ a\\isactrlsub {\\isadigit{2}}\\isactrlsub {k\\ensuremath{{}_2}}{\\isacharparenright}\\ {\\isasymequiv}\\ c\\isactrlsub {\\isadigit{2}}\\ a\\isactrlsub {\\isadigit{2}}\\isactrlsub {\\isadigit{1}}\\ a\\isactrlsub {\\isadigit{2}}\\isactrlsub {\\isadigit{2}}\\ \\ldots\\ a\\isactrlsub {\\isadigit{2}}\\isactrlsub {k\\ensuremath{{}_2}}{\\isacharparenright}\\isanewline\n      \\ \\ \\ \\ {\\isacharampersand}{\\isacharampersand}{\\isacharampersand}\\ \\ldots\\isanewline\n      \\ \\ \\ \\ {\\isacharampersand}{\\isacharampersand}{\\isacharampersand}\\ {\\isacharparenleft}CASE\\ {\\isacharparenleft}C\\isactrlsub {n}\\ a\\isactrlsub {n}\\isactrlsub {\\isadigit{1}}\\ a\\isactrlsub {n}\\isactrlsub {\\isadigit{2}}\\ \\ldots\\ a\\isactrlsub {n}\\isactrlsub {k\\ensuremath{{}_n}}{\\isacharparenright}\\ {\\isasymequiv}\\ c\\isactrlsub {n}\\ a\\isactrlsub {n}\\isactrlsub {\\isadigit{1}}\\ a\\isactrlsub {n}\\isactrlsub {\\isadigit{2}}\\ \\ldots\\ a\\isactrlsub {n}\\isactrlsub {k\\ensuremath{{}_n}}{\\isacharparenright}{\\isachardoublequoteclose}\\isanewline\n    }\n  }\n  We delete the code equations for the old constructor @{term Word}\n  and case combinator @{term case_val} such that the code generator\n  reports missing adaptations.\n\\<close>"], ["", "lift_definition Word' :: \"uint32 \\<Rightarrow> val\" is Word"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "code_datatype Bool Word'"], ["", "lift_definition case_val' :: \"(bool \\<Rightarrow> 'a) \\<Rightarrow> (uint32 \\<Rightarrow> 'a) \\<Rightarrow> val \\<Rightarrow> 'a\" is case_val"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemmas [code, simp] = val.case [Transfer.transferred]"], ["", "lemma case_val'_cert:\n  fixes bool word' b w\n  assumes \"CASE \\<equiv> case_val' bool word'\"\n  shows \"(CASE (Bool b) \\<equiv> bool b) &&& (CASE (Word' w) \\<equiv> word' w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (CASE (Bool b) \\<equiv> bool b) &&& CASE (Word' w) \\<equiv> word' w", "by (simp_all add: assms)"], ["", "setup \\<open>Code.declare_case_global @{thm case_val'_cert}\\<close>"], ["", "declare [[code drop: case_val Word]]"], ["", "subsection \\<open>Make functions use functions on machine words\\<close>"], ["", "text \\<open>\n  Finally, we merely have to change the code equations to use the \n  new functions that operate on @{typ uint32}. As before, the\n  attribute \\<open>Transfer.transferred\\<close> does the job. In our example,\n  we adapt the equality test on @{typ val} (code equations\n  @{thm [source] val.eq.simps}) and the denotational and small-step \n  semantics (code equations @{thm [source] eval.simps} and\n  @{thm [source] step.equation}, respectively).\n\n  We check that the adaptation has suceeded by exporting the functions.\n  As we only use native word sizes that PolyML supports, we can use \n  the usual target \\<open>SML\\<close> instead of \\<open>SML_word\\<close>.\n\\<close>"], ["", "lemmas [code] = \n  val.eq.simps[THEN meta_eq_to_obj_eq, Transfer.transferred, THEN eq_reflection]\n  eval.simps[Transfer.transferred]\n  step.equation[Transfer.transferred]"], ["", "export_code reduce step' eval checking SML"], ["", "section \\<open>Troubleshooting\\<close>"], ["", "text \\<open>\n  This section explains some possible problems when using native words.\n  If you experience other difficulties, please contact the author.\n\\<close>"], ["", "subsection \\<open>\\<open>export_code\\<close> raises an exception \\label{section:export_code:exception}\\<close>"], ["", "text \\<open>\n  Probably, you have defined and are using a function on a native word type,\n  but the code equation refers to emulated words. For example, the following\n  defines a function \\<open>double\\<close> that doubles a word. When we try to export\n  code for \\<open>double\\<close> without any further setup, \\<open>export_code\\<close> will\n  raise an exception or generate code that does not compile.\n\\<close>"], ["", "lift_definition double :: \"uint32 \\<Rightarrow> uint32\" is \"\\<lambda>x. x + x\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "text \\<open>\n  We have to prove a code equation that only uses the existing operations on\n  @{typ uint32}. Then, \\<open>export_code\\<close> works again.\n\\<close>"], ["", "lemma double_code [code]: \"double n = n + n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. double n = n + n", "by transfer simp"], ["", "subsection \\<open>The generated code does not compile\\<close>"], ["", "text \\<open>\n  Probably, you have been exporting to a target language for which there\n  is no setup, or your compiler does not provide the required API. Every\n  theory for native words mentions at the start the limitations on code\n  generation. Check that your concrete application meets all the\n  requirements.\n\n  Alternatively, this might be an instance of the problem described \n  in \\S\\ref{section:export_code:exception}.\n\n  For Haskell, you have to enable the extension TypeSynonymInstances with \\texttt{-XTypeSynonymInstances}\n  if you are using polymorphic bit operations on the native word types.\n\\<close>"], ["", "subsection \\<open>The generated code is too slow\\<close>"], ["", "text \\<open>\n  The generated code will most likely not be as fast as a direct implementation in the target language with manual tuning.\n  This is because we want the configuration of the code generation to be sound (as it can be used to prove theorems in Isabelle).\n  Therefore, the bit operations sometimes perform range checks before they call the target language API.\n  Here are some examples:\n  \\begin{itemize}\n  \\item Shift distances and bit indices in target languages are often expected to fit into a bounded integer or word.\n    However, the size of these types varies across target languages and platforms.\n    Hence, no Isabelle/HOL type can model uniformly all of them.\n    Instead, the bit operations use arbitrary-precision integers for such quantities and check at run-time that the values fit into a bounded integer or word, respectively -- if not, they raise an exception.\n  \n  \\item Division and modulo operations explicitly test whether the divisor is $0$ and return the HOL value of division by $0$ in that case.\n    This is necessary because some languages leave the behaviour of division by 0 unspecified.\n  \\end{itemize}\n  \n  If you have better ideas how to eliminate such checks and speed up the generated code without sacrificing soundness, please contact the author!\n\\<close>"], ["", "(*<*)"], ["", "end"], ["", "(*>*)"]]}