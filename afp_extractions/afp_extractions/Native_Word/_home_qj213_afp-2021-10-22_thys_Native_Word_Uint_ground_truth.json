{"file_name": "/home/qj213/afp-2021-10-22/thys/Native_Word/Uint.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Native_Word", "problem_names": ["lemma dflt_size_by_int[code]: \"dflt_size = nat_of_integer dflt_size_integer\"", "lemma dflt_size[simp]: \n  \"dflt_size > 0\"\n  \"dflt_size \\<ge> Suc 0\"\n  \"\\<not> dflt_size < Suc 0\"", "lemmas [code] = less_uint.rep_eq less_eq_uint.rep_eq", "lemma [transfer_rule]:\n  \"((=) ===> cr_uint) of_bool of_bool\"", "lemma transfer_rule_numeral_uint [transfer_rule]:\n  \"((=) ===> cr_uint) numeral numeral\"", "lemma [transfer_rule]:\n  \\<open>(cr_uint ===> (\\<longleftrightarrow>)) even ((dvd) 2 :: uint \\<Rightarrow> bool)\\<close>", "lemma [code]:\n  \\<open>take_bit n a = a AND mask n\\<close> for a :: uint", "lemma [code]:\n  \\<open>mask (Suc n) = push_bit n (1 :: uint) OR mask n\\<close>\n  \\<open>mask 0 = (0 :: uint)\\<close>", "lemma test_bit_uint_transfer [transfer_rule]:\n  \\<open>(cr_uint ===> (=)) bit (!!)\\<close>", "lemma shiftl_uint_transfer [transfer_rule]:\n  \\<open>(cr_uint ===> (=) ===> cr_uint) (\\<lambda>k n. push_bit n k) (<<)\\<close>", "lemma shiftr_uint_transfer [transfer_rule]:\n  \\<open>(cr_uint ===> (=) ===> cr_uint) (\\<lambda>k n. drop_bit n k) (>>)\\<close>", "lemmas [code] = bit_uint.rep_eq lsb_uint.rep_eq msb_uint.rep_eq", "lemmas [code] = equal_uint.rep_eq", "lemmas [code] = size_uint.rep_eq", "lemma Rep_uint_numeral [simp]: \"Rep_uint (numeral n) = numeral n\"", "lemma numeral_uint_transfer [transfer_rule]:\n  \"(rel_fun (=) cr_uint) numeral numeral\"", "lemma numeral_uint [code_unfold]: \"numeral n = Uint (numeral n)\"", "lemma Rep_uint_neg_numeral [simp]: \"Rep_uint (- numeral n) = - numeral n\"", "lemma neg_numeral_uint [code_unfold]: \"- numeral n = Uint (- numeral n)\"", "lemma Abs_uint_numeral [code_post]: \"Abs_uint (numeral n) = numeral n\"", "lemma Abs_uint_0 [code_post]: \"Abs_uint 0 = 0\"", "lemma Abs_uint_1 [code_post]: \"Abs_uint 1 = 1\"", "lemma [code]: \"wivs_mask_integer = 2 ^ dflt_size - 1\"", "lemma [code]: \"wivs_shift_integer = 2 ^ dflt_size\"", "lemma wivs_index_integer_code[code]: \"wivs_index_integer = dflt_size_integer - 1\"", "lemma [code]: \"wivs_overflow_integer = 2 ^ (dflt_size - 1)\"", "lemma [code]: \"wivs_least_integer = - (2 ^ (dflt_size - 1))\"", "lemma Uint_code [code]:\n  \"Uint i = \n  (let i' = i AND wivs_mask_integer in \n   if bit i' wivs_index then Uint_signed (i' - wivs_shift_integer) else Uint_signed i')\"", "lemma Uint_signed_code [code abstract]:\n  \"Rep_uint (Uint_signed i) = \n  (if i < wivs_least_integer \\<or> i \\<ge> wivs_overflow_integer then Rep_uint (undefined Uint i) else word_of_int (int_of_integer_symbolic i))\"", "lemma Rep_uint'_code [code]: \"Rep_uint' x = (BITS n. bit x n)\"", "lemma Abs_uint'_code [code]:\n  \"Abs_uint' x = Uint (integer_of_int (uint x))\"", "lemma term_of_uint_code [code]:\n  defines \"TR \\<equiv> typerep.Typerep\" and \"bit0 \\<equiv> STR ''Numeral_Type.bit0''\" \n  shows\n  \"term_of_class.term_of x = \n   Code_Evaluation.App (Code_Evaluation.Const (STR ''Uint.uint.Abs_uint'') (TR (STR ''fun'') [TR (STR ''Word.word'')  [TR (STR ''Uint.dflt_size'') []], TR (STR ''Uint.uint'') []]))\n       (term_of_class.term_of (Rep_uint' x))\"", "lemma div_uint_code [code]: \"x div y = (if y = 0 then 0 else uint_div x y)\"", "lemma mod_uint_code [code]: \"x mod y = (if y = 0 then x else uint_mod x y)\"", "lemma uint_divmod_code [code]:\n  \"uint_divmod x y =\n  (if wivs_overflow_uint \\<le> y then if x < y then (0, x) else (1, x - y)\n   else if y = 0 then (div0_uint x, mod0_uint x)\n   else let q = push_bit 1 (uint_sdiv (drop_bit 1 x) y);\n            r = x - q * y\n        in if r \\<ge> y then (q + 1, r - y) else (q, r))\"", "lemma uint_sdiv_code [code abstract]:\n  \"Rep_uint (uint_sdiv x y) =\n   (if y = 0 then Rep_uint (undefined ((div) :: uint \\<Rightarrow> _) x (0 :: uint))\n    else Rep_uint x sdiv Rep_uint y)\"", "lemma test_bit_uint_code [code]:\n  \"bit x n \\<longleftrightarrow> n < dflt_size \\<and> uint_test_bit x (integer_of_nat n)\"", "lemma uint_test_bit_code [code]:\n  \"uint_test_bit w n =\n  (if n < 0 \\<or> dflt_size_integer \\<le> n then undefined (bit :: uint \\<Rightarrow> _) w n else bit (Rep_uint w) (nat_of_integer n))\"", "lemma set_bit_uint_code [code]:\n  \"set_bit x n b = (if n < dflt_size then uint_set_bit x (integer_of_nat n) b else x)\"", "lemma uint_set_bit_code [code abstract]:\n  \"Rep_uint (uint_set_bit w n b) = \n  (if n < 0 \\<or> dflt_size_integer \\<le> n then Rep_uint (undefined (set_bit :: uint \\<Rightarrow> _) w n b)\n   else set_bit (Rep_uint w) (nat_of_integer n) b)\"", "lemma uint_set_bits_code [code]:\n  \"uint_set_bits f w n =\n  (if n = 0 then w \n   else let n' = n - 1 in uint_set_bits f (push_bit 1 w OR (if f n' then 1 else 0)) n')\"", "lemma set_bits_uint [code]:\n  \"(BITS n. f n) = uint_set_bits f 0 dflt_size\"", "lemma lsb_code [code]: fixes x :: uint shows \"lsb x = bit x 0\"", "lemma shiftl_uint_code [code]: \"push_bit n x = (if n < dflt_size then uint_shiftl x (integer_of_nat n) else 0)\"", "lemma uint_shiftl_code [code abstract]:\n  \"Rep_uint (uint_shiftl w n) =\n  (if n < 0 \\<or> dflt_size_integer \\<le> n then Rep_uint (undefined (push_bit :: nat \\<Rightarrow> uint \\<Rightarrow> _) w n) else push_bit (nat_of_integer n) (Rep_uint w))\"", "lemma shiftr_uint_code [code]: \"drop_bit n x = (if n < dflt_size then uint_shiftr x (integer_of_nat n) else 0)\"", "lemma uint_shiftr_code [code abstract]:\n  \"Rep_uint (uint_shiftr w n) =\n  (if n < 0 \\<or> dflt_size_integer \\<le> n then Rep_uint (undefined (drop_bit :: nat \\<Rightarrow> uint \\<Rightarrow> _) w n) else drop_bit (nat_of_integer n) (Rep_uint w))\"", "lemma sshiftr_uint_code [code]:\n  \"x >>> n = \n  (if n < dflt_size then uint_sshiftr x (integer_of_nat n) else \n    if bit x wivs_index then -1 else 0)\"", "lemma uint_sshiftr_code [code abstract]:\n  \"Rep_uint (uint_sshiftr w n) =\n  (if n < 0 \\<or> dflt_size_integer \\<le> n then Rep_uint (undefined sshiftr_uint w n) else signed_drop_bit (nat_of_integer n) (Rep_uint w))\"", "lemma uint_msb_test_bit: \"msb x \\<longleftrightarrow> bit (x :: uint) wivs_index\"", "lemma msb_uint_code [code]: \"msb x \\<longleftrightarrow> uint_test_bit x wivs_index_integer\"", "lemma uint_of_int_code [code]: \"uint_of_int i = (BITS n. bit i n)\"", "lemmas partial_term_of_uint [code] = partial_term_of_code"], "translations": [["", "lemma dflt_size_by_int[code]: \"dflt_size = nat_of_integer dflt_size_integer\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dflt_size = nat_of_integer dflt_size_integer", "by transfer simp"], ["", "lemma dflt_size[simp]: \n  \"dflt_size > 0\"\n  \"dflt_size \\<ge> Suc 0\"\n  \"\\<not> dflt_size < Suc 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < dflt_size &&& Suc 0 \\<le> dflt_size &&& \\<not> dflt_size < Suc 0", "using len_gt_0[where 'a=dflt_size]"], ["proof (prove)\nusing this:\n  0 < dflt_size\n\ngoal (1 subgoal):\n 1. 0 < dflt_size &&& Suc 0 \\<le> dflt_size &&& \\<not> dflt_size < Suc 0", "by (simp_all del: len_gt_0)"], ["", "end"], ["", "declare prod.Quotient[transfer_rule]"], ["", "section \\<open>Type definition and primitive operations\\<close>"], ["", "typedef uint = \"UNIV :: dflt_size word set\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> UNIV", ".."], ["", "setup_lifting type_definition_uint"], ["", "text \\<open>Use an abstract type for code generation to disable pattern matching on @{term Abs_uint}.\\<close>"], ["", "declare Rep_uint_inverse[code abstype]"], ["", "declare Quotient_uint[transfer_rule]"], ["", "instantiation uint :: comm_ring_1\nbegin"], ["", "lift_definition zero_uint :: uint is \"0 :: dflt_size word\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition one_uint :: uint is \"1\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition plus_uint :: \"uint \\<Rightarrow> uint \\<Rightarrow> uint\" is \"(+) :: dflt_size word \\<Rightarrow> _\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition minus_uint :: \"uint \\<Rightarrow> uint \\<Rightarrow> uint\" is \"(-)\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition uminus_uint :: \"uint \\<Rightarrow> uint\" is uminus"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition times_uint :: \"uint \\<Rightarrow> uint \\<Rightarrow> uint\" is \"(*)\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(uint, comm_ring_1_class)", "by (standard; transfer) (simp_all add: algebra_simps)"], ["", "end"], ["", "instantiation uint :: semiring_modulo\nbegin"], ["", "lift_definition divide_uint :: \"uint \\<Rightarrow> uint \\<Rightarrow> uint\" is \"(div)\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition modulo_uint :: \"uint \\<Rightarrow> uint \\<Rightarrow> uint\" is \"(mod)\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(uint, semiring_modulo_class)", "by (standard; transfer) (fact word_mod_div_equality)"], ["", "end"], ["", "instantiation uint :: linorder begin"], ["", "lift_definition less_uint :: \"uint \\<Rightarrow> uint \\<Rightarrow> bool\" is \"(<)\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition less_eq_uint :: \"uint \\<Rightarrow> uint \\<Rightarrow> bool\" is \"(\\<le>)\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(uint, linorder_class)", "by (standard; transfer) (simp_all add: less_le_not_le linear)"], ["", "end"], ["", "lemmas [code] = less_uint.rep_eq less_eq_uint.rep_eq"], ["", "context\n  includes lifting_syntax\n  notes\n    transfer_rule_of_bool [transfer_rule]\n    transfer_rule_numeral [transfer_rule]\nbegin"], ["", "lemma [transfer_rule]:\n  \"((=) ===> cr_uint) of_bool of_bool\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((=) ===> cr_uint) of_bool of_bool", "by transfer_prover"], ["", "lemma transfer_rule_numeral_uint [transfer_rule]:\n  \"((=) ===> cr_uint) numeral numeral\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((=) ===> cr_uint) numeral numeral", "by transfer_prover"], ["", "lemma [transfer_rule]:\n  \\<open>(cr_uint ===> (\\<longleftrightarrow>)) even ((dvd) 2 :: uint \\<Rightarrow> bool)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (cr_uint ===> (=)) even ((dvd) 2)", "by (unfold dvd_def) transfer_prover"], ["", "end"], ["", "instantiation uint :: semiring_bits\nbegin"], ["", "lift_definition bit_uint :: \\<open>uint \\<Rightarrow> nat \\<Rightarrow> bool\\<close> is bit"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(uint, semiring_bits_class)", "by (standard; transfer)\n    (fact bit_iff_odd even_iff_mod_2_eq_zero odd_iff_mod_2_eq_one odd_one bits_induct\n       bits_div_0 bits_div_by_1 bits_mod_div_trivial even_succ_div_2\n       even_mask_div_iff exp_div_exp_eq div_exp_eq mod_exp_eq mult_exp_mod_exp_eq\n       div_exp_mod_exp_eq even_mult_exp_div_exp_iff)+"], ["", "end"], ["", "instantiation uint :: semiring_bit_shifts\nbegin"], ["", "lift_definition push_bit_uint :: \\<open>nat \\<Rightarrow> uint \\<Rightarrow> uint\\<close> is push_bit"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition drop_bit_uint :: \\<open>nat \\<Rightarrow> uint \\<Rightarrow> uint\\<close> is drop_bit"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition take_bit_uint :: \\<open>nat \\<Rightarrow> uint \\<Rightarrow> uint\\<close> is take_bit"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(uint, semiring_bit_shifts_class)", "by (standard; transfer)\n  (fact push_bit_eq_mult drop_bit_eq_div take_bit_eq_mod)+"], ["", "end"], ["", "instantiation uint :: ring_bit_operations\nbegin"], ["", "lift_definition not_uint :: \\<open>uint \\<Rightarrow> uint\\<close> is NOT"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition and_uint :: \\<open>uint \\<Rightarrow> uint \\<Rightarrow> uint\\<close> is \\<open>(AND)\\<close>"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition or_uint :: \\<open>uint \\<Rightarrow> uint \\<Rightarrow> uint\\<close> is \\<open>(OR)\\<close>"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition xor_uint :: \\<open>uint \\<Rightarrow> uint \\<Rightarrow> uint\\<close> is \\<open>(XOR)\\<close>"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition mask_uint :: \\<open>nat \\<Rightarrow> uint\\<close> is mask"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(uint, ring_bit_operations_class)", "by (standard; transfer)\n  (simp_all add: bit_and_iff bit_or_iff bit_xor_iff bit_not_iff minus_eq_not_minus_1 mask_eq_decr_exp)"], ["", "end"], ["", "lemma [code]:\n  \\<open>take_bit n a = a AND mask n\\<close> for a :: uint"], ["proof (prove)\ngoal (1 subgoal):\n 1. take_bit n a = a AND mask n", "by (fact take_bit_eq_mask)"], ["", "lemma [code]:\n  \\<open>mask (Suc n) = push_bit n (1 :: uint) OR mask n\\<close>\n  \\<open>mask 0 = (0 :: uint)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. mask (Suc n) = push_bit n 1 OR mask n &&& mask 0 = 0", "by (simp_all add: mask_Suc_exp push_bit_of_1)"], ["", "instance uint :: semiring_bit_syntax"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(uint, semiring_bit_syntax_class)", ".."], ["", "context\n  includes lifting_syntax\nbegin"], ["", "lemma test_bit_uint_transfer [transfer_rule]:\n  \\<open>(cr_uint ===> (=)) bit (!!)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (cr_uint ===> (=)) bit (!!)", "unfolding test_bit_eq_bit"], ["proof (prove)\ngoal (1 subgoal):\n 1. (cr_uint ===> (=)) bit bit", "by transfer_prover"], ["", "lemma shiftl_uint_transfer [transfer_rule]:\n  \\<open>(cr_uint ===> (=) ===> cr_uint) (\\<lambda>k n. push_bit n k) (<<)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (cr_uint ===> (=) ===> cr_uint) (\\<lambda>k n. push_bit n k) (<<)", "unfolding shiftl_eq_push_bit"], ["proof (prove)\ngoal (1 subgoal):\n 1. (cr_uint ===> (=) ===> cr_uint) (\\<lambda>k n. push_bit n k)\n     (\\<lambda>a n. push_bit n a)", "by transfer_prover"], ["", "lemma shiftr_uint_transfer [transfer_rule]:\n  \\<open>(cr_uint ===> (=) ===> cr_uint) (\\<lambda>k n. drop_bit n k) (>>)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (cr_uint ===> (=) ===> cr_uint) (\\<lambda>k n. drop_bit n k) (>>)", "unfolding shiftr_eq_drop_bit"], ["proof (prove)\ngoal (1 subgoal):\n 1. (cr_uint ===> (=) ===> cr_uint) (\\<lambda>k n. drop_bit n k)\n     (\\<lambda>a n. drop_bit n a)", "by transfer_prover"], ["", "end"], ["", "instantiation uint :: lsb\nbegin"], ["", "lift_definition lsb_uint :: \\<open>uint \\<Rightarrow> bool\\<close> is lsb"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(uint, lsb_class)", "by (standard; transfer)\n  (fact lsb_odd)"], ["", "end"], ["", "instantiation uint :: msb\nbegin"], ["", "lift_definition msb_uint :: \\<open>uint \\<Rightarrow> bool\\<close> is msb"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(uint, msb_class)", ".."], ["", "end"], ["", "instantiation uint :: set_bit\nbegin"], ["", "lift_definition set_bit_uint :: \\<open>uint \\<Rightarrow> nat \\<Rightarrow> bool \\<Rightarrow> uint\\<close> is set_bit"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(uint, set_bit_class)", "apply standard"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a m b n.\n       bit (set_bit_class.set_bit a m b) n =\n       ((if m = n then b else bit a n) \\<and> 2 ^ n \\<noteq> 0)", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a m b n.\n       bit (set_bit_class.set_bit a m b) n =\n       ((if m = n then b else bit a n) \\<and> 2 ^ n \\<noteq> 0)", "apply (simp add: bit_simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "instantiation uint :: bit_comprehension begin"], ["", "lift_definition set_bits_uint :: \"(nat \\<Rightarrow> bool) \\<Rightarrow> uint\" is \"set_bits\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(uint, bit_comprehension_class)", "by (standard; transfer) (fact set_bits_bit_eq)"], ["", "end"], ["", "lemmas [code] = bit_uint.rep_eq lsb_uint.rep_eq msb_uint.rep_eq"], ["", "instantiation uint :: equal begin"], ["", "lift_definition equal_uint :: \"uint \\<Rightarrow> uint \\<Rightarrow> bool\" is \"equal_class.equal\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(uint, equal_class)", "by standard (transfer, simp add: equal_eq)"], ["", "end"], ["", "lemmas [code] = equal_uint.rep_eq"], ["", "instantiation uint :: size begin"], ["", "lift_definition size_uint :: \"uint \\<Rightarrow> nat\" is \"size\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(uint, size_class)", ".."], ["", "end"], ["", "lemmas [code] = size_uint.rep_eq"], ["", "lift_definition sshiftr_uint :: \"uint \\<Rightarrow> nat \\<Rightarrow> uint\" (infixl \">>>\" 55) is \\<open>\\<lambda>w n. signed_drop_bit n w\\<close>"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition uint_of_int :: \"int \\<Rightarrow> uint\" is \"word_of_int\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "text \\<open>Use pretty numerals from integer for pretty printing\\<close>"], ["", "context includes integer.lifting begin"], ["", "lift_definition Uint :: \"integer \\<Rightarrow> uint\" is \"word_of_int\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma Rep_uint_numeral [simp]: \"Rep_uint (numeral n) = numeral n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_uint (numeral n) = numeral n", "by(induction n)(simp_all add: one_uint_def Abs_uint_inverse numeral.simps plus_uint_def)"], ["", "lemma numeral_uint_transfer [transfer_rule]:\n  \"(rel_fun (=) cr_uint) numeral numeral\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_fun (=) cr_uint numeral numeral", "by(auto simp add: cr_uint_def)"], ["", "lemma numeral_uint [code_unfold]: \"numeral n = Uint (numeral n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. numeral n = Uint (numeral n)", "by transfer simp"], ["", "lemma Rep_uint_neg_numeral [simp]: \"Rep_uint (- numeral n) = - numeral n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_uint (- numeral n) = - numeral n", "by(simp only: uminus_uint_def)(simp add: Abs_uint_inverse)"], ["", "lemma neg_numeral_uint [code_unfold]: \"- numeral n = Uint (- numeral n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - numeral n = Uint (- numeral n)", "by transfer(simp add: cr_uint_def)"], ["", "end"], ["", "lemma Abs_uint_numeral [code_post]: \"Abs_uint (numeral n) = numeral n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_uint (numeral n) = numeral n", "by(induction n)(simp_all add: one_uint_def numeral.simps plus_uint_def Abs_uint_inverse)"], ["", "lemma Abs_uint_0 [code_post]: \"Abs_uint 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_uint 0 = 0", "by(simp add: zero_uint_def)"], ["", "lemma Abs_uint_1 [code_post]: \"Abs_uint 1 = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_uint 1 = 1", "by(simp add: one_uint_def)"], ["", "section \\<open>Code setup\\<close>"], ["", "code_printing code_module Uint \\<rightharpoonup> (SML)\n\\<open>\nstructure Uint : sig\n  val set_bit : Word.word -> IntInf.int -> bool -> Word.word\n  val shiftl : Word.word -> IntInf.int -> Word.word\n  val shiftr : Word.word -> IntInf.int -> Word.word\n  val shiftr_signed : Word.word -> IntInf.int -> Word.word\n  val test_bit : Word.word -> IntInf.int -> bool\nend = struct\n\nfun set_bit x n b =\n  let val mask = Word.<< (0wx1, Word.fromLargeInt (IntInf.toLarge n))\n  in if b then Word.orb (x, mask)\n     else Word.andb (x, Word.notb mask)\n  end\n\nfun shiftl x n =\n  Word.<< (x, Word.fromLargeInt (IntInf.toLarge n))\n\nfun shiftr x n =\n  Word.>> (x, Word.fromLargeInt (IntInf.toLarge n))\n\nfun shiftr_signed x n =\n  Word.~>> (x, Word.fromLargeInt (IntInf.toLarge n))\n\nfun test_bit x n =\n  Word.andb (x, Word.<< (0wx1, Word.fromLargeInt (IntInf.toLarge n))) <> Word.fromInt 0\n\nend; (* struct Uint *)\\<close>"], ["", "code_reserved SML Uint"], ["", "code_printing code_module Uint \\<rightharpoonup> (Haskell)\n \\<open>module Uint(Int, Word, dflt_size) where\n\n  import qualified Prelude\n  import Data.Int(Int)\n  import Data.Word(Word)\n  import qualified Data.Bits\n\n  dflt_size :: Prelude.Integer\n  dflt_size = Prelude.toInteger (bitSize_aux (0::Word)) where\n    bitSize_aux :: (Data.Bits.Bits a, Prelude.Bounded a) => a -> Int\n    bitSize_aux = Data.Bits.bitSize\\<close>\n  and (Haskell_Quickcheck)\n \\<open>module Uint(Int, Word, dflt_size) where\n\n  import qualified Prelude\n  import Data.Int(Int)\n  import Data.Word(Word)\n  import qualified Data.Bits\n\n  dflt_size :: Prelude.Int\n  dflt_size = bitSize_aux (0::Word) where\n    bitSize_aux :: (Data.Bits.Bits a, Prelude.Bounded a) => a -> Int\n    bitSize_aux = Data.Bits.bitSize\n\\<close>"], ["", "code_reserved Haskell Uint dflt_size"], ["", "text \\<open>\n  OCaml and Scala provide only signed bit numbers, so we use these and \n  implement sign-sensitive operations like comparisons manually.\n\\<close>"], ["", "code_printing code_module \"Uint\" \\<rightharpoonup> (OCaml)\n\\<open>module Uint : sig\n  type t = int\n  val dflt_size : Z.t\n  val less : t -> t -> bool\n  val less_eq : t -> t -> bool\n  val set_bit : t -> Z.t -> bool -> t\n  val shiftl : t -> Z.t -> t\n  val shiftr : t -> Z.t -> t\n  val shiftr_signed : t -> Z.t -> t\n  val test_bit : t -> Z.t -> bool\n  val int_mask : int\n  val int32_mask : int32\n  val int64_mask : int64\nend = struct\n\ntype t = int\n\nlet dflt_size = Z.of_int Sys.int_size;;\n\n(* negative numbers have their highest bit set, \n   so they are greater than positive ones *)\nlet less x y =\n  if x<0 then\n    y<0 && x<y\n  else y < 0 || x < y;;\n\nlet less_eq x y =\n  if x < 0 then\n    y < 0 &&  x <= y\n  else y < 0 || x <= y;;\n\nlet set_bit x n b =\n  let mask = 1 lsl (Z.to_int n)\n  in if b then x lor mask\n     else x land (lnot mask);;\n\nlet shiftl x n = x lsl (Z.to_int n);;\n\nlet shiftr x n = x lsr (Z.to_int n);;\n\nlet shiftr_signed x n = x asr (Z.to_int n);;\n\nlet test_bit x n = x land (1 lsl (Z.to_int n)) <> 0;;\n\nlet int_mask =\n  if Sys.int_size < 32 then lnot 0 else 0xFFFFFFFF;;\n\nlet int32_mask = \n  if Sys.int_size < 32 then Int32.pred (Int32.shift_left Int32.one Sys.int_size)\n  else Int32.of_string \"0xFFFFFFFF\";;\n\nlet int64_mask = \n  if Sys.int_size < 64 then Int64.pred (Int64.shift_left Int64.one Sys.int_size)\n  else Int64.of_string \"0xFFFFFFFFFFFFFFFF\";;\n\nend;; (*struct Uint*)\\<close>"], ["", "code_reserved OCaml Uint"], ["", "code_printing code_module Uint \\<rightharpoonup> (Scala)\n\\<open>object Uint {\ndef dflt_size : BigInt = BigInt(32)\n\ndef less(x: Int, y: Int) : Boolean =\n  if (x < 0) y < 0 && x < y\n  else y < 0 || x < y\n\ndef less_eq(x: Int, y: Int) : Boolean =\n  if (x < 0) y < 0 && x <= y\n  else y < 0 || x <= y\n\ndef set_bit(x: Int, n: BigInt, b: Boolean) : Int =\n  if (b)\n    x | (1 << n.intValue)\n  else\n    x & (1 << n.intValue).unary_~\n\ndef shiftl(x: Int, n: BigInt) : Int = x << n.intValue\n\ndef shiftr(x: Int, n: BigInt) : Int = x >>> n.intValue\n\ndef shiftr_signed(x: Int, n: BigInt) : Int = x >> n.intValue\n\ndef test_bit(x: Int, n: BigInt) : Boolean =\n  (x & (1 << n.intValue)) != 0\n\n} /* object Uint */\\<close>"], ["", "code_reserved Scala Uint"], ["", "text \\<open>\n  OCaml's conversion from Big\\_int to int demands that the value fits into a signed integer.\n  The following justifies the implementation.\n\\<close>"], ["", "context includes integer.lifting begin"], ["", "definition wivs_mask :: int where \"wivs_mask = 2^ dflt_size - 1\""], ["", "lift_definition wivs_mask_integer :: integer is wivs_mask"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma [code]: \"wivs_mask_integer = 2 ^ dflt_size - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wivs_mask_integer = 2 ^ dflt_size - 1", "by transfer (simp add: wivs_mask_def)"], ["", "definition wivs_shift :: int where \"wivs_shift = 2 ^ dflt_size\""], ["", "lift_definition wivs_shift_integer :: integer is wivs_shift"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma [code]: \"wivs_shift_integer = 2 ^ dflt_size\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wivs_shift_integer = 2 ^ dflt_size", "by transfer (simp add: wivs_shift_def)"], ["", "definition wivs_index :: nat where \"wivs_index == dflt_size - 1\""], ["", "lift_definition wivs_index_integer :: integer is \"int wivs_index\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma wivs_index_integer_code[code]: \"wivs_index_integer = dflt_size_integer - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wivs_index_integer = dflt_size_integer - 1", "by transfer (simp add: wivs_index_def of_nat_diff)"], ["", "definition wivs_overflow :: int where \"wivs_overflow == 2^ (dflt_size - 1)\""], ["", "lift_definition wivs_overflow_integer :: integer is wivs_overflow"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma [code]: \"wivs_overflow_integer = 2 ^ (dflt_size - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wivs_overflow_integer = 2 ^ (dflt_size - 1)", "by transfer (simp add: wivs_overflow_def)"], ["", "definition wivs_least :: int where \"wivs_least == - wivs_overflow\""], ["", "lift_definition wivs_least_integer :: integer is wivs_least"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma [code]: \"wivs_least_integer = - (2 ^ (dflt_size - 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wivs_least_integer = - (2 ^ (dflt_size - 1))", "by transfer (simp add: wivs_overflow_def wivs_least_def)"], ["", "definition Uint_signed :: \"integer \\<Rightarrow> uint\" where\n  \"Uint_signed i = (if i < wivs_least_integer \\<or> wivs_overflow_integer \\<le> i then undefined Uint i else Uint i)\""], ["", "lemma Uint_code [code]:\n  \"Uint i = \n  (let i' = i AND wivs_mask_integer in \n   if bit i' wivs_index then Uint_signed (i' - wivs_shift_integer) else Uint_signed i')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Uint i =\n    (let i' = i AND wivs_mask_integer\n     in if bit i' wivs_index then Uint_signed (i' - wivs_shift_integer)\n        else Uint_signed i')", "including undefined_transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. Uint i =\n    (let i' = i AND wivs_mask_integer\n     in if bit i' wivs_index then Uint_signed (i' - wivs_shift_integer)\n        else Uint_signed i')", "unfolding Uint_signed_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Uint i =\n    (let i' = i AND wivs_mask_integer\n     in if bit i' wivs_index\n        then if i' - wivs_shift_integer < wivs_least_integer \\<or>\n                wivs_overflow_integer \\<le> i' - wivs_shift_integer\n             then undefined Uint (i' - wivs_shift_integer)\n             else Uint (i' - wivs_shift_integer)\n        else if i' < wivs_least_integer \\<or> wivs_overflow_integer \\<le> i'\n             then undefined Uint i' else Uint i')", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       word_of_int i =\n       (let i' = i AND wivs_mask\n        in if bit i' wivs_index\n           then if i' - wivs_shift < wivs_least \\<or>\n                   wivs_overflow \\<le> i' - wivs_shift\n                then map_fun (map_fun int_of_integer Abs_uint)\n                      (map_fun integer_of_int Rep_uint) undefined\n                      word_of_int (i' - wivs_shift)\n                else word_of_int (i' - wivs_shift)\n           else if i' < wivs_least \\<or> wivs_overflow \\<le> i'\n                then map_fun (map_fun int_of_integer Abs_uint)\n                      (map_fun integer_of_int Rep_uint) undefined\n                      word_of_int i'\n                else word_of_int i')", "apply (subst word_of_int_via_signed)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>i. ?mask133 i = mask dflt_size\n 2. \\<And>i. ?shift133 i = 1 << dflt_size\n 3. \\<And>i. ?index133 i = dflt_size - 1\n 4. \\<And>i. ?overflow133 i = 1 << dflt_size - 1\n 5. \\<And>i. ?least133 i = - ?overflow133 i\n 6. \\<And>i.\n       (let i' = i AND ?mask133 i\n        in if i' !! ?index133 i\n           then if i' - ?shift133 i < ?least133 i \\<or>\n                   ?overflow133 i \\<le> i' - ?shift133 i\n                then ?arbitrary1.133 i i'\n                else word_of_int (i' - ?shift133 i)\n           else if i' < ?least133 i \\<or> ?overflow133 i \\<le> i'\n                then ?arbitrary2.133 i i' else word_of_int i') =\n       (let i' = i AND wivs_mask\n        in if bit i' wivs_index\n           then if i' - wivs_shift < wivs_least \\<or>\n                   wivs_overflow \\<le> i' - wivs_shift\n                then map_fun (map_fun int_of_integer Abs_uint)\n                      (map_fun integer_of_int Rep_uint) undefined\n                      word_of_int (i' - wivs_shift)\n                else word_of_int (i' - wivs_shift)\n           else if i' < wivs_least \\<or> wivs_overflow \\<le> i'\n                then map_fun (map_fun int_of_integer Abs_uint)\n                      (map_fun integer_of_int Rep_uint) undefined\n                      word_of_int i'\n                else word_of_int i')", "apply (auto simp add: shiftl_eq_push_bit push_bit_of_1 mask_eq_exp_minus_1 word_of_int_via_signed\n         wivs_mask_def wivs_index_def wivs_overflow_def wivs_least_def wivs_shift_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma Uint_signed_code [code abstract]:\n  \"Rep_uint (Uint_signed i) = \n  (if i < wivs_least_integer \\<or> i \\<ge> wivs_overflow_integer then Rep_uint (undefined Uint i) else word_of_int (int_of_integer_symbolic i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_uint (Uint_signed i) =\n    (if i < wivs_least_integer \\<or> wivs_overflow_integer \\<le> i\n     then Rep_uint (undefined Uint i)\n     else word_of_int (int_of_integer_symbolic i))", "unfolding Uint_signed_def Uint_def int_of_integer_symbolic_def word_of_integer_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_uint\n     (if i < wivs_least_integer \\<or> wivs_overflow_integer \\<le> i\n      then undefined (map_fun int_of_integer Abs_uint word_of_int) i\n      else map_fun int_of_integer Abs_uint word_of_int i) =\n    (if i < wivs_least_integer \\<or> wivs_overflow_integer \\<le> i\n     then Rep_uint\n           (undefined (map_fun int_of_integer Abs_uint word_of_int) i)\n     else word_of_int (int_of_integer i))", "by(simp add: Abs_uint_inverse)"], ["", "end"], ["", "text \\<open>\n  Avoid @{term Abs_uint} in generated code, use @{term Rep_uint'} instead. \n  The symbolic implementations for code\\_simp use @{term Rep_uint}.\n\n  The new destructor @{term Rep_uint'} is executable.\n  As the simplifier is given the [code abstract] equations literally, \n  we cannot implement @{term Rep_uint} directly, because that makes code\\_simp loop.\n\n  If code generation raises Match, some equation probably contains @{term Rep_uint} \n  ([code abstract] equations for @{typ uint} may use @{term Rep_uint} because\n  these instances will be folded away.)\n\\<close>"], ["", "definition Rep_uint' where [simp]: \"Rep_uint' = Rep_uint\""], ["", "lemma Rep_uint'_code [code]: \"Rep_uint' x = (BITS n. bit x n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_uint' x = (BITS n. bit x n)", "unfolding Rep_uint'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_uint x = (BITS n. bit x n)", "by transfer (simp add: set_bits_bit_eq)"], ["", "lift_definition Abs_uint' :: \"dflt_size word \\<Rightarrow> uint\" is \"\\<lambda>x :: dflt_size word. x\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma Abs_uint'_code [code]:\n  \"Abs_uint' x = Uint (integer_of_int (uint x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_uint' x = Uint (integer_of_int (uint x))", "including integer.lifting"], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_uint' x = Uint (integer_of_int (uint x))", "by transfer simp"], ["", "declare [[code drop: \"term_of_class.term_of :: uint \\<Rightarrow> _\"]]"], ["", "lemma term_of_uint_code [code]:\n  defines \"TR \\<equiv> typerep.Typerep\" and \"bit0 \\<equiv> STR ''Numeral_Type.bit0''\" \n  shows\n  \"term_of_class.term_of x = \n   Code_Evaluation.App (Code_Evaluation.Const (STR ''Uint.uint.Abs_uint'') (TR (STR ''fun'') [TR (STR ''Word.word'')  [TR (STR ''Uint.dflt_size'') []], TR (STR ''Uint.uint'') []]))\n       (term_of_class.term_of (Rep_uint' x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. term_of_class.term_of x =\n    Code_Evaluation.App\n     (Code_Evaluation.Const STR ''Uint.uint.Abs_uint''\n       (TR STR ''fun''\n         [TR STR ''Word.word'' [TR STR ''Uint.dflt_size'' []],\n          TR STR ''Uint.uint'' []]))\n     (term_of_class.term_of (Rep_uint' x))", "by(simp add: term_of_anything)"], ["", "text \\<open>Important:\n  We must prevent the reflection oracle (eval-tac) to \n  use our machine-dependent type.\n\\<close>"], ["", "code_printing\n  type_constructor uint \\<rightharpoonup>\n  (SML) \"Word.word\" and\n  (Haskell) \"Uint.Word\" and\n  (OCaml) \"Uint.t\" and\n  (Scala) \"Int\" and\n  (Eval) \"*** \\\"Error: Machine dependent type\\\" ***\" and\n  (Quickcheck) \"Word.word\" \n| constant dflt_size_integer \\<rightharpoonup>\n  (SML) \"(IntInf.fromLarge (Int.toLarge Word.wordSize))\" and\n  (Eval) \"(raise (Fail \\\"Machine dependent code\\\"))\" and\n  (Quickcheck) \"Word.wordSize\" and\n  (Haskell) \"Uint.dflt'_size\" and\n  (OCaml) \"Uint.dflt'_size\" and\n  (Scala) \"Uint.dflt'_size\"\n| constant Uint \\<rightharpoonup>\n  (SML) \"Word.fromLargeInt (IntInf.toLarge _)\" and\n  (Eval) \"(raise (Fail \\\"Machine dependent code\\\"))\" and\n  (Quickcheck) \"Word.fromInt\" and\n  (Haskell) \"(Prelude.fromInteger _ :: Uint.Word)\" and\n  (Haskell_Quickcheck) \"(Prelude.fromInteger (Prelude.toInteger _) :: Uint.Word)\" and\n  (Scala) \"_.intValue\"\n| constant Uint_signed \\<rightharpoonup>\n  (OCaml) \"Z.to'_int\"\n| constant \"0 :: uint\" \\<rightharpoonup>\n  (SML) \"(Word.fromInt 0)\" and\n  (Eval) \"(raise (Fail \\\"Machine dependent code\\\"))\" and\n  (Quickcheck) \"(Word.fromInt 0)\" and\n  (Haskell) \"(0 :: Uint.Word)\" and\n  (OCaml) \"0\" and\n  (Scala) \"0\"\n| constant \"1 :: uint\" \\<rightharpoonup>\n  (SML) \"(Word.fromInt 1)\" and\n  (Eval) \"(raise (Fail \\\"Machine dependent code\\\"))\" and\n  (Quickcheck) \"(Word.fromInt 1)\" and\n  (Haskell) \"(1 :: Uint.Word)\" and\n  (OCaml) \"1\" and\n  (Scala) \"1\"\n| constant \"plus :: uint \\<Rightarrow> _ \" \\<rightharpoonup>\n  (SML) \"Word.+ ((_), (_))\" and\n  (Eval) \"(raise (Fail \\\"Machine dependent code\\\"))\" and\n  (Quickcheck) \"Word.+ ((_), (_))\" and\n  (Haskell) infixl 6 \"+\" and\n  (OCaml) \"Pervasives.(+)\" and\n  (Scala) infixl 7 \"+\"\n| constant \"uminus :: uint \\<Rightarrow> _\" \\<rightharpoonup>\n  (SML) \"Word.~\" and\n  (Eval) \"(raise (Fail \\\"Machine dependent code\\\"))\" and\n  (Quickcheck) \"Word.~\" and\n  (Haskell) \"negate\" and\n  (OCaml) \"Pervasives.(~-)\" and\n  (Scala) \"!(- _)\"\n| constant \"minus :: uint \\<Rightarrow> _\" \\<rightharpoonup>\n  (SML) \"Word.- ((_), (_))\" and\n  (Eval) \"(raise (Fail \\\"Machine dependent code\\\"))\" and\n  (Quickcheck) \"Word.- ((_), (_))\" and\n  (Haskell) infixl 6 \"-\" and\n  (OCaml) \"Pervasives.(-)\" and\n  (Scala) infixl 7 \"-\"\n| constant \"times :: uint \\<Rightarrow> _ \\<Rightarrow> _\" \\<rightharpoonup>\n  (SML) \"Word.* ((_), (_))\" and\n  (Eval) \"(raise (Fail \\\"Machine dependent code\\\"))\" and\n  (Quickcheck) \"Word.* ((_), (_))\" and\n  (Haskell) infixl 7 \"*\" and\n  (OCaml) \"Pervasives.( * )\" and\n  (Scala) infixl 8 \"*\"\n| constant \"HOL.equal :: uint \\<Rightarrow> _ \\<Rightarrow> bool\" \\<rightharpoonup>\n  (SML) \"!((_ : Word.word) = _)\" and\n  (Eval) \"(raise (Fail \\\"Machine dependent code\\\"))\" and\n  (Quickcheck) \"!((_ : Word.word) = _)\" and\n  (Haskell) infix 4 \"==\" and\n  (OCaml) \"(Pervasives.(=):Uint.t -> Uint.t -> bool)\" and\n  (Scala) infixl 5 \"==\"\n| class_instance uint :: equal \\<rightharpoonup>\n  (Haskell) -\n| constant \"less_eq :: uint \\<Rightarrow> _ \\<Rightarrow> bool\" \\<rightharpoonup>\n  (SML) \"Word.<= ((_), (_))\" and\n  (Eval) \"(raise (Fail \\\"Machine dependent code\\\"))\" and\n  (Quickcheck) \"Word.<= ((_), (_))\" and\n  (Haskell) infix 4 \"<=\" and\n  (OCaml) \"Uint.less'_eq\" and\n  (Scala) \"Uint.less'_eq\"\n| constant \"less :: uint \\<Rightarrow> _ \\<Rightarrow> bool\" \\<rightharpoonup>\n  (SML) \"Word.< ((_), (_))\" and\n  (Eval) \"(raise (Fail \\\"Machine dependent code\\\"))\" and\n  (Quickcheck) \"Word.< ((_), (_))\" and\n  (Haskell) infix 4 \"<\" and\n  (OCaml) \"Uint.less\" and\n  (Scala) \"Uint.less\"\n| constant \"NOT :: uint \\<Rightarrow> _\" \\<rightharpoonup>\n  (SML) \"Word.notb\" and\n  (Eval) \"(raise (Fail \\\"Machine dependent code\\\"))\" and\n  (Quickcheck) \"Word.notb\" and\n  (Haskell) \"Data'_Bits.complement\" and\n  (OCaml) \"Pervasives.lnot\" and\n  (Scala) \"_.unary'_~\"\n| constant \"(AND) :: uint \\<Rightarrow> _\" \\<rightharpoonup>\n  (SML) \"Word.andb ((_),/ (_))\" and\n  (Eval) \"(raise (Fail \\\"Machine dependent code\\\"))\" and\n  (Quickcheck) \"Word.andb ((_),/ (_))\" and\n  (Haskell) infixl 7 \"Data_Bits..&.\" and\n  (OCaml) \"Pervasives.(land)\" and\n  (Scala) infixl 3 \"&\"\n| constant \"(OR) :: uint \\<Rightarrow> _\" \\<rightharpoonup>\n  (SML) \"Word.orb ((_),/ (_))\" and\n  (Eval) \"(raise (Fail \\\"Machine dependent code\\\"))\" and\n  (Quickcheck) \"Word.orb ((_),/ (_))\" and\n  (Haskell) infixl 5 \"Data_Bits..|.\" and\n  (OCaml) \"Pervasives.(lor)\" and\n  (Scala) infixl 1 \"|\"\n| constant \"(XOR) :: uint \\<Rightarrow> _\" \\<rightharpoonup>\n  (SML) \"Word.xorb ((_),/ (_))\" and\n  (Eval) \"(raise (Fail \\\"Machine dependent code\\\"))\" and\n  (Quickcheck) \"Word.xorb ((_),/ (_))\" and\n  (Haskell) \"Data'_Bits.xor\" and\n  (OCaml) \"Pervasives.(lxor)\" and\n  (Scala) infixl 2 \"^\""], ["", "definition uint_divmod :: \"uint \\<Rightarrow> uint \\<Rightarrow> uint \\<times> uint\" where\n  \"uint_divmod x y = \n  (if y = 0 then (undefined ((div) :: uint \\<Rightarrow> _) x (0 :: uint), undefined ((mod) :: uint \\<Rightarrow> _) x (0 :: uint)) \n  else (x div y, x mod y))\""], ["", "definition uint_div :: \"uint \\<Rightarrow> uint \\<Rightarrow> uint\" \nwhere \"uint_div x y = fst (uint_divmod x y)\""], ["", "definition uint_mod :: \"uint \\<Rightarrow> uint \\<Rightarrow> uint\" \nwhere \"uint_mod x y = snd (uint_divmod x y)\""], ["", "lemma div_uint_code [code]: \"x div y = (if y = 0 then 0 else uint_div x y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x div y = (if y = 0 then 0 else uint_div x y)", "including undefined_transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. x div y = (if y = 0 then 0 else uint_div x y)", "unfolding uint_divmod_def uint_div_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. x div y =\n    (if y = 0 then 0\n     else fst (if y = 0 then (undefined (div) x 0, undefined (mod) x 0)\n               else (x div y, x mod y)))", "by transfer(simp add: word_div_def)"], ["", "lemma mod_uint_code [code]: \"x mod y = (if y = 0 then x else uint_mod x y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x mod y = (if y = 0 then x else uint_mod x y)", "including undefined_transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. x mod y = (if y = 0 then x else uint_mod x y)", "unfolding uint_mod_def uint_divmod_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. x mod y =\n    (if y = 0 then x\n     else snd (if y = 0 then (undefined (div) x 0, undefined (mod) x 0)\n               else (x div y, x mod y)))", "by transfer(simp add: word_mod_def)"], ["", "definition uint_sdiv :: \"uint \\<Rightarrow> uint \\<Rightarrow> uint\"\nwhere [code del]:\n  \"uint_sdiv x y =\n   (if y = 0 then undefined ((div) :: uint \\<Rightarrow> _) x (0 :: uint)\n    else Abs_uint (Rep_uint x sdiv Rep_uint y))\""], ["", "definition div0_uint :: \"uint \\<Rightarrow> uint\"\nwhere [code del]: \"div0_uint x = undefined ((div) :: uint \\<Rightarrow> _) x (0 :: uint)\""], ["", "declare [[code abort: div0_uint]]"], ["", "definition mod0_uint :: \"uint \\<Rightarrow> uint\"\nwhere [code del]: \"mod0_uint x = undefined ((mod) :: uint \\<Rightarrow> _) x (0 :: uint)\""], ["", "declare [[code abort: mod0_uint]]"], ["", "definition wivs_overflow_uint :: uint \n  where \"wivs_overflow_uint \\<equiv> push_bit (dflt_size - 1) 1\""], ["", "lemma uint_divmod_code [code]:\n  \"uint_divmod x y =\n  (if wivs_overflow_uint \\<le> y then if x < y then (0, x) else (1, x - y)\n   else if y = 0 then (div0_uint x, mod0_uint x)\n   else let q = push_bit 1 (uint_sdiv (drop_bit 1 x) y);\n            r = x - q * y\n        in if r \\<ge> y then (q + 1, r - y) else (q, r))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. uint_divmod x y =\n    (if wivs_overflow_uint \\<le> y then if x < y then (0, x) else (1, x - y)\n     else if y = 0 then (div0_uint x, mod0_uint x)\n          else let q = push_bit 1 (uint_sdiv (drop_bit 1 x) y);\n                   r = x - q * y\n               in if y \\<le> r then (q + 1, r - y) else (q, r))", "proof (cases \\<open>y = 0\\<close>)"], ["proof (state)\ngoal (2 subgoals):\n 1. y = 0 \\<Longrightarrow>\n    uint_divmod x y =\n    (if wivs_overflow_uint \\<le> y then if x < y then (0, x) else (1, x - y)\n     else if y = 0 then (div0_uint x, mod0_uint x)\n          else let q = push_bit 1 (uint_sdiv (drop_bit 1 x) y);\n                   r = x - q * y\n               in if y \\<le> r then (q + 1, r - y) else (q, r))\n 2. y \\<noteq> 0 \\<Longrightarrow>\n    uint_divmod x y =\n    (if wivs_overflow_uint \\<le> y then if x < y then (0, x) else (1, x - y)\n     else if y = 0 then (div0_uint x, mod0_uint x)\n          else let q = push_bit 1 (uint_sdiv (drop_bit 1 x) y);\n                   r = x - q * y\n               in if y \\<le> r then (q + 1, r - y) else (q, r))", "case True"], ["proof (state)\nthis:\n  y = 0\n\ngoal (2 subgoals):\n 1. y = 0 \\<Longrightarrow>\n    uint_divmod x y =\n    (if wivs_overflow_uint \\<le> y then if x < y then (0, x) else (1, x - y)\n     else if y = 0 then (div0_uint x, mod0_uint x)\n          else let q = push_bit 1 (uint_sdiv (drop_bit 1 x) y);\n                   r = x - q * y\n               in if y \\<le> r then (q + 1, r - y) else (q, r))\n 2. y \\<noteq> 0 \\<Longrightarrow>\n    uint_divmod x y =\n    (if wivs_overflow_uint \\<le> y then if x < y then (0, x) else (1, x - y)\n     else if y = 0 then (div0_uint x, mod0_uint x)\n          else let q = push_bit 1 (uint_sdiv (drop_bit 1 x) y);\n                   r = x - q * y\n               in if y \\<le> r then (q + 1, r - y) else (q, r))", "moreover"], ["proof (state)\nthis:\n  y = 0\n\ngoal (2 subgoals):\n 1. y = 0 \\<Longrightarrow>\n    uint_divmod x y =\n    (if wivs_overflow_uint \\<le> y then if x < y then (0, x) else (1, x - y)\n     else if y = 0 then (div0_uint x, mod0_uint x)\n          else let q = push_bit 1 (uint_sdiv (drop_bit 1 x) y);\n                   r = x - q * y\n               in if y \\<le> r then (q + 1, r - y) else (q, r))\n 2. y \\<noteq> 0 \\<Longrightarrow>\n    uint_divmod x y =\n    (if wivs_overflow_uint \\<le> y then if x < y then (0, x) else (1, x - y)\n     else if y = 0 then (div0_uint x, mod0_uint x)\n          else let q = push_bit 1 (uint_sdiv (drop_bit 1 x) y);\n                   r = x - q * y\n               in if y \\<le> r then (q + 1, r - y) else (q, r))", "have \\<open>x \\<ge> 0\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> x", "by transfer simp"], ["proof (state)\nthis:\n  0 \\<le> x\n\ngoal (2 subgoals):\n 1. y = 0 \\<Longrightarrow>\n    uint_divmod x y =\n    (if wivs_overflow_uint \\<le> y then if x < y then (0, x) else (1, x - y)\n     else if y = 0 then (div0_uint x, mod0_uint x)\n          else let q = push_bit 1 (uint_sdiv (drop_bit 1 x) y);\n                   r = x - q * y\n               in if y \\<le> r then (q + 1, r - y) else (q, r))\n 2. y \\<noteq> 0 \\<Longrightarrow>\n    uint_divmod x y =\n    (if wivs_overflow_uint \\<le> y then if x < y then (0, x) else (1, x - y)\n     else if y = 0 then (div0_uint x, mod0_uint x)\n          else let q = push_bit 1 (uint_sdiv (drop_bit 1 x) y);\n                   r = x - q * y\n               in if y \\<le> r then (q + 1, r - y) else (q, r))", "moreover"], ["proof (state)\nthis:\n  0 \\<le> x\n\ngoal (2 subgoals):\n 1. y = 0 \\<Longrightarrow>\n    uint_divmod x y =\n    (if wivs_overflow_uint \\<le> y then if x < y then (0, x) else (1, x - y)\n     else if y = 0 then (div0_uint x, mod0_uint x)\n          else let q = push_bit 1 (uint_sdiv (drop_bit 1 x) y);\n                   r = x - q * y\n               in if y \\<le> r then (q + 1, r - y) else (q, r))\n 2. y \\<noteq> 0 \\<Longrightarrow>\n    uint_divmod x y =\n    (if wivs_overflow_uint \\<le> y then if x < y then (0, x) else (1, x - y)\n     else if y = 0 then (div0_uint x, mod0_uint x)\n          else let q = push_bit 1 (uint_sdiv (drop_bit 1 x) y);\n                   r = x - q * y\n               in if y \\<le> r then (q + 1, r - y) else (q, r))", "have \\<open>wivs_overflow_uint > 0\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < wivs_overflow_uint", "apply (simp add: wivs_overflow_uint_def push_bit_of_1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < 2 ^ (dflt_size - Suc 0)", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < 2 ^ (dflt_size - Suc 0)", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. take_bit dflt_size 0 < take_bit dflt_size (2 ^ (dflt_size - Suc 0))", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  0 < wivs_overflow_uint\n\ngoal (2 subgoals):\n 1. y = 0 \\<Longrightarrow>\n    uint_divmod x y =\n    (if wivs_overflow_uint \\<le> y then if x < y then (0, x) else (1, x - y)\n     else if y = 0 then (div0_uint x, mod0_uint x)\n          else let q = push_bit 1 (uint_sdiv (drop_bit 1 x) y);\n                   r = x - q * y\n               in if y \\<le> r then (q + 1, r - y) else (q, r))\n 2. y \\<noteq> 0 \\<Longrightarrow>\n    uint_divmod x y =\n    (if wivs_overflow_uint \\<le> y then if x < y then (0, x) else (1, x - y)\n     else if y = 0 then (div0_uint x, mod0_uint x)\n          else let q = push_bit 1 (uint_sdiv (drop_bit 1 x) y);\n                   r = x - q * y\n               in if y \\<le> r then (q + 1, r - y) else (q, r))", "ultimately"], ["proof (chain)\npicking this:\n  y = 0\n  0 \\<le> x\n  0 < wivs_overflow_uint", "show ?thesis"], ["proof (prove)\nusing this:\n  y = 0\n  0 \\<le> x\n  0 < wivs_overflow_uint\n\ngoal (1 subgoal):\n 1. uint_divmod x y =\n    (if wivs_overflow_uint \\<le> y then if x < y then (0, x) else (1, x - y)\n     else if y = 0 then (div0_uint x, mod0_uint x)\n          else let q = push_bit 1 (uint_sdiv (drop_bit 1 x) y);\n                   r = x - q * y\n               in if y \\<le> r then (q + 1, r - y) else (q, r))", "by (auto simp add: uint_divmod_def div0_uint_def mod0_uint_def not_less)"], ["proof (state)\nthis:\n  uint_divmod x y =\n  (if wivs_overflow_uint \\<le> y then if x < y then (0, x) else (1, x - y)\n   else if y = 0 then (div0_uint x, mod0_uint x)\n        else let q = push_bit 1 (uint_sdiv (drop_bit 1 x) y); r = x - q * y\n             in if y \\<le> r then (q + 1, r - y) else (q, r))\n\ngoal (1 subgoal):\n 1. y \\<noteq> 0 \\<Longrightarrow>\n    uint_divmod x y =\n    (if wivs_overflow_uint \\<le> y then if x < y then (0, x) else (1, x - y)\n     else if y = 0 then (div0_uint x, mod0_uint x)\n          else let q = push_bit 1 (uint_sdiv (drop_bit 1 x) y);\n                   r = x - q * y\n               in if y \\<le> r then (q + 1, r - y) else (q, r))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. y \\<noteq> 0 \\<Longrightarrow>\n    uint_divmod x y =\n    (if wivs_overflow_uint \\<le> y then if x < y then (0, x) else (1, x - y)\n     else if y = 0 then (div0_uint x, mod0_uint x)\n          else let q = push_bit 1 (uint_sdiv (drop_bit 1 x) y);\n                   r = x - q * y\n               in if y \\<le> r then (q + 1, r - y) else (q, r))", "case False"], ["proof (state)\nthis:\n  y \\<noteq> 0\n\ngoal (1 subgoal):\n 1. y \\<noteq> 0 \\<Longrightarrow>\n    uint_divmod x y =\n    (if wivs_overflow_uint \\<le> y then if x < y then (0, x) else (1, x - y)\n     else if y = 0 then (div0_uint x, mod0_uint x)\n          else let q = push_bit 1 (uint_sdiv (drop_bit 1 x) y);\n                   r = x - q * y\n               in if y \\<le> r then (q + 1, r - y) else (q, r))", "then"], ["proof (chain)\npicking this:\n  y \\<noteq> 0", "show ?thesis"], ["proof (prove)\nusing this:\n  y \\<noteq> 0\n\ngoal (1 subgoal):\n 1. uint_divmod x y =\n    (if wivs_overflow_uint \\<le> y then if x < y then (0, x) else (1, x - y)\n     else if y = 0 then (div0_uint x, mod0_uint x)\n          else let q = push_bit 1 (uint_sdiv (drop_bit 1 x) y);\n                   r = x - q * y\n               in if y \\<le> r then (q + 1, r - y) else (q, r))", "including undefined_transfer"], ["proof (prove)\nusing this:\n  y \\<noteq> 0\n\ngoal (1 subgoal):\n 1. uint_divmod x y =\n    (if wivs_overflow_uint \\<le> y then if x < y then (0, x) else (1, x - y)\n     else if y = 0 then (div0_uint x, mod0_uint x)\n          else let q = push_bit 1 (uint_sdiv (drop_bit 1 x) y);\n                   r = x - q * y\n               in if y \\<le> r then (q + 1, r - y) else (q, r))", "unfolding uint_divmod_def uint_sdiv_def div0_uint_def mod0_uint_def\n      wivs_overflow_uint_def"], ["proof (prove)\nusing this:\n  y \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (if y = 0 then (undefined (div) x 0, undefined (mod) x 0)\n     else (x div y, x mod y)) =\n    (if push_bit (dflt_size - 1) 1 \\<le> y\n     then if x < y then (0, x) else (1, x - y)\n     else if y = 0 then (undefined (div) x 0, undefined (mod) x 0)\n          else let q = push_bit 1\n                        (if y = 0 then undefined (div) (drop_bit 1 x) 0\n                         else Abs_uint\n                               (Rep_uint (drop_bit 1 x) sdiv Rep_uint y));\n                   r = x - q * y\n               in if y \\<le> r then (q + 1, r - y) else (q, r))", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y x.\n       y \\<noteq> 0 \\<Longrightarrow>\n       (if y = 0\n        then (map_fun (map_fun Rep_uint (map_fun Rep_uint Abs_uint))\n               (map_fun Abs_uint (map_fun Abs_uint Rep_uint)) undefined\n               (div) x 0,\n              map_fun (map_fun Rep_uint (map_fun Rep_uint Abs_uint))\n               (map_fun Abs_uint (map_fun Abs_uint Rep_uint)) undefined\n               (mod) x 0)\n        else (x div y, x mod y)) =\n       (if push_bit (dflt_size - 1) 1 \\<le> y\n        then if x < y then (0, x) else (1, x - y)\n        else if y = 0\n             then (map_fun (map_fun Rep_uint (map_fun Rep_uint Abs_uint))\n                    (map_fun Abs_uint (map_fun Abs_uint Rep_uint)) undefined\n                    (div) x 0,\n                   map_fun (map_fun Rep_uint (map_fun Rep_uint Abs_uint))\n                    (map_fun Abs_uint (map_fun Abs_uint Rep_uint)) undefined\n                    (mod) x 0)\n             else let q = push_bit 1\n                           (if y = 0\n                            then map_fun\n                                  (map_fun Rep_uint\n                                    (map_fun Rep_uint Abs_uint))\n                                  (map_fun Abs_uint\n                                    (map_fun Abs_uint Rep_uint))\n                                  undefined (div) (drop_bit 1 x) 0\n                            else drop_bit 1 x sdiv y);\n                      r = x - q * y\n                  in if y \\<le> r then (q + 1, r - y) else (q, r))", "apply (simp add: divmod_via_sdivmod push_bit_of_1 shiftl_eq_push_bit shiftr_eq_drop_bit)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  uint_divmod x y =\n  (if wivs_overflow_uint \\<le> y then if x < y then (0, x) else (1, x - y)\n   else if y = 0 then (div0_uint x, mod0_uint x)\n        else let q = push_bit 1 (uint_sdiv (drop_bit 1 x) y); r = x - q * y\n             in if y \\<le> r then (q + 1, r - y) else (q, r))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma uint_sdiv_code [code abstract]:\n  \"Rep_uint (uint_sdiv x y) =\n   (if y = 0 then Rep_uint (undefined ((div) :: uint \\<Rightarrow> _) x (0 :: uint))\n    else Rep_uint x sdiv Rep_uint y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_uint (uint_sdiv x y) =\n    (if y = 0 then Rep_uint (undefined (div) x 0)\n     else Rep_uint x sdiv Rep_uint y)", "unfolding uint_sdiv_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_uint\n     (if y = 0 then undefined (div) x 0\n      else Abs_uint (Rep_uint x sdiv Rep_uint y)) =\n    (if y = 0 then Rep_uint (undefined (div) x 0)\n     else Rep_uint x sdiv Rep_uint y)", "by(simp add: Abs_uint_inverse)"], ["", "text \\<open>\n  Note that we only need a translation for signed division, but not for the remainder\n  because @{thm uint_divmod_code} computes both with division only.\n\\<close>"], ["", "code_printing\n  constant uint_div \\<rightharpoonup>\n  (SML) \"Word.div ((_), (_))\" and\n  (Eval) \"(raise (Fail \\\"Machine dependent code\\\"))\" and\n  (Quickcheck) \"Word.div ((_), (_))\" and\n  (Haskell) \"Prelude.div\"\n| constant uint_mod \\<rightharpoonup>\n  (SML) \"Word.mod ((_), (_))\" and\n  (Eval) \"(raise (Fail \\\"Machine dependent code\\\"))\" and\n  (Quickcheck) \"Word.mod ((_), (_))\" and\n  (Haskell) \"Prelude.mod\"\n| constant uint_divmod \\<rightharpoonup>\n  (Haskell) \"divmod\"\n| constant uint_sdiv \\<rightharpoonup>\n  (OCaml) \"Pervasives.('/)\" and\n  (Scala) \"_ '/ _\""], ["", "definition uint_test_bit :: \"uint \\<Rightarrow> integer \\<Rightarrow> bool\"\nwhere [code del]:\n  \"uint_test_bit x n =\n  (if n < 0 \\<or> dflt_size_integer \\<le> n then undefined (bit :: uint \\<Rightarrow> _) x n\n   else bit x (nat_of_integer n))\""], ["", "lemma test_bit_uint_code [code]:\n  \"bit x n \\<longleftrightarrow> n < dflt_size \\<and> uint_test_bit x (integer_of_nat n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bit x n = (n < dflt_size \\<and> uint_test_bit x (integer_of_nat n))", "including undefined_transfer integer.lifting"], ["proof (prove)\ngoal (1 subgoal):\n 1. bit x n = (n < dflt_size \\<and> uint_test_bit x (integer_of_nat n))", "unfolding uint_test_bit_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. bit x n =\n    (n < dflt_size \\<and>\n     (if integer_of_nat n < 0 \\<or> dflt_size_integer \\<le> integer_of_nat n\n      then undefined bit x (integer_of_nat n)\n      else bit x (nat_of_integer (integer_of_nat n))))", "by (transfer, simp, transfer, simp)"], ["", "lemma uint_test_bit_code [code]:\n  \"uint_test_bit w n =\n  (if n < 0 \\<or> dflt_size_integer \\<le> n then undefined (bit :: uint \\<Rightarrow> _) w n else bit (Rep_uint w) (nat_of_integer n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. uint_test_bit w n =\n    (if n < 0 \\<or> dflt_size_integer \\<le> n then undefined bit w n\n     else bit (Rep_uint w) (nat_of_integer n))", "unfolding uint_test_bit_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if n < 0 \\<or> dflt_size_integer \\<le> n then undefined bit w n\n     else bit w (nat_of_integer n)) =\n    (if n < 0 \\<or> dflt_size_integer \\<le> n then undefined bit w n\n     else bit (Rep_uint w) (nat_of_integer n))", "by(simp add: bit_uint.rep_eq)"], ["", "code_printing constant uint_test_bit \\<rightharpoonup>\n  (SML) \"Uint.test'_bit\" and\n  (Eval) \"(raise (Fail \\\"Machine dependent code\\\"))\" and\n  (Quickcheck) \"Uint.test'_bit\" and\n  (Haskell) \"Data'_Bits.testBitBounded\" and\n  (OCaml) \"Uint.test'_bit\" and\n  (Scala) \"Uint.test'_bit\""], ["", "definition uint_set_bit :: \"uint \\<Rightarrow> integer \\<Rightarrow> bool \\<Rightarrow> uint\"\nwhere [code del]:\n  \"uint_set_bit x n b =\n  (if n < 0 \\<or> dflt_size_integer \\<le> n then undefined (set_bit :: uint \\<Rightarrow> _) x n b\n   else set_bit x (nat_of_integer n) b)\""], ["", "lemma set_bit_uint_code [code]:\n  \"set_bit x n b = (if n < dflt_size then uint_set_bit x (integer_of_nat n) b else x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_bit_class.set_bit x n b =\n    (if n < dflt_size then uint_set_bit x (integer_of_nat n) b else x)", "including undefined_transfer integer.lifting"], ["proof (prove)\ngoal (1 subgoal):\n 1. set_bit_class.set_bit x n b =\n    (if n < dflt_size then uint_set_bit x (integer_of_nat n) b else x)", "unfolding uint_set_bit_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. set_bit_class.set_bit x n b =\n    (if n < dflt_size\n     then if integer_of_nat n < 0 \\<or>\n             dflt_size_integer \\<le> integer_of_nat n\n          then undefined set_bit_class.set_bit x (integer_of_nat n) b\n          else set_bit_class.set_bit x (nat_of_integer (integer_of_nat n)) b\n     else x)", "by (transfer) (auto cong: conj_cong simp add: not_less set_bit_beyond word_size)"], ["", "lemma uint_set_bit_code [code abstract]:\n  \"Rep_uint (uint_set_bit w n b) = \n  (if n < 0 \\<or> dflt_size_integer \\<le> n then Rep_uint (undefined (set_bit :: uint \\<Rightarrow> _) w n b)\n   else set_bit (Rep_uint w) (nat_of_integer n) b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_uint (uint_set_bit w n b) =\n    (if n < 0 \\<or> dflt_size_integer \\<le> n\n     then Rep_uint (undefined set_bit_class.set_bit w n b)\n     else set_bit_class.set_bit (Rep_uint w) (nat_of_integer n) b)", "including undefined_transfer integer.lifting"], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_uint (uint_set_bit w n b) =\n    (if n < 0 \\<or> dflt_size_integer \\<le> n\n     then Rep_uint (undefined set_bit_class.set_bit w n b)\n     else set_bit_class.set_bit (Rep_uint w) (nat_of_integer n) b)", "unfolding uint_set_bit_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_uint\n     (if n < 0 \\<or> dflt_size_integer \\<le> n\n      then undefined set_bit_class.set_bit w n b\n      else set_bit_class.set_bit w (nat_of_integer n) b) =\n    (if n < 0 \\<or> dflt_size_integer \\<le> n\n     then Rep_uint (undefined set_bit_class.set_bit w n b)\n     else set_bit_class.set_bit (Rep_uint w) (nat_of_integer n) b)", "by transfer simp"], ["", "code_printing constant uint_set_bit \\<rightharpoonup>\n  (SML) \"Uint.set'_bit\" and\n  (Eval) \"(raise (Fail \\\"Machine dependent code\\\"))\" and\n  (Quickcheck) \"Uint.set'_bit\" and\n  (Haskell) \"Data'_Bits.setBitBounded\" and\n  (OCaml) \"Uint.set'_bit\" and\n  (Scala) \"Uint.set'_bit\""], ["", "lift_definition uint_set_bits :: \"(nat \\<Rightarrow> bool) \\<Rightarrow> uint \\<Rightarrow> nat \\<Rightarrow> uint\" is set_bits_aux"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma uint_set_bits_code [code]:\n  \"uint_set_bits f w n =\n  (if n = 0 then w \n   else let n' = n - 1 in uint_set_bits f (push_bit 1 w OR (if f n' then 1 else 0)) n')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. uint_set_bits f w n =\n    (if n = 0 then w\n     else let n' = n - 1\n          in uint_set_bits f (push_bit 1 w OR (if f n' then 1 else 0)) n')", "apply (transfer fixing: n)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f w.\n       set_bits_aux f w n =\n       (if n = 0 then w\n        else let n' = n - 1\n             in set_bits_aux f (push_bit 1 w OR (if f n' then 1 else 0)) n')", "apply (cases n)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>f w.\n       n = 0 \\<Longrightarrow>\n       set_bits_aux f w n =\n       (if n = 0 then w\n        else let n' = n - 1\n             in set_bits_aux f (push_bit 1 w OR (if f n' then 1 else 0)) n')\n 2. \\<And>f w nat.\n       n = Suc nat \\<Longrightarrow>\n       set_bits_aux f w n =\n       (if n = 0 then w\n        else let n' = n - 1\n             in set_bits_aux f (push_bit 1 w OR (if f n' then 1 else 0)) n')", "apply (simp_all add: shiftl_eq_push_bit)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma set_bits_uint [code]:\n  \"(BITS n. f n) = uint_set_bits f 0 dflt_size\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (BITS n. f n) = uint_set_bits f 0 dflt_size", "by transfer (simp add: set_bits_conv_set_bits_aux)"], ["", "lemma lsb_code [code]: fixes x :: uint shows \"lsb x = bit x 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lsb x = bit x 0", "by transfer (simp add: lsb_word_eq)"], ["", "definition uint_shiftl :: \"uint \\<Rightarrow> integer \\<Rightarrow> uint\"\nwhere [code del]:\n  \"uint_shiftl x n = (if n < 0 \\<or> dflt_size_integer \\<le> n then undefined (push_bit :: nat \\<Rightarrow> uint \\<Rightarrow> _) x n else push_bit (nat_of_integer n) x)\""], ["", "lemma shiftl_uint_code [code]: \"push_bit n x = (if n < dflt_size then uint_shiftl x (integer_of_nat n) else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. push_bit n x =\n    (if n < dflt_size then uint_shiftl x (integer_of_nat n) else 0)", "including undefined_transfer integer.lifting"], ["proof (prove)\ngoal (1 subgoal):\n 1. push_bit n x =\n    (if n < dflt_size then uint_shiftl x (integer_of_nat n) else 0)", "unfolding uint_shiftl_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. push_bit n x =\n    (if n < dflt_size\n     then if integer_of_nat n < 0 \\<or>\n             dflt_size_integer \\<le> integer_of_nat n\n          then undefined push_bit x (integer_of_nat n)\n          else push_bit (nat_of_integer (integer_of_nat n)) x\n     else 0)", "by (transfer fixing: n) simp"], ["", "lemma uint_shiftl_code [code abstract]:\n  \"Rep_uint (uint_shiftl w n) =\n  (if n < 0 \\<or> dflt_size_integer \\<le> n then Rep_uint (undefined (push_bit :: nat \\<Rightarrow> uint \\<Rightarrow> _) w n) else push_bit (nat_of_integer n) (Rep_uint w))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_uint (uint_shiftl w n) =\n    (if n < 0 \\<or> dflt_size_integer \\<le> n\n     then Rep_uint (undefined push_bit w n)\n     else push_bit (nat_of_integer n) (Rep_uint w))", "including undefined_transfer integer.lifting"], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_uint (uint_shiftl w n) =\n    (if n < 0 \\<or> dflt_size_integer \\<le> n\n     then Rep_uint (undefined push_bit w n)\n     else push_bit (nat_of_integer n) (Rep_uint w))", "unfolding uint_shiftl_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_uint\n     (if n < 0 \\<or> dflt_size_integer \\<le> n then undefined push_bit w n\n      else push_bit (nat_of_integer n) w) =\n    (if n < 0 \\<or> dflt_size_integer \\<le> n\n     then Rep_uint (undefined push_bit w n)\n     else push_bit (nat_of_integer n) (Rep_uint w))", "by transfer simp"], ["", "code_printing constant uint_shiftl \\<rightharpoonup>\n  (SML) \"Uint.shiftl\" and\n  (Eval) \"(raise (Fail \\\"Machine dependent code\\\"))\" and\n  (Quickcheck) \"Uint.shiftl\" and\n  (Haskell) \"Data'_Bits.shiftlBounded\" and\n  (OCaml) \"Uint.shiftl\" and\n  (Scala) \"Uint.shiftl\""], ["", "definition uint_shiftr :: \"uint \\<Rightarrow> integer \\<Rightarrow> uint\"\nwhere [code del]:\n  \"uint_shiftr x n = (if n < 0 \\<or> dflt_size_integer \\<le> n then undefined (drop_bit :: nat \\<Rightarrow> uint \\<Rightarrow> _) x n else drop_bit (nat_of_integer n) x)\""], ["", "lemma shiftr_uint_code [code]: \"drop_bit n x = (if n < dflt_size then uint_shiftr x (integer_of_nat n) else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. drop_bit n x =\n    (if n < dflt_size then uint_shiftr x (integer_of_nat n) else 0)", "including undefined_transfer integer.lifting"], ["proof (prove)\ngoal (1 subgoal):\n 1. drop_bit n x =\n    (if n < dflt_size then uint_shiftr x (integer_of_nat n) else 0)", "unfolding uint_shiftr_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. drop_bit n x =\n    (if n < dflt_size\n     then if integer_of_nat n < 0 \\<or>\n             dflt_size_integer \\<le> integer_of_nat n\n          then undefined drop_bit x (integer_of_nat n)\n          else drop_bit (nat_of_integer (integer_of_nat n)) x\n     else 0)", "by (transfer fixing: n) simp"], ["", "lemma uint_shiftr_code [code abstract]:\n  \"Rep_uint (uint_shiftr w n) =\n  (if n < 0 \\<or> dflt_size_integer \\<le> n then Rep_uint (undefined (drop_bit :: nat \\<Rightarrow> uint \\<Rightarrow> _) w n) else drop_bit (nat_of_integer n) (Rep_uint w))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_uint (uint_shiftr w n) =\n    (if n < 0 \\<or> dflt_size_integer \\<le> n\n     then Rep_uint (undefined drop_bit w n)\n     else drop_bit (nat_of_integer n) (Rep_uint w))", "including undefined_transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_uint (uint_shiftr w n) =\n    (if n < 0 \\<or> dflt_size_integer \\<le> n\n     then Rep_uint (undefined drop_bit w n)\n     else drop_bit (nat_of_integer n) (Rep_uint w))", "unfolding uint_shiftr_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_uint\n     (if n < 0 \\<or> dflt_size_integer \\<le> n then undefined drop_bit w n\n      else drop_bit (nat_of_integer n) w) =\n    (if n < 0 \\<or> dflt_size_integer \\<le> n\n     then Rep_uint (undefined drop_bit w n)\n     else drop_bit (nat_of_integer n) (Rep_uint w))", "by transfer simp"], ["", "code_printing constant uint_shiftr \\<rightharpoonup>\n  (SML) \"Uint.shiftr\" and\n  (Eval) \"(raise (Fail \\\"Machine dependent code\\\"))\" and\n  (Quickcheck) \"Uint.shiftr\" and\n  (Haskell) \"Data'_Bits.shiftrBounded\" and\n  (OCaml) \"Uint.shiftr\" and\n  (Scala) \"Uint.shiftr\""], ["", "definition uint_sshiftr :: \"uint \\<Rightarrow> integer \\<Rightarrow> uint\"\nwhere [code del]:\n  \"uint_sshiftr x n =\n  (if n < 0 \\<or> dflt_size_integer \\<le> n then undefined sshiftr_uint x n else sshiftr_uint x (nat_of_integer n))\""], ["", "lemma sshiftr_uint_code [code]:\n  \"x >>> n = \n  (if n < dflt_size then uint_sshiftr x (integer_of_nat n) else \n    if bit x wivs_index then -1 else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x >>> n =\n    (if n < dflt_size then uint_sshiftr x (integer_of_nat n)\n     else if bit x wivs_index then - 1 else 0)", "including undefined_transfer integer.lifting"], ["proof (prove)\ngoal (1 subgoal):\n 1. x >>> n =\n    (if n < dflt_size then uint_sshiftr x (integer_of_nat n)\n     else if bit x wivs_index then - 1 else 0)", "unfolding uint_sshiftr_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. x >>> n =\n    (if n < dflt_size\n     then if integer_of_nat n < 0 \\<or>\n             dflt_size_integer \\<le> integer_of_nat n\n          then undefined (>>>) x (integer_of_nat n)\n          else x >>> nat_of_integer (integer_of_nat n)\n     else if bit x wivs_index then - 1 else 0)", "by transfer(simp add: not_less signed_drop_bit_beyond word_size wivs_index_def)"], ["", "lemma uint_sshiftr_code [code abstract]:\n  \"Rep_uint (uint_sshiftr w n) =\n  (if n < 0 \\<or> dflt_size_integer \\<le> n then Rep_uint (undefined sshiftr_uint w n) else signed_drop_bit (nat_of_integer n) (Rep_uint w))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_uint (uint_sshiftr w n) =\n    (if n < 0 \\<or> dflt_size_integer \\<le> n\n     then Rep_uint (undefined (>>>) w n)\n     else signed_drop_bit (nat_of_integer n) (Rep_uint w))", "including undefined_transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_uint (uint_sshiftr w n) =\n    (if n < 0 \\<or> dflt_size_integer \\<le> n\n     then Rep_uint (undefined (>>>) w n)\n     else signed_drop_bit (nat_of_integer n) (Rep_uint w))", "unfolding uint_sshiftr_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_uint\n     (if n < 0 \\<or> dflt_size_integer \\<le> n then undefined (>>>) w n\n      else w >>> nat_of_integer n) =\n    (if n < 0 \\<or> dflt_size_integer \\<le> n\n     then Rep_uint (undefined (>>>) w n)\n     else signed_drop_bit (nat_of_integer n) (Rep_uint w))", "by transfer simp"], ["", "code_printing constant uint_sshiftr \\<rightharpoonup>\n  (SML) \"Uint.shiftr'_signed\" and\n  (Eval) \"(raise (Fail \\\"Machine dependent code\\\"))\" and\n  (Quickcheck) \"Uint.shiftr'_signed\" and\n  (Haskell) \n    \"(Prelude.fromInteger (Prelude.toInteger (Data'_Bits.shiftrBounded (Prelude.fromInteger (Prelude.toInteger _) :: Uint.Int) _)) :: Uint.Word)\" and\n  (OCaml) \"Uint.shiftr'_signed\" and\n  (Scala) \"Uint.shiftr'_signed\""], ["", "lemma uint_msb_test_bit: \"msb x \\<longleftrightarrow> bit (x :: uint) wivs_index\""], ["proof (prove)\ngoal (1 subgoal):\n 1. msb x = bit x wivs_index", "by transfer (simp add: msb_word_iff_bit wivs_index_def)"], ["", "lemma msb_uint_code [code]: \"msb x \\<longleftrightarrow> uint_test_bit x wivs_index_integer\""], ["proof (prove)\ngoal (1 subgoal):\n 1. msb x = uint_test_bit x wivs_index_integer", "apply(simp add: uint_test_bit_def uint_msb_test_bit \n  wivs_index_integer_code dflt_size_integer_def wivs_index_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (of_nat dflt_size < 1 \\<longrightarrow>\n     bit x (dflt_size - Suc 0) =\n     undefined bit x (of_nat dflt_size - 1)) \\<and>\n    (\\<not> of_nat dflt_size < 1 \\<longrightarrow>\n     bit x (dflt_size - Suc 0) =\n     bit x (nat_of_integer (of_nat dflt_size - 1)))", "by (metis (full_types) One_nat_def dflt_size(2) less_iff_diff_less_0 \n    nat_of_integer_of_nat of_nat_1 of_nat_diff of_nat_less_0_iff wivs_index_def)"], ["", "lemma uint_of_int_code [code]: \"uint_of_int i = (BITS n. bit i n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. uint_of_int i = (BITS n. bit i n)", "by transfer (simp add: word_of_int_conv_set_bits)"], ["", "section \\<open>Quickcheck setup\\<close>"], ["", "definition uint_of_natural :: \"natural \\<Rightarrow> uint\"\nwhere \"uint_of_natural x \\<equiv> Uint (integer_of_natural x)\""], ["", "instantiation uint :: \"{random, exhaustive, full_exhaustive}\" begin"], ["", "definition \"random_uint \\<equiv> qc_random_cnv uint_of_natural\""], ["", "definition \"exhaustive_uint \\<equiv> qc_exhaustive_cnv uint_of_natural\""], ["", "definition \"full_exhaustive_uint \\<equiv> qc_full_exhaustive_cnv uint_of_natural\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(uint, exhaustive_class) &&&\n    OFCLASS(uint, full_exhaustive_class) &&& OFCLASS(uint, random_class)", ".."], ["", "end"], ["", "instantiation uint :: narrowing begin"], ["", "interpretation quickcheck_narrowing_samples\n  \"\\<lambda>i. (Uint i, Uint (- i))\" \"0\"\n  \"Typerep.Typerep (STR ''Uint.uint'') []\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "definition \"narrowing_uint d = qc_narrowing_drawn_from (narrowing_samples d) d\""], ["", "declare [[code drop: \"partial_term_of :: uint itself \\<Rightarrow> _\"]]"], ["", "lemmas partial_term_of_uint [code] = partial_term_of_code"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(uint, narrowing_class)", ".."], ["", "end"], ["", "no_notation sshiftr_uint (infixl \">>>\" 55)"], ["", "end"]]}