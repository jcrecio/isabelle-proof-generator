{"file_name": "/home/qj213/afp-2021-10-22/thys/Native_Word/Uint64.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Native_Word", "problem_names": ["lemmas [code] = less_uint64.rep_eq less_eq_uint64.rep_eq", "lemma [transfer_rule]:\n  \"((=) ===> cr_uint64) of_bool of_bool\"", "lemma transfer_rule_numeral_uint [transfer_rule]:\n  \"((=) ===> cr_uint64) numeral numeral\"", "lemma [transfer_rule]:\n  \\<open>(cr_uint64 ===> (\\<longleftrightarrow>)) even ((dvd) 2 :: uint64 \\<Rightarrow> bool)\\<close>", "lemma [code]:\n  \\<open>take_bit n a = a AND mask n\\<close> for a :: uint64", "lemma [code]:\n  \\<open>mask (Suc n) = push_bit n (1 :: uint64) OR mask n\\<close>\n  \\<open>mask 0 = (0 :: uint64)\\<close>", "lemma test_bit_uint64_transfer [transfer_rule]:\n  \\<open>(cr_uint64 ===> (=)) bit (!!)\\<close>", "lemma shiftl_uint64_transfer [transfer_rule]:\n  \\<open>(cr_uint64 ===> (=) ===> cr_uint64) (\\<lambda>k n. push_bit n k) (<<)\\<close>", "lemma shiftr_uint64_transfer [transfer_rule]:\n  \\<open>(cr_uint64 ===> (=) ===> cr_uint64) (\\<lambda>k n. drop_bit n k) (>>)\\<close>", "lemmas [code] = bit_uint64.rep_eq lsb_uint64.rep_eq msb_uint64.rep_eq", "lemmas [code] = equal_uint64.rep_eq", "lemmas [code] = size_uint64.rep_eq", "lemma Rep_uint64_numeral [simp]: \"Rep_uint64 (numeral n) = numeral n\"", "lemma numeral_uint64_transfer [transfer_rule]:\n  \"(rel_fun (=) cr_uint64) numeral numeral\"", "lemma numeral_uint64 [code_unfold]: \"numeral n = Uint64 (numeral n)\"", "lemma Rep_uint64_neg_numeral [simp]: \"Rep_uint64 (- numeral n) = - numeral n\"", "lemma neg_numeral_uint64 [code_unfold]: \"- numeral n = Uint64 (- numeral n)\"", "lemma Abs_uint64_numeral [code_post]: \"Abs_uint64 (numeral n) = numeral n\"", "lemma Abs_uint64_0 [code_post]: \"Abs_uint64 0 = 0\"", "lemma Abs_uint64_1 [code_post]: \"Abs_uint64 1 = 1\"", "lemma Uint64_code [code]:\n  \"Uint64 i = \n  (let i' = i AND 0xFFFFFFFFFFFFFFFF\n   in if bit i' 63 then Uint64_signed (i' - 0x10000000000000000) else Uint64_signed i')\"", "lemma Uint64_signed_code [code abstract]:\n  \"Rep_uint64 (Uint64_signed i) = \n  (if i < -(0x8000000000000000) \\<or> i \\<ge> 0x8000000000000000 then Rep_uint64 (undefined Uint64 i) else word_of_int (int_of_integer_symbolic i))\"", "lemma Rep_uint64'_transfer [transfer_rule]:\n  \"rel_fun cr_uint64 (=) (\\<lambda>x. x) Rep_uint64'\"", "lemma Rep_uint64'_code [code]: \"Rep_uint64' x = (BITS n. bit x n)\"", "lemma Abs_uint64'_code [code]:\n  \"Abs_uint64' x = Uint64 (integer_of_int (uint x))\"", "lemma term_of_uint64_code [code]:\n  defines \"TR \\<equiv> typerep.Typerep\" and \"bit0 \\<equiv> STR ''Numeral_Type.bit0''\" \n  shows\n  \"term_of_class.term_of x = \n   Code_Evaluation.App (Code_Evaluation.Const (STR ''Uint64.uint64.Abs_uint64'') (TR (STR ''fun'') [TR (STR ''Word.word'') [TR bit0 [TR bit0 [TR bit0 [TR bit0 [TR bit0 [TR bit0 [TR (STR ''Numeral_Type.num1'') []]]]]]]], TR (STR ''Uint64.uint64'') []]))\n       (term_of_class.term_of (Rep_uint64' x))\"", "lemma div_uint64_code [code]: \"x div y = (if y = 0 then 0 else uint64_div x y)\"", "lemma mod_uint64_code [code]: \"x mod y = (if y = 0 then x else uint64_mod x y)\"", "lemma uint64_divmod_code [code]:\n  \"uint64_divmod x y =\n  (if 0x8000000000000000 \\<le> y then if x < y then (0, x) else (1, x - y)\n   else if y = 0 then (div0_uint64 x, mod0_uint64 x)\n   else let q = push_bit 1 (uint64_sdiv (drop_bit 1 x) y);\n            r = x - q * y\n        in if r \\<ge> y then (q + 1, r - y) else (q, r))\"", "lemma uint64_sdiv_code [code abstract]:\n  \"Rep_uint64 (uint64_sdiv x y) =\n   (if y = 0 then Rep_uint64 (undefined ((div) :: uint64 \\<Rightarrow> _) x (0 :: uint64))\n    else Rep_uint64 x sdiv Rep_uint64 y)\"", "lemma bit_uint64_code [code]:\n  \"bit x n \\<longleftrightarrow> n < 64 \\<and> uint64_test_bit x (integer_of_nat n)\"", "lemma uint64_test_bit_code [code]:\n  \"uint64_test_bit w n =\n  (if n < 0 \\<or> 63 < n then undefined (bit :: uint64 \\<Rightarrow> _) w n else bit (Rep_uint64 w) (nat_of_integer n))\"", "lemma set_bit_uint64_code [code]:\n  \"set_bit x n b = (if n < 64 then uint64_set_bit x (integer_of_nat n) b else x)\"", "lemma uint64_set_bit_code [code abstract]:\n  \"Rep_uint64 (uint64_set_bit w n b) = \n  (if n < 0 \\<or> 63 < n then Rep_uint64 (undefined (set_bit :: uint64 \\<Rightarrow> _) w n b)\n   else set_bit (Rep_uint64 w) (nat_of_integer n) b)\"", "lemma uint64_set_bits_code [code]:\n  \"uint64_set_bits f w n =\n  (if n = 0 then w \n   else let n' = n - 1 in uint64_set_bits f (push_bit 1 w OR (if f n' then 1 else 0)) n')\"", "lemma set_bits_uint64 [code]:\n  \"(BITS n. f n) = uint64_set_bits f 0 64\"", "lemma lsb_code [code]: fixes x :: uint64 shows \"lsb x = bit x 0\"", "lemma shiftl_uint64_code [code]: \"push_bit n x = (if n < 64 then uint64_shiftl x (integer_of_nat n) else 0)\"", "lemma uint64_shiftl_code [code abstract]:\n  \"Rep_uint64 (uint64_shiftl w n) =\n  (if n < 0 \\<or> 64 \\<le> n then Rep_uint64 (undefined (push_bit :: nat \\<Rightarrow> uint64 \\<Rightarrow> _) w n) else push_bit (nat_of_integer n) (Rep_uint64 w))\"", "lemma shiftr_uint64_code [code]: \"drop_bit n x = (if n < 64 then uint64_shiftr x (integer_of_nat n) else 0)\"", "lemma uint64_shiftr_code [code abstract]:\n  \"Rep_uint64 (uint64_shiftr w n) =\n  (if n < 0 \\<or> 64 \\<le> n then Rep_uint64 (undefined (drop_bit :: nat \\<Rightarrow> uint64 \\<Rightarrow> _) w n) else drop_bit (nat_of_integer n) (Rep_uint64 w))\"", "lemma sshiftr_uint64_code [code]:\n  \"x >>> n = \n  (if n < 64 then uint64_sshiftr x (integer_of_nat n) else if bit x 63 then - 1 else 0)\"", "lemma uint64_sshiftr_code [code abstract]:\n  \"Rep_uint64 (uint64_sshiftr w n) =\n  (if n < 0 \\<or> 64 \\<le> n then Rep_uint64 (undefined sshiftr_uint64 w n) else signed_drop_bit (nat_of_integer n) (Rep_uint64 w))\"", "lemma uint64_msb_test_bit: \"msb x \\<longleftrightarrow> bit (x :: uint64) 63\"", "lemma msb_uint64_code [code]: \"msb x \\<longleftrightarrow> uint64_test_bit x 63\"", "lemma uint64_of_int_code [code]: \"uint64_of_int i = Uint64 (integer_of_int i)\"", "lemma int_of_uint64_code [code]:\n  \"int_of_uint64 x = int_of_integer (integer_of_uint64 x)\"", "lemma nat_of_uint64_code [code]:\n  \"nat_of_uint64 x = nat_of_integer (integer_of_uint64 x)\"", "lemma integer_of_uint64_signed_code [code]:\n  \"integer_of_uint64_signed n =\n  (if bit n 63 then undefined integer_of_uint64 n else integer_of_int (uint (Rep_uint64' n)))\"", "lemma integer_of_uint64_code [code]:\n  \"integer_of_uint64 n =\n  (if bit n 63 then integer_of_uint64_signed (n AND 0x7FFFFFFFFFFFFFFF) OR 0x8000000000000000 else integer_of_uint64_signed n)\"", "lemmas partial_term_of_uint64 [code] = partial_term_of_code"], "translations": [["", "lemmas [code] = less_uint64.rep_eq less_eq_uint64.rep_eq"], ["", "context\n  includes lifting_syntax\n  notes\n    transfer_rule_of_bool [transfer_rule]\n    transfer_rule_numeral [transfer_rule]\nbegin"], ["", "lemma [transfer_rule]:\n  \"((=) ===> cr_uint64) of_bool of_bool\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((=) ===> cr_uint64) of_bool of_bool", "by transfer_prover"], ["", "lemma transfer_rule_numeral_uint [transfer_rule]:\n  \"((=) ===> cr_uint64) numeral numeral\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((=) ===> cr_uint64) numeral numeral", "by transfer_prover"], ["", "lemma [transfer_rule]:\n  \\<open>(cr_uint64 ===> (\\<longleftrightarrow>)) even ((dvd) 2 :: uint64 \\<Rightarrow> bool)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (cr_uint64 ===> (=)) even ((dvd) 2)", "by (unfold dvd_def) transfer_prover"], ["", "end"], ["", "instantiation uint64 :: semiring_bits\nbegin"], ["", "lift_definition bit_uint64 :: \\<open>uint64 \\<Rightarrow> nat \\<Rightarrow> bool\\<close> is bit"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(uint64, semiring_bits_class)", "by (standard; transfer)\n    (fact bit_iff_odd even_iff_mod_2_eq_zero odd_iff_mod_2_eq_one odd_one bits_induct\n       bits_div_0 bits_div_by_1 bits_mod_div_trivial even_succ_div_2\n       even_mask_div_iff exp_div_exp_eq div_exp_eq mod_exp_eq mult_exp_mod_exp_eq\n       div_exp_mod_exp_eq even_mult_exp_div_exp_iff)+"], ["", "end"], ["", "instantiation uint64 :: semiring_bit_shifts\nbegin"], ["", "lift_definition push_bit_uint64 :: \\<open>nat \\<Rightarrow> uint64 \\<Rightarrow> uint64\\<close> is push_bit"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition drop_bit_uint64 :: \\<open>nat \\<Rightarrow> uint64 \\<Rightarrow> uint64\\<close> is drop_bit"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition take_bit_uint64 :: \\<open>nat \\<Rightarrow> uint64 \\<Rightarrow> uint64\\<close> is take_bit"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(uint64, semiring_bit_shifts_class)", "by (standard; transfer)\n  (fact push_bit_eq_mult drop_bit_eq_div take_bit_eq_mod)+"], ["", "end"], ["", "instantiation uint64 :: ring_bit_operations\nbegin"], ["", "lift_definition not_uint64 :: \\<open>uint64 \\<Rightarrow> uint64\\<close> is NOT"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition and_uint64 :: \\<open>uint64 \\<Rightarrow> uint64 \\<Rightarrow> uint64\\<close> is \\<open>(AND)\\<close>"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition or_uint64 :: \\<open>uint64 \\<Rightarrow> uint64 \\<Rightarrow> uint64\\<close> is \\<open>(OR)\\<close>"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition xor_uint64 :: \\<open>uint64 \\<Rightarrow> uint64 \\<Rightarrow> uint64\\<close> is \\<open>(XOR)\\<close>"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition mask_uint64 :: \\<open>nat \\<Rightarrow> uint64\\<close> is mask"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(uint64, ring_bit_operations_class)", "by (standard; transfer)\n  (simp_all add: bit_and_iff bit_or_iff bit_xor_iff bit_not_iff minus_eq_not_minus_1 mask_eq_decr_exp)"], ["", "end"], ["", "lemma [code]:\n  \\<open>take_bit n a = a AND mask n\\<close> for a :: uint64"], ["proof (prove)\ngoal (1 subgoal):\n 1. take_bit n a = a AND mask n", "by (fact take_bit_eq_mask)"], ["", "lemma [code]:\n  \\<open>mask (Suc n) = push_bit n (1 :: uint64) OR mask n\\<close>\n  \\<open>mask 0 = (0 :: uint64)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. mask (Suc n) = push_bit n 1 OR mask n &&& mask 0 = 0", "by (simp_all add: mask_Suc_exp push_bit_of_1)"], ["", "instance uint64 :: semiring_bit_syntax"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(uint64, semiring_bit_syntax_class)", ".."], ["", "context\n  includes lifting_syntax\nbegin"], ["", "lemma test_bit_uint64_transfer [transfer_rule]:\n  \\<open>(cr_uint64 ===> (=)) bit (!!)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (cr_uint64 ===> (=)) bit (!!)", "unfolding test_bit_eq_bit"], ["proof (prove)\ngoal (1 subgoal):\n 1. (cr_uint64 ===> (=)) bit bit", "by transfer_prover"], ["", "lemma shiftl_uint64_transfer [transfer_rule]:\n  \\<open>(cr_uint64 ===> (=) ===> cr_uint64) (\\<lambda>k n. push_bit n k) (<<)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (cr_uint64 ===> (=) ===> cr_uint64) (\\<lambda>k n. push_bit n k) (<<)", "unfolding shiftl_eq_push_bit"], ["proof (prove)\ngoal (1 subgoal):\n 1. (cr_uint64 ===> (=) ===> cr_uint64) (\\<lambda>k n. push_bit n k)\n     (\\<lambda>a n. push_bit n a)", "by transfer_prover"], ["", "lemma shiftr_uint64_transfer [transfer_rule]:\n  \\<open>(cr_uint64 ===> (=) ===> cr_uint64) (\\<lambda>k n. drop_bit n k) (>>)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (cr_uint64 ===> (=) ===> cr_uint64) (\\<lambda>k n. drop_bit n k) (>>)", "unfolding shiftr_eq_drop_bit"], ["proof (prove)\ngoal (1 subgoal):\n 1. (cr_uint64 ===> (=) ===> cr_uint64) (\\<lambda>k n. drop_bit n k)\n     (\\<lambda>a n. drop_bit n a)", "by transfer_prover"], ["", "end"], ["", "instantiation uint64 :: lsb\nbegin"], ["", "lift_definition lsb_uint64 :: \\<open>uint64 \\<Rightarrow> bool\\<close> is lsb"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(uint64, lsb_class)", "by (standard; transfer)\n  (fact lsb_odd)"], ["", "end"], ["", "instantiation uint64 :: msb\nbegin"], ["", "lift_definition msb_uint64 :: \\<open>uint64 \\<Rightarrow> bool\\<close> is msb"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(uint64, msb_class)", ".."], ["", "end"], ["", "instantiation uint64 :: set_bit\nbegin"], ["", "lift_definition set_bit_uint64 :: \\<open>uint64 \\<Rightarrow> nat \\<Rightarrow> bool \\<Rightarrow> uint64\\<close> is set_bit"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(uint64, set_bit_class)", "apply standard"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a m b n.\n       bit (set_bit_class.set_bit a m b) n =\n       ((if m = n then b else bit a n) \\<and> 2 ^ n \\<noteq> 0)", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a m b n.\n       bit (set_bit_class.set_bit a m b) n =\n       ((if m = n then b else bit a n) \\<and> 2 ^ n \\<noteq> 0)", "apply (simp add: bit_simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "instantiation uint64 :: bit_comprehension begin"], ["", "lift_definition set_bits_uint64 :: \"(nat \\<Rightarrow> bool) \\<Rightarrow> uint64\" is \"set_bits\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(uint64, bit_comprehension_class)", "by (standard; transfer) (fact set_bits_bit_eq)"], ["", "end"], ["", "lemmas [code] = bit_uint64.rep_eq lsb_uint64.rep_eq msb_uint64.rep_eq"], ["", "instantiation uint64 :: equal begin"], ["", "lift_definition equal_uint64 :: \"uint64 \\<Rightarrow> uint64 \\<Rightarrow> bool\" is \"equal_class.equal\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(uint64, equal_class)", "by standard (transfer, simp add: equal_eq)"], ["", "end"], ["", "lemmas [code] = equal_uint64.rep_eq"], ["", "instantiation uint64 :: size begin"], ["", "lift_definition size_uint64 :: \"uint64 \\<Rightarrow> nat\" is \"size\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(uint64, size_class)", ".."], ["", "end"], ["", "lemmas [code] = size_uint64.rep_eq"], ["", "lift_definition sshiftr_uint64 :: \"uint64 \\<Rightarrow> nat \\<Rightarrow> uint64\" (infixl \">>>\" 55) is \\<open>\\<lambda>w n. signed_drop_bit n w\\<close>"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition uint64_of_int :: \"int \\<Rightarrow> uint64\" is \"word_of_int\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "definition uint64_of_nat :: \"nat \\<Rightarrow> uint64\"\nwhere \"uint64_of_nat = uint64_of_int \\<circ> int\""], ["", "lift_definition int_of_uint64 :: \"uint64 \\<Rightarrow> int\" is \"uint\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition nat_of_uint64 :: \"uint64 \\<Rightarrow> nat\" is \"unat\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "definition integer_of_uint64 :: \"uint64 \\<Rightarrow> integer\"\nwhere \"integer_of_uint64 = integer_of_int o int_of_uint64\""], ["", "text \\<open>Use pretty numerals from integer for pretty printing\\<close>"], ["", "context includes integer.lifting begin"], ["", "lift_definition Uint64 :: \"integer \\<Rightarrow> uint64\" is \"word_of_int\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma Rep_uint64_numeral [simp]: \"Rep_uint64 (numeral n) = numeral n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_uint64 (numeral n) = numeral n", "by(induction n)(simp_all add: one_uint64_def Abs_uint64_inverse numeral.simps plus_uint64_def)"], ["", "lemma numeral_uint64_transfer [transfer_rule]:\n  \"(rel_fun (=) cr_uint64) numeral numeral\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_fun (=) cr_uint64 numeral numeral", "by(auto simp add: cr_uint64_def)"], ["", "lemma numeral_uint64 [code_unfold]: \"numeral n = Uint64 (numeral n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. numeral n = Uint64 (numeral n)", "by transfer simp"], ["", "lemma Rep_uint64_neg_numeral [simp]: \"Rep_uint64 (- numeral n) = - numeral n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_uint64 (- numeral n) = - numeral n", "by(simp only: uminus_uint64_def)(simp add: Abs_uint64_inverse)"], ["", "lemma neg_numeral_uint64 [code_unfold]: \"- numeral n = Uint64 (- numeral n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - numeral n = Uint64 (- numeral n)", "by transfer(simp add: cr_uint64_def)"], ["", "end"], ["", "lemma Abs_uint64_numeral [code_post]: \"Abs_uint64 (numeral n) = numeral n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_uint64 (numeral n) = numeral n", "by(induction n)(simp_all add: one_uint64_def numeral.simps plus_uint64_def Abs_uint64_inverse)"], ["", "lemma Abs_uint64_0 [code_post]: \"Abs_uint64 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_uint64 0 = 0", "by(simp add: zero_uint64_def)"], ["", "lemma Abs_uint64_1 [code_post]: \"Abs_uint64 1 = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_uint64 1 = 1", "by(simp add: one_uint64_def)"], ["", "section \\<open>Code setup\\<close>"], ["", "text \\<open> For SML, we generate an implementation of unsigned 64-bit words using \\verb$IntInf.int$.\n  If @{ML \"LargeWord.wordSize > 63\"} of the Isabelle/ML runtime environment holds, then we assume\n  that there is also a \\<open>Word64\\<close> structure available and accordingly replace the implementation\n  for the target \\verb$Eval$.\n\\<close>"], ["", "code_printing code_module \"Uint64\" \\<rightharpoonup> (SML) \\<open>(* Test that words can handle numbers between 0 and 63 *)\nval _ = if 6 <= Word.wordSize then () else raise (Fail (\"wordSize less than 6\"));\n\nstructure Uint64 : sig\n  eqtype uint64;\n  val zero : uint64;\n  val one : uint64;\n  val fromInt : IntInf.int -> uint64;\n  val toInt : uint64 -> IntInf.int;\n  val toLarge : uint64 -> LargeWord.word;\n  val fromLarge : LargeWord.word -> uint64\n  val plus : uint64 -> uint64 -> uint64;\n  val minus : uint64 -> uint64 -> uint64;\n  val times : uint64 -> uint64 -> uint64;\n  val divide : uint64 -> uint64 -> uint64;\n  val modulus : uint64 -> uint64 -> uint64;\n  val negate : uint64 -> uint64;\n  val less_eq : uint64 -> uint64 -> bool;\n  val less : uint64 -> uint64 -> bool;\n  val notb : uint64 -> uint64;\n  val andb : uint64 -> uint64 -> uint64;\n  val orb : uint64 -> uint64 -> uint64;\n  val xorb : uint64 -> uint64 -> uint64;\n  val shiftl : uint64 -> IntInf.int -> uint64;\n  val shiftr : uint64 -> IntInf.int -> uint64;\n  val shiftr_signed : uint64 -> IntInf.int -> uint64;\n  val set_bit : uint64 -> IntInf.int -> bool -> uint64;\n  val test_bit : uint64 -> IntInf.int -> bool;\nend = struct\n\ntype uint64 = IntInf.int;\n\nval mask = 0xFFFFFFFFFFFFFFFF : IntInf.int;\n\nval zero = 0 : IntInf.int;\n\nval one = 1 : IntInf.int;\n\nfun fromInt x = IntInf.andb(x, mask);\n\nfun toInt x = x\n\nfun toLarge x = LargeWord.fromLargeInt (IntInf.toLarge x);\n\nfun fromLarge x = IntInf.fromLarge (LargeWord.toLargeInt x);\n\nfun plus x y = IntInf.andb(IntInf.+(x, y), mask);\n\nfun minus x y = IntInf.andb(IntInf.-(x, y), mask);\n\nfun negate x = IntInf.andb(IntInf.~(x), mask);\n\nfun times x y = IntInf.andb(IntInf.*(x, y), mask);\n\nfun divide x y = IntInf.div(x, y);\n\nfun modulus x y = IntInf.mod(x, y);\n\nfun less_eq x y = IntInf.<=(x, y);\n\nfun less x y = IntInf.<(x, y);\n\nfun notb x = IntInf.andb(IntInf.notb(x), mask);\n\nfun orb x y = IntInf.orb(x, y);\n\nfun andb x y = IntInf.andb(x, y);\n\nfun xorb x y = IntInf.xorb(x, y);\n\nval maxWord = IntInf.pow (2, Word.wordSize);\n\nfun shiftl x n = \n  if n < maxWord then IntInf.andb(IntInf.<< (x, Word.fromLargeInt (IntInf.toLarge n)), mask)\n  else 0;\n\nfun shiftr x n =\n  if n < maxWord then IntInf.~>> (x, Word.fromLargeInt (IntInf.toLarge n))\n  else 0;\n\nval msb_mask = 0x8000000000000000 : IntInf.int;\n\nfun shiftr_signed x i =\n  if IntInf.andb(x, msb_mask) = 0 then shiftr x i\n  else if i >= 64 then 0xFFFFFFFFFFFFFFFF\n  else let\n    val x' = shiftr x i\n    val m' = IntInf.andb(IntInf.<<(mask, Word.max(0w64 - Word.fromLargeInt (IntInf.toLarge i), 0w0)), mask)\n  in IntInf.orb(x', m') end;\n\nfun test_bit x n =\n  if n < maxWord then IntInf.andb (x, IntInf.<< (1, Word.fromLargeInt (IntInf.toLarge n))) <> 0\n  else false;\n\nfun set_bit x n b =\n  if n < 64 then\n    if b then IntInf.orb (x, IntInf.<< (1, Word.fromLargeInt (IntInf.toLarge n)))\n    else IntInf.andb (x, IntInf.notb (IntInf.<< (1, Word.fromLargeInt (IntInf.toLarge n))))\n  else x;\n\nend\n\\<close>"], ["", "code_reserved SML Uint64"], ["", "setup \\<open>\nlet\n  val polyml64 = LargeWord.wordSize > 63;\n  (* PolyML 5.6 has bugs in its Word64 implementation. We test for one such bug and refrain\n     from using Word64 in that case. Testing is done with dynamic code evaluation such that\n     the compiler does not choke on the Word64 structure, which need not be present in a 32bit\n     environment. *)\n  val error_msg = \"Buggy Word64 structure\";\n  val test_code = \n   \"val _ = if Word64.div (0w18446744073709551611 : Word64.word, 0w3) = 0w6148914691236517203 then ()\\n\" ^\n   \"else raise (Fail \\\"\" ^ error_msg ^ \"\\\");\";\n  val f = Exn.interruptible_capture (fn () => ML_Compiler.eval ML_Compiler.flags Position.none (ML_Lex.tokenize test_code))\n  val use_Word64 = polyml64 andalso\n    (case f () of \n       Exn.Res _ => true\n     | Exn.Exn (e as ERROR m) => if String.isSuffix error_msg m then false else Exn.reraise e\n     | Exn.Exn e => Exn.reraise e)\n    ;\n\n  val newline = \"\\n\";\n  val content = \n    \"structure Uint64 : sig\" ^ newline ^\n    \"  eqtype uint64;\" ^ newline ^\n    \"  val zero : uint64;\" ^ newline ^\n    \"  val one : uint64;\" ^ newline ^\n    \"  val fromInt : IntInf.int -> uint64;\" ^ newline ^\n    \"  val toInt : uint64 -> IntInf.int;\" ^ newline ^\n    \"  val toLarge : uint64 -> LargeWord.word;\" ^ newline ^\n    \"  val fromLarge : LargeWord.word -> uint64\" ^ newline ^\n    \"  val plus : uint64 -> uint64 -> uint64;\" ^ newline ^\n    \"  val minus : uint64 -> uint64 -> uint64;\" ^ newline ^\n    \"  val times : uint64 -> uint64 -> uint64;\" ^ newline ^\n    \"  val divide : uint64 -> uint64 -> uint64;\" ^ newline ^\n    \"  val modulus : uint64 -> uint64 -> uint64;\" ^ newline ^\n    \"  val negate : uint64 -> uint64;\" ^ newline ^\n    \"  val less_eq : uint64 -> uint64 -> bool;\" ^ newline ^\n    \"  val less : uint64 -> uint64 -> bool;\" ^ newline ^\n    \"  val notb : uint64 -> uint64;\" ^ newline ^\n    \"  val andb : uint64 -> uint64 -> uint64;\" ^ newline ^\n    \"  val orb : uint64 -> uint64 -> uint64;\" ^ newline ^\n    \"  val xorb : uint64 -> uint64 -> uint64;\" ^ newline ^\n    \"  val shiftl : uint64 -> IntInf.int -> uint64;\" ^ newline ^\n    \"  val shiftr : uint64 -> IntInf.int -> uint64;\" ^ newline ^\n    \"  val shiftr_signed : uint64 -> IntInf.int -> uint64;\" ^ newline ^\n    \"  val set_bit : uint64 -> IntInf.int -> bool -> uint64;\" ^ newline ^\n    \"  val test_bit : uint64 -> IntInf.int -> bool;\" ^ newline ^\n    \"end = struct\" ^ newline ^\n    \"\" ^ newline ^\n    \"type uint64 = Word64.word;\" ^ newline ^\n    \"\" ^ newline ^\n    \"val zero = (0wx0 : uint64);\" ^ newline ^\n    \"\" ^ newline ^\n    \"val one = (0wx1 : uint64);\" ^ newline ^\n    \"\" ^ newline ^\n    \"fun fromInt x = Word64.fromLargeInt (IntInf.toLarge x);\" ^ newline ^\n    \"\" ^ newline ^\n    \"fun toInt x = IntInf.fromLarge (Word64.toLargeInt x);\"  ^ newline ^\n    \"\" ^ newline ^\n    \"fun fromLarge x = Word64.fromLarge x;\" ^ newline ^\n    \"\" ^ newline ^\n    \"fun toLarge x = Word64.toLarge x;\"  ^ newline ^\n    \"\" ^ newline ^\n    \"fun plus x y = Word64.+(x, y);\" ^ newline ^\n    \"\" ^ newline ^\n    \"fun minus x y = Word64.-(x, y);\" ^ newline ^\n    \"\" ^ newline ^\n    \"fun negate x = Word64.~(x);\" ^ newline ^\n    \"\" ^ newline ^\n    \"fun times x y = Word64.*(x, y);\" ^ newline ^\n    \"\" ^ newline ^\n    \"fun divide x y = Word64.div(x, y);\" ^ newline ^\n    \"\" ^ newline ^\n    \"fun modulus x y = Word64.mod(x, y);\" ^ newline ^\n    \"\" ^ newline ^\n    \"fun less_eq x y = Word64.<=(x, y);\" ^ newline ^\n    \"\" ^ newline ^\n    \"fun less x y = Word64.<(x, y);\" ^ newline ^\n    \"\" ^ newline ^\n    \"fun set_bit x n b =\" ^ newline ^\n    \"  let val mask = Word64.<< (0wx1, Word.fromLargeInt (IntInf.toLarge n))\" ^ newline ^\n    \"  in if b then Word64.orb (x, mask)\" ^ newline ^\n    \"     else Word64.andb (x, Word64.notb mask)\" ^ newline ^\n    \"  end\" ^ newline ^\n    \"\" ^ newline ^\n    \"fun shiftl x n =\" ^ newline ^\n    \"  Word64.<< (x, Word.fromLargeInt (IntInf.toLarge n))\" ^ newline ^\n    \"\" ^ newline ^\n    \"fun shiftr x n =\" ^ newline ^\n    \"  Word64.>> (x, Word.fromLargeInt (IntInf.toLarge n))\" ^ newline ^\n    \"\" ^ newline ^\n    \"fun shiftr_signed x n =\" ^ newline ^\n    \"  Word64.~>> (x, Word.fromLargeInt (IntInf.toLarge n))\" ^ newline ^\n    \"\" ^ newline ^\n    \"fun test_bit x n =\" ^ newline ^\n    \"  Word64.andb (x, Word64.<< (0wx1, Word.fromLargeInt (IntInf.toLarge n))) <> Word64.fromInt 0\" ^ newline ^\n    \"\" ^ newline ^\n    \"val notb = Word64.notb\" ^ newline ^\n    \"\" ^ newline ^\n    \"fun andb x y = Word64.andb(x, y);\" ^ newline ^\n    \"\" ^ newline ^\n    \"fun orb x y = Word64.orb(x, y);\" ^ newline ^\n    \"\" ^ newline ^\n    \"fun xorb x y = Word64.xorb(x, y);\" ^ newline ^\n    \"\" ^ newline ^\n    \"end (*struct Uint64*)\"\n  val target_SML64 = \"SML_word\";\nin\n  (if use_Word64 then Code_Target.set_printings (Code_Symbol.Module (\"Uint64\", [(Code_Runtime.target, SOME (content, []))])) else I)\n  #> Code_Target.set_printings (Code_Symbol.Module (\"Uint64\", [(target_SML64, SOME (content, []))]))\nend\n\\<close>"], ["", "code_printing code_module Uint64 \\<rightharpoonup> (Haskell)\n \\<open>module Uint64(Int64, Word64) where\n\n  import Data.Int(Int64)\n  import Data.Word(Word64)\\<close>"], ["", "code_reserved Haskell Uint64"], ["", "text \\<open>\n  OCaml and Scala provide only signed 64bit numbers, so we use these and \n  implement sign-sensitive operations like comparisons manually.\n\\<close>"], ["", "code_printing code_module \"Uint64\" \\<rightharpoonup> (OCaml)\n\\<open>module Uint64 : sig\n  val less : int64 -> int64 -> bool\n  val less_eq : int64 -> int64 -> bool\n  val set_bit : int64 -> Z.t -> bool -> int64\n  val shiftl : int64 -> Z.t -> int64\n  val shiftr : int64 -> Z.t -> int64\n  val shiftr_signed : int64 -> Z.t -> int64\n  val test_bit : int64 -> Z.t -> bool\nend = struct\n\n(* negative numbers have their highest bit set, \n   so they are greater than positive ones *)\nlet less x y =\n  if Int64.compare x Int64.zero < 0 then\n    Int64.compare y Int64.zero < 0 && Int64.compare x y < 0\n  else Int64.compare y Int64.zero < 0 || Int64.compare x y < 0;;\n\nlet less_eq x y =\n  if Int64.compare x Int64.zero < 0 then\n    Int64.compare y Int64.zero < 0 && Int64.compare x y <= 0\n  else Int64.compare y Int64.zero < 0 || Int64.compare x y <= 0;;\n\nlet set_bit x n b =\n  let mask = Int64.shift_left Int64.one (Z.to_int n)\n  in if b then Int64.logor x mask\n     else Int64.logand x (Int64.lognot mask);;\n\nlet shiftl x n = Int64.shift_left x (Z.to_int n);;\n\nlet shiftr x n = Int64.shift_right_logical x (Z.to_int n);;\n\nlet shiftr_signed x n = Int64.shift_right x (Z.to_int n);;\n\nlet test_bit x n =\n  Int64.compare \n    (Int64.logand x (Int64.shift_left Int64.one (Z.to_int n)))\n    Int64.zero\n  <> 0;;\n\nend;; (*struct Uint64*)\\<close>"], ["", "code_reserved OCaml Uint64"], ["", "code_printing code_module Uint64 \\<rightharpoonup> (Scala)\n\\<open>object Uint64 {\n\ndef less(x: Long, y: Long) : Boolean =\n  if (x < 0) y < 0 && x < y\n  else y < 0 || x < y\n\ndef less_eq(x: Long, y: Long) : Boolean =\n  if (x < 0) y < 0 && x <= y\n  else y < 0 || x <= y\n\ndef set_bit(x: Long, n: BigInt, b: Boolean) : Long =\n  if (b)\n    x | (1L << n.intValue)\n  else\n    x & (1L << n.intValue).unary_~\n\ndef shiftl(x: Long, n: BigInt) : Long = x << n.intValue\n\ndef shiftr(x: Long, n: BigInt) : Long = x >>> n.intValue\n\ndef shiftr_signed(x: Long, n: BigInt) : Long = x >> n.intValue\n\ndef test_bit(x: Long, n: BigInt) : Boolean =\n  (x & (1L << n.intValue)) != 0\n\n} /* object Uint64 */\\<close>"], ["", "code_reserved Scala Uint64"], ["", "text \\<open>\n  OCaml's conversion from Big\\_int to int64 demands that the value fits int a signed 64-bit integer.\n  The following justifies the implementation.\n\\<close>"], ["", "definition Uint64_signed :: \"integer \\<Rightarrow> uint64\" \nwhere \"Uint64_signed i = (if i < -(0x8000000000000000) \\<or> i \\<ge> 0x8000000000000000 then undefined Uint64 i else Uint64 i)\""], ["", "lemma Uint64_code [code]:\n  \"Uint64 i = \n  (let i' = i AND 0xFFFFFFFFFFFFFFFF\n   in if bit i' 63 then Uint64_signed (i' - 0x10000000000000000) else Uint64_signed i')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Uint64 i =\n    (let i' = i AND 18446744073709551615\n     in if bit i' 63 then Uint64_signed (i' - 18446744073709551616)\n        else Uint64_signed i')", "including undefined_transfer integer.lifting"], ["proof (prove)\ngoal (1 subgoal):\n 1. Uint64 i =\n    (let i' = i AND 18446744073709551615\n     in if bit i' 63 then Uint64_signed (i' - 18446744073709551616)\n        else Uint64_signed i')", "unfolding Uint64_signed_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Uint64 i =\n    (let i' = i AND 18446744073709551615\n     in if bit i' 63\n        then if i' - 18446744073709551616 < - 9223372036854775808 \\<or>\n                9223372036854775808 \\<le> i' - 18446744073709551616\n             then undefined Uint64 (i' - 18446744073709551616)\n             else Uint64 (i' - 18446744073709551616)\n        else if i' < - 9223372036854775808 \\<or>\n                9223372036854775808 \\<le> i'\n             then undefined Uint64 i' else Uint64 i')", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       word_of_int i =\n       (let i' = i AND 18446744073709551615\n        in if bit i' 63\n           then if i' - 18446744073709551616 < - 9223372036854775808 \\<or>\n                   9223372036854775808 \\<le> i' - 18446744073709551616\n                then map_fun (map_fun int_of_integer Abs_uint64)\n                      (map_fun integer_of_int Rep_uint64) undefined\n                      word_of_int (i' - 18446744073709551616)\n                else word_of_int (i' - 18446744073709551616)\n           else if i' < - 9223372036854775808 \\<or>\n                   9223372036854775808 \\<le> i'\n                then map_fun (map_fun int_of_integer Abs_uint64)\n                      (map_fun integer_of_int Rep_uint64) undefined\n                      word_of_int i'\n                else word_of_int i')", "apply (subst word_of_int_via_signed)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>i. ?mask5355 i = mask LENGTH(64)\n 2. \\<And>i. ?shift5355 i = 1 << LENGTH(64)\n 3. \\<And>i. ?index5355 i = LENGTH(64) - 1\n 4. \\<And>i. ?overflow5355 i = 1 << LENGTH(64) - 1\n 5. \\<And>i. ?least5355 i = - ?overflow5355 i\n 6. \\<And>i.\n       (let i' = i AND ?mask5355 i\n        in if i' !! ?index5355 i\n           then if i' - ?shift5355 i < ?least5355 i \\<or>\n                   ?overflow5355 i \\<le> i' - ?shift5355 i\n                then ?arbitrary1.5355 i i'\n                else word_of_int (i' - ?shift5355 i)\n           else if i' < ?least5355 i \\<or> ?overflow5355 i \\<le> i'\n                then ?arbitrary2.5355 i i' else word_of_int i') =\n       (let i' = i AND 18446744073709551615\n        in if bit i' 63\n           then if i' - 18446744073709551616 < - 9223372036854775808 \\<or>\n                   9223372036854775808 \\<le> i' - 18446744073709551616\n                then map_fun (map_fun int_of_integer Abs_uint64)\n                      (map_fun integer_of_int Rep_uint64) undefined\n                      word_of_int (i' - 18446744073709551616)\n                else word_of_int (i' - 18446744073709551616)\n           else if i' < - 9223372036854775808 \\<or>\n                   9223372036854775808 \\<le> i'\n                then map_fun (map_fun int_of_integer Abs_uint64)\n                      (map_fun integer_of_int Rep_uint64) undefined\n                      word_of_int i'\n                else word_of_int i')", "apply (auto simp add: shiftl_eq_push_bit push_bit_of_1 mask_eq_exp_minus_1 word_of_int_via_signed cong del: if_cong)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma Uint64_signed_code [code abstract]:\n  \"Rep_uint64 (Uint64_signed i) = \n  (if i < -(0x8000000000000000) \\<or> i \\<ge> 0x8000000000000000 then Rep_uint64 (undefined Uint64 i) else word_of_int (int_of_integer_symbolic i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_uint64 (Uint64_signed i) =\n    (if i < - 9223372036854775808 \\<or> 9223372036854775808 \\<le> i\n     then Rep_uint64 (undefined Uint64 i)\n     else word_of_int (int_of_integer_symbolic i))", "unfolding Uint64_signed_def Uint64_def int_of_integer_symbolic_def word_of_integer_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_uint64\n     (if i < - 9223372036854775808 \\<or> 9223372036854775808 \\<le> i\n      then undefined (map_fun int_of_integer Abs_uint64 word_of_int) i\n      else map_fun int_of_integer Abs_uint64 word_of_int i) =\n    (if i < - 9223372036854775808 \\<or> 9223372036854775808 \\<le> i\n     then Rep_uint64\n           (undefined (map_fun int_of_integer Abs_uint64 word_of_int) i)\n     else word_of_int (int_of_integer i))", "by(simp add: Abs_uint64_inverse)"], ["", "text \\<open>\n  Avoid @{term Abs_uint64} in generated code, use @{term Rep_uint64'} instead. \n  The symbolic implementations for code\\_simp use @{term Rep_uint64}.\n\n  The new destructor @{term Rep_uint64'} is executable.\n  As the simplifier is given the [code abstract] equations literally, \n  we cannot implement @{term Rep_uint64} directly, because that makes code\\_simp loop.\n\n  If code generation raises Match, some equation probably contains @{term Rep_uint64} \n  ([code abstract] equations for @{typ uint64} may use @{term Rep_uint64} because\n  these instances will be folded away.)\n\n  To convert @{typ \"64 word\"} values into @{typ uint64}, use @{term \"Abs_uint64'\"}.\n\\<close>"], ["", "definition Rep_uint64' where [simp]: \"Rep_uint64' = Rep_uint64\""], ["", "lemma Rep_uint64'_transfer [transfer_rule]:\n  \"rel_fun cr_uint64 (=) (\\<lambda>x. x) Rep_uint64'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_fun cr_uint64 (=) (\\<lambda>x. x) Rep_uint64'", "unfolding Rep_uint64'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_fun cr_uint64 (=) (\\<lambda>x. x) Rep_uint64", "by(rule uint64.rep_transfer)"], ["", "lemma Rep_uint64'_code [code]: \"Rep_uint64' x = (BITS n. bit x n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_uint64' x = (BITS n. bit x n)", "by transfer (simp add: set_bits_bit_eq)"], ["", "lift_definition Abs_uint64' :: \"64 word \\<Rightarrow> uint64\" is \"\\<lambda>x :: 64 word. x\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma Abs_uint64'_code [code]:\n  \"Abs_uint64' x = Uint64 (integer_of_int (uint x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_uint64' x = Uint64 (integer_of_int (uint x))", "including integer.lifting"], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_uint64' x = Uint64 (integer_of_int (uint x))", "by transfer simp"], ["", "declare [[code drop: \"term_of_class.term_of :: uint64 \\<Rightarrow> _\"]]"], ["", "lemma term_of_uint64_code [code]:\n  defines \"TR \\<equiv> typerep.Typerep\" and \"bit0 \\<equiv> STR ''Numeral_Type.bit0''\" \n  shows\n  \"term_of_class.term_of x = \n   Code_Evaluation.App (Code_Evaluation.Const (STR ''Uint64.uint64.Abs_uint64'') (TR (STR ''fun'') [TR (STR ''Word.word'') [TR bit0 [TR bit0 [TR bit0 [TR bit0 [TR bit0 [TR bit0 [TR (STR ''Numeral_Type.num1'') []]]]]]]], TR (STR ''Uint64.uint64'') []]))\n       (term_of_class.term_of (Rep_uint64' x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. term_of_class.term_of x =\n    Code_Evaluation.App\n     (Code_Evaluation.Const STR ''Uint64.uint64.Abs_uint64''\n       (TR STR ''fun''\n         [TR STR ''Word.word''\n           [TR bit0\n             [TR bit0\n               [TR bit0\n                 [TR bit0\n                   [TR bit0\n                     [TR bit0 [TR STR ''Numeral_Type.num1'' []]]]]]]],\n          TR STR ''Uint64.uint64'' []]))\n     (term_of_class.term_of (Rep_uint64' x))", "by(simp add: term_of_anything)"], ["", "code_printing\n  type_constructor uint64 \\<rightharpoonup>\n  (SML) \"Uint64.uint64\" and\n  (Haskell) \"Uint64.Word64\" and\n  (OCaml) \"int64\" and\n  (Scala) \"Long\"\n| constant Uint64 \\<rightharpoonup>\n  (SML) \"Uint64.fromInt\" and\n  (Haskell) \"(Prelude.fromInteger _ :: Uint64.Word64)\" and\n  (Haskell_Quickcheck) \"(Prelude.fromInteger (Prelude.toInteger _) :: Uint64.Word64)\" and\n  (Scala) \"_.longValue\"\n| constant Uint64_signed \\<rightharpoonup>\n  (OCaml) \"Z.to'_int64\"\n| constant \"0 :: uint64\" \\<rightharpoonup>\n  (SML) \"Uint64.zero\" and\n  (Haskell) \"(0 :: Uint64.Word64)\" and\n  (OCaml) \"Int64.zero\" and\n  (Scala) \"0\"\n| constant \"1 :: uint64\" \\<rightharpoonup>\n  (SML) \"Uint64.one\" and\n  (Haskell) \"(1 :: Uint64.Word64)\" and\n  (OCaml) \"Int64.one\" and\n  (Scala) \"1\"\n| constant \"plus :: uint64 \\<Rightarrow> _ \" \\<rightharpoonup>\n  (SML) \"Uint64.plus\" and\n  (Haskell) infixl 6 \"+\" and\n  (OCaml) \"Int64.add\" and\n  (Scala) infixl 7 \"+\"\n| constant \"uminus :: uint64 \\<Rightarrow> _\" \\<rightharpoonup>\n  (SML) \"Uint64.negate\" and\n  (Haskell) \"negate\" and\n  (OCaml) \"Int64.neg\" and\n  (Scala) \"!(- _)\"\n| constant \"minus :: uint64 \\<Rightarrow> _\" \\<rightharpoonup>\n  (SML) \"Uint64.minus\" and\n  (Haskell) infixl 6 \"-\" and\n  (OCaml) \"Int64.sub\" and\n  (Scala) infixl 7 \"-\"\n| constant \"times :: uint64 \\<Rightarrow> _ \\<Rightarrow> _\" \\<rightharpoonup>\n  (SML) \"Uint64.times\" and\n  (Haskell) infixl 7 \"*\" and\n  (OCaml) \"Int64.mul\" and\n  (Scala) infixl 8 \"*\"\n| constant \"HOL.equal :: uint64 \\<Rightarrow> _ \\<Rightarrow> bool\" \\<rightharpoonup>\n  (SML) \"!((_ : Uint64.uint64) = _)\" and\n  (Haskell) infix 4 \"==\" and\n  (OCaml) \"(Int64.compare _ _ = 0)\" and\n  (Scala) infixl 5 \"==\"\n| class_instance uint64 :: equal \\<rightharpoonup>\n  (Haskell) -\n| constant \"less_eq :: uint64 \\<Rightarrow> _ \\<Rightarrow> bool\" \\<rightharpoonup>\n  (SML) \"Uint64.less'_eq\" and\n  (Haskell) infix 4 \"<=\" and\n  (OCaml) \"Uint64.less'_eq\" and\n  (Scala) \"Uint64.less'_eq\"\n| constant \"less :: uint64 \\<Rightarrow> _ \\<Rightarrow> bool\" \\<rightharpoonup>\n  (SML) \"Uint64.less\" and\n  (Haskell) infix 4 \"<\" and\n  (OCaml) \"Uint64.less\" and\n  (Scala) \"Uint64.less\"\n| constant \"NOT :: uint64 \\<Rightarrow> _\" \\<rightharpoonup>\n  (SML) \"Uint64.notb\" and\n  (Haskell) \"Data'_Bits.complement\" and\n  (OCaml) \"Int64.lognot\" and\n  (Scala) \"_.unary'_~\"\n| constant \"(AND) :: uint64 \\<Rightarrow> _\" \\<rightharpoonup>\n  (SML) \"Uint64.andb\" and\n  (Haskell) infixl 7 \"Data_Bits..&.\" and\n  (OCaml) \"Int64.logand\" and\n  (Scala) infixl 3 \"&\"\n| constant \"(OR) :: uint64 \\<Rightarrow> _\" \\<rightharpoonup>\n  (SML) \"Uint64.orb\" and\n  (Haskell) infixl 5 \"Data_Bits..|.\" and\n  (OCaml) \"Int64.logor\" and\n  (Scala) infixl 1 \"|\"\n| constant \"(XOR) :: uint64 \\<Rightarrow> _\" \\<rightharpoonup>\n  (SML) \"Uint64.xorb\" and\n  (Haskell) \"Data'_Bits.xor\" and\n  (OCaml) \"Int64.logxor\" and\n  (Scala) infixl 2 \"^\""], ["", "definition uint64_divmod :: \"uint64 \\<Rightarrow> uint64 \\<Rightarrow> uint64 \\<times> uint64\" where\n  \"uint64_divmod x y = \n  (if y = 0 then (undefined ((div) :: uint64 \\<Rightarrow> _) x (0 :: uint64), undefined ((mod) :: uint64 \\<Rightarrow> _) x (0 :: uint64)) \n  else (x div y, x mod y))\""], ["", "definition uint64_div :: \"uint64 \\<Rightarrow> uint64 \\<Rightarrow> uint64\" \nwhere \"uint64_div x y = fst (uint64_divmod x y)\""], ["", "definition uint64_mod :: \"uint64 \\<Rightarrow> uint64 \\<Rightarrow> uint64\" \nwhere \"uint64_mod x y = snd (uint64_divmod x y)\""], ["", "lemma div_uint64_code [code]: \"x div y = (if y = 0 then 0 else uint64_div x y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x div y = (if y = 0 then 0 else uint64_div x y)", "including undefined_transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. x div y = (if y = 0 then 0 else uint64_div x y)", "unfolding uint64_divmod_def uint64_div_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. x div y =\n    (if y = 0 then 0\n     else fst (if y = 0 then (undefined (div) x 0, undefined (mod) x 0)\n               else (x div y, x mod y)))", "by transfer (simp add: word_div_def)"], ["", "lemma mod_uint64_code [code]: \"x mod y = (if y = 0 then x else uint64_mod x y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x mod y = (if y = 0 then x else uint64_mod x y)", "including undefined_transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. x mod y = (if y = 0 then x else uint64_mod x y)", "unfolding uint64_mod_def uint64_divmod_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. x mod y =\n    (if y = 0 then x\n     else snd (if y = 0 then (undefined (div) x 0, undefined (mod) x 0)\n               else (x div y, x mod y)))", "by transfer (simp add: word_mod_def)"], ["", "definition uint64_sdiv :: \"uint64 \\<Rightarrow> uint64 \\<Rightarrow> uint64\"\nwhere [code del]:\n  \"uint64_sdiv x y =\n   (if y = 0 then undefined ((div) :: uint64 \\<Rightarrow> _) x (0 :: uint64)\n    else Abs_uint64 (Rep_uint64 x sdiv Rep_uint64 y))\""], ["", "definition div0_uint64 :: \"uint64 \\<Rightarrow> uint64\"\nwhere [code del]: \"div0_uint64 x = undefined ((div) :: uint64 \\<Rightarrow> _) x (0 :: uint64)\""], ["", "declare [[code abort: div0_uint64]]"], ["", "definition mod0_uint64 :: \"uint64 \\<Rightarrow> uint64\"\nwhere [code del]: \"mod0_uint64 x = undefined ((mod) :: uint64 \\<Rightarrow> _) x (0 :: uint64)\""], ["", "declare [[code abort: mod0_uint64]]"], ["", "lemma uint64_divmod_code [code]:\n  \"uint64_divmod x y =\n  (if 0x8000000000000000 \\<le> y then if x < y then (0, x) else (1, x - y)\n   else if y = 0 then (div0_uint64 x, mod0_uint64 x)\n   else let q = push_bit 1 (uint64_sdiv (drop_bit 1 x) y);\n            r = x - q * y\n        in if r \\<ge> y then (q + 1, r - y) else (q, r))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. uint64_divmod x y =\n    (if 9223372036854775808 \\<le> y\n     then if x < y then (0, x) else (1, x - y)\n     else if y = 0 then (div0_uint64 x, mod0_uint64 x)\n          else let q = push_bit 1 (uint64_sdiv (drop_bit 1 x) y);\n                   r = x - q * y\n               in if y \\<le> r then (q + 1, r - y) else (q, r))", "including undefined_transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. uint64_divmod x y =\n    (if 9223372036854775808 \\<le> y\n     then if x < y then (0, x) else (1, x - y)\n     else if y = 0 then (div0_uint64 x, mod0_uint64 x)\n          else let q = push_bit 1 (uint64_sdiv (drop_bit 1 x) y);\n                   r = x - q * y\n               in if y \\<le> r then (q + 1, r - y) else (q, r))", "unfolding uint64_divmod_def uint64_sdiv_def div0_uint64_def mod0_uint64_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if y = 0 then (undefined (div) x 0, undefined (mod) x 0)\n     else (x div y, x mod y)) =\n    (if 9223372036854775808 \\<le> y\n     then if x < y then (0, x) else (1, x - y)\n     else if y = 0 then (undefined (div) x 0, undefined (mod) x 0)\n          else let q = push_bit 1\n                        (if y = 0 then undefined (div) (drop_bit 1 x) 0\n                         else Abs_uint64\n                               (Rep_uint64 (drop_bit 1 x) sdiv\n                                Rep_uint64 y));\n                   r = x - q * y\n               in if y \\<le> r then (q + 1, r - y) else (q, r))", "by transfer (simp add: divmod_via_sdivmod shiftr_eq_drop_bit shiftl_eq_push_bit ac_simps)"], ["", "lemma uint64_sdiv_code [code abstract]:\n  \"Rep_uint64 (uint64_sdiv x y) =\n   (if y = 0 then Rep_uint64 (undefined ((div) :: uint64 \\<Rightarrow> _) x (0 :: uint64))\n    else Rep_uint64 x sdiv Rep_uint64 y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_uint64 (uint64_sdiv x y) =\n    (if y = 0 then Rep_uint64 (undefined (div) x 0)\n     else Rep_uint64 x sdiv Rep_uint64 y)", "unfolding uint64_sdiv_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_uint64\n     (if y = 0 then undefined (div) x 0\n      else Abs_uint64 (Rep_uint64 x sdiv Rep_uint64 y)) =\n    (if y = 0 then Rep_uint64 (undefined (div) x 0)\n     else Rep_uint64 x sdiv Rep_uint64 y)", "by(simp add: Abs_uint64_inverse)"], ["", "text \\<open>\n  Note that we only need a translation for signed division, but not for the remainder\n  because @{thm uint64_divmod_code} computes both with division only.\n\\<close>"], ["", "code_printing\n  constant uint64_div \\<rightharpoonup>\n  (SML) \"Uint64.divide\" and\n  (Haskell) \"Prelude.div\"\n| constant uint64_mod \\<rightharpoonup>\n  (SML) \"Uint64.modulus\" and\n  (Haskell) \"Prelude.mod\"\n| constant uint64_divmod \\<rightharpoonup>\n  (Haskell) \"divmod\"\n| constant uint64_sdiv \\<rightharpoonup>\n  (OCaml) \"Int64.div\" and\n  (Scala) \"_ '/ _\""], ["", "definition uint64_test_bit :: \"uint64 \\<Rightarrow> integer \\<Rightarrow> bool\"\nwhere [code del]:\n  \"uint64_test_bit x n =\n  (if n < 0 \\<or> 63 < n then undefined (bit :: uint64 \\<Rightarrow> _) x n\n   else bit x (nat_of_integer n))\""], ["", "lemma bit_uint64_code [code]:\n  \"bit x n \\<longleftrightarrow> n < 64 \\<and> uint64_test_bit x (integer_of_nat n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bit x n = (n < 64 \\<and> uint64_test_bit x (integer_of_nat n))", "including undefined_transfer integer.lifting"], ["proof (prove)\ngoal (1 subgoal):\n 1. bit x n = (n < 64 \\<and> uint64_test_bit x (integer_of_nat n))", "unfolding uint64_test_bit_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. bit x n =\n    (n < 64 \\<and>\n     (if integer_of_nat n < 0 \\<or> 63 < integer_of_nat n\n      then undefined bit x (integer_of_nat n)\n      else bit x (nat_of_integer (integer_of_nat n))))", "by (transfer, simp, transfer, simp)"], ["", "lemma uint64_test_bit_code [code]:\n  \"uint64_test_bit w n =\n  (if n < 0 \\<or> 63 < n then undefined (bit :: uint64 \\<Rightarrow> _) w n else bit (Rep_uint64 w) (nat_of_integer n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. uint64_test_bit w n =\n    (if n < 0 \\<or> 63 < n then undefined bit w n\n     else bit (Rep_uint64 w) (nat_of_integer n))", "unfolding uint64_test_bit_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if n < 0 \\<or> 63 < n then undefined bit w n\n     else bit w (nat_of_integer n)) =\n    (if n < 0 \\<or> 63 < n then undefined bit w n\n     else bit (Rep_uint64 w) (nat_of_integer n))", "by(simp add: bit_uint64.rep_eq)"], ["", "code_printing constant uint64_test_bit \\<rightharpoonup>\n  (SML) \"Uint64.test'_bit\" and\n  (Haskell) \"Data'_Bits.testBitBounded\" and\n  (OCaml) \"Uint64.test'_bit\" and\n  (Scala) \"Uint64.test'_bit\" and\n  (Eval) \"(fn x => fn i => if i < 0 orelse i >= 64 then raise (Fail \\\"argument to uint64'_test'_bit out of bounds\\\") else Uint64.test'_bit x i)\""], ["", "definition uint64_set_bit :: \"uint64 \\<Rightarrow> integer \\<Rightarrow> bool \\<Rightarrow> uint64\"\nwhere [code del]:\n  \"uint64_set_bit x n b =\n  (if n < 0 \\<or> 63 < n then undefined (set_bit :: uint64 \\<Rightarrow> _) x n b\n   else set_bit x (nat_of_integer n) b)\""], ["", "lemma set_bit_uint64_code [code]:\n  \"set_bit x n b = (if n < 64 then uint64_set_bit x (integer_of_nat n) b else x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_bit_class.set_bit x n b =\n    (if n < 64 then uint64_set_bit x (integer_of_nat n) b else x)", "including undefined_transfer integer.lifting"], ["proof (prove)\ngoal (1 subgoal):\n 1. set_bit_class.set_bit x n b =\n    (if n < 64 then uint64_set_bit x (integer_of_nat n) b else x)", "unfolding uint64_set_bit_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. set_bit_class.set_bit x n b =\n    (if n < 64\n     then if integer_of_nat n < 0 \\<or> 63 < integer_of_nat n\n          then undefined set_bit_class.set_bit x (integer_of_nat n) b\n          else set_bit_class.set_bit x (nat_of_integer (integer_of_nat n)) b\n     else x)", "by(transfer)(auto cong: conj_cong simp add: not_less set_bit_beyond word_size)"], ["", "lemma uint64_set_bit_code [code abstract]:\n  \"Rep_uint64 (uint64_set_bit w n b) = \n  (if n < 0 \\<or> 63 < n then Rep_uint64 (undefined (set_bit :: uint64 \\<Rightarrow> _) w n b)\n   else set_bit (Rep_uint64 w) (nat_of_integer n) b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_uint64 (uint64_set_bit w n b) =\n    (if n < 0 \\<or> 63 < n\n     then Rep_uint64 (undefined set_bit_class.set_bit w n b)\n     else set_bit_class.set_bit (Rep_uint64 w) (nat_of_integer n) b)", "including undefined_transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_uint64 (uint64_set_bit w n b) =\n    (if n < 0 \\<or> 63 < n\n     then Rep_uint64 (undefined set_bit_class.set_bit w n b)\n     else set_bit_class.set_bit (Rep_uint64 w) (nat_of_integer n) b)", "unfolding uint64_set_bit_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_uint64\n     (if n < 0 \\<or> 63 < n then undefined set_bit_class.set_bit w n b\n      else set_bit_class.set_bit w (nat_of_integer n) b) =\n    (if n < 0 \\<or> 63 < n\n     then Rep_uint64 (undefined set_bit_class.set_bit w n b)\n     else set_bit_class.set_bit (Rep_uint64 w) (nat_of_integer n) b)", "by transfer simp"], ["", "code_printing constant uint64_set_bit \\<rightharpoonup>\n  (SML) \"Uint64.set'_bit\" and\n  (Haskell) \"Data'_Bits.setBitBounded\" and\n  (OCaml) \"Uint64.set'_bit\" and\n  (Scala) \"Uint64.set'_bit\" and\n  (Eval) \"(fn x => fn i => fn b => if i < 0 orelse i >= 64 then raise (Fail \\\"argument to uint64'_set'_bit out of bounds\\\") else Uint64.set'_bit x i b)\""], ["", "lift_definition uint64_set_bits :: \"(nat \\<Rightarrow> bool) \\<Rightarrow> uint64 \\<Rightarrow> nat \\<Rightarrow> uint64\" is set_bits_aux"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma uint64_set_bits_code [code]:\n  \"uint64_set_bits f w n =\n  (if n = 0 then w \n   else let n' = n - 1 in uint64_set_bits f (push_bit 1 w OR (if f n' then 1 else 0)) n')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. uint64_set_bits f w n =\n    (if n = 0 then w\n     else let n' = n - 1\n          in uint64_set_bits f (push_bit 1 w OR (if f n' then 1 else 0)) n')", "apply (transfer fixing: n)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f w.\n       set_bits_aux f w n =\n       (if n = 0 then w\n        else let n' = n - 1\n             in set_bits_aux f (push_bit 1 w OR (if f n' then 1 else 0)) n')", "apply (cases n)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>f w.\n       n = 0 \\<Longrightarrow>\n       set_bits_aux f w n =\n       (if n = 0 then w\n        else let n' = n - 1\n             in set_bits_aux f (push_bit 1 w OR (if f n' then 1 else 0)) n')\n 2. \\<And>f w nat.\n       n = Suc nat \\<Longrightarrow>\n       set_bits_aux f w n =\n       (if n = 0 then w\n        else let n' = n - 1\n             in set_bits_aux f (push_bit 1 w OR (if f n' then 1 else 0)) n')", "apply (simp_all add: shiftl_eq_push_bit)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma set_bits_uint64 [code]:\n  \"(BITS n. f n) = uint64_set_bits f 0 64\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (BITS n. f n) = uint64_set_bits f 0 64", "by transfer(simp add: set_bits_conv_set_bits_aux)"], ["", "lemma lsb_code [code]: fixes x :: uint64 shows \"lsb x = bit x 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lsb x = bit x 0", "by transfer (simp add: lsb_word_eq)"], ["", "definition uint64_shiftl :: \"uint64 \\<Rightarrow> integer \\<Rightarrow> uint64\"\nwhere [code del]:\n  \"uint64_shiftl x n = (if n < 0 \\<or> 64 \\<le> n then undefined (push_bit :: nat \\<Rightarrow> uint64 \\<Rightarrow> _) x n else push_bit (nat_of_integer n) x)\""], ["", "lemma shiftl_uint64_code [code]: \"push_bit n x = (if n < 64 then uint64_shiftl x (integer_of_nat n) else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. push_bit n x =\n    (if n < 64 then uint64_shiftl x (integer_of_nat n) else 0)", "including undefined_transfer integer.lifting"], ["proof (prove)\ngoal (1 subgoal):\n 1. push_bit n x =\n    (if n < 64 then uint64_shiftl x (integer_of_nat n) else 0)", "unfolding uint64_shiftl_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. push_bit n x =\n    (if n < 64\n     then if integer_of_nat n < 0 \\<or> 64 \\<le> integer_of_nat n\n          then undefined push_bit x (integer_of_nat n)\n          else push_bit (nat_of_integer (integer_of_nat n)) x\n     else 0)", "by transfer simp"], ["", "lemma uint64_shiftl_code [code abstract]:\n  \"Rep_uint64 (uint64_shiftl w n) =\n  (if n < 0 \\<or> 64 \\<le> n then Rep_uint64 (undefined (push_bit :: nat \\<Rightarrow> uint64 \\<Rightarrow> _) w n) else push_bit (nat_of_integer n) (Rep_uint64 w))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_uint64 (uint64_shiftl w n) =\n    (if n < 0 \\<or> 64 \\<le> n then Rep_uint64 (undefined push_bit w n)\n     else push_bit (nat_of_integer n) (Rep_uint64 w))", "including undefined_transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_uint64 (uint64_shiftl w n) =\n    (if n < 0 \\<or> 64 \\<le> n then Rep_uint64 (undefined push_bit w n)\n     else push_bit (nat_of_integer n) (Rep_uint64 w))", "unfolding uint64_shiftl_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_uint64\n     (if n < 0 \\<or> 64 \\<le> n then undefined push_bit w n\n      else push_bit (nat_of_integer n) w) =\n    (if n < 0 \\<or> 64 \\<le> n then Rep_uint64 (undefined push_bit w n)\n     else push_bit (nat_of_integer n) (Rep_uint64 w))", "by transfer simp"], ["", "code_printing constant uint64_shiftl \\<rightharpoonup>\n  (SML) \"Uint64.shiftl\" and\n  (Haskell) \"Data'_Bits.shiftlBounded\" and\n  (OCaml) \"Uint64.shiftl\" and\n  (Scala) \"Uint64.shiftl\" and\n  (Eval) \"(fn x => fn i => if i < 0 orelse i >= 64 then raise (Fail \\\"argument to uint64'_shiftl out of bounds\\\") else Uint64.shiftl x i)\""], ["", "definition uint64_shiftr :: \"uint64 \\<Rightarrow> integer \\<Rightarrow> uint64\"\nwhere [code del]:\n  \"uint64_shiftr x n = (if n < 0 \\<or> 64 \\<le> n then undefined (drop_bit :: nat \\<Rightarrow> uint64 \\<Rightarrow> _) x n else drop_bit (nat_of_integer n) x)\""], ["", "lemma shiftr_uint64_code [code]: \"drop_bit n x = (if n < 64 then uint64_shiftr x (integer_of_nat n) else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. drop_bit n x =\n    (if n < 64 then uint64_shiftr x (integer_of_nat n) else 0)", "including undefined_transfer integer.lifting"], ["proof (prove)\ngoal (1 subgoal):\n 1. drop_bit n x =\n    (if n < 64 then uint64_shiftr x (integer_of_nat n) else 0)", "unfolding uint64_shiftr_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. drop_bit n x =\n    (if n < 64\n     then if integer_of_nat n < 0 \\<or> 64 \\<le> integer_of_nat n\n          then undefined drop_bit x (integer_of_nat n)\n          else drop_bit (nat_of_integer (integer_of_nat n)) x\n     else 0)", "by transfer simp"], ["", "lemma uint64_shiftr_code [code abstract]:\n  \"Rep_uint64 (uint64_shiftr w n) =\n  (if n < 0 \\<or> 64 \\<le> n then Rep_uint64 (undefined (drop_bit :: nat \\<Rightarrow> uint64 \\<Rightarrow> _) w n) else drop_bit (nat_of_integer n) (Rep_uint64 w))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_uint64 (uint64_shiftr w n) =\n    (if n < 0 \\<or> 64 \\<le> n then Rep_uint64 (undefined drop_bit w n)\n     else drop_bit (nat_of_integer n) (Rep_uint64 w))", "including undefined_transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_uint64 (uint64_shiftr w n) =\n    (if n < 0 \\<or> 64 \\<le> n then Rep_uint64 (undefined drop_bit w n)\n     else drop_bit (nat_of_integer n) (Rep_uint64 w))", "unfolding uint64_shiftr_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_uint64\n     (if n < 0 \\<or> 64 \\<le> n then undefined drop_bit w n\n      else drop_bit (nat_of_integer n) w) =\n    (if n < 0 \\<or> 64 \\<le> n then Rep_uint64 (undefined drop_bit w n)\n     else drop_bit (nat_of_integer n) (Rep_uint64 w))", "by transfer simp"], ["", "code_printing constant uint64_shiftr \\<rightharpoonup>\n  (SML) \"Uint64.shiftr\" and\n  (Haskell) \"Data'_Bits.shiftrBounded\" and\n  (OCaml) \"Uint64.shiftr\" and\n  (Scala) \"Uint64.shiftr\" and\n  (Eval) \"(fn x => fn i => if i < 0 orelse i >= 64 then raise (Fail \\\"argument to uint64'_shiftr out of bounds\\\") else Uint64.shiftr x i)\""], ["", "definition uint64_sshiftr :: \"uint64 \\<Rightarrow> integer \\<Rightarrow> uint64\"\nwhere [code del]:\n  \"uint64_sshiftr x n =\n  (if n < 0 \\<or> 64 \\<le> n then undefined sshiftr_uint64 x n else sshiftr_uint64 x (nat_of_integer n))\""], ["", "lemma sshiftr_uint64_code [code]:\n  \"x >>> n = \n  (if n < 64 then uint64_sshiftr x (integer_of_nat n) else if bit x 63 then - 1 else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x >>> n =\n    (if n < 64 then uint64_sshiftr x (integer_of_nat n)\n     else if bit x 63 then - 1 else 0)", "including undefined_transfer integer.lifting"], ["proof (prove)\ngoal (1 subgoal):\n 1. x >>> n =\n    (if n < 64 then uint64_sshiftr x (integer_of_nat n)\n     else if bit x 63 then - 1 else 0)", "unfolding uint64_sshiftr_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. x >>> n =\n    (if n < 64\n     then if integer_of_nat n < 0 \\<or> 64 \\<le> integer_of_nat n\n          then undefined (>>>) x (integer_of_nat n)\n          else x >>> nat_of_integer (integer_of_nat n)\n     else if bit x 63 then - 1 else 0)", "by transfer (simp add: not_less signed_drop_bit_beyond)"], ["", "lemma uint64_sshiftr_code [code abstract]:\n  \"Rep_uint64 (uint64_sshiftr w n) =\n  (if n < 0 \\<or> 64 \\<le> n then Rep_uint64 (undefined sshiftr_uint64 w n) else signed_drop_bit (nat_of_integer n) (Rep_uint64 w))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_uint64 (uint64_sshiftr w n) =\n    (if n < 0 \\<or> 64 \\<le> n then Rep_uint64 (undefined (>>>) w n)\n     else signed_drop_bit (nat_of_integer n) (Rep_uint64 w))", "including undefined_transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_uint64 (uint64_sshiftr w n) =\n    (if n < 0 \\<or> 64 \\<le> n then Rep_uint64 (undefined (>>>) w n)\n     else signed_drop_bit (nat_of_integer n) (Rep_uint64 w))", "unfolding uint64_sshiftr_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_uint64\n     (if n < 0 \\<or> 64 \\<le> n then undefined (>>>) w n\n      else w >>> nat_of_integer n) =\n    (if n < 0 \\<or> 64 \\<le> n then Rep_uint64 (undefined (>>>) w n)\n     else signed_drop_bit (nat_of_integer n) (Rep_uint64 w))", "by transfer simp"], ["", "code_printing constant uint64_sshiftr \\<rightharpoonup>\n  (SML) \"Uint64.shiftr'_signed\" and\n  (Haskell) \n    \"(Prelude.fromInteger (Prelude.toInteger (Data'_Bits.shiftrBounded (Prelude.fromInteger (Prelude.toInteger _) :: Uint64.Int64) _)) :: Uint64.Word64)\" and\n  (OCaml) \"Uint64.shiftr'_signed\" and\n  (Scala) \"Uint64.shiftr'_signed\" and\n  (Eval) \"(fn x => fn i => if i < 0 orelse i >= 64 then raise (Fail \\\"argument to uint64'_shiftr'_signed out of bounds\\\") else Uint64.shiftr'_signed x i)\""], ["", "lemma uint64_msb_test_bit: \"msb x \\<longleftrightarrow> bit (x :: uint64) 63\""], ["proof (prove)\ngoal (1 subgoal):\n 1. msb x = bit x 63", "by transfer (simp add: msb_word_iff_bit)"], ["", "lemma msb_uint64_code [code]: \"msb x \\<longleftrightarrow> uint64_test_bit x 63\""], ["proof (prove)\ngoal (1 subgoal):\n 1. msb x = uint64_test_bit x 63", "by (simp add: uint64_test_bit_def uint64_msb_test_bit)"], ["", "lemma uint64_of_int_code [code]: \"uint64_of_int i = Uint64 (integer_of_int i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. uint64_of_int i = Uint64 (integer_of_int i)", "including integer.lifting"], ["proof (prove)\ngoal (1 subgoal):\n 1. uint64_of_int i = Uint64 (integer_of_int i)", "by transfer simp"], ["", "lemma int_of_uint64_code [code]:\n  \"int_of_uint64 x = int_of_integer (integer_of_uint64 x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int_of_uint64 x = int_of_integer (integer_of_uint64 x)", "by(simp add: integer_of_uint64_def)"], ["", "lemma nat_of_uint64_code [code]:\n  \"nat_of_uint64 x = nat_of_integer (integer_of_uint64 x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nat_of_uint64 x = nat_of_integer (integer_of_uint64 x)", "unfolding integer_of_uint64_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. nat_of_uint64 x =\n    nat_of_integer ((integer_of_int \\<circ> int_of_uint64) x)", "including integer.lifting"], ["proof (prove)\ngoal (1 subgoal):\n 1. nat_of_uint64 x =\n    nat_of_integer ((integer_of_int \\<circ> int_of_uint64) x)", "by transfer simp"], ["", "definition integer_of_uint64_signed :: \"uint64 \\<Rightarrow> integer\"\nwhere\n  \"integer_of_uint64_signed n = (if bit n 63 then undefined integer_of_uint64 n else integer_of_uint64 n)\""], ["", "lemma integer_of_uint64_signed_code [code]:\n  \"integer_of_uint64_signed n =\n  (if bit n 63 then undefined integer_of_uint64 n else integer_of_int (uint (Rep_uint64' n)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. integer_of_uint64_signed n =\n    (if bit n 63 then undefined integer_of_uint64 n\n     else integer_of_int (uint (Rep_uint64' n)))", "unfolding integer_of_uint64_signed_def integer_of_uint64_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if bit n 63 then undefined (integer_of_int \\<circ> int_of_uint64) n\n     else (integer_of_int \\<circ> int_of_uint64) n) =\n    (if bit n 63 then undefined (integer_of_int \\<circ> int_of_uint64) n\n     else integer_of_int (uint (Rep_uint64' n)))", "including undefined_transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if bit n 63 then undefined (integer_of_int \\<circ> int_of_uint64) n\n     else (integer_of_int \\<circ> int_of_uint64) n) =\n    (if bit n 63 then undefined (integer_of_int \\<circ> int_of_uint64) n\n     else integer_of_int (uint (Rep_uint64' n)))", "by transfer simp"], ["", "lemma integer_of_uint64_code [code]:\n  \"integer_of_uint64 n =\n  (if bit n 63 then integer_of_uint64_signed (n AND 0x7FFFFFFFFFFFFFFF) OR 0x8000000000000000 else integer_of_uint64_signed n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. integer_of_uint64 n =\n    (if bit n 63\n     then integer_of_uint64_signed (n AND 9223372036854775807) OR\n          9223372036854775808\n     else integer_of_uint64_signed n)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. integer_of_uint64 n =\n    (if bit n 63\n     then integer_of_uint64_signed (n AND 9223372036854775807) OR\n          9223372036854775808\n     else integer_of_uint64_signed n)", "have \\<open>(0x7FFFFFFFFFFFFFFF :: uint64) = mask 63\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. 9223372036854775807 = mask 63", "by (simp add: mask_eq_exp_minus_1)"], ["proof (state)\nthis:\n  9223372036854775807 = mask 63\n\ngoal (1 subgoal):\n 1. integer_of_uint64 n =\n    (if bit n 63\n     then integer_of_uint64_signed (n AND 9223372036854775807) OR\n          9223372036854775808\n     else integer_of_uint64_signed n)", "then"], ["proof (chain)\npicking this:\n  9223372036854775807 = mask 63", "have *: \\<open>n AND 0x7FFFFFFFFFFFFFFF = take_bit 63 n\\<close>"], ["proof (prove)\nusing this:\n  9223372036854775807 = mask 63\n\ngoal (1 subgoal):\n 1. n AND 9223372036854775807 = take_bit 63 n", "by (simp add: take_bit_eq_mask)"], ["proof (state)\nthis:\n  n AND 9223372036854775807 = take_bit 63 n\n\ngoal (1 subgoal):\n 1. integer_of_uint64 n =\n    (if bit n 63\n     then integer_of_uint64_signed (n AND 9223372036854775807) OR\n          9223372036854775808\n     else integer_of_uint64_signed n)", "have **: \\<open>(0x8000000000000000 :: int) = 2 ^ 63\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. 9223372036854775808 = 2 ^ 63", "by simp"], ["proof (state)\nthis:\n  9223372036854775808 = 2 ^ 63\n\ngoal (1 subgoal):\n 1. integer_of_uint64 n =\n    (if bit n 63\n     then integer_of_uint64_signed (n AND 9223372036854775807) OR\n          9223372036854775808\n     else integer_of_uint64_signed n)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. integer_of_uint64 n =\n    (if bit n 63\n     then integer_of_uint64_signed (n AND 9223372036854775807) OR\n          9223372036854775808\n     else integer_of_uint64_signed n)", "unfolding integer_of_uint64_def integer_of_uint64_signed_def o_def *"], ["proof (prove)\ngoal (1 subgoal):\n 1. integer_of_int (int_of_uint64 n) =\n    (if bit n 63\n     then (if bit (take_bit 63 n) 63\n           then undefined (\\<lambda>x. integer_of_int (int_of_uint64 x))\n                 (take_bit 63 n)\n           else integer_of_int (int_of_uint64 (take_bit 63 n))) OR\n          9223372036854775808\n     else if bit n 63\n          then undefined (\\<lambda>x. integer_of_int (int_of_uint64 x)) n\n          else integer_of_int (int_of_uint64 n))", "including undefined_transfer integer.lifting"], ["proof (prove)\ngoal (1 subgoal):\n 1. integer_of_int (int_of_uint64 n) =\n    (if bit n 63\n     then (if bit (take_bit 63 n) 63\n           then undefined (\\<lambda>x. integer_of_int (int_of_uint64 x))\n                 (take_bit 63 n)\n           else integer_of_int (int_of_uint64 (take_bit 63 n))) OR\n          9223372036854775808\n     else if bit n 63\n          then undefined (\\<lambda>x. integer_of_int (int_of_uint64 x)) n\n          else integer_of_int (int_of_uint64 n))", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       uint n =\n       (if bit n 63\n        then (if bit (take_bit 63 n) 63\n              then map_fun (map_fun Rep_uint64 integer_of_int)\n                    (map_fun Abs_uint64 int_of_integer) undefined uint\n                    (take_bit 63 n)\n              else uint (take_bit 63 n)) OR\n             9223372036854775808\n        else if bit n 63\n             then map_fun (map_fun Rep_uint64 integer_of_int)\n                   (map_fun Abs_uint64 int_of_integer) undefined uint n\n             else uint n)", "apply (rule bit_eqI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n na.\n       2 ^ na \\<noteq> 0 \\<Longrightarrow>\n       bit (uint n) na =\n       bit (if bit n 63\n            then (if bit (take_bit 63 n) 63\n                  then map_fun (map_fun Rep_uint64 integer_of_int)\n                        (map_fun Abs_uint64 int_of_integer) undefined uint\n                        (take_bit 63 n)\n                  else uint (take_bit 63 n)) OR\n                 9223372036854775808\n            else if bit n 63\n                 then map_fun (map_fun Rep_uint64 integer_of_int)\n                       (map_fun Abs_uint64 int_of_integer) undefined uint n\n                 else uint n)\n        na", "apply (simp add: test_bit_eq_bit bit_or_iff bit_take_bit_iff bit_uint_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n na.\n       bit n 63 \\<longrightarrow>\n       (na < 64 \\<and> bit n na) =\n       (na < 64 \\<and> na < 63 \\<and> bit n na \\<or>\n        bit 9223372036854775808 na)", "apply (simp only: bit_exp_iff bit_or_iff **)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n na.\n       bit n 63 \\<longrightarrow>\n       (na < 64 \\<and> bit n na) =\n       (na < 64 \\<and> na < 63 \\<and> bit n na \\<or>\n        2 ^ 63 \\<noteq> 0 \\<and> 63 = na)", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  integer_of_uint64 n =\n  (if bit n 63\n   then integer_of_uint64_signed (n AND 9223372036854775807) OR\n        9223372036854775808\n   else integer_of_uint64_signed n)\n\ngoal:\nNo subgoals!", "qed"], ["", "code_printing\n  constant \"integer_of_uint64\" \\<rightharpoonup>\n  (SML) \"Uint64.toInt\" and\n  (Haskell) \"Prelude.toInteger\"\n| constant \"integer_of_uint64_signed\" \\<rightharpoonup>\n  (OCaml) \"Z.of'_int64\" and\n  (Scala) \"BigInt\""], ["", "section \\<open>Quickcheck setup\\<close>"], ["", "definition uint64_of_natural :: \"natural \\<Rightarrow> uint64\"\nwhere \"uint64_of_natural x \\<equiv> Uint64 (integer_of_natural x)\""], ["", "instantiation uint64 :: \"{random, exhaustive, full_exhaustive}\" begin"], ["", "definition \"random_uint64 \\<equiv> qc_random_cnv uint64_of_natural\""], ["", "definition \"exhaustive_uint64 \\<equiv> qc_exhaustive_cnv uint64_of_natural\""], ["", "definition \"full_exhaustive_uint64 \\<equiv> qc_full_exhaustive_cnv uint64_of_natural\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(uint64, exhaustive_class) &&&\n    OFCLASS(uint64, full_exhaustive_class) &&& OFCLASS(uint64, random_class)", ".."], ["", "end"], ["", "instantiation uint64 :: narrowing begin"], ["", "interpretation quickcheck_narrowing_samples\n  \"\\<lambda>i. let x = Uint64 i in (x, 0xFFFFFFFFFFFFFFFF - x)\" \"0\"\n  \"Typerep.Typerep (STR ''Uint64.uint64'') []\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "definition \"narrowing_uint64 d = qc_narrowing_drawn_from (narrowing_samples d) d\""], ["", "declare [[code drop: \"partial_term_of :: uint64 itself \\<Rightarrow> _\"]]"], ["", "lemmas partial_term_of_uint64 [code] = partial_term_of_code"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(uint64, narrowing_class)", ".."], ["", "end"], ["", "no_notation sshiftr_uint64 (infixl \">>>\" 55)"], ["", "end"]]}