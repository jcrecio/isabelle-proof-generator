{"file_name": "/home/qj213/afp-2021-10-22/thys/Native_Word/Code_Target_Word_Base.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Native_Word", "problem_names": ["lemma div_half_nat:\n  fixes x y :: nat\n  assumes \"y \\<noteq> 0\"\n  shows \"(x div y, x mod y) = (let q = 2 * (x div 2 div y); r = x - q * y in if y \\<le> r then (q + 1, r - y) else (q, r))\"", "lemma div_half_word:\n  fixes x y :: \"'a :: len word\"\n  assumes \"y \\<noteq> 0\"\n  shows \"(x div y, x mod y) = (let q = (x >> 1) div y << 1; r = x - q * y in if y \\<le> r then (q + 1, r - y) else (q, r))\"", "lemma word_test_bit_set_bits: \"(BITS n. f n :: 'a :: len word) !! n \\<longleftrightarrow> n < LENGTH('a) \\<and> f n\"", "lemma word_of_int_conv_set_bits: \"word_of_int i = (BITS n. i !! n)\"", "lemma word_and_mask_or_conv_and_mask:\n  \"n !! index \\<Longrightarrow> (n AND mask index) OR (1 << index) = n AND mask (index + 1)\"\n  for n :: \\<open>'a::len word\\<close>", "lemma uint_and_mask_or_full:\n  fixes n :: \"'a :: len word\"\n  assumes \"n !! (LENGTH('a) - 1)\"\n  and \"mask1 = mask (LENGTH('a) - 1)\"\n  and \"mask2 = 1 << LENGTH('a) - 1\"\n  shows \"uint (n AND mask1) OR mask2 = uint n\"", "lemmas word_sdiv_def = sdiv_word_def", "lemmas word_smod_def = smod_word_def", "lemma [code]:\n  \"x sdiv y =\n   (let x' = sint x; y' = sint y;\n        negative = (x' < 0) \\<noteq> (y' < 0);\n        result = abs x' div abs y'\n    in word_of_int (if negative then -result else result))\"\n  for x y :: \\<open>'a::len word\\<close>", "lemma [code]:\n  \"x smod y =\n   (let x' = sint x; y' = sint y;\n        negative = (x' < 0);\n        result = abs x' mod abs y'\n    in word_of_int (if negative then -result else result))\"\n  for x y :: \\<open>'a::len word\\<close>", "lemma divmod_via_sdivmod:\n  fixes x y :: \"'a :: len word\"\n  assumes \"y \\<noteq> 0\"\n  shows\n  \"(x div y, x mod y) =\n  (if 1 << (LENGTH('a) - 1) \\<le> y then if x < y then (0, x) else (1, x - y)\n   else let q = ((x >> 1) sdiv y) << 1;\n            r = x - q * y\n        in if r \\<ge> y then (q + 1, r - y) else (q, r))\"", "lemma word_of_integer_code [code]: \"word_of_integer n = word_of_int (int_of_integer n)\"", "lemma word_of_int_code:\n  \"uint (word_of_int x :: 'a word) = x AND mask (LENGTH('a :: len))\"", "lemma set_bits_aux_conv:\n  \\<open>set_bits_aux w n = (w << n) OR (set_bits f AND mask n)\\<close>\n  for w :: \\<open>'a::len word\\<close>", "lemma set_bits_aux_0 [simp]:\n  \\<open>set_bits_aux w 0 = w\\<close>", "lemma set_bits_aux_Suc [simp]:\n  \\<open>set_bits_aux w (Suc n) = set_bits_aux ((w << 1) OR (if f n then 1 else 0)) n\\<close>", "lemma set_bits_aux_simps [code]:\n  \\<open>set_bits_aux w 0 = w\\<close>\n  \\<open>set_bits_aux w (Suc n) = set_bits_aux ((w << 1) OR (if f n then 1 else 0)) n\\<close>", "lemma word_of_int_via_signed:\n  fixes mask\n  assumes mask_def: \"mask = Bit_Operations.mask (LENGTH('a))\"\n  and shift_def: \"shift = 1 << LENGTH('a)\"\n  and index_def: \"index = LENGTH('a) - 1\"\n  and overflow_def:\"overflow = 1 << (LENGTH('a) - 1)\"\n  and least_def: \"least = - overflow\"\n  shows\n  \"(word_of_int i :: 'a :: len word) =\n   (let i' = i AND mask\n    in if i' !! index then\n         if i' - shift < least \\<or> overflow \\<le> i' - shift then arbitrary1 i' else word_of_int (i' - shift)\n       else if i' < least \\<or> overflow \\<le> i' then arbitrary2 i' else word_of_int i')\"", "lemma partial_term_of_code:\n  \"partial_term_of (ty :: 'a itself) (Quickcheck_Narrowing.Narrowing_variable p t) \\<equiv>\n    Code_Evaluation.Free (STR ''_'') tr\"\n  \"partial_term_of (ty :: 'a itself) (Quickcheck_Narrowing.Narrowing_constructor i []) \\<equiv>\n   Code_Evaluation.term_of (partial_term_of_sample i)\"", "lemmas [code] =\n  quickcheck_narrowing_samples.narrowing_samples.simps\n  quickcheck_narrowing_samples.partial_term_of_sample_def"], "translations": [["", "lemma div_half_nat:\n  fixes x y :: nat\n  assumes \"y \\<noteq> 0\"\n  shows \"(x div y, x mod y) = (let q = 2 * (x div 2 div y); r = x - q * y in if y \\<le> r then (q + 1, r - y) else (q, r))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x div y, x mod y) =\n    (let q = 2 * (x div 2 div y); r = x - q * y\n     in if y \\<le> r then (q + 1, r - y) else (q, r))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (x div y, x mod y) =\n    (let q = 2 * (x div 2 div y); r = x - q * y\n     in if y \\<le> r then (q + 1, r - y) else (q, r))", "let ?q = \"2 * (x div 2 div y)\""], ["proof (state)\ngoal (1 subgoal):\n 1. (x div y, x mod y) =\n    (let q = 2 * (x div 2 div y); r = x - q * y\n     in if y \\<le> r then (q + 1, r - y) else (q, r))", "have q: \"?q = x div y - x div y mod 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * (x div 2 div y) = x div y - x div y mod 2", "by(metis div_mult2_eq mult.commute minus_mod_eq_mult_div [symmetric])"], ["proof (state)\nthis:\n  2 * (x div 2 div y) = x div y - x div y mod 2\n\ngoal (1 subgoal):\n 1. (x div y, x mod y) =\n    (let q = 2 * (x div 2 div y); r = x - q * y\n     in if y \\<le> r then (q + 1, r - y) else (q, r))", "let ?r = \"x - ?q * y\""], ["proof (state)\ngoal (1 subgoal):\n 1. (x div y, x mod y) =\n    (let q = 2 * (x div 2 div y); r = x - q * y\n     in if y \\<le> r then (q + 1, r - y) else (q, r))", "have r: \"?r = x mod y + x div y mod 2 * y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x - 2 * (x div 2 div y) * y = x mod y + x div y mod 2 * y", "by(simp add: q diff_mult_distrib minus_mod_eq_div_mult [symmetric])(metis diff_diff_cancel mod_less_eq_dividend mod_mult2_eq add.commute mult.commute)"], ["proof (state)\nthis:\n  x - 2 * (x div 2 div y) * y = x mod y + x div y mod 2 * y\n\ngoal (1 subgoal):\n 1. (x div y, x mod y) =\n    (let q = 2 * (x div 2 div y); r = x - q * y\n     in if y \\<le> r then (q + 1, r - y) else (q, r))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (x div y, x mod y) =\n    (let q = 2 * (x div 2 div y); r = x - q * y\n     in if y \\<le> r then (q + 1, r - y) else (q, r))", "proof(cases \"y \\<le> x - ?q * y\")"], ["proof (state)\ngoal (2 subgoals):\n 1. y \\<le> x - 2 * (x div 2 div y) * y \\<Longrightarrow>\n    (x div y, x mod y) =\n    (let q = 2 * (x div 2 div y); r = x - q * y\n     in if y \\<le> r then (q + 1, r - y) else (q, r))\n 2. \\<not> y \\<le> x - 2 * (x div 2 div y) * y \\<Longrightarrow>\n    (x div y, x mod y) =\n    (let q = 2 * (x div 2 div y); r = x - q * y\n     in if y \\<le> r then (q + 1, r - y) else (q, r))", "case True"], ["proof (state)\nthis:\n  y \\<le> x - 2 * (x div 2 div y) * y\n\ngoal (2 subgoals):\n 1. y \\<le> x - 2 * (x div 2 div y) * y \\<Longrightarrow>\n    (x div y, x mod y) =\n    (let q = 2 * (x div 2 div y); r = x - q * y\n     in if y \\<le> r then (q + 1, r - y) else (q, r))\n 2. \\<not> y \\<le> x - 2 * (x div 2 div y) * y \\<Longrightarrow>\n    (x div y, x mod y) =\n    (let q = 2 * (x div 2 div y); r = x - q * y\n     in if y \\<le> r then (q + 1, r - y) else (q, r))", "with assms q"], ["proof (chain)\npicking this:\n  y \\<noteq> 0\n  2 * (x div 2 div y) = x div y - x div y mod 2\n  y \\<le> x - 2 * (x div 2 div y) * y", "have \"x div y mod 2 \\<noteq> 0\""], ["proof (prove)\nusing this:\n  y \\<noteq> 0\n  2 * (x div 2 div y) = x div y - x div y mod 2\n  y \\<le> x - 2 * (x div 2 div y) * y\n\ngoal (1 subgoal):\n 1. x div y mod 2 \\<noteq> 0", "unfolding r"], ["proof (prove)\nusing this:\n  y \\<noteq> 0\n  2 * (x div 2 div y) = x div y - x div y mod 2\n  y \\<le> x mod y + x div y mod 2 * y\n\ngoal (1 subgoal):\n 1. x div y mod 2 \\<noteq> 0", "by (metis Nat.add_0_right diff_0_eq_0 diff_Suc_1 le_div_geq mod2_gr_0 mod_div_trivial mult_0 neq0_conv numeral_1_eq_Suc_0 numerals(1))"], ["proof (state)\nthis:\n  x div y mod 2 \\<noteq> 0\n\ngoal (2 subgoals):\n 1. y \\<le> x - 2 * (x div 2 div y) * y \\<Longrightarrow>\n    (x div y, x mod y) =\n    (let q = 2 * (x div 2 div y); r = x - q * y\n     in if y \\<le> r then (q + 1, r - y) else (q, r))\n 2. \\<not> y \\<le> x - 2 * (x div 2 div y) * y \\<Longrightarrow>\n    (x div y, x mod y) =\n    (let q = 2 * (x div 2 div y); r = x - q * y\n     in if y \\<le> r then (q + 1, r - y) else (q, r))", "hence \"x div y = ?q + 1\""], ["proof (prove)\nusing this:\n  x div y mod 2 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. x div y = 2 * (x div 2 div y) + 1", "unfolding q"], ["proof (prove)\nusing this:\n  x div y mod 2 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. x div y = x div y - x div y mod 2 + 1", "by simp"], ["proof (state)\nthis:\n  x div y = 2 * (x div 2 div y) + 1\n\ngoal (2 subgoals):\n 1. y \\<le> x - 2 * (x div 2 div y) * y \\<Longrightarrow>\n    (x div y, x mod y) =\n    (let q = 2 * (x div 2 div y); r = x - q * y\n     in if y \\<le> r then (q + 1, r - y) else (q, r))\n 2. \\<not> y \\<le> x - 2 * (x div 2 div y) * y \\<Longrightarrow>\n    (x div y, x mod y) =\n    (let q = 2 * (x div 2 div y); r = x - q * y\n     in if y \\<le> r then (q + 1, r - y) else (q, r))", "moreover"], ["proof (state)\nthis:\n  x div y = 2 * (x div 2 div y) + 1\n\ngoal (2 subgoals):\n 1. y \\<le> x - 2 * (x div 2 div y) * y \\<Longrightarrow>\n    (x div y, x mod y) =\n    (let q = 2 * (x div 2 div y); r = x - q * y\n     in if y \\<le> r then (q + 1, r - y) else (q, r))\n 2. \\<not> y \\<le> x - 2 * (x div 2 div y) * y \\<Longrightarrow>\n    (x div y, x mod y) =\n    (let q = 2 * (x div 2 div y); r = x - q * y\n     in if y \\<le> r then (q + 1, r - y) else (q, r))", "hence \"x mod y = ?r - y\""], ["proof (prove)\nusing this:\n  x div y = 2 * (x div 2 div y) + 1\n\ngoal (1 subgoal):\n 1. x mod y = x - 2 * (x div 2 div y) * y - y", "by simp(metis minus_div_mult_eq_mod [symmetric] diff_commute diff_diff_left mult_Suc)"], ["proof (state)\nthis:\n  x mod y = x - 2 * (x div 2 div y) * y - y\n\ngoal (2 subgoals):\n 1. y \\<le> x - 2 * (x div 2 div y) * y \\<Longrightarrow>\n    (x div y, x mod y) =\n    (let q = 2 * (x div 2 div y); r = x - q * y\n     in if y \\<le> r then (q + 1, r - y) else (q, r))\n 2. \\<not> y \\<le> x - 2 * (x div 2 div y) * y \\<Longrightarrow>\n    (x div y, x mod y) =\n    (let q = 2 * (x div 2 div y); r = x - q * y\n     in if y \\<le> r then (q + 1, r - y) else (q, r))", "ultimately"], ["proof (chain)\npicking this:\n  x div y = 2 * (x div 2 div y) + 1\n  x mod y = x - 2 * (x div 2 div y) * y - y", "show ?thesis"], ["proof (prove)\nusing this:\n  x div y = 2 * (x div 2 div y) + 1\n  x mod y = x - 2 * (x div 2 div y) * y - y\n\ngoal (1 subgoal):\n 1. (x div y, x mod y) =\n    (let q = 2 * (x div 2 div y); r = x - q * y\n     in if y \\<le> r then (q + 1, r - y) else (q, r))", "using True"], ["proof (prove)\nusing this:\n  x div y = 2 * (x div 2 div y) + 1\n  x mod y = x - 2 * (x div 2 div y) * y - y\n  y \\<le> x - 2 * (x div 2 div y) * y\n\ngoal (1 subgoal):\n 1. (x div y, x mod y) =\n    (let q = 2 * (x div 2 div y); r = x - q * y\n     in if y \\<le> r then (q + 1, r - y) else (q, r))", "by(simp add: Let_def)"], ["proof (state)\nthis:\n  (x div y, x mod y) =\n  (let q = 2 * (x div 2 div y); r = x - q * y\n   in if y \\<le> r then (q + 1, r - y) else (q, r))\n\ngoal (1 subgoal):\n 1. \\<not> y \\<le> x - 2 * (x div 2 div y) * y \\<Longrightarrow>\n    (x div y, x mod y) =\n    (let q = 2 * (x div 2 div y); r = x - q * y\n     in if y \\<le> r then (q + 1, r - y) else (q, r))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> y \\<le> x - 2 * (x div 2 div y) * y \\<Longrightarrow>\n    (x div y, x mod y) =\n    (let q = 2 * (x div 2 div y); r = x - q * y\n     in if y \\<le> r then (q + 1, r - y) else (q, r))", "case False"], ["proof (state)\nthis:\n  \\<not> y \\<le> x - 2 * (x div 2 div y) * y\n\ngoal (1 subgoal):\n 1. \\<not> y \\<le> x - 2 * (x div 2 div y) * y \\<Longrightarrow>\n    (x div y, x mod y) =\n    (let q = 2 * (x div 2 div y); r = x - q * y\n     in if y \\<le> r then (q + 1, r - y) else (q, r))", "hence \"x div y mod 2 = 0\""], ["proof (prove)\nusing this:\n  \\<not> y \\<le> x - 2 * (x div 2 div y) * y\n\ngoal (1 subgoal):\n 1. x div y mod 2 = 0", "unfolding r"], ["proof (prove)\nusing this:\n  \\<not> y \\<le> x mod y + x div y mod 2 * y\n\ngoal (1 subgoal):\n 1. x div y mod 2 = 0", "by(simp add: not_le)(metis Nat.add_0_right assms div_less div_mult_self2 mod_div_trivial mult.commute)"], ["proof (state)\nthis:\n  x div y mod 2 = 0\n\ngoal (1 subgoal):\n 1. \\<not> y \\<le> x - 2 * (x div 2 div y) * y \\<Longrightarrow>\n    (x div y, x mod y) =\n    (let q = 2 * (x div 2 div y); r = x - q * y\n     in if y \\<le> r then (q + 1, r - y) else (q, r))", "hence \"x div y = ?q\""], ["proof (prove)\nusing this:\n  x div y mod 2 = 0\n\ngoal (1 subgoal):\n 1. x div y = 2 * (x div 2 div y)", "unfolding q"], ["proof (prove)\nusing this:\n  x div y mod 2 = 0\n\ngoal (1 subgoal):\n 1. x div y = x div y - x div y mod 2", "by simp"], ["proof (state)\nthis:\n  x div y = 2 * (x div 2 div y)\n\ngoal (1 subgoal):\n 1. \\<not> y \\<le> x - 2 * (x div 2 div y) * y \\<Longrightarrow>\n    (x div y, x mod y) =\n    (let q = 2 * (x div 2 div y); r = x - q * y\n     in if y \\<le> r then (q + 1, r - y) else (q, r))", "moreover"], ["proof (state)\nthis:\n  x div y = 2 * (x div 2 div y)\n\ngoal (1 subgoal):\n 1. \\<not> y \\<le> x - 2 * (x div 2 div y) * y \\<Longrightarrow>\n    (x div y, x mod y) =\n    (let q = 2 * (x div 2 div y); r = x - q * y\n     in if y \\<le> r then (q + 1, r - y) else (q, r))", "hence \"x mod y = ?r\""], ["proof (prove)\nusing this:\n  x div y = 2 * (x div 2 div y)\n\ngoal (1 subgoal):\n 1. x mod y = x - 2 * (x div 2 div y) * y", "by (metis minus_div_mult_eq_mod [symmetric])"], ["proof (state)\nthis:\n  x mod y = x - 2 * (x div 2 div y) * y\n\ngoal (1 subgoal):\n 1. \\<not> y \\<le> x - 2 * (x div 2 div y) * y \\<Longrightarrow>\n    (x div y, x mod y) =\n    (let q = 2 * (x div 2 div y); r = x - q * y\n     in if y \\<le> r then (q + 1, r - y) else (q, r))", "ultimately"], ["proof (chain)\npicking this:\n  x div y = 2 * (x div 2 div y)\n  x mod y = x - 2 * (x div 2 div y) * y", "show ?thesis"], ["proof (prove)\nusing this:\n  x div y = 2 * (x div 2 div y)\n  x mod y = x - 2 * (x div 2 div y) * y\n\ngoal (1 subgoal):\n 1. (x div y, x mod y) =\n    (let q = 2 * (x div 2 div y); r = x - q * y\n     in if y \\<le> r then (q + 1, r - y) else (q, r))", "using False"], ["proof (prove)\nusing this:\n  x div y = 2 * (x div 2 div y)\n  x mod y = x - 2 * (x div 2 div y) * y\n  \\<not> y \\<le> x - 2 * (x div 2 div y) * y\n\ngoal (1 subgoal):\n 1. (x div y, x mod y) =\n    (let q = 2 * (x div 2 div y); r = x - q * y\n     in if y \\<le> r then (q + 1, r - y) else (q, r))", "by(simp add: Let_def)"], ["proof (state)\nthis:\n  (x div y, x mod y) =\n  (let q = 2 * (x div 2 div y); r = x - q * y\n   in if y \\<le> r then (q + 1, r - y) else (q, r))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (x div y, x mod y) =\n  (let q = 2 * (x div 2 div y); r = x - q * y\n   in if y \\<le> r then (q + 1, r - y) else (q, r))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma div_half_word:\n  fixes x y :: \"'a :: len word\"\n  assumes \"y \\<noteq> 0\"\n  shows \"(x div y, x mod y) = (let q = (x >> 1) div y << 1; r = x - q * y in if y \\<le> r then (q + 1, r - y) else (q, r))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x div y, x mod y) =\n    (let q = (x >> 1) div y << 1; r = x - q * y\n     in if y \\<le> r then (q + 1, r - y) else (q, r))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (x div y, x mod y) =\n    (let q = (x >> 1) div y << 1; r = x - q * y\n     in if y \\<le> r then (q + 1, r - y) else (q, r))", "obtain n where n: \"x = of_nat n\" \"n < 2 ^ LENGTH('a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>n.\n        \\<lbrakk>x = word_of_nat n; n < 2 ^ LENGTH('a)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule that [of \\<open>unat x\\<close>]) simp_all"], ["proof (state)\nthis:\n  x = word_of_nat n\n  n < 2 ^ LENGTH('a)\n\ngoal (1 subgoal):\n 1. (x div y, x mod y) =\n    (let q = (x >> 1) div y << 1; r = x - q * y\n     in if y \\<le> r then (q + 1, r - y) else (q, r))", "moreover"], ["proof (state)\nthis:\n  x = word_of_nat n\n  n < 2 ^ LENGTH('a)\n\ngoal (1 subgoal):\n 1. (x div y, x mod y) =\n    (let q = (x >> 1) div y << 1; r = x - q * y\n     in if y \\<le> r then (q + 1, r - y) else (q, r))", "obtain m where m: \"y = of_nat m\" \"m < 2 ^ LENGTH('a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>m.\n        \\<lbrakk>y = word_of_nat m; m < 2 ^ LENGTH('a)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule that [of \\<open>unat y\\<close>]) simp_all"], ["proof (state)\nthis:\n  y = word_of_nat m\n  m < 2 ^ LENGTH('a)\n\ngoal (1 subgoal):\n 1. (x div y, x mod y) =\n    (let q = (x >> 1) div y << 1; r = x - q * y\n     in if y \\<le> r then (q + 1, r - y) else (q, r))", "ultimately"], ["proof (chain)\npicking this:\n  x = word_of_nat n\n  n < 2 ^ LENGTH('a)\n  y = word_of_nat m\n  m < 2 ^ LENGTH('a)", "have [simp]: \\<open>unat (of_nat n :: 'a word) = n\\<close> \\<open>unat (of_nat m :: 'a word) = m\\<close>"], ["proof (prove)\nusing this:\n  x = word_of_nat n\n  n < 2 ^ LENGTH('a)\n  y = word_of_nat m\n  m < 2 ^ LENGTH('a)\n\ngoal (1 subgoal):\n 1. unat (word_of_nat n) = n &&& unat (word_of_nat m) = m", "by (transfer, simp add: take_bit_of_nat take_bit_nat_eq_self_iff)+"], ["proof (state)\nthis:\n  unat (word_of_nat n) = n\n  unat (word_of_nat m) = m\n\ngoal (1 subgoal):\n 1. (x div y, x mod y) =\n    (let q = (x >> 1) div y << 1; r = x - q * y\n     in if y \\<le> r then (q + 1, r - y) else (q, r))", "let ?q = \"(x >> 1) div y << 1\""], ["proof (state)\ngoal (1 subgoal):\n 1. (x div y, x mod y) =\n    (let q = (x >> 1) div y << 1; r = x - q * y\n     in if y \\<le> r then (q + 1, r - y) else (q, r))", "let ?q' = \"2 * (n div 2 div m)\""], ["proof (state)\ngoal (1 subgoal):\n 1. (x div y, x mod y) =\n    (let q = (x >> 1) div y << 1; r = x - q * y\n     in if y \\<le> r then (q + 1, r - y) else (q, r))", "have \"n div 2 div m < 2 ^ LENGTH('a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n div 2 div m < 2 ^ LENGTH('a)", "using n"], ["proof (prove)\nusing this:\n  x = word_of_nat n\n  n < 2 ^ LENGTH('a)\n\ngoal (1 subgoal):\n 1. n div 2 div m < 2 ^ LENGTH('a)", "by (metis of_nat_inverse unat_lt2p uno_simps(2))"], ["proof (state)\nthis:\n  n div 2 div m < 2 ^ LENGTH('a)\n\ngoal (1 subgoal):\n 1. (x div y, x mod y) =\n    (let q = (x >> 1) div y << 1; r = x - q * y\n     in if y \\<le> r then (q + 1, r - y) else (q, r))", "hence q: \"?q = of_nat ?q'\""], ["proof (prove)\nusing this:\n  n div 2 div m < 2 ^ LENGTH('a)\n\ngoal (1 subgoal):\n 1. (x >> 1) div y << 1 = word_of_nat (2 * (n div 2 div m))", "using n m"], ["proof (prove)\nusing this:\n  n div 2 div m < 2 ^ LENGTH('a)\n  x = word_of_nat n\n  n < 2 ^ LENGTH('a)\n  y = word_of_nat m\n  m < 2 ^ LENGTH('a)\n\ngoal (1 subgoal):\n 1. (x >> 1) div y << 1 = word_of_nat (2 * (n div 2 div m))", "by (auto simp add: shiftr_word_eq drop_bit_eq_div shiftl_t2n word_arith_nat_div uno_simps take_bit_nat_eq_self)"], ["proof (state)\nthis:\n  (x >> 1) div y << 1 = word_of_nat (2 * (n div 2 div m))\n\ngoal (1 subgoal):\n 1. (x div y, x mod y) =\n    (let q = (x >> 1) div y << 1; r = x - q * y\n     in if y \\<le> r then (q + 1, r - y) else (q, r))", "from assms"], ["proof (chain)\npicking this:\n  y \\<noteq> 0", "have \"m \\<noteq> 0\""], ["proof (prove)\nusing this:\n  y \\<noteq> 0\n\ngoal (1 subgoal):\n 1. m \\<noteq> 0", "using m"], ["proof (prove)\nusing this:\n  y \\<noteq> 0\n  y = word_of_nat m\n  m < 2 ^ LENGTH('a)\n\ngoal (1 subgoal):\n 1. m \\<noteq> 0", "by -(rule notI, simp)"], ["proof (state)\nthis:\n  m \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (x div y, x mod y) =\n    (let q = (x >> 1) div y << 1; r = x - q * y\n     in if y \\<le> r then (q + 1, r - y) else (q, r))", "from n"], ["proof (chain)\npicking this:\n  x = word_of_nat n\n  n < 2 ^ LENGTH('a)", "have \"2 * (n div 2 div m) < 2 ^ LENGTH('a)\""], ["proof (prove)\nusing this:\n  x = word_of_nat n\n  n < 2 ^ LENGTH('a)\n\ngoal (1 subgoal):\n 1. 2 * (n div 2 div m) < 2 ^ LENGTH('a)", "by(metis mult.commute div_mult2_eq minus_mod_eq_mult_div [symmetric] less_imp_diff_less of_nat_inverse unat_lt2p uno_simps(2))"], ["proof (state)\nthis:\n  2 * (n div 2 div m) < 2 ^ LENGTH('a)\n\ngoal (1 subgoal):\n 1. (x div y, x mod y) =\n    (let q = (x >> 1) div y << 1; r = x - q * y\n     in if y \\<le> r then (q + 1, r - y) else (q, r))", "moreover"], ["proof (state)\nthis:\n  2 * (n div 2 div m) < 2 ^ LENGTH('a)\n\ngoal (1 subgoal):\n 1. (x div y, x mod y) =\n    (let q = (x >> 1) div y << 1; r = x - q * y\n     in if y \\<le> r then (q + 1, r - y) else (q, r))", "have \"2 * (n div 2 div m) * m < 2 ^ LENGTH('a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * (n div 2 div m) * m < 2 ^ LENGTH('a)", "using n"], ["proof (prove)\nusing this:\n  x = word_of_nat n\n  n < 2 ^ LENGTH('a)\n\ngoal (1 subgoal):\n 1. 2 * (n div 2 div m) * m < 2 ^ LENGTH('a)", "unfolding div_mult2_eq[symmetric]"], ["proof (prove)\nusing this:\n  x = word_of_nat n\n  n < 2 ^ LENGTH('a)\n\ngoal (1 subgoal):\n 1. 2 * (n div (2 * m)) * m < 2 ^ LENGTH('a)", "by(subst (2) mult.commute)(simp add: minus_mod_eq_div_mult [symmetric] diff_mult_distrib minus_mod_eq_mult_div [symmetric] div_mult2_eq)"], ["proof (state)\nthis:\n  2 * (n div 2 div m) * m < 2 ^ LENGTH('a)\n\ngoal (1 subgoal):\n 1. (x div y, x mod y) =\n    (let q = (x >> 1) div y << 1; r = x - q * y\n     in if y \\<le> r then (q + 1, r - y) else (q, r))", "moreover"], ["proof (state)\nthis:\n  2 * (n div 2 div m) * m < 2 ^ LENGTH('a)\n\ngoal (1 subgoal):\n 1. (x div y, x mod y) =\n    (let q = (x >> 1) div y << 1; r = x - q * y\n     in if y \\<le> r then (q + 1, r - y) else (q, r))", "have \"2 * (n div 2 div m) * m \\<le> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * (n div 2 div m) * m \\<le> n", "by (simp flip: div_mult2_eq ac_simps)"], ["proof (state)\nthis:\n  2 * (n div 2 div m) * m \\<le> n\n\ngoal (1 subgoal):\n 1. (x div y, x mod y) =\n    (let q = (x >> 1) div y << 1; r = x - q * y\n     in if y \\<le> r then (q + 1, r - y) else (q, r))", "ultimately"], ["proof (chain)\npicking this:\n  2 * (n div 2 div m) < 2 ^ LENGTH('a)\n  2 * (n div 2 div m) * m < 2 ^ LENGTH('a)\n  2 * (n div 2 div m) * m \\<le> n", "have r: \"x - ?q * y = of_nat (n - ?q' * m)\"\n    and \"y \\<le> x - ?q * y \\<Longrightarrow> of_nat (n - ?q' * m) - y = of_nat (n - ?q' * m - m)\""], ["proof (prove)\nusing this:\n  2 * (n div 2 div m) < 2 ^ LENGTH('a)\n  2 * (n div 2 div m) * m < 2 ^ LENGTH('a)\n  2 * (n div 2 div m) * m \\<le> n\n\ngoal (1 subgoal):\n 1. x - ((x >> 1) div y << 1) * y =\n    word_of_nat (n - 2 * (n div 2 div m) * m) &&&\n    (y \\<le> x - ((x >> 1) div y << 1) * y \\<Longrightarrow>\n     word_of_nat (n - 2 * (n div 2 div m) * m) - y =\n     word_of_nat (n - 2 * (n div 2 div m) * m - m))", "using n m"], ["proof (prove)\nusing this:\n  2 * (n div 2 div m) < 2 ^ LENGTH('a)\n  2 * (n div 2 div m) * m < 2 ^ LENGTH('a)\n  2 * (n div 2 div m) * m \\<le> n\n  x = word_of_nat n\n  n < 2 ^ LENGTH('a)\n  y = word_of_nat m\n  m < 2 ^ LENGTH('a)\n\ngoal (1 subgoal):\n 1. x - ((x >> 1) div y << 1) * y =\n    word_of_nat (n - 2 * (n div 2 div m) * m) &&&\n    (y \\<le> x - ((x >> 1) div y << 1) * y \\<Longrightarrow>\n     word_of_nat (n - 2 * (n div 2 div m) * m) - y =\n     word_of_nat (n - 2 * (n div 2 div m) * m - m))", "unfolding q"], ["proof (prove)\nusing this:\n  2 * (n div 2 div m) < 2 ^ LENGTH('a)\n  2 * (n div 2 div m) * m < 2 ^ LENGTH('a)\n  2 * (n div 2 div m) * m \\<le> n\n  x = word_of_nat n\n  n < 2 ^ LENGTH('a)\n  y = word_of_nat m\n  m < 2 ^ LENGTH('a)\n\ngoal (1 subgoal):\n 1. x - word_of_nat (2 * (n div 2 div m)) * y =\n    word_of_nat (n - 2 * (n div 2 div m) * m) &&&\n    (y \\<le> x - word_of_nat (2 * (n div 2 div m)) * y \\<Longrightarrow>\n     word_of_nat (n - 2 * (n div 2 div m) * m) - y =\n     word_of_nat (n - 2 * (n div 2 div m) * m - m))", "apply (simp_all add: of_nat_diff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>word_of_nat m\n             \\<le> word_of_nat n -\n                   2 * word_of_nat (n div 2 div m) * word_of_nat m;\n     2 * (n div 2 div m) < 2 ^ LENGTH('a); 2 * (n div 2 div m) * m \\<le> n;\n     x = word_of_nat n; n < 2 ^ LENGTH('a); y = word_of_nat m;\n     m < 2 ^ LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> word_of_nat n -\n                      2 * word_of_nat (n div 2 div m) * word_of_nat m -\n                      word_of_nat m =\n                      word_of_nat (n - (2 * (n div 2 div m) * m + m))", "apply (subst of_nat_diff)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>word_of_nat m\n             \\<le> word_of_nat n -\n                   2 * word_of_nat (n div 2 div m) * word_of_nat m;\n     2 * (n div 2 div m) < 2 ^ LENGTH('a); 2 * (n div 2 div m) * m \\<le> n;\n     x = word_of_nat n; n < 2 ^ LENGTH('a); y = word_of_nat m;\n     m < 2 ^ LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> 2 * (n div 2 div m) * m + m \\<le> n\n 2. \\<lbrakk>word_of_nat m\n             \\<le> word_of_nat n -\n                   2 * word_of_nat (n div 2 div m) * word_of_nat m;\n     2 * (n div 2 div m) < 2 ^ LENGTH('a); 2 * (n div 2 div m) * m \\<le> n;\n     x = word_of_nat n; n < 2 ^ LENGTH('a); y = word_of_nat m;\n     m < 2 ^ LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> word_of_nat n -\n                      2 * word_of_nat (n div 2 div m) * word_of_nat m -\n                      word_of_nat m =\n                      word_of_nat n -\n                      word_of_nat (2 * (n div 2 div m) * m + m)", "apply (simp_all add: word_le_nat_alt take_bit_nat_eq_self unat_sub_if' unat_word_ariths)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>m \\<le> (if nat (of_bool (2 \\<le> LENGTH('a)) * 2) *\n                         (n div 2 div m) *\n                         m\n                         \\<le> n\n                      then unat (word_of_nat n) -\n                           unat\n                            (2 * word_of_nat (n div 2 div m) *\n                             word_of_nat m)\n                      else unat (word_of_nat n) + 2 ^ LENGTH('a) -\n                           unat\n                            (2 * word_of_nat (n div 2 div m) *\n                             word_of_nat m));\n     2 * (n div 2 div m) < 2 ^ LENGTH('a); 2 * (n div 2 div m) * m \\<le> n;\n     x = word_of_nat n; n < 2 ^ LENGTH('a); y = word_of_nat m;\n     m < 2 ^ LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> 2 * (n div 2 div m) * m + m \\<le> n", "apply (cases \\<open>2 \\<le> LENGTH('a)\\<close>)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>m \\<le> (if nat (of_bool (2 \\<le> LENGTH('a)) * 2) *\n                         (n div 2 div m) *\n                         m\n                         \\<le> n\n                      then unat (word_of_nat n) -\n                           unat\n                            (2 * word_of_nat (n div 2 div m) *\n                             word_of_nat m)\n                      else unat (word_of_nat n) + 2 ^ LENGTH('a) -\n                           unat\n                            (2 * word_of_nat (n div 2 div m) *\n                             word_of_nat m));\n     2 * (n div 2 div m) < 2 ^ LENGTH('a); 2 * (n div 2 div m) * m \\<le> n;\n     x = word_of_nat n; n < 2 ^ LENGTH('a); y = word_of_nat m;\n     m < 2 ^ LENGTH('a); 2 \\<le> LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> 2 * (n div 2 div m) * m + m \\<le> n\n 2. \\<lbrakk>m \\<le> (if nat (of_bool (2 \\<le> LENGTH('a)) * 2) *\n                         (n div 2 div m) *\n                         m\n                         \\<le> n\n                      then unat (word_of_nat n) -\n                           unat\n                            (2 * word_of_nat (n div 2 div m) *\n                             word_of_nat m)\n                      else unat (word_of_nat n) + 2 ^ LENGTH('a) -\n                           unat\n                            (2 * word_of_nat (n div 2 div m) *\n                             word_of_nat m));\n     2 * (n div 2 div m) < 2 ^ LENGTH('a); 2 * (n div 2 div m) * m \\<le> n;\n     x = word_of_nat n; n < 2 ^ LENGTH('a); y = word_of_nat m;\n     m < 2 ^ LENGTH('a); \\<not> 2 \\<le> LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> 2 * (n div 2 div m) * m + m \\<le> n", "apply (simp_all add: unat_word_ariths take_bit_nat_eq_self)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  x - ((x >> 1) div y << 1) * y = word_of_nat (n - 2 * (n div 2 div m) * m)\n  y \\<le> x - ((x >> 1) div y << 1) * y \\<Longrightarrow>\n  word_of_nat (n - 2 * (n div 2 div m) * m) - y =\n  word_of_nat (n - 2 * (n div 2 div m) * m - m)\n\ngoal (1 subgoal):\n 1. (x div y, x mod y) =\n    (let q = (x >> 1) div y << 1; r = x - q * y\n     in if y \\<le> r then (q + 1, r - y) else (q, r))", "then"], ["proof (chain)\npicking this:\n  x - ((x >> 1) div y << 1) * y = word_of_nat (n - 2 * (n div 2 div m) * m)\n  y \\<le> x - ((x >> 1) div y << 1) * y \\<Longrightarrow>\n  word_of_nat (n - 2 * (n div 2 div m) * m) - y =\n  word_of_nat (n - 2 * (n div 2 div m) * m - m)", "show ?thesis"], ["proof (prove)\nusing this:\n  x - ((x >> 1) div y << 1) * y = word_of_nat (n - 2 * (n div 2 div m) * m)\n  y \\<le> x - ((x >> 1) div y << 1) * y \\<Longrightarrow>\n  word_of_nat (n - 2 * (n div 2 div m) * m) - y =\n  word_of_nat (n - 2 * (n div 2 div m) * m - m)\n\ngoal (1 subgoal):\n 1. (x div y, x mod y) =\n    (let q = (x >> 1) div y << 1; r = x - q * y\n     in if y \\<le> r then (q + 1, r - y) else (q, r))", "using n m div_half_nat [OF \\<open>m \\<noteq> 0\\<close>, of n]"], ["proof (prove)\nusing this:\n  x - ((x >> 1) div y << 1) * y = word_of_nat (n - 2 * (n div 2 div m) * m)\n  y \\<le> x - ((x >> 1) div y << 1) * y \\<Longrightarrow>\n  word_of_nat (n - 2 * (n div 2 div m) * m) - y =\n  word_of_nat (n - 2 * (n div 2 div m) * m - m)\n  x = word_of_nat n\n  n < 2 ^ LENGTH('a)\n  y = word_of_nat m\n  m < 2 ^ LENGTH('a)\n  (n div m, n mod m) =\n  (let q = 2 * (n div 2 div m); r = n - q * m\n   in if m \\<le> r then (q + 1, r - m) else (q, r))\n\ngoal (1 subgoal):\n 1. (x div y, x mod y) =\n    (let q = (x >> 1) div y << 1; r = x - q * y\n     in if y \\<le> r then (q + 1, r - y) else (q, r))", "unfolding q"], ["proof (prove)\nusing this:\n  x - word_of_nat (2 * (n div 2 div m)) * y =\n  word_of_nat (n - 2 * (n div 2 div m) * m)\n  y \\<le> x - word_of_nat (2 * (n div 2 div m)) * y \\<Longrightarrow>\n  word_of_nat (n - 2 * (n div 2 div m) * m) - y =\n  word_of_nat (n - 2 * (n div 2 div m) * m - m)\n  x = word_of_nat n\n  n < 2 ^ LENGTH('a)\n  y = word_of_nat m\n  m < 2 ^ LENGTH('a)\n  (n div m, n mod m) =\n  (let q = 2 * (n div 2 div m); r = n - q * m\n   in if m \\<le> r then (q + 1, r - m) else (q, r))\n\ngoal (1 subgoal):\n 1. (x div y, x mod y) =\n    (let q = word_of_nat (2 * (n div 2 div m)); r = x - q * y\n     in if y \\<le> r then (q + 1, r - y) else (q, r))", "by (simp add: word_le_nat_alt word_div_def word_mod_def Let_def take_bit_nat_eq_self\n      flip: zdiv_int zmod_int\n      split del: if_split split: if_split_asm)"], ["proof (state)\nthis:\n  (x div y, x mod y) =\n  (let q = (x >> 1) div y << 1; r = x - q * y\n   in if y \\<le> r then (q + 1, r - y) else (q, r))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma word_test_bit_set_bits: \"(BITS n. f n :: 'a :: len word) !! n \\<longleftrightarrow> n < LENGTH('a) \\<and> f n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (BITS n. f n) !! n = (n < LENGTH('a) \\<and> f n)", "by (simp add: test_bit_eq_bit bit_set_bits_word_iff)"], ["", "lemma word_of_int_conv_set_bits: \"word_of_int i = (BITS n. i !! n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. word_of_int i = (BITS n. i !! n)", "by (rule word_eqI) (auto simp add: word_test_bit_set_bits)"], ["", "lemma word_and_mask_or_conv_and_mask:\n  \"n !! index \\<Longrightarrow> (n AND mask index) OR (1 << index) = n AND mask (index + 1)\"\n  for n :: \\<open>'a::len word\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. n !! index \\<Longrightarrow>\n    n AND mask index OR (1 << index) = n AND mask (index + 1)", "by(rule word_eqI)(auto simp add: word_ao_nth word_size nth_shiftl simp del: shiftl_1)"], ["", "lemma uint_and_mask_or_full:\n  fixes n :: \"'a :: len word\"\n  assumes \"n !! (LENGTH('a) - 1)\"\n  and \"mask1 = mask (LENGTH('a) - 1)\"\n  and \"mask2 = 1 << LENGTH('a) - 1\"\n  shows \"uint (n AND mask1) OR mask2 = uint n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. uint (n AND mask1) OR mask2 = uint n", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. uint (n AND mask1) OR mask2 = uint n", "have \"mask2 = uint (1 << LENGTH('a) - 1 :: 'a word)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mask2 = uint (1 << LENGTH('a) - 1)", "using assms"], ["proof (prove)\nusing this:\n  n !! (LENGTH('a) - 1)\n  mask1 = mask (LENGTH('a) - 1)\n  mask2 = 1 << LENGTH('a) - 1\n\ngoal (1 subgoal):\n 1. mask2 = uint (1 << LENGTH('a) - 1)", "by (simp add: uint_shiftl word_size bintrunc_shiftl del: shiftl_1)"], ["proof (state)\nthis:\n  mask2 = uint (1 << LENGTH('a) - 1)\n\ngoal (1 subgoal):\n 1. uint (n AND mask1) OR mask2 = uint n", "hence \"uint (n AND mask1) OR mask2 = uint (n AND mask1 OR (1 << LENGTH('a) - 1 :: 'a word))\""], ["proof (prove)\nusing this:\n  mask2 = uint (1 << LENGTH('a) - 1)\n\ngoal (1 subgoal):\n 1. uint (n AND mask1) OR mask2 =\n    uint (n AND mask1 OR (1 << LENGTH('a) - 1))", "by(simp add: uint_or)"], ["proof (state)\nthis:\n  uint (n AND mask1) OR mask2 = uint (n AND mask1 OR (1 << LENGTH('a) - 1))\n\ngoal (1 subgoal):\n 1. uint (n AND mask1) OR mask2 = uint n", "also"], ["proof (state)\nthis:\n  uint (n AND mask1) OR mask2 = uint (n AND mask1 OR (1 << LENGTH('a) - 1))\n\ngoal (1 subgoal):\n 1. uint (n AND mask1) OR mask2 = uint n", "have \"\\<dots> = uint (n AND mask (LENGTH('a) - 1 + 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. uint (n AND mask1 OR (1 << LENGTH('a) - 1)) =\n    uint (n AND mask (LENGTH('a) - 1 + 1))", "using assms"], ["proof (prove)\nusing this:\n  n !! (LENGTH('a) - 1)\n  mask1 = mask (LENGTH('a) - 1)\n  mask2 = 1 << LENGTH('a) - 1\n\ngoal (1 subgoal):\n 1. uint (n AND mask1 OR (1 << LENGTH('a) - 1)) =\n    uint (n AND mask (LENGTH('a) - 1 + 1))", "by(simp only: word_and_mask_or_conv_and_mask)"], ["proof (state)\nthis:\n  uint (n AND mask1 OR (1 << LENGTH('a) - 1)) =\n  uint (n AND mask (LENGTH('a) - 1 + 1))\n\ngoal (1 subgoal):\n 1. uint (n AND mask1) OR mask2 = uint n", "also"], ["proof (state)\nthis:\n  uint (n AND mask1 OR (1 << LENGTH('a) - 1)) =\n  uint (n AND mask (LENGTH('a) - 1 + 1))\n\ngoal (1 subgoal):\n 1. uint (n AND mask1) OR mask2 = uint n", "have \"\\<dots> = uint n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. uint (n AND mask (LENGTH('a) - 1 + 1)) = uint n", "by simp"], ["proof (state)\nthis:\n  uint (n AND mask (LENGTH('a) - 1 + 1)) = uint n\n\ngoal (1 subgoal):\n 1. uint (n AND mask1) OR mask2 = uint n", "finally"], ["proof (chain)\npicking this:\n  uint (n AND mask1) OR mask2 = uint n", "show ?thesis"], ["proof (prove)\nusing this:\n  uint (n AND mask1) OR mask2 = uint n\n\ngoal (1 subgoal):\n 1. uint (n AND mask1) OR mask2 = uint n", "."], ["proof (state)\nthis:\n  uint (n AND mask1) OR mask2 = uint n\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Division on @{typ \"'a word\"} is unsigned, but Scala and OCaml only have signed division and modulus.\\<close>"], ["", "lemmas word_sdiv_def = sdiv_word_def"], ["", "lemmas word_smod_def = smod_word_def"], ["", "lemma [code]:\n  \"x sdiv y =\n   (let x' = sint x; y' = sint y;\n        negative = (x' < 0) \\<noteq> (y' < 0);\n        result = abs x' div abs y'\n    in word_of_int (if negative then -result else result))\"\n  for x y :: \\<open>'a::len word\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. x sdiv y =\n    (let x' = sint x; y' = sint y; negative = (x' < 0) \\<noteq> (y' < 0);\n         result = \\<bar>x'\\<bar> div \\<bar>y'\\<bar>\n     in word_of_int (if negative then - result else result))", "by (simp add: sdiv_word_def signed_divide_int_def sgn_if Let_def not_less not_le)"], ["", "lemma [code]:\n  \"x smod y =\n   (let x' = sint x; y' = sint y;\n        negative = (x' < 0);\n        result = abs x' mod abs y'\n    in word_of_int (if negative then -result else result))\"\n  for x y :: \\<open>'a::len word\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. x smod y =\n    (let x' = sint x; y' = sint y; negative = x' < 0;\n         result = \\<bar>x'\\<bar> mod \\<bar>y'\\<bar>\n     in word_of_int (if negative then - result else result))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x smod y =\n    (let x' = sint x; y' = sint y; negative = x' < 0;\n         result = \\<bar>x'\\<bar> mod \\<bar>y'\\<bar>\n     in word_of_int (if negative then - result else result))", "have *: \\<open>k mod l = k - k div l * l\\<close> for k l :: int"], ["proof (prove)\ngoal (1 subgoal):\n 1. k mod l = k - k div l * l", "by (simp add: minus_div_mult_eq_mod)"], ["proof (state)\nthis:\n  ?k mod ?l = ?k - ?k div ?l * ?l\n\ngoal (1 subgoal):\n 1. x smod y =\n    (let x' = sint x; y' = sint y; negative = x' < 0;\n         result = \\<bar>x'\\<bar> mod \\<bar>y'\\<bar>\n     in word_of_int (if negative then - result else result))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. x smod y =\n    (let x' = sint x; y' = sint y; negative = x' < 0;\n         result = \\<bar>x'\\<bar> mod \\<bar>y'\\<bar>\n     in word_of_int (if negative then - result else result))", "by (simp add: smod_word_def signed_modulo_int_def signed_divide_int_def * sgn_if Let_def)"], ["proof (state)\nthis:\n  x smod y =\n  (let x' = sint x; y' = sint y; negative = x' < 0;\n       result = \\<bar>x'\\<bar> mod \\<bar>y'\\<bar>\n   in word_of_int (if negative then - result else result))\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  This algorithm implements unsigned division in terms of signed division.\n  Taken from Hacker's Delight.\n\\<close>"], ["", "lemma divmod_via_sdivmod:\n  fixes x y :: \"'a :: len word\"\n  assumes \"y \\<noteq> 0\"\n  shows\n  \"(x div y, x mod y) =\n  (if 1 << (LENGTH('a) - 1) \\<le> y then if x < y then (0, x) else (1, x - y)\n   else let q = ((x >> 1) sdiv y) << 1;\n            r = x - q * y\n        in if r \\<ge> y then (q + 1, r - y) else (q, r))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x div y, x mod y) =\n    (if 1 << LENGTH('a) - 1 \\<le> y\n     then if x < y then (0, x) else (1, x - y)\n     else let q = (x >> 1) sdiv y << 1; r = x - q * y\n          in if y \\<le> r then (q + 1, r - y) else (q, r))", "proof(cases \"1 << (LENGTH('a) - 1) \\<le> y\")"], ["proof (state)\ngoal (2 subgoals):\n 1. 1 << LENGTH('a) - 1 \\<le> y \\<Longrightarrow>\n    (x div y, x mod y) =\n    (if 1 << LENGTH('a) - 1 \\<le> y\n     then if x < y then (0, x) else (1, x - y)\n     else let q = (x >> 1) sdiv y << 1; r = x - q * y\n          in if y \\<le> r then (q + 1, r - y) else (q, r))\n 2. \\<not> 1 << LENGTH('a) - 1 \\<le> y \\<Longrightarrow>\n    (x div y, x mod y) =\n    (if 1 << LENGTH('a) - 1 \\<le> y\n     then if x < y then (0, x) else (1, x - y)\n     else let q = (x >> 1) sdiv y << 1; r = x - q * y\n          in if y \\<le> r then (q + 1, r - y) else (q, r))", "case True"], ["proof (state)\nthis:\n  1 << LENGTH('a) - 1 \\<le> y\n\ngoal (2 subgoals):\n 1. 1 << LENGTH('a) - 1 \\<le> y \\<Longrightarrow>\n    (x div y, x mod y) =\n    (if 1 << LENGTH('a) - 1 \\<le> y\n     then if x < y then (0, x) else (1, x - y)\n     else let q = (x >> 1) sdiv y << 1; r = x - q * y\n          in if y \\<le> r then (q + 1, r - y) else (q, r))\n 2. \\<not> 1 << LENGTH('a) - 1 \\<le> y \\<Longrightarrow>\n    (x div y, x mod y) =\n    (if 1 << LENGTH('a) - 1 \\<le> y\n     then if x < y then (0, x) else (1, x - y)\n     else let q = (x >> 1) sdiv y << 1; r = x - q * y\n          in if y \\<le> r then (q + 1, r - y) else (q, r))", "note y = this"], ["proof (state)\nthis:\n  1 << LENGTH('a) - 1 \\<le> y\n\ngoal (2 subgoals):\n 1. 1 << LENGTH('a) - 1 \\<le> y \\<Longrightarrow>\n    (x div y, x mod y) =\n    (if 1 << LENGTH('a) - 1 \\<le> y\n     then if x < y then (0, x) else (1, x - y)\n     else let q = (x >> 1) sdiv y << 1; r = x - q * y\n          in if y \\<le> r then (q + 1, r - y) else (q, r))\n 2. \\<not> 1 << LENGTH('a) - 1 \\<le> y \\<Longrightarrow>\n    (x div y, x mod y) =\n    (if 1 << LENGTH('a) - 1 \\<le> y\n     then if x < y then (0, x) else (1, x - y)\n     else let q = (x >> 1) sdiv y << 1; r = x - q * y\n          in if y \\<le> r then (q + 1, r - y) else (q, r))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (x div y, x mod y) =\n    (if 1 << LENGTH('a) - 1 \\<le> y\n     then if x < y then (0, x) else (1, x - y)\n     else let q = (x >> 1) sdiv y << 1; r = x - q * y\n          in if y \\<le> r then (q + 1, r - y) else (q, r))", "proof(cases \"x < y\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x < y \\<Longrightarrow>\n    (x div y, x mod y) =\n    (if 1 << LENGTH('a) - 1 \\<le> y\n     then if x < y then (0, x) else (1, x - y)\n     else let q = (x >> 1) sdiv y << 1; r = x - q * y\n          in if y \\<le> r then (q + 1, r - y) else (q, r))\n 2. \\<not> x < y \\<Longrightarrow>\n    (x div y, x mod y) =\n    (if 1 << LENGTH('a) - 1 \\<le> y\n     then if x < y then (0, x) else (1, x - y)\n     else let q = (x >> 1) sdiv y << 1; r = x - q * y\n          in if y \\<le> r then (q + 1, r - y) else (q, r))", "case True"], ["proof (state)\nthis:\n  x < y\n\ngoal (2 subgoals):\n 1. x < y \\<Longrightarrow>\n    (x div y, x mod y) =\n    (if 1 << LENGTH('a) - 1 \\<le> y\n     then if x < y then (0, x) else (1, x - y)\n     else let q = (x >> 1) sdiv y << 1; r = x - q * y\n          in if y \\<le> r then (q + 1, r - y) else (q, r))\n 2. \\<not> x < y \\<Longrightarrow>\n    (x div y, x mod y) =\n    (if 1 << LENGTH('a) - 1 \\<le> y\n     then if x < y then (0, x) else (1, x - y)\n     else let q = (x >> 1) sdiv y << 1; r = x - q * y\n          in if y \\<le> r then (q + 1, r - y) else (q, r))", "then"], ["proof (chain)\npicking this:\n  x < y", "have \"x mod y = x\""], ["proof (prove)\nusing this:\n  x < y\n\ngoal (1 subgoal):\n 1. x mod y = x", "by transfer simp"], ["proof (state)\nthis:\n  x mod y = x\n\ngoal (2 subgoals):\n 1. x < y \\<Longrightarrow>\n    (x div y, x mod y) =\n    (if 1 << LENGTH('a) - 1 \\<le> y\n     then if x < y then (0, x) else (1, x - y)\n     else let q = (x >> 1) sdiv y << 1; r = x - q * y\n          in if y \\<le> r then (q + 1, r - y) else (q, r))\n 2. \\<not> x < y \\<Longrightarrow>\n    (x div y, x mod y) =\n    (if 1 << LENGTH('a) - 1 \\<le> y\n     then if x < y then (0, x) else (1, x - y)\n     else let q = (x >> 1) sdiv y << 1; r = x - q * y\n          in if y \\<le> r then (q + 1, r - y) else (q, r))", "thus ?thesis"], ["proof (prove)\nusing this:\n  x mod y = x\n\ngoal (1 subgoal):\n 1. (x div y, x mod y) =\n    (if 1 << LENGTH('a) - 1 \\<le> y\n     then if x < y then (0, x) else (1, x - y)\n     else let q = (x >> 1) sdiv y << 1; r = x - q * y\n          in if y \\<le> r then (q + 1, r - y) else (q, r))", "using True y"], ["proof (prove)\nusing this:\n  x mod y = x\n  x < y\n  1 << LENGTH('a) - 1 \\<le> y\n\ngoal (1 subgoal):\n 1. (x div y, x mod y) =\n    (if 1 << LENGTH('a) - 1 \\<le> y\n     then if x < y then (0, x) else (1, x - y)\n     else let q = (x >> 1) sdiv y << 1; r = x - q * y\n          in if y \\<le> r then (q + 1, r - y) else (q, r))", "by(simp add: word_div_lt_eq_0)"], ["proof (state)\nthis:\n  (x div y, x mod y) =\n  (if 1 << LENGTH('a) - 1 \\<le> y then if x < y then (0, x) else (1, x - y)\n   else let q = (x >> 1) sdiv y << 1; r = x - q * y\n        in if y \\<le> r then (q + 1, r - y) else (q, r))\n\ngoal (1 subgoal):\n 1. \\<not> x < y \\<Longrightarrow>\n    (x div y, x mod y) =\n    (if 1 << LENGTH('a) - 1 \\<le> y\n     then if x < y then (0, x) else (1, x - y)\n     else let q = (x >> 1) sdiv y << 1; r = x - q * y\n          in if y \\<le> r then (q + 1, r - y) else (q, r))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> x < y \\<Longrightarrow>\n    (x div y, x mod y) =\n    (if 1 << LENGTH('a) - 1 \\<le> y\n     then if x < y then (0, x) else (1, x - y)\n     else let q = (x >> 1) sdiv y << 1; r = x - q * y\n          in if y \\<le> r then (q + 1, r - y) else (q, r))", "case False"], ["proof (state)\nthis:\n  \\<not> x < y\n\ngoal (1 subgoal):\n 1. \\<not> x < y \\<Longrightarrow>\n    (x div y, x mod y) =\n    (if 1 << LENGTH('a) - 1 \\<le> y\n     then if x < y then (0, x) else (1, x - y)\n     else let q = (x >> 1) sdiv y << 1; r = x - q * y\n          in if y \\<le> r then (q + 1, r - y) else (q, r))", "obtain n where n: \"y = of_nat n\" \"n < 2 ^ LENGTH('a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>n.\n        \\<lbrakk>y = word_of_nat n; n < 2 ^ LENGTH('a)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule that [of \\<open>unat y\\<close>]) simp_all"], ["proof (state)\nthis:\n  y = word_of_nat n\n  n < 2 ^ LENGTH('a)\n\ngoal (1 subgoal):\n 1. \\<not> x < y \\<Longrightarrow>\n    (x div y, x mod y) =\n    (if 1 << LENGTH('a) - 1 \\<le> y\n     then if x < y then (0, x) else (1, x - y)\n     else let q = (x >> 1) sdiv y << 1; r = x - q * y\n          in if y \\<le> r then (q + 1, r - y) else (q, r))", "have \"unat x < 2 ^ LENGTH('a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unat x < 2 ^ LENGTH('a)", "by(rule unat_lt2p)"], ["proof (state)\nthis:\n  unat x < 2 ^ LENGTH('a)\n\ngoal (1 subgoal):\n 1. \\<not> x < y \\<Longrightarrow>\n    (x div y, x mod y) =\n    (if 1 << LENGTH('a) - 1 \\<le> y\n     then if x < y then (0, x) else (1, x - y)\n     else let q = (x >> 1) sdiv y << 1; r = x - q * y\n          in if y \\<le> r then (q + 1, r - y) else (q, r))", "also"], ["proof (state)\nthis:\n  unat x < 2 ^ LENGTH('a)\n\ngoal (1 subgoal):\n 1. \\<not> x < y \\<Longrightarrow>\n    (x div y, x mod y) =\n    (if 1 << LENGTH('a) - 1 \\<le> y\n     then if x < y then (0, x) else (1, x - y)\n     else let q = (x >> 1) sdiv y << 1; r = x - q * y\n          in if y \\<le> r then (q + 1, r - y) else (q, r))", "have \"\\<dots> = 2 * 2 ^ (LENGTH('a) - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ LENGTH('a) = 2 * 2 ^ (LENGTH('a) - 1)", "by(metis Suc_pred len_gt_0 power_Suc One_nat_def)"], ["proof (state)\nthis:\n  2 ^ LENGTH('a) = 2 * 2 ^ (LENGTH('a) - 1)\n\ngoal (1 subgoal):\n 1. \\<not> x < y \\<Longrightarrow>\n    (x div y, x mod y) =\n    (if 1 << LENGTH('a) - 1 \\<le> y\n     then if x < y then (0, x) else (1, x - y)\n     else let q = (x >> 1) sdiv y << 1; r = x - q * y\n          in if y \\<le> r then (q + 1, r - y) else (q, r))", "also"], ["proof (state)\nthis:\n  2 ^ LENGTH('a) = 2 * 2 ^ (LENGTH('a) - 1)\n\ngoal (1 subgoal):\n 1. \\<not> x < y \\<Longrightarrow>\n    (x div y, x mod y) =\n    (if 1 << LENGTH('a) - 1 \\<le> y\n     then if x < y then (0, x) else (1, x - y)\n     else let q = (x >> 1) sdiv y << 1; r = x - q * y\n          in if y \\<le> r then (q + 1, r - y) else (q, r))", "have \"\\<dots> \\<le> 2 * n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * 2 ^ (LENGTH('a) - 1) \\<le> 2 * n", "using y n"], ["proof (prove)\nusing this:\n  1 << LENGTH('a) - 1 \\<le> y\n  y = word_of_nat n\n  n < 2 ^ LENGTH('a)\n\ngoal (1 subgoal):\n 1. 2 * 2 ^ (LENGTH('a) - 1) \\<le> 2 * n", "by transfer (simp add: push_bit_of_1 take_bit_eq_mod)"], ["proof (state)\nthis:\n  2 * 2 ^ (LENGTH('a) - 1) \\<le> 2 * n\n\ngoal (1 subgoal):\n 1. \\<not> x < y \\<Longrightarrow>\n    (x div y, x mod y) =\n    (if 1 << LENGTH('a) - 1 \\<le> y\n     then if x < y then (0, x) else (1, x - y)\n     else let q = (x >> 1) sdiv y << 1; r = x - q * y\n          in if y \\<le> r then (q + 1, r - y) else (q, r))", "finally"], ["proof (chain)\npicking this:\n  unat x < 2 * n", "have div: \"x div of_nat n = 1\""], ["proof (prove)\nusing this:\n  unat x < 2 * n\n\ngoal (1 subgoal):\n 1. x div word_of_nat n = 1", "using False n"], ["proof (prove)\nusing this:\n  unat x < 2 * n\n  \\<not> x < y\n  y = word_of_nat n\n  n < 2 ^ LENGTH('a)\n\ngoal (1 subgoal):\n 1. x div word_of_nat n = 1", "by (simp add: word_div_eq_1_iff take_bit_nat_eq_self)"], ["proof (state)\nthis:\n  x div word_of_nat n = 1\n\ngoal (1 subgoal):\n 1. \\<not> x < y \\<Longrightarrow>\n    (x div y, x mod y) =\n    (if 1 << LENGTH('a) - 1 \\<le> y\n     then if x < y then (0, x) else (1, x - y)\n     else let q = (x >> 1) sdiv y << 1; r = x - q * y\n          in if y \\<le> r then (q + 1, r - y) else (q, r))", "moreover"], ["proof (state)\nthis:\n  x div word_of_nat n = 1\n\ngoal (1 subgoal):\n 1. \\<not> x < y \\<Longrightarrow>\n    (x div y, x mod y) =\n    (if 1 << LENGTH('a) - 1 \\<le> y\n     then if x < y then (0, x) else (1, x - y)\n     else let q = (x >> 1) sdiv y << 1; r = x - q * y\n          in if y \\<le> r then (q + 1, r - y) else (q, r))", "have \"x mod y = x - x div y * y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x mod y = x - x div y * y", "by (simp add: minus_div_mult_eq_mod)"], ["proof (state)\nthis:\n  x mod y = x - x div y * y\n\ngoal (1 subgoal):\n 1. \\<not> x < y \\<Longrightarrow>\n    (x div y, x mod y) =\n    (if 1 << LENGTH('a) - 1 \\<le> y\n     then if x < y then (0, x) else (1, x - y)\n     else let q = (x >> 1) sdiv y << 1; r = x - q * y\n          in if y \\<le> r then (q + 1, r - y) else (q, r))", "with div n"], ["proof (chain)\npicking this:\n  x div word_of_nat n = 1\n  y = word_of_nat n\n  n < 2 ^ LENGTH('a)\n  x mod y = x - x div y * y", "have \"x mod y = x - y\""], ["proof (prove)\nusing this:\n  x div word_of_nat n = 1\n  y = word_of_nat n\n  n < 2 ^ LENGTH('a)\n  x mod y = x - x div y * y\n\ngoal (1 subgoal):\n 1. x mod y = x - y", "by simp"], ["proof (state)\nthis:\n  x mod y = x - y\n\ngoal (1 subgoal):\n 1. \\<not> x < y \\<Longrightarrow>\n    (x div y, x mod y) =\n    (if 1 << LENGTH('a) - 1 \\<le> y\n     then if x < y then (0, x) else (1, x - y)\n     else let q = (x >> 1) sdiv y << 1; r = x - q * y\n          in if y \\<le> r then (q + 1, r - y) else (q, r))", "ultimately"], ["proof (chain)\npicking this:\n  x div word_of_nat n = 1\n  x mod y = x - y", "show ?thesis"], ["proof (prove)\nusing this:\n  x div word_of_nat n = 1\n  x mod y = x - y\n\ngoal (1 subgoal):\n 1. (x div y, x mod y) =\n    (if 1 << LENGTH('a) - 1 \\<le> y\n     then if x < y then (0, x) else (1, x - y)\n     else let q = (x >> 1) sdiv y << 1; r = x - q * y\n          in if y \\<le> r then (q + 1, r - y) else (q, r))", "using False y n"], ["proof (prove)\nusing this:\n  x div word_of_nat n = 1\n  x mod y = x - y\n  \\<not> x < y\n  1 << LENGTH('a) - 1 \\<le> y\n  y = word_of_nat n\n  n < 2 ^ LENGTH('a)\n\ngoal (1 subgoal):\n 1. (x div y, x mod y) =\n    (if 1 << LENGTH('a) - 1 \\<le> y\n     then if x < y then (0, x) else (1, x - y)\n     else let q = (x >> 1) sdiv y << 1; r = x - q * y\n          in if y \\<le> r then (q + 1, r - y) else (q, r))", "by simp"], ["proof (state)\nthis:\n  (x div y, x mod y) =\n  (if 1 << LENGTH('a) - 1 \\<le> y then if x < y then (0, x) else (1, x - y)\n   else let q = (x >> 1) sdiv y << 1; r = x - q * y\n        in if y \\<le> r then (q + 1, r - y) else (q, r))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (x div y, x mod y) =\n  (if 1 << LENGTH('a) - 1 \\<le> y then if x < y then (0, x) else (1, x - y)\n   else let q = (x >> 1) sdiv y << 1; r = x - q * y\n        in if y \\<le> r then (q + 1, r - y) else (q, r))\n\ngoal (1 subgoal):\n 1. \\<not> 1 << LENGTH('a) - 1 \\<le> y \\<Longrightarrow>\n    (x div y, x mod y) =\n    (if 1 << LENGTH('a) - 1 \\<le> y\n     then if x < y then (0, x) else (1, x - y)\n     else let q = (x >> 1) sdiv y << 1; r = x - q * y\n          in if y \\<le> r then (q + 1, r - y) else (q, r))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> 1 << LENGTH('a) - 1 \\<le> y \\<Longrightarrow>\n    (x div y, x mod y) =\n    (if 1 << LENGTH('a) - 1 \\<le> y\n     then if x < y then (0, x) else (1, x - y)\n     else let q = (x >> 1) sdiv y << 1; r = x - q * y\n          in if y \\<le> r then (q + 1, r - y) else (q, r))", "case False"], ["proof (state)\nthis:\n  \\<not> 1 << LENGTH('a) - 1 \\<le> y\n\ngoal (1 subgoal):\n 1. \\<not> 1 << LENGTH('a) - 1 \\<le> y \\<Longrightarrow>\n    (x div y, x mod y) =\n    (if 1 << LENGTH('a) - 1 \\<le> y\n     then if x < y then (0, x) else (1, x - y)\n     else let q = (x >> 1) sdiv y << 1; r = x - q * y\n          in if y \\<le> r then (q + 1, r - y) else (q, r))", "note y = this"], ["proof (state)\nthis:\n  \\<not> 1 << LENGTH('a) - 1 \\<le> y\n\ngoal (1 subgoal):\n 1. \\<not> 1 << LENGTH('a) - 1 \\<le> y \\<Longrightarrow>\n    (x div y, x mod y) =\n    (if 1 << LENGTH('a) - 1 \\<le> y\n     then if x < y then (0, x) else (1, x - y)\n     else let q = (x >> 1) sdiv y << 1; r = x - q * y\n          in if y \\<le> r then (q + 1, r - y) else (q, r))", "obtain n where n: \"x = of_nat n\" \"n < 2 ^ LENGTH('a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>n.\n        \\<lbrakk>x = word_of_nat n; n < 2 ^ LENGTH('a)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule that [of \\<open>unat x\\<close>]) simp_all"], ["proof (state)\nthis:\n  x = word_of_nat n\n  n < 2 ^ LENGTH('a)\n\ngoal (1 subgoal):\n 1. \\<not> 1 << LENGTH('a) - 1 \\<le> y \\<Longrightarrow>\n    (x div y, x mod y) =\n    (if 1 << LENGTH('a) - 1 \\<le> y\n     then if x < y then (0, x) else (1, x - y)\n     else let q = (x >> 1) sdiv y << 1; r = x - q * y\n          in if y \\<le> r then (q + 1, r - y) else (q, r))", "hence \"int n div 2 + 2 ^ (LENGTH('a) - Suc 0) < 2 ^ LENGTH('a)\""], ["proof (prove)\nusing this:\n  x = word_of_nat n\n  n < 2 ^ LENGTH('a)\n\ngoal (1 subgoal):\n 1. int n div 2 + 2 ^ (LENGTH('a) - Suc 0) < 2 ^ LENGTH('a)", "by (cases \\<open>LENGTH('a)\\<close>)\n      (auto dest: less_imp_of_nat_less [where ?'a = int])"], ["proof (state)\nthis:\n  int n div 2 + 2 ^ (LENGTH('a) - Suc 0) < 2 ^ LENGTH('a)\n\ngoal (1 subgoal):\n 1. \\<not> 1 << LENGTH('a) - 1 \\<le> y \\<Longrightarrow>\n    (x div y, x mod y) =\n    (if 1 << LENGTH('a) - 1 \\<le> y\n     then if x < y then (0, x) else (1, x - y)\n     else let q = (x >> 1) sdiv y << 1; r = x - q * y\n          in if y \\<le> r then (q + 1, r - y) else (q, r))", "with y n"], ["proof (chain)\npicking this:\n  \\<not> 1 << LENGTH('a) - 1 \\<le> y\n  x = word_of_nat n\n  n < 2 ^ LENGTH('a)\n  int n div 2 + 2 ^ (LENGTH('a) - Suc 0) < 2 ^ LENGTH('a)", "have \"sint (x >> 1) = uint (x >> 1)\""], ["proof (prove)\nusing this:\n  \\<not> 1 << LENGTH('a) - 1 \\<le> y\n  x = word_of_nat n\n  n < 2 ^ LENGTH('a)\n  int n div 2 + 2 ^ (LENGTH('a) - Suc 0) < 2 ^ LENGTH('a)\n\ngoal (1 subgoal):\n 1. sint (x >> 1) = uint (x >> 1)", "by (simp add: sint_uint sbintrunc_mod2p shiftr_div_2n take_bit_nat_eq_self)"], ["proof (state)\nthis:\n  sint (x >> 1) = uint (x >> 1)\n\ngoal (1 subgoal):\n 1. \\<not> 1 << LENGTH('a) - 1 \\<le> y \\<Longrightarrow>\n    (x div y, x mod y) =\n    (if 1 << LENGTH('a) - 1 \\<le> y\n     then if x < y then (0, x) else (1, x - y)\n     else let q = (x >> 1) sdiv y << 1; r = x - q * y\n          in if y \\<le> r then (q + 1, r - y) else (q, r))", "moreover"], ["proof (state)\nthis:\n  sint (x >> 1) = uint (x >> 1)\n\ngoal (1 subgoal):\n 1. \\<not> 1 << LENGTH('a) - 1 \\<le> y \\<Longrightarrow>\n    (x div y, x mod y) =\n    (if 1 << LENGTH('a) - 1 \\<le> y\n     then if x < y then (0, x) else (1, x - y)\n     else let q = (x >> 1) sdiv y << 1; r = x - q * y\n          in if y \\<le> r then (q + 1, r - y) else (q, r))", "have \"uint y + 2 ^ (LENGTH('a) - Suc 0) < 2 ^ LENGTH('a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. uint y + 2 ^ (LENGTH('a) - Suc 0) < 2 ^ LENGTH('a)", "using y"], ["proof (prove)\nusing this:\n  \\<not> 1 << LENGTH('a) - 1 \\<le> y\n\ngoal (1 subgoal):\n 1. uint y + 2 ^ (LENGTH('a) - Suc 0) < 2 ^ LENGTH('a)", "by (cases \"LENGTH('a)\")\n      (simp_all add: not_le word_2p_lem word_size)"], ["proof (state)\nthis:\n  uint y + 2 ^ (LENGTH('a) - Suc 0) < 2 ^ LENGTH('a)\n\ngoal (1 subgoal):\n 1. \\<not> 1 << LENGTH('a) - 1 \\<le> y \\<Longrightarrow>\n    (x div y, x mod y) =\n    (if 1 << LENGTH('a) - 1 \\<le> y\n     then if x < y then (0, x) else (1, x - y)\n     else let q = (x >> 1) sdiv y << 1; r = x - q * y\n          in if y \\<le> r then (q + 1, r - y) else (q, r))", "then"], ["proof (chain)\npicking this:\n  uint y + 2 ^ (LENGTH('a) - Suc 0) < 2 ^ LENGTH('a)", "have \"sint y = uint y\""], ["proof (prove)\nusing this:\n  uint y + 2 ^ (LENGTH('a) - Suc 0) < 2 ^ LENGTH('a)\n\ngoal (1 subgoal):\n 1. sint y = uint y", "by (simp add: sint_uint sbintrunc_mod2p)"], ["proof (state)\nthis:\n  sint y = uint y\n\ngoal (1 subgoal):\n 1. \\<not> 1 << LENGTH('a) - 1 \\<le> y \\<Longrightarrow>\n    (x div y, x mod y) =\n    (if 1 << LENGTH('a) - 1 \\<le> y\n     then if x < y then (0, x) else (1, x - y)\n     else let q = (x >> 1) sdiv y << 1; r = x - q * y\n          in if y \\<le> r then (q + 1, r - y) else (q, r))", "ultimately"], ["proof (chain)\npicking this:\n  sint (x >> 1) = uint (x >> 1)\n  sint y = uint y", "show ?thesis"], ["proof (prove)\nusing this:\n  sint (x >> 1) = uint (x >> 1)\n  sint y = uint y\n\ngoal (1 subgoal):\n 1. (x div y, x mod y) =\n    (if 1 << LENGTH('a) - 1 \\<le> y\n     then if x < y then (0, x) else (1, x - y)\n     else let q = (x >> 1) sdiv y << 1; r = x - q * y\n          in if y \\<le> r then (q + 1, r - y) else (q, r))", "using y"], ["proof (prove)\nusing this:\n  sint (x >> 1) = uint (x >> 1)\n  sint y = uint y\n  \\<not> 1 << LENGTH('a) - 1 \\<le> y\n\ngoal (1 subgoal):\n 1. (x div y, x mod y) =\n    (if 1 << LENGTH('a) - 1 \\<le> y\n     then if x < y then (0, x) else (1, x - y)\n     else let q = (x >> 1) sdiv y << 1; r = x - q * y\n          in if y \\<le> r then (q + 1, r - y) else (q, r))", "apply (subst div_half_word [OF assms])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sint (x >> 1) = uint (x >> 1); sint y = uint y;\n     \\<not> 1 << LENGTH('a) - 1 \\<le> y\\<rbrakk>\n    \\<Longrightarrow> (let q = (x >> 1) div y << 1; r = x - q * y\n                       in if y \\<le> r then (q + 1, r - y) else (q, r)) =\n                      (if 1 << LENGTH('a) - 1 \\<le> y\n                       then if x < y then (0, x) else (1, x - y)\n                       else let q = (x >> 1) sdiv y << 1; r = x - q * y\n                            in if y \\<le> r then (q + 1, r - y) else (q, r))", "apply (simp add: sdiv_word_def signed_divide_int_def flip: uint_div)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (x div y, x mod y) =\n  (if 1 << LENGTH('a) - 1 \\<le> y then if x < y then (0, x) else (1, x - y)\n   else let q = (x >> 1) sdiv y << 1; r = x - q * y\n        in if y \\<le> r then (q + 1, r - y) else (q, r))\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>More implementations tailored towards target-language implementations\\<close>"], ["", "context\nincludes integer.lifting\nbegin"], ["", "lift_definition word_of_integer :: \"integer \\<Rightarrow> 'a :: len word\" is word_of_int"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma word_of_integer_code [code]: \"word_of_integer n = word_of_int (int_of_integer n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. word_of_integer n = word_of_int (int_of_integer n)", "by(simp add: word_of_integer.rep_eq)"], ["", "end"], ["", "lemma word_of_int_code:\n  \"uint (word_of_int x :: 'a word) = x AND mask (LENGTH('a :: len))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. uint (word_of_int x) = x AND mask LENGTH('a)", "by (simp add: take_bit_eq_mask)"], ["", "context fixes f :: \"nat \\<Rightarrow> bool\" begin"], ["", "definition set_bits_aux :: \\<open>'a word \\<Rightarrow> nat \\<Rightarrow> 'a :: len word\\<close>\n  where \\<open>set_bits_aux w n = push_bit n w OR take_bit n (set_bits f)\\<close>"], ["", "lemma set_bits_aux_conv:\n  \\<open>set_bits_aux w n = (w << n) OR (set_bits f AND mask n)\\<close>\n  for w :: \\<open>'a::len word\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.set_bits_aux w n = (w << n) OR set_bits f AND mask n", "by (rule bit_word_eqI)\n    (auto simp add: set_bits_aux_def shiftl_word_eq bit_and_iff bit_or_iff bit_push_bit_iff bit_take_bit_iff bit_mask_iff bit_set_bits_word_iff)"], ["", "corollary set_bits_conv_set_bits_aux:\n  \\<open>set_bits f = (set_bits_aux 0 (LENGTH('a)) :: 'a :: len word)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. set_bits f = local.set_bits_aux 0 LENGTH('a)", "by (simp add: set_bits_aux_conv)"], ["", "lemma set_bits_aux_0 [simp]:\n  \\<open>set_bits_aux w 0 = w\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.set_bits_aux w 0 = w", "by  (simp add: set_bits_aux_conv)"], ["", "lemma set_bits_aux_Suc [simp]:\n  \\<open>set_bits_aux w (Suc n) = set_bits_aux ((w << 1) OR (if f n then 1 else 0)) n\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.set_bits_aux w (Suc n) =\n    local.set_bits_aux ((w << 1) OR (if f n then 1 else 0)) n", "by (simp add: set_bits_aux_def shiftl_word_eq bit_eq_iff bit_or_iff bit_push_bit_iff bit_take_bit_iff bit_set_bits_word_iff)\n    (auto simp add: bit_exp_iff not_less bit_1_iff less_Suc_eq_le)"], ["", "lemma set_bits_aux_simps [code]:\n  \\<open>set_bits_aux w 0 = w\\<close>\n  \\<open>set_bits_aux w (Suc n) = set_bits_aux ((w << 1) OR (if f n then 1 else 0)) n\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.set_bits_aux w 0 = w &&&\n    local.set_bits_aux w (Suc n) =\n    local.set_bits_aux ((w << 1) OR (if f n then 1 else 0)) n", "by simp_all"], ["", "end"], ["", "lemma word_of_int_via_signed:\n  fixes mask\n  assumes mask_def: \"mask = Bit_Operations.mask (LENGTH('a))\"\n  and shift_def: \"shift = 1 << LENGTH('a)\"\n  and index_def: \"index = LENGTH('a) - 1\"\n  and overflow_def:\"overflow = 1 << (LENGTH('a) - 1)\"\n  and least_def: \"least = - overflow\"\n  shows\n  \"(word_of_int i :: 'a :: len word) =\n   (let i' = i AND mask\n    in if i' !! index then\n         if i' - shift < least \\<or> overflow \\<le> i' - shift then arbitrary1 i' else word_of_int (i' - shift)\n       else if i' < least \\<or> overflow \\<le> i' then arbitrary2 i' else word_of_int i')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. word_of_int i =\n    (let i' = i AND mask\n     in if i' !! index\n        then if i' - shift < least \\<or> overflow \\<le> i' - shift\n             then arbitrary1 i' else word_of_int (i' - shift)\n        else if i' < least \\<or> overflow \\<le> i' then arbitrary2 i'\n             else word_of_int i')", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. word_of_int i =\n    (let i' = i AND mask\n     in if i' !! index\n        then if i' - shift < least \\<or> overflow \\<le> i' - shift\n             then arbitrary1 i' else word_of_int (i' - shift)\n        else if i' < least \\<or> overflow \\<le> i' then arbitrary2 i'\n             else word_of_int i')", "define i' where \"i' = i AND mask\""], ["proof (state)\nthis:\n  i' = i AND mask\n\ngoal (1 subgoal):\n 1. word_of_int i =\n    (let i' = i AND mask\n     in if i' !! index\n        then if i' - shift < least \\<or> overflow \\<le> i' - shift\n             then arbitrary1 i' else word_of_int (i' - shift)\n        else if i' < least \\<or> overflow \\<le> i' then arbitrary2 i'\n             else word_of_int i')", "have \"shift = mask + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. shift = mask + 1", "unfolding assms"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 << LENGTH('a) = mask LENGTH('a) + 1", "by(simp add: bin_mask_p1_conv_shift)"], ["proof (state)\nthis:\n  shift = mask + 1\n\ngoal (1 subgoal):\n 1. word_of_int i =\n    (let i' = i AND mask\n     in if i' !! index\n        then if i' - shift < least \\<or> overflow \\<le> i' - shift\n             then arbitrary1 i' else word_of_int (i' - shift)\n        else if i' < least \\<or> overflow \\<le> i' then arbitrary2 i'\n             else word_of_int i')", "hence \"i' < shift\""], ["proof (prove)\nusing this:\n  shift = mask + 1\n\ngoal (1 subgoal):\n 1. i' < shift", "by(simp add: mask_def i'_def int_and_le)"], ["proof (state)\nthis:\n  i' < shift\n\ngoal (1 subgoal):\n 1. word_of_int i =\n    (let i' = i AND mask\n     in if i' !! index\n        then if i' - shift < least \\<or> overflow \\<le> i' - shift\n             then arbitrary1 i' else word_of_int (i' - shift)\n        else if i' < least \\<or> overflow \\<le> i' then arbitrary2 i'\n             else word_of_int i')", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. word_of_int i =\n    (let i' = i AND mask\n     in if i' !! index\n        then if i' - shift < least \\<or> overflow \\<le> i' - shift\n             then arbitrary1 i' else word_of_int (i' - shift)\n        else if i' < least \\<or> overflow \\<le> i' then arbitrary2 i'\n             else word_of_int i')", "proof(cases \"i' !! index\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i' !! index \\<Longrightarrow>\n    word_of_int i =\n    (let i' = i AND mask\n     in if i' !! index\n        then if i' - shift < least \\<or> overflow \\<le> i' - shift\n             then arbitrary1 i' else word_of_int (i' - shift)\n        else if i' < least \\<or> overflow \\<le> i' then arbitrary2 i'\n             else word_of_int i')\n 2. \\<not> i' !! index \\<Longrightarrow>\n    word_of_int i =\n    (let i' = i AND mask\n     in if i' !! index\n        then if i' - shift < least \\<or> overflow \\<le> i' - shift\n             then arbitrary1 i' else word_of_int (i' - shift)\n        else if i' < least \\<or> overflow \\<le> i' then arbitrary2 i'\n             else word_of_int i')", "case True"], ["proof (state)\nthis:\n  i' !! index\n\ngoal (2 subgoals):\n 1. i' !! index \\<Longrightarrow>\n    word_of_int i =\n    (let i' = i AND mask\n     in if i' !! index\n        then if i' - shift < least \\<or> overflow \\<le> i' - shift\n             then arbitrary1 i' else word_of_int (i' - shift)\n        else if i' < least \\<or> overflow \\<le> i' then arbitrary2 i'\n             else word_of_int i')\n 2. \\<not> i' !! index \\<Longrightarrow>\n    word_of_int i =\n    (let i' = i AND mask\n     in if i' !! index\n        then if i' - shift < least \\<or> overflow \\<le> i' - shift\n             then arbitrary1 i' else word_of_int (i' - shift)\n        else if i' < least \\<or> overflow \\<le> i' then arbitrary2 i'\n             else word_of_int i')", "then"], ["proof (chain)\npicking this:\n  i' !! index", "have unf: \"i' = overflow OR i'\""], ["proof (prove)\nusing this:\n  i' !! index\n\ngoal (1 subgoal):\n 1. i' = overflow OR i'", "apply (simp add: assms i'_def shiftl_eq_push_bit push_bit_of_1 flip: take_bit_eq_mask)"], ["proof (prove)\ngoal (1 subgoal):\n 1. bit (take_bit LENGTH('a) i) (LENGTH('a) - Suc 0) \\<Longrightarrow>\n    take_bit LENGTH('a) i =\n    2 ^ (LENGTH('a) - Suc 0) OR take_bit LENGTH('a) i", "apply (rule bit_eqI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>bit (take_bit LENGTH('a) i) (LENGTH('a) - Suc 0);\n        2 ^ n \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> bit (take_bit LENGTH('a) i) n =\n                         bit (2 ^ (LENGTH('a) - Suc 0) OR\n                              take_bit LENGTH('a) i)\n                          n", "apply (auto simp add: bit_take_bit_iff bit_or_iff bit_exp_iff)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  i' = overflow OR i'\n\ngoal (2 subgoals):\n 1. i' !! index \\<Longrightarrow>\n    word_of_int i =\n    (let i' = i AND mask\n     in if i' !! index\n        then if i' - shift < least \\<or> overflow \\<le> i' - shift\n             then arbitrary1 i' else word_of_int (i' - shift)\n        else if i' < least \\<or> overflow \\<le> i' then arbitrary2 i'\n             else word_of_int i')\n 2. \\<not> i' !! index \\<Longrightarrow>\n    word_of_int i =\n    (let i' = i AND mask\n     in if i' !! index\n        then if i' - shift < least \\<or> overflow \\<le> i' - shift\n             then arbitrary1 i' else word_of_int (i' - shift)\n        else if i' < least \\<or> overflow \\<le> i' then arbitrary2 i'\n             else word_of_int i')", "have \"overflow \\<le> i'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. overflow \\<le> i'", "by(subst unf)(rule le_int_or, simp add: bin_sign_and assms i'_def)"], ["proof (state)\nthis:\n  overflow \\<le> i'\n\ngoal (2 subgoals):\n 1. i' !! index \\<Longrightarrow>\n    word_of_int i =\n    (let i' = i AND mask\n     in if i' !! index\n        then if i' - shift < least \\<or> overflow \\<le> i' - shift\n             then arbitrary1 i' else word_of_int (i' - shift)\n        else if i' < least \\<or> overflow \\<le> i' then arbitrary2 i'\n             else word_of_int i')\n 2. \\<not> i' !! index \\<Longrightarrow>\n    word_of_int i =\n    (let i' = i AND mask\n     in if i' !! index\n        then if i' - shift < least \\<or> overflow \\<le> i' - shift\n             then arbitrary1 i' else word_of_int (i' - shift)\n        else if i' < least \\<or> overflow \\<le> i' then arbitrary2 i'\n             else word_of_int i')", "hence \"i' - shift < least \\<longleftrightarrow> False\""], ["proof (prove)\nusing this:\n  overflow \\<le> i'\n\ngoal (1 subgoal):\n 1. (i' - shift < least) = False", "unfolding assms"], ["proof (prove)\nusing this:\n  1 << LENGTH('a) - 1 \\<le> i'\n\ngoal (1 subgoal):\n 1. (i' - (1 << LENGTH('a)) < - (1 << LENGTH('a) - 1)) = False", "by(cases \"LENGTH('a)\")(simp_all add: not_less)"], ["proof (state)\nthis:\n  (i' - shift < least) = False\n\ngoal (2 subgoals):\n 1. i' !! index \\<Longrightarrow>\n    word_of_int i =\n    (let i' = i AND mask\n     in if i' !! index\n        then if i' - shift < least \\<or> overflow \\<le> i' - shift\n             then arbitrary1 i' else word_of_int (i' - shift)\n        else if i' < least \\<or> overflow \\<le> i' then arbitrary2 i'\n             else word_of_int i')\n 2. \\<not> i' !! index \\<Longrightarrow>\n    word_of_int i =\n    (let i' = i AND mask\n     in if i' !! index\n        then if i' - shift < least \\<or> overflow \\<le> i' - shift\n             then arbitrary1 i' else word_of_int (i' - shift)\n        else if i' < least \\<or> overflow \\<le> i' then arbitrary2 i'\n             else word_of_int i')", "moreover"], ["proof (state)\nthis:\n  (i' - shift < least) = False\n\ngoal (2 subgoals):\n 1. i' !! index \\<Longrightarrow>\n    word_of_int i =\n    (let i' = i AND mask\n     in if i' !! index\n        then if i' - shift < least \\<or> overflow \\<le> i' - shift\n             then arbitrary1 i' else word_of_int (i' - shift)\n        else if i' < least \\<or> overflow \\<le> i' then arbitrary2 i'\n             else word_of_int i')\n 2. \\<not> i' !! index \\<Longrightarrow>\n    word_of_int i =\n    (let i' = i AND mask\n     in if i' !! index\n        then if i' - shift < least \\<or> overflow \\<le> i' - shift\n             then arbitrary1 i' else word_of_int (i' - shift)\n        else if i' < least \\<or> overflow \\<le> i' then arbitrary2 i'\n             else word_of_int i')", "have \"overflow \\<le> i' - shift \\<longleftrightarrow> False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (overflow \\<le> i' - shift) = False", "using \\<open>i' < shift\\<close>"], ["proof (prove)\nusing this:\n  i' < shift\n\ngoal (1 subgoal):\n 1. (overflow \\<le> i' - shift) = False", "unfolding assms"], ["proof (prove)\nusing this:\n  i' < 1 << LENGTH('a)\n\ngoal (1 subgoal):\n 1. (1 << LENGTH('a) - 1 \\<le> i' - (1 << LENGTH('a))) = False", "by(cases \"LENGTH('a)\")(auto simp add: not_le elim: less_le_trans)"], ["proof (state)\nthis:\n  (overflow \\<le> i' - shift) = False\n\ngoal (2 subgoals):\n 1. i' !! index \\<Longrightarrow>\n    word_of_int i =\n    (let i' = i AND mask\n     in if i' !! index\n        then if i' - shift < least \\<or> overflow \\<le> i' - shift\n             then arbitrary1 i' else word_of_int (i' - shift)\n        else if i' < least \\<or> overflow \\<le> i' then arbitrary2 i'\n             else word_of_int i')\n 2. \\<not> i' !! index \\<Longrightarrow>\n    word_of_int i =\n    (let i' = i AND mask\n     in if i' !! index\n        then if i' - shift < least \\<or> overflow \\<le> i' - shift\n             then arbitrary1 i' else word_of_int (i' - shift)\n        else if i' < least \\<or> overflow \\<le> i' then arbitrary2 i'\n             else word_of_int i')", "moreover"], ["proof (state)\nthis:\n  (overflow \\<le> i' - shift) = False\n\ngoal (2 subgoals):\n 1. i' !! index \\<Longrightarrow>\n    word_of_int i =\n    (let i' = i AND mask\n     in if i' !! index\n        then if i' - shift < least \\<or> overflow \\<le> i' - shift\n             then arbitrary1 i' else word_of_int (i' - shift)\n        else if i' < least \\<or> overflow \\<le> i' then arbitrary2 i'\n             else word_of_int i')\n 2. \\<not> i' !! index \\<Longrightarrow>\n    word_of_int i =\n    (let i' = i AND mask\n     in if i' !! index\n        then if i' - shift < least \\<or> overflow \\<le> i' - shift\n             then arbitrary1 i' else word_of_int (i' - shift)\n        else if i' < least \\<or> overflow \\<le> i' then arbitrary2 i'\n             else word_of_int i')", "have \"word_of_int (i' - shift) = (word_of_int i :: 'a word)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. word_of_int (i' - shift) = word_of_int i", "using \\<open>i' < shift\\<close>"], ["proof (prove)\nusing this:\n  i' < shift\n\ngoal (1 subgoal):\n 1. word_of_int (i' - shift) = word_of_int i", "by (simp add: i'_def shift_def mask_def shiftl_eq_push_bit push_bit_of_1 word_of_int_eq_iff flip: take_bit_eq_mask)"], ["proof (state)\nthis:\n  word_of_int (i' - shift) = word_of_int i\n\ngoal (2 subgoals):\n 1. i' !! index \\<Longrightarrow>\n    word_of_int i =\n    (let i' = i AND mask\n     in if i' !! index\n        then if i' - shift < least \\<or> overflow \\<le> i' - shift\n             then arbitrary1 i' else word_of_int (i' - shift)\n        else if i' < least \\<or> overflow \\<le> i' then arbitrary2 i'\n             else word_of_int i')\n 2. \\<not> i' !! index \\<Longrightarrow>\n    word_of_int i =\n    (let i' = i AND mask\n     in if i' !! index\n        then if i' - shift < least \\<or> overflow \\<le> i' - shift\n             then arbitrary1 i' else word_of_int (i' - shift)\n        else if i' < least \\<or> overflow \\<le> i' then arbitrary2 i'\n             else word_of_int i')", "ultimately"], ["proof (chain)\npicking this:\n  (i' - shift < least) = False\n  (overflow \\<le> i' - shift) = False\n  word_of_int (i' - shift) = word_of_int i", "show ?thesis"], ["proof (prove)\nusing this:\n  (i' - shift < least) = False\n  (overflow \\<le> i' - shift) = False\n  word_of_int (i' - shift) = word_of_int i\n\ngoal (1 subgoal):\n 1. word_of_int i =\n    (let i' = i AND mask\n     in if i' !! index\n        then if i' - shift < least \\<or> overflow \\<le> i' - shift\n             then arbitrary1 i' else word_of_int (i' - shift)\n        else if i' < least \\<or> overflow \\<le> i' then arbitrary2 i'\n             else word_of_int i')", "using True"], ["proof (prove)\nusing this:\n  (i' - shift < least) = False\n  (overflow \\<le> i' - shift) = False\n  word_of_int (i' - shift) = word_of_int i\n  i' !! index\n\ngoal (1 subgoal):\n 1. word_of_int i =\n    (let i' = i AND mask\n     in if i' !! index\n        then if i' - shift < least \\<or> overflow \\<le> i' - shift\n             then arbitrary1 i' else word_of_int (i' - shift)\n        else if i' < least \\<or> overflow \\<le> i' then arbitrary2 i'\n             else word_of_int i')", "by(simp add: Let_def i'_def)"], ["proof (state)\nthis:\n  word_of_int i =\n  (let i' = i AND mask\n   in if i' !! index\n      then if i' - shift < least \\<or> overflow \\<le> i' - shift\n           then arbitrary1 i' else word_of_int (i' - shift)\n      else if i' < least \\<or> overflow \\<le> i' then arbitrary2 i'\n           else word_of_int i')\n\ngoal (1 subgoal):\n 1. \\<not> i' !! index \\<Longrightarrow>\n    word_of_int i =\n    (let i' = i AND mask\n     in if i' !! index\n        then if i' - shift < least \\<or> overflow \\<le> i' - shift\n             then arbitrary1 i' else word_of_int (i' - shift)\n        else if i' < least \\<or> overflow \\<le> i' then arbitrary2 i'\n             else word_of_int i')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> i' !! index \\<Longrightarrow>\n    word_of_int i =\n    (let i' = i AND mask\n     in if i' !! index\n        then if i' - shift < least \\<or> overflow \\<le> i' - shift\n             then arbitrary1 i' else word_of_int (i' - shift)\n        else if i' < least \\<or> overflow \\<le> i' then arbitrary2 i'\n             else word_of_int i')", "case False"], ["proof (state)\nthis:\n  \\<not> i' !! index\n\ngoal (1 subgoal):\n 1. \\<not> i' !! index \\<Longrightarrow>\n    word_of_int i =\n    (let i' = i AND mask\n     in if i' !! index\n        then if i' - shift < least \\<or> overflow \\<le> i' - shift\n             then arbitrary1 i' else word_of_int (i' - shift)\n        else if i' < least \\<or> overflow \\<le> i' then arbitrary2 i'\n             else word_of_int i')", "hence \"i' = i AND Bit_Operations.mask (LENGTH('a) - 1)\""], ["proof (prove)\nusing this:\n  \\<not> i' !! index\n\ngoal (1 subgoal):\n 1. i' = i AND mask (LENGTH('a) - 1)", "unfolding assms i'_def"], ["proof (prove)\nusing this:\n  \\<not> (i AND mask LENGTH('a)) !! (LENGTH('a) - 1)\n\ngoal (1 subgoal):\n 1. i AND mask LENGTH('a) = i AND mask (LENGTH('a) - 1)", "by(clarsimp simp add: i'_def bin_nth_ops intro!: bin_eqI)(cases \"LENGTH('a)\", auto simp add: less_Suc_eq)"], ["proof (state)\nthis:\n  i' = i AND mask (LENGTH('a) - 1)\n\ngoal (1 subgoal):\n 1. \\<not> i' !! index \\<Longrightarrow>\n    word_of_int i =\n    (let i' = i AND mask\n     in if i' !! index\n        then if i' - shift < least \\<or> overflow \\<le> i' - shift\n             then arbitrary1 i' else word_of_int (i' - shift)\n        else if i' < least \\<or> overflow \\<le> i' then arbitrary2 i'\n             else word_of_int i')", "also"], ["proof (state)\nthis:\n  i' = i AND mask (LENGTH('a) - 1)\n\ngoal (1 subgoal):\n 1. \\<not> i' !! index \\<Longrightarrow>\n    word_of_int i =\n    (let i' = i AND mask\n     in if i' !! index\n        then if i' - shift < least \\<or> overflow \\<le> i' - shift\n             then arbitrary1 i' else word_of_int (i' - shift)\n        else if i' < least \\<or> overflow \\<le> i' then arbitrary2 i'\n             else word_of_int i')", "have \"\\<dots> \\<le> Bit_Operations.mask (LENGTH('a) - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i AND mask (LENGTH('a) - 1) \\<le> mask (LENGTH('a) - 1)", "by(rule int_and_le) simp"], ["proof (state)\nthis:\n  i AND mask (LENGTH('a) - 1) \\<le> mask (LENGTH('a) - 1)\n\ngoal (1 subgoal):\n 1. \\<not> i' !! index \\<Longrightarrow>\n    word_of_int i =\n    (let i' = i AND mask\n     in if i' !! index\n        then if i' - shift < least \\<or> overflow \\<le> i' - shift\n             then arbitrary1 i' else word_of_int (i' - shift)\n        else if i' < least \\<or> overflow \\<le> i' then arbitrary2 i'\n             else word_of_int i')", "also"], ["proof (state)\nthis:\n  i AND mask (LENGTH('a) - 1) \\<le> mask (LENGTH('a) - 1)\n\ngoal (1 subgoal):\n 1. \\<not> i' !! index \\<Longrightarrow>\n    word_of_int i =\n    (let i' = i AND mask\n     in if i' !! index\n        then if i' - shift < least \\<or> overflow \\<le> i' - shift\n             then arbitrary1 i' else word_of_int (i' - shift)\n        else if i' < least \\<or> overflow \\<le> i' then arbitrary2 i'\n             else word_of_int i')", "have \"\\<dots> < overflow\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mask (LENGTH('a) - 1) < overflow", "unfolding overflow_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. mask (LENGTH('a) - 1) < 1 << LENGTH('a) - 1", "by(simp add: bin_mask_p1_conv_shift[symmetric])"], ["proof (state)\nthis:\n  mask (LENGTH('a) - 1) < overflow\n\ngoal (1 subgoal):\n 1. \\<not> i' !! index \\<Longrightarrow>\n    word_of_int i =\n    (let i' = i AND mask\n     in if i' !! index\n        then if i' - shift < least \\<or> overflow \\<le> i' - shift\n             then arbitrary1 i' else word_of_int (i' - shift)\n        else if i' < least \\<or> overflow \\<le> i' then arbitrary2 i'\n             else word_of_int i')", "also"], ["proof (state)\nthis:\n  mask (LENGTH('a) - 1) < overflow\n\ngoal (1 subgoal):\n 1. \\<not> i' !! index \\<Longrightarrow>\n    word_of_int i =\n    (let i' = i AND mask\n     in if i' !! index\n        then if i' - shift < least \\<or> overflow \\<le> i' - shift\n             then arbitrary1 i' else word_of_int (i' - shift)\n        else if i' < least \\<or> overflow \\<le> i' then arbitrary2 i'\n             else word_of_int i')", "have \"least \\<le> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. least \\<le> 0", "unfolding least_def overflow_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. - (1 << LENGTH('a) - 1) \\<le> 0", "by simp"], ["proof (state)\nthis:\n  least \\<le> 0\n\ngoal (1 subgoal):\n 1. \\<not> i' !! index \\<Longrightarrow>\n    word_of_int i =\n    (let i' = i AND mask\n     in if i' !! index\n        then if i' - shift < least \\<or> overflow \\<le> i' - shift\n             then arbitrary1 i' else word_of_int (i' - shift)\n        else if i' < least \\<or> overflow \\<le> i' then arbitrary2 i'\n             else word_of_int i')", "have \"0 \\<le> i'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> i'", "by (simp add: i'_def mask_def)"], ["proof (state)\nthis:\n  0 \\<le> i'\n\ngoal (1 subgoal):\n 1. \\<not> i' !! index \\<Longrightarrow>\n    word_of_int i =\n    (let i' = i AND mask\n     in if i' !! index\n        then if i' - shift < least \\<or> overflow \\<le> i' - shift\n             then arbitrary1 i' else word_of_int (i' - shift)\n        else if i' < least \\<or> overflow \\<le> i' then arbitrary2 i'\n             else word_of_int i')", "hence \"least \\<le> i'\""], ["proof (prove)\nusing this:\n  0 \\<le> i'\n\ngoal (1 subgoal):\n 1. least \\<le> i'", "using \\<open>least \\<le> 0\\<close>"], ["proof (prove)\nusing this:\n  0 \\<le> i'\n  least \\<le> 0\n\ngoal (1 subgoal):\n 1. least \\<le> i'", "by simp"], ["proof (state)\nthis:\n  least \\<le> i'\n\ngoal (1 subgoal):\n 1. \\<not> i' !! index \\<Longrightarrow>\n    word_of_int i =\n    (let i' = i AND mask\n     in if i' !! index\n        then if i' - shift < least \\<or> overflow \\<le> i' - shift\n             then arbitrary1 i' else word_of_int (i' - shift)\n        else if i' < least \\<or> overflow \\<le> i' then arbitrary2 i'\n             else word_of_int i')", "moreover"], ["proof (state)\nthis:\n  least \\<le> i'\n\ngoal (1 subgoal):\n 1. \\<not> i' !! index \\<Longrightarrow>\n    word_of_int i =\n    (let i' = i AND mask\n     in if i' !! index\n        then if i' - shift < least \\<or> overflow \\<le> i' - shift\n             then arbitrary1 i' else word_of_int (i' - shift)\n        else if i' < least \\<or> overflow \\<le> i' then arbitrary2 i'\n             else word_of_int i')", "have \"word_of_int i' = (word_of_int i :: 'a word)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. word_of_int i' = word_of_int i", "by(rule word_eqI)(auto simp add: i'_def bin_nth_ops mask_def)"], ["proof (state)\nthis:\n  word_of_int i' = word_of_int i\n\ngoal (1 subgoal):\n 1. \\<not> i' !! index \\<Longrightarrow>\n    word_of_int i =\n    (let i' = i AND mask\n     in if i' !! index\n        then if i' - shift < least \\<or> overflow \\<le> i' - shift\n             then arbitrary1 i' else word_of_int (i' - shift)\n        else if i' < least \\<or> overflow \\<le> i' then arbitrary2 i'\n             else word_of_int i')", "ultimately"], ["proof (chain)\npicking this:\n  i' < overflow\n  least \\<le> i'\n  word_of_int i' = word_of_int i", "show ?thesis"], ["proof (prove)\nusing this:\n  i' < overflow\n  least \\<le> i'\n  word_of_int i' = word_of_int i\n\ngoal (1 subgoal):\n 1. word_of_int i =\n    (let i' = i AND mask\n     in if i' !! index\n        then if i' - shift < least \\<or> overflow \\<le> i' - shift\n             then arbitrary1 i' else word_of_int (i' - shift)\n        else if i' < least \\<or> overflow \\<le> i' then arbitrary2 i'\n             else word_of_int i')", "using False"], ["proof (prove)\nusing this:\n  i' < overflow\n  least \\<le> i'\n  word_of_int i' = word_of_int i\n  \\<not> i' !! index\n\ngoal (1 subgoal):\n 1. word_of_int i =\n    (let i' = i AND mask\n     in if i' !! index\n        then if i' - shift < least \\<or> overflow \\<le> i' - shift\n             then arbitrary1 i' else word_of_int (i' - shift)\n        else if i' < least \\<or> overflow \\<le> i' then arbitrary2 i'\n             else word_of_int i')", "by(simp add: Let_def i'_def)"], ["proof (state)\nthis:\n  word_of_int i =\n  (let i' = i AND mask\n   in if i' !! index\n      then if i' - shift < least \\<or> overflow \\<le> i' - shift\n           then arbitrary1 i' else word_of_int (i' - shift)\n      else if i' < least \\<or> overflow \\<le> i' then arbitrary2 i'\n           else word_of_int i')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  word_of_int i =\n  (let i' = i AND mask\n   in if i' !! index\n      then if i' - shift < least \\<or> overflow \\<le> i' - shift\n           then arbitrary1 i' else word_of_int (i' - shift)\n      else if i' < least \\<or> overflow \\<le> i' then arbitrary2 i'\n           else word_of_int i')\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Quickcheck conversion functions\\<close>"], ["", "context\n  includes state_combinator_syntax\nbegin"], ["", "definition qc_random_cnv ::\n  \"(natural \\<Rightarrow> 'a::term_of) \\<Rightarrow> natural \\<Rightarrow> Random.seed\n    \\<Rightarrow> ('a \\<times> (unit \\<Rightarrow> Code_Evaluation.term)) \\<times> Random.seed\"\n  where \"qc_random_cnv a_of_natural i = Random.range (i + 1) \\<circ>\\<rightarrow> (\\<lambda>k. Pair (\n       let n = a_of_natural k\n       in (n, \\<lambda>_. Code_Evaluation.term_of n)))\""], ["", "end"], ["", "definition qc_exhaustive_cnv :: \"(natural \\<Rightarrow> 'a) \\<Rightarrow> ('a \\<Rightarrow> (bool \\<times> term list) option)\n  \\<Rightarrow> natural \\<Rightarrow> (bool \\<times> term list) option\"\nwhere\n  \"qc_exhaustive_cnv a_of_natural f d =\n   Quickcheck_Exhaustive.exhaustive (%x. f (a_of_natural x)) d\""], ["", "definition qc_full_exhaustive_cnv ::\n  \"(natural \\<Rightarrow> ('a::term_of)) \\<Rightarrow> ('a \\<times> (unit \\<Rightarrow> term) \\<Rightarrow> (bool \\<times> term list) option)\n  \\<Rightarrow> natural \\<Rightarrow> (bool \\<times> term list) option\"\nwhere\n  \"qc_full_exhaustive_cnv a_of_natural f d = Quickcheck_Exhaustive.full_exhaustive\n  (%(x, xt). f (a_of_natural x, %_. Code_Evaluation.term_of (a_of_natural x))) d\""], ["", "declare [[quickcheck_narrowing_ghc_options = \"-XTypeSynonymInstances\"]]"], ["", "definition qc_narrowing_drawn_from :: \"'a list \\<Rightarrow> integer \\<Rightarrow> _\"\nwhere\n  \"qc_narrowing_drawn_from xs =\n   foldr Quickcheck_Narrowing.sum (map Quickcheck_Narrowing.cons (butlast xs)) (Quickcheck_Narrowing.cons (last xs))\""], ["", "locale quickcheck_narrowing_samples =\n  fixes a_of_integer :: \"integer \\<Rightarrow> 'a \\<times> 'a :: {partial_term_of, term_of}\"\n  and zero :: \"'a\"\n  and tr :: \"typerep\"\nbegin"], ["", "function narrowing_samples :: \"integer \\<Rightarrow> 'a list\"\nwhere\n  \"narrowing_samples i =\n   (if i > 0 then let (a, a') = a_of_integer i in narrowing_samples (i - 1) @ [a, a'] else [zero])\""], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>P x. (\\<And>i. x = i \\<Longrightarrow> P) \\<Longrightarrow> P\n 2. \\<And>i ia.\n       i = ia \\<Longrightarrow>\n       (if 0 < i\n        then let (a, a') = a_of_integer i\n             in narrowing_samples_sumC (i - 1) @ [a, a']\n        else [zero]) =\n       (if 0 < ia\n        then let (a, a') = a_of_integer ia\n             in narrowing_samples_sumC (ia - 1) @ [a, a']\n        else [zero])", "by pat_completeness auto"], ["", "termination"], ["proof (prove)\ngoal (1 subgoal):\n 1. All narrowing_samples_dom", "including integer.lifting"], ["proof (prove)\ngoal (1 subgoal):\n 1. All narrowing_samples_dom", "proof(relation \"measure nat_of_integer\")"], ["proof (state)\ngoal (2 subgoals):\n 1. wf (measure nat_of_integer)\n 2. \\<And>i x xa y.\n       \\<lbrakk>0 < i; x = a_of_integer i; (xa, y) = x\\<rbrakk>\n       \\<Longrightarrow> (i - 1, i) \\<in> measure nat_of_integer", "fix i :: integer"], ["proof (state)\ngoal (2 subgoals):\n 1. wf (measure nat_of_integer)\n 2. \\<And>i x xa y.\n       \\<lbrakk>0 < i; x = a_of_integer i; (xa, y) = x\\<rbrakk>\n       \\<Longrightarrow> (i - 1, i) \\<in> measure nat_of_integer", "assume \"0 < i\""], ["proof (state)\nthis:\n  0 < i\n\ngoal (2 subgoals):\n 1. wf (measure nat_of_integer)\n 2. \\<And>i x xa y.\n       \\<lbrakk>0 < i; x = a_of_integer i; (xa, y) = x\\<rbrakk>\n       \\<Longrightarrow> (i - 1, i) \\<in> measure nat_of_integer", "thus \"(i - 1, i) \\<in> measure nat_of_integer\""], ["proof (prove)\nusing this:\n  0 < i\n\ngoal (1 subgoal):\n 1. (i - 1, i) \\<in> measure nat_of_integer", "by simp(transfer, simp)"], ["proof (state)\nthis:\n  (i - 1, i) \\<in> measure nat_of_integer\n\ngoal (1 subgoal):\n 1. wf (measure nat_of_integer)", "qed simp"], ["", "definition partial_term_of_sample :: \"integer \\<Rightarrow> 'a\"\nwhere\n  \"partial_term_of_sample i =\n  (if i < 0 then undefined\n   else if i = 0 then zero\n   else if i mod 2 = 0 then snd (a_of_integer (i div 2))\n   else fst (a_of_integer (i div 2 + 1)))\""], ["", "lemma partial_term_of_code:\n  \"partial_term_of (ty :: 'a itself) (Quickcheck_Narrowing.Narrowing_variable p t) \\<equiv>\n    Code_Evaluation.Free (STR ''_'') tr\"\n  \"partial_term_of (ty :: 'a itself) (Quickcheck_Narrowing.Narrowing_constructor i []) \\<equiv>\n   Code_Evaluation.term_of (partial_term_of_sample i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (partial_term_of ty (narrowing_term.Narrowing_variable p t) \\<equiv>\n     Code_Evaluation.Free STR ''_'' tr) &&&\n    partial_term_of ty (narrowing_term.Narrowing_constructor i []) \\<equiv>\n    term_of_class.term_of (partial_term_of_sample i)", "by (rule partial_term_of_anything)+"], ["", "end"], ["", "lemmas [code] =\n  quickcheck_narrowing_samples.narrowing_samples.simps\n  quickcheck_narrowing_samples.partial_term_of_sample_def"], ["", "text \\<open>\n  The separate code target \\<open>SML_word\\<close> collects setups for the\n  code generator that PolyML does not provide.\n\\<close>"], ["", "setup \\<open>Code_Target.add_derived_target (\"SML_word\", [(Code_ML.target_SML, I)])\\<close>"], ["", "code_identifier code_module Code_Target_Word_Base \\<rightharpoonup>\n  (SML) Word and (Haskell) Word and (OCaml) Word and (Scala) Word"], ["", "end"]]}