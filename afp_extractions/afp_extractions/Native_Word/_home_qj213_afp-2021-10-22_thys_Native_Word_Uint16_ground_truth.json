{"file_name": "/home/qj213/afp-2021-10-22/thys/Native_Word/Uint16.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Native_Word", "problem_names": ["lemmas [code] = less_uint16.rep_eq less_eq_uint16.rep_eq", "lemma [transfer_rule]:\n  \"((=) ===> cr_uint16) of_bool of_bool\"", "lemma transfer_rule_numeral_uint [transfer_rule]:\n  \"((=) ===> cr_uint16) numeral numeral\"", "lemma [transfer_rule]:\n  \\<open>(cr_uint16 ===> (\\<longleftrightarrow>)) even ((dvd) 2 :: uint16 \\<Rightarrow> bool)\\<close>", "lemma [code]:\n  \\<open>take_bit n a = a AND mask n\\<close> for a :: uint16", "lemma [code]:\n  \\<open>mask (Suc n) = push_bit n (1 :: uint16) OR mask n\\<close>\n  \\<open>mask 0 = (0 :: uint16)\\<close>", "lemma test_bit_uint16_transfer [transfer_rule]:\n  \\<open>(cr_uint16 ===> (=)) bit (!!)\\<close>", "lemma shiftl_uint16_transfer [transfer_rule]:\n  \\<open>(cr_uint16 ===> (=) ===> cr_uint16) (\\<lambda>k n. push_bit n k) (<<)\\<close>", "lemma shiftr_uint16_transfer [transfer_rule]:\n  \\<open>(cr_uint16 ===> (=) ===> cr_uint16) (\\<lambda>k n. drop_bit n k) (>>)\\<close>", "lemmas [code] = bit_uint16.rep_eq lsb_uint16.rep_eq msb_uint16.rep_eq", "lemmas [code] = equal_uint16.rep_eq", "lemmas [code] = size_uint16.rep_eq", "lemma Rep_uint16_numeral [simp]: \"Rep_uint16 (numeral n) = numeral n\"", "lemma Rep_uint16_neg_numeral [simp]: \"Rep_uint16 (- numeral n) = - numeral n\"", "lemma numeral_uint16_transfer [transfer_rule]:\n  \"(rel_fun (=) cr_uint16) numeral numeral\"", "lemma numeral_uint16 [code_unfold]: \"numeral n = Uint16 (numeral n)\"", "lemma neg_numeral_uint16 [code_unfold]: \"- numeral n = Uint16 (- numeral n)\"", "lemma Abs_uint16_numeral [code_post]: \"Abs_uint16 (numeral n) = numeral n\"", "lemma Abs_uint16_0 [code_post]: \"Abs_uint16 0 = 0\"", "lemma Abs_uint16_1 [code_post]: \"Abs_uint16 1 = 1\"", "lemma Rep_uint16'_transfer [transfer_rule]:\n  \"rel_fun cr_uint16 (=) (\\<lambda>x. x) Rep_uint16'\"", "lemma Rep_uint16'_code [code]: \"Rep_uint16' x = (BITS n. bit x n)\"", "lemma Abs_uint16'_code [code]:\n  \"Abs_uint16' x = Uint16 (integer_of_int (uint x))\"", "lemma term_of_uint16_code [code]:\n  defines \"TR \\<equiv> typerep.Typerep\" and \"bit0 \\<equiv> STR ''Numeral_Type.bit0''\" shows\n  \"term_of_class.term_of x = \n   Code_Evaluation.App (Code_Evaluation.Const (STR ''Uint16.uint16.Abs_uint16'') (TR (STR ''fun'') [TR (STR ''Word.word'') [TR bit0 [TR bit0 [TR bit0 [TR bit0 [TR (STR ''Numeral_Type.num1'') []]]]]], TR (STR ''Uint16.uint16'') []]))\n       (term_of_class.term_of (Rep_uint16' x))\"", "lemma Uin16_code [code abstract]: \"Rep_uint16 (Uint16 i) = word_of_int (int_of_integer_symbolic i)\"", "lemma div_uint16_code [code]: \"x div y = (if y = 0 then 0 else uint16_div x y)\"", "lemma mod_uint16_code [code]: \"x mod y = (if y = 0 then x else uint16_mod x y)\"", "lemma uint16_div_code [code abstract]:\n  \"Rep_uint16 (uint16_div x y) =\n  (if y = 0 then Rep_uint16 (undefined ((div) :: uint16 \\<Rightarrow> _) x (0 :: uint16)) else Rep_uint16 x div Rep_uint16 y)\"", "lemma uint16_mod_code [code abstract]:\n  \"Rep_uint16 (uint16_mod x y) =\n  (if y = 0 then Rep_uint16 (undefined ((mod) :: uint16 \\<Rightarrow> _) x (0 :: uint16)) else Rep_uint16 x mod Rep_uint16 y)\"", "lemma test_bit_uint16_code [code]:\n  \"bit x n \\<longleftrightarrow> n < 16 \\<and> uint16_test_bit x (integer_of_nat n)\"", "lemma uint16_test_bit_code [code]:\n  \"uint16_test_bit w n =\n  (if n < 0 \\<or> 15 < n then undefined (bit :: uint16 \\<Rightarrow> _) w n else bit (Rep_uint16 w) (nat_of_integer n))\"", "lemma set_bit_uint16_code [code]:\n  \"set_bit x n b = (if n < 16 then uint16_set_bit x (integer_of_nat n) b else x)\"", "lemma uint16_set_bit_code [code abstract]:\n  \"Rep_uint16 (uint16_set_bit w n b) = \n  (if n < 0 \\<or> 15 < n then Rep_uint16 (undefined (set_bit :: uint16 \\<Rightarrow> _) w n b)\n   else set_bit (Rep_uint16 w) (nat_of_integer n) b)\"", "lemma uint16_set_bits_code [code]:\n  \"uint16_set_bits f w n =\n  (if n = 0 then w \n   else let n' = n - 1 in uint16_set_bits f ((push_bit 1 w) OR (if f n' then 1 else 0)) n')\"", "lemma set_bits_uint16 [code]:\n  \"(BITS n. f n) = uint16_set_bits f 0 16\"", "lemma lsb_code [code]: fixes x :: uint16 shows \"lsb x \\<longleftrightarrow> bit x 0\"", "lemma shiftl_uint16_code [code]: \"push_bit n x = (if n < 16 then uint16_shiftl x (integer_of_nat n) else 0)\"", "lemma uint16_shiftl_code [code abstract]:\n  \"Rep_uint16 (uint16_shiftl w n) =\n  (if n < 0 \\<or> 16 \\<le> n then Rep_uint16 (undefined (push_bit :: nat \\<Rightarrow> uint16 \\<Rightarrow> _) w n)\n   else push_bit (nat_of_integer n) (Rep_uint16 w))\"", "lemma shiftr_uint16_code [code]: \"drop_bit n x = (if n < 16 then uint16_shiftr x (integer_of_nat n) else 0)\"", "lemma uint16_shiftr_code [code abstract]:\n  \"Rep_uint16 (uint16_shiftr w n) =\n  (if n < 0 \\<or> 16 \\<le> n then Rep_uint16 (undefined (drop_bit :: nat \\<Rightarrow> uint16 \\<Rightarrow> _) w n)\n   else drop_bit (nat_of_integer n) (Rep_uint16 w))\"", "lemma sshiftr_uint16_code [code]:\n  \"x >>> n = \n  (if n < 16 then uint16_sshiftr x (integer_of_nat n) else if bit x 15 then -1 else 0)\"", "lemma uint16_sshiftr_code [code abstract]:\n  \"Rep_uint16 (uint16_sshiftr w n) =\n  (if n < 0 \\<or> 16 \\<le> n then Rep_uint16 (undefined sshiftr_uint16 w n)\n   else signed_drop_bit (nat_of_integer n) (Rep_uint16 w))\"", "lemma uint16_msb_test_bit: \"msb x \\<longleftrightarrow> bit (x :: uint16) 15\"", "lemma msb_uint16_code [code]: \"msb x \\<longleftrightarrow> uint16_test_bit x 15\"", "lemma uint16_of_int_code [code]: \"uint16_of_int i = Uint16 (integer_of_int i)\"", "lemma int_of_uint16_code [code]:\n  \"int_of_uint16 x = int_of_integer (integer_of_uint16 x)\"", "lemma nat_of_uint16_code [code]:\n  \"nat_of_uint16 x = nat_of_integer (integer_of_uint16 x)\"", "lemma integer_of_uint16_code [code]:\n  \"integer_of_uint16 n = integer_of_int (uint (Rep_uint16' n))\"", "lemmas partial_term_of_uint16 [code] = partial_term_of_code"], "translations": [["", "lemmas [code] = less_uint16.rep_eq less_eq_uint16.rep_eq"], ["", "context\n  includes lifting_syntax\n  notes\n    transfer_rule_of_bool [transfer_rule]\n    transfer_rule_numeral [transfer_rule]\nbegin"], ["", "lemma [transfer_rule]:\n  \"((=) ===> cr_uint16) of_bool of_bool\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((=) ===> cr_uint16) of_bool of_bool", "by transfer_prover"], ["", "lemma transfer_rule_numeral_uint [transfer_rule]:\n  \"((=) ===> cr_uint16) numeral numeral\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((=) ===> cr_uint16) numeral numeral", "by transfer_prover"], ["", "lemma [transfer_rule]:\n  \\<open>(cr_uint16 ===> (\\<longleftrightarrow>)) even ((dvd) 2 :: uint16 \\<Rightarrow> bool)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (cr_uint16 ===> (=)) even ((dvd) 2)", "by (unfold dvd_def) transfer_prover"], ["", "end"], ["", "instantiation uint16 :: semiring_bits\nbegin"], ["", "lift_definition bit_uint16 :: \\<open>uint16 \\<Rightarrow> nat \\<Rightarrow> bool\\<close> is bit"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(uint16, semiring_bits_class)", "by (standard; transfer)\n    (fact bit_iff_odd even_iff_mod_2_eq_zero odd_iff_mod_2_eq_one odd_one bits_induct\n       bits_div_0 bits_div_by_1 bits_mod_div_trivial even_succ_div_2\n       even_mask_div_iff exp_div_exp_eq div_exp_eq mod_exp_eq mult_exp_mod_exp_eq\n       div_exp_mod_exp_eq even_mult_exp_div_exp_iff)+"], ["", "end"], ["", "instantiation uint16 :: semiring_bit_shifts\nbegin"], ["", "lift_definition push_bit_uint16 :: \\<open>nat \\<Rightarrow> uint16 \\<Rightarrow> uint16\\<close> is push_bit"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition drop_bit_uint16 :: \\<open>nat \\<Rightarrow> uint16 \\<Rightarrow> uint16\\<close> is drop_bit"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition take_bit_uint16 :: \\<open>nat \\<Rightarrow> uint16 \\<Rightarrow> uint16\\<close> is take_bit"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(uint16, semiring_bit_shifts_class)", "by (standard; transfer)\n  (fact push_bit_eq_mult drop_bit_eq_div take_bit_eq_mod)+"], ["", "end"], ["", "instantiation uint16 :: ring_bit_operations\nbegin"], ["", "lift_definition not_uint16 :: \\<open>uint16 \\<Rightarrow> uint16\\<close> is NOT"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition and_uint16 :: \\<open>uint16 \\<Rightarrow> uint16 \\<Rightarrow> uint16\\<close> is \\<open>(AND)\\<close>"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition or_uint16 :: \\<open>uint16 \\<Rightarrow> uint16 \\<Rightarrow> uint16\\<close> is \\<open>(OR)\\<close>"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition xor_uint16 :: \\<open>uint16 \\<Rightarrow> uint16 \\<Rightarrow> uint16\\<close> is \\<open>(XOR)\\<close>"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition mask_uint16 :: \\<open>nat \\<Rightarrow> uint16\\<close> is mask"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(uint16, ring_bit_operations_class)", "by (standard; transfer)\n  (simp_all add: bit_and_iff bit_or_iff bit_xor_iff bit_not_iff minus_eq_not_minus_1 mask_eq_decr_exp)"], ["", "end"], ["", "lemma [code]:\n  \\<open>take_bit n a = a AND mask n\\<close> for a :: uint16"], ["proof (prove)\ngoal (1 subgoal):\n 1. take_bit n a = a AND mask n", "by (fact take_bit_eq_mask)"], ["", "lemma [code]:\n  \\<open>mask (Suc n) = push_bit n (1 :: uint16) OR mask n\\<close>\n  \\<open>mask 0 = (0 :: uint16)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. mask (Suc n) = push_bit n 1 OR mask n &&& mask 0 = 0", "by (simp_all add: mask_Suc_exp push_bit_of_1)"], ["", "instance uint16 :: semiring_bit_syntax"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(uint16, semiring_bit_syntax_class)", ".."], ["", "context\n  includes lifting_syntax\nbegin"], ["", "lemma test_bit_uint16_transfer [transfer_rule]:\n  \\<open>(cr_uint16 ===> (=)) bit (!!)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (cr_uint16 ===> (=)) bit (!!)", "unfolding test_bit_eq_bit"], ["proof (prove)\ngoal (1 subgoal):\n 1. (cr_uint16 ===> (=)) bit bit", "by transfer_prover"], ["", "lemma shiftl_uint16_transfer [transfer_rule]:\n  \\<open>(cr_uint16 ===> (=) ===> cr_uint16) (\\<lambda>k n. push_bit n k) (<<)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (cr_uint16 ===> (=) ===> cr_uint16) (\\<lambda>k n. push_bit n k) (<<)", "unfolding shiftl_eq_push_bit"], ["proof (prove)\ngoal (1 subgoal):\n 1. (cr_uint16 ===> (=) ===> cr_uint16) (\\<lambda>k n. push_bit n k)\n     (\\<lambda>a n. push_bit n a)", "by transfer_prover"], ["", "lemma shiftr_uint16_transfer [transfer_rule]:\n  \\<open>(cr_uint16 ===> (=) ===> cr_uint16) (\\<lambda>k n. drop_bit n k) (>>)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (cr_uint16 ===> (=) ===> cr_uint16) (\\<lambda>k n. drop_bit n k) (>>)", "unfolding shiftr_eq_drop_bit"], ["proof (prove)\ngoal (1 subgoal):\n 1. (cr_uint16 ===> (=) ===> cr_uint16) (\\<lambda>k n. drop_bit n k)\n     (\\<lambda>a n. drop_bit n a)", "by transfer_prover"], ["", "end"], ["", "instantiation uint16 :: lsb\nbegin"], ["", "lift_definition lsb_uint16 :: \\<open>uint16 \\<Rightarrow> bool\\<close> is lsb"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(uint16, lsb_class)", "by (standard; transfer)\n  (fact lsb_odd)"], ["", "end"], ["", "instantiation uint16 :: msb\nbegin"], ["", "lift_definition msb_uint16 :: \\<open>uint16 \\<Rightarrow> bool\\<close> is msb"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(uint16, msb_class)", ".."], ["", "end"], ["", "instantiation uint16 :: set_bit\nbegin"], ["", "lift_definition set_bit_uint16 :: \\<open>uint16 \\<Rightarrow> nat \\<Rightarrow> bool \\<Rightarrow> uint16\\<close> is set_bit"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(uint16, set_bit_class)", "apply standard"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a m b n.\n       bit (set_bit_class.set_bit a m b) n =\n       ((if m = n then b else bit a n) \\<and> 2 ^ n \\<noteq> 0)", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a m b n.\n       bit (set_bit_class.set_bit a m b) n =\n       ((if m = n then b else bit a n) \\<and> 2 ^ n \\<noteq> 0)", "apply (simp add: bit_simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "instantiation uint16 :: bit_comprehension begin"], ["", "lift_definition set_bits_uint16 :: \"(nat \\<Rightarrow> bool) \\<Rightarrow> uint16\" is \"set_bits\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(uint16, bit_comprehension_class)", "by (standard; transfer) (fact set_bits_bit_eq)"], ["", "end"], ["", "lemmas [code] = bit_uint16.rep_eq lsb_uint16.rep_eq msb_uint16.rep_eq"], ["", "instantiation uint16 :: equal begin"], ["", "lift_definition equal_uint16 :: \"uint16 \\<Rightarrow> uint16 \\<Rightarrow> bool\" is \"equal_class.equal\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(uint16, equal_class)", "by standard (transfer, simp add: equal_eq)"], ["", "end"], ["", "lemmas [code] = equal_uint16.rep_eq"], ["", "instantiation uint16 :: size begin"], ["", "lift_definition size_uint16 :: \"uint16 \\<Rightarrow> nat\" is \"size\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(uint16, size_class)", ".."], ["", "end"], ["", "lemmas [code] = size_uint16.rep_eq"], ["", "lift_definition sshiftr_uint16 :: \"uint16 \\<Rightarrow> nat \\<Rightarrow> uint16\" (infixl \">>>\" 55) is \\<open>\\<lambda>w n. signed_drop_bit n w\\<close>"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition uint16_of_int :: \"int \\<Rightarrow> uint16\" is \"word_of_int\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "definition uint16_of_nat :: \"nat \\<Rightarrow> uint16\"\nwhere \"uint16_of_nat = uint16_of_int \\<circ> int\""], ["", "lift_definition int_of_uint16 :: \"uint16 \\<Rightarrow> int\" is \"uint\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition nat_of_uint16 :: \"uint16 \\<Rightarrow> nat\" is \"unat\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "definition integer_of_uint16 :: \"uint16 \\<Rightarrow> integer\"\nwhere \"integer_of_uint16 = integer_of_int o int_of_uint16\""], ["", "text \\<open>Use pretty numerals from integer for pretty printing\\<close>"], ["", "context includes integer.lifting begin"], ["", "lift_definition Uint16 :: \"integer \\<Rightarrow> uint16\" is \"word_of_int\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma Rep_uint16_numeral [simp]: \"Rep_uint16 (numeral n) = numeral n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_uint16 (numeral n) = numeral n", "by(induction n)(simp_all add: one_uint16_def Abs_uint16_inverse numeral.simps plus_uint16_def)"], ["", "lemma Rep_uint16_neg_numeral [simp]: \"Rep_uint16 (- numeral n) = - numeral n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_uint16 (- numeral n) = - numeral n", "by(simp only: uminus_uint16_def)(simp add: Abs_uint16_inverse)"], ["", "lemma numeral_uint16_transfer [transfer_rule]:\n  \"(rel_fun (=) cr_uint16) numeral numeral\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_fun (=) cr_uint16 numeral numeral", "by(auto simp add: cr_uint16_def)"], ["", "lemma numeral_uint16 [code_unfold]: \"numeral n = Uint16 (numeral n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. numeral n = Uint16 (numeral n)", "by transfer simp"], ["", "lemma neg_numeral_uint16 [code_unfold]: \"- numeral n = Uint16 (- numeral n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - numeral n = Uint16 (- numeral n)", "by transfer(simp add: cr_uint16_def)"], ["", "end"], ["", "lemma Abs_uint16_numeral [code_post]: \"Abs_uint16 (numeral n) = numeral n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_uint16 (numeral n) = numeral n", "by(induction n)(simp_all add: one_uint16_def numeral.simps plus_uint16_def Abs_uint16_inverse)"], ["", "lemma Abs_uint16_0 [code_post]: \"Abs_uint16 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_uint16 0 = 0", "by(simp add: zero_uint16_def)"], ["", "lemma Abs_uint16_1 [code_post]: \"Abs_uint16 1 = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_uint16 1 = 1", "by(simp add: one_uint16_def)"], ["", "section \\<open>Code setup\\<close>"], ["", "code_printing code_module Uint16 \\<rightharpoonup> (SML_word)\n\\<open>(* Test that words can handle numbers between 0 and 15 *)\nval _ = if 4 <= Word.wordSize then () else raise (Fail (\"wordSize less than 4\"));\n\nstructure Uint16 : sig\n  val set_bit : Word16.word -> IntInf.int -> bool -> Word16.word\n  val shiftl : Word16.word -> IntInf.int -> Word16.word\n  val shiftr : Word16.word -> IntInf.int -> Word16.word\n  val shiftr_signed : Word16.word -> IntInf.int -> Word16.word\n  val test_bit : Word16.word -> IntInf.int -> bool\nend = struct\n\nfun set_bit x n b =\n  let val mask = Word16.<< (0wx1, Word.fromLargeInt (IntInf.toLarge n))\n  in if b then Word16.orb (x, mask)\n     else Word16.andb (x, Word16.notb mask)\n  end\n\nfun shiftl x n =\n  Word16.<< (x, Word.fromLargeInt (IntInf.toLarge n))\n\nfun shiftr x n =\n  Word16.>> (x, Word.fromLargeInt (IntInf.toLarge n))\n\nfun shiftr_signed x n =\n  Word16.~>> (x, Word.fromLargeInt (IntInf.toLarge n))\n\nfun test_bit x n =\n  Word16.andb (x, Word16.<< (0wx1, Word.fromLargeInt (IntInf.toLarge n))) <> Word16.fromInt 0\n\nend; (* struct Uint16 *)\\<close>"], ["", "code_reserved SML_word Uint16"], ["", "code_printing code_module Uint16 \\<rightharpoonup> (Haskell)\n \\<open>module Uint16(Int16, Word16) where\n\n  import Data.Int(Int16)\n  import Data.Word(Word16)\\<close>"], ["", "code_reserved Haskell Uint16"], ["", "text \\<open>Scala provides unsigned 16-bit numbers as Char.\\<close>"], ["", "code_printing code_module Uint16 \\<rightharpoonup> (Scala)\n\\<open>object Uint16 {\n\ndef set_bit(x: scala.Char, n: BigInt, b: Boolean) : scala.Char =\n  if (b)\n    (x | (1.toChar << n.intValue)).toChar\n  else\n    (x & (1.toChar << n.intValue).unary_~).toChar\n\ndef shiftl(x: scala.Char, n: BigInt) : scala.Char = (x << n.intValue).toChar\n\ndef shiftr(x: scala.Char, n: BigInt) : scala.Char = (x >>> n.intValue).toChar\n\ndef shiftr_signed(x: scala.Char, n: BigInt) : scala.Char = (x.toShort >> n.intValue).toChar\n\ndef test_bit(x: scala.Char, n: BigInt) : Boolean = (x & (1.toChar << n.intValue)) != 0\n\n} /* object Uint16 */\\<close>"], ["", "code_reserved Scala Uint16"], ["", "text \\<open>\n  Avoid @{term Abs_uint16} in generated code, use @{term Rep_uint16'} instead. \n  The symbolic implementations for code\\_simp use @{term Rep_uint16}.\n\n  The new destructor @{term Rep_uint16'} is executable.\n  As the simplifier is given the [code abstract] equations literally, \n  we cannot implement @{term Rep_uint16} directly, because that makes code\\_simp loop.\n\n  If code generation raises Match, some equation probably contains @{term Rep_uint16} \n  ([code abstract] equations for @{typ uint16} may use @{term Rep_uint16} because\n  these instances will be folded away.)\n\n  To convert @{typ \"16 word\"} values into @{typ uint16}, use @{term \"Abs_uint16'\"}.\n\\<close>"], ["", "definition Rep_uint16' where [simp]: \"Rep_uint16' = Rep_uint16\""], ["", "lemma Rep_uint16'_transfer [transfer_rule]:\n  \"rel_fun cr_uint16 (=) (\\<lambda>x. x) Rep_uint16'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_fun cr_uint16 (=) (\\<lambda>x. x) Rep_uint16'", "unfolding Rep_uint16'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_fun cr_uint16 (=) (\\<lambda>x. x) Rep_uint16", "by(rule uint16.rep_transfer)"], ["", "lemma Rep_uint16'_code [code]: \"Rep_uint16' x = (BITS n. bit x n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_uint16' x = (BITS n. bit x n)", "by transfer (simp add: set_bits_bit_eq)"], ["", "lift_definition Abs_uint16' :: \"16 word \\<Rightarrow> uint16\" is \"\\<lambda>x :: 16 word. x\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma Abs_uint16'_code [code]:\n  \"Abs_uint16' x = Uint16 (integer_of_int (uint x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_uint16' x = Uint16 (integer_of_int (uint x))", "including integer.lifting"], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_uint16' x = Uint16 (integer_of_int (uint x))", "by transfer simp"], ["", "declare [[code drop: \"term_of_class.term_of :: uint16 \\<Rightarrow> _\"]]"], ["", "lemma term_of_uint16_code [code]:\n  defines \"TR \\<equiv> typerep.Typerep\" and \"bit0 \\<equiv> STR ''Numeral_Type.bit0''\" shows\n  \"term_of_class.term_of x = \n   Code_Evaluation.App (Code_Evaluation.Const (STR ''Uint16.uint16.Abs_uint16'') (TR (STR ''fun'') [TR (STR ''Word.word'') [TR bit0 [TR bit0 [TR bit0 [TR bit0 [TR (STR ''Numeral_Type.num1'') []]]]]], TR (STR ''Uint16.uint16'') []]))\n       (term_of_class.term_of (Rep_uint16' x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. term_of_class.term_of x =\n    Code_Evaluation.App\n     (Code_Evaluation.Const STR ''Uint16.uint16.Abs_uint16''\n       (TR STR ''fun''\n         [TR STR ''Word.word''\n           [TR bit0\n             [TR bit0\n               [TR bit0 [TR bit0 [TR STR ''Numeral_Type.num1'' []]]]]],\n          TR STR ''Uint16.uint16'' []]))\n     (term_of_class.term_of (Rep_uint16' x))", "by(simp add: term_of_anything)"], ["", "lemma Uin16_code [code abstract]: \"Rep_uint16 (Uint16 i) = word_of_int (int_of_integer_symbolic i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_uint16 (Uint16 i) = word_of_int (int_of_integer_symbolic i)", "unfolding Uint16_def int_of_integer_symbolic_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_uint16 (map_fun int_of_integer Abs_uint16 word_of_int i) =\n    word_of_int (int_of_integer i)", "by(simp add: Abs_uint16_inverse)"], ["", "code_printing\n  type_constructor uint16 \\<rightharpoonup>\n  (SML_word) \"Word16.word\" and\n  (Haskell) \"Uint16.Word16\" and\n  (Scala) \"scala.Char\"\n| constant Uint16 \\<rightharpoonup>\n  (SML_word) \"Word16.fromLargeInt (IntInf.toLarge _)\" and\n  (Haskell) \"(Prelude.fromInteger _ :: Uint16.Word16)\" and\n  (Haskell_Quickcheck) \"(Prelude.fromInteger (Prelude.toInteger _) :: Uint16.Word16)\" and\n  (Scala) \"_.charValue\"\n| constant \"0 :: uint16\" \\<rightharpoonup>\n  (SML_word) \"(Word16.fromInt 0)\" and\n  (Haskell) \"(0 :: Uint16.Word16)\" and\n  (Scala) \"0\"\n| constant \"1 :: uint16\" \\<rightharpoonup>\n  (SML_word) \"(Word16.fromInt 1)\" and\n  (Haskell) \"(1 :: Uint16.Word16)\" and\n  (Scala) \"1\"\n| constant \"plus :: uint16 \\<Rightarrow> _ \\<Rightarrow> _\" \\<rightharpoonup>\n  (SML_word) \"Word16.+ ((_), (_))\" and\n  (Haskell) infixl 6 \"+\" and\n  (Scala) \"(_ +/ _).toChar\"\n| constant \"uminus :: uint16 \\<Rightarrow> _\" \\<rightharpoonup>\n  (SML_word) \"Word16.~\" and\n  (Haskell) \"negate\" and\n  (Scala) \"(- _).toChar\"\n| constant \"minus :: uint16 \\<Rightarrow> _\" \\<rightharpoonup>\n  (SML_word) \"Word16.- ((_), (_))\" and\n  (Haskell) infixl 6 \"-\" and\n  (Scala) \"(_ -/ _).toChar\"\n| constant \"times :: uint16 \\<Rightarrow> _ \\<Rightarrow> _\" \\<rightharpoonup>\n  (SML_word) \"Word16.* ((_), (_))\" and\n  (Haskell) infixl 7 \"*\" and\n  (Scala) \"(_ */ _).toChar\"\n| constant \"HOL.equal :: uint16 \\<Rightarrow> _ \\<Rightarrow> bool\" \\<rightharpoonup>\n  (SML_word) \"!((_ : Word16.word) = _)\" and\n  (Haskell) infix 4 \"==\" and\n  (Scala) infixl 5 \"==\"\n| class_instance uint16 :: equal \\<rightharpoonup> (Haskell) -\n| constant \"less_eq :: uint16 \\<Rightarrow> _ \\<Rightarrow> bool\" \\<rightharpoonup>\n  (SML_word) \"Word16.<= ((_), (_))\" and\n  (Haskell) infix 4 \"<=\" and\n  (Scala) infixl 4 \"<=\"\n| constant \"less :: uint16 \\<Rightarrow> _ \\<Rightarrow> bool\" \\<rightharpoonup>\n  (SML_word) \"Word16.< ((_), (_))\" and\n  (Haskell) infix 4 \"<\" and\n  (Scala) infixl 4 \"<\"\n| constant \"NOT :: uint16 \\<Rightarrow> _\" \\<rightharpoonup>\n  (SML_word) \"Word16.notb\" and\n  (Haskell) \"Data'_Bits.complement\" and\n  (Scala) \"_.unary'_~.toChar\"\n| constant \"(AND) :: uint16 \\<Rightarrow> _\" \\<rightharpoonup>\n  (SML_word) \"Word16.andb ((_),/ (_))\" and\n  (Haskell) infixl 7 \"Data_Bits..&.\" and\n  (Scala) \"(_ & _).toChar\"\n| constant \"(OR) :: uint16 \\<Rightarrow> _\" \\<rightharpoonup>\n  (SML_word) \"Word16.orb ((_),/ (_))\" and\n  (Haskell) infixl 5 \"Data_Bits..|.\" and\n  (Scala) \"(_ | _).toChar\"\n| constant \"(XOR) :: uint16 \\<Rightarrow> _\" \\<rightharpoonup>\n  (SML_word) \"Word16.xorb ((_),/ (_))\" and\n  (Haskell) \"Data'_Bits.xor\" and\n  (Scala) \"(_ ^ _).toChar\""], ["", "definition uint16_div :: \"uint16 \\<Rightarrow> uint16 \\<Rightarrow> uint16\" \nwhere \"uint16_div x y = (if y = 0 then undefined ((div) :: uint16 \\<Rightarrow> _) x (0 :: uint16) else x div y)\""], ["", "definition uint16_mod :: \"uint16 \\<Rightarrow> uint16 \\<Rightarrow> uint16\" \nwhere \"uint16_mod x y = (if y = 0 then undefined ((mod) :: uint16 \\<Rightarrow> _) x (0 :: uint16) else x mod y)\""], ["", "context includes undefined_transfer begin"], ["", "lemma div_uint16_code [code]: \"x div y = (if y = 0 then 0 else uint16_div x y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x div y = (if y = 0 then 0 else uint16_div x y)", "unfolding uint16_div_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. x div y =\n    (if y = 0 then 0 else if y = 0 then undefined (div) x 0 else x div y)", "by transfer (simp add: word_div_def)"], ["", "lemma mod_uint16_code [code]: \"x mod y = (if y = 0 then x else uint16_mod x y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x mod y = (if y = 0 then x else uint16_mod x y)", "unfolding uint16_mod_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. x mod y =\n    (if y = 0 then x else if y = 0 then undefined (mod) x 0 else x mod y)", "by transfer (simp add: word_mod_def)"], ["", "lemma uint16_div_code [code abstract]:\n  \"Rep_uint16 (uint16_div x y) =\n  (if y = 0 then Rep_uint16 (undefined ((div) :: uint16 \\<Rightarrow> _) x (0 :: uint16)) else Rep_uint16 x div Rep_uint16 y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_uint16 (uint16_div x y) =\n    (if y = 0 then Rep_uint16 (undefined (div) x 0)\n     else Rep_uint16 x div Rep_uint16 y)", "unfolding uint16_div_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_uint16 (if y = 0 then undefined (div) x 0 else x div y) =\n    (if y = 0 then Rep_uint16 (undefined (div) x 0)\n     else Rep_uint16 x div Rep_uint16 y)", "by transfer simp"], ["", "lemma uint16_mod_code [code abstract]:\n  \"Rep_uint16 (uint16_mod x y) =\n  (if y = 0 then Rep_uint16 (undefined ((mod) :: uint16 \\<Rightarrow> _) x (0 :: uint16)) else Rep_uint16 x mod Rep_uint16 y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_uint16 (uint16_mod x y) =\n    (if y = 0 then Rep_uint16 (undefined (mod) x 0)\n     else Rep_uint16 x mod Rep_uint16 y)", "unfolding uint16_mod_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_uint16 (if y = 0 then undefined (mod) x 0 else x mod y) =\n    (if y = 0 then Rep_uint16 (undefined (mod) x 0)\n     else Rep_uint16 x mod Rep_uint16 y)", "by transfer simp"], ["", "end"], ["", "code_printing constant uint16_div \\<rightharpoonup>\n  (SML_word) \"Word16.div ((_), (_))\" and\n  (Haskell) \"Prelude.div\" and\n  (Scala) \"(_ '/ _).toChar\"\n| constant uint16_mod \\<rightharpoonup>\n  (SML_word) \"Word16.mod ((_), (_))\" and\n  (Haskell) \"Prelude.mod\" and\n  (Scala) \"(_ % _).toChar\""], ["", "definition uint16_test_bit :: \"uint16 \\<Rightarrow> integer \\<Rightarrow> bool\"\nwhere [code del]:\n  \"uint16_test_bit x n =\n  (if n < 0 \\<or> 15 < n then undefined (bit :: uint16 \\<Rightarrow> _) x n\n   else bit x (nat_of_integer n))\""], ["", "lemma test_bit_uint16_code [code]:\n  \"bit x n \\<longleftrightarrow> n < 16 \\<and> uint16_test_bit x (integer_of_nat n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bit x n = (n < 16 \\<and> uint16_test_bit x (integer_of_nat n))", "including undefined_transfer integer.lifting"], ["proof (prove)\ngoal (1 subgoal):\n 1. bit x n = (n < 16 \\<and> uint16_test_bit x (integer_of_nat n))", "unfolding uint16_test_bit_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. bit x n =\n    (n < 16 \\<and>\n     (if integer_of_nat n < 0 \\<or> 15 < integer_of_nat n\n      then undefined bit x (integer_of_nat n)\n      else bit x (nat_of_integer (integer_of_nat n))))", "by (transfer, simp, transfer, simp)"], ["", "lemma uint16_test_bit_code [code]:\n  \"uint16_test_bit w n =\n  (if n < 0 \\<or> 15 < n then undefined (bit :: uint16 \\<Rightarrow> _) w n else bit (Rep_uint16 w) (nat_of_integer n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. uint16_test_bit w n =\n    (if n < 0 \\<or> 15 < n then undefined bit w n\n     else bit (Rep_uint16 w) (nat_of_integer n))", "unfolding uint16_test_bit_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if n < 0 \\<or> 15 < n then undefined bit w n\n     else bit w (nat_of_integer n)) =\n    (if n < 0 \\<or> 15 < n then undefined bit w n\n     else bit (Rep_uint16 w) (nat_of_integer n))", "by (simp add: bit_uint16.rep_eq)"], ["", "code_printing constant uint16_test_bit \\<rightharpoonup>\n  (SML_word) \"Uint16.test'_bit\" and\n  (Haskell) \"Data'_Bits.testBitBounded\" and\n  (Scala) \"Uint16.test'_bit\""], ["", "definition uint16_set_bit :: \"uint16 \\<Rightarrow> integer \\<Rightarrow> bool \\<Rightarrow> uint16\"\nwhere [code del]:\n  \"uint16_set_bit x n b =\n  (if n < 0 \\<or> 15 < n then undefined (set_bit :: uint16 \\<Rightarrow> _) x n b\n   else set_bit x (nat_of_integer n) b)\""], ["", "lemma set_bit_uint16_code [code]:\n  \"set_bit x n b = (if n < 16 then uint16_set_bit x (integer_of_nat n) b else x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_bit_class.set_bit x n b =\n    (if n < 16 then uint16_set_bit x (integer_of_nat n) b else x)", "including undefined_transfer integer.lifting"], ["proof (prove)\ngoal (1 subgoal):\n 1. set_bit_class.set_bit x n b =\n    (if n < 16 then uint16_set_bit x (integer_of_nat n) b else x)", "unfolding uint16_set_bit_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. set_bit_class.set_bit x n b =\n    (if n < 16\n     then if integer_of_nat n < 0 \\<or> 15 < integer_of_nat n\n          then undefined set_bit_class.set_bit x (integer_of_nat n) b\n          else set_bit_class.set_bit x (nat_of_integer (integer_of_nat n)) b\n     else x)", "by(transfer)(auto cong: conj_cong simp add: not_less set_bit_beyond word_size)"], ["", "lemma uint16_set_bit_code [code abstract]:\n  \"Rep_uint16 (uint16_set_bit w n b) = \n  (if n < 0 \\<or> 15 < n then Rep_uint16 (undefined (set_bit :: uint16 \\<Rightarrow> _) w n b)\n   else set_bit (Rep_uint16 w) (nat_of_integer n) b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_uint16 (uint16_set_bit w n b) =\n    (if n < 0 \\<or> 15 < n\n     then Rep_uint16 (undefined set_bit_class.set_bit w n b)\n     else set_bit_class.set_bit (Rep_uint16 w) (nat_of_integer n) b)", "including undefined_transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_uint16 (uint16_set_bit w n b) =\n    (if n < 0 \\<or> 15 < n\n     then Rep_uint16 (undefined set_bit_class.set_bit w n b)\n     else set_bit_class.set_bit (Rep_uint16 w) (nat_of_integer n) b)", "unfolding uint16_set_bit_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_uint16\n     (if n < 0 \\<or> 15 < n then undefined set_bit_class.set_bit w n b\n      else set_bit_class.set_bit w (nat_of_integer n) b) =\n    (if n < 0 \\<or> 15 < n\n     then Rep_uint16 (undefined set_bit_class.set_bit w n b)\n     else set_bit_class.set_bit (Rep_uint16 w) (nat_of_integer n) b)", "by transfer simp"], ["", "code_printing constant uint16_set_bit \\<rightharpoonup>\n  (SML_word) \"Uint16.set'_bit\" and\n  (Haskell) \"Data'_Bits.setBitBounded\" and\n  (Scala) \"Uint16.set'_bit\""], ["", "lift_definition uint16_set_bits :: \"(nat \\<Rightarrow> bool) \\<Rightarrow> uint16 \\<Rightarrow> nat \\<Rightarrow> uint16\" is set_bits_aux"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma uint16_set_bits_code [code]:\n  \"uint16_set_bits f w n =\n  (if n = 0 then w \n   else let n' = n - 1 in uint16_set_bits f ((push_bit 1 w) OR (if f n' then 1 else 0)) n')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. uint16_set_bits f w n =\n    (if n = 0 then w\n     else let n' = n - 1\n          in uint16_set_bits f (push_bit 1 w OR (if f n' then 1 else 0)) n')", "apply (transfer fixing: n)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f w.\n       set_bits_aux f w n =\n       (if n = 0 then w\n        else let n' = n - 1\n             in set_bits_aux f (push_bit 1 w OR (if f n' then 1 else 0)) n')", "apply (cases n)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>f w.\n       n = 0 \\<Longrightarrow>\n       set_bits_aux f w n =\n       (if n = 0 then w\n        else let n' = n - 1\n             in set_bits_aux f (push_bit 1 w OR (if f n' then 1 else 0)) n')\n 2. \\<And>f w nat.\n       n = Suc nat \\<Longrightarrow>\n       set_bits_aux f w n =\n       (if n = 0 then w\n        else let n' = n - 1\n             in set_bits_aux f (push_bit 1 w OR (if f n' then 1 else 0)) n')", "apply (simp_all add: shiftl_eq_push_bit)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma set_bits_uint16 [code]:\n  \"(BITS n. f n) = uint16_set_bits f 0 16\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (BITS n. f n) = uint16_set_bits f 0 16", "by transfer(simp add: set_bits_conv_set_bits_aux)"], ["", "lemma lsb_code [code]: fixes x :: uint16 shows \"lsb x \\<longleftrightarrow> bit x 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lsb x = bit x 0", "by transfer (simp add: lsb_odd)"], ["", "definition uint16_shiftl :: \"uint16 \\<Rightarrow> integer \\<Rightarrow> uint16\"\nwhere [code del]:\n  \"uint16_shiftl x n = (if n < 0 \\<or> 16 \\<le> n then undefined (push_bit :: nat \\<Rightarrow> uint16 \\<Rightarrow> _) x n else push_bit (nat_of_integer n) x)\""], ["", "lemma shiftl_uint16_code [code]: \"push_bit n x = (if n < 16 then uint16_shiftl x (integer_of_nat n) else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. push_bit n x =\n    (if n < 16 then uint16_shiftl x (integer_of_nat n) else 0)", "including undefined_transfer integer.lifting"], ["proof (prove)\ngoal (1 subgoal):\n 1. push_bit n x =\n    (if n < 16 then uint16_shiftl x (integer_of_nat n) else 0)", "unfolding uint16_shiftl_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. push_bit n x =\n    (if n < 16\n     then if integer_of_nat n < 0 \\<or> 16 \\<le> integer_of_nat n\n          then undefined push_bit x (integer_of_nat n)\n          else push_bit (nat_of_integer (integer_of_nat n)) x\n     else 0)", "by transfer simp"], ["", "lemma uint16_shiftl_code [code abstract]:\n  \"Rep_uint16 (uint16_shiftl w n) =\n  (if n < 0 \\<or> 16 \\<le> n then Rep_uint16 (undefined (push_bit :: nat \\<Rightarrow> uint16 \\<Rightarrow> _) w n)\n   else push_bit (nat_of_integer n) (Rep_uint16 w))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_uint16 (uint16_shiftl w n) =\n    (if n < 0 \\<or> 16 \\<le> n then Rep_uint16 (undefined push_bit w n)\n     else push_bit (nat_of_integer n) (Rep_uint16 w))", "including undefined_transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_uint16 (uint16_shiftl w n) =\n    (if n < 0 \\<or> 16 \\<le> n then Rep_uint16 (undefined push_bit w n)\n     else push_bit (nat_of_integer n) (Rep_uint16 w))", "unfolding uint16_shiftl_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_uint16\n     (if n < 0 \\<or> 16 \\<le> n then undefined push_bit w n\n      else push_bit (nat_of_integer n) w) =\n    (if n < 0 \\<or> 16 \\<le> n then Rep_uint16 (undefined push_bit w n)\n     else push_bit (nat_of_integer n) (Rep_uint16 w))", "by transfer simp"], ["", "code_printing constant uint16_shiftl \\<rightharpoonup>\n  (SML_word) \"Uint16.shiftl\" and\n  (Haskell) \"Data'_Bits.shiftlBounded\" and\n  (Scala) \"Uint16.shiftl\""], ["", "definition uint16_shiftr :: \"uint16 \\<Rightarrow> integer \\<Rightarrow> uint16\"\nwhere [code del]:\n  \"uint16_shiftr x n = (if n < 0 \\<or> 16 \\<le> n then undefined (drop_bit :: nat \\<Rightarrow> uint16 \\<Rightarrow> _) x n else drop_bit (nat_of_integer n) x)\""], ["", "lemma shiftr_uint16_code [code]: \"drop_bit n x = (if n < 16 then uint16_shiftr x (integer_of_nat n) else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. drop_bit n x =\n    (if n < 16 then uint16_shiftr x (integer_of_nat n) else 0)", "including undefined_transfer integer.lifting"], ["proof (prove)\ngoal (1 subgoal):\n 1. drop_bit n x =\n    (if n < 16 then uint16_shiftr x (integer_of_nat n) else 0)", "unfolding uint16_shiftr_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. drop_bit n x =\n    (if n < 16\n     then if integer_of_nat n < 0 \\<or> 16 \\<le> integer_of_nat n\n          then undefined drop_bit x (integer_of_nat n)\n          else drop_bit (nat_of_integer (integer_of_nat n)) x\n     else 0)", "by transfer simp"], ["", "lemma uint16_shiftr_code [code abstract]:\n  \"Rep_uint16 (uint16_shiftr w n) =\n  (if n < 0 \\<or> 16 \\<le> n then Rep_uint16 (undefined (drop_bit :: nat \\<Rightarrow> uint16 \\<Rightarrow> _) w n)\n   else drop_bit (nat_of_integer n) (Rep_uint16 w))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_uint16 (uint16_shiftr w n) =\n    (if n < 0 \\<or> 16 \\<le> n then Rep_uint16 (undefined drop_bit w n)\n     else drop_bit (nat_of_integer n) (Rep_uint16 w))", "including undefined_transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_uint16 (uint16_shiftr w n) =\n    (if n < 0 \\<or> 16 \\<le> n then Rep_uint16 (undefined drop_bit w n)\n     else drop_bit (nat_of_integer n) (Rep_uint16 w))", "unfolding uint16_shiftr_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_uint16\n     (if n < 0 \\<or> 16 \\<le> n then undefined drop_bit w n\n      else drop_bit (nat_of_integer n) w) =\n    (if n < 0 \\<or> 16 \\<le> n then Rep_uint16 (undefined drop_bit w n)\n     else drop_bit (nat_of_integer n) (Rep_uint16 w))", "by transfer simp"], ["", "code_printing constant uint16_shiftr \\<rightharpoonup>\n  (SML_word) \"Uint16.shiftr\" and\n  (Haskell) \"Data'_Bits.shiftrBounded\" and\n  (Scala) \"Uint16.shiftr\""], ["", "definition uint16_sshiftr :: \"uint16 \\<Rightarrow> integer \\<Rightarrow> uint16\"\nwhere [code del]:\n  \"uint16_sshiftr x n =\n  (if n < 0 \\<or> 16 \\<le> n then undefined sshiftr_uint16 x n else sshiftr_uint16 x (nat_of_integer n))\""], ["", "lemma sshiftr_uint16_code [code]:\n  \"x >>> n = \n  (if n < 16 then uint16_sshiftr x (integer_of_nat n) else if bit x 15 then -1 else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x >>> n =\n    (if n < 16 then uint16_sshiftr x (integer_of_nat n)\n     else if bit x 15 then - 1 else 0)", "including undefined_transfer integer.lifting"], ["proof (prove)\ngoal (1 subgoal):\n 1. x >>> n =\n    (if n < 16 then uint16_sshiftr x (integer_of_nat n)\n     else if bit x 15 then - 1 else 0)", "unfolding uint16_sshiftr_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. x >>> n =\n    (if n < 16\n     then if integer_of_nat n < 0 \\<or> 16 \\<le> integer_of_nat n\n          then undefined (>>>) x (integer_of_nat n)\n          else x >>> nat_of_integer (integer_of_nat n)\n     else if bit x 15 then - 1 else 0)", "by transfer (simp add: not_less signed_drop_bit_beyond word_size)"], ["", "lemma uint16_sshiftr_code [code abstract]:\n  \"Rep_uint16 (uint16_sshiftr w n) =\n  (if n < 0 \\<or> 16 \\<le> n then Rep_uint16 (undefined sshiftr_uint16 w n)\n   else signed_drop_bit (nat_of_integer n) (Rep_uint16 w))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_uint16 (uint16_sshiftr w n) =\n    (if n < 0 \\<or> 16 \\<le> n then Rep_uint16 (undefined (>>>) w n)\n     else signed_drop_bit (nat_of_integer n) (Rep_uint16 w))", "including undefined_transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_uint16 (uint16_sshiftr w n) =\n    (if n < 0 \\<or> 16 \\<le> n then Rep_uint16 (undefined (>>>) w n)\n     else signed_drop_bit (nat_of_integer n) (Rep_uint16 w))", "unfolding uint16_sshiftr_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_uint16\n     (if n < 0 \\<or> 16 \\<le> n then undefined (>>>) w n\n      else w >>> nat_of_integer n) =\n    (if n < 0 \\<or> 16 \\<le> n then Rep_uint16 (undefined (>>>) w n)\n     else signed_drop_bit (nat_of_integer n) (Rep_uint16 w))", "by transfer simp"], ["", "code_printing constant uint16_sshiftr \\<rightharpoonup>\n  (SML_word) \"Uint16.shiftr'_signed\" and\n  (Haskell) \n    \"(Prelude.fromInteger (Prelude.toInteger (Data'_Bits.shiftrBounded (Prelude.fromInteger (Prelude.toInteger _) :: Uint16.Int16) _)) :: Uint16.Word16)\" and\n  (Scala) \"Uint16.shiftr'_signed\""], ["", "lemma uint16_msb_test_bit: \"msb x \\<longleftrightarrow> bit (x :: uint16) 15\""], ["proof (prove)\ngoal (1 subgoal):\n 1. msb x = bit x 15", "by transfer (simp add: msb_word_iff_bit)"], ["", "lemma msb_uint16_code [code]: \"msb x \\<longleftrightarrow> uint16_test_bit x 15\""], ["proof (prove)\ngoal (1 subgoal):\n 1. msb x = uint16_test_bit x 15", "by (simp add: uint16_test_bit_def uint16_msb_test_bit)"], ["", "lemma uint16_of_int_code [code]: \"uint16_of_int i = Uint16 (integer_of_int i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. uint16_of_int i = Uint16 (integer_of_int i)", "including integer.lifting"], ["proof (prove)\ngoal (1 subgoal):\n 1. uint16_of_int i = Uint16 (integer_of_int i)", "by transfer simp"], ["", "lemma int_of_uint16_code [code]:\n  \"int_of_uint16 x = int_of_integer (integer_of_uint16 x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int_of_uint16 x = int_of_integer (integer_of_uint16 x)", "by(simp add: integer_of_uint16_def)"], ["", "lemma nat_of_uint16_code [code]:\n  \"nat_of_uint16 x = nat_of_integer (integer_of_uint16 x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nat_of_uint16 x = nat_of_integer (integer_of_uint16 x)", "unfolding integer_of_uint16_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. nat_of_uint16 x =\n    nat_of_integer ((integer_of_int \\<circ> int_of_uint16) x)", "including integer.lifting"], ["proof (prove)\ngoal (1 subgoal):\n 1. nat_of_uint16 x =\n    nat_of_integer ((integer_of_int \\<circ> int_of_uint16) x)", "by transfer simp"], ["", "lemma integer_of_uint16_code [code]:\n  \"integer_of_uint16 n = integer_of_int (uint (Rep_uint16' n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. integer_of_uint16 n = integer_of_int (uint (Rep_uint16' n))", "unfolding integer_of_uint16_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (integer_of_int \\<circ> int_of_uint16) n =\n    integer_of_int (uint (Rep_uint16' n))", "by transfer auto"], ["", "code_printing\n  constant \"integer_of_uint16\" \\<rightharpoonup>\n  (SML_word) \"Word16.toInt _ : IntInf.int\" and\n  (Haskell) \"Prelude.toInteger\" and\n  (Scala) \"BigInt\""], ["", "section \\<open>Quickcheck setup\\<close>"], ["", "definition uint16_of_natural :: \"natural \\<Rightarrow> uint16\"\nwhere \"uint16_of_natural x \\<equiv> Uint16 (integer_of_natural x)\""], ["", "instantiation uint16 :: \"{random, exhaustive, full_exhaustive}\" begin"], ["", "definition \"random_uint16 \\<equiv> qc_random_cnv uint16_of_natural\""], ["", "definition \"exhaustive_uint16 \\<equiv> qc_exhaustive_cnv uint16_of_natural\""], ["", "definition \"full_exhaustive_uint16 \\<equiv> qc_full_exhaustive_cnv uint16_of_natural\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(uint16, exhaustive_class) &&&\n    OFCLASS(uint16, full_exhaustive_class) &&& OFCLASS(uint16, random_class)", ".."], ["", "end"], ["", "instantiation uint16 :: narrowing begin"], ["", "interpretation quickcheck_narrowing_samples\n  \"\\<lambda>i. let x = Uint16 i in (x, 0xFFFF - x)\" \"0\"\n  \"Typerep.Typerep (STR ''Uint16.uint16'') []\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "definition \"narrowing_uint16 d = qc_narrowing_drawn_from (narrowing_samples d) d\""], ["", "declare [[code drop: \"partial_term_of :: uint16 itself \\<Rightarrow> _\"]]"], ["", "lemmas partial_term_of_uint16 [code] = partial_term_of_code"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(uint16, narrowing_class)", ".."], ["", "end"], ["", "no_notation sshiftr_uint16 (infixl \">>>\" 55)"], ["", "end"]]}