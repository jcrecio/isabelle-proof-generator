{"file_name": "/home/qj213/afp-2021-10-22/thys/Native_Word/Uint32.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Native_Word", "problem_names": ["lemmas [code] = less_uint32.rep_eq less_eq_uint32.rep_eq", "lemma [transfer_rule]:\n  \"((=) ===> cr_uint32) of_bool of_bool\"", "lemma transfer_rule_numeral_uint [transfer_rule]:\n  \"((=) ===> cr_uint32) numeral numeral\"", "lemma [transfer_rule]:\n  \\<open>(cr_uint32 ===> (\\<longleftrightarrow>)) even ((dvd) 2 :: uint32 \\<Rightarrow> bool)\\<close>", "lemma [code]:\n  \\<open>take_bit n a = a AND mask n\\<close> for a :: uint32", "lemma [code]:\n  \\<open>mask (Suc n) = push_bit n (1 :: uint32) OR mask n\\<close>\n  \\<open>mask 0 = (0 :: uint32)\\<close>", "lemma test_bit_uint32_transfer [transfer_rule]:\n  \\<open>(cr_uint32 ===> (=)) bit (!!)\\<close>", "lemma shiftl_uint32_transfer [transfer_rule]:\n  \\<open>(cr_uint32 ===> (=) ===> cr_uint32) (\\<lambda>k n. push_bit n k) (<<)\\<close>", "lemma shiftr_uint32_transfer [transfer_rule]:\n  \\<open>(cr_uint32 ===> (=) ===> cr_uint32) (\\<lambda>k n. drop_bit n k) (>>)\\<close>", "lemmas [code] = bit_uint32.rep_eq lsb_uint32.rep_eq msb_uint32.rep_eq", "lemmas [code] = equal_uint32.rep_eq", "lemmas [code] = size_uint32.rep_eq", "lemma Rep_uint32_numeral [simp]: \"Rep_uint32 (numeral n) = numeral n\"", "lemma numeral_uint32_transfer [transfer_rule]:\n  \"(rel_fun (=) cr_uint32) numeral numeral\"", "lemma numeral_uint32 [code_unfold]: \"numeral n = Uint32 (numeral n)\"", "lemma Rep_uint32_neg_numeral [simp]: \"Rep_uint32 (- numeral n) = - numeral n\"", "lemma neg_numeral_uint32 [code_unfold]: \"- numeral n = Uint32 (- numeral n)\"", "lemma Abs_uint32_numeral [code_post]: \"Abs_uint32 (numeral n) = numeral n\"", "lemma Abs_uint32_0 [code_post]: \"Abs_uint32 0 = 0\"", "lemma Abs_uint32_1 [code_post]: \"Abs_uint32 1 = 1\"", "lemma Uint32_code [code]:\n  \"Uint32 i = \n  (let i' = i AND 0xFFFFFFFF\n   in if bit i' 31 then Uint32_signed (i' - 0x100000000) else Uint32_signed i')\"", "lemma Uint32_signed_code [code abstract]:\n  \"Rep_uint32 (Uint32_signed i) = \n  (if i < -(0x80000000) \\<or> i \\<ge> 0x80000000 then Rep_uint32 (undefined Uint32 i) else word_of_int (int_of_integer_symbolic i))\"", "lemma Rep_uint32'_transfer [transfer_rule]:\n  \"rel_fun cr_uint32 (=) (\\<lambda>x. x) Rep_uint32'\"", "lemma Rep_uint32'_code [code]: \"Rep_uint32' x = (BITS n. bit x n)\"", "lemma Abs_uint32'_code [code]:\n  \"Abs_uint32' x = Uint32 (integer_of_int (uint x))\"", "lemma term_of_uint32_code [code]:\n  defines \"TR \\<equiv> typerep.Typerep\" and \"bit0 \\<equiv> STR ''Numeral_Type.bit0''\" \n  shows\n  \"term_of_class.term_of x = \n   Code_Evaluation.App (Code_Evaluation.Const (STR ''Uint32.uint32.Abs_uint32'') (TR (STR ''fun'') [TR (STR ''Word.word'') [TR bit0 [TR bit0 [TR bit0 [TR bit0 [TR bit0 [TR (STR ''Numeral_Type.num1'') []]]]]]], TR (STR ''Uint32.uint32'') []]))\n       (term_of_class.term_of (Rep_uint32' x))\"", "lemma div_uint32_code [code]: \"x div y = (if y = 0 then 0 else uint32_div x y)\"", "lemma mod_uint32_code [code]: \"x mod y = (if y = 0 then x else uint32_mod x y)\"", "lemma uint32_divmod_code [code]:\n  \"uint32_divmod x y =\n  (if 0x80000000 \\<le> y then if x < y then (0, x) else (1, x - y)\n   else if y = 0 then (div0_uint32 x, mod0_uint32 x)\n   else let q = (uint32_sdiv (drop_bit 1 x) y) << 1;\n            r = x - q * y\n        in if r \\<ge> y then (q + 1, r - y) else (q, r))\"", "lemma uint32_sdiv_code [code abstract]:\n  \"Rep_uint32 (uint32_sdiv x y) =\n   (if y = 0 then Rep_uint32 (undefined ((div) :: uint32 \\<Rightarrow> _) x (0 :: uint32))\n    else Rep_uint32 x sdiv Rep_uint32 y)\"", "lemma test_bit_uint32_code [code]:\n  \"bit x n \\<longleftrightarrow> n < 32 \\<and> uint32_test_bit x (integer_of_nat n)\"", "lemma uint32_test_bit_code [code]:\n  \"uint32_test_bit w n =\n  (if n < 0 \\<or> 31 < n then undefined (bit :: uint32 \\<Rightarrow> _) w n else bit (Rep_uint32 w) (nat_of_integer n))\"", "lemma set_bit_uint32_code [code]:\n  \"set_bit x n b = (if n < 32 then uint32_set_bit x (integer_of_nat n) b else x)\"", "lemma uint32_set_bit_code [code abstract]:\n  \"Rep_uint32 (uint32_set_bit w n b) = \n  (if n < 0 \\<or> 31 < n then Rep_uint32 (undefined (set_bit :: uint32 \\<Rightarrow> _) w n b)\n   else set_bit (Rep_uint32 w) (nat_of_integer n) b)\"", "lemma uint32_set_bits_code [code]:\n  \"uint32_set_bits f w n =\n  (if n = 0 then w \n   else let n' = n - 1 in uint32_set_bits f (push_bit 1 w OR (if f n' then 1 else 0)) n')\"", "lemma set_bits_uint32 [code]:\n  \"(BITS n. f n) = uint32_set_bits f 0 32\"", "lemma lsb_code [code]: fixes x :: uint32 shows \"lsb x \\<longleftrightarrow> bit x 0\"", "lemma shiftl_uint32_code [code]: \"push_bit n x = (if n < 32 then uint32_shiftl x (integer_of_nat n) else 0)\"", "lemma uint32_shiftl_code [code abstract]:\n  \"Rep_uint32 (uint32_shiftl w n) =\n  (if n < 0 \\<or> 32 \\<le> n then Rep_uint32 (undefined (push_bit :: nat \\<Rightarrow> uint32 \\<Rightarrow> _) w n) else push_bit (nat_of_integer n) (Rep_uint32 w))\"", "lemma shiftr_uint32_code [code]: \"drop_bit n x = (if n < 32 then uint32_shiftr x (integer_of_nat n) else 0)\"", "lemma uint32_shiftr_code [code abstract]:\n  \"Rep_uint32 (uint32_shiftr w n) =\n  (if n < 0 \\<or> 32 \\<le> n then Rep_uint32 (undefined (drop_bit :: nat \\<Rightarrow> uint32 \\<Rightarrow> _) w n) else drop_bit (nat_of_integer n) (Rep_uint32 w))\"", "lemma sshiftr_uint32_code [code]:\n  \"x >>> n = \n  (if n < 32 then uint32_sshiftr x (integer_of_nat n) else if bit x 31 then - 1 else 0)\"", "lemma uint32_sshiftr_code [code abstract]:\n  \"Rep_uint32 (uint32_sshiftr w n) =\n  (if n < 0 \\<or> 32 \\<le> n then Rep_uint32 (undefined sshiftr_uint32 w n) else signed_drop_bit (nat_of_integer n) (Rep_uint32 w))\"", "lemma uint32_msb_test_bit: \"msb x \\<longleftrightarrow> bit (x :: uint32) 31\"", "lemma msb_uint32_code [code]: \"msb x \\<longleftrightarrow> uint32_test_bit x 31\"", "lemma uint32_of_int_code [code]: \"uint32_of_int i = Uint32 (integer_of_int i)\"", "lemma int_of_uint32_code [code]:\n  \"int_of_uint32 x = int_of_integer (integer_of_uint32 x)\"", "lemma nat_of_uint32_code [code]:\n  \"nat_of_uint32 x = nat_of_integer (integer_of_uint32 x)\"", "lemma integer_of_uint32_signed_code [code]:\n  \"integer_of_uint32_signed n =\n  (if bit n 31 then undefined integer_of_uint32 n else integer_of_int (uint (Rep_uint32' n)))\"", "lemma integer_of_uint32_code [code]:\n  \"integer_of_uint32 n =\n  (if bit n 31 then integer_of_uint32_signed (n AND 0x7FFFFFFF) OR 0x80000000 else integer_of_uint32_signed n)\"", "lemmas partial_term_of_uint32 [code] = partial_term_of_code"], "translations": [["", "lemmas [code] = less_uint32.rep_eq less_eq_uint32.rep_eq"], ["", "context\n  includes lifting_syntax\n  notes\n    transfer_rule_of_bool [transfer_rule]\n    transfer_rule_numeral [transfer_rule]\nbegin"], ["", "lemma [transfer_rule]:\n  \"((=) ===> cr_uint32) of_bool of_bool\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((=) ===> cr_uint32) of_bool of_bool", "by transfer_prover"], ["", "lemma transfer_rule_numeral_uint [transfer_rule]:\n  \"((=) ===> cr_uint32) numeral numeral\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((=) ===> cr_uint32) numeral numeral", "by transfer_prover"], ["", "lemma [transfer_rule]:\n  \\<open>(cr_uint32 ===> (\\<longleftrightarrow>)) even ((dvd) 2 :: uint32 \\<Rightarrow> bool)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (cr_uint32 ===> (=)) even ((dvd) 2)", "by (unfold dvd_def) transfer_prover"], ["", "end"], ["", "instantiation uint32:: semiring_bits\nbegin"], ["", "lift_definition bit_uint32 :: \\<open>uint32 \\<Rightarrow> nat \\<Rightarrow> bool\\<close> is bit"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(uint32, semiring_bits_class)", "by (standard; transfer)\n    (fact bit_iff_odd even_iff_mod_2_eq_zero odd_iff_mod_2_eq_one odd_one bits_induct\n       bits_div_0 bits_div_by_1 bits_mod_div_trivial even_succ_div_2\n       even_mask_div_iff exp_div_exp_eq div_exp_eq mod_exp_eq mult_exp_mod_exp_eq\n       div_exp_mod_exp_eq even_mult_exp_div_exp_iff)+"], ["", "end"], ["", "instantiation uint32 :: semiring_bit_shifts\nbegin"], ["", "lift_definition push_bit_uint32 :: \\<open>nat \\<Rightarrow> uint32 \\<Rightarrow> uint32\\<close> is push_bit"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition drop_bit_uint32 :: \\<open>nat \\<Rightarrow> uint32 \\<Rightarrow> uint32\\<close> is drop_bit"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition take_bit_uint32 :: \\<open>nat \\<Rightarrow> uint32 \\<Rightarrow> uint32\\<close> is take_bit"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(uint32, semiring_bit_shifts_class)", "by (standard; transfer)\n  (fact push_bit_eq_mult drop_bit_eq_div take_bit_eq_mod)+"], ["", "end"], ["", "instantiation uint32 :: ring_bit_operations\nbegin"], ["", "lift_definition not_uint32 :: \\<open>uint32 \\<Rightarrow> uint32\\<close> is NOT"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition and_uint32 :: \\<open>uint32 \\<Rightarrow> uint32 \\<Rightarrow> uint32\\<close> is \\<open>(AND)\\<close>"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition or_uint32 :: \\<open>uint32 \\<Rightarrow> uint32 \\<Rightarrow> uint32\\<close> is \\<open>(OR)\\<close>"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition xor_uint32 :: \\<open>uint32 \\<Rightarrow> uint32 \\<Rightarrow> uint32\\<close> is \\<open>(XOR)\\<close>"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition mask_uint32 :: \\<open>nat \\<Rightarrow> uint32\\<close> is mask"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(uint32, ring_bit_operations_class)", "by (standard; transfer)\n  (simp_all add: bit_and_iff bit_or_iff bit_xor_iff bit_not_iff minus_eq_not_minus_1 mask_eq_decr_exp)"], ["", "end"], ["", "lemma [code]:\n  \\<open>take_bit n a = a AND mask n\\<close> for a :: uint32"], ["proof (prove)\ngoal (1 subgoal):\n 1. take_bit n a = a AND mask n", "by (fact take_bit_eq_mask)"], ["", "lemma [code]:\n  \\<open>mask (Suc n) = push_bit n (1 :: uint32) OR mask n\\<close>\n  \\<open>mask 0 = (0 :: uint32)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. mask (Suc n) = push_bit n 1 OR mask n &&& mask 0 = 0", "by (simp_all add: mask_Suc_exp push_bit_of_1)"], ["", "instance uint32 :: semiring_bit_syntax"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(uint32, semiring_bit_syntax_class)", ".."], ["", "context\n  includes lifting_syntax\nbegin"], ["", "lemma test_bit_uint32_transfer [transfer_rule]:\n  \\<open>(cr_uint32 ===> (=)) bit (!!)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (cr_uint32 ===> (=)) bit (!!)", "unfolding test_bit_eq_bit"], ["proof (prove)\ngoal (1 subgoal):\n 1. (cr_uint32 ===> (=)) bit bit", "by transfer_prover"], ["", "lemma shiftl_uint32_transfer [transfer_rule]:\n  \\<open>(cr_uint32 ===> (=) ===> cr_uint32) (\\<lambda>k n. push_bit n k) (<<)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (cr_uint32 ===> (=) ===> cr_uint32) (\\<lambda>k n. push_bit n k) (<<)", "unfolding shiftl_eq_push_bit"], ["proof (prove)\ngoal (1 subgoal):\n 1. (cr_uint32 ===> (=) ===> cr_uint32) (\\<lambda>k n. push_bit n k)\n     (\\<lambda>a n. push_bit n a)", "by transfer_prover"], ["", "lemma shiftr_uint32_transfer [transfer_rule]:\n  \\<open>(cr_uint32 ===> (=) ===> cr_uint32) (\\<lambda>k n. drop_bit n k) (>>)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (cr_uint32 ===> (=) ===> cr_uint32) (\\<lambda>k n. drop_bit n k) (>>)", "unfolding shiftr_eq_drop_bit"], ["proof (prove)\ngoal (1 subgoal):\n 1. (cr_uint32 ===> (=) ===> cr_uint32) (\\<lambda>k n. drop_bit n k)\n     (\\<lambda>a n. drop_bit n a)", "by transfer_prover"], ["", "end"], ["", "instantiation uint32 :: lsb\nbegin"], ["", "lift_definition lsb_uint32 :: \\<open>uint32 \\<Rightarrow> bool\\<close> is lsb"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(uint32, lsb_class)", "by (standard; transfer)\n  (fact lsb_odd)"], ["", "end"], ["", "instantiation uint32 :: msb\nbegin"], ["", "lift_definition msb_uint32 :: \\<open>uint32 \\<Rightarrow> bool\\<close> is msb"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(uint32, msb_class)", ".."], ["", "end"], ["", "instantiation uint32 :: set_bit\nbegin"], ["", "lift_definition set_bit_uint32 :: \\<open>uint32 \\<Rightarrow> nat \\<Rightarrow> bool \\<Rightarrow> uint32\\<close> is set_bit"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(uint32, set_bit_class)", "apply standard"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a m b n.\n       bit (set_bit_class.set_bit a m b) n =\n       ((if m = n then b else bit a n) \\<and> 2 ^ n \\<noteq> 0)", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a m b n.\n       bit (set_bit_class.set_bit a m b) n =\n       ((if m = n then b else bit a n) \\<and> 2 ^ n \\<noteq> 0)", "apply (simp add: bit_simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "instantiation uint32 :: bit_comprehension begin"], ["", "lift_definition set_bits_uint32 :: \"(nat \\<Rightarrow> bool) \\<Rightarrow> uint32\" is \"set_bits\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(uint32, bit_comprehension_class)", "by (standard; transfer) (fact set_bits_bit_eq)"], ["", "end"], ["", "lemmas [code] = bit_uint32.rep_eq lsb_uint32.rep_eq msb_uint32.rep_eq"], ["", "instantiation uint32 :: equal begin"], ["", "lift_definition equal_uint32 :: \"uint32 \\<Rightarrow> uint32 \\<Rightarrow> bool\" is \"equal_class.equal\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(uint32, equal_class)", "by standard (transfer, simp add: equal_eq)"], ["", "end"], ["", "lemmas [code] = equal_uint32.rep_eq"], ["", "instantiation uint32 :: size begin"], ["", "lift_definition size_uint32 :: \"uint32 \\<Rightarrow> nat\" is \"size\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(uint32, size_class)", ".."], ["", "end"], ["", "lemmas [code] = size_uint32.rep_eq"], ["", "lift_definition sshiftr_uint32 :: \"uint32 \\<Rightarrow> nat \\<Rightarrow> uint32\" (infixl \">>>\" 55) is \\<open>\\<lambda>w n. signed_drop_bit n w\\<close>"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition uint32_of_int :: \"int \\<Rightarrow> uint32\" is \"word_of_int\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "definition uint32_of_nat :: \"nat \\<Rightarrow> uint32\"\nwhere \"uint32_of_nat = uint32_of_int \\<circ> int\""], ["", "lift_definition int_of_uint32 :: \"uint32 \\<Rightarrow> int\" is \"uint\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition nat_of_uint32 :: \"uint32 \\<Rightarrow> nat\" is \"unat\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "definition integer_of_uint32 :: \"uint32 \\<Rightarrow> integer\"\nwhere \"integer_of_uint32 = integer_of_int o int_of_uint32\""], ["", "text \\<open>Use pretty numerals from integer for pretty printing\\<close>"], ["", "context includes integer.lifting begin"], ["", "lift_definition Uint32 :: \"integer \\<Rightarrow> uint32\" is \"word_of_int\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma Rep_uint32_numeral [simp]: \"Rep_uint32 (numeral n) = numeral n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_uint32 (numeral n) = numeral n", "by(induction n)(simp_all add: one_uint32_def Abs_uint32_inverse numeral.simps plus_uint32_def)"], ["", "lemma numeral_uint32_transfer [transfer_rule]:\n  \"(rel_fun (=) cr_uint32) numeral numeral\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_fun (=) cr_uint32 numeral numeral", "by(auto simp add: cr_uint32_def)"], ["", "lemma numeral_uint32 [code_unfold]: \"numeral n = Uint32 (numeral n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. numeral n = Uint32 (numeral n)", "by transfer simp"], ["", "lemma Rep_uint32_neg_numeral [simp]: \"Rep_uint32 (- numeral n) = - numeral n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_uint32 (- numeral n) = - numeral n", "by(simp only: uminus_uint32_def)(simp add: Abs_uint32_inverse)"], ["", "lemma neg_numeral_uint32 [code_unfold]: \"- numeral n = Uint32 (- numeral n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - numeral n = Uint32 (- numeral n)", "by transfer(simp add: cr_uint32_def)"], ["", "end"], ["", "lemma Abs_uint32_numeral [code_post]: \"Abs_uint32 (numeral n) = numeral n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_uint32 (numeral n) = numeral n", "by(induction n)(simp_all add: one_uint32_def numeral.simps plus_uint32_def Abs_uint32_inverse)"], ["", "lemma Abs_uint32_0 [code_post]: \"Abs_uint32 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_uint32 0 = 0", "by(simp add: zero_uint32_def)"], ["", "lemma Abs_uint32_1 [code_post]: \"Abs_uint32 1 = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_uint32 1 = 1", "by(simp add: one_uint32_def)"], ["", "section \\<open>Code setup\\<close>"], ["", "code_printing code_module Uint32 \\<rightharpoonup> (SML)\n\\<open>(* Test that words can handle numbers between 0 and 31 *)\nval _ = if 5 <= Word.wordSize then () else raise (Fail (\"wordSize less than 5\"));\n\nstructure Uint32 : sig\n  val set_bit : Word32.word -> IntInf.int -> bool -> Word32.word\n  val shiftl : Word32.word -> IntInf.int -> Word32.word\n  val shiftr : Word32.word -> IntInf.int -> Word32.word\n  val shiftr_signed : Word32.word -> IntInf.int -> Word32.word\n  val test_bit : Word32.word -> IntInf.int -> bool\nend = struct\n\nfun set_bit x n b =\n  let val mask = Word32.<< (0wx1, Word.fromLargeInt (IntInf.toLarge n))\n  in if b then Word32.orb (x, mask)\n     else Word32.andb (x, Word32.notb mask)\n  end\n\nfun shiftl x n =\n  Word32.<< (x, Word.fromLargeInt (IntInf.toLarge n))\n\nfun shiftr x n =\n  Word32.>> (x, Word.fromLargeInt (IntInf.toLarge n))\n\nfun shiftr_signed x n =\n  Word32.~>> (x, Word.fromLargeInt (IntInf.toLarge n))\n\nfun test_bit x n =\n  Word32.andb (x, Word32.<< (0wx1, Word.fromLargeInt (IntInf.toLarge n))) <> Word32.fromInt 0\n\nend; (* struct Uint32 *)\\<close>"], ["", "code_reserved SML Uint32"], ["", "code_printing code_module Uint32 \\<rightharpoonup> (Haskell)\n \\<open>module Uint32(Int32, Word32) where\n\n  import Data.Int(Int32)\n  import Data.Word(Word32)\\<close>"], ["", "code_reserved Haskell Uint32"], ["", "text \\<open>\n  OCaml and Scala provide only signed 32bit numbers, so we use these and \n  implement sign-sensitive operations like comparisons manually.\n\\<close>"], ["", "code_printing code_module \"Uint32\" \\<rightharpoonup> (OCaml)\n\\<open>module Uint32 : sig\n  val less : int32 -> int32 -> bool\n  val less_eq : int32 -> int32 -> bool\n  val set_bit : int32 -> Z.t -> bool -> int32\n  val shiftl : int32 -> Z.t -> int32\n  val shiftr : int32 -> Z.t -> int32\n  val shiftr_signed : int32 -> Z.t -> int32\n  val test_bit : int32 -> Z.t -> bool\nend = struct\n\n(* negative numbers have their highest bit set, \n   so they are greater than positive ones *)\nlet less x y =\n  if Int32.compare x Int32.zero < 0 then\n    Int32.compare y Int32.zero < 0 && Int32.compare x y < 0\n  else Int32.compare y Int32.zero < 0 || Int32.compare x y < 0;;\n\nlet less_eq x y =\n  if Int32.compare x Int32.zero < 0 then\n    Int32.compare y Int32.zero < 0 && Int32.compare x y <= 0\n  else Int32.compare y Int32.zero < 0 || Int32.compare x y <= 0;;\n\nlet set_bit x n b =\n  let mask = Int32.shift_left Int32.one (Z.to_int n)\n  in if b then Int32.logor x mask\n     else Int32.logand x (Int32.lognot mask);;\n\nlet shiftl x n = Int32.shift_left x (Z.to_int n);;\n\nlet shiftr x n = Int32.shift_right_logical x (Z.to_int n);;\n\nlet shiftr_signed x n = Int32.shift_right x (Z.to_int n);;\n\nlet test_bit x n =\n  Int32.compare \n    (Int32.logand x (Int32.shift_left Int32.one (Z.to_int n)))\n    Int32.zero\n  <> 0;;\n\nend;; (*struct Uint32*)\\<close>"], ["", "code_reserved OCaml Uint32"], ["", "code_printing code_module Uint32 \\<rightharpoonup> (Scala)\n\\<open>object Uint32 {\n\ndef less(x: Int, y: Int) : Boolean =\n  if (x < 0) y < 0 && x < y\n  else y < 0 || x < y\n\ndef less_eq(x: Int, y: Int) : Boolean =\n  if (x < 0) y < 0 && x <= y\n  else y < 0 || x <= y\n\ndef set_bit(x: Int, n: BigInt, b: Boolean) : Int =\n  if (b)\n    x | (1 << n.intValue)\n  else\n    x & (1 << n.intValue).unary_~\n\ndef shiftl(x: Int, n: BigInt) : Int = x << n.intValue\n\ndef shiftr(x: Int, n: BigInt) : Int = x >>> n.intValue\n\ndef shiftr_signed(x: Int, n: BigInt) : Int = x >> n.intValue\n\ndef test_bit(x: Int, n: BigInt) : Boolean =\n  (x & (1 << n.intValue)) != 0\n\n} /* object Uint32 */\\<close>"], ["", "code_reserved Scala Uint32"], ["", "text \\<open>\n  OCaml's conversion from Big\\_int to int32 demands that the value fits int a signed 32-bit integer.\n  The following justifies the implementation.\n\\<close>"], ["", "definition Uint32_signed :: \"integer \\<Rightarrow> uint32\" \nwhere \"Uint32_signed i = (if i < -(0x80000000) \\<or> i \\<ge> 0x80000000 then undefined Uint32 i else Uint32 i)\""], ["", "lemma Uint32_code [code]:\n  \"Uint32 i = \n  (let i' = i AND 0xFFFFFFFF\n   in if bit i' 31 then Uint32_signed (i' - 0x100000000) else Uint32_signed i')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Uint32 i =\n    (let i' = i AND 4294967295\n     in if bit i' 31 then Uint32_signed (i' - 4294967296)\n        else Uint32_signed i')", "including undefined_transfer integer.lifting"], ["proof (prove)\ngoal (1 subgoal):\n 1. Uint32 i =\n    (let i' = i AND 4294967295\n     in if bit i' 31 then Uint32_signed (i' - 4294967296)\n        else Uint32_signed i')", "unfolding Uint32_signed_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Uint32 i =\n    (let i' = i AND 4294967295\n     in if bit i' 31\n        then if i' - 4294967296 < - 2147483648 \\<or>\n                2147483648 \\<le> i' - 4294967296\n             then undefined Uint32 (i' - 4294967296)\n             else Uint32 (i' - 4294967296)\n        else if i' < - 2147483648 \\<or> 2147483648 \\<le> i'\n             then undefined Uint32 i' else Uint32 i')", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       word_of_int i =\n       (let i' = i AND 4294967295\n        in if bit i' 31\n           then if i' - 4294967296 < - 2147483648 \\<or>\n                   2147483648 \\<le> i' - 4294967296\n                then map_fun (map_fun int_of_integer Abs_uint32)\n                      (map_fun integer_of_int Rep_uint32) undefined\n                      word_of_int (i' - 4294967296)\n                else word_of_int (i' - 4294967296)\n           else if i' < - 2147483648 \\<or> 2147483648 \\<le> i'\n                then map_fun (map_fun int_of_integer Abs_uint32)\n                      (map_fun integer_of_int Rep_uint32) undefined\n                      word_of_int i'\n                else word_of_int i')", "apply (subst word_of_int_via_signed)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>i. ?mask2754 i = mask LENGTH(32)\n 2. \\<And>i. ?shift2754 i = 1 << LENGTH(32)\n 3. \\<And>i. ?index2754 i = LENGTH(32) - 1\n 4. \\<And>i. ?overflow2754 i = 1 << LENGTH(32) - 1\n 5. \\<And>i. ?least2754 i = - ?overflow2754 i\n 6. \\<And>i.\n       (let i' = i AND ?mask2754 i\n        in if i' !! ?index2754 i\n           then if i' - ?shift2754 i < ?least2754 i \\<or>\n                   ?overflow2754 i \\<le> i' - ?shift2754 i\n                then ?arbitrary1.2754 i i'\n                else word_of_int (i' - ?shift2754 i)\n           else if i' < ?least2754 i \\<or> ?overflow2754 i \\<le> i'\n                then ?arbitrary2.2754 i i' else word_of_int i') =\n       (let i' = i AND 4294967295\n        in if bit i' 31\n           then if i' - 4294967296 < - 2147483648 \\<or>\n                   2147483648 \\<le> i' - 4294967296\n                then map_fun (map_fun int_of_integer Abs_uint32)\n                      (map_fun integer_of_int Rep_uint32) undefined\n                      word_of_int (i' - 4294967296)\n                else word_of_int (i' - 4294967296)\n           else if i' < - 2147483648 \\<or> 2147483648 \\<le> i'\n                then map_fun (map_fun int_of_integer Abs_uint32)\n                      (map_fun integer_of_int Rep_uint32) undefined\n                      word_of_int i'\n                else word_of_int i')", "apply (auto simp add: shiftl_eq_push_bit push_bit_of_1 mask_eq_exp_minus_1 word_of_int_via_signed cong del: if_cong)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma Uint32_signed_code [code abstract]:\n  \"Rep_uint32 (Uint32_signed i) = \n  (if i < -(0x80000000) \\<or> i \\<ge> 0x80000000 then Rep_uint32 (undefined Uint32 i) else word_of_int (int_of_integer_symbolic i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_uint32 (Uint32_signed i) =\n    (if i < - 2147483648 \\<or> 2147483648 \\<le> i\n     then Rep_uint32 (undefined Uint32 i)\n     else word_of_int (int_of_integer_symbolic i))", "unfolding Uint32_signed_def Uint32_def int_of_integer_symbolic_def word_of_integer_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_uint32\n     (if i < - 2147483648 \\<or> 2147483648 \\<le> i\n      then undefined (map_fun int_of_integer Abs_uint32 word_of_int) i\n      else map_fun int_of_integer Abs_uint32 word_of_int i) =\n    (if i < - 2147483648 \\<or> 2147483648 \\<le> i\n     then Rep_uint32\n           (undefined (map_fun int_of_integer Abs_uint32 word_of_int) i)\n     else word_of_int (int_of_integer i))", "by(simp add: Abs_uint32_inverse)"], ["", "text \\<open>\n  Avoid @{term Abs_uint32} in generated code, use @{term Rep_uint32'} instead. \n  The symbolic implementations for code\\_simp use @{term Rep_uint32}.\n\n  The new destructor @{term Rep_uint32'} is executable.\n  As the simplifier is given the [code abstract] equations literally, \n  we cannot implement @{term Rep_uint32} directly, because that makes code\\_simp loop.\n\n  If code generation raises Match, some equation probably contains @{term Rep_uint32} \n  ([code abstract] equations for @{typ uint32} may use @{term Rep_uint32} because\n  these instances will be folded away.)\n\n  To convert @{typ \"32 word\"} values into @{typ uint32}, use @{term \"Abs_uint32'\"}.\n\\<close>"], ["", "definition Rep_uint32' where [simp]: \"Rep_uint32' = Rep_uint32\""], ["", "lemma Rep_uint32'_transfer [transfer_rule]:\n  \"rel_fun cr_uint32 (=) (\\<lambda>x. x) Rep_uint32'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_fun cr_uint32 (=) (\\<lambda>x. x) Rep_uint32'", "unfolding Rep_uint32'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_fun cr_uint32 (=) (\\<lambda>x. x) Rep_uint32", "by(rule uint32.rep_transfer)"], ["", "lemma Rep_uint32'_code [code]: \"Rep_uint32' x = (BITS n. bit x n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_uint32' x = (BITS n. bit x n)", "by transfer (simp add: set_bits_bit_eq)"], ["", "lift_definition Abs_uint32' :: \"32 word \\<Rightarrow> uint32\" is \"\\<lambda>x :: 32 word. x\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma Abs_uint32'_code [code]:\n  \"Abs_uint32' x = Uint32 (integer_of_int (uint x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_uint32' x = Uint32 (integer_of_int (uint x))", "including integer.lifting"], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_uint32' x = Uint32 (integer_of_int (uint x))", "by transfer simp"], ["", "declare [[code drop: \"term_of_class.term_of :: uint32 \\<Rightarrow> _\"]]"], ["", "lemma term_of_uint32_code [code]:\n  defines \"TR \\<equiv> typerep.Typerep\" and \"bit0 \\<equiv> STR ''Numeral_Type.bit0''\" \n  shows\n  \"term_of_class.term_of x = \n   Code_Evaluation.App (Code_Evaluation.Const (STR ''Uint32.uint32.Abs_uint32'') (TR (STR ''fun'') [TR (STR ''Word.word'') [TR bit0 [TR bit0 [TR bit0 [TR bit0 [TR bit0 [TR (STR ''Numeral_Type.num1'') []]]]]]], TR (STR ''Uint32.uint32'') []]))\n       (term_of_class.term_of (Rep_uint32' x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. term_of_class.term_of x =\n    Code_Evaluation.App\n     (Code_Evaluation.Const STR ''Uint32.uint32.Abs_uint32''\n       (TR STR ''fun''\n         [TR STR ''Word.word''\n           [TR bit0\n             [TR bit0\n               [TR bit0\n                 [TR bit0 [TR bit0 [TR STR ''Numeral_Type.num1'' []]]]]]],\n          TR STR ''Uint32.uint32'' []]))\n     (term_of_class.term_of (Rep_uint32' x))", "by(simp add: term_of_anything)"], ["", "code_printing\n  type_constructor uint32 \\<rightharpoonup>\n  (SML) \"Word32.word\" and\n  (Haskell) \"Uint32.Word32\" and\n  (OCaml) \"int32\" and\n  (Scala) \"Int\" and\n  (Eval) \"Word32.word\"\n| constant Uint32 \\<rightharpoonup>\n  (SML) \"Word32.fromLargeInt (IntInf.toLarge _)\" and\n  (Haskell) \"(Prelude.fromInteger _ :: Uint32.Word32)\" and\n  (Haskell_Quickcheck) \"(Prelude.fromInteger (Prelude.toInteger _) :: Uint32.Word32)\" and\n  (Scala) \"_.intValue\"\n| constant Uint32_signed \\<rightharpoonup>\n  (OCaml) \"Z.to'_int32\"\n| constant \"0 :: uint32\" \\<rightharpoonup>\n  (SML) \"(Word32.fromInt 0)\" and\n  (Haskell) \"(0 :: Uint32.Word32)\" and\n  (OCaml) \"Int32.zero\" and\n  (Scala) \"0\"\n| constant \"1 :: uint32\" \\<rightharpoonup>\n  (SML) \"(Word32.fromInt 1)\" and\n  (Haskell) \"(1 :: Uint32.Word32)\" and\n  (OCaml) \"Int32.one\" and\n  (Scala) \"1\"\n| constant \"plus :: uint32 \\<Rightarrow> _ \" \\<rightharpoonup>\n  (SML) \"Word32.+ ((_), (_))\" and\n  (Haskell) infixl 6 \"+\" and\n  (OCaml) \"Int32.add\" and\n  (Scala) infixl 7 \"+\"\n| constant \"uminus :: uint32 \\<Rightarrow> _\" \\<rightharpoonup>\n  (SML) \"Word32.~\" and\n  (Haskell) \"negate\" and\n  (OCaml) \"Int32.neg\" and\n  (Scala) \"!(- _)\"\n| constant \"minus :: uint32 \\<Rightarrow> _\" \\<rightharpoonup>\n  (SML) \"Word32.- ((_), (_))\" and\n  (Haskell) infixl 6 \"-\" and\n  (OCaml) \"Int32.sub\" and\n  (Scala) infixl 7 \"-\"\n| constant \"times :: uint32 \\<Rightarrow> _ \\<Rightarrow> _\" \\<rightharpoonup>\n  (SML) \"Word32.* ((_), (_))\" and\n  (Haskell) infixl 7 \"*\" and\n  (OCaml) \"Int32.mul\" and\n  (Scala) infixl 8 \"*\"\n| constant \"HOL.equal :: uint32 \\<Rightarrow> _ \\<Rightarrow> bool\" \\<rightharpoonup>\n  (SML) \"!((_ : Word32.word) = _)\" and\n  (Haskell) infix 4 \"==\" and\n  (OCaml) \"(Int32.compare _ _ = 0)\" and\n  (Scala) infixl 5 \"==\"\n| class_instance uint32 :: equal \\<rightharpoonup>\n  (Haskell) -\n| constant \"less_eq :: uint32 \\<Rightarrow> _ \\<Rightarrow> bool\" \\<rightharpoonup>\n  (SML) \"Word32.<= ((_), (_))\" and\n  (Haskell) infix 4 \"<=\" and\n  (OCaml) \"Uint32.less'_eq\" and\n  (Scala) \"Uint32.less'_eq\"\n| constant \"less :: uint32 \\<Rightarrow> _ \\<Rightarrow> bool\" \\<rightharpoonup>\n  (SML) \"Word32.< ((_), (_))\" and\n  (Haskell) infix 4 \"<\" and\n  (OCaml) \"Uint32.less\" and\n  (Scala) \"Uint32.less\"\n| constant \"NOT :: uint32 \\<Rightarrow> _\" \\<rightharpoonup>\n  (SML) \"Word32.notb\" and\n  (Haskell) \"Data'_Bits.complement\" and\n  (OCaml) \"Int32.lognot\" and\n  (Scala) \"_.unary'_~\"\n| constant \"(AND) :: uint32 \\<Rightarrow> _\" \\<rightharpoonup>\n  (SML) \"Word32.andb ((_),/ (_))\" and\n  (Haskell) infixl 7 \"Data_Bits..&.\" and\n  (OCaml) \"Int32.logand\" and\n  (Scala) infixl 3 \"&\"\n| constant \"(OR) :: uint32 \\<Rightarrow> _\" \\<rightharpoonup>\n  (SML) \"Word32.orb ((_),/ (_))\" and\n  (Haskell) infixl 5 \"Data_Bits..|.\" and\n  (OCaml) \"Int32.logor\" and\n  (Scala) infixl 1 \"|\"\n| constant \"(XOR) :: uint32 \\<Rightarrow> _\" \\<rightharpoonup>\n  (SML) \"Word32.xorb ((_),/ (_))\" and\n  (Haskell) \"Data'_Bits.xor\" and\n  (OCaml) \"Int32.logxor\" and\n  (Scala) infixl 2 \"^\""], ["", "definition uint32_divmod :: \"uint32 \\<Rightarrow> uint32 \\<Rightarrow> uint32 \\<times> uint32\" where\n  \"uint32_divmod x y = \n  (if y = 0 then (undefined ((div) :: uint32 \\<Rightarrow> _) x (0 :: uint32), undefined ((mod) :: uint32 \\<Rightarrow> _) x (0 :: uint32)) \n  else (x div y, x mod y))\""], ["", "definition uint32_div :: \"uint32 \\<Rightarrow> uint32 \\<Rightarrow> uint32\" \nwhere \"uint32_div x y = fst (uint32_divmod x y)\""], ["", "definition uint32_mod :: \"uint32 \\<Rightarrow> uint32 \\<Rightarrow> uint32\" \nwhere \"uint32_mod x y = snd (uint32_divmod x y)\""], ["", "lemma div_uint32_code [code]: \"x div y = (if y = 0 then 0 else uint32_div x y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x div y = (if y = 0 then 0 else uint32_div x y)", "including undefined_transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. x div y = (if y = 0 then 0 else uint32_div x y)", "unfolding uint32_divmod_def uint32_div_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. x div y =\n    (if y = 0 then 0\n     else fst (if y = 0 then (undefined (div) x 0, undefined (mod) x 0)\n               else (x div y, x mod y)))", "by transfer (simp add: word_div_def)"], ["", "lemma mod_uint32_code [code]: \"x mod y = (if y = 0 then x else uint32_mod x y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x mod y = (if y = 0 then x else uint32_mod x y)", "including undefined_transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. x mod y = (if y = 0 then x else uint32_mod x y)", "unfolding uint32_mod_def uint32_divmod_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. x mod y =\n    (if y = 0 then x\n     else snd (if y = 0 then (undefined (div) x 0, undefined (mod) x 0)\n               else (x div y, x mod y)))", "by transfer (simp add: word_mod_def)"], ["", "definition uint32_sdiv :: \"uint32 \\<Rightarrow> uint32 \\<Rightarrow> uint32\"\nwhere [code del]:\n  \"uint32_sdiv x y =\n   (if y = 0 then undefined ((div) :: uint32 \\<Rightarrow> _) x (0 :: uint32)\n    else Abs_uint32 (Rep_uint32 x sdiv Rep_uint32 y))\""], ["", "definition div0_uint32 :: \"uint32 \\<Rightarrow> uint32\"\nwhere [code del]: \"div0_uint32 x = undefined ((div) :: uint32 \\<Rightarrow> _) x (0 :: uint32)\""], ["", "declare [[code abort: div0_uint32]]"], ["", "definition mod0_uint32 :: \"uint32 \\<Rightarrow> uint32\"\nwhere [code del]: \"mod0_uint32 x = undefined ((mod) :: uint32 \\<Rightarrow> _) x (0 :: uint32)\""], ["", "declare [[code abort: mod0_uint32]]"], ["", "lemma uint32_divmod_code [code]:\n  \"uint32_divmod x y =\n  (if 0x80000000 \\<le> y then if x < y then (0, x) else (1, x - y)\n   else if y = 0 then (div0_uint32 x, mod0_uint32 x)\n   else let q = (uint32_sdiv (drop_bit 1 x) y) << 1;\n            r = x - q * y\n        in if r \\<ge> y then (q + 1, r - y) else (q, r))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. uint32_divmod x y =\n    (if 2147483648 \\<le> y then if x < y then (0, x) else (1, x - y)\n     else if y = 0 then (div0_uint32 x, mod0_uint32 x)\n          else let q = uint32_sdiv (drop_bit 1 x) y << 1; r = x - q * y\n               in if y \\<le> r then (q + 1, r - y) else (q, r))", "including undefined_transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. uint32_divmod x y =\n    (if 2147483648 \\<le> y then if x < y then (0, x) else (1, x - y)\n     else if y = 0 then (div0_uint32 x, mod0_uint32 x)\n          else let q = uint32_sdiv (drop_bit 1 x) y << 1; r = x - q * y\n               in if y \\<le> r then (q + 1, r - y) else (q, r))", "unfolding uint32_divmod_def uint32_sdiv_def div0_uint32_def mod0_uint32_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if y = 0 then (undefined (div) x 0, undefined (mod) x 0)\n     else (x div y, x mod y)) =\n    (if 2147483648 \\<le> y then if x < y then (0, x) else (1, x - y)\n     else if y = 0 then (undefined (div) x 0, undefined (mod) x 0)\n          else let q = (if y = 0 then undefined (div) (drop_bit 1 x) 0\n                        else Abs_uint32\n                              (Rep_uint32 (drop_bit 1 x) sdiv\n                               Rep_uint32 y)) <<\n                       1;\n                   r = x - q * y\n               in if y \\<le> r then (q + 1, r - y) else (q, r))", "by transfer (simp add: divmod_via_sdivmod shiftr_eq_drop_bit shiftl_eq_push_bit ac_simps)"], ["", "lemma uint32_sdiv_code [code abstract]:\n  \"Rep_uint32 (uint32_sdiv x y) =\n   (if y = 0 then Rep_uint32 (undefined ((div) :: uint32 \\<Rightarrow> _) x (0 :: uint32))\n    else Rep_uint32 x sdiv Rep_uint32 y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_uint32 (uint32_sdiv x y) =\n    (if y = 0 then Rep_uint32 (undefined (div) x 0)\n     else Rep_uint32 x sdiv Rep_uint32 y)", "unfolding uint32_sdiv_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_uint32\n     (if y = 0 then undefined (div) x 0\n      else Abs_uint32 (Rep_uint32 x sdiv Rep_uint32 y)) =\n    (if y = 0 then Rep_uint32 (undefined (div) x 0)\n     else Rep_uint32 x sdiv Rep_uint32 y)", "by(simp add: Abs_uint32_inverse)"], ["", "text \\<open>\n  Note that we only need a translation for signed division, but not for the remainder\n  because @{thm uint32_divmod_code} computes both with division only.\n\\<close>"], ["", "code_printing\n  constant uint32_div \\<rightharpoonup>\n  (SML) \"Word32.div ((_), (_))\" and\n  (Haskell) \"Prelude.div\"\n| constant uint32_mod \\<rightharpoonup>\n  (SML) \"Word32.mod ((_), (_))\" and\n  (Haskell) \"Prelude.mod\"\n| constant uint32_divmod \\<rightharpoonup>\n  (Haskell) \"divmod\"\n| constant uint32_sdiv \\<rightharpoonup>\n  (OCaml) \"Int32.div\" and\n  (Scala) \"_ '/ _\""], ["", "definition uint32_test_bit :: \"uint32 \\<Rightarrow> integer \\<Rightarrow> bool\"\nwhere [code del]:\n  \"uint32_test_bit x n =\n  (if n < 0 \\<or> 31 < n then undefined (bit :: uint32 \\<Rightarrow> _) x n\n   else bit x (nat_of_integer n))\""], ["", "lemma test_bit_uint32_code [code]:\n  \"bit x n \\<longleftrightarrow> n < 32 \\<and> uint32_test_bit x (integer_of_nat n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bit x n = (n < 32 \\<and> uint32_test_bit x (integer_of_nat n))", "including undefined_transfer integer.lifting"], ["proof (prove)\ngoal (1 subgoal):\n 1. bit x n = (n < 32 \\<and> uint32_test_bit x (integer_of_nat n))", "unfolding uint32_test_bit_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. bit x n =\n    (n < 32 \\<and>\n     (if integer_of_nat n < 0 \\<or> 31 < integer_of_nat n\n      then undefined bit x (integer_of_nat n)\n      else bit x (nat_of_integer (integer_of_nat n))))", "by (transfer, simp, transfer, simp)"], ["", "lemma uint32_test_bit_code [code]:\n  \"uint32_test_bit w n =\n  (if n < 0 \\<or> 31 < n then undefined (bit :: uint32 \\<Rightarrow> _) w n else bit (Rep_uint32 w) (nat_of_integer n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. uint32_test_bit w n =\n    (if n < 0 \\<or> 31 < n then undefined bit w n\n     else bit (Rep_uint32 w) (nat_of_integer n))", "unfolding uint32_test_bit_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if n < 0 \\<or> 31 < n then undefined bit w n\n     else bit w (nat_of_integer n)) =\n    (if n < 0 \\<or> 31 < n then undefined bit w n\n     else bit (Rep_uint32 w) (nat_of_integer n))", "by(simp add: bit_uint32.rep_eq)"], ["", "code_printing constant uint32_test_bit \\<rightharpoonup>\n  (SML) \"Uint32.test'_bit\" and\n  (Haskell) \"Data'_Bits.testBitBounded\" and\n  (OCaml) \"Uint32.test'_bit\" and\n  (Scala) \"Uint32.test'_bit\" and\n  (Eval) \"(fn w => fn n => if n < 0 orelse 32 <= n then raise (Fail \\\"argument to uint32'_test'_bit out of bounds\\\") else Uint32.test'_bit w n)\""], ["", "definition uint32_set_bit :: \"uint32 \\<Rightarrow> integer \\<Rightarrow> bool \\<Rightarrow> uint32\"\nwhere [code del]:\n  \"uint32_set_bit x n b =\n  (if n < 0 \\<or> 31 < n then undefined (set_bit :: uint32 \\<Rightarrow> _) x n b\n   else set_bit x (nat_of_integer n) b)\""], ["", "lemma set_bit_uint32_code [code]:\n  \"set_bit x n b = (if n < 32 then uint32_set_bit x (integer_of_nat n) b else x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_bit_class.set_bit x n b =\n    (if n < 32 then uint32_set_bit x (integer_of_nat n) b else x)", "including undefined_transfer integer.lifting"], ["proof (prove)\ngoal (1 subgoal):\n 1. set_bit_class.set_bit x n b =\n    (if n < 32 then uint32_set_bit x (integer_of_nat n) b else x)", "unfolding uint32_set_bit_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. set_bit_class.set_bit x n b =\n    (if n < 32\n     then if integer_of_nat n < 0 \\<or> 31 < integer_of_nat n\n          then undefined set_bit_class.set_bit x (integer_of_nat n) b\n          else set_bit_class.set_bit x (nat_of_integer (integer_of_nat n)) b\n     else x)", "by(transfer)(auto cong: conj_cong simp add: not_less set_bit_beyond word_size)"], ["", "lemma uint32_set_bit_code [code abstract]:\n  \"Rep_uint32 (uint32_set_bit w n b) = \n  (if n < 0 \\<or> 31 < n then Rep_uint32 (undefined (set_bit :: uint32 \\<Rightarrow> _) w n b)\n   else set_bit (Rep_uint32 w) (nat_of_integer n) b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_uint32 (uint32_set_bit w n b) =\n    (if n < 0 \\<or> 31 < n\n     then Rep_uint32 (undefined set_bit_class.set_bit w n b)\n     else set_bit_class.set_bit (Rep_uint32 w) (nat_of_integer n) b)", "including undefined_transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_uint32 (uint32_set_bit w n b) =\n    (if n < 0 \\<or> 31 < n\n     then Rep_uint32 (undefined set_bit_class.set_bit w n b)\n     else set_bit_class.set_bit (Rep_uint32 w) (nat_of_integer n) b)", "unfolding uint32_set_bit_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_uint32\n     (if n < 0 \\<or> 31 < n then undefined set_bit_class.set_bit w n b\n      else set_bit_class.set_bit w (nat_of_integer n) b) =\n    (if n < 0 \\<or> 31 < n\n     then Rep_uint32 (undefined set_bit_class.set_bit w n b)\n     else set_bit_class.set_bit (Rep_uint32 w) (nat_of_integer n) b)", "by transfer simp"], ["", "code_printing constant uint32_set_bit \\<rightharpoonup>\n  (SML) \"Uint32.set'_bit\" and\n  (Haskell) \"Data'_Bits.setBitBounded\" and\n  (OCaml) \"Uint32.set'_bit\" and\n  (Scala) \"Uint32.set'_bit\" and\n  (Eval) \"(fn w => fn n => fn b => if n < 0 orelse 32 <= n then raise (Fail \\\"argument to uint32'_set'_bit out of bounds\\\") else Uint32.set'_bit x n b)\""], ["", "lift_definition uint32_set_bits :: \"(nat \\<Rightarrow> bool) \\<Rightarrow> uint32 \\<Rightarrow> nat \\<Rightarrow> uint32\" is set_bits_aux"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma uint32_set_bits_code [code]:\n  \"uint32_set_bits f w n =\n  (if n = 0 then w \n   else let n' = n - 1 in uint32_set_bits f (push_bit 1 w OR (if f n' then 1 else 0)) n')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. uint32_set_bits f w n =\n    (if n = 0 then w\n     else let n' = n - 1\n          in uint32_set_bits f (push_bit 1 w OR (if f n' then 1 else 0)) n')", "apply (transfer fixing: n)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f w.\n       set_bits_aux f w n =\n       (if n = 0 then w\n        else let n' = n - 1\n             in set_bits_aux f (push_bit 1 w OR (if f n' then 1 else 0)) n')", "apply (cases n)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>f w.\n       n = 0 \\<Longrightarrow>\n       set_bits_aux f w n =\n       (if n = 0 then w\n        else let n' = n - 1\n             in set_bits_aux f (push_bit 1 w OR (if f n' then 1 else 0)) n')\n 2. \\<And>f w nat.\n       n = Suc nat \\<Longrightarrow>\n       set_bits_aux f w n =\n       (if n = 0 then w\n        else let n' = n - 1\n             in set_bits_aux f (push_bit 1 w OR (if f n' then 1 else 0)) n')", "apply (simp_all add: shiftl_eq_push_bit)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma set_bits_uint32 [code]:\n  \"(BITS n. f n) = uint32_set_bits f 0 32\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (BITS n. f n) = uint32_set_bits f 0 32", "by transfer(simp add: set_bits_conv_set_bits_aux)"], ["", "lemma lsb_code [code]: fixes x :: uint32 shows \"lsb x \\<longleftrightarrow> bit x 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lsb x = bit x 0", "by transfer (simp add: lsb_word_eq)"], ["", "definition uint32_shiftl :: \"uint32 \\<Rightarrow> integer \\<Rightarrow> uint32\"\nwhere [code del]:\n  \"uint32_shiftl x n = (if n < 0 \\<or> 32 \\<le> n then undefined (push_bit :: nat \\<Rightarrow> uint32 \\<Rightarrow> _) x n else push_bit (nat_of_integer n) x)\""], ["", "lemma shiftl_uint32_code [code]: \"push_bit n x = (if n < 32 then uint32_shiftl x (integer_of_nat n) else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. push_bit n x =\n    (if n < 32 then uint32_shiftl x (integer_of_nat n) else 0)", "including undefined_transfer integer.lifting"], ["proof (prove)\ngoal (1 subgoal):\n 1. push_bit n x =\n    (if n < 32 then uint32_shiftl x (integer_of_nat n) else 0)", "unfolding uint32_shiftl_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. push_bit n x =\n    (if n < 32\n     then if integer_of_nat n < 0 \\<or> 32 \\<le> integer_of_nat n\n          then undefined push_bit x (integer_of_nat n)\n          else push_bit (nat_of_integer (integer_of_nat n)) x\n     else 0)", "by transfer simp"], ["", "lemma uint32_shiftl_code [code abstract]:\n  \"Rep_uint32 (uint32_shiftl w n) =\n  (if n < 0 \\<or> 32 \\<le> n then Rep_uint32 (undefined (push_bit :: nat \\<Rightarrow> uint32 \\<Rightarrow> _) w n) else push_bit (nat_of_integer n) (Rep_uint32 w))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_uint32 (uint32_shiftl w n) =\n    (if n < 0 \\<or> 32 \\<le> n then Rep_uint32 (undefined push_bit w n)\n     else push_bit (nat_of_integer n) (Rep_uint32 w))", "including undefined_transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_uint32 (uint32_shiftl w n) =\n    (if n < 0 \\<or> 32 \\<le> n then Rep_uint32 (undefined push_bit w n)\n     else push_bit (nat_of_integer n) (Rep_uint32 w))", "unfolding uint32_shiftl_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_uint32\n     (if n < 0 \\<or> 32 \\<le> n then undefined push_bit w n\n      else push_bit (nat_of_integer n) w) =\n    (if n < 0 \\<or> 32 \\<le> n then Rep_uint32 (undefined push_bit w n)\n     else push_bit (nat_of_integer n) (Rep_uint32 w))", "by transfer (simp add: shiftl_eq_push_bit)"], ["", "code_printing constant uint32_shiftl \\<rightharpoonup>\n  (SML) \"Uint32.shiftl\" and\n  (Haskell) \"Data'_Bits.shiftlBounded\" and\n  (OCaml) \"Uint32.shiftl\" and\n  (Scala) \"Uint32.shiftl\" and\n  (Eval) \"(fn x => fn i => if i < 0 orelse i >= 32 then raise Fail \\\"argument to uint32'_shiftl out of bounds\\\" else Uint32.shiftl x i)\""], ["", "definition uint32_shiftr :: \"uint32 \\<Rightarrow> integer \\<Rightarrow> uint32\"\nwhere [code del]:\n  \"uint32_shiftr x n = (if n < 0 \\<or> 32 \\<le> n then undefined (drop_bit :: nat \\<Rightarrow> uint32 \\<Rightarrow> _) x n else drop_bit (nat_of_integer n) x)\""], ["", "lemma shiftr_uint32_code [code]: \"drop_bit n x = (if n < 32 then uint32_shiftr x (integer_of_nat n) else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. drop_bit n x =\n    (if n < 32 then uint32_shiftr x (integer_of_nat n) else 0)", "including undefined_transfer integer.lifting"], ["proof (prove)\ngoal (1 subgoal):\n 1. drop_bit n x =\n    (if n < 32 then uint32_shiftr x (integer_of_nat n) else 0)", "unfolding uint32_shiftr_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. drop_bit n x =\n    (if n < 32\n     then if integer_of_nat n < 0 \\<or> 32 \\<le> integer_of_nat n\n          then undefined drop_bit x (integer_of_nat n)\n          else drop_bit (nat_of_integer (integer_of_nat n)) x\n     else 0)", "by transfer simp"], ["", "lemma uint32_shiftr_code [code abstract]:\n  \"Rep_uint32 (uint32_shiftr w n) =\n  (if n < 0 \\<or> 32 \\<le> n then Rep_uint32 (undefined (drop_bit :: nat \\<Rightarrow> uint32 \\<Rightarrow> _) w n) else drop_bit (nat_of_integer n) (Rep_uint32 w))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_uint32 (uint32_shiftr w n) =\n    (if n < 0 \\<or> 32 \\<le> n then Rep_uint32 (undefined drop_bit w n)\n     else drop_bit (nat_of_integer n) (Rep_uint32 w))", "including undefined_transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_uint32 (uint32_shiftr w n) =\n    (if n < 0 \\<or> 32 \\<le> n then Rep_uint32 (undefined drop_bit w n)\n     else drop_bit (nat_of_integer n) (Rep_uint32 w))", "unfolding uint32_shiftr_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_uint32\n     (if n < 0 \\<or> 32 \\<le> n then undefined drop_bit w n\n      else drop_bit (nat_of_integer n) w) =\n    (if n < 0 \\<or> 32 \\<le> n then Rep_uint32 (undefined drop_bit w n)\n     else drop_bit (nat_of_integer n) (Rep_uint32 w))", "by transfer simp"], ["", "code_printing constant uint32_shiftr \\<rightharpoonup>\n  (SML) \"Uint32.shiftr\" and\n  (Haskell) \"Data'_Bits.shiftrBounded\" and\n  (OCaml) \"Uint32.shiftr\" and\n  (Scala) \"Uint32.shiftr\" and\n  (Eval) \"(fn x => fn i => if i < 0 orelse i >= 32 then raise Fail \\\"argument to uint32'_shiftr out of bounds\\\" else Uint32.shiftr x i)\""], ["", "definition uint32_sshiftr :: \"uint32 \\<Rightarrow> integer \\<Rightarrow> uint32\"\nwhere [code del]:\n  \"uint32_sshiftr x n =\n  (if n < 0 \\<or> 32 \\<le> n then undefined sshiftr_uint32 x n else sshiftr_uint32 x (nat_of_integer n))\""], ["", "lemma sshiftr_uint32_code [code]:\n  \"x >>> n = \n  (if n < 32 then uint32_sshiftr x (integer_of_nat n) else if bit x 31 then - 1 else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x >>> n =\n    (if n < 32 then uint32_sshiftr x (integer_of_nat n)\n     else if bit x 31 then - 1 else 0)", "including undefined_transfer integer.lifting"], ["proof (prove)\ngoal (1 subgoal):\n 1. x >>> n =\n    (if n < 32 then uint32_sshiftr x (integer_of_nat n)\n     else if bit x 31 then - 1 else 0)", "unfolding uint32_sshiftr_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. x >>> n =\n    (if n < 32\n     then if integer_of_nat n < 0 \\<or> 32 \\<le> integer_of_nat n\n          then undefined (>>>) x (integer_of_nat n)\n          else x >>> nat_of_integer (integer_of_nat n)\n     else if bit x 31 then - 1 else 0)", "by transfer (simp add: not_less signed_drop_bit_beyond)"], ["", "lemma uint32_sshiftr_code [code abstract]:\n  \"Rep_uint32 (uint32_sshiftr w n) =\n  (if n < 0 \\<or> 32 \\<le> n then Rep_uint32 (undefined sshiftr_uint32 w n) else signed_drop_bit (nat_of_integer n) (Rep_uint32 w))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_uint32 (uint32_sshiftr w n) =\n    (if n < 0 \\<or> 32 \\<le> n then Rep_uint32 (undefined (>>>) w n)\n     else signed_drop_bit (nat_of_integer n) (Rep_uint32 w))", "including undefined_transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_uint32 (uint32_sshiftr w n) =\n    (if n < 0 \\<or> 32 \\<le> n then Rep_uint32 (undefined (>>>) w n)\n     else signed_drop_bit (nat_of_integer n) (Rep_uint32 w))", "unfolding uint32_sshiftr_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_uint32\n     (if n < 0 \\<or> 32 \\<le> n then undefined (>>>) w n\n      else w >>> nat_of_integer n) =\n    (if n < 0 \\<or> 32 \\<le> n then Rep_uint32 (undefined (>>>) w n)\n     else signed_drop_bit (nat_of_integer n) (Rep_uint32 w))", "by transfer simp"], ["", "code_printing constant uint32_sshiftr \\<rightharpoonup>\n  (SML) \"Uint32.shiftr'_signed\" and\n  (Haskell) \n    \"(Prelude.fromInteger (Prelude.toInteger (Data'_Bits.shiftrBounded (Prelude.fromInteger (Prelude.toInteger _) :: Uint32.Int32) _)) :: Uint32.Word32)\" and\n  (OCaml) \"Uint32.shiftr'_signed\" and\n  (Scala) \"Uint32.shiftr'_signed\" and\n  (Eval) \"(fn x => fn i => if i < 0 orelse i >= 32 then raise Fail \\\"argument to uint32'_shiftr'_signed out of bounds\\\" else Uint32.shiftr'_signed x i)\""], ["", "lemma uint32_msb_test_bit: \"msb x \\<longleftrightarrow> bit (x :: uint32) 31\""], ["proof (prove)\ngoal (1 subgoal):\n 1. msb x = bit x 31", "by transfer (simp add: msb_word_iff_bit)"], ["", "lemma msb_uint32_code [code]: \"msb x \\<longleftrightarrow> uint32_test_bit x 31\""], ["proof (prove)\ngoal (1 subgoal):\n 1. msb x = uint32_test_bit x 31", "by (simp add: uint32_test_bit_def uint32_msb_test_bit)"], ["", "lemma uint32_of_int_code [code]: \"uint32_of_int i = Uint32 (integer_of_int i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. uint32_of_int i = Uint32 (integer_of_int i)", "including integer.lifting"], ["proof (prove)\ngoal (1 subgoal):\n 1. uint32_of_int i = Uint32 (integer_of_int i)", "by transfer simp"], ["", "lemma int_of_uint32_code [code]:\n  \"int_of_uint32 x = int_of_integer (integer_of_uint32 x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int_of_uint32 x = int_of_integer (integer_of_uint32 x)", "by(simp add: integer_of_uint32_def)"], ["", "lemma nat_of_uint32_code [code]:\n  \"nat_of_uint32 x = nat_of_integer (integer_of_uint32 x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nat_of_uint32 x = nat_of_integer (integer_of_uint32 x)", "unfolding integer_of_uint32_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. nat_of_uint32 x =\n    nat_of_integer ((integer_of_int \\<circ> int_of_uint32) x)", "including integer.lifting"], ["proof (prove)\ngoal (1 subgoal):\n 1. nat_of_uint32 x =\n    nat_of_integer ((integer_of_int \\<circ> int_of_uint32) x)", "by transfer simp"], ["", "definition integer_of_uint32_signed :: \"uint32 \\<Rightarrow> integer\"\nwhere\n  \"integer_of_uint32_signed n = (if bit n 31 then undefined integer_of_uint32 n else integer_of_uint32 n)\""], ["", "lemma integer_of_uint32_signed_code [code]:\n  \"integer_of_uint32_signed n =\n  (if bit n 31 then undefined integer_of_uint32 n else integer_of_int (uint (Rep_uint32' n)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. integer_of_uint32_signed n =\n    (if bit n 31 then undefined integer_of_uint32 n\n     else integer_of_int (uint (Rep_uint32' n)))", "unfolding integer_of_uint32_signed_def integer_of_uint32_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if bit n 31 then undefined (integer_of_int \\<circ> int_of_uint32) n\n     else (integer_of_int \\<circ> int_of_uint32) n) =\n    (if bit n 31 then undefined (integer_of_int \\<circ> int_of_uint32) n\n     else integer_of_int (uint (Rep_uint32' n)))", "including undefined_transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if bit n 31 then undefined (integer_of_int \\<circ> int_of_uint32) n\n     else (integer_of_int \\<circ> int_of_uint32) n) =\n    (if bit n 31 then undefined (integer_of_int \\<circ> int_of_uint32) n\n     else integer_of_int (uint (Rep_uint32' n)))", "by transfer simp"], ["", "lemma integer_of_uint32_code [code]:\n  \"integer_of_uint32 n =\n  (if bit n 31 then integer_of_uint32_signed (n AND 0x7FFFFFFF) OR 0x80000000 else integer_of_uint32_signed n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. integer_of_uint32 n =\n    (if bit n 31\n     then integer_of_uint32_signed (n AND 2147483647) OR 2147483648\n     else integer_of_uint32_signed n)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. integer_of_uint32 n =\n    (if bit n 31\n     then integer_of_uint32_signed (n AND 2147483647) OR 2147483648\n     else integer_of_uint32_signed n)", "have \\<open>(0x7FFFFFFF :: uint32) = mask 31\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. 2147483647 = mask 31", "by (simp add: mask_eq_exp_minus_1)"], ["proof (state)\nthis:\n  2147483647 = mask 31\n\ngoal (1 subgoal):\n 1. integer_of_uint32 n =\n    (if bit n 31\n     then integer_of_uint32_signed (n AND 2147483647) OR 2147483648\n     else integer_of_uint32_signed n)", "then"], ["proof (chain)\npicking this:\n  2147483647 = mask 31", "have *: \\<open>n AND 0x7FFFFFFF = take_bit 31 n\\<close>"], ["proof (prove)\nusing this:\n  2147483647 = mask 31\n\ngoal (1 subgoal):\n 1. n AND 2147483647 = take_bit 31 n", "by (simp add: take_bit_eq_mask)"], ["proof (state)\nthis:\n  n AND 2147483647 = take_bit 31 n\n\ngoal (1 subgoal):\n 1. integer_of_uint32 n =\n    (if bit n 31\n     then integer_of_uint32_signed (n AND 2147483647) OR 2147483648\n     else integer_of_uint32_signed n)", "have **: \\<open>(0x80000000 :: int) = 2 ^ 31\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. 2147483648 = 2 ^ 31", "by simp"], ["proof (state)\nthis:\n  2147483648 = 2 ^ 31\n\ngoal (1 subgoal):\n 1. integer_of_uint32 n =\n    (if bit n 31\n     then integer_of_uint32_signed (n AND 2147483647) OR 2147483648\n     else integer_of_uint32_signed n)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. integer_of_uint32 n =\n    (if bit n 31\n     then integer_of_uint32_signed (n AND 2147483647) OR 2147483648\n     else integer_of_uint32_signed n)", "unfolding integer_of_uint32_def integer_of_uint32_signed_def o_def *"], ["proof (prove)\ngoal (1 subgoal):\n 1. integer_of_int (int_of_uint32 n) =\n    (if bit n 31\n     then (if bit (take_bit 31 n) 31\n           then undefined (\\<lambda>x. integer_of_int (int_of_uint32 x))\n                 (take_bit 31 n)\n           else integer_of_int (int_of_uint32 (take_bit 31 n))) OR\n          2147483648\n     else if bit n 31\n          then undefined (\\<lambda>x. integer_of_int (int_of_uint32 x)) n\n          else integer_of_int (int_of_uint32 n))", "including undefined_transfer integer.lifting"], ["proof (prove)\ngoal (1 subgoal):\n 1. integer_of_int (int_of_uint32 n) =\n    (if bit n 31\n     then (if bit (take_bit 31 n) 31\n           then undefined (\\<lambda>x. integer_of_int (int_of_uint32 x))\n                 (take_bit 31 n)\n           else integer_of_int (int_of_uint32 (take_bit 31 n))) OR\n          2147483648\n     else if bit n 31\n          then undefined (\\<lambda>x. integer_of_int (int_of_uint32 x)) n\n          else integer_of_int (int_of_uint32 n))", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       uint n =\n       (if bit n 31\n        then (if bit (take_bit 31 n) 31\n              then map_fun (map_fun Rep_uint32 integer_of_int)\n                    (map_fun Abs_uint32 int_of_integer) undefined uint\n                    (take_bit 31 n)\n              else uint (take_bit 31 n)) OR\n             2147483648\n        else if bit n 31\n             then map_fun (map_fun Rep_uint32 integer_of_int)\n                   (map_fun Abs_uint32 int_of_integer) undefined uint n\n             else uint n)", "apply (rule bit_eqI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n na.\n       2 ^ na \\<noteq> 0 \\<Longrightarrow>\n       bit (uint n) na =\n       bit (if bit n 31\n            then (if bit (take_bit 31 n) 31\n                  then map_fun (map_fun Rep_uint32 integer_of_int)\n                        (map_fun Abs_uint32 int_of_integer) undefined uint\n                        (take_bit 31 n)\n                  else uint (take_bit 31 n)) OR\n                 2147483648\n            else if bit n 31\n                 then map_fun (map_fun Rep_uint32 integer_of_int)\n                       (map_fun Abs_uint32 int_of_integer) undefined uint n\n                 else uint n)\n        na", "apply (simp add: test_bit_eq_bit bit_or_iff bit_take_bit_iff bit_uint_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n na.\n       bit n 31 \\<longrightarrow>\n       (na < 32 \\<and> bit n na) =\n       (na < 32 \\<and> na < 31 \\<and> bit n na \\<or> bit 2147483648 na)", "apply (simp only: bit_exp_iff bit_or_iff **)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n na.\n       bit n 31 \\<longrightarrow>\n       (na < 32 \\<and> bit n na) =\n       (na < 32 \\<and> na < 31 \\<and> bit n na \\<or>\n        2 ^ 31 \\<noteq> 0 \\<and> 31 = na)", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  integer_of_uint32 n =\n  (if bit n 31\n   then integer_of_uint32_signed (n AND 2147483647) OR 2147483648\n   else integer_of_uint32_signed n)\n\ngoal:\nNo subgoals!", "qed"], ["", "code_printing\n  constant \"integer_of_uint32\" \\<rightharpoonup>\n  (SML) \"IntInf.fromLarge (Word32.toLargeInt _) : IntInf.int\" and\n  (Haskell) \"Prelude.toInteger\"\n| constant \"integer_of_uint32_signed\" \\<rightharpoonup>\n  (OCaml) \"Z.of'_int32\" and\n  (Scala) \"BigInt\""], ["", "section \\<open>Quickcheck setup\\<close>"], ["", "definition uint32_of_natural :: \"natural \\<Rightarrow> uint32\"\nwhere \"uint32_of_natural x \\<equiv> Uint32 (integer_of_natural x)\""], ["", "instantiation uint32 :: \"{random, exhaustive, full_exhaustive}\" begin"], ["", "definition \"random_uint32 \\<equiv> qc_random_cnv uint32_of_natural\""], ["", "definition \"exhaustive_uint32 \\<equiv> qc_exhaustive_cnv uint32_of_natural\""], ["", "definition \"full_exhaustive_uint32 \\<equiv> qc_full_exhaustive_cnv uint32_of_natural\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(uint32, exhaustive_class) &&&\n    OFCLASS(uint32, full_exhaustive_class) &&& OFCLASS(uint32, random_class)", ".."], ["", "end"], ["", "instantiation uint32 :: narrowing begin"], ["", "interpretation quickcheck_narrowing_samples\n  \"\\<lambda>i. let x = Uint32 i in (x, 0xFFFFFFFF - x)\" \"0\"\n  \"Typerep.Typerep (STR ''Uint32.uint32'') []\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "definition \"narrowing_uint32 d = qc_narrowing_drawn_from (narrowing_samples d) d\""], ["", "declare [[code drop: \"partial_term_of :: uint32 itself \\<Rightarrow> _\"]]"], ["", "lemmas partial_term_of_uint32 [code] = partial_term_of_code"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(uint32, narrowing_class)", ".."], ["", "end"], ["", "no_notation sshiftr_uint32 (infixl \">>>\" 55)"], ["", "end"]]}