{"file_name": "/home/qj213/afp-2021-10-22/thys/Rank_Nullity_Theorem/Dim_Formula.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Rank_Nullity_Theorem", "problem_names": ["lemma dependent_mono:\n  assumes d:\"dependent A\"\n  and A_in_B: \"A \\<subseteq> B\"\n  shows  \"dependent B\"", "lemma scalars_zero_if_independent:\n  assumes fin_A: \"finite A\"\n  and ind: \"independent A\"\n  and sum: \"(\\<Sum>x\\<in>A. scale (f x) x) = 0\"\n  shows \"\\<forall>x \\<in> A. f x = 0\"", "lemma inj_on_extended:\n  assumes lf: \"Vector_Spaces.linear scaleB scaleC f\"\n  and f: \"finite C\"\n  and ind_C: \"independent C\"\n  and C_eq: \"C = B \\<union> W\"\n  and disj_set: \"B \\<inter> W = {}\"\n  and span_B: \"{x. f x = 0} \\<subseteq> span B\"\n  shows \"inj_on f W\"\n  \\<comment> \\<open>The proof is carried out by reductio ad absurdum\\<close>", "theorem rank_nullity_theorem:\n  assumes l: \"Vector_Spaces.linear scale scaleC f\"\n  shows \"dimension = dim {x. f x = 0} + vector_space.dim scaleC (range f)\"", "lemma rank_nullity_theorem_matrices:\n  fixes A::\"'a::{field}^'cols::{finite, wellorder}^'rows\"\n  shows \"ncols A = vec.dim (null_space A) + vec.dim (col_space A)\""], "translations": [["", "lemma dependent_mono:\n  assumes d:\"dependent A\"\n  and A_in_B: \"A \\<subseteq> B\"\n  shows  \"dependent B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.dependent B", "using independent_mono [OF _ A_in_B] d"], ["proof (prove)\nusing this:\n  local.independent B \\<Longrightarrow> local.independent A\n  local.dependent A\n\ngoal (1 subgoal):\n 1. local.dependent B", "by auto"], ["", "text\\<open>Given a finite independent set, a linear combination of its \n  elements equal to zero is possible only if every coefficient is zero:\\<close>"], ["", "lemma scalars_zero_if_independent:\n  assumes fin_A: \"finite A\"\n  and ind: \"independent A\"\n  and sum: \"(\\<Sum>x\\<in>A. scale (f x) x) = 0\"\n  shows \"\\<forall>x \\<in> A. f x = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>A. f x = (0::'a)", "using fin_A ind local.dependent_finite sum"], ["proof (prove)\nusing this:\n  finite A\n  local.independent A\n  finite ?S \\<Longrightarrow>\n  local.dependent ?S =\n  (\\<exists>u.\n      (\\<exists>v\\<in>?S. u v \\<noteq> (0::'a)) \\<and>\n      (\\<Sum>v\\<in>?S. u v *s v) = (0::'b))\n  (\\<Sum>x\\<in>A. f x *s x) = (0::'b)\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>A. f x = (0::'a)", "by blast"], ["", "end"], ["", "context finite_dimensional_vector_space\nbegin"], ["", "text\\<open>In an finite dimensional vector space, every independent set is finite, and \n  thus @{thm [display ]scalars_zero_if_independent [no_vars]} holds:\\<close>"], ["", "corollary scalars_zero_if_independent_euclidean:\n  assumes ind: \"independent A\"\n    and sum: \"(\\<Sum>x\\<in>A. scale (f x) x) = 0\"\n  shows \"\\<forall>x \\<in> A. f x = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>A. f x = (0::'a)", "using finiteI_independent ind scalars_zero_if_independent sum"], ["proof (prove)\nusing this:\n  local.independent ?B \\<Longrightarrow> finite ?B\n  local.independent A\n  \\<lbrakk>finite ?A; local.independent ?A;\n   (\\<Sum>x\\<in>?A. ?f x *s x) = (0::'b)\\<rbrakk>\n  \\<Longrightarrow> \\<forall>x\\<in>?A. ?f x = (0::'a)\n  (\\<Sum>x\\<in>A. f x *s x) = (0::'b)\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>A. f x = (0::'a)", "by blast"], ["", "end"], ["", "text\\<open>The following lemma states that every linear form is injective over the \n  elements which define the basis of the range of the linear form. \n  This property is applied later over the elements of an arbitrary \n  basis which are not in the basis of the nullifier or kernel set \n  (\\emph{i.e.}, the candidates to be the basis of the range space \n  of the linear form).\\<close>"], ["", "text\\<open>Thanks to this result, it can be concluded that the cardinal \n  of the elements of a basis which do not belong to the kernel \n  of a linear form @{term \"f::'a => 'b\"} is equal to the cardinal \n  of the set obtained when applying @{term \"f::'a => 'b\"} to such elements.\\<close>"], ["", "text\\<open>The application of this lemma is not usually found in the pencil and paper \n  proofs of the ``rank nullity theorem'', but will be crucial to know that,\n  being @{term \"f::'a => 'b\"} a linear form from a finite dimensional\n  vector space @{term \"V\"} to a vector space @{term \"V'\"}, \n  and given a basis @{term \"B::'a set\"} of @{term \"ker f\"}, \n  when @{term \"B\"} is completed up to a basis of @{term \"V::'a set\"}\n  with a set @{term \"W::'a set\"}, the cardinal of this set is\n  equal to the cardinal of its range set:\\<close>"], ["", "context vector_space\nbegin"], ["", "lemma inj_on_extended:\n  assumes lf: \"Vector_Spaces.linear scaleB scaleC f\"\n  and f: \"finite C\"\n  and ind_C: \"independent C\"\n  and C_eq: \"C = B \\<union> W\"\n  and disj_set: \"B \\<inter> W = {}\"\n  and span_B: \"{x. f x = 0} \\<subseteq> span B\"\n  shows \"inj_on f W\"\n  \\<comment> \\<open>The proof is carried out by reductio ad absurdum\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on f W", "proof (unfold inj_on_def, rule+, rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> W; y \\<in> W; f x = f y; x \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> False", "interpret lf: Vector_Spaces.linear scaleB scaleC f"], ["proof (prove)\ngoal (1 subgoal):\n 1. linear scaleB scaleC f", "using lf"], ["proof (prove)\nusing this:\n  linear scaleB scaleC f\n\ngoal (1 subgoal):\n 1. linear scaleB scaleC f", "by simp\n  \\<comment> \\<open>Some previous consequences of the premises that are used later:\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> W; y \\<in> W; f x = f y; x \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> False", "have fin_B: \"finite B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite B", "using finite_subset [OF _ f] C_eq"], ["proof (prove)\nusing this:\n  ?A \\<subseteq> C \\<Longrightarrow> finite ?A\n  C = B \\<union> W\n\ngoal (1 subgoal):\n 1. finite B", "by simp"], ["proof (state)\nthis:\n  finite B\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> W; y \\<in> W; f x = f y; x \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> False", "have ind_B: \"independent B\" and ind_W: \"independent W\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.independent B &&& local.independent W", "using independent_mono[OF ind_C] C_eq"], ["proof (prove)\nusing this:\n  ?B \\<subseteq> C \\<Longrightarrow> local.independent ?B\n  C = B \\<union> W\n\ngoal (1 subgoal):\n 1. local.independent B &&& local.independent W", "by simp_all\n  \\<comment> \\<open>The proof starts here; we assume that there exist two different elements\\<close>\n  \\<comment> \\<open>with the same image:\\<close>"], ["proof (state)\nthis:\n  local.independent B\n  local.independent W\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> W; y \\<in> W; f x = f y; x \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> False", "fix x::'b and y::'b"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> W; y \\<in> W; f x = f y; x \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> False", "assume x: \"x \\<in> W\" and y: \"y \\<in> W\" and f_eq: \"f x = f y\" and x_not_y: \"x \\<noteq> y\""], ["proof (state)\nthis:\n  x \\<in> W\n  y \\<in> W\n  f x = f y\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> W; y \\<in> W; f x = f y; x \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> False", "have fin_yB: \"finite (insert y B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (insert y B)", "using fin_B"], ["proof (prove)\nusing this:\n  finite B\n\ngoal (1 subgoal):\n 1. finite (insert y B)", "by simp"], ["proof (state)\nthis:\n  finite (insert y B)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> W; y \\<in> W; f x = f y; x \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> False", "have \"f (x - y) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f (x - y) = (0::'d)", "by (metis diff_self f_eq lf.diff)"], ["proof (state)\nthis:\n  f (x - y) = (0::'d)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> W; y \\<in> W; f x = f y; x \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> False", "hence \"x - y \\<in> {x. f x = 0}\""], ["proof (prove)\nusing this:\n  f (x - y) = (0::'d)\n\ngoal (1 subgoal):\n 1. x - y \\<in> {x. f x = (0::'d)}", "by simp"], ["proof (state)\nthis:\n  x - y \\<in> {x. f x = (0::'d)}\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> W; y \\<in> W; f x = f y; x \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> False", "hence \"\\<exists>g. (\\<Sum>v\\<in>B. scale (g v) v) = (x - y)\""], ["proof (prove)\nusing this:\n  x - y \\<in> {x. f x = (0::'d)}\n\ngoal (1 subgoal):\n 1. \\<exists>g. (\\<Sum>v\\<in>B. g v *s v) = x - y", "using span_B"], ["proof (prove)\nusing this:\n  x - y \\<in> {x. f x = (0::'d)}\n  {x. f x = (0::'d)} \\<subseteq> local.span B\n\ngoal (1 subgoal):\n 1. \\<exists>g. (\\<Sum>v\\<in>B. g v *s v) = x - y", "unfolding span_finite [OF fin_B]"], ["proof (prove)\nusing this:\n  x - y \\<in> {x. f x = (0::'d)}\n  {x. f x = (0::'d)} \\<subseteq> range (\\<lambda>u. \\<Sum>v\\<in>B. u v *s v)\n\ngoal (1 subgoal):\n 1. \\<exists>g. (\\<Sum>v\\<in>B. g v *s v) = x - y", "by force"], ["proof (state)\nthis:\n  \\<exists>g. (\\<Sum>v\\<in>B. g v *s v) = x - y\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> W; y \\<in> W; f x = f y; x \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<exists>g. (\\<Sum>v\\<in>B. g v *s v) = x - y", "obtain g where sum: \"(\\<Sum>v\\<in>B. scale (g v) v) = (x - y)\""], ["proof (prove)\nusing this:\n  \\<exists>g. (\\<Sum>v\\<in>B. g v *s v) = x - y\n\ngoal (1 subgoal):\n 1. (\\<And>g.\n        (\\<Sum>v\\<in>B. g v *s v) = x - y \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast\n  \\<comment> \\<open>We define one of the elements as a linear combination of the second \n      element and the ones in $B$\\<close>"], ["proof (state)\nthis:\n  (\\<Sum>v\\<in>B. g v *s v) = x - y\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> W; y \\<in> W; f x = f y; x \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> False", "define h :: \"'b \\<Rightarrow> 'a\" where \"h a = (if a = y then 1 else g a)\" for a"], ["proof (state)\nthis:\n  h ?a = (if ?a = y then 1::'a else g ?a)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> W; y \\<in> W; f x = f y; x \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> False", "have \"x = y + (\\<Sum>v\\<in>B. scale (g v) v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = y + (\\<Sum>v\\<in>B. g v *s v)", "using sum"], ["proof (prove)\nusing this:\n  (\\<Sum>v\\<in>B. g v *s v) = x - y\n\ngoal (1 subgoal):\n 1. x = y + (\\<Sum>v\\<in>B. g v *s v)", "by auto"], ["proof (state)\nthis:\n  x = y + (\\<Sum>v\\<in>B. g v *s v)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> W; y \\<in> W; f x = f y; x \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  x = y + (\\<Sum>v\\<in>B. g v *s v)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> W; y \\<in> W; f x = f y; x \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> False", "have \"... = scale (h y) y  + (\\<Sum>v\\<in>B. scale (g v) v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y + (\\<Sum>v\\<in>B. g v *s v) = h y *s y + (\\<Sum>v\\<in>B. g v *s v)", "unfolding h_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. y + (\\<Sum>v\\<in>B. g v *s v) =\n    (if y = y then 1::'a else g y) *s y + (\\<Sum>v\\<in>B. g v *s v)", "by simp"], ["proof (state)\nthis:\n  y + (\\<Sum>v\\<in>B. g v *s v) = h y *s y + (\\<Sum>v\\<in>B. g v *s v)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> W; y \\<in> W; f x = f y; x \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  y + (\\<Sum>v\\<in>B. g v *s v) = h y *s y + (\\<Sum>v\\<in>B. g v *s v)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> W; y \\<in> W; f x = f y; x \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> False", "have \"... = scale (h y) y + (\\<Sum>v\\<in>B. scale (h v) v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h y *s y + (\\<Sum>v\\<in>B. g v *s v) =\n    h y *s y + (\\<Sum>v\\<in>B. h v *s v)", "apply (unfold add_left_cancel, rule sum.cong)"], ["proof (prove)\ngoal (2 subgoals):\n 1. B = B\n 2. \\<And>x. x \\<in> B \\<Longrightarrow> g x *s x = h x *s x", "using y h_def empty_iff disj_set"], ["proof (prove)\nusing this:\n  y \\<in> W\n  h ?a = (if ?a = y then 1::'a else g ?a)\n  (?c \\<in> {}) = False\n  B \\<inter> W = {}\n\ngoal (2 subgoals):\n 1. B = B\n 2. \\<And>x. x \\<in> B \\<Longrightarrow> g x *s x = h x *s x", "by auto"], ["proof (state)\nthis:\n  h y *s y + (\\<Sum>v\\<in>B. g v *s v) =\n  h y *s y + (\\<Sum>v\\<in>B. h v *s v)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> W; y \\<in> W; f x = f y; x \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  h y *s y + (\\<Sum>v\\<in>B. g v *s v) =\n  h y *s y + (\\<Sum>v\\<in>B. h v *s v)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> W; y \\<in> W; f x = f y; x \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> False", "have \"... = (\\<Sum>v\\<in>(insert y B). scale (h v) v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h y *s y + (\\<Sum>v\\<in>B. h v *s v) =\n    (\\<Sum>v\\<in>insert y B. h v *s v)", "by (rule sum.insert[symmetric], rule fin_B)\n       (metis (lifting) IntI disj_set empty_iff y)"], ["proof (state)\nthis:\n  h y *s y + (\\<Sum>v\\<in>B. h v *s v) = (\\<Sum>v\\<in>insert y B. h v *s v)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> W; y \\<in> W; f x = f y; x \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  x = (\\<Sum>v\\<in>insert y B. h v *s v)", "have x_in_span_yB: \"x \\<in> span (insert y B)\""], ["proof (prove)\nusing this:\n  x = (\\<Sum>v\\<in>insert y B. h v *s v)\n\ngoal (1 subgoal):\n 1. x \\<in> local.span (insert y B)", "unfolding span_finite[OF fin_yB]"], ["proof (prove)\nusing this:\n  x = (\\<Sum>v\\<in>insert y B. h v *s v)\n\ngoal (1 subgoal):\n 1. x \\<in> range (\\<lambda>u. \\<Sum>v\\<in>insert y B. u v *s v)", "by auto\n  \\<comment> \\<open>We have that a subset of elements of $C$ is linearly dependent\\<close>"], ["proof (state)\nthis:\n  x \\<in> local.span (insert y B)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> W; y \\<in> W; f x = f y; x \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> False", "have dep: \"dependent (insert x (insert y B))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.dependent (insert x (insert y B))", "by (unfold dependent_def, rule bexI [of _ x])\n       (metis Diff_insert_absorb Int_iff disj_set empty_iff insert_iff \n         x x_in_span_yB x_not_y, simp)\n  \\<comment> \\<open>Therefore, the set $C$ is also dependent:\\<close>"], ["proof (state)\nthis:\n  local.dependent (insert x (insert y B))\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> W; y \\<in> W; f x = f y; x \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> False", "hence \"dependent C\""], ["proof (prove)\nusing this:\n  local.dependent (insert x (insert y B))\n\ngoal (1 subgoal):\n 1. local.dependent C", "using C_eq x y"], ["proof (prove)\nusing this:\n  local.dependent (insert x (insert y B))\n  C = B \\<union> W\n  x \\<in> W\n  y \\<in> W\n\ngoal (1 subgoal):\n 1. local.dependent C", "by (metis Un_commute Un_upper2 dependent_mono insert_absorb insert_subset)\n  \\<comment> \\<open>This yields the contradiction, since $C$ is independent:\\<close>"], ["proof (state)\nthis:\n  local.dependent C\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> W; y \\<in> W; f x = f y; x \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  local.dependent C\n\ngoal (1 subgoal):\n 1. False", "using ind_C"], ["proof (prove)\nusing this:\n  local.dependent C\n  local.independent C\n\ngoal (1 subgoal):\n 1. False", "by contradiction"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "subsection\\<open>The proof\\<close>"], ["", "text\\<open>Now the rank nullity theorem can be proved; given any linear form \n  @{term \"f::'a => 'b\"}, the sum of the dimensions of its kernel and \n  range subspaces is equal to the dimension of the source vector space.\\<close>"], ["", "text\\<open>The statement of the ``rank nullity theorem for linear algebra'', as \n  well as its proof, follow the ones on~\\cite{AX97}. The proof is the \n  traditional one found in the literature. The theorem is also named \n  ``fundamental theorem of linear algebra'' in some texts (for instance,\n  in~\\cite{GO10}).\\<close>"], ["", "context finite_dimensional_vector_space\nbegin"], ["", "theorem rank_nullity_theorem:\n  assumes l: \"Vector_Spaces.linear scale scaleC f\"\n  shows \"dimension = dim {x. f x = 0} + vector_space.dim scaleC (range f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.dimension =\n    local.dim {x. f x = (0::'c)} + vector_space.dim scaleC (range f)", "proof -\n  \\<comment> \\<open>For convenience we define abbreviations for the universe set, $V$, \n    and the kernel of $f$\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. local.dimension =\n    local.dim {x. f x = (0::'c)} + vector_space.dim scaleC (range f)", "interpret l: Vector_Spaces.linear scale scaleC f"], ["proof (prove)\ngoal (1 subgoal):\n 1. linear (*s) scaleC f", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. local.dimension = local.dim {x. f x = (0::'c)} + l.vs2.dim (range f)", "define V :: \"'b set\" where \"V = UNIV\""], ["proof (state)\nthis:\n  V = UNIV\n\ngoal (1 subgoal):\n 1. local.dimension = local.dim {x. f x = (0::'c)} + l.vs2.dim (range f)", "define ker_f where \"ker_f = {x. f x = 0}\"\n  \\<comment> \\<open>The kernel is a proper subspace:\\<close>"], ["proof (state)\nthis:\n  ker_f = {x. f x = (0::'c)}\n\ngoal (1 subgoal):\n 1. local.dimension = local.dim {x. f x = (0::'c)} + l.vs2.dim (range f)", "have sub_ker: \"subspace {x. f x = 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.subspace {x. f x = (0::'c)}", "using l.subspace_kernel"], ["proof (prove)\nusing this:\n  local.subspace {x. f x = (0::'c)}\n\ngoal (1 subgoal):\n 1. local.subspace {x. f x = (0::'c)}", ".\n  \\<comment> \\<open>The kernel has its proper basis, $B$:\\<close>"], ["proof (state)\nthis:\n  local.subspace {x. f x = (0::'c)}\n\ngoal (1 subgoal):\n 1. local.dimension = local.dim {x. f x = (0::'c)} + l.vs2.dim (range f)", "obtain B where B_in_ker: \"B \\<subseteq> {x. f x = 0}\"\n    and independent_B: \"independent B\"\n    and ker_in_span:\"{x. f x = 0} \\<subseteq> span B\"\n    and card_B: \"card B = dim {x. f x = 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>B.\n        \\<lbrakk>B \\<subseteq> {x. f x = (0::'c)}; local.independent B;\n         {x. f x = (0::'c)} \\<subseteq> local.span B;\n         card B = local.dim {x. f x = (0::'c)}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using basis_exists"], ["proof (prove)\nusing this:\n  (\\<And>B.\n      \\<lbrakk>B \\<subseteq> ?V; local.independent B;\n       ?V \\<subseteq> local.span B; card B = local.dim ?V\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>B.\n        \\<lbrakk>B \\<subseteq> {x. f x = (0::'c)}; local.independent B;\n         {x. f x = (0::'c)} \\<subseteq> local.span B;\n         card B = local.dim {x. f x = (0::'c)}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast\n  \\<comment> \\<open>The space $V$ has a (finite dimensional) basis, $C$:\\<close>"], ["proof (state)\nthis:\n  B \\<subseteq> {x. f x = (0::'c)}\n  local.independent B\n  {x. f x = (0::'c)} \\<subseteq> local.span B\n  card B = local.dim {x. f x = (0::'c)}\n\ngoal (1 subgoal):\n 1. local.dimension = local.dim {x. f x = (0::'c)} + l.vs2.dim (range f)", "obtain C where B_in_C: \"B \\<subseteq> C\" and C_in_V: \"C \\<subseteq> V\" \n    and independent_C: \"independent C\"\n    and span_C: \"V = span C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>C.\n        \\<lbrakk>B \\<subseteq> C; C \\<subseteq> V; local.independent C;\n         V = local.span C\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding V_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>C.\n        \\<lbrakk>B \\<subseteq> C; C \\<subseteq> UNIV; local.independent C;\n         UNIV = local.span C\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis independent_B extend_basis_superset independent_extend_basis span_extend_basis span_superset)\n  \\<comment> \\<open>The basis of $V$, $C$, can be decomposed in the disjoint union of the \n      basis of the kernel, $B$, and its complementary set, $C - B$\\<close>"], ["proof (state)\nthis:\n  B \\<subseteq> C\n  C \\<subseteq> V\n  local.independent C\n  V = local.span C\n\ngoal (1 subgoal):\n 1. local.dimension = local.dim {x. f x = (0::'c)} + l.vs2.dim (range f)", "have C_eq: \"C = B \\<union> (C - B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. C = B \\<union> (C - B)", "by (rule Diff_partition [OF B_in_C, symmetric])"], ["proof (state)\nthis:\n  C = B \\<union> (C - B)\n\ngoal (1 subgoal):\n 1. local.dimension = local.dim {x. f x = (0::'c)} + l.vs2.dim (range f)", "have eq_fC: \"f ` C = f ` B \\<union> f ` (C - B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f ` C = f ` B \\<union> f ` (C - B)", "by (subst C_eq, unfold image_Un, simp) \n  \\<comment> \\<open>The basis $C$, and its image, are finite, since $V$ is finite-dimensional\\<close>"], ["proof (state)\nthis:\n  f ` C = f ` B \\<union> f ` (C - B)\n\ngoal (1 subgoal):\n 1. local.dimension = local.dim {x. f x = (0::'c)} + l.vs2.dim (range f)", "have finite_C: \"finite C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite C", "using finiteI_independent[OF independent_C]"], ["proof (prove)\nusing this:\n  finite C\n\ngoal (1 subgoal):\n 1. finite C", "."], ["proof (state)\nthis:\n  finite C\n\ngoal (1 subgoal):\n 1. local.dimension = local.dim {x. f x = (0::'c)} + l.vs2.dim (range f)", "have finite_fC: \"finite (f ` C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (f ` C)", "by (rule finite_imageI [OF finite_C])\n  \\<comment> \\<open>The basis $B$ of the kernel of $f$, and its image, are also finite\\<close>"], ["proof (state)\nthis:\n  finite (f ` C)\n\ngoal (1 subgoal):\n 1. local.dimension = local.dim {x. f x = (0::'c)} + l.vs2.dim (range f)", "have finite_B: \"finite B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite B", "by (rule rev_finite_subset [OF finite_C B_in_C])"], ["proof (state)\nthis:\n  finite B\n\ngoal (1 subgoal):\n 1. local.dimension = local.dim {x. f x = (0::'c)} + l.vs2.dim (range f)", "have finite_fB: \"finite (f ` B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (f ` B)", "by (rule finite_imageI[OF finite_B])\n  \\<comment> \\<open>The set $C - B$ is also finite\\<close>"], ["proof (state)\nthis:\n  finite (f ` B)\n\ngoal (1 subgoal):\n 1. local.dimension = local.dim {x. f x = (0::'c)} + l.vs2.dim (range f)", "have finite_CB: \"finite (C - B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (C - B)", "by (rule finite_Diff [OF finite_C, of B])"], ["proof (state)\nthis:\n  finite (C - B)\n\ngoal (1 subgoal):\n 1. local.dimension = local.dim {x. f x = (0::'c)} + l.vs2.dim (range f)", "have dim_ker_le_dim_V:\"dim (ker_f) \\<le> dim V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.dim ker_f \\<le> local.dim V", "using dim_subset [of ker_f V]"], ["proof (prove)\nusing this:\n  ker_f \\<subseteq> V \\<Longrightarrow> local.dim ker_f \\<le> local.dim V\n\ngoal (1 subgoal):\n 1. local.dim ker_f \\<le> local.dim V", "unfolding V_def"], ["proof (prove)\nusing this:\n  ker_f \\<subseteq> UNIV \\<Longrightarrow>\n  local.dim ker_f \\<le> local.dim UNIV\n\ngoal (1 subgoal):\n 1. local.dim ker_f \\<le> local.dim UNIV", "by simp\n  \\<comment> \\<open>Here it starts the proof of the theorem: the sets $B$ and \n      $C - B$ must be proven to be bases, respectively, of the kernel \n      of $f$ and its range\\<close>"], ["proof (state)\nthis:\n  local.dim ker_f \\<le> local.dim V\n\ngoal (1 subgoal):\n 1. local.dimension = local.dim {x. f x = (0::'c)} + l.vs2.dim (range f)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.dimension = local.dim {x. f x = (0::'c)} + l.vs2.dim (range f)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. local.dimension = local.dim {x. f x = (0::'c)} + l.vs2.dim (range f)", "have \"dimension = dim V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.dimension = local.dim V", "unfolding V_def dim_UNIV dimension_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. card Basis = card Basis", "by (metis basis_card_eq_dim dimension_def independent_Basis span_Basis top_greatest)"], ["proof (state)\nthis:\n  local.dimension = local.dim V\n\ngoal (1 subgoal):\n 1. local.dimension = local.dim {x. f x = (0::'c)} + l.vs2.dim (range f)", "also"], ["proof (state)\nthis:\n  local.dimension = local.dim V\n\ngoal (1 subgoal):\n 1. local.dimension = local.dim {x. f x = (0::'c)} + l.vs2.dim (range f)", "have \"dim V = dim C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.dim V = local.dim C", "unfolding span_C dim_span"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.dim C = local.dim C", ".."], ["proof (state)\nthis:\n  local.dim V = local.dim C\n\ngoal (1 subgoal):\n 1. local.dimension = local.dim {x. f x = (0::'c)} + l.vs2.dim (range f)", "also"], ["proof (state)\nthis:\n  local.dim V = local.dim C\n\ngoal (1 subgoal):\n 1. local.dimension = local.dim {x. f x = (0::'c)} + l.vs2.dim (range f)", "have \"... = card C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.dim C = card C", "using basis_card_eq_dim [of C C, OF _ span_superset independent_C]"], ["proof (prove)\nusing this:\n  C \\<subseteq> C \\<Longrightarrow> card C = local.dim C\n\ngoal (1 subgoal):\n 1. local.dim C = card C", "by simp"], ["proof (state)\nthis:\n  local.dim C = card C\n\ngoal (1 subgoal):\n 1. local.dimension = local.dim {x. f x = (0::'c)} + l.vs2.dim (range f)", "also"], ["proof (state)\nthis:\n  local.dim C = card C\n\ngoal (1 subgoal):\n 1. local.dimension = local.dim {x. f x = (0::'c)} + l.vs2.dim (range f)", "have \"... = card (B \\<union> (C - B))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card C = card (B \\<union> (C - B))", "using C_eq"], ["proof (prove)\nusing this:\n  C = B \\<union> (C - B)\n\ngoal (1 subgoal):\n 1. card C = card (B \\<union> (C - B))", "by simp"], ["proof (state)\nthis:\n  card C = card (B \\<union> (C - B))\n\ngoal (1 subgoal):\n 1. local.dimension = local.dim {x. f x = (0::'c)} + l.vs2.dim (range f)", "also"], ["proof (state)\nthis:\n  card C = card (B \\<union> (C - B))\n\ngoal (1 subgoal):\n 1. local.dimension = local.dim {x. f x = (0::'c)} + l.vs2.dim (range f)", "have \"... = card B + card (C-B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (B \\<union> (C - B)) = card B + card (C - B)", "by (rule card_Un_disjoint[OF finite_B finite_CB], fast)"], ["proof (state)\nthis:\n  card (B \\<union> (C - B)) = card B + card (C - B)\n\ngoal (1 subgoal):\n 1. local.dimension = local.dim {x. f x = (0::'c)} + l.vs2.dim (range f)", "also"], ["proof (state)\nthis:\n  card (B \\<union> (C - B)) = card B + card (C - B)\n\ngoal (1 subgoal):\n 1. local.dimension = local.dim {x. f x = (0::'c)} + l.vs2.dim (range f)", "have \"... = dim ker_f + card (C-B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card B + card (C - B) = local.dim ker_f + card (C - B)", "unfolding ker_f_def card_B"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.dim {x. f x = (0::'c)} + card (C - B) =\n    local.dim {x. f x = (0::'c)} + card (C - B)", "..\n    \\<comment> \\<open>Now it has to be proved that the elements of $C - B$ are a basis of \n      the range of $f$\\<close>"], ["proof (state)\nthis:\n  card B + card (C - B) = local.dim ker_f + card (C - B)\n\ngoal (1 subgoal):\n 1. local.dimension = local.dim {x. f x = (0::'c)} + l.vs2.dim (range f)", "also"], ["proof (state)\nthis:\n  card B + card (C - B) = local.dim ker_f + card (C - B)\n\ngoal (1 subgoal):\n 1. local.dimension = local.dim {x. f x = (0::'c)} + l.vs2.dim (range f)", "have \"... = dim ker_f + l.vs2.dim (range f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.dim ker_f + card (C - B) = local.dim ker_f + l.vs2.dim (range f)", "proof (unfold add_left_cancel)"], ["proof (state)\ngoal (1 subgoal):\n 1. card (C - B) = l.vs2.dim (range f)", "define W where \"W = C - B\""], ["proof (state)\nthis:\n  W = C - B\n\ngoal (1 subgoal):\n 1. card (C - B) = l.vs2.dim (range f)", "have finite_W: \"finite W\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite W", "unfolding W_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (C - B)", "using finite_CB"], ["proof (prove)\nusing this:\n  finite (C - B)\n\ngoal (1 subgoal):\n 1. finite (C - B)", "."], ["proof (state)\nthis:\n  finite W\n\ngoal (1 subgoal):\n 1. card (C - B) = l.vs2.dim (range f)", "have finite_fW: \"finite (f ` W)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (f ` W)", "using finite_imageI[OF finite_W]"], ["proof (prove)\nusing this:\n  finite (?h ` W)\n\ngoal (1 subgoal):\n 1. finite (f ` W)", "."], ["proof (state)\nthis:\n  finite (f ` W)\n\ngoal (1 subgoal):\n 1. card (C - B) = l.vs2.dim (range f)", "have \"card W = card (f ` W)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card W = card (f ` W)", "by (rule card_image [symmetric], rule inj_on_extended[OF l, of C B], rule finite_C)\n          (rule independent_C,unfold W_def, subst C_eq, rule refl, simp, rule ker_in_span)"], ["proof (state)\nthis:\n  card W = card (f ` W)\n\ngoal (1 subgoal):\n 1. card (C - B) = l.vs2.dim (range f)", "also"], ["proof (state)\nthis:\n  card W = card (f ` W)\n\ngoal (1 subgoal):\n 1. card (C - B) = l.vs2.dim (range f)", "have \"... = l.vs2.dim (range f)\"\n        \\<comment> \\<open>The image set of $W$ is independent and its span contains the range \n             of $f$, so it is a basis of the range:\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. card (f ` W) = l.vs2.dim (range f)", "proof (rule l.vs2.basis_card_eq_dim)\n        \\<comment> \\<open>1. The image set of $W$ generates the range of $f$:\\<close>"], ["proof (state)\ngoal (3 subgoals):\n 1. f ` W \\<subseteq> range f\n 2. range f \\<subseteq> l.vs2.span (f ` W)\n 3. l.vs2.independent (f ` W)", "show \"range f \\<subseteq> l.vs2.span (f ` W)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. range f \\<subseteq> l.vs2.span (f ` W)", "proof (unfold l.vs2.span_finite [OF finite_fW], auto)\n          \\<comment> \\<open>Given any element $v$ in $V$, its image can be expressed as a \n            linear combination of elements of the image by $f$ of $C$:\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       f xa \\<in> range (\\<lambda>u. \\<Sum>v\\<in>f ` W. scaleC (u v) v)", "fix v :: 'b"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       f xa \\<in> range (\\<lambda>u. \\<Sum>v\\<in>f ` W. scaleC (u v) v)", "have fV_span: \"f ` V \\<subseteq> l.vs2.span  (f ` C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f ` V \\<subseteq> l.vs2.span (f ` C)", "by (simp add: span_C l.span_image)"], ["proof (state)\nthis:\n  f ` V \\<subseteq> l.vs2.span (f ` C)\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       f xa \\<in> range (\\<lambda>u. \\<Sum>v\\<in>f ` W. scaleC (u v) v)", "have \"\\<exists>g. (\\<Sum>x\\<in>f`C. scaleC (g x) x) = f v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>g. (\\<Sum>x\\<in>f ` C. scaleC (g x) x) = f v", "using fV_span"], ["proof (prove)\nusing this:\n  f ` V \\<subseteq> l.vs2.span (f ` C)\n\ngoal (1 subgoal):\n 1. \\<exists>g. (\\<Sum>x\\<in>f ` C. scaleC (g x) x) = f v", "unfolding V_def"], ["proof (prove)\nusing this:\n  range f \\<subseteq> l.vs2.span (f ` C)\n\ngoal (1 subgoal):\n 1. \\<exists>g. (\\<Sum>x\\<in>f ` C. scaleC (g x) x) = f v", "using l.vs2.span_finite[OF finite_fC]"], ["proof (prove)\nusing this:\n  range f \\<subseteq> l.vs2.span (f ` C)\n  l.vs2.span (f ` C) = range (\\<lambda>u. \\<Sum>v\\<in>f ` C. scaleC (u v) v)\n\ngoal (1 subgoal):\n 1. \\<exists>g. (\\<Sum>x\\<in>f ` C. scaleC (g x) x) = f v", "by (metis (no_types, lifting) V_def rangeE rangeI span_C l.span_image)"], ["proof (state)\nthis:\n  \\<exists>g. (\\<Sum>x\\<in>f ` C. scaleC (g x) x) = f v\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       f xa \\<in> range (\\<lambda>u. \\<Sum>v\\<in>f ` W. scaleC (u v) v)", "then"], ["proof (chain)\npicking this:\n  \\<exists>g. (\\<Sum>x\\<in>f ` C. scaleC (g x) x) = f v", "obtain g where fv: \"f v = (\\<Sum>x\\<in>f ` C. scaleC (g x) x)\""], ["proof (prove)\nusing this:\n  \\<exists>g. (\\<Sum>x\\<in>f ` C. scaleC (g x) x) = f v\n\ngoal (1 subgoal):\n 1. (\\<And>g.\n        f v = (\\<Sum>x\\<in>f ` C. scaleC (g x) x) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by metis\n              \\<comment> \\<open>We recall that $C$ is equal to $B$ union $(C - B)$, and $B$ \n            is the basis of the kernel; thus, the image of the elements of \n            $B$ will be equal to zero:\\<close>"], ["proof (state)\nthis:\n  f v = (\\<Sum>x\\<in>f ` C. scaleC (g x) x)\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       f xa \\<in> range (\\<lambda>u. \\<Sum>v\\<in>f ` W. scaleC (u v) v)", "have zero_fB: \"(\\<Sum>x\\<in>f ` B. scaleC (g x) x) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>f ` B. scaleC (g x) x) = (0::'c)", "using B_in_ker"], ["proof (prove)\nusing this:\n  B \\<subseteq> {x. f x = (0::'c)}\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>f ` B. scaleC (g x) x) = (0::'c)", "by (auto intro!: sum.neutral)"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>f ` B. scaleC (g x) x) = (0::'c)\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       f xa \\<in> range (\\<lambda>u. \\<Sum>v\\<in>f ` W. scaleC (u v) v)", "have zero_inter: \"(\\<Sum>x\\<in>(f ` B \\<inter> f ` W). scaleC (g x) x) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>f ` B \\<inter> f ` W. scaleC (g x) x) = (0::'c)", "using B_in_ker"], ["proof (prove)\nusing this:\n  B \\<subseteq> {x. f x = (0::'c)}\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>f ` B \\<inter> f ` W. scaleC (g x) x) = (0::'c)", "by (auto intro!: sum.neutral)"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>f ` B \\<inter> f ` W. scaleC (g x) x) = (0::'c)\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       f xa \\<in> range (\\<lambda>u. \\<Sum>v\\<in>f ` W. scaleC (u v) v)", "have \"f v = (\\<Sum>x\\<in>f ` C. scaleC (g x) x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f v = (\\<Sum>x\\<in>f ` C. scaleC (g x) x)", "using fv"], ["proof (prove)\nusing this:\n  f v = (\\<Sum>x\\<in>f ` C. scaleC (g x) x)\n\ngoal (1 subgoal):\n 1. f v = (\\<Sum>x\\<in>f ` C. scaleC (g x) x)", "."], ["proof (state)\nthis:\n  f v = (\\<Sum>x\\<in>f ` C. scaleC (g x) x)\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       f xa \\<in> range (\\<lambda>u. \\<Sum>v\\<in>f ` W. scaleC (u v) v)", "also"], ["proof (state)\nthis:\n  f v = (\\<Sum>x\\<in>f ` C. scaleC (g x) x)\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       f xa \\<in> range (\\<lambda>u. \\<Sum>v\\<in>f ` W. scaleC (u v) v)", "have \"... = (\\<Sum>x\\<in>(f ` B \\<union> f ` W).  scaleC (g x) x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>f ` C. scaleC (g x) x) =\n    (\\<Sum>x\\<in>f ` B \\<union> f ` W. scaleC (g x) x)", "using eq_fC W_def"], ["proof (prove)\nusing this:\n  f ` C = f ` B \\<union> f ` (C - B)\n  W = C - B\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>f ` C. scaleC (g x) x) =\n    (\\<Sum>x\\<in>f ` B \\<union> f ` W. scaleC (g x) x)", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>f ` C. scaleC (g x) x) =\n  (\\<Sum>x\\<in>f ` B \\<union> f ` W. scaleC (g x) x)\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       f xa \\<in> range (\\<lambda>u. \\<Sum>v\\<in>f ` W. scaleC (u v) v)", "also"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>f ` C. scaleC (g x) x) =\n  (\\<Sum>x\\<in>f ` B \\<union> f ` W. scaleC (g x) x)\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       f xa \\<in> range (\\<lambda>u. \\<Sum>v\\<in>f ` W. scaleC (u v) v)", "have \"... = \n              (\\<Sum>x\\<in>f ` B. scaleC (g x) x) + (\\<Sum>x\\<in>f ` W. scaleC (g x) x) \n                - (\\<Sum>x\\<in>(f ` B \\<inter> f ` W). scaleC (g x) x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>f ` B \\<union> f ` W. scaleC (g x) x) =\n    (\\<Sum>x\\<in>f ` B. scaleC (g x) x) +\n    (\\<Sum>x\\<in>f ` W. scaleC (g x) x) -\n    (\\<Sum>x\\<in>f ` B \\<inter> f ` W. scaleC (g x) x)", "using sum_Un [OF finite_fB finite_fW]"], ["proof (prove)\nusing this:\n  sum ?f (f ` B \\<union> f ` W) =\n  sum ?f (f ` B) + sum ?f (f ` W) - sum ?f (f ` B \\<inter> f ` W)\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>f ` B \\<union> f ` W. scaleC (g x) x) =\n    (\\<Sum>x\\<in>f ` B. scaleC (g x) x) +\n    (\\<Sum>x\\<in>f ` W. scaleC (g x) x) -\n    (\\<Sum>x\\<in>f ` B \\<inter> f ` W. scaleC (g x) x)", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>f ` B \\<union> f ` W. scaleC (g x) x) =\n  (\\<Sum>x\\<in>f ` B. scaleC (g x) x) +\n  (\\<Sum>x\\<in>f ` W. scaleC (g x) x) -\n  (\\<Sum>x\\<in>f ` B \\<inter> f ` W. scaleC (g x) x)\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       f xa \\<in> range (\\<lambda>u. \\<Sum>v\\<in>f ` W. scaleC (u v) v)", "also"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>f ` B \\<union> f ` W. scaleC (g x) x) =\n  (\\<Sum>x\\<in>f ` B. scaleC (g x) x) +\n  (\\<Sum>x\\<in>f ` W. scaleC (g x) x) -\n  (\\<Sum>x\\<in>f ` B \\<inter> f ` W. scaleC (g x) x)\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       f xa \\<in> range (\\<lambda>u. \\<Sum>v\\<in>f ` W. scaleC (u v) v)", "have \"... = (\\<Sum>x\\<in>f ` W. scaleC (g x) x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>f ` B. scaleC (g x) x) +\n    (\\<Sum>x\\<in>f ` W. scaleC (g x) x) -\n    (\\<Sum>x\\<in>f ` B \\<inter> f ` W. scaleC (g x) x) =\n    (\\<Sum>x\\<in>f ` W. scaleC (g x) x)", "unfolding zero_fB zero_inter"], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'c) + (\\<Sum>x\\<in>f ` W. scaleC (g x) x) - (0::'c) =\n    (\\<Sum>x\\<in>f ` W. scaleC (g x) x)", "by simp\n              \\<comment> \\<open>We have proved that the image set of $W$ is a generating set \n              of the range of $f$\\<close>"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>f ` B. scaleC (g x) x) +\n  (\\<Sum>x\\<in>f ` W. scaleC (g x) x) -\n  (\\<Sum>x\\<in>f ` B \\<inter> f ` W. scaleC (g x) x) =\n  (\\<Sum>x\\<in>f ` W. scaleC (g x) x)\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       f xa \\<in> range (\\<lambda>u. \\<Sum>v\\<in>f ` W. scaleC (u v) v)", "finally"], ["proof (chain)\npicking this:\n  f v = (\\<Sum>x\\<in>f ` W. scaleC (g x) x)", "show \"f v \\<in> range (\\<lambda>u. \\<Sum>v\\<in>f ` W. scaleC (u v) v)\""], ["proof (prove)\nusing this:\n  f v = (\\<Sum>x\\<in>f ` W. scaleC (g x) x)\n\ngoal (1 subgoal):\n 1. f v \\<in> range (\\<lambda>u. \\<Sum>v\\<in>f ` W. scaleC (u v) v)", "by auto"], ["proof (state)\nthis:\n  f v \\<in> range (\\<lambda>u. \\<Sum>v\\<in>f ` W. scaleC (u v) v)\n\ngoal:\nNo subgoals!", "qed\n          \\<comment> \\<open>2. The image set of $W$ is linearly independent:\\<close>"], ["proof (state)\nthis:\n  range f \\<subseteq> l.vs2.span (f ` W)\n\ngoal (2 subgoals):\n 1. f ` W \\<subseteq> range f\n 2. l.vs2.independent (f ` W)", "show \"l.vs2.independent (f ` W)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l.vs2.independent (f ` W)", "using finite_fW"], ["proof (prove)\nusing this:\n  finite (f ` W)\n\ngoal (1 subgoal):\n 1. l.vs2.independent (f ` W)", "proof (rule l.vs2.independent_if_scalars_zero)\n          \\<comment> \\<open>Every linear combination (given by $g x$) of the elements of \n           the image set of $W$ equal to zero, requires every coefficient to \n           be zero:\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>fa x.\n       \\<lbrakk>(\\<Sum>x\\<in>f ` W. scaleC (fa x) x) = (0::'c);\n        x \\<in> f ` W\\<rbrakk>\n       \\<Longrightarrow> fa x = (0::'a)", "fix g :: \"'c => 'a\" and w :: 'c"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>fa x.\n       \\<lbrakk>(\\<Sum>x\\<in>f ` W. scaleC (fa x) x) = (0::'c);\n        x \\<in> f ` W\\<rbrakk>\n       \\<Longrightarrow> fa x = (0::'a)", "assume sum: \"(\\<Sum>x\\<in>f ` W. scaleC (g x) x) = 0\" and w: \"w \\<in> f ` W\""], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>f ` W. scaleC (g x) x) = (0::'c)\n  w \\<in> f ` W\n\ngoal (1 subgoal):\n 1. \\<And>fa x.\n       \\<lbrakk>(\\<Sum>x\\<in>f ` W. scaleC (fa x) x) = (0::'c);\n        x \\<in> f ` W\\<rbrakk>\n       \\<Longrightarrow> fa x = (0::'a)", "have \"0 = (\\<Sum>x\\<in>f ` W. scaleC (g x) x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'c) = (\\<Sum>x\\<in>f ` W. scaleC (g x) x)", "using sum"], ["proof (prove)\nusing this:\n  (\\<Sum>x\\<in>f ` W. scaleC (g x) x) = (0::'c)\n\ngoal (1 subgoal):\n 1. (0::'c) = (\\<Sum>x\\<in>f ` W. scaleC (g x) x)", "by simp"], ["proof (state)\nthis:\n  (0::'c) = (\\<Sum>x\\<in>f ` W. scaleC (g x) x)\n\ngoal (1 subgoal):\n 1. \\<And>fa x.\n       \\<lbrakk>(\\<Sum>x\\<in>f ` W. scaleC (fa x) x) = (0::'c);\n        x \\<in> f ` W\\<rbrakk>\n       \\<Longrightarrow> fa x = (0::'a)", "also"], ["proof (state)\nthis:\n  (0::'c) = (\\<Sum>x\\<in>f ` W. scaleC (g x) x)\n\ngoal (1 subgoal):\n 1. \\<And>fa x.\n       \\<lbrakk>(\\<Sum>x\\<in>f ` W. scaleC (fa x) x) = (0::'c);\n        x \\<in> f ` W\\<rbrakk>\n       \\<Longrightarrow> fa x = (0::'a)", "have \"... = sum ((\\<lambda>x. scaleC (g x) x) \\<circ> f) W\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>f ` W. scaleC (g x) x) =\n    sum ((\\<lambda>x. scaleC (g x) x) \\<circ> f) W", "by (rule sum.reindex, rule inj_on_extended[OF l, of C B])\n              (unfold W_def, rule finite_C, rule independent_C, rule C_eq, simp, \n                rule ker_in_span)"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>f ` W. scaleC (g x) x) =\n  sum ((\\<lambda>x. scaleC (g x) x) \\<circ> f) W\n\ngoal (1 subgoal):\n 1. \\<And>fa x.\n       \\<lbrakk>(\\<Sum>x\\<in>f ` W. scaleC (fa x) x) = (0::'c);\n        x \\<in> f ` W\\<rbrakk>\n       \\<Longrightarrow> fa x = (0::'a)", "also"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>f ` W. scaleC (g x) x) =\n  sum ((\\<lambda>x. scaleC (g x) x) \\<circ> f) W\n\ngoal (1 subgoal):\n 1. \\<And>fa x.\n       \\<lbrakk>(\\<Sum>x\\<in>f ` W. scaleC (fa x) x) = (0::'c);\n        x \\<in> f ` W\\<rbrakk>\n       \\<Longrightarrow> fa x = (0::'a)", "have \"... = (\\<Sum>x\\<in>W. scaleC ((g \\<circ> f) x) (f x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum ((\\<lambda>x. scaleC (g x) x) \\<circ> f) W =\n    (\\<Sum>x\\<in>W. scaleC ((g \\<circ> f) x) (f x))", "unfolding o_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>W. scaleC (g (f x)) (f x)) =\n    (\\<Sum>x\\<in>W. scaleC (g (f x)) (f x))", ".."], ["proof (state)\nthis:\n  sum ((\\<lambda>x. scaleC (g x) x) \\<circ> f) W =\n  (\\<Sum>x\\<in>W. scaleC ((g \\<circ> f) x) (f x))\n\ngoal (1 subgoal):\n 1. \\<And>fa x.\n       \\<lbrakk>(\\<Sum>x\\<in>f ` W. scaleC (fa x) x) = (0::'c);\n        x \\<in> f ` W\\<rbrakk>\n       \\<Longrightarrow> fa x = (0::'a)", "also"], ["proof (state)\nthis:\n  sum ((\\<lambda>x. scaleC (g x) x) \\<circ> f) W =\n  (\\<Sum>x\\<in>W. scaleC ((g \\<circ> f) x) (f x))\n\ngoal (1 subgoal):\n 1. \\<And>fa x.\n       \\<lbrakk>(\\<Sum>x\\<in>f ` W. scaleC (fa x) x) = (0::'c);\n        x \\<in> f ` W\\<rbrakk>\n       \\<Longrightarrow> fa x = (0::'a)", "have \"... = f (\\<Sum>x\\<in>W. scale ((g \\<circ> f) x) x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>W. scaleC ((g \\<circ> f) x) (f x)) =\n    f (\\<Sum>x\\<in>W. (g \\<circ> f) x *s x)", "unfolding l.sum[symmetric] l.scale[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. f (\\<Sum>x\\<in>W. (g \\<circ> f) x *s x) =\n    f (\\<Sum>x\\<in>W. (g \\<circ> f) x *s x)", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>W. scaleC ((g \\<circ> f) x) (f x)) =\n  f (\\<Sum>x\\<in>W. (g \\<circ> f) x *s x)\n\ngoal (1 subgoal):\n 1. \\<And>fa x.\n       \\<lbrakk>(\\<Sum>x\\<in>f ` W. scaleC (fa x) x) = (0::'c);\n        x \\<in> f ` W\\<rbrakk>\n       \\<Longrightarrow> fa x = (0::'a)", "finally"], ["proof (chain)\npicking this:\n  (0::'c) = f (\\<Sum>x\\<in>W. (g \\<circ> f) x *s x)", "have f_sum_zero:\"f (\\<Sum>x\\<in>W. scale ((g \\<circ> f) x) x) = 0\""], ["proof (prove)\nusing this:\n  (0::'c) = f (\\<Sum>x\\<in>W. (g \\<circ> f) x *s x)\n\ngoal (1 subgoal):\n 1. f (\\<Sum>x\\<in>W. (g \\<circ> f) x *s x) = (0::'c)", "by (rule sym)"], ["proof (state)\nthis:\n  f (\\<Sum>x\\<in>W. (g \\<circ> f) x *s x) = (0::'c)\n\ngoal (1 subgoal):\n 1. \\<And>fa x.\n       \\<lbrakk>(\\<Sum>x\\<in>f ` W. scaleC (fa x) x) = (0::'c);\n        x \\<in> f ` W\\<rbrakk>\n       \\<Longrightarrow> fa x = (0::'a)", "hence \"(\\<Sum>x\\<in>W. scale ((g \\<circ> f) x) x) \\<in> ker_f\""], ["proof (prove)\nusing this:\n  f (\\<Sum>x\\<in>W. (g \\<circ> f) x *s x) = (0::'c)\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>W. (g \\<circ> f) x *s x) \\<in> ker_f", "unfolding ker_f_def"], ["proof (prove)\nusing this:\n  f (\\<Sum>x\\<in>W. (g \\<circ> f) x *s x) = (0::'c)\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>W. (g \\<circ> f) x *s x) \\<in> {x. f x = (0::'c)}", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>W. (g \\<circ> f) x *s x) \\<in> ker_f\n\ngoal (1 subgoal):\n 1. \\<And>fa x.\n       \\<lbrakk>(\\<Sum>x\\<in>f ` W. scaleC (fa x) x) = (0::'c);\n        x \\<in> f ` W\\<rbrakk>\n       \\<Longrightarrow> fa x = (0::'a)", "hence \"\\<exists>h. (\\<Sum>v\\<in>B. scale (h v) v) = (\\<Sum>x\\<in>W. scale ((g \\<circ> f) x) x)\""], ["proof (prove)\nusing this:\n  (\\<Sum>x\\<in>W. (g \\<circ> f) x *s x) \\<in> ker_f\n\ngoal (1 subgoal):\n 1. \\<exists>h.\n       (\\<Sum>v\\<in>B. h v *s v) = (\\<Sum>x\\<in>W. (g \\<circ> f) x *s x)", "using span_finite[OF finite_B]"], ["proof (prove)\nusing this:\n  (\\<Sum>x\\<in>W. (g \\<circ> f) x *s x) \\<in> ker_f\n  local.span B = range (\\<lambda>u. \\<Sum>v\\<in>B. u v *s v)\n\ngoal (1 subgoal):\n 1. \\<exists>h.\n       (\\<Sum>v\\<in>B. h v *s v) = (\\<Sum>x\\<in>W. (g \\<circ> f) x *s x)", "using ker_in_span"], ["proof (prove)\nusing this:\n  (\\<Sum>x\\<in>W. (g \\<circ> f) x *s x) \\<in> ker_f\n  local.span B = range (\\<lambda>u. \\<Sum>v\\<in>B. u v *s v)\n  {x. f x = (0::'c)} \\<subseteq> local.span B\n\ngoal (1 subgoal):\n 1. \\<exists>h.\n       (\\<Sum>v\\<in>B. h v *s v) = (\\<Sum>x\\<in>W. (g \\<circ> f) x *s x)", "unfolding ker_f_def"], ["proof (prove)\nusing this:\n  (\\<Sum>x\\<in>W. (g \\<circ> f) x *s x) \\<in> {x. f x = (0::'c)}\n  local.span B = range (\\<lambda>u. \\<Sum>v\\<in>B. u v *s v)\n  {x. f x = (0::'c)} \\<subseteq> local.span B\n\ngoal (1 subgoal):\n 1. \\<exists>h.\n       (\\<Sum>v\\<in>B. h v *s v) = (\\<Sum>x\\<in>W. (g \\<circ> f) x *s x)", "by force"], ["proof (state)\nthis:\n  \\<exists>h.\n     (\\<Sum>v\\<in>B. h v *s v) = (\\<Sum>x\\<in>W. (g \\<circ> f) x *s x)\n\ngoal (1 subgoal):\n 1. \\<And>fa x.\n       \\<lbrakk>(\\<Sum>x\\<in>f ` W. scaleC (fa x) x) = (0::'c);\n        x \\<in> f ` W\\<rbrakk>\n       \\<Longrightarrow> fa x = (0::'a)", "then"], ["proof (chain)\npicking this:\n  \\<exists>h.\n     (\\<Sum>v\\<in>B. h v *s v) = (\\<Sum>x\\<in>W. (g \\<circ> f) x *s x)", "obtain h where \n            sum_h: \"(\\<Sum>v\\<in>B. scale (h v) v) = (\\<Sum>x\\<in>W. scale ((g \\<circ> f) x) x)\""], ["proof (prove)\nusing this:\n  \\<exists>h.\n     (\\<Sum>v\\<in>B. h v *s v) = (\\<Sum>x\\<in>W. (g \\<circ> f) x *s x)\n\ngoal (1 subgoal):\n 1. (\\<And>h.\n        (\\<Sum>v\\<in>B. h v *s v) =\n        (\\<Sum>x\\<in>W. (g \\<circ> f) x *s x) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  (\\<Sum>v\\<in>B. h v *s v) = (\\<Sum>x\\<in>W. (g \\<circ> f) x *s x)\n\ngoal (1 subgoal):\n 1. \\<And>fa x.\n       \\<lbrakk>(\\<Sum>x\\<in>f ` W. scaleC (fa x) x) = (0::'c);\n        x \\<in> f ` W\\<rbrakk>\n       \\<Longrightarrow> fa x = (0::'a)", "define t where \"t a = (if a \\<in> B then h a else - ((g \\<circ> f) a))\" for a"], ["proof (state)\nthis:\n  t ?a = (if ?a \\<in> B then h ?a else - (g \\<circ> f) ?a)\n\ngoal (1 subgoal):\n 1. \\<And>fa x.\n       \\<lbrakk>(\\<Sum>x\\<in>f ` W. scaleC (fa x) x) = (0::'c);\n        x \\<in> f ` W\\<rbrakk>\n       \\<Longrightarrow> fa x = (0::'a)", "have \"0 = (\\<Sum>v\\<in>B. scale (h v) v) + - (\\<Sum>x\\<in>W. scale ((g \\<circ> f) x) x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'b) =\n    (\\<Sum>v\\<in>B. h v *s v) + - (\\<Sum>x\\<in>W. (g \\<circ> f) x *s x)", "using sum_h"], ["proof (prove)\nusing this:\n  (\\<Sum>v\\<in>B. h v *s v) = (\\<Sum>x\\<in>W. (g \\<circ> f) x *s x)\n\ngoal (1 subgoal):\n 1. (0::'b) =\n    (\\<Sum>v\\<in>B. h v *s v) + - (\\<Sum>x\\<in>W. (g \\<circ> f) x *s x)", "by simp"], ["proof (state)\nthis:\n  (0::'b) =\n  (\\<Sum>v\\<in>B. h v *s v) + - (\\<Sum>x\\<in>W. (g \\<circ> f) x *s x)\n\ngoal (1 subgoal):\n 1. \\<And>fa x.\n       \\<lbrakk>(\\<Sum>x\\<in>f ` W. scaleC (fa x) x) = (0::'c);\n        x \\<in> f ` W\\<rbrakk>\n       \\<Longrightarrow> fa x = (0::'a)", "also"], ["proof (state)\nthis:\n  (0::'b) =\n  (\\<Sum>v\\<in>B. h v *s v) + - (\\<Sum>x\\<in>W. (g \\<circ> f) x *s x)\n\ngoal (1 subgoal):\n 1. \\<And>fa x.\n       \\<lbrakk>(\\<Sum>x\\<in>f ` W. scaleC (fa x) x) = (0::'c);\n        x \\<in> f ` W\\<rbrakk>\n       \\<Longrightarrow> fa x = (0::'a)", "have \"... =  (\\<Sum>v\\<in>B. scale (h v) v) + (\\<Sum>x\\<in>W. - (scale ((g \\<circ> f) x) x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>v\\<in>B. h v *s v) + - (\\<Sum>x\\<in>W. (g \\<circ> f) x *s x) =\n    (\\<Sum>v\\<in>B. h v *s v) + (\\<Sum>x\\<in>W. - ((g \\<circ> f) x *s x))", "unfolding sum_negf"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>v\\<in>B. h v *s v) + - (\\<Sum>x\\<in>W. (g \\<circ> f) x *s x) =\n    (\\<Sum>v\\<in>B. h v *s v) + - (\\<Sum>x\\<in>W. (g \\<circ> f) x *s x)", ".."], ["proof (state)\nthis:\n  (\\<Sum>v\\<in>B. h v *s v) + - (\\<Sum>x\\<in>W. (g \\<circ> f) x *s x) =\n  (\\<Sum>v\\<in>B. h v *s v) + (\\<Sum>x\\<in>W. - ((g \\<circ> f) x *s x))\n\ngoal (1 subgoal):\n 1. \\<And>fa x.\n       \\<lbrakk>(\\<Sum>x\\<in>f ` W. scaleC (fa x) x) = (0::'c);\n        x \\<in> f ` W\\<rbrakk>\n       \\<Longrightarrow> fa x = (0::'a)", "also"], ["proof (state)\nthis:\n  (\\<Sum>v\\<in>B. h v *s v) + - (\\<Sum>x\\<in>W. (g \\<circ> f) x *s x) =\n  (\\<Sum>v\\<in>B. h v *s v) + (\\<Sum>x\\<in>W. - ((g \\<circ> f) x *s x))\n\ngoal (1 subgoal):\n 1. \\<And>fa x.\n       \\<lbrakk>(\\<Sum>x\\<in>f ` W. scaleC (fa x) x) = (0::'c);\n        x \\<in> f ` W\\<rbrakk>\n       \\<Longrightarrow> fa x = (0::'a)", "have \"... = (\\<Sum>v\\<in>B. scale (t v) v) + (\\<Sum>x\\<in>W. -(scale((g \\<circ> f) x) x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>v\\<in>B. h v *s v) + (\\<Sum>x\\<in>W. - ((g \\<circ> f) x *s x)) =\n    (\\<Sum>v\\<in>B. t v *s v) + (\\<Sum>x\\<in>W. - ((g \\<circ> f) x *s x))", "unfolding add_right_cancel"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>v\\<in>B. h v *s v) = (\\<Sum>v\\<in>B. t v *s v)", "unfolding t_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>v\\<in>B. h v *s v) =\n    (\\<Sum>v\\<in>B. (if v \\<in> B then h v else - (g \\<circ> f) v) *s v)", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>v\\<in>B. h v *s v) + (\\<Sum>x\\<in>W. - ((g \\<circ> f) x *s x)) =\n  (\\<Sum>v\\<in>B. t v *s v) + (\\<Sum>x\\<in>W. - ((g \\<circ> f) x *s x))\n\ngoal (1 subgoal):\n 1. \\<And>fa x.\n       \\<lbrakk>(\\<Sum>x\\<in>f ` W. scaleC (fa x) x) = (0::'c);\n        x \\<in> f ` W\\<rbrakk>\n       \\<Longrightarrow> fa x = (0::'a)", "also"], ["proof (state)\nthis:\n  (\\<Sum>v\\<in>B. h v *s v) + (\\<Sum>x\\<in>W. - ((g \\<circ> f) x *s x)) =\n  (\\<Sum>v\\<in>B. t v *s v) + (\\<Sum>x\\<in>W. - ((g \\<circ> f) x *s x))\n\ngoal (1 subgoal):\n 1. \\<And>fa x.\n       \\<lbrakk>(\\<Sum>x\\<in>f ` W. scaleC (fa x) x) = (0::'c);\n        x \\<in> f ` W\\<rbrakk>\n       \\<Longrightarrow> fa x = (0::'a)", "have \"... =  (\\<Sum>v\\<in>B. scale (t v) v) + (\\<Sum>x\\<in>W. scale (t x) x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>v\\<in>B. t v *s v) + (\\<Sum>x\\<in>W. - ((g \\<circ> f) x *s x)) =\n    (\\<Sum>v\\<in>B. t v *s v) + (\\<Sum>x\\<in>W. t x *s x)", "by (unfold add_left_cancel t_def W_def, rule sum.cong) simp+"], ["proof (state)\nthis:\n  (\\<Sum>v\\<in>B. t v *s v) + (\\<Sum>x\\<in>W. - ((g \\<circ> f) x *s x)) =\n  (\\<Sum>v\\<in>B. t v *s v) + (\\<Sum>x\\<in>W. t x *s x)\n\ngoal (1 subgoal):\n 1. \\<And>fa x.\n       \\<lbrakk>(\\<Sum>x\\<in>f ` W. scaleC (fa x) x) = (0::'c);\n        x \\<in> f ` W\\<rbrakk>\n       \\<Longrightarrow> fa x = (0::'a)", "also"], ["proof (state)\nthis:\n  (\\<Sum>v\\<in>B. t v *s v) + (\\<Sum>x\\<in>W. - ((g \\<circ> f) x *s x)) =\n  (\\<Sum>v\\<in>B. t v *s v) + (\\<Sum>x\\<in>W. t x *s x)\n\ngoal (1 subgoal):\n 1. \\<And>fa x.\n       \\<lbrakk>(\\<Sum>x\\<in>f ` W. scaleC (fa x) x) = (0::'c);\n        x \\<in> f ` W\\<rbrakk>\n       \\<Longrightarrow> fa x = (0::'a)", "have \"... = (\\<Sum>v\\<in>B \\<union> W. scale (t v) v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>v\\<in>B. t v *s v) + (\\<Sum>x\\<in>W. t x *s x) =\n    (\\<Sum>v\\<in>B \\<union> W. t v *s v)", "by (rule sum.union_inter_neutral [symmetric], rule finite_B, rule finite_W) \n              (simp add: W_def)"], ["proof (state)\nthis:\n  (\\<Sum>v\\<in>B. t v *s v) + (\\<Sum>x\\<in>W. t x *s x) =\n  (\\<Sum>v\\<in>B \\<union> W. t v *s v)\n\ngoal (1 subgoal):\n 1. \\<And>fa x.\n       \\<lbrakk>(\\<Sum>x\\<in>f ` W. scaleC (fa x) x) = (0::'c);\n        x \\<in> f ` W\\<rbrakk>\n       \\<Longrightarrow> fa x = (0::'a)", "finally"], ["proof (chain)\npicking this:\n  (0::'b) = (\\<Sum>v\\<in>B \\<union> W. t v *s v)", "have \"(\\<Sum>v\\<in>B \\<union> W. scale (t v) v) = 0\""], ["proof (prove)\nusing this:\n  (0::'b) = (\\<Sum>v\\<in>B \\<union> W. t v *s v)\n\ngoal (1 subgoal):\n 1. (\\<Sum>v\\<in>B \\<union> W. t v *s v) = (0::'b)", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>v\\<in>B \\<union> W. t v *s v) = (0::'b)\n\ngoal (1 subgoal):\n 1. \\<And>fa x.\n       \\<lbrakk>(\\<Sum>x\\<in>f ` W. scaleC (fa x) x) = (0::'c);\n        x \\<in> f ` W\\<rbrakk>\n       \\<Longrightarrow> fa x = (0::'a)", "hence coef_zero: \"\\<forall>x\\<in>B \\<union> W. t x = 0\""], ["proof (prove)\nusing this:\n  (\\<Sum>v\\<in>B \\<union> W. t v *s v) = (0::'b)\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>B \\<union> W. t x = (0::'a)", "using C_eq scalars_zero_if_independent [OF finite_C independent_C]"], ["proof (prove)\nusing this:\n  (\\<Sum>v\\<in>B \\<union> W. t v *s v) = (0::'b)\n  C = B \\<union> (C - B)\n  (\\<Sum>x\\<in>C. ?f x *s x) = (0::'b) \\<Longrightarrow>\n  \\<forall>x\\<in>C. ?f x = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>B \\<union> W. t x = (0::'a)", "unfolding W_def"], ["proof (prove)\nusing this:\n  (\\<Sum>v\\<in>B \\<union> (C - B). t v *s v) = (0::'b)\n  C = B \\<union> (C - B)\n  (\\<Sum>x\\<in>C. ?f x *s x) = (0::'b) \\<Longrightarrow>\n  \\<forall>x\\<in>C. ?f x = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>B \\<union> (C - B). t x = (0::'a)", "by simp"], ["proof (state)\nthis:\n  \\<forall>x\\<in>B \\<union> W. t x = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>fa x.\n       \\<lbrakk>(\\<Sum>x\\<in>f ` W. scaleC (fa x) x) = (0::'c);\n        x \\<in> f ` W\\<rbrakk>\n       \\<Longrightarrow> fa x = (0::'a)", "obtain y where w_fy: \"w = f y \" and y_in_W: \"y \\<in> W\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>w = f y; y \\<in> W\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using w"], ["proof (prove)\nusing this:\n  w \\<in> f ` W\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>w = f y; y \\<in> W\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fast"], ["proof (state)\nthis:\n  w = f y\n  y \\<in> W\n\ngoal (1 subgoal):\n 1. \\<And>fa x.\n       \\<lbrakk>(\\<Sum>x\\<in>f ` W. scaleC (fa x) x) = (0::'c);\n        x \\<in> f ` W\\<rbrakk>\n       \\<Longrightarrow> fa x = (0::'a)", "have \"- g w = t y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - g w = t y", "unfolding t_def w_fy"], ["proof (prove)\ngoal (1 subgoal):\n 1. - g (f y) = (if y \\<in> B then h y else - (g \\<circ> f) y)", "using y_in_W"], ["proof (prove)\nusing this:\n  y \\<in> W\n\ngoal (1 subgoal):\n 1. - g (f y) = (if y \\<in> B then h y else - (g \\<circ> f) y)", "unfolding W_def"], ["proof (prove)\nusing this:\n  y \\<in> C - B\n\ngoal (1 subgoal):\n 1. - g (f y) = (if y \\<in> B then h y else - (g \\<circ> f) y)", "by simp"], ["proof (state)\nthis:\n  - g w = t y\n\ngoal (1 subgoal):\n 1. \\<And>fa x.\n       \\<lbrakk>(\\<Sum>x\\<in>f ` W. scaleC (fa x) x) = (0::'c);\n        x \\<in> f ` W\\<rbrakk>\n       \\<Longrightarrow> fa x = (0::'a)", "also"], ["proof (state)\nthis:\n  - g w = t y\n\ngoal (1 subgoal):\n 1. \\<And>fa x.\n       \\<lbrakk>(\\<Sum>x\\<in>f ` W. scaleC (fa x) x) = (0::'c);\n        x \\<in> f ` W\\<rbrakk>\n       \\<Longrightarrow> fa x = (0::'a)", "have \"... = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t y = (0::'a)", "using coef_zero y_in_W"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>B \\<union> W. t x = (0::'a)\n  y \\<in> W\n\ngoal (1 subgoal):\n 1. t y = (0::'a)", "unfolding W_def"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>B \\<union> (C - B). t x = (0::'a)\n  y \\<in> C - B\n\ngoal (1 subgoal):\n 1. t y = (0::'a)", "by simp"], ["proof (state)\nthis:\n  t y = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>fa x.\n       \\<lbrakk>(\\<Sum>x\\<in>f ` W. scaleC (fa x) x) = (0::'c);\n        x \\<in> f ` W\\<rbrakk>\n       \\<Longrightarrow> fa x = (0::'a)", "finally"], ["proof (chain)\npicking this:\n  - g w = (0::'a)", "show \"g w = 0\""], ["proof (prove)\nusing this:\n  - g w = (0::'a)\n\ngoal (1 subgoal):\n 1. g w = (0::'a)", "by simp"], ["proof (state)\nthis:\n  g w = (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  l.vs2.independent (f ` W)\n\ngoal (1 subgoal):\n 1. f ` W \\<subseteq> range f", "qed auto"], ["proof (state)\nthis:\n  card (f ` W) = l.vs2.dim (range f)\n\ngoal (1 subgoal):\n 1. card (C - B) = l.vs2.dim (range f)", "finally"], ["proof (chain)\npicking this:\n  card W = l.vs2.dim (range f)", "show \"card (C - B) = l.vs2.dim (range f)\""], ["proof (prove)\nusing this:\n  card W = l.vs2.dim (range f)\n\ngoal (1 subgoal):\n 1. card (C - B) = l.vs2.dim (range f)", "unfolding W_def"], ["proof (prove)\nusing this:\n  card (C - B) = l.vs2.dim (range f)\n\ngoal (1 subgoal):\n 1. card (C - B) = l.vs2.dim (range f)", "."], ["proof (state)\nthis:\n  card (C - B) = l.vs2.dim (range f)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  local.dim ker_f + card (C - B) = local.dim ker_f + l.vs2.dim (range f)\n\ngoal (1 subgoal):\n 1. local.dimension = local.dim {x. f x = (0::'c)} + l.vs2.dim (range f)", "finally"], ["proof (chain)\npicking this:\n  local.dimension = local.dim ker_f + l.vs2.dim (range f)", "show ?thesis"], ["proof (prove)\nusing this:\n  local.dimension = local.dim ker_f + l.vs2.dim (range f)\n\ngoal (1 subgoal):\n 1. local.dimension = local.dim {x. f x = (0::'c)} + l.vs2.dim (range f)", "unfolding V_def ker_f_def"], ["proof (prove)\nusing this:\n  local.dimension = local.dim {x. f x = (0::'c)} + l.vs2.dim (range f)\n\ngoal (1 subgoal):\n 1. local.dimension = local.dim {x. f x = (0::'c)} + l.vs2.dim (range f)", "unfolding dim_UNIV"], ["proof (prove)\nusing this:\n  local.dimension = local.dim {x. f x = (0::'c)} + l.vs2.dim (range f)\n\ngoal (1 subgoal):\n 1. local.dimension = local.dim {x. f x = (0::'c)} + l.vs2.dim (range f)", "."], ["proof (state)\nthis:\n  local.dimension = local.dim {x. f x = (0::'c)} + l.vs2.dim (range f)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  local.dimension = local.dim {x. f x = (0::'c)} + l.vs2.dim (range f)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "subsection\\<open>The rank nullity theorem for matrices\\<close>"], ["", "text\\<open>The proof of the theorem for matrices\n  is direct, as a consequence of the ``rank nullity theorem''.\\<close>"], ["", "lemma rank_nullity_theorem_matrices:\n  fixes A::\"'a::{field}^'cols::{finite, wellorder}^'rows\"\n  shows \"ncols A = vec.dim (null_space A) + vec.dim (col_space A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ncols A = vec.dim (null_space A) + vec.dim (col_space A)", "using vec.rank_nullity_theorem[OF matrix_vector_mul_linear_gen, of A]"], ["proof (prove)\nusing this:\n  finite_dimensional_vector_space.dimension cart_basis =\n  vec.dim {x. A *v x = 0} + vec.dim (range ((*v) A))\n\ngoal (1 subgoal):\n 1. ncols A = vec.dim (null_space A) + vec.dim (col_space A)", "apply (subst (2 3) matrix_of_matrix_vector_mul [of A, symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_dimensional_vector_space.dimension cart_basis =\n    vec.dim {x. A *v x = 0} + vec.dim (range ((*v) A)) \\<Longrightarrow>\n    ncols A =\n    vec.dim (null_space (matrix ((*v) A))) +\n    vec.dim (col_space (matrix ((*v) A)))", "unfolding null_space_eq_ker[OF matrix_vector_mul_linear_gen]"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_dimensional_vector_space.dimension cart_basis =\n    vec.dim {x. A *v x = 0} + vec.dim (range ((*v) A)) \\<Longrightarrow>\n    ncols A =\n    vec.dim {x. A *v x = 0} + vec.dim (col_space (matrix ((*v) A)))", "unfolding col_space_eq_range [OF matrix_vector_mul_linear_gen]"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_dimensional_vector_space.dimension cart_basis =\n    vec.dim {x. A *v x = 0} + vec.dim (range ((*v) A)) \\<Longrightarrow>\n    ncols A = vec.dim {x. A *v x = 0} + vec.dim (range ((*v) A))", "unfolding vec.dimension_def ncols_def card_cart_basis"], ["proof (prove)\ngoal (1 subgoal):\n 1. CARD('cols) =\n    vec.dim {x. A *v x = 0} + vec.dim (range ((*v) A)) \\<Longrightarrow>\n    CARD('cols) = vec.dim {x. A *v x = 0} + vec.dim (range ((*v) A))", "by simp"], ["", "end"]]}