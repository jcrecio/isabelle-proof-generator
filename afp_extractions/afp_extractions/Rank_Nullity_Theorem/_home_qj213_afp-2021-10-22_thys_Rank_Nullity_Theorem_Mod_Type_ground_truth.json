{"file_name": "/home/qj213/afp-2021-10-22/thys/Rank_Nullity_Theorem/Mod_Type.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Rank_Nullity_Theorem", "problem_names": ["lemma size0: \"0 < int CARD ('a)\"", "lemmas definitions =\n  zero_def one_def add_def mult_def minus_def diff_def", "lemma Rep_less_n: \"Rep x < int CARD ('a)\"", "lemma Rep_le_n: \"Rep x \\<le> int CARD ('a)\"", "lemma Rep_inject_sym: \"x = y \\<longleftrightarrow> Rep x = Rep y\"", "lemma Rep_inverse: \"Abs (Rep x) = x\"", "lemma Abs_inverse: \"m \\<in> {0..<int CARD ('a)} \\<Longrightarrow> Rep (Abs m) = m\"", "lemma Rep_Abs_mod: \"Rep (Abs (m mod int CARD ('a))) = m mod int CARD ('a)\"", "lemma Rep_Abs_0: \"Rep (Abs 0) = 0\"", "lemma Rep_0: \"Rep 0 = 0\"", "lemma Rep_Abs_1: \"Rep (Abs 1) = 1\"", "lemma Rep_1: \"Rep 1 = 1\"", "lemma Rep_mod: \"Rep x mod int CARD ('a) = Rep x\"", "lemmas Rep_simps =\n  Rep_inject_sym Rep_inverse Rep_Abs_mod Rep_mod Rep_Abs_0 Rep_Abs_1", "lemma bij_Rep: \"bij_betw (Rep) (UNIV::'a set) {0..<int CARD('a)}\"", "lemma mono_Rep: \"mono Rep\"", "lemma Rep_ge_0: \"0 \\<le> Rep x\"", "lemma bij_Abs: \"bij_betw (Abs) {0..<int CARD('a)} (UNIV::'a set)\"", "lemma bij_from_nat: \"bij_betw (from_nat) {0..<CARD('a)} (UNIV::'a set)\"", "lemma to_nat_is_inv: \"the_inv_into {0..<CARD('a)} (from_nat::nat=>'a) = (to_nat::'a=>nat)\"", "lemma bij_to_nat: \"bij_betw (to_nat) (UNIV::'a set) {0..<CARD('a)}\"", "lemma finite_mod_type: \"finite (UNIV::'a set)\"", "lemma least_0: \"(LEAST n. n \\<in> (UNIV::'a set)) = 0\"", "lemma add_to_nat_def: \"x + y = from_nat (to_nat x + to_nat y)\"", "lemma to_nat_1: \"to_nat 1 = 1\"", "lemma add_def':\n  shows \"x + y = Abs' (Rep x + Rep y)\"", "lemma Abs'_0:\n  shows \"Abs' (CARD('a))=(0::'a)\"", "lemma Rep_plus_one_le_card:\n  assumes a: \"a + 1 \\<noteq> 0\"\n  shows \"(Rep a) + 1 < CARD ('a)\"", "lemma to_nat_plus_one_less_card: \"\\<forall>a. a+1 \\<noteq> 0 --> to_nat a + 1 < CARD('a)\"", "lemma strict_mono_to_nat: \"strict_mono to_nat\"", "lemma to_nat_eq [simp]: \"to_nat x = to_nat y \\<longleftrightarrow> x = y\"", "lemma mod_type_forall_eq [simp]: \"(\\<forall>j::'a. (to_nat j)<CARD('a) \\<longrightarrow> P j) = (\\<forall>a. P a)\"", "lemma to_nat_from_nat:\n  assumes t:\"to_nat j = k\"\n  shows \"from_nat k = j\"", "lemma to_nat_mono:\n  assumes ab: \"a < b\"\n  shows \"to_nat a < to_nat b\"", "lemma to_nat_mono':\n  assumes ab: \"a \\<le> b\"\n  shows \"to_nat a \\<le> to_nat b\"", "lemma least_mod_type:\n  shows \"0 \\<le> (n::'a)\"", "lemma to_nat_from_nat_id:\n  assumes x: \"x<CARD('a)\"\n  shows \"to_nat ((from_nat x)::'a) = x\"", "lemma from_nat_to_nat_id[simp]:\n  shows \"from_nat (to_nat x) = x\"", "lemma from_nat_to_nat:\n  assumes t:\"from_nat j = k\" and j: \"j<CARD('a)\"\n  shows \"to_nat k = j\"", "lemma from_nat_mono:\n  assumes i_le_j: \"i<j\" and j: \"j<CARD('a)\"\n  shows \"(from_nat i::'a) < from_nat j\"", "lemma from_nat_mono':\n  assumes i_le_j: \"i \\<le> j\" and \"j<CARD ('a)\"\n  shows \"(from_nat i::'a) \\<le> from_nat j\"", "lemma to_nat_suc:\n  assumes \"to_nat (x)+1 < CARD ('a)\"\n  shows \"to_nat (x + 1::'a) = (to_nat x) + 1\"", "lemma to_nat_le:\n  assumes \"y < from_nat k\"\n  shows  \"to_nat y < k\"", "lemma le_Suc:\n  assumes ab: \"a < (b::'a)\"\n  shows \"a + 1 \\<le> b\"", "lemma le_Suc':\nassumes ab: \"a + 1 \\<le> b\"\n  and less_card: \"(to_nat a) + 1 < CARD ('a)\"\n  shows \"a < b\"", "lemma Suc_le:\n  assumes less_card: \"(to_nat a) + 1 < CARD ('a)\"\n  shows \"a < a + 1\"", "lemma Suc_le':\n  fixes a::'a\n  assumes \"a + 1 \\<noteq> 0\"\n  shows \"a < a + 1\"", "lemma from_nat_not_eq:\n  assumes a_eq_to_nat: \"a \\<noteq> to_nat b\"\n  and a_less_card: \"a<CARD('a)\"\n  shows \"from_nat a \\<noteq> b\"", "lemma Suc_less:\n  fixes i::'a\n  assumes \"i<j\"\n  and \"i+1 \\<noteq> j\"\n  shows \"i+1<j\"", "lemma Greatest_is_minus_1: \"\\<forall>a::'a. a \\<le> -1\"", "lemma a_eq_minus_1: \"\\<forall>a::'a. a+1 = 0 \\<longrightarrow> a = -1\"", "lemma forall_from_nat_rw:\n  shows \"(\\<forall>x\\<in>{0..<CARD('a)}. P (from_nat x::'a)) = (\\<forall>x. P (from_nat x))\"", "lemma from_nat_eq_imp_eq:\n  assumes f_eq: \"from_nat x = (from_nat xa::'a)\"\nand x: \"x<CARD('a)\" and xa: \"xa<CARD('a)\"\n  shows \"x=xa\"", "lemma to_nat_less_card:\n  fixes j::\"'a\"\n  shows \"to_nat j < CARD ('a)\"", "lemma from_nat_0: \"from_nat 0 = 0\"", "lemma to_nat_0: \"to_nat 0 = 0\"", "lemma to_nat_eq_0: \"(to_nat x = 0) = (x = 0)\"", "lemma suc_not_zero:\n  assumes \"to_nat a + 1 \\<noteq> CARD('a)\"\n  shows \"a+1 \\<noteq> 0\"", "lemma from_nat_suc:\nshows \"from_nat (j + 1) = from_nat j + 1\"", "lemma to_nat_plus_1_set:\nshows \"to_nat a + 1 \\<in> {1..<CARD('a)+1}\"", "lemma from_nat_CARD:\n  shows \"from_nat (CARD('a)) = (0::'a::{mod_type})\""], "translations": [["", "lemma size0: \"0 < int CARD ('a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < int CARD('a)", "using size1"], ["proof (prove)\nusing this:\n  1 < int CARD('a)\n\ngoal (1 subgoal):\n 1. 0 < int CARD('a)", "by simp"], ["", "lemmas definitions =\n  zero_def one_def add_def mult_def minus_def diff_def"], ["", "lemma Rep_less_n: \"Rep x < int CARD ('a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep x < int CARD('a)", "by (rule type_definition.Rep [OF type, simplified, THEN conjunct2])"], ["", "lemma Rep_le_n: \"Rep x \\<le> int CARD ('a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep x \\<le> int CARD('a)", "by (rule Rep_less_n [THEN order_less_imp_le])"], ["", "lemma Rep_inject_sym: \"x = y \\<longleftrightarrow> Rep x = Rep y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x = y) = (Rep x = Rep y)", "by (rule type_definition.Rep_inject [OF type, symmetric])"], ["", "lemma Rep_inverse: \"Abs (Rep x) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs (Rep x) = x", "by (rule type_definition.Rep_inverse [OF type])"], ["", "lemma Abs_inverse: \"m \\<in> {0..<int CARD ('a)} \\<Longrightarrow> Rep (Abs m) = m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<in> {0..<int CARD('a)} \\<Longrightarrow> Rep (Abs m) = m", "by (rule type_definition.Abs_inverse [OF type])"], ["", "lemma Rep_Abs_mod: \"Rep (Abs (m mod int CARD ('a))) = m mod int CARD ('a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep (Abs (m mod int CARD('a))) = m mod int CARD('a)", "by (simp add: Abs_inverse pos_mod_conj [OF size0])"], ["", "lemma Rep_Abs_0: \"Rep (Abs 0) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep (Abs 0) = 0", "apply (rule Abs_inverse [of 0])"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<in> {0..<int CARD('a)}", "using size0"], ["proof (prove)\nusing this:\n  0 < int CARD('a)\n\ngoal (1 subgoal):\n 1. 0 \\<in> {0..<int CARD('a)}", "by simp"], ["", "lemma Rep_0: \"Rep 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep (0::'a) = 0", "by (simp add: zero_def Rep_Abs_0)"], ["", "lemma Rep_Abs_1: \"Rep (Abs 1) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep (Abs 1) = 1", "by (simp add: Abs_inverse size1)"], ["", "lemma Rep_1: \"Rep 1 = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep (1::'a) = 1", "by (simp add: one_def Rep_Abs_1)"], ["", "lemma Rep_mod: \"Rep x mod int CARD ('a) = Rep x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep x mod int CARD('a) = Rep x", "apply (rule_tac x=x in type_definition.Abs_cases [OF type])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>x = Abs y; y \\<in> {0..<int CARD('a)}\\<rbrakk>\n       \\<Longrightarrow> Rep x mod int CARD('a) = Rep x", "apply (simp add: type_definition.Abs_inverse [OF type])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemmas Rep_simps =\n  Rep_inject_sym Rep_inverse Rep_Abs_mod Rep_mod Rep_Abs_0 Rep_Abs_1"], ["", "subsection\\<open>Conversion between a modular class and the subset of natural numbers associated.\\<close>"], ["", "text\\<open>Definitions to make transformations among elements of a modular class and naturals\\<close>"], ["", "definition to_nat :: \"'a => nat\"\n  where \"to_nat = nat \\<circ> Rep\""], ["", "definition Abs' :: \"int => 'a\"\n  where \"Abs' x = Abs(x mod int CARD ('a))\""], ["", "definition from_nat :: \"nat \\<Rightarrow> 'a\"\n  where \"from_nat = (Abs' \\<circ> int)\""], ["", "lemma bij_Rep: \"bij_betw (Rep) (UNIV::'a set) {0..<int CARD('a)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bij_betw Rep UNIV {0..<int CARD('a)}", "proof (unfold bij_betw_def, rule conjI)"], ["proof (state)\ngoal (2 subgoals):\n 1. inj Rep\n 2. range Rep = {0..<int CARD('a)}", "show \"inj Rep\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj Rep", "by (metis strict_mono_imp_inj_on strict_mono_Rep)"], ["proof (state)\nthis:\n  inj Rep\n\ngoal (1 subgoal):\n 1. range Rep = {0..<int CARD('a)}", "show \"range Rep = {0..<int CARD('a)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. range Rep = {0..<int CARD('a)}", "using Typedef.type_definition.Rep_range[OF type]"], ["proof (prove)\nusing this:\n  range Rep = {0..<int CARD('a)}\n\ngoal (1 subgoal):\n 1. range Rep = {0..<int CARD('a)}", "."], ["proof (state)\nthis:\n  range Rep = {0..<int CARD('a)}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mono_Rep: \"mono Rep\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono Rep", "by (metis strict_mono_Rep strict_mono_mono)"], ["", "lemma Rep_ge_0: \"0 \\<le> Rep x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> Rep x", "using bij_Rep"], ["proof (prove)\nusing this:\n  bij_betw Rep UNIV {0..<int CARD('a)}\n\ngoal (1 subgoal):\n 1. 0 \\<le> Rep x", "unfolding bij_betw_def"], ["proof (prove)\nusing this:\n  inj Rep \\<and> range Rep = {0..<int CARD('a)}\n\ngoal (1 subgoal):\n 1. 0 \\<le> Rep x", "by auto"], ["", "lemma bij_Abs: \"bij_betw (Abs) {0..<int CARD('a)} (UNIV::'a set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bij_betw Abs {0..<int CARD('a)} UNIV", "proof (unfold bij_betw_def, rule conjI)"], ["proof (state)\ngoal (2 subgoals):\n 1. inj_on Abs {0..<int CARD('a)}\n 2. Abs ` {0..<int CARD('a)} = UNIV", "show \"inj_on Abs {0..<int CARD('a)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on Abs {0..<int CARD('a)}", "by (metis inj_on_inverseI type type_definition.Abs_inverse)"], ["proof (state)\nthis:\n  inj_on Abs {0..<int CARD('a)}\n\ngoal (1 subgoal):\n 1. Abs ` {0..<int CARD('a)} = UNIV", "show \"Abs ` {0..<int CARD('a)} = (UNIV::'a set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs ` {0..<int CARD('a)} = UNIV", "by (metis type type_definition.univ)"], ["proof (state)\nthis:\n  Abs ` {0..<int CARD('a)} = UNIV\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary bij_Abs': \"bij_betw (Abs') {0..<int CARD('a)} (UNIV::'a set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bij_betw Abs' {0..<int CARD('a)} UNIV", "proof (unfold bij_betw_def, rule conjI)"], ["proof (state)\ngoal (2 subgoals):\n 1. inj_on Abs' {0..<int CARD('a)}\n 2. Abs' ` {0..<int CARD('a)} = UNIV", "show \"inj_on Abs' {0..<int CARD('a)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on Abs' {0..<int CARD('a)}", "unfolding inj_on_def Abs'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{0..<int CARD('a)}.\n       \\<forall>y\\<in>{0..<int CARD('a)}.\n          Abs (x mod int CARD('a)) =\n          Abs (y mod int CARD('a)) \\<longrightarrow>\n          x = y", "by (auto, metis Rep_Abs_mod mod_pos_pos_trivial)"], ["proof (state)\nthis:\n  inj_on Abs' {0..<int CARD('a)}\n\ngoal (1 subgoal):\n 1. Abs' ` {0..<int CARD('a)} = UNIV", "show \"Abs' ` {0..<int CARD('a)} = (UNIV::'a set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs' ` {0..<int CARD('a)} = UNIV", "proof (unfold image_def Abs'_def, auto)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. \\<exists>xa\\<in>{0..<int CARD('a)}. x = Abs xa", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. \\<exists>xa\\<in>{0..<int CARD('a)}. x = Abs xa", "show \"\\<exists>xa\\<in>{0..<int CARD('a)}. x = Abs xa\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>xa\\<in>{0..<int CARD('a)}. x = Abs xa", "by (rule bexI[of _ \"Rep x\"], auto simp add: Rep_less_n[of x] Rep_ge_0[of x], metis Rep_inverse)"], ["proof (state)\nthis:\n  \\<exists>xa\\<in>{0..<int CARD('a)}. x = Abs xa\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Abs' ` {0..<int CARD('a)} = UNIV\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bij_from_nat: \"bij_betw (from_nat) {0..<CARD('a)} (UNIV::'a set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bij_betw mod_type_class.from_nat {0..<CARD('a)} UNIV", "proof (unfold bij_betw_def, rule conjI)"], ["proof (state)\ngoal (2 subgoals):\n 1. inj_on mod_type_class.from_nat {0..<CARD('a)}\n 2. mod_type_class.from_nat ` {0..<CARD('a)} = UNIV", "have set_eq: \"{0::int..<int CARD('a)} = int` {0..<CARD('a)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {0..<int CARD('a)} = int ` {0..<CARD('a)}", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>0 \\<le> x; x < int CARD('a)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> int ` {0..<CARD('a)}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>0 \\<le> x; x < int CARD('a)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> int ` {0..<CARD('a)}", "fix x::int"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>0 \\<le> x; x < int CARD('a)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> int ` {0..<CARD('a)}", "assume x1: \"(0::int) \\<le> x\" and x2: \"x < int CARD('a)\""], ["proof (state)\nthis:\n  0 \\<le> x\n  x < int CARD('a)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>0 \\<le> x; x < int CARD('a)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> int ` {0..<CARD('a)}", "show \"x \\<in> int ` {0::nat..<CARD('a)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> int ` {0..<CARD('a)}", "proof (unfold image_def, auto, rule bexI[of _ \"nat x\"])"], ["proof (state)\ngoal (2 subgoals):\n 1. x = int (nat x)\n 2. nat x \\<in> {0..<CARD('a)}", "show \" x = int (nat x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = int (nat x)", "using x1"], ["proof (prove)\nusing this:\n  0 \\<le> x\n\ngoal (1 subgoal):\n 1. x = int (nat x)", "by auto"], ["proof (state)\nthis:\n  x = int (nat x)\n\ngoal (1 subgoal):\n 1. nat x \\<in> {0..<CARD('a)}", "show \"nat x \\<in> {0::nat..<CARD('a)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nat x \\<in> {0..<CARD('a)}", "using x1 x2"], ["proof (prove)\nusing this:\n  0 \\<le> x\n  x < int CARD('a)\n\ngoal (1 subgoal):\n 1. nat x \\<in> {0..<CARD('a)}", "by auto"], ["proof (state)\nthis:\n  nat x \\<in> {0..<CARD('a)}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x \\<in> int ` {0..<CARD('a)}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  {0..<int CARD('a)} = int ` {0..<CARD('a)}\n\ngoal (2 subgoals):\n 1. inj_on mod_type_class.from_nat {0..<CARD('a)}\n 2. mod_type_class.from_nat ` {0..<CARD('a)} = UNIV", "show \"inj_on (from_nat::nat\\<Rightarrow>'a) {0::nat..<CARD('a)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on mod_type_class.from_nat {0..<CARD('a)}", "proof (unfold from_nat_def , rule comp_inj_on)"], ["proof (state)\ngoal (2 subgoals):\n 1. inj_on int {0..<CARD('a)}\n 2. inj_on Abs' (int ` {0..<CARD('a)})", "show \"inj_on int {0::nat..<CARD('a)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on int {0..<CARD('a)}", "by (metis inj_of_nat subset_inj_on top_greatest)"], ["proof (state)\nthis:\n  inj_on int {0..<CARD('a)}\n\ngoal (1 subgoal):\n 1. inj_on Abs' (int ` {0..<CARD('a)})", "show \"inj_on (Abs'::int=>'a) (int ` {0::nat..<CARD('a)})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on Abs' (int ` {0..<CARD('a)})", "using bij_Abs"], ["proof (prove)\nusing this:\n  bij_betw Abs {0..<int CARD('a)} UNIV\n\ngoal (1 subgoal):\n 1. inj_on Abs' (int ` {0..<CARD('a)})", "unfolding bij_betw_def set_eq"], ["proof (prove)\nusing this:\n  inj_on Abs (int ` {0..<CARD('a)}) \\<and> Abs ` int ` {0..<CARD('a)} = UNIV\n\ngoal (1 subgoal):\n 1. inj_on Abs' (int ` {0..<CARD('a)})", "by (metis (hide_lams, no_types) Abs'_def Abs_inverse Rep_inverse Rep_mod inj_on_def set_eq)"], ["proof (state)\nthis:\n  inj_on Abs' (int ` {0..<CARD('a)})\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  inj_on mod_type_class.from_nat {0..<CARD('a)}\n\ngoal (1 subgoal):\n 1. mod_type_class.from_nat ` {0..<CARD('a)} = UNIV", "show \"(from_nat::nat=>'a)` {0::nat..<CARD('a)} = UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.from_nat ` {0..<CARD('a)} = UNIV", "unfolding from_nat_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (Abs' \\<circ> int) ` {0..<CARD('a)} = UNIV", "using bij_Abs'"], ["proof (prove)\nusing this:\n  bij_betw Abs' {0..<int CARD('a)} UNIV\n\ngoal (1 subgoal):\n 1. (Abs' \\<circ> int) ` {0..<CARD('a)} = UNIV", "unfolding bij_betw_def set_eq o_def"], ["proof (prove)\nusing this:\n  inj_on Abs' (int ` {0..<CARD('a)}) \\<and>\n  Abs' ` int ` {0..<CARD('a)} = UNIV\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. Abs' (int x)) ` {0..<CARD('a)} = UNIV", "by blast"], ["proof (state)\nthis:\n  mod_type_class.from_nat ` {0..<CARD('a)} = UNIV\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma to_nat_is_inv: \"the_inv_into {0..<CARD('a)} (from_nat::nat=>'a) = (to_nat::'a=>nat)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. the_inv_into {0..<CARD('a)} mod_type_class.from_nat =\n    mod_type_class.to_nat", "proof (unfold the_inv_into_def fun_eq_iff from_nat_def to_nat_def o_def, clarify)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (THE y. y \\<in> {0..<CARD('a)} \\<and> Abs' (int y) = x) = nat (Rep x)", "fix x::\"'a\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (THE y. y \\<in> {0..<CARD('a)} \\<and> Abs' (int y) = x) = nat (Rep x)", "show \"(THE y::nat. y \\<in> {0::nat..<CARD('a)} \\<and> Abs' (int y) = x) = nat (Rep x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (THE y. y \\<in> {0..<CARD('a)} \\<and> Abs' (int y) = x) = nat (Rep x)", "proof (rule the_equality, auto)"], ["proof (state)\ngoal (5 subgoals):\n 1. 0 \\<le> Rep x \\<Longrightarrow> nat (Rep x) < CARD('a)\n 2. 0 \\<le> Rep x \\<Longrightarrow> Abs' (Rep x) = x\n 3. \\<not> 0 \\<le> Rep x \\<Longrightarrow> 0 < CARD('a)\n 4. \\<not> 0 \\<le> Rep x \\<Longrightarrow> Abs' 0 = x\n 5. \\<And>y.\n       \\<lbrakk>y < CARD('a); x = Abs' (int y)\\<rbrakk>\n       \\<Longrightarrow> y = nat (Rep (Abs' (int y)))", "show \" Abs' (Rep x) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs' (Rep x) = x", "by (metis Abs'_def Rep_inverse Rep_mod)"], ["proof (state)\nthis:\n  Abs' (Rep x) = x\n\ngoal (4 subgoals):\n 1. 0 \\<le> Rep x \\<Longrightarrow> nat (Rep x) < CARD('a)\n 2. \\<not> 0 \\<le> Rep x \\<Longrightarrow> 0 < CARD('a)\n 3. \\<not> 0 \\<le> Rep x \\<Longrightarrow> Abs' 0 = x\n 4. \\<And>y.\n       \\<lbrakk>y < CARD('a); x = Abs' (int y)\\<rbrakk>\n       \\<Longrightarrow> y = nat (Rep (Abs' (int y)))", "show \"nat (Rep x) < CARD('a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nat (Rep x) < CARD('a)", "by (metis (full_types) Rep_less_n nat_int size0 zless_nat_conj)"], ["proof (state)\nthis:\n  nat (Rep x) < CARD('a)\n\ngoal (3 subgoals):\n 1. \\<not> 0 \\<le> Rep x \\<Longrightarrow> 0 < CARD('a)\n 2. \\<not> 0 \\<le> Rep x \\<Longrightarrow> Abs' 0 = x\n 3. \\<And>y.\n       \\<lbrakk>y < CARD('a); x = Abs' (int y)\\<rbrakk>\n       \\<Longrightarrow> y = nat (Rep (Abs' (int y)))", "assume x:  \"\\<not> (0::int) \\<le> Rep x\""], ["proof (state)\nthis:\n  \\<not> 0 \\<le> Rep x\n\ngoal (3 subgoals):\n 1. \\<not> 0 \\<le> Rep x \\<Longrightarrow> 0 < CARD('a)\n 2. \\<not> 0 \\<le> Rep x \\<Longrightarrow> Abs' 0 = x\n 3. \\<And>y.\n       \\<lbrakk>y < CARD('a); x = Abs' (int y)\\<rbrakk>\n       \\<Longrightarrow> y = nat (Rep (Abs' (int y)))", "show \"(0::nat) < CARD('a)\" and \"Abs' (0::int) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < CARD('a) &&& Abs' 0 = x", "using Rep_ge_0 x"], ["proof (prove)\nusing this:\n  0 \\<le> Rep ?x\n  \\<not> 0 \\<le> Rep x\n\ngoal (1 subgoal):\n 1. 0 < CARD('a) &&& Abs' 0 = x", "by auto"], ["proof (state)\nthis:\n  0 < CARD('a)\n  Abs' 0 = x\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>y < CARD('a); x = Abs' (int y)\\<rbrakk>\n       \\<Longrightarrow> y = nat (Rep (Abs' (int y)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>y < CARD('a); x = Abs' (int y)\\<rbrakk>\n       \\<Longrightarrow> y = nat (Rep (Abs' (int y)))", "fix y::nat"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>y < CARD('a); x = Abs' (int y)\\<rbrakk>\n       \\<Longrightarrow> y = nat (Rep (Abs' (int y)))", "assume y: \"y < CARD('a)\""], ["proof (state)\nthis:\n  y < CARD('a)\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>y < CARD('a); x = Abs' (int y)\\<rbrakk>\n       \\<Longrightarrow> y = nat (Rep (Abs' (int y)))", "have \"(Rep(Abs'(int y)::'a)) = (Rep((Abs(int y mod int CARD('a)))::'a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep (Abs' (int y)) = Rep (Abs (int y mod int CARD('a)))", "unfolding Abs'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep (Abs (int y mod int CARD('a))) = Rep (Abs (int y mod int CARD('a)))", ".."], ["proof (state)\nthis:\n  Rep (Abs' (int y)) = Rep (Abs (int y mod int CARD('a)))\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>y < CARD('a); x = Abs' (int y)\\<rbrakk>\n       \\<Longrightarrow> y = nat (Rep (Abs' (int y)))", "also"], ["proof (state)\nthis:\n  Rep (Abs' (int y)) = Rep (Abs (int y mod int CARD('a)))\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>y < CARD('a); x = Abs' (int y)\\<rbrakk>\n       \\<Longrightarrow> y = nat (Rep (Abs' (int y)))", "have \"... =  (Rep (Abs (int y)::'a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep (Abs (int y mod int CARD('a))) = Rep (Abs (int y))", "using zmod_int[of y \"CARD('a)\"]"], ["proof (prove)\nusing this:\n  int (y mod CARD('a)) = int y mod int CARD('a)\n\ngoal (1 subgoal):\n 1. Rep (Abs (int y mod int CARD('a))) = Rep (Abs (int y))", "using y mod_less"], ["proof (prove)\nusing this:\n  int (y mod CARD('a)) = int y mod int CARD('a)\n  y < CARD('a)\n  ?m < ?n \\<Longrightarrow> ?m mod ?n = ?m\n\ngoal (1 subgoal):\n 1. Rep (Abs (int y mod int CARD('a))) = Rep (Abs (int y))", "by auto"], ["proof (state)\nthis:\n  Rep (Abs (int y mod int CARD('a))) = Rep (Abs (int y))\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>y < CARD('a); x = Abs' (int y)\\<rbrakk>\n       \\<Longrightarrow> y = nat (Rep (Abs' (int y)))", "also"], ["proof (state)\nthis:\n  Rep (Abs (int y mod int CARD('a))) = Rep (Abs (int y))\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>y < CARD('a); x = Abs' (int y)\\<rbrakk>\n       \\<Longrightarrow> y = nat (Rep (Abs' (int y)))", "have \"... =  (int y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep (Abs (int y)) = int y", "proof (rule Abs_inverse)"], ["proof (state)\ngoal (1 subgoal):\n 1. int y \\<in> {0..<int CARD('a)}", "show \"int y \\<in> {0::int..<int CARD('a)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int y \\<in> {0..<int CARD('a)}", "using y"], ["proof (prove)\nusing this:\n  y < CARD('a)\n\ngoal (1 subgoal):\n 1. int y \\<in> {0..<int CARD('a)}", "by auto"], ["proof (state)\nthis:\n  int y \\<in> {0..<int CARD('a)}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Rep (Abs (int y)) = int y\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>y < CARD('a); x = Abs' (int y)\\<rbrakk>\n       \\<Longrightarrow> y = nat (Rep (Abs' (int y)))", "finally"], ["proof (chain)\npicking this:\n  Rep (Abs' (int y)) = int y", "show \"y = nat (Rep (Abs' (int y)::'a))\""], ["proof (prove)\nusing this:\n  Rep (Abs' (int y)) = int y\n\ngoal (1 subgoal):\n 1. y = nat (Rep (Abs' (int y)))", "by (metis nat_int)"], ["proof (state)\nthis:\n  y = nat (Rep (Abs' (int y)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (THE y. y \\<in> {0..<CARD('a)} \\<and> Abs' (int y) = x) = nat (Rep x)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bij_to_nat: \"bij_betw (to_nat) (UNIV::'a set) {0..<CARD('a)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bij_betw mod_type_class.to_nat UNIV {0..<CARD('a)}", "using bij_betw_the_inv_into[OF bij_from_nat]"], ["proof (prove)\nusing this:\n  bij_betw (the_inv_into {0..<CARD('a)} mod_type_class.from_nat) UNIV\n   {0..<CARD('a)}\n\ngoal (1 subgoal):\n 1. bij_betw mod_type_class.to_nat UNIV {0..<CARD('a)}", "unfolding to_nat_is_inv"], ["proof (prove)\nusing this:\n  bij_betw mod_type_class.to_nat UNIV {0..<CARD('a)}\n\ngoal (1 subgoal):\n 1. bij_betw mod_type_class.to_nat UNIV {0..<CARD('a)}", "."], ["", "lemma finite_mod_type: \"finite (UNIV::'a set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite UNIV", "using finite_imageD[of \"to_nat\" \"UNIV::'a set\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>finite (range mod_type_class.to_nat);\n   inj mod_type_class.to_nat\\<rbrakk>\n  \\<Longrightarrow> finite UNIV\n\ngoal (1 subgoal):\n 1. finite UNIV", "using bij_to_nat"], ["proof (prove)\nusing this:\n  \\<lbrakk>finite (range mod_type_class.to_nat);\n   inj mod_type_class.to_nat\\<rbrakk>\n  \\<Longrightarrow> finite UNIV\n  bij_betw mod_type_class.to_nat UNIV {0..<CARD('a)}\n\ngoal (1 subgoal):\n 1. finite UNIV", "unfolding bij_betw_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>finite (range mod_type_class.to_nat);\n   inj mod_type_class.to_nat\\<rbrakk>\n  \\<Longrightarrow> finite UNIV\n  inj mod_type_class.to_nat \\<and>\n  range mod_type_class.to_nat = {0..<CARD('a)}\n\ngoal (1 subgoal):\n 1. finite UNIV", "by auto"], ["", "subclass (in mod_type) finite"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.finite TYPE('a)", "by (intro_classes, rule finite_mod_type)"], ["", "lemma least_0: \"(LEAST n. n \\<in> (UNIV::'a set)) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST n. n \\<in> UNIV) = (0::'a)", "proof (rule Least_equality, auto)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y. (0::'a) \\<le> y", "fix y::\"'a\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y. (0::'a) \\<le> y", "have \"(0::'a) \\<le> Abs (Rep y mod int CARD('a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) \\<le> Abs (Rep y mod int CARD('a))", "using strict_mono_Rep"], ["proof (prove)\nusing this:\n  strict_mono Rep\n\ngoal (1 subgoal):\n 1. (0::'a) \\<le> Abs (Rep y mod int CARD('a))", "unfolding strict_mono_def"], ["proof (prove)\nusing this:\n  \\<forall>x y. x < y \\<longrightarrow> Rep x < Rep y\n\ngoal (1 subgoal):\n 1. (0::'a) \\<le> Abs (Rep y mod int CARD('a))", "by (metis (hide_lams, mono_tags) Rep_0 Rep_ge_0 strict_mono_Rep strict_mono_less_eq)"], ["proof (state)\nthis:\n  (0::'a) \\<le> Abs (Rep y mod int CARD('a))\n\ngoal (1 subgoal):\n 1. \\<And>y. (0::'a) \\<le> y", "also"], ["proof (state)\nthis:\n  (0::'a) \\<le> Abs (Rep y mod int CARD('a))\n\ngoal (1 subgoal):\n 1. \\<And>y. (0::'a) \\<le> y", "have \"... = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs (Rep y mod int CARD('a)) = y", "by (metis Rep_inverse Rep_mod)"], ["proof (state)\nthis:\n  Abs (Rep y mod int CARD('a)) = y\n\ngoal (1 subgoal):\n 1. \\<And>y. (0::'a) \\<le> y", "finally"], ["proof (chain)\npicking this:\n  (0::'a) \\<le> y", "show \"(0::'a) \\<le> y\""], ["proof (prove)\nusing this:\n  (0::'a) \\<le> y\n\ngoal (1 subgoal):\n 1. (0::'a) \\<le> y", "."], ["proof (state)\nthis:\n  (0::'a) \\<le> y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma add_to_nat_def: \"x + y = from_nat (to_nat x + to_nat y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x + y =\n    mod_type_class.from_nat\n     (mod_type_class.to_nat x + mod_type_class.to_nat y)", "unfolding from_nat_def to_nat_def o_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. x + y = Abs' (int (nat (Rep x) + nat (Rep y)))", "using Rep_ge_0[of x]"], ["proof (prove)\nusing this:\n  0 \\<le> Rep x\n\ngoal (1 subgoal):\n 1. x + y = Abs' (int (nat (Rep x) + nat (Rep y)))", "using Rep_ge_0[of y]"], ["proof (prove)\nusing this:\n  0 \\<le> Rep x\n  0 \\<le> Rep y\n\ngoal (1 subgoal):\n 1. x + y = Abs' (int (nat (Rep x) + nat (Rep y)))", "using Rep_less_n[of x] Rep_less_n[of y]"], ["proof (prove)\nusing this:\n  0 \\<le> Rep x\n  0 \\<le> Rep y\n  Rep x < int CARD('a)\n  Rep y < int CARD('a)\n\ngoal (1 subgoal):\n 1. x + y = Abs' (int (nat (Rep x) + nat (Rep y)))", "unfolding Abs'_def"], ["proof (prove)\nusing this:\n  0 \\<le> Rep x\n  0 \\<le> Rep y\n  Rep x < int CARD('a)\n  Rep y < int CARD('a)\n\ngoal (1 subgoal):\n 1. x + y = Abs (int (nat (Rep x) + nat (Rep y)) mod int CARD('a))", "unfolding add_def[of x y]"], ["proof (prove)\nusing this:\n  0 \\<le> Rep x\n  0 \\<le> Rep y\n  Rep x < int CARD('a)\n  Rep y < int CARD('a)\n\ngoal (1 subgoal):\n 1. Abs ((Rep x + Rep y) mod int CARD('a)) =\n    Abs (int (nat (Rep x) + nat (Rep y)) mod int CARD('a))", "by auto"], ["", "lemma to_nat_1: \"to_nat 1 = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.to_nat (1::'a) = 1", "by (simp add: to_nat_def Rep_1)"], ["", "lemma add_def':\n  shows \"x + y = Abs' (Rep x + Rep y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x + y = Abs' (Rep x + Rep y)", "unfolding Abs'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. x + y = Abs ((Rep x + Rep y) mod int CARD('a))", "using add_def"], ["proof (prove)\nusing this:\n  ?x + ?y = Abs ((Rep ?x + Rep ?y) mod int CARD('a))\n\ngoal (1 subgoal):\n 1. x + y = Abs ((Rep x + Rep y) mod int CARD('a))", "by simp"], ["", "lemma Abs'_0:\n  shows \"Abs' (CARD('a))=(0::'a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs' (int CARD('a)) = (0::'a)", "by (metis (hide_lams, mono_tags) Abs'_def mod_self zero_def)"], ["", "lemma Rep_plus_one_le_card:\n  assumes a: \"a + 1 \\<noteq> 0\"\n  shows \"(Rep a) + 1 < CARD ('a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep a + 1 < int CARD('a)", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> Rep a + 1 < int CARD('a) \\<Longrightarrow> False", "assume \"\\<not> Rep a + 1 < CARD('a)\""], ["proof (state)\nthis:\n  \\<not> Rep a + 1 < int CARD('a)\n\ngoal (1 subgoal):\n 1. \\<not> Rep a + 1 < int CARD('a) \\<Longrightarrow> False", "hence to_nat_eq_card: \"Rep a + 1 = CARD('a)\""], ["proof (prove)\nusing this:\n  \\<not> Rep a + 1 < int CARD('a)\n\ngoal (1 subgoal):\n 1. Rep a + 1 = int CARD('a)", "using Rep_less_n"], ["proof (prove)\nusing this:\n  \\<not> Rep a + 1 < int CARD('a)\n  Rep ?x < int CARD('a)\n\ngoal (1 subgoal):\n 1. Rep a + 1 = int CARD('a)", "by (simp add: add1_zle_eq order_class.less_le)"], ["proof (state)\nthis:\n  Rep a + 1 = int CARD('a)\n\ngoal (1 subgoal):\n 1. \\<not> Rep a + 1 < int CARD('a) \\<Longrightarrow> False", "have \"a+1 = Abs' (Rep a + Rep (1::'a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a + (1::'a) = Abs' (Rep a + Rep (1::'a))", "using add_def'"], ["proof (prove)\nusing this:\n  ?x + ?y = Abs' (Rep ?x + Rep ?y)\n\ngoal (1 subgoal):\n 1. a + (1::'a) = Abs' (Rep a + Rep (1::'a))", "by auto"], ["proof (state)\nthis:\n  a + (1::'a) = Abs' (Rep a + Rep (1::'a))\n\ngoal (1 subgoal):\n 1. \\<not> Rep a + 1 < int CARD('a) \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  a + (1::'a) = Abs' (Rep a + Rep (1::'a))\n\ngoal (1 subgoal):\n 1. \\<not> Rep a + 1 < int CARD('a) \\<Longrightarrow> False", "have \"... = Abs' ((Rep a) + 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs' (Rep a + Rep (1::'a)) = Abs' (Rep a + 1)", "using Rep_1"], ["proof (prove)\nusing this:\n  Rep (1::'a) = 1\n\ngoal (1 subgoal):\n 1. Abs' (Rep a + Rep (1::'a)) = Abs' (Rep a + 1)", "by simp"], ["proof (state)\nthis:\n  Abs' (Rep a + Rep (1::'a)) = Abs' (Rep a + 1)\n\ngoal (1 subgoal):\n 1. \\<not> Rep a + 1 < int CARD('a) \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  Abs' (Rep a + Rep (1::'a)) = Abs' (Rep a + 1)\n\ngoal (1 subgoal):\n 1. \\<not> Rep a + 1 < int CARD('a) \\<Longrightarrow> False", "have \"... = Abs' (CARD('a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs' (Rep a + 1) = Abs' (int CARD('a))", "unfolding to_nat_eq_card"], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs' (int CARD('a)) = Abs' (int CARD('a))", ".."], ["proof (state)\nthis:\n  Abs' (Rep a + 1) = Abs' (int CARD('a))\n\ngoal (1 subgoal):\n 1. \\<not> Rep a + 1 < int CARD('a) \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  Abs' (Rep a + 1) = Abs' (int CARD('a))\n\ngoal (1 subgoal):\n 1. \\<not> Rep a + 1 < int CARD('a) \\<Longrightarrow> False", "have \"... = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs' (int CARD('a)) = (0::'a)", "using Abs'_0"], ["proof (prove)\nusing this:\n  Abs' (int CARD('a)) = (0::'a)\n\ngoal (1 subgoal):\n 1. Abs' (int CARD('a)) = (0::'a)", "by auto"], ["proof (state)\nthis:\n  Abs' (int CARD('a)) = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<not> Rep a + 1 < int CARD('a) \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  a + (1::'a) = (0::'a)", "show False"], ["proof (prove)\nusing this:\n  a + (1::'a) = (0::'a)\n\ngoal (1 subgoal):\n 1. False", "using a"], ["proof (prove)\nusing this:\n  a + (1::'a) = (0::'a)\n  a + (1::'a) \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. False", "by contradiction"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma to_nat_plus_one_less_card: \"\\<forall>a. a+1 \\<noteq> 0 --> to_nat a + 1 < CARD('a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a.\n       a + (1::'a) \\<noteq> (0::'a) \\<longrightarrow>\n       mod_type_class.to_nat a + 1 < CARD('a)", "proof (clarify)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       a + (1::'a) \\<noteq> (0::'a) \\<Longrightarrow>\n       mod_type_class.to_nat a + 1 < CARD('a)", "fix a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       a + (1::'a) \\<noteq> (0::'a) \\<Longrightarrow>\n       mod_type_class.to_nat a + 1 < CARD('a)", "assume a: \"a + 1 \\<noteq> 0\""], ["proof (state)\nthis:\n  a + (1::'a) \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       a + (1::'a) \\<noteq> (0::'a) \\<Longrightarrow>\n       mod_type_class.to_nat a + 1 < CARD('a)", "have \"Rep a + 1 < int CARD('a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep a + 1 < int CARD('a)", "using Rep_plus_one_le_card[OF a]"], ["proof (prove)\nusing this:\n  Rep a + 1 < int CARD('a)\n\ngoal (1 subgoal):\n 1. Rep a + 1 < int CARD('a)", "by auto"], ["proof (state)\nthis:\n  Rep a + 1 < int CARD('a)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       a + (1::'a) \\<noteq> (0::'a) \\<Longrightarrow>\n       mod_type_class.to_nat a + 1 < CARD('a)", "hence \"nat (Rep a + 1) < nat (int CARD('a))\""], ["proof (prove)\nusing this:\n  Rep a + 1 < int CARD('a)\n\ngoal (1 subgoal):\n 1. nat (Rep a + 1) < nat (int CARD('a))", "unfolding zless_nat_conj"], ["proof (prove)\nusing this:\n  Rep a + 1 < int CARD('a)\n\ngoal (1 subgoal):\n 1. 0 < int CARD('a) \\<and> Rep a + 1 < int CARD('a)", "using size0"], ["proof (prove)\nusing this:\n  Rep a + 1 < int CARD('a)\n  0 < int CARD('a)\n\ngoal (1 subgoal):\n 1. 0 < int CARD('a) \\<and> Rep a + 1 < int CARD('a)", "by fast"], ["proof (state)\nthis:\n  nat (Rep a + 1) < nat (int CARD('a))\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       a + (1::'a) \\<noteq> (0::'a) \\<Longrightarrow>\n       mod_type_class.to_nat a + 1 < CARD('a)", "thus \"to_nat a + 1 < CARD('a)\""], ["proof (prove)\nusing this:\n  nat (Rep a + 1) < nat (int CARD('a))\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat a + 1 < CARD('a)", "unfolding to_nat_def o_def"], ["proof (prove)\nusing this:\n  nat (Rep a + 1) < nat (int CARD('a))\n\ngoal (1 subgoal):\n 1. nat (Rep a) + 1 < CARD('a)", "using nat_add_distrib[OF Rep_ge_0]"], ["proof (prove)\nusing this:\n  nat (Rep a + 1) < nat (int CARD('a))\n  0 \\<le> ?z' \\<Longrightarrow>\n  nat (Rep ?x1 + ?z') = nat (Rep ?x1) + nat ?z'\n\ngoal (1 subgoal):\n 1. nat (Rep a) + 1 < CARD('a)", "by simp"], ["proof (state)\nthis:\n  mod_type_class.to_nat a + 1 < CARD('a)\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary to_nat_plus_one_less_card':\nassumes \"a+1 \\<noteq> 0\"\nshows \"to_nat a + 1 < CARD('a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.to_nat a + 1 < CARD('a)", "using to_nat_plus_one_less_card assms"], ["proof (prove)\nusing this:\n  \\<forall>a.\n     a + (1::'a) \\<noteq> (0::'a) \\<longrightarrow>\n     mod_type_class.to_nat a + 1 < CARD('a)\n  a + (1::'a) \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat a + 1 < CARD('a)", "by simp"], ["", "lemma strict_mono_to_nat: \"strict_mono to_nat\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strict_mono mod_type_class.to_nat", "using strict_mono_Rep"], ["proof (prove)\nusing this:\n  strict_mono Rep\n\ngoal (1 subgoal):\n 1. strict_mono mod_type_class.to_nat", "unfolding strict_mono_def to_nat_def"], ["proof (prove)\nusing this:\n  \\<forall>x y. x < y \\<longrightarrow> Rep x < Rep y\n\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       x < y \\<longrightarrow> (nat \\<circ> Rep) x < (nat \\<circ> Rep) y", "using Rep_ge_0"], ["proof (prove)\nusing this:\n  \\<forall>x y. x < y \\<longrightarrow> Rep x < Rep y\n  0 \\<le> Rep ?x\n\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       x < y \\<longrightarrow> (nat \\<circ> Rep) x < (nat \\<circ> Rep) y", "by (metis comp_apply nat_less_eq_zless)"], ["", "lemma to_nat_eq [simp]: \"to_nat x = to_nat y \\<longleftrightarrow> x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (mod_type_class.to_nat x = mod_type_class.to_nat y) = (x = y)", "using injD [OF bij_betw_imp_inj_on[OF bij_to_nat]]"], ["proof (prove)\nusing this:\n  mod_type_class.to_nat ?x = mod_type_class.to_nat ?y \\<Longrightarrow>\n  ?x = ?y\n\ngoal (1 subgoal):\n 1. (mod_type_class.to_nat x = mod_type_class.to_nat y) = (x = y)", "by blast"], ["", "lemma mod_type_forall_eq [simp]: \"(\\<forall>j::'a. (to_nat j)<CARD('a) \\<longrightarrow> P j) = (\\<forall>a. P a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>j. mod_type_class.to_nat j < CARD('a) \\<longrightarrow> P j) =\n    (\\<forall>a. P a)", "proof (auto)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<forall>j.\n          mod_type_class.to_nat j < CARD('a) \\<longrightarrow>\n          P j \\<Longrightarrow>\n       P a", "fix a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<forall>j.\n          mod_type_class.to_nat j < CARD('a) \\<longrightarrow>\n          P j \\<Longrightarrow>\n       P a", "assume a: \"\\<forall>j. (to_nat::'a=>nat) j < CARD('a) \\<longrightarrow> P j\""], ["proof (state)\nthis:\n  \\<forall>j. mod_type_class.to_nat j < CARD('a) \\<longrightarrow> P j\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<forall>j.\n          mod_type_class.to_nat j < CARD('a) \\<longrightarrow>\n          P j \\<Longrightarrow>\n       P a", "have \"(to_nat::'a=>nat) a < CARD('a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.to_nat a < CARD('a)", "using bij_to_nat"], ["proof (prove)\nusing this:\n  bij_betw mod_type_class.to_nat UNIV {0..<CARD('a)}\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat a < CARD('a)", "unfolding bij_betw_def"], ["proof (prove)\nusing this:\n  inj mod_type_class.to_nat \\<and>\n  range mod_type_class.to_nat = {0..<CARD('a)}\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat a < CARD('a)", "by auto"], ["proof (state)\nthis:\n  mod_type_class.to_nat a < CARD('a)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<forall>j.\n          mod_type_class.to_nat j < CARD('a) \\<longrightarrow>\n          P j \\<Longrightarrow>\n       P a", "thus \"P a\""], ["proof (prove)\nusing this:\n  mod_type_class.to_nat a < CARD('a)\n\ngoal (1 subgoal):\n 1. P a", "using a"], ["proof (prove)\nusing this:\n  mod_type_class.to_nat a < CARD('a)\n  \\<forall>j. mod_type_class.to_nat j < CARD('a) \\<longrightarrow> P j\n\ngoal (1 subgoal):\n 1. P a", "by auto"], ["proof (state)\nthis:\n  P a\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma to_nat_from_nat:\n  assumes t:\"to_nat j = k\"\n  shows \"from_nat k = j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.from_nat k = j", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. mod_type_class.from_nat k = j", "have \"from_nat k = from_nat (to_nat j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.from_nat k =\n    mod_type_class.from_nat (mod_type_class.to_nat j)", "unfolding t"], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.from_nat k = mod_type_class.from_nat k", ".."], ["proof (state)\nthis:\n  mod_type_class.from_nat k =\n  mod_type_class.from_nat (mod_type_class.to_nat j)\n\ngoal (1 subgoal):\n 1. mod_type_class.from_nat k = j", "also"], ["proof (state)\nthis:\n  mod_type_class.from_nat k =\n  mod_type_class.from_nat (mod_type_class.to_nat j)\n\ngoal (1 subgoal):\n 1. mod_type_class.from_nat k = j", "have \"... = from_nat (the_inv_into {0..<CARD('a)} (from_nat) j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.from_nat (mod_type_class.to_nat j) =\n    mod_type_class.from_nat\n     (the_inv_into {0..<CARD('a)} mod_type_class.from_nat j)", "unfolding to_nat_is_inv"], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.from_nat (mod_type_class.to_nat j) =\n    mod_type_class.from_nat (mod_type_class.to_nat j)", ".."], ["proof (state)\nthis:\n  mod_type_class.from_nat (mod_type_class.to_nat j) =\n  mod_type_class.from_nat\n   (the_inv_into {0..<CARD('a)} mod_type_class.from_nat j)\n\ngoal (1 subgoal):\n 1. mod_type_class.from_nat k = j", "also"], ["proof (state)\nthis:\n  mod_type_class.from_nat (mod_type_class.to_nat j) =\n  mod_type_class.from_nat\n   (the_inv_into {0..<CARD('a)} mod_type_class.from_nat j)\n\ngoal (1 subgoal):\n 1. mod_type_class.from_nat k = j", "have \"... = j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.from_nat\n     (the_inv_into {0..<CARD('a)} mod_type_class.from_nat j) =\n    j", "proof (rule f_the_inv_into_f)"], ["proof (state)\ngoal (2 subgoals):\n 1. inj_on mod_type_class.from_nat {0..<CARD('a)}\n 2. j \\<in> mod_type_class.from_nat ` {0..<CARD('a)}", "show \"inj_on from_nat {0..<CARD('a)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on mod_type_class.from_nat {0..<CARD('a)}", "by (metis bij_betw_imp_inj_on bij_from_nat)"], ["proof (state)\nthis:\n  inj_on mod_type_class.from_nat {0..<CARD('a)}\n\ngoal (1 subgoal):\n 1. j \\<in> mod_type_class.from_nat ` {0..<CARD('a)}", "show \"j \\<in> from_nat ` {0..<CARD('a)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j \\<in> mod_type_class.from_nat ` {0..<CARD('a)}", "by (metis UNIV_I bij_betw_def bij_from_nat)"], ["proof (state)\nthis:\n  j \\<in> mod_type_class.from_nat ` {0..<CARD('a)}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  mod_type_class.from_nat\n   (the_inv_into {0..<CARD('a)} mod_type_class.from_nat j) =\n  j\n\ngoal (1 subgoal):\n 1. mod_type_class.from_nat k = j", "finally"], ["proof (chain)\npicking this:\n  mod_type_class.from_nat k = j", "show \"from_nat k = j\""], ["proof (prove)\nusing this:\n  mod_type_class.from_nat k = j\n\ngoal (1 subgoal):\n 1. mod_type_class.from_nat k = j", "."], ["proof (state)\nthis:\n  mod_type_class.from_nat k = j\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma to_nat_mono:\n  assumes ab: \"a < b\"\n  shows \"to_nat a < to_nat b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.to_nat a < mod_type_class.to_nat b", "using strict_mono_to_nat"], ["proof (prove)\nusing this:\n  strict_mono mod_type_class.to_nat\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat a < mod_type_class.to_nat b", "unfolding strict_mono_def"], ["proof (prove)\nusing this:\n  \\<forall>x y.\n     x < y \\<longrightarrow>\n     mod_type_class.to_nat x < mod_type_class.to_nat y\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat a < mod_type_class.to_nat b", "using assms"], ["proof (prove)\nusing this:\n  \\<forall>x y.\n     x < y \\<longrightarrow>\n     mod_type_class.to_nat x < mod_type_class.to_nat y\n  a < b\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat a < mod_type_class.to_nat b", "by fast"], ["", "lemma to_nat_mono':\n  assumes ab: \"a \\<le> b\"\n  shows \"to_nat a \\<le> to_nat b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.to_nat a \\<le> mod_type_class.to_nat b", "proof (cases \"a=b\")"], ["proof (state)\ngoal (2 subgoals):\n 1. a = b \\<Longrightarrow>\n    mod_type_class.to_nat a \\<le> mod_type_class.to_nat b\n 2. a \\<noteq> b \\<Longrightarrow>\n    mod_type_class.to_nat a \\<le> mod_type_class.to_nat b", "case True"], ["proof (state)\nthis:\n  a = b\n\ngoal (2 subgoals):\n 1. a = b \\<Longrightarrow>\n    mod_type_class.to_nat a \\<le> mod_type_class.to_nat b\n 2. a \\<noteq> b \\<Longrightarrow>\n    mod_type_class.to_nat a \\<le> mod_type_class.to_nat b", "thus ?thesis"], ["proof (prove)\nusing this:\n  a = b\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat a \\<le> mod_type_class.to_nat b", "by auto"], ["proof (state)\nthis:\n  mod_type_class.to_nat a \\<le> mod_type_class.to_nat b\n\ngoal (1 subgoal):\n 1. a \\<noteq> b \\<Longrightarrow>\n    mod_type_class.to_nat a \\<le> mod_type_class.to_nat b", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. a \\<noteq> b \\<Longrightarrow>\n    mod_type_class.to_nat a \\<le> mod_type_class.to_nat b", "case False"], ["proof (state)\nthis:\n  a \\<noteq> b\n\ngoal (1 subgoal):\n 1. a \\<noteq> b \\<Longrightarrow>\n    mod_type_class.to_nat a \\<le> mod_type_class.to_nat b", "hence \"a<b\""], ["proof (prove)\nusing this:\n  a \\<noteq> b\n\ngoal (1 subgoal):\n 1. a < b", "using ab"], ["proof (prove)\nusing this:\n  a \\<noteq> b\n  a \\<le> b\n\ngoal (1 subgoal):\n 1. a < b", "by simp"], ["proof (state)\nthis:\n  a < b\n\ngoal (1 subgoal):\n 1. a \\<noteq> b \\<Longrightarrow>\n    mod_type_class.to_nat a \\<le> mod_type_class.to_nat b", "thus ?thesis"], ["proof (prove)\nusing this:\n  a < b\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat a \\<le> mod_type_class.to_nat b", "using to_nat_mono"], ["proof (prove)\nusing this:\n  a < b\n  ?a < ?b \\<Longrightarrow>\n  mod_type_class.to_nat ?a < mod_type_class.to_nat ?b\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat a \\<le> mod_type_class.to_nat b", "by fastforce"], ["proof (state)\nthis:\n  mod_type_class.to_nat a \\<le> mod_type_class.to_nat b\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma least_mod_type:\n  shows \"0 \\<le> (n::'a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) \\<le> n", "using least_0"], ["proof (prove)\nusing this:\n  (LEAST n. n \\<in> UNIV) = (0::'a)\n\ngoal (1 subgoal):\n 1. (0::'a) \\<le> n", "by (metis (full_types) Least_le UNIV_I)"], ["", "lemma to_nat_from_nat_id:\n  assumes x: \"x<CARD('a)\"\n  shows \"to_nat ((from_nat x)::'a) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.to_nat (mod_type_class.from_nat x) = x", "unfolding to_nat_is_inv[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. the_inv_into {0..<CARD('a)} mod_type_class.from_nat\n     (mod_type_class.from_nat x) =\n    x", "proof (rule the_inv_into_f_f)"], ["proof (state)\ngoal (2 subgoals):\n 1. inj_on mod_type_class.from_nat {0..<CARD('a)}\n 2. x \\<in> {0..<CARD('a)}", "show \"inj_on (from_nat::nat=>'a) {0..<CARD('a)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on mod_type_class.from_nat {0..<CARD('a)}", "using bij_from_nat"], ["proof (prove)\nusing this:\n  bij_betw mod_type_class.from_nat {0..<CARD('a)} UNIV\n\ngoal (1 subgoal):\n 1. inj_on mod_type_class.from_nat {0..<CARD('a)}", "unfolding bij_betw_def"], ["proof (prove)\nusing this:\n  inj_on mod_type_class.from_nat {0..<CARD('a)} \\<and>\n  mod_type_class.from_nat ` {0..<CARD('a)} = UNIV\n\ngoal (1 subgoal):\n 1. inj_on mod_type_class.from_nat {0..<CARD('a)}", "by auto"], ["proof (state)\nthis:\n  inj_on mod_type_class.from_nat {0..<CARD('a)}\n\ngoal (1 subgoal):\n 1. x \\<in> {0..<CARD('a)}", "show \"x \\<in> {0..<CARD('a)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> {0..<CARD('a)}", "using x"], ["proof (prove)\nusing this:\n  x < CARD('a)\n\ngoal (1 subgoal):\n 1. x \\<in> {0..<CARD('a)}", "by simp"], ["proof (state)\nthis:\n  x \\<in> {0..<CARD('a)}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma from_nat_to_nat_id[simp]:\n  shows \"from_nat (to_nat x) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.from_nat (mod_type_class.to_nat x) = x", "by (metis to_nat_from_nat)"], ["", "lemma from_nat_to_nat:\n  assumes t:\"from_nat j = k\" and j: \"j<CARD('a)\"\n  shows \"to_nat k = j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.to_nat k = j", "by (metis j t to_nat_from_nat_id)"], ["", "lemma from_nat_mono:\n  assumes i_le_j: \"i<j\" and j: \"j<CARD('a)\"\n  shows \"(from_nat i::'a) < from_nat j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.from_nat i < mod_type_class.from_nat j", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. mod_type_class.from_nat i < mod_type_class.from_nat j", "have i: \"i<CARD('a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < CARD('a)", "using i_le_j j"], ["proof (prove)\nusing this:\n  i < j\n  j < CARD('a)\n\ngoal (1 subgoal):\n 1. i < CARD('a)", "by simp"], ["proof (state)\nthis:\n  i < CARD('a)\n\ngoal (1 subgoal):\n 1. mod_type_class.from_nat i < mod_type_class.from_nat j", "obtain a where a: \"i=to_nat a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a.\n        i = mod_type_class.to_nat a \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using bij_to_nat"], ["proof (prove)\nusing this:\n  bij_betw mod_type_class.to_nat UNIV {0..<CARD('a)}\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        i = mod_type_class.to_nat a \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding bij_betw_def"], ["proof (prove)\nusing this:\n  inj mod_type_class.to_nat \\<and>\n  range mod_type_class.to_nat = {0..<CARD('a)}\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        i = mod_type_class.to_nat a \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using i to_nat_from_nat_id"], ["proof (prove)\nusing this:\n  inj mod_type_class.to_nat \\<and>\n  range mod_type_class.to_nat = {0..<CARD('a)}\n  i < CARD('a)\n  ?x < CARD('a) \\<Longrightarrow>\n  mod_type_class.to_nat (mod_type_class.from_nat ?x) = ?x\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        i = mod_type_class.to_nat a \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  i = mod_type_class.to_nat a\n\ngoal (1 subgoal):\n 1. mod_type_class.from_nat i < mod_type_class.from_nat j", "obtain b where b: \"j=to_nat b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>b.\n        j = mod_type_class.to_nat b \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using bij_to_nat"], ["proof (prove)\nusing this:\n  bij_betw mod_type_class.to_nat UNIV {0..<CARD('a)}\n\ngoal (1 subgoal):\n 1. (\\<And>b.\n        j = mod_type_class.to_nat b \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding bij_betw_def"], ["proof (prove)\nusing this:\n  inj mod_type_class.to_nat \\<and>\n  range mod_type_class.to_nat = {0..<CARD('a)}\n\ngoal (1 subgoal):\n 1. (\\<And>b.\n        j = mod_type_class.to_nat b \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using j to_nat_from_nat_id"], ["proof (prove)\nusing this:\n  inj mod_type_class.to_nat \\<and>\n  range mod_type_class.to_nat = {0..<CARD('a)}\n  j < CARD('a)\n  ?x < CARD('a) \\<Longrightarrow>\n  mod_type_class.to_nat (mod_type_class.from_nat ?x) = ?x\n\ngoal (1 subgoal):\n 1. (\\<And>b.\n        j = mod_type_class.to_nat b \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  j = mod_type_class.to_nat b\n\ngoal (1 subgoal):\n 1. mod_type_class.from_nat i < mod_type_class.from_nat j", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.from_nat i < mod_type_class.from_nat j", "by (metis a b from_nat_to_nat_id i_le_j strict_mono_less strict_mono_to_nat)"], ["proof (state)\nthis:\n  mod_type_class.from_nat i < mod_type_class.from_nat j\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma from_nat_mono':\n  assumes i_le_j: \"i \\<le> j\" and \"j<CARD ('a)\"\n  shows \"(from_nat i::'a) \\<le> from_nat j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.from_nat i \\<le> mod_type_class.from_nat j", "proof (cases \"i=j\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i = j \\<Longrightarrow>\n    mod_type_class.from_nat i \\<le> mod_type_class.from_nat j\n 2. i \\<noteq> j \\<Longrightarrow>\n    mod_type_class.from_nat i \\<le> mod_type_class.from_nat j", "case True"], ["proof (state)\nthis:\n  i = j\n\ngoal (2 subgoals):\n 1. i = j \\<Longrightarrow>\n    mod_type_class.from_nat i \\<le> mod_type_class.from_nat j\n 2. i \\<noteq> j \\<Longrightarrow>\n    mod_type_class.from_nat i \\<le> mod_type_class.from_nat j", "have \"(from_nat i::'a) = from_nat j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.from_nat i = mod_type_class.from_nat j", "using True"], ["proof (prove)\nusing this:\n  i = j\n\ngoal (1 subgoal):\n 1. mod_type_class.from_nat i = mod_type_class.from_nat j", "by simp"], ["proof (state)\nthis:\n  mod_type_class.from_nat i = mod_type_class.from_nat j\n\ngoal (2 subgoals):\n 1. i = j \\<Longrightarrow>\n    mod_type_class.from_nat i \\<le> mod_type_class.from_nat j\n 2. i \\<noteq> j \\<Longrightarrow>\n    mod_type_class.from_nat i \\<le> mod_type_class.from_nat j", "thus ?thesis"], ["proof (prove)\nusing this:\n  mod_type_class.from_nat i = mod_type_class.from_nat j\n\ngoal (1 subgoal):\n 1. mod_type_class.from_nat i \\<le> mod_type_class.from_nat j", "by simp"], ["proof (state)\nthis:\n  mod_type_class.from_nat i \\<le> mod_type_class.from_nat j\n\ngoal (1 subgoal):\n 1. i \\<noteq> j \\<Longrightarrow>\n    mod_type_class.from_nat i \\<le> mod_type_class.from_nat j", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. i \\<noteq> j \\<Longrightarrow>\n    mod_type_class.from_nat i \\<le> mod_type_class.from_nat j", "case False"], ["proof (state)\nthis:\n  i \\<noteq> j\n\ngoal (1 subgoal):\n 1. i \\<noteq> j \\<Longrightarrow>\n    mod_type_class.from_nat i \\<le> mod_type_class.from_nat j", "hence \"i<j\""], ["proof (prove)\nusing this:\n  i \\<noteq> j\n\ngoal (1 subgoal):\n 1. i < j", "using i_le_j"], ["proof (prove)\nusing this:\n  i \\<noteq> j\n  i \\<le> j\n\ngoal (1 subgoal):\n 1. i < j", "by simp"], ["proof (state)\nthis:\n  i < j\n\ngoal (1 subgoal):\n 1. i \\<noteq> j \\<Longrightarrow>\n    mod_type_class.from_nat i \\<le> mod_type_class.from_nat j", "thus ?thesis"], ["proof (prove)\nusing this:\n  i < j\n\ngoal (1 subgoal):\n 1. mod_type_class.from_nat i \\<le> mod_type_class.from_nat j", "by (metis assms(2) from_nat_mono less_imp_le)"], ["proof (state)\nthis:\n  mod_type_class.from_nat i \\<le> mod_type_class.from_nat j\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma to_nat_suc:\n  assumes \"to_nat (x)+1 < CARD ('a)\"\n  shows \"to_nat (x + 1::'a) = (to_nat x) + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.to_nat (x + (1::'a)) = mod_type_class.to_nat x + 1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. mod_type_class.to_nat (x + (1::'a)) = mod_type_class.to_nat x + 1", "have \"(x::'a) + 1 = from_nat (to_nat x + to_nat (1::'a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x + (1::'a) =\n    mod_type_class.from_nat\n     (mod_type_class.to_nat x + mod_type_class.to_nat (1::'a))", "unfolding add_to_nat_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.from_nat\n     (mod_type_class.to_nat x + mod_type_class.to_nat (1::'a)) =\n    mod_type_class.from_nat\n     (mod_type_class.to_nat x + mod_type_class.to_nat (1::'a))", ".."], ["proof (state)\nthis:\n  x + (1::'a) =\n  mod_type_class.from_nat\n   (mod_type_class.to_nat x + mod_type_class.to_nat (1::'a))\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat (x + (1::'a)) = mod_type_class.to_nat x + 1", "hence \"to_nat ((x::'a) + 1) = to_nat (from_nat (to_nat x + to_nat (1::'a))::'a)\""], ["proof (prove)\nusing this:\n  x + (1::'a) =\n  mod_type_class.from_nat\n   (mod_type_class.to_nat x + mod_type_class.to_nat (1::'a))\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat (x + (1::'a)) =\n    mod_type_class.to_nat\n     (mod_type_class.from_nat\n       (mod_type_class.to_nat x + mod_type_class.to_nat (1::'a)))", "by presburger"], ["proof (state)\nthis:\n  mod_type_class.to_nat (x + (1::'a)) =\n  mod_type_class.to_nat\n   (mod_type_class.from_nat\n     (mod_type_class.to_nat x + mod_type_class.to_nat (1::'a)))\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat (x + (1::'a)) = mod_type_class.to_nat x + 1", "also"], ["proof (state)\nthis:\n  mod_type_class.to_nat (x + (1::'a)) =\n  mod_type_class.to_nat\n   (mod_type_class.from_nat\n     (mod_type_class.to_nat x + mod_type_class.to_nat (1::'a)))\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat (x + (1::'a)) = mod_type_class.to_nat x + 1", "have \"... = to_nat (from_nat (to_nat x + 1)::'a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.to_nat\n     (mod_type_class.from_nat\n       (mod_type_class.to_nat x + mod_type_class.to_nat (1::'a))) =\n    mod_type_class.to_nat\n     (mod_type_class.from_nat (mod_type_class.to_nat x + 1))", "unfolding to_nat_1"], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.to_nat\n     (mod_type_class.from_nat (mod_type_class.to_nat x + 1)) =\n    mod_type_class.to_nat\n     (mod_type_class.from_nat (mod_type_class.to_nat x + 1))", ".."], ["proof (state)\nthis:\n  mod_type_class.to_nat\n   (mod_type_class.from_nat\n     (mod_type_class.to_nat x + mod_type_class.to_nat (1::'a))) =\n  mod_type_class.to_nat\n   (mod_type_class.from_nat (mod_type_class.to_nat x + 1))\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat (x + (1::'a)) = mod_type_class.to_nat x + 1", "also"], ["proof (state)\nthis:\n  mod_type_class.to_nat\n   (mod_type_class.from_nat\n     (mod_type_class.to_nat x + mod_type_class.to_nat (1::'a))) =\n  mod_type_class.to_nat\n   (mod_type_class.from_nat (mod_type_class.to_nat x + 1))\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat (x + (1::'a)) = mod_type_class.to_nat x + 1", "have \"... = (to_nat x + 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.to_nat\n     (mod_type_class.from_nat (mod_type_class.to_nat x + 1)) =\n    mod_type_class.to_nat x + 1", "by (metis assms to_nat_from_nat_id)"], ["proof (state)\nthis:\n  mod_type_class.to_nat\n   (mod_type_class.from_nat (mod_type_class.to_nat x + 1)) =\n  mod_type_class.to_nat x + 1\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat (x + (1::'a)) = mod_type_class.to_nat x + 1", "finally"], ["proof (chain)\npicking this:\n  mod_type_class.to_nat (x + (1::'a)) = mod_type_class.to_nat x + 1", "show ?thesis"], ["proof (prove)\nusing this:\n  mod_type_class.to_nat (x + (1::'a)) = mod_type_class.to_nat x + 1\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat (x + (1::'a)) = mod_type_class.to_nat x + 1", "."], ["proof (state)\nthis:\n  mod_type_class.to_nat (x + (1::'a)) = mod_type_class.to_nat x + 1\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma to_nat_le:\n  assumes \"y < from_nat k\"\n  shows  \"to_nat y < k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.to_nat y < k", "proof (cases \"k<CARD('a)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. k < CARD('a) \\<Longrightarrow> mod_type_class.to_nat y < k\n 2. \\<not> k < CARD('a) \\<Longrightarrow> mod_type_class.to_nat y < k", "case True"], ["proof (state)\nthis:\n  k < CARD('a)\n\ngoal (2 subgoals):\n 1. k < CARD('a) \\<Longrightarrow> mod_type_class.to_nat y < k\n 2. \\<not> k < CARD('a) \\<Longrightarrow> mod_type_class.to_nat y < k", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.to_nat y < k", "by (metis (full_types) True assms to_nat_from_nat_id to_nat_mono)"], ["proof (state)\nthis:\n  mod_type_class.to_nat y < k\n\ngoal (1 subgoal):\n 1. \\<not> k < CARD('a) \\<Longrightarrow> mod_type_class.to_nat y < k", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> k < CARD('a) \\<Longrightarrow> mod_type_class.to_nat y < k", "case False"], ["proof (state)\nthis:\n  \\<not> k < CARD('a)\n\ngoal (1 subgoal):\n 1. \\<not> k < CARD('a) \\<Longrightarrow> mod_type_class.to_nat y < k", "have \"to_nat y < CARD ('a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.to_nat y < CARD('a)", "using bij_to_nat"], ["proof (prove)\nusing this:\n  bij_betw mod_type_class.to_nat UNIV {0..<CARD('a)}\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat y < CARD('a)", "unfolding bij_betw_def"], ["proof (prove)\nusing this:\n  inj mod_type_class.to_nat \\<and>\n  range mod_type_class.to_nat = {0..<CARD('a)}\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat y < CARD('a)", "by auto"], ["proof (state)\nthis:\n  mod_type_class.to_nat y < CARD('a)\n\ngoal (1 subgoal):\n 1. \\<not> k < CARD('a) \\<Longrightarrow> mod_type_class.to_nat y < k", "thus ?thesis"], ["proof (prove)\nusing this:\n  mod_type_class.to_nat y < CARD('a)\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat y < k", "using False"], ["proof (prove)\nusing this:\n  mod_type_class.to_nat y < CARD('a)\n  \\<not> k < CARD('a)\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat y < k", "by auto"], ["proof (state)\nthis:\n  mod_type_class.to_nat y < k\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma le_Suc:\n  assumes ab: \"a < (b::'a)\"\n  shows \"a + 1 \\<le> b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a + (1::'a) \\<le> b", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. a + (1::'a) \\<le> b", "have \"a + 1 = (from_nat (to_nat (a + 1))::'a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a + (1::'a) =\n    mod_type_class.from_nat (mod_type_class.to_nat (a + (1::'a)))", "using from_nat_to_nat_id [of \"a+1\",symmetric]"], ["proof (prove)\nusing this:\n  a + (1::'a) =\n  mod_type_class.from_nat (mod_type_class.to_nat (a + (1::'a)))\n\ngoal (1 subgoal):\n 1. a + (1::'a) =\n    mod_type_class.from_nat (mod_type_class.to_nat (a + (1::'a)))", "."], ["proof (state)\nthis:\n  a + (1::'a) =\n  mod_type_class.from_nat (mod_type_class.to_nat (a + (1::'a)))\n\ngoal (1 subgoal):\n 1. a + (1::'a) \\<le> b", "also"], ["proof (state)\nthis:\n  a + (1::'a) =\n  mod_type_class.from_nat (mod_type_class.to_nat (a + (1::'a)))\n\ngoal (1 subgoal):\n 1. a + (1::'a) \\<le> b", "have \"... \\<le> (from_nat (to_nat (b::'a))::'a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.from_nat (mod_type_class.to_nat (a + (1::'a)))\n    \\<le> mod_type_class.from_nat (mod_type_class.to_nat b)", "proof (rule from_nat_mono')"], ["proof (state)\ngoal (2 subgoals):\n 1. mod_type_class.to_nat (a + (1::'a)) \\<le> mod_type_class.to_nat b\n 2. mod_type_class.to_nat b < CARD('a)", "have \"to_nat a < to_nat b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.to_nat a < mod_type_class.to_nat b", "using ab"], ["proof (prove)\nusing this:\n  a < b\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat a < mod_type_class.to_nat b", "by (metis to_nat_mono)"], ["proof (state)\nthis:\n  mod_type_class.to_nat a < mod_type_class.to_nat b\n\ngoal (2 subgoals):\n 1. mod_type_class.to_nat (a + (1::'a)) \\<le> mod_type_class.to_nat b\n 2. mod_type_class.to_nat b < CARD('a)", "hence \"to_nat a + 1 \\<le> to_nat b\""], ["proof (prove)\nusing this:\n  mod_type_class.to_nat a < mod_type_class.to_nat b\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat a + 1 \\<le> mod_type_class.to_nat b", "by simp"], ["proof (state)\nthis:\n  mod_type_class.to_nat a + 1 \\<le> mod_type_class.to_nat b\n\ngoal (2 subgoals):\n 1. mod_type_class.to_nat (a + (1::'a)) \\<le> mod_type_class.to_nat b\n 2. mod_type_class.to_nat b < CARD('a)", "thus \"to_nat b < CARD ('a)\""], ["proof (prove)\nusing this:\n  mod_type_class.to_nat a + 1 \\<le> mod_type_class.to_nat b\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat b < CARD('a)", "using bij_to_nat"], ["proof (prove)\nusing this:\n  mod_type_class.to_nat a + 1 \\<le> mod_type_class.to_nat b\n  bij_betw mod_type_class.to_nat UNIV {0..<CARD('a)}\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat b < CARD('a)", "unfolding  bij_betw_def"], ["proof (prove)\nusing this:\n  mod_type_class.to_nat a + 1 \\<le> mod_type_class.to_nat b\n  inj mod_type_class.to_nat \\<and>\n  range mod_type_class.to_nat = {0..<CARD('a)}\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat b < CARD('a)", "by auto"], ["proof (state)\nthis:\n  mod_type_class.to_nat b < CARD('a)\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat (a + (1::'a)) \\<le> mod_type_class.to_nat b", "hence \"to_nat a + 1 < CARD ('a)\""], ["proof (prove)\nusing this:\n  mod_type_class.to_nat b < CARD('a)\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat a + 1 < CARD('a)", "by (metis \\<open>to_nat a + 1 \\<le> to_nat b\\<close> preorder_class.le_less_trans)"], ["proof (state)\nthis:\n  mod_type_class.to_nat a + 1 < CARD('a)\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat (a + (1::'a)) \\<le> mod_type_class.to_nat b", "thus \"to_nat (a + 1) \\<le> to_nat b\""], ["proof (prove)\nusing this:\n  mod_type_class.to_nat a + 1 < CARD('a)\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat (a + (1::'a)) \\<le> mod_type_class.to_nat b", "by (metis \\<open>to_nat a + 1 \\<le> to_nat b\\<close> to_nat_suc)"], ["proof (state)\nthis:\n  mod_type_class.to_nat (a + (1::'a)) \\<le> mod_type_class.to_nat b\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  mod_type_class.from_nat (mod_type_class.to_nat (a + (1::'a)))\n  \\<le> mod_type_class.from_nat (mod_type_class.to_nat b)\n\ngoal (1 subgoal):\n 1. a + (1::'a) \\<le> b", "also"], ["proof (state)\nthis:\n  mod_type_class.from_nat (mod_type_class.to_nat (a + (1::'a)))\n  \\<le> mod_type_class.from_nat (mod_type_class.to_nat b)\n\ngoal (1 subgoal):\n 1. a + (1::'a) \\<le> b", "have \"... = b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.from_nat (mod_type_class.to_nat b) = b", "by (metis from_nat_to_nat_id)"], ["proof (state)\nthis:\n  mod_type_class.from_nat (mod_type_class.to_nat b) = b\n\ngoal (1 subgoal):\n 1. a + (1::'a) \\<le> b", "finally"], ["proof (chain)\npicking this:\n  a + (1::'a) \\<le> b", "show \"a + (1::'a) \\<le> b\""], ["proof (prove)\nusing this:\n  a + (1::'a) \\<le> b\n\ngoal (1 subgoal):\n 1. a + (1::'a) \\<le> b", "."], ["proof (state)\nthis:\n  a + (1::'a) \\<le> b\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma le_Suc':\nassumes ab: \"a + 1 \\<le> b\"\n  and less_card: \"(to_nat a) + 1 < CARD ('a)\"\n  shows \"a < b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a < b", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. a < b", "have \"a = (from_nat (to_nat a)::'a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a = mod_type_class.from_nat (mod_type_class.to_nat a)", "using from_nat_to_nat_id [of \"a\",symmetric]"], ["proof (prove)\nusing this:\n  a = mod_type_class.from_nat (mod_type_class.to_nat a)\n\ngoal (1 subgoal):\n 1. a = mod_type_class.from_nat (mod_type_class.to_nat a)", "."], ["proof (state)\nthis:\n  a = mod_type_class.from_nat (mod_type_class.to_nat a)\n\ngoal (1 subgoal):\n 1. a < b", "also"], ["proof (state)\nthis:\n  a = mod_type_class.from_nat (mod_type_class.to_nat a)\n\ngoal (1 subgoal):\n 1. a < b", "have \"... < (from_nat (to_nat b)::'a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.from_nat (mod_type_class.to_nat a)\n    < mod_type_class.from_nat (mod_type_class.to_nat b)", "proof (rule from_nat_mono)"], ["proof (state)\ngoal (2 subgoals):\n 1. mod_type_class.to_nat a < mod_type_class.to_nat b\n 2. mod_type_class.to_nat b < CARD('a)", "show \"to_nat b < CARD('a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.to_nat b < CARD('a)", "using bij_to_nat"], ["proof (prove)\nusing this:\n  bij_betw mod_type_class.to_nat UNIV {0..<CARD('a)}\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat b < CARD('a)", "unfolding  bij_betw_def"], ["proof (prove)\nusing this:\n  inj mod_type_class.to_nat \\<and>\n  range mod_type_class.to_nat = {0..<CARD('a)}\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat b < CARD('a)", "by auto"], ["proof (state)\nthis:\n  mod_type_class.to_nat b < CARD('a)\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat a < mod_type_class.to_nat b", "have \"to_nat (a + 1) \\<le>  to_nat b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.to_nat (a + (1::'a)) \\<le> mod_type_class.to_nat b", "using ab"], ["proof (prove)\nusing this:\n  a + (1::'a) \\<le> b\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat (a + (1::'a)) \\<le> mod_type_class.to_nat b", "by (metis to_nat_mono')"], ["proof (state)\nthis:\n  mod_type_class.to_nat (a + (1::'a)) \\<le> mod_type_class.to_nat b\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat a < mod_type_class.to_nat b", "hence \"to_nat (a) + 1 \\<le>  to_nat b\""], ["proof (prove)\nusing this:\n  mod_type_class.to_nat (a + (1::'a)) \\<le> mod_type_class.to_nat b\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat a + 1 \\<le> mod_type_class.to_nat b", "using to_nat_suc[OF less_card]"], ["proof (prove)\nusing this:\n  mod_type_class.to_nat (a + (1::'a)) \\<le> mod_type_class.to_nat b\n  mod_type_class.to_nat (a + (1::'a)) = mod_type_class.to_nat a + 1\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat a + 1 \\<le> mod_type_class.to_nat b", "by auto"], ["proof (state)\nthis:\n  mod_type_class.to_nat a + 1 \\<le> mod_type_class.to_nat b\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat a < mod_type_class.to_nat b", "thus \"to_nat a < to_nat b\""], ["proof (prove)\nusing this:\n  mod_type_class.to_nat a + 1 \\<le> mod_type_class.to_nat b\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat a < mod_type_class.to_nat b", "by simp"], ["proof (state)\nthis:\n  mod_type_class.to_nat a < mod_type_class.to_nat b\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  mod_type_class.from_nat (mod_type_class.to_nat a)\n  < mod_type_class.from_nat (mod_type_class.to_nat b)\n\ngoal (1 subgoal):\n 1. a < b", "finally"], ["proof (chain)\npicking this:\n  a < mod_type_class.from_nat (mod_type_class.to_nat b)", "show \"a < b\""], ["proof (prove)\nusing this:\n  a < mod_type_class.from_nat (mod_type_class.to_nat b)\n\ngoal (1 subgoal):\n 1. a < b", "by (metis to_nat_from_nat)"], ["proof (state)\nthis:\n  a < b\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Suc_le:\n  assumes less_card: \"(to_nat a) + 1 < CARD ('a)\"\n  shows \"a < a + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a < a + (1::'a)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. a < a + (1::'a)", "have \"(to_nat a) < (to_nat a) + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.to_nat a < mod_type_class.to_nat a + 1", "by simp"], ["proof (state)\nthis:\n  mod_type_class.to_nat a < mod_type_class.to_nat a + 1\n\ngoal (1 subgoal):\n 1. a < a + (1::'a)", "hence \"(to_nat a) < to_nat (a + 1)\""], ["proof (prove)\nusing this:\n  mod_type_class.to_nat a < mod_type_class.to_nat a + 1\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat a < mod_type_class.to_nat (a + (1::'a))", "by (metis less_card to_nat_suc)"], ["proof (state)\nthis:\n  mod_type_class.to_nat a < mod_type_class.to_nat (a + (1::'a))\n\ngoal (1 subgoal):\n 1. a < a + (1::'a)", "hence \"(from_nat (to_nat a)::'a) < from_nat (to_nat (a + 1))\""], ["proof (prove)\nusing this:\n  mod_type_class.to_nat a < mod_type_class.to_nat (a + (1::'a))\n\ngoal (1 subgoal):\n 1. mod_type_class.from_nat (mod_type_class.to_nat a)\n    < mod_type_class.from_nat (mod_type_class.to_nat (a + (1::'a)))", "by (rule from_nat_mono, metis less_card to_nat_suc)"], ["proof (state)\nthis:\n  mod_type_class.from_nat (mod_type_class.to_nat a)\n  < mod_type_class.from_nat (mod_type_class.to_nat (a + (1::'a)))\n\ngoal (1 subgoal):\n 1. a < a + (1::'a)", "thus \"a < a + 1\""], ["proof (prove)\nusing this:\n  mod_type_class.from_nat (mod_type_class.to_nat a)\n  < mod_type_class.from_nat (mod_type_class.to_nat (a + (1::'a)))\n\ngoal (1 subgoal):\n 1. a < a + (1::'a)", "by (metis to_nat_from_nat)"], ["proof (state)\nthis:\n  a < a + (1::'a)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Suc_le':\n  fixes a::'a\n  assumes \"a + 1 \\<noteq> 0\"\n  shows \"a < a + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a < a + (1::'a)", "using Suc_le to_nat_plus_one_less_card assms"], ["proof (prove)\nusing this:\n  mod_type_class.to_nat ?a + 1 < CARD('a) \\<Longrightarrow>\n  ?a < ?a + (1::'a)\n  \\<forall>a.\n     a + (1::'a) \\<noteq> (0::'a) \\<longrightarrow>\n     mod_type_class.to_nat a + 1 < CARD('a)\n  a + (1::'a) \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. a < a + (1::'a)", "by blast"], ["", "lemma from_nat_not_eq:\n  assumes a_eq_to_nat: \"a \\<noteq> to_nat b\"\n  and a_less_card: \"a<CARD('a)\"\n  shows \"from_nat a \\<noteq> b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.from_nat a \\<noteq> b", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> mod_type_class.from_nat a \\<noteq> b \\<Longrightarrow> False", "assume \"\\<not> from_nat a \\<noteq> b\""], ["proof (state)\nthis:\n  \\<not> mod_type_class.from_nat a \\<noteq> b\n\ngoal (1 subgoal):\n 1. \\<not> mod_type_class.from_nat a \\<noteq> b \\<Longrightarrow> False", "hence \"from_nat a = b\""], ["proof (prove)\nusing this:\n  \\<not> mod_type_class.from_nat a \\<noteq> b\n\ngoal (1 subgoal):\n 1. mod_type_class.from_nat a = b", "by simp"], ["proof (state)\nthis:\n  mod_type_class.from_nat a = b\n\ngoal (1 subgoal):\n 1. \\<not> mod_type_class.from_nat a \\<noteq> b \\<Longrightarrow> False", "hence \"to_nat ((from_nat a)::'a) = to_nat b\""], ["proof (prove)\nusing this:\n  mod_type_class.from_nat a = b\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat (mod_type_class.from_nat a) =\n    mod_type_class.to_nat b", "by auto"], ["proof (state)\nthis:\n  mod_type_class.to_nat (mod_type_class.from_nat a) =\n  mod_type_class.to_nat b\n\ngoal (1 subgoal):\n 1. \\<not> mod_type_class.from_nat a \\<noteq> b \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  mod_type_class.to_nat (mod_type_class.from_nat a) =\n  mod_type_class.to_nat b\n\ngoal (1 subgoal):\n 1. False", "by (metis a_eq_to_nat a_less_card to_nat_from_nat_id)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Suc_less:\n  fixes i::'a\n  assumes \"i<j\"\n  and \"i+1 \\<noteq> j\"\n  shows \"i+1<j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i + (1::'a) < j", "by (metis assms le_Suc le_neq_trans)"], ["", "lemma Greatest_is_minus_1: \"\\<forall>a::'a. a \\<le> -1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a. a \\<le> - (1::'a)", "proof (clarify)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a. a \\<le> - (1::'a)", "fix a::'a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a. a \\<le> - (1::'a)", "have zero_ge_card_1: \"0 \\<le> int CARD('a) - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> int CARD('a) - 1", "using size1"], ["proof (prove)\nusing this:\n  1 < int CARD('a)\n\ngoal (1 subgoal):\n 1. 0 \\<le> int CARD('a) - 1", "by auto"], ["proof (state)\nthis:\n  0 \\<le> int CARD('a) - 1\n\ngoal (1 subgoal):\n 1. \\<And>a. a \\<le> - (1::'a)", "have card_less: \"int CARD('a) - 1 < int CARD('a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int CARD('a) - 1 < int CARD('a)", "by auto"], ["proof (state)\nthis:\n  int CARD('a) - 1 < int CARD('a)\n\ngoal (1 subgoal):\n 1. \\<And>a. a \\<le> - (1::'a)", "have not_zero: \"1 mod int CARD('a) \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 mod int CARD('a) \\<noteq> 0", "by (metis (hide_lams, mono_tags) Rep_Abs_1 Rep_mod zero_neq_one)"], ["proof (state)\nthis:\n  1 mod int CARD('a) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>a. a \\<le> - (1::'a)", "have int_card: \"int (CARD('a) - 1) = int CARD('a) - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (CARD('a) - 1) = int CARD('a) - 1", "using of_nat_diff[of 1 \"CARD ('a)\"]"], ["proof (prove)\nusing this:\n  1 \\<le> CARD('a) \\<Longrightarrow>\n  of_nat (CARD('a) - 1) = of_nat CARD('a) - of_nat 1\n\ngoal (1 subgoal):\n 1. int (CARD('a) - 1) = int CARD('a) - 1", "using size1"], ["proof (prove)\nusing this:\n  1 \\<le> CARD('a) \\<Longrightarrow>\n  of_nat (CARD('a) - 1) = of_nat CARD('a) - of_nat 1\n  1 < int CARD('a)\n\ngoal (1 subgoal):\n 1. int (CARD('a) - 1) = int CARD('a) - 1", "by simp"], ["proof (state)\nthis:\n  int (CARD('a) - 1) = int CARD('a) - 1\n\ngoal (1 subgoal):\n 1. \\<And>a. a \\<le> - (1::'a)", "have \"a = Abs' (Rep a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a = Abs' (Rep a)", "by (metis (hide_lams, mono_tags) Rep_0 add_0_right add_def'\n      monoid_add_class.add.right_neutral)"], ["proof (state)\nthis:\n  a = Abs' (Rep a)\n\ngoal (1 subgoal):\n 1. \\<And>a. a \\<le> - (1::'a)", "also"], ["proof (state)\nthis:\n  a = Abs' (Rep a)\n\ngoal (1 subgoal):\n 1. \\<And>a. a \\<le> - (1::'a)", "have \"... = Abs' (int (nat (Rep a)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs' (Rep a) = Abs' (int (nat (Rep a)))", "by (metis Rep_ge_0 int_nat_eq)"], ["proof (state)\nthis:\n  Abs' (Rep a) = Abs' (int (nat (Rep a)))\n\ngoal (1 subgoal):\n 1. \\<And>a. a \\<le> - (1::'a)", "also"], ["proof (state)\nthis:\n  Abs' (Rep a) = Abs' (int (nat (Rep a)))\n\ngoal (1 subgoal):\n 1. \\<And>a. a \\<le> - (1::'a)", "have \"...  \\<le> Abs' (int (CARD('a) - 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs' (int (nat (Rep a))) \\<le> Abs' (int (CARD('a) - 1))", "proof (rule from_nat_mono'[unfolded from_nat_def o_def, of \"nat (Rep a)\" \"CARD('a) - 1\"])"], ["proof (state)\ngoal (2 subgoals):\n 1. nat (Rep a) \\<le> CARD('a) - 1\n 2. CARD('a) - 1 < CARD('a)", "show \"nat (Rep a) \\<le> CARD('a) - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nat (Rep a) \\<le> CARD('a) - 1", "using Rep_less_n"], ["proof (prove)\nusing this:\n  Rep ?x < int CARD('a)\n\ngoal (1 subgoal):\n 1. nat (Rep a) \\<le> CARD('a) - 1", "using int_card nat_le_iff"], ["proof (prove)\nusing this:\n  Rep ?x < int CARD('a)\n  int (CARD('a) - 1) = int CARD('a) - 1\n  (nat ?x \\<le> ?n) = (?x \\<le> int ?n)\n\ngoal (1 subgoal):\n 1. nat (Rep a) \\<le> CARD('a) - 1", "by auto"], ["proof (state)\nthis:\n  nat (Rep a) \\<le> CARD('a) - 1\n\ngoal (1 subgoal):\n 1. CARD('a) - 1 < CARD('a)", "show \"CARD('a) - 1 < CARD('a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CARD('a) - 1 < CARD('a)", "using finite_UNIV_card_ge_0 finite_mod_type"], ["proof (prove)\nusing this:\n  finite UNIV \\<Longrightarrow> 0 < CARD(?'a)\n  finite UNIV\n\ngoal (1 subgoal):\n 1. CARD('a) - 1 < CARD('a)", "by fastforce"], ["proof (state)\nthis:\n  CARD('a) - 1 < CARD('a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Abs' (int (nat (Rep a))) \\<le> Abs' (int (CARD('a) - 1))\n\ngoal (1 subgoal):\n 1. \\<And>a. a \\<le> - (1::'a)", "also"], ["proof (state)\nthis:\n  Abs' (int (nat (Rep a))) \\<le> Abs' (int (CARD('a) - 1))\n\ngoal (1 subgoal):\n 1. \\<And>a. a \\<le> - (1::'a)", "have \"... = - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs' (int (CARD('a) - 1)) = - (1::'a)", "unfolding Abs'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs (int (CARD('a) - 1) mod int CARD('a)) = - (1::'a)", "unfolding minus_def zmod_zminus1_eq_if"], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs (int (CARD('a) - 1) mod int CARD('a)) =\n    Abs (if Rep (1::'a) mod int CARD('a) = 0 then 0\n         else int CARD('a) - Rep (1::'a) mod int CARD('a))", "unfolding Rep_1"], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs (int (CARD('a) - 1) mod int CARD('a)) =\n    Abs (if 1 mod int CARD('a) = 0 then 0\n         else int CARD('a) - 1 mod int CARD('a))", "apply (rule cong [of Abs], rule refl)"], ["proof (prove)\ngoal (1 subgoal):\n 1. int (CARD('a) - 1) mod int CARD('a) =\n    (if 1 mod int CARD('a) = 0 then 0\n     else int CARD('a) - 1 mod int CARD('a))", "unfolding if_not_P [OF not_zero]"], ["proof (prove)\ngoal (1 subgoal):\n 1. int (CARD('a) - 1) mod int CARD('a) = int CARD('a) - 1 mod int CARD('a)", "unfolding int_card"], ["proof (prove)\ngoal (1 subgoal):\n 1. (int CARD('a) - 1) mod int CARD('a) = int CARD('a) - 1 mod int CARD('a)", "unfolding mod_pos_pos_trivial[OF zero_ge_card_1 card_less]"], ["proof (prove)\ngoal (1 subgoal):\n 1. int CARD('a) - 1 = int CARD('a) - 1 mod int CARD('a)", "using mod_pos_pos_trivial[OF _ size1]"], ["proof (prove)\nusing this:\n  0 \\<le> 1 \\<Longrightarrow> 1 mod int CARD('a) = 1\n\ngoal (1 subgoal):\n 1. int CARD('a) - 1 = int CARD('a) - 1 mod int CARD('a)", "by presburger"], ["proof (state)\nthis:\n  Abs' (int (CARD('a) - 1)) = - (1::'a)\n\ngoal (1 subgoal):\n 1. \\<And>a. a \\<le> - (1::'a)", "finally"], ["proof (chain)\npicking this:\n  a \\<le> - (1::'a)", "show \"a \\<le> -1\""], ["proof (prove)\nusing this:\n  a \\<le> - (1::'a)\n\ngoal (1 subgoal):\n 1. a \\<le> - (1::'a)", "by fastforce"], ["proof (state)\nthis:\n  a \\<le> - (1::'a)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma a_eq_minus_1: \"\\<forall>a::'a. a+1 = 0 \\<longrightarrow> a = -1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a. a + (1::'a) = (0::'a) \\<longrightarrow> a = - (1::'a)", "by (metis eq_neg_iff_add_eq_0)"], ["", "lemma forall_from_nat_rw:\n  shows \"(\\<forall>x\\<in>{0..<CARD('a)}. P (from_nat x::'a)) = (\\<forall>x. P (from_nat x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x\\<in>{0..<CARD('a)}. P (mod_type_class.from_nat x)) =\n    (\\<forall>x. P (mod_type_class.from_nat x))", "proof (auto)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<forall>x\\<in>{0..<CARD('a)}.\n          P (mod_type_class.from_nat x) \\<Longrightarrow>\n       P (mod_type_class.from_nat x)", "fix y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<forall>x\\<in>{0..<CARD('a)}.\n          P (mod_type_class.from_nat x) \\<Longrightarrow>\n       P (mod_type_class.from_nat x)", "assume *: \"\\<forall>x\\<in>{0..<CARD('a)}. P (from_nat x)\""], ["proof (state)\nthis:\n  \\<forall>x\\<in>{0..<CARD('a)}. P (mod_type_class.from_nat x)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<forall>x\\<in>{0..<CARD('a)}.\n          P (mod_type_class.from_nat x) \\<Longrightarrow>\n       P (mod_type_class.from_nat x)", "have \"from_nat y \\<in> (UNIV::'a set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.from_nat y \\<in> UNIV", "by auto"], ["proof (state)\nthis:\n  mod_type_class.from_nat y \\<in> UNIV\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<forall>x\\<in>{0..<CARD('a)}.\n          P (mod_type_class.from_nat x) \\<Longrightarrow>\n       P (mod_type_class.from_nat x)", "from this"], ["proof (chain)\npicking this:\n  mod_type_class.from_nat y \\<in> UNIV", "obtain x where x1: \"from_nat y = (from_nat x::'a)\" and x2: \"x\\<in>{0..<CARD('a)}\""], ["proof (prove)\nusing this:\n  mod_type_class.from_nat y \\<in> UNIV\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>mod_type_class.from_nat y = mod_type_class.from_nat x;\n         x \\<in> {0..<CARD('a)}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using bij_from_nat"], ["proof (prove)\nusing this:\n  mod_type_class.from_nat y \\<in> UNIV\n  bij_betw mod_type_class.from_nat {0..<CARD('a)} UNIV\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>mod_type_class.from_nat y = mod_type_class.from_nat x;\n         x \\<in> {0..<CARD('a)}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding bij_betw_def"], ["proof (prove)\nusing this:\n  mod_type_class.from_nat y \\<in> UNIV\n  inj_on mod_type_class.from_nat {0..<CARD('a)} \\<and>\n  mod_type_class.from_nat ` {0..<CARD('a)} = UNIV\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>mod_type_class.from_nat y = mod_type_class.from_nat x;\n         x \\<in> {0..<CARD('a)}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis from_nat_to_nat_id rangeI the_inv_into_onto to_nat_is_inv)"], ["proof (state)\nthis:\n  mod_type_class.from_nat y = mod_type_class.from_nat x\n  x \\<in> {0..<CARD('a)}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<forall>x\\<in>{0..<CARD('a)}.\n          P (mod_type_class.from_nat x) \\<Longrightarrow>\n       P (mod_type_class.from_nat x)", "show \"P (from_nat y::'a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P (mod_type_class.from_nat y)", "unfolding x1"], ["proof (prove)\ngoal (1 subgoal):\n 1. P (mod_type_class.from_nat x)", "using * x2"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>{0..<CARD('a)}. P (mod_type_class.from_nat x)\n  x \\<in> {0..<CARD('a)}\n\ngoal (1 subgoal):\n 1. P (mod_type_class.from_nat x)", "by simp"], ["proof (state)\nthis:\n  P (mod_type_class.from_nat y)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma from_nat_eq_imp_eq:\n  assumes f_eq: \"from_nat x = (from_nat xa::'a)\"\nand x: \"x<CARD('a)\" and xa: \"xa<CARD('a)\"\n  shows \"x=xa\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = xa", "using assms from_nat_not_eq"], ["proof (prove)\nusing this:\n  mod_type_class.from_nat x = mod_type_class.from_nat xa\n  x < CARD('a)\n  xa < CARD('a)\n  \\<lbrakk>?a \\<noteq> mod_type_class.to_nat ?b; ?a < CARD('a)\\<rbrakk>\n  \\<Longrightarrow> mod_type_class.from_nat ?a \\<noteq> ?b\n\ngoal (1 subgoal):\n 1. x = xa", "by metis"], ["", "lemma to_nat_less_card:\n  fixes j::\"'a\"\n  shows \"to_nat j < CARD ('a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.to_nat j < CARD('a)", "using bij_to_nat"], ["proof (prove)\nusing this:\n  bij_betw mod_type_class.to_nat UNIV {0..<CARD('a)}\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat j < CARD('a)", "unfolding bij_betw_def"], ["proof (prove)\nusing this:\n  inj mod_type_class.to_nat \\<and>\n  range mod_type_class.to_nat = {0..<CARD('a)}\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat j < CARD('a)", "by auto"], ["", "lemma from_nat_0: \"from_nat 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.from_nat 0 = (0::'a)", "unfolding from_nat_def o_def of_nat_0 Abs'_def mod_0 zero_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs 0 = Abs 0", ".."], ["", "lemma to_nat_0: \"to_nat 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.to_nat (0::'a) = 0", "unfolding to_nat_def o_def Rep_0 nat_0"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 = 0", ".."], ["", "lemma to_nat_eq_0: \"(to_nat x = 0) = (x = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (mod_type_class.to_nat x = 0) = (x = (0::'a))", "by (auto simp add: to_nat_0 from_nat_0 dest: to_nat_from_nat)"], ["", "lemma suc_not_zero:\n  assumes \"to_nat a + 1 \\<noteq> CARD('a)\"\n  shows \"a+1 \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a + (1::'a) \\<noteq> (0::'a)", "proof (rule ccontr, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. a + (1::'a) = (0::'a) \\<Longrightarrow> False", "assume a_plus_one_zero: \"a + 1 = 0\""], ["proof (state)\nthis:\n  a + (1::'a) = (0::'a)\n\ngoal (1 subgoal):\n 1. a + (1::'a) = (0::'a) \\<Longrightarrow> False", "hence rep_eq_card: \"Rep a + 1 = CARD('a)\""], ["proof (prove)\nusing this:\n  a + (1::'a) = (0::'a)\n\ngoal (1 subgoal):\n 1. Rep a + 1 = int CARD('a)", "using assms to_nat_0 Suc_eq_plus1 Suc_lessI Zero_not_Suc to_nat_less_card to_nat_suc"], ["proof (prove)\nusing this:\n  a + (1::'a) = (0::'a)\n  mod_type_class.to_nat a + 1 \\<noteq> CARD('a)\n  mod_type_class.to_nat (0::'a) = 0\n  Suc ?n = ?n + 1\n  \\<lbrakk>?m < ?n; Suc ?m \\<noteq> ?n\\<rbrakk>\n  \\<Longrightarrow> Suc ?m < ?n\n  0 \\<noteq> Suc ?m\n  mod_type_class.to_nat ?j < CARD('a)\n  mod_type_class.to_nat ?x + 1 < CARD('a) \\<Longrightarrow>\n  mod_type_class.to_nat (?x + (1::'a)) = mod_type_class.to_nat ?x + 1\n\ngoal (1 subgoal):\n 1. Rep a + 1 = int CARD('a)", "by (metis (hide_lams, mono_tags))"], ["proof (state)\nthis:\n  Rep a + 1 = int CARD('a)\n\ngoal (1 subgoal):\n 1. a + (1::'a) = (0::'a) \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  Rep a + 1 = int CARD('a)\n\ngoal (1 subgoal):\n 1. a + (1::'a) = (0::'a) \\<Longrightarrow> False", "have \"Rep a + 1 < CARD('a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep a + 1 < int CARD('a)", "using Abs'_0 Rep_1 Suc_eq_plus1 Suc_lessI Suc_neq_Zero add_def' assms\n    rep_eq_card to_nat_0 to_nat_less_card to_nat_suc"], ["proof (prove)\nusing this:\n  Abs' (int CARD('a)) = (0::'a)\n  Rep (1::'a) = 1\n  Suc ?n = ?n + 1\n  \\<lbrakk>?m < ?n; Suc ?m \\<noteq> ?n\\<rbrakk>\n  \\<Longrightarrow> Suc ?m < ?n\n  Suc ?m = 0 \\<Longrightarrow> ?R\n  ?x + ?y = Abs' (Rep ?x + Rep ?y)\n  mod_type_class.to_nat a + 1 \\<noteq> CARD('a)\n  Rep a + 1 = int CARD('a)\n  mod_type_class.to_nat (0::'a) = 0\n  mod_type_class.to_nat ?j < CARD('a)\n  mod_type_class.to_nat ?x + 1 < CARD('a) \\<Longrightarrow>\n  mod_type_class.to_nat (?x + (1::'a)) = mod_type_class.to_nat ?x + 1\n\ngoal (1 subgoal):\n 1. Rep a + 1 < int CARD('a)", "by (metis (hide_lams, mono_tags))"], ["proof (state)\nthis:\n  Rep a + 1 < int CARD('a)\n\ngoal (1 subgoal):\n 1. a + (1::'a) = (0::'a) \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  Rep a + 1 = int CARD('a)\n  Rep a + 1 < int CARD('a)", "show False"], ["proof (prove)\nusing this:\n  Rep a + 1 = int CARD('a)\n  Rep a + 1 < int CARD('a)\n\ngoal (1 subgoal):\n 1. False", "by fastforce"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma from_nat_suc:\nshows \"from_nat (j + 1) = from_nat j + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.from_nat (j + 1) = mod_type_class.from_nat j + (1::'a)", "unfolding from_nat_def o_def Abs'_def add_def' Rep_1 Rep_Abs_mod"], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs (int (j + 1) mod int CARD('a)) =\n    Abs ((int j mod int CARD('a) + 1) mod int CARD('a))", "unfolding of_nat_add"], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs ((int j + int 1) mod int CARD('a)) =\n    Abs ((int j mod int CARD('a) + 1) mod int CARD('a))", "apply (subst mod_add_left_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs ((int j + int 1) mod int CARD('a)) =\n    Abs ((int j + 1) mod int CARD('a))", "unfolding of_nat_1"], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs ((int j + 1) mod int CARD('a)) = Abs ((int j + 1) mod int CARD('a))", ".."], ["", "lemma to_nat_plus_1_set:\nshows \"to_nat a + 1 \\<in> {1..<CARD('a)+1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.to_nat a + 1 \\<in> {1..<CARD('a) + 1}", "using to_nat_less_card"], ["proof (prove)\nusing this:\n  mod_type_class.to_nat ?j < CARD('a)\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat a + 1 \\<in> {1..<CARD('a) + 1}", "by simp"], ["", "end"], ["", "lemma from_nat_CARD:\n  shows \"from_nat (CARD('a)) = (0::'a::{mod_type})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.from_nat CARD('a) = (0::'a)", "unfolding from_nat_def o_def Abs'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs (int CARD('a) mod int CARD('a)) = (0::'a)", "by (simp add: zero_def)"], ["", "subsection\\<open>Instantiations\\<close>"], ["", "instantiation bit0 and bit1:: (finite) mod_type\nbegin"], ["", "definition \"(Rep::'a bit0 => int)  x = Rep_bit0 x\""], ["", "definition \"(Abs::int => 'a bit0) x = Abs_bit0' x\""], ["", "definition \"(Rep::'a bit1 => int)  x = Rep_bit1 x\""], ["", "definition \"(Abs::int => 'a bit1) x = Abs_bit1' x\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a bit0, mod_type_class) &&& OFCLASS('a bit1, mod_type_class)", "proof"], ["proof (state)\ngoal (18 subgoals):\n 1. type_definition Rep Abs {0..<int CARD('a bit0)}\n 2. 1 < int CARD('a bit0)\n 3. 0 = Abs 0\n 4. 1 = Abs 1\n 5. \\<And>x y. x + y = Abs ((Rep x + Rep y) mod int CARD('a bit0))\n 6. \\<And>x y. x * y = Abs (Rep x * Rep y mod int CARD('a bit0))\n 7. \\<And>x y. x - y = Abs ((Rep x - Rep y) mod int CARD('a bit0))\n 8. \\<And>x. - x = Abs (- Rep x mod int CARD('a bit0))\n 9. strict_mono Rep\n 10. type_definition Rep Abs {0..<int CARD('a bit1)}\nA total of 18 subgoals...", "show \"(0::'a bit0) = Abs (0::int)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 = Abs 0", "unfolding Abs_bit0_def Abs_bit0'_def zero_bit0_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_bit0 0 = Abs_bit0 (0 mod int CARD('a bit0))", "by auto"], ["proof (state)\nthis:\n  0 = Abs 0\n\ngoal (17 subgoals):\n 1. type_definition Rep Abs {0..<int CARD('a bit0)}\n 2. 1 < int CARD('a bit0)\n 3. 1 = Abs 1\n 4. \\<And>x y. x + y = Abs ((Rep x + Rep y) mod int CARD('a bit0))\n 5. \\<And>x y. x * y = Abs (Rep x * Rep y mod int CARD('a bit0))\n 6. \\<And>x y. x - y = Abs ((Rep x - Rep y) mod int CARD('a bit0))\n 7. \\<And>x. - x = Abs (- Rep x mod int CARD('a bit0))\n 8. strict_mono Rep\n 9. type_definition Rep Abs {0..<int CARD('a bit1)}\n 10. 1 < int CARD('a bit1)\nA total of 17 subgoals...", "show \"(1::int) < int CARD('a bit0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 < int CARD('a bit0)", "by (metis bit0.size1)"], ["proof (state)\nthis:\n  1 < int CARD('a bit0)\n\ngoal (16 subgoals):\n 1. type_definition Rep Abs {0..<int CARD('a bit0)}\n 2. 1 = Abs 1\n 3. \\<And>x y. x + y = Abs ((Rep x + Rep y) mod int CARD('a bit0))\n 4. \\<And>x y. x * y = Abs (Rep x * Rep y mod int CARD('a bit0))\n 5. \\<And>x y. x - y = Abs ((Rep x - Rep y) mod int CARD('a bit0))\n 6. \\<And>x. - x = Abs (- Rep x mod int CARD('a bit0))\n 7. strict_mono Rep\n 8. type_definition Rep Abs {0..<int CARD('a bit1)}\n 9. 1 < int CARD('a bit1)\n 10. 0 = Abs 0\nA total of 16 subgoals...", "show \"type_definition (Rep::'a bit0 => int) (Abs:: int => 'a bit0) {0::int..<int CARD('a bit0)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. type_definition Rep Abs {0..<int CARD('a bit0)}", "proof (unfold type_definition_def Rep_bit0_def [abs_def]\n      Abs_bit0_def [abs_def] Abs_bit0'_def, intro conjI)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<forall>x. Rep_bit0 x \\<in> {0..<int CARD('a bit0)}\n 2. \\<forall>x. Abs_bit0 (Rep_bit0 x mod int CARD('a bit0)) = x\n 3. \\<forall>y.\n       y \\<in> {0..<int CARD('a bit0)} \\<longrightarrow>\n       Rep_bit0 (Abs_bit0 (y mod int CARD('a bit0))) = y", "show \"\\<forall>x::'a bit0. Rep_bit0 x \\<in> {0::int..<int CARD('a bit0)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x. Rep_bit0 x \\<in> {0..<int CARD('a bit0)}", "unfolding card_bit0"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x. Rep_bit0 x \\<in> {0..<int (2 * CARD('a))}", "unfolding of_nat_mult"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x. Rep_bit0 x \\<in> {0..<int 2 * int CARD('a)}", "using Rep_bit0 [where ?'a = \"'a\"]"], ["proof (prove)\nusing this:\n  Rep_bit0 ?x \\<in> {0..<2 * int CARD('a)}\n\ngoal (1 subgoal):\n 1. \\<forall>x. Rep_bit0 x \\<in> {0..<int 2 * int CARD('a)}", "by simp"], ["proof (state)\nthis:\n  \\<forall>x. Rep_bit0 x \\<in> {0..<int CARD('a bit0)}\n\ngoal (2 subgoals):\n 1. \\<forall>x. Abs_bit0 (Rep_bit0 x mod int CARD('a bit0)) = x\n 2. \\<forall>y.\n       y \\<in> {0..<int CARD('a bit0)} \\<longrightarrow>\n       Rep_bit0 (Abs_bit0 (y mod int CARD('a bit0))) = y", "show \"\\<forall>x::'a bit0. Abs_bit0 (Rep_bit0 x mod int CARD('a bit0)) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x. Abs_bit0 (Rep_bit0 x mod int CARD('a bit0)) = x", "by (metis Rep_bit0_inverse bit0.Rep_mod)"], ["proof (state)\nthis:\n  \\<forall>x. Abs_bit0 (Rep_bit0 x mod int CARD('a bit0)) = x\n\ngoal (1 subgoal):\n 1. \\<forall>y.\n       y \\<in> {0..<int CARD('a bit0)} \\<longrightarrow>\n       Rep_bit0 (Abs_bit0 (y mod int CARD('a bit0))) = y", "show \"\\<forall>y::int. y \\<in> {0::int..<int CARD('a bit0)}\n      \\<longrightarrow> Rep_bit0 ((Abs_bit0::int => 'a bit0) (y mod int CARD('a bit0))) = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>y.\n       y \\<in> {0..<int CARD('a bit0)} \\<longrightarrow>\n       Rep_bit0 (Abs_bit0 (y mod int CARD('a bit0))) = y", "by (metis bit0.Abs_inverse bit0.Rep_mod)"], ["proof (state)\nthis:\n  \\<forall>y.\n     y \\<in> {0..<int CARD('a bit0)} \\<longrightarrow>\n     Rep_bit0 (Abs_bit0 (y mod int CARD('a bit0))) = y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  type_definition Rep Abs {0..<int CARD('a bit0)}\n\ngoal (15 subgoals):\n 1. 1 = Abs 1\n 2. \\<And>x y. x + y = Abs ((Rep x + Rep y) mod int CARD('a bit0))\n 3. \\<And>x y. x * y = Abs (Rep x * Rep y mod int CARD('a bit0))\n 4. \\<And>x y. x - y = Abs ((Rep x - Rep y) mod int CARD('a bit0))\n 5. \\<And>x. - x = Abs (- Rep x mod int CARD('a bit0))\n 6. strict_mono Rep\n 7. type_definition Rep Abs {0..<int CARD('a bit1)}\n 8. 1 < int CARD('a bit1)\n 9. 0 = Abs 0\n 10. 1 = Abs 1\nA total of 15 subgoals...", "show \"(1::'a bit0) = Abs (1::int)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 = Abs 1", "unfolding Abs_bit0_def Abs_bit0'_def one_bit0_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_bit0 1 = Abs_bit0 (1 mod int CARD('a bit0))", "by (metis bit0.of_nat_eq of_nat_1 one_bit0_def)"], ["proof (state)\nthis:\n  1 = Abs 1\n\ngoal (14 subgoals):\n 1. \\<And>x y. x + y = Abs ((Rep x + Rep y) mod int CARD('a bit0))\n 2. \\<And>x y. x * y = Abs (Rep x * Rep y mod int CARD('a bit0))\n 3. \\<And>x y. x - y = Abs ((Rep x - Rep y) mod int CARD('a bit0))\n 4. \\<And>x. - x = Abs (- Rep x mod int CARD('a bit0))\n 5. strict_mono Rep\n 6. type_definition Rep Abs {0..<int CARD('a bit1)}\n 7. 1 < int CARD('a bit1)\n 8. 0 = Abs 0\n 9. 1 = Abs 1\n 10. \\<And>x y. x + y = Abs ((Rep x + Rep y) mod int CARD('a bit1))\nA total of 14 subgoals...", "fix x y :: \"'a bit0\""], ["proof (state)\ngoal (14 subgoals):\n 1. \\<And>x y. x + y = Abs ((Rep x + Rep y) mod int CARD('a bit0))\n 2. \\<And>x y. x * y = Abs (Rep x * Rep y mod int CARD('a bit0))\n 3. \\<And>x y. x - y = Abs ((Rep x - Rep y) mod int CARD('a bit0))\n 4. \\<And>x. - x = Abs (- Rep x mod int CARD('a bit0))\n 5. strict_mono Rep\n 6. type_definition Rep Abs {0..<int CARD('a bit1)}\n 7. 1 < int CARD('a bit1)\n 8. 0 = Abs 0\n 9. 1 = Abs 1\n 10. \\<And>x y. x + y = Abs ((Rep x + Rep y) mod int CARD('a bit1))\nA total of 14 subgoals...", "show \"x + y = Abs ((Rep x + Rep y) mod int CARD('a bit0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x + y = Abs ((Rep x + Rep y) mod int CARD('a bit0))", "unfolding Abs_bit0_def Rep_bit0_def plus_bit0_def Abs_bit0'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_bit0 ((Rep_bit0 x + Rep_bit0 y) mod int CARD('a bit0)) =\n    Abs_bit0\n     ((Rep_bit0 x + Rep_bit0 y) mod int CARD('a bit0) mod int CARD('a bit0))", "by fastforce"], ["proof (state)\nthis:\n  x + y = Abs ((Rep x + Rep y) mod int CARD('a bit0))\n\ngoal (13 subgoals):\n 1. \\<And>x y. x * y = Abs (Rep x * Rep y mod int CARD('a bit0))\n 2. \\<And>x y. x - y = Abs ((Rep x - Rep y) mod int CARD('a bit0))\n 3. \\<And>x. - x = Abs (- Rep x mod int CARD('a bit0))\n 4. strict_mono Rep\n 5. type_definition Rep Abs {0..<int CARD('a bit1)}\n 6. 1 < int CARD('a bit1)\n 7. 0 = Abs 0\n 8. 1 = Abs 1\n 9. \\<And>x y. x + y = Abs ((Rep x + Rep y) mod int CARD('a bit1))\n 10. \\<And>x y. x * y = Abs (Rep x * Rep y mod int CARD('a bit1))\nA total of 13 subgoals...", "show \"x * y = Abs (Rep x * Rep y mod int CARD('a bit0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * y = Abs (Rep x * Rep y mod int CARD('a bit0))", "unfolding Abs_bit0_def Rep_bit0_def times_bit0_def Abs_bit0'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_bit0 (Rep_bit0 x * Rep_bit0 y mod int CARD('a bit0)) =\n    Abs_bit0\n     (Rep_bit0 x * Rep_bit0 y mod int CARD('a bit0) mod int CARD('a bit0))", "by fastforce"], ["proof (state)\nthis:\n  x * y = Abs (Rep x * Rep y mod int CARD('a bit0))\n\ngoal (12 subgoals):\n 1. \\<And>x y. x - y = Abs ((Rep x - Rep y) mod int CARD('a bit0))\n 2. \\<And>x. - x = Abs (- Rep x mod int CARD('a bit0))\n 3. strict_mono Rep\n 4. type_definition Rep Abs {0..<int CARD('a bit1)}\n 5. 1 < int CARD('a bit1)\n 6. 0 = Abs 0\n 7. 1 = Abs 1\n 8. \\<And>x y. x + y = Abs ((Rep x + Rep y) mod int CARD('a bit1))\n 9. \\<And>x y. x * y = Abs (Rep x * Rep y mod int CARD('a bit1))\n 10. \\<And>x y. x - y = Abs ((Rep x - Rep y) mod int CARD('a bit1))\nA total of 12 subgoals...", "show \"x - y = Abs ((Rep x - Rep y) mod int CARD('a bit0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x - y = Abs ((Rep x - Rep y) mod int CARD('a bit0))", "unfolding Abs_bit0_def Rep_bit0_def minus_bit0_def Abs_bit0'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_bit0 ((Rep_bit0 x - Rep_bit0 y) mod int CARD('a bit0)) =\n    Abs_bit0\n     ((Rep_bit0 x - Rep_bit0 y) mod int CARD('a bit0) mod int CARD('a bit0))", "by fastforce"], ["proof (state)\nthis:\n  x - y = Abs ((Rep x - Rep y) mod int CARD('a bit0))\n\ngoal (11 subgoals):\n 1. \\<And>x. - x = Abs (- Rep x mod int CARD('a bit0))\n 2. strict_mono Rep\n 3. type_definition Rep Abs {0..<int CARD('a bit1)}\n 4. 1 < int CARD('a bit1)\n 5. 0 = Abs 0\n 6. 1 = Abs 1\n 7. \\<And>x y. x + y = Abs ((Rep x + Rep y) mod int CARD('a bit1))\n 8. \\<And>x y. x * y = Abs (Rep x * Rep y mod int CARD('a bit1))\n 9. \\<And>x y. x - y = Abs ((Rep x - Rep y) mod int CARD('a bit1))\n 10. \\<And>x. - x = Abs (- Rep x mod int CARD('a bit1))\nA total of 11 subgoals...", "show \"- x = Abs (- Rep x mod int CARD('a bit0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - x = Abs (- Rep x mod int CARD('a bit0))", "unfolding Abs_bit0_def Rep_bit0_def uminus_bit0_def Abs_bit0'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_bit0 (- Rep_bit0 x mod int CARD('a bit0)) =\n    Abs_bit0 (- Rep_bit0 x mod int CARD('a bit0) mod int CARD('a bit0))", "by fastforce"], ["proof (state)\nthis:\n  - x = Abs (- Rep x mod int CARD('a bit0))\n\ngoal (10 subgoals):\n 1. strict_mono Rep\n 2. type_definition Rep Abs {0..<int CARD('a bit1)}\n 3. 1 < int CARD('a bit1)\n 4. 0 = Abs 0\n 5. 1 = Abs 1\n 6. \\<And>x y. x + y = Abs ((Rep x + Rep y) mod int CARD('a bit1))\n 7. \\<And>x y. x * y = Abs (Rep x * Rep y mod int CARD('a bit1))\n 8. \\<And>x y. x - y = Abs ((Rep x - Rep y) mod int CARD('a bit1))\n 9. \\<And>x. - x = Abs (- Rep x mod int CARD('a bit1))\n 10. strict_mono Rep", "show \"(0::'a bit1) = Abs (0::int)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 = Abs 0", "unfolding Abs_bit1_def Abs_bit1'_def zero_bit1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_bit1 0 = Abs_bit1 (0 mod int CARD('a bit1))", "by auto"], ["proof (state)\nthis:\n  0 = Abs 0\n\ngoal (9 subgoals):\n 1. strict_mono Rep\n 2. type_definition Rep Abs {0..<int CARD('a bit1)}\n 3. 1 < int CARD('a bit1)\n 4. 1 = Abs 1\n 5. \\<And>x y. x + y = Abs ((Rep x + Rep y) mod int CARD('a bit1))\n 6. \\<And>x y. x * y = Abs (Rep x * Rep y mod int CARD('a bit1))\n 7. \\<And>x y. x - y = Abs ((Rep x - Rep y) mod int CARD('a bit1))\n 8. \\<And>x. - x = Abs (- Rep x mod int CARD('a bit1))\n 9. strict_mono Rep", "show \"(1::int) < int CARD('a bit1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 < int CARD('a bit1)", "by (metis bit1.size1)"], ["proof (state)\nthis:\n  1 < int CARD('a bit1)\n\ngoal (8 subgoals):\n 1. strict_mono Rep\n 2. type_definition Rep Abs {0..<int CARD('a bit1)}\n 3. 1 = Abs 1\n 4. \\<And>x y. x + y = Abs ((Rep x + Rep y) mod int CARD('a bit1))\n 5. \\<And>x y. x * y = Abs (Rep x * Rep y mod int CARD('a bit1))\n 6. \\<And>x y. x - y = Abs ((Rep x - Rep y) mod int CARD('a bit1))\n 7. \\<And>x. - x = Abs (- Rep x mod int CARD('a bit1))\n 8. strict_mono Rep", "show \"(1::'a bit1) = Abs (1::int)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 = Abs 1", "unfolding Abs_bit1_def Abs_bit1'_def one_bit1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_bit1 1 = Abs_bit1 (1 mod int CARD('a bit1))", "by (metis bit1.of_nat_eq of_nat_1 one_bit1_def)"], ["proof (state)\nthis:\n  1 = Abs 1\n\ngoal (7 subgoals):\n 1. strict_mono Rep\n 2. type_definition Rep Abs {0..<int CARD('a bit1)}\n 3. \\<And>x y. x + y = Abs ((Rep x + Rep y) mod int CARD('a bit1))\n 4. \\<And>x y. x * y = Abs (Rep x * Rep y mod int CARD('a bit1))\n 5. \\<And>x y. x - y = Abs ((Rep x - Rep y) mod int CARD('a bit1))\n 6. \\<And>x. - x = Abs (- Rep x mod int CARD('a bit1))\n 7. strict_mono Rep", "fix x y :: \"'a bit1\""], ["proof (state)\ngoal (7 subgoals):\n 1. strict_mono Rep\n 2. type_definition Rep Abs {0..<int CARD('a bit1)}\n 3. \\<And>x y. x + y = Abs ((Rep x + Rep y) mod int CARD('a bit1))\n 4. \\<And>x y. x * y = Abs (Rep x * Rep y mod int CARD('a bit1))\n 5. \\<And>x y. x - y = Abs ((Rep x - Rep y) mod int CARD('a bit1))\n 6. \\<And>x. - x = Abs (- Rep x mod int CARD('a bit1))\n 7. strict_mono Rep", "show \"x + y = Abs ((Rep x + Rep y) mod int CARD('a bit1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x + y = Abs ((Rep x + Rep y) mod int CARD('a bit1))", "unfolding Abs_bit1_def Abs_bit1'_def Rep_bit1_def plus_bit1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_bit1 ((Rep_bit1 x + Rep_bit1 y) mod int CARD('a bit1)) =\n    Abs_bit1\n     ((Rep_bit1 x + Rep_bit1 y) mod int CARD('a bit1) mod int CARD('a bit1))", "by fastforce"], ["proof (state)\nthis:\n  x + y = Abs ((Rep x + Rep y) mod int CARD('a bit1))\n\ngoal (6 subgoals):\n 1. strict_mono Rep\n 2. type_definition Rep Abs {0..<int CARD('a bit1)}\n 3. \\<And>x y. x * y = Abs (Rep x * Rep y mod int CARD('a bit1))\n 4. \\<And>x y. x - y = Abs ((Rep x - Rep y) mod int CARD('a bit1))\n 5. \\<And>x. - x = Abs (- Rep x mod int CARD('a bit1))\n 6. strict_mono Rep", "show \"x * y = Abs (Rep x * Rep y mod int CARD('a bit1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * y = Abs (Rep x * Rep y mod int CARD('a bit1))", "unfolding Abs_bit1_def Rep_bit1_def times_bit1_def Abs_bit1'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_bit1 (Rep_bit1 x * Rep_bit1 y mod int CARD('a bit1)) =\n    Abs_bit1\n     (Rep_bit1 x * Rep_bit1 y mod int CARD('a bit1) mod int CARD('a bit1))", "by fastforce"], ["proof (state)\nthis:\n  x * y = Abs (Rep x * Rep y mod int CARD('a bit1))\n\ngoal (5 subgoals):\n 1. strict_mono Rep\n 2. type_definition Rep Abs {0..<int CARD('a bit1)}\n 3. \\<And>x y. x - y = Abs ((Rep x - Rep y) mod int CARD('a bit1))\n 4. \\<And>x. - x = Abs (- Rep x mod int CARD('a bit1))\n 5. strict_mono Rep", "show \"x - y = Abs ((Rep x - Rep y) mod int CARD('a bit1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x - y = Abs ((Rep x - Rep y) mod int CARD('a bit1))", "unfolding Abs_bit1_def Rep_bit1_def minus_bit1_def Abs_bit1'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_bit1 ((Rep_bit1 x - Rep_bit1 y) mod int CARD('a bit1)) =\n    Abs_bit1\n     ((Rep_bit1 x - Rep_bit1 y) mod int CARD('a bit1) mod int CARD('a bit1))", "by fastforce"], ["proof (state)\nthis:\n  x - y = Abs ((Rep x - Rep y) mod int CARD('a bit1))\n\ngoal (4 subgoals):\n 1. strict_mono Rep\n 2. type_definition Rep Abs {0..<int CARD('a bit1)}\n 3. \\<And>x. - x = Abs (- Rep x mod int CARD('a bit1))\n 4. strict_mono Rep", "show \"- x = Abs (- Rep x mod int CARD('a bit1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - x = Abs (- Rep x mod int CARD('a bit1))", "unfolding Abs_bit1_def Rep_bit1_def uminus_bit1_def Abs_bit1'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_bit1 (- Rep_bit1 x mod int CARD('a bit1)) =\n    Abs_bit1 (- Rep_bit1 x mod int CARD('a bit1) mod int CARD('a bit1))", "by fastforce"], ["proof (state)\nthis:\n  - x = Abs (- Rep x mod int CARD('a bit1))\n\ngoal (3 subgoals):\n 1. strict_mono Rep\n 2. type_definition Rep Abs {0..<int CARD('a bit1)}\n 3. strict_mono Rep", "show \"type_definition (Rep::'a bit1 => int) (Abs:: int => 'a bit1) {0::int..<int CARD('a bit1)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. type_definition Rep Abs {0..<int CARD('a bit1)}", "proof (unfold type_definition_def Rep_bit1_def [abs_def]\n      Abs_bit1_def [abs_def] Abs_bit1'_def, intro conjI)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<forall>x. Rep_bit1 x \\<in> {0..<int CARD('a bit1)}\n 2. \\<forall>x. Abs_bit1 (Rep_bit1 x mod int CARD('a bit1)) = x\n 3. \\<forall>y.\n       y \\<in> {0..<int CARD('a bit1)} \\<longrightarrow>\n       Rep_bit1 (Abs_bit1 (y mod int CARD('a bit1))) = y", "have int_2: \"int 2 = 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int 2 = 2", "by auto"], ["proof (state)\nthis:\n  int 2 = 2\n\ngoal (3 subgoals):\n 1. \\<forall>x. Rep_bit1 x \\<in> {0..<int CARD('a bit1)}\n 2. \\<forall>x. Abs_bit1 (Rep_bit1 x mod int CARD('a bit1)) = x\n 3. \\<forall>y.\n       y \\<in> {0..<int CARD('a bit1)} \\<longrightarrow>\n       Rep_bit1 (Abs_bit1 (y mod int CARD('a bit1))) = y", "show \"\\<forall>x::'a bit1. Rep_bit1 x \\<in> {0::int..<int CARD('a bit1)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x. Rep_bit1 x \\<in> {0..<int CARD('a bit1)}", "unfolding card_bit1"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x. Rep_bit1 x \\<in> {0..<int (Suc (2 * CARD('a)))}", "unfolding of_nat_Suc of_nat_mult"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x. Rep_bit1 x \\<in> {0..<1 + int 2 * int CARD('a)}", "using Rep_bit1 [where ?'a = \"'a\"]"], ["proof (prove)\nusing this:\n  Rep_bit1 ?x \\<in> {0..<1 + 2 * int CARD('a)}\n\ngoal (1 subgoal):\n 1. \\<forall>x. Rep_bit1 x \\<in> {0..<1 + int 2 * int CARD('a)}", "unfolding int_2"], ["proof (prove)\nusing this:\n  Rep_bit1 ?x \\<in> {0..<1 + 2 * int CARD('a)}\n\ngoal (1 subgoal):\n 1. \\<forall>x. Rep_bit1 x \\<in> {0..<1 + 2 * int CARD('a)}", ".."], ["proof (state)\nthis:\n  \\<forall>x. Rep_bit1 x \\<in> {0..<int CARD('a bit1)}\n\ngoal (2 subgoals):\n 1. \\<forall>x. Abs_bit1 (Rep_bit1 x mod int CARD('a bit1)) = x\n 2. \\<forall>y.\n       y \\<in> {0..<int CARD('a bit1)} \\<longrightarrow>\n       Rep_bit1 (Abs_bit1 (y mod int CARD('a bit1))) = y", "show \"\\<forall>x::'a bit1. Abs_bit1 (Rep_bit1 x mod int CARD('a bit1)) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x. Abs_bit1 (Rep_bit1 x mod int CARD('a bit1)) = x", "by (metis Rep_bit1_inverse bit1.Rep_mod)"], ["proof (state)\nthis:\n  \\<forall>x. Abs_bit1 (Rep_bit1 x mod int CARD('a bit1)) = x\n\ngoal (1 subgoal):\n 1. \\<forall>y.\n       y \\<in> {0..<int CARD('a bit1)} \\<longrightarrow>\n       Rep_bit1 (Abs_bit1 (y mod int CARD('a bit1))) = y", "show \"\\<forall>y::int. y \\<in> {0::int..<int CARD('a bit1)}\n    \\<longrightarrow> Rep_bit1 ((Abs_bit1::int => 'a bit1) (y mod int CARD('a bit1))) = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>y.\n       y \\<in> {0..<int CARD('a bit1)} \\<longrightarrow>\n       Rep_bit1 (Abs_bit1 (y mod int CARD('a bit1))) = y", "by (metis bit1.Abs_inverse bit1.Rep_mod)"], ["proof (state)\nthis:\n  \\<forall>y.\n     y \\<in> {0..<int CARD('a bit1)} \\<longrightarrow>\n     Rep_bit1 (Abs_bit1 (y mod int CARD('a bit1))) = y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  type_definition Rep Abs {0..<int CARD('a bit1)}\n\ngoal (2 subgoals):\n 1. strict_mono Rep\n 2. strict_mono Rep", "show \"strict_mono (Rep::'a bit0 => int)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strict_mono Rep", "unfolding strict_mono_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y. x < y \\<longrightarrow> Rep x < Rep y", "by (metis Rep_bit0_def less_bit0_def)"], ["proof (state)\nthis:\n  strict_mono Rep\n\ngoal (1 subgoal):\n 1. strict_mono Rep", "show \"strict_mono (Rep::'a bit1 => int)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strict_mono Rep", "unfolding strict_mono_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y. x < y \\<longrightarrow> Rep x < Rep y", "by (metis Rep_bit1_def less_bit1_def)"], ["proof (state)\nthis:\n  strict_mono Rep\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "end"]]}