{"file_name": "/home/qj213/afp-2021-10-22/thys/Rank_Nullity_Theorem/Miscellaneous.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Rank_Nullity_Theorem", "problem_names": ["lemma nrows_not_0[simp]:\n  shows \"0 \\<noteq> nrows A\"", "lemma ncols_not_0[simp]:\n  shows \"0 \\<noteq> ncols A\"", "lemma nrows_transpose: \"nrows (transpose A) = ncols A\"", "lemma ncols_transpose: \"ncols (transpose A) = nrows A\"", "lemma finite_rows: \"finite (rows A)\"", "lemma finite_columns: \"finite (columns A)\"", "lemma transpose_vector: \"x v* A = transpose A *v x\"", "lemma transpose_zero[simp]: \"(transpose A = 0) = (A = 0)\"", "lemma vector_scalar_matrix_ac:\n  fixes k :: \"'a::{field}\" and x :: \"'a::{field}^'n\" and A :: \"'a^'m^'n\"\n  shows \"x v* (k *k A) = k *s (x v* A)\"", "lemma transpose_scalar: \"transpose (k *k A) = k *k transpose A\"", "lemma scalar_matrix_vector_assoc:\n  fixes A :: \"'a::{field}^'m^'n\"\n  shows \"k *s (A *v v) = k *k A *v v\"", "lemma matrix_scalar_vector_ac:\n  fixes A :: \"'a::{field}^'m^'n\"\n  shows \"A *v (k *s v) = k *k A *v v\"", "lemma card_finite:\n  assumes \"card S = CARD('n::finite)\"\n  shows \"finite S\"", "lemma independent_is_basis:\n  fixes B :: \"('a::{field}^'n) set\"\n  shows \"vec.independent B \\<and> card B = CARD('n) \\<longleftrightarrow> is_basis B\"", "lemma basis_finite:\n  fixes B :: \"('a::{field}^'n) set\"\n  assumes \"is_basis B\"\n  shows \"finite B\"", "lemma card_eq_dim_span_indep:\n  assumes \"dim (span A) = card A\" and \"finite A\"\n  shows \"independent A\"", "lemma dim_zero_eq:\n  assumes dim_A: \"dim A = 0\"\n  shows \"A = {} \\<or> A = {0}\"", "lemma dim_zero_eq': \n  assumes A: \"A = {} \\<or> A = {0}\"\n  shows \"dim A = 0\"", "lemma dim_zero_subspace_eq:\n  assumes subs_A: \"subspace A\"\n  shows \"(dim A = 0) = (A = {0})\"", "lemma span_0_imp_set_empty_or_0:\n  assumes \"span A = {0}\"\n  shows \"A = {} \\<or> A = {0}\"", "lemma linear_injective_ker_0:\n  shows \"inj f = ({x. f x = 0} = {0})\"", "lemma snd_if_conv:\n  shows \"snd (if P then (A,B) else (C,D))=(if P then B else D)\"", "lemma row_matrix_matrix_mult:\n  fixes A::\"'a::{comm_ring_1}^'n^'m\"\n  shows \"(P $ i) v* A = (P ** A) $ i\"", "lemma column_matrix_matrix_mult:\n  shows \"column i (P**A) = P *v (column i A)\"", "lemma matrix_matrix_mult_inner_mult:\n  shows \"(A ** B) $ i $ j = row i A \\<bullet> column j B\"", "lemma matrix_vmult_column_sum:\n  fixes A::\"'a::{field}^'n^'m\"\n  shows \"\\<exists>f. A *v x = sum (\\<lambda>y. f y *s y) (columns A)\"", "lemma matrix_inv:\n  assumes \"invertible M\"\n  shows matrix_inv_left: \"matrix_inv M ** M = mat 1\"\n    and matrix_inv_right: \"M ** matrix_inv M = mat 1\"", "lemma matrix_inv_unique:\n  fixes A::\"'a::{semiring_1}^'n^'n\"\n  assumes AB: \"A ** B = mat 1\" and BA: \"B ** A = mat 1\"\n  shows \"matrix_inv A = B\"", "lemma matrix_vector_mult_zero_eq:\n  assumes P: \"invertible P\"\n  shows \"((P**A)*v x = 0) = (A *v x = 0)\"", "lemma independent_image_matrix_vector_mult:\n  fixes P::\"'a::{field}^'n^'m\"\n  assumes ind_B: \"vec.independent B\" and inv_P: \"invertible P\"\n  shows \"vec.independent (((*v) P)` B)\"", "lemma independent_preimage_matrix_vector_mult:\nfixes P::\"'a::{field}^'n^'n\"\nassumes ind_B: \"vec.independent (((*v) P)` B)\" and inv_P: \"invertible P\"\nshows \"vec.independent B\"", "lemma dimension_vector[code_unfold]: \"vec.dimension TYPE('a::{field}) TYPE('rows::{mod_type})=CARD('rows)\""], "translations": [["", "lemma nrows_not_0[simp]:\n  shows \"0 \\<noteq> nrows A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<noteq> nrows A", "unfolding nrows_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<noteq> CARD('c)", "by simp"], ["", "lemma ncols_not_0[simp]:\n  shows \"0 \\<noteq> ncols A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<noteq> ncols A", "unfolding ncols_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<noteq> CARD('b)", "by simp"], ["", "lemma nrows_transpose: \"nrows (transpose A) = ncols A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nrows (Finite_Cartesian_Product.transpose A) = ncols A", "unfolding nrows_def ncols_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. CARD('c) = CARD('c)", ".."], ["", "lemma ncols_transpose: \"ncols (transpose A) = nrows A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ncols (Finite_Cartesian_Product.transpose A) = nrows A", "unfolding nrows_def ncols_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. CARD('b) = CARD('b)", ".."], ["", "lemma finite_rows: \"finite (rows A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (rows A)", "using finite_Atleast_Atmost_nat[of \"\\<lambda>i. row i A\"]"], ["proof (prove)\nusing this:\n  finite {row x A |x. x \\<in> UNIV}\n\ngoal (1 subgoal):\n 1. finite (rows A)", "unfolding rows_def"], ["proof (prove)\nusing this:\n  finite {row x A |x. x \\<in> UNIV}\n\ngoal (1 subgoal):\n 1. finite {row i A |i. i \\<in> UNIV}", "."], ["", "lemma finite_columns: \"finite (columns A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (columns A)", "using finite_Atleast_Atmost_nat[of \"\\<lambda>i. column i A\"]"], ["proof (prove)\nusing this:\n  finite {column x A |x. x \\<in> UNIV}\n\ngoal (1 subgoal):\n 1. finite (columns A)", "unfolding columns_def"], ["proof (prove)\nusing this:\n  finite {column x A |x. x \\<in> UNIV}\n\ngoal (1 subgoal):\n 1. finite {column i A |i. i \\<in> UNIV}", "."], ["", "lemma transpose_vector: \"x v* A = transpose A *v x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x v* A = Finite_Cartesian_Product.transpose A *v x", "by simp"], ["", "lemma transpose_zero[simp]: \"(transpose A = 0) = (A = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Finite_Cartesian_Product.transpose A = 0) = (A = 0)", "unfolding transpose_def zero_vec_def vec_eq_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>i ia.\n        (\\<chi>i j. A $ j $ i) $ i $ ia = (\\<chi>i ia. (0::'a)) $ i $ ia) =\n    (\\<forall>i ia. A $ i $ ia = (\\<chi>i ia. (0::'a)) $ i $ ia)", "by auto"], ["", "subsection\\<open>Theorems obtained from the AFP\\<close>"], ["", "text\\<open>The following theorems and definitions have been obtained from the AFP \n@{url \"http://isa-afp.org/browser_info/current/HOL/Tarskis_Geometry/Linear_Algebra2.html\"}.\nI have removed some restrictions over the type classes.\\<close>"], ["", "lemma vector_scalar_matrix_ac:\n  fixes k :: \"'a::{field}\" and x :: \"'a::{field}^'n\" and A :: \"'a^'m^'n\"\n  shows \"x v* (k *k A) = k *s (x v* A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x v* (k *k A) = k *s (x v* A)", "using scalar_vector_matrix_assoc"], ["proof (prove)\nusing this:\n  ?k *s ?x v* ?A = ?k *s (?x v* ?A)\n\ngoal (1 subgoal):\n 1. x v* (k *k A) = k *s (x v* A)", "unfolding vector_matrix_mult_def matrix_scalar_mult_def vec_eq_iff"], ["proof (prove)\nusing this:\n  \\<forall>i.\n     (\\<chi>j. \\<Sum>i\\<in>UNIV. ?A $ i $ j * (?k *s ?x) $ i) $ i =\n     (?k *s (\\<chi>j. \\<Sum>i\\<in>UNIV. ?A $ i $ j * ?x $ i)) $ i\n\ngoal (1 subgoal):\n 1. \\<forall>i.\n       (\\<chi>j.\n           \\<Sum>i\\<in>UNIV. (\\<chi>i j. k * A $ i $ j) $ i $ j * x $ i) $\n       i =\n       (k *s (\\<chi>j. \\<Sum>i\\<in>UNIV. A $ i $ j * x $ i)) $ i", "by (auto simp add: sum_distrib_left vector_space_over_itself.scale_scale)"], ["", "lemma transpose_scalar: \"transpose (k *k A) = k *k transpose A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Finite_Cartesian_Product.transpose (k *k A) =\n    k *k Finite_Cartesian_Product.transpose A", "unfolding transpose_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<chi>i j. (k *k A) $ j $ i) = k *k (\\<chi>i j. A $ j $ i)", "by (vector, simp add: matrix_scalar_mult_def)"], ["", "lemma scalar_matrix_vector_assoc:\n  fixes A :: \"'a::{field}^'m^'n\"\n  shows \"k *s (A *v v) = k *k A *v v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k *s (A *v v) = k *k A *v v", "by (metis transpose_scalar vector_scalar_matrix_ac vector_transpose_matrix)"], ["", "lemma matrix_scalar_vector_ac:\n  fixes A :: \"'a::{field}^'m^'n\"\n  shows \"A *v (k *s v) = k *k A *v v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A *v (k *s v) = k *k A *v v", "by (simp add: Miscellaneous.scalar_matrix_vector_assoc vec.scale)"], ["", "definition\n  is_basis :: \"('a::{field}^'n) set => bool\" where\n  \"is_basis S \\<equiv> vec.independent S \\<and> vec.span S = UNIV\""], ["", "lemma card_finite:\n  assumes \"card S = CARD('n::finite)\"\n  shows \"finite S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite S", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite S", "from \\<open>card S = CARD('n)\\<close>"], ["proof (chain)\npicking this:\n  card S = CARD('n)", "have \"card S \\<noteq> 0\""], ["proof (prove)\nusing this:\n  card S = CARD('n)\n\ngoal (1 subgoal):\n 1. card S \\<noteq> 0", "by simp"], ["proof (state)\nthis:\n  card S \\<noteq> 0\n\ngoal (1 subgoal):\n 1. finite S", "with card_eq_0_iff [of S]"], ["proof (chain)\npicking this:\n  (card S = 0) = (S = {} \\<or> infinite S)\n  card S \\<noteq> 0", "show \"finite S\""], ["proof (prove)\nusing this:\n  (card S = 0) = (S = {} \\<or> infinite S)\n  card S \\<noteq> 0\n\ngoal (1 subgoal):\n 1. finite S", "by simp"], ["proof (state)\nthis:\n  finite S\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma independent_is_basis:\n  fixes B :: \"('a::{field}^'n) set\"\n  shows \"vec.independent B \\<and> card B = CARD('n) \\<longleftrightarrow> is_basis B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (vec.independent B \\<and> card B = CARD('n)) = is_basis B", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. vec.independent B \\<and> card B = CARD('n) \\<Longrightarrow> is_basis B\n 2. is_basis B \\<Longrightarrow> vec.independent B \\<and> card B = CARD('n)", "assume \"vec.independent B \\<and> card B = CARD('n)\""], ["proof (state)\nthis:\n  vec.independent B \\<and> card B = CARD('n)\n\ngoal (2 subgoals):\n 1. vec.independent B \\<and> card B = CARD('n) \\<Longrightarrow> is_basis B\n 2. is_basis B \\<Longrightarrow> vec.independent B \\<and> card B = CARD('n)", "hence \"vec.independent B\" and \"card B = CARD('n)\""], ["proof (prove)\nusing this:\n  vec.independent B \\<and> card B = CARD('n)\n\ngoal (1 subgoal):\n 1. vec.independent B &&& card B = CARD('n)", "by simp+"], ["proof (state)\nthis:\n  vec.independent B\n  card B = CARD('n)\n\ngoal (2 subgoals):\n 1. vec.independent B \\<and> card B = CARD('n) \\<Longrightarrow> is_basis B\n 2. is_basis B \\<Longrightarrow> vec.independent B \\<and> card B = CARD('n)", "from card_finite [of B, where 'n = 'n] and \\<open>card B = CARD('n)\\<close>"], ["proof (chain)\npicking this:\n  card B = CARD('n) \\<Longrightarrow> finite B\n  card B = CARD('n)", "have \"finite B\""], ["proof (prove)\nusing this:\n  card B = CARD('n) \\<Longrightarrow> finite B\n  card B = CARD('n)\n\ngoal (1 subgoal):\n 1. finite B", "by simp"], ["proof (state)\nthis:\n  finite B\n\ngoal (2 subgoals):\n 1. vec.independent B \\<and> card B = CARD('n) \\<Longrightarrow> is_basis B\n 2. is_basis B \\<Longrightarrow> vec.independent B \\<and> card B = CARD('n)", "from \\<open>card B = CARD('n)\\<close>"], ["proof (chain)\npicking this:\n  card B = CARD('n)", "have \"card B = vec.dim (UNIV :: (('a^'n) set))\""], ["proof (prove)\nusing this:\n  card B = CARD('n)\n\ngoal (1 subgoal):\n 1. card B = vec.dim UNIV", "unfolding vec_dim_card"], ["proof (prove)\nusing this:\n  card B = CARD('n)\n\ngoal (1 subgoal):\n 1. card B = CARD('n)", "."], ["proof (state)\nthis:\n  card B = vec.dim UNIV\n\ngoal (2 subgoals):\n 1. vec.independent B \\<and> card B = CARD('n) \\<Longrightarrow> is_basis B\n 2. is_basis B \\<Longrightarrow> vec.independent B \\<and> card B = CARD('n)", "with vec.card_eq_dim [of B UNIV] and \\<open>finite B\\<close> and \\<open>vec.independent B\\<close>"], ["proof (chain)\npicking this:\n  \\<lbrakk>B \\<subseteq> UNIV; card B = vec.dim UNIV; finite B\\<rbrakk>\n  \\<Longrightarrow> vec.independent B = (UNIV \\<subseteq> vec.span B)\n  finite B\n  vec.independent B\n  card B = vec.dim UNIV", "have \"vec.span B = UNIV\""], ["proof (prove)\nusing this:\n  \\<lbrakk>B \\<subseteq> UNIV; card B = vec.dim UNIV; finite B\\<rbrakk>\n  \\<Longrightarrow> vec.independent B = (UNIV \\<subseteq> vec.span B)\n  finite B\n  vec.independent B\n  card B = vec.dim UNIV\n\ngoal (1 subgoal):\n 1. vec.span B = UNIV", "by auto"], ["proof (state)\nthis:\n  vec.span B = UNIV\n\ngoal (2 subgoals):\n 1. vec.independent B \\<and> card B = CARD('n) \\<Longrightarrow> is_basis B\n 2. is_basis B \\<Longrightarrow> vec.independent B \\<and> card B = CARD('n)", "with \\<open>vec.independent B\\<close>"], ["proof (chain)\npicking this:\n  vec.independent B\n  vec.span B = UNIV", "show \"is_basis B\""], ["proof (prove)\nusing this:\n  vec.independent B\n  vec.span B = UNIV\n\ngoal (1 subgoal):\n 1. is_basis B", "unfolding is_basis_def"], ["proof (prove)\nusing this:\n  vec.independent B\n  vec.span B = UNIV\n\ngoal (1 subgoal):\n 1. vec.independent B \\<and> vec.span B = UNIV", ".."], ["proof (state)\nthis:\n  is_basis B\n\ngoal (1 subgoal):\n 1. is_basis B \\<Longrightarrow> vec.independent B \\<and> card B = CARD('n)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. is_basis B \\<Longrightarrow> vec.independent B \\<and> card B = CARD('n)", "assume \"is_basis B\""], ["proof (state)\nthis:\n  is_basis B\n\ngoal (1 subgoal):\n 1. is_basis B \\<Longrightarrow> vec.independent B \\<and> card B = CARD('n)", "hence \"vec.independent B\""], ["proof (prove)\nusing this:\n  is_basis B\n\ngoal (1 subgoal):\n 1. vec.independent B", "unfolding is_basis_def"], ["proof (prove)\nusing this:\n  vec.independent B \\<and> vec.span B = UNIV\n\ngoal (1 subgoal):\n 1. vec.independent B", ".."], ["proof (state)\nthis:\n  vec.independent B\n\ngoal (1 subgoal):\n 1. is_basis B \\<Longrightarrow> vec.independent B \\<and> card B = CARD('n)", "moreover"], ["proof (state)\nthis:\n  vec.independent B\n\ngoal (1 subgoal):\n 1. is_basis B \\<Longrightarrow> vec.independent B \\<and> card B = CARD('n)", "have \"card B = CARD('n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card B = CARD('n)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. card B = CARD('n)", "have \"B \\<subseteq> UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B \\<subseteq> UNIV", "by simp"], ["proof (state)\nthis:\n  B \\<subseteq> UNIV\n\ngoal (1 subgoal):\n 1. card B = CARD('n)", "moreover"], ["proof (state)\nthis:\n  B \\<subseteq> UNIV\n\ngoal (1 subgoal):\n 1. card B = CARD('n)", "{"], ["proof (state)\nthis:\n  B \\<subseteq> UNIV\n\ngoal (1 subgoal):\n 1. card B = CARD('n)", "from \\<open>is_basis B\\<close>"], ["proof (chain)\npicking this:\n  is_basis B", "have \"UNIV \\<subseteq> vec.span B\" and \"vec.independent B\""], ["proof (prove)\nusing this:\n  is_basis B\n\ngoal (1 subgoal):\n 1. UNIV \\<subseteq> vec.span B &&& vec.independent B", "unfolding is_basis_def"], ["proof (prove)\nusing this:\n  vec.independent B \\<and> vec.span B = UNIV\n\ngoal (1 subgoal):\n 1. UNIV \\<subseteq> vec.span B &&& vec.independent B", "by simp+"], ["proof (state)\nthis:\n  UNIV \\<subseteq> vec.span B\n  vec.independent B\n\ngoal (1 subgoal):\n 1. card B = CARD('n)", "}"], ["proof (state)\nthis:\n  UNIV \\<subseteq> vec.span B\n  vec.independent B\n\ngoal (1 subgoal):\n 1. card B = CARD('n)", "ultimately"], ["proof (chain)\npicking this:\n  B \\<subseteq> UNIV\n  UNIV \\<subseteq> vec.span B\n  vec.independent B", "have \"card B = vec.dim (UNIV::((real^'n) set))\""], ["proof (prove)\nusing this:\n  B \\<subseteq> UNIV\n  UNIV \\<subseteq> vec.span B\n  vec.independent B\n\ngoal (1 subgoal):\n 1. card B = vec.dim UNIV", "using vec.basis_card_eq_dim [of B UNIV]"], ["proof (prove)\nusing this:\n  B \\<subseteq> UNIV\n  UNIV \\<subseteq> vec.span B\n  vec.independent B\n  \\<lbrakk>B \\<subseteq> UNIV; UNIV \\<subseteq> vec.span B;\n   vec.independent B\\<rbrakk>\n  \\<Longrightarrow> card B = vec.dim UNIV\n\ngoal (1 subgoal):\n 1. card B = vec.dim UNIV", "unfolding vec_dim_card"], ["proof (prove)\nusing this:\n  B \\<subseteq> UNIV\n  UNIV \\<subseteq> vec.span B\n  vec.independent B\n  \\<lbrakk>B \\<subseteq> UNIV; UNIV \\<subseteq> vec.span B;\n   vec.independent B\\<rbrakk>\n  \\<Longrightarrow> card B = CARD('n)\n\ngoal (1 subgoal):\n 1. card B = CARD('n)", "by simp"], ["proof (state)\nthis:\n  card B = vec.dim UNIV\n\ngoal (1 subgoal):\n 1. card B = CARD('n)", "then"], ["proof (chain)\npicking this:\n  card B = vec.dim UNIV", "show \"card B = CARD('n)\""], ["proof (prove)\nusing this:\n  card B = vec.dim UNIV\n\ngoal (1 subgoal):\n 1. card B = CARD('n)", "by (metis vec_dim_card)"], ["proof (state)\nthis:\n  card B = CARD('n)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  card B = CARD('n)\n\ngoal (1 subgoal):\n 1. is_basis B \\<Longrightarrow> vec.independent B \\<and> card B = CARD('n)", "ultimately"], ["proof (chain)\npicking this:\n  vec.independent B\n  card B = CARD('n)", "show \"vec.independent B \\<and> card B = CARD('n)\""], ["proof (prove)\nusing this:\n  vec.independent B\n  card B = CARD('n)\n\ngoal (1 subgoal):\n 1. vec.independent B \\<and> card B = CARD('n)", ".."], ["proof (state)\nthis:\n  vec.independent B \\<and> card B = CARD('n)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma basis_finite:\n  fixes B :: \"('a::{field}^'n) set\"\n  assumes \"is_basis B\"\n  shows \"finite B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite B", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite B", "from independent_is_basis [of B] and \\<open>is_basis B\\<close>"], ["proof (chain)\npicking this:\n  (vec.independent B \\<and> card B = CARD('n)) = is_basis B\n  is_basis B", "have \"card B = CARD('n)\""], ["proof (prove)\nusing this:\n  (vec.independent B \\<and> card B = CARD('n)) = is_basis B\n  is_basis B\n\ngoal (1 subgoal):\n 1. card B = CARD('n)", "by simp"], ["proof (state)\nthis:\n  card B = CARD('n)\n\ngoal (1 subgoal):\n 1. finite B", "with card_finite [of B, where 'n = 'n]"], ["proof (chain)\npicking this:\n  card B = CARD('n) \\<Longrightarrow> finite B\n  card B = CARD('n)", "show \"finite B\""], ["proof (prove)\nusing this:\n  card B = CARD('n) \\<Longrightarrow> finite B\n  card B = CARD('n)\n\ngoal (1 subgoal):\n 1. finite B", "by simp"], ["proof (state)\nthis:\n  finite B\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>Here ends the statements obtained from AFP: \n  @{url \"http://isa-afp.org/browser_info/current/HOL/Tarskis_Geometry/Linear_Algebra2.html\"}\n  which have been generalized.\\<close>"], ["", "subsection\\<open>Basic properties involving span, linearity and dimensions\\<close>"], ["", "context finite_dimensional_vector_space\nbegin"], ["", "text\\<open>This theorem is the reciprocal theorem of @{thm \"indep_card_eq_dim_span\"}\\<close>"], ["", "lemma card_eq_dim_span_indep:\n  assumes \"dim (span A) = card A\" and \"finite A\"\n  shows \"independent A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.independent A", "by (metis assms card_le_dim_spanning dim_subset equalityE span_superset)"], ["", "lemma dim_zero_eq:\n  assumes dim_A: \"dim A = 0\"\n  shows \"A = {} \\<or> A = {0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A = {} \\<or> A = {0::'b}", "using dim_A local.card_ge_dim_independent local.independent_empty"], ["proof (prove)\nusing this:\n  local.dim A = 0\n  \\<lbrakk>?B \\<subseteq> ?V; local.independent ?B;\n   local.dim ?V \\<le> card ?B\\<rbrakk>\n  \\<Longrightarrow> ?V \\<subseteq> local.span ?B\n  local.independent {}\n\ngoal (1 subgoal):\n 1. A = {} \\<or> A = {0::'b}", "by force"], ["", "lemma dim_zero_eq': \n  assumes A: \"A = {} \\<or> A = {0}\"\n  shows \"dim A = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.dim A = 0", "using assms local.dim_span local.indep_card_eq_dim_span local.independent_empty"], ["proof (prove)\nusing this:\n  A = {} \\<or> A = {0::'b}\n  local.dim (local.span ?S) = local.dim ?S\n  local.independent ?B \\<Longrightarrow>\n  finite ?B \\<and> card ?B = local.dim (local.span ?B)\n  local.independent {}\n\ngoal (1 subgoal):\n 1. local.dim A = 0", "by fastforce"], ["", "lemma dim_zero_subspace_eq:\n  assumes subs_A: \"subspace A\"\n  shows \"(dim A = 0) = (A = {0})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (local.dim A = 0) = (A = {0::'b})", "by (metis dim_zero_eq dim_zero_eq' subspace_0[OF subs_A] empty_iff)"], ["", "lemma span_0_imp_set_empty_or_0:\n  assumes \"span A = {0}\"\n  shows \"A = {} \\<or> A = {0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A = {} \\<or> A = {0::'b}", "by (metis assms span_superset subset_singletonD)"], ["", "end"], ["", "context Vector_Spaces.linear\nbegin"], ["", "lemma linear_injective_ker_0:\n  shows \"inj f = ({x. f x = 0} = {0})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj f = ({x. f x = (0::'c)} = {0::'b})", "using inj_iff_eq_0"], ["proof (prove)\nusing this:\n  inj f = (\\<forall>x. f x = (0::'c) \\<longrightarrow> x = (0::'b))\n\ngoal (1 subgoal):\n 1. inj f = ({x. f x = (0::'c)} = {0::'b})", "by auto"], ["", "end"], ["", "lemma snd_if_conv:\n  shows \"snd (if P then (A,B) else (C,D))=(if P then B else D)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (if P then (A, B) else (C, D)) = (if P then B else D)", "by simp"], ["", "subsection\\<open>Basic properties about matrix multiplication\\<close>"], ["", "lemma row_matrix_matrix_mult:\n  fixes A::\"'a::{comm_ring_1}^'n^'m\"\n  shows \"(P $ i) v* A = (P ** A) $ i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P $ i v* A = (P ** A) $ i", "unfolding vec_eq_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>ia. (P $ i v* A) $ ia = (P ** A) $ i $ ia", "unfolding vector_matrix_mult_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>ia.\n       (\\<chi>j. \\<Sum>ia\\<in>UNIV. A $ ia $ j * P $ i $ ia) $ ia =\n       (P ** A) $ i $ ia", "unfolding matrix_matrix_mult_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>ia.\n       (\\<chi>j. \\<Sum>ia\\<in>UNIV. A $ ia $ j * P $ i $ ia) $ ia =\n       (\\<chi>i j. \\<Sum>k\\<in>UNIV. P $ i $ k * A $ k $ j) $ i $ ia", "by (auto intro!: sum.cong)"], ["", "corollary row_matrix_matrix_mult':\n  fixes A::\"'a::{comm_ring_1}^'n^'m\"\n  shows \"(row i P) v* A = row i (P ** A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. row i P v* A = row i (P ** A)", "using row_matrix_matrix_mult"], ["proof (prove)\nusing this:\n  ?P $ ?i v* ?A = (?P ** ?A) $ ?i\n\ngoal (1 subgoal):\n 1. row i P v* A = row i (P ** A)", "unfolding row_def vec_nth_inverse"], ["proof (prove)\nusing this:\n  ?P $ ?i v* ?A = (?P ** ?A) $ ?i\n\ngoal (1 subgoal):\n 1. P $ i v* A = (P ** A) $ i", "."], ["", "lemma column_matrix_matrix_mult:\n  shows \"column i (P**A) = P *v (column i A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. column i (P ** A) = P *v column i A", "unfolding column_def matrix_vector_mult_def matrix_matrix_mult_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<chi>ia.\n        (\\<chi>i j. \\<Sum>k\\<in>UNIV. P $ i $ k * A $ k $ j) $ ia $ i) =\n    (\\<chi>ia. \\<Sum>j\\<in>UNIV. P $ ia $ j * (\\<chi>ia. A $ ia $ i) $ j)", "by fastforce"], ["", "lemma matrix_matrix_mult_inner_mult:\n  shows \"(A ** B) $ i $ j = row i A \\<bullet> column j B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A ** B) $ i $ j = row i A \\<bullet> column j B", "unfolding inner_vec_def matrix_matrix_mult_def row_def column_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<chi>i j. \\<Sum>k\\<in>UNIV. A $ i $ k * B $ k $ j) $ i $ j =\n    (\\<Sum>ia\\<in>UNIV.\n       vec_lambda (($) (A $ i)) $ ia \\<bullet> (\\<chi>i. B $ i $ j) $ ia)", "by auto"], ["", "lemma matrix_vmult_column_sum:\n  fixes A::\"'a::{field}^'n^'m\"\n  shows \"\\<exists>f. A *v x = sum (\\<lambda>y. f y *s y) (columns A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>f. A *v x = (\\<Sum>y\\<in>columns A. f y *s y)", "proof (rule exI[of _ \"\\<lambda>y. sum (\\<lambda>i. x $ i) {i. y = column i A}\"])"], ["proof (state)\ngoal (1 subgoal):\n 1. A *v x = (\\<Sum>y\\<in>columns A. (\\<Sum>i | y = column i A. x $ i) *s y)", "let ?f=\"\\<lambda>y. sum (\\<lambda>i. x $ i) {i. y = column i A}\""], ["proof (state)\ngoal (1 subgoal):\n 1. A *v x = (\\<Sum>y\\<in>columns A. (\\<Sum>i | y = column i A. x $ i) *s y)", "let ?g=\"(\\<lambda>y. {i. y=column i (A)})\""], ["proof (state)\ngoal (1 subgoal):\n 1. A *v x = (\\<Sum>y\\<in>columns A. (\\<Sum>i | y = column i A. x $ i) *s y)", "have inj: \"inj_on ?g (columns (A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on (\\<lambda>y. {i. y = column i A}) (columns A)", "unfolding inj_on_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>columns A.\n       \\<forall>y\\<in>columns A.\n          {i. x = column i A} = {i. y = column i A} \\<longrightarrow> x = y", "unfolding columns_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{column i A |i. i \\<in> UNIV}.\n       \\<forall>y\\<in>{column i A |i. i \\<in> UNIV}.\n          {i. x = column i A} = {i. y = column i A} \\<longrightarrow> x = y", "by auto"], ["proof (state)\nthis:\n  inj_on (\\<lambda>y. {i. y = column i A}) (columns A)\n\ngoal (1 subgoal):\n 1. A *v x = (\\<Sum>y\\<in>columns A. (\\<Sum>i | y = column i A. x $ i) *s y)", "have union_univ: \"\\<Union> (?g`(columns (A))) = UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>y\\<in>columns A. {i. y = column i A}) = UNIV", "unfolding columns_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>y\\<in>{column i A |i. i \\<in> UNIV}. {i. y = column i A}) =\n    UNIV", "by auto"], ["proof (state)\nthis:\n  (\\<Union>y\\<in>columns A. {i. y = column i A}) = UNIV\n\ngoal (1 subgoal):\n 1. A *v x = (\\<Sum>y\\<in>columns A. (\\<Sum>i | y = column i A. x $ i) *s y)", "have \"A *v x = (\\<Sum>i\\<in>UNIV. x $ i *s column i A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A *v x = (\\<Sum>i\\<in>UNIV. x $ i *s column i A)", "unfolding matrix_mult_sum"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>UNIV. x $ i *s column i A) =\n    (\\<Sum>i\\<in>UNIV. x $ i *s column i A)", ".."], ["proof (state)\nthis:\n  A *v x = (\\<Sum>i\\<in>UNIV. x $ i *s column i A)\n\ngoal (1 subgoal):\n 1. A *v x = (\\<Sum>y\\<in>columns A. (\\<Sum>i | y = column i A. x $ i) *s y)", "also"], ["proof (state)\nthis:\n  A *v x = (\\<Sum>i\\<in>UNIV. x $ i *s column i A)\n\ngoal (1 subgoal):\n 1. A *v x = (\\<Sum>y\\<in>columns A. (\\<Sum>i | y = column i A. x $ i) *s y)", "have \"... = sum (\\<lambda>i.  x $ i *s column i A) (\\<Union>(?g`(columns A)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>UNIV. x $ i *s column i A) =\n    (\\<Sum>i\\<in>(\\<Union>y\\<in>columns A. {i. y = column i A}).\n       x $ i *s column i A)", "unfolding union_univ"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>UNIV. x $ i *s column i A) =\n    (\\<Sum>i\\<in>UNIV. x $ i *s column i A)", ".."], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>UNIV. x $ i *s column i A) =\n  (\\<Sum>i\\<in>(\\<Union>y\\<in>columns A. {i. y = column i A}).\n     x $ i *s column i A)\n\ngoal (1 subgoal):\n 1. A *v x = (\\<Sum>y\\<in>columns A. (\\<Sum>i | y = column i A. x $ i) *s y)", "also"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>UNIV. x $ i *s column i A) =\n  (\\<Sum>i\\<in>(\\<Union>y\\<in>columns A. {i. y = column i A}).\n     x $ i *s column i A)\n\ngoal (1 subgoal):\n 1. A *v x = (\\<Sum>y\\<in>columns A. (\\<Sum>i | y = column i A. x $ i) *s y)", "have \"... = sum (sum ((\\<lambda>i.  x $ i *s column i A)))  (?g`(columns A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>(\\<Union>y\\<in>columns A. {i. y = column i A}).\n       x $ i *s column i A) =\n    sum (sum (\\<lambda>i. x $ i *s column i A))\n     ((\\<lambda>y. {i. y = column i A}) ` columns A)", "by (rule sum.Union_disjoint[unfolded o_def], auto)"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>(\\<Union>y\\<in>columns A. {i. y = column i A}).\n     x $ i *s column i A) =\n  sum (sum (\\<lambda>i. x $ i *s column i A))\n   ((\\<lambda>y. {i. y = column i A}) ` columns A)\n\ngoal (1 subgoal):\n 1. A *v x = (\\<Sum>y\\<in>columns A. (\\<Sum>i | y = column i A. x $ i) *s y)", "also"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>(\\<Union>y\\<in>columns A. {i. y = column i A}).\n     x $ i *s column i A) =\n  sum (sum (\\<lambda>i. x $ i *s column i A))\n   ((\\<lambda>y. {i. y = column i A}) ` columns A)\n\ngoal (1 subgoal):\n 1. A *v x = (\\<Sum>y\\<in>columns A. (\\<Sum>i | y = column i A. x $ i) *s y)", "have \"... = sum ((sum ((\\<lambda>i.  x $ i *s column i A))) \\<circ> ?g)  (columns A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum (sum (\\<lambda>i. x $ i *s column i A))\n     ((\\<lambda>y. {i. y = column i A}) ` columns A) =\n    sum (sum (\\<lambda>i. x $ i *s column i A) \\<circ>\n         (\\<lambda>y. {i. y = column i A}))\n     (columns A)", "by (rule sum.reindex, simp add: inj)"], ["proof (state)\nthis:\n  sum (sum (\\<lambda>i. x $ i *s column i A))\n   ((\\<lambda>y. {i. y = column i A}) ` columns A) =\n  sum (sum (\\<lambda>i. x $ i *s column i A) \\<circ>\n       (\\<lambda>y. {i. y = column i A}))\n   (columns A)\n\ngoal (1 subgoal):\n 1. A *v x = (\\<Sum>y\\<in>columns A. (\\<Sum>i | y = column i A. x $ i) *s y)", "also"], ["proof (state)\nthis:\n  sum (sum (\\<lambda>i. x $ i *s column i A))\n   ((\\<lambda>y. {i. y = column i A}) ` columns A) =\n  sum (sum (\\<lambda>i. x $ i *s column i A) \\<circ>\n       (\\<lambda>y. {i. y = column i A}))\n   (columns A)\n\ngoal (1 subgoal):\n 1. A *v x = (\\<Sum>y\\<in>columns A. (\\<Sum>i | y = column i A. x $ i) *s y)", "have \"... =  sum (\\<lambda>y. ?f y *s y) (columns A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum (sum (\\<lambda>i. x $ i *s column i A) \\<circ>\n         (\\<lambda>y. {i. y = column i A}))\n     (columns A) =\n    (\\<Sum>y\\<in>columns A. (\\<Sum>i | y = column i A. x $ i) *s y)", "proof (rule sum.cong, unfold o_def)"], ["proof (state)\ngoal (2 subgoals):\n 1. columns A = columns A\n 2. \\<And>xa.\n       xa \\<in> columns A \\<Longrightarrow>\n       (\\<Sum>i | xa = column i A. x $ i *s column i A) =\n       (\\<Sum>i | xa = column i A. x $ i) *s xa", "fix xa"], ["proof (state)\ngoal (2 subgoals):\n 1. columns A = columns A\n 2. \\<And>xa.\n       xa \\<in> columns A \\<Longrightarrow>\n       (\\<Sum>i | xa = column i A. x $ i *s column i A) =\n       (\\<Sum>i | xa = column i A. x $ i) *s xa", "have \"sum (\\<lambda>i. x $ i *s column i A) {i. xa = column i A} \n      = sum (\\<lambda>i. x $ i *s xa) {i. xa = column i A}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i | xa = column i A. x $ i *s column i A) =\n    (\\<Sum>i | xa = column i A. x $ i *s xa)", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>i | xa = column i A. x $ i *s column i A) =\n  (\\<Sum>i | xa = column i A. x $ i *s xa)\n\ngoal (2 subgoals):\n 1. columns A = columns A\n 2. \\<And>xa.\n       xa \\<in> columns A \\<Longrightarrow>\n       (\\<Sum>i | xa = column i A. x $ i *s column i A) =\n       (\\<Sum>i | xa = column i A. x $ i) *s xa", "also"], ["proof (state)\nthis:\n  (\\<Sum>i | xa = column i A. x $ i *s column i A) =\n  (\\<Sum>i | xa = column i A. x $ i *s xa)\n\ngoal (2 subgoals):\n 1. columns A = columns A\n 2. \\<And>xa.\n       xa \\<in> columns A \\<Longrightarrow>\n       (\\<Sum>i | xa = column i A. x $ i *s column i A) =\n       (\\<Sum>i | xa = column i A. x $ i) *s xa", "have \"... = sum (\\<lambda>i. x $ i) {i. xa = column i A} *s xa\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i | xa = column i A. x $ i *s xa) =\n    (\\<Sum>i | xa = column i A. x $ i) *s xa", "using vec.scale_sum_left[of \"(\\<lambda>i. x $ i)\" \"{i. xa = column i A}\" xa]"], ["proof (prove)\nusing this:\n  (\\<Sum>i | xa = column i A. x $ i) *s xa =\n  (\\<Sum>a\\<in>{i. xa = column i A}. x $ a *s xa)\n\ngoal (1 subgoal):\n 1. (\\<Sum>i | xa = column i A. x $ i *s xa) =\n    (\\<Sum>i | xa = column i A. x $ i) *s xa", ".."], ["proof (state)\nthis:\n  (\\<Sum>i | xa = column i A. x $ i *s xa) =\n  (\\<Sum>i | xa = column i A. x $ i) *s xa\n\ngoal (2 subgoals):\n 1. columns A = columns A\n 2. \\<And>xa.\n       xa \\<in> columns A \\<Longrightarrow>\n       (\\<Sum>i | xa = column i A. x $ i *s column i A) =\n       (\\<Sum>i | xa = column i A. x $ i) *s xa", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>i | xa = column i A. x $ i *s column i A) =\n  (\\<Sum>i | xa = column i A. x $ i) *s xa", "show \"(\\<Sum>i | xa = column i A. x $ i *s column i A) = (\\<Sum>i | xa = column i A. x $ i) *s xa\""], ["proof (prove)\nusing this:\n  (\\<Sum>i | xa = column i A. x $ i *s column i A) =\n  (\\<Sum>i | xa = column i A. x $ i) *s xa\n\ngoal (1 subgoal):\n 1. (\\<Sum>i | xa = column i A. x $ i *s column i A) =\n    (\\<Sum>i | xa = column i A. x $ i) *s xa", "."], ["proof (state)\nthis:\n  (\\<Sum>i | xa = column i A. x $ i *s column i A) =\n  (\\<Sum>i | xa = column i A. x $ i) *s xa\n\ngoal (1 subgoal):\n 1. columns A = columns A", "qed rule"], ["proof (state)\nthis:\n  sum (sum (\\<lambda>i. x $ i *s column i A) \\<circ>\n       (\\<lambda>y. {i. y = column i A}))\n   (columns A) =\n  (\\<Sum>y\\<in>columns A. (\\<Sum>i | y = column i A. x $ i) *s y)\n\ngoal (1 subgoal):\n 1. A *v x = (\\<Sum>y\\<in>columns A. (\\<Sum>i | y = column i A. x $ i) *s y)", "finally"], ["proof (chain)\npicking this:\n  A *v x = (\\<Sum>y\\<in>columns A. (\\<Sum>i | y = column i A. x $ i) *s y)", "show \"A *v x = (\\<Sum>y\\<in>columns A. (\\<Sum>i | y = column i A. x $ i) *s y)\""], ["proof (prove)\nusing this:\n  A *v x = (\\<Sum>y\\<in>columns A. (\\<Sum>i | y = column i A. x $ i) *s y)\n\ngoal (1 subgoal):\n 1. A *v x = (\\<Sum>y\\<in>columns A. (\\<Sum>i | y = column i A. x $ i) *s y)", "."], ["proof (state)\nthis:\n  A *v x = (\\<Sum>y\\<in>columns A. (\\<Sum>i | y = column i A. x $ i) *s y)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection\\<open>Properties about invertibility\\<close>"], ["", "lemma matrix_inv:\n  assumes \"invertible M\"\n  shows matrix_inv_left: \"matrix_inv M ** M = mat 1\"\n    and matrix_inv_right: \"M ** matrix_inv M = mat 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_inv M ** M = mat (1::'a) &&& M ** matrix_inv M = mat (1::'a)", "using \\<open>invertible M\\<close> and someI_ex [of \"\\<lambda> N. M ** N = mat 1 \\<and> N ** M = mat 1\"]"], ["proof (prove)\nusing this:\n  invertible M\n  \\<exists>x.\n     M ** x = mat (1::'a) \\<and> x ** M = mat (1::'a) \\<Longrightarrow>\n  M ** (SOME x. M ** x = mat (1::'a) \\<and> x ** M = mat (1::'a)) =\n  mat (1::'a) \\<and>\n  (SOME x. M ** x = mat (1::'a) \\<and> x ** M = mat (1::'a)) ** M =\n  mat (1::'a)\n\ngoal (1 subgoal):\n 1. matrix_inv M ** M = mat (1::'a) &&& M ** matrix_inv M = mat (1::'a)", "unfolding invertible_def and matrix_inv_def"], ["proof (prove)\nusing this:\n  \\<exists>A'. M ** A' = mat (1::'a) \\<and> A' ** M = mat (1::'a)\n  \\<exists>x.\n     M ** x = mat (1::'a) \\<and> x ** M = mat (1::'a) \\<Longrightarrow>\n  M ** (SOME x. M ** x = mat (1::'a) \\<and> x ** M = mat (1::'a)) =\n  mat (1::'a) \\<and>\n  (SOME x. M ** x = mat (1::'a) \\<and> x ** M = mat (1::'a)) ** M =\n  mat (1::'a)\n\ngoal (1 subgoal):\n 1. (SOME A'. M ** A' = mat (1::'a) \\<and> A' ** M = mat (1::'a)) ** M =\n    mat (1::'a) &&&\n    M ** (SOME A'. M ** A' = mat (1::'a) \\<and> A' ** M = mat (1::'a)) =\n    mat (1::'a)", "by simp_all"], ["", "text\\<open>In the library, @{thm \"matrix_inv_def\"} allows the use of non squary matrices.\n  The following lemma can be also proved fixing @{term \"A::'a::{semiring_1}^'n^'m\"}\\<close>"], ["", "lemma matrix_inv_unique:\n  fixes A::\"'a::{semiring_1}^'n^'n\"\n  assumes AB: \"A ** B = mat 1\" and BA: \"B ** A = mat 1\"\n  shows \"matrix_inv A = B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_inv A = B", "by (metis AB BA invertible_def matrix_inv_right matrix_mul_assoc matrix_mul_lid)"], ["", "lemma matrix_vector_mult_zero_eq:\n  assumes P: \"invertible P\"\n  shows \"((P**A)*v x = 0) = (A *v x = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P ** A *v x = 0) = (A *v x = 0)", "proof (rule iffI)"], ["proof (state)\ngoal (2 subgoals):\n 1. P ** A *v x = 0 \\<Longrightarrow> A *v x = 0\n 2. A *v x = 0 \\<Longrightarrow> P ** A *v x = 0", "assume \"P ** A *v x = 0\""], ["proof (state)\nthis:\n  P ** A *v x = 0\n\ngoal (2 subgoals):\n 1. P ** A *v x = 0 \\<Longrightarrow> A *v x = 0\n 2. A *v x = 0 \\<Longrightarrow> P ** A *v x = 0", "hence \"matrix_inv P *v (P ** A *v x) = matrix_inv P *v 0\""], ["proof (prove)\nusing this:\n  P ** A *v x = 0\n\ngoal (1 subgoal):\n 1. matrix_inv P *v (P ** A *v x) = matrix_inv P *v 0", "by simp"], ["proof (state)\nthis:\n  matrix_inv P *v (P ** A *v x) = matrix_inv P *v 0\n\ngoal (2 subgoals):\n 1. P ** A *v x = 0 \\<Longrightarrow> A *v x = 0\n 2. A *v x = 0 \\<Longrightarrow> P ** A *v x = 0", "hence \"matrix_inv P *v (P ** A *v x) =  0\""], ["proof (prove)\nusing this:\n  matrix_inv P *v (P ** A *v x) = matrix_inv P *v 0\n\ngoal (1 subgoal):\n 1. matrix_inv P *v (P ** A *v x) = 0", "by (metis matrix_vector_mult_0_right)"], ["proof (state)\nthis:\n  matrix_inv P *v (P ** A *v x) = 0\n\ngoal (2 subgoals):\n 1. P ** A *v x = 0 \\<Longrightarrow> A *v x = 0\n 2. A *v x = 0 \\<Longrightarrow> P ** A *v x = 0", "hence \"(matrix_inv P ** P ** A) *v x =  0\""], ["proof (prove)\nusing this:\n  matrix_inv P *v (P ** A *v x) = 0\n\ngoal (1 subgoal):\n 1. matrix_inv P ** P ** A *v x = 0", "by (metis matrix_vector_mul_assoc)"], ["proof (state)\nthis:\n  matrix_inv P ** P ** A *v x = 0\n\ngoal (2 subgoals):\n 1. P ** A *v x = 0 \\<Longrightarrow> A *v x = 0\n 2. A *v x = 0 \\<Longrightarrow> P ** A *v x = 0", "thus \"A *v x =  0\""], ["proof (prove)\nusing this:\n  matrix_inv P ** P ** A *v x = 0\n\ngoal (1 subgoal):\n 1. A *v x = 0", "by (metis assms matrix_inv_left matrix_mul_lid)"], ["proof (state)\nthis:\n  A *v x = 0\n\ngoal (1 subgoal):\n 1. A *v x = 0 \\<Longrightarrow> P ** A *v x = 0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. A *v x = 0 \\<Longrightarrow> P ** A *v x = 0", "assume \"A *v x = 0\""], ["proof (state)\nthis:\n  A *v x = 0\n\ngoal (1 subgoal):\n 1. A *v x = 0 \\<Longrightarrow> P ** A *v x = 0", "thus \"P ** A *v x = 0\""], ["proof (prove)\nusing this:\n  A *v x = 0\n\ngoal (1 subgoal):\n 1. P ** A *v x = 0", "by (metis matrix_vector_mul_assoc matrix_vector_mult_0_right)"], ["proof (state)\nthis:\n  P ** A *v x = 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma independent_image_matrix_vector_mult:\n  fixes P::\"'a::{field}^'n^'m\"\n  assumes ind_B: \"vec.independent B\" and inv_P: \"invertible P\"\n  shows \"vec.independent (((*v) P)` B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec.independent ((*v) P ` B)", "proof (rule vec.independent_injective_image)"], ["proof (state)\ngoal (2 subgoals):\n 1. vec.independent B\n 2. inj_on ((*v) P) (vec.span B)", "show \"vec.independent B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec.independent B", "using ind_B"], ["proof (prove)\nusing this:\n  vec.independent B\n\ngoal (1 subgoal):\n 1. vec.independent B", "."], ["proof (state)\nthis:\n  vec.independent B\n\ngoal (1 subgoal):\n 1. inj_on ((*v) P) (vec.span B)", "show \"inj_on ((*v) P) (vec.span B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on ((*v) P) (vec.span B)", "using inj_matrix_vector_mult[OF inv_P]"], ["proof (prove)\nusing this:\n  inj ((*v) P)\n\ngoal (1 subgoal):\n 1. inj_on ((*v) P) (vec.span B)", "unfolding inj_on_def"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>UNIV.\n     \\<forall>y\\<in>UNIV. P *v x = P *v y \\<longrightarrow> x = y\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>vec.span B.\n       \\<forall>y\\<in>vec.span B. P *v x = P *v y \\<longrightarrow> x = y", "by simp"], ["proof (state)\nthis:\n  inj_on ((*v) P) (vec.span B)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma independent_preimage_matrix_vector_mult:\nfixes P::\"'a::{field}^'n^'n\"\nassumes ind_B: \"vec.independent (((*v) P)` B)\" and inv_P: \"invertible P\"\nshows \"vec.independent B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec.independent B", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. vec.independent B", "have \"vec.independent (((*v) (matrix_inv P))` (((*v) P)` B))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec.independent ((*v) (matrix_inv P) ` (*v) P ` B)", "proof (rule independent_image_matrix_vector_mult)"], ["proof (state)\ngoal (2 subgoals):\n 1. vec.independent ((*v) P ` B)\n 2. invertible (matrix_inv P)", "show \"vec.independent ((*v) P ` B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec.independent ((*v) P ` B)", "using ind_B"], ["proof (prove)\nusing this:\n  vec.independent ((*v) P ` B)\n\ngoal (1 subgoal):\n 1. vec.independent ((*v) P ` B)", "."], ["proof (state)\nthis:\n  vec.independent ((*v) P ` B)\n\ngoal (1 subgoal):\n 1. invertible (matrix_inv P)", "show \"invertible (matrix_inv P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invertible (matrix_inv P)", "by (metis matrix_inv_left matrix_inv_right inv_P invertible_def)"], ["proof (state)\nthis:\n  invertible (matrix_inv P)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  vec.independent ((*v) (matrix_inv P) ` (*v) P ` B)\n\ngoal (1 subgoal):\n 1. vec.independent B", "moreover"], ["proof (state)\nthis:\n  vec.independent ((*v) (matrix_inv P) ` (*v) P ` B)\n\ngoal (1 subgoal):\n 1. vec.independent B", "have \"((*v) (matrix_inv P))` (((*v) P)` B) = B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (*v) (matrix_inv P) ` (*v) P ` B = B", "proof (auto)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xb. xb \\<in> B \\<Longrightarrow> matrix_inv P *v (P *v xb) \\<in> B\n 2. \\<And>x.\n       x \\<in> B \\<Longrightarrow> x \\<in> (*v) (matrix_inv P) ` (*v) P ` B", "fix x"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xb. xb \\<in> B \\<Longrightarrow> matrix_inv P *v (P *v xb) \\<in> B\n 2. \\<And>x.\n       x \\<in> B \\<Longrightarrow> x \\<in> (*v) (matrix_inv P) ` (*v) P ` B", "assume x: \"x \\<in> B\""], ["proof (state)\nthis:\n  x \\<in> B\n\ngoal (2 subgoals):\n 1. \\<And>xb. xb \\<in> B \\<Longrightarrow> matrix_inv P *v (P *v xb) \\<in> B\n 2. \\<And>x.\n       x \\<in> B \\<Longrightarrow> x \\<in> (*v) (matrix_inv P) ` (*v) P ` B", "show \"matrix_inv P *v (P *v x) \\<in> B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_inv P *v (P *v x) \\<in> B", "by (metis (full_types) x inv_P matrix_inv_left matrix_vector_mul_assoc matrix_vector_mul_lid)"], ["proof (state)\nthis:\n  matrix_inv P *v (P *v x) \\<in> B\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> B \\<Longrightarrow> x \\<in> (*v) (matrix_inv P) ` (*v) P ` B", "thus \"x \\<in> (*v) (matrix_inv P) ` (*v) P ` B\""], ["proof (prove)\nusing this:\n  matrix_inv P *v (P *v x) \\<in> B\n\ngoal (1 subgoal):\n 1. x \\<in> (*v) (matrix_inv P) ` (*v) P ` B", "unfolding image_def"], ["proof (prove)\nusing this:\n  matrix_inv P *v (P *v x) \\<in> B\n\ngoal (1 subgoal):\n 1. x \\<in> {y. \\<exists>x\\<in>{y. \\<exists>x\\<in>B. y = P *v x}.\n                   y = matrix_inv P *v x}", "by (auto, metis  inv_P matrix_inv_left matrix_vector_mul_assoc matrix_vector_mul_lid)"], ["proof (state)\nthis:\n  x \\<in> (*v) (matrix_inv P) ` (*v) P ` B\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (*v) (matrix_inv P) ` (*v) P ` B = B\n\ngoal (1 subgoal):\n 1. vec.independent B", "ultimately"], ["proof (chain)\npicking this:\n  vec.independent ((*v) (matrix_inv P) ` (*v) P ` B)\n  (*v) (matrix_inv P) ` (*v) P ` B = B", "show ?thesis"], ["proof (prove)\nusing this:\n  vec.independent ((*v) (matrix_inv P) ` (*v) P ` B)\n  (*v) (matrix_inv P) ` (*v) P ` B = B\n\ngoal (1 subgoal):\n 1. vec.independent B", "by simp"], ["proof (state)\nthis:\n  vec.independent B\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection\\<open>Properties about the dimension of vectors\\<close>"], ["", "lemma dimension_vector[code_unfold]: \"vec.dimension TYPE('a::{field}) TYPE('rows::{mod_type})=CARD('rows)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_dimensional_vector_space.dimension cart_basis = CARD('rows)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite_dimensional_vector_space.dimension cart_basis = CARD('rows)", "let ?f=\"\\<lambda>x. axis (from_nat x) 1::'a^'rows::{mod_type}\""], ["proof (state)\ngoal (1 subgoal):\n 1. finite_dimensional_vector_space.dimension cart_basis = CARD('rows)", "have \"vec.dimension TYPE('a::{field}) TYPE('rows::{mod_type}) = card (cart_basis::('a^'rows::{mod_type}) set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_dimensional_vector_space.dimension cart_basis = card cart_basis", "unfolding vec.dimension_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. card cart_basis = card cart_basis", ".."], ["proof (state)\nthis:\n  finite_dimensional_vector_space.dimension cart_basis = card cart_basis\n\ngoal (1 subgoal):\n 1. finite_dimensional_vector_space.dimension cart_basis = CARD('rows)", "also"], ["proof (state)\nthis:\n  finite_dimensional_vector_space.dimension cart_basis = card cart_basis\n\ngoal (1 subgoal):\n 1. finite_dimensional_vector_space.dimension cart_basis = CARD('rows)", "have \"... = card{..<CARD('rows)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card cart_basis = card {..<CARD('rows)}", "unfolding cart_basis_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. card {axis i (1::'a) |i. i \\<in> UNIV} = card {..<CARD('rows)}", "proof (rule bij_betw_same_card[symmetric, of ?f], unfold bij_betw_def, unfold inj_on_def axis_eq_axis, auto)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x < CARD('rows); y < CARD('rows);\n        mod_type_class.from_nat x = mod_type_class.from_nat y\\<rbrakk>\n       \\<Longrightarrow> x = y\n 2. \\<And>i.\n       axis i (1::'a)\n       \\<in> (\\<lambda>x. axis (mod_type_class.from_nat x) (1::'a)) `\n             {..<CARD('rows)}", "fix x y"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x < CARD('rows); y < CARD('rows);\n        mod_type_class.from_nat x = mod_type_class.from_nat y\\<rbrakk>\n       \\<Longrightarrow> x = y\n 2. \\<And>i.\n       axis i (1::'a)\n       \\<in> (\\<lambda>x. axis (mod_type_class.from_nat x) (1::'a)) `\n             {..<CARD('rows)}", "assume x: \"x < CARD('rows)\" and y: \"y < CARD('rows)\" and eq: \"from_nat x = (from_nat y::'rows)\""], ["proof (state)\nthis:\n  x < CARD('rows)\n  y < CARD('rows)\n  mod_type_class.from_nat x = mod_type_class.from_nat y\n\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x < CARD('rows); y < CARD('rows);\n        mod_type_class.from_nat x = mod_type_class.from_nat y\\<rbrakk>\n       \\<Longrightarrow> x = y\n 2. \\<And>i.\n       axis i (1::'a)\n       \\<in> (\\<lambda>x. axis (mod_type_class.from_nat x) (1::'a)) `\n             {..<CARD('rows)}", "show \"x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = y", "using from_nat_eq_imp_eq[OF eq x y]"], ["proof (prove)\nusing this:\n  x = y\n\ngoal (1 subgoal):\n 1. x = y", "."], ["proof (state)\nthis:\n  x = y\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       axis i (1::'a)\n       \\<in> (\\<lambda>x. axis (mod_type_class.from_nat x) (1::'a)) `\n             {..<CARD('rows)}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       axis i (1::'a)\n       \\<in> (\\<lambda>x. axis (mod_type_class.from_nat x) (1::'a)) `\n             {..<CARD('rows)}", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       axis i (1::'a)\n       \\<in> (\\<lambda>x. axis (mod_type_class.from_nat x) (1::'a)) `\n             {..<CARD('rows)}", "show \"axis i 1 \\<in> (\\<lambda>x. axis (from_nat x::'rows) 1) ` {..<CARD('rows)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. axis i (1::'b)\n    \\<in> (\\<lambda>x. axis (mod_type_class.from_nat x) (1::'b)) `\n          {..<CARD('rows)}", "unfolding image_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. axis i (1::'b)\n    \\<in> {y. \\<exists>x\\<in>{..<CARD('rows)}.\n                 y = axis (mod_type_class.from_nat x) (1::'b)}", "by (auto, metis lessThan_iff to_nat_from_nat to_nat_less_card)"], ["proof (state)\nthis:\n  axis i (1::?'b1)\n  \\<in> (\\<lambda>x. axis (mod_type_class.from_nat x) (1::?'b1)) `\n        {..<CARD('rows)}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  card cart_basis = card {..<CARD('rows)}\n\ngoal (1 subgoal):\n 1. finite_dimensional_vector_space.dimension cart_basis = CARD('rows)", "also"], ["proof (state)\nthis:\n  card cart_basis = card {..<CARD('rows)}\n\ngoal (1 subgoal):\n 1. finite_dimensional_vector_space.dimension cart_basis = CARD('rows)", "have \"... = CARD('rows)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card {..<CARD('rows)} = CARD('rows)", "by (metis card_lessThan)"], ["proof (state)\nthis:\n  card {..<CARD('rows)} = CARD('rows)\n\ngoal (1 subgoal):\n 1. finite_dimensional_vector_space.dimension cart_basis = CARD('rows)", "finally"], ["proof (chain)\npicking this:\n  finite_dimensional_vector_space.dimension cart_basis = CARD('rows)", "show ?thesis"], ["proof (prove)\nusing this:\n  finite_dimensional_vector_space.dimension cart_basis = CARD('rows)\n\ngoal (1 subgoal):\n 1. finite_dimensional_vector_space.dimension cart_basis = CARD('rows)", "."], ["proof (state)\nthis:\n  finite_dimensional_vector_space.dimension cart_basis = CARD('rows)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection\\<open>Instantiations and interpretations\\<close>"], ["", "text\\<open>Functions between two real vector spaces form a real vector\\<close>"], ["", "instantiation \"fun\" :: (real_vector, real_vector) real_vector\nbegin"], ["", "definition \"scaleR_fun a f = (\\<lambda>i. a *\\<^sub>R f i )\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a \\<Rightarrow> 'b, real_vector_class)", "by (intro_classes, auto simp add: fun_eq_iff scaleR_fun_def scaleR_left.add scaleR_right.add)"], ["", "end"], ["", "instantiation vec :: (type, finite) equal\nbegin"], ["", "definition equal_vec :: \"('a, 'b::finite) vec => ('a, 'b::finite) vec => bool\" \n  where \"equal_vec x y = (\\<forall>i. x$i = y$i)\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(('a, 'b) vec, equal_class)", "proof (intro_classes)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y. equal_class.equal x y = (x = y)", "fix x y::\"('a, 'b::finite) vec\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y. equal_class.equal x y = (x = y)", "show \"equal_class.equal x y = (x = y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. equal_class.equal x y = (x = y)", "unfolding equal_vec_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>i. x $ i = y $ i) = (x = y)", "using vec_eq_iff"], ["proof (prove)\nusing this:\n  (?x = ?y) = (\\<forall>i. ?x $ i = ?y $ i)\n\ngoal (1 subgoal):\n 1. (\\<forall>i. x $ i = y $ i) = (x = y)", "by auto"], ["proof (state)\nthis:\n  equal_class.equal x y = (x = y)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "interpretation matrix: vector_space \"((*k))::'a::{field}=>'a^'cols^'rows=>'a^'cols^'rows\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vector_space (*k)", "proof (unfold_locales)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>a x y. a *k (x + y) = a *k x + a *k y\n 2. \\<And>a b x. (a + b) *k x = a *k x + b *k x\n 3. \\<And>a b x. a *k (b *k x) = a * b *k x\n 4. \\<And>x. (1::'a) *k x = x", "fix a::'a and x y::\"'a^'cols^'rows\""], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>a x y. a *k (x + y) = a *k x + a *k y\n 2. \\<And>a b x. (a + b) *k x = a *k x + b *k x\n 3. \\<And>a b x. a *k (b *k x) = a * b *k x\n 4. \\<And>x. (1::'a) *k x = x", "show \"a *k (x + y) = a *k x + a *k y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a *k (x + y) = a *k x + a *k y", "unfolding matrix_scalar_mult_def vec_eq_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i ia.\n       (\\<chi>i j. a * (x + y) $ i $ j) $ i $ ia =\n       ((\\<chi>i j. a * x $ i $ j) + (\\<chi>i j. a * y $ i $ j)) $ i $ ia", "by (simp add: vector_space_over_itself.scale_right_distrib)"], ["proof (state)\nthis:\n  a *k (x + y) = a *k x + a *k y\n\ngoal (3 subgoals):\n 1. \\<And>a b x. (a + b) *k x = a *k x + b *k x\n 2. \\<And>a b x. a *k (b *k x) = a * b *k x\n 3. \\<And>x. (1::'a) *k x = x", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>a b x. (a + b) *k x = a *k x + b *k x\n 2. \\<And>a b x. a *k (b *k x) = a * b *k x\n 3. \\<And>x. (1::'a) *k x = x", "fix a b::'a and x::\"'a^'cols^'rows\""], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>a b x. (a + b) *k x = a *k x + b *k x\n 2. \\<And>a b x. a *k (b *k x) = a * b *k x\n 3. \\<And>x. (1::'a) *k x = x", "show \"(a + b) *k x = a *k x + b *k x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a + b) *k x = a *k x + b *k x", "unfolding matrix_scalar_mult_def vec_eq_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i ia.\n       (\\<chi>i j. (a + b) * x $ i $ j) $ i $ ia =\n       ((\\<chi>i j. a * x $ i $ j) + (\\<chi>i j. b * x $ i $ j)) $ i $ ia", "by (simp add: comm_semiring_class.distrib)"], ["proof (state)\nthis:\n  (a + b) *k x = a *k x + b *k x\n\ngoal (2 subgoals):\n 1. \\<And>a b x. a *k (b *k x) = a * b *k x\n 2. \\<And>x. (1::'a) *k x = x", "show \"a *k (b *k x) = a * b *k x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a *k (b *k x) = a * b *k x", "unfolding matrix_scalar_mult_def vec_eq_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i ia.\n       (\\<chi>i j. a * (\\<chi>i j. b * x $ i $ j) $ i $ j) $ i $ ia =\n       (\\<chi>i j. a * b * x $ i $ j) $ i $ ia", "by auto"], ["proof (state)\nthis:\n  a *k (b *k x) = a * b *k x\n\ngoal (1 subgoal):\n 1. \\<And>x. (1::'a) *k x = x", "show\"1 *k x = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1::'a) *k x = x", "unfolding matrix_scalar_mult_def vec_eq_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i ia. (\\<chi>i j. (1::'a) * x $ i $ j) $ i $ ia = x $ i $ ia", "by auto"], ["proof (state)\nthis:\n  (1::'a) *k x = x\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}