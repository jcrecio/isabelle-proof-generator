{"file_name": "/home/qj213/afp-2021-10-22/thys/List-Infinite/ListInf/ListInf_Prefix.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/List-Infinite", "problem_names": ["lemma prefix_eq_prefix_take_ex: \"prefix xs ys = (\\<exists>n. ys \\<down> n = xs)\"", "lemma prefix_take_eq_prefix_take_ex: \"(ys \\<down> (length xs) = xs) = (\\<exists>n. ys \\<down> n = xs)\"", "lemma prefix_eq_prefix_take: \"prefix xs ys = (ys \\<down> (length xs) = xs)\"", "lemma strict_prefix_take_eq_strict_prefix_take_ex: \"\n  (ys \\<down> (length xs) = xs \\<and> xs \\<noteq> ys) =\n  ((\\<exists>n. ys \\<down> n = xs) \\<and> xs \\<noteq> ys)\"", "lemma strict_prefix_eq_strict_prefix_take_ex: \"strict_prefix xs ys = ((\\<exists>n. ys \\<down> n = xs) \\<and> xs \\<noteq> ys)\"", "lemma strict_prefix_eq_strict_prefix_take: \"strict_prefix xs ys = (ys \\<down> (length xs) = xs \\<and> xs \\<noteq> ys)\"", "lemma take_imp_prefix: \"prefix (xs \\<down> n) xs\"", "lemma eq_imp_prefix: \"xs = (ys::'a list) \\<Longrightarrow> prefix xs ys\"", "lemma le_take_imp_prefix: \"a \\<le> b \\<Longrightarrow> prefix (xs \\<down> a) (xs \\<down> b)\"", "lemma take_prefix_imp_le: \"\n  \\<lbrakk> a \\<le> length xs; prefix (xs \\<down> a) (xs \\<down> b) \\<rbrakk> \\<Longrightarrow> a \\<le> b\"", "lemma take_prefixeq_le_conv: \"\n  a \\<le> length xs \\<Longrightarrow> prefix (xs \\<down> a) (xs \\<down> b) = (a \\<le> b)\"", "lemma append_imp_prefix[simp, intro]: \"prefix a (a @ b)\"", "lemma prefix_imp_take_eq: \"\n  \\<lbrakk> n \\<le> length xs; prefix xs ys \\<rbrakk> \\<Longrightarrow> xs \\<down> n = ys \\<down> n\"", "lemma prefix_length_le_eq_conv: \"(prefix xs ys \\<and> length ys \\<le> length xs) = (xs = ys)\"", "lemma take_length_prefix_conv: \"\n  length xs \\<le> length ys \\<Longrightarrow> prefix (ys \\<down> length xs) xs = prefix xs ys\"", "lemma append_eq_imp_take: \"\n  \\<lbrakk> k \\<le> length xs; length r1 = k; r1 @ r2 = xs \\<rbrakk> \\<Longrightarrow> r1 = xs \\<down> k\"", "lemma take_the_conv: \"\n  xs \\<down> k = (if length xs \\<le> k then xs else (THE r. length r = k \\<and> (\\<exists>r2. r @ r2 = xs)))\"", "lemma prefix_refl: \"prefix xs (xs::'a list)\"", "lemma prefix_trans: \"\\<lbrakk> prefix xs ys; prefix (ys::'a list) zs \\<rbrakk> \\<Longrightarrow> prefix xs zs\"", "lemma prefixeq_antisym: \"\\<lbrakk> prefix xs ys; prefix (ys::'a list) xs \\<rbrakk> \\<Longrightarrow> xs = ys\"", "lemma zip_mirror[rule_format]: \"\n  \\<lbrakk> i < min (length xs) (length ys);\n    p1 = (zip xs ys) ! i; p2 = (zip ys xs) ! i \\<rbrakk> \\<Longrightarrow>\n  mirror_pair p1 = p2\"", "lemma mirror_pair_equal: \"equal_pair (mirror_pair p) = (equal_pair p)\"", "lemma equal_pair_count_le: \"equal_pair_count xs \\<le> length xs\"", "lemma equal_pair_count_0: \"\n  fst (hd ps) \\<noteq> snd (hd ps) \\<Longrightarrow> equal_pair_count ps = 0\"", "lemma equal_pair_count_Suc: \"\n  equal_pair_count ((a, a) # ps) = Suc (equal_pair_count ps)\"", "lemma equal_pair_count_eq_pairwise[rule_format]: \"\n  \\<lbrakk> length ps1 = length ps2;\n    \\<forall>i<length ps2. equal_pair (ps1 ! i) = equal_pair(ps2 ! i) \\<rbrakk>\n  \\<Longrightarrow> equal_pair_count ps1 = equal_pair_count ps2\"", "lemma equal_pair_count_mirror_pairwise[rule_format]: \"\n  \\<lbrakk> length ps1 = length ps2;\n    \\<forall>i<length ps2. ps1 ! i = mirror_pair (ps2 ! i) \\<rbrakk>\n  \\<Longrightarrow> equal_pair_count ps1 = equal_pair_count ps2\"", "lemma equal_pair_count_correct:\"\n  \\<And>i. i < equal_pair_count ps \\<Longrightarrow> equal_pair (ps ! i)\"", "lemma equal_pair_count_maximality_aux[rule_format]: \"\\<And>i.\n  i = equal_pair_count ps \\<Longrightarrow> length ps = i \\<or> \\<not> equal_pair (ps ! i)\"", "lemma equal_pair_count_maximality2a[rule_format]: \"\n  equal_pair_count ps = length ps \\<or> \\<comment> \\<open>either all pairs are equal\\<close>\n  (\\<forall>i\\<ge>equal_pair_count ps.(\\<exists>j\\<le>i. \\<not>equal_pair (ps ! j)))\"", "lemmas equal_pair_count_maximality =\n  equal_pair_count_maximality1a equal_pair_count_maximality1b\n  equal_pair_count_maximality2a equal_pair_count_maximality2b", "lemma inf_prefix_length_commute[rule_format]:\n  \"inf_prefix_length xs ys = inf_prefix_length ys xs\"", "lemma inf_prefix_length_leL[intro]:\n  \"inf_prefix_length xs ys \\<le> length xs\"", "lemmas inf_prefix_length_le =\n  inf_prefix_length_leL\n  inf_prefix_length_leR", "lemma inf_prefix_length_le_min[rule_format]:\n  \"inf_prefix_length xs ys \\<le> min (length xs) (length ys)\"", "lemma hd_inf_prefix_length_0: \"\n  hd xs \\<noteq> hd ys \\<Longrightarrow> inf_prefix_length xs ys = 0\"", "lemma inf_prefix_length_NilL[simp]: \"inf_prefix_length [] ys = 0\"", "lemma inf_prefix_length_NilR[simp]: \"inf_prefix_length xs [] = 0\"", "lemma inf_prefix_length_Suc[simp]: \"\n  inf_prefix_length (a # xs) (a # ys) = Suc (inf_prefix_length xs ys)\"", "lemma inf_prefix_length_correct: \"\n  i < inf_prefix_length xs ys \\<Longrightarrow> xs ! i = ys ! i\"", "lemma inf_prefix_length_maximality1[rule_format]: \"\n  inf_prefix_length xs ys \\<noteq> min (length xs) (length ys) \\<Longrightarrow>\n  xs ! (inf_prefix_length xs ys) \\<noteq> ys ! (inf_prefix_length xs ys)\"", "lemmas inf_prefix_length_maximality =\n  inf_prefix_length_maximality1 inf_prefix_length_maximality2", "lemma inf_prefix_length_append[simp]: \"\n  inf_prefix_length (zs @ xs) (zs @ ys) =\n  length zs + inf_prefix_length xs ys\"", "lemma inf_prefix_length_take_correct: \"\n  n \\<le> inf_prefix_length xs ys \\<Longrightarrow> xs \\<down> n = ys \\<down> n\"", "lemma inf_prefix_length_0_imp_hd_neq: \"\n  \\<lbrakk> xs \\<noteq> []; ys \\<noteq> []; inf_prefix_length xs ys = 0 \\<rbrakk> \\<Longrightarrow> hd xs \\<noteq> hd ys\"", "lemma length_inf_prefix: \"length (xs \\<sqinter> ys) = inf_prefix_length xs ys\"", "lemma inf_prefix_commute: \"xs \\<sqinter> ys = ys \\<sqinter> xs\"", "lemma inf_prefix_takeL: \"xs \\<sqinter> ys = xs \\<down> (inf_prefix_length xs ys)\"", "lemma inf_prefix_takeR: \"xs \\<sqinter> ys = ys \\<down> (inf_prefix_length xs ys)\"", "lemma inf_prefix_correct: \"i < length (xs \\<sqinter> ys) \\<Longrightarrow> xs ! i = ys ! i\"", "lemma inf_prefix_take_correct: \"\n  n \\<le> length (xs \\<sqinter> ys) \\<Longrightarrow> xs \\<down> n = ys \\<down> n\"", "lemma is_inf_prefix[rule_format]: \"\n  \\<lbrakk> length zs = length (xs \\<sqinter> ys);\n    \\<And>i. i < length (xs \\<sqinter> ys) \\<Longrightarrow> zs ! i = xs ! i \\<and> zs ! i = ys ! i \\<rbrakk> \\<Longrightarrow>\n  zs = xs \\<sqinter> ys\"", "lemma hd_inf_prefix_Nil: \"hd xs \\<noteq> hd ys \\<Longrightarrow> xs \\<sqinter> ys = []\"", "lemma inf_prefix_Nil_imp_hd_neq: \"\n  \\<lbrakk> xs \\<noteq> []; ys \\<noteq> []; xs \\<sqinter> ys = [] \\<rbrakk> \\<Longrightarrow> hd xs \\<noteq> hd ys\"", "lemma length_inf_prefix_append[simp]: \"\n  length ((zs @ xs) \\<sqinter> (zs @ ys)) =\n  length zs + length (xs \\<sqinter> ys)\"", "lemma inf_prefix_append[simp]: \"(zs @ xs) \\<sqinter> (zs @ ys) = zs @ (xs \\<sqinter> ys)\"", "lemma hd_neq_inf_prefix_append: \"\n  hd xs \\<noteq> hd ys \\<Longrightarrow> (zs @ xs) \\<sqinter> (zs @ ys) = zs\"", "lemma inf_prefix_NilL[simp]: \"[] \\<sqinter> ys = []\"", "lemmas inf_prefix_Nil = inf_prefix_NilL inf_prefix_NilR", "lemma inf_prefix_Cons[simp]: \"(a # xs) \\<sqinter> (a # ys) = a # xs \\<sqinter> ys\"", "lemma inf_prefix_le1: \"prefix (xs \\<sqinter> ys) xs\"", "lemma inf_prefix_le2: \"prefix (xs \\<sqinter> ys) ys\"", "lemma le_inf_prefix_iff: \"prefix x (y \\<sqinter> z) = (prefix x y \\<and> prefix x z)\"", "lemma le_imp_le_inf_prefix: \"\\<lbrakk> prefix x y; prefix x z \\<rbrakk> \\<Longrightarrow> prefix x (y \\<sqinter> z)\"", "lemma iprefix_eq_iprefix_take: \"(xs \\<sqsubseteq> f) = (f \\<Down> length xs = xs)\"", "lemma iprefix_take_eq_iprefix_take_ex: \"\n  (f \\<Down> length xs = xs) = (\\<exists>n. f \\<Down> n = xs)\"", "lemma iprefix_eq_iprefix_take_ex: \"(xs \\<sqsubseteq> f) = (\\<exists>n. f \\<Down> n = xs)\"", "lemma i_take_imp_iprefix[intro]: \"f \\<Down> n \\<sqsubseteq> f\"", "lemma i_take_prefix_le_conv: \"prefix (f \\<Down> a) (f \\<Down> b) = (a \\<le> b)\"", "lemma i_append_imp_iprefix[simp,intro]: \"xs \\<sqsubseteq> xs \\<frown> f\"", "lemma iprefix_imp_take_eq: \"\n  \\<lbrakk> n \\<le> length xs; xs \\<sqsubseteq> f \\<rbrakk> \\<Longrightarrow> xs \\<down> n = f \\<Down> n\"", "lemma prefixeq_iprefix_trans: \"\\<lbrakk> prefix xs ys; ys \\<sqsubseteq> f \\<rbrakk> \\<Longrightarrow> xs \\<sqsubseteq> f\"", "lemma i_take_length_prefix_conv: \"prefix (f \\<Down> length xs) xs = (xs \\<sqsubseteq> f)\"", "lemma iprefixI[intro?]: \"f = xs \\<frown> g \\<Longrightarrow> xs \\<sqsubseteq> f\"", "lemma iprefixE[elim?]: \"\\<lbrakk> xs \\<sqsubseteq> f; \\<And>g. f = xs \\<frown> g \\<Longrightarrow> C \\<rbrakk> \\<Longrightarrow> C\"", "lemma Nil_iprefix[iff]: \"[] \\<sqsubseteq> f\"", "lemma same_prefix_iprefix[simp]: \"(xs @ ys \\<sqsubseteq> xs \\<frown> f) = (ys \\<sqsubseteq> f)\"", "lemma prefix_iprefix[simp]: \"prefix xs ys \\<Longrightarrow> xs \\<sqsubseteq> ys \\<frown> f\"", "lemma append_iprefixD: \"xs @ ys \\<sqsubseteq> f \\<Longrightarrow> xs \\<sqsubseteq> f\"", "lemma iprefix_length_le_imp_prefix: \"\n  \\<lbrakk> xs \\<sqsubseteq> ys \\<frown> f; length xs \\<le> length ys \\<rbrakk> \\<Longrightarrow> prefix xs ys\"", "lemma iprefix_i_append: \"\n  (xs \\<sqsubseteq> ys \\<frown> f) = (prefix xs ys \\<or> (\\<exists>zs. xs = ys @ zs \\<and> zs \\<sqsubseteq> f))\"", "lemma i_append_one_iprefix: \"\n  xs \\<sqsubseteq> f \\<Longrightarrow> xs @ [f (length xs)] \\<sqsubseteq> f\"", "lemma iprefix_same_length_le: \"\n  \\<lbrakk> xs \\<sqsubseteq> f; ys \\<sqsubseteq> f; length xs \\<le> length ys \\<rbrakk> \\<Longrightarrow> prefix xs ys\"", "lemma iprefix_same_cases: \"\n  \\<lbrakk> xs \\<sqsubseteq> f; ys \\<sqsubseteq> f \\<rbrakk> \\<Longrightarrow> prefix xs ys \\<or> prefix ys xs\"", "lemma set_mono_iprefix: \"xs \\<sqsubseteq> f \\<Longrightarrow> set xs \\<subseteq> range f\""], "translations": [["", "lemma prefix_eq_prefix_take_ex: \"prefix xs ys = (\\<exists>n. ys \\<down> n = xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prefix xs ys = (\\<exists>n. ys \\<down> n = xs)", "apply (unfold prefix_def, safe)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>zs.\n       ys = xs @ zs \\<Longrightarrow> \\<exists>n. (xs @ zs) \\<down> n = xs\n 2. \\<And>n.\n       xs = ys \\<down> n \\<Longrightarrow>\n       \\<exists>zs. ys = ys \\<down> n @ zs", "apply (rule_tac x=\"length xs\" in exI, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       xs = ys \\<down> n \\<Longrightarrow>\n       \\<exists>zs. ys = ys \\<down> n @ zs", "apply (rule_tac x=\"ys \\<up> n\" in exI, simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma prefix_take_eq_prefix_take_ex: \"(ys \\<down> (length xs) = xs) = (\\<exists>n. ys \\<down> n = xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ys \\<down> length xs = xs) = (\\<exists>n. ys \\<down> n = xs)", "by (fastforce simp: min_def)"], ["", "lemma prefix_eq_prefix_take: \"prefix xs ys = (ys \\<down> (length xs) = xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prefix xs ys = (ys \\<down> length xs = xs)", "by (simp only: prefix_eq_prefix_take_ex prefix_take_eq_prefix_take_ex)"], ["", "lemma strict_prefix_take_eq_strict_prefix_take_ex: \"\n  (ys \\<down> (length xs) = xs \\<and> xs \\<noteq> ys) =\n  ((\\<exists>n. ys \\<down> n = xs) \\<and> xs \\<noteq> ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ys \\<down> length xs = xs \\<and> xs \\<noteq> ys) =\n    ((\\<exists>n. ys \\<down> n = xs) \\<and> xs \\<noteq> ys)", "by (simp add: prefix_take_eq_prefix_take_ex)"], ["", "lemma strict_prefix_eq_strict_prefix_take_ex: \"strict_prefix xs ys = ((\\<exists>n. ys \\<down> n = xs) \\<and> xs \\<noteq> ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strict_prefix xs ys =\n    ((\\<exists>n. ys \\<down> n = xs) \\<and> xs \\<noteq> ys)", "by (simp add: strict_prefix_def prefix_eq_prefix_take_ex)"], ["", "lemma strict_prefix_eq_strict_prefix_take: \"strict_prefix xs ys = (ys \\<down> (length xs) = xs \\<and> xs \\<noteq> ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strict_prefix xs ys = (ys \\<down> length xs = xs \\<and> xs \\<noteq> ys)", "by (simp only: strict_prefix_eq_strict_prefix_take_ex strict_prefix_take_eq_strict_prefix_take_ex)"], ["", "lemma take_imp_prefix: \"prefix (xs \\<down> n) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prefix (xs \\<down> n) xs", "by (rule take_is_prefix)"], ["", "lemma eq_imp_prefix: \"xs = (ys::'a list) \\<Longrightarrow> prefix xs ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs = ys \\<Longrightarrow> prefix xs ys", "by simp"], ["", "lemma le_take_imp_prefix: \"a \\<le> b \\<Longrightarrow> prefix (xs \\<down> a) (xs \\<down> b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<le> b \\<Longrightarrow> prefix (xs \\<down> a) (xs \\<down> b)", "by (fastforce simp: prefix_eq_prefix_take_ex min_def)"], ["", "lemma take_prefix_imp_le: \"\n  \\<lbrakk> a \\<le> length xs; prefix (xs \\<down> a) (xs \\<down> b) \\<rbrakk> \\<Longrightarrow> a \\<le> b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<le> length xs;\n     prefix (xs \\<down> a) (xs \\<down> b)\\<rbrakk>\n    \\<Longrightarrow> a \\<le> b", "by (drule prefix_length_le, simp)"], ["", "lemma take_prefixeq_le_conv: \"\n  a \\<le> length xs \\<Longrightarrow> prefix (xs \\<down> a) (xs \\<down> b) = (a \\<le> b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<le> length xs \\<Longrightarrow>\n    prefix (xs \\<down> a) (xs \\<down> b) = (a \\<le> b)", "apply (rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>a \\<le> length xs;\n     prefix (xs \\<down> a) (xs \\<down> b)\\<rbrakk>\n    \\<Longrightarrow> a \\<le> b\n 2. \\<lbrakk>a \\<le> length xs; a \\<le> b\\<rbrakk>\n    \\<Longrightarrow> prefix (xs \\<down> a) (xs \\<down> b)", "apply (rule take_prefix_imp_le, assumption+)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<le> length xs; a \\<le> b\\<rbrakk>\n    \\<Longrightarrow> prefix (xs \\<down> a) (xs \\<down> b)", "apply (rule le_take_imp_prefix, assumption+)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma append_imp_prefix[simp, intro]: \"prefix a (a @ b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prefix a (a @ b)", "by (unfold prefix_def, blast)"], ["", "lemma prefix_imp_take_eq: \"\n  \\<lbrakk> n \\<le> length xs; prefix xs ys \\<rbrakk> \\<Longrightarrow> xs \\<down> n = ys \\<down> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n \\<le> length xs; prefix xs ys\\<rbrakk>\n    \\<Longrightarrow> xs \\<down> n = ys \\<down> n", "by (clarsimp simp: prefix_def)"], ["", "lemma prefix_length_le_eq_conv: \"(prefix xs ys \\<and> length ys \\<le> length xs) = (xs = ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (prefix xs ys \\<and> length ys \\<le> length xs) = (xs = ys)", "apply (rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. prefix xs ys \\<and> length ys \\<le> length xs \\<Longrightarrow> xs = ys\n 2. xs = ys \\<Longrightarrow> prefix xs ys \\<and> length ys \\<le> length xs", "apply (erule conjE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>prefix xs ys; length ys \\<le> length xs\\<rbrakk>\n    \\<Longrightarrow> xs = ys\n 2. xs = ys \\<Longrightarrow> prefix xs ys \\<and> length ys \\<le> length xs", "apply (frule prefix_length_le)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>prefix xs ys; length ys \\<le> length xs;\n     length xs \\<le> length ys\\<rbrakk>\n    \\<Longrightarrow> xs = ys\n 2. xs = ys \\<Longrightarrow> prefix xs ys \\<and> length ys \\<le> length xs", "apply (simp add: prefix_eq_prefix_take)"], ["proof (prove)\ngoal (1 subgoal):\n 1. xs = ys \\<Longrightarrow> prefix xs ys \\<and> length ys \\<le> length xs", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma take_length_prefix_conv: \"\n  length xs \\<le> length ys \\<Longrightarrow> prefix (ys \\<down> length xs) xs = prefix xs ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length xs \\<le> length ys \\<Longrightarrow>\n    prefix (ys \\<down> length xs) xs = prefix xs ys", "by (fastforce simp: prefix_eq_prefix_take)"], ["", "lemma append_eq_imp_take: \"\n  \\<lbrakk> k \\<le> length xs; length r1 = k; r1 @ r2 = xs \\<rbrakk> \\<Longrightarrow> r1 = xs \\<down> k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>k \\<le> length xs; length r1 = k; r1 @ r2 = xs\\<rbrakk>\n    \\<Longrightarrow> r1 = xs \\<down> k", "by fastforce"], ["", "lemma take_the_conv: \"\n  xs \\<down> k = (if length xs \\<le> k then xs else (THE r. length r = k \\<and> (\\<exists>r2. r @ r2 = xs)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<down> k =\n    (if length xs \\<le> k then xs\n     else THE r. length r = k \\<and> (\\<exists>r2. r @ r2 = xs))", "apply (clarsimp simp: linorder_not_le)"], ["proof (prove)\ngoal (1 subgoal):\n 1. k < length xs \\<Longrightarrow>\n    xs \\<down> k = (THE r. length r = k \\<and> (\\<exists>r2. r @ r2 = xs))", "apply (rule the1I2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. k < length xs \\<Longrightarrow>\n    \\<exists>!r. length r = k \\<and> (\\<exists>r2. r @ r2 = xs)\n 2. \\<And>r.\n       \\<lbrakk>k < length xs;\n        length r = k \\<and> (\\<exists>r2. r @ r2 = xs)\\<rbrakk>\n       \\<Longrightarrow> xs \\<down> k = r", "apply (simp add: Ex1_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. k < length xs \\<Longrightarrow>\n    \\<exists>x.\n       length x = k \\<and>\n       (\\<exists>r2. x @ r2 = xs) \\<and>\n       (\\<forall>y.\n           length y = k \\<and> (\\<exists>r2. y @ r2 = xs) \\<longrightarrow>\n           y = x)\n 2. \\<And>r.\n       \\<lbrakk>k < length xs;\n        length r = k \\<and> (\\<exists>r2. r @ r2 = xs)\\<rbrakk>\n       \\<Longrightarrow> xs \\<down> k = r", "apply (rule_tac x=\"xs \\<down> k\" in exI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. k < length xs \\<Longrightarrow>\n    length (xs \\<down> k) = k \\<and>\n    (\\<exists>r2. xs \\<down> k @ r2 = xs) \\<and>\n    (\\<forall>y.\n        length y = k \\<and> (\\<exists>r2. y @ r2 = xs) \\<longrightarrow>\n        y = xs \\<down> k)\n 2. \\<And>r.\n       \\<lbrakk>k < length xs;\n        length r = k \\<and> (\\<exists>r2. r @ r2 = xs)\\<rbrakk>\n       \\<Longrightarrow> xs \\<down> k = r", "apply (intro conjI)"], ["proof (prove)\ngoal (4 subgoals):\n 1. k < length xs \\<Longrightarrow> length (xs \\<down> k) = k\n 2. k < length xs \\<Longrightarrow> \\<exists>r2. xs \\<down> k @ r2 = xs\n 3. k < length xs \\<Longrightarrow>\n    \\<forall>y.\n       length y = k \\<and> (\\<exists>r2. y @ r2 = xs) \\<longrightarrow>\n       y = xs \\<down> k\n 4. \\<And>r.\n       \\<lbrakk>k < length xs;\n        length r = k \\<and> (\\<exists>r2. r @ r2 = xs)\\<rbrakk>\n       \\<Longrightarrow> xs \\<down> k = r", "apply (simp add: min_eqR)"], ["proof (prove)\ngoal (3 subgoals):\n 1. k < length xs \\<Longrightarrow> \\<exists>r2. xs \\<down> k @ r2 = xs\n 2. k < length xs \\<Longrightarrow>\n    \\<forall>y.\n       length y = k \\<and> (\\<exists>r2. y @ r2 = xs) \\<longrightarrow>\n       y = xs \\<down> k\n 3. \\<And>r.\n       \\<lbrakk>k < length xs;\n        length r = k \\<and> (\\<exists>r2. r @ r2 = xs)\\<rbrakk>\n       \\<Longrightarrow> xs \\<down> k = r", "apply (rule_tac x=\"xs \\<up> k\" in exI, simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. k < length xs \\<Longrightarrow>\n    \\<forall>y.\n       length y = k \\<and> (\\<exists>r2. y @ r2 = xs) \\<longrightarrow>\n       y = xs \\<down> k\n 2. \\<And>r.\n       \\<lbrakk>k < length xs;\n        length r = k \\<and> (\\<exists>r2. r @ r2 = xs)\\<rbrakk>\n       \\<Longrightarrow> xs \\<down> k = r", "apply fastforce"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>r.\n       \\<lbrakk>k < length xs;\n        length r = k \\<and> (\\<exists>r2. r @ r2 = xs)\\<rbrakk>\n       \\<Longrightarrow> xs \\<down> k = r", "apply fastforce"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma prefix_refl: \"prefix xs (xs::'a list)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prefix xs xs", "by (rule prefix_order.order_refl)"], ["", "lemma prefix_trans: \"\\<lbrakk> prefix xs ys; prefix (ys::'a list) zs \\<rbrakk> \\<Longrightarrow> prefix xs zs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>prefix xs ys; prefix ys zs\\<rbrakk>\n    \\<Longrightarrow> prefix xs zs", "by (rule prefix_order.order_trans)"], ["", "lemma prefixeq_antisym: \"\\<lbrakk> prefix xs ys; prefix (ys::'a list) xs \\<rbrakk> \\<Longrightarrow> xs = ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>prefix xs ys; prefix ys xs\\<rbrakk> \\<Longrightarrow> xs = ys", "by (rule prefix_order.antisym)"], ["", "subsection \\<open>Counting equal pairs\\<close>"], ["", "text \\<open>Counting number of equal elements in two lists\\<close>"], ["", "definition mirror_pair :: \"('a \\<times> 'b) \\<Rightarrow> ('b \\<times> 'a)\"\n  where \"mirror_pair p \\<equiv> (snd p, fst p)\""], ["", "lemma zip_mirror[rule_format]: \"\n  \\<lbrakk> i < min (length xs) (length ys);\n    p1 = (zip xs ys) ! i; p2 = (zip ys xs) ! i \\<rbrakk> \\<Longrightarrow>\n  mirror_pair p1 = p2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < min (length xs) (length ys); p1 = zip xs ys ! i;\n     p2 = zip ys xs ! i\\<rbrakk>\n    \\<Longrightarrow> mirror_pair p1 = p2", "by (simp add: mirror_pair_def)"], ["", "definition equal_pair :: \"('a \\<times> 'a) \\<Rightarrow> bool\"\n  where \"equal_pair p \\<equiv> (fst p = snd p)\""], ["", "lemma mirror_pair_equal: \"equal_pair (mirror_pair p) = (equal_pair p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. equal_pair (mirror_pair p) = equal_pair p", "by (fastforce simp: mirror_pair_def equal_pair_def)"], ["", "primrec\n  equal_pair_count :: \"('a \\<times> 'a) list \\<Rightarrow> nat\"\nwhere\n  \"equal_pair_count [] = 0\"\n| \"equal_pair_count (p # ps) = (\n    if (fst p = snd p)\n      then Suc (equal_pair_count ps)\n      else 0)\""], ["", "lemma equal_pair_count_le: \"equal_pair_count xs \\<le> length xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. equal_pair_count xs \\<le> length xs", "by (induct xs, simp_all)"], ["", "lemma equal_pair_count_0: \"\n  fst (hd ps) \\<noteq> snd (hd ps) \\<Longrightarrow> equal_pair_count ps = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (hd ps) \\<noteq> snd (hd ps) \\<Longrightarrow>\n    equal_pair_count ps = 0", "by (case_tac ps, simp_all)"], ["", "lemma equal_pair_count_Suc: \"\n  equal_pair_count ((a, a) # ps) = Suc (equal_pair_count ps)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. equal_pair_count ((a, a) # ps) = Suc (equal_pair_count ps)", "by simp"], ["", "lemma equal_pair_count_eq_pairwise[rule_format]: \"\n  \\<lbrakk> length ps1 = length ps2;\n    \\<forall>i<length ps2. equal_pair (ps1 ! i) = equal_pair(ps2 ! i) \\<rbrakk>\n  \\<Longrightarrow> equal_pair_count ps1 = equal_pair_count ps2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length ps1 = length ps2;\n     \\<forall>i<length ps2.\n        equal_pair (ps1 ! i) = equal_pair (ps2 ! i)\\<rbrakk>\n    \\<Longrightarrow> equal_pair_count ps1 = equal_pair_count ps2", "apply (induct rule: list_induct2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>i<length [].\n       equal_pair ([] ! i) = equal_pair ([] ! i) \\<Longrightarrow>\n    equal_pair_count [] = equal_pair_count []\n 2. \\<And>x xs y ys.\n       \\<lbrakk>length xs = length ys;\n        \\<forall>i<length ys.\n           equal_pair (xs ! i) = equal_pair (ys ! i) \\<Longrightarrow>\n        equal_pair_count xs = equal_pair_count ys;\n        \\<forall>i<length (y # ys).\n           equal_pair ((x # xs) ! i) = equal_pair ((y # ys) ! i)\\<rbrakk>\n       \\<Longrightarrow> equal_pair_count (x # xs) =\n                         equal_pair_count (y # ys)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xs y ys.\n       \\<lbrakk>length xs = length ys;\n        \\<forall>i<length ys.\n           equal_pair (xs ! i) = equal_pair (ys ! i) \\<Longrightarrow>\n        equal_pair_count xs = equal_pair_count ys;\n        \\<forall>i<length (y # ys).\n           equal_pair ((x # xs) ! i) = equal_pair ((y # ys) ! i)\\<rbrakk>\n       \\<Longrightarrow> equal_pair_count (x # xs) =\n                         equal_pair_count (y # ys)", "apply (fastforce simp add: equal_pair_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma equal_pair_count_mirror_pairwise[rule_format]: \"\n  \\<lbrakk> length ps1 = length ps2;\n    \\<forall>i<length ps2. ps1 ! i = mirror_pair (ps2 ! i) \\<rbrakk>\n  \\<Longrightarrow> equal_pair_count ps1 = equal_pair_count ps2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length ps1 = length ps2;\n     \\<forall>i<length ps2. ps1 ! i = mirror_pair (ps2 ! i)\\<rbrakk>\n    \\<Longrightarrow> equal_pair_count ps1 = equal_pair_count ps2", "apply (rule equal_pair_count_eq_pairwise, assumption)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>length ps1 = length ps2;\n        \\<forall>i<length ps2. ps1 ! i = mirror_pair (ps2 ! i);\n        i < length ps2\\<rbrakk>\n       \\<Longrightarrow> equal_pair (ps1 ! i) = equal_pair (ps2 ! i)", "apply (simp add: mirror_pair_equal)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(* The lemma states that all pairs with index < equal_pair_count ps\n  are equal. It does not deal with maximality of equal_pair_count *)"], ["", "lemma equal_pair_count_correct:\"\n  \\<And>i. i < equal_pair_count ps \\<Longrightarrow> equal_pair (ps ! i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i. i < equal_pair_count ps \\<Longrightarrow> equal_pair (ps ! i)", "apply (induct ps)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i. i < equal_pair_count [] \\<Longrightarrow> equal_pair ([] ! i)\n 2. \\<And>a ps i.\n       \\<lbrakk>\\<And>i.\n                   i < equal_pair_count ps \\<Longrightarrow>\n                   equal_pair (ps ! i);\n        i < equal_pair_count (a # ps)\\<rbrakk>\n       \\<Longrightarrow> equal_pair ((a # ps) ! i)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a ps i.\n       \\<lbrakk>\\<And>i.\n                   i < equal_pair_count ps \\<Longrightarrow>\n                   equal_pair (ps ! i);\n        i < equal_pair_count (a # ps)\\<rbrakk>\n       \\<Longrightarrow> equal_pair ((a # ps) ! i)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a ps i.\n       \\<lbrakk>\\<And>i.\n                   i < equal_pair_count ps \\<Longrightarrow>\n                   equal_pair (ps ! i);\n        i < (if fst a = snd a then Suc (equal_pair_count ps)\n             else 0)\\<rbrakk>\n       \\<Longrightarrow> equal_pair ((a # ps) ! i)", "apply (split if_split_asm)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a ps i.\n       \\<lbrakk>\\<And>i.\n                   i < equal_pair_count ps \\<Longrightarrow>\n                   equal_pair (ps ! i);\n        fst a = snd a; i < Suc (equal_pair_count ps)\\<rbrakk>\n       \\<Longrightarrow> equal_pair ((a # ps) ! i)\n 2. \\<And>a ps i.\n       \\<lbrakk>\\<And>i.\n                   i < equal_pair_count ps \\<Longrightarrow>\n                   equal_pair (ps ! i);\n        fst a \\<noteq> snd a; i < 0\\<rbrakk>\n       \\<Longrightarrow> equal_pair ((a # ps) ! i)", "apply (case_tac i)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a ps i.\n       \\<lbrakk>\\<And>i.\n                   i < equal_pair_count ps \\<Longrightarrow>\n                   equal_pair (ps ! i);\n        fst a = snd a; i < Suc (equal_pair_count ps); i = 0\\<rbrakk>\n       \\<Longrightarrow> equal_pair ((a # ps) ! i)\n 2. \\<And>a ps i nat.\n       \\<lbrakk>\\<And>i.\n                   i < equal_pair_count ps \\<Longrightarrow>\n                   equal_pair (ps ! i);\n        fst a = snd a; i < Suc (equal_pair_count ps); i = Suc nat\\<rbrakk>\n       \\<Longrightarrow> equal_pair ((a # ps) ! i)\n 3. \\<And>a ps i.\n       \\<lbrakk>\\<And>i.\n                   i < equal_pair_count ps \\<Longrightarrow>\n                   equal_pair (ps ! i);\n        fst a \\<noteq> snd a; i < 0\\<rbrakk>\n       \\<Longrightarrow> equal_pair ((a # ps) ! i)", "apply (simp add: equal_pair_def)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(* For @{text \"i = equal_pair_count ps\"} holds:\n  either @{text \"ps ! i\"} not an equal pair,\n  or all pairs are equal (@{text \"equal_pair_count = length ps\"}) *)"], ["", "lemma equal_pair_count_maximality_aux[rule_format]: \"\\<And>i.\n  i = equal_pair_count ps \\<Longrightarrow> length ps = i \\<or> \\<not> equal_pair (ps ! i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i = equal_pair_count ps \\<Longrightarrow>\n       length ps = i \\<or> \\<not> equal_pair (ps ! i)", "apply (induct ps)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i.\n       i = equal_pair_count [] \\<Longrightarrow>\n       length [] = i \\<or> \\<not> equal_pair ([] ! i)\n 2. \\<And>a ps i.\n       \\<lbrakk>\\<And>i.\n                   i = equal_pair_count ps \\<Longrightarrow>\n                   length ps = i \\<or> \\<not> equal_pair (ps ! i);\n        i = equal_pair_count (a # ps)\\<rbrakk>\n       \\<Longrightarrow> length (a # ps) = i \\<or>\n                         \\<not> equal_pair ((a # ps) ! i)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a ps i.\n       \\<lbrakk>\\<And>i.\n                   i = equal_pair_count ps \\<Longrightarrow>\n                   length ps = i \\<or> \\<not> equal_pair (ps ! i);\n        i = equal_pair_count (a # ps)\\<rbrakk>\n       \\<Longrightarrow> length (a # ps) = i \\<or>\n                         \\<not> equal_pair ((a # ps) ! i)", "apply (simp add: equal_pair_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "corollary equal_pair_count_maximality1a[rule_format]: \"\n  equal_pair_count ps = length ps \\<or> \\<not> equal_pair (ps!equal_pair_count ps)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. equal_pair_count ps = length ps \\<or>\n    \\<not> equal_pair (ps ! equal_pair_count ps)", "apply (insert equal_pair_count_maximality_aux[of \"equal_pair_count ps\" ps])"], ["proof (prove)\ngoal (1 subgoal):\n 1. (equal_pair_count ps = equal_pair_count ps \\<Longrightarrow>\n     length ps = equal_pair_count ps \\<or>\n     \\<not> equal_pair (ps ! equal_pair_count ps)) \\<Longrightarrow>\n    equal_pair_count ps = length ps \\<or>\n    \\<not> equal_pair (ps ! equal_pair_count ps)", "apply clarsimp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "corollary equal_pair_count_maximality1b[rule_format]: \"\n  equal_pair_count ps \\<noteq> length ps \\<Longrightarrow>\n  \\<not> equal_pair (ps!equal_pair_count ps)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. equal_pair_count ps \\<noteq> length ps \\<Longrightarrow>\n    \\<not> equal_pair (ps ! equal_pair_count ps)", "by (insert equal_pair_count_maximality1a[of ps], simp)"], ["", "lemma equal_pair_count_maximality2a[rule_format]: \"\n  equal_pair_count ps = length ps \\<or> \\<comment> \\<open>either all pairs are equal\\<close>\n  (\\<forall>i\\<ge>equal_pair_count ps.(\\<exists>j\\<le>i. \\<not>equal_pair (ps ! j)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. equal_pair_count ps = length ps \\<or>\n    (\\<forall>i\\<ge>equal_pair_count ps.\n        \\<exists>j\\<le>i. \\<not> equal_pair (ps ! j))", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>equal_pair_count ps \\<noteq> length ps;\n        equal_pair_count ps \\<le> i\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j\\<le>i. \\<not> equal_pair (ps ! j)", "apply (rule_tac x=\"equal_pair_count ps\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>equal_pair_count ps \\<noteq> length ps;\n        equal_pair_count ps \\<le> i\\<rbrakk>\n       \\<Longrightarrow> equal_pair_count ps \\<le> i \\<and>\n                         \\<not> equal_pair (ps ! equal_pair_count ps)", "apply (simp add: equal_pair_count_maximality1b equal_pair_count_le)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "corollary equal_pair_count_maximality2b[rule_format]: \"\n  equal_pair_count ps \\<noteq> length ps \\<Longrightarrow>\n  \\<forall>i\\<ge>equal_pair_count ps.(\\<exists>j\\<le>i. \\<not>equal_pair (ps!j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. equal_pair_count ps \\<noteq> length ps \\<Longrightarrow>\n    \\<forall>i\\<ge>equal_pair_count ps.\n       \\<exists>j\\<le>i. \\<not> equal_pair (ps ! j)", "by (insert equal_pair_count_maximality2a[of ps], simp)"], ["", "lemmas equal_pair_count_maximality =\n  equal_pair_count_maximality1a equal_pair_count_maximality1b\n  equal_pair_count_maximality2a equal_pair_count_maximality2b"], ["", "subsection \\<open>Prefix length\\<close>"], ["", "text \\<open>Length of the prefix infimum\\<close>"], ["", "definition inf_prefix_length :: \"'a list \\<Rightarrow> 'a list \\<Rightarrow> nat\"\n  where \"inf_prefix_length xs ys \\<equiv> equal_pair_count (zip xs ys)\""], ["", "value \"int (inf_prefix_length [1::int,2,3,4,7,8,15] [1::int,2,3,4,7,15])\""], ["", "value \"int (inf_prefix_length [1::int,2,3,4] [1::int,2,3,4,7,15])\""], ["", "value \"int (inf_prefix_length [] [1::int,2,3,4,7,15])\""], ["", "value \"int (inf_prefix_length [1::int,2,3,4,5] [1::int,2,3,4,5])\""], ["", "lemma inf_prefix_length_commute[rule_format]:\n  \"inf_prefix_length xs ys = inf_prefix_length ys xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inf_prefix_length xs ys = inf_prefix_length ys xs", "apply (unfold inf_prefix_length_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. equal_pair_count (zip xs ys) = equal_pair_count (zip ys xs)", "apply (insert equal_pair_count_mirror_pairwise[of \"zip xs ys\" \"zip ys xs\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>length (zip xs ys) = length (zip ys xs);\n      \\<And>i.\n         i < length (zip ys xs) \\<Longrightarrow>\n         zip xs ys ! i = mirror_pair (zip ys xs ! i)\\<rbrakk>\n     \\<Longrightarrow> equal_pair_count (zip xs ys) =\n                       equal_pair_count (zip ys xs)) \\<Longrightarrow>\n    equal_pair_count (zip xs ys) = equal_pair_count (zip ys xs)", "apply (simp add: equal_pair_count_mirror_pairwise[of \"zip xs ys\" \"zip ys xs\"] mirror_pair_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma inf_prefix_length_leL[intro]:\n  \"inf_prefix_length xs ys \\<le> length xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inf_prefix_length xs ys \\<le> length xs", "apply (unfold inf_prefix_length_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. equal_pair_count (zip xs ys) \\<le> length xs", "apply (insert equal_pair_count_le[of \"zip xs ys\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. equal_pair_count (zip xs ys) \\<le> length (zip xs ys) \\<Longrightarrow>\n    equal_pair_count (zip xs ys) \\<le> length xs", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "corollary inf_prefix_length_leR[intro]:\n  \"inf_prefix_length xs ys \\<le> length ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inf_prefix_length xs ys \\<le> length ys", "by (simp add: inf_prefix_length_commute[of xs] inf_prefix_length_leL)"], ["", "lemmas inf_prefix_length_le =\n  inf_prefix_length_leL\n  inf_prefix_length_leR"], ["", "lemma inf_prefix_length_le_min[rule_format]:\n  \"inf_prefix_length xs ys \\<le> min (length xs) (length ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inf_prefix_length xs ys \\<le> min (length xs) (length ys)", "by (simp add: inf_prefix_length_le)"], ["", "lemma hd_inf_prefix_length_0: \"\n  hd xs \\<noteq> hd ys \\<Longrightarrow> inf_prefix_length xs ys = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hd xs \\<noteq> hd ys \\<Longrightarrow> inf_prefix_length xs ys = 0", "apply (unfold inf_prefix_length_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. hd xs \\<noteq> hd ys \\<Longrightarrow> equal_pair_count (zip xs ys) = 0", "apply (case_tac \"xs = []\", simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>hd xs \\<noteq> hd ys; xs \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> equal_pair_count (zip xs ys) = 0", "apply (case_tac \"ys = []\", simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>hd xs \\<noteq> hd ys; xs \\<noteq> []; ys \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> equal_pair_count (zip xs ys) = 0", "apply (simp add: equal_pair_count_0 hd_zip)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma inf_prefix_length_NilL[simp]: \"inf_prefix_length [] ys = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inf_prefix_length [] ys = 0", "by (simp add: inf_prefix_length_def)"], ["", "lemma inf_prefix_length_NilR[simp]: \"inf_prefix_length xs [] = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inf_prefix_length xs [] = 0", "by (simp add: inf_prefix_length_def)"], ["", "lemma inf_prefix_length_Suc[simp]: \"\n  inf_prefix_length (a # xs) (a # ys) = Suc (inf_prefix_length xs ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inf_prefix_length (a # xs) (a # ys) = Suc (inf_prefix_length xs ys)", "by (simp add: inf_prefix_length_def)"], ["", "lemma inf_prefix_length_correct: \"\n  i < inf_prefix_length xs ys \\<Longrightarrow> xs ! i = ys ! i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < inf_prefix_length xs ys \\<Longrightarrow> xs ! i = ys ! i", "apply (frule order_less_le_trans[OF _ inf_prefix_length_leL])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < inf_prefix_length xs ys; i < length xs\\<rbrakk>\n    \\<Longrightarrow> xs ! i = ys ! i", "apply (frule order_less_le_trans[OF _ inf_prefix_length_leR])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < inf_prefix_length xs ys; i < length xs;\n     i < length ys\\<rbrakk>\n    \\<Longrightarrow> xs ! i = ys ! i", "apply (unfold inf_prefix_length_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < equal_pair_count (zip xs ys); i < length xs;\n     i < length ys\\<rbrakk>\n    \\<Longrightarrow> xs ! i = ys ! i", "apply (drule equal_pair_count_correct)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < length xs; i < length ys;\n     equal_pair (zip xs ys ! i)\\<rbrakk>\n    \\<Longrightarrow> xs ! i = ys ! i", "apply (simp add: equal_pair_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "corollary nth_neq_imp_inf_prefix_length_le: \"\n  xs ! i \\<noteq> ys ! i \\<Longrightarrow> inf_prefix_length xs ys \\<le> i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs ! i \\<noteq> ys ! i \\<Longrightarrow> inf_prefix_length xs ys \\<le> i", "apply (rule ccontr)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>xs ! i \\<noteq> ys ! i;\n     \\<not> inf_prefix_length xs ys \\<le> i\\<rbrakk>\n    \\<Longrightarrow> False", "apply (simp add: inf_prefix_length_correct)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma inf_prefix_length_maximality1[rule_format]: \"\n  inf_prefix_length xs ys \\<noteq> min (length xs) (length ys) \\<Longrightarrow>\n  xs ! (inf_prefix_length xs ys) \\<noteq> ys ! (inf_prefix_length xs ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inf_prefix_length xs ys \\<noteq>\n    min (length xs) (length ys) \\<Longrightarrow>\n    xs ! inf_prefix_length xs ys \\<noteq> ys ! inf_prefix_length xs ys", "apply (insert equal_pair_count_maximality1b[of \"zip xs ys\", folded inf_prefix_length_def], simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>inf_prefix_length xs ys \\<noteq> min (length xs) (length ys);\n     \\<not> equal_pair (zip xs ys ! inf_prefix_length xs ys)\\<rbrakk>\n    \\<Longrightarrow> xs ! inf_prefix_length xs ys \\<noteq>\n                      ys ! inf_prefix_length xs ys", "apply (drule neq_le_trans)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<not> equal_pair\n            (zip xs ys ! inf_prefix_length xs ys) \\<Longrightarrow>\n    inf_prefix_length xs ys \\<le> min (length xs) (length ys)\n 2. \\<lbrakk>\\<not> equal_pair (zip xs ys ! inf_prefix_length xs ys);\n     inf_prefix_length xs ys < min (length xs) (length ys)\\<rbrakk>\n    \\<Longrightarrow> xs ! inf_prefix_length xs ys \\<noteq>\n                      ys ! inf_prefix_length xs ys", "apply (simp add: inf_prefix_length_le)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> equal_pair (zip xs ys ! inf_prefix_length xs ys);\n     inf_prefix_length xs ys < min (length xs) (length ys)\\<rbrakk>\n    \\<Longrightarrow> xs ! inf_prefix_length xs ys \\<noteq>\n                      ys ! inf_prefix_length xs ys", "apply (simp add:  inf_prefix_length_def equal_pair_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "corollary inf_prefix_length_maximality2[rule_format]: \"\n  \\<lbrakk> inf_prefix_length xs ys \\<noteq> min (length xs) (length ys);\n    inf_prefix_length xs ys \\<le> i \\<rbrakk> \\<Longrightarrow>\n  \\<exists>j\\<le>i. xs ! j \\<noteq> ys ! j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>inf_prefix_length xs ys \\<noteq> min (length xs) (length ys);\n     inf_prefix_length xs ys \\<le> i\\<rbrakk>\n    \\<Longrightarrow> \\<exists>j\\<le>i. xs ! j \\<noteq> ys ! j", "apply (rule_tac x=\"inf_prefix_length xs ys\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>inf_prefix_length xs ys \\<noteq> min (length xs) (length ys);\n     inf_prefix_length xs ys \\<le> i\\<rbrakk>\n    \\<Longrightarrow> inf_prefix_length xs ys \\<le> i \\<and>\n                      xs ! inf_prefix_length xs ys \\<noteq>\n                      ys ! inf_prefix_length xs ys", "apply (simp add: inf_prefix_length_maximality1 inf_prefix_length_le_min)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemmas inf_prefix_length_maximality =\n  inf_prefix_length_maximality1 inf_prefix_length_maximality2"], ["", "lemma inf_prefix_length_append[simp]: \"\n  inf_prefix_length (zs @ xs) (zs @ ys) =\n  length zs + inf_prefix_length xs ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inf_prefix_length (zs @ xs) (zs @ ys) =\n    length zs + inf_prefix_length xs ys", "apply (induct zs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. inf_prefix_length ([] @ xs) ([] @ ys) =\n    length [] + inf_prefix_length xs ys\n 2. \\<And>a zs.\n       inf_prefix_length (zs @ xs) (zs @ ys) =\n       length zs + inf_prefix_length xs ys \\<Longrightarrow>\n       inf_prefix_length ((a # zs) @ xs) ((a # zs) @ ys) =\n       length (a # zs) + inf_prefix_length xs ys", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a zs.\n       inf_prefix_length (zs @ xs) (zs @ ys) =\n       length zs + inf_prefix_length xs ys \\<Longrightarrow>\n       inf_prefix_length ((a # zs) @ xs) ((a # zs) @ ys) =\n       length (a # zs) + inf_prefix_length xs ys", "apply (simp add: inf_prefix_length_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma inf_prefix_length_take_correct: \"\n  n \\<le> inf_prefix_length xs ys \\<Longrightarrow> xs \\<down> n = ys \\<down> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<le> inf_prefix_length xs ys \\<Longrightarrow>\n    xs \\<down> n = ys \\<down> n", "apply (frule order_trans[OF _ inf_prefix_length_leL])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n \\<le> inf_prefix_length xs ys; n \\<le> length xs\\<rbrakk>\n    \\<Longrightarrow> xs \\<down> n = ys \\<down> n", "apply (frule order_trans[OF _ inf_prefix_length_leR])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n \\<le> inf_prefix_length xs ys; n \\<le> length xs;\n     n \\<le> length ys\\<rbrakk>\n    \\<Longrightarrow> xs \\<down> n = ys \\<down> n", "apply (simp add: list_eq_iff inf_prefix_length_correct)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma inf_prefix_length_0_imp_hd_neq: \"\n  \\<lbrakk> xs \\<noteq> []; ys \\<noteq> []; inf_prefix_length xs ys = 0 \\<rbrakk> \\<Longrightarrow> hd xs \\<noteq> hd ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>xs \\<noteq> []; ys \\<noteq> [];\n     inf_prefix_length xs ys = 0\\<rbrakk>\n    \\<Longrightarrow> hd xs \\<noteq> hd ys", "apply (rule ccontr)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>xs \\<noteq> []; ys \\<noteq> []; inf_prefix_length xs ys = 0;\n     \\<not> hd xs \\<noteq> hd ys\\<rbrakk>\n    \\<Longrightarrow> False", "apply (insert inf_prefix_length_maximality2[of xs ys 0])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>xs \\<noteq> []; ys \\<noteq> []; inf_prefix_length xs ys = 0;\n     \\<not> hd xs \\<noteq> hd ys;\n     \\<lbrakk>inf_prefix_length xs ys \\<noteq> min (length xs) (length ys);\n      inf_prefix_length xs ys \\<le> 0\\<rbrakk>\n     \\<Longrightarrow> \\<exists>j\\<le>0. xs ! j \\<noteq> ys ! j\\<rbrakk>\n    \\<Longrightarrow> False", "apply (simp add: hd_eq_first)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection \\<open>Prefix infimum\\<close>"], ["", "definition inf_prefix :: \"'a list \\<Rightarrow> 'a list \\<Rightarrow> 'a list\"  (infixl \"\\<sqinter>\" 70)\n  where \"xs \\<sqinter> ys \\<equiv> xs \\<down> (inf_prefix_length xs ys)\""], ["", "lemma length_inf_prefix: \"length (xs \\<sqinter> ys) = inf_prefix_length xs ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (xs \\<sqinter> ys) = inf_prefix_length xs ys", "by (simp add: inf_prefix_def min_eqR inf_prefix_length_leL)"], ["", "lemma inf_prefix_commute: \"xs \\<sqinter> ys = ys \\<sqinter> xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<sqinter> ys = ys \\<sqinter> xs", "by (simp add: inf_prefix_def inf_prefix_length_commute[of ys] inf_prefix_length_take_correct)"], ["", "lemma inf_prefix_takeL: \"xs \\<sqinter> ys = xs \\<down> (inf_prefix_length xs ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<sqinter> ys = xs \\<down> inf_prefix_length xs ys", "by (simp add: inf_prefix_def)"], ["", "lemma inf_prefix_takeR: \"xs \\<sqinter> ys = ys \\<down> (inf_prefix_length xs ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<sqinter> ys = ys \\<down> inf_prefix_length xs ys", "by (subst inf_prefix_commute, subst inf_prefix_length_commute, rule inf_prefix_takeL)"], ["", "lemma inf_prefix_correct: \"i < length (xs \\<sqinter> ys) \\<Longrightarrow> xs ! i = ys ! i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < length (xs \\<sqinter> ys) \\<Longrightarrow> xs ! i = ys ! i", "by (simp add: length_inf_prefix inf_prefix_length_correct)"], ["", "corollary inf_prefix_correctL: \"\n  i < length (xs \\<sqinter> ys) \\<Longrightarrow> (xs \\<sqinter> ys) ! i = xs ! i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < length (xs \\<sqinter> ys) \\<Longrightarrow>\n    (xs \\<sqinter> ys) ! i = xs ! i", "by (simp add: inf_prefix_takeL)"], ["", "corollary inf_prefix_correctR: \"\n  i < length (xs \\<sqinter> ys) \\<Longrightarrow> (xs \\<sqinter> ys) ! i = ys ! i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < length (xs \\<sqinter> ys) \\<Longrightarrow>\n    (xs \\<sqinter> ys) ! i = ys ! i", "by (simp add: inf_prefix_takeR)"], ["", "lemma inf_prefix_take_correct: \"\n  n \\<le> length (xs \\<sqinter> ys) \\<Longrightarrow> xs \\<down> n = ys \\<down> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<le> length (xs \\<sqinter> ys) \\<Longrightarrow>\n    xs \\<down> n = ys \\<down> n", "by (simp add: length_inf_prefix inf_prefix_length_take_correct)"], ["", "lemma is_inf_prefix[rule_format]: \"\n  \\<lbrakk> length zs = length (xs \\<sqinter> ys);\n    \\<And>i. i < length (xs \\<sqinter> ys) \\<Longrightarrow> zs ! i = xs ! i \\<and> zs ! i = ys ! i \\<rbrakk> \\<Longrightarrow>\n  zs = xs \\<sqinter> ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length zs = length (xs \\<sqinter> ys);\n     \\<And>i.\n        i < length (xs \\<sqinter> ys) \\<Longrightarrow>\n        zs ! i = xs ! i \\<and> zs ! i = ys ! i\\<rbrakk>\n    \\<Longrightarrow> zs = xs \\<sqinter> ys", "by (simp add: list_eq_iff inf_prefix_def)"], ["", "lemma hd_inf_prefix_Nil: \"hd xs \\<noteq> hd ys \\<Longrightarrow> xs \\<sqinter> ys = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hd xs \\<noteq> hd ys \\<Longrightarrow> xs \\<sqinter> ys = []", "by (simp add: inf_prefix_def hd_inf_prefix_length_0)"], ["", "lemma inf_prefix_Nil_imp_hd_neq: \"\n  \\<lbrakk> xs \\<noteq> []; ys \\<noteq> []; xs \\<sqinter> ys = [] \\<rbrakk> \\<Longrightarrow> hd xs \\<noteq> hd ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>xs \\<noteq> []; ys \\<noteq> []; xs \\<sqinter> ys = []\\<rbrakk>\n    \\<Longrightarrow> hd xs \\<noteq> hd ys", "by (simp add: inf_prefix_def inf_prefix_length_0_imp_hd_neq)"], ["", "lemma length_inf_prefix_append[simp]: \"\n  length ((zs @ xs) \\<sqinter> (zs @ ys)) =\n  length zs + length (xs \\<sqinter> ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length ((zs @ xs) \\<sqinter> (zs @ ys)) =\n    length zs + length (xs \\<sqinter> ys)", "by (simp add: length_inf_prefix)"], ["", "lemma inf_prefix_append[simp]: \"(zs @ xs) \\<sqinter> (zs @ ys) = zs @ (xs \\<sqinter> ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (zs @ xs) \\<sqinter> (zs @ ys) = zs @ xs \\<sqinter> ys", "apply (rule is_inf_prefix[symmetric], simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length ((zs @ xs) \\<sqinter> (zs @ ys)) \\<Longrightarrow>\n       (zs @ xs \\<sqinter> ys) ! i = (zs @ xs) ! i \\<and>\n       (zs @ xs \\<sqinter> ys) ! i = (zs @ ys) ! i", "apply (clarsimp simp: nth_append)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i < length zs + length (xs \\<sqinter> ys);\n        \\<not> i < length zs\\<rbrakk>\n       \\<Longrightarrow> (xs \\<sqinter> ys) ! (i - length zs) =\n                         xs ! (i - length zs) \\<and>\n                         (xs \\<sqinter> ys) ! (i - length zs) =\n                         ys ! (i - length zs)", "apply (intro conjI inf_prefix_correctL inf_prefix_correctR, simp+)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma hd_neq_inf_prefix_append: \"\n  hd xs \\<noteq> hd ys \\<Longrightarrow> (zs @ xs) \\<sqinter> (zs @ ys) = zs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hd xs \\<noteq> hd ys \\<Longrightarrow>\n    (zs @ xs) \\<sqinter> (zs @ ys) = zs", "by (simp add: hd_inf_prefix_Nil)"], ["", "lemma inf_prefix_NilL[simp]: \"[] \\<sqinter> ys = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [] \\<sqinter> ys = []", "by (simp del: length_0_conv add: length_0_conv[symmetric] length_inf_prefix)"], ["", "corollary inf_prefix_NilR[simp]: \"xs \\<sqinter> [] = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<sqinter> [] = []", "by (simp add: inf_prefix_commute)"], ["", "lemmas inf_prefix_Nil = inf_prefix_NilL inf_prefix_NilR"], ["", "lemma inf_prefix_Cons[simp]: \"(a # xs) \\<sqinter> (a # ys) = a # xs \\<sqinter> ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a # xs) \\<sqinter> (a # ys) = a # xs \\<sqinter> ys", "by (insert inf_prefix_append[of \"[a]\" xs ys], simp)"], ["", "corollary inf_prefix_hd[simp]: \"hd ((a # xs) \\<sqinter> (a # ys)) = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hd ((a # xs) \\<sqinter> (a # ys)) = a", "by simp"], ["", "lemma inf_prefix_le1: \"prefix (xs \\<sqinter> ys) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prefix (xs \\<sqinter> ys) xs", "by (simp add: inf_prefix_takeL take_imp_prefix)"], ["", "lemma inf_prefix_le2: \"prefix (xs \\<sqinter> ys) ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prefix (xs \\<sqinter> ys) ys", "by (simp add: inf_prefix_takeR take_imp_prefix)"], ["", "lemma le_inf_prefix_iff: \"prefix x (y \\<sqinter> z) = (prefix x y \\<and> prefix x z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prefix x (y \\<sqinter> z) = (prefix x y \\<and> prefix x z)", "apply (rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. prefix x (y \\<sqinter> z) \\<Longrightarrow> prefix x y \\<and> prefix x z\n 2. prefix x y \\<and> prefix x z \\<Longrightarrow> prefix x (y \\<sqinter> z)", "apply (blast intro: prefix_order.order_trans inf_prefix_le1 inf_prefix_le2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. prefix x y \\<and> prefix x z \\<Longrightarrow> prefix x (y \\<sqinter> z)", "apply (clarsimp simp: prefix_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma le_imp_le_inf_prefix: \"\\<lbrakk> prefix x y; prefix x z \\<rbrakk> \\<Longrightarrow> prefix x (y \\<sqinter> z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>prefix x y; prefix x z\\<rbrakk>\n    \\<Longrightarrow> prefix x (y \\<sqinter> z)", "by (rule le_inf_prefix_iff[THEN iffD2], simp)"], ["", "interpretation prefix:\n  semilattice_inf\n    \"(\\<sqinter>) :: 'a list \\<Rightarrow> 'a list \\<Rightarrow> 'a list\"\n    \"prefix\"\n    \"strict_prefix\""], ["proof (prove)\ngoal (1 subgoal):\n 1. class.semilattice_inf (\\<sqinter>) prefix strict_prefix", "apply intro_locales"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.semilattice_inf_axioms (\\<sqinter>) prefix", "apply (rule class.semilattice_inf_axioms.intro)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x y. prefix (x \\<sqinter> y) x\n 2. \\<And>x y. prefix (x \\<sqinter> y) y\n 3. \\<And>x y z.\n       \\<lbrakk>prefix x y; prefix x z\\<rbrakk>\n       \\<Longrightarrow> prefix x (y \\<sqinter> z)", "apply (rule inf_prefix_le1)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y. prefix (x \\<sqinter> y) y\n 2. \\<And>x y z.\n       \\<lbrakk>prefix x y; prefix x z\\<rbrakk>\n       \\<Longrightarrow> prefix x (y \\<sqinter> z)", "apply (rule inf_prefix_le2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>prefix x y; prefix x z\\<rbrakk>\n       \\<Longrightarrow> prefix x (y \\<sqinter> z)", "apply (rule le_imp_le_inf_prefix, assumption+)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection \\<open>Prefices for infinite lists\\<close>"], ["", "definition iprefix :: \"'a list \\<Rightarrow> 'a ilist \\<Rightarrow> bool\"  (infixl \"\\<sqsubseteq>\" 50)\n  where \"xs \\<sqsubseteq> f \\<equiv> \\<exists>g. f = xs \\<frown> g\""], ["", "lemma iprefix_eq_iprefix_take: \"(xs \\<sqsubseteq> f) = (f \\<Down> length xs = xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (xs \\<sqsubseteq> f) = (f \\<Down> length xs = xs)", "apply (unfold iprefix_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>g. f = xs \\<frown> g) = (f \\<Down> length xs = xs)", "apply (rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<exists>g. f = xs \\<frown> g \\<Longrightarrow> f \\<Down> length xs = xs\n 2. f \\<Down> length xs = xs \\<Longrightarrow> \\<exists>g. f = xs \\<frown> g", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<Down> length xs = xs \\<Longrightarrow> \\<exists>g. f = xs \\<frown> g", "apply (rule_tac x=\"f \\<Up> (length xs)\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<Down> length xs = xs \\<Longrightarrow>\n    f = xs \\<frown> f \\<Up> length xs", "apply (subst i_append_i_take_i_drop_id[where n=\"length xs\", symmetric], simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iprefix_take_eq_iprefix_take_ex: \"\n  (f \\<Down> length xs = xs) = (\\<exists>n. f \\<Down> n = xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f \\<Down> length xs = xs) = (\\<exists>n. f \\<Down> n = xs)", "apply (rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. f \\<Down> length xs = xs \\<Longrightarrow> \\<exists>n. f \\<Down> n = xs\n 2. \\<exists>n. f \\<Down> n = xs \\<Longrightarrow> f \\<Down> length xs = xs", "apply (rule_tac x=\"length xs\" in exI, assumption)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>n. f \\<Down> n = xs \\<Longrightarrow> f \\<Down> length xs = xs", "apply clarsimp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iprefix_eq_iprefix_take_ex: \"(xs \\<sqsubseteq> f) = (\\<exists>n. f \\<Down> n = xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (xs \\<sqsubseteq> f) = (\\<exists>n. f \\<Down> n = xs)", "by (simp add: iprefix_eq_iprefix_take iprefix_take_eq_iprefix_take_ex)"], ["", "lemma i_take_imp_iprefix[intro]: \"f \\<Down> n \\<sqsubseteq> f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<Down> n \\<sqsubseteq> f", "by (simp add: iprefix_eq_iprefix_take)"], ["", "lemma i_take_prefix_le_conv: \"prefix (f \\<Down> a) (f \\<Down> b) = (a \\<le> b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prefix (f \\<Down> a) (f \\<Down> b) = (a \\<le> b)", "by (fastforce simp: prefix_eq_prefix_take list_eq_iff)"], ["", "lemma i_append_imp_iprefix[simp,intro]: \"xs \\<sqsubseteq> xs \\<frown> f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<sqsubseteq> xs \\<frown> f", "by (simp add: iprefix_def)"], ["", "lemma iprefix_imp_take_eq: \"\n  \\<lbrakk> n \\<le> length xs; xs \\<sqsubseteq> f \\<rbrakk> \\<Longrightarrow> xs \\<down> n = f \\<Down> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n \\<le> length xs; xs \\<sqsubseteq> f\\<rbrakk>\n    \\<Longrightarrow> xs \\<down> n = f \\<Down> n", "by (clarsimp simp: iprefix_eq_iprefix_take_ex min_eqR)"], ["", "lemma prefixeq_iprefix_trans: \"\\<lbrakk> prefix xs ys; ys \\<sqsubseteq> f \\<rbrakk> \\<Longrightarrow> xs \\<sqsubseteq> f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>prefix xs ys; ys \\<sqsubseteq> f\\<rbrakk>\n    \\<Longrightarrow> xs \\<sqsubseteq> f", "by (fastforce simp: iprefix_eq_iprefix_take_ex prefix_eq_prefix_take_ex)"], ["", "lemma i_take_length_prefix_conv: \"prefix (f \\<Down> length xs) xs = (xs \\<sqsubseteq> f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prefix (f \\<Down> length xs) xs = (xs \\<sqsubseteq> f)", "by (simp add: iprefix_eq_iprefix_take prefix_length_le_eq_conv[symmetric])"], ["", "lemma iprefixI[intro?]: \"f = xs \\<frown> g \\<Longrightarrow> xs \\<sqsubseteq> f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f = xs \\<frown> g \\<Longrightarrow> xs \\<sqsubseteq> f", "by (unfold iprefix_def, simp)"], ["", "lemma iprefixE[elim?]: \"\\<lbrakk> xs \\<sqsubseteq> f; \\<And>g. f = xs \\<frown> g \\<Longrightarrow> C \\<rbrakk> \\<Longrightarrow> C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>xs \\<sqsubseteq> f;\n     \\<And>g. f = xs \\<frown> g \\<Longrightarrow> C\\<rbrakk>\n    \\<Longrightarrow> C", "by (unfold iprefix_def, blast)"], ["", "lemma Nil_iprefix[iff]: \"[] \\<sqsubseteq> f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [] \\<sqsubseteq> f", "by (unfold iprefix_def, simp)"], ["", "lemma same_prefix_iprefix[simp]: \"(xs @ ys \\<sqsubseteq> xs \\<frown> f) = (ys \\<sqsubseteq> f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (xs @ ys \\<sqsubseteq> xs \\<frown> f) = (ys \\<sqsubseteq> f)", "by (simp add: iprefix_eq_iprefix_take)"], ["", "lemma prefix_iprefix[simp]: \"prefix xs ys \\<Longrightarrow> xs \\<sqsubseteq> ys \\<frown> f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prefix xs ys \\<Longrightarrow> xs \\<sqsubseteq> ys \\<frown> f", "by (clarsimp simp: prefix_def iprefix_def i_append_assoc[symmetric] simp del: i_append_assoc)"], ["", "lemma append_iprefixD: \"xs @ ys \\<sqsubseteq> f \\<Longrightarrow> xs \\<sqsubseteq> f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs @ ys \\<sqsubseteq> f \\<Longrightarrow> xs \\<sqsubseteq> f", "by (clarsimp simp: iprefix_def i_append_assoc[symmetric] simp del: i_append_assoc)"], ["", "lemma iprefix_length_le_imp_prefix: \"\n  \\<lbrakk> xs \\<sqsubseteq> ys \\<frown> f; length xs \\<le> length ys \\<rbrakk> \\<Longrightarrow> prefix xs ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>xs \\<sqsubseteq> ys \\<frown> f;\n     length xs \\<le> length ys\\<rbrakk>\n    \\<Longrightarrow> prefix xs ys", "by (clarsimp simp: iprefix_eq_iprefix_take_ex take_is_prefix)"], ["", "lemma iprefix_i_append: \"\n  (xs \\<sqsubseteq> ys \\<frown> f) = (prefix xs ys \\<or> (\\<exists>zs. xs = ys @ zs \\<and> zs \\<sqsubseteq> f))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (xs \\<sqsubseteq> ys \\<frown> f) =\n    (prefix xs ys \\<or>\n     (\\<exists>zs. xs = ys @ zs \\<and> zs \\<sqsubseteq> f))", "apply (rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. xs \\<sqsubseteq> ys \\<frown> f \\<Longrightarrow>\n    prefix xs ys \\<or> (\\<exists>zs. xs = ys @ zs \\<and> zs \\<sqsubseteq> f)\n 2. prefix xs ys \\<or>\n    (\\<exists>zs. xs = ys @ zs \\<and> zs \\<sqsubseteq> f) \\<Longrightarrow>\n    xs \\<sqsubseteq> ys \\<frown> f", "apply (case_tac \"length xs \\<le> length ys\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>xs \\<sqsubseteq> ys \\<frown> f;\n     length xs \\<le> length ys\\<rbrakk>\n    \\<Longrightarrow> prefix xs ys \\<or>\n                      (\\<exists>zs. xs = ys @ zs \\<and> zs \\<sqsubseteq> f)\n 2. \\<lbrakk>xs \\<sqsubseteq> ys \\<frown> f;\n     \\<not> length xs \\<le> length ys\\<rbrakk>\n    \\<Longrightarrow> prefix xs ys \\<or>\n                      (\\<exists>zs. xs = ys @ zs \\<and> zs \\<sqsubseteq> f)\n 3. prefix xs ys \\<or>\n    (\\<exists>zs. xs = ys @ zs \\<and> zs \\<sqsubseteq> f) \\<Longrightarrow>\n    xs \\<sqsubseteq> ys \\<frown> f", "apply (blast intro: iprefix_length_le_imp_prefix)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>xs \\<sqsubseteq> ys \\<frown> f;\n     \\<not> length xs \\<le> length ys\\<rbrakk>\n    \\<Longrightarrow> prefix xs ys \\<or>\n                      (\\<exists>zs. xs = ys @ zs \\<and> zs \\<sqsubseteq> f)\n 2. prefix xs ys \\<or>\n    (\\<exists>zs. xs = ys @ zs \\<and> zs \\<sqsubseteq> f) \\<Longrightarrow>\n    xs \\<sqsubseteq> ys \\<frown> f", "apply (rule disjI2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>xs \\<sqsubseteq> ys \\<frown> f;\n     \\<not> length xs \\<le> length ys\\<rbrakk>\n    \\<Longrightarrow> \\<exists>zs. xs = ys @ zs \\<and> zs \\<sqsubseteq> f\n 2. prefix xs ys \\<or>\n    (\\<exists>zs. xs = ys @ zs \\<and> zs \\<sqsubseteq> f) \\<Longrightarrow>\n    xs \\<sqsubseteq> ys \\<frown> f", "apply (rule_tac x=\"f \\<Down> (length xs - length ys)\" in exI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>xs \\<sqsubseteq> ys \\<frown> f;\n     \\<not> length xs \\<le> length ys\\<rbrakk>\n    \\<Longrightarrow> xs = ys @ f \\<Down> (length xs - length ys) \\<and>\n                      f \\<Down> (length xs - length ys) \\<sqsubseteq> f\n 2. prefix xs ys \\<or>\n    (\\<exists>zs. xs = ys @ zs \\<and> zs \\<sqsubseteq> f) \\<Longrightarrow>\n    xs \\<sqsubseteq> ys \\<frown> f", "apply (simp add: iprefix_eq_iprefix_take)"], ["proof (prove)\ngoal (1 subgoal):\n 1. prefix xs ys \\<or>\n    (\\<exists>zs. xs = ys @ zs \\<and> zs \\<sqsubseteq> f) \\<Longrightarrow>\n    xs \\<sqsubseteq> ys \\<frown> f", "apply fastforce"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma i_append_one_iprefix: \"\n  xs \\<sqsubseteq> f \\<Longrightarrow> xs @ [f (length xs)] \\<sqsubseteq> f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<sqsubseteq> f \\<Longrightarrow>\n    xs @ [f (length xs)] \\<sqsubseteq> f", "by (simp add: iprefix_eq_iprefix_take i_take_Suc_conv_app_nth)"], ["", "lemma iprefix_same_length_le: \"\n  \\<lbrakk> xs \\<sqsubseteq> f; ys \\<sqsubseteq> f; length xs \\<le> length ys \\<rbrakk> \\<Longrightarrow> prefix xs ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>xs \\<sqsubseteq> f; ys \\<sqsubseteq> f;\n     length xs \\<le> length ys\\<rbrakk>\n    \\<Longrightarrow> prefix xs ys", "by (clarsimp simp: iprefix_eq_iprefix_take_ex i_take_prefix_le_conv)"], ["", "lemma iprefix_same_cases: \"\n  \\<lbrakk> xs \\<sqsubseteq> f; ys \\<sqsubseteq> f \\<rbrakk> \\<Longrightarrow> prefix xs ys \\<or> prefix ys xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>xs \\<sqsubseteq> f; ys \\<sqsubseteq> f\\<rbrakk>\n    \\<Longrightarrow> prefix xs ys \\<or> prefix ys xs", "apply (case_tac \"length xs \\<le> length ys\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>xs \\<sqsubseteq> f; ys \\<sqsubseteq> f;\n     length xs \\<le> length ys\\<rbrakk>\n    \\<Longrightarrow> prefix xs ys \\<or> prefix ys xs\n 2. \\<lbrakk>xs \\<sqsubseteq> f; ys \\<sqsubseteq> f;\n     \\<not> length xs \\<le> length ys\\<rbrakk>\n    \\<Longrightarrow> prefix xs ys \\<or> prefix ys xs", "apply (simp add: iprefix_same_length_le)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma set_mono_iprefix: \"xs \\<sqsubseteq> f \\<Longrightarrow> set xs \\<subseteq> range f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<sqsubseteq> f \\<Longrightarrow> set xs \\<subseteq> range f", "by (unfold iprefix_def, fastforce)"], ["", "end"]]}