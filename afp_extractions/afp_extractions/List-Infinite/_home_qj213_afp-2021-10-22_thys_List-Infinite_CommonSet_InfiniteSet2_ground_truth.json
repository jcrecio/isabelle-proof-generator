{"file_name": "/home/qj213/afp-2021-10-22/thys/List-Infinite/CommonSet/InfiniteSet2.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/List-Infinite", "problem_names": ["lemma icard_UNIV_nat: \"icard (UNIV::nat set) = \\<infinity>\"", "lemma icard_finite_conv: \"(icard A = enat (card A)) = finite A\"", "lemma icard_infinite_conv: \"(icard A = \\<infinity>) = infinite A\"", "lemma icard_eq_enat_imp: \"icard A = enat n \\<Longrightarrow> finite A\"", "lemma icard_eq_Infty_imp: \"icard A = \\<infinity> \\<Longrightarrow> infinite A\"", "lemma icard_the_enat: \"finite A \\<Longrightarrow> the_enat (icard A) = card A\"", "lemma icard_eq_enat_imp_card: \"icard A = enat n \\<Longrightarrow> card A = n\"", "lemma icard_eq_enat_card_conv: \"0 < n \\<Longrightarrow> (icard A = enat n) = (card A = n)\"", "lemma icard_empty[simp]: \"icard {} = 0\"", "lemma icard_empty_iff: \"(icard A = 0) = (A = {})\"", "lemmas icard_empty_iff_enat = icard_empty_iff[unfolded zero_enat_def]", "lemma icard_not_empty_iff: \"(0 < icard A) = (A \\<noteq> {})\"", "lemmas icard_not_empty_iff_enat = icard_not_empty_iff[unfolded zero_enat_def]", "lemma icard_singleton: \"icard {a} = eSuc 0\"", "lemmas icard_singleton_enat[simp] = icard_singleton[unfolded zero_enat_def]", "lemma icard_1_imp_singleton: \"icard A = eSuc 0 \\<Longrightarrow> \\<exists>a. A = {a}\"", "lemma icard_1_singleton_conv: \"(icard A = eSuc 0) = (\\<exists>a. A = {a})\"", "lemma icard_insert_disjoint: \"x \\<notin> A \\<Longrightarrow> icard (insert x A) = eSuc (icard A)\"", "lemma icard_insert_if: \"icard (insert x A) = (if x \\<in> A then icard A else eSuc (icard A))\"", "lemmas icard_0_eq = icard_empty_iff", "lemma icard_Suc_Diff1: \"x \\<in> A \\<Longrightarrow> eSuc (icard (A - {x})) = icard A\"", "lemma icard_Diff_singleton: \"x \\<in> A \\<Longrightarrow> icard (A - {x}) = icard A - 1\"", "lemma icard_Diff_singleton_if: \"icard (A - {x}) = (if x \\<in> A then icard A - 1 else icard A)\"", "lemma icard_insert: \"icard (insert x A) = eSuc (icard (A - {x}))\"", "lemma icard_insert_le: \"icard A \\<le> icard (insert x A)\"", "lemma icard_mono: \"A \\<subseteq> B \\<Longrightarrow> icard A \\<le> icard B\"", "lemma not_icard_seteq: \"\\<exists>(A::nat set) B. (A \\<subseteq> B \\<and> icard B \\<le> icard A \\<and> \\<not> A = B)\"", "lemma not_psubset_icard_mono: \"\\<exists>(A::nat set) B. A \\<subset> B \\<and> \\<not> icard A < icard B\"", "lemma icard_Un_Int: \"icard A + icard B = icard (A \\<union> B) + icard (A \\<inter> B)\"", "lemma icard_Un_disjoint: \"A \\<inter> B = {} \\<Longrightarrow> icard (A \\<union> B) = icard A + icard B\"", "lemma not_icard_Diff_subset: \"\\<exists>(A::nat set) B. B \\<subseteq> A \\<and> \\<not> icard (A - B) = icard A - icard B\"", "lemma not_icard_Diff1_less: \"\\<exists>(A::nat set)x. x \\<in> A \\<and> \\<not> icard (A - {x}) < icard A\"", "lemma not_icard_Diff2_less: \"\\<exists>(A::nat set)x y. x \\<in> A \\<and> y \\<in> A \\<and> \\<not> icard (A - {x} - {y}) < icard A\"", "lemma icard_Diff1_le: \"icard (A - {x}) \\<le> icard A\"", "lemma icard_psubset: \"\\<lbrakk> A \\<subseteq> B; icard A < icard B \\<rbrakk> \\<Longrightarrow> A \\<subset> B\"", "lemma icard_partition: \"\n  \\<lbrakk> \\<And>c. c \\<in> C \\<Longrightarrow> icard c = k; \\<And>c1 c2. \\<lbrakk>c1 \\<in> C; c2 \\<in> C; c1 \\<noteq> c2\\<rbrakk> \\<Longrightarrow> c1 \\<inter> c2 = {} \\<rbrakk> \\<Longrightarrow>\n  icard (\\<Union>C) = k * icard C\"", "lemma icard_image_le: \"icard (f ` A) \\<le> icard A\"", "lemma icard_image: \"inj_on f A \\<Longrightarrow> icard (f ` A) = icard A\"", "lemma not_eq_icard_imp_inj_on: \"\\<exists>(f::nat\\<Rightarrow>nat) (A::nat set). icard (f ` A) = icard A \\<and> \\<not> inj_on f A\"", "lemma not_inj_on_iff_eq_icard: \"\\<exists>(f::nat\\<Rightarrow>nat) (A::nat set). \\<not> (inj_on f A = (icard (f ` A) = icard A))\"", "lemma icard_inj_on_le: \"\\<lbrakk> inj_on f A; f ` A \\<subseteq> B \\<rbrakk> \\<Longrightarrow> icard A \\<le> icard B\"", "lemma icard_bij_eq: \"\n  \\<lbrakk> inj_on f A; f ` A \\<subseteq> B; inj_on g B; g ` B \\<subseteq> A \\<rbrakk> \\<Longrightarrow>\n  icard A = icard B\"", "lemma icard_cartesian_product: \"icard (A \\<times> B) = icard A * icard B\"", "lemma icard_cartesian_product_singleton: \"icard ({x} \\<times> A) = icard A\"", "lemma icard_cartesian_product_singleton_right: \"icard (A \\<times> {x}) = icard A\"", "lemma\n  icard_lessThan: \"icard {..<u} = enat u\" and\n  icard_atMost: \"icard {..u} = enat (Suc u)\" and\n  icard_atLeastLessThan: \"icard {l..<u} = enat (u - l)\" and\n  icard_atLeastAtMost: \"icard {l..u} = enat (Suc u - l)\" and\n  icard_greaterThanAtMost: \"icard {l<..u} = enat (u - l)\" and\n  icard_greaterThanLessThan: \"icard {l<..<u} = enat (u - Suc l)\"", "lemma icard_atLeast: \"icard {(u::nat)..} = \\<infinity>\"", "lemma icard_greaterThan: \"icard {(u::nat)<..} = \\<infinity>\"", "lemma\n  icard_atLeastZeroLessThan_int: \"icard {0..<u} = enat (nat u)\" and\n  icard_atLeastLessThan_int: \"icard {l..<u} = enat (nat (u - l))\" and\n  icard_atLeastAtMost_int: \"icard {l..u} = enat (nat (u - l + 1))\" and\n  icard_greaterThanAtMost_int: \"icard {l<..u} = enat (nat (u - l))\"", "lemma icard_atLeast_int: \"icard {(u::int)..} = \\<infinity>\"", "lemma icard_greaterThan_int: \"icard {(u::int)<..} = \\<infinity>\"", "lemma icard_atMost_int: \"icard {..(u::int)} = \\<infinity>\"", "lemma icard_lessThan_int: \"icard {..<(u::int)} = \\<infinity>\""], "translations": [["", "lemma icard_UNIV_nat: \"icard (UNIV::nat set) = \\<infinity>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. icard UNIV = \\<infinity>", "by (simp add: icard_def)"], ["", "lemma icard_finite_conv: \"(icard A = enat (card A)) = finite A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (icard A = enat (card A)) = finite A", "by (case_tac \"finite A\", simp_all add: icard_def)"], ["", "lemma icard_infinite_conv: \"(icard A = \\<infinity>) = infinite A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (icard A = \\<infinity>) = infinite A", "by (case_tac \"finite A\", simp_all add: icard_def)"], ["", "corollary icard_finite: \"finite A \\<Longrightarrow> icard A = enat (card A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite A \\<Longrightarrow> icard A = enat (card A)", "by (rule icard_finite_conv[THEN iffD2])"], ["", "corollary icard_infinite[simp]: \"infinite A \\<Longrightarrow> icard A = \\<infinity>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infinite A \\<Longrightarrow> icard A = \\<infinity>", "by (rule icard_infinite_conv[THEN iffD2])"], ["", "lemma icard_eq_enat_imp: \"icard A = enat n \\<Longrightarrow> finite A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. icard A = enat n \\<Longrightarrow> finite A", "by (case_tac \"finite A\", simp_all)"], ["", "lemma icard_eq_Infty_imp: \"icard A = \\<infinity> \\<Longrightarrow> infinite A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. icard A = \\<infinity> \\<Longrightarrow> infinite A", "by (rule icard_infinite_conv[THEN iffD1])"], ["", "lemma icard_the_enat: \"finite A \\<Longrightarrow> the_enat (icard A) = card A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite A \\<Longrightarrow> the_enat (icard A) = card A", "by (simp add: icard_def)"], ["", "lemma icard_eq_enat_imp_card: \"icard A = enat n \\<Longrightarrow> card A = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. icard A = enat n \\<Longrightarrow> card A = n", "by (frule icard_eq_enat_imp, simp add: icard_finite)"], ["", "lemma icard_eq_enat_card_conv: \"0 < n \\<Longrightarrow> (icard A = enat n) = (card A = n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < n \\<Longrightarrow> (icard A = enat n) = (card A = n)", "apply (rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < n; icard A = enat n\\<rbrakk> \\<Longrightarrow> card A = n\n 2. \\<lbrakk>0 < n; card A = n\\<rbrakk> \\<Longrightarrow> icard A = enat n", "apply (simp add: icard_eq_enat_imp_card)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < n; card A = n\\<rbrakk> \\<Longrightarrow> icard A = enat n", "apply (drule sym, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < card A; n = card A\\<rbrakk>\n    \\<Longrightarrow> icard A = enat (card A)", "apply (frule card_gr0_imp_finite)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < card A; n = card A; finite A\\<rbrakk>\n    \\<Longrightarrow> icard A = enat (card A)", "apply (rule icard_finite, assumption)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma icard_empty[simp]: \"icard {} = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. icard {} = 0", "by (simp add: icard_finite[OF finite.emptyI])"], ["", "lemma icard_empty_iff: \"(icard A = 0) = (A = {})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (icard A = 0) = (A = {})", "apply (unfold zero_enat_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (icard A = enat 0) = (A = {})", "apply (rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. icard A = enat 0 \\<Longrightarrow> A = {}\n 2. A = {} \\<Longrightarrow> icard A = enat 0", "apply (frule icard_eq_enat_imp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>icard A = enat 0; finite A\\<rbrakk> \\<Longrightarrow> A = {}\n 2. A = {} \\<Longrightarrow> icard A = enat 0", "apply (simp add: icard_finite)"], ["proof (prove)\ngoal (1 subgoal):\n 1. A = {} \\<Longrightarrow> icard A = enat 0", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemmas icard_empty_iff_enat = icard_empty_iff[unfolded zero_enat_def]"], ["", "lemma icard_not_empty_iff: \"(0 < icard A) = (A \\<noteq> {})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0 < icard A) = (A \\<noteq> {})", "by (simp add: icard_empty_iff[symmetric])"], ["", "lemmas icard_not_empty_iff_enat = icard_not_empty_iff[unfolded zero_enat_def]"], ["", "lemma icard_singleton: \"icard {a} = eSuc 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. icard {a} = eSuc 0", "by (simp add: icard_finite eSuc_enat)"], ["", "lemmas icard_singleton_enat[simp] = icard_singleton[unfolded zero_enat_def]"], ["", "lemma icard_1_imp_singleton: \"icard A = eSuc 0 \\<Longrightarrow> \\<exists>a. A = {a}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. icard A = eSuc 0 \\<Longrightarrow> \\<exists>a. A = {a}", "apply (simp add: eSuc_enat)"], ["proof (prove)\ngoal (1 subgoal):\n 1. icard A = enat (Suc 0) \\<Longrightarrow> \\<exists>a. A = {a}", "apply (frule icard_eq_enat_imp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>icard A = enat (Suc 0); finite A\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a. A = {a}", "apply (simp add: icard_finite card_1_imp_singleton)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma icard_1_singleton_conv: \"(icard A = eSuc 0) = (\\<exists>a. A = {a})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (icard A = eSuc 0) = (\\<exists>a. A = {a})", "apply (rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. icard A = eSuc 0 \\<Longrightarrow> \\<exists>a. A = {a}\n 2. \\<exists>a. A = {a} \\<Longrightarrow> icard A = eSuc 0", "apply (simp add: icard_1_imp_singleton)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>a. A = {a} \\<Longrightarrow> icard A = eSuc 0", "apply fastforce"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma icard_insert_disjoint: \"x \\<notin> A \\<Longrightarrow> icard (insert x A) = eSuc (icard A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> A \\<Longrightarrow> icard (insert x A) = eSuc (icard A)", "apply (case_tac \"finite A\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<notin> A; finite A\\<rbrakk>\n    \\<Longrightarrow> icard (insert x A) = eSuc (icard A)\n 2. \\<lbrakk>x \\<notin> A; infinite A\\<rbrakk>\n    \\<Longrightarrow> icard (insert x A) = eSuc (icard A)", "apply (simp add: icard_finite eSuc_enat card_insert_disjoint)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<notin> A; infinite A\\<rbrakk>\n    \\<Longrightarrow> icard (insert x A) = eSuc (icard A)", "apply (simp add: infinite_insert)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma icard_insert_if: \"icard (insert x A) = (if x \\<in> A then icard A else eSuc (icard A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. icard (insert x A) = (if x \\<in> A then icard A else eSuc (icard A))", "apply (case_tac \"x \\<in> A\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. x \\<in> A \\<Longrightarrow>\n    icard (insert x A) = (if x \\<in> A then icard A else eSuc (icard A))\n 2. x \\<notin> A \\<Longrightarrow>\n    icard (insert x A) = (if x \\<in> A then icard A else eSuc (icard A))", "apply (simp add: insert_absorb)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> A \\<Longrightarrow>\n    icard (insert x A) = (if x \\<in> A then icard A else eSuc (icard A))", "apply (simp add: icard_insert_disjoint)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemmas icard_0_eq = icard_empty_iff"], ["", "lemma icard_Suc_Diff1: \"x \\<in> A \\<Longrightarrow> eSuc (icard (A - {x})) = icard A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> A \\<Longrightarrow> eSuc (icard (A - {x})) = icard A", "apply (case_tac \"finite A\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<in> A; finite A\\<rbrakk>\n    \\<Longrightarrow> eSuc (icard (A - {x})) = icard A\n 2. \\<lbrakk>x \\<in> A; infinite A\\<rbrakk>\n    \\<Longrightarrow> eSuc (icard (A - {x})) = icard A", "apply (simp add: icard_finite eSuc_enat in_imp_not_empty not_empty_card_gr0_conv[THEN iffD1])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> A; infinite A\\<rbrakk>\n    \\<Longrightarrow> eSuc (icard (A - {x})) = icard A", "apply (simp add: Diff_infinite_finite[OF singleton_finite])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma icard_Diff_singleton: \"x \\<in> A \\<Longrightarrow> icard (A - {x}) = icard A - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> A \\<Longrightarrow> icard (A - {x}) = icard A - 1", "apply (rule eSuc_inject[THEN iffD1])"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> A \\<Longrightarrow> eSuc (icard (A - {x})) = eSuc (icard A - 1)", "apply (frule in_imp_not_empty, drule icard_not_empty_iff[THEN iffD2])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> A; 0 < icard A\\<rbrakk>\n    \\<Longrightarrow> eSuc (icard (A - {x})) = eSuc (icard A - 1)", "apply (simp add: icard_Suc_Diff1 eSuc_pred_enat one_eSuc)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma icard_Diff_singleton_if: \"icard (A - {x}) = (if x \\<in> A then icard A - 1 else icard A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. icard (A - {x}) = (if x \\<in> A then icard A - 1 else icard A)", "by (simp add: icard_Diff_singleton)"], ["", "lemma icard_insert: \"icard (insert x A) = eSuc (icard (A - {x}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. icard (insert x A) = eSuc (icard (A - {x}))", "by (metis icard_Diff_singleton_if icard_Suc_Diff1 icard_insert_disjoint insert_absorb)"], ["", "lemma icard_insert_le: \"icard A \\<le> icard (insert x A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. icard A \\<le> icard (insert x A)", "by (simp add: icard_insert_if)"], ["", "lemma icard_mono: \"A \\<subseteq> B \\<Longrightarrow> icard A \\<le> icard B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<subseteq> B \\<Longrightarrow> icard A \\<le> icard B", "apply (case_tac \"finite B\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>A \\<subseteq> B; finite B\\<rbrakk>\n    \\<Longrightarrow> icard A \\<le> icard B\n 2. \\<lbrakk>A \\<subseteq> B; infinite B\\<rbrakk>\n    \\<Longrightarrow> icard A \\<le> icard B", "apply (frule subset_finite_imp_finite, simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>A \\<subseteq> B; finite B; finite A\\<rbrakk>\n    \\<Longrightarrow> icard A \\<le> icard B\n 2. \\<lbrakk>A \\<subseteq> B; infinite B\\<rbrakk>\n    \\<Longrightarrow> icard A \\<le> icard B", "apply (simp add: icard_finite card_mono)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<subseteq> B; infinite B\\<rbrakk>\n    \\<Longrightarrow> icard A \\<le> icard B", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma not_icard_seteq: \"\\<exists>(A::nat set) B. (A \\<subseteq> B \\<and> icard B \\<le> icard A \\<and> \\<not> A = B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>A B.\n       A \\<subseteq> B \\<and> icard B \\<le> icard A \\<and> A \\<noteq> B", "apply (rule_tac x=\"{1..}\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>B.\n       {1..} \\<subseteq> B \\<and>\n       icard B \\<le> icard {1..} \\<and> {1..} \\<noteq> B", "apply (rule_tac x=\"{0..}\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. {1..} \\<subseteq> {0..} \\<and>\n    icard {0..} \\<le> icard {1..} \\<and> {1..} \\<noteq> {0..}", "apply (fastforce simp add: infinite_atLeast)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma not_psubset_icard_mono: \"\\<exists>(A::nat set) B. A \\<subset> B \\<and> \\<not> icard A < icard B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>A B. A \\<subset> B \\<and> \\<not> icard A < icard B", "apply (rule_tac x=\"{1..}\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>B. {1..} \\<subset> B \\<and> \\<not> icard {1..} < icard B", "apply (rule_tac x=\"{0..}\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. {1..} \\<subset> {0..} \\<and> \\<not> icard {1..} < icard {0..}", "apply (fastforce simp add: infinite_atLeast)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma icard_Un_Int: \"icard A + icard B = icard (A \\<union> B) + icard (A \\<inter> B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. icard A + icard B = icard (A \\<union> B) + icard (A \\<inter> B)", "apply (case_tac \"finite A\", case_tac \"finite B\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>finite A; finite B\\<rbrakk>\n    \\<Longrightarrow> icard A + icard B =\n                      icard (A \\<union> B) + icard (A \\<inter> B)\n 2. \\<lbrakk>finite A; infinite B\\<rbrakk>\n    \\<Longrightarrow> icard A + icard B =\n                      icard (A \\<union> B) + icard (A \\<inter> B)\n 3. infinite A \\<Longrightarrow>\n    icard A + icard B = icard (A \\<union> B) + icard (A \\<inter> B)", "apply (simp add: icard_finite card_Un_Int[of A])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>finite A; infinite B\\<rbrakk>\n    \\<Longrightarrow> icard A + icard B =\n                      icard (A \\<union> B) + icard (A \\<inter> B)\n 2. infinite A \\<Longrightarrow>\n    icard A + icard B = icard (A \\<union> B) + icard (A \\<inter> B)", "apply simp_all"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma icard_Un_disjoint: \"A \\<inter> B = {} \\<Longrightarrow> icard (A \\<union> B) = icard A + icard B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<inter> B = {} \\<Longrightarrow>\n    icard (A \\<union> B) = icard A + icard B", "by (simp add: icard_Un_Int[of A])"], ["", "lemma not_icard_Diff_subset: \"\\<exists>(A::nat set) B. B \\<subseteq> A \\<and> \\<not> icard (A - B) = icard A - icard B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>A B.\n       B \\<subseteq> A \\<and> icard (A - B) \\<noteq> icard A - icard B", "apply (rule_tac x=\"{0..}\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>B\\<subseteq>{0..}.\n       icard ({0..} - B) \\<noteq> icard {0..} - icard B", "apply (rule_tac x=\"{1..}\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. {1..} \\<subseteq> {0..} \\<and>\n    icard ({0..} - {1..}) \\<noteq> icard {0..} - icard {1..}", "apply (simp add: set_diff_eq linorder_not_le icard_UNIV_nat eSuc_enat)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma not_icard_Diff1_less: \"\\<exists>(A::nat set)x. x \\<in> A \\<and> \\<not> icard (A - {x}) < icard A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>A x. x \\<in> A \\<and> \\<not> icard (A - {x}) < icard A", "by (rule_tac x=\"{0..}\" in exI, simp)"], ["", "lemma not_icard_Diff2_less: \"\\<exists>(A::nat set)x y. x \\<in> A \\<and> y \\<in> A \\<and> \\<not> icard (A - {x} - {y}) < icard A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>A x y.\n       x \\<in> A \\<and>\n       y \\<in> A \\<and> \\<not> icard (A - {x} - {y}) < icard A", "by (rule_tac x=\"{0..}\" in exI, simp)"], ["", "lemma icard_Diff1_le: \"icard (A - {x}) \\<le> icard A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. icard (A - {x}) \\<le> icard A", "by (rule icard_mono, rule Diff_subset)"], ["", "lemma icard_psubset: \"\\<lbrakk> A \\<subseteq> B; icard A < icard B \\<rbrakk> \\<Longrightarrow> A \\<subset> B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<subseteq> B; icard A < icard B\\<rbrakk>\n    \\<Longrightarrow> A \\<subset> B", "by (metis less_le psubset_eq)"], ["", "lemma icard_partition: \"\n  \\<lbrakk> \\<And>c. c \\<in> C \\<Longrightarrow> icard c = k; \\<And>c1 c2. \\<lbrakk>c1 \\<in> C; c2 \\<in> C; c1 \\<noteq> c2\\<rbrakk> \\<Longrightarrow> c1 \\<inter> c2 = {} \\<rbrakk> \\<Longrightarrow>\n  icard (\\<Union>C) = k * icard C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>c. c \\<in> C \\<Longrightarrow> icard c = k;\n     \\<And>c1 c2.\n        \\<lbrakk>c1 \\<in> C; c2 \\<in> C; c1 \\<noteq> c2\\<rbrakk>\n        \\<Longrightarrow> c1 \\<inter> c2 = {}\\<rbrakk>\n    \\<Longrightarrow> icard (\\<Union> C) = k * icard C", "apply (case_tac \"C = {}\", simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>c. c \\<in> C \\<Longrightarrow> icard c = k;\n     \\<And>c1 c2.\n        \\<lbrakk>c1 \\<in> C; c2 \\<in> C; c1 \\<noteq> c2\\<rbrakk>\n        \\<Longrightarrow> c1 \\<inter> c2 = {};\n     C \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> icard (\\<Union> C) = k * icard C", "apply (case_tac \"k = 0\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>c. c \\<in> C \\<Longrightarrow> icard c = k;\n     \\<And>c1 c2.\n        \\<lbrakk>c1 \\<in> C; c2 \\<in> C; c1 \\<noteq> c2\\<rbrakk>\n        \\<Longrightarrow> c1 \\<inter> c2 = {};\n     C \\<noteq> {}; k = 0\\<rbrakk>\n    \\<Longrightarrow> icard (\\<Union> C) = k * icard C\n 2. \\<lbrakk>\\<And>c. c \\<in> C \\<Longrightarrow> icard c = k;\n     \\<And>c1 c2.\n        \\<lbrakk>c1 \\<in> C; c2 \\<in> C; c1 \\<noteq> c2\\<rbrakk>\n        \\<Longrightarrow> c1 \\<inter> c2 = {};\n     C \\<noteq> {}; k \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> icard (\\<Union> C) = k * icard C", "apply (simp add: icard_empty_iff_enat)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>c. c \\<in> C \\<Longrightarrow> icard c = k;\n     \\<And>c1 c2.\n        \\<lbrakk>c1 \\<in> C; c2 \\<in> C; c1 \\<noteq> c2\\<rbrakk>\n        \\<Longrightarrow> c1 \\<inter> c2 = {};\n     C \\<noteq> {}; k \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> icard (\\<Union> C) = k * icard C", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>c. c \\<in> C \\<Longrightarrow> icard c = k;\n     \\<And>c1 c2.\n        \\<lbrakk>c1 \\<in> C; c2 \\<in> C; c1 \\<noteq> c2\\<rbrakk>\n        \\<Longrightarrow> c1 \\<inter> c2 = {};\n     C \\<noteq> {}; enat 0 < k\\<rbrakk>\n    \\<Longrightarrow> icard (\\<Union> C) = k * icard C", "apply (case_tac k, rename_tac k1)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>k1.\n       \\<lbrakk>\\<And>c. c \\<in> C \\<Longrightarrow> icard c = k;\n        \\<And>c1 c2.\n           \\<lbrakk>c1 \\<in> C; c2 \\<in> C; c1 \\<noteq> c2\\<rbrakk>\n           \\<Longrightarrow> c1 \\<inter> c2 = {};\n        C \\<noteq> {}; enat 0 < k; k = enat k1\\<rbrakk>\n       \\<Longrightarrow> icard (\\<Union> C) = k * icard C\n 2. \\<lbrakk>\\<And>c. c \\<in> C \\<Longrightarrow> icard c = k;\n     \\<And>c1 c2.\n        \\<lbrakk>c1 \\<in> C; c2 \\<in> C; c1 \\<noteq> c2\\<rbrakk>\n        \\<Longrightarrow> c1 \\<inter> c2 = {};\n     C \\<noteq> {}; enat 0 < k; k = \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> icard (\\<Union> C) = k * icard C", "apply (subgoal_tac \"0 < k1\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>k1.\n       \\<lbrakk>\\<And>c. c \\<in> C \\<Longrightarrow> icard c = k;\n        \\<And>c1 c2.\n           \\<lbrakk>c1 \\<in> C; c2 \\<in> C; c1 \\<noteq> c2\\<rbrakk>\n           \\<Longrightarrow> c1 \\<inter> c2 = {};\n        C \\<noteq> {}; enat 0 < k; k = enat k1; 0 < k1\\<rbrakk>\n       \\<Longrightarrow> icard (\\<Union> C) = k * icard C\n 2. \\<And>k1.\n       \\<lbrakk>\\<And>c. c \\<in> C \\<Longrightarrow> icard c = k;\n        \\<And>c1 c2.\n           \\<lbrakk>c1 \\<in> C; c2 \\<in> C; c1 \\<noteq> c2\\<rbrakk>\n           \\<Longrightarrow> c1 \\<inter> c2 = {};\n        C \\<noteq> {}; enat 0 < k; k = enat k1\\<rbrakk>\n       \\<Longrightarrow> 0 < k1\n 3. \\<lbrakk>\\<And>c. c \\<in> C \\<Longrightarrow> icard c = k;\n     \\<And>c1 c2.\n        \\<lbrakk>c1 \\<in> C; c2 \\<in> C; c1 \\<noteq> c2\\<rbrakk>\n        \\<Longrightarrow> c1 \\<inter> c2 = {};\n     C \\<noteq> {}; enat 0 < k; k = \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> icard (\\<Union> C) = k * icard C", "prefer 2"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>k1.\n       \\<lbrakk>\\<And>c. c \\<in> C \\<Longrightarrow> icard c = k;\n        \\<And>c1 c2.\n           \\<lbrakk>c1 \\<in> C; c2 \\<in> C; c1 \\<noteq> c2\\<rbrakk>\n           \\<Longrightarrow> c1 \\<inter> c2 = {};\n        C \\<noteq> {}; enat 0 < k; k = enat k1\\<rbrakk>\n       \\<Longrightarrow> 0 < k1\n 2. \\<And>k1.\n       \\<lbrakk>\\<And>c. c \\<in> C \\<Longrightarrow> icard c = k;\n        \\<And>c1 c2.\n           \\<lbrakk>c1 \\<in> C; c2 \\<in> C; c1 \\<noteq> c2\\<rbrakk>\n           \\<Longrightarrow> c1 \\<inter> c2 = {};\n        C \\<noteq> {}; enat 0 < k; k = enat k1; 0 < k1\\<rbrakk>\n       \\<Longrightarrow> icard (\\<Union> C) = k * icard C\n 3. \\<lbrakk>\\<And>c. c \\<in> C \\<Longrightarrow> icard c = k;\n     \\<And>c1 c2.\n        \\<lbrakk>c1 \\<in> C; c2 \\<in> C; c1 \\<noteq> c2\\<rbrakk>\n        \\<Longrightarrow> c1 \\<inter> c2 = {};\n     C \\<noteq> {}; enat 0 < k; k = \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> icard (\\<Union> C) = k * icard C", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>k1.\n       \\<lbrakk>\\<And>c. c \\<in> C \\<Longrightarrow> icard c = k;\n        \\<And>c1 c2.\n           \\<lbrakk>c1 \\<in> C; c2 \\<in> C; c1 \\<noteq> c2\\<rbrakk>\n           \\<Longrightarrow> c1 \\<inter> c2 = {};\n        C \\<noteq> {}; enat 0 < k; k = enat k1; 0 < k1\\<rbrakk>\n       \\<Longrightarrow> icard (\\<Union> C) = k * icard C\n 2. \\<lbrakk>\\<And>c. c \\<in> C \\<Longrightarrow> icard c = k;\n     \\<And>c1 c2.\n        \\<lbrakk>c1 \\<in> C; c2 \\<in> C; c1 \\<noteq> c2\\<rbrakk>\n        \\<Longrightarrow> c1 \\<inter> c2 = {};\n     C \\<noteq> {}; enat 0 < k; k = \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> icard (\\<Union> C) = k * icard C", "apply (case_tac \"finite C\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>k1.\n       \\<lbrakk>\\<And>c. c \\<in> C \\<Longrightarrow> icard c = k;\n        \\<And>c1 c2.\n           \\<lbrakk>c1 \\<in> C; c2 \\<in> C; c1 \\<noteq> c2\\<rbrakk>\n           \\<Longrightarrow> c1 \\<inter> c2 = {};\n        C \\<noteq> {}; enat 0 < k; k = enat k1; 0 < k1; finite C\\<rbrakk>\n       \\<Longrightarrow> icard (\\<Union> C) = k * icard C\n 2. \\<And>k1.\n       \\<lbrakk>\\<And>c. c \\<in> C \\<Longrightarrow> icard c = k;\n        \\<And>c1 c2.\n           \\<lbrakk>c1 \\<in> C; c2 \\<in> C; c1 \\<noteq> c2\\<rbrakk>\n           \\<Longrightarrow> c1 \\<inter> c2 = {};\n        C \\<noteq> {}; enat 0 < k; k = enat k1; 0 < k1; infinite C\\<rbrakk>\n       \\<Longrightarrow> icard (\\<Union> C) = k * icard C\n 3. \\<lbrakk>\\<And>c. c \\<in> C \\<Longrightarrow> icard c = k;\n     \\<And>c1 c2.\n        \\<lbrakk>c1 \\<in> C; c2 \\<in> C; c1 \\<noteq> c2\\<rbrakk>\n        \\<Longrightarrow> c1 \\<inter> c2 = {};\n     C \\<noteq> {}; enat 0 < k; k = \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> icard (\\<Union> C) = k * icard C", "apply (simp add: icard_finite)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>k1.\n       \\<lbrakk>\\<And>c. c \\<in> C \\<Longrightarrow> icard c = enat k1;\n        \\<And>c1 c2.\n           \\<lbrakk>c1 \\<in> C; c2 \\<in> C; c1 \\<noteq> c2\\<rbrakk>\n           \\<Longrightarrow> c1 \\<inter> c2 = {};\n        C \\<noteq> {}; k = enat k1; 0 < k1; finite C\\<rbrakk>\n       \\<Longrightarrow> icard (\\<Union> C) = enat (k1 * card C)\n 2. \\<And>k1.\n       \\<lbrakk>\\<And>c. c \\<in> C \\<Longrightarrow> icard c = k;\n        \\<And>c1 c2.\n           \\<lbrakk>c1 \\<in> C; c2 \\<in> C; c1 \\<noteq> c2\\<rbrakk>\n           \\<Longrightarrow> c1 \\<inter> c2 = {};\n        C \\<noteq> {}; enat 0 < k; k = enat k1; 0 < k1; infinite C\\<rbrakk>\n       \\<Longrightarrow> icard (\\<Union> C) = k * icard C\n 3. \\<lbrakk>\\<And>c. c \\<in> C \\<Longrightarrow> icard c = k;\n     \\<And>c1 c2.\n        \\<lbrakk>c1 \\<in> C; c2 \\<in> C; c1 \\<noteq> c2\\<rbrakk>\n        \\<Longrightarrow> c1 \\<inter> c2 = {};\n     C \\<noteq> {}; enat 0 < k; k = \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> icard (\\<Union> C) = k * icard C", "apply (subgoal_tac \"\\<And>c. c \\<in> C \\<Longrightarrow> card c = k1\")"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>k1.\n       \\<lbrakk>\\<And>c. c \\<in> C \\<Longrightarrow> icard c = enat k1;\n        \\<And>c1 c2.\n           \\<lbrakk>c1 \\<in> C; c2 \\<in> C; c1 \\<noteq> c2\\<rbrakk>\n           \\<Longrightarrow> c1 \\<inter> c2 = {};\n        C \\<noteq> {}; k = enat k1; 0 < k1; finite C;\n        \\<And>c. c \\<in> C \\<Longrightarrow> card c = k1\\<rbrakk>\n       \\<Longrightarrow> icard (\\<Union> C) = enat (k1 * card C)\n 2. \\<And>k1 c.\n       \\<lbrakk>\\<And>c. c \\<in> C \\<Longrightarrow> icard c = enat k1;\n        \\<And>c1 c2.\n           \\<lbrakk>c1 \\<in> C; c2 \\<in> C; c1 \\<noteq> c2\\<rbrakk>\n           \\<Longrightarrow> c1 \\<inter> c2 = {};\n        C \\<noteq> {}; k = enat k1; 0 < k1; finite C; c \\<in> C\\<rbrakk>\n       \\<Longrightarrow> card c = k1\n 3. \\<And>k1.\n       \\<lbrakk>\\<And>c. c \\<in> C \\<Longrightarrow> icard c = k;\n        \\<And>c1 c2.\n           \\<lbrakk>c1 \\<in> C; c2 \\<in> C; c1 \\<noteq> c2\\<rbrakk>\n           \\<Longrightarrow> c1 \\<inter> c2 = {};\n        C \\<noteq> {}; enat 0 < k; k = enat k1; 0 < k1; infinite C\\<rbrakk>\n       \\<Longrightarrow> icard (\\<Union> C) = k * icard C\n 4. \\<lbrakk>\\<And>c. c \\<in> C \\<Longrightarrow> icard c = k;\n     \\<And>c1 c2.\n        \\<lbrakk>c1 \\<in> C; c2 \\<in> C; c1 \\<noteq> c2\\<rbrakk>\n        \\<Longrightarrow> c1 \\<inter> c2 = {};\n     C \\<noteq> {}; enat 0 < k; k = \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> icard (\\<Union> C) = k * icard C", "prefer 2"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>k1 c.\n       \\<lbrakk>\\<And>c. c \\<in> C \\<Longrightarrow> icard c = enat k1;\n        \\<And>c1 c2.\n           \\<lbrakk>c1 \\<in> C; c2 \\<in> C; c1 \\<noteq> c2\\<rbrakk>\n           \\<Longrightarrow> c1 \\<inter> c2 = {};\n        C \\<noteq> {}; k = enat k1; 0 < k1; finite C; c \\<in> C\\<rbrakk>\n       \\<Longrightarrow> card c = k1\n 2. \\<And>k1.\n       \\<lbrakk>\\<And>c. c \\<in> C \\<Longrightarrow> icard c = enat k1;\n        \\<And>c1 c2.\n           \\<lbrakk>c1 \\<in> C; c2 \\<in> C; c1 \\<noteq> c2\\<rbrakk>\n           \\<Longrightarrow> c1 \\<inter> c2 = {};\n        C \\<noteq> {}; k = enat k1; 0 < k1; finite C;\n        \\<And>c. c \\<in> C \\<Longrightarrow> card c = k1\\<rbrakk>\n       \\<Longrightarrow> icard (\\<Union> C) = enat (k1 * card C)\n 3. \\<And>k1.\n       \\<lbrakk>\\<And>c. c \\<in> C \\<Longrightarrow> icard c = k;\n        \\<And>c1 c2.\n           \\<lbrakk>c1 \\<in> C; c2 \\<in> C; c1 \\<noteq> c2\\<rbrakk>\n           \\<Longrightarrow> c1 \\<inter> c2 = {};\n        C \\<noteq> {}; enat 0 < k; k = enat k1; 0 < k1; infinite C\\<rbrakk>\n       \\<Longrightarrow> icard (\\<Union> C) = k * icard C\n 4. \\<lbrakk>\\<And>c. c \\<in> C \\<Longrightarrow> icard c = k;\n     \\<And>c1 c2.\n        \\<lbrakk>c1 \\<in> C; c2 \\<in> C; c1 \\<noteq> c2\\<rbrakk>\n        \\<Longrightarrow> c1 \\<inter> c2 = {};\n     C \\<noteq> {}; enat 0 < k; k = \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> icard (\\<Union> C) = k * icard C", "apply (rule icard_eq_enat_imp_card, simp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>k1.\n       \\<lbrakk>\\<And>c. c \\<in> C \\<Longrightarrow> icard c = enat k1;\n        \\<And>c1 c2.\n           \\<lbrakk>c1 \\<in> C; c2 \\<in> C; c1 \\<noteq> c2\\<rbrakk>\n           \\<Longrightarrow> c1 \\<inter> c2 = {};\n        C \\<noteq> {}; k = enat k1; 0 < k1; finite C;\n        \\<And>c. c \\<in> C \\<Longrightarrow> card c = k1\\<rbrakk>\n       \\<Longrightarrow> icard (\\<Union> C) = enat (k1 * card C)\n 2. \\<And>k1.\n       \\<lbrakk>\\<And>c. c \\<in> C \\<Longrightarrow> icard c = k;\n        \\<And>c1 c2.\n           \\<lbrakk>c1 \\<in> C; c2 \\<in> C; c1 \\<noteq> c2\\<rbrakk>\n           \\<Longrightarrow> c1 \\<inter> c2 = {};\n        C \\<noteq> {}; enat 0 < k; k = enat k1; 0 < k1; infinite C\\<rbrakk>\n       \\<Longrightarrow> icard (\\<Union> C) = k * icard C\n 3. \\<lbrakk>\\<And>c. c \\<in> C \\<Longrightarrow> icard c = k;\n     \\<And>c1 c2.\n        \\<lbrakk>c1 \\<in> C; c2 \\<in> C; c1 \\<noteq> c2\\<rbrakk>\n        \\<Longrightarrow> c1 \\<inter> c2 = {};\n     C \\<noteq> {}; enat 0 < k; k = \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> icard (\\<Union> C) = k * icard C", "apply (frule_tac C=C and k=k1 in SetInterval2.card_partition, simp+)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>k1.\n       \\<lbrakk>\\<And>c. c \\<in> C \\<Longrightarrow> icard c = enat k1;\n        \\<And>c1 c2.\n           \\<lbrakk>c1 \\<in> C; c2 \\<in> C; c1 \\<noteq> c2\\<rbrakk>\n           \\<Longrightarrow> c1 \\<inter> c2 = {};\n        C \\<noteq> {}; k = enat k1; 0 < k1; finite C;\n        \\<And>c. c \\<in> C \\<Longrightarrow> card c = k1;\n        card (\\<Union> C) = k1 * card C\\<rbrakk>\n       \\<Longrightarrow> icard (\\<Union> C) = enat (k1 * card C)\n 2. \\<And>k1.\n       \\<lbrakk>\\<And>c. c \\<in> C \\<Longrightarrow> icard c = k;\n        \\<And>c1 c2.\n           \\<lbrakk>c1 \\<in> C; c2 \\<in> C; c1 \\<noteq> c2\\<rbrakk>\n           \\<Longrightarrow> c1 \\<inter> c2 = {};\n        C \\<noteq> {}; enat 0 < k; k = enat k1; 0 < k1; infinite C\\<rbrakk>\n       \\<Longrightarrow> icard (\\<Union> C) = k * icard C\n 3. \\<lbrakk>\\<And>c. c \\<in> C \\<Longrightarrow> icard c = k;\n     \\<And>c1 c2.\n        \\<lbrakk>c1 \\<in> C; c2 \\<in> C; c1 \\<noteq> c2\\<rbrakk>\n        \\<Longrightarrow> c1 \\<inter> c2 = {};\n     C \\<noteq> {}; enat 0 < k; k = \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> icard (\\<Union> C) = k * icard C", "apply (subgoal_tac \"finite (\\<Union>C)\")"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>k1.\n       \\<lbrakk>\\<And>c. c \\<in> C \\<Longrightarrow> icard c = enat k1;\n        \\<And>c1 c2.\n           \\<lbrakk>c1 \\<in> C; c2 \\<in> C; c1 \\<noteq> c2\\<rbrakk>\n           \\<Longrightarrow> c1 \\<inter> c2 = {};\n        C \\<noteq> {}; k = enat k1; 0 < k1; finite C;\n        \\<And>c. c \\<in> C \\<Longrightarrow> card c = k1;\n        card (\\<Union> C) = k1 * card C; finite (\\<Union> C)\\<rbrakk>\n       \\<Longrightarrow> icard (\\<Union> C) = enat (k1 * card C)\n 2. \\<And>k1.\n       \\<lbrakk>\\<And>c. c \\<in> C \\<Longrightarrow> icard c = enat k1;\n        \\<And>c1 c2.\n           \\<lbrakk>c1 \\<in> C; c2 \\<in> C; c1 \\<noteq> c2\\<rbrakk>\n           \\<Longrightarrow> c1 \\<inter> c2 = {};\n        C \\<noteq> {}; k = enat k1; 0 < k1; finite C;\n        \\<And>c. c \\<in> C \\<Longrightarrow> card c = k1;\n        card (\\<Union> C) = k1 * card C\\<rbrakk>\n       \\<Longrightarrow> finite (\\<Union> C)\n 3. \\<And>k1.\n       \\<lbrakk>\\<And>c. c \\<in> C \\<Longrightarrow> icard c = k;\n        \\<And>c1 c2.\n           \\<lbrakk>c1 \\<in> C; c2 \\<in> C; c1 \\<noteq> c2\\<rbrakk>\n           \\<Longrightarrow> c1 \\<inter> c2 = {};\n        C \\<noteq> {}; enat 0 < k; k = enat k1; 0 < k1; infinite C\\<rbrakk>\n       \\<Longrightarrow> icard (\\<Union> C) = k * icard C\n 4. \\<lbrakk>\\<And>c. c \\<in> C \\<Longrightarrow> icard c = k;\n     \\<And>c1 c2.\n        \\<lbrakk>c1 \\<in> C; c2 \\<in> C; c1 \\<noteq> c2\\<rbrakk>\n        \\<Longrightarrow> c1 \\<inter> c2 = {};\n     C \\<noteq> {}; enat 0 < k; k = \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> icard (\\<Union> C) = k * icard C", "prefer 2"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>k1.\n       \\<lbrakk>\\<And>c. c \\<in> C \\<Longrightarrow> icard c = enat k1;\n        \\<And>c1 c2.\n           \\<lbrakk>c1 \\<in> C; c2 \\<in> C; c1 \\<noteq> c2\\<rbrakk>\n           \\<Longrightarrow> c1 \\<inter> c2 = {};\n        C \\<noteq> {}; k = enat k1; 0 < k1; finite C;\n        \\<And>c. c \\<in> C \\<Longrightarrow> card c = k1;\n        card (\\<Union> C) = k1 * card C\\<rbrakk>\n       \\<Longrightarrow> finite (\\<Union> C)\n 2. \\<And>k1.\n       \\<lbrakk>\\<And>c. c \\<in> C \\<Longrightarrow> icard c = enat k1;\n        \\<And>c1 c2.\n           \\<lbrakk>c1 \\<in> C; c2 \\<in> C; c1 \\<noteq> c2\\<rbrakk>\n           \\<Longrightarrow> c1 \\<inter> c2 = {};\n        C \\<noteq> {}; k = enat k1; 0 < k1; finite C;\n        \\<And>c. c \\<in> C \\<Longrightarrow> card c = k1;\n        card (\\<Union> C) = k1 * card C; finite (\\<Union> C)\\<rbrakk>\n       \\<Longrightarrow> icard (\\<Union> C) = enat (k1 * card C)\n 3. \\<And>k1.\n       \\<lbrakk>\\<And>c. c \\<in> C \\<Longrightarrow> icard c = k;\n        \\<And>c1 c2.\n           \\<lbrakk>c1 \\<in> C; c2 \\<in> C; c1 \\<noteq> c2\\<rbrakk>\n           \\<Longrightarrow> c1 \\<inter> c2 = {};\n        C \\<noteq> {}; enat 0 < k; k = enat k1; 0 < k1; infinite C\\<rbrakk>\n       \\<Longrightarrow> icard (\\<Union> C) = k * icard C\n 4. \\<lbrakk>\\<And>c. c \\<in> C \\<Longrightarrow> icard c = k;\n     \\<And>c1 c2.\n        \\<lbrakk>c1 \\<in> C; c2 \\<in> C; c1 \\<noteq> c2\\<rbrakk>\n        \\<Longrightarrow> c1 \\<inter> c2 = {};\n     C \\<noteq> {}; enat 0 < k; k = \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> icard (\\<Union> C) = k * icard C", "apply (rule card_gr0_imp_finite)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>k1.\n       \\<lbrakk>\\<And>c. c \\<in> C \\<Longrightarrow> icard c = enat k1;\n        \\<And>c1 c2.\n           \\<lbrakk>c1 \\<in> C; c2 \\<in> C; c1 \\<noteq> c2\\<rbrakk>\n           \\<Longrightarrow> c1 \\<inter> c2 = {};\n        C \\<noteq> {}; k = enat k1; 0 < k1; finite C;\n        \\<And>c. c \\<in> C \\<Longrightarrow> card c = k1;\n        card (\\<Union> C) = k1 * card C\\<rbrakk>\n       \\<Longrightarrow> 0 < card (\\<Union> C)\n 2. \\<And>k1.\n       \\<lbrakk>\\<And>c. c \\<in> C \\<Longrightarrow> icard c = enat k1;\n        \\<And>c1 c2.\n           \\<lbrakk>c1 \\<in> C; c2 \\<in> C; c1 \\<noteq> c2\\<rbrakk>\n           \\<Longrightarrow> c1 \\<inter> c2 = {};\n        C \\<noteq> {}; k = enat k1; 0 < k1; finite C;\n        \\<And>c. c \\<in> C \\<Longrightarrow> card c = k1;\n        card (\\<Union> C) = k1 * card C; finite (\\<Union> C)\\<rbrakk>\n       \\<Longrightarrow> icard (\\<Union> C) = enat (k1 * card C)\n 3. \\<And>k1.\n       \\<lbrakk>\\<And>c. c \\<in> C \\<Longrightarrow> icard c = k;\n        \\<And>c1 c2.\n           \\<lbrakk>c1 \\<in> C; c2 \\<in> C; c1 \\<noteq> c2\\<rbrakk>\n           \\<Longrightarrow> c1 \\<inter> c2 = {};\n        C \\<noteq> {}; enat 0 < k; k = enat k1; 0 < k1; infinite C\\<rbrakk>\n       \\<Longrightarrow> icard (\\<Union> C) = k * icard C\n 4. \\<lbrakk>\\<And>c. c \\<in> C \\<Longrightarrow> icard c = k;\n     \\<And>c1 c2.\n        \\<lbrakk>c1 \\<in> C; c2 \\<in> C; c1 \\<noteq> c2\\<rbrakk>\n        \\<Longrightarrow> c1 \\<inter> c2 = {};\n     C \\<noteq> {}; enat 0 < k; k = \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> icard (\\<Union> C) = k * icard C", "apply (simp add: not_empty_card_gr0_conv)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>k1.\n       \\<lbrakk>\\<And>c. c \\<in> C \\<Longrightarrow> icard c = enat k1;\n        \\<And>c1 c2.\n           \\<lbrakk>c1 \\<in> C; c2 \\<in> C; c1 \\<noteq> c2\\<rbrakk>\n           \\<Longrightarrow> c1 \\<inter> c2 = {};\n        C \\<noteq> {}; k = enat k1; 0 < k1; finite C;\n        \\<And>c. c \\<in> C \\<Longrightarrow> card c = k1;\n        card (\\<Union> C) = k1 * card C; finite (\\<Union> C)\\<rbrakk>\n       \\<Longrightarrow> icard (\\<Union> C) = enat (k1 * card C)\n 2. \\<And>k1.\n       \\<lbrakk>\\<And>c. c \\<in> C \\<Longrightarrow> icard c = k;\n        \\<And>c1 c2.\n           \\<lbrakk>c1 \\<in> C; c2 \\<in> C; c1 \\<noteq> c2\\<rbrakk>\n           \\<Longrightarrow> c1 \\<inter> c2 = {};\n        C \\<noteq> {}; enat 0 < k; k = enat k1; 0 < k1; infinite C\\<rbrakk>\n       \\<Longrightarrow> icard (\\<Union> C) = k * icard C\n 3. \\<lbrakk>\\<And>c. c \\<in> C \\<Longrightarrow> icard c = k;\n     \\<And>c1 c2.\n        \\<lbrakk>c1 \\<in> C; c2 \\<in> C; c1 \\<noteq> c2\\<rbrakk>\n        \\<Longrightarrow> c1 \\<inter> c2 = {};\n     C \\<noteq> {}; enat 0 < k; k = \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> icard (\\<Union> C) = k * icard C", "apply (simp add: icard_finite)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>k1.\n       \\<lbrakk>\\<And>c. c \\<in> C \\<Longrightarrow> icard c = k;\n        \\<And>c1 c2.\n           \\<lbrakk>c1 \\<in> C; c2 \\<in> C; c1 \\<noteq> c2\\<rbrakk>\n           \\<Longrightarrow> c1 \\<inter> c2 = {};\n        C \\<noteq> {}; enat 0 < k; k = enat k1; 0 < k1; infinite C\\<rbrakk>\n       \\<Longrightarrow> icard (\\<Union> C) = k * icard C\n 2. \\<lbrakk>\\<And>c. c \\<in> C \\<Longrightarrow> icard c = k;\n     \\<And>c1 c2.\n        \\<lbrakk>c1 \\<in> C; c2 \\<in> C; c1 \\<noteq> c2\\<rbrakk>\n        \\<Longrightarrow> c1 \\<inter> c2 = {};\n     C \\<noteq> {}; enat 0 < k; k = \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> icard (\\<Union> C) = k * icard C", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>k1.\n       \\<lbrakk>\\<And>c. c \\<in> C \\<Longrightarrow> icard c = enat k1;\n        \\<And>c1 c2.\n           \\<lbrakk>c1 \\<in> C; c2 \\<in> C; c1 \\<noteq> c2\\<rbrakk>\n           \\<Longrightarrow> c1 \\<inter> c2 = {};\n        C \\<noteq> {}; k = enat k1; 0 < k1; infinite C\\<rbrakk>\n       \\<Longrightarrow> icard (\\<Union> C) = \\<infinity>\n 2. \\<lbrakk>\\<And>c. c \\<in> C \\<Longrightarrow> icard c = k;\n     \\<And>c1 c2.\n        \\<lbrakk>c1 \\<in> C; c2 \\<in> C; c1 \\<noteq> c2\\<rbrakk>\n        \\<Longrightarrow> c1 \\<inter> c2 = {};\n     C \\<noteq> {}; enat 0 < k; k = \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> icard (\\<Union> C) = k * icard C", "apply (rule icard_infinite)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>k1.\n       \\<lbrakk>\\<And>c. c \\<in> C \\<Longrightarrow> icard c = enat k1;\n        \\<And>c1 c2.\n           \\<lbrakk>c1 \\<in> C; c2 \\<in> C; c1 \\<noteq> c2\\<rbrakk>\n           \\<Longrightarrow> c1 \\<inter> c2 = {};\n        C \\<noteq> {}; k = enat k1; 0 < k1; infinite C\\<rbrakk>\n       \\<Longrightarrow> infinite (\\<Union> C)\n 2. \\<lbrakk>\\<And>c. c \\<in> C \\<Longrightarrow> icard c = k;\n     \\<And>c1 c2.\n        \\<lbrakk>c1 \\<in> C; c2 \\<in> C; c1 \\<noteq> c2\\<rbrakk>\n        \\<Longrightarrow> c1 \\<inter> c2 = {};\n     C \\<noteq> {}; enat 0 < k; k = \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> icard (\\<Union> C) = k * icard C", "apply (rule ccontr, simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>k1.\n       \\<lbrakk>\\<And>c. c \\<in> C \\<Longrightarrow> icard c = enat k1;\n        \\<And>c1 c2.\n           \\<lbrakk>c1 \\<in> C; c2 \\<in> C; c1 \\<noteq> c2\\<rbrakk>\n           \\<Longrightarrow> c1 \\<inter> c2 = {};\n        C \\<noteq> {}; k = enat k1; 0 < k1; infinite C;\n        finite (\\<Union> C)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<lbrakk>\\<And>c. c \\<in> C \\<Longrightarrow> icard c = k;\n     \\<And>c1 c2.\n        \\<lbrakk>c1 \\<in> C; c2 \\<in> C; c1 \\<noteq> c2\\<rbrakk>\n        \\<Longrightarrow> c1 \\<inter> c2 = {};\n     C \\<noteq> {}; enat 0 < k; k = \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> icard (\\<Union> C) = k * icard C", "apply (drule finite_UnionD, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>c. c \\<in> C \\<Longrightarrow> icard c = k;\n     \\<And>c1 c2.\n        \\<lbrakk>c1 \\<in> C; c2 \\<in> C; c1 \\<noteq> c2\\<rbrakk>\n        \\<Longrightarrow> c1 \\<inter> c2 = {};\n     C \\<noteq> {}; enat 0 < k; k = \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> icard (\\<Union> C) = k * icard C", "apply (frule icard_not_empty_iff[THEN iffD2])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>c. c \\<in> C \\<Longrightarrow> icard c = k;\n     \\<And>c1 c2.\n        \\<lbrakk>c1 \\<in> C; c2 \\<in> C; c1 \\<noteq> c2\\<rbrakk>\n        \\<Longrightarrow> c1 \\<inter> c2 = {};\n     C \\<noteq> {}; enat 0 < k; k = \\<infinity>; 0 < icard C\\<rbrakk>\n    \\<Longrightarrow> icard (\\<Union> C) = k * icard C", "apply (simp add: icard_infinite_conv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>c. c \\<in> C \\<Longrightarrow> infinite c;\n     \\<And>c1 c2.\n        \\<lbrakk>c1 \\<in> C; c2 \\<in> C; c1 \\<noteq> c2\\<rbrakk>\n        \\<Longrightarrow> c1 \\<inter> c2 = {};\n     C \\<noteq> {}; k = \\<infinity>; enat 0 < icard C\\<rbrakk>\n    \\<Longrightarrow> infinite (\\<Union> C)", "apply (frule not_empty_imp_ex, erule exE, rename_tac c)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c.\n       \\<lbrakk>\\<And>c. c \\<in> C \\<Longrightarrow> infinite c;\n        \\<And>c1 c2.\n           \\<lbrakk>c1 \\<in> C; c2 \\<in> C; c1 \\<noteq> c2\\<rbrakk>\n           \\<Longrightarrow> c1 \\<inter> c2 = {};\n        C \\<noteq> {}; k = \\<infinity>; enat 0 < icard C; c \\<in> C\\<rbrakk>\n       \\<Longrightarrow> infinite (\\<Union> C)", "apply (frule Union_upper)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c.\n       \\<lbrakk>\\<And>c. c \\<in> C \\<Longrightarrow> infinite c;\n        \\<And>c1 c2.\n           \\<lbrakk>c1 \\<in> C; c2 \\<in> C; c1 \\<noteq> c2\\<rbrakk>\n           \\<Longrightarrow> c1 \\<inter> c2 = {};\n        C \\<noteq> {}; k = \\<infinity>; enat 0 < icard C; c \\<in> C;\n        c \\<subseteq> \\<Union> C\\<rbrakk>\n       \\<Longrightarrow> infinite (\\<Union> C)", "apply (rule infinite_super, assumption)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c.\n       \\<lbrakk>\\<And>c. c \\<in> C \\<Longrightarrow> infinite c;\n        \\<And>c1 c2.\n           \\<lbrakk>c1 \\<in> C; c2 \\<in> C; c1 \\<noteq> c2\\<rbrakk>\n           \\<Longrightarrow> c1 \\<inter> c2 = {};\n        C \\<noteq> {}; k = \\<infinity>; enat 0 < icard C; c \\<in> C;\n        c \\<subseteq> \\<Union> C\\<rbrakk>\n       \\<Longrightarrow> infinite c", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma icard_image_le: \"icard (f ` A) \\<le> icard A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. icard (f ` A) \\<le> icard A", "apply (case_tac \"finite A\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. finite A \\<Longrightarrow> icard (f ` A) \\<le> icard A\n 2. infinite A \\<Longrightarrow> icard (f ` A) \\<le> icard A", "apply (simp add: icard_finite card_image_le)"], ["proof (prove)\ngoal (1 subgoal):\n 1. infinite A \\<Longrightarrow> icard (f ` A) \\<le> icard A", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma icard_image: \"inj_on f A \\<Longrightarrow> icard (f ` A) = icard A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on f A \\<Longrightarrow> icard (f ` A) = icard A", "apply (case_tac \"finite A\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>inj_on f A; finite A\\<rbrakk>\n    \\<Longrightarrow> icard (f ` A) = icard A\n 2. \\<lbrakk>inj_on f A; infinite A\\<rbrakk>\n    \\<Longrightarrow> icard (f ` A) = icard A", "apply (simp add: icard_finite card_image)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>inj_on f A; infinite A\\<rbrakk>\n    \\<Longrightarrow> icard (f ` A) = icard A", "apply (simp add: icard_infinite_conv inj_on_imp_infinite_image)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma not_eq_icard_imp_inj_on: \"\\<exists>(f::nat\\<Rightarrow>nat) (A::nat set). icard (f ` A) = icard A \\<and> \\<not> inj_on f A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>f A. icard (f ` A) = icard A \\<and> \\<not> inj_on f A", "apply (rule_tac x=\"\\<lambda>n. (if n = 0 then Suc 0 else n)\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>A.\n       icard ((\\<lambda>n. if n = 0 then Suc 0 else n) ` A) = icard A \\<and>\n       \\<not> inj_on (\\<lambda>n. if n = 0 then Suc 0 else n) A", "apply (rule_tac x=\"{0..}\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. icard ((\\<lambda>n. if n = 0 then Suc 0 else n) ` {0..}) =\n    icard {0..} \\<and>\n    \\<not> inj_on (\\<lambda>n. if n = 0 then Suc 0 else n) {0..}", "apply (rule conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. icard ((\\<lambda>n. if n = 0 then Suc 0 else n) ` {0..}) = icard {0..}\n 2. \\<not> inj_on (\\<lambda>n. if n = 0 then Suc 0 else n) {0..}", "apply (rule subst[of \"{1..}\" \"((\\<lambda>n. if n = 0 then Suc 0 else n) ` {0..})\"])"], ["proof (prove)\ngoal (3 subgoals):\n 1. {1..} = (\\<lambda>n. if n = 0 then Suc 0 else n) ` {0..}\n 2. icard {1..} = icard {0..}\n 3. \\<not> inj_on (\\<lambda>n. if n = 0 then Suc 0 else n) {0..}", "apply (simp add: set_eq_iff)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<forall>x. (Suc 0 \\<le> x) = (x = Suc 0 \\<or> 0 < x)\n 2. icard {1..} = icard {0..}\n 3. \\<not> inj_on (\\<lambda>n. if n = 0 then Suc 0 else n) {0..}", "apply (rule allI, rename_tac n)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>n. (Suc 0 \\<le> n) = (n = Suc 0 \\<or> 0 < n)\n 2. icard {1..} = icard {0..}\n 3. \\<not> inj_on (\\<lambda>n. if n = 0 then Suc 0 else n) {0..}", "apply (case_tac \"n = 0\", simp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>n.\n       n \\<noteq> 0 \\<Longrightarrow>\n       (Suc 0 \\<le> n) = (n = Suc 0 \\<or> 0 < n)\n 2. icard {1..} = icard {0..}\n 3. \\<not> inj_on (\\<lambda>n. if n = 0 then Suc 0 else n) {0..}", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. icard {1..} = icard {0..}\n 2. \\<not> inj_on (\\<lambda>n. if n = 0 then Suc 0 else n) {0..}", "apply (simp only: icard_infinite[OF infinite_atLeast])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> inj_on (\\<lambda>n. if n = 0 then Suc 0 else n) {0..}", "apply (simp add: inj_on_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x.\n       (x = 0 \\<longrightarrow>\n        (\\<exists>y>0. 0 < y \\<longrightarrow> Suc 0 = y)) \\<and>\n       (0 < x \\<longrightarrow> x = Suc 0)", "apply blast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma not_inj_on_iff_eq_icard: \"\\<exists>(f::nat\\<Rightarrow>nat) (A::nat set). \\<not> (inj_on f A = (icard (f ` A) = icard A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>f A. inj_on f A \\<noteq> (icard (f ` A) = icard A)", "by (insert not_eq_icard_imp_inj_on, blast)"], ["", "lemma icard_inj_on_le: \"\\<lbrakk> inj_on f A; f ` A \\<subseteq> B \\<rbrakk> \\<Longrightarrow> icard A \\<le> icard B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>inj_on f A; f ` A \\<subseteq> B\\<rbrakk>\n    \\<Longrightarrow> icard A \\<le> icard B", "apply (case_tac \"finite B\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>inj_on f A; f ` A \\<subseteq> B; finite B\\<rbrakk>\n    \\<Longrightarrow> icard A \\<le> icard B\n 2. \\<lbrakk>inj_on f A; f ` A \\<subseteq> B; infinite B\\<rbrakk>\n    \\<Longrightarrow> icard A \\<le> icard B", "apply (metis icard_image icard_mono)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>inj_on f A; f ` A \\<subseteq> B; infinite B\\<rbrakk>\n    \\<Longrightarrow> icard A \\<le> icard B", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma icard_bij_eq: \"\n  \\<lbrakk> inj_on f A; f ` A \\<subseteq> B; inj_on g B; g ` B \\<subseteq> A \\<rbrakk> \\<Longrightarrow>\n  icard A = icard B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>inj_on f A; f ` A \\<subseteq> B; inj_on g B;\n     g ` B \\<subseteq> A\\<rbrakk>\n    \\<Longrightarrow> icard A = icard B", "by (simp add: order_eq_iff icard_inj_on_le)"], ["", "lemma icard_cartesian_product: \"icard (A \\<times> B) = icard A * icard B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. icard (A \\<times> B) = icard A * icard B", "apply (case_tac \"A = {} \\<or> B = {}\", fastforce)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (A = {} \\<or> B = {}) \\<Longrightarrow>\n    icard (A \\<times> B) = icard A * icard B", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<noteq> {}; B \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> icard (A \\<times> B) = icard A * icard B", "apply (case_tac \"finite A \\<and> finite B\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>A \\<noteq> {}; B \\<noteq> {}; finite A \\<and> finite B\\<rbrakk>\n    \\<Longrightarrow> icard (A \\<times> B) = icard A * icard B\n 2. \\<lbrakk>A \\<noteq> {}; B \\<noteq> {};\n     \\<not> (finite A \\<and> finite B)\\<rbrakk>\n    \\<Longrightarrow> icard (A \\<times> B) = icard A * icard B", "apply (simp add: icard_finite)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<noteq> {}; B \\<noteq> {};\n     \\<not> (finite A \\<and> finite B)\\<rbrakk>\n    \\<Longrightarrow> icard (A \\<times> B) = icard A * icard B", "apply (simp only: de_Morgan_conj, erule disjE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>A \\<noteq> {}; B \\<noteq> {}; infinite A\\<rbrakk>\n    \\<Longrightarrow> icard (A \\<times> B) = icard A * icard B\n 2. \\<lbrakk>A \\<noteq> {}; B \\<noteq> {}; infinite B\\<rbrakk>\n    \\<Longrightarrow> icard (A \\<times> B) = icard A * icard B", "apply (simp_all add:\n  icard_not_empty_iff[symmetric]\n  cartesian_product_infiniteL_imp_infinite cartesian_product_infiniteR_imp_infinite)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma icard_cartesian_product_singleton: \"icard ({x} \\<times> A) = icard A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. icard ({x} \\<times> A) = icard A", "by (simp add: icard_cartesian_product mult_eSuc)"], ["", "lemma icard_cartesian_product_singleton_right: \"icard (A \\<times> {x}) = icard A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. icard (A \\<times> {x}) = icard A", "by (simp add: icard_cartesian_product mult_eSuc_right)"], ["", "lemma\n  icard_lessThan: \"icard {..<u} = enat u\" and\n  icard_atMost: \"icard {..u} = enat (Suc u)\" and\n  icard_atLeastLessThan: \"icard {l..<u} = enat (u - l)\" and\n  icard_atLeastAtMost: \"icard {l..u} = enat (Suc u - l)\" and\n  icard_greaterThanAtMost: \"icard {l<..u} = enat (u - l)\" and\n  icard_greaterThanLessThan: \"icard {l<..<u} = enat (u - Suc l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (icard {..<u} = enat u &&&\n     icard {..u} = enat (Suc u) &&& icard {l..<u} = enat (u - l)) &&&\n    icard {l..u} = enat (Suc u - l) &&&\n    icard {l<..u} = enat (u - l) &&& icard {l<..<u} = enat (u - Suc l)", "by (simp_all add: icard_finite)"], ["", "lemma icard_atLeast: \"icard {(u::nat)..} = \\<infinity>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. icard {u..} = \\<infinity>", "by (simp add: infinite_atLeast)"], ["", "lemma icard_greaterThan: \"icard {(u::nat)<..} = \\<infinity>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. icard {u<..} = \\<infinity>", "by (simp add: infinite_greaterThan)"], ["", "lemma\n  icard_atLeastZeroLessThan_int: \"icard {0..<u} = enat (nat u)\" and\n  icard_atLeastLessThan_int: \"icard {l..<u} = enat (nat (u - l))\" and\n  icard_atLeastAtMost_int: \"icard {l..u} = enat (nat (u - l + 1))\" and\n  icard_greaterThanAtMost_int: \"icard {l<..u} = enat (nat (u - l))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (icard {0..<u} = enat (nat u) &&&\n     icard {l..<u} = enat (nat (u - l))) &&&\n    icard {l..u} = enat (nat (u - l + 1)) &&&\n    icard {l<..u} = enat (nat (u - l))", "by (simp_all add: icard_finite)"], ["", "lemma icard_atLeast_int: \"icard {(u::int)..} = \\<infinity>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. icard {u..} = \\<infinity>", "by (simp add: infinite_atLeast_int)"], ["", "lemma icard_greaterThan_int: \"icard {(u::int)<..} = \\<infinity>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. icard {u<..} = \\<infinity>", "by (simp add: infinite_greaterThan_int)"], ["", "lemma icard_atMost_int: \"icard {..(u::int)} = \\<infinity>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. icard {..u} = \\<infinity>", "by (simp add: infinite_atMost_int)"], ["", "lemma icard_lessThan_int: \"icard {..<(u::int)} = \\<infinity>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. icard {..<u} = \\<infinity>", "by (simp add: infinite_lessThan_int)"], ["", "end"]]}