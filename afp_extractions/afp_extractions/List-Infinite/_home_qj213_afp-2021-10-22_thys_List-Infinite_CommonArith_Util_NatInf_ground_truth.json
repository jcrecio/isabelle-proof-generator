{"file_name": "/home/qj213/afp-2021-10-22/thys/List-Infinite/CommonArith/Util_NatInf.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/List-Infinite", "problem_names": ["lemmas enat_arith_defs =\n  zero_enat_def one_enat_def\n  plus_enat_def diff_enat_def times_enat_def div_enat_def mod_enat_def", "lemmas ineq0_conv_enat[simp] = i0_less[symmetric, unfolded zero_enat_def]", "lemmas iless_eSuc0_enat[simp] = iless_eSuc0[unfolded zero_enat_def]", "lemma diff_eq_conv_nat: \"(x - y = (z::nat)) = (if y < x then x = y + z else z = 0)\"", "lemma idiff_eq_conv: \"\n  (x - y = (z::enat)) =\n  (if y < x then x = y + z else if x \\<noteq> \\<infinity> then z = 0 else z = \\<infinity>)\"", "lemmas idiff_eq_conv_enat = idiff_eq_conv[unfolded zero_enat_def]", "lemma less_eq_idiff_eq_sum: \"y \\<le> (x::enat) \\<Longrightarrow> (z \\<le> x - y) = (z + y \\<le> x)\"", "lemma eSuc_pred: \"0 < n \\<Longrightarrow> eSuc (n - eSuc 0) = n\"", "lemmas eSuc_pred_enat = eSuc_pred[unfolded zero_enat_def]", "lemmas iadd_0_enat[simp] = add_0_left[where 'a = enat, unfolded zero_enat_def]", "lemmas iadd_0_right_enat[simp] = add_0_right[where 'a=enat, unfolded zero_enat_def]", "lemma ile_add1: \"(n::enat) \\<le> n + m\"", "lemma ile_add2: \"(n::enat) \\<le> m + n\"", "lemma iadd_iless_mono: \"\\<lbrakk> (i::enat) < j; k < l \\<rbrakk> \\<Longrightarrow> i + k < j + l\"", "lemma trans_ile_iadd1: \"i \\<le> (j::enat) \\<Longrightarrow> i \\<le> j + m\"", "lemma trans_ile_iadd2: \"i \\<le> (j::enat) \\<Longrightarrow> i \\<le> m + j\"", "lemma trans_iless_iadd1: \"i < (j::enat) \\<Longrightarrow> i < j + m\"", "lemma trans_iless_iadd2: \"i < (j::enat) \\<Longrightarrow> i < m + j\"", "lemma iadd_ileD1: \"m + k \\<le> (n::enat) \\<Longrightarrow> m \\<le> n\"", "lemma iadd_ileD2: \"m + k \\<le> (n::enat) \\<Longrightarrow> k \\<le> n\"", "lemma idiff_ile_mono: \"m \\<le> (n::enat) \\<Longrightarrow> m - l \\<le> n - l\"", "lemma idiff_ile_mono2: \"m \\<le> (n::enat) \\<Longrightarrow> l - n \\<le> l - m\"", "lemma idiff_iless_mono: \"\\<lbrakk> m < (n::enat); l \\<le> m \\<rbrakk> \\<Longrightarrow> m - l < n - l\"", "lemma idiff_iless_mono2: \"\\<lbrakk> m < (n::enat); m < l \\<rbrakk> \\<Longrightarrow> l - n \\<le> l - m\"", "lemmas imult_infinity_enat[simp] = imult_infinity[unfolded zero_enat_def]", "lemmas imult_infinity_right_enat[simp] = imult_infinity_right[unfolded zero_enat_def]", "lemma idiv_enat_enat[simp, code]: \"enat a div enat b = enat (a div b)\"", "lemma idiv_infinity: \"0 < n \\<Longrightarrow> (\\<infinity>::enat) div n = \\<infinity>\"", "lemmas idiv_infinity_enat[simp] = idiv_infinity[unfolded zero_enat_def]", "lemma idiv_infinity_right[simp]: \"n \\<noteq> \\<infinity> \\<Longrightarrow> n div (\\<infinity>::enat) = 0\"", "lemma idiv_infinity_if: \"n div \\<infinity> = (if n = \\<infinity> then \\<infinity> else 0::enat)\"", "lemmas idiv_infinity_if_enat = idiv_infinity_if[unfolded zero_enat_def]", "lemmas imult_0_enat[simp] = mult_zero_left[where 'a=enat,unfolded zero_enat_def]", "lemmas imult_0_right_enat[simp] = mult_zero_right[where 'a=enat,unfolded zero_enat_def]", "lemmas imult_is_0_enat = imult_is_0[unfolded zero_enat_def]", "lemmas enat_0_less_mult_iff_enat = enat_0_less_mult_iff[unfolded zero_enat_def]", "lemma imult_infinity_if: \"\\<infinity> * n = (if n = 0 then 0 else \\<infinity>::enat)\"", "lemma imult_infinity_right_if: \"n * \\<infinity> = (if n = 0 then 0 else \\<infinity>::enat)\"", "lemmas imult_infinity_if_enat = imult_infinity_if[unfolded zero_enat_def]", "lemmas imult_infinity_right_if_enat = imult_infinity_right_if[unfolded zero_enat_def]", "lemmas imult_is_infinity_enat = imult_is_infinity[unfolded zero_enat_def]", "lemma idiv_by_0: \"(a::enat) div 0 = 0\"", "lemmas idiv_by_0_enat[simp, code] = idiv_by_0[unfolded zero_enat_def]", "lemma idiv_0: \"0 div (a::enat) = 0\"", "lemmas idiv_0_enat[simp, code] = idiv_0[unfolded zero_enat_def]", "lemma imod_by_0: \"(a::enat) mod 0 = a\"", "lemmas imod_by_0_enat[simp, code] = imod_by_0[unfolded zero_enat_def]", "lemma imod_0: \"0 mod (a::enat) = 0\"", "lemmas imod_0_enat[simp, code] = imod_0[unfolded zero_enat_def]", "lemma imod_enat_enat[simp, code]: \"enat a mod enat b = enat (a mod b)\"", "lemma imod_infinity[simp, code]: \"\\<infinity> mod n = (\\<infinity>::enat)\"", "lemma imod_infinity_right[simp, code]: \"n mod (\\<infinity>::enat) = n\"", "lemma idiv_self: \"\\<lbrakk> 0 < (n::enat); n \\<noteq> \\<infinity> \\<rbrakk> \\<Longrightarrow> n div n = 1\"", "lemma imod_self: \"n \\<noteq> \\<infinity> \\<Longrightarrow> (n::enat) mod n = 0\"", "lemma idiv_iless: \"m < (n::enat) \\<Longrightarrow> m div n = 0\"", "lemma imod_iless: \"m < (n::enat) \\<Longrightarrow> m mod n = m\"", "lemma imod_iless_divisor: \"\\<lbrakk> 0 < (n::enat); m \\<noteq> \\<infinity> \\<rbrakk>  \\<Longrightarrow> m mod n < n\"", "lemma imod_ile_dividend: \"(m::enat) mod n \\<le> m\"", "lemma idiv_ile_dividend: \"(m::enat) div n \\<le> m\"", "lemma idiv_imult2_eq: \"(a::enat) div (b * c) = a div b div c\"", "lemma imult_ile_mono: \"\\<lbrakk> (i::enat) \\<le> j; k \\<le> l \\<rbrakk> \\<Longrightarrow> i * k \\<le> j * l\"", "lemma imult_ile_mono1: \"(i::enat) \\<le> j \\<Longrightarrow> i * k \\<le> j * k\"", "lemma imult_ile_mono2: \"(i::enat) \\<le> j \\<Longrightarrow> k * i \\<le> k * j\"", "lemma imult_iless_mono1: \"\\<lbrakk> (i::enat) < j; 0 < k; k \\<noteq> \\<infinity> \\<rbrakk> \\<Longrightarrow> i * k \\<le> j * k\"", "lemma imult_iless_mono2: \"\\<lbrakk> (i::enat) < j; 0 < k; k \\<noteq> \\<infinity> \\<rbrakk> \\<Longrightarrow> k * i \\<le> k * j\"", "lemma imod_1: \"(enat m) mod eSuc 0 = 0\"", "lemmas imod_1_enat[simp, code] = imod_1[unfolded zero_enat_def]", "lemma imod_iadd_self2: \"(m + enat n) mod (enat n) = m mod (enat n)\"", "lemma imod_iadd_self1: \"(enat n + m) mod (enat n) = m mod (enat n)\"", "lemma idiv_imod_equality: \"(m::enat) div n * n + m mod n + k = m + k\"", "lemma imod_idiv_equality: \"(m::enat) div n * n + m mod n = m\"", "lemma idiv_ile_mono: \"m \\<le> (n::enat) \\<Longrightarrow> m div k \\<le> n div k\"", "lemma idiv_ile_mono2: \"\\<lbrakk> 0 < m; m \\<le> (n::enat) \\<rbrakk> \\<Longrightarrow> k div n \\<le> k div m\""], "translations": [["", "lemmas enat_arith_defs =\n  zero_enat_def one_enat_def\n  plus_enat_def diff_enat_def times_enat_def div_enat_def mod_enat_def"], ["", "declare zero_enat_def[simp]"], ["", "lemmas ineq0_conv_enat[simp] = i0_less[symmetric, unfolded zero_enat_def]"], ["", "lemmas iless_eSuc0_enat[simp] = iless_eSuc0[unfolded zero_enat_def]"], ["", "subsubsection \\<open>Addition, difference, order\\<close>"], ["", "lemma diff_eq_conv_nat: \"(x - y = (z::nat)) = (if y < x then x = y + z else z = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x - y = z) = (if y < x then x = y + z else z = 0)", "by auto"], ["", "lemma idiff_eq_conv: \"\n  (x - y = (z::enat)) =\n  (if y < x then x = y + z else if x \\<noteq> \\<infinity> then z = 0 else z = \\<infinity>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x - y = z) =\n    (if y < x then x = y + z\n     else if x \\<noteq> \\<infinity> then z = 0 else z = \\<infinity>)", "by (case_tac x, case_tac y, case_tac z, auto, case_tac z, auto)"], ["", "lemmas idiff_eq_conv_enat = idiff_eq_conv[unfolded zero_enat_def]"], ["", "lemma less_eq_idiff_eq_sum: \"y \\<le> (x::enat) \\<Longrightarrow> (z \\<le> x - y) = (z + y \\<le> x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<le> x \\<Longrightarrow> (z \\<le> x - y) = (z + y \\<le> x)", "by (case_tac x, case_tac y, case_tac z, fastforce+)"], ["", "lemma eSuc_pred: \"0 < n \\<Longrightarrow> eSuc (n - eSuc 0) = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < n \\<Longrightarrow> eSuc (n - eSuc 0) = n", "apply (case_tac n)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>nat.\n       \\<lbrakk>0 < n; n = enat nat\\<rbrakk>\n       \\<Longrightarrow> eSuc (n - eSuc 0) = n\n 2. \\<lbrakk>0 < n; n = \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> eSuc (n - eSuc 0) = n", "apply (simp add: eSuc_enat)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemmas eSuc_pred_enat = eSuc_pred[unfolded zero_enat_def]"], ["", "lemmas iadd_0_enat[simp] = add_0_left[where 'a = enat, unfolded zero_enat_def]"], ["", "lemmas iadd_0_right_enat[simp] = add_0_right[where 'a=enat, unfolded zero_enat_def]"], ["", "lemma ile_add1: \"(n::enat) \\<le> n + m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<le> n + m", "by (case_tac m, case_tac n, simp_all)"], ["", "lemma ile_add2: \"(n::enat) \\<le> m + n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<le> m + n", "by (simp only: add.commute[of m] ile_add1)"], ["", "lemma iadd_iless_mono: \"\\<lbrakk> (i::enat) < j; k < l \\<rbrakk> \\<Longrightarrow> i + k < j + l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < j; k < l\\<rbrakk> \\<Longrightarrow> i + k < j + l", "by (case_tac i, case_tac k, case_tac j, case_tac l, simp_all)"], ["", "lemma trans_ile_iadd1: \"i \\<le> (j::enat) \\<Longrightarrow> i \\<le> j + m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<le> j \\<Longrightarrow> i \\<le> j + m", "by (rule order_trans[OF _ ile_add1])"], ["", "lemma trans_ile_iadd2: \"i \\<le> (j::enat) \\<Longrightarrow> i \\<le> m + j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<le> j \\<Longrightarrow> i \\<le> m + j", "by (rule order_trans[OF _ ile_add2])"], ["", "lemma trans_iless_iadd1: \"i < (j::enat) \\<Longrightarrow> i < j + m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < j \\<Longrightarrow> i < j + m", "by (rule order_less_le_trans[OF _ ile_add1])"], ["", "lemma trans_iless_iadd2: \"i < (j::enat) \\<Longrightarrow> i < m + j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < j \\<Longrightarrow> i < m + j", "by (rule order_less_le_trans[OF _ ile_add2])"], ["", "lemma iadd_ileD1: \"m + k \\<le> (n::enat) \\<Longrightarrow> m \\<le> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m + k \\<le> n \\<Longrightarrow> m \\<le> n", "by (case_tac m, case_tac n, case_tac k, simp_all)"], ["", "lemma iadd_ileD2: \"m + k \\<le> (n::enat) \\<Longrightarrow> k \\<le> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m + k \\<le> n \\<Longrightarrow> k \\<le> n", "by (rule iadd_ileD1, simp only: add.commute[of m])"], ["", "lemma idiff_ile_mono: \"m \\<le> (n::enat) \\<Longrightarrow> m - l \\<le> n - l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<le> n \\<Longrightarrow> m - l \\<le> n - l", "by (case_tac m, case_tac n, case_tac l, simp_all)"], ["", "lemma idiff_ile_mono2: \"m \\<le> (n::enat) \\<Longrightarrow> l - n \\<le> l - m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<le> n \\<Longrightarrow> l - n \\<le> l - m", "by (case_tac m, case_tac n, case_tac l, simp_all, case_tac l, simp_all)"], ["", "lemma idiff_iless_mono: \"\\<lbrakk> m < (n::enat); l \\<le> m \\<rbrakk> \\<Longrightarrow> m - l < n - l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>m < n; l \\<le> m\\<rbrakk> \\<Longrightarrow> m - l < n - l", "by (case_tac m, case_tac n, case_tac l, simp_all, case_tac l, simp_all)"], ["", "lemma idiff_iless_mono2: \"\\<lbrakk> m < (n::enat); m < l \\<rbrakk> \\<Longrightarrow> l - n \\<le> l - m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>m < n; m < l\\<rbrakk> \\<Longrightarrow> l - n \\<le> l - m", "by (case_tac m, case_tac n, case_tac l, simp_all, case_tac l, simp_all)"], ["", "subsubsection \\<open>Multiplication and division\\<close>"], ["", "lemmas imult_infinity_enat[simp] = imult_infinity[unfolded zero_enat_def]"], ["", "lemmas imult_infinity_right_enat[simp] = imult_infinity_right[unfolded zero_enat_def]"], ["", "lemma idiv_enat_enat[simp, code]: \"enat a div enat b = enat (a div b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. enat a div enat b = enat (a div b)", "unfolding div_enat_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case enat a of\n     enat x \\<Rightarrow>\n       case enat b of enat y \\<Rightarrow> enat (x div y)\n       | \\<infinity> \\<Rightarrow> 0\n     | \\<infinity> \\<Rightarrow>\n         case enat b of enat 0 \\<Rightarrow> 0\n         | enat (Suc n) \\<Rightarrow> \\<infinity>\n         | \\<infinity> \\<Rightarrow> \\<infinity>) =\n    enat (a div b)", "by simp"], ["", "lemma idiv_infinity: \"0 < n \\<Longrightarrow> (\\<infinity>::enat) div n = \\<infinity>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < n \\<Longrightarrow> \\<infinity> div n = \\<infinity>", "unfolding div_enat_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < n \\<Longrightarrow>\n    (case \\<infinity> of\n     enat x \\<Rightarrow>\n       case n of enat y \\<Rightarrow> enat (x div y)\n       | \\<infinity> \\<Rightarrow> 0\n     | \\<infinity> \\<Rightarrow>\n         case n of enat 0 \\<Rightarrow> 0\n         | enat (Suc n) \\<Rightarrow> \\<infinity>\n         | \\<infinity> \\<Rightarrow> \\<infinity>) =\n    \\<infinity>", "apply (case_tac n, simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>0 < nat; n = enat nat\\<rbrakk>\n       \\<Longrightarrow> (case nat of 0 \\<Rightarrow> 0\n                          | Suc n \\<Rightarrow> \\<infinity>) =\n                         \\<infinity>", "apply (rename_tac n1, case_tac n1, simp_all)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemmas idiv_infinity_enat[simp] = idiv_infinity[unfolded zero_enat_def]"], ["", "lemma idiv_infinity_right[simp]: \"n \\<noteq> \\<infinity> \\<Longrightarrow> n div (\\<infinity>::enat) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<noteq> \\<infinity> \\<Longrightarrow> n div \\<infinity> = 0", "unfolding div_enat_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<noteq> \\<infinity> \\<Longrightarrow>\n    (case n of\n     enat x \\<Rightarrow>\n       case \\<infinity> of enat y \\<Rightarrow> enat (x div y)\n       | \\<infinity> \\<Rightarrow> 0\n     | \\<infinity> \\<Rightarrow>\n         case \\<infinity> of enat 0 \\<Rightarrow> 0\n         | enat (Suc n) \\<Rightarrow> \\<infinity>\n         | \\<infinity> \\<Rightarrow> \\<infinity>) =\n    0", "by (case_tac n, simp_all)"], ["", "lemma idiv_infinity_if: \"n div \\<infinity> = (if n = \\<infinity> then \\<infinity> else 0::enat)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n div \\<infinity> = (if n = \\<infinity> then \\<infinity> else 0)", "unfolding div_enat_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case n of\n     enat x \\<Rightarrow>\n       case \\<infinity> of enat y \\<Rightarrow> enat (x div y)\n       | \\<infinity> \\<Rightarrow> 0\n     | \\<infinity> \\<Rightarrow>\n         case \\<infinity> of enat 0 \\<Rightarrow> 0\n         | enat (Suc n) \\<Rightarrow> \\<infinity>\n         | \\<infinity> \\<Rightarrow> \\<infinity>) =\n    (if n = \\<infinity> then \\<infinity> else 0)", "by (case_tac n, simp_all)"], ["", "lemmas idiv_infinity_if_enat = idiv_infinity_if[unfolded zero_enat_def]"], ["", "lemmas imult_0_enat[simp] = mult_zero_left[where 'a=enat,unfolded zero_enat_def]"], ["", "lemmas imult_0_right_enat[simp] = mult_zero_right[where 'a=enat,unfolded zero_enat_def]"], ["", "lemmas imult_is_0_enat = imult_is_0[unfolded zero_enat_def]"], ["", "lemmas enat_0_less_mult_iff_enat = enat_0_less_mult_iff[unfolded zero_enat_def]"], ["", "lemma imult_infinity_if: \"\\<infinity> * n = (if n = 0 then 0 else \\<infinity>::enat)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<infinity> * n = (if n = 0 then 0 else \\<infinity>)", "by (case_tac n, simp_all)"], ["", "lemma imult_infinity_right_if: \"n * \\<infinity> = (if n = 0 then 0 else \\<infinity>::enat)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n * \\<infinity> = (if n = 0 then 0 else \\<infinity>)", "by (case_tac n, simp_all)"], ["", "lemmas imult_infinity_if_enat = imult_infinity_if[unfolded zero_enat_def]"], ["", "lemmas imult_infinity_right_if_enat = imult_infinity_right_if[unfolded zero_enat_def]"], ["", "lemmas imult_is_infinity_enat = imult_is_infinity[unfolded zero_enat_def]"], ["", "lemma idiv_by_0: \"(a::enat) div 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a div 0 = 0", "unfolding div_enat_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case a of\n     enat x \\<Rightarrow>\n       case 0 of enat y \\<Rightarrow> enat (x div y)\n       | \\<infinity> \\<Rightarrow> 0\n     | \\<infinity> \\<Rightarrow>\n         case 0 of enat 0 \\<Rightarrow> 0\n         | enat (Suc n) \\<Rightarrow> \\<infinity>\n         | \\<infinity> \\<Rightarrow> \\<infinity>) =\n    0", "by (case_tac a, simp_all)"], ["", "lemmas idiv_by_0_enat[simp, code] = idiv_by_0[unfolded zero_enat_def]"], ["", "lemma idiv_0: \"0 div (a::enat) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 div a = 0", "unfolding div_enat_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case 0 of\n     enat x \\<Rightarrow>\n       case a of enat y \\<Rightarrow> enat (x div y)\n       | \\<infinity> \\<Rightarrow> 0\n     | \\<infinity> \\<Rightarrow>\n         case a of enat 0 \\<Rightarrow> 0\n         | enat (Suc n) \\<Rightarrow> \\<infinity>\n         | \\<infinity> \\<Rightarrow> \\<infinity>) =\n    0", "by (case_tac a, simp_all)"], ["", "lemmas idiv_0_enat[simp, code] = idiv_0[unfolded zero_enat_def]"], ["", "lemma imod_by_0: \"(a::enat) mod 0 = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a mod 0 = a", "unfolding mod_enat_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case a of\n     enat x \\<Rightarrow>\n       case 0 of enat y \\<Rightarrow> enat (x mod y)\n       | \\<infinity> \\<Rightarrow> a\n     | \\<infinity> \\<Rightarrow> \\<infinity>) =\n    a", "by (case_tac a, simp_all)"], ["", "lemmas imod_by_0_enat[simp, code] = imod_by_0[unfolded zero_enat_def]"], ["", "lemma imod_0: \"0 mod (a::enat) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 mod a = 0", "unfolding mod_enat_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case 0 of\n     enat x \\<Rightarrow>\n       case a of enat y \\<Rightarrow> enat (x mod y)\n       | \\<infinity> \\<Rightarrow> 0\n     | \\<infinity> \\<Rightarrow> \\<infinity>) =\n    0", "by (case_tac a, simp_all)"], ["", "lemmas imod_0_enat[simp, code] = imod_0[unfolded zero_enat_def]"], ["", "lemma imod_enat_enat[simp, code]: \"enat a mod enat b = enat (a mod b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. enat a mod enat b = enat (a mod b)", "unfolding mod_enat_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case enat a of\n     enat x \\<Rightarrow>\n       case enat b of enat y \\<Rightarrow> enat (x mod y)\n       | \\<infinity> \\<Rightarrow> enat a\n     | \\<infinity> \\<Rightarrow> \\<infinity>) =\n    enat (a mod b)", "by simp"], ["", "lemma imod_infinity[simp, code]: \"\\<infinity> mod n = (\\<infinity>::enat)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<infinity> mod n = \\<infinity>", "unfolding mod_enat_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case \\<infinity> of\n     enat x \\<Rightarrow>\n       case n of enat y \\<Rightarrow> enat (x mod y)\n       | \\<infinity> \\<Rightarrow> \\<infinity>\n     | \\<infinity> \\<Rightarrow> \\<infinity>) =\n    \\<infinity>", "by simp"], ["", "lemma imod_infinity_right[simp, code]: \"n mod (\\<infinity>::enat) = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n mod \\<infinity> = n", "unfolding mod_enat_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case n of\n     enat x \\<Rightarrow>\n       case \\<infinity> of enat y \\<Rightarrow> enat (x mod y)\n       | \\<infinity> \\<Rightarrow> n\n     | \\<infinity> \\<Rightarrow> \\<infinity>) =\n    n", "by (case_tac n) simp_all"], ["", "lemma idiv_self: \"\\<lbrakk> 0 < (n::enat); n \\<noteq> \\<infinity> \\<rbrakk> \\<Longrightarrow> n div n = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < n; n \\<noteq> \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> n div n = 1", "by (case_tac n, simp_all add: one_enat_def)"], ["", "lemma imod_self: \"n \\<noteq> \\<infinity> \\<Longrightarrow> (n::enat) mod n = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<noteq> \\<infinity> \\<Longrightarrow> n mod n = 0", "by (case_tac n, simp_all)"], ["", "lemma idiv_iless: \"m < (n::enat) \\<Longrightarrow> m div n = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m < n \\<Longrightarrow> m div n = 0", "by (case_tac m, simp_all) (case_tac n, simp_all)"], ["", "lemma imod_iless: \"m < (n::enat) \\<Longrightarrow> m mod n = m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m < n \\<Longrightarrow> m mod n = m", "by (case_tac m, simp_all) (case_tac n, simp_all)"], ["", "lemma imod_iless_divisor: \"\\<lbrakk> 0 < (n::enat); m \\<noteq> \\<infinity> \\<rbrakk>  \\<Longrightarrow> m mod n < n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < n; m \\<noteq> \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> m mod n < n", "by (case_tac m, simp_all) (case_tac n, simp_all)"], ["", "lemma imod_ile_dividend: \"(m::enat) mod n \\<le> m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m mod n \\<le> m", "by (case_tac m, simp_all) (case_tac n, simp_all)"], ["", "lemma idiv_ile_dividend: \"(m::enat) div n \\<le> m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m div n \\<le> m", "by (case_tac m, simp_all) (case_tac n, simp_all)"], ["", "lemma idiv_imult2_eq: \"(a::enat) div (b * c) = a div b div c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a div (b * c) = a div b div c", "apply (case_tac a, case_tac b, case_tac c, simp_all add: div_mult2_eq)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>nat.\n       \\<lbrakk>a = enat nat; b = \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> enat nat div (\\<infinity> * c) = enat 0\n 2. a = \\<infinity> \\<Longrightarrow>\n    \\<infinity> div (b * c) = \\<infinity> div b div c", "apply (simp add: imult_infinity_if)"], ["proof (prove)\ngoal (1 subgoal):\n 1. a = \\<infinity> \\<Longrightarrow>\n    \\<infinity> div (b * c) = \\<infinity> div b div c", "apply (case_tac \"b = 0\", simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a = \\<infinity>; b \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> \\<infinity> div (b * c) = \\<infinity> div b div c", "apply (case_tac \"c = 0\", simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a = \\<infinity>; b \\<noteq> 0; c \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> \\<infinity> div (b * c) = \\<infinity> div b div c", "apply (simp add: idiv_infinity[OF enat_0_less_mult_iff[THEN iffD2]])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma imult_ile_mono: \"\\<lbrakk> (i::enat) \\<le> j; k \\<le> l \\<rbrakk> \\<Longrightarrow> i * k \\<le> j * l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<le> j; k \\<le> l\\<rbrakk>\n    \\<Longrightarrow> i * k \\<le> j * l", "apply (case_tac i, case_tac j, case_tac k, case_tac l, simp_all add: mult_le_mono)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>nat.\n       \\<lbrakk>k \\<le> l; i = enat nat; j = \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> enat nat * k \\<le> \\<infinity> * l\n 2. \\<lbrakk>j = \\<infinity>; k \\<le> l; i = \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> \\<infinity> * k \\<le> \\<infinity> * l", "apply (case_tac k, case_tac l, simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>j = \\<infinity>; k \\<le> l; i = \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> \\<infinity> * k \\<le> \\<infinity> * l", "apply (case_tac k, case_tac l, simp_all)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma imult_ile_mono1: \"(i::enat) \\<le> j \\<Longrightarrow> i * k \\<le> j * k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<le> j \\<Longrightarrow> i * k \\<le> j * k", "by (rule imult_ile_mono[OF _ order_refl])"], ["", "lemma imult_ile_mono2: \"(i::enat) \\<le> j \\<Longrightarrow> k * i \\<le> k * j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<le> j \\<Longrightarrow> k * i \\<le> k * j", "by (rule imult_ile_mono[OF order_refl])"], ["", "lemma imult_iless_mono1: \"\\<lbrakk> (i::enat) < j; 0 < k; k \\<noteq> \\<infinity> \\<rbrakk> \\<Longrightarrow> i * k \\<le> j * k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < j; 0 < k; k \\<noteq> \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> i * k \\<le> j * k", "by (case_tac i, case_tac j, case_tac k, simp_all)"], ["", "lemma imult_iless_mono2: \"\\<lbrakk> (i::enat) < j; 0 < k; k \\<noteq> \\<infinity> \\<rbrakk> \\<Longrightarrow> k * i \\<le> k * j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < j; 0 < k; k \\<noteq> \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> k * i \\<le> k * j", "by (simp only: mult.commute[of k], rule imult_iless_mono1)"], ["", "lemma imod_1: \"(enat m) mod eSuc 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. enat m mod eSuc 0 = 0", "by (simp add: eSuc_enat)"], ["", "lemmas imod_1_enat[simp, code] = imod_1[unfolded zero_enat_def]"], ["", "lemma imod_iadd_self2: \"(m + enat n) mod (enat n) = m mod (enat n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (m + enat n) mod enat n = m mod enat n", "by (case_tac m, simp_all)"], ["", "lemma imod_iadd_self1: \"(enat n + m) mod (enat n) = m mod (enat n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (enat n + m) mod enat n = m mod enat n", "by (simp only: add.commute[of _ m] imod_iadd_self2)"], ["", "lemma idiv_imod_equality: \"(m::enat) div n * n + m mod n + k = m + k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m div n * n + m mod n + k = m + k", "by (case_tac m, simp_all) (case_tac n, simp_all)"], ["", "lemma imod_idiv_equality: \"(m::enat) div n * n + m mod n = m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m div n * n + m mod n = m", "by (insert idiv_imod_equality[of m n 0], simp)"], ["", "lemma idiv_ile_mono: \"m \\<le> (n::enat) \\<Longrightarrow> m div k \\<le> n div k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<le> n \\<Longrightarrow> m div k \\<le> n div k", "apply (case_tac \"k = 0\", simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>m \\<le> n; k \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> m div k \\<le> n div k", "apply (case_tac m, case_tac k, simp_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>nat nata.\n       \\<lbrakk>enat nat \\<le> n; 0 < nata; m = enat nat;\n        k = enat nata\\<rbrakk>\n       \\<Longrightarrow> enat (nat div nata) \\<le> n div enat nata\n 2. \\<And>nat.\n       \\<lbrakk>enat nat \\<le> n; m = enat nat; k = \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> enat 0 \\<le> n div \\<infinity>", "apply (case_tac n)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>nat nata natb.\n       \\<lbrakk>enat nat \\<le> n; 0 < nata; m = enat nat; k = enat nata;\n        n = enat natb\\<rbrakk>\n       \\<Longrightarrow> enat (nat div nata) \\<le> n div enat nata\n 2. \\<And>nat nata.\n       \\<lbrakk>enat nat \\<le> n; 0 < nata; m = enat nat; k = enat nata;\n        n = \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> enat (nat div nata) \\<le> n div enat nata\n 3. \\<And>nat.\n       \\<lbrakk>enat nat \\<le> n; m = enat nat; k = \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> enat 0 \\<le> n div \\<infinity>", "apply (simp add: div_le_mono)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>nat nata.\n       \\<lbrakk>enat nat \\<le> n; 0 < nata; m = enat nat; k = enat nata;\n        n = \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> enat (nat div nata) \\<le> n div enat nata\n 2. \\<And>nat.\n       \\<lbrakk>enat nat \\<le> n; m = enat nat; k = \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> enat 0 \\<le> n div \\<infinity>", "apply (simp add: idiv_infinity)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>enat nat \\<le> n; m = enat nat; k = \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> enat 0 \\<le> n div \\<infinity>", "apply (simp add: i0_lb[unfolded zero_enat_def])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma idiv_ile_mono2: \"\\<lbrakk> 0 < m; m \\<le> (n::enat) \\<rbrakk> \\<Longrightarrow> k div n \\<le> k div m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < m; m \\<le> n\\<rbrakk>\n    \\<Longrightarrow> k div n \\<le> k div m", "apply (case_tac \"n = 0\", simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < m; m \\<le> n; n \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> k div n \\<le> k div m", "apply (case_tac m, case_tac k, simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat nata.\n       \\<lbrakk>0 < nat; enat nat \\<le> n; enat 0 < n; m = enat nat;\n        k = enat nata\\<rbrakk>\n       \\<Longrightarrow> enat nata div n \\<le> enat (nata div nat)", "apply (case_tac n)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>nat nata natb.\n       \\<lbrakk>0 < nat; enat nat \\<le> n; enat 0 < n; m = enat nat;\n        k = enat nata; n = enat natb\\<rbrakk>\n       \\<Longrightarrow> enat nata div n \\<le> enat (nata div nat)\n 2. \\<And>nat nata.\n       \\<lbrakk>0 < nat; enat nat \\<le> n; enat 0 < n; m = enat nat;\n        k = enat nata; n = \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> enat nata div n \\<le> enat (nata div nat)", "apply (simp add: div_le_mono2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat nata.\n       \\<lbrakk>0 < nat; enat nat \\<le> n; enat 0 < n; m = enat nat;\n        k = enat nata; n = \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> enat nata div n \\<le> enat (nata div nat)", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"]]}