{"file_name": "/home/qj213/afp-2021-10-22/thys/List-Infinite/CommonSet/SetInterval2.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/List-Infinite", "problem_names": ["lemma mono_on_subset: \"\\<lbrakk> mono_on f A ; B \\<subseteq> A \\<rbrakk> \\<Longrightarrow> mono_on f B\"", "lemma strict_mono_on_subset: \"\\<lbrakk> strict_mono_on f A ; B \\<subseteq> A \\<rbrakk> \\<Longrightarrow> strict_mono_on f B\"", "lemma mono_on_UNIV_mono_conv: \"mono_on f UNIV = mono f\"", "lemma strict_mono_on_UNIV_strict_mono_conv: \"\n  strict_mono_on f UNIV = strict_mono f\"", "lemma mono_imp_mono_on: \"mono f \\<Longrightarrow> mono_on f A\"", "lemma strict_mono_imp_strict_mono_on: \"strict_mono f \\<Longrightarrow> strict_mono_on f A\"", "lemma strict_mono_on_imp_mono_on: \"strict_mono_on f A \\<Longrightarrow> mono_on f A\"", "lemma inj_imp_inj_on: \"inj f \\<Longrightarrow> inj_on f A\"", "lemma strict_mono_on_imp_inj_on: \"\n  strict_mono_on f (A::'a::linorder set) \\<Longrightarrow> inj_on f A\"", "lemma strict_mono_imp_inj: \"strict_mono (f::('a::linorder \\<Rightarrow> 'b::order)) \\<Longrightarrow> inj f\"", "lemma strict_mono_on_mono_on_conv: \"\n  strict_mono_on f (A::'a::linorder set) = (mono_on f A \\<and> inj_on f A)\"", "lemma inj_on_image_mem_iff: \"\n  \\<lbrakk> inj_on f A; B \\<subseteq> A; a \\<in> A \\<rbrakk> \\<Longrightarrow> (f a \\<in> f ` B) = (a \\<in> B)\"", "lemma surj_on_conv: \"(surj_on f A B) = (\\<forall>b\\<in>B. \\<exists>a\\<in>A. b = f a)\"", "lemma surj_on_image_conv: \"(surj_on f A B) = (B \\<subseteq> f ` A)\"", "lemma surj_on_id: \"surj_on id A A\"", "lemma\n  surj_onI: \"\\<lbrakk> \\<forall>b \\<in> B. \\<exists>a\\<in>A. b = f a \\<rbrakk> \\<Longrightarrow> surj_on f A B\" and\n  surj_onD2: \"surj_on f A B \\<Longrightarrow> \\<forall>b \\<in> B. \\<exists>a\\<in>A. b = f a\" and\n  surj_onD: \"\\<lbrakk> surj_on f A B; b \\<in> B \\<rbrakk> \\<Longrightarrow> \\<exists>a\\<in>A. b = f a\"", "lemma comp_surj_on: \"\n  \\<lbrakk> surj_on f A B; surj_on g B C \\<rbrakk> \\<Longrightarrow> surj_on (g \\<circ> f) A C\"", "lemma surj_on_Un_right: \"surj_on f A (B1 \\<union> B2) = (surj_on f A B1 \\<and> surj_on f A B2)\"", "lemma surj_on_Un_left: \"\n  surj_on f (A1 \\<union> A2) B =\n  (\\<exists>B1. \\<exists>B2. B \\<subseteq> B1 \\<union> B2 \\<and> surj_on f A1 B1 \\<and> surj_on f A2 B2)\"", "lemma surj_on_diff_right: \"surj_on f A B \\<Longrightarrow> surj_on f A (B - B')\"", "lemma surj_on_empty_right: \"surj_on f A {}\"", "lemma surj_on_empty_left: \"surj_on f {} B = (B = {})\"", "lemma surj_on_imageI: \"surj_on (g \\<circ> f) A B \\<Longrightarrow> surj_on g (f ` A) B\"", "lemma surj_on_insert_right: \"surj_on f A (insert b B) = (surj_on f A B \\<and> surj_on f A {b})\"", "lemma surj_on_insert_left: \"surj_on f (insert a A) B = (surj_on f A (B - {f a}))\"", "lemma surj_on_subset_right: \"\\<lbrakk> surj_on f A B; B' \\<subseteq> B \\<rbrakk> \\<Longrightarrow> surj_on f A B'\"", "lemma surj_on_subset_left: \"\\<lbrakk> surj_on f A B; A \\<subseteq> A' \\<rbrakk> \\<Longrightarrow> surj_on f A' B\"", "lemma bij_betw_imp_surj_on: \"bij_betw f A B \\<Longrightarrow> surj_on f A B\"", "lemma bij_betw_inj_on_surj_on_conv: \"\n  bij_betw f A B = (inj_on f A \\<and> surj_on f A B \\<and> f ` A \\<subseteq> B)\"", "lemma image_nat_induct: \"\n  \\<lbrakk> P (f 0); \\<And>n. P (f n) \\<Longrightarrow> P (f (Suc n)); surj_on f UNIV I; a \\<in> I \\<rbrakk> \\<Longrightarrow> P a\"", "lemma nat_induct'[rule_format]: \"\n  \\<lbrakk> P n0; \\<And>n. \\<lbrakk> n0 \\<le> n;  P n \\<rbrakk> \\<Longrightarrow> P (Suc n); n0 \\<le> n \\<rbrakk> \\<Longrightarrow> P n\"", "lemma enat_induct: \"\n  \\<lbrakk> P 0; P \\<infinity>; \\<And>n. P n \\<Longrightarrow> P (eSuc n)\\<rbrakk> \\<Longrightarrow> P n\"", "lemma eSuc_imp_Suc_aux_0:\n  \"\\<lbrakk> \\<And>n. P n \\<Longrightarrow> P (eSuc n); n0' \\<le> n'; P (enat n')\\<rbrakk> \\<Longrightarrow> P (enat (Suc n'))\"", "lemma eSuc_imp_Suc_aux_n0:\n  \"\\<lbrakk> \\<And>n. \\<lbrakk>enat n0' \\<le> n; P n\\<rbrakk> \\<Longrightarrow> P (eSuc n); n0' \\<le> n'; P (enat n')\\<rbrakk> \\<Longrightarrow> P (enat (Suc n'))\"", "lemma enat_induct': \"\n  \\<lbrakk> P (n0::enat); P \\<infinity>; \\<And>n. \\<lbrakk> n0 \\<le> n;  P n \\<rbrakk> \\<Longrightarrow> P (eSuc n); n0 \\<le> n \\<rbrakk> \\<Longrightarrow> P n\"", "lemma wf_less_interval:\"\n  wf { (x,y). x \\<in> (I::nat set) \\<and> y \\<in> I \\<and> x < y }\"", "lemma interval_induct: \"\n  \\<lbrakk> \\<And>x. \\<forall>y. (x\\<in>(I::nat set) \\<and> y \\<in> I \\<and> y < x \\<longrightarrow> P y) \\<Longrightarrow> P x \\<rbrakk>\n  \\<Longrightarrow> P a\"\n  (is \"\\<lbrakk> \\<And>x. \\<forall>y. ?IA x y \\<Longrightarrow> P x \\<rbrakk> \\<Longrightarrow> P a\")", "lemma add_left_inj: \"inj (\\<lambda>x. n + (x::'a::cancel_ab_semigroup_add))\"", "lemma add_right_inj: \"inj (\\<lambda>x. x + (n::'a::cancel_ab_semigroup_add))\"", "lemma mult_left_inj: \"0 < n \\<Longrightarrow> inj (\\<lambda>x. (n::nat) * x)\"", "lemma mult_right_inj: \"0 < n \\<Longrightarrow> inj (\\<lambda>x. x * (n::nat))\"", "lemma sub_left_inj_on: \"inj_on (\\<lambda>x. (x::nat) - k) {k..}\"", "lemma sub_right_inj_on: \"inj_on (\\<lambda>x. k - (x::nat)) {..k}\"", "lemma add_left_strict_mono: \"strict_mono (\\<lambda>x. n + (x::'a::ordered_cancel_ab_semigroup_add))\"", "lemma add_right_strict_mono: \"strict_mono (\\<lambda>x. x + (n::'a::ordered_cancel_ab_semigroup_add))\"", "lemma mult_left_strict_mono: \"0 < n \\<Longrightarrow> strict_mono (\\<lambda>x. n * (x::nat))\"", "lemma mult_right_strict_mono: \"0 < n \\<Longrightarrow> strict_mono (\\<lambda>x. x * (n::nat))\"", "lemma sub_left_strict_mono_on: \"strict_mono_on (\\<lambda>x. (x::nat) - k) {k..}\"", "lemma div_right_strict_mono_on: \"\n  \\<lbrakk> 0 < (k::nat); \\<forall>x\\<in>I. \\<forall>y\\<in>I. x < y \\<longrightarrow> x + k \\<le> y \\<rbrakk> \\<Longrightarrow>\n  strict_mono_on (\\<lambda>x. x div k) I\"", "lemma mod_eq_div_right_strict_mono_on: \"\n  \\<lbrakk> 0 < (k::nat); \\<forall>x\\<in>I. \\<forall>y\\<in>I. x mod k = y mod k \\<rbrakk> \\<Longrightarrow>\n  strict_mono_on (\\<lambda>x. x div k) I\"", "lemma iMinI: \"k \\<in> I \\<Longrightarrow> iMin I \\<in> I\"", "lemma iMinI_ex: \"\\<exists>x. x \\<in> I \\<Longrightarrow> iMin I \\<in> I\"", "lemma iMinI2: \"\\<lbrakk> k \\<in> I; \\<And>x. x \\<in> I \\<Longrightarrow> P x \\<rbrakk> \\<Longrightarrow> P (iMin I)\"", "lemma iMinI2_ex: \"\\<lbrakk> \\<exists>x. x \\<in> I; \\<And>x. x \\<in> I \\<Longrightarrow> P x \\<rbrakk> \\<Longrightarrow> P (iMin I)\"", "lemma iMinI2_ex2: \"\\<lbrakk> I \\<noteq> {} ; \\<And>x. x \\<in> I \\<Longrightarrow> P x \\<rbrakk> \\<Longrightarrow> P (iMin I)\"", "lemma iMin_le[dest]: \"k \\<in> I \\<Longrightarrow> iMin I \\<le> k\"", "lemma iMin_neq_imp_greater[dest]: \"\\<lbrakk> k \\<in> I; k \\<noteq> iMin I \\<rbrakk> \\<Longrightarrow> iMin I < k\"", "lemma iMin_mono: \"\n  \\<lbrakk> mono f; \\<exists>x. x \\<in> I \\<rbrakk> \\<Longrightarrow> iMin (f ` I) = f (iMin I)\"", "lemma not_less_iMin: \"k < iMin I \\<Longrightarrow> k \\<notin> I\"", "lemma Collect_not_less_iMin: \"k < iMin {x. P x} \\<Longrightarrow> \\<not> P k\"", "lemma Collect_iMin_le: \"P k \\<Longrightarrow> iMin {x. P x} \\<le> k\"", "lemma Collect_minI: \"\\<lbrakk> k \\<in> I; P (k::('a::wellorder)) \\<rbrakk> \\<Longrightarrow> \\<exists>x\\<in>I. P x \\<and> (\\<forall>y\\<in>I. y < x \\<longrightarrow> \\<not> P y)\"", "lemma iMin_the:  \"iMin I = (THE x. x \\<in> I \\<and> (\\<forall>y. y \\<in> I \\<longrightarrow> x \\<le> y))\"", "lemma iMin_the2: \"iMin I = (THE x. x \\<in> I \\<and> (\\<forall>y\\<in>I. x \\<le> y))\"", "lemma iMin_equality: \"\n  \\<lbrakk> k \\<in> I; \\<And>x. x \\<in> I \\<Longrightarrow> k \\<le> x \\<rbrakk> \\<Longrightarrow> iMin I = k\"", "lemma iMin_mono_on: \"\n  \\<lbrakk> mono_on f I; \\<exists>x. x \\<in> I \\<rbrakk> \\<Longrightarrow> iMin (f ` I) = f (iMin I)\"", "lemma iMin_mono_on2: \"\n  \\<lbrakk> mono_on f I; I \\<noteq> {} \\<rbrakk> \\<Longrightarrow> iMin (f ` I) = f (iMin I)\"", "lemma iMinI2_order:\"\n  \\<lbrakk> k \\<in> I; \\<And>y. y \\<in> I \\<Longrightarrow> k \\<le> y;\n    \\<And>x. \\<lbrakk> x \\<in> I; \\<forall>y\\<in>I. x \\<le> y \\<rbrakk> \\<Longrightarrow> P x \\<rbrakk> \\<Longrightarrow>\n  P (iMin I)\"", "lemma wellorder_iMin_lemma: \"\n  k \\<in> I \\<Longrightarrow> iMin I \\<in> I \\<and> iMin I \\<le> k\"", "lemma iMin_Min_conv: \"\n  \\<lbrakk> finite I; I \\<noteq> {} \\<rbrakk> \\<Longrightarrow> iMin I = Min I\"", "lemma Min_neq_imp_greater[dest]: \"\\<lbrakk> finite I; k \\<in> I; k \\<noteq> Min I \\<rbrakk> \\<Longrightarrow> Min I < k\"", "lemma Max_neq_imp_less[dest]: \"\\<lbrakk> finite I; k \\<in> I; k \\<noteq> Max I \\<rbrakk> \\<Longrightarrow> k < Max I\"", "lemma nat_Least_mono: \"\n  \\<lbrakk> A \\<noteq> {}; mono (f::(nat\\<Rightarrow>nat)) \\<rbrakk> \\<Longrightarrow>\n  (LEAST x. x \\<in> f ` A) = f (LEAST x. x \\<in> A)\"", "lemma Least_disj: \"\n  \\<lbrakk> \\<exists>x. P x; \\<exists>x. Q x \\<rbrakk> \\<Longrightarrow>\n  (LEAST (x::'a::wellorder). (P x \\<or> Q x)) = min (LEAST x. P x) (LEAST x. Q x)\"", "lemma Least_imp_le: \"\n  \\<lbrakk> \\<exists>x. P x; \\<And>x. P x \\<Longrightarrow> Q x \\<rbrakk> \\<Longrightarrow>\n  (LEAST (x::'a::wellorder). Q x) \\<le> (LEAST x. P x)\"", "lemma Least_imp_disj_eq: \"\n  \\<lbrakk> \\<exists>x. P x; \\<And>x. P x \\<Longrightarrow> Q x \\<rbrakk> \\<Longrightarrow>\n  (LEAST (x::'a::wellorder). P x \\<or> Q x) = (LEAST x. Q x)\"", "lemma Least_le_imp_le: \"\n  \\<lbrakk> \\<exists>x. P x; \\<exists>x. Q x; \\<And>x y. \\<lbrakk> P x; Q y \\<rbrakk> \\<Longrightarrow> x \\<le> y \\<rbrakk> \\<Longrightarrow>\n  (LEAST (x::'a::wellorder). P x) \\<le> (LEAST (x::'a::wellorder). Q x)\"", "lemma Least_le_imp_le_disj: \"\n  \\<lbrakk> \\<exists>x. P x; \\<And>x y. \\<lbrakk> P x; Q y \\<rbrakk> \\<Longrightarrow> x \\<le> y \\<rbrakk> \\<Longrightarrow>\n  (LEAST (x::'a::wellorder). P x \\<or> Q x) = (LEAST (x::'a::wellorder). P x)\"", "lemma Max_equality: \"\\<lbrakk> (k::'a::linorder) \\<in> A; finite A; \\<And>x. x \\<in> A \\<Longrightarrow> x \\<le> k \\<rbrakk> \\<Longrightarrow>\n  Max A = k\"", "lemma not_greater_Max: \"\\<lbrakk> finite A; Max A < k \\<rbrakk>  \\<Longrightarrow> k \\<notin> A\"", "lemma Collect_not_greater_Max: \"\\<lbrakk> finite {x. P x}; Max {x. P x} < k \\<rbrakk> \\<Longrightarrow> \\<not> P k\"", "lemma Collect_Max_ge: \"\\<lbrakk> finite {x. P x}; P k \\<rbrakk> \\<Longrightarrow> k \\<le> Max {x. P x}\"", "lemma MaxI: \"\\<lbrakk> k \\<in> A; finite A \\<rbrakk> \\<Longrightarrow> Max A \\<in> A\"", "lemma MaxI_ex: \"\\<lbrakk> \\<exists>x. x \\<in> A; finite A \\<rbrakk> \\<Longrightarrow> Max A \\<in> A\"", "lemma MaxI_ex2: \"\\<lbrakk> A \\<noteq> {}; finite A \\<rbrakk> \\<Longrightarrow> Max A \\<in> A\"", "lemma MaxI2: \"\\<lbrakk> k \\<in> A; \\<And>x. x \\<in> A \\<Longrightarrow> P x; finite A \\<rbrakk> \\<Longrightarrow> P (Max A)\"", "lemma MaxI2_ex:\"\\<lbrakk> \\<exists>x. x \\<in> A; \\<And>x. x \\<in> A \\<Longrightarrow> P x; finite A \\<rbrakk> \\<Longrightarrow> P (Max A)\"", "lemma MaxI2_ex2:\"\\<lbrakk> A \\<noteq> {}; \\<And>x. x \\<in> A \\<Longrightarrow> P x; finite A \\<rbrakk> \\<Longrightarrow> P (Max A)\"", "lemma Max_mono: \"\\<lbrakk> mono f; \\<exists>x. x \\<in> A; finite A \\<rbrakk> \\<Longrightarrow> Max (f ` A) = f (Max A)\"", "lemma Max_mono2:\"\\<lbrakk> mono f; A \\<noteq> {}; finite A \\<rbrakk> \\<Longrightarrow> Max (f ` A) = f (Max A)\"", "lemma Max_mono_on: \"\\<lbrakk> mono_on f A; \\<exists>x. x \\<in> A; finite A \\<rbrakk> \\<Longrightarrow> Max (f ` A) = f (Max A)\"", "lemma Max_mono_on2: \"\n  \\<lbrakk> mono_on f A; A \\<noteq> {}; finite A \\<rbrakk> \\<Longrightarrow> Max (f ` A) = f (Max A)\"", "lemma Max_the: \"\n  \\<lbrakk> A \\<noteq> {}; finite A \\<rbrakk> \\<Longrightarrow>\n  Max A = (THE x. x \\<in> A \\<and> (\\<forall>y. y \\<in> A \\<longrightarrow> y \\<le> x))\"", "lemma Max_the2: \"\\<lbrakk> A \\<noteq> {}; finite A \\<rbrakk> \\<Longrightarrow>\n  Max A = (THE x. x \\<in> A \\<and> (\\<forall>y\\<in>A. y \\<le> x))\"", "lemma wellorder_Max_lemma: \"\\<lbrakk> k \\<in> A; finite A \\<rbrakk> \\<Longrightarrow> Max A \\<in> A \\<and> k \\<le> Max A\"", "lemma MaxI2_order: \"\\<lbrakk> k \\<in> A; finite A; \\<And>y. y \\<in> A \\<Longrightarrow> y \\<le> k;\n  \\<And>x. \\<lbrakk> x \\<in> A; \\<forall>y\\<in>A. y \\<le> x \\<rbrakk> \\<Longrightarrow> P x \\<rbrakk>\n  \\<Longrightarrow> P (Max A)\"", "lemma Min_le_Max: \"\\<lbrakk> finite A; A \\<noteq> {} \\<rbrakk> \\<Longrightarrow> Min A \\<le> Max A\"", "lemma iMin_le_Max: \"\\<lbrakk> finite A; A \\<noteq> {} \\<rbrakk> \\<Longrightarrow> iMin A \\<le> Max A\"", "lemma iMax_finite_conv: \"finite I = (iMax I \\<noteq> \\<infinity>)\"", "lemma iMax_infinite_conv: \"infinite I = (iMax I = \\<infinity>)\"", "lemma \"class.distrib_lattice (min::('a::linorder \\<Rightarrow> 'a \\<Rightarrow> 'a)) (\\<le>) (<) max\"", "lemma max_Min_eq_Min_max[rule_format]: \"\n  finite A \\<Longrightarrow>\n  A \\<noteq> {} \\<longrightarrow>\n  max x (Min A) = Min {max x a |a. a \\<in> A}\"", "lemma max_iMin_eq_iMin_max: \"\n  \\<lbrakk> finite A; A \\<noteq> {} \\<rbrakk> \\<Longrightarrow>\n  max x (iMin A) = iMin {max x a |a. a \\<in> A}\"", "lemma \"\\<lbrakk> finite A; A \\<noteq>{} \\<rbrakk> \\<Longrightarrow> \\<forall>x\\<in>A. x \\<le> Max A\"", "lemma iMin_subset: \"\\<lbrakk> A \\<noteq> {}; A \\<subseteq> B \\<rbrakk> \\<Longrightarrow> iMin B \\<le> iMin A\"", "lemma Max_subset: \"\\<lbrakk> A \\<noteq> {}; A \\<subseteq> B; finite B \\<rbrakk> \\<Longrightarrow> Max A \\<le> Max B\"", "lemma Min_subset: \"\\<lbrakk> A \\<noteq> {}; A \\<subseteq> B; finite B \\<rbrakk> \\<Longrightarrow> Min B \\<le> Min A\"", "lemma iMin_Int_ge1: \"(A \\<inter> B) \\<noteq> {} \\<Longrightarrow> iMin A \\<le> iMin (A \\<inter> B)\"", "lemma iMin_Int_ge2: \"(A \\<inter> B) \\<noteq> {} \\<Longrightarrow> iMin B \\<le> iMin (A \\<inter> B)\"", "lemma iMin_Int_ge: \"(A \\<inter> B) \\<noteq> {} \\<Longrightarrow> max (iMin A) (iMin B) \\<le> iMin (A \\<inter> B)\"", "lemma Max_Int_le1: \"\\<lbrakk> (A \\<inter> B) \\<noteq> {}; finite A \\<rbrakk> \\<Longrightarrow> Max (A \\<inter> B) \\<le> Max A\"", "lemma Max_Int_le2: \"\\<lbrakk> (A \\<inter> B) \\<noteq> {}; finite B \\<rbrakk> \\<Longrightarrow> Max (A \\<inter> B) \\<le> Max B\"", "lemma Max_Int_le: \"\\<lbrakk> (A \\<inter> B) \\<noteq> {}; finite A; finite B \\<rbrakk> \\<Longrightarrow>\n  Max (A \\<inter> B) \\<le> min (Max A) (Max B)\"", "lemma iMin_Un[rule_format]: \"\n  \\<lbrakk> A \\<noteq> {}; B \\<noteq> {} \\<rbrakk> \\<Longrightarrow>\n  iMin (A \\<union> B) = min (iMin A) (iMin B)\"", "lemma iMin_singleton[simp]: \"iMin {a} = a\"", "lemma iMax_singleton[simp]: \"iMax {a} = enat a\"", "lemma Max_le_Min_imp_singleton: \"\n  \\<lbrakk> finite A; A \\<noteq> {}; Max A \\<le> Min A \\<rbrakk> \\<Longrightarrow> A = {Min A}\"", "lemma Max_le_Min_conv_singleton: \"\n  \\<lbrakk> finite A; A \\<noteq> {} \\<rbrakk> \\<Longrightarrow> (Max A \\<le> Min A) = (\\<exists>x. A = {x})\"", "lemma Max_le_iMin_imp_le: \"\n  \\<lbrakk> finite A; Max A \\<le> iMin B; a \\<in> A; b \\<in> B \\<rbrakk> \\<Longrightarrow> a \\<le> b\"", "lemma le_imp_Max_le_iMin: \"\n  \\<lbrakk> finite A; A \\<noteq> {}; B \\<noteq> {}; \\<forall>a\\<in>A. \\<forall>b\\<in>B. a \\<le> b \\<rbrakk> \\<Longrightarrow> Max A \\<le> iMin B\"", "lemma Max_le_iMin_conv_le: \"\n  \\<lbrakk> finite A; A \\<noteq> {}; B \\<noteq> {} \\<rbrakk> \\<Longrightarrow> (Max A \\<le> iMin B) = (\\<forall>a\\<in>A. \\<forall>b\\<in>B. a \\<le> b)\"", "lemma Max_less_iMin_imp_less: \"\n  \\<lbrakk> finite A; Max A < iMin B; a \\<in> A; b \\<in> B \\<rbrakk> \\<Longrightarrow> a < b\"", "lemma less_imp_Max_less_iMin: \"\n  \\<lbrakk> finite A; A \\<noteq> {}; B \\<noteq> {}; \\<forall>a\\<in>A. \\<forall>b\\<in>B. a < b \\<rbrakk> \\<Longrightarrow> Max A < iMin B\"", "lemma Max_less_iMin_conv_less: \"\n  \\<lbrakk> finite A; A \\<noteq> {}; B \\<noteq> {} \\<rbrakk> \\<Longrightarrow> (Max A < iMin B) = (\\<forall>a\\<in>A. \\<forall>b\\<in>B. a < b)\"", "lemma Max_less_iMin_imp_disjoint: \"\n  \\<lbrakk> finite A; Max A < iMin B \\<rbrakk> \\<Longrightarrow> A \\<inter> B = {}\"", "lemma iMin_in_idem: \"n \\<in> I \\<Longrightarrow> min n (iMin I) = iMin I\"", "lemma iMin_insert: \"I \\<noteq> {} \\<Longrightarrow> iMin (insert n I) = min n (iMin I)\"", "lemma iMin_insert_remove: \"\n  iMin (insert n I) =\n  (if I - {n} = {} then n else min n (iMin (I - {n})))\"", "lemma iMin_remove: \"n \\<in> I \\<Longrightarrow> iMin I = (if I - {n} = {} then n else min n (iMin (I - {n})))\"", "lemma iMin_subset_idem: \"\\<lbrakk> B \\<noteq> {}; B \\<subseteq> A \\<rbrakk> \\<Longrightarrow> min (iMin B) (iMin A) = iMin A\"", "lemma iMin_union_inter: \"A \\<inter> B \\<noteq> {} \\<Longrightarrow> min (iMin (A \\<union> B)) (iMin (A \\<inter> B)) = min (iMin A) (iMin B)\"", "lemma iMin_ge_iff: \"I \\<noteq> {} \\<Longrightarrow> (n \\<le> iMin I) = (\\<forall>a\\<in>I. n \\<le> a)\"", "lemma iMin_gr_iff: \"I \\<noteq> {} \\<Longrightarrow> (n < iMin I) = (\\<forall>a\\<in>I. n < a)\"", "lemma iMin_le_iff: \"I \\<noteq> {} \\<Longrightarrow> (iMin I \\<le> n) = (\\<exists>a\\<in>I. a \\<le> n)\"", "lemma iMin_less_iff: \"I \\<noteq> {} \\<Longrightarrow> (iMin I < n) = (\\<exists>a\\<in>I. a < n)\"", "lemma hom_iMin_commute: \"\\<lbrakk> \\<And>x y. h (min x y) = min (h x) (h y); I \\<noteq> {} \\<rbrakk> \\<Longrightarrow> iMin (h ` I) = h (iMin I)\"", "lemmas iMin_eqI = iMin_equality", "lemmas iMin_in = iMinI_ex2", "lemma \"reflP ((\\<le>)::('a::preorder \\<Rightarrow> 'a \\<Rightarrow> bool))\"", "lemma \"symP (=)\"", "lemma \"equivP (=)\"", "lemma \"irreflP ((<)::('a::preorder \\<Rightarrow> 'a \\<Rightarrow> bool))\"", "lemma singleton_not_empty: \"{a} \\<noteq> {}\"", "lemma singleton_finite: \"finite {a}\"", "lemma singleton_ball: \"(\\<forall>x\\<in>{a}. P x) = P a\"", "lemma singleton_bex: \"(\\<exists>x\\<in>{a}. P x) = P a\"", "lemma subset_singleton_conv: \"(A \\<subseteq> {a}) = (A = {} \\<or> A = {a})\"", "lemma singleton_subset_conv: \"({a} \\<subseteq> A) = (a \\<in> A)\"", "lemma singleton_eq_conv: \"({a} = {b}) = (a = b)\"", "lemma singleton_subset_singleton_conv: \"({a} \\<subseteq> {b}) = (a = b)\"", "lemma singleton_Int1_if: \"{a} \\<inter> A = (if a \\<in> A then {a} else {})\"", "lemma singleton_Int2_if: \"A \\<inter> {a} = (if a \\<in> A then {a} else {})\"", "lemma singleton_image: \"f ` {a} = {f a}\"", "lemma inj_on_singleton: \"inj_on f {a}\"", "lemma strict_mono_on_singleton: \"strict_mono_on f {a}\"", "lemma infinite_imp_not_singleton: \"infinite A \\<Longrightarrow> \\<not> (\\<exists>a. A = {a})\"", "lemma infinite_insert: \"infinite (insert a A) = infinite A\"", "lemma infinite_Diff_insert: \"infinite (A - insert a B) = infinite (A - B)\"", "lemma subset_finite_imp_finite: \"\\<lbrakk> finite A; B \\<subseteq> A \\<rbrakk> \\<Longrightarrow> finite B\"", "lemma infinite_not_subset_finite: \"\\<lbrakk> infinite A; finite B \\<rbrakk> \\<Longrightarrow> \\<not> A \\<subseteq> B\"", "lemma Un_infinite_right: \"infinite T \\<Longrightarrow> infinite (S \\<union> T)\"", "lemma Un_infinite_iff: \"infinite (S \\<union> T) = (infinite S \\<or> infinite T)\"", "lemma cartesian_product_infiniteL_imp_infinite: \"\\<lbrakk> infinite A; B \\<noteq> {} \\<rbrakk> \\<Longrightarrow> infinite (A \\<times> B)\"", "lemma cartesian_product_infiniteR_imp_infinite: \"\\<lbrakk> infinite B; A \\<noteq> {} \\<rbrakk> \\<Longrightarrow> infinite (A \\<times> B)\"", "lemma finite_nat_iff_bounded2: \"\n  finite S = (\\<exists>(k::nat).\\<forall>n\\<in>S. n < k)\"", "lemma finite_nat_iff_bounded_le2: \"\n  finite S = (\\<exists>(k::nat).\\<forall>n\\<in>S. n \\<le> k)\"", "lemma nat_asc_chain_imp_unbounded: \"\n  \\<lbrakk> S \\<noteq> {}; (\\<forall>m\\<in>S. \\<exists>n\\<in>S. m < (n::nat)) \\<rbrakk> \\<Longrightarrow> \\<forall>m. \\<exists>n\\<in>S. m \\<le> n\"", "lemma infinite_nat_iff_asc_chain: \"\n  S \\<noteq> {} \\<Longrightarrow> infinite S = (\\<forall>m\\<in>S. \\<exists>n\\<in>S. m < (n::nat))\"", "lemma infinite_imp_asc_chain: \"infinite S \\<Longrightarrow> \\<forall>m\\<in>S. \\<exists>n\\<in>S. m < (n::nat)\"", "lemma infinite_image_imp_infinite: \"infinite (f ` A) \\<Longrightarrow> infinite A\"", "lemma inj_on_imp_infinite_image: \"\\<lbrakk> infinite A; inj_on f A \\<rbrakk> \\<Longrightarrow> infinite (f ` A)\"", "lemma inj_on_infinite_image_iff: \"inj_on f A \\<Longrightarrow> infinite (f ` A) = infinite A\"", "lemma inj_on_finite_image_iff: \"inj_on f A \\<Longrightarrow> finite (f ` A) = finite A\"", "lemma nat_ex_greater_finite_Max_conv: \"\n  A \\<noteq> {} \\<Longrightarrow> (\\<exists>x\\<in>A. (n::nat) < x) = (finite A \\<longrightarrow> n < Max A)\"", "lemma disjoint_iff_in_not_in1: \"(A \\<inter> B = {}) = (\\<forall>x\\<in>A. x \\<notin> B)\"", "lemma disjoint_iff_in_not_in2: \"(A \\<inter> B = {}) = (\\<forall>x\\<in>B. x \\<notin> A)\"", "lemma disjoint_in_Un: \"\n  \\<lbrakk> A \\<inter> B = {}; x \\<in> A \\<union> B \\<rbrakk> \\<Longrightarrow> x \\<notin> A \\<or> x \\<notin> B\"", "lemma partition_Union: \"A \\<subseteq> \\<Union>C \\<Longrightarrow> (\\<Union>c\\<in>C. A \\<inter> c) = A\"", "lemma disjoint_partition_Int: \"\n  \\<forall>c1\\<in>C. \\<forall>c2\\<in>C. c1 \\<noteq> c2 \\<longrightarrow> c1 \\<inter> c2 = {} \\<Longrightarrow>\n  \\<forall>a1\\<in>{A \\<inter> c| c. c \\<in> C}. \\<forall>a2\\<in>{A \\<inter> c| c. c \\<in> C}.\n    a1 \\<noteq> a2 \\<longrightarrow> a1 \\<inter> a2 = {}\"", "lemma \"{f x |x. x \\<in> A} = (\\<Union>x\\<in>A. {f x})\"", "lemma card_partition: \"\n  \\<lbrakk> finite C; \\<And>c. c \\<in> C \\<Longrightarrow> card c = k; \\<And>c1 c2. \\<lbrakk>c1 \\<in> C; c2 \\<in> C; c1 \\<noteq> c2\\<rbrakk> \\<Longrightarrow> c1 \\<inter> c2 = {} \\<rbrakk> \\<Longrightarrow>\n  card (\\<Union>C) = k * card C\"", "lemma subset_image_Int: \"A \\<subseteq> B \\<Longrightarrow> f ` (A \\<inter> B) = f ` A \\<inter> f ` B\"", "lemma image_diff_disjoint_image_Int: \"\n  \\<lbrakk> f ` (A - B) \\<inter> f ` B = {} \\<rbrakk> \\<Longrightarrow>\n  f ` (A \\<inter> B) = f ` A \\<inter> f ` B\"", "lemma subset_imp_Int_subset1: \"A \\<subseteq> C \\<Longrightarrow> A \\<inter> B \\<subseteq> C\"", "lemma subset_imp_Int_subset2: \"B \\<subseteq> C \\<Longrightarrow> A \\<inter> B \\<subseteq> C\"", "lemmas set_interval_defs =\n  lessThan_def atMost_def\n  greaterThan_def atLeast_def\n  greaterThanLessThan_def atLeastLessThan_def\n  greaterThanAtMost_def atLeastAtMost_def", "lemma image_add_atLeast:\n  \"(\\<lambda>n::nat. n+k) ` {i..} = {i+k..}\" (is \"?A = ?B\")", "lemma image_add_atMost:\n  \"(\\<lambda>n::nat. n+k) ` {..i} = {k..i+k}\" (is \"?A = ?B\")", "lemmas image_add_lemmas =\n  image_add_atLeastAtMost\n  image_add_atLeast\n  image_add_atMost", "lemmas image_Suc_lemmas =\n  image_Suc_atLeastAtMost\n  image_Suc_atLeast\n  image_Suc_atMost", "lemma atMost_atLeastAtMost_0_conv: \"{..i::nat} = {0..i}\"", "lemma atLeastAtMost_subset_atMost: \"(k::'a::order) \\<le> k' \\<Longrightarrow> {l..k} \\<subseteq> {..k'}\"", "lemma lessThan_insert: \"insert (n::'a::order) {..<n} = {..n}\"", "lemma greaterThan_insert: \"insert (n::'a::order) {n<..} = {n..}\"", "lemma atMost_remove: \"{..n} - {(n::'a::order)} = {..<n}\"", "lemma atLeast_remove: \"{n..} - {(n::'a::order)} = {n<..}\"", "lemma atMost_lessThan_conv: \"{..n} = {..<Suc n}\"", "lemma atLeastAtMost_atLeastLessThan_conv: \"{l..u} = {l..<Suc u}\"", "lemma atLeast_greaterThan_conv: \"{Suc n..} = {n<..}\"", "lemma atLeastAtMost_greaterThanAtMost_conv: \"{Suc l..u} = {l<..u}\"", "lemma finite_subset_atLeastAtMost: \"finite A \\<Longrightarrow> A \\<subseteq> {Min A..Max A}\"", "lemma Max_le_imp_subset_atMost: \"\n  \\<lbrakk> finite A;  Max A \\<le> n \\<rbrakk> \\<Longrightarrow> A \\<subseteq> {..n}\"", "lemma subset_atMost_imp_Max_le:\"\n  \\<lbrakk> finite A; A \\<noteq> {}; A \\<subseteq> {..n} \\<rbrakk> \\<Longrightarrow> Max A \\<le> n\"", "lemma subset_atMost_Max_le_conv: \"\n  \\<lbrakk> finite A; A \\<noteq> {} \\<rbrakk> \\<Longrightarrow> (A \\<subseteq> {..n}) = (Max A \\<le> n)\"", "lemma iMin_atLeast: \"iMin {n..} = n\"", "lemma iMin_greaterThan: \"iMin {n<..} = Suc n\"", "lemma iMin_atMost: \"iMin {..(n::nat)} = 0\"", "lemma iMin_lessThan: \"0 < n \\<Longrightarrow> iMin {..<(n::nat)} = 0\"", "lemma Max_atMost: \"Max {..(n::nat)} = n\"", "lemma Max_lessThan: \"0 < n \\<Longrightarrow> Max {..<n} = n - Suc 0\"", "lemma iMin_atLeastLessThan: \"m < n \\<Longrightarrow> iMin {m..<n} = m\"", "lemma Max_atLeastLessThan: \"m < n \\<Longrightarrow> Max {m..<n} = n - Suc 0\"", "lemma iMin_greaterThanLessThan: \"Suc m < n \\<Longrightarrow> iMin {m<..<n} = Suc m\"", "lemma Max_greaterThanLessThan: \"Suc m < n \\<Longrightarrow> Max {m<..<n} = n - Suc 0\"", "lemma iMin_greaterThanAtMost: \"m < n \\<Longrightarrow> iMin {m<..n} = Suc m\"", "lemma Max_greaterThanAtMost: \"m < n \\<Longrightarrow> Max {m<..(n::nat)} = n\"", "lemma iMin_atLeastAtMost: \"m \\<le> n \\<Longrightarrow> iMin {m..n} = m\"", "lemma Max_atLeastAtMost: \"m \\<le> n \\<Longrightarrow> Max {m..(n::nat)} = n\"", "lemma infinite_atLeast: \"infinite {(n::nat)..}\"", "lemma infinite_greaterThan: \"infinite {(n::nat)<..}\"", "lemma infinite_atLeast_int: \"infinite {(n::int)..}\"", "lemma infinite_greaterThan_int: \"infinite {(n::int)<..}\"", "lemma infinite_atMost_int: \"infinite {..(n::int)}\"", "lemma infinite_lessThan_int: \"infinite {..<(n::int)}\"", "lemma sum_singleton: \"(\\<Sum>x\\<in>{a}. f x) = f a\"", "lemma card_singleton: \"card {a} = Suc 0\"", "lemma card_cartesian_product_singleton_right: \"card (A \\<times> {x}) = card A\"", "lemma card_1_imp_singleton: \"card A = Suc 0 \\<Longrightarrow> (\\<exists>a. A = {a})\"", "lemma card_1_singleton_conv: \"(card A = Suc 0) = (\\<exists>a. A = {a})\"", "lemma card_gr0_imp_finite: \"0 < card A \\<Longrightarrow> finite A\"", "lemma card_gr0_imp_not_empty: \"(0 < card A) \\<Longrightarrow> A \\<noteq> {}\"", "lemma not_empty_card_gr0_conv: \"finite A \\<Longrightarrow> (A \\<noteq> {}) = (0 < card A)\"", "lemma nat_card_le_Max: \"card (A::nat set) \\<le> Suc (Max A)\"", "lemma Int_card1: \"finite A \\<Longrightarrow> card (A \\<inter> B) \\<le> card A\"", "lemma Int_card2: \"finite B \\<Longrightarrow> card (A \\<inter> B) \\<le> card B\"", "lemma Un_card1: \"\\<lbrakk> finite A; finite B \\<rbrakk> \\<Longrightarrow> card A \\<le> card (A \\<union> B)\"", "lemma Un_card2: \"\\<lbrakk> finite A; finite B \\<rbrakk> \\<Longrightarrow> card B \\<le> card (A \\<union> B)\"", "lemma card_Un_conv: \"\n  \\<lbrakk> finite A; finite B \\<rbrakk> \\<Longrightarrow>\n  card (A \\<union> B) = card A + card B - card (A \\<inter> B)\"", "lemma card_Int_conv: \"\n  \\<lbrakk> finite A; finite B \\<rbrakk> \\<Longrightarrow>\n  card (A \\<inter> B) = card A + card B - card (A \\<union> B)\"", "lemma pigeonhole_principle[rule_format]: \"\n  card (f ` A) < card A \\<longrightarrow> (\\<exists>x\\<in>A. \\<exists>y\\<in>A. x \\<noteq> y \\<and> f x = f y)\""], "translations": [["", "lemma mono_on_subset: \"\\<lbrakk> mono_on f A ; B \\<subseteq> A \\<rbrakk> \\<Longrightarrow> mono_on f B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>SetInterval2.mono_on f A; B \\<subseteq> A\\<rbrakk>\n    \\<Longrightarrow> SetInterval2.mono_on f B", "unfolding mono_on_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>a\\<in>A.\n                \\<forall>b\\<in>A. a \\<le> b \\<longrightarrow> f a \\<le> f b;\n     B \\<subseteq> A\\<rbrakk>\n    \\<Longrightarrow> \\<forall>a\\<in>B.\n                         \\<forall>b\\<in>B.\n                            a \\<le> b \\<longrightarrow> f a \\<le> f b", "by blast"], ["", "lemma strict_mono_on_subset: \"\\<lbrakk> strict_mono_on f A ; B \\<subseteq> A \\<rbrakk> \\<Longrightarrow> strict_mono_on f B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>SetInterval2.strict_mono_on f A; B \\<subseteq> A\\<rbrakk>\n    \\<Longrightarrow> SetInterval2.strict_mono_on f B", "unfolding strict_mono_on_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>a\\<in>A.\n                \\<forall>b\\<in>A. a < b \\<longrightarrow> f a < f b;\n     B \\<subseteq> A\\<rbrakk>\n    \\<Longrightarrow> \\<forall>a\\<in>B.\n                         \\<forall>b\\<in>B. a < b \\<longrightarrow> f a < f b", "by blast"], ["", "lemma mono_on_UNIV_mono_conv: \"mono_on f UNIV = mono f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SetInterval2.mono_on f UNIV = mono f", "unfolding mono_on_def mono_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>a\\<in>UNIV.\n        \\<forall>b\\<in>UNIV. a \\<le> b \\<longrightarrow> f a \\<le> f b) =\n    (\\<forall>x y. x \\<le> y \\<longrightarrow> f x \\<le> f y)", "by blast"], ["", "lemma strict_mono_on_UNIV_strict_mono_conv: \"\n  strict_mono_on f UNIV = strict_mono f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SetInterval2.strict_mono_on f UNIV = strict_mono f", "unfolding strict_mono_on_def strict_mono_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>a\\<in>UNIV.\n        \\<forall>b\\<in>UNIV. a < b \\<longrightarrow> f a < f b) =\n    (\\<forall>x y. x < y \\<longrightarrow> f x < f y)", "by blast"], ["", "lemma mono_imp_mono_on: \"mono f \\<Longrightarrow> mono_on f A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono f \\<Longrightarrow> SetInterval2.mono_on f A", "unfolding mono_on_def mono_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       x \\<le> y \\<longrightarrow> f x \\<le> f y \\<Longrightarrow>\n    \\<forall>a\\<in>A.\n       \\<forall>b\\<in>A. a \\<le> b \\<longrightarrow> f a \\<le> f b", "by blast"], ["", "lemma strict_mono_imp_strict_mono_on: \"strict_mono f \\<Longrightarrow> strict_mono_on f A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strict_mono f \\<Longrightarrow> SetInterval2.strict_mono_on f A", "unfolding strict_mono_on_def strict_mono_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y. x < y \\<longrightarrow> f x < f y \\<Longrightarrow>\n    \\<forall>a\\<in>A. \\<forall>b\\<in>A. a < b \\<longrightarrow> f a < f b", "by blast"], ["", "lemma strict_mono_on_imp_mono_on: \"strict_mono_on f A \\<Longrightarrow> mono_on f A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SetInterval2.strict_mono_on f A \\<Longrightarrow>\n    SetInterval2.mono_on f A", "apply (unfold strict_mono_on_def mono_on_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a\\<in>A.\n       \\<forall>b\\<in>A. a < b \\<longrightarrow> f a < f b \\<Longrightarrow>\n    \\<forall>a\\<in>A.\n       \\<forall>b\\<in>A. a \\<le> b \\<longrightarrow> f a \\<le> f b", "apply (fastforce simp: order_le_less)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsubsection \\<open>Injectivity\\<close>"], ["", "lemma inj_imp_inj_on: \"inj f \\<Longrightarrow> inj_on f A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj f \\<Longrightarrow> inj_on f A", "unfolding inj_on_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>UNIV.\n       \\<forall>y\\<in>UNIV.\n          f x = f y \\<longrightarrow> x = y \\<Longrightarrow>\n    \\<forall>x\\<in>A. \\<forall>y\\<in>A. f x = f y \\<longrightarrow> x = y", "by blast"], ["", "lemma strict_mono_on_imp_inj_on: \"\n  strict_mono_on f (A::'a::linorder set) \\<Longrightarrow> inj_on f A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SetInterval2.strict_mono_on f A \\<Longrightarrow> inj_on f A", "apply (unfold strict_mono_on_def inj_on_def, clarify)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>\\<forall>a\\<in>A.\n                   \\<forall>b\\<in>A. a < b \\<longrightarrow> f a < f b;\n        x \\<in> A; y \\<in> A; f x = f y\\<rbrakk>\n       \\<Longrightarrow> x = y", "apply (rule ccontr)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>\\<forall>a\\<in>A.\n                   \\<forall>b\\<in>A. a < b \\<longrightarrow> f a < f b;\n        x \\<in> A; y \\<in> A; f x = f y; x \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> False", "apply (fastforce simp add: linorder_neq_iff)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma strict_mono_imp_inj: \"strict_mono (f::('a::linorder \\<Rightarrow> 'b::order)) \\<Longrightarrow> inj f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strict_mono f \\<Longrightarrow> inj f", "by (rule strict_mono_imp_inj_on)"], ["", "lemma strict_mono_on_mono_on_conv: \"\n  strict_mono_on f (A::'a::linorder set) = (mono_on f A \\<and> inj_on f A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SetInterval2.strict_mono_on f A =\n    (SetInterval2.mono_on f A \\<and> inj_on f A)", "apply (rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. SetInterval2.strict_mono_on f A \\<Longrightarrow>\n    SetInterval2.mono_on f A \\<and> inj_on f A\n 2. SetInterval2.mono_on f A \\<and> inj_on f A \\<Longrightarrow>\n    SetInterval2.strict_mono_on f A", "apply (frule strict_mono_on_imp_mono_on)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>SetInterval2.strict_mono_on f A;\n     SetInterval2.mono_on f A\\<rbrakk>\n    \\<Longrightarrow> SetInterval2.mono_on f A \\<and> inj_on f A\n 2. SetInterval2.mono_on f A \\<and> inj_on f A \\<Longrightarrow>\n    SetInterval2.strict_mono_on f A", "apply (frule strict_mono_on_imp_inj_on)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>SetInterval2.strict_mono_on f A; SetInterval2.mono_on f A;\n     inj_on f A\\<rbrakk>\n    \\<Longrightarrow> SetInterval2.mono_on f A \\<and> inj_on f A\n 2. SetInterval2.mono_on f A \\<and> inj_on f A \\<Longrightarrow>\n    SetInterval2.strict_mono_on f A", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. SetInterval2.mono_on f A \\<and> inj_on f A \\<Longrightarrow>\n    SetInterval2.strict_mono_on f A", "apply (erule conjE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>SetInterval2.mono_on f A; inj_on f A\\<rbrakk>\n    \\<Longrightarrow> SetInterval2.strict_mono_on f A", "apply (unfold inj_on_def mono_on_def strict_mono_on_def, clarify)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<forall>a\\<in>A.\n                   \\<forall>b\\<in>A.\n                      a \\<le> b \\<longrightarrow> f a \\<le> f b;\n        \\<forall>x\\<in>A.\n           \\<forall>y\\<in>A. f x = f y \\<longrightarrow> x = y;\n        a \\<in> A; b \\<in> A; a < b\\<rbrakk>\n       \\<Longrightarrow> f a < f b", "apply fastforce"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "corollary strict_mono_mono_conv: \"\n  strict_mono (f::('a::linorder \\<Rightarrow> 'b::order)) = (mono f \\<and> inj f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strict_mono f = (mono f \\<and> inj f)", "by (simp only: strict_mono_on_UNIV_strict_mono_conv[symmetric]\n  mono_on_UNIV_mono_conv[symmetric] strict_mono_on_mono_on_conv)"], ["", "lemma inj_on_image_mem_iff: \"\n  \\<lbrakk> inj_on f A; B \\<subseteq> A; a \\<in> A \\<rbrakk> \\<Longrightarrow> (f a \\<in> f ` B) = (a \\<in> B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>inj_on f A; B \\<subseteq> A; a \\<in> A\\<rbrakk>\n    \\<Longrightarrow> (f a \\<in> f ` B) = (a \\<in> B)", "unfolding inj_on_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>x\\<in>A.\n                \\<forall>y\\<in>A. f x = f y \\<longrightarrow> x = y;\n     B \\<subseteq> A; a \\<in> A\\<rbrakk>\n    \\<Longrightarrow> (f a \\<in> f ` B) = (a \\<in> B)", "by blast"], ["", "corollary inj_on_union_image_Int: \"\n  inj_on f (A \\<union> B) \\<Longrightarrow> f ` (A \\<inter> B) = f ` A \\<inter> f ` B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on f (A \\<union> B) \\<Longrightarrow>\n    f ` (A \\<inter> B) = f ` A \\<inter> f ` B", "by (rule inj_on_image_Int[OF _ Un_upper1 Un_upper2])"], ["", "subsubsection \\<open>Surjectivity\\<close>"], ["", "definition surj_on :: \"('a \\<Rightarrow> 'b) \\<Rightarrow> 'a set \\<Rightarrow> 'b set \\<Rightarrow> bool\"\n  where \"surj_on f A B \\<equiv> \\<forall>b\\<in>B. \\<exists>a\\<in>A. b = f a\""], ["", "lemma surj_on_conv: \"(surj_on f A B) = (\\<forall>b\\<in>B. \\<exists>a\\<in>A. b = f a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. surj_on f A B = (\\<forall>b\\<in>B. \\<exists>a\\<in>A. b = f a)", "unfolding surj_on_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>b\\<in>B. \\<exists>a\\<in>A. b = f a) =\n    (\\<forall>b\\<in>B. \\<exists>a\\<in>A. b = f a)", ".."], ["", "lemma surj_on_image_conv: \"(surj_on f A B) = (B \\<subseteq> f ` A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. surj_on f A B = (B \\<subseteq> f ` A)", "unfolding surj_on_conv"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>b\\<in>B. \\<exists>a\\<in>A. b = f a) = (B \\<subseteq> f ` A)", "by blast"], ["", "lemma surj_on_id: \"surj_on id A A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. surj_on id A A", "unfolding id_def surj_on_conv"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>b\\<in>A. \\<exists>a\\<in>A. b = a", "by blast"], ["", "lemma\n  surj_onI: \"\\<lbrakk> \\<forall>b \\<in> B. \\<exists>a\\<in>A. b = f a \\<rbrakk> \\<Longrightarrow> surj_on f A B\" and\n  surj_onD2: \"surj_on f A B \\<Longrightarrow> \\<forall>b \\<in> B. \\<exists>a\\<in>A. b = f a\" and\n  surj_onD: \"\\<lbrakk> surj_on f A B; b \\<in> B \\<rbrakk> \\<Longrightarrow> \\<exists>a\\<in>A. b = f a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>b\\<in>B. \\<exists>a\\<in>A. b = f a \\<Longrightarrow>\n     surj_on f A B) &&&\n    (surj_on f A B \\<Longrightarrow>\n     \\<forall>b\\<in>B. \\<exists>a\\<in>A. b = f a) &&&\n    (\\<lbrakk>surj_on f A B; b \\<in> B\\<rbrakk>\n     \\<Longrightarrow> \\<exists>a\\<in>A. b = f a)", "unfolding surj_on_conv"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>b\\<in>B. \\<exists>a\\<in>A. b = f a \\<Longrightarrow>\n     \\<forall>b\\<in>B. \\<exists>a\\<in>A. b = f a) &&&\n    (\\<forall>b\\<in>B. \\<exists>a\\<in>A. b = f a \\<Longrightarrow>\n     \\<forall>b\\<in>B. \\<exists>a\\<in>A. b = f a) &&&\n    (\\<lbrakk>\\<forall>b\\<in>B. \\<exists>a\\<in>A. b = f a;\n      b \\<in> B\\<rbrakk>\n     \\<Longrightarrow> \\<exists>a\\<in>A. b = f a)", "by blast+"], ["", "lemma comp_surj_on: \"\n  \\<lbrakk> surj_on f A B; surj_on g B C \\<rbrakk> \\<Longrightarrow> surj_on (g \\<circ> f) A C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>surj_on f A B; surj_on g B C\\<rbrakk>\n    \\<Longrightarrow> surj_on (g \\<circ> f) A C", "unfolding comp_def surj_on_image_conv"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>B \\<subseteq> f ` A; C \\<subseteq> g ` B\\<rbrakk>\n    \\<Longrightarrow> C \\<subseteq> (\\<lambda>x. g (f x)) ` A", "by blast"], ["", "lemma surj_on_Un_right: \"surj_on f A (B1 \\<union> B2) = (surj_on f A B1 \\<and> surj_on f A B2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. surj_on f A (B1 \\<union> B2) = (surj_on f A B1 \\<and> surj_on f A B2)", "unfolding surj_on_image_conv"], ["proof (prove)\ngoal (1 subgoal):\n 1. (B1 \\<union> B2 \\<subseteq> f ` A) =\n    (B1 \\<subseteq> f ` A \\<and> B2 \\<subseteq> f ` A)", "by blast"], ["", "lemma surj_on_Un_left: \"\n  surj_on f (A1 \\<union> A2) B =\n  (\\<exists>B1. \\<exists>B2. B \\<subseteq> B1 \\<union> B2 \\<and> surj_on f A1 B1 \\<and> surj_on f A2 B2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. surj_on f (A1 \\<union> A2) B =\n    (\\<exists>B1 B2.\n        B \\<subseteq> B1 \\<union> B2 \\<and>\n        surj_on f A1 B1 \\<and> surj_on f A2 B2)", "unfolding surj_on_image_conv"], ["proof (prove)\ngoal (1 subgoal):\n 1. (B \\<subseteq> f ` (A1 \\<union> A2)) =\n    (\\<exists>B1 B2.\n        B \\<subseteq> B1 \\<union> B2 \\<and>\n        B1 \\<subseteq> f ` A1 \\<and> B2 \\<subseteq> f ` A2)", "apply (rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. B \\<subseteq> f ` (A1 \\<union> A2) \\<Longrightarrow>\n    \\<exists>B1 B2.\n       B \\<subseteq> B1 \\<union> B2 \\<and>\n       B1 \\<subseteq> f ` A1 \\<and> B2 \\<subseteq> f ` A2\n 2. \\<exists>B1 B2.\n       B \\<subseteq> B1 \\<union> B2 \\<and>\n       B1 \\<subseteq> f ` A1 \\<and> B2 \\<subseteq> f ` A2 \\<Longrightarrow>\n    B \\<subseteq> f ` (A1 \\<union> A2)", "apply (rule_tac x=\"f ` A1\" in exI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. B \\<subseteq> f ` (A1 \\<union> A2) \\<Longrightarrow>\n    \\<exists>B2.\n       B \\<subseteq> f ` A1 \\<union> B2 \\<and>\n       f ` A1 \\<subseteq> f ` A1 \\<and> B2 \\<subseteq> f ` A2\n 2. \\<exists>B1 B2.\n       B \\<subseteq> B1 \\<union> B2 \\<and>\n       B1 \\<subseteq> f ` A1 \\<and> B2 \\<subseteq> f ` A2 \\<Longrightarrow>\n    B \\<subseteq> f ` (A1 \\<union> A2)", "apply (rule_tac x=\"f ` A2\" in exI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. B \\<subseteq> f ` (A1 \\<union> A2) \\<Longrightarrow>\n    B \\<subseteq> f ` A1 \\<union> f ` A2 \\<and>\n    f ` A1 \\<subseteq> f ` A1 \\<and> f ` A2 \\<subseteq> f ` A2\n 2. \\<exists>B1 B2.\n       B \\<subseteq> B1 \\<union> B2 \\<and>\n       B1 \\<subseteq> f ` A1 \\<and> B2 \\<subseteq> f ` A2 \\<Longrightarrow>\n    B \\<subseteq> f ` (A1 \\<union> A2)", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>B1 B2.\n       B \\<subseteq> B1 \\<union> B2 \\<and>\n       B1 \\<subseteq> f ` A1 \\<and> B2 \\<subseteq> f ` A2 \\<Longrightarrow>\n    B \\<subseteq> f ` (A1 \\<union> A2)", "apply blast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma surj_on_diff_right: \"surj_on f A B \\<Longrightarrow> surj_on f A (B - B')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. surj_on f A B \\<Longrightarrow> surj_on f A (B - B')", "unfolding surj_on_conv"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>b\\<in>B. \\<exists>a\\<in>A. b = f a \\<Longrightarrow>\n    \\<forall>b\\<in>B - B'. \\<exists>a\\<in>A. b = f a", "by blast"], ["", "lemma surj_on_empty_right: \"surj_on f A {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. surj_on f A {}", "unfolding surj_on_conv"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>b\\<in>{}. \\<exists>a\\<in>A. b = f a", "by blast"], ["", "lemma surj_on_empty_left: \"surj_on f {} B = (B = {})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. surj_on f {} B = (B = {})", "unfolding surj_on_conv"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>b\\<in>B. \\<exists>a\\<in>{}. b = f a) = (B = {})", "by blast"], ["", "lemma surj_on_imageI: \"surj_on (g \\<circ> f) A B \\<Longrightarrow> surj_on g (f ` A) B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. surj_on (g \\<circ> f) A B \\<Longrightarrow> surj_on g (f ` A) B", "unfolding surj_on_conv"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>b\\<in>B.\n       \\<exists>a\\<in>A. b = (g \\<circ> f) a \\<Longrightarrow>\n    \\<forall>b\\<in>B. \\<exists>a\\<in>f ` A. b = g a", "by fastforce"], ["", "lemma surj_on_insert_right: \"surj_on f A (insert b B) = (surj_on f A B \\<and> surj_on f A {b})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. surj_on f A (insert b B) = (surj_on f A B \\<and> surj_on f A {b})", "unfolding surj_on_conv"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>b\\<in>insert b B. \\<exists>a\\<in>A. b = f a) =\n    ((\\<forall>b\\<in>B. \\<exists>a\\<in>A. b = f a) \\<and>\n     (\\<forall>b\\<in>{b}. \\<exists>a\\<in>A. b = f a))", "by blast"], ["", "lemma surj_on_insert_left: \"surj_on f (insert a A) B = (surj_on f A (B - {f a}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. surj_on f (insert a A) B = surj_on f A (B - {f a})", "unfolding surj_on_conv"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>b\\<in>B. \\<exists>a\\<in>insert a A. b = f a) =\n    (\\<forall>b\\<in>B - {f a}. \\<exists>a\\<in>A. b = f a)", "by blast"], ["", "lemma surj_on_subset_right: \"\\<lbrakk> surj_on f A B; B' \\<subseteq> B \\<rbrakk> \\<Longrightarrow> surj_on f A B'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>surj_on f A B; B' \\<subseteq> B\\<rbrakk>\n    \\<Longrightarrow> surj_on f A B'", "unfolding surj_on_conv"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>b\\<in>B. \\<exists>a\\<in>A. b = f a;\n     B' \\<subseteq> B\\<rbrakk>\n    \\<Longrightarrow> \\<forall>b\\<in>B'. \\<exists>a\\<in>A. b = f a", "by blast"], ["", "lemma surj_on_subset_left: \"\\<lbrakk> surj_on f A B; A \\<subseteq> A' \\<rbrakk> \\<Longrightarrow> surj_on f A' B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>surj_on f A B; A \\<subseteq> A'\\<rbrakk>\n    \\<Longrightarrow> surj_on f A' B", "unfolding surj_on_conv"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>b\\<in>B. \\<exists>a\\<in>A. b = f a;\n     A \\<subseteq> A'\\<rbrakk>\n    \\<Longrightarrow> \\<forall>b\\<in>B. \\<exists>a\\<in>A'. b = f a", "by blast"], ["", "lemma bij_betw_imp_surj_on: \"bij_betw f A B \\<Longrightarrow> surj_on f A B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bij_betw f A B \\<Longrightarrow> surj_on f A B", "unfolding bij_betw_def surj_on_image_conv"], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on f A \\<and> f ` A = B \\<Longrightarrow> B \\<subseteq> f ` A", "by simp"], ["", "lemma bij_betw_inj_on_surj_on_conv: \"\n  bij_betw f A B = (inj_on f A \\<and> surj_on f A B \\<and> f ` A \\<subseteq> B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bij_betw f A B =\n    (inj_on f A \\<and> surj_on f A B \\<and> f ` A \\<subseteq> B)", "unfolding bij_betw_def surj_on_image_conv"], ["proof (prove)\ngoal (1 subgoal):\n 1. (inj_on f A \\<and> f ` A = B) =\n    (inj_on f A \\<and> B \\<subseteq> f ` A \\<and> f ` A \\<subseteq> B)", "by blast"], ["", "subsubsection \\<open>Induction over natural sets\\<close>"], ["", "lemma image_nat_induct: \"\n  \\<lbrakk> P (f 0); \\<And>n. P (f n) \\<Longrightarrow> P (f (Suc n)); surj_on f UNIV I; a \\<in> I \\<rbrakk> \\<Longrightarrow> P a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P (f 0); \\<And>n. P (f n) \\<Longrightarrow> P (f (Suc n));\n     surj_on f UNIV I; a \\<in> I\\<rbrakk>\n    \\<Longrightarrow> P a", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>P (f 0); \\<And>n. P (f n) \\<Longrightarrow> P (f (Suc n));\n     surj_on f UNIV I; a \\<in> I\\<rbrakk>\n    \\<Longrightarrow> P a", "assume as_P0: \"P (f 0)\"\n    and  as_IA: \"\\<And>n. P (f n) \\<Longrightarrow> P (f (Suc n))\"\n    and  as_surj_f: \"surj_on f UNIV I\"\n    and  as_a: \"a \\<in> I\""], ["proof (state)\nthis:\n  P (f 0)\n  P (f ?n) \\<Longrightarrow> P (f (Suc ?n))\n  surj_on f UNIV I\n  a \\<in> I\n\ngoal (1 subgoal):\n 1. \\<lbrakk>P (f 0); \\<And>n. P (f n) \\<Longrightarrow> P (f (Suc n));\n     surj_on f UNIV I; a \\<in> I\\<rbrakk>\n    \\<Longrightarrow> P a", "have P_n:\"\\<And>n. P (f n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n. P (f n)", "apply (induct_tac n)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n. P (f 0)\n 2. \\<And>n na. P (f na) \\<Longrightarrow> P (f (Suc na))", "apply (simp only: as_P0)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n na. P (f na) \\<Longrightarrow> P (f (Suc na))", "apply (simp only: as_IA)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  P (f ?n)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>P (f 0); \\<And>n. P (f n) \\<Longrightarrow> P (f (Suc n));\n     surj_on f UNIV I; a \\<in> I\\<rbrakk>\n    \\<Longrightarrow> P a", "have \"\\<forall>x\\<in>I. \\<exists>n. x = f n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>I. \\<exists>n. x = f n", "using as_surj_f"], ["proof (prove)\nusing this:\n  surj_on f UNIV I\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>I. \\<exists>n. x = f n", "by (unfold surj_on_conv, blast)"], ["proof (state)\nthis:\n  \\<forall>x\\<in>I. \\<exists>n. x = f n\n\ngoal (1 subgoal):\n 1. \\<lbrakk>P (f 0); \\<And>n. P (f n) \\<Longrightarrow> P (f (Suc n));\n     surj_on f UNIV I; a \\<in> I\\<rbrakk>\n    \\<Longrightarrow> P a", "hence \"\\<exists>n. a = f n\""], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>I. \\<exists>n. x = f n\n\ngoal (1 subgoal):\n 1. \\<exists>n. a = f n", "using as_a"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>I. \\<exists>n. x = f n\n  a \\<in> I\n\ngoal (1 subgoal):\n 1. \\<exists>n. a = f n", "by blast"], ["proof (state)\nthis:\n  \\<exists>n. a = f n\n\ngoal (1 subgoal):\n 1. \\<lbrakk>P (f 0); \\<And>n. P (f n) \\<Longrightarrow> P (f (Suc n));\n     surj_on f UNIV I; a \\<in> I\\<rbrakk>\n    \\<Longrightarrow> P a", "thus \"P a\""], ["proof (prove)\nusing this:\n  \\<exists>n. a = f n\n\ngoal (1 subgoal):\n 1. P a", "using P_n"], ["proof (prove)\nusing this:\n  \\<exists>n. a = f n\n  P (f ?n)\n\ngoal (1 subgoal):\n 1. P a", "by blast"], ["proof (state)\nthis:\n  P a\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma nat_induct'[rule_format]: \"\n  \\<lbrakk> P n0; \\<And>n. \\<lbrakk> n0 \\<le> n;  P n \\<rbrakk> \\<Longrightarrow> P (Suc n); n0 \\<le> n \\<rbrakk> \\<Longrightarrow> P n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P n0;\n     \\<And>n. \\<lbrakk>n0 \\<le> n; P n\\<rbrakk> \\<Longrightarrow> P (Suc n);\n     n0 \\<le> n\\<rbrakk>\n    \\<Longrightarrow> P n", "by (insert nat_induct[where n=\"n-n0\" and P=\"\\<lambda>n. P (n0+n)\"], simp)"], ["", "lemma enat_induct: \"\n  \\<lbrakk> P 0; P \\<infinity>; \\<And>n. P n \\<Longrightarrow> P (eSuc n)\\<rbrakk> \\<Longrightarrow> P n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P 0; P \\<infinity>;\n     \\<And>n. P n \\<Longrightarrow> P (eSuc n)\\<rbrakk>\n    \\<Longrightarrow> P n", "apply (case_tac n)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>nat.\n       \\<lbrakk>P 0; P \\<infinity>;\n        \\<And>n. P n \\<Longrightarrow> P (eSuc n); n = enat nat\\<rbrakk>\n       \\<Longrightarrow> P n\n 2. \\<lbrakk>P 0; P \\<infinity>; \\<And>n. P n \\<Longrightarrow> P (eSuc n);\n     n = \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> P n", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>P 0; P \\<infinity>; \\<And>n. P n \\<Longrightarrow> P (eSuc n);\n     n = \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> P n\n 2. \\<And>nat.\n       \\<lbrakk>P 0; P \\<infinity>;\n        \\<And>n. P n \\<Longrightarrow> P (eSuc n); n = enat nat\\<rbrakk>\n       \\<Longrightarrow> P n", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>P 0; P \\<infinity>;\n        \\<And>n. P n \\<Longrightarrow> P (eSuc n); n = enat nat\\<rbrakk>\n       \\<Longrightarrow> P n", "apply (simp only: enat_defs)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>P (enat 0); P \\<infinity>;\n        \\<And>n.\n           P n \\<Longrightarrow>\n           P (case n of enat n \\<Rightarrow> enat (Suc n)\n              | \\<infinity> \\<Rightarrow> \\<infinity>);\n        n = enat nat\\<rbrakk>\n       \\<Longrightarrow> P (enat nat)", "apply (rename_tac n1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n1.\n       \\<lbrakk>P (enat 0); P \\<infinity>;\n        \\<And>n.\n           P n \\<Longrightarrow>\n           P (case n of enat n \\<Rightarrow> enat (Suc n)\n              | \\<infinity> \\<Rightarrow> \\<infinity>);\n        n = enat n1\\<rbrakk>\n       \\<Longrightarrow> P (enat n1)", "apply (induct_tac n1)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n1.\n       \\<lbrakk>P (enat 0); P \\<infinity>;\n        \\<And>n.\n           P n \\<Longrightarrow>\n           P (case n of enat n \\<Rightarrow> enat (Suc n)\n              | \\<infinity> \\<Rightarrow> \\<infinity>);\n        n = enat n1\\<rbrakk>\n       \\<Longrightarrow> P (enat 0)\n 2. \\<And>n1 na.\n       \\<lbrakk>P (enat 0); P \\<infinity>;\n        \\<And>n.\n           P n \\<Longrightarrow>\n           P (case n of enat n \\<Rightarrow> enat (Suc n)\n              | \\<infinity> \\<Rightarrow> \\<infinity>);\n        n = enat n1; P (enat na)\\<rbrakk>\n       \\<Longrightarrow> P (enat (Suc na))", "apply (simp add: enat.splits)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma eSuc_imp_Suc_aux_0:\n  \"\\<lbrakk> \\<And>n. P n \\<Longrightarrow> P (eSuc n); n0' \\<le> n'; P (enat n')\\<rbrakk> \\<Longrightarrow> P (enat (Suc n'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>n. P n \\<Longrightarrow> P (eSuc n); n0' \\<le> n';\n     P (enat n')\\<rbrakk>\n    \\<Longrightarrow> P (enat (Suc n'))", "by (simp only: enat_defs enat.splits)"], ["", "lemma eSuc_imp_Suc_aux_n0:\n  \"\\<lbrakk> \\<And>n. \\<lbrakk>enat n0' \\<le> n; P n\\<rbrakk> \\<Longrightarrow> P (eSuc n); n0' \\<le> n'; P (enat n')\\<rbrakk> \\<Longrightarrow> P (enat (Suc n'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>n.\n                \\<lbrakk>enat n0' \\<le> n; P n\\<rbrakk>\n                \\<Longrightarrow> P (eSuc n);\n     n0' \\<le> n'; P (enat n')\\<rbrakk>\n    \\<Longrightarrow> P (enat (Suc n'))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>n.\n                \\<lbrakk>enat n0' \\<le> n; P n\\<rbrakk>\n                \\<Longrightarrow> P (eSuc n);\n     n0' \\<le> n'; P (enat n')\\<rbrakk>\n    \\<Longrightarrow> P (enat (Suc n'))", "assume IA: \"\\<And>n. \\<lbrakk>enat n0' \\<le> n; P n\\<rbrakk> \\<Longrightarrow> P (eSuc n)\"\n    and n0_n: \"n0' \\<le> n'\"\n    and Pn: \"P (enat n')\""], ["proof (state)\nthis:\n  \\<lbrakk>enat n0' \\<le> ?n; P ?n\\<rbrakk> \\<Longrightarrow> P (eSuc ?n)\n  n0' \\<le> n'\n  P (enat n')\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>n.\n                \\<lbrakk>enat n0' \\<le> n; P n\\<rbrakk>\n                \\<Longrightarrow> P (eSuc n);\n     n0' \\<le> n'; P (enat n')\\<rbrakk>\n    \\<Longrightarrow> P (enat (Suc n'))", "from n0_n"], ["proof (chain)\npicking this:\n  n0' \\<le> n'", "have \"(enat n0' \\<le> enat n')\""], ["proof (prove)\nusing this:\n  n0' \\<le> n'\n\ngoal (1 subgoal):\n 1. enat n0' \\<le> enat n'", "by simp"], ["proof (state)\nthis:\n  enat n0' \\<le> enat n'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>n.\n                \\<lbrakk>enat n0' \\<le> n; P n\\<rbrakk>\n                \\<Longrightarrow> P (eSuc n);\n     n0' \\<le> n'; P (enat n')\\<rbrakk>\n    \\<Longrightarrow> P (enat (Suc n'))", "with Pn IA"], ["proof (chain)\npicking this:\n  P (enat n')\n  \\<lbrakk>enat n0' \\<le> ?n; P ?n\\<rbrakk> \\<Longrightarrow> P (eSuc ?n)\n  enat n0' \\<le> enat n'", "have \"P (eSuc (enat n'))\""], ["proof (prove)\nusing this:\n  P (enat n')\n  \\<lbrakk>enat n0' \\<le> ?n; P ?n\\<rbrakk> \\<Longrightarrow> P (eSuc ?n)\n  enat n0' \\<le> enat n'\n\ngoal (1 subgoal):\n 1. P (eSuc (enat n'))", "by blast"], ["proof (state)\nthis:\n  P (eSuc (enat n'))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>n.\n                \\<lbrakk>enat n0' \\<le> n; P n\\<rbrakk>\n                \\<Longrightarrow> P (eSuc n);\n     n0' \\<le> n'; P (enat n')\\<rbrakk>\n    \\<Longrightarrow> P (enat (Suc n'))", "thus \"P (enat (Suc n'))\""], ["proof (prove)\nusing this:\n  P (eSuc (enat n'))\n\ngoal (1 subgoal):\n 1. P (enat (Suc n'))", "by (simp only: eSuc_enat)"], ["proof (state)\nthis:\n  P (enat (Suc n'))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma enat_induct': \"\n  \\<lbrakk> P (n0::enat); P \\<infinity>; \\<And>n. \\<lbrakk> n0 \\<le> n;  P n \\<rbrakk> \\<Longrightarrow> P (eSuc n); n0 \\<le> n \\<rbrakk> \\<Longrightarrow> P n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P n0; P \\<infinity>;\n     \\<And>n.\n        \\<lbrakk>n0 \\<le> n; P n\\<rbrakk> \\<Longrightarrow> P (eSuc n);\n     n0 \\<le> n\\<rbrakk>\n    \\<Longrightarrow> P n", "apply (case_tac n)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>nat.\n       \\<lbrakk>P n0; P \\<infinity>;\n        \\<And>n.\n           \\<lbrakk>n0 \\<le> n; P n\\<rbrakk> \\<Longrightarrow> P (eSuc n);\n        n0 \\<le> n; n = enat nat\\<rbrakk>\n       \\<Longrightarrow> P n\n 2. \\<lbrakk>P n0; P \\<infinity>;\n     \\<And>n.\n        \\<lbrakk>n0 \\<le> n; P n\\<rbrakk> \\<Longrightarrow> P (eSuc n);\n     n0 \\<le> n; n = \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> P n", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>P n0; P \\<infinity>;\n     \\<And>n.\n        \\<lbrakk>n0 \\<le> n; P n\\<rbrakk> \\<Longrightarrow> P (eSuc n);\n     n0 \\<le> n; n = \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> P n\n 2. \\<And>nat.\n       \\<lbrakk>P n0; P \\<infinity>;\n        \\<And>n.\n           \\<lbrakk>n0 \\<le> n; P n\\<rbrakk> \\<Longrightarrow> P (eSuc n);\n        n0 \\<le> n; n = enat nat\\<rbrakk>\n       \\<Longrightarrow> P n", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>P n0; P \\<infinity>;\n        \\<And>n.\n           \\<lbrakk>n0 \\<le> n; P n\\<rbrakk> \\<Longrightarrow> P (eSuc n);\n        n0 \\<le> n; n = enat nat\\<rbrakk>\n       \\<Longrightarrow> P n", "apply (case_tac n0)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>nat nata.\n       \\<lbrakk>P n0; P \\<infinity>;\n        \\<And>n.\n           \\<lbrakk>n0 \\<le> n; P n\\<rbrakk> \\<Longrightarrow> P (eSuc n);\n        n0 \\<le> n; n = enat nat; n0 = enat nata\\<rbrakk>\n       \\<Longrightarrow> P n\n 2. \\<And>nat.\n       \\<lbrakk>P n0; P \\<infinity>;\n        \\<And>n.\n           \\<lbrakk>n0 \\<le> n; P n\\<rbrakk> \\<Longrightarrow> P (eSuc n);\n        n0 \\<le> n; n = enat nat; n0 = \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> P n", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>nat.\n       \\<lbrakk>P n0; P \\<infinity>;\n        \\<And>n.\n           \\<lbrakk>n0 \\<le> n; P n\\<rbrakk> \\<Longrightarrow> P (eSuc n);\n        n0 \\<le> n; n = enat nat; n0 = \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> P n\n 2. \\<And>nat nata.\n       \\<lbrakk>P n0; P \\<infinity>;\n        \\<And>n.\n           \\<lbrakk>n0 \\<le> n; P n\\<rbrakk> \\<Longrightarrow> P (eSuc n);\n        n0 \\<le> n; n = enat nat; n0 = enat nata\\<rbrakk>\n       \\<Longrightarrow> P n", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat nata.\n       \\<lbrakk>P n0; P \\<infinity>;\n        \\<And>n.\n           \\<lbrakk>n0 \\<le> n; P n\\<rbrakk> \\<Longrightarrow> P (eSuc n);\n        n0 \\<le> n; n = enat nat; n0 = enat nata\\<rbrakk>\n       \\<Longrightarrow> P n", "apply (rename_tac n' n0', simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n' n0'.\n       \\<lbrakk>P (enat n0'); P \\<infinity>;\n        \\<And>n.\n           \\<lbrakk>enat n0' \\<le> n; P n\\<rbrakk>\n           \\<Longrightarrow> P (eSuc n);\n        n0' \\<le> n'; n = enat n'; n0 = enat n0'\\<rbrakk>\n       \\<Longrightarrow> P (enat n')", "apply (rule_tac ?n0.0=\"n0'\" and n=n' and P=\"\\<lambda>n. P (enat n)\" in nat_induct')"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>n' n0'.\n       \\<lbrakk>P (enat n0'); P \\<infinity>;\n        \\<And>n.\n           \\<lbrakk>enat n0' \\<le> n; P n\\<rbrakk>\n           \\<Longrightarrow> P (eSuc n);\n        n0' \\<le> n'; n = enat n'; n0 = enat n0'\\<rbrakk>\n       \\<Longrightarrow> P (enat n0')\n 2. \\<And>n' n0' na.\n       \\<lbrakk>P (enat n0'); P \\<infinity>;\n        \\<And>n.\n           \\<lbrakk>enat n0' \\<le> n; P n\\<rbrakk>\n           \\<Longrightarrow> P (eSuc n);\n        n0' \\<le> n'; n = enat n'; n0 = enat n0'; n0' \\<le> na;\n        P (enat na)\\<rbrakk>\n       \\<Longrightarrow> P (enat (Suc na))\n 3. \\<And>n' n0'.\n       \\<lbrakk>P (enat n0'); P \\<infinity>;\n        \\<And>n.\n           \\<lbrakk>enat n0' \\<le> n; P n\\<rbrakk>\n           \\<Longrightarrow> P (eSuc n);\n        n0' \\<le> n'; n = enat n'; n0 = enat n0'\\<rbrakk>\n       \\<Longrightarrow> n0' \\<le> n'", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n' n0' na.\n       \\<lbrakk>P (enat n0'); P \\<infinity>;\n        \\<And>n.\n           \\<lbrakk>enat n0' \\<le> n; P n\\<rbrakk>\n           \\<Longrightarrow> P (eSuc n);\n        n0' \\<le> n'; n = enat n'; n0 = enat n0'; n0' \\<le> na;\n        P (enat na)\\<rbrakk>\n       \\<Longrightarrow> P (enat (Suc na))\n 2. \\<And>n' n0'.\n       \\<lbrakk>P (enat n0'); P \\<infinity>;\n        \\<And>n.\n           \\<lbrakk>enat n0' \\<le> n; P n\\<rbrakk>\n           \\<Longrightarrow> P (eSuc n);\n        n0' \\<le> n'; n = enat n'; n0 = enat n0'\\<rbrakk>\n       \\<Longrightarrow> n0' \\<le> n'", "apply (simp add: eSuc_enat[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n' n0'.\n       \\<lbrakk>P (enat n0'); P \\<infinity>;\n        \\<And>n.\n           \\<lbrakk>enat n0' \\<le> n; P n\\<rbrakk>\n           \\<Longrightarrow> P (eSuc n);\n        n0' \\<le> n'; n = enat n'; n0 = enat n0'\\<rbrakk>\n       \\<Longrightarrow> n0' \\<le> n'", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma wf_less_interval:\"\n  wf { (x,y). x \\<in> (I::nat set) \\<and> y \\<in> I \\<and> x < y }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf {(x, y). x \\<in> I \\<and> y \\<in> I \\<and> x < y}", "apply (rule wf_subset[where\n  p=\"{ (x,y). x \\<in> I \\<and> y \\<in> I \\<and> x < y }\" and\n  r=\"{(x,y). x < y}\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. wf {(x, y). x < y}\n 2. {(x, y). x \\<in> I \\<and> y \\<in> I \\<and> x < y}\n    \\<subseteq> {(x, y). x < y}", "apply (rule wf_less)"], ["proof (prove)\ngoal (1 subgoal):\n 1. {(x, y). x \\<in> I \\<and> y \\<in> I \\<and> x < y}\n    \\<subseteq> {(x, y). x < y}", "apply blast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma interval_induct: \"\n  \\<lbrakk> \\<And>x. \\<forall>y. (x\\<in>(I::nat set) \\<and> y \\<in> I \\<and> y < x \\<longrightarrow> P y) \\<Longrightarrow> P x \\<rbrakk>\n  \\<Longrightarrow> P a\"\n  (is \"\\<lbrakk> \\<And>x. \\<forall>y. ?IA x y \\<Longrightarrow> P x \\<rbrakk> \\<Longrightarrow> P a\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<forall>y.\n           x \\<in> I \\<and> y \\<in> I \\<and> y < x \\<longrightarrow>\n           P y \\<Longrightarrow>\n        P x) \\<Longrightarrow>\n    P a", "apply (rule_tac r=\"{ (x,y). x \\<in> I \\<and> y \\<in> I \\<and> x < y }\" in wf_induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. (\\<And>x.\n        \\<forall>y.\n           x \\<in> I \\<and> y \\<in> I \\<and> y < x \\<longrightarrow>\n           P y \\<Longrightarrow>\n        P x) \\<Longrightarrow>\n    wf {(x, y). x \\<in> I \\<and> y \\<in> I \\<and> x < y}\n 2. \\<And>x.\n       \\<lbrakk>\\<And>x.\n                   \\<forall>y.\n                      x \\<in> I \\<and>\n                      y \\<in> I \\<and> y < x \\<longrightarrow>\n                      P y \\<Longrightarrow>\n                   P x;\n        \\<forall>y.\n           (y, x)\n           \\<in> {(x, y).\n                  x \\<in> I \\<and> y \\<in> I \\<and> x < y} \\<longrightarrow>\n           P y\\<rbrakk>\n       \\<Longrightarrow> P x", "apply (rule wf_less_interval)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>x.\n                   \\<forall>y.\n                      x \\<in> I \\<and>\n                      y \\<in> I \\<and> y < x \\<longrightarrow>\n                      P y \\<Longrightarrow>\n                   P x;\n        \\<forall>y.\n           (y, x)\n           \\<in> {(x, y).\n                  x \\<in> I \\<and> y \\<in> I \\<and> x < y} \\<longrightarrow>\n           P y\\<rbrakk>\n       \\<Longrightarrow> P x", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "corollary interval_induct_rule:\"\n  \\<lbrakk> \\<And>x. (\\<And>y. (x\\<in>(I::nat set) \\<and> y \\<in> I \\<and> y < x \\<Longrightarrow> P y)) \\<Longrightarrow> P x \\<rbrakk>\n  \\<Longrightarrow> P a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x.\n        (\\<And>y.\n            x \\<in> I \\<and> y \\<in> I \\<and> y < x \\<Longrightarrow>\n            P y) \\<Longrightarrow>\n        P x) \\<Longrightarrow>\n    P a", "by (blast intro: interval_induct)"], ["", "subsubsection \\<open>Monotonicity and injectivity of artithmetic operators\\<close>"], ["", "lemma add_left_inj: \"inj (\\<lambda>x. n + (x::'a::cancel_ab_semigroup_add))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj ((+) n)", "by (simp add: inj_on_def)"], ["", "lemma add_right_inj: \"inj (\\<lambda>x. x + (n::'a::cancel_ab_semigroup_add))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj (\\<lambda>x. x + n)", "by (simp add: inj_on_def)"], ["", "lemma mult_left_inj: \"0 < n \\<Longrightarrow> inj (\\<lambda>x. (n::nat) * x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < n \\<Longrightarrow> inj ((*) n)", "by (simp add: inj_on_def)"], ["", "lemma mult_right_inj: \"0 < n \\<Longrightarrow> inj (\\<lambda>x. x * (n::nat))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < n \\<Longrightarrow> inj (\\<lambda>x. x * n)", "by (simp add: inj_on_def)"], ["", "lemma sub_left_inj_on: \"inj_on (\\<lambda>x. (x::nat) - k) {k..}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on (\\<lambda>x. x - k) {k..}", "by (rule inj_onI, simp)"], ["", "lemma sub_right_inj_on: \"inj_on (\\<lambda>x. k - (x::nat)) {..k}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on ((-) k) {..k}", "by (rule inj_onI, simp)"], ["", "lemma add_left_strict_mono: \"strict_mono (\\<lambda>x. n + (x::'a::ordered_cancel_ab_semigroup_add))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strict_mono ((+) n)", "by (unfold strict_mono_def, clarify, rule add_strict_left_mono)"], ["", "lemma add_right_strict_mono: \"strict_mono (\\<lambda>x. x + (n::'a::ordered_cancel_ab_semigroup_add))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strict_mono (\\<lambda>x. x + n)", "by (unfold strict_mono_def, clarify, rule add_strict_right_mono)"], ["", "lemma mult_left_strict_mono: \"0 < n \\<Longrightarrow> strict_mono (\\<lambda>x. n * (x::nat))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < n \\<Longrightarrow> strict_mono ((*) n)", "by (unfold strict_mono_def, clarify, simp)"], ["", "lemma mult_right_strict_mono: \"0 < n \\<Longrightarrow> strict_mono (\\<lambda>x. x * (n::nat))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < n \\<Longrightarrow> strict_mono (\\<lambda>x. x * n)", "by (unfold strict_mono_def, clarify, simp)"], ["", "lemma sub_left_strict_mono_on: \"strict_mono_on (\\<lambda>x. (x::nat) - k) {k..}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SetInterval2.strict_mono_on (\\<lambda>x. x - k) {k..}", "apply (rule strict_mono_on_mono_on_conv[THEN iffD2], rule conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. SetInterval2.mono_on (\\<lambda>x. x - k) {k..}\n 2. inj_on (\\<lambda>x. x - k) {k..}", "apply (unfold mono_on_def, clarify, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on (\\<lambda>x. x - k) {k..}", "apply (rule sub_left_inj_on)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma div_right_strict_mono_on: \"\n  \\<lbrakk> 0 < (k::nat); \\<forall>x\\<in>I. \\<forall>y\\<in>I. x < y \\<longrightarrow> x + k \\<le> y \\<rbrakk> \\<Longrightarrow>\n  strict_mono_on (\\<lambda>x. x div k) I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < k;\n     \\<forall>x\\<in>I.\n        \\<forall>y\\<in>I. x < y \\<longrightarrow> x + k \\<le> y\\<rbrakk>\n    \\<Longrightarrow> SetInterval2.strict_mono_on (\\<lambda>x. x div k) I", "apply (unfold strict_mono_on_def, clarify)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>0 < k;\n        \\<forall>x\\<in>I.\n           \\<forall>y\\<in>I. x < y \\<longrightarrow> x + k \\<le> y;\n        a \\<in> I; b \\<in> I; a < b\\<rbrakk>\n       \\<Longrightarrow> a div k < b div k", "apply (fastforce dest: div_le_mono[of _ _ k])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma mod_eq_div_right_strict_mono_on: \"\n  \\<lbrakk> 0 < (k::nat); \\<forall>x\\<in>I. \\<forall>y\\<in>I. x mod k = y mod k \\<rbrakk> \\<Longrightarrow>\n  strict_mono_on (\\<lambda>x. x div k) I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < k;\n     \\<forall>x\\<in>I. \\<forall>y\\<in>I. x mod k = y mod k\\<rbrakk>\n    \\<Longrightarrow> SetInterval2.strict_mono_on (\\<lambda>x. x div k) I", "apply (rule div_right_strict_mono_on, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < k;\n     \\<forall>x\\<in>I. \\<forall>y\\<in>I. x mod k = y mod k\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x\\<in>I.\n                         \\<forall>y\\<in>I.\n                            x < y \\<longrightarrow> x + k \\<le> y", "apply (blast intro: less_mod_eq_imp_add_divisor_le)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "corollary div_right_inj_on: \"\n  \\<lbrakk> 0 < (k::nat); \\<forall>x\\<in>I. \\<forall>y\\<in>I. x < y \\<longrightarrow> x + k \\<le> y \\<rbrakk> \\<Longrightarrow>\n  inj_on (\\<lambda>x. x div k) I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < k;\n     \\<forall>x\\<in>I.\n        \\<forall>y\\<in>I. x < y \\<longrightarrow> x + k \\<le> y\\<rbrakk>\n    \\<Longrightarrow> inj_on (\\<lambda>x. x div k) I", "by (rule strict_mono_on_imp_inj_on[OF div_right_strict_mono_on])"], ["", "corollary mod_eq_imp_div_right_inj_on: \"\n  \\<lbrakk> 0 < (k::nat); \\<forall>x\\<in>I. \\<forall>y\\<in>I. x mod k = y mod k \\<rbrakk> \\<Longrightarrow>\n  inj_on (\\<lambda>x. x div k) I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < k;\n     \\<forall>x\\<in>I. \\<forall>y\\<in>I. x mod k = y mod k\\<rbrakk>\n    \\<Longrightarrow> inj_on (\\<lambda>x. x div k) I", "by (rule strict_mono_on_imp_inj_on[OF mod_eq_div_right_strict_mono_on])"], ["", "subsection \\<open>\\<open>Min\\<close> and \\<open>Max\\<close> elements of a set\\<close>"], ["", "text \\<open>A special minimum operator is required for dealing with infinite wellordered sets\n  because the standard operator @{term \"Min\"} is usable only with finite sets.\\<close>"], ["", "definition iMin :: \"'a::wellorder set \\<Rightarrow> 'a\"\n  where \"iMin I \\<equiv> LEAST x. x \\<in> I\""], ["", "subsubsection \\<open>Basic results, as for \\<open>Least\\<close>\\<close>"], ["", "lemma iMinI: \"k \\<in> I \\<Longrightarrow> iMin I \\<in> I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k \\<in> I \\<Longrightarrow> iMin I \\<in> I", "unfolding iMin_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. k \\<in> I \\<Longrightarrow> (LEAST x. x \\<in> I) \\<in> I", "by (rule_tac k=k in LeastI)"], ["", "lemma iMinI_ex: \"\\<exists>x. x \\<in> I \\<Longrightarrow> iMin I \\<in> I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> I \\<Longrightarrow> iMin I \\<in> I", "by (blast intro: iMinI)"], ["", "corollary  iMinI_ex2: \"I \\<noteq> {} \\<Longrightarrow> iMin I \\<in> I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. I \\<noteq> {} \\<Longrightarrow> iMin I \\<in> I", "by (blast intro: iMinI_ex)"], ["", "lemma iMinI2: \"\\<lbrakk> k \\<in> I; \\<And>x. x \\<in> I \\<Longrightarrow> P x \\<rbrakk> \\<Longrightarrow> P (iMin I)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>k \\<in> I; \\<And>x. x \\<in> I \\<Longrightarrow> P x\\<rbrakk>\n    \\<Longrightarrow> P (iMin I)", "by (blast intro: iMinI)"], ["", "lemma iMinI2_ex: \"\\<lbrakk> \\<exists>x. x \\<in> I; \\<And>x. x \\<in> I \\<Longrightarrow> P x \\<rbrakk> \\<Longrightarrow> P (iMin I)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<exists>x. x \\<in> I;\n     \\<And>x. x \\<in> I \\<Longrightarrow> P x\\<rbrakk>\n    \\<Longrightarrow> P (iMin I)", "by (blast intro: iMinI_ex)"], ["", "lemma iMinI2_ex2: \"\\<lbrakk> I \\<noteq> {} ; \\<And>x. x \\<in> I \\<Longrightarrow> P x \\<rbrakk> \\<Longrightarrow> P (iMin I)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>I \\<noteq> {};\n     \\<And>x. x \\<in> I \\<Longrightarrow> P x\\<rbrakk>\n    \\<Longrightarrow> P (iMin I)", "by (blast intro: iMinI_ex2)"], ["", "lemma iMin_le[dest]: \"k \\<in> I \\<Longrightarrow> iMin I \\<le> k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k \\<in> I \\<Longrightarrow> iMin I \\<le> k", "by (simp only: iMin_def Least_le)"], ["", "lemma iMin_neq_imp_greater[dest]: \"\\<lbrakk> k \\<in> I; k \\<noteq> iMin I \\<rbrakk> \\<Longrightarrow> iMin I < k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>k \\<in> I; k \\<noteq> iMin I\\<rbrakk>\n    \\<Longrightarrow> iMin I < k", "by (rule order_neq_le_trans[OF not_sym iMin_le])"], ["", "lemma iMin_mono: \"\n  \\<lbrakk> mono f; \\<exists>x. x \\<in> I \\<rbrakk> \\<Longrightarrow> iMin (f ` I) = f (iMin I)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>mono f; \\<exists>x. x \\<in> I\\<rbrakk>\n    \\<Longrightarrow> iMin (f ` I) = f (iMin I)", "apply (unfold iMin_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>mono f; \\<exists>x. x \\<in> I\\<rbrakk>\n    \\<Longrightarrow> (LEAST x. x \\<in> f ` I) = f (LEAST x. x \\<in> I)", "apply (rule Least_mono[of f I], simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>mono f; \\<exists>x. x \\<in> I\\<rbrakk>\n    \\<Longrightarrow> \\<exists>x\\<in>I. \\<forall>xa\\<in>I. x \\<le> xa", "apply (rule_tac x=\"iMin I\" in bexI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>mono f; \\<exists>x. x \\<in> I\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x\\<in>I. iMin I \\<le> x\n 2. \\<lbrakk>mono f; \\<exists>x. x \\<in> I\\<rbrakk>\n    \\<Longrightarrow> iMin I \\<in> I", "apply (simp add: iMin_le)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>mono f; \\<exists>x. x \\<in> I\\<rbrakk>\n    \\<Longrightarrow> iMin I \\<in> I", "apply (simp add: iMinI_ex)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "corollary iMin_mono2: \"\n  \\<lbrakk> mono f; I \\<noteq> {} \\<rbrakk> \\<Longrightarrow> iMin (f ` I) = f (iMin I)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>mono f; I \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> iMin (f ` I) = f (iMin I)", "by (blast intro: iMin_mono)"], ["", "lemma not_less_iMin: \"k < iMin I \\<Longrightarrow> k \\<notin> I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k < iMin I \\<Longrightarrow> k \\<notin> I", "unfolding iMin_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. k < (LEAST x. x \\<in> I) \\<Longrightarrow> k \\<notin> I", "by (rule not_less_Least)"], ["", "lemma Collect_not_less_iMin: \"k < iMin {x. P x} \\<Longrightarrow> \\<not> P k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k < iMin {x. P x} \\<Longrightarrow> \\<not> P k", "by (drule not_less_iMin, blast)"], ["", "lemma Collect_iMin_le: \"P k \\<Longrightarrow> iMin {x. P x} \\<le> k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P k \\<Longrightarrow> iMin {x. P x} \\<le> k", "by (rule iMin_le, blast)"], ["", "lemma Collect_minI: \"\\<lbrakk> k \\<in> I; P (k::('a::wellorder)) \\<rbrakk> \\<Longrightarrow> \\<exists>x\\<in>I. P x \\<and> (\\<forall>y\\<in>I. y < x \\<longrightarrow> \\<not> P y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>k \\<in> I; P k\\<rbrakk>\n    \\<Longrightarrow> \\<exists>x\\<in>I.\n                         P x \\<and>\n                         (\\<forall>y\\<in>I.\n                             y < x \\<longrightarrow> \\<not> P y)", "apply (rule_tac x=\"iMin {y \\<in> I. P y}\" in bexI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>k \\<in> I; P k\\<rbrakk>\n    \\<Longrightarrow> P (iMin {y \\<in> I. P y}) \\<and>\n                      (\\<forall>y\\<in>I.\n                          y < iMin {y \\<in> I. P y} \\<longrightarrow>\n                          \\<not> P y)\n 2. \\<lbrakk>k \\<in> I; P k\\<rbrakk>\n    \\<Longrightarrow> iMin {y \\<in> I. P y} \\<in> I", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>k \\<in> I; P k\\<rbrakk>\n    \\<Longrightarrow> iMin {y \\<in> I. P y} \\<in> I\n 2. \\<lbrakk>k \\<in> I; P k\\<rbrakk>\n    \\<Longrightarrow> P (iMin {y \\<in> I. P y}) \\<and>\n                      (\\<forall>y\\<in>I.\n                          y < iMin {y \\<in> I. P y} \\<longrightarrow>\n                          \\<not> P y)", "apply (rule subsetD[OF _ iMinI, OF Collect_is_subset], blast)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>k \\<in> I; P k\\<rbrakk>\n    \\<Longrightarrow> P (iMin {y \\<in> I. P y}) \\<and>\n                      (\\<forall>y\\<in>I.\n                          y < iMin {y \\<in> I. P y} \\<longrightarrow>\n                          \\<not> P y)", "apply (rule conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>k \\<in> I; P k\\<rbrakk>\n    \\<Longrightarrow> P (iMin {y \\<in> I. P y})\n 2. \\<lbrakk>k \\<in> I; P k\\<rbrakk>\n    \\<Longrightarrow> \\<forall>y\\<in>I.\n                         y < iMin {y \\<in> I. P y} \\<longrightarrow>\n                         \\<not> P y", "apply (blast intro: iMinI2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>k \\<in> I; P k\\<rbrakk>\n    \\<Longrightarrow> \\<forall>y\\<in>I.\n                         y < iMin {y \\<in> I. P y} \\<longrightarrow>\n                         \\<not> P y", "apply (blast dest: not_less_iMin)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "corollary Collect_minI_ex: \"\\<exists>k\\<in>I. P (k::('a::wellorder)) \\<Longrightarrow> \\<exists>x\\<in>I. P x \\<and> (\\<forall>y\\<in>I. y < x \\<longrightarrow> \\<not> P y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>k\\<in>I. P k \\<Longrightarrow>\n    \\<exists>x\\<in>I.\n       P x \\<and> (\\<forall>y\\<in>I. y < x \\<longrightarrow> \\<not> P y)", "by (erule bexE, rule Collect_minI)"], ["", "corollary Collect_minI_ex2: \"{k\\<in>I. P (k::('a::wellorder))} \\<noteq> {} \\<Longrightarrow> \\<exists>x\\<in>I. P x \\<and> (\\<forall>y\\<in>I. y < x \\<longrightarrow> \\<not> P y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {k \\<in> I. P k} \\<noteq> {} \\<Longrightarrow>\n    \\<exists>x\\<in>I.\n       P x \\<and> (\\<forall>y\\<in>I. y < x \\<longrightarrow> \\<not> P y)", "by (drule ex_in_conv[THEN iffD2], blast intro: Collect_minI)"], ["", "lemma iMin_the:  \"iMin I = (THE x. x \\<in> I \\<and> (\\<forall>y. y \\<in> I \\<longrightarrow> x \\<le> y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. iMin I =\n    (THE x.\n        x \\<in> I \\<and>\n        (\\<forall>y. y \\<in> I \\<longrightarrow> x \\<le> y))", "by (simp add: iMin_def Least_def)"], ["", "lemma iMin_the2: \"iMin I = (THE x. x \\<in> I \\<and> (\\<forall>y\\<in>I. x \\<le> y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. iMin I = (THE x. x \\<in> I \\<and> (\\<forall>y\\<in>I. x \\<le> y))", "apply (simp add: iMin_the)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (THE x.\n        x \\<in> I \\<and>\n        (\\<forall>y. y \\<in> I \\<longrightarrow> x \\<le> y)) =\n    (THE x. x \\<in> I \\<and> (\\<forall>y\\<in>I. x \\<le> y))", "apply (subgoal_tac \"\\<And>x. (\\<forall>y \\<in> I. x \\<le> y) = (\\<forall>y. y \\<in> I \\<longrightarrow> x \\<le> y) \")"], ["proof (prove)\ngoal (2 subgoals):\n 1. (\\<And>x.\n        (\\<forall>y\\<in>I. x \\<le> y) =\n        (\\<forall>y.\n            y \\<in> I \\<longrightarrow> x \\<le> y)) \\<Longrightarrow>\n    (THE x.\n        x \\<in> I \\<and>\n        (\\<forall>y. y \\<in> I \\<longrightarrow> x \\<le> y)) =\n    (THE x. x \\<in> I \\<and> (\\<forall>y\\<in>I. x \\<le> y))\n 2. \\<And>x.\n       (\\<forall>y\\<in>I. x \\<le> y) =\n       (\\<forall>y. y \\<in> I \\<longrightarrow> x \\<le> y)", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       (\\<forall>y\\<in>I. x \\<le> y) =\n       (\\<forall>y. y \\<in> I \\<longrightarrow> x \\<le> y)\n 2. (\\<And>x.\n        (\\<forall>y\\<in>I. x \\<le> y) =\n        (\\<forall>y.\n            y \\<in> I \\<longrightarrow> x \\<le> y)) \\<Longrightarrow>\n    (THE x.\n        x \\<in> I \\<and>\n        (\\<forall>y. y \\<in> I \\<longrightarrow> x \\<le> y)) =\n    (THE x. x \\<in> I \\<and> (\\<forall>y\\<in>I. x \\<le> y))", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x.\n        (\\<forall>y\\<in>I. x \\<le> y) =\n        (\\<forall>y.\n            y \\<in> I \\<longrightarrow> x \\<le> y)) \\<Longrightarrow>\n    (THE x.\n        x \\<in> I \\<and>\n        (\\<forall>y. y \\<in> I \\<longrightarrow> x \\<le> y)) =\n    (THE x. x \\<in> I \\<and> (\\<forall>y\\<in>I. x \\<le> y))", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iMin_equality: \"\n  \\<lbrakk> k \\<in> I; \\<And>x. x \\<in> I \\<Longrightarrow> k \\<le> x \\<rbrakk> \\<Longrightarrow> iMin I = k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>k \\<in> I;\n     \\<And>x. x \\<in> I \\<Longrightarrow> k \\<le> x\\<rbrakk>\n    \\<Longrightarrow> iMin I = k", "unfolding iMin_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>k \\<in> I;\n     \\<And>x. x \\<in> I \\<Longrightarrow> k \\<le> x\\<rbrakk>\n    \\<Longrightarrow> (LEAST x. x \\<in> I) = k", "by (blast intro: Least_equality)"], ["", "lemma iMin_mono_on: \"\n  \\<lbrakk> mono_on f I; \\<exists>x. x \\<in> I \\<rbrakk> \\<Longrightarrow> iMin (f ` I) = f (iMin I)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>SetInterval2.mono_on f I; \\<exists>x. x \\<in> I\\<rbrakk>\n    \\<Longrightarrow> iMin (f ` I) = f (iMin I)", "apply (unfold mono_on_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>a\\<in>I.\n                \\<forall>b\\<in>I. a \\<le> b \\<longrightarrow> f a \\<le> f b;\n     \\<exists>x. x \\<in> I\\<rbrakk>\n    \\<Longrightarrow> iMin (f ` I) = f (iMin I)", "apply (rule iMin_equality)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>a\\<in>I.\n                \\<forall>b\\<in>I. a \\<le> b \\<longrightarrow> f a \\<le> f b;\n     \\<exists>x. x \\<in> I\\<rbrakk>\n    \\<Longrightarrow> f (iMin I) \\<in> f ` I\n 2. \\<And>x.\n       \\<lbrakk>\\<forall>a\\<in>I.\n                   \\<forall>b\\<in>I.\n                      a \\<le> b \\<longrightarrow> f a \\<le> f b;\n        \\<exists>x. x \\<in> I; x \\<in> f ` I\\<rbrakk>\n       \\<Longrightarrow> f (iMin I) \\<le> x", "apply (blast intro: iMinI_ex)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iMin_mono_on2: \"\n  \\<lbrakk> mono_on f I; I \\<noteq> {} \\<rbrakk> \\<Longrightarrow> iMin (f ` I) = f (iMin I)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>SetInterval2.mono_on f I; I \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> iMin (f ` I) = f (iMin I)", "by (rule iMin_mono_on, blast+)"], ["", "lemma iMinI2_order:\"\n  \\<lbrakk> k \\<in> I; \\<And>y. y \\<in> I \\<Longrightarrow> k \\<le> y;\n    \\<And>x. \\<lbrakk> x \\<in> I; \\<forall>y\\<in>I. x \\<le> y \\<rbrakk> \\<Longrightarrow> P x \\<rbrakk> \\<Longrightarrow>\n  P (iMin I)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>k \\<in> I; \\<And>y. y \\<in> I \\<Longrightarrow> k \\<le> y;\n     \\<And>x.\n        \\<lbrakk>x \\<in> I; \\<forall>y\\<in>I. x \\<le> y\\<rbrakk>\n        \\<Longrightarrow> P x\\<rbrakk>\n    \\<Longrightarrow> P (iMin I)", "by (simp add: iMin_def LeastI2_order)"], ["", "lemma wellorder_iMin_lemma: \"\n  k \\<in> I \\<Longrightarrow> iMin I \\<in> I \\<and> iMin I \\<le> k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k \\<in> I \\<Longrightarrow> iMin I \\<in> I \\<and> iMin I \\<le> k", "by (blast intro: iMinI iMin_le)"], ["", "lemma iMin_Min_conv: \"\n  \\<lbrakk> finite I; I \\<noteq> {} \\<rbrakk> \\<Longrightarrow> iMin I = Min I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite I; I \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> iMin I = Min I", "apply (rule order_antisym)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>finite I; I \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> iMin I \\<le> Min I\n 2. \\<lbrakk>finite I; I \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> Min I \\<le> iMin I", "apply (rule Min_ge_iff[THEN iffD2], assumption+)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>finite I; I \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> \\<forall>a\\<in>I. iMin I \\<le> a\n 2. \\<lbrakk>finite I; I \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> Min I \\<le> iMin I", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite I; I \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> Min I \\<le> iMin I", "apply (rule Min_le_iff[THEN iffD2], assumption+)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite I; I \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a\\<in>I. a \\<le> iMin I", "apply (blast intro: iMinI_ex2)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma Min_neq_imp_greater[dest]: \"\\<lbrakk> finite I; k \\<in> I; k \\<noteq> Min I \\<rbrakk> \\<Longrightarrow> Min I < k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite I; k \\<in> I; k \\<noteq> Min I\\<rbrakk>\n    \\<Longrightarrow> Min I < k", "by (rule order_neq_le_trans[OF not_sym Min_le])"], ["", "lemma Max_neq_imp_less[dest]: \"\\<lbrakk> finite I; k \\<in> I; k \\<noteq> Max I \\<rbrakk> \\<Longrightarrow> k < Max I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite I; k \\<in> I; k \\<noteq> Max I\\<rbrakk>\n    \\<Longrightarrow> k < Max I", "by (rule order_neq_le_trans[OF _ Max_ge])"], ["", "lemma nat_Least_mono: \"\n  \\<lbrakk> A \\<noteq> {}; mono (f::(nat\\<Rightarrow>nat)) \\<rbrakk> \\<Longrightarrow>\n  (LEAST x. x \\<in> f ` A) = f (LEAST x. x \\<in> A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<noteq> {}; incseq f\\<rbrakk>\n    \\<Longrightarrow> (LEAST x. x \\<in> f ` A) = f (LEAST x. x \\<in> A)", "unfolding iMin_def[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<noteq> {}; incseq f\\<rbrakk>\n    \\<Longrightarrow> iMin (f ` A) = f (iMin A)", "by (blast intro: iMin_mono2)"], ["", "lemma Least_disj: \"\n  \\<lbrakk> \\<exists>x. P x; \\<exists>x. Q x \\<rbrakk> \\<Longrightarrow>\n  (LEAST (x::'a::wellorder). (P x \\<or> Q x)) = min (LEAST x. P x) (LEAST x. Q x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<exists>x. P x; \\<exists>x. Q x\\<rbrakk>\n    \\<Longrightarrow> (LEAST x. P x \\<or> Q x) =\n                      min (LEAST x. P x) (LEAST x. Q x)", "apply (elim exE, rename_tac x1 x2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<lbrakk>P x1; Q x2\\<rbrakk>\n       \\<Longrightarrow> (LEAST x. P x \\<or> Q x) =\n                         min (LEAST x. P x) (LEAST x. Q x)", "apply (subgoal_tac \"\\<And>x1 x2 P Q. \\<lbrakk>P x1; Q x2; Least P \\<le> Least Q\\<rbrakk> \\<Longrightarrow> (LEAST x. P x \\<or> Q x) = Least P\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1 x2.\n       \\<lbrakk>P x1; Q x2;\n        \\<And>x1 x2 P Q.\n           \\<lbrakk>P x1; Q x2; Least P \\<le> Least Q\\<rbrakk>\n           \\<Longrightarrow> (LEAST x. P x \\<or> Q x) = Least P\\<rbrakk>\n       \\<Longrightarrow> (LEAST x. P x \\<or> Q x) =\n                         min (LEAST x. P x) (LEAST x. Q x)\n 2. \\<And>x1 x2 x1a x2a Pa Qa.\n       \\<lbrakk>P x1; Q x2; Pa x1a; Qa x2a; Least Pa \\<le> Least Qa\\<rbrakk>\n       \\<Longrightarrow> (LEAST x. Pa x \\<or> Qa x) = Least Pa", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1 x2 x1a x2a Pa Qa.\n       \\<lbrakk>P x1; Q x2; Pa x1a; Qa x2a; Least Pa \\<le> Least Qa\\<rbrakk>\n       \\<Longrightarrow> (LEAST x. Pa x \\<or> Qa x) = Least Pa\n 2. \\<And>x1 x2.\n       \\<lbrakk>P x1; Q x2;\n        \\<And>x1 x2 P Q.\n           \\<lbrakk>P x1; Q x2; Least P \\<le> Least Q\\<rbrakk>\n           \\<Longrightarrow> (LEAST x. P x \\<or> Q x) = Least P\\<rbrakk>\n       \\<Longrightarrow> (LEAST x. P x \\<or> Q x) =\n                         min (LEAST x. P x) (LEAST x. Q x)", "apply (rule Least_equality)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x1 x2 x1a x2a Pa Qa.\n       \\<lbrakk>P x1; Q x2; Pa x1a; Qa x2a; Least Pa \\<le> Least Qa\\<rbrakk>\n       \\<Longrightarrow> Pa (Least Pa) \\<or> Qa (Least Pa)\n 2. \\<And>x1 x2 x1a x2a Pa Qa y.\n       \\<lbrakk>P x1; Q x2; Pa x1a; Qa x2a; Least Pa \\<le> Least Qa;\n        Pa y \\<or> Qa y\\<rbrakk>\n       \\<Longrightarrow> Least Pa \\<le> y\n 3. \\<And>x1 x2.\n       \\<lbrakk>P x1; Q x2;\n        \\<And>x1 x2 P Q.\n           \\<lbrakk>P x1; Q x2; Least P \\<le> Least Q\\<rbrakk>\n           \\<Longrightarrow> (LEAST x. P x \\<or> Q x) = Least P\\<rbrakk>\n       \\<Longrightarrow> (LEAST x. P x \\<or> Q x) =\n                         min (LEAST x. P x) (LEAST x. Q x)", "apply (blast intro: LeastI Least_le)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1 x2 x1a x2a Pa Qa y.\n       \\<lbrakk>P x1; Q x2; Pa x1a; Qa x2a; Least Pa \\<le> Least Qa;\n        Pa y \\<or> Qa y\\<rbrakk>\n       \\<Longrightarrow> Least Pa \\<le> y\n 2. \\<And>x1 x2.\n       \\<lbrakk>P x1; Q x2;\n        \\<And>x1 x2 P Q.\n           \\<lbrakk>P x1; Q x2; Least P \\<le> Least Q\\<rbrakk>\n           \\<Longrightarrow> (LEAST x. P x \\<or> Q x) = Least P\\<rbrakk>\n       \\<Longrightarrow> (LEAST x. P x \\<or> Q x) =\n                         min (LEAST x. P x) (LEAST x. Q x)", "apply (erule disjE)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x1 x2 x1a x2a Pa Qa y.\n       \\<lbrakk>P x1; Q x2; Pa x1a; Qa x2a; Least Pa \\<le> Least Qa;\n        Pa y\\<rbrakk>\n       \\<Longrightarrow> Least Pa \\<le> y\n 2. \\<And>x1 x2 x1a x2a Pa Qa y.\n       \\<lbrakk>P x1; Q x2; Pa x1a; Qa x2a; Least Pa \\<le> Least Qa;\n        Qa y\\<rbrakk>\n       \\<Longrightarrow> Least Pa \\<le> y\n 3. \\<And>x1 x2.\n       \\<lbrakk>P x1; Q x2;\n        \\<And>x1 x2 P Q.\n           \\<lbrakk>P x1; Q x2; Least P \\<le> Least Q\\<rbrakk>\n           \\<Longrightarrow> (LEAST x. P x \\<or> Q x) = Least P\\<rbrakk>\n       \\<Longrightarrow> (LEAST x. P x \\<or> Q x) =\n                         min (LEAST x. P x) (LEAST x. Q x)", "apply (rule Least_le, assumption)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1 x2 x1a x2a Pa Qa y.\n       \\<lbrakk>P x1; Q x2; Pa x1a; Qa x2a; Least Pa \\<le> Least Qa;\n        Qa y\\<rbrakk>\n       \\<Longrightarrow> Least Pa \\<le> y\n 2. \\<And>x1 x2.\n       \\<lbrakk>P x1; Q x2;\n        \\<And>x1 x2 P Q.\n           \\<lbrakk>P x1; Q x2; Least P \\<le> Least Q\\<rbrakk>\n           \\<Longrightarrow> (LEAST x. P x \\<or> Q x) = Least P\\<rbrakk>\n       \\<Longrightarrow> (LEAST x. P x \\<or> Q x) =\n                         min (LEAST x. P x) (LEAST x. Q x)", "apply (rule order_trans, assumption)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1 x2 x1a x2a Pa Qa y.\n       \\<lbrakk>P x1; Q x2; Pa x1a; Qa x2a; Least Pa \\<le> Least Qa;\n        Qa y\\<rbrakk>\n       \\<Longrightarrow> Least Qa \\<le> y\n 2. \\<And>x1 x2.\n       \\<lbrakk>P x1; Q x2;\n        \\<And>x1 x2 P Q.\n           \\<lbrakk>P x1; Q x2; Least P \\<le> Least Q\\<rbrakk>\n           \\<Longrightarrow> (LEAST x. P x \\<or> Q x) = Least P\\<rbrakk>\n       \\<Longrightarrow> (LEAST x. P x \\<or> Q x) =\n                         min (LEAST x. P x) (LEAST x. Q x)", "apply (rule Least_le, assumption)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<lbrakk>P x1; Q x2;\n        \\<And>x1 x2 P Q.\n           \\<lbrakk>P x1; Q x2; Least P \\<le> Least Q\\<rbrakk>\n           \\<Longrightarrow> (LEAST x. P x \\<or> Q x) = Least P\\<rbrakk>\n       \\<Longrightarrow> (LEAST x. P x \\<or> Q x) =\n                         min (LEAST x. P x) (LEAST x. Q x)", "apply (unfold min_def, split if_split, safe)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1 x2.\n       \\<lbrakk>P x1; Q x2;\n        \\<And>x1 x2 P Q.\n           \\<lbrakk>P x1; Q x2; Least P \\<le> Least Q\\<rbrakk>\n           \\<Longrightarrow> (LEAST x. P x \\<or> Q x) = Least P;\n        Least P \\<le> Least Q\\<rbrakk>\n       \\<Longrightarrow> (LEAST x. P x \\<or> Q x) = Least P\n 2. \\<And>x1 x2.\n       \\<lbrakk>P x1; Q x2;\n        \\<And>x1 x2 P Q.\n           \\<lbrakk>P x1; Q x2; Least P \\<le> Least Q\\<rbrakk>\n           \\<Longrightarrow> (LEAST x. P x \\<or> Q x) = Least P;\n        \\<not> Least P \\<le> Least Q\\<rbrakk>\n       \\<Longrightarrow> (LEAST x. P x \\<or> Q x) = Least Q", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<lbrakk>P x1; Q x2;\n        \\<And>x1 x2 P Q.\n           \\<lbrakk>P x1; Q x2; Least P \\<le> Least Q\\<rbrakk>\n           \\<Longrightarrow> (LEAST x. P x \\<or> Q x) = Least P;\n        \\<not> Least P \\<le> Least Q\\<rbrakk>\n       \\<Longrightarrow> (LEAST x. P x \\<or> Q x) = Least Q", "apply (subst disj_commute)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<lbrakk>P x1; Q x2;\n        \\<And>x1 x2 P Q.\n           \\<lbrakk>P x1; Q x2; Least P \\<le> Least Q\\<rbrakk>\n           \\<Longrightarrow> (LEAST x. P x \\<or> Q x) = Least P;\n        \\<not> Least P \\<le> Least Q\\<rbrakk>\n       \\<Longrightarrow> (LEAST x. Q x \\<or> P x) = Least Q", "apply (fastforce simp: linorder_not_le)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma Least_imp_le: \"\n  \\<lbrakk> \\<exists>x. P x; \\<And>x. P x \\<Longrightarrow> Q x \\<rbrakk> \\<Longrightarrow>\n  (LEAST (x::'a::wellorder). Q x) \\<le> (LEAST x. P x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<exists>x. P x; \\<And>x. P x \\<Longrightarrow> Q x\\<rbrakk>\n    \\<Longrightarrow> (LEAST x. Q x) \\<le> (LEAST x. P x)", "by (blast intro: Least_le LeastI2_ex)"], ["", "lemma Least_imp_disj_eq: \"\n  \\<lbrakk> \\<exists>x. P x; \\<And>x. P x \\<Longrightarrow> Q x \\<rbrakk> \\<Longrightarrow>\n  (LEAST (x::'a::wellorder). P x \\<or> Q x) = (LEAST x. Q x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<exists>x. P x; \\<And>x. P x \\<Longrightarrow> Q x\\<rbrakk>\n    \\<Longrightarrow> (LEAST x. P x \\<or> Q x) = (LEAST x. Q x)", "apply (subst Least_disj, assumption, blast)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<exists>x. P x; \\<And>x. P x \\<Longrightarrow> Q x\\<rbrakk>\n    \\<Longrightarrow> min (Least P) (Least Q) = Least Q", "apply (subst min.commute)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<exists>x. P x; \\<And>x. P x \\<Longrightarrow> Q x\\<rbrakk>\n    \\<Longrightarrow> min (Least Q) (Least P) = Least Q", "apply (rule min.absorb_iff1[THEN iffD1])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<exists>x. P x; \\<And>x. P x \\<Longrightarrow> Q x\\<rbrakk>\n    \\<Longrightarrow> Least Q \\<le> Least P", "apply (rule Least_imp_le, assumption, blast)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma Least_le_imp_le: \"\n  \\<lbrakk> \\<exists>x. P x; \\<exists>x. Q x; \\<And>x y. \\<lbrakk> P x; Q y \\<rbrakk> \\<Longrightarrow> x \\<le> y \\<rbrakk> \\<Longrightarrow>\n  (LEAST (x::'a::wellorder). P x) \\<le> (LEAST (x::'a::wellorder). Q x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<exists>x. P x; \\<exists>x. Q x;\n     \\<And>x y.\n        \\<lbrakk>P x; Q y\\<rbrakk> \\<Longrightarrow> x \\<le> y\\<rbrakk>\n    \\<Longrightarrow> (LEAST x. P x) \\<le> (LEAST x. Q x)", "by (blast intro: LeastI)"], ["", "lemma Least_le_imp_le_disj: \"\n  \\<lbrakk> \\<exists>x. P x; \\<And>x y. \\<lbrakk> P x; Q y \\<rbrakk> \\<Longrightarrow> x \\<le> y \\<rbrakk> \\<Longrightarrow>\n  (LEAST (x::'a::wellorder). P x \\<or> Q x) = (LEAST (x::'a::wellorder). P x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<exists>x. P x;\n     \\<And>x y.\n        \\<lbrakk>P x; Q y\\<rbrakk> \\<Longrightarrow> x \\<le> y\\<rbrakk>\n    \\<Longrightarrow> (LEAST x. P x \\<or> Q x) = (LEAST x. P x)", "apply (case_tac \"\\<exists>x. Q x\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<exists>x. P x;\n     \\<And>x y. \\<lbrakk>P x; Q y\\<rbrakk> \\<Longrightarrow> x \\<le> y;\n     \\<exists>x. Q x\\<rbrakk>\n    \\<Longrightarrow> (LEAST x. P x \\<or> Q x) = (LEAST x. P x)\n 2. \\<lbrakk>\\<exists>x. P x;\n     \\<And>x y. \\<lbrakk>P x; Q y\\<rbrakk> \\<Longrightarrow> x \\<le> y;\n     \\<nexists>x. Q x\\<rbrakk>\n    \\<Longrightarrow> (LEAST x. P x \\<or> Q x) = (LEAST x. P x)", "apply (simp only: Least_disj min.absorb_iff1[THEN iffD1, OF Least_le_imp_le])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<exists>x. P x;\n     \\<And>x y. \\<lbrakk>P x; Q y\\<rbrakk> \\<Longrightarrow> x \\<le> y;\n     \\<nexists>x. Q x\\<rbrakk>\n    \\<Longrightarrow> (LEAST x. P x \\<or> Q x) = (LEAST x. P x)", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma Max_equality: \"\\<lbrakk> (k::'a::linorder) \\<in> A; finite A; \\<And>x. x \\<in> A \\<Longrightarrow> x \\<le> k \\<rbrakk> \\<Longrightarrow>\n  Max A = k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>k \\<in> A; finite A;\n     \\<And>x. x \\<in> A \\<Longrightarrow> x \\<le> k\\<rbrakk>\n    \\<Longrightarrow> Max A = k", "by (rule Max_eqI)"], ["", "lemma not_greater_Max: \"\\<lbrakk> finite A; Max A < k \\<rbrakk>  \\<Longrightarrow> k \\<notin> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite A; Max A < k\\<rbrakk> \\<Longrightarrow> k \\<notin> A", "apply (rule ccontr, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite A; Max A < k; k \\<in> A\\<rbrakk> \\<Longrightarrow> False", "apply (frule Max_ge[of A k], blast)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite A; Max A < k; k \\<in> A; k \\<le> Max A\\<rbrakk>\n    \\<Longrightarrow> False", "apply (frule order_le_less_trans[of _ _ k], blast)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite A; Max A < k; k \\<in> A; k \\<le> Max A; k < k\\<rbrakk>\n    \\<Longrightarrow> False", "apply blast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma Collect_not_greater_Max: \"\\<lbrakk> finite {x. P x}; Max {x. P x} < k \\<rbrakk> \\<Longrightarrow> \\<not> P k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite {x. P x}; Max {x. P x} < k\\<rbrakk>\n    \\<Longrightarrow> \\<not> P k", "by (drule not_greater_Max, assumption, drule Collect_not_in_imp_not)"], ["", "lemma Collect_Max_ge: \"\\<lbrakk> finite {x. P x}; P k \\<rbrakk> \\<Longrightarrow> k \\<le> Max {x. P x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite {x. P x}; P k\\<rbrakk>\n    \\<Longrightarrow> k \\<le> Max {x. P x}", "by (rule Max_ge, assumption, rule CollectI)"], ["", "lemma MaxI: \"\\<lbrakk> k \\<in> A; finite A \\<rbrakk> \\<Longrightarrow> Max A \\<in> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>k \\<in> A; finite A\\<rbrakk> \\<Longrightarrow> Max A \\<in> A", "by (case_tac \"A = {}\", simp_all)"], ["", "lemma MaxI_ex: \"\\<lbrakk> \\<exists>x. x \\<in> A; finite A \\<rbrakk> \\<Longrightarrow> Max A \\<in> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<exists>x. x \\<in> A; finite A\\<rbrakk>\n    \\<Longrightarrow> Max A \\<in> A", "by (blast intro: MaxI)"], ["", "lemma MaxI_ex2: \"\\<lbrakk> A \\<noteq> {}; finite A \\<rbrakk> \\<Longrightarrow> Max A \\<in> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<noteq> {}; finite A\\<rbrakk>\n    \\<Longrightarrow> Max A \\<in> A", "by (blast intro: MaxI)"], ["", "lemma MaxI2: \"\\<lbrakk> k \\<in> A; \\<And>x. x \\<in> A \\<Longrightarrow> P x; finite A \\<rbrakk> \\<Longrightarrow> P (Max A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>k \\<in> A; \\<And>x. x \\<in> A \\<Longrightarrow> P x;\n     finite A\\<rbrakk>\n    \\<Longrightarrow> P (Max A)", "by (drule Max_in, blast+)"], ["", "lemma MaxI2_ex:\"\\<lbrakk> \\<exists>x. x \\<in> A; \\<And>x. x \\<in> A \\<Longrightarrow> P x; finite A \\<rbrakk> \\<Longrightarrow> P (Max A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<exists>x. x \\<in> A;\n     \\<And>x. x \\<in> A \\<Longrightarrow> P x; finite A\\<rbrakk>\n    \\<Longrightarrow> P (Max A)", "by (blast intro: MaxI2)"], ["", "lemma MaxI2_ex2:\"\\<lbrakk> A \\<noteq> {}; \\<And>x. x \\<in> A \\<Longrightarrow> P x; finite A \\<rbrakk> \\<Longrightarrow> P (Max A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<noteq> {}; \\<And>x. x \\<in> A \\<Longrightarrow> P x;\n     finite A\\<rbrakk>\n    \\<Longrightarrow> P (Max A)", "by (blast intro: MaxI2)"], ["", "lemma Max_mono: \"\\<lbrakk> mono f; \\<exists>x. x \\<in> A; finite A \\<rbrakk> \\<Longrightarrow> Max (f ` A) = f (Max A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>mono f; \\<exists>x. x \\<in> A; finite A\\<rbrakk>\n    \\<Longrightarrow> Max (f ` A) = f (Max A)", "apply (unfold mono_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>x y. x \\<le> y \\<longrightarrow> f x \\<le> f y;\n     \\<exists>x. x \\<in> A; finite A\\<rbrakk>\n    \\<Longrightarrow> Max (f ` A) = f (Max A)", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>x y. x \\<le> y \\<longrightarrow> f x \\<le> f y;\n        finite A; x \\<in> A\\<rbrakk>\n       \\<Longrightarrow> Max (f ` A) = f (Max A)", "apply (frule Max_in, blast)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>x y. x \\<le> y \\<longrightarrow> f x \\<le> f y;\n        finite A; x \\<in> A; Max A \\<in> A\\<rbrakk>\n       \\<Longrightarrow> Max (f ` A) = f (Max A)", "apply (rule Max_equality, clarsimp+)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma Max_mono2:\"\\<lbrakk> mono f; A \\<noteq> {}; finite A \\<rbrakk> \\<Longrightarrow> Max (f ` A) = f (Max A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>mono f; A \\<noteq> {}; finite A\\<rbrakk>\n    \\<Longrightarrow> Max (f ` A) = f (Max A)", "by (blast intro: Max_mono)"], ["", "lemma Max_mono_on: \"\\<lbrakk> mono_on f A; \\<exists>x. x \\<in> A; finite A \\<rbrakk> \\<Longrightarrow> Max (f ` A) = f (Max A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>SetInterval2.mono_on f A; \\<exists>x. x \\<in> A;\n     finite A\\<rbrakk>\n    \\<Longrightarrow> Max (f ` A) = f (Max A)", "apply (unfold mono_on_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>a\\<in>A.\n                \\<forall>b\\<in>A. a \\<le> b \\<longrightarrow> f a \\<le> f b;\n     \\<exists>x. x \\<in> A; finite A\\<rbrakk>\n    \\<Longrightarrow> Max (f ` A) = f (Max A)", "apply (rule Max_equality)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<forall>a\\<in>A.\n                \\<forall>b\\<in>A. a \\<le> b \\<longrightarrow> f a \\<le> f b;\n     \\<exists>x. x \\<in> A; finite A\\<rbrakk>\n    \\<Longrightarrow> f (Max A) \\<in> f ` A\n 2. \\<lbrakk>\\<forall>a\\<in>A.\n                \\<forall>b\\<in>A. a \\<le> b \\<longrightarrow> f a \\<le> f b;\n     \\<exists>x. x \\<in> A; finite A\\<rbrakk>\n    \\<Longrightarrow> finite (f ` A)\n 3. \\<And>x.\n       \\<lbrakk>\\<forall>a\\<in>A.\n                   \\<forall>b\\<in>A.\n                      a \\<le> b \\<longrightarrow> f a \\<le> f b;\n        \\<exists>x. x \\<in> A; finite A; x \\<in> f ` A\\<rbrakk>\n       \\<Longrightarrow> x \\<le> f (Max A)", "apply (blast intro: Max_in)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>a\\<in>A.\n                \\<forall>b\\<in>A. a \\<le> b \\<longrightarrow> f a \\<le> f b;\n     \\<exists>x. x \\<in> A; finite A\\<rbrakk>\n    \\<Longrightarrow> finite (f ` A)\n 2. \\<And>x.\n       \\<lbrakk>\\<forall>a\\<in>A.\n                   \\<forall>b\\<in>A.\n                      a \\<le> b \\<longrightarrow> f a \\<le> f b;\n        \\<exists>x. x \\<in> A; finite A; x \\<in> f ` A\\<rbrakk>\n       \\<Longrightarrow> x \\<le> f (Max A)", "apply (rule finite_imageI, assumption)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>a\\<in>A.\n                   \\<forall>b\\<in>A.\n                      a \\<le> b \\<longrightarrow> f a \\<le> f b;\n        \\<exists>x. x \\<in> A; finite A; x \\<in> f ` A\\<rbrakk>\n       \\<Longrightarrow> x \\<le> f (Max A)", "apply (blast intro: Max_in Max_ge)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma Max_mono_on2: \"\n  \\<lbrakk> mono_on f A; A \\<noteq> {}; finite A \\<rbrakk> \\<Longrightarrow> Max (f ` A) = f (Max A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>SetInterval2.mono_on f A; A \\<noteq> {}; finite A\\<rbrakk>\n    \\<Longrightarrow> Max (f ` A) = f (Max A)", "by (rule Max_mono_on, blast+)"], ["", "lemma Max_the: \"\n  \\<lbrakk> A \\<noteq> {}; finite A \\<rbrakk> \\<Longrightarrow>\n  Max A = (THE x. x \\<in> A \\<and> (\\<forall>y. y \\<in> A \\<longrightarrow> y \\<le> x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<noteq> {}; finite A\\<rbrakk>\n    \\<Longrightarrow> Max A =\n                      (THE x.\n                          x \\<in> A \\<and>\n                          (\\<forall>y.\n                              y \\<in> A \\<longrightarrow> y \\<le> x))", "apply (rule iffD1[OF eq_commute])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<noteq> {}; finite A\\<rbrakk>\n    \\<Longrightarrow> (THE x.\n                          x \\<in> A \\<and>\n                          (\\<forall>y.\n                              y \\<in> A \\<longrightarrow> y \\<le> x)) =\n                      Max A", "apply (rule the_equality, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>A \\<noteq> {}; finite A;\n        x \\<in> A \\<and>\n        (\\<forall>y. y \\<in> A \\<longrightarrow> y \\<le> x)\\<rbrakk>\n       \\<Longrightarrow> x = Max A", "apply (rule sym)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>A \\<noteq> {}; finite A;\n        x \\<in> A \\<and>\n        (\\<forall>y. y \\<in> A \\<longrightarrow> y \\<le> x)\\<rbrakk>\n       \\<Longrightarrow> Max A = x", "apply (rule Max_equality)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>A \\<noteq> {}; finite A;\n        x \\<in> A \\<and>\n        (\\<forall>y. y \\<in> A \\<longrightarrow> y \\<le> x)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> A\n 2. \\<And>x.\n       \\<lbrakk>A \\<noteq> {}; finite A;\n        x \\<in> A \\<and>\n        (\\<forall>y. y \\<in> A \\<longrightarrow> y \\<le> x)\\<rbrakk>\n       \\<Longrightarrow> finite A\n 3. \\<And>x xa.\n       \\<lbrakk>A \\<noteq> {}; finite A;\n        x \\<in> A \\<and>\n        (\\<forall>y. y \\<in> A \\<longrightarrow> y \\<le> x);\n        xa \\<in> A\\<rbrakk>\n       \\<Longrightarrow> xa \\<le> x", "apply blast+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma Max_the2: \"\\<lbrakk> A \\<noteq> {}; finite A \\<rbrakk> \\<Longrightarrow>\n  Max A = (THE x. x \\<in> A \\<and> (\\<forall>y\\<in>A. y \\<le> x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<noteq> {}; finite A\\<rbrakk>\n    \\<Longrightarrow> Max A =\n                      (THE x.\n                          x \\<in> A \\<and> (\\<forall>y\\<in>A. y \\<le> x))", "apply (simp add: Max_the)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<noteq> {}; finite A\\<rbrakk>\n    \\<Longrightarrow> (THE x.\n                          x \\<in> A \\<and>\n                          (\\<forall>y.\n                              y \\<in> A \\<longrightarrow> y \\<le> x)) =\n                      (THE x.\n                          x \\<in> A \\<and> (\\<forall>y\\<in>A. y \\<le> x))", "apply (subgoal_tac \"\\<And>x. (\\<forall>y\\<in>A. y \\<le> x) = (\\<forall>y. y \\<in> A \\<longrightarrow> y \\<le> x) \")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>A \\<noteq> {}; finite A;\n     \\<And>x.\n        (\\<forall>y\\<in>A. y \\<le> x) =\n        (\\<forall>y. y \\<in> A \\<longrightarrow> y \\<le> x)\\<rbrakk>\n    \\<Longrightarrow> (THE x.\n                          x \\<in> A \\<and>\n                          (\\<forall>y.\n                              y \\<in> A \\<longrightarrow> y \\<le> x)) =\n                      (THE x.\n                          x \\<in> A \\<and> (\\<forall>y\\<in>A. y \\<le> x))\n 2. \\<And>x.\n       \\<lbrakk>A \\<noteq> {}; finite A\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>y\\<in>A. y \\<le> x) =\n                         (\\<forall>y. y \\<in> A \\<longrightarrow> y \\<le> x)", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>A \\<noteq> {}; finite A\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>y\\<in>A. y \\<le> x) =\n                         (\\<forall>y. y \\<in> A \\<longrightarrow> y \\<le> x)\n 2. \\<lbrakk>A \\<noteq> {}; finite A;\n     \\<And>x.\n        (\\<forall>y\\<in>A. y \\<le> x) =\n        (\\<forall>y. y \\<in> A \\<longrightarrow> y \\<le> x)\\<rbrakk>\n    \\<Longrightarrow> (THE x.\n                          x \\<in> A \\<and>\n                          (\\<forall>y.\n                              y \\<in> A \\<longrightarrow> y \\<le> x)) =\n                      (THE x.\n                          x \\<in> A \\<and> (\\<forall>y\\<in>A. y \\<le> x))", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<noteq> {}; finite A;\n     \\<And>x.\n        (\\<forall>y\\<in>A. y \\<le> x) =\n        (\\<forall>y. y \\<in> A \\<longrightarrow> y \\<le> x)\\<rbrakk>\n    \\<Longrightarrow> (THE x.\n                          x \\<in> A \\<and>\n                          (\\<forall>y.\n                              y \\<in> A \\<longrightarrow> y \\<le> x)) =\n                      (THE x.\n                          x \\<in> A \\<and> (\\<forall>y\\<in>A. y \\<le> x))", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma wellorder_Max_lemma: \"\\<lbrakk> k \\<in> A; finite A \\<rbrakk> \\<Longrightarrow> Max A \\<in> A \\<and> k \\<le> Max A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>k \\<in> A; finite A\\<rbrakk>\n    \\<Longrightarrow> Max A \\<in> A \\<and> k \\<le> Max A", "by (case_tac \"A = {}\", simp_all)"], ["", "lemma MaxI2_order: \"\\<lbrakk> k \\<in> A; finite A; \\<And>y. y \\<in> A \\<Longrightarrow> y \\<le> k;\n  \\<And>x. \\<lbrakk> x \\<in> A; \\<forall>y\\<in>A. y \\<le> x \\<rbrakk> \\<Longrightarrow> P x \\<rbrakk>\n  \\<Longrightarrow> P (Max A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>k \\<in> A; finite A;\n     \\<And>y. y \\<in> A \\<Longrightarrow> y \\<le> k;\n     \\<And>x.\n        \\<lbrakk>x \\<in> A; \\<forall>y\\<in>A. y \\<le> x\\<rbrakk>\n        \\<Longrightarrow> P x\\<rbrakk>\n    \\<Longrightarrow> P (Max A)", "by (simp add: Max_equality)"], ["", "lemma Min_le_Max: \"\\<lbrakk> finite A; A \\<noteq> {} \\<rbrakk> \\<Longrightarrow> Min A \\<le> Max A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite A; A \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> Min A \\<le> Max A", "by (rule Max_ge[OF _ Min_in])"], ["", "lemma iMin_le_Max: \"\\<lbrakk> finite A; A \\<noteq> {} \\<rbrakk> \\<Longrightarrow> iMin A \\<le> Max A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite A; A \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> iMin A \\<le> Max A", "by (rule ssubst[OF iMin_Min_conv], assumption+, rule Min_le_Max)"], ["", "subsubsection \\<open>\\<open>Max\\<close> for sets over \\<open>enat\\<close>\\<close>"], ["", "definition iMax :: \"nat set \\<Rightarrow> enat\"\n  where \"iMax i \\<equiv> if (finite i) then (enat (Max i)) else \\<infinity>\""], ["", "lemma iMax_finite_conv: \"finite I = (iMax I \\<noteq> \\<infinity>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite I = (iMax I \\<noteq> \\<infinity>)", "by (simp add: iMax_def)"], ["", "lemma iMax_infinite_conv: \"infinite I = (iMax I = \\<infinity>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infinite I = (iMax I = \\<infinity>)", "by (simp add: iMax_def)"], ["", "lemma \"class.distrib_lattice (min::('a::linorder \\<Rightarrow> 'a \\<Rightarrow> 'a)) (\\<le>) (<) max\""], ["proof (prove)\ngoal (1 subgoal):\n 1. class.distrib_lattice min (\\<le>) (<) max", "apply (subgoal_tac \"class.order (\\<le>) (<)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. class.order (\\<le>) (<) \\<Longrightarrow>\n    class.distrib_lattice min (\\<le>) (<) max\n 2. class.order (\\<le>) (<)", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. class.order (\\<le>) (<)\n 2. class.order (\\<le>) (<) \\<Longrightarrow>\n    class.distrib_lattice min (\\<le>) (<) max", "apply (rule class.order.intro)"], ["proof (prove)\ngoal (3 subgoals):\n 1. class.preorder (\\<le>) (<)\n 2. class.order_axioms (\\<le>)\n 3. class.order (\\<le>) (<) \\<Longrightarrow>\n    class.distrib_lattice min (\\<le>) (<) max", "apply (rule class.preorder.intro)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x y. (x < y) = (x \\<le> y \\<and> \\<not> y \\<le> x)\n 2. \\<And>x. x \\<le> x\n 3. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 4. class.order_axioms (\\<le>)\n 5. class.order (\\<le>) (<) \\<Longrightarrow>\n    class.distrib_lattice min (\\<le>) (<) max", "apply (rule less_le_not_le)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x. x \\<le> x\n 2. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 3. class.order_axioms (\\<le>)\n 4. class.order (\\<le>) (<) \\<Longrightarrow>\n    class.distrib_lattice min (\\<le>) (<) max", "apply (rule order_refl)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 2. class.order_axioms (\\<le>)\n 3. class.order (\\<le>) (<) \\<Longrightarrow>\n    class.distrib_lattice min (\\<le>) (<) max", "apply (rule order_trans, assumption+)"], ["proof (prove)\ngoal (2 subgoals):\n 1. class.order_axioms (\\<le>)\n 2. class.order (\\<le>) (<) \\<Longrightarrow>\n    class.distrib_lattice min (\\<le>) (<) max", "apply (rule class.order_axioms.intro)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 2. class.order (\\<le>) (<) \\<Longrightarrow>\n    class.distrib_lattice min (\\<le>) (<) max", "apply (rule order_antisym, assumption+)"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.order (\\<le>) (<) \\<Longrightarrow>\n    class.distrib_lattice min (\\<le>) (<) max", "apply (subgoal_tac \"class.linorder (\\<le>) (<)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>class.order (\\<le>) (<); class.linorder (\\<le>) (<)\\<rbrakk>\n    \\<Longrightarrow> class.distrib_lattice min (\\<le>) (<) max\n 2. class.order (\\<le>) (<) \\<Longrightarrow> class.linorder (\\<le>) (<)", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. class.order (\\<le>) (<) \\<Longrightarrow> class.linorder (\\<le>) (<)\n 2. \\<lbrakk>class.order (\\<le>) (<); class.linorder (\\<le>) (<)\\<rbrakk>\n    \\<Longrightarrow> class.distrib_lattice min (\\<le>) (<) max", "apply (rule class.linorder.intro, assumption)"], ["proof (prove)\ngoal (2 subgoals):\n 1. class.order (\\<le>) (<) \\<Longrightarrow> class.linorder_axioms (\\<le>)\n 2. \\<lbrakk>class.order (\\<le>) (<); class.linorder (\\<le>) (<)\\<rbrakk>\n    \\<Longrightarrow> class.distrib_lattice min (\\<le>) (<) max", "apply (rule class.linorder_axioms.intro)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       class.order (\\<le>) (<) \\<Longrightarrow> x \\<le> y \\<or> y \\<le> x\n 2. \\<lbrakk>class.order (\\<le>) (<); class.linorder (\\<le>) (<)\\<rbrakk>\n    \\<Longrightarrow> class.distrib_lattice min (\\<le>) (<) max", "apply (rule linorder_class.linear)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>class.order (\\<le>) (<); class.linorder (\\<le>) (<)\\<rbrakk>\n    \\<Longrightarrow> class.distrib_lattice min (\\<le>) (<) max", "apply (rule class.distrib_lattice.intro)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>class.order (\\<le>) (<); class.linorder (\\<le>) (<)\\<rbrakk>\n    \\<Longrightarrow> class.lattice min (\\<le>) (<) max\n 2. \\<lbrakk>class.order (\\<le>) (<); class.linorder (\\<le>) (<)\\<rbrakk>\n    \\<Longrightarrow> class.distrib_lattice_axioms min max", "apply (rule class.lattice.intro)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>class.order (\\<le>) (<); class.linorder (\\<le>) (<)\\<rbrakk>\n    \\<Longrightarrow> class.semilattice_inf min (\\<le>) (<)\n 2. \\<lbrakk>class.order (\\<le>) (<); class.linorder (\\<le>) (<)\\<rbrakk>\n    \\<Longrightarrow> class.semilattice_sup max (\\<le>) (<)\n 3. \\<lbrakk>class.order (\\<le>) (<); class.linorder (\\<le>) (<)\\<rbrakk>\n    \\<Longrightarrow> class.distrib_lattice_axioms min max", "apply (rule class.semilattice_inf.intro, assumption)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>class.order (\\<le>) (<); class.linorder (\\<le>) (<)\\<rbrakk>\n    \\<Longrightarrow> class.semilattice_inf_axioms min (\\<le>)\n 2. \\<lbrakk>class.order (\\<le>) (<); class.linorder (\\<le>) (<)\\<rbrakk>\n    \\<Longrightarrow> class.semilattice_sup max (\\<le>) (<)\n 3. \\<lbrakk>class.order (\\<le>) (<); class.linorder (\\<le>) (<)\\<rbrakk>\n    \\<Longrightarrow> class.distrib_lattice_axioms min max", "apply (rule class.semilattice_inf_axioms.intro)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>class.order (\\<le>) (<); class.linorder (\\<le>) (<)\\<rbrakk>\n       \\<Longrightarrow> min x y \\<le> x\n 2. \\<And>x y.\n       \\<lbrakk>class.order (\\<le>) (<); class.linorder (\\<le>) (<)\\<rbrakk>\n       \\<Longrightarrow> min x y \\<le> y\n 3. \\<And>x y z.\n       \\<lbrakk>class.order (\\<le>) (<); class.linorder (\\<le>) (<);\n        x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> min y z\n 4. \\<lbrakk>class.order (\\<le>) (<); class.linorder (\\<le>) (<)\\<rbrakk>\n    \\<Longrightarrow> class.semilattice_sup max (\\<le>) (<)\n 5. \\<lbrakk>class.order (\\<le>) (<); class.linorder (\\<le>) (<)\\<rbrakk>\n    \\<Longrightarrow> class.distrib_lattice_axioms min max", "apply (rule le_minI1)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>class.order (\\<le>) (<); class.linorder (\\<le>) (<)\\<rbrakk>\n       \\<Longrightarrow> min x y \\<le> y\n 2. \\<And>x y z.\n       \\<lbrakk>class.order (\\<le>) (<); class.linorder (\\<le>) (<);\n        x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> min y z\n 3. \\<lbrakk>class.order (\\<le>) (<); class.linorder (\\<le>) (<)\\<rbrakk>\n    \\<Longrightarrow> class.semilattice_sup max (\\<le>) (<)\n 4. \\<lbrakk>class.order (\\<le>) (<); class.linorder (\\<le>) (<)\\<rbrakk>\n    \\<Longrightarrow> class.distrib_lattice_axioms min max", "apply (rule le_minI2)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>class.order (\\<le>) (<); class.linorder (\\<le>) (<);\n        x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> min y z\n 2. \\<lbrakk>class.order (\\<le>) (<); class.linorder (\\<le>) (<)\\<rbrakk>\n    \\<Longrightarrow> class.semilattice_sup max (\\<le>) (<)\n 3. \\<lbrakk>class.order (\\<le>) (<); class.linorder (\\<le>) (<)\\<rbrakk>\n    \\<Longrightarrow> class.distrib_lattice_axioms min max", "apply (rule conj_le_imp_min, assumption+)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>class.order (\\<le>) (<); class.linorder (\\<le>) (<)\\<rbrakk>\n    \\<Longrightarrow> class.semilattice_sup max (\\<le>) (<)\n 2. \\<lbrakk>class.order (\\<le>) (<); class.linorder (\\<le>) (<)\\<rbrakk>\n    \\<Longrightarrow> class.distrib_lattice_axioms min max", "apply (rule class.semilattice_sup.intro, assumption)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>class.order (\\<le>) (<); class.linorder (\\<le>) (<)\\<rbrakk>\n    \\<Longrightarrow> class.semilattice_sup_axioms max (\\<le>)\n 2. \\<lbrakk>class.order (\\<le>) (<); class.linorder (\\<le>) (<)\\<rbrakk>\n    \\<Longrightarrow> class.distrib_lattice_axioms min max", "apply (rule class.semilattice_sup_axioms.intro)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>class.order (\\<le>) (<); class.linorder (\\<le>) (<)\\<rbrakk>\n       \\<Longrightarrow> x \\<le> max x y\n 2. \\<And>y x.\n       \\<lbrakk>class.order (\\<le>) (<); class.linorder (\\<le>) (<)\\<rbrakk>\n       \\<Longrightarrow> y \\<le> max x y\n 3. \\<And>y x z.\n       \\<lbrakk>class.order (\\<le>) (<); class.linorder (\\<le>) (<);\n        y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> max y z \\<le> x\n 4. \\<lbrakk>class.order (\\<le>) (<); class.linorder (\\<le>) (<)\\<rbrakk>\n    \\<Longrightarrow> class.distrib_lattice_axioms min max", "apply (rule max.cobounded1)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>y x.\n       \\<lbrakk>class.order (\\<le>) (<); class.linorder (\\<le>) (<)\\<rbrakk>\n       \\<Longrightarrow> y \\<le> max x y\n 2. \\<And>y x z.\n       \\<lbrakk>class.order (\\<le>) (<); class.linorder (\\<le>) (<);\n        y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> max y z \\<le> x\n 3. \\<lbrakk>class.order (\\<le>) (<); class.linorder (\\<le>) (<)\\<rbrakk>\n    \\<Longrightarrow> class.distrib_lattice_axioms min max", "apply (rule max.cobounded2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>y x z.\n       \\<lbrakk>class.order (\\<le>) (<); class.linorder (\\<le>) (<);\n        y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> max y z \\<le> x\n 2. \\<lbrakk>class.order (\\<le>) (<); class.linorder (\\<le>) (<)\\<rbrakk>\n    \\<Longrightarrow> class.distrib_lattice_axioms min max", "apply (rule conj_le_imp_max, assumption+)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>class.order (\\<le>) (<); class.linorder (\\<le>) (<)\\<rbrakk>\n    \\<Longrightarrow> class.distrib_lattice_axioms min max", "apply (rule class.distrib_lattice_axioms.intro)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>class.order (\\<le>) (<); class.linorder (\\<le>) (<)\\<rbrakk>\n       \\<Longrightarrow> max x (min y z) = min (max x y) (max x z)", "apply (rule max_min_distrib2)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "print_locale Lattices.distrib_lattice"], ["", "lemma max_Min_eq_Min_max[rule_format]: \"\n  finite A \\<Longrightarrow>\n  A \\<noteq> {} \\<longrightarrow>\n  max x (Min A) = Min {max x a |a. a \\<in> A}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite A \\<Longrightarrow>\n    A \\<noteq> {} \\<longrightarrow>\n    max x (Min A) = Min {max x a |a. a \\<in> A}", "apply (rule finite.induct[of A], simp_all del: insert_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Aa a.\n       \\<lbrakk>finite A; finite Aa;\n        Aa \\<noteq> {} \\<longrightarrow>\n        max x (Min Aa) = Min {max x a |a. a \\<in> Aa}\\<rbrakk>\n       \\<Longrightarrow> max x (Min (insert a Aa)) =\n                         Min {max x aa |aa. aa \\<in> insert a Aa}", "apply (rename_tac A1 a)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>A1 a.\n       \\<lbrakk>finite A; finite A1;\n        A1 \\<noteq> {} \\<longrightarrow>\n        max x (Min A1) = Min {max x a |a. a \\<in> A1}\\<rbrakk>\n       \\<Longrightarrow> max x (Min (insert a A1)) =\n                         Min {max x aa |aa. aa \\<in> insert a A1}", "apply (case_tac \"A1 = {}\", simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>A1 a.\n       \\<lbrakk>finite A; finite A1;\n        A1 \\<noteq> {} \\<longrightarrow>\n        max x (Min A1) = Min {max x a |a. a \\<in> A1};\n        A1 \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> max x (Min (insert a A1)) =\n                         Min {max x aa |aa. aa \\<in> insert a A1}", "apply (rule_tac\n  t=\"{max x b |b. b \\<in> insert a A1}\" and\n  s=\"insert (max x a) {max x b |b. b \\<in> A1}\"\n  in subst)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>A1 a.\n       \\<lbrakk>finite A; finite A1;\n        A1 \\<noteq> {} \\<longrightarrow>\n        max x (Min A1) = Min {max x a |a. a \\<in> A1};\n        A1 \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> insert (max x a) {max x b |b. b \\<in> A1} =\n                         {max x b |b. b \\<in> insert a A1}\n 2. \\<And>A1 a.\n       \\<lbrakk>finite A; finite A1;\n        A1 \\<noteq> {} \\<longrightarrow>\n        max x (Min A1) = Min {max x a |a. a \\<in> A1};\n        A1 \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> max x (Min (insert a A1)) =\n                         Min (insert (max x a) {max x b |b. b \\<in> A1})", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>A1 a.\n       \\<lbrakk>finite A; finite A1;\n        A1 \\<noteq> {} \\<longrightarrow>\n        max x (Min A1) = Min {max x a |a. a \\<in> A1};\n        A1 \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> max x (Min (insert a A1)) =\n                         Min (insert (max x a) {max x b |b. b \\<in> A1})", "apply (subst Min_insert, simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>A1 a.\n       \\<lbrakk>finite A; finite A1;\n        max x (Min A1) = Min {max x a |a. a \\<in> A1};\n        A1 \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> max x (min a (Min A1)) =\n                         min (max x a) (Min {max x b |b. b \\<in> A1})", "apply (case_tac \"a \\<le> Min A1\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>A1 a.\n       \\<lbrakk>finite A; finite A1;\n        max x (Min A1) = Min {max x a |a. a \\<in> A1}; A1 \\<noteq> {};\n        a \\<le> Min A1\\<rbrakk>\n       \\<Longrightarrow> max x (min a (Min A1)) =\n                         min (max x a) (Min {max x b |b. b \\<in> A1})\n 2. \\<And>A1 a.\n       \\<lbrakk>finite A; finite A1;\n        max x (Min A1) = Min {max x a |a. a \\<in> A1}; A1 \\<noteq> {};\n        \\<not> a \\<le> Min A1\\<rbrakk>\n       \\<Longrightarrow> max x (min a (Min A1)) =\n                         min (max x a) (Min {max x b |b. b \\<in> A1})", "apply (frule max_le_monoR[where x=x])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>A1 a.\n       \\<lbrakk>finite A; finite A1;\n        max x (Min A1) = Min {max x a |a. a \\<in> A1}; A1 \\<noteq> {};\n        a \\<le> Min A1; max x a \\<le> max x (Min A1)\\<rbrakk>\n       \\<Longrightarrow> max x (min a (Min A1)) =\n                         min (max x a) (Min {max x b |b. b \\<in> A1})\n 2. \\<And>A1 a.\n       \\<lbrakk>finite A; finite A1;\n        max x (Min A1) = Min {max x a |a. a \\<in> A1}; A1 \\<noteq> {};\n        \\<not> a \\<le> Min A1\\<rbrakk>\n       \\<Longrightarrow> max x (min a (Min A1)) =\n                         min (max x a) (Min {max x b |b. b \\<in> A1})", "apply (simp only: min_eqL)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>A1 a.\n       \\<lbrakk>finite A; finite A1;\n        max x (Min A1) = Min {max x a |a. a \\<in> A1}; A1 \\<noteq> {};\n        \\<not> a \\<le> Min A1\\<rbrakk>\n       \\<Longrightarrow> max x (min a (Min A1)) =\n                         min (max x a) (Min {max x b |b. b \\<in> A1})", "apply (simp only: linorder_not_le)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>A1 a.\n       \\<lbrakk>finite A; finite A1;\n        max x (Min A1) = Min {max x a |a. a \\<in> A1}; A1 \\<noteq> {};\n        Min A1 < a\\<rbrakk>\n       \\<Longrightarrow> max x (min a (Min A1)) =\n                         min (max x a) (Min {max x b |b. b \\<in> A1})", "apply (frule max_le_monoR[where x=x, OF less_imp_le])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>A1 a.\n       \\<lbrakk>finite A; finite A1;\n        max x (Min A1) = Min {max x a |a. a \\<in> A1}; A1 \\<noteq> {};\n        Min A1 < a; max x (Min A1) \\<le> max x a\\<rbrakk>\n       \\<Longrightarrow> max x (min a (Min A1)) =\n                         min (max x a) (Min {max x b |b. b \\<in> A1})", "apply (simp only: min_eqR)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma max_iMin_eq_iMin_max: \"\n  \\<lbrakk> finite A; A \\<noteq> {} \\<rbrakk> \\<Longrightarrow>\n  max x (iMin A) = iMin {max x a |a. a \\<in> A}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite A; A \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> max x (iMin A) = iMin {max x a |a. a \\<in> A}", "apply (simp add: iMin_Min_conv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite A; A \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> max x (Min A) = Min {max x a |a. a \\<in> A}", "apply (insert iMin_Min_conv[of \"{max x a |a. a \\<in> A}\"], simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite A; A \\<noteq> {};\n     iMin {max x a |a. a \\<in> A} = Min {max x a |a. a \\<in> A}\\<rbrakk>\n    \\<Longrightarrow> max x (Min A) = Min {max x a |a. a \\<in> A}", "apply (subgoal_tac \"finite {max x a |a. a \\<in> A}\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>finite A; A \\<noteq> {};\n     iMin {max x a |a. a \\<in> A} = Min {max x a |a. a \\<in> A};\n     finite {max x a |a. a \\<in> A}\\<rbrakk>\n    \\<Longrightarrow> max x (Min A) = Min {max x a |a. a \\<in> A}\n 2. \\<lbrakk>finite A; A \\<noteq> {};\n     iMin {max x a |a. a \\<in> A} = Min {max x a |a. a \\<in> A}\\<rbrakk>\n    \\<Longrightarrow> finite {max x a |a. a \\<in> A}", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>finite A; A \\<noteq> {};\n     iMin {max x a |a. a \\<in> A} = Min {max x a |a. a \\<in> A}\\<rbrakk>\n    \\<Longrightarrow> finite {max x a |a. a \\<in> A}\n 2. \\<lbrakk>finite A; A \\<noteq> {};\n     iMin {max x a |a. a \\<in> A} = Min {max x a |a. a \\<in> A};\n     finite {max x a |a. a \\<in> A}\\<rbrakk>\n    \\<Longrightarrow> max x (Min A) = Min {max x a |a. a \\<in> A}", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite A; A \\<noteq> {};\n     iMin {max x a |a. a \\<in> A} = Min {max x a |a. a \\<in> A};\n     finite {max x a |a. a \\<in> A}\\<rbrakk>\n    \\<Longrightarrow> max x (Min A) = Min {max x a |a. a \\<in> A}", "apply (simp add: max_Min_eq_Min_max)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma \"\\<lbrakk> finite A; A \\<noteq>{} \\<rbrakk> \\<Longrightarrow> \\<forall>x\\<in>A. x \\<le> Max A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite A; A \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x\\<in>A. x \\<le> Max A", "by simp"], ["", "subsubsection \\<open>\\<open>Min\\<close> and \\<open>Max\\<close> for set operations\\<close>"], ["", "lemma iMin_subset: \"\\<lbrakk> A \\<noteq> {}; A \\<subseteq> B \\<rbrakk> \\<Longrightarrow> iMin B \\<le> iMin A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<noteq> {}; A \\<subseteq> B\\<rbrakk>\n    \\<Longrightarrow> iMin B \\<le> iMin A", "by (blast intro: iMin_le iMinI_ex2)"], ["", "lemma Max_subset: \"\\<lbrakk> A \\<noteq> {}; A \\<subseteq> B; finite B \\<rbrakk> \\<Longrightarrow> Max A \\<le> Max B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<noteq> {}; A \\<subseteq> B; finite B\\<rbrakk>\n    \\<Longrightarrow> Max A \\<le> Max B", "by (rule linorder_class.Max_mono)"], ["", "lemma Min_subset: \"\\<lbrakk> A \\<noteq> {}; A \\<subseteq> B; finite B \\<rbrakk> \\<Longrightarrow> Min B \\<le> Min A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<noteq> {}; A \\<subseteq> B; finite B\\<rbrakk>\n    \\<Longrightarrow> Min B \\<le> Min A", "by (rule linorder_class.Min_antimono)"], ["", "lemma iMin_Int_ge1: \"(A \\<inter> B) \\<noteq> {} \\<Longrightarrow> iMin A \\<le> iMin (A \\<inter> B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<inter> B \\<noteq> {} \\<Longrightarrow>\n    iMin A \\<le> iMin (A \\<inter> B)", "by (rule iMin_subset[OF _ Int_lower1])"], ["", "lemma iMin_Int_ge2: \"(A \\<inter> B) \\<noteq> {} \\<Longrightarrow> iMin B \\<le> iMin (A \\<inter> B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<inter> B \\<noteq> {} \\<Longrightarrow>\n    iMin B \\<le> iMin (A \\<inter> B)", "by (rule iMin_subset[OF _ Int_lower2])"], ["", "lemma iMin_Int_ge: \"(A \\<inter> B) \\<noteq> {} \\<Longrightarrow> max (iMin A) (iMin B) \\<le> iMin (A \\<inter> B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<inter> B \\<noteq> {} \\<Longrightarrow>\n    max (iMin A) (iMin B) \\<le> iMin (A \\<inter> B)", "apply (rule conj_le_imp_max)"], ["proof (prove)\ngoal (2 subgoals):\n 1. A \\<inter> B \\<noteq> {} \\<Longrightarrow>\n    iMin A \\<le> iMin (A \\<inter> B)\n 2. A \\<inter> B \\<noteq> {} \\<Longrightarrow>\n    iMin B \\<le> iMin (A \\<inter> B)", "apply (rule iMin_Int_ge1, assumption)"], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<inter> B \\<noteq> {} \\<Longrightarrow>\n    iMin B \\<le> iMin (A \\<inter> B)", "apply (rule iMin_Int_ge2, assumption)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma Max_Int_le1: \"\\<lbrakk> (A \\<inter> B) \\<noteq> {}; finite A \\<rbrakk> \\<Longrightarrow> Max (A \\<inter> B) \\<le> Max A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<inter> B \\<noteq> {}; finite A\\<rbrakk>\n    \\<Longrightarrow> Max (A \\<inter> B) \\<le> Max A", "by (rule Max_subset[OF _ Int_lower1])"], ["", "lemma Max_Int_le2: \"\\<lbrakk> (A \\<inter> B) \\<noteq> {}; finite B \\<rbrakk> \\<Longrightarrow> Max (A \\<inter> B) \\<le> Max B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<inter> B \\<noteq> {}; finite B\\<rbrakk>\n    \\<Longrightarrow> Max (A \\<inter> B) \\<le> Max B", "by (rule Max_subset[OF _ Int_lower2])"], ["", "lemma Max_Int_le: \"\\<lbrakk> (A \\<inter> B) \\<noteq> {}; finite A; finite B \\<rbrakk> \\<Longrightarrow>\n  Max (A \\<inter> B) \\<le> min (Max A) (Max B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<inter> B \\<noteq> {}; finite A; finite B\\<rbrakk>\n    \\<Longrightarrow> Max (A \\<inter> B) \\<le> min (Max A) (Max B)", "apply (rule conj_le_imp_min)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>A \\<inter> B \\<noteq> {}; finite A; finite B\\<rbrakk>\n    \\<Longrightarrow> Max (A \\<inter> B) \\<le> Max A\n 2. \\<lbrakk>A \\<inter> B \\<noteq> {}; finite A; finite B\\<rbrakk>\n    \\<Longrightarrow> Max (A \\<inter> B) \\<le> Max B", "apply (rule Max_Int_le1, assumption+)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<inter> B \\<noteq> {}; finite A; finite B\\<rbrakk>\n    \\<Longrightarrow> Max (A \\<inter> B) \\<le> Max B", "apply (rule Max_Int_le2, assumption+)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iMin_Un[rule_format]: \"\n  \\<lbrakk> A \\<noteq> {}; B \\<noteq> {} \\<rbrakk> \\<Longrightarrow>\n  iMin (A \\<union> B) = min (iMin A) (iMin B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<noteq> {}; B \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> iMin (A \\<union> B) = min (iMin A) (iMin B)", "apply (rule order_antisym)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>A \\<noteq> {}; B \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> iMin (A \\<union> B) \\<le> min (iMin A) (iMin B)\n 2. \\<lbrakk>A \\<noteq> {}; B \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> min (iMin A) (iMin B) \\<le> iMin (A \\<union> B)", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>A \\<noteq> {}; B \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> iMin (A \\<union> B) \\<le> iMin A \\<and>\n                      iMin (A \\<union> B) \\<le> iMin B\n 2. \\<lbrakk>A \\<noteq> {}; B \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> min (iMin A) (iMin B) \\<le> iMin (A \\<union> B)", "apply (blast intro: iMin_subset)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<noteq> {}; B \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> min (iMin A) (iMin B) \\<le> iMin (A \\<union> B)", "apply (simp add: min_le_iff_disj)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<noteq> {}; B \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> iMin A \\<le> iMin (A \\<union> B) \\<or>\n                      iMin B \\<le> iMin (A \\<union> B)", "apply (insert iMinI_ex2[of \"A\\<union>B\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<noteq> {}; B \\<noteq> {};\n     A \\<union> B \\<noteq> {} \\<Longrightarrow>\n     iMin (A \\<union> B) \\<in> A \\<union> B\\<rbrakk>\n    \\<Longrightarrow> iMin A \\<le> iMin (A \\<union> B) \\<or>\n                      iMin B \\<le> iMin (A \\<union> B)", "apply (blast intro: iMin_le)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iMin_singleton[simp]: \"iMin {a} = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. iMin {a} = a", "by (rule singletonI[THEN iMinI, THEN singletonD])"], ["", "lemma iMax_singleton[simp]: \"iMax {a} = enat a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. iMax {a} = enat a", "by (simp add: iMax_def)"], ["", "lemma Max_le_Min_imp_singleton: \"\n  \\<lbrakk> finite A; A \\<noteq> {}; Max A \\<le> Min A \\<rbrakk> \\<Longrightarrow> A = {Min A}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite A; A \\<noteq> {}; Max A \\<le> Min A\\<rbrakk>\n    \\<Longrightarrow> A = {Min A}", "apply (frule Max_le_iff[THEN iffD1, of _ \"Min A\"], assumption+)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite A; A \\<noteq> {}; Max A \\<le> Min A;\n     \\<forall>a\\<in>A. a \\<le> Min A\\<rbrakk>\n    \\<Longrightarrow> A = {Min A}", "apply (frule Min_ge_iff[THEN iffD1, of _ \"Min A\"], assumption, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite A; A \\<noteq> {}; Max A \\<le> Min A;\n     \\<forall>a\\<in>A. a \\<le> Min A;\n     \\<forall>a\\<in>A. Min A \\<le> a\\<rbrakk>\n    \\<Longrightarrow> A = {Min A}", "apply (rule set_eqI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>finite A; A \\<noteq> {}; Max A \\<le> Min A;\n        \\<forall>a\\<in>A. a \\<le> Min A;\n        \\<forall>a\\<in>A. Min A \\<le> a\\<rbrakk>\n       \\<Longrightarrow> (x \\<in> A) = (x \\<in> {Min A})", "apply (unfold Ball_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>finite A; A \\<noteq> {}; Max A \\<le> Min A;\n        \\<forall>x. x \\<in> A \\<longrightarrow> x \\<le> Min A;\n        \\<forall>x. x \\<in> A \\<longrightarrow> Min A \\<le> x\\<rbrakk>\n       \\<Longrightarrow> (x \\<in> A) = (x \\<in> {Min A})", "apply (erule_tac x=x in allE, erule_tac x=x in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>finite A; A \\<noteq> {}; Max A \\<le> Min A;\n        x \\<in> A \\<longrightarrow> x \\<le> Min A;\n        x \\<in> A \\<longrightarrow> Min A \\<le> x\\<rbrakk>\n       \\<Longrightarrow> (x \\<in> A) = (x \\<in> {Min A})", "apply (blast intro: order_antisym Min_in)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma Max_le_Min_conv_singleton: \"\n  \\<lbrakk> finite A; A \\<noteq> {} \\<rbrakk> \\<Longrightarrow> (Max A \\<le> Min A) = (\\<exists>x. A = {x})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite A; A \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> (Max A \\<le> Min A) = (\\<exists>x. A = {x})", "apply (rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>finite A; A \\<noteq> {}; Max A \\<le> Min A\\<rbrakk>\n    \\<Longrightarrow> \\<exists>x. A = {x}\n 2. \\<lbrakk>finite A; A \\<noteq> {}; \\<exists>x. A = {x}\\<rbrakk>\n    \\<Longrightarrow> Max A \\<le> Min A", "apply (rule_tac x=\"Min A\" in exI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>finite A; A \\<noteq> {}; Max A \\<le> Min A\\<rbrakk>\n    \\<Longrightarrow> A = {Min A}\n 2. \\<lbrakk>finite A; A \\<noteq> {}; \\<exists>x. A = {x}\\<rbrakk>\n    \\<Longrightarrow> Max A \\<le> Min A", "apply (rule Max_le_Min_imp_singleton, assumption+)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite A; A \\<noteq> {}; \\<exists>x. A = {x}\\<rbrakk>\n    \\<Longrightarrow> Max A \\<le> Min A", "apply fastforce"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma Max_le_iMin_imp_le: \"\n  \\<lbrakk> finite A; Max A \\<le> iMin B; a \\<in> A; b \\<in> B \\<rbrakk> \\<Longrightarrow> a \\<le> b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite A; Max A \\<le> iMin B; a \\<in> A; b \\<in> B\\<rbrakk>\n    \\<Longrightarrow> a \\<le> b", "by (blast dest: Max_ge intro: order_trans)"], ["", "lemma le_imp_Max_le_iMin: \"\n  \\<lbrakk> finite A; A \\<noteq> {}; B \\<noteq> {}; \\<forall>a\\<in>A. \\<forall>b\\<in>B. a \\<le> b \\<rbrakk> \\<Longrightarrow> Max A \\<le> iMin B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite A; A \\<noteq> {}; B \\<noteq> {};\n     \\<forall>a\\<in>A. \\<forall>b\\<in>B. a \\<le> b\\<rbrakk>\n    \\<Longrightarrow> Max A \\<le> iMin B", "by (blast intro: Max_in iMinI_ex2)"], ["", "lemma Max_le_iMin_conv_le: \"\n  \\<lbrakk> finite A; A \\<noteq> {}; B \\<noteq> {} \\<rbrakk> \\<Longrightarrow> (Max A \\<le> iMin B) = (\\<forall>a\\<in>A. \\<forall>b\\<in>B. a \\<le> b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite A; A \\<noteq> {}; B \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> (Max A \\<le> iMin B) =\n                      (\\<forall>a\\<in>A. \\<forall>b\\<in>B. a \\<le> b)", "by (blast intro: Max_le_iMin_imp_le le_imp_Max_le_iMin)"], ["", "lemma Max_less_iMin_imp_less: \"\n  \\<lbrakk> finite A; Max A < iMin B; a \\<in> A; b \\<in> B \\<rbrakk> \\<Longrightarrow> a < b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite A; Max A < iMin B; a \\<in> A; b \\<in> B\\<rbrakk>\n    \\<Longrightarrow> a < b", "by (blast dest: Max_less_iff intro: order_less_le_trans iMin_le)"], ["", "lemma less_imp_Max_less_iMin: \"\n  \\<lbrakk> finite A; A \\<noteq> {}; B \\<noteq> {}; \\<forall>a\\<in>A. \\<forall>b\\<in>B. a < b \\<rbrakk> \\<Longrightarrow> Max A < iMin B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite A; A \\<noteq> {}; B \\<noteq> {};\n     \\<forall>a\\<in>A. \\<forall>b\\<in>B. a < b\\<rbrakk>\n    \\<Longrightarrow> Max A < iMin B", "by (blast intro: Max_in iMinI_ex2)"], ["", "lemma Max_less_iMin_conv_less: \"\n  \\<lbrakk> finite A; A \\<noteq> {}; B \\<noteq> {} \\<rbrakk> \\<Longrightarrow> (Max A < iMin B) = (\\<forall>a\\<in>A. \\<forall>b\\<in>B. a < b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite A; A \\<noteq> {}; B \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> (Max A < iMin B) =\n                      (\\<forall>a\\<in>A. \\<forall>b\\<in>B. a < b)", "by (blast intro: Max_less_iMin_imp_less less_imp_Max_less_iMin)"], ["", "lemma Max_less_iMin_imp_disjoint: \"\n  \\<lbrakk> finite A; Max A < iMin B \\<rbrakk> \\<Longrightarrow> A \\<inter> B = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite A; Max A < iMin B\\<rbrakk>\n    \\<Longrightarrow> A \\<inter> B = {}", "apply (case_tac \"A = {}\", simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite A; Max A < iMin B; A \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> A \\<inter> B = {}", "apply (case_tac \"B = {}\", simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite A; Max A < iMin B; A \\<noteq> {}; B \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> A \\<inter> B = {}", "apply (rule disjoint_iff_not_equal[THEN iffD2])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite A; Max A < iMin B; A \\<noteq> {}; B \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x\\<in>A. \\<forall>y\\<in>B. x \\<noteq> y", "apply (intro ballI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>finite A; Max A < iMin B; A \\<noteq> {}; B \\<noteq> {};\n        x \\<in> A; y \\<in> B\\<rbrakk>\n       \\<Longrightarrow> x \\<noteq> y", "apply (rule less_imp_neq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>finite A; Max A < iMin B; A \\<noteq> {}; B \\<noteq> {};\n        x \\<in> A; y \\<in> B\\<rbrakk>\n       \\<Longrightarrow> x < y", "by (rule Max_less_iMin_imp_less)"], ["", "lemma iMin_in_idem: \"n \\<in> I \\<Longrightarrow> min n (iMin I) = iMin I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<in> I \\<Longrightarrow> min n (iMin I) = iMin I", "by (simp add: iMin_le min_eqR)"], ["", "lemma iMin_insert: \"I \\<noteq> {} \\<Longrightarrow> iMin (insert n I) = min n (iMin I)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. I \\<noteq> {} \\<Longrightarrow> iMin (insert n I) = min n (iMin I)", "apply (subst insert_is_Un)"], ["proof (prove)\ngoal (1 subgoal):\n 1. I \\<noteq> {} \\<Longrightarrow> iMin ({n} \\<union> I) = min n (iMin I)", "apply (subst iMin_Un)"], ["proof (prove)\ngoal (3 subgoals):\n 1. I \\<noteq> {} \\<Longrightarrow> {n} \\<noteq> {}\n 2. I \\<noteq> {} \\<Longrightarrow> I \\<noteq> {}\n 3. I \\<noteq> {} \\<Longrightarrow> min (iMin {n}) (iMin I) = min n (iMin I)", "apply simp_all"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iMin_insert_remove: \"\n  iMin (insert n I) =\n  (if I - {n} = {} then n else min n (iMin (I - {n})))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. iMin (insert n I) = (if I - {n} = {} then n else min n (iMin (I - {n})))", "by (metis iMin_insert iMin_singleton insert_Diff_single)"], ["", "lemma iMin_remove: \"n \\<in> I \\<Longrightarrow> iMin I = (if I - {n} = {} then n else min n (iMin (I - {n})))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<in> I \\<Longrightarrow>\n    iMin I = (if I - {n} = {} then n else min n (iMin (I - {n})))", "by (metis iMin_insert_remove insert_absorb)"], ["", "lemma iMin_subset_idem: \"\\<lbrakk> B \\<noteq> {}; B \\<subseteq> A \\<rbrakk> \\<Longrightarrow> min (iMin B) (iMin A) = iMin A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>B \\<noteq> {}; B \\<subseteq> A\\<rbrakk>\n    \\<Longrightarrow> min (iMin B) (iMin A) = iMin A", "by (metis iMin_subset min.absorb2)"], ["", "lemma iMin_union_inter: \"A \\<inter> B \\<noteq> {} \\<Longrightarrow> min (iMin (A \\<union> B)) (iMin (A \\<inter> B)) = min (iMin A) (iMin B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<inter> B \\<noteq> {} \\<Longrightarrow>\n    min (iMin (A \\<union> B)) (iMin (A \\<inter> B)) = min (iMin A) (iMin B)", "by (metis Int_empty_left Int_lower2 Un_absorb2 Un_assoc Un_empty iMin_Un)"], ["", "lemma iMin_ge_iff: \"I \\<noteq> {} \\<Longrightarrow> (n \\<le> iMin I) = (\\<forall>a\\<in>I. n \\<le> a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. I \\<noteq> {} \\<Longrightarrow>\n    (n \\<le> iMin I) = (\\<forall>a\\<in>I. n \\<le> a)", "by (metis Collect_iMin_le Collect_mem_eq iMinI_ex2 order_trans)"], ["", "lemma iMin_gr_iff: \"I \\<noteq> {} \\<Longrightarrow> (n < iMin I) = (\\<forall>a\\<in>I. n < a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. I \\<noteq> {} \\<Longrightarrow> (n < iMin I) = (\\<forall>a\\<in>I. n < a)", "by (metis iMinI_ex2 iMin_neq_imp_greater order_less_trans)"], ["", "lemma iMin_le_iff: \"I \\<noteq> {} \\<Longrightarrow> (iMin I \\<le> n) = (\\<exists>a\\<in>I. a \\<le> n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. I \\<noteq> {} \\<Longrightarrow>\n    (iMin I \\<le> n) = (\\<exists>a\\<in>I. a \\<le> n)", "by (metis Collect_iMin_le Collect_mem_eq iMinI_ex2 order_trans)"], ["", "lemma iMin_less_iff: \"I \\<noteq> {} \\<Longrightarrow> (iMin I < n) = (\\<exists>a\\<in>I. a < n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. I \\<noteq> {} \\<Longrightarrow> (iMin I < n) = (\\<exists>a\\<in>I. a < n)", "by (metis iMinI_ex2 iMin_neq_imp_greater order_less_trans)"], ["", "lemma hom_iMin_commute: \"\\<lbrakk> \\<And>x y. h (min x y) = min (h x) (h y); I \\<noteq> {} \\<rbrakk> \\<Longrightarrow> iMin (h ` I) = h (iMin I)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x y. h (min x y) = min (h x) (h y);\n     I \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> iMin (h ` I) = h (iMin I)", "apply (rule iMin_equality)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>x y. h (min x y) = min (h x) (h y);\n     I \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> h (iMin I) \\<in> h ` I\n 2. \\<And>x.\n       \\<lbrakk>\\<And>x y. h (min x y) = min (h x) (h y); I \\<noteq> {};\n        x \\<in> h ` I\\<rbrakk>\n       \\<Longrightarrow> h (iMin I) \\<le> x", "apply (blast intro: iMinI_ex2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>x y. h (min x y) = min (h x) (h y); I \\<noteq> {};\n        x \\<in> h ` I\\<rbrakk>\n       \\<Longrightarrow> h (iMin I) \\<le> x", "apply (rename_tac y)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>\\<And>x y. h (min x y) = min (h x) (h y); I \\<noteq> {};\n        y \\<in> h ` I\\<rbrakk>\n       \\<Longrightarrow> h (iMin I) \\<le> y", "apply (drule_tac x=\"iMin I\" in meta_spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>I \\<noteq> {}; y \\<in> h ` I;\n        \\<And>y. h (min (iMin I) y) = min (h (iMin I)) (h y)\\<rbrakk>\n       \\<Longrightarrow> h (iMin I) \\<le> y", "apply (clarsimp simp: image_iff, rename_tac x)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>I \\<noteq> {};\n        \\<And>y. h (min (iMin I) y) = min (h (iMin I)) (h y);\n        x \\<in> I\\<rbrakk>\n       \\<Longrightarrow> h (iMin I) \\<le> h x", "apply (drule_tac x=x in meta_spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>I \\<noteq> {}; x \\<in> I;\n        h (min (iMin I) x) = min (h (iMin I)) (h x)\\<rbrakk>\n       \\<Longrightarrow> h (iMin I) \\<le> h x", "apply (rule_tac t=\"h (iMin I)\" and s=\"min (h (iMin I)) (h x)\" in subst)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>I \\<noteq> {}; x \\<in> I;\n        h (min (iMin I) x) = min (h (iMin I)) (h x)\\<rbrakk>\n       \\<Longrightarrow> min (h (iMin I)) (h x) = h (iMin I)\n 2. \\<And>x.\n       \\<lbrakk>I \\<noteq> {}; x \\<in> I;\n        h (min (iMin I) x) = min (h (iMin I)) (h x)\\<rbrakk>\n       \\<Longrightarrow> min (h (iMin I)) (h x) \\<le> h x", "apply (simp add: min_eqL[OF iMin_le])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>I \\<noteq> {}; x \\<in> I;\n        h (min (iMin I) x) = min (h (iMin I)) (h x)\\<rbrakk>\n       \\<Longrightarrow> min (h (iMin I)) (h x) \\<le> h x", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>Synonyms for similarity with theorem names for @{term Min}\"\\<close>"], ["", "lemmas iMin_eqI = iMin_equality"], ["", "lemmas iMin_in = iMinI_ex2"], ["", "subsection \\<open>Some auxiliary results for set operations\\<close>"], ["", "subsubsection \\<open>Some additional abbreviations for relations\\<close>"], ["", "text \\<open>Abbreviations for \\<open>refl\\<close>, \\<open>sym\\<close>, \\<open>equiv\\<close>, \\<open>refl\\<close>, \\<open>trans\\<close>\\<close>"], ["", "abbreviation (input) reflP :: \"('a \\<Rightarrow> 'a \\<Rightarrow> bool) \\<Rightarrow> bool\" where\n  \"reflP r \\<equiv> refl {(x, y). r x y}\""], ["", "abbreviation (input) symP :: \"('a => 'a => bool) => bool\" where\n  \"symP r == sym {(x, y). r x y}\""], ["", "abbreviation (input) transP :: \"('a => 'a => bool) => bool\" where\n  \"transP r == trans {(x, y). r x y}\""], ["", "abbreviation (input) equivP :: \"('a \\<Rightarrow> 'a \\<Rightarrow> bool) \\<Rightarrow> bool\" where\n  \"equivP r \\<equiv> reflP r \\<and> symP r \\<and> transp r\""], ["", "abbreviation (input) irreflP :: \"('a \\<Rightarrow> 'a \\<Rightarrow> bool) \\<Rightarrow> bool\" where\n  \"irreflP r \\<equiv> irrefl {(x, y). r x y}\""], ["", "text \\<open>Example for \\<open>reflP\\<close>\\<close>"], ["", "lemma \"reflP ((\\<le>)::('a::preorder \\<Rightarrow> 'a \\<Rightarrow> bool))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. refl {(x, y). x \\<le> y}", "by (simp add: refl_on_def)"], ["", "text \\<open>Example for \\<open>symP\\<close>\\<close>"], ["", "lemma \"symP (=)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sym {(x, y). x = y}", "by (simp add: sym_def)"], ["", "text \\<open>Example for \\<open>equivP\\<close>\\<close>"], ["", "lemma \"equivP (=)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. refl {(x, y). x = y} \\<and> sym {(x, y). x = y} \\<and> transp (=)", "by (simp add: trans_def refl_on_def sym_def)"], ["", "text \\<open>Example for \\<open>irreflP\\<close>\\<close>"], ["", "lemma \"irreflP ((<)::('a::preorder \\<Rightarrow> 'a \\<Rightarrow> bool))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. irrefl {(x, y). x < y}", "by (simp add: irrefl_def)"], ["", "subsubsection \\<open>Auxiliary results for \\<open>singletons\\<close>\\<close>"], ["", "lemma singleton_not_empty: \"{a} \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {a} \\<noteq> {}", "by blast"], ["", "lemma singleton_finite: \"finite {a}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {a}", "by blast"], ["", "lemma singleton_ball: \"(\\<forall>x\\<in>{a}. P x) = P a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x\\<in>{a}. P x) = P a", "by blast"], ["", "lemma singleton_bex: \"(\\<exists>x\\<in>{a}. P x) = P a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>x\\<in>{a}. P x) = P a", "by blast"], ["", "lemma subset_singleton_conv: \"(A \\<subseteq> {a}) = (A = {} \\<or> A = {a})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A \\<subseteq> {a}) = (A = {} \\<or> A = {a})", "by blast"], ["", "lemma singleton_subset_conv: \"({a} \\<subseteq> A) = (a \\<in> A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ({a} \\<subseteq> A) = (a \\<in> A)", "by blast"], ["", "lemma singleton_eq_conv: \"({a} = {b}) = (a = b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ({a} = {b}) = (a = b)", "by blast"], ["", "lemma singleton_subset_singleton_conv: \"({a} \\<subseteq> {b}) = (a = b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ({a} \\<subseteq> {b}) = (a = b)", "by blast"], ["", "lemma singleton_Int1_if: \"{a} \\<inter> A = (if a \\<in> A then {a} else {})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {a} \\<inter> A = (if a \\<in> A then {a} else {})", "by (split if_split, blast)"], ["", "lemma singleton_Int2_if: \"A \\<inter> {a} = (if a \\<in> A then {a} else {})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<inter> {a} = (if a \\<in> A then {a} else {})", "by (split if_split, blast)"], ["", "lemma singleton_image: \"f ` {a} = {f a}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f ` {a} = {f a}", "by blast"], ["", "lemma inj_on_singleton: \"inj_on f {a}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on f {a}", "by blast"], ["", "lemma strict_mono_on_singleton: \"strict_mono_on f {a}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SetInterval2.strict_mono_on f {a}", "unfolding strict_mono_on_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>aa\\<in>{a}.\n       \\<forall>b\\<in>{a}. aa < b \\<longrightarrow> f aa < f b", "by blast"], ["", "subsubsection \\<open>Auxiliary results for \\<open>finite\\<close> and \\<open>infinite\\<close> sets\\<close>"], ["", "lemma infinite_imp_not_singleton: \"infinite A \\<Longrightarrow> \\<not> (\\<exists>a. A = {a})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infinite A \\<Longrightarrow> \\<nexists>a. A = {a}", "by blast"], ["", "lemma infinite_insert: \"infinite (insert a A) = infinite A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infinite (insert a A) = infinite A", "by simp"], ["", "lemma infinite_Diff_insert: \"infinite (A - insert a B) = infinite (A - B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infinite (A - insert a B) = infinite (A - B)", "by simp"], ["", "lemma subset_finite_imp_finite: \"\\<lbrakk> finite A; B \\<subseteq> A \\<rbrakk> \\<Longrightarrow> finite B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite A; B \\<subseteq> A\\<rbrakk> \\<Longrightarrow> finite B", "by (rule finite_subset)"], ["", "lemma infinite_not_subset_finite: \"\\<lbrakk> infinite A; finite B \\<rbrakk> \\<Longrightarrow> \\<not> A \\<subseteq> B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>infinite A; finite B\\<rbrakk>\n    \\<Longrightarrow> \\<not> A \\<subseteq> B", "by (blast intro: subset_finite_imp_finite)"], ["", "lemma Un_infinite_right: \"infinite T \\<Longrightarrow> infinite (S \\<union> T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infinite T \\<Longrightarrow> infinite (S \\<union> T)", "by blast"], ["", "lemma Un_infinite_iff: \"infinite (S \\<union> T) = (infinite S \\<or> infinite T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infinite (S \\<union> T) = (infinite S \\<or> infinite T)", "by blast"], ["", "text \\<open>Give own name to the lemma about finiteness of the integer image of a nat set\\<close>"], ["", "corollary finite_A_int_A_conv: \"finite A = finite (int ` A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite A = finite (int ` A)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite A = finite (int ` A)", "have \"inj_on int A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on int A", "by (auto intro: inj_onI)"], ["proof (state)\nthis:\n  inj_on int A\n\ngoal (1 subgoal):\n 1. finite A = finite (int ` A)", "then"], ["proof (chain)\npicking this:\n  inj_on int A", "show ?thesis"], ["proof (prove)\nusing this:\n  inj_on int A\n\ngoal (1 subgoal):\n 1. finite A = finite (int ` A)", "by (simp add: finite_image_iff)"], ["proof (state)\nthis:\n  finite A = finite (int ` A)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Corresponding fact fo infinite sets\\<close>"], ["", "corollary infinite_A_int_A_conv: \"infinite A = infinite (int ` A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infinite A = infinite (int ` A)", "by (simp only: finite_A_int_A_conv)"], ["", "lemma cartesian_product_infiniteL_imp_infinite: \"\\<lbrakk> infinite A; B \\<noteq> {} \\<rbrakk> \\<Longrightarrow> infinite (A \\<times> B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>infinite A; B \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> infinite (A \\<times> B)", "by (blast dest: finite_cartesian_productD1)"], ["", "lemma cartesian_product_infiniteR_imp_infinite: \"\\<lbrakk> infinite B; A \\<noteq> {} \\<rbrakk> \\<Longrightarrow> infinite (A \\<times> B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>infinite B; A \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> infinite (A \\<times> B)", "by (blast dest: finite_cartesian_productD2)"], ["", "lemma finite_nat_iff_bounded2: \"\n  finite S = (\\<exists>(k::nat).\\<forall>n\\<in>S. n < k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite S = (\\<exists>k. \\<forall>n\\<in>S. n < k)", "by (simp only: finite_nat_iff_bounded, blast)"], ["", "lemma finite_nat_iff_bounded_le2: \"\n  finite S = (\\<exists>(k::nat).\\<forall>n\\<in>S. n \\<le> k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite S = (\\<exists>k. \\<forall>n\\<in>S. n \\<le> k)", "by (simp only: finite_nat_iff_bounded_le, blast)"], ["", "lemma nat_asc_chain_imp_unbounded: \"\n  \\<lbrakk> S \\<noteq> {}; (\\<forall>m\\<in>S. \\<exists>n\\<in>S. m < (n::nat)) \\<rbrakk> \\<Longrightarrow> \\<forall>m. \\<exists>n\\<in>S. m \\<le> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>S \\<noteq> {};\n     \\<forall>m\\<in>S. \\<exists>n\\<in>S. m < n\\<rbrakk>\n    \\<Longrightarrow> \\<forall>m. \\<exists>n\\<in>S. m \\<le> n", "apply (rule allI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m.\n       \\<lbrakk>S \\<noteq> {};\n        \\<forall>m\\<in>S. \\<exists>n\\<in>S. m < n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n\\<in>S. m \\<le> n", "apply (induct_tac m)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>m.\n       \\<lbrakk>S \\<noteq> {};\n        \\<forall>m\\<in>S. \\<exists>n\\<in>S. m < n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n\\<in>S. 0 \\<le> n\n 2. \\<And>m n.\n       \\<lbrakk>S \\<noteq> {}; \\<forall>m\\<in>S. \\<exists>n\\<in>S. m < n;\n        \\<exists>na\\<in>S. n \\<le> na\\<rbrakk>\n       \\<Longrightarrow> \\<exists>na\\<in>S. Suc n \\<le> na", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m n.\n       \\<lbrakk>S \\<noteq> {}; \\<forall>m\\<in>S. \\<exists>n\\<in>S. m < n;\n        \\<exists>na\\<in>S. n \\<le> na\\<rbrakk>\n       \\<Longrightarrow> \\<exists>na\\<in>S. Suc n \\<le> na", "apply (erule bexE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m n na.\n       \\<lbrakk>S \\<noteq> {}; \\<forall>m\\<in>S. \\<exists>n\\<in>S. m < n;\n        na \\<in> S; n \\<le> na\\<rbrakk>\n       \\<Longrightarrow> \\<exists>na\\<in>S. Suc n \\<le> na", "apply (rename_tac n1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m n n1.\n       \\<lbrakk>S \\<noteq> {}; \\<forall>m\\<in>S. \\<exists>n\\<in>S. m < n;\n        n1 \\<in> S; n \\<le> n1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>na\\<in>S. Suc n \\<le> na", "apply (erule_tac x=n1 in ballE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>m n n1.\n       \\<lbrakk>S \\<noteq> {}; n1 \\<in> S; n \\<le> n1;\n        \\<exists>n\\<in>S. n1 < n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>na\\<in>S. Suc n \\<le> na\n 2. \\<And>m n n1.\n       \\<lbrakk>S \\<noteq> {}; n1 \\<in> S; n \\<le> n1;\n        n1 \\<notin> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>na\\<in>S. Suc n \\<le> na", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>m n n1.\n       \\<lbrakk>S \\<noteq> {}; n1 \\<in> S; n \\<le> n1;\n        n1 \\<notin> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>na\\<in>S. Suc n \\<le> na\n 2. \\<And>m n n1.\n       \\<lbrakk>S \\<noteq> {}; n1 \\<in> S; n \\<le> n1;\n        \\<exists>n\\<in>S. n1 < n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>na\\<in>S. Suc n \\<le> na", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m n n1.\n       \\<lbrakk>S \\<noteq> {}; n1 \\<in> S; n \\<le> n1;\n        \\<exists>n\\<in>S. n1 < n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>na\\<in>S. Suc n \\<le> na", "apply (clarify, rename_tac x, rule_tac x=x in bexI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>m n n1 x.\n       \\<lbrakk>S \\<noteq> {}; n1 \\<in> S; n \\<le> n1; x \\<in> S;\n        n1 < x\\<rbrakk>\n       \\<Longrightarrow> Suc n \\<le> x\n 2. \\<And>m n n1 x.\n       \\<lbrakk>S \\<noteq> {}; n1 \\<in> S; n \\<le> n1; x \\<in> S;\n        n1 < x\\<rbrakk>\n       \\<Longrightarrow> x \\<in> S", "apply simp_all"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma infinite_nat_iff_asc_chain: \"\n  S \\<noteq> {} \\<Longrightarrow> infinite S = (\\<forall>m\\<in>S. \\<exists>n\\<in>S. m < (n::nat))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S \\<noteq> {} \\<Longrightarrow>\n    infinite S = (\\<forall>m\\<in>S. \\<exists>n\\<in>S. m < n)", "by (metis Max_in infinite_nat_iff_unbounded not_greater_Max)"], ["", "lemma infinite_imp_asc_chain: \"infinite S \\<Longrightarrow> \\<forall>m\\<in>S. \\<exists>n\\<in>S. m < (n::nat)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infinite S \\<Longrightarrow> \\<forall>m\\<in>S. \\<exists>n\\<in>S. m < n", "by (rule infinite_nat_iff_asc_chain[THEN iffD1, OF infinite_imp_nonempty])"], ["", "lemma infinite_image_imp_infinite: \"infinite (f ` A) \\<Longrightarrow> infinite A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infinite (f ` A) \\<Longrightarrow> infinite A", "by fastforce"], ["", "lemma inj_on_imp_infinite_image: \"\\<lbrakk> infinite A; inj_on f A \\<rbrakk> \\<Longrightarrow> infinite (f ` A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>infinite A; inj_on f A\\<rbrakk>\n    \\<Longrightarrow> infinite (f ` A)", "apply (frule card_image)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>infinite A; inj_on f A; card (f ` A) = card A\\<rbrakk>\n    \\<Longrightarrow> infinite (f ` A)", "apply (fastforce simp: card_eq_0_iff)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma inj_on_infinite_image_iff: \"inj_on f A \\<Longrightarrow> infinite (f ` A) = infinite A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on f A \\<Longrightarrow> infinite (f ` A) = infinite A", "apply (rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>inj_on f A; infinite (f ` A)\\<rbrakk>\n    \\<Longrightarrow> infinite A\n 2. \\<lbrakk>inj_on f A; infinite A\\<rbrakk>\n    \\<Longrightarrow> infinite (f ` A)", "apply (rule ccontr, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>inj_on f A; infinite A\\<rbrakk>\n    \\<Longrightarrow> infinite (f ` A)", "apply (rule inj_on_imp_infinite_image, assumption+)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma inj_on_finite_image_iff: \"inj_on f A \\<Longrightarrow> finite (f ` A) = finite A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on f A \\<Longrightarrow> finite (f ` A) = finite A", "by (drule inj_on_infinite_image_iff, simp)"], ["", "lemma nat_ex_greater_finite_Max_conv: \"\n  A \\<noteq> {} \\<Longrightarrow> (\\<exists>x\\<in>A. (n::nat) < x) = (finite A \\<longrightarrow> n < Max A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<noteq> {} \\<Longrightarrow>\n    (\\<exists>x\\<in>A. n < x) = (finite A \\<longrightarrow> n < Max A)", "apply (rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>A \\<noteq> {}; \\<exists>x\\<in>A. n < x\\<rbrakk>\n    \\<Longrightarrow> finite A \\<longrightarrow> n < Max A\n 2. \\<lbrakk>A \\<noteq> {}; finite A \\<longrightarrow> n < Max A\\<rbrakk>\n    \\<Longrightarrow> \\<exists>x\\<in>A. n < x", "apply (blast intro: order_less_le_trans Max_ge)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<noteq> {}; finite A \\<longrightarrow> n < Max A\\<rbrakk>\n    \\<Longrightarrow> \\<exists>x\\<in>A. n < x", "apply (case_tac \"finite A\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>A \\<noteq> {}; finite A \\<longrightarrow> n < Max A;\n     finite A\\<rbrakk>\n    \\<Longrightarrow> \\<exists>x\\<in>A. n < x\n 2. \\<lbrakk>A \\<noteq> {}; finite A \\<longrightarrow> n < Max A;\n     infinite A\\<rbrakk>\n    \\<Longrightarrow> \\<exists>x\\<in>A. n < x", "apply (blast intro: Max_in)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<noteq> {}; finite A \\<longrightarrow> n < Max A;\n     infinite A\\<rbrakk>\n    \\<Longrightarrow> \\<exists>x\\<in>A. n < x", "apply (drule infinite_nat_iff_unbounded[THEN iffD1, rule_format, of _ n])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<noteq> {}; finite A \\<longrightarrow> n < Max A;\n     \\<exists>na>n. na \\<in> A\\<rbrakk>\n    \\<Longrightarrow> \\<exists>x\\<in>A. n < x", "apply blast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "corollary nat_ex_greater_infinite_finite_Max_conv': \"\n  (\\<exists>x\\<in>A. (n::nat) < x) = (finite A \\<and> A \\<noteq> {} \\<and> n < Max A \\<or> infinite A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>x\\<in>A. n < x) =\n    (finite A \\<and> A \\<noteq> {} \\<and> n < Max A \\<or> infinite A)", "apply (case_tac \"A = {}\", blast)"], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<noteq> {} \\<Longrightarrow>\n    (\\<exists>x\\<in>A. n < x) =\n    (finite A \\<and> A \\<noteq> {} \\<and> n < Max A \\<or> infinite A)", "apply (drule nat_ex_greater_finite_Max_conv[of _ n])"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>x\\<in>A. n < x) =\n    (finite A \\<longrightarrow> n < Max A) \\<Longrightarrow>\n    (\\<exists>x\\<in>A. n < x) =\n    (finite A \\<and> A \\<noteq> {} \\<and> n < Max A \\<or> infinite A)", "apply blast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsubsection \\<open>Some auxiliary results for disjoint sets\\<close>"], ["", "lemma disjoint_iff_in_not_in1: \"(A \\<inter> B = {}) = (\\<forall>x\\<in>A. x \\<notin> B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A \\<inter> B = {}) = (\\<forall>x\\<in>A. x \\<notin> B)", "by blast"], ["", "lemma disjoint_iff_in_not_in2: \"(A \\<inter> B = {}) = (\\<forall>x\\<in>B. x \\<notin> A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A \\<inter> B = {}) = (\\<forall>x\\<in>B. x \\<notin> A)", "by blast"], ["", "lemma disjoint_in_Un: \"\n  \\<lbrakk> A \\<inter> B = {}; x \\<in> A \\<union> B \\<rbrakk> \\<Longrightarrow> x \\<notin> A \\<or> x \\<notin> B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<inter> B = {}; x \\<in> A \\<union> B\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> A \\<or> x \\<notin> B", "by (blast intro: disjoint_iff_in_not_in1[THEN iffD1])+"], ["", "lemma partition_Union: \"A \\<subseteq> \\<Union>C \\<Longrightarrow> (\\<Union>c\\<in>C. A \\<inter> c) = A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<subseteq> \\<Union> C \\<Longrightarrow>\n    \\<Union> ((\\<inter>) A ` C) = A", "by blast"], ["", "lemma disjoint_partition_Int: \"\n  \\<forall>c1\\<in>C. \\<forall>c2\\<in>C. c1 \\<noteq> c2 \\<longrightarrow> c1 \\<inter> c2 = {} \\<Longrightarrow>\n  \\<forall>a1\\<in>{A \\<inter> c| c. c \\<in> C}. \\<forall>a2\\<in>{A \\<inter> c| c. c \\<in> C}.\n    a1 \\<noteq> a2 \\<longrightarrow> a1 \\<inter> a2 = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>c1\\<in>C.\n       \\<forall>c2\\<in>C.\n          c1 \\<noteq> c2 \\<longrightarrow>\n          c1 \\<inter> c2 = {} \\<Longrightarrow>\n    \\<forall>a1\\<in>{A \\<inter> c |c. c \\<in> C}.\n       \\<forall>a2\\<in>{A \\<inter> c |c. c \\<in> C}.\n          a1 \\<noteq> a2 \\<longrightarrow> a1 \\<inter> a2 = {}", "by blast"], ["", "lemma \"{f x |x. x \\<in> A} = (\\<Union>x\\<in>A. {f x})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {f x |x. x \\<in> A} = (\\<Union>x\\<in>A. {f x})", "by fastforce"], ["", "text \\<open>This lemma version drops the superfluous precondition @{term \"finite (\\<Union>C)\"}\n  (and turns the resulting equation to the sensible order \\<open>card .. = k * card ..\\<close>).\\<close>"], ["", "lemma card_partition: \"\n  \\<lbrakk> finite C; \\<And>c. c \\<in> C \\<Longrightarrow> card c = k; \\<And>c1 c2. \\<lbrakk>c1 \\<in> C; c2 \\<in> C; c1 \\<noteq> c2\\<rbrakk> \\<Longrightarrow> c1 \\<inter> c2 = {} \\<rbrakk> \\<Longrightarrow>\n  card (\\<Union>C) = k * card C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite C; \\<And>c. c \\<in> C \\<Longrightarrow> card c = k;\n     \\<And>c1 c2.\n        \\<lbrakk>c1 \\<in> C; c2 \\<in> C; c1 \\<noteq> c2\\<rbrakk>\n        \\<Longrightarrow> c1 \\<inter> c2 = {}\\<rbrakk>\n    \\<Longrightarrow> card (\\<Union> C) = k * card C", "by (metis card.infinite card_partition finite_Union mult_eq_if)"], ["", "subsubsection \\<open>Some auxiliary results for subset relation\\<close>"], ["", "lemma subset_image_Int: \"A \\<subseteq> B \\<Longrightarrow> f ` (A \\<inter> B) = f ` A \\<inter> f ` B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<subseteq> B \\<Longrightarrow>\n    f ` (A \\<inter> B) = f ` A \\<inter> f ` B", "by (simp only: Int_absorb2 image_mono)"], ["", "lemma image_diff_disjoint_image_Int: \"\n  \\<lbrakk> f ` (A - B) \\<inter> f ` B = {} \\<rbrakk> \\<Longrightarrow>\n  f ` (A \\<inter> B) = f ` A \\<inter> f ` B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f ` (A - B) \\<inter> f ` B = {} \\<Longrightarrow>\n    f ` (A \\<inter> B) = f ` A \\<inter> f ` B", "apply (rule set_eqI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       f ` (A - B) \\<inter> f ` B = {} \\<Longrightarrow>\n       (x \\<in> f ` (A \\<inter> B)) = (x \\<in> f ` A \\<inter> f ` B)", "apply (simp add: image_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       f ` (A - B) \\<inter> f ` B = {} \\<Longrightarrow>\n       (\\<exists>xa\\<in>A \\<inter> B. x = f xa) =\n       ((\\<exists>xa\\<in>A. x = f xa) \\<and> (\\<exists>xa\\<in>B. x = f xa))", "apply blast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma subset_imp_Int_subset1: \"A \\<subseteq> C \\<Longrightarrow> A \\<inter> B \\<subseteq> C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<subseteq> C \\<Longrightarrow> A \\<inter> B \\<subseteq> C", "by (rule subset_trans[of _ \"C \\<inter> B\", OF Int_mono, OF _ subset_refl Int_lower1])"], ["", "lemma subset_imp_Int_subset2: \"B \\<subseteq> C \\<Longrightarrow> A \\<inter> B \\<subseteq> C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B \\<subseteq> C \\<Longrightarrow> A \\<inter> B \\<subseteq> C", "by (simp only: Int_commute[of A], rule subset_imp_Int_subset1)"], ["", "subsubsection \\<open>Auxiliary results for intervals from \\<open>SetInterval\\<close>\\<close>"], ["", "lemmas set_interval_defs =\n  lessThan_def atMost_def\n  greaterThan_def atLeast_def\n  greaterThanLessThan_def atLeastLessThan_def\n  greaterThanAtMost_def atLeastAtMost_def"], ["", "lemma image_add_atLeast:\n  \"(\\<lambda>n::nat. n+k) ` {i..} = {i+k..}\" (is \"?A = ?B\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n. n + k) ` {i..} = {i + k..}", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<lambda>n. n + k) ` {i..} \\<subseteq> {i + k..}\n 2. {i + k..} \\<subseteq> (\\<lambda>n. n + k) ` {i..}", "show \"?A \\<subseteq> ?B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n. n + k) ` {i..} \\<subseteq> {i + k..}", "by fastforce"], ["proof (state)\nthis:\n  (\\<lambda>n. n + k) ` {i..} \\<subseteq> {i + k..}\n\ngoal (1 subgoal):\n 1. {i + k..} \\<subseteq> (\\<lambda>n. n + k) ` {i..}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. {i + k..} \\<subseteq> (\\<lambda>n. n + k) ` {i..}", "show \"?B \\<subseteq> ?A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {i + k..} \\<subseteq> (\\<lambda>n. n + k) ` {i..}", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {i + k..} \\<Longrightarrow>\n       x \\<in> (\\<lambda>n. n + k) ` {i..}", "fix n"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {i + k..} \\<Longrightarrow>\n       x \\<in> (\\<lambda>n. n + k) ` {i..}", "assume a: \"n : ?B\""], ["proof (state)\nthis:\n  n \\<in> {i + k..}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {i + k..} \\<Longrightarrow>\n       x \\<in> (\\<lambda>n. n + k) ` {i..}", "hence \"n - k \\<in> {i..}\""], ["proof (prove)\nusing this:\n  n \\<in> {i + k..}\n\ngoal (1 subgoal):\n 1. n - k \\<in> {i..}", "by simp"], ["proof (state)\nthis:\n  n - k \\<in> {i..}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {i + k..} \\<Longrightarrow>\n       x \\<in> (\\<lambda>n. n + k) ` {i..}", "moreover"], ["proof (state)\nthis:\n  n - k \\<in> {i..}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {i + k..} \\<Longrightarrow>\n       x \\<in> (\\<lambda>n. n + k) ` {i..}", "have \"n = (n - k) + k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n = n - k + k", "using a"], ["proof (prove)\nusing this:\n  n \\<in> {i + k..}\n\ngoal (1 subgoal):\n 1. n = n - k + k", "by fastforce"], ["proof (state)\nthis:\n  n = n - k + k\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {i + k..} \\<Longrightarrow>\n       x \\<in> (\\<lambda>n. n + k) ` {i..}", "ultimately"], ["proof (chain)\npicking this:\n  n - k \\<in> {i..}\n  n = n - k + k", "show \"n \\<in> ?A\""], ["proof (prove)\nusing this:\n  n - k \\<in> {i..}\n  n = n - k + k\n\ngoal (1 subgoal):\n 1. n \\<in> (\\<lambda>n. n + k) ` {i..}", "by blast"], ["proof (state)\nthis:\n  n \\<in> (\\<lambda>n. n + k) ` {i..}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  {i + k..} \\<subseteq> (\\<lambda>n. n + k) ` {i..}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma image_add_atMost:\n  \"(\\<lambda>n::nat. n+k) ` {..i} = {k..i+k}\" (is \"?A = ?B\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n. n + k) ` {..i} = {k..i + k}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<lambda>n. n + k) ` {..i} = {k..i + k}", "have s1: \"{..i} = {0..i}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {..i} = {0..i}", "by (simp add: set_interval_defs)"], ["proof (state)\nthis:\n  {..i} = {0..i}\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. n + k) ` {..i} = {k..i + k}", "then"], ["proof (chain)\npicking this:\n  {..i} = {0..i}", "show \"?A = ?B\""], ["proof (prove)\nusing this:\n  {..i} = {0..i}\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. n + k) ` {..i} = {k..i + k}", "by simp"], ["proof (state)\nthis:\n  (\\<lambda>n. n + k) ` {..i} = {k..i + k}\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary image_Suc_atLeast: \"Suc ` {i..} = {Suc i..}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc ` {i..} = {Suc i..}", "by (insert image_add_atLeast[of \"Suc 0\"], simp)"], ["", "corollary image_Suc_atMost: \"Suc ` {..i} = {Suc 0..Suc i}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc ` {..i} = {Suc 0..Suc i}", "by (insert image_add_atMost[of \"Suc 0\"], simp)"], ["", "lemmas image_add_lemmas =\n  image_add_atLeastAtMost\n  image_add_atLeast\n  image_add_atMost"], ["", "lemmas image_Suc_lemmas =\n  image_Suc_atLeastAtMost\n  image_Suc_atLeast\n  image_Suc_atMost"], ["", "lemma atMost_atLeastAtMost_0_conv: \"{..i::nat} = {0..i}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {..i} = {0..i}", "by (simp add: set_interval_defs)"], ["", "lemma atLeastAtMost_subset_atMost: \"(k::'a::order) \\<le> k' \\<Longrightarrow> {l..k} \\<subseteq> {..k'}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k \\<le> k' \\<Longrightarrow> {l..k} \\<subseteq> {..k'}", "by (simp)"], ["", "lemma lessThan_insert: \"insert (n::'a::order) {..<n} = {..n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert n {..<n} = {..n}", "apply (rule set_eqI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. (x \\<in> insert n {..<n}) = (x \\<in> {..n})", "apply (clarsimp simp add: order_le_less)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. (x = n \\<or> x < n) = (x < n \\<or> x = n)", "apply blast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma greaterThan_insert: \"insert (n::'a::order) {n<..} = {n..}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert n {n<..} = {n..}", "apply (rule set_eqI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. (x \\<in> insert n {n<..}) = (x \\<in> {n..})", "apply (clarsimp simp add: order_le_less)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. (x = n \\<or> n < x) = (n < x \\<or> n = x)", "apply blast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma atMost_remove: \"{..n} - {(n::'a::order)} = {..<n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {..n} - {n} = {..<n}", "apply (simp only: lessThan_insert[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. insert n {..<n} - {n} = {..<n}", "apply (rule Diff_insert_absorb)"], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<notin> {..<n}", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma atLeast_remove: \"{n..} - {(n::'a::order)} = {n<..}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {n..} - {n} = {n<..}", "apply (simp only: greaterThan_insert[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. insert n {n<..} - {n} = {n<..}", "apply (rule Diff_insert_absorb)"], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<notin> {n<..}", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma atMost_lessThan_conv: \"{..n} = {..<Suc n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {..n} = {..<Suc n}", "by (simp only: atMost_def lessThan_def less_Suc_eq_le)"], ["", "lemma atLeastAtMost_atLeastLessThan_conv: \"{l..u} = {l..<Suc u}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {l..u} = {l..<Suc u}", "by (simp only: atLeastAtMost_def atLeastLessThan_def atMost_lessThan_conv)"], ["", "lemma atLeast_greaterThan_conv: \"{Suc n..} = {n<..}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {Suc n..} = {n<..}", "by (simp only: atLeast_def greaterThan_def Suc_le_eq)"], ["", "lemma atLeastAtMost_greaterThanAtMost_conv: \"{Suc l..u} = {l<..u}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {Suc l..u} = {l<..u}", "by (simp only: greaterThanAtMost_def atLeastAtMost_def atLeast_greaterThan_conv)"], ["", "lemma finite_subset_atLeastAtMost: \"finite A \\<Longrightarrow> A \\<subseteq> {Min A..Max A}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite A \\<Longrightarrow> A \\<subseteq> {Min A..Max A}", "by (simp add: subset_eq)"], ["", "lemma Max_le_imp_subset_atMost: \"\n  \\<lbrakk> finite A;  Max A \\<le> n \\<rbrakk> \\<Longrightarrow> A \\<subseteq> {..n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite A; Max A \\<le> n\\<rbrakk>\n    \\<Longrightarrow> A \\<subseteq> {..n}", "by (rule subset_trans[OF finite_subset_atLeastAtMost atLeastAtMost_subset_atMost])"], ["", "lemma subset_atMost_imp_Max_le:\"\n  \\<lbrakk> finite A; A \\<noteq> {}; A \\<subseteq> {..n} \\<rbrakk> \\<Longrightarrow> Max A \\<le> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite A; A \\<noteq> {}; A \\<subseteq> {..n}\\<rbrakk>\n    \\<Longrightarrow> Max A \\<le> n", "by (simp add: subset_iff)"], ["", "lemma subset_atMost_Max_le_conv: \"\n  \\<lbrakk> finite A; A \\<noteq> {} \\<rbrakk> \\<Longrightarrow> (A \\<subseteq> {..n}) = (Max A \\<le> n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite A; A \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> (A \\<subseteq> {..n}) = (Max A \\<le> n)", "apply (rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>finite A; A \\<noteq> {}; A \\<subseteq> {..n}\\<rbrakk>\n    \\<Longrightarrow> Max A \\<le> n\n 2. \\<lbrakk>finite A; A \\<noteq> {}; Max A \\<le> n\\<rbrakk>\n    \\<Longrightarrow> A \\<subseteq> {..n}", "apply (blast intro: subset_atMost_imp_Max_le)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite A; A \\<noteq> {}; Max A \\<le> n\\<rbrakk>\n    \\<Longrightarrow> A \\<subseteq> {..n}", "apply (rule Max_le_imp_subset_atMost, assumption+)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iMin_atLeast: \"iMin {n..} = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. iMin {n..} = n", "by (rule iMin_equality, simp_all)"], ["", "lemma iMin_greaterThan: \"iMin {n<..} = Suc n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. iMin {n<..} = Suc n", "by (simp only: atLeast_Suc_greaterThan[symmetric] iMin_atLeast)"], ["", "lemma iMin_atMost: \"iMin {..(n::nat)} = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. iMin {..n} = 0", "by (rule iMin_equality, simp_all)"], ["", "lemma iMin_lessThan: \"0 < n \\<Longrightarrow> iMin {..<(n::nat)} = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < n \\<Longrightarrow> iMin {..<n} = 0", "by (rule iMin_equality, simp_all)"], ["", "lemma Max_atMost: \"Max {..(n::nat)} = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Max {..n} = n", "by (rule Max_equality[OF _ finite_atMost], simp_all)"], ["", "lemma Max_lessThan: \"0 < n \\<Longrightarrow> Max {..<n} = n - Suc 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < n \\<Longrightarrow> Max {..<n} = n - Suc 0", "by (rule Max_equality[OF _ finite_lessThan], simp_all)"], ["", "lemma iMin_atLeastLessThan: \"m < n \\<Longrightarrow> iMin {m..<n} = m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m < n \\<Longrightarrow> iMin {m..<n} = m", "by (rule iMin_equality, simp_all)"], ["", "lemma Max_atLeastLessThan: \"m < n \\<Longrightarrow> Max {m..<n} = n - Suc 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m < n \\<Longrightarrow> Max {m..<n} = n - Suc 0", "by (rule Max_equality[OF _ finite_atLeastLessThan], simp_all add: less_imp_le_pred)"], ["", "lemma iMin_greaterThanLessThan: \"Suc m < n \\<Longrightarrow> iMin {m<..<n} = Suc m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc m < n \\<Longrightarrow> iMin {m<..<n} = Suc m", "by (simp only: atLeastSucLessThan_greaterThanLessThan[symmetric] iMin_atLeastLessThan)"], ["", "lemma Max_greaterThanLessThan: \"Suc m < n \\<Longrightarrow> Max {m<..<n} = n - Suc 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc m < n \\<Longrightarrow> Max {m<..<n} = n - Suc 0", "by (simp only: atLeastSucLessThan_greaterThanLessThan[symmetric] Max_atLeastLessThan)"], ["", "lemma iMin_greaterThanAtMost: \"m < n \\<Longrightarrow> iMin {m<..n} = Suc m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m < n \\<Longrightarrow> iMin {m<..n} = Suc m", "by (simp only: atLeastSucAtMost_greaterThanAtMost[symmetric] atLeastLessThanSuc_atLeastAtMost[symmetric] iMin_atLeastLessThan)"], ["", "lemma Max_greaterThanAtMost: \"m < n \\<Longrightarrow> Max {m<..(n::nat)} = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m < n \\<Longrightarrow> Max {m<..n} = n", "by (simp add: atLeastSucAtMost_greaterThanAtMost[symmetric] atLeastLessThanSuc_atLeastAtMost[symmetric] Max_atLeastLessThan)"], ["", "lemma iMin_atLeastAtMost: \"m \\<le> n \\<Longrightarrow> iMin {m..n} = m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<le> n \\<Longrightarrow> iMin {m..n} = m", "by (rule iMin_equality, simp_all)"], ["", "lemma Max_atLeastAtMost: \"m \\<le> n \\<Longrightarrow> Max {m..(n::nat)} = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<le> n \\<Longrightarrow> Max {m..n} = n", "by (rule Max_equality[OF _ finite_atLeastAtMost], simp_all)"], ["", "lemma infinite_atLeast: \"infinite {(n::nat)..}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infinite {n..}", "by (rule unbounded_k_infinite[of n], fastforce)"], ["", "lemma infinite_greaterThan: \"infinite {(n::nat)<..}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infinite {n<..}", "by (simp add: atLeast_Suc_greaterThan[symmetric] infinite_atLeast)"], ["", "lemma infinite_atLeast_int: \"infinite {(n::int)..}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infinite {n..}", "apply (rule_tac f=\"\\<lambda>x. nat (x - n)\" in inj_on_infinite_image_iff[THEN iffD1, rule_format])"], ["proof (prove)\ngoal (2 subgoals):\n 1. inj_on (\\<lambda>x. nat (x - n)) {n..}\n 2. infinite ((\\<lambda>x. nat (x - n)) ` {n..})", "apply (fastforce simp: inj_on_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. infinite ((\\<lambda>x. nat (x - n)) ` {n..})", "apply (rule_tac t=\"((\\<lambda>x. nat (x - n)) ` {n..})\" and s=\"{0..}\" in subst)"], ["proof (prove)\ngoal (2 subgoals):\n 1. {0..} = (\\<lambda>x. nat (x - n)) ` {n..}\n 2. infinite {0..}", "apply (simp add: set_eq_iff image_iff Bex_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>x. \\<exists>xa\\<ge>n. x = nat (xa - n)\n 2. infinite {0..}", "apply (clarify, rename_tac n1)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n1. \\<exists>x\\<ge>n. n1 = nat (x - n)\n 2. infinite {0..}", "apply (rule_tac x=\"n + int n1\" in exI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n1. n \\<le> n + int n1 \\<and> n1 = nat (n + int n1 - n)\n 2. infinite {0..}", "apply simp_all"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma infinite_greaterThan_int: \"infinite {(n::int)<..}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infinite {n<..}", "apply (simp only: atLeast_remove[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. infinite ({n..} - {n})", "apply (rule Diff_infinite_finite[OF singleton_finite])"], ["proof (prove)\ngoal (1 subgoal):\n 1. infinite {n..}", "apply (rule infinite_atLeast_int)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma infinite_atMost_int: \"infinite {..(n::int)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infinite {..n}", "apply (rule_tac f=\"\\<lambda>x. n - x\" in inj_on_infinite_image_iff[THEN iffD1, rule_format])"], ["proof (prove)\ngoal (2 subgoals):\n 1. inj_on ((-) n) {..n}\n 2. infinite ((-) n ` {..n})", "apply (simp add: inj_on_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. infinite ((-) n ` {..n})", "apply (rule_tac t=\"((-) n ` {..n})\" and s=\"{0..}\" in subst)"], ["proof (prove)\ngoal (2 subgoals):\n 1. {0..} = (-) n ` {..n}\n 2. infinite {0..}", "apply (simp add: set_eq_iff image_iff Bex_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. infinite {0..}", "apply (rule infinite_atLeast_int)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma infinite_lessThan_int: \"infinite {..<(n::int)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infinite {..<n}", "apply (simp only: atMost_remove[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. infinite ({..n} - {n})", "apply (rule Diff_infinite_finite[OF singleton_finite])"], ["proof (prove)\ngoal (1 subgoal):\n 1. infinite {..n}", "apply (rule infinite_atMost_int)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsubsection \\<open>Auxiliary results for @{term card}\\<close>"], ["", "lemma sum_singleton: \"(\\<Sum>x\\<in>{a}. f x) = f a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum f {a} = f a", "by simp"], ["", "lemma card_singleton: \"card {a} = Suc 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card {a} = Suc 0", "by simp"], ["", "lemma card_cartesian_product_singleton_right: \"card (A \\<times> {x}) = card A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (A \\<times> {x}) = card A", "by (simp add: card_cartesian_product)"], ["", "lemma card_1_imp_singleton: \"card A = Suc 0 \\<Longrightarrow> (\\<exists>a. A = {a})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card A = Suc 0 \\<Longrightarrow> \\<exists>a. A = {a}", "by (metis card_eq_SucD)"], ["", "lemma card_1_singleton_conv: \"(card A = Suc 0) = (\\<exists>a. A = {a})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (card A = Suc 0) = (\\<exists>a. A = {a})", "apply (rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. card A = Suc 0 \\<Longrightarrow> \\<exists>a. A = {a}\n 2. \\<exists>a. A = {a} \\<Longrightarrow> card A = Suc 0", "apply (simp add: card_1_imp_singleton)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>a. A = {a} \\<Longrightarrow> card A = Suc 0", "apply fastforce"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma card_gr0_imp_finite: \"0 < card A \\<Longrightarrow> finite A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < card A \\<Longrightarrow> finite A", "by (rule ccontr, simp)"], ["", "lemma card_gr0_imp_not_empty: \"(0 < card A) \\<Longrightarrow> A \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < card A \\<Longrightarrow> A \\<noteq> {}", "by (rule ccontr, simp)"], ["", "lemma not_empty_card_gr0_conv: \"finite A \\<Longrightarrow> (A \\<noteq> {}) = (0 < card A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite A \\<Longrightarrow> (A \\<noteq> {}) = (0 < card A)", "by fastforce"], ["", "lemma nat_card_le_Max: \"card (A::nat set) \\<le> Suc (Max A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card A \\<le> Suc (Max A)", "apply (case_tac \"finite A\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. finite A \\<Longrightarrow> card A \\<le> Suc (Max A)\n 2. infinite A \\<Longrightarrow> card A \\<le> Suc (Max A)", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. infinite A \\<Longrightarrow> card A \\<le> Suc (Max A)\n 2. finite A \\<Longrightarrow> card A \\<le> Suc (Max A)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite A \\<Longrightarrow> card A \\<le> Suc (Max A)", "apply (cut_tac card_mono[OF finite_atMost, of A \"Max A\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>finite A; card A \\<le> card {..Max A}\\<rbrakk>\n    \\<Longrightarrow> card A \\<le> Suc (Max A)\n 2. finite A \\<Longrightarrow> A \\<subseteq> {..Max A}", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite A \\<Longrightarrow> A \\<subseteq> {..Max A}", "apply fastforce"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma Int_card1: \"finite A \\<Longrightarrow> card (A \\<inter> B) \\<le> card A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite A \\<Longrightarrow> card (A \\<inter> B) \\<le> card A", "by (rule card_mono, simp_all)"], ["", "lemma Int_card2: \"finite B \\<Longrightarrow> card (A \\<inter> B) \\<le> card B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite B \\<Longrightarrow> card (A \\<inter> B) \\<le> card B", "by (simp only: Int_commute[of A], rule Int_card1)"], ["", "lemma Un_card1: \"\\<lbrakk> finite A; finite B \\<rbrakk> \\<Longrightarrow> card A \\<le> card (A \\<union> B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite A; finite B\\<rbrakk>\n    \\<Longrightarrow> card A \\<le> card (A \\<union> B)", "by (rule card_mono, simp_all)"], ["", "lemma Un_card2: \"\\<lbrakk> finite A; finite B \\<rbrakk> \\<Longrightarrow> card B \\<le> card (A \\<union> B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite A; finite B\\<rbrakk>\n    \\<Longrightarrow> card B \\<le> card (A \\<union> B)", "by (simp only: Un_commute[of A], rule Un_card1)"], ["", "lemma card_Un_conv: \"\n  \\<lbrakk> finite A; finite B \\<rbrakk> \\<Longrightarrow>\n  card (A \\<union> B) = card A + card B - card (A \\<inter> B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite A; finite B\\<rbrakk>\n    \\<Longrightarrow> card (A \\<union> B) =\n                      card A + card B - card (A \\<inter> B)", "by (simp only: card_Un_Int diff_add_inverse2)"], ["", "lemma card_Int_conv: \"\n  \\<lbrakk> finite A; finite B \\<rbrakk> \\<Longrightarrow>\n  card (A \\<inter> B) = card A + card B - card (A \\<union> B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite A; finite B\\<rbrakk>\n    \\<Longrightarrow> card (A \\<inter> B) =\n                      card A + card B - card (A \\<union> B)", "by (simp only: card_Un_Int diff_add_inverse)"], ["", "text \\<open>Pigeonhole principle, dirichlet's box principle\\<close>"], ["", "lemma pigeonhole_principle[rule_format]: \"\n  card (f ` A) < card A \\<longrightarrow> (\\<exists>x\\<in>A. \\<exists>y\\<in>A. x \\<noteq> y \\<and> f x = f y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (f ` A) < card A \\<longrightarrow>\n    (\\<exists>x\\<in>A. \\<exists>y\\<in>A. x \\<noteq> y \\<and> f x = f y)", "apply (case_tac \"finite A\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. finite A \\<Longrightarrow>\n    card (f ` A) < card A \\<longrightarrow>\n    (\\<exists>x\\<in>A. \\<exists>y\\<in>A. x \\<noteq> y \\<and> f x = f y)\n 2. infinite A \\<Longrightarrow>\n    card (f ` A) < card A \\<longrightarrow>\n    (\\<exists>x\\<in>A. \\<exists>y\\<in>A. x \\<noteq> y \\<and> f x = f y)", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. infinite A \\<Longrightarrow>\n    card (f ` A) < card A \\<longrightarrow>\n    (\\<exists>x\\<in>A. \\<exists>y\\<in>A. x \\<noteq> y \\<and> f x = f y)\n 2. finite A \\<Longrightarrow>\n    card (f ` A) < card A \\<longrightarrow>\n    (\\<exists>x\\<in>A. \\<exists>y\\<in>A. x \\<noteq> y \\<and> f x = f y)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite A \\<Longrightarrow>\n    card (f ` A) < card A \\<longrightarrow>\n    (\\<exists>x\\<in>A. \\<exists>y\\<in>A. x \\<noteq> y \\<and> f x = f y)", "apply (rule finite.induct[of A])"], ["proof (prove)\ngoal (3 subgoals):\n 1. finite A \\<Longrightarrow> finite A\n 2. finite A \\<Longrightarrow>\n    card (f ` {}) < card {} \\<longrightarrow>\n    (\\<exists>x\\<in>{}. \\<exists>y\\<in>{}. x \\<noteq> y \\<and> f x = f y)\n 3. \\<And>Aa a.\n       \\<lbrakk>finite A; finite Aa;\n        card (f ` Aa) < card Aa \\<longrightarrow>\n        (\\<exists>x\\<in>Aa.\n            \\<exists>y\\<in>Aa. x \\<noteq> y \\<and> f x = f y)\\<rbrakk>\n       \\<Longrightarrow> card (f ` insert a Aa)\n                         < card (insert a Aa) \\<longrightarrow>\n                         (\\<exists>x\\<in>insert a Aa.\n                             \\<exists>y\\<in>insert a Aa.\n                                x \\<noteq> y \\<and> f x = f y)", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Aa a.\n       \\<lbrakk>finite A; finite Aa;\n        card (f ` Aa) < card Aa \\<longrightarrow>\n        (\\<exists>x\\<in>Aa.\n            \\<exists>y\\<in>Aa. x \\<noteq> y \\<and> f x = f y)\\<rbrakk>\n       \\<Longrightarrow> card (insert (f a) (f ` Aa))\n                         < card (insert a Aa) \\<longrightarrow>\n                         (\\<exists>y\\<in>Aa.\n                             a \\<noteq> y \\<and> f a = f y) \\<or>\n                         (\\<exists>x\\<in>Aa.\n                             x \\<noteq> a \\<and> f x = f a \\<or>\n                             (\\<exists>y\\<in>Aa.\n                                 x \\<noteq> y \\<and> f x = f y))", "apply (clarsimp, rename_tac A1 a)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>A1 a.\n       \\<lbrakk>finite A; finite A1;\n        card (f ` A1) < card A1 \\<longrightarrow>\n        (\\<exists>x\\<in>A1.\n            \\<exists>y\\<in>A1. x \\<noteq> y \\<and> f x = f y);\n        card (insert (f a) (f ` A1)) < card (insert a A1);\n        \\<forall>x\\<in>A1.\n           (x = a \\<or> f x \\<noteq> f a) \\<and>\n           (\\<forall>y\\<in>A1. x = y \\<or> f x \\<noteq> f y)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y\\<in>A1. a \\<noteq> y \\<and> f a = f y", "apply (case_tac \"a \\<in> A1\", force simp: insert_absorb)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>A1 a.\n       \\<lbrakk>finite A; finite A1;\n        card (f ` A1) < card A1 \\<longrightarrow>\n        (\\<exists>x\\<in>A1.\n            \\<exists>y\\<in>A1. x \\<noteq> y \\<and> f x = f y);\n        card (insert (f a) (f ` A1)) < card (insert a A1);\n        \\<forall>x\\<in>A1.\n           (x = a \\<or> f x \\<noteq> f a) \\<and>\n           (\\<forall>y\\<in>A1. x = y \\<or> f x \\<noteq> f y);\n        a \\<notin> A1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y\\<in>A1. a \\<noteq> y \\<and> f a = f y", "apply (case_tac \"f a \\<in> f ` A1\", fastforce+)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "corollary pigeonhole_principle_linorder[rule_format]: \"\n  card (f ` A) < card (A::'a::linorder set) \\<Longrightarrow> (\\<exists>x\\<in>A. \\<exists>y\\<in>A. x < y \\<and> f x = f y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (f ` A) < card A \\<Longrightarrow>\n    \\<exists>x\\<in>A. \\<exists>y\\<in>A. x < y \\<and> f x = f y", "apply (drule pigeonhole_principle, clarify)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> A; y \\<in> A; x \\<noteq> y; f x = f y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>A.\n                            \\<exists>y\\<in>A. x < y \\<and> f x = f y", "apply (drule neq_iff[THEN iffD1])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> A; y \\<in> A; f x = f y; x < y \\<or> y < x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>A.\n                            \\<exists>y\\<in>A. x < y \\<and> f x = f y", "apply fastforce"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "corollary pigeonhole_mod: \"\n  \\<lbrakk> 0 < m; m < card A \\<rbrakk> \\<Longrightarrow> \\<exists>x\\<in>A. \\<exists>y\\<in>A. x < y \\<and> x mod m = y mod m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < m; m < card A\\<rbrakk>\n    \\<Longrightarrow> \\<exists>x\\<in>A.\n                         \\<exists>y\\<in>A. x < y \\<and> x mod m = y mod m", "apply (rule pigeonhole_principle_linorder)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < m; m < card A\\<rbrakk>\n    \\<Longrightarrow> card ((\\<lambda>x. x mod m) ` A) < card A", "apply (rule le_less_trans[of _ \"card {..<m}\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < m; m < card A\\<rbrakk>\n    \\<Longrightarrow> card ((\\<lambda>x. x mod m) ` A) \\<le> card {..<m}\n 2. \\<lbrakk>0 < m; m < card A\\<rbrakk>\n    \\<Longrightarrow> card {..<m} < card A", "apply (rule card_mono)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>0 < m; m < card A\\<rbrakk> \\<Longrightarrow> finite {..<m}\n 2. \\<lbrakk>0 < m; m < card A\\<rbrakk>\n    \\<Longrightarrow> (\\<lambda>x. x mod m) ` A \\<subseteq> {..<m}\n 3. \\<lbrakk>0 < m; m < card A\\<rbrakk>\n    \\<Longrightarrow> card {..<m} < card A", "apply fastforce+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "corollary pigeonhole_mod2: \"\n  \\<lbrakk> (0::nat) < m; m \\<le> c; inj_on f {..c} \\<rbrakk> \\<Longrightarrow> \\<exists>x\\<le>c. \\<exists>y\\<le>c. x < y \\<and> f x mod m = f y mod m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < m; m \\<le> c; inj_on f {..c}\\<rbrakk>\n    \\<Longrightarrow> \\<exists>x\\<le>c.\n                         \\<exists>y\\<le>c.\n                            x < y \\<and> f x mod m = f y mod m", "apply (insert pigeonhole_mod[of m \"f ` {..c}\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < m; m \\<le> c; inj_on f {..c};\n     \\<lbrakk>0 < m; m < card (f ` {..c})\\<rbrakk>\n     \\<Longrightarrow> \\<exists>x\\<in>f ` {..c}.\n                          \\<exists>y\\<in>f ` {..c}.\n                             x < y \\<and> x mod m = y mod m\\<rbrakk>\n    \\<Longrightarrow> \\<exists>x\\<le>c.\n                         \\<exists>y\\<le>c.\n                            x < y \\<and> f x mod m = f y mod m", "apply (clarsimp simp add: card_image, rename_tac x y)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>0 < m; m \\<le> c; inj_on f {..c}; x \\<le> c; y \\<le> c;\n        f x < f y; f x mod m = f y mod m\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<le>c.\n                            \\<exists>y\\<le>c.\n                               x < y \\<and> f x mod m = f y mod m", "apply (subgoal_tac \"x \\<noteq> y\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>0 < m; m \\<le> c; inj_on f {..c}; x \\<le> c; y \\<le> c;\n        f x < f y; f x mod m = f y mod m; x \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<le>c.\n                            \\<exists>y\\<le>c.\n                               x < y \\<and> f x mod m = f y mod m\n 2. \\<And>x y.\n       \\<lbrakk>0 < m; m \\<le> c; inj_on f {..c}; x \\<le> c; y \\<le> c;\n        f x < f y; f x mod m = f y mod m\\<rbrakk>\n       \\<Longrightarrow> x \\<noteq> y", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>0 < m; m \\<le> c; inj_on f {..c}; x \\<le> c; y \\<le> c;\n        f x < f y; f x mod m = f y mod m\\<rbrakk>\n       \\<Longrightarrow> x \\<noteq> y\n 2. \\<And>x y.\n       \\<lbrakk>0 < m; m \\<le> c; inj_on f {..c}; x \\<le> c; y \\<le> c;\n        f x < f y; f x mod m = f y mod m; x \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<le>c.\n                            \\<exists>y\\<le>c.\n                               x < y \\<and> f x mod m = f y mod m", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>0 < m; m \\<le> c; inj_on f {..c}; x \\<le> c; y \\<le> c;\n        f x < f y; f x mod m = f y mod m; x \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<le>c.\n                            \\<exists>y\\<le>c.\n                               x < y \\<and> f x mod m = f y mod m", "apply (drule neq_iff[THEN iffD1], safe)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>0 < m; m \\<le> c; inj_on f {..c}; x \\<le> c; y \\<le> c;\n        f x < f y; f x mod m = f y mod m; x < y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<le>c.\n                            \\<exists>y\\<le>c.\n                               x < y \\<and> f x mod m = f y mod m\n 2. \\<And>x y.\n       \\<lbrakk>0 < m; m \\<le> c; inj_on f {..c}; x \\<le> c; y \\<le> c;\n        f x < f y; f x mod m = f y mod m; y < x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<le>c.\n                            \\<exists>y\\<le>c.\n                               x < y \\<and> f x mod m = f y mod m", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>0 < m; m \\<le> c; inj_on f {..c}; x \\<le> c; y \\<le> c;\n        f x < f y; f x mod m = f y mod m; y < x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<le>c.\n                            \\<exists>y\\<le>c.\n                               x < y \\<and> f x mod m = f y mod m", "apply (blast intro: eq_commute[THEN iffD1])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"]]}