{"file_name": "/home/qj213/afp-2021-10-22/thys/MFMC_Countable/MFMC_Reduction.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/MFMC_Countable", "problem_names": ["lemma bipartite_web_of_sel [simp]: fixes \\<Gamma> (structure) shows\n  \"edge (bipartite_web_of \\<Gamma>) (Inl u) (Inr v) \\<longleftrightarrow> edge \\<Gamma> u v \\<or> u = v \\<and> u \\<in> \\<^bold>V \\<and> u \\<notin> A \\<Gamma> \\<and> v \\<notin> B \\<Gamma>\"\n  \"edge (bipartite_web_of \\<Gamma>) uv (Inl u) \\<longleftrightarrow> False\"\n  \"edge (bipartite_web_of \\<Gamma>) (Inr v) uv \\<longleftrightarrow> False\"\n  \"weight (bipartite_web_of \\<Gamma>) (Inl u) = (if u \\<in> B \\<Gamma> then 0 else weight \\<Gamma> u)\"\n  \"weight (bipartite_web_of \\<Gamma>) (Inr v) = (if v \\<in> A \\<Gamma> then 0 else weight \\<Gamma> v)\"\n  \"A (bipartite_web_of \\<Gamma>) = Inl ` (\\<^bold>V - B \\<Gamma>)\"\n  \"B (bipartite_web_of \\<Gamma>) = Inr ` (- A \\<Gamma>)\"", "lemma edge_bipartite_webI1: \"edge \\<Gamma> u v \\<Longrightarrow> edge (bipartite_web_of \\<Gamma>) (Inl u) (Inr v)\"", "lemma edge_bipartite_webI2:\n  \"\\<lbrakk> u \\<in> \\<^bold>V\\<^bsub>\\<Gamma>\\<^esub>; u \\<notin> A \\<Gamma>; u \\<notin> B \\<Gamma> \\<rbrakk> \\<Longrightarrow> edge (bipartite_web_of \\<Gamma>) (Inl u) (Inr u)\"", "lemma edge_bipartite_webE:\n  fixes \\<Gamma> (structure)\n  assumes \"edge (bipartite_web_of \\<Gamma>) uv uv'\"\n  obtains u v where \"uv = Inl u\" \"uv' = Inr v\" \"edge \\<Gamma> u v\"\n    | u where \"uv = Inl u\" \"uv' = Inr u\" \"u \\<in> \\<^bold>V\" \"u \\<notin> A \\<Gamma>\" \"u \\<notin> B \\<Gamma>\"", "lemma E_bipartite_web:\n  fixes \\<Gamma> (structure) shows\n  \"\\<^bold>E\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> = (\\<lambda>(x, y). (Inl x, Inr y)) ` \\<^bold>E \\<union> (\\<lambda>x. (Inl x, Inr x)) ` (\\<^bold>V - A \\<Gamma> - B \\<Gamma>)\"", "lemma vertex_bipartite_web [simp]:\n  \"vertex (bipartite_web_of \\<Gamma>) (Inl x) \\<longleftrightarrow> vertex \\<Gamma> x \\<and> x \\<notin> B \\<Gamma>\"\n  \"vertex (bipartite_web_of \\<Gamma>) (Inr x) \\<longleftrightarrow> vertex \\<Gamma> x \\<and> x \\<notin> A \\<Gamma>\"", "lemma separating_of_bipartite_aux:\n  assumes p: \"path \\<Gamma> x p y\" and y: \"y \\<in> B \\<Gamma>\"\n  and x: \"x \\<in> A \\<Gamma> \\<or> Inr x \\<in> S\"\n  shows \"(\\<exists>z\\<in>set p. z \\<in> separating_of_bipartite S) \\<or> x \\<in> separating_of_bipartite S\"", "lemma separating_of_bipartite:\n  \"separating \\<Gamma> (separating_of_bipartite S)\"", "lemma current_bipartite_web_finite:\n  assumes f: \"current (bipartite_web_of \\<Gamma>) f\" (is \"current ?\\<Gamma> _\")\n  shows \"f e \\<noteq> \\<top>\"", "lemma current_of_bipartite_simps [simp]: \"current_of_bipartite f (x, y) = f (Inl x, Inr y) * indicator \\<^bold>E (x, y)\"", "lemma d_OUT_current_of_bipartite:\n  assumes f: \"current (bipartite_web_of \\<Gamma>) f\"\n  shows \"d_OUT (current_of_bipartite f) x = d_OUT f (Inl x) - f (Inl x, Inr x)\"", "lemma d_IN_current_of_bipartite:\n  assumes f: \"current (bipartite_web_of \\<Gamma>) f\"\n  shows \"d_IN (current_of_bipartite f) x = d_IN f (Inr x) - f (Inl x, Inr x)\"", "lemma current_current_of_bipartite: \\<comment> \\<open>Lemma 6.3\\<close>\n  assumes f: \"current (bipartite_web_of \\<Gamma>) f\" (is \"current ?\\<Gamma> _\")\n  and w: \"wave (bipartite_web_of \\<Gamma>) f\"\n  shows \"current \\<Gamma> (current_of_bipartite f)\" (is \"current _ ?f\")", "lemma TER_current_of_bipartite: \\<comment> \\<open>Lemma 6.3\\<close>\n  assumes f: \"current (bipartite_web_of \\<Gamma>) f\" (is \"current ?\\<Gamma> _\")\n  and w: \"wave (bipartite_web_of \\<Gamma>) f\"\n  shows \"TER (current_of_bipartite f) = separating_of_bipartite (TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f)\"\n    (is \"TER ?f = separating_of_bipartite ?TER\")", "lemma wave_current_of_bipartite: \\<comment> \\<open>Lemma 6.3\\<close>\n  assumes f: \"current (bipartite_web_of \\<Gamma>) f\" (is \"current ?\\<Gamma> _\")\n  and w: \"wave (bipartite_web_of \\<Gamma>) f\"\n  shows \"wave \\<Gamma> (current_of_bipartite f)\" (is \"wave _ ?f\")", "lemma countable_bipartite_web_of: \"countable_bipartite_web (bipartite_web_of \\<Gamma>)\" (is \"countable_bipartite_web ?\\<Gamma>\")", "lemma unhindered_bipartite_web_of:\n  assumes loose: \"loose \\<Gamma>\"\n  shows \"\\<not> hindered (bipartite_web_of \\<Gamma>)\"", "lemma (in -) divide_less_1_iff_ennreal: \"a / b < (1::ennreal) \\<longleftrightarrow> (0 < b \\<and> a < b \\<or> b = 0 \\<and> a = 0 \\<or> b = top)\"", "lemma linkable_bipartite_web_ofD:\n  assumes link: \"linkable (bipartite_web_of \\<Gamma>)\" (is \"linkable ?\\<Gamma>\")\n  and countable: \"countable \\<^bold>E\"\n  shows \"linkable \\<Gamma>\"", "lemma linkage_quotient_webD:\n  fixes \\<Gamma> :: \"('v, 'more) web_scheme\" (structure) and h g\n  defines \"k \\<equiv> plus_current h g\"\n  assumes f: \"current \\<Gamma> f\"\n  and w: \"wave \\<Gamma> f\"\n  and wg: \"web_flow (quotient_web \\<Gamma> f) g\" (is \"web_flow ?\\<Gamma> _\")\n  and link: \"linkage (quotient_web \\<Gamma> f) g\"\n  and trim: \"trimming \\<Gamma> f h\"\n  shows \"web_flow \\<Gamma> k\"\n  and \"orthogonal_current \\<Gamma> k (\\<E> (TER f))\"", "lemma ex_orthogonal_current': \\<comment> \\<open>Lemma 4.15\\<close>\n  assumes loose_linkable: \"\\<And>f. \\<lbrakk> current \\<Gamma> f; wave \\<Gamma> f; loose (quotient_web \\<Gamma> f) \\<rbrakk> \\<Longrightarrow> linkable (quotient_web \\<Gamma> f)\"\n  shows \"\\<exists>f S. web_flow \\<Gamma> f \\<and> separating \\<Gamma> S \\<and> orthogonal_current \\<Gamma> f S\"", "lemma web_of_network_sel [simp]:\n  fixes \\<Delta> (structure) shows\n  \"edge (web_of_network \\<Delta>) e e' \\<longleftrightarrow> e \\<in> \\<^bold>E \\<and> e' \\<in> \\<^bold>E \\<and> snd e = fst e'\"\n  \"weight (web_of_network \\<Delta>) e = capacity \\<Delta> e\"\n  \"A (web_of_network \\<Delta>) = {(source \\<Delta>, x)|x. edge \\<Delta> (source \\<Delta>) x}\"\n  \"B (web_of_network \\<Delta>) = {(x, sink \\<Delta>)|x. edge \\<Delta> x (sink \\<Delta>)}\"", "lemma vertex_web_of_network [simp]:\n  \"vertex (web_of_network \\<Delta>) (x, y) \\<longleftrightarrow> edge \\<Delta> x y \\<and> (\\<exists>z. edge \\<Delta> y z \\<or> edge \\<Delta> z x)\"", "lemma flow_flow_of_current:\n  fixes \\<Delta> (structure) and \\<Gamma>\n  defines [simp]: \"\\<Gamma> \\<equiv> web_of_network \\<Delta>\"\n  assumes fw: \"web_flow \\<Gamma> f\"\n  shows \"flow \\<Delta> (flow_of_current \\<Delta> f)\" (is \"flow _ ?f\")", "lemma cut_RF_separating:\n  fixes \\<Delta> (structure)\n  assumes sep: \"separating_network \\<Delta> V\"\n  and sink: \"sink \\<Delta> \\<notin> V\"\n  shows \"cut \\<Delta> (RF\\<^sup>N V)\"", "lemma separating_network_cut_of_sep:\n  assumes sep: \"separating \\<Gamma> S\"\n  and source_sink: \"source \\<Delta> \\<noteq> sink \\<Delta>\"\n  shows \"separating_network \\<Delta> (fst ` \\<E> S)\"", "lemma separating_cut:\n  assumes sep: \"separating \\<Gamma> S\"\n  and neq: \"source \\<Delta> \\<noteq> sink \\<Delta>\"\n  and sink_out: \"\\<And>x. \\<not> edge \\<Delta> (sink \\<Delta>) x\"\n  shows \"cut \\<Delta> (cut_of_sep S)\"", "lemma f: \"current \\<Gamma> f\"", "lemma orthogonal_leave_RF:\n  assumes e: \"edge \\<Delta> x y\"\n  and x: \"x \\<in> (cut_of_sep S)\"\n  and y: \"y \\<notin> (cut_of_sep S)\"\n  shows \"(x, y) \\<in> S\"", "lemma orthogonal_flow_of_current:\n  assumes source_sink: \"source \\<Delta> \\<noteq> sink \\<Delta>\"\n  and sink_out: \"\\<And>x. \\<not> edge \\<Delta> (sink \\<Delta>) x\"\n  and no_direct_edge: \"\\<not> edge \\<Delta> (source \\<Delta>) (sink \\<Delta>)\" \\<comment> \\<open>Otherwise, @{const A} and @{const B} of the web would not be disjoint.\\<close>\n  shows \"orthogonal \\<Delta> (flow_of_current \\<Delta> f) (cut_of_sep S)\" (is \"orthogonal _ ?f ?S\")", "lemma cut_cut': \"cut \\<Delta>'' S \\<Longrightarrow> cut \\<Delta> (cut' S)\"", "lemma IN_Edge: \"\\<^bold>I\\<^bold>N\\<^bsub>\\<Delta>''\\<^esub> (Edge x y) = (if edge \\<Delta> x y then {Vertex x} else {})\"", "lemma OUT_Edge: \"\\<^bold>O\\<^bold>U\\<^bold>T\\<^bsub>\\<Delta>''\\<^esub> (Edge x y) = (if edge \\<Delta> x y then {Vertex y} else {})\"", "lemma d_IN_Edge:\n  assumes f: \"flow \\<Delta>'' f\"\n  shows \"d_IN f (Edge x y) = f (Vertex x, Edge x y)\"", "lemma d_OUT_Edge:\n  assumes f: \"flow \\<Delta>'' f\"\n  shows \"d_OUT f (Edge x y) = f (Edge x y, Vertex y)\"", "lemma orthogonal_cut':\n  assumes ortho: \"orthogonal \\<Delta>'' f S\"\n  and f: \"flow \\<Delta>'' f\"\n  shows \"orthogonal \\<Delta> (collect f) (cut' S)\"", "lemma countable_web_web_of_network: \n  assumes source_in: \"\\<And>x. \\<not> edge \\<Delta> x (source \\<Delta>)\"\n  and sink_out: \"\\<And>y. \\<not> edge \\<Delta> (sink \\<Delta>) y\"\n  and undead: \"\\<And>x y. edge \\<Delta> x y \\<Longrightarrow> (\\<exists>z. edge \\<Delta> y z) \\<or> (\\<exists>z. edge \\<Delta> z x)\"\n  and source_sink: \"\\<not> edge \\<Delta> (source \\<Delta>) (sink \\<Delta>)\"\n  and no_loop: \"\\<And>x. \\<not> edge \\<Delta> x x\"\n  shows \"countable_web (web_of_network \\<Delta>)\" (is \"countable_web ?\\<Gamma>\")", "lemma max_flow_min_cut':\n  assumes ex_orthogonal_current: \" \\<exists>f S. web_flow (web_of_network \\<Delta>) f \\<and> separating (web_of_network \\<Delta>) S \\<and> orthogonal_current (web_of_network \\<Delta>) f S\"\n  and source_in: \"\\<And>x. \\<not> edge \\<Delta> x (source \\<Delta>)\"\n  and sink_out: \"\\<And>y. \\<not> edge \\<Delta> (sink \\<Delta>) y\"\n  and undead: \"\\<And>x y. edge \\<Delta> x y \\<Longrightarrow> (\\<exists>z. edge \\<Delta> y z) \\<or> (\\<exists>z. edge \\<Delta> z x)\"\n  and source_sink: \"\\<not> edge \\<Delta> (source \\<Delta>) (sink \\<Delta>)\"\n  and no_loop: \"\\<And>x. \\<not> edge \\<Delta> x x\"\n  and capacity_pos: \"\\<And>e. e \\<in> \\<^bold>E \\<Longrightarrow> capacity \\<Delta> e > 0\"\n  shows \"\\<exists>f S. flow \\<Delta> f \\<and> cut \\<Delta> S \\<and> orthogonal \\<Delta> f S\"", "lemma \\<Delta>'''_sel [simp]:\n  \"edge \\<Delta>''' x y \\<longleftrightarrow> edge \\<Delta> x y \\<and> capacity \\<Delta> (x, y) > 0 \\<and> y \\<noteq> source \\<Delta> \\<and> x \\<noteq> sink \\<Delta>\"\n  \"capacity \\<Delta>''' (x, y) = (if x = sink \\<Delta> \\<or> y = source \\<Delta> then 0 else capacity \\<Delta> (x, y))\"\n  \"source \\<Delta>''' = source \\<Delta>\"\n  \"sink \\<Delta>''' = sink \\<Delta>\"\n  for x y", "lemma \\<Delta>'''_countable_network: \"countable_network \\<Delta>'''\"", "lemma flow_\\<Delta>''':\n  assumes f: \"flow \\<Delta>''' f\" and cut: \"cut \\<Delta>''' S\" and ortho: \"orthogonal \\<Delta>''' f S\"\n    shows \"flow \\<Delta> f\" \"cut \\<Delta> S\" \"orthogonal \\<Delta> f S\""], "translations": [["", "lemma bipartite_web_of_sel [simp]: fixes \\<Gamma> (structure) shows\n  \"edge (bipartite_web_of \\<Gamma>) (Inl u) (Inr v) \\<longleftrightarrow> edge \\<Gamma> u v \\<or> u = v \\<and> u \\<in> \\<^bold>V \\<and> u \\<notin> A \\<Gamma> \\<and> v \\<notin> B \\<Gamma>\"\n  \"edge (bipartite_web_of \\<Gamma>) uv (Inl u) \\<longleftrightarrow> False\"\n  \"edge (bipartite_web_of \\<Gamma>) (Inr v) uv \\<longleftrightarrow> False\"\n  \"weight (bipartite_web_of \\<Gamma>) (Inl u) = (if u \\<in> B \\<Gamma> then 0 else weight \\<Gamma> u)\"\n  \"weight (bipartite_web_of \\<Gamma>) (Inr v) = (if v \\<in> A \\<Gamma> then 0 else weight \\<Gamma> v)\"\n  \"A (bipartite_web_of \\<Gamma>) = Inl ` (\\<^bold>V - B \\<Gamma>)\"\n  \"B (bipartite_web_of \\<Gamma>) = Inr ` (- A \\<Gamma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (edge (bipartite_web_of \\<Gamma>) (Inl u) (Inr v) =\n     (edge \\<Gamma> u v \\<or>\n      u = v \\<and>\n      u \\<in> \\<^bold>V \\<and>\n      u \\<notin> A \\<Gamma> \\<and> v \\<notin> B \\<Gamma>) &&&\n     edge (bipartite_web_of \\<Gamma>) uv (Inl u) = False &&&\n     edge (bipartite_web_of \\<Gamma>) (Inr v) uv = False) &&&\n    (weight (bipartite_web_of \\<Gamma>) (Inl u) =\n     (if u \\<in> B \\<Gamma> then 0 else weight \\<Gamma> u) &&&\n     weight (bipartite_web_of \\<Gamma>) (Inr v) =\n     (if v \\<in> A \\<Gamma> then 0 else weight \\<Gamma> v)) &&&\n    A (bipartite_web_of \\<Gamma>) = Inl ` (\\<^bold>V - B \\<Gamma>) &&&\n    B (bipartite_web_of \\<Gamma>) = Inr ` (- A \\<Gamma>)", "by(simp_all add: bipartite_web_of_def split: sum.split)"], ["", "lemma edge_bipartite_webI1: \"edge \\<Gamma> u v \\<Longrightarrow> edge (bipartite_web_of \\<Gamma>) (Inl u) (Inr v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. edge \\<Gamma> u v \\<Longrightarrow>\n    edge (bipartite_web_of \\<Gamma>) (Inl u) (Inr v)", "by(auto)"], ["", "lemma edge_bipartite_webI2:\n  \"\\<lbrakk> u \\<in> \\<^bold>V\\<^bsub>\\<Gamma>\\<^esub>; u \\<notin> A \\<Gamma>; u \\<notin> B \\<Gamma> \\<rbrakk> \\<Longrightarrow> edge (bipartite_web_of \\<Gamma>) (Inl u) (Inr u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>u \\<in> \\<^bold>V\\<^bsub>\\<Gamma>\\<^esub>;\n     u \\<notin> A \\<Gamma>; u \\<notin> B \\<Gamma>\\<rbrakk>\n    \\<Longrightarrow> edge (bipartite_web_of \\<Gamma>) (Inl u) (Inr u)", "by(auto)"], ["", "lemma edge_bipartite_webE:\n  fixes \\<Gamma> (structure)\n  assumes \"edge (bipartite_web_of \\<Gamma>) uv uv'\"\n  obtains u v where \"uv = Inl u\" \"uv' = Inr v\" \"edge \\<Gamma> u v\"\n    | u where \"uv = Inl u\" \"uv' = Inr u\" \"u \\<in> \\<^bold>V\" \"u \\<notin> A \\<Gamma>\" \"u \\<notin> B \\<Gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>u v.\n                \\<lbrakk>uv = Inl u; uv' = Inr v; edge \\<Gamma> u v\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<And>u.\n        \\<lbrakk>uv = Inl u; uv' = Inr u; u \\<in> \\<^bold>V;\n         u \\<notin> A \\<Gamma>; u \\<notin> B \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "using assms"], ["proof (prove)\nusing this:\n  edge (bipartite_web_of \\<Gamma>) uv uv'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>u v.\n                \\<lbrakk>uv = Inl u; uv' = Inr v; edge \\<Gamma> u v\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<And>u.\n        \\<lbrakk>uv = Inl u; uv' = Inr u; u \\<in> \\<^bold>V;\n         u \\<notin> A \\<Gamma>; u \\<notin> B \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by(cases uv uv' rule: sum.exhaust[case_product sum.exhaust]) auto"], ["", "lemma E_bipartite_web:\n  fixes \\<Gamma> (structure) shows\n  \"\\<^bold>E\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> = (\\<lambda>(x, y). (Inl x, Inr y)) ` \\<^bold>E \\<union> (\\<lambda>x. (Inl x, Inr x)) ` (\\<^bold>V - A \\<Gamma> - B \\<Gamma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<^bold>E\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> =\n    (\\<lambda>(x, y). (Inl x, Inr y)) ` \\<^bold>E \\<union>\n    (\\<lambda>x. (Inl x, Inr x)) ` (\\<^bold>V - A \\<Gamma> - B \\<Gamma>)", "by(auto elim: edge_bipartite_webE)"], ["", "context web begin"], ["", "lemma vertex_bipartite_web [simp]:\n  \"vertex (bipartite_web_of \\<Gamma>) (Inl x) \\<longleftrightarrow> vertex \\<Gamma> x \\<and> x \\<notin> B \\<Gamma>\"\n  \"vertex (bipartite_web_of \\<Gamma>) (Inr x) \\<longleftrightarrow> vertex \\<Gamma> x \\<and> x \\<notin> A \\<Gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vertex (bipartite_web_of \\<Gamma>) (Inl x) =\n    (vertex \\<Gamma> x \\<and> x \\<notin> B \\<Gamma>) &&&\n    vertex (bipartite_web_of \\<Gamma>) (Inr x) =\n    (vertex \\<Gamma> x \\<and> x \\<notin> A \\<Gamma>)", "by(auto 4 4 simp add: vertex_def dest: B_out A_in intro: edge_bipartite_webI1 edge_bipartite_webI2 elim!: edge_bipartite_webE)"], ["", "definition separating_of_bipartite :: \"('v + 'v) set \\<Rightarrow> 'v set\"\nwhere\n  \"separating_of_bipartite S =\n  (let A_S = Inl -` S; B_S = Inr -` S in (A_S \\<inter> B_S) \\<union> (A \\<Gamma> \\<inter> A_S) \\<union> (B \\<Gamma> \\<inter> B_S))\""], ["", "context\n  fixes S :: \"('v + 'v) set\"\n  assumes sep: \"separating (bipartite_web_of \\<Gamma>) S\"\nbegin"], ["", "text \\<open>Proof of separation follows @{cite Aharoni1983EJC}\\<close>"], ["", "lemma separating_of_bipartite_aux:\n  assumes p: \"path \\<Gamma> x p y\" and y: \"y \\<in> B \\<Gamma>\"\n  and x: \"x \\<in> A \\<Gamma> \\<or> Inr x \\<in> S\"\n  shows \"(\\<exists>z\\<in>set p. z \\<in> separating_of_bipartite S) \\<or> x \\<in> separating_of_bipartite S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>z\\<in>set p. z \\<in> separating_of_bipartite S) \\<or>\n    x \\<in> separating_of_bipartite S", "proof(cases \"p = []\")"], ["proof (state)\ngoal (2 subgoals):\n 1. p = [] \\<Longrightarrow>\n    (\\<exists>z\\<in>set p. z \\<in> separating_of_bipartite S) \\<or>\n    x \\<in> separating_of_bipartite S\n 2. p \\<noteq> [] \\<Longrightarrow>\n    (\\<exists>z\\<in>set p. z \\<in> separating_of_bipartite S) \\<or>\n    x \\<in> separating_of_bipartite S", "case True"], ["proof (state)\nthis:\n  p = []\n\ngoal (2 subgoals):\n 1. p = [] \\<Longrightarrow>\n    (\\<exists>z\\<in>set p. z \\<in> separating_of_bipartite S) \\<or>\n    x \\<in> separating_of_bipartite S\n 2. p \\<noteq> [] \\<Longrightarrow>\n    (\\<exists>z\\<in>set p. z \\<in> separating_of_bipartite S) \\<or>\n    x \\<in> separating_of_bipartite S", "with p"], ["proof (chain)\npicking this:\n  path \\<Gamma> x p y\n  p = []", "have \"x = y\""], ["proof (prove)\nusing this:\n  path \\<Gamma> x p y\n  p = []\n\ngoal (1 subgoal):\n 1. x = y", "by cases auto"], ["proof (state)\nthis:\n  x = y\n\ngoal (2 subgoals):\n 1. p = [] \\<Longrightarrow>\n    (\\<exists>z\\<in>set p. z \\<in> separating_of_bipartite S) \\<or>\n    x \\<in> separating_of_bipartite S\n 2. p \\<noteq> [] \\<Longrightarrow>\n    (\\<exists>z\\<in>set p. z \\<in> separating_of_bipartite S) \\<or>\n    x \\<in> separating_of_bipartite S", "with y x"], ["proof (chain)\npicking this:\n  y \\<in> B \\<Gamma>\n  x \\<in> A \\<Gamma> \\<or> Inr x \\<in> S\n  x = y", "have \"x \\<in> separating_of_bipartite S\""], ["proof (prove)\nusing this:\n  y \\<in> B \\<Gamma>\n  x \\<in> A \\<Gamma> \\<or> Inr x \\<in> S\n  x = y\n\ngoal (1 subgoal):\n 1. x \\<in> separating_of_bipartite S", "using disjoint"], ["proof (prove)\nusing this:\n  y \\<in> B \\<Gamma>\n  x \\<in> A \\<Gamma> \\<or> Inr x \\<in> S\n  x = y\n  A \\<Gamma> \\<inter> B \\<Gamma> = {}\n\ngoal (1 subgoal):\n 1. x \\<in> separating_of_bipartite S", "by(auto simp add: separating_of_bipartite_def Let_def)"], ["proof (state)\nthis:\n  x \\<in> separating_of_bipartite S\n\ngoal (2 subgoals):\n 1. p = [] \\<Longrightarrow>\n    (\\<exists>z\\<in>set p. z \\<in> separating_of_bipartite S) \\<or>\n    x \\<in> separating_of_bipartite S\n 2. p \\<noteq> [] \\<Longrightarrow>\n    (\\<exists>z\\<in>set p. z \\<in> separating_of_bipartite S) \\<or>\n    x \\<in> separating_of_bipartite S", "thus ?thesis"], ["proof (prove)\nusing this:\n  x \\<in> separating_of_bipartite S\n\ngoal (1 subgoal):\n 1. (\\<exists>z\\<in>set p. z \\<in> separating_of_bipartite S) \\<or>\n    x \\<in> separating_of_bipartite S", ".."], ["proof (state)\nthis:\n  (\\<exists>z\\<in>set p. z \\<in> separating_of_bipartite S) \\<or>\n  x \\<in> separating_of_bipartite S\n\ngoal (1 subgoal):\n 1. p \\<noteq> [] \\<Longrightarrow>\n    (\\<exists>z\\<in>set p. z \\<in> separating_of_bipartite S) \\<or>\n    x \\<in> separating_of_bipartite S", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. p \\<noteq> [] \\<Longrightarrow>\n    (\\<exists>z\\<in>set p. z \\<in> separating_of_bipartite S) \\<or>\n    x \\<in> separating_of_bipartite S", "case nNil: False"], ["proof (state)\nthis:\n  p \\<noteq> []\n\ngoal (1 subgoal):\n 1. p \\<noteq> [] \\<Longrightarrow>\n    (\\<exists>z\\<in>set p. z \\<in> separating_of_bipartite S) \\<or>\n    x \\<in> separating_of_bipartite S", "define inmarked where \"inmarked x \\<longleftrightarrow> x \\<in> A \\<Gamma> \\<or> Inr x \\<in> S\" for x"], ["proof (state)\nthis:\n  inmarked ?x = (?x \\<in> A \\<Gamma> \\<or> Inr ?x \\<in> S)\n\ngoal (1 subgoal):\n 1. p \\<noteq> [] \\<Longrightarrow>\n    (\\<exists>z\\<in>set p. z \\<in> separating_of_bipartite S) \\<or>\n    x \\<in> separating_of_bipartite S", "define outmarked where \"outmarked x \\<longleftrightarrow> x \\<in> B \\<Gamma> \\<or> Inl x \\<in> S\" for x"], ["proof (state)\nthis:\n  outmarked ?x = (?x \\<in> B \\<Gamma> \\<or> Inl ?x \\<in> S)\n\ngoal (1 subgoal):\n 1. p \\<noteq> [] \\<Longrightarrow>\n    (\\<exists>z\\<in>set p. z \\<in> separating_of_bipartite S) \\<or>\n    x \\<in> separating_of_bipartite S", "let ?\\<Gamma> = \"bipartite_web_of \\<Gamma>\""], ["proof (state)\ngoal (1 subgoal):\n 1. p \\<noteq> [] \\<Longrightarrow>\n    (\\<exists>z\\<in>set p. z \\<in> separating_of_bipartite S) \\<or>\n    x \\<in> separating_of_bipartite S", "let ?double = \"\\<lambda>x. inmarked x \\<and> outmarked x\""], ["proof (state)\ngoal (1 subgoal):\n 1. p \\<noteq> [] \\<Longrightarrow>\n    (\\<exists>z\\<in>set p. z \\<in> separating_of_bipartite S) \\<or>\n    x \\<in> separating_of_bipartite S", "define tailmarked where \"tailmarked = (\\<lambda>(x, y :: 'v). outmarked x)\""], ["proof (state)\nthis:\n  tailmarked = (\\<lambda>(x, y). outmarked x)\n\ngoal (1 subgoal):\n 1. p \\<noteq> [] \\<Longrightarrow>\n    (\\<exists>z\\<in>set p. z \\<in> separating_of_bipartite S) \\<or>\n    x \\<in> separating_of_bipartite S", "define headmarked where \"headmarked = (\\<lambda>(x :: 'v, y). inmarked y)\""], ["proof (state)\nthis:\n  headmarked = (\\<lambda>(x, y). inmarked y)\n\ngoal (1 subgoal):\n 1. p \\<noteq> [] \\<Longrightarrow>\n    (\\<exists>z\\<in>set p. z \\<in> separating_of_bipartite S) \\<or>\n    x \\<in> separating_of_bipartite S", "have marked_E: \"tailmarked e \\<or> headmarked e\" if \"e \\<in> \\<^bold>E\" for e \\<comment> \\<open>Lemma 1b\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. tailmarked e \\<or> headmarked e", "proof(cases e)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b. e = (a, b) \\<Longrightarrow> tailmarked e \\<or> headmarked e", "case (Pair x y)"], ["proof (state)\nthis:\n  e = (x, y)\n\ngoal (1 subgoal):\n 1. \\<And>a b. e = (a, b) \\<Longrightarrow> tailmarked e \\<or> headmarked e", "with that"], ["proof (chain)\npicking this:\n  e \\<in> \\<^bold>E\n  e = (x, y)", "have \"path ?\\<Gamma> (Inl x) [Inr y] (Inr y)\""], ["proof (prove)\nusing this:\n  e \\<in> \\<^bold>E\n  e = (x, y)\n\ngoal (1 subgoal):\n 1. path (bipartite_web_of \\<Gamma>) (Inl x) [Inr y] (Inr y)", "by(auto intro!: rtrancl_path.intros)"], ["proof (state)\nthis:\n  path (bipartite_web_of \\<Gamma>) (Inl x) [Inr y] (Inr y)\n\ngoal (1 subgoal):\n 1. \\<And>a b. e = (a, b) \\<Longrightarrow> tailmarked e \\<or> headmarked e", "from separatingD[OF sep this] that Pair"], ["proof (chain)\npicking this:\n  \\<lbrakk>Inl x \\<in> A (bipartite_web_of \\<Gamma>);\n   Inr y \\<in> B (bipartite_web_of \\<Gamma>)\\<rbrakk>\n  \\<Longrightarrow> (\\<exists>z\\<in>set [Inr y]. z \\<in> S) \\<or>\n                    Inl x \\<in> S\n  e \\<in> \\<^bold>E\n  e = (x, y)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>Inl x \\<in> A (bipartite_web_of \\<Gamma>);\n   Inr y \\<in> B (bipartite_web_of \\<Gamma>)\\<rbrakk>\n  \\<Longrightarrow> (\\<exists>z\\<in>set [Inr y]. z \\<in> S) \\<or>\n                    Inl x \\<in> S\n  e \\<in> \\<^bold>E\n  e = (x, y)\n\ngoal (1 subgoal):\n 1. tailmarked e \\<or> headmarked e", "by(fastforce simp add: vertex_def inmarked_def outmarked_def tailmarked_def headmarked_def)"], ["proof (state)\nthis:\n  tailmarked e \\<or> headmarked e\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?e \\<in> \\<^bold>E \\<Longrightarrow> tailmarked ?e \\<or> headmarked ?e\n\ngoal (1 subgoal):\n 1. p \\<noteq> [] \\<Longrightarrow>\n    (\\<exists>z\\<in>set p. z \\<in> separating_of_bipartite S) \\<or>\n    x \\<in> separating_of_bipartite S", "have \"\\<exists>z\\<in>set (x # p). ?double z\" \\<comment> \\<open>Lemma 2\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>z\\<in>set (x # p). inmarked z \\<and> outmarked z", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>z\\<in>set (x # p). inmarked z \\<and> outmarked z", "have \"inmarked ((x # p) ! (i + 1)) \\<or> outmarked ((x # p) ! i)\" if \"i < length p\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. inmarked ((x # p) ! (i + 1)) \\<or> outmarked ((x # p) ! i)", "using rtrancl_path_nth[OF p that] marked_E[of \"((x # p) ! i, p ! i)\"] that"], ["proof (prove)\nusing this:\n  edge \\<Gamma> ((x # p) ! i) (p ! i)\n  ((x # p) ! i, p ! i) \\<in> \\<^bold>E \\<Longrightarrow>\n  tailmarked ((x # p) ! i, p ! i) \\<or> headmarked ((x # p) ! i, p ! i)\n  i < length p\n\ngoal (1 subgoal):\n 1. inmarked ((x # p) ! (i + 1)) \\<or> outmarked ((x # p) ! i)", "by(auto simp add: tailmarked_def headmarked_def nth_Cons split: nat.split)"], ["proof (state)\nthis:\n  ?i < length p \\<Longrightarrow>\n  inmarked ((x # p) ! (?i + 1)) \\<or> outmarked ((x # p) ! ?i)\n\ngoal (1 subgoal):\n 1. \\<exists>z\\<in>set (x # p). inmarked z \\<and> outmarked z", "hence \"{i. i < length p \\<and> inmarked (p ! i)} \\<union> {i. i < length (x # butlast p) \\<and> outmarked ((x # butlast p) ! i)} = {i. i < length p}\"\n      (is \"?in \\<union> ?out = _\")"], ["proof (prove)\nusing this:\n  ?i < length p \\<Longrightarrow>\n  inmarked ((x # p) ! (?i + 1)) \\<or> outmarked ((x # p) ! ?i)\n\ngoal (1 subgoal):\n 1. {i. i < length p \\<and> inmarked (p ! i)} \\<union>\n    {i. i < length (x # butlast p) \\<and> outmarked ((x # butlast p) ! i)} =\n    {i. i < length p}", "using nNil"], ["proof (prove)\nusing this:\n  ?i < length p \\<Longrightarrow>\n  inmarked ((x # p) ! (?i + 1)) \\<or> outmarked ((x # p) ! ?i)\n  p \\<noteq> []\n\ngoal (1 subgoal):\n 1. {i. i < length p \\<and> inmarked (p ! i)} \\<union>\n    {i. i < length (x # butlast p) \\<and> outmarked ((x # butlast p) ! i)} =\n    {i. i < length p}", "by(force simp add: nth_Cons' nth_butlast elim: meta_allE[where x=0] cong del: old.nat.case_cong_weak)"], ["proof (state)\nthis:\n  {i. i < length p \\<and> inmarked (p ! i)} \\<union>\n  {i. i < length (x # butlast p) \\<and> outmarked ((x # butlast p) ! i)} =\n  {i. i < length p}\n\ngoal (1 subgoal):\n 1. \\<exists>z\\<in>set (x # p). inmarked z \\<and> outmarked z", "hence \"length p + 2 = card (?in \\<union> ?out) + 2\""], ["proof (prove)\nusing this:\n  {i. i < length p \\<and> inmarked (p ! i)} \\<union>\n  {i. i < length (x # butlast p) \\<and> outmarked ((x # butlast p) ! i)} =\n  {i. i < length p}\n\ngoal (1 subgoal):\n 1. length p + 2 =\n    card\n     ({i. i < length p \\<and> inmarked (p ! i)} \\<union>\n      {i. i < length (x # butlast p) \\<and>\n          outmarked ((x # butlast p) ! i)}) +\n    2", "by simp"], ["proof (state)\nthis:\n  length p + 2 =\n  card\n   ({i. i < length p \\<and> inmarked (p ! i)} \\<union>\n    {i. i < length (x # butlast p) \\<and>\n        outmarked ((x # butlast p) ! i)}) +\n  2\n\ngoal (1 subgoal):\n 1. \\<exists>z\\<in>set (x # p). inmarked z \\<and> outmarked z", "also"], ["proof (state)\nthis:\n  length p + 2 =\n  card\n   ({i. i < length p \\<and> inmarked (p ! i)} \\<union>\n    {i. i < length (x # butlast p) \\<and>\n        outmarked ((x # butlast p) ! i)}) +\n  2\n\ngoal (1 subgoal):\n 1. \\<exists>z\\<in>set (x # p). inmarked z \\<and> outmarked z", "have \"\\<dots> \\<le> (card ?in + 1) + (card ?out + 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card\n     ({i. i < length p \\<and> inmarked (p ! i)} \\<union>\n      {i. i < length (x # butlast p) \\<and>\n          outmarked ((x # butlast p) ! i)}) +\n    2\n    \\<le> card {i. i < length p \\<and> inmarked (p ! i)} + 1 +\n          (card\n            {i. i < length (x # butlast p) \\<and>\n                outmarked ((x # butlast p) ! i)} +\n           1)", "by(simp add: card_Un_le)"], ["proof (state)\nthis:\n  card\n   ({i. i < length p \\<and> inmarked (p ! i)} \\<union>\n    {i. i < length (x # butlast p) \\<and>\n        outmarked ((x # butlast p) ! i)}) +\n  2\n  \\<le> card {i. i < length p \\<and> inmarked (p ! i)} + 1 +\n        (card\n          {i. i < length (x # butlast p) \\<and>\n              outmarked ((x # butlast p) ! i)} +\n         1)\n\ngoal (1 subgoal):\n 1. \\<exists>z\\<in>set (x # p). inmarked z \\<and> outmarked z", "also"], ["proof (state)\nthis:\n  card\n   ({i. i < length p \\<and> inmarked (p ! i)} \\<union>\n    {i. i < length (x # butlast p) \\<and>\n        outmarked ((x # butlast p) ! i)}) +\n  2\n  \\<le> card {i. i < length p \\<and> inmarked (p ! i)} + 1 +\n        (card\n          {i. i < length (x # butlast p) \\<and>\n              outmarked ((x # butlast p) ! i)} +\n         1)\n\ngoal (1 subgoal):\n 1. \\<exists>z\\<in>set (x # p). inmarked z \\<and> outmarked z", "have \"card ?in = card ((\\<lambda>i. Inl (i + 1) :: _ + nat) ` ?in)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card {i. i < length p \\<and> inmarked (p ! i)} =\n    card\n     ((\\<lambda>i. Inl (i + 1)) ` {i. i < length p \\<and> inmarked (p ! i)})", "by(rule card_image[symmetric])(simp add: inj_on_def)"], ["proof (state)\nthis:\n  card {i. i < length p \\<and> inmarked (p ! i)} =\n  card\n   ((\\<lambda>i. Inl (i + 1)) ` {i. i < length p \\<and> inmarked (p ! i)})\n\ngoal (1 subgoal):\n 1. \\<exists>z\\<in>set (x # p). inmarked z \\<and> outmarked z", "also"], ["proof (state)\nthis:\n  card {i. i < length p \\<and> inmarked (p ! i)} =\n  card\n   ((\\<lambda>i. Inl (i + 1)) ` {i. i < length p \\<and> inmarked (p ! i)})\n\ngoal (1 subgoal):\n 1. \\<exists>z\\<in>set (x # p). inmarked z \\<and> outmarked z", "have \"\\<dots> + 1 = card (insert (Inl 0) {Inl (Suc i) :: _ + nat|i. i < length p \\<and> inmarked (p ! i)})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card\n     ((\\<lambda>i. Inl (i + 1)) `\n      {i. i < length p \\<and> inmarked (p ! i)}) +\n    1 =\n    card\n     (insert (Inl 0) {Inl (Suc i) |i. i < length p \\<and> inmarked (p ! i)})", "by(subst card_insert_if)(auto intro!: arg_cong[where f=card])"], ["proof (state)\nthis:\n  card\n   ((\\<lambda>i. Inl (i + 1)) ` {i. i < length p \\<and> inmarked (p ! i)}) +\n  1 =\n  card\n   (insert (Inl 0) {Inl (Suc i) |i. i < length p \\<and> inmarked (p ! i)})\n\ngoal (1 subgoal):\n 1. \\<exists>z\\<in>set (x # p). inmarked z \\<and> outmarked z", "also"], ["proof (state)\nthis:\n  card\n   ((\\<lambda>i. Inl (i + 1)) ` {i. i < length p \\<and> inmarked (p ! i)}) +\n  1 =\n  card\n   (insert (Inl 0) {Inl (Suc i) |i. i < length p \\<and> inmarked (p ! i)})\n\ngoal (1 subgoal):\n 1. \\<exists>z\\<in>set (x # p). inmarked z \\<and> outmarked z", "have \"\\<dots> = card {Inl i :: nat + nat|i. i < length (x # p) \\<and> inmarked ((x # p) ! i)}\" (is \"_ = card ?in\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. card\n     (insert (Inl 0)\n       {Inl (Suc i) |i. i < length p \\<and> inmarked (p ! i)}) =\n    card {Inl i |i. i < length (x # p) \\<and> inmarked ((x # p) ! i)}", "using x"], ["proof (prove)\nusing this:\n  x \\<in> A \\<Gamma> \\<or> Inr x \\<in> S\n\ngoal (1 subgoal):\n 1. card\n     (insert (Inl 0)\n       {Inl (Suc i) |i. i < length p \\<and> inmarked (p ! i)}) =\n    card {Inl i |i. i < length (x # p) \\<and> inmarked ((x # p) ! i)}", "by(intro arg_cong[where f=card])(auto simp add: nth_Cons inmarked_def split: nat.split_asm)"], ["proof (state)\nthis:\n  card\n   (insert (Inl 0) {Inl (Suc i) |i. i < length p \\<and> inmarked (p ! i)}) =\n  card {Inl i |i. i < length (x # p) \\<and> inmarked ((x # p) ! i)}\n\ngoal (1 subgoal):\n 1. \\<exists>z\\<in>set (x # p). inmarked z \\<and> outmarked z", "also"], ["proof (state)\nthis:\n  card\n   (insert (Inl 0) {Inl (Suc i) |i. i < length p \\<and> inmarked (p ! i)}) =\n  card {Inl i |i. i < length (x # p) \\<and> inmarked ((x # p) ! i)}\n\ngoal (1 subgoal):\n 1. \\<exists>z\\<in>set (x # p). inmarked z \\<and> outmarked z", "have \"card ?out = card ((Inr :: _ \\<Rightarrow> nat + _) ` ?out)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card\n     {i. i < length (x # butlast p) \\<and>\n         outmarked ((x # butlast p) ! i)} =\n    card\n     (Inr `\n      {i. i < length (x # butlast p) \\<and>\n          outmarked ((x # butlast p) ! i)})", "by(simp add: card_image)"], ["proof (state)\nthis:\n  card\n   {i. i < length (x # butlast p) \\<and> outmarked ((x # butlast p) ! i)} =\n  card\n   (Inr `\n    {i. i < length (x # butlast p) \\<and> outmarked ((x # butlast p) ! i)})\n\ngoal (1 subgoal):\n 1. \\<exists>z\\<in>set (x # p). inmarked z \\<and> outmarked z", "also"], ["proof (state)\nthis:\n  card\n   {i. i < length (x # butlast p) \\<and> outmarked ((x # butlast p) ! i)} =\n  card\n   (Inr `\n    {i. i < length (x # butlast p) \\<and> outmarked ((x # butlast p) ! i)})\n\ngoal (1 subgoal):\n 1. \\<exists>z\\<in>set (x # p). inmarked z \\<and> outmarked z", "have \"\\<dots> + 1 = card (insert (Inr (length p)) {Inr i :: nat + _|i. i < length p \\<and> outmarked ((x # p) ! i)})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card\n     (Inr `\n      {i. i < length (x # butlast p) \\<and>\n          outmarked ((x # butlast p) ! i)}) +\n    1 =\n    card\n     (insert (Inr (length p))\n       {Inr i |i. i < length p \\<and> outmarked ((x # p) ! i)})", "using nNil"], ["proof (prove)\nusing this:\n  p \\<noteq> []\n\ngoal (1 subgoal):\n 1. card\n     (Inr `\n      {i. i < length (x # butlast p) \\<and>\n          outmarked ((x # butlast p) ! i)}) +\n    1 =\n    card\n     (insert (Inr (length p))\n       {Inr i |i. i < length p \\<and> outmarked ((x # p) ! i)})", "by(subst card_insert_if)(auto intro!: arg_cong[where f=card] simp add: nth_Cons nth_butlast cong: nat.case_cong)"], ["proof (state)\nthis:\n  card\n   (Inr `\n    {i. i < length (x # butlast p) \\<and>\n        outmarked ((x # butlast p) ! i)}) +\n  1 =\n  card\n   (insert (Inr (length p))\n     {Inr i |i. i < length p \\<and> outmarked ((x # p) ! i)})\n\ngoal (1 subgoal):\n 1. \\<exists>z\\<in>set (x # p). inmarked z \\<and> outmarked z", "also"], ["proof (state)\nthis:\n  card\n   (Inr `\n    {i. i < length (x # butlast p) \\<and>\n        outmarked ((x # butlast p) ! i)}) +\n  1 =\n  card\n   (insert (Inr (length p))\n     {Inr i |i. i < length p \\<and> outmarked ((x # p) ! i)})\n\ngoal (1 subgoal):\n 1. \\<exists>z\\<in>set (x # p). inmarked z \\<and> outmarked z", "have \"\\<dots> = card {Inr i :: nat + _|i. i < length (x # p) \\<and> outmarked ((x # p) ! i)}\" (is \"_ = card ?out\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. card\n     (insert (Inr (length p))\n       {Inr i |i. i < length p \\<and> outmarked ((x # p) ! i)}) =\n    card {Inr i |i. i < length (x # p) \\<and> outmarked ((x # p) ! i)}", "using nNil rtrancl_path_last[OF p nNil] y"], ["proof (prove)\nusing this:\n  p \\<noteq> []\n  last p = y\n  y \\<in> B \\<Gamma>\n\ngoal (1 subgoal):\n 1. card\n     (insert (Inr (length p))\n       {Inr i |i. i < length p \\<and> outmarked ((x # p) ! i)}) =\n    card {Inr i |i. i < length (x # p) \\<and> outmarked ((x # p) ! i)}", "by(intro arg_cong[where f=card])(auto simp add: outmarked_def last_conv_nth)"], ["proof (state)\nthis:\n  card\n   (insert (Inr (length p))\n     {Inr i |i. i < length p \\<and> outmarked ((x # p) ! i)}) =\n  card {Inr i |i. i < length (x # p) \\<and> outmarked ((x # p) ! i)}\n\ngoal (1 subgoal):\n 1. \\<exists>z\\<in>set (x # p). inmarked z \\<and> outmarked z", "also"], ["proof (state)\nthis:\n  card\n   (insert (Inr (length p))\n     {Inr i |i. i < length p \\<and> outmarked ((x # p) ! i)}) =\n  card {Inr i |i. i < length (x # p) \\<and> outmarked ((x # p) ! i)}\n\ngoal (1 subgoal):\n 1. \\<exists>z\\<in>set (x # p). inmarked z \\<and> outmarked z", "have \"card ?in + card ?out = card (?in \\<union> ?out)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card {Inl i |i. i < length (x # p) \\<and> inmarked ((x # p) ! i)} +\n    card {Inr i |i. i < length (x # p) \\<and> outmarked ((x # p) ! i)} =\n    card\n     ({Inl i |i. i < length (x # p) \\<and> inmarked ((x # p) ! i)} \\<union>\n      {Inr i |i. i < length (x # p) \\<and> outmarked ((x # p) ! i)})", "by(rule card_Un_disjoint[symmetric]) auto"], ["proof (state)\nthis:\n  card {Inl i |i. i < length (x # p) \\<and> inmarked ((x # p) ! i)} +\n  card {Inr i |i. i < length (x # p) \\<and> outmarked ((x # p) ! i)} =\n  card\n   ({Inl i |i. i < length (x # p) \\<and> inmarked ((x # p) ! i)} \\<union>\n    {Inr i |i. i < length (x # p) \\<and> outmarked ((x # p) ! i)})\n\ngoal (1 subgoal):\n 1. \\<exists>z\\<in>set (x # p). inmarked z \\<and> outmarked z", "also"], ["proof (state)\nthis:\n  card {Inl i |i. i < length (x # p) \\<and> inmarked ((x # p) ! i)} +\n  card {Inr i |i. i < length (x # p) \\<and> outmarked ((x # p) ! i)} =\n  card\n   ({Inl i |i. i < length (x # p) \\<and> inmarked ((x # p) ! i)} \\<union>\n    {Inr i |i. i < length (x # p) \\<and> outmarked ((x # p) ! i)})\n\ngoal (1 subgoal):\n 1. \\<exists>z\\<in>set (x # p). inmarked z \\<and> outmarked z", "let ?f = \"case_sum id id\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>z\\<in>set (x # p). inmarked z \\<and> outmarked z", "have \"?f ` (?in \\<union> ?out) \\<subseteq> {i. i < length (x # p)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. case_sum id id `\n    ({Inl i |i. i < length (x # p) \\<and> inmarked ((x # p) ! i)} \\<union>\n     {Inr i |i. i < length (x # p) \\<and> outmarked ((x # p) ! i)})\n    \\<subseteq> {i. i < length (x # p)}", "by auto"], ["proof (state)\nthis:\n  case_sum id id `\n  ({Inl i |i. i < length (x # p) \\<and> inmarked ((x # p) ! i)} \\<union>\n   {Inr i |i. i < length (x # p) \\<and> outmarked ((x # p) ! i)})\n  \\<subseteq> {i. i < length (x # p)}\n\ngoal (1 subgoal):\n 1. \\<exists>z\\<in>set (x # p). inmarked z \\<and> outmarked z", "from card_mono[OF _ this]"], ["proof (chain)\npicking this:\n  finite {i. i < length (x # p)} \\<Longrightarrow>\n  card\n   (case_sum id id `\n    ({Inl i |i. i < length (x # p) \\<and> inmarked ((x # p) ! i)} \\<union>\n     {Inr i |i. i < length (x # p) \\<and> outmarked ((x # p) ! i)}))\n  \\<le> card {i. i < length (x # p)}", "have \"card (?f ` (?in \\<union> ?out)) \\<le> length p + 1\""], ["proof (prove)\nusing this:\n  finite {i. i < length (x # p)} \\<Longrightarrow>\n  card\n   (case_sum id id `\n    ({Inl i |i. i < length (x # p) \\<and> inmarked ((x # p) ! i)} \\<union>\n     {Inr i |i. i < length (x # p) \\<and> outmarked ((x # p) ! i)}))\n  \\<le> card {i. i < length (x # p)}\n\ngoal (1 subgoal):\n 1. card\n     (case_sum id id `\n      ({Inl i |i. i < length (x # p) \\<and> inmarked ((x # p) ! i)} \\<union>\n       {Inr i |i. i < length (x # p) \\<and> outmarked ((x # p) ! i)}))\n    \\<le> length p + 1", "by simp"], ["proof (state)\nthis:\n  card\n   (case_sum id id `\n    ({Inl i |i. i < length (x # p) \\<and> inmarked ((x # p) ! i)} \\<union>\n     {Inr i |i. i < length (x # p) \\<and> outmarked ((x # p) ! i)}))\n  \\<le> length p + 1\n\ngoal (1 subgoal):\n 1. \\<exists>z\\<in>set (x # p). inmarked z \\<and> outmarked z", "ultimately"], ["proof (chain)\npicking this:\n  length p + 2\n  \\<le> card\n         ({Inl i |i.\n           i < length (x # p) \\<and> inmarked ((x # p) ! i)} \\<union>\n          {Inr i |i. i < length (x # p) \\<and> outmarked ((x # p) ! i)})\n  card\n   (case_sum id id `\n    ({Inl i |i. i < length (x # p) \\<and> inmarked ((x # p) ! i)} \\<union>\n     {Inr i |i. i < length (x # p) \\<and> outmarked ((x # p) ! i)}))\n  \\<le> length p + 1", "have \"\\<not> inj_on ?f (?in \\<union> ?out)\""], ["proof (prove)\nusing this:\n  length p + 2\n  \\<le> card\n         ({Inl i |i.\n           i < length (x # p) \\<and> inmarked ((x # p) ! i)} \\<union>\n          {Inr i |i. i < length (x # p) \\<and> outmarked ((x # p) ! i)})\n  card\n   (case_sum id id `\n    ({Inl i |i. i < length (x # p) \\<and> inmarked ((x # p) ! i)} \\<union>\n     {Inr i |i. i < length (x # p) \\<and> outmarked ((x # p) ! i)}))\n  \\<le> length p + 1\n\ngoal (1 subgoal):\n 1. \\<not> inj_on (case_sum id id)\n            ({Inl i |i.\n              i < length (x # p) \\<and> inmarked ((x # p) ! i)} \\<union>\n             {Inr i |i. i < length (x # p) \\<and> outmarked ((x # p) ! i)})", "by(intro pigeonhole) simp"], ["proof (state)\nthis:\n  \\<not> inj_on (case_sum id id)\n          ({Inl i |i.\n            i < length (x # p) \\<and> inmarked ((x # p) ! i)} \\<union>\n           {Inr i |i. i < length (x # p) \\<and> outmarked ((x # p) ! i)})\n\ngoal (1 subgoal):\n 1. \\<exists>z\\<in>set (x # p). inmarked z \\<and> outmarked z", "then"], ["proof (chain)\npicking this:\n  \\<not> inj_on (case_sum id id)\n          ({Inl i |i.\n            i < length (x # p) \\<and> inmarked ((x # p) ! i)} \\<union>\n           {Inr i |i. i < length (x # p) \\<and> outmarked ((x # p) ! i)})", "obtain i where \"i < length (x # p)\" \"?double ((x # p) ! i)\""], ["proof (prove)\nusing this:\n  \\<not> inj_on (case_sum id id)\n          ({Inl i |i.\n            i < length (x # p) \\<and> inmarked ((x # p) ! i)} \\<union>\n           {Inr i |i. i < length (x # p) \\<and> outmarked ((x # p) ! i)})\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>i < length (x # p);\n         inmarked ((x # p) ! i) \\<and> outmarked ((x # p) ! i)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto simp add: inj_on_def)"], ["proof (state)\nthis:\n  i < length (x # p)\n  inmarked ((x # p) ! i) \\<and> outmarked ((x # p) ! i)\n\ngoal (1 subgoal):\n 1. \\<exists>z\\<in>set (x # p). inmarked z \\<and> outmarked z", "thus ?thesis"], ["proof (prove)\nusing this:\n  i < length (x # p)\n  inmarked ((x # p) ! i) \\<and> outmarked ((x # p) ! i)\n\ngoal (1 subgoal):\n 1. \\<exists>z\\<in>set (x # p). inmarked z \\<and> outmarked z", "by(auto simp add: set_conv_nth)"], ["proof (state)\nthis:\n  \\<exists>z\\<in>set (x # p). inmarked z \\<and> outmarked z\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>z\\<in>set (x # p). inmarked z \\<and> outmarked z\n\ngoal (1 subgoal):\n 1. p \\<noteq> [] \\<Longrightarrow>\n    (\\<exists>z\\<in>set p. z \\<in> separating_of_bipartite S) \\<or>\n    x \\<in> separating_of_bipartite S", "moreover"], ["proof (state)\nthis:\n  \\<exists>z\\<in>set (x # p). inmarked z \\<and> outmarked z\n\ngoal (1 subgoal):\n 1. p \\<noteq> [] \\<Longrightarrow>\n    (\\<exists>z\\<in>set p. z \\<in> separating_of_bipartite S) \\<or>\n    x \\<in> separating_of_bipartite S", "have \"z \\<in> separating_of_bipartite S\" if \"?double z\" for z"], ["proof (prove)\ngoal (1 subgoal):\n 1. z \\<in> separating_of_bipartite S", "using that disjoint"], ["proof (prove)\nusing this:\n  inmarked z \\<and> outmarked z\n  A \\<Gamma> \\<inter> B \\<Gamma> = {}\n\ngoal (1 subgoal):\n 1. z \\<in> separating_of_bipartite S", "by(auto simp add: separating_of_bipartite_def Let_def inmarked_def outmarked_def)"], ["proof (state)\nthis:\n  inmarked ?z \\<and> outmarked ?z \\<Longrightarrow>\n  ?z \\<in> separating_of_bipartite S\n\ngoal (1 subgoal):\n 1. p \\<noteq> [] \\<Longrightarrow>\n    (\\<exists>z\\<in>set p. z \\<in> separating_of_bipartite S) \\<or>\n    x \\<in> separating_of_bipartite S", "ultimately"], ["proof (chain)\npicking this:\n  \\<exists>z\\<in>set (x # p). inmarked z \\<and> outmarked z\n  inmarked ?z \\<and> outmarked ?z \\<Longrightarrow>\n  ?z \\<in> separating_of_bipartite S", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>z\\<in>set (x # p). inmarked z \\<and> outmarked z\n  inmarked ?z \\<and> outmarked ?z \\<Longrightarrow>\n  ?z \\<in> separating_of_bipartite S\n\ngoal (1 subgoal):\n 1. (\\<exists>z\\<in>set p. z \\<in> separating_of_bipartite S) \\<or>\n    x \\<in> separating_of_bipartite S", "by auto"], ["proof (state)\nthis:\n  (\\<exists>z\\<in>set p. z \\<in> separating_of_bipartite S) \\<or>\n  x \\<in> separating_of_bipartite S\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma separating_of_bipartite:\n  \"separating \\<Gamma> (separating_of_bipartite S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. separating \\<Gamma> (separating_of_bipartite S)", "by(rule separating_gen.intros)(erule (1) separating_of_bipartite_aux; simp)"], ["", "end"], ["", "lemma current_bipartite_web_finite:\n  assumes f: \"current (bipartite_web_of \\<Gamma>) f\" (is \"current ?\\<Gamma> _\")\n  shows \"f e \\<noteq> \\<top>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f e \\<noteq> \\<top>", "proof(cases e)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b. e = (a, b) \\<Longrightarrow> f e \\<noteq> \\<top>", "case (Pair x y)"], ["proof (state)\nthis:\n  e = (x, y)\n\ngoal (1 subgoal):\n 1. \\<And>a b. e = (a, b) \\<Longrightarrow> f e \\<noteq> \\<top>", "have \"f e \\<le> d_OUT f x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f e \\<le> d_OUT f x", "unfolding Pair d_OUT_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. f (x, y) \\<le> (\\<Sum>\\<^sup>+ y. f (x, y))", "by(rule nn_integral_ge_point) simp"], ["proof (state)\nthis:\n  f e \\<le> d_OUT f x\n\ngoal (1 subgoal):\n 1. \\<And>a b. e = (a, b) \\<Longrightarrow> f e \\<noteq> \\<top>", "also"], ["proof (state)\nthis:\n  f e \\<le> d_OUT f x\n\ngoal (1 subgoal):\n 1. \\<And>a b. e = (a, b) \\<Longrightarrow> f e \\<noteq> \\<top>", "have \"\\<dots> \\<le> weight ?\\<Gamma> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT f x \\<le> weight (bipartite_web_of \\<Gamma>) x", "by(rule currentD_weight_OUT[OF f])"], ["proof (state)\nthis:\n  d_OUT f x \\<le> weight (bipartite_web_of \\<Gamma>) x\n\ngoal (1 subgoal):\n 1. \\<And>a b. e = (a, b) \\<Longrightarrow> f e \\<noteq> \\<top>", "also"], ["proof (state)\nthis:\n  d_OUT f x \\<le> weight (bipartite_web_of \\<Gamma>) x\n\ngoal (1 subgoal):\n 1. \\<And>a b. e = (a, b) \\<Longrightarrow> f e \\<noteq> \\<top>", "have \"\\<dots> < \\<top>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. weight (bipartite_web_of \\<Gamma>) x < \\<top>", "by(cases x)(simp_all add: less_top[symmetric])"], ["proof (state)\nthis:\n  weight (bipartite_web_of \\<Gamma>) x < \\<top>\n\ngoal (1 subgoal):\n 1. \\<And>a b. e = (a, b) \\<Longrightarrow> f e \\<noteq> \\<top>", "finally"], ["proof (chain)\npicking this:\n  f e < \\<top>", "show ?thesis"], ["proof (prove)\nusing this:\n  f e < \\<top>\n\ngoal (1 subgoal):\n 1. f e \\<noteq> \\<top>", "by simp"], ["proof (state)\nthis:\n  f e \\<noteq> \\<top>\n\ngoal:\nNo subgoals!", "qed"], ["", "definition current_of_bipartite :: \"('v + 'v) current \\<Rightarrow> 'v current\"\nwhere \"current_of_bipartite f = (\\<lambda>(x, y). f (Inl x, Inr y) * indicator \\<^bold>E (x, y))\""], ["", "lemma current_of_bipartite_simps [simp]: \"current_of_bipartite f (x, y) = f (Inl x, Inr y) * indicator \\<^bold>E (x, y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. current_of_bipartite f (x, y) =\n    f (Inl x, Inr y) * indicator \\<^bold>E (x, y)", "by(simp add: current_of_bipartite_def)"], ["", "lemma d_OUT_current_of_bipartite:\n  assumes f: \"current (bipartite_web_of \\<Gamma>) f\"\n  shows \"d_OUT (current_of_bipartite f) x = d_OUT f (Inl x) - f (Inl x, Inr x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT (current_of_bipartite f) x = d_OUT f (Inl x) - f (Inl x, Inr x)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. d_OUT (current_of_bipartite f) x = d_OUT f (Inl x) - f (Inl x, Inr x)", "have \"d_OUT (current_of_bipartite f) x = \\<integral>\\<^sup>+ y. f (Inl x, y) * indicator \\<^bold>E (x, projr y) \\<partial>count_space (range Inr)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT (current_of_bipartite f) x =\n    (\\<Sum>\\<^sup>+ y\\<in>range Inr.\n       f (Inl x, y) * indicator \\<^bold>E (x, projr y))", "by(simp add: d_OUT_def nn_integral_count_space_reindex)"], ["proof (state)\nthis:\n  d_OUT (current_of_bipartite f) x =\n  (\\<Sum>\\<^sup>+ y\\<in>range Inr.\n     f (Inl x, y) * indicator \\<^bold>E (x, projr y))\n\ngoal (1 subgoal):\n 1. d_OUT (current_of_bipartite f) x = d_OUT f (Inl x) - f (Inl x, Inr x)", "also"], ["proof (state)\nthis:\n  d_OUT (current_of_bipartite f) x =\n  (\\<Sum>\\<^sup>+ y\\<in>range Inr.\n     f (Inl x, y) * indicator \\<^bold>E (x, projr y))\n\ngoal (1 subgoal):\n 1. d_OUT (current_of_bipartite f) x = d_OUT f (Inl x) - f (Inl x, Inr x)", "have \"\\<dots> = d_OUT f (Inl x) - \\<integral>\\<^sup>+ y. f (Inl x, y) * indicator {Inr x} y \\<partial>count_space UNIV\" (is \"_ = _ - ?rest\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y\\<in>range Inr.\n       f (Inl x, y) * indicator \\<^bold>E (x, projr y)) =\n    d_OUT f (Inl x) -\n    (\\<integral>\\<^sup>+y\\<in>{Inr x}. f (Inl x, y)\n     \\<partial>count_space UNIV)", "unfolding d_OUT_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y\\<in>range Inr.\n       f (Inl x, y) * indicator \\<^bold>E (x, projr y)) =\n    (\\<Sum>\\<^sup>+ y. f (Inl x, y)) -\n    (\\<integral>\\<^sup>+y\\<in>{Inr x}. f (Inl x, y)\n     \\<partial>count_space UNIV)", "by(subst nn_integral_diff[symmetric])(auto 4 4 simp add: current_bipartite_web_finite[OF f] AE_count_space nn_integral_count_space_indicator no_loop split: split_indicator intro!: nn_integral_cong intro: currentD_outside[OF f] elim: edge_bipartite_webE)"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y\\<in>range Inr.\n     f (Inl x, y) * indicator \\<^bold>E (x, projr y)) =\n  d_OUT f (Inl x) -\n  (\\<integral>\\<^sup>+y\\<in>{Inr x}. f (Inl x, y)\\<partial>count_space UNIV)\n\ngoal (1 subgoal):\n 1. d_OUT (current_of_bipartite f) x = d_OUT f (Inl x) - f (Inl x, Inr x)", "finally"], ["proof (chain)\npicking this:\n  d_OUT (current_of_bipartite f) x =\n  d_OUT f (Inl x) -\n  (\\<integral>\\<^sup>+y\\<in>{Inr x}. f (Inl x, y)\\<partial>count_space UNIV)", "show ?thesis"], ["proof (prove)\nusing this:\n  d_OUT (current_of_bipartite f) x =\n  d_OUT f (Inl x) -\n  (\\<integral>\\<^sup>+y\\<in>{Inr x}. f (Inl x, y)\\<partial>count_space UNIV)\n\ngoal (1 subgoal):\n 1. d_OUT (current_of_bipartite f) x = d_OUT f (Inl x) - f (Inl x, Inr x)", "by simp"], ["proof (state)\nthis:\n  d_OUT (current_of_bipartite f) x = d_OUT f (Inl x) - f (Inl x, Inr x)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma d_IN_current_of_bipartite:\n  assumes f: \"current (bipartite_web_of \\<Gamma>) f\"\n  shows \"d_IN (current_of_bipartite f) x = d_IN f (Inr x) - f (Inl x, Inr x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN (current_of_bipartite f) x = d_IN f (Inr x) - f (Inl x, Inr x)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. d_IN (current_of_bipartite f) x = d_IN f (Inr x) - f (Inl x, Inr x)", "have \"d_IN (current_of_bipartite f) x = \\<integral>\\<^sup>+ y. f (y, Inr x) * indicator \\<^bold>E (projl y, x) \\<partial>count_space (range Inl)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN (current_of_bipartite f) x =\n    (\\<Sum>\\<^sup>+ y\\<in>range Inl.\n       f (y, Inr x) * indicator \\<^bold>E (projl y, x))", "by(simp add: d_IN_def nn_integral_count_space_reindex)"], ["proof (state)\nthis:\n  d_IN (current_of_bipartite f) x =\n  (\\<Sum>\\<^sup>+ y\\<in>range Inl.\n     f (y, Inr x) * indicator \\<^bold>E (projl y, x))\n\ngoal (1 subgoal):\n 1. d_IN (current_of_bipartite f) x = d_IN f (Inr x) - f (Inl x, Inr x)", "also"], ["proof (state)\nthis:\n  d_IN (current_of_bipartite f) x =\n  (\\<Sum>\\<^sup>+ y\\<in>range Inl.\n     f (y, Inr x) * indicator \\<^bold>E (projl y, x))\n\ngoal (1 subgoal):\n 1. d_IN (current_of_bipartite f) x = d_IN f (Inr x) - f (Inl x, Inr x)", "have \"\\<dots> = d_IN f (Inr x) - \\<integral>\\<^sup>+ y. f (y, Inr x) * indicator {Inl x} y \\<partial>count_space UNIV\" (is \"_ = _ - ?rest\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y\\<in>range Inl.\n       f (y, Inr x) * indicator \\<^bold>E (projl y, x)) =\n    d_IN f (Inr x) -\n    (\\<integral>\\<^sup>+y\\<in>{Inl x}. f (y, Inr x)\n     \\<partial>count_space UNIV)", "unfolding d_IN_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y\\<in>range Inl.\n       f (y, Inr x) * indicator \\<^bold>E (projl y, x)) =\n    (\\<Sum>\\<^sup>+ xa. f (xa, Inr x)) -\n    (\\<integral>\\<^sup>+y\\<in>{Inl x}. f (y, Inr x)\n     \\<partial>count_space UNIV)", "by(subst nn_integral_diff[symmetric])(auto 4 4 simp add: current_bipartite_web_finite[OF f] AE_count_space nn_integral_count_space_indicator no_loop split: split_indicator intro!: nn_integral_cong intro: currentD_outside[OF f] elim: edge_bipartite_webE)"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y\\<in>range Inl.\n     f (y, Inr x) * indicator \\<^bold>E (projl y, x)) =\n  d_IN f (Inr x) -\n  (\\<integral>\\<^sup>+y\\<in>{Inl x}. f (y, Inr x)\\<partial>count_space UNIV)\n\ngoal (1 subgoal):\n 1. d_IN (current_of_bipartite f) x = d_IN f (Inr x) - f (Inl x, Inr x)", "finally"], ["proof (chain)\npicking this:\n  d_IN (current_of_bipartite f) x =\n  d_IN f (Inr x) -\n  (\\<integral>\\<^sup>+y\\<in>{Inl x}. f (y, Inr x)\\<partial>count_space UNIV)", "show ?thesis"], ["proof (prove)\nusing this:\n  d_IN (current_of_bipartite f) x =\n  d_IN f (Inr x) -\n  (\\<integral>\\<^sup>+y\\<in>{Inl x}. f (y, Inr x)\\<partial>count_space UNIV)\n\ngoal (1 subgoal):\n 1. d_IN (current_of_bipartite f) x = d_IN f (Inr x) - f (Inl x, Inr x)", "by simp"], ["proof (state)\nthis:\n  d_IN (current_of_bipartite f) x = d_IN f (Inr x) - f (Inl x, Inr x)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma current_current_of_bipartite: \\<comment> \\<open>Lemma 6.3\\<close>\n  assumes f: \"current (bipartite_web_of \\<Gamma>) f\" (is \"current ?\\<Gamma> _\")\n  and w: \"wave (bipartite_web_of \\<Gamma>) f\"\n  shows \"current \\<Gamma> (current_of_bipartite f)\" (is \"current _ ?f\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. current \\<Gamma> (current_of_bipartite f)", "proof"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x. d_OUT (current_of_bipartite f) x \\<le> weight \\<Gamma> x\n 2. \\<And>x. d_IN (current_of_bipartite f) x \\<le> weight \\<Gamma> x\n 3. \\<And>x.\n       \\<lbrakk>x \\<notin> A \\<Gamma>; x \\<notin> B \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> d_OUT (current_of_bipartite f) x\n                         \\<le> d_IN (current_of_bipartite f) x\n 4. \\<And>e.\n       e \\<notin> \\<^bold>E \\<Longrightarrow> current_of_bipartite f e = 0", "fix x"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x. d_OUT (current_of_bipartite f) x \\<le> weight \\<Gamma> x\n 2. \\<And>x. d_IN (current_of_bipartite f) x \\<le> weight \\<Gamma> x\n 3. \\<And>x.\n       \\<lbrakk>x \\<notin> A \\<Gamma>; x \\<notin> B \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> d_OUT (current_of_bipartite f) x\n                         \\<le> d_IN (current_of_bipartite f) x\n 4. \\<And>e.\n       e \\<notin> \\<^bold>E \\<Longrightarrow> current_of_bipartite f e = 0", "have \"d_OUT ?f x \\<le> d_OUT f (Inl x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT (current_of_bipartite f) x \\<le> d_OUT f (Inl x)", "by(simp add: d_OUT_current_of_bipartite[OF f] diff_le_self_ennreal)"], ["proof (state)\nthis:\n  d_OUT (current_of_bipartite f) x \\<le> d_OUT f (Inl x)\n\ngoal (4 subgoals):\n 1. \\<And>x. d_OUT (current_of_bipartite f) x \\<le> weight \\<Gamma> x\n 2. \\<And>x. d_IN (current_of_bipartite f) x \\<le> weight \\<Gamma> x\n 3. \\<And>x.\n       \\<lbrakk>x \\<notin> A \\<Gamma>; x \\<notin> B \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> d_OUT (current_of_bipartite f) x\n                         \\<le> d_IN (current_of_bipartite f) x\n 4. \\<And>e.\n       e \\<notin> \\<^bold>E \\<Longrightarrow> current_of_bipartite f e = 0", "also"], ["proof (state)\nthis:\n  d_OUT (current_of_bipartite f) x \\<le> d_OUT f (Inl x)\n\ngoal (4 subgoals):\n 1. \\<And>x. d_OUT (current_of_bipartite f) x \\<le> weight \\<Gamma> x\n 2. \\<And>x. d_IN (current_of_bipartite f) x \\<le> weight \\<Gamma> x\n 3. \\<And>x.\n       \\<lbrakk>x \\<notin> A \\<Gamma>; x \\<notin> B \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> d_OUT (current_of_bipartite f) x\n                         \\<le> d_IN (current_of_bipartite f) x\n 4. \\<And>e.\n       e \\<notin> \\<^bold>E \\<Longrightarrow> current_of_bipartite f e = 0", "have \"\\<dots> \\<le> weight \\<Gamma> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT f (Inl x) \\<le> weight \\<Gamma> x", "using currentD_weight_OUT[OF f, of \"Inl x\"]"], ["proof (prove)\nusing this:\n  d_OUT f (Inl x) \\<le> weight (bipartite_web_of \\<Gamma>) (Inl x)\n\ngoal (1 subgoal):\n 1. d_OUT f (Inl x) \\<le> weight \\<Gamma> x", "by(simp split: if_split_asm)"], ["proof (state)\nthis:\n  d_OUT f (Inl x) \\<le> weight \\<Gamma> x\n\ngoal (4 subgoals):\n 1. \\<And>x. d_OUT (current_of_bipartite f) x \\<le> weight \\<Gamma> x\n 2. \\<And>x. d_IN (current_of_bipartite f) x \\<le> weight \\<Gamma> x\n 3. \\<And>x.\n       \\<lbrakk>x \\<notin> A \\<Gamma>; x \\<notin> B \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> d_OUT (current_of_bipartite f) x\n                         \\<le> d_IN (current_of_bipartite f) x\n 4. \\<And>e.\n       e \\<notin> \\<^bold>E \\<Longrightarrow> current_of_bipartite f e = 0", "finally"], ["proof (chain)\npicking this:\n  d_OUT (current_of_bipartite f) x \\<le> weight \\<Gamma> x", "show \"d_OUT ?f x \\<le> weight \\<Gamma> x\""], ["proof (prove)\nusing this:\n  d_OUT (current_of_bipartite f) x \\<le> weight \\<Gamma> x\n\ngoal (1 subgoal):\n 1. d_OUT (current_of_bipartite f) x \\<le> weight \\<Gamma> x", "."], ["proof (state)\nthis:\n  d_OUT (current_of_bipartite f) x \\<le> weight \\<Gamma> x\n\ngoal (3 subgoals):\n 1. \\<And>x. d_IN (current_of_bipartite f) x \\<le> weight \\<Gamma> x\n 2. \\<And>x.\n       \\<lbrakk>x \\<notin> A \\<Gamma>; x \\<notin> B \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> d_OUT (current_of_bipartite f) x\n                         \\<le> d_IN (current_of_bipartite f) x\n 3. \\<And>e.\n       e \\<notin> \\<^bold>E \\<Longrightarrow> current_of_bipartite f e = 0", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x. d_IN (current_of_bipartite f) x \\<le> weight \\<Gamma> x\n 2. \\<And>x.\n       \\<lbrakk>x \\<notin> A \\<Gamma>; x \\<notin> B \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> d_OUT (current_of_bipartite f) x\n                         \\<le> d_IN (current_of_bipartite f) x\n 3. \\<And>e.\n       e \\<notin> \\<^bold>E \\<Longrightarrow> current_of_bipartite f e = 0", "fix x"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x. d_IN (current_of_bipartite f) x \\<le> weight \\<Gamma> x\n 2. \\<And>x.\n       \\<lbrakk>x \\<notin> A \\<Gamma>; x \\<notin> B \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> d_OUT (current_of_bipartite f) x\n                         \\<le> d_IN (current_of_bipartite f) x\n 3. \\<And>e.\n       e \\<notin> \\<^bold>E \\<Longrightarrow> current_of_bipartite f e = 0", "have \"d_IN ?f x \\<le> d_IN f (Inr x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN (current_of_bipartite f) x \\<le> d_IN f (Inr x)", "by(simp add: d_IN_current_of_bipartite[OF f] diff_le_self_ennreal)"], ["proof (state)\nthis:\n  d_IN (current_of_bipartite f) x \\<le> d_IN f (Inr x)\n\ngoal (3 subgoals):\n 1. \\<And>x. d_IN (current_of_bipartite f) x \\<le> weight \\<Gamma> x\n 2. \\<And>x.\n       \\<lbrakk>x \\<notin> A \\<Gamma>; x \\<notin> B \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> d_OUT (current_of_bipartite f) x\n                         \\<le> d_IN (current_of_bipartite f) x\n 3. \\<And>e.\n       e \\<notin> \\<^bold>E \\<Longrightarrow> current_of_bipartite f e = 0", "also"], ["proof (state)\nthis:\n  d_IN (current_of_bipartite f) x \\<le> d_IN f (Inr x)\n\ngoal (3 subgoals):\n 1. \\<And>x. d_IN (current_of_bipartite f) x \\<le> weight \\<Gamma> x\n 2. \\<And>x.\n       \\<lbrakk>x \\<notin> A \\<Gamma>; x \\<notin> B \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> d_OUT (current_of_bipartite f) x\n                         \\<le> d_IN (current_of_bipartite f) x\n 3. \\<And>e.\n       e \\<notin> \\<^bold>E \\<Longrightarrow> current_of_bipartite f e = 0", "have \"\\<dots> \\<le> weight \\<Gamma> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN f (Inr x) \\<le> weight \\<Gamma> x", "using currentD_weight_IN[OF f, of \"Inr x\"]"], ["proof (prove)\nusing this:\n  d_IN f (Inr x) \\<le> weight (bipartite_web_of \\<Gamma>) (Inr x)\n\ngoal (1 subgoal):\n 1. d_IN f (Inr x) \\<le> weight \\<Gamma> x", "by(simp split: if_split_asm)"], ["proof (state)\nthis:\n  d_IN f (Inr x) \\<le> weight \\<Gamma> x\n\ngoal (3 subgoals):\n 1. \\<And>x. d_IN (current_of_bipartite f) x \\<le> weight \\<Gamma> x\n 2. \\<And>x.\n       \\<lbrakk>x \\<notin> A \\<Gamma>; x \\<notin> B \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> d_OUT (current_of_bipartite f) x\n                         \\<le> d_IN (current_of_bipartite f) x\n 3. \\<And>e.\n       e \\<notin> \\<^bold>E \\<Longrightarrow> current_of_bipartite f e = 0", "finally"], ["proof (chain)\npicking this:\n  d_IN (current_of_bipartite f) x \\<le> weight \\<Gamma> x", "show \"d_IN ?f x \\<le> weight \\<Gamma> x\""], ["proof (prove)\nusing this:\n  d_IN (current_of_bipartite f) x \\<le> weight \\<Gamma> x\n\ngoal (1 subgoal):\n 1. d_IN (current_of_bipartite f) x \\<le> weight \\<Gamma> x", "."], ["proof (state)\nthis:\n  d_IN (current_of_bipartite f) x \\<le> weight \\<Gamma> x\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<notin> A \\<Gamma>; x \\<notin> B \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> d_OUT (current_of_bipartite f) x\n                         \\<le> d_IN (current_of_bipartite f) x\n 2. \\<And>e.\n       e \\<notin> \\<^bold>E \\<Longrightarrow> current_of_bipartite f e = 0", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<notin> A \\<Gamma>; x \\<notin> B \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> d_OUT (current_of_bipartite f) x\n                         \\<le> d_IN (current_of_bipartite f) x\n 2. \\<And>e.\n       e \\<notin> \\<^bold>E \\<Longrightarrow> current_of_bipartite f e = 0", "have OUT: \"d_OUT ?f b = 0\" if \"b \\<in> B \\<Gamma>\" for b"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT (current_of_bipartite f) b = 0", "using that"], ["proof (prove)\nusing this:\n  b \\<in> B \\<Gamma>\n\ngoal (1 subgoal):\n 1. d_OUT (current_of_bipartite f) b = 0", "by(auto simp add: d_OUT_def nn_integral_0_iff emeasure_count_space_eq_0 intro!: currentD_outside[OF f] dest: B_out)"], ["proof (state)\nthis:\n  ?b \\<in> B \\<Gamma> \\<Longrightarrow>\n  d_OUT (current_of_bipartite f) ?b = 0\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<notin> A \\<Gamma>; x \\<notin> B \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> d_OUT (current_of_bipartite f) x\n                         \\<le> d_IN (current_of_bipartite f) x\n 2. \\<And>e.\n       e \\<notin> \\<^bold>E \\<Longrightarrow> current_of_bipartite f e = 0", "show \"d_OUT ?f x \\<le> d_IN ?f x\" if A: \"x \\<notin> A \\<Gamma>\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT (current_of_bipartite f) x \\<le> d_IN (current_of_bipartite f) x", "proof(cases \"x \\<in> B \\<Gamma> \\<or> x \\<notin> \\<^bold>V\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<in> B \\<Gamma> \\<or> x \\<notin> \\<^bold>V \\<Longrightarrow>\n    d_OUT (current_of_bipartite f) x \\<le> d_IN (current_of_bipartite f) x\n 2. \\<not> (x \\<in> B \\<Gamma> \\<or> x \\<notin> \\<^bold>V) \\<Longrightarrow>\n    d_OUT (current_of_bipartite f) x \\<le> d_IN (current_of_bipartite f) x", "case True"], ["proof (state)\nthis:\n  x \\<in> B \\<Gamma> \\<or> x \\<notin> \\<^bold>V\n\ngoal (2 subgoals):\n 1. x \\<in> B \\<Gamma> \\<or> x \\<notin> \\<^bold>V \\<Longrightarrow>\n    d_OUT (current_of_bipartite f) x \\<le> d_IN (current_of_bipartite f) x\n 2. \\<not> (x \\<in> B \\<Gamma> \\<or> x \\<notin> \\<^bold>V) \\<Longrightarrow>\n    d_OUT (current_of_bipartite f) x \\<le> d_IN (current_of_bipartite f) x", "then"], ["proof (chain)\npicking this:\n  x \\<in> B \\<Gamma> \\<or> x \\<notin> \\<^bold>V", "show ?thesis"], ["proof (prove)\nusing this:\n  x \\<in> B \\<Gamma> \\<or> x \\<notin> \\<^bold>V\n\ngoal (1 subgoal):\n 1. d_OUT (current_of_bipartite f) x \\<le> d_IN (current_of_bipartite f) x", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<in> B \\<Gamma> \\<Longrightarrow>\n    d_OUT (current_of_bipartite f) x \\<le> d_IN (current_of_bipartite f) x\n 2. x \\<notin> \\<^bold>V \\<Longrightarrow>\n    d_OUT (current_of_bipartite f) x \\<le> d_IN (current_of_bipartite f) x", "assume \"x \\<in> B \\<Gamma>\""], ["proof (state)\nthis:\n  x \\<in> B \\<Gamma>\n\ngoal (2 subgoals):\n 1. x \\<in> B \\<Gamma> \\<Longrightarrow>\n    d_OUT (current_of_bipartite f) x \\<le> d_IN (current_of_bipartite f) x\n 2. x \\<notin> \\<^bold>V \\<Longrightarrow>\n    d_OUT (current_of_bipartite f) x \\<le> d_IN (current_of_bipartite f) x", "with OUT[OF this]"], ["proof (chain)\npicking this:\n  d_OUT (current_of_bipartite f) x = 0\n  x \\<in> B \\<Gamma>", "show ?thesis"], ["proof (prove)\nusing this:\n  d_OUT (current_of_bipartite f) x = 0\n  x \\<in> B \\<Gamma>\n\ngoal (1 subgoal):\n 1. d_OUT (current_of_bipartite f) x \\<le> d_IN (current_of_bipartite f) x", "by auto"], ["proof (state)\nthis:\n  d_OUT (current_of_bipartite f) x \\<le> d_IN (current_of_bipartite f) x\n\ngoal (1 subgoal):\n 1. x \\<notin> \\<^bold>V \\<Longrightarrow>\n    d_OUT (current_of_bipartite f) x \\<le> d_IN (current_of_bipartite f) x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<notin> \\<^bold>V \\<Longrightarrow>\n    d_OUT (current_of_bipartite f) x \\<le> d_IN (current_of_bipartite f) x", "assume \"x \\<notin> \\<^bold>V\""], ["proof (state)\nthis:\n  x \\<notin> \\<^bold>V\n\ngoal (1 subgoal):\n 1. x \\<notin> \\<^bold>V \\<Longrightarrow>\n    d_OUT (current_of_bipartite f) x \\<le> d_IN (current_of_bipartite f) x", "hence \"d_OUT ?f x = 0\""], ["proof (prove)\nusing this:\n  x \\<notin> \\<^bold>V\n\ngoal (1 subgoal):\n 1. d_OUT (current_of_bipartite f) x = 0", "by(auto simp add: d_OUT_def vertex_def nn_integral_0_iff emeasure_count_space_eq_0 intro!: currentD_outside[OF f])"], ["proof (state)\nthis:\n  d_OUT (current_of_bipartite f) x = 0\n\ngoal (1 subgoal):\n 1. x \\<notin> \\<^bold>V \\<Longrightarrow>\n    d_OUT (current_of_bipartite f) x \\<le> d_IN (current_of_bipartite f) x", "thus ?thesis"], ["proof (prove)\nusing this:\n  d_OUT (current_of_bipartite f) x = 0\n\ngoal (1 subgoal):\n 1. d_OUT (current_of_bipartite f) x \\<le> d_IN (current_of_bipartite f) x", "by simp"], ["proof (state)\nthis:\n  d_OUT (current_of_bipartite f) x \\<le> d_IN (current_of_bipartite f) x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  d_OUT (current_of_bipartite f) x \\<le> d_IN (current_of_bipartite f) x\n\ngoal (1 subgoal):\n 1. \\<not> (x \\<in> B \\<Gamma> \\<or> x \\<notin> \\<^bold>V) \\<Longrightarrow>\n    d_OUT (current_of_bipartite f) x \\<le> d_IN (current_of_bipartite f) x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (x \\<in> B \\<Gamma> \\<or> x \\<notin> \\<^bold>V) \\<Longrightarrow>\n    d_OUT (current_of_bipartite f) x \\<le> d_IN (current_of_bipartite f) x", "case B [simplified]: False"], ["proof (state)\nthis:\n  x \\<notin> B \\<Gamma> \\<and> vertex \\<Gamma> x\n\ngoal (1 subgoal):\n 1. \\<not> (x \\<in> B \\<Gamma> \\<or> x \\<notin> \\<^bold>V) \\<Longrightarrow>\n    d_OUT (current_of_bipartite f) x \\<le> d_IN (current_of_bipartite f) x", "have \"d_OUT ?f x = d_OUT f (Inl x) - f (Inl x, Inr x)\" (is \"_ = _ - ?rest\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT (current_of_bipartite f) x = d_OUT f (Inl x) - f (Inl x, Inr x)", "by(simp add: d_OUT_current_of_bipartite[OF f])"], ["proof (state)\nthis:\n  d_OUT (current_of_bipartite f) x = d_OUT f (Inl x) - f (Inl x, Inr x)\n\ngoal (1 subgoal):\n 1. \\<not> (x \\<in> B \\<Gamma> \\<or> x \\<notin> \\<^bold>V) \\<Longrightarrow>\n    d_OUT (current_of_bipartite f) x \\<le> d_IN (current_of_bipartite f) x", "also"], ["proof (state)\nthis:\n  d_OUT (current_of_bipartite f) x = d_OUT f (Inl x) - f (Inl x, Inr x)\n\ngoal (1 subgoal):\n 1. \\<not> (x \\<in> B \\<Gamma> \\<or> x \\<notin> \\<^bold>V) \\<Longrightarrow>\n    d_OUT (current_of_bipartite f) x \\<le> d_IN (current_of_bipartite f) x", "have \"d_OUT f (Inl x) \\<le> d_IN f (Inr x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT f (Inl x) \\<le> d_IN f (Inr x)", "proof(rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> d_OUT f (Inl x) \\<le> d_IN f (Inr x) \\<Longrightarrow> False", "assume \"\\<not> ?thesis\""], ["proof (state)\nthis:\n  \\<not> d_OUT f (Inl x) \\<le> d_IN f (Inr x)\n\ngoal (1 subgoal):\n 1. \\<not> d_OUT f (Inl x) \\<le> d_IN f (Inr x) \\<Longrightarrow> False", "hence *: \"d_IN f (Inr x) < d_OUT f (Inl x)\""], ["proof (prove)\nusing this:\n  \\<not> d_OUT f (Inl x) \\<le> d_IN f (Inr x)\n\ngoal (1 subgoal):\n 1. d_IN f (Inr x) < d_OUT f (Inl x)", "by(simp add: not_less)"], ["proof (state)\nthis:\n  d_IN f (Inr x) < d_OUT f (Inl x)\n\ngoal (1 subgoal):\n 1. \\<not> d_OUT f (Inl x) \\<le> d_IN f (Inr x) \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  d_IN f (Inr x) < d_OUT f (Inl x)\n\ngoal (1 subgoal):\n 1. \\<not> d_OUT f (Inl x) \\<le> d_IN f (Inr x) \\<Longrightarrow> False", "have \"\\<dots> \\<le> weight \\<Gamma> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT f (Inl x) \\<le> weight \\<Gamma> x", "using currentD_weight_OUT[OF f, of \"Inl x\"] B"], ["proof (prove)\nusing this:\n  d_OUT f (Inl x) \\<le> weight (bipartite_web_of \\<Gamma>) (Inl x)\n  x \\<notin> B \\<Gamma> \\<and> vertex \\<Gamma> x\n\ngoal (1 subgoal):\n 1. d_OUT f (Inl x) \\<le> weight \\<Gamma> x", "by simp"], ["proof (state)\nthis:\n  d_OUT f (Inl x) \\<le> weight \\<Gamma> x\n\ngoal (1 subgoal):\n 1. \\<not> d_OUT f (Inl x) \\<le> d_IN f (Inr x) \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  d_IN f (Inr x) < weight \\<Gamma> x", "have \"Inr x \\<notin> TER\\<^bsub>?\\<Gamma>\\<^esub> f\""], ["proof (prove)\nusing this:\n  d_IN f (Inr x) < weight \\<Gamma> x\n\ngoal (1 subgoal):\n 1. Inr x \\<notin> TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f", "using A"], ["proof (prove)\nusing this:\n  d_IN f (Inr x) < weight \\<Gamma> x\n  x \\<notin> A \\<Gamma>\n\ngoal (1 subgoal):\n 1. Inr x \\<notin> TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f", "by(auto elim!: SAT.cases)"], ["proof (state)\nthis:\n  Inr x \\<notin> TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f\n\ngoal (1 subgoal):\n 1. \\<not> d_OUT f (Inl x) \\<le> d_IN f (Inr x) \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  Inr x \\<notin> TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f\n\ngoal (1 subgoal):\n 1. \\<not> d_OUT f (Inl x) \\<le> d_IN f (Inr x) \\<Longrightarrow> False", "have \"Inl x \\<notin> TER\\<^bsub>?\\<Gamma>\\<^esub> f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Inl x \\<notin> TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f", "using *"], ["proof (prove)\nusing this:\n  d_IN f (Inr x) < d_OUT f (Inl x)\n\ngoal (1 subgoal):\n 1. Inl x \\<notin> TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f", "by(auto simp add: SINK.simps)"], ["proof (state)\nthis:\n  Inl x \\<notin> TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f\n\ngoal (1 subgoal):\n 1. \\<not> d_OUT f (Inl x) \\<le> d_IN f (Inr x) \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  Inl x \\<notin> TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f\n\ngoal (1 subgoal):\n 1. \\<not> d_OUT f (Inl x) \\<le> d_IN f (Inr x) \\<Longrightarrow> False", "have \"path ?\\<Gamma> (Inl x) [Inr x] (Inr x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path (bipartite_web_of \\<Gamma>) (Inl x) [Inr x] (Inr x)", "by(rule rtrancl_path.step)(auto intro!: rtrancl_path.base simp add: no_loop A B)"], ["proof (state)\nthis:\n  path (bipartite_web_of \\<Gamma>) (Inl x) [Inr x] (Inr x)\n\ngoal (1 subgoal):\n 1. \\<not> d_OUT f (Inl x) \\<le> d_IN f (Inr x) \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  Inr x \\<notin> TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f\n  Inl x \\<notin> TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f\n  path (bipartite_web_of \\<Gamma>) (Inl x) [Inr x] (Inr x)", "show False"], ["proof (prove)\nusing this:\n  Inr x \\<notin> TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f\n  Inl x \\<notin> TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f\n  path (bipartite_web_of \\<Gamma>) (Inl x) [Inr x] (Inr x)\n\ngoal (1 subgoal):\n 1. False", "using waveD_separating[OF w] A B"], ["proof (prove)\nusing this:\n  Inr x \\<notin> TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f\n  Inl x \\<notin> TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f\n  path (bipartite_web_of \\<Gamma>) (Inl x) [Inr x] (Inr x)\n  separating (bipartite_web_of \\<Gamma>)\n   (TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f)\n  x \\<notin> A \\<Gamma>\n  x \\<notin> B \\<Gamma> \\<and> vertex \\<Gamma> x\n\ngoal (1 subgoal):\n 1. False", "by(auto dest!: separatingD)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  d_OUT f (Inl x) \\<le> d_IN f (Inr x)\n\ngoal (1 subgoal):\n 1. \\<not> (x \\<in> B \\<Gamma> \\<or> x \\<notin> \\<^bold>V) \\<Longrightarrow>\n    d_OUT (current_of_bipartite f) x \\<le> d_IN (current_of_bipartite f) x", "hence \"d_OUT f (Inl x) - ?rest \\<le> d_IN f (Inr x) - ?rest\""], ["proof (prove)\nusing this:\n  d_OUT f (Inl x) \\<le> d_IN f (Inr x)\n\ngoal (1 subgoal):\n 1. d_OUT f (Inl x) - f (Inl x, Inr x)\n    \\<le> d_IN f (Inr x) - f (Inl x, Inr x)", "by(rule ennreal_minus_mono) simp"], ["proof (state)\nthis:\n  d_OUT f (Inl x) - f (Inl x, Inr x) \\<le> d_IN f (Inr x) - f (Inl x, Inr x)\n\ngoal (1 subgoal):\n 1. \\<not> (x \\<in> B \\<Gamma> \\<or> x \\<notin> \\<^bold>V) \\<Longrightarrow>\n    d_OUT (current_of_bipartite f) x \\<le> d_IN (current_of_bipartite f) x", "also"], ["proof (state)\nthis:\n  d_OUT f (Inl x) - f (Inl x, Inr x) \\<le> d_IN f (Inr x) - f (Inl x, Inr x)\n\ngoal (1 subgoal):\n 1. \\<not> (x \\<in> B \\<Gamma> \\<or> x \\<notin> \\<^bold>V) \\<Longrightarrow>\n    d_OUT (current_of_bipartite f) x \\<le> d_IN (current_of_bipartite f) x", "have \"\\<dots> =  d_IN ?f x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN f (Inr x) - f (Inl x, Inr x) = d_IN (current_of_bipartite f) x", "by(simp add: d_IN_current_of_bipartite[OF f])"], ["proof (state)\nthis:\n  d_IN f (Inr x) - f (Inl x, Inr x) = d_IN (current_of_bipartite f) x\n\ngoal (1 subgoal):\n 1. \\<not> (x \\<in> B \\<Gamma> \\<or> x \\<notin> \\<^bold>V) \\<Longrightarrow>\n    d_OUT (current_of_bipartite f) x \\<le> d_IN (current_of_bipartite f) x", "finally"], ["proof (chain)\npicking this:\n  d_OUT (current_of_bipartite f) x \\<le> d_IN (current_of_bipartite f) x", "show ?thesis"], ["proof (prove)\nusing this:\n  d_OUT (current_of_bipartite f) x \\<le> d_IN (current_of_bipartite f) x\n\ngoal (1 subgoal):\n 1. d_OUT (current_of_bipartite f) x \\<le> d_IN (current_of_bipartite f) x", "."], ["proof (state)\nthis:\n  d_OUT (current_of_bipartite f) x \\<le> d_IN (current_of_bipartite f) x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?x \\<notin> A \\<Gamma> \\<Longrightarrow>\n  d_OUT (current_of_bipartite f) ?x \\<le> d_IN (current_of_bipartite f) ?x\n\ngoal (1 subgoal):\n 1. \\<And>e.\n       e \\<notin> \\<^bold>E \\<Longrightarrow> current_of_bipartite f e = 0", "show \"?f e = 0\" if \"e \\<notin> \\<^bold>E\" for e"], ["proof (prove)\ngoal (1 subgoal):\n 1. current_of_bipartite f e = 0", "using that"], ["proof (prove)\nusing this:\n  e \\<notin> \\<^bold>E\n\ngoal (1 subgoal):\n 1. current_of_bipartite f e = 0", "by(cases e)(auto)"], ["proof (state)\nthis:\n  ?e \\<notin> \\<^bold>E \\<Longrightarrow> current_of_bipartite f ?e = 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma TER_current_of_bipartite: \\<comment> \\<open>Lemma 6.3\\<close>\n  assumes f: \"current (bipartite_web_of \\<Gamma>) f\" (is \"current ?\\<Gamma> _\")\n  and w: \"wave (bipartite_web_of \\<Gamma>) f\"\n  shows \"TER (current_of_bipartite f) = separating_of_bipartite (TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f)\"\n    (is \"TER ?f = separating_of_bipartite ?TER\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. TER (current_of_bipartite f) =\n    separating_of_bipartite (TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f)", "proof(rule set_eqI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (x \\<in> TER (current_of_bipartite f)) =\n       (x \\<in> separating_of_bipartite\n                 (TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f))", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (x \\<in> TER (current_of_bipartite f)) =\n       (x \\<in> separating_of_bipartite\n                 (TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f))", "consider (A) \"x \\<in> A \\<Gamma>\" \"x \\<in> \\<^bold>V\" | (B) \"x \\<in> B \\<Gamma>\" \"x \\<in> \\<^bold>V\"\n    | (inner) \"x \\<notin> A \\<Gamma>\" \"x \\<notin> B \\<Gamma>\" \"x \\<in> \\<^bold>V\" | (outside) \"x \\<notin> \\<^bold>V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>x \\<in> A \\<Gamma>; x \\<in> \\<^bold>V\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     \\<lbrakk>x \\<in> B \\<Gamma>; x \\<in> \\<^bold>V\\<rbrakk>\n     \\<Longrightarrow> thesis;\n     \\<lbrakk>x \\<notin> A \\<Gamma>; x \\<notin> B \\<Gamma>;\n      x \\<in> \\<^bold>V\\<rbrakk>\n     \\<Longrightarrow> thesis;\n     x \\<notin> \\<^bold>V \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>\\<lbrakk>x \\<in> A \\<Gamma>; x \\<in> \\<^bold>V\\<rbrakk>\n           \\<Longrightarrow> ?thesis;\n   \\<lbrakk>x \\<in> B \\<Gamma>; x \\<in> \\<^bold>V\\<rbrakk>\n   \\<Longrightarrow> ?thesis;\n   \\<lbrakk>x \\<notin> A \\<Gamma>; x \\<notin> B \\<Gamma>;\n    x \\<in> \\<^bold>V\\<rbrakk>\n   \\<Longrightarrow> ?thesis;\n   x \\<notin> \\<^bold>V \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       (x \\<in> TER (current_of_bipartite f)) =\n       (x \\<in> separating_of_bipartite\n                 (TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f))", "thus \"x \\<in> TER ?f \\<longleftrightarrow> x \\<in> separating_of_bipartite ?TER\""], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<lbrakk>x \\<in> A \\<Gamma>; x \\<in> \\<^bold>V\\<rbrakk>\n           \\<Longrightarrow> ?thesis;\n   \\<lbrakk>x \\<in> B \\<Gamma>; x \\<in> \\<^bold>V\\<rbrakk>\n   \\<Longrightarrow> ?thesis;\n   \\<lbrakk>x \\<notin> A \\<Gamma>; x \\<notin> B \\<Gamma>;\n    x \\<in> \\<^bold>V\\<rbrakk>\n   \\<Longrightarrow> ?thesis;\n   x \\<notin> \\<^bold>V \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (x \\<in> TER (current_of_bipartite f)) =\n    (x \\<in> separating_of_bipartite\n              (TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f))", "proof cases"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<lbrakk>x \\<in> A \\<Gamma>; x \\<in> \\<^bold>V\\<rbrakk>\n    \\<Longrightarrow> (x \\<in> TER (current_of_bipartite f)) =\n                      (x \\<in> separating_of_bipartite\n                                (TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub>\n                                  f))\n 2. \\<lbrakk>x \\<in> B \\<Gamma>; x \\<in> \\<^bold>V\\<rbrakk>\n    \\<Longrightarrow> (x \\<in> TER (current_of_bipartite f)) =\n                      (x \\<in> separating_of_bipartite\n                                (TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub>\n                                  f))\n 3. \\<lbrakk>x \\<notin> A \\<Gamma>; x \\<notin> B \\<Gamma>;\n     x \\<in> \\<^bold>V\\<rbrakk>\n    \\<Longrightarrow> (x \\<in> TER (current_of_bipartite f)) =\n                      (x \\<in> separating_of_bipartite\n                                (TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub>\n                                  f))\n 4. x \\<notin> \\<^bold>V \\<Longrightarrow>\n    (x \\<in> TER (current_of_bipartite f)) =\n    (x \\<in> separating_of_bipartite\n              (TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f))", "case A"], ["proof (state)\nthis:\n  x \\<in> A \\<Gamma>\n  x \\<in> \\<^bold>V\n\ngoal (4 subgoals):\n 1. \\<lbrakk>x \\<in> A \\<Gamma>; x \\<in> \\<^bold>V\\<rbrakk>\n    \\<Longrightarrow> (x \\<in> TER (current_of_bipartite f)) =\n                      (x \\<in> separating_of_bipartite\n                                (TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub>\n                                  f))\n 2. \\<lbrakk>x \\<in> B \\<Gamma>; x \\<in> \\<^bold>V\\<rbrakk>\n    \\<Longrightarrow> (x \\<in> TER (current_of_bipartite f)) =\n                      (x \\<in> separating_of_bipartite\n                                (TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub>\n                                  f))\n 3. \\<lbrakk>x \\<notin> A \\<Gamma>; x \\<notin> B \\<Gamma>;\n     x \\<in> \\<^bold>V\\<rbrakk>\n    \\<Longrightarrow> (x \\<in> TER (current_of_bipartite f)) =\n                      (x \\<in> separating_of_bipartite\n                                (TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub>\n                                  f))\n 4. x \\<notin> \\<^bold>V \\<Longrightarrow>\n    (x \\<in> TER (current_of_bipartite f)) =\n    (x \\<in> separating_of_bipartite\n              (TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f))", "hence \"d_OUT ?f x = d_OUT f (Inl x)\""], ["proof (prove)\nusing this:\n  x \\<in> A \\<Gamma>\n  x \\<in> \\<^bold>V\n\ngoal (1 subgoal):\n 1. d_OUT (current_of_bipartite f) x = d_OUT f (Inl x)", "using currentD_outside[OF f, of \"Inl x\" \"Inr x\"]"], ["proof (prove)\nusing this:\n  x \\<in> A \\<Gamma>\n  x \\<in> \\<^bold>V\n  \\<not> edge (bipartite_web_of \\<Gamma>) (Inl x) (Inr x) \\<Longrightarrow>\n  f (Inl x, Inr x) = 0\n\ngoal (1 subgoal):\n 1. d_OUT (current_of_bipartite f) x = d_OUT f (Inl x)", "by(simp add: d_OUT_current_of_bipartite[OF f] no_loop)"], ["proof (state)\nthis:\n  d_OUT (current_of_bipartite f) x = d_OUT f (Inl x)\n\ngoal (4 subgoals):\n 1. \\<lbrakk>x \\<in> A \\<Gamma>; x \\<in> \\<^bold>V\\<rbrakk>\n    \\<Longrightarrow> (x \\<in> TER (current_of_bipartite f)) =\n                      (x \\<in> separating_of_bipartite\n                                (TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub>\n                                  f))\n 2. \\<lbrakk>x \\<in> B \\<Gamma>; x \\<in> \\<^bold>V\\<rbrakk>\n    \\<Longrightarrow> (x \\<in> TER (current_of_bipartite f)) =\n                      (x \\<in> separating_of_bipartite\n                                (TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub>\n                                  f))\n 3. \\<lbrakk>x \\<notin> A \\<Gamma>; x \\<notin> B \\<Gamma>;\n     x \\<in> \\<^bold>V\\<rbrakk>\n    \\<Longrightarrow> (x \\<in> TER (current_of_bipartite f)) =\n                      (x \\<in> separating_of_bipartite\n                                (TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub>\n                                  f))\n 4. x \\<notin> \\<^bold>V \\<Longrightarrow>\n    (x \\<in> TER (current_of_bipartite f)) =\n    (x \\<in> separating_of_bipartite\n              (TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f))", "thus ?thesis"], ["proof (prove)\nusing this:\n  d_OUT (current_of_bipartite f) x = d_OUT f (Inl x)\n\ngoal (1 subgoal):\n 1. (x \\<in> TER (current_of_bipartite f)) =\n    (x \\<in> separating_of_bipartite\n              (TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f))", "using A disjoint"], ["proof (prove)\nusing this:\n  d_OUT (current_of_bipartite f) x = d_OUT f (Inl x)\n  x \\<in> A \\<Gamma>\n  x \\<in> \\<^bold>V\n  A \\<Gamma> \\<inter> B \\<Gamma> = {}\n\ngoal (1 subgoal):\n 1. (x \\<in> TER (current_of_bipartite f)) =\n    (x \\<in> separating_of_bipartite\n              (TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f))", "by(auto simp add: separating_of_bipartite_def Let_def SINK.simps intro!: SAT.A imageI)"], ["proof (state)\nthis:\n  (x \\<in> TER (current_of_bipartite f)) =\n  (x \\<in> separating_of_bipartite\n            (TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f))\n\ngoal (3 subgoals):\n 1. \\<lbrakk>x \\<in> B \\<Gamma>; x \\<in> \\<^bold>V\\<rbrakk>\n    \\<Longrightarrow> (x \\<in> TER (current_of_bipartite f)) =\n                      (x \\<in> separating_of_bipartite\n                                (TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub>\n                                  f))\n 2. \\<lbrakk>x \\<notin> A \\<Gamma>; x \\<notin> B \\<Gamma>;\n     x \\<in> \\<^bold>V\\<rbrakk>\n    \\<Longrightarrow> (x \\<in> TER (current_of_bipartite f)) =\n                      (x \\<in> separating_of_bipartite\n                                (TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub>\n                                  f))\n 3. x \\<notin> \\<^bold>V \\<Longrightarrow>\n    (x \\<in> TER (current_of_bipartite f)) =\n    (x \\<in> separating_of_bipartite\n              (TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f))", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>x \\<in> B \\<Gamma>; x \\<in> \\<^bold>V\\<rbrakk>\n    \\<Longrightarrow> (x \\<in> TER (current_of_bipartite f)) =\n                      (x \\<in> separating_of_bipartite\n                                (TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub>\n                                  f))\n 2. \\<lbrakk>x \\<notin> A \\<Gamma>; x \\<notin> B \\<Gamma>;\n     x \\<in> \\<^bold>V\\<rbrakk>\n    \\<Longrightarrow> (x \\<in> TER (current_of_bipartite f)) =\n                      (x \\<in> separating_of_bipartite\n                                (TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub>\n                                  f))\n 3. x \\<notin> \\<^bold>V \\<Longrightarrow>\n    (x \\<in> TER (current_of_bipartite f)) =\n    (x \\<in> separating_of_bipartite\n              (TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f))", "case B"], ["proof (state)\nthis:\n  x \\<in> B \\<Gamma>\n  x \\<in> \\<^bold>V\n\ngoal (3 subgoals):\n 1. \\<lbrakk>x \\<in> B \\<Gamma>; x \\<in> \\<^bold>V\\<rbrakk>\n    \\<Longrightarrow> (x \\<in> TER (current_of_bipartite f)) =\n                      (x \\<in> separating_of_bipartite\n                                (TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub>\n                                  f))\n 2. \\<lbrakk>x \\<notin> A \\<Gamma>; x \\<notin> B \\<Gamma>;\n     x \\<in> \\<^bold>V\\<rbrakk>\n    \\<Longrightarrow> (x \\<in> TER (current_of_bipartite f)) =\n                      (x \\<in> separating_of_bipartite\n                                (TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub>\n                                  f))\n 3. x \\<notin> \\<^bold>V \\<Longrightarrow>\n    (x \\<in> TER (current_of_bipartite f)) =\n    (x \\<in> separating_of_bipartite\n              (TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f))", "then"], ["proof (chain)\npicking this:\n  x \\<in> B \\<Gamma>\n  x \\<in> \\<^bold>V", "have \"d_IN ?f x = d_IN f (Inr x)\""], ["proof (prove)\nusing this:\n  x \\<in> B \\<Gamma>\n  x \\<in> \\<^bold>V\n\ngoal (1 subgoal):\n 1. d_IN (current_of_bipartite f) x = d_IN f (Inr x)", "using currentD_outside[OF f, of \"Inl x\" \"Inr x\"]"], ["proof (prove)\nusing this:\n  x \\<in> B \\<Gamma>\n  x \\<in> \\<^bold>V\n  \\<not> edge (bipartite_web_of \\<Gamma>) (Inl x) (Inr x) \\<Longrightarrow>\n  f (Inl x, Inr x) = 0\n\ngoal (1 subgoal):\n 1. d_IN (current_of_bipartite f) x = d_IN f (Inr x)", "by(simp add: d_IN_current_of_bipartite[OF f] no_loop)"], ["proof (state)\nthis:\n  d_IN (current_of_bipartite f) x = d_IN f (Inr x)\n\ngoal (3 subgoals):\n 1. \\<lbrakk>x \\<in> B \\<Gamma>; x \\<in> \\<^bold>V\\<rbrakk>\n    \\<Longrightarrow> (x \\<in> TER (current_of_bipartite f)) =\n                      (x \\<in> separating_of_bipartite\n                                (TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub>\n                                  f))\n 2. \\<lbrakk>x \\<notin> A \\<Gamma>; x \\<notin> B \\<Gamma>;\n     x \\<in> \\<^bold>V\\<rbrakk>\n    \\<Longrightarrow> (x \\<in> TER (current_of_bipartite f)) =\n                      (x \\<in> separating_of_bipartite\n                                (TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub>\n                                  f))\n 3. x \\<notin> \\<^bold>V \\<Longrightarrow>\n    (x \\<in> TER (current_of_bipartite f)) =\n    (x \\<in> separating_of_bipartite\n              (TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f))", "moreover"], ["proof (state)\nthis:\n  d_IN (current_of_bipartite f) x = d_IN f (Inr x)\n\ngoal (3 subgoals):\n 1. \\<lbrakk>x \\<in> B \\<Gamma>; x \\<in> \\<^bold>V\\<rbrakk>\n    \\<Longrightarrow> (x \\<in> TER (current_of_bipartite f)) =\n                      (x \\<in> separating_of_bipartite\n                                (TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub>\n                                  f))\n 2. \\<lbrakk>x \\<notin> A \\<Gamma>; x \\<notin> B \\<Gamma>;\n     x \\<in> \\<^bold>V\\<rbrakk>\n    \\<Longrightarrow> (x \\<in> TER (current_of_bipartite f)) =\n                      (x \\<in> separating_of_bipartite\n                                (TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub>\n                                  f))\n 3. x \\<notin> \\<^bold>V \\<Longrightarrow>\n    (x \\<in> TER (current_of_bipartite f)) =\n    (x \\<in> separating_of_bipartite\n              (TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f))", "have \"d_OUT ?f x = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT (current_of_bipartite f) x = 0", "using B currentD_outside[OF f, of \"Inl x\" \"Inr x\"]"], ["proof (prove)\nusing this:\n  x \\<in> B \\<Gamma>\n  x \\<in> \\<^bold>V\n  \\<not> edge (bipartite_web_of \\<Gamma>) (Inl x) (Inr x) \\<Longrightarrow>\n  f (Inl x, Inr x) = 0\n\ngoal (1 subgoal):\n 1. d_OUT (current_of_bipartite f) x = 0", "by(simp add: d_OUT_current_of_bipartite[OF f] no_loop)(auto simp add: d_OUT_def nn_integral_0_iff emeasure_count_space_eq_0 intro!: currentD_outside[OF f] elim!: edge_bipartite_webE dest: B_out)"], ["proof (state)\nthis:\n  d_OUT (current_of_bipartite f) x = 0\n\ngoal (3 subgoals):\n 1. \\<lbrakk>x \\<in> B \\<Gamma>; x \\<in> \\<^bold>V\\<rbrakk>\n    \\<Longrightarrow> (x \\<in> TER (current_of_bipartite f)) =\n                      (x \\<in> separating_of_bipartite\n                                (TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub>\n                                  f))\n 2. \\<lbrakk>x \\<notin> A \\<Gamma>; x \\<notin> B \\<Gamma>;\n     x \\<in> \\<^bold>V\\<rbrakk>\n    \\<Longrightarrow> (x \\<in> TER (current_of_bipartite f)) =\n                      (x \\<in> separating_of_bipartite\n                                (TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub>\n                                  f))\n 3. x \\<notin> \\<^bold>V \\<Longrightarrow>\n    (x \\<in> TER (current_of_bipartite f)) =\n    (x \\<in> separating_of_bipartite\n              (TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f))", "moreover"], ["proof (state)\nthis:\n  d_OUT (current_of_bipartite f) x = 0\n\ngoal (3 subgoals):\n 1. \\<lbrakk>x \\<in> B \\<Gamma>; x \\<in> \\<^bold>V\\<rbrakk>\n    \\<Longrightarrow> (x \\<in> TER (current_of_bipartite f)) =\n                      (x \\<in> separating_of_bipartite\n                                (TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub>\n                                  f))\n 2. \\<lbrakk>x \\<notin> A \\<Gamma>; x \\<notin> B \\<Gamma>;\n     x \\<in> \\<^bold>V\\<rbrakk>\n    \\<Longrightarrow> (x \\<in> TER (current_of_bipartite f)) =\n                      (x \\<in> separating_of_bipartite\n                                (TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub>\n                                  f))\n 3. x \\<notin> \\<^bold>V \\<Longrightarrow>\n    (x \\<in> TER (current_of_bipartite f)) =\n    (x \\<in> separating_of_bipartite\n              (TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f))", "have \"d_OUT f (Inr x) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT f (Inr x) = 0", "using B disjoint"], ["proof (prove)\nusing this:\n  x \\<in> B \\<Gamma>\n  x \\<in> \\<^bold>V\n  A \\<Gamma> \\<inter> B \\<Gamma> = {}\n\ngoal (1 subgoal):\n 1. d_OUT f (Inr x) = 0", "by(intro currentD_OUT[OF f]) auto"], ["proof (state)\nthis:\n  d_OUT f (Inr x) = 0\n\ngoal (3 subgoals):\n 1. \\<lbrakk>x \\<in> B \\<Gamma>; x \\<in> \\<^bold>V\\<rbrakk>\n    \\<Longrightarrow> (x \\<in> TER (current_of_bipartite f)) =\n                      (x \\<in> separating_of_bipartite\n                                (TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub>\n                                  f))\n 2. \\<lbrakk>x \\<notin> A \\<Gamma>; x \\<notin> B \\<Gamma>;\n     x \\<in> \\<^bold>V\\<rbrakk>\n    \\<Longrightarrow> (x \\<in> TER (current_of_bipartite f)) =\n                      (x \\<in> separating_of_bipartite\n                                (TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub>\n                                  f))\n 3. x \\<notin> \\<^bold>V \\<Longrightarrow>\n    (x \\<in> TER (current_of_bipartite f)) =\n    (x \\<in> separating_of_bipartite\n              (TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f))", "ultimately"], ["proof (chain)\npicking this:\n  d_IN (current_of_bipartite f) x = d_IN f (Inr x)\n  d_OUT (current_of_bipartite f) x = 0\n  d_OUT f (Inr x) = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  d_IN (current_of_bipartite f) x = d_IN f (Inr x)\n  d_OUT (current_of_bipartite f) x = 0\n  d_OUT f (Inr x) = 0\n\ngoal (1 subgoal):\n 1. (x \\<in> TER (current_of_bipartite f)) =\n    (x \\<in> separating_of_bipartite\n              (TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f))", "using B"], ["proof (prove)\nusing this:\n  d_IN (current_of_bipartite f) x = d_IN f (Inr x)\n  d_OUT (current_of_bipartite f) x = 0\n  d_OUT f (Inr x) = 0\n  x \\<in> B \\<Gamma>\n  x \\<in> \\<^bold>V\n\ngoal (1 subgoal):\n 1. (x \\<in> TER (current_of_bipartite f)) =\n    (x \\<in> separating_of_bipartite\n              (TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f))", "by(auto simp add: separating_of_bipartite_def Let_def SINK.simps SAT.simps)"], ["proof (state)\nthis:\n  (x \\<in> TER (current_of_bipartite f)) =\n  (x \\<in> separating_of_bipartite\n            (TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<notin> A \\<Gamma>; x \\<notin> B \\<Gamma>;\n     x \\<in> \\<^bold>V\\<rbrakk>\n    \\<Longrightarrow> (x \\<in> TER (current_of_bipartite f)) =\n                      (x \\<in> separating_of_bipartite\n                                (TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub>\n                                  f))\n 2. x \\<notin> \\<^bold>V \\<Longrightarrow>\n    (x \\<in> TER (current_of_bipartite f)) =\n    (x \\<in> separating_of_bipartite\n              (TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<notin> A \\<Gamma>; x \\<notin> B \\<Gamma>;\n     x \\<in> \\<^bold>V\\<rbrakk>\n    \\<Longrightarrow> (x \\<in> TER (current_of_bipartite f)) =\n                      (x \\<in> separating_of_bipartite\n                                (TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub>\n                                  f))\n 2. x \\<notin> \\<^bold>V \\<Longrightarrow>\n    (x \\<in> TER (current_of_bipartite f)) =\n    (x \\<in> separating_of_bipartite\n              (TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f))", "case outside"], ["proof (state)\nthis:\n  x \\<notin> \\<^bold>V\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<notin> A \\<Gamma>; x \\<notin> B \\<Gamma>;\n     x \\<in> \\<^bold>V\\<rbrakk>\n    \\<Longrightarrow> (x \\<in> TER (current_of_bipartite f)) =\n                      (x \\<in> separating_of_bipartite\n                                (TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub>\n                                  f))\n 2. x \\<notin> \\<^bold>V \\<Longrightarrow>\n    (x \\<in> TER (current_of_bipartite f)) =\n    (x \\<in> separating_of_bipartite\n              (TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f))", "with current_current_of_bipartite[OF f w]"], ["proof (chain)\npicking this:\n  current \\<Gamma> (current_of_bipartite f)\n  x \\<notin> \\<^bold>V", "have \"d_OUT ?f x = 0\" \"d_IN ?f x = 0\""], ["proof (prove)\nusing this:\n  current \\<Gamma> (current_of_bipartite f)\n  x \\<notin> \\<^bold>V\n\ngoal (1 subgoal):\n 1. d_OUT (current_of_bipartite f) x = 0 &&&\n    d_IN (current_of_bipartite f) x = 0", "by(rule currentD_outside_OUT currentD_outside_IN)+"], ["proof (state)\nthis:\n  d_OUT (current_of_bipartite f) x = 0\n  d_IN (current_of_bipartite f) x = 0\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<notin> A \\<Gamma>; x \\<notin> B \\<Gamma>;\n     x \\<in> \\<^bold>V\\<rbrakk>\n    \\<Longrightarrow> (x \\<in> TER (current_of_bipartite f)) =\n                      (x \\<in> separating_of_bipartite\n                                (TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub>\n                                  f))\n 2. x \\<notin> \\<^bold>V \\<Longrightarrow>\n    (x \\<in> TER (current_of_bipartite f)) =\n    (x \\<in> separating_of_bipartite\n              (TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f))", "moreover"], ["proof (state)\nthis:\n  d_OUT (current_of_bipartite f) x = 0\n  d_IN (current_of_bipartite f) x = 0\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<notin> A \\<Gamma>; x \\<notin> B \\<Gamma>;\n     x \\<in> \\<^bold>V\\<rbrakk>\n    \\<Longrightarrow> (x \\<in> TER (current_of_bipartite f)) =\n                      (x \\<in> separating_of_bipartite\n                                (TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub>\n                                  f))\n 2. x \\<notin> \\<^bold>V \\<Longrightarrow>\n    (x \\<in> TER (current_of_bipartite f)) =\n    (x \\<in> separating_of_bipartite\n              (TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f))", "from outside"], ["proof (chain)\npicking this:\n  x \\<notin> \\<^bold>V", "have \"Inl x \\<notin> vertices ?\\<Gamma>\" \"Inr x \\<notin> vertices ?\\<Gamma>\""], ["proof (prove)\nusing this:\n  x \\<notin> \\<^bold>V\n\ngoal (1 subgoal):\n 1. Inl x \\<notin> \\<^bold>V\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> &&&\n    Inr x \\<notin> \\<^bold>V\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub>", "by auto"], ["proof (state)\nthis:\n  Inl x \\<notin> \\<^bold>V\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub>\n  Inr x \\<notin> \\<^bold>V\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub>\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<notin> A \\<Gamma>; x \\<notin> B \\<Gamma>;\n     x \\<in> \\<^bold>V\\<rbrakk>\n    \\<Longrightarrow> (x \\<in> TER (current_of_bipartite f)) =\n                      (x \\<in> separating_of_bipartite\n                                (TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub>\n                                  f))\n 2. x \\<notin> \\<^bold>V \\<Longrightarrow>\n    (x \\<in> TER (current_of_bipartite f)) =\n    (x \\<in> separating_of_bipartite\n              (TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f))", "hence \"d_OUT f (Inl x) = 0\" \"d_IN f (Inl x) = 0\" \"d_OUT f (Inr x) = 0\" \"d_IN f (Inr x) = 0\""], ["proof (prove)\nusing this:\n  Inl x \\<notin> \\<^bold>V\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub>\n  Inr x \\<notin> \\<^bold>V\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub>\n\ngoal (1 subgoal):\n 1. (d_OUT f (Inl x) = 0 &&& d_IN f (Inl x) = 0) &&&\n    d_OUT f (Inr x) = 0 &&& d_IN f (Inr x) = 0", "by(blast intro: currentD_outside_OUT[OF f] currentD_outside_IN[OF f])+"], ["proof (state)\nthis:\n  d_OUT f (Inl x) = 0\n  d_IN f (Inl x) = 0\n  d_OUT f (Inr x) = 0\n  d_IN f (Inr x) = 0\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<notin> A \\<Gamma>; x \\<notin> B \\<Gamma>;\n     x \\<in> \\<^bold>V\\<rbrakk>\n    \\<Longrightarrow> (x \\<in> TER (current_of_bipartite f)) =\n                      (x \\<in> separating_of_bipartite\n                                (TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub>\n                                  f))\n 2. x \\<notin> \\<^bold>V \\<Longrightarrow>\n    (x \\<in> TER (current_of_bipartite f)) =\n    (x \\<in> separating_of_bipartite\n              (TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f))", "ultimately"], ["proof (chain)\npicking this:\n  d_OUT (current_of_bipartite f) x = 0\n  d_IN (current_of_bipartite f) x = 0\n  d_OUT f (Inl x) = 0\n  d_IN f (Inl x) = 0\n  d_OUT f (Inr x) = 0\n  d_IN f (Inr x) = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  d_OUT (current_of_bipartite f) x = 0\n  d_IN (current_of_bipartite f) x = 0\n  d_OUT f (Inl x) = 0\n  d_IN f (Inl x) = 0\n  d_OUT f (Inr x) = 0\n  d_IN f (Inr x) = 0\n\ngoal (1 subgoal):\n 1. (x \\<in> TER (current_of_bipartite f)) =\n    (x \\<in> separating_of_bipartite\n              (TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f))", "using outside weight_outside[of x]"], ["proof (prove)\nusing this:\n  d_OUT (current_of_bipartite f) x = 0\n  d_IN (current_of_bipartite f) x = 0\n  d_OUT f (Inl x) = 0\n  d_IN f (Inl x) = 0\n  d_OUT f (Inr x) = 0\n  d_IN f (Inr x) = 0\n  x \\<notin> \\<^bold>V\n  x \\<notin> \\<^bold>V \\<Longrightarrow> weight \\<Gamma> x = 0\n\ngoal (1 subgoal):\n 1. (x \\<in> TER (current_of_bipartite f)) =\n    (x \\<in> separating_of_bipartite\n              (TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f))", "by(auto simp add: separating_of_bipartite_def Let_def SINK.simps SAT.simps not_le)"], ["proof (state)\nthis:\n  (x \\<in> TER (current_of_bipartite f)) =\n  (x \\<in> separating_of_bipartite\n            (TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<notin> A \\<Gamma>; x \\<notin> B \\<Gamma>;\n     x \\<in> \\<^bold>V\\<rbrakk>\n    \\<Longrightarrow> (x \\<in> TER (current_of_bipartite f)) =\n                      (x \\<in> separating_of_bipartite\n                                (TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub>\n                                  f))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<notin> A \\<Gamma>; x \\<notin> B \\<Gamma>;\n     x \\<in> \\<^bold>V\\<rbrakk>\n    \\<Longrightarrow> (x \\<in> TER (current_of_bipartite f)) =\n                      (x \\<in> separating_of_bipartite\n                                (TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub>\n                                  f))", "case inner"], ["proof (state)\nthis:\n  x \\<notin> A \\<Gamma>\n  x \\<notin> B \\<Gamma>\n  x \\<in> \\<^bold>V\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<notin> A \\<Gamma>; x \\<notin> B \\<Gamma>;\n     x \\<in> \\<^bold>V\\<rbrakk>\n    \\<Longrightarrow> (x \\<in> TER (current_of_bipartite f)) =\n                      (x \\<in> separating_of_bipartite\n                                (TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub>\n                                  f))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<in> TER (current_of_bipartite f)) =\n    (x \\<in> separating_of_bipartite\n              (TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<in> TER (current_of_bipartite f) \\<Longrightarrow>\n    x \\<in> separating_of_bipartite\n             (TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f)\n 2. x \\<in> separating_of_bipartite\n             (TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub>\n               f) \\<Longrightarrow>\n    x \\<in> TER (current_of_bipartite f)", "assume \"x \\<in> separating_of_bipartite ?TER\""], ["proof (state)\nthis:\n  x \\<in> separating_of_bipartite\n           (TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f)\n\ngoal (2 subgoals):\n 1. x \\<in> TER (current_of_bipartite f) \\<Longrightarrow>\n    x \\<in> separating_of_bipartite\n             (TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f)\n 2. x \\<in> separating_of_bipartite\n             (TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub>\n               f) \\<Longrightarrow>\n    x \\<in> TER (current_of_bipartite f)", "with inner"], ["proof (chain)\npicking this:\n  x \\<notin> A \\<Gamma>\n  x \\<notin> B \\<Gamma>\n  x \\<in> \\<^bold>V\n  x \\<in> separating_of_bipartite\n           (TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f)", "have l: \"Inl x \\<in> ?TER\" and r: \"Inr x \\<in> ?TER\""], ["proof (prove)\nusing this:\n  x \\<notin> A \\<Gamma>\n  x \\<notin> B \\<Gamma>\n  x \\<in> \\<^bold>V\n  x \\<in> separating_of_bipartite\n           (TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f)\n\ngoal (1 subgoal):\n 1. Inl x \\<in> TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f &&&\n    Inr x \\<in> TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f", "by(auto simp add: separating_of_bipartite_def Let_def)"], ["proof (state)\nthis:\n  Inl x \\<in> TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f\n  Inr x \\<in> TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f\n\ngoal (2 subgoals):\n 1. x \\<in> TER (current_of_bipartite f) \\<Longrightarrow>\n    x \\<in> separating_of_bipartite\n             (TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f)\n 2. x \\<in> separating_of_bipartite\n             (TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub>\n               f) \\<Longrightarrow>\n    x \\<in> TER (current_of_bipartite f)", "have \"f (Inl x, Inr x) \\<le> d_OUT f (Inl x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f (Inl x, Inr x) \\<le> d_OUT f (Inl x)", "unfolding d_OUT_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. f (Inl x, Inr x) \\<le> (\\<Sum>\\<^sup>+ y. f (Inl x, y))", "by(rule nn_integral_ge_point) simp"], ["proof (state)\nthis:\n  f (Inl x, Inr x) \\<le> d_OUT f (Inl x)\n\ngoal (2 subgoals):\n 1. x \\<in> TER (current_of_bipartite f) \\<Longrightarrow>\n    x \\<in> separating_of_bipartite\n             (TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f)\n 2. x \\<in> separating_of_bipartite\n             (TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub>\n               f) \\<Longrightarrow>\n    x \\<in> TER (current_of_bipartite f)", "with l"], ["proof (chain)\npicking this:\n  Inl x \\<in> TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f\n  f (Inl x, Inr x) \\<le> d_OUT f (Inl x)", "have 0: \"f (Inl x, Inr x) = 0\""], ["proof (prove)\nusing this:\n  Inl x \\<in> TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f\n  f (Inl x, Inr x) \\<le> d_OUT f (Inl x)\n\ngoal (1 subgoal):\n 1. f (Inl x, Inr x) = 0", "by(auto simp add: SINK.simps)"], ["proof (state)\nthis:\n  f (Inl x, Inr x) = 0\n\ngoal (2 subgoals):\n 1. x \\<in> TER (current_of_bipartite f) \\<Longrightarrow>\n    x \\<in> separating_of_bipartite\n             (TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f)\n 2. x \\<in> separating_of_bipartite\n             (TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub>\n               f) \\<Longrightarrow>\n    x \\<in> TER (current_of_bipartite f)", "with l"], ["proof (chain)\npicking this:\n  Inl x \\<in> TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f\n  f (Inl x, Inr x) = 0", "have \"x \\<in> SINK ?f\""], ["proof (prove)\nusing this:\n  Inl x \\<in> TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f\n  f (Inl x, Inr x) = 0\n\ngoal (1 subgoal):\n 1. x \\<in> SINK (current_of_bipartite f)", "by(simp add: SINK.simps d_OUT_current_of_bipartite[OF f])"], ["proof (state)\nthis:\n  x \\<in> SINK (current_of_bipartite f)\n\ngoal (2 subgoals):\n 1. x \\<in> TER (current_of_bipartite f) \\<Longrightarrow>\n    x \\<in> separating_of_bipartite\n             (TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f)\n 2. x \\<in> separating_of_bipartite\n             (TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub>\n               f) \\<Longrightarrow>\n    x \\<in> TER (current_of_bipartite f)", "moreover"], ["proof (state)\nthis:\n  x \\<in> SINK (current_of_bipartite f)\n\ngoal (2 subgoals):\n 1. x \\<in> TER (current_of_bipartite f) \\<Longrightarrow>\n    x \\<in> separating_of_bipartite\n             (TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f)\n 2. x \\<in> separating_of_bipartite\n             (TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub>\n               f) \\<Longrightarrow>\n    x \\<in> TER (current_of_bipartite f)", "from r"], ["proof (chain)\npicking this:\n  Inr x \\<in> TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f", "have \"Inr x \\<in> SAT ?\\<Gamma> f\""], ["proof (prove)\nusing this:\n  Inr x \\<in> TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f\n\ngoal (1 subgoal):\n 1. Inr x \\<in> SAT (bipartite_web_of \\<Gamma>) f", "by auto"], ["proof (state)\nthis:\n  Inr x \\<in> SAT (bipartite_web_of \\<Gamma>) f\n\ngoal (2 subgoals):\n 1. x \\<in> TER (current_of_bipartite f) \\<Longrightarrow>\n    x \\<in> separating_of_bipartite\n             (TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f)\n 2. x \\<in> separating_of_bipartite\n             (TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub>\n               f) \\<Longrightarrow>\n    x \\<in> TER (current_of_bipartite f)", "with inner"], ["proof (chain)\npicking this:\n  x \\<notin> A \\<Gamma>\n  x \\<notin> B \\<Gamma>\n  x \\<in> \\<^bold>V\n  Inr x \\<in> SAT (bipartite_web_of \\<Gamma>) f", "have \"x \\<in> SAT \\<Gamma> ?f\""], ["proof (prove)\nusing this:\n  x \\<notin> A \\<Gamma>\n  x \\<notin> B \\<Gamma>\n  x \\<in> \\<^bold>V\n  Inr x \\<in> SAT (bipartite_web_of \\<Gamma>) f\n\ngoal (1 subgoal):\n 1. x \\<in> SAT \\<Gamma> (current_of_bipartite f)", "by(auto elim!: SAT.cases intro!: SAT.IN simp add: 0 d_IN_current_of_bipartite[OF f])"], ["proof (state)\nthis:\n  x \\<in> SAT \\<Gamma> (current_of_bipartite f)\n\ngoal (2 subgoals):\n 1. x \\<in> TER (current_of_bipartite f) \\<Longrightarrow>\n    x \\<in> separating_of_bipartite\n             (TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f)\n 2. x \\<in> separating_of_bipartite\n             (TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub>\n               f) \\<Longrightarrow>\n    x \\<in> TER (current_of_bipartite f)", "ultimately"], ["proof (chain)\npicking this:\n  x \\<in> SINK (current_of_bipartite f)\n  x \\<in> SAT \\<Gamma> (current_of_bipartite f)", "show \"x \\<in> TER ?f\""], ["proof (prove)\nusing this:\n  x \\<in> SINK (current_of_bipartite f)\n  x \\<in> SAT \\<Gamma> (current_of_bipartite f)\n\ngoal (1 subgoal):\n 1. x \\<in> TER (current_of_bipartite f)", "by simp"], ["proof (state)\nthis:\n  x \\<in> TER (current_of_bipartite f)\n\ngoal (1 subgoal):\n 1. x \\<in> TER (current_of_bipartite f) \\<Longrightarrow>\n    x \\<in> separating_of_bipartite\n             (TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<in> TER (current_of_bipartite f) \\<Longrightarrow>\n    x \\<in> separating_of_bipartite\n             (TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f)", "assume *: \"x \\<in> TER ?f\""], ["proof (state)\nthis:\n  x \\<in> TER (current_of_bipartite f)\n\ngoal (1 subgoal):\n 1. x \\<in> TER (current_of_bipartite f) \\<Longrightarrow>\n    x \\<in> separating_of_bipartite\n             (TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f)", "have \"d_IN f (Inr x) \\<le> weight ?\\<Gamma> (Inr x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN f (Inr x) \\<le> weight (bipartite_web_of \\<Gamma>) (Inr x)", "using f"], ["proof (prove)\nusing this:\n  current (bipartite_web_of \\<Gamma>) f\n\ngoal (1 subgoal):\n 1. d_IN f (Inr x) \\<le> weight (bipartite_web_of \\<Gamma>) (Inr x)", "by(rule currentD_weight_IN)"], ["proof (state)\nthis:\n  d_IN f (Inr x) \\<le> weight (bipartite_web_of \\<Gamma>) (Inr x)\n\ngoal (1 subgoal):\n 1. x \\<in> TER (current_of_bipartite f) \\<Longrightarrow>\n    x \\<in> separating_of_bipartite\n             (TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f)", "also"], ["proof (state)\nthis:\n  d_IN f (Inr x) \\<le> weight (bipartite_web_of \\<Gamma>) (Inr x)\n\ngoal (1 subgoal):\n 1. x \\<in> TER (current_of_bipartite f) \\<Longrightarrow>\n    x \\<in> separating_of_bipartite\n             (TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f)", "have \"\\<dots> \\<le> weight \\<Gamma> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. weight (bipartite_web_of \\<Gamma>) (Inr x) \\<le> weight \\<Gamma> x", "using inner"], ["proof (prove)\nusing this:\n  x \\<notin> A \\<Gamma>\n  x \\<notin> B \\<Gamma>\n  x \\<in> \\<^bold>V\n\ngoal (1 subgoal):\n 1. weight (bipartite_web_of \\<Gamma>) (Inr x) \\<le> weight \\<Gamma> x", "by simp"], ["proof (state)\nthis:\n  weight (bipartite_web_of \\<Gamma>) (Inr x) \\<le> weight \\<Gamma> x\n\ngoal (1 subgoal):\n 1. x \\<in> TER (current_of_bipartite f) \\<Longrightarrow>\n    x \\<in> separating_of_bipartite\n             (TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f)", "also"], ["proof (state)\nthis:\n  weight (bipartite_web_of \\<Gamma>) (Inr x) \\<le> weight \\<Gamma> x\n\ngoal (1 subgoal):\n 1. x \\<in> TER (current_of_bipartite f) \\<Longrightarrow>\n    x \\<in> separating_of_bipartite\n             (TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f)", "have \"\\<dots> \\<le> d_IN ?f x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. weight \\<Gamma> x \\<le> d_IN (current_of_bipartite f) x", "using inner *"], ["proof (prove)\nusing this:\n  x \\<notin> A \\<Gamma>\n  x \\<notin> B \\<Gamma>\n  x \\<in> \\<^bold>V\n  x \\<in> TER (current_of_bipartite f)\n\ngoal (1 subgoal):\n 1. weight \\<Gamma> x \\<le> d_IN (current_of_bipartite f) x", "by(auto elim: SAT.cases)"], ["proof (state)\nthis:\n  weight \\<Gamma> x \\<le> d_IN (current_of_bipartite f) x\n\ngoal (1 subgoal):\n 1. x \\<in> TER (current_of_bipartite f) \\<Longrightarrow>\n    x \\<in> separating_of_bipartite\n             (TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f)", "also"], ["proof (state)\nthis:\n  weight \\<Gamma> x \\<le> d_IN (current_of_bipartite f) x\n\ngoal (1 subgoal):\n 1. x \\<in> TER (current_of_bipartite f) \\<Longrightarrow>\n    x \\<in> separating_of_bipartite\n             (TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f)", "have \"\\<dots> \\<le> d_IN f (Inr x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN (current_of_bipartite f) x \\<le> d_IN f (Inr x)", "by(simp add: d_IN_current_of_bipartite[OF f] max_def diff_le_self_ennreal)"], ["proof (state)\nthis:\n  d_IN (current_of_bipartite f) x \\<le> d_IN f (Inr x)\n\ngoal (1 subgoal):\n 1. x \\<in> TER (current_of_bipartite f) \\<Longrightarrow>\n    x \\<in> separating_of_bipartite\n             (TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f)", "ultimately"], ["proof (chain)\npicking this:\n  d_IN f (Inr x) \\<le> d_IN (current_of_bipartite f) x\n  d_IN (current_of_bipartite f) x \\<le> d_IN f (Inr x)", "have eq: \"d_IN ?f x = d_IN f (Inr x)\""], ["proof (prove)\nusing this:\n  d_IN f (Inr x) \\<le> d_IN (current_of_bipartite f) x\n  d_IN (current_of_bipartite f) x \\<le> d_IN f (Inr x)\n\ngoal (1 subgoal):\n 1. d_IN (current_of_bipartite f) x = d_IN f (Inr x)", "by simp"], ["proof (state)\nthis:\n  d_IN (current_of_bipartite f) x = d_IN f (Inr x)\n\ngoal (1 subgoal):\n 1. x \\<in> TER (current_of_bipartite f) \\<Longrightarrow>\n    x \\<in> separating_of_bipartite\n             (TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f)", "hence 0: \"f (Inl x, Inr x) = 0\""], ["proof (prove)\nusing this:\n  d_IN (current_of_bipartite f) x = d_IN f (Inr x)\n\ngoal (1 subgoal):\n 1. f (Inl x, Inr x) = 0", "using ennreal_minus_cancel_iff[of \"d_IN f (Inr x)\" \"f (Inl x, Inr x)\" 0] currentD_weight_IN[OF f, of \"Inr x\"] inner\n          d_IN_ge_point[of f \"Inl x\" \"Inr x\"]"], ["proof (prove)\nusing this:\n  d_IN (current_of_bipartite f) x = d_IN f (Inr x)\n  (d_IN f (Inr x) - f (Inl x, Inr x) = d_IN f (Inr x) - 0) =\n  (f (Inl x, Inr x) = 0 \\<or>\n   d_IN f (Inr x) \\<le> f (Inl x, Inr x) \\<and> d_IN f (Inr x) \\<le> 0 \\<or>\n   d_IN f (Inr x) = \\<top>)\n  d_IN f (Inr x) \\<le> weight (bipartite_web_of \\<Gamma>) (Inr x)\n  x \\<notin> A \\<Gamma>\n  x \\<notin> B \\<Gamma>\n  x \\<in> \\<^bold>V\n  f (Inl x, Inr x) \\<le> d_IN f (Inr x)\n\ngoal (1 subgoal):\n 1. f (Inl x, Inr x) = 0", "by(auto simp add: d_IN_current_of_bipartite[OF f] top_unique)"], ["proof (state)\nthis:\n  f (Inl x, Inr x) = 0\n\ngoal (1 subgoal):\n 1. x \\<in> TER (current_of_bipartite f) \\<Longrightarrow>\n    x \\<in> separating_of_bipartite\n             (TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f)", "have \"Inl x \\<in> ?TER\" \"Inr x \\<in> ?TER\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Inl x \\<in> TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f &&&\n    Inr x \\<in> TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f", "using inner * currentD_OUT[OF f, of \"Inr x\"]"], ["proof (prove)\nusing this:\n  x \\<notin> A \\<Gamma>\n  x \\<notin> B \\<Gamma>\n  x \\<in> \\<^bold>V\n  x \\<in> TER (current_of_bipartite f)\n  Inr x \\<in> B (bipartite_web_of \\<Gamma>) \\<Longrightarrow>\n  d_OUT f (Inr x) = 0\n\ngoal (1 subgoal):\n 1. Inl x \\<in> TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f &&&\n    Inr x \\<in> TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f", "by(auto simp add: SAT.simps SINK.simps d_OUT_current_of_bipartite[OF f] 0 eq)"], ["proof (state)\nthis:\n  Inl x \\<in> TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f\n  Inr x \\<in> TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f\n\ngoal (1 subgoal):\n 1. x \\<in> TER (current_of_bipartite f) \\<Longrightarrow>\n    x \\<in> separating_of_bipartite\n             (TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f)", "thus \"x \\<in> separating_of_bipartite ?TER\""], ["proof (prove)\nusing this:\n  Inl x \\<in> TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f\n  Inr x \\<in> TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f\n\ngoal (1 subgoal):\n 1. x \\<in> separating_of_bipartite\n             (TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f)", "unfolding separating_of_bipartite_def Let_def"], ["proof (prove)\nusing this:\n  Inl x \\<in> TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f\n  Inr x \\<in> TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f\n\ngoal (1 subgoal):\n 1. x \\<in> Inl -` TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f \\<inter>\n            Inr -` TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f \\<union>\n            A \\<Gamma> \\<inter>\n            Inl -` TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f \\<union>\n            B \\<Gamma> \\<inter>\n            Inr -` TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f", "by blast"], ["proof (state)\nthis:\n  x \\<in> separating_of_bipartite\n           (TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (x \\<in> TER (current_of_bipartite f)) =\n  (x \\<in> separating_of_bipartite\n            (TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (x \\<in> TER (current_of_bipartite f)) =\n  (x \\<in> separating_of_bipartite\n            (TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma wave_current_of_bipartite: \\<comment> \\<open>Lemma 6.3\\<close>\n  assumes f: \"current (bipartite_web_of \\<Gamma>) f\" (is \"current ?\\<Gamma> _\")\n  and w: \"wave (bipartite_web_of \\<Gamma>) f\"\n  shows \"wave \\<Gamma> (current_of_bipartite f)\" (is \"wave _ ?f\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. wave \\<Gamma> (current_of_bipartite f)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. separating \\<Gamma> (TER (current_of_bipartite f))\n 2. \\<And>x.\n       x \\<notin> RF (TER (current_of_bipartite f)) \\<Longrightarrow>\n       d_OUT (current_of_bipartite f) x = 0", "have sep': \"separating \\<Gamma> (separating_of_bipartite (TER\\<^bsub>?\\<Gamma>\\<^esub> f))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. separating \\<Gamma>\n     (separating_of_bipartite\n       (TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f))", "by(rule separating_of_bipartite)(rule waveD_separating[OF w])"], ["proof (state)\nthis:\n  separating \\<Gamma>\n   (separating_of_bipartite\n     (TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f))\n\ngoal (2 subgoals):\n 1. separating \\<Gamma> (TER (current_of_bipartite f))\n 2. \\<And>x.\n       x \\<notin> RF (TER (current_of_bipartite f)) \\<Longrightarrow>\n       d_OUT (current_of_bipartite f) x = 0", "then"], ["proof (chain)\npicking this:\n  separating \\<Gamma>\n   (separating_of_bipartite\n     (TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f))", "show sep: \"separating \\<Gamma> (TER (current_of_bipartite f))\""], ["proof (prove)\nusing this:\n  separating \\<Gamma>\n   (separating_of_bipartite\n     (TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f))\n\ngoal (1 subgoal):\n 1. separating \\<Gamma> (TER (current_of_bipartite f))", "by(simp add: TER_current_of_bipartite[OF f w])"], ["proof (state)\nthis:\n  separating \\<Gamma> (TER (current_of_bipartite f))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<notin> RF (TER (current_of_bipartite f)) \\<Longrightarrow>\n       d_OUT (current_of_bipartite f) x = 0", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<notin> RF (TER (current_of_bipartite f)) \\<Longrightarrow>\n       d_OUT (current_of_bipartite f) x = 0", "assume \"x \\<notin> RF (TER ?f)\""], ["proof (state)\nthis:\n  x \\<notin> RF (TER (current_of_bipartite f))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<notin> RF (TER (current_of_bipartite f)) \\<Longrightarrow>\n       d_OUT (current_of_bipartite f) x = 0", "then"], ["proof (chain)\npicking this:\n  x \\<notin> RF (TER (current_of_bipartite f))", "obtain p y where p: \"path \\<Gamma> x p y\" and y: \"y \\<in> B \\<Gamma>\" and x: \"x \\<notin> TER ?f\"\n    and bypass: \"\\<And>z. z \\<in> set p \\<Longrightarrow> z \\<notin> TER ?f\""], ["proof (prove)\nusing this:\n  x \\<notin> RF (TER (current_of_bipartite f))\n\ngoal (1 subgoal):\n 1. (\\<And>p y.\n        \\<lbrakk>path \\<Gamma> x p y; y \\<in> B \\<Gamma>;\n         x \\<notin> TER (current_of_bipartite f);\n         \\<And>z.\n            z \\<in> set p \\<Longrightarrow>\n            z \\<notin> TER (current_of_bipartite f)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto simp add: roofed_def elim: rtrancl_path_distinct)"], ["proof (state)\nthis:\n  path \\<Gamma> x p y\n  y \\<in> B \\<Gamma>\n  x \\<notin> TER (current_of_bipartite f)\n  ?z \\<in> set p \\<Longrightarrow> ?z \\<notin> TER (current_of_bipartite f)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<notin> RF (TER (current_of_bipartite f)) \\<Longrightarrow>\n       d_OUT (current_of_bipartite f) x = 0", "from p"], ["proof (chain)\npicking this:\n  path \\<Gamma> x p y", "obtain p' where p': \"path \\<Gamma> x p' y\" and distinct: \"distinct (x # p')\"\n    and subset: \"set p' \\<subseteq> set p\""], ["proof (prove)\nusing this:\n  path \\<Gamma> x p y\n\ngoal (1 subgoal):\n 1. (\\<And>p'.\n        \\<lbrakk>path \\<Gamma> x p' y; distinct (x # p');\n         set p' \\<subseteq> set p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto elim: rtrancl_path_distinct)"], ["proof (state)\nthis:\n  path \\<Gamma> x p' y\n  distinct (x # p')\n  set p' \\<subseteq> set p\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<notin> RF (TER (current_of_bipartite f)) \\<Longrightarrow>\n       d_OUT (current_of_bipartite f) x = 0", "consider (outside) \"x \\<notin> \\<^bold>V\" | (A) \"x \\<in> A \\<Gamma>\" | (B) \"x \\<in> B \\<Gamma>\" | (inner) \"x \\<in> \\<^bold>V\" \"x \\<notin> A \\<Gamma>\" \"x \\<notin> B \\<Gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<notin> \\<^bold>V \\<Longrightarrow> thesis;\n     x \\<in> A \\<Gamma> \\<Longrightarrow> thesis;\n     x \\<in> B \\<Gamma> \\<Longrightarrow> thesis;\n     \\<lbrakk>x \\<in> \\<^bold>V; x \\<notin> A \\<Gamma>;\n      x \\<notin> B \\<Gamma>\\<rbrakk>\n     \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>x \\<notin> \\<^bold>V \\<Longrightarrow> ?thesis;\n   x \\<in> A \\<Gamma> \\<Longrightarrow> ?thesis;\n   x \\<in> B \\<Gamma> \\<Longrightarrow> ?thesis;\n   \\<lbrakk>x \\<in> \\<^bold>V; x \\<notin> A \\<Gamma>;\n    x \\<notin> B \\<Gamma>\\<rbrakk>\n   \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<notin> RF (TER (current_of_bipartite f)) \\<Longrightarrow>\n       d_OUT (current_of_bipartite f) x = 0", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>x \\<notin> \\<^bold>V \\<Longrightarrow> ?thesis;\n   x \\<in> A \\<Gamma> \\<Longrightarrow> ?thesis;\n   x \\<in> B \\<Gamma> \\<Longrightarrow> ?thesis;\n   \\<lbrakk>x \\<in> \\<^bold>V; x \\<notin> A \\<Gamma>;\n    x \\<notin> B \\<Gamma>\\<rbrakk>\n   \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis", "show \"d_OUT ?f x = 0\""], ["proof (prove)\nusing this:\n  \\<lbrakk>x \\<notin> \\<^bold>V \\<Longrightarrow> ?thesis;\n   x \\<in> A \\<Gamma> \\<Longrightarrow> ?thesis;\n   x \\<in> B \\<Gamma> \\<Longrightarrow> ?thesis;\n   \\<lbrakk>x \\<in> \\<^bold>V; x \\<notin> A \\<Gamma>;\n    x \\<notin> B \\<Gamma>\\<rbrakk>\n   \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. d_OUT (current_of_bipartite f) x = 0", "proof cases"], ["proof (state)\ngoal (4 subgoals):\n 1. x \\<notin> \\<^bold>V \\<Longrightarrow>\n    d_OUT (current_of_bipartite f) x = 0\n 2. x \\<in> A \\<Gamma> \\<Longrightarrow>\n    d_OUT (current_of_bipartite f) x = 0\n 3. x \\<in> B \\<Gamma> \\<Longrightarrow>\n    d_OUT (current_of_bipartite f) x = 0\n 4. \\<lbrakk>x \\<in> \\<^bold>V; x \\<notin> A \\<Gamma>;\n     x \\<notin> B \\<Gamma>\\<rbrakk>\n    \\<Longrightarrow> d_OUT (current_of_bipartite f) x = 0", "case outside"], ["proof (state)\nthis:\n  x \\<notin> \\<^bold>V\n\ngoal (4 subgoals):\n 1. x \\<notin> \\<^bold>V \\<Longrightarrow>\n    d_OUT (current_of_bipartite f) x = 0\n 2. x \\<in> A \\<Gamma> \\<Longrightarrow>\n    d_OUT (current_of_bipartite f) x = 0\n 3. x \\<in> B \\<Gamma> \\<Longrightarrow>\n    d_OUT (current_of_bipartite f) x = 0\n 4. \\<lbrakk>x \\<in> \\<^bold>V; x \\<notin> A \\<Gamma>;\n     x \\<notin> B \\<Gamma>\\<rbrakk>\n    \\<Longrightarrow> d_OUT (current_of_bipartite f) x = 0", "with f w"], ["proof (chain)\npicking this:\n  current (bipartite_web_of \\<Gamma>) f\n  wave (bipartite_web_of \\<Gamma>) f\n  x \\<notin> \\<^bold>V", "show ?thesis"], ["proof (prove)\nusing this:\n  current (bipartite_web_of \\<Gamma>) f\n  wave (bipartite_web_of \\<Gamma>) f\n  x \\<notin> \\<^bold>V\n\ngoal (1 subgoal):\n 1. d_OUT (current_of_bipartite f) x = 0", "by(rule currentD_outside_OUT[OF current_current_of_bipartite])"], ["proof (state)\nthis:\n  d_OUT (current_of_bipartite f) x = 0\n\ngoal (3 subgoals):\n 1. x \\<in> A \\<Gamma> \\<Longrightarrow>\n    d_OUT (current_of_bipartite f) x = 0\n 2. x \\<in> B \\<Gamma> \\<Longrightarrow>\n    d_OUT (current_of_bipartite f) x = 0\n 3. \\<lbrakk>x \\<in> \\<^bold>V; x \\<notin> A \\<Gamma>;\n     x \\<notin> B \\<Gamma>\\<rbrakk>\n    \\<Longrightarrow> d_OUT (current_of_bipartite f) x = 0", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. x \\<in> A \\<Gamma> \\<Longrightarrow>\n    d_OUT (current_of_bipartite f) x = 0\n 2. x \\<in> B \\<Gamma> \\<Longrightarrow>\n    d_OUT (current_of_bipartite f) x = 0\n 3. \\<lbrakk>x \\<in> \\<^bold>V; x \\<notin> A \\<Gamma>;\n     x \\<notin> B \\<Gamma>\\<rbrakk>\n    \\<Longrightarrow> d_OUT (current_of_bipartite f) x = 0", "case A"], ["proof (state)\nthis:\n  x \\<in> A \\<Gamma>\n\ngoal (3 subgoals):\n 1. x \\<in> A \\<Gamma> \\<Longrightarrow>\n    d_OUT (current_of_bipartite f) x = 0\n 2. x \\<in> B \\<Gamma> \\<Longrightarrow>\n    d_OUT (current_of_bipartite f) x = 0\n 3. \\<lbrakk>x \\<in> \\<^bold>V; x \\<notin> A \\<Gamma>;\n     x \\<notin> B \\<Gamma>\\<rbrakk>\n    \\<Longrightarrow> d_OUT (current_of_bipartite f) x = 0", "from separatingD[OF sep p A y] bypass"], ["proof (chain)\npicking this:\n  (\\<exists>z\\<in>set p. z \\<in> TER (current_of_bipartite f)) \\<or>\n  x \\<in> TER (current_of_bipartite f)\n  ?z \\<in> set p \\<Longrightarrow> ?z \\<notin> TER (current_of_bipartite f)", "have \"x \\<in> TER ?f\""], ["proof (prove)\nusing this:\n  (\\<exists>z\\<in>set p. z \\<in> TER (current_of_bipartite f)) \\<or>\n  x \\<in> TER (current_of_bipartite f)\n  ?z \\<in> set p \\<Longrightarrow> ?z \\<notin> TER (current_of_bipartite f)\n\ngoal (1 subgoal):\n 1. x \\<in> TER (current_of_bipartite f)", "by blast"], ["proof (state)\nthis:\n  x \\<in> TER (current_of_bipartite f)\n\ngoal (3 subgoals):\n 1. x \\<in> A \\<Gamma> \\<Longrightarrow>\n    d_OUT (current_of_bipartite f) x = 0\n 2. x \\<in> B \\<Gamma> \\<Longrightarrow>\n    d_OUT (current_of_bipartite f) x = 0\n 3. \\<lbrakk>x \\<in> \\<^bold>V; x \\<notin> A \\<Gamma>;\n     x \\<notin> B \\<Gamma>\\<rbrakk>\n    \\<Longrightarrow> d_OUT (current_of_bipartite f) x = 0", "thus ?thesis"], ["proof (prove)\nusing this:\n  x \\<in> TER (current_of_bipartite f)\n\ngoal (1 subgoal):\n 1. d_OUT (current_of_bipartite f) x = 0", "by(simp add: SINK.simps)"], ["proof (state)\nthis:\n  d_OUT (current_of_bipartite f) x = 0\n\ngoal (2 subgoals):\n 1. x \\<in> B \\<Gamma> \\<Longrightarrow>\n    d_OUT (current_of_bipartite f) x = 0\n 2. \\<lbrakk>x \\<in> \\<^bold>V; x \\<notin> A \\<Gamma>;\n     x \\<notin> B \\<Gamma>\\<rbrakk>\n    \\<Longrightarrow> d_OUT (current_of_bipartite f) x = 0", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<in> B \\<Gamma> \\<Longrightarrow>\n    d_OUT (current_of_bipartite f) x = 0\n 2. \\<lbrakk>x \\<in> \\<^bold>V; x \\<notin> A \\<Gamma>;\n     x \\<notin> B \\<Gamma>\\<rbrakk>\n    \\<Longrightarrow> d_OUT (current_of_bipartite f) x = 0", "case B"], ["proof (state)\nthis:\n  x \\<in> B \\<Gamma>\n\ngoal (2 subgoals):\n 1. x \\<in> B \\<Gamma> \\<Longrightarrow>\n    d_OUT (current_of_bipartite f) x = 0\n 2. \\<lbrakk>x \\<in> \\<^bold>V; x \\<notin> A \\<Gamma>;\n     x \\<notin> B \\<Gamma>\\<rbrakk>\n    \\<Longrightarrow> d_OUT (current_of_bipartite f) x = 0", "with f w"], ["proof (chain)\npicking this:\n  current (bipartite_web_of \\<Gamma>) f\n  wave (bipartite_web_of \\<Gamma>) f\n  x \\<in> B \\<Gamma>", "show ?thesis"], ["proof (prove)\nusing this:\n  current (bipartite_web_of \\<Gamma>) f\n  wave (bipartite_web_of \\<Gamma>) f\n  x \\<in> B \\<Gamma>\n\ngoal (1 subgoal):\n 1. d_OUT (current_of_bipartite f) x = 0", "by(rule currentD_OUT[OF current_current_of_bipartite])"], ["proof (state)\nthis:\n  d_OUT (current_of_bipartite f) x = 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> \\<^bold>V; x \\<notin> A \\<Gamma>;\n     x \\<notin> B \\<Gamma>\\<rbrakk>\n    \\<Longrightarrow> d_OUT (current_of_bipartite f) x = 0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> \\<^bold>V; x \\<notin> A \\<Gamma>;\n     x \\<notin> B \\<Gamma>\\<rbrakk>\n    \\<Longrightarrow> d_OUT (current_of_bipartite f) x = 0", "case inner"], ["proof (state)\nthis:\n  x \\<in> \\<^bold>V\n  x \\<notin> A \\<Gamma>\n  x \\<notin> B \\<Gamma>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> \\<^bold>V; x \\<notin> A \\<Gamma>;\n     x \\<notin> B \\<Gamma>\\<rbrakk>\n    \\<Longrightarrow> d_OUT (current_of_bipartite f) x = 0", "hence \"path ?\\<Gamma> (Inl x) [Inr x] (Inr x)\""], ["proof (prove)\nusing this:\n  x \\<in> \\<^bold>V\n  x \\<notin> A \\<Gamma>\n  x \\<notin> B \\<Gamma>\n\ngoal (1 subgoal):\n 1. path (bipartite_web_of \\<Gamma>) (Inl x) [Inr x] (Inr x)", "by(auto intro!: rtrancl_path.intros)"], ["proof (state)\nthis:\n  path (bipartite_web_of \\<Gamma>) (Inl x) [Inr x] (Inr x)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> \\<^bold>V; x \\<notin> A \\<Gamma>;\n     x \\<notin> B \\<Gamma>\\<rbrakk>\n    \\<Longrightarrow> d_OUT (current_of_bipartite f) x = 0", "from inner waveD_separating[OF w, THEN separatingD, OF this]"], ["proof (chain)\npicking this:\n  x \\<in> \\<^bold>V\n  x \\<notin> A \\<Gamma>\n  x \\<notin> B \\<Gamma>\n  \\<lbrakk>Inl x \\<in> A (bipartite_web_of \\<Gamma>);\n   Inr x \\<in> B (bipartite_web_of \\<Gamma>)\\<rbrakk>\n  \\<Longrightarrow> (\\<exists>z\\<in>set [Inr x].\n                        z \\<in> TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub>\n                                 f) \\<or>\n                    Inl x\n                    \\<in> TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f", "consider (Inl) \"Inl x \\<in> TER\\<^bsub>?\\<Gamma>\\<^esub> f\" | (Inr) \"Inr x \\<in> TER\\<^bsub>?\\<Gamma>\\<^esub> f\""], ["proof (prove)\nusing this:\n  x \\<in> \\<^bold>V\n  x \\<notin> A \\<Gamma>\n  x \\<notin> B \\<Gamma>\n  \\<lbrakk>Inl x \\<in> A (bipartite_web_of \\<Gamma>);\n   Inr x \\<in> B (bipartite_web_of \\<Gamma>)\\<rbrakk>\n  \\<Longrightarrow> (\\<exists>z\\<in>set [Inr x].\n                        z \\<in> TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub>\n                                 f) \\<or>\n                    Inl x\n                    \\<in> TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Inl x\n             \\<in> TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub>\n                    f \\<Longrightarrow>\n             thesis;\n     Inr x\n     \\<in> TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f \\<Longrightarrow>\n     thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>Inl x\n           \\<in> TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub>\n                  f \\<Longrightarrow>\n           ?thesis;\n   Inr x\n   \\<in> TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f \\<Longrightarrow>\n   ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> \\<^bold>V; x \\<notin> A \\<Gamma>;\n     x \\<notin> B \\<Gamma>\\<rbrakk>\n    \\<Longrightarrow> d_OUT (current_of_bipartite f) x = 0", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>Inl x\n           \\<in> TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub>\n                  f \\<Longrightarrow>\n           ?thesis;\n   Inr x\n   \\<in> TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f \\<Longrightarrow>\n   ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>Inl x\n           \\<in> TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub>\n                  f \\<Longrightarrow>\n           ?thesis;\n   Inr x\n   \\<in> TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f \\<Longrightarrow>\n   ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. d_OUT (current_of_bipartite f) x = 0", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. Inl x\n    \\<in> TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f \\<Longrightarrow>\n    d_OUT (current_of_bipartite f) x = 0\n 2. Inr x\n    \\<in> TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f \\<Longrightarrow>\n    d_OUT (current_of_bipartite f) x = 0", "case Inl"], ["proof (state)\nthis:\n  Inl x \\<in> TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f\n\ngoal (2 subgoals):\n 1. Inl x\n    \\<in> TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f \\<Longrightarrow>\n    d_OUT (current_of_bipartite f) x = 0\n 2. Inr x\n    \\<in> TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f \\<Longrightarrow>\n    d_OUT (current_of_bipartite f) x = 0", "thus ?thesis"], ["proof (prove)\nusing this:\n  Inl x \\<in> TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f\n\ngoal (1 subgoal):\n 1. d_OUT (current_of_bipartite f) x = 0", "by(auto simp add: SINK.simps d_OUT_current_of_bipartite[OF f] max_def)"], ["proof (state)\nthis:\n  d_OUT (current_of_bipartite f) x = 0\n\ngoal (1 subgoal):\n 1. Inr x\n    \\<in> TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f \\<Longrightarrow>\n    d_OUT (current_of_bipartite f) x = 0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. Inr x\n    \\<in> TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f \\<Longrightarrow>\n    d_OUT (current_of_bipartite f) x = 0", "case Inr"], ["proof (state)\nthis:\n  Inr x \\<in> TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f\n\ngoal (1 subgoal):\n 1. Inr x\n    \\<in> TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f \\<Longrightarrow>\n    d_OUT (current_of_bipartite f) x = 0", "with separating_of_bipartite_aux[OF waveD_separating[OF w] p y] x bypass"], ["proof (chain)\npicking this:\n  x \\<in> A \\<Gamma> \\<or>\n  Inr x\n  \\<in> TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f \\<Longrightarrow>\n  (\\<exists>z\\<in>set p.\n      z \\<in> separating_of_bipartite\n               (TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f)) \\<or>\n  x \\<in> separating_of_bipartite\n           (TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f)\n  x \\<notin> TER (current_of_bipartite f)\n  ?z \\<in> set p \\<Longrightarrow> ?z \\<notin> TER (current_of_bipartite f)\n  Inr x \\<in> TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f", "have False"], ["proof (prove)\nusing this:\n  x \\<in> A \\<Gamma> \\<or>\n  Inr x\n  \\<in> TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f \\<Longrightarrow>\n  (\\<exists>z\\<in>set p.\n      z \\<in> separating_of_bipartite\n               (TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f)) \\<or>\n  x \\<in> separating_of_bipartite\n           (TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f)\n  x \\<notin> TER (current_of_bipartite f)\n  ?z \\<in> set p \\<Longrightarrow> ?z \\<notin> TER (current_of_bipartite f)\n  Inr x \\<in> TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f\n\ngoal (1 subgoal):\n 1. False", "unfolding TER_current_of_bipartite[OF f w]"], ["proof (prove)\nusing this:\n  x \\<in> A \\<Gamma> \\<or>\n  Inr x\n  \\<in> TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f \\<Longrightarrow>\n  (\\<exists>z\\<in>set p.\n      z \\<in> separating_of_bipartite\n               (TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f)) \\<or>\n  x \\<in> separating_of_bipartite\n           (TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f)\n  x \\<notin> separating_of_bipartite\n              (TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f)\n  ?z \\<in> set p \\<Longrightarrow>\n  ?z \\<notin> separating_of_bipartite\n               (TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f)\n  Inr x \\<in> TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. Inr x\n    \\<in> TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f \\<Longrightarrow>\n    d_OUT (current_of_bipartite f) x = 0", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. d_OUT (current_of_bipartite f) x = 0", ".."], ["proof (state)\nthis:\n  d_OUT (current_of_bipartite f) x = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  d_OUT (current_of_bipartite f) x = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  d_OUT (current_of_bipartite f) x = 0\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "context countable_web begin"], ["", "lemma countable_bipartite_web_of: \"countable_bipartite_web (bipartite_web_of \\<Gamma>)\" (is \"countable_bipartite_web ?\\<Gamma>\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. countable_bipartite_web (bipartite_web_of \\<Gamma>)", "proof"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<^bold>V\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub>\n    \\<subseteq> A (bipartite_web_of \\<Gamma>) \\<union>\n                B (bipartite_web_of \\<Gamma>)\n 2. A (bipartite_web_of \\<Gamma>)\n    \\<subseteq> \\<^bold>V\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub>\n 3. \\<And>x y.\n       edge (bipartite_web_of \\<Gamma>) x y \\<Longrightarrow>\n       x \\<in> A (bipartite_web_of \\<Gamma>) \\<and>\n       y \\<in> B (bipartite_web_of \\<Gamma>)\n 4. A (bipartite_web_of \\<Gamma>) \\<inter> B (bipartite_web_of \\<Gamma>) =\n    {}\n 5. \\<And>x.\n       x \\<notin> \\<^bold>V\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> \\<Longrightarrow>\n       weight (bipartite_web_of \\<Gamma>) x = 0\n 6. \\<And>x. weight (bipartite_web_of \\<Gamma>) x \\<noteq> \\<top>\n 7. countable \\<^bold>E\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub>", "show \"\\<^bold>V\\<^bsub>?\\<Gamma>\\<^esub> \\<subseteq> A ?\\<Gamma> \\<union> B ?\\<Gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<^bold>V\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub>\n    \\<subseteq> A (bipartite_web_of \\<Gamma>) \\<union>\n                B (bipartite_web_of \\<Gamma>)", "apply(rule subsetI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<^bold>V\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> \\<Longrightarrow>\n       x \\<in> A (bipartite_web_of \\<Gamma>) \\<union>\n               B (bipartite_web_of \\<Gamma>)", "subgoal for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> \\<^bold>V\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> \\<Longrightarrow>\n    x \\<in> A (bipartite_web_of \\<Gamma>) \\<union>\n            B (bipartite_web_of \\<Gamma>)", "by(cases x) auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<^bold>V\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub>\n  \\<subseteq> A (bipartite_web_of \\<Gamma>) \\<union>\n              B (bipartite_web_of \\<Gamma>)\n\ngoal (6 subgoals):\n 1. A (bipartite_web_of \\<Gamma>)\n    \\<subseteq> \\<^bold>V\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub>\n 2. \\<And>x y.\n       edge (bipartite_web_of \\<Gamma>) x y \\<Longrightarrow>\n       x \\<in> A (bipartite_web_of \\<Gamma>) \\<and>\n       y \\<in> B (bipartite_web_of \\<Gamma>)\n 3. A (bipartite_web_of \\<Gamma>) \\<inter> B (bipartite_web_of \\<Gamma>) =\n    {}\n 4. \\<And>x.\n       x \\<notin> \\<^bold>V\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> \\<Longrightarrow>\n       weight (bipartite_web_of \\<Gamma>) x = 0\n 5. \\<And>x. weight (bipartite_web_of \\<Gamma>) x \\<noteq> \\<top>\n 6. countable \\<^bold>E\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub>", "show \"A ?\\<Gamma> \\<subseteq> \\<^bold>V\\<^bsub>?\\<Gamma>\\<^esub>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A (bipartite_web_of \\<Gamma>)\n    \\<subseteq> \\<^bold>V\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub>", "by auto"], ["proof (state)\nthis:\n  A (bipartite_web_of \\<Gamma>)\n  \\<subseteq> \\<^bold>V\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub>\n\ngoal (5 subgoals):\n 1. \\<And>x y.\n       edge (bipartite_web_of \\<Gamma>) x y \\<Longrightarrow>\n       x \\<in> A (bipartite_web_of \\<Gamma>) \\<and>\n       y \\<in> B (bipartite_web_of \\<Gamma>)\n 2. A (bipartite_web_of \\<Gamma>) \\<inter> B (bipartite_web_of \\<Gamma>) =\n    {}\n 3. \\<And>x.\n       x \\<notin> \\<^bold>V\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> \\<Longrightarrow>\n       weight (bipartite_web_of \\<Gamma>) x = 0\n 4. \\<And>x. weight (bipartite_web_of \\<Gamma>) x \\<noteq> \\<top>\n 5. countable \\<^bold>E\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub>", "show \"x \\<in> A ?\\<Gamma> \\<and> y \\<in> B ?\\<Gamma>\" if \"edge ?\\<Gamma> x y\" for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> A (bipartite_web_of \\<Gamma>) \\<and>\n    y \\<in> B (bipartite_web_of \\<Gamma>)", "using that"], ["proof (prove)\nusing this:\n  edge (bipartite_web_of \\<Gamma>) x y\n\ngoal (1 subgoal):\n 1. x \\<in> A (bipartite_web_of \\<Gamma>) \\<and>\n    y \\<in> B (bipartite_web_of \\<Gamma>)", "by(cases x y rule: sum.exhaust[case_product sum.exhaust])(auto simp add: inj_image_mem_iff vertex_def B_out A_in)"], ["proof (state)\nthis:\n  edge (bipartite_web_of \\<Gamma>) ?x ?y \\<Longrightarrow>\n  ?x \\<in> A (bipartite_web_of \\<Gamma>) \\<and>\n  ?y \\<in> B (bipartite_web_of \\<Gamma>)\n\ngoal (4 subgoals):\n 1. A (bipartite_web_of \\<Gamma>) \\<inter> B (bipartite_web_of \\<Gamma>) =\n    {}\n 2. \\<And>x.\n       x \\<notin> \\<^bold>V\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> \\<Longrightarrow>\n       weight (bipartite_web_of \\<Gamma>) x = 0\n 3. \\<And>x. weight (bipartite_web_of \\<Gamma>) x \\<noteq> \\<top>\n 4. countable \\<^bold>E\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub>", "show \"A ?\\<Gamma> \\<inter> B ?\\<Gamma> = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A (bipartite_web_of \\<Gamma>) \\<inter> B (bipartite_web_of \\<Gamma>) =\n    {}", "by auto"], ["proof (state)\nthis:\n  A (bipartite_web_of \\<Gamma>) \\<inter> B (bipartite_web_of \\<Gamma>) = {}\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       x \\<notin> \\<^bold>V\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> \\<Longrightarrow>\n       weight (bipartite_web_of \\<Gamma>) x = 0\n 2. \\<And>x. weight (bipartite_web_of \\<Gamma>) x \\<noteq> \\<top>\n 3. countable \\<^bold>E\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub>", "show \"countable \\<^bold>E\\<^bsub>?\\<Gamma>\\<^esub>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. countable \\<^bold>E\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub>", "by(simp add: E_bipartite_web)"], ["proof (state)\nthis:\n  countable \\<^bold>E\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub>\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<notin> \\<^bold>V\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> \\<Longrightarrow>\n       weight (bipartite_web_of \\<Gamma>) x = 0\n 2. \\<And>x. weight (bipartite_web_of \\<Gamma>) x \\<noteq> \\<top>", "show \"weight ?\\<Gamma> x \\<noteq> \\<top>\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. weight (bipartite_web_of \\<Gamma>) x \\<noteq> \\<top>", "by(cases x) simp_all"], ["proof (state)\nthis:\n  weight (bipartite_web_of \\<Gamma>) ?x \\<noteq> \\<top>\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<notin> \\<^bold>V\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> \\<Longrightarrow>\n       weight (bipartite_web_of \\<Gamma>) x = 0", "show \"weight (bipartite_web_of \\<Gamma>) x = 0\" if \"x \\<notin> \\<^bold>V\\<^bsub>?\\<Gamma>\\<^esub>\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. weight (bipartite_web_of \\<Gamma>) x = 0", "using that"], ["proof (prove)\nusing this:\n  x \\<notin> \\<^bold>V\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub>\n\ngoal (1 subgoal):\n 1. weight (bipartite_web_of \\<Gamma>) x = 0", "by(cases x)(auto simp add: weight_outside)"], ["proof (state)\nthis:\n  ?x \\<notin> \\<^bold>V\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> \\<Longrightarrow>\n  weight (bipartite_web_of \\<Gamma>) ?x = 0\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "context web begin"], ["", "lemma unhindered_bipartite_web_of:\n  assumes loose: \"loose \\<Gamma>\"\n  shows \"\\<not> hindered (bipartite_web_of \\<Gamma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> hindered (bipartite_web_of \\<Gamma>)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. hindered (bipartite_web_of \\<Gamma>) \\<Longrightarrow> False", "assume \"hindered (bipartite_web_of \\<Gamma>)\" (is \"hindered ?\\<Gamma>\")"], ["proof (state)\nthis:\n  hindered (bipartite_web_of \\<Gamma>)\n\ngoal (1 subgoal):\n 1. hindered (bipartite_web_of \\<Gamma>) \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  hindered (bipartite_web_of \\<Gamma>)", "obtain f where f: \"current ?\\<Gamma> f\" and w: \"wave ?\\<Gamma> f\" and hind: \"hindrance ?\\<Gamma> f\""], ["proof (prove)\nusing this:\n  hindered (bipartite_web_of \\<Gamma>)\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        \\<lbrakk>current (bipartite_web_of \\<Gamma>) f;\n         wave (bipartite_web_of \\<Gamma>) f;\n         hindrance (bipartite_web_of \\<Gamma>) f\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by cases"], ["proof (state)\nthis:\n  current (bipartite_web_of \\<Gamma>) f\n  wave (bipartite_web_of \\<Gamma>) f\n  hindrance (bipartite_web_of \\<Gamma>) f\n\ngoal (1 subgoal):\n 1. hindered (bipartite_web_of \\<Gamma>) \\<Longrightarrow> False", "from f w"], ["proof (chain)\npicking this:\n  current (bipartite_web_of \\<Gamma>) f\n  wave (bipartite_web_of \\<Gamma>) f", "have \"current \\<Gamma> (current_of_bipartite f)\""], ["proof (prove)\nusing this:\n  current (bipartite_web_of \\<Gamma>) f\n  wave (bipartite_web_of \\<Gamma>) f\n\ngoal (1 subgoal):\n 1. current \\<Gamma> (current_of_bipartite f)", "by(rule current_current_of_bipartite)"], ["proof (state)\nthis:\n  current \\<Gamma> (current_of_bipartite f)\n\ngoal (1 subgoal):\n 1. hindered (bipartite_web_of \\<Gamma>) \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  current \\<Gamma> (current_of_bipartite f)\n\ngoal (1 subgoal):\n 1. hindered (bipartite_web_of \\<Gamma>) \\<Longrightarrow> False", "from f w"], ["proof (chain)\npicking this:\n  current (bipartite_web_of \\<Gamma>) f\n  wave (bipartite_web_of \\<Gamma>) f", "have \"wave \\<Gamma> (current_of_bipartite f)\""], ["proof (prove)\nusing this:\n  current (bipartite_web_of \\<Gamma>) f\n  wave (bipartite_web_of \\<Gamma>) f\n\ngoal (1 subgoal):\n 1. wave \\<Gamma> (current_of_bipartite f)", "by(rule wave_current_of_bipartite)"], ["proof (state)\nthis:\n  wave \\<Gamma> (current_of_bipartite f)\n\ngoal (1 subgoal):\n 1. hindered (bipartite_web_of \\<Gamma>) \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  current \\<Gamma> (current_of_bipartite f)\n  wave \\<Gamma> (current_of_bipartite f)", "have *: \"current_of_bipartite f = zero_current\""], ["proof (prove)\nusing this:\n  current \\<Gamma> (current_of_bipartite f)\n  wave \\<Gamma> (current_of_bipartite f)\n\ngoal (1 subgoal):\n 1. current_of_bipartite f = (\\<lambda>_. 0)", "by(rule looseD_wave[OF loose])"], ["proof (state)\nthis:\n  current_of_bipartite f = (\\<lambda>_. 0)\n\ngoal (1 subgoal):\n 1. hindered (bipartite_web_of \\<Gamma>) \\<Longrightarrow> False", "have zero: \"f (Inl x, Inr y) = 0\" if \"x \\<noteq> y\" for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. f (Inl x, Inr y) = 0", "using that *[THEN fun_cong, of \"(x, y)\"]"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  current_of_bipartite f (x, y) = 0\n\ngoal (1 subgoal):\n 1. f (Inl x, Inr y) = 0", "by(cases \"edge \\<Gamma> x y\")(auto intro: currentD_outside[OF f])"], ["proof (state)\nthis:\n  ?x \\<noteq> ?y \\<Longrightarrow> f (Inl ?x, Inr ?y) = 0\n\ngoal (1 subgoal):\n 1. hindered (bipartite_web_of \\<Gamma>) \\<Longrightarrow> False", "have OUT: \"d_OUT f (Inl x) = f (Inl x, Inr x)\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT f (Inl x) = f (Inl x, Inr x)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. d_OUT f (Inl x) = f (Inl x, Inr x)", "have \"d_OUT f (Inl x) = (\\<Sum>\\<^sup>+ y. f (Inl x, y) * indicator {Inr x} y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT f (Inl x) =\n    \\<integral>\\<^sup>+y\\<in>{Inr x}. f (Inl x, y)\\<partial>count_space UNIV", "unfolding d_OUT_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y. f (Inl x, y)) =\n    \\<integral>\\<^sup>+y\\<in>{Inr x}. f (Inl x, y)\\<partial>count_space UNIV", "using zero currentD_outside[OF f]"], ["proof (prove)\nusing this:\n  ?x \\<noteq> ?y \\<Longrightarrow> f (Inl ?x, Inr ?y) = 0\n  \\<not> edge (bipartite_web_of \\<Gamma>) ?x ?y \\<Longrightarrow>\n  f (?x, ?y) = 0\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y. f (Inl x, y)) =\n    \\<integral>\\<^sup>+y\\<in>{Inr x}. f (Inl x, y)\\<partial>count_space UNIV", "apply(intro nn_integral_cong)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>\\<And>x y.\n                   x \\<noteq> y \\<Longrightarrow> f (Inl x, Inr y) = 0;\n        \\<And>x y.\n           \\<not> edge (bipartite_web_of \\<Gamma>) x y \\<Longrightarrow>\n           f (x, y) = 0;\n        xa \\<in> space (count_space UNIV)\\<rbrakk>\n       \\<Longrightarrow> f (Inl x, xa) =\n                         f (Inl x, xa) * indicator {Inr x} xa", "subgoal for y"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x y. x \\<noteq> y \\<Longrightarrow> f (Inl x, Inr y) = 0;\n     \\<And>x y.\n        \\<not> edge (bipartite_web_of \\<Gamma>) x y \\<Longrightarrow>\n        f (x, y) = 0;\n     y \\<in> space (count_space UNIV)\\<rbrakk>\n    \\<Longrightarrow> f (Inl x, y) = f (Inl x, y) * indicator {Inr x} y", "by(cases y)(auto split: split_indicator)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  d_OUT f (Inl x) =\n  \\<integral>\\<^sup>+y\\<in>{Inr x}. f (Inl x, y)\\<partial>count_space UNIV\n\ngoal (1 subgoal):\n 1. d_OUT f (Inl x) = f (Inl x, Inr x)", "also"], ["proof (state)\nthis:\n  d_OUT f (Inl x) =\n  \\<integral>\\<^sup>+y\\<in>{Inr x}. f (Inl x, y)\\<partial>count_space UNIV\n\ngoal (1 subgoal):\n 1. d_OUT f (Inl x) = f (Inl x, Inr x)", "have \"\\<dots> = f (Inl x, Inr x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+y\\<in>{Inr x}. f (Inl x, y)\n    \\<partial>count_space UNIV =\n    f (Inl x, Inr x)", "by simp"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+y\\<in>{Inr x}. f (Inl x, y)\\<partial>count_space UNIV =\n  f (Inl x, Inr x)\n\ngoal (1 subgoal):\n 1. d_OUT f (Inl x) = f (Inl x, Inr x)", "finally"], ["proof (chain)\npicking this:\n  d_OUT f (Inl x) = f (Inl x, Inr x)", "show ?thesis"], ["proof (prove)\nusing this:\n  d_OUT f (Inl x) = f (Inl x, Inr x)\n\ngoal (1 subgoal):\n 1. d_OUT f (Inl x) = f (Inl x, Inr x)", "."], ["proof (state)\nthis:\n  d_OUT f (Inl x) = f (Inl x, Inr x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  d_OUT f (Inl ?x) = f (Inl ?x, Inr ?x)\n\ngoal (1 subgoal):\n 1. hindered (bipartite_web_of \\<Gamma>) \\<Longrightarrow> False", "have IN: \"d_IN f (Inr x) = f (Inl x, Inr x)\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN f (Inr x) = f (Inl x, Inr x)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. d_IN f (Inr x) = f (Inl x, Inr x)", "have \"d_IN f (Inr x) = (\\<Sum>\\<^sup>+ y. f (y, Inr x) * indicator {Inl x} y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN f (Inr x) =\n    \\<integral>\\<^sup>+y\\<in>{Inl x}. f (y, Inr x)\\<partial>count_space UNIV", "unfolding d_IN_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ xa. f (xa, Inr x)) =\n    \\<integral>\\<^sup>+y\\<in>{Inl x}. f (y, Inr x)\\<partial>count_space UNIV", "using zero currentD_outside[OF f]"], ["proof (prove)\nusing this:\n  ?x \\<noteq> ?y \\<Longrightarrow> f (Inl ?x, Inr ?y) = 0\n  \\<not> edge (bipartite_web_of \\<Gamma>) ?x ?y \\<Longrightarrow>\n  f (?x, ?y) = 0\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ xa. f (xa, Inr x)) =\n    \\<integral>\\<^sup>+y\\<in>{Inl x}. f (y, Inr x)\\<partial>count_space UNIV", "apply(intro nn_integral_cong)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>\\<And>x y.\n                   x \\<noteq> y \\<Longrightarrow> f (Inl x, Inr y) = 0;\n        \\<And>x y.\n           \\<not> edge (bipartite_web_of \\<Gamma>) x y \\<Longrightarrow>\n           f (x, y) = 0;\n        xa \\<in> space (count_space UNIV)\\<rbrakk>\n       \\<Longrightarrow> f (xa, Inr x) =\n                         f (xa, Inr x) * indicator {Inl x} xa", "subgoal for y"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x y. x \\<noteq> y \\<Longrightarrow> f (Inl x, Inr y) = 0;\n     \\<And>x y.\n        \\<not> edge (bipartite_web_of \\<Gamma>) x y \\<Longrightarrow>\n        f (x, y) = 0;\n     y \\<in> space (count_space UNIV)\\<rbrakk>\n    \\<Longrightarrow> f (y, Inr x) = f (y, Inr x) * indicator {Inl x} y", "by(cases y)(auto split: split_indicator)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  d_IN f (Inr x) =\n  \\<integral>\\<^sup>+y\\<in>{Inl x}. f (y, Inr x)\\<partial>count_space UNIV\n\ngoal (1 subgoal):\n 1. d_IN f (Inr x) = f (Inl x, Inr x)", "also"], ["proof (state)\nthis:\n  d_IN f (Inr x) =\n  \\<integral>\\<^sup>+y\\<in>{Inl x}. f (y, Inr x)\\<partial>count_space UNIV\n\ngoal (1 subgoal):\n 1. d_IN f (Inr x) = f (Inl x, Inr x)", "have \"\\<dots> = f (Inl x, Inr x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+y\\<in>{Inl x}. f (y, Inr x)\n    \\<partial>count_space UNIV =\n    f (Inl x, Inr x)", "by simp"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+y\\<in>{Inl x}. f (y, Inr x)\\<partial>count_space UNIV =\n  f (Inl x, Inr x)\n\ngoal (1 subgoal):\n 1. d_IN f (Inr x) = f (Inl x, Inr x)", "finally"], ["proof (chain)\npicking this:\n  d_IN f (Inr x) = f (Inl x, Inr x)", "show ?thesis"], ["proof (prove)\nusing this:\n  d_IN f (Inr x) = f (Inl x, Inr x)\n\ngoal (1 subgoal):\n 1. d_IN f (Inr x) = f (Inl x, Inr x)", "."], ["proof (state)\nthis:\n  d_IN f (Inr x) = f (Inl x, Inr x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  d_IN f (Inr ?x) = f (Inl ?x, Inr ?x)\n\ngoal (1 subgoal):\n 1. hindered (bipartite_web_of \\<Gamma>) \\<Longrightarrow> False", "let ?TER = \"TER\\<^bsub>?\\<Gamma>\\<^esub> f\""], ["proof (state)\ngoal (1 subgoal):\n 1. hindered (bipartite_web_of \\<Gamma>) \\<Longrightarrow> False", "from hind"], ["proof (chain)\npicking this:\n  hindrance (bipartite_web_of \\<Gamma>) f", "obtain a where a: \"a \\<in> A ?\\<Gamma>\" and n\\<E>: \"a \\<notin> \\<E>\\<^bsub>?\\<Gamma>\\<^esub> (TER\\<^bsub>?\\<Gamma>\\<^esub> f)\"\n    and OUT_a: \"d_OUT f a < weight ?\\<Gamma> a\""], ["proof (prove)\nusing this:\n  hindrance (bipartite_web_of \\<Gamma>) f\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>a \\<in> A (bipartite_web_of \\<Gamma>);\n         a \\<notin> \\<E>\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub>\n                     (TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f);\n         d_OUT f a < weight (bipartite_web_of \\<Gamma>) a\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by cases"], ["proof (state)\nthis:\n  a \\<in> A (bipartite_web_of \\<Gamma>)\n  a \\<notin> \\<E>\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub>\n              (TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f)\n  d_OUT f a < weight (bipartite_web_of \\<Gamma>) a\n\ngoal (1 subgoal):\n 1. hindered (bipartite_web_of \\<Gamma>) \\<Longrightarrow> False", "from a"], ["proof (chain)\npicking this:\n  a \\<in> A (bipartite_web_of \\<Gamma>)", "obtain a' where a': \"a = Inl a'\" and v: \"vertex \\<Gamma> a'\" and b: \"a' \\<notin> B \\<Gamma>\""], ["proof (prove)\nusing this:\n  a \\<in> A (bipartite_web_of \\<Gamma>)\n\ngoal (1 subgoal):\n 1. (\\<And>a'.\n        \\<lbrakk>a = Inl a'; vertex \\<Gamma> a';\n         a' \\<notin> B \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  a = Inl a'\n  vertex \\<Gamma> a'\n  a' \\<notin> B \\<Gamma>\n\ngoal (1 subgoal):\n 1. hindered (bipartite_web_of \\<Gamma>) \\<Longrightarrow> False", "have A: \"a' \\<in> A \\<Gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a' \\<in> A \\<Gamma>", "proof(rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. a' \\<notin> A \\<Gamma> \\<Longrightarrow> False", "assume A: \"a' \\<notin> A \\<Gamma>\""], ["proof (state)\nthis:\n  a' \\<notin> A \\<Gamma>\n\ngoal (1 subgoal):\n 1. a' \\<notin> A \\<Gamma> \\<Longrightarrow> False", "hence \"edge ?\\<Gamma> (Inl a') (Inr a')\""], ["proof (prove)\nusing this:\n  a' \\<notin> A \\<Gamma>\n\ngoal (1 subgoal):\n 1. edge (bipartite_web_of \\<Gamma>) (Inl a') (Inr a')", "using v b"], ["proof (prove)\nusing this:\n  a' \\<notin> A \\<Gamma>\n  vertex \\<Gamma> a'\n  a' \\<notin> B \\<Gamma>\n\ngoal (1 subgoal):\n 1. edge (bipartite_web_of \\<Gamma>) (Inl a') (Inr a')", "by simp"], ["proof (state)\nthis:\n  edge (bipartite_web_of \\<Gamma>) (Inl a') (Inr a')\n\ngoal (1 subgoal):\n 1. a' \\<notin> A \\<Gamma> \\<Longrightarrow> False", "hence p: \"path ?\\<Gamma> (Inl a') [Inr a'] (Inr a')\""], ["proof (prove)\nusing this:\n  edge (bipartite_web_of \\<Gamma>) (Inl a') (Inr a')\n\ngoal (1 subgoal):\n 1. path (bipartite_web_of \\<Gamma>) (Inl a') [Inr a'] (Inr a')", "by(simp add: rtrancl_path_simps)"], ["proof (state)\nthis:\n  path (bipartite_web_of \\<Gamma>) (Inl a') [Inr a'] (Inr a')\n\ngoal (1 subgoal):\n 1. a' \\<notin> A \\<Gamma> \\<Longrightarrow> False", "from separatingD[OF waveD_separating[OF w] this] b v A"], ["proof (chain)\npicking this:\n  \\<lbrakk>Inl a' \\<in> A (bipartite_web_of \\<Gamma>);\n   Inr a' \\<in> B (bipartite_web_of \\<Gamma>)\\<rbrakk>\n  \\<Longrightarrow> (\\<exists>z\\<in>set [Inr a'].\n                        z \\<in> TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub>\n                                 f) \\<or>\n                    Inl a'\n                    \\<in> TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f\n  a' \\<notin> B \\<Gamma>\n  vertex \\<Gamma> a'\n  a' \\<notin> A \\<Gamma>", "have \"Inl a' \\<in> ?TER \\<or> Inr a' \\<in> ?TER\""], ["proof (prove)\nusing this:\n  \\<lbrakk>Inl a' \\<in> A (bipartite_web_of \\<Gamma>);\n   Inr a' \\<in> B (bipartite_web_of \\<Gamma>)\\<rbrakk>\n  \\<Longrightarrow> (\\<exists>z\\<in>set [Inr a'].\n                        z \\<in> TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub>\n                                 f) \\<or>\n                    Inl a'\n                    \\<in> TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f\n  a' \\<notin> B \\<Gamma>\n  vertex \\<Gamma> a'\n  a' \\<notin> A \\<Gamma>\n\ngoal (1 subgoal):\n 1. Inl a' \\<in> TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f \\<or>\n    Inr a' \\<in> TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f", "by auto"], ["proof (state)\nthis:\n  Inl a' \\<in> TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f \\<or>\n  Inr a' \\<in> TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f\n\ngoal (1 subgoal):\n 1. a' \\<notin> A \\<Gamma> \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  Inl a' \\<in> TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f \\<or>\n  Inr a' \\<in> TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f\n\ngoal (1 subgoal):\n 1. False", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. Inl a'\n    \\<in> TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f \\<Longrightarrow>\n    False\n 2. Inr a'\n    \\<in> TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f \\<Longrightarrow>\n    False", "case left"], ["proof (state)\nthis:\n  Inl a' \\<in> TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f\n\ngoal (2 subgoals):\n 1. Inl a'\n    \\<in> TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f \\<Longrightarrow>\n    False\n 2. Inr a'\n    \\<in> TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f \\<Longrightarrow>\n    False", "hence \"d_OUT f (Inl a') = 0\""], ["proof (prove)\nusing this:\n  Inl a' \\<in> TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f\n\ngoal (1 subgoal):\n 1. d_OUT f (Inl a') = 0", "by(simp add: SINK.simps)"], ["proof (state)\nthis:\n  d_OUT f (Inl a') = 0\n\ngoal (2 subgoals):\n 1. Inl a'\n    \\<in> TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f \\<Longrightarrow>\n    False\n 2. Inr a'\n    \\<in> TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  d_OUT f (Inl a') = 0\n\ngoal (2 subgoals):\n 1. Inl a'\n    \\<in> TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f \\<Longrightarrow>\n    False\n 2. Inr a'\n    \\<in> TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f \\<Longrightarrow>\n    False", "hence \"d_IN f (Inr a') = 0\""], ["proof (prove)\nusing this:\n  d_OUT f (Inl a') = 0\n\ngoal (1 subgoal):\n 1. d_IN f (Inr a') = 0", "by(simp add: OUT IN)"], ["proof (state)\nthis:\n  d_IN f (Inr a') = 0\n\ngoal (2 subgoals):\n 1. Inl a'\n    \\<in> TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f \\<Longrightarrow>\n    False\n 2. Inr a'\n    \\<in> TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f \\<Longrightarrow>\n    False", "ultimately"], ["proof (chain)\npicking this:\n  d_OUT f (Inl a') = 0\n  d_IN f (Inr a') = 0", "have \"Inr a' \\<notin> ?TER\""], ["proof (prove)\nusing this:\n  d_OUT f (Inl a') = 0\n  d_IN f (Inr a') = 0\n\ngoal (1 subgoal):\n 1. Inr a' \\<notin> TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f", "using v b A OUT_a a'"], ["proof (prove)\nusing this:\n  d_OUT f (Inl a') = 0\n  d_IN f (Inr a') = 0\n  vertex \\<Gamma> a'\n  a' \\<notin> B \\<Gamma>\n  a' \\<notin> A \\<Gamma>\n  d_OUT f a < weight (bipartite_web_of \\<Gamma>) a\n  a = Inl a'\n\ngoal (1 subgoal):\n 1. Inr a' \\<notin> TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f", "by(auto simp add: SAT.simps)"], ["proof (state)\nthis:\n  Inr a' \\<notin> TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f\n\ngoal (2 subgoals):\n 1. Inl a'\n    \\<in> TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f \\<Longrightarrow>\n    False\n 2. Inr a'\n    \\<in> TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  Inr a' \\<notin> TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f", "have \"essential ?\\<Gamma> (B ?\\<Gamma>) ?TER (Inl a')\""], ["proof (prove)\nusing this:\n  Inr a' \\<notin> TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f\n\ngoal (1 subgoal):\n 1. essential (bipartite_web_of \\<Gamma>) (B (bipartite_web_of \\<Gamma>))\n     (TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f) (Inl a')", "using A"], ["proof (prove)\nusing this:\n  Inr a' \\<notin> TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f\n  a' \\<notin> A \\<Gamma>\n\ngoal (1 subgoal):\n 1. essential (bipartite_web_of \\<Gamma>) (B (bipartite_web_of \\<Gamma>))\n     (TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f) (Inl a')", "by(intro essentialI[OF p]) simp_all"], ["proof (state)\nthis:\n  essential (bipartite_web_of \\<Gamma>) (B (bipartite_web_of \\<Gamma>))\n   (TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f) (Inl a')\n\ngoal (2 subgoals):\n 1. Inl a'\n    \\<in> TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f \\<Longrightarrow>\n    False\n 2. Inr a'\n    \\<in> TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f \\<Longrightarrow>\n    False", "with n\\<E> left a'"], ["proof (chain)\npicking this:\n  a \\<notin> \\<E>\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub>\n              (TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f)\n  Inl a' \\<in> TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f\n  a = Inl a'\n  essential (bipartite_web_of \\<Gamma>) (B (bipartite_web_of \\<Gamma>))\n   (TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f) (Inl a')", "show False"], ["proof (prove)\nusing this:\n  a \\<notin> \\<E>\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub>\n              (TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f)\n  Inl a' \\<in> TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f\n  a = Inl a'\n  essential (bipartite_web_of \\<Gamma>) (B (bipartite_web_of \\<Gamma>))\n   (TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f) (Inl a')\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. Inr a'\n    \\<in> TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f \\<Longrightarrow>\n    False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. Inr a'\n    \\<in> TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f \\<Longrightarrow>\n    False", "case right"], ["proof (state)\nthis:\n  Inr a' \\<in> TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f\n\ngoal (1 subgoal):\n 1. Inr a'\n    \\<in> TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f \\<Longrightarrow>\n    False", "hence \"d_IN f (Inr a') = weight \\<Gamma> a'\""], ["proof (prove)\nusing this:\n  Inr a' \\<in> TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f\n\ngoal (1 subgoal):\n 1. d_IN f (Inr a') = weight \\<Gamma> a'", "using A"], ["proof (prove)\nusing this:\n  Inr a' \\<in> TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f\n  a' \\<notin> A \\<Gamma>\n\ngoal (1 subgoal):\n 1. d_IN f (Inr a') = weight \\<Gamma> a'", "by(auto simp add: currentD_SAT[OF f])"], ["proof (state)\nthis:\n  d_IN f (Inr a') = weight \\<Gamma> a'\n\ngoal (1 subgoal):\n 1. Inr a'\n    \\<in> TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f \\<Longrightarrow>\n    False", "hence \"d_OUT f (Inl a') = weight \\<Gamma> a'\""], ["proof (prove)\nusing this:\n  d_IN f (Inr a') = weight \\<Gamma> a'\n\ngoal (1 subgoal):\n 1. d_OUT f (Inl a') = weight \\<Gamma> a'", "by(simp add: IN OUT)"], ["proof (state)\nthis:\n  d_OUT f (Inl a') = weight \\<Gamma> a'\n\ngoal (1 subgoal):\n 1. Inr a'\n    \\<in> TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f \\<Longrightarrow>\n    False", "with OUT_a a' b"], ["proof (chain)\npicking this:\n  d_OUT f a < weight (bipartite_web_of \\<Gamma>) a\n  a = Inl a'\n  a' \\<notin> B \\<Gamma>\n  d_OUT f (Inl a') = weight \\<Gamma> a'", "show False"], ["proof (prove)\nusing this:\n  d_OUT f a < weight (bipartite_web_of \\<Gamma>) a\n  a = Inl a'\n  a' \\<notin> B \\<Gamma>\n  d_OUT f (Inl a') = weight \\<Gamma> a'\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  a' \\<in> A \\<Gamma>\n\ngoal (1 subgoal):\n 1. hindered (bipartite_web_of \\<Gamma>) \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  a' \\<in> A \\<Gamma>\n\ngoal (1 subgoal):\n 1. hindered (bipartite_web_of \\<Gamma>) \\<Longrightarrow> False", "from A"], ["proof (chain)\npicking this:\n  a' \\<in> A \\<Gamma>", "have \"d_OUT f (Inl a') = 0\""], ["proof (prove)\nusing this:\n  a' \\<in> A \\<Gamma>\n\ngoal (1 subgoal):\n 1. d_OUT f (Inl a') = 0", "using currentD_outside[OF f, of \"Inl a'\" \"Inr a'\"]"], ["proof (prove)\nusing this:\n  a' \\<in> A \\<Gamma>\n  \\<not> edge (bipartite_web_of \\<Gamma>) (Inl a')\n          (Inr a') \\<Longrightarrow>\n  f (Inl a', Inr a') = 0\n\ngoal (1 subgoal):\n 1. d_OUT f (Inl a') = 0", "by(simp add: OUT no_loop)"], ["proof (state)\nthis:\n  d_OUT f (Inl a') = 0\n\ngoal (1 subgoal):\n 1. hindered (bipartite_web_of \\<Gamma>) \\<Longrightarrow> False", "with b v"], ["proof (chain)\npicking this:\n  a' \\<notin> B \\<Gamma>\n  vertex \\<Gamma> a'\n  d_OUT f (Inl a') = 0", "have TER: \"Inl a' \\<in> ?TER\""], ["proof (prove)\nusing this:\n  a' \\<notin> B \\<Gamma>\n  vertex \\<Gamma> a'\n  d_OUT f (Inl a') = 0\n\ngoal (1 subgoal):\n 1. Inl a' \\<in> TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f", "by(simp add: SAT.A SINK.simps)"], ["proof (state)\nthis:\n  Inl a' \\<in> TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f\n\ngoal (1 subgoal):\n 1. hindered (bipartite_web_of \\<Gamma>) \\<Longrightarrow> False", "with n\\<E> a'"], ["proof (chain)\npicking this:\n  a \\<notin> \\<E>\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub>\n              (TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f)\n  a = Inl a'\n  Inl a' \\<in> TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f", "have ness: \"\\<not> essential ?\\<Gamma> (B ?\\<Gamma>) ?TER (Inl a')\""], ["proof (prove)\nusing this:\n  a \\<notin> \\<E>\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub>\n              (TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f)\n  a = Inl a'\n  Inl a' \\<in> TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f\n\ngoal (1 subgoal):\n 1. \\<not> essential (bipartite_web_of \\<Gamma>)\n            (B (bipartite_web_of \\<Gamma>))\n            (TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f) (Inl a')", "by simp"], ["proof (state)\nthis:\n  \\<not> essential (bipartite_web_of \\<Gamma>)\n          (B (bipartite_web_of \\<Gamma>))\n          (TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f) (Inl a')\n\ngoal (1 subgoal):\n 1. hindered (bipartite_web_of \\<Gamma>) \\<Longrightarrow> False", "have \"a' \\<notin> \\<E> (TER zero_current)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a' \\<notin> \\<E> (TER (\\<lambda>_. 0))", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. a' \\<in> \\<E> (TER (\\<lambda>_. 0)) \\<Longrightarrow> False", "assume \"a' \\<in> \\<E> (TER zero_current)\""], ["proof (state)\nthis:\n  a' \\<in> \\<E> (TER (\\<lambda>_. 0))\n\ngoal (1 subgoal):\n 1. a' \\<in> \\<E> (TER (\\<lambda>_. 0)) \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  a' \\<in> \\<E> (TER (\\<lambda>_. 0))", "obtain p y where p: \"path \\<Gamma> a' p y\" and y: \"y \\<in> B \\<Gamma>\"\n      and bypass: \"\\<And>z. z \\<in> set p \\<Longrightarrow> z \\<notin> TER zero_current\""], ["proof (prove)\nusing this:\n  a' \\<in> \\<E> (TER (\\<lambda>_. 0))\n\ngoal (1 subgoal):\n 1. (\\<And>p y.\n        \\<lbrakk>path \\<Gamma> a' p y; y \\<in> B \\<Gamma>;\n         \\<And>z.\n            z \\<in> set p \\<Longrightarrow>\n            z \\<notin> TER (\\<lambda>_. 0)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(rule \\<E>_E_RF)(auto intro: roofed_greaterI)"], ["proof (state)\nthis:\n  path \\<Gamma> a' p y\n  y \\<in> B \\<Gamma>\n  ?z \\<in> set p \\<Longrightarrow> ?z \\<notin> TER (\\<lambda>_. 0)\n\ngoal (1 subgoal):\n 1. a' \\<in> \\<E> (TER (\\<lambda>_. 0)) \\<Longrightarrow> False", "from p"], ["proof (chain)\npicking this:\n  path \\<Gamma> a' p y", "show False"], ["proof (prove)\nusing this:\n  path \\<Gamma> a' p y\n\ngoal (1 subgoal):\n 1. False", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>p = []; y = a'\\<rbrakk> \\<Longrightarrow> False\n 2. \\<And>ya ys.\n       \\<lbrakk>p = ya # ys; edge \\<Gamma> a' ya;\n        path \\<Gamma> ya ys y\\<rbrakk>\n       \\<Longrightarrow> False", "case base"], ["proof (state)\nthis:\n  p = []\n  y = a'\n\ngoal (2 subgoals):\n 1. \\<lbrakk>p = []; y = a'\\<rbrakk> \\<Longrightarrow> False\n 2. \\<And>ya ys.\n       \\<lbrakk>p = ya # ys; edge \\<Gamma> a' ya;\n        path \\<Gamma> ya ys y\\<rbrakk>\n       \\<Longrightarrow> False", "with y A disjoint"], ["proof (chain)\npicking this:\n  y \\<in> B \\<Gamma>\n  a' \\<in> A \\<Gamma>\n  A \\<Gamma> \\<inter> B \\<Gamma> = {}\n  p = []\n  y = a'", "show False"], ["proof (prove)\nusing this:\n  y \\<in> B \\<Gamma>\n  a' \\<in> A \\<Gamma>\n  A \\<Gamma> \\<inter> B \\<Gamma> = {}\n  p = []\n  y = a'\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<And>ya ys.\n       \\<lbrakk>p = ya # ys; edge \\<Gamma> a' ya;\n        path \\<Gamma> ya ys y\\<rbrakk>\n       \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ya ys.\n       \\<lbrakk>p = ya # ys; edge \\<Gamma> a' ya;\n        path \\<Gamma> ya ys y\\<rbrakk>\n       \\<Longrightarrow> False", "case (step x p')"], ["proof (state)\nthis:\n  p = x # p'\n  edge \\<Gamma> a' x\n  path \\<Gamma> x p' y\n\ngoal (1 subgoal):\n 1. \\<And>ya ys.\n       \\<lbrakk>p = ya # ys; edge \\<Gamma> a' ya;\n        path \\<Gamma> ya ys y\\<rbrakk>\n       \\<Longrightarrow> False", "from step(2)"], ["proof (chain)\npicking this:\n  edge \\<Gamma> a' x", "have \"path ?\\<Gamma> (Inl a') [Inr x] (Inr x)\""], ["proof (prove)\nusing this:\n  edge \\<Gamma> a' x\n\ngoal (1 subgoal):\n 1. path (bipartite_web_of \\<Gamma>) (Inl a') [Inr x] (Inr x)", "by(simp add: rtrancl_path_simps)"], ["proof (state)\nthis:\n  path (bipartite_web_of \\<Gamma>) (Inl a') [Inr x] (Inr x)\n\ngoal (1 subgoal):\n 1. \\<And>ya ys.\n       \\<lbrakk>p = ya # ys; edge \\<Gamma> a' ya;\n        path \\<Gamma> ya ys y\\<rbrakk>\n       \\<Longrightarrow> False", "from not_essentialD[OF ness this] bypass[of x] step(1)"], ["proof (chain)\npicking this:\n  Inr x \\<in> B (bipartite_web_of \\<Gamma>) \\<Longrightarrow>\n  Inl a' \\<noteq> Inr x \\<and>\n  (\\<exists>z\\<in>set [Inr x].\n      z \\<noteq> Inl a' \\<and>\n      z \\<in> TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f)\n  x \\<in> set p \\<Longrightarrow> x \\<notin> TER (\\<lambda>_. 0)\n  p = x # p'", "have \"Inr x \\<in> ?TER\""], ["proof (prove)\nusing this:\n  Inr x \\<in> B (bipartite_web_of \\<Gamma>) \\<Longrightarrow>\n  Inl a' \\<noteq> Inr x \\<and>\n  (\\<exists>z\\<in>set [Inr x].\n      z \\<noteq> Inl a' \\<and>\n      z \\<in> TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f)\n  x \\<in> set p \\<Longrightarrow> x \\<notin> TER (\\<lambda>_. 0)\n  p = x # p'\n\ngoal (1 subgoal):\n 1. Inr x \\<in> TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f", "by simp"], ["proof (state)\nthis:\n  Inr x \\<in> TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f\n\ngoal (1 subgoal):\n 1. \\<And>ya ys.\n       \\<lbrakk>p = ya # ys; edge \\<Gamma> a' ya;\n        path \\<Gamma> ya ys y\\<rbrakk>\n       \\<Longrightarrow> False", "with bypass[of x] step(1)"], ["proof (chain)\npicking this:\n  x \\<in> set p \\<Longrightarrow> x \\<notin> TER (\\<lambda>_. 0)\n  p = x # p'\n  Inr x \\<in> TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f", "have \"d_IN f (Inr x) > 0\""], ["proof (prove)\nusing this:\n  x \\<in> set p \\<Longrightarrow> x \\<notin> TER (\\<lambda>_. 0)\n  p = x # p'\n  Inr x \\<in> TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f\n\ngoal (1 subgoal):\n 1. 0 < d_IN f (Inr x)", "by(auto simp add: currentD_SAT[OF f] zero_less_iff_neq_zero)"], ["proof (state)\nthis:\n  0 < d_IN f (Inr x)\n\ngoal (1 subgoal):\n 1. \\<And>ya ys.\n       \\<lbrakk>p = ya # ys; edge \\<Gamma> a' ya;\n        path \\<Gamma> ya ys y\\<rbrakk>\n       \\<Longrightarrow> False", "hence x: \"Inl x \\<notin> ?TER\""], ["proof (prove)\nusing this:\n  0 < d_IN f (Inr x)\n\ngoal (1 subgoal):\n 1. Inl x \\<notin> TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f", "by(auto simp add: SINK.simps OUT IN)"], ["proof (state)\nthis:\n  Inl x \\<notin> TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f\n\ngoal (1 subgoal):\n 1. \\<And>ya ys.\n       \\<lbrakk>p = ya # ys; edge \\<Gamma> a' ya;\n        path \\<Gamma> ya ys y\\<rbrakk>\n       \\<Longrightarrow> False", "from step(1)"], ["proof (chain)\npicking this:\n  p = x # p'", "have \"set (x # p') \\<subseteq> set p\""], ["proof (prove)\nusing this:\n  p = x # p'\n\ngoal (1 subgoal):\n 1. set (x # p') \\<subseteq> set p", "by auto"], ["proof (state)\nthis:\n  set (x # p') \\<subseteq> set p\n\ngoal (1 subgoal):\n 1. \\<And>ya ys.\n       \\<lbrakk>p = ya # ys; edge \\<Gamma> a' ya;\n        path \\<Gamma> ya ys y\\<rbrakk>\n       \\<Longrightarrow> False", "with \\<open>path \\<Gamma> x p' y\\<close> x y"], ["proof (chain)\npicking this:\n  path \\<Gamma> x p' y\n  Inl x \\<notin> TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f\n  y \\<in> B \\<Gamma>\n  set (x # p') \\<subseteq> set p", "show False"], ["proof (prove)\nusing this:\n  path \\<Gamma> x p' y\n  Inl x \\<notin> TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f\n  y \\<in> B \\<Gamma>\n  set (x # p') \\<subseteq> set p\n\ngoal (1 subgoal):\n 1. False", "proof induction"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>Inl x\n                \\<notin> TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f;\n        x \\<in> B \\<Gamma>; set [x] \\<subseteq> set p\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>x y ys z.\n       \\<lbrakk>edge \\<Gamma> x y; path \\<Gamma> y ys z;\n        \\<lbrakk>Inl y\n                 \\<notin> TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f;\n         z \\<in> B \\<Gamma>; set (y # ys) \\<subseteq> set p\\<rbrakk>\n        \\<Longrightarrow> False;\n        Inl x \\<notin> TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f;\n        z \\<in> B \\<Gamma>; set (x # y # ys) \\<subseteq> set p\\<rbrakk>\n       \\<Longrightarrow> False", "case (base x)"], ["proof (state)\nthis:\n  Inl x \\<notin> TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f\n  x \\<in> B \\<Gamma>\n  set [x] \\<subseteq> set p\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>Inl x\n                \\<notin> TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f;\n        x \\<in> B \\<Gamma>; set [x] \\<subseteq> set p\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>x y ys z.\n       \\<lbrakk>edge \\<Gamma> x y; path \\<Gamma> y ys z;\n        \\<lbrakk>Inl y\n                 \\<notin> TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f;\n         z \\<in> B \\<Gamma>; set (y # ys) \\<subseteq> set p\\<rbrakk>\n        \\<Longrightarrow> False;\n        Inl x \\<notin> TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f;\n        z \\<in> B \\<Gamma>; set (x # y # ys) \\<subseteq> set p\\<rbrakk>\n       \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  Inl x \\<notin> TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f\n  x \\<in> B \\<Gamma>\n  set [x] \\<subseteq> set p\n\ngoal (1 subgoal):\n 1. False", "using currentD_outside_IN[OF f, of \"Inl x\"] currentD_outside_OUT[OF f, of \"Inl x\"]"], ["proof (prove)\nusing this:\n  Inl x \\<notin> TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f\n  x \\<in> B \\<Gamma>\n  set [x] \\<subseteq> set p\n  Inl x\n  \\<notin> \\<^bold>V\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> \\<Longrightarrow>\n  d_IN f (Inl x) = 0\n  Inl x\n  \\<notin> \\<^bold>V\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> \\<Longrightarrow>\n  d_OUT f (Inl x) = 0\n\ngoal (1 subgoal):\n 1. False", "by(auto simp add: currentD_SAT[OF f] SINK.simps dest!: bypass)"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<And>x y ys z.\n       \\<lbrakk>edge \\<Gamma> x y; path \\<Gamma> y ys z;\n        \\<lbrakk>Inl y\n                 \\<notin> TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f;\n         z \\<in> B \\<Gamma>; set (y # ys) \\<subseteq> set p\\<rbrakk>\n        \\<Longrightarrow> False;\n        Inl x \\<notin> TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f;\n        z \\<in> B \\<Gamma>; set (x # y # ys) \\<subseteq> set p\\<rbrakk>\n       \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y ys z.\n       \\<lbrakk>edge \\<Gamma> x y; path \\<Gamma> y ys z;\n        \\<lbrakk>Inl y\n                 \\<notin> TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f;\n         z \\<in> B \\<Gamma>; set (y # ys) \\<subseteq> set p\\<rbrakk>\n        \\<Longrightarrow> False;\n        Inl x \\<notin> TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f;\n        z \\<in> B \\<Gamma>; set (x # y # ys) \\<subseteq> set p\\<rbrakk>\n       \\<Longrightarrow> False", "case (step x z p' y)"], ["proof (state)\nthis:\n  edge \\<Gamma> x z\n  path \\<Gamma> z p' y\n  \\<lbrakk>Inl z \\<notin> TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f;\n   y \\<in> B \\<Gamma>; set (z # p') \\<subseteq> set p\\<rbrakk>\n  \\<Longrightarrow> False\n  Inl x \\<notin> TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f\n  y \\<in> B \\<Gamma>\n  set (x # z # p') \\<subseteq> set p\n\ngoal (1 subgoal):\n 1. \\<And>x y ys z.\n       \\<lbrakk>edge \\<Gamma> x y; path \\<Gamma> y ys z;\n        \\<lbrakk>Inl y\n                 \\<notin> TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f;\n         z \\<in> B \\<Gamma>; set (y # ys) \\<subseteq> set p\\<rbrakk>\n        \\<Longrightarrow> False;\n        Inl x \\<notin> TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f;\n        z \\<in> B \\<Gamma>; set (x # y # ys) \\<subseteq> set p\\<rbrakk>\n       \\<Longrightarrow> False", "from step.prems(3) bypass[of x] weight_outside[of x]"], ["proof (chain)\npicking this:\n  set (x # z # p') \\<subseteq> set p\n  x \\<in> set p \\<Longrightarrow> x \\<notin> TER (\\<lambda>_. 0)\n  x \\<notin> \\<^bold>V \\<Longrightarrow> weight \\<Gamma> x = 0", "have x: \"vertex \\<Gamma> x\""], ["proof (prove)\nusing this:\n  set (x # z # p') \\<subseteq> set p\n  x \\<in> set p \\<Longrightarrow> x \\<notin> TER (\\<lambda>_. 0)\n  x \\<notin> \\<^bold>V \\<Longrightarrow> weight \\<Gamma> x = 0\n\ngoal (1 subgoal):\n 1. vertex \\<Gamma> x", "by(auto)"], ["proof (state)\nthis:\n  vertex \\<Gamma> x\n\ngoal (1 subgoal):\n 1. \\<And>x y ys z.\n       \\<lbrakk>edge \\<Gamma> x y; path \\<Gamma> y ys z;\n        \\<lbrakk>Inl y\n                 \\<notin> TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f;\n         z \\<in> B \\<Gamma>; set (y # ys) \\<subseteq> set p\\<rbrakk>\n        \\<Longrightarrow> False;\n        Inl x \\<notin> TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f;\n        z \\<in> B \\<Gamma>; set (x # y # ys) \\<subseteq> set p\\<rbrakk>\n       \\<Longrightarrow> False", "from \\<open>edge \\<Gamma> x z\\<close>"], ["proof (chain)\npicking this:\n  edge \\<Gamma> x z", "have \"path ?\\<Gamma> (Inl x) [Inr z] (Inr z)\""], ["proof (prove)\nusing this:\n  edge \\<Gamma> x z\n\ngoal (1 subgoal):\n 1. path (bipartite_web_of \\<Gamma>) (Inl x) [Inr z] (Inr z)", "by(simp add: rtrancl_path_simps)"], ["proof (state)\nthis:\n  path (bipartite_web_of \\<Gamma>) (Inl x) [Inr z] (Inr z)\n\ngoal (1 subgoal):\n 1. \\<And>x y ys z.\n       \\<lbrakk>edge \\<Gamma> x y; path \\<Gamma> y ys z;\n        \\<lbrakk>Inl y\n                 \\<notin> TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f;\n         z \\<in> B \\<Gamma>; set (y # ys) \\<subseteq> set p\\<rbrakk>\n        \\<Longrightarrow> False;\n        Inl x \\<notin> TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f;\n        z \\<in> B \\<Gamma>; set (x # y # ys) \\<subseteq> set p\\<rbrakk>\n       \\<Longrightarrow> False", "from separatingD[OF waveD_separating[OF w] this] step.prems(1) step.prems(3) bypass[of z] x \\<open>edge \\<Gamma> x z\\<close>"], ["proof (chain)\npicking this:\n  \\<lbrakk>Inl x \\<in> A (bipartite_web_of \\<Gamma>);\n   Inr z \\<in> B (bipartite_web_of \\<Gamma>)\\<rbrakk>\n  \\<Longrightarrow> (\\<exists>z\\<in>set [Inr z].\n                        z \\<in> TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub>\n                                 f) \\<or>\n                    Inl x\n                    \\<in> TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f\n  Inl x \\<notin> TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f\n  set (x # z # p') \\<subseteq> set p\n  z \\<in> set p \\<Longrightarrow> z \\<notin> TER (\\<lambda>_. 0)\n  vertex \\<Gamma> x\n  edge \\<Gamma> x z", "have \"Inr z \\<in> ?TER\""], ["proof (prove)\nusing this:\n  \\<lbrakk>Inl x \\<in> A (bipartite_web_of \\<Gamma>);\n   Inr z \\<in> B (bipartite_web_of \\<Gamma>)\\<rbrakk>\n  \\<Longrightarrow> (\\<exists>z\\<in>set [Inr z].\n                        z \\<in> TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub>\n                                 f) \\<or>\n                    Inl x\n                    \\<in> TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f\n  Inl x \\<notin> TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f\n  set (x # z # p') \\<subseteq> set p\n  z \\<in> set p \\<Longrightarrow> z \\<notin> TER (\\<lambda>_. 0)\n  vertex \\<Gamma> x\n  edge \\<Gamma> x z\n\ngoal (1 subgoal):\n 1. Inr z \\<in> TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f", "by(force simp add: B_out inj_image_mem_iff)"], ["proof (state)\nthis:\n  Inr z \\<in> TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f\n\ngoal (1 subgoal):\n 1. \\<And>x y ys z.\n       \\<lbrakk>edge \\<Gamma> x y; path \\<Gamma> y ys z;\n        \\<lbrakk>Inl y\n                 \\<notin> TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f;\n         z \\<in> B \\<Gamma>; set (y # ys) \\<subseteq> set p\\<rbrakk>\n        \\<Longrightarrow> False;\n        Inl x \\<notin> TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f;\n        z \\<in> B \\<Gamma>; set (x # y # ys) \\<subseteq> set p\\<rbrakk>\n       \\<Longrightarrow> False", "with bypass[of z] step.prems(3) \\<open>edge \\<Gamma> x z\\<close>"], ["proof (chain)\npicking this:\n  z \\<in> set p \\<Longrightarrow> z \\<notin> TER (\\<lambda>_. 0)\n  set (x # z # p') \\<subseteq> set p\n  edge \\<Gamma> x z\n  Inr z \\<in> TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f", "have \"d_IN f (Inr z) > 0\""], ["proof (prove)\nusing this:\n  z \\<in> set p \\<Longrightarrow> z \\<notin> TER (\\<lambda>_. 0)\n  set (x # z # p') \\<subseteq> set p\n  edge \\<Gamma> x z\n  Inr z \\<in> TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f\n\ngoal (1 subgoal):\n 1. 0 < d_IN f (Inr z)", "by(auto simp add: currentD_SAT[OF f] A_in zero_less_iff_neq_zero)"], ["proof (state)\nthis:\n  0 < d_IN f (Inr z)\n\ngoal (1 subgoal):\n 1. \\<And>x y ys z.\n       \\<lbrakk>edge \\<Gamma> x y; path \\<Gamma> y ys z;\n        \\<lbrakk>Inl y\n                 \\<notin> TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f;\n         z \\<in> B \\<Gamma>; set (y # ys) \\<subseteq> set p\\<rbrakk>\n        \\<Longrightarrow> False;\n        Inl x \\<notin> TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f;\n        z \\<in> B \\<Gamma>; set (x # y # ys) \\<subseteq> set p\\<rbrakk>\n       \\<Longrightarrow> False", "hence x: \"Inl z \\<notin> ?TER\""], ["proof (prove)\nusing this:\n  0 < d_IN f (Inr z)\n\ngoal (1 subgoal):\n 1. Inl z \\<notin> TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f", "by(auto simp add: SINK.simps OUT IN)"], ["proof (state)\nthis:\n  Inl z \\<notin> TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f\n\ngoal (1 subgoal):\n 1. \\<And>x y ys z.\n       \\<lbrakk>edge \\<Gamma> x y; path \\<Gamma> y ys z;\n        \\<lbrakk>Inl y\n                 \\<notin> TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f;\n         z \\<in> B \\<Gamma>; set (y # ys) \\<subseteq> set p\\<rbrakk>\n        \\<Longrightarrow> False;\n        Inl x \\<notin> TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f;\n        z \\<in> B \\<Gamma>; set (x # y # ys) \\<subseteq> set p\\<rbrakk>\n       \\<Longrightarrow> False", "with step.IH[OF this] step.prems(2,3)"], ["proof (chain)\npicking this:\n  \\<lbrakk>y \\<in> B \\<Gamma>; set (z # p') \\<subseteq> set p\\<rbrakk>\n  \\<Longrightarrow> False\n  y \\<in> B \\<Gamma>\n  set (x # z # p') \\<subseteq> set p\n  Inl z \\<notin> TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f", "show False"], ["proof (prove)\nusing this:\n  \\<lbrakk>y \\<in> B \\<Gamma>; set (z # p') \\<subseteq> set p\\<rbrakk>\n  \\<Longrightarrow> False\n  y \\<in> B \\<Gamma>\n  set (x # z # p') \\<subseteq> set p\n  Inl z \\<notin> TER\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> f\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  a' \\<notin> \\<E> (TER (\\<lambda>_. 0))\n\ngoal (1 subgoal):\n 1. hindered (bipartite_web_of \\<Gamma>) \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  a' \\<notin> \\<E> (TER (\\<lambda>_. 0))\n\ngoal (1 subgoal):\n 1. hindered (bipartite_web_of \\<Gamma>) \\<Longrightarrow> False", "have \"d_OUT zero_current a' < weight \\<Gamma> a'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT (\\<lambda>_. 0) a' < weight \\<Gamma> a'", "using OUT_a a' b"], ["proof (prove)\nusing this:\n  d_OUT f a < weight (bipartite_web_of \\<Gamma>) a\n  a = Inl a'\n  a' \\<notin> B \\<Gamma>\n\ngoal (1 subgoal):\n 1. d_OUT (\\<lambda>_. 0) a' < weight \\<Gamma> a'", "by (auto simp: zero_less_iff_neq_zero)"], ["proof (state)\nthis:\n  d_OUT (\\<lambda>_. 0) a' < weight \\<Gamma> a'\n\ngoal (1 subgoal):\n 1. hindered (bipartite_web_of \\<Gamma>) \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  a' \\<in> A \\<Gamma>\n  a' \\<notin> \\<E> (TER (\\<lambda>_. 0))\n  d_OUT (\\<lambda>_. 0) a' < weight \\<Gamma> a'", "have \"hindrance \\<Gamma> zero_current\""], ["proof (prove)\nusing this:\n  a' \\<in> A \\<Gamma>\n  a' \\<notin> \\<E> (TER (\\<lambda>_. 0))\n  d_OUT (\\<lambda>_. 0) a' < weight \\<Gamma> a'\n\ngoal (1 subgoal):\n 1. hindrance \\<Gamma> (\\<lambda>_. 0)", "by(rule hindrance)"], ["proof (state)\nthis:\n  hindrance \\<Gamma> (\\<lambda>_. 0)\n\ngoal (1 subgoal):\n 1. hindered (bipartite_web_of \\<Gamma>) \\<Longrightarrow> False", "with looseD_hindrance[OF loose]"], ["proof (chain)\npicking this:\n  \\<not> hindrance \\<Gamma> (\\<lambda>_. 0)\n  hindrance \\<Gamma> (\\<lambda>_. 0)", "show False"], ["proof (prove)\nusing this:\n  \\<not> hindrance \\<Gamma> (\\<lambda>_. 0)\n  hindrance \\<Gamma> (\\<lambda>_. 0)\n\ngoal (1 subgoal):\n 1. False", "by contradiction"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in -) divide_less_1_iff_ennreal: \"a / b < (1::ennreal) \\<longleftrightarrow> (0 < b \\<and> a < b \\<or> b = 0 \\<and> a = 0 \\<or> b = top)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a / b < 1) =\n    (0 < b \\<and> a < b \\<or> b = 0 \\<and> a = 0 \\<or> b = \\<top>)", "by (cases a; cases b; cases \"b = 0\")\n     (auto simp: divide_ennreal ennreal_less_iff ennreal_top_divide)"], ["", "lemma linkable_bipartite_web_ofD:\n  assumes link: \"linkable (bipartite_web_of \\<Gamma>)\" (is \"linkable ?\\<Gamma>\")\n  and countable: \"countable \\<^bold>E\"\n  shows \"linkable \\<Gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. linkable \\<Gamma>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. linkable \\<Gamma>", "from link"], ["proof (chain)\npicking this:\n  linkable (bipartite_web_of \\<Gamma>)", "obtain f where wf: \"web_flow ?\\<Gamma> f\" and link: \"linkage ?\\<Gamma> f\""], ["proof (prove)\nusing this:\n  linkable (bipartite_web_of \\<Gamma>)\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        \\<lbrakk>web_flow (bipartite_web_of \\<Gamma>) f;\n         linkage (bipartite_web_of \\<Gamma>) f\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  web_flow (bipartite_web_of \\<Gamma>) f\n  linkage (bipartite_web_of \\<Gamma>) f\n\ngoal (1 subgoal):\n 1. linkable \\<Gamma>", "from wf"], ["proof (chain)\npicking this:\n  web_flow (bipartite_web_of \\<Gamma>) f", "have f: \"current ?\\<Gamma> f\""], ["proof (prove)\nusing this:\n  web_flow (bipartite_web_of \\<Gamma>) f\n\ngoal (1 subgoal):\n 1. current (bipartite_web_of \\<Gamma>) f", "by(rule web_flowD_current)"], ["proof (state)\nthis:\n  current (bipartite_web_of \\<Gamma>) f\n\ngoal (1 subgoal):\n 1. linkable \\<Gamma>", "define f' where \"f' = current_of_bipartite f\""], ["proof (state)\nthis:\n  f' = current_of_bipartite f\n\ngoal (1 subgoal):\n 1. linkable \\<Gamma>", "have IN_le_OUT: \"d_IN f' x \\<le> d_OUT f' x\" if \"x \\<notin> B \\<Gamma>\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN f' x \\<le> d_OUT f' x", "proof(cases \"x \\<in> \\<^bold>V\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<in> \\<^bold>V \\<Longrightarrow> d_IN f' x \\<le> d_OUT f' x\n 2. x \\<notin> \\<^bold>V \\<Longrightarrow> d_IN f' x \\<le> d_OUT f' x", "case True"], ["proof (state)\nthis:\n  x \\<in> \\<^bold>V\n\ngoal (2 subgoals):\n 1. x \\<in> \\<^bold>V \\<Longrightarrow> d_IN f' x \\<le> d_OUT f' x\n 2. x \\<notin> \\<^bold>V \\<Longrightarrow> d_IN f' x \\<le> d_OUT f' x", "have \"d_IN f' x = d_IN f (Inr x) - f (Inl x, Inr x)\" (is \"_ = _ - ?rest\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN f' x = d_IN f (Inr x) - f (Inl x, Inr x)", "by(simp add: f'_def d_IN_current_of_bipartite[OF f])"], ["proof (state)\nthis:\n  d_IN f' x = d_IN f (Inr x) - f (Inl x, Inr x)\n\ngoal (2 subgoals):\n 1. x \\<in> \\<^bold>V \\<Longrightarrow> d_IN f' x \\<le> d_OUT f' x\n 2. x \\<notin> \\<^bold>V \\<Longrightarrow> d_IN f' x \\<le> d_OUT f' x", "also"], ["proof (state)\nthis:\n  d_IN f' x = d_IN f (Inr x) - f (Inl x, Inr x)\n\ngoal (2 subgoals):\n 1. x \\<in> \\<^bold>V \\<Longrightarrow> d_IN f' x \\<le> d_OUT f' x\n 2. x \\<notin> \\<^bold>V \\<Longrightarrow> d_IN f' x \\<le> d_OUT f' x", "have \"\\<dots> \\<le> weight ?\\<Gamma> (Inr x) - ?rest\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN f (Inr x) - f (Inl x, Inr x)\n    \\<le> weight (bipartite_web_of \\<Gamma>) (Inr x) - f (Inl x, Inr x)", "using currentD_weight_IN[OF f, of \"Inr x\"]"], ["proof (prove)\nusing this:\n  d_IN f (Inr x) \\<le> weight (bipartite_web_of \\<Gamma>) (Inr x)\n\ngoal (1 subgoal):\n 1. d_IN f (Inr x) - f (Inl x, Inr x)\n    \\<le> weight (bipartite_web_of \\<Gamma>) (Inr x) - f (Inl x, Inr x)", "by(rule ennreal_minus_mono) simp"], ["proof (state)\nthis:\n  d_IN f (Inr x) - f (Inl x, Inr x)\n  \\<le> weight (bipartite_web_of \\<Gamma>) (Inr x) - f (Inl x, Inr x)\n\ngoal (2 subgoals):\n 1. x \\<in> \\<^bold>V \\<Longrightarrow> d_IN f' x \\<le> d_OUT f' x\n 2. x \\<notin> \\<^bold>V \\<Longrightarrow> d_IN f' x \\<le> d_OUT f' x", "also"], ["proof (state)\nthis:\n  d_IN f (Inr x) - f (Inl x, Inr x)\n  \\<le> weight (bipartite_web_of \\<Gamma>) (Inr x) - f (Inl x, Inr x)\n\ngoal (2 subgoals):\n 1. x \\<in> \\<^bold>V \\<Longrightarrow> d_IN f' x \\<le> d_OUT f' x\n 2. x \\<notin> \\<^bold>V \\<Longrightarrow> d_IN f' x \\<le> d_OUT f' x", "have \"\\<dots> \\<le> weight ?\\<Gamma> (Inl x) - ?rest\""], ["proof (prove)\ngoal (1 subgoal):\n 1. weight (bipartite_web_of \\<Gamma>) (Inr x) - f (Inl x, Inr x)\n    \\<le> weight (bipartite_web_of \\<Gamma>) (Inl x) - f (Inl x, Inr x)", "using that ennreal_minus_mono"], ["proof (prove)\nusing this:\n  x \\<notin> B \\<Gamma>\n  \\<lbrakk>?a \\<le> ?c; ?d \\<le> ?b\\<rbrakk>\n  \\<Longrightarrow> ?a - ?b \\<le> ?c - ?d\n\ngoal (1 subgoal):\n 1. weight (bipartite_web_of \\<Gamma>) (Inr x) - f (Inl x, Inr x)\n    \\<le> weight (bipartite_web_of \\<Gamma>) (Inl x) - f (Inl x, Inr x)", "by(auto)"], ["proof (state)\nthis:\n  weight (bipartite_web_of \\<Gamma>) (Inr x) - f (Inl x, Inr x)\n  \\<le> weight (bipartite_web_of \\<Gamma>) (Inl x) - f (Inl x, Inr x)\n\ngoal (2 subgoals):\n 1. x \\<in> \\<^bold>V \\<Longrightarrow> d_IN f' x \\<le> d_OUT f' x\n 2. x \\<notin> \\<^bold>V \\<Longrightarrow> d_IN f' x \\<le> d_OUT f' x", "also"], ["proof (state)\nthis:\n  weight (bipartite_web_of \\<Gamma>) (Inr x) - f (Inl x, Inr x)\n  \\<le> weight (bipartite_web_of \\<Gamma>) (Inl x) - f (Inl x, Inr x)\n\ngoal (2 subgoals):\n 1. x \\<in> \\<^bold>V \\<Longrightarrow> d_IN f' x \\<le> d_OUT f' x\n 2. x \\<notin> \\<^bold>V \\<Longrightarrow> d_IN f' x \\<le> d_OUT f' x", "have \"weight ?\\<Gamma> (Inl x) = d_OUT f (Inl x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. weight (bipartite_web_of \\<Gamma>) (Inl x) = d_OUT f (Inl x)", "using that linkageD[OF link, of \"Inl x\"] True"], ["proof (prove)\nusing this:\n  x \\<notin> B \\<Gamma>\n  Inl x \\<in> A (bipartite_web_of \\<Gamma>) \\<Longrightarrow>\n  d_OUT f (Inl x) = weight (bipartite_web_of \\<Gamma>) (Inl x)\n  x \\<in> \\<^bold>V\n\ngoal (1 subgoal):\n 1. weight (bipartite_web_of \\<Gamma>) (Inl x) = d_OUT f (Inl x)", "by auto"], ["proof (state)\nthis:\n  weight (bipartite_web_of \\<Gamma>) (Inl x) = d_OUT f (Inl x)\n\ngoal (2 subgoals):\n 1. x \\<in> \\<^bold>V \\<Longrightarrow> d_IN f' x \\<le> d_OUT f' x\n 2. x \\<notin> \\<^bold>V \\<Longrightarrow> d_IN f' x \\<le> d_OUT f' x", "also"], ["proof (state)\nthis:\n  weight (bipartite_web_of \\<Gamma>) (Inl x) = d_OUT f (Inl x)\n\ngoal (2 subgoals):\n 1. x \\<in> \\<^bold>V \\<Longrightarrow> d_IN f' x \\<le> d_OUT f' x\n 2. x \\<notin> \\<^bold>V \\<Longrightarrow> d_IN f' x \\<le> d_OUT f' x", "have \"\\<dots> - ?rest = d_OUT f' x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT f (Inl x) - f (Inl x, Inr x) = d_OUT f' x", "by(simp add: f'_def d_OUT_current_of_bipartite[OF f])"], ["proof (state)\nthis:\n  d_OUT f (Inl x) - f (Inl x, Inr x) = d_OUT f' x\n\ngoal (2 subgoals):\n 1. x \\<in> \\<^bold>V \\<Longrightarrow> d_IN f' x \\<le> d_OUT f' x\n 2. x \\<notin> \\<^bold>V \\<Longrightarrow> d_IN f' x \\<le> d_OUT f' x", "finally"], ["proof (chain)\npicking this:\n  d_IN f' x \\<le> d_OUT f' x", "show ?thesis"], ["proof (prove)\nusing this:\n  d_IN f' x \\<le> d_OUT f' x\n\ngoal (1 subgoal):\n 1. d_IN f' x \\<le> d_OUT f' x", "."], ["proof (state)\nthis:\n  d_IN f' x \\<le> d_OUT f' x\n\ngoal (1 subgoal):\n 1. x \\<notin> \\<^bold>V \\<Longrightarrow> d_IN f' x \\<le> d_OUT f' x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<notin> \\<^bold>V \\<Longrightarrow> d_IN f' x \\<le> d_OUT f' x", "case False"], ["proof (state)\nthis:\n  x \\<notin> \\<^bold>V\n\ngoal (1 subgoal):\n 1. x \\<notin> \\<^bold>V \\<Longrightarrow> d_IN f' x \\<le> d_OUT f' x", "with currentD_outside_OUT[OF f, of \"Inl x\"] currentD_outside_IN[OF f, of \"Inr x\"]"], ["proof (chain)\npicking this:\n  Inl x\n  \\<notin> \\<^bold>V\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> \\<Longrightarrow>\n  d_OUT f (Inl x) = 0\n  Inr x\n  \\<notin> \\<^bold>V\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> \\<Longrightarrow>\n  d_IN f (Inr x) = 0\n  x \\<notin> \\<^bold>V", "show ?thesis"], ["proof (prove)\nusing this:\n  Inl x\n  \\<notin> \\<^bold>V\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> \\<Longrightarrow>\n  d_OUT f (Inl x) = 0\n  Inr x\n  \\<notin> \\<^bold>V\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> \\<Longrightarrow>\n  d_IN f (Inr x) = 0\n  x \\<notin> \\<^bold>V\n\ngoal (1 subgoal):\n 1. d_IN f' x \\<le> d_OUT f' x", "by(simp add: f'_def d_IN_current_of_bipartite[OF f] d_OUT_current_of_bipartite[OF f])"], ["proof (state)\nthis:\n  d_IN f' x \\<le> d_OUT f' x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?x \\<notin> B \\<Gamma> \\<Longrightarrow> d_IN f' ?x \\<le> d_OUT f' ?x\n\ngoal (1 subgoal):\n 1. linkable \\<Gamma>", "have link: \"linkage \\<Gamma> f'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. linkage \\<Gamma> f'", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> A \\<Gamma> \\<Longrightarrow> d_OUT f' x = weight \\<Gamma> x", "show \"d_OUT f' a = weight \\<Gamma> a\" if \"a \\<in> A \\<Gamma>\" for a"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT f' a = weight \\<Gamma> a", "proof(cases \"a \\<in> \\<^bold>V\")"], ["proof (state)\ngoal (2 subgoals):\n 1. a \\<in> \\<^bold>V \\<Longrightarrow> d_OUT f' a = weight \\<Gamma> a\n 2. a \\<notin> \\<^bold>V \\<Longrightarrow> d_OUT f' a = weight \\<Gamma> a", "case True"], ["proof (state)\nthis:\n  a \\<in> \\<^bold>V\n\ngoal (2 subgoals):\n 1. a \\<in> \\<^bold>V \\<Longrightarrow> d_OUT f' a = weight \\<Gamma> a\n 2. a \\<notin> \\<^bold>V \\<Longrightarrow> d_OUT f' a = weight \\<Gamma> a", "from that"], ["proof (chain)\npicking this:\n  a \\<in> A \\<Gamma>", "have \"a \\<notin> B \\<Gamma>\""], ["proof (prove)\nusing this:\n  a \\<in> A \\<Gamma>\n\ngoal (1 subgoal):\n 1. a \\<notin> B \\<Gamma>", "using disjoint"], ["proof (prove)\nusing this:\n  a \\<in> A \\<Gamma>\n  A \\<Gamma> \\<inter> B \\<Gamma> = {}\n\ngoal (1 subgoal):\n 1. a \\<notin> B \\<Gamma>", "by auto"], ["proof (state)\nthis:\n  a \\<notin> B \\<Gamma>\n\ngoal (2 subgoals):\n 1. a \\<in> \\<^bold>V \\<Longrightarrow> d_OUT f' a = weight \\<Gamma> a\n 2. a \\<notin> \\<^bold>V \\<Longrightarrow> d_OUT f' a = weight \\<Gamma> a", "with that True linkageD[OF link, of \"Inl a\"] ennreal_minus_cancel_iff[of _ _ 0] currentD_outside[OF f, of \"Inl a\" \"Inr a\"]"], ["proof (chain)\npicking this:\n  a \\<in> A \\<Gamma>\n  a \\<in> \\<^bold>V\n  Inl a \\<in> A (bipartite_web_of \\<Gamma>) \\<Longrightarrow>\n  d_OUT f (Inl a) = weight (bipartite_web_of \\<Gamma>) (Inl a)\n  (?a - ?b = ?a - 0) =\n  (?b = 0 \\<or> ?a \\<le> ?b \\<and> ?a \\<le> 0 \\<or> ?a = \\<top>)\n  \\<not> edge (bipartite_web_of \\<Gamma>) (Inl a) (Inr a) \\<Longrightarrow>\n  f (Inl a, Inr a) = 0\n  a \\<notin> B \\<Gamma>", "show ?thesis"], ["proof (prove)\nusing this:\n  a \\<in> A \\<Gamma>\n  a \\<in> \\<^bold>V\n  Inl a \\<in> A (bipartite_web_of \\<Gamma>) \\<Longrightarrow>\n  d_OUT f (Inl a) = weight (bipartite_web_of \\<Gamma>) (Inl a)\n  (?a - ?b = ?a - 0) =\n  (?b = 0 \\<or> ?a \\<le> ?b \\<and> ?a \\<le> 0 \\<or> ?a = \\<top>)\n  \\<not> edge (bipartite_web_of \\<Gamma>) (Inl a) (Inr a) \\<Longrightarrow>\n  f (Inl a, Inr a) = 0\n  a \\<notin> B \\<Gamma>\n\ngoal (1 subgoal):\n 1. d_OUT f' a = weight \\<Gamma> a", "by(clarsimp simp add: f'_def d_OUT_current_of_bipartite[OF f] max_def no_loop)"], ["proof (state)\nthis:\n  d_OUT f' a = weight \\<Gamma> a\n\ngoal (1 subgoal):\n 1. a \\<notin> \\<^bold>V \\<Longrightarrow> d_OUT f' a = weight \\<Gamma> a", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. a \\<notin> \\<^bold>V \\<Longrightarrow> d_OUT f' a = weight \\<Gamma> a", "case False"], ["proof (state)\nthis:\n  a \\<notin> \\<^bold>V\n\ngoal (1 subgoal):\n 1. a \\<notin> \\<^bold>V \\<Longrightarrow> d_OUT f' a = weight \\<Gamma> a", "with weight_outside[OF this] currentD_outside[OF f, of \"Inl a\" \"Inr a\"] currentD_outside_OUT[OF f, of \"Inl a\"]"], ["proof (chain)\npicking this:\n  weight \\<Gamma> a = 0\n  \\<not> edge (bipartite_web_of \\<Gamma>) (Inl a) (Inr a) \\<Longrightarrow>\n  f (Inl a, Inr a) = 0\n  Inl a\n  \\<notin> \\<^bold>V\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> \\<Longrightarrow>\n  d_OUT f (Inl a) = 0\n  a \\<notin> \\<^bold>V", "show ?thesis"], ["proof (prove)\nusing this:\n  weight \\<Gamma> a = 0\n  \\<not> edge (bipartite_web_of \\<Gamma>) (Inl a) (Inr a) \\<Longrightarrow>\n  f (Inl a, Inr a) = 0\n  Inl a\n  \\<notin> \\<^bold>V\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> \\<Longrightarrow>\n  d_OUT f (Inl a) = 0\n  a \\<notin> \\<^bold>V\n\ngoal (1 subgoal):\n 1. d_OUT f' a = weight \\<Gamma> a", "by(simp add: f'_def d_OUT_current_of_bipartite[OF f] no_loop)"], ["proof (state)\nthis:\n  d_OUT f' a = weight \\<Gamma> a\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?a \\<in> A \\<Gamma> \\<Longrightarrow> d_OUT f' ?a = weight \\<Gamma> ?a\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  linkage \\<Gamma> f'\n\ngoal (1 subgoal):\n 1. linkable \\<Gamma>", "define F where \"F = {g. (\\<forall>e. 0 \\<le> g e) \\<and> (\\<forall>e. e \\<notin> \\<^bold>E \\<longrightarrow> g e = 0) \\<and>\n    (\\<forall>x. x \\<notin> B \\<Gamma> \\<longrightarrow> d_IN g x \\<le> d_OUT g x) \\<and>\n    linkage \\<Gamma> g \\<and>\n    (\\<forall>x\\<in>A \\<Gamma>. d_IN g x = 0) \\<and>\n    (\\<forall>x. d_OUT g x \\<le> weight \\<Gamma> x) \\<and>\n    (\\<forall>x. d_IN g x \\<le> weight \\<Gamma> x) \\<and>\n    (\\<forall>x\\<in>B \\<Gamma>. d_OUT g x = 0) \\<and> g \\<le> f'}\""], ["proof (state)\nthis:\n  F =\n  {g. (\\<forall>e. 0 \\<le> g e) \\<and>\n      (\\<forall>e. e \\<notin> \\<^bold>E \\<longrightarrow> g e = 0) \\<and>\n      (\\<forall>x.\n          x \\<notin> B \\<Gamma> \\<longrightarrow>\n          d_IN g x \\<le> d_OUT g x) \\<and>\n      linkage \\<Gamma> g \\<and>\n      (\\<forall>x\\<in>A \\<Gamma>. d_IN g x = 0) \\<and>\n      (\\<forall>x. d_OUT g x \\<le> weight \\<Gamma> x) \\<and>\n      (\\<forall>x. d_IN g x \\<le> weight \\<Gamma> x) \\<and>\n      (\\<forall>x\\<in>B \\<Gamma>. d_OUT g x = 0) \\<and> g \\<le> f'}\n\ngoal (1 subgoal):\n 1. linkable \\<Gamma>", "define leq where \"leq = restrict_rel F {(f, f'). f' \\<le> f}\""], ["proof (state)\nthis:\n  leq = restrict_rel F {(f, f'). f' \\<le> f}\n\ngoal (1 subgoal):\n 1. linkable \\<Gamma>", "have F: \"Field leq = F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Field leq = F", "by(auto simp add: leq_def)"], ["proof (state)\nthis:\n  Field leq = F\n\ngoal (1 subgoal):\n 1. linkable \\<Gamma>", "have F_I [intro?]: \"f \\<in> Field leq\" if \"\\<And>e. 0 \\<le> f e\" and \"\\<And>e. e \\<notin> \\<^bold>E \\<Longrightarrow> f e = 0\"\n    and \"\\<And>x. x \\<notin> B \\<Gamma> \\<Longrightarrow> d_IN f x \\<le> d_OUT f x\" and \"linkage \\<Gamma> f\"\n    and \"\\<And>x. x \\<in> A \\<Gamma> \\<Longrightarrow> d_IN f x = 0\" and \"\\<And>x. d_OUT f x \\<le> weight \\<Gamma> x\"\n    and \"\\<And>x. d_IN f x \\<le> weight \\<Gamma> x\" and \"\\<And>x. x \\<in> B \\<Gamma> \\<Longrightarrow> d_OUT f x = 0\"\n    and \"f \\<le> f'\" for f"], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<in> Field leq", "using that"], ["proof (prove)\nusing this:\n  0 \\<le> f ?e\n  ?e \\<notin> \\<^bold>E \\<Longrightarrow> f ?e = 0\n  ?x \\<notin> B \\<Gamma> \\<Longrightarrow> d_IN f ?x \\<le> d_OUT f ?x\n  linkage \\<Gamma> f\n  ?x \\<in> A \\<Gamma> \\<Longrightarrow> d_IN f ?x = 0\n  d_OUT f ?x \\<le> weight \\<Gamma> ?x\n  d_IN f ?x \\<le> weight \\<Gamma> ?x\n  ?x \\<in> B \\<Gamma> \\<Longrightarrow> d_OUT f ?x = 0\n  f \\<le> f'\n\ngoal (1 subgoal):\n 1. f \\<in> Field leq", "by(simp add: F F_def)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<And>e. 0 \\<le> ?f e;\n   \\<And>e. e \\<notin> \\<^bold>E \\<Longrightarrow> ?f e = 0;\n   \\<And>x.\n      x \\<notin> B \\<Gamma> \\<Longrightarrow> d_IN ?f x \\<le> d_OUT ?f x;\n   linkage \\<Gamma> ?f;\n   \\<And>x. x \\<in> A \\<Gamma> \\<Longrightarrow> d_IN ?f x = 0;\n   \\<And>x. d_OUT ?f x \\<le> weight \\<Gamma> x;\n   \\<And>x. d_IN ?f x \\<le> weight \\<Gamma> x;\n   \\<And>x. x \\<in> B \\<Gamma> \\<Longrightarrow> d_OUT ?f x = 0;\n   ?f \\<le> f'\\<rbrakk>\n  \\<Longrightarrow> ?f \\<in> Field leq\n\ngoal (1 subgoal):\n 1. linkable \\<Gamma>", "have F_nonneg: \"0 \\<le> f e\" if \"f \\<in> Field leq\" for f e"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> f e", "using that"], ["proof (prove)\nusing this:\n  f \\<in> Field leq\n\ngoal (1 subgoal):\n 1. 0 \\<le> f e", "by(cases e)(simp add: F F_def)"], ["proof (state)\nthis:\n  ?f \\<in> Field leq \\<Longrightarrow> 0 \\<le> ?f ?e\n\ngoal (1 subgoal):\n 1. linkable \\<Gamma>", "have F_outside: \"f e = 0\" if \"f \\<in> Field leq\" \"e \\<notin> \\<^bold>E\" for f e"], ["proof (prove)\ngoal (1 subgoal):\n 1. f e = 0", "using that"], ["proof (prove)\nusing this:\n  f \\<in> Field leq\n  e \\<notin> \\<^bold>E\n\ngoal (1 subgoal):\n 1. f e = 0", "by(cases e)(simp add: F F_def)"], ["proof (state)\nthis:\n  \\<lbrakk>?f \\<in> Field leq; ?e \\<notin> \\<^bold>E\\<rbrakk>\n  \\<Longrightarrow> ?f ?e = 0\n\ngoal (1 subgoal):\n 1. linkable \\<Gamma>", "have F_IN_OUT: \"d_IN f x \\<le> d_OUT f x\" if \"f \\<in> Field leq\" \"x \\<notin> B \\<Gamma>\" for f x"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN f x \\<le> d_OUT f x", "using that"], ["proof (prove)\nusing this:\n  f \\<in> Field leq\n  x \\<notin> B \\<Gamma>\n\ngoal (1 subgoal):\n 1. d_IN f x \\<le> d_OUT f x", "by(simp add: F F_def)"], ["proof (state)\nthis:\n  \\<lbrakk>?f \\<in> Field leq; ?x \\<notin> B \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> d_IN ?f ?x \\<le> d_OUT ?f ?x\n\ngoal (1 subgoal):\n 1. linkable \\<Gamma>", "have F_link: \"linkage \\<Gamma> f\" if \"f \\<in> Field leq\" for f"], ["proof (prove)\ngoal (1 subgoal):\n 1. linkage \\<Gamma> f", "using that"], ["proof (prove)\nusing this:\n  f \\<in> Field leq\n\ngoal (1 subgoal):\n 1. linkage \\<Gamma> f", "by(simp add: F F_def)"], ["proof (state)\nthis:\n  ?f \\<in> Field leq \\<Longrightarrow> linkage \\<Gamma> ?f\n\ngoal (1 subgoal):\n 1. linkable \\<Gamma>", "have F_IN: \"d_IN f x = 0\" if \"f \\<in> Field leq\" \"x \\<in> A \\<Gamma>\" for f x"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN f x = 0", "using that"], ["proof (prove)\nusing this:\n  f \\<in> Field leq\n  x \\<in> A \\<Gamma>\n\ngoal (1 subgoal):\n 1. d_IN f x = 0", "by(simp add: F F_def)"], ["proof (state)\nthis:\n  \\<lbrakk>?f \\<in> Field leq; ?x \\<in> A \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> d_IN ?f ?x = 0\n\ngoal (1 subgoal):\n 1. linkable \\<Gamma>", "have F_OUT: \"d_OUT f x = 0\" if \"f \\<in> Field leq\" \"x \\<in> B \\<Gamma>\" for f x"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT f x = 0", "using that"], ["proof (prove)\nusing this:\n  f \\<in> Field leq\n  x \\<in> B \\<Gamma>\n\ngoal (1 subgoal):\n 1. d_OUT f x = 0", "by(simp add: F F_def)"], ["proof (state)\nthis:\n  \\<lbrakk>?f \\<in> Field leq; ?x \\<in> B \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> d_OUT ?f ?x = 0\n\ngoal (1 subgoal):\n 1. linkable \\<Gamma>", "have F_weight_OUT: \"d_OUT f x \\<le> weight \\<Gamma> x\" if \"f \\<in> Field leq\" for f x"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT f x \\<le> weight \\<Gamma> x", "using that"], ["proof (prove)\nusing this:\n  f \\<in> Field leq\n\ngoal (1 subgoal):\n 1. d_OUT f x \\<le> weight \\<Gamma> x", "by(simp add: F F_def)"], ["proof (state)\nthis:\n  ?f \\<in> Field leq \\<Longrightarrow> d_OUT ?f ?x \\<le> weight \\<Gamma> ?x\n\ngoal (1 subgoal):\n 1. linkable \\<Gamma>", "have F_weight_IN: \"d_IN f x \\<le> weight \\<Gamma> x\" if \"f \\<in> Field leq\" for f x"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN f x \\<le> weight \\<Gamma> x", "using that"], ["proof (prove)\nusing this:\n  f \\<in> Field leq\n\ngoal (1 subgoal):\n 1. d_IN f x \\<le> weight \\<Gamma> x", "by(simp add: F F_def)"], ["proof (state)\nthis:\n  ?f \\<in> Field leq \\<Longrightarrow> d_IN ?f ?x \\<le> weight \\<Gamma> ?x\n\ngoal (1 subgoal):\n 1. linkable \\<Gamma>", "have F_le: \"f e \\<le> f' e\" if \"f \\<in> Field leq\" for f e"], ["proof (prove)\ngoal (1 subgoal):\n 1. f e \\<le> f' e", "using that"], ["proof (prove)\nusing this:\n  f \\<in> Field leq\n\ngoal (1 subgoal):\n 1. f e \\<le> f' e", "by(cases e)(simp add: F F_def le_fun_def)"], ["proof (state)\nthis:\n  ?f \\<in> Field leq \\<Longrightarrow> ?f ?e \\<le> f' ?e\n\ngoal (1 subgoal):\n 1. linkable \\<Gamma>", "have F_finite_OUT: \"d_OUT f x \\<noteq> \\<top>\" if \"f \\<in> Field leq\" for f x"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT f x \\<noteq> \\<top>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. d_OUT f x \\<noteq> \\<top>", "have \"d_OUT f x \\<le> weight \\<Gamma> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT f x \\<le> weight \\<Gamma> x", "by(rule F_weight_OUT[OF that])"], ["proof (state)\nthis:\n  d_OUT f x \\<le> weight \\<Gamma> x\n\ngoal (1 subgoal):\n 1. d_OUT f x \\<noteq> \\<top>", "also"], ["proof (state)\nthis:\n  d_OUT f x \\<le> weight \\<Gamma> x\n\ngoal (1 subgoal):\n 1. d_OUT f x \\<noteq> \\<top>", "have \"\\<dots> < \\<top>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. weight \\<Gamma> x < \\<top>", "by(simp add: less_top[symmetric])"], ["proof (state)\nthis:\n  weight \\<Gamma> x < \\<top>\n\ngoal (1 subgoal):\n 1. d_OUT f x \\<noteq> \\<top>", "finally"], ["proof (chain)\npicking this:\n  d_OUT f x < \\<top>", "show ?thesis"], ["proof (prove)\nusing this:\n  d_OUT f x < \\<top>\n\ngoal (1 subgoal):\n 1. d_OUT f x \\<noteq> \\<top>", "by simp"], ["proof (state)\nthis:\n  d_OUT f x \\<noteq> \\<top>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?f \\<in> Field leq \\<Longrightarrow> d_OUT ?f ?x \\<noteq> \\<top>\n\ngoal (1 subgoal):\n 1. linkable \\<Gamma>", "have F_finite: \"f e \\<noteq> \\<top>\" if \"f \\<in> Field leq\" for f e"], ["proof (prove)\ngoal (1 subgoal):\n 1. f e \\<noteq> \\<top>", "proof(cases e)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b. e = (a, b) \\<Longrightarrow> f e \\<noteq> \\<top>", "case (Pair x y)"], ["proof (state)\nthis:\n  e = (x, y)\n\ngoal (1 subgoal):\n 1. \\<And>a b. e = (a, b) \\<Longrightarrow> f e \\<noteq> \\<top>", "have \"f e \\<le> d_OUT f x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f e \\<le> d_OUT f x", "unfolding Pair d_OUT_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. f (x, y) \\<le> (\\<Sum>\\<^sup>+ y. f (x, y))", "by(rule nn_integral_ge_point) simp"], ["proof (state)\nthis:\n  f e \\<le> d_OUT f x\n\ngoal (1 subgoal):\n 1. \\<And>a b. e = (a, b) \\<Longrightarrow> f e \\<noteq> \\<top>", "also"], ["proof (state)\nthis:\n  f e \\<le> d_OUT f x\n\ngoal (1 subgoal):\n 1. \\<And>a b. e = (a, b) \\<Longrightarrow> f e \\<noteq> \\<top>", "have \"\\<dots> < \\<top>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT f x < \\<top>", "by(simp add: F_finite_OUT[OF that] less_top[symmetric])"], ["proof (state)\nthis:\n  d_OUT f x < \\<top>\n\ngoal (1 subgoal):\n 1. \\<And>a b. e = (a, b) \\<Longrightarrow> f e \\<noteq> \\<top>", "finally"], ["proof (chain)\npicking this:\n  f e < \\<top>", "show ?thesis"], ["proof (prove)\nusing this:\n  f e < \\<top>\n\ngoal (1 subgoal):\n 1. f e \\<noteq> \\<top>", "by simp"], ["proof (state)\nthis:\n  f e \\<noteq> \\<top>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?f \\<in> Field leq \\<Longrightarrow> ?f ?e \\<noteq> \\<top>\n\ngoal (1 subgoal):\n 1. linkable \\<Gamma>", "have f': \"f' \\<in> Field leq\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f' \\<in> Field leq", "proof"], ["proof (state)\ngoal (9 subgoals):\n 1. \\<And>e. 0 \\<le> f' e\n 2. \\<And>e. e \\<notin> \\<^bold>E \\<Longrightarrow> f' e = 0\n 3. \\<And>x.\n       x \\<notin> B \\<Gamma> \\<Longrightarrow> d_IN f' x \\<le> d_OUT f' x\n 4. linkage \\<Gamma> f'\n 5. \\<And>x. x \\<in> A \\<Gamma> \\<Longrightarrow> d_IN f' x = 0\n 6. \\<And>x. d_OUT f' x \\<le> weight \\<Gamma> x\n 7. \\<And>x. d_IN f' x \\<le> weight \\<Gamma> x\n 8. \\<And>x. x \\<in> B \\<Gamma> \\<Longrightarrow> d_OUT f' x = 0\n 9. f' \\<le> f'", "show \"0 \\<le> f' e\" for e"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> f' e", "by(cases e)(simp add: f'_def)"], ["proof (state)\nthis:\n  0 \\<le> f' ?e\n\ngoal (8 subgoals):\n 1. \\<And>e. e \\<notin> \\<^bold>E \\<Longrightarrow> f' e = 0\n 2. \\<And>x.\n       x \\<notin> B \\<Gamma> \\<Longrightarrow> d_IN f' x \\<le> d_OUT f' x\n 3. linkage \\<Gamma> f'\n 4. \\<And>x. x \\<in> A \\<Gamma> \\<Longrightarrow> d_IN f' x = 0\n 5. \\<And>x. d_OUT f' x \\<le> weight \\<Gamma> x\n 6. \\<And>x. d_IN f' x \\<le> weight \\<Gamma> x\n 7. \\<And>x. x \\<in> B \\<Gamma> \\<Longrightarrow> d_OUT f' x = 0\n 8. f' \\<le> f'", "show \"f' e = 0\" if \"e \\<notin> \\<^bold>E\" for e"], ["proof (prove)\ngoal (1 subgoal):\n 1. f' e = 0", "using that"], ["proof (prove)\nusing this:\n  e \\<notin> \\<^bold>E\n\ngoal (1 subgoal):\n 1. f' e = 0", "by(clarsimp split: split_indicator_asm simp add: f'_def)"], ["proof (state)\nthis:\n  ?e \\<notin> \\<^bold>E \\<Longrightarrow> f' ?e = 0\n\ngoal (7 subgoals):\n 1. \\<And>x.\n       x \\<notin> B \\<Gamma> \\<Longrightarrow> d_IN f' x \\<le> d_OUT f' x\n 2. linkage \\<Gamma> f'\n 3. \\<And>x. x \\<in> A \\<Gamma> \\<Longrightarrow> d_IN f' x = 0\n 4. \\<And>x. d_OUT f' x \\<le> weight \\<Gamma> x\n 5. \\<And>x. d_IN f' x \\<le> weight \\<Gamma> x\n 6. \\<And>x. x \\<in> B \\<Gamma> \\<Longrightarrow> d_OUT f' x = 0\n 7. f' \\<le> f'", "show \"d_IN f' x \\<le> d_OUT f' x\" if \"x \\<notin> B \\<Gamma>\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN f' x \\<le> d_OUT f' x", "using that"], ["proof (prove)\nusing this:\n  x \\<notin> B \\<Gamma>\n\ngoal (1 subgoal):\n 1. d_IN f' x \\<le> d_OUT f' x", "by(rule IN_le_OUT)"], ["proof (state)\nthis:\n  ?x \\<notin> B \\<Gamma> \\<Longrightarrow> d_IN f' ?x \\<le> d_OUT f' ?x\n\ngoal (6 subgoals):\n 1. linkage \\<Gamma> f'\n 2. \\<And>x. x \\<in> A \\<Gamma> \\<Longrightarrow> d_IN f' x = 0\n 3. \\<And>x. d_OUT f' x \\<le> weight \\<Gamma> x\n 4. \\<And>x. d_IN f' x \\<le> weight \\<Gamma> x\n 5. \\<And>x. x \\<in> B \\<Gamma> \\<Longrightarrow> d_OUT f' x = 0\n 6. f' \\<le> f'", "show \"linkage \\<Gamma> f'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. linkage \\<Gamma> f'", "by(rule link)"], ["proof (state)\nthis:\n  linkage \\<Gamma> f'\n\ngoal (5 subgoals):\n 1. \\<And>x. x \\<in> A \\<Gamma> \\<Longrightarrow> d_IN f' x = 0\n 2. \\<And>x. d_OUT f' x \\<le> weight \\<Gamma> x\n 3. \\<And>x. d_IN f' x \\<le> weight \\<Gamma> x\n 4. \\<And>x. x \\<in> B \\<Gamma> \\<Longrightarrow> d_OUT f' x = 0\n 5. f' \\<le> f'", "show \"d_IN f' x = 0\" if \"x \\<in> A \\<Gamma>\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN f' x = 0", "using that currentD_IN[OF f, of \"Inl x\"] disjoint\n      currentD_outside[OF f, of \"Inl x\" \"Inr x\"] currentD_outside_IN[OF f, of \"Inr x\"]"], ["proof (prove)\nusing this:\n  x \\<in> A \\<Gamma>\n  Inl x \\<in> A (bipartite_web_of \\<Gamma>) \\<Longrightarrow>\n  d_IN f (Inl x) = 0\n  A \\<Gamma> \\<inter> B \\<Gamma> = {}\n  \\<not> edge (bipartite_web_of \\<Gamma>) (Inl x) (Inr x) \\<Longrightarrow>\n  f (Inl x, Inr x) = 0\n  Inr x\n  \\<notin> \\<^bold>V\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> \\<Longrightarrow>\n  d_IN f (Inr x) = 0\n\ngoal (1 subgoal):\n 1. d_IN f' x = 0", "by(cases \"x \\<in> \\<^bold>V\")(auto simp add: d_IN_current_of_bipartite[OF f] no_loop f'_def)"], ["proof (state)\nthis:\n  ?x \\<in> A \\<Gamma> \\<Longrightarrow> d_IN f' ?x = 0\n\ngoal (4 subgoals):\n 1. \\<And>x. d_OUT f' x \\<le> weight \\<Gamma> x\n 2. \\<And>x. d_IN f' x \\<le> weight \\<Gamma> x\n 3. \\<And>x. x \\<in> B \\<Gamma> \\<Longrightarrow> d_OUT f' x = 0\n 4. f' \\<le> f'", "show \"d_OUT f' x = 0\" if \"x \\<in> B \\<Gamma>\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT f' x = 0", "using that currentD_OUT[OF f, of \"Inr x\"] disjoint\n      currentD_outside[OF f, of \"Inl x\" \"Inr x\"] currentD_outside_OUT[OF f, of \"Inl x\"]"], ["proof (prove)\nusing this:\n  x \\<in> B \\<Gamma>\n  Inr x \\<in> B (bipartite_web_of \\<Gamma>) \\<Longrightarrow>\n  d_OUT f (Inr x) = 0\n  A \\<Gamma> \\<inter> B \\<Gamma> = {}\n  \\<not> edge (bipartite_web_of \\<Gamma>) (Inl x) (Inr x) \\<Longrightarrow>\n  f (Inl x, Inr x) = 0\n  Inl x\n  \\<notin> \\<^bold>V\\<^bsub>bipartite_web_of \\<Gamma>\\<^esub> \\<Longrightarrow>\n  d_OUT f (Inl x) = 0\n\ngoal (1 subgoal):\n 1. d_OUT f' x = 0", "by(cases \"x \\<in> \\<^bold>V\")(auto simp add: d_OUT_current_of_bipartite[OF f] no_loop f'_def)"], ["proof (state)\nthis:\n  ?x \\<in> B \\<Gamma> \\<Longrightarrow> d_OUT f' ?x = 0\n\ngoal (3 subgoals):\n 1. \\<And>x. d_OUT f' x \\<le> weight \\<Gamma> x\n 2. \\<And>x. d_IN f' x \\<le> weight \\<Gamma> x\n 3. f' \\<le> f'", "show \"d_OUT f' x \\<le> weight \\<Gamma> x\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT f' x \\<le> weight \\<Gamma> x", "using currentD_weight_OUT[OF f, of \"Inl x\"]"], ["proof (prove)\nusing this:\n  d_OUT f (Inl x) \\<le> weight (bipartite_web_of \\<Gamma>) (Inl x)\n\ngoal (1 subgoal):\n 1. d_OUT f' x \\<le> weight \\<Gamma> x", "by(simp add: d_OUT_current_of_bipartite[OF f] ennreal_diff_le_mono_left f'_def split: if_split_asm)"], ["proof (state)\nthis:\n  d_OUT f' ?x \\<le> weight \\<Gamma> ?x\n\ngoal (2 subgoals):\n 1. \\<And>x. d_IN f' x \\<le> weight \\<Gamma> x\n 2. f' \\<le> f'", "show \"d_IN f' x \\<le> weight \\<Gamma> x\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN f' x \\<le> weight \\<Gamma> x", "using currentD_weight_IN[OF f, of \"Inr x\"]"], ["proof (prove)\nusing this:\n  d_IN f (Inr x) \\<le> weight (bipartite_web_of \\<Gamma>) (Inr x)\n\ngoal (1 subgoal):\n 1. d_IN f' x \\<le> weight \\<Gamma> x", "by(simp add: d_IN_current_of_bipartite[OF f] ennreal_diff_le_mono_left f'_def split: if_split_asm)"], ["proof (state)\nthis:\n  d_IN f' ?x \\<le> weight \\<Gamma> ?x\n\ngoal (1 subgoal):\n 1. f' \\<le> f'", "qed simp"], ["proof (state)\nthis:\n  f' \\<in> Field leq\n\ngoal (1 subgoal):\n 1. linkable \\<Gamma>", "have F_leI: \"g \\<in> Field leq\" if f: \"f \\<in> Field leq\" and le: \"\\<And>e. g e \\<le> f e\"\n    and nonneg: \"\\<And>e. 0 \\<le> g e\" and IN_OUT: \"\\<And>x. x \\<notin> B \\<Gamma> \\<Longrightarrow> d_IN g x \\<le> d_OUT g x\"\n    and link: \"linkage \\<Gamma> g\"\n    for f g"], ["proof (prove)\ngoal (1 subgoal):\n 1. g \\<in> Field leq", "proof"], ["proof (state)\ngoal (9 subgoals):\n 1. \\<And>e. 0 \\<le> g e\n 2. \\<And>e. e \\<notin> \\<^bold>E \\<Longrightarrow> g e = 0\n 3. \\<And>x.\n       x \\<notin> B \\<Gamma> \\<Longrightarrow> d_IN g x \\<le> d_OUT g x\n 4. linkage \\<Gamma> g\n 5. \\<And>x. x \\<in> A \\<Gamma> \\<Longrightarrow> d_IN g x = 0\n 6. \\<And>x. d_OUT g x \\<le> weight \\<Gamma> x\n 7. \\<And>x. d_IN g x \\<le> weight \\<Gamma> x\n 8. \\<And>x. x \\<in> B \\<Gamma> \\<Longrightarrow> d_OUT g x = 0\n 9. g \\<le> f'", "show \"g e = 0\" if \"e \\<notin> \\<^bold>E\" for e"], ["proof (prove)\ngoal (1 subgoal):\n 1. g e = 0", "using nonneg[of e] F_outside[OF f that] le[of e]"], ["proof (prove)\nusing this:\n  0 \\<le> g e\n  f e = 0\n  g e \\<le> f e\n\ngoal (1 subgoal):\n 1. g e = 0", "by simp"], ["proof (state)\nthis:\n  ?e \\<notin> \\<^bold>E \\<Longrightarrow> g ?e = 0\n\ngoal (8 subgoals):\n 1. \\<And>e. 0 \\<le> g e\n 2. \\<And>x.\n       x \\<notin> B \\<Gamma> \\<Longrightarrow> d_IN g x \\<le> d_OUT g x\n 3. linkage \\<Gamma> g\n 4. \\<And>x. x \\<in> A \\<Gamma> \\<Longrightarrow> d_IN g x = 0\n 5. \\<And>x. d_OUT g x \\<le> weight \\<Gamma> x\n 6. \\<And>x. d_IN g x \\<le> weight \\<Gamma> x\n 7. \\<And>x. x \\<in> B \\<Gamma> \\<Longrightarrow> d_OUT g x = 0\n 8. g \\<le> f'", "show \"d_IN g a = 0\" if \"a \\<in> A \\<Gamma>\" for a"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN g a = 0", "using d_IN_mono[of g a f, OF le] F_IN[OF f that]"], ["proof (prove)\nusing this:\n  d_IN g a \\<le> d_IN f a\n  d_IN f a = 0\n\ngoal (1 subgoal):\n 1. d_IN g a = 0", "by auto"], ["proof (state)\nthis:\n  ?a \\<in> A \\<Gamma> \\<Longrightarrow> d_IN g ?a = 0\n\ngoal (7 subgoals):\n 1. \\<And>e. 0 \\<le> g e\n 2. \\<And>x.\n       x \\<notin> B \\<Gamma> \\<Longrightarrow> d_IN g x \\<le> d_OUT g x\n 3. linkage \\<Gamma> g\n 4. \\<And>x. d_OUT g x \\<le> weight \\<Gamma> x\n 5. \\<And>x. d_IN g x \\<le> weight \\<Gamma> x\n 6. \\<And>x. x \\<in> B \\<Gamma> \\<Longrightarrow> d_OUT g x = 0\n 7. g \\<le> f'", "show \"d_OUT g b = 0\" if \"b \\<in> B \\<Gamma>\" for b"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT g b = 0", "using d_OUT_mono[of g b f, OF le] F_OUT[OF f that]"], ["proof (prove)\nusing this:\n  d_OUT g b \\<le> d_OUT f b\n  d_OUT f b = 0\n\ngoal (1 subgoal):\n 1. d_OUT g b = 0", "by auto"], ["proof (state)\nthis:\n  ?b \\<in> B \\<Gamma> \\<Longrightarrow> d_OUT g ?b = 0\n\ngoal (6 subgoals):\n 1. \\<And>e. 0 \\<le> g e\n 2. \\<And>x.\n       x \\<notin> B \\<Gamma> \\<Longrightarrow> d_IN g x \\<le> d_OUT g x\n 3. linkage \\<Gamma> g\n 4. \\<And>x. d_OUT g x \\<le> weight \\<Gamma> x\n 5. \\<And>x. d_IN g x \\<le> weight \\<Gamma> x\n 6. g \\<le> f'", "show \"d_OUT g x \\<le> weight \\<Gamma> x\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT g x \\<le> weight \\<Gamma> x", "using d_OUT_mono[of g x f, OF le] F_weight_OUT[OF f]"], ["proof (prove)\nusing this:\n  d_OUT g x \\<le> d_OUT f x\n  d_OUT f ?x \\<le> weight \\<Gamma> ?x\n\ngoal (1 subgoal):\n 1. d_OUT g x \\<le> weight \\<Gamma> x", "by(rule order_trans)"], ["proof (state)\nthis:\n  d_OUT g ?x \\<le> weight \\<Gamma> ?x\n\ngoal (5 subgoals):\n 1. \\<And>e. 0 \\<le> g e\n 2. \\<And>x.\n       x \\<notin> B \\<Gamma> \\<Longrightarrow> d_IN g x \\<le> d_OUT g x\n 3. linkage \\<Gamma> g\n 4. \\<And>x. d_IN g x \\<le> weight \\<Gamma> x\n 5. g \\<le> f'", "show \"d_IN g x \\<le> weight \\<Gamma> x\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN g x \\<le> weight \\<Gamma> x", "using d_IN_mono[of g x f, OF le] F_weight_IN[OF f]"], ["proof (prove)\nusing this:\n  d_IN g x \\<le> d_IN f x\n  d_IN f ?x \\<le> weight \\<Gamma> ?x\n\ngoal (1 subgoal):\n 1. d_IN g x \\<le> weight \\<Gamma> x", "by(rule order_trans)"], ["proof (state)\nthis:\n  d_IN g ?x \\<le> weight \\<Gamma> ?x\n\ngoal (4 subgoals):\n 1. \\<And>e. 0 \\<le> g e\n 2. \\<And>x.\n       x \\<notin> B \\<Gamma> \\<Longrightarrow> d_IN g x \\<le> d_OUT g x\n 3. linkage \\<Gamma> g\n 4. g \\<le> f'", "show \"g \\<le> f'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g \\<le> f'", "using order_trans[OF le F_le[OF f]]"], ["proof (prove)\nusing this:\n  g ?e1 \\<le> f' ?e1\n\ngoal (1 subgoal):\n 1. g \\<le> f'", "by(auto simp add: le_fun_def)"], ["proof (state)\nthis:\n  g \\<le> f'\n\ngoal (3 subgoals):\n 1. \\<And>e. 0 \\<le> g e\n 2. \\<And>x.\n       x \\<notin> B \\<Gamma> \\<Longrightarrow> d_IN g x \\<le> d_OUT g x\n 3. linkage \\<Gamma> g", "qed(blast intro: IN_OUT link nonneg)+"], ["proof (state)\nthis:\n  \\<lbrakk>?f \\<in> Field leq; \\<And>e. ?g e \\<le> ?f e;\n   \\<And>e. 0 \\<le> ?g e;\n   \\<And>x.\n      x \\<notin> B \\<Gamma> \\<Longrightarrow> d_IN ?g x \\<le> d_OUT ?g x;\n   linkage \\<Gamma> ?g\\<rbrakk>\n  \\<Longrightarrow> ?g \\<in> Field leq\n\ngoal (1 subgoal):\n 1. linkable \\<Gamma>", "have chain_Field: \"Inf M \\<in> F\" if M: \"M \\<in> Chains leq\" and nempty: \"M \\<noteq> {}\" for M"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Sqinter> M \\<in> F", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Sqinter> M \\<in> F", "from nempty"], ["proof (chain)\npicking this:\n  M \\<noteq> {}", "obtain g0 where g0_in_M: \"g0 \\<in> M\""], ["proof (prove)\nusing this:\n  M \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>g0. g0 \\<in> M \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  g0 \\<in> M\n\ngoal (1 subgoal):\n 1. \\<Sqinter> M \\<in> F", "with M"], ["proof (chain)\npicking this:\n  M \\<in> Chains leq\n  g0 \\<in> M", "have g0: \"g0 \\<in> Field leq\""], ["proof (prove)\nusing this:\n  M \\<in> Chains leq\n  g0 \\<in> M\n\ngoal (1 subgoal):\n 1. g0 \\<in> Field leq", "by(rule Chains_FieldD)"], ["proof (state)\nthis:\n  g0 \\<in> Field leq\n\ngoal (1 subgoal):\n 1. \\<Sqinter> M \\<in> F", "from M"], ["proof (chain)\npicking this:\n  M \\<in> Chains leq", "have \"M \\<in> Chains {(g, g'). g' \\<le> g}\""], ["proof (prove)\nusing this:\n  M \\<in> Chains leq\n\ngoal (1 subgoal):\n 1. M \\<in> Chains {(g, g'). g' \\<le> g}", "by(rule mono_Chains[THEN subsetD, rotated])(auto simp add: leq_def in_restrict_rel_iff)"], ["proof (state)\nthis:\n  M \\<in> Chains {(g, g'). g' \\<le> g}\n\ngoal (1 subgoal):\n 1. \\<Sqinter> M \\<in> F", "then"], ["proof (chain)\npicking this:\n  M \\<in> Chains {(g, g'). g' \\<le> g}", "have \"Complete_Partial_Order.chain (\\<ge>) M\""], ["proof (prove)\nusing this:\n  M \\<in> Chains {(g, g'). g' \\<le> g}\n\ngoal (1 subgoal):\n 1. Complete_Partial_Order.chain (\\<lambda>x y. y \\<le> x) M", "by(rule Chains_into_chain)"], ["proof (state)\nthis:\n  Complete_Partial_Order.chain (\\<lambda>x y. y \\<le> x) M\n\ngoal (1 subgoal):\n 1. \\<Sqinter> M \\<in> F", "hence chain': \"Complete_Partial_Order.chain (\\<le>) M\""], ["proof (prove)\nusing this:\n  Complete_Partial_Order.chain (\\<lambda>x y. y \\<le> x) M\n\ngoal (1 subgoal):\n 1. Complete_Partial_Order.chain (\\<le>) M", "by(simp add: chain_dual)"], ["proof (state)\nthis:\n  Complete_Partial_Order.chain (\\<le>) M\n\ngoal (1 subgoal):\n 1. \\<Sqinter> M \\<in> F", "have \"support_flow f' \\<subseteq> \\<^bold>E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. support_flow f' \\<subseteq> \\<^bold>E", "using F_outside[OF f']"], ["proof (prove)\nusing this:\n  ?e \\<notin> \\<^bold>E \\<Longrightarrow> f' ?e = 0\n\ngoal (1 subgoal):\n 1. support_flow f' \\<subseteq> \\<^bold>E", "by(auto intro: ccontr simp add: support_flow.simps)"], ["proof (state)\nthis:\n  support_flow f' \\<subseteq> \\<^bold>E\n\ngoal (1 subgoal):\n 1. \\<Sqinter> M \\<in> F", "then"], ["proof (chain)\npicking this:\n  support_flow f' \\<subseteq> \\<^bold>E", "have countable': \"countable (support_flow f')\""], ["proof (prove)\nusing this:\n  support_flow f' \\<subseteq> \\<^bold>E\n\ngoal (1 subgoal):\n 1. countable (support_flow f')", "by(rule countable_subset)(simp add: E_bipartite_web countable \"\\<^bold>V_def\")"], ["proof (state)\nthis:\n  countable (support_flow f')\n\ngoal (1 subgoal):\n 1. \\<Sqinter> M \\<in> F", "have finite_OUT: \"d_OUT f' x \\<noteq> \\<top>\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT f' x \\<noteq> \\<top>", "using weight_finite[of x]"], ["proof (prove)\nusing this:\n  weight \\<Gamma> x \\<noteq> \\<top>\n\ngoal (1 subgoal):\n 1. d_OUT f' x \\<noteq> \\<top>", "by(rule neq_top_trans)(rule F_weight_OUT[OF f'])"], ["proof (state)\nthis:\n  d_OUT f' ?x \\<noteq> \\<top>\n\ngoal (1 subgoal):\n 1. \\<Sqinter> M \\<in> F", "have finite_IN: \"d_IN f' x \\<noteq> \\<top>\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN f' x \\<noteq> \\<top>", "using weight_finite[of x]"], ["proof (prove)\nusing this:\n  weight \\<Gamma> x \\<noteq> \\<top>\n\ngoal (1 subgoal):\n 1. d_IN f' x \\<noteq> \\<top>", "by(rule neq_top_trans)(rule F_weight_IN[OF f'])"], ["proof (state)\nthis:\n  d_IN f' ?x \\<noteq> \\<top>\n\ngoal (1 subgoal):\n 1. \\<Sqinter> M \\<in> F", "have OUT_M: \"d_OUT (Inf M) x = (INF g\\<in>M. d_OUT g x)\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT (\\<Sqinter> M) x = (\\<Sqinter>g\\<in>M. d_OUT g x)", "using chain' nempty countable' _ finite_OUT"], ["proof (prove)\nusing this:\n  Complete_Partial_Order.chain (\\<le>) M\n  M \\<noteq> {}\n  countable (support_flow f')\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  d_OUT f' ?x \\<noteq> \\<top>\n\ngoal (1 subgoal):\n 1. d_OUT (\\<Sqinter> M) x = (\\<Sqinter>g\\<in>M. d_OUT g x)", "by(rule d_OUT_Inf)(auto dest!: Chains_FieldD[OF M] simp add: leq_def F_nonneg F_le)"], ["proof (state)\nthis:\n  d_OUT (\\<Sqinter> M) ?x = (\\<Sqinter>g\\<in>M. d_OUT g ?x)\n\ngoal (1 subgoal):\n 1. \\<Sqinter> M \\<in> F", "have IN_M: \"d_IN (Inf M) x = (INF g\\<in>M. d_IN g x)\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN (\\<Sqinter> M) x = (\\<Sqinter>g\\<in>M. d_IN g x)", "using chain' nempty countable' _ finite_IN"], ["proof (prove)\nusing this:\n  Complete_Partial_Order.chain (\\<le>) M\n  M \\<noteq> {}\n  countable (support_flow f')\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  d_IN f' ?x \\<noteq> \\<top>\n\ngoal (1 subgoal):\n 1. d_IN (\\<Sqinter> M) x = (\\<Sqinter>g\\<in>M. d_IN g x)", "by(rule d_IN_Inf)(auto dest!: Chains_FieldD[OF M] simp add: leq_def F_nonneg F_le)"], ["proof (state)\nthis:\n  d_IN (\\<Sqinter> M) ?x = (\\<Sqinter>g\\<in>M. d_IN g ?x)\n\ngoal (1 subgoal):\n 1. \\<Sqinter> M \\<in> F", "show \"Inf M \\<in> F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Sqinter> M \\<in> F", "using g0"], ["proof (prove)\nusing this:\n  g0 \\<in> Field leq\n\ngoal (1 subgoal):\n 1. \\<Sqinter> M \\<in> F", "unfolding F[symmetric]"], ["proof (prove)\nusing this:\n  g0 \\<in> Field leq\n\ngoal (1 subgoal):\n 1. \\<Sqinter> M \\<in> Field leq", "proof(rule F_leI)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>e. (\\<Sqinter> M) e \\<le> g0 e\n 2. \\<And>e. 0 \\<le> (\\<Sqinter> M) e\n 3. \\<And>x.\n       x \\<notin> B \\<Gamma> \\<Longrightarrow>\n       d_IN (\\<Sqinter> M) x \\<le> d_OUT (\\<Sqinter> M) x\n 4. linkage \\<Gamma> (\\<Sqinter> M)", "show \"(Inf M) e \\<le> g0 e\" for e"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sqinter> M) e \\<le> g0 e", "using g0_in_M"], ["proof (prove)\nusing this:\n  g0 \\<in> M\n\ngoal (1 subgoal):\n 1. (\\<Sqinter> M) e \\<le> g0 e", "by(auto intro: INF_lower)"], ["proof (state)\nthis:\n  (\\<Sqinter> M) ?e \\<le> g0 ?e\n\ngoal (3 subgoals):\n 1. \\<And>e. 0 \\<le> (\\<Sqinter> M) e\n 2. \\<And>x.\n       x \\<notin> B \\<Gamma> \\<Longrightarrow>\n       d_IN (\\<Sqinter> M) x \\<le> d_OUT (\\<Sqinter> M) x\n 3. linkage \\<Gamma> (\\<Sqinter> M)", "show \"0 \\<le> (Inf M) e\" for e"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> (\\<Sqinter> M) e", "by(auto intro!: INF_greatest dest: F_nonneg dest!: Chains_FieldD[OF M])"], ["proof (state)\nthis:\n  0 \\<le> (\\<Sqinter> M) ?e\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<notin> B \\<Gamma> \\<Longrightarrow>\n       d_IN (\\<Sqinter> M) x \\<le> d_OUT (\\<Sqinter> M) x\n 2. linkage \\<Gamma> (\\<Sqinter> M)", "show \"d_IN (Inf M) x \\<le> d_OUT (Inf M) x\" if \"x \\<notin> B \\<Gamma>\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN (\\<Sqinter> M) x \\<le> d_OUT (\\<Sqinter> M) x", "using that"], ["proof (prove)\nusing this:\n  x \\<notin> B \\<Gamma>\n\ngoal (1 subgoal):\n 1. d_IN (\\<Sqinter> M) x \\<le> d_OUT (\\<Sqinter> M) x", "by(auto simp add: IN_M OUT_M intro!: INF_mono dest: Chains_FieldD[OF M] intro: F_IN_OUT[OF _ that])"], ["proof (state)\nthis:\n  ?x \\<notin> B \\<Gamma> \\<Longrightarrow>\n  d_IN (\\<Sqinter> M) ?x \\<le> d_OUT (\\<Sqinter> M) ?x\n\ngoal (1 subgoal):\n 1. linkage \\<Gamma> (\\<Sqinter> M)", "show \"linkage \\<Gamma> (Inf M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. linkage \\<Gamma> (\\<Sqinter> M)", "using nempty"], ["proof (prove)\nusing this:\n  M \\<noteq> {}\n\ngoal (1 subgoal):\n 1. linkage \\<Gamma> (\\<Sqinter> M)", "by(simp add: linkage.simps OUT_M F_link[THEN linkageD] Chains_FieldD[OF M] cong: INF_cong)"], ["proof (state)\nthis:\n  linkage \\<Gamma> (\\<Sqinter> M)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<Sqinter> M \\<in> F\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>?M \\<in> Chains leq; ?M \\<noteq> {}\\<rbrakk>\n  \\<Longrightarrow> \\<Sqinter> ?M \\<in> F\n\ngoal (1 subgoal):\n 1. linkable \\<Gamma>", "let ?P = \"\\<lambda>g z. z \\<notin> A \\<Gamma> \\<and> z \\<notin> B \\<Gamma> \\<and> d_OUT g z > d_IN g z\""], ["proof (state)\ngoal (1 subgoal):\n 1. linkable \\<Gamma>", "define link\n    where \"link g =\n      (if \\<exists>z. ?P g z then\n        let z = SOME z. ?P g z; factor = d_IN g z / d_OUT g z\n        in (\\<lambda>(x, y). (if x = z then factor else 1) * g (x, y))\n       else g)\" for g"], ["proof (state)\nthis:\n  link ?g =\n  (if \\<exists>z.\n         z \\<notin> A \\<Gamma> \\<and>\n         z \\<notin> B \\<Gamma> \\<and> d_IN ?g z < d_OUT ?g z\n   then let z = SOME z.\n                   z \\<notin> A \\<Gamma> \\<and>\n                   z \\<notin> B \\<Gamma> \\<and> d_IN ?g z < d_OUT ?g z;\n            factor = d_IN ?g z / d_OUT ?g z\n        in (\\<lambda>(x, y). (if x = z then factor else 1) * ?g (x, y))\n   else ?g)\n\ngoal (1 subgoal):\n 1. linkable \\<Gamma>", "have increasing: \"link g \\<le> g \\<and> link g \\<in> Field leq\" if g: \"g \\<in> Field leq\" for g"], ["proof (prove)\ngoal (1 subgoal):\n 1. link g \\<le> g \\<and> link g \\<in> Field leq", "proof(cases \"\\<exists>z. ?P g z\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>z.\n       z \\<notin> A \\<Gamma> \\<and>\n       z \\<notin> B \\<Gamma> \\<and> d_IN g z < d_OUT g z \\<Longrightarrow>\n    link g \\<le> g \\<and> link g \\<in> Field leq\n 2. \\<nexists>z.\n       z \\<notin> A \\<Gamma> \\<and>\n       z \\<notin> B \\<Gamma> \\<and> d_IN g z < d_OUT g z \\<Longrightarrow>\n    link g \\<le> g \\<and> link g \\<in> Field leq", "case False"], ["proof (state)\nthis:\n  \\<nexists>z.\n     z \\<notin> A \\<Gamma> \\<and>\n     z \\<notin> B \\<Gamma> \\<and> d_IN g z < d_OUT g z\n\ngoal (2 subgoals):\n 1. \\<exists>z.\n       z \\<notin> A \\<Gamma> \\<and>\n       z \\<notin> B \\<Gamma> \\<and> d_IN g z < d_OUT g z \\<Longrightarrow>\n    link g \\<le> g \\<and> link g \\<in> Field leq\n 2. \\<nexists>z.\n       z \\<notin> A \\<Gamma> \\<and>\n       z \\<notin> B \\<Gamma> \\<and> d_IN g z < d_OUT g z \\<Longrightarrow>\n    link g \\<le> g \\<and> link g \\<in> Field leq", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<nexists>z.\n     z \\<notin> A \\<Gamma> \\<and>\n     z \\<notin> B \\<Gamma> \\<and> d_IN g z < d_OUT g z\n\ngoal (1 subgoal):\n 1. link g \\<le> g \\<and> link g \\<in> Field leq", "using that"], ["proof (prove)\nusing this:\n  \\<nexists>z.\n     z \\<notin> A \\<Gamma> \\<and>\n     z \\<notin> B \\<Gamma> \\<and> d_IN g z < d_OUT g z\n  g \\<in> Field leq\n\ngoal (1 subgoal):\n 1. link g \\<le> g \\<and> link g \\<in> Field leq", "by(auto simp add: link_def leq_def)"], ["proof (state)\nthis:\n  link g \\<le> g \\<and> link g \\<in> Field leq\n\ngoal (1 subgoal):\n 1. \\<exists>z.\n       z \\<notin> A \\<Gamma> \\<and>\n       z \\<notin> B \\<Gamma> \\<and> d_IN g z < d_OUT g z \\<Longrightarrow>\n    link g \\<le> g \\<and> link g \\<in> Field leq", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>z.\n       z \\<notin> A \\<Gamma> \\<and>\n       z \\<notin> B \\<Gamma> \\<and> d_IN g z < d_OUT g z \\<Longrightarrow>\n    link g \\<le> g \\<and> link g \\<in> Field leq", "case True"], ["proof (state)\nthis:\n  \\<exists>z.\n     z \\<notin> A \\<Gamma> \\<and>\n     z \\<notin> B \\<Gamma> \\<and> d_IN g z < d_OUT g z\n\ngoal (1 subgoal):\n 1. \\<exists>z.\n       z \\<notin> A \\<Gamma> \\<and>\n       z \\<notin> B \\<Gamma> \\<and> d_IN g z < d_OUT g z \\<Longrightarrow>\n    link g \\<le> g \\<and> link g \\<in> Field leq", "define z where \"z = Eps (?P g)\""], ["proof (state)\nthis:\n  z =\n  (SOME z.\n      z \\<notin> A \\<Gamma> \\<and>\n      z \\<notin> B \\<Gamma> \\<and> d_IN g z < d_OUT g z)\n\ngoal (1 subgoal):\n 1. \\<exists>z.\n       z \\<notin> A \\<Gamma> \\<and>\n       z \\<notin> B \\<Gamma> \\<and> d_IN g z < d_OUT g z \\<Longrightarrow>\n    link g \\<le> g \\<and> link g \\<in> Field leq", "from True"], ["proof (chain)\npicking this:\n  \\<exists>z.\n     z \\<notin> A \\<Gamma> \\<and>\n     z \\<notin> B \\<Gamma> \\<and> d_IN g z < d_OUT g z", "have \"?P g z\""], ["proof (prove)\nusing this:\n  \\<exists>z.\n     z \\<notin> A \\<Gamma> \\<and>\n     z \\<notin> B \\<Gamma> \\<and> d_IN g z < d_OUT g z\n\ngoal (1 subgoal):\n 1. z \\<notin> A \\<Gamma> \\<and>\n    z \\<notin> B \\<Gamma> \\<and> d_IN g z < d_OUT g z", "unfolding z_def"], ["proof (prove)\nusing this:\n  \\<exists>z.\n     z \\<notin> A \\<Gamma> \\<and>\n     z \\<notin> B \\<Gamma> \\<and> d_IN g z < d_OUT g z\n\ngoal (1 subgoal):\n 1. (SOME z.\n        z \\<notin> A \\<Gamma> \\<and>\n        z \\<notin> B \\<Gamma> \\<and> d_IN g z < d_OUT g z)\n    \\<notin> A \\<Gamma> \\<and>\n    (SOME z.\n        z \\<notin> A \\<Gamma> \\<and>\n        z \\<notin> B \\<Gamma> \\<and> d_IN g z < d_OUT g z)\n    \\<notin> B \\<Gamma> \\<and>\n    d_IN g\n     (SOME z.\n         z \\<notin> A \\<Gamma> \\<and>\n         z \\<notin> B \\<Gamma> \\<and> d_IN g z < d_OUT g z)\n    < d_OUT g\n       (SOME z.\n           z \\<notin> A \\<Gamma> \\<and>\n           z \\<notin> B \\<Gamma> \\<and> d_IN g z < d_OUT g z)", "by(rule someI_ex)"], ["proof (state)\nthis:\n  z \\<notin> A \\<Gamma> \\<and>\n  z \\<notin> B \\<Gamma> \\<and> d_IN g z < d_OUT g z\n\ngoal (1 subgoal):\n 1. \\<exists>z.\n       z \\<notin> A \\<Gamma> \\<and>\n       z \\<notin> B \\<Gamma> \\<and> d_IN g z < d_OUT g z \\<Longrightarrow>\n    link g \\<le> g \\<and> link g \\<in> Field leq", "hence A: \"z \\<notin> A \\<Gamma>\" and B: \"z \\<notin> B \\<Gamma>\" and less: \"d_IN g z < d_OUT g z\""], ["proof (prove)\nusing this:\n  z \\<notin> A \\<Gamma> \\<and>\n  z \\<notin> B \\<Gamma> \\<and> d_IN g z < d_OUT g z\n\ngoal (1 subgoal):\n 1. z \\<notin> A \\<Gamma> &&& z \\<notin> B \\<Gamma> &&& d_IN g z < d_OUT g z", "by simp_all"], ["proof (state)\nthis:\n  z \\<notin> A \\<Gamma>\n  z \\<notin> B \\<Gamma>\n  d_IN g z < d_OUT g z\n\ngoal (1 subgoal):\n 1. \\<exists>z.\n       z \\<notin> A \\<Gamma> \\<and>\n       z \\<notin> B \\<Gamma> \\<and> d_IN g z < d_OUT g z \\<Longrightarrow>\n    link g \\<le> g \\<and> link g \\<in> Field leq", "let ?factor = \"d_IN g z / d_OUT g z\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>z.\n       z \\<notin> A \\<Gamma> \\<and>\n       z \\<notin> B \\<Gamma> \\<and> d_IN g z < d_OUT g z \\<Longrightarrow>\n    link g \\<le> g \\<and> link g \\<in> Field leq", "have link [simp]: \"link g (x, y) = (if x = z then ?factor else 1) * g (x, y)\" for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. link g (x, y) = (if x = z then d_IN g z / d_OUT g z else 1) * g (x, y)", "using True"], ["proof (prove)\nusing this:\n  \\<exists>z.\n     z \\<notin> A \\<Gamma> \\<and>\n     z \\<notin> B \\<Gamma> \\<and> d_IN g z < d_OUT g z\n\ngoal (1 subgoal):\n 1. link g (x, y) = (if x = z then d_IN g z / d_OUT g z else 1) * g (x, y)", "by(auto simp add: link_def z_def Let_def)"], ["proof (state)\nthis:\n  link g (?x, ?y) =\n  (if ?x = z then d_IN g z / d_OUT g z else 1) * g (?x, ?y)\n\ngoal (1 subgoal):\n 1. \\<exists>z.\n       z \\<notin> A \\<Gamma> \\<and>\n       z \\<notin> B \\<Gamma> \\<and> d_IN g z < d_OUT g z \\<Longrightarrow>\n    link g \\<le> g \\<and> link g \\<in> Field leq", "have \"?factor \\<le> 1\" (is \"?factor \\<le> _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN g z / d_OUT g z \\<le> 1", "using less"], ["proof (prove)\nusing this:\n  d_IN g z < d_OUT g z\n\ngoal (1 subgoal):\n 1. d_IN g z / d_OUT g z \\<le> 1", "by(cases \"d_OUT g z\" \"d_IN g z\" rule: ennreal2_cases) (simp_all add: ennreal_less_iff divide_ennreal)"], ["proof (state)\nthis:\n  d_IN g z / d_OUT g z \\<le> 1\n\ngoal (1 subgoal):\n 1. \\<exists>z.\n       z \\<notin> A \\<Gamma> \\<and>\n       z \\<notin> B \\<Gamma> \\<and> d_IN g z < d_OUT g z \\<Longrightarrow>\n    link g \\<le> g \\<and> link g \\<in> Field leq", "hence le': \"?factor * g (x, y) \\<le> 1 * g (x, y)\" for y x"], ["proof (prove)\nusing this:\n  d_IN g z / d_OUT g z \\<le> 1\n\ngoal (1 subgoal):\n 1. d_IN g z / d_OUT g z * g (x, y) \\<le> 1 * g (x, y)", "by(rule mult_right_mono)(simp add: F_nonneg[OF g])"], ["proof (state)\nthis:\n  d_IN g z / d_OUT g z * g (?x, ?y) \\<le> 1 * g (?x, ?y)\n\ngoal (1 subgoal):\n 1. \\<exists>z.\n       z \\<notin> A \\<Gamma> \\<and>\n       z \\<notin> B \\<Gamma> \\<and> d_IN g z < d_OUT g z \\<Longrightarrow>\n    link g \\<le> g \\<and> link g \\<in> Field leq", "hence le: \"link g e \\<le> g e\" for e"], ["proof (prove)\nusing this:\n  d_IN g z / d_OUT g z * g (?x, ?y) \\<le> 1 * g (?x, ?y)\n\ngoal (1 subgoal):\n 1. link g e \\<le> g e", "by(cases e)simp"], ["proof (state)\nthis:\n  link g ?e \\<le> g ?e\n\ngoal (1 subgoal):\n 1. \\<exists>z.\n       z \\<notin> A \\<Gamma> \\<and>\n       z \\<notin> B \\<Gamma> \\<and> d_IN g z < d_OUT g z \\<Longrightarrow>\n    link g \\<le> g \\<and> link g \\<in> Field leq", "have \"link g \\<in> Field leq\""], ["proof (prove)\ngoal (1 subgoal):\n 1. link g \\<in> Field leq", "using g le"], ["proof (prove)\nusing this:\n  g \\<in> Field leq\n  link g ?e \\<le> g ?e\n\ngoal (1 subgoal):\n 1. link g \\<in> Field leq", "proof(rule F_leI)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>e. 0 \\<le> link g e\n 2. \\<And>x.\n       x \\<notin> B \\<Gamma> \\<Longrightarrow>\n       d_IN (link g) x \\<le> d_OUT (link g) x\n 3. linkage \\<Gamma> (link g)", "show nonneg: \"0 \\<le> link g e\" for e"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> link g e", "using F_nonneg[OF g, of e]"], ["proof (prove)\nusing this:\n  0 \\<le> g e\n\ngoal (1 subgoal):\n 1. 0 \\<le> link g e", "by(cases e) simp"], ["proof (state)\nthis:\n  0 \\<le> link g ?e\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<notin> B \\<Gamma> \\<Longrightarrow>\n       d_IN (link g) x \\<le> d_OUT (link g) x\n 2. linkage \\<Gamma> (link g)", "show \"linkage \\<Gamma> (link g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. linkage \\<Gamma> (link g)", "using that A F_link[OF g]"], ["proof (prove)\nusing this:\n  g \\<in> Field leq\n  z \\<notin> A \\<Gamma>\n  linkage \\<Gamma> g\n\ngoal (1 subgoal):\n 1. linkage \\<Gamma> (link g)", "by(clarsimp simp add: linkage.simps d_OUT_def)"], ["proof (state)\nthis:\n  linkage \\<Gamma> (link g)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<notin> B \\<Gamma> \\<Longrightarrow>\n       d_IN (link g) x \\<le> d_OUT (link g) x", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<notin> B \\<Gamma> \\<Longrightarrow>\n       d_IN (link g) x \\<le> d_OUT (link g) x", "assume x: \"x \\<notin> B \\<Gamma>\""], ["proof (state)\nthis:\n  x \\<notin> B \\<Gamma>\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<notin> B \\<Gamma> \\<Longrightarrow>\n       d_IN (link g) x \\<le> d_OUT (link g) x", "have \"d_IN (link g) x \\<le> d_IN g x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN (link g) x \\<le> d_IN g x", "unfolding d_IN_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ xa. link g (xa, x)) \\<le> (\\<Sum>\\<^sup>+ xa. g (xa, x))", "using le'"], ["proof (prove)\nusing this:\n  d_IN g z / d_OUT g z * g (?x, ?y) \\<le> 1 * g (?x, ?y)\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ xa. link g (xa, x)) \\<le> (\\<Sum>\\<^sup>+ xa. g (xa, x))", "by(auto intro: nn_integral_mono)"], ["proof (state)\nthis:\n  d_IN (link g) x \\<le> d_IN g x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<notin> B \\<Gamma> \\<Longrightarrow>\n       d_IN (link g) x \\<le> d_OUT (link g) x", "also"], ["proof (state)\nthis:\n  d_IN (link g) x \\<le> d_IN g x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<notin> B \\<Gamma> \\<Longrightarrow>\n       d_IN (link g) x \\<le> d_OUT (link g) x", "have \"\\<dots> \\<le> d_OUT (link g) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN g x \\<le> d_OUT (link g) x", "proof(cases \"x = z\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x = z \\<Longrightarrow> d_IN g x \\<le> d_OUT (link g) x\n 2. x \\<noteq> z \\<Longrightarrow> d_IN g x \\<le> d_OUT (link g) x", "case True"], ["proof (state)\nthis:\n  x = z\n\ngoal (2 subgoals):\n 1. x = z \\<Longrightarrow> d_IN g x \\<le> d_OUT (link g) x\n 2. x \\<noteq> z \\<Longrightarrow> d_IN g x \\<le> d_OUT (link g) x", "have \"d_IN g x = d_OUT (link g) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN g x = d_OUT (link g) x", "unfolding d_OUT_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN g x = (\\<Sum>\\<^sup>+ y. link g (x, y))", "using True F_weight_IN[OF g, of x] F_IN_OUT[OF g x] F_finite_OUT F_finite_OUT[OF g, of x]"], ["proof (prove)\nusing this:\n  x = z\n  d_IN g x \\<le> weight \\<Gamma> x\n  d_IN g x \\<le> d_OUT g x\n  ?f \\<in> Field leq \\<Longrightarrow> d_OUT ?f ?x \\<noteq> \\<top>\n  d_OUT g x \\<noteq> \\<top>\n\ngoal (1 subgoal):\n 1. d_IN g x = (\\<Sum>\\<^sup>+ y. link g (x, y))", "by(cases \"d_OUT g z = 0\")\n            (auto simp add: nn_integral_divide nn_integral_cmult d_OUT_def[symmetric] ennreal_divide_times less_top)"], ["proof (state)\nthis:\n  d_IN g x = d_OUT (link g) x\n\ngoal (2 subgoals):\n 1. x = z \\<Longrightarrow> d_IN g x \\<le> d_OUT (link g) x\n 2. x \\<noteq> z \\<Longrightarrow> d_IN g x \\<le> d_OUT (link g) x", "thus ?thesis"], ["proof (prove)\nusing this:\n  d_IN g x = d_OUT (link g) x\n\ngoal (1 subgoal):\n 1. d_IN g x \\<le> d_OUT (link g) x", "by simp"], ["proof (state)\nthis:\n  d_IN g x \\<le> d_OUT (link g) x\n\ngoal (1 subgoal):\n 1. x \\<noteq> z \\<Longrightarrow> d_IN g x \\<le> d_OUT (link g) x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<noteq> z \\<Longrightarrow> d_IN g x \\<le> d_OUT (link g) x", "case False"], ["proof (state)\nthis:\n  x \\<noteq> z\n\ngoal (1 subgoal):\n 1. x \\<noteq> z \\<Longrightarrow> d_IN g x \\<le> d_OUT (link g) x", "have \"d_IN g x \\<le> d_OUT g x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN g x \\<le> d_OUT g x", "using x"], ["proof (prove)\nusing this:\n  x \\<notin> B \\<Gamma>\n\ngoal (1 subgoal):\n 1. d_IN g x \\<le> d_OUT g x", "by(rule F_IN_OUT[OF g])"], ["proof (state)\nthis:\n  d_IN g x \\<le> d_OUT g x\n\ngoal (1 subgoal):\n 1. x \\<noteq> z \\<Longrightarrow> d_IN g x \\<le> d_OUT (link g) x", "also"], ["proof (state)\nthis:\n  d_IN g x \\<le> d_OUT g x\n\ngoal (1 subgoal):\n 1. x \\<noteq> z \\<Longrightarrow> d_IN g x \\<le> d_OUT (link g) x", "have \"\\<dots> \\<le> d_OUT (link g) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT g x \\<le> d_OUT (link g) x", "unfolding d_OUT_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y. g (x, y)) \\<le> (\\<Sum>\\<^sup>+ y. link g (x, y))", "using False"], ["proof (prove)\nusing this:\n  x \\<noteq> z\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y. g (x, y)) \\<le> (\\<Sum>\\<^sup>+ y. link g (x, y))", "by(auto intro!: nn_integral_mono)"], ["proof (state)\nthis:\n  d_OUT g x \\<le> d_OUT (link g) x\n\ngoal (1 subgoal):\n 1. x \\<noteq> z \\<Longrightarrow> d_IN g x \\<le> d_OUT (link g) x", "finally"], ["proof (chain)\npicking this:\n  d_IN g x \\<le> d_OUT (link g) x", "show ?thesis"], ["proof (prove)\nusing this:\n  d_IN g x \\<le> d_OUT (link g) x\n\ngoal (1 subgoal):\n 1. d_IN g x \\<le> d_OUT (link g) x", "."], ["proof (state)\nthis:\n  d_IN g x \\<le> d_OUT (link g) x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  d_IN g x \\<le> d_OUT (link g) x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<notin> B \\<Gamma> \\<Longrightarrow>\n       d_IN (link g) x \\<le> d_OUT (link g) x", "finally"], ["proof (chain)\npicking this:\n  d_IN (link g) x \\<le> d_OUT (link g) x", "show \"d_IN (link g) x \\<le> d_OUT (link g) x\""], ["proof (prove)\nusing this:\n  d_IN (link g) x \\<le> d_OUT (link g) x\n\ngoal (1 subgoal):\n 1. d_IN (link g) x \\<le> d_OUT (link g) x", "."], ["proof (state)\nthis:\n  d_IN (link g) x \\<le> d_OUT (link g) x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  link g \\<in> Field leq\n\ngoal (1 subgoal):\n 1. \\<exists>z.\n       z \\<notin> A \\<Gamma> \\<and>\n       z \\<notin> B \\<Gamma> \\<and> d_IN g z < d_OUT g z \\<Longrightarrow>\n    link g \\<le> g \\<and> link g \\<in> Field leq", "with le g"], ["proof (chain)\npicking this:\n  link g ?e \\<le> g ?e\n  g \\<in> Field leq\n  link g \\<in> Field leq", "show ?thesis"], ["proof (prove)\nusing this:\n  link g ?e \\<le> g ?e\n  g \\<in> Field leq\n  link g \\<in> Field leq\n\ngoal (1 subgoal):\n 1. link g \\<le> g \\<and> link g \\<in> Field leq", "unfolding F"], ["proof (prove)\nusing this:\n  link g ?e \\<le> g ?e\n  g \\<in> F\n  link g \\<in> F\n\ngoal (1 subgoal):\n 1. link g \\<le> g \\<and> link g \\<in> F", "by(simp add: leq_def le_fun_def del: link)"], ["proof (state)\nthis:\n  link g \\<le> g \\<and> link g \\<in> Field leq\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?g \\<in> Field leq \\<Longrightarrow>\n  link ?g \\<le> ?g \\<and> link ?g \\<in> Field leq\n\ngoal (1 subgoal):\n 1. linkable \\<Gamma>", "have \"bourbaki_witt_fixpoint Inf leq link\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bourbaki_witt_fixpoint Inf leq link", "using chain_Field increasing"], ["proof (prove)\nusing this:\n  \\<lbrakk>?M \\<in> Chains leq; ?M \\<noteq> {}\\<rbrakk>\n  \\<Longrightarrow> \\<Sqinter> ?M \\<in> F\n  ?g \\<in> Field leq \\<Longrightarrow>\n  link ?g \\<le> ?g \\<and> link ?g \\<in> Field leq\n\ngoal (1 subgoal):\n 1. bourbaki_witt_fixpoint Inf leq link", "unfolding leq_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>?M \\<in> Chains (restrict_rel F {(f, f'). f' \\<le> f});\n   ?M \\<noteq> {}\\<rbrakk>\n  \\<Longrightarrow> \\<Sqinter> ?M \\<in> F\n  ?g \\<in> Field (restrict_rel F {(f, f'). f' \\<le> f}) \\<Longrightarrow>\n  link ?g \\<le> ?g \\<and>\n  link ?g \\<in> Field (restrict_rel F {(f, f'). f' \\<le> f})\n\ngoal (1 subgoal):\n 1. bourbaki_witt_fixpoint Inf (restrict_rel F {(f, f'). f' \\<le> f}) link", "by(intro bourbaki_witt_fixpoint_restrict_rel)(auto intro: Inf_greatest Inf_lower)"], ["proof (state)\nthis:\n  bourbaki_witt_fixpoint Inf leq link\n\ngoal (1 subgoal):\n 1. linkable \\<Gamma>", "then"], ["proof (chain)\npicking this:\n  bourbaki_witt_fixpoint Inf leq link", "interpret bourbaki_witt_fixpoint Inf leq link"], ["proof (prove)\nusing this:\n  bourbaki_witt_fixpoint Inf leq link\n\ngoal (1 subgoal):\n 1. bourbaki_witt_fixpoint Inf leq link", "."], ["proof (state)\ngoal (1 subgoal):\n 1. linkable \\<Gamma>", "define g where \"g = fixp_above f'\""], ["proof (state)\nthis:\n  g = fixp_above f'\n\ngoal (1 subgoal):\n 1. linkable \\<Gamma>", "have g: \"g \\<in> Field leq\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g \\<in> Field leq", "using f'"], ["proof (prove)\nusing this:\n  f' \\<in> Field leq\n\ngoal (1 subgoal):\n 1. g \\<in> Field leq", "unfolding g_def"], ["proof (prove)\nusing this:\n  f' \\<in> Field leq\n\ngoal (1 subgoal):\n 1. fixp_above f' \\<in> Field leq", "by(rule fixp_above_Field)"], ["proof (state)\nthis:\n  g \\<in> Field leq\n\ngoal (1 subgoal):\n 1. linkable \\<Gamma>", "hence \"linkage \\<Gamma> g\""], ["proof (prove)\nusing this:\n  g \\<in> Field leq\n\ngoal (1 subgoal):\n 1. linkage \\<Gamma> g", "by(rule F_link)"], ["proof (state)\nthis:\n  linkage \\<Gamma> g\n\ngoal (1 subgoal):\n 1. linkable \\<Gamma>", "moreover"], ["proof (state)\nthis:\n  linkage \\<Gamma> g\n\ngoal (1 subgoal):\n 1. linkable \\<Gamma>", "have \"web_flow \\<Gamma> g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. web_flow \\<Gamma> g", "proof(intro web_flow.intros current.intros)"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>x. d_OUT g x \\<le> weight \\<Gamma> x\n 2. \\<And>x. d_IN g x \\<le> weight \\<Gamma> x\n 3. \\<And>x.\n       x \\<notin> A \\<Gamma> \\<Longrightarrow> d_OUT g x \\<le> d_IN g x\n 4. \\<And>a. a \\<in> A \\<Gamma> \\<Longrightarrow> d_IN g a = 0\n 5. \\<And>b. b \\<in> B \\<Gamma> \\<Longrightarrow> d_OUT g b = 0\n 6. \\<And>e. e \\<notin> \\<^bold>E \\<Longrightarrow> g e = 0\n 7. \\<And>x.\n       \\<lbrakk>x \\<in> \\<^bold>V; x \\<notin> A \\<Gamma>;\n        x \\<notin> B \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> KIR g x", "show \"d_OUT g x \\<le> weight \\<Gamma> x\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT g x \\<le> weight \\<Gamma> x", "using g"], ["proof (prove)\nusing this:\n  g \\<in> Field leq\n\ngoal (1 subgoal):\n 1. d_OUT g x \\<le> weight \\<Gamma> x", "by(rule F_weight_OUT)"], ["proof (state)\nthis:\n  d_OUT g ?x \\<le> weight \\<Gamma> ?x\n\ngoal (6 subgoals):\n 1. \\<And>x. d_IN g x \\<le> weight \\<Gamma> x\n 2. \\<And>x.\n       x \\<notin> A \\<Gamma> \\<Longrightarrow> d_OUT g x \\<le> d_IN g x\n 3. \\<And>a. a \\<in> A \\<Gamma> \\<Longrightarrow> d_IN g a = 0\n 4. \\<And>b. b \\<in> B \\<Gamma> \\<Longrightarrow> d_OUT g b = 0\n 5. \\<And>e. e \\<notin> \\<^bold>E \\<Longrightarrow> g e = 0\n 6. \\<And>x.\n       \\<lbrakk>x \\<in> \\<^bold>V; x \\<notin> A \\<Gamma>;\n        x \\<notin> B \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> KIR g x", "show \"d_IN g x \\<le> weight \\<Gamma> x\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN g x \\<le> weight \\<Gamma> x", "using g"], ["proof (prove)\nusing this:\n  g \\<in> Field leq\n\ngoal (1 subgoal):\n 1. d_IN g x \\<le> weight \\<Gamma> x", "by(rule F_weight_IN)"], ["proof (state)\nthis:\n  d_IN g ?x \\<le> weight \\<Gamma> ?x\n\ngoal (5 subgoals):\n 1. \\<And>x.\n       x \\<notin> A \\<Gamma> \\<Longrightarrow> d_OUT g x \\<le> d_IN g x\n 2. \\<And>a. a \\<in> A \\<Gamma> \\<Longrightarrow> d_IN g a = 0\n 3. \\<And>b. b \\<in> B \\<Gamma> \\<Longrightarrow> d_OUT g b = 0\n 4. \\<And>e. e \\<notin> \\<^bold>E \\<Longrightarrow> g e = 0\n 5. \\<And>x.\n       \\<lbrakk>x \\<in> \\<^bold>V; x \\<notin> A \\<Gamma>;\n        x \\<notin> B \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> KIR g x", "show \"d_IN g x = 0\" if \"x \\<in> A \\<Gamma>\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN g x = 0", "using g that"], ["proof (prove)\nusing this:\n  g \\<in> Field leq\n  x \\<in> A \\<Gamma>\n\ngoal (1 subgoal):\n 1. d_IN g x = 0", "by(rule F_IN)"], ["proof (state)\nthis:\n  ?x \\<in> A \\<Gamma> \\<Longrightarrow> d_IN g ?x = 0\n\ngoal (4 subgoals):\n 1. \\<And>x.\n       x \\<notin> A \\<Gamma> \\<Longrightarrow> d_OUT g x \\<le> d_IN g x\n 2. \\<And>b. b \\<in> B \\<Gamma> \\<Longrightarrow> d_OUT g b = 0\n 3. \\<And>e. e \\<notin> \\<^bold>E \\<Longrightarrow> g e = 0\n 4. \\<And>x.\n       \\<lbrakk>x \\<in> \\<^bold>V; x \\<notin> A \\<Gamma>;\n        x \\<notin> B \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> KIR g x", "show B: \"d_OUT g x = 0\" if \"x \\<in> B \\<Gamma>\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT g x = 0", "using g that"], ["proof (prove)\nusing this:\n  g \\<in> Field leq\n  x \\<in> B \\<Gamma>\n\ngoal (1 subgoal):\n 1. d_OUT g x = 0", "by(rule F_OUT)"], ["proof (state)\nthis:\n  ?x \\<in> B \\<Gamma> \\<Longrightarrow> d_OUT g ?x = 0\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       x \\<notin> A \\<Gamma> \\<Longrightarrow> d_OUT g x \\<le> d_IN g x\n 2. \\<And>e. e \\<notin> \\<^bold>E \\<Longrightarrow> g e = 0\n 3. \\<And>x.\n       \\<lbrakk>x \\<in> \\<^bold>V; x \\<notin> A \\<Gamma>;\n        x \\<notin> B \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> KIR g x", "show \"g e = 0\" if \"e \\<notin> \\<^bold>E\" for e"], ["proof (prove)\ngoal (1 subgoal):\n 1. g e = 0", "using g that"], ["proof (prove)\nusing this:\n  g \\<in> Field leq\n  e \\<notin> \\<^bold>E\n\ngoal (1 subgoal):\n 1. g e = 0", "by(rule F_outside)"], ["proof (state)\nthis:\n  ?e \\<notin> \\<^bold>E \\<Longrightarrow> g ?e = 0\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<notin> A \\<Gamma> \\<Longrightarrow> d_OUT g x \\<le> d_IN g x\n 2. \\<And>x.\n       \\<lbrakk>x \\<in> \\<^bold>V; x \\<notin> A \\<Gamma>;\n        x \\<notin> B \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> KIR g x", "show KIR: \"KIR g x\" if A: \"x \\<notin> A \\<Gamma>\" and B: \"x \\<notin> B \\<Gamma>\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. KIR g x", "proof(rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. d_OUT g x \\<noteq> d_IN g x \\<Longrightarrow> False", "define z where \"z = Eps (?P g)\""], ["proof (state)\nthis:\n  z =\n  (SOME z.\n      z \\<notin> A \\<Gamma> \\<and>\n      z \\<notin> B \\<Gamma> \\<and> d_IN g z < d_OUT g z)\n\ngoal (1 subgoal):\n 1. d_OUT g x \\<noteq> d_IN g x \\<Longrightarrow> False", "assume \"\\<not> KIR g x\""], ["proof (state)\nthis:\n  d_OUT g x \\<noteq> d_IN g x\n\ngoal (1 subgoal):\n 1. d_OUT g x \\<noteq> d_IN g x \\<Longrightarrow> False", "with F_IN_OUT[OF g B]"], ["proof (chain)\npicking this:\n  d_IN g x \\<le> d_OUT g x\n  d_OUT g x \\<noteq> d_IN g x", "have \"d_OUT g x > d_IN g x\""], ["proof (prove)\nusing this:\n  d_IN g x \\<le> d_OUT g x\n  d_OUT g x \\<noteq> d_IN g x\n\ngoal (1 subgoal):\n 1. d_IN g x < d_OUT g x", "by simp"], ["proof (state)\nthis:\n  d_IN g x < d_OUT g x\n\ngoal (1 subgoal):\n 1. d_OUT g x \\<noteq> d_IN g x \\<Longrightarrow> False", "with A B"], ["proof (chain)\npicking this:\n  x \\<notin> A \\<Gamma>\n  x \\<notin> B \\<Gamma>\n  d_IN g x < d_OUT g x", "have Ex: \"\\<exists>x. ?P g x\""], ["proof (prove)\nusing this:\n  x \\<notin> A \\<Gamma>\n  x \\<notin> B \\<Gamma>\n  d_IN g x < d_OUT g x\n\ngoal (1 subgoal):\n 1. \\<exists>x.\n       x \\<notin> A \\<Gamma> \\<and>\n       x \\<notin> B \\<Gamma> \\<and> d_IN g x < d_OUT g x", "by blast"], ["proof (state)\nthis:\n  \\<exists>x.\n     x \\<notin> A \\<Gamma> \\<and>\n     x \\<notin> B \\<Gamma> \\<and> d_IN g x < d_OUT g x\n\ngoal (1 subgoal):\n 1. d_OUT g x \\<noteq> d_IN g x \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<exists>x.\n     x \\<notin> A \\<Gamma> \\<and>\n     x \\<notin> B \\<Gamma> \\<and> d_IN g x < d_OUT g x", "have \"?P g z\""], ["proof (prove)\nusing this:\n  \\<exists>x.\n     x \\<notin> A \\<Gamma> \\<and>\n     x \\<notin> B \\<Gamma> \\<and> d_IN g x < d_OUT g x\n\ngoal (1 subgoal):\n 1. z \\<notin> A \\<Gamma> \\<and>\n    z \\<notin> B \\<Gamma> \\<and> d_IN g z < d_OUT g z", "unfolding z_def"], ["proof (prove)\nusing this:\n  \\<exists>x.\n     x \\<notin> A \\<Gamma> \\<and>\n     x \\<notin> B \\<Gamma> \\<and> d_IN g x < d_OUT g x\n\ngoal (1 subgoal):\n 1. (SOME z.\n        z \\<notin> A \\<Gamma> \\<and>\n        z \\<notin> B \\<Gamma> \\<and> d_IN g z < d_OUT g z)\n    \\<notin> A \\<Gamma> \\<and>\n    (SOME z.\n        z \\<notin> A \\<Gamma> \\<and>\n        z \\<notin> B \\<Gamma> \\<and> d_IN g z < d_OUT g z)\n    \\<notin> B \\<Gamma> \\<and>\n    d_IN g\n     (SOME z.\n         z \\<notin> A \\<Gamma> \\<and>\n         z \\<notin> B \\<Gamma> \\<and> d_IN g z < d_OUT g z)\n    < d_OUT g\n       (SOME z.\n           z \\<notin> A \\<Gamma> \\<and>\n           z \\<notin> B \\<Gamma> \\<and> d_IN g z < d_OUT g z)", "by(rule someI_ex)"], ["proof (state)\nthis:\n  z \\<notin> A \\<Gamma> \\<and>\n  z \\<notin> B \\<Gamma> \\<and> d_IN g z < d_OUT g z\n\ngoal (1 subgoal):\n 1. d_OUT g x \\<noteq> d_IN g x \\<Longrightarrow> False", "hence A: \"z \\<notin> A \\<Gamma>\" and B: \"z \\<notin> B \\<Gamma>\" and less: \"d_IN g z < d_OUT g z\""], ["proof (prove)\nusing this:\n  z \\<notin> A \\<Gamma> \\<and>\n  z \\<notin> B \\<Gamma> \\<and> d_IN g z < d_OUT g z\n\ngoal (1 subgoal):\n 1. z \\<notin> A \\<Gamma> &&& z \\<notin> B \\<Gamma> &&& d_IN g z < d_OUT g z", "by simp_all"], ["proof (state)\nthis:\n  z \\<notin> A \\<Gamma>\n  z \\<notin> B \\<Gamma>\n  d_IN g z < d_OUT g z\n\ngoal (1 subgoal):\n 1. d_OUT g x \\<noteq> d_IN g x \\<Longrightarrow> False", "let ?factor = \"d_IN g z / d_OUT g z\""], ["proof (state)\ngoal (1 subgoal):\n 1. d_OUT g x \\<noteq> d_IN g x \\<Longrightarrow> False", "have \"\\<exists>y. edge \\<Gamma> z y \\<and> g (z, y) > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>y. edge \\<Gamma> z y \\<and> 0 < g (z, y)", "proof(rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<nexists>y. edge \\<Gamma> z y \\<and> 0 < g (z, y) \\<Longrightarrow>\n    False", "assume \"\\<not> ?thesis\""], ["proof (state)\nthis:\n  \\<nexists>y. edge \\<Gamma> z y \\<and> 0 < g (z, y)\n\ngoal (1 subgoal):\n 1. \\<nexists>y. edge \\<Gamma> z y \\<and> 0 < g (z, y) \\<Longrightarrow>\n    False", "hence \"d_OUT g z = 0\""], ["proof (prove)\nusing this:\n  \\<nexists>y. edge \\<Gamma> z y \\<and> 0 < g (z, y)\n\ngoal (1 subgoal):\n 1. d_OUT g z = 0", "using F_outside[OF g]"], ["proof (prove)\nusing this:\n  \\<nexists>y. edge \\<Gamma> z y \\<and> 0 < g (z, y)\n  ?e \\<notin> \\<^bold>E \\<Longrightarrow> g ?e = 0\n\ngoal (1 subgoal):\n 1. d_OUT g z = 0", "by(force simp add: d_OUT_def nn_integral_0_iff_AE AE_count_space not_less)"], ["proof (state)\nthis:\n  d_OUT g z = 0\n\ngoal (1 subgoal):\n 1. \\<nexists>y. edge \\<Gamma> z y \\<and> 0 < g (z, y) \\<Longrightarrow>\n    False", "with less"], ["proof (chain)\npicking this:\n  d_IN g z < d_OUT g z\n  d_OUT g z = 0", "show False"], ["proof (prove)\nusing this:\n  d_IN g z < d_OUT g z\n  d_OUT g z = 0\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>y. edge \\<Gamma> z y \\<and> 0 < g (z, y)\n\ngoal (1 subgoal):\n 1. d_OUT g x \\<noteq> d_IN g x \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<exists>y. edge \\<Gamma> z y \\<and> 0 < g (z, y)", "obtain y where y: \"edge \\<Gamma> z y\" and gr0: \"g (z, y) > 0\""], ["proof (prove)\nusing this:\n  \\<exists>y. edge \\<Gamma> z y \\<and> 0 < g (z, y)\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>edge \\<Gamma> z y; 0 < g (z, y)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  edge \\<Gamma> z y\n  0 < g (z, y)\n\ngoal (1 subgoal):\n 1. d_OUT g x \\<noteq> d_IN g x \\<Longrightarrow> False", "have \"?factor < 1\" (is \"?factor < _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN g z / d_OUT g z < 1", "using less"], ["proof (prove)\nusing this:\n  d_IN g z < d_OUT g z\n\ngoal (1 subgoal):\n 1. d_IN g z / d_OUT g z < 1", "by(cases \"d_OUT g z\" \"d_IN g z\" rule: ennreal2_cases)\n          (auto simp add: ennreal_less_iff divide_ennreal)"], ["proof (state)\nthis:\n  d_IN g z / d_OUT g z < 1\n\ngoal (1 subgoal):\n 1. d_OUT g x \\<noteq> d_IN g x \\<Longrightarrow> False", "hence le': \"?factor * g (z, y) < 1 * g (z, y)\""], ["proof (prove)\nusing this:\n  d_IN g z / d_OUT g z < 1\n\ngoal (1 subgoal):\n 1. d_IN g z / d_OUT g z * g (z, y) < 1 * g (z, y)", "using gr0 F_finite[OF g]"], ["proof (prove)\nusing this:\n  d_IN g z / d_OUT g z < 1\n  0 < g (z, y)\n  g ?e \\<noteq> \\<top>\n\ngoal (1 subgoal):\n 1. d_IN g z / d_OUT g z * g (z, y) < 1 * g (z, y)", "by(intro ennreal_mult_strict_right_mono) (auto simp: less_top)"], ["proof (state)\nthis:\n  d_IN g z / d_OUT g z * g (z, y) < 1 * g (z, y)\n\ngoal (1 subgoal):\n 1. d_OUT g x \\<noteq> d_IN g x \\<Longrightarrow> False", "hence \"link g (z, y) \\<noteq> g (z, y)\""], ["proof (prove)\nusing this:\n  d_IN g z / d_OUT g z * g (z, y) < 1 * g (z, y)\n\ngoal (1 subgoal):\n 1. link g (z, y) \\<noteq> g (z, y)", "using Ex"], ["proof (prove)\nusing this:\n  d_IN g z / d_OUT g z * g (z, y) < 1 * g (z, y)\n  \\<exists>x.\n     x \\<notin> A \\<Gamma> \\<and>\n     x \\<notin> B \\<Gamma> \\<and> d_IN g x < d_OUT g x\n\ngoal (1 subgoal):\n 1. link g (z, y) \\<noteq> g (z, y)", "by(auto simp add: link_def z_def Let_def)"], ["proof (state)\nthis:\n  link g (z, y) \\<noteq> g (z, y)\n\ngoal (1 subgoal):\n 1. d_OUT g x \\<noteq> d_IN g x \\<Longrightarrow> False", "hence \"link g \\<noteq> g\""], ["proof (prove)\nusing this:\n  link g (z, y) \\<noteq> g (z, y)\n\ngoal (1 subgoal):\n 1. link g \\<noteq> g", "by(auto simp add: fun_eq_iff)"], ["proof (state)\nthis:\n  link g \\<noteq> g\n\ngoal (1 subgoal):\n 1. d_OUT g x \\<noteq> d_IN g x \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  link g \\<noteq> g\n\ngoal (1 subgoal):\n 1. d_OUT g x \\<noteq> d_IN g x \\<Longrightarrow> False", "have \"link g = g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. link g = g", "using f'"], ["proof (prove)\nusing this:\n  f' \\<in> Field leq\n\ngoal (1 subgoal):\n 1. link g = g", "unfolding g_def"], ["proof (prove)\nusing this:\n  f' \\<in> Field leq\n\ngoal (1 subgoal):\n 1. link (fixp_above f') = fixp_above f'", "by(rule fixp_above_unfold[symmetric])"], ["proof (state)\nthis:\n  link g = g\n\ngoal (1 subgoal):\n 1. d_OUT g x \\<noteq> d_IN g x \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  link g \\<noteq> g\n  link g = g", "show False"], ["proof (prove)\nusing this:\n  link g \\<noteq> g\n  link g = g\n\ngoal (1 subgoal):\n 1. False", "by contradiction"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>?x \\<notin> A \\<Gamma>; ?x \\<notin> B \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> KIR g ?x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<notin> A \\<Gamma> \\<Longrightarrow> d_OUT g x \\<le> d_IN g x", "show \"d_OUT g x \\<le> d_IN g x\" if \"x \\<notin> A \\<Gamma>\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT g x \\<le> d_IN g x", "using KIR[of x] that B[of x]"], ["proof (prove)\nusing this:\n  \\<lbrakk>x \\<notin> A \\<Gamma>; x \\<notin> B \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> KIR g x\n  x \\<notin> A \\<Gamma>\n  x \\<in> B \\<Gamma> \\<Longrightarrow> d_OUT g x = 0\n\ngoal (1 subgoal):\n 1. d_OUT g x \\<le> d_IN g x", "by(cases \"x \\<in> B \\<Gamma>\") auto"], ["proof (state)\nthis:\n  ?x \\<notin> A \\<Gamma> \\<Longrightarrow> d_OUT g ?x \\<le> d_IN g ?x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  web_flow \\<Gamma> g\n\ngoal (1 subgoal):\n 1. linkable \\<Gamma>", "ultimately"], ["proof (chain)\npicking this:\n  linkage \\<Gamma> g\n  web_flow \\<Gamma> g", "show ?thesis"], ["proof (prove)\nusing this:\n  linkage \\<Gamma> g\n  web_flow \\<Gamma> g\n\ngoal (1 subgoal):\n 1. linkable \\<Gamma>", "by blast"], ["proof (state)\nthis:\n  linkable \\<Gamma>\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "subsection \\<open>Extending a wave by a linkage\\<close>"], ["", "lemma linkage_quotient_webD:\n  fixes \\<Gamma> :: \"('v, 'more) web_scheme\" (structure) and h g\n  defines \"k \\<equiv> plus_current h g\"\n  assumes f: \"current \\<Gamma> f\"\n  and w: \"wave \\<Gamma> f\"\n  and wg: \"web_flow (quotient_web \\<Gamma> f) g\" (is \"web_flow ?\\<Gamma> _\")\n  and link: \"linkage (quotient_web \\<Gamma> f) g\"\n  and trim: \"trimming \\<Gamma> f h\"\n  shows \"web_flow \\<Gamma> k\"\n  and \"orthogonal_current \\<Gamma> k (\\<E> (TER f))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. web_flow \\<Gamma> k &&& orthogonal_current \\<Gamma> k (\\<E> (TER f))", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. web_flow \\<Gamma> k\n 2. orthogonal_current \\<Gamma> k (\\<E> (TER f))", "from wg"], ["proof (chain)\npicking this:\n  web_flow (quotient_web \\<Gamma> f) g", "have g: \"current ?\\<Gamma> g\""], ["proof (prove)\nusing this:\n  web_flow (quotient_web \\<Gamma> f) g\n\ngoal (1 subgoal):\n 1. current (quotient_web \\<Gamma> f) g", "by(rule web_flowD_current)"], ["proof (state)\nthis:\n  current (quotient_web \\<Gamma> f) g\n\ngoal (2 subgoals):\n 1. web_flow \\<Gamma> k\n 2. orthogonal_current \\<Gamma> k (\\<E> (TER f))", "from trim"], ["proof (chain)\npicking this:\n  trimming \\<Gamma> f h", "obtain h: \"current \\<Gamma> h\" and w': \"wave \\<Gamma> h\" and h_le_f: \"\\<And>e. h e \\<le> f e\"\n    and KIR: \"\\<And>x. \\<lbrakk>x \\<in> RF\\<^sup>\\<circ> (TER f); x \\<notin> A \\<Gamma>\\<rbrakk> \\<Longrightarrow> KIR h x\"\n    and TER: \"TER h \\<supseteq> \\<E> (TER f) - A \\<Gamma>\""], ["proof (prove)\nusing this:\n  trimming \\<Gamma> f h\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>current \\<Gamma> h; wave \\<Gamma> h; \\<And>e. h e \\<le> f e;\n      \\<And>x.\n         \\<lbrakk>x \\<in> RF\\<^sup>\\<circ> (TER f);\n          x \\<notin> A \\<Gamma>\\<rbrakk>\n         \\<Longrightarrow> KIR h x;\n      \\<E> (TER f) - A \\<Gamma> \\<subseteq> TER h\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases)(auto simp add: le_fun_def)"], ["proof (state)\nthis:\n  current \\<Gamma> h\n  wave \\<Gamma> h\n  h ?e \\<le> f ?e\n  \\<lbrakk>?x \\<in> RF\\<^sup>\\<circ> (TER f);\n   ?x \\<notin> A \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> KIR h ?x\n  \\<E> (TER f) - A \\<Gamma> \\<subseteq> TER h\n\ngoal (2 subgoals):\n 1. web_flow \\<Gamma> k\n 2. orthogonal_current \\<Gamma> k (\\<E> (TER f))", "have eq: \"quotient_web \\<Gamma> f = quotient_web \\<Gamma> h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. quotient_web \\<Gamma> f = quotient_web \\<Gamma> h", "using w trim"], ["proof (prove)\nusing this:\n  wave \\<Gamma> f\n  trimming \\<Gamma> f h\n\ngoal (1 subgoal):\n 1. quotient_web \\<Gamma> f = quotient_web \\<Gamma> h", "by(rule quotient_web_trimming)"], ["proof (state)\nthis:\n  quotient_web \\<Gamma> f = quotient_web \\<Gamma> h\n\ngoal (2 subgoals):\n 1. web_flow \\<Gamma> k\n 2. orthogonal_current \\<Gamma> k (\\<E> (TER f))", "let ?T = \"\\<E> (TER f)\""], ["proof (state)\ngoal (2 subgoals):\n 1. web_flow \\<Gamma> k\n 2. orthogonal_current \\<Gamma> k (\\<E> (TER f))", "have RFc: \"RF\\<^sup>\\<circ> (TER h) = RF\\<^sup>\\<circ> (TER f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RF\\<^sup>\\<circ> (TER h) = RF\\<^sup>\\<circ> (TER f)", "by(subst (1 2) roofed_circ_essential[symmetric])(simp only: trimming_\\<E>[OF w trim])"], ["proof (state)\nthis:\n  RF\\<^sup>\\<circ> (TER h) = RF\\<^sup>\\<circ> (TER f)\n\ngoal (2 subgoals):\n 1. web_flow \\<Gamma> k\n 2. orthogonal_current \\<Gamma> k (\\<E> (TER f))", "have OUT_k: \"d_OUT k x = (if x \\<in> RF\\<^sup>\\<circ> (TER f) then d_OUT h x else d_OUT g x)\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT k x =\n    (if x \\<in> RF\\<^sup>\\<circ> (TER f) then d_OUT h x else d_OUT g x)", "using OUT_plus_current[OF h w', of g] web_flowD_current[OF wg]"], ["proof (prove)\nusing this:\n  current (quotient_web \\<Gamma> h) g \\<Longrightarrow>\n  d_OUT (plus_current h g) ?x =\n  (if ?x \\<in> RF\\<^sup>\\<circ> (TER h) then d_OUT h ?x else d_OUT g ?x)\n  current (quotient_web \\<Gamma> f) g\n\ngoal (1 subgoal):\n 1. d_OUT k x =\n    (if x \\<in> RF\\<^sup>\\<circ> (TER f) then d_OUT h x else d_OUT g x)", "unfolding eq k_def RFc"], ["proof (prove)\nusing this:\n  current (quotient_web \\<Gamma> h) g \\<Longrightarrow>\n  d_OUT (plus_current h g) ?x =\n  (if ?x \\<in> RF\\<^sup>\\<circ> (TER f) then d_OUT h ?x else d_OUT g ?x)\n  current (quotient_web \\<Gamma> h) g\n\ngoal (1 subgoal):\n 1. d_OUT (plus_current h g) x =\n    (if x \\<in> RF\\<^sup>\\<circ> (TER f) then d_OUT h x else d_OUT g x)", "by simp"], ["proof (state)\nthis:\n  d_OUT k ?x =\n  (if ?x \\<in> RF\\<^sup>\\<circ> (TER f) then d_OUT h ?x else d_OUT g ?x)\n\ngoal (2 subgoals):\n 1. web_flow \\<Gamma> k\n 2. orthogonal_current \\<Gamma> k (\\<E> (TER f))", "have RF: \"RF (TER h) = RF (TER f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RF (TER h) = RF (TER f)", "by(subst (1 2) RF_essential[symmetric])(simp only: trimming_\\<E>[OF w trim])"], ["proof (state)\nthis:\n  RF (TER h) = RF (TER f)\n\ngoal (2 subgoals):\n 1. web_flow \\<Gamma> k\n 2. orthogonal_current \\<Gamma> k (\\<E> (TER f))", "have IN_k: \"d_IN k x = (if x \\<in> RF (TER f) then d_IN h x else d_IN g x)\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN k x = (if x \\<in> RF (TER f) then d_IN h x else d_IN g x)", "using IN_plus_current[OF h w', of g] web_flowD_current[OF wg]"], ["proof (prove)\nusing this:\n  current (quotient_web \\<Gamma> h) g \\<Longrightarrow>\n  d_IN (plus_current h g) ?x =\n  (if ?x \\<in> RF (TER h) then d_IN h ?x else d_IN g ?x)\n  current (quotient_web \\<Gamma> f) g\n\ngoal (1 subgoal):\n 1. d_IN k x = (if x \\<in> RF (TER f) then d_IN h x else d_IN g x)", "unfolding eq k_def RF"], ["proof (prove)\nusing this:\n  current (quotient_web \\<Gamma> h) g \\<Longrightarrow>\n  d_IN (plus_current h g) ?x =\n  (if ?x \\<in> RF (TER f) then d_IN h ?x else d_IN g ?x)\n  current (quotient_web \\<Gamma> h) g\n\ngoal (1 subgoal):\n 1. d_IN (plus_current h g) x =\n    (if x \\<in> RF (TER f) then d_IN h x else d_IN g x)", "by simp"], ["proof (state)\nthis:\n  d_IN k ?x = (if ?x \\<in> RF (TER f) then d_IN h ?x else d_IN g ?x)\n\ngoal (2 subgoals):\n 1. web_flow \\<Gamma> k\n 2. orthogonal_current \\<Gamma> k (\\<E> (TER f))", "have k: \"current \\<Gamma> k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. current \\<Gamma> k", "unfolding k_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. current \\<Gamma> (plus_current h g)", "using h w' g"], ["proof (prove)\nusing this:\n  current \\<Gamma> h\n  wave \\<Gamma> h\n  current (quotient_web \\<Gamma> f) g\n\ngoal (1 subgoal):\n 1. current \\<Gamma> (plus_current h g)", "unfolding eq"], ["proof (prove)\nusing this:\n  current \\<Gamma> h\n  wave \\<Gamma> h\n  current (quotient_web \\<Gamma> h) g\n\ngoal (1 subgoal):\n 1. current \\<Gamma> (plus_current h g)", "by(rule current_plus_current)"], ["proof (state)\nthis:\n  current \\<Gamma> k\n\ngoal (2 subgoals):\n 1. web_flow \\<Gamma> k\n 2. orthogonal_current \\<Gamma> k (\\<E> (TER f))", "then"], ["proof (chain)\npicking this:\n  current \\<Gamma> k", "show wk: \"web_flow \\<Gamma> k\""], ["proof (prove)\nusing this:\n  current \\<Gamma> k\n\ngoal (1 subgoal):\n 1. web_flow \\<Gamma> k", "proof(rule web_flow)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> \\<^bold>V; x \\<notin> A \\<Gamma>;\n        x \\<notin> B \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> KIR k x", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> \\<^bold>V; x \\<notin> A \\<Gamma>;\n        x \\<notin> B \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> KIR k x", "assume \"x \\<in> \\<^bold>V\" and A: \"x \\<notin> A \\<Gamma>\" and B: \"x \\<notin> B \\<Gamma>\""], ["proof (state)\nthis:\n  x \\<in> \\<^bold>V\n  x \\<notin> A \\<Gamma>\n  x \\<notin> B \\<Gamma>\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> \\<^bold>V; x \\<notin> A \\<Gamma>;\n        x \\<notin> B \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> KIR k x", "show \"KIR k x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. KIR k x", "proof(cases \"x \\<in> \\<E> (TER f)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<in> \\<E> (TER f) \\<Longrightarrow> KIR k x\n 2. x \\<notin> \\<E> (TER f) \\<Longrightarrow> KIR k x", "case False"], ["proof (state)\nthis:\n  x \\<notin> \\<E> (TER f)\n\ngoal (2 subgoals):\n 1. x \\<in> \\<E> (TER f) \\<Longrightarrow> KIR k x\n 2. x \\<notin> \\<E> (TER f) \\<Longrightarrow> KIR k x", "thus ?thesis"], ["proof (prove)\nusing this:\n  x \\<notin> \\<E> (TER f)\n\ngoal (1 subgoal):\n 1. KIR k x", "using A KIR[of x] web_flowD_KIR[OF wg, of x] B"], ["proof (prove)\nusing this:\n  x \\<notin> \\<E> (TER f)\n  x \\<notin> A \\<Gamma>\n  \\<lbrakk>x \\<in> RF\\<^sup>\\<circ> (TER f); x \\<notin> A \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> KIR h x\n  \\<lbrakk>x \\<notin> A (quotient_web \\<Gamma> f);\n   x \\<notin> B (quotient_web \\<Gamma> f)\\<rbrakk>\n  \\<Longrightarrow> KIR g x\n  x \\<notin> B \\<Gamma>\n\ngoal (1 subgoal):\n 1. KIR k x", "by(auto simp add: OUT_k IN_k roofed_circ_def)"], ["proof (state)\nthis:\n  KIR k x\n\ngoal (1 subgoal):\n 1. x \\<in> \\<E> (TER f) \\<Longrightarrow> KIR k x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<in> \\<E> (TER f) \\<Longrightarrow> KIR k x", "case True"], ["proof (state)\nthis:\n  x \\<in> \\<E> (TER f)\n\ngoal (1 subgoal):\n 1. x \\<in> \\<E> (TER f) \\<Longrightarrow> KIR k x", "with A TER"], ["proof (chain)\npicking this:\n  x \\<notin> A \\<Gamma>\n  \\<E> (TER f) - A \\<Gamma> \\<subseteq> TER h\n  x \\<in> \\<E> (TER f)", "have [simp]: \"d_OUT h x = 0\" and \"d_IN h x \\<ge> weight \\<Gamma> x\""], ["proof (prove)\nusing this:\n  x \\<notin> A \\<Gamma>\n  \\<E> (TER f) - A \\<Gamma> \\<subseteq> TER h\n  x \\<in> \\<E> (TER f)\n\ngoal (1 subgoal):\n 1. d_OUT h x = 0 &&& weight \\<Gamma> x \\<le> d_IN h x", "by(auto simp add: SINK.simps elim: SAT.cases)"], ["proof (state)\nthis:\n  d_OUT h x = 0\n  weight \\<Gamma> x \\<le> d_IN h x\n\ngoal (1 subgoal):\n 1. x \\<in> \\<E> (TER f) \\<Longrightarrow> KIR k x", "with currentD_weight_IN[OF h, of x]"], ["proof (chain)\npicking this:\n  d_IN h x \\<le> weight \\<Gamma> x\n  d_OUT h x = 0\n  weight \\<Gamma> x \\<le> d_IN h x", "have [simp]: \"d_IN h x = weight \\<Gamma> x\""], ["proof (prove)\nusing this:\n  d_IN h x \\<le> weight \\<Gamma> x\n  d_OUT h x = 0\n  weight \\<Gamma> x \\<le> d_IN h x\n\ngoal (1 subgoal):\n 1. d_IN h x = weight \\<Gamma> x", "by auto"], ["proof (state)\nthis:\n  d_IN h x = weight \\<Gamma> x\n\ngoal (1 subgoal):\n 1. x \\<in> \\<E> (TER f) \\<Longrightarrow> KIR k x", "from linkageD[OF link, of x] True currentD_IN[OF g, of x] B"], ["proof (chain)\npicking this:\n  x \\<in> A (quotient_web \\<Gamma> f) \\<Longrightarrow>\n  d_OUT g x = weight (quotient_web \\<Gamma> f) x\n  x \\<in> \\<E> (TER f)\n  x \\<in> A (quotient_web \\<Gamma> f) \\<Longrightarrow> d_IN g x = 0\n  x \\<notin> B \\<Gamma>", "have \"d_OUT g x = weight \\<Gamma> x\" \"d_IN g x = 0\""], ["proof (prove)\nusing this:\n  x \\<in> A (quotient_web \\<Gamma> f) \\<Longrightarrow>\n  d_OUT g x = weight (quotient_web \\<Gamma> f) x\n  x \\<in> \\<E> (TER f)\n  x \\<in> A (quotient_web \\<Gamma> f) \\<Longrightarrow> d_IN g x = 0\n  x \\<notin> B \\<Gamma>\n\ngoal (1 subgoal):\n 1. d_OUT g x = weight \\<Gamma> x &&& d_IN g x = 0", "by(auto simp add: roofed_circ_def)"], ["proof (state)\nthis:\n  d_OUT g x = weight \\<Gamma> x\n  d_IN g x = 0\n\ngoal (1 subgoal):\n 1. x \\<in> \\<E> (TER f) \\<Longrightarrow> KIR k x", "thus ?thesis"], ["proof (prove)\nusing this:\n  d_OUT g x = weight \\<Gamma> x\n  d_IN g x = 0\n\ngoal (1 subgoal):\n 1. KIR k x", "using True"], ["proof (prove)\nusing this:\n  d_OUT g x = weight \\<Gamma> x\n  d_IN g x = 0\n  x \\<in> \\<E> (TER f)\n\ngoal (1 subgoal):\n 1. KIR k x", "by(auto simp add: IN_k OUT_k roofed_circ_def intro: roofed_greaterI)"], ["proof (state)\nthis:\n  KIR k x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  KIR k x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  web_flow \\<Gamma> k\n\ngoal (1 subgoal):\n 1. orthogonal_current \\<Gamma> k (\\<E> (TER f))", "have h_le_k: \"h e \\<le> k e\" for e"], ["proof (prove)\ngoal (1 subgoal):\n 1. h e \\<le> k e", "unfolding k_def plus_current_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. h e \\<le> h e + g e", "by(rule add_increasing2) simp_all"], ["proof (state)\nthis:\n  h ?e \\<le> k ?e\n\ngoal (1 subgoal):\n 1. orthogonal_current \\<Gamma> k (\\<E> (TER f))", "hence \"SAT \\<Gamma> h \\<subseteq> SAT \\<Gamma> k\""], ["proof (prove)\nusing this:\n  h ?e \\<le> k ?e\n\ngoal (1 subgoal):\n 1. SAT \\<Gamma> h \\<subseteq> SAT \\<Gamma> k", "by(rule SAT_mono)"], ["proof (state)\nthis:\n  SAT \\<Gamma> h \\<subseteq> SAT \\<Gamma> k\n\ngoal (1 subgoal):\n 1. orthogonal_current \\<Gamma> k (\\<E> (TER f))", "hence SAT: \"?T \\<subseteq> SAT \\<Gamma> k\""], ["proof (prove)\nusing this:\n  SAT \\<Gamma> h \\<subseteq> SAT \\<Gamma> k\n\ngoal (1 subgoal):\n 1. \\<E> (TER f) \\<subseteq> SAT \\<Gamma> k", "using TER"], ["proof (prove)\nusing this:\n  SAT \\<Gamma> h \\<subseteq> SAT \\<Gamma> k\n  \\<E> (TER f) - A \\<Gamma> \\<subseteq> TER h\n\ngoal (1 subgoal):\n 1. \\<E> (TER f) \\<subseteq> SAT \\<Gamma> k", "by(auto simp add: elim!: SAT.cases intro: SAT.intros)"], ["proof (state)\nthis:\n  \\<E> (TER f) \\<subseteq> SAT \\<Gamma> k\n\ngoal (1 subgoal):\n 1. orthogonal_current \\<Gamma> k (\\<E> (TER f))", "show \"orthogonal_current \\<Gamma> k ?T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. orthogonal_current \\<Gamma> k (\\<E> (TER f))", "proof(rule orthogonal_current)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> \\<E> (TER f); x \\<notin> A \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> weight \\<Gamma> x \\<le> d_IN k x\n 2. \\<And>x.\n       \\<lbrakk>x \\<in> \\<E> (TER f); x \\<in> A \\<Gamma>;\n        x \\<notin> B \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> d_OUT k x = weight \\<Gamma> x\n 3. \\<And>u v.\n       \\<lbrakk>v \\<in> RF (\\<E> (TER f));\n        u \\<notin> RF\\<^sup>\\<circ> (\\<E> (TER f))\\<rbrakk>\n       \\<Longrightarrow> k (u, v) = 0", "show \"weight \\<Gamma> x \\<le> d_IN k x\" if \"x \\<in> ?T\" \"x \\<notin> A \\<Gamma>\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. weight \\<Gamma> x \\<le> d_IN k x", "using subsetD[OF SAT, of x] that"], ["proof (prove)\nusing this:\n  x \\<in> \\<E> (TER f) \\<Longrightarrow> x \\<in> SAT \\<Gamma> k\n  x \\<in> \\<E> (TER f)\n  x \\<notin> A \\<Gamma>\n\ngoal (1 subgoal):\n 1. weight \\<Gamma> x \\<le> d_IN k x", "by(auto simp add: currentD_SAT[OF k])"], ["proof (state)\nthis:\n  \\<lbrakk>?x \\<in> \\<E> (TER f); ?x \\<notin> A \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> weight \\<Gamma> ?x \\<le> d_IN k ?x\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> \\<E> (TER f); x \\<in> A \\<Gamma>;\n        x \\<notin> B \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> d_OUT k x = weight \\<Gamma> x\n 2. \\<And>u v.\n       \\<lbrakk>v \\<in> RF (\\<E> (TER f));\n        u \\<notin> RF\\<^sup>\\<circ> (\\<E> (TER f))\\<rbrakk>\n       \\<Longrightarrow> k (u, v) = 0", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> \\<E> (TER f); x \\<in> A \\<Gamma>;\n        x \\<notin> B \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> d_OUT k x = weight \\<Gamma> x\n 2. \\<And>u v.\n       \\<lbrakk>v \\<in> RF (\\<E> (TER f));\n        u \\<notin> RF\\<^sup>\\<circ> (\\<E> (TER f))\\<rbrakk>\n       \\<Longrightarrow> k (u, v) = 0", "fix x"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> \\<E> (TER f); x \\<in> A \\<Gamma>;\n        x \\<notin> B \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> d_OUT k x = weight \\<Gamma> x\n 2. \\<And>u v.\n       \\<lbrakk>v \\<in> RF (\\<E> (TER f));\n        u \\<notin> RF\\<^sup>\\<circ> (\\<E> (TER f))\\<rbrakk>\n       \\<Longrightarrow> k (u, v) = 0", "assume x: \"x \\<in> ?T\" and A: \"x \\<in> A \\<Gamma>\" and B: \"x \\<notin> B \\<Gamma>\""], ["proof (state)\nthis:\n  x \\<in> \\<E> (TER f)\n  x \\<in> A \\<Gamma>\n  x \\<notin> B \\<Gamma>\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> \\<E> (TER f); x \\<in> A \\<Gamma>;\n        x \\<notin> B \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> d_OUT k x = weight \\<Gamma> x\n 2. \\<And>u v.\n       \\<lbrakk>v \\<in> RF (\\<E> (TER f));\n        u \\<notin> RF\\<^sup>\\<circ> (\\<E> (TER f))\\<rbrakk>\n       \\<Longrightarrow> k (u, v) = 0", "with d_OUT_mono[of h x f, OF h_le_f]"], ["proof (chain)\npicking this:\n  d_OUT h x \\<le> d_OUT f x\n  x \\<in> \\<E> (TER f)\n  x \\<in> A \\<Gamma>\n  x \\<notin> B \\<Gamma>", "have \"d_OUT h x = 0\""], ["proof (prove)\nusing this:\n  d_OUT h x \\<le> d_OUT f x\n  x \\<in> \\<E> (TER f)\n  x \\<in> A \\<Gamma>\n  x \\<notin> B \\<Gamma>\n\ngoal (1 subgoal):\n 1. d_OUT h x = 0", "by(auto simp add: SINK.simps)"], ["proof (state)\nthis:\n  d_OUT h x = 0\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> \\<E> (TER f); x \\<in> A \\<Gamma>;\n        x \\<notin> B \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> d_OUT k x = weight \\<Gamma> x\n 2. \\<And>u v.\n       \\<lbrakk>v \\<in> RF (\\<E> (TER f));\n        u \\<notin> RF\\<^sup>\\<circ> (\\<E> (TER f))\\<rbrakk>\n       \\<Longrightarrow> k (u, v) = 0", "moreover"], ["proof (state)\nthis:\n  d_OUT h x = 0\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> \\<E> (TER f); x \\<in> A \\<Gamma>;\n        x \\<notin> B \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> d_OUT k x = weight \\<Gamma> x\n 2. \\<And>u v.\n       \\<lbrakk>v \\<in> RF (\\<E> (TER f));\n        u \\<notin> RF\\<^sup>\\<circ> (\\<E> (TER f))\\<rbrakk>\n       \\<Longrightarrow> k (u, v) = 0", "from linkageD[OF link, of x] x A"], ["proof (chain)\npicking this:\n  x \\<in> A (quotient_web \\<Gamma> f) \\<Longrightarrow>\n  d_OUT g x = weight (quotient_web \\<Gamma> f) x\n  x \\<in> \\<E> (TER f)\n  x \\<in> A \\<Gamma>", "have \"d_OUT g x = weight ?\\<Gamma> x\""], ["proof (prove)\nusing this:\n  x \\<in> A (quotient_web \\<Gamma> f) \\<Longrightarrow>\n  d_OUT g x = weight (quotient_web \\<Gamma> f) x\n  x \\<in> \\<E> (TER f)\n  x \\<in> A \\<Gamma>\n\ngoal (1 subgoal):\n 1. d_OUT g x = weight (quotient_web \\<Gamma> f) x", "by simp"], ["proof (state)\nthis:\n  d_OUT g x = weight (quotient_web \\<Gamma> f) x\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> \\<E> (TER f); x \\<in> A \\<Gamma>;\n        x \\<notin> B \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> d_OUT k x = weight \\<Gamma> x\n 2. \\<And>u v.\n       \\<lbrakk>v \\<in> RF (\\<E> (TER f));\n        u \\<notin> RF\\<^sup>\\<circ> (\\<E> (TER f))\\<rbrakk>\n       \\<Longrightarrow> k (u, v) = 0", "ultimately"], ["proof (chain)\npicking this:\n  d_OUT h x = 0\n  d_OUT g x = weight (quotient_web \\<Gamma> f) x", "show \"d_OUT k x = weight \\<Gamma> x\""], ["proof (prove)\nusing this:\n  d_OUT h x = 0\n  d_OUT g x = weight (quotient_web \\<Gamma> f) x\n\ngoal (1 subgoal):\n 1. d_OUT k x = weight \\<Gamma> x", "using x A currentD_IN[OF f A] B"], ["proof (prove)\nusing this:\n  d_OUT h x = 0\n  d_OUT g x = weight (quotient_web \\<Gamma> f) x\n  x \\<in> \\<E> (TER f)\n  x \\<in> A \\<Gamma>\n  d_IN f x = 0\n  x \\<notin> B \\<Gamma>\n\ngoal (1 subgoal):\n 1. d_OUT k x = weight \\<Gamma> x", "by(auto simp add: d_OUT_add roofed_circ_def k_def plus_current_def )"], ["proof (state)\nthis:\n  d_OUT k x = weight \\<Gamma> x\n\ngoal (1 subgoal):\n 1. \\<And>u v.\n       \\<lbrakk>v \\<in> RF (\\<E> (TER f));\n        u \\<notin> RF\\<^sup>\\<circ> (\\<E> (TER f))\\<rbrakk>\n       \\<Longrightarrow> k (u, v) = 0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>u v.\n       \\<lbrakk>v \\<in> RF (\\<E> (TER f));\n        u \\<notin> RF\\<^sup>\\<circ> (\\<E> (TER f))\\<rbrakk>\n       \\<Longrightarrow> k (u, v) = 0", "fix u v"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>u v.\n       \\<lbrakk>v \\<in> RF (\\<E> (TER f));\n        u \\<notin> RF\\<^sup>\\<circ> (\\<E> (TER f))\\<rbrakk>\n       \\<Longrightarrow> k (u, v) = 0", "assume v: \"v \\<in> RF ?T\" and u: \"u \\<notin> RF\\<^sup>\\<circ> ?T\""], ["proof (state)\nthis:\n  v \\<in> RF (\\<E> (TER f))\n  u \\<notin> RF\\<^sup>\\<circ> (\\<E> (TER f))\n\ngoal (1 subgoal):\n 1. \\<And>u v.\n       \\<lbrakk>v \\<in> RF (\\<E> (TER f));\n        u \\<notin> RF\\<^sup>\\<circ> (\\<E> (TER f))\\<rbrakk>\n       \\<Longrightarrow> k (u, v) = 0", "have \"h (u, v) \\<le> f (u, v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h (u, v) \\<le> f (u, v)", "by(rule h_le_f)"], ["proof (state)\nthis:\n  h (u, v) \\<le> f (u, v)\n\ngoal (1 subgoal):\n 1. \\<And>u v.\n       \\<lbrakk>v \\<in> RF (\\<E> (TER f));\n        u \\<notin> RF\\<^sup>\\<circ> (\\<E> (TER f))\\<rbrakk>\n       \\<Longrightarrow> k (u, v) = 0", "also"], ["proof (state)\nthis:\n  h (u, v) \\<le> f (u, v)\n\ngoal (1 subgoal):\n 1. \\<And>u v.\n       \\<lbrakk>v \\<in> RF (\\<E> (TER f));\n        u \\<notin> RF\\<^sup>\\<circ> (\\<E> (TER f))\\<rbrakk>\n       \\<Longrightarrow> k (u, v) = 0", "have \"\\<dots> \\<le> d_OUT f u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f (u, v) \\<le> d_OUT f u", "unfolding d_OUT_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. f (u, v) \\<le> (\\<Sum>\\<^sup>+ y. f (u, y))", "by(rule nn_integral_ge_point) simp"], ["proof (state)\nthis:\n  f (u, v) \\<le> d_OUT f u\n\ngoal (1 subgoal):\n 1. \\<And>u v.\n       \\<lbrakk>v \\<in> RF (\\<E> (TER f));\n        u \\<notin> RF\\<^sup>\\<circ> (\\<E> (TER f))\\<rbrakk>\n       \\<Longrightarrow> k (u, v) = 0", "also"], ["proof (state)\nthis:\n  f (u, v) \\<le> d_OUT f u\n\ngoal (1 subgoal):\n 1. \\<And>u v.\n       \\<lbrakk>v \\<in> RF (\\<E> (TER f));\n        u \\<notin> RF\\<^sup>\\<circ> (\\<E> (TER f))\\<rbrakk>\n       \\<Longrightarrow> k (u, v) = 0", "have \"\\<dots> = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT f u = 0", "using u"], ["proof (prove)\nusing this:\n  u \\<notin> RF\\<^sup>\\<circ> (\\<E> (TER f))\n\ngoal (1 subgoal):\n 1. d_OUT f u = 0", "using RF_essential[of \\<Gamma> \"TER f\"]"], ["proof (prove)\nusing this:\n  u \\<notin> RF\\<^sup>\\<circ> (\\<E> (TER f))\n  RF (\\<E> (TER f)) = RF (TER f)\n\ngoal (1 subgoal):\n 1. d_OUT f u = 0", "by(auto simp add: roofed_circ_def SINK.simps intro: waveD_OUT[OF w])"], ["proof (state)\nthis:\n  d_OUT f u = 0\n\ngoal (1 subgoal):\n 1. \\<And>u v.\n       \\<lbrakk>v \\<in> RF (\\<E> (TER f));\n        u \\<notin> RF\\<^sup>\\<circ> (\\<E> (TER f))\\<rbrakk>\n       \\<Longrightarrow> k (u, v) = 0", "finally"], ["proof (chain)\npicking this:\n  h (u, v) \\<le> 0", "have \"h (u, v) = 0\""], ["proof (prove)\nusing this:\n  h (u, v) \\<le> 0\n\ngoal (1 subgoal):\n 1. h (u, v) = 0", "by simp"], ["proof (state)\nthis:\n  h (u, v) = 0\n\ngoal (1 subgoal):\n 1. \\<And>u v.\n       \\<lbrakk>v \\<in> RF (\\<E> (TER f));\n        u \\<notin> RF\\<^sup>\\<circ> (\\<E> (TER f))\\<rbrakk>\n       \\<Longrightarrow> k (u, v) = 0", "moreover"], ["proof (state)\nthis:\n  h (u, v) = 0\n\ngoal (1 subgoal):\n 1. \\<And>u v.\n       \\<lbrakk>v \\<in> RF (\\<E> (TER f));\n        u \\<notin> RF\\<^sup>\\<circ> (\\<E> (TER f))\\<rbrakk>\n       \\<Longrightarrow> k (u, v) = 0", "have \"g (u, v) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g (u, v) = 0", "using g v RF_essential[of \\<Gamma> \"TER f\"]"], ["proof (prove)\nusing this:\n  current (quotient_web \\<Gamma> f) g\n  v \\<in> RF (\\<E> (TER f))\n  RF (\\<E> (TER f)) = RF (TER f)\n\ngoal (1 subgoal):\n 1. g (u, v) = 0", "by(auto intro: currentD_outside simp add: roofed_circ_def)"], ["proof (state)\nthis:\n  g (u, v) = 0\n\ngoal (1 subgoal):\n 1. \\<And>u v.\n       \\<lbrakk>v \\<in> RF (\\<E> (TER f));\n        u \\<notin> RF\\<^sup>\\<circ> (\\<E> (TER f))\\<rbrakk>\n       \\<Longrightarrow> k (u, v) = 0", "ultimately"], ["proof (chain)\npicking this:\n  h (u, v) = 0\n  g (u, v) = 0", "show \"k (u, v) = 0\""], ["proof (prove)\nusing this:\n  h (u, v) = 0\n  g (u, v) = 0\n\ngoal (1 subgoal):\n 1. k (u, v) = 0", "by(simp add: k_def)"], ["proof (state)\nthis:\n  k (u, v) = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  orthogonal_current \\<Gamma> k (\\<E> (TER f))\n\ngoal:\nNo subgoals!", "qed"], ["", "context countable_web begin"], ["", "lemma ex_orthogonal_current': \\<comment> \\<open>Lemma 4.15\\<close>\n  assumes loose_linkable: \"\\<And>f. \\<lbrakk> current \\<Gamma> f; wave \\<Gamma> f; loose (quotient_web \\<Gamma> f) \\<rbrakk> \\<Longrightarrow> linkable (quotient_web \\<Gamma> f)\"\n  shows \"\\<exists>f S. web_flow \\<Gamma> f \\<and> separating \\<Gamma> S \\<and> orthogonal_current \\<Gamma> f S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>f S.\n       web_flow \\<Gamma> f \\<and>\n       separating \\<Gamma> S \\<and> orthogonal_current \\<Gamma> f S", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>f S.\n       web_flow \\<Gamma> f \\<and>\n       separating \\<Gamma> S \\<and> orthogonal_current \\<Gamma> f S", "from ex_maximal_wave[OF countable]"], ["proof (chain)\npicking this:\n  \\<exists>f.\n     current \\<Gamma> f \\<and>\n     wave \\<Gamma> f \\<and>\n     (\\<forall>w.\n         current \\<Gamma> w \\<and>\n         wave \\<Gamma> w \\<and> f \\<le> w \\<longrightarrow>\n         f = w)", "obtain f where f: \"current \\<Gamma> f\"\n    and w: \"wave \\<Gamma> f\"\n    and maximal: \"\\<And>w. \\<lbrakk> current \\<Gamma> w; wave \\<Gamma> w; f \\<le> w \\<rbrakk> \\<Longrightarrow> f = w\""], ["proof (prove)\nusing this:\n  \\<exists>f.\n     current \\<Gamma> f \\<and>\n     wave \\<Gamma> f \\<and>\n     (\\<forall>w.\n         current \\<Gamma> w \\<and>\n         wave \\<Gamma> w \\<and> f \\<le> w \\<longrightarrow>\n         f = w)\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        \\<lbrakk>current \\<Gamma> f; wave \\<Gamma> f;\n         \\<And>w.\n            \\<lbrakk>current \\<Gamma> w; wave \\<Gamma> w; f \\<le> w\\<rbrakk>\n            \\<Longrightarrow> f = w\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  current \\<Gamma> f\n  wave \\<Gamma> f\n  \\<lbrakk>current \\<Gamma> ?w; wave \\<Gamma> ?w; f \\<le> ?w\\<rbrakk>\n  \\<Longrightarrow> f = ?w\n\ngoal (1 subgoal):\n 1. \\<exists>f S.\n       web_flow \\<Gamma> f \\<and>\n       separating \\<Gamma> S \\<and> orthogonal_current \\<Gamma> f S", "from ex_trimming[OF f w countable weight_finite]"], ["proof (chain)\npicking this:\n  \\<exists>g. trimming \\<Gamma> f g", "obtain h where h: \"trimming \\<Gamma> f h\""], ["proof (prove)\nusing this:\n  \\<exists>g. trimming \\<Gamma> f g\n\ngoal (1 subgoal):\n 1. (\\<And>h.\n        trimming \\<Gamma> f h \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  trimming \\<Gamma> f h\n\ngoal (1 subgoal):\n 1. \\<exists>f S.\n       web_flow \\<Gamma> f \\<and>\n       separating \\<Gamma> S \\<and> orthogonal_current \\<Gamma> f S", "let ?\\<Gamma> = \"quotient_web \\<Gamma> f\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>f S.\n       web_flow \\<Gamma> f \\<and>\n       separating \\<Gamma> S \\<and> orthogonal_current \\<Gamma> f S", "interpret \\<Gamma>: countable_web \"?\\<Gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. countable_web (quotient_web \\<Gamma> f)", "by(rule countable_web_quotient_web)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>f S.\n       web_flow \\<Gamma> f \\<and>\n       separating \\<Gamma> S \\<and> orthogonal_current \\<Gamma> f S", "have \"loose ?\\<Gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. loose (quotient_web \\<Gamma> f)", "using f w maximal"], ["proof (prove)\nusing this:\n  current \\<Gamma> f\n  wave \\<Gamma> f\n  \\<lbrakk>current \\<Gamma> ?w; wave \\<Gamma> ?w; f \\<le> ?w\\<rbrakk>\n  \\<Longrightarrow> f = ?w\n\ngoal (1 subgoal):\n 1. loose (quotient_web \\<Gamma> f)", "by(rule loose_quotient_web[OF  weight_finite])"], ["proof (state)\nthis:\n  loose (quotient_web \\<Gamma> f)\n\ngoal (1 subgoal):\n 1. \\<exists>f S.\n       web_flow \\<Gamma> f \\<and>\n       separating \\<Gamma> S \\<and> orthogonal_current \\<Gamma> f S", "with f w"], ["proof (chain)\npicking this:\n  current \\<Gamma> f\n  wave \\<Gamma> f\n  loose (quotient_web \\<Gamma> f)", "have \"linkable ?\\<Gamma>\""], ["proof (prove)\nusing this:\n  current \\<Gamma> f\n  wave \\<Gamma> f\n  loose (quotient_web \\<Gamma> f)\n\ngoal (1 subgoal):\n 1. linkable (quotient_web \\<Gamma> f)", "by(rule loose_linkable)"], ["proof (state)\nthis:\n  linkable (quotient_web \\<Gamma> f)\n\ngoal (1 subgoal):\n 1. \\<exists>f S.\n       web_flow \\<Gamma> f \\<and>\n       separating \\<Gamma> S \\<and> orthogonal_current \\<Gamma> f S", "then"], ["proof (chain)\npicking this:\n  linkable (quotient_web \\<Gamma> f)", "obtain g where wg: \"web_flow ?\\<Gamma> g\" and link: \"linkage ?\\<Gamma> g\""], ["proof (prove)\nusing this:\n  linkable (quotient_web \\<Gamma> f)\n\ngoal (1 subgoal):\n 1. (\\<And>g.\n        \\<lbrakk>web_flow (quotient_web \\<Gamma> f) g;\n         linkage (quotient_web \\<Gamma> f) g\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  web_flow (quotient_web \\<Gamma> f) g\n  linkage (quotient_web \\<Gamma> f) g\n\ngoal (1 subgoal):\n 1. \\<exists>f S.\n       web_flow \\<Gamma> f \\<and>\n       separating \\<Gamma> S \\<and> orthogonal_current \\<Gamma> f S", "let ?k = \"plus_current h g\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>f S.\n       web_flow \\<Gamma> f \\<and>\n       separating \\<Gamma> S \\<and> orthogonal_current \\<Gamma> f S", "have \"web_flow \\<Gamma> ?k\" \"orthogonal_current \\<Gamma> ?k (\\<E> (TER f))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. web_flow \\<Gamma> (plus_current h g) &&&\n    orthogonal_current \\<Gamma> (plus_current h g) (\\<E> (TER f))", "by(rule linkage_quotient_webD[OF f w wg link h])+"], ["proof (state)\nthis:\n  web_flow \\<Gamma> (plus_current h g)\n  orthogonal_current \\<Gamma> (plus_current h g) (\\<E> (TER f))\n\ngoal (1 subgoal):\n 1. \\<exists>f S.\n       web_flow \\<Gamma> f \\<and>\n       separating \\<Gamma> S \\<and> orthogonal_current \\<Gamma> f S", "moreover"], ["proof (state)\nthis:\n  web_flow \\<Gamma> (plus_current h g)\n  orthogonal_current \\<Gamma> (plus_current h g) (\\<E> (TER f))\n\ngoal (1 subgoal):\n 1. \\<exists>f S.\n       web_flow \\<Gamma> f \\<and>\n       separating \\<Gamma> S \\<and> orthogonal_current \\<Gamma> f S", "have \"separating \\<Gamma> (\\<E> (TER f))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. separating \\<Gamma> (\\<E> (TER f))", "using waveD_separating[OF w]"], ["proof (prove)\nusing this:\n  separating \\<Gamma> (TER f)\n\ngoal (1 subgoal):\n 1. separating \\<Gamma> (\\<E> (TER f))", "by(rule separating_essential)"], ["proof (state)\nthis:\n  separating \\<Gamma> (\\<E> (TER f))\n\ngoal (1 subgoal):\n 1. \\<exists>f S.\n       web_flow \\<Gamma> f \\<and>\n       separating \\<Gamma> S \\<and> orthogonal_current \\<Gamma> f S", "ultimately"], ["proof (chain)\npicking this:\n  web_flow \\<Gamma> (plus_current h g)\n  orthogonal_current \\<Gamma> (plus_current h g) (\\<E> (TER f))\n  separating \\<Gamma> (\\<E> (TER f))", "show ?thesis"], ["proof (prove)\nusing this:\n  web_flow \\<Gamma> (plus_current h g)\n  orthogonal_current \\<Gamma> (plus_current h g) (\\<E> (TER f))\n  separating \\<Gamma> (\\<E> (TER f))\n\ngoal (1 subgoal):\n 1. \\<exists>f S.\n       web_flow \\<Gamma> f \\<and>\n       separating \\<Gamma> S \\<and> orthogonal_current \\<Gamma> f S", "by blast"], ["proof (state)\nthis:\n  \\<exists>f S.\n     web_flow \\<Gamma> f \\<and>\n     separating \\<Gamma> S \\<and> orthogonal_current \\<Gamma> f S\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "subsection \\<open>From a network to a web\\<close>"], ["", "definition web_of_network :: \"('v, 'more) network_scheme \\<Rightarrow> ('v edge, 'more) web_scheme\"\nwhere\n  \"web_of_network \\<Delta> =\n   \\<lparr>edge = \\<lambda>(x, y) (y', z). y' = y \\<and> edge \\<Delta> x y \\<and> edge \\<Delta> y z,\n    weight = capacity \\<Delta>,\n    A = {(source \\<Delta>, x)|x. edge \\<Delta> (source \\<Delta>) x},\n    B = {(x, sink \\<Delta>)|x. edge \\<Delta> x (sink \\<Delta>)},\n    \\<dots> = network.more \\<Delta>\\<rparr>\""], ["", "lemma web_of_network_sel [simp]:\n  fixes \\<Delta> (structure) shows\n  \"edge (web_of_network \\<Delta>) e e' \\<longleftrightarrow> e \\<in> \\<^bold>E \\<and> e' \\<in> \\<^bold>E \\<and> snd e = fst e'\"\n  \"weight (web_of_network \\<Delta>) e = capacity \\<Delta> e\"\n  \"A (web_of_network \\<Delta>) = {(source \\<Delta>, x)|x. edge \\<Delta> (source \\<Delta>) x}\"\n  \"B (web_of_network \\<Delta>) = {(x, sink \\<Delta>)|x. edge \\<Delta> x (sink \\<Delta>)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (edge (web_of_network \\<Delta>) e e' =\n     (e \\<in> \\<^bold>E \\<and> e' \\<in> \\<^bold>E \\<and> snd e = fst e') &&&\n     weight (web_of_network \\<Delta>) e = capacity \\<Delta> e) &&&\n    A (web_of_network \\<Delta>) =\n    {(source \\<Delta>, x) |x. edge \\<Delta> (source \\<Delta>) x} &&&\n    B (web_of_network \\<Delta>) =\n    {(x, sink \\<Delta>) |x. edge \\<Delta> x (sink \\<Delta>)}", "by(auto simp add: web_of_network_def split: prod.split)"], ["", "lemma vertex_web_of_network [simp]:\n  \"vertex (web_of_network \\<Delta>) (x, y) \\<longleftrightarrow> edge \\<Delta> x y \\<and> (\\<exists>z. edge \\<Delta> y z \\<or> edge \\<Delta> z x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vertex (web_of_network \\<Delta>) (x, y) =\n    (edge \\<Delta> x y \\<and>\n     (\\<exists>z. edge \\<Delta> y z \\<or> edge \\<Delta> z x))", "by(auto simp add: vertex_def Domainp.simps Rangep.simps)"], ["", "definition flow_of_current :: \"('v, 'more) network_scheme \\<Rightarrow> 'v edge current \\<Rightarrow> 'v flow\"\nwhere \"flow_of_current \\<Delta> f e = max (d_OUT f e) (d_IN f e)\""], ["", "lemma flow_flow_of_current:\n  fixes \\<Delta> (structure) and \\<Gamma>\n  defines [simp]: \"\\<Gamma> \\<equiv> web_of_network \\<Delta>\"\n  assumes fw: \"web_flow \\<Gamma> f\"\n  shows \"flow \\<Delta> (flow_of_current \\<Delta> f)\" (is \"flow _ ?f\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. flow \\<Delta> (flow_of_current \\<Delta> f)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>e. flow_of_current \\<Delta> f e \\<le> capacity \\<Delta> e\n 2. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>;\n        x \\<noteq> sink \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> KIR (flow_of_current \\<Delta> f) x", "from fw"], ["proof (chain)\npicking this:\n  web_flow \\<Gamma> f", "have f: \"current \\<Gamma> f\" and KIR: \"\\<And>x. \\<lbrakk> x \\<notin> A \\<Gamma>; x \\<notin> B \\<Gamma> \\<rbrakk> \\<Longrightarrow> KIR f x\""], ["proof (prove)\nusing this:\n  web_flow \\<Gamma> f\n\ngoal (1 subgoal):\n 1. current \\<Gamma> f &&&\n    (\\<And>x.\n        \\<lbrakk>x \\<notin> A \\<Gamma>; x \\<notin> B \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> KIR f x)", "by(auto 4 3 dest: web_flowD_current web_flowD_KIR)"], ["proof (state)\nthis:\n  current \\<Gamma> f\n  \\<lbrakk>?x \\<notin> A \\<Gamma>; ?x \\<notin> B \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> KIR f ?x\n\ngoal (2 subgoals):\n 1. \\<And>e. flow_of_current \\<Delta> f e \\<le> capacity \\<Delta> e\n 2. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>;\n        x \\<noteq> sink \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> KIR (flow_of_current \\<Delta> f) x", "show \"?f e \\<le> capacity \\<Delta> e\" for e"], ["proof (prove)\ngoal (1 subgoal):\n 1. flow_of_current \\<Delta> f e \\<le> capacity \\<Delta> e", "using currentD_weight_OUT[OF f, of e] currentD_weight_IN[OF f, of e]"], ["proof (prove)\nusing this:\n  d_OUT f e \\<le> weight \\<Gamma> e\n  d_IN f e \\<le> weight \\<Gamma> e\n\ngoal (1 subgoal):\n 1. flow_of_current \\<Delta> f e \\<le> capacity \\<Delta> e", "by(simp add: flow_of_current_def)"], ["proof (state)\nthis:\n  flow_of_current \\<Delta> f ?e \\<le> capacity \\<Delta> ?e\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>;\n        x \\<noteq> sink \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> KIR (flow_of_current \\<Delta> f) x", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>;\n        x \\<noteq> sink \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> KIR (flow_of_current \\<Delta> f) x", "assume x: \"x \\<noteq> source \\<Delta>\" \"x \\<noteq> sink \\<Delta>\""], ["proof (state)\nthis:\n  x \\<noteq> source \\<Delta>\n  x \\<noteq> sink \\<Delta>\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>;\n        x \\<noteq> sink \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> KIR (flow_of_current \\<Delta> f) x", "have \"d_OUT ?f x = (\\<Sum>\\<^sup>+ y. d_IN f (x, y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT (flow_of_current \\<Delta> f) x = (\\<Sum>\\<^sup>+ y. d_IN f (x, y))", "unfolding d_OUT_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y. flow_of_current \\<Delta> f (x, y)) =\n    (\\<Sum>\\<^sup>+ y. d_IN f (x, y))", "by(simp add: flow_of_current_def max_absorb2 currentD_OUT_IN[OF f] x)"], ["proof (state)\nthis:\n  d_OUT (flow_of_current \\<Delta> f) x = (\\<Sum>\\<^sup>+ y. d_IN f (x, y))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>;\n        x \\<noteq> sink \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> KIR (flow_of_current \\<Delta> f) x", "also"], ["proof (state)\nthis:\n  d_OUT (flow_of_current \\<Delta> f) x = (\\<Sum>\\<^sup>+ y. d_IN f (x, y))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>;\n        x \\<noteq> sink \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> KIR (flow_of_current \\<Delta> f) x", "have \"\\<dots> = (\\<Sum>\\<^sup>+ y. \\<Sum>\\<^sup>+ e\\<in>range (\\<lambda>z. (z, x)). f (e, x, y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y. d_IN f (x, y)) =\n    (\\<Sum>\\<^sup>+ y.\n       \\<Sum>\\<^sup>+ e\\<in>range (\\<lambda>z. (z, x)). f (e, x, y))", "by(auto simp add: nn_integral_count_space_indicator d_IN_def intro!: nn_integral_cong currentD_outside[OF f] split: split_indicator)"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y. d_IN f (x, y)) =\n  (\\<Sum>\\<^sup>+ y.\n     \\<Sum>\\<^sup>+ e\\<in>range (\\<lambda>z. (z, x)). f (e, x, y))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>;\n        x \\<noteq> sink \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> KIR (flow_of_current \\<Delta> f) x", "also"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y. d_IN f (x, y)) =\n  (\\<Sum>\\<^sup>+ y.\n     \\<Sum>\\<^sup>+ e\\<in>range (\\<lambda>z. (z, x)). f (e, x, y))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>;\n        x \\<noteq> sink \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> KIR (flow_of_current \\<Delta> f) x", "have \"\\<dots> = (\\<Sum>\\<^sup>+ z\\<in>UNIV. \\<Sum>\\<^sup>+ y. f ((z, x), x, y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y.\n       \\<Sum>\\<^sup>+ e\\<in>range (\\<lambda>z. (z, x)). f (e, x, y)) =\n    (\\<Sum>\\<^sup>+ z. \\<Sum>\\<^sup>+ y. f ((z, x), x, y))", "by(subst nn_integral_snd_count_space[of \"case_prod _\", simplified])\n      (simp add: nn_integral_count_space_reindex nn_integral_fst_count_space[of \"case_prod _\", simplified])"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y.\n     \\<Sum>\\<^sup>+ e\\<in>range (\\<lambda>z. (z, x)). f (e, x, y)) =\n  (\\<Sum>\\<^sup>+ z. \\<Sum>\\<^sup>+ y. f ((z, x), x, y))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>;\n        x \\<noteq> sink \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> KIR (flow_of_current \\<Delta> f) x", "also"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y.\n     \\<Sum>\\<^sup>+ e\\<in>range (\\<lambda>z. (z, x)). f (e, x, y)) =\n  (\\<Sum>\\<^sup>+ z. \\<Sum>\\<^sup>+ y. f ((z, x), x, y))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>;\n        x \\<noteq> sink \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> KIR (flow_of_current \\<Delta> f) x", "have \"\\<dots> = (\\<Sum>\\<^sup>+ z. \\<Sum>\\<^sup>+ e\\<in>range (Pair x). f ((z, x), e))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ z. \\<Sum>\\<^sup>+ y. f ((z, x), x, y)) =\n    (\\<Sum>\\<^sup>+ z. \\<Sum>\\<^sup>+ e\\<in>range (Pair x). f ((z, x), e))", "by(simp add: nn_integral_count_space_reindex)"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ z. \\<Sum>\\<^sup>+ y. f ((z, x), x, y)) =\n  (\\<Sum>\\<^sup>+ z. \\<Sum>\\<^sup>+ e\\<in>range (Pair x). f ((z, x), e))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>;\n        x \\<noteq> sink \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> KIR (flow_of_current \\<Delta> f) x", "also"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ z. \\<Sum>\\<^sup>+ y. f ((z, x), x, y)) =\n  (\\<Sum>\\<^sup>+ z. \\<Sum>\\<^sup>+ e\\<in>range (Pair x). f ((z, x), e))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>;\n        x \\<noteq> sink \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> KIR (flow_of_current \\<Delta> f) x", "have \"\\<dots> = (\\<Sum>\\<^sup>+ z. d_OUT f (z, x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ z. \\<Sum>\\<^sup>+ e\\<in>range (Pair x). f ((z, x), e)) =\n    (\\<Sum>\\<^sup>+ z. d_OUT f (z, x))", "by(auto intro!: nn_integral_cong currentD_outside[OF f] simp add: d_OUT_def nn_integral_count_space_indicator split: split_indicator)"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ z. \\<Sum>\\<^sup>+ e\\<in>range (Pair x). f ((z, x), e)) =\n  (\\<Sum>\\<^sup>+ z. d_OUT f (z, x))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>;\n        x \\<noteq> sink \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> KIR (flow_of_current \\<Delta> f) x", "also"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ z. \\<Sum>\\<^sup>+ e\\<in>range (Pair x). f ((z, x), e)) =\n  (\\<Sum>\\<^sup>+ z. d_OUT f (z, x))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>;\n        x \\<noteq> sink \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> KIR (flow_of_current \\<Delta> f) x", "have \"\\<dots> = (\\<Sum>\\<^sup>+ z\\<in>{z. edge \\<Delta> z x}. d_OUT f (z, x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ z. d_OUT f (z, x)) =\n    (\\<Sum>\\<^sup>+ z\\<in>{z. edge \\<Delta> z x}. d_OUT f (z, x))", "by(auto intro!: nn_integral_cong currentD_outside_OUT[OF f] simp add: nn_integral_count_space_indicator split: split_indicator)"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ z. d_OUT f (z, x)) =\n  (\\<Sum>\\<^sup>+ z\\<in>{z. edge \\<Delta> z x}. d_OUT f (z, x))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>;\n        x \\<noteq> sink \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> KIR (flow_of_current \\<Delta> f) x", "also"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ z. d_OUT f (z, x)) =\n  (\\<Sum>\\<^sup>+ z\\<in>{z. edge \\<Delta> z x}. d_OUT f (z, x))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>;\n        x \\<noteq> sink \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> KIR (flow_of_current \\<Delta> f) x", "have \"\\<dots> = (\\<Sum>\\<^sup>+ z\\<in>{z. edge \\<Delta> z x}. max (d_OUT f (z, x)) (d_IN f (z, x)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ z\\<in>{z. edge \\<Delta> z x}. d_OUT f (z, x)) =\n    (\\<Sum>\\<^sup>+ z\\<in>{z. edge \\<Delta> z x}.\n       max (d_OUT f (z, x)) (d_IN f (z, x)))", "proof(rule nn_integral_cong)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> space (count_space {z. edge \\<Delta> z x}) \\<Longrightarrow>\n       d_OUT f (xa, x) = max (d_OUT f (xa, x)) (d_IN f (xa, x))", "show \"d_OUT f (z, x) = max (d_OUT f (z, x)) (d_IN f (z, x))\"\n      if \"z \\<in> space (count_space {z. edge \\<Delta> z x})\" for z"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT f (z, x) = max (d_OUT f (z, x)) (d_IN f (z, x))", "using currentD_IN[OF f] that"], ["proof (prove)\nusing this:\n  ?a \\<in> A \\<Gamma> \\<Longrightarrow> d_IN f ?a = 0\n  z \\<in> space (count_space {z. edge \\<Delta> z x})\n\ngoal (1 subgoal):\n 1. d_OUT f (z, x) = max (d_OUT f (z, x)) (d_IN f (z, x))", "by(cases \"z = source \\<Delta>\")(simp_all add: max_absorb1  currentD_IN[OF f] KIR x)"], ["proof (state)\nthis:\n  ?z \\<in> space (count_space {z. edge \\<Delta> z x}) \\<Longrightarrow>\n  d_OUT f (?z, x) = max (d_OUT f (?z, x)) (d_IN f (?z, x))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ z\\<in>{z. edge \\<Delta> z x}. d_OUT f (z, x)) =\n  (\\<Sum>\\<^sup>+ z\\<in>{z. edge \\<Delta> z x}.\n     max (d_OUT f (z, x)) (d_IN f (z, x)))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>;\n        x \\<noteq> sink \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> KIR (flow_of_current \\<Delta> f) x", "also"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ z\\<in>{z. edge \\<Delta> z x}. d_OUT f (z, x)) =\n  (\\<Sum>\\<^sup>+ z\\<in>{z. edge \\<Delta> z x}.\n     max (d_OUT f (z, x)) (d_IN f (z, x)))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>;\n        x \\<noteq> sink \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> KIR (flow_of_current \\<Delta> f) x", "have \"\\<dots> = (\\<Sum>\\<^sup>+ z. max (d_OUT f (z, x)) (d_IN f (z, x)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ z\\<in>{z. edge \\<Delta> z x}.\n       max (d_OUT f (z, x)) (d_IN f (z, x))) =\n    (\\<Sum>\\<^sup>+ z. max (d_OUT f (z, x)) (d_IN f (z, x)))", "by(auto intro!: nn_integral_cong currentD_outside_OUT[OF f] currentD_outside_IN[OF f] simp add: nn_integral_count_space_indicator max_def split: split_indicator)"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ z\\<in>{z. edge \\<Delta> z x}.\n     max (d_OUT f (z, x)) (d_IN f (z, x))) =\n  (\\<Sum>\\<^sup>+ z. max (d_OUT f (z, x)) (d_IN f (z, x)))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>;\n        x \\<noteq> sink \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> KIR (flow_of_current \\<Delta> f) x", "also"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ z\\<in>{z. edge \\<Delta> z x}.\n     max (d_OUT f (z, x)) (d_IN f (z, x))) =\n  (\\<Sum>\\<^sup>+ z. max (d_OUT f (z, x)) (d_IN f (z, x)))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>;\n        x \\<noteq> sink \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> KIR (flow_of_current \\<Delta> f) x", "have \"\\<dots> = d_IN ?f x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ z. max (d_OUT f (z, x)) (d_IN f (z, x))) =\n    d_IN (flow_of_current \\<Delta> f) x", "by(simp add: flow_of_current_def d_IN_def)"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ z. max (d_OUT f (z, x)) (d_IN f (z, x))) =\n  d_IN (flow_of_current \\<Delta> f) x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>;\n        x \\<noteq> sink \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> KIR (flow_of_current \\<Delta> f) x", "finally"], ["proof (chain)\npicking this:\n  KIR (flow_of_current \\<Delta> f) x", "show \"KIR ?f x\""], ["proof (prove)\nusing this:\n  KIR (flow_of_current \\<Delta> f) x\n\ngoal (1 subgoal):\n 1. KIR (flow_of_current \\<Delta> f) x", "."], ["proof (state)\nthis:\n  KIR (flow_of_current \\<Delta> f) x\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  The reduction of Conjecture 1.2 to Conjecture 3.6 is flawed in @{cite \"AharoniBergerGeorgakopoulusPerlsteinSpruessel2011JCT\"}.\n  Not every essential A-B separating set of vertices in @{term \"web_of_network \\<Delta>\"} is an s-t-cut in\n  @{term \\<Delta>}, as the following counterexample shows.\n\n  The network @{term \\<Delta>} has five nodes @{term \"s\"}, @{term \"t\"}, @{term \"x\"}, @{term \"y\"} and @{term \"z\"}\n  and edges @{term \"(s, x)\"}, @{term \"(x, y)\"}, @{term \"(y, z)\"}, @{term \"(y, t)\"} and @{term \"(z, t)\"}.\n  For @{term \"web_of_network \\<Delta>\"}, the set @{term \"S = {(x, y), (y, z)}\"} is essential and A-B separating.\n  (@{term \"(x, y)\"} is essential due to the path @{term \"[(y, z)]\"} and @{term \"(y, z)\"} is essential\n  due to the path @{term \"[(z, t)]\"}). However, @{term S} is not a cut in @{term \\<Delta>} because the node @{term y}\n  has an outgoing edge that is in @{term S} and one that is not in @{term S}.\n\n  However, this can be remedied if all edges carry positive capacity. Then, orthogonality of the current\n  rules out the above possibility.\n\\<close>"], ["", "lemma cut_RF_separating:\n  fixes \\<Delta> (structure)\n  assumes sep: \"separating_network \\<Delta> V\"\n  and sink: \"sink \\<Delta> \\<notin> V\"\n  shows \"cut \\<Delta> (RF\\<^sup>N V)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cut \\<Delta> (RF\\<^sup>N V)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. source \\<Delta> \\<in> RF\\<^sup>N V\n 2. sink \\<Delta> \\<notin> RF\\<^sup>N V", "show \"source \\<Delta> \\<in> RF\\<^sup>N V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. source \\<Delta> \\<in> RF\\<^sup>N V", "by(rule roofedI)(auto dest: separatingD[OF sep])"], ["proof (state)\nthis:\n  source \\<Delta> \\<in> RF\\<^sup>N V\n\ngoal (1 subgoal):\n 1. sink \\<Delta> \\<notin> RF\\<^sup>N V", "show \"sink \\<Delta> \\<notin> RF\\<^sup>N V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sink \\<Delta> \\<notin> RF\\<^sup>N V", "using sink"], ["proof (prove)\nusing this:\n  sink \\<Delta> \\<notin> V\n\ngoal (1 subgoal):\n 1. sink \\<Delta> \\<notin> RF\\<^sup>N V", "by(auto dest: roofedD[OF _ rtrancl_path.base])"], ["proof (state)\nthis:\n  sink \\<Delta> \\<notin> RF\\<^sup>N V\n\ngoal:\nNo subgoals!", "qed"], ["", "context\n  fixes \\<Delta> :: \"('v, 'more) network_scheme\" and \\<Gamma> (structure)\n  defines \\<Gamma>_def: \"\\<Gamma> \\<equiv> web_of_network \\<Delta>\"\nbegin"], ["", "lemma separating_network_cut_of_sep:\n  assumes sep: \"separating \\<Gamma> S\"\n  and source_sink: \"source \\<Delta> \\<noteq> sink \\<Delta>\"\n  shows \"separating_network \\<Delta> (fst ` \\<E> S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. separating_network \\<Delta> (fst ` \\<E> S)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p.\n       path \\<Delta> (source \\<Delta>) p (sink \\<Delta>) \\<Longrightarrow>\n       (\\<exists>z\\<in>set p. z \\<in> fst ` \\<E> S) \\<or>\n       source \\<Delta> \\<in> fst ` \\<E> S", "define s t where \"s = source \\<Delta>\" and \"t = sink \\<Delta>\""], ["proof (state)\nthis:\n  s = source \\<Delta>\n  t = sink \\<Delta>\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       path \\<Delta> (source \\<Delta>) p (sink \\<Delta>) \\<Longrightarrow>\n       (\\<exists>z\\<in>set p. z \\<in> fst ` \\<E> S) \\<or>\n       source \\<Delta> \\<in> fst ` \\<E> S", "fix p"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p.\n       path \\<Delta> (source \\<Delta>) p (sink \\<Delta>) \\<Longrightarrow>\n       (\\<exists>z\\<in>set p. z \\<in> fst ` \\<E> S) \\<or>\n       source \\<Delta> \\<in> fst ` \\<E> S", "assume p: \"path \\<Delta> s p t\""], ["proof (state)\nthis:\n  path \\<Delta> s p t\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       path \\<Delta> (source \\<Delta>) p (sink \\<Delta>) \\<Longrightarrow>\n       (\\<exists>z\\<in>set p. z \\<in> fst ` \\<E> S) \\<or>\n       source \\<Delta> \\<in> fst ` \\<E> S", "with p source_sink"], ["proof (chain)\npicking this:\n  path \\<Delta> s p t\n  source \\<Delta> \\<noteq> sink \\<Delta>\n  path \\<Delta> s p t", "have \"p \\<noteq> []\""], ["proof (prove)\nusing this:\n  path \\<Delta> s p t\n  source \\<Delta> \\<noteq> sink \\<Delta>\n  path \\<Delta> s p t\n\ngoal (1 subgoal):\n 1. p \\<noteq> []", "by cases(auto simp add: s_def t_def)"], ["proof (state)\nthis:\n  p \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       path \\<Delta> (source \\<Delta>) p (sink \\<Delta>) \\<Longrightarrow>\n       (\\<exists>z\\<in>set p. z \\<in> fst ` \\<E> S) \\<or>\n       source \\<Delta> \\<in> fst ` \\<E> S", "with p"], ["proof (chain)\npicking this:\n  path \\<Delta> s p t\n  p \\<noteq> []", "have p': \"path \\<Gamma> (s, hd p) (zip p (tl p)) (last (s # butlast p), t)\""], ["proof (prove)\nusing this:\n  path \\<Delta> s p t\n  p \\<noteq> []\n\ngoal (1 subgoal):\n 1. path \\<Gamma> (s, hd p) (zip p (tl p)) (last (s # butlast p), t)", "proof(induction)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       [] \\<noteq> [] \\<Longrightarrow>\n       path \\<Gamma> (x, hd []) (zip [] (tl [])) (last (x # butlast []), x)\n 2. \\<And>x y ys z.\n       \\<lbrakk>edge \\<Delta> x y; path \\<Delta> y ys z;\n        ys \\<noteq> [] \\<Longrightarrow>\n        path \\<Gamma> (y, hd ys) (zip ys (tl ys))\n         (last (y # butlast ys), z);\n        y # ys \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> path \\<Gamma> (x, hd (y # ys))\n                          (zip (y # ys) (tl (y # ys)))\n                          (last (x # butlast (y # ys)), z)", "case (step x y p z)"], ["proof (state)\nthis:\n  edge \\<Delta> x y\n  path \\<Delta> y p z\n  p \\<noteq> [] \\<Longrightarrow>\n  path \\<Gamma> (y, hd p) (zip p (tl p)) (last (y # butlast p), z)\n  y # p \\<noteq> []\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       [] \\<noteq> [] \\<Longrightarrow>\n       path \\<Gamma> (x, hd []) (zip [] (tl [])) (last (x # butlast []), x)\n 2. \\<And>x y ys z.\n       \\<lbrakk>edge \\<Delta> x y; path \\<Delta> y ys z;\n        ys \\<noteq> [] \\<Longrightarrow>\n        path \\<Gamma> (y, hd ys) (zip ys (tl ys))\n         (last (y # butlast ys), z);\n        y # ys \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> path \\<Gamma> (x, hd (y # ys))\n                          (zip (y # ys) (tl (y # ys)))\n                          (last (x # butlast (y # ys)), z)", "then"], ["proof (chain)\npicking this:\n  edge \\<Delta> x y\n  path \\<Delta> y p z\n  p \\<noteq> [] \\<Longrightarrow>\n  path \\<Gamma> (y, hd p) (zip p (tl p)) (last (y # butlast p), z)\n  y # p \\<noteq> []", "show ?case"], ["proof (prove)\nusing this:\n  edge \\<Delta> x y\n  path \\<Delta> y p z\n  p \\<noteq> [] \\<Longrightarrow>\n  path \\<Gamma> (y, hd p) (zip p (tl p)) (last (y # butlast p), z)\n  y # p \\<noteq> []\n\ngoal (1 subgoal):\n 1. path \\<Gamma> (x, hd (y # p)) (zip (y # p) (tl (y # p)))\n     (last (x # butlast (y # p)), z)", "by(cases p)(auto elim: rtrancl_path.cases intro: rtrancl_path.intros simp add: \\<Gamma>_def)"], ["proof (state)\nthis:\n  path \\<Gamma> (x, hd (y # p)) (zip (y # p) (tl (y # p)))\n   (last (x # butlast (y # p)), z)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       [] \\<noteq> [] \\<Longrightarrow>\n       path \\<Gamma> (x, hd []) (zip [] (tl [])) (last (x # butlast []), x)", "qed simp"], ["proof (state)\nthis:\n  path \\<Gamma> (s, hd p) (zip p (tl p)) (last (s # butlast p), t)\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       path \\<Delta> (source \\<Delta>) p (sink \\<Delta>) \\<Longrightarrow>\n       (\\<exists>z\\<in>set p. z \\<in> fst ` \\<E> S) \\<or>\n       source \\<Delta> \\<in> fst ` \\<E> S", "from sep"], ["proof (chain)\npicking this:\n  separating \\<Gamma> S", "have \"separating \\<Gamma> (\\<E> S)\""], ["proof (prove)\nusing this:\n  separating \\<Gamma> S\n\ngoal (1 subgoal):\n 1. separating \\<Gamma> (\\<E> S)", "by(rule separating_essential)"], ["proof (state)\nthis:\n  separating \\<Gamma> (\\<E> S)\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       path \\<Delta> (source \\<Delta>) p (sink \\<Delta>) \\<Longrightarrow>\n       (\\<exists>z\\<in>set p. z \\<in> fst ` \\<E> S) \\<or>\n       source \\<Delta> \\<in> fst ` \\<E> S", "from this p'"], ["proof (chain)\npicking this:\n  separating \\<Gamma> (\\<E> S)\n  path \\<Gamma> (s, hd p) (zip p (tl p)) (last (s # butlast p), t)", "have \"(\\<exists>z\\<in>set (zip p (tl p)). z \\<in> \\<E> S) \\<or> (s, hd p) \\<in> \\<E> S\""], ["proof (prove)\nusing this:\n  separating \\<Gamma> (\\<E> S)\n  path \\<Gamma> (s, hd p) (zip p (tl p)) (last (s # butlast p), t)\n\ngoal (1 subgoal):\n 1. (\\<exists>z\\<in>set (zip p (tl p)). z \\<in> \\<E> S) \\<or>\n    (s, hd p) \\<in> \\<E> S", "apply(rule separatingD)"], ["proof (prove)\ngoal (2 subgoals):\n 1. (s, hd p) \\<in> A \\<Gamma>\n 2. (last (s # butlast p), t) \\<in> B \\<Gamma>", "using rtrancl_path_nth[OF p, of 0] rtrancl_path_nth[OF p, of \"length p - 1\"] \\<open>p \\<noteq> []\\<close> rtrancl_path_last[OF p]"], ["proof (prove)\nusing this:\n  0 < length p \\<Longrightarrow> edge \\<Delta> ((s # p) ! 0) (p ! 0)\n  length p - 1 < length p \\<Longrightarrow>\n  edge \\<Delta> ((s # p) ! (length p - 1)) (p ! (length p - 1))\n  p \\<noteq> []\n  p \\<noteq> [] \\<Longrightarrow> last p = t\n\ngoal (2 subgoals):\n 1. (s, hd p) \\<in> A \\<Gamma>\n 2. (last (s # butlast p), t) \\<in> B \\<Gamma>", "apply(auto simp add: \\<Gamma>_def s_def t_def hd_conv_nth last_conv_nth nth_butlast nth_Cons' cong: if_cong split: if_split_asm)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>p \\<noteq> []; p ! 0 = sink \\<Delta>; length p \\<le> Suc 0;\n     edge \\<Delta> (source \\<Delta>) (sink \\<Delta>);\n     butlast p \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> edge \\<Delta> (butlast p ! 0) (sink \\<Delta>)\n 2. \\<lbrakk>p \\<noteq> []; p ! (length p - Suc 0) = sink \\<Delta>;\n     edge \\<Delta> (source \\<Delta>) (p ! 0); \\<not> length p \\<le> Suc 0;\n     edge \\<Delta> (p ! (length p - Suc (Suc 0))) (sink \\<Delta>);\n     butlast p = []\\<rbrakk>\n    \\<Longrightarrow> edge \\<Delta> (source \\<Delta>) (sink \\<Delta>)", "apply(metis One_nat_def Suc_leI cancel_comm_monoid_add_class.diff_cancel le_antisym length_butlast length_greater_0_conv list.size(3))+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (\\<exists>z\\<in>set (zip p (tl p)). z \\<in> \\<E> S) \\<or>\n  (s, hd p) \\<in> \\<E> S\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       path \\<Delta> (source \\<Delta>) p (sink \\<Delta>) \\<Longrightarrow>\n       (\\<exists>z\\<in>set p. z \\<in> fst ` \\<E> S) \\<or>\n       source \\<Delta> \\<in> fst ` \\<E> S", "then"], ["proof (chain)\npicking this:\n  (\\<exists>z\\<in>set (zip p (tl p)). z \\<in> \\<E> S) \\<or>\n  (s, hd p) \\<in> \\<E> S", "show \"(\\<exists>z\\<in>set p. z \\<in> fst ` \\<E> S) \\<or> s \\<in> fst ` \\<E> S\""], ["proof (prove)\nusing this:\n  (\\<exists>z\\<in>set (zip p (tl p)). z \\<in> \\<E> S) \\<or>\n  (s, hd p) \\<in> \\<E> S\n\ngoal (1 subgoal):\n 1. (\\<exists>z\\<in>set p. z \\<in> fst ` \\<E> S) \\<or> s \\<in> fst ` \\<E> S", "by(auto dest!: set_zip_leftD intro: rev_image_eqI)"], ["proof (state)\nthis:\n  (\\<exists>z\\<in>set p. z \\<in> fst ` \\<E> S) \\<or> s \\<in> fst ` \\<E> S\n\ngoal:\nNo subgoals!", "qed"], ["", "definition cut_of_sep :: \"('v \\<times> 'v) set \\<Rightarrow> 'v set\"\nwhere \"cut_of_sep S = RF\\<^sup>N\\<^bsub>\\<Delta>\\<^esub> (fst ` \\<E> S)\""], ["", "lemma separating_cut:\n  assumes sep: \"separating \\<Gamma> S\"\n  and neq: \"source \\<Delta> \\<noteq> sink \\<Delta>\"\n  and sink_out: \"\\<And>x. \\<not> edge \\<Delta> (sink \\<Delta>) x\"\n  shows \"cut \\<Delta> (cut_of_sep S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cut \\<Delta> (local.cut_of_sep S)", "unfolding cut_of_sep_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. cut \\<Delta> (RF\\<^sup>N\\<^bsub>\\<Delta>\\<^esub> (fst ` \\<E> S))", "proof(rule cut_RF_separating)"], ["proof (state)\ngoal (2 subgoals):\n 1. separating_network \\<Delta> (fst ` \\<E> S)\n 2. sink \\<Delta> \\<notin> fst ` \\<E> S", "show \"separating_network \\<Delta> (fst ` \\<E> S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. separating_network \\<Delta> (fst ` \\<E> S)", "using sep neq"], ["proof (prove)\nusing this:\n  separating \\<Gamma> S\n  source \\<Delta> \\<noteq> sink \\<Delta>\n\ngoal (1 subgoal):\n 1. separating_network \\<Delta> (fst ` \\<E> S)", "by(rule separating_network_cut_of_sep)"], ["proof (state)\nthis:\n  separating_network \\<Delta> (fst ` \\<E> S)\n\ngoal (1 subgoal):\n 1. sink \\<Delta> \\<notin> fst ` \\<E> S", "show \"sink \\<Delta> \\<notin> fst ` \\<E> S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sink \\<Delta> \\<notin> fst ` \\<E> S", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. sink \\<Delta> \\<in> fst ` \\<E> S \\<Longrightarrow> False", "assume \"sink \\<Delta> \\<in> fst ` \\<E> S\""], ["proof (state)\nthis:\n  sink \\<Delta> \\<in> fst ` \\<E> S\n\ngoal (1 subgoal):\n 1. sink \\<Delta> \\<in> fst ` \\<E> S \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  sink \\<Delta> \\<in> fst ` \\<E> S", "obtain x where \"(sink \\<Delta>, x) \\<in> \\<E> S\""], ["proof (prove)\nusing this:\n  sink \\<Delta> \\<in> fst ` \\<E> S\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        (sink \\<Delta>, x) \\<in> \\<E> S \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  (sink \\<Delta>, x) \\<in> \\<E> S\n\ngoal (1 subgoal):\n 1. sink \\<Delta> \\<in> fst ` \\<E> S \\<Longrightarrow> False", "hence \"(sink \\<Delta>, x) \\<in> \\<^bold>V\""], ["proof (prove)\nusing this:\n  (sink \\<Delta>, x) \\<in> \\<E> S\n\ngoal (1 subgoal):\n 1. (sink \\<Delta>, x) \\<in> \\<^bold>V", "by(auto simp add: \\<Gamma>_def dest!: essential_vertex)"], ["proof (state)\nthis:\n  (sink \\<Delta>, x) \\<in> \\<^bold>V\n\ngoal (1 subgoal):\n 1. sink \\<Delta> \\<in> fst ` \\<E> S \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  (sink \\<Delta>, x) \\<in> \\<^bold>V", "show False"], ["proof (prove)\nusing this:\n  (sink \\<Delta>, x) \\<in> \\<^bold>V\n\ngoal (1 subgoal):\n 1. False", "by(simp add: \\<Gamma>_def sink_out)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sink \\<Delta> \\<notin> fst ` \\<E> S\n\ngoal:\nNo subgoals!", "qed"], ["", "context\n  fixes f :: \"'v edge current\" and S\n  assumes wf: \"web_flow \\<Gamma> f\"\n  and ortho: \"orthogonal_current \\<Gamma> f S\"\n  and sep: \"separating \\<Gamma> S\"\n  and capacity_pos: \"\\<And>e. e \\<in> \\<^bold>E\\<^bsub>\\<Delta>\\<^esub> \\<Longrightarrow> capacity \\<Delta> e > 0\"\nbegin"], ["", "private"], ["", "lemma f: \"current \\<Gamma> f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. current \\<Gamma> f", "using wf"], ["proof (prove)\nusing this:\n  web_flow \\<Gamma> f\n\ngoal (1 subgoal):\n 1. current \\<Gamma> f", "by(rule web_flowD_current)"], ["", "lemma orthogonal_leave_RF:\n  assumes e: \"edge \\<Delta> x y\"\n  and x: \"x \\<in> (cut_of_sep S)\"\n  and y: \"y \\<notin> (cut_of_sep S)\"\n  shows \"(x, y) \\<in> S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x, y) \\<in> S", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (x, y) \\<in> S", "from y"], ["proof (chain)\npicking this:\n  y \\<notin> local.cut_of_sep S", "obtain p where p: \"path \\<Delta> y p (sink \\<Delta>)\" and y': \"y \\<notin> fst ` \\<E> S\"\n    and bypass: \"\\<And>z. z \\<in> set p \\<Longrightarrow> z \\<notin> fst ` \\<E> S\""], ["proof (prove)\nusing this:\n  y \\<notin> local.cut_of_sep S\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        \\<lbrakk>path \\<Delta> y p (sink \\<Delta>); y \\<notin> fst ` \\<E> S;\n         \\<And>z.\n            z \\<in> set p \\<Longrightarrow> z \\<notin> fst ` \\<E> S\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto simp add: roofed_def cut_of_sep_def \\<Gamma>_def[symmetric])"], ["proof (state)\nthis:\n  path \\<Delta> y p (sink \\<Delta>)\n  y \\<notin> fst ` \\<E> S\n  ?z \\<in> set p \\<Longrightarrow> ?z \\<notin> fst ` \\<E> S\n\ngoal (1 subgoal):\n 1. (x, y) \\<in> S", "from e p"], ["proof (chain)\npicking this:\n  edge \\<Delta> x y\n  path \\<Delta> y p (sink \\<Delta>)", "have p': \"path \\<Delta> x (y # p) (sink \\<Delta>)\""], ["proof (prove)\nusing this:\n  edge \\<Delta> x y\n  path \\<Delta> y p (sink \\<Delta>)\n\ngoal (1 subgoal):\n 1. path \\<Delta> x (y # p) (sink \\<Delta>)", ".."], ["proof (state)\nthis:\n  path \\<Delta> x (y # p) (sink \\<Delta>)\n\ngoal (1 subgoal):\n 1. (x, y) \\<in> S", "from roofedD[OF x[unfolded cut_of_sep_def] this] y' bypass"], ["proof (chain)\npicking this:\n  sink \\<Delta> \\<in> {sink \\<Delta>} \\<Longrightarrow>\n  (\\<exists>z\\<in>set (y # p). z \\<in> fst ` \\<E> S) \\<or>\n  x \\<in> fst ` \\<E> S\n  y \\<notin> fst ` \\<E> S\n  ?z \\<in> set p \\<Longrightarrow> ?z \\<notin> fst ` \\<E> S", "have \"x \\<in> fst ` \\<E> S\""], ["proof (prove)\nusing this:\n  sink \\<Delta> \\<in> {sink \\<Delta>} \\<Longrightarrow>\n  (\\<exists>z\\<in>set (y # p). z \\<in> fst ` \\<E> S) \\<or>\n  x \\<in> fst ` \\<E> S\n  y \\<notin> fst ` \\<E> S\n  ?z \\<in> set p \\<Longrightarrow> ?z \\<notin> fst ` \\<E> S\n\ngoal (1 subgoal):\n 1. x \\<in> fst ` \\<E> S", "by(auto simp add: \\<Gamma>_def[symmetric])"], ["proof (state)\nthis:\n  x \\<in> fst ` \\<E> S\n\ngoal (1 subgoal):\n 1. (x, y) \\<in> S", "then"], ["proof (chain)\npicking this:\n  x \\<in> fst ` \\<E> S", "obtain z where xz: \"(x, z) \\<in> \\<E> S\""], ["proof (prove)\nusing this:\n  x \\<in> fst ` \\<E> S\n\ngoal (1 subgoal):\n 1. (\\<And>z.\n        (x, z) \\<in> \\<E> S \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  (x, z) \\<in> \\<E> S\n\ngoal (1 subgoal):\n 1. (x, y) \\<in> S", "then"], ["proof (chain)\npicking this:\n  (x, z) \\<in> \\<E> S", "obtain q b where q: \"path \\<Gamma> (x, z) q b\" and b: \"b \\<in> B \\<Gamma>\"\n    and distinct: \"distinct ((x, z) # q)\" and bypass': \"\\<And>z. z \\<in> set q \\<Longrightarrow> z \\<notin> RF S\""], ["proof (prove)\nusing this:\n  (x, z) \\<in> \\<E> S\n\ngoal (1 subgoal):\n 1. (\\<And>q b.\n        \\<lbrakk>path \\<Gamma> (x, z) q b; b \\<in> B \\<Gamma>;\n         distinct ((x, z) # q);\n         \\<And>z. z \\<in> set q \\<Longrightarrow> z \\<notin> RF S\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(rule \\<E>_E_RF) blast"], ["proof (state)\nthis:\n  path \\<Gamma> (x, z) q b\n  b \\<in> B \\<Gamma>\n  distinct ((x, z) # q)\n  ?z \\<in> set q \\<Longrightarrow> ?z \\<notin> RF S\n\ngoal (1 subgoal):\n 1. (x, y) \\<in> S", "define p' where \"p' = y # p\""], ["proof (state)\nthis:\n  p' = y # p\n\ngoal (1 subgoal):\n 1. (x, y) \\<in> S", "hence \"p' \\<noteq> []\""], ["proof (prove)\nusing this:\n  p' = y # p\n\ngoal (1 subgoal):\n 1. p' \\<noteq> []", "by simp"], ["proof (state)\nthis:\n  p' \\<noteq> []\n\ngoal (1 subgoal):\n 1. (x, y) \\<in> S", "with p'"], ["proof (chain)\npicking this:\n  path \\<Delta> x (y # p) (sink \\<Delta>)\n  p' \\<noteq> []", "have \"path \\<Gamma> (x, hd p') (zip p' (tl p')) (last (x # butlast p'), sink \\<Delta>)\""], ["proof (prove)\nusing this:\n  path \\<Delta> x (y # p) (sink \\<Delta>)\n  p' \\<noteq> []\n\ngoal (1 subgoal):\n 1. path \\<Gamma> (x, hd p') (zip p' (tl p'))\n     (last (x # butlast p'), sink \\<Delta>)", "unfolding p'_def[symmetric]"], ["proof (prove)\nusing this:\n  path \\<Delta> x p' (sink \\<Delta>)\n  p' \\<noteq> []\n\ngoal (1 subgoal):\n 1. path \\<Gamma> (x, hd p') (zip p' (tl p'))\n     (last (x # butlast p'), sink \\<Delta>)", "proof(induction)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       [] \\<noteq> [] \\<Longrightarrow>\n       path \\<Gamma> (x, hd []) (zip [] (tl [])) (last (x # butlast []), x)\n 2. \\<And>x y ys z.\n       \\<lbrakk>edge \\<Delta> x y; path \\<Delta> y ys z;\n        ys \\<noteq> [] \\<Longrightarrow>\n        path \\<Gamma> (y, hd ys) (zip ys (tl ys))\n         (last (y # butlast ys), z);\n        y # ys \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> path \\<Gamma> (x, hd (y # ys))\n                          (zip (y # ys) (tl (y # ys)))\n                          (last (x # butlast (y # ys)), z)", "case (step x y p z)"], ["proof (state)\nthis:\n  edge \\<Delta> x y\n  path \\<Delta> y p z\n  p \\<noteq> [] \\<Longrightarrow>\n  path \\<Gamma> (y, hd p) (zip p (tl p)) (last (y # butlast p), z)\n  y # p \\<noteq> []\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       [] \\<noteq> [] \\<Longrightarrow>\n       path \\<Gamma> (x, hd []) (zip [] (tl [])) (last (x # butlast []), x)\n 2. \\<And>x y ys z.\n       \\<lbrakk>edge \\<Delta> x y; path \\<Delta> y ys z;\n        ys \\<noteq> [] \\<Longrightarrow>\n        path \\<Gamma> (y, hd ys) (zip ys (tl ys))\n         (last (y # butlast ys), z);\n        y # ys \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> path \\<Gamma> (x, hd (y # ys))\n                          (zip (y # ys) (tl (y # ys)))\n                          (last (x # butlast (y # ys)), z)", "then"], ["proof (chain)\npicking this:\n  edge \\<Delta> x y\n  path \\<Delta> y p z\n  p \\<noteq> [] \\<Longrightarrow>\n  path \\<Gamma> (y, hd p) (zip p (tl p)) (last (y # butlast p), z)\n  y # p \\<noteq> []", "show ?case"], ["proof (prove)\nusing this:\n  edge \\<Delta> x y\n  path \\<Delta> y p z\n  p \\<noteq> [] \\<Longrightarrow>\n  path \\<Gamma> (y, hd p) (zip p (tl p)) (last (y # butlast p), z)\n  y # p \\<noteq> []\n\ngoal (1 subgoal):\n 1. path \\<Gamma> (x, hd (y # p)) (zip (y # p) (tl (y # p)))\n     (last (x # butlast (y # p)), z)", "by(cases p)(auto elim: rtrancl_path.cases intro: rtrancl_path.intros simp add: \\<Gamma>_def)"], ["proof (state)\nthis:\n  path \\<Gamma> (x, hd (y # p)) (zip (y # p) (tl (y # p)))\n   (last (x # butlast (y # p)), z)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       [] \\<noteq> [] \\<Longrightarrow>\n       path \\<Gamma> (x, hd []) (zip [] (tl [])) (last (x # butlast []), x)", "qed simp"], ["proof (state)\nthis:\n  path \\<Gamma> (x, hd p') (zip p' (tl p'))\n   (last (x # butlast p'), sink \\<Delta>)\n\ngoal (1 subgoal):\n 1. (x, y) \\<in> S", "then"], ["proof (chain)\npicking this:\n  path \\<Gamma> (x, hd p') (zip p' (tl p'))\n   (last (x # butlast p'), sink \\<Delta>)", "have p'': \"path \\<Gamma> (x, y) (zip (y # p) p) (last (x # butlast (y # p)), sink \\<Delta>)\" (is \"path _ ?y ?p ?t\")"], ["proof (prove)\nusing this:\n  path \\<Gamma> (x, hd p') (zip p' (tl p'))\n   (last (x # butlast p'), sink \\<Delta>)\n\ngoal (1 subgoal):\n 1. path \\<Gamma> (x, y) (zip (y # p) p)\n     (last (x # butlast (y # p)), sink \\<Delta>)", "by(simp add: p'_def)"], ["proof (state)\nthis:\n  path \\<Gamma> (x, y) (zip (y # p) p)\n   (last (x # butlast (y # p)), sink \\<Delta>)\n\ngoal (1 subgoal):\n 1. (x, y) \\<in> S", "have \"(?y # ?p) ! length p = ?t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((x, y) # zip (y # p) p) ! length p =\n    (last (x # butlast (y # p)), sink \\<Delta>)", "using rtrancl_path_last[OF p'] p rtrancl_path_last[OF p]"], ["proof (prove)\nusing this:\n  y # p \\<noteq> [] \\<Longrightarrow> last (y # p) = sink \\<Delta>\n  path \\<Delta> y p (sink \\<Delta>)\n  p \\<noteq> [] \\<Longrightarrow> last p = sink \\<Delta>\n\ngoal (1 subgoal):\n 1. ((x, y) # zip (y # p) p) ! length p =\n    (last (x # butlast (y # p)), sink \\<Delta>)", "apply(auto split: if_split_asm simp add: nth_Cons butlast_conv_take take_Suc_conv_app_nth split: nat.split elim: rtrancl_path.cases)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x2a.\n       \\<lbrakk>path \\<Delta> y p (sink \\<Delta>); p \\<noteq> [];\n        last p = sink \\<Delta>; length p = Suc (Suc x2a)\\<rbrakk>\n       \\<Longrightarrow> p ! Suc x2a = sink \\<Delta>", "apply(simp add: last_conv_nth)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  ((x, y) # zip (y # p) p) ! length p =\n  (last (x # butlast (y # p)), sink \\<Delta>)\n\ngoal (1 subgoal):\n 1. (x, y) \\<in> S", "moreover"], ["proof (state)\nthis:\n  ((x, y) # zip (y # p) p) ! length p =\n  (last (x # butlast (y # p)), sink \\<Delta>)\n\ngoal (1 subgoal):\n 1. (x, y) \\<in> S", "have \"length p < length (?y # ?p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length p < length ((x, y) # zip (y # p) p)", "by simp"], ["proof (state)\nthis:\n  length p < length ((x, y) # zip (y # p) p)\n\ngoal (1 subgoal):\n 1. (x, y) \\<in> S", "ultimately"], ["proof (chain)\npicking this:\n  ((x, y) # zip (y # p) p) ! length p =\n  (last (x # butlast (y # p)), sink \\<Delta>)\n  length p < length ((x, y) # zip (y # p) p)", "have t: \"?t \\<in> B \\<Gamma>\""], ["proof (prove)\nusing this:\n  ((x, y) # zip (y # p) p) ! length p =\n  (last (x # butlast (y # p)), sink \\<Delta>)\n  length p < length ((x, y) # zip (y # p) p)\n\ngoal (1 subgoal):\n 1. (last (x # butlast (y # p)), sink \\<Delta>) \\<in> B \\<Gamma>", "using rtrancl_path_nth[OF p'', of \"length p - 1\"] e"], ["proof (prove)\nusing this:\n  ((x, y) # zip (y # p) p) ! length p =\n  (last (x # butlast (y # p)), sink \\<Delta>)\n  length p < length ((x, y) # zip (y # p) p)\n  length p - 1 < length (zip (y # p) p) \\<Longrightarrow>\n  edge \\<Gamma> (((x, y) # zip (y # p) p) ! (length p - 1))\n   (zip (y # p) p ! (length p - 1))\n  edge \\<Delta> x y\n\ngoal (1 subgoal):\n 1. (last (x # butlast (y # p)), sink \\<Delta>) \\<in> B \\<Gamma>", "by(cases p)(simp_all add: \\<Gamma>_def split: if_split_asm)"], ["proof (state)\nthis:\n  (last (x # butlast (y # p)), sink \\<Delta>) \\<in> B \\<Gamma>\n\ngoal (1 subgoal):\n 1. (x, y) \\<in> S", "show S: \"(x, y) \\<in> S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x, y) \\<in> S", "proof(cases \"x = source \\<Delta>\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x = source \\<Delta> \\<Longrightarrow> (x, y) \\<in> S\n 2. x \\<noteq> source \\<Delta> \\<Longrightarrow> (x, y) \\<in> S", "case True"], ["proof (state)\nthis:\n  x = source \\<Delta>\n\ngoal (2 subgoals):\n 1. x = source \\<Delta> \\<Longrightarrow> (x, y) \\<in> S\n 2. x \\<noteq> source \\<Delta> \\<Longrightarrow> (x, y) \\<in> S", "from separatingD[OF separating_essential, OF sep p'' _ t] e True"], ["proof (chain)\npicking this:\n  (x, y) \\<in> A \\<Gamma> \\<Longrightarrow>\n  (\\<exists>z\\<in>set (zip (y # p) p). z \\<in> \\<E> S) \\<or>\n  (x, y) \\<in> \\<E> S\n  edge \\<Delta> x y\n  x = source \\<Delta>", "consider (z) z z' where \"(z, z') \\<in> set ?p\" \"(z, z') \\<in> \\<E> S\" | \"(x, y) \\<in> S\""], ["proof (prove)\nusing this:\n  (x, y) \\<in> A \\<Gamma> \\<Longrightarrow>\n  (\\<exists>z\\<in>set (zip (y # p) p). z \\<in> \\<E> S) \\<or>\n  (x, y) \\<in> \\<E> S\n  edge \\<Delta> x y\n  x = source \\<Delta>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>z z'.\n                \\<lbrakk>(z, z') \\<in> set (zip (y # p) p);\n                 (z, z') \\<in> \\<E> S\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     (x, y) \\<in> S \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by(auto simp add: \\<Gamma>_def)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<And>z z'.\n              \\<lbrakk>(z, z') \\<in> set (zip (y # p) p);\n               (z, z') \\<in> \\<E> S\\<rbrakk>\n              \\<Longrightarrow> ?thesis;\n   (x, y) \\<in> S \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (2 subgoals):\n 1. x = source \\<Delta> \\<Longrightarrow> (x, y) \\<in> S\n 2. x \\<noteq> source \\<Delta> \\<Longrightarrow> (x, y) \\<in> S", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>z z'.\n              \\<lbrakk>(z, z') \\<in> set (zip (y # p) p);\n               (z, z') \\<in> \\<E> S\\<rbrakk>\n              \\<Longrightarrow> ?thesis;\n   (x, y) \\<in> S \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (x, y) \\<in> S", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>z z'.\n       \\<lbrakk>(z, z') \\<in> set (zip (y # p) p);\n        (z, z') \\<in> \\<E> S\\<rbrakk>\n       \\<Longrightarrow> (x, y) \\<in> S\n 2. (x, y) \\<in> S \\<Longrightarrow> (x, y) \\<in> S", "case (z z)"], ["proof (state)\nthis:\n  (z, z') \\<in> set (zip (y # p) p)\n  (z, z') \\<in> \\<E> S\n\ngoal (2 subgoals):\n 1. \\<And>z z'.\n       \\<lbrakk>(z, z') \\<in> set (zip (y # p) p);\n        (z, z') \\<in> \\<E> S\\<rbrakk>\n       \\<Longrightarrow> (x, y) \\<in> S\n 2. (x, y) \\<in> S \\<Longrightarrow> (x, y) \\<in> S", "hence \"z \\<in> set p\" \"z \\<in> fst ` \\<E> S\""], ["proof (prove)\nusing this:\n  (z, z') \\<in> set (zip (y # p) p)\n  (z, z') \\<in> \\<E> S\n\ngoal (1 subgoal):\n 1. z \\<in> set p &&& z \\<in> fst ` \\<E> S", "using y'"], ["proof (prove)\nusing this:\n  (z, z') \\<in> set (zip (y # p) p)\n  (z, z') \\<in> \\<E> S\n  y \\<notin> fst ` \\<E> S\n\ngoal (1 subgoal):\n 1. z \\<in> set p &&& z \\<in> fst ` \\<E> S", "by(auto dest!: set_zip_leftD intro: rev_image_eqI)"], ["proof (state)\nthis:\n  z \\<in> set p\n  z \\<in> fst ` \\<E> S\n\ngoal (2 subgoals):\n 1. \\<And>z z'.\n       \\<lbrakk>(z, z') \\<in> set (zip (y # p) p);\n        (z, z') \\<in> \\<E> S\\<rbrakk>\n       \\<Longrightarrow> (x, y) \\<in> S\n 2. (x, y) \\<in> S \\<Longrightarrow> (x, y) \\<in> S", "hence False"], ["proof (prove)\nusing this:\n  z \\<in> set p\n  z \\<in> fst ` \\<E> S\n\ngoal (1 subgoal):\n 1. False", "by(auto dest: bypass)"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. \\<And>z z'.\n       \\<lbrakk>(z, z') \\<in> set (zip (y # p) p);\n        (z, z') \\<in> \\<E> S\\<rbrakk>\n       \\<Longrightarrow> (x, y) \\<in> S\n 2. (x, y) \\<in> S \\<Longrightarrow> (x, y) \\<in> S", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. (x, y) \\<in> S", ".."], ["proof (state)\nthis:\n  (x, y) \\<in> S\n\ngoal (1 subgoal):\n 1. (x, y) \\<in> S \\<Longrightarrow> (x, y) \\<in> S", "qed"], ["proof (state)\nthis:\n  (x, y) \\<in> S\n\ngoal (1 subgoal):\n 1. x \\<noteq> source \\<Delta> \\<Longrightarrow> (x, y) \\<in> S", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<noteq> source \\<Delta> \\<Longrightarrow> (x, y) \\<in> S", "case False"], ["proof (state)\nthis:\n  x \\<noteq> source \\<Delta>\n\ngoal (1 subgoal):\n 1. x \\<noteq> source \\<Delta> \\<Longrightarrow> (x, y) \\<in> S", "have \"\\<exists>e. edge \\<Gamma> e (x, z) \\<and> f (e, (x, z)) > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>e. edge \\<Gamma> e (x, z) \\<and> 0 < f (e, x, z)", "proof(rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<nexists>e.\n       edge \\<Gamma> e (x, z) \\<and> 0 < f (e, x, z) \\<Longrightarrow>\n    False", "assume \"\\<not> ?thesis\""], ["proof (state)\nthis:\n  \\<nexists>e. edge \\<Gamma> e (x, z) \\<and> 0 < f (e, x, z)\n\ngoal (1 subgoal):\n 1. \\<nexists>e.\n       edge \\<Gamma> e (x, z) \\<and> 0 < f (e, x, z) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<nexists>e. edge \\<Gamma> e (x, z) \\<and> 0 < f (e, x, z)", "have \"d_IN f (x, z) = 0\""], ["proof (prove)\nusing this:\n  \\<nexists>e. edge \\<Gamma> e (x, z) \\<and> 0 < f (e, x, z)\n\ngoal (1 subgoal):\n 1. d_IN f (x, z) = 0", "unfolding d_IN_def"], ["proof (prove)\nusing this:\n  \\<nexists>e. edge \\<Gamma> e (x, z) \\<and> 0 < f (e, x, z)\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ xa. f (xa, x, z)) = 0", "using currentD_outside[OF f, of _ \"(x, z)\"]"], ["proof (prove)\nusing this:\n  \\<nexists>e. edge \\<Gamma> e (x, z) \\<and> 0 < f (e, x, z)\n  \\<not> edge \\<Gamma> ?x (x, z) \\<Longrightarrow> f (?x, x, z) = 0\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ xa. f (xa, x, z)) = 0", "by(force simp add: nn_integral_0_iff_AE AE_count_space not_less)"], ["proof (state)\nthis:\n  d_IN f (x, z) = 0\n\ngoal (1 subgoal):\n 1. \\<nexists>e.\n       edge \\<Gamma> e (x, z) \\<and> 0 < f (e, x, z) \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  d_IN f (x, z) = 0\n\ngoal (1 subgoal):\n 1. \\<nexists>e.\n       edge \\<Gamma> e (x, z) \\<and> 0 < f (e, x, z) \\<Longrightarrow>\n    False", "from xz"], ["proof (chain)\npicking this:\n  (x, z) \\<in> \\<E> S", "have \"(x, z) \\<in> S\""], ["proof (prove)\nusing this:\n  (x, z) \\<in> \\<E> S\n\ngoal (1 subgoal):\n 1. (x, z) \\<in> S", "by auto"], ["proof (state)\nthis:\n  (x, z) \\<in> S\n\ngoal (1 subgoal):\n 1. \\<nexists>e.\n       edge \\<Gamma> e (x, z) \\<and> 0 < f (e, x, z) \\<Longrightarrow>\n    False", "hence \"(x, z) \\<in> SAT \\<Gamma> f\""], ["proof (prove)\nusing this:\n  (x, z) \\<in> S\n\ngoal (1 subgoal):\n 1. (x, z) \\<in> SAT \\<Gamma> f", "by(rule orthogonal_currentD_SAT[OF ortho])"], ["proof (state)\nthis:\n  (x, z) \\<in> SAT \\<Gamma> f\n\ngoal (1 subgoal):\n 1. \\<nexists>e.\n       edge \\<Gamma> e (x, z) \\<and> 0 < f (e, x, z) \\<Longrightarrow>\n    False", "with False"], ["proof (chain)\npicking this:\n  x \\<noteq> source \\<Delta>\n  (x, z) \\<in> SAT \\<Gamma> f", "have \"d_IN f (x, z) \\<ge> capacity \\<Delta> (x, z)\""], ["proof (prove)\nusing this:\n  x \\<noteq> source \\<Delta>\n  (x, z) \\<in> SAT \\<Gamma> f\n\ngoal (1 subgoal):\n 1. capacity \\<Delta> (x, z) \\<le> d_IN f (x, z)", "by(auto simp add: SAT.simps \\<Gamma>_def)"], ["proof (state)\nthis:\n  capacity \\<Delta> (x, z) \\<le> d_IN f (x, z)\n\ngoal (1 subgoal):\n 1. \\<nexists>e.\n       edge \\<Gamma> e (x, z) \\<and> 0 < f (e, x, z) \\<Longrightarrow>\n    False", "ultimately"], ["proof (chain)\npicking this:\n  d_IN f (x, z) = 0\n  capacity \\<Delta> (x, z) \\<le> d_IN f (x, z)", "have \"\\<not> capacity \\<Delta> (x, z) > 0\""], ["proof (prove)\nusing this:\n  d_IN f (x, z) = 0\n  capacity \\<Delta> (x, z) \\<le> d_IN f (x, z)\n\ngoal (1 subgoal):\n 1. \\<not> 0 < capacity \\<Delta> (x, z)", "by auto"], ["proof (state)\nthis:\n  \\<not> 0 < capacity \\<Delta> (x, z)\n\ngoal (1 subgoal):\n 1. \\<nexists>e.\n       edge \\<Gamma> e (x, z) \\<and> 0 < f (e, x, z) \\<Longrightarrow>\n    False", "hence \"\\<not> edge \\<Delta> x z\""], ["proof (prove)\nusing this:\n  \\<not> 0 < capacity \\<Delta> (x, z)\n\ngoal (1 subgoal):\n 1. \\<not> edge \\<Delta> x z", "using capacity_pos[of \"(x, z)\"]"], ["proof (prove)\nusing this:\n  \\<not> 0 < capacity \\<Delta> (x, z)\n  (x, z) \\<in> \\<^bold>E\\<^bsub>\\<Delta>\\<^esub> \\<Longrightarrow>\n  0 < capacity \\<Delta> (x, z)\n\ngoal (1 subgoal):\n 1. \\<not> edge \\<Delta> x z", "by auto"], ["proof (state)\nthis:\n  \\<not> edge \\<Delta> x z\n\ngoal (1 subgoal):\n 1. \\<nexists>e.\n       edge \\<Gamma> e (x, z) \\<and> 0 < f (e, x, z) \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  \\<not> edge \\<Delta> x z\n\ngoal (1 subgoal):\n 1. \\<nexists>e.\n       edge \\<Gamma> e (x, z) \\<and> 0 < f (e, x, z) \\<Longrightarrow>\n    False", "with q"], ["proof (chain)\npicking this:\n  path \\<Gamma> (x, z) q b\n  \\<not> edge \\<Delta> x z", "have \"b = (x, z)\""], ["proof (prove)\nusing this:\n  path \\<Gamma> (x, z) q b\n  \\<not> edge \\<Delta> x z\n\ngoal (1 subgoal):\n 1. b = (x, z)", "by cases(auto simp add: \\<Gamma>_def)"], ["proof (state)\nthis:\n  b = (x, z)\n\ngoal (1 subgoal):\n 1. \\<nexists>e.\n       edge \\<Gamma> e (x, z) \\<and> 0 < f (e, x, z) \\<Longrightarrow>\n    False", "with b"], ["proof (chain)\npicking this:\n  b \\<in> B \\<Gamma>\n  b = (x, z)", "have \"edge \\<Delta> x z\""], ["proof (prove)\nusing this:\n  b \\<in> B \\<Gamma>\n  b = (x, z)\n\ngoal (1 subgoal):\n 1. edge \\<Delta> x z", "by(simp add: \\<Gamma>_def)"], ["proof (state)\nthis:\n  edge \\<Delta> x z\n\ngoal (1 subgoal):\n 1. \\<nexists>e.\n       edge \\<Gamma> e (x, z) \\<and> 0 < f (e, x, z) \\<Longrightarrow>\n    False", "ultimately"], ["proof (chain)\npicking this:\n  \\<not> edge \\<Delta> x z\n  edge \\<Delta> x z", "show False"], ["proof (prove)\nusing this:\n  \\<not> edge \\<Delta> x z\n  edge \\<Delta> x z\n\ngoal (1 subgoal):\n 1. False", "by contradiction"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>e. edge \\<Gamma> e (x, z) \\<and> 0 < f (e, x, z)\n\ngoal (1 subgoal):\n 1. x \\<noteq> source \\<Delta> \\<Longrightarrow> (x, y) \\<in> S", "then"], ["proof (chain)\npicking this:\n  \\<exists>e. edge \\<Gamma> e (x, z) \\<and> 0 < f (e, x, z)", "obtain u where ux: \"edge \\<Delta> u x\" and xz': \"edge \\<Delta> x z\" and uxz: \"edge \\<Gamma> (u, x) (x, z)\"\n      and gt0: \"f ((u, x), (x, z)) > 0\""], ["proof (prove)\nusing this:\n  \\<exists>e. edge \\<Gamma> e (x, z) \\<and> 0 < f (e, x, z)\n\ngoal (1 subgoal):\n 1. (\\<And>u.\n        \\<lbrakk>edge \\<Delta> u x; edge \\<Delta> x z;\n         edge \\<Gamma> (u, x) (x, z); 0 < f ((u, x), x, z)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto simp add: \\<Gamma>_def)"], ["proof (state)\nthis:\n  edge \\<Delta> u x\n  edge \\<Delta> x z\n  edge \\<Gamma> (u, x) (x, z)\n  0 < f ((u, x), x, z)\n\ngoal (1 subgoal):\n 1. x \\<noteq> source \\<Delta> \\<Longrightarrow> (x, y) \\<in> S", "have \"(u, x) \\<in> RF\\<^sup>\\<circ> S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (u, x) \\<in> RF\\<^sup>\\<circ> S", "using orthogonal_currentD_in[OF ortho, of \"(x, z)\" \"(u, x)\"] gt0 xz"], ["proof (prove)\nusing this:\n  \\<lbrakk>(x, z) \\<in> RF S; (u, x) \\<notin> RF\\<^sup>\\<circ> S\\<rbrakk>\n  \\<Longrightarrow> f ((u, x), x, z) = 0\n  0 < f ((u, x), x, z)\n  (x, z) \\<in> \\<E> S\n\ngoal (1 subgoal):\n 1. (u, x) \\<in> RF\\<^sup>\\<circ> S", "by(fastforce intro: roofed_greaterI)"], ["proof (state)\nthis:\n  (u, x) \\<in> RF\\<^sup>\\<circ> S\n\ngoal (1 subgoal):\n 1. x \\<noteq> source \\<Delta> \\<Longrightarrow> (x, y) \\<in> S", "hence ux_RF: \"(u, x) \\<in> RF (\\<E> S)\" and ux_\\<E>: \"(u, x) \\<notin> \\<E> S\""], ["proof (prove)\nusing this:\n  (u, x) \\<in> RF\\<^sup>\\<circ> S\n\ngoal (1 subgoal):\n 1. (u, x) \\<in> RF (\\<E> S) &&& (u, x) \\<notin> \\<E> S", "unfolding RF_essential"], ["proof (prove)\nusing this:\n  (u, x) \\<in> RF\\<^sup>\\<circ> S\n\ngoal (1 subgoal):\n 1. (u, x) \\<in> RF S &&& (u, x) \\<notin> \\<E> S", "by(simp_all add: roofed_circ_def)"], ["proof (state)\nthis:\n  (u, x) \\<in> RF (\\<E> S)\n  (u, x) \\<notin> \\<E> S\n\ngoal (1 subgoal):\n 1. x \\<noteq> source \\<Delta> \\<Longrightarrow> (x, y) \\<in> S", "from ux e"], ["proof (chain)\npicking this:\n  edge \\<Delta> u x\n  edge \\<Delta> x y", "have \"edge \\<Gamma> (u, x) (x, y)\""], ["proof (prove)\nusing this:\n  edge \\<Delta> u x\n  edge \\<Delta> x y\n\ngoal (1 subgoal):\n 1. edge \\<Gamma> (u, x) (x, y)", "by(simp add: \\<Gamma>_def)"], ["proof (state)\nthis:\n  edge \\<Gamma> (u, x) (x, y)\n\ngoal (1 subgoal):\n 1. x \\<noteq> source \\<Delta> \\<Longrightarrow> (x, y) \\<in> S", "hence \"path \\<Gamma> (u, x) ((x, y) # ?p) ?t\""], ["proof (prove)\nusing this:\n  edge \\<Gamma> (u, x) (x, y)\n\ngoal (1 subgoal):\n 1. path \\<Gamma> (u, x) ((x, y) # zip (y # p) p)\n     (last (x # butlast (y # p)), sink \\<Delta>)", "using p''"], ["proof (prove)\nusing this:\n  edge \\<Gamma> (u, x) (x, y)\n  path \\<Gamma> (x, y) (zip (y # p) p)\n   (last (x # butlast (y # p)), sink \\<Delta>)\n\ngoal (1 subgoal):\n 1. path \\<Gamma> (u, x) ((x, y) # zip (y # p) p)\n     (last (x # butlast (y # p)), sink \\<Delta>)", ".."], ["proof (state)\nthis:\n  path \\<Gamma> (u, x) ((x, y) # zip (y # p) p)\n   (last (x # butlast (y # p)), sink \\<Delta>)\n\ngoal (1 subgoal):\n 1. x \\<noteq> source \\<Delta> \\<Longrightarrow> (x, y) \\<in> S", "from roofedD[OF ux_RF this t] ux_\\<E>"], ["proof (chain)\npicking this:\n  (\\<exists>z\\<in>set ((x, y) # zip (y # p) p). z \\<in> \\<E> S) \\<or>\n  (u, x) \\<in> \\<E> S\n  (u, x) \\<notin> \\<E> S", "consider \"(x, y) \\<in> S\" | (z) z z' where \"(z, z') \\<in> set ?p\" \"(z, z') \\<in> \\<E> S\""], ["proof (prove)\nusing this:\n  (\\<exists>z\\<in>set ((x, y) # zip (y # p) p). z \\<in> \\<E> S) \\<or>\n  (u, x) \\<in> \\<E> S\n  (u, x) \\<notin> \\<E> S\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(x, y) \\<in> S \\<Longrightarrow> thesis;\n     \\<And>z z'.\n        \\<lbrakk>(z, z') \\<in> set (zip (y # p) p);\n         (z, z') \\<in> \\<E> S\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>(x, y) \\<in> S \\<Longrightarrow> ?thesis;\n   \\<And>z z'.\n      \\<lbrakk>(z, z') \\<in> set (zip (y # p) p);\n       (z, z') \\<in> \\<E> S\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. x \\<noteq> source \\<Delta> \\<Longrightarrow> (x, y) \\<in> S", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>(x, y) \\<in> S \\<Longrightarrow> ?thesis;\n   \\<And>z z'.\n      \\<lbrakk>(z, z') \\<in> set (zip (y # p) p);\n       (z, z') \\<in> \\<E> S\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (x, y) \\<in> S", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. (x, y) \\<in> S \\<Longrightarrow> (x, y) \\<in> S\n 2. \\<And>z z'.\n       \\<lbrakk>(z, z') \\<in> set (zip (y # p) p);\n        (z, z') \\<in> \\<E> S\\<rbrakk>\n       \\<Longrightarrow> (x, y) \\<in> S", "case (z z)"], ["proof (state)\nthis:\n  (z, z') \\<in> set (zip (y # p) p)\n  (z, z') \\<in> \\<E> S\n\ngoal (2 subgoals):\n 1. (x, y) \\<in> S \\<Longrightarrow> (x, y) \\<in> S\n 2. \\<And>z z'.\n       \\<lbrakk>(z, z') \\<in> set (zip (y # p) p);\n        (z, z') \\<in> \\<E> S\\<rbrakk>\n       \\<Longrightarrow> (x, y) \\<in> S", "with bypass[of z] y'"], ["proof (chain)\npicking this:\n  z \\<in> set p \\<Longrightarrow> z \\<notin> fst ` \\<E> S\n  y \\<notin> fst ` \\<E> S\n  (z, z') \\<in> set (zip (y # p) p)\n  (z, z') \\<in> \\<E> S", "have False"], ["proof (prove)\nusing this:\n  z \\<in> set p \\<Longrightarrow> z \\<notin> fst ` \\<E> S\n  y \\<notin> fst ` \\<E> S\n  (z, z') \\<in> set (zip (y # p) p)\n  (z, z') \\<in> \\<E> S\n\ngoal (1 subgoal):\n 1. False", "by(fastforce dest!: set_zip_leftD intro: rev_image_eqI)"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. (x, y) \\<in> S \\<Longrightarrow> (x, y) \\<in> S\n 2. \\<And>z z'.\n       \\<lbrakk>(z, z') \\<in> set (zip (y # p) p);\n        (z, z') \\<in> \\<E> S\\<rbrakk>\n       \\<Longrightarrow> (x, y) \\<in> S", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. (x, y) \\<in> S", ".."], ["proof (state)\nthis:\n  (x, y) \\<in> S\n\ngoal (1 subgoal):\n 1. (x, y) \\<in> S \\<Longrightarrow> (x, y) \\<in> S", "qed"], ["proof (state)\nthis:\n  (x, y) \\<in> S\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (x, y) \\<in> S\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma orthogonal_flow_of_current:\n  assumes source_sink: \"source \\<Delta> \\<noteq> sink \\<Delta>\"\n  and sink_out: \"\\<And>x. \\<not> edge \\<Delta> (sink \\<Delta>) x\"\n  and no_direct_edge: \"\\<not> edge \\<Delta> (source \\<Delta>) (sink \\<Delta>)\" \\<comment> \\<open>Otherwise, @{const A} and @{const B} of the web would not be disjoint.\\<close>\n  shows \"orthogonal \\<Delta> (flow_of_current \\<Delta> f) (cut_of_sep S)\" (is \"orthogonal _ ?f ?S\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. orthogonal \\<Delta> (flow_of_current \\<Delta> f) (local.cut_of_sep S)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>edge \\<Delta> x y; x \\<in> local.cut_of_sep S;\n        y \\<notin> local.cut_of_sep S\\<rbrakk>\n       \\<Longrightarrow> flow_of_current \\<Delta> f (x, y) =\n                         capacity \\<Delta> (x, y)\n 2. \\<And>x y.\n       \\<lbrakk>edge \\<Delta> x y; x \\<notin> local.cut_of_sep S;\n        y \\<in> local.cut_of_sep S\\<rbrakk>\n       \\<Longrightarrow> flow_of_current \\<Delta> f (x, y) = 0", "fix x y"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>edge \\<Delta> x y; x \\<in> local.cut_of_sep S;\n        y \\<notin> local.cut_of_sep S\\<rbrakk>\n       \\<Longrightarrow> flow_of_current \\<Delta> f (x, y) =\n                         capacity \\<Delta> (x, y)\n 2. \\<And>x y.\n       \\<lbrakk>edge \\<Delta> x y; x \\<notin> local.cut_of_sep S;\n        y \\<in> local.cut_of_sep S\\<rbrakk>\n       \\<Longrightarrow> flow_of_current \\<Delta> f (x, y) = 0", "assume e: \"edge \\<Delta> x y\" and \"x \\<in> ?S\" and \"y \\<notin> ?S\""], ["proof (state)\nthis:\n  edge \\<Delta> x y\n  x \\<in> local.cut_of_sep S\n  y \\<notin> local.cut_of_sep S\n\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>edge \\<Delta> x y; x \\<in> local.cut_of_sep S;\n        y \\<notin> local.cut_of_sep S\\<rbrakk>\n       \\<Longrightarrow> flow_of_current \\<Delta> f (x, y) =\n                         capacity \\<Delta> (x, y)\n 2. \\<And>x y.\n       \\<lbrakk>edge \\<Delta> x y; x \\<notin> local.cut_of_sep S;\n        y \\<in> local.cut_of_sep S\\<rbrakk>\n       \\<Longrightarrow> flow_of_current \\<Delta> f (x, y) = 0", "then"], ["proof (chain)\npicking this:\n  edge \\<Delta> x y\n  x \\<in> local.cut_of_sep S\n  y \\<notin> local.cut_of_sep S", "have S: \"(x, y) \\<in> S\""], ["proof (prove)\nusing this:\n  edge \\<Delta> x y\n  x \\<in> local.cut_of_sep S\n  y \\<notin> local.cut_of_sep S\n\ngoal (1 subgoal):\n 1. (x, y) \\<in> S", "by(rule orthogonal_leave_RF)"], ["proof (state)\nthis:\n  (x, y) \\<in> S\n\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>edge \\<Delta> x y; x \\<in> local.cut_of_sep S;\n        y \\<notin> local.cut_of_sep S\\<rbrakk>\n       \\<Longrightarrow> flow_of_current \\<Delta> f (x, y) =\n                         capacity \\<Delta> (x, y)\n 2. \\<And>x y.\n       \\<lbrakk>edge \\<Delta> x y; x \\<notin> local.cut_of_sep S;\n        y \\<in> local.cut_of_sep S\\<rbrakk>\n       \\<Longrightarrow> flow_of_current \\<Delta> f (x, y) = 0", "show \"?f (x, y) = capacity \\<Delta> (x, y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. flow_of_current \\<Delta> f (x, y) = capacity \\<Delta> (x, y)", "proof(cases \"x = source \\<Delta>\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x = source \\<Delta> \\<Longrightarrow>\n    flow_of_current \\<Delta> f (x, y) = capacity \\<Delta> (x, y)\n 2. x \\<noteq> source \\<Delta> \\<Longrightarrow>\n    flow_of_current \\<Delta> f (x, y) = capacity \\<Delta> (x, y)", "case False"], ["proof (state)\nthis:\n  x \\<noteq> source \\<Delta>\n\ngoal (2 subgoals):\n 1. x = source \\<Delta> \\<Longrightarrow>\n    flow_of_current \\<Delta> f (x, y) = capacity \\<Delta> (x, y)\n 2. x \\<noteq> source \\<Delta> \\<Longrightarrow>\n    flow_of_current \\<Delta> f (x, y) = capacity \\<Delta> (x, y)", "with orthogonal_currentD_SAT[OF ortho S]"], ["proof (chain)\npicking this:\n  (x, y) \\<in> SAT \\<Gamma> f\n  x \\<noteq> source \\<Delta>", "have \"weight \\<Gamma> (x, y) \\<le> d_IN f (x, y)\""], ["proof (prove)\nusing this:\n  (x, y) \\<in> SAT \\<Gamma> f\n  x \\<noteq> source \\<Delta>\n\ngoal (1 subgoal):\n 1. weight \\<Gamma> (x, y) \\<le> d_IN f (x, y)", "by cases(simp_all add: \\<Gamma>_def)"], ["proof (state)\nthis:\n  weight \\<Gamma> (x, y) \\<le> d_IN f (x, y)\n\ngoal (2 subgoals):\n 1. x = source \\<Delta> \\<Longrightarrow>\n    flow_of_current \\<Delta> f (x, y) = capacity \\<Delta> (x, y)\n 2. x \\<noteq> source \\<Delta> \\<Longrightarrow>\n    flow_of_current \\<Delta> f (x, y) = capacity \\<Delta> (x, y)", "with False currentD_OUT_IN[OF f, of \"(x, y)\"] currentD_weight_IN[OF f, of \"(x, y)\"]"], ["proof (chain)\npicking this:\n  x \\<noteq> source \\<Delta>\n  (x, y) \\<notin> A \\<Gamma> \\<Longrightarrow>\n  d_OUT f (x, y) \\<le> d_IN f (x, y)\n  d_IN f (x, y) \\<le> weight \\<Gamma> (x, y)\n  weight \\<Gamma> (x, y) \\<le> d_IN f (x, y)", "show ?thesis"], ["proof (prove)\nusing this:\n  x \\<noteq> source \\<Delta>\n  (x, y) \\<notin> A \\<Gamma> \\<Longrightarrow>\n  d_OUT f (x, y) \\<le> d_IN f (x, y)\n  d_IN f (x, y) \\<le> weight \\<Gamma> (x, y)\n  weight \\<Gamma> (x, y) \\<le> d_IN f (x, y)\n\ngoal (1 subgoal):\n 1. flow_of_current \\<Delta> f (x, y) = capacity \\<Delta> (x, y)", "by(simp add: flow_of_current_def \\<Gamma>_def max_def)"], ["proof (state)\nthis:\n  flow_of_current \\<Delta> f (x, y) = capacity \\<Delta> (x, y)\n\ngoal (1 subgoal):\n 1. x = source \\<Delta> \\<Longrightarrow>\n    flow_of_current \\<Delta> f (x, y) = capacity \\<Delta> (x, y)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x = source \\<Delta> \\<Longrightarrow>\n    flow_of_current \\<Delta> f (x, y) = capacity \\<Delta> (x, y)", "case True"], ["proof (state)\nthis:\n  x = source \\<Delta>\n\ngoal (1 subgoal):\n 1. x = source \\<Delta> \\<Longrightarrow>\n    flow_of_current \\<Delta> f (x, y) = capacity \\<Delta> (x, y)", "with orthogonal_currentD_A[OF ortho S] e currentD_weight_IN[OF f, of \"(x, y)\"] no_direct_edge"], ["proof (chain)\npicking this:\n  \\<lbrakk>(x, y) \\<in> A \\<Gamma>; (x, y) \\<notin> B \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> d_OUT f (x, y) = weight \\<Gamma> (x, y)\n  edge \\<Delta> x y\n  d_IN f (x, y) \\<le> weight \\<Gamma> (x, y)\n  \\<not> edge \\<Delta> (source \\<Delta>) (sink \\<Delta>)\n  x = source \\<Delta>", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>(x, y) \\<in> A \\<Gamma>; (x, y) \\<notin> B \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> d_OUT f (x, y) = weight \\<Gamma> (x, y)\n  edge \\<Delta> x y\n  d_IN f (x, y) \\<le> weight \\<Gamma> (x, y)\n  \\<not> edge \\<Delta> (source \\<Delta>) (sink \\<Delta>)\n  x = source \\<Delta>\n\ngoal (1 subgoal):\n 1. flow_of_current \\<Delta> f (x, y) = capacity \\<Delta> (x, y)", "by(auto simp add: flow_of_current_def \\<Gamma>_def max_def)"], ["proof (state)\nthis:\n  flow_of_current \\<Delta> f (x, y) = capacity \\<Delta> (x, y)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  flow_of_current \\<Delta> f (x, y) = capacity \\<Delta> (x, y)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>edge \\<Delta> x y; x \\<notin> local.cut_of_sep S;\n        y \\<in> local.cut_of_sep S\\<rbrakk>\n       \\<Longrightarrow> flow_of_current \\<Delta> f (x, y) = 0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>edge \\<Delta> x y; x \\<notin> local.cut_of_sep S;\n        y \\<in> local.cut_of_sep S\\<rbrakk>\n       \\<Longrightarrow> flow_of_current \\<Delta> f (x, y) = 0", "from sep source_sink sink_out"], ["proof (chain)\npicking this:\n  separating \\<Gamma> S\n  source \\<Delta> \\<noteq> sink \\<Delta>\n  \\<not> edge \\<Delta> (sink \\<Delta>) ?x", "have cut: \"cut \\<Delta> ?S\""], ["proof (prove)\nusing this:\n  separating \\<Gamma> S\n  source \\<Delta> \\<noteq> sink \\<Delta>\n  \\<not> edge \\<Delta> (sink \\<Delta>) ?x\n\ngoal (1 subgoal):\n 1. cut \\<Delta> (local.cut_of_sep S)", "by(rule separating_cut)"], ["proof (state)\nthis:\n  cut \\<Delta> (local.cut_of_sep S)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>edge \\<Delta> x y; x \\<notin> local.cut_of_sep S;\n        y \\<in> local.cut_of_sep S\\<rbrakk>\n       \\<Longrightarrow> flow_of_current \\<Delta> f (x, y) = 0", "fix x y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>edge \\<Delta> x y; x \\<notin> local.cut_of_sep S;\n        y \\<in> local.cut_of_sep S\\<rbrakk>\n       \\<Longrightarrow> flow_of_current \\<Delta> f (x, y) = 0", "assume xy: \"edge \\<Delta> x y\"\n    and x: \"x \\<notin> ?S\"\n    and y: \"y \\<in> ?S\""], ["proof (state)\nthis:\n  edge \\<Delta> x y\n  x \\<notin> local.cut_of_sep S\n  y \\<in> local.cut_of_sep S\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>edge \\<Delta> x y; x \\<notin> local.cut_of_sep S;\n        y \\<in> local.cut_of_sep S\\<rbrakk>\n       \\<Longrightarrow> flow_of_current \\<Delta> f (x, y) = 0", "from x"], ["proof (chain)\npicking this:\n  x \\<notin> local.cut_of_sep S", "obtain p where p: \"path \\<Delta> x p (sink \\<Delta>)\" and x': \"x \\<notin> fst ` \\<E> S\"\n    and bypass: \"\\<And>z. z \\<in> set p \\<Longrightarrow> z \\<notin> fst ` \\<E> S\""], ["proof (prove)\nusing this:\n  x \\<notin> local.cut_of_sep S\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        \\<lbrakk>path \\<Delta> x p (sink \\<Delta>); x \\<notin> fst ` \\<E> S;\n         \\<And>z.\n            z \\<in> set p \\<Longrightarrow> z \\<notin> fst ` \\<E> S\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto simp add: roofed_def cut_of_sep_def)"], ["proof (state)\nthis:\n  path \\<Delta> x p (sink \\<Delta>)\n  x \\<notin> fst ` \\<E> S\n  ?z \\<in> set p \\<Longrightarrow> ?z \\<notin> fst ` \\<E> S\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>edge \\<Delta> x y; x \\<notin> local.cut_of_sep S;\n        y \\<in> local.cut_of_sep S\\<rbrakk>\n       \\<Longrightarrow> flow_of_current \\<Delta> f (x, y) = 0", "have source: \"x \\<noteq> source \\<Delta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<noteq> source \\<Delta>", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. x = source \\<Delta> \\<Longrightarrow> False", "assume \"x = source \\<Delta>\""], ["proof (state)\nthis:\n  x = source \\<Delta>\n\ngoal (1 subgoal):\n 1. x = source \\<Delta> \\<Longrightarrow> False", "have \"separating_network \\<Delta> (fst ` \\<E> S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. separating_network \\<Delta> (fst ` \\<E> S)", "using sep source_sink"], ["proof (prove)\nusing this:\n  separating \\<Gamma> S\n  source \\<Delta> \\<noteq> sink \\<Delta>\n\ngoal (1 subgoal):\n 1. separating_network \\<Delta> (fst ` \\<E> S)", "by(rule separating_network_cut_of_sep)"], ["proof (state)\nthis:\n  separating_network \\<Delta> (fst ` \\<E> S)\n\ngoal (1 subgoal):\n 1. x = source \\<Delta> \\<Longrightarrow> False", "from separatingD[OF this p] \\<open>x = source \\<Delta>\\<close> x"], ["proof (chain)\npicking this:\n  \\<lbrakk>x \\<in> {source \\<Delta>};\n   sink \\<Delta> \\<in> {sink \\<Delta>}\\<rbrakk>\n  \\<Longrightarrow> (\\<exists>z\\<in>set p. z \\<in> fst ` \\<E> S) \\<or>\n                    x \\<in> fst ` \\<E> S\n  x = source \\<Delta>\n  x \\<notin> local.cut_of_sep S", "show False"], ["proof (prove)\nusing this:\n  \\<lbrakk>x \\<in> {source \\<Delta>};\n   sink \\<Delta> \\<in> {sink \\<Delta>}\\<rbrakk>\n  \\<Longrightarrow> (\\<exists>z\\<in>set p. z \\<in> fst ` \\<E> S) \\<or>\n                    x \\<in> fst ` \\<E> S\n  x = source \\<Delta>\n  x \\<notin> local.cut_of_sep S\n\ngoal (1 subgoal):\n 1. False", "by(auto dest: bypass intro: roofed_greaterI simp add: cut_of_sep_def)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x \\<noteq> source \\<Delta>\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>edge \\<Delta> x y; x \\<notin> local.cut_of_sep S;\n        y \\<in> local.cut_of_sep S\\<rbrakk>\n       \\<Longrightarrow> flow_of_current \\<Delta> f (x, y) = 0", "hence A: \"(x, y) \\<notin> A \\<Gamma>\""], ["proof (prove)\nusing this:\n  x \\<noteq> source \\<Delta>\n\ngoal (1 subgoal):\n 1. (x, y) \\<notin> A \\<Gamma>", "by(simp add: \\<Gamma>_def)"], ["proof (state)\nthis:\n  (x, y) \\<notin> A \\<Gamma>\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>edge \\<Delta> x y; x \\<notin> local.cut_of_sep S;\n        y \\<in> local.cut_of_sep S\\<rbrakk>\n       \\<Longrightarrow> flow_of_current \\<Delta> f (x, y) = 0", "have \"f ((u, v), x, y) = 0\" for u v"], ["proof (prove)\ngoal (1 subgoal):\n 1. f ((u, v), x, y) = 0", "proof(cases \"edge \\<Gamma> (u, v) (x, y)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. edge \\<Gamma> (u, v) (x, y) \\<Longrightarrow> f ((u, v), x, y) = 0\n 2. \\<not> edge \\<Gamma> (u, v) (x, y) \\<Longrightarrow>\n    f ((u, v), x, y) = 0", "case False"], ["proof (state)\nthis:\n  \\<not> edge \\<Gamma> (u, v) (x, y)\n\ngoal (2 subgoals):\n 1. edge \\<Gamma> (u, v) (x, y) \\<Longrightarrow> f ((u, v), x, y) = 0\n 2. \\<not> edge \\<Gamma> (u, v) (x, y) \\<Longrightarrow>\n    f ((u, v), x, y) = 0", "with f"], ["proof (chain)\npicking this:\n  current \\<Gamma> f\n  \\<not> edge \\<Gamma> (u, v) (x, y)", "show ?thesis"], ["proof (prove)\nusing this:\n  current \\<Gamma> f\n  \\<not> edge \\<Gamma> (u, v) (x, y)\n\ngoal (1 subgoal):\n 1. f ((u, v), x, y) = 0", "by(rule currentD_outside)"], ["proof (state)\nthis:\n  f ((u, v), x, y) = 0\n\ngoal (1 subgoal):\n 1. edge \\<Gamma> (u, v) (x, y) \\<Longrightarrow> f ((u, v), x, y) = 0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. edge \\<Gamma> (u, v) (x, y) \\<Longrightarrow> f ((u, v), x, y) = 0", "case True"], ["proof (state)\nthis:\n  edge \\<Gamma> (u, v) (x, y)\n\ngoal (1 subgoal):\n 1. edge \\<Gamma> (u, v) (x, y) \\<Longrightarrow> f ((u, v), x, y) = 0", "hence [simp]: \"v = x\" and ux: \"edge \\<Delta> u x\""], ["proof (prove)\nusing this:\n  edge \\<Gamma> (u, v) (x, y)\n\ngoal (1 subgoal):\n 1. v = x &&& edge \\<Delta> u x", "by(auto simp add: \\<Gamma>_def)"], ["proof (state)\nthis:\n  v = x\n  edge \\<Delta> u x\n\ngoal (1 subgoal):\n 1. edge \\<Gamma> (u, v) (x, y) \\<Longrightarrow> f ((u, v), x, y) = 0", "have \"(x, y) \\<in> RF S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x, y) \\<in> RF S", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p ya.\n       \\<lbrakk>path \\<Gamma> (x, y) p ya; ya \\<in> B \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>z\\<in>set p. z \\<in> S) \\<or>\n                         (x, y) \\<in> S", "fix q b"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p ya.\n       \\<lbrakk>path \\<Gamma> (x, y) p ya; ya \\<in> B \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>z\\<in>set p. z \\<in> S) \\<or>\n                         (x, y) \\<in> S", "assume q: \"path \\<Gamma> (x, y) q b\" and b: \"b \\<in> B \\<Gamma>\""], ["proof (state)\nthis:\n  path \\<Gamma> (x, y) q b\n  b \\<in> B \\<Gamma>\n\ngoal (1 subgoal):\n 1. \\<And>p ya.\n       \\<lbrakk>path \\<Gamma> (x, y) p ya; ya \\<in> B \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>z\\<in>set p. z \\<in> S) \\<or>\n                         (x, y) \\<in> S", "define xy where \"xy = (x, y)\""], ["proof (state)\nthis:\n  xy = (x, y)\n\ngoal (1 subgoal):\n 1. \\<And>p ya.\n       \\<lbrakk>path \\<Gamma> (x, y) p ya; ya \\<in> B \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>z\\<in>set p. z \\<in> S) \\<or>\n                         (x, y) \\<in> S", "from q"], ["proof (chain)\npicking this:\n  path \\<Gamma> (x, y) q b", "have \"path \\<Delta> (snd xy) (map snd q) (snd b)\""], ["proof (prove)\nusing this:\n  path \\<Gamma> (x, y) q b\n\ngoal (1 subgoal):\n 1. path \\<Delta> (snd xy) (map snd q) (snd b)", "unfolding xy_def[symmetric]"], ["proof (prove)\nusing this:\n  path \\<Gamma> xy q b\n\ngoal (1 subgoal):\n 1. path \\<Delta> (snd xy) (map snd q) (snd b)", "by(induction)(auto intro: rtrancl_path.intros simp add: \\<Gamma>_def)"], ["proof (state)\nthis:\n  path \\<Delta> (snd xy) (map snd q) (snd b)\n\ngoal (1 subgoal):\n 1. \\<And>p ya.\n       \\<lbrakk>path \\<Gamma> (x, y) p ya; ya \\<in> B \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>z\\<in>set p. z \\<in> S) \\<or>\n                         (x, y) \\<in> S", "with b"], ["proof (chain)\npicking this:\n  b \\<in> B \\<Gamma>\n  path \\<Delta> (snd xy) (map snd q) (snd b)", "have \"path \\<Delta> y (map snd q) (sink \\<Delta>)\""], ["proof (prove)\nusing this:\n  b \\<in> B \\<Gamma>\n  path \\<Delta> (snd xy) (map snd q) (snd b)\n\ngoal (1 subgoal):\n 1. path \\<Delta> y (map snd q) (sink \\<Delta>)", "by(auto simp add: xy_def \\<Gamma>_def)"], ["proof (state)\nthis:\n  path \\<Delta> y (map snd q) (sink \\<Delta>)\n\ngoal (1 subgoal):\n 1. \\<And>p ya.\n       \\<lbrakk>path \\<Gamma> (x, y) p ya; ya \\<in> B \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>z\\<in>set p. z \\<in> S) \\<or>\n                         (x, y) \\<in> S", "from roofedD[OF y[unfolded cut_of_sep_def] this]"], ["proof (chain)\npicking this:\n  sink \\<Delta> \\<in> {sink \\<Delta>} \\<Longrightarrow>\n  (\\<exists>z\\<in>set (map snd q). z \\<in> fst ` \\<E> S) \\<or>\n  y \\<in> fst ` \\<E> S", "have \"\\<exists>z\\<in>set (y # map snd q). z \\<in> ?S\""], ["proof (prove)\nusing this:\n  sink \\<Delta> \\<in> {sink \\<Delta>} \\<Longrightarrow>\n  (\\<exists>z\\<in>set (map snd q). z \\<in> fst ` \\<E> S) \\<or>\n  y \\<in> fst ` \\<E> S\n\ngoal (1 subgoal):\n 1. \\<exists>z\\<in>set (y # map snd q). z \\<in> local.cut_of_sep S", "by(auto intro: roofed_greaterI simp add: cut_of_sep_def)"], ["proof (state)\nthis:\n  \\<exists>z\\<in>set (y # map snd q). z \\<in> local.cut_of_sep S\n\ngoal (1 subgoal):\n 1. \\<And>p ya.\n       \\<lbrakk>path \\<Gamma> (x, y) p ya; ya \\<in> B \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>z\\<in>set p. z \\<in> S) \\<or>\n                         (x, y) \\<in> S", "from split_list_last_prop[OF this]"], ["proof (chain)\npicking this:\n  \\<exists>ys x zs.\n     y # map snd q = ys @ x # zs \\<and>\n     x \\<in> local.cut_of_sep S \\<and>\n     (\\<forall>z\\<in>set zs. z \\<notin> local.cut_of_sep S)", "obtain xs z ys where decomp: \"y # map snd q = xs @ z # ys\"\n        and z: \"z \\<in> ?S\" and last: \"\\<And>z. z \\<in> set ys \\<Longrightarrow> z \\<notin> ?S\""], ["proof (prove)\nusing this:\n  \\<exists>ys x zs.\n     y # map snd q = ys @ x # zs \\<and>\n     x \\<in> local.cut_of_sep S \\<and>\n     (\\<forall>z\\<in>set zs. z \\<notin> local.cut_of_sep S)\n\ngoal (1 subgoal):\n 1. (\\<And>xs z ys.\n        \\<lbrakk>y # map snd q = xs @ z # ys; z \\<in> local.cut_of_sep S;\n         \\<And>z.\n            z \\<in> set ys \\<Longrightarrow>\n            z \\<notin> local.cut_of_sep S\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  y # map snd q = xs @ z # ys\n  z \\<in> local.cut_of_sep S\n  ?z \\<in> set ys \\<Longrightarrow> ?z \\<notin> local.cut_of_sep S\n\ngoal (1 subgoal):\n 1. \\<And>p ya.\n       \\<lbrakk>path \\<Gamma> (x, y) p ya; ya \\<in> B \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>z\\<in>set p. z \\<in> S) \\<or>\n                         (x, y) \\<in> S", "from decomp"], ["proof (chain)\npicking this:\n  y # map snd q = xs @ z # ys", "obtain x' xs' z'' ys' where decomp': \"(x', y) # q = xs' @ (z'', z) # ys'\"\n        and \"xs = map snd xs'\" and ys: \"ys = map snd ys'\" and x': \"xs' = [] \\<Longrightarrow> x' = x\""], ["proof (prove)\nusing this:\n  y # map snd q = xs @ z # ys\n\ngoal (1 subgoal):\n 1. (\\<And>x' xs' z'' ys'.\n        \\<lbrakk>(x', y) # q = xs' @ (z'', z) # ys'; xs = map snd xs';\n         ys = map snd ys'; xs' = [] \\<Longrightarrow> x' = x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce simp add: Cons_eq_append_conv map_eq_append_conv)"], ["proof (state)\nthis:\n  (x', y) # q = xs' @ (z'', z) # ys'\n  xs = map snd xs'\n  ys = map snd ys'\n  xs' = [] \\<Longrightarrow> x' = x\n\ngoal (1 subgoal):\n 1. \\<And>p ya.\n       \\<lbrakk>path \\<Gamma> (x, y) p ya; ya \\<in> B \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>z\\<in>set p. z \\<in> S) \\<or>\n                         (x, y) \\<in> S", "from cut z"], ["proof (chain)\npicking this:\n  cut \\<Delta> (local.cut_of_sep S)\n  z \\<in> local.cut_of_sep S", "have z_sink: \"z \\<noteq> sink \\<Delta>\""], ["proof (prove)\nusing this:\n  cut \\<Delta> (local.cut_of_sep S)\n  z \\<in> local.cut_of_sep S\n\ngoal (1 subgoal):\n 1. z \\<noteq> sink \\<Delta>", "by cases(auto)"], ["proof (state)\nthis:\n  z \\<noteq> sink \\<Delta>\n\ngoal (1 subgoal):\n 1. \\<And>p ya.\n       \\<lbrakk>path \\<Gamma> (x, y) p ya; ya \\<in> B \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>z\\<in>set p. z \\<in> S) \\<or>\n                         (x, y) \\<in> S", "then"], ["proof (chain)\npicking this:\n  z \\<noteq> sink \\<Delta>", "have \"ys' \\<noteq> []\""], ["proof (prove)\nusing this:\n  z \\<noteq> sink \\<Delta>\n\ngoal (1 subgoal):\n 1. ys' \\<noteq> []", "using rtrancl_path_last[OF q] decomp' b x' q"], ["proof (prove)\nusing this:\n  z \\<noteq> sink \\<Delta>\n  q \\<noteq> [] \\<Longrightarrow> last q = b\n  (x', y) # q = xs' @ (z'', z) # ys'\n  b \\<in> B \\<Gamma>\n  xs' = [] \\<Longrightarrow> x' = x\n  path \\<Gamma> (x, y) q b\n\ngoal (1 subgoal):\n 1. ys' \\<noteq> []", "by(auto simp add: Cons_eq_append_conv \\<Gamma>_def elim: rtrancl_path.cases)"], ["proof (state)\nthis:\n  ys' \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>p ya.\n       \\<lbrakk>path \\<Gamma> (x, y) p ya; ya \\<in> B \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>z\\<in>set p. z \\<in> S) \\<or>\n                         (x, y) \\<in> S", "then"], ["proof (chain)\npicking this:\n  ys' \\<noteq> []", "obtain w z''' ys'' where ys': \"ys' = (w, z''') # ys''\""], ["proof (prove)\nusing this:\n  ys' \\<noteq> []\n\ngoal (1 subgoal):\n 1. (\\<And>w z''' ys''.\n        ys' = (w, z''') # ys'' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto simp add: neq_Nil_conv)"], ["proof (state)\nthis:\n  ys' = (w, z''') # ys''\n\ngoal (1 subgoal):\n 1. \\<And>p ya.\n       \\<lbrakk>path \\<Gamma> (x, y) p ya; ya \\<in> B \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>z\\<in>set p. z \\<in> S) \\<or>\n                         (x, y) \\<in> S", "from q[THEN rtrancl_path_nth, of \"length xs'\"] decomp' ys' x'"], ["proof (chain)\npicking this:\n  length xs' < length q \\<Longrightarrow>\n  edge \\<Gamma> (((x, y) # q) ! length xs') (q ! length xs')\n  (x', y) # q = xs' @ (z'', z) # ys'\n  ys' = (w, z''') # ys''\n  xs' = [] \\<Longrightarrow> x' = x", "have \"edge \\<Gamma> (z'', z) (w, z''')\""], ["proof (prove)\nusing this:\n  length xs' < length q \\<Longrightarrow>\n  edge \\<Gamma> (((x, y) # q) ! length xs') (q ! length xs')\n  (x', y) # q = xs' @ (z'', z) # ys'\n  ys' = (w, z''') # ys''\n  xs' = [] \\<Longrightarrow> x' = x\n\ngoal (1 subgoal):\n 1. edge \\<Gamma> (z'', z) (w, z''')", "by(auto simp add: Cons_eq_append_conv nth_append)"], ["proof (state)\nthis:\n  edge \\<Gamma> (z'', z) (w, z''')\n\ngoal (1 subgoal):\n 1. \\<And>p ya.\n       \\<lbrakk>path \\<Gamma> (x, y) p ya; ya \\<in> B \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>z\\<in>set p. z \\<in> S) \\<or>\n                         (x, y) \\<in> S", "hence w: \"w = z\" and zz''': \"edge \\<Delta> z z'''\""], ["proof (prove)\nusing this:\n  edge \\<Gamma> (z'', z) (w, z''')\n\ngoal (1 subgoal):\n 1. w = z &&& edge \\<Delta> z z'''", "by(auto simp add: \\<Gamma>_def)"], ["proof (state)\nthis:\n  w = z\n  edge \\<Delta> z z'''\n\ngoal (1 subgoal):\n 1. \\<And>p ya.\n       \\<lbrakk>path \\<Gamma> (x, y) p ya; ya \\<in> B \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>z\\<in>set p. z \\<in> S) \\<or>\n                         (x, y) \\<in> S", "from ys' ys last[of z''']"], ["proof (chain)\npicking this:\n  ys' = (w, z''') # ys''\n  ys = map snd ys'\n  z''' \\<in> set ys \\<Longrightarrow> z''' \\<notin> local.cut_of_sep S", "have \"z''' \\<notin> ?S\""], ["proof (prove)\nusing this:\n  ys' = (w, z''') # ys''\n  ys = map snd ys'\n  z''' \\<in> set ys \\<Longrightarrow> z''' \\<notin> local.cut_of_sep S\n\ngoal (1 subgoal):\n 1. z''' \\<notin> local.cut_of_sep S", "by simp"], ["proof (state)\nthis:\n  z''' \\<notin> local.cut_of_sep S\n\ngoal (1 subgoal):\n 1. \\<And>p ya.\n       \\<lbrakk>path \\<Gamma> (x, y) p ya; ya \\<in> B \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>z\\<in>set p. z \\<in> S) \\<or>\n                         (x, y) \\<in> S", "with zz''' z"], ["proof (chain)\npicking this:\n  edge \\<Delta> z z'''\n  z \\<in> local.cut_of_sep S\n  z''' \\<notin> local.cut_of_sep S", "have \"(z, z''') \\<in> S\""], ["proof (prove)\nusing this:\n  edge \\<Delta> z z'''\n  z \\<in> local.cut_of_sep S\n  z''' \\<notin> local.cut_of_sep S\n\ngoal (1 subgoal):\n 1. (z, z''') \\<in> S", "by(rule orthogonal_leave_RF)"], ["proof (state)\nthis:\n  (z, z''') \\<in> S\n\ngoal (1 subgoal):\n 1. \\<And>p ya.\n       \\<lbrakk>path \\<Gamma> (x, y) p ya; ya \\<in> B \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>z\\<in>set p. z \\<in> S) \\<or>\n                         (x, y) \\<in> S", "moreover"], ["proof (state)\nthis:\n  (z, z''') \\<in> S\n\ngoal (1 subgoal):\n 1. \\<And>p ya.\n       \\<lbrakk>path \\<Gamma> (x, y) p ya; ya \\<in> B \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>z\\<in>set p. z \\<in> S) \\<or>\n                         (x, y) \\<in> S", "have \"(z, z''') \\<in> set q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (z, z''') \\<in> set q", "using decomp' ys' w"], ["proof (prove)\nusing this:\n  (x', y) # q = xs' @ (z'', z) # ys'\n  ys' = (w, z''') # ys''\n  w = z\n\ngoal (1 subgoal):\n 1. (z, z''') \\<in> set q", "by(auto simp add: Cons_eq_append_conv)"], ["proof (state)\nthis:\n  (z, z''') \\<in> set q\n\ngoal (1 subgoal):\n 1. \\<And>p ya.\n       \\<lbrakk>path \\<Gamma> (x, y) p ya; ya \\<in> B \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>z\\<in>set p. z \\<in> S) \\<or>\n                         (x, y) \\<in> S", "ultimately"], ["proof (chain)\npicking this:\n  (z, z''') \\<in> S\n  (z, z''') \\<in> set q", "show \"(\\<exists>z\\<in>set q. z \\<in> S) \\<or> (x, y) \\<in> S\""], ["proof (prove)\nusing this:\n  (z, z''') \\<in> S\n  (z, z''') \\<in> set q\n\ngoal (1 subgoal):\n 1. (\\<exists>z\\<in>set q. z \\<in> S) \\<or> (x, y) \\<in> S", "by blast"], ["proof (state)\nthis:\n  (\\<exists>z\\<in>set q. z \\<in> S) \\<or> (x, y) \\<in> S\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (x, y) \\<in> RF S\n\ngoal (1 subgoal):\n 1. edge \\<Gamma> (u, v) (x, y) \\<Longrightarrow> f ((u, v), x, y) = 0", "moreover"], ["proof (state)\nthis:\n  (x, y) \\<in> RF S\n\ngoal (1 subgoal):\n 1. edge \\<Gamma> (u, v) (x, y) \\<Longrightarrow> f ((u, v), x, y) = 0", "have \"(u, x) \\<notin> RF\\<^sup>\\<circ> S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (u, x) \\<notin> RF\\<^sup>\\<circ> S", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. (u, x) \\<in> RF\\<^sup>\\<circ> S \\<Longrightarrow> False", "assume \"(u, x) \\<in> RF\\<^sup>\\<circ> S\""], ["proof (state)\nthis:\n  (u, x) \\<in> RF\\<^sup>\\<circ> S\n\ngoal (1 subgoal):\n 1. (u, x) \\<in> RF\\<^sup>\\<circ> S \\<Longrightarrow> False", "hence ux_RF: \"(u, x) \\<in> RF (\\<E> S)\" and ux_\\<E>: \"(u, x) \\<notin> \\<E> S\""], ["proof (prove)\nusing this:\n  (u, x) \\<in> RF\\<^sup>\\<circ> S\n\ngoal (1 subgoal):\n 1. (u, x) \\<in> RF (\\<E> S) &&& (u, x) \\<notin> \\<E> S", "unfolding RF_essential"], ["proof (prove)\nusing this:\n  (u, x) \\<in> RF\\<^sup>\\<circ> S\n\ngoal (1 subgoal):\n 1. (u, x) \\<in> RF S &&& (u, x) \\<notin> \\<E> S", "by(simp_all add: roofed_circ_def)"], ["proof (state)\nthis:\n  (u, x) \\<in> RF (\\<E> S)\n  (u, x) \\<notin> \\<E> S\n\ngoal (1 subgoal):\n 1. (u, x) \\<in> RF\\<^sup>\\<circ> S \\<Longrightarrow> False", "have \"x \\<noteq> sink \\<Delta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<noteq> sink \\<Delta>", "using p xy"], ["proof (prove)\nusing this:\n  path \\<Delta> x p (sink \\<Delta>)\n  edge \\<Delta> x y\n\ngoal (1 subgoal):\n 1. x \\<noteq> sink \\<Delta>", "by cases(auto simp add: sink_out)"], ["proof (state)\nthis:\n  x \\<noteq> sink \\<Delta>\n\ngoal (1 subgoal):\n 1. (u, x) \\<in> RF\\<^sup>\\<circ> S \\<Longrightarrow> False", "with p"], ["proof (chain)\npicking this:\n  path \\<Delta> x p (sink \\<Delta>)\n  x \\<noteq> sink \\<Delta>", "have nNil: \"p \\<noteq> []\""], ["proof (prove)\nusing this:\n  path \\<Delta> x p (sink \\<Delta>)\n  x \\<noteq> sink \\<Delta>\n\ngoal (1 subgoal):\n 1. p \\<noteq> []", "by(auto elim: rtrancl_path.cases)"], ["proof (state)\nthis:\n  p \\<noteq> []\n\ngoal (1 subgoal):\n 1. (u, x) \\<in> RF\\<^sup>\\<circ> S \\<Longrightarrow> False", "with p"], ["proof (chain)\npicking this:\n  path \\<Delta> x p (sink \\<Delta>)\n  p \\<noteq> []", "have \"edge \\<Delta> x (hd p)\""], ["proof (prove)\nusing this:\n  path \\<Delta> x p (sink \\<Delta>)\n  p \\<noteq> []\n\ngoal (1 subgoal):\n 1. edge \\<Delta> x (hd p)", "by cases auto"], ["proof (state)\nthis:\n  edge \\<Delta> x (hd p)\n\ngoal (1 subgoal):\n 1. (u, x) \\<in> RF\\<^sup>\\<circ> S \\<Longrightarrow> False", "with ux"], ["proof (chain)\npicking this:\n  edge \\<Delta> u x\n  edge \\<Delta> x (hd p)", "have \"edge \\<Gamma> (u, x) (x, hd p)\""], ["proof (prove)\nusing this:\n  edge \\<Delta> u x\n  edge \\<Delta> x (hd p)\n\ngoal (1 subgoal):\n 1. edge \\<Gamma> (u, x) (x, hd p)", "by(simp add: \\<Gamma>_def)"], ["proof (state)\nthis:\n  edge \\<Gamma> (u, x) (x, hd p)\n\ngoal (1 subgoal):\n 1. (u, x) \\<in> RF\\<^sup>\\<circ> S \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  edge \\<Gamma> (u, x) (x, hd p)\n\ngoal (1 subgoal):\n 1. (u, x) \\<in> RF\\<^sup>\\<circ> S \\<Longrightarrow> False", "from p nNil"], ["proof (chain)\npicking this:\n  path \\<Delta> x p (sink \\<Delta>)\n  p \\<noteq> []", "have \"path \\<Gamma> (x, hd p) (zip p (tl p)) (last (x # butlast p), sink \\<Delta>)\" (is \"path _ ?x ?p ?t\")"], ["proof (prove)\nusing this:\n  path \\<Delta> x p (sink \\<Delta>)\n  p \\<noteq> []\n\ngoal (1 subgoal):\n 1. path \\<Gamma> (x, hd p) (zip p (tl p))\n     (last (x # butlast p), sink \\<Delta>)", "proof(induction)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       [] \\<noteq> [] \\<Longrightarrow>\n       path \\<Gamma> (x, hd []) (zip [] (tl [])) (last (x # butlast []), x)\n 2. \\<And>x y ys z.\n       \\<lbrakk>edge \\<Delta> x y; path \\<Delta> y ys z;\n        ys \\<noteq> [] \\<Longrightarrow>\n        path \\<Gamma> (y, hd ys) (zip ys (tl ys))\n         (last (y # butlast ys), z);\n        y # ys \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> path \\<Gamma> (x, hd (y # ys))\n                          (zip (y # ys) (tl (y # ys)))\n                          (last (x # butlast (y # ys)), z)", "case (step x y p z)"], ["proof (state)\nthis:\n  edge \\<Delta> x y\n  path \\<Delta> y p z\n  p \\<noteq> [] \\<Longrightarrow>\n  path \\<Gamma> (y, hd p) (zip p (tl p)) (last (y # butlast p), z)\n  y # p \\<noteq> []\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       [] \\<noteq> [] \\<Longrightarrow>\n       path \\<Gamma> (x, hd []) (zip [] (tl [])) (last (x # butlast []), x)\n 2. \\<And>x y ys z.\n       \\<lbrakk>edge \\<Delta> x y; path \\<Delta> y ys z;\n        ys \\<noteq> [] \\<Longrightarrow>\n        path \\<Gamma> (y, hd ys) (zip ys (tl ys))\n         (last (y # butlast ys), z);\n        y # ys \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> path \\<Gamma> (x, hd (y # ys))\n                          (zip (y # ys) (tl (y # ys)))\n                          (last (x # butlast (y # ys)), z)", "then"], ["proof (chain)\npicking this:\n  edge \\<Delta> x y\n  path \\<Delta> y p z\n  p \\<noteq> [] \\<Longrightarrow>\n  path \\<Gamma> (y, hd p) (zip p (tl p)) (last (y # butlast p), z)\n  y # p \\<noteq> []", "show ?case"], ["proof (prove)\nusing this:\n  edge \\<Delta> x y\n  path \\<Delta> y p z\n  p \\<noteq> [] \\<Longrightarrow>\n  path \\<Gamma> (y, hd p) (zip p (tl p)) (last (y # butlast p), z)\n  y # p \\<noteq> []\n\ngoal (1 subgoal):\n 1. path \\<Gamma> (x, hd (y # p)) (zip (y # p) (tl (y # p)))\n     (last (x # butlast (y # p)), z)", "by(cases p)(auto elim: rtrancl_path.cases intro: rtrancl_path.intros simp add: \\<Gamma>_def)"], ["proof (state)\nthis:\n  path \\<Gamma> (x, hd (y # p)) (zip (y # p) (tl (y # p)))\n   (last (x # butlast (y # p)), z)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       [] \\<noteq> [] \\<Longrightarrow>\n       path \\<Gamma> (x, hd []) (zip [] (tl [])) (last (x # butlast []), x)", "qed simp"], ["proof (state)\nthis:\n  path \\<Gamma> (x, hd p) (zip p (tl p))\n   (last (x # butlast p), sink \\<Delta>)\n\ngoal (1 subgoal):\n 1. (u, x) \\<in> RF\\<^sup>\\<circ> S \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  edge \\<Gamma> (u, x) (x, hd p)\n  path \\<Gamma> (x, hd p) (zip p (tl p))\n   (last (x # butlast p), sink \\<Delta>)", "have p': \"path \\<Gamma> (u, x) (?x # ?p) ?t\""], ["proof (prove)\nusing this:\n  edge \\<Gamma> (u, x) (x, hd p)\n  path \\<Gamma> (x, hd p) (zip p (tl p))\n   (last (x # butlast p), sink \\<Delta>)\n\ngoal (1 subgoal):\n 1. path \\<Gamma> (u, x) ((x, hd p) # zip p (tl p))\n     (last (x # butlast p), sink \\<Delta>)", ".."], ["proof (state)\nthis:\n  path \\<Gamma> (u, x) ((x, hd p) # zip p (tl p))\n   (last (x # butlast p), sink \\<Delta>)\n\ngoal (1 subgoal):\n 1. (u, x) \\<in> RF\\<^sup>\\<circ> S \\<Longrightarrow> False", "have \"(?x # ?p) ! (length p - 1) = ?t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((x, hd p) # zip p (tl p)) ! (length p - 1) =\n    (last (x # butlast p), sink \\<Delta>)", "using rtrancl_path_last[OF p] p nNil"], ["proof (prove)\nusing this:\n  p \\<noteq> [] \\<Longrightarrow> last p = sink \\<Delta>\n  path \\<Delta> x p (sink \\<Delta>)\n  p \\<noteq> []\n\ngoal (1 subgoal):\n 1. ((x, hd p) # zip p (tl p)) ! (length p - 1) =\n    (last (x # butlast p), sink \\<Delta>)", "apply(auto split: if_split_asm simp add: nth_Cons butlast_conv_take take_Suc_conv_app_nth not_le split: nat.split elim: rtrancl_path.cases)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x2.\n       \\<lbrakk>last p = sink \\<Delta>; path \\<Delta> x p (sink \\<Delta>);\n        p \\<noteq> []; length p - Suc 0 = Suc x2; Suc 0 < length p\\<rbrakk>\n       \\<Longrightarrow> tl p ! x2 = sink \\<Delta>", "apply(simp add: last_conv_nth nth_tl)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  ((x, hd p) # zip p (tl p)) ! (length p - 1) =\n  (last (x # butlast p), sink \\<Delta>)\n\ngoal (1 subgoal):\n 1. (u, x) \\<in> RF\\<^sup>\\<circ> S \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  ((x, hd p) # zip p (tl p)) ! (length p - 1) =\n  (last (x # butlast p), sink \\<Delta>)\n\ngoal (1 subgoal):\n 1. (u, x) \\<in> RF\\<^sup>\\<circ> S \\<Longrightarrow> False", "have \"length p - 1 < length (?x # ?p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length p - 1 < length ((x, hd p) # zip p (tl p))", "by simp"], ["proof (state)\nthis:\n  length p - 1 < length ((x, hd p) # zip p (tl p))\n\ngoal (1 subgoal):\n 1. (u, x) \\<in> RF\\<^sup>\\<circ> S \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  ((x, hd p) # zip p (tl p)) ! (length p - 1) =\n  (last (x # butlast p), sink \\<Delta>)\n  length p - 1 < length ((x, hd p) # zip p (tl p))", "have t: \"?t \\<in> B \\<Gamma>\""], ["proof (prove)\nusing this:\n  ((x, hd p) # zip p (tl p)) ! (length p - 1) =\n  (last (x # butlast p), sink \\<Delta>)\n  length p - 1 < length ((x, hd p) # zip p (tl p))\n\ngoal (1 subgoal):\n 1. (last (x # butlast p), sink \\<Delta>) \\<in> B \\<Gamma>", "using rtrancl_path_nth[OF p', of \"length p - 1\"]"], ["proof (prove)\nusing this:\n  ((x, hd p) # zip p (tl p)) ! (length p - 1) =\n  (last (x # butlast p), sink \\<Delta>)\n  length p - 1 < length ((x, hd p) # zip p (tl p))\n  length p - 1 < length ((x, hd p) # zip p (tl p)) \\<Longrightarrow>\n  edge \\<Gamma> (((u, x) # (x, hd p) # zip p (tl p)) ! (length p - 1))\n   (((x, hd p) # zip p (tl p)) ! (length p - 1))\n\ngoal (1 subgoal):\n 1. (last (x # butlast p), sink \\<Delta>) \\<in> B \\<Gamma>", "by(cases p)(simp_all add: \\<Gamma>_def split: if_split_asm)"], ["proof (state)\nthis:\n  (last (x # butlast p), sink \\<Delta>) \\<in> B \\<Gamma>\n\ngoal (1 subgoal):\n 1. (u, x) \\<in> RF\\<^sup>\\<circ> S \\<Longrightarrow> False", "from roofedD[OF ux_RF p' t] ux_\\<E>"], ["proof (chain)\npicking this:\n  (\\<exists>z\\<in>set ((x, hd p) # zip p (tl p)). z \\<in> \\<E> S) \\<or>\n  (u, x) \\<in> \\<E> S\n  (u, x) \\<notin> \\<E> S", "consider (X) \"(x, hd p) \\<in> \\<E> S\"\n        | (z) z z' where \"(z, z') \\<in> set (zip p (tl p))\" \"(z, z') \\<in> \\<E> S\""], ["proof (prove)\nusing this:\n  (\\<exists>z\\<in>set ((x, hd p) # zip p (tl p)). z \\<in> \\<E> S) \\<or>\n  (u, x) \\<in> \\<E> S\n  (u, x) \\<notin> \\<E> S\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(x, hd p) \\<in> \\<E> S \\<Longrightarrow> thesis;\n     \\<And>z z'.\n        \\<lbrakk>(z, z') \\<in> set (zip p (tl p));\n         (z, z') \\<in> \\<E> S\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>(x, hd p) \\<in> \\<E> S \\<Longrightarrow> ?thesis;\n   \\<And>z z'.\n      \\<lbrakk>(z, z') \\<in> set (zip p (tl p));\n       (z, z') \\<in> \\<E> S\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (u, x) \\<in> RF\\<^sup>\\<circ> S \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  \\<lbrakk>(x, hd p) \\<in> \\<E> S \\<Longrightarrow> ?thesis;\n   \\<And>z z'.\n      \\<lbrakk>(z, z') \\<in> set (zip p (tl p));\n       (z, z') \\<in> \\<E> S\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. False", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. (x, hd p) \\<in> \\<E> S \\<Longrightarrow> False\n 2. \\<And>z z'.\n       \\<lbrakk>(z, z') \\<in> set (zip p (tl p));\n        (z, z') \\<in> \\<E> S\\<rbrakk>\n       \\<Longrightarrow> False", "case X"], ["proof (state)\nthis:\n  (x, hd p) \\<in> \\<E> S\n\ngoal (2 subgoals):\n 1. (x, hd p) \\<in> \\<E> S \\<Longrightarrow> False\n 2. \\<And>z z'.\n       \\<lbrakk>(z, z') \\<in> set (zip p (tl p));\n        (z, z') \\<in> \\<E> S\\<rbrakk>\n       \\<Longrightarrow> False", "with x'"], ["proof (chain)\npicking this:\n  x \\<notin> fst ` \\<E> S\n  (x, hd p) \\<in> \\<E> S", "show False"], ["proof (prove)\nusing this:\n  x \\<notin> fst ` \\<E> S\n  (x, hd p) \\<in> \\<E> S\n\ngoal (1 subgoal):\n 1. False", "by(auto simp add: cut_of_sep_def intro: rev_image_eqI)"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<And>z z'.\n       \\<lbrakk>(z, z') \\<in> set (zip p (tl p));\n        (z, z') \\<in> \\<E> S\\<rbrakk>\n       \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>z z'.\n       \\<lbrakk>(z, z') \\<in> set (zip p (tl p));\n        (z, z') \\<in> \\<E> S\\<rbrakk>\n       \\<Longrightarrow> False", "case (z z)"], ["proof (state)\nthis:\n  (z, z') \\<in> set (zip p (tl p))\n  (z, z') \\<in> \\<E> S\n\ngoal (1 subgoal):\n 1. \\<And>z z'.\n       \\<lbrakk>(z, z') \\<in> set (zip p (tl p));\n        (z, z') \\<in> \\<E> S\\<rbrakk>\n       \\<Longrightarrow> False", "with bypass[of z]"], ["proof (chain)\npicking this:\n  z \\<in> set p \\<Longrightarrow> z \\<notin> fst ` \\<E> S\n  (z, z') \\<in> set (zip p (tl p))\n  (z, z') \\<in> \\<E> S", "show False"], ["proof (prove)\nusing this:\n  z \\<in> set p \\<Longrightarrow> z \\<notin> fst ` \\<E> S\n  (z, z') \\<in> set (zip p (tl p))\n  (z, z') \\<in> \\<E> S\n\ngoal (1 subgoal):\n 1. False", "by(auto 4 3 simp add: cut_of_sep_def intro: rev_image_eqI dest!: set_zip_leftD)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (u, x) \\<notin> RF\\<^sup>\\<circ> S\n\ngoal (1 subgoal):\n 1. edge \\<Gamma> (u, v) (x, y) \\<Longrightarrow> f ((u, v), x, y) = 0", "ultimately"], ["proof (chain)\npicking this:\n  (x, y) \\<in> RF S\n  (u, x) \\<notin> RF\\<^sup>\\<circ> S", "show ?thesis"], ["proof (prove)\nusing this:\n  (x, y) \\<in> RF S\n  (u, x) \\<notin> RF\\<^sup>\\<circ> S\n\ngoal (1 subgoal):\n 1. f ((u, v), x, y) = 0", "unfolding \\<open>v = x\\<close>"], ["proof (prove)\nusing this:\n  (x, y) \\<in> RF S\n  (u, x) \\<notin> RF\\<^sup>\\<circ> S\n\ngoal (1 subgoal):\n 1. f ((u, x), x, y) = 0", "by(rule orthogonal_currentD_in[OF ortho])"], ["proof (state)\nthis:\n  f ((u, v), x, y) = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  f ((?u, ?v), x, y) = 0\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>edge \\<Delta> x y; x \\<notin> local.cut_of_sep S;\n        y \\<in> local.cut_of_sep S\\<rbrakk>\n       \\<Longrightarrow> flow_of_current \\<Delta> f (x, y) = 0", "then"], ["proof (chain)\npicking this:\n  f ((?u, ?v), x, y) = 0", "have \"d_IN f (x, y) = 0\""], ["proof (prove)\nusing this:\n  f ((?u, ?v), x, y) = 0\n\ngoal (1 subgoal):\n 1. d_IN f (x, y) = 0", "unfolding d_IN_def"], ["proof (prove)\nusing this:\n  f ((?u, ?v), x, y) = 0\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ xa. f (xa, x, y)) = 0", "by(simp add: nn_integral_0_iff emeasure_count_space_eq_0)"], ["proof (state)\nthis:\n  d_IN f (x, y) = 0\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>edge \\<Delta> x y; x \\<notin> local.cut_of_sep S;\n        y \\<in> local.cut_of_sep S\\<rbrakk>\n       \\<Longrightarrow> flow_of_current \\<Delta> f (x, y) = 0", "with currentD_OUT_IN[OF f A]"], ["proof (chain)\npicking this:\n  d_OUT f (x, y) \\<le> d_IN f (x, y)\n  d_IN f (x, y) = 0", "show \"flow_of_current \\<Delta> f (x, y) = 0\""], ["proof (prove)\nusing this:\n  d_OUT f (x, y) \\<le> d_IN f (x, y)\n  d_IN f (x, y) = 0\n\ngoal (1 subgoal):\n 1. flow_of_current \\<Delta> f (x, y) = 0", "by(simp add: flow_of_current_def max_def)"], ["proof (state)\nthis:\n  flow_of_current \\<Delta> f (x, y) = 0\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "end"], ["", "subsection \\<open>Avoiding antiparallel edges and self-loops\\<close>"], ["", "context antiparallel_edges begin"], ["", "abbreviation cut' :: \"'a vertex set \\<Rightarrow> 'a set\" where \"cut' S \\<equiv> Vertex -` S\""], ["", "lemma cut_cut': \"cut \\<Delta>'' S \\<Longrightarrow> cut \\<Delta> (cut' S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cut \\<Delta>'' S \\<Longrightarrow> cut \\<Delta> (Vertex -` S)", "by(auto simp add: cut.simps)"], ["", "lemma IN_Edge: \"\\<^bold>I\\<^bold>N\\<^bsub>\\<Delta>''\\<^esub> (Edge x y) = (if edge \\<Delta> x y then {Vertex x} else {})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<^bold>I\\<^bold>N\\<^bsub>\\<Delta>''\\<^esub> (Edge x y) =\n    (if edge \\<Delta> x y then {Vertex x} else {})", "by(auto simp add: incoming_def)"], ["", "lemma OUT_Edge: \"\\<^bold>O\\<^bold>U\\<^bold>T\\<^bsub>\\<Delta>''\\<^esub> (Edge x y) = (if edge \\<Delta> x y then {Vertex y} else {})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<^bold>O\\<^bold>U\\<^bold>T\\<^bsub>\\<Delta>''\\<^esub> (Edge x y) =\n    (if edge \\<Delta> x y then {Vertex y} else {})", "by(auto simp add: outgoing_def)"], ["", "interpretation \\<Delta>'': countable_network \\<Delta>''"], ["proof (prove)\ngoal (1 subgoal):\n 1. countable_network \\<Delta>''", "by(rule \\<Delta>''_countable_network)"], ["", "lemma d_IN_Edge:\n  assumes f: \"flow \\<Delta>'' f\"\n  shows \"d_IN f (Edge x y) = f (Vertex x, Edge x y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN f (Edge x y) = f (Vertex x, Edge x y)", "by(subst d_IN_alt_def[OF \\<Delta>''.flowD_outside[OF f], of _ \\<Delta>''])(simp_all add: IN_Edge nn_integral_count_space_indicator max_def \\<Delta>''.flowD_outside[OF f])"], ["", "lemma d_OUT_Edge:\n  assumes f: \"flow \\<Delta>'' f\"\n  shows \"d_OUT f (Edge x y) = f (Edge x y, Vertex y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT f (Edge x y) = f (Edge x y, Vertex y)", "by(subst d_OUT_alt_def[OF \\<Delta>''.flowD_outside[OF f], of _ \\<Delta>''])(simp_all add: OUT_Edge nn_integral_count_space_indicator max_def \\<Delta>''.flowD_outside[OF f])"], ["", "lemma orthogonal_cut':\n  assumes ortho: \"orthogonal \\<Delta>'' f S\"\n  and f: \"flow \\<Delta>'' f\"\n  shows \"orthogonal \\<Delta> (collect f) (cut' S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. orthogonal \\<Delta> (\\<lambda>(x, y). f (Edge x y, Vertex y))\n     (Vertex -` S)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>edge \\<Delta> x y; x \\<in> Vertex -` S;\n        y \\<notin> Vertex -` S\\<rbrakk>\n       \\<Longrightarrow> (case (x, y) of\n                          (x, y) \\<Rightarrow> f (Edge x y, Vertex y)) =\n                         capacity \\<Delta> (x, y)\n 2. \\<And>x y.\n       \\<lbrakk>edge \\<Delta> x y; x \\<notin> Vertex -` S;\n        y \\<in> Vertex -` S\\<rbrakk>\n       \\<Longrightarrow> (case (x, y) of\n                          (x, y) \\<Rightarrow> f (Edge x y, Vertex y)) =\n                         0", "show \"collect f (x, y) = capacity \\<Delta> (x, y)\" if edge: \"edge \\<Delta> x y\" and x: \"x \\<in> cut' S\" and y: \"y \\<notin> cut' S\" for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case (x, y) of (x, y) \\<Rightarrow> f (Edge x y, Vertex y)) =\n    capacity \\<Delta> (x, y)", "proof(cases \"Edge x y \\<in> S\")"], ["proof (state)\ngoal (2 subgoals):\n 1. Edge x y \\<in> S \\<Longrightarrow>\n    (case (x, y) of (x, y) \\<Rightarrow> f (Edge x y, Vertex y)) =\n    capacity \\<Delta> (x, y)\n 2. Edge x y \\<notin> S \\<Longrightarrow>\n    (case (x, y) of (x, y) \\<Rightarrow> f (Edge x y, Vertex y)) =\n    capacity \\<Delta> (x, y)", "case True"], ["proof (state)\nthis:\n  Edge x y \\<in> S\n\ngoal (2 subgoals):\n 1. Edge x y \\<in> S \\<Longrightarrow>\n    (case (x, y) of (x, y) \\<Rightarrow> f (Edge x y, Vertex y)) =\n    capacity \\<Delta> (x, y)\n 2. Edge x y \\<notin> S \\<Longrightarrow>\n    (case (x, y) of (x, y) \\<Rightarrow> f (Edge x y, Vertex y)) =\n    capacity \\<Delta> (x, y)", "from y"], ["proof (chain)\npicking this:\n  y \\<notin> Vertex -` S", "have \"Vertex y \\<notin> S\""], ["proof (prove)\nusing this:\n  y \\<notin> Vertex -` S\n\ngoal (1 subgoal):\n 1. Vertex y \\<notin> S", "by auto"], ["proof (state)\nthis:\n  Vertex y \\<notin> S\n\ngoal (2 subgoals):\n 1. Edge x y \\<in> S \\<Longrightarrow>\n    (case (x, y) of (x, y) \\<Rightarrow> f (Edge x y, Vertex y)) =\n    capacity \\<Delta> (x, y)\n 2. Edge x y \\<notin> S \\<Longrightarrow>\n    (case (x, y) of (x, y) \\<Rightarrow> f (Edge x y, Vertex y)) =\n    capacity \\<Delta> (x, y)", "from orthogonalD_out[OF ortho _ True this] edge"], ["proof (chain)\npicking this:\n  edge \\<Delta>'' (Edge x y) (Vertex y) \\<Longrightarrow>\n  f (Edge x y, Vertex y) = capacity \\<Delta>'' (Edge x y, Vertex y)\n  edge \\<Delta> x y", "show ?thesis"], ["proof (prove)\nusing this:\n  edge \\<Delta>'' (Edge x y) (Vertex y) \\<Longrightarrow>\n  f (Edge x y, Vertex y) = capacity \\<Delta>'' (Edge x y, Vertex y)\n  edge \\<Delta> x y\n\ngoal (1 subgoal):\n 1. (case (x, y) of (x, y) \\<Rightarrow> f (Edge x y, Vertex y)) =\n    capacity \\<Delta> (x, y)", "by simp"], ["proof (state)\nthis:\n  (case (x, y) of (x, y) \\<Rightarrow> f (Edge x y, Vertex y)) =\n  capacity \\<Delta> (x, y)\n\ngoal (1 subgoal):\n 1. Edge x y \\<notin> S \\<Longrightarrow>\n    (case (x, y) of (x, y) \\<Rightarrow> f (Edge x y, Vertex y)) =\n    capacity \\<Delta> (x, y)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. Edge x y \\<notin> S \\<Longrightarrow>\n    (case (x, y) of (x, y) \\<Rightarrow> f (Edge x y, Vertex y)) =\n    capacity \\<Delta> (x, y)", "case False"], ["proof (state)\nthis:\n  Edge x y \\<notin> S\n\ngoal (1 subgoal):\n 1. Edge x y \\<notin> S \\<Longrightarrow>\n    (case (x, y) of (x, y) \\<Rightarrow> f (Edge x y, Vertex y)) =\n    capacity \\<Delta> (x, y)", "from x"], ["proof (chain)\npicking this:\n  x \\<in> Vertex -` S", "have \"Vertex x \\<in> S\""], ["proof (prove)\nusing this:\n  x \\<in> Vertex -` S\n\ngoal (1 subgoal):\n 1. Vertex x \\<in> S", "by auto"], ["proof (state)\nthis:\n  Vertex x \\<in> S\n\ngoal (1 subgoal):\n 1. Edge x y \\<notin> S \\<Longrightarrow>\n    (case (x, y) of (x, y) \\<Rightarrow> f (Edge x y, Vertex y)) =\n    capacity \\<Delta> (x, y)", "from orthogonalD_out[OF ortho _ this False] edge"], ["proof (chain)\npicking this:\n  edge \\<Delta>'' (Vertex x) (Edge x y) \\<Longrightarrow>\n  f (Vertex x, Edge x y) = capacity \\<Delta>'' (Vertex x, Edge x y)\n  edge \\<Delta> x y", "have \"capacity \\<Delta> (x, y) = d_IN f (Edge x y)\""], ["proof (prove)\nusing this:\n  edge \\<Delta>'' (Vertex x) (Edge x y) \\<Longrightarrow>\n  f (Vertex x, Edge x y) = capacity \\<Delta>'' (Vertex x, Edge x y)\n  edge \\<Delta> x y\n\ngoal (1 subgoal):\n 1. capacity \\<Delta> (x, y) = d_IN f (Edge x y)", "by(simp add: d_IN_Edge[OF f])"], ["proof (state)\nthis:\n  capacity \\<Delta> (x, y) = d_IN f (Edge x y)\n\ngoal (1 subgoal):\n 1. Edge x y \\<notin> S \\<Longrightarrow>\n    (case (x, y) of (x, y) \\<Rightarrow> f (Edge x y, Vertex y)) =\n    capacity \\<Delta> (x, y)", "also"], ["proof (state)\nthis:\n  capacity \\<Delta> (x, y) = d_IN f (Edge x y)\n\ngoal (1 subgoal):\n 1. Edge x y \\<notin> S \\<Longrightarrow>\n    (case (x, y) of (x, y) \\<Rightarrow> f (Edge x y, Vertex y)) =\n    capacity \\<Delta> (x, y)", "have \"\\<dots> = d_OUT f (Edge x y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN f (Edge x y) = d_OUT f (Edge x y)", "by(simp add: flowD_KIR[OF f])"], ["proof (state)\nthis:\n  d_IN f (Edge x y) = d_OUT f (Edge x y)\n\ngoal (1 subgoal):\n 1. Edge x y \\<notin> S \\<Longrightarrow>\n    (case (x, y) of (x, y) \\<Rightarrow> f (Edge x y, Vertex y)) =\n    capacity \\<Delta> (x, y)", "also"], ["proof (state)\nthis:\n  d_IN f (Edge x y) = d_OUT f (Edge x y)\n\ngoal (1 subgoal):\n 1. Edge x y \\<notin> S \\<Longrightarrow>\n    (case (x, y) of (x, y) \\<Rightarrow> f (Edge x y, Vertex y)) =\n    capacity \\<Delta> (x, y)", "have \"\\<dots> = f (Edge x y, Vertex y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT f (Edge x y) = f (Edge x y, Vertex y)", "using edge"], ["proof (prove)\nusing this:\n  edge \\<Delta> x y\n\ngoal (1 subgoal):\n 1. d_OUT f (Edge x y) = f (Edge x y, Vertex y)", "by(simp add: d_OUT_Edge[OF f])"], ["proof (state)\nthis:\n  d_OUT f (Edge x y) = f (Edge x y, Vertex y)\n\ngoal (1 subgoal):\n 1. Edge x y \\<notin> S \\<Longrightarrow>\n    (case (x, y) of (x, y) \\<Rightarrow> f (Edge x y, Vertex y)) =\n    capacity \\<Delta> (x, y)", "finally"], ["proof (chain)\npicking this:\n  capacity \\<Delta> (x, y) = f (Edge x y, Vertex y)", "show ?thesis"], ["proof (prove)\nusing this:\n  capacity \\<Delta> (x, y) = f (Edge x y, Vertex y)\n\ngoal (1 subgoal):\n 1. (case (x, y) of (x, y) \\<Rightarrow> f (Edge x y, Vertex y)) =\n    capacity \\<Delta> (x, y)", "by simp"], ["proof (state)\nthis:\n  (case (x, y) of (x, y) \\<Rightarrow> f (Edge x y, Vertex y)) =\n  capacity \\<Delta> (x, y)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>edge \\<Delta> ?x ?y; ?x \\<in> Vertex -` S;\n   ?y \\<notin> Vertex -` S\\<rbrakk>\n  \\<Longrightarrow> (case (?x, ?y) of\n                     (x, y) \\<Rightarrow> f (Edge x y, Vertex y)) =\n                    capacity \\<Delta> (?x, ?y)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>edge \\<Delta> x y; x \\<notin> Vertex -` S;\n        y \\<in> Vertex -` S\\<rbrakk>\n       \\<Longrightarrow> (case (x, y) of\n                          (x, y) \\<Rightarrow> f (Edge x y, Vertex y)) =\n                         0", "show \"collect f (x, y) = 0\" if edge: \"edge \\<Delta> x y\" and x: \"x \\<notin> cut' S\" and y: \"y \\<in> cut' S\" for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case (x, y) of (x, y) \\<Rightarrow> f (Edge x y, Vertex y)) = 0", "proof(cases \"Edge x y \\<in> S\")"], ["proof (state)\ngoal (2 subgoals):\n 1. Edge x y \\<in> S \\<Longrightarrow>\n    (case (x, y) of (x, y) \\<Rightarrow> f (Edge x y, Vertex y)) = 0\n 2. Edge x y \\<notin> S \\<Longrightarrow>\n    (case (x, y) of (x, y) \\<Rightarrow> f (Edge x y, Vertex y)) = 0", "case True"], ["proof (state)\nthis:\n  Edge x y \\<in> S\n\ngoal (2 subgoals):\n 1. Edge x y \\<in> S \\<Longrightarrow>\n    (case (x, y) of (x, y) \\<Rightarrow> f (Edge x y, Vertex y)) = 0\n 2. Edge x y \\<notin> S \\<Longrightarrow>\n    (case (x, y) of (x, y) \\<Rightarrow> f (Edge x y, Vertex y)) = 0", "from x"], ["proof (chain)\npicking this:\n  x \\<notin> Vertex -` S", "have \"Vertex x \\<notin> S\""], ["proof (prove)\nusing this:\n  x \\<notin> Vertex -` S\n\ngoal (1 subgoal):\n 1. Vertex x \\<notin> S", "by auto"], ["proof (state)\nthis:\n  Vertex x \\<notin> S\n\ngoal (2 subgoals):\n 1. Edge x y \\<in> S \\<Longrightarrow>\n    (case (x, y) of (x, y) \\<Rightarrow> f (Edge x y, Vertex y)) = 0\n 2. Edge x y \\<notin> S \\<Longrightarrow>\n    (case (x, y) of (x, y) \\<Rightarrow> f (Edge x y, Vertex y)) = 0", "from orthogonalD_in[OF ortho _ this True] edge"], ["proof (chain)\npicking this:\n  edge \\<Delta>'' (Vertex x) (Edge x y) \\<Longrightarrow>\n  f (Vertex x, Edge x y) = 0\n  edge \\<Delta> x y", "have \"0 = d_IN f (Edge x y)\""], ["proof (prove)\nusing this:\n  edge \\<Delta>'' (Vertex x) (Edge x y) \\<Longrightarrow>\n  f (Vertex x, Edge x y) = 0\n  edge \\<Delta> x y\n\ngoal (1 subgoal):\n 1. 0 = d_IN f (Edge x y)", "by(simp add: d_IN_Edge[OF f])"], ["proof (state)\nthis:\n  0 = d_IN f (Edge x y)\n\ngoal (2 subgoals):\n 1. Edge x y \\<in> S \\<Longrightarrow>\n    (case (x, y) of (x, y) \\<Rightarrow> f (Edge x y, Vertex y)) = 0\n 2. Edge x y \\<notin> S \\<Longrightarrow>\n    (case (x, y) of (x, y) \\<Rightarrow> f (Edge x y, Vertex y)) = 0", "also"], ["proof (state)\nthis:\n  0 = d_IN f (Edge x y)\n\ngoal (2 subgoals):\n 1. Edge x y \\<in> S \\<Longrightarrow>\n    (case (x, y) of (x, y) \\<Rightarrow> f (Edge x y, Vertex y)) = 0\n 2. Edge x y \\<notin> S \\<Longrightarrow>\n    (case (x, y) of (x, y) \\<Rightarrow> f (Edge x y, Vertex y)) = 0", "have \"\\<dots> = d_OUT f (Edge x y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN f (Edge x y) = d_OUT f (Edge x y)", "by(simp add: flowD_KIR[OF f])"], ["proof (state)\nthis:\n  d_IN f (Edge x y) = d_OUT f (Edge x y)\n\ngoal (2 subgoals):\n 1. Edge x y \\<in> S \\<Longrightarrow>\n    (case (x, y) of (x, y) \\<Rightarrow> f (Edge x y, Vertex y)) = 0\n 2. Edge x y \\<notin> S \\<Longrightarrow>\n    (case (x, y) of (x, y) \\<Rightarrow> f (Edge x y, Vertex y)) = 0", "also"], ["proof (state)\nthis:\n  d_IN f (Edge x y) = d_OUT f (Edge x y)\n\ngoal (2 subgoals):\n 1. Edge x y \\<in> S \\<Longrightarrow>\n    (case (x, y) of (x, y) \\<Rightarrow> f (Edge x y, Vertex y)) = 0\n 2. Edge x y \\<notin> S \\<Longrightarrow>\n    (case (x, y) of (x, y) \\<Rightarrow> f (Edge x y, Vertex y)) = 0", "have \"\\<dots> = f (Edge x y, Vertex y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT f (Edge x y) = f (Edge x y, Vertex y)", "using edge"], ["proof (prove)\nusing this:\n  edge \\<Delta> x y\n\ngoal (1 subgoal):\n 1. d_OUT f (Edge x y) = f (Edge x y, Vertex y)", "by(simp add: d_OUT_Edge[OF f])"], ["proof (state)\nthis:\n  d_OUT f (Edge x y) = f (Edge x y, Vertex y)\n\ngoal (2 subgoals):\n 1. Edge x y \\<in> S \\<Longrightarrow>\n    (case (x, y) of (x, y) \\<Rightarrow> f (Edge x y, Vertex y)) = 0\n 2. Edge x y \\<notin> S \\<Longrightarrow>\n    (case (x, y) of (x, y) \\<Rightarrow> f (Edge x y, Vertex y)) = 0", "finally"], ["proof (chain)\npicking this:\n  0 = f (Edge x y, Vertex y)", "show ?thesis"], ["proof (prove)\nusing this:\n  0 = f (Edge x y, Vertex y)\n\ngoal (1 subgoal):\n 1. (case (x, y) of (x, y) \\<Rightarrow> f (Edge x y, Vertex y)) = 0", "by simp"], ["proof (state)\nthis:\n  (case (x, y) of (x, y) \\<Rightarrow> f (Edge x y, Vertex y)) = 0\n\ngoal (1 subgoal):\n 1. Edge x y \\<notin> S \\<Longrightarrow>\n    (case (x, y) of (x, y) \\<Rightarrow> f (Edge x y, Vertex y)) = 0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. Edge x y \\<notin> S \\<Longrightarrow>\n    (case (x, y) of (x, y) \\<Rightarrow> f (Edge x y, Vertex y)) = 0", "case False"], ["proof (state)\nthis:\n  Edge x y \\<notin> S\n\ngoal (1 subgoal):\n 1. Edge x y \\<notin> S \\<Longrightarrow>\n    (case (x, y) of (x, y) \\<Rightarrow> f (Edge x y, Vertex y)) = 0", "from y"], ["proof (chain)\npicking this:\n  y \\<in> Vertex -` S", "have \"Vertex y \\<in> S\""], ["proof (prove)\nusing this:\n  y \\<in> Vertex -` S\n\ngoal (1 subgoal):\n 1. Vertex y \\<in> S", "by auto"], ["proof (state)\nthis:\n  Vertex y \\<in> S\n\ngoal (1 subgoal):\n 1. Edge x y \\<notin> S \\<Longrightarrow>\n    (case (x, y) of (x, y) \\<Rightarrow> f (Edge x y, Vertex y)) = 0", "from orthogonalD_in[OF ortho _ False this] edge"], ["proof (chain)\npicking this:\n  edge \\<Delta>'' (Edge x y) (Vertex y) \\<Longrightarrow>\n  f (Edge x y, Vertex y) = 0\n  edge \\<Delta> x y", "show ?thesis"], ["proof (prove)\nusing this:\n  edge \\<Delta>'' (Edge x y) (Vertex y) \\<Longrightarrow>\n  f (Edge x y, Vertex y) = 0\n  edge \\<Delta> x y\n\ngoal (1 subgoal):\n 1. (case (x, y) of (x, y) \\<Rightarrow> f (Edge x y, Vertex y)) = 0", "by simp"], ["proof (state)\nthis:\n  (case (x, y) of (x, y) \\<Rightarrow> f (Edge x y, Vertex y)) = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>edge \\<Delta> ?x ?y; ?x \\<notin> Vertex -` S;\n   ?y \\<in> Vertex -` S\\<rbrakk>\n  \\<Longrightarrow> (case (?x, ?y) of\n                     (x, y) \\<Rightarrow> f (Edge x y, Vertex y)) =\n                    0\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "context countable_network begin"], ["", "lemma countable_web_web_of_network: \n  assumes source_in: \"\\<And>x. \\<not> edge \\<Delta> x (source \\<Delta>)\"\n  and sink_out: \"\\<And>y. \\<not> edge \\<Delta> (sink \\<Delta>) y\"\n  and undead: \"\\<And>x y. edge \\<Delta> x y \\<Longrightarrow> (\\<exists>z. edge \\<Delta> y z) \\<or> (\\<exists>z. edge \\<Delta> z x)\"\n  and source_sink: \"\\<not> edge \\<Delta> (source \\<Delta>) (sink \\<Delta>)\"\n  and no_loop: \"\\<And>x. \\<not> edge \\<Delta> x x\"\n  shows \"countable_web (web_of_network \\<Delta>)\" (is \"countable_web ?\\<Gamma>\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. countable_web (web_of_network \\<Delta>)", "proof"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>x y.\n       x \\<in> A (web_of_network \\<Delta>) \\<Longrightarrow>\n       \\<not> edge (web_of_network \\<Delta>) y x\n 2. \\<And>x y.\n       x \\<in> B (web_of_network \\<Delta>) \\<Longrightarrow>\n       \\<not> edge (web_of_network \\<Delta>) x y\n 3. A (web_of_network \\<Delta>)\n    \\<subseteq> \\<^bold>V\\<^bsub>web_of_network \\<Delta>\\<^esub>\n 4. A (web_of_network \\<Delta>) \\<inter> B (web_of_network \\<Delta>) = {}\n 5. \\<And>x. \\<not> edge (web_of_network \\<Delta>) x x\n 6. \\<And>x.\n       x \\<notin> \\<^bold>V\\<^bsub>web_of_network \\<Delta>\\<^esub> \\<Longrightarrow>\n       weight (web_of_network \\<Delta>) x = 0\n 7. \\<And>x. weight (web_of_network \\<Delta>) x \\<noteq> \\<top>\n 8. countable \\<^bold>E\\<^bsub>web_of_network \\<Delta>\\<^esub>", "show \"\\<not> edge ?\\<Gamma> y x\" if \"x \\<in> A ?\\<Gamma>\" for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> edge (web_of_network \\<Delta>) y x", "using that"], ["proof (prove)\nusing this:\n  x \\<in> A (web_of_network \\<Delta>)\n\ngoal (1 subgoal):\n 1. \\<not> edge (web_of_network \\<Delta>) y x", "by(clarsimp simp add: source_in)"], ["proof (state)\nthis:\n  ?x \\<in> A (web_of_network \\<Delta>) \\<Longrightarrow>\n  \\<not> edge (web_of_network \\<Delta>) ?y ?x\n\ngoal (7 subgoals):\n 1. \\<And>x y.\n       x \\<in> B (web_of_network \\<Delta>) \\<Longrightarrow>\n       \\<not> edge (web_of_network \\<Delta>) x y\n 2. A (web_of_network \\<Delta>)\n    \\<subseteq> \\<^bold>V\\<^bsub>web_of_network \\<Delta>\\<^esub>\n 3. A (web_of_network \\<Delta>) \\<inter> B (web_of_network \\<Delta>) = {}\n 4. \\<And>x. \\<not> edge (web_of_network \\<Delta>) x x\n 5. \\<And>x.\n       x \\<notin> \\<^bold>V\\<^bsub>web_of_network \\<Delta>\\<^esub> \\<Longrightarrow>\n       weight (web_of_network \\<Delta>) x = 0\n 6. \\<And>x. weight (web_of_network \\<Delta>) x \\<noteq> \\<top>\n 7. countable \\<^bold>E\\<^bsub>web_of_network \\<Delta>\\<^esub>", "show \"\\<not> edge ?\\<Gamma> x y\" if \"x \\<in> B ?\\<Gamma>\" for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> edge (web_of_network \\<Delta>) x y", "using that"], ["proof (prove)\nusing this:\n  x \\<in> B (web_of_network \\<Delta>)\n\ngoal (1 subgoal):\n 1. \\<not> edge (web_of_network \\<Delta>) x y", "by(clarsimp simp add: sink_out)"], ["proof (state)\nthis:\n  ?x \\<in> B (web_of_network \\<Delta>) \\<Longrightarrow>\n  \\<not> edge (web_of_network \\<Delta>) ?x ?y\n\ngoal (6 subgoals):\n 1. A (web_of_network \\<Delta>)\n    \\<subseteq> \\<^bold>V\\<^bsub>web_of_network \\<Delta>\\<^esub>\n 2. A (web_of_network \\<Delta>) \\<inter> B (web_of_network \\<Delta>) = {}\n 3. \\<And>x. \\<not> edge (web_of_network \\<Delta>) x x\n 4. \\<And>x.\n       x \\<notin> \\<^bold>V\\<^bsub>web_of_network \\<Delta>\\<^esub> \\<Longrightarrow>\n       weight (web_of_network \\<Delta>) x = 0\n 5. \\<And>x. weight (web_of_network \\<Delta>) x \\<noteq> \\<top>\n 6. countable \\<^bold>E\\<^bsub>web_of_network \\<Delta>\\<^esub>", "show \"A ?\\<Gamma> \\<subseteq> \\<^bold>V\\<^bsub>?\\<Gamma>\\<^esub>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A (web_of_network \\<Delta>)\n    \\<subseteq> \\<^bold>V\\<^bsub>web_of_network \\<Delta>\\<^esub>", "by(auto 4 3 dest: undead)"], ["proof (state)\nthis:\n  A (web_of_network \\<Delta>)\n  \\<subseteq> \\<^bold>V\\<^bsub>web_of_network \\<Delta>\\<^esub>\n\ngoal (5 subgoals):\n 1. A (web_of_network \\<Delta>) \\<inter> B (web_of_network \\<Delta>) = {}\n 2. \\<And>x. \\<not> edge (web_of_network \\<Delta>) x x\n 3. \\<And>x.\n       x \\<notin> \\<^bold>V\\<^bsub>web_of_network \\<Delta>\\<^esub> \\<Longrightarrow>\n       weight (web_of_network \\<Delta>) x = 0\n 4. \\<And>x. weight (web_of_network \\<Delta>) x \\<noteq> \\<top>\n 5. countable \\<^bold>E\\<^bsub>web_of_network \\<Delta>\\<^esub>", "show \"A ?\\<Gamma> \\<inter> B ?\\<Gamma> = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A (web_of_network \\<Delta>) \\<inter> B (web_of_network \\<Delta>) = {}", "using source_sink"], ["proof (prove)\nusing this:\n  \\<not> edge \\<Delta> (source \\<Delta>) (sink \\<Delta>)\n\ngoal (1 subgoal):\n 1. A (web_of_network \\<Delta>) \\<inter> B (web_of_network \\<Delta>) = {}", "by auto"], ["proof (state)\nthis:\n  A (web_of_network \\<Delta>) \\<inter> B (web_of_network \\<Delta>) = {}\n\ngoal (4 subgoals):\n 1. \\<And>x. \\<not> edge (web_of_network \\<Delta>) x x\n 2. \\<And>x.\n       x \\<notin> \\<^bold>V\\<^bsub>web_of_network \\<Delta>\\<^esub> \\<Longrightarrow>\n       weight (web_of_network \\<Delta>) x = 0\n 3. \\<And>x. weight (web_of_network \\<Delta>) x \\<noteq> \\<top>\n 4. countable \\<^bold>E\\<^bsub>web_of_network \\<Delta>\\<^esub>", "show \"\\<not> edge ?\\<Gamma> x x\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> edge (web_of_network \\<Delta>) x x", "by(auto simp add: no_loop)"], ["proof (state)\nthis:\n  \\<not> edge (web_of_network \\<Delta>) ?x ?x\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       x \\<notin> \\<^bold>V\\<^bsub>web_of_network \\<Delta>\\<^esub> \\<Longrightarrow>\n       weight (web_of_network \\<Delta>) x = 0\n 2. \\<And>x. weight (web_of_network \\<Delta>) x \\<noteq> \\<top>\n 3. countable \\<^bold>E\\<^bsub>web_of_network \\<Delta>\\<^esub>", "show \"weight ?\\<Gamma> x = 0\" if \"x \\<notin> \\<^bold>V\\<^bsub>?\\<Gamma>\\<^esub>\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. weight (web_of_network \\<Delta>) x = 0", "using that undead"], ["proof (prove)\nusing this:\n  x \\<notin> \\<^bold>V\\<^bsub>web_of_network \\<Delta>\\<^esub>\n  edge \\<Delta> ?x ?y \\<Longrightarrow>\n  (\\<exists>z. edge \\<Delta> ?y z) \\<or> (\\<exists>z. edge \\<Delta> z ?x)\n\ngoal (1 subgoal):\n 1. weight (web_of_network \\<Delta>) x = 0", "by(cases x)(auto intro!: capacity_outside)"], ["proof (state)\nthis:\n  ?x \\<notin> \\<^bold>V\\<^bsub>web_of_network \\<Delta>\\<^esub> \\<Longrightarrow>\n  weight (web_of_network \\<Delta>) ?x = 0\n\ngoal (2 subgoals):\n 1. \\<And>x. weight (web_of_network \\<Delta>) x \\<noteq> \\<top>\n 2. countable \\<^bold>E\\<^bsub>web_of_network \\<Delta>\\<^esub>", "show \"weight ?\\<Gamma> x \\<noteq> \\<top>\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. weight (web_of_network \\<Delta>) x \\<noteq> \\<top>", "using capacity_finite[of x]"], ["proof (prove)\nusing this:\n  capacity \\<Delta> x \\<noteq> \\<top>\n\ngoal (1 subgoal):\n 1. weight (web_of_network \\<Delta>) x \\<noteq> \\<top>", "by(cases x) simp"], ["proof (state)\nthis:\n  weight (web_of_network \\<Delta>) ?x \\<noteq> \\<top>\n\ngoal (1 subgoal):\n 1. countable \\<^bold>E\\<^bsub>web_of_network \\<Delta>\\<^esub>", "have \"\\<^bold>E\\<^bsub>?\\<Gamma>\\<^esub> \\<subseteq> \\<^bold>E \\<times> \\<^bold>E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<^bold>E\\<^bsub>web_of_network \\<Delta>\\<^esub>\n    \\<subseteq> \\<^bold>E \\<times> \\<^bold>E", "by auto"], ["proof (state)\nthis:\n  \\<^bold>E\\<^bsub>web_of_network \\<Delta>\\<^esub>\n  \\<subseteq> \\<^bold>E \\<times> \\<^bold>E\n\ngoal (1 subgoal):\n 1. countable \\<^bold>E\\<^bsub>web_of_network \\<Delta>\\<^esub>", "thus \"countable \\<^bold>E\\<^bsub>?\\<Gamma>\\<^esub>\""], ["proof (prove)\nusing this:\n  \\<^bold>E\\<^bsub>web_of_network \\<Delta>\\<^esub>\n  \\<subseteq> \\<^bold>E \\<times> \\<^bold>E\n\ngoal (1 subgoal):\n 1. countable \\<^bold>E\\<^bsub>web_of_network \\<Delta>\\<^esub>", "by(rule countable_subset)(simp)"], ["proof (state)\nthis:\n  countable \\<^bold>E\\<^bsub>web_of_network \\<Delta>\\<^esub>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma max_flow_min_cut':\n  assumes ex_orthogonal_current: \" \\<exists>f S. web_flow (web_of_network \\<Delta>) f \\<and> separating (web_of_network \\<Delta>) S \\<and> orthogonal_current (web_of_network \\<Delta>) f S\"\n  and source_in: \"\\<And>x. \\<not> edge \\<Delta> x (source \\<Delta>)\"\n  and sink_out: \"\\<And>y. \\<not> edge \\<Delta> (sink \\<Delta>) y\"\n  and undead: \"\\<And>x y. edge \\<Delta> x y \\<Longrightarrow> (\\<exists>z. edge \\<Delta> y z) \\<or> (\\<exists>z. edge \\<Delta> z x)\"\n  and source_sink: \"\\<not> edge \\<Delta> (source \\<Delta>) (sink \\<Delta>)\"\n  and no_loop: \"\\<And>x. \\<not> edge \\<Delta> x x\"\n  and capacity_pos: \"\\<And>e. e \\<in> \\<^bold>E \\<Longrightarrow> capacity \\<Delta> e > 0\"\n  shows \"\\<exists>f S. flow \\<Delta> f \\<and> cut \\<Delta> S \\<and> orthogonal \\<Delta> f S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>f S.\n       flow \\<Delta> f \\<and> cut \\<Delta> S \\<and> orthogonal \\<Delta> f S", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>f S.\n       flow \\<Delta> f \\<and> cut \\<Delta> S \\<and> orthogonal \\<Delta> f S", "let ?\\<Gamma> = \"web_of_network \\<Delta>\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>f S.\n       flow \\<Delta> f \\<and> cut \\<Delta> S \\<and> orthogonal \\<Delta> f S", "from ex_orthogonal_current"], ["proof (chain)\npicking this:\n  \\<exists>f S.\n     web_flow (web_of_network \\<Delta>) f \\<and>\n     separating (web_of_network \\<Delta>) S \\<and>\n     orthogonal_current (web_of_network \\<Delta>) f S", "obtain f S\n    where f: \"web_flow (web_of_network \\<Delta>) f\"\n    and S: \"separating (web_of_network \\<Delta>) S\"\n    and ortho: \"orthogonal_current (web_of_network \\<Delta>) f S\""], ["proof (prove)\nusing this:\n  \\<exists>f S.\n     web_flow (web_of_network \\<Delta>) f \\<and>\n     separating (web_of_network \\<Delta>) S \\<and>\n     orthogonal_current (web_of_network \\<Delta>) f S\n\ngoal (1 subgoal):\n 1. (\\<And>f S.\n        \\<lbrakk>web_flow (web_of_network \\<Delta>) f;\n         separating (web_of_network \\<Delta>) S;\n         orthogonal_current (web_of_network \\<Delta>) f S\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast+"], ["proof (state)\nthis:\n  web_flow (web_of_network \\<Delta>) f\n  separating (web_of_network \\<Delta>) S\n  orthogonal_current (web_of_network \\<Delta>) f S\n\ngoal (1 subgoal):\n 1. \\<exists>f S.\n       flow \\<Delta> f \\<and> cut \\<Delta> S \\<and> orthogonal \\<Delta> f S", "let ?f = \"flow_of_current \\<Delta> f\" and ?S = \"cut_of_sep \\<Delta> S\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>f S.\n       flow \\<Delta> f \\<and> cut \\<Delta> S \\<and> orthogonal \\<Delta> f S", "from f"], ["proof (chain)\npicking this:\n  web_flow (web_of_network \\<Delta>) f", "have \"flow \\<Delta> ?f\""], ["proof (prove)\nusing this:\n  web_flow (web_of_network \\<Delta>) f\n\ngoal (1 subgoal):\n 1. flow \\<Delta> (flow_of_current \\<Delta> f)", "by(rule flow_flow_of_current)"], ["proof (state)\nthis:\n  flow \\<Delta> (flow_of_current \\<Delta> f)\n\ngoal (1 subgoal):\n 1. \\<exists>f S.\n       flow \\<Delta> f \\<and> cut \\<Delta> S \\<and> orthogonal \\<Delta> f S", "moreover"], ["proof (state)\nthis:\n  flow \\<Delta> (flow_of_current \\<Delta> f)\n\ngoal (1 subgoal):\n 1. \\<exists>f S.\n       flow \\<Delta> f \\<and> cut \\<Delta> S \\<and> orthogonal \\<Delta> f S", "have \"cut \\<Delta> ?S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cut \\<Delta> (cut_of_sep \\<Delta> S)", "using S source_neq_sink sink_out"], ["proof (prove)\nusing this:\n  separating (web_of_network \\<Delta>) S\n  source \\<Delta> \\<noteq> sink \\<Delta>\n  \\<not> edge \\<Delta> (sink \\<Delta>) ?y\n\ngoal (1 subgoal):\n 1. cut \\<Delta> (cut_of_sep \\<Delta> S)", "by(rule separating_cut)"], ["proof (state)\nthis:\n  cut \\<Delta> (cut_of_sep \\<Delta> S)\n\ngoal (1 subgoal):\n 1. \\<exists>f S.\n       flow \\<Delta> f \\<and> cut \\<Delta> S \\<and> orthogonal \\<Delta> f S", "moreover"], ["proof (state)\nthis:\n  cut \\<Delta> (cut_of_sep \\<Delta> S)\n\ngoal (1 subgoal):\n 1. \\<exists>f S.\n       flow \\<Delta> f \\<and> cut \\<Delta> S \\<and> orthogonal \\<Delta> f S", "have \"orthogonal \\<Delta> ?f ?S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. orthogonal \\<Delta> (flow_of_current \\<Delta> f) (cut_of_sep \\<Delta> S)", "using f ortho S capacity_pos source_neq_sink sink_out source_sink"], ["proof (prove)\nusing this:\n  web_flow (web_of_network \\<Delta>) f\n  orthogonal_current (web_of_network \\<Delta>) f S\n  separating (web_of_network \\<Delta>) S\n  ?e \\<in> \\<^bold>E \\<Longrightarrow> 0 < capacity \\<Delta> ?e\n  source \\<Delta> \\<noteq> sink \\<Delta>\n  \\<not> edge \\<Delta> (sink \\<Delta>) ?y\n  \\<not> edge \\<Delta> (source \\<Delta>) (sink \\<Delta>)\n\ngoal (1 subgoal):\n 1. orthogonal \\<Delta> (flow_of_current \\<Delta> f) (cut_of_sep \\<Delta> S)", "by(rule orthogonal_flow_of_current)"], ["proof (state)\nthis:\n  orthogonal \\<Delta> (flow_of_current \\<Delta> f) (cut_of_sep \\<Delta> S)\n\ngoal (1 subgoal):\n 1. \\<exists>f S.\n       flow \\<Delta> f \\<and> cut \\<Delta> S \\<and> orthogonal \\<Delta> f S", "ultimately"], ["proof (chain)\npicking this:\n  flow \\<Delta> (flow_of_current \\<Delta> f)\n  cut \\<Delta> (cut_of_sep \\<Delta> S)\n  orthogonal \\<Delta> (flow_of_current \\<Delta> f) (cut_of_sep \\<Delta> S)", "show ?thesis"], ["proof (prove)\nusing this:\n  flow \\<Delta> (flow_of_current \\<Delta> f)\n  cut \\<Delta> (cut_of_sep \\<Delta> S)\n  orthogonal \\<Delta> (flow_of_current \\<Delta> f) (cut_of_sep \\<Delta> S)\n\ngoal (1 subgoal):\n 1. \\<exists>f S.\n       flow \\<Delta> f \\<and> cut \\<Delta> S \\<and> orthogonal \\<Delta> f S", "by blast"], ["proof (state)\nthis:\n  \\<exists>f S.\n     flow \\<Delta> f \\<and> cut \\<Delta> S \\<and> orthogonal \\<Delta> f S\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Eliminating zero edges and incoming edges to @{term source} and outgoing edges of @{term sink}\\<close>"], ["", "definition \\<Delta>''' :: \"'v network\" where \"\\<Delta>''' =\n    \\<lparr>edge = \\<lambda>x y. edge \\<Delta> x y \\<and> capacity \\<Delta> (x, y) > 0 \\<and> y \\<noteq> source \\<Delta> \\<and> x \\<noteq> sink \\<Delta>,\n      capacity = \\<lambda>(x, y). if x = sink \\<Delta> \\<or> y = source \\<Delta> then 0 else capacity \\<Delta> (x, y),\n      source = source \\<Delta>,\n      sink = sink \\<Delta>\\<rparr>\""], ["", "lemma \\<Delta>'''_sel [simp]:\n  \"edge \\<Delta>''' x y \\<longleftrightarrow> edge \\<Delta> x y \\<and> capacity \\<Delta> (x, y) > 0 \\<and> y \\<noteq> source \\<Delta> \\<and> x \\<noteq> sink \\<Delta>\"\n  \"capacity \\<Delta>''' (x, y) = (if x = sink \\<Delta> \\<or> y = source \\<Delta> then 0 else capacity \\<Delta> (x, y))\"\n  \"source \\<Delta>''' = source \\<Delta>\"\n  \"sink \\<Delta>''' = sink \\<Delta>\"\n  for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. (edge \\<Delta>''' x y =\n     (edge \\<Delta> x y \\<and>\n      0 < capacity \\<Delta> (x, y) \\<and>\n      y \\<noteq> source \\<Delta> \\<and> x \\<noteq> sink \\<Delta>) &&&\n     capacity \\<Delta>''' (x, y) =\n     (if x = sink \\<Delta> \\<or> y = source \\<Delta> then 0\n      else capacity \\<Delta> (x, y))) &&&\n    source \\<Delta>''' = source \\<Delta> &&&\n    sink \\<Delta>''' = sink \\<Delta>", "by(simp_all add: \\<Delta>'''_def)"], ["", "lemma \\<Delta>'''_countable_network: \"countable_network \\<Delta>'''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. countable_network \\<Delta>'''", "proof(unfold_locales)"], ["proof (state)\ngoal (4 subgoals):\n 1. countable \\<^bold>E\\<^bsub>\\<Delta>'''\\<^esub>\n 2. source \\<Delta>''' \\<noteq> sink \\<Delta>'''\n 3. \\<And>e.\n       e \\<notin> \\<^bold>E\\<^bsub>\\<Delta>'''\\<^esub> \\<Longrightarrow>\n       capacity \\<Delta>''' e = 0\n 4. \\<And>e. capacity \\<Delta>''' e \\<noteq> \\<top>", "have \"\\<^bold>E\\<^bsub>\\<Delta>'''\\<^esub> \\<subseteq> \\<^bold>E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<^bold>E\\<^bsub>\\<Delta>'''\\<^esub> \\<subseteq> \\<^bold>E", "by auto"], ["proof (state)\nthis:\n  \\<^bold>E\\<^bsub>\\<Delta>'''\\<^esub> \\<subseteq> \\<^bold>E\n\ngoal (4 subgoals):\n 1. countable \\<^bold>E\\<^bsub>\\<Delta>'''\\<^esub>\n 2. source \\<Delta>''' \\<noteq> sink \\<Delta>'''\n 3. \\<And>e.\n       e \\<notin> \\<^bold>E\\<^bsub>\\<Delta>'''\\<^esub> \\<Longrightarrow>\n       capacity \\<Delta>''' e = 0\n 4. \\<And>e. capacity \\<Delta>''' e \\<noteq> \\<top>", "then"], ["proof (chain)\npicking this:\n  \\<^bold>E\\<^bsub>\\<Delta>'''\\<^esub> \\<subseteq> \\<^bold>E", "show \"countable \\<^bold>E\\<^bsub>\\<Delta>'''\\<^esub>\""], ["proof (prove)\nusing this:\n  \\<^bold>E\\<^bsub>\\<Delta>'''\\<^esub> \\<subseteq> \\<^bold>E\n\ngoal (1 subgoal):\n 1. countable \\<^bold>E\\<^bsub>\\<Delta>'''\\<^esub>", "by(rule countable_subset) simp"], ["proof (state)\nthis:\n  countable \\<^bold>E\\<^bsub>\\<Delta>'''\\<^esub>\n\ngoal (3 subgoals):\n 1. source \\<Delta>''' \\<noteq> sink \\<Delta>'''\n 2. \\<And>e.\n       e \\<notin> \\<^bold>E\\<^bsub>\\<Delta>'''\\<^esub> \\<Longrightarrow>\n       capacity \\<Delta>''' e = 0\n 3. \\<And>e. capacity \\<Delta>''' e \\<noteq> \\<top>", "show \"capacity \\<Delta>''' e = 0\" if \"e \\<notin> \\<^bold>E\\<^bsub>\\<Delta>'''\\<^esub>\" for e"], ["proof (prove)\ngoal (1 subgoal):\n 1. capacity \\<Delta>''' e = 0", "using capacity_outside[of e] that"], ["proof (prove)\nusing this:\n  e \\<notin> \\<^bold>E \\<Longrightarrow> capacity \\<Delta> e = 0\n  e \\<notin> \\<^bold>E\\<^bsub>\\<Delta>'''\\<^esub>\n\ngoal (1 subgoal):\n 1. capacity \\<Delta>''' e = 0", "by(auto split: if_split_asm intro: ccontr)"], ["proof (state)\nthis:\n  ?e \\<notin> \\<^bold>E\\<^bsub>\\<Delta>'''\\<^esub> \\<Longrightarrow>\n  capacity \\<Delta>''' ?e = 0\n\ngoal (2 subgoals):\n 1. source \\<Delta>''' \\<noteq> sink \\<Delta>'''\n 2. \\<And>e. capacity \\<Delta>''' e \\<noteq> \\<top>", "qed(auto simp add: split: if_split_asm)"], ["", "lemma flow_\\<Delta>''':\n  assumes f: \"flow \\<Delta>''' f\" and cut: \"cut \\<Delta>''' S\" and ortho: \"orthogonal \\<Delta>''' f S\"\n    shows \"flow \\<Delta> f\" \"cut \\<Delta> S\" \"orthogonal \\<Delta> f S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. flow \\<Delta> f &&& cut \\<Delta> S &&& orthogonal \\<Delta> f S", "proof -"], ["proof (state)\ngoal (3 subgoals):\n 1. flow \\<Delta> f\n 2. cut \\<Delta> S\n 3. orthogonal \\<Delta> f S", "interpret \\<Delta>''': countable_network \\<Delta>'''"], ["proof (prove)\ngoal (1 subgoal):\n 1. countable_network \\<Delta>'''", "by(rule \\<Delta>'''_countable_network)"], ["proof (state)\ngoal (3 subgoals):\n 1. flow \\<Delta> f\n 2. cut \\<Delta> S\n 3. orthogonal \\<Delta> f S", "show \"flow \\<Delta> f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. flow \\<Delta> f", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>e. f e \\<le> capacity \\<Delta> e\n 2. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>;\n        x \\<noteq> sink \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> KIR f x", "show \"f e \\<le> capacity \\<Delta> e\" for e"], ["proof (prove)\ngoal (1 subgoal):\n 1. f e \\<le> capacity \\<Delta> e", "using flowD_capacity[OF f, of e]"], ["proof (prove)\nusing this:\n  f e \\<le> capacity \\<Delta>''' e\n\ngoal (1 subgoal):\n 1. f e \\<le> capacity \\<Delta> e", "by(cases e)(simp split: if_split_asm)"], ["proof (state)\nthis:\n  f ?e \\<le> capacity \\<Delta> ?e\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>;\n        x \\<noteq> sink \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> KIR f x", "show \"KIR f x\" if \"x \\<noteq> source \\<Delta>\" \"x \\<noteq> sink \\<Delta>\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. KIR f x", "using flowD_KIR[OF f, of x] that"], ["proof (prove)\nusing this:\n  \\<lbrakk>x \\<noteq> source \\<Delta>''';\n   x \\<noteq> sink \\<Delta>'''\\<rbrakk>\n  \\<Longrightarrow> KIR f x\n  x \\<noteq> source \\<Delta>\n  x \\<noteq> sink \\<Delta>\n\ngoal (1 subgoal):\n 1. KIR f x", "by simp"], ["proof (state)\nthis:\n  \\<lbrakk>?x \\<noteq> source \\<Delta>; ?x \\<noteq> sink \\<Delta>\\<rbrakk>\n  \\<Longrightarrow> KIR f ?x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  flow \\<Delta> f\n\ngoal (2 subgoals):\n 1. cut \\<Delta> S\n 2. orthogonal \\<Delta> f S", "show \"cut \\<Delta> S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cut \\<Delta> S", "using cut"], ["proof (prove)\nusing this:\n  cut \\<Delta>''' S\n\ngoal (1 subgoal):\n 1. cut \\<Delta> S", "by(simp add: cut.simps)"], ["proof (state)\nthis:\n  cut \\<Delta> S\n\ngoal (1 subgoal):\n 1. orthogonal \\<Delta> f S", "show \"orthogonal \\<Delta> f S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. orthogonal \\<Delta> f S", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>edge \\<Delta> x y; x \\<in> S; y \\<notin> S\\<rbrakk>\n       \\<Longrightarrow> f (x, y) = capacity \\<Delta> (x, y)\n 2. \\<And>x y.\n       \\<lbrakk>edge \\<Delta> x y; x \\<notin> S; y \\<in> S\\<rbrakk>\n       \\<Longrightarrow> f (x, y) = 0", "show \"f (x, y) = capacity \\<Delta> (x, y)\" if edge: \"edge \\<Delta> x y\" and x: \"x \\<in> S\" and y: \"y \\<notin> S\" for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. f (x, y) = capacity \\<Delta> (x, y)", "proof(cases \"edge \\<Delta>''' x y\")"], ["proof (state)\ngoal (2 subgoals):\n 1. edge \\<Delta>''' x y \\<Longrightarrow>\n    f (x, y) = capacity \\<Delta> (x, y)\n 2. \\<not> edge \\<Delta>''' x y \\<Longrightarrow>\n    f (x, y) = capacity \\<Delta> (x, y)", "case True"], ["proof (state)\nthis:\n  edge \\<Delta>''' x y\n\ngoal (2 subgoals):\n 1. edge \\<Delta>''' x y \\<Longrightarrow>\n    f (x, y) = capacity \\<Delta> (x, y)\n 2. \\<not> edge \\<Delta>''' x y \\<Longrightarrow>\n    f (x, y) = capacity \\<Delta> (x, y)", "with orthogonalD_out[OF ortho this x y]"], ["proof (chain)\npicking this:\n  f (x, y) = capacity \\<Delta>''' (x, y)\n  edge \\<Delta>''' x y", "show ?thesis"], ["proof (prove)\nusing this:\n  f (x, y) = capacity \\<Delta>''' (x, y)\n  edge \\<Delta>''' x y\n\ngoal (1 subgoal):\n 1. f (x, y) = capacity \\<Delta> (x, y)", "by simp"], ["proof (state)\nthis:\n  f (x, y) = capacity \\<Delta> (x, y)\n\ngoal (1 subgoal):\n 1. \\<not> edge \\<Delta>''' x y \\<Longrightarrow>\n    f (x, y) = capacity \\<Delta> (x, y)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> edge \\<Delta>''' x y \\<Longrightarrow>\n    f (x, y) = capacity \\<Delta> (x, y)", "case False"], ["proof (state)\nthis:\n  \\<not> edge \\<Delta>''' x y\n\ngoal (1 subgoal):\n 1. \\<not> edge \\<Delta>''' x y \\<Longrightarrow>\n    f (x, y) = capacity \\<Delta> (x, y)", "from cut y x"], ["proof (chain)\npicking this:\n  cut \\<Delta>''' S\n  y \\<notin> S\n  x \\<in> S", "have xy: \"y \\<noteq> source \\<Delta> \\<and> x \\<noteq> sink \\<Delta>\""], ["proof (prove)\nusing this:\n  cut \\<Delta>''' S\n  y \\<notin> S\n  x \\<in> S\n\ngoal (1 subgoal):\n 1. y \\<noteq> source \\<Delta> \\<and> x \\<noteq> sink \\<Delta>", "by(cases) auto"], ["proof (state)\nthis:\n  y \\<noteq> source \\<Delta> \\<and> x \\<noteq> sink \\<Delta>\n\ngoal (1 subgoal):\n 1. \\<not> edge \\<Delta>''' x y \\<Longrightarrow>\n    f (x, y) = capacity \\<Delta> (x, y)", "with xy edge False"], ["proof (chain)\npicking this:\n  y \\<noteq> source \\<Delta> \\<and> x \\<noteq> sink \\<Delta>\n  edge \\<Delta> x y\n  \\<not> edge \\<Delta>''' x y\n  y \\<noteq> source \\<Delta> \\<and> x \\<noteq> sink \\<Delta>", "have \"capacity \\<Delta> (x, y) = 0\""], ["proof (prove)\nusing this:\n  y \\<noteq> source \\<Delta> \\<and> x \\<noteq> sink \\<Delta>\n  edge \\<Delta> x y\n  \\<not> edge \\<Delta>''' x y\n  y \\<noteq> source \\<Delta> \\<and> x \\<noteq> sink \\<Delta>\n\ngoal (1 subgoal):\n 1. capacity \\<Delta> (x, y) = 0", "by simp"], ["proof (state)\nthis:\n  capacity \\<Delta> (x, y) = 0\n\ngoal (1 subgoal):\n 1. \\<not> edge \\<Delta>''' x y \\<Longrightarrow>\n    f (x, y) = capacity \\<Delta> (x, y)", "with \\<Delta>'''.flowD_outside[OF f, of \"(x, y)\"] False"], ["proof (chain)\npicking this:\n  (x, y) \\<notin> \\<^bold>E\\<^bsub>\\<Delta>'''\\<^esub> \\<Longrightarrow>\n  f (x, y) = 0\n  \\<not> edge \\<Delta>''' x y\n  capacity \\<Delta> (x, y) = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  (x, y) \\<notin> \\<^bold>E\\<^bsub>\\<Delta>'''\\<^esub> \\<Longrightarrow>\n  f (x, y) = 0\n  \\<not> edge \\<Delta>''' x y\n  capacity \\<Delta> (x, y) = 0\n\ngoal (1 subgoal):\n 1. f (x, y) = capacity \\<Delta> (x, y)", "by simp"], ["proof (state)\nthis:\n  f (x, y) = capacity \\<Delta> (x, y)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>edge \\<Delta> ?x ?y; ?x \\<in> S; ?y \\<notin> S\\<rbrakk>\n  \\<Longrightarrow> f (?x, ?y) = capacity \\<Delta> (?x, ?y)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>edge \\<Delta> x y; x \\<notin> S; y \\<in> S\\<rbrakk>\n       \\<Longrightarrow> f (x, y) = 0", "show \"f (x, y) = 0\" if edge: \"edge \\<Delta> x y\" and x: \"x \\<notin> S\" and y: \"y \\<in> S\" for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. f (x, y) = 0", "using orthogonalD_in[OF ortho _ x y] \\<Delta>'''.flowD_outside[OF f, of \"(x, y)\"]"], ["proof (prove)\nusing this:\n  edge \\<Delta>''' x y \\<Longrightarrow> f (x, y) = 0\n  (x, y) \\<notin> \\<^bold>E\\<^bsub>\\<Delta>'''\\<^esub> \\<Longrightarrow>\n  f (x, y) = 0\n\ngoal (1 subgoal):\n 1. f (x, y) = 0", "by(cases \"edge \\<Delta>''' x y\")simp_all"], ["proof (state)\nthis:\n  \\<lbrakk>edge \\<Delta> ?x ?y; ?x \\<notin> S; ?y \\<in> S\\<rbrakk>\n  \\<Longrightarrow> f (?x, ?y) = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  orthogonal \\<Delta> f S\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "end"]]}