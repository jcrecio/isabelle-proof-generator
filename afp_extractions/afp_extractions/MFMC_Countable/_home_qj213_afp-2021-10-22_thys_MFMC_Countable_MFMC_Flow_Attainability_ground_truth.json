{"file_name": "/home/qj213/afp-2021-10-22/thys/MFMC_Countable/MFMC_Flow_Attainability.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/MFMC_Countable", "problem_names": ["lemma cleanup_simps [simp]:\n  \"cleanup f (a, b) = (if f (a, b) > f (b, a) then f (a, b) - f (b, a) else 0)\"", "lemma value_flow_cleanup:\n  assumes [simp]: \"\\<And>x. f (x, source \\<Delta>) = 0\"\n  shows \"value_flow \\<Delta> (cleanup f) = value_flow \\<Delta> f\"", "lemma KIR_cleanup:\n  assumes KIR: \"KIR f x\"\n  and finite_IN: \"d_IN f x \\<noteq> \\<top>\"\n  shows \"KIR (cleanup f) x\"", "lemma source_in_not_cycle:\n  assumes \"cycle \\<Delta> p\"\n  shows \"(x, source \\<Delta>) \\<notin> set (cycle_edges p)\"", "lemma source_out_not_cycle:\n  \"cycle \\<Delta> p \\<Longrightarrow> (source \\<Delta>, x) \\<notin> set (cycle_edges p)\"", "lemma flowD_source_IN:\n  assumes \"flow \\<Delta> f\"\n  shows \"d_IN f (source \\<Delta>) = 0\"", "lemma flowD_finite_IN:\n  assumes f: \"flow \\<Delta> f\" and x: \"x \\<noteq> sink \\<Delta>\"\n  shows \"d_IN f x \\<noteq> top\"", "lemma flowD_finite_OUT:\n  assumes \"flow \\<Delta> f\" \"x \\<noteq> source \\<Delta>\" \"x \\<noteq> sink \\<Delta>\"\n  shows \"d_OUT f x \\<noteq> \\<top>\"", "lemma g_outside: \"e \\<notin> \\<^bold>E \\<Longrightarrow> g e = 0\"", "lemma g_loop [simp]: \"g (x, x) = 0\"", "lemma finite_IN_g: \"x \\<noteq> sink \\<Delta> \\<Longrightarrow> d_IN g x \\<noteq> top\"", "lemma finite_OUT_g:\n  assumes \"x \\<noteq> sink \\<Delta>\"\n  shows \"d_OUT g x \\<noteq> top\"", "lemma g_source_in [simp]: \"g (x, source \\<Delta>) = 0\"", "lemma finite_g [simp]: \"g e \\<noteq> top\"", "lemma range_enum_v: \"range enum_v \\<subseteq> \\<^bold>V - {source \\<Delta>, sink \\<Delta>}\"", "lemma enum_v_repeat:\n  assumes x: \"x \\<in> \\<^bold>V\" \"x \\<noteq> source \\<Delta>\" \"x \\<noteq> sink \\<Delta>\"\n  shows \"\\<exists>i'>i. enum_v i' = x\"", "lemma h_plus_le_g: \"h_plus i e \\<le> g e\"", "lemma h_plus_outside: \"e \\<notin> \\<^bold>E \\<Longrightarrow> h_plus i e = 0\"", "lemma h_plus_not_infty [simp]: \"h_plus i e \\<noteq> top\"", "lemma h_plus_mono: \"h_plus i e \\<le> h_plus (Suc i) e\"", "lemma h_plus_mono': \"i \\<le> j \\<Longrightarrow> h_plus i e \\<le> h_plus j e\"", "lemma d_OUT_h_plus_not_infty': \"x \\<noteq> sink \\<Delta> \\<Longrightarrow> d_OUT (h_plus i) x \\<noteq> top\"", "lemma h_plus_OUT_le_IN:\n  assumes \"x \\<noteq> source \\<Delta>\"\n  shows \"d_OUT (h_plus i) x \\<le> d_IN (h_plus i) x\"", "lemma h_plus_OUT_eq_IN:\n  assumes enum: \"enum_v (Suc i) = x\"\n  shows \"d_OUT (h_plus (Suc i)) x = d_IN (h_plus i) x\"", "lemma h_plus_source_in [simp]: \"h_plus i (x, source \\<Delta>) = 0\"", "lemma h_plus_sum_finite: \"(\\<Sum>\\<^sup>+ e. h_plus i e) \\<noteq> top\"", "lemma d_OUT_h_plus_not_infty [simp]: \"d_OUT (h_plus i) x \\<noteq> top\"", "lemma cycle_enum_cycle [simp]: \"cycles \\<Delta> \\<noteq> {} \\<Longrightarrow> cycle \\<Delta> (enum_cycle n)\"", "lemma h_minus_aux_le_h': \"h_minus_aux j e \\<le> h' e\"", "lemma h_minus_aux_finite [simp]: \"h_minus_aux j e \\<noteq> top\"", "lemma h_minus_aux_mono: \"h_minus_aux j e \\<le> h_minus_aux (Suc j) e\"", "lemma d_OUT_h_minus_aux:\n  assumes \"cycles \\<Delta> \\<noteq> {}\"\n  shows \"d_OUT (h_minus_aux j) x = d_IN (h_minus_aux j) x\"", "lemma h_minus_aux_source:\n  assumes \"cycles \\<Delta> \\<noteq> {}\"\n  shows \"h_minus_aux j (source \\<Delta>, y) = 0\"", "lemma h_minus_aux_cycle:\n  fixes j defines \"C \\<equiv> enum_cycle j\"\n  assumes \"cycles \\<Delta> \\<noteq> {}\"\n  shows \"\\<exists>e\\<in>set (cycle_edges C). h_minus_aux (Suc j) e = h' e\"", "lemma h_minus_le_h_plus: \"h_minus i e \\<le> h_plus i e\"", "lemma finite_h': \"h_plus (Suc i) e - h_minus i e \\<noteq> top\"", "lemma h_minus_mono: \"h_minus i e \\<le> h_minus (Suc i) e\"", "lemma h_minus_finite [simp]: \"h_minus i e \\<noteq> \\<top>\"", "lemma d_OUT_h_minus:\n  assumes cycles: \"cycles \\<Delta> \\<noteq> {}\"\n  shows \"d_OUT (h_minus i) x = d_IN (h_minus i) x\"", "lemma h_minus_source:\n  assumes \"cycles \\<Delta> \\<noteq> {}\"\n  shows \"h_minus n (source \\<Delta>, y) = 0\"", "lemma h_minus_source_in [simp]: \"h_minus i (x, source \\<Delta>) = 0\"", "lemma h_minus_OUT_finite [simp]: \"d_OUT (h_minus i) x \\<noteq> top\"", "lemma h_minus_cycle:\n  assumes \"cycle \\<Delta> C\"\n  shows \"\\<exists>e\\<in>set (cycle_edges C). h_minus i e = h_plus i e\"", "lemma lim_h_plus_le_g: \"lim_h_plus e \\<le> g e\"", "lemma lim_h_plus_finite [simp]: \"lim_h_plus e \\<noteq> top\"", "lemma lim_h_minus_le_lim_h_plus: \"lim_h_minus e \\<le> lim_h_plus e\"", "lemma lim_h_minus_finite [simp]: \"lim_h_minus e \\<noteq> top\"", "lemma lim_h_minus_IN_finite [simp]:\n  assumes \"x \\<noteq> sink \\<Delta>\"\n  shows \"d_IN lim_h_minus x \\<noteq> top\"", "lemma lim_h_plus_OUT_IN:\n  assumes \"x \\<noteq> source \\<Delta>\" \"x \\<noteq> sink \\<Delta>\"\n  shows \"d_OUT lim_h_plus x = d_IN lim_h_plus x\"", "lemma lim_h_minus_OUT_IN:\n  assumes cycles: \"cycles \\<Delta> \\<noteq> {}\"\n  shows \"d_OUT lim_h_minus x = d_IN lim_h_minus x\"", "lemma h_le_lim_h_plus: \"h e \\<le> lim_h_plus e\"", "lemma h_le_g: \"h e \\<le> g e\"", "lemma flow_h: \"flow \\<Delta> h\"", "lemma value_h_plus: \"value_flow \\<Delta> (h_plus i) = value_flow \\<Delta> g\" (is \"?lhs = ?rhs\")", "lemma value_h: \"value_flow \\<Delta> h = value_flow \\<Delta> g\" (is \"?lhs = ?rhs\")", "lemma d_IN_h_source [simp]: \"d_IN (h_diff i) (source \\<Delta>) = 0\"", "lemma h_diff_le_h_plus: \"h_diff i e \\<le> h_plus i e\"", "lemma h_diff_le_g: \"h_diff i e \\<le> g e\"", "lemma h_diff_loop [simp]: \"h_diff i (x, x) = 0\"", "lemma supp_h_diff_edges: \"support_flow (h_diff i) \\<subseteq> \\<^bold>E\"", "lemma h_diff_OUT_le_IN:\n  assumes \"x \\<noteq> source \\<Delta>\"\n  shows \"d_OUT (h_diff i) x \\<le> d_IN (h_diff i) x\"", "lemma h_diff_cycle:\n  assumes \"cycle \\<Delta> p\"\n  shows \"\\<exists>e\\<in>set (cycle_edges p). h_diff i e = 0\"", "lemma d_IN_h_le_value': \"d_IN (h_diff i) x \\<le> value_flow \\<Delta> (h_plus i)\"", "lemma d_IN_h_le_value: \"d_IN h x \\<le> value_flow \\<Delta> h\" (is \"?lhs \\<le> ?rhs\")", "lemma flow_cleanup: \\<comment> \\<open>Lemma 5.4\\<close>\n  \"\\<exists>h \\<le> g. flow \\<Delta> h \\<and> value_flow \\<Delta> h = value_flow \\<Delta> g \\<and> (\\<forall>x. d_IN h x \\<le> value_flow \\<Delta> h)\"", "lemma residual_network_sel [simp]:\n  \"edge (residual_network f) x y \\<longleftrightarrow> edge \\<Delta> x y \\<or> edge \\<Delta> y x \\<and> y \\<noteq> source \\<Delta>\"\n  \"capacity (residual_network f) (x, y) = (if edge \\<Delta> x y then capacity \\<Delta> (x, y) - f (x, y) else if y = source \\<Delta> then 0 else f (y, x))\"\n  \"source (residual_network f) = source \\<Delta>\"\n  \"sink (residual_network f) = sink \\<Delta>\"\n  \"network.more (residual_network f) = network.more \\<Delta>\"", "lemma \"\\<^bold>E_residual_network\": \"\\<^bold>E\\<^bsub>residual_network f\\<^esub> = \\<^bold>E \\<union> {(x, y). (y, x) \\<in> \\<^bold>E \\<and> y \\<noteq> source \\<Delta>}\"", "lemma vertices_residual_network [simp]: \"vertex (residual_network f) = vertex \\<Delta>\"", "lemma wf_residual_networkD:\n  \"\\<lbrakk> wf_residual_network; edge \\<Delta> x y \\<rbrakk> \\<Longrightarrow> \\<not> edge \\<Delta> y x\"\n  \"\\<lbrakk> wf_residual_network; e \\<in> \\<^bold>E \\<rbrakk> \\<Longrightarrow> prod.swap e \\<notin> \\<^bold>E\"\n  \"\\<lbrakk> wf_residual_network; edge \\<Delta> (source \\<Delta>) (sink \\<Delta>) \\<rbrakk> \\<Longrightarrow> False\"", "lemma residual_countable_network:\n  assumes wf: \"wf_residual_network\"\n  and f: \"flow \\<Delta> f\"\n  shows \"countable_network (residual_network f)\" (is \"countable_network ?\\<Delta>\")", "lemma \\<Delta>''_flow_attainability:\n  assumes \"flow_attainability_axioms \\<Delta>\"\n  shows \"flow_attainability \\<Delta>''\"", "lemma \\<Delta>''_wf_residual_network:\n  assumes no_loop: \"\\<And>x. \\<not> edge \\<Delta> x x\"\n  shows \"\\<Delta>''.wf_residual_network\"", "lemma residual_flow_attainability:\n  assumes wf: \"wf_residual_network\"\n  and f: \"flow \\<Delta> f\"\n  shows \"flow_attainability (residual_network f)\" (is \"flow_attainability ?\\<Delta>\")", "lemma plus_flow_simps [simp]: fixes G (structure) shows\n  \"(f \\<oplus> g) (x, y) = (if edge G x y then f (x, y) + g (x, y) - g (y, x) else 0)\"", "lemma plus_flow_outside: fixes G (structure) shows \"e \\<notin> \\<^bold>E \\<Longrightarrow> (f \\<oplus> g) e = 0\"", "lemma\n  fixes \\<Delta> (structure)\n  assumes f_outside: \"\\<And>e. e \\<notin> \\<^bold>E \\<Longrightarrow> f e = 0\"\n  and g_le_f: \"\\<And>x y. edge \\<Delta> x y \\<Longrightarrow> g (y, x) \\<le> f (x, y)\"\n  shows OUT_plus_flow: \"d_IN g x \\<noteq> top \\<Longrightarrow> d_OUT (f \\<oplus> g) x = d_OUT f x + (\\<Sum>\\<^sup>+ y\\<in>UNIV. g (x, y) * indicator \\<^bold>E (x, y)) - (\\<Sum>\\<^sup>+ y. g (y, x) * indicator \\<^bold>E (x, y))\"\n    (is \"_ \\<Longrightarrow> ?OUT\" is \"_ \\<Longrightarrow> _ = _ + ?g_out - ?g_out'\")\n  and IN_plus_flow: \"d_OUT g x \\<noteq> top \\<Longrightarrow> d_IN (f \\<oplus> g) x = d_IN f x + (\\<Sum>\\<^sup>+ y\\<in>UNIV. g (y, x) * indicator \\<^bold>E (y, x)) - (\\<Sum>\\<^sup>+ y. g (x, y) * indicator \\<^bold>E (y, x))\"\n    (is \"_ \\<Longrightarrow> ?IN\" is \"_ \\<Longrightarrow> _ = _ + ?g_in - ?g_in'\")", "lemma d_IN_plus_flow:\n  assumes wf: \"wf_residual_network\"\n  and f: \"flow \\<Delta> f\"\n  and g: \"flow (residual_network f) g\"\n  shows \"d_IN (f \\<oplus> g) x \\<le> d_IN f x + d_IN g x\"", "lemma scale_flow:\n  assumes f: \"flow \\<Delta> f\"\n  and c: \"c \\<le> 1\"\n  shows \"flow \\<Delta> (\\<lambda>e. c * f e)\"", "lemma value_scale_flow:\n  \"value_flow \\<Delta> (\\<lambda>e. c * f e) = c * value_flow \\<Delta> f\"", "lemma value_flow:\n  assumes f: \"flow \\<Delta> f\"\n  and source_out: \"\\<And>y. edge \\<Delta> (source \\<Delta>) y \\<longleftrightarrow> y = x\"\n  shows \"value_flow \\<Delta> f = f (source \\<Delta>, x)\"", "lemma value_plus_flow:\n  assumes wf: \"wf_residual_network\"\n  and f: \"flow \\<Delta> f\"\n  and g: \"flow (residual_network f) g\"\n  shows \"value_flow \\<Delta> (f \\<oplus> g) = value_flow \\<Delta> f + value_flow \\<Delta> g\"", "lemma flow_residual_add: \\<comment> \\<open>Lemma 5.3\\<close>\n  assumes wf: \"wf_residual_network\"\n  and f: \"flow \\<Delta> f\"\n  and g: \"flow (residual_network f) g\"\n  shows \"flow \\<Delta> (f \\<oplus> g)\"", "lemma minus_flow_simps [simp]:\n  \"(f \\<ominus> g) (x, y) = (if edge \\<Delta> x y then f (x, y) - g (x, y) else if edge \\<Delta> y x then g (y, x) - f (y, x) else 0)\"", "lemma minus_flow:\n  assumes wf: \"wf_residual_network\"\n  and f: \"flow \\<Delta> f\"\n  and g: \"flow \\<Delta> g\"\n  and value_le: \"value_flow \\<Delta> g \\<le> value_flow \\<Delta> f\"\n  and f_finite: \"f (source \\<Delta>, x) \\<noteq> \\<top>\"\n  and source_out: \"\\<And>y. edge \\<Delta> (source \\<Delta>) y \\<longleftrightarrow> y = x\"\n  shows \"flow (residual_network g) (f \\<ominus> g)\" (is \"flow ?\\<Delta> ?f\")", "lemma value_minus_flow:\n  assumes f: \"flow \\<Delta> f\"\n  and g: \"flow \\<Delta> g\"\n  and value_le: \"value_flow \\<Delta> g \\<le> value_flow \\<Delta> f\"\n  and source_out: \"\\<And>y. edge \\<Delta> (source \\<Delta>) y \\<longleftrightarrow> y = x\"\n  shows \"value_flow \\<Delta> (f \\<ominus> g) = value_flow \\<Delta> f - value_flow \\<Delta> g\" (is \"?value\")", "lemma flow_by_value:\n  assumes \"v < \\<alpha>\"\n  and real[rule_format]: \"\\<forall>f. \\<alpha> = \\<top> \\<longrightarrow> flow \\<Delta> f \\<longrightarrow> value_flow \\<Delta> f < \\<alpha>\"\n  obtains f where \"flow \\<Delta> f\" \"value_flow \\<Delta> f = v\"", "theorem ex_max_flow':\n  assumes wf: \"wf_residual_network\"\n  assumes source_out: \"\\<And>y. edge \\<Delta> (source \\<Delta>) y \\<longleftrightarrow> y = x\"\n  and nontrivial: \"\\<^bold>V - {source \\<Delta>, sink \\<Delta>} \\<noteq> {}\"\n  and real: \"\\<alpha> = ennreal \\<alpha>'\" and \\<alpha>'_nonneg[simp]: \"0 \\<le> \\<alpha>'\"\n  shows \"\\<exists>f. flow \\<Delta> f \\<and> value_flow \\<Delta> f = \\<alpha> \\<and> (\\<forall>x. d_IN f x \\<le> value_flow \\<Delta> f)\"", "theorem ex_max_flow'': \\<comment> \\<open>eliminate assumption of no antiparallel edges using locale @{const wf_residual_network}\\<close>\n  assumes source_out: \"\\<And>y. edge \\<Delta> (source \\<Delta>) y \\<longleftrightarrow> y = x\"\n  and nontrivial: \"\\<^bold>E \\<noteq> {}\"\n  and real: \"\\<alpha> = ennreal \\<alpha>'\" and nn[simp]: \"0 \\<le> \\<alpha>'\"\n  shows \"\\<exists>f. flow \\<Delta> f \\<and> value_flow \\<Delta> f = \\<alpha> \\<and> (\\<forall>x. d_IN f x \\<le> value_flow \\<Delta> f)\"", "lemma not_Inner_conv: \"x \\<notin> range Inner \\<longleftrightarrow> x = SOURCE\"", "lemma inj_on_Inner [simp]: \"inj_on Inner A\"", "lemma capacity'_source_in [simp]: \"capacity' (y, Inner (source \\<Delta>)) = (if y = SOURCE then \\<alpha> else 0)\"", "lemma \\<Delta>'_sel [simp]:\n  \"edge \\<Delta>' = edge'\"\n  \"capacity \\<Delta>' = capacity'\"\n  \"source \\<Delta>' = SOURCE\"\n  \"sink \\<Delta>' = Inner (sink \\<Delta>)\"", "lemma \"\\<^bold>E_\\<Delta>'\": \"\\<^bold>E\\<^bsub>\\<Delta>'\\<^esub> = {(SOURCE, Inner (source \\<Delta>))} \\<union> (\\<lambda>(x, y). (Inner x, Inner y)) ` \\<^bold>E\"", "lemma \\<Delta>'_countable_network:\n  assumes \"\\<alpha> \\<noteq> \\<top>\"\n  shows \"countable_network \\<Delta>'\"", "lemma \\<Delta>'_flow_attainability:\n  assumes \"\\<alpha> \\<noteq> \\<top>\"\n  shows \"flow_attainability \\<Delta>'\"", "lemma d_OUT_lift_Inner [simp]: \"d_OUT (lift f) (Inner x) = d_OUT f x\" (is \"?lhs = ?rhs\")", "lemma d_OUT_lift_SOURCE [simp]: \"d_OUT (lift f) SOURCE = value_flow \\<Delta> f\" (is \"?lhs = ?rhs\")", "lemma d_IN_lift_Inner [simp]:\n  assumes \"x \\<noteq> source \\<Delta>\"\n  shows \"d_IN (lift f) (Inner x) = d_IN f x\" (is \"?lhs = ?rhs\")", "lemma d_IN_lift_source [simp]: \"d_IN (lift f) (Inner (source \\<Delta>)) = value_flow \\<Delta> f + d_IN f (source \\<Delta>)\" (is \"?lhs = ?rhs\")", "lemma flow_lift [simp]:\n  assumes \"flow \\<Delta> f\"\n  shows \"flow \\<Delta>' (lift f)\"", "lemma flow_unlift [simp]:\n  assumes f: \"flow \\<Delta>' f\"\n  shows \"flow \\<Delta> (unlift f)\"", "lemma value_unlift:\n  assumes f: \"flow \\<Delta>' f\"\n  shows \"value_flow \\<Delta> (unlift f) = value_flow \\<Delta>' f\"", "theorem ex_max_flow:\n  \"\\<exists>f. flow \\<Delta> f \\<and> value_flow \\<Delta> f = \\<alpha> \\<and> (\\<forall>x. d_IN f x \\<le> value_flow \\<Delta> f)\""], "translations": [["", "lemma cleanup_simps [simp]:\n  \"cleanup f (a, b) = (if f (a, b) > f (b, a) then f (a, b) - f (b, a) else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cleanup f (a, b) =\n    (if f (b, a) < f (a, b) then f (a, b) - f (b, a) else 0)", "by(simp add: cleanup_def)"], ["", "lemma value_flow_cleanup:\n  assumes [simp]: \"\\<And>x. f (x, source \\<Delta>) = 0\"\n  shows \"value_flow \\<Delta> (cleanup f) = value_flow \\<Delta> f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. value_flow \\<Delta> (cleanup f) = value_flow \\<Delta> f", "unfolding d_OUT_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y. cleanup f (source \\<Delta>, y)) =\n    (\\<Sum>\\<^sup>+ y. f (source \\<Delta>, y))", "by (auto simp add: not_less intro!: nn_integral_cong intro: antisym)"], ["", "lemma KIR_cleanup:\n  assumes KIR: \"KIR f x\"\n  and finite_IN: \"d_IN f x \\<noteq> \\<top>\"\n  shows \"KIR (cleanup f) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. KIR (cleanup f) x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. KIR (cleanup f) x", "from finite_IN KIR"], ["proof (chain)\npicking this:\n  d_IN f x \\<noteq> \\<top>\n  KIR f x", "have finite_OUT: \"d_OUT f x \\<noteq> \\<top>\""], ["proof (prove)\nusing this:\n  d_IN f x \\<noteq> \\<top>\n  KIR f x\n\ngoal (1 subgoal):\n 1. d_OUT f x \\<noteq> \\<top>", "by simp"], ["proof (state)\nthis:\n  d_OUT f x \\<noteq> \\<top>\n\ngoal (1 subgoal):\n 1. KIR (cleanup f) x", "have finite_IN: \"(\\<Sum>\\<^sup>+ y\\<in>A. f (y, x)) \\<noteq> \\<top>\" for A"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y\\<in>A. f (y, x)) \\<noteq> \\<top>", "using finite_IN"], ["proof (prove)\nusing this:\n  d_IN f x \\<noteq> \\<top>\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y\\<in>A. f (y, x)) \\<noteq> \\<top>", "by(rule neq_top_trans)(auto simp add: d_IN_def nn_integral_count_space_indicator intro!: nn_integral_mono split: split_indicator)"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y\\<in>?A. f (y, x)) \\<noteq> \\<top>\n\ngoal (1 subgoal):\n 1. KIR (cleanup f) x", "have finite_OUT: \"(\\<Sum>\\<^sup>+ y\\<in>A. f (x, y)) \\<noteq> \\<top>\" for A"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y\\<in>A. f (x, y)) \\<noteq> \\<top>", "using finite_OUT"], ["proof (prove)\nusing this:\n  d_OUT f x \\<noteq> \\<top>\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y\\<in>A. f (x, y)) \\<noteq> \\<top>", "by(rule neq_top_trans)(auto simp add: d_OUT_def nn_integral_count_space_indicator intro!: nn_integral_mono split: split_indicator)"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y\\<in>?A. f (x, y)) \\<noteq> \\<top>\n\ngoal (1 subgoal):\n 1. KIR (cleanup f) x", "have finite_in: \"f (x, y) \\<noteq> \\<top>\" for y"], ["proof (prove)\ngoal (1 subgoal):\n 1. f (x, y) \\<noteq> \\<top>", "using \\<open>d_OUT f x \\<noteq> \\<top>\\<close>"], ["proof (prove)\nusing this:\n  d_OUT f x \\<noteq> \\<top>\n\ngoal (1 subgoal):\n 1. f (x, y) \\<noteq> \\<top>", "by(rule neq_top_trans) (rule d_OUT_ge_point)"], ["proof (state)\nthis:\n  f (x, ?y) \\<noteq> \\<top>\n\ngoal (1 subgoal):\n 1. KIR (cleanup f) x", "let ?M = \"{y. f (x, y) > f (y, x)}\""], ["proof (state)\ngoal (1 subgoal):\n 1. KIR (cleanup f) x", "have \"d_OUT (cleanup f) x = (\\<Sum>\\<^sup>+ y\\<in>?M. f (x, y) - f (y, x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT (cleanup f) x =\n    (\\<Sum>\\<^sup>+ y\\<in>{y. f (y, x) < f (x, y)}. f (x, y) - f (y, x))", "by(auto simp add: d_OUT_def nn_integral_count_space_indicator intro!: nn_integral_cong)"], ["proof (state)\nthis:\n  d_OUT (cleanup f) x =\n  (\\<Sum>\\<^sup>+ y\\<in>{y. f (y, x) < f (x, y)}. f (x, y) - f (y, x))\n\ngoal (1 subgoal):\n 1. KIR (cleanup f) x", "also"], ["proof (state)\nthis:\n  d_OUT (cleanup f) x =\n  (\\<Sum>\\<^sup>+ y\\<in>{y. f (y, x) < f (x, y)}. f (x, y) - f (y, x))\n\ngoal (1 subgoal):\n 1. KIR (cleanup f) x", "have \"\\<dots> = (\\<Sum>\\<^sup>+ y\\<in>?M. f (x, y)) - (\\<Sum>\\<^sup>+ y\\<in>?M. f (y, x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y\\<in>{y. f (y, x) < f (x, y)}. f (x, y) - f (y, x)) =\n    (\\<Sum>\\<^sup>+ y\\<in>{y. f (y, x) < f (x, y)}. f (x, y)) -\n    (\\<Sum>\\<^sup>+ y\\<in>{y. f (y, x) < f (x, y)}. f (y, x))", "using finite_IN"], ["proof (prove)\nusing this:\n  (\\<Sum>\\<^sup>+ y\\<in>?A. f (y, x)) \\<noteq> \\<top>\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y\\<in>{y. f (y, x) < f (x, y)}. f (x, y) - f (y, x)) =\n    (\\<Sum>\\<^sup>+ y\\<in>{y. f (y, x) < f (x, y)}. f (x, y)) -\n    (\\<Sum>\\<^sup>+ y\\<in>{y. f (y, x) < f (x, y)}. f (y, x))", "by(subst nn_integral_diff)(auto simp add: AE_count_space)"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y\\<in>{y. f (y, x) < f (x, y)}. f (x, y) - f (y, x)) =\n  (\\<Sum>\\<^sup>+ y\\<in>{y. f (y, x) < f (x, y)}. f (x, y)) -\n  (\\<Sum>\\<^sup>+ y\\<in>{y. f (y, x) < f (x, y)}. f (y, x))\n\ngoal (1 subgoal):\n 1. KIR (cleanup f) x", "also"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y\\<in>{y. f (y, x) < f (x, y)}. f (x, y) - f (y, x)) =\n  (\\<Sum>\\<^sup>+ y\\<in>{y. f (y, x) < f (x, y)}. f (x, y)) -\n  (\\<Sum>\\<^sup>+ y\\<in>{y. f (y, x) < f (x, y)}. f (y, x))\n\ngoal (1 subgoal):\n 1. KIR (cleanup f) x", "have \"\\<dots> = (d_OUT f x - (\\<Sum>\\<^sup>+ y\\<in>{y. f (x, y) \\<le> f (y, x)}. f (x, y))) - (\\<Sum>\\<^sup>+ y\\<in>?M. f (y, x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y\\<in>{y. f (y, x) < f (x, y)}. f (x, y)) -\n    (\\<Sum>\\<^sup>+ y\\<in>{y. f (y, x) < f (x, y)}. f (y, x)) =\n    d_OUT f x -\n    (\\<Sum>\\<^sup>+ y\\<in>{y. f (x, y) \\<le> f (y, x)}. f (x, y)) -\n    (\\<Sum>\\<^sup>+ y\\<in>{y. f (y, x) < f (x, y)}. f (y, x))", "unfolding d_OUT_def d_IN_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y\\<in>{y. f (y, x) < f (x, y)}. f (x, y)) -\n    (\\<Sum>\\<^sup>+ y\\<in>{y. f (y, x) < f (x, y)}. f (y, x)) =\n    (\\<Sum>\\<^sup>+ y. f (x, y)) -\n    (\\<Sum>\\<^sup>+ y\\<in>{y. f (x, y) \\<le> f (y, x)}. f (x, y)) -\n    (\\<Sum>\\<^sup>+ y\\<in>{y. f (y, x) < f (x, y)}. f (y, x))", "using finite_IN finite_OUT"], ["proof (prove)\nusing this:\n  (\\<Sum>\\<^sup>+ y\\<in>?A. f (y, x)) \\<noteq> \\<top>\n  (\\<Sum>\\<^sup>+ y\\<in>?A. f (x, y)) \\<noteq> \\<top>\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y\\<in>{y. f (y, x) < f (x, y)}. f (x, y)) -\n    (\\<Sum>\\<^sup>+ y\\<in>{y. f (y, x) < f (x, y)}. f (y, x)) =\n    (\\<Sum>\\<^sup>+ y. f (x, y)) -\n    (\\<Sum>\\<^sup>+ y\\<in>{y. f (x, y) \\<le> f (y, x)}. f (x, y)) -\n    (\\<Sum>\\<^sup>+ y\\<in>{y. f (y, x) < f (x, y)}. f (y, x))", "apply(simp add: nn_integral_count_space_indicator)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>A.\n                \\<integral>\\<^sup>+y\\<in>A. f (y, x)\n                \\<partial>count_space UNIV \\<noteq>\n                \\<top>;\n     \\<And>A.\n        \\<integral>\\<^sup>+y\\<in>A. f (x, y)\n        \\<partial>count_space UNIV \\<noteq>\n        \\<top>\\<rbrakk>\n    \\<Longrightarrow> (\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < f (x, y)}.\n    f (x, y)\n                       \\<partial>count_space UNIV) -\n                      (\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < f (x, y)}.\n    f (y, x)\n                       \\<partial>count_space UNIV) =\n                      (\\<Sum>\\<^sup>+ y. f (x, y)) -\n                      (\\<integral>\\<^sup>+y\\<in>{y.\n           f (x, y) \\<le> f (y, x)}.\n    f (x, y)\n                       \\<partial>count_space UNIV) -\n                      (\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < f (x, y)}.\n    f (y, x)\n                       \\<partial>count_space UNIV)", "apply(subst (2) nn_integral_diff[symmetric])"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>\\<And>A.\n                \\<integral>\\<^sup>+y\\<in>A. f (y, x)\n                \\<partial>count_space UNIV \\<noteq>\n                \\<top>;\n     \\<And>A.\n        \\<integral>\\<^sup>+y\\<in>A. f (x, y)\n        \\<partial>count_space UNIV \\<noteq>\n        \\<top>\\<rbrakk>\n    \\<Longrightarrow> (\\<lambda>y. f (x, y))\n                      \\<in> borel_measurable (count_space UNIV)\n 2. \\<lbrakk>\\<And>A.\n                \\<integral>\\<^sup>+y\\<in>A. f (y, x)\n                \\<partial>count_space UNIV \\<noteq>\n                \\<top>;\n     \\<And>A.\n        \\<integral>\\<^sup>+y\\<in>A. f (x, y)\n        \\<partial>count_space UNIV \\<noteq>\n        \\<top>\\<rbrakk>\n    \\<Longrightarrow> (\\<lambda>y.\n                          f (x, y) *\n                          indicator {y. f (x, y) \\<le> f (y, x)} y)\n                      \\<in> borel_measurable (count_space UNIV)\n 3. \\<lbrakk>\\<And>A.\n                \\<integral>\\<^sup>+y\\<in>A. f (y, x)\n                \\<partial>count_space UNIV \\<noteq>\n                \\<top>;\n     \\<And>A.\n        \\<integral>\\<^sup>+y\\<in>A. f (x, y)\n        \\<partial>count_space UNIV \\<noteq>\n        \\<top>\\<rbrakk>\n    \\<Longrightarrow> \\<integral>\\<^sup>+y\\<in>{y. f (x, y) \\<le> f (y, x)}.\n   f (x, y)\n                      \\<partial>count_space UNIV \\<noteq>\n                      \\<infinity>\n 4. \\<lbrakk>\\<And>A.\n                \\<integral>\\<^sup>+y\\<in>A. f (y, x)\n                \\<partial>count_space UNIV \\<noteq>\n                \\<top>;\n     \\<And>A.\n        \\<integral>\\<^sup>+y\\<in>A. f (x, y)\n        \\<partial>count_space UNIV \\<noteq>\n        \\<top>\\<rbrakk>\n    \\<Longrightarrow> AE xa in count_space\n                                UNIV. f (x, xa) *\nindicator {y. f (x, y) \\<le> f (y, x)} xa\n\\<le> f (x, xa)\n 5. \\<lbrakk>\\<And>A.\n                \\<integral>\\<^sup>+y\\<in>A. f (y, x)\n                \\<partial>count_space UNIV \\<noteq>\n                \\<top>;\n     \\<And>A.\n        \\<integral>\\<^sup>+y\\<in>A. f (x, y)\n        \\<partial>count_space UNIV \\<noteq>\n        \\<top>\\<rbrakk>\n    \\<Longrightarrow> (\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < f (x, y)}.\n    f (x, y)\n                       \\<partial>count_space UNIV) -\n                      (\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < f (x, y)}.\n    f (y, x)\n                       \\<partial>count_space UNIV) =\n                      (\\<Sum>\\<^sup>+ xa.\n                         f (x, xa) -\n                         f (x, xa) *\n                         indicator {y. f (x, y) \\<le> f (y, x)} xa) -\n                      (\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < f (x, y)}.\n    f (y, x)\n                       \\<partial>count_space UNIV)", "apply(auto simp add: AE_count_space finite_in split: split_indicator intro!: arg_cong2[where f=\"(-)\"] intro!: nn_integral_cong)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y\\<in>{y. f (y, x) < f (x, y)}. f (x, y)) -\n  (\\<Sum>\\<^sup>+ y\\<in>{y. f (y, x) < f (x, y)}. f (y, x)) =\n  d_OUT f x -\n  (\\<Sum>\\<^sup>+ y\\<in>{y. f (x, y) \\<le> f (y, x)}. f (x, y)) -\n  (\\<Sum>\\<^sup>+ y\\<in>{y. f (y, x) < f (x, y)}. f (y, x))\n\ngoal (1 subgoal):\n 1. KIR (cleanup f) x", "also"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y\\<in>{y. f (y, x) < f (x, y)}. f (x, y)) -\n  (\\<Sum>\\<^sup>+ y\\<in>{y. f (y, x) < f (x, y)}. f (y, x)) =\n  d_OUT f x -\n  (\\<Sum>\\<^sup>+ y\\<in>{y. f (x, y) \\<le> f (y, x)}. f (x, y)) -\n  (\\<Sum>\\<^sup>+ y\\<in>{y. f (y, x) < f (x, y)}. f (y, x))\n\ngoal (1 subgoal):\n 1. KIR (cleanup f) x", "have \"\\<dots> = (d_IN f x - (\\<Sum>\\<^sup>+ y\\<in>?M. f (y, x))) - (\\<Sum>\\<^sup>+ y\\<in>{y. f (x, y) \\<le> f (y, x)}. f (x, y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT f x -\n    (\\<Sum>\\<^sup>+ y\\<in>{y. f (x, y) \\<le> f (y, x)}. f (x, y)) -\n    (\\<Sum>\\<^sup>+ y\\<in>{y. f (y, x) < f (x, y)}. f (y, x)) =\n    d_IN f x - (\\<Sum>\\<^sup>+ y\\<in>{y. f (y, x) < f (x, y)}. f (y, x)) -\n    (\\<Sum>\\<^sup>+ y\\<in>{y. f (x, y) \\<le> f (y, x)}. f (x, y))", "using KIR"], ["proof (prove)\nusing this:\n  KIR f x\n\ngoal (1 subgoal):\n 1. d_OUT f x -\n    (\\<Sum>\\<^sup>+ y\\<in>{y. f (x, y) \\<le> f (y, x)}. f (x, y)) -\n    (\\<Sum>\\<^sup>+ y\\<in>{y. f (y, x) < f (x, y)}. f (y, x)) =\n    d_IN f x - (\\<Sum>\\<^sup>+ y\\<in>{y. f (y, x) < f (x, y)}. f (y, x)) -\n    (\\<Sum>\\<^sup>+ y\\<in>{y. f (x, y) \\<le> f (y, x)}. f (x, y))", "by(simp add: diff_diff_commute_ennreal)"], ["proof (state)\nthis:\n  d_OUT f x -\n  (\\<Sum>\\<^sup>+ y\\<in>{y. f (x, y) \\<le> f (y, x)}. f (x, y)) -\n  (\\<Sum>\\<^sup>+ y\\<in>{y. f (y, x) < f (x, y)}. f (y, x)) =\n  d_IN f x - (\\<Sum>\\<^sup>+ y\\<in>{y. f (y, x) < f (x, y)}. f (y, x)) -\n  (\\<Sum>\\<^sup>+ y\\<in>{y. f (x, y) \\<le> f (y, x)}. f (x, y))\n\ngoal (1 subgoal):\n 1. KIR (cleanup f) x", "also"], ["proof (state)\nthis:\n  d_OUT f x -\n  (\\<Sum>\\<^sup>+ y\\<in>{y. f (x, y) \\<le> f (y, x)}. f (x, y)) -\n  (\\<Sum>\\<^sup>+ y\\<in>{y. f (y, x) < f (x, y)}. f (y, x)) =\n  d_IN f x - (\\<Sum>\\<^sup>+ y\\<in>{y. f (y, x) < f (x, y)}. f (y, x)) -\n  (\\<Sum>\\<^sup>+ y\\<in>{y. f (x, y) \\<le> f (y, x)}. f (x, y))\n\ngoal (1 subgoal):\n 1. KIR (cleanup f) x", "have \"\\<dots> = (\\<Sum>\\<^sup>+ y\\<in>{y. f (x, y) \\<le> f (y, x)}. f (y, x)) - (\\<Sum>\\<^sup>+ y\\<in>{y. f (x, y) \\<le> f (y, x)}. f (x, y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN f x - (\\<Sum>\\<^sup>+ y\\<in>{y. f (y, x) < f (x, y)}. f (y, x)) -\n    (\\<Sum>\\<^sup>+ y\\<in>{y. f (x, y) \\<le> f (y, x)}. f (x, y)) =\n    (\\<Sum>\\<^sup>+ y\\<in>{y. f (x, y) \\<le> f (y, x)}. f (y, x)) -\n    (\\<Sum>\\<^sup>+ y\\<in>{y. f (x, y) \\<le> f (y, x)}. f (x, y))", "using finite_IN finite_IN[of \"{ _ }\"]"], ["proof (prove)\nusing this:\n  (\\<Sum>\\<^sup>+ y\\<in>?A. f (y, x)) \\<noteq> \\<top>\n  (\\<Sum>\\<^sup>+ y\\<in>{?uu3}. f (y, x)) \\<noteq> \\<top>\n\ngoal (1 subgoal):\n 1. d_IN f x - (\\<Sum>\\<^sup>+ y\\<in>{y. f (y, x) < f (x, y)}. f (y, x)) -\n    (\\<Sum>\\<^sup>+ y\\<in>{y. f (x, y) \\<le> f (y, x)}. f (x, y)) =\n    (\\<Sum>\\<^sup>+ y\\<in>{y. f (x, y) \\<le> f (y, x)}. f (y, x)) -\n    (\\<Sum>\\<^sup>+ y\\<in>{y. f (x, y) \\<le> f (y, x)}. f (x, y))", "apply(simp add: d_IN_def nn_integral_count_space_indicator)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>A.\n                \\<integral>\\<^sup>+y\\<in>A. f (y, x)\n                \\<partial>count_space UNIV \\<noteq>\n                \\<top>;\n     \\<And>uu. f (uu, x) \\<noteq> \\<top>\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>\\<^sup>+ xa. f (xa, x)) -\n                      (\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < f (x, y)}.\n    f (y, x)\n                       \\<partial>count_space UNIV) -\n                      (\\<integral>\\<^sup>+y\\<in>{y.\n           f (x, y) \\<le> f (y, x)}.\n    f (x, y)\n                       \\<partial>count_space UNIV) =\n                      (\\<integral>\\<^sup>+y\\<in>{y.\n           f (x, y) \\<le> f (y, x)}.\n    f (y, x)\n                       \\<partial>count_space UNIV) -\n                      (\\<integral>\\<^sup>+y\\<in>{y.\n           f (x, y) \\<le> f (y, x)}.\n    f (x, y)\n                       \\<partial>count_space UNIV)", "apply(subst nn_integral_diff[symmetric])"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>\\<And>A.\n                \\<integral>\\<^sup>+y\\<in>A. f (y, x)\n                \\<partial>count_space UNIV \\<noteq>\n                \\<top>;\n     \\<And>uu. f (uu, x) \\<noteq> \\<top>\\<rbrakk>\n    \\<Longrightarrow> (\\<lambda>xa. f (xa, x))\n                      \\<in> borel_measurable (count_space UNIV)\n 2. \\<lbrakk>\\<And>A.\n                \\<integral>\\<^sup>+y\\<in>A. f (y, x)\n                \\<partial>count_space UNIV \\<noteq>\n                \\<top>;\n     \\<And>uu. f (uu, x) \\<noteq> \\<top>\\<rbrakk>\n    \\<Longrightarrow> (\\<lambda>y.\n                          f (y, x) * indicator {y. f (y, x) < f (x, y)} y)\n                      \\<in> borel_measurable (count_space UNIV)\n 3. \\<lbrakk>\\<And>A.\n                \\<integral>\\<^sup>+y\\<in>A. f (y, x)\n                \\<partial>count_space UNIV \\<noteq>\n                \\<top>;\n     \\<And>uu. f (uu, x) \\<noteq> \\<top>\\<rbrakk>\n    \\<Longrightarrow> \\<integral>\\<^sup>+y\\<in>{y. f (y, x) < f (x, y)}.\n   f (y, x)\n                      \\<partial>count_space UNIV \\<noteq>\n                      \\<infinity>\n 4. \\<lbrakk>\\<And>A.\n                \\<integral>\\<^sup>+y\\<in>A. f (y, x)\n                \\<partial>count_space UNIV \\<noteq>\n                \\<top>;\n     \\<And>uu. f (uu, x) \\<noteq> \\<top>\\<rbrakk>\n    \\<Longrightarrow> AE xa in count_space\n                                UNIV. f (xa, x) *\nindicator {y. f (y, x) < f (x, y)} xa\n\\<le> f (xa, x)\n 5. \\<lbrakk>\\<And>A.\n                \\<integral>\\<^sup>+y\\<in>A. f (y, x)\n                \\<partial>count_space UNIV \\<noteq>\n                \\<top>;\n     \\<And>uu. f (uu, x) \\<noteq> \\<top>\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>\\<^sup>+ xa.\n                         f (xa, x) -\n                         f (xa, x) *\n                         indicator {y. f (y, x) < f (x, y)} xa) -\n                      (\\<integral>\\<^sup>+y\\<in>{y.\n           f (x, y) \\<le> f (y, x)}.\n    f (x, y)\n                       \\<partial>count_space UNIV) =\n                      (\\<integral>\\<^sup>+y\\<in>{y.\n           f (x, y) \\<le> f (y, x)}.\n    f (y, x)\n                       \\<partial>count_space UNIV) -\n                      (\\<integral>\\<^sup>+y\\<in>{y.\n           f (x, y) \\<le> f (y, x)}.\n    f (x, y)\n                       \\<partial>count_space UNIV)", "apply(auto simp add: d_IN_def AE_count_space split: split_indicator intro!: arg_cong2[where f=\"(-)\"] intro!: nn_integral_cong)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  d_IN f x - (\\<Sum>\\<^sup>+ y\\<in>{y. f (y, x) < f (x, y)}. f (y, x)) -\n  (\\<Sum>\\<^sup>+ y\\<in>{y. f (x, y) \\<le> f (y, x)}. f (x, y)) =\n  (\\<Sum>\\<^sup>+ y\\<in>{y. f (x, y) \\<le> f (y, x)}. f (y, x)) -\n  (\\<Sum>\\<^sup>+ y\\<in>{y. f (x, y) \\<le> f (y, x)}. f (x, y))\n\ngoal (1 subgoal):\n 1. KIR (cleanup f) x", "also"], ["proof (state)\nthis:\n  d_IN f x - (\\<Sum>\\<^sup>+ y\\<in>{y. f (y, x) < f (x, y)}. f (y, x)) -\n  (\\<Sum>\\<^sup>+ y\\<in>{y. f (x, y) \\<le> f (y, x)}. f (x, y)) =\n  (\\<Sum>\\<^sup>+ y\\<in>{y. f (x, y) \\<le> f (y, x)}. f (y, x)) -\n  (\\<Sum>\\<^sup>+ y\\<in>{y. f (x, y) \\<le> f (y, x)}. f (x, y))\n\ngoal (1 subgoal):\n 1. KIR (cleanup f) x", "have \"\\<dots> = (\\<Sum>\\<^sup>+ y\\<in>{y. f (x, y) \\<le> f (y, x)}. f (y, x) - f (x, y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y\\<in>{y. f (x, y) \\<le> f (y, x)}. f (y, x)) -\n    (\\<Sum>\\<^sup>+ y\\<in>{y. f (x, y) \\<le> f (y, x)}. f (x, y)) =\n    (\\<Sum>\\<^sup>+ y\\<in>{y. f (x, y) \\<le> f (y, x)}. f (y, x) - f (x, y))", "using finite_OUT"], ["proof (prove)\nusing this:\n  (\\<Sum>\\<^sup>+ y\\<in>?A. f (x, y)) \\<noteq> \\<top>\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y\\<in>{y. f (x, y) \\<le> f (y, x)}. f (y, x)) -\n    (\\<Sum>\\<^sup>+ y\\<in>{y. f (x, y) \\<le> f (y, x)}. f (x, y)) =\n    (\\<Sum>\\<^sup>+ y\\<in>{y. f (x, y) \\<le> f (y, x)}. f (y, x) - f (x, y))", "by(subst nn_integral_diff)(auto simp add: AE_count_space)"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y\\<in>{y. f (x, y) \\<le> f (y, x)}. f (y, x)) -\n  (\\<Sum>\\<^sup>+ y\\<in>{y. f (x, y) \\<le> f (y, x)}. f (x, y)) =\n  (\\<Sum>\\<^sup>+ y\\<in>{y. f (x, y) \\<le> f (y, x)}. f (y, x) - f (x, y))\n\ngoal (1 subgoal):\n 1. KIR (cleanup f) x", "also"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y\\<in>{y. f (x, y) \\<le> f (y, x)}. f (y, x)) -\n  (\\<Sum>\\<^sup>+ y\\<in>{y. f (x, y) \\<le> f (y, x)}. f (x, y)) =\n  (\\<Sum>\\<^sup>+ y\\<in>{y. f (x, y) \\<le> f (y, x)}. f (y, x) - f (x, y))\n\ngoal (1 subgoal):\n 1. KIR (cleanup f) x", "have \"\\<dots> = d_IN (cleanup f) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y\\<in>{y. f (x, y) \\<le> f (y, x)}.\n       f (y, x) - f (x, y)) =\n    d_IN (cleanup f) x", "using finite_in"], ["proof (prove)\nusing this:\n  f (x, ?y) \\<noteq> \\<top>\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y\\<in>{y. f (x, y) \\<le> f (y, x)}.\n       f (y, x) - f (x, y)) =\n    d_IN (cleanup f) x", "by(auto simp add: d_IN_def nn_integral_count_space_indicator intro!: ennreal_diff_self nn_integral_cong split: split_indicator)"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y\\<in>{y. f (x, y) \\<le> f (y, x)}. f (y, x) - f (x, y)) =\n  d_IN (cleanup f) x\n\ngoal (1 subgoal):\n 1. KIR (cleanup f) x", "finally"], ["proof (chain)\npicking this:\n  KIR (cleanup f) x", "show \"KIR (cleanup f) x\""], ["proof (prove)\nusing this:\n  KIR (cleanup f) x\n\ngoal (1 subgoal):\n 1. KIR (cleanup f) x", "."], ["proof (state)\nthis:\n  KIR (cleanup f) x\n\ngoal:\nNo subgoals!", "qed"], ["", "locale flow_attainability = countable_network \\<Delta>\n  for \\<Delta> :: \"('v, 'more) network_scheme\" (structure)\n  +\n  assumes finite_capacity: \"\\<And>x. x \\<noteq> sink \\<Delta> \\<Longrightarrow> d_IN (capacity \\<Delta>) x \\<noteq> \\<top> \\<or> d_OUT (capacity \\<Delta>) x \\<noteq> \\<top>\"\n  and no_loop: \"\\<And>x. \\<not> edge \\<Delta> x x\"\n  and source_in: \"\\<And>x. \\<not> edge \\<Delta> x (source \\<Delta>)\"\nbegin"], ["", "lemma source_in_not_cycle:\n  assumes \"cycle \\<Delta> p\"\n  shows \"(x, source \\<Delta>) \\<notin> set (cycle_edges p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x, source \\<Delta>) \\<notin> set (cycle_edges p)", "using cycle_edges_edges[OF assms] source_in[of x]"], ["proof (prove)\nusing this:\n  set (cycle_edges p) \\<subseteq> \\<^bold>E\n  \\<not> edge \\<Delta> x (source \\<Delta>)\n\ngoal (1 subgoal):\n 1. (x, source \\<Delta>) \\<notin> set (cycle_edges p)", "by(auto)"], ["", "lemma source_out_not_cycle:\n  \"cycle \\<Delta> p \\<Longrightarrow> (source \\<Delta>, x) \\<notin> set (cycle_edges p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cycle \\<Delta> p \\<Longrightarrow>\n    (source \\<Delta>, x) \\<notin> set (cycle_edges p)", "by(auto dest: cycle_leave_ex_enter source_in_not_cycle)"], ["", "lemma flowD_source_IN:\n  assumes \"flow \\<Delta> f\"\n  shows \"d_IN f (source \\<Delta>) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN f (source \\<Delta>) = 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. d_IN f (source \\<Delta>) = 0", "have \"d_IN f (source \\<Delta>) = (\\<Sum>\\<^sup>+ y\\<in>\\<^bold>I\\<^bold>N (source \\<Delta>). f (y, source \\<Delta>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN f (source \\<Delta>) =\n    (\\<Sum>\\<^sup>+ y\\<in>\\<^bold>I\\<^bold>N (source \\<Delta>).\n       f (y, source \\<Delta>))", "by(rule d_IN_alt_def)(simp add: flowD_outside[OF assms])"], ["proof (state)\nthis:\n  d_IN f (source \\<Delta>) =\n  (\\<Sum>\\<^sup>+ y\\<in>\\<^bold>I\\<^bold>N (source \\<Delta>).\n     f (y, source \\<Delta>))\n\ngoal (1 subgoal):\n 1. d_IN f (source \\<Delta>) = 0", "also"], ["proof (state)\nthis:\n  d_IN f (source \\<Delta>) =\n  (\\<Sum>\\<^sup>+ y\\<in>\\<^bold>I\\<^bold>N (source \\<Delta>).\n     f (y, source \\<Delta>))\n\ngoal (1 subgoal):\n 1. d_IN f (source \\<Delta>) = 0", "have \"\\<dots> = (\\<Sum>\\<^sup>+ y\\<in>\\<^bold>I\\<^bold>N (source \\<Delta>). 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y\\<in>\\<^bold>I\\<^bold>N (source \\<Delta>).\n       f (y, source \\<Delta>)) =\n    (\\<Sum>\\<^sup>+ y\\<in>\\<^bold>I\\<^bold>N (source \\<Delta>). 0)", "by(rule nn_integral_cong)(simp add: source_in incoming_def)"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y\\<in>\\<^bold>I\\<^bold>N (source \\<Delta>).\n     f (y, source \\<Delta>)) =\n  (\\<Sum>\\<^sup>+ y\\<in>\\<^bold>I\\<^bold>N (source \\<Delta>). 0)\n\ngoal (1 subgoal):\n 1. d_IN f (source \\<Delta>) = 0", "finally"], ["proof (chain)\npicking this:\n  d_IN f (source \\<Delta>) =\n  (\\<Sum>\\<^sup>+ y\\<in>\\<^bold>I\\<^bold>N (source \\<Delta>). 0)", "show ?thesis"], ["proof (prove)\nusing this:\n  d_IN f (source \\<Delta>) =\n  (\\<Sum>\\<^sup>+ y\\<in>\\<^bold>I\\<^bold>N (source \\<Delta>). 0)\n\ngoal (1 subgoal):\n 1. d_IN f (source \\<Delta>) = 0", "by simp"], ["proof (state)\nthis:\n  d_IN f (source \\<Delta>) = 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma flowD_finite_IN:\n  assumes f: \"flow \\<Delta> f\" and x: \"x \\<noteq> sink \\<Delta>\"\n  shows \"d_IN f x \\<noteq> top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN f x \\<noteq> \\<top>", "proof(cases \"x = source \\<Delta>\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x = source \\<Delta> \\<Longrightarrow> d_IN f x \\<noteq> \\<top>\n 2. x \\<noteq> source \\<Delta> \\<Longrightarrow> d_IN f x \\<noteq> \\<top>", "case True"], ["proof (state)\nthis:\n  x = source \\<Delta>\n\ngoal (2 subgoals):\n 1. x = source \\<Delta> \\<Longrightarrow> d_IN f x \\<noteq> \\<top>\n 2. x \\<noteq> source \\<Delta> \\<Longrightarrow> d_IN f x \\<noteq> \\<top>", "thus ?thesis"], ["proof (prove)\nusing this:\n  x = source \\<Delta>\n\ngoal (1 subgoal):\n 1. d_IN f x \\<noteq> \\<top>", "by(simp add: flowD_source_IN[OF f])"], ["proof (state)\nthis:\n  d_IN f x \\<noteq> \\<top>\n\ngoal (1 subgoal):\n 1. x \\<noteq> source \\<Delta> \\<Longrightarrow> d_IN f x \\<noteq> \\<top>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<noteq> source \\<Delta> \\<Longrightarrow> d_IN f x \\<noteq> \\<top>", "case False"], ["proof (state)\nthis:\n  x \\<noteq> source \\<Delta>\n\ngoal (1 subgoal):\n 1. x \\<noteq> source \\<Delta> \\<Longrightarrow> d_IN f x \\<noteq> \\<top>", "from finite_capacity[OF x]"], ["proof (chain)\npicking this:\n  d_IN (capacity \\<Delta>) x \\<noteq> \\<top> \\<or>\n  d_OUT (capacity \\<Delta>) x \\<noteq> \\<top>", "show ?thesis"], ["proof (prove)\nusing this:\n  d_IN (capacity \\<Delta>) x \\<noteq> \\<top> \\<or>\n  d_OUT (capacity \\<Delta>) x \\<noteq> \\<top>\n\ngoal (1 subgoal):\n 1. d_IN f x \\<noteq> \\<top>", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. d_IN (capacity \\<Delta>) x \\<noteq> \\<top> \\<Longrightarrow>\n    d_IN f x \\<noteq> \\<top>\n 2. d_OUT (capacity \\<Delta>) x \\<noteq> \\<top> \\<Longrightarrow>\n    d_IN f x \\<noteq> \\<top>", "assume *: \"d_IN (capacity \\<Delta>) x \\<noteq> \\<top>\""], ["proof (state)\nthis:\n  d_IN (capacity \\<Delta>) x \\<noteq> \\<top>\n\ngoal (2 subgoals):\n 1. d_IN (capacity \\<Delta>) x \\<noteq> \\<top> \\<Longrightarrow>\n    d_IN f x \\<noteq> \\<top>\n 2. d_OUT (capacity \\<Delta>) x \\<noteq> \\<top> \\<Longrightarrow>\n    d_IN f x \\<noteq> \\<top>", "from flowD_capacity[OF f]"], ["proof (chain)\npicking this:\n  f ?e \\<le> capacity \\<Delta> ?e", "have \"d_IN f x \\<le> d_IN (capacity \\<Delta>) x\""], ["proof (prove)\nusing this:\n  f ?e \\<le> capacity \\<Delta> ?e\n\ngoal (1 subgoal):\n 1. d_IN f x \\<le> d_IN (capacity \\<Delta>) x", "by(rule d_IN_mono)"], ["proof (state)\nthis:\n  d_IN f x \\<le> d_IN (capacity \\<Delta>) x\n\ngoal (2 subgoals):\n 1. d_IN (capacity \\<Delta>) x \\<noteq> \\<top> \\<Longrightarrow>\n    d_IN f x \\<noteq> \\<top>\n 2. d_OUT (capacity \\<Delta>) x \\<noteq> \\<top> \\<Longrightarrow>\n    d_IN f x \\<noteq> \\<top>", "also"], ["proof (state)\nthis:\n  d_IN f x \\<le> d_IN (capacity \\<Delta>) x\n\ngoal (2 subgoals):\n 1. d_IN (capacity \\<Delta>) x \\<noteq> \\<top> \\<Longrightarrow>\n    d_IN f x \\<noteq> \\<top>\n 2. d_OUT (capacity \\<Delta>) x \\<noteq> \\<top> \\<Longrightarrow>\n    d_IN f x \\<noteq> \\<top>", "have \"\\<dots> < \\<top>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN (capacity \\<Delta>) x < \\<top>", "using *"], ["proof (prove)\nusing this:\n  d_IN (capacity \\<Delta>) x \\<noteq> \\<top>\n\ngoal (1 subgoal):\n 1. d_IN (capacity \\<Delta>) x < \\<top>", "by (simp add: less_top)"], ["proof (state)\nthis:\n  d_IN (capacity \\<Delta>) x < \\<top>\n\ngoal (2 subgoals):\n 1. d_IN (capacity \\<Delta>) x \\<noteq> \\<top> \\<Longrightarrow>\n    d_IN f x \\<noteq> \\<top>\n 2. d_OUT (capacity \\<Delta>) x \\<noteq> \\<top> \\<Longrightarrow>\n    d_IN f x \\<noteq> \\<top>", "finally"], ["proof (chain)\npicking this:\n  d_IN f x < \\<top>", "show ?thesis"], ["proof (prove)\nusing this:\n  d_IN f x < \\<top>\n\ngoal (1 subgoal):\n 1. d_IN f x \\<noteq> \\<top>", "by simp"], ["proof (state)\nthis:\n  d_IN f x \\<noteq> \\<top>\n\ngoal (1 subgoal):\n 1. d_OUT (capacity \\<Delta>) x \\<noteq> \\<top> \\<Longrightarrow>\n    d_IN f x \\<noteq> \\<top>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. d_OUT (capacity \\<Delta>) x \\<noteq> \\<top> \\<Longrightarrow>\n    d_IN f x \\<noteq> \\<top>", "assume *: \"d_OUT (capacity \\<Delta>) x \\<noteq> \\<top>\""], ["proof (state)\nthis:\n  d_OUT (capacity \\<Delta>) x \\<noteq> \\<top>\n\ngoal (1 subgoal):\n 1. d_OUT (capacity \\<Delta>) x \\<noteq> \\<top> \\<Longrightarrow>\n    d_IN f x \\<noteq> \\<top>", "have \"d_IN f x = d_OUT f x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN f x = d_OUT f x", "using flowD_KIR[OF f False x]"], ["proof (prove)\nusing this:\n  KIR f x\n\ngoal (1 subgoal):\n 1. d_IN f x = d_OUT f x", "by simp"], ["proof (state)\nthis:\n  d_IN f x = d_OUT f x\n\ngoal (1 subgoal):\n 1. d_OUT (capacity \\<Delta>) x \\<noteq> \\<top> \\<Longrightarrow>\n    d_IN f x \\<noteq> \\<top>", "also"], ["proof (state)\nthis:\n  d_IN f x = d_OUT f x\n\ngoal (1 subgoal):\n 1. d_OUT (capacity \\<Delta>) x \\<noteq> \\<top> \\<Longrightarrow>\n    d_IN f x \\<noteq> \\<top>", "have \"\\<dots> \\<le> d_OUT (capacity \\<Delta>) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT f x \\<le> d_OUT (capacity \\<Delta>) x", "using flowD_capacity[OF f]"], ["proof (prove)\nusing this:\n  f ?e \\<le> capacity \\<Delta> ?e\n\ngoal (1 subgoal):\n 1. d_OUT f x \\<le> d_OUT (capacity \\<Delta>) x", "by(rule d_OUT_mono)"], ["proof (state)\nthis:\n  d_OUT f x \\<le> d_OUT (capacity \\<Delta>) x\n\ngoal (1 subgoal):\n 1. d_OUT (capacity \\<Delta>) x \\<noteq> \\<top> \\<Longrightarrow>\n    d_IN f x \\<noteq> \\<top>", "also"], ["proof (state)\nthis:\n  d_OUT f x \\<le> d_OUT (capacity \\<Delta>) x\n\ngoal (1 subgoal):\n 1. d_OUT (capacity \\<Delta>) x \\<noteq> \\<top> \\<Longrightarrow>\n    d_IN f x \\<noteq> \\<top>", "have \"\\<dots> < \\<top>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT (capacity \\<Delta>) x < \\<top>", "using *"], ["proof (prove)\nusing this:\n  d_OUT (capacity \\<Delta>) x \\<noteq> \\<top>\n\ngoal (1 subgoal):\n 1. d_OUT (capacity \\<Delta>) x < \\<top>", "by (simp add: less_top)"], ["proof (state)\nthis:\n  d_OUT (capacity \\<Delta>) x < \\<top>\n\ngoal (1 subgoal):\n 1. d_OUT (capacity \\<Delta>) x \\<noteq> \\<top> \\<Longrightarrow>\n    d_IN f x \\<noteq> \\<top>", "finally"], ["proof (chain)\npicking this:\n  d_IN f x < \\<top>", "show ?thesis"], ["proof (prove)\nusing this:\n  d_IN f x < \\<top>\n\ngoal (1 subgoal):\n 1. d_IN f x \\<noteq> \\<top>", "by simp"], ["proof (state)\nthis:\n  d_IN f x \\<noteq> \\<top>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  d_IN f x \\<noteq> \\<top>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma flowD_finite_OUT:\n  assumes \"flow \\<Delta> f\" \"x \\<noteq> source \\<Delta>\" \"x \\<noteq> sink \\<Delta>\"\n  shows \"d_OUT f x \\<noteq> \\<top>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT f x \\<noteq> \\<top>", "using flowD_KIR[OF assms] assms"], ["proof (prove)\nusing this:\n  KIR f x\n  flow \\<Delta> f\n  x \\<noteq> source \\<Delta>\n  x \\<noteq> sink \\<Delta>\n\ngoal (1 subgoal):\n 1. d_OUT f x \\<noteq> \\<top>", "by(simp add: flowD_finite_IN)"], ["", "end"], ["", "locale flow_network = flow_attainability\n  +\n  fixes g :: \"'v flow\"\n  assumes g: \"flow \\<Delta> g\"\n  and g_finite: \"value_flow \\<Delta> g \\<noteq> \\<top>\"\n  and nontrivial: \"\\<^bold>V - {source \\<Delta>, sink \\<Delta>} \\<noteq> {}\"\nbegin"], ["", "lemma g_outside: \"e \\<notin> \\<^bold>E \\<Longrightarrow> g e = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. e \\<notin> \\<^bold>E \\<Longrightarrow> g e = 0", "by(rule flowD_outside)(rule g)"], ["", "lemma g_loop [simp]: \"g (x, x) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g (x, x) = 0", "by(rule g_outside)(simp add: no_loop)"], ["", "lemma finite_IN_g: \"x \\<noteq> sink \\<Delta> \\<Longrightarrow> d_IN g x \\<noteq> top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<noteq> sink \\<Delta> \\<Longrightarrow> d_IN g x \\<noteq> \\<top>", "by(rule flowD_finite_IN[OF g])"], ["", "lemma finite_OUT_g:\n  assumes \"x \\<noteq> sink \\<Delta>\"\n  shows \"d_OUT g x \\<noteq> top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT g x \\<noteq> \\<top>", "proof(cases \"x = source \\<Delta>\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x = source \\<Delta> \\<Longrightarrow> d_OUT g x \\<noteq> \\<top>\n 2. x \\<noteq> source \\<Delta> \\<Longrightarrow> d_OUT g x \\<noteq> \\<top>", "case True"], ["proof (state)\nthis:\n  x = source \\<Delta>\n\ngoal (2 subgoals):\n 1. x = source \\<Delta> \\<Longrightarrow> d_OUT g x \\<noteq> \\<top>\n 2. x \\<noteq> source \\<Delta> \\<Longrightarrow> d_OUT g x \\<noteq> \\<top>", "with g_finite"], ["proof (chain)\npicking this:\n  value_flow \\<Delta> g \\<noteq> \\<top>\n  x = source \\<Delta>", "show ?thesis"], ["proof (prove)\nusing this:\n  value_flow \\<Delta> g \\<noteq> \\<top>\n  x = source \\<Delta>\n\ngoal (1 subgoal):\n 1. d_OUT g x \\<noteq> \\<top>", "by simp"], ["proof (state)\nthis:\n  d_OUT g x \\<noteq> \\<top>\n\ngoal (1 subgoal):\n 1. x \\<noteq> source \\<Delta> \\<Longrightarrow> d_OUT g x \\<noteq> \\<top>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<noteq> source \\<Delta> \\<Longrightarrow> d_OUT g x \\<noteq> \\<top>", "case False"], ["proof (state)\nthis:\n  x \\<noteq> source \\<Delta>\n\ngoal (1 subgoal):\n 1. x \\<noteq> source \\<Delta> \\<Longrightarrow> d_OUT g x \\<noteq> \\<top>", "with g"], ["proof (chain)\npicking this:\n  flow \\<Delta> g\n  x \\<noteq> source \\<Delta>", "have \"KIR g x\""], ["proof (prove)\nusing this:\n  flow \\<Delta> g\n  x \\<noteq> source \\<Delta>\n\ngoal (1 subgoal):\n 1. KIR g x", "using assms"], ["proof (prove)\nusing this:\n  flow \\<Delta> g\n  x \\<noteq> source \\<Delta>\n  x \\<noteq> sink \\<Delta>\n\ngoal (1 subgoal):\n 1. KIR g x", "by(auto dest: flowD_KIR)"], ["proof (state)\nthis:\n  KIR g x\n\ngoal (1 subgoal):\n 1. x \\<noteq> source \\<Delta> \\<Longrightarrow> d_OUT g x \\<noteq> \\<top>", "with finite_IN_g[of x] False assms"], ["proof (chain)\npicking this:\n  x \\<noteq> sink \\<Delta> \\<Longrightarrow> d_IN g x \\<noteq> \\<top>\n  x \\<noteq> source \\<Delta>\n  x \\<noteq> sink \\<Delta>\n  KIR g x", "show ?thesis"], ["proof (prove)\nusing this:\n  x \\<noteq> sink \\<Delta> \\<Longrightarrow> d_IN g x \\<noteq> \\<top>\n  x \\<noteq> source \\<Delta>\n  x \\<noteq> sink \\<Delta>\n  KIR g x\n\ngoal (1 subgoal):\n 1. d_OUT g x \\<noteq> \\<top>", "by(simp)"], ["proof (state)\nthis:\n  d_OUT g x \\<noteq> \\<top>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma g_source_in [simp]: \"g (x, source \\<Delta>) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g (x, source \\<Delta>) = 0", "by(rule g_outside)(simp add: source_in)"], ["", "lemma finite_g [simp]: \"g e \\<noteq> top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g e \\<noteq> \\<top>", "by(rule flowD_finite[OF g])"], ["", "definition enum_v :: \"nat \\<Rightarrow> 'v\"\nwhere \"enum_v n = from_nat_into (\\<^bold>V - {source \\<Delta>, sink \\<Delta>}) (fst (prod_decode n))\""], ["", "lemma range_enum_v: \"range enum_v \\<subseteq> \\<^bold>V - {source \\<Delta>, sink \\<Delta>}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. range enum_v \\<subseteq> \\<^bold>V - {source \\<Delta>, sink \\<Delta>}", "using from_nat_into[OF nontrivial]"], ["proof (prove)\nusing this:\n  from_nat_into (\\<^bold>V - {source \\<Delta>, sink \\<Delta>}) ?n\n  \\<in> \\<^bold>V - {source \\<Delta>, sink \\<Delta>}\n\ngoal (1 subgoal):\n 1. range enum_v \\<subseteq> \\<^bold>V - {source \\<Delta>, sink \\<Delta>}", "by(auto simp add: enum_v_def)"], ["", "lemma enum_v_repeat:\n  assumes x: \"x \\<in> \\<^bold>V\" \"x \\<noteq> source \\<Delta>\" \"x \\<noteq> sink \\<Delta>\"\n  shows \"\\<exists>i'>i. enum_v i' = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>i'>i. enum_v i' = x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>i'>i. enum_v i' = x", "let ?V = \"\\<^bold>V - {source \\<Delta>, sink \\<Delta>}\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>i'>i. enum_v i' = x", "let ?n = \"to_nat_on ?V x\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>i'>i. enum_v i' = x", "let ?A = \"{?n} \\<times> (UNIV :: nat set)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>i'>i. enum_v i' = x", "from x"], ["proof (chain)\npicking this:\n  x \\<in> \\<^bold>V\n  x \\<noteq> source \\<Delta>\n  x \\<noteq> sink \\<Delta>", "have x': \"x \\<in> \\<^bold>V - {source \\<Delta>, sink \\<Delta>}\""], ["proof (prove)\nusing this:\n  x \\<in> \\<^bold>V\n  x \\<noteq> source \\<Delta>\n  x \\<noteq> sink \\<Delta>\n\ngoal (1 subgoal):\n 1. x \\<in> \\<^bold>V - {source \\<Delta>, sink \\<Delta>}", "by simp"], ["proof (state)\nthis:\n  x \\<in> \\<^bold>V - {source \\<Delta>, sink \\<Delta>}\n\ngoal (1 subgoal):\n 1. \\<exists>i'>i. enum_v i' = x", "have \"infinite ?A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infinite\n     ({to_nat_on (\\<^bold>V - {source \\<Delta>, sink \\<Delta>}) x} \\<times>\n      UNIV)", "by(auto dest: finite_cartesian_productD2)"], ["proof (state)\nthis:\n  infinite\n   ({to_nat_on (\\<^bold>V - {source \\<Delta>, sink \\<Delta>}) x} \\<times>\n    UNIV)\n\ngoal (1 subgoal):\n 1. \\<exists>i'>i. enum_v i' = x", "hence \"infinite (prod_encode ` ?A)\""], ["proof (prove)\nusing this:\n  infinite\n   ({to_nat_on (\\<^bold>V - {source \\<Delta>, sink \\<Delta>}) x} \\<times>\n    UNIV)\n\ngoal (1 subgoal):\n 1. infinite\n     (prod_encode `\n      ({to_nat_on (\\<^bold>V - {source \\<Delta>, sink \\<Delta>}) x} \\<times>\n       UNIV))", "by(auto dest: finite_imageD simp add: inj_prod_encode)"], ["proof (state)\nthis:\n  infinite\n   (prod_encode `\n    ({to_nat_on (\\<^bold>V - {source \\<Delta>, sink \\<Delta>}) x} \\<times>\n     UNIV))\n\ngoal (1 subgoal):\n 1. \\<exists>i'>i. enum_v i' = x", "then"], ["proof (chain)\npicking this:\n  infinite\n   (prod_encode `\n    ({to_nat_on (\\<^bold>V - {source \\<Delta>, sink \\<Delta>}) x} \\<times>\n     UNIV))", "obtain i' where \"i' > i\" \"i' \\<in> prod_encode ` ?A\""], ["proof (prove)\nusing this:\n  infinite\n   (prod_encode `\n    ({to_nat_on (\\<^bold>V - {source \\<Delta>, sink \\<Delta>}) x} \\<times>\n     UNIV))\n\ngoal (1 subgoal):\n 1. (\\<And>i'.\n        \\<lbrakk>i < i';\n         i' \\<in> prod_encode `\n                  ({to_nat_on (\\<^bold>V - {source \\<Delta>, sink \\<Delta>})\n                     x} \\<times>\n                   UNIV)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding infinite_nat_iff_unbounded"], ["proof (prove)\nusing this:\n  \\<forall>m.\n     \\<exists>n>m.\n        n \\<in> prod_encode `\n                ({to_nat_on (\\<^bold>V - {source \\<Delta>, sink \\<Delta>})\n                   x} \\<times>\n                 UNIV)\n\ngoal (1 subgoal):\n 1. (\\<And>i'.\n        \\<lbrakk>i < i';\n         i' \\<in> prod_encode `\n                  ({to_nat_on (\\<^bold>V - {source \\<Delta>, sink \\<Delta>})\n                     x} \\<times>\n                   UNIV)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  i < i'\n  i' \\<in> prod_encode `\n           ({to_nat_on (\\<^bold>V - {source \\<Delta>, sink \\<Delta>})\n              x} \\<times>\n            UNIV)\n\ngoal (1 subgoal):\n 1. \\<exists>i'>i. enum_v i' = x", "from this(2)"], ["proof (chain)\npicking this:\n  i' \\<in> prod_encode `\n           ({to_nat_on (\\<^bold>V - {source \\<Delta>, sink \\<Delta>})\n              x} \\<times>\n            UNIV)", "have \"enum_v i' = x\""], ["proof (prove)\nusing this:\n  i' \\<in> prod_encode `\n           ({to_nat_on (\\<^bold>V - {source \\<Delta>, sink \\<Delta>})\n              x} \\<times>\n            UNIV)\n\ngoal (1 subgoal):\n 1. enum_v i' = x", "using x"], ["proof (prove)\nusing this:\n  i' \\<in> prod_encode `\n           ({to_nat_on (\\<^bold>V - {source \\<Delta>, sink \\<Delta>})\n              x} \\<times>\n            UNIV)\n  x \\<in> \\<^bold>V\n  x \\<noteq> source \\<Delta>\n  x \\<noteq> sink \\<Delta>\n\ngoal (1 subgoal):\n 1. enum_v i' = x", "by(clarsimp simp add: enum_v_def)"], ["proof (state)\nthis:\n  enum_v i' = x\n\ngoal (1 subgoal):\n 1. \\<exists>i'>i. enum_v i' = x", "with \\<open>i' > i\\<close>"], ["proof (chain)\npicking this:\n  i < i'\n  enum_v i' = x", "show ?thesis"], ["proof (prove)\nusing this:\n  i < i'\n  enum_v i' = x\n\ngoal (1 subgoal):\n 1. \\<exists>i'>i. enum_v i' = x", "by blast"], ["proof (state)\nthis:\n  \\<exists>i'>i. enum_v i' = x\n\ngoal:\nNo subgoals!", "qed"], ["", "fun h_plus :: \"nat \\<Rightarrow> 'v edge \\<Rightarrow> ennreal\"\nwhere\n  \"h_plus 0 (x, y) = (if x = source \\<Delta> then g (x, y) else 0)\"\n| \"h_plus (Suc i) (x, y) =\n  (if enum_v (Suc i) = x \\<and> d_OUT (h_plus i) x < d_IN (h_plus i) x then\n   let total = d_IN (h_plus i) x - d_OUT (h_plus i) x;\n       share = g (x, y) - h_plus i (x, y);\n       shares = d_OUT g x - d_OUT (h_plus i) x\n   in h_plus i (x, y) + share * total / shares\n   else h_plus i (x, y))\""], ["", "lemma h_plus_le_g: \"h_plus i e \\<le> g e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h_plus i e \\<le> g e", "proof(induction i arbitrary: e and e)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>e. h_plus 0 e \\<le> g e\n 2. \\<And>i e.\n       (\\<And>e. h_plus i e \\<le> g e) \\<Longrightarrow>\n       h_plus (Suc i) e \\<le> g e", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>e. h_plus 0 e \\<le> g e\n 2. \\<And>i e.\n       (\\<And>e. h_plus i e \\<le> g e) \\<Longrightarrow>\n       h_plus (Suc i) e \\<le> g e", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. h_plus 0 e \\<le> g e", "by(cases e) simp"], ["proof (state)\nthis:\n  h_plus 0 e \\<le> g e\n\ngoal (1 subgoal):\n 1. \\<And>i e.\n       (\\<And>e. h_plus i e \\<le> g e) \\<Longrightarrow>\n       h_plus (Suc i) e \\<le> g e", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i e.\n       (\\<And>e. h_plus i e \\<le> g e) \\<Longrightarrow>\n       h_plus (Suc i) e \\<le> g e", "case (Suc i)"], ["proof (state)\nthis:\n  h_plus i ?e \\<le> g ?e\n\ngoal (1 subgoal):\n 1. \\<And>i e.\n       (\\<And>e. h_plus i e \\<le> g e) \\<Longrightarrow>\n       h_plus (Suc i) e \\<le> g e", "{"], ["proof (state)\nthis:\n  h_plus i ?e \\<le> g ?e\n\ngoal (1 subgoal):\n 1. \\<And>i e.\n       (\\<And>e. h_plus i e \\<le> g e) \\<Longrightarrow>\n       h_plus (Suc i) e \\<le> g e", "fix x y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i e.\n       (\\<And>e. h_plus i e \\<le> g e) \\<Longrightarrow>\n       h_plus (Suc i) e \\<le> g e", "assume enum: \"x = enum_v (Suc i)\""], ["proof (state)\nthis:\n  x = enum_v (Suc i)\n\ngoal (1 subgoal):\n 1. \\<And>i e.\n       (\\<And>e. h_plus i e \\<le> g e) \\<Longrightarrow>\n       h_plus (Suc i) e \\<le> g e", "assume less: \"d_OUT (h_plus i) x < d_IN (h_plus i) x\""], ["proof (state)\nthis:\n  d_OUT (h_plus i) x < d_IN (h_plus i) x\n\ngoal (1 subgoal):\n 1. \\<And>i e.\n       (\\<And>e. h_plus i e \\<le> g e) \\<Longrightarrow>\n       h_plus (Suc i) e \\<le> g e", "from enum"], ["proof (chain)\npicking this:\n  x = enum_v (Suc i)", "have x: \"x \\<noteq> source \\<Delta>\" \"x \\<noteq> sink \\<Delta>\""], ["proof (prove)\nusing this:\n  x = enum_v (Suc i)\n\ngoal (1 subgoal):\n 1. x \\<noteq> source \\<Delta> &&& x \\<noteq> sink \\<Delta>", "using range_enum_v"], ["proof (prove)\nusing this:\n  x = enum_v (Suc i)\n  range enum_v \\<subseteq> \\<^bold>V - {source \\<Delta>, sink \\<Delta>}\n\ngoal (1 subgoal):\n 1. x \\<noteq> source \\<Delta> &&& x \\<noteq> sink \\<Delta>", "by(auto dest: sym intro: rev_image_eqI)"], ["proof (state)\nthis:\n  x \\<noteq> source \\<Delta>\n  x \\<noteq> sink \\<Delta>\n\ngoal (1 subgoal):\n 1. \\<And>i e.\n       (\\<And>e. h_plus i e \\<le> g e) \\<Longrightarrow>\n       h_plus (Suc i) e \\<le> g e", "define share where \"share = g (x, y) - h_plus i (x, y)\""], ["proof (state)\nthis:\n  share = g (x, y) - h_plus i (x, y)\n\ngoal (1 subgoal):\n 1. \\<And>i e.\n       (\\<And>e. h_plus i e \\<le> g e) \\<Longrightarrow>\n       h_plus (Suc i) e \\<le> g e", "define shares where \"shares = d_OUT g x - d_OUT (h_plus i) x\""], ["proof (state)\nthis:\n  shares = d_OUT g x - d_OUT (h_plus i) x\n\ngoal (1 subgoal):\n 1. \\<And>i e.\n       (\\<And>e. h_plus i e \\<le> g e) \\<Longrightarrow>\n       h_plus (Suc i) e \\<le> g e", "define total where \"total = d_IN (h_plus i) x - d_OUT (h_plus i) x\""], ["proof (state)\nthis:\n  total = d_IN (h_plus i) x - d_OUT (h_plus i) x\n\ngoal (1 subgoal):\n 1. \\<And>i e.\n       (\\<And>e. h_plus i e \\<le> g e) \\<Longrightarrow>\n       h_plus (Suc i) e \\<le> g e", "let ?h = \"h_plus i (x, y) + share * total / shares\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i e.\n       (\\<And>e. h_plus i e \\<le> g e) \\<Longrightarrow>\n       h_plus (Suc i) e \\<le> g e", "have \"d_OUT (h_plus i) x \\<le> d_OUT g x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT (h_plus i) x \\<le> d_OUT g x", "by(rule d_OUT_mono)(rule Suc.IH)"], ["proof (state)\nthis:\n  d_OUT (h_plus i) x \\<le> d_OUT g x\n\ngoal (1 subgoal):\n 1. \\<And>i e.\n       (\\<And>e. h_plus i e \\<le> g e) \\<Longrightarrow>\n       h_plus (Suc i) e \\<le> g e", "also"], ["proof (state)\nthis:\n  d_OUT (h_plus i) x \\<le> d_OUT g x\n\ngoal (1 subgoal):\n 1. \\<And>i e.\n       (\\<And>e. h_plus i e \\<le> g e) \\<Longrightarrow>\n       h_plus (Suc i) e \\<le> g e", "have \"\\<dots> < top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT g x < \\<top>", "using finite_OUT_g[of x] x"], ["proof (prove)\nusing this:\n  x \\<noteq> sink \\<Delta> \\<Longrightarrow> d_OUT g x \\<noteq> \\<top>\n  x \\<noteq> source \\<Delta>\n  x \\<noteq> sink \\<Delta>\n\ngoal (1 subgoal):\n 1. d_OUT g x < \\<top>", "by (simp add: less_top)"], ["proof (state)\nthis:\n  d_OUT g x < \\<top>\n\ngoal (1 subgoal):\n 1. \\<And>i e.\n       (\\<And>e. h_plus i e \\<le> g e) \\<Longrightarrow>\n       h_plus (Suc i) e \\<le> g e", "finally"], ["proof (chain)\npicking this:\n  d_OUT (h_plus i) x < \\<top>", "have \"d_OUT (h_plus i) x \\<noteq> \\<top>\""], ["proof (prove)\nusing this:\n  d_OUT (h_plus i) x < \\<top>\n\ngoal (1 subgoal):\n 1. d_OUT (h_plus i) x \\<noteq> \\<top>", "by simp"], ["proof (state)\nthis:\n  d_OUT (h_plus i) x \\<noteq> \\<top>\n\ngoal (1 subgoal):\n 1. \\<And>i e.\n       (\\<And>e. h_plus i e \\<le> g e) \\<Longrightarrow>\n       h_plus (Suc i) e \\<le> g e", "then"], ["proof (chain)\npicking this:\n  d_OUT (h_plus i) x \\<noteq> \\<top>", "have shares_eq: \"shares = (\\<Sum>\\<^sup>+ y. g (x, y) - h_plus i (x, y))\""], ["proof (prove)\nusing this:\n  d_OUT (h_plus i) x \\<noteq> \\<top>\n\ngoal (1 subgoal):\n 1. shares = (\\<Sum>\\<^sup>+ y. g (x, y) - h_plus i (x, y))", "unfolding shares_def d_OUT_def"], ["proof (prove)\nusing this:\n  (\\<Sum>\\<^sup>+ y. h_plus i (x, y)) \\<noteq> \\<top>\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y. g (x, y)) - (\\<Sum>\\<^sup>+ y. h_plus i (x, y)) =\n    (\\<Sum>\\<^sup>+ y. g (x, y) - h_plus i (x, y))", "by(subst nn_integral_diff)(simp_all add: AE_count_space Suc.IH)"], ["proof (state)\nthis:\n  shares = (\\<Sum>\\<^sup>+ y. g (x, y) - h_plus i (x, y))\n\ngoal (1 subgoal):\n 1. \\<And>i e.\n       (\\<And>e. h_plus i e \\<le> g e) \\<Longrightarrow>\n       h_plus (Suc i) e \\<le> g e", "have *: \"share / shares \\<le> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. share / shares \\<le> 1", "proof (cases \"share = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. share = 0 \\<Longrightarrow> share / shares \\<le> 1\n 2. share \\<noteq> 0 \\<Longrightarrow> share / shares \\<le> 1", "case True"], ["proof (state)\nthis:\n  share = 0\n\ngoal (2 subgoals):\n 1. share = 0 \\<Longrightarrow> share / shares \\<le> 1\n 2. share \\<noteq> 0 \\<Longrightarrow> share / shares \\<le> 1", "thus ?thesis"], ["proof (prove)\nusing this:\n  share = 0\n\ngoal (1 subgoal):\n 1. share / shares \\<le> 1", "by(simp)"], ["proof (state)\nthis:\n  share / shares \\<le> 1\n\ngoal (1 subgoal):\n 1. share \\<noteq> 0 \\<Longrightarrow> share / shares \\<le> 1", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. share \\<noteq> 0 \\<Longrightarrow> share / shares \\<le> 1", "case False"], ["proof (state)\nthis:\n  share \\<noteq> 0\n\ngoal (1 subgoal):\n 1. share \\<noteq> 0 \\<Longrightarrow> share / shares \\<le> 1", "hence \"share > 0\""], ["proof (prove)\nusing this:\n  share \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 0 < share", "using \\<open>h_plus i (x, y) \\<le> g _\\<close>"], ["proof (prove)\nusing this:\n  share \\<noteq> 0\n  h_plus i (x, y) \\<le> g (x, y)\n\ngoal (1 subgoal):\n 1. 0 < share", "by(simp add: share_def dual_order.strict_iff_order)"], ["proof (state)\nthis:\n  0 < share\n\ngoal (1 subgoal):\n 1. share \\<noteq> 0 \\<Longrightarrow> share / shares \\<le> 1", "moreover"], ["proof (state)\nthis:\n  0 < share\n\ngoal (1 subgoal):\n 1. share \\<noteq> 0 \\<Longrightarrow> share / shares \\<le> 1", "have \"share \\<le> shares\""], ["proof (prove)\ngoal (1 subgoal):\n 1. share \\<le> shares", "unfolding share_def shares_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. g (x, y) - h_plus i (x, y)\n    \\<le> (\\<Sum>\\<^sup>+ y. g (x, y) - h_plus i (x, y))", "by(rule nn_integral_ge_point)simp"], ["proof (state)\nthis:\n  share \\<le> shares\n\ngoal (1 subgoal):\n 1. share \\<noteq> 0 \\<Longrightarrow> share / shares \\<le> 1", "ultimately"], ["proof (chain)\npicking this:\n  0 < share\n  share \\<le> shares", "show ?thesis"], ["proof (prove)\nusing this:\n  0 < share\n  share \\<le> shares\n\ngoal (1 subgoal):\n 1. share / shares \\<le> 1", "by(simp add: divide_le_posI_ennreal)"], ["proof (state)\nthis:\n  share / shares \\<le> 1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  share / shares \\<le> 1\n\ngoal (1 subgoal):\n 1. \\<And>i e.\n       (\\<And>e. h_plus i e \\<le> g e) \\<Longrightarrow>\n       h_plus (Suc i) e \\<le> g e", "note shares_def"], ["proof (state)\nthis:\n  shares = d_OUT g x - d_OUT (h_plus i) x\n\ngoal (1 subgoal):\n 1. \\<And>i e.\n       (\\<And>e. h_plus i e \\<le> g e) \\<Longrightarrow>\n       h_plus (Suc i) e \\<le> g e", "also"], ["proof (state)\nthis:\n  shares = d_OUT g x - d_OUT (h_plus i) x\n\ngoal (1 subgoal):\n 1. \\<And>i e.\n       (\\<And>e. h_plus i e \\<le> g e) \\<Longrightarrow>\n       h_plus (Suc i) e \\<le> g e", "have \"d_OUT g x = d_IN g x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. KIR g x", "by(rule flowD_KIR[OF g x])"], ["proof (state)\nthis:\n  KIR g x\n\ngoal (1 subgoal):\n 1. \\<And>i e.\n       (\\<And>e. h_plus i e \\<le> g e) \\<Longrightarrow>\n       h_plus (Suc i) e \\<le> g e", "also"], ["proof (state)\nthis:\n  KIR g x\n\ngoal (1 subgoal):\n 1. \\<And>i e.\n       (\\<And>e. h_plus i e \\<le> g e) \\<Longrightarrow>\n       h_plus (Suc i) e \\<le> g e", "have \"d_IN (h_plus i) x \\<le> d_IN g x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN (h_plus i) x \\<le> d_IN g x", "by(rule d_IN_mono)(rule Suc.IH)"], ["proof (state)\nthis:\n  d_IN (h_plus i) x \\<le> d_IN g x\n\ngoal (1 subgoal):\n 1. \\<And>i e.\n       (\\<And>e. h_plus i e \\<le> g e) \\<Longrightarrow>\n       h_plus (Suc i) e \\<le> g e", "ultimately"], ["proof (chain)\npicking this:\n  shares = d_IN g x - d_OUT (h_plus i) x\n  d_IN (h_plus i) x \\<le> d_IN g x", "have *: \"total \\<le> shares\""], ["proof (prove)\nusing this:\n  shares = d_IN g x - d_OUT (h_plus i) x\n  d_IN (h_plus i) x \\<le> d_IN g x\n\ngoal (1 subgoal):\n 1. total \\<le> shares", "unfolding total_def"], ["proof (prove)\nusing this:\n  shares = d_IN g x - d_OUT (h_plus i) x\n  d_IN (h_plus i) x \\<le> d_IN g x\n\ngoal (1 subgoal):\n 1. d_IN (h_plus i) x - d_OUT (h_plus i) x \\<le> shares", "by(simp add: ennreal_minus_mono)"], ["proof (state)\nthis:\n  total \\<le> shares\n\ngoal (1 subgoal):\n 1. \\<And>i e.\n       (\\<And>e. h_plus i e \\<le> g e) \\<Longrightarrow>\n       h_plus (Suc i) e \\<le> g e", "moreover"], ["proof (state)\nthis:\n  total \\<le> shares\n\ngoal (1 subgoal):\n 1. \\<And>i e.\n       (\\<And>e. h_plus i e \\<le> g e) \\<Longrightarrow>\n       h_plus (Suc i) e \\<le> g e", "have \"total > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < total", "unfolding total_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < d_IN (h_plus i) x - d_OUT (h_plus i) x", "using less"], ["proof (prove)\nusing this:\n  d_OUT (h_plus i) x < d_IN (h_plus i) x\n\ngoal (1 subgoal):\n 1. 0 < d_IN (h_plus i) x - d_OUT (h_plus i) x", "by (clarsimp simp add: diff_gr0_ennreal)"], ["proof (state)\nthis:\n  0 < total\n\ngoal (1 subgoal):\n 1. \\<And>i e.\n       (\\<And>e. h_plus i e \\<le> g e) \\<Longrightarrow>\n       h_plus (Suc i) e \\<le> g e", "ultimately"], ["proof (chain)\npicking this:\n  total \\<le> shares\n  0 < total", "have \"total / shares \\<le> 1\""], ["proof (prove)\nusing this:\n  total \\<le> shares\n  0 < total\n\ngoal (1 subgoal):\n 1. total / shares \\<le> 1", "by(intro divide_le_posI_ennreal)(simp_all)"], ["proof (state)\nthis:\n  total / shares \\<le> 1\n\ngoal (1 subgoal):\n 1. \\<And>i e.\n       (\\<And>e. h_plus i e \\<le> g e) \\<Longrightarrow>\n       h_plus (Suc i) e \\<le> g e", "hence \"share * (total / shares) \\<le> share * 1\""], ["proof (prove)\nusing this:\n  total / shares \\<le> 1\n\ngoal (1 subgoal):\n 1. share * (total / shares) \\<le> share * 1", "by(rule mult_left_mono) simp"], ["proof (state)\nthis:\n  share * (total / shares) \\<le> share * 1\n\ngoal (1 subgoal):\n 1. \\<And>i e.\n       (\\<And>e. h_plus i e \\<le> g e) \\<Longrightarrow>\n       h_plus (Suc i) e \\<le> g e", "hence \"?h \\<le> h_plus i (x, y) + share\""], ["proof (prove)\nusing this:\n  share * (total / shares) \\<le> share * 1\n\ngoal (1 subgoal):\n 1. h_plus i (x, y) + share * total / shares \\<le> h_plus i (x, y) + share", "by(simp add: ennreal_times_divide add_mono)"], ["proof (state)\nthis:\n  h_plus i (x, y) + share * total / shares \\<le> h_plus i (x, y) + share\n\ngoal (1 subgoal):\n 1. \\<And>i e.\n       (\\<And>e. h_plus i e \\<le> g e) \\<Longrightarrow>\n       h_plus (Suc i) e \\<le> g e", "also"], ["proof (state)\nthis:\n  h_plus i (x, y) + share * total / shares \\<le> h_plus i (x, y) + share\n\ngoal (1 subgoal):\n 1. \\<And>i e.\n       (\\<And>e. h_plus i e \\<le> g e) \\<Longrightarrow>\n       h_plus (Suc i) e \\<le> g e", "have \"\\<dots> = g (x, y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h_plus i (x, y) + share = g (x, y)", "unfolding share_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. h_plus i (x, y) + (g (x, y) - h_plus i (x, y)) = g (x, y)", "using \\<open>h_plus i (x, y) \\<le> g _\\<close> finite_g[of \"(x, y)\"]"], ["proof (prove)\nusing this:\n  h_plus i (x, y) \\<le> g (x, y)\n  g (x, y) \\<noteq> \\<top>\n\ngoal (1 subgoal):\n 1. h_plus i (x, y) + (g (x, y) - h_plus i (x, y)) = g (x, y)", "by simp"], ["proof (state)\nthis:\n  h_plus i (x, y) + share = g (x, y)\n\ngoal (1 subgoal):\n 1. \\<And>i e.\n       (\\<And>e. h_plus i e \\<le> g e) \\<Longrightarrow>\n       h_plus (Suc i) e \\<le> g e", "moreover"], ["proof (state)\nthis:\n  h_plus i (x, y) + share = g (x, y)\n\ngoal (1 subgoal):\n 1. \\<And>i e.\n       (\\<And>e. h_plus i e \\<le> g e) \\<Longrightarrow>\n       h_plus (Suc i) e \\<le> g e", "note calculation"], ["proof (state)\nthis:\n  h_plus i (x, y) + share * total / shares \\<le> h_plus i (x, y) + share\n  h_plus i (x, y) + share = g (x, y)\n\ngoal (1 subgoal):\n 1. \\<And>i e.\n       (\\<And>e. h_plus i e \\<le> g e) \\<Longrightarrow>\n       h_plus (Suc i) e \\<le> g e", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?x2 = enum_v (Suc i);\n   d_OUT (h_plus i) ?x2 < d_IN (h_plus i) ?x2\\<rbrakk>\n  \\<Longrightarrow> h_plus i (?x2, ?y2) +\n                    (g (?x2, ?y2) - h_plus i (?x2, ?y2)) *\n                    (d_IN (h_plus i) ?x2 - d_OUT (h_plus i) ?x2) /\n                    (d_OUT g ?x2 - d_OUT (h_plus i) ?x2)\n                    \\<le> h_plus i (?x2, ?y2) +\n                          (g (?x2, ?y2) - h_plus i (?x2, ?y2))\n  \\<lbrakk>?x2 = enum_v (Suc i);\n   d_OUT (h_plus i) ?x2 < d_IN (h_plus i) ?x2\\<rbrakk>\n  \\<Longrightarrow> h_plus i (?x2, ?y2) +\n                    (g (?x2, ?y2) - h_plus i (?x2, ?y2)) =\n                    g (?x2, ?y2)\n\ngoal (1 subgoal):\n 1. \\<And>i e.\n       (\\<And>e. h_plus i e \\<le> g e) \\<Longrightarrow>\n       h_plus (Suc i) e \\<le> g e", "note * = this"], ["proof (state)\nthis:\n  \\<lbrakk>?x2 = enum_v (Suc i);\n   d_OUT (h_plus i) ?x2 < d_IN (h_plus i) ?x2\\<rbrakk>\n  \\<Longrightarrow> h_plus i (?x2, ?y2) +\n                    (g (?x2, ?y2) - h_plus i (?x2, ?y2)) *\n                    (d_IN (h_plus i) ?x2 - d_OUT (h_plus i) ?x2) /\n                    (d_OUT g ?x2 - d_OUT (h_plus i) ?x2)\n                    \\<le> h_plus i (?x2, ?y2) +\n                          (g (?x2, ?y2) - h_plus i (?x2, ?y2))\n  \\<lbrakk>?x2 = enum_v (Suc i);\n   d_OUT (h_plus i) ?x2 < d_IN (h_plus i) ?x2\\<rbrakk>\n  \\<Longrightarrow> h_plus i (?x2, ?y2) +\n                    (g (?x2, ?y2) - h_plus i (?x2, ?y2)) =\n                    g (?x2, ?y2)\n\ngoal (1 subgoal):\n 1. \\<And>i e.\n       (\\<And>e. h_plus i e \\<le> g e) \\<Longrightarrow>\n       h_plus (Suc i) e \\<le> g e", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. h_plus (Suc i) e \\<le> g e", "using Suc.IH *"], ["proof (prove)\nusing this:\n  h_plus i ?e \\<le> g ?e\n  \\<lbrakk>?x2 = enum_v (Suc i);\n   d_OUT (h_plus i) ?x2 < d_IN (h_plus i) ?x2\\<rbrakk>\n  \\<Longrightarrow> h_plus i (?x2, ?y2) +\n                    (g (?x2, ?y2) - h_plus i (?x2, ?y2)) *\n                    (d_IN (h_plus i) ?x2 - d_OUT (h_plus i) ?x2) /\n                    (d_OUT g ?x2 - d_OUT (h_plus i) ?x2)\n                    \\<le> h_plus i (?x2, ?y2) +\n                          (g (?x2, ?y2) - h_plus i (?x2, ?y2))\n  \\<lbrakk>?x2 = enum_v (Suc i);\n   d_OUT (h_plus i) ?x2 < d_IN (h_plus i) ?x2\\<rbrakk>\n  \\<Longrightarrow> h_plus i (?x2, ?y2) +\n                    (g (?x2, ?y2) - h_plus i (?x2, ?y2)) =\n                    g (?x2, ?y2)\n\ngoal (1 subgoal):\n 1. h_plus (Suc i) e \\<le> g e", "by(cases e) clarsimp"], ["proof (state)\nthis:\n  h_plus (Suc i) e \\<le> g e\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma h_plus_outside: \"e \\<notin> \\<^bold>E \\<Longrightarrow> h_plus i e = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. e \\<notin> \\<^bold>E \\<Longrightarrow> h_plus i e = 0", "by (metis g_outside h_plus_le_g le_zero_eq)"], ["", "lemma h_plus_not_infty [simp]: \"h_plus i e \\<noteq> top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h_plus i e \\<noteq> \\<top>", "using h_plus_le_g[of i e]"], ["proof (prove)\nusing this:\n  h_plus i e \\<le> g e\n\ngoal (1 subgoal):\n 1. h_plus i e \\<noteq> \\<top>", "by (auto simp: top_unique)"], ["", "lemma h_plus_mono: \"h_plus i e \\<le> h_plus (Suc i) e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h_plus i e \\<le> h_plus (Suc i) e", "proof(cases e)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       e = (a, b) \\<Longrightarrow> h_plus i e \\<le> h_plus (Suc i) e", "case [simp]: (Pair x y)"], ["proof (state)\nthis:\n  e = (x, y)\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       e = (a, b) \\<Longrightarrow> h_plus i e \\<le> h_plus (Suc i) e", "{"], ["proof (state)\nthis:\n  e = (x, y)\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       e = (a, b) \\<Longrightarrow> h_plus i e \\<le> h_plus (Suc i) e", "assume \"d_OUT (h_plus i) x < d_IN (h_plus i) x\""], ["proof (state)\nthis:\n  d_OUT (h_plus i) x < d_IN (h_plus i) x\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       e = (a, b) \\<Longrightarrow> h_plus i e \\<le> h_plus (Suc i) e", "hence \"h_plus i (x, y) + 0 \\<le> h_plus i (x, y) + (g (x, y) - h_plus i (x, y)) * (d_IN (h_plus i) x - d_OUT (h_plus i) x) / (d_OUT g x - d_OUT (h_plus i) x)\""], ["proof (prove)\nusing this:\n  d_OUT (h_plus i) x < d_IN (h_plus i) x\n\ngoal (1 subgoal):\n 1. h_plus i (x, y) + 0\n    \\<le> h_plus i (x, y) +\n          (g (x, y) - h_plus i (x, y)) *\n          (d_IN (h_plus i) x - d_OUT (h_plus i) x) /\n          (d_OUT g x - d_OUT (h_plus i) x)", "by(intro add_left_mono d_OUT_mono le_funI) (simp_all add: h_plus_le_g)"], ["proof (state)\nthis:\n  h_plus i (x, y) + 0\n  \\<le> h_plus i (x, y) +\n        (g (x, y) - h_plus i (x, y)) *\n        (d_IN (h_plus i) x - d_OUT (h_plus i) x) /\n        (d_OUT g x - d_OUT (h_plus i) x)\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       e = (a, b) \\<Longrightarrow> h_plus i e \\<le> h_plus (Suc i) e", "}"], ["proof (state)\nthis:\n  d_OUT (h_plus i) x < d_IN (h_plus i) x \\<Longrightarrow>\n  h_plus i (x, y) + 0\n  \\<le> h_plus i (x, y) +\n        (g (x, y) - h_plus i (x, y)) *\n        (d_IN (h_plus i) x - d_OUT (h_plus i) x) /\n        (d_OUT g x - d_OUT (h_plus i) x)\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       e = (a, b) \\<Longrightarrow> h_plus i e \\<le> h_plus (Suc i) e", "then"], ["proof (chain)\npicking this:\n  d_OUT (h_plus i) x < d_IN (h_plus i) x \\<Longrightarrow>\n  h_plus i (x, y) + 0\n  \\<le> h_plus i (x, y) +\n        (g (x, y) - h_plus i (x, y)) *\n        (d_IN (h_plus i) x - d_OUT (h_plus i) x) /\n        (d_OUT g x - d_OUT (h_plus i) x)", "show ?thesis"], ["proof (prove)\nusing this:\n  d_OUT (h_plus i) x < d_IN (h_plus i) x \\<Longrightarrow>\n  h_plus i (x, y) + 0\n  \\<le> h_plus i (x, y) +\n        (g (x, y) - h_plus i (x, y)) *\n        (d_IN (h_plus i) x - d_OUT (h_plus i) x) /\n        (d_OUT g x - d_OUT (h_plus i) x)\n\ngoal (1 subgoal):\n 1. h_plus i e \\<le> h_plus (Suc i) e", "by clarsimp"], ["proof (state)\nthis:\n  h_plus i e \\<le> h_plus (Suc i) e\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma h_plus_mono': \"i \\<le> j \\<Longrightarrow> h_plus i e \\<le> h_plus j e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<le> j \\<Longrightarrow> h_plus i e \\<le> h_plus j e", "by(induction rule: dec_induct)(auto intro: h_plus_mono order_trans)"], ["", "lemma d_OUT_h_plus_not_infty': \"x \\<noteq> sink \\<Delta> \\<Longrightarrow> d_OUT (h_plus i) x \\<noteq> top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<noteq> sink \\<Delta> \\<Longrightarrow>\n    d_OUT (h_plus i) x \\<noteq> \\<top>", "using d_OUT_mono[of \"h_plus i\" x g, OF h_plus_le_g] finite_OUT_g[of x]"], ["proof (prove)\nusing this:\n  d_OUT (h_plus i) x \\<le> d_OUT g x\n  x \\<noteq> sink \\<Delta> \\<Longrightarrow> d_OUT g x \\<noteq> \\<top>\n\ngoal (1 subgoal):\n 1. x \\<noteq> sink \\<Delta> \\<Longrightarrow>\n    d_OUT (h_plus i) x \\<noteq> \\<top>", "by (auto simp: top_unique)"], ["", "lemma h_plus_OUT_le_IN:\n  assumes \"x \\<noteq> source \\<Delta>\"\n  shows \"d_OUT (h_plus i) x \\<le> d_IN (h_plus i) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT (h_plus i) x \\<le> d_IN (h_plus i) x", "proof(induction i)"], ["proof (state)\ngoal (2 subgoals):\n 1. d_OUT (h_plus 0) x \\<le> d_IN (h_plus 0) x\n 2. \\<And>i.\n       d_OUT (h_plus i) x \\<le> d_IN (h_plus i) x \\<Longrightarrow>\n       d_OUT (h_plus (Suc i)) x \\<le> d_IN (h_plus (Suc i)) x", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. d_OUT (h_plus 0) x \\<le> d_IN (h_plus 0) x\n 2. \\<And>i.\n       d_OUT (h_plus i) x \\<le> d_IN (h_plus i) x \\<Longrightarrow>\n       d_OUT (h_plus (Suc i)) x \\<le> d_IN (h_plus (Suc i)) x", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT (h_plus 0) x \\<le> d_IN (h_plus 0) x", "using assms"], ["proof (prove)\nusing this:\n  x \\<noteq> source \\<Delta>\n\ngoal (1 subgoal):\n 1. d_OUT (h_plus 0) x \\<le> d_IN (h_plus 0) x", "by(simp add: d_OUT_def)"], ["proof (state)\nthis:\n  d_OUT (h_plus 0) x \\<le> d_IN (h_plus 0) x\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       d_OUT (h_plus i) x \\<le> d_IN (h_plus i) x \\<Longrightarrow>\n       d_OUT (h_plus (Suc i)) x \\<le> d_IN (h_plus (Suc i)) x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       d_OUT (h_plus i) x \\<le> d_IN (h_plus i) x \\<Longrightarrow>\n       d_OUT (h_plus (Suc i)) x \\<le> d_IN (h_plus (Suc i)) x", "case (Suc i)"], ["proof (state)\nthis:\n  d_OUT (h_plus i) x \\<le> d_IN (h_plus i) x\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       d_OUT (h_plus i) x \\<le> d_IN (h_plus i) x \\<Longrightarrow>\n       d_OUT (h_plus (Suc i)) x \\<le> d_IN (h_plus (Suc i)) x", "have \"d_OUT (h_plus (Suc i)) x \\<le> d_IN (h_plus i) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT (h_plus (Suc i)) x \\<le> d_IN (h_plus i) x", "proof(cases \"enum_v (Suc i) = x \\<and> d_OUT (h_plus i) x < d_IN (h_plus i) x\")"], ["proof (state)\ngoal (2 subgoals):\n 1. enum_v (Suc i) = x \\<and>\n    d_OUT (h_plus i) x < d_IN (h_plus i) x \\<Longrightarrow>\n    d_OUT (h_plus (Suc i)) x \\<le> d_IN (h_plus i) x\n 2. \\<not> (enum_v (Suc i) = x \\<and>\n            d_OUT (h_plus i) x < d_IN (h_plus i) x) \\<Longrightarrow>\n    d_OUT (h_plus (Suc i)) x \\<le> d_IN (h_plus i) x", "case False"], ["proof (state)\nthis:\n  \\<not> (enum_v (Suc i) = x \\<and> d_OUT (h_plus i) x < d_IN (h_plus i) x)\n\ngoal (2 subgoals):\n 1. enum_v (Suc i) = x \\<and>\n    d_OUT (h_plus i) x < d_IN (h_plus i) x \\<Longrightarrow>\n    d_OUT (h_plus (Suc i)) x \\<le> d_IN (h_plus i) x\n 2. \\<not> (enum_v (Suc i) = x \\<and>\n            d_OUT (h_plus i) x < d_IN (h_plus i) x) \\<Longrightarrow>\n    d_OUT (h_plus (Suc i)) x \\<le> d_IN (h_plus i) x", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> (enum_v (Suc i) = x \\<and> d_OUT (h_plus i) x < d_IN (h_plus i) x)\n\ngoal (1 subgoal):\n 1. d_OUT (h_plus (Suc i)) x \\<le> d_IN (h_plus i) x", "using Suc.IH"], ["proof (prove)\nusing this:\n  \\<not> (enum_v (Suc i) = x \\<and> d_OUT (h_plus i) x < d_IN (h_plus i) x)\n  d_OUT (h_plus i) x \\<le> d_IN (h_plus i) x\n\ngoal (1 subgoal):\n 1. d_OUT (h_plus (Suc i)) x \\<le> d_IN (h_plus i) x", "by(simp add: d_OUT_def cong: conj_cong)"], ["proof (state)\nthis:\n  d_OUT (h_plus (Suc i)) x \\<le> d_IN (h_plus i) x\n\ngoal (1 subgoal):\n 1. enum_v (Suc i) = x \\<and>\n    d_OUT (h_plus i) x < d_IN (h_plus i) x \\<Longrightarrow>\n    d_OUT (h_plus (Suc i)) x \\<le> d_IN (h_plus i) x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. enum_v (Suc i) = x \\<and>\n    d_OUT (h_plus i) x < d_IN (h_plus i) x \\<Longrightarrow>\n    d_OUT (h_plus (Suc i)) x \\<le> d_IN (h_plus i) x", "case True"], ["proof (state)\nthis:\n  enum_v (Suc i) = x \\<and> d_OUT (h_plus i) x < d_IN (h_plus i) x\n\ngoal (1 subgoal):\n 1. enum_v (Suc i) = x \\<and>\n    d_OUT (h_plus i) x < d_IN (h_plus i) x \\<Longrightarrow>\n    d_OUT (h_plus (Suc i)) x \\<le> d_IN (h_plus i) x", "hence x: \"x \\<noteq> sink \\<Delta>\" and le: \"d_OUT (h_plus i) x < d_IN (h_plus i) x\""], ["proof (prove)\nusing this:\n  enum_v (Suc i) = x \\<and> d_OUT (h_plus i) x < d_IN (h_plus i) x\n\ngoal (1 subgoal):\n 1. x \\<noteq> sink \\<Delta> &&& d_OUT (h_plus i) x < d_IN (h_plus i) x", "using range_enum_v"], ["proof (prove)\nusing this:\n  enum_v (Suc i) = x \\<and> d_OUT (h_plus i) x < d_IN (h_plus i) x\n  range enum_v \\<subseteq> \\<^bold>V - {source \\<Delta>, sink \\<Delta>}\n\ngoal (1 subgoal):\n 1. x \\<noteq> sink \\<Delta> &&& d_OUT (h_plus i) x < d_IN (h_plus i) x", "by auto"], ["proof (state)\nthis:\n  x \\<noteq> sink \\<Delta>\n  d_OUT (h_plus i) x < d_IN (h_plus i) x\n\ngoal (1 subgoal):\n 1. enum_v (Suc i) = x \\<and>\n    d_OUT (h_plus i) x < d_IN (h_plus i) x \\<Longrightarrow>\n    d_OUT (h_plus (Suc i)) x \\<le> d_IN (h_plus i) x", "let ?r = \"\\<lambda>y. (g (x, y) - h_plus i (x, y)) * (d_IN (h_plus i) x - d_OUT (h_plus i) x) / (d_OUT g x - d_OUT (h_plus i) x)\""], ["proof (state)\ngoal (1 subgoal):\n 1. enum_v (Suc i) = x \\<and>\n    d_OUT (h_plus i) x < d_IN (h_plus i) x \\<Longrightarrow>\n    d_OUT (h_plus (Suc i)) x \\<le> d_IN (h_plus i) x", "have \"d_OUT (h_plus (Suc i)) x = d_OUT (h_plus i) x + (\\<Sum>\\<^sup>+ y. ?r y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT (h_plus (Suc i)) x =\n    d_OUT (h_plus i) x +\n    (\\<Sum>\\<^sup>+ y.\n       (g (x, y) - h_plus i (x, y)) *\n       (d_IN (h_plus i) x - d_OUT (h_plus i) x) /\n       (d_OUT g x - d_OUT (h_plus i) x))", "using True"], ["proof (prove)\nusing this:\n  enum_v (Suc i) = x \\<and> d_OUT (h_plus i) x < d_IN (h_plus i) x\n\ngoal (1 subgoal):\n 1. d_OUT (h_plus (Suc i)) x =\n    d_OUT (h_plus i) x +\n    (\\<Sum>\\<^sup>+ y.\n       (g (x, y) - h_plus i (x, y)) *\n       (d_IN (h_plus i) x - d_OUT (h_plus i) x) /\n       (d_OUT g x - d_OUT (h_plus i) x))", "unfolding d_OUT_def h_plus.simps"], ["proof (prove)\nusing this:\n  enum_v (Suc i) = x \\<and>\n  (\\<Sum>\\<^sup>+ y. h_plus i (x, y)) < d_IN (h_plus i) x\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y.\n       if enum_v (Suc i) = x \\<and>\n          (\\<Sum>\\<^sup>+ y. h_plus i (x, y)) < d_IN (h_plus i) x\n       then let total =\n                  d_IN (h_plus i) x - (\\<Sum>\\<^sup>+ y. h_plus i (x, y));\n                share = g (x, y) - h_plus i (x, y);\n                shares =\n                  (\\<Sum>\\<^sup>+ y. g (x, y)) -\n                  (\\<Sum>\\<^sup>+ y. h_plus i (x, y))\n            in h_plus i (x, y) + share * total / shares\n       else h_plus i (x, y)) =\n    (\\<Sum>\\<^sup>+ y. h_plus i (x, y)) +\n    (\\<Sum>\\<^sup>+ y.\n       (g (x, y) - h_plus i (x, y)) *\n       (d_IN (h_plus i) x - (\\<Sum>\\<^sup>+ y. h_plus i (x, y))) /\n       ((\\<Sum>\\<^sup>+ y. g (x, y)) - (\\<Sum>\\<^sup>+ y. h_plus i (x, y))))", "by(simp add: AE_count_space nn_integral_add)"], ["proof (state)\nthis:\n  d_OUT (h_plus (Suc i)) x =\n  d_OUT (h_plus i) x +\n  (\\<Sum>\\<^sup>+ y.\n     (g (x, y) - h_plus i (x, y)) *\n     (d_IN (h_plus i) x - d_OUT (h_plus i) x) /\n     (d_OUT g x - d_OUT (h_plus i) x))\n\ngoal (1 subgoal):\n 1. enum_v (Suc i) = x \\<and>\n    d_OUT (h_plus i) x < d_IN (h_plus i) x \\<Longrightarrow>\n    d_OUT (h_plus (Suc i)) x \\<le> d_IN (h_plus i) x", "also"], ["proof (state)\nthis:\n  d_OUT (h_plus (Suc i)) x =\n  d_OUT (h_plus i) x +\n  (\\<Sum>\\<^sup>+ y.\n     (g (x, y) - h_plus i (x, y)) *\n     (d_IN (h_plus i) x - d_OUT (h_plus i) x) /\n     (d_OUT g x - d_OUT (h_plus i) x))\n\ngoal (1 subgoal):\n 1. enum_v (Suc i) = x \\<and>\n    d_OUT (h_plus i) x < d_IN (h_plus i) x \\<Longrightarrow>\n    d_OUT (h_plus (Suc i)) x \\<le> d_IN (h_plus i) x", "from True"], ["proof (chain)\npicking this:\n  enum_v (Suc i) = x \\<and> d_OUT (h_plus i) x < d_IN (h_plus i) x", "have \"x \\<noteq> source \\<Delta>\" \"x \\<noteq> sink \\<Delta>\""], ["proof (prove)\nusing this:\n  enum_v (Suc i) = x \\<and> d_OUT (h_plus i) x < d_IN (h_plus i) x\n\ngoal (1 subgoal):\n 1. x \\<noteq> source \\<Delta> &&& x \\<noteq> sink \\<Delta>", "using range_enum_v"], ["proof (prove)\nusing this:\n  enum_v (Suc i) = x \\<and> d_OUT (h_plus i) x < d_IN (h_plus i) x\n  range enum_v \\<subseteq> \\<^bold>V - {source \\<Delta>, sink \\<Delta>}\n\ngoal (1 subgoal):\n 1. x \\<noteq> source \\<Delta> &&& x \\<noteq> sink \\<Delta>", "by auto"], ["proof (state)\nthis:\n  x \\<noteq> source \\<Delta>\n  x \\<noteq> sink \\<Delta>\n\ngoal (1 subgoal):\n 1. enum_v (Suc i) = x \\<and>\n    d_OUT (h_plus i) x < d_IN (h_plus i) x \\<Longrightarrow>\n    d_OUT (h_plus (Suc i)) x \\<le> d_IN (h_plus i) x", "from flowD_KIR[OF g this] le d_IN_mono[of \"h_plus i\" x g, OF h_plus_le_g]"], ["proof (chain)\npicking this:\n  KIR g x\n  d_OUT (h_plus i) x < d_IN (h_plus i) x\n  d_IN (h_plus i) x \\<le> d_IN g x", "have le': \"d_OUT (h_plus i) x < d_OUT g x\""], ["proof (prove)\nusing this:\n  KIR g x\n  d_OUT (h_plus i) x < d_IN (h_plus i) x\n  d_IN (h_plus i) x \\<le> d_IN g x\n\ngoal (1 subgoal):\n 1. d_OUT (h_plus i) x < d_OUT g x", "by(simp)"], ["proof (state)\nthis:\n  d_OUT (h_plus i) x < d_OUT g x\n\ngoal (1 subgoal):\n 1. enum_v (Suc i) = x \\<and>\n    d_OUT (h_plus i) x < d_IN (h_plus i) x \\<Longrightarrow>\n    d_OUT (h_plus (Suc i)) x \\<le> d_IN (h_plus i) x", "then"], ["proof (chain)\npicking this:\n  d_OUT (h_plus i) x < d_OUT g x", "have \"(\\<Sum>\\<^sup>+ y. ?r y) =\n      (d_IN (h_plus i) x - d_OUT (h_plus i) x) * ((\\<Sum>\\<^sup>+ y. g (x, y) - h_plus i (x, y)) / (d_OUT g x - d_OUT (h_plus i) x))\""], ["proof (prove)\nusing this:\n  d_OUT (h_plus i) x < d_OUT g x\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y.\n       (g (x, y) - h_plus i (x, y)) *\n       (d_IN (h_plus i) x - d_OUT (h_plus i) x) /\n       (d_OUT g x - d_OUT (h_plus i) x)) =\n    (d_IN (h_plus i) x - d_OUT (h_plus i) x) *\n    ((\\<Sum>\\<^sup>+ y. g (x, y) - h_plus i (x, y)) /\n     (d_OUT g x - d_OUT (h_plus i) x))", "by(subst mult.commute, subst ennreal_times_divide[symmetric])\n        (simp add: nn_integral_cmult nn_integral_divide Suc.IH diff_gr0_ennreal)"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y.\n     (g (x, y) - h_plus i (x, y)) *\n     (d_IN (h_plus i) x - d_OUT (h_plus i) x) /\n     (d_OUT g x - d_OUT (h_plus i) x)) =\n  (d_IN (h_plus i) x - d_OUT (h_plus i) x) *\n  ((\\<Sum>\\<^sup>+ y. g (x, y) - h_plus i (x, y)) /\n   (d_OUT g x - d_OUT (h_plus i) x))\n\ngoal (1 subgoal):\n 1. enum_v (Suc i) = x \\<and>\n    d_OUT (h_plus i) x < d_IN (h_plus i) x \\<Longrightarrow>\n    d_OUT (h_plus (Suc i)) x \\<le> d_IN (h_plus i) x", "also"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y.\n     (g (x, y) - h_plus i (x, y)) *\n     (d_IN (h_plus i) x - d_OUT (h_plus i) x) /\n     (d_OUT g x - d_OUT (h_plus i) x)) =\n  (d_IN (h_plus i) x - d_OUT (h_plus i) x) *\n  ((\\<Sum>\\<^sup>+ y. g (x, y) - h_plus i (x, y)) /\n   (d_OUT g x - d_OUT (h_plus i) x))\n\ngoal (1 subgoal):\n 1. enum_v (Suc i) = x \\<and>\n    d_OUT (h_plus i) x < d_IN (h_plus i) x \\<Longrightarrow>\n    d_OUT (h_plus (Suc i)) x \\<le> d_IN (h_plus i) x", "have \"(\\<Sum>\\<^sup>+ y. g (x, y) - h_plus i (x, y)) = d_OUT g x - d_OUT (h_plus i) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y. g (x, y) - h_plus i (x, y)) =\n    d_OUT g x - d_OUT (h_plus i) x", "using x"], ["proof (prove)\nusing this:\n  x \\<noteq> sink \\<Delta>\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y. g (x, y) - h_plus i (x, y)) =\n    d_OUT g x - d_OUT (h_plus i) x", "by(subst nn_integral_diff)(simp_all add: d_OUT_def[symmetric] h_plus_le_g d_OUT_h_plus_not_infty')"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y. g (x, y) - h_plus i (x, y)) =\n  d_OUT g x - d_OUT (h_plus i) x\n\ngoal (1 subgoal):\n 1. enum_v (Suc i) = x \\<and>\n    d_OUT (h_plus i) x < d_IN (h_plus i) x \\<Longrightarrow>\n    d_OUT (h_plus (Suc i)) x \\<le> d_IN (h_plus i) x", "also"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y. g (x, y) - h_plus i (x, y)) =\n  d_OUT g x - d_OUT (h_plus i) x\n\ngoal (1 subgoal):\n 1. enum_v (Suc i) = x \\<and>\n    d_OUT (h_plus i) x < d_IN (h_plus i) x \\<Longrightarrow>\n    d_OUT (h_plus (Suc i)) x \\<le> d_IN (h_plus i) x", "have \"\\<dots> / \\<dots> = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (d_OUT g x - d_OUT (h_plus i) x) / (d_OUT g x - d_OUT (h_plus i) x) = 1", "using le' finite_OUT_g[of x] x"], ["proof (prove)\nusing this:\n  d_OUT (h_plus i) x < d_OUT g x\n  x \\<noteq> sink \\<Delta> \\<Longrightarrow> d_OUT g x \\<noteq> \\<top>\n  x \\<noteq> sink \\<Delta>\n\ngoal (1 subgoal):\n 1. (d_OUT g x - d_OUT (h_plus i) x) / (d_OUT g x - d_OUT (h_plus i) x) = 1", "by(auto intro!: ennreal_divide_self dest: diff_gr0_ennreal simp: less_top[symmetric])"], ["proof (state)\nthis:\n  (d_OUT g x - d_OUT (h_plus i) x) / (d_OUT g x - d_OUT (h_plus i) x) = 1\n\ngoal (1 subgoal):\n 1. enum_v (Suc i) = x \\<and>\n    d_OUT (h_plus i) x < d_IN (h_plus i) x \\<Longrightarrow>\n    d_OUT (h_plus (Suc i)) x \\<le> d_IN (h_plus i) x", "also"], ["proof (state)\nthis:\n  (d_OUT g x - d_OUT (h_plus i) x) / (d_OUT g x - d_OUT (h_plus i) x) = 1\n\ngoal (1 subgoal):\n 1. enum_v (Suc i) = x \\<and>\n    d_OUT (h_plus i) x < d_IN (h_plus i) x \\<Longrightarrow>\n    d_OUT (h_plus (Suc i)) x \\<le> d_IN (h_plus i) x", "have \"d_OUT (h_plus i) x + (d_IN (h_plus i) x - d_OUT (h_plus i) x) * 1 = d_IN (h_plus i) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT (h_plus i) x + (d_IN (h_plus i) x - d_OUT (h_plus i) x) * 1 =\n    d_IN (h_plus i) x", "using x"], ["proof (prove)\nusing this:\n  x \\<noteq> sink \\<Delta>\n\ngoal (1 subgoal):\n 1. d_OUT (h_plus i) x + (d_IN (h_plus i) x - d_OUT (h_plus i) x) * 1 =\n    d_IN (h_plus i) x", "by (simp add: Suc)"], ["proof (state)\nthis:\n  d_OUT (h_plus i) x + (d_IN (h_plus i) x - d_OUT (h_plus i) x) * 1 =\n  d_IN (h_plus i) x\n\ngoal (1 subgoal):\n 1. enum_v (Suc i) = x \\<and>\n    d_OUT (h_plus i) x < d_IN (h_plus i) x \\<Longrightarrow>\n    d_OUT (h_plus (Suc i)) x \\<le> d_IN (h_plus i) x", "finally"], ["proof (chain)\npicking this:\n  d_OUT (h_plus (Suc i)) x = d_IN (h_plus i) x", "show ?thesis"], ["proof (prove)\nusing this:\n  d_OUT (h_plus (Suc i)) x = d_IN (h_plus i) x\n\ngoal (1 subgoal):\n 1. d_OUT (h_plus (Suc i)) x \\<le> d_IN (h_plus i) x", "by simp"], ["proof (state)\nthis:\n  d_OUT (h_plus (Suc i)) x \\<le> d_IN (h_plus i) x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  d_OUT (h_plus (Suc i)) x \\<le> d_IN (h_plus i) x\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       d_OUT (h_plus i) x \\<le> d_IN (h_plus i) x \\<Longrightarrow>\n       d_OUT (h_plus (Suc i)) x \\<le> d_IN (h_plus (Suc i)) x", "also"], ["proof (state)\nthis:\n  d_OUT (h_plus (Suc i)) x \\<le> d_IN (h_plus i) x\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       d_OUT (h_plus i) x \\<le> d_IN (h_plus i) x \\<Longrightarrow>\n       d_OUT (h_plus (Suc i)) x \\<le> d_IN (h_plus (Suc i)) x", "have \"\\<dots> \\<le> d_IN (h_plus (Suc i)) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN (h_plus i) x \\<le> d_IN (h_plus (Suc i)) x", "by(rule d_IN_mono)(rule h_plus_mono)"], ["proof (state)\nthis:\n  d_IN (h_plus i) x \\<le> d_IN (h_plus (Suc i)) x\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       d_OUT (h_plus i) x \\<le> d_IN (h_plus i) x \\<Longrightarrow>\n       d_OUT (h_plus (Suc i)) x \\<le> d_IN (h_plus (Suc i)) x", "finally"], ["proof (chain)\npicking this:\n  d_OUT (h_plus (Suc i)) x \\<le> d_IN (h_plus (Suc i)) x", "show ?case"], ["proof (prove)\nusing this:\n  d_OUT (h_plus (Suc i)) x \\<le> d_IN (h_plus (Suc i)) x\n\ngoal (1 subgoal):\n 1. d_OUT (h_plus (Suc i)) x \\<le> d_IN (h_plus (Suc i)) x", "."], ["proof (state)\nthis:\n  d_OUT (h_plus (Suc i)) x \\<le> d_IN (h_plus (Suc i)) x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma h_plus_OUT_eq_IN:\n  assumes enum: \"enum_v (Suc i) = x\"\n  shows \"d_OUT (h_plus (Suc i)) x = d_IN (h_plus i) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT (h_plus (Suc i)) x = d_IN (h_plus i) x", "proof(cases \"d_OUT (h_plus i) x < d_IN (h_plus i) x\")"], ["proof (state)\ngoal (2 subgoals):\n 1. d_OUT (h_plus i) x < d_IN (h_plus i) x \\<Longrightarrow>\n    d_OUT (h_plus (Suc i)) x = d_IN (h_plus i) x\n 2. \\<not> d_OUT (h_plus i) x < d_IN (h_plus i) x \\<Longrightarrow>\n    d_OUT (h_plus (Suc i)) x = d_IN (h_plus i) x", "case False"], ["proof (state)\nthis:\n  \\<not> d_OUT (h_plus i) x < d_IN (h_plus i) x\n\ngoal (2 subgoals):\n 1. d_OUT (h_plus i) x < d_IN (h_plus i) x \\<Longrightarrow>\n    d_OUT (h_plus (Suc i)) x = d_IN (h_plus i) x\n 2. \\<not> d_OUT (h_plus i) x < d_IN (h_plus i) x \\<Longrightarrow>\n    d_OUT (h_plus (Suc i)) x = d_IN (h_plus i) x", "from enum"], ["proof (chain)\npicking this:\n  enum_v (Suc i) = x", "have \"x \\<noteq> source \\<Delta>\""], ["proof (prove)\nusing this:\n  enum_v (Suc i) = x\n\ngoal (1 subgoal):\n 1. x \\<noteq> source \\<Delta>", "using range_enum_v"], ["proof (prove)\nusing this:\n  enum_v (Suc i) = x\n  range enum_v \\<subseteq> \\<^bold>V - {source \\<Delta>, sink \\<Delta>}\n\ngoal (1 subgoal):\n 1. x \\<noteq> source \\<Delta>", "by auto"], ["proof (state)\nthis:\n  x \\<noteq> source \\<Delta>\n\ngoal (2 subgoals):\n 1. d_OUT (h_plus i) x < d_IN (h_plus i) x \\<Longrightarrow>\n    d_OUT (h_plus (Suc i)) x = d_IN (h_plus i) x\n 2. \\<not> d_OUT (h_plus i) x < d_IN (h_plus i) x \\<Longrightarrow>\n    d_OUT (h_plus (Suc i)) x = d_IN (h_plus i) x", "from h_plus_OUT_le_IN[OF this, of i] False"], ["proof (chain)\npicking this:\n  d_OUT (h_plus i) x \\<le> d_IN (h_plus i) x\n  \\<not> d_OUT (h_plus i) x < d_IN (h_plus i) x", "have \"d_OUT (h_plus i) x = d_IN (h_plus i) x\""], ["proof (prove)\nusing this:\n  d_OUT (h_plus i) x \\<le> d_IN (h_plus i) x\n  \\<not> d_OUT (h_plus i) x < d_IN (h_plus i) x\n\ngoal (1 subgoal):\n 1. KIR (h_plus i) x", "by auto"], ["proof (state)\nthis:\n  KIR (h_plus i) x\n\ngoal (2 subgoals):\n 1. d_OUT (h_plus i) x < d_IN (h_plus i) x \\<Longrightarrow>\n    d_OUT (h_plus (Suc i)) x = d_IN (h_plus i) x\n 2. \\<not> d_OUT (h_plus i) x < d_IN (h_plus i) x \\<Longrightarrow>\n    d_OUT (h_plus (Suc i)) x = d_IN (h_plus i) x", "with False enum"], ["proof (chain)\npicking this:\n  \\<not> d_OUT (h_plus i) x < d_IN (h_plus i) x\n  enum_v (Suc i) = x\n  KIR (h_plus i) x", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> d_OUT (h_plus i) x < d_IN (h_plus i) x\n  enum_v (Suc i) = x\n  KIR (h_plus i) x\n\ngoal (1 subgoal):\n 1. d_OUT (h_plus (Suc i)) x = d_IN (h_plus i) x", "by(simp add: d_OUT_def)"], ["proof (state)\nthis:\n  d_OUT (h_plus (Suc i)) x = d_IN (h_plus i) x\n\ngoal (1 subgoal):\n 1. d_OUT (h_plus i) x < d_IN (h_plus i) x \\<Longrightarrow>\n    d_OUT (h_plus (Suc i)) x = d_IN (h_plus i) x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. d_OUT (h_plus i) x < d_IN (h_plus i) x \\<Longrightarrow>\n    d_OUT (h_plus (Suc i)) x = d_IN (h_plus i) x", "case True"], ["proof (state)\nthis:\n  d_OUT (h_plus i) x < d_IN (h_plus i) x\n\ngoal (1 subgoal):\n 1. d_OUT (h_plus i) x < d_IN (h_plus i) x \\<Longrightarrow>\n    d_OUT (h_plus (Suc i)) x = d_IN (h_plus i) x", "from enum"], ["proof (chain)\npicking this:\n  enum_v (Suc i) = x", "have x: \"x \\<noteq> source \\<Delta>\" and sink: \"x \\<noteq> sink \\<Delta>\""], ["proof (prove)\nusing this:\n  enum_v (Suc i) = x\n\ngoal (1 subgoal):\n 1. x \\<noteq> source \\<Delta> &&& x \\<noteq> sink \\<Delta>", "using range_enum_v"], ["proof (prove)\nusing this:\n  enum_v (Suc i) = x\n  range enum_v \\<subseteq> \\<^bold>V - {source \\<Delta>, sink \\<Delta>}\n\ngoal (1 subgoal):\n 1. x \\<noteq> source \\<Delta> &&& x \\<noteq> sink \\<Delta>", "by auto"], ["proof (state)\nthis:\n  x \\<noteq> source \\<Delta>\n  x \\<noteq> sink \\<Delta>\n\ngoal (1 subgoal):\n 1. d_OUT (h_plus i) x < d_IN (h_plus i) x \\<Longrightarrow>\n    d_OUT (h_plus (Suc i)) x = d_IN (h_plus i) x", "let ?r = \"\\<lambda>y. (g (x, y) - h_plus i (x, y)) * (d_IN (h_plus i) x - d_OUT (h_plus i) x) / (d_OUT g x - d_OUT (h_plus i) x)\""], ["proof (state)\ngoal (1 subgoal):\n 1. d_OUT (h_plus i) x < d_IN (h_plus i) x \\<Longrightarrow>\n    d_OUT (h_plus (Suc i)) x = d_IN (h_plus i) x", "have \"d_OUT (h_plus (Suc i)) x = d_OUT (h_plus i) x + (\\<Sum>\\<^sup>+ y. ?r y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT (h_plus (Suc i)) x =\n    d_OUT (h_plus i) x +\n    (\\<Sum>\\<^sup>+ y.\n       (g (x, y) - h_plus i (x, y)) *\n       (d_IN (h_plus i) x - d_OUT (h_plus i) x) /\n       (d_OUT g x - d_OUT (h_plus i) x))", "using True enum"], ["proof (prove)\nusing this:\n  d_OUT (h_plus i) x < d_IN (h_plus i) x\n  enum_v (Suc i) = x\n\ngoal (1 subgoal):\n 1. d_OUT (h_plus (Suc i)) x =\n    d_OUT (h_plus i) x +\n    (\\<Sum>\\<^sup>+ y.\n       (g (x, y) - h_plus i (x, y)) *\n       (d_IN (h_plus i) x - d_OUT (h_plus i) x) /\n       (d_OUT g x - d_OUT (h_plus i) x))", "unfolding d_OUT_def h_plus.simps"], ["proof (prove)\nusing this:\n  (\\<Sum>\\<^sup>+ y. h_plus i (x, y)) < d_IN (h_plus i) x\n  enum_v (Suc i) = x\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y.\n       if enum_v (Suc i) = x \\<and>\n          (\\<Sum>\\<^sup>+ y. h_plus i (x, y)) < d_IN (h_plus i) x\n       then let total =\n                  d_IN (h_plus i) x - (\\<Sum>\\<^sup>+ y. h_plus i (x, y));\n                share = g (x, y) - h_plus i (x, y);\n                shares =\n                  (\\<Sum>\\<^sup>+ y. g (x, y)) -\n                  (\\<Sum>\\<^sup>+ y. h_plus i (x, y))\n            in h_plus i (x, y) + share * total / shares\n       else h_plus i (x, y)) =\n    (\\<Sum>\\<^sup>+ y. h_plus i (x, y)) +\n    (\\<Sum>\\<^sup>+ y.\n       (g (x, y) - h_plus i (x, y)) *\n       (d_IN (h_plus i) x - (\\<Sum>\\<^sup>+ y. h_plus i (x, y))) /\n       ((\\<Sum>\\<^sup>+ y. g (x, y)) - (\\<Sum>\\<^sup>+ y. h_plus i (x, y))))", "by(simp add: AE_count_space nn_integral_add)"], ["proof (state)\nthis:\n  d_OUT (h_plus (Suc i)) x =\n  d_OUT (h_plus i) x +\n  (\\<Sum>\\<^sup>+ y.\n     (g (x, y) - h_plus i (x, y)) *\n     (d_IN (h_plus i) x - d_OUT (h_plus i) x) /\n     (d_OUT g x - d_OUT (h_plus i) x))\n\ngoal (1 subgoal):\n 1. d_OUT (h_plus i) x < d_IN (h_plus i) x \\<Longrightarrow>\n    d_OUT (h_plus (Suc i)) x = d_IN (h_plus i) x", "also"], ["proof (state)\nthis:\n  d_OUT (h_plus (Suc i)) x =\n  d_OUT (h_plus i) x +\n  (\\<Sum>\\<^sup>+ y.\n     (g (x, y) - h_plus i (x, y)) *\n     (d_IN (h_plus i) x - d_OUT (h_plus i) x) /\n     (d_OUT g x - d_OUT (h_plus i) x))\n\ngoal (1 subgoal):\n 1. d_OUT (h_plus i) x < d_IN (h_plus i) x \\<Longrightarrow>\n    d_OUT (h_plus (Suc i)) x = d_IN (h_plus i) x", "from True enum"], ["proof (chain)\npicking this:\n  d_OUT (h_plus i) x < d_IN (h_plus i) x\n  enum_v (Suc i) = x", "have \"x \\<noteq> source \\<Delta>\" \"x \\<noteq> sink \\<Delta>\""], ["proof (prove)\nusing this:\n  d_OUT (h_plus i) x < d_IN (h_plus i) x\n  enum_v (Suc i) = x\n\ngoal (1 subgoal):\n 1. x \\<noteq> source \\<Delta> &&& x \\<noteq> sink \\<Delta>", "using range_enum_v"], ["proof (prove)\nusing this:\n  d_OUT (h_plus i) x < d_IN (h_plus i) x\n  enum_v (Suc i) = x\n  range enum_v \\<subseteq> \\<^bold>V - {source \\<Delta>, sink \\<Delta>}\n\ngoal (1 subgoal):\n 1. x \\<noteq> source \\<Delta> &&& x \\<noteq> sink \\<Delta>", "by auto"], ["proof (state)\nthis:\n  x \\<noteq> source \\<Delta>\n  x \\<noteq> sink \\<Delta>\n\ngoal (1 subgoal):\n 1. d_OUT (h_plus i) x < d_IN (h_plus i) x \\<Longrightarrow>\n    d_OUT (h_plus (Suc i)) x = d_IN (h_plus i) x", "from flowD_KIR[OF g this] True d_IN_mono[of \"h_plus i\" x g, OF h_plus_le_g]"], ["proof (chain)\npicking this:\n  KIR g x\n  d_OUT (h_plus i) x < d_IN (h_plus i) x\n  d_IN (h_plus i) x \\<le> d_IN g x", "have le': \"d_OUT (h_plus i) x < d_OUT g x\""], ["proof (prove)\nusing this:\n  KIR g x\n  d_OUT (h_plus i) x < d_IN (h_plus i) x\n  d_IN (h_plus i) x \\<le> d_IN g x\n\ngoal (1 subgoal):\n 1. d_OUT (h_plus i) x < d_OUT g x", "by(simp)"], ["proof (state)\nthis:\n  d_OUT (h_plus i) x < d_OUT g x\n\ngoal (1 subgoal):\n 1. d_OUT (h_plus i) x < d_IN (h_plus i) x \\<Longrightarrow>\n    d_OUT (h_plus (Suc i)) x = d_IN (h_plus i) x", "then"], ["proof (chain)\npicking this:\n  d_OUT (h_plus i) x < d_OUT g x", "have \"(\\<Sum>\\<^sup>+ y. ?r y ) =\n    (d_IN (h_plus i) x - d_OUT (h_plus i) x) * ((\\<Sum>\\<^sup>+ y. g (x, y) - h_plus i (x, y)) / (d_OUT g x - d_OUT (h_plus i) x))\""], ["proof (prove)\nusing this:\n  d_OUT (h_plus i) x < d_OUT g x\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y.\n       (g (x, y) - h_plus i (x, y)) *\n       (d_IN (h_plus i) x - d_OUT (h_plus i) x) /\n       (d_OUT g x - d_OUT (h_plus i) x)) =\n    (d_IN (h_plus i) x - d_OUT (h_plus i) x) *\n    ((\\<Sum>\\<^sup>+ y. g (x, y) - h_plus i (x, y)) /\n     (d_OUT g x - d_OUT (h_plus i) x))", "by(subst mult.commute, subst ennreal_times_divide[symmetric])\n      (simp add: nn_integral_cmult nn_integral_divide h_plus_OUT_le_IN[OF x] diff_gr0_ennreal)"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y.\n     (g (x, y) - h_plus i (x, y)) *\n     (d_IN (h_plus i) x - d_OUT (h_plus i) x) /\n     (d_OUT g x - d_OUT (h_plus i) x)) =\n  (d_IN (h_plus i) x - d_OUT (h_plus i) x) *\n  ((\\<Sum>\\<^sup>+ y. g (x, y) - h_plus i (x, y)) /\n   (d_OUT g x - d_OUT (h_plus i) x))\n\ngoal (1 subgoal):\n 1. d_OUT (h_plus i) x < d_IN (h_plus i) x \\<Longrightarrow>\n    d_OUT (h_plus (Suc i)) x = d_IN (h_plus i) x", "also"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y.\n     (g (x, y) - h_plus i (x, y)) *\n     (d_IN (h_plus i) x - d_OUT (h_plus i) x) /\n     (d_OUT g x - d_OUT (h_plus i) x)) =\n  (d_IN (h_plus i) x - d_OUT (h_plus i) x) *\n  ((\\<Sum>\\<^sup>+ y. g (x, y) - h_plus i (x, y)) /\n   (d_OUT g x - d_OUT (h_plus i) x))\n\ngoal (1 subgoal):\n 1. d_OUT (h_plus i) x < d_IN (h_plus i) x \\<Longrightarrow>\n    d_OUT (h_plus (Suc i)) x = d_IN (h_plus i) x", "have \"(\\<Sum>\\<^sup>+ y. g (x, y) - h_plus i (x, y)) = d_OUT g x - d_OUT (h_plus i) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y. g (x, y) - h_plus i (x, y)) =\n    d_OUT g x - d_OUT (h_plus i) x", "using sink"], ["proof (prove)\nusing this:\n  x \\<noteq> sink \\<Delta>\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y. g (x, y) - h_plus i (x, y)) =\n    d_OUT g x - d_OUT (h_plus i) x", "by(subst nn_integral_diff)(simp_all add: d_OUT_def[symmetric] h_plus_le_g d_OUT_h_plus_not_infty')"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y. g (x, y) - h_plus i (x, y)) =\n  d_OUT g x - d_OUT (h_plus i) x\n\ngoal (1 subgoal):\n 1. d_OUT (h_plus i) x < d_IN (h_plus i) x \\<Longrightarrow>\n    d_OUT (h_plus (Suc i)) x = d_IN (h_plus i) x", "also"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y. g (x, y) - h_plus i (x, y)) =\n  d_OUT g x - d_OUT (h_plus i) x\n\ngoal (1 subgoal):\n 1. d_OUT (h_plus i) x < d_IN (h_plus i) x \\<Longrightarrow>\n    d_OUT (h_plus (Suc i)) x = d_IN (h_plus i) x", "have \"\\<dots> / \\<dots> = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (d_OUT g x - d_OUT (h_plus i) x) / (d_OUT g x - d_OUT (h_plus i) x) = 1", "using le' finite_OUT_g[of x] sink"], ["proof (prove)\nusing this:\n  d_OUT (h_plus i) x < d_OUT g x\n  x \\<noteq> sink \\<Delta> \\<Longrightarrow> d_OUT g x \\<noteq> \\<top>\n  x \\<noteq> sink \\<Delta>\n\ngoal (1 subgoal):\n 1. (d_OUT g x - d_OUT (h_plus i) x) / (d_OUT g x - d_OUT (h_plus i) x) = 1", "by(auto intro!: ennreal_divide_self dest: diff_gr0_ennreal simp: less_top[symmetric])"], ["proof (state)\nthis:\n  (d_OUT g x - d_OUT (h_plus i) x) / (d_OUT g x - d_OUT (h_plus i) x) = 1\n\ngoal (1 subgoal):\n 1. d_OUT (h_plus i) x < d_IN (h_plus i) x \\<Longrightarrow>\n    d_OUT (h_plus (Suc i)) x = d_IN (h_plus i) x", "also"], ["proof (state)\nthis:\n  (d_OUT g x - d_OUT (h_plus i) x) / (d_OUT g x - d_OUT (h_plus i) x) = 1\n\ngoal (1 subgoal):\n 1. d_OUT (h_plus i) x < d_IN (h_plus i) x \\<Longrightarrow>\n    d_OUT (h_plus (Suc i)) x = d_IN (h_plus i) x", "have \"d_OUT (h_plus i) x + (d_IN (h_plus i) x - d_OUT (h_plus i) x) * 1 = d_IN (h_plus i) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT (h_plus i) x + (d_IN (h_plus i) x - d_OUT (h_plus i) x) * 1 =\n    d_IN (h_plus i) x", "using sink"], ["proof (prove)\nusing this:\n  x \\<noteq> sink \\<Delta>\n\ngoal (1 subgoal):\n 1. d_OUT (h_plus i) x + (d_IN (h_plus i) x - d_OUT (h_plus i) x) * 1 =\n    d_IN (h_plus i) x", "by (simp add: h_plus_OUT_le_IN x)"], ["proof (state)\nthis:\n  d_OUT (h_plus i) x + (d_IN (h_plus i) x - d_OUT (h_plus i) x) * 1 =\n  d_IN (h_plus i) x\n\ngoal (1 subgoal):\n 1. d_OUT (h_plus i) x < d_IN (h_plus i) x \\<Longrightarrow>\n    d_OUT (h_plus (Suc i)) x = d_IN (h_plus i) x", "finally"], ["proof (chain)\npicking this:\n  d_OUT (h_plus (Suc i)) x = d_IN (h_plus i) x", "show ?thesis"], ["proof (prove)\nusing this:\n  d_OUT (h_plus (Suc i)) x = d_IN (h_plus i) x\n\ngoal (1 subgoal):\n 1. d_OUT (h_plus (Suc i)) x = d_IN (h_plus i) x", "."], ["proof (state)\nthis:\n  d_OUT (h_plus (Suc i)) x = d_IN (h_plus i) x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma h_plus_source_in [simp]: \"h_plus i (x, source \\<Delta>) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h_plus i (x, source \\<Delta>) = 0", "by(induction i)simp_all"], ["", "lemma h_plus_sum_finite: \"(\\<Sum>\\<^sup>+ e. h_plus i e) \\<noteq> top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. integral\\<^sup>N (count_space UNIV) (h_plus i) \\<noteq> \\<top>", "proof(induction i)"], ["proof (state)\ngoal (2 subgoals):\n 1. integral\\<^sup>N (count_space UNIV) (h_plus 0) \\<noteq> \\<top>\n 2. \\<And>i.\n       integral\\<^sup>N (count_space UNIV) (h_plus i) \\<noteq>\n       \\<top> \\<Longrightarrow>\n       integral\\<^sup>N (count_space UNIV) (h_plus (Suc i)) \\<noteq> \\<top>", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. integral\\<^sup>N (count_space UNIV) (h_plus 0) \\<noteq> \\<top>\n 2. \\<And>i.\n       integral\\<^sup>N (count_space UNIV) (h_plus i) \\<noteq>\n       \\<top> \\<Longrightarrow>\n       integral\\<^sup>N (count_space UNIV) (h_plus (Suc i)) \\<noteq> \\<top>", "have \"(\\<Sum>\\<^sup>+ e\\<in>UNIV. h_plus 0 e) = (\\<Sum>\\<^sup>+ (x, y). h_plus 0 (x, y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. integral\\<^sup>N (count_space UNIV) (h_plus 0) =\n    (\\<Sum>\\<^sup>+ (x, y). h_plus 0 (x, y))", "by(simp del: h_plus.simps)"], ["proof (state)\nthis:\n  integral\\<^sup>N (count_space UNIV) (h_plus 0) =\n  (\\<Sum>\\<^sup>+ (x, y). h_plus 0 (x, y))\n\ngoal (2 subgoals):\n 1. integral\\<^sup>N (count_space UNIV) (h_plus 0) \\<noteq> \\<top>\n 2. \\<And>i.\n       integral\\<^sup>N (count_space UNIV) (h_plus i) \\<noteq>\n       \\<top> \\<Longrightarrow>\n       integral\\<^sup>N (count_space UNIV) (h_plus (Suc i)) \\<noteq> \\<top>", "also"], ["proof (state)\nthis:\n  integral\\<^sup>N (count_space UNIV) (h_plus 0) =\n  (\\<Sum>\\<^sup>+ (x, y). h_plus 0 (x, y))\n\ngoal (2 subgoals):\n 1. integral\\<^sup>N (count_space UNIV) (h_plus 0) \\<noteq> \\<top>\n 2. \\<And>i.\n       integral\\<^sup>N (count_space UNIV) (h_plus i) \\<noteq>\n       \\<top> \\<Longrightarrow>\n       integral\\<^sup>N (count_space UNIV) (h_plus (Suc i)) \\<noteq> \\<top>", "have \"\\<dots> = (\\<Sum>\\<^sup>+ (x, y)\\<in>range (Pair (source \\<Delta>)). h_plus 0 (x, y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ (x, y). h_plus 0 (x, y)) =\n    (\\<Sum>\\<^sup>+ (x, y)\\<in>range (Pair (source \\<Delta>)).\n       h_plus 0 (x, y))", "by(auto simp add: nn_integral_count_space_indicator intro!: nn_integral_cong)"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ (x, y). h_plus 0 (x, y)) =\n  (\\<Sum>\\<^sup>+ (x, y)\\<in>range (Pair (source \\<Delta>)).\n     h_plus 0 (x, y))\n\ngoal (2 subgoals):\n 1. integral\\<^sup>N (count_space UNIV) (h_plus 0) \\<noteq> \\<top>\n 2. \\<And>i.\n       integral\\<^sup>N (count_space UNIV) (h_plus i) \\<noteq>\n       \\<top> \\<Longrightarrow>\n       integral\\<^sup>N (count_space UNIV) (h_plus (Suc i)) \\<noteq> \\<top>", "also"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ (x, y). h_plus 0 (x, y)) =\n  (\\<Sum>\\<^sup>+ (x, y)\\<in>range (Pair (source \\<Delta>)).\n     h_plus 0 (x, y))\n\ngoal (2 subgoals):\n 1. integral\\<^sup>N (count_space UNIV) (h_plus 0) \\<noteq> \\<top>\n 2. \\<And>i.\n       integral\\<^sup>N (count_space UNIV) (h_plus i) \\<noteq>\n       \\<top> \\<Longrightarrow>\n       integral\\<^sup>N (count_space UNIV) (h_plus (Suc i)) \\<noteq> \\<top>", "have \"\\<dots> = value_flow \\<Delta> g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ (x, y)\\<in>range (Pair (source \\<Delta>)).\n       h_plus 0 (x, y)) =\n    value_flow \\<Delta> g", "by(simp add: d_OUT_def nn_integral_count_space_reindex)"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ (x, y)\\<in>range (Pair (source \\<Delta>)).\n     h_plus 0 (x, y)) =\n  value_flow \\<Delta> g\n\ngoal (2 subgoals):\n 1. integral\\<^sup>N (count_space UNIV) (h_plus 0) \\<noteq> \\<top>\n 2. \\<And>i.\n       integral\\<^sup>N (count_space UNIV) (h_plus i) \\<noteq>\n       \\<top> \\<Longrightarrow>\n       integral\\<^sup>N (count_space UNIV) (h_plus (Suc i)) \\<noteq> \\<top>", "also"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ (x, y)\\<in>range (Pair (source \\<Delta>)).\n     h_plus 0 (x, y)) =\n  value_flow \\<Delta> g\n\ngoal (2 subgoals):\n 1. integral\\<^sup>N (count_space UNIV) (h_plus 0) \\<noteq> \\<top>\n 2. \\<And>i.\n       integral\\<^sup>N (count_space UNIV) (h_plus i) \\<noteq>\n       \\<top> \\<Longrightarrow>\n       integral\\<^sup>N (count_space UNIV) (h_plus (Suc i)) \\<noteq> \\<top>", "have \"\\<dots> < \\<top>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. value_flow \\<Delta> g < \\<top>", "using g_finite"], ["proof (prove)\nusing this:\n  value_flow \\<Delta> g \\<noteq> \\<top>\n\ngoal (1 subgoal):\n 1. value_flow \\<Delta> g < \\<top>", "by (simp add: less_top)"], ["proof (state)\nthis:\n  value_flow \\<Delta> g < \\<top>\n\ngoal (2 subgoals):\n 1. integral\\<^sup>N (count_space UNIV) (h_plus 0) \\<noteq> \\<top>\n 2. \\<And>i.\n       integral\\<^sup>N (count_space UNIV) (h_plus i) \\<noteq>\n       \\<top> \\<Longrightarrow>\n       integral\\<^sup>N (count_space UNIV) (h_plus (Suc i)) \\<noteq> \\<top>", "finally"], ["proof (chain)\npicking this:\n  integral\\<^sup>N (count_space UNIV) (h_plus 0) < \\<top>", "show ?case"], ["proof (prove)\nusing this:\n  integral\\<^sup>N (count_space UNIV) (h_plus 0) < \\<top>\n\ngoal (1 subgoal):\n 1. integral\\<^sup>N (count_space UNIV) (h_plus 0) \\<noteq> \\<top>", "by simp"], ["proof (state)\nthis:\n  integral\\<^sup>N (count_space UNIV) (h_plus 0) \\<noteq> \\<top>\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       integral\\<^sup>N (count_space UNIV) (h_plus i) \\<noteq>\n       \\<top> \\<Longrightarrow>\n       integral\\<^sup>N (count_space UNIV) (h_plus (Suc i)) \\<noteq> \\<top>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       integral\\<^sup>N (count_space UNIV) (h_plus i) \\<noteq>\n       \\<top> \\<Longrightarrow>\n       integral\\<^sup>N (count_space UNIV) (h_plus (Suc i)) \\<noteq> \\<top>", "case (Suc i)"], ["proof (state)\nthis:\n  integral\\<^sup>N (count_space UNIV) (h_plus i) \\<noteq> \\<top>\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       integral\\<^sup>N (count_space UNIV) (h_plus i) \\<noteq>\n       \\<top> \\<Longrightarrow>\n       integral\\<^sup>N (count_space UNIV) (h_plus (Suc i)) \\<noteq> \\<top>", "define xi where \"xi = enum_v (Suc i)\""], ["proof (state)\nthis:\n  xi = enum_v (Suc i)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       integral\\<^sup>N (count_space UNIV) (h_plus i) \\<noteq>\n       \\<top> \\<Longrightarrow>\n       integral\\<^sup>N (count_space UNIV) (h_plus (Suc i)) \\<noteq> \\<top>", "then"], ["proof (chain)\npicking this:\n  xi = enum_v (Suc i)", "have xi: \"xi \\<noteq> source \\<Delta>\" \"xi \\<noteq> sink \\<Delta>\""], ["proof (prove)\nusing this:\n  xi = enum_v (Suc i)\n\ngoal (1 subgoal):\n 1. xi \\<noteq> source \\<Delta> &&& xi \\<noteq> sink \\<Delta>", "using range_enum_v"], ["proof (prove)\nusing this:\n  xi = enum_v (Suc i)\n  range enum_v \\<subseteq> \\<^bold>V - {source \\<Delta>, sink \\<Delta>}\n\ngoal (1 subgoal):\n 1. xi \\<noteq> source \\<Delta> &&& xi \\<noteq> sink \\<Delta>", "by auto"], ["proof (state)\nthis:\n  xi \\<noteq> source \\<Delta>\n  xi \\<noteq> sink \\<Delta>\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       integral\\<^sup>N (count_space UNIV) (h_plus i) \\<noteq>\n       \\<top> \\<Longrightarrow>\n       integral\\<^sup>N (count_space UNIV) (h_plus (Suc i)) \\<noteq> \\<top>", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. integral\\<^sup>N (count_space UNIV) (h_plus (Suc i)) \\<noteq> \\<top>", "proof(cases \"d_OUT (h_plus i) xi < d_IN (h_plus i) xi\")"], ["proof (state)\ngoal (2 subgoals):\n 1. d_OUT (h_plus i) xi < d_IN (h_plus i) xi \\<Longrightarrow>\n    integral\\<^sup>N (count_space UNIV) (h_plus (Suc i)) \\<noteq> \\<top>\n 2. \\<not> d_OUT (h_plus i) xi < d_IN (h_plus i) xi \\<Longrightarrow>\n    integral\\<^sup>N (count_space UNIV) (h_plus (Suc i)) \\<noteq> \\<top>", "case False"], ["proof (state)\nthis:\n  \\<not> d_OUT (h_plus i) xi < d_IN (h_plus i) xi\n\ngoal (2 subgoals):\n 1. d_OUT (h_plus i) xi < d_IN (h_plus i) xi \\<Longrightarrow>\n    integral\\<^sup>N (count_space UNIV) (h_plus (Suc i)) \\<noteq> \\<top>\n 2. \\<not> d_OUT (h_plus i) xi < d_IN (h_plus i) xi \\<Longrightarrow>\n    integral\\<^sup>N (count_space UNIV) (h_plus (Suc i)) \\<noteq> \\<top>", "hence \"(\\<Sum>\\<^sup>+ e\\<in>UNIV. h_plus (Suc i) e) = (\\<Sum>\\<^sup>+ e. h_plus i e)\""], ["proof (prove)\nusing this:\n  \\<not> d_OUT (h_plus i) xi < d_IN (h_plus i) xi\n\ngoal (1 subgoal):\n 1. integral\\<^sup>N (count_space UNIV) (h_plus (Suc i)) =\n    integral\\<^sup>N (count_space UNIV) (h_plus i)", "by(auto intro!: nn_integral_cong simp add: xi_def)"], ["proof (state)\nthis:\n  integral\\<^sup>N (count_space UNIV) (h_plus (Suc i)) =\n  integral\\<^sup>N (count_space UNIV) (h_plus i)\n\ngoal (2 subgoals):\n 1. d_OUT (h_plus i) xi < d_IN (h_plus i) xi \\<Longrightarrow>\n    integral\\<^sup>N (count_space UNIV) (h_plus (Suc i)) \\<noteq> \\<top>\n 2. \\<not> d_OUT (h_plus i) xi < d_IN (h_plus i) xi \\<Longrightarrow>\n    integral\\<^sup>N (count_space UNIV) (h_plus (Suc i)) \\<noteq> \\<top>", "with Suc.IH"], ["proof (chain)\npicking this:\n  integral\\<^sup>N (count_space UNIV) (h_plus i) \\<noteq> \\<top>\n  integral\\<^sup>N (count_space UNIV) (h_plus (Suc i)) =\n  integral\\<^sup>N (count_space UNIV) (h_plus i)", "show ?thesis"], ["proof (prove)\nusing this:\n  integral\\<^sup>N (count_space UNIV) (h_plus i) \\<noteq> \\<top>\n  integral\\<^sup>N (count_space UNIV) (h_plus (Suc i)) =\n  integral\\<^sup>N (count_space UNIV) (h_plus i)\n\ngoal (1 subgoal):\n 1. integral\\<^sup>N (count_space UNIV) (h_plus (Suc i)) \\<noteq> \\<top>", "by simp"], ["proof (state)\nthis:\n  integral\\<^sup>N (count_space UNIV) (h_plus (Suc i)) \\<noteq> \\<top>\n\ngoal (1 subgoal):\n 1. d_OUT (h_plus i) xi < d_IN (h_plus i) xi \\<Longrightarrow>\n    integral\\<^sup>N (count_space UNIV) (h_plus (Suc i)) \\<noteq> \\<top>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. d_OUT (h_plus i) xi < d_IN (h_plus i) xi \\<Longrightarrow>\n    integral\\<^sup>N (count_space UNIV) (h_plus (Suc i)) \\<noteq> \\<top>", "case True"], ["proof (state)\nthis:\n  d_OUT (h_plus i) xi < d_IN (h_plus i) xi\n\ngoal (1 subgoal):\n 1. d_OUT (h_plus i) xi < d_IN (h_plus i) xi \\<Longrightarrow>\n    integral\\<^sup>N (count_space UNIV) (h_plus (Suc i)) \\<noteq> \\<top>", "have less: \"d_OUT (h_plus i) xi < d_OUT g xi\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT (h_plus i) xi < d_OUT g xi", "using True flowD_KIR[OF g xi] d_IN_mono[of \"h_plus i\" xi, OF h_plus_le_g]"], ["proof (prove)\nusing this:\n  d_OUT (h_plus i) xi < d_IN (h_plus i) xi\n  KIR g xi\n  d_IN (h_plus i) xi \\<le> d_IN g xi\n\ngoal (1 subgoal):\n 1. d_OUT (h_plus i) xi < d_OUT g xi", "by simp"], ["proof (state)\nthis:\n  d_OUT (h_plus i) xi < d_OUT g xi\n\ngoal (1 subgoal):\n 1. d_OUT (h_plus i) xi < d_IN (h_plus i) xi \\<Longrightarrow>\n    integral\\<^sup>N (count_space UNIV) (h_plus (Suc i)) \\<noteq> \\<top>", "have \"(\\<Sum>\\<^sup>+ e. h_plus (Suc i) e) =\n      (\\<Sum>\\<^sup>+ e\\<in>UNIV. h_plus i e) + (\\<Sum>\\<^sup>+ (x, y). ((g (x, y) - h_plus i (x, y)) * (d_IN (h_plus i) x - d_OUT (h_plus i) x) / (d_OUT g x - d_OUT (h_plus i) x)) * indicator (range (Pair xi)) (x, y))\"\n      (is \"_ = ?IH + ?rest\" is \"_ = _ + \\<integral>\\<^sup>+ (x, y). ?f x y * _ \\<partial>_\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. integral\\<^sup>N (count_space UNIV) (h_plus (Suc i)) =\n    integral\\<^sup>N (count_space UNIV) (h_plus i) +\n    (\\<Sum>\\<^sup>+ (x, y).\n       (g (x, y) - h_plus i (x, y)) *\n       (d_IN (h_plus i) x - d_OUT (h_plus i) x) /\n       (d_OUT g x - d_OUT (h_plus i) x) *\n       indicator (range (Pair xi)) (x, y))", "using xi True"], ["proof (prove)\nusing this:\n  xi \\<noteq> source \\<Delta>\n  xi \\<noteq> sink \\<Delta>\n  d_OUT (h_plus i) xi < d_IN (h_plus i) xi\n\ngoal (1 subgoal):\n 1. integral\\<^sup>N (count_space UNIV) (h_plus (Suc i)) =\n    integral\\<^sup>N (count_space UNIV) (h_plus i) +\n    (\\<Sum>\\<^sup>+ (x, y).\n       (g (x, y) - h_plus i (x, y)) *\n       (d_IN (h_plus i) x - d_OUT (h_plus i) x) /\n       (d_OUT g x - d_OUT (h_plus i) x) *\n       indicator (range (Pair xi)) (x, y))", "by(subst nn_integral_add[symmetric])(auto simp add: xi_def split_beta AE_count_space intro!: nn_integral_cong split: split_indicator intro!: h_plus_le_g h_plus_OUT_le_IN d_OUT_mono le_funI)"], ["proof (state)\nthis:\n  integral\\<^sup>N (count_space UNIV) (h_plus (Suc i)) =\n  integral\\<^sup>N (count_space UNIV) (h_plus i) +\n  (\\<Sum>\\<^sup>+ (x, y).\n     (g (x, y) - h_plus i (x, y)) *\n     (d_IN (h_plus i) x - d_OUT (h_plus i) x) /\n     (d_OUT g x - d_OUT (h_plus i) x) *\n     indicator (range (Pair xi)) (x, y))\n\ngoal (1 subgoal):\n 1. d_OUT (h_plus i) xi < d_IN (h_plus i) xi \\<Longrightarrow>\n    integral\\<^sup>N (count_space UNIV) (h_plus (Suc i)) \\<noteq> \\<top>", "also"], ["proof (state)\nthis:\n  integral\\<^sup>N (count_space UNIV) (h_plus (Suc i)) =\n  integral\\<^sup>N (count_space UNIV) (h_plus i) +\n  (\\<Sum>\\<^sup>+ (x, y).\n     (g (x, y) - h_plus i (x, y)) *\n     (d_IN (h_plus i) x - d_OUT (h_plus i) x) /\n     (d_OUT g x - d_OUT (h_plus i) x) *\n     indicator (range (Pair xi)) (x, y))\n\ngoal (1 subgoal):\n 1. d_OUT (h_plus i) xi < d_IN (h_plus i) xi \\<Longrightarrow>\n    integral\\<^sup>N (count_space UNIV) (h_plus (Suc i)) \\<noteq> \\<top>", "have \"?rest = (\\<Sum>\\<^sup>+ (x, y)\\<in>range (Pair xi). ?f x y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ (x, y).\n       (g (x, y) - h_plus i (x, y)) *\n       (d_IN (h_plus i) x - d_OUT (h_plus i) x) /\n       (d_OUT g x - d_OUT (h_plus i) x) *\n       indicator (range (Pair xi)) (x, y)) =\n    (\\<Sum>\\<^sup>+ (x, y)\\<in>range (Pair xi).\n       (g (x, y) - h_plus i (x, y)) *\n       (d_IN (h_plus i) x - d_OUT (h_plus i) x) /\n       (d_OUT g x - d_OUT (h_plus i) x))", "by(simp add: nn_integral_count_space_indicator split_def)"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ (x, y).\n     (g (x, y) - h_plus i (x, y)) *\n     (d_IN (h_plus i) x - d_OUT (h_plus i) x) /\n     (d_OUT g x - d_OUT (h_plus i) x) *\n     indicator (range (Pair xi)) (x, y)) =\n  (\\<Sum>\\<^sup>+ (x, y)\\<in>range (Pair xi).\n     (g (x, y) - h_plus i (x, y)) *\n     (d_IN (h_plus i) x - d_OUT (h_plus i) x) /\n     (d_OUT g x - d_OUT (h_plus i) x))\n\ngoal (1 subgoal):\n 1. d_OUT (h_plus i) xi < d_IN (h_plus i) xi \\<Longrightarrow>\n    integral\\<^sup>N (count_space UNIV) (h_plus (Suc i)) \\<noteq> \\<top>", "also"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ (x, y).\n     (g (x, y) - h_plus i (x, y)) *\n     (d_IN (h_plus i) x - d_OUT (h_plus i) x) /\n     (d_OUT g x - d_OUT (h_plus i) x) *\n     indicator (range (Pair xi)) (x, y)) =\n  (\\<Sum>\\<^sup>+ (x, y)\\<in>range (Pair xi).\n     (g (x, y) - h_plus i (x, y)) *\n     (d_IN (h_plus i) x - d_OUT (h_plus i) x) /\n     (d_OUT g x - d_OUT (h_plus i) x))\n\ngoal (1 subgoal):\n 1. d_OUT (h_plus i) xi < d_IN (h_plus i) xi \\<Longrightarrow>\n    integral\\<^sup>N (count_space UNIV) (h_plus (Suc i)) \\<noteq> \\<top>", "have \"\\<dots> = (\\<Sum>\\<^sup>+ y. ?f xi y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ (x, y)\\<in>range (Pair xi).\n       (g (x, y) - h_plus i (x, y)) *\n       (d_IN (h_plus i) x - d_OUT (h_plus i) x) /\n       (d_OUT g x - d_OUT (h_plus i) x)) =\n    (\\<Sum>\\<^sup>+ y.\n       (g (xi, y) - h_plus i (xi, y)) *\n       (d_IN (h_plus i) xi - d_OUT (h_plus i) xi) /\n       (d_OUT g xi - d_OUT (h_plus i) xi))", "by(simp add: nn_integral_count_space_reindex)"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ (x, y)\\<in>range (Pair xi).\n     (g (x, y) - h_plus i (x, y)) *\n     (d_IN (h_plus i) x - d_OUT (h_plus i) x) /\n     (d_OUT g x - d_OUT (h_plus i) x)) =\n  (\\<Sum>\\<^sup>+ y.\n     (g (xi, y) - h_plus i (xi, y)) *\n     (d_IN (h_plus i) xi - d_OUT (h_plus i) xi) /\n     (d_OUT g xi - d_OUT (h_plus i) xi))\n\ngoal (1 subgoal):\n 1. d_OUT (h_plus i) xi < d_IN (h_plus i) xi \\<Longrightarrow>\n    integral\\<^sup>N (count_space UNIV) (h_plus (Suc i)) \\<noteq> \\<top>", "also"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ (x, y)\\<in>range (Pair xi).\n     (g (x, y) - h_plus i (x, y)) *\n     (d_IN (h_plus i) x - d_OUT (h_plus i) x) /\n     (d_OUT g x - d_OUT (h_plus i) x)) =\n  (\\<Sum>\\<^sup>+ y.\n     (g (xi, y) - h_plus i (xi, y)) *\n     (d_IN (h_plus i) xi - d_OUT (h_plus i) xi) /\n     (d_OUT g xi - d_OUT (h_plus i) xi))\n\ngoal (1 subgoal):\n 1. d_OUT (h_plus i) xi < d_IN (h_plus i) xi \\<Longrightarrow>\n    integral\\<^sup>N (count_space UNIV) (h_plus (Suc i)) \\<noteq> \\<top>", "have \"\\<dots> = (\\<Sum>\\<^sup>+ y. g (xi, y) - h_plus i (xi, y)) * ((d_IN (h_plus i) xi - d_OUT (h_plus i) xi) / (d_OUT g xi - d_OUT (h_plus i) xi))\"\n      (is \"_ = ?integral * ?factor\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y.\n       (g (xi, y) - h_plus i (xi, y)) *\n       (d_IN (h_plus i) xi - d_OUT (h_plus i) xi) /\n       (d_OUT g xi - d_OUT (h_plus i) xi)) =\n    (\\<Sum>\\<^sup>+ y. g (xi, y) - h_plus i (xi, y)) *\n    ((d_IN (h_plus i) xi - d_OUT (h_plus i) xi) /\n     (d_OUT g xi - d_OUT (h_plus i) xi))", "using True less"], ["proof (prove)\nusing this:\n  d_OUT (h_plus i) xi < d_IN (h_plus i) xi\n  d_OUT (h_plus i) xi < d_OUT g xi\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y.\n       (g (xi, y) - h_plus i (xi, y)) *\n       (d_IN (h_plus i) xi - d_OUT (h_plus i) xi) /\n       (d_OUT g xi - d_OUT (h_plus i) xi)) =\n    (\\<Sum>\\<^sup>+ y. g (xi, y) - h_plus i (xi, y)) *\n    ((d_IN (h_plus i) xi - d_OUT (h_plus i) xi) /\n     (d_OUT g xi - d_OUT (h_plus i) xi))", "by(simp add: nn_integral_multc nn_integral_divide diff_gr0_ennreal ennreal_times_divide)"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y.\n     (g (xi, y) - h_plus i (xi, y)) *\n     (d_IN (h_plus i) xi - d_OUT (h_plus i) xi) /\n     (d_OUT g xi - d_OUT (h_plus i) xi)) =\n  (\\<Sum>\\<^sup>+ y. g (xi, y) - h_plus i (xi, y)) *\n  ((d_IN (h_plus i) xi - d_OUT (h_plus i) xi) /\n   (d_OUT g xi - d_OUT (h_plus i) xi))\n\ngoal (1 subgoal):\n 1. d_OUT (h_plus i) xi < d_IN (h_plus i) xi \\<Longrightarrow>\n    integral\\<^sup>N (count_space UNIV) (h_plus (Suc i)) \\<noteq> \\<top>", "also"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y.\n     (g (xi, y) - h_plus i (xi, y)) *\n     (d_IN (h_plus i) xi - d_OUT (h_plus i) xi) /\n     (d_OUT g xi - d_OUT (h_plus i) xi)) =\n  (\\<Sum>\\<^sup>+ y. g (xi, y) - h_plus i (xi, y)) *\n  ((d_IN (h_plus i) xi - d_OUT (h_plus i) xi) /\n   (d_OUT g xi - d_OUT (h_plus i) xi))\n\ngoal (1 subgoal):\n 1. d_OUT (h_plus i) xi < d_IN (h_plus i) xi \\<Longrightarrow>\n    integral\\<^sup>N (count_space UNIV) (h_plus (Suc i)) \\<noteq> \\<top>", "have \"?integral = d_OUT g xi - d_OUT (h_plus i) xi\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y. g (xi, y) - h_plus i (xi, y)) =\n    d_OUT g xi - d_OUT (h_plus i) xi", "unfolding d_OUT_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y. g (xi, y) - h_plus i (xi, y)) =\n    (\\<Sum>\\<^sup>+ y. g (xi, y)) - (\\<Sum>\\<^sup>+ y. h_plus i (xi, y))", "using xi"], ["proof (prove)\nusing this:\n  xi \\<noteq> source \\<Delta>\n  xi \\<noteq> sink \\<Delta>\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y. g (xi, y) - h_plus i (xi, y)) =\n    (\\<Sum>\\<^sup>+ y. g (xi, y)) - (\\<Sum>\\<^sup>+ y. h_plus i (xi, y))", "by(subst nn_integral_diff)(simp_all add: h_plus_le_g d_OUT_def[symmetric] d_OUT_h_plus_not_infty')"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y. g (xi, y) - h_plus i (xi, y)) =\n  d_OUT g xi - d_OUT (h_plus i) xi\n\ngoal (1 subgoal):\n 1. d_OUT (h_plus i) xi < d_IN (h_plus i) xi \\<Longrightarrow>\n    integral\\<^sup>N (count_space UNIV) (h_plus (Suc i)) \\<noteq> \\<top>", "also"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y. g (xi, y) - h_plus i (xi, y)) =\n  d_OUT g xi - d_OUT (h_plus i) xi\n\ngoal (1 subgoal):\n 1. d_OUT (h_plus i) xi < d_IN (h_plus i) xi \\<Longrightarrow>\n    integral\\<^sup>N (count_space UNIV) (h_plus (Suc i)) \\<noteq> \\<top>", "have \"\\<dots> * ?factor = (d_IN (h_plus i) xi - d_OUT (h_plus i) xi)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (d_OUT g xi - d_OUT (h_plus i) xi) *\n    ((d_IN (h_plus i) xi - d_OUT (h_plus i) xi) /\n     (d_OUT g xi - d_OUT (h_plus i) xi)) =\n    d_IN (h_plus i) xi - d_OUT (h_plus i) xi", "using xi"], ["proof (prove)\nusing this:\n  xi \\<noteq> source \\<Delta>\n  xi \\<noteq> sink \\<Delta>\n\ngoal (1 subgoal):\n 1. (d_OUT g xi - d_OUT (h_plus i) xi) *\n    ((d_IN (h_plus i) xi - d_OUT (h_plus i) xi) /\n     (d_OUT g xi - d_OUT (h_plus i) xi)) =\n    d_IN (h_plus i) xi - d_OUT (h_plus i) xi", "apply (subst ennreal_times_divide)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>xi \\<noteq> source \\<Delta>; xi \\<noteq> sink \\<Delta>\\<rbrakk>\n    \\<Longrightarrow> (d_OUT g xi - d_OUT (h_plus i) xi) *\n                      (d_IN (h_plus i) xi - d_OUT (h_plus i) xi) /\n                      (d_OUT g xi - d_OUT (h_plus i) xi) =\n                      d_IN (h_plus i) xi - d_OUT (h_plus i) xi", "apply (subst mult.commute)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>xi \\<noteq> source \\<Delta>; xi \\<noteq> sink \\<Delta>\\<rbrakk>\n    \\<Longrightarrow> (d_IN (h_plus i) xi - d_OUT (h_plus i) xi) *\n                      (d_OUT g xi - d_OUT (h_plus i) xi) /\n                      (d_OUT g xi - d_OUT (h_plus i) xi) =\n                      d_IN (h_plus i) xi - d_OUT (h_plus i) xi", "apply (subst ennreal_mult_divide_eq)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>xi \\<noteq> source \\<Delta>; xi \\<noteq> sink \\<Delta>\\<rbrakk>\n    \\<Longrightarrow> d_OUT g xi - d_OUT (h_plus i) xi \\<noteq> 0\n 2. \\<lbrakk>xi \\<noteq> source \\<Delta>; xi \\<noteq> sink \\<Delta>\\<rbrakk>\n    \\<Longrightarrow> d_OUT g xi - d_OUT (h_plus i) xi \\<noteq> \\<top>\n 3. \\<lbrakk>xi \\<noteq> source \\<Delta>; xi \\<noteq> sink \\<Delta>\\<rbrakk>\n    \\<Longrightarrow> d_IN (h_plus i) xi - d_OUT (h_plus i) xi =\n                      d_IN (h_plus i) xi - d_OUT (h_plus i) xi", "apply (simp_all add: diff_gr0_ennreal finite_OUT_g less zero_less_iff_neq_zero[symmetric])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (d_OUT g xi - d_OUT (h_plus i) xi) *\n  ((d_IN (h_plus i) xi - d_OUT (h_plus i) xi) /\n   (d_OUT g xi - d_OUT (h_plus i) xi)) =\n  d_IN (h_plus i) xi - d_OUT (h_plus i) xi\n\ngoal (1 subgoal):\n 1. d_OUT (h_plus i) xi < d_IN (h_plus i) xi \\<Longrightarrow>\n    integral\\<^sup>N (count_space UNIV) (h_plus (Suc i)) \\<noteq> \\<top>", "also"], ["proof (state)\nthis:\n  (d_OUT g xi - d_OUT (h_plus i) xi) *\n  ((d_IN (h_plus i) xi - d_OUT (h_plus i) xi) /\n   (d_OUT g xi - d_OUT (h_plus i) xi)) =\n  d_IN (h_plus i) xi - d_OUT (h_plus i) xi\n\ngoal (1 subgoal):\n 1. d_OUT (h_plus i) xi < d_IN (h_plus i) xi \\<Longrightarrow>\n    integral\\<^sup>N (count_space UNIV) (h_plus (Suc i)) \\<noteq> \\<top>", "have \"\\<dots> \\<noteq> \\<top>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN (h_plus i) xi - d_OUT (h_plus i) xi \\<noteq> \\<top>", "using h_plus_OUT_eq_IN[OF refl, of i, folded xi_def, symmetric] xi"], ["proof (prove)\nusing this:\n  d_IN (h_plus i) xi = d_OUT (h_plus (Suc i)) xi\n  xi \\<noteq> source \\<Delta>\n  xi \\<noteq> sink \\<Delta>\n\ngoal (1 subgoal):\n 1. d_IN (h_plus i) xi - d_OUT (h_plus i) xi \\<noteq> \\<top>", "by(simp add: d_OUT_h_plus_not_infty')"], ["proof (state)\nthis:\n  d_IN (h_plus i) xi - d_OUT (h_plus i) xi \\<noteq> \\<top>\n\ngoal (1 subgoal):\n 1. d_OUT (h_plus i) xi < d_IN (h_plus i) xi \\<Longrightarrow>\n    integral\\<^sup>N (count_space UNIV) (h_plus (Suc i)) \\<noteq> \\<top>", "ultimately"], ["proof (chain)\npicking this:\n  integral\\<^sup>N (count_space UNIV) (h_plus (Suc i)) =\n  integral\\<^sup>N (count_space UNIV) (h_plus i) +\n  (d_IN (h_plus i) xi - d_OUT (h_plus i) xi)\n  d_IN (h_plus i) xi - d_OUT (h_plus i) xi \\<noteq> \\<top>", "show ?thesis"], ["proof (prove)\nusing this:\n  integral\\<^sup>N (count_space UNIV) (h_plus (Suc i)) =\n  integral\\<^sup>N (count_space UNIV) (h_plus i) +\n  (d_IN (h_plus i) xi - d_OUT (h_plus i) xi)\n  d_IN (h_plus i) xi - d_OUT (h_plus i) xi \\<noteq> \\<top>\n\ngoal (1 subgoal):\n 1. integral\\<^sup>N (count_space UNIV) (h_plus (Suc i)) \\<noteq> \\<top>", "using Suc.IH"], ["proof (prove)\nusing this:\n  integral\\<^sup>N (count_space UNIV) (h_plus (Suc i)) =\n  integral\\<^sup>N (count_space UNIV) (h_plus i) +\n  (d_IN (h_plus i) xi - d_OUT (h_plus i) xi)\n  d_IN (h_plus i) xi - d_OUT (h_plus i) xi \\<noteq> \\<top>\n  integral\\<^sup>N (count_space UNIV) (h_plus i) \\<noteq> \\<top>\n\ngoal (1 subgoal):\n 1. integral\\<^sup>N (count_space UNIV) (h_plus (Suc i)) \\<noteq> \\<top>", "by simp"], ["proof (state)\nthis:\n  integral\\<^sup>N (count_space UNIV) (h_plus (Suc i)) \\<noteq> \\<top>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  integral\\<^sup>N (count_space UNIV) (h_plus (Suc i)) \\<noteq> \\<top>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma d_OUT_h_plus_not_infty [simp]: \"d_OUT (h_plus i) x \\<noteq> top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT (h_plus i) x \\<noteq> \\<top>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. d_OUT (h_plus i) x \\<noteq> \\<top>", "have \"d_OUT (h_plus i) x \\<le> (\\<Sum>\\<^sup>+ y\\<in>UNIV. \\<Sum>\\<^sup>+ x. h_plus i (x, y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT (h_plus i) x\n    \\<le> (\\<Sum>\\<^sup>+ y. \\<Sum>\\<^sup>+ x. h_plus i (x, y))", "unfolding d_OUT_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y. h_plus i (x, y))\n    \\<le> (\\<Sum>\\<^sup>+ y. \\<Sum>\\<^sup>+ x. h_plus i (x, y))", "by(rule nn_integral_mono nn_integral_ge_point)+ simp"], ["proof (state)\nthis:\n  d_OUT (h_plus i) x\n  \\<le> (\\<Sum>\\<^sup>+ y. \\<Sum>\\<^sup>+ x. h_plus i (x, y))\n\ngoal (1 subgoal):\n 1. d_OUT (h_plus i) x \\<noteq> \\<top>", "also"], ["proof (state)\nthis:\n  d_OUT (h_plus i) x\n  \\<le> (\\<Sum>\\<^sup>+ y. \\<Sum>\\<^sup>+ x. h_plus i (x, y))\n\ngoal (1 subgoal):\n 1. d_OUT (h_plus i) x \\<noteq> \\<top>", "have \"\\<dots> < \\<top>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y. \\<Sum>\\<^sup>+ x. h_plus i (x, y)) < \\<top>", "using h_plus_sum_finite"], ["proof (prove)\nusing this:\n  integral\\<^sup>N (count_space UNIV) (h_plus ?i) \\<noteq> \\<top>\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y. \\<Sum>\\<^sup>+ x. h_plus i (x, y)) < \\<top>", "by(simp add: nn_integral_snd_count_space less_top)"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y. \\<Sum>\\<^sup>+ x. h_plus i (x, y)) < \\<top>\n\ngoal (1 subgoal):\n 1. d_OUT (h_plus i) x \\<noteq> \\<top>", "finally"], ["proof (chain)\npicking this:\n  d_OUT (h_plus i) x < \\<top>", "show ?thesis"], ["proof (prove)\nusing this:\n  d_OUT (h_plus i) x < \\<top>\n\ngoal (1 subgoal):\n 1. d_OUT (h_plus i) x \\<noteq> \\<top>", "by simp"], ["proof (state)\nthis:\n  d_OUT (h_plus i) x \\<noteq> \\<top>\n\ngoal:\nNo subgoals!", "qed"], ["", "definition enum_cycle :: \"nat \\<Rightarrow> 'v path\"\nwhere \"enum_cycle = from_nat_into (cycles \\<Delta>)\""], ["", "lemma cycle_enum_cycle [simp]: \"cycles \\<Delta> \\<noteq> {} \\<Longrightarrow> cycle \\<Delta> (enum_cycle n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cycles \\<Delta> \\<noteq> {} \\<Longrightarrow>\n    cycle \\<Delta> (enum_cycle n)", "unfolding enum_cycle_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. cycles \\<Delta> \\<noteq> {} \\<Longrightarrow>\n    cycle \\<Delta> (from_nat_into (cycles \\<Delta>) n)", "using from_nat_into[of \"cycles \\<Delta>\" n]"], ["proof (prove)\nusing this:\n  cycles \\<Delta> \\<noteq> {} \\<Longrightarrow>\n  from_nat_into (cycles \\<Delta>) n \\<in> cycles \\<Delta>\n\ngoal (1 subgoal):\n 1. cycles \\<Delta> \\<noteq> {} \\<Longrightarrow>\n    cycle \\<Delta> (from_nat_into (cycles \\<Delta>) n)", "by simp"], ["", "context\n  fixes h' :: \"'v flow\"\n  assumes finite_h': \"h' e \\<noteq> top\"\nbegin"], ["", "fun h_minus_aux :: \"nat \\<Rightarrow> 'v edge \\<Rightarrow> ennreal\"\nwhere\n  \"h_minus_aux 0 e = 0\"\n| \"h_minus_aux (Suc j) e =\n  (if e \\<in> set (cycle_edges (enum_cycle j)) then\n     h_minus_aux j e + Min {h' e' - h_minus_aux j e'|e'. e'\\<in>set (cycle_edges (enum_cycle j))}\n   else h_minus_aux j e)\""], ["", "lemma h_minus_aux_le_h': \"h_minus_aux j e \\<le> h' e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h_minus_aux j e \\<le> h' e", "proof(induction j e rule: h_minus_aux.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>e. h_minus_aux 0 e \\<le> h' e\n 2. \\<And>j e.\n       \\<lbrakk>e \\<in> set (cycle_edges (enum_cycle j)) \\<Longrightarrow>\n                h_minus_aux j e \\<le> h' e;\n        \\<And>x xa.\n           e \\<in> set (cycle_edges (enum_cycle j)) \\<Longrightarrow>\n           h_minus_aux j xa \\<le> h' xa;\n        e \\<notin> set (cycle_edges (enum_cycle j)) \\<Longrightarrow>\n        h_minus_aux j e \\<le> h' e\\<rbrakk>\n       \\<Longrightarrow> h_minus_aux (Suc j) e \\<le> h' e", "case 0: (1 e)"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>e. h_minus_aux 0 e \\<le> h' e\n 2. \\<And>j e.\n       \\<lbrakk>e \\<in> set (cycle_edges (enum_cycle j)) \\<Longrightarrow>\n                h_minus_aux j e \\<le> h' e;\n        \\<And>x xa.\n           e \\<in> set (cycle_edges (enum_cycle j)) \\<Longrightarrow>\n           h_minus_aux j xa \\<le> h' xa;\n        e \\<notin> set (cycle_edges (enum_cycle j)) \\<Longrightarrow>\n        h_minus_aux j e \\<le> h' e\\<rbrakk>\n       \\<Longrightarrow> h_minus_aux (Suc j) e \\<le> h' e", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. h_minus_aux 0 e \\<le> h' e", "by simp"], ["proof (state)\nthis:\n  h_minus_aux 0 e \\<le> h' e\n\ngoal (1 subgoal):\n 1. \\<And>j e.\n       \\<lbrakk>e \\<in> set (cycle_edges (enum_cycle j)) \\<Longrightarrow>\n                h_minus_aux j e \\<le> h' e;\n        \\<And>x xa.\n           e \\<in> set (cycle_edges (enum_cycle j)) \\<Longrightarrow>\n           h_minus_aux j xa \\<le> h' xa;\n        e \\<notin> set (cycle_edges (enum_cycle j)) \\<Longrightarrow>\n        h_minus_aux j e \\<le> h' e\\<rbrakk>\n       \\<Longrightarrow> h_minus_aux (Suc j) e \\<le> h' e", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j e.\n       \\<lbrakk>e \\<in> set (cycle_edges (enum_cycle j)) \\<Longrightarrow>\n                h_minus_aux j e \\<le> h' e;\n        \\<And>x xa.\n           e \\<in> set (cycle_edges (enum_cycle j)) \\<Longrightarrow>\n           h_minus_aux j xa \\<le> h' xa;\n        e \\<notin> set (cycle_edges (enum_cycle j)) \\<Longrightarrow>\n        h_minus_aux j e \\<le> h' e\\<rbrakk>\n       \\<Longrightarrow> h_minus_aux (Suc j) e \\<le> h' e", "case Suc: (2 j e)"], ["proof (state)\nthis:\n  e \\<in> set (cycle_edges (enum_cycle j)) \\<Longrightarrow>\n  h_minus_aux j e \\<le> h' e\n  e \\<in> set (cycle_edges (enum_cycle j)) \\<Longrightarrow>\n  h_minus_aux j ?xa \\<le> h' ?xa\n  e \\<notin> set (cycle_edges (enum_cycle j)) \\<Longrightarrow>\n  h_minus_aux j e \\<le> h' e\n\ngoal (1 subgoal):\n 1. \\<And>j e.\n       \\<lbrakk>e \\<in> set (cycle_edges (enum_cycle j)) \\<Longrightarrow>\n                h_minus_aux j e \\<le> h' e;\n        \\<And>x xa.\n           e \\<in> set (cycle_edges (enum_cycle j)) \\<Longrightarrow>\n           h_minus_aux j xa \\<le> h' xa;\n        e \\<notin> set (cycle_edges (enum_cycle j)) \\<Longrightarrow>\n        h_minus_aux j e \\<le> h' e\\<rbrakk>\n       \\<Longrightarrow> h_minus_aux (Suc j) e \\<le> h' e", "{"], ["proof (state)\nthis:\n  e \\<in> set (cycle_edges (enum_cycle j)) \\<Longrightarrow>\n  h_minus_aux j e \\<le> h' e\n  e \\<in> set (cycle_edges (enum_cycle j)) \\<Longrightarrow>\n  h_minus_aux j ?xa \\<le> h' ?xa\n  e \\<notin> set (cycle_edges (enum_cycle j)) \\<Longrightarrow>\n  h_minus_aux j e \\<le> h' e\n\ngoal (1 subgoal):\n 1. \\<And>j e.\n       \\<lbrakk>e \\<in> set (cycle_edges (enum_cycle j)) \\<Longrightarrow>\n                h_minus_aux j e \\<le> h' e;\n        \\<And>x xa.\n           e \\<in> set (cycle_edges (enum_cycle j)) \\<Longrightarrow>\n           h_minus_aux j xa \\<le> h' xa;\n        e \\<notin> set (cycle_edges (enum_cycle j)) \\<Longrightarrow>\n        h_minus_aux j e \\<le> h' e\\<rbrakk>\n       \\<Longrightarrow> h_minus_aux (Suc j) e \\<le> h' e", "assume e: \"e \\<in> set (cycle_edges (enum_cycle j))\""], ["proof (state)\nthis:\n  e \\<in> set (cycle_edges (enum_cycle j))\n\ngoal (1 subgoal):\n 1. \\<And>j e.\n       \\<lbrakk>e \\<in> set (cycle_edges (enum_cycle j)) \\<Longrightarrow>\n                h_minus_aux j e \\<le> h' e;\n        \\<And>x xa.\n           e \\<in> set (cycle_edges (enum_cycle j)) \\<Longrightarrow>\n           h_minus_aux j xa \\<le> h' xa;\n        e \\<notin> set (cycle_edges (enum_cycle j)) \\<Longrightarrow>\n        h_minus_aux j e \\<le> h' e\\<rbrakk>\n       \\<Longrightarrow> h_minus_aux (Suc j) e \\<le> h' e", "then"], ["proof (chain)\npicking this:\n  e \\<in> set (cycle_edges (enum_cycle j))", "have \"h_minus_aux j e + Min {h' e' - h_minus_aux j e' |e'. e' \\<in> set (cycle_edges (enum_cycle j))} \\<le>\n      h_minus_aux j e + (h' e - h_minus_aux j e)\""], ["proof (prove)\nusing this:\n  e \\<in> set (cycle_edges (enum_cycle j))\n\ngoal (1 subgoal):\n 1. h_minus_aux j e +\n    Min {h' e' - h_minus_aux j e' |e'.\n         e' \\<in> set (cycle_edges (enum_cycle j))}\n    \\<le> h_minus_aux j e + (h' e - h_minus_aux j e)", "using [[simproc add: finite_Collect]]"], ["proof (prove)\nusing this:\n  e \\<in> set (cycle_edges (enum_cycle j))\n\ngoal (1 subgoal):\n 1. h_minus_aux j e +\n    Min {h' e' - h_minus_aux j e' |e'.\n         e' \\<in> set (cycle_edges (enum_cycle j))}\n    \\<le> h_minus_aux j e + (h' e - h_minus_aux j e)", "by(cases e rule: prod.exhaust)(auto intro!: add_mono Min_le)"], ["proof (state)\nthis:\n  h_minus_aux j e +\n  Min {h' e' - h_minus_aux j e' |e'.\n       e' \\<in> set (cycle_edges (enum_cycle j))}\n  \\<le> h_minus_aux j e + (h' e - h_minus_aux j e)\n\ngoal (1 subgoal):\n 1. \\<And>j e.\n       \\<lbrakk>e \\<in> set (cycle_edges (enum_cycle j)) \\<Longrightarrow>\n                h_minus_aux j e \\<le> h' e;\n        \\<And>x xa.\n           e \\<in> set (cycle_edges (enum_cycle j)) \\<Longrightarrow>\n           h_minus_aux j xa \\<le> h' xa;\n        e \\<notin> set (cycle_edges (enum_cycle j)) \\<Longrightarrow>\n        h_minus_aux j e \\<le> h' e\\<rbrakk>\n       \\<Longrightarrow> h_minus_aux (Suc j) e \\<le> h' e", "also"], ["proof (state)\nthis:\n  h_minus_aux j e +\n  Min {h' e' - h_minus_aux j e' |e'.\n       e' \\<in> set (cycle_edges (enum_cycle j))}\n  \\<le> h_minus_aux j e + (h' e - h_minus_aux j e)\n\ngoal (1 subgoal):\n 1. \\<And>j e.\n       \\<lbrakk>e \\<in> set (cycle_edges (enum_cycle j)) \\<Longrightarrow>\n                h_minus_aux j e \\<le> h' e;\n        \\<And>x xa.\n           e \\<in> set (cycle_edges (enum_cycle j)) \\<Longrightarrow>\n           h_minus_aux j xa \\<le> h' xa;\n        e \\<notin> set (cycle_edges (enum_cycle j)) \\<Longrightarrow>\n        h_minus_aux j e \\<le> h' e\\<rbrakk>\n       \\<Longrightarrow> h_minus_aux (Suc j) e \\<le> h' e", "have \"\\<dots> = h' e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h_minus_aux j e + (h' e - h_minus_aux j e) = h' e", "using e finite_h'[of e] Suc.IH(2)[of e]"], ["proof (prove)\nusing this:\n  e \\<in> set (cycle_edges (enum_cycle j))\n  h' e \\<noteq> \\<top>\n  e \\<in> set (cycle_edges (enum_cycle j)) \\<Longrightarrow>\n  h_minus_aux j e \\<le> h' e\n\ngoal (1 subgoal):\n 1. h_minus_aux j e + (h' e - h_minus_aux j e) = h' e", "by(cases e rule: prod.exhaust)\n        (auto simp add: add_diff_eq_ennreal top_unique intro!: ennreal_add_diff_cancel_left)"], ["proof (state)\nthis:\n  h_minus_aux j e + (h' e - h_minus_aux j e) = h' e\n\ngoal (1 subgoal):\n 1. \\<And>j e.\n       \\<lbrakk>e \\<in> set (cycle_edges (enum_cycle j)) \\<Longrightarrow>\n                h_minus_aux j e \\<le> h' e;\n        \\<And>x xa.\n           e \\<in> set (cycle_edges (enum_cycle j)) \\<Longrightarrow>\n           h_minus_aux j xa \\<le> h' xa;\n        e \\<notin> set (cycle_edges (enum_cycle j)) \\<Longrightarrow>\n        h_minus_aux j e \\<le> h' e\\<rbrakk>\n       \\<Longrightarrow> h_minus_aux (Suc j) e \\<le> h' e", "also"], ["proof (state)\nthis:\n  h_minus_aux j e + (h' e - h_minus_aux j e) = h' e\n\ngoal (1 subgoal):\n 1. \\<And>j e.\n       \\<lbrakk>e \\<in> set (cycle_edges (enum_cycle j)) \\<Longrightarrow>\n                h_minus_aux j e \\<le> h' e;\n        \\<And>x xa.\n           e \\<in> set (cycle_edges (enum_cycle j)) \\<Longrightarrow>\n           h_minus_aux j xa \\<le> h' xa;\n        e \\<notin> set (cycle_edges (enum_cycle j)) \\<Longrightarrow>\n        h_minus_aux j e \\<le> h' e\\<rbrakk>\n       \\<Longrightarrow> h_minus_aux (Suc j) e \\<le> h' e", "note calculation"], ["proof (state)\nthis:\n  h_minus_aux j e +\n  Min {h' e' - h_minus_aux j e' |e'.\n       e' \\<in> set (cycle_edges (enum_cycle j))}\n  \\<le> h' e\n\ngoal (1 subgoal):\n 1. \\<And>j e.\n       \\<lbrakk>e \\<in> set (cycle_edges (enum_cycle j)) \\<Longrightarrow>\n                h_minus_aux j e \\<le> h' e;\n        \\<And>x xa.\n           e \\<in> set (cycle_edges (enum_cycle j)) \\<Longrightarrow>\n           h_minus_aux j xa \\<le> h' xa;\n        e \\<notin> set (cycle_edges (enum_cycle j)) \\<Longrightarrow>\n        h_minus_aux j e \\<le> h' e\\<rbrakk>\n       \\<Longrightarrow> h_minus_aux (Suc j) e \\<le> h' e", "}"], ["proof (state)\nthis:\n  e \\<in> set (cycle_edges (enum_cycle j)) \\<Longrightarrow>\n  h_minus_aux j e +\n  Min {h' e' - h_minus_aux j e' |e'.\n       e' \\<in> set (cycle_edges (enum_cycle j))}\n  \\<le> h' e\n\ngoal (1 subgoal):\n 1. \\<And>j e.\n       \\<lbrakk>e \\<in> set (cycle_edges (enum_cycle j)) \\<Longrightarrow>\n                h_minus_aux j e \\<le> h' e;\n        \\<And>x xa.\n           e \\<in> set (cycle_edges (enum_cycle j)) \\<Longrightarrow>\n           h_minus_aux j xa \\<le> h' xa;\n        e \\<notin> set (cycle_edges (enum_cycle j)) \\<Longrightarrow>\n        h_minus_aux j e \\<le> h' e\\<rbrakk>\n       \\<Longrightarrow> h_minus_aux (Suc j) e \\<le> h' e", "then"], ["proof (chain)\npicking this:\n  e \\<in> set (cycle_edges (enum_cycle j)) \\<Longrightarrow>\n  h_minus_aux j e +\n  Min {h' e' - h_minus_aux j e' |e'.\n       e' \\<in> set (cycle_edges (enum_cycle j))}\n  \\<le> h' e", "show ?case"], ["proof (prove)\nusing this:\n  e \\<in> set (cycle_edges (enum_cycle j)) \\<Longrightarrow>\n  h_minus_aux j e +\n  Min {h' e' - h_minus_aux j e' |e'.\n       e' \\<in> set (cycle_edges (enum_cycle j))}\n  \\<le> h' e\n\ngoal (1 subgoal):\n 1. h_minus_aux (Suc j) e \\<le> h' e", "using Suc"], ["proof (prove)\nusing this:\n  e \\<in> set (cycle_edges (enum_cycle j)) \\<Longrightarrow>\n  h_minus_aux j e +\n  Min {h' e' - h_minus_aux j e' |e'.\n       e' \\<in> set (cycle_edges (enum_cycle j))}\n  \\<le> h' e\n  e \\<in> set (cycle_edges (enum_cycle j)) \\<Longrightarrow>\n  h_minus_aux j e \\<le> h' e\n  e \\<in> set (cycle_edges (enum_cycle j)) \\<Longrightarrow>\n  h_minus_aux j ?xa \\<le> h' ?xa\n  e \\<notin> set (cycle_edges (enum_cycle j)) \\<Longrightarrow>\n  h_minus_aux j e \\<le> h' e\n\ngoal (1 subgoal):\n 1. h_minus_aux (Suc j) e \\<le> h' e", "by clarsimp"], ["proof (state)\nthis:\n  h_minus_aux (Suc j) e \\<le> h' e\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma h_minus_aux_finite [simp]: \"h_minus_aux j e \\<noteq> top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h_minus_aux j e \\<noteq> \\<top>", "using h_minus_aux_le_h'[of j e] finite_h'[of e]"], ["proof (prove)\nusing this:\n  h_minus_aux j e \\<le> h' e\n  h' e \\<noteq> \\<top>\n\ngoal (1 subgoal):\n 1. h_minus_aux j e \\<noteq> \\<top>", "by (auto simp: top_unique)"], ["", "lemma h_minus_aux_mono: \"h_minus_aux j e \\<le> h_minus_aux (Suc j) e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h_minus_aux j e \\<le> h_minus_aux (Suc j) e", "proof(cases \"e \\<in> set (cycle_edges (enum_cycle j)) = True\")"], ["proof (state)\ngoal (2 subgoals):\n 1. (e \\<in> set (cycle_edges (enum_cycle j))) = True \\<Longrightarrow>\n    h_minus_aux j e \\<le> h_minus_aux (Suc j) e\n 2. (e \\<in> set (cycle_edges (enum_cycle j))) \\<noteq>\n    True \\<Longrightarrow>\n    h_minus_aux j e \\<le> h_minus_aux (Suc j) e", "case True"], ["proof (state)\nthis:\n  (e \\<in> set (cycle_edges (enum_cycle j))) = True\n\ngoal (2 subgoals):\n 1. (e \\<in> set (cycle_edges (enum_cycle j))) = True \\<Longrightarrow>\n    h_minus_aux j e \\<le> h_minus_aux (Suc j) e\n 2. (e \\<in> set (cycle_edges (enum_cycle j))) \\<noteq>\n    True \\<Longrightarrow>\n    h_minus_aux j e \\<le> h_minus_aux (Suc j) e", "have \"h_minus_aux j e + 0 \\<le> h_minus_aux (Suc j) e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h_minus_aux j e + 0 \\<le> h_minus_aux (Suc j) e", "unfolding h_minus_aux.simps True if_True"], ["proof (prove)\ngoal (1 subgoal):\n 1. h_minus_aux j e + 0\n    \\<le> h_minus_aux j e +\n          Min {h' e' - h_minus_aux j e' |e'.\n               e' \\<in> set (cycle_edges (enum_cycle j))}", "using True [[simproc add: finite_Collect]]"], ["proof (prove)\nusing this:\n  (e \\<in> set (cycle_edges (enum_cycle j))) = True\n\ngoal (1 subgoal):\n 1. h_minus_aux j e + 0\n    \\<le> h_minus_aux j e +\n          Min {h' e' - h_minus_aux j e' |e'.\n               e' \\<in> set (cycle_edges (enum_cycle j))}", "by(cases e)(rule add_mono, auto intro!: Min.boundedI simp add: h_minus_aux_le_h')"], ["proof (state)\nthis:\n  h_minus_aux j e + 0 \\<le> h_minus_aux (Suc j) e\n\ngoal (2 subgoals):\n 1. (e \\<in> set (cycle_edges (enum_cycle j))) = True \\<Longrightarrow>\n    h_minus_aux j e \\<le> h_minus_aux (Suc j) e\n 2. (e \\<in> set (cycle_edges (enum_cycle j))) \\<noteq>\n    True \\<Longrightarrow>\n    h_minus_aux j e \\<le> h_minus_aux (Suc j) e", "thus ?thesis"], ["proof (prove)\nusing this:\n  h_minus_aux j e + 0 \\<le> h_minus_aux (Suc j) e\n\ngoal (1 subgoal):\n 1. h_minus_aux j e \\<le> h_minus_aux (Suc j) e", "by simp"], ["proof (state)\nthis:\n  h_minus_aux j e \\<le> h_minus_aux (Suc j) e\n\ngoal (1 subgoal):\n 1. (e \\<in> set (cycle_edges (enum_cycle j))) \\<noteq>\n    True \\<Longrightarrow>\n    h_minus_aux j e \\<le> h_minus_aux (Suc j) e", "qed simp"], ["", "lemma d_OUT_h_minus_aux:\n  assumes \"cycles \\<Delta> \\<noteq> {}\"\n  shows \"d_OUT (h_minus_aux j) x = d_IN (h_minus_aux j) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. KIR (h_minus_aux j) x", "proof(induction j)"], ["proof (state)\ngoal (2 subgoals):\n 1. KIR (h_minus_aux 0) x\n 2. \\<And>j.\n       KIR (h_minus_aux j) x \\<Longrightarrow> KIR (h_minus_aux (Suc j)) x", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. KIR (h_minus_aux 0) x\n 2. \\<And>j.\n       KIR (h_minus_aux j) x \\<Longrightarrow> KIR (h_minus_aux (Suc j)) x", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. KIR (h_minus_aux 0) x", "by simp"], ["proof (state)\nthis:\n  KIR (h_minus_aux 0) x\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       KIR (h_minus_aux j) x \\<Longrightarrow> KIR (h_minus_aux (Suc j)) x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j.\n       KIR (h_minus_aux j) x \\<Longrightarrow> KIR (h_minus_aux (Suc j)) x", "case (Suc j)"], ["proof (state)\nthis:\n  KIR (h_minus_aux j) x\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       KIR (h_minus_aux j) x \\<Longrightarrow> KIR (h_minus_aux (Suc j)) x", "define C where \"C = enum_cycle j\""], ["proof (state)\nthis:\n  C = enum_cycle j\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       KIR (h_minus_aux j) x \\<Longrightarrow> KIR (h_minus_aux (Suc j)) x", "define \\<delta> where \"\\<delta> = Min {h' e' - h_minus_aux j e' |e'. e' \\<in> set (cycle_edges C)}\""], ["proof (state)\nthis:\n  \\<delta> =\n  Min {h' e' - h_minus_aux j e' |e'. e' \\<in> set (cycle_edges C)}\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       KIR (h_minus_aux j) x \\<Longrightarrow> KIR (h_minus_aux (Suc j)) x", "have \"d_OUT (h_minus_aux (Suc j)) x =\n    (\\<Sum>\\<^sup>+ y. h_minus_aux j (x, y) + (if (x, y) \\<in> set (cycle_edges C) then \\<delta> else 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT (h_minus_aux (Suc j)) x =\n    (\\<Sum>\\<^sup>+ y.\n       h_minus_aux j (x, y) +\n       (if (x, y) \\<in> set (cycle_edges C) then \\<delta> else 0))", "unfolding d_OUT_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y. h_minus_aux (Suc j) (x, y)) =\n    (\\<Sum>\\<^sup>+ y.\n       h_minus_aux j (x, y) +\n       (if (x, y) \\<in> set (cycle_edges C) then \\<delta> else 0))", "by(simp add: if_distrib C_def \\<delta>_def cong del: if_weak_cong)"], ["proof (state)\nthis:\n  d_OUT (h_minus_aux (Suc j)) x =\n  (\\<Sum>\\<^sup>+ y.\n     h_minus_aux j (x, y) +\n     (if (x, y) \\<in> set (cycle_edges C) then \\<delta> else 0))\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       KIR (h_minus_aux j) x \\<Longrightarrow> KIR (h_minus_aux (Suc j)) x", "also"], ["proof (state)\nthis:\n  d_OUT (h_minus_aux (Suc j)) x =\n  (\\<Sum>\\<^sup>+ y.\n     h_minus_aux j (x, y) +\n     (if (x, y) \\<in> set (cycle_edges C) then \\<delta> else 0))\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       KIR (h_minus_aux j) x \\<Longrightarrow> KIR (h_minus_aux (Suc j)) x", "have \"\\<dots> = d_OUT (h_minus_aux j) x + (\\<Sum>\\<^sup>+ y. \\<delta> * indicator (set (cycle_edges C)) (x, y))\"\n    (is \"_ = _ + ?add\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y.\n       h_minus_aux j (x, y) +\n       (if (x, y) \\<in> set (cycle_edges C) then \\<delta> else 0)) =\n    d_OUT (h_minus_aux j) x +\n    (\\<Sum>\\<^sup>+ y. \\<delta> * indicator (set (cycle_edges C)) (x, y))", "by(subst nn_integral_add)(auto simp add: AE_count_space d_OUT_def intro!: arg_cong2[where f=\"(+)\"] nn_integral_cong)"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y.\n     h_minus_aux j (x, y) +\n     (if (x, y) \\<in> set (cycle_edges C) then \\<delta> else 0)) =\n  d_OUT (h_minus_aux j) x +\n  (\\<Sum>\\<^sup>+ y. \\<delta> * indicator (set (cycle_edges C)) (x, y))\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       KIR (h_minus_aux j) x \\<Longrightarrow> KIR (h_minus_aux (Suc j)) x", "also"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y.\n     h_minus_aux j (x, y) +\n     (if (x, y) \\<in> set (cycle_edges C) then \\<delta> else 0)) =\n  d_OUT (h_minus_aux j) x +\n  (\\<Sum>\\<^sup>+ y. \\<delta> * indicator (set (cycle_edges C)) (x, y))\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       KIR (h_minus_aux j) x \\<Longrightarrow> KIR (h_minus_aux (Suc j)) x", "have \"?add = (\\<Sum>\\<^sup>+ e\\<in>range (Pair x). \\<delta> * indicator {(x', y). (x', y) \\<in> set (cycle_edges C) \\<and> x' = x} e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y. \\<delta> * indicator (set (cycle_edges C)) (x, y)) =\n    \\<integral>\\<^sup>+e\\<in>{(x', y).\n                              (x', y) \\<in> set (cycle_edges C) \\<and>\n                              x' = x}.\n                       \\<delta>\n    \\<partial>count_space (range (Pair x))", "by(auto simp add: nn_integral_count_space_reindex intro!: nn_integral_cong split: split_indicator)"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y. \\<delta> * indicator (set (cycle_edges C)) (x, y)) =\n  \\<integral>\\<^sup>+e\\<in>{(x', y).\n                            (x', y) \\<in> set (cycle_edges C) \\<and>\n                            x' = x}.\n                     \\<delta>\n  \\<partial>count_space (range (Pair x))\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       KIR (h_minus_aux j) x \\<Longrightarrow> KIR (h_minus_aux (Suc j)) x", "also"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y. \\<delta> * indicator (set (cycle_edges C)) (x, y)) =\n  \\<integral>\\<^sup>+e\\<in>{(x', y).\n                            (x', y) \\<in> set (cycle_edges C) \\<and>\n                            x' = x}.\n                     \\<delta>\n  \\<partial>count_space (range (Pair x))\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       KIR (h_minus_aux j) x \\<Longrightarrow> KIR (h_minus_aux (Suc j)) x", "have \"\\<dots> = \\<delta> * card (set (filter (\\<lambda>(x', y). x' = x) (cycle_edges C)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+e\\<in>{(x', y).\n                              (x', y) \\<in> set (cycle_edges C) \\<and>\n                              x' = x}.\n                       \\<delta>\n    \\<partial>count_space (range (Pair x)) =\n    \\<delta> *\n    of_nat (card (set (filter (\\<lambda>(x', y). x' = x) (cycle_edges C))))", "using [[simproc add: finite_Collect]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+e\\<in>{(x', y).\n                              (x', y) \\<in> set (cycle_edges C) \\<and>\n                              x' = x}.\n                       \\<delta>\n    \\<partial>count_space (range (Pair x)) =\n    \\<delta> *\n    of_nat (card (set (filter (\\<lambda>(x', y). x' = x) (cycle_edges C))))", "apply(subst nn_integral_cmult_indicator; auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<delta> *\n    emeasure (count_space (range (Pair x)))\n     {(x', y). (x', y) \\<in> set (cycle_edges C) \\<and> x' = x} =\n    \\<delta> *\n    of_nat\n     (card\n       {xa \\<in> set (cycle_edges C).\n        case xa of (x', y) \\<Rightarrow> x' = x})", "apply(subst emeasure_count_space; auto simp add: split_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+e\\<in>{(x', y).\n                            (x', y) \\<in> set (cycle_edges C) \\<and>\n                            x' = x}.\n                     \\<delta>\n  \\<partial>count_space (range (Pair x)) =\n  \\<delta> *\n  of_nat (card (set (filter (\\<lambda>(x', y). x' = x) (cycle_edges C))))\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       KIR (h_minus_aux j) x \\<Longrightarrow> KIR (h_minus_aux (Suc j)) x", "also"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+e\\<in>{(x', y).\n                            (x', y) \\<in> set (cycle_edges C) \\<and>\n                            x' = x}.\n                     \\<delta>\n  \\<partial>count_space (range (Pair x)) =\n  \\<delta> *\n  of_nat (card (set (filter (\\<lambda>(x', y). x' = x) (cycle_edges C))))\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       KIR (h_minus_aux j) x \\<Longrightarrow> KIR (h_minus_aux (Suc j)) x", "have \"card (set (filter (\\<lambda>(x', y). x' = x) (cycle_edges C))) = card (set (filter (\\<lambda>(x', y). y = x) (cycle_edges C)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (set (filter (\\<lambda>(x', y). x' = x) (cycle_edges C))) =\n    card (set (filter (\\<lambda>(x', y). y = x) (cycle_edges C)))", "unfolding C_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. card\n     (set (filter (\\<lambda>(x', y). x' = x)\n            (cycle_edges (enum_cycle j)))) =\n    card\n     (set (filter (\\<lambda>(x', y). y = x) (cycle_edges (enum_cycle j))))", "by(rule cycle_enter_leave_same)(rule cycle_enum_cycle[OF assms])"], ["proof (state)\nthis:\n  card (set (filter (\\<lambda>(x', y). x' = x) (cycle_edges C))) =\n  card (set (filter (\\<lambda>(x', y). y = x) (cycle_edges C)))\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       KIR (h_minus_aux j) x \\<Longrightarrow> KIR (h_minus_aux (Suc j)) x", "also"], ["proof (state)\nthis:\n  card (set (filter (\\<lambda>(x', y). x' = x) (cycle_edges C))) =\n  card (set (filter (\\<lambda>(x', y). y = x) (cycle_edges C)))\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       KIR (h_minus_aux j) x \\<Longrightarrow> KIR (h_minus_aux (Suc j)) x", "have \"\\<delta> * \\<dots> =  (\\<Sum>\\<^sup>+ e\\<in>range (\\<lambda>x'. (x', x)). \\<delta> * indicator {(x', y). (x', y) \\<in> set (cycle_edges C) \\<and> y = x} e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<delta> *\n    of_nat (card (set (filter (\\<lambda>(x', y). y = x) (cycle_edges C)))) =\n    \\<integral>\\<^sup>+e\\<in>{(x', y).\n                              (x', y) \\<in> set (cycle_edges C) \\<and>\n                              y = x}.\n                       \\<delta>\n    \\<partial>count_space (range (\\<lambda>x'. (x', x)))", "using [[simproc add: finite_Collect]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<delta> *\n    of_nat (card (set (filter (\\<lambda>(x', y). y = x) (cycle_edges C)))) =\n    \\<integral>\\<^sup>+e\\<in>{(x', y).\n                              (x', y) \\<in> set (cycle_edges C) \\<and>\n                              y = x}.\n                       \\<delta>\n    \\<partial>count_space (range (\\<lambda>x'. (x', x)))", "apply(subst nn_integral_cmult_indicator; auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<delta> *\n    of_nat\n     (card\n       {xa \\<in> set (cycle_edges C).\n        case xa of (x', y) \\<Rightarrow> y = x}) =\n    \\<delta> *\n    emeasure (count_space (range (\\<lambda>x'. (x', x))))\n     {(x', y). (x', y) \\<in> set (cycle_edges C) \\<and> y = x}", "apply(subst emeasure_count_space; auto simp add: split_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<delta> *\n  of_nat (card (set (filter (\\<lambda>(x', y). y = x) (cycle_edges C)))) =\n  \\<integral>\\<^sup>+e\\<in>{(x', y).\n                            (x', y) \\<in> set (cycle_edges C) \\<and> y = x}.\n                     \\<delta>\n  \\<partial>count_space (range (\\<lambda>x'. (x', x)))\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       KIR (h_minus_aux j) x \\<Longrightarrow> KIR (h_minus_aux (Suc j)) x", "also"], ["proof (state)\nthis:\n  \\<delta> *\n  of_nat (card (set (filter (\\<lambda>(x', y). y = x) (cycle_edges C)))) =\n  \\<integral>\\<^sup>+e\\<in>{(x', y).\n                            (x', y) \\<in> set (cycle_edges C) \\<and> y = x}.\n                     \\<delta>\n  \\<partial>count_space (range (\\<lambda>x'. (x', x)))\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       KIR (h_minus_aux j) x \\<Longrightarrow> KIR (h_minus_aux (Suc j)) x", "have \"\\<dots> = (\\<Sum>\\<^sup>+ x'. \\<delta> * indicator (set (cycle_edges C)) (x', x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+e\\<in>{(x', y).\n                              (x', y) \\<in> set (cycle_edges C) \\<and>\n                              y = x}.\n                       \\<delta>\n    \\<partial>count_space (range (\\<lambda>x'. (x', x))) =\n    (\\<Sum>\\<^sup>+ x'. \\<delta> * indicator (set (cycle_edges C)) (x', x))", "by(auto simp add: nn_integral_count_space_reindex intro!: nn_integral_cong split: split_indicator)"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+e\\<in>{(x', y).\n                            (x', y) \\<in> set (cycle_edges C) \\<and> y = x}.\n                     \\<delta>\n  \\<partial>count_space (range (\\<lambda>x'. (x', x))) =\n  (\\<Sum>\\<^sup>+ x'. \\<delta> * indicator (set (cycle_edges C)) (x', x))\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       KIR (h_minus_aux j) x \\<Longrightarrow> KIR (h_minus_aux (Suc j)) x", "also"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+e\\<in>{(x', y).\n                            (x', y) \\<in> set (cycle_edges C) \\<and> y = x}.\n                     \\<delta>\n  \\<partial>count_space (range (\\<lambda>x'. (x', x))) =\n  (\\<Sum>\\<^sup>+ x'. \\<delta> * indicator (set (cycle_edges C)) (x', x))\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       KIR (h_minus_aux j) x \\<Longrightarrow> KIR (h_minus_aux (Suc j)) x", "have \"d_OUT (h_minus_aux j) x + \\<dots> = (\\<Sum>\\<^sup>+ x'. h_minus_aux j (x', x) + \\<delta> * indicator (set (cycle_edges C)) (x', x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT (h_minus_aux j) x +\n    (\\<Sum>\\<^sup>+ x'.\n       \\<delta> * indicator (set (cycle_edges C)) (x', x)) =\n    (\\<Sum>\\<^sup>+ x'.\n       h_minus_aux j (x', x) +\n       \\<delta> * indicator (set (cycle_edges C)) (x', x))", "unfolding Suc.IH d_IN_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ xa. h_minus_aux j (xa, x)) +\n    (\\<Sum>\\<^sup>+ x'.\n       \\<delta> * indicator (set (cycle_edges C)) (x', x)) =\n    (\\<Sum>\\<^sup>+ x'.\n       h_minus_aux j (x', x) +\n       \\<delta> * indicator (set (cycle_edges C)) (x', x))", "by(simp add: nn_integral_add[symmetric])"], ["proof (state)\nthis:\n  d_OUT (h_minus_aux j) x +\n  (\\<Sum>\\<^sup>+ x'. \\<delta> * indicator (set (cycle_edges C)) (x', x)) =\n  (\\<Sum>\\<^sup>+ x'.\n     h_minus_aux j (x', x) +\n     \\<delta> * indicator (set (cycle_edges C)) (x', x))\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       KIR (h_minus_aux j) x \\<Longrightarrow> KIR (h_minus_aux (Suc j)) x", "also"], ["proof (state)\nthis:\n  d_OUT (h_minus_aux j) x +\n  (\\<Sum>\\<^sup>+ x'. \\<delta> * indicator (set (cycle_edges C)) (x', x)) =\n  (\\<Sum>\\<^sup>+ x'.\n     h_minus_aux j (x', x) +\n     \\<delta> * indicator (set (cycle_edges C)) (x', x))\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       KIR (h_minus_aux j) x \\<Longrightarrow> KIR (h_minus_aux (Suc j)) x", "have \"\\<dots> = d_IN (h_minus_aux (Suc j)) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ x'.\n       h_minus_aux j (x', x) +\n       \\<delta> * indicator (set (cycle_edges C)) (x', x)) =\n    d_IN (h_minus_aux (Suc j)) x", "unfolding d_IN_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ x'.\n       h_minus_aux j (x', x) +\n       \\<delta> * indicator (set (cycle_edges C)) (x', x)) =\n    (\\<Sum>\\<^sup>+ xa. h_minus_aux (Suc j) (xa, x))", "by(auto intro!: nn_integral_cong simp add: \\<delta>_def C_def split: split_indicator)"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ x'.\n     h_minus_aux j (x', x) +\n     \\<delta> * indicator (set (cycle_edges C)) (x', x)) =\n  d_IN (h_minus_aux (Suc j)) x\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       KIR (h_minus_aux j) x \\<Longrightarrow> KIR (h_minus_aux (Suc j)) x", "finally"], ["proof (chain)\npicking this:\n  KIR (h_minus_aux (Suc j)) x", "show ?case"], ["proof (prove)\nusing this:\n  KIR (h_minus_aux (Suc j)) x\n\ngoal (1 subgoal):\n 1. KIR (h_minus_aux (Suc j)) x", "."], ["proof (state)\nthis:\n  KIR (h_minus_aux (Suc j)) x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma h_minus_aux_source:\n  assumes \"cycles \\<Delta> \\<noteq> {}\"\n  shows \"h_minus_aux j (source \\<Delta>, y) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h_minus_aux j (source \\<Delta>, y) = 0", "proof(induction j)"], ["proof (state)\ngoal (2 subgoals):\n 1. h_minus_aux 0 (source \\<Delta>, y) = 0\n 2. \\<And>j.\n       h_minus_aux j (source \\<Delta>, y) = 0 \\<Longrightarrow>\n       h_minus_aux (Suc j) (source \\<Delta>, y) = 0", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. h_minus_aux 0 (source \\<Delta>, y) = 0\n 2. \\<And>j.\n       h_minus_aux j (source \\<Delta>, y) = 0 \\<Longrightarrow>\n       h_minus_aux (Suc j) (source \\<Delta>, y) = 0", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. h_minus_aux 0 (source \\<Delta>, y) = 0", "by simp"], ["proof (state)\nthis:\n  h_minus_aux 0 (source \\<Delta>, y) = 0\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       h_minus_aux j (source \\<Delta>, y) = 0 \\<Longrightarrow>\n       h_minus_aux (Suc j) (source \\<Delta>, y) = 0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j.\n       h_minus_aux j (source \\<Delta>, y) = 0 \\<Longrightarrow>\n       h_minus_aux (Suc j) (source \\<Delta>, y) = 0", "case (Suc j)"], ["proof (state)\nthis:\n  h_minus_aux j (source \\<Delta>, y) = 0\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       h_minus_aux j (source \\<Delta>, y) = 0 \\<Longrightarrow>\n       h_minus_aux (Suc j) (source \\<Delta>, y) = 0", "have \"(source \\<Delta>, y) \\<notin> set (cycle_edges (enum_cycle j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (source \\<Delta>, y) \\<notin> set (cycle_edges (enum_cycle j))", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. (source \\<Delta>, y)\n    \\<in> set (cycle_edges (enum_cycle j)) \\<Longrightarrow>\n    False", "assume *: \"(source \\<Delta>, y) \\<in> set (cycle_edges (enum_cycle j))\""], ["proof (state)\nthis:\n  (source \\<Delta>, y) \\<in> set (cycle_edges (enum_cycle j))\n\ngoal (1 subgoal):\n 1. (source \\<Delta>, y)\n    \\<in> set (cycle_edges (enum_cycle j)) \\<Longrightarrow>\n    False", "have cycle: \"cycle \\<Delta> (enum_cycle j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cycle \\<Delta> (enum_cycle j)", "using assms"], ["proof (prove)\nusing this:\n  cycles \\<Delta> \\<noteq> {}\n\ngoal (1 subgoal):\n 1. cycle \\<Delta> (enum_cycle j)", "by(rule cycle_enum_cycle)"], ["proof (state)\nthis:\n  cycle \\<Delta> (enum_cycle j)\n\ngoal (1 subgoal):\n 1. (source \\<Delta>, y)\n    \\<in> set (cycle_edges (enum_cycle j)) \\<Longrightarrow>\n    False", "from cycle_leave_ex_enter[OF this *]"], ["proof (chain)\npicking this:\n  \\<exists>z. (z, source \\<Delta>) \\<in> set (cycle_edges (enum_cycle j))", "obtain z where \"(z, source \\<Delta>) \\<in> set (cycle_edges (enum_cycle j))\""], ["proof (prove)\nusing this:\n  \\<exists>z. (z, source \\<Delta>) \\<in> set (cycle_edges (enum_cycle j))\n\ngoal (1 subgoal):\n 1. (\\<And>z.\n        (z, source \\<Delta>)\n        \\<in> set (cycle_edges (enum_cycle j)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  (z, source \\<Delta>) \\<in> set (cycle_edges (enum_cycle j))\n\ngoal (1 subgoal):\n 1. (source \\<Delta>, y)\n    \\<in> set (cycle_edges (enum_cycle j)) \\<Longrightarrow>\n    False", "with cycle_edges_edges[OF cycle]"], ["proof (chain)\npicking this:\n  set (cycle_edges (enum_cycle j)) \\<subseteq> \\<^bold>E\n  (z, source \\<Delta>) \\<in> set (cycle_edges (enum_cycle j))", "have \"(z, source \\<Delta>) \\<in> \\<^bold>E\""], ["proof (prove)\nusing this:\n  set (cycle_edges (enum_cycle j)) \\<subseteq> \\<^bold>E\n  (z, source \\<Delta>) \\<in> set (cycle_edges (enum_cycle j))\n\ngoal (1 subgoal):\n 1. (z, source \\<Delta>) \\<in> \\<^bold>E", ".."], ["proof (state)\nthis:\n  (z, source \\<Delta>) \\<in> \\<^bold>E\n\ngoal (1 subgoal):\n 1. (source \\<Delta>, y)\n    \\<in> set (cycle_edges (enum_cycle j)) \\<Longrightarrow>\n    False", "thus False"], ["proof (prove)\nusing this:\n  (z, source \\<Delta>) \\<in> \\<^bold>E\n\ngoal (1 subgoal):\n 1. False", "using source_in[of z]"], ["proof (prove)\nusing this:\n  (z, source \\<Delta>) \\<in> \\<^bold>E\n  \\<not> edge \\<Delta> z (source \\<Delta>)\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (source \\<Delta>, y) \\<notin> set (cycle_edges (enum_cycle j))\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       h_minus_aux j (source \\<Delta>, y) = 0 \\<Longrightarrow>\n       h_minus_aux (Suc j) (source \\<Delta>, y) = 0", "then"], ["proof (chain)\npicking this:\n  (source \\<Delta>, y) \\<notin> set (cycle_edges (enum_cycle j))", "show ?case"], ["proof (prove)\nusing this:\n  (source \\<Delta>, y) \\<notin> set (cycle_edges (enum_cycle j))\n\ngoal (1 subgoal):\n 1. h_minus_aux (Suc j) (source \\<Delta>, y) = 0", "using Suc.IH"], ["proof (prove)\nusing this:\n  (source \\<Delta>, y) \\<notin> set (cycle_edges (enum_cycle j))\n  h_minus_aux j (source \\<Delta>, y) = 0\n\ngoal (1 subgoal):\n 1. h_minus_aux (Suc j) (source \\<Delta>, y) = 0", "by simp"], ["proof (state)\nthis:\n  h_minus_aux (Suc j) (source \\<Delta>, y) = 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma h_minus_aux_cycle:\n  fixes j defines \"C \\<equiv> enum_cycle j\"\n  assumes \"cycles \\<Delta> \\<noteq> {}\"\n  shows \"\\<exists>e\\<in>set (cycle_edges C). h_minus_aux (Suc j) e = h' e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>e\\<in>set (cycle_edges C). h_minus_aux (Suc j) e = h' e", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>e\\<in>set (cycle_edges C). h_minus_aux (Suc j) e = h' e", "let ?A = \"{h' e' - h_minus_aux j e'|e'. e' \\<in> set (cycle_edges C)}\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>e\\<in>set (cycle_edges C). h_minus_aux (Suc j) e = h' e", "from assms"], ["proof (chain)\npicking this:\n  C \\<equiv> enum_cycle j\n  cycles \\<Delta> \\<noteq> {}", "have \"cycle \\<Delta> C\""], ["proof (prove)\nusing this:\n  C \\<equiv> enum_cycle j\n  cycles \\<Delta> \\<noteq> {}\n\ngoal (1 subgoal):\n 1. cycle \\<Delta> C", "by auto"], ["proof (state)\nthis:\n  cycle \\<Delta> C\n\ngoal (1 subgoal):\n 1. \\<exists>e\\<in>set (cycle_edges C). h_minus_aux (Suc j) e = h' e", "from cycle_edges_not_Nil[OF this]"], ["proof (chain)\npicking this:\n  cycle_edges C \\<noteq> []", "have \"Min ?A \\<in> ?A\""], ["proof (prove)\nusing this:\n  cycle_edges C \\<noteq> []\n\ngoal (1 subgoal):\n 1. Min {h' e' - h_minus_aux j e' |e'. e' \\<in> set (cycle_edges C)}\n    \\<in> {h' e' - h_minus_aux j e' |e'. e' \\<in> set (cycle_edges C)}", "using [[simproc add: finite_Collect]]"], ["proof (prove)\nusing this:\n  cycle_edges C \\<noteq> []\n\ngoal (1 subgoal):\n 1. Min {h' e' - h_minus_aux j e' |e'. e' \\<in> set (cycle_edges C)}\n    \\<in> {h' e' - h_minus_aux j e' |e'. e' \\<in> set (cycle_edges C)}", "by(intro Min_in)(fastforce simp add: neq_Nil_conv)+"], ["proof (state)\nthis:\n  Min {h' e' - h_minus_aux j e' |e'. e' \\<in> set (cycle_edges C)}\n  \\<in> {h' e' - h_minus_aux j e' |e'. e' \\<in> set (cycle_edges C)}\n\ngoal (1 subgoal):\n 1. \\<exists>e\\<in>set (cycle_edges C). h_minus_aux (Suc j) e = h' e", "then"], ["proof (chain)\npicking this:\n  Min {h' e' - h_minus_aux j e' |e'. e' \\<in> set (cycle_edges C)}\n  \\<in> {h' e' - h_minus_aux j e' |e'. e' \\<in> set (cycle_edges C)}", "obtain e' where e: \"e' \\<in> set (cycle_edges C)\"\n    and \"Min ?A = h' e' - h_minus_aux j e'\""], ["proof (prove)\nusing this:\n  Min {h' e' - h_minus_aux j e' |e'. e' \\<in> set (cycle_edges C)}\n  \\<in> {h' e' - h_minus_aux j e' |e'. e' \\<in> set (cycle_edges C)}\n\ngoal (1 subgoal):\n 1. (\\<And>e'.\n        \\<lbrakk>e' \\<in> set (cycle_edges C);\n         Min {h' e' - h_minus_aux j e' |e'. e' \\<in> set (cycle_edges C)} =\n         h' e' - h_minus_aux j e'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  e' \\<in> set (cycle_edges C)\n  Min {h' e' - h_minus_aux j e' |e'. e' \\<in> set (cycle_edges C)} =\n  h' e' - h_minus_aux j e'\n\ngoal (1 subgoal):\n 1. \\<exists>e\\<in>set (cycle_edges C). h_minus_aux (Suc j) e = h' e", "hence \"h_minus_aux (Suc j) e' = h' e'\""], ["proof (prove)\nusing this:\n  e' \\<in> set (cycle_edges C)\n  Min {h' e' - h_minus_aux j e' |e'. e' \\<in> set (cycle_edges C)} =\n  h' e' - h_minus_aux j e'\n\ngoal (1 subgoal):\n 1. h_minus_aux (Suc j) e' = h' e'", "by(simp add: C_def h_minus_aux_le_h')"], ["proof (state)\nthis:\n  h_minus_aux (Suc j) e' = h' e'\n\ngoal (1 subgoal):\n 1. \\<exists>e\\<in>set (cycle_edges C). h_minus_aux (Suc j) e = h' e", "with e"], ["proof (chain)\npicking this:\n  e' \\<in> set (cycle_edges C)\n  h_minus_aux (Suc j) e' = h' e'", "show ?thesis"], ["proof (prove)\nusing this:\n  e' \\<in> set (cycle_edges C)\n  h_minus_aux (Suc j) e' = h' e'\n\ngoal (1 subgoal):\n 1. \\<exists>e\\<in>set (cycle_edges C). h_minus_aux (Suc j) e = h' e", "by blast"], ["proof (state)\nthis:\n  \\<exists>e\\<in>set (cycle_edges C). h_minus_aux (Suc j) e = h' e\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "fun h_minus :: \"nat \\<Rightarrow> 'v edge \\<Rightarrow> ennreal\"\nwhere\n  \"h_minus 0 e = 0\"\n| \"h_minus (Suc i) e = h_minus i e + (SUP j. h_minus_aux (\\<lambda>e'. h_plus (Suc i) e' - h_minus i e') j e)\""], ["", "lemma h_minus_le_h_plus: \"h_minus i e \\<le> h_plus i e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h_minus i e \\<le> h_plus i e", "proof(induction i e rule: h_minus.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>e. h_minus 0 e \\<le> h_plus 0 e\n 2. \\<And>i e.\n       \\<lbrakk>h_minus i e \\<le> h_plus i e;\n        \\<And>x xa.\n           x \\<in> UNIV \\<Longrightarrow>\n           h_minus i xa \\<le> h_plus i xa\\<rbrakk>\n       \\<Longrightarrow> h_minus (Suc i) e \\<le> h_plus (Suc i) e", "case 0: (1 e)"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>e. h_minus 0 e \\<le> h_plus 0 e\n 2. \\<And>i e.\n       \\<lbrakk>h_minus i e \\<le> h_plus i e;\n        \\<And>x xa.\n           x \\<in> UNIV \\<Longrightarrow>\n           h_minus i xa \\<le> h_plus i xa\\<rbrakk>\n       \\<Longrightarrow> h_minus (Suc i) e \\<le> h_plus (Suc i) e", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. h_minus 0 e \\<le> h_plus 0 e", "by simp"], ["proof (state)\nthis:\n  h_minus 0 e \\<le> h_plus 0 e\n\ngoal (1 subgoal):\n 1. \\<And>i e.\n       \\<lbrakk>h_minus i e \\<le> h_plus i e;\n        \\<And>x xa.\n           x \\<in> UNIV \\<Longrightarrow>\n           h_minus i xa \\<le> h_plus i xa\\<rbrakk>\n       \\<Longrightarrow> h_minus (Suc i) e \\<le> h_plus (Suc i) e", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i e.\n       \\<lbrakk>h_minus i e \\<le> h_plus i e;\n        \\<And>x xa.\n           x \\<in> UNIV \\<Longrightarrow>\n           h_minus i xa \\<le> h_plus i xa\\<rbrakk>\n       \\<Longrightarrow> h_minus (Suc i) e \\<le> h_plus (Suc i) e", "case Suc: (2 i e)"], ["proof (state)\nthis:\n  h_minus i e \\<le> h_plus i e\n  ?x \\<in> UNIV \\<Longrightarrow> h_minus i ?xa \\<le> h_plus i ?xa\n\ngoal (1 subgoal):\n 1. \\<And>i e.\n       \\<lbrakk>h_minus i e \\<le> h_plus i e;\n        \\<And>x xa.\n           x \\<in> UNIV \\<Longrightarrow>\n           h_minus i xa \\<le> h_plus i xa\\<rbrakk>\n       \\<Longrightarrow> h_minus (Suc i) e \\<le> h_plus (Suc i) e", "note IH = Suc.IH(2)[OF UNIV_I]"], ["proof (state)\nthis:\n  h_minus i ?xa \\<le> h_plus i ?xa\n\ngoal (1 subgoal):\n 1. \\<And>i e.\n       \\<lbrakk>h_minus i e \\<le> h_plus i e;\n        \\<And>x xa.\n           x \\<in> UNIV \\<Longrightarrow>\n           h_minus i xa \\<le> h_plus i xa\\<rbrakk>\n       \\<Longrightarrow> h_minus (Suc i) e \\<le> h_plus (Suc i) e", "let ?h' = \"\\<lambda>e'. h_plus (Suc i) e' - h_minus i e'\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i e.\n       \\<lbrakk>h_minus i e \\<le> h_plus i e;\n        \\<And>x xa.\n           x \\<in> UNIV \\<Longrightarrow>\n           h_minus i xa \\<le> h_plus i xa\\<rbrakk>\n       \\<Longrightarrow> h_minus (Suc i) e \\<le> h_plus (Suc i) e", "have h': \"?h' e' \\<noteq> top\" for e'"], ["proof (prove)\ngoal (1 subgoal):\n 1. h_plus (Suc i) e' - h_minus i e' \\<noteq> \\<top>", "using IH(1)[of e']"], ["proof (prove)\nusing this:\n  h_minus i e' \\<le> h_plus i e'\n\ngoal (1 subgoal):\n 1. h_plus (Suc i) e' - h_minus i e' \\<noteq> \\<top>", "by(simp add: )"], ["proof (state)\nthis:\n  h_plus (Suc i) ?e' - h_minus i ?e' \\<noteq> \\<top>\n\ngoal (1 subgoal):\n 1. \\<And>i e.\n       \\<lbrakk>h_minus i e \\<le> h_plus i e;\n        \\<And>x xa.\n           x \\<in> UNIV \\<Longrightarrow>\n           h_minus i xa \\<le> h_plus i xa\\<rbrakk>\n       \\<Longrightarrow> h_minus (Suc i) e \\<le> h_plus (Suc i) e", "have \"(\\<Squnion>j. h_minus_aux ?h' j e) \\<le> ?h' e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Squnion>j.\n        h_minus_aux (\\<lambda>e'. h_plus (Suc i) e' - h_minus i e') j e)\n    \\<le> h_plus (Suc i) e - h_minus i e", "by(rule SUP_least)(rule h_minus_aux_le_h'[OF h'])"], ["proof (state)\nthis:\n  (\\<Squnion>j.\n      h_minus_aux (\\<lambda>e'. h_plus (Suc i) e' - h_minus i e') j e)\n  \\<le> h_plus (Suc i) e - h_minus i e\n\ngoal (1 subgoal):\n 1. \\<And>i e.\n       \\<lbrakk>h_minus i e \\<le> h_plus i e;\n        \\<And>x xa.\n           x \\<in> UNIV \\<Longrightarrow>\n           h_minus i xa \\<le> h_plus i xa\\<rbrakk>\n       \\<Longrightarrow> h_minus (Suc i) e \\<le> h_plus (Suc i) e", "hence \"h_minus (Suc i) e \\<le> h_minus i e + \\<dots>\""], ["proof (prove)\nusing this:\n  (\\<Squnion>j.\n      h_minus_aux (\\<lambda>e'. h_plus (Suc i) e' - h_minus i e') j e)\n  \\<le> h_plus (Suc i) e - h_minus i e\n\ngoal (1 subgoal):\n 1. h_minus (Suc i) e \\<le> h_minus i e + (h_plus (Suc i) e - h_minus i e)", "by(simp add: add_mono)"], ["proof (state)\nthis:\n  h_minus (Suc i) e \\<le> h_minus i e + (h_plus (Suc i) e - h_minus i e)\n\ngoal (1 subgoal):\n 1. \\<And>i e.\n       \\<lbrakk>h_minus i e \\<le> h_plus i e;\n        \\<And>x xa.\n           x \\<in> UNIV \\<Longrightarrow>\n           h_minus i xa \\<le> h_plus i xa\\<rbrakk>\n       \\<Longrightarrow> h_minus (Suc i) e \\<le> h_plus (Suc i) e", "also"], ["proof (state)\nthis:\n  h_minus (Suc i) e \\<le> h_minus i e + (h_plus (Suc i) e - h_minus i e)\n\ngoal (1 subgoal):\n 1. \\<And>i e.\n       \\<lbrakk>h_minus i e \\<le> h_plus i e;\n        \\<And>x xa.\n           x \\<in> UNIV \\<Longrightarrow>\n           h_minus i xa \\<le> h_plus i xa\\<rbrakk>\n       \\<Longrightarrow> h_minus (Suc i) e \\<le> h_plus (Suc i) e", "have \"\\<dots> = h_plus (Suc i) e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h_minus i e + (h_plus (Suc i) e - h_minus i e) = h_plus (Suc i) e", "using IH[of e] h_plus_mono[of i e]"], ["proof (prove)\nusing this:\n  h_minus i e \\<le> h_plus i e\n  h_plus i e \\<le> h_plus (Suc i) e\n\ngoal (1 subgoal):\n 1. h_minus i e + (h_plus (Suc i) e - h_minus i e) = h_plus (Suc i) e", "by auto"], ["proof (state)\nthis:\n  h_minus i e + (h_plus (Suc i) e - h_minus i e) = h_plus (Suc i) e\n\ngoal (1 subgoal):\n 1. \\<And>i e.\n       \\<lbrakk>h_minus i e \\<le> h_plus i e;\n        \\<And>x xa.\n           x \\<in> UNIV \\<Longrightarrow>\n           h_minus i xa \\<le> h_plus i xa\\<rbrakk>\n       \\<Longrightarrow> h_minus (Suc i) e \\<le> h_plus (Suc i) e", "finally"], ["proof (chain)\npicking this:\n  h_minus (Suc i) e \\<le> h_plus (Suc i) e", "show ?case"], ["proof (prove)\nusing this:\n  h_minus (Suc i) e \\<le> h_plus (Suc i) e\n\ngoal (1 subgoal):\n 1. h_minus (Suc i) e \\<le> h_plus (Suc i) e", "."], ["proof (state)\nthis:\n  h_minus (Suc i) e \\<le> h_plus (Suc i) e\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma finite_h': \"h_plus (Suc i) e - h_minus i e \\<noteq> top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h_plus (Suc i) e - h_minus i e \\<noteq> \\<top>", "by simp"], ["", "lemma h_minus_mono: \"h_minus i e \\<le> h_minus (Suc i) e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h_minus i e \\<le> h_minus (Suc i) e", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. h_minus i e \\<le> h_minus (Suc i) e", "have \"h_minus i e + 0 \\<le> h_minus (Suc i) e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h_minus i e + 0 \\<le> h_minus (Suc i) e", "unfolding h_minus.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. h_minus i e + 0\n    \\<le> h_minus i e +\n          (\\<Squnion>j.\n              h_minus_aux (\\<lambda>e'. h_plus (Suc i) e' - h_minus i e') j\n               e)", "by(rule add_mono; simp add: SUP_upper2)"], ["proof (state)\nthis:\n  h_minus i e + 0 \\<le> h_minus (Suc i) e\n\ngoal (1 subgoal):\n 1. h_minus i e \\<le> h_minus (Suc i) e", "thus ?thesis"], ["proof (prove)\nusing this:\n  h_minus i e + 0 \\<le> h_minus (Suc i) e\n\ngoal (1 subgoal):\n 1. h_minus i e \\<le> h_minus (Suc i) e", "by simp"], ["proof (state)\nthis:\n  h_minus i e \\<le> h_minus (Suc i) e\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma h_minus_finite [simp]: \"h_minus i e \\<noteq> \\<top>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h_minus i e \\<noteq> \\<top>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. h_minus i e \\<noteq> \\<top>", "have \"h_minus i e \\<le> h_plus i e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h_minus i e \\<le> h_plus i e", "by(rule h_minus_le_h_plus)"], ["proof (state)\nthis:\n  h_minus i e \\<le> h_plus i e\n\ngoal (1 subgoal):\n 1. h_minus i e \\<noteq> \\<top>", "also"], ["proof (state)\nthis:\n  h_minus i e \\<le> h_plus i e\n\ngoal (1 subgoal):\n 1. h_minus i e \\<noteq> \\<top>", "have \"\\<dots> < \\<top>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h_plus i e < \\<top>", "by (simp add: less_top[symmetric])"], ["proof (state)\nthis:\n  h_plus i e < \\<top>\n\ngoal (1 subgoal):\n 1. h_minus i e \\<noteq> \\<top>", "finally"], ["proof (chain)\npicking this:\n  h_minus i e < \\<top>", "show ?thesis"], ["proof (prove)\nusing this:\n  h_minus i e < \\<top>\n\ngoal (1 subgoal):\n 1. h_minus i e \\<noteq> \\<top>", "by simp"], ["proof (state)\nthis:\n  h_minus i e \\<noteq> \\<top>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma d_OUT_h_minus:\n  assumes cycles: \"cycles \\<Delta> \\<noteq> {}\"\n  shows \"d_OUT (h_minus i) x = d_IN (h_minus i) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. KIR (h_minus i) x", "proof(induction i)"], ["proof (state)\ngoal (2 subgoals):\n 1. KIR (h_minus 0) x\n 2. \\<And>i. KIR (h_minus i) x \\<Longrightarrow> KIR (h_minus (Suc i)) x", "case (Suc i)"], ["proof (state)\nthis:\n  KIR (h_minus i) x\n\ngoal (2 subgoals):\n 1. KIR (h_minus 0) x\n 2. \\<And>i. KIR (h_minus i) x \\<Longrightarrow> KIR (h_minus (Suc i)) x", "let ?h' = \"\\<lambda>e. h_plus (Suc i) e - h_minus i e\""], ["proof (state)\ngoal (2 subgoals):\n 1. KIR (h_minus 0) x\n 2. \\<And>i. KIR (h_minus i) x \\<Longrightarrow> KIR (h_minus (Suc i)) x", "have \"d_OUT (\\<lambda>e. h_minus (Suc i) e) x = d_OUT (h_minus i) x + d_OUT (\\<lambda>e. SUP j. h_minus_aux ?h' j e) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT (h_minus (Suc i)) x =\n    d_OUT (h_minus i) x +\n    d_OUT\n     (\\<lambda>e.\n         \\<Squnion>j.\n            h_minus_aux (\\<lambda>e. h_plus (Suc i) e - h_minus i e) j e)\n     x", "by(simp add: d_OUT_add SUP_upper2)"], ["proof (state)\nthis:\n  d_OUT (h_minus (Suc i)) x =\n  d_OUT (h_minus i) x +\n  d_OUT\n   (\\<lambda>e.\n       \\<Squnion>j.\n          h_minus_aux (\\<lambda>e. h_plus (Suc i) e - h_minus i e) j e)\n   x\n\ngoal (2 subgoals):\n 1. KIR (h_minus 0) x\n 2. \\<And>i. KIR (h_minus i) x \\<Longrightarrow> KIR (h_minus (Suc i)) x", "also"], ["proof (state)\nthis:\n  d_OUT (h_minus (Suc i)) x =\n  d_OUT (h_minus i) x +\n  d_OUT\n   (\\<lambda>e.\n       \\<Squnion>j.\n          h_minus_aux (\\<lambda>e. h_plus (Suc i) e - h_minus i e) j e)\n   x\n\ngoal (2 subgoals):\n 1. KIR (h_minus 0) x\n 2. \\<And>i. KIR (h_minus i) x \\<Longrightarrow> KIR (h_minus (Suc i)) x", "have \"d_OUT (\\<lambda>e. SUP j. h_minus_aux ?h' j e) x = (SUP j. d_OUT (h_minus_aux ?h' j) x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT\n     (\\<lambda>e.\n         \\<Squnion>j.\n            h_minus_aux (\\<lambda>e. h_plus (Suc i) e - h_minus i e) j e)\n     x =\n    (\\<Squnion>j.\n        d_OUT (h_minus_aux (\\<lambda>e. h_plus (Suc i) e - h_minus i e) j)\n         x)", "by(rule d_OUT_monotone_convergence_SUP incseq_SucI le_funI h_minus_aux_mono finite_h')+"], ["proof (state)\nthis:\n  d_OUT\n   (\\<lambda>e.\n       \\<Squnion>j.\n          h_minus_aux (\\<lambda>e. h_plus (Suc i) e - h_minus i e) j e)\n   x =\n  (\\<Squnion>j.\n      d_OUT (h_minus_aux (\\<lambda>e. h_plus (Suc i) e - h_minus i e) j) x)\n\ngoal (2 subgoals):\n 1. KIR (h_minus 0) x\n 2. \\<And>i. KIR (h_minus i) x \\<Longrightarrow> KIR (h_minus (Suc i)) x", "also"], ["proof (state)\nthis:\n  d_OUT\n   (\\<lambda>e.\n       \\<Squnion>j.\n          h_minus_aux (\\<lambda>e. h_plus (Suc i) e - h_minus i e) j e)\n   x =\n  (\\<Squnion>j.\n      d_OUT (h_minus_aux (\\<lambda>e. h_plus (Suc i) e - h_minus i e) j) x)\n\ngoal (2 subgoals):\n 1. KIR (h_minus 0) x\n 2. \\<And>i. KIR (h_minus i) x \\<Longrightarrow> KIR (h_minus (Suc i)) x", "have \"\\<dots> = (SUP j. d_IN (h_minus_aux ?h' j) x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Squnion>j.\n        d_OUT (h_minus_aux (\\<lambda>e. h_plus (Suc i) e - h_minus i e) j)\n         x) =\n    (\\<Squnion>j.\n        d_IN (h_minus_aux (\\<lambda>e. h_plus (Suc i) e - h_minus i e) j) x)", "by(rule SUP_cong[OF refl])(rule d_OUT_h_minus_aux[OF finite_h' cycles])"], ["proof (state)\nthis:\n  (\\<Squnion>j.\n      d_OUT (h_minus_aux (\\<lambda>e. h_plus (Suc i) e - h_minus i e) j)\n       x) =\n  (\\<Squnion>j.\n      d_IN (h_minus_aux (\\<lambda>e. h_plus (Suc i) e - h_minus i e) j) x)\n\ngoal (2 subgoals):\n 1. KIR (h_minus 0) x\n 2. \\<And>i. KIR (h_minus i) x \\<Longrightarrow> KIR (h_minus (Suc i)) x", "also"], ["proof (state)\nthis:\n  (\\<Squnion>j.\n      d_OUT (h_minus_aux (\\<lambda>e. h_plus (Suc i) e - h_minus i e) j)\n       x) =\n  (\\<Squnion>j.\n      d_IN (h_minus_aux (\\<lambda>e. h_plus (Suc i) e - h_minus i e) j) x)\n\ngoal (2 subgoals):\n 1. KIR (h_minus 0) x\n 2. \\<And>i. KIR (h_minus i) x \\<Longrightarrow> KIR (h_minus (Suc i)) x", "have \"\\<dots> = d_IN (\\<lambda>e. SUP j. h_minus_aux ?h' j e) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Squnion>j.\n        d_IN (h_minus_aux (\\<lambda>e. h_plus (Suc i) e - h_minus i e) j)\n         x) =\n    d_IN\n     (\\<lambda>e.\n         \\<Squnion>j.\n            h_minus_aux (\\<lambda>e. h_plus (Suc i) e - h_minus i e) j e)\n     x", "by(rule d_IN_monotone_convergence_SUP[symmetric] incseq_SucI le_funI h_minus_aux_mono finite_h')+"], ["proof (state)\nthis:\n  (\\<Squnion>j.\n      d_IN (h_minus_aux (\\<lambda>e. h_plus (Suc i) e - h_minus i e) j) x) =\n  d_IN\n   (\\<lambda>e.\n       \\<Squnion>j.\n          h_minus_aux (\\<lambda>e. h_plus (Suc i) e - h_minus i e) j e)\n   x\n\ngoal (2 subgoals):\n 1. KIR (h_minus 0) x\n 2. \\<And>i. KIR (h_minus i) x \\<Longrightarrow> KIR (h_minus (Suc i)) x", "also"], ["proof (state)\nthis:\n  (\\<Squnion>j.\n      d_IN (h_minus_aux (\\<lambda>e. h_plus (Suc i) e - h_minus i e) j) x) =\n  d_IN\n   (\\<lambda>e.\n       \\<Squnion>j.\n          h_minus_aux (\\<lambda>e. h_plus (Suc i) e - h_minus i e) j e)\n   x\n\ngoal (2 subgoals):\n 1. KIR (h_minus 0) x\n 2. \\<And>i. KIR (h_minus i) x \\<Longrightarrow> KIR (h_minus (Suc i)) x", "have \"d_OUT (h_minus i) x + \\<dots> = d_IN (\\<lambda>e. h_minus (Suc i) e) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT (h_minus i) x +\n    d_IN\n     (\\<lambda>e.\n         \\<Squnion>j.\n            h_minus_aux (\\<lambda>e. h_plus (Suc i) e - h_minus i e) j e)\n     x =\n    d_IN (h_minus (Suc i)) x", "using Suc.IH"], ["proof (prove)\nusing this:\n  KIR (h_minus i) x\n\ngoal (1 subgoal):\n 1. d_OUT (h_minus i) x +\n    d_IN\n     (\\<lambda>e.\n         \\<Squnion>j.\n            h_minus_aux (\\<lambda>e. h_plus (Suc i) e - h_minus i e) j e)\n     x =\n    d_IN (h_minus (Suc i)) x", "by(simp add: d_IN_add SUP_upper2)"], ["proof (state)\nthis:\n  d_OUT (h_minus i) x +\n  d_IN\n   (\\<lambda>e.\n       \\<Squnion>j.\n          h_minus_aux (\\<lambda>e. h_plus (Suc i) e - h_minus i e) j e)\n   x =\n  d_IN (h_minus (Suc i)) x\n\ngoal (2 subgoals):\n 1. KIR (h_minus 0) x\n 2. \\<And>i. KIR (h_minus i) x \\<Longrightarrow> KIR (h_minus (Suc i)) x", "finally"], ["proof (chain)\npicking this:\n  KIR (h_minus (Suc i)) x", "show ?case"], ["proof (prove)\nusing this:\n  KIR (h_minus (Suc i)) x\n\ngoal (1 subgoal):\n 1. KIR (h_minus (Suc i)) x", "."], ["proof (state)\nthis:\n  KIR (h_minus (Suc i)) x\n\ngoal (1 subgoal):\n 1. KIR (h_minus 0) x", "qed simp"], ["", "lemma h_minus_source:\n  assumes \"cycles \\<Delta> \\<noteq> {}\"\n  shows \"h_minus n (source \\<Delta>, y) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h_minus n (source \\<Delta>, y) = 0", "by(induction n)(simp_all add: h_minus_aux_source[OF finite_h' assms])"], ["", "lemma h_minus_source_in [simp]: \"h_minus i (x, source \\<Delta>) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h_minus i (x, source \\<Delta>) = 0", "using h_minus_le_h_plus[of i \"(x, source \\<Delta>)\"]"], ["proof (prove)\nusing this:\n  h_minus i (x, source \\<Delta>) \\<le> h_plus i (x, source \\<Delta>)\n\ngoal (1 subgoal):\n 1. h_minus i (x, source \\<Delta>) = 0", "by simp"], ["", "lemma h_minus_OUT_finite [simp]: \"d_OUT (h_minus i) x \\<noteq> top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT (h_minus i) x \\<noteq> \\<top>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. d_OUT (h_minus i) x \\<noteq> \\<top>", "have \"d_OUT (h_minus i) x \\<le> d_OUT (h_plus i) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT (h_minus i) x \\<le> d_OUT (h_plus i) x", "by(rule d_OUT_mono)(rule h_minus_le_h_plus)"], ["proof (state)\nthis:\n  d_OUT (h_minus i) x \\<le> d_OUT (h_plus i) x\n\ngoal (1 subgoal):\n 1. d_OUT (h_minus i) x \\<noteq> \\<top>", "also"], ["proof (state)\nthis:\n  d_OUT (h_minus i) x \\<le> d_OUT (h_plus i) x\n\ngoal (1 subgoal):\n 1. d_OUT (h_minus i) x \\<noteq> \\<top>", "have \"\\<dots> < \\<top>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT (h_plus i) x < \\<top>", "by (simp add: less_top[symmetric])"], ["proof (state)\nthis:\n  d_OUT (h_plus i) x < \\<top>\n\ngoal (1 subgoal):\n 1. d_OUT (h_minus i) x \\<noteq> \\<top>", "finally"], ["proof (chain)\npicking this:\n  d_OUT (h_minus i) x < \\<top>", "show ?thesis"], ["proof (prove)\nusing this:\n  d_OUT (h_minus i) x < \\<top>\n\ngoal (1 subgoal):\n 1. d_OUT (h_minus i) x \\<noteq> \\<top>", "by simp"], ["proof (state)\nthis:\n  d_OUT (h_minus i) x \\<noteq> \\<top>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma h_minus_cycle:\n  assumes \"cycle \\<Delta> C\"\n  shows \"\\<exists>e\\<in>set (cycle_edges C). h_minus i e = h_plus i e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>e\\<in>set (cycle_edges C). h_minus i e = h_plus i e", "proof(cases i)"], ["proof (state)\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow>\n    \\<exists>e\\<in>set (cycle_edges C). h_minus i e = h_plus i e\n 2. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       \\<exists>e\\<in>set (cycle_edges C). h_minus i e = h_plus i e", "case (Suc i)"], ["proof (state)\nthis:\n  i = Suc i\n\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow>\n    \\<exists>e\\<in>set (cycle_edges C). h_minus i e = h_plus i e\n 2. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       \\<exists>e\\<in>set (cycle_edges C). h_minus i e = h_plus i e", "let ?h' = \"\\<lambda>e. h_plus (Suc i) e - h_minus i e\""], ["proof (state)\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow>\n    \\<exists>e\\<in>set (cycle_edges C). h_minus i e = h_plus i e\n 2. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       \\<exists>e\\<in>set (cycle_edges C). h_minus i e = h_plus i e", "from assms"], ["proof (chain)\npicking this:\n  cycle \\<Delta> C", "have cycles: \"cycles \\<Delta> \\<noteq> {}\""], ["proof (prove)\nusing this:\n  cycle \\<Delta> C\n\ngoal (1 subgoal):\n 1. cycles \\<Delta> \\<noteq> {}", "by auto"], ["proof (state)\nthis:\n  cycles \\<Delta> \\<noteq> {}\n\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow>\n    \\<exists>e\\<in>set (cycle_edges C). h_minus i e = h_plus i e\n 2. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       \\<exists>e\\<in>set (cycle_edges C). h_minus i e = h_plus i e", "with assms from_nat_into_surj[of \"cycles \\<Delta>\" C]"], ["proof (chain)\npicking this:\n  cycle \\<Delta> C\n  \\<lbrakk>countable (cycles \\<Delta>); C \\<in> cycles \\<Delta>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>n. from_nat_into (cycles \\<Delta>) n = C\n  cycles \\<Delta> \\<noteq> {}", "obtain j where j: \"C = enum_cycle j\""], ["proof (prove)\nusing this:\n  cycle \\<Delta> C\n  \\<lbrakk>countable (cycles \\<Delta>); C \\<in> cycles \\<Delta>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>n. from_nat_into (cycles \\<Delta>) n = C\n  cycles \\<Delta> \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>j. C = enum_cycle j \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto simp add: enum_cycle_def)"], ["proof (state)\nthis:\n  C = enum_cycle j\n\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow>\n    \\<exists>e\\<in>set (cycle_edges C). h_minus i e = h_plus i e\n 2. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       \\<exists>e\\<in>set (cycle_edges C). h_minus i e = h_plus i e", "from h_minus_aux_cycle[of \"?h'\" j, OF finite_h' cycles] j"], ["proof (chain)\npicking this:\n  \\<exists>e\\<in>set (cycle_edges (enum_cycle j)).\n     h_minus_aux (\\<lambda>e. h_plus (Suc i) e - h_minus i e) (Suc j) e =\n     h_plus (Suc i) e - h_minus i e\n  C = enum_cycle j", "obtain e where e: \"e \\<in> set (cycle_edges C)\" and \"h_minus_aux ?h' (Suc j) e = ?h' e\""], ["proof (prove)\nusing this:\n  \\<exists>e\\<in>set (cycle_edges (enum_cycle j)).\n     h_minus_aux (\\<lambda>e. h_plus (Suc i) e - h_minus i e) (Suc j) e =\n     h_plus (Suc i) e - h_minus i e\n  C = enum_cycle j\n\ngoal (1 subgoal):\n 1. (\\<And>e.\n        \\<lbrakk>e \\<in> set (cycle_edges C);\n         h_minus_aux (\\<lambda>e. h_plus (Suc i) e - h_minus i e) (Suc j)\n          e =\n         h_plus (Suc i) e - h_minus i e\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto)"], ["proof (state)\nthis:\n  e \\<in> set (cycle_edges C)\n  h_minus_aux (\\<lambda>e. h_plus (Suc i) e - h_minus i e) (Suc j) e =\n  h_plus (Suc i) e - h_minus i e\n\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow>\n    \\<exists>e\\<in>set (cycle_edges C). h_minus i e = h_plus i e\n 2. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       \\<exists>e\\<in>set (cycle_edges C). h_minus i e = h_plus i e", "then"], ["proof (chain)\npicking this:\n  e \\<in> set (cycle_edges C)\n  h_minus_aux (\\<lambda>e. h_plus (Suc i) e - h_minus i e) (Suc j) e =\n  h_plus (Suc i) e - h_minus i e", "have \"h_plus (Suc i) e = h_minus i e + h_minus_aux ?h' (Suc j) e\""], ["proof (prove)\nusing this:\n  e \\<in> set (cycle_edges C)\n  h_minus_aux (\\<lambda>e. h_plus (Suc i) e - h_minus i e) (Suc j) e =\n  h_plus (Suc i) e - h_minus i e\n\ngoal (1 subgoal):\n 1. h_plus (Suc i) e =\n    h_minus i e +\n    h_minus_aux (\\<lambda>e. h_plus (Suc i) e - h_minus i e) (Suc j) e", "using order_trans[OF h_minus_le_h_plus h_plus_mono]"], ["proof (prove)\nusing this:\n  e \\<in> set (cycle_edges C)\n  h_minus_aux (\\<lambda>e. h_plus (Suc i) e - h_minus i e) (Suc j) e =\n  h_plus (Suc i) e - h_minus i e\n  h_minus ?i1 ?e1 \\<le> h_plus (Suc ?i1) ?e1\n\ngoal (1 subgoal):\n 1. h_plus (Suc i) e =\n    h_minus i e +\n    h_minus_aux (\\<lambda>e. h_plus (Suc i) e - h_minus i e) (Suc j) e", "by (subst eq_commute) simp"], ["proof (state)\nthis:\n  h_plus (Suc i) e =\n  h_minus i e +\n  h_minus_aux (\\<lambda>e. h_plus (Suc i) e - h_minus i e) (Suc j) e\n\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow>\n    \\<exists>e\\<in>set (cycle_edges C). h_minus i e = h_plus i e\n 2. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       \\<exists>e\\<in>set (cycle_edges C). h_minus i e = h_plus i e", "also"], ["proof (state)\nthis:\n  h_plus (Suc i) e =\n  h_minus i e +\n  h_minus_aux (\\<lambda>e. h_plus (Suc i) e - h_minus i e) (Suc j) e\n\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow>\n    \\<exists>e\\<in>set (cycle_edges C). h_minus i e = h_plus i e\n 2. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       \\<exists>e\\<in>set (cycle_edges C). h_minus i e = h_plus i e", "have \"\\<dots> \\<le> h_minus (Suc i) e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h_minus i e +\n    h_minus_aux (\\<lambda>e. h_plus (Suc i) e - h_minus i e) (Suc j) e\n    \\<le> h_minus (Suc i) e", "unfolding h_minus.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. h_minus i e +\n    h_minus_aux (\\<lambda>e. h_plus (Suc i) e - h_minus i e) (Suc j) e\n    \\<le> h_minus i e +\n          (\\<Squnion>j.\n              h_minus_aux (\\<lambda>e'. h_plus (Suc i) e' - h_minus i e') j\n               e)", "by(intro add_mono SUP_upper; simp)"], ["proof (state)\nthis:\n  h_minus i e +\n  h_minus_aux (\\<lambda>e. h_plus (Suc i) e - h_minus i e) (Suc j) e\n  \\<le> h_minus (Suc i) e\n\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow>\n    \\<exists>e\\<in>set (cycle_edges C). h_minus i e = h_plus i e\n 2. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       \\<exists>e\\<in>set (cycle_edges C). h_minus i e = h_plus i e", "finally"], ["proof (chain)\npicking this:\n  h_plus (Suc i) e \\<le> h_minus (Suc i) e", "show ?thesis"], ["proof (prove)\nusing this:\n  h_plus (Suc i) e \\<le> h_minus (Suc i) e\n\ngoal (1 subgoal):\n 1. \\<exists>e\\<in>set (cycle_edges C). h_minus i e = h_plus i e", "using e h_minus_le_h_plus[of \"Suc i\" e] Suc"], ["proof (prove)\nusing this:\n  h_plus (Suc i) e \\<le> h_minus (Suc i) e\n  e \\<in> set (cycle_edges C)\n  h_minus (Suc i) e \\<le> h_plus (Suc i) e\n  i = Suc i\n\ngoal (1 subgoal):\n 1. \\<exists>e\\<in>set (cycle_edges C). h_minus i e = h_plus i e", "by auto"], ["proof (state)\nthis:\n  \\<exists>e\\<in>set (cycle_edges C). h_minus i e = h_plus i e\n\ngoal (1 subgoal):\n 1. i = 0 \\<Longrightarrow>\n    \\<exists>e\\<in>set (cycle_edges C). h_minus i e = h_plus i e", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. i = 0 \\<Longrightarrow>\n    \\<exists>e\\<in>set (cycle_edges C). h_minus i e = h_plus i e", "case 0"], ["proof (state)\nthis:\n  i = 0\n\ngoal (1 subgoal):\n 1. i = 0 \\<Longrightarrow>\n    \\<exists>e\\<in>set (cycle_edges C). h_minus i e = h_plus i e", "from cycle_edges_not_Nil[OF assms]"], ["proof (chain)\npicking this:\n  cycle_edges C \\<noteq> []", "obtain x y where e: \"(x, y) \\<in> set (cycle_edges C)\""], ["proof (prove)\nusing this:\n  cycle_edges C \\<noteq> []\n\ngoal (1 subgoal):\n 1. (\\<And>x y.\n        (x, y) \\<in> set (cycle_edges C) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(fastforce simp add: neq_Nil_conv)"], ["proof (state)\nthis:\n  (x, y) \\<in> set (cycle_edges C)\n\ngoal (1 subgoal):\n 1. i = 0 \\<Longrightarrow>\n    \\<exists>e\\<in>set (cycle_edges C). h_minus i e = h_plus i e", "then"], ["proof (chain)\npicking this:\n  (x, y) \\<in> set (cycle_edges C)", "have \"x \\<noteq> source \\<Delta>\""], ["proof (prove)\nusing this:\n  (x, y) \\<in> set (cycle_edges C)\n\ngoal (1 subgoal):\n 1. x \\<noteq> source \\<Delta>", "using assms"], ["proof (prove)\nusing this:\n  (x, y) \\<in> set (cycle_edges C)\n  cycle \\<Delta> C\n\ngoal (1 subgoal):\n 1. x \\<noteq> source \\<Delta>", "by(auto dest: source_out_not_cycle)"], ["proof (state)\nthis:\n  x \\<noteq> source \\<Delta>\n\ngoal (1 subgoal):\n 1. i = 0 \\<Longrightarrow>\n    \\<exists>e\\<in>set (cycle_edges C). h_minus i e = h_plus i e", "hence \"h_plus 0 (x, y) = 0\""], ["proof (prove)\nusing this:\n  x \\<noteq> source \\<Delta>\n\ngoal (1 subgoal):\n 1. h_plus 0 (x, y) = 0", "by simp"], ["proof (state)\nthis:\n  h_plus 0 (x, y) = 0\n\ngoal (1 subgoal):\n 1. i = 0 \\<Longrightarrow>\n    \\<exists>e\\<in>set (cycle_edges C). h_minus i e = h_plus i e", "with e 0"], ["proof (chain)\npicking this:\n  (x, y) \\<in> set (cycle_edges C)\n  i = 0\n  h_plus 0 (x, y) = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  (x, y) \\<in> set (cycle_edges C)\n  i = 0\n  h_plus 0 (x, y) = 0\n\ngoal (1 subgoal):\n 1. \\<exists>e\\<in>set (cycle_edges C). h_minus i e = h_plus i e", "by(auto simp del: h_plus.simps)"], ["proof (state)\nthis:\n  \\<exists>e\\<in>set (cycle_edges C). h_minus i e = h_plus i e\n\ngoal:\nNo subgoals!", "qed"], ["", "abbreviation lim_h_plus :: \"'v edge \\<Rightarrow> ennreal\"\nwhere \"lim_h_plus e \\<equiv> SUP n. h_plus n e\""], ["", "abbreviation lim_h_minus :: \"'v edge \\<Rightarrow> ennreal\"\nwhere \"lim_h_minus e \\<equiv> SUP n. h_minus n e\""], ["", "lemma lim_h_plus_le_g: \"lim_h_plus e \\<le> g e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Squnion>n. h_plus n e) \\<le> g e", "by(rule SUP_least)(rule h_plus_le_g)"], ["", "lemma lim_h_plus_finite [simp]: \"lim_h_plus e \\<noteq> top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Squnion>n. h_plus n e) \\<noteq> \\<top>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Squnion>n. h_plus n e) \\<noteq> \\<top>", "have \"lim_h_plus e \\<le> g e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Squnion>n. h_plus n e) \\<le> g e", "by(rule lim_h_plus_le_g)"], ["proof (state)\nthis:\n  (\\<Squnion>n. h_plus n e) \\<le> g e\n\ngoal (1 subgoal):\n 1. (\\<Squnion>n. h_plus n e) \\<noteq> \\<top>", "also"], ["proof (state)\nthis:\n  (\\<Squnion>n. h_plus n e) \\<le> g e\n\ngoal (1 subgoal):\n 1. (\\<Squnion>n. h_plus n e) \\<noteq> \\<top>", "have \"\\<dots> < top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g e < \\<top>", "by (simp add: less_top[symmetric])"], ["proof (state)\nthis:\n  g e < \\<top>\n\ngoal (1 subgoal):\n 1. (\\<Squnion>n. h_plus n e) \\<noteq> \\<top>", "finally"], ["proof (chain)\npicking this:\n  (\\<Squnion>n. h_plus n e) < \\<top>", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<Squnion>n. h_plus n e) < \\<top>\n\ngoal (1 subgoal):\n 1. (\\<Squnion>n. h_plus n e) \\<noteq> \\<top>", "unfolding less_top"], ["proof (prove)\nusing this:\n  (\\<Squnion>n. h_plus n e) < \\<top>\n\ngoal (1 subgoal):\n 1. (\\<Squnion>n. h_plus n e) < \\<top>", "."], ["proof (state)\nthis:\n  (\\<Squnion>n. h_plus n e) \\<noteq> \\<top>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lim_h_minus_le_lim_h_plus: \"lim_h_minus e \\<le> lim_h_plus e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Squnion>n. h_minus n e) \\<le> (\\<Squnion>n. h_plus n e)", "by(rule SUP_mono)(blast intro: h_minus_le_h_plus)"], ["", "lemma lim_h_minus_finite [simp]: \"lim_h_minus e \\<noteq> top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Squnion>n. h_minus n e) \\<noteq> \\<top>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Squnion>n. h_minus n e) \\<noteq> \\<top>", "have \"lim_h_minus e \\<le> lim_h_plus e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Squnion>n. h_minus n e) \\<le> (\\<Squnion>n. h_plus n e)", "by(rule lim_h_minus_le_lim_h_plus)"], ["proof (state)\nthis:\n  (\\<Squnion>n. h_minus n e) \\<le> (\\<Squnion>n. h_plus n e)\n\ngoal (1 subgoal):\n 1. (\\<Squnion>n. h_minus n e) \\<noteq> \\<top>", "also"], ["proof (state)\nthis:\n  (\\<Squnion>n. h_minus n e) \\<le> (\\<Squnion>n. h_plus n e)\n\ngoal (1 subgoal):\n 1. (\\<Squnion>n. h_minus n e) \\<noteq> \\<top>", "have \"\\<dots> < top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Squnion>n. h_plus n e) < \\<top>", "unfolding less_top[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Squnion>n. h_plus n e) \\<noteq> \\<top>", "by (rule lim_h_plus_finite)"], ["proof (state)\nthis:\n  (\\<Squnion>n. h_plus n e) < \\<top>\n\ngoal (1 subgoal):\n 1. (\\<Squnion>n. h_minus n e) \\<noteq> \\<top>", "finally"], ["proof (chain)\npicking this:\n  (\\<Squnion>n. h_minus n e) < \\<top>", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<Squnion>n. h_minus n e) < \\<top>\n\ngoal (1 subgoal):\n 1. (\\<Squnion>n. h_minus n e) \\<noteq> \\<top>", "unfolding less_top[symmetric]"], ["proof (prove)\nusing this:\n  (\\<Squnion>n. h_minus n e) \\<noteq> \\<top>\n\ngoal (1 subgoal):\n 1. (\\<Squnion>n. h_minus n e) \\<noteq> \\<top>", "by simp"], ["proof (state)\nthis:\n  (\\<Squnion>n. h_minus n e) \\<noteq> \\<top>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lim_h_minus_IN_finite [simp]:\n  assumes \"x \\<noteq> sink \\<Delta>\"\n  shows \"d_IN lim_h_minus x \\<noteq> top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN (\\<lambda>e. \\<Squnion>n. h_minus n e) x \\<noteq> \\<top>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. d_IN (\\<lambda>e. \\<Squnion>n. h_minus n e) x \\<noteq> \\<top>", "have \"d_IN lim_h_minus x \\<le> d_IN lim_h_plus x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN (\\<lambda>e. \\<Squnion>n. h_minus n e) x\n    \\<le> d_IN (\\<lambda>e. \\<Squnion>n. h_plus n e) x", "by(intro d_IN_mono le_funI lim_h_minus_le_lim_h_plus)"], ["proof (state)\nthis:\n  d_IN (\\<lambda>e. \\<Squnion>n. h_minus n e) x\n  \\<le> d_IN (\\<lambda>e. \\<Squnion>n. h_plus n e) x\n\ngoal (1 subgoal):\n 1. d_IN (\\<lambda>e. \\<Squnion>n. h_minus n e) x \\<noteq> \\<top>", "also"], ["proof (state)\nthis:\n  d_IN (\\<lambda>e. \\<Squnion>n. h_minus n e) x\n  \\<le> d_IN (\\<lambda>e. \\<Squnion>n. h_plus n e) x\n\ngoal (1 subgoal):\n 1. d_IN (\\<lambda>e. \\<Squnion>n. h_minus n e) x \\<noteq> \\<top>", "have \"\\<dots> \\<le> d_IN g x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN (\\<lambda>e. \\<Squnion>n. h_plus n e) x \\<le> d_IN g x", "by(intro d_IN_mono le_funI lim_h_plus_le_g)"], ["proof (state)\nthis:\n  d_IN (\\<lambda>e. \\<Squnion>n. h_plus n e) x \\<le> d_IN g x\n\ngoal (1 subgoal):\n 1. d_IN (\\<lambda>e. \\<Squnion>n. h_minus n e) x \\<noteq> \\<top>", "also"], ["proof (state)\nthis:\n  d_IN (\\<lambda>e. \\<Squnion>n. h_plus n e) x \\<le> d_IN g x\n\ngoal (1 subgoal):\n 1. d_IN (\\<lambda>e. \\<Squnion>n. h_minus n e) x \\<noteq> \\<top>", "have \"\\<dots> < \\<top>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN g x < \\<top>", "using assms"], ["proof (prove)\nusing this:\n  x \\<noteq> sink \\<Delta>\n\ngoal (1 subgoal):\n 1. d_IN g x < \\<top>", "by(simp add: finite_IN_g less_top[symmetric])"], ["proof (state)\nthis:\n  d_IN g x < \\<top>\n\ngoal (1 subgoal):\n 1. d_IN (\\<lambda>e. \\<Squnion>n. h_minus n e) x \\<noteq> \\<top>", "finally"], ["proof (chain)\npicking this:\n  d_IN (\\<lambda>e. \\<Squnion>n. h_minus n e) x < \\<top>", "show ?thesis"], ["proof (prove)\nusing this:\n  d_IN (\\<lambda>e. \\<Squnion>n. h_minus n e) x < \\<top>\n\ngoal (1 subgoal):\n 1. d_IN (\\<lambda>e. \\<Squnion>n. h_minus n e) x \\<noteq> \\<top>", "by simp"], ["proof (state)\nthis:\n  d_IN (\\<lambda>e. \\<Squnion>n. h_minus n e) x \\<noteq> \\<top>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lim_h_plus_OUT_IN:\n  assumes \"x \\<noteq> source \\<Delta>\" \"x \\<noteq> sink \\<Delta>\"\n  shows \"d_OUT lim_h_plus x = d_IN lim_h_plus x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. KIR (\\<lambda>e. \\<Squnion>n. h_plus n e) x", "proof(cases \"x \\<in> \\<^bold>V\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<in> \\<^bold>V \\<Longrightarrow>\n    KIR (\\<lambda>e. \\<Squnion>n. h_plus n e) x\n 2. x \\<notin> \\<^bold>V \\<Longrightarrow>\n    KIR (\\<lambda>e. \\<Squnion>n. h_plus n e) x", "case True"], ["proof (state)\nthis:\n  x \\<in> \\<^bold>V\n\ngoal (2 subgoals):\n 1. x \\<in> \\<^bold>V \\<Longrightarrow>\n    KIR (\\<lambda>e. \\<Squnion>n. h_plus n e) x\n 2. x \\<notin> \\<^bold>V \\<Longrightarrow>\n    KIR (\\<lambda>e. \\<Squnion>n. h_plus n e) x", "have \"d_OUT lim_h_plus x = (SUP n. d_OUT (h_plus n) x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT (\\<lambda>e. \\<Squnion>n. h_plus n e) x =\n    (\\<Squnion>n. d_OUT (h_plus n) x)", "by(rule d_OUT_monotone_convergence_SUP incseq_SucI le_funI h_plus_mono)+"], ["proof (state)\nthis:\n  d_OUT (\\<lambda>e. \\<Squnion>n. h_plus n e) x =\n  (\\<Squnion>n. d_OUT (h_plus n) x)\n\ngoal (2 subgoals):\n 1. x \\<in> \\<^bold>V \\<Longrightarrow>\n    KIR (\\<lambda>e. \\<Squnion>n. h_plus n e) x\n 2. x \\<notin> \\<^bold>V \\<Longrightarrow>\n    KIR (\\<lambda>e. \\<Squnion>n. h_plus n e) x", "also"], ["proof (state)\nthis:\n  d_OUT (\\<lambda>e. \\<Squnion>n. h_plus n e) x =\n  (\\<Squnion>n. d_OUT (h_plus n) x)\n\ngoal (2 subgoals):\n 1. x \\<in> \\<^bold>V \\<Longrightarrow>\n    KIR (\\<lambda>e. \\<Squnion>n. h_plus n e) x\n 2. x \\<notin> \\<^bold>V \\<Longrightarrow>\n    KIR (\\<lambda>e. \\<Squnion>n. h_plus n e) x", "have \"\\<dots> = (SUP n. d_IN (h_plus n) x)\" (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Squnion>n. d_OUT (h_plus n) x) = (\\<Squnion>n. d_IN (h_plus n) x)", "proof(rule antisym)"], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<Squnion>n. d_OUT (h_plus n) x) \\<le> (\\<Squnion>n. d_IN (h_plus n) x)\n 2. (\\<Squnion>n. d_IN (h_plus n) x) \\<le> (\\<Squnion>n. d_OUT (h_plus n) x)", "show \"?lhs \\<le> ?rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Squnion>n. d_OUT (h_plus n) x) \\<le> (\\<Squnion>n. d_IN (h_plus n) x)", "by(rule SUP_mono)(auto intro: h_plus_OUT_le_IN[OF assms(1)])"], ["proof (state)\nthis:\n  (\\<Squnion>n. d_OUT (h_plus n) x) \\<le> (\\<Squnion>n. d_IN (h_plus n) x)\n\ngoal (1 subgoal):\n 1. (\\<Squnion>n. d_IN (h_plus n) x) \\<le> (\\<Squnion>n. d_OUT (h_plus n) x)", "show \"?rhs \\<le> ?lhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Squnion>n. d_IN (h_plus n) x) \\<le> (\\<Squnion>n. d_OUT (h_plus n) x)", "proof(rule SUP_mono)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       n \\<in> UNIV \\<Longrightarrow>\n       \\<exists>m\\<in>UNIV. d_IN (h_plus n) x \\<le> d_OUT (h_plus m) x", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       n \\<in> UNIV \\<Longrightarrow>\n       \\<exists>m\\<in>UNIV. d_IN (h_plus n) x \\<le> d_OUT (h_plus m) x", "from enum_v_repeat[OF True assms, of i]"], ["proof (chain)\npicking this:\n  \\<exists>i'>i. enum_v i' = x", "obtain i' where \"i' > i\" \"enum_v i' = x\""], ["proof (prove)\nusing this:\n  \\<exists>i'>i. enum_v i' = x\n\ngoal (1 subgoal):\n 1. (\\<And>i'.\n        \\<lbrakk>i < i'; enum_v i' = x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  i < i'\n  enum_v i' = x\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       n \\<in> UNIV \\<Longrightarrow>\n       \\<exists>m\\<in>UNIV. d_IN (h_plus n) x \\<le> d_OUT (h_plus m) x", "moreover"], ["proof (state)\nthis:\n  i < i'\n  enum_v i' = x\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       n \\<in> UNIV \\<Longrightarrow>\n       \\<exists>m\\<in>UNIV. d_IN (h_plus n) x \\<le> d_OUT (h_plus m) x", "then"], ["proof (chain)\npicking this:\n  i < i'\n  enum_v i' = x", "obtain i'' where i': \"i' = Suc i''\""], ["proof (prove)\nusing this:\n  i < i'\n  enum_v i' = x\n\ngoal (1 subgoal):\n 1. (\\<And>i''. i' = Suc i'' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases i') auto"], ["proof (state)\nthis:\n  i' = Suc i''\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       n \\<in> UNIV \\<Longrightarrow>\n       \\<exists>m\\<in>UNIV. d_IN (h_plus n) x \\<le> d_OUT (h_plus m) x", "ultimately"], ["proof (chain)\npicking this:\n  i < i'\n  enum_v i' = x\n  i' = Suc i''", "have \"d_OUT (h_plus i') x = d_IN (h_plus i'') x\""], ["proof (prove)\nusing this:\n  i < i'\n  enum_v i' = x\n  i' = Suc i''\n\ngoal (1 subgoal):\n 1. d_OUT (h_plus i') x = d_IN (h_plus i'') x", "using  \\<open>x \\<noteq> source \\<Delta>\\<close>"], ["proof (prove)\nusing this:\n  i < i'\n  enum_v i' = x\n  i' = Suc i''\n  x \\<noteq> source \\<Delta>\n\ngoal (1 subgoal):\n 1. d_OUT (h_plus i') x = d_IN (h_plus i'') x", "by(simp add: h_plus_OUT_eq_IN)"], ["proof (state)\nthis:\n  d_OUT (h_plus i') x = d_IN (h_plus i'') x\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       n \\<in> UNIV \\<Longrightarrow>\n       \\<exists>m\\<in>UNIV. d_IN (h_plus n) x \\<le> d_OUT (h_plus m) x", "moreover"], ["proof (state)\nthis:\n  d_OUT (h_plus i') x = d_IN (h_plus i'') x\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       n \\<in> UNIV \\<Longrightarrow>\n       \\<exists>m\\<in>UNIV. d_IN (h_plus n) x \\<le> d_OUT (h_plus m) x", "have \"i \\<le> i''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<le> i''", "using \\<open>i < i'\\<close> i'"], ["proof (prove)\nusing this:\n  i < i'\n  i' = Suc i''\n\ngoal (1 subgoal):\n 1. i \\<le> i''", "by simp"], ["proof (state)\nthis:\n  i \\<le> i''\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       n \\<in> UNIV \\<Longrightarrow>\n       \\<exists>m\\<in>UNIV. d_IN (h_plus n) x \\<le> d_OUT (h_plus m) x", "then"], ["proof (chain)\npicking this:\n  i \\<le> i''", "have \"d_IN (h_plus i) x \\<le> d_IN (h_plus i'') x\""], ["proof (prove)\nusing this:\n  i \\<le> i''\n\ngoal (1 subgoal):\n 1. d_IN (h_plus i) x \\<le> d_IN (h_plus i'') x", "by(intro d_IN_mono h_plus_mono')"], ["proof (state)\nthis:\n  d_IN (h_plus i) x \\<le> d_IN (h_plus i'') x\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       n \\<in> UNIV \\<Longrightarrow>\n       \\<exists>m\\<in>UNIV. d_IN (h_plus n) x \\<le> d_OUT (h_plus m) x", "ultimately"], ["proof (chain)\npicking this:\n  d_OUT (h_plus i') x = d_IN (h_plus i'') x\n  d_IN (h_plus i) x \\<le> d_IN (h_plus i'') x", "have \"d_IN (h_plus i) x \\<le> d_OUT (h_plus i') x\""], ["proof (prove)\nusing this:\n  d_OUT (h_plus i') x = d_IN (h_plus i'') x\n  d_IN (h_plus i) x \\<le> d_IN (h_plus i'') x\n\ngoal (1 subgoal):\n 1. d_IN (h_plus i) x \\<le> d_OUT (h_plus i') x", "by simp"], ["proof (state)\nthis:\n  d_IN (h_plus i) x \\<le> d_OUT (h_plus i') x\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       n \\<in> UNIV \\<Longrightarrow>\n       \\<exists>m\\<in>UNIV. d_IN (h_plus n) x \\<le> d_OUT (h_plus m) x", "thus \"\\<exists>i'\\<in>UNIV. d_IN (h_plus i) x \\<le> d_OUT (h_plus i') x\""], ["proof (prove)\nusing this:\n  d_IN (h_plus i) x \\<le> d_OUT (h_plus i') x\n\ngoal (1 subgoal):\n 1. \\<exists>i'\\<in>UNIV. d_IN (h_plus i) x \\<le> d_OUT (h_plus i') x", "by blast"], ["proof (state)\nthis:\n  \\<exists>i'\\<in>UNIV. d_IN (h_plus i) x \\<le> d_OUT (h_plus i') x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Squnion>n. d_IN (h_plus n) x) \\<le> (\\<Squnion>n. d_OUT (h_plus n) x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Squnion>n. d_OUT (h_plus n) x) = (\\<Squnion>n. d_IN (h_plus n) x)\n\ngoal (2 subgoals):\n 1. x \\<in> \\<^bold>V \\<Longrightarrow>\n    KIR (\\<lambda>e. \\<Squnion>n. h_plus n e) x\n 2. x \\<notin> \\<^bold>V \\<Longrightarrow>\n    KIR (\\<lambda>e. \\<Squnion>n. h_plus n e) x", "also"], ["proof (state)\nthis:\n  (\\<Squnion>n. d_OUT (h_plus n) x) = (\\<Squnion>n. d_IN (h_plus n) x)\n\ngoal (2 subgoals):\n 1. x \\<in> \\<^bold>V \\<Longrightarrow>\n    KIR (\\<lambda>e. \\<Squnion>n. h_plus n e) x\n 2. x \\<notin> \\<^bold>V \\<Longrightarrow>\n    KIR (\\<lambda>e. \\<Squnion>n. h_plus n e) x", "have \"\\<dots> = d_IN lim_h_plus x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Squnion>n. d_IN (h_plus n) x) =\n    d_IN (\\<lambda>e. \\<Squnion>n. h_plus n e) x", "by(rule d_IN_monotone_convergence_SUP[symmetric] incseq_SucI le_funI h_plus_mono)+"], ["proof (state)\nthis:\n  (\\<Squnion>n. d_IN (h_plus n) x) =\n  d_IN (\\<lambda>e. \\<Squnion>n. h_plus n e) x\n\ngoal (2 subgoals):\n 1. x \\<in> \\<^bold>V \\<Longrightarrow>\n    KIR (\\<lambda>e. \\<Squnion>n. h_plus n e) x\n 2. x \\<notin> \\<^bold>V \\<Longrightarrow>\n    KIR (\\<lambda>e. \\<Squnion>n. h_plus n e) x", "finally"], ["proof (chain)\npicking this:\n  KIR (\\<lambda>e. \\<Squnion>n. h_plus n e) x", "show ?thesis"], ["proof (prove)\nusing this:\n  KIR (\\<lambda>e. \\<Squnion>n. h_plus n e) x\n\ngoal (1 subgoal):\n 1. KIR (\\<lambda>e. \\<Squnion>n. h_plus n e) x", "."], ["proof (state)\nthis:\n  KIR (\\<lambda>e. \\<Squnion>n. h_plus n e) x\n\ngoal (1 subgoal):\n 1. x \\<notin> \\<^bold>V \\<Longrightarrow>\n    KIR (\\<lambda>e. \\<Squnion>n. h_plus n e) x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<notin> \\<^bold>V \\<Longrightarrow>\n    KIR (\\<lambda>e. \\<Squnion>n. h_plus n e) x", "case False"], ["proof (state)\nthis:\n  x \\<notin> \\<^bold>V\n\ngoal (1 subgoal):\n 1. x \\<notin> \\<^bold>V \\<Longrightarrow>\n    KIR (\\<lambda>e. \\<Squnion>n. h_plus n e) x", "have \"(x, y) \\<notin> support_flow lim_h_plus\" for y"], ["proof (prove)\ngoal (1 subgoal):\n 1. (x, y) \\<notin> support_flow (\\<lambda>e. \\<Squnion>n. h_plus n e)", "using False h_plus_outside[of \"(x, y)\"]"], ["proof (prove)\nusing this:\n  x \\<notin> \\<^bold>V\n  (x, y) \\<notin> \\<^bold>E \\<Longrightarrow> h_plus ?i (x, y) = 0\n\ngoal (1 subgoal):\n 1. (x, y) \\<notin> support_flow (\\<lambda>e. \\<Squnion>n. h_plus n e)", "by(fastforce elim!: support_flow.cases simp add: less_SUP_iff vertex_def)"], ["proof (state)\nthis:\n  (x, ?y) \\<notin> support_flow (\\<lambda>e. \\<Squnion>n. h_plus n e)\n\ngoal (1 subgoal):\n 1. x \\<notin> \\<^bold>V \\<Longrightarrow>\n    KIR (\\<lambda>e. \\<Squnion>n. h_plus n e) x", "moreover"], ["proof (state)\nthis:\n  (x, ?y) \\<notin> support_flow (\\<lambda>e. \\<Squnion>n. h_plus n e)\n\ngoal (1 subgoal):\n 1. x \\<notin> \\<^bold>V \\<Longrightarrow>\n    KIR (\\<lambda>e. \\<Squnion>n. h_plus n e) x", "have \"(y, x) \\<notin> support_flow lim_h_plus\" for y"], ["proof (prove)\ngoal (1 subgoal):\n 1. (y, x) \\<notin> support_flow (\\<lambda>e. \\<Squnion>n. h_plus n e)", "using False h_plus_outside[of \"(y, x)\"]"], ["proof (prove)\nusing this:\n  x \\<notin> \\<^bold>V\n  (y, x) \\<notin> \\<^bold>E \\<Longrightarrow> h_plus ?i (y, x) = 0\n\ngoal (1 subgoal):\n 1. (y, x) \\<notin> support_flow (\\<lambda>e. \\<Squnion>n. h_plus n e)", "by(fastforce elim!: support_flow.cases simp add: less_SUP_iff vertex_def)"], ["proof (state)\nthis:\n  (?y, x) \\<notin> support_flow (\\<lambda>e. \\<Squnion>n. h_plus n e)\n\ngoal (1 subgoal):\n 1. x \\<notin> \\<^bold>V \\<Longrightarrow>\n    KIR (\\<lambda>e. \\<Squnion>n. h_plus n e) x", "ultimately"], ["proof (chain)\npicking this:\n  (x, ?y) \\<notin> support_flow (\\<lambda>e. \\<Squnion>n. h_plus n e)\n  (?y, x) \\<notin> support_flow (\\<lambda>e. \\<Squnion>n. h_plus n e)", "show ?thesis"], ["proof (prove)\nusing this:\n  (x, ?y) \\<notin> support_flow (\\<lambda>e. \\<Squnion>n. h_plus n e)\n  (?y, x) \\<notin> support_flow (\\<lambda>e. \\<Squnion>n. h_plus n e)\n\ngoal (1 subgoal):\n 1. KIR (\\<lambda>e. \\<Squnion>n. h_plus n e) x", "by(auto simp add: d_OUT_alt_def2 d_IN_alt_def2 AE_count_space intro!: nn_integral_cong_AE)"], ["proof (state)\nthis:\n  KIR (\\<lambda>e. \\<Squnion>n. h_plus n e) x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lim_h_minus_OUT_IN:\n  assumes cycles: \"cycles \\<Delta> \\<noteq> {}\"\n  shows \"d_OUT lim_h_minus x = d_IN lim_h_minus x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. KIR (\\<lambda>e. \\<Squnion>n. h_minus n e) x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. KIR (\\<lambda>e. \\<Squnion>n. h_minus n e) x", "have \"d_OUT lim_h_minus x = (SUP n. d_OUT (h_minus n) x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT (\\<lambda>e. \\<Squnion>n. h_minus n e) x =\n    (\\<Squnion>n. d_OUT (h_minus n) x)", "by(rule d_OUT_monotone_convergence_SUP incseq_SucI le_funI h_minus_mono)+"], ["proof (state)\nthis:\n  d_OUT (\\<lambda>e. \\<Squnion>n. h_minus n e) x =\n  (\\<Squnion>n. d_OUT (h_minus n) x)\n\ngoal (1 subgoal):\n 1. KIR (\\<lambda>e. \\<Squnion>n. h_minus n e) x", "also"], ["proof (state)\nthis:\n  d_OUT (\\<lambda>e. \\<Squnion>n. h_minus n e) x =\n  (\\<Squnion>n. d_OUT (h_minus n) x)\n\ngoal (1 subgoal):\n 1. KIR (\\<lambda>e. \\<Squnion>n. h_minus n e) x", "have \"\\<dots> = (SUP n. d_IN (h_minus n) x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Squnion>n. d_OUT (h_minus n) x) = (\\<Squnion>n. d_IN (h_minus n) x)", "using cycles"], ["proof (prove)\nusing this:\n  cycles \\<Delta> \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<Squnion>n. d_OUT (h_minus n) x) = (\\<Squnion>n. d_IN (h_minus n) x)", "by(simp add: d_OUT_h_minus)"], ["proof (state)\nthis:\n  (\\<Squnion>n. d_OUT (h_minus n) x) = (\\<Squnion>n. d_IN (h_minus n) x)\n\ngoal (1 subgoal):\n 1. KIR (\\<lambda>e. \\<Squnion>n. h_minus n e) x", "also"], ["proof (state)\nthis:\n  (\\<Squnion>n. d_OUT (h_minus n) x) = (\\<Squnion>n. d_IN (h_minus n) x)\n\ngoal (1 subgoal):\n 1. KIR (\\<lambda>e. \\<Squnion>n. h_minus n e) x", "have \"\\<dots> = d_IN lim_h_minus x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Squnion>n. d_IN (h_minus n) x) =\n    d_IN (\\<lambda>e. \\<Squnion>n. h_minus n e) x", "by(rule d_IN_monotone_convergence_SUP[symmetric] incseq_SucI le_funI h_minus_mono)+"], ["proof (state)\nthis:\n  (\\<Squnion>n. d_IN (h_minus n) x) =\n  d_IN (\\<lambda>e. \\<Squnion>n. h_minus n e) x\n\ngoal (1 subgoal):\n 1. KIR (\\<lambda>e. \\<Squnion>n. h_minus n e) x", "finally"], ["proof (chain)\npicking this:\n  KIR (\\<lambda>e. \\<Squnion>n. h_minus n e) x", "show ?thesis"], ["proof (prove)\nusing this:\n  KIR (\\<lambda>e. \\<Squnion>n. h_minus n e) x\n\ngoal (1 subgoal):\n 1. KIR (\\<lambda>e. \\<Squnion>n. h_minus n e) x", "."], ["proof (state)\nthis:\n  KIR (\\<lambda>e. \\<Squnion>n. h_minus n e) x\n\ngoal:\nNo subgoals!", "qed"], ["", "definition h :: \"'v edge \\<Rightarrow> ennreal\"\nwhere \"h e = lim_h_plus e - (if cycles \\<Delta> \\<noteq> {} then lim_h_minus e else 0)\""], ["", "lemma h_le_lim_h_plus: \"h e \\<le> lim_h_plus e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h e \\<le> (\\<Squnion>n. h_plus n e)", "by (simp add: h_def)"], ["", "lemma h_le_g: \"h e \\<le> g e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h e \\<le> g e", "using h_le_lim_h_plus[of e] lim_h_plus_le_g[of e]"], ["proof (prove)\nusing this:\n  h e \\<le> (\\<Squnion>n. h_plus n e)\n  (\\<Squnion>n. h_plus n e) \\<le> g e\n\ngoal (1 subgoal):\n 1. h e \\<le> g e", "by simp"], ["", "lemma flow_h: \"flow \\<Delta> h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. flow \\<Delta> h", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>e. h e \\<le> capacity \\<Delta> e\n 2. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>;\n        x \\<noteq> sink \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> KIR h x", "fix e"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>e. h e \\<le> capacity \\<Delta> e\n 2. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>;\n        x \\<noteq> sink \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> KIR h x", "have \"h e \\<le> lim_h_plus e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h e \\<le> (\\<Squnion>n. h_plus n e)", "by(rule h_le_lim_h_plus)"], ["proof (state)\nthis:\n  h e \\<le> (\\<Squnion>n. h_plus n e)\n\ngoal (2 subgoals):\n 1. \\<And>e. h e \\<le> capacity \\<Delta> e\n 2. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>;\n        x \\<noteq> sink \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> KIR h x", "also"], ["proof (state)\nthis:\n  h e \\<le> (\\<Squnion>n. h_plus n e)\n\ngoal (2 subgoals):\n 1. \\<And>e. h e \\<le> capacity \\<Delta> e\n 2. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>;\n        x \\<noteq> sink \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> KIR h x", "have \"\\<dots> \\<le> g e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Squnion>n. h_plus n e) \\<le> g e", "by(rule lim_h_plus_le_g)"], ["proof (state)\nthis:\n  (\\<Squnion>n. h_plus n e) \\<le> g e\n\ngoal (2 subgoals):\n 1. \\<And>e. h e \\<le> capacity \\<Delta> e\n 2. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>;\n        x \\<noteq> sink \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> KIR h x", "also"], ["proof (state)\nthis:\n  (\\<Squnion>n. h_plus n e) \\<le> g e\n\ngoal (2 subgoals):\n 1. \\<And>e. h e \\<le> capacity \\<Delta> e\n 2. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>;\n        x \\<noteq> sink \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> KIR h x", "have \"\\<dots> \\<le> capacity \\<Delta> e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g e \\<le> capacity \\<Delta> e", "using g"], ["proof (prove)\nusing this:\n  flow \\<Delta> g\n\ngoal (1 subgoal):\n 1. g e \\<le> capacity \\<Delta> e", "by(rule flowD_capacity)"], ["proof (state)\nthis:\n  g e \\<le> capacity \\<Delta> e\n\ngoal (2 subgoals):\n 1. \\<And>e. h e \\<le> capacity \\<Delta> e\n 2. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>;\n        x \\<noteq> sink \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> KIR h x", "finally"], ["proof (chain)\npicking this:\n  h e \\<le> capacity \\<Delta> e", "show \"h e \\<le> \\<dots>\""], ["proof (prove)\nusing this:\n  h e \\<le> capacity \\<Delta> e\n\ngoal (1 subgoal):\n 1. h e \\<le> capacity \\<Delta> e", "."], ["proof (state)\nthis:\n  h e \\<le> capacity \\<Delta> e\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>;\n        x \\<noteq> sink \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> KIR h x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>;\n        x \\<noteq> sink \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> KIR h x", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>;\n        x \\<noteq> sink \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> KIR h x", "assume \"x \\<noteq> source \\<Delta>\" \"x \\<noteq> sink \\<Delta>\""], ["proof (state)\nthis:\n  x \\<noteq> source \\<Delta>\n  x \\<noteq> sink \\<Delta>\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>;\n        x \\<noteq> sink \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> KIR h x", "then"], ["proof (chain)\npicking this:\n  x \\<noteq> source \\<Delta>\n  x \\<noteq> sink \\<Delta>", "show \"KIR h x\""], ["proof (prove)\nusing this:\n  x \\<noteq> source \\<Delta>\n  x \\<noteq> sink \\<Delta>\n\ngoal (1 subgoal):\n 1. KIR h x", "by (cases \"cycles \\<Delta> = {}\")\n       (auto simp add: h_def[abs_def] lim_h_plus_OUT_IN d_OUT_diff d_IN_diff lim_h_minus_le_lim_h_plus lim_h_minus_OUT_IN)"], ["proof (state)\nthis:\n  KIR h x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma value_h_plus: \"value_flow \\<Delta> (h_plus i) = value_flow \\<Delta> g\" (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. value_flow \\<Delta> (h_plus i) = value_flow \\<Delta> g", "proof(rule antisym)"], ["proof (state)\ngoal (2 subgoals):\n 1. value_flow \\<Delta> (h_plus i) \\<le> value_flow \\<Delta> g\n 2. value_flow \\<Delta> g \\<le> value_flow \\<Delta> (h_plus i)", "show \"?lhs \\<le> ?rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. value_flow \\<Delta> (h_plus i) \\<le> value_flow \\<Delta> g", "by(rule d_OUT_mono)(rule h_plus_le_g)"], ["proof (state)\nthis:\n  value_flow \\<Delta> (h_plus i) \\<le> value_flow \\<Delta> g\n\ngoal (1 subgoal):\n 1. value_flow \\<Delta> g \\<le> value_flow \\<Delta> (h_plus i)", "have \"?rhs \\<le> value_flow \\<Delta> (h_plus 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. value_flow \\<Delta> g \\<le> value_flow \\<Delta> (h_plus 0)", "by(auto simp add: d_OUT_def cong: if_cong intro!: nn_integral_mono)"], ["proof (state)\nthis:\n  value_flow \\<Delta> g \\<le> value_flow \\<Delta> (h_plus 0)\n\ngoal (1 subgoal):\n 1. value_flow \\<Delta> g \\<le> value_flow \\<Delta> (h_plus i)", "also"], ["proof (state)\nthis:\n  value_flow \\<Delta> g \\<le> value_flow \\<Delta> (h_plus 0)\n\ngoal (1 subgoal):\n 1. value_flow \\<Delta> g \\<le> value_flow \\<Delta> (h_plus i)", "have \"\\<dots> \\<le> value_flow \\<Delta> (h_plus i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. value_flow \\<Delta> (h_plus 0) \\<le> value_flow \\<Delta> (h_plus i)", "by(rule d_OUT_mono)(rule h_plus_mono'; simp)"], ["proof (state)\nthis:\n  value_flow \\<Delta> (h_plus 0) \\<le> value_flow \\<Delta> (h_plus i)\n\ngoal (1 subgoal):\n 1. value_flow \\<Delta> g \\<le> value_flow \\<Delta> (h_plus i)", "finally"], ["proof (chain)\npicking this:\n  value_flow \\<Delta> g \\<le> value_flow \\<Delta> (h_plus i)", "show \"?rhs \\<le> ?lhs\""], ["proof (prove)\nusing this:\n  value_flow \\<Delta> g \\<le> value_flow \\<Delta> (h_plus i)\n\ngoal (1 subgoal):\n 1. value_flow \\<Delta> g \\<le> value_flow \\<Delta> (h_plus i)", "."], ["proof (state)\nthis:\n  value_flow \\<Delta> g \\<le> value_flow \\<Delta> (h_plus i)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma value_h: \"value_flow \\<Delta> h = value_flow \\<Delta> g\" (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. value_flow \\<Delta> h = value_flow \\<Delta> g", "proof(rule antisym)"], ["proof (state)\ngoal (2 subgoals):\n 1. value_flow \\<Delta> h \\<le> value_flow \\<Delta> g\n 2. value_flow \\<Delta> g \\<le> value_flow \\<Delta> h", "have \"?lhs \\<le> value_flow \\<Delta> lim_h_plus\""], ["proof (prove)\ngoal (1 subgoal):\n 1. value_flow \\<Delta> h\n    \\<le> value_flow \\<Delta> (\\<lambda>e. \\<Squnion>n. h_plus n e)", "using ennreal_minus_mono"], ["proof (prove)\nusing this:\n  \\<lbrakk>?a \\<le> ?c; ?d \\<le> ?b\\<rbrakk>\n  \\<Longrightarrow> ?a - ?b \\<le> ?c - ?d\n\ngoal (1 subgoal):\n 1. value_flow \\<Delta> h\n    \\<le> value_flow \\<Delta> (\\<lambda>e. \\<Squnion>n. h_plus n e)", "by(fastforce simp add: h_def intro!: d_OUT_mono)"], ["proof (state)\nthis:\n  value_flow \\<Delta> h\n  \\<le> value_flow \\<Delta> (\\<lambda>e. \\<Squnion>n. h_plus n e)\n\ngoal (2 subgoals):\n 1. value_flow \\<Delta> h \\<le> value_flow \\<Delta> g\n 2. value_flow \\<Delta> g \\<le> value_flow \\<Delta> h", "also"], ["proof (state)\nthis:\n  value_flow \\<Delta> h\n  \\<le> value_flow \\<Delta> (\\<lambda>e. \\<Squnion>n. h_plus n e)\n\ngoal (2 subgoals):\n 1. value_flow \\<Delta> h \\<le> value_flow \\<Delta> g\n 2. value_flow \\<Delta> g \\<le> value_flow \\<Delta> h", "have \"\\<dots> \\<le> ?rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. value_flow \\<Delta> (\\<lambda>e. \\<Squnion>n. h_plus n e)\n    \\<le> value_flow \\<Delta> g", "by(rule d_OUT_mono)(rule lim_h_plus_le_g)"], ["proof (state)\nthis:\n  value_flow \\<Delta> (\\<lambda>e. \\<Squnion>n. h_plus n e)\n  \\<le> value_flow \\<Delta> g\n\ngoal (2 subgoals):\n 1. value_flow \\<Delta> h \\<le> value_flow \\<Delta> g\n 2. value_flow \\<Delta> g \\<le> value_flow \\<Delta> h", "finally"], ["proof (chain)\npicking this:\n  value_flow \\<Delta> h \\<le> value_flow \\<Delta> g", "show \"?lhs \\<le> ?rhs\""], ["proof (prove)\nusing this:\n  value_flow \\<Delta> h \\<le> value_flow \\<Delta> g\n\ngoal (1 subgoal):\n 1. value_flow \\<Delta> h \\<le> value_flow \\<Delta> g", "."], ["proof (state)\nthis:\n  value_flow \\<Delta> h \\<le> value_flow \\<Delta> g\n\ngoal (1 subgoal):\n 1. value_flow \\<Delta> g \\<le> value_flow \\<Delta> h", "show \"?rhs \\<le> ?lhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. value_flow \\<Delta> g \\<le> value_flow \\<Delta> h", "by(auto simp add: d_OUT_def h_def h_minus_source cong: if_cong intro!: nn_integral_mono SUP_upper2[where i=0])"], ["proof (state)\nthis:\n  value_flow \\<Delta> g \\<le> value_flow \\<Delta> h\n\ngoal:\nNo subgoals!", "qed"], ["", "definition h_diff :: \"nat \\<Rightarrow> 'v edge \\<Rightarrow> ennreal\"\nwhere \"h_diff i e = h_plus i e - (if cycles \\<Delta> \\<noteq> {} then h_minus i e else 0)\""], ["", "lemma d_IN_h_source [simp]: \"d_IN (h_diff i) (source \\<Delta>) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN (h_diff i) (source \\<Delta>) = 0", "by(simp add: d_IN_def h_diff_def cong del: if_weak_cong)"], ["", "lemma h_diff_le_h_plus: \"h_diff i e \\<le> h_plus i e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h_diff i e \\<le> h_plus i e", "by(simp add: h_diff_def)"], ["", "lemma h_diff_le_g: \"h_diff i e \\<le> g e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h_diff i e \\<le> g e", "using h_diff_le_h_plus[of i e] h_plus_le_g[of i e]"], ["proof (prove)\nusing this:\n  h_diff i e \\<le> h_plus i e\n  h_plus i e \\<le> g e\n\ngoal (1 subgoal):\n 1. h_diff i e \\<le> g e", "by simp"], ["", "lemma h_diff_loop [simp]: \"h_diff i (x, x) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h_diff i (x, x) = 0", "using h_diff_le_g[of i \"(x, x)\"]"], ["proof (prove)\nusing this:\n  h_diff i (x, x) \\<le> g (x, x)\n\ngoal (1 subgoal):\n 1. h_diff i (x, x) = 0", "by simp"], ["", "lemma supp_h_diff_edges: \"support_flow (h_diff i) \\<subseteq> \\<^bold>E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. support_flow (h_diff i) \\<subseteq> \\<^bold>E", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> support_flow (h_diff i) \\<Longrightarrow> x \\<in> \\<^bold>E", "fix e"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> support_flow (h_diff i) \\<Longrightarrow> x \\<in> \\<^bold>E", "assume \"e \\<in> support_flow (h_diff i)\""], ["proof (state)\nthis:\n  e \\<in> support_flow (h_diff i)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> support_flow (h_diff i) \\<Longrightarrow> x \\<in> \\<^bold>E", "then"], ["proof (chain)\npicking this:\n  e \\<in> support_flow (h_diff i)", "have \"0 < h_diff i e\""], ["proof (prove)\nusing this:\n  e \\<in> support_flow (h_diff i)\n\ngoal (1 subgoal):\n 1. 0 < h_diff i e", "by(auto elim: support_flow.cases)"], ["proof (state)\nthis:\n  0 < h_diff i e\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> support_flow (h_diff i) \\<Longrightarrow> x \\<in> \\<^bold>E", "also"], ["proof (state)\nthis:\n  0 < h_diff i e\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> support_flow (h_diff i) \\<Longrightarrow> x \\<in> \\<^bold>E", "have \"h_diff i e \\<le> h_plus i e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h_diff i e \\<le> h_plus i e", "by(rule h_diff_le_h_plus)"], ["proof (state)\nthis:\n  h_diff i e \\<le> h_plus i e\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> support_flow (h_diff i) \\<Longrightarrow> x \\<in> \\<^bold>E", "finally"], ["proof (chain)\npicking this:\n  0 < h_plus i e", "show \"e \\<in> \\<^bold>E\""], ["proof (prove)\nusing this:\n  0 < h_plus i e\n\ngoal (1 subgoal):\n 1. e \\<in> \\<^bold>E", "using h_plus_outside[of e i]"], ["proof (prove)\nusing this:\n  0 < h_plus i e\n  e \\<notin> \\<^bold>E \\<Longrightarrow> h_plus i e = 0\n\ngoal (1 subgoal):\n 1. e \\<in> \\<^bold>E", "by(cases \"e \\<in> \\<^bold>E\") auto"], ["proof (state)\nthis:\n  e \\<in> \\<^bold>E\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma h_diff_OUT_le_IN:\n  assumes \"x \\<noteq> source \\<Delta>\"\n  shows \"d_OUT (h_diff i) x \\<le> d_IN (h_diff i) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT (h_diff i) x \\<le> d_IN (h_diff i) x", "proof(cases \"cycles \\<Delta> \\<noteq> {}\")"], ["proof (state)\ngoal (2 subgoals):\n 1. cycles \\<Delta> \\<noteq> {} \\<Longrightarrow>\n    d_OUT (h_diff i) x \\<le> d_IN (h_diff i) x\n 2. \\<not> cycles \\<Delta> \\<noteq> {} \\<Longrightarrow>\n    d_OUT (h_diff i) x \\<le> d_IN (h_diff i) x", "case False"], ["proof (state)\nthis:\n  \\<not> cycles \\<Delta> \\<noteq> {}\n\ngoal (2 subgoals):\n 1. cycles \\<Delta> \\<noteq> {} \\<Longrightarrow>\n    d_OUT (h_diff i) x \\<le> d_IN (h_diff i) x\n 2. \\<not> cycles \\<Delta> \\<noteq> {} \\<Longrightarrow>\n    d_OUT (h_diff i) x \\<le> d_IN (h_diff i) x", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> cycles \\<Delta> \\<noteq> {}\n\ngoal (1 subgoal):\n 1. d_OUT (h_diff i) x \\<le> d_IN (h_diff i) x", "using assms"], ["proof (prove)\nusing this:\n  \\<not> cycles \\<Delta> \\<noteq> {}\n  x \\<noteq> source \\<Delta>\n\ngoal (1 subgoal):\n 1. d_OUT (h_diff i) x \\<le> d_IN (h_diff i) x", "by(simp add: h_diff_def[abs_def] h_plus_OUT_le_IN)"], ["proof (state)\nthis:\n  d_OUT (h_diff i) x \\<le> d_IN (h_diff i) x\n\ngoal (1 subgoal):\n 1. cycles \\<Delta> \\<noteq> {} \\<Longrightarrow>\n    d_OUT (h_diff i) x \\<le> d_IN (h_diff i) x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. cycles \\<Delta> \\<noteq> {} \\<Longrightarrow>\n    d_OUT (h_diff i) x \\<le> d_IN (h_diff i) x", "case cycles: True"], ["proof (state)\nthis:\n  cycles \\<Delta> \\<noteq> {}\n\ngoal (1 subgoal):\n 1. cycles \\<Delta> \\<noteq> {} \\<Longrightarrow>\n    d_OUT (h_diff i) x \\<le> d_IN (h_diff i) x", "then"], ["proof (chain)\npicking this:\n  cycles \\<Delta> \\<noteq> {}", "have \"d_OUT (h_diff i) x = d_OUT (h_plus i) x - d_OUT (h_minus i) x\""], ["proof (prove)\nusing this:\n  cycles \\<Delta> \\<noteq> {}\n\ngoal (1 subgoal):\n 1. d_OUT (h_diff i) x = d_OUT (h_plus i) x - d_OUT (h_minus i) x", "unfolding h_diff_def[abs_def]"], ["proof (prove)\nusing this:\n  cycles \\<Delta> \\<noteq> {}\n\ngoal (1 subgoal):\n 1. d_OUT\n     (\\<lambda>e.\n         h_plus i e -\n         (if cycles \\<Delta> \\<noteq> {} then h_minus i e else 0))\n     x =\n    d_OUT (h_plus i) x - d_OUT (h_minus i) x", "using assms"], ["proof (prove)\nusing this:\n  cycles \\<Delta> \\<noteq> {}\n  x \\<noteq> source \\<Delta>\n\ngoal (1 subgoal):\n 1. d_OUT\n     (\\<lambda>e.\n         h_plus i e -\n         (if cycles \\<Delta> \\<noteq> {} then h_minus i e else 0))\n     x =\n    d_OUT (h_plus i) x - d_OUT (h_minus i) x", "by (simp add: h_minus_le_h_plus d_OUT_diff)"], ["proof (state)\nthis:\n  d_OUT (h_diff i) x = d_OUT (h_plus i) x - d_OUT (h_minus i) x\n\ngoal (1 subgoal):\n 1. cycles \\<Delta> \\<noteq> {} \\<Longrightarrow>\n    d_OUT (h_diff i) x \\<le> d_IN (h_diff i) x", "also"], ["proof (state)\nthis:\n  d_OUT (h_diff i) x = d_OUT (h_plus i) x - d_OUT (h_minus i) x\n\ngoal (1 subgoal):\n 1. cycles \\<Delta> \\<noteq> {} \\<Longrightarrow>\n    d_OUT (h_diff i) x \\<le> d_IN (h_diff i) x", "have \"\\<dots> \\<le> d_IN (h_plus i) x - d_IN (h_minus i) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT (h_plus i) x - d_OUT (h_minus i) x\n    \\<le> d_IN (h_plus i) x - d_IN (h_minus i) x", "using cycles assms"], ["proof (prove)\nusing this:\n  cycles \\<Delta> \\<noteq> {}\n  x \\<noteq> source \\<Delta>\n\ngoal (1 subgoal):\n 1. d_OUT (h_plus i) x - d_OUT (h_minus i) x\n    \\<le> d_IN (h_plus i) x - d_IN (h_minus i) x", "by(intro ennreal_minus_mono h_plus_OUT_le_IN)(simp_all add: d_OUT_h_minus)"], ["proof (state)\nthis:\n  d_OUT (h_plus i) x - d_OUT (h_minus i) x\n  \\<le> d_IN (h_plus i) x - d_IN (h_minus i) x\n\ngoal (1 subgoal):\n 1. cycles \\<Delta> \\<noteq> {} \\<Longrightarrow>\n    d_OUT (h_diff i) x \\<le> d_IN (h_diff i) x", "also"], ["proof (state)\nthis:\n  d_OUT (h_plus i) x - d_OUT (h_minus i) x\n  \\<le> d_IN (h_plus i) x - d_IN (h_minus i) x\n\ngoal (1 subgoal):\n 1. cycles \\<Delta> \\<noteq> {} \\<Longrightarrow>\n    d_OUT (h_diff i) x \\<le> d_IN (h_diff i) x", "have \"\\<dots> = d_IN (h_diff i) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN (h_plus i) x - d_IN (h_minus i) x = d_IN (h_diff i) x", "using cycles"], ["proof (prove)\nusing this:\n  cycles \\<Delta> \\<noteq> {}\n\ngoal (1 subgoal):\n 1. d_IN (h_plus i) x - d_IN (h_minus i) x = d_IN (h_diff i) x", "unfolding h_diff_def[abs_def]"], ["proof (prove)\nusing this:\n  cycles \\<Delta> \\<noteq> {}\n\ngoal (1 subgoal):\n 1. d_IN (h_plus i) x - d_IN (h_minus i) x =\n    d_IN\n     (\\<lambda>e.\n         h_plus i e -\n         (if cycles \\<Delta> \\<noteq> {} then h_minus i e else 0))\n     x", "by(subst d_IN_diff)(simp_all add: h_minus_le_h_plus d_OUT_h_minus[symmetric])"], ["proof (state)\nthis:\n  d_IN (h_plus i) x - d_IN (h_minus i) x = d_IN (h_diff i) x\n\ngoal (1 subgoal):\n 1. cycles \\<Delta> \\<noteq> {} \\<Longrightarrow>\n    d_OUT (h_diff i) x \\<le> d_IN (h_diff i) x", "finally"], ["proof (chain)\npicking this:\n  d_OUT (h_diff i) x \\<le> d_IN (h_diff i) x", "show ?thesis"], ["proof (prove)\nusing this:\n  d_OUT (h_diff i) x \\<le> d_IN (h_diff i) x\n\ngoal (1 subgoal):\n 1. d_OUT (h_diff i) x \\<le> d_IN (h_diff i) x", "."], ["proof (state)\nthis:\n  d_OUT (h_diff i) x \\<le> d_IN (h_diff i) x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma h_diff_cycle:\n  assumes \"cycle \\<Delta> p\"\n  shows \"\\<exists>e\\<in>set (cycle_edges p). h_diff i e = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>e\\<in>set (cycle_edges p). h_diff i e = 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>e\\<in>set (cycle_edges p). h_diff i e = 0", "from h_minus_cycle[OF assms, of i]"], ["proof (chain)\npicking this:\n  \\<exists>e\\<in>set (cycle_edges p). h_minus i e = h_plus i e", "obtain e\n    where e: \"e \\<in> set (cycle_edges p)\" and \"h_minus i e = h_plus i e\""], ["proof (prove)\nusing this:\n  \\<exists>e\\<in>set (cycle_edges p). h_minus i e = h_plus i e\n\ngoal (1 subgoal):\n 1. (\\<And>e.\n        \\<lbrakk>e \\<in> set (cycle_edges p);\n         h_minus i e = h_plus i e\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  e \\<in> set (cycle_edges p)\n  h_minus i e = h_plus i e\n\ngoal (1 subgoal):\n 1. \\<exists>e\\<in>set (cycle_edges p). h_diff i e = 0", "hence \"h_diff i e = 0\""], ["proof (prove)\nusing this:\n  e \\<in> set (cycle_edges p)\n  h_minus i e = h_plus i e\n\ngoal (1 subgoal):\n 1. h_diff i e = 0", "using assms"], ["proof (prove)\nusing this:\n  e \\<in> set (cycle_edges p)\n  h_minus i e = h_plus i e\n  cycle \\<Delta> p\n\ngoal (1 subgoal):\n 1. h_diff i e = 0", "by(auto simp add: h_diff_def)"], ["proof (state)\nthis:\n  h_diff i e = 0\n\ngoal (1 subgoal):\n 1. \\<exists>e\\<in>set (cycle_edges p). h_diff i e = 0", "with e"], ["proof (chain)\npicking this:\n  e \\<in> set (cycle_edges p)\n  h_diff i e = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  e \\<in> set (cycle_edges p)\n  h_diff i e = 0\n\ngoal (1 subgoal):\n 1. \\<exists>e\\<in>set (cycle_edges p). h_diff i e = 0", "by blast"], ["proof (state)\nthis:\n  \\<exists>e\\<in>set (cycle_edges p). h_diff i e = 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma d_IN_h_le_value': \"d_IN (h_diff i) x \\<le> value_flow \\<Delta> (h_plus i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN (h_diff i) x \\<le> value_flow \\<Delta> (h_plus i)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. d_IN (h_diff i) x \\<le> value_flow \\<Delta> (h_plus i)", "let ?supp = \"support_flow (h_diff i)\""], ["proof (state)\ngoal (1 subgoal):\n 1. d_IN (h_diff i) x \\<le> value_flow \\<Delta> (h_plus i)", "define X where \"X = {y. (y, x) \\<in> ?supp^*} - {x}\""], ["proof (state)\nthis:\n  X = {y. (y, x) \\<in> (support_flow (h_diff i))\\<^sup>*} - {x}\n\ngoal (1 subgoal):\n 1. d_IN (h_diff i) x \\<le> value_flow \\<Delta> (h_plus i)", "{"], ["proof (state)\nthis:\n  X = {y. (y, x) \\<in> (support_flow (h_diff i))\\<^sup>*} - {x}\n\ngoal (1 subgoal):\n 1. d_IN (h_diff i) x \\<le> value_flow \\<Delta> (h_plus i)", "fix x y"], ["proof (state)\ngoal (1 subgoal):\n 1. d_IN (h_diff i) x \\<le> value_flow \\<Delta> (h_plus i)", "assume x: \"x \\<notin> X\" and y: \"y \\<in> X\""], ["proof (state)\nthis:\n  x \\<notin> X\n  y \\<in> X\n\ngoal (1 subgoal):\n 1. d_IN (h_diff i) x \\<le> value_flow \\<Delta> (h_plus i)", "{"], ["proof (state)\nthis:\n  x \\<notin> X\n  y \\<in> X\n\ngoal (1 subgoal):\n 1. d_IN (h_diff i) x \\<le> value_flow \\<Delta> (h_plus i)", "assume yx: \"(y, x) \\<in> ?supp\\<^sup>*\" and neq: \"y \\<noteq> x\" and xy: \"(x, y) \\<in> ?supp\""], ["proof (state)\nthis:\n  (y, x) \\<in> (support_flow (h_diff i))\\<^sup>*\n  y \\<noteq> x\n  (x, y) \\<in> support_flow (h_diff i)\n\ngoal (1 subgoal):\n 1. d_IN (h_diff i) x \\<le> value_flow \\<Delta> (h_plus i)", "from yx"], ["proof (chain)\npicking this:\n  (y, x) \\<in> (support_flow (h_diff i))\\<^sup>*", "obtain p' where \"rtrancl_path (\\<lambda>x y. (x, y) \\<in> ?supp) y p' x\""], ["proof (prove)\nusing this:\n  (y, x) \\<in> (support_flow (h_diff i))\\<^sup>*\n\ngoal (1 subgoal):\n 1. (\\<And>p'.\n        rtrancl_path (\\<lambda>x y. (x, y) \\<in> support_flow (h_diff i)) y\n         p' x \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding rtrancl_def rtranclp_eq_rtrancl_path"], ["proof (prove)\nusing this:\n  (y, x)\n  \\<in> {(xa, x).\n         \\<exists>xs.\n            rtrancl_path\n             (\\<lambda>x xa. (x, xa) \\<in> support_flow (h_diff i)) xa xs x}\n\ngoal (1 subgoal):\n 1. (\\<And>p'.\n        rtrancl_path (\\<lambda>x y. (x, y) \\<in> support_flow (h_diff i)) y\n         p' x \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  rtrancl_path (\\<lambda>x y. (x, y) \\<in> support_flow (h_diff i)) y p' x\n\ngoal (1 subgoal):\n 1. d_IN (h_diff i) x \\<le> value_flow \\<Delta> (h_plus i)", "then"], ["proof (chain)\npicking this:\n  rtrancl_path (\\<lambda>x y. (x, y) \\<in> support_flow (h_diff i)) y p' x", "obtain p where p: \"rtrancl_path (\\<lambda>x y. (x, y) \\<in> ?supp) y p x\"\n        and distinct: \"distinct (y # p)\""], ["proof (prove)\nusing this:\n  rtrancl_path (\\<lambda>x y. (x, y) \\<in> support_flow (h_diff i)) y p' x\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        \\<lbrakk>rtrancl_path\n                  (\\<lambda>x y. (x, y) \\<in> support_flow (h_diff i)) y p\n                  x;\n         distinct (y # p)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(rule rtrancl_path_distinct)"], ["proof (state)\nthis:\n  rtrancl_path (\\<lambda>x y. (x, y) \\<in> support_flow (h_diff i)) y p x\n  distinct (y # p)\n\ngoal (1 subgoal):\n 1. d_IN (h_diff i) x \\<le> value_flow \\<Delta> (h_plus i)", "with neq"], ["proof (chain)\npicking this:\n  y \\<noteq> x\n  rtrancl_path (\\<lambda>x y. (x, y) \\<in> support_flow (h_diff i)) y p x\n  distinct (y # p)", "have \"p \\<noteq> []\""], ["proof (prove)\nusing this:\n  y \\<noteq> x\n  rtrancl_path (\\<lambda>x y. (x, y) \\<in> support_flow (h_diff i)) y p x\n  distinct (y # p)\n\ngoal (1 subgoal):\n 1. p \\<noteq> []", "by(auto elim: rtrancl_path.cases)"], ["proof (state)\nthis:\n  p \\<noteq> []\n\ngoal (1 subgoal):\n 1. d_IN (h_diff i) x \\<le> value_flow \\<Delta> (h_plus i)", "from xy"], ["proof (chain)\npicking this:\n  (x, y) \\<in> support_flow (h_diff i)", "have \"(x, y) \\<in> \\<^bold>E\""], ["proof (prove)\nusing this:\n  (x, y) \\<in> support_flow (h_diff i)\n\ngoal (1 subgoal):\n 1. (x, y) \\<in> \\<^bold>E", "using supp_h_diff_edges[of i]"], ["proof (prove)\nusing this:\n  (x, y) \\<in> support_flow (h_diff i)\n  support_flow (h_diff i) \\<subseteq> \\<^bold>E\n\ngoal (1 subgoal):\n 1. (x, y) \\<in> \\<^bold>E", "by(auto)"], ["proof (state)\nthis:\n  (x, y) \\<in> \\<^bold>E\n\ngoal (1 subgoal):\n 1. d_IN (h_diff i) x \\<le> value_flow \\<Delta> (h_plus i)", "moreover"], ["proof (state)\nthis:\n  (x, y) \\<in> \\<^bold>E\n\ngoal (1 subgoal):\n 1. d_IN (h_diff i) x \\<le> value_flow \\<Delta> (h_plus i)", "from p"], ["proof (chain)\npicking this:\n  rtrancl_path (\\<lambda>x y. (x, y) \\<in> support_flow (h_diff i)) y p x", "have \"path \\<Delta> y p x\""], ["proof (prove)\nusing this:\n  rtrancl_path (\\<lambda>x y. (x, y) \\<in> support_flow (h_diff i)) y p x\n\ngoal (1 subgoal):\n 1. path \\<Delta> y p x", "by(rule rtrancl_path_mono)(auto dest: supp_h_diff_edges[THEN subsetD])"], ["proof (state)\nthis:\n  path \\<Delta> y p x\n\ngoal (1 subgoal):\n 1. d_IN (h_diff i) x \\<le> value_flow \\<Delta> (h_plus i)", "ultimately"], ["proof (chain)\npicking this:\n  (x, y) \\<in> \\<^bold>E\n  path \\<Delta> y p x", "have \"path \\<Delta> x (y # p) x\""], ["proof (prove)\nusing this:\n  (x, y) \\<in> \\<^bold>E\n  path \\<Delta> y p x\n\ngoal (1 subgoal):\n 1. path \\<Delta> x (y # p) x", "by(auto intro: rtrancl_path.intros)"], ["proof (state)\nthis:\n  path \\<Delta> x (y # p) x\n\ngoal (1 subgoal):\n 1. d_IN (h_diff i) x \\<le> value_flow \\<Delta> (h_plus i)", "hence cycle: \"cycle \\<Delta> (y # p)\""], ["proof (prove)\nusing this:\n  path \\<Delta> x (y # p) x\n\ngoal (1 subgoal):\n 1. cycle \\<Delta> (y # p)", "using _ distinct"], ["proof (prove)\nusing this:\n  path \\<Delta> x (y # p) x\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  distinct (y # p)\n\ngoal (1 subgoal):\n 1. cycle \\<Delta> (y # p)", "by(rule cycle) simp"], ["proof (state)\nthis:\n  cycle \\<Delta> (y # p)\n\ngoal (1 subgoal):\n 1. d_IN (h_diff i) x \\<le> value_flow \\<Delta> (h_plus i)", "from h_diff_cycle[OF this, of i]"], ["proof (chain)\npicking this:\n  \\<exists>e\\<in>set (cycle_edges (y # p)). h_diff i e = 0", "obtain e\n        where e: \"e \\<in> set (cycle_edges (y # p))\" and 0: \"h_diff i e = 0\""], ["proof (prove)\nusing this:\n  \\<exists>e\\<in>set (cycle_edges (y # p)). h_diff i e = 0\n\ngoal (1 subgoal):\n 1. (\\<And>e.\n        \\<lbrakk>e \\<in> set (cycle_edges (y # p)); h_diff i e = 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  e \\<in> set (cycle_edges (y # p))\n  h_diff i e = 0\n\ngoal (1 subgoal):\n 1. d_IN (h_diff i) x \\<le> value_flow \\<Delta> (h_plus i)", "from e"], ["proof (chain)\npicking this:\n  e \\<in> set (cycle_edges (y # p))", "obtain n where e': \"e = ((y # p) ! n, (p @ [y]) ! n)\" and n: \"n < Suc (length p)\""], ["proof (prove)\nusing this:\n  e \\<in> set (cycle_edges (y # p))\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        \\<lbrakk>e = ((y # p) ! n, (p @ [y]) ! n);\n         n < Suc (length p)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto simp add: cycle_edges_def set_zip)"], ["proof (state)\nthis:\n  e = ((y # p) ! n, (p @ [y]) ! n)\n  n < Suc (length p)\n\ngoal (1 subgoal):\n 1. d_IN (h_diff i) x \\<le> value_flow \\<Delta> (h_plus i)", "have \"e \\<in> ?supp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. e \\<in> support_flow (h_diff i)", "proof(cases \"n = length p\")"], ["proof (state)\ngoal (2 subgoals):\n 1. n = length p \\<Longrightarrow> e \\<in> support_flow (h_diff i)\n 2. n \\<noteq> length p \\<Longrightarrow> e \\<in> support_flow (h_diff i)", "case True"], ["proof (state)\nthis:\n  n = length p\n\ngoal (2 subgoals):\n 1. n = length p \\<Longrightarrow> e \\<in> support_flow (h_diff i)\n 2. n \\<noteq> length p \\<Longrightarrow> e \\<in> support_flow (h_diff i)", "with rtrancl_path_last[OF p] \\<open>p \\<noteq> []\\<close>"], ["proof (chain)\npicking this:\n  p \\<noteq> [] \\<Longrightarrow> last p = x\n  p \\<noteq> []\n  n = length p", "have \"(y # p) ! n = x\""], ["proof (prove)\nusing this:\n  p \\<noteq> [] \\<Longrightarrow> last p = x\n  p \\<noteq> []\n  n = length p\n\ngoal (1 subgoal):\n 1. (y # p) ! n = x", "by(cases p)(simp_all add: last_conv_nth del: last.simps)"], ["proof (state)\nthis:\n  (y # p) ! n = x\n\ngoal (2 subgoals):\n 1. n = length p \\<Longrightarrow> e \\<in> support_flow (h_diff i)\n 2. n \\<noteq> length p \\<Longrightarrow> e \\<in> support_flow (h_diff i)", "with e' True"], ["proof (chain)\npicking this:\n  e = ((y # p) ! n, (p @ [y]) ! n)\n  n = length p\n  (y # p) ! n = x", "have \"e = (x, y)\""], ["proof (prove)\nusing this:\n  e = ((y # p) ! n, (p @ [y]) ! n)\n  n = length p\n  (y # p) ! n = x\n\ngoal (1 subgoal):\n 1. e = (x, y)", "by simp"], ["proof (state)\nthis:\n  e = (x, y)\n\ngoal (2 subgoals):\n 1. n = length p \\<Longrightarrow> e \\<in> support_flow (h_diff i)\n 2. n \\<noteq> length p \\<Longrightarrow> e \\<in> support_flow (h_diff i)", "with xy"], ["proof (chain)\npicking this:\n  (x, y) \\<in> support_flow (h_diff i)\n  e = (x, y)", "show ?thesis"], ["proof (prove)\nusing this:\n  (x, y) \\<in> support_flow (h_diff i)\n  e = (x, y)\n\ngoal (1 subgoal):\n 1. e \\<in> support_flow (h_diff i)", "by simp"], ["proof (state)\nthis:\n  e \\<in> support_flow (h_diff i)\n\ngoal (1 subgoal):\n 1. n \\<noteq> length p \\<Longrightarrow> e \\<in> support_flow (h_diff i)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. n \\<noteq> length p \\<Longrightarrow> e \\<in> support_flow (h_diff i)", "case False"], ["proof (state)\nthis:\n  n \\<noteq> length p\n\ngoal (1 subgoal):\n 1. n \\<noteq> length p \\<Longrightarrow> e \\<in> support_flow (h_diff i)", "with n"], ["proof (chain)\npicking this:\n  n < Suc (length p)\n  n \\<noteq> length p", "have \"n < length p\""], ["proof (prove)\nusing this:\n  n < Suc (length p)\n  n \\<noteq> length p\n\ngoal (1 subgoal):\n 1. n < length p", "by simp"], ["proof (state)\nthis:\n  n < length p\n\ngoal (1 subgoal):\n 1. n \\<noteq> length p \\<Longrightarrow> e \\<in> support_flow (h_diff i)", "with rtrancl_path_nth[OF p this] e'"], ["proof (chain)\npicking this:\n  ((y # p) ! n, p ! n) \\<in> support_flow (h_diff i)\n  e = ((y # p) ! n, (p @ [y]) ! n)\n  n < length p", "show ?thesis"], ["proof (prove)\nusing this:\n  ((y # p) ! n, p ! n) \\<in> support_flow (h_diff i)\n  e = ((y # p) ! n, (p @ [y]) ! n)\n  n < length p\n\ngoal (1 subgoal):\n 1. e \\<in> support_flow (h_diff i)", "by(simp add: nth_append)"], ["proof (state)\nthis:\n  e \\<in> support_flow (h_diff i)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  e \\<in> support_flow (h_diff i)\n\ngoal (1 subgoal):\n 1. d_IN (h_diff i) x \\<le> value_flow \\<Delta> (h_plus i)", "with 0"], ["proof (chain)\npicking this:\n  h_diff i e = 0\n  e \\<in> support_flow (h_diff i)", "have False"], ["proof (prove)\nusing this:\n  h_diff i e = 0\n  e \\<in> support_flow (h_diff i)\n\ngoal (1 subgoal):\n 1. False", "by(simp add: support_flow.simps)"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. d_IN (h_diff i) x \\<le> value_flow \\<Delta> (h_plus i)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>(y, x) \\<in> (support_flow (h_diff i))\\<^sup>*; y \\<noteq> x;\n   (x, y) \\<in> support_flow (h_diff i)\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. d_IN (h_diff i) x \\<le> value_flow \\<Delta> (h_plus i)", "hence \"(x, y) \\<notin> ?supp\""], ["proof (prove)\nusing this:\n  \\<lbrakk>(y, x) \\<in> (support_flow (h_diff i))\\<^sup>*; y \\<noteq> x;\n   (x, y) \\<in> support_flow (h_diff i)\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. (x, y) \\<notin> support_flow (h_diff i)", "using x y"], ["proof (prove)\nusing this:\n  \\<lbrakk>(y, x) \\<in> (support_flow (h_diff i))\\<^sup>*; y \\<noteq> x;\n   (x, y) \\<in> support_flow (h_diff i)\\<rbrakk>\n  \\<Longrightarrow> False\n  x \\<notin> X\n  y \\<in> X\n\ngoal (1 subgoal):\n 1. (x, y) \\<notin> support_flow (h_diff i)", "by(auto simp add: X_def intro: converse_rtrancl_into_rtrancl)"], ["proof (state)\nthis:\n  (x, y) \\<notin> support_flow (h_diff i)\n\ngoal (1 subgoal):\n 1. d_IN (h_diff i) x \\<le> value_flow \\<Delta> (h_plus i)", "then"], ["proof (chain)\npicking this:\n  (x, y) \\<notin> support_flow (h_diff i)", "have \"h_diff i (x, y) = 0\""], ["proof (prove)\nusing this:\n  (x, y) \\<notin> support_flow (h_diff i)\n\ngoal (1 subgoal):\n 1. h_diff i (x, y) = 0", "by(simp add: support_flow.simps)"], ["proof (state)\nthis:\n  h_diff i (x, y) = 0\n\ngoal (1 subgoal):\n 1. d_IN (h_diff i) x \\<le> value_flow \\<Delta> (h_plus i)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?xa2 \\<notin> X; ?y2 \\<in> X\\<rbrakk>\n  \\<Longrightarrow> h_diff i (?xa2, ?y2) = 0\n\ngoal (1 subgoal):\n 1. d_IN (h_diff i) x \\<le> value_flow \\<Delta> (h_plus i)", "note acyclic = this"], ["proof (state)\nthis:\n  \\<lbrakk>?xa2 \\<notin> X; ?y2 \\<in> X\\<rbrakk>\n  \\<Longrightarrow> h_diff i (?xa2, ?y2) = 0\n\ngoal (1 subgoal):\n 1. d_IN (h_diff i) x \\<le> value_flow \\<Delta> (h_plus i)", "{"], ["proof (state)\nthis:\n  \\<lbrakk>?xa2 \\<notin> X; ?y2 \\<in> X\\<rbrakk>\n  \\<Longrightarrow> h_diff i (?xa2, ?y2) = 0\n\ngoal (1 subgoal):\n 1. d_IN (h_diff i) x \\<le> value_flow \\<Delta> (h_plus i)", "fix y"], ["proof (state)\ngoal (1 subgoal):\n 1. d_IN (h_diff i) x \\<le> value_flow \\<Delta> (h_plus i)", "assume \"y \\<notin> X\""], ["proof (state)\nthis:\n  y \\<notin> X\n\ngoal (1 subgoal):\n 1. d_IN (h_diff i) x \\<le> value_flow \\<Delta> (h_plus i)", "hence \"(y, x) \\<notin> ?supp\""], ["proof (prove)\nusing this:\n  y \\<notin> X\n\ngoal (1 subgoal):\n 1. (y, x) \\<notin> support_flow (h_diff i)", "by(auto simp add: X_def support_flow.simps intro: not_in_support_flowD)"], ["proof (state)\nthis:\n  (y, x) \\<notin> support_flow (h_diff i)\n\ngoal (1 subgoal):\n 1. d_IN (h_diff i) x \\<le> value_flow \\<Delta> (h_plus i)", "hence \"h_diff i (y, x) = 0\""], ["proof (prove)\nusing this:\n  (y, x) \\<notin> support_flow (h_diff i)\n\ngoal (1 subgoal):\n 1. h_diff i (y, x) = 0", "by(simp add: support_flow.simps)"], ["proof (state)\nthis:\n  h_diff i (y, x) = 0\n\ngoal (1 subgoal):\n 1. d_IN (h_diff i) x \\<le> value_flow \\<Delta> (h_plus i)", "}"], ["proof (state)\nthis:\n  ?y2 \\<notin> X \\<Longrightarrow> h_diff i (?y2, x) = 0\n\ngoal (1 subgoal):\n 1. d_IN (h_diff i) x \\<le> value_flow \\<Delta> (h_plus i)", "note in_X = this"], ["proof (state)\nthis:\n  ?y2 \\<notin> X \\<Longrightarrow> h_diff i (?y2, x) = 0\n\ngoal (1 subgoal):\n 1. d_IN (h_diff i) x \\<le> value_flow \\<Delta> (h_plus i)", "let ?diff = \"\\<lambda>x. (\\<Sum>\\<^sup>+ y. h_diff i (x, y) * indicator X x * indicator X y)\""], ["proof (state)\ngoal (1 subgoal):\n 1. d_IN (h_diff i) x \\<le> value_flow \\<Delta> (h_plus i)", "have finite2: \"(\\<Sum>\\<^sup>+ x. ?diff x) \\<noteq> top\" (is \"?lhs \\<noteq> _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ x.\n       \\<integral>\\<^sup>+y\\<in>X. (h_diff i (x, y) * indicator X x)\n       \\<partial>count_space UNIV) \\<noteq>\n    \\<top>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ x.\n       \\<integral>\\<^sup>+y\\<in>X. (h_diff i (x, y) * indicator X x)\n       \\<partial>count_space UNIV) \\<noteq>\n    \\<top>", "have \"?lhs \\<le> (\\<Sum>\\<^sup>+ x\\<in>UNIV. \\<Sum>\\<^sup>+ y. h_plus i (x, y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ x.\n       \\<integral>\\<^sup>+y\\<in>X. (h_diff i (x, y) * indicator X x)\n       \\<partial>count_space UNIV)\n    \\<le> (\\<Sum>\\<^sup>+ x. \\<Sum>\\<^sup>+ y. h_plus i (x, y))", "by(intro nn_integral_mono)(auto simp add: h_diff_def split: split_indicator)"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ x.\n     \\<integral>\\<^sup>+y\\<in>X. (h_diff i (x, y) * indicator X x)\n     \\<partial>count_space UNIV)\n  \\<le> (\\<Sum>\\<^sup>+ x. \\<Sum>\\<^sup>+ y. h_plus i (x, y))\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ x.\n       \\<integral>\\<^sup>+y\\<in>X. (h_diff i (x, y) * indicator X x)\n       \\<partial>count_space UNIV) \\<noteq>\n    \\<top>", "also"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ x.\n     \\<integral>\\<^sup>+y\\<in>X. (h_diff i (x, y) * indicator X x)\n     \\<partial>count_space UNIV)\n  \\<le> (\\<Sum>\\<^sup>+ x. \\<Sum>\\<^sup>+ y. h_plus i (x, y))\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ x.\n       \\<integral>\\<^sup>+y\\<in>X. (h_diff i (x, y) * indicator X x)\n       \\<partial>count_space UNIV) \\<noteq>\n    \\<top>", "have \"\\<dots> = (\\<Sum>\\<^sup>+ e. h_plus i e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ x. \\<Sum>\\<^sup>+ y. h_plus i (x, y)) =\n    integral\\<^sup>N (count_space UNIV) (h_plus i)", "by(rule nn_integral_fst_count_space)"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ x. \\<Sum>\\<^sup>+ y. h_plus i (x, y)) =\n  integral\\<^sup>N (count_space UNIV) (h_plus i)\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ x.\n       \\<integral>\\<^sup>+y\\<in>X. (h_diff i (x, y) * indicator X x)\n       \\<partial>count_space UNIV) \\<noteq>\n    \\<top>", "also"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ x. \\<Sum>\\<^sup>+ y. h_plus i (x, y)) =\n  integral\\<^sup>N (count_space UNIV) (h_plus i)\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ x.\n       \\<integral>\\<^sup>+y\\<in>X. (h_diff i (x, y) * indicator X x)\n       \\<partial>count_space UNIV) \\<noteq>\n    \\<top>", "have \"\\<dots> < \\<top>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. integral\\<^sup>N (count_space UNIV) (h_plus i) < \\<top>", "by(simp add: h_plus_sum_finite less_top[symmetric])"], ["proof (state)\nthis:\n  integral\\<^sup>N (count_space UNIV) (h_plus i) < \\<top>\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ x.\n       \\<integral>\\<^sup>+y\\<in>X. (h_diff i (x, y) * indicator X x)\n       \\<partial>count_space UNIV) \\<noteq>\n    \\<top>", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>\\<^sup>+ x.\n     \\<integral>\\<^sup>+y\\<in>X. (h_diff i (x, y) * indicator X x)\n     \\<partial>count_space UNIV)\n  < \\<top>", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<Sum>\\<^sup>+ x.\n     \\<integral>\\<^sup>+y\\<in>X. (h_diff i (x, y) * indicator X x)\n     \\<partial>count_space UNIV)\n  < \\<top>\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ x.\n       \\<integral>\\<^sup>+y\\<in>X. (h_diff i (x, y) * indicator X x)\n       \\<partial>count_space UNIV) \\<noteq>\n    \\<top>", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ x.\n     \\<integral>\\<^sup>+y\\<in>X. (h_diff i (x, y) * indicator X x)\n     \\<partial>count_space UNIV) \\<noteq>\n  \\<top>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ x.\n     \\<integral>\\<^sup>+y\\<in>X. (h_diff i (x, y) * indicator X x)\n     \\<partial>count_space UNIV) \\<noteq>\n  \\<top>\n\ngoal (1 subgoal):\n 1. d_IN (h_diff i) x \\<le> value_flow \\<Delta> (h_plus i)", "have finite1: \"?diff x \\<noteq> top\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+y\\<in>X. (h_diff i (x, y) * indicator X x)\n    \\<partial>count_space UNIV \\<noteq>\n    \\<top>", "using finite2"], ["proof (prove)\nusing this:\n  (\\<Sum>\\<^sup>+ x.\n     \\<integral>\\<^sup>+y\\<in>X. (h_diff i (x, y) * indicator X x)\n     \\<partial>count_space UNIV) \\<noteq>\n  \\<top>\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+y\\<in>X. (h_diff i (x, y) * indicator X x)\n    \\<partial>count_space UNIV \\<noteq>\n    \\<top>", "by(rule neq_top_trans)(rule nn_integral_ge_point, simp)"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+y\\<in>X. (h_diff i (?x, y) * indicator X ?x)\n  \\<partial>count_space UNIV \\<noteq>\n  \\<top>\n\ngoal (1 subgoal):\n 1. d_IN (h_diff i) x \\<le> value_flow \\<Delta> (h_plus i)", "have finite3: \"(\\<Sum>\\<^sup>+ x. d_OUT (h_diff i) x * indicator (X - {source \\<Delta>}) x) \\<noteq> \\<top>\" (is \"?lhs \\<noteq> _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. set_nn_integral (count_space UNIV) (X - {source \\<Delta>})\n     (d_OUT (h_diff i)) \\<noteq>\n    \\<top>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. set_nn_integral (count_space UNIV) (X - {source \\<Delta>})\n     (d_OUT (h_diff i)) \\<noteq>\n    \\<top>", "have \"?lhs \\<le> (\\<Sum>\\<^sup>+ x\\<in>UNIV. \\<Sum>\\<^sup>+ y. h_plus i (x, y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_nn_integral (count_space UNIV) (X - {source \\<Delta>})\n     (d_OUT (h_diff i))\n    \\<le> (\\<Sum>\\<^sup>+ x. \\<Sum>\\<^sup>+ y. h_plus i (x, y))", "unfolding d_OUT_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+x\\<in>X - {source \\<Delta>}.\n                       (\\<Sum>\\<^sup>+ y. h_diff i (x, y))\n    \\<partial>count_space UNIV\n    \\<le> (\\<Sum>\\<^sup>+ x. \\<Sum>\\<^sup>+ y. h_plus i (x, y))", "apply(simp add: nn_integral_multc[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ x.\n       \\<Sum>\\<^sup>+ xa.\n         h_diff i (x, xa) * indicator (X - {source \\<Delta>}) x)\n    \\<le> (\\<Sum>\\<^sup>+ x. \\<Sum>\\<^sup>+ y. h_plus i (x, y))", "apply(intro nn_integral_mono)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>x \\<in> space (count_space UNIV);\n        xa \\<in> space (count_space UNIV)\\<rbrakk>\n       \\<Longrightarrow> h_diff i (x, xa) *\n                         indicator (X - {source \\<Delta>}) x\n                         \\<le> h_plus i (x, xa)", "apply(auto simp add: h_diff_def split: split_indicator)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  set_nn_integral (count_space UNIV) (X - {source \\<Delta>})\n   (d_OUT (h_diff i))\n  \\<le> (\\<Sum>\\<^sup>+ x. \\<Sum>\\<^sup>+ y. h_plus i (x, y))\n\ngoal (1 subgoal):\n 1. set_nn_integral (count_space UNIV) (X - {source \\<Delta>})\n     (d_OUT (h_diff i)) \\<noteq>\n    \\<top>", "also"], ["proof (state)\nthis:\n  set_nn_integral (count_space UNIV) (X - {source \\<Delta>})\n   (d_OUT (h_diff i))\n  \\<le> (\\<Sum>\\<^sup>+ x. \\<Sum>\\<^sup>+ y. h_plus i (x, y))\n\ngoal (1 subgoal):\n 1. set_nn_integral (count_space UNIV) (X - {source \\<Delta>})\n     (d_OUT (h_diff i)) \\<noteq>\n    \\<top>", "have \"\\<dots> = (\\<Sum>\\<^sup>+ e. h_plus i e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ x. \\<Sum>\\<^sup>+ y. h_plus i (x, y)) =\n    integral\\<^sup>N (count_space UNIV) (h_plus i)", "by(rule nn_integral_fst_count_space)"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ x. \\<Sum>\\<^sup>+ y. h_plus i (x, y)) =\n  integral\\<^sup>N (count_space UNIV) (h_plus i)\n\ngoal (1 subgoal):\n 1. set_nn_integral (count_space UNIV) (X - {source \\<Delta>})\n     (d_OUT (h_diff i)) \\<noteq>\n    \\<top>", "also"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ x. \\<Sum>\\<^sup>+ y. h_plus i (x, y)) =\n  integral\\<^sup>N (count_space UNIV) (h_plus i)\n\ngoal (1 subgoal):\n 1. set_nn_integral (count_space UNIV) (X - {source \\<Delta>})\n     (d_OUT (h_diff i)) \\<noteq>\n    \\<top>", "have \"\\<dots> < \\<top>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. integral\\<^sup>N (count_space UNIV) (h_plus i) < \\<top>", "by(simp add: h_plus_sum_finite less_top[symmetric])"], ["proof (state)\nthis:\n  integral\\<^sup>N (count_space UNIV) (h_plus i) < \\<top>\n\ngoal (1 subgoal):\n 1. set_nn_integral (count_space UNIV) (X - {source \\<Delta>})\n     (d_OUT (h_diff i)) \\<noteq>\n    \\<top>", "finally"], ["proof (chain)\npicking this:\n  set_nn_integral (count_space UNIV) (X - {source \\<Delta>})\n   (d_OUT (h_diff i))\n  < \\<top>", "show ?thesis"], ["proof (prove)\nusing this:\n  set_nn_integral (count_space UNIV) (X - {source \\<Delta>})\n   (d_OUT (h_diff i))\n  < \\<top>\n\ngoal (1 subgoal):\n 1. set_nn_integral (count_space UNIV) (X - {source \\<Delta>})\n     (d_OUT (h_diff i)) \\<noteq>\n    \\<top>", "by simp"], ["proof (state)\nthis:\n  set_nn_integral (count_space UNIV) (X - {source \\<Delta>})\n   (d_OUT (h_diff i)) \\<noteq>\n  \\<top>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  set_nn_integral (count_space UNIV) (X - {source \\<Delta>})\n   (d_OUT (h_diff i)) \\<noteq>\n  \\<top>\n\ngoal (1 subgoal):\n 1. d_IN (h_diff i) x \\<le> value_flow \\<Delta> (h_plus i)", "have \"d_IN (h_diff i) x = (\\<Sum>\\<^sup>+ y. h_diff i (y, x) * indicator X y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN (h_diff i) x =\n    \\<integral>\\<^sup>+y\\<in>X. h_diff i (y, x)\\<partial>count_space UNIV", "unfolding d_IN_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ xa. h_diff i (xa, x)) =\n    \\<integral>\\<^sup>+y\\<in>X. h_diff i (y, x)\\<partial>count_space UNIV", "by(rule nn_integral_cong)(simp add: in_X split: split_indicator)"], ["proof (state)\nthis:\n  d_IN (h_diff i) x =\n  \\<integral>\\<^sup>+y\\<in>X. h_diff i (y, x)\\<partial>count_space UNIV\n\ngoal (1 subgoal):\n 1. d_IN (h_diff i) x \\<le> value_flow \\<Delta> (h_plus i)", "also"], ["proof (state)\nthis:\n  d_IN (h_diff i) x =\n  \\<integral>\\<^sup>+y\\<in>X. h_diff i (y, x)\\<partial>count_space UNIV\n\ngoal (1 subgoal):\n 1. d_IN (h_diff i) x \\<le> value_flow \\<Delta> (h_plus i)", "have \"\\<dots> \\<le> (\\<Sum>\\<^sup>+ x\\<in>- X. \\<Sum>\\<^sup>+ y. h_diff i (y, x) * indicator X y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+y\\<in>X. h_diff i (y, x)\\<partial>count_space UNIV\n    \\<le> (\\<Sum>\\<^sup>+ x\\<in>- X.\n             \\<integral>\\<^sup>+y\\<in>X. h_diff i (y, x)\n             \\<partial>count_space UNIV)", "by(rule nn_integral_ge_point)(simp add: X_def)"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+y\\<in>X. h_diff i (y, x)\\<partial>count_space UNIV\n  \\<le> (\\<Sum>\\<^sup>+ x\\<in>- X.\n           \\<integral>\\<^sup>+y\\<in>X. h_diff i (y, x)\n           \\<partial>count_space UNIV)\n\ngoal (1 subgoal):\n 1. d_IN (h_diff i) x \\<le> value_flow \\<Delta> (h_plus i)", "also"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+y\\<in>X. h_diff i (y, x)\\<partial>count_space UNIV\n  \\<le> (\\<Sum>\\<^sup>+ x\\<in>- X.\n           \\<integral>\\<^sup>+y\\<in>X. h_diff i (y, x)\n           \\<partial>count_space UNIV)\n\ngoal (1 subgoal):\n 1. d_IN (h_diff i) x \\<le> value_flow \\<Delta> (h_plus i)", "have \"\\<dots> = (\\<Sum>\\<^sup>+ x\\<in>UNIV. \\<Sum>\\<^sup>+ y. h_diff i (y, x) * indicator X y * indicator (- X) x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ x\\<in>- X.\n       \\<integral>\\<^sup>+y\\<in>X. h_diff i (y, x)\n       \\<partial>count_space UNIV) =\n    (\\<Sum>\\<^sup>+ x.\n       \\<Sum>\\<^sup>+ y.\n         h_diff i (y, x) * indicator X y * indicator (- X) x)", "by(simp add: nn_integral_multc nn_integral_count_space_indicator)"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ x\\<in>- X.\n     \\<integral>\\<^sup>+y\\<in>X. h_diff i (y, x)\n     \\<partial>count_space UNIV) =\n  (\\<Sum>\\<^sup>+ x.\n     \\<Sum>\\<^sup>+ y. h_diff i (y, x) * indicator X y * indicator (- X) x)\n\ngoal (1 subgoal):\n 1. d_IN (h_diff i) x \\<le> value_flow \\<Delta> (h_plus i)", "also"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ x\\<in>- X.\n     \\<integral>\\<^sup>+y\\<in>X. h_diff i (y, x)\n     \\<partial>count_space UNIV) =\n  (\\<Sum>\\<^sup>+ x.\n     \\<Sum>\\<^sup>+ y. h_diff i (y, x) * indicator X y * indicator (- X) x)\n\ngoal (1 subgoal):\n 1. d_IN (h_diff i) x \\<le> value_flow \\<Delta> (h_plus i)", "have \"\\<dots> = (\\<Sum>\\<^sup>+ x\\<in>UNIV. \\<Sum>\\<^sup>+ y. h_diff i (x, y) * indicator X x * indicator (- X) y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ x.\n       \\<Sum>\\<^sup>+ y.\n         h_diff i (y, x) * indicator X y * indicator (- X) x) =\n    (\\<Sum>\\<^sup>+ x.\n       \\<integral>\\<^sup>+y\\<in>- X. (h_diff i (x, y) * indicator X x)\n       \\<partial>count_space UNIV)", "by(subst nn_integral_snd_count_space[where f=\"case_prod _\", simplified])(simp add: nn_integral_fst_count_space[where f=\"case_prod _\", simplified])"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ x.\n     \\<Sum>\\<^sup>+ y.\n       h_diff i (y, x) * indicator X y * indicator (- X) x) =\n  (\\<Sum>\\<^sup>+ x.\n     \\<integral>\\<^sup>+y\\<in>- X. (h_diff i (x, y) * indicator X x)\n     \\<partial>count_space UNIV)\n\ngoal (1 subgoal):\n 1. d_IN (h_diff i) x \\<le> value_flow \\<Delta> (h_plus i)", "also"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ x.\n     \\<Sum>\\<^sup>+ y.\n       h_diff i (y, x) * indicator X y * indicator (- X) x) =\n  (\\<Sum>\\<^sup>+ x.\n     \\<integral>\\<^sup>+y\\<in>- X. (h_diff i (x, y) * indicator X x)\n     \\<partial>count_space UNIV)\n\ngoal (1 subgoal):\n 1. d_IN (h_diff i) x \\<le> value_flow \\<Delta> (h_plus i)", "have \"\\<dots> = (\\<Sum>\\<^sup>+ x\\<in>UNIV. (\\<Sum>\\<^sup>+ y. h_diff i (x, y) * indicator X x * indicator (- X) y) + (?diff x - ?diff x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ x.\n       \\<integral>\\<^sup>+y\\<in>- X. (h_diff i (x, y) * indicator X x)\n       \\<partial>count_space UNIV) =\n    (\\<Sum>\\<^sup>+ x.\n       (\\<integral>\\<^sup>+y\\<in>- X. (h_diff i (x, y) * indicator X x)\n        \\<partial>count_space UNIV) +\n       ((\\<integral>\\<^sup>+y\\<in>X. (h_diff i (x, y) * indicator X x)\n         \\<partial>count_space UNIV) -\n        (\\<integral>\\<^sup>+y\\<in>X. (h_diff i (x, y) * indicator X x)\n         \\<partial>count_space UNIV)))", "by(simp add: finite1)"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ x.\n     \\<integral>\\<^sup>+y\\<in>- X. (h_diff i (x, y) * indicator X x)\n     \\<partial>count_space UNIV) =\n  (\\<Sum>\\<^sup>+ x.\n     (\\<integral>\\<^sup>+y\\<in>- X. (h_diff i (x, y) * indicator X x)\n      \\<partial>count_space UNIV) +\n     ((\\<integral>\\<^sup>+y\\<in>X. (h_diff i (x, y) * indicator X x)\n       \\<partial>count_space UNIV) -\n      (\\<integral>\\<^sup>+y\\<in>X. (h_diff i (x, y) * indicator X x)\n       \\<partial>count_space UNIV)))\n\ngoal (1 subgoal):\n 1. d_IN (h_diff i) x \\<le> value_flow \\<Delta> (h_plus i)", "also"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ x.\n     \\<integral>\\<^sup>+y\\<in>- X. (h_diff i (x, y) * indicator X x)\n     \\<partial>count_space UNIV) =\n  (\\<Sum>\\<^sup>+ x.\n     (\\<integral>\\<^sup>+y\\<in>- X. (h_diff i (x, y) * indicator X x)\n      \\<partial>count_space UNIV) +\n     ((\\<integral>\\<^sup>+y\\<in>X. (h_diff i (x, y) * indicator X x)\n       \\<partial>count_space UNIV) -\n      (\\<integral>\\<^sup>+y\\<in>X. (h_diff i (x, y) * indicator X x)\n       \\<partial>count_space UNIV)))\n\ngoal (1 subgoal):\n 1. d_IN (h_diff i) x \\<le> value_flow \\<Delta> (h_plus i)", "have \"\\<dots> = (\\<Sum>\\<^sup>+ x\\<in>UNIV. (\\<Sum>\\<^sup>+ y. h_diff i (x, y) * indicator X x * indicator (- X) y + h_diff i (x, y) * indicator X x * indicator X y) - ?diff x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ x.\n       (\\<integral>\\<^sup>+y\\<in>- X. (h_diff i (x, y) * indicator X x)\n        \\<partial>count_space UNIV) +\n       ((\\<integral>\\<^sup>+y\\<in>X. (h_diff i (x, y) * indicator X x)\n         \\<partial>count_space UNIV) -\n        (\\<integral>\\<^sup>+y\\<in>X. (h_diff i (x, y) * indicator X x)\n         \\<partial>count_space UNIV))) =\n    (\\<Sum>\\<^sup>+ x.\n       (\\<Sum>\\<^sup>+ y.\n          h_diff i (x, y) * indicator X x * indicator (- X) y +\n          h_diff i (x, y) * indicator X x * indicator X y) -\n       (\\<integral>\\<^sup>+y\\<in>X. (h_diff i (x, y) * indicator X x)\n        \\<partial>count_space UNIV))", "apply (subst add_diff_eq_ennreal)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       \\<integral>\\<^sup>+y\\<in>X. (h_diff i (xa, y) * indicator X xa)\n       \\<partial>count_space UNIV\n       \\<le> \\<integral>\\<^sup>+y\\<in>X. (h_diff i (xa, y) * indicator X xa)\n             \\<partial>count_space UNIV\n 2. (\\<Sum>\\<^sup>+ x.\n       (\\<integral>\\<^sup>+y\\<in>- X. (h_diff i (x, y) * indicator X x)\n        \\<partial>count_space UNIV) +\n       (\\<integral>\\<^sup>+y\\<in>X. (h_diff i (x, y) * indicator X x)\n        \\<partial>count_space UNIV) -\n       (\\<integral>\\<^sup>+y\\<in>X. (h_diff i (x, y) * indicator X x)\n        \\<partial>count_space UNIV)) =\n    (\\<Sum>\\<^sup>+ x.\n       (\\<Sum>\\<^sup>+ y.\n          h_diff i (x, y) * indicator X x * indicator (- X) y +\n          h_diff i (x, y) * indicator X x * indicator X y) -\n       (\\<integral>\\<^sup>+y\\<in>X. (h_diff i (x, y) * indicator X x)\n        \\<partial>count_space UNIV))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ x.\n       (\\<integral>\\<^sup>+y\\<in>- X. (h_diff i (x, y) * indicator X x)\n        \\<partial>count_space UNIV) +\n       (\\<integral>\\<^sup>+y\\<in>X. (h_diff i (x, y) * indicator X x)\n        \\<partial>count_space UNIV) -\n       (\\<integral>\\<^sup>+y\\<in>X. (h_diff i (x, y) * indicator X x)\n        \\<partial>count_space UNIV)) =\n    (\\<Sum>\\<^sup>+ x.\n       (\\<Sum>\\<^sup>+ y.\n          h_diff i (x, y) * indicator X x * indicator (- X) y +\n          h_diff i (x, y) * indicator X x * indicator X y) -\n       (\\<integral>\\<^sup>+y\\<in>X. (h_diff i (x, y) * indicator X x)\n        \\<partial>count_space UNIV))", "by(subst nn_integral_add[symmetric])(simp_all add:)"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ x.\n     (\\<integral>\\<^sup>+y\\<in>- X. (h_diff i (x, y) * indicator X x)\n      \\<partial>count_space UNIV) +\n     ((\\<integral>\\<^sup>+y\\<in>X. (h_diff i (x, y) * indicator X x)\n       \\<partial>count_space UNIV) -\n      (\\<integral>\\<^sup>+y\\<in>X. (h_diff i (x, y) * indicator X x)\n       \\<partial>count_space UNIV))) =\n  (\\<Sum>\\<^sup>+ x.\n     (\\<Sum>\\<^sup>+ y.\n        h_diff i (x, y) * indicator X x * indicator (- X) y +\n        h_diff i (x, y) * indicator X x * indicator X y) -\n     (\\<integral>\\<^sup>+y\\<in>X. (h_diff i (x, y) * indicator X x)\n      \\<partial>count_space UNIV))\n\ngoal (1 subgoal):\n 1. d_IN (h_diff i) x \\<le> value_flow \\<Delta> (h_plus i)", "also"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ x.\n     (\\<integral>\\<^sup>+y\\<in>- X. (h_diff i (x, y) * indicator X x)\n      \\<partial>count_space UNIV) +\n     ((\\<integral>\\<^sup>+y\\<in>X. (h_diff i (x, y) * indicator X x)\n       \\<partial>count_space UNIV) -\n      (\\<integral>\\<^sup>+y\\<in>X. (h_diff i (x, y) * indicator X x)\n       \\<partial>count_space UNIV))) =\n  (\\<Sum>\\<^sup>+ x.\n     (\\<Sum>\\<^sup>+ y.\n        h_diff i (x, y) * indicator X x * indicator (- X) y +\n        h_diff i (x, y) * indicator X x * indicator X y) -\n     (\\<integral>\\<^sup>+y\\<in>X. (h_diff i (x, y) * indicator X x)\n      \\<partial>count_space UNIV))\n\ngoal (1 subgoal):\n 1. d_IN (h_diff i) x \\<le> value_flow \\<Delta> (h_plus i)", "have \"\\<dots> = (\\<Sum>\\<^sup>+ x\\<in>UNIV. (\\<Sum>\\<^sup>+ y. h_diff i (x, y) * indicator X x) - ?diff x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ x.\n       (\\<Sum>\\<^sup>+ y.\n          h_diff i (x, y) * indicator X x * indicator (- X) y +\n          h_diff i (x, y) * indicator X x * indicator X y) -\n       (\\<integral>\\<^sup>+y\\<in>X. (h_diff i (x, y) * indicator X x)\n        \\<partial>count_space UNIV)) =\n    (\\<Sum>\\<^sup>+ x.\n       (\\<Sum>\\<^sup>+ y. h_diff i (x, y) * indicator X x) -\n       (\\<integral>\\<^sup>+y\\<in>X. (h_diff i (x, y) * indicator X x)\n        \\<partial>count_space UNIV))", "by(auto intro!: nn_integral_cong arg_cong2[where f=\"(-)\"] split: split_indicator)"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ x.\n     (\\<Sum>\\<^sup>+ y.\n        h_diff i (x, y) * indicator X x * indicator (- X) y +\n        h_diff i (x, y) * indicator X x * indicator X y) -\n     (\\<integral>\\<^sup>+y\\<in>X. (h_diff i (x, y) * indicator X x)\n      \\<partial>count_space UNIV)) =\n  (\\<Sum>\\<^sup>+ x.\n     (\\<Sum>\\<^sup>+ y. h_diff i (x, y) * indicator X x) -\n     (\\<integral>\\<^sup>+y\\<in>X. (h_diff i (x, y) * indicator X x)\n      \\<partial>count_space UNIV))\n\ngoal (1 subgoal):\n 1. d_IN (h_diff i) x \\<le> value_flow \\<Delta> (h_plus i)", "also"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ x.\n     (\\<Sum>\\<^sup>+ y.\n        h_diff i (x, y) * indicator X x * indicator (- X) y +\n        h_diff i (x, y) * indicator X x * indicator X y) -\n     (\\<integral>\\<^sup>+y\\<in>X. (h_diff i (x, y) * indicator X x)\n      \\<partial>count_space UNIV)) =\n  (\\<Sum>\\<^sup>+ x.\n     (\\<Sum>\\<^sup>+ y. h_diff i (x, y) * indicator X x) -\n     (\\<integral>\\<^sup>+y\\<in>X. (h_diff i (x, y) * indicator X x)\n      \\<partial>count_space UNIV))\n\ngoal (1 subgoal):\n 1. d_IN (h_diff i) x \\<le> value_flow \\<Delta> (h_plus i)", "have \"\\<dots> = (\\<Sum>\\<^sup>+ x\\<in>UNIV. \\<Sum>\\<^sup>+ y\\<in>UNIV. h_diff i (x, y) * indicator X x) - (\\<Sum>\\<^sup>+ x. ?diff x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ x.\n       (\\<Sum>\\<^sup>+ y. h_diff i (x, y) * indicator X x) -\n       (\\<integral>\\<^sup>+y\\<in>X. (h_diff i (x, y) * indicator X x)\n        \\<partial>count_space UNIV)) =\n    (\\<Sum>\\<^sup>+ x. \\<Sum>\\<^sup>+ y. h_diff i (x, y) * indicator X x) -\n    (\\<Sum>\\<^sup>+ x.\n       \\<integral>\\<^sup>+y\\<in>X. (h_diff i (x, y) * indicator X x)\n       \\<partial>count_space UNIV)", "by(subst nn_integral_diff)(auto simp add: AE_count_space finite2 intro!: nn_integral_mono split: split_indicator)"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ x.\n     (\\<Sum>\\<^sup>+ y. h_diff i (x, y) * indicator X x) -\n     (\\<integral>\\<^sup>+y\\<in>X. (h_diff i (x, y) * indicator X x)\n      \\<partial>count_space UNIV)) =\n  (\\<Sum>\\<^sup>+ x. \\<Sum>\\<^sup>+ y. h_diff i (x, y) * indicator X x) -\n  (\\<Sum>\\<^sup>+ x.\n     \\<integral>\\<^sup>+y\\<in>X. (h_diff i (x, y) * indicator X x)\n     \\<partial>count_space UNIV)\n\ngoal (1 subgoal):\n 1. d_IN (h_diff i) x \\<le> value_flow \\<Delta> (h_plus i)", "also"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ x.\n     (\\<Sum>\\<^sup>+ y. h_diff i (x, y) * indicator X x) -\n     (\\<integral>\\<^sup>+y\\<in>X. (h_diff i (x, y) * indicator X x)\n      \\<partial>count_space UNIV)) =\n  (\\<Sum>\\<^sup>+ x. \\<Sum>\\<^sup>+ y. h_diff i (x, y) * indicator X x) -\n  (\\<Sum>\\<^sup>+ x.\n     \\<integral>\\<^sup>+y\\<in>X. (h_diff i (x, y) * indicator X x)\n     \\<partial>count_space UNIV)\n\ngoal (1 subgoal):\n 1. d_IN (h_diff i) x \\<le> value_flow \\<Delta> (h_plus i)", "have \"(\\<Sum>\\<^sup>+ x\\<in>UNIV. \\<Sum>\\<^sup>+ y\\<in>UNIV. h_diff i (x, y) * indicator X x) = (\\<Sum>\\<^sup>+ x. d_OUT (h_diff i) x * indicator X x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ x. \\<Sum>\\<^sup>+ y. h_diff i (x, y) * indicator X x) =\n    set_nn_integral (count_space UNIV) X (d_OUT (h_diff i))", "unfolding d_OUT_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ x. \\<Sum>\\<^sup>+ y. h_diff i (x, y) * indicator X x) =\n    \\<integral>\\<^sup>+x\\<in>X. (\\<Sum>\\<^sup>+ y. h_diff i (x, y))\n    \\<partial>count_space UNIV", "by(simp add: nn_integral_multc)"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ x. \\<Sum>\\<^sup>+ y. h_diff i (x, y) * indicator X x) =\n  set_nn_integral (count_space UNIV) X (d_OUT (h_diff i))\n\ngoal (1 subgoal):\n 1. d_IN (h_diff i) x \\<le> value_flow \\<Delta> (h_plus i)", "also"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ x. \\<Sum>\\<^sup>+ y. h_diff i (x, y) * indicator X x) =\n  set_nn_integral (count_space UNIV) X (d_OUT (h_diff i))\n\ngoal (1 subgoal):\n 1. d_IN (h_diff i) x \\<le> value_flow \\<Delta> (h_plus i)", "have \"\\<dots> = (\\<Sum>\\<^sup>+ x. d_OUT (h_diff i) x * indicator (X - {source \\<Delta>}) x + value_flow \\<Delta> (h_diff i) * indicator X (source \\<Delta>) * indicator {source \\<Delta>} x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_nn_integral (count_space UNIV) X (d_OUT (h_diff i)) =\n    (\\<Sum>\\<^sup>+ x.\n       d_OUT (h_diff i) x * indicator (X - {source \\<Delta>}) x +\n       value_flow \\<Delta> (h_diff i) * indicator X (source \\<Delta>) *\n       indicator {source \\<Delta>} x)", "by(rule nn_integral_cong)(simp split: split_indicator)"], ["proof (state)\nthis:\n  set_nn_integral (count_space UNIV) X (d_OUT (h_diff i)) =\n  (\\<Sum>\\<^sup>+ x.\n     d_OUT (h_diff i) x * indicator (X - {source \\<Delta>}) x +\n     value_flow \\<Delta> (h_diff i) * indicator X (source \\<Delta>) *\n     indicator {source \\<Delta>} x)\n\ngoal (1 subgoal):\n 1. d_IN (h_diff i) x \\<le> value_flow \\<Delta> (h_plus i)", "also"], ["proof (state)\nthis:\n  set_nn_integral (count_space UNIV) X (d_OUT (h_diff i)) =\n  (\\<Sum>\\<^sup>+ x.\n     d_OUT (h_diff i) x * indicator (X - {source \\<Delta>}) x +\n     value_flow \\<Delta> (h_diff i) * indicator X (source \\<Delta>) *\n     indicator {source \\<Delta>} x)\n\ngoal (1 subgoal):\n 1. d_IN (h_diff i) x \\<le> value_flow \\<Delta> (h_plus i)", "have \"\\<dots> = (\\<Sum>\\<^sup>+ x. d_OUT (h_diff i) x * indicator (X - {source \\<Delta>}) x) + value_flow \\<Delta> (h_diff i) * indicator X (source \\<Delta>)\"\n    (is \"_ = ?out\" is \"_ = _ + ?value\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ x.\n       d_OUT (h_diff i) x * indicator (X - {source \\<Delta>}) x +\n       value_flow \\<Delta> (h_diff i) * indicator X (source \\<Delta>) *\n       indicator {source \\<Delta>} x) =\n    set_nn_integral (count_space UNIV) (X - {source \\<Delta>})\n     (d_OUT (h_diff i)) +\n    value_flow \\<Delta> (h_diff i) * indicator X (source \\<Delta>)", "by(subst nn_integral_add) simp_all"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ x.\n     d_OUT (h_diff i) x * indicator (X - {source \\<Delta>}) x +\n     value_flow \\<Delta> (h_diff i) * indicator X (source \\<Delta>) *\n     indicator {source \\<Delta>} x) =\n  set_nn_integral (count_space UNIV) (X - {source \\<Delta>})\n   (d_OUT (h_diff i)) +\n  value_flow \\<Delta> (h_diff i) * indicator X (source \\<Delta>)\n\ngoal (1 subgoal):\n 1. d_IN (h_diff i) x \\<le> value_flow \\<Delta> (h_plus i)", "also"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ x.\n     d_OUT (h_diff i) x * indicator (X - {source \\<Delta>}) x +\n     value_flow \\<Delta> (h_diff i) * indicator X (source \\<Delta>) *\n     indicator {source \\<Delta>} x) =\n  set_nn_integral (count_space UNIV) (X - {source \\<Delta>})\n   (d_OUT (h_diff i)) +\n  value_flow \\<Delta> (h_diff i) * indicator X (source \\<Delta>)\n\ngoal (1 subgoal):\n 1. d_IN (h_diff i) x \\<le> value_flow \\<Delta> (h_plus i)", "have \"(\\<Sum>\\<^sup>+ x\\<in>UNIV. \\<Sum>\\<^sup>+ y. h_diff i (x, y) * indicator X x * indicator X y) =\n             (\\<Sum>\\<^sup>+ x\\<in>UNIV. \\<Sum>\\<^sup>+ y. h_diff i (x, y) * indicator X y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ x.\n       \\<integral>\\<^sup>+y\\<in>X. (h_diff i (x, y) * indicator X x)\n       \\<partial>count_space UNIV) =\n    (\\<Sum>\\<^sup>+ x.\n       \\<integral>\\<^sup>+y\\<in>X. h_diff i (x, y)\n       \\<partial>count_space UNIV)", "using acyclic"], ["proof (prove)\nusing this:\n  \\<lbrakk>?xa2 \\<notin> X; ?y2 \\<in> X\\<rbrakk>\n  \\<Longrightarrow> h_diff i (?xa2, ?y2) = 0\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ x.\n       \\<integral>\\<^sup>+y\\<in>X. (h_diff i (x, y) * indicator X x)\n       \\<partial>count_space UNIV) =\n    (\\<Sum>\\<^sup>+ x.\n       \\<integral>\\<^sup>+y\\<in>X. h_diff i (x, y)\n       \\<partial>count_space UNIV)", "by(intro nn_integral_cong)(simp split: split_indicator)"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ x.\n     \\<integral>\\<^sup>+y\\<in>X. (h_diff i (x, y) * indicator X x)\n     \\<partial>count_space UNIV) =\n  (\\<Sum>\\<^sup>+ x.\n     \\<integral>\\<^sup>+y\\<in>X. h_diff i (x, y)\\<partial>count_space UNIV)\n\ngoal (1 subgoal):\n 1. d_IN (h_diff i) x \\<le> value_flow \\<Delta> (h_plus i)", "also"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ x.\n     \\<integral>\\<^sup>+y\\<in>X. (h_diff i (x, y) * indicator X x)\n     \\<partial>count_space UNIV) =\n  (\\<Sum>\\<^sup>+ x.\n     \\<integral>\\<^sup>+y\\<in>X. h_diff i (x, y)\\<partial>count_space UNIV)\n\ngoal (1 subgoal):\n 1. d_IN (h_diff i) x \\<le> value_flow \\<Delta> (h_plus i)", "have \"\\<dots> = (\\<Sum>\\<^sup>+ y\\<in>UNIV. \\<Sum>\\<^sup>+ x. h_diff i (x, y) * indicator X y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ x.\n       \\<integral>\\<^sup>+y\\<in>X. h_diff i (x, y)\n       \\<partial>count_space UNIV) =\n    (\\<Sum>\\<^sup>+ y. \\<Sum>\\<^sup>+ x. h_diff i (x, y) * indicator X y)", "by(subst nn_integral_snd_count_space[where f=\"case_prod _\", simplified])(simp add: nn_integral_fst_count_space[where f=\"case_prod _\", simplified])"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ x.\n     \\<integral>\\<^sup>+y\\<in>X. h_diff i (x, y)\n     \\<partial>count_space UNIV) =\n  (\\<Sum>\\<^sup>+ y. \\<Sum>\\<^sup>+ x. h_diff i (x, y) * indicator X y)\n\ngoal (1 subgoal):\n 1. d_IN (h_diff i) x \\<le> value_flow \\<Delta> (h_plus i)", "also"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ x.\n     \\<integral>\\<^sup>+y\\<in>X. h_diff i (x, y)\n     \\<partial>count_space UNIV) =\n  (\\<Sum>\\<^sup>+ y. \\<Sum>\\<^sup>+ x. h_diff i (x, y) * indicator X y)\n\ngoal (1 subgoal):\n 1. d_IN (h_diff i) x \\<le> value_flow \\<Delta> (h_plus i)", "have \"\\<dots> = (\\<Sum>\\<^sup>+ y. d_IN (h_diff i) y * indicator X y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y. \\<Sum>\\<^sup>+ x. h_diff i (x, y) * indicator X y) =\n    set_nn_integral (count_space UNIV) X (d_IN (h_diff i))", "unfolding d_IN_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y. \\<Sum>\\<^sup>+ x. h_diff i (x, y) * indicator X y) =\n    \\<integral>\\<^sup>+y\\<in>X. (\\<Sum>\\<^sup>+ x. h_diff i (x, y))\n    \\<partial>count_space UNIV", "by(simp add: nn_integral_multc)"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y. \\<Sum>\\<^sup>+ x. h_diff i (x, y) * indicator X y) =\n  set_nn_integral (count_space UNIV) X (d_IN (h_diff i))\n\ngoal (1 subgoal):\n 1. d_IN (h_diff i) x \\<le> value_flow \\<Delta> (h_plus i)", "also"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y. \\<Sum>\\<^sup>+ x. h_diff i (x, y) * indicator X y) =\n  set_nn_integral (count_space UNIV) X (d_IN (h_diff i))\n\ngoal (1 subgoal):\n 1. d_IN (h_diff i) x \\<le> value_flow \\<Delta> (h_plus i)", "have \"\\<dots> = (\\<Sum>\\<^sup>+ y. d_IN (h_diff i) y * indicator (X - {source \\<Delta>}) y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_nn_integral (count_space UNIV) X (d_IN (h_diff i)) =\n    set_nn_integral (count_space UNIV) (X - {source \\<Delta>})\n     (d_IN (h_diff i))", "by(rule nn_integral_cong)(simp split: split_indicator)"], ["proof (state)\nthis:\n  set_nn_integral (count_space UNIV) X (d_IN (h_diff i)) =\n  set_nn_integral (count_space UNIV) (X - {source \\<Delta>})\n   (d_IN (h_diff i))\n\ngoal (1 subgoal):\n 1. d_IN (h_diff i) x \\<le> value_flow \\<Delta> (h_plus i)", "also"], ["proof (state)\nthis:\n  set_nn_integral (count_space UNIV) X (d_IN (h_diff i)) =\n  set_nn_integral (count_space UNIV) (X - {source \\<Delta>})\n   (d_IN (h_diff i))\n\ngoal (1 subgoal):\n 1. d_IN (h_diff i) x \\<le> value_flow \\<Delta> (h_plus i)", "have \"?out - \\<dots> \\<le> (\\<Sum>\\<^sup>+ x. d_OUT (h_diff i) x * indicator (X - {source \\<Delta>}) x) - \\<dots> + ?value\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_nn_integral (count_space UNIV) (X - {source \\<Delta>})\n     (d_OUT (h_diff i)) +\n    value_flow \\<Delta> (h_diff i) * indicator X (source \\<Delta>) -\n    set_nn_integral (count_space UNIV) (X - {source \\<Delta>})\n     (d_IN (h_diff i))\n    \\<le> set_nn_integral (count_space UNIV) (X - {source \\<Delta>})\n           (d_OUT (h_diff i)) -\n          set_nn_integral (count_space UNIV) (X - {source \\<Delta>})\n           (d_IN (h_diff i)) +\n          value_flow \\<Delta> (h_diff i) * indicator X (source \\<Delta>)", "by (auto simp add: add_ac intro!: add_diff_le_ennreal)"], ["proof (state)\nthis:\n  set_nn_integral (count_space UNIV) (X - {source \\<Delta>})\n   (d_OUT (h_diff i)) +\n  value_flow \\<Delta> (h_diff i) * indicator X (source \\<Delta>) -\n  set_nn_integral (count_space UNIV) (X - {source \\<Delta>})\n   (d_IN (h_diff i))\n  \\<le> set_nn_integral (count_space UNIV) (X - {source \\<Delta>})\n         (d_OUT (h_diff i)) -\n        set_nn_integral (count_space UNIV) (X - {source \\<Delta>})\n         (d_IN (h_diff i)) +\n        value_flow \\<Delta> (h_diff i) * indicator X (source \\<Delta>)\n\ngoal (1 subgoal):\n 1. d_IN (h_diff i) x \\<le> value_flow \\<Delta> (h_plus i)", "also"], ["proof (state)\nthis:\n  set_nn_integral (count_space UNIV) (X - {source \\<Delta>})\n   (d_OUT (h_diff i)) +\n  value_flow \\<Delta> (h_diff i) * indicator X (source \\<Delta>) -\n  set_nn_integral (count_space UNIV) (X - {source \\<Delta>})\n   (d_IN (h_diff i))\n  \\<le> set_nn_integral (count_space UNIV) (X - {source \\<Delta>})\n         (d_OUT (h_diff i)) -\n        set_nn_integral (count_space UNIV) (X - {source \\<Delta>})\n         (d_IN (h_diff i)) +\n        value_flow \\<Delta> (h_diff i) * indicator X (source \\<Delta>)\n\ngoal (1 subgoal):\n 1. d_IN (h_diff i) x \\<le> value_flow \\<Delta> (h_plus i)", "have \"\\<dots> \\<le> 0 + ?value\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_nn_integral (count_space UNIV) (X - {source \\<Delta>})\n     (d_OUT (h_diff i)) -\n    set_nn_integral (count_space UNIV) (X - {source \\<Delta>})\n     (d_IN (h_diff i)) +\n    value_flow \\<Delta> (h_diff i) * indicator X (source \\<Delta>)\n    \\<le> 0 + value_flow \\<Delta> (h_diff i) * indicator X (source \\<Delta>)", "using h_diff_OUT_le_IN finite3"], ["proof (prove)\nusing this:\n  ?x \\<noteq> source \\<Delta> \\<Longrightarrow>\n  d_OUT (h_diff ?i) ?x \\<le> d_IN (h_diff ?i) ?x\n  set_nn_integral (count_space UNIV) (X - {source \\<Delta>})\n   (d_OUT (h_diff i)) \\<noteq>\n  \\<top>\n\ngoal (1 subgoal):\n 1. set_nn_integral (count_space UNIV) (X - {source \\<Delta>})\n     (d_OUT (h_diff i)) -\n    set_nn_integral (count_space UNIV) (X - {source \\<Delta>})\n     (d_IN (h_diff i)) +\n    value_flow \\<Delta> (h_diff i) * indicator X (source \\<Delta>)\n    \\<le> 0 + value_flow \\<Delta> (h_diff i) * indicator X (source \\<Delta>)", "by(intro nn_integral_mono add_right_mono)(auto split: split_indicator intro!: diff_eq_0_ennreal nn_integral_mono simp add: less_top)"], ["proof (state)\nthis:\n  set_nn_integral (count_space UNIV) (X - {source \\<Delta>})\n   (d_OUT (h_diff i)) -\n  set_nn_integral (count_space UNIV) (X - {source \\<Delta>})\n   (d_IN (h_diff i)) +\n  value_flow \\<Delta> (h_diff i) * indicator X (source \\<Delta>)\n  \\<le> 0 + value_flow \\<Delta> (h_diff i) * indicator X (source \\<Delta>)\n\ngoal (1 subgoal):\n 1. d_IN (h_diff i) x \\<le> value_flow \\<Delta> (h_plus i)", "also"], ["proof (state)\nthis:\n  set_nn_integral (count_space UNIV) (X - {source \\<Delta>})\n   (d_OUT (h_diff i)) -\n  set_nn_integral (count_space UNIV) (X - {source \\<Delta>})\n   (d_IN (h_diff i)) +\n  value_flow \\<Delta> (h_diff i) * indicator X (source \\<Delta>)\n  \\<le> 0 + value_flow \\<Delta> (h_diff i) * indicator X (source \\<Delta>)\n\ngoal (1 subgoal):\n 1. d_IN (h_diff i) x \\<le> value_flow \\<Delta> (h_plus i)", "have \"\\<dots> \\<le> value_flow \\<Delta> (h_diff i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 + value_flow \\<Delta> (h_diff i) * indicator X (source \\<Delta>)\n    \\<le> value_flow \\<Delta> (h_diff i)", "by(simp split: split_indicator)"], ["proof (state)\nthis:\n  0 + value_flow \\<Delta> (h_diff i) * indicator X (source \\<Delta>)\n  \\<le> value_flow \\<Delta> (h_diff i)\n\ngoal (1 subgoal):\n 1. d_IN (h_diff i) x \\<le> value_flow \\<Delta> (h_plus i)", "also"], ["proof (state)\nthis:\n  0 + value_flow \\<Delta> (h_diff i) * indicator X (source \\<Delta>)\n  \\<le> value_flow \\<Delta> (h_diff i)\n\ngoal (1 subgoal):\n 1. d_IN (h_diff i) x \\<le> value_flow \\<Delta> (h_plus i)", "have \"\\<dots> \\<le> value_flow \\<Delta> (h_plus i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. value_flow \\<Delta> (h_diff i) \\<le> value_flow \\<Delta> (h_plus i)", "by(rule d_OUT_mono le_funI h_diff_le_h_plus)+"], ["proof (state)\nthis:\n  value_flow \\<Delta> (h_diff i) \\<le> value_flow \\<Delta> (h_plus i)\n\ngoal (1 subgoal):\n 1. d_IN (h_diff i) x \\<le> value_flow \\<Delta> (h_plus i)", "finally"], ["proof (chain)\npicking this:\n  d_IN (h_diff i) x \\<le> value_flow \\<Delta> (h_plus i)", "show ?thesis"], ["proof (prove)\nusing this:\n  d_IN (h_diff i) x \\<le> value_flow \\<Delta> (h_plus i)\n\ngoal (1 subgoal):\n 1. d_IN (h_diff i) x \\<le> value_flow \\<Delta> (h_plus i)", "."], ["proof (state)\nthis:\n  d_IN (h_diff i) x \\<le> value_flow \\<Delta> (h_plus i)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma d_IN_h_le_value: \"d_IN h x \\<le> value_flow \\<Delta> h\" (is \"?lhs \\<le> ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN h x \\<le> value_flow \\<Delta> h", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. d_IN h x \\<le> value_flow \\<Delta> h", "have [tendsto_intros]: \"(\\<lambda>i. h_plus i e) \\<longlonglongrightarrow> lim_h_plus e\" for e"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>i. h_plus i e)\n    \\<longlonglongrightarrow> (\\<Squnion>n. h_plus n e)", "by(rule LIMSEQ_SUP incseq_SucI h_plus_mono)+"], ["proof (state)\nthis:\n  (\\<lambda>i. h_plus i ?e)\n  \\<longlonglongrightarrow> (\\<Squnion>n. h_plus n ?e)\n\ngoal (1 subgoal):\n 1. d_IN h x \\<le> value_flow \\<Delta> h", "have [tendsto_intros]: \"(\\<lambda>i. h_minus i e) \\<longlonglongrightarrow> lim_h_minus e\" for e"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>i. h_minus i e)\n    \\<longlonglongrightarrow> (\\<Squnion>n. h_minus n e)", "by(rule LIMSEQ_SUP incseq_SucI h_minus_mono)+"], ["proof (state)\nthis:\n  (\\<lambda>i. h_minus i ?e)\n  \\<longlonglongrightarrow> (\\<Squnion>n. h_minus n ?e)\n\ngoal (1 subgoal):\n 1. d_IN h x \\<le> value_flow \\<Delta> h", "have \"(\\<lambda>i. h_diff i e) \\<longlonglongrightarrow> lim_h_plus e - (if cycles \\<Delta> \\<noteq> {} then lim_h_minus e else 0)\" for e"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>i. h_diff i e)\n    \\<longlonglongrightarrow> (\\<Squnion>n. h_plus n e) -\n                              (if cycles \\<Delta> \\<noteq> {}\n                               then \\<Squnion>n. h_minus n e else 0)", "by(auto intro!: tendsto_intros tendsto_diff_ennreal simp add: h_diff_def simp del: Sup_eq_top_iff SUP_eq_top_iff)"], ["proof (state)\nthis:\n  (\\<lambda>i. h_diff i ?e)\n  \\<longlonglongrightarrow> (\\<Squnion>n. h_plus n ?e) -\n                            (if cycles \\<Delta> \\<noteq> {}\n                             then \\<Squnion>n. h_minus n ?e else 0)\n\ngoal (1 subgoal):\n 1. d_IN h x \\<le> value_flow \\<Delta> h", "then"], ["proof (chain)\npicking this:\n  (\\<lambda>i. h_diff i ?e)\n  \\<longlonglongrightarrow> (\\<Squnion>n. h_plus n ?e) -\n                            (if cycles \\<Delta> \\<noteq> {}\n                             then \\<Squnion>n. h_minus n ?e else 0)", "have \"d_IN h x = (\\<Sum>\\<^sup>+ y. liminf (\\<lambda>i. h_diff i (y, x)))\""], ["proof (prove)\nusing this:\n  (\\<lambda>i. h_diff i ?e)\n  \\<longlonglongrightarrow> (\\<Squnion>n. h_plus n ?e) -\n                            (if cycles \\<Delta> \\<noteq> {}\n                             then \\<Squnion>n. h_minus n ?e else 0)\n\ngoal (1 subgoal):\n 1. d_IN h x = (\\<Sum>\\<^sup>+ y. liminf (\\<lambda>i. h_diff i (y, x)))", "by(simp add: d_IN_def h_def tendsto_iff_Liminf_eq_Limsup)"], ["proof (state)\nthis:\n  d_IN h x = (\\<Sum>\\<^sup>+ y. liminf (\\<lambda>i. h_diff i (y, x)))\n\ngoal (1 subgoal):\n 1. d_IN h x \\<le> value_flow \\<Delta> h", "also"], ["proof (state)\nthis:\n  d_IN h x = (\\<Sum>\\<^sup>+ y. liminf (\\<lambda>i. h_diff i (y, x)))\n\ngoal (1 subgoal):\n 1. d_IN h x \\<le> value_flow \\<Delta> h", "have \"\\<dots> \\<le> liminf (\\<lambda>i. d_IN (h_diff i) x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y. liminf (\\<lambda>i. h_diff i (y, x)))\n    \\<le> liminf (\\<lambda>i. d_IN (h_diff i) x)", "unfolding d_IN_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y. liminf (\\<lambda>i. h_diff i (y, x)))\n    \\<le> liminf (\\<lambda>i. \\<Sum>\\<^sup>+ xa. h_diff i (xa, x))", "by(rule nn_integral_liminf) simp_all"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y. liminf (\\<lambda>i. h_diff i (y, x)))\n  \\<le> liminf (\\<lambda>i. d_IN (h_diff i) x)\n\ngoal (1 subgoal):\n 1. d_IN h x \\<le> value_flow \\<Delta> h", "also"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y. liminf (\\<lambda>i. h_diff i (y, x)))\n  \\<le> liminf (\\<lambda>i. d_IN (h_diff i) x)\n\ngoal (1 subgoal):\n 1. d_IN h x \\<le> value_flow \\<Delta> h", "have \"\\<dots> \\<le> liminf (\\<lambda>i. value_flow \\<Delta> h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. liminf (\\<lambda>i. d_IN (h_diff i) x)\n    \\<le> liminf (\\<lambda>i. value_flow \\<Delta> h)", "using d_IN_h_le_value'[of _ x]"], ["proof (prove)\nusing this:\n  d_IN (h_diff ?i) x \\<le> value_flow \\<Delta> (h_plus ?i)\n\ngoal (1 subgoal):\n 1. liminf (\\<lambda>i. d_IN (h_diff i) x)\n    \\<le> liminf (\\<lambda>i. value_flow \\<Delta> h)", "by(intro Liminf_mono eventually_sequentiallyI)(auto simp add: value_h_plus value_h)"], ["proof (state)\nthis:\n  liminf (\\<lambda>i. d_IN (h_diff i) x)\n  \\<le> liminf (\\<lambda>i. value_flow \\<Delta> h)\n\ngoal (1 subgoal):\n 1. d_IN h x \\<le> value_flow \\<Delta> h", "also"], ["proof (state)\nthis:\n  liminf (\\<lambda>i. d_IN (h_diff i) x)\n  \\<le> liminf (\\<lambda>i. value_flow \\<Delta> h)\n\ngoal (1 subgoal):\n 1. d_IN h x \\<le> value_flow \\<Delta> h", "have \"\\<dots> = value_flow \\<Delta> h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. liminf (\\<lambda>i. value_flow \\<Delta> h) = value_flow \\<Delta> h", "by(simp add: Liminf_const)"], ["proof (state)\nthis:\n  liminf (\\<lambda>i. value_flow \\<Delta> h) = value_flow \\<Delta> h\n\ngoal (1 subgoal):\n 1. d_IN h x \\<le> value_flow \\<Delta> h", "finally"], ["proof (chain)\npicking this:\n  d_IN h x \\<le> value_flow \\<Delta> h", "show ?thesis"], ["proof (prove)\nusing this:\n  d_IN h x \\<le> value_flow \\<Delta> h\n\ngoal (1 subgoal):\n 1. d_IN h x \\<le> value_flow \\<Delta> h", "."], ["proof (state)\nthis:\n  d_IN h x \\<le> value_flow \\<Delta> h\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma flow_cleanup: \\<comment> \\<open>Lemma 5.4\\<close>\n  \"\\<exists>h \\<le> g. flow \\<Delta> h \\<and> value_flow \\<Delta> h = value_flow \\<Delta> g \\<and> (\\<forall>x. d_IN h x \\<le> value_flow \\<Delta> h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>h\\<le>g.\n       flow \\<Delta> h \\<and>\n       value_flow \\<Delta> h = value_flow \\<Delta> g \\<and>\n       (\\<forall>x. d_IN h x \\<le> value_flow \\<Delta> h)", "by(intro exI[where x=h] conjI strip le_funI d_IN_h_le_value flow_h value_h h_le_g)"], ["", "end"], ["", "subsection \\<open>Residual network\\<close>"], ["", "context countable_network begin"], ["", "definition residual_network :: \"'v flow \\<Rightarrow> ('v, 'more) network_scheme\"\nwhere \"residual_network f =\n  \\<lparr>edge = \\<lambda>x y. edge \\<Delta> x y \\<or> edge \\<Delta> y x \\<and> y \\<noteq> source \\<Delta>,\n   capacity = \\<lambda>(x, y). if edge \\<Delta> x y then capacity \\<Delta> (x, y) - f (x, y) else if y = source \\<Delta> then 0 else f (y, x),\n   source = source \\<Delta>, sink = sink \\<Delta>, \\<dots> = network.more \\<Delta> \\<rparr>\""], ["", "lemma residual_network_sel [simp]:\n  \"edge (residual_network f) x y \\<longleftrightarrow> edge \\<Delta> x y \\<or> edge \\<Delta> y x \\<and> y \\<noteq> source \\<Delta>\"\n  \"capacity (residual_network f) (x, y) = (if edge \\<Delta> x y then capacity \\<Delta> (x, y) - f (x, y) else if y = source \\<Delta> then 0 else f (y, x))\"\n  \"source (residual_network f) = source \\<Delta>\"\n  \"sink (residual_network f) = sink \\<Delta>\"\n  \"network.more (residual_network f) = network.more \\<Delta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (edge (residual_network f) x y =\n     (edge \\<Delta> x y \\<or>\n      edge \\<Delta> y x \\<and> y \\<noteq> source \\<Delta>) &&&\n     capacity (residual_network f) (x, y) =\n     (if edge \\<Delta> x y then capacity \\<Delta> (x, y) - f (x, y)\n      else if y = source \\<Delta> then 0 else f (y, x))) &&&\n    source (residual_network f) = source \\<Delta> &&&\n    sink (residual_network f) = sink \\<Delta> &&&\n    network.more (residual_network f) = network.more \\<Delta>", "by(simp_all add: residual_network_def)"], ["", "lemma \"\\<^bold>E_residual_network\": \"\\<^bold>E\\<^bsub>residual_network f\\<^esub> = \\<^bold>E \\<union> {(x, y). (y, x) \\<in> \\<^bold>E \\<and> y \\<noteq> source \\<Delta>}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<^bold>E\\<^bsub>residual_network f\\<^esub> =\n    \\<^bold>E \\<union>\n    {(x, y). (y, x) \\<in> \\<^bold>E \\<and> y \\<noteq> source \\<Delta>}", "by auto"], ["", "lemma vertices_residual_network [simp]: \"vertex (residual_network f) = vertex \\<Delta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vertex (residual_network f) = vertex \\<Delta>", "by(auto simp add: vertex_def fun_eq_iff)"], ["", "inductive wf_residual_network :: \"bool\"\nwhere \"\\<lbrakk> \\<And>x y. (x, y) \\<in> \\<^bold>E \\<Longrightarrow> (y, x) \\<notin> \\<^bold>E; (source \\<Delta>, sink \\<Delta>) \\<notin> \\<^bold>E \\<rbrakk> \\<Longrightarrow> wf_residual_network\""], ["", "lemma wf_residual_networkD:\n  \"\\<lbrakk> wf_residual_network; edge \\<Delta> x y \\<rbrakk> \\<Longrightarrow> \\<not> edge \\<Delta> y x\"\n  \"\\<lbrakk> wf_residual_network; e \\<in> \\<^bold>E \\<rbrakk> \\<Longrightarrow> prod.swap e \\<notin> \\<^bold>E\"\n  \"\\<lbrakk> wf_residual_network; edge \\<Delta> (source \\<Delta>) (sink \\<Delta>) \\<rbrakk> \\<Longrightarrow> False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>wf_residual_network; edge \\<Delta> x y\\<rbrakk>\n     \\<Longrightarrow> \\<not> edge \\<Delta> y x) &&&\n    (\\<lbrakk>wf_residual_network; e \\<in> \\<^bold>E\\<rbrakk>\n     \\<Longrightarrow> prod.swap e \\<notin> \\<^bold>E) &&&\n    (\\<lbrakk>wf_residual_network;\n      edge \\<Delta> (source \\<Delta>) (sink \\<Delta>)\\<rbrakk>\n     \\<Longrightarrow> False)", "by(auto simp add: wf_residual_network.simps)"], ["", "lemma residual_countable_network:\n  assumes wf: \"wf_residual_network\"\n  and f: \"flow \\<Delta> f\"\n  shows \"countable_network (residual_network f)\" (is \"countable_network ?\\<Delta>\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. countable_network (residual_network f)", "proof"], ["proof (state)\ngoal (4 subgoals):\n 1. countable \\<^bold>E\\<^bsub>residual_network f\\<^esub>\n 2. source (residual_network f) \\<noteq> sink (residual_network f)\n 3. \\<And>e.\n       e \\<notin> \\<^bold>E\\<^bsub>residual_network f\\<^esub> \\<Longrightarrow>\n       capacity (residual_network f) e = 0\n 4. \\<And>e. capacity (residual_network f) e \\<noteq> \\<top>", "have \"countable (converse \\<^bold>E)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. countable (\\<^bold>E\\<inverse>)", "by simp"], ["proof (state)\nthis:\n  countable (\\<^bold>E\\<inverse>)\n\ngoal (4 subgoals):\n 1. countable \\<^bold>E\\<^bsub>residual_network f\\<^esub>\n 2. source (residual_network f) \\<noteq> sink (residual_network f)\n 3. \\<And>e.\n       e \\<notin> \\<^bold>E\\<^bsub>residual_network f\\<^esub> \\<Longrightarrow>\n       capacity (residual_network f) e = 0\n 4. \\<And>e. capacity (residual_network f) e \\<noteq> \\<top>", "then"], ["proof (chain)\npicking this:\n  countable (\\<^bold>E\\<inverse>)", "have \"countable {(x, y). (y, x) \\<in> \\<^bold>E \\<and> y \\<noteq> source \\<Delta>}\""], ["proof (prove)\nusing this:\n  countable (\\<^bold>E\\<inverse>)\n\ngoal (1 subgoal):\n 1. countable\n     {(x, y). (y, x) \\<in> \\<^bold>E \\<and> y \\<noteq> source \\<Delta>}", "by(rule countable_subset[rotated]) auto"], ["proof (state)\nthis:\n  countable\n   {(x, y). (y, x) \\<in> \\<^bold>E \\<and> y \\<noteq> source \\<Delta>}\n\ngoal (4 subgoals):\n 1. countable \\<^bold>E\\<^bsub>residual_network f\\<^esub>\n 2. source (residual_network f) \\<noteq> sink (residual_network f)\n 3. \\<And>e.\n       e \\<notin> \\<^bold>E\\<^bsub>residual_network f\\<^esub> \\<Longrightarrow>\n       capacity (residual_network f) e = 0\n 4. \\<And>e. capacity (residual_network f) e \\<noteq> \\<top>", "then"], ["proof (chain)\npicking this:\n  countable\n   {(x, y). (y, x) \\<in> \\<^bold>E \\<and> y \\<noteq> source \\<Delta>}", "show \"countable \\<^bold>E\\<^bsub>?\\<Delta>\\<^esub>\""], ["proof (prove)\nusing this:\n  countable\n   {(x, y). (y, x) \\<in> \\<^bold>E \\<and> y \\<noteq> source \\<Delta>}\n\ngoal (1 subgoal):\n 1. countable \\<^bold>E\\<^bsub>residual_network f\\<^esub>", "unfolding \"\\<^bold>E_residual_network\""], ["proof (prove)\nusing this:\n  countable\n   {(x, y). (y, x) \\<in> \\<^bold>E \\<and> y \\<noteq> source \\<Delta>}\n\ngoal (1 subgoal):\n 1. countable\n     (\\<^bold>E \\<union>\n      {(x, y). (y, x) \\<in> \\<^bold>E \\<and> y \\<noteq> source \\<Delta>})", "by simp"], ["proof (state)\nthis:\n  countable \\<^bold>E\\<^bsub>residual_network f\\<^esub>\n\ngoal (3 subgoals):\n 1. source (residual_network f) \\<noteq> sink (residual_network f)\n 2. \\<And>e.\n       e \\<notin> \\<^bold>E\\<^bsub>residual_network f\\<^esub> \\<Longrightarrow>\n       capacity (residual_network f) e = 0\n 3. \\<And>e. capacity (residual_network f) e \\<noteq> \\<top>", "show \"source ?\\<Delta> \\<noteq> sink ?\\<Delta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. source (residual_network f) \\<noteq> sink (residual_network f)", "by simp"], ["proof (state)\nthis:\n  source (residual_network f) \\<noteq> sink (residual_network f)\n\ngoal (2 subgoals):\n 1. \\<And>e.\n       e \\<notin> \\<^bold>E\\<^bsub>residual_network f\\<^esub> \\<Longrightarrow>\n       capacity (residual_network f) e = 0\n 2. \\<And>e. capacity (residual_network f) e \\<noteq> \\<top>", "show \"capacity ?\\<Delta> e = 0\" if \"e \\<notin> \\<^bold>E\\<^bsub>?\\<Delta>\\<^esub>\" for e"], ["proof (prove)\ngoal (1 subgoal):\n 1. capacity (residual_network f) e = 0", "using that"], ["proof (prove)\nusing this:\n  e \\<notin> \\<^bold>E\\<^bsub>residual_network f\\<^esub>\n\ngoal (1 subgoal):\n 1. capacity (residual_network f) e = 0", "by(cases e)(auto intro: flowD_outside[OF f])"], ["proof (state)\nthis:\n  ?e \\<notin> \\<^bold>E\\<^bsub>residual_network f\\<^esub> \\<Longrightarrow>\n  capacity (residual_network f) ?e = 0\n\ngoal (1 subgoal):\n 1. \\<And>e. capacity (residual_network f) e \\<noteq> \\<top>", "show \"capacity ?\\<Delta> e \\<noteq> top\" for e"], ["proof (prove)\ngoal (1 subgoal):\n 1. capacity (residual_network f) e \\<noteq> \\<top>", "using flowD_finite[OF f]"], ["proof (prove)\nusing this:\n  f ?e \\<noteq> \\<top>\n\ngoal (1 subgoal):\n 1. capacity (residual_network f) e \\<noteq> \\<top>", "by(cases e) auto"], ["proof (state)\nthis:\n  capacity (residual_network f) ?e \\<noteq> \\<top>\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "context antiparallel_edges begin"], ["", "interpretation \\<Delta>'': countable_network \\<Delta>''"], ["proof (prove)\ngoal (1 subgoal):\n 1. countable_network \\<Delta>''", "by(rule \\<Delta>''_countable_network)"], ["", "lemma \\<Delta>''_flow_attainability:\n  assumes \"flow_attainability_axioms \\<Delta>\"\n  shows \"flow_attainability \\<Delta>''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. flow_attainability \\<Delta>''", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. flow_attainability \\<Delta>''", "interpret flow_attainability \\<Delta>"], ["proof (prove)\ngoal (1 subgoal):\n 1. flow_attainability \\<Delta>", "using _ assms"], ["proof (prove)\nusing this:\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  flow_attainability_axioms \\<Delta>\n\ngoal (1 subgoal):\n 1. flow_attainability \\<Delta>", "by(rule flow_attainability.intro) unfold_locales"], ["proof (state)\ngoal (1 subgoal):\n 1. flow_attainability \\<Delta>''", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. flow_attainability \\<Delta>''", "proof"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x.\n       x \\<noteq> sink \\<Delta>'' \\<Longrightarrow>\n       d_IN (capacity \\<Delta>'') x \\<noteq> \\<top> \\<or>\n       d_OUT (capacity \\<Delta>'') x \\<noteq> \\<top>\n 2. \\<And>x. \\<not> edge \\<Delta>'' x x\n 3. \\<And>x. \\<not> edge \\<Delta>'' x (source \\<Delta>'')", "show \"d_IN (capacity \\<Delta>'') v \\<noteq> \\<top> \\<or> d_OUT (capacity \\<Delta>'') v \\<noteq> \\<top>\" if \"v \\<noteq> sink \\<Delta>''\" for v"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN (capacity \\<Delta>'') v \\<noteq> \\<top> \\<or>\n    d_OUT (capacity \\<Delta>'') v \\<noteq> \\<top>", "using that finite_capacity"], ["proof (prove)\nusing this:\n  v \\<noteq> sink \\<Delta>''\n  ?x \\<noteq> sink \\<Delta> \\<Longrightarrow>\n  d_IN (capacity \\<Delta>) ?x \\<noteq> \\<top> \\<or>\n  d_OUT (capacity \\<Delta>) ?x \\<noteq> \\<top>\n\ngoal (1 subgoal):\n 1. d_IN (capacity \\<Delta>'') v \\<noteq> \\<top> \\<or>\n    d_OUT (capacity \\<Delta>'') v \\<noteq> \\<top>", "by(cases v)(simp_all add: max_def)"], ["proof (state)\nthis:\n  ?v \\<noteq> sink \\<Delta>'' \\<Longrightarrow>\n  d_IN (capacity \\<Delta>'') ?v \\<noteq> \\<top> \\<or>\n  d_OUT (capacity \\<Delta>'') ?v \\<noteq> \\<top>\n\ngoal (2 subgoals):\n 1. \\<And>x. \\<not> edge \\<Delta>'' x x\n 2. \\<And>x. \\<not> edge \\<Delta>'' x (source \\<Delta>'')", "show \"\\<not> edge \\<Delta>'' v v\" for v"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> edge \\<Delta>'' v v", "by(auto elim: edg.cases)"], ["proof (state)\nthis:\n  \\<not> edge \\<Delta>'' ?v ?v\n\ngoal (1 subgoal):\n 1. \\<And>x. \\<not> edge \\<Delta>'' x (source \\<Delta>'')", "show \"\\<not> edge \\<Delta>'' v (source \\<Delta>'')\" for v"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> edge \\<Delta>'' v (source \\<Delta>'')", "by(simp add: source_in)"], ["proof (state)\nthis:\n  \\<not> edge \\<Delta>'' ?v (source \\<Delta>'')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  flow_attainability \\<Delta>''\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma \\<Delta>''_wf_residual_network:\n  assumes no_loop: \"\\<And>x. \\<not> edge \\<Delta> x x\"\n  shows \"\\<Delta>''.wf_residual_network\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Delta>''.wf_residual_network", "by(auto simp add: \\<Delta>''.wf_residual_network.simps assms elim!: edg.cases)"], ["", "end"], ["", "subsection \\<open>The attainability theorem\\<close>"], ["", "context flow_attainability begin"], ["", "lemma residual_flow_attainability:\n  assumes wf: \"wf_residual_network\"\n  and f: \"flow \\<Delta> f\"\n  shows \"flow_attainability (residual_network f)\" (is \"flow_attainability ?\\<Delta>\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. flow_attainability (residual_network f)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. flow_attainability (residual_network f)", "interpret res: countable_network \"residual_network f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. countable_network (residual_network f)", "by(rule residual_countable_network[OF assms])"], ["proof (state)\ngoal (1 subgoal):\n 1. flow_attainability (residual_network f)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. flow_attainability (residual_network f)", "proof"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x.\n       x \\<noteq> sink (residual_network f) \\<Longrightarrow>\n       d_IN (capacity (residual_network f)) x \\<noteq> \\<top> \\<or>\n       d_OUT (capacity (residual_network f)) x \\<noteq> \\<top>\n 2. \\<And>x. \\<not> edge (residual_network f) x x\n 3. \\<And>x.\n       \\<not> edge (residual_network f) x (source (residual_network f))", "fix x"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x.\n       x \\<noteq> sink (residual_network f) \\<Longrightarrow>\n       d_IN (capacity (residual_network f)) x \\<noteq> \\<top> \\<or>\n       d_OUT (capacity (residual_network f)) x \\<noteq> \\<top>\n 2. \\<And>x. \\<not> edge (residual_network f) x x\n 3. \\<And>x.\n       \\<not> edge (residual_network f) x (source (residual_network f))", "assume sink: \"x \\<noteq> sink ?\\<Delta>\""], ["proof (state)\nthis:\n  x \\<noteq> sink (residual_network f)\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       x \\<noteq> sink (residual_network f) \\<Longrightarrow>\n       d_IN (capacity (residual_network f)) x \\<noteq> \\<top> \\<or>\n       d_OUT (capacity (residual_network f)) x \\<noteq> \\<top>\n 2. \\<And>x. \\<not> edge (residual_network f) x x\n 3. \\<And>x.\n       \\<not> edge (residual_network f) x (source (residual_network f))", "then"], ["proof (chain)\npicking this:\n  x \\<noteq> sink (residual_network f)", "consider (source) \"x = source \\<Delta>\" | (IN) \"d_IN (capacity \\<Delta>) x \\<noteq> \\<top>\" | (OUT) \"x \\<noteq> source \\<Delta>\" \"d_OUT (capacity \\<Delta>) x \\<noteq> \\<top>\""], ["proof (prove)\nusing this:\n  x \\<noteq> sink (residual_network f)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x = source \\<Delta> \\<Longrightarrow> thesis;\n     d_IN (capacity \\<Delta>) x \\<noteq> \\<top> \\<Longrightarrow> thesis;\n     \\<lbrakk>x \\<noteq> source \\<Delta>;\n      d_OUT (capacity \\<Delta>) x \\<noteq> \\<top>\\<rbrakk>\n     \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "using finite_capacity[of x]"], ["proof (prove)\nusing this:\n  x \\<noteq> sink (residual_network f)\n  x \\<noteq> sink \\<Delta> \\<Longrightarrow>\n  d_IN (capacity \\<Delta>) x \\<noteq> \\<top> \\<or>\n  d_OUT (capacity \\<Delta>) x \\<noteq> \\<top>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x = source \\<Delta> \\<Longrightarrow> thesis;\n     d_IN (capacity \\<Delta>) x \\<noteq> \\<top> \\<Longrightarrow> thesis;\n     \\<lbrakk>x \\<noteq> source \\<Delta>;\n      d_OUT (capacity \\<Delta>) x \\<noteq> \\<top>\\<rbrakk>\n     \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>x = source \\<Delta> \\<Longrightarrow> ?thesis;\n   d_IN (capacity \\<Delta>) x \\<noteq> \\<top> \\<Longrightarrow> ?thesis;\n   \\<lbrakk>x \\<noteq> source \\<Delta>;\n    d_OUT (capacity \\<Delta>) x \\<noteq> \\<top>\\<rbrakk>\n   \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       x \\<noteq> sink (residual_network f) \\<Longrightarrow>\n       d_IN (capacity (residual_network f)) x \\<noteq> \\<top> \\<or>\n       d_OUT (capacity (residual_network f)) x \\<noteq> \\<top>\n 2. \\<And>x. \\<not> edge (residual_network f) x x\n 3. \\<And>x.\n       \\<not> edge (residual_network f) x (source (residual_network f))", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>x = source \\<Delta> \\<Longrightarrow> ?thesis;\n   d_IN (capacity \\<Delta>) x \\<noteq> \\<top> \\<Longrightarrow> ?thesis;\n   \\<lbrakk>x \\<noteq> source \\<Delta>;\n    d_OUT (capacity \\<Delta>) x \\<noteq> \\<top>\\<rbrakk>\n   \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis", "show \"d_IN (capacity ?\\<Delta>) x \\<noteq> \\<top> \\<or> d_OUT (capacity ?\\<Delta>) x \\<noteq> \\<top>\""], ["proof (prove)\nusing this:\n  \\<lbrakk>x = source \\<Delta> \\<Longrightarrow> ?thesis;\n   d_IN (capacity \\<Delta>) x \\<noteq> \\<top> \\<Longrightarrow> ?thesis;\n   \\<lbrakk>x \\<noteq> source \\<Delta>;\n    d_OUT (capacity \\<Delta>) x \\<noteq> \\<top>\\<rbrakk>\n   \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. d_IN (capacity (residual_network f)) x \\<noteq> \\<top> \\<or>\n    d_OUT (capacity (residual_network f)) x \\<noteq> \\<top>", "proof(cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. x = source \\<Delta> \\<Longrightarrow>\n    d_IN (capacity (residual_network f)) x \\<noteq> \\<top> \\<or>\n    d_OUT (capacity (residual_network f)) x \\<noteq> \\<top>\n 2. d_IN (capacity \\<Delta>) x \\<noteq> \\<top> \\<Longrightarrow>\n    d_IN (capacity (residual_network f)) x \\<noteq> \\<top> \\<or>\n    d_OUT (capacity (residual_network f)) x \\<noteq> \\<top>\n 3. \\<lbrakk>x \\<noteq> source \\<Delta>;\n     d_OUT (capacity \\<Delta>) x \\<noteq> \\<top>\\<rbrakk>\n    \\<Longrightarrow> d_IN (capacity (residual_network f)) x \\<noteq>\n                      \\<top> \\<or>\n                      d_OUT (capacity (residual_network f)) x \\<noteq>\n                      \\<top>", "case source"], ["proof (state)\nthis:\n  x = source \\<Delta>\n\ngoal (3 subgoals):\n 1. x = source \\<Delta> \\<Longrightarrow>\n    d_IN (capacity (residual_network f)) x \\<noteq> \\<top> \\<or>\n    d_OUT (capacity (residual_network f)) x \\<noteq> \\<top>\n 2. d_IN (capacity \\<Delta>) x \\<noteq> \\<top> \\<Longrightarrow>\n    d_IN (capacity (residual_network f)) x \\<noteq> \\<top> \\<or>\n    d_OUT (capacity (residual_network f)) x \\<noteq> \\<top>\n 3. \\<lbrakk>x \\<noteq> source \\<Delta>;\n     d_OUT (capacity \\<Delta>) x \\<noteq> \\<top>\\<rbrakk>\n    \\<Longrightarrow> d_IN (capacity (residual_network f)) x \\<noteq>\n                      \\<top> \\<or>\n                      d_OUT (capacity (residual_network f)) x \\<noteq>\n                      \\<top>", "hence \"d_IN (capacity ?\\<Delta>) x = 0\""], ["proof (prove)\nusing this:\n  x = source \\<Delta>\n\ngoal (1 subgoal):\n 1. d_IN (capacity (residual_network f)) x = 0", "by(simp add: d_IN_def source_in)"], ["proof (state)\nthis:\n  d_IN (capacity (residual_network f)) x = 0\n\ngoal (3 subgoals):\n 1. x = source \\<Delta> \\<Longrightarrow>\n    d_IN (capacity (residual_network f)) x \\<noteq> \\<top> \\<or>\n    d_OUT (capacity (residual_network f)) x \\<noteq> \\<top>\n 2. d_IN (capacity \\<Delta>) x \\<noteq> \\<top> \\<Longrightarrow>\n    d_IN (capacity (residual_network f)) x \\<noteq> \\<top> \\<or>\n    d_OUT (capacity (residual_network f)) x \\<noteq> \\<top>\n 3. \\<lbrakk>x \\<noteq> source \\<Delta>;\n     d_OUT (capacity \\<Delta>) x \\<noteq> \\<top>\\<rbrakk>\n    \\<Longrightarrow> d_IN (capacity (residual_network f)) x \\<noteq>\n                      \\<top> \\<or>\n                      d_OUT (capacity (residual_network f)) x \\<noteq>\n                      \\<top>", "thus ?thesis"], ["proof (prove)\nusing this:\n  d_IN (capacity (residual_network f)) x = 0\n\ngoal (1 subgoal):\n 1. d_IN (capacity (residual_network f)) x \\<noteq> \\<top> \\<or>\n    d_OUT (capacity (residual_network f)) x \\<noteq> \\<top>", "by simp"], ["proof (state)\nthis:\n  d_IN (capacity (residual_network f)) x \\<noteq> \\<top> \\<or>\n  d_OUT (capacity (residual_network f)) x \\<noteq> \\<top>\n\ngoal (2 subgoals):\n 1. d_IN (capacity \\<Delta>) x \\<noteq> \\<top> \\<Longrightarrow>\n    d_IN (capacity (residual_network f)) x \\<noteq> \\<top> \\<or>\n    d_OUT (capacity (residual_network f)) x \\<noteq> \\<top>\n 2. \\<lbrakk>x \\<noteq> source \\<Delta>;\n     d_OUT (capacity \\<Delta>) x \\<noteq> \\<top>\\<rbrakk>\n    \\<Longrightarrow> d_IN (capacity (residual_network f)) x \\<noteq>\n                      \\<top> \\<or>\n                      d_OUT (capacity (residual_network f)) x \\<noteq>\n                      \\<top>", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. d_IN (capacity \\<Delta>) x \\<noteq> \\<top> \\<Longrightarrow>\n    d_IN (capacity (residual_network f)) x \\<noteq> \\<top> \\<or>\n    d_OUT (capacity (residual_network f)) x \\<noteq> \\<top>\n 2. \\<lbrakk>x \\<noteq> source \\<Delta>;\n     d_OUT (capacity \\<Delta>) x \\<noteq> \\<top>\\<rbrakk>\n    \\<Longrightarrow> d_IN (capacity (residual_network f)) x \\<noteq>\n                      \\<top> \\<or>\n                      d_OUT (capacity (residual_network f)) x \\<noteq>\n                      \\<top>", "case IN"], ["proof (state)\nthis:\n  d_IN (capacity \\<Delta>) x \\<noteq> \\<top>\n\ngoal (2 subgoals):\n 1. d_IN (capacity \\<Delta>) x \\<noteq> \\<top> \\<Longrightarrow>\n    d_IN (capacity (residual_network f)) x \\<noteq> \\<top> \\<or>\n    d_OUT (capacity (residual_network f)) x \\<noteq> \\<top>\n 2. \\<lbrakk>x \\<noteq> source \\<Delta>;\n     d_OUT (capacity \\<Delta>) x \\<noteq> \\<top>\\<rbrakk>\n    \\<Longrightarrow> d_IN (capacity (residual_network f)) x \\<noteq>\n                      \\<top> \\<or>\n                      d_OUT (capacity (residual_network f)) x \\<noteq>\n                      \\<top>", "have \"d_IN (capacity ?\\<Delta>) x =\n        (\\<Sum>\\<^sup>+ y. (capacity \\<Delta> (y, x) - f (y, x)) * indicator \\<^bold>E (y, x) +\n              (if x = source \\<Delta> then 0 else f (x, y) * indicator \\<^bold>E (x, y)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN (capacity (residual_network f)) x =\n    (\\<Sum>\\<^sup>+ y.\n       (capacity \\<Delta> (y, x) - f (y, x)) * indicator \\<^bold>E (y, x) +\n       (if x = source \\<Delta> then 0\n        else f (x, y) * indicator \\<^bold>E (x, y)))", "using flowD_outside[OF f]"], ["proof (prove)\nusing this:\n  ?e \\<notin> \\<^bold>E \\<Longrightarrow> f ?e = 0\n\ngoal (1 subgoal):\n 1. d_IN (capacity (residual_network f)) x =\n    (\\<Sum>\\<^sup>+ y.\n       (capacity \\<Delta> (y, x) - f (y, x)) * indicator \\<^bold>E (y, x) +\n       (if x = source \\<Delta> then 0\n        else f (x, y) * indicator \\<^bold>E (x, y)))", "unfolding d_IN_def"], ["proof (prove)\nusing this:\n  ?e \\<notin> \\<^bold>E \\<Longrightarrow> f ?e = 0\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ xa. capacity (residual_network f) (xa, x)) =\n    (\\<Sum>\\<^sup>+ y.\n       (capacity \\<Delta> (y, x) - f (y, x)) * indicator \\<^bold>E (y, x) +\n       (if x = source \\<Delta> then 0\n        else f (x, y) * indicator \\<^bold>E (x, y)))", "by(auto intro!: nn_integral_cong split: split_indicator dest: wf_residual_networkD[OF wf])"], ["proof (state)\nthis:\n  d_IN (capacity (residual_network f)) x =\n  (\\<Sum>\\<^sup>+ y.\n     (capacity \\<Delta> (y, x) - f (y, x)) * indicator \\<^bold>E (y, x) +\n     (if x = source \\<Delta> then 0\n      else f (x, y) * indicator \\<^bold>E (x, y)))\n\ngoal (2 subgoals):\n 1. d_IN (capacity \\<Delta>) x \\<noteq> \\<top> \\<Longrightarrow>\n    d_IN (capacity (residual_network f)) x \\<noteq> \\<top> \\<or>\n    d_OUT (capacity (residual_network f)) x \\<noteq> \\<top>\n 2. \\<lbrakk>x \\<noteq> source \\<Delta>;\n     d_OUT (capacity \\<Delta>) x \\<noteq> \\<top>\\<rbrakk>\n    \\<Longrightarrow> d_IN (capacity (residual_network f)) x \\<noteq>\n                      \\<top> \\<or>\n                      d_OUT (capacity (residual_network f)) x \\<noteq>\n                      \\<top>", "also"], ["proof (state)\nthis:\n  d_IN (capacity (residual_network f)) x =\n  (\\<Sum>\\<^sup>+ y.\n     (capacity \\<Delta> (y, x) - f (y, x)) * indicator \\<^bold>E (y, x) +\n     (if x = source \\<Delta> then 0\n      else f (x, y) * indicator \\<^bold>E (x, y)))\n\ngoal (2 subgoals):\n 1. d_IN (capacity \\<Delta>) x \\<noteq> \\<top> \\<Longrightarrow>\n    d_IN (capacity (residual_network f)) x \\<noteq> \\<top> \\<or>\n    d_OUT (capacity (residual_network f)) x \\<noteq> \\<top>\n 2. \\<lbrakk>x \\<noteq> source \\<Delta>;\n     d_OUT (capacity \\<Delta>) x \\<noteq> \\<top>\\<rbrakk>\n    \\<Longrightarrow> d_IN (capacity (residual_network f)) x \\<noteq>\n                      \\<top> \\<or>\n                      d_OUT (capacity (residual_network f)) x \\<noteq>\n                      \\<top>", "have \"\\<dots> = (\\<Sum>\\<^sup>+ y. (capacity \\<Delta> (y, x) - f (y, x)) * indicator \\<^bold>E (y, x)) +\n        (\\<Sum>\\<^sup>+ y. (if x = source \\<Delta> then 0 else f (x, y) * indicator \\<^bold>E (x, y)))\"\n        (is \"_ = ?in + ?out\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y.\n       (capacity \\<Delta> (y, x) - f (y, x)) * indicator \\<^bold>E (y, x) +\n       (if x = source \\<Delta> then 0\n        else f (x, y) * indicator \\<^bold>E (x, y))) =\n    (\\<Sum>\\<^sup>+ y.\n       (capacity \\<Delta> (y, x) - f (y, x)) * indicator \\<^bold>E (y, x)) +\n    (\\<Sum>\\<^sup>+ y.\n       if x = source \\<Delta> then 0\n       else f (x, y) * indicator \\<^bold>E (x, y))", "by(subst nn_integral_add)(auto simp add: AE_count_space split: split_indicator intro!: flowD_capacity[OF f])"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y.\n     (capacity \\<Delta> (y, x) - f (y, x)) * indicator \\<^bold>E (y, x) +\n     (if x = source \\<Delta> then 0\n      else f (x, y) * indicator \\<^bold>E (x, y))) =\n  (\\<Sum>\\<^sup>+ y.\n     (capacity \\<Delta> (y, x) - f (y, x)) * indicator \\<^bold>E (y, x)) +\n  (\\<Sum>\\<^sup>+ y.\n     if x = source \\<Delta> then 0\n     else f (x, y) * indicator \\<^bold>E (x, y))\n\ngoal (2 subgoals):\n 1. d_IN (capacity \\<Delta>) x \\<noteq> \\<top> \\<Longrightarrow>\n    d_IN (capacity (residual_network f)) x \\<noteq> \\<top> \\<or>\n    d_OUT (capacity (residual_network f)) x \\<noteq> \\<top>\n 2. \\<lbrakk>x \\<noteq> source \\<Delta>;\n     d_OUT (capacity \\<Delta>) x \\<noteq> \\<top>\\<rbrakk>\n    \\<Longrightarrow> d_IN (capacity (residual_network f)) x \\<noteq>\n                      \\<top> \\<or>\n                      d_OUT (capacity (residual_network f)) x \\<noteq>\n                      \\<top>", "also"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y.\n     (capacity \\<Delta> (y, x) - f (y, x)) * indicator \\<^bold>E (y, x) +\n     (if x = source \\<Delta> then 0\n      else f (x, y) * indicator \\<^bold>E (x, y))) =\n  (\\<Sum>\\<^sup>+ y.\n     (capacity \\<Delta> (y, x) - f (y, x)) * indicator \\<^bold>E (y, x)) +\n  (\\<Sum>\\<^sup>+ y.\n     if x = source \\<Delta> then 0\n     else f (x, y) * indicator \\<^bold>E (x, y))\n\ngoal (2 subgoals):\n 1. d_IN (capacity \\<Delta>) x \\<noteq> \\<top> \\<Longrightarrow>\n    d_IN (capacity (residual_network f)) x \\<noteq> \\<top> \\<or>\n    d_OUT (capacity (residual_network f)) x \\<noteq> \\<top>\n 2. \\<lbrakk>x \\<noteq> source \\<Delta>;\n     d_OUT (capacity \\<Delta>) x \\<noteq> \\<top>\\<rbrakk>\n    \\<Longrightarrow> d_IN (capacity (residual_network f)) x \\<noteq>\n                      \\<top> \\<or>\n                      d_OUT (capacity (residual_network f)) x \\<noteq>\n                      \\<top>", "have \"\\<dots> \\<le> d_IN (capacity \\<Delta>) x + (if x = source \\<Delta> then 0 else d_OUT f x)\" (is \"_ \\<le> ?in + ?rest\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y.\n       (capacity \\<Delta> (y, x) - f (y, x)) * indicator \\<^bold>E (y, x)) +\n    (\\<Sum>\\<^sup>+ y.\n       if x = source \\<Delta> then 0\n       else f (x, y) * indicator \\<^bold>E (x, y))\n    \\<le> d_IN (capacity \\<Delta>) x +\n          (if x = source \\<Delta> then 0 else d_OUT f x)", "unfolding d_IN_def d_OUT_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y.\n       (capacity \\<Delta> (y, x) - f (y, x)) * indicator \\<^bold>E (y, x)) +\n    (\\<Sum>\\<^sup>+ y.\n       if x = source \\<Delta> then 0\n       else f (x, y) * indicator \\<^bold>E (x, y))\n    \\<le> (\\<Sum>\\<^sup>+ xa. capacity \\<Delta> (xa, x)) +\n          (if x = source \\<Delta> then 0 else \\<Sum>\\<^sup>+ y. f (x, y))", "by(rule add_mono)(auto intro!: nn_integral_mono split: split_indicator simp add: nn_integral_0_iff_AE AE_count_space intro!: diff_le_self_ennreal)"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y.\n     (capacity \\<Delta> (y, x) - f (y, x)) * indicator \\<^bold>E (y, x)) +\n  (\\<Sum>\\<^sup>+ y.\n     if x = source \\<Delta> then 0\n     else f (x, y) * indicator \\<^bold>E (x, y))\n  \\<le> d_IN (capacity \\<Delta>) x +\n        (if x = source \\<Delta> then 0 else d_OUT f x)\n\ngoal (2 subgoals):\n 1. d_IN (capacity \\<Delta>) x \\<noteq> \\<top> \\<Longrightarrow>\n    d_IN (capacity (residual_network f)) x \\<noteq> \\<top> \\<or>\n    d_OUT (capacity (residual_network f)) x \\<noteq> \\<top>\n 2. \\<lbrakk>x \\<noteq> source \\<Delta>;\n     d_OUT (capacity \\<Delta>) x \\<noteq> \\<top>\\<rbrakk>\n    \\<Longrightarrow> d_IN (capacity (residual_network f)) x \\<noteq>\n                      \\<top> \\<or>\n                      d_OUT (capacity (residual_network f)) x \\<noteq>\n                      \\<top>", "also"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y.\n     (capacity \\<Delta> (y, x) - f (y, x)) * indicator \\<^bold>E (y, x)) +\n  (\\<Sum>\\<^sup>+ y.\n     if x = source \\<Delta> then 0\n     else f (x, y) * indicator \\<^bold>E (x, y))\n  \\<le> d_IN (capacity \\<Delta>) x +\n        (if x = source \\<Delta> then 0 else d_OUT f x)\n\ngoal (2 subgoals):\n 1. d_IN (capacity \\<Delta>) x \\<noteq> \\<top> \\<Longrightarrow>\n    d_IN (capacity (residual_network f)) x \\<noteq> \\<top> \\<or>\n    d_OUT (capacity (residual_network f)) x \\<noteq> \\<top>\n 2. \\<lbrakk>x \\<noteq> source \\<Delta>;\n     d_OUT (capacity \\<Delta>) x \\<noteq> \\<top>\\<rbrakk>\n    \\<Longrightarrow> d_IN (capacity (residual_network f)) x \\<noteq>\n                      \\<top> \\<or>\n                      d_OUT (capacity (residual_network f)) x \\<noteq>\n                      \\<top>", "consider (source) \"x = source \\<Delta>\" | (inner) \"x \\<noteq> source \\<Delta>\" \"x \\<noteq> sink \\<Delta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x = source \\<Delta> \\<Longrightarrow> thesis;\n     \\<lbrakk>x \\<noteq> source \\<Delta>; x \\<noteq> sink \\<Delta>\\<rbrakk>\n     \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "using sink"], ["proof (prove)\nusing this:\n  x \\<noteq> sink (residual_network f)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x = source \\<Delta> \\<Longrightarrow> thesis;\n     \\<lbrakk>x \\<noteq> source \\<Delta>; x \\<noteq> sink \\<Delta>\\<rbrakk>\n     \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>x = source \\<Delta> \\<Longrightarrow> ?thesis;\n   \\<lbrakk>x \\<noteq> source \\<Delta>; x \\<noteq> sink \\<Delta>\\<rbrakk>\n   \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (2 subgoals):\n 1. d_IN (capacity \\<Delta>) x \\<noteq> \\<top> \\<Longrightarrow>\n    d_IN (capacity (residual_network f)) x \\<noteq> \\<top> \\<or>\n    d_OUT (capacity (residual_network f)) x \\<noteq> \\<top>\n 2. \\<lbrakk>x \\<noteq> source \\<Delta>;\n     d_OUT (capacity \\<Delta>) x \\<noteq> \\<top>\\<rbrakk>\n    \\<Longrightarrow> d_IN (capacity (residual_network f)) x \\<noteq>\n                      \\<top> \\<or>\n                      d_OUT (capacity (residual_network f)) x \\<noteq>\n                      \\<top>", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>x = source \\<Delta> \\<Longrightarrow> ?thesis;\n   \\<lbrakk>x \\<noteq> source \\<Delta>; x \\<noteq> sink \\<Delta>\\<rbrakk>\n   \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis", "have \"?rest < \\<top>\""], ["proof (prove)\nusing this:\n  \\<lbrakk>x = source \\<Delta> \\<Longrightarrow> ?thesis;\n   \\<lbrakk>x \\<noteq> source \\<Delta>; x \\<noteq> sink \\<Delta>\\<rbrakk>\n   \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (if x = source \\<Delta> then 0 else d_OUT f x) < \\<top>", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. x = source \\<Delta> \\<Longrightarrow>\n    (if x = source \\<Delta> then 0 else d_OUT f x) < \\<top>\n 2. \\<lbrakk>x \\<noteq> source \\<Delta>; x \\<noteq> sink \\<Delta>\\<rbrakk>\n    \\<Longrightarrow> (if x = source \\<Delta> then 0 else d_OUT f x)\n                      < \\<top>", "case inner"], ["proof (state)\nthis:\n  x \\<noteq> source \\<Delta>\n  x \\<noteq> sink \\<Delta>\n\ngoal (2 subgoals):\n 1. x = source \\<Delta> \\<Longrightarrow>\n    (if x = source \\<Delta> then 0 else d_OUT f x) < \\<top>\n 2. \\<lbrakk>x \\<noteq> source \\<Delta>; x \\<noteq> sink \\<Delta>\\<rbrakk>\n    \\<Longrightarrow> (if x = source \\<Delta> then 0 else d_OUT f x)\n                      < \\<top>", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if x = source \\<Delta> then 0 else d_OUT f x) < \\<top>", "using inner flowD_finite_OUT[OF f inner]"], ["proof (prove)\nusing this:\n  x \\<noteq> source \\<Delta>\n  x \\<noteq> sink \\<Delta>\n  d_OUT f x \\<noteq> \\<top>\n\ngoal (1 subgoal):\n 1. (if x = source \\<Delta> then 0 else d_OUT f x) < \\<top>", "by (simp add: less_top)"], ["proof (state)\nthis:\n  (if x = source \\<Delta> then 0 else d_OUT f x) < \\<top>\n\ngoal (1 subgoal):\n 1. x = source \\<Delta> \\<Longrightarrow>\n    (if x = source \\<Delta> then 0 else d_OUT f x) < \\<top>", "qed simp"], ["proof (state)\nthis:\n  (if x = source \\<Delta> then 0 else d_OUT f x) < \\<top>\n\ngoal (2 subgoals):\n 1. d_IN (capacity \\<Delta>) x \\<noteq> \\<top> \\<Longrightarrow>\n    d_IN (capacity (residual_network f)) x \\<noteq> \\<top> \\<or>\n    d_OUT (capacity (residual_network f)) x \\<noteq> \\<top>\n 2. \\<lbrakk>x \\<noteq> source \\<Delta>;\n     d_OUT (capacity \\<Delta>) x \\<noteq> \\<top>\\<rbrakk>\n    \\<Longrightarrow> d_IN (capacity (residual_network f)) x \\<noteq>\n                      \\<top> \\<or>\n                      d_OUT (capacity (residual_network f)) x \\<noteq>\n                      \\<top>", "ultimately"], ["proof (chain)\npicking this:\n  d_IN (capacity (residual_network f)) x\n  \\<le> d_IN (capacity \\<Delta>) x +\n        (if x = source \\<Delta> then 0 else d_OUT f x)\n  (if x = source \\<Delta> then 0 else d_OUT f x) < \\<top>", "show ?thesis"], ["proof (prove)\nusing this:\n  d_IN (capacity (residual_network f)) x\n  \\<le> d_IN (capacity \\<Delta>) x +\n        (if x = source \\<Delta> then 0 else d_OUT f x)\n  (if x = source \\<Delta> then 0 else d_OUT f x) < \\<top>\n\ngoal (1 subgoal):\n 1. d_IN (capacity (residual_network f)) x \\<noteq> \\<top> \\<or>\n    d_OUT (capacity (residual_network f)) x \\<noteq> \\<top>", "using IN sink"], ["proof (prove)\nusing this:\n  d_IN (capacity (residual_network f)) x\n  \\<le> d_IN (capacity \\<Delta>) x +\n        (if x = source \\<Delta> then 0 else d_OUT f x)\n  (if x = source \\<Delta> then 0 else d_OUT f x) < \\<top>\n  d_IN (capacity \\<Delta>) x \\<noteq> \\<top>\n  x \\<noteq> sink (residual_network f)\n\ngoal (1 subgoal):\n 1. d_IN (capacity (residual_network f)) x \\<noteq> \\<top> \\<or>\n    d_OUT (capacity (residual_network f)) x \\<noteq> \\<top>", "by (auto simp: less_top[symmetric] top_unique)"], ["proof (state)\nthis:\n  d_IN (capacity (residual_network f)) x \\<noteq> \\<top> \\<or>\n  d_OUT (capacity (residual_network f)) x \\<noteq> \\<top>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> source \\<Delta>;\n     d_OUT (capacity \\<Delta>) x \\<noteq> \\<top>\\<rbrakk>\n    \\<Longrightarrow> d_IN (capacity (residual_network f)) x \\<noteq>\n                      \\<top> \\<or>\n                      d_OUT (capacity (residual_network f)) x \\<noteq>\n                      \\<top>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> source \\<Delta>;\n     d_OUT (capacity \\<Delta>) x \\<noteq> \\<top>\\<rbrakk>\n    \\<Longrightarrow> d_IN (capacity (residual_network f)) x \\<noteq>\n                      \\<top> \\<or>\n                      d_OUT (capacity (residual_network f)) x \\<noteq>\n                      \\<top>", "case OUT"], ["proof (state)\nthis:\n  x \\<noteq> source \\<Delta>\n  d_OUT (capacity \\<Delta>) x \\<noteq> \\<top>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> source \\<Delta>;\n     d_OUT (capacity \\<Delta>) x \\<noteq> \\<top>\\<rbrakk>\n    \\<Longrightarrow> d_IN (capacity (residual_network f)) x \\<noteq>\n                      \\<top> \\<or>\n                      d_OUT (capacity (residual_network f)) x \\<noteq>\n                      \\<top>", "have \"d_OUT (capacity ?\\<Delta>) x =\n        (\\<Sum>\\<^sup>+ y. (capacity \\<Delta> (x, y) - f (x, y)) * indicator \\<^bold>E (x, y) +\n              (if y = source \\<Delta> then 0 else f (y, x) * indicator \\<^bold>E (y, x)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT (capacity (residual_network f)) x =\n    (\\<Sum>\\<^sup>+ y.\n       (capacity \\<Delta> (x, y) - f (x, y)) * indicator \\<^bold>E (x, y) +\n       (if y = source \\<Delta> then 0\n        else f (y, x) * indicator \\<^bold>E (y, x)))", "using flowD_outside[OF f]"], ["proof (prove)\nusing this:\n  ?e \\<notin> \\<^bold>E \\<Longrightarrow> f ?e = 0\n\ngoal (1 subgoal):\n 1. d_OUT (capacity (residual_network f)) x =\n    (\\<Sum>\\<^sup>+ y.\n       (capacity \\<Delta> (x, y) - f (x, y)) * indicator \\<^bold>E (x, y) +\n       (if y = source \\<Delta> then 0\n        else f (y, x) * indicator \\<^bold>E (y, x)))", "unfolding d_OUT_def"], ["proof (prove)\nusing this:\n  ?e \\<notin> \\<^bold>E \\<Longrightarrow> f ?e = 0\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y. capacity (residual_network f) (x, y)) =\n    (\\<Sum>\\<^sup>+ y.\n       (capacity \\<Delta> (x, y) - f (x, y)) * indicator \\<^bold>E (x, y) +\n       (if y = source \\<Delta> then 0\n        else f (y, x) * indicator \\<^bold>E (y, x)))", "by(auto intro!: nn_integral_cong split: split_indicator dest: wf_residual_networkD[OF wf] simp add: source_in)"], ["proof (state)\nthis:\n  d_OUT (capacity (residual_network f)) x =\n  (\\<Sum>\\<^sup>+ y.\n     (capacity \\<Delta> (x, y) - f (x, y)) * indicator \\<^bold>E (x, y) +\n     (if y = source \\<Delta> then 0\n      else f (y, x) * indicator \\<^bold>E (y, x)))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> source \\<Delta>;\n     d_OUT (capacity \\<Delta>) x \\<noteq> \\<top>\\<rbrakk>\n    \\<Longrightarrow> d_IN (capacity (residual_network f)) x \\<noteq>\n                      \\<top> \\<or>\n                      d_OUT (capacity (residual_network f)) x \\<noteq>\n                      \\<top>", "also"], ["proof (state)\nthis:\n  d_OUT (capacity (residual_network f)) x =\n  (\\<Sum>\\<^sup>+ y.\n     (capacity \\<Delta> (x, y) - f (x, y)) * indicator \\<^bold>E (x, y) +\n     (if y = source \\<Delta> then 0\n      else f (y, x) * indicator \\<^bold>E (y, x)))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> source \\<Delta>;\n     d_OUT (capacity \\<Delta>) x \\<noteq> \\<top>\\<rbrakk>\n    \\<Longrightarrow> d_IN (capacity (residual_network f)) x \\<noteq>\n                      \\<top> \\<or>\n                      d_OUT (capacity (residual_network f)) x \\<noteq>\n                      \\<top>", "have \"\\<dots> = (\\<Sum>\\<^sup>+ y. (capacity \\<Delta> (x, y) - f (x, y)) * indicator \\<^bold>E (x, y)) +\n        (\\<Sum>\\<^sup>+ y. (if y = source \\<Delta> then 0 else f (y, x) * indicator \\<^bold>E (y, x)))\"\n        (is \"_ = ?in + ?out\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y.\n       (capacity \\<Delta> (x, y) - f (x, y)) * indicator \\<^bold>E (x, y) +\n       (if y = source \\<Delta> then 0\n        else f (y, x) * indicator \\<^bold>E (y, x))) =\n    (\\<Sum>\\<^sup>+ y.\n       (capacity \\<Delta> (x, y) - f (x, y)) * indicator \\<^bold>E (x, y)) +\n    (\\<Sum>\\<^sup>+ y.\n       if y = source \\<Delta> then 0\n       else f (y, x) * indicator \\<^bold>E (y, x))", "by(subst nn_integral_add)(auto simp add: AE_count_space split: split_indicator intro!: flowD_capacity[OF f])"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y.\n     (capacity \\<Delta> (x, y) - f (x, y)) * indicator \\<^bold>E (x, y) +\n     (if y = source \\<Delta> then 0\n      else f (y, x) * indicator \\<^bold>E (y, x))) =\n  (\\<Sum>\\<^sup>+ y.\n     (capacity \\<Delta> (x, y) - f (x, y)) * indicator \\<^bold>E (x, y)) +\n  (\\<Sum>\\<^sup>+ y.\n     if y = source \\<Delta> then 0\n     else f (y, x) * indicator \\<^bold>E (y, x))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> source \\<Delta>;\n     d_OUT (capacity \\<Delta>) x \\<noteq> \\<top>\\<rbrakk>\n    \\<Longrightarrow> d_IN (capacity (residual_network f)) x \\<noteq>\n                      \\<top> \\<or>\n                      d_OUT (capacity (residual_network f)) x \\<noteq>\n                      \\<top>", "also"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y.\n     (capacity \\<Delta> (x, y) - f (x, y)) * indicator \\<^bold>E (x, y) +\n     (if y = source \\<Delta> then 0\n      else f (y, x) * indicator \\<^bold>E (y, x))) =\n  (\\<Sum>\\<^sup>+ y.\n     (capacity \\<Delta> (x, y) - f (x, y)) * indicator \\<^bold>E (x, y)) +\n  (\\<Sum>\\<^sup>+ y.\n     if y = source \\<Delta> then 0\n     else f (y, x) * indicator \\<^bold>E (y, x))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> source \\<Delta>;\n     d_OUT (capacity \\<Delta>) x \\<noteq> \\<top>\\<rbrakk>\n    \\<Longrightarrow> d_IN (capacity (residual_network f)) x \\<noteq>\n                      \\<top> \\<or>\n                      d_OUT (capacity (residual_network f)) x \\<noteq>\n                      \\<top>", "have \"\\<dots> \\<le> d_OUT (capacity \\<Delta>) x + d_IN f x\" (is \"_ \\<le> ?out + ?rest\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y.\n       (capacity \\<Delta> (x, y) - f (x, y)) * indicator \\<^bold>E (x, y)) +\n    (\\<Sum>\\<^sup>+ y.\n       if y = source \\<Delta> then 0\n       else f (y, x) * indicator \\<^bold>E (y, x))\n    \\<le> d_OUT (capacity \\<Delta>) x + d_IN f x", "unfolding d_IN_def d_OUT_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y.\n       (capacity \\<Delta> (x, y) - f (x, y)) * indicator \\<^bold>E (x, y)) +\n    (\\<Sum>\\<^sup>+ y.\n       if y = source \\<Delta> then 0\n       else f (y, x) * indicator \\<^bold>E (y, x))\n    \\<le> (\\<Sum>\\<^sup>+ y. capacity \\<Delta> (x, y)) +\n          (\\<Sum>\\<^sup>+ xa. f (xa, x))", "by(rule add_mono)(auto intro!: nn_integral_mono split: split_indicator simp add: nn_integral_0_iff_AE AE_count_space intro!: diff_le_self_ennreal)"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y.\n     (capacity \\<Delta> (x, y) - f (x, y)) * indicator \\<^bold>E (x, y)) +\n  (\\<Sum>\\<^sup>+ y.\n     if y = source \\<Delta> then 0\n     else f (y, x) * indicator \\<^bold>E (y, x))\n  \\<le> d_OUT (capacity \\<Delta>) x + d_IN f x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> source \\<Delta>;\n     d_OUT (capacity \\<Delta>) x \\<noteq> \\<top>\\<rbrakk>\n    \\<Longrightarrow> d_IN (capacity (residual_network f)) x \\<noteq>\n                      \\<top> \\<or>\n                      d_OUT (capacity (residual_network f)) x \\<noteq>\n                      \\<top>", "also"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y.\n     (capacity \\<Delta> (x, y) - f (x, y)) * indicator \\<^bold>E (x, y)) +\n  (\\<Sum>\\<^sup>+ y.\n     if y = source \\<Delta> then 0\n     else f (y, x) * indicator \\<^bold>E (y, x))\n  \\<le> d_OUT (capacity \\<Delta>) x + d_IN f x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> source \\<Delta>;\n     d_OUT (capacity \\<Delta>) x \\<noteq> \\<top>\\<rbrakk>\n    \\<Longrightarrow> d_IN (capacity (residual_network f)) x \\<noteq>\n                      \\<top> \\<or>\n                      d_OUT (capacity (residual_network f)) x \\<noteq>\n                      \\<top>", "have \"?rest = d_OUT f x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN f x = d_OUT f x", "using flowD_KIR[OF f OUT(1)] sink"], ["proof (prove)\nusing this:\n  x \\<noteq> sink \\<Delta> \\<Longrightarrow> KIR f x\n  x \\<noteq> sink (residual_network f)\n\ngoal (1 subgoal):\n 1. d_IN f x = d_OUT f x", "by simp"], ["proof (state)\nthis:\n  d_IN f x = d_OUT f x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> source \\<Delta>;\n     d_OUT (capacity \\<Delta>) x \\<noteq> \\<top>\\<rbrakk>\n    \\<Longrightarrow> d_IN (capacity (residual_network f)) x \\<noteq>\n                      \\<top> \\<or>\n                      d_OUT (capacity (residual_network f)) x \\<noteq>\n                      \\<top>", "also"], ["proof (state)\nthis:\n  d_IN f x = d_OUT f x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> source \\<Delta>;\n     d_OUT (capacity \\<Delta>) x \\<noteq> \\<top>\\<rbrakk>\n    \\<Longrightarrow> d_IN (capacity (residual_network f)) x \\<noteq>\n                      \\<top> \\<or>\n                      d_OUT (capacity (residual_network f)) x \\<noteq>\n                      \\<top>", "have \"?out + \\<dots> \\<le> ?out + ?out\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT (capacity \\<Delta>) x + d_OUT f x\n    \\<le> d_OUT (capacity \\<Delta>) x + d_OUT (capacity \\<Delta>) x", "by(intro add_left_mono d_OUT_mono flowD_capacity[OF f])"], ["proof (state)\nthis:\n  d_OUT (capacity \\<Delta>) x + d_OUT f x\n  \\<le> d_OUT (capacity \\<Delta>) x + d_OUT (capacity \\<Delta>) x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> source \\<Delta>;\n     d_OUT (capacity \\<Delta>) x \\<noteq> \\<top>\\<rbrakk>\n    \\<Longrightarrow> d_IN (capacity (residual_network f)) x \\<noteq>\n                      \\<top> \\<or>\n                      d_OUT (capacity (residual_network f)) x \\<noteq>\n                      \\<top>", "finally"], ["proof (chain)\npicking this:\n  d_OUT (capacity (residual_network f)) x\n  \\<le> d_OUT (capacity \\<Delta>) x + d_OUT (capacity \\<Delta>) x", "show ?thesis"], ["proof (prove)\nusing this:\n  d_OUT (capacity (residual_network f)) x\n  \\<le> d_OUT (capacity \\<Delta>) x + d_OUT (capacity \\<Delta>) x\n\ngoal (1 subgoal):\n 1. d_IN (capacity (residual_network f)) x \\<noteq> \\<top> \\<or>\n    d_OUT (capacity (residual_network f)) x \\<noteq> \\<top>", "using OUT"], ["proof (prove)\nusing this:\n  d_OUT (capacity (residual_network f)) x\n  \\<le> d_OUT (capacity \\<Delta>) x + d_OUT (capacity \\<Delta>) x\n  x \\<noteq> source \\<Delta>\n  d_OUT (capacity \\<Delta>) x \\<noteq> \\<top>\n\ngoal (1 subgoal):\n 1. d_IN (capacity (residual_network f)) x \\<noteq> \\<top> \\<or>\n    d_OUT (capacity (residual_network f)) x \\<noteq> \\<top>", "by (auto simp: top_unique)"], ["proof (state)\nthis:\n  d_IN (capacity (residual_network f)) x \\<noteq> \\<top> \\<or>\n  d_OUT (capacity (residual_network f)) x \\<noteq> \\<top>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  d_IN (capacity (residual_network f)) x \\<noteq> \\<top> \\<or>\n  d_OUT (capacity (residual_network f)) x \\<noteq> \\<top>\n\ngoal (2 subgoals):\n 1. \\<And>x. \\<not> edge (residual_network f) x x\n 2. \\<And>x.\n       \\<not> edge (residual_network f) x (source (residual_network f))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x. \\<not> edge (residual_network f) x x\n 2. \\<And>x.\n       \\<not> edge (residual_network f) x (source (residual_network f))", "show \"\\<not> edge ?\\<Delta> x x\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> edge (residual_network f) x x", "by(simp add: no_loop)"], ["proof (state)\nthis:\n  \\<not> edge (residual_network f) ?x ?x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<not> edge (residual_network f) x (source (residual_network f))", "show \"\\<not> edge ?\\<Delta> x (source ?\\<Delta>)\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> edge (residual_network f) x (source (residual_network f))", "by(simp add: source_in)"], ["proof (state)\nthis:\n  \\<not> edge (residual_network f) ?x (source (residual_network f))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  flow_attainability (residual_network f)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "definition plus_flow :: \"('v, 'more) graph_scheme \\<Rightarrow> 'v flow \\<Rightarrow> 'v flow \\<Rightarrow> 'v flow\" (infixr \"\\<oplus>\\<index>\" 65)\nwhere \"plus_flow G f g = (\\<lambda>(x, y). if edge G x y then f (x, y) + g (x, y) - g (y, x) else 0)\""], ["", "lemma plus_flow_simps [simp]: fixes G (structure) shows\n  \"(f \\<oplus> g) (x, y) = (if edge G x y then f (x, y) + g (x, y) - g (y, x) else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f \\<oplus> g) (x, y) =\n    (if edge G x y then f (x, y) + g (x, y) - g (y, x) else 0)", "by(simp add: plus_flow_def)"], ["", "lemma plus_flow_outside: fixes G (structure) shows \"e \\<notin> \\<^bold>E \\<Longrightarrow> (f \\<oplus> g) e = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. e \\<notin> \\<^bold>E \\<Longrightarrow> (f \\<oplus> g) e = 0", "by(cases e) simp"], ["", "lemma\n  fixes \\<Delta> (structure)\n  assumes f_outside: \"\\<And>e. e \\<notin> \\<^bold>E \\<Longrightarrow> f e = 0\"\n  and g_le_f: \"\\<And>x y. edge \\<Delta> x y \\<Longrightarrow> g (y, x) \\<le> f (x, y)\"\n  shows OUT_plus_flow: \"d_IN g x \\<noteq> top \\<Longrightarrow> d_OUT (f \\<oplus> g) x = d_OUT f x + (\\<Sum>\\<^sup>+ y\\<in>UNIV. g (x, y) * indicator \\<^bold>E (x, y)) - (\\<Sum>\\<^sup>+ y. g (y, x) * indicator \\<^bold>E (x, y))\"\n    (is \"_ \\<Longrightarrow> ?OUT\" is \"_ \\<Longrightarrow> _ = _ + ?g_out - ?g_out'\")\n  and IN_plus_flow: \"d_OUT g x \\<noteq> top \\<Longrightarrow> d_IN (f \\<oplus> g) x = d_IN f x + (\\<Sum>\\<^sup>+ y\\<in>UNIV. g (y, x) * indicator \\<^bold>E (y, x)) - (\\<Sum>\\<^sup>+ y. g (x, y) * indicator \\<^bold>E (y, x))\"\n    (is \"_ \\<Longrightarrow> ?IN\" is \"_ \\<Longrightarrow> _ = _ + ?g_in - ?g_in'\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (d_IN g x \\<noteq> \\<top> \\<Longrightarrow>\n     d_OUT (f \\<oplus> g) x =\n     d_OUT f x + (\\<Sum>\\<^sup>+ y. g (x, y) * indicator \\<^bold>E (x, y)) -\n     (\\<Sum>\\<^sup>+ y. g (y, x) * indicator \\<^bold>E (x, y))) &&&\n    (d_OUT g x \\<noteq> \\<top> \\<Longrightarrow>\n     d_IN (f \\<oplus> g) x =\n     d_IN f x + (\\<Sum>\\<^sup>+ y. g (y, x) * indicator \\<^bold>E (y, x)) -\n     (\\<Sum>\\<^sup>+ y. g (x, y) * indicator \\<^bold>E (y, x)))", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. d_IN g x \\<noteq> \\<top> \\<Longrightarrow>\n    d_OUT (f \\<oplus> g) x =\n    d_OUT f x + (\\<Sum>\\<^sup>+ y. g (x, y) * indicator \\<^bold>E (x, y)) -\n    (\\<Sum>\\<^sup>+ y. g (y, x) * indicator \\<^bold>E (x, y))\n 2. d_OUT g x \\<noteq> \\<top> \\<Longrightarrow>\n    d_IN (f \\<oplus> g) x =\n    d_IN f x + (\\<Sum>\\<^sup>+ y. g (y, x) * indicator \\<^bold>E (y, x)) -\n    (\\<Sum>\\<^sup>+ y. g (x, y) * indicator \\<^bold>E (y, x))", "assume \"d_IN g x \\<noteq> top\""], ["proof (state)\nthis:\n  d_IN g x \\<noteq> \\<top>\n\ngoal (2 subgoals):\n 1. d_IN g x \\<noteq> \\<top> \\<Longrightarrow>\n    d_OUT (f \\<oplus> g) x =\n    d_OUT f x + (\\<Sum>\\<^sup>+ y. g (x, y) * indicator \\<^bold>E (x, y)) -\n    (\\<Sum>\\<^sup>+ y. g (y, x) * indicator \\<^bold>E (x, y))\n 2. d_OUT g x \\<noteq> \\<top> \\<Longrightarrow>\n    d_IN (f \\<oplus> g) x =\n    d_IN f x + (\\<Sum>\\<^sup>+ y. g (y, x) * indicator \\<^bold>E (y, x)) -\n    (\\<Sum>\\<^sup>+ y. g (x, y) * indicator \\<^bold>E (y, x))", "then"], ["proof (chain)\npicking this:\n  d_IN g x \\<noteq> \\<top>", "have finite1: \"(\\<Sum>\\<^sup>+ y. g (y, x) * indicator A (f y)) \\<noteq> top\" for A f"], ["proof (prove)\nusing this:\n  d_IN g x \\<noteq> \\<top>\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y. g (y, x) * indicator A (f y)) \\<noteq> \\<top>", "by(rule neq_top_trans)(auto split: split_indicator simp add: d_IN_def intro!: nn_integral_mono)"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y. g (y, x) * indicator ?A1 (?f1 y)) \\<noteq> \\<top>\n\ngoal (2 subgoals):\n 1. d_IN g x \\<noteq> \\<top> \\<Longrightarrow>\n    d_OUT (f \\<oplus> g) x =\n    d_OUT f x + (\\<Sum>\\<^sup>+ y. g (x, y) * indicator \\<^bold>E (x, y)) -\n    (\\<Sum>\\<^sup>+ y. g (y, x) * indicator \\<^bold>E (x, y))\n 2. d_OUT g x \\<noteq> \\<top> \\<Longrightarrow>\n    d_IN (f \\<oplus> g) x =\n    d_IN f x + (\\<Sum>\\<^sup>+ y. g (y, x) * indicator \\<^bold>E (y, x)) -\n    (\\<Sum>\\<^sup>+ y. g (x, y) * indicator \\<^bold>E (y, x))", "have \"d_OUT (f \\<oplus> g) x = (\\<Sum>\\<^sup>+ y. (g (x, y) + (f (x, y) - g (y, x))) * indicator \\<^bold>E (x, y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT (f \\<oplus> g) x =\n    (\\<Sum>\\<^sup>+ y.\n       (g (x, y) + (f (x, y) - g (y, x))) * indicator \\<^bold>E (x, y))", "unfolding d_OUT_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y. (f \\<oplus> g) (x, y)) =\n    (\\<Sum>\\<^sup>+ y.\n       (g (x, y) + (f (x, y) - g (y, x))) * indicator \\<^bold>E (x, y))", "by(rule nn_integral_cong)(simp split: split_indicator add: add_diff_eq_ennreal add.commute ennreal_diff_add_assoc g_le_f)"], ["proof (state)\nthis:\n  d_OUT (f \\<oplus> g) x =\n  (\\<Sum>\\<^sup>+ y.\n     (g (x, y) + (f (x, y) - g (y, x))) * indicator \\<^bold>E (x, y))\n\ngoal (2 subgoals):\n 1. d_IN g x \\<noteq> \\<top> \\<Longrightarrow>\n    d_OUT (f \\<oplus> g) x =\n    d_OUT f x + (\\<Sum>\\<^sup>+ y. g (x, y) * indicator \\<^bold>E (x, y)) -\n    (\\<Sum>\\<^sup>+ y. g (y, x) * indicator \\<^bold>E (x, y))\n 2. d_OUT g x \\<noteq> \\<top> \\<Longrightarrow>\n    d_IN (f \\<oplus> g) x =\n    d_IN f x + (\\<Sum>\\<^sup>+ y. g (y, x) * indicator \\<^bold>E (y, x)) -\n    (\\<Sum>\\<^sup>+ y. g (x, y) * indicator \\<^bold>E (y, x))", "also"], ["proof (state)\nthis:\n  d_OUT (f \\<oplus> g) x =\n  (\\<Sum>\\<^sup>+ y.\n     (g (x, y) + (f (x, y) - g (y, x))) * indicator \\<^bold>E (x, y))\n\ngoal (2 subgoals):\n 1. d_IN g x \\<noteq> \\<top> \\<Longrightarrow>\n    d_OUT (f \\<oplus> g) x =\n    d_OUT f x + (\\<Sum>\\<^sup>+ y. g (x, y) * indicator \\<^bold>E (x, y)) -\n    (\\<Sum>\\<^sup>+ y. g (y, x) * indicator \\<^bold>E (x, y))\n 2. d_OUT g x \\<noteq> \\<top> \\<Longrightarrow>\n    d_IN (f \\<oplus> g) x =\n    d_IN f x + (\\<Sum>\\<^sup>+ y. g (y, x) * indicator \\<^bold>E (y, x)) -\n    (\\<Sum>\\<^sup>+ y. g (x, y) * indicator \\<^bold>E (y, x))", "have \"\\<dots> = ?g_out + (\\<Sum>\\<^sup>+ y. (f (x, y) - g (y, x)) * indicator \\<^bold>E (x, y))\"\n    (is \"_ = _ + ?rest\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y.\n       (g (x, y) + (f (x, y) - g (y, x))) * indicator \\<^bold>E (x, y)) =\n    (\\<Sum>\\<^sup>+ y. g (x, y) * indicator \\<^bold>E (x, y)) +\n    (\\<Sum>\\<^sup>+ y. (f (x, y) - g (y, x)) * indicator \\<^bold>E (x, y))", "by(subst nn_integral_add[symmetric])(auto simp add: AE_count_space g_le_f split: split_indicator intro!: nn_integral_cong)"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y.\n     (g (x, y) + (f (x, y) - g (y, x))) * indicator \\<^bold>E (x, y)) =\n  (\\<Sum>\\<^sup>+ y. g (x, y) * indicator \\<^bold>E (x, y)) +\n  (\\<Sum>\\<^sup>+ y. (f (x, y) - g (y, x)) * indicator \\<^bold>E (x, y))\n\ngoal (2 subgoals):\n 1. d_IN g x \\<noteq> \\<top> \\<Longrightarrow>\n    d_OUT (f \\<oplus> g) x =\n    d_OUT f x + (\\<Sum>\\<^sup>+ y. g (x, y) * indicator \\<^bold>E (x, y)) -\n    (\\<Sum>\\<^sup>+ y. g (y, x) * indicator \\<^bold>E (x, y))\n 2. d_OUT g x \\<noteq> \\<top> \\<Longrightarrow>\n    d_IN (f \\<oplus> g) x =\n    d_IN f x + (\\<Sum>\\<^sup>+ y. g (y, x) * indicator \\<^bold>E (y, x)) -\n    (\\<Sum>\\<^sup>+ y. g (x, y) * indicator \\<^bold>E (y, x))", "also"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y.\n     (g (x, y) + (f (x, y) - g (y, x))) * indicator \\<^bold>E (x, y)) =\n  (\\<Sum>\\<^sup>+ y. g (x, y) * indicator \\<^bold>E (x, y)) +\n  (\\<Sum>\\<^sup>+ y. (f (x, y) - g (y, x)) * indicator \\<^bold>E (x, y))\n\ngoal (2 subgoals):\n 1. d_IN g x \\<noteq> \\<top> \\<Longrightarrow>\n    d_OUT (f \\<oplus> g) x =\n    d_OUT f x + (\\<Sum>\\<^sup>+ y. g (x, y) * indicator \\<^bold>E (x, y)) -\n    (\\<Sum>\\<^sup>+ y. g (y, x) * indicator \\<^bold>E (x, y))\n 2. d_OUT g x \\<noteq> \\<top> \\<Longrightarrow>\n    d_IN (f \\<oplus> g) x =\n    d_IN f x + (\\<Sum>\\<^sup>+ y. g (y, x) * indicator \\<^bold>E (y, x)) -\n    (\\<Sum>\\<^sup>+ y. g (x, y) * indicator \\<^bold>E (y, x))", "have \"?rest = (\\<Sum>\\<^sup>+ y. f (x, y) * indicator \\<^bold>E (x, y)) - ?g_out'\" (is \"_ = ?f - _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y. (f (x, y) - g (y, x)) * indicator \\<^bold>E (x, y)) =\n    (\\<Sum>\\<^sup>+ y. f (x, y) * indicator \\<^bold>E (x, y)) -\n    (\\<Sum>\\<^sup>+ y. g (y, x) * indicator \\<^bold>E (x, y))", "apply(subst nn_integral_diff[symmetric])"], ["proof (prove)\ngoal (5 subgoals):\n 1. (\\<lambda>y. f (x, y) * indicator \\<^bold>E (x, y))\n    \\<in> borel_measurable (count_space UNIV)\n 2. (\\<lambda>y. g (y, x) * indicator \\<^bold>E (x, y))\n    \\<in> borel_measurable (count_space UNIV)\n 3. (\\<Sum>\\<^sup>+ y. g (y, x) * indicator \\<^bold>E (x, y)) \\<noteq>\n    \\<infinity>\n 4. AE xa in count_space\n              UNIV. g (xa, x) * indicator \\<^bold>E (x, xa)\n                    \\<le> f (x, xa) * indicator \\<^bold>E (x, xa)\n 5. (\\<Sum>\\<^sup>+ y. (f (x, y) - g (y, x)) * indicator \\<^bold>E (x, y)) =\n    (\\<Sum>\\<^sup>+ xa.\n       f (x, xa) * indicator \\<^bold>E (x, xa) -\n       g (xa, x) * indicator \\<^bold>E (x, xa))", "apply(auto intro!: nn_integral_cong split: split_indicator simp add: AE_count_space g_le_f finite1)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y. (f (x, y) - g (y, x)) * indicator \\<^bold>E (x, y)) =\n  (\\<Sum>\\<^sup>+ y. f (x, y) * indicator \\<^bold>E (x, y)) -\n  (\\<Sum>\\<^sup>+ y. g (y, x) * indicator \\<^bold>E (x, y))\n\ngoal (2 subgoals):\n 1. d_IN g x \\<noteq> \\<top> \\<Longrightarrow>\n    d_OUT (f \\<oplus> g) x =\n    d_OUT f x + (\\<Sum>\\<^sup>+ y. g (x, y) * indicator \\<^bold>E (x, y)) -\n    (\\<Sum>\\<^sup>+ y. g (y, x) * indicator \\<^bold>E (x, y))\n 2. d_OUT g x \\<noteq> \\<top> \\<Longrightarrow>\n    d_IN (f \\<oplus> g) x =\n    d_IN f x + (\\<Sum>\\<^sup>+ y. g (y, x) * indicator \\<^bold>E (y, x)) -\n    (\\<Sum>\\<^sup>+ y. g (x, y) * indicator \\<^bold>E (y, x))", "also"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y. (f (x, y) - g (y, x)) * indicator \\<^bold>E (x, y)) =\n  (\\<Sum>\\<^sup>+ y. f (x, y) * indicator \\<^bold>E (x, y)) -\n  (\\<Sum>\\<^sup>+ y. g (y, x) * indicator \\<^bold>E (x, y))\n\ngoal (2 subgoals):\n 1. d_IN g x \\<noteq> \\<top> \\<Longrightarrow>\n    d_OUT (f \\<oplus> g) x =\n    d_OUT f x + (\\<Sum>\\<^sup>+ y. g (x, y) * indicator \\<^bold>E (x, y)) -\n    (\\<Sum>\\<^sup>+ y. g (y, x) * indicator \\<^bold>E (x, y))\n 2. d_OUT g x \\<noteq> \\<top> \\<Longrightarrow>\n    d_IN (f \\<oplus> g) x =\n    d_IN f x + (\\<Sum>\\<^sup>+ y. g (y, x) * indicator \\<^bold>E (y, x)) -\n    (\\<Sum>\\<^sup>+ y. g (x, y) * indicator \\<^bold>E (y, x))", "have \"?f = d_OUT f x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y. f (x, y) * indicator \\<^bold>E (x, y)) = d_OUT f x", "unfolding d_OUT_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y. f (x, y) * indicator \\<^bold>E (x, y)) =\n    (\\<Sum>\\<^sup>+ y. f (x, y))", "using f_outside"], ["proof (prove)\nusing this:\n  ?e \\<notin> \\<^bold>E \\<Longrightarrow> f ?e = 0\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y. f (x, y) * indicator \\<^bold>E (x, y)) =\n    (\\<Sum>\\<^sup>+ y. f (x, y))", "by(auto intro!: nn_integral_cong split: split_indicator)"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y. f (x, y) * indicator \\<^bold>E (x, y)) = d_OUT f x\n\ngoal (2 subgoals):\n 1. d_IN g x \\<noteq> \\<top> \\<Longrightarrow>\n    d_OUT (f \\<oplus> g) x =\n    d_OUT f x + (\\<Sum>\\<^sup>+ y. g (x, y) * indicator \\<^bold>E (x, y)) -\n    (\\<Sum>\\<^sup>+ y. g (y, x) * indicator \\<^bold>E (x, y))\n 2. d_OUT g x \\<noteq> \\<top> \\<Longrightarrow>\n    d_IN (f \\<oplus> g) x =\n    d_IN f x + (\\<Sum>\\<^sup>+ y. g (y, x) * indicator \\<^bold>E (y, x)) -\n    (\\<Sum>\\<^sup>+ y. g (x, y) * indicator \\<^bold>E (y, x))", "also"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y. f (x, y) * indicator \\<^bold>E (x, y)) = d_OUT f x\n\ngoal (2 subgoals):\n 1. d_IN g x \\<noteq> \\<top> \\<Longrightarrow>\n    d_OUT (f \\<oplus> g) x =\n    d_OUT f x + (\\<Sum>\\<^sup>+ y. g (x, y) * indicator \\<^bold>E (x, y)) -\n    (\\<Sum>\\<^sup>+ y. g (y, x) * indicator \\<^bold>E (x, y))\n 2. d_OUT g x \\<noteq> \\<top> \\<Longrightarrow>\n    d_IN (f \\<oplus> g) x =\n    d_IN f x + (\\<Sum>\\<^sup>+ y. g (y, x) * indicator \\<^bold>E (y, x)) -\n    (\\<Sum>\\<^sup>+ y. g (x, y) * indicator \\<^bold>E (y, x))", "have \"(\\<Sum>\\<^sup>+ y. g (x, y) * indicator \\<^bold>E (x, y)) + (d_OUT f x - (\\<Sum>\\<^sup>+ y. g (y, x) * indicator \\<^bold>E (x, y))) =\n     d_OUT f x + ?g_out - ?g_out'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y. g (x, y) * indicator \\<^bold>E (x, y)) +\n    (d_OUT f x -\n     (\\<Sum>\\<^sup>+ y. g (y, x) * indicator \\<^bold>E (x, y))) =\n    d_OUT f x + (\\<Sum>\\<^sup>+ y. g (x, y) * indicator \\<^bold>E (x, y)) -\n    (\\<Sum>\\<^sup>+ y. g (y, x) * indicator \\<^bold>E (x, y))", "by (subst ennreal_diff_add_assoc[symmetric])\n        (auto simp: ac_simps d_OUT_def intro!: nn_integral_mono g_le_f split: split_indicator)"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y. g (x, y) * indicator \\<^bold>E (x, y)) +\n  (d_OUT f x - (\\<Sum>\\<^sup>+ y. g (y, x) * indicator \\<^bold>E (x, y))) =\n  d_OUT f x + (\\<Sum>\\<^sup>+ y. g (x, y) * indicator \\<^bold>E (x, y)) -\n  (\\<Sum>\\<^sup>+ y. g (y, x) * indicator \\<^bold>E (x, y))\n\ngoal (2 subgoals):\n 1. d_IN g x \\<noteq> \\<top> \\<Longrightarrow>\n    d_OUT (f \\<oplus> g) x =\n    d_OUT f x + (\\<Sum>\\<^sup>+ y. g (x, y) * indicator \\<^bold>E (x, y)) -\n    (\\<Sum>\\<^sup>+ y. g (y, x) * indicator \\<^bold>E (x, y))\n 2. d_OUT g x \\<noteq> \\<top> \\<Longrightarrow>\n    d_IN (f \\<oplus> g) x =\n    d_IN f x + (\\<Sum>\\<^sup>+ y. g (y, x) * indicator \\<^bold>E (y, x)) -\n    (\\<Sum>\\<^sup>+ y. g (x, y) * indicator \\<^bold>E (y, x))", "finally"], ["proof (chain)\npicking this:\n  d_OUT (f \\<oplus> g) x =\n  d_OUT f x + (\\<Sum>\\<^sup>+ y. g (x, y) * indicator \\<^bold>E (x, y)) -\n  (\\<Sum>\\<^sup>+ y. g (y, x) * indicator \\<^bold>E (x, y))", "show ?OUT"], ["proof (prove)\nusing this:\n  d_OUT (f \\<oplus> g) x =\n  d_OUT f x + (\\<Sum>\\<^sup>+ y. g (x, y) * indicator \\<^bold>E (x, y)) -\n  (\\<Sum>\\<^sup>+ y. g (y, x) * indicator \\<^bold>E (x, y))\n\ngoal (1 subgoal):\n 1. d_OUT (f \\<oplus> g) x =\n    d_OUT f x + (\\<Sum>\\<^sup>+ y. g (x, y) * indicator \\<^bold>E (x, y)) -\n    (\\<Sum>\\<^sup>+ y. g (y, x) * indicator \\<^bold>E (x, y))", "."], ["proof (state)\nthis:\n  d_OUT (f \\<oplus> g) x =\n  d_OUT f x + (\\<Sum>\\<^sup>+ y. g (x, y) * indicator \\<^bold>E (x, y)) -\n  (\\<Sum>\\<^sup>+ y. g (y, x) * indicator \\<^bold>E (x, y))\n\ngoal (1 subgoal):\n 1. d_OUT g x \\<noteq> \\<top> \\<Longrightarrow>\n    d_IN (f \\<oplus> g) x =\n    d_IN f x + (\\<Sum>\\<^sup>+ y. g (y, x) * indicator \\<^bold>E (y, x)) -\n    (\\<Sum>\\<^sup>+ y. g (x, y) * indicator \\<^bold>E (y, x))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. d_OUT g x \\<noteq> \\<top> \\<Longrightarrow>\n    d_IN (f \\<oplus> g) x =\n    d_IN f x + (\\<Sum>\\<^sup>+ y. g (y, x) * indicator \\<^bold>E (y, x)) -\n    (\\<Sum>\\<^sup>+ y. g (x, y) * indicator \\<^bold>E (y, x))", "assume \"d_OUT g x \\<noteq> top\""], ["proof (state)\nthis:\n  d_OUT g x \\<noteq> \\<top>\n\ngoal (1 subgoal):\n 1. d_OUT g x \\<noteq> \\<top> \\<Longrightarrow>\n    d_IN (f \\<oplus> g) x =\n    d_IN f x + (\\<Sum>\\<^sup>+ y. g (y, x) * indicator \\<^bold>E (y, x)) -\n    (\\<Sum>\\<^sup>+ y. g (x, y) * indicator \\<^bold>E (y, x))", "then"], ["proof (chain)\npicking this:\n  d_OUT g x \\<noteq> \\<top>", "have finite2: \"(\\<Sum>\\<^sup>+ y. g (x, y) * indicator A (f y)) \\<noteq> top\" for A f"], ["proof (prove)\nusing this:\n  d_OUT g x \\<noteq> \\<top>\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y. g (x, y) * indicator A (f y)) \\<noteq> \\<top>", "by(rule neq_top_trans)(auto split: split_indicator simp add: d_OUT_def intro!: nn_integral_mono)"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y. g (x, y) * indicator ?A1 (?f1 y)) \\<noteq> \\<top>\n\ngoal (1 subgoal):\n 1. d_OUT g x \\<noteq> \\<top> \\<Longrightarrow>\n    d_IN (f \\<oplus> g) x =\n    d_IN f x + (\\<Sum>\\<^sup>+ y. g (y, x) * indicator \\<^bold>E (y, x)) -\n    (\\<Sum>\\<^sup>+ y. g (x, y) * indicator \\<^bold>E (y, x))", "have \"d_IN (f \\<oplus> g) x = (\\<Sum>\\<^sup>+ y. (g (y, x) + (f (y, x) - g (x, y))) * indicator \\<^bold>E (y, x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN (f \\<oplus> g) x =\n    (\\<Sum>\\<^sup>+ y.\n       (g (y, x) + (f (y, x) - g (x, y))) * indicator \\<^bold>E (y, x))", "unfolding d_IN_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ xa. (f \\<oplus> g) (xa, x)) =\n    (\\<Sum>\\<^sup>+ y.\n       (g (y, x) + (f (y, x) - g (x, y))) * indicator \\<^bold>E (y, x))", "by(rule nn_integral_cong)(simp split: split_indicator add: add_diff_eq_ennreal add.commute ennreal_diff_add_assoc g_le_f)"], ["proof (state)\nthis:\n  d_IN (f \\<oplus> g) x =\n  (\\<Sum>\\<^sup>+ y.\n     (g (y, x) + (f (y, x) - g (x, y))) * indicator \\<^bold>E (y, x))\n\ngoal (1 subgoal):\n 1. d_OUT g x \\<noteq> \\<top> \\<Longrightarrow>\n    d_IN (f \\<oplus> g) x =\n    d_IN f x + (\\<Sum>\\<^sup>+ y. g (y, x) * indicator \\<^bold>E (y, x)) -\n    (\\<Sum>\\<^sup>+ y. g (x, y) * indicator \\<^bold>E (y, x))", "also"], ["proof (state)\nthis:\n  d_IN (f \\<oplus> g) x =\n  (\\<Sum>\\<^sup>+ y.\n     (g (y, x) + (f (y, x) - g (x, y))) * indicator \\<^bold>E (y, x))\n\ngoal (1 subgoal):\n 1. d_OUT g x \\<noteq> \\<top> \\<Longrightarrow>\n    d_IN (f \\<oplus> g) x =\n    d_IN f x + (\\<Sum>\\<^sup>+ y. g (y, x) * indicator \\<^bold>E (y, x)) -\n    (\\<Sum>\\<^sup>+ y. g (x, y) * indicator \\<^bold>E (y, x))", "have \"\\<dots> = (\\<Sum>\\<^sup>+ y\\<in>UNIV. g (y, x) * indicator \\<^bold>E (y, x)) + (\\<Sum>\\<^sup>+ y. (f (y, x) - g (x, y)) * indicator \\<^bold>E (y, x))\"\n    (is \"_ = _ + ?rest\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y.\n       (g (y, x) + (f (y, x) - g (x, y))) * indicator \\<^bold>E (y, x)) =\n    (\\<Sum>\\<^sup>+ y. g (y, x) * indicator \\<^bold>E (y, x)) +\n    (\\<Sum>\\<^sup>+ y. (f (y, x) - g (x, y)) * indicator \\<^bold>E (y, x))", "by(subst nn_integral_add[symmetric])(auto simp add: AE_count_space g_le_f split: split_indicator intro!: nn_integral_cong)"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y.\n     (g (y, x) + (f (y, x) - g (x, y))) * indicator \\<^bold>E (y, x)) =\n  (\\<Sum>\\<^sup>+ y. g (y, x) * indicator \\<^bold>E (y, x)) +\n  (\\<Sum>\\<^sup>+ y. (f (y, x) - g (x, y)) * indicator \\<^bold>E (y, x))\n\ngoal (1 subgoal):\n 1. d_OUT g x \\<noteq> \\<top> \\<Longrightarrow>\n    d_IN (f \\<oplus> g) x =\n    d_IN f x + (\\<Sum>\\<^sup>+ y. g (y, x) * indicator \\<^bold>E (y, x)) -\n    (\\<Sum>\\<^sup>+ y. g (x, y) * indicator \\<^bold>E (y, x))", "also"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y.\n     (g (y, x) + (f (y, x) - g (x, y))) * indicator \\<^bold>E (y, x)) =\n  (\\<Sum>\\<^sup>+ y. g (y, x) * indicator \\<^bold>E (y, x)) +\n  (\\<Sum>\\<^sup>+ y. (f (y, x) - g (x, y)) * indicator \\<^bold>E (y, x))\n\ngoal (1 subgoal):\n 1. d_OUT g x \\<noteq> \\<top> \\<Longrightarrow>\n    d_IN (f \\<oplus> g) x =\n    d_IN f x + (\\<Sum>\\<^sup>+ y. g (y, x) * indicator \\<^bold>E (y, x)) -\n    (\\<Sum>\\<^sup>+ y. g (x, y) * indicator \\<^bold>E (y, x))", "have \"?rest = (\\<Sum>\\<^sup>+ y. f (y, x) * indicator \\<^bold>E (y, x))- ?g_in'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y. (f (y, x) - g (x, y)) * indicator \\<^bold>E (y, x)) =\n    (\\<Sum>\\<^sup>+ y. f (y, x) * indicator \\<^bold>E (y, x)) -\n    (\\<Sum>\\<^sup>+ y. g (x, y) * indicator \\<^bold>E (y, x))", "by(subst nn_integral_diff[symmetric])(auto intro!: nn_integral_cong split: split_indicator simp add: add_ac add_diff_eq_ennreal AE_count_space g_le_f finite2)"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y. (f (y, x) - g (x, y)) * indicator \\<^bold>E (y, x)) =\n  (\\<Sum>\\<^sup>+ y. f (y, x) * indicator \\<^bold>E (y, x)) -\n  (\\<Sum>\\<^sup>+ y. g (x, y) * indicator \\<^bold>E (y, x))\n\ngoal (1 subgoal):\n 1. d_OUT g x \\<noteq> \\<top> \\<Longrightarrow>\n    d_IN (f \\<oplus> g) x =\n    d_IN f x + (\\<Sum>\\<^sup>+ y. g (y, x) * indicator \\<^bold>E (y, x)) -\n    (\\<Sum>\\<^sup>+ y. g (x, y) * indicator \\<^bold>E (y, x))", "also"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y. (f (y, x) - g (x, y)) * indicator \\<^bold>E (y, x)) =\n  (\\<Sum>\\<^sup>+ y. f (y, x) * indicator \\<^bold>E (y, x)) -\n  (\\<Sum>\\<^sup>+ y. g (x, y) * indicator \\<^bold>E (y, x))\n\ngoal (1 subgoal):\n 1. d_OUT g x \\<noteq> \\<top> \\<Longrightarrow>\n    d_IN (f \\<oplus> g) x =\n    d_IN f x + (\\<Sum>\\<^sup>+ y. g (y, x) * indicator \\<^bold>E (y, x)) -\n    (\\<Sum>\\<^sup>+ y. g (x, y) * indicator \\<^bold>E (y, x))", "have \"(\\<Sum>\\<^sup>+ y. f (y, x) * indicator \\<^bold>E (y, x)) = d_IN f x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y. f (y, x) * indicator \\<^bold>E (y, x)) = d_IN f x", "unfolding d_IN_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y. f (y, x) * indicator \\<^bold>E (y, x)) =\n    (\\<Sum>\\<^sup>+ xa. f (xa, x))", "using f_outside"], ["proof (prove)\nusing this:\n  ?e \\<notin> \\<^bold>E \\<Longrightarrow> f ?e = 0\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y. f (y, x) * indicator \\<^bold>E (y, x)) =\n    (\\<Sum>\\<^sup>+ xa. f (xa, x))", "by(auto intro!: nn_integral_cong split: split_indicator)"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y. f (y, x) * indicator \\<^bold>E (y, x)) = d_IN f x\n\ngoal (1 subgoal):\n 1. d_OUT g x \\<noteq> \\<top> \\<Longrightarrow>\n    d_IN (f \\<oplus> g) x =\n    d_IN f x + (\\<Sum>\\<^sup>+ y. g (y, x) * indicator \\<^bold>E (y, x)) -\n    (\\<Sum>\\<^sup>+ y. g (x, y) * indicator \\<^bold>E (y, x))", "also"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y. f (y, x) * indicator \\<^bold>E (y, x)) = d_IN f x\n\ngoal (1 subgoal):\n 1. d_OUT g x \\<noteq> \\<top> \\<Longrightarrow>\n    d_IN (f \\<oplus> g) x =\n    d_IN f x + (\\<Sum>\\<^sup>+ y. g (y, x) * indicator \\<^bold>E (y, x)) -\n    (\\<Sum>\\<^sup>+ y. g (x, y) * indicator \\<^bold>E (y, x))", "have \"(\\<Sum>\\<^sup>+ y. g (y, x) * indicator \\<^bold>E (y, x)) + (d_IN f x - (\\<Sum>\\<^sup>+ y. g (x, y) * indicator \\<^bold>E (y, x))) =\n     d_IN f x + ?g_in - ?g_in'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y. g (y, x) * indicator \\<^bold>E (y, x)) +\n    (d_IN f x - (\\<Sum>\\<^sup>+ y. g (x, y) * indicator \\<^bold>E (y, x))) =\n    d_IN f x + (\\<Sum>\\<^sup>+ y. g (y, x) * indicator \\<^bold>E (y, x)) -\n    (\\<Sum>\\<^sup>+ y. g (x, y) * indicator \\<^bold>E (y, x))", "by (subst ennreal_diff_add_assoc[symmetric])\n        (auto simp: ac_simps d_IN_def intro!: nn_integral_mono g_le_f split: split_indicator)"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y. g (y, x) * indicator \\<^bold>E (y, x)) +\n  (d_IN f x - (\\<Sum>\\<^sup>+ y. g (x, y) * indicator \\<^bold>E (y, x))) =\n  d_IN f x + (\\<Sum>\\<^sup>+ y. g (y, x) * indicator \\<^bold>E (y, x)) -\n  (\\<Sum>\\<^sup>+ y. g (x, y) * indicator \\<^bold>E (y, x))\n\ngoal (1 subgoal):\n 1. d_OUT g x \\<noteq> \\<top> \\<Longrightarrow>\n    d_IN (f \\<oplus> g) x =\n    d_IN f x + (\\<Sum>\\<^sup>+ y. g (y, x) * indicator \\<^bold>E (y, x)) -\n    (\\<Sum>\\<^sup>+ y. g (x, y) * indicator \\<^bold>E (y, x))", "finally"], ["proof (chain)\npicking this:\n  d_IN (f \\<oplus> g) x =\n  d_IN f x + (\\<Sum>\\<^sup>+ y. g (y, x) * indicator \\<^bold>E (y, x)) -\n  (\\<Sum>\\<^sup>+ y. g (x, y) * indicator \\<^bold>E (y, x))", "show ?IN"], ["proof (prove)\nusing this:\n  d_IN (f \\<oplus> g) x =\n  d_IN f x + (\\<Sum>\\<^sup>+ y. g (y, x) * indicator \\<^bold>E (y, x)) -\n  (\\<Sum>\\<^sup>+ y. g (x, y) * indicator \\<^bold>E (y, x))\n\ngoal (1 subgoal):\n 1. d_IN (f \\<oplus> g) x =\n    d_IN f x + (\\<Sum>\\<^sup>+ y. g (y, x) * indicator \\<^bold>E (y, x)) -\n    (\\<Sum>\\<^sup>+ y. g (x, y) * indicator \\<^bold>E (y, x))", "."], ["proof (state)\nthis:\n  d_IN (f \\<oplus> g) x =\n  d_IN f x + (\\<Sum>\\<^sup>+ y. g (y, x) * indicator \\<^bold>E (y, x)) -\n  (\\<Sum>\\<^sup>+ y. g (x, y) * indicator \\<^bold>E (y, x))\n\ngoal:\nNo subgoals!", "qed"], ["", "context countable_network begin"], ["", "lemma d_IN_plus_flow:\n  assumes wf: \"wf_residual_network\"\n  and f: \"flow \\<Delta> f\"\n  and g: \"flow (residual_network f) g\"\n  shows \"d_IN (f \\<oplus> g) x \\<le> d_IN f x + d_IN g x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN (f \\<oplus> g) x \\<le> d_IN f x + d_IN g x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. d_IN (f \\<oplus> g) x \\<le> d_IN f x + d_IN g x", "have \"d_IN (f \\<oplus> g) x \\<le> (\\<Sum>\\<^sup>+ y. f (y, x) + g (y, x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN (f \\<oplus> g) x \\<le> (\\<Sum>\\<^sup>+ y. f (y, x) + g (y, x))", "unfolding d_IN_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ xa. (f \\<oplus> g) (xa, x))\n    \\<le> (\\<Sum>\\<^sup>+ y. f (y, x) + g (y, x))", "by(rule nn_integral_mono)(auto intro: diff_le_self_ennreal)"], ["proof (state)\nthis:\n  d_IN (f \\<oplus> g) x \\<le> (\\<Sum>\\<^sup>+ y. f (y, x) + g (y, x))\n\ngoal (1 subgoal):\n 1. d_IN (f \\<oplus> g) x \\<le> d_IN f x + d_IN g x", "also"], ["proof (state)\nthis:\n  d_IN (f \\<oplus> g) x \\<le> (\\<Sum>\\<^sup>+ y. f (y, x) + g (y, x))\n\ngoal (1 subgoal):\n 1. d_IN (f \\<oplus> g) x \\<le> d_IN f x + d_IN g x", "have \"\\<dots> = d_IN f x + d_IN g x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y. f (y, x) + g (y, x)) = d_IN f x + d_IN g x", "by(subst nn_integral_add)(simp_all add: d_IN_def)"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y. f (y, x) + g (y, x)) = d_IN f x + d_IN g x\n\ngoal (1 subgoal):\n 1. d_IN (f \\<oplus> g) x \\<le> d_IN f x + d_IN g x", "finally"], ["proof (chain)\npicking this:\n  d_IN (f \\<oplus> g) x \\<le> d_IN f x + d_IN g x", "show ?thesis"], ["proof (prove)\nusing this:\n  d_IN (f \\<oplus> g) x \\<le> d_IN f x + d_IN g x\n\ngoal (1 subgoal):\n 1. d_IN (f \\<oplus> g) x \\<le> d_IN f x + d_IN g x", "."], ["proof (state)\nthis:\n  d_IN (f \\<oplus> g) x \\<le> d_IN f x + d_IN g x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma scale_flow:\n  assumes f: \"flow \\<Delta> f\"\n  and c: \"c \\<le> 1\"\n  shows \"flow \\<Delta> (\\<lambda>e. c * f e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. flow \\<Delta> (\\<lambda>e. c * f e)", "proof(intro flow.intros)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>e. c * f e \\<le> capacity \\<Delta> e\n 2. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>;\n        x \\<noteq> sink \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> KIR (\\<lambda>e. c * f e) x", "fix e"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>e. c * f e \\<le> capacity \\<Delta> e\n 2. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>;\n        x \\<noteq> sink \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> KIR (\\<lambda>e. c * f e) x", "from c"], ["proof (chain)\npicking this:\n  c \\<le> 1", "have \"c * f e \\<le> 1 * f e\""], ["proof (prove)\nusing this:\n  c \\<le> 1\n\ngoal (1 subgoal):\n 1. c * f e \\<le> 1 * f e", "by(rule mult_right_mono) simp"], ["proof (state)\nthis:\n  c * f e \\<le> 1 * f e\n\ngoal (2 subgoals):\n 1. \\<And>e. c * f e \\<le> capacity \\<Delta> e\n 2. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>;\n        x \\<noteq> sink \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> KIR (\\<lambda>e. c * f e) x", "also"], ["proof (state)\nthis:\n  c * f e \\<le> 1 * f e\n\ngoal (2 subgoals):\n 1. \\<And>e. c * f e \\<le> capacity \\<Delta> e\n 2. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>;\n        x \\<noteq> sink \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> KIR (\\<lambda>e. c * f e) x", "have \"\\<dots> \\<le> capacity \\<Delta> e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 * f e \\<le> capacity \\<Delta> e", "using flowD_capacity[OF f, of e]"], ["proof (prove)\nusing this:\n  f e \\<le> capacity \\<Delta> e\n\ngoal (1 subgoal):\n 1. 1 * f e \\<le> capacity \\<Delta> e", "by simp"], ["proof (state)\nthis:\n  1 * f e \\<le> capacity \\<Delta> e\n\ngoal (2 subgoals):\n 1. \\<And>e. c * f e \\<le> capacity \\<Delta> e\n 2. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>;\n        x \\<noteq> sink \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> KIR (\\<lambda>e. c * f e) x", "finally"], ["proof (chain)\npicking this:\n  c * f e \\<le> capacity \\<Delta> e", "show \"c * f e \\<le> \\<dots>\""], ["proof (prove)\nusing this:\n  c * f e \\<le> capacity \\<Delta> e\n\ngoal (1 subgoal):\n 1. c * f e \\<le> capacity \\<Delta> e", "."], ["proof (state)\nthis:\n  c * f e \\<le> capacity \\<Delta> e\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>;\n        x \\<noteq> sink \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> KIR (\\<lambda>e. c * f e) x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>;\n        x \\<noteq> sink \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> KIR (\\<lambda>e. c * f e) x", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>;\n        x \\<noteq> sink \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> KIR (\\<lambda>e. c * f e) x", "assume x: \"x \\<noteq> source \\<Delta>\" \"x \\<noteq> sink \\<Delta>\""], ["proof (state)\nthis:\n  x \\<noteq> source \\<Delta>\n  x \\<noteq> sink \\<Delta>\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>;\n        x \\<noteq> sink \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> KIR (\\<lambda>e. c * f e) x", "have \"d_OUT (\\<lambda>e. c * f e) x = c * d_OUT f x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT (\\<lambda>e. c * f e) x = c * d_OUT f x", "by(simp add: d_OUT_cmult)"], ["proof (state)\nthis:\n  d_OUT (\\<lambda>e. c * f e) x = c * d_OUT f x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>;\n        x \\<noteq> sink \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> KIR (\\<lambda>e. c * f e) x", "also"], ["proof (state)\nthis:\n  d_OUT (\\<lambda>e. c * f e) x = c * d_OUT f x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>;\n        x \\<noteq> sink \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> KIR (\\<lambda>e. c * f e) x", "have \"d_OUT f x = d_IN f x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. KIR f x", "using f x"], ["proof (prove)\nusing this:\n  flow \\<Delta> f\n  x \\<noteq> source \\<Delta>\n  x \\<noteq> sink \\<Delta>\n\ngoal (1 subgoal):\n 1. KIR f x", "by(rule flowD_KIR)"], ["proof (state)\nthis:\n  KIR f x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>;\n        x \\<noteq> sink \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> KIR (\\<lambda>e. c * f e) x", "also"], ["proof (state)\nthis:\n  KIR f x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>;\n        x \\<noteq> sink \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> KIR (\\<lambda>e. c * f e) x", "have \"c * \\<dots> = d_IN (\\<lambda>e. c * f e) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c * d_IN f x = d_IN (\\<lambda>e. c * f e) x", "by(simp add: d_IN_cmult)"], ["proof (state)\nthis:\n  c * d_IN f x = d_IN (\\<lambda>e. c * f e) x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>;\n        x \\<noteq> sink \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> KIR (\\<lambda>e. c * f e) x", "finally"], ["proof (chain)\npicking this:\n  KIR (\\<lambda>e. c * f e) x", "show \"KIR (\\<lambda>e. c * f e) x\""], ["proof (prove)\nusing this:\n  KIR (\\<lambda>e. c * f e) x\n\ngoal (1 subgoal):\n 1. KIR (\\<lambda>e. c * f e) x", "."], ["proof (state)\nthis:\n  KIR (\\<lambda>e. c * f e) x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma value_scale_flow:\n  \"value_flow \\<Delta> (\\<lambda>e. c * f e) = c * value_flow \\<Delta> f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. value_flow \\<Delta> (\\<lambda>e. c * f e) = c * value_flow \\<Delta> f", "by(rule d_OUT_cmult)"], ["", "lemma value_flow:\n  assumes f: \"flow \\<Delta> f\"\n  and source_out: \"\\<And>y. edge \\<Delta> (source \\<Delta>) y \\<longleftrightarrow> y = x\"\n  shows \"value_flow \\<Delta> f = f (source \\<Delta>, x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. value_flow \\<Delta> f = f (source \\<Delta>, x)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. value_flow \\<Delta> f = f (source \\<Delta>, x)", "have \"value_flow \\<Delta> f = (\\<Sum>\\<^sup>+ y\\<in>\\<^bold>O\\<^bold>U\\<^bold>T (source \\<Delta>). f (source \\<Delta>, y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. value_flow \\<Delta> f =\n    (\\<Sum>\\<^sup>+ y\\<in>\\<^bold>O\\<^bold>U\\<^bold>T (source \\<Delta>).\n       f (source \\<Delta>, y))", "by(rule d_OUT_alt_def)(simp add: flowD_outside[OF f])"], ["proof (state)\nthis:\n  value_flow \\<Delta> f =\n  (\\<Sum>\\<^sup>+ y\\<in>\\<^bold>O\\<^bold>U\\<^bold>T (source \\<Delta>).\n     f (source \\<Delta>, y))\n\ngoal (1 subgoal):\n 1. value_flow \\<Delta> f = f (source \\<Delta>, x)", "also"], ["proof (state)\nthis:\n  value_flow \\<Delta> f =\n  (\\<Sum>\\<^sup>+ y\\<in>\\<^bold>O\\<^bold>U\\<^bold>T (source \\<Delta>).\n     f (source \\<Delta>, y))\n\ngoal (1 subgoal):\n 1. value_flow \\<Delta> f = f (source \\<Delta>, x)", "have \"\\<dots> = (\\<Sum>\\<^sup>+ y. f (source \\<Delta>, y) * indicator {x} y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y\\<in>\\<^bold>O\\<^bold>U\\<^bold>T (source \\<Delta>).\n       f (source \\<Delta>, y)) =\n    \\<integral>\\<^sup>+y\\<in>{x}. f (source \\<Delta>, y)\n    \\<partial>count_space UNIV", "by(subst nn_integral_count_space_indicator)(auto intro!: nn_integral_cong split: split_indicator simp add: outgoing_def source_out)"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y\\<in>\\<^bold>O\\<^bold>U\\<^bold>T (source \\<Delta>).\n     f (source \\<Delta>, y)) =\n  \\<integral>\\<^sup>+y\\<in>{x}. f (source \\<Delta>, y)\n  \\<partial>count_space UNIV\n\ngoal (1 subgoal):\n 1. value_flow \\<Delta> f = f (source \\<Delta>, x)", "also"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y\\<in>\\<^bold>O\\<^bold>U\\<^bold>T (source \\<Delta>).\n     f (source \\<Delta>, y)) =\n  \\<integral>\\<^sup>+y\\<in>{x}. f (source \\<Delta>, y)\n  \\<partial>count_space UNIV\n\ngoal (1 subgoal):\n 1. value_flow \\<Delta> f = f (source \\<Delta>, x)", "have \"\\<dots> = f (source \\<Delta>, x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+y\\<in>{x}. f (source \\<Delta>, y)\n    \\<partial>count_space UNIV =\n    f (source \\<Delta>, x)", "by(simp add: one_ennreal_def[symmetric] max_def)"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+y\\<in>{x}. f (source \\<Delta>, y)\n  \\<partial>count_space UNIV =\n  f (source \\<Delta>, x)\n\ngoal (1 subgoal):\n 1. value_flow \\<Delta> f = f (source \\<Delta>, x)", "finally"], ["proof (chain)\npicking this:\n  value_flow \\<Delta> f = f (source \\<Delta>, x)", "show ?thesis"], ["proof (prove)\nusing this:\n  value_flow \\<Delta> f = f (source \\<Delta>, x)\n\ngoal (1 subgoal):\n 1. value_flow \\<Delta> f = f (source \\<Delta>, x)", "."], ["proof (state)\nthis:\n  value_flow \\<Delta> f = f (source \\<Delta>, x)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "context flow_attainability begin"], ["", "lemma value_plus_flow:\n  assumes wf: \"wf_residual_network\"\n  and f: \"flow \\<Delta> f\"\n  and g: \"flow (residual_network f) g\"\n  shows \"value_flow \\<Delta> (f \\<oplus> g) = value_flow \\<Delta> f + value_flow \\<Delta> g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. value_flow \\<Delta> (f \\<oplus> g) =\n    value_flow \\<Delta> f + value_flow \\<Delta> g", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. value_flow \\<Delta> (f \\<oplus> g) =\n    value_flow \\<Delta> f + value_flow \\<Delta> g", "interpret RES: countable_network \"residual_network f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. countable_network (residual_network f)", "using wf f"], ["proof (prove)\nusing this:\n  wf_residual_network\n  flow \\<Delta> f\n\ngoal (1 subgoal):\n 1. countable_network (residual_network f)", "by(rule residual_countable_network)"], ["proof (state)\ngoal (1 subgoal):\n 1. value_flow \\<Delta> (f \\<oplus> g) =\n    value_flow \\<Delta> f + value_flow \\<Delta> g", "have \"value_flow \\<Delta> (f \\<oplus> g) = (\\<Sum>\\<^sup>+ y. f (source \\<Delta>, y) + g (source \\<Delta>, y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. value_flow \\<Delta> (f \\<oplus> g) =\n    (\\<Sum>\\<^sup>+ y. f (source \\<Delta>, y) + g (source \\<Delta>, y))", "unfolding d_OUT_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y. (f \\<oplus> g) (source \\<Delta>, y)) =\n    (\\<Sum>\\<^sup>+ y. f (source \\<Delta>, y) + g (source \\<Delta>, y))", "by(rule nn_integral_cong)(simp add: flowD_outside[OF f] RES.flowD_outside[OF g] source_in)"], ["proof (state)\nthis:\n  value_flow \\<Delta> (f \\<oplus> g) =\n  (\\<Sum>\\<^sup>+ y. f (source \\<Delta>, y) + g (source \\<Delta>, y))\n\ngoal (1 subgoal):\n 1. value_flow \\<Delta> (f \\<oplus> g) =\n    value_flow \\<Delta> f + value_flow \\<Delta> g", "also"], ["proof (state)\nthis:\n  value_flow \\<Delta> (f \\<oplus> g) =\n  (\\<Sum>\\<^sup>+ y. f (source \\<Delta>, y) + g (source \\<Delta>, y))\n\ngoal (1 subgoal):\n 1. value_flow \\<Delta> (f \\<oplus> g) =\n    value_flow \\<Delta> f + value_flow \\<Delta> g", "have \"\\<dots> = value_flow \\<Delta> f + value_flow \\<Delta> g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y. f (source \\<Delta>, y) + g (source \\<Delta>, y)) =\n    value_flow \\<Delta> f + value_flow \\<Delta> g", "unfolding d_OUT_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y. f (source \\<Delta>, y) + g (source \\<Delta>, y)) =\n    (\\<Sum>\\<^sup>+ y. f (source \\<Delta>, y)) +\n    (\\<Sum>\\<^sup>+ y. g (source \\<Delta>, y))", "by(rule nn_integral_add) simp_all"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y. f (source \\<Delta>, y) + g (source \\<Delta>, y)) =\n  value_flow \\<Delta> f + value_flow \\<Delta> g\n\ngoal (1 subgoal):\n 1. value_flow \\<Delta> (f \\<oplus> g) =\n    value_flow \\<Delta> f + value_flow \\<Delta> g", "finally"], ["proof (chain)\npicking this:\n  value_flow \\<Delta> (f \\<oplus> g) =\n  value_flow \\<Delta> f + value_flow \\<Delta> g", "show ?thesis"], ["proof (prove)\nusing this:\n  value_flow \\<Delta> (f \\<oplus> g) =\n  value_flow \\<Delta> f + value_flow \\<Delta> g\n\ngoal (1 subgoal):\n 1. value_flow \\<Delta> (f \\<oplus> g) =\n    value_flow \\<Delta> f + value_flow \\<Delta> g", "."], ["proof (state)\nthis:\n  value_flow \\<Delta> (f \\<oplus> g) =\n  value_flow \\<Delta> f + value_flow \\<Delta> g\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma flow_residual_add: \\<comment> \\<open>Lemma 5.3\\<close>\n  assumes wf: \"wf_residual_network\"\n  and f: \"flow \\<Delta> f\"\n  and g: \"flow (residual_network f) g\"\n  shows \"flow \\<Delta> (f \\<oplus> g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. flow \\<Delta> (f \\<oplus> g)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>e. (f \\<oplus> g) e \\<le> capacity \\<Delta> e\n 2. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>;\n        x \\<noteq> sink \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> KIR (f \\<oplus> g) x", "fix e"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>e. (f \\<oplus> g) e \\<le> capacity \\<Delta> e\n 2. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>;\n        x \\<noteq> sink \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> KIR (f \\<oplus> g) x", "{"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>e. (f \\<oplus> g) e \\<le> capacity \\<Delta> e\n 2. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>;\n        x \\<noteq> sink \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> KIR (f \\<oplus> g) x", "assume e: \"e \\<in> \\<^bold>E\""], ["proof (state)\nthis:\n  e \\<in> \\<^bold>E\n\ngoal (2 subgoals):\n 1. \\<And>e. (f \\<oplus> g) e \\<le> capacity \\<Delta> e\n 2. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>;\n        x \\<noteq> sink \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> KIR (f \\<oplus> g) x", "hence \"(f \\<oplus> g) e = f e + g e - g (prod.swap e)\""], ["proof (prove)\nusing this:\n  e \\<in> \\<^bold>E\n\ngoal (1 subgoal):\n 1. (f \\<oplus> g) e = f e + g e - g (prod.swap e)", "by(cases e) simp"], ["proof (state)\nthis:\n  (f \\<oplus> g) e = f e + g e - g (prod.swap e)\n\ngoal (2 subgoals):\n 1. \\<And>e. (f \\<oplus> g) e \\<le> capacity \\<Delta> e\n 2. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>;\n        x \\<noteq> sink \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> KIR (f \\<oplus> g) x", "also"], ["proof (state)\nthis:\n  (f \\<oplus> g) e = f e + g e - g (prod.swap e)\n\ngoal (2 subgoals):\n 1. \\<And>e. (f \\<oplus> g) e \\<le> capacity \\<Delta> e\n 2. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>;\n        x \\<noteq> sink \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> KIR (f \\<oplus> g) x", "have \"\\<dots> \\<le> f e + g e - 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f e + g e - g (prod.swap e) \\<le> f e + g e - 0", "by(rule ennreal_minus_mono) simp_all"], ["proof (state)\nthis:\n  f e + g e - g (prod.swap e) \\<le> f e + g e - 0\n\ngoal (2 subgoals):\n 1. \\<And>e. (f \\<oplus> g) e \\<le> capacity \\<Delta> e\n 2. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>;\n        x \\<noteq> sink \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> KIR (f \\<oplus> g) x", "also"], ["proof (state)\nthis:\n  f e + g e - g (prod.swap e) \\<le> f e + g e - 0\n\ngoal (2 subgoals):\n 1. \\<And>e. (f \\<oplus> g) e \\<le> capacity \\<Delta> e\n 2. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>;\n        x \\<noteq> sink \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> KIR (f \\<oplus> g) x", "have \"\\<dots> \\<le> f e + (capacity \\<Delta> e - f e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f e + g e - 0 \\<le> f e + (capacity \\<Delta> e - f e)", "using e flowD_capacity[OF g, of e]"], ["proof (prove)\nusing this:\n  e \\<in> \\<^bold>E\n  g e \\<le> capacity (residual_network f) e\n\ngoal (1 subgoal):\n 1. f e + g e - 0 \\<le> f e + (capacity \\<Delta> e - f e)", "by(simp split: prod.split_asm add: add_mono)"], ["proof (state)\nthis:\n  f e + g e - 0 \\<le> f e + (capacity \\<Delta> e - f e)\n\ngoal (2 subgoals):\n 1. \\<And>e. (f \\<oplus> g) e \\<le> capacity \\<Delta> e\n 2. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>;\n        x \\<noteq> sink \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> KIR (f \\<oplus> g) x", "also"], ["proof (state)\nthis:\n  f e + g e - 0 \\<le> f e + (capacity \\<Delta> e - f e)\n\ngoal (2 subgoals):\n 1. \\<And>e. (f \\<oplus> g) e \\<le> capacity \\<Delta> e\n 2. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>;\n        x \\<noteq> sink \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> KIR (f \\<oplus> g) x", "have \"\\<dots> = capacity \\<Delta> e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f e + (capacity \\<Delta> e - f e) = capacity \\<Delta> e", "using flowD_capacity[OF f, of e]"], ["proof (prove)\nusing this:\n  f e \\<le> capacity \\<Delta> e\n\ngoal (1 subgoal):\n 1. f e + (capacity \\<Delta> e - f e) = capacity \\<Delta> e", "by simp"], ["proof (state)\nthis:\n  f e + (capacity \\<Delta> e - f e) = capacity \\<Delta> e\n\ngoal (2 subgoals):\n 1. \\<And>e. (f \\<oplus> g) e \\<le> capacity \\<Delta> e\n 2. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>;\n        x \\<noteq> sink \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> KIR (f \\<oplus> g) x", "also"], ["proof (state)\nthis:\n  f e + (capacity \\<Delta> e - f e) = capacity \\<Delta> e\n\ngoal (2 subgoals):\n 1. \\<And>e. (f \\<oplus> g) e \\<le> capacity \\<Delta> e\n 2. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>;\n        x \\<noteq> sink \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> KIR (f \\<oplus> g) x", "note calculation"], ["proof (state)\nthis:\n  (f \\<oplus> g) e \\<le> capacity \\<Delta> e\n\ngoal (2 subgoals):\n 1. \\<And>e. (f \\<oplus> g) e \\<le> capacity \\<Delta> e\n 2. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>;\n        x \\<noteq> sink \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> KIR (f \\<oplus> g) x", "}"], ["proof (state)\nthis:\n  e \\<in> \\<^bold>E \\<Longrightarrow>\n  (f \\<oplus> g) e \\<le> capacity \\<Delta> e\n\ngoal (2 subgoals):\n 1. \\<And>e. (f \\<oplus> g) e \\<le> capacity \\<Delta> e\n 2. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>;\n        x \\<noteq> sink \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> KIR (f \\<oplus> g) x", "thus \"(f \\<oplus> g) e \\<le> capacity \\<Delta> e\""], ["proof (prove)\nusing this:\n  e \\<in> \\<^bold>E \\<Longrightarrow>\n  (f \\<oplus> g) e \\<le> capacity \\<Delta> e\n\ngoal (1 subgoal):\n 1. (f \\<oplus> g) e \\<le> capacity \\<Delta> e", "by(cases e) auto"], ["proof (state)\nthis:\n  (f \\<oplus> g) e \\<le> capacity \\<Delta> e\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>;\n        x \\<noteq> sink \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> KIR (f \\<oplus> g) x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>;\n        x \\<noteq> sink \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> KIR (f \\<oplus> g) x", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>;\n        x \\<noteq> sink \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> KIR (f \\<oplus> g) x", "assume x: \"x \\<noteq> source \\<Delta>\" \"x \\<noteq> sink \\<Delta>\""], ["proof (state)\nthis:\n  x \\<noteq> source \\<Delta>\n  x \\<noteq> sink \\<Delta>\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>;\n        x \\<noteq> sink \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> KIR (f \\<oplus> g) x", "have g_le_f: \"g (y, x) \\<le> f (x, y)\" if \"edge \\<Delta> x y\" for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. g (y, x) \\<le> f (x, y)", "using that flowD_capacity[OF g, of \"(y, x)\"]"], ["proof (prove)\nusing this:\n  edge \\<Delta> x y\n  g (y, x) \\<le> capacity (residual_network f) (y, x)\n\ngoal (1 subgoal):\n 1. g (y, x) \\<le> f (x, y)", "by(auto split: if_split_asm dest: wf_residual_networkD[OF wf] elim: order_trans)"], ["proof (state)\nthis:\n  edge \\<Delta> ?x ?y \\<Longrightarrow> g (?y, ?x) \\<le> f (?x, ?y)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>;\n        x \\<noteq> sink \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> KIR (f \\<oplus> g) x", "interpret RES: flow_attainability \"residual_network f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. flow_attainability (residual_network f)", "using wf f"], ["proof (prove)\nusing this:\n  wf_residual_network\n  flow \\<Delta> f\n\ngoal (1 subgoal):\n 1. flow_attainability (residual_network f)", "by(rule residual_flow_attainability)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>;\n        x \\<noteq> sink \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> KIR (f \\<oplus> g) x", "have finite1: \"(\\<Sum>\\<^sup>+ y. g (y, x) * indicator A (f y)) \\<noteq> \\<top>\" for A f"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y. g (y, x) * indicator A (f y)) \\<noteq> \\<top>", "using RES.flowD_finite_IN[OF g, of x]"], ["proof (prove)\nusing this:\n  x \\<noteq> sink (residual_network f) \\<Longrightarrow>\n  d_IN g x \\<noteq> \\<top>\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y. g (y, x) * indicator A (f y)) \\<noteq> \\<top>", "by(rule neq_top_trans)(auto simp add: x d_IN_def split: split_indicator intro: nn_integral_mono)"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y. g (y, x) * indicator ?A1 (?f1 y)) \\<noteq> \\<top>\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>;\n        x \\<noteq> sink \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> KIR (f \\<oplus> g) x", "have finite2: \"(\\<Sum>\\<^sup>+ y. g (x, y) * indicator A (f y)) \\<noteq> \\<top>\" for A f"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y. g (x, y) * indicator A (f y)) \\<noteq> \\<top>", "using RES.flowD_finite_OUT[OF g, of x]"], ["proof (prove)\nusing this:\n  \\<lbrakk>x \\<noteq> source (residual_network f);\n   x \\<noteq> sink (residual_network f)\\<rbrakk>\n  \\<Longrightarrow> d_OUT g x \\<noteq> \\<top>\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y. g (x, y) * indicator A (f y)) \\<noteq> \\<top>", "by(rule neq_top_trans)(auto simp add: x d_OUT_def split: split_indicator intro: nn_integral_mono)"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y. g (x, y) * indicator ?A2 (?f2 y)) \\<noteq> \\<top>\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>;\n        x \\<noteq> sink \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> KIR (f \\<oplus> g) x", "have \"d_OUT (f \\<oplus> g) x = d_OUT f x + (\\<Sum>\\<^sup>+ y. g (x, y) * indicator \\<^bold>E (x, y)) - (\\<Sum>\\<^sup>+ y. g (y, x) * indicator \\<^bold>E (x, y))\"\n    (is \"_ = ?f + ?g_out - ?g_in\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT (f \\<oplus> g) x =\n    d_OUT f x + (\\<Sum>\\<^sup>+ y. g (x, y) * indicator \\<^bold>E (x, y)) -\n    (\\<Sum>\\<^sup>+ y. g (y, x) * indicator \\<^bold>E (x, y))", "using flowD_outside[OF f] g_le_f RES.flowD_finite_IN[OF g, of x]"], ["proof (prove)\nusing this:\n  ?e \\<notin> \\<^bold>E \\<Longrightarrow> f ?e = 0\n  edge \\<Delta> ?x ?y \\<Longrightarrow> g (?y, ?x) \\<le> f (?x, ?y)\n  x \\<noteq> sink (residual_network f) \\<Longrightarrow>\n  d_IN g x \\<noteq> \\<top>\n\ngoal (1 subgoal):\n 1. d_OUT (f \\<oplus> g) x =\n    d_OUT f x + (\\<Sum>\\<^sup>+ y. g (x, y) * indicator \\<^bold>E (x, y)) -\n    (\\<Sum>\\<^sup>+ y. g (y, x) * indicator \\<^bold>E (x, y))", "by(rule OUT_plus_flow)(simp_all add: x)"], ["proof (state)\nthis:\n  d_OUT (f \\<oplus> g) x =\n  d_OUT f x + (\\<Sum>\\<^sup>+ y. g (x, y) * indicator \\<^bold>E (x, y)) -\n  (\\<Sum>\\<^sup>+ y. g (y, x) * indicator \\<^bold>E (x, y))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>;\n        x \\<noteq> sink \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> KIR (f \\<oplus> g) x", "also"], ["proof (state)\nthis:\n  d_OUT (f \\<oplus> g) x =\n  d_OUT f x + (\\<Sum>\\<^sup>+ y. g (x, y) * indicator \\<^bold>E (x, y)) -\n  (\\<Sum>\\<^sup>+ y. g (y, x) * indicator \\<^bold>E (x, y))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>;\n        x \\<noteq> sink \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> KIR (f \\<oplus> g) x", "have \"?f = d_IN f x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. KIR f x", "using f x"], ["proof (prove)\nusing this:\n  flow \\<Delta> f\n  x \\<noteq> source \\<Delta>\n  x \\<noteq> sink \\<Delta>\n\ngoal (1 subgoal):\n 1. KIR f x", "by(auto dest: flowD_KIR)"], ["proof (state)\nthis:\n  KIR f x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>;\n        x \\<noteq> sink \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> KIR (f \\<oplus> g) x", "also"], ["proof (state)\nthis:\n  KIR f x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>;\n        x \\<noteq> sink \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> KIR (f \\<oplus> g) x", "have \"?g_out = (\\<Sum>\\<^sup>+ y. g (x, y) * indicator (- \\<^bold>E) (y, x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y. g (x, y) * indicator \\<^bold>E (x, y)) =\n    (\\<Sum>\\<^sup>+ y. g (x, y) * indicator (- \\<^bold>E) (y, x))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y. g (x, y) * indicator \\<^bold>E (x, y)) =\n    (\\<Sum>\\<^sup>+ y. g (x, y) * indicator (- \\<^bold>E) (y, x))", "have \"(\\<Sum>\\<^sup>+ y. g (x, y) * indicator (- \\<^bold>E) (y, x)) =\n          (\\<Sum>\\<^sup>+ y. g (x, y) * indicator \\<^bold>E (x, y)) + (\\<Sum>\\<^sup>+ y. g (x, y) * indicator (- \\<^bold>E) (x, y) * indicator (- \\<^bold>E) (y, x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y. g (x, y) * indicator (- \\<^bold>E) (y, x)) =\n    (\\<Sum>\\<^sup>+ y. g (x, y) * indicator \\<^bold>E (x, y)) +\n    (\\<Sum>\\<^sup>+ y.\n       g (x, y) * indicator (- \\<^bold>E) (x, y) *\n       indicator (- \\<^bold>E) (y, x))", "by(subst nn_integral_add[symmetric])(auto simp add: AE_count_space dest: wf_residual_networkD[OF wf] split: split_indicator intro!: nn_integral_cong)"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y. g (x, y) * indicator (- \\<^bold>E) (y, x)) =\n  (\\<Sum>\\<^sup>+ y. g (x, y) * indicator \\<^bold>E (x, y)) +\n  (\\<Sum>\\<^sup>+ y.\n     g (x, y) * indicator (- \\<^bold>E) (x, y) *\n     indicator (- \\<^bold>E) (y, x))\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y. g (x, y) * indicator \\<^bold>E (x, y)) =\n    (\\<Sum>\\<^sup>+ y. g (x, y) * indicator (- \\<^bold>E) (y, x))", "also"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y. g (x, y) * indicator (- \\<^bold>E) (y, x)) =\n  (\\<Sum>\\<^sup>+ y. g (x, y) * indicator \\<^bold>E (x, y)) +\n  (\\<Sum>\\<^sup>+ y.\n     g (x, y) * indicator (- \\<^bold>E) (x, y) *\n     indicator (- \\<^bold>E) (y, x))\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y. g (x, y) * indicator \\<^bold>E (x, y)) =\n    (\\<Sum>\\<^sup>+ y. g (x, y) * indicator (- \\<^bold>E) (y, x))", "have \"(\\<Sum>\\<^sup>+ y. g (x, y) * indicator (- \\<^bold>E) (x, y) * indicator (- \\<^bold>E) (y, x)) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y.\n       g (x, y) * indicator (- \\<^bold>E) (x, y) *\n       indicator (- \\<^bold>E) (y, x)) =\n    0", "using RES.flowD_outside[OF g]"], ["proof (prove)\nusing this:\n  ?e \\<notin> \\<^bold>E\\<^bsub>residual_network f\\<^esub> \\<Longrightarrow>\n  g ?e = 0\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y.\n       g (x, y) * indicator (- \\<^bold>E) (x, y) *\n       indicator (- \\<^bold>E) (y, x)) =\n    0", "by(auto simp add: nn_integral_0_iff_AE AE_count_space split: split_indicator)"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y.\n     g (x, y) * indicator (- \\<^bold>E) (x, y) *\n     indicator (- \\<^bold>E) (y, x)) =\n  0\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y. g (x, y) * indicator \\<^bold>E (x, y)) =\n    (\\<Sum>\\<^sup>+ y. g (x, y) * indicator (- \\<^bold>E) (y, x))", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>\\<^sup>+ y. g (x, y) * indicator (- \\<^bold>E) (y, x)) =\n  (\\<Sum>\\<^sup>+ y. g (x, y) * indicator \\<^bold>E (x, y)) + 0", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<Sum>\\<^sup>+ y. g (x, y) * indicator (- \\<^bold>E) (y, x)) =\n  (\\<Sum>\\<^sup>+ y. g (x, y) * indicator \\<^bold>E (x, y)) + 0\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y. g (x, y) * indicator \\<^bold>E (x, y)) =\n    (\\<Sum>\\<^sup>+ y. g (x, y) * indicator (- \\<^bold>E) (y, x))", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y. g (x, y) * indicator \\<^bold>E (x, y)) =\n  (\\<Sum>\\<^sup>+ y. g (x, y) * indicator (- \\<^bold>E) (y, x))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y. g (x, y) * indicator \\<^bold>E (x, y)) =\n  (\\<Sum>\\<^sup>+ y. g (x, y) * indicator (- \\<^bold>E) (y, x))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>;\n        x \\<noteq> sink \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> KIR (f \\<oplus> g) x", "also"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y. g (x, y) * indicator \\<^bold>E (x, y)) =\n  (\\<Sum>\\<^sup>+ y. g (x, y) * indicator (- \\<^bold>E) (y, x))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>;\n        x \\<noteq> sink \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> KIR (f \\<oplus> g) x", "have \"\\<dots> = (\\<Sum>\\<^sup>+ y. g (x, y) - g (x, y) * indicator \\<^bold>E (y, x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y. g (x, y) * indicator (- \\<^bold>E) (y, x)) =\n    (\\<Sum>\\<^sup>+ y. g (x, y) - g (x, y) * indicator \\<^bold>E (y, x))", "by(rule nn_integral_cong)(simp split: split_indicator add: RES.flowD_finite[OF g])"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y. g (x, y) * indicator (- \\<^bold>E) (y, x)) =\n  (\\<Sum>\\<^sup>+ y. g (x, y) - g (x, y) * indicator \\<^bold>E (y, x))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>;\n        x \\<noteq> sink \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> KIR (f \\<oplus> g) x", "also"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y. g (x, y) * indicator (- \\<^bold>E) (y, x)) =\n  (\\<Sum>\\<^sup>+ y. g (x, y) - g (x, y) * indicator \\<^bold>E (y, x))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>;\n        x \\<noteq> sink \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> KIR (f \\<oplus> g) x", "have \"\\<dots> = d_OUT g x - (\\<Sum>\\<^sup>+ y. g (x, y) * indicator \\<^bold>E (y, x))\"\n    (is \"_ = _ - ?g_in_E\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y. g (x, y) - g (x, y) * indicator \\<^bold>E (y, x)) =\n    d_OUT g x - (\\<Sum>\\<^sup>+ y. g (x, y) * indicator \\<^bold>E (y, x))", "unfolding d_OUT_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y. g (x, y) - g (x, y) * indicator \\<^bold>E (y, x)) =\n    (\\<Sum>\\<^sup>+ y. g (x, y)) -\n    (\\<Sum>\\<^sup>+ y. g (x, y) * indicator \\<^bold>E (y, x))", "by(subst nn_integral_diff)(simp_all add: AE_count_space finite2 split: split_indicator)"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y. g (x, y) - g (x, y) * indicator \\<^bold>E (y, x)) =\n  d_OUT g x - (\\<Sum>\\<^sup>+ y. g (x, y) * indicator \\<^bold>E (y, x))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>;\n        x \\<noteq> sink \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> KIR (f \\<oplus> g) x", "also"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y. g (x, y) - g (x, y) * indicator \\<^bold>E (y, x)) =\n  d_OUT g x - (\\<Sum>\\<^sup>+ y. g (x, y) * indicator \\<^bold>E (y, x))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>;\n        x \\<noteq> sink \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> KIR (f \\<oplus> g) x", "have \"d_IN f x + (d_OUT g x - (\\<Sum>\\<^sup>+ y. g (x, y) * indicator \\<^bold>E (y, x))) - ?g_in =\n    ((d_IN f x + d_OUT g x) - (\\<Sum>\\<^sup>+ y. g (x, y) * indicator \\<^bold>E (y, x))) - ?g_in\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN f x +\n    (d_OUT g x -\n     (\\<Sum>\\<^sup>+ y. g (x, y) * indicator \\<^bold>E (y, x))) -\n    (\\<Sum>\\<^sup>+ y. g (y, x) * indicator \\<^bold>E (x, y)) =\n    d_IN f x + d_OUT g x -\n    (\\<Sum>\\<^sup>+ y. g (x, y) * indicator \\<^bold>E (y, x)) -\n    (\\<Sum>\\<^sup>+ y. g (y, x) * indicator \\<^bold>E (x, y))", "by (subst add_diff_eq_ennreal) (auto simp: d_OUT_def intro!: nn_integral_mono split: split_indicator)"], ["proof (state)\nthis:\n  d_IN f x +\n  (d_OUT g x - (\\<Sum>\\<^sup>+ y. g (x, y) * indicator \\<^bold>E (y, x))) -\n  (\\<Sum>\\<^sup>+ y. g (y, x) * indicator \\<^bold>E (x, y)) =\n  d_IN f x + d_OUT g x -\n  (\\<Sum>\\<^sup>+ y. g (x, y) * indicator \\<^bold>E (y, x)) -\n  (\\<Sum>\\<^sup>+ y. g (y, x) * indicator \\<^bold>E (x, y))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>;\n        x \\<noteq> sink \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> KIR (f \\<oplus> g) x", "also"], ["proof (state)\nthis:\n  d_IN f x +\n  (d_OUT g x - (\\<Sum>\\<^sup>+ y. g (x, y) * indicator \\<^bold>E (y, x))) -\n  (\\<Sum>\\<^sup>+ y. g (y, x) * indicator \\<^bold>E (x, y)) =\n  d_IN f x + d_OUT g x -\n  (\\<Sum>\\<^sup>+ y. g (x, y) * indicator \\<^bold>E (y, x)) -\n  (\\<Sum>\\<^sup>+ y. g (y, x) * indicator \\<^bold>E (x, y))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>;\n        x \\<noteq> sink \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> KIR (f \\<oplus> g) x", "have \"d_OUT g x = d_IN g x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. KIR g x", "using x g"], ["proof (prove)\nusing this:\n  x \\<noteq> source \\<Delta>\n  x \\<noteq> sink \\<Delta>\n  flow (residual_network f) g\n\ngoal (1 subgoal):\n 1. KIR g x", "by(auto dest: flowD_KIR)"], ["proof (state)\nthis:\n  KIR g x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>;\n        x \\<noteq> sink \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> KIR (f \\<oplus> g) x", "also"], ["proof (state)\nthis:\n  KIR g x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>;\n        x \\<noteq> sink \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> KIR (f \\<oplus> g) x", "have \"\\<dots> = (\\<Sum>\\<^sup>+ y\\<in>UNIV. g (y, x) * indicator (- \\<^bold>E) (y, x)) + (\\<Sum>\\<^sup>+ y. g (y, x) * indicator \\<^bold>E (y, x))\"\n    (is \"_ = ?x + ?g_in_E'\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN g x =\n    (\\<Sum>\\<^sup>+ y. g (y, x) * indicator (- \\<^bold>E) (y, x)) +\n    (\\<Sum>\\<^sup>+ y. g (y, x) * indicator \\<^bold>E (y, x))", "by(subst nn_integral_add[symmetric])(auto intro!: nn_integral_cong simp add: d_IN_def AE_count_space split: split_indicator)"], ["proof (state)\nthis:\n  d_IN g x =\n  (\\<Sum>\\<^sup>+ y. g (y, x) * indicator (- \\<^bold>E) (y, x)) +\n  (\\<Sum>\\<^sup>+ y. g (y, x) * indicator \\<^bold>E (y, x))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>;\n        x \\<noteq> sink \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> KIR (f \\<oplus> g) x", "also"], ["proof (state)\nthis:\n  d_IN g x =\n  (\\<Sum>\\<^sup>+ y. g (y, x) * indicator (- \\<^bold>E) (y, x)) +\n  (\\<Sum>\\<^sup>+ y. g (y, x) * indicator \\<^bold>E (y, x))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>;\n        x \\<noteq> sink \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> KIR (f \\<oplus> g) x", "have \"?x = ?g_in\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y. g (y, x) * indicator (- \\<^bold>E) (y, x)) =\n    (\\<Sum>\\<^sup>+ y. g (y, x) * indicator \\<^bold>E (x, y))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y. g (y, x) * indicator (- \\<^bold>E) (y, x)) =\n    (\\<Sum>\\<^sup>+ y. g (y, x) * indicator \\<^bold>E (x, y))", "have \"?x = (\\<Sum>\\<^sup>+ y. g (y, x) * indicator (- \\<^bold>E) (x, y) * indicator (- \\<^bold>E) (y, x)) + ?g_in\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y. g (y, x) * indicator (- \\<^bold>E) (y, x)) =\n    (\\<Sum>\\<^sup>+ y.\n       g (y, x) * indicator (- \\<^bold>E) (x, y) *\n       indicator (- \\<^bold>E) (y, x)) +\n    (\\<Sum>\\<^sup>+ y. g (y, x) * indicator \\<^bold>E (x, y))", "by(subst nn_integral_add[symmetric])(auto simp add: AE_count_space  dest: wf_residual_networkD[OF wf] split: split_indicator intro!: nn_integral_cong)"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y. g (y, x) * indicator (- \\<^bold>E) (y, x)) =\n  (\\<Sum>\\<^sup>+ y.\n     g (y, x) * indicator (- \\<^bold>E) (x, y) *\n     indicator (- \\<^bold>E) (y, x)) +\n  (\\<Sum>\\<^sup>+ y. g (y, x) * indicator \\<^bold>E (x, y))\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y. g (y, x) * indicator (- \\<^bold>E) (y, x)) =\n    (\\<Sum>\\<^sup>+ y. g (y, x) * indicator \\<^bold>E (x, y))", "also"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y. g (y, x) * indicator (- \\<^bold>E) (y, x)) =\n  (\\<Sum>\\<^sup>+ y.\n     g (y, x) * indicator (- \\<^bold>E) (x, y) *\n     indicator (- \\<^bold>E) (y, x)) +\n  (\\<Sum>\\<^sup>+ y. g (y, x) * indicator \\<^bold>E (x, y))\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y. g (y, x) * indicator (- \\<^bold>E) (y, x)) =\n    (\\<Sum>\\<^sup>+ y. g (y, x) * indicator \\<^bold>E (x, y))", "have \"(\\<Sum>\\<^sup>+ y. g (y, x) * indicator (- \\<^bold>E) (x, y) * indicator (- \\<^bold>E) (y, x)) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y.\n       g (y, x) * indicator (- \\<^bold>E) (x, y) *\n       indicator (- \\<^bold>E) (y, x)) =\n    0", "using RES.flowD_outside[OF g]"], ["proof (prove)\nusing this:\n  ?e \\<notin> \\<^bold>E\\<^bsub>residual_network f\\<^esub> \\<Longrightarrow>\n  g ?e = 0\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y.\n       g (y, x) * indicator (- \\<^bold>E) (x, y) *\n       indicator (- \\<^bold>E) (y, x)) =\n    0", "by(auto simp add: nn_integral_0_iff_AE AE_count_space split: split_indicator)"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y.\n     g (y, x) * indicator (- \\<^bold>E) (x, y) *\n     indicator (- \\<^bold>E) (y, x)) =\n  0\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y. g (y, x) * indicator (- \\<^bold>E) (y, x)) =\n    (\\<Sum>\\<^sup>+ y. g (y, x) * indicator \\<^bold>E (x, y))", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>\\<^sup>+ y. g (y, x) * indicator (- \\<^bold>E) (y, x)) =\n  0 + (\\<Sum>\\<^sup>+ y. g (y, x) * indicator \\<^bold>E (x, y))", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<Sum>\\<^sup>+ y. g (y, x) * indicator (- \\<^bold>E) (y, x)) =\n  0 + (\\<Sum>\\<^sup>+ y. g (y, x) * indicator \\<^bold>E (x, y))\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y. g (y, x) * indicator (- \\<^bold>E) (y, x)) =\n    (\\<Sum>\\<^sup>+ y. g (y, x) * indicator \\<^bold>E (x, y))", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y. g (y, x) * indicator (- \\<^bold>E) (y, x)) =\n  (\\<Sum>\\<^sup>+ y. g (y, x) * indicator \\<^bold>E (x, y))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y. g (y, x) * indicator (- \\<^bold>E) (y, x)) =\n  (\\<Sum>\\<^sup>+ y. g (y, x) * indicator \\<^bold>E (x, y))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>;\n        x \\<noteq> sink \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> KIR (f \\<oplus> g) x", "also"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y. g (y, x) * indicator (- \\<^bold>E) (y, x)) =\n  (\\<Sum>\\<^sup>+ y. g (y, x) * indicator \\<^bold>E (x, y))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>;\n        x \\<noteq> sink \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> KIR (f \\<oplus> g) x", "have \"(d_IN f x + (?g_in + ?g_in_E') - ?g_in_E) - ?g_in =\n    d_IN f x + ?g_in_E' + ?g_in - ?g_in - ?g_in_E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN f x +\n    ((\\<Sum>\\<^sup>+ y. g (y, x) * indicator \\<^bold>E (x, y)) +\n     (\\<Sum>\\<^sup>+ y. g (y, x) * indicator \\<^bold>E (y, x))) -\n    (\\<Sum>\\<^sup>+ y. g (x, y) * indicator \\<^bold>E (y, x)) -\n    (\\<Sum>\\<^sup>+ y. g (y, x) * indicator \\<^bold>E (x, y)) =\n    d_IN f x + (\\<Sum>\\<^sup>+ y. g (y, x) * indicator \\<^bold>E (y, x)) +\n    (\\<Sum>\\<^sup>+ y. g (y, x) * indicator \\<^bold>E (x, y)) -\n    (\\<Sum>\\<^sup>+ y. g (y, x) * indicator \\<^bold>E (x, y)) -\n    (\\<Sum>\\<^sup>+ y. g (x, y) * indicator \\<^bold>E (y, x))", "by (subst diff_diff_commute_ennreal) (simp add: ac_simps)"], ["proof (state)\nthis:\n  d_IN f x +\n  ((\\<Sum>\\<^sup>+ y. g (y, x) * indicator \\<^bold>E (x, y)) +\n   (\\<Sum>\\<^sup>+ y. g (y, x) * indicator \\<^bold>E (y, x))) -\n  (\\<Sum>\\<^sup>+ y. g (x, y) * indicator \\<^bold>E (y, x)) -\n  (\\<Sum>\\<^sup>+ y. g (y, x) * indicator \\<^bold>E (x, y)) =\n  d_IN f x + (\\<Sum>\\<^sup>+ y. g (y, x) * indicator \\<^bold>E (y, x)) +\n  (\\<Sum>\\<^sup>+ y. g (y, x) * indicator \\<^bold>E (x, y)) -\n  (\\<Sum>\\<^sup>+ y. g (y, x) * indicator \\<^bold>E (x, y)) -\n  (\\<Sum>\\<^sup>+ y. g (x, y) * indicator \\<^bold>E (y, x))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>;\n        x \\<noteq> sink \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> KIR (f \\<oplus> g) x", "also"], ["proof (state)\nthis:\n  d_IN f x +\n  ((\\<Sum>\\<^sup>+ y. g (y, x) * indicator \\<^bold>E (x, y)) +\n   (\\<Sum>\\<^sup>+ y. g (y, x) * indicator \\<^bold>E (y, x))) -\n  (\\<Sum>\\<^sup>+ y. g (x, y) * indicator \\<^bold>E (y, x)) -\n  (\\<Sum>\\<^sup>+ y. g (y, x) * indicator \\<^bold>E (x, y)) =\n  d_IN f x + (\\<Sum>\\<^sup>+ y. g (y, x) * indicator \\<^bold>E (y, x)) +\n  (\\<Sum>\\<^sup>+ y. g (y, x) * indicator \\<^bold>E (x, y)) -\n  (\\<Sum>\\<^sup>+ y. g (y, x) * indicator \\<^bold>E (x, y)) -\n  (\\<Sum>\\<^sup>+ y. g (x, y) * indicator \\<^bold>E (y, x))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>;\n        x \\<noteq> sink \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> KIR (f \\<oplus> g) x", "have \"\\<dots> = d_IN f x + ?g_in_E' - ?g_in_E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN f x + (\\<Sum>\\<^sup>+ y. g (y, x) * indicator \\<^bold>E (y, x)) +\n    (\\<Sum>\\<^sup>+ y. g (y, x) * indicator \\<^bold>E (x, y)) -\n    (\\<Sum>\\<^sup>+ y. g (y, x) * indicator \\<^bold>E (x, y)) -\n    (\\<Sum>\\<^sup>+ y. g (x, y) * indicator \\<^bold>E (y, x)) =\n    d_IN f x + (\\<Sum>\\<^sup>+ y. g (y, x) * indicator \\<^bold>E (y, x)) -\n    (\\<Sum>\\<^sup>+ y. g (x, y) * indicator \\<^bold>E (y, x))", "by (subst ennreal_add_diff_cancel_right) (simp_all add: finite1)"], ["proof (state)\nthis:\n  d_IN f x + (\\<Sum>\\<^sup>+ y. g (y, x) * indicator \\<^bold>E (y, x)) +\n  (\\<Sum>\\<^sup>+ y. g (y, x) * indicator \\<^bold>E (x, y)) -\n  (\\<Sum>\\<^sup>+ y. g (y, x) * indicator \\<^bold>E (x, y)) -\n  (\\<Sum>\\<^sup>+ y. g (x, y) * indicator \\<^bold>E (y, x)) =\n  d_IN f x + (\\<Sum>\\<^sup>+ y. g (y, x) * indicator \\<^bold>E (y, x)) -\n  (\\<Sum>\\<^sup>+ y. g (x, y) * indicator \\<^bold>E (y, x))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>;\n        x \\<noteq> sink \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> KIR (f \\<oplus> g) x", "also"], ["proof (state)\nthis:\n  d_IN f x + (\\<Sum>\\<^sup>+ y. g (y, x) * indicator \\<^bold>E (y, x)) +\n  (\\<Sum>\\<^sup>+ y. g (y, x) * indicator \\<^bold>E (x, y)) -\n  (\\<Sum>\\<^sup>+ y. g (y, x) * indicator \\<^bold>E (x, y)) -\n  (\\<Sum>\\<^sup>+ y. g (x, y) * indicator \\<^bold>E (y, x)) =\n  d_IN f x + (\\<Sum>\\<^sup>+ y. g (y, x) * indicator \\<^bold>E (y, x)) -\n  (\\<Sum>\\<^sup>+ y. g (x, y) * indicator \\<^bold>E (y, x))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>;\n        x \\<noteq> sink \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> KIR (f \\<oplus> g) x", "have \"\\<dots> = d_IN (f \\<oplus> g) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN f x + (\\<Sum>\\<^sup>+ y. g (y, x) * indicator \\<^bold>E (y, x)) -\n    (\\<Sum>\\<^sup>+ y. g (x, y) * indicator \\<^bold>E (y, x)) =\n    d_IN (f \\<oplus> g) x", "using flowD_outside[OF f]  g_le_f RES.flowD_finite_OUT[OF g, of x]"], ["proof (prove)\nusing this:\n  ?e \\<notin> \\<^bold>E \\<Longrightarrow> f ?e = 0\n  edge \\<Delta> ?x ?y \\<Longrightarrow> g (?y, ?x) \\<le> f (?x, ?y)\n  \\<lbrakk>x \\<noteq> source (residual_network f);\n   x \\<noteq> sink (residual_network f)\\<rbrakk>\n  \\<Longrightarrow> d_OUT g x \\<noteq> \\<top>\n\ngoal (1 subgoal):\n 1. d_IN f x + (\\<Sum>\\<^sup>+ y. g (y, x) * indicator \\<^bold>E (y, x)) -\n    (\\<Sum>\\<^sup>+ y. g (x, y) * indicator \\<^bold>E (y, x)) =\n    d_IN (f \\<oplus> g) x", "by(rule IN_plus_flow[symmetric])(simp_all add: x)"], ["proof (state)\nthis:\n  d_IN f x + (\\<Sum>\\<^sup>+ y. g (y, x) * indicator \\<^bold>E (y, x)) -\n  (\\<Sum>\\<^sup>+ y. g (x, y) * indicator \\<^bold>E (y, x)) =\n  d_IN (f \\<oplus> g) x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>;\n        x \\<noteq> sink \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> KIR (f \\<oplus> g) x", "finally"], ["proof (chain)\npicking this:\n  KIR (f \\<oplus> g) x", "show \"KIR (f \\<oplus> g) x\""], ["proof (prove)\nusing this:\n  KIR (f \\<oplus> g) x\n\ngoal (1 subgoal):\n 1. KIR (f \\<oplus> g) x", "by simp"], ["proof (state)\nthis:\n  KIR (f \\<oplus> g) x\n\ngoal:\nNo subgoals!", "qed"], ["", "definition minus_flow :: \"'v flow \\<Rightarrow> 'v flow \\<Rightarrow> 'v flow\" (infixl \"\\<ominus>\" 65)\nwhere\n  \"f \\<ominus> g = (\\<lambda>(x, y). if edge \\<Delta> x y then f (x, y) - g (x, y) else if edge \\<Delta> y x then g (y, x) - f (y, x) else 0)\""], ["", "lemma minus_flow_simps [simp]:\n  \"(f \\<ominus> g) (x, y) = (if edge \\<Delta> x y then f (x, y) - g (x, y) else if edge \\<Delta> y x then g (y, x) - f (y, x) else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f \\<ominus> g) (x, y) =\n    (if edge \\<Delta> x y then f (x, y) - g (x, y)\n     else if edge \\<Delta> y x then g (y, x) - f (y, x) else 0)", "by(simp add: minus_flow_def)"], ["", "lemma minus_flow:\n  assumes wf: \"wf_residual_network\"\n  and f: \"flow \\<Delta> f\"\n  and g: \"flow \\<Delta> g\"\n  and value_le: \"value_flow \\<Delta> g \\<le> value_flow \\<Delta> f\"\n  and f_finite: \"f (source \\<Delta>, x) \\<noteq> \\<top>\"\n  and source_out: \"\\<And>y. edge \\<Delta> (source \\<Delta>) y \\<longleftrightarrow> y = x\"\n  shows \"flow (residual_network g) (f \\<ominus> g)\" (is \"flow ?\\<Delta> ?f\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. flow (residual_network g) (f \\<ominus> g)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>e. (f \\<ominus> g) e \\<le> capacity (residual_network g) e\n 2. \\<And>x.\n       \\<lbrakk>x \\<noteq> source (residual_network g);\n        x \\<noteq> sink (residual_network g)\\<rbrakk>\n       \\<Longrightarrow> KIR (f \\<ominus> g) x", "show \"?f e \\<le> capacity ?\\<Delta> e\" for e"], ["proof (prove)\ngoal (1 subgoal):\n 1. (f \\<ominus> g) e \\<le> capacity (residual_network g) e", "using value_le f_finite flowD_capacity[OF g] flowD_capacity[OF f]"], ["proof (prove)\nusing this:\n  value_flow \\<Delta> g \\<le> value_flow \\<Delta> f\n  f (source \\<Delta>, x) \\<noteq> \\<top>\n  g ?e \\<le> capacity \\<Delta> ?e\n  f ?e \\<le> capacity \\<Delta> ?e\n\ngoal (1 subgoal):\n 1. (f \\<ominus> g) e \\<le> capacity (residual_network g) e", "by(cases e)(auto simp add: source_in source_out value_flow[OF f source_out] value_flow[OF g source_out] less_top\n                     intro!: diff_le_self_ennreal diff_eq_0_ennreal ennreal_minus_mono)"], ["proof (state)\nthis:\n  (f \\<ominus> g) ?e \\<le> capacity (residual_network g) ?e\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source (residual_network g);\n        x \\<noteq> sink (residual_network g)\\<rbrakk>\n       \\<Longrightarrow> KIR (f \\<ominus> g) x", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source (residual_network g);\n        x \\<noteq> sink (residual_network g)\\<rbrakk>\n       \\<Longrightarrow> KIR (f \\<ominus> g) x", "assume \"x \\<noteq> source ?\\<Delta>\" \"x \\<noteq> sink ?\\<Delta>\""], ["proof (state)\nthis:\n  x \\<noteq> source (residual_network g)\n  x \\<noteq> sink (residual_network g)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source (residual_network g);\n        x \\<noteq> sink (residual_network g)\\<rbrakk>\n       \\<Longrightarrow> KIR (f \\<ominus> g) x", "hence x: \"x \\<noteq> source \\<Delta>\" \"x \\<noteq> sink \\<Delta>\""], ["proof (prove)\nusing this:\n  x \\<noteq> source (residual_network g)\n  x \\<noteq> sink (residual_network g)\n\ngoal (1 subgoal):\n 1. x \\<noteq> source \\<Delta> &&& x \\<noteq> sink \\<Delta>", "by simp_all"], ["proof (state)\nthis:\n  x \\<noteq> source \\<Delta>\n  x \\<noteq> sink \\<Delta>\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source (residual_network g);\n        x \\<noteq> sink (residual_network g)\\<rbrakk>\n       \\<Longrightarrow> KIR (f \\<ominus> g) x", "have finite_f_in: \"(\\<Sum>\\<^sup>+ y. f (y, x) * indicator A y) \\<noteq> top\" for A"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+y\\<in>A. f (y, x)\\<partial>count_space UNIV \\<noteq>\n    \\<top>", "using flowD_finite_IN[OF f, of x]"], ["proof (prove)\nusing this:\n  x \\<noteq> sink \\<Delta> \\<Longrightarrow> d_IN f x \\<noteq> \\<top>\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+y\\<in>A. f (y, x)\\<partial>count_space UNIV \\<noteq>\n    \\<top>", "by(rule neq_top_trans)(auto simp add: x d_IN_def split: split_indicator intro!: nn_integral_mono)"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+y\\<in>?A. f (y, x)\\<partial>count_space UNIV \\<noteq>\n  \\<top>\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source (residual_network g);\n        x \\<noteq> sink (residual_network g)\\<rbrakk>\n       \\<Longrightarrow> KIR (f \\<ominus> g) x", "have finite_f_out: \"(\\<Sum>\\<^sup>+ y. f (x, y) * indicator A y) \\<noteq> top\" for A"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+y\\<in>A. f (x, y)\\<partial>count_space UNIV \\<noteq>\n    \\<top>", "using flowD_finite_OUT[OF f, of x]"], ["proof (prove)\nusing this:\n  \\<lbrakk>x \\<noteq> source \\<Delta>; x \\<noteq> sink \\<Delta>\\<rbrakk>\n  \\<Longrightarrow> d_OUT f x \\<noteq> \\<top>\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+y\\<in>A. f (x, y)\\<partial>count_space UNIV \\<noteq>\n    \\<top>", "by(rule neq_top_trans)(auto simp add: x d_OUT_def split: split_indicator intro!: nn_integral_mono)"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+y\\<in>?A. f (x, y)\\<partial>count_space UNIV \\<noteq>\n  \\<top>\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source (residual_network g);\n        x \\<noteq> sink (residual_network g)\\<rbrakk>\n       \\<Longrightarrow> KIR (f \\<ominus> g) x", "have finite_f[simp]: \"f (x, y) \\<noteq> top\" \"f (y, x) \\<noteq> top\" for y"], ["proof (prove)\ngoal (1 subgoal):\n 1. f (x, y) \\<noteq> \\<top> &&& f (y, x) \\<noteq> \\<top>", "using finite_f_in[of \"{y}\"] finite_f_out[of \"{y}\"]"], ["proof (prove)\nusing this:\n  \\<integral>\\<^sup>+y\\<in>{y}. f (y, x)\\<partial>count_space UNIV \\<noteq>\n  \\<top>\n  \\<integral>\\<^sup>+y\\<in>{y}. f (x, y)\\<partial>count_space UNIV \\<noteq>\n  \\<top>\n\ngoal (1 subgoal):\n 1. f (x, y) \\<noteq> \\<top> &&& f (y, x) \\<noteq> \\<top>", "by auto"], ["proof (state)\nthis:\n  f (x, ?y) \\<noteq> \\<top>\n  f (?y, x) \\<noteq> \\<top>\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source (residual_network g);\n        x \\<noteq> sink (residual_network g)\\<rbrakk>\n       \\<Longrightarrow> KIR (f \\<ominus> g) x", "have finite_g_in: \"(\\<Sum>\\<^sup>+ y. g (y, x) * indicator A y) \\<noteq> top\" for A"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+y\\<in>A. g (y, x)\\<partial>count_space UNIV \\<noteq>\n    \\<top>", "using flowD_finite_IN[OF g, of x]"], ["proof (prove)\nusing this:\n  x \\<noteq> sink \\<Delta> \\<Longrightarrow> d_IN g x \\<noteq> \\<top>\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+y\\<in>A. g (y, x)\\<partial>count_space UNIV \\<noteq>\n    \\<top>", "by(rule neq_top_trans)(auto simp add: x d_IN_def split: split_indicator intro!: nn_integral_mono)"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+y\\<in>?A. g (y, x)\\<partial>count_space UNIV \\<noteq>\n  \\<top>\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source (residual_network g);\n        x \\<noteq> sink (residual_network g)\\<rbrakk>\n       \\<Longrightarrow> KIR (f \\<ominus> g) x", "have finite_g_out: \"(\\<Sum>\\<^sup>+ y. g (x, y) * indicator A y) \\<noteq> top\" for A"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+y\\<in>A. g (x, y)\\<partial>count_space UNIV \\<noteq>\n    \\<top>", "using flowD_finite_OUT[OF g x]"], ["proof (prove)\nusing this:\n  d_OUT g x \\<noteq> \\<top>\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+y\\<in>A. g (x, y)\\<partial>count_space UNIV \\<noteq>\n    \\<top>", "by(rule neq_top_trans)(auto simp add: x d_OUT_def split: split_indicator intro!: nn_integral_mono)"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+y\\<in>?A. g (x, y)\\<partial>count_space UNIV \\<noteq>\n  \\<top>\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source (residual_network g);\n        x \\<noteq> sink (residual_network g)\\<rbrakk>\n       \\<Longrightarrow> KIR (f \\<ominus> g) x", "have finite_g[simp]: \"g (x, y) \\<noteq> top\" \"g (y, x) \\<noteq> top\" for y"], ["proof (prove)\ngoal (1 subgoal):\n 1. g (x, y) \\<noteq> \\<top> &&& g (y, x) \\<noteq> \\<top>", "using finite_g_in[of \"{y}\"] finite_g_out[of \"{y}\"]"], ["proof (prove)\nusing this:\n  \\<integral>\\<^sup>+y\\<in>{y}. g (y, x)\\<partial>count_space UNIV \\<noteq>\n  \\<top>\n  \\<integral>\\<^sup>+y\\<in>{y}. g (x, y)\\<partial>count_space UNIV \\<noteq>\n  \\<top>\n\ngoal (1 subgoal):\n 1. g (x, y) \\<noteq> \\<top> &&& g (y, x) \\<noteq> \\<top>", "by auto"], ["proof (state)\nthis:\n  g (x, ?y) \\<noteq> \\<top>\n  g (?y, x) \\<noteq> \\<top>\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source (residual_network g);\n        x \\<noteq> sink (residual_network g)\\<rbrakk>\n       \\<Longrightarrow> KIR (f \\<ominus> g) x", "have \"d_OUT (f \\<ominus> g) x = (\\<Sum>\\<^sup>+ y. (f (x, y) - g (x, y)) * indicator \\<^bold>E (x, y) * indicator {y. g (x, y) \\<le> f (x, y)} y) +\n    (\\<Sum>\\<^sup>+ y. (g (y, x) - f (y, x)) * indicator \\<^bold>E (y, x) * indicator {y. f (y, x) < g (y, x)} y)\"\n    (is \"_ = ?out + ?in\" is \"_ = (\\<Sum>\\<^sup>+ y\\<in>_. _ * ?f_ge_g y) + (\\<Sum>\\<^sup>+ y\\<in>_. _ * ?g_gt_f y)\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT (f \\<ominus> g) x =\n    (\\<integral>\\<^sup>+y\\<in>{y. g (x, y) \\<le> f (x, y)}.\n                        ((f (x, y) - g (x, y)) * indicator \\<^bold>E (x, y))\n     \\<partial>count_space UNIV) +\n    (\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}.\n                        ((g (y, x) - f (y, x)) * indicator \\<^bold>E (y, x))\n     \\<partial>count_space UNIV)", "using flowD_finite[OF g]"], ["proof (prove)\nusing this:\n  g ?e \\<noteq> \\<top>\n\ngoal (1 subgoal):\n 1. d_OUT (f \\<ominus> g) x =\n    (\\<integral>\\<^sup>+y\\<in>{y. g (x, y) \\<le> f (x, y)}.\n                        ((f (x, y) - g (x, y)) * indicator \\<^bold>E (x, y))\n     \\<partial>count_space UNIV) +\n    (\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}.\n                        ((g (y, x) - f (y, x)) * indicator \\<^bold>E (y, x))\n     \\<partial>count_space UNIV)", "apply(subst nn_integral_add[symmetric])"], ["proof (prove)\ngoal (3 subgoals):\n 1. (\\<And>e. g e \\<noteq> \\<top>) \\<Longrightarrow>\n    (\\<lambda>y.\n        (f (x, y) - g (x, y)) * indicator \\<^bold>E (x, y) *\n        indicator {y. g (x, y) \\<le> f (x, y)} y)\n    \\<in> borel_measurable (count_space UNIV)\n 2. (\\<And>e. g e \\<noteq> \\<top>) \\<Longrightarrow>\n    (\\<lambda>y.\n        (g (y, x) - f (y, x)) * indicator \\<^bold>E (y, x) *\n        indicator {y. f (y, x) < g (y, x)} y)\n    \\<in> borel_measurable (count_space UNIV)\n 3. (\\<And>e. g e \\<noteq> \\<top>) \\<Longrightarrow>\n    d_OUT (f \\<ominus> g) x =\n    (\\<Sum>\\<^sup>+ x.\n       (f (x, x) - g (x, x)) * indicator \\<^bold>E (x, x) *\n       indicator {y. g (x, y) \\<le> f (x, y)} x +\n       (g (x, x) - f (x, x)) * indicator \\<^bold>E (x, x) *\n       indicator {y. f (y, x) < g (y, x)} x)", "apply(auto 4 4 simp add: d_OUT_def not_le less_top[symmetric] intro!: nn_integral_cong\n           dest!: wf_residual_networkD[OF wf] split: split_indicator intro!: diff_eq_0_ennreal)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  d_OUT (f \\<ominus> g) x =\n  (\\<integral>\\<^sup>+y\\<in>{y. g (x, y) \\<le> f (x, y)}.\n                      ((f (x, y) - g (x, y)) * indicator \\<^bold>E (x, y))\n   \\<partial>count_space UNIV) +\n  (\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}.\n                      ((g (y, x) - f (y, x)) * indicator \\<^bold>E (y, x))\n   \\<partial>count_space UNIV)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source (residual_network g);\n        x \\<noteq> sink (residual_network g)\\<rbrakk>\n       \\<Longrightarrow> KIR (f \\<ominus> g) x", "also"], ["proof (state)\nthis:\n  d_OUT (f \\<ominus> g) x =\n  (\\<integral>\\<^sup>+y\\<in>{y. g (x, y) \\<le> f (x, y)}.\n                      ((f (x, y) - g (x, y)) * indicator \\<^bold>E (x, y))\n   \\<partial>count_space UNIV) +\n  (\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}.\n                      ((g (y, x) - f (y, x)) * indicator \\<^bold>E (y, x))\n   \\<partial>count_space UNIV)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source (residual_network g);\n        x \\<noteq> sink (residual_network g)\\<rbrakk>\n       \\<Longrightarrow> KIR (f \\<ominus> g) x", "have \"?in = (\\<Sum>\\<^sup>+ y. (g (y, x) - f (y, x)) * ?g_gt_f y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}.\n                       ((g (y, x) - f (y, x)) * indicator \\<^bold>E (y, x))\n    \\<partial>count_space UNIV =\n    \\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. (g (y, x) - f (y, x))\n    \\<partial>count_space UNIV", "using flowD_outside[OF f] flowD_outside[OF g]"], ["proof (prove)\nusing this:\n  ?e \\<notin> \\<^bold>E \\<Longrightarrow> f ?e = 0\n  ?e \\<notin> \\<^bold>E \\<Longrightarrow> g ?e = 0\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}.\n                       ((g (y, x) - f (y, x)) * indicator \\<^bold>E (y, x))\n    \\<partial>count_space UNIV =\n    \\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. (g (y, x) - f (y, x))\n    \\<partial>count_space UNIV", "by(auto intro!: nn_integral_cong split: split_indicator)"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}.\n                     ((g (y, x) - f (y, x)) * indicator \\<^bold>E (y, x))\n  \\<partial>count_space UNIV =\n  \\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. (g (y, x) - f (y, x))\n  \\<partial>count_space UNIV\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source (residual_network g);\n        x \\<noteq> sink (residual_network g)\\<rbrakk>\n       \\<Longrightarrow> KIR (f \\<ominus> g) x", "also"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}.\n                     ((g (y, x) - f (y, x)) * indicator \\<^bold>E (y, x))\n  \\<partial>count_space UNIV =\n  \\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. (g (y, x) - f (y, x))\n  \\<partial>count_space UNIV\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source (residual_network g);\n        x \\<noteq> sink (residual_network g)\\<rbrakk>\n       \\<Longrightarrow> KIR (f \\<ominus> g) x", "have \"\\<dots> = (\\<Sum>\\<^sup>+ y\\<in>UNIV. g (y, x) * ?g_gt_f y) - (\\<Sum>\\<^sup>+ y. f (y, x) * ?g_gt_f y)\" (is \"_ = ?g_in - ?f_in\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. (g (y, x) - f (y, x))\n    \\<partial>count_space UNIV =\n    (\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. g (y, x)\n     \\<partial>count_space UNIV) -\n    (\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. f (y, x)\n     \\<partial>count_space UNIV)", "using finite_f_in"], ["proof (prove)\nusing this:\n  \\<integral>\\<^sup>+y\\<in>?A. f (y, x)\\<partial>count_space UNIV \\<noteq>\n  \\<top>\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. (g (y, x) - f (y, x))\n    \\<partial>count_space UNIV =\n    (\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. g (y, x)\n     \\<partial>count_space UNIV) -\n    (\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. f (y, x)\n     \\<partial>count_space UNIV)", "by(subst nn_integral_diff[symmetric])(auto simp add: AE_count_space split: split_indicator intro!: nn_integral_cong)"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. (g (y, x) - f (y, x))\n  \\<partial>count_space UNIV =\n  (\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. g (y, x)\n   \\<partial>count_space UNIV) -\n  (\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. f (y, x)\n   \\<partial>count_space UNIV)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source (residual_network g);\n        x \\<noteq> sink (residual_network g)\\<rbrakk>\n       \\<Longrightarrow> KIR (f \\<ominus> g) x", "also"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. (g (y, x) - f (y, x))\n  \\<partial>count_space UNIV =\n  (\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. g (y, x)\n   \\<partial>count_space UNIV) -\n  (\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. f (y, x)\n   \\<partial>count_space UNIV)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source (residual_network g);\n        x \\<noteq> sink (residual_network g)\\<rbrakk>\n       \\<Longrightarrow> KIR (f \\<ominus> g) x", "have \"?out = (\\<Sum>\\<^sup>+ y. (f (x, y) - g (x, y)) * ?f_ge_g y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+y\\<in>{y. g (x, y) \\<le> f (x, y)}.\n                       ((f (x, y) - g (x, y)) * indicator \\<^bold>E (x, y))\n    \\<partial>count_space UNIV =\n    \\<integral>\\<^sup>+y\\<in>{y. g (x, y) \\<le> f (x, y)}.\n                       (f (x, y) - g (x, y))\n    \\<partial>count_space UNIV", "using flowD_outside[OF f] flowD_outside[OF g]"], ["proof (prove)\nusing this:\n  ?e \\<notin> \\<^bold>E \\<Longrightarrow> f ?e = 0\n  ?e \\<notin> \\<^bold>E \\<Longrightarrow> g ?e = 0\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+y\\<in>{y. g (x, y) \\<le> f (x, y)}.\n                       ((f (x, y) - g (x, y)) * indicator \\<^bold>E (x, y))\n    \\<partial>count_space UNIV =\n    \\<integral>\\<^sup>+y\\<in>{y. g (x, y) \\<le> f (x, y)}.\n                       (f (x, y) - g (x, y))\n    \\<partial>count_space UNIV", "by(auto intro!: nn_integral_cong split: split_indicator)"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+y\\<in>{y. g (x, y) \\<le> f (x, y)}.\n                     ((f (x, y) - g (x, y)) * indicator \\<^bold>E (x, y))\n  \\<partial>count_space UNIV =\n  \\<integral>\\<^sup>+y\\<in>{y. g (x, y) \\<le> f (x, y)}.\n                     (f (x, y) - g (x, y))\n  \\<partial>count_space UNIV\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source (residual_network g);\n        x \\<noteq> sink (residual_network g)\\<rbrakk>\n       \\<Longrightarrow> KIR (f \\<ominus> g) x", "also"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+y\\<in>{y. g (x, y) \\<le> f (x, y)}.\n                     ((f (x, y) - g (x, y)) * indicator \\<^bold>E (x, y))\n  \\<partial>count_space UNIV =\n  \\<integral>\\<^sup>+y\\<in>{y. g (x, y) \\<le> f (x, y)}.\n                     (f (x, y) - g (x, y))\n  \\<partial>count_space UNIV\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source (residual_network g);\n        x \\<noteq> sink (residual_network g)\\<rbrakk>\n       \\<Longrightarrow> KIR (f \\<ominus> g) x", "have \"\\<dots> = (\\<Sum>\\<^sup>+ y. f (x, y) * ?f_ge_g y) - (\\<Sum>\\<^sup>+ y. g (x, y) * ?f_ge_g y)\" (is \"_ = ?f_out - ?g_out\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+y\\<in>{y. g (x, y) \\<le> f (x, y)}.\n                       (f (x, y) - g (x, y))\n    \\<partial>count_space UNIV =\n    (\\<integral>\\<^sup>+y\\<in>{y. g (x, y) \\<le> f (x, y)}. f (x, y)\n     \\<partial>count_space UNIV) -\n    (\\<integral>\\<^sup>+y\\<in>{y. g (x, y) \\<le> f (x, y)}. g (x, y)\n     \\<partial>count_space UNIV)", "using finite_g_out"], ["proof (prove)\nusing this:\n  \\<integral>\\<^sup>+y\\<in>?A. g (x, y)\\<partial>count_space UNIV \\<noteq>\n  \\<top>\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+y\\<in>{y. g (x, y) \\<le> f (x, y)}.\n                       (f (x, y) - g (x, y))\n    \\<partial>count_space UNIV =\n    (\\<integral>\\<^sup>+y\\<in>{y. g (x, y) \\<le> f (x, y)}. f (x, y)\n     \\<partial>count_space UNIV) -\n    (\\<integral>\\<^sup>+y\\<in>{y. g (x, y) \\<le> f (x, y)}. g (x, y)\n     \\<partial>count_space UNIV)", "by(subst nn_integral_diff[symmetric])(auto simp add: AE_count_space split: split_indicator intro!: nn_integral_cong)"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+y\\<in>{y. g (x, y) \\<le> f (x, y)}.\n                     (f (x, y) - g (x, y))\n  \\<partial>count_space UNIV =\n  (\\<integral>\\<^sup>+y\\<in>{y. g (x, y) \\<le> f (x, y)}. f (x, y)\n   \\<partial>count_space UNIV) -\n  (\\<integral>\\<^sup>+y\\<in>{y. g (x, y) \\<le> f (x, y)}. g (x, y)\n   \\<partial>count_space UNIV)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source (residual_network g);\n        x \\<noteq> sink (residual_network g)\\<rbrakk>\n       \\<Longrightarrow> KIR (f \\<ominus> g) x", "also"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+y\\<in>{y. g (x, y) \\<le> f (x, y)}.\n                     (f (x, y) - g (x, y))\n  \\<partial>count_space UNIV =\n  (\\<integral>\\<^sup>+y\\<in>{y. g (x, y) \\<le> f (x, y)}. f (x, y)\n   \\<partial>count_space UNIV) -\n  (\\<integral>\\<^sup>+y\\<in>{y. g (x, y) \\<le> f (x, y)}. g (x, y)\n   \\<partial>count_space UNIV)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source (residual_network g);\n        x \\<noteq> sink (residual_network g)\\<rbrakk>\n       \\<Longrightarrow> KIR (f \\<ominus> g) x", "have \"?f_out = d_OUT f x - (\\<Sum>\\<^sup>+ y. f (x, y) * indicator {y. f (x, y) < g (x, y)} y)\" (is \"_ = _ - ?f_out_less\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+y\\<in>{y. g (x, y) \\<le> f (x, y)}. f (x, y)\n    \\<partial>count_space UNIV =\n    d_OUT f x -\n    (\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. f (x, y)\n     \\<partial>count_space UNIV)", "unfolding d_OUT_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+y\\<in>{y. g (x, y) \\<le> f (x, y)}. f (x, y)\n    \\<partial>count_space UNIV =\n    (\\<Sum>\\<^sup>+ y. f (x, y)) -\n    (\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. f (x, y)\n     \\<partial>count_space UNIV)", "using flowD_finite[OF f]"], ["proof (prove)\nusing this:\n  f ?e \\<noteq> \\<top>\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+y\\<in>{y. g (x, y) \\<le> f (x, y)}. f (x, y)\n    \\<partial>count_space UNIV =\n    (\\<Sum>\\<^sup>+ y. f (x, y)) -\n    (\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. f (x, y)\n     \\<partial>count_space UNIV)", "using finite_f_out"], ["proof (prove)\nusing this:\n  f ?e \\<noteq> \\<top>\n  \\<integral>\\<^sup>+y\\<in>?A. f (x, y)\\<partial>count_space UNIV \\<noteq>\n  \\<top>\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+y\\<in>{y. g (x, y) \\<le> f (x, y)}. f (x, y)\n    \\<partial>count_space UNIV =\n    (\\<Sum>\\<^sup>+ y. f (x, y)) -\n    (\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. f (x, y)\n     \\<partial>count_space UNIV)", "by(subst nn_integral_diff[symmetric])(auto split: split_indicator intro!: nn_integral_cong)"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+y\\<in>{y. g (x, y) \\<le> f (x, y)}. f (x, y)\n  \\<partial>count_space UNIV =\n  d_OUT f x -\n  (\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. f (x, y)\n   \\<partial>count_space UNIV)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source (residual_network g);\n        x \\<noteq> sink (residual_network g)\\<rbrakk>\n       \\<Longrightarrow> KIR (f \\<ominus> g) x", "also"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+y\\<in>{y. g (x, y) \\<le> f (x, y)}. f (x, y)\n  \\<partial>count_space UNIV =\n  d_OUT f x -\n  (\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. f (x, y)\n   \\<partial>count_space UNIV)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source (residual_network g);\n        x \\<noteq> sink (residual_network g)\\<rbrakk>\n       \\<Longrightarrow> KIR (f \\<ominus> g) x", "have \"?g_out = d_OUT g x - (\\<Sum>\\<^sup>+ y. g (x, y) * indicator {y. f (x, y) < g (x, y)} y)\" (is \"_ = _ - ?g_less_f\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+y\\<in>{y. g (x, y) \\<le> f (x, y)}. g (x, y)\n    \\<partial>count_space UNIV =\n    d_OUT g x -\n    (\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. g (x, y)\n     \\<partial>count_space UNIV)", "unfolding d_OUT_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+y\\<in>{y. g (x, y) \\<le> f (x, y)}. g (x, y)\n    \\<partial>count_space UNIV =\n    (\\<Sum>\\<^sup>+ y. g (x, y)) -\n    (\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. g (x, y)\n     \\<partial>count_space UNIV)", "using flowD_finite[OF g] finite_g_out"], ["proof (prove)\nusing this:\n  g ?e \\<noteq> \\<top>\n  \\<integral>\\<^sup>+y\\<in>?A. g (x, y)\\<partial>count_space UNIV \\<noteq>\n  \\<top>\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+y\\<in>{y. g (x, y) \\<le> f (x, y)}. g (x, y)\n    \\<partial>count_space UNIV =\n    (\\<Sum>\\<^sup>+ y. g (x, y)) -\n    (\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. g (x, y)\n     \\<partial>count_space UNIV)", "by(subst nn_integral_diff[symmetric])(auto split: split_indicator intro!: nn_integral_cong)"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+y\\<in>{y. g (x, y) \\<le> f (x, y)}. g (x, y)\n  \\<partial>count_space UNIV =\n  d_OUT g x -\n  (\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. g (x, y)\n   \\<partial>count_space UNIV)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source (residual_network g);\n        x \\<noteq> sink (residual_network g)\\<rbrakk>\n       \\<Longrightarrow> KIR (f \\<ominus> g) x", "also"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+y\\<in>{y. g (x, y) \\<le> f (x, y)}. g (x, y)\n  \\<partial>count_space UNIV =\n  d_OUT g x -\n  (\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. g (x, y)\n   \\<partial>count_space UNIV)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source (residual_network g);\n        x \\<noteq> sink (residual_network g)\\<rbrakk>\n       \\<Longrightarrow> KIR (f \\<ominus> g) x", "have \"d_OUT f x - ?f_out_less - (d_OUT g x - ?g_less_f) + (?g_in - ?f_in) =\n    (?g_less_f + (d_OUT f x - ?f_out_less)) - d_OUT g x + (?g_in - ?f_in)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT f x -\n    (\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. f (x, y)\n     \\<partial>count_space UNIV) -\n    (d_OUT g x -\n     (\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. g (x, y)\n      \\<partial>count_space UNIV)) +\n    ((\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. g (y, x)\n      \\<partial>count_space UNIV) -\n     (\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. f (y, x)\n      \\<partial>count_space UNIV)) =\n    (\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. g (x, y)\n     \\<partial>count_space UNIV) +\n    (d_OUT f x -\n     (\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. f (x, y)\n      \\<partial>count_space UNIV)) -\n    d_OUT g x +\n    ((\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. g (y, x)\n      \\<partial>count_space UNIV) -\n     (\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. f (y, x)\n      \\<partial>count_space UNIV))", "by (subst diff_diff_ennreal')\n       (auto simp: ac_simps d_OUT_def nn_integral_diff[symmetric] finite_g_out finite_f_out intro!: nn_integral_mono split: split_indicator )"], ["proof (state)\nthis:\n  d_OUT f x -\n  (\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. f (x, y)\n   \\<partial>count_space UNIV) -\n  (d_OUT g x -\n   (\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. g (x, y)\n    \\<partial>count_space UNIV)) +\n  ((\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. g (y, x)\n    \\<partial>count_space UNIV) -\n   (\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. f (y, x)\n    \\<partial>count_space UNIV)) =\n  (\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. g (x, y)\n   \\<partial>count_space UNIV) +\n  (d_OUT f x -\n   (\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. f (x, y)\n    \\<partial>count_space UNIV)) -\n  d_OUT g x +\n  ((\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. g (y, x)\n    \\<partial>count_space UNIV) -\n   (\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. f (y, x)\n    \\<partial>count_space UNIV))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source (residual_network g);\n        x \\<noteq> sink (residual_network g)\\<rbrakk>\n       \\<Longrightarrow> KIR (f \\<ominus> g) x", "also"], ["proof (state)\nthis:\n  d_OUT f x -\n  (\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. f (x, y)\n   \\<partial>count_space UNIV) -\n  (d_OUT g x -\n   (\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. g (x, y)\n    \\<partial>count_space UNIV)) +\n  ((\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. g (y, x)\n    \\<partial>count_space UNIV) -\n   (\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. f (y, x)\n    \\<partial>count_space UNIV)) =\n  (\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. g (x, y)\n   \\<partial>count_space UNIV) +\n  (d_OUT f x -\n   (\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. f (x, y)\n    \\<partial>count_space UNIV)) -\n  d_OUT g x +\n  ((\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. g (y, x)\n    \\<partial>count_space UNIV) -\n   (\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. f (y, x)\n    \\<partial>count_space UNIV))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source (residual_network g);\n        x \\<noteq> sink (residual_network g)\\<rbrakk>\n       \\<Longrightarrow> KIR (f \\<ominus> g) x", "have \"\\<dots> = ?g_less_f + d_OUT f x - ?f_out_less - d_OUT g x + (?g_in - ?f_in)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. g (x, y)\n     \\<partial>count_space UNIV) +\n    (d_OUT f x -\n     (\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. f (x, y)\n      \\<partial>count_space UNIV)) -\n    d_OUT g x +\n    ((\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. g (y, x)\n      \\<partial>count_space UNIV) -\n     (\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. f (y, x)\n      \\<partial>count_space UNIV)) =\n    (\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. g (x, y)\n     \\<partial>count_space UNIV) +\n    d_OUT f x -\n    (\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. f (x, y)\n     \\<partial>count_space UNIV) -\n    d_OUT g x +\n    ((\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. g (y, x)\n      \\<partial>count_space UNIV) -\n     (\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. f (y, x)\n      \\<partial>count_space UNIV))", "by (subst add_diff_eq_ennreal)\n       (auto simp: d_OUT_def intro!: nn_integral_mono split: split_indicator)"], ["proof (state)\nthis:\n  (\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. g (x, y)\n   \\<partial>count_space UNIV) +\n  (d_OUT f x -\n   (\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. f (x, y)\n    \\<partial>count_space UNIV)) -\n  d_OUT g x +\n  ((\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. g (y, x)\n    \\<partial>count_space UNIV) -\n   (\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. f (y, x)\n    \\<partial>count_space UNIV)) =\n  (\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. g (x, y)\n   \\<partial>count_space UNIV) +\n  d_OUT f x -\n  (\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. f (x, y)\n   \\<partial>count_space UNIV) -\n  d_OUT g x +\n  ((\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. g (y, x)\n    \\<partial>count_space UNIV) -\n   (\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. f (y, x)\n    \\<partial>count_space UNIV))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source (residual_network g);\n        x \\<noteq> sink (residual_network g)\\<rbrakk>\n       \\<Longrightarrow> KIR (f \\<ominus> g) x", "also"], ["proof (state)\nthis:\n  (\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. g (x, y)\n   \\<partial>count_space UNIV) +\n  (d_OUT f x -\n   (\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. f (x, y)\n    \\<partial>count_space UNIV)) -\n  d_OUT g x +\n  ((\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. g (y, x)\n    \\<partial>count_space UNIV) -\n   (\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. f (y, x)\n    \\<partial>count_space UNIV)) =\n  (\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. g (x, y)\n   \\<partial>count_space UNIV) +\n  d_OUT f x -\n  (\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. f (x, y)\n   \\<partial>count_space UNIV) -\n  d_OUT g x +\n  ((\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. g (y, x)\n    \\<partial>count_space UNIV) -\n   (\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. f (y, x)\n    \\<partial>count_space UNIV))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source (residual_network g);\n        x \\<noteq> sink (residual_network g)\\<rbrakk>\n       \\<Longrightarrow> KIR (f \\<ominus> g) x", "have \"\\<dots> = d_OUT f x + ?g_less_f - ?f_out_less - d_OUT g x + (?g_in - ?f_in)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. g (x, y)\n     \\<partial>count_space UNIV) +\n    d_OUT f x -\n    (\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. f (x, y)\n     \\<partial>count_space UNIV) -\n    d_OUT g x +\n    ((\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. g (y, x)\n      \\<partial>count_space UNIV) -\n     (\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. f (y, x)\n      \\<partial>count_space UNIV)) =\n    d_OUT f x +\n    (\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. g (x, y)\n     \\<partial>count_space UNIV) -\n    (\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. f (x, y)\n     \\<partial>count_space UNIV) -\n    d_OUT g x +\n    ((\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. g (y, x)\n      \\<partial>count_space UNIV) -\n     (\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. f (y, x)\n      \\<partial>count_space UNIV))", "by (simp add: ac_simps)"], ["proof (state)\nthis:\n  (\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. g (x, y)\n   \\<partial>count_space UNIV) +\n  d_OUT f x -\n  (\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. f (x, y)\n   \\<partial>count_space UNIV) -\n  d_OUT g x +\n  ((\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. g (y, x)\n    \\<partial>count_space UNIV) -\n   (\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. f (y, x)\n    \\<partial>count_space UNIV)) =\n  d_OUT f x +\n  (\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. g (x, y)\n   \\<partial>count_space UNIV) -\n  (\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. f (x, y)\n   \\<partial>count_space UNIV) -\n  d_OUT g x +\n  ((\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. g (y, x)\n    \\<partial>count_space UNIV) -\n   (\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. f (y, x)\n    \\<partial>count_space UNIV))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source (residual_network g);\n        x \\<noteq> sink (residual_network g)\\<rbrakk>\n       \\<Longrightarrow> KIR (f \\<ominus> g) x", "also"], ["proof (state)\nthis:\n  (\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. g (x, y)\n   \\<partial>count_space UNIV) +\n  d_OUT f x -\n  (\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. f (x, y)\n   \\<partial>count_space UNIV) -\n  d_OUT g x +\n  ((\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. g (y, x)\n    \\<partial>count_space UNIV) -\n   (\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. f (y, x)\n    \\<partial>count_space UNIV)) =\n  d_OUT f x +\n  (\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. g (x, y)\n   \\<partial>count_space UNIV) -\n  (\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. f (x, y)\n   \\<partial>count_space UNIV) -\n  d_OUT g x +\n  ((\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. g (y, x)\n    \\<partial>count_space UNIV) -\n   (\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. f (y, x)\n    \\<partial>count_space UNIV))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source (residual_network g);\n        x \\<noteq> sink (residual_network g)\\<rbrakk>\n       \\<Longrightarrow> KIR (f \\<ominus> g) x", "have \"\\<dots> = d_OUT f x + (?g_less_f - ?f_out_less) - d_OUT g x + (?g_in - ?f_in)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT f x +\n    (\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. g (x, y)\n     \\<partial>count_space UNIV) -\n    (\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. f (x, y)\n     \\<partial>count_space UNIV) -\n    d_OUT g x +\n    ((\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. g (y, x)\n      \\<partial>count_space UNIV) -\n     (\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. f (y, x)\n      \\<partial>count_space UNIV)) =\n    d_OUT f x +\n    ((\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. g (x, y)\n      \\<partial>count_space UNIV) -\n     (\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. f (x, y)\n      \\<partial>count_space UNIV)) -\n    d_OUT g x +\n    ((\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. g (y, x)\n      \\<partial>count_space UNIV) -\n     (\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. f (y, x)\n      \\<partial>count_space UNIV))", "by (subst add_diff_eq_ennreal[symmetric])\n       (auto intro!: nn_integral_mono split: split_indicator)"], ["proof (state)\nthis:\n  d_OUT f x +\n  (\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. g (x, y)\n   \\<partial>count_space UNIV) -\n  (\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. f (x, y)\n   \\<partial>count_space UNIV) -\n  d_OUT g x +\n  ((\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. g (y, x)\n    \\<partial>count_space UNIV) -\n   (\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. f (y, x)\n    \\<partial>count_space UNIV)) =\n  d_OUT f x +\n  ((\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. g (x, y)\n    \\<partial>count_space UNIV) -\n   (\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. f (x, y)\n    \\<partial>count_space UNIV)) -\n  d_OUT g x +\n  ((\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. g (y, x)\n    \\<partial>count_space UNIV) -\n   (\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. f (y, x)\n    \\<partial>count_space UNIV))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source (residual_network g);\n        x \\<noteq> sink (residual_network g)\\<rbrakk>\n       \\<Longrightarrow> KIR (f \\<ominus> g) x", "also"], ["proof (state)\nthis:\n  d_OUT f x +\n  (\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. g (x, y)\n   \\<partial>count_space UNIV) -\n  (\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. f (x, y)\n   \\<partial>count_space UNIV) -\n  d_OUT g x +\n  ((\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. g (y, x)\n    \\<partial>count_space UNIV) -\n   (\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. f (y, x)\n    \\<partial>count_space UNIV)) =\n  d_OUT f x +\n  ((\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. g (x, y)\n    \\<partial>count_space UNIV) -\n   (\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. f (x, y)\n    \\<partial>count_space UNIV)) -\n  d_OUT g x +\n  ((\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. g (y, x)\n    \\<partial>count_space UNIV) -\n   (\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. f (y, x)\n    \\<partial>count_space UNIV))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source (residual_network g);\n        x \\<noteq> sink (residual_network g)\\<rbrakk>\n       \\<Longrightarrow> KIR (f \\<ominus> g) x", "have \"\\<dots> = (?g_in - ?f_in) + ((?g_less_f - ?f_out_less) + d_OUT f x - d_OUT g x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT f x +\n    ((\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. g (x, y)\n      \\<partial>count_space UNIV) -\n     (\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. f (x, y)\n      \\<partial>count_space UNIV)) -\n    d_OUT g x +\n    ((\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. g (y, x)\n      \\<partial>count_space UNIV) -\n     (\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. f (y, x)\n      \\<partial>count_space UNIV)) =\n    (\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. g (y, x)\n     \\<partial>count_space UNIV) -\n    (\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. f (y, x)\n     \\<partial>count_space UNIV) +\n    ((\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. g (x, y)\n      \\<partial>count_space UNIV) -\n     (\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. f (x, y)\n      \\<partial>count_space UNIV) +\n     d_OUT f x -\n     d_OUT g x)", "by (simp add: ac_simps)"], ["proof (state)\nthis:\n  d_OUT f x +\n  ((\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. g (x, y)\n    \\<partial>count_space UNIV) -\n   (\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. f (x, y)\n    \\<partial>count_space UNIV)) -\n  d_OUT g x +\n  ((\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. g (y, x)\n    \\<partial>count_space UNIV) -\n   (\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. f (y, x)\n    \\<partial>count_space UNIV)) =\n  (\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. g (y, x)\n   \\<partial>count_space UNIV) -\n  (\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. f (y, x)\n   \\<partial>count_space UNIV) +\n  ((\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. g (x, y)\n    \\<partial>count_space UNIV) -\n   (\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. f (x, y)\n    \\<partial>count_space UNIV) +\n   d_OUT f x -\n   d_OUT g x)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source (residual_network g);\n        x \\<noteq> sink (residual_network g)\\<rbrakk>\n       \\<Longrightarrow> KIR (f \\<ominus> g) x", "also"], ["proof (state)\nthis:\n  d_OUT f x +\n  ((\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. g (x, y)\n    \\<partial>count_space UNIV) -\n   (\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. f (x, y)\n    \\<partial>count_space UNIV)) -\n  d_OUT g x +\n  ((\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. g (y, x)\n    \\<partial>count_space UNIV) -\n   (\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. f (y, x)\n    \\<partial>count_space UNIV)) =\n  (\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. g (y, x)\n   \\<partial>count_space UNIV) -\n  (\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. f (y, x)\n   \\<partial>count_space UNIV) +\n  ((\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. g (x, y)\n    \\<partial>count_space UNIV) -\n   (\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. f (x, y)\n    \\<partial>count_space UNIV) +\n   d_OUT f x -\n   d_OUT g x)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source (residual_network g);\n        x \\<noteq> sink (residual_network g)\\<rbrakk>\n       \\<Longrightarrow> KIR (f \\<ominus> g) x", "have \"\\<dots> = ((?g_in - ?f_in) + ((?g_less_f - ?f_out_less) + d_OUT f x)) - d_OUT g x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. g (y, x)\n     \\<partial>count_space UNIV) -\n    (\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. f (y, x)\n     \\<partial>count_space UNIV) +\n    ((\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. g (x, y)\n      \\<partial>count_space UNIV) -\n     (\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. f (x, y)\n      \\<partial>count_space UNIV) +\n     d_OUT f x -\n     d_OUT g x) =\n    (\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. g (y, x)\n     \\<partial>count_space UNIV) -\n    (\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. f (y, x)\n     \\<partial>count_space UNIV) +\n    ((\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. g (x, y)\n      \\<partial>count_space UNIV) -\n     (\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. f (x, y)\n      \\<partial>count_space UNIV) +\n     d_OUT f x) -\n    d_OUT g x", "apply (subst add_diff_eq_ennreal)"], ["proof (prove)\ngoal (2 subgoals):\n 1. d_OUT g x\n    \\<le> (\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. g (x, y)\n           \\<partial>count_space UNIV) -\n          (\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. f (x, y)\n           \\<partial>count_space UNIV) +\n          d_OUT f x\n 2. (\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. g (y, x)\n     \\<partial>count_space UNIV) -\n    (\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. f (y, x)\n     \\<partial>count_space UNIV) +\n    ((\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. g (x, y)\n      \\<partial>count_space UNIV) -\n     (\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. f (x, y)\n      \\<partial>count_space UNIV) +\n     d_OUT f x) -\n    d_OUT g x =\n    (\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. g (y, x)\n     \\<partial>count_space UNIV) -\n    (\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. f (y, x)\n     \\<partial>count_space UNIV) +\n    ((\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. g (x, y)\n      \\<partial>count_space UNIV) -\n     (\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. f (x, y)\n      \\<partial>count_space UNIV) +\n     d_OUT f x) -\n    d_OUT g x", "apply (simp_all add: d_OUT_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y. g (x, y))\n    \\<le> (\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. g (x, y)\n           \\<partial>count_space UNIV) -\n          (\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. f (x, y)\n           \\<partial>count_space UNIV) +\n          (\\<Sum>\\<^sup>+ y. f (x, y))", "apply (subst nn_integral_diff[symmetric])"], ["proof (prove)\ngoal (5 subgoals):\n 1. (\\<lambda>y. g (x, y) * indicator {y. f (x, y) < g (x, y)} y)\n    \\<in> borel_measurable (count_space UNIV)\n 2. (\\<lambda>y. f (x, y) * indicator {y. f (x, y) < g (x, y)} y)\n    \\<in> borel_measurable (count_space UNIV)\n 3. \\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. f (x, y)\n    \\<partial>count_space UNIV \\<noteq>\n    \\<infinity>\n 4. AE x in count_space\n             UNIV. f (x, x) * indicator {y. f (x, y) < g (x, y)} x\n                   \\<le> g (x, x) * indicator {y. f (x, y) < g (x, y)} x\n 5. (\\<Sum>\\<^sup>+ y. g (x, y))\n    \\<le> (\\<Sum>\\<^sup>+ x.\n             g (x, x) * indicator {y. f (x, y) < g (x, y)} x -\n             f (x, x) * indicator {y. f (x, y) < g (x, y)} x) +\n          (\\<Sum>\\<^sup>+ y. f (x, y))", "apply (auto simp: AE_count_space finite_f_out nn_integral_add[symmetric] not_less diff_add_cancel_ennreal intro!: nn_integral_mono split: split_indicator)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. g (y, x)\n   \\<partial>count_space UNIV) -\n  (\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. f (y, x)\n   \\<partial>count_space UNIV) +\n  ((\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. g (x, y)\n    \\<partial>count_space UNIV) -\n   (\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. f (x, y)\n    \\<partial>count_space UNIV) +\n   d_OUT f x -\n   d_OUT g x) =\n  (\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. g (y, x)\n   \\<partial>count_space UNIV) -\n  (\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. f (y, x)\n   \\<partial>count_space UNIV) +\n  ((\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. g (x, y)\n    \\<partial>count_space UNIV) -\n   (\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. f (x, y)\n    \\<partial>count_space UNIV) +\n   d_OUT f x) -\n  d_OUT g x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source (residual_network g);\n        x \\<noteq> sink (residual_network g)\\<rbrakk>\n       \\<Longrightarrow> KIR (f \\<ominus> g) x", "also"], ["proof (state)\nthis:\n  (\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. g (y, x)\n   \\<partial>count_space UNIV) -\n  (\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. f (y, x)\n   \\<partial>count_space UNIV) +\n  ((\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. g (x, y)\n    \\<partial>count_space UNIV) -\n   (\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. f (x, y)\n    \\<partial>count_space UNIV) +\n   d_OUT f x -\n   d_OUT g x) =\n  (\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. g (y, x)\n   \\<partial>count_space UNIV) -\n  (\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. f (y, x)\n   \\<partial>count_space UNIV) +\n  ((\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. g (x, y)\n    \\<partial>count_space UNIV) -\n   (\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. f (x, y)\n    \\<partial>count_space UNIV) +\n   d_OUT f x) -\n  d_OUT g x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source (residual_network g);\n        x \\<noteq> sink (residual_network g)\\<rbrakk>\n       \\<Longrightarrow> KIR (f \\<ominus> g) x", "have \"\\<dots> = ((?g_less_f - ?f_out_less) + (d_OUT f x + (?g_in - ?f_in))) - d_OUT g x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. g (y, x)\n     \\<partial>count_space UNIV) -\n    (\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. f (y, x)\n     \\<partial>count_space UNIV) +\n    ((\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. g (x, y)\n      \\<partial>count_space UNIV) -\n     (\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. f (x, y)\n      \\<partial>count_space UNIV) +\n     d_OUT f x) -\n    d_OUT g x =\n    (\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. g (x, y)\n     \\<partial>count_space UNIV) -\n    (\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. f (x, y)\n     \\<partial>count_space UNIV) +\n    (d_OUT f x +\n     ((\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. g (y, x)\n       \\<partial>count_space UNIV) -\n      (\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. f (y, x)\n       \\<partial>count_space UNIV))) -\n    d_OUT g x", "by (simp add: ac_simps)"], ["proof (state)\nthis:\n  (\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. g (y, x)\n   \\<partial>count_space UNIV) -\n  (\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. f (y, x)\n   \\<partial>count_space UNIV) +\n  ((\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. g (x, y)\n    \\<partial>count_space UNIV) -\n   (\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. f (x, y)\n    \\<partial>count_space UNIV) +\n   d_OUT f x) -\n  d_OUT g x =\n  (\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. g (x, y)\n   \\<partial>count_space UNIV) -\n  (\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. f (x, y)\n   \\<partial>count_space UNIV) +\n  (d_OUT f x +\n   ((\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. g (y, x)\n     \\<partial>count_space UNIV) -\n    (\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. f (y, x)\n     \\<partial>count_space UNIV))) -\n  d_OUT g x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source (residual_network g);\n        x \\<noteq> sink (residual_network g)\\<rbrakk>\n       \\<Longrightarrow> KIR (f \\<ominus> g) x", "also"], ["proof (state)\nthis:\n  (\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. g (y, x)\n   \\<partial>count_space UNIV) -\n  (\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. f (y, x)\n   \\<partial>count_space UNIV) +\n  ((\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. g (x, y)\n    \\<partial>count_space UNIV) -\n   (\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. f (x, y)\n    \\<partial>count_space UNIV) +\n   d_OUT f x) -\n  d_OUT g x =\n  (\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. g (x, y)\n   \\<partial>count_space UNIV) -\n  (\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. f (x, y)\n   \\<partial>count_space UNIV) +\n  (d_OUT f x +\n   ((\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. g (y, x)\n     \\<partial>count_space UNIV) -\n    (\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. f (y, x)\n     \\<partial>count_space UNIV))) -\n  d_OUT g x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source (residual_network g);\n        x \\<noteq> sink (residual_network g)\\<rbrakk>\n       \\<Longrightarrow> KIR (f \\<ominus> g) x", "have \"\\<dots> = ((?g_less_f - ?f_out_less) + (d_IN f x + (?g_in - ?f_in))) - d_IN g x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. g (x, y)\n     \\<partial>count_space UNIV) -\n    (\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. f (x, y)\n     \\<partial>count_space UNIV) +\n    (d_OUT f x +\n     ((\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. g (y, x)\n       \\<partial>count_space UNIV) -\n      (\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. f (y, x)\n       \\<partial>count_space UNIV))) -\n    d_OUT g x =\n    (\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. g (x, y)\n     \\<partial>count_space UNIV) -\n    (\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. f (x, y)\n     \\<partial>count_space UNIV) +\n    (d_IN f x +\n     ((\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. g (y, x)\n       \\<partial>count_space UNIV) -\n      (\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. f (y, x)\n       \\<partial>count_space UNIV))) -\n    d_IN g x", "unfolding flowD_KIR[OF f x] flowD_KIR[OF g x]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. g (x, y)\n     \\<partial>count_space UNIV) -\n    (\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. f (x, y)\n     \\<partial>count_space UNIV) +\n    (d_IN f x +\n     ((\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. g (y, x)\n       \\<partial>count_space UNIV) -\n      (\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. f (y, x)\n       \\<partial>count_space UNIV))) -\n    d_IN g x =\n    (\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. g (x, y)\n     \\<partial>count_space UNIV) -\n    (\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. f (x, y)\n     \\<partial>count_space UNIV) +\n    (d_IN f x +\n     ((\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. g (y, x)\n       \\<partial>count_space UNIV) -\n      (\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. f (y, x)\n       \\<partial>count_space UNIV))) -\n    d_IN g x", ".."], ["proof (state)\nthis:\n  (\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. g (x, y)\n   \\<partial>count_space UNIV) -\n  (\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. f (x, y)\n   \\<partial>count_space UNIV) +\n  (d_OUT f x +\n   ((\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. g (y, x)\n     \\<partial>count_space UNIV) -\n    (\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. f (y, x)\n     \\<partial>count_space UNIV))) -\n  d_OUT g x =\n  (\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. g (x, y)\n   \\<partial>count_space UNIV) -\n  (\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. f (x, y)\n   \\<partial>count_space UNIV) +\n  (d_IN f x +\n   ((\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. g (y, x)\n     \\<partial>count_space UNIV) -\n    (\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. f (y, x)\n     \\<partial>count_space UNIV))) -\n  d_IN g x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source (residual_network g);\n        x \\<noteq> sink (residual_network g)\\<rbrakk>\n       \\<Longrightarrow> KIR (f \\<ominus> g) x", "also"], ["proof (state)\nthis:\n  (\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. g (x, y)\n   \\<partial>count_space UNIV) -\n  (\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. f (x, y)\n   \\<partial>count_space UNIV) +\n  (d_OUT f x +\n   ((\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. g (y, x)\n     \\<partial>count_space UNIV) -\n    (\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. f (y, x)\n     \\<partial>count_space UNIV))) -\n  d_OUT g x =\n  (\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. g (x, y)\n   \\<partial>count_space UNIV) -\n  (\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. f (x, y)\n   \\<partial>count_space UNIV) +\n  (d_IN f x +\n   ((\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. g (y, x)\n     \\<partial>count_space UNIV) -\n    (\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. f (y, x)\n     \\<partial>count_space UNIV))) -\n  d_IN g x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source (residual_network g);\n        x \\<noteq> sink (residual_network g)\\<rbrakk>\n       \\<Longrightarrow> KIR (f \\<ominus> g) x", "have \"\\<dots> = (?g_less_f - ?f_out_less) + ((d_IN f x + (?g_in - ?f_in)) - d_IN g x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. g (x, y)\n     \\<partial>count_space UNIV) -\n    (\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. f (x, y)\n     \\<partial>count_space UNIV) +\n    (d_IN f x +\n     ((\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. g (y, x)\n       \\<partial>count_space UNIV) -\n      (\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. f (y, x)\n       \\<partial>count_space UNIV))) -\n    d_IN g x =\n    (\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. g (x, y)\n     \\<partial>count_space UNIV) -\n    (\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. f (x, y)\n     \\<partial>count_space UNIV) +\n    (d_IN f x +\n     ((\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. g (y, x)\n       \\<partial>count_space UNIV) -\n      (\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. f (y, x)\n       \\<partial>count_space UNIV)) -\n     d_IN g x)", "apply (subst (2) add_diff_eq_ennreal)"], ["proof (prove)\ngoal (2 subgoals):\n 1. d_IN g x\n    \\<le> d_IN f x +\n          ((\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. g (y, x)\n            \\<partial>count_space UNIV) -\n           (\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. f (y, x)\n            \\<partial>count_space UNIV))\n 2. (\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. g (x, y)\n     \\<partial>count_space UNIV) -\n    (\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. f (x, y)\n     \\<partial>count_space UNIV) +\n    (d_IN f x +\n     ((\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. g (y, x)\n       \\<partial>count_space UNIV) -\n      (\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. f (y, x)\n       \\<partial>count_space UNIV))) -\n    d_IN g x =\n    (\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. g (x, y)\n     \\<partial>count_space UNIV) -\n    (\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. f (x, y)\n     \\<partial>count_space UNIV) +\n    (d_IN f x +\n     ((\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. g (y, x)\n       \\<partial>count_space UNIV) -\n      (\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. f (y, x)\n       \\<partial>count_space UNIV))) -\n    d_IN g x", "apply (simp_all add: d_IN_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ x. g (x, x))\n    \\<le> (\\<Sum>\\<^sup>+ x. f (x, x)) +\n          ((\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. g (y, x)\n            \\<partial>count_space UNIV) -\n           (\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. f (y, x)\n            \\<partial>count_space UNIV))", "apply (subst nn_integral_diff[symmetric])"], ["proof (prove)\ngoal (5 subgoals):\n 1. (\\<lambda>y. g (y, x) * indicator {y. f (y, x) < g (y, x)} y)\n    \\<in> borel_measurable (count_space UNIV)\n 2. (\\<lambda>y. f (y, x) * indicator {y. f (y, x) < g (y, x)} y)\n    \\<in> borel_measurable (count_space UNIV)\n 3. \\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. f (y, x)\n    \\<partial>count_space UNIV \\<noteq>\n    \\<infinity>\n 4. AE x in count_space\n             UNIV. f (x, x) * indicator {y. f (y, x) < g (y, x)} x\n                   \\<le> g (x, x) * indicator {y. f (y, x) < g (y, x)} x\n 5. (\\<Sum>\\<^sup>+ x. g (x, x))\n    \\<le> (\\<Sum>\\<^sup>+ x. f (x, x)) +\n          (\\<Sum>\\<^sup>+ x.\n             g (x, x) * indicator {y. f (y, x) < g (y, x)} x -\n             f (x, x) * indicator {y. f (y, x) < g (y, x)} x)", "apply (auto simp: AE_count_space finite_f_in finite_f_out nn_integral_add[symmetric] not_less  ennreal_ineq_diff_add[symmetric]\n                intro!: nn_integral_mono split: split_indicator)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. g (x, y)\n   \\<partial>count_space UNIV) -\n  (\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. f (x, y)\n   \\<partial>count_space UNIV) +\n  (d_IN f x +\n   ((\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. g (y, x)\n     \\<partial>count_space UNIV) -\n    (\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. f (y, x)\n     \\<partial>count_space UNIV))) -\n  d_IN g x =\n  (\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. g (x, y)\n   \\<partial>count_space UNIV) -\n  (\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. f (x, y)\n   \\<partial>count_space UNIV) +\n  (d_IN f x +\n   ((\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. g (y, x)\n     \\<partial>count_space UNIV) -\n    (\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. f (y, x)\n     \\<partial>count_space UNIV)) -\n   d_IN g x)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source (residual_network g);\n        x \\<noteq> sink (residual_network g)\\<rbrakk>\n       \\<Longrightarrow> KIR (f \\<ominus> g) x", "also"], ["proof (state)\nthis:\n  (\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. g (x, y)\n   \\<partial>count_space UNIV) -\n  (\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. f (x, y)\n   \\<partial>count_space UNIV) +\n  (d_IN f x +\n   ((\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. g (y, x)\n     \\<partial>count_space UNIV) -\n    (\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. f (y, x)\n     \\<partial>count_space UNIV))) -\n  d_IN g x =\n  (\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. g (x, y)\n   \\<partial>count_space UNIV) -\n  (\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. f (x, y)\n   \\<partial>count_space UNIV) +\n  (d_IN f x +\n   ((\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. g (y, x)\n     \\<partial>count_space UNIV) -\n    (\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. f (y, x)\n     \\<partial>count_space UNIV)) -\n   d_IN g x)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source (residual_network g);\n        x \\<noteq> sink (residual_network g)\\<rbrakk>\n       \\<Longrightarrow> KIR (f \\<ominus> g) x", "have \"\\<dots> = (?g_less_f - ?f_out_less) + (d_IN f x + ?g_in - d_IN g x - ?f_in)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. g (x, y)\n     \\<partial>count_space UNIV) -\n    (\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. f (x, y)\n     \\<partial>count_space UNIV) +\n    (d_IN f x +\n     ((\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. g (y, x)\n       \\<partial>count_space UNIV) -\n      (\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. f (y, x)\n       \\<partial>count_space UNIV)) -\n     d_IN g x) =\n    (\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. g (x, y)\n     \\<partial>count_space UNIV) -\n    (\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. f (x, y)\n     \\<partial>count_space UNIV) +\n    (d_IN f x +\n     (\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. g (y, x)\n      \\<partial>count_space UNIV) -\n     d_IN g x -\n     (\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. f (y, x)\n      \\<partial>count_space UNIV))", "by (subst (2) add_diff_eq_ennreal) (auto intro!: nn_integral_mono split: split_indicator simp: diff_diff_commute_ennreal)"], ["proof (state)\nthis:\n  (\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. g (x, y)\n   \\<partial>count_space UNIV) -\n  (\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. f (x, y)\n   \\<partial>count_space UNIV) +\n  (d_IN f x +\n   ((\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. g (y, x)\n     \\<partial>count_space UNIV) -\n    (\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. f (y, x)\n     \\<partial>count_space UNIV)) -\n   d_IN g x) =\n  (\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. g (x, y)\n   \\<partial>count_space UNIV) -\n  (\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. f (x, y)\n   \\<partial>count_space UNIV) +\n  (d_IN f x +\n   (\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. g (y, x)\n    \\<partial>count_space UNIV) -\n   d_IN g x -\n   (\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. f (y, x)\n    \\<partial>count_space UNIV))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source (residual_network g);\n        x \\<noteq> sink (residual_network g)\\<rbrakk>\n       \\<Longrightarrow> KIR (f \\<ominus> g) x", "also"], ["proof (state)\nthis:\n  (\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. g (x, y)\n   \\<partial>count_space UNIV) -\n  (\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. f (x, y)\n   \\<partial>count_space UNIV) +\n  (d_IN f x +\n   ((\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. g (y, x)\n     \\<partial>count_space UNIV) -\n    (\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. f (y, x)\n     \\<partial>count_space UNIV)) -\n   d_IN g x) =\n  (\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. g (x, y)\n   \\<partial>count_space UNIV) -\n  (\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. f (x, y)\n   \\<partial>count_space UNIV) +\n  (d_IN f x +\n   (\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. g (y, x)\n    \\<partial>count_space UNIV) -\n   d_IN g x -\n   (\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. f (y, x)\n    \\<partial>count_space UNIV))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source (residual_network g);\n        x \\<noteq> sink (residual_network g)\\<rbrakk>\n       \\<Longrightarrow> KIR (f \\<ominus> g) x", "have \"\\<dots> = (?g_less_f - ?f_out_less) + (d_IN f x - (d_IN g x - ?g_in) - ?f_in)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. g (x, y)\n     \\<partial>count_space UNIV) -\n    (\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. f (x, y)\n     \\<partial>count_space UNIV) +\n    (d_IN f x +\n     (\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. g (y, x)\n      \\<partial>count_space UNIV) -\n     d_IN g x -\n     (\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. f (y, x)\n      \\<partial>count_space UNIV)) =\n    (\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. g (x, y)\n     \\<partial>count_space UNIV) -\n    (\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. f (x, y)\n     \\<partial>count_space UNIV) +\n    (d_IN f x -\n     (d_IN g x -\n      (\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. g (y, x)\n       \\<partial>count_space UNIV)) -\n     (\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. f (y, x)\n      \\<partial>count_space UNIV))", "apply (subst diff_diff_ennreal')"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. g (y, x)\n    \\<partial>count_space UNIV\n    \\<le> d_IN g x\n 2. d_IN g x -\n    (\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. g (y, x)\n     \\<partial>count_space UNIV)\n    \\<le> d_IN f x\n 3. (\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. g (x, y)\n     \\<partial>count_space UNIV) -\n    (\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. f (x, y)\n     \\<partial>count_space UNIV) +\n    (d_IN f x +\n     (\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. g (y, x)\n      \\<partial>count_space UNIV) -\n     d_IN g x -\n     (\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. f (y, x)\n      \\<partial>count_space UNIV)) =\n    (\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. g (x, y)\n     \\<partial>count_space UNIV) -\n    (\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. f (x, y)\n     \\<partial>count_space UNIV) +\n    (d_IN f x +\n     (\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. g (y, x)\n      \\<partial>count_space UNIV) -\n     d_IN g x -\n     (\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. f (y, x)\n      \\<partial>count_space UNIV))", "apply (auto simp: d_IN_def intro!: nn_integral_mono split: split_indicator)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ x. g (x, x)) -\n    (\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. g (y, x)\n     \\<partial>count_space UNIV)\n    \\<le> (\\<Sum>\\<^sup>+ x. f (x, x))", "apply (subst nn_integral_diff[symmetric])"], ["proof (prove)\ngoal (5 subgoals):\n 1. (\\<lambda>x. g (x, x)) \\<in> borel_measurable (count_space UNIV)\n 2. (\\<lambda>y. g (y, x) * indicator {y. f (y, x) < g (y, x)} y)\n    \\<in> borel_measurable (count_space UNIV)\n 3. \\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. g (y, x)\n    \\<partial>count_space UNIV \\<noteq>\n    \\<infinity>\n 4. AE x in count_space\n             UNIV. g (x, x) * indicator {y. f (y, x) < g (y, x)} x\n                   \\<le> g (x, x)\n 5. (\\<Sum>\\<^sup>+ x.\n       g (x, x) - g (x, x) * indicator {y. f (y, x) < g (y, x)} x)\n    \\<le> (\\<Sum>\\<^sup>+ x. f (x, x))", "apply (auto simp: AE_count_space finite_g_in intro!: nn_integral_mono split: split_indicator)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. g (x, y)\n   \\<partial>count_space UNIV) -\n  (\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. f (x, y)\n   \\<partial>count_space UNIV) +\n  (d_IN f x +\n   (\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. g (y, x)\n    \\<partial>count_space UNIV) -\n   d_IN g x -\n   (\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. f (y, x)\n    \\<partial>count_space UNIV)) =\n  (\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. g (x, y)\n   \\<partial>count_space UNIV) -\n  (\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. f (x, y)\n   \\<partial>count_space UNIV) +\n  (d_IN f x -\n   (d_IN g x -\n    (\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. g (y, x)\n     \\<partial>count_space UNIV)) -\n   (\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. f (y, x)\n    \\<partial>count_space UNIV))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source (residual_network g);\n        x \\<noteq> sink (residual_network g)\\<rbrakk>\n       \\<Longrightarrow> KIR (f \\<ominus> g) x", "also"], ["proof (state)\nthis:\n  (\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. g (x, y)\n   \\<partial>count_space UNIV) -\n  (\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. f (x, y)\n   \\<partial>count_space UNIV) +\n  (d_IN f x +\n   (\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. g (y, x)\n    \\<partial>count_space UNIV) -\n   d_IN g x -\n   (\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. f (y, x)\n    \\<partial>count_space UNIV)) =\n  (\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. g (x, y)\n   \\<partial>count_space UNIV) -\n  (\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. f (x, y)\n   \\<partial>count_space UNIV) +\n  (d_IN f x -\n   (d_IN g x -\n    (\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. g (y, x)\n     \\<partial>count_space UNIV)) -\n   (\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. f (y, x)\n    \\<partial>count_space UNIV))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source (residual_network g);\n        x \\<noteq> sink (residual_network g)\\<rbrakk>\n       \\<Longrightarrow> KIR (f \\<ominus> g) x", "have \"\\<dots> =(d_IN f x - ?f_in) - (d_IN g x - ?g_in) + (?g_less_f - ?f_out_less)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. g (x, y)\n     \\<partial>count_space UNIV) -\n    (\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. f (x, y)\n     \\<partial>count_space UNIV) +\n    (d_IN f x -\n     (d_IN g x -\n      (\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. g (y, x)\n       \\<partial>count_space UNIV)) -\n     (\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. f (y, x)\n      \\<partial>count_space UNIV)) =\n    d_IN f x -\n    (\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. f (y, x)\n     \\<partial>count_space UNIV) -\n    (d_IN g x -\n     (\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. g (y, x)\n      \\<partial>count_space UNIV)) +\n    ((\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. g (x, y)\n      \\<partial>count_space UNIV) -\n     (\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. f (x, y)\n      \\<partial>count_space UNIV))", "by (simp add: ac_simps diff_diff_commute_ennreal)"], ["proof (state)\nthis:\n  (\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. g (x, y)\n   \\<partial>count_space UNIV) -\n  (\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. f (x, y)\n   \\<partial>count_space UNIV) +\n  (d_IN f x -\n   (d_IN g x -\n    (\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. g (y, x)\n     \\<partial>count_space UNIV)) -\n   (\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. f (y, x)\n    \\<partial>count_space UNIV)) =\n  d_IN f x -\n  (\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. f (y, x)\n   \\<partial>count_space UNIV) -\n  (d_IN g x -\n   (\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. g (y, x)\n    \\<partial>count_space UNIV)) +\n  ((\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. g (x, y)\n    \\<partial>count_space UNIV) -\n   (\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. f (x, y)\n    \\<partial>count_space UNIV))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source (residual_network g);\n        x \\<noteq> sink (residual_network g)\\<rbrakk>\n       \\<Longrightarrow> KIR (f \\<ominus> g) x", "also"], ["proof (state)\nthis:\n  (\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. g (x, y)\n   \\<partial>count_space UNIV) -\n  (\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. f (x, y)\n   \\<partial>count_space UNIV) +\n  (d_IN f x -\n   (d_IN g x -\n    (\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. g (y, x)\n     \\<partial>count_space UNIV)) -\n   (\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. f (y, x)\n    \\<partial>count_space UNIV)) =\n  d_IN f x -\n  (\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. f (y, x)\n   \\<partial>count_space UNIV) -\n  (d_IN g x -\n   (\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. g (y, x)\n    \\<partial>count_space UNIV)) +\n  ((\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. g (x, y)\n    \\<partial>count_space UNIV) -\n   (\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. f (x, y)\n    \\<partial>count_space UNIV))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source (residual_network g);\n        x \\<noteq> sink (residual_network g)\\<rbrakk>\n       \\<Longrightarrow> KIR (f \\<ominus> g) x", "have \"?g_less_f - ?f_out_less = (\\<Sum>\\<^sup>+ y. (g (x, y) - f (x, y)) * indicator {y. f (x, y) < g (x, y)} y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. g (x, y)\n     \\<partial>count_space UNIV) -\n    (\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. f (x, y)\n     \\<partial>count_space UNIV) =\n    \\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. (g (x, y) - f (x, y))\n    \\<partial>count_space UNIV", "using finite_f_out"], ["proof (prove)\nusing this:\n  \\<integral>\\<^sup>+y\\<in>?A. f (x, y)\\<partial>count_space UNIV \\<noteq>\n  \\<top>\n\ngoal (1 subgoal):\n 1. (\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. g (x, y)\n     \\<partial>count_space UNIV) -\n    (\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. f (x, y)\n     \\<partial>count_space UNIV) =\n    \\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. (g (x, y) - f (x, y))\n    \\<partial>count_space UNIV", "by(subst nn_integral_diff[symmetric])(auto simp add: AE_count_space split: split_indicator intro!: nn_integral_cong)"], ["proof (state)\nthis:\n  (\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. g (x, y)\n   \\<partial>count_space UNIV) -\n  (\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. f (x, y)\n   \\<partial>count_space UNIV) =\n  \\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. (g (x, y) - f (x, y))\n  \\<partial>count_space UNIV\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source (residual_network g);\n        x \\<noteq> sink (residual_network g)\\<rbrakk>\n       \\<Longrightarrow> KIR (f \\<ominus> g) x", "also"], ["proof (state)\nthis:\n  (\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. g (x, y)\n   \\<partial>count_space UNIV) -\n  (\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. f (x, y)\n   \\<partial>count_space UNIV) =\n  \\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. (g (x, y) - f (x, y))\n  \\<partial>count_space UNIV\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source (residual_network g);\n        x \\<noteq> sink (residual_network g)\\<rbrakk>\n       \\<Longrightarrow> KIR (f \\<ominus> g) x", "have \"\\<dots> = (\\<Sum>\\<^sup>+ y. (g (x, y) - f (x, y)) * indicator \\<^bold>E (x, y) * indicator {y. f (x, y) < g (x, y)} y)\" (is \"_ = ?diff_out\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. (g (x, y) - f (x, y))\n    \\<partial>count_space UNIV =\n    \\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}.\n                       ((g (x, y) - f (x, y)) * indicator \\<^bold>E (x, y))\n    \\<partial>count_space UNIV", "using flowD_outside[OF f] flowD_outside[OF g]"], ["proof (prove)\nusing this:\n  ?e \\<notin> \\<^bold>E \\<Longrightarrow> f ?e = 0\n  ?e \\<notin> \\<^bold>E \\<Longrightarrow> g ?e = 0\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. (g (x, y) - f (x, y))\n    \\<partial>count_space UNIV =\n    \\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}.\n                       ((g (x, y) - f (x, y)) * indicator \\<^bold>E (x, y))\n    \\<partial>count_space UNIV", "by(auto intro!: nn_integral_cong split: split_indicator)"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. (g (x, y) - f (x, y))\n  \\<partial>count_space UNIV =\n  \\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}.\n                     ((g (x, y) - f (x, y)) * indicator \\<^bold>E (x, y))\n  \\<partial>count_space UNIV\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source (residual_network g);\n        x \\<noteq> sink (residual_network g)\\<rbrakk>\n       \\<Longrightarrow> KIR (f \\<ominus> g) x", "also"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}. (g (x, y) - f (x, y))\n  \\<partial>count_space UNIV =\n  \\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}.\n                     ((g (x, y) - f (x, y)) * indicator \\<^bold>E (x, y))\n  \\<partial>count_space UNIV\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source (residual_network g);\n        x \\<noteq> sink (residual_network g)\\<rbrakk>\n       \\<Longrightarrow> KIR (f \\<ominus> g) x", "have \"d_IN f x - ?f_in = (\\<Sum>\\<^sup>+ y. f (y, x) * indicator {y. g (y, x) \\<le> f (y, x)} y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN f x -\n    (\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. f (y, x)\n     \\<partial>count_space UNIV) =\n    \\<integral>\\<^sup>+y\\<in>{y. g (y, x) \\<le> f (y, x)}. f (y, x)\n    \\<partial>count_space UNIV", "unfolding d_IN_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ x. f (x, x)) -\n    (\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. f (y, x)\n     \\<partial>count_space UNIV) =\n    \\<integral>\\<^sup>+y\\<in>{y. g (y, x) \\<le> f (y, x)}. f (y, x)\n    \\<partial>count_space UNIV", "using finite_f_in"], ["proof (prove)\nusing this:\n  \\<integral>\\<^sup>+y\\<in>?A. f (y, x)\\<partial>count_space UNIV \\<noteq>\n  \\<top>\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ x. f (x, x)) -\n    (\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. f (y, x)\n     \\<partial>count_space UNIV) =\n    \\<integral>\\<^sup>+y\\<in>{y. g (y, x) \\<le> f (y, x)}. f (y, x)\n    \\<partial>count_space UNIV", "apply(subst nn_integral_diff[symmetric])"], ["proof (prove)\ngoal (5 subgoals):\n 1. (\\<And>A.\n        \\<integral>\\<^sup>+y\\<in>A. f (y, x)\n        \\<partial>count_space UNIV \\<noteq>\n        \\<top>) \\<Longrightarrow>\n    (\\<lambda>x. f (x, x)) \\<in> borel_measurable (count_space UNIV)\n 2. (\\<And>A.\n        \\<integral>\\<^sup>+y\\<in>A. f (y, x)\n        \\<partial>count_space UNIV \\<noteq>\n        \\<top>) \\<Longrightarrow>\n    (\\<lambda>y. f (y, x) * indicator {y. f (y, x) < g (y, x)} y)\n    \\<in> borel_measurable (count_space UNIV)\n 3. (\\<And>A.\n        \\<integral>\\<^sup>+y\\<in>A. f (y, x)\n        \\<partial>count_space UNIV \\<noteq>\n        \\<top>) \\<Longrightarrow>\n    \\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. f (y, x)\n    \\<partial>count_space UNIV \\<noteq>\n    \\<infinity>\n 4. (\\<And>A.\n        \\<integral>\\<^sup>+y\\<in>A. f (y, x)\n        \\<partial>count_space UNIV \\<noteq>\n        \\<top>) \\<Longrightarrow>\n    AE x in count_space\n             UNIV. f (x, x) * indicator {y. f (y, x) < g (y, x)} x\n                   \\<le> f (x, x)\n 5. (\\<And>A.\n        \\<integral>\\<^sup>+y\\<in>A. f (y, x)\n        \\<partial>count_space UNIV \\<noteq>\n        \\<top>) \\<Longrightarrow>\n    (\\<Sum>\\<^sup>+ x.\n       f (x, x) - f (x, x) * indicator {y. f (y, x) < g (y, x)} x) =\n    \\<integral>\\<^sup>+y\\<in>{y. g (y, x) \\<le> f (y, x)}. f (y, x)\n    \\<partial>count_space UNIV", "apply(auto simp add: AE_count_space split: split_indicator intro!: nn_integral_cong)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  d_IN f x -\n  (\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. f (y, x)\n   \\<partial>count_space UNIV) =\n  \\<integral>\\<^sup>+y\\<in>{y. g (y, x) \\<le> f (y, x)}. f (y, x)\n  \\<partial>count_space UNIV\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source (residual_network g);\n        x \\<noteq> sink (residual_network g)\\<rbrakk>\n       \\<Longrightarrow> KIR (f \\<ominus> g) x", "also"], ["proof (state)\nthis:\n  d_IN f x -\n  (\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. f (y, x)\n   \\<partial>count_space UNIV) =\n  \\<integral>\\<^sup>+y\\<in>{y. g (y, x) \\<le> f (y, x)}. f (y, x)\n  \\<partial>count_space UNIV\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source (residual_network g);\n        x \\<noteq> sink (residual_network g)\\<rbrakk>\n       \\<Longrightarrow> KIR (f \\<ominus> g) x", "have \"d_IN g x - ?g_in = (\\<Sum>\\<^sup>+ y. g (y, x) * indicator {y. g (y, x) \\<le> f (y, x)} y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN g x -\n    (\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. g (y, x)\n     \\<partial>count_space UNIV) =\n    \\<integral>\\<^sup>+y\\<in>{y. g (y, x) \\<le> f (y, x)}. g (y, x)\n    \\<partial>count_space UNIV", "unfolding d_IN_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ x. g (x, x)) -\n    (\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. g (y, x)\n     \\<partial>count_space UNIV) =\n    \\<integral>\\<^sup>+y\\<in>{y. g (y, x) \\<le> f (y, x)}. g (y, x)\n    \\<partial>count_space UNIV", "using finite_g_in"], ["proof (prove)\nusing this:\n  \\<integral>\\<^sup>+y\\<in>?A. g (y, x)\\<partial>count_space UNIV \\<noteq>\n  \\<top>\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ x. g (x, x)) -\n    (\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. g (y, x)\n     \\<partial>count_space UNIV) =\n    \\<integral>\\<^sup>+y\\<in>{y. g (y, x) \\<le> f (y, x)}. g (y, x)\n    \\<partial>count_space UNIV", "by(subst nn_integral_diff[symmetric])(auto simp add: flowD_finite[OF g] AE_count_space split: split_indicator intro!: nn_integral_cong)"], ["proof (state)\nthis:\n  d_IN g x -\n  (\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. g (y, x)\n   \\<partial>count_space UNIV) =\n  \\<integral>\\<^sup>+y\\<in>{y. g (y, x) \\<le> f (y, x)}. g (y, x)\n  \\<partial>count_space UNIV\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source (residual_network g);\n        x \\<noteq> sink (residual_network g)\\<rbrakk>\n       \\<Longrightarrow> KIR (f \\<ominus> g) x", "also"], ["proof (state)\nthis:\n  d_IN g x -\n  (\\<integral>\\<^sup>+y\\<in>{y. f (y, x) < g (y, x)}. g (y, x)\n   \\<partial>count_space UNIV) =\n  \\<integral>\\<^sup>+y\\<in>{y. g (y, x) \\<le> f (y, x)}. g (y, x)\n  \\<partial>count_space UNIV\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source (residual_network g);\n        x \\<noteq> sink (residual_network g)\\<rbrakk>\n       \\<Longrightarrow> KIR (f \\<ominus> g) x", "have \"(\\<Sum>\\<^sup>+ y\\<in>UNIV. f (y, x) * indicator {y. g (y, x) \\<le> f (y, x)} y) - \\<dots> = (\\<Sum>\\<^sup>+ y. (f (y, x) - g (y, x)) * indicator {y. g (y, x) \\<le> f (y, x)} y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<integral>\\<^sup>+y\\<in>{y. g (y, x) \\<le> f (y, x)}. f (y, x)\n     \\<partial>count_space UNIV) -\n    (\\<integral>\\<^sup>+y\\<in>{y. g (y, x) \\<le> f (y, x)}. g (y, x)\n     \\<partial>count_space UNIV) =\n    \\<integral>\\<^sup>+y\\<in>{y. g (y, x) \\<le> f (y, x)}.\n                       (f (y, x) - g (y, x))\n    \\<partial>count_space UNIV", "using finite_g_in"], ["proof (prove)\nusing this:\n  \\<integral>\\<^sup>+y\\<in>?A. g (y, x)\\<partial>count_space UNIV \\<noteq>\n  \\<top>\n\ngoal (1 subgoal):\n 1. (\\<integral>\\<^sup>+y\\<in>{y. g (y, x) \\<le> f (y, x)}. f (y, x)\n     \\<partial>count_space UNIV) -\n    (\\<integral>\\<^sup>+y\\<in>{y. g (y, x) \\<le> f (y, x)}. g (y, x)\n     \\<partial>count_space UNIV) =\n    \\<integral>\\<^sup>+y\\<in>{y. g (y, x) \\<le> f (y, x)}.\n                       (f (y, x) - g (y, x))\n    \\<partial>count_space UNIV", "by(subst nn_integral_diff[symmetric])(auto simp add: flowD_finite[OF g] AE_count_space split: split_indicator intro!: nn_integral_cong)"], ["proof (state)\nthis:\n  (\\<integral>\\<^sup>+y\\<in>{y. g (y, x) \\<le> f (y, x)}. f (y, x)\n   \\<partial>count_space UNIV) -\n  (\\<integral>\\<^sup>+y\\<in>{y. g (y, x) \\<le> f (y, x)}. g (y, x)\n   \\<partial>count_space UNIV) =\n  \\<integral>\\<^sup>+y\\<in>{y. g (y, x) \\<le> f (y, x)}.\n                     (f (y, x) - g (y, x))\n  \\<partial>count_space UNIV\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source (residual_network g);\n        x \\<noteq> sink (residual_network g)\\<rbrakk>\n       \\<Longrightarrow> KIR (f \\<ominus> g) x", "also"], ["proof (state)\nthis:\n  (\\<integral>\\<^sup>+y\\<in>{y. g (y, x) \\<le> f (y, x)}. f (y, x)\n   \\<partial>count_space UNIV) -\n  (\\<integral>\\<^sup>+y\\<in>{y. g (y, x) \\<le> f (y, x)}. g (y, x)\n   \\<partial>count_space UNIV) =\n  \\<integral>\\<^sup>+y\\<in>{y. g (y, x) \\<le> f (y, x)}.\n                     (f (y, x) - g (y, x))\n  \\<partial>count_space UNIV\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source (residual_network g);\n        x \\<noteq> sink (residual_network g)\\<rbrakk>\n       \\<Longrightarrow> KIR (f \\<ominus> g) x", "have \"\\<dots> = (\\<Sum>\\<^sup>+ y. (f (y, x) - g (y, x)) * indicator \\<^bold>E (y, x) * indicator {y. g (y, x) \\<le> f (y, x)} y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+y\\<in>{y. g (y, x) \\<le> f (y, x)}.\n                       (f (y, x) - g (y, x))\n    \\<partial>count_space UNIV =\n    \\<integral>\\<^sup>+y\\<in>{y. g (y, x) \\<le> f (y, x)}.\n                       ((f (y, x) - g (y, x)) * indicator \\<^bold>E (y, x))\n    \\<partial>count_space UNIV", "using flowD_outside[OF f] flowD_outside[OF g]"], ["proof (prove)\nusing this:\n  ?e \\<notin> \\<^bold>E \\<Longrightarrow> f ?e = 0\n  ?e \\<notin> \\<^bold>E \\<Longrightarrow> g ?e = 0\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+y\\<in>{y. g (y, x) \\<le> f (y, x)}.\n                       (f (y, x) - g (y, x))\n    \\<partial>count_space UNIV =\n    \\<integral>\\<^sup>+y\\<in>{y. g (y, x) \\<le> f (y, x)}.\n                       ((f (y, x) - g (y, x)) * indicator \\<^bold>E (y, x))\n    \\<partial>count_space UNIV", "by(auto intro!: nn_integral_cong split: split_indicator)"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+y\\<in>{y. g (y, x) \\<le> f (y, x)}.\n                     (f (y, x) - g (y, x))\n  \\<partial>count_space UNIV =\n  \\<integral>\\<^sup>+y\\<in>{y. g (y, x) \\<le> f (y, x)}.\n                     ((f (y, x) - g (y, x)) * indicator \\<^bold>E (y, x))\n  \\<partial>count_space UNIV\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source (residual_network g);\n        x \\<noteq> sink (residual_network g)\\<rbrakk>\n       \\<Longrightarrow> KIR (f \\<ominus> g) x", "also"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+y\\<in>{y. g (y, x) \\<le> f (y, x)}.\n                     (f (y, x) - g (y, x))\n  \\<partial>count_space UNIV =\n  \\<integral>\\<^sup>+y\\<in>{y. g (y, x) \\<le> f (y, x)}.\n                     ((f (y, x) - g (y, x)) * indicator \\<^bold>E (y, x))\n  \\<partial>count_space UNIV\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source (residual_network g);\n        x \\<noteq> sink (residual_network g)\\<rbrakk>\n       \\<Longrightarrow> KIR (f \\<ominus> g) x", "have \"\\<dots> + ?diff_out = d_IN ?f x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<integral>\\<^sup>+y\\<in>{y. g (y, x) \\<le> f (y, x)}.\n                        ((f (y, x) - g (y, x)) * indicator \\<^bold>E (y, x))\n     \\<partial>count_space UNIV) +\n    (\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}.\n                        ((g (x, y) - f (x, y)) * indicator \\<^bold>E (x, y))\n     \\<partial>count_space UNIV) =\n    d_IN (f \\<ominus> g) x", "using flowD_finite[OF g]"], ["proof (prove)\nusing this:\n  g ?e \\<noteq> \\<top>\n\ngoal (1 subgoal):\n 1. (\\<integral>\\<^sup>+y\\<in>{y. g (y, x) \\<le> f (y, x)}.\n                        ((f (y, x) - g (y, x)) * indicator \\<^bold>E (y, x))\n     \\<partial>count_space UNIV) +\n    (\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}.\n                        ((g (x, y) - f (x, y)) * indicator \\<^bold>E (x, y))\n     \\<partial>count_space UNIV) =\n    d_IN (f \\<ominus> g) x", "apply(subst nn_integral_add[symmetric])"], ["proof (prove)\ngoal (3 subgoals):\n 1. (\\<And>e. g e \\<noteq> \\<top>) \\<Longrightarrow>\n    (\\<lambda>y.\n        (f (y, x) - g (y, x)) * indicator \\<^bold>E (y, x) *\n        indicator {y. g (y, x) \\<le> f (y, x)} y)\n    \\<in> borel_measurable (count_space UNIV)\n 2. (\\<And>e. g e \\<noteq> \\<top>) \\<Longrightarrow>\n    (\\<lambda>y.\n        (g (x, y) - f (x, y)) * indicator \\<^bold>E (x, y) *\n        indicator {y. f (x, y) < g (x, y)} y)\n    \\<in> borel_measurable (count_space UNIV)\n 3. (\\<And>e. g e \\<noteq> \\<top>) \\<Longrightarrow>\n    (\\<Sum>\\<^sup>+ x.\n       (f (x, x) - g (x, x)) * indicator \\<^bold>E (x, x) *\n       indicator {y. g (y, x) \\<le> f (y, x)} x +\n       (g (x, x) - f (x, x)) * indicator \\<^bold>E (x, x) *\n       indicator {y. f (x, y) < g (x, y)} x) =\n    d_IN (f \\<ominus> g) x", "apply(auto 4 4 simp add: d_IN_def not_le less_top[symmetric] intro!: nn_integral_cong\n               dest!: wf_residual_networkD[OF wf] split: split_indicator intro: diff_eq_0_ennreal)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (\\<integral>\\<^sup>+y\\<in>{y. g (y, x) \\<le> f (y, x)}.\n                      ((f (y, x) - g (y, x)) * indicator \\<^bold>E (y, x))\n   \\<partial>count_space UNIV) +\n  (\\<integral>\\<^sup>+y\\<in>{y. f (x, y) < g (x, y)}.\n                      ((g (x, y) - f (x, y)) * indicator \\<^bold>E (x, y))\n   \\<partial>count_space UNIV) =\n  d_IN (f \\<ominus> g) x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source (residual_network g);\n        x \\<noteq> sink (residual_network g)\\<rbrakk>\n       \\<Longrightarrow> KIR (f \\<ominus> g) x", "finally"], ["proof (chain)\npicking this:\n  KIR (f \\<ominus> g) x", "show \"KIR ?f x\""], ["proof (prove)\nusing this:\n  KIR (f \\<ominus> g) x\n\ngoal (1 subgoal):\n 1. KIR (f \\<ominus> g) x", "."], ["proof (state)\nthis:\n  KIR (f \\<ominus> g) x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma value_minus_flow:\n  assumes f: \"flow \\<Delta> f\"\n  and g: \"flow \\<Delta> g\"\n  and value_le: \"value_flow \\<Delta> g \\<le> value_flow \\<Delta> f\"\n  and source_out: \"\\<And>y. edge \\<Delta> (source \\<Delta>) y \\<longleftrightarrow> y = x\"\n  shows \"value_flow \\<Delta> (f \\<ominus> g) = value_flow \\<Delta> f - value_flow \\<Delta> g\" (is \"?value\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. value_flow \\<Delta> (f \\<ominus> g) =\n    value_flow \\<Delta> f - value_flow \\<Delta> g", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. value_flow \\<Delta> (f \\<ominus> g) =\n    value_flow \\<Delta> f - value_flow \\<Delta> g", "have \"value_flow \\<Delta> (f \\<ominus> g) = (\\<Sum>\\<^sup>+ y\\<in>\\<^bold>O\\<^bold>U\\<^bold>T (source \\<Delta>). (f \\<ominus> g) (source \\<Delta>, y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. value_flow \\<Delta> (f \\<ominus> g) =\n    (\\<Sum>\\<^sup>+ y\\<in>\\<^bold>O\\<^bold>U\\<^bold>T (source \\<Delta>).\n       (f \\<ominus> g) (source \\<Delta>, y))", "by(subst d_OUT_alt_def)(auto simp add: flowD_outside[OF f] flowD_outside[OF g] source_in)"], ["proof (state)\nthis:\n  value_flow \\<Delta> (f \\<ominus> g) =\n  (\\<Sum>\\<^sup>+ y\\<in>\\<^bold>O\\<^bold>U\\<^bold>T (source \\<Delta>).\n     (f \\<ominus> g) (source \\<Delta>, y))\n\ngoal (1 subgoal):\n 1. value_flow \\<Delta> (f \\<ominus> g) =\n    value_flow \\<Delta> f - value_flow \\<Delta> g", "also"], ["proof (state)\nthis:\n  value_flow \\<Delta> (f \\<ominus> g) =\n  (\\<Sum>\\<^sup>+ y\\<in>\\<^bold>O\\<^bold>U\\<^bold>T (source \\<Delta>).\n     (f \\<ominus> g) (source \\<Delta>, y))\n\ngoal (1 subgoal):\n 1. value_flow \\<Delta> (f \\<ominus> g) =\n    value_flow \\<Delta> f - value_flow \\<Delta> g", "have \"\\<dots> = (\\<Sum>\\<^sup>+ y. (f (source \\<Delta>, y) - g (source \\<Delta>, y)) * indicator {x} y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y\\<in>\\<^bold>O\\<^bold>U\\<^bold>T (source \\<Delta>).\n       (f \\<ominus> g) (source \\<Delta>, y)) =\n    \\<integral>\\<^sup>+y\\<in>{x}.\n                       (f (source \\<Delta>, y) - g (source \\<Delta>, y))\n    \\<partial>count_space UNIV", "by(subst nn_integral_count_space_indicator)(auto intro!: nn_integral_cong split: split_indicator simp add: outgoing_def source_out)"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y\\<in>\\<^bold>O\\<^bold>U\\<^bold>T (source \\<Delta>).\n     (f \\<ominus> g) (source \\<Delta>, y)) =\n  \\<integral>\\<^sup>+y\\<in>{x}.\n                     (f (source \\<Delta>, y) - g (source \\<Delta>, y))\n  \\<partial>count_space UNIV\n\ngoal (1 subgoal):\n 1. value_flow \\<Delta> (f \\<ominus> g) =\n    value_flow \\<Delta> f - value_flow \\<Delta> g", "also"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y\\<in>\\<^bold>O\\<^bold>U\\<^bold>T (source \\<Delta>).\n     (f \\<ominus> g) (source \\<Delta>, y)) =\n  \\<integral>\\<^sup>+y\\<in>{x}.\n                     (f (source \\<Delta>, y) - g (source \\<Delta>, y))\n  \\<partial>count_space UNIV\n\ngoal (1 subgoal):\n 1. value_flow \\<Delta> (f \\<ominus> g) =\n    value_flow \\<Delta> f - value_flow \\<Delta> g", "have \"\\<dots> = f (source \\<Delta>, x) - g (source \\<Delta>, x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+y\\<in>{x}.\n                       (f (source \\<Delta>, y) - g (source \\<Delta>, y))\n    \\<partial>count_space UNIV =\n    f (source \\<Delta>, x) - g (source \\<Delta>, x)", "using value_le value_flow[OF f source_out] value_flow[OF g source_out]"], ["proof (prove)\nusing this:\n  value_flow \\<Delta> g \\<le> value_flow \\<Delta> f\n  value_flow \\<Delta> f = f (source \\<Delta>, x)\n  value_flow \\<Delta> g = g (source \\<Delta>, x)\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+y\\<in>{x}.\n                       (f (source \\<Delta>, y) - g (source \\<Delta>, y))\n    \\<partial>count_space UNIV =\n    f (source \\<Delta>, x) - g (source \\<Delta>, x)", "by(auto simp add: one_ennreal_def[symmetric] max_def not_le intro: antisym)"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+y\\<in>{x}.\n                     (f (source \\<Delta>, y) - g (source \\<Delta>, y))\n  \\<partial>count_space UNIV =\n  f (source \\<Delta>, x) - g (source \\<Delta>, x)\n\ngoal (1 subgoal):\n 1. value_flow \\<Delta> (f \\<ominus> g) =\n    value_flow \\<Delta> f - value_flow \\<Delta> g", "also"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+y\\<in>{x}.\n                     (f (source \\<Delta>, y) - g (source \\<Delta>, y))\n  \\<partial>count_space UNIV =\n  f (source \\<Delta>, x) - g (source \\<Delta>, x)\n\ngoal (1 subgoal):\n 1. value_flow \\<Delta> (f \\<ominus> g) =\n    value_flow \\<Delta> f - value_flow \\<Delta> g", "have \"\\<dots> = value_flow \\<Delta> f - value_flow \\<Delta> g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f (source \\<Delta>, x) - g (source \\<Delta>, x) =\n    value_flow \\<Delta> f - value_flow \\<Delta> g", "using f g source_out"], ["proof (prove)\nusing this:\n  flow \\<Delta> f\n  flow \\<Delta> g\n  edge \\<Delta> (source \\<Delta>) ?y = (?y = x)\n\ngoal (1 subgoal):\n 1. f (source \\<Delta>, x) - g (source \\<Delta>, x) =\n    value_flow \\<Delta> f - value_flow \\<Delta> g", "by(simp add: value_flow)"], ["proof (state)\nthis:\n  f (source \\<Delta>, x) - g (source \\<Delta>, x) =\n  value_flow \\<Delta> f - value_flow \\<Delta> g\n\ngoal (1 subgoal):\n 1. value_flow \\<Delta> (f \\<ominus> g) =\n    value_flow \\<Delta> f - value_flow \\<Delta> g", "finally"], ["proof (chain)\npicking this:\n  value_flow \\<Delta> (f \\<ominus> g) =\n  value_flow \\<Delta> f - value_flow \\<Delta> g", "show ?value"], ["proof (prove)\nusing this:\n  value_flow \\<Delta> (f \\<ominus> g) =\n  value_flow \\<Delta> f - value_flow \\<Delta> g\n\ngoal (1 subgoal):\n 1. value_flow \\<Delta> (f \\<ominus> g) =\n    value_flow \\<Delta> f - value_flow \\<Delta> g", "."], ["proof (state)\nthis:\n  value_flow \\<Delta> (f \\<ominus> g) =\n  value_flow \\<Delta> f - value_flow \\<Delta> g\n\ngoal:\nNo subgoals!", "qed"], ["", "context\n  fixes \\<alpha>\n  defines \"\\<alpha> \\<equiv> (SUP g\\<in>{g. flow \\<Delta> g}. value_flow \\<Delta> g)\"\nbegin"], ["", "lemma flow_by_value:\n  assumes \"v < \\<alpha>\"\n  and real[rule_format]: \"\\<forall>f. \\<alpha> = \\<top> \\<longrightarrow> flow \\<Delta> f \\<longrightarrow> value_flow \\<Delta> f < \\<alpha>\"\n  obtains f where \"flow \\<Delta> f\" \"value_flow \\<Delta> f = v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>f.\n        \\<lbrakk>flow \\<Delta> f; value_flow \\<Delta> f = v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>f.\n        \\<lbrakk>flow \\<Delta> f; value_flow \\<Delta> f = v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \\<alpha>_pos: \"\\<alpha> > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < \\<alpha>", "using assms"], ["proof (prove)\nusing this:\n  v < \\<alpha>\n  \\<forall>f.\n     \\<alpha> = \\<top> \\<longrightarrow>\n     flow \\<Delta> f \\<longrightarrow> value_flow \\<Delta> f < \\<alpha>\n\ngoal (1 subgoal):\n 1. 0 < \\<alpha>", "by (auto simp add: zero_less_iff_neq_zero)"], ["proof (state)\nthis:\n  0 < \\<alpha>\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        \\<lbrakk>flow \\<Delta> f; value_flow \\<Delta> f = v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from \\<open>v < \\<alpha>\\<close>"], ["proof (chain)\npicking this:\n  v < \\<alpha>", "obtain f where f: \"flow \\<Delta> f\" and v: \"v < value_flow \\<Delta> f\""], ["proof (prove)\nusing this:\n  v < \\<alpha>\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        \\<lbrakk>flow \\<Delta> f; v < value_flow \\<Delta> f\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding \\<alpha>_def less_SUP_iff"], ["proof (prove)\nusing this:\n  \\<exists>x\\<in>Collect (flow \\<Delta>). v < value_flow \\<Delta> x\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        \\<lbrakk>flow \\<Delta> f; v < value_flow \\<Delta> f\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  flow \\<Delta> f\n  v < value_flow \\<Delta> f\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        \\<lbrakk>flow \\<Delta> f; value_flow \\<Delta> f = v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have [simp]: \"value_flow \\<Delta> f \\<noteq> \\<top>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. value_flow \\<Delta> f \\<noteq> \\<top>", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. value_flow \\<Delta> f = \\<top> \\<Longrightarrow> False", "assume val: \"value_flow \\<Delta> f = \\<top>\""], ["proof (state)\nthis:\n  value_flow \\<Delta> f = \\<top>\n\ngoal (1 subgoal):\n 1. value_flow \\<Delta> f = \\<top> \\<Longrightarrow> False", "from f"], ["proof (chain)\npicking this:\n  flow \\<Delta> f", "have \"value_flow \\<Delta> f \\<le> \\<alpha>\""], ["proof (prove)\nusing this:\n  flow \\<Delta> f\n\ngoal (1 subgoal):\n 1. value_flow \\<Delta> f \\<le> \\<alpha>", "unfolding \\<alpha>_def"], ["proof (prove)\nusing this:\n  flow \\<Delta> f\n\ngoal (1 subgoal):\n 1. value_flow \\<Delta> f\n    \\<le> \\<Squnion> (value_flow \\<Delta> ` {g. flow \\<Delta> g})", "by(blast intro: SUP_upper2)"], ["proof (state)\nthis:\n  value_flow \\<Delta> f \\<le> \\<alpha>\n\ngoal (1 subgoal):\n 1. value_flow \\<Delta> f = \\<top> \\<Longrightarrow> False", "with val"], ["proof (chain)\npicking this:\n  value_flow \\<Delta> f = \\<top>\n  value_flow \\<Delta> f \\<le> \\<alpha>", "have \"\\<alpha> = \\<top>\""], ["proof (prove)\nusing this:\n  value_flow \\<Delta> f = \\<top>\n  value_flow \\<Delta> f \\<le> \\<alpha>\n\ngoal (1 subgoal):\n 1. \\<alpha> = \\<top>", "by (simp add: top_unique)"], ["proof (state)\nthis:\n  \\<alpha> = \\<top>\n\ngoal (1 subgoal):\n 1. value_flow \\<Delta> f = \\<top> \\<Longrightarrow> False", "from real[OF this f] val"], ["proof (chain)\npicking this:\n  value_flow \\<Delta> f < \\<alpha>\n  value_flow \\<Delta> f = \\<top>", "show False"], ["proof (prove)\nusing this:\n  value_flow \\<Delta> f < \\<alpha>\n  value_flow \\<Delta> f = \\<top>\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  value_flow \\<Delta> f \\<noteq> \\<top>\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        \\<lbrakk>flow \\<Delta> f; value_flow \\<Delta> f = v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "let ?f = \"\\<lambda>e. (v / value_flow \\<Delta> f) * f e\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>f.\n        \\<lbrakk>flow \\<Delta> f; value_flow \\<Delta> f = v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "note f"], ["proof (state)\nthis:\n  flow \\<Delta> f\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        \\<lbrakk>flow \\<Delta> f; value_flow \\<Delta> f = v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  flow \\<Delta> f\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        \\<lbrakk>flow \\<Delta> f; value_flow \\<Delta> f = v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have *: \"0 < value_flow \\<Delta> f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < value_flow \\<Delta> f", "using \\<open>v < value_flow \\<Delta> f\\<close>"], ["proof (prove)\nusing this:\n  v < value_flow \\<Delta> f\n\ngoal (1 subgoal):\n 1. 0 < value_flow \\<Delta> f", "by (auto simp add: zero_less_iff_neq_zero)"], ["proof (state)\nthis:\n  0 < value_flow \\<Delta> f\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        \\<lbrakk>flow \\<Delta> f; value_flow \\<Delta> f = v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  0 < value_flow \\<Delta> f", "have \"v / value_flow \\<Delta> f \\<le> 1\""], ["proof (prove)\nusing this:\n  0 < value_flow \\<Delta> f\n\ngoal (1 subgoal):\n 1. v / value_flow \\<Delta> f \\<le> 1", "using v"], ["proof (prove)\nusing this:\n  0 < value_flow \\<Delta> f\n  v < value_flow \\<Delta> f\n\ngoal (1 subgoal):\n 1. v / value_flow \\<Delta> f \\<le> 1", "by (auto intro!: divide_le_posI_ennreal)"], ["proof (state)\nthis:\n  v / value_flow \\<Delta> f \\<le> 1\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        \\<lbrakk>flow \\<Delta> f; value_flow \\<Delta> f = v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "ultimately"], ["proof (chain)\npicking this:\n  flow \\<Delta> f\n  v / value_flow \\<Delta> f \\<le> 1", "have \"flow \\<Delta> ?f\""], ["proof (prove)\nusing this:\n  flow \\<Delta> f\n  v / value_flow \\<Delta> f \\<le> 1\n\ngoal (1 subgoal):\n 1. flow \\<Delta> (\\<lambda>e. v / value_flow \\<Delta> f * f e)", "by (rule scale_flow)"], ["proof (state)\nthis:\n  flow \\<Delta> (\\<lambda>e. v / value_flow \\<Delta> f * f e)\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        \\<lbrakk>flow \\<Delta> f; value_flow \\<Delta> f = v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  flow \\<Delta> (\\<lambda>e. v / value_flow \\<Delta> f * f e)\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        \\<lbrakk>flow \\<Delta> f; value_flow \\<Delta> f = v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "{"], ["proof (state)\nthis:\n  flow \\<Delta> (\\<lambda>e. v / value_flow \\<Delta> f * f e)\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        \\<lbrakk>flow \\<Delta> f; value_flow \\<Delta> f = v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"value_flow \\<Delta> ?f = v * (value_flow \\<Delta> f / value_flow \\<Delta> f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. value_flow \\<Delta> (\\<lambda>e. v / value_flow \\<Delta> f * f e) =\n    v * (value_flow \\<Delta> f / value_flow \\<Delta> f)", "by(subst value_scale_flow)(simp add: divide_ennreal_def ac_simps)"], ["proof (state)\nthis:\n  value_flow \\<Delta> (\\<lambda>e. v / value_flow \\<Delta> f * f e) =\n  v * (value_flow \\<Delta> f / value_flow \\<Delta> f)\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        \\<lbrakk>flow \\<Delta> f; value_flow \\<Delta> f = v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "also"], ["proof (state)\nthis:\n  value_flow \\<Delta> (\\<lambda>e. v / value_flow \\<Delta> f * f e) =\n  v * (value_flow \\<Delta> f / value_flow \\<Delta> f)\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        \\<lbrakk>flow \\<Delta> f; value_flow \\<Delta> f = v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"\\<dots> = v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v * (value_flow \\<Delta> f / value_flow \\<Delta> f) = v", "using *"], ["proof (prove)\nusing this:\n  0 < value_flow \\<Delta> f\n\ngoal (1 subgoal):\n 1. v * (value_flow \\<Delta> f / value_flow \\<Delta> f) = v", "by(subst ennreal_divide_self) (auto simp: less_top[symmetric])"], ["proof (state)\nthis:\n  v * (value_flow \\<Delta> f / value_flow \\<Delta> f) = v\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        \\<lbrakk>flow \\<Delta> f; value_flow \\<Delta> f = v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "also"], ["proof (state)\nthis:\n  v * (value_flow \\<Delta> f / value_flow \\<Delta> f) = v\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        \\<lbrakk>flow \\<Delta> f; value_flow \\<Delta> f = v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "note calculation"], ["proof (state)\nthis:\n  value_flow \\<Delta> (\\<lambda>e. v / value_flow \\<Delta> f * f e) = v\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        \\<lbrakk>flow \\<Delta> f; value_flow \\<Delta> f = v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "}"], ["proof (state)\nthis:\n  value_flow \\<Delta> (\\<lambda>e. v / value_flow \\<Delta> f * f e) = v\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        \\<lbrakk>flow \\<Delta> f; value_flow \\<Delta> f = v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "ultimately"], ["proof (chain)\npicking this:\n  flow \\<Delta> (\\<lambda>e. v / value_flow \\<Delta> f * f e)\n  value_flow \\<Delta> (\\<lambda>e. v / value_flow \\<Delta> f * f e) = v", "show ?thesis"], ["proof (prove)\nusing this:\n  flow \\<Delta> (\\<lambda>e. v / value_flow \\<Delta> f * f e)\n  value_flow \\<Delta> (\\<lambda>e. v / value_flow \\<Delta> f * f e) = v\n\ngoal (1 subgoal):\n 1. thesis", "by(rule that)"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem ex_max_flow':\n  assumes wf: \"wf_residual_network\"\n  assumes source_out: \"\\<And>y. edge \\<Delta> (source \\<Delta>) y \\<longleftrightarrow> y = x\"\n  and nontrivial: \"\\<^bold>V - {source \\<Delta>, sink \\<Delta>} \\<noteq> {}\"\n  and real: \"\\<alpha> = ennreal \\<alpha>'\" and \\<alpha>'_nonneg[simp]: \"0 \\<le> \\<alpha>'\"\n  shows \"\\<exists>f. flow \\<Delta> f \\<and> value_flow \\<Delta> f = \\<alpha> \\<and> (\\<forall>x. d_IN f x \\<le> value_flow \\<Delta> f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>f.\n       flow \\<Delta> f \\<and>\n       value_flow \\<Delta> f = \\<alpha> \\<and>\n       (\\<forall>x. d_IN f x \\<le> value_flow \\<Delta> f)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>f.\n       flow \\<Delta> f \\<and>\n       value_flow \\<Delta> f = \\<alpha> \\<and>\n       (\\<forall>x. d_IN f x \\<le> value_flow \\<Delta> f)", "have \\<alpha>'_not_neg[simp]: \"\\<not> \\<alpha>' < 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> \\<alpha>' < 0", "using \\<alpha>'_nonneg"], ["proof (prove)\nusing this:\n  0 \\<le> \\<alpha>'\n\ngoal (1 subgoal):\n 1. \\<not> \\<alpha>' < 0", "by linarith"], ["proof (state)\nthis:\n  \\<not> \\<alpha>' < 0\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       flow \\<Delta> f \\<and>\n       value_flow \\<Delta> f = \\<alpha> \\<and>\n       (\\<forall>x. d_IN f x \\<le> value_flow \\<Delta> f)", "let ?v = \"\\<lambda>i. (1 - (1 / 2) ^ i) * \\<alpha>\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>f.\n       flow \\<Delta> f \\<and>\n       value_flow \\<Delta> f = \\<alpha> \\<and>\n       (\\<forall>x. d_IN f x \\<le> value_flow \\<Delta> f)", "let ?v_r = \"\\<lambda>i. ennreal ((1 - (1 / 2) ^ i) * \\<alpha>')\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>f.\n       flow \\<Delta> f \\<and>\n       value_flow \\<Delta> f = \\<alpha> \\<and>\n       (\\<forall>x. d_IN f x \\<le> value_flow \\<Delta> f)", "have v_eq: \"?v i = ?v_r i\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. (1 - (1 / 2) ^ i) * \\<alpha> = ennreal ((1 - (1 / 2) ^ i) * \\<alpha>')", "by (auto simp: real ennreal_mult power_le_one ennreal_lessI ennreal_minus[symmetric]\n                   ennreal_power[symmetric] divide_ennreal_def)"], ["proof (state)\nthis:\n  (1 - (1 / 2) ^ ?i) * \\<alpha> = ennreal ((1 - (1 / 2) ^ ?i) * \\<alpha>')\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       flow \\<Delta> f \\<and>\n       value_flow \\<Delta> f = \\<alpha> \\<and>\n       (\\<forall>x. d_IN f x \\<le> value_flow \\<Delta> f)", "have \"\\<exists>f. flow \\<Delta> f \\<and> value_flow \\<Delta> f = ?v i\" for i :: nat"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>f.\n       flow \\<Delta> f \\<and>\n       value_flow \\<Delta> f = (1 - (1 / 2) ^ i) * \\<alpha>", "proof(cases \"\\<alpha> = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<alpha> = 0 \\<Longrightarrow>\n    \\<exists>f.\n       flow \\<Delta> f \\<and>\n       value_flow \\<Delta> f = (1 - (1 / 2) ^ i) * \\<alpha>\n 2. \\<alpha> \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>f.\n       flow \\<Delta> f \\<and>\n       value_flow \\<Delta> f = (1 - (1 / 2) ^ i) * \\<alpha>", "case True"], ["proof (state)\nthis:\n  \\<alpha> = 0\n\ngoal (2 subgoals):\n 1. \\<alpha> = 0 \\<Longrightarrow>\n    \\<exists>f.\n       flow \\<Delta> f \\<and>\n       value_flow \\<Delta> f = (1 - (1 / 2) ^ i) * \\<alpha>\n 2. \\<alpha> \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>f.\n       flow \\<Delta> f \\<and>\n       value_flow \\<Delta> f = (1 - (1 / 2) ^ i) * \\<alpha>", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<alpha> = 0\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       flow \\<Delta> f \\<and>\n       value_flow \\<Delta> f = (1 - (1 / 2) ^ i) * \\<alpha>", "by(auto intro!: exI[where x=\"\\<lambda>_. 0\"])"], ["proof (state)\nthis:\n  \\<exists>f.\n     flow \\<Delta> f \\<and>\n     value_flow \\<Delta> f = (1 - (1 / 2) ^ i) * \\<alpha>\n\ngoal (1 subgoal):\n 1. \\<alpha> \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>f.\n       flow \\<Delta> f \\<and>\n       value_flow \\<Delta> f = (1 - (1 / 2) ^ i) * \\<alpha>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<alpha> \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>f.\n       flow \\<Delta> f \\<and>\n       value_flow \\<Delta> f = (1 - (1 / 2) ^ i) * \\<alpha>", "case False"], ["proof (state)\nthis:\n  \\<alpha> \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<alpha> \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>f.\n       flow \\<Delta> f \\<and>\n       value_flow \\<Delta> f = (1 - (1 / 2) ^ i) * \\<alpha>", "then"], ["proof (chain)\npicking this:\n  \\<alpha> \\<noteq> 0", "have \"?v i < \\<alpha>\""], ["proof (prove)\nusing this:\n  \\<alpha> \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (1 - (1 / 2) ^ i) * \\<alpha> < \\<alpha>", "unfolding v_eq"], ["proof (prove)\nusing this:\n  \\<alpha> \\<noteq> 0\n\ngoal (1 subgoal):\n 1. ennreal ((1 - (1 / 2) ^ i) * \\<alpha>') < \\<alpha>", "by (auto simp: real field_simps intro!: ennreal_lessI) (simp_all add: less_le)"], ["proof (state)\nthis:\n  (1 - (1 / 2) ^ i) * \\<alpha> < \\<alpha>\n\ngoal (1 subgoal):\n 1. \\<alpha> \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>f.\n       flow \\<Delta> f \\<and>\n       value_flow \\<Delta> f = (1 - (1 / 2) ^ i) * \\<alpha>", "then"], ["proof (chain)\npicking this:\n  (1 - (1 / 2) ^ i) * \\<alpha> < \\<alpha>", "obtain f where \"flow \\<Delta> f\" and \"value_flow \\<Delta> f = ?v i\""], ["proof (prove)\nusing this:\n  (1 - (1 / 2) ^ i) * \\<alpha> < \\<alpha>\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        \\<lbrakk>flow \\<Delta> f;\n         value_flow \\<Delta> f = (1 - (1 / 2) ^ i) * \\<alpha>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(rule flow_by_value)(simp add: real)"], ["proof (state)\nthis:\n  flow \\<Delta> f\n  value_flow \\<Delta> f = (1 - (1 / 2) ^ i) * \\<alpha>\n\ngoal (1 subgoal):\n 1. \\<alpha> \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>f.\n       flow \\<Delta> f \\<and>\n       value_flow \\<Delta> f = (1 - (1 / 2) ^ i) * \\<alpha>", "thus ?thesis"], ["proof (prove)\nusing this:\n  flow \\<Delta> f\n  value_flow \\<Delta> f = (1 - (1 / 2) ^ i) * \\<alpha>\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       flow \\<Delta> f \\<and>\n       value_flow \\<Delta> f = (1 - (1 / 2) ^ i) * \\<alpha>", "by blast"], ["proof (state)\nthis:\n  \\<exists>f.\n     flow \\<Delta> f \\<and>\n     value_flow \\<Delta> f = (1 - (1 / 2) ^ i) * \\<alpha>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>f.\n     flow \\<Delta> f \\<and>\n     value_flow \\<Delta> f = (1 - (1 / 2) ^ ?i) * \\<alpha>\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       flow \\<Delta> f \\<and>\n       value_flow \\<Delta> f = \\<alpha> \\<and>\n       (\\<forall>x. d_IN f x \\<le> value_flow \\<Delta> f)", "then"], ["proof (chain)\npicking this:\n  \\<exists>f.\n     flow \\<Delta> f \\<and>\n     value_flow \\<Delta> f = (1 - (1 / 2) ^ ?i) * \\<alpha>", "obtain f_aux where f_aux: \"\\<And>i. flow \\<Delta> (f_aux i)\"\n    and value_aux: \"\\<And>i. value_flow \\<Delta> (f_aux i) = ?v_r i\""], ["proof (prove)\nusing this:\n  \\<exists>f.\n     flow \\<Delta> f \\<and>\n     value_flow \\<Delta> f = (1 - (1 / 2) ^ ?i) * \\<alpha>\n\ngoal (1 subgoal):\n 1. (\\<And>f_aux.\n        \\<lbrakk>\\<And>i. flow \\<Delta> (f_aux i);\n         \\<And>i.\n            value_flow \\<Delta> (f_aux i) =\n            ennreal ((1 - (1 / 2) ^ i) * \\<alpha>')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding v_eq"], ["proof (prove)\nusing this:\n  \\<exists>f.\n     flow \\<Delta> f \\<and>\n     value_flow \\<Delta> f = ennreal ((1 - (1 / 2) ^ ?i) * \\<alpha>')\n\ngoal (1 subgoal):\n 1. (\\<And>f_aux.\n        \\<lbrakk>\\<And>i. flow \\<Delta> (f_aux i);\n         \\<And>i.\n            value_flow \\<Delta> (f_aux i) =\n            ennreal ((1 - (1 / 2) ^ i) * \\<alpha>')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by moura"], ["proof (state)\nthis:\n  flow \\<Delta> (f_aux ?i)\n  value_flow \\<Delta> (f_aux ?i) = ennreal ((1 - (1 / 2) ^ ?i) * \\<alpha>')\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       flow \\<Delta> f \\<and>\n       value_flow \\<Delta> f = \\<alpha> \\<and>\n       (\\<forall>x. d_IN f x \\<le> value_flow \\<Delta> f)", "define f_i where \"f_i = rec_nat (\\<lambda>_. 0) (\\<lambda>i f_i.\n    let g = f_aux (Suc i) \\<ominus> f_i;\n      k_i = SOME k. k \\<le> g \\<and> flow (residual_network f_i) k \\<and> value_flow (residual_network f_i) k = value_flow (residual_network f_i) g \\<and> (\\<forall>x. d_IN k x \\<le> value_flow (residual_network f_i) k)\n    in f_i \\<oplus> k_i)\""], ["proof (state)\nthis:\n  f_i =\n  rec_nat (\\<lambda>_. 0)\n   (\\<lambda>i f_i.\n       let g = f_aux (Suc i) \\<ominus> f_i\n       in Let (SOME k.\n                  k \\<le> g \\<and>\n                  flow (residual_network f_i) k \\<and>\n                  value_flow (residual_network f_i) k =\n                  value_flow (residual_network f_i) g \\<and>\n                  (\\<forall>x.\n                      d_IN k x \\<le> value_flow (residual_network f_i) k))\n           ((\\<oplus>) f_i))\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       flow \\<Delta> f \\<and>\n       value_flow \\<Delta> f = \\<alpha> \\<and>\n       (\\<forall>x. d_IN f x \\<le> value_flow \\<Delta> f)", "let ?P = \"\\<lambda>i k. k \\<le> f_aux (Suc i) \\<ominus> f_i i \\<and> flow (residual_network (f_i i)) k \\<and> value_flow (residual_network (f_i i)) k = value_flow (residual_network (f_i i)) (f_aux (Suc i) \\<ominus> f_i i) \\<and> (\\<forall>x. d_IN k x \\<le> value_flow (residual_network (f_i i)) k)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>f.\n       flow \\<Delta> f \\<and>\n       value_flow \\<Delta> f = \\<alpha> \\<and>\n       (\\<forall>x. d_IN f x \\<le> value_flow \\<Delta> f)", "define k_i where \"k_i i = Eps (?P i)\" for i"], ["proof (state)\nthis:\n  k_i ?i =\n  (SOME k.\n      k \\<le> f_aux (Suc ?i) \\<ominus> f_i ?i \\<and>\n      flow (residual_network (f_i ?i)) k \\<and>\n      value_flow (residual_network (f_i ?i)) k =\n      value_flow (residual_network (f_i ?i))\n       (f_aux (Suc ?i) \\<ominus> f_i ?i) \\<and>\n      (\\<forall>x. d_IN k x \\<le> value_flow (residual_network (f_i ?i)) k))\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       flow \\<Delta> f \\<and>\n       value_flow \\<Delta> f = \\<alpha> \\<and>\n       (\\<forall>x. d_IN f x \\<le> value_flow \\<Delta> f)", "have f_i_simps [simp]: \"f_i 0 = (\\<lambda>_. 0)\" \"f_i (Suc i) = f_i i \\<oplus> k_i i\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. f_i 0 = (\\<lambda>_. 0) &&& f_i (Suc i) = f_i i \\<oplus> k_i i", "by(simp_all add: f_i_def Let_def k_i_def)"], ["proof (state)\nthis:\n  f_i 0 = (\\<lambda>_. 0)\n  f_i (Suc ?i) = f_i ?i \\<oplus> k_i ?i\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       flow \\<Delta> f \\<and>\n       value_flow \\<Delta> f = \\<alpha> \\<and>\n       (\\<forall>x. d_IN f x \\<le> value_flow \\<Delta> f)", "have k_i: \"flow (residual_network (f_i i)) (k_i i)\" (is ?k_i)\n    and value_k_i: \"value_flow (residual_network (f_i i)) (k_i i) = value_flow (residual_network (f_i i)) (f_aux (Suc i) \\<ominus> f_i i)\" (is \"?value_k_i\")\n    and IN_k_i: \"d_IN (k_i i) x \\<le> value_flow (residual_network (f_i i)) (k_i i)\" (is \"?IN_k_i\")\n    and value_diff: \"value_flow (residual_network (f_i i)) (f_aux (Suc i) \\<ominus> f_i i) = value_flow \\<Delta> (f_aux (Suc i)) - value_flow \\<Delta> (f_i i)\" (is \"?value_diff\")\n    if \"flow_network \\<Delta> (f_i i)\" and value_f_i: \"value_flow \\<Delta> (f_i i) = value_flow \\<Delta> (f_aux i)\" for i x"], ["proof (prove)\ngoal (1 subgoal):\n 1. (flow (residual_network (f_i i)) (k_i i) &&&\n     value_flow (residual_network (f_i i)) (k_i i) =\n     value_flow (residual_network (f_i i))\n      (f_aux (Suc i) \\<ominus> f_i i)) &&&\n    d_IN (k_i i) x \\<le> value_flow (residual_network (f_i i)) (k_i i) &&&\n    value_flow (residual_network (f_i i)) (f_aux (Suc i) \\<ominus> f_i i) =\n    value_flow \\<Delta> (f_aux (Suc i)) - value_flow \\<Delta> (f_i i)", "proof -"], ["proof (state)\ngoal (4 subgoals):\n 1. flow (residual_network (f_i i)) (k_i i)\n 2. value_flow (residual_network (f_i i)) (k_i i) =\n    value_flow (residual_network (f_i i)) (f_aux (Suc i) \\<ominus> f_i i)\n 3. d_IN (k_i i) x \\<le> value_flow (residual_network (f_i i)) (k_i i)\n 4. value_flow (residual_network (f_i i)) (f_aux (Suc i) \\<ominus> f_i i) =\n    value_flow \\<Delta> (f_aux (Suc i)) - value_flow \\<Delta> (f_i i)", "let ?RES = \"residual_network (f_i i)\""], ["proof (state)\ngoal (4 subgoals):\n 1. flow (residual_network (f_i i)) (k_i i)\n 2. value_flow (residual_network (f_i i)) (k_i i) =\n    value_flow (residual_network (f_i i)) (f_aux (Suc i) \\<ominus> f_i i)\n 3. d_IN (k_i i) x \\<le> value_flow (residual_network (f_i i)) (k_i i)\n 4. value_flow (residual_network (f_i i)) (f_aux (Suc i) \\<ominus> f_i i) =\n    value_flow \\<Delta> (f_aux (Suc i)) - value_flow \\<Delta> (f_i i)", "interpret fn: flow_network \\<Delta> \"f_i i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. flow_network \\<Delta> (f_i i)", "by(rule that)"], ["proof (state)\ngoal (4 subgoals):\n 1. flow (residual_network (f_i i)) (k_i i)\n 2. value_flow (residual_network (f_i i)) (k_i i) =\n    value_flow (residual_network (f_i i)) (f_aux (Suc i) \\<ominus> f_i i)\n 3. d_IN (k_i i) x \\<le> value_flow (residual_network (f_i i)) (k_i i)\n 4. value_flow (residual_network (f_i i)) (f_aux (Suc i) \\<ominus> f_i i) =\n    value_flow \\<Delta> (f_aux (Suc i)) - value_flow \\<Delta> (f_i i)", "interpret RES: flow_attainability \"?RES\""], ["proof (prove)\ngoal (1 subgoal):\n 1. flow_attainability (residual_network (f_i i))", "using wf fn.g"], ["proof (prove)\nusing this:\n  wf_residual_network\n  flow \\<Delta> (f_i i)\n\ngoal (1 subgoal):\n 1. flow_attainability (residual_network (f_i i))", "by(rule residual_flow_attainability)"], ["proof (state)\ngoal (4 subgoals):\n 1. flow (residual_network (f_i i)) (k_i i)\n 2. value_flow (residual_network (f_i i)) (k_i i) =\n    value_flow (residual_network (f_i i)) (f_aux (Suc i) \\<ominus> f_i i)\n 3. d_IN (k_i i) x \\<le> value_flow (residual_network (f_i i)) (k_i i)\n 4. value_flow (residual_network (f_i i)) (f_aux (Suc i) \\<ominus> f_i i) =\n    value_flow \\<Delta> (f_aux (Suc i)) - value_flow \\<Delta> (f_i i)", "have le: \"value_flow \\<Delta> (f_i i) \\<le> value_flow \\<Delta> (f_aux (Suc i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. value_flow \\<Delta> (f_i i) \\<le> value_flow \\<Delta> (f_aux (Suc i))", "unfolding value_aux value_f_i"], ["proof (prove)\ngoal (1 subgoal):\n 1. ennreal ((1 - (1 / 2) ^ i) * \\<alpha>')\n    \\<le> ennreal ((1 - (1 / 2) ^ Suc i) * \\<alpha>')", "unfolding v_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. ennreal ((1 - (1 / 2) ^ i) * \\<alpha>')\n    \\<le> ennreal ((1 - (1 / 2) ^ Suc i) * \\<alpha>')", "by (rule ennreal_leI) (auto simp: field_simps)"], ["proof (state)\nthis:\n  value_flow \\<Delta> (f_i i) \\<le> value_flow \\<Delta> (f_aux (Suc i))\n\ngoal (4 subgoals):\n 1. flow (residual_network (f_i i)) (k_i i)\n 2. value_flow (residual_network (f_i i)) (k_i i) =\n    value_flow (residual_network (f_i i)) (f_aux (Suc i) \\<ominus> f_i i)\n 3. d_IN (k_i i) x \\<le> value_flow (residual_network (f_i i)) (k_i i)\n 4. value_flow (residual_network (f_i i)) (f_aux (Suc i) \\<ominus> f_i i) =\n    value_flow \\<Delta> (f_aux (Suc i)) - value_flow \\<Delta> (f_i i)", "with wf f_aux fn.g"], ["proof (chain)\npicking this:\n  wf_residual_network\n  flow \\<Delta> (f_aux ?i)\n  flow \\<Delta> (f_i i)\n  value_flow \\<Delta> (f_i i) \\<le> value_flow \\<Delta> (f_aux (Suc i))", "have res_flow: \"flow ?RES (f_aux (Suc i) \\<ominus> f_i i)\""], ["proof (prove)\nusing this:\n  wf_residual_network\n  flow \\<Delta> (f_aux ?i)\n  flow \\<Delta> (f_i i)\n  value_flow \\<Delta> (f_i i) \\<le> value_flow \\<Delta> (f_aux (Suc i))\n\ngoal (1 subgoal):\n 1. flow (residual_network (f_i i)) (f_aux (Suc i) \\<ominus> f_i i)", "using flowD_finite[OF f_aux] source_out"], ["proof (prove)\nusing this:\n  wf_residual_network\n  flow \\<Delta> (f_aux ?i)\n  flow \\<Delta> (f_i i)\n  value_flow \\<Delta> (f_i i) \\<le> value_flow \\<Delta> (f_aux (Suc i))\n  f_aux ?i1 ?e \\<noteq> \\<top>\n  edge \\<Delta> (source \\<Delta>) ?y = (?y = x)\n\ngoal (1 subgoal):\n 1. flow (residual_network (f_i i)) (f_aux (Suc i) \\<ominus> f_i i)", "by(rule minus_flow)"], ["proof (state)\nthis:\n  flow (residual_network (f_i i)) (f_aux (Suc i) \\<ominus> f_i i)\n\ngoal (4 subgoals):\n 1. flow (residual_network (f_i i)) (k_i i)\n 2. value_flow (residual_network (f_i i)) (k_i i) =\n    value_flow (residual_network (f_i i)) (f_aux (Suc i) \\<ominus> f_i i)\n 3. d_IN (k_i i) x \\<le> value_flow (residual_network (f_i i)) (k_i i)\n 4. value_flow (residual_network (f_i i)) (f_aux (Suc i) \\<ominus> f_i i) =\n    value_flow \\<Delta> (f_aux (Suc i)) - value_flow \\<Delta> (f_i i)", "show value': ?value_diff"], ["proof (prove)\ngoal (1 subgoal):\n 1. value_flow (residual_network (f_i i)) (f_aux (Suc i) \\<ominus> f_i i) =\n    value_flow \\<Delta> (f_aux (Suc i)) - value_flow \\<Delta> (f_i i)", "by(simp add: value_minus_flow[OF f_aux fn.g le source_out])"], ["proof (state)\nthis:\n  value_flow (residual_network (f_i i)) (f_aux (Suc i) \\<ominus> f_i i) =\n  value_flow \\<Delta> (f_aux (Suc i)) - value_flow \\<Delta> (f_i i)\n\ngoal (3 subgoals):\n 1. flow (residual_network (f_i i)) (k_i i)\n 2. value_flow (residual_network (f_i i)) (k_i i) =\n    value_flow (residual_network (f_i i)) (f_aux (Suc i) \\<ominus> f_i i)\n 3. d_IN (k_i i) x \\<le> value_flow (residual_network (f_i i)) (k_i i)", "also"], ["proof (state)\nthis:\n  value_flow (residual_network (f_i i)) (f_aux (Suc i) \\<ominus> f_i i) =\n  value_flow \\<Delta> (f_aux (Suc i)) - value_flow \\<Delta> (f_i i)\n\ngoal (3 subgoals):\n 1. flow (residual_network (f_i i)) (k_i i)\n 2. value_flow (residual_network (f_i i)) (k_i i) =\n    value_flow (residual_network (f_i i)) (f_aux (Suc i) \\<ominus> f_i i)\n 3. d_IN (k_i i) x \\<le> value_flow (residual_network (f_i i)) (k_i i)", "have \"\\<dots> < \\<top>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. value_flow \\<Delta> (f_aux (Suc i)) - value_flow \\<Delta> (f_i i)\n    < \\<top>", "unfolding value_aux v_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. ennreal ((1 - (1 / 2) ^ Suc i) * \\<alpha>') -\n    value_flow \\<Delta> (f_i i)\n    < \\<top>", "by (auto simp: less_top[symmetric])"], ["proof (state)\nthis:\n  value_flow \\<Delta> (f_aux (Suc i)) - value_flow \\<Delta> (f_i i) < \\<top>\n\ngoal (3 subgoals):\n 1. flow (residual_network (f_i i)) (k_i i)\n 2. value_flow (residual_network (f_i i)) (k_i i) =\n    value_flow (residual_network (f_i i)) (f_aux (Suc i) \\<ominus> f_i i)\n 3. d_IN (k_i i) x \\<le> value_flow (residual_network (f_i i)) (k_i i)", "finally"], ["proof (chain)\npicking this:\n  value_flow (residual_network (f_i i)) (f_aux (Suc i) \\<ominus> f_i i)\n  < \\<top>", "have \"value_flow ?RES (f_aux (Suc i) \\<ominus> f_i i) \\<noteq> \\<top>\""], ["proof (prove)\nusing this:\n  value_flow (residual_network (f_i i)) (f_aux (Suc i) \\<ominus> f_i i)\n  < \\<top>\n\ngoal (1 subgoal):\n 1. value_flow (residual_network (f_i i))\n     (f_aux (Suc i) \\<ominus> f_i i) \\<noteq>\n    \\<top>", "by simp"], ["proof (state)\nthis:\n  value_flow (residual_network (f_i i))\n   (f_aux (Suc i) \\<ominus> f_i i) \\<noteq>\n  \\<top>\n\ngoal (3 subgoals):\n 1. flow (residual_network (f_i i)) (k_i i)\n 2. value_flow (residual_network (f_i i)) (k_i i) =\n    value_flow (residual_network (f_i i)) (f_aux (Suc i) \\<ominus> f_i i)\n 3. d_IN (k_i i) x \\<le> value_flow (residual_network (f_i i)) (k_i i)", "then"], ["proof (chain)\npicking this:\n  value_flow (residual_network (f_i i))\n   (f_aux (Suc i) \\<ominus> f_i i) \\<noteq>\n  \\<top>", "have fn': \"flow_network ?RES (f_aux (Suc i) \\<ominus> f_i i)\""], ["proof (prove)\nusing this:\n  value_flow (residual_network (f_i i))\n   (f_aux (Suc i) \\<ominus> f_i i) \\<noteq>\n  \\<top>\n\ngoal (1 subgoal):\n 1. flow_network (residual_network (f_i i)) (f_aux (Suc i) \\<ominus> f_i i)", "using nontrivial res_flow"], ["proof (prove)\nusing this:\n  value_flow (residual_network (f_i i))\n   (f_aux (Suc i) \\<ominus> f_i i) \\<noteq>\n  \\<top>\n  \\<^bold>V - {source \\<Delta>, sink \\<Delta>} \\<noteq> {}\n  flow (residual_network (f_i i)) (f_aux (Suc i) \\<ominus> f_i i)\n\ngoal (1 subgoal):\n 1. flow_network (residual_network (f_i i)) (f_aux (Suc i) \\<ominus> f_i i)", "by(unfold_locales) simp_all"], ["proof (state)\nthis:\n  flow_network (residual_network (f_i i)) (f_aux (Suc i) \\<ominus> f_i i)\n\ngoal (3 subgoals):\n 1. flow (residual_network (f_i i)) (k_i i)\n 2. value_flow (residual_network (f_i i)) (k_i i) =\n    value_flow (residual_network (f_i i)) (f_aux (Suc i) \\<ominus> f_i i)\n 3. d_IN (k_i i) x \\<le> value_flow (residual_network (f_i i)) (k_i i)", "then"], ["proof (chain)\npicking this:\n  flow_network (residual_network (f_i i)) (f_aux (Suc i) \\<ominus> f_i i)", "interpret fn': flow_network \"?RES\" \"f_aux (Suc i) \\<ominus> f_i i\""], ["proof (prove)\nusing this:\n  flow_network (residual_network (f_i i)) (f_aux (Suc i) \\<ominus> f_i i)\n\ngoal (1 subgoal):\n 1. flow_network (residual_network (f_i i)) (f_aux (Suc i) \\<ominus> f_i i)", "."], ["proof (state)\ngoal (3 subgoals):\n 1. flow (residual_network (f_i i)) (k_i i)\n 2. value_flow (residual_network (f_i i)) (k_i i) =\n    value_flow (residual_network (f_i i)) (f_aux (Suc i) \\<ominus> f_i i)\n 3. d_IN (k_i i) x \\<le> value_flow (residual_network (f_i i)) (k_i i)", "from fn'.flow_cleanup"], ["proof (chain)\npicking this:\n  \\<exists>h\\<le>f_aux (Suc i) \\<ominus> f_i i.\n     flow (residual_network (f_i i)) h \\<and>\n     value_flow (residual_network (f_i i)) h =\n     value_flow (residual_network (f_i i))\n      (f_aux (Suc i) \\<ominus> f_i i) \\<and>\n     (\\<forall>x. d_IN h x \\<le> value_flow (residual_network (f_i i)) h)", "show ?k_i ?value_k_i ?IN_k_i"], ["proof (prove)\nusing this:\n  \\<exists>h\\<le>f_aux (Suc i) \\<ominus> f_i i.\n     flow (residual_network (f_i i)) h \\<and>\n     value_flow (residual_network (f_i i)) h =\n     value_flow (residual_network (f_i i))\n      (f_aux (Suc i) \\<ominus> f_i i) \\<and>\n     (\\<forall>x. d_IN h x \\<le> value_flow (residual_network (f_i i)) h)\n\ngoal (1 subgoal):\n 1. flow (residual_network (f_i i)) (k_i i) &&&\n    value_flow (residual_network (f_i i)) (k_i i) =\n    value_flow (residual_network (f_i i))\n     (f_aux (Suc i) \\<ominus> f_i i) &&&\n    d_IN (k_i i) x \\<le> value_flow (residual_network (f_i i)) (k_i i)", "unfolding k_i_def"], ["proof (prove)\nusing this:\n  \\<exists>h\\<le>f_aux (Suc i) \\<ominus> f_i i.\n     flow (residual_network (f_i i)) h \\<and>\n     value_flow (residual_network (f_i i)) h =\n     value_flow (residual_network (f_i i))\n      (f_aux (Suc i) \\<ominus> f_i i) \\<and>\n     (\\<forall>x. d_IN h x \\<le> value_flow (residual_network (f_i i)) h)\n\ngoal (1 subgoal):\n 1. flow (residual_network (f_i i))\n     (SOME k.\n         k \\<le> f_aux (Suc i) \\<ominus> f_i i \\<and>\n         flow (residual_network (f_i i)) k \\<and>\n         value_flow (residual_network (f_i i)) k =\n         value_flow (residual_network (f_i i))\n          (f_aux (Suc i) \\<ominus> f_i i) \\<and>\n         (\\<forall>x.\n             d_IN k x \\<le> value_flow (residual_network (f_i i)) k)) &&&\n    value_flow (residual_network (f_i i))\n     (SOME k.\n         k \\<le> f_aux (Suc i) \\<ominus> f_i i \\<and>\n         flow (residual_network (f_i i)) k \\<and>\n         value_flow (residual_network (f_i i)) k =\n         value_flow (residual_network (f_i i))\n          (f_aux (Suc i) \\<ominus> f_i i) \\<and>\n         (\\<forall>x.\n             d_IN k x \\<le> value_flow (residual_network (f_i i)) k)) =\n    value_flow (residual_network (f_i i))\n     (f_aux (Suc i) \\<ominus> f_i i) &&&\n    d_IN\n     (SOME k.\n         k \\<le> f_aux (Suc i) \\<ominus> f_i i \\<and>\n         flow (residual_network (f_i i)) k \\<and>\n         value_flow (residual_network (f_i i)) k =\n         value_flow (residual_network (f_i i))\n          (f_aux (Suc i) \\<ominus> f_i i) \\<and>\n         (\\<forall>x.\n             d_IN k x \\<le> value_flow (residual_network (f_i i)) k))\n     x\n    \\<le> value_flow (residual_network (f_i i))\n           (SOME k.\n               k \\<le> f_aux (Suc i) \\<ominus> f_i i \\<and>\n               flow (residual_network (f_i i)) k \\<and>\n               value_flow (residual_network (f_i i)) k =\n               value_flow (residual_network (f_i i))\n                (f_aux (Suc i) \\<ominus> f_i i) \\<and>\n               (\\<forall>x.\n                   d_IN k x \\<le> value_flow (residual_network (f_i i)) k))", "by(rule someI2_ex; blast)+"], ["proof (state)\nthis:\n  flow (residual_network (f_i i)) (k_i i)\n  value_flow (residual_network (f_i i)) (k_i i) =\n  value_flow (residual_network (f_i i)) (f_aux (Suc i) \\<ominus> f_i i)\n  d_IN (k_i i) x \\<le> value_flow (residual_network (f_i i)) (k_i i)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>flow_network \\<Delta> (f_i ?i);\n   value_flow \\<Delta> (f_i ?i) = value_flow \\<Delta> (f_aux ?i)\\<rbrakk>\n  \\<Longrightarrow> flow (residual_network (f_i ?i)) (k_i ?i)\n  \\<lbrakk>flow_network \\<Delta> (f_i ?i);\n   value_flow \\<Delta> (f_i ?i) = value_flow \\<Delta> (f_aux ?i)\\<rbrakk>\n  \\<Longrightarrow> value_flow (residual_network (f_i ?i)) (k_i ?i) =\n                    value_flow (residual_network (f_i ?i))\n                     (f_aux (Suc ?i) \\<ominus> f_i ?i)\n  \\<lbrakk>flow_network \\<Delta> (f_i ?i);\n   value_flow \\<Delta> (f_i ?i) = value_flow \\<Delta> (f_aux ?i)\\<rbrakk>\n  \\<Longrightarrow> d_IN (k_i ?i) ?x\n                    \\<le> value_flow (residual_network (f_i ?i)) (k_i ?i)\n  \\<lbrakk>flow_network \\<Delta> (f_i ?i);\n   value_flow \\<Delta> (f_i ?i) = value_flow \\<Delta> (f_aux ?i)\\<rbrakk>\n  \\<Longrightarrow> value_flow (residual_network (f_i ?i))\n                     (f_aux (Suc ?i) \\<ominus> f_i ?i) =\n                    value_flow \\<Delta> (f_aux (Suc ?i)) -\n                    value_flow \\<Delta> (f_i ?i)\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       flow \\<Delta> f \\<and>\n       value_flow \\<Delta> f = \\<alpha> \\<and>\n       (\\<forall>x. d_IN f x \\<le> value_flow \\<Delta> f)", "have fn_i: \"flow_network \\<Delta> (f_i i)\"\n    and value_f_i: \"value_flow \\<Delta> (f_i i) = value_flow \\<Delta> (f_aux i)\"\n    and d_IN_i: \"d_IN (f_i i) x \\<le> value_flow \\<Delta> (f_i i)\"  for i x"], ["proof (prove)\ngoal (1 subgoal):\n 1. flow_network \\<Delta> (f_i i) &&&\n    value_flow \\<Delta> (f_i i) = value_flow \\<Delta> (f_aux i) &&&\n    d_IN (f_i i) x \\<le> value_flow \\<Delta> (f_i i)", "proof(induction i)"], ["proof (state)\ngoal (6 subgoals):\n 1. flow_network \\<Delta> (f_i 0)\n 2. value_flow \\<Delta> (f_i 0) = value_flow \\<Delta> (f_aux 0)\n 3. d_IN (f_i 0) x \\<le> value_flow \\<Delta> (f_i 0)\n 4. \\<And>i.\n       \\<lbrakk>flow_network \\<Delta> (f_i i);\n        value_flow \\<Delta> (f_i i) = value_flow \\<Delta> (f_aux i);\n        d_IN (f_i i) x \\<le> value_flow \\<Delta> (f_i i)\\<rbrakk>\n       \\<Longrightarrow> flow_network \\<Delta> (f_i (Suc i))\n 5. \\<And>i.\n       \\<lbrakk>flow_network \\<Delta> (f_i i);\n        value_flow \\<Delta> (f_i i) = value_flow \\<Delta> (f_aux i);\n        d_IN (f_i i) x \\<le> value_flow \\<Delta> (f_i i)\\<rbrakk>\n       \\<Longrightarrow> value_flow \\<Delta> (f_i (Suc i)) =\n                         value_flow \\<Delta> (f_aux (Suc i))\n 6. \\<And>i.\n       \\<lbrakk>flow_network \\<Delta> (f_i i);\n        value_flow \\<Delta> (f_i i) = value_flow \\<Delta> (f_aux i);\n        d_IN (f_i i) x \\<le> value_flow \\<Delta> (f_i i)\\<rbrakk>\n       \\<Longrightarrow> d_IN (f_i (Suc i)) x\n                         \\<le> value_flow \\<Delta> (f_i (Suc i))", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (6 subgoals):\n 1. flow_network \\<Delta> (f_i 0)\n 2. value_flow \\<Delta> (f_i 0) = value_flow \\<Delta> (f_aux 0)\n 3. d_IN (f_i 0) x \\<le> value_flow \\<Delta> (f_i 0)\n 4. \\<And>i.\n       \\<lbrakk>flow_network \\<Delta> (f_i i);\n        value_flow \\<Delta> (f_i i) = value_flow \\<Delta> (f_aux i);\n        d_IN (f_i i) x \\<le> value_flow \\<Delta> (f_i i)\\<rbrakk>\n       \\<Longrightarrow> flow_network \\<Delta> (f_i (Suc i))\n 5. \\<And>i.\n       \\<lbrakk>flow_network \\<Delta> (f_i i);\n        value_flow \\<Delta> (f_i i) = value_flow \\<Delta> (f_aux i);\n        d_IN (f_i i) x \\<le> value_flow \\<Delta> (f_i i)\\<rbrakk>\n       \\<Longrightarrow> value_flow \\<Delta> (f_i (Suc i)) =\n                         value_flow \\<Delta> (f_aux (Suc i))\n 6. \\<And>i.\n       \\<lbrakk>flow_network \\<Delta> (f_i i);\n        value_flow \\<Delta> (f_i i) = value_flow \\<Delta> (f_aux i);\n        d_IN (f_i i) x \\<le> value_flow \\<Delta> (f_i i)\\<rbrakk>\n       \\<Longrightarrow> d_IN (f_i (Suc i)) x\n                         \\<le> value_flow \\<Delta> (f_i (Suc i))", "{"], ["proof (state)\nthis:\n  \n\ngoal (6 subgoals):\n 1. flow_network \\<Delta> (f_i 0)\n 2. value_flow \\<Delta> (f_i 0) = value_flow \\<Delta> (f_aux 0)\n 3. d_IN (f_i 0) x \\<le> value_flow \\<Delta> (f_i 0)\n 4. \\<And>i.\n       \\<lbrakk>flow_network \\<Delta> (f_i i);\n        value_flow \\<Delta> (f_i i) = value_flow \\<Delta> (f_aux i);\n        d_IN (f_i i) x \\<le> value_flow \\<Delta> (f_i i)\\<rbrakk>\n       \\<Longrightarrow> flow_network \\<Delta> (f_i (Suc i))\n 5. \\<And>i.\n       \\<lbrakk>flow_network \\<Delta> (f_i i);\n        value_flow \\<Delta> (f_i i) = value_flow \\<Delta> (f_aux i);\n        d_IN (f_i i) x \\<le> value_flow \\<Delta> (f_i i)\\<rbrakk>\n       \\<Longrightarrow> value_flow \\<Delta> (f_i (Suc i)) =\n                         value_flow \\<Delta> (f_aux (Suc i))\n 6. \\<And>i.\n       \\<lbrakk>flow_network \\<Delta> (f_i i);\n        value_flow \\<Delta> (f_i i) = value_flow \\<Delta> (f_aux i);\n        d_IN (f_i i) x \\<le> value_flow \\<Delta> (f_i i)\\<rbrakk>\n       \\<Longrightarrow> d_IN (f_i (Suc i)) x\n                         \\<le> value_flow \\<Delta> (f_i (Suc i))", "case 1"], ["proof (state)\nthis:\n  \n\ngoal (6 subgoals):\n 1. flow_network \\<Delta> (f_i 0)\n 2. value_flow \\<Delta> (f_i 0) = value_flow \\<Delta> (f_aux 0)\n 3. d_IN (f_i 0) x \\<le> value_flow \\<Delta> (f_i 0)\n 4. \\<And>i.\n       \\<lbrakk>flow_network \\<Delta> (f_i i);\n        value_flow \\<Delta> (f_i i) = value_flow \\<Delta> (f_aux i);\n        d_IN (f_i i) x \\<le> value_flow \\<Delta> (f_i i)\\<rbrakk>\n       \\<Longrightarrow> flow_network \\<Delta> (f_i (Suc i))\n 5. \\<And>i.\n       \\<lbrakk>flow_network \\<Delta> (f_i i);\n        value_flow \\<Delta> (f_i i) = value_flow \\<Delta> (f_aux i);\n        d_IN (f_i i) x \\<le> value_flow \\<Delta> (f_i i)\\<rbrakk>\n       \\<Longrightarrow> value_flow \\<Delta> (f_i (Suc i)) =\n                         value_flow \\<Delta> (f_aux (Suc i))\n 6. \\<And>i.\n       \\<lbrakk>flow_network \\<Delta> (f_i i);\n        value_flow \\<Delta> (f_i i) = value_flow \\<Delta> (f_aux i);\n        d_IN (f_i i) x \\<le> value_flow \\<Delta> (f_i i)\\<rbrakk>\n       \\<Longrightarrow> d_IN (f_i (Suc i)) x\n                         \\<le> value_flow \\<Delta> (f_i (Suc i))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. flow_network \\<Delta> (f_i 0)", "using nontrivial"], ["proof (prove)\nusing this:\n  \\<^bold>V - {source \\<Delta>, sink \\<Delta>} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. flow_network \\<Delta> (f_i 0)", "by(unfold_locales)(simp_all add: f_aux value_aux)"], ["proof (state)\nthis:\n  flow_network \\<Delta> (f_i 0)\n\ngoal (5 subgoals):\n 1. value_flow \\<Delta> (f_i 0) = value_flow \\<Delta> (f_aux 0)\n 2. d_IN (f_i 0) x \\<le> value_flow \\<Delta> (f_i 0)\n 3. \\<And>i.\n       \\<lbrakk>flow_network \\<Delta> (f_i i);\n        value_flow \\<Delta> (f_i i) = value_flow \\<Delta> (f_aux i);\n        d_IN (f_i i) x \\<le> value_flow \\<Delta> (f_i i)\\<rbrakk>\n       \\<Longrightarrow> flow_network \\<Delta> (f_i (Suc i))\n 4. \\<And>i.\n       \\<lbrakk>flow_network \\<Delta> (f_i i);\n        value_flow \\<Delta> (f_i i) = value_flow \\<Delta> (f_aux i);\n        d_IN (f_i i) x \\<le> value_flow \\<Delta> (f_i i)\\<rbrakk>\n       \\<Longrightarrow> value_flow \\<Delta> (f_i (Suc i)) =\n                         value_flow \\<Delta> (f_aux (Suc i))\n 5. \\<And>i.\n       \\<lbrakk>flow_network \\<Delta> (f_i i);\n        value_flow \\<Delta> (f_i i) = value_flow \\<Delta> (f_aux i);\n        d_IN (f_i i) x \\<le> value_flow \\<Delta> (f_i i)\\<rbrakk>\n       \\<Longrightarrow> d_IN (f_i (Suc i)) x\n                         \\<le> value_flow \\<Delta> (f_i (Suc i))", "}"], ["proof (state)\nthis:\n  flow_network \\<Delta> (f_i 0)\n\ngoal (5 subgoals):\n 1. value_flow \\<Delta> (f_i 0) = value_flow \\<Delta> (f_aux 0)\n 2. d_IN (f_i 0) x \\<le> value_flow \\<Delta> (f_i 0)\n 3. \\<And>i.\n       \\<lbrakk>flow_network \\<Delta> (f_i i);\n        value_flow \\<Delta> (f_i i) = value_flow \\<Delta> (f_aux i);\n        d_IN (f_i i) x \\<le> value_flow \\<Delta> (f_i i)\\<rbrakk>\n       \\<Longrightarrow> flow_network \\<Delta> (f_i (Suc i))\n 4. \\<And>i.\n       \\<lbrakk>flow_network \\<Delta> (f_i i);\n        value_flow \\<Delta> (f_i i) = value_flow \\<Delta> (f_aux i);\n        d_IN (f_i i) x \\<le> value_flow \\<Delta> (f_i i)\\<rbrakk>\n       \\<Longrightarrow> value_flow \\<Delta> (f_i (Suc i)) =\n                         value_flow \\<Delta> (f_aux (Suc i))\n 5. \\<And>i.\n       \\<lbrakk>flow_network \\<Delta> (f_i i);\n        value_flow \\<Delta> (f_i i) = value_flow \\<Delta> (f_aux i);\n        d_IN (f_i i) x \\<le> value_flow \\<Delta> (f_i i)\\<rbrakk>\n       \\<Longrightarrow> d_IN (f_i (Suc i)) x\n                         \\<le> value_flow \\<Delta> (f_i (Suc i))", "{"], ["proof (state)\nthis:\n  flow_network \\<Delta> (f_i 0)\n\ngoal (5 subgoals):\n 1. value_flow \\<Delta> (f_i 0) = value_flow \\<Delta> (f_aux 0)\n 2. d_IN (f_i 0) x \\<le> value_flow \\<Delta> (f_i 0)\n 3. \\<And>i.\n       \\<lbrakk>flow_network \\<Delta> (f_i i);\n        value_flow \\<Delta> (f_i i) = value_flow \\<Delta> (f_aux i);\n        d_IN (f_i i) x \\<le> value_flow \\<Delta> (f_i i)\\<rbrakk>\n       \\<Longrightarrow> flow_network \\<Delta> (f_i (Suc i))\n 4. \\<And>i.\n       \\<lbrakk>flow_network \\<Delta> (f_i i);\n        value_flow \\<Delta> (f_i i) = value_flow \\<Delta> (f_aux i);\n        d_IN (f_i i) x \\<le> value_flow \\<Delta> (f_i i)\\<rbrakk>\n       \\<Longrightarrow> value_flow \\<Delta> (f_i (Suc i)) =\n                         value_flow \\<Delta> (f_aux (Suc i))\n 5. \\<And>i.\n       \\<lbrakk>flow_network \\<Delta> (f_i i);\n        value_flow \\<Delta> (f_i i) = value_flow \\<Delta> (f_aux i);\n        d_IN (f_i i) x \\<le> value_flow \\<Delta> (f_i i)\\<rbrakk>\n       \\<Longrightarrow> d_IN (f_i (Suc i)) x\n                         \\<le> value_flow \\<Delta> (f_i (Suc i))", "case 2"], ["proof (state)\nthis:\n  \n\ngoal (5 subgoals):\n 1. value_flow \\<Delta> (f_i 0) = value_flow \\<Delta> (f_aux 0)\n 2. d_IN (f_i 0) x \\<le> value_flow \\<Delta> (f_i 0)\n 3. \\<And>i.\n       \\<lbrakk>flow_network \\<Delta> (f_i i);\n        value_flow \\<Delta> (f_i i) = value_flow \\<Delta> (f_aux i);\n        d_IN (f_i i) x \\<le> value_flow \\<Delta> (f_i i)\\<rbrakk>\n       \\<Longrightarrow> flow_network \\<Delta> (f_i (Suc i))\n 4. \\<And>i.\n       \\<lbrakk>flow_network \\<Delta> (f_i i);\n        value_flow \\<Delta> (f_i i) = value_flow \\<Delta> (f_aux i);\n        d_IN (f_i i) x \\<le> value_flow \\<Delta> (f_i i)\\<rbrakk>\n       \\<Longrightarrow> value_flow \\<Delta> (f_i (Suc i)) =\n                         value_flow \\<Delta> (f_aux (Suc i))\n 5. \\<And>i.\n       \\<lbrakk>flow_network \\<Delta> (f_i i);\n        value_flow \\<Delta> (f_i i) = value_flow \\<Delta> (f_aux i);\n        d_IN (f_i i) x \\<le> value_flow \\<Delta> (f_i i)\\<rbrakk>\n       \\<Longrightarrow> d_IN (f_i (Suc i)) x\n                         \\<le> value_flow \\<Delta> (f_i (Suc i))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. value_flow \\<Delta> (f_i 0) = value_flow \\<Delta> (f_aux 0)", "by(simp add: value_aux)"], ["proof (state)\nthis:\n  value_flow \\<Delta> (f_i 0) = value_flow \\<Delta> (f_aux 0)\n\ngoal (4 subgoals):\n 1. d_IN (f_i 0) x \\<le> value_flow \\<Delta> (f_i 0)\n 2. \\<And>i.\n       \\<lbrakk>flow_network \\<Delta> (f_i i);\n        value_flow \\<Delta> (f_i i) = value_flow \\<Delta> (f_aux i);\n        d_IN (f_i i) x \\<le> value_flow \\<Delta> (f_i i)\\<rbrakk>\n       \\<Longrightarrow> flow_network \\<Delta> (f_i (Suc i))\n 3. \\<And>i.\n       \\<lbrakk>flow_network \\<Delta> (f_i i);\n        value_flow \\<Delta> (f_i i) = value_flow \\<Delta> (f_aux i);\n        d_IN (f_i i) x \\<le> value_flow \\<Delta> (f_i i)\\<rbrakk>\n       \\<Longrightarrow> value_flow \\<Delta> (f_i (Suc i)) =\n                         value_flow \\<Delta> (f_aux (Suc i))\n 4. \\<And>i.\n       \\<lbrakk>flow_network \\<Delta> (f_i i);\n        value_flow \\<Delta> (f_i i) = value_flow \\<Delta> (f_aux i);\n        d_IN (f_i i) x \\<le> value_flow \\<Delta> (f_i i)\\<rbrakk>\n       \\<Longrightarrow> d_IN (f_i (Suc i)) x\n                         \\<le> value_flow \\<Delta> (f_i (Suc i))", "}"], ["proof (state)\nthis:\n  value_flow \\<Delta> (f_i 0) = value_flow \\<Delta> (f_aux 0)\n\ngoal (4 subgoals):\n 1. d_IN (f_i 0) x \\<le> value_flow \\<Delta> (f_i 0)\n 2. \\<And>i.\n       \\<lbrakk>flow_network \\<Delta> (f_i i);\n        value_flow \\<Delta> (f_i i) = value_flow \\<Delta> (f_aux i);\n        d_IN (f_i i) x \\<le> value_flow \\<Delta> (f_i i)\\<rbrakk>\n       \\<Longrightarrow> flow_network \\<Delta> (f_i (Suc i))\n 3. \\<And>i.\n       \\<lbrakk>flow_network \\<Delta> (f_i i);\n        value_flow \\<Delta> (f_i i) = value_flow \\<Delta> (f_aux i);\n        d_IN (f_i i) x \\<le> value_flow \\<Delta> (f_i i)\\<rbrakk>\n       \\<Longrightarrow> value_flow \\<Delta> (f_i (Suc i)) =\n                         value_flow \\<Delta> (f_aux (Suc i))\n 4. \\<And>i.\n       \\<lbrakk>flow_network \\<Delta> (f_i i);\n        value_flow \\<Delta> (f_i i) = value_flow \\<Delta> (f_aux i);\n        d_IN (f_i i) x \\<le> value_flow \\<Delta> (f_i i)\\<rbrakk>\n       \\<Longrightarrow> d_IN (f_i (Suc i)) x\n                         \\<le> value_flow \\<Delta> (f_i (Suc i))", "{"], ["proof (state)\nthis:\n  value_flow \\<Delta> (f_i 0) = value_flow \\<Delta> (f_aux 0)\n\ngoal (4 subgoals):\n 1. d_IN (f_i 0) x \\<le> value_flow \\<Delta> (f_i 0)\n 2. \\<And>i.\n       \\<lbrakk>flow_network \\<Delta> (f_i i);\n        value_flow \\<Delta> (f_i i) = value_flow \\<Delta> (f_aux i);\n        d_IN (f_i i) x \\<le> value_flow \\<Delta> (f_i i)\\<rbrakk>\n       \\<Longrightarrow> flow_network \\<Delta> (f_i (Suc i))\n 3. \\<And>i.\n       \\<lbrakk>flow_network \\<Delta> (f_i i);\n        value_flow \\<Delta> (f_i i) = value_flow \\<Delta> (f_aux i);\n        d_IN (f_i i) x \\<le> value_flow \\<Delta> (f_i i)\\<rbrakk>\n       \\<Longrightarrow> value_flow \\<Delta> (f_i (Suc i)) =\n                         value_flow \\<Delta> (f_aux (Suc i))\n 4. \\<And>i.\n       \\<lbrakk>flow_network \\<Delta> (f_i i);\n        value_flow \\<Delta> (f_i i) = value_flow \\<Delta> (f_aux i);\n        d_IN (f_i i) x \\<le> value_flow \\<Delta> (f_i i)\\<rbrakk>\n       \\<Longrightarrow> d_IN (f_i (Suc i)) x\n                         \\<le> value_flow \\<Delta> (f_i (Suc i))", "case 3"], ["proof (state)\nthis:\n  \n\ngoal (4 subgoals):\n 1. d_IN (f_i 0) x \\<le> value_flow \\<Delta> (f_i 0)\n 2. \\<And>i.\n       \\<lbrakk>flow_network \\<Delta> (f_i i);\n        value_flow \\<Delta> (f_i i) = value_flow \\<Delta> (f_aux i);\n        d_IN (f_i i) x \\<le> value_flow \\<Delta> (f_i i)\\<rbrakk>\n       \\<Longrightarrow> flow_network \\<Delta> (f_i (Suc i))\n 3. \\<And>i.\n       \\<lbrakk>flow_network \\<Delta> (f_i i);\n        value_flow \\<Delta> (f_i i) = value_flow \\<Delta> (f_aux i);\n        d_IN (f_i i) x \\<le> value_flow \\<Delta> (f_i i)\\<rbrakk>\n       \\<Longrightarrow> value_flow \\<Delta> (f_i (Suc i)) =\n                         value_flow \\<Delta> (f_aux (Suc i))\n 4. \\<And>i.\n       \\<lbrakk>flow_network \\<Delta> (f_i i);\n        value_flow \\<Delta> (f_i i) = value_flow \\<Delta> (f_aux i);\n        d_IN (f_i i) x \\<le> value_flow \\<Delta> (f_i i)\\<rbrakk>\n       \\<Longrightarrow> d_IN (f_i (Suc i)) x\n                         \\<le> value_flow \\<Delta> (f_i (Suc i))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN (f_i 0) x \\<le> value_flow \\<Delta> (f_i 0)", "by(simp)"], ["proof (state)\nthis:\n  d_IN (f_i 0) x \\<le> value_flow \\<Delta> (f_i 0)\n\ngoal (3 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>flow_network \\<Delta> (f_i i);\n        value_flow \\<Delta> (f_i i) = value_flow \\<Delta> (f_aux i);\n        d_IN (f_i i) x \\<le> value_flow \\<Delta> (f_i i)\\<rbrakk>\n       \\<Longrightarrow> flow_network \\<Delta> (f_i (Suc i))\n 2. \\<And>i.\n       \\<lbrakk>flow_network \\<Delta> (f_i i);\n        value_flow \\<Delta> (f_i i) = value_flow \\<Delta> (f_aux i);\n        d_IN (f_i i) x \\<le> value_flow \\<Delta> (f_i i)\\<rbrakk>\n       \\<Longrightarrow> value_flow \\<Delta> (f_i (Suc i)) =\n                         value_flow \\<Delta> (f_aux (Suc i))\n 3. \\<And>i.\n       \\<lbrakk>flow_network \\<Delta> (f_i i);\n        value_flow \\<Delta> (f_i i) = value_flow \\<Delta> (f_aux i);\n        d_IN (f_i i) x \\<le> value_flow \\<Delta> (f_i i)\\<rbrakk>\n       \\<Longrightarrow> d_IN (f_i (Suc i)) x\n                         \\<le> value_flow \\<Delta> (f_i (Suc i))", "}"], ["proof (state)\nthis:\n  d_IN (f_i 0) x \\<le> value_flow \\<Delta> (f_i 0)\n\ngoal (3 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>flow_network \\<Delta> (f_i i);\n        value_flow \\<Delta> (f_i i) = value_flow \\<Delta> (f_aux i);\n        d_IN (f_i i) x \\<le> value_flow \\<Delta> (f_i i)\\<rbrakk>\n       \\<Longrightarrow> flow_network \\<Delta> (f_i (Suc i))\n 2. \\<And>i.\n       \\<lbrakk>flow_network \\<Delta> (f_i i);\n        value_flow \\<Delta> (f_i i) = value_flow \\<Delta> (f_aux i);\n        d_IN (f_i i) x \\<le> value_flow \\<Delta> (f_i i)\\<rbrakk>\n       \\<Longrightarrow> value_flow \\<Delta> (f_i (Suc i)) =\n                         value_flow \\<Delta> (f_aux (Suc i))\n 3. \\<And>i.\n       \\<lbrakk>flow_network \\<Delta> (f_i i);\n        value_flow \\<Delta> (f_i i) = value_flow \\<Delta> (f_aux i);\n        d_IN (f_i i) x \\<le> value_flow \\<Delta> (f_i i)\\<rbrakk>\n       \\<Longrightarrow> d_IN (f_i (Suc i)) x\n                         \\<le> value_flow \\<Delta> (f_i (Suc i))", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>flow_network \\<Delta> (f_i i);\n        value_flow \\<Delta> (f_i i) = value_flow \\<Delta> (f_aux i);\n        d_IN (f_i i) x \\<le> value_flow \\<Delta> (f_i i)\\<rbrakk>\n       \\<Longrightarrow> flow_network \\<Delta> (f_i (Suc i))\n 2. \\<And>i.\n       \\<lbrakk>flow_network \\<Delta> (f_i i);\n        value_flow \\<Delta> (f_i i) = value_flow \\<Delta> (f_aux i);\n        d_IN (f_i i) x \\<le> value_flow \\<Delta> (f_i i)\\<rbrakk>\n       \\<Longrightarrow> value_flow \\<Delta> (f_i (Suc i)) =\n                         value_flow \\<Delta> (f_aux (Suc i))\n 3. \\<And>i.\n       \\<lbrakk>flow_network \\<Delta> (f_i i);\n        value_flow \\<Delta> (f_i i) = value_flow \\<Delta> (f_aux i);\n        d_IN (f_i i) x \\<le> value_flow \\<Delta> (f_i i)\\<rbrakk>\n       \\<Longrightarrow> d_IN (f_i (Suc i)) x\n                         \\<le> value_flow \\<Delta> (f_i (Suc i))", "case (Suc i)"], ["proof (state)\nthis:\n  flow_network \\<Delta> (f_i i)\n  value_flow \\<Delta> (f_i i) = value_flow \\<Delta> (f_aux i)\n  d_IN (f_i i) x \\<le> value_flow \\<Delta> (f_i i)\n\ngoal (3 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>flow_network \\<Delta> (f_i i);\n        value_flow \\<Delta> (f_i i) = value_flow \\<Delta> (f_aux i);\n        d_IN (f_i i) x \\<le> value_flow \\<Delta> (f_i i)\\<rbrakk>\n       \\<Longrightarrow> flow_network \\<Delta> (f_i (Suc i))\n 2. \\<And>i.\n       \\<lbrakk>flow_network \\<Delta> (f_i i);\n        value_flow \\<Delta> (f_i i) = value_flow \\<Delta> (f_aux i);\n        d_IN (f_i i) x \\<le> value_flow \\<Delta> (f_i i)\\<rbrakk>\n       \\<Longrightarrow> value_flow \\<Delta> (f_i (Suc i)) =\n                         value_flow \\<Delta> (f_aux (Suc i))\n 3. \\<And>i.\n       \\<lbrakk>flow_network \\<Delta> (f_i i);\n        value_flow \\<Delta> (f_i i) = value_flow \\<Delta> (f_aux i);\n        d_IN (f_i i) x \\<le> value_flow \\<Delta> (f_i i)\\<rbrakk>\n       \\<Longrightarrow> d_IN (f_i (Suc i)) x\n                         \\<le> value_flow \\<Delta> (f_i (Suc i))", "interpret fn: flow_network \\<Delta> \"f_i i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. flow_network \\<Delta> (f_i i)", "using Suc.IH(1)"], ["proof (prove)\nusing this:\n  flow_network \\<Delta> (f_i i)\n\ngoal (1 subgoal):\n 1. flow_network \\<Delta> (f_i i)", "."], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>flow_network \\<Delta> (f_i i);\n        value_flow \\<Delta> (f_i i) = value_flow \\<Delta> (f_aux i);\n        d_IN (f_i i) x \\<le> value_flow \\<Delta> (f_i i)\\<rbrakk>\n       \\<Longrightarrow> flow_network \\<Delta> (f_i (Suc i))\n 2. \\<And>i.\n       \\<lbrakk>flow_network \\<Delta> (f_i i);\n        value_flow \\<Delta> (f_i i) = value_flow \\<Delta> (f_aux i);\n        d_IN (f_i i) x \\<le> value_flow \\<Delta> (f_i i)\\<rbrakk>\n       \\<Longrightarrow> value_flow \\<Delta> (f_i (Suc i)) =\n                         value_flow \\<Delta> (f_aux (Suc i))\n 3. \\<And>i.\n       \\<lbrakk>flow_network \\<Delta> (f_i i);\n        value_flow \\<Delta> (f_i i) = value_flow \\<Delta> (f_aux i);\n        d_IN (f_i i) x \\<le> value_flow \\<Delta> (f_i i)\\<rbrakk>\n       \\<Longrightarrow> d_IN (f_i (Suc i)) x\n                         \\<le> value_flow \\<Delta> (f_i (Suc i))", "let ?RES = \"residual_network (f_i i)\""], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>flow_network \\<Delta> (f_i i);\n        value_flow \\<Delta> (f_i i) = value_flow \\<Delta> (f_aux i);\n        d_IN (f_i i) x \\<le> value_flow \\<Delta> (f_i i)\\<rbrakk>\n       \\<Longrightarrow> flow_network \\<Delta> (f_i (Suc i))\n 2. \\<And>i.\n       \\<lbrakk>flow_network \\<Delta> (f_i i);\n        value_flow \\<Delta> (f_i i) = value_flow \\<Delta> (f_aux i);\n        d_IN (f_i i) x \\<le> value_flow \\<Delta> (f_i i)\\<rbrakk>\n       \\<Longrightarrow> value_flow \\<Delta> (f_i (Suc i)) =\n                         value_flow \\<Delta> (f_aux (Suc i))\n 3. \\<And>i.\n       \\<lbrakk>flow_network \\<Delta> (f_i i);\n        value_flow \\<Delta> (f_i i) = value_flow \\<Delta> (f_aux i);\n        d_IN (f_i i) x \\<le> value_flow \\<Delta> (f_i i)\\<rbrakk>\n       \\<Longrightarrow> d_IN (f_i (Suc i)) x\n                         \\<le> value_flow \\<Delta> (f_i (Suc i))", "have k_i: \"flow ?RES (k_i i)\"\n      and value_k_i: \"value_flow ?RES (k_i i) = value_flow ?RES (f_aux (Suc i) \\<ominus> f_i i)\"\n      and d_IN_k_i: \"d_IN (k_i i) x \\<le> value_flow ?RES (k_i i)\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. flow (residual_network (f_i i)) (k_i i) &&&\n    value_flow (residual_network (f_i i)) (k_i i) =\n    value_flow (residual_network (f_i i))\n     (f_aux (Suc i) \\<ominus> f_i i) &&&\n    d_IN (k_i i) x \\<le> value_flow (residual_network (f_i i)) (k_i i)", "using Suc.IH(1-2)"], ["proof (prove)\nusing this:\n  flow_network \\<Delta> (f_i i)\n  value_flow \\<Delta> (f_i i) = value_flow \\<Delta> (f_aux i)\n\ngoal (1 subgoal):\n 1. flow (residual_network (f_i i)) (k_i i) &&&\n    value_flow (residual_network (f_i i)) (k_i i) =\n    value_flow (residual_network (f_i i))\n     (f_aux (Suc i) \\<ominus> f_i i) &&&\n    d_IN (k_i i) x \\<le> value_flow (residual_network (f_i i)) (k_i i)", "by(rule k_i value_k_i IN_k_i)+"], ["proof (state)\nthis:\n  flow (residual_network (f_i i)) (k_i i)\n  value_flow (residual_network (f_i i)) (k_i i) =\n  value_flow (residual_network (f_i i)) (f_aux (Suc i) \\<ominus> f_i i)\n  d_IN (k_i i) ?x \\<le> value_flow (residual_network (f_i i)) (k_i i)\n\ngoal (3 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>flow_network \\<Delta> (f_i i);\n        value_flow \\<Delta> (f_i i) = value_flow \\<Delta> (f_aux i);\n        d_IN (f_i i) x \\<le> value_flow \\<Delta> (f_i i)\\<rbrakk>\n       \\<Longrightarrow> flow_network \\<Delta> (f_i (Suc i))\n 2. \\<And>i.\n       \\<lbrakk>flow_network \\<Delta> (f_i i);\n        value_flow \\<Delta> (f_i i) = value_flow \\<Delta> (f_aux i);\n        d_IN (f_i i) x \\<le> value_flow \\<Delta> (f_i i)\\<rbrakk>\n       \\<Longrightarrow> value_flow \\<Delta> (f_i (Suc i)) =\n                         value_flow \\<Delta> (f_aux (Suc i))\n 3. \\<And>i.\n       \\<lbrakk>flow_network \\<Delta> (f_i i);\n        value_flow \\<Delta> (f_i i) = value_flow \\<Delta> (f_aux i);\n        d_IN (f_i i) x \\<le> value_flow \\<Delta> (f_i i)\\<rbrakk>\n       \\<Longrightarrow> d_IN (f_i (Suc i)) x\n                         \\<le> value_flow \\<Delta> (f_i (Suc i))", "interpret RES: flow_attainability \"?RES\""], ["proof (prove)\ngoal (1 subgoal):\n 1. flow_attainability (residual_network (f_i i))", "using wf fn.g"], ["proof (prove)\nusing this:\n  wf_residual_network\n  flow \\<Delta> (f_i i)\n\ngoal (1 subgoal):\n 1. flow_attainability (residual_network (f_i i))", "by(rule residual_flow_attainability)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>flow_network \\<Delta> (f_i i);\n        value_flow \\<Delta> (f_i i) = value_flow \\<Delta> (f_aux i);\n        d_IN (f_i i) x \\<le> value_flow \\<Delta> (f_i i)\\<rbrakk>\n       \\<Longrightarrow> flow_network \\<Delta> (f_i (Suc i))\n 2. \\<And>i.\n       \\<lbrakk>flow_network \\<Delta> (f_i i);\n        value_flow \\<Delta> (f_i i) = value_flow \\<Delta> (f_aux i);\n        d_IN (f_i i) x \\<le> value_flow \\<Delta> (f_i i)\\<rbrakk>\n       \\<Longrightarrow> value_flow \\<Delta> (f_i (Suc i)) =\n                         value_flow \\<Delta> (f_aux (Suc i))\n 3. \\<And>i.\n       \\<lbrakk>flow_network \\<Delta> (f_i i);\n        value_flow \\<Delta> (f_i i) = value_flow \\<Delta> (f_aux i);\n        d_IN (f_i i) x \\<le> value_flow \\<Delta> (f_i i)\\<rbrakk>\n       \\<Longrightarrow> d_IN (f_i (Suc i)) x\n                         \\<le> value_flow \\<Delta> (f_i (Suc i))", "have le: \"value_flow \\<Delta> (f_i i) \\<le> value_flow \\<Delta> (f_aux (Suc i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. value_flow \\<Delta> (f_i i) \\<le> value_flow \\<Delta> (f_aux (Suc i))", "unfolding value_aux Suc.IH(2) v_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. ennreal ((1 - (1 / 2) ^ i) * \\<alpha>')\n    \\<le> ennreal ((1 - (1 / 2) ^ Suc i) * \\<alpha>')", "using \\<alpha>'_nonneg"], ["proof (prove)\nusing this:\n  0 \\<le> \\<alpha>'\n\ngoal (1 subgoal):\n 1. ennreal ((1 - (1 / 2) ^ i) * \\<alpha>')\n    \\<le> ennreal ((1 - (1 / 2) ^ Suc i) * \\<alpha>')", "by(intro ennreal_leI)(simp add: real field_simps)"], ["proof (state)\nthis:\n  value_flow \\<Delta> (f_i i) \\<le> value_flow \\<Delta> (f_aux (Suc i))\n\ngoal (3 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>flow_network \\<Delta> (f_i i);\n        value_flow \\<Delta> (f_i i) = value_flow \\<Delta> (f_aux i);\n        d_IN (f_i i) x \\<le> value_flow \\<Delta> (f_i i)\\<rbrakk>\n       \\<Longrightarrow> flow_network \\<Delta> (f_i (Suc i))\n 2. \\<And>i.\n       \\<lbrakk>flow_network \\<Delta> (f_i i);\n        value_flow \\<Delta> (f_i i) = value_flow \\<Delta> (f_aux i);\n        d_IN (f_i i) x \\<le> value_flow \\<Delta> (f_i i)\\<rbrakk>\n       \\<Longrightarrow> value_flow \\<Delta> (f_i (Suc i)) =\n                         value_flow \\<Delta> (f_aux (Suc i))\n 3. \\<And>i.\n       \\<lbrakk>flow_network \\<Delta> (f_i i);\n        value_flow \\<Delta> (f_i i) = value_flow \\<Delta> (f_aux i);\n        d_IN (f_i i) x \\<le> value_flow \\<Delta> (f_i i)\\<rbrakk>\n       \\<Longrightarrow> d_IN (f_i (Suc i)) x\n                         \\<le> value_flow \\<Delta> (f_i (Suc i))", "{"], ["proof (state)\nthis:\n  value_flow \\<Delta> (f_i i) \\<le> value_flow \\<Delta> (f_aux (Suc i))\n\ngoal (3 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>flow_network \\<Delta> (f_i i);\n        value_flow \\<Delta> (f_i i) = value_flow \\<Delta> (f_aux i);\n        d_IN (f_i i) x \\<le> value_flow \\<Delta> (f_i i)\\<rbrakk>\n       \\<Longrightarrow> flow_network \\<Delta> (f_i (Suc i))\n 2. \\<And>i.\n       \\<lbrakk>flow_network \\<Delta> (f_i i);\n        value_flow \\<Delta> (f_i i) = value_flow \\<Delta> (f_aux i);\n        d_IN (f_i i) x \\<le> value_flow \\<Delta> (f_i i)\\<rbrakk>\n       \\<Longrightarrow> value_flow \\<Delta> (f_i (Suc i)) =\n                         value_flow \\<Delta> (f_aux (Suc i))\n 3. \\<And>i.\n       \\<lbrakk>flow_network \\<Delta> (f_i i);\n        value_flow \\<Delta> (f_i i) = value_flow \\<Delta> (f_aux i);\n        d_IN (f_i i) x \\<le> value_flow \\<Delta> (f_i i)\\<rbrakk>\n       \\<Longrightarrow> d_IN (f_i (Suc i)) x\n                         \\<le> value_flow \\<Delta> (f_i (Suc i))", "case 1"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>flow_network \\<Delta> (f_i i);\n        value_flow \\<Delta> (f_i i) = value_flow \\<Delta> (f_aux i);\n        d_IN (f_i i) x \\<le> value_flow \\<Delta> (f_i i)\\<rbrakk>\n       \\<Longrightarrow> flow_network \\<Delta> (f_i (Suc i))\n 2. \\<And>i.\n       \\<lbrakk>flow_network \\<Delta> (f_i i);\n        value_flow \\<Delta> (f_i i) = value_flow \\<Delta> (f_aux i);\n        d_IN (f_i i) x \\<le> value_flow \\<Delta> (f_i i)\\<rbrakk>\n       \\<Longrightarrow> value_flow \\<Delta> (f_i (Suc i)) =\n                         value_flow \\<Delta> (f_aux (Suc i))\n 3. \\<And>i.\n       \\<lbrakk>flow_network \\<Delta> (f_i i);\n        value_flow \\<Delta> (f_i i) = value_flow \\<Delta> (f_aux i);\n        d_IN (f_i i) x \\<le> value_flow \\<Delta> (f_i i)\\<rbrakk>\n       \\<Longrightarrow> d_IN (f_i (Suc i)) x\n                         \\<le> value_flow \\<Delta> (f_i (Suc i))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. flow_network \\<Delta> (f_i (Suc i))", "unfolding f_i_simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. flow_network \\<Delta> (f_i i \\<oplus> k_i i)", "proof"], ["proof (state)\ngoal (3 subgoals):\n 1. flow \\<Delta> (f_i i \\<oplus> k_i i)\n 2. value_flow \\<Delta> (f_i i \\<oplus> k_i i) \\<noteq> \\<top>\n 3. \\<^bold>V - {source \\<Delta>, sink \\<Delta>} \\<noteq> {}", "show \"flow \\<Delta> (f_i i \\<oplus> k_i i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. flow \\<Delta> (f_i i \\<oplus> k_i i)", "using wf fn.g k_i"], ["proof (prove)\nusing this:\n  wf_residual_network\n  flow \\<Delta> (f_i i)\n  flow (residual_network (f_i i)) (k_i i)\n\ngoal (1 subgoal):\n 1. flow \\<Delta> (f_i i \\<oplus> k_i i)", "by(rule flow_residual_add)"], ["proof (state)\nthis:\n  flow \\<Delta> (f_i i \\<oplus> k_i i)\n\ngoal (2 subgoals):\n 1. value_flow \\<Delta> (f_i i \\<oplus> k_i i) \\<noteq> \\<top>\n 2. \\<^bold>V - {source \\<Delta>, sink \\<Delta>} \\<noteq> {}", "with RES.flowD_finite[OF k_i]"], ["proof (chain)\npicking this:\n  k_i i ?e \\<noteq> \\<top>\n  flow \\<Delta> (f_i i \\<oplus> k_i i)", "show \"value_flow \\<Delta> (f_i i \\<oplus> k_i i) \\<noteq> \\<top>\""], ["proof (prove)\nusing this:\n  k_i i ?e \\<noteq> \\<top>\n  flow \\<Delta> (f_i i \\<oplus> k_i i)\n\ngoal (1 subgoal):\n 1. value_flow \\<Delta> (f_i i \\<oplus> k_i i) \\<noteq> \\<top>", "by(simp add: value_flow[OF _ source_out])"], ["proof (state)\nthis:\n  value_flow \\<Delta> (f_i i \\<oplus> k_i i) \\<noteq> \\<top>\n\ngoal (1 subgoal):\n 1. \\<^bold>V - {source \\<Delta>, sink \\<Delta>} \\<noteq> {}", "qed(rule nontrivial)"], ["proof (state)\nthis:\n  flow_network \\<Delta> (f_i (Suc i))\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>flow_network \\<Delta> (f_i i);\n        value_flow \\<Delta> (f_i i) = value_flow \\<Delta> (f_aux i);\n        d_IN (f_i i) x \\<le> value_flow \\<Delta> (f_i i)\\<rbrakk>\n       \\<Longrightarrow> value_flow \\<Delta> (f_i (Suc i)) =\n                         value_flow \\<Delta> (f_aux (Suc i))\n 2. \\<And>i.\n       \\<lbrakk>flow_network \\<Delta> (f_i i);\n        value_flow \\<Delta> (f_i i) = value_flow \\<Delta> (f_aux i);\n        d_IN (f_i i) x \\<le> value_flow \\<Delta> (f_i i)\\<rbrakk>\n       \\<Longrightarrow> d_IN (f_i (Suc i)) x\n                         \\<le> value_flow \\<Delta> (f_i (Suc i))", "}"], ["proof (state)\nthis:\n  flow_network \\<Delta> (f_i (Suc i))\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>flow_network \\<Delta> (f_i i);\n        value_flow \\<Delta> (f_i i) = value_flow \\<Delta> (f_aux i);\n        d_IN (f_i i) x \\<le> value_flow \\<Delta> (f_i i)\\<rbrakk>\n       \\<Longrightarrow> value_flow \\<Delta> (f_i (Suc i)) =\n                         value_flow \\<Delta> (f_aux (Suc i))\n 2. \\<And>i.\n       \\<lbrakk>flow_network \\<Delta> (f_i i);\n        value_flow \\<Delta> (f_i i) = value_flow \\<Delta> (f_aux i);\n        d_IN (f_i i) x \\<le> value_flow \\<Delta> (f_i i)\\<rbrakk>\n       \\<Longrightarrow> d_IN (f_i (Suc i)) x\n                         \\<le> value_flow \\<Delta> (f_i (Suc i))", "from value_k_i"], ["proof (chain)\npicking this:\n  value_flow (residual_network (f_i i)) (k_i i) =\n  value_flow (residual_network (f_i i)) (f_aux (Suc i) \\<ominus> f_i i)", "have value_k: \"value_flow ?RES (k_i i) = value_flow \\<Delta> (f_aux (Suc i)) - value_flow \\<Delta> (f_aux i)\""], ["proof (prove)\nusing this:\n  value_flow (residual_network (f_i i)) (k_i i) =\n  value_flow (residual_network (f_i i)) (f_aux (Suc i) \\<ominus> f_i i)\n\ngoal (1 subgoal):\n 1. value_flow (residual_network (f_i i)) (k_i i) =\n    value_flow \\<Delta> (f_aux (Suc i)) - value_flow \\<Delta> (f_aux i)", "by(simp add: value_minus_flow[OF f_aux fn.g le source_out] Suc.IH)"], ["proof (state)\nthis:\n  value_flow (residual_network (f_i i)) (k_i i) =\n  value_flow \\<Delta> (f_aux (Suc i)) - value_flow \\<Delta> (f_aux i)\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>flow_network \\<Delta> (f_i i);\n        value_flow \\<Delta> (f_i i) = value_flow \\<Delta> (f_aux i);\n        d_IN (f_i i) x \\<le> value_flow \\<Delta> (f_i i)\\<rbrakk>\n       \\<Longrightarrow> value_flow \\<Delta> (f_i (Suc i)) =\n                         value_flow \\<Delta> (f_aux (Suc i))\n 2. \\<And>i.\n       \\<lbrakk>flow_network \\<Delta> (f_i i);\n        value_flow \\<Delta> (f_i i) = value_flow \\<Delta> (f_aux i);\n        d_IN (f_i i) x \\<le> value_flow \\<Delta> (f_i i)\\<rbrakk>\n       \\<Longrightarrow> d_IN (f_i (Suc i)) x\n                         \\<le> value_flow \\<Delta> (f_i (Suc i))", "{"], ["proof (state)\nthis:\n  value_flow (residual_network (f_i i)) (k_i i) =\n  value_flow \\<Delta> (f_aux (Suc i)) - value_flow \\<Delta> (f_aux i)\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>flow_network \\<Delta> (f_i i);\n        value_flow \\<Delta> (f_i i) = value_flow \\<Delta> (f_aux i);\n        d_IN (f_i i) x \\<le> value_flow \\<Delta> (f_i i)\\<rbrakk>\n       \\<Longrightarrow> value_flow \\<Delta> (f_i (Suc i)) =\n                         value_flow \\<Delta> (f_aux (Suc i))\n 2. \\<And>i.\n       \\<lbrakk>flow_network \\<Delta> (f_i i);\n        value_flow \\<Delta> (f_i i) = value_flow \\<Delta> (f_aux i);\n        d_IN (f_i i) x \\<le> value_flow \\<Delta> (f_i i)\\<rbrakk>\n       \\<Longrightarrow> d_IN (f_i (Suc i)) x\n                         \\<le> value_flow \\<Delta> (f_i (Suc i))", "case 2"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>flow_network \\<Delta> (f_i i);\n        value_flow \\<Delta> (f_i i) = value_flow \\<Delta> (f_aux i);\n        d_IN (f_i i) x \\<le> value_flow \\<Delta> (f_i i)\\<rbrakk>\n       \\<Longrightarrow> value_flow \\<Delta> (f_i (Suc i)) =\n                         value_flow \\<Delta> (f_aux (Suc i))\n 2. \\<And>i.\n       \\<lbrakk>flow_network \\<Delta> (f_i i);\n        value_flow \\<Delta> (f_i i) = value_flow \\<Delta> (f_aux i);\n        d_IN (f_i i) x \\<le> value_flow \\<Delta> (f_i i)\\<rbrakk>\n       \\<Longrightarrow> d_IN (f_i (Suc i)) x\n                         \\<le> value_flow \\<Delta> (f_i (Suc i))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. value_flow \\<Delta> (f_i (Suc i)) = value_flow \\<Delta> (f_aux (Suc i))", "using value_k"], ["proof (prove)\nusing this:\n  value_flow (residual_network (f_i i)) (k_i i) =\n  value_flow \\<Delta> (f_aux (Suc i)) - value_flow \\<Delta> (f_aux i)\n\ngoal (1 subgoal):\n 1. value_flow \\<Delta> (f_i (Suc i)) = value_flow \\<Delta> (f_aux (Suc i))", "by(auto simp add: source_out value_plus_flow[OF wf fn.g k_i] Suc.IH value_aux field_simps intro!: ennreal_leI)"], ["proof (state)\nthis:\n  value_flow \\<Delta> (f_i (Suc i)) = value_flow \\<Delta> (f_aux (Suc i))\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>flow_network \\<Delta> (f_i i);\n        value_flow \\<Delta> (f_i i) = value_flow \\<Delta> (f_aux i);\n        d_IN (f_i i) x \\<le> value_flow \\<Delta> (f_i i)\\<rbrakk>\n       \\<Longrightarrow> d_IN (f_i (Suc i)) x\n                         \\<le> value_flow \\<Delta> (f_i (Suc i))", "}"], ["proof (state)\nthis:\n  value_flow \\<Delta> (f_i (Suc i)) = value_flow \\<Delta> (f_aux (Suc i))\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>flow_network \\<Delta> (f_i i);\n        value_flow \\<Delta> (f_i i) = value_flow \\<Delta> (f_aux i);\n        d_IN (f_i i) x \\<le> value_flow \\<Delta> (f_i i)\\<rbrakk>\n       \\<Longrightarrow> d_IN (f_i (Suc i)) x\n                         \\<le> value_flow \\<Delta> (f_i (Suc i))", "note value_f = this"], ["proof (state)\nthis:\n  value_flow \\<Delta> (f_i (Suc i)) = value_flow \\<Delta> (f_aux (Suc i))\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>flow_network \\<Delta> (f_i i);\n        value_flow \\<Delta> (f_i i) = value_flow \\<Delta> (f_aux i);\n        d_IN (f_i i) x \\<le> value_flow \\<Delta> (f_i i)\\<rbrakk>\n       \\<Longrightarrow> d_IN (f_i (Suc i)) x\n                         \\<le> value_flow \\<Delta> (f_i (Suc i))", "{"], ["proof (state)\nthis:\n  value_flow \\<Delta> (f_i (Suc i)) = value_flow \\<Delta> (f_aux (Suc i))\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>flow_network \\<Delta> (f_i i);\n        value_flow \\<Delta> (f_i i) = value_flow \\<Delta> (f_aux i);\n        d_IN (f_i i) x \\<le> value_flow \\<Delta> (f_i i)\\<rbrakk>\n       \\<Longrightarrow> d_IN (f_i (Suc i)) x\n                         \\<le> value_flow \\<Delta> (f_i (Suc i))", "case 3"], ["proof (state)\nthis:\n  \n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>flow_network \\<Delta> (f_i i);\n        value_flow \\<Delta> (f_i i) = value_flow \\<Delta> (f_aux i);\n        d_IN (f_i i) x \\<le> value_flow \\<Delta> (f_i i)\\<rbrakk>\n       \\<Longrightarrow> d_IN (f_i (Suc i)) x\n                         \\<le> value_flow \\<Delta> (f_i (Suc i))", "have \"d_IN (f_i i \\<oplus> k_i i) x \\<le> d_IN (f_i i) x + d_IN (k_i i) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN (f_i i \\<oplus> k_i i) x \\<le> d_IN (f_i i) x + d_IN (k_i i) x", "using fn.g k_i"], ["proof (prove)\nusing this:\n  flow \\<Delta> (f_i i)\n  flow (residual_network (f_i i)) (k_i i)\n\ngoal (1 subgoal):\n 1. d_IN (f_i i \\<oplus> k_i i) x \\<le> d_IN (f_i i) x + d_IN (k_i i) x", "by(rule d_IN_plus_flow[OF wf])"], ["proof (state)\nthis:\n  d_IN (f_i i \\<oplus> k_i i) x \\<le> d_IN (f_i i) x + d_IN (k_i i) x\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>flow_network \\<Delta> (f_i i);\n        value_flow \\<Delta> (f_i i) = value_flow \\<Delta> (f_aux i);\n        d_IN (f_i i) x \\<le> value_flow \\<Delta> (f_i i)\\<rbrakk>\n       \\<Longrightarrow> d_IN (f_i (Suc i)) x\n                         \\<le> value_flow \\<Delta> (f_i (Suc i))", "also"], ["proof (state)\nthis:\n  d_IN (f_i i \\<oplus> k_i i) x \\<le> d_IN (f_i i) x + d_IN (k_i i) x\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>flow_network \\<Delta> (f_i i);\n        value_flow \\<Delta> (f_i i) = value_flow \\<Delta> (f_aux i);\n        d_IN (f_i i) x \\<le> value_flow \\<Delta> (f_i i)\\<rbrakk>\n       \\<Longrightarrow> d_IN (f_i (Suc i)) x\n                         \\<le> value_flow \\<Delta> (f_i (Suc i))", "have \"\\<dots> \\<le> value_flow \\<Delta> (f_i i) + d_IN (k_i i) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN (f_i i) x + d_IN (k_i i) x\n    \\<le> value_flow \\<Delta> (f_i i) + d_IN (k_i i) x", "using Suc.IH(3)"], ["proof (prove)\nusing this:\n  d_IN (f_i i) x \\<le> value_flow \\<Delta> (f_i i)\n\ngoal (1 subgoal):\n 1. d_IN (f_i i) x + d_IN (k_i i) x\n    \\<le> value_flow \\<Delta> (f_i i) + d_IN (k_i i) x", "by(rule add_right_mono)"], ["proof (state)\nthis:\n  d_IN (f_i i) x + d_IN (k_i i) x\n  \\<le> value_flow \\<Delta> (f_i i) + d_IN (k_i i) x\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>flow_network \\<Delta> (f_i i);\n        value_flow \\<Delta> (f_i i) = value_flow \\<Delta> (f_aux i);\n        d_IN (f_i i) x \\<le> value_flow \\<Delta> (f_i i)\\<rbrakk>\n       \\<Longrightarrow> d_IN (f_i (Suc i)) x\n                         \\<le> value_flow \\<Delta> (f_i (Suc i))", "also"], ["proof (state)\nthis:\n  d_IN (f_i i) x + d_IN (k_i i) x\n  \\<le> value_flow \\<Delta> (f_i i) + d_IN (k_i i) x\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>flow_network \\<Delta> (f_i i);\n        value_flow \\<Delta> (f_i i) = value_flow \\<Delta> (f_aux i);\n        d_IN (f_i i) x \\<le> value_flow \\<Delta> (f_i i)\\<rbrakk>\n       \\<Longrightarrow> d_IN (f_i (Suc i)) x\n                         \\<le> value_flow \\<Delta> (f_i (Suc i))", "have \"\\<dots> \\<le> value_flow \\<Delta> (f_i i) + value_flow ?RES (k_i i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. value_flow \\<Delta> (f_i i) + d_IN (k_i i) x\n    \\<le> value_flow \\<Delta> (f_i i) +\n          value_flow (residual_network (f_i i)) (k_i i)", "using d_IN_k_i"], ["proof (prove)\nusing this:\n  d_IN (k_i i) ?x \\<le> value_flow (residual_network (f_i i)) (k_i i)\n\ngoal (1 subgoal):\n 1. value_flow \\<Delta> (f_i i) + d_IN (k_i i) x\n    \\<le> value_flow \\<Delta> (f_i i) +\n          value_flow (residual_network (f_i i)) (k_i i)", "by(rule add_left_mono)"], ["proof (state)\nthis:\n  value_flow \\<Delta> (f_i i) + d_IN (k_i i) x\n  \\<le> value_flow \\<Delta> (f_i i) +\n        value_flow (residual_network (f_i i)) (k_i i)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>flow_network \\<Delta> (f_i i);\n        value_flow \\<Delta> (f_i i) = value_flow \\<Delta> (f_aux i);\n        d_IN (f_i i) x \\<le> value_flow \\<Delta> (f_i i)\\<rbrakk>\n       \\<Longrightarrow> d_IN (f_i (Suc i)) x\n                         \\<le> value_flow \\<Delta> (f_i (Suc i))", "also"], ["proof (state)\nthis:\n  value_flow \\<Delta> (f_i i) + d_IN (k_i i) x\n  \\<le> value_flow \\<Delta> (f_i i) +\n        value_flow (residual_network (f_i i)) (k_i i)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>flow_network \\<Delta> (f_i i);\n        value_flow \\<Delta> (f_i i) = value_flow \\<Delta> (f_aux i);\n        d_IN (f_i i) x \\<le> value_flow \\<Delta> (f_i i)\\<rbrakk>\n       \\<Longrightarrow> d_IN (f_i (Suc i)) x\n                         \\<le> value_flow \\<Delta> (f_i (Suc i))", "have \"\\<dots> = value_flow \\<Delta> (f_i (Suc i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. value_flow \\<Delta> (f_i i) +\n    value_flow (residual_network (f_i i)) (k_i i) =\n    value_flow \\<Delta> (f_i (Suc i))", "unfolding value_f Suc.IH(2) value_k"], ["proof (prove)\ngoal (1 subgoal):\n 1. value_flow \\<Delta> (f_aux i) +\n    (value_flow \\<Delta> (f_aux (Suc i)) - value_flow \\<Delta> (f_aux i)) =\n    value_flow \\<Delta> (f_aux (Suc i))", "by(auto simp add: value_aux field_simps intro!: ennreal_leI)"], ["proof (state)\nthis:\n  value_flow \\<Delta> (f_i i) +\n  value_flow (residual_network (f_i i)) (k_i i) =\n  value_flow \\<Delta> (f_i (Suc i))\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>flow_network \\<Delta> (f_i i);\n        value_flow \\<Delta> (f_i i) = value_flow \\<Delta> (f_aux i);\n        d_IN (f_i i) x \\<le> value_flow \\<Delta> (f_i i)\\<rbrakk>\n       \\<Longrightarrow> d_IN (f_i (Suc i)) x\n                         \\<le> value_flow \\<Delta> (f_i (Suc i))", "finally"], ["proof (chain)\npicking this:\n  d_IN (f_i i \\<oplus> k_i i) x \\<le> value_flow \\<Delta> (f_i (Suc i))", "show ?case"], ["proof (prove)\nusing this:\n  d_IN (f_i i \\<oplus> k_i i) x \\<le> value_flow \\<Delta> (f_i (Suc i))\n\ngoal (1 subgoal):\n 1. d_IN (f_i (Suc i)) x \\<le> value_flow \\<Delta> (f_i (Suc i))", "by simp"], ["proof (state)\nthis:\n  d_IN (f_i (Suc i)) x \\<le> value_flow \\<Delta> (f_i (Suc i))\n\ngoal:\nNo subgoals!", "}"], ["proof (state)\nthis:\n  d_IN (f_i (Suc i)) x \\<le> value_flow \\<Delta> (f_i (Suc i))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  flow_network \\<Delta> (f_i ?i)\n  value_flow \\<Delta> (f_i ?i) = value_flow \\<Delta> (f_aux ?i)\n  d_IN (f_i ?i) ?x \\<le> value_flow \\<Delta> (f_i ?i)\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       flow \\<Delta> f \\<and>\n       value_flow \\<Delta> f = \\<alpha> \\<and>\n       (\\<forall>x. d_IN f x \\<le> value_flow \\<Delta> f)", "interpret fn: flow_network \\<Delta> \"f_i i\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. flow_network \\<Delta> (f_i i)", "by(rule fn_i)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>f.\n       flow \\<Delta> f \\<and>\n       value_flow \\<Delta> f = \\<alpha> \\<and>\n       (\\<forall>x. d_IN f x \\<le> value_flow \\<Delta> f)", "note k_i = k_i[OF fn_i value_f_i] and value_k_i = value_k_i[OF fn_i value_f_i]\n    and IN_k_i = IN_k_i[OF fn_i value_f_i] and value_diff = value_diff[OF fn_i value_f_i]"], ["proof (state)\nthis:\n  flow (residual_network (f_i ?i)) (k_i ?i)\n  value_flow (residual_network (f_i ?i)) (k_i ?i) =\n  value_flow (residual_network (f_i ?i)) (f_aux (Suc ?i) \\<ominus> f_i ?i)\n  d_IN (k_i ?i) ?x \\<le> value_flow (residual_network (f_i ?i)) (k_i ?i)\n  value_flow (residual_network (f_i ?i)) (f_aux (Suc ?i) \\<ominus> f_i ?i) =\n  value_flow \\<Delta> (f_aux (Suc ?i)) - value_flow \\<Delta> (f_i ?i)\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       flow \\<Delta> f \\<and>\n       value_flow \\<Delta> f = \\<alpha> \\<and>\n       (\\<forall>x. d_IN f x \\<le> value_flow \\<Delta> f)", "have \"\\<exists>x\\<ge>0. f_i i e = ennreal x\" for i e"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x\\<ge>0. f_i i e = ennreal x", "using fn.finite_g[of i e]"], ["proof (prove)\nusing this:\n  f_i i e \\<noteq> \\<top>\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<ge>0. f_i i e = ennreal x", "by (cases \"f_i i e\") auto"], ["proof (state)\nthis:\n  \\<exists>x\\<ge>0. f_i ?i ?e = ennreal x\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       flow \\<Delta> f \\<and>\n       value_flow \\<Delta> f = \\<alpha> \\<and>\n       (\\<forall>x. d_IN f x \\<le> value_flow \\<Delta> f)", "then"], ["proof (chain)\npicking this:\n  \\<exists>x\\<ge>0. f_i ?i ?e = ennreal x", "obtain f_i' where f_i': \"\\<And>i e. f_i i e = ennreal (f_i' i e)\" and [simp]: \"\\<And>i e. 0 \\<le> f_i' i e\""], ["proof (prove)\nusing this:\n  \\<exists>x\\<ge>0. f_i ?i ?e = ennreal x\n\ngoal (1 subgoal):\n 1. (\\<And>f_i'.\n        \\<lbrakk>\\<And>i e. f_i i e = ennreal (f_i' i e);\n         \\<And>i e. 0 \\<le> f_i' i e\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  f_i ?i ?e = ennreal (f_i' ?i ?e)\n  0 \\<le> f_i' ?i ?e\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       flow \\<Delta> f \\<and>\n       value_flow \\<Delta> f = \\<alpha> \\<and>\n       (\\<forall>x. d_IN f x \\<le> value_flow \\<Delta> f)", "{"], ["proof (state)\nthis:\n  f_i ?i ?e = ennreal (f_i' ?i ?e)\n  0 \\<le> f_i' ?i ?e\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       flow \\<Delta> f \\<and>\n       value_flow \\<Delta> f = \\<alpha> \\<and>\n       (\\<forall>x. d_IN f x \\<le> value_flow \\<Delta> f)", "fix i e"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>f.\n       flow \\<Delta> f \\<and>\n       value_flow \\<Delta> f = \\<alpha> \\<and>\n       (\\<forall>x. d_IN f x \\<le> value_flow \\<Delta> f)", "obtain x y :: 'v where e: \"e = (x, y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x y. e = (x, y) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases e)"], ["proof (state)\nthis:\n  e = (x, y)\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       flow \\<Delta> f \\<and>\n       value_flow \\<Delta> f = \\<alpha> \\<and>\n       (\\<forall>x. d_IN f x \\<le> value_flow \\<Delta> f)", "have \"k_i i (x, y) \\<le> d_IN (k_i i) y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k_i i (x, y) \\<le> d_IN (k_i i) y", "by (rule d_IN_ge_point)"], ["proof (state)\nthis:\n  k_i i (x, y) \\<le> d_IN (k_i i) y\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       flow \\<Delta> f \\<and>\n       value_flow \\<Delta> f = \\<alpha> \\<and>\n       (\\<forall>x. d_IN f x \\<le> value_flow \\<Delta> f)", "also"], ["proof (state)\nthis:\n  k_i i (x, y) \\<le> d_IN (k_i i) y\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       flow \\<Delta> f \\<and>\n       value_flow \\<Delta> f = \\<alpha> \\<and>\n       (\\<forall>x. d_IN f x \\<le> value_flow \\<Delta> f)", "have \"\\<dots> \\<le> value_flow (residual_network (f_i i)) (k_i i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN (k_i i) y \\<le> value_flow (residual_network (f_i i)) (k_i i)", "by(rule IN_k_i)"], ["proof (state)\nthis:\n  d_IN (k_i i) y \\<le> value_flow (residual_network (f_i i)) (k_i i)\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       flow \\<Delta> f \\<and>\n       value_flow \\<Delta> f = \\<alpha> \\<and>\n       (\\<forall>x. d_IN f x \\<le> value_flow \\<Delta> f)", "also"], ["proof (state)\nthis:\n  d_IN (k_i i) y \\<le> value_flow (residual_network (f_i i)) (k_i i)\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       flow \\<Delta> f \\<and>\n       value_flow \\<Delta> f = \\<alpha> \\<and>\n       (\\<forall>x. d_IN f x \\<le> value_flow \\<Delta> f)", "have \"\\<dots> < \\<top>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. value_flow (residual_network (f_i i)) (k_i i) < \\<top>", "using value_k_i[of i] value_diff[of i]"], ["proof (prove)\nusing this:\n  value_flow (residual_network (f_i i)) (k_i i) =\n  value_flow (residual_network (f_i i)) (f_aux (Suc i) \\<ominus> f_i i)\n  value_flow (residual_network (f_i i)) (f_aux (Suc i) \\<ominus> f_i i) =\n  value_flow \\<Delta> (f_aux (Suc i)) - value_flow \\<Delta> (f_i i)\n\ngoal (1 subgoal):\n 1. value_flow (residual_network (f_i i)) (k_i i) < \\<top>", "by(simp add: value_k_i value_f_i value_aux real less_top[symmetric])"], ["proof (state)\nthis:\n  value_flow (residual_network (f_i i)) (k_i i) < \\<top>\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       flow \\<Delta> f \\<and>\n       value_flow \\<Delta> f = \\<alpha> \\<and>\n       (\\<forall>x. d_IN f x \\<le> value_flow \\<Delta> f)", "finally"], ["proof (chain)\npicking this:\n  k_i i (x, y) < \\<top>", "have \"\\<exists>x\\<ge>0. k_i i e = ennreal x\""], ["proof (prove)\nusing this:\n  k_i i (x, y) < \\<top>\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<ge>0. k_i i e = ennreal x", "by(cases \"k_i i e\")(auto simp add: e)"], ["proof (state)\nthis:\n  \\<exists>x\\<ge>0. k_i i e = ennreal x\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       flow \\<Delta> f \\<and>\n       value_flow \\<Delta> f = \\<alpha> \\<and>\n       (\\<forall>x. d_IN f x \\<le> value_flow \\<Delta> f)", "}"], ["proof (state)\nthis:\n  \\<exists>x\\<ge>0. k_i ?ia2 ?e2 = ennreal x\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       flow \\<Delta> f \\<and>\n       value_flow \\<Delta> f = \\<alpha> \\<and>\n       (\\<forall>x. d_IN f x \\<le> value_flow \\<Delta> f)", "then"], ["proof (chain)\npicking this:\n  \\<exists>x\\<ge>0. k_i ?ia2 ?e2 = ennreal x", "obtain k_i' where k_i': \"\\<And>i e. k_i i e = ennreal (k_i' i e)\" and k_i'_nonneg[simp]: \"\\<And>i e. 0 \\<le> k_i' i e\""], ["proof (prove)\nusing this:\n  \\<exists>x\\<ge>0. k_i ?ia2 ?e2 = ennreal x\n\ngoal (1 subgoal):\n 1. (\\<And>k_i'.\n        \\<lbrakk>\\<And>i e. k_i i e = ennreal (k_i' i e);\n         \\<And>i e. 0 \\<le> k_i' i e\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  k_i ?i ?e = ennreal (k_i' ?i ?e)\n  0 \\<le> k_i' ?i ?e\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       flow \\<Delta> f \\<and>\n       value_flow \\<Delta> f = \\<alpha> \\<and>\n       (\\<forall>x. d_IN f x \\<le> value_flow \\<Delta> f)", "have wf_k: \"(x, y) \\<in> \\<^bold>E \\<Longrightarrow> k_i i (y, x) \\<le> f_i i (x, y) + k_i i (x, y)\" for i x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. (x, y) \\<in> \\<^bold>E \\<Longrightarrow>\n    k_i i (y, x) \\<le> f_i i (x, y) + k_i i (x, y)", "using flowD_capacity[OF k_i, of i \"(y, x)\"]"], ["proof (prove)\nusing this:\n  k_i i (y, x) \\<le> capacity (residual_network (f_i i)) (y, x)\n\ngoal (1 subgoal):\n 1. (x, y) \\<in> \\<^bold>E \\<Longrightarrow>\n    k_i i (y, x) \\<le> f_i i (x, y) + k_i i (x, y)", "by (auto split: if_split_asm dest: wf_residual_networkD[OF wf] elim: order_trans)"], ["proof (state)\nthis:\n  (?x, ?y) \\<in> \\<^bold>E \\<Longrightarrow>\n  k_i ?i (?y, ?x) \\<le> f_i ?i (?x, ?y) + k_i ?i (?x, ?y)\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       flow \\<Delta> f \\<and>\n       value_flow \\<Delta> f = \\<alpha> \\<and>\n       (\\<forall>x. d_IN f x \\<le> value_flow \\<Delta> f)", "have f_i'_0[simp]: \"f_i' 0 = (\\<lambda>_. 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f_i' 0 = (\\<lambda>_. 0)", "using f_i_simps(1)"], ["proof (prove)\nusing this:\n  f_i 0 = (\\<lambda>_. 0)\n\ngoal (1 subgoal):\n 1. f_i' 0 = (\\<lambda>_. 0)", "by (simp del: f_i_simps add: fun_eq_iff f_i')"], ["proof (state)\nthis:\n  f_i' 0 = (\\<lambda>_. 0)\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       flow \\<Delta> f \\<and>\n       value_flow \\<Delta> f = \\<alpha> \\<and>\n       (\\<forall>x. d_IN f x \\<le> value_flow \\<Delta> f)", "have f_i'_Suc[simp]: \"f_i' (Suc i) e =  (if e \\<in> \\<^bold>E then f_i' i e + (k_i' i e - k_i' i (prod.swap e)) else 0)\" for i e"], ["proof (prove)\ngoal (1 subgoal):\n 1. f_i' (Suc i) e =\n    (if e \\<in> \\<^bold>E then f_i' i e + (k_i' i e - k_i' i (prod.swap e))\n     else 0)", "using f_i_simps(2)[of i, unfolded fun_eq_iff, THEN spec, of e] wf_k[of \"fst e\" \"snd e\" i]"], ["proof (prove)\nusing this:\n  f_i (Suc i) e = (f_i i \\<oplus> k_i i) e\n  (fst e, snd e) \\<in> \\<^bold>E \\<Longrightarrow>\n  k_i i (snd e, fst e) \\<le> f_i i (fst e, snd e) + k_i i (fst e, snd e)\n\ngoal (1 subgoal):\n 1. f_i' (Suc i) e =\n    (if e \\<in> \\<^bold>E then f_i' i e + (k_i' i e - k_i' i (prod.swap e))\n     else 0)", "by (auto simp del: f_i_simps ennreal_plus\n             simp add: fun_eq_iff f_i' k_i' ennreal_plus[symmetric] ennreal_minus split: if_split_asm)"], ["proof (state)\nthis:\n  f_i' (Suc ?i) ?e =\n  (if ?e \\<in> \\<^bold>E\n   then f_i' ?i ?e + (k_i' ?i ?e - k_i' ?i (prod.swap ?e)) else 0)\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       flow \\<Delta> f \\<and>\n       value_flow \\<Delta> f = \\<alpha> \\<and>\n       (\\<forall>x. d_IN f x \\<le> value_flow \\<Delta> f)", "have k_i'_le: \"k_i' i e \\<le> \\<alpha>' / 2 ^ (Suc i)\" for i e"], ["proof (prove)\ngoal (1 subgoal):\n 1. k_i' i e \\<le> \\<alpha>' / 2 ^ Suc i", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. k_i' i e \\<le> \\<alpha>' / 2 ^ Suc i", "obtain x y where e: \"e = (x, y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x y. e = (x, y) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases e)"], ["proof (state)\nthis:\n  e = (x, y)\n\ngoal (1 subgoal):\n 1. k_i' i e \\<le> \\<alpha>' / 2 ^ Suc i", "have \"k_i' i (x, y) \\<le> d_IN (k_i' i) y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ennreal (k_i' i (x, y)) \\<le> d_IN (\\<lambda>x. ennreal (k_i' i x)) y", "by (rule d_IN_ge_point)"], ["proof (state)\nthis:\n  ennreal (k_i' i (x, y)) \\<le> d_IN (\\<lambda>x. ennreal (k_i' i x)) y\n\ngoal (1 subgoal):\n 1. k_i' i e \\<le> \\<alpha>' / 2 ^ Suc i", "also"], ["proof (state)\nthis:\n  ennreal (k_i' i (x, y)) \\<le> d_IN (\\<lambda>x. ennreal (k_i' i x)) y\n\ngoal (1 subgoal):\n 1. k_i' i e \\<le> \\<alpha>' / 2 ^ Suc i", "have \"\\<dots> \\<le> value_flow (residual_network (f_i i)) (k_i' i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN (\\<lambda>x. ennreal (k_i' i x)) y\n    \\<le> value_flow (residual_network (f_i i))\n           (\\<lambda>x. ennreal (k_i' i x))", "using IN_k_i[of i y]"], ["proof (prove)\nusing this:\n  d_IN (k_i i) y \\<le> value_flow (residual_network (f_i i)) (k_i i)\n\ngoal (1 subgoal):\n 1. d_IN (\\<lambda>x. ennreal (k_i' i x)) y\n    \\<le> value_flow (residual_network (f_i i))\n           (\\<lambda>x. ennreal (k_i' i x))", "by(simp add: k_i'[abs_def])"], ["proof (state)\nthis:\n  d_IN (\\<lambda>x. ennreal (k_i' i x)) y\n  \\<le> value_flow (residual_network (f_i i))\n         (\\<lambda>x. ennreal (k_i' i x))\n\ngoal (1 subgoal):\n 1. k_i' i e \\<le> \\<alpha>' / 2 ^ Suc i", "also"], ["proof (state)\nthis:\n  d_IN (\\<lambda>x. ennreal (k_i' i x)) y\n  \\<le> value_flow (residual_network (f_i i))\n         (\\<lambda>x. ennreal (k_i' i x))\n\ngoal (1 subgoal):\n 1. k_i' i e \\<le> \\<alpha>' / 2 ^ Suc i", "have \"\\<dots> = \\<alpha>' / 2 ^ (Suc i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. value_flow (residual_network (f_i i)) (\\<lambda>x. ennreal (k_i' i x)) =\n    ennreal (\\<alpha>' / 2 ^ Suc i)", "using value_k_i[of i] value_diff[of i]"], ["proof (prove)\nusing this:\n  value_flow (residual_network (f_i i)) (k_i i) =\n  value_flow (residual_network (f_i i)) (f_aux (Suc i) \\<ominus> f_i i)\n  value_flow (residual_network (f_i i)) (f_aux (Suc i) \\<ominus> f_i i) =\n  value_flow \\<Delta> (f_aux (Suc i)) - value_flow \\<Delta> (f_i i)\n\ngoal (1 subgoal):\n 1. value_flow (residual_network (f_i i)) (\\<lambda>x. ennreal (k_i' i x)) =\n    ennreal (\\<alpha>' / 2 ^ Suc i)", "by(simp add: value_f_i value_aux real k_i'[abs_def] field_simps ennreal_minus mult_le_cancel_left1)"], ["proof (state)\nthis:\n  value_flow (residual_network (f_i i)) (\\<lambda>x. ennreal (k_i' i x)) =\n  ennreal (\\<alpha>' / 2 ^ Suc i)\n\ngoal (1 subgoal):\n 1. k_i' i e \\<le> \\<alpha>' / 2 ^ Suc i", "finally"], ["proof (chain)\npicking this:\n  ennreal (k_i' i (x, y)) \\<le> ennreal (\\<alpha>' / 2 ^ Suc i)", "show ?thesis"], ["proof (prove)\nusing this:\n  ennreal (k_i' i (x, y)) \\<le> ennreal (\\<alpha>' / 2 ^ Suc i)\n\ngoal (1 subgoal):\n 1. k_i' i e \\<le> \\<alpha>' / 2 ^ Suc i", "using e"], ["proof (prove)\nusing this:\n  ennreal (k_i' i (x, y)) \\<le> ennreal (\\<alpha>' / 2 ^ Suc i)\n  e = (x, y)\n\ngoal (1 subgoal):\n 1. k_i' i e \\<le> \\<alpha>' / 2 ^ Suc i", "by simp"], ["proof (state)\nthis:\n  k_i' i e \\<le> \\<alpha>' / 2 ^ Suc i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  k_i' ?i ?e \\<le> \\<alpha>' / 2 ^ Suc ?i\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       flow \\<Delta> f \\<and>\n       value_flow \\<Delta> f = \\<alpha> \\<and>\n       (\\<forall>x. d_IN f x \\<le> value_flow \\<Delta> f)", "have convergent: \"convergent (\\<lambda>i. f_i' i e)\" for e"], ["proof (prove)\ngoal (1 subgoal):\n 1. convergent (\\<lambda>i. f_i' i e)", "proof(cases \"\\<alpha>' > 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 < \\<alpha>' \\<Longrightarrow> convergent (\\<lambda>i. f_i' i e)\n 2. \\<not> 0 < \\<alpha>' \\<Longrightarrow> convergent (\\<lambda>i. f_i' i e)", "case False"], ["proof (state)\nthis:\n  \\<not> 0 < \\<alpha>'\n\ngoal (2 subgoals):\n 1. 0 < \\<alpha>' \\<Longrightarrow> convergent (\\<lambda>i. f_i' i e)\n 2. \\<not> 0 < \\<alpha>' \\<Longrightarrow> convergent (\\<lambda>i. f_i' i e)", "obtain x y where [simp]: \"e = (x, y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x y. e = (x, y) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases e)"], ["proof (state)\nthis:\n  e = (x, y)\n\ngoal (2 subgoals):\n 1. 0 < \\<alpha>' \\<Longrightarrow> convergent (\\<lambda>i. f_i' i e)\n 2. \\<not> 0 < \\<alpha>' \\<Longrightarrow> convergent (\\<lambda>i. f_i' i e)", "{"], ["proof (state)\nthis:\n  e = (x, y)\n\ngoal (2 subgoals):\n 1. 0 < \\<alpha>' \\<Longrightarrow> convergent (\\<lambda>i. f_i' i e)\n 2. \\<not> 0 < \\<alpha>' \\<Longrightarrow> convergent (\\<lambda>i. f_i' i e)", "fix i"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 < \\<alpha>' \\<Longrightarrow> convergent (\\<lambda>i. f_i' i e)\n 2. \\<not> 0 < \\<alpha>' \\<Longrightarrow> convergent (\\<lambda>i. f_i' i e)", "from False \\<alpha>'_nonneg"], ["proof (chain)\npicking this:\n  \\<not> 0 < \\<alpha>'\n  0 \\<le> \\<alpha>'", "have \"\\<alpha>' = 0\""], ["proof (prove)\nusing this:\n  \\<not> 0 < \\<alpha>'\n  0 \\<le> \\<alpha>'\n\ngoal (1 subgoal):\n 1. \\<alpha>' = 0", "by simp"], ["proof (state)\nthis:\n  \\<alpha>' = 0\n\ngoal (2 subgoals):\n 1. 0 < \\<alpha>' \\<Longrightarrow> convergent (\\<lambda>i. f_i' i e)\n 2. \\<not> 0 < \\<alpha>' \\<Longrightarrow> convergent (\\<lambda>i. f_i' i e)", "moreover"], ["proof (state)\nthis:\n  \\<alpha>' = 0\n\ngoal (2 subgoals):\n 1. 0 < \\<alpha>' \\<Longrightarrow> convergent (\\<lambda>i. f_i' i e)\n 2. \\<not> 0 < \\<alpha>' \\<Longrightarrow> convergent (\\<lambda>i. f_i' i e)", "have \"f_i i (x, y) \\<le> d_IN (f_i i) y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f_i i (x, y) \\<le> d_IN (f_i i) y", "by (rule d_IN_ge_point)"], ["proof (state)\nthis:\n  f_i i (x, y) \\<le> d_IN (f_i i) y\n\ngoal (2 subgoals):\n 1. 0 < \\<alpha>' \\<Longrightarrow> convergent (\\<lambda>i. f_i' i e)\n 2. \\<not> 0 < \\<alpha>' \\<Longrightarrow> convergent (\\<lambda>i. f_i' i e)", "ultimately"], ["proof (chain)\npicking this:\n  \\<alpha>' = 0\n  f_i i (x, y) \\<le> d_IN (f_i i) y", "have \"f_i i (x, y) = 0\""], ["proof (prove)\nusing this:\n  \\<alpha>' = 0\n  f_i i (x, y) \\<le> d_IN (f_i i) y\n\ngoal (1 subgoal):\n 1. f_i i (x, y) = 0", "using d_IN_i[of i y]"], ["proof (prove)\nusing this:\n  \\<alpha>' = 0\n  f_i i (x, y) \\<le> d_IN (f_i i) y\n  d_IN (f_i i) y \\<le> value_flow \\<Delta> (f_i i)\n\ngoal (1 subgoal):\n 1. f_i i (x, y) = 0", "by(simp add: value_f_i value_aux real)"], ["proof (state)\nthis:\n  f_i i (x, y) = 0\n\ngoal (2 subgoals):\n 1. 0 < \\<alpha>' \\<Longrightarrow> convergent (\\<lambda>i. f_i' i e)\n 2. \\<not> 0 < \\<alpha>' \\<Longrightarrow> convergent (\\<lambda>i. f_i' i e)", "}"], ["proof (state)\nthis:\n  f_i ?ia2 (x, y) = 0\n\ngoal (2 subgoals):\n 1. 0 < \\<alpha>' \\<Longrightarrow> convergent (\\<lambda>i. f_i' i e)\n 2. \\<not> 0 < \\<alpha>' \\<Longrightarrow> convergent (\\<lambda>i. f_i' i e)", "thus ?thesis"], ["proof (prove)\nusing this:\n  f_i ?ia2 (x, y) = 0\n\ngoal (1 subgoal):\n 1. convergent (\\<lambda>i. f_i' i e)", "by(simp add: f_i' convergent_const)"], ["proof (state)\nthis:\n  convergent (\\<lambda>i. f_i' i e)\n\ngoal (1 subgoal):\n 1. 0 < \\<alpha>' \\<Longrightarrow> convergent (\\<lambda>i. f_i' i e)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. 0 < \\<alpha>' \\<Longrightarrow> convergent (\\<lambda>i. f_i' i e)", "case \\<alpha>'_pos: True"], ["proof (state)\nthis:\n  0 < \\<alpha>'\n\ngoal (1 subgoal):\n 1. 0 < \\<alpha>' \\<Longrightarrow> convergent (\\<lambda>i. f_i' i e)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. convergent (\\<lambda>i. f_i' i e)", "proof(rule real_Cauchy_convergent Cauchy_real_Suc_diff)+"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n. \\<bar>f_i' (Suc n) e - f_i' n e\\<bar> \\<le> ?c2 / ?x2 ^ n\n 2. 1 < ?x2", "fix n"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n. \\<bar>f_i' (Suc n) e - f_i' n e\\<bar> \\<le> ?c2 / ?x2 ^ n\n 2. 1 < ?x2", "have \"\\<bar>k_i' n e - k_i' n (prod.swap e)\\<bar> \\<le> \\<bar>k_i' n e\\<bar> + \\<bar>k_i' n (prod.swap e)\\<bar>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>k_i' n e - k_i' n (prod.swap e)\\<bar>\n    \\<le> \\<bar>k_i' n e\\<bar> + \\<bar>k_i' n (prod.swap e)\\<bar>", "by (rule abs_triangle_ineq4)"], ["proof (state)\nthis:\n  \\<bar>k_i' n e - k_i' n (prod.swap e)\\<bar>\n  \\<le> \\<bar>k_i' n e\\<bar> + \\<bar>k_i' n (prod.swap e)\\<bar>\n\ngoal (2 subgoals):\n 1. \\<And>n. \\<bar>f_i' (Suc n) e - f_i' n e\\<bar> \\<le> ?c2 / ?x2 ^ n\n 2. 1 < ?x2", "then"], ["proof (chain)\npicking this:\n  \\<bar>k_i' n e - k_i' n (prod.swap e)\\<bar>\n  \\<le> \\<bar>k_i' n e\\<bar> + \\<bar>k_i' n (prod.swap e)\\<bar>", "have \"\\<bar>k_i' n e - k_i' n (prod.swap e)\\<bar> \\<le> \\<alpha>' / 2 ^ n\""], ["proof (prove)\nusing this:\n  \\<bar>k_i' n e - k_i' n (prod.swap e)\\<bar>\n  \\<le> \\<bar>k_i' n e\\<bar> + \\<bar>k_i' n (prod.swap e)\\<bar>\n\ngoal (1 subgoal):\n 1. \\<bar>k_i' n e - k_i' n (prod.swap e)\\<bar> \\<le> \\<alpha>' / 2 ^ n", "using k_i'_le[of n e] k_i'_le[of n \"prod.swap e\"]"], ["proof (prove)\nusing this:\n  \\<bar>k_i' n e - k_i' n (prod.swap e)\\<bar>\n  \\<le> \\<bar>k_i' n e\\<bar> + \\<bar>k_i' n (prod.swap e)\\<bar>\n  k_i' n e \\<le> \\<alpha>' / 2 ^ Suc n\n  k_i' n (prod.swap e) \\<le> \\<alpha>' / 2 ^ Suc n\n\ngoal (1 subgoal):\n 1. \\<bar>k_i' n e - k_i' n (prod.swap e)\\<bar> \\<le> \\<alpha>' / 2 ^ n", "by simp"], ["proof (state)\nthis:\n  \\<bar>k_i' n e - k_i' n (prod.swap e)\\<bar> \\<le> \\<alpha>' / 2 ^ n\n\ngoal (2 subgoals):\n 1. \\<And>n. \\<bar>f_i' (Suc n) e - f_i' n e\\<bar> \\<le> ?c2 / ?x2 ^ n\n 2. 1 < ?x2", "then"], ["proof (chain)\npicking this:\n  \\<bar>k_i' n e - k_i' n (prod.swap e)\\<bar> \\<le> \\<alpha>' / 2 ^ n", "have \"\\<bar>f_i' (Suc n) e - f_i' n e\\<bar> \\<le> \\<alpha>' / 2 ^ n\""], ["proof (prove)\nusing this:\n  \\<bar>k_i' n e - k_i' n (prod.swap e)\\<bar> \\<le> \\<alpha>' / 2 ^ n\n\ngoal (1 subgoal):\n 1. \\<bar>f_i' (Suc n) e - f_i' n e\\<bar> \\<le> \\<alpha>' / 2 ^ n", "using flowD_outside[OF fn.g]"], ["proof (prove)\nusing this:\n  \\<bar>k_i' n e - k_i' n (prod.swap e)\\<bar> \\<le> \\<alpha>' / 2 ^ n\n  ?e \\<notin> \\<^bold>E \\<Longrightarrow> f_i ?i1 ?e = 0\n\ngoal (1 subgoal):\n 1. \\<bar>f_i' (Suc n) e - f_i' n e\\<bar> \\<le> \\<alpha>' / 2 ^ n", "by (cases e) (auto simp: f_i')"], ["proof (state)\nthis:\n  \\<bar>f_i' (Suc n) e - f_i' n e\\<bar> \\<le> \\<alpha>' / 2 ^ n\n\ngoal (2 subgoals):\n 1. \\<And>n. \\<bar>f_i' (Suc n) e - f_i' n e\\<bar> \\<le> ?c2 / ?x2 ^ n\n 2. 1 < ?x2", "thus \"\\<bar>f_i' (Suc n) e - f_i' n e\\<bar> \\<le> \\<alpha>' / 2 ^ n\""], ["proof (prove)\nusing this:\n  \\<bar>f_i' (Suc n) e - f_i' n e\\<bar> \\<le> \\<alpha>' / 2 ^ n\n\ngoal (1 subgoal):\n 1. \\<bar>f_i' (Suc n) e - f_i' n e\\<bar> \\<le> \\<alpha>' / 2 ^ n", "by simp"], ["proof (state)\nthis:\n  \\<bar>f_i' (Suc n) e - f_i' n e\\<bar> \\<le> \\<alpha>' / 2 ^ n\n\ngoal (1 subgoal):\n 1. 1 < 2", "qed simp"], ["proof (state)\nthis:\n  convergent (\\<lambda>i. f_i' i e)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  convergent (\\<lambda>i. f_i' i ?e)\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       flow \\<Delta> f \\<and>\n       value_flow \\<Delta> f = \\<alpha> \\<and>\n       (\\<forall>x. d_IN f x \\<le> value_flow \\<Delta> f)", "then"], ["proof (chain)\npicking this:\n  convergent (\\<lambda>i. f_i' i ?e)", "obtain f' where f': \"\\<And>e. (\\<lambda>i. f_i' i e) \\<longlonglongrightarrow> f' e\""], ["proof (prove)\nusing this:\n  convergent (\\<lambda>i. f_i' i ?e)\n\ngoal (1 subgoal):\n 1. (\\<And>f'.\n        (\\<And>e.\n            (\\<lambda>i. f_i' i e)\n            \\<longlonglongrightarrow> f' e) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding convergent_def"], ["proof (prove)\nusing this:\n  \\<exists>L. (\\<lambda>i. f_i' i ?e) \\<longlonglongrightarrow> L\n\ngoal (1 subgoal):\n 1. (\\<And>f'.\n        (\\<And>e.\n            (\\<lambda>i. f_i' i e)\n            \\<longlonglongrightarrow> f' e) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  (\\<lambda>i. f_i' i ?e) \\<longlonglongrightarrow> f' ?e\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       flow \\<Delta> f \\<and>\n       value_flow \\<Delta> f = \\<alpha> \\<and>\n       (\\<forall>x. d_IN f x \\<le> value_flow \\<Delta> f)", "hence f: \"\\<And>e. (\\<lambda>i. f_i i e) \\<longlonglongrightarrow> ennreal (f' e)\""], ["proof (prove)\nusing this:\n  (\\<lambda>i. f_i' i ?e) \\<longlonglongrightarrow> f' ?e\n\ngoal (1 subgoal):\n 1. \\<And>e. (\\<lambda>i. f_i i e) \\<longlonglongrightarrow> ennreal (f' e)", "unfolding f_i'"], ["proof (prove)\nusing this:\n  (\\<lambda>i. f_i' i ?e) \\<longlonglongrightarrow> f' ?e\n\ngoal (1 subgoal):\n 1. \\<And>e.\n       (\\<lambda>i. ennreal (f_i' i e))\n       \\<longlonglongrightarrow> ennreal (f' e)", "by simp"], ["proof (state)\nthis:\n  (\\<lambda>i. f_i i ?e) \\<longlonglongrightarrow> ennreal (f' ?e)\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       flow \\<Delta> f \\<and>\n       value_flow \\<Delta> f = \\<alpha> \\<and>\n       (\\<forall>x. d_IN f x \\<le> value_flow \\<Delta> f)", "have f'_nonneg: \"0 \\<le> f' e\" for e"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> f' e", "by (rule LIMSEQ_le_const[OF f']) auto"], ["proof (state)\nthis:\n  0 \\<le> f' ?e\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       flow \\<Delta> f \\<and>\n       value_flow \\<Delta> f = \\<alpha> \\<and>\n       (\\<forall>x. d_IN f x \\<le> value_flow \\<Delta> f)", "let ?k = \"\\<lambda>i x y. (k_i' i (x, y) - k_i' i (y, x)) * indicator \\<^bold>E (x, y)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>f.\n       flow \\<Delta> f \\<and>\n       value_flow \\<Delta> f = \\<alpha> \\<and>\n       (\\<forall>x. d_IN f x \\<le> value_flow \\<Delta> f)", "have sum_i': \"f_i' i (x, y) = (\\<Sum>j<i. ?k j x y)\" for x y i"], ["proof (prove)\ngoal (1 subgoal):\n 1. f_i' i (x, y) =\n    (\\<Sum>j<i.\n        (k_i' j (x, y) - k_i' j (y, x)) * indicat_real \\<^bold>E (x, y))", "by (induction i) auto"], ["proof (state)\nthis:\n  f_i' ?i (?x, ?y) =\n  (\\<Sum>j<?i.\n      (k_i' j (?x, ?y) - k_i' j (?y, ?x)) * indicat_real \\<^bold>E (?x, ?y))\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       flow \\<Delta> f \\<and>\n       value_flow \\<Delta> f = \\<alpha> \\<and>\n       (\\<forall>x. d_IN f x \\<le> value_flow \\<Delta> f)", "have summable_nk: \"summable (\\<lambda>i. \\<bar>?k i x y\\<bar>)\" for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. summable\n     (\\<lambda>i.\n         \\<bar>(k_i' i (x, y) - k_i' i (y, x)) *\n               indicat_real \\<^bold>E (x, y)\\<bar>)", "proof(rule summable_rabs_comparison_test)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>N.\n       \\<forall>i\\<ge>N.\n          \\<bar>(k_i' i (x, y) - k_i' i (y, x)) *\n                indicat_real \\<^bold>E (x, y)\\<bar>\n          \\<le> ?g i\n 2. summable ?g", "show \"\\<exists>N. \\<forall>i\\<ge>N. \\<bar>?k i x y\\<bar> \\<le> \\<alpha>' * (1 / 2) ^ i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>N.\n       \\<forall>i\\<ge>N.\n          \\<bar>(k_i' i (x, y) - k_i' i (y, x)) *\n                indicat_real \\<^bold>E (x, y)\\<bar>\n          \\<le> \\<alpha>' * (1 / 2) ^ i", "proof (intro exI allI impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       ?N \\<le> i \\<Longrightarrow>\n       \\<bar>(k_i' i (x, y) - k_i' i (y, x)) *\n             indicat_real \\<^bold>E (x, y)\\<bar>\n       \\<le> \\<alpha>' * (1 / 2) ^ i", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       ?N \\<le> i \\<Longrightarrow>\n       \\<bar>(k_i' i (x, y) - k_i' i (y, x)) *\n             indicat_real \\<^bold>E (x, y)\\<bar>\n       \\<le> \\<alpha>' * (1 / 2) ^ i", "have \"\\<bar>?k i x y\\<bar> \\<le> k_i' i (x, y) + k_i' i (y, x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>(k_i' i (x, y) - k_i' i (y, x)) *\n          indicat_real \\<^bold>E (x, y)\\<bar>\n    \\<le> k_i' i (x, y) + k_i' i (y, x)", "by (auto intro!: abs_triangle_ineq4[THEN order_trans] split: split_indicator)"], ["proof (state)\nthis:\n  \\<bar>(k_i' i (x, y) - k_i' i (y, x)) *\n        indicat_real \\<^bold>E (x, y)\\<bar>\n  \\<le> k_i' i (x, y) + k_i' i (y, x)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       ?N \\<le> i \\<Longrightarrow>\n       \\<bar>(k_i' i (x, y) - k_i' i (y, x)) *\n             indicat_real \\<^bold>E (x, y)\\<bar>\n       \\<le> \\<alpha>' * (1 / 2) ^ i", "also"], ["proof (state)\nthis:\n  \\<bar>(k_i' i (x, y) - k_i' i (y, x)) *\n        indicat_real \\<^bold>E (x, y)\\<bar>\n  \\<le> k_i' i (x, y) + k_i' i (y, x)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       ?N \\<le> i \\<Longrightarrow>\n       \\<bar>(k_i' i (x, y) - k_i' i (y, x)) *\n             indicat_real \\<^bold>E (x, y)\\<bar>\n       \\<le> \\<alpha>' * (1 / 2) ^ i", "have \"\\<dots> \\<le> \\<alpha>' * (1 / 2) ^ i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k_i' i (x, y) + k_i' i (y, x) \\<le> \\<alpha>' * (1 / 2) ^ i", "using k_i'_le[of i \"(x, y)\"] k_i'_le[of i \"(y, x)\"] \\<alpha>'_nonneg k_i'_nonneg[of i \"(x, y)\"] k_i'_nonneg[of i \"(y, x)\"]"], ["proof (prove)\nusing this:\n  k_i' i (x, y) \\<le> \\<alpha>' / 2 ^ Suc i\n  k_i' i (y, x) \\<le> \\<alpha>' / 2 ^ Suc i\n  0 \\<le> \\<alpha>'\n  0 \\<le> k_i' i (x, y)\n  0 \\<le> k_i' i (y, x)\n\ngoal (1 subgoal):\n 1. k_i' i (x, y) + k_i' i (y, x) \\<le> \\<alpha>' * (1 / 2) ^ i", "by(auto simp add: abs_real_def power_divide split: split_indicator)"], ["proof (state)\nthis:\n  k_i' i (x, y) + k_i' i (y, x) \\<le> \\<alpha>' * (1 / 2) ^ i\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       ?N \\<le> i \\<Longrightarrow>\n       \\<bar>(k_i' i (x, y) - k_i' i (y, x)) *\n             indicat_real \\<^bold>E (x, y)\\<bar>\n       \\<le> \\<alpha>' * (1 / 2) ^ i", "finally"], ["proof (chain)\npicking this:\n  \\<bar>(k_i' i (x, y) - k_i' i (y, x)) *\n        indicat_real \\<^bold>E (x, y)\\<bar>\n  \\<le> \\<alpha>' * (1 / 2) ^ i", "show \"\\<bar>?k i x y\\<bar> \\<le> \\<alpha>' * (1 / 2) ^ i\""], ["proof (prove)\nusing this:\n  \\<bar>(k_i' i (x, y) - k_i' i (y, x)) *\n        indicat_real \\<^bold>E (x, y)\\<bar>\n  \\<le> \\<alpha>' * (1 / 2) ^ i\n\ngoal (1 subgoal):\n 1. \\<bar>(k_i' i (x, y) - k_i' i (y, x)) *\n          indicat_real \\<^bold>E (x, y)\\<bar>\n    \\<le> \\<alpha>' * (1 / 2) ^ i", "by simp"], ["proof (state)\nthis:\n  \\<bar>(k_i' i (x, y) - k_i' i (y, x)) *\n        indicat_real \\<^bold>E (x, y)\\<bar>\n  \\<le> \\<alpha>' * (1 / 2) ^ i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>N.\n     \\<forall>i\\<ge>N.\n        \\<bar>(k_i' i (x, y) - k_i' i (y, x)) *\n              indicat_real \\<^bold>E (x, y)\\<bar>\n        \\<le> \\<alpha>' * (1 / 2) ^ i\n\ngoal (1 subgoal):\n 1. summable (\\<lambda>i. \\<alpha>' * (1 / 2) ^ i)", "show \"summable (\\<lambda>i. \\<alpha>' * (1 / 2) ^ i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. summable (\\<lambda>i. \\<alpha>' * (1 / 2) ^ i)", "by(rule summable_mult complete_algebra_summable_geometric)+ simp"], ["proof (state)\nthis:\n  summable (\\<lambda>i. \\<alpha>' * (1 / 2) ^ i)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  summable\n   (\\<lambda>i.\n       \\<bar>(k_i' i (?x, ?y) - k_i' i (?y, ?x)) *\n             indicat_real \\<^bold>E (?x, ?y)\\<bar>)\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       flow \\<Delta> f \\<and>\n       value_flow \\<Delta> f = \\<alpha> \\<and>\n       (\\<forall>x. d_IN f x \\<le> value_flow \\<Delta> f)", "hence summable_k: \"summable (\\<lambda>i. ?k i x y)\" for x y"], ["proof (prove)\nusing this:\n  summable\n   (\\<lambda>i.\n       \\<bar>(k_i' i (?x, ?y) - k_i' i (?y, ?x)) *\n             indicat_real \\<^bold>E (?x, ?y)\\<bar>)\n\ngoal (1 subgoal):\n 1. summable\n     (\\<lambda>i.\n         (k_i' i (x, y) - k_i' i (y, x)) * indicat_real \\<^bold>E (x, y))", "by(auto intro: summable_norm_cancel)"], ["proof (state)\nthis:\n  summable\n   (\\<lambda>i.\n       (k_i' i (?x, ?y) - k_i' i (?y, ?x)) *\n       indicat_real \\<^bold>E (?x, ?y))\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       flow \\<Delta> f \\<and>\n       value_flow \\<Delta> f = \\<alpha> \\<and>\n       (\\<forall>x. d_IN f x \\<le> value_flow \\<Delta> f)", "have suminf: \"(\\<Sum>i. (k_i' i (x, y) - k_i' i (y, x)) * indicator \\<^bold>E (x, y)) = f' (x, y)\" for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i.\n        (k_i' i (x, y) - k_i' i (y, x)) * indicat_real \\<^bold>E (x, y)) =\n    f' (x, y)", "by(rule LIMSEQ_unique[OF summable_LIMSEQ])(simp_all add: sum_i'[symmetric] f' summable_k)"], ["proof (state)\nthis:\n  (\\<Sum>i.\n      (k_i' i (?x, ?y) - k_i' i (?y, ?x)) *\n      indicat_real \\<^bold>E (?x, ?y)) =\n  f' (?x, ?y)\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       flow \\<Delta> f \\<and>\n       value_flow \\<Delta> f = \\<alpha> \\<and>\n       (\\<forall>x. d_IN f x \\<le> value_flow \\<Delta> f)", "have flow: \"flow \\<Delta> f'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. flow \\<Delta> (\\<lambda>x. ennreal (f' x))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>e. ennreal (f' e) \\<le> capacity \\<Delta> e\n 2. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>;\n        x \\<noteq> sink \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> KIR (\\<lambda>x. ennreal (f' x)) x", "fix e"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>e. ennreal (f' e) \\<le> capacity \\<Delta> e\n 2. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>;\n        x \\<noteq> sink \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> KIR (\\<lambda>x. ennreal (f' x)) x", "have \"f' e \\<le> Sup {..capacity \\<Delta> e}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ennreal (f' e) \\<le> \\<Squnion> {..capacity \\<Delta> e}", "using _ f"], ["proof (prove)\nusing this:\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  (\\<lambda>i. f_i i ?e) \\<longlonglongrightarrow> ennreal (f' ?e)\n\ngoal (1 subgoal):\n 1. ennreal (f' e) \\<le> \\<Squnion> {..capacity \\<Delta> e}", "by(rule Sup_lim)(simp add: flowD_capacity[OF fn.g])"], ["proof (state)\nthis:\n  ennreal (f' e) \\<le> \\<Squnion> {..capacity \\<Delta> e}\n\ngoal (2 subgoals):\n 1. \\<And>e. ennreal (f' e) \\<le> capacity \\<Delta> e\n 2. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>;\n        x \\<noteq> sink \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> KIR (\\<lambda>x. ennreal (f' x)) x", "then"], ["proof (chain)\npicking this:\n  ennreal (f' e) \\<le> \\<Squnion> {..capacity \\<Delta> e}", "show \"f' e \\<le> capacity \\<Delta> e\""], ["proof (prove)\nusing this:\n  ennreal (f' e) \\<le> \\<Squnion> {..capacity \\<Delta> e}\n\ngoal (1 subgoal):\n 1. ennreal (f' e) \\<le> capacity \\<Delta> e", "by simp"], ["proof (state)\nthis:\n  ennreal (f' e) \\<le> capacity \\<Delta> e\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>;\n        x \\<noteq> sink \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> KIR (\\<lambda>x. ennreal (f' x)) x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>;\n        x \\<noteq> sink \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> KIR (\\<lambda>x. ennreal (f' x)) x", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>;\n        x \\<noteq> sink \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> KIR (\\<lambda>x. ennreal (f' x)) x", "assume x: \"x \\<noteq> source \\<Delta>\" \"x \\<noteq> sink \\<Delta>\""], ["proof (state)\nthis:\n  x \\<noteq> source \\<Delta>\n  x \\<noteq> sink \\<Delta>\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>;\n        x \\<noteq> sink \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> KIR (\\<lambda>x. ennreal (f' x)) x", "have integrable_f_i: \"integrable (count_space UNIV) (\\<lambda>y. f_i' i (x, y))\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. integrable (count_space UNIV) (\\<lambda>y. f_i' i (x, y))", "using flowD_finite_OUT[OF fn.g x, of i]"], ["proof (prove)\nusing this:\n  d_OUT (f_i i) x \\<noteq> \\<top>\n\ngoal (1 subgoal):\n 1. integrable (count_space UNIV) (\\<lambda>y. f_i' i (x, y))", "by(auto intro!: integrableI_bounded simp add: f_i' d_OUT_def less_top)"], ["proof (state)\nthis:\n  integrable (count_space UNIV) (\\<lambda>y. f_i' ?i (x, y))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>;\n        x \\<noteq> sink \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> KIR (\\<lambda>x. ennreal (f' x)) x", "have integrable_f_i': \"integrable (count_space UNIV) (\\<lambda>y. f_i' i (y, x))\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. integrable (count_space UNIV) (\\<lambda>y. f_i' i (y, x))", "using flowD_finite_IN[OF fn.g, of x i] x"], ["proof (prove)\nusing this:\n  x \\<noteq> sink \\<Delta> \\<Longrightarrow> d_IN (f_i i) x \\<noteq> \\<top>\n  x \\<noteq> source \\<Delta>\n  x \\<noteq> sink \\<Delta>\n\ngoal (1 subgoal):\n 1. integrable (count_space UNIV) (\\<lambda>y. f_i' i (y, x))", "by(auto intro!: integrableI_bounded simp add: f_i' d_IN_def less_top)"], ["proof (state)\nthis:\n  integrable (count_space UNIV) (\\<lambda>y. f_i' ?i (y, x))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>;\n        x \\<noteq> sink \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> KIR (\\<lambda>x. ennreal (f' x)) x", "have integral_k_bounded: \"(\\<Sum>\\<^sup>+ y. norm (?k i x y)) \\<le> \\<alpha>' / 2 ^ i\" (is ?thesis1)\n      and integral_k'_bounded: \"(\\<Sum>\\<^sup>+ y. norm (?k i y x)) \\<le> \\<alpha>' / 2 ^ i\" (is ?thesis2) for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ x.\n       ennreal\n        (norm\n          ((k_i' i (x, x) - k_i' i (x, x)) *\n           indicat_real \\<^bold>E (x, x))))\n    \\<le> ennreal (\\<alpha>' / 2 ^ i) &&&\n    (\\<Sum>\\<^sup>+ x.\n       ennreal\n        (norm\n          ((k_i' i (x, x) - k_i' i (x, x)) *\n           indicat_real \\<^bold>E (x, x))))\n    \\<le> ennreal (\\<alpha>' / 2 ^ i)", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<Sum>\\<^sup>+ x.\n       ennreal\n        (norm\n          ((k_i' i (x, x) - k_i' i (x, x)) *\n           indicat_real \\<^bold>E (x, x))))\n    \\<le> ennreal (\\<alpha>' / 2 ^ i)\n 2. (\\<Sum>\\<^sup>+ x.\n       ennreal\n        (norm\n          ((k_i' i (x, x) - k_i' i (x, x)) *\n           indicat_real \\<^bold>E (x, x))))\n    \\<le> ennreal (\\<alpha>' / 2 ^ i)", "define b where \"b = (\\<Sum>\\<^sup>+ y. k_i i (x, y) + k_i i (y, x))\""], ["proof (state)\nthis:\n  b = (\\<Sum>\\<^sup>+ y. k_i i (x, y) + k_i i (y, x))\n\ngoal (2 subgoals):\n 1. (\\<Sum>\\<^sup>+ x.\n       ennreal\n        (norm\n          ((k_i' i (x, x) - k_i' i (x, x)) *\n           indicat_real \\<^bold>E (x, x))))\n    \\<le> ennreal (\\<alpha>' / 2 ^ i)\n 2. (\\<Sum>\\<^sup>+ x.\n       ennreal\n        (norm\n          ((k_i' i (x, x) - k_i' i (x, x)) *\n           indicat_real \\<^bold>E (x, x))))\n    \\<le> ennreal (\\<alpha>' / 2 ^ i)", "have \"b = d_OUT (k_i i) x + d_IN (k_i i) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b = d_OUT (k_i i) x + d_IN (k_i i) x", "unfolding b_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y. k_i i (x, y) + k_i i (y, x)) =\n    d_OUT (k_i i) x + d_IN (k_i i) x", "by(subst nn_integral_add)(simp_all add: d_OUT_def d_IN_def)"], ["proof (state)\nthis:\n  b = d_OUT (k_i i) x + d_IN (k_i i) x\n\ngoal (2 subgoals):\n 1. (\\<Sum>\\<^sup>+ x.\n       ennreal\n        (norm\n          ((k_i' i (x, x) - k_i' i (x, x)) *\n           indicat_real \\<^bold>E (x, x))))\n    \\<le> ennreal (\\<alpha>' / 2 ^ i)\n 2. (\\<Sum>\\<^sup>+ x.\n       ennreal\n        (norm\n          ((k_i' i (x, x) - k_i' i (x, x)) *\n           indicat_real \\<^bold>E (x, x))))\n    \\<le> ennreal (\\<alpha>' / 2 ^ i)", "also"], ["proof (state)\nthis:\n  b = d_OUT (k_i i) x + d_IN (k_i i) x\n\ngoal (2 subgoals):\n 1. (\\<Sum>\\<^sup>+ x.\n       ennreal\n        (norm\n          ((k_i' i (x, x) - k_i' i (x, x)) *\n           indicat_real \\<^bold>E (x, x))))\n    \\<le> ennreal (\\<alpha>' / 2 ^ i)\n 2. (\\<Sum>\\<^sup>+ x.\n       ennreal\n        (norm\n          ((k_i' i (x, x) - k_i' i (x, x)) *\n           indicat_real \\<^bold>E (x, x))))\n    \\<le> ennreal (\\<alpha>' / 2 ^ i)", "have \"d_OUT (k_i i) x = d_IN (k_i i) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. KIR (k_i i) x", "using k_i"], ["proof (prove)\nusing this:\n  flow (residual_network (f_i ?i)) (k_i ?i)\n\ngoal (1 subgoal):\n 1. KIR (k_i i) x", "by(rule flowD_KIR)(simp_all add: x)"], ["proof (state)\nthis:\n  KIR (k_i i) x\n\ngoal (2 subgoals):\n 1. (\\<Sum>\\<^sup>+ x.\n       ennreal\n        (norm\n          ((k_i' i (x, x) - k_i' i (x, x)) *\n           indicat_real \\<^bold>E (x, x))))\n    \\<le> ennreal (\\<alpha>' / 2 ^ i)\n 2. (\\<Sum>\\<^sup>+ x.\n       ennreal\n        (norm\n          ((k_i' i (x, x) - k_i' i (x, x)) *\n           indicat_real \\<^bold>E (x, x))))\n    \\<le> ennreal (\\<alpha>' / 2 ^ i)", "also"], ["proof (state)\nthis:\n  KIR (k_i i) x\n\ngoal (2 subgoals):\n 1. (\\<Sum>\\<^sup>+ x.\n       ennreal\n        (norm\n          ((k_i' i (x, x) - k_i' i (x, x)) *\n           indicat_real \\<^bold>E (x, x))))\n    \\<le> ennreal (\\<alpha>' / 2 ^ i)\n 2. (\\<Sum>\\<^sup>+ x.\n       ennreal\n        (norm\n          ((k_i' i (x, x) - k_i' i (x, x)) *\n           indicat_real \\<^bold>E (x, x))))\n    \\<le> ennreal (\\<alpha>' / 2 ^ i)", "have \"\\<dots> + \\<dots> \\<le> value_flow \\<Delta> (k_i i) + value_flow \\<Delta> (k_i i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN (k_i i) x + d_IN (k_i i) x\n    \\<le> value_flow \\<Delta> (k_i i) + value_flow \\<Delta> (k_i i)", "using IN_k_i[of i x, simplified]"], ["proof (prove)\nusing this:\n  d_IN (k_i i) x \\<le> value_flow \\<Delta> (k_i i)\n\ngoal (1 subgoal):\n 1. d_IN (k_i i) x + d_IN (k_i i) x\n    \\<le> value_flow \\<Delta> (k_i i) + value_flow \\<Delta> (k_i i)", "by-(rule add_mono)"], ["proof (state)\nthis:\n  d_IN (k_i i) x + d_IN (k_i i) x\n  \\<le> value_flow \\<Delta> (k_i i) + value_flow \\<Delta> (k_i i)\n\ngoal (2 subgoals):\n 1. (\\<Sum>\\<^sup>+ x.\n       ennreal\n        (norm\n          ((k_i' i (x, x) - k_i' i (x, x)) *\n           indicat_real \\<^bold>E (x, x))))\n    \\<le> ennreal (\\<alpha>' / 2 ^ i)\n 2. (\\<Sum>\\<^sup>+ x.\n       ennreal\n        (norm\n          ((k_i' i (x, x) - k_i' i (x, x)) *\n           indicat_real \\<^bold>E (x, x))))\n    \\<le> ennreal (\\<alpha>' / 2 ^ i)", "also"], ["proof (state)\nthis:\n  d_IN (k_i i) x + d_IN (k_i i) x\n  \\<le> value_flow \\<Delta> (k_i i) + value_flow \\<Delta> (k_i i)\n\ngoal (2 subgoals):\n 1. (\\<Sum>\\<^sup>+ x.\n       ennreal\n        (norm\n          ((k_i' i (x, x) - k_i' i (x, x)) *\n           indicat_real \\<^bold>E (x, x))))\n    \\<le> ennreal (\\<alpha>' / 2 ^ i)\n 2. (\\<Sum>\\<^sup>+ x.\n       ennreal\n        (norm\n          ((k_i' i (x, x) - k_i' i (x, x)) *\n           indicat_real \\<^bold>E (x, x))))\n    \\<le> ennreal (\\<alpha>' / 2 ^ i)", "have \"\\<dots> \\<le> \\<alpha>' / 2 ^ i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. value_flow \\<Delta> (k_i i) + value_flow \\<Delta> (k_i i)\n    \\<le> ennreal (\\<alpha>' / 2 ^ i)", "using value_k_i[of i] value_diff[of i]"], ["proof (prove)\nusing this:\n  value_flow (residual_network (f_i i)) (k_i i) =\n  value_flow (residual_network (f_i i)) (f_aux (Suc i) \\<ominus> f_i i)\n  value_flow (residual_network (f_i i)) (f_aux (Suc i) \\<ominus> f_i i) =\n  value_flow \\<Delta> (f_aux (Suc i)) - value_flow \\<Delta> (f_i i)\n\ngoal (1 subgoal):\n 1. value_flow \\<Delta> (k_i i) + value_flow \\<Delta> (k_i i)\n    \\<le> ennreal (\\<alpha>' / 2 ^ i)", "by(simp add: value_aux value_f_i  field_simps ennreal_minus_if ennreal_plus_if mult_le_cancel_left1\n                del: ennreal_plus)"], ["proof (state)\nthis:\n  value_flow \\<Delta> (k_i i) + value_flow \\<Delta> (k_i i)\n  \\<le> ennreal (\\<alpha>' / 2 ^ i)\n\ngoal (2 subgoals):\n 1. (\\<Sum>\\<^sup>+ x.\n       ennreal\n        (norm\n          ((k_i' i (x, x) - k_i' i (x, x)) *\n           indicat_real \\<^bold>E (x, x))))\n    \\<le> ennreal (\\<alpha>' / 2 ^ i)\n 2. (\\<Sum>\\<^sup>+ x.\n       ennreal\n        (norm\n          ((k_i' i (x, x) - k_i' i (x, x)) *\n           indicat_real \\<^bold>E (x, x))))\n    \\<le> ennreal (\\<alpha>' / 2 ^ i)", "also"], ["proof (state)\nthis:\n  value_flow \\<Delta> (k_i i) + value_flow \\<Delta> (k_i i)\n  \\<le> ennreal (\\<alpha>' / 2 ^ i)\n\ngoal (2 subgoals):\n 1. (\\<Sum>\\<^sup>+ x.\n       ennreal\n        (norm\n          ((k_i' i (x, x) - k_i' i (x, x)) *\n           indicat_real \\<^bold>E (x, x))))\n    \\<le> ennreal (\\<alpha>' / 2 ^ i)\n 2. (\\<Sum>\\<^sup>+ x.\n       ennreal\n        (norm\n          ((k_i' i (x, x) - k_i' i (x, x)) *\n           indicat_real \\<^bold>E (x, x))))\n    \\<le> ennreal (\\<alpha>' / 2 ^ i)", "have \"(\\<Sum>\\<^sup>+ y\\<in>UNIV. norm (?k i x y)) \\<le> b\" and \"(\\<Sum>\\<^sup>+ y. norm (?k i y x)) \\<le> b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ x.\n       ennreal\n        (norm\n          ((k_i' i (x, x) - k_i' i (x, x)) *\n           indicat_real \\<^bold>E (x, x))))\n    \\<le> b &&&\n    (\\<Sum>\\<^sup>+ x.\n       ennreal\n        (norm\n          ((k_i' i (x, x) - k_i' i (x, x)) *\n           indicat_real \\<^bold>E (x, x))))\n    \\<le> b", "unfolding b_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ x.\n       ennreal\n        (norm\n          ((k_i' i (x, x) - k_i' i (x, x)) *\n           indicat_real \\<^bold>E (x, x))))\n    \\<le> (\\<Sum>\\<^sup>+ y. k_i i (x, y) + k_i i (y, x)) &&&\n    (\\<Sum>\\<^sup>+ x.\n       ennreal\n        (norm\n          ((k_i' i (x, x) - k_i' i (x, x)) *\n           indicat_real \\<^bold>E (x, x))))\n    \\<le> (\\<Sum>\\<^sup>+ y. k_i i (x, y) + k_i i (y, x))", "by(rule nn_integral_mono; simp add: abs_real_def k_i' ennreal_plus_if del:  ennreal_plus split: split_indicator)+"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ x.\n     ennreal\n      (norm\n        ((k_i' i (x, x) - k_i' i (x, x)) * indicat_real \\<^bold>E (x, x))))\n  \\<le> b\n  (\\<Sum>\\<^sup>+ x.\n     ennreal\n      (norm\n        ((k_i' i (x, x) - k_i' i (x, x)) * indicat_real \\<^bold>E (x, x))))\n  \\<le> b\n\ngoal (2 subgoals):\n 1. (\\<Sum>\\<^sup>+ x.\n       ennreal\n        (norm\n          ((k_i' i (x, x) - k_i' i (x, x)) *\n           indicat_real \\<^bold>E (x, x))))\n    \\<le> ennreal (\\<alpha>' / 2 ^ i)\n 2. (\\<Sum>\\<^sup>+ x.\n       ennreal\n        (norm\n          ((k_i' i (x, x) - k_i' i (x, x)) *\n           indicat_real \\<^bold>E (x, x))))\n    \\<le> ennreal (\\<alpha>' / 2 ^ i)", "ultimately"], ["proof (chain)\npicking this:\n  b \\<le> ennreal (\\<alpha>' / 2 ^ i)\n  (\\<Sum>\\<^sup>+ x.\n     ennreal\n      (norm\n        ((k_i' i (x, x) - k_i' i (x, x)) * indicat_real \\<^bold>E (x, x))))\n  \\<le> b\n  (\\<Sum>\\<^sup>+ x.\n     ennreal\n      (norm\n        ((k_i' i (x, x) - k_i' i (x, x)) * indicat_real \\<^bold>E (x, x))))\n  \\<le> b", "show ?thesis1 ?thesis2"], ["proof (prove)\nusing this:\n  b \\<le> ennreal (\\<alpha>' / 2 ^ i)\n  (\\<Sum>\\<^sup>+ x.\n     ennreal\n      (norm\n        ((k_i' i (x, x) - k_i' i (x, x)) * indicat_real \\<^bold>E (x, x))))\n  \\<le> b\n  (\\<Sum>\\<^sup>+ x.\n     ennreal\n      (norm\n        ((k_i' i (x, x) - k_i' i (x, x)) * indicat_real \\<^bold>E (x, x))))\n  \\<le> b\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ x.\n       ennreal\n        (norm\n          ((k_i' i (x, x) - k_i' i (x, x)) *\n           indicat_real \\<^bold>E (x, x))))\n    \\<le> ennreal (\\<alpha>' / 2 ^ i) &&&\n    (\\<Sum>\\<^sup>+ x.\n       ennreal\n        (norm\n          ((k_i' i (x, x) - k_i' i (x, x)) *\n           indicat_real \\<^bold>E (x, x))))\n    \\<le> ennreal (\\<alpha>' / 2 ^ i)", "by(auto)"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ x.\n     ennreal\n      (norm\n        ((k_i' i (x, x) - k_i' i (x, x)) * indicat_real \\<^bold>E (x, x))))\n  \\<le> ennreal (\\<alpha>' / 2 ^ i)\n  (\\<Sum>\\<^sup>+ x.\n     ennreal\n      (norm\n        ((k_i' i (x, x) - k_i' i (x, x)) * indicat_real \\<^bold>E (x, x))))\n  \\<le> ennreal (\\<alpha>' / 2 ^ i)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ x.\n     ennreal\n      (norm\n        ((k_i' ?i (x, x) - k_i' ?i (x, x)) *\n         indicat_real \\<^bold>E (x, x))))\n  \\<le> ennreal (\\<alpha>' / 2 ^ ?i)\n  (\\<Sum>\\<^sup>+ x.\n     ennreal\n      (norm\n        ((k_i' ?i (x, x) - k_i' ?i (x, x)) *\n         indicat_real \\<^bold>E (x, x))))\n  \\<le> ennreal (\\<alpha>' / 2 ^ ?i)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>;\n        x \\<noteq> sink \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> KIR (\\<lambda>x. ennreal (f' x)) x", "have integrable_k: \"integrable (count_space UNIV) (\\<lambda>y. ?k i x y)\"\n      and integrable_k': \"integrable (count_space UNIV) (\\<lambda>y. ?k i y x)\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. integrable (count_space UNIV)\n     (\\<lambda>y.\n         (k_i' i (x, y) - k_i' i (y, x)) *\n         indicat_real \\<^bold>E (x, y)) &&&\n    integrable (count_space UNIV)\n     (\\<lambda>y.\n         (k_i' i (y, x) - k_i' i (x, y)) * indicat_real \\<^bold>E (y, x))", "using integral_k_bounded[of i] integral_k'_bounded[of i] real"], ["proof (prove)\nusing this:\n  (\\<Sum>\\<^sup>+ x.\n     ennreal\n      (norm\n        ((k_i' i (x, x) - k_i' i (x, x)) * indicat_real \\<^bold>E (x, x))))\n  \\<le> ennreal (\\<alpha>' / 2 ^ i)\n  (\\<Sum>\\<^sup>+ x.\n     ennreal\n      (norm\n        ((k_i' i (x, x) - k_i' i (x, x)) * indicat_real \\<^bold>E (x, x))))\n  \\<le> ennreal (\\<alpha>' / 2 ^ i)\n  \\<alpha> = ennreal \\<alpha>'\n\ngoal (1 subgoal):\n 1. integrable (count_space UNIV)\n     (\\<lambda>y.\n         (k_i' i (x, y) - k_i' i (y, x)) *\n         indicat_real \\<^bold>E (x, y)) &&&\n    integrable (count_space UNIV)\n     (\\<lambda>y.\n         (k_i' i (y, x) - k_i' i (x, y)) * indicat_real \\<^bold>E (y, x))", "by(auto intro!: integrableI_bounded simp: less_top[symmetric] top_unique ennreal_divide_eq_top_iff)"], ["proof (state)\nthis:\n  integrable (count_space UNIV)\n   (\\<lambda>y.\n       (k_i' ?i (x, y) - k_i' ?i (y, x)) * indicat_real \\<^bold>E (x, y))\n  integrable (count_space UNIV)\n   (\\<lambda>y.\n       (k_i' ?i (y, x) - k_i' ?i (x, y)) * indicat_real \\<^bold>E (y, x))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>;\n        x \\<noteq> sink \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> KIR (\\<lambda>x. ennreal (f' x)) x", "have summable'_k: \"summable (\\<lambda>i. \\<integral> y. \\<bar>?k i x y\\<bar> \\<partial>count_space UNIV)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. summable\n     (\\<lambda>i.\n         LINT y|count_space UNIV.\n            \\<bar>(k_i' i (x, y) - k_i' i (y, x)) *\n                  indicat_real \\<^bold>E (x, y)\\<bar>)", "proof(rule summable_comparison_test)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>N.\n       \\<forall>n\\<ge>N.\n          norm\n           (LINT y|count_space UNIV.\n               \\<bar>(k_i' n (x, y) - k_i' n (y, x)) *\n                     indicat_real \\<^bold>E (x, y)\\<bar>)\n          \\<le> ?g n\n 2. summable ?g", "have \"\\<bar>\\<integral> y. \\<bar>?k i x y\\<bar> \\<partial>count_space UNIV\\<bar> \\<le> \\<alpha>' * (1 / 2) ^ i\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>LINT y|count_space UNIV.\n             \\<bar>(k_i' i (x, y) - k_i' i (y, x)) *\n                   indicat_real \\<^bold>E (x, y)\\<bar>\\<bar>\n    \\<le> \\<alpha>' * (1 / 2) ^ i", "using integral_norm_bound_ennreal[OF integrable_norm, OF integrable_k, of i] integral_k_bounded[of i]"], ["proof (prove)\nusing this:\n  ennreal\n   (norm\n     (LINT x|count_space UNIV.\n         norm\n          ((k_i' i (x, x) - k_i' i (x, x)) *\n           indicat_real \\<^bold>E (x, x))))\n  \\<le> (\\<Sum>\\<^sup>+ x.\n           ennreal\n            (norm\n              (norm\n                ((k_i' i (x, x) - k_i' i (x, x)) *\n                 indicat_real \\<^bold>E (x, x)))))\n  (\\<Sum>\\<^sup>+ x.\n     ennreal\n      (norm\n        ((k_i' i (x, x) - k_i' i (x, x)) * indicat_real \\<^bold>E (x, x))))\n  \\<le> ennreal (\\<alpha>' / 2 ^ i)\n\ngoal (1 subgoal):\n 1. \\<bar>LINT y|count_space UNIV.\n             \\<bar>(k_i' i (x, y) - k_i' i (y, x)) *\n                   indicat_real \\<^bold>E (x, y)\\<bar>\\<bar>\n    \\<le> \\<alpha>' * (1 / 2) ^ i", "by(bestsimp simp add: real power_divide dest: order_trans)"], ["proof (state)\nthis:\n  \\<bar>LINT y|count_space UNIV.\n           \\<bar>(k_i' ?i (x, y) - k_i' ?i (y, x)) *\n                 indicat_real \\<^bold>E (x, y)\\<bar>\\<bar>\n  \\<le> \\<alpha>' * (1 / 2) ^ ?i\n\ngoal (2 subgoals):\n 1. \\<exists>N.\n       \\<forall>n\\<ge>N.\n          norm\n           (LINT y|count_space UNIV.\n               \\<bar>(k_i' n (x, y) - k_i' n (y, x)) *\n                     indicat_real \\<^bold>E (x, y)\\<bar>)\n          \\<le> ?g n\n 2. summable ?g", "thus \"\\<exists>N. \\<forall>i\\<ge>N. norm (\\<integral> y. \\<bar>?k i x y\\<bar> \\<partial>count_space UNIV) \\<le> \\<alpha>' * (1 / 2) ^ i\""], ["proof (prove)\nusing this:\n  \\<bar>LINT y|count_space UNIV.\n           \\<bar>(k_i' ?i (x, y) - k_i' ?i (y, x)) *\n                 indicat_real \\<^bold>E (x, y)\\<bar>\\<bar>\n  \\<le> \\<alpha>' * (1 / 2) ^ ?i\n\ngoal (1 subgoal):\n 1. \\<exists>N.\n       \\<forall>i\\<ge>N.\n          norm\n           (LINT y|count_space UNIV.\n               \\<bar>(k_i' i (x, y) - k_i' i (y, x)) *\n                     indicat_real \\<^bold>E (x, y)\\<bar>)\n          \\<le> \\<alpha>' * (1 / 2) ^ i", "by auto"], ["proof (state)\nthis:\n  \\<exists>N.\n     \\<forall>i\\<ge>N.\n        norm\n         (LINT y|count_space UNIV.\n             \\<bar>(k_i' i (x, y) - k_i' i (y, x)) *\n                   indicat_real \\<^bold>E (x, y)\\<bar>)\n        \\<le> \\<alpha>' * (1 / 2) ^ i\n\ngoal (1 subgoal):\n 1. summable (\\<lambda>i. \\<alpha>' * (1 / 2) ^ i)", "show \"summable (\\<lambda>i. \\<alpha>' * (1 / 2) ^ i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. summable (\\<lambda>i. \\<alpha>' * (1 / 2) ^ i)", "by(rule summable_mult complete_algebra_summable_geometric)+ simp"], ["proof (state)\nthis:\n  summable (\\<lambda>i. \\<alpha>' * (1 / 2) ^ i)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  summable\n   (\\<lambda>i.\n       LINT y|count_space UNIV.\n          \\<bar>(k_i' i (x, y) - k_i' i (y, x)) *\n                indicat_real \\<^bold>E (x, y)\\<bar>)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>;\n        x \\<noteq> sink \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> KIR (\\<lambda>x. ennreal (f' x)) x", "have summable'_k': \"summable (\\<lambda>i. \\<integral> y. \\<bar>?k i y x\\<bar> \\<partial>count_space UNIV)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. summable\n     (\\<lambda>i.\n         LINT y|count_space UNIV.\n            \\<bar>(k_i' i (y, x) - k_i' i (x, y)) *\n                  indicat_real \\<^bold>E (y, x)\\<bar>)", "proof(rule summable_comparison_test)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>N.\n       \\<forall>n\\<ge>N.\n          norm\n           (LINT y|count_space UNIV.\n               \\<bar>(k_i' n (y, x) - k_i' n (x, y)) *\n                     indicat_real \\<^bold>E (y, x)\\<bar>)\n          \\<le> ?g n\n 2. summable ?g", "have \"\\<bar>\\<integral> y. \\<bar>?k i y x\\<bar> \\<partial>count_space UNIV\\<bar> \\<le> \\<alpha>' * (1 / 2) ^ i\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>LINT y|count_space UNIV.\n             \\<bar>(k_i' i (y, x) - k_i' i (x, y)) *\n                   indicat_real \\<^bold>E (y, x)\\<bar>\\<bar>\n    \\<le> \\<alpha>' * (1 / 2) ^ i", "using integral_norm_bound_ennreal[OF integrable_norm, OF integrable_k', of i] integral_k'_bounded[of i]"], ["proof (prove)\nusing this:\n  ennreal\n   (norm\n     (LINT x|count_space UNIV.\n         norm\n          ((k_i' i (x, x) - k_i' i (x, x)) *\n           indicat_real \\<^bold>E (x, x))))\n  \\<le> (\\<Sum>\\<^sup>+ x.\n           ennreal\n            (norm\n              (norm\n                ((k_i' i (x, x) - k_i' i (x, x)) *\n                 indicat_real \\<^bold>E (x, x)))))\n  (\\<Sum>\\<^sup>+ x.\n     ennreal\n      (norm\n        ((k_i' i (x, x) - k_i' i (x, x)) * indicat_real \\<^bold>E (x, x))))\n  \\<le> ennreal (\\<alpha>' / 2 ^ i)\n\ngoal (1 subgoal):\n 1. \\<bar>LINT y|count_space UNIV.\n             \\<bar>(k_i' i (y, x) - k_i' i (x, y)) *\n                   indicat_real \\<^bold>E (y, x)\\<bar>\\<bar>\n    \\<le> \\<alpha>' * (1 / 2) ^ i", "by(bestsimp simp add: real power_divide dest: order_trans)"], ["proof (state)\nthis:\n  \\<bar>LINT y|count_space UNIV.\n           \\<bar>(k_i' ?i (y, x) - k_i' ?i (x, y)) *\n                 indicat_real \\<^bold>E (y, x)\\<bar>\\<bar>\n  \\<le> \\<alpha>' * (1 / 2) ^ ?i\n\ngoal (2 subgoals):\n 1. \\<exists>N.\n       \\<forall>n\\<ge>N.\n          norm\n           (LINT y|count_space UNIV.\n               \\<bar>(k_i' n (y, x) - k_i' n (x, y)) *\n                     indicat_real \\<^bold>E (y, x)\\<bar>)\n          \\<le> ?g n\n 2. summable ?g", "thus \"\\<exists>N. \\<forall>i\\<ge>N. norm (\\<integral> y. \\<bar>?k i y x\\<bar> \\<partial>count_space UNIV) \\<le> \\<alpha>' * (1 / 2) ^ i\""], ["proof (prove)\nusing this:\n  \\<bar>LINT y|count_space UNIV.\n           \\<bar>(k_i' ?i (y, x) - k_i' ?i (x, y)) *\n                 indicat_real \\<^bold>E (y, x)\\<bar>\\<bar>\n  \\<le> \\<alpha>' * (1 / 2) ^ ?i\n\ngoal (1 subgoal):\n 1. \\<exists>N.\n       \\<forall>i\\<ge>N.\n          norm\n           (LINT y|count_space UNIV.\n               \\<bar>(k_i' i (y, x) - k_i' i (x, y)) *\n                     indicat_real \\<^bold>E (y, x)\\<bar>)\n          \\<le> \\<alpha>' * (1 / 2) ^ i", "by auto"], ["proof (state)\nthis:\n  \\<exists>N.\n     \\<forall>i\\<ge>N.\n        norm\n         (LINT y|count_space UNIV.\n             \\<bar>(k_i' i (y, x) - k_i' i (x, y)) *\n                   indicat_real \\<^bold>E (y, x)\\<bar>)\n        \\<le> \\<alpha>' * (1 / 2) ^ i\n\ngoal (1 subgoal):\n 1. summable (\\<lambda>i. \\<alpha>' * (1 / 2) ^ i)", "show \"summable (\\<lambda>i. \\<alpha>' * (1 / 2) ^ i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. summable (\\<lambda>i. \\<alpha>' * (1 / 2) ^ i)", "by(rule summable_mult complete_algebra_summable_geometric)+ simp"], ["proof (state)\nthis:\n  summable (\\<lambda>i. \\<alpha>' * (1 / 2) ^ i)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  summable\n   (\\<lambda>i.\n       LINT y|count_space UNIV.\n          \\<bar>(k_i' i (y, x) - k_i' i (x, y)) *\n                indicat_real \\<^bold>E (y, x)\\<bar>)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>;\n        x \\<noteq> sink \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> KIR (\\<lambda>x. ennreal (f' x)) x", "have \"(\\<lambda>i. \\<integral> y. ?k i x y \\<partial>count_space UNIV) sums \\<integral> y. (\\<Sum>i. ?k i x y) \\<partial>count_space UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>i.\n        LINT y|count_space UNIV.\n           (k_i' i (x, y) - k_i' i (y, x)) *\n           indicat_real \\<^bold>E (x, y)) sums\n    (LINT y|count_space UNIV.\n        (\\<Sum>i.\n            (k_i' i (x, y) - k_i' i (y, x)) *\n            indicat_real \\<^bold>E (x, y)))", "using integrable_k"], ["proof (prove)\nusing this:\n  integrable (count_space UNIV)\n   (\\<lambda>y.\n       (k_i' ?i (x, y) - k_i' ?i (y, x)) * indicat_real \\<^bold>E (x, y))\n\ngoal (1 subgoal):\n 1. (\\<lambda>i.\n        LINT y|count_space UNIV.\n           (k_i' i (x, y) - k_i' i (y, x)) *\n           indicat_real \\<^bold>E (x, y)) sums\n    (LINT y|count_space UNIV.\n        (\\<Sum>i.\n            (k_i' i (x, y) - k_i' i (y, x)) *\n            indicat_real \\<^bold>E (x, y)))", "by(rule sums_integral)(simp_all add: summable_nk summable'_k)"], ["proof (state)\nthis:\n  (\\<lambda>i.\n      LINT y|count_space UNIV.\n         (k_i' i (x, y) - k_i' i (y, x)) *\n         indicat_real \\<^bold>E (x, y)) sums\n  (LINT y|count_space UNIV.\n      (\\<Sum>i.\n          (k_i' i (x, y) - k_i' i (y, x)) * indicat_real \\<^bold>E (x, y)))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>;\n        x \\<noteq> sink \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> KIR (\\<lambda>x. ennreal (f' x)) x", "also"], ["proof (state)\nthis:\n  (\\<lambda>i.\n      LINT y|count_space UNIV.\n         (k_i' i (x, y) - k_i' i (y, x)) *\n         indicat_real \\<^bold>E (x, y)) sums\n  (LINT y|count_space UNIV.\n      (\\<Sum>i.\n          (k_i' i (x, y) - k_i' i (y, x)) * indicat_real \\<^bold>E (x, y)))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>;\n        x \\<noteq> sink \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> KIR (\\<lambda>x. ennreal (f' x)) x", "have \"\\<dots> = \\<integral> y. f' (x, y) \\<partial>count_space UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LINT y|count_space UNIV.\n       (\\<Sum>i.\n           (k_i' i (x, y) - k_i' i (y, x)) *\n           indicat_real \\<^bold>E (x, y)) =\n    LINT y|count_space UNIV. f' (x, y)", "by(rule Bochner_Integration.integral_cong[OF refl])(rule suminf)"], ["proof (state)\nthis:\n  LINT y|count_space UNIV.\n     (\\<Sum>i.\n         (k_i' i (x, y) - k_i' i (y, x)) * indicat_real \\<^bold>E (x, y)) =\n  LINT y|count_space UNIV. f' (x, y)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>;\n        x \\<noteq> sink \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> KIR (\\<lambda>x. ennreal (f' x)) x", "finally"], ["proof (chain)\npicking this:\n  (\\<lambda>i.\n      LINT y|count_space UNIV.\n         (k_i' i (x, y) - k_i' i (y, x)) *\n         indicat_real \\<^bold>E (x, y)) sums\n  (LINT y|count_space UNIV. f' (x, y))", "have \"(\\<lambda>i. \\<Sum>j<i. \\<integral> y. ?k j x y \\<partial>count_space UNIV) \\<longlonglongrightarrow> \\<dots>\""], ["proof (prove)\nusing this:\n  (\\<lambda>i.\n      LINT y|count_space UNIV.\n         (k_i' i (x, y) - k_i' i (y, x)) *\n         indicat_real \\<^bold>E (x, y)) sums\n  (LINT y|count_space UNIV. f' (x, y))\n\ngoal (1 subgoal):\n 1. (\\<lambda>i.\n        \\<Sum>j<i.\n           LINT y|count_space UNIV.\n              (k_i' j (x, y) - k_i' j (y, x)) *\n              indicat_real \\<^bold>E (x, y))\n    \\<longlonglongrightarrow> LINT y|count_space UNIV. f' (x, y)", "unfolding sums_def"], ["proof (prove)\nusing this:\n  (\\<lambda>n.\n      \\<Sum>i<n.\n         LINT y|count_space UNIV.\n            (k_i' i (x, y) - k_i' i (y, x)) * indicat_real \\<^bold>E (x, y))\n  \\<longlonglongrightarrow> LINT y|count_space UNIV. f' (x, y)\n\ngoal (1 subgoal):\n 1. (\\<lambda>i.\n        \\<Sum>j<i.\n           LINT y|count_space UNIV.\n              (k_i' j (x, y) - k_i' j (y, x)) *\n              indicat_real \\<^bold>E (x, y))\n    \\<longlonglongrightarrow> LINT y|count_space UNIV. f' (x, y)", "."], ["proof (state)\nthis:\n  (\\<lambda>i.\n      \\<Sum>j<i.\n         LINT y|count_space UNIV.\n            (k_i' j (x, y) - k_i' j (y, x)) * indicat_real \\<^bold>E (x, y))\n  \\<longlonglongrightarrow> LINT y|count_space UNIV. f' (x, y)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>;\n        x \\<noteq> sink \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> KIR (\\<lambda>x. ennreal (f' x)) x", "also"], ["proof (state)\nthis:\n  (\\<lambda>i.\n      \\<Sum>j<i.\n         LINT y|count_space UNIV.\n            (k_i' j (x, y) - k_i' j (y, x)) * indicat_real \\<^bold>E (x, y))\n  \\<longlonglongrightarrow> LINT y|count_space UNIV. f' (x, y)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>;\n        x \\<noteq> sink \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> KIR (\\<lambda>x. ennreal (f' x)) x", "have \"(\\<lambda>i. \\<Sum>j<i. \\<integral> y. ?k j x y \\<partial>count_space UNIV) = (\\<lambda>i. \\<integral> y. f_i' i (x, y) \\<partial>count_space UNIV)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>i.\n        \\<Sum>j<i.\n           LINT y|count_space UNIV.\n              (k_i' j (x, y) - k_i' j (y, x)) *\n              indicat_real \\<^bold>E (x, y)) =\n    (\\<lambda>i. LINT y|count_space UNIV. f_i' i (x, y))", "unfolding sum_i'"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>i.\n        \\<Sum>j<i.\n           LINT y|count_space UNIV.\n              (k_i' j (x, y) - k_i' j (y, x)) *\n              indicat_real \\<^bold>E (x, y)) =\n    (\\<lambda>i.\n        LINT y|count_space UNIV.\n           (\\<Sum>j<i.\n               (k_i' j (x, y) - k_i' j (y, x)) *\n               indicat_real \\<^bold>E (x, y)))", "by(rule ext Bochner_Integration.integral_sum[symmetric] integrable_k)+"], ["proof (state)\nthis:\n  (\\<lambda>i.\n      \\<Sum>j<i.\n         LINT y|count_space UNIV.\n            (k_i' j (x, y) - k_i' j (y, x)) *\n            indicat_real \\<^bold>E (x, y)) =\n  (\\<lambda>i. LINT y|count_space UNIV. f_i' i (x, y))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>;\n        x \\<noteq> sink \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> KIR (\\<lambda>x. ennreal (f' x)) x", "finally"], ["proof (chain)\npicking this:\n  (\\<lambda>i. LINT y|count_space UNIV. f_i' i (x, y))\n  \\<longlonglongrightarrow> LINT y|count_space UNIV. f' (x, y)", "have \"(\\<lambda>i. ennreal (\\<integral> y. f_i' i (x, y) \\<partial>count_space UNIV)) \\<longlonglongrightarrow> ennreal (\\<integral> y. f' (x, y) \\<partial>count_space UNIV)\""], ["proof (prove)\nusing this:\n  (\\<lambda>i. LINT y|count_space UNIV. f_i' i (x, y))\n  \\<longlonglongrightarrow> LINT y|count_space UNIV. f' (x, y)\n\ngoal (1 subgoal):\n 1. (\\<lambda>i. ennreal (LINT y|count_space UNIV. f_i' i (x, y)))\n    \\<longlonglongrightarrow> ennreal (LINT y|count_space UNIV. f' (x, y))", "by simp"], ["proof (state)\nthis:\n  (\\<lambda>i. ennreal (LINT y|count_space UNIV. f_i' i (x, y)))\n  \\<longlonglongrightarrow> ennreal (LINT y|count_space UNIV. f' (x, y))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>;\n        x \\<noteq> sink \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> KIR (\\<lambda>x. ennreal (f' x)) x", "also"], ["proof (state)\nthis:\n  (\\<lambda>i. ennreal (LINT y|count_space UNIV. f_i' i (x, y)))\n  \\<longlonglongrightarrow> ennreal (LINT y|count_space UNIV. f' (x, y))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>;\n        x \\<noteq> sink \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> KIR (\\<lambda>x. ennreal (f' x)) x", "have \"(\\<lambda>i. ennreal (\\<integral> y. f_i' i (x, y) \\<partial>count_space UNIV)) = (\\<lambda>i. d_OUT (f_i i) x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>i. ennreal (LINT y|count_space UNIV. f_i' i (x, y))) =\n    (\\<lambda>i. d_OUT (f_i i) x)", "unfolding d_OUT_def f_i'"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>i. ennreal (LINT y|count_space UNIV. f_i' i (x, y))) =\n    (\\<lambda>i. \\<Sum>\\<^sup>+ y. ennreal (f_i' i (x, y)))", "by(rule ext nn_integral_eq_integral[symmetric] integrable_f_i)+ simp"], ["proof (state)\nthis:\n  (\\<lambda>i. ennreal (LINT y|count_space UNIV. f_i' i (x, y))) =\n  (\\<lambda>i. d_OUT (f_i i) x)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>;\n        x \\<noteq> sink \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> KIR (\\<lambda>x. ennreal (f' x)) x", "also"], ["proof (state)\nthis:\n  (\\<lambda>i. ennreal (LINT y|count_space UNIV. f_i' i (x, y))) =\n  (\\<lambda>i. d_OUT (f_i i) x)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>;\n        x \\<noteq> sink \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> KIR (\\<lambda>x. ennreal (f' x)) x", "have \"ennreal (\\<integral> y. f' (x, y) \\<partial>count_space UNIV) = d_OUT f' x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ennreal (LINT y|count_space UNIV. f' (x, y)) =\n    d_OUT (\\<lambda>x. ennreal (f' x)) x", "unfolding d_OUT_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ennreal (LINT y|count_space UNIV. f' (x, y)) =\n    (\\<Sum>\\<^sup>+ y. ennreal (f' (x, y)))", "by(rule nn_integral_eq_integral[symmetric])(simp_all add: f'_nonneg, simp add: suminf[symmetric] integrable_suminf integrable_k summable_nk summable'_k)"], ["proof (state)\nthis:\n  ennreal (LINT y|count_space UNIV. f' (x, y)) =\n  d_OUT (\\<lambda>x. ennreal (f' x)) x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>;\n        x \\<noteq> sink \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> KIR (\\<lambda>x. ennreal (f' x)) x", "also"], ["proof (state)\nthis:\n  ennreal (LINT y|count_space UNIV. f' (x, y)) =\n  d_OUT (\\<lambda>x. ennreal (f' x)) x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>;\n        x \\<noteq> sink \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> KIR (\\<lambda>x. ennreal (f' x)) x", "have \"(\\<lambda>i. d_OUT (f_i i) x) = (\\<lambda>i. d_IN (f_i i) x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>i. d_OUT (f_i i) x) = (\\<lambda>i. d_IN (f_i i) x)", "using flowD_KIR[OF fn.g x]"], ["proof (prove)\nusing this:\n  KIR (f_i ?i1) x\n\ngoal (1 subgoal):\n 1. (\\<lambda>i. d_OUT (f_i i) x) = (\\<lambda>i. d_IN (f_i i) x)", "by(simp)"], ["proof (state)\nthis:\n  (\\<lambda>i. d_OUT (f_i i) x) = (\\<lambda>i. d_IN (f_i i) x)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>;\n        x \\<noteq> sink \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> KIR (\\<lambda>x. ennreal (f' x)) x", "finally"], ["proof (chain)\npicking this:\n  (\\<lambda>i. d_IN (f_i i) x)\n  \\<longlonglongrightarrow> d_OUT (\\<lambda>x. ennreal (f' x)) x", "have *: \"(\\<lambda>i. d_IN (f_i i) x) \\<longlonglongrightarrow> d_OUT (\\<lambda>x. ennreal (f' x)) x\""], ["proof (prove)\nusing this:\n  (\\<lambda>i. d_IN (f_i i) x)\n  \\<longlonglongrightarrow> d_OUT (\\<lambda>x. ennreal (f' x)) x\n\ngoal (1 subgoal):\n 1. (\\<lambda>i. d_IN (f_i i) x)\n    \\<longlonglongrightarrow> d_OUT (\\<lambda>x. ennreal (f' x)) x", "."], ["proof (state)\nthis:\n  (\\<lambda>i. d_IN (f_i i) x)\n  \\<longlonglongrightarrow> d_OUT (\\<lambda>x. ennreal (f' x)) x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>;\n        x \\<noteq> sink \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> KIR (\\<lambda>x. ennreal (f' x)) x", "have \"(\\<lambda>i. \\<integral> y. ?k i y x \\<partial>count_space UNIV) sums \\<integral> y. (\\<Sum>i. ?k i y x) \\<partial>count_space UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>i.\n        LINT y|count_space UNIV.\n           (k_i' i (y, x) - k_i' i (x, y)) *\n           indicat_real \\<^bold>E (y, x)) sums\n    (LINT y|count_space UNIV.\n        (\\<Sum>i.\n            (k_i' i (y, x) - k_i' i (x, y)) *\n            indicat_real \\<^bold>E (y, x)))", "using integrable_k'"], ["proof (prove)\nusing this:\n  integrable (count_space UNIV)\n   (\\<lambda>y.\n       (k_i' ?i (y, x) - k_i' ?i (x, y)) * indicat_real \\<^bold>E (y, x))\n\ngoal (1 subgoal):\n 1. (\\<lambda>i.\n        LINT y|count_space UNIV.\n           (k_i' i (y, x) - k_i' i (x, y)) *\n           indicat_real \\<^bold>E (y, x)) sums\n    (LINT y|count_space UNIV.\n        (\\<Sum>i.\n            (k_i' i (y, x) - k_i' i (x, y)) *\n            indicat_real \\<^bold>E (y, x)))", "by(rule sums_integral)(simp_all add: summable_nk summable'_k')"], ["proof (state)\nthis:\n  (\\<lambda>i.\n      LINT y|count_space UNIV.\n         (k_i' i (y, x) - k_i' i (x, y)) *\n         indicat_real \\<^bold>E (y, x)) sums\n  (LINT y|count_space UNIV.\n      (\\<Sum>i.\n          (k_i' i (y, x) - k_i' i (x, y)) * indicat_real \\<^bold>E (y, x)))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>;\n        x \\<noteq> sink \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> KIR (\\<lambda>x. ennreal (f' x)) x", "also"], ["proof (state)\nthis:\n  (\\<lambda>i.\n      LINT y|count_space UNIV.\n         (k_i' i (y, x) - k_i' i (x, y)) *\n         indicat_real \\<^bold>E (y, x)) sums\n  (LINT y|count_space UNIV.\n      (\\<Sum>i.\n          (k_i' i (y, x) - k_i' i (x, y)) * indicat_real \\<^bold>E (y, x)))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>;\n        x \\<noteq> sink \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> KIR (\\<lambda>x. ennreal (f' x)) x", "have \"\\<dots> = \\<integral> y. f' (y, x) \\<partial>count_space UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LINT y|count_space UNIV.\n       (\\<Sum>i.\n           (k_i' i (y, x) - k_i' i (x, y)) *\n           indicat_real \\<^bold>E (y, x)) =\n    LINT y|count_space UNIV. f' (y, x)", "by(rule Bochner_Integration.integral_cong[OF refl])(rule suminf)"], ["proof (state)\nthis:\n  LINT y|count_space UNIV.\n     (\\<Sum>i.\n         (k_i' i (y, x) - k_i' i (x, y)) * indicat_real \\<^bold>E (y, x)) =\n  LINT y|count_space UNIV. f' (y, x)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>;\n        x \\<noteq> sink \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> KIR (\\<lambda>x. ennreal (f' x)) x", "finally"], ["proof (chain)\npicking this:\n  (\\<lambda>i.\n      LINT y|count_space UNIV.\n         (k_i' i (y, x) - k_i' i (x, y)) *\n         indicat_real \\<^bold>E (y, x)) sums\n  (LINT y|count_space UNIV. f' (y, x))", "have \"(\\<lambda>i. \\<Sum>j<i. \\<integral> y. ?k j y x \\<partial>count_space UNIV) \\<longlonglongrightarrow> \\<dots>\""], ["proof (prove)\nusing this:\n  (\\<lambda>i.\n      LINT y|count_space UNIV.\n         (k_i' i (y, x) - k_i' i (x, y)) *\n         indicat_real \\<^bold>E (y, x)) sums\n  (LINT y|count_space UNIV. f' (y, x))\n\ngoal (1 subgoal):\n 1. (\\<lambda>i.\n        \\<Sum>j<i.\n           LINT y|count_space UNIV.\n              (k_i' j (y, x) - k_i' j (x, y)) *\n              indicat_real \\<^bold>E (y, x))\n    \\<longlonglongrightarrow> LINT y|count_space UNIV. f' (y, x)", "unfolding sums_def"], ["proof (prove)\nusing this:\n  (\\<lambda>n.\n      \\<Sum>i<n.\n         LINT y|count_space UNIV.\n            (k_i' i (y, x) - k_i' i (x, y)) * indicat_real \\<^bold>E (y, x))\n  \\<longlonglongrightarrow> LINT y|count_space UNIV. f' (y, x)\n\ngoal (1 subgoal):\n 1. (\\<lambda>i.\n        \\<Sum>j<i.\n           LINT y|count_space UNIV.\n              (k_i' j (y, x) - k_i' j (x, y)) *\n              indicat_real \\<^bold>E (y, x))\n    \\<longlonglongrightarrow> LINT y|count_space UNIV. f' (y, x)", "."], ["proof (state)\nthis:\n  (\\<lambda>i.\n      \\<Sum>j<i.\n         LINT y|count_space UNIV.\n            (k_i' j (y, x) - k_i' j (x, y)) * indicat_real \\<^bold>E (y, x))\n  \\<longlonglongrightarrow> LINT y|count_space UNIV. f' (y, x)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>;\n        x \\<noteq> sink \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> KIR (\\<lambda>x. ennreal (f' x)) x", "also"], ["proof (state)\nthis:\n  (\\<lambda>i.\n      \\<Sum>j<i.\n         LINT y|count_space UNIV.\n            (k_i' j (y, x) - k_i' j (x, y)) * indicat_real \\<^bold>E (y, x))\n  \\<longlonglongrightarrow> LINT y|count_space UNIV. f' (y, x)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>;\n        x \\<noteq> sink \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> KIR (\\<lambda>x. ennreal (f' x)) x", "have \"(\\<lambda>i. \\<Sum>j<i. \\<integral> y. ?k j y x \\<partial>count_space UNIV) = (\\<lambda>i. \\<integral> y. f_i' i (y, x) \\<partial>count_space UNIV)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>i.\n        \\<Sum>j<i.\n           LINT y|count_space UNIV.\n              (k_i' j (y, x) - k_i' j (x, y)) *\n              indicat_real \\<^bold>E (y, x)) =\n    (\\<lambda>i. LINT y|count_space UNIV. f_i' i (y, x))", "unfolding sum_i'"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>i.\n        \\<Sum>j<i.\n           LINT y|count_space UNIV.\n              (k_i' j (y, x) - k_i' j (x, y)) *\n              indicat_real \\<^bold>E (y, x)) =\n    (\\<lambda>i.\n        LINT y|count_space UNIV.\n           (\\<Sum>j<i.\n               (k_i' j (y, x) - k_i' j (x, y)) *\n               indicat_real \\<^bold>E (y, x)))", "by(rule ext Bochner_Integration.integral_sum[symmetric] integrable_k')+"], ["proof (state)\nthis:\n  (\\<lambda>i.\n      \\<Sum>j<i.\n         LINT y|count_space UNIV.\n            (k_i' j (y, x) - k_i' j (x, y)) *\n            indicat_real \\<^bold>E (y, x)) =\n  (\\<lambda>i. LINT y|count_space UNIV. f_i' i (y, x))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>;\n        x \\<noteq> sink \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> KIR (\\<lambda>x. ennreal (f' x)) x", "finally"], ["proof (chain)\npicking this:\n  (\\<lambda>i. LINT y|count_space UNIV. f_i' i (y, x))\n  \\<longlonglongrightarrow> LINT y|count_space UNIV. f' (y, x)", "have \"(\\<lambda>i. ennreal (\\<integral> y. f_i' i (y, x) \\<partial>count_space UNIV)) \\<longlonglongrightarrow> ennreal (\\<integral> y. f' (y, x) \\<partial>count_space UNIV)\""], ["proof (prove)\nusing this:\n  (\\<lambda>i. LINT y|count_space UNIV. f_i' i (y, x))\n  \\<longlonglongrightarrow> LINT y|count_space UNIV. f' (y, x)\n\ngoal (1 subgoal):\n 1. (\\<lambda>i. ennreal (LINT y|count_space UNIV. f_i' i (y, x)))\n    \\<longlonglongrightarrow> ennreal (LINT y|count_space UNIV. f' (y, x))", "by simp"], ["proof (state)\nthis:\n  (\\<lambda>i. ennreal (LINT y|count_space UNIV. f_i' i (y, x)))\n  \\<longlonglongrightarrow> ennreal (LINT y|count_space UNIV. f' (y, x))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>;\n        x \\<noteq> sink \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> KIR (\\<lambda>x. ennreal (f' x)) x", "also"], ["proof (state)\nthis:\n  (\\<lambda>i. ennreal (LINT y|count_space UNIV. f_i' i (y, x)))\n  \\<longlonglongrightarrow> ennreal (LINT y|count_space UNIV. f' (y, x))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>;\n        x \\<noteq> sink \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> KIR (\\<lambda>x. ennreal (f' x)) x", "have \"(\\<lambda>i. ennreal (\\<integral> y. f_i' i (y, x) \\<partial>count_space UNIV)) = (\\<lambda>i. d_IN (f_i i) x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>i. ennreal (LINT y|count_space UNIV. f_i' i (y, x))) =\n    (\\<lambda>i. d_IN (f_i i) x)", "unfolding d_IN_def f_i'"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>i. ennreal (LINT y|count_space UNIV. f_i' i (y, x))) =\n    (\\<lambda>i. \\<Sum>\\<^sup>+ x. ennreal (f_i' i (x, x)))", "by(rule ext nn_integral_eq_integral[symmetric] integrable_f_i')+ simp"], ["proof (state)\nthis:\n  (\\<lambda>i. ennreal (LINT y|count_space UNIV. f_i' i (y, x))) =\n  (\\<lambda>i. d_IN (f_i i) x)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>;\n        x \\<noteq> sink \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> KIR (\\<lambda>x. ennreal (f' x)) x", "also"], ["proof (state)\nthis:\n  (\\<lambda>i. ennreal (LINT y|count_space UNIV. f_i' i (y, x))) =\n  (\\<lambda>i. d_IN (f_i i) x)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>;\n        x \\<noteq> sink \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> KIR (\\<lambda>x. ennreal (f' x)) x", "have \"ennreal (\\<integral> y. f' (y, x) \\<partial>count_space UNIV) = d_IN f' x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ennreal (LINT y|count_space UNIV. f' (y, x)) =\n    d_IN (\\<lambda>x. ennreal (f' x)) x", "unfolding d_IN_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ennreal (LINT y|count_space UNIV. f' (y, x)) =\n    (\\<Sum>\\<^sup>+ x. ennreal (f' (x, x)))", "by(rule nn_integral_eq_integral[symmetric])(simp_all add: f'_nonneg, simp add: suminf[symmetric] integrable_suminf integrable_k' summable_nk summable'_k')"], ["proof (state)\nthis:\n  ennreal (LINT y|count_space UNIV. f' (y, x)) =\n  d_IN (\\<lambda>x. ennreal (f' x)) x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>;\n        x \\<noteq> sink \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> KIR (\\<lambda>x. ennreal (f' x)) x", "finally"], ["proof (chain)\npicking this:\n  (\\<lambda>i. d_IN (f_i i) x)\n  \\<longlonglongrightarrow> d_IN (\\<lambda>x. ennreal (f' x)) x", "show \"d_OUT f' x = d_IN f' x\""], ["proof (prove)\nusing this:\n  (\\<lambda>i. d_IN (f_i i) x)\n  \\<longlonglongrightarrow> d_IN (\\<lambda>x. ennreal (f' x)) x\n\ngoal (1 subgoal):\n 1. KIR (\\<lambda>x. ennreal (f' x)) x", "using *"], ["proof (prove)\nusing this:\n  (\\<lambda>i. d_IN (f_i i) x)\n  \\<longlonglongrightarrow> d_IN (\\<lambda>x. ennreal (f' x)) x\n  (\\<lambda>i. d_IN (f_i i) x)\n  \\<longlonglongrightarrow> d_OUT (\\<lambda>x. ennreal (f' x)) x\n\ngoal (1 subgoal):\n 1. KIR (\\<lambda>x. ennreal (f' x)) x", "by(blast intro: LIMSEQ_unique)"], ["proof (state)\nthis:\n  KIR (\\<lambda>x. ennreal (f' x)) x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  flow \\<Delta> (\\<lambda>x. ennreal (f' x))\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       flow \\<Delta> f \\<and>\n       value_flow \\<Delta> f = \\<alpha> \\<and>\n       (\\<forall>x. d_IN f x \\<le> value_flow \\<Delta> f)", "moreover"], ["proof (state)\nthis:\n  flow \\<Delta> (\\<lambda>x. ennreal (f' x))\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       flow \\<Delta> f \\<and>\n       value_flow \\<Delta> f = \\<alpha> \\<and>\n       (\\<forall>x. d_IN f x \\<le> value_flow \\<Delta> f)", "{"], ["proof (state)\nthis:\n  flow \\<Delta> (\\<lambda>x. ennreal (f' x))\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       flow \\<Delta> f \\<and>\n       value_flow \\<Delta> f = \\<alpha> \\<and>\n       (\\<forall>x. d_IN f x \\<le> value_flow \\<Delta> f)", "have \"incseq (\\<lambda>i. value_flow \\<Delta> (f_i i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. incseq (\\<lambda>i. value_flow \\<Delta> (f_i i))", "by(rule incseq_SucI)(simp add: value_aux value_f_i real field_simps \\<alpha>'_nonneg ennreal_leI del: f_i_simps)"], ["proof (state)\nthis:\n  incseq (\\<lambda>i. value_flow \\<Delta> (f_i i))\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       flow \\<Delta> f \\<and>\n       value_flow \\<Delta> f = \\<alpha> \\<and>\n       (\\<forall>x. d_IN f x \\<le> value_flow \\<Delta> f)", "then"], ["proof (chain)\npicking this:\n  incseq (\\<lambda>i. value_flow \\<Delta> (f_i i))", "have \"(\\<lambda>i. value_flow \\<Delta> (f_i i)) \\<longlonglongrightarrow> (SUP i. value_flow \\<Delta> (f_i i))\""], ["proof (prove)\nusing this:\n  incseq (\\<lambda>i. value_flow \\<Delta> (f_i i))\n\ngoal (1 subgoal):\n 1. (\\<lambda>i. value_flow \\<Delta> (f_i i))\n    \\<longlonglongrightarrow> (\\<Squnion>i. value_flow \\<Delta> (f_i i))", "by(rule LIMSEQ_SUP)"], ["proof (state)\nthis:\n  (\\<lambda>i. value_flow \\<Delta> (f_i i))\n  \\<longlonglongrightarrow> (\\<Squnion>i. value_flow \\<Delta> (f_i i))\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       flow \\<Delta> f \\<and>\n       value_flow \\<Delta> f = \\<alpha> \\<and>\n       (\\<forall>x. d_IN f x \\<le> value_flow \\<Delta> f)", "also"], ["proof (state)\nthis:\n  (\\<lambda>i. value_flow \\<Delta> (f_i i))\n  \\<longlonglongrightarrow> (\\<Squnion>i. value_flow \\<Delta> (f_i i))\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       flow \\<Delta> f \\<and>\n       value_flow \\<Delta> f = \\<alpha> \\<and>\n       (\\<forall>x. d_IN f x \\<le> value_flow \\<Delta> f)", "have \"(SUP i. value_flow \\<Delta> (f_i i)) = \\<alpha>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Squnion>i. value_flow \\<Delta> (f_i i)) = \\<alpha>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Squnion>i. value_flow \\<Delta> (f_i i)) = \\<alpha>", "have \"\\<alpha> - (SUP i. value_flow \\<Delta> (f_i i)) = (INF i. \\<alpha> - value_flow \\<Delta> (f_i i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha> - (\\<Squnion>i. value_flow \\<Delta> (f_i i)) =\n    (\\<Sqinter>i. \\<alpha> - value_flow \\<Delta> (f_i i))", "by(simp add: ennreal_SUP_const_minus real)"], ["proof (state)\nthis:\n  \\<alpha> - (\\<Squnion>i. value_flow \\<Delta> (f_i i)) =\n  (\\<Sqinter>i. \\<alpha> - value_flow \\<Delta> (f_i i))\n\ngoal (1 subgoal):\n 1. (\\<Squnion>i. value_flow \\<Delta> (f_i i)) = \\<alpha>", "also"], ["proof (state)\nthis:\n  \\<alpha> - (\\<Squnion>i. value_flow \\<Delta> (f_i i)) =\n  (\\<Sqinter>i. \\<alpha> - value_flow \\<Delta> (f_i i))\n\ngoal (1 subgoal):\n 1. (\\<Squnion>i. value_flow \\<Delta> (f_i i)) = \\<alpha>", "have \"\\<alpha> - value_flow \\<Delta> (f_i i) = \\<alpha>' / 2 ^ i\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha> - value_flow \\<Delta> (f_i i) = ennreal (\\<alpha>' / 2 ^ i)", "by(simp add: value_f_i value_aux real ennreal_minus_if field_simps mult_le_cancel_left1)"], ["proof (state)\nthis:\n  \\<alpha> - value_flow \\<Delta> (f_i ?i) = ennreal (\\<alpha>' / 2 ^ ?i)\n\ngoal (1 subgoal):\n 1. (\\<Squnion>i. value_flow \\<Delta> (f_i i)) = \\<alpha>", "hence \"(INF i. \\<alpha> - value_flow \\<Delta> (f_i i)) = (INF i. ennreal (\\<alpha>' / 2  ^ i))\""], ["proof (prove)\nusing this:\n  \\<alpha> - value_flow \\<Delta> (f_i ?i) = ennreal (\\<alpha>' / 2 ^ ?i)\n\ngoal (1 subgoal):\n 1. (\\<Sqinter>i. \\<alpha> - value_flow \\<Delta> (f_i i)) =\n    (\\<Sqinter>i. ennreal (\\<alpha>' / 2 ^ i))", "by(auto intro: INF_cong)"], ["proof (state)\nthis:\n  (\\<Sqinter>i. \\<alpha> - value_flow \\<Delta> (f_i i)) =\n  (\\<Sqinter>i. ennreal (\\<alpha>' / 2 ^ i))\n\ngoal (1 subgoal):\n 1. (\\<Squnion>i. value_flow \\<Delta> (f_i i)) = \\<alpha>", "also"], ["proof (state)\nthis:\n  (\\<Sqinter>i. \\<alpha> - value_flow \\<Delta> (f_i i)) =\n  (\\<Sqinter>i. ennreal (\\<alpha>' / 2 ^ i))\n\ngoal (1 subgoal):\n 1. (\\<Squnion>i. value_flow \\<Delta> (f_i i)) = \\<alpha>", "have \"\\<dots> = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sqinter>i. ennreal (\\<alpha>' / 2 ^ i)) = 0", "proof(rule LIMSEQ_unique)"], ["proof (state)\ngoal (2 subgoals):\n 1. ?X \\<longlonglongrightarrow> (\\<Sqinter>i. ennreal (\\<alpha>' / 2 ^ i))\n 2. ?X \\<longlonglongrightarrow> 0", "show \"(\\<lambda>i. \\<alpha>' / 2 ^ i) \\<longlonglongrightarrow> (INF i. ennreal (\\<alpha>' / 2  ^ i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. ennreal (\\<alpha>' / 2 ^ x))\n    \\<longlonglongrightarrow> (\\<Sqinter>i. ennreal (\\<alpha>' / 2 ^ i))", "by(rule LIMSEQ_INF)(simp add: field_simps real decseq_SucI)"], ["proof (state)\nthis:\n  (\\<lambda>x. ennreal (\\<alpha>' / 2 ^ x))\n  \\<longlonglongrightarrow> (\\<Sqinter>i. ennreal (\\<alpha>' / 2 ^ i))\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. ennreal (\\<alpha>' / 2 ^ x)) \\<longlonglongrightarrow> 0", "qed(simp add: LIMSEQ_divide_realpow_zero real ennreal_0[symmetric] del: ennreal_0)"], ["proof (state)\nthis:\n  (\\<Sqinter>i. ennreal (\\<alpha>' / 2 ^ i)) = 0\n\ngoal (1 subgoal):\n 1. (\\<Squnion>i. value_flow \\<Delta> (f_i i)) = \\<alpha>", "finally"], ["proof (chain)\npicking this:\n  \\<alpha> - (\\<Squnion>i. value_flow \\<Delta> (f_i i)) = 0", "show \"(SUP i. value_flow \\<Delta> (f_i i)) = \\<alpha>\""], ["proof (prove)\nusing this:\n  \\<alpha> - (\\<Squnion>i. value_flow \\<Delta> (f_i i)) = 0\n\ngoal (1 subgoal):\n 1. (\\<Squnion>i. value_flow \\<Delta> (f_i i)) = \\<alpha>", "apply (intro antisym)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<alpha> - (\\<Squnion>i. value_flow \\<Delta> (f_i i)) =\n    0 \\<Longrightarrow>\n    (\\<Squnion>i. value_flow \\<Delta> (f_i i)) \\<le> \\<alpha>\n 2. \\<alpha> - (\\<Squnion>i. value_flow \\<Delta> (f_i i)) =\n    0 \\<Longrightarrow>\n    \\<alpha> \\<le> (\\<Squnion>i. value_flow \\<Delta> (f_i i))", "apply (auto simp: \\<alpha>_def intro!: SUP_mono fn.g) []"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha> - (\\<Squnion>i. value_flow \\<Delta> (f_i i)) =\n    0 \\<Longrightarrow>\n    \\<alpha> \\<le> (\\<Squnion>i. value_flow \\<Delta> (f_i i))", "apply (rule ennreal_minus_eq_0)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha> - (\\<Squnion>i. value_flow \\<Delta> (f_i i)) =\n    0 \\<Longrightarrow>\n    \\<alpha> - (\\<Squnion>i. value_flow \\<Delta> (f_i i)) = 0", "apply assumption"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (\\<Squnion>i. value_flow \\<Delta> (f_i i)) = \\<alpha>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Squnion>i. value_flow \\<Delta> (f_i i)) = \\<alpha>\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       flow \\<Delta> f \\<and>\n       value_flow \\<Delta> f = \\<alpha> \\<and>\n       (\\<forall>x. d_IN f x \\<le> value_flow \\<Delta> f)", "also"], ["proof (state)\nthis:\n  (\\<Squnion>i. value_flow \\<Delta> (f_i i)) = \\<alpha>\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       flow \\<Delta> f \\<and>\n       value_flow \\<Delta> f = \\<alpha> \\<and>\n       (\\<forall>x. d_IN f x \\<le> value_flow \\<Delta> f)", "have \"(\\<lambda>i. value_flow \\<Delta> (f_i i)) \\<longlonglongrightarrow> value_flow \\<Delta> f'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>i. value_flow \\<Delta> (f_i i))\n    \\<longlonglongrightarrow> value_flow \\<Delta>\n                               (\\<lambda>x. ennreal (f' x))", "by(simp add: value_flow[OF flow source_out] value_flow[OF fn.g source_out] f)"], ["proof (state)\nthis:\n  (\\<lambda>i. value_flow \\<Delta> (f_i i))\n  \\<longlonglongrightarrow> value_flow \\<Delta> (\\<lambda>x. ennreal (f' x))\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       flow \\<Delta> f \\<and>\n       value_flow \\<Delta> f = \\<alpha> \\<and>\n       (\\<forall>x. d_IN f x \\<le> value_flow \\<Delta> f)", "ultimately"], ["proof (chain)\npicking this:\n  (\\<lambda>i. value_flow \\<Delta> (f_i i))\n  \\<longlonglongrightarrow> \\<alpha>\n  (\\<lambda>i. value_flow \\<Delta> (f_i i))\n  \\<longlonglongrightarrow> value_flow \\<Delta> (\\<lambda>x. ennreal (f' x))", "have \"value_flow \\<Delta> f' = \\<alpha>\""], ["proof (prove)\nusing this:\n  (\\<lambda>i. value_flow \\<Delta> (f_i i))\n  \\<longlonglongrightarrow> \\<alpha>\n  (\\<lambda>i. value_flow \\<Delta> (f_i i))\n  \\<longlonglongrightarrow> value_flow \\<Delta> (\\<lambda>x. ennreal (f' x))\n\ngoal (1 subgoal):\n 1. value_flow \\<Delta> (\\<lambda>x. ennreal (f' x)) = \\<alpha>", "by(blast intro: LIMSEQ_unique)"], ["proof (state)\nthis:\n  value_flow \\<Delta> (\\<lambda>x. ennreal (f' x)) = \\<alpha>\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       flow \\<Delta> f \\<and>\n       value_flow \\<Delta> f = \\<alpha> \\<and>\n       (\\<forall>x. d_IN f x \\<le> value_flow \\<Delta> f)", "}"], ["proof (state)\nthis:\n  value_flow \\<Delta> (\\<lambda>x. ennreal (f' x)) = \\<alpha>\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       flow \\<Delta> f \\<and>\n       value_flow \\<Delta> f = \\<alpha> \\<and>\n       (\\<forall>x. d_IN f x \\<le> value_flow \\<Delta> f)", "note value_f = this"], ["proof (state)\nthis:\n  value_flow \\<Delta> (\\<lambda>x. ennreal (f' x)) = \\<alpha>\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       flow \\<Delta> f \\<and>\n       value_flow \\<Delta> f = \\<alpha> \\<and>\n       (\\<forall>x. d_IN f x \\<le> value_flow \\<Delta> f)", "moreover"], ["proof (state)\nthis:\n  value_flow \\<Delta> (\\<lambda>x. ennreal (f' x)) = \\<alpha>\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       flow \\<Delta> f \\<and>\n       value_flow \\<Delta> f = \\<alpha> \\<and>\n       (\\<forall>x. d_IN f x \\<le> value_flow \\<Delta> f)", "{"], ["proof (state)\nthis:\n  value_flow \\<Delta> (\\<lambda>x. ennreal (f' x)) = \\<alpha>\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       flow \\<Delta> f \\<and>\n       value_flow \\<Delta> f = \\<alpha> \\<and>\n       (\\<forall>x. d_IN f x \\<le> value_flow \\<Delta> f)", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>f.\n       flow \\<Delta> f \\<and>\n       value_flow \\<Delta> f = \\<alpha> \\<and>\n       (\\<forall>x. d_IN f x \\<le> value_flow \\<Delta> f)", "have \"d_IN f' x = \\<integral>\\<^sup>+ y. liminf (\\<lambda>i. f_i i (y, x)) \\<partial>count_space UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN (\\<lambda>x. ennreal (f' x)) x =\n    (\\<Sum>\\<^sup>+ y. liminf (\\<lambda>i. f_i i (y, x)))", "unfolding d_IN_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ x. ennreal (f' (x, x))) =\n    (\\<Sum>\\<^sup>+ y. liminf (\\<lambda>i. f_i i (y, x)))", "using f"], ["proof (prove)\nusing this:\n  (\\<lambda>i. f_i i ?e) \\<longlonglongrightarrow> ennreal (f' ?e)\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ x. ennreal (f' (x, x))) =\n    (\\<Sum>\\<^sup>+ y. liminf (\\<lambda>i. f_i i (y, x)))", "by(simp add: tendsto_iff_Liminf_eq_Limsup)"], ["proof (state)\nthis:\n  d_IN (\\<lambda>x. ennreal (f' x)) x =\n  (\\<Sum>\\<^sup>+ y. liminf (\\<lambda>i. f_i i (y, x)))\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       flow \\<Delta> f \\<and>\n       value_flow \\<Delta> f = \\<alpha> \\<and>\n       (\\<forall>x. d_IN f x \\<le> value_flow \\<Delta> f)", "also"], ["proof (state)\nthis:\n  d_IN (\\<lambda>x. ennreal (f' x)) x =\n  (\\<Sum>\\<^sup>+ y. liminf (\\<lambda>i. f_i i (y, x)))\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       flow \\<Delta> f \\<and>\n       value_flow \\<Delta> f = \\<alpha> \\<and>\n       (\\<forall>x. d_IN f x \\<le> value_flow \\<Delta> f)", "have \"\\<dots> \\<le> liminf (\\<lambda>i. d_IN (f_i i) x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y. liminf (\\<lambda>i. f_i i (y, x)))\n    \\<le> liminf (\\<lambda>i. d_IN (f_i i) x)", "unfolding d_IN_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y. liminf (\\<lambda>i. f_i i (y, x)))\n    \\<le> liminf (\\<lambda>i. \\<Sum>\\<^sup>+ x. f_i i (x, x))", "by(rule nn_integral_liminf)(simp_all add:)"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y. liminf (\\<lambda>i. f_i i (y, x)))\n  \\<le> liminf (\\<lambda>i. d_IN (f_i i) x)\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       flow \\<Delta> f \\<and>\n       value_flow \\<Delta> f = \\<alpha> \\<and>\n       (\\<forall>x. d_IN f x \\<le> value_flow \\<Delta> f)", "also"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y. liminf (\\<lambda>i. f_i i (y, x)))\n  \\<le> liminf (\\<lambda>i. d_IN (f_i i) x)\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       flow \\<Delta> f \\<and>\n       value_flow \\<Delta> f = \\<alpha> \\<and>\n       (\\<forall>x. d_IN f x \\<le> value_flow \\<Delta> f)", "have \"\\<dots> \\<le> liminf (\\<lambda>i. \\<alpha>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. liminf (\\<lambda>i. d_IN (f_i i) x) \\<le> liminf (\\<lambda>i. \\<alpha>)", "using d_IN_i[of _ x] fn.g"], ["proof (prove)\nusing this:\n  d_IN (f_i ?i) x \\<le> value_flow \\<Delta> (f_i ?i)\n  flow \\<Delta> (f_i ?i)\n\ngoal (1 subgoal):\n 1. liminf (\\<lambda>i. d_IN (f_i i) x) \\<le> liminf (\\<lambda>i. \\<alpha>)", "by(auto intro!: Liminf_mono SUP_upper2 eventually_sequentiallyI simp add: \\<alpha>_def)"], ["proof (state)\nthis:\n  liminf (\\<lambda>i. d_IN (f_i i) x) \\<le> liminf (\\<lambda>i. \\<alpha>)\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       flow \\<Delta> f \\<and>\n       value_flow \\<Delta> f = \\<alpha> \\<and>\n       (\\<forall>x. d_IN f x \\<le> value_flow \\<Delta> f)", "also"], ["proof (state)\nthis:\n  liminf (\\<lambda>i. d_IN (f_i i) x) \\<le> liminf (\\<lambda>i. \\<alpha>)\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       flow \\<Delta> f \\<and>\n       value_flow \\<Delta> f = \\<alpha> \\<and>\n       (\\<forall>x. d_IN f x \\<le> value_flow \\<Delta> f)", "have \"\\<dots> = value_flow \\<Delta> f'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. liminf (\\<lambda>i. \\<alpha>) =\n    value_flow \\<Delta> (\\<lambda>x. ennreal (f' x))", "using value_f"], ["proof (prove)\nusing this:\n  value_flow \\<Delta> (\\<lambda>x. ennreal (f' x)) = \\<alpha>\n\ngoal (1 subgoal):\n 1. liminf (\\<lambda>i. \\<alpha>) =\n    value_flow \\<Delta> (\\<lambda>x. ennreal (f' x))", "by(simp add: Liminf_const)"], ["proof (state)\nthis:\n  liminf (\\<lambda>i. \\<alpha>) =\n  value_flow \\<Delta> (\\<lambda>x. ennreal (f' x))\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       flow \\<Delta> f \\<and>\n       value_flow \\<Delta> f = \\<alpha> \\<and>\n       (\\<forall>x. d_IN f x \\<le> value_flow \\<Delta> f)", "also"], ["proof (state)\nthis:\n  liminf (\\<lambda>i. \\<alpha>) =\n  value_flow \\<Delta> (\\<lambda>x. ennreal (f' x))\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       flow \\<Delta> f \\<and>\n       value_flow \\<Delta> f = \\<alpha> \\<and>\n       (\\<forall>x. d_IN f x \\<le> value_flow \\<Delta> f)", "note calculation"], ["proof (state)\nthis:\n  d_IN (\\<lambda>x. ennreal (f' x)) x\n  \\<le> value_flow \\<Delta> (\\<lambda>x. ennreal (f' x))\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       flow \\<Delta> f \\<and>\n       value_flow \\<Delta> f = \\<alpha> \\<and>\n       (\\<forall>x. d_IN f x \\<le> value_flow \\<Delta> f)", "}"], ["proof (state)\nthis:\n  d_IN (\\<lambda>x. ennreal (f' x)) ?xa2\n  \\<le> value_flow \\<Delta> (\\<lambda>x. ennreal (f' x))\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       flow \\<Delta> f \\<and>\n       value_flow \\<Delta> f = \\<alpha> \\<and>\n       (\\<forall>x. d_IN f x \\<le> value_flow \\<Delta> f)", "ultimately"], ["proof (chain)\npicking this:\n  flow \\<Delta> (\\<lambda>x. ennreal (f' x))\n  value_flow \\<Delta> (\\<lambda>x. ennreal (f' x)) = \\<alpha>\n  d_IN (\\<lambda>x. ennreal (f' x)) ?xa2\n  \\<le> value_flow \\<Delta> (\\<lambda>x. ennreal (f' x))", "show ?thesis"], ["proof (prove)\nusing this:\n  flow \\<Delta> (\\<lambda>x. ennreal (f' x))\n  value_flow \\<Delta> (\\<lambda>x. ennreal (f' x)) = \\<alpha>\n  d_IN (\\<lambda>x. ennreal (f' x)) ?xa2\n  \\<le> value_flow \\<Delta> (\\<lambda>x. ennreal (f' x))\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       flow \\<Delta> f \\<and>\n       value_flow \\<Delta> f = \\<alpha> \\<and>\n       (\\<forall>x. d_IN f x \\<le> value_flow \\<Delta> f)", "by blast"], ["proof (state)\nthis:\n  \\<exists>f.\n     flow \\<Delta> f \\<and>\n     value_flow \\<Delta> f = \\<alpha> \\<and>\n     (\\<forall>x. d_IN f x \\<le> value_flow \\<Delta> f)\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem ex_max_flow'': \\<comment> \\<open>eliminate assumption of no antiparallel edges using locale @{const wf_residual_network}\\<close>\n  assumes source_out: \"\\<And>y. edge \\<Delta> (source \\<Delta>) y \\<longleftrightarrow> y = x\"\n  and nontrivial: \"\\<^bold>E \\<noteq> {}\"\n  and real: \"\\<alpha> = ennreal \\<alpha>'\" and nn[simp]: \"0 \\<le> \\<alpha>'\"\n  shows \"\\<exists>f. flow \\<Delta> f \\<and> value_flow \\<Delta> f = \\<alpha> \\<and> (\\<forall>x. d_IN f x \\<le> value_flow \\<Delta> f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>f.\n       flow \\<Delta> f \\<and>\n       value_flow \\<Delta> f = \\<alpha> \\<and>\n       (\\<forall>x. d_IN f x \\<le> value_flow \\<Delta> f)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>f.\n       flow \\<Delta> f \\<and>\n       value_flow \\<Delta> f = \\<alpha> \\<and>\n       (\\<forall>x. d_IN f x \\<le> value_flow \\<Delta> f)", "interpret antiparallel_edges \\<Delta>"], ["proof (prove)\ngoal (1 subgoal):\n 1. antiparallel_edges \\<Delta>", ".."], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>f.\n       flow \\<Delta> f \\<and>\n       value_flow \\<Delta> f = \\<alpha> \\<and>\n       (\\<forall>x. d_IN f x \\<le> value_flow \\<Delta> f)", "interpret \\<Delta>'': flow_attainability \\<Delta>''"], ["proof (prove)\ngoal (1 subgoal):\n 1. flow_attainability \\<Delta>''", "by(rule \\<Delta>''_flow_attainability flow_attainability.axioms(2))+unfold_locales"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>f.\n       flow \\<Delta> f \\<and>\n       value_flow \\<Delta> f = \\<alpha> \\<and>\n       (\\<forall>x. d_IN f x \\<le> value_flow \\<Delta> f)", "have wf_\\<Delta>'': \"\\<Delta>''.wf_residual_network\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Delta>''.wf_residual_network", "by(rule \\<Delta>''_wf_residual_network; simp add: no_loop)"], ["proof (state)\nthis:\n  \\<Delta>''.wf_residual_network\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       flow \\<Delta> f \\<and>\n       value_flow \\<Delta> f = \\<alpha> \\<and>\n       (\\<forall>x. d_IN f x \\<le> value_flow \\<Delta> f)", "have source_out': \"edge \\<Delta>'' (source \\<Delta>'') y \\<longleftrightarrow> y = Edge (source \\<Delta>) x\" for y"], ["proof (prove)\ngoal (1 subgoal):\n 1. edge \\<Delta>'' (source \\<Delta>'') y = (y = Edge (source \\<Delta>) x)", "by(auto simp add: source_out)"], ["proof (state)\nthis:\n  edge \\<Delta>'' (source \\<Delta>'') ?y = (?y = Edge (source \\<Delta>) x)\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       flow \\<Delta> f \\<and>\n       value_flow \\<Delta> f = \\<alpha> \\<and>\n       (\\<forall>x. d_IN f x \\<le> value_flow \\<Delta> f)", "have nontrivial': \"\\<^bold>V\\<^bsub>\\<Delta>''\\<^esub> - {source \\<Delta>'', sink \\<Delta>''} \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<^bold>V\\<^bsub>\\<Delta>''\\<^esub> -\n    {source \\<Delta>'', sink \\<Delta>''} \\<noteq>\n    {}", "using nontrivial"], ["proof (prove)\nusing this:\n  \\<^bold>E \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<^bold>V\\<^bsub>\\<Delta>''\\<^esub> -\n    {source \\<Delta>'', sink \\<Delta>''} \\<noteq>\n    {}", "by(auto simp add: \"\\<^bold>V_\\<Delta>''\")"], ["proof (state)\nthis:\n  \\<^bold>V\\<^bsub>\\<Delta>''\\<^esub> -\n  {source \\<Delta>'', sink \\<Delta>''} \\<noteq>\n  {}\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       flow \\<Delta> f \\<and>\n       value_flow \\<Delta> f = \\<alpha> \\<and>\n       (\\<forall>x. d_IN f x \\<le> value_flow \\<Delta> f)", "have \"(SUP g \\<in> {g. flow \\<Delta>'' g}. value_flow \\<Delta>'' g) = (SUP g \\<in> {g. flow \\<Delta> g}. value_flow \\<Delta> g)\" (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Squnion> (value_flow \\<Delta>'' ` {g. flow \\<Delta>'' g}) =\n    \\<Squnion> (value_flow \\<Delta> ` {g. flow \\<Delta> g})", "proof(intro antisym SUP_least; unfold mem_Collect_eq)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>g.\n       flow \\<Delta>'' g \\<Longrightarrow>\n       value_flow \\<Delta>'' g\n       \\<le> \\<Squnion> (value_flow \\<Delta> ` {g. flow \\<Delta> g})\n 2. \\<And>g.\n       flow \\<Delta> g \\<Longrightarrow>\n       value_flow \\<Delta> g\n       \\<le> \\<Squnion> (value_flow \\<Delta>'' ` {g. flow \\<Delta>'' g})", "fix g"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>g.\n       flow \\<Delta>'' g \\<Longrightarrow>\n       value_flow \\<Delta>'' g\n       \\<le> \\<Squnion> (value_flow \\<Delta> ` {g. flow \\<Delta> g})\n 2. \\<And>g.\n       flow \\<Delta> g \\<Longrightarrow>\n       value_flow \\<Delta> g\n       \\<le> \\<Squnion> (value_flow \\<Delta>'' ` {g. flow \\<Delta>'' g})", "assume g: \"flow \\<Delta>'' g\""], ["proof (state)\nthis:\n  flow \\<Delta>'' g\n\ngoal (2 subgoals):\n 1. \\<And>g.\n       flow \\<Delta>'' g \\<Longrightarrow>\n       value_flow \\<Delta>'' g\n       \\<le> \\<Squnion> (value_flow \\<Delta> ` {g. flow \\<Delta> g})\n 2. \\<And>g.\n       flow \\<Delta> g \\<Longrightarrow>\n       value_flow \\<Delta> g\n       \\<le> \\<Squnion> (value_flow \\<Delta>'' ` {g. flow \\<Delta>'' g})", "hence \"value_flow \\<Delta>'' g = value_flow \\<Delta> (collect g)\""], ["proof (prove)\nusing this:\n  flow \\<Delta>'' g\n\ngoal (1 subgoal):\n 1. value_flow \\<Delta>'' g =\n    value_flow \\<Delta> (\\<lambda>(x, y). g (Edge x y, Vertex y))", "by(simp add: value_collect)"], ["proof (state)\nthis:\n  value_flow \\<Delta>'' g =\n  value_flow \\<Delta> (\\<lambda>(x, y). g (Edge x y, Vertex y))\n\ngoal (2 subgoals):\n 1. \\<And>g.\n       flow \\<Delta>'' g \\<Longrightarrow>\n       value_flow \\<Delta>'' g\n       \\<le> \\<Squnion> (value_flow \\<Delta> ` {g. flow \\<Delta> g})\n 2. \\<And>g.\n       flow \\<Delta> g \\<Longrightarrow>\n       value_flow \\<Delta> g\n       \\<le> \\<Squnion> (value_flow \\<Delta>'' ` {g. flow \\<Delta>'' g})", "also"], ["proof (state)\nthis:\n  value_flow \\<Delta>'' g =\n  value_flow \\<Delta> (\\<lambda>(x, y). g (Edge x y, Vertex y))\n\ngoal (2 subgoals):\n 1. \\<And>g.\n       flow \\<Delta>'' g \\<Longrightarrow>\n       value_flow \\<Delta>'' g\n       \\<le> \\<Squnion> (value_flow \\<Delta> ` {g. flow \\<Delta> g})\n 2. \\<And>g.\n       flow \\<Delta> g \\<Longrightarrow>\n       value_flow \\<Delta> g\n       \\<le> \\<Squnion> (value_flow \\<Delta>'' ` {g. flow \\<Delta>'' g})", "{"], ["proof (state)\nthis:\n  value_flow \\<Delta>'' g =\n  value_flow \\<Delta> (\\<lambda>(x, y). g (Edge x y, Vertex y))\n\ngoal (2 subgoals):\n 1. \\<And>g.\n       flow \\<Delta>'' g \\<Longrightarrow>\n       value_flow \\<Delta>'' g\n       \\<le> \\<Squnion> (value_flow \\<Delta> ` {g. flow \\<Delta> g})\n 2. \\<And>g.\n       flow \\<Delta> g \\<Longrightarrow>\n       value_flow \\<Delta> g\n       \\<le> \\<Squnion> (value_flow \\<Delta>'' ` {g. flow \\<Delta>'' g})", "from g"], ["proof (chain)\npicking this:\n  flow \\<Delta>'' g", "have \"flow \\<Delta> (collect g)\""], ["proof (prove)\nusing this:\n  flow \\<Delta>'' g\n\ngoal (1 subgoal):\n 1. flow \\<Delta> (\\<lambda>(x, y). g (Edge x y, Vertex y))", "by simp"], ["proof (state)\nthis:\n  flow \\<Delta> (\\<lambda>(x, y). g (Edge x y, Vertex y))\n\ngoal (2 subgoals):\n 1. \\<And>g.\n       flow \\<Delta>'' g \\<Longrightarrow>\n       value_flow \\<Delta>'' g\n       \\<le> \\<Squnion> (value_flow \\<Delta> ` {g. flow \\<Delta> g})\n 2. \\<And>g.\n       flow \\<Delta> g \\<Longrightarrow>\n       value_flow \\<Delta> g\n       \\<le> \\<Squnion> (value_flow \\<Delta>'' ` {g. flow \\<Delta>'' g})", "}"], ["proof (state)\nthis:\n  flow \\<Delta> (\\<lambda>(x, y). g (Edge x y, Vertex y))\n\ngoal (2 subgoals):\n 1. \\<And>g.\n       flow \\<Delta>'' g \\<Longrightarrow>\n       value_flow \\<Delta>'' g\n       \\<le> \\<Squnion> (value_flow \\<Delta> ` {g. flow \\<Delta> g})\n 2. \\<And>g.\n       flow \\<Delta> g \\<Longrightarrow>\n       value_flow \\<Delta> g\n       \\<le> \\<Squnion> (value_flow \\<Delta>'' ` {g. flow \\<Delta>'' g})", "then"], ["proof (chain)\npicking this:\n  flow \\<Delta> (\\<lambda>(x, y). g (Edge x y, Vertex y))", "have \"\\<dots> \\<le> ?rhs\""], ["proof (prove)\nusing this:\n  flow \\<Delta> (\\<lambda>(x, y). g (Edge x y, Vertex y))\n\ngoal (1 subgoal):\n 1. value_flow \\<Delta> (\\<lambda>(x, y). g (Edge x y, Vertex y))\n    \\<le> \\<Squnion> (value_flow \\<Delta> ` {g. flow \\<Delta> g})", "by(blast intro: SUP_upper2)"], ["proof (state)\nthis:\n  value_flow \\<Delta> (\\<lambda>(x, y). g (Edge x y, Vertex y))\n  \\<le> \\<Squnion> (value_flow \\<Delta> ` {g. flow \\<Delta> g})\n\ngoal (2 subgoals):\n 1. \\<And>g.\n       flow \\<Delta>'' g \\<Longrightarrow>\n       value_flow \\<Delta>'' g\n       \\<le> \\<Squnion> (value_flow \\<Delta> ` {g. flow \\<Delta> g})\n 2. \\<And>g.\n       flow \\<Delta> g \\<Longrightarrow>\n       value_flow \\<Delta> g\n       \\<le> \\<Squnion> (value_flow \\<Delta>'' ` {g. flow \\<Delta>'' g})", "finally"], ["proof (chain)\npicking this:\n  value_flow \\<Delta>'' g\n  \\<le> \\<Squnion> (value_flow \\<Delta> ` {g. flow \\<Delta> g})", "show \"value_flow \\<Delta>'' g \\<le> \\<dots>\""], ["proof (prove)\nusing this:\n  value_flow \\<Delta>'' g\n  \\<le> \\<Squnion> (value_flow \\<Delta> ` {g. flow \\<Delta> g})\n\ngoal (1 subgoal):\n 1. value_flow \\<Delta>'' g\n    \\<le> \\<Squnion> (value_flow \\<Delta> ` {g. flow \\<Delta> g})", "."], ["proof (state)\nthis:\n  value_flow \\<Delta>'' g\n  \\<le> \\<Squnion> (value_flow \\<Delta> ` {g. flow \\<Delta> g})\n\ngoal (1 subgoal):\n 1. \\<And>g.\n       flow \\<Delta> g \\<Longrightarrow>\n       value_flow \\<Delta> g\n       \\<le> \\<Squnion> (value_flow \\<Delta>'' ` {g. flow \\<Delta>'' g})", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>g.\n       flow \\<Delta> g \\<Longrightarrow>\n       value_flow \\<Delta> g\n       \\<le> \\<Squnion> (value_flow \\<Delta>'' ` {g. flow \\<Delta>'' g})", "fix g"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>g.\n       flow \\<Delta> g \\<Longrightarrow>\n       value_flow \\<Delta> g\n       \\<le> \\<Squnion> (value_flow \\<Delta>'' ` {g. flow \\<Delta>'' g})", "assume g: \"flow \\<Delta> g\""], ["proof (state)\nthis:\n  flow \\<Delta> g\n\ngoal (1 subgoal):\n 1. \\<And>g.\n       flow \\<Delta> g \\<Longrightarrow>\n       value_flow \\<Delta> g\n       \\<le> \\<Squnion> (value_flow \\<Delta>'' ` {g. flow \\<Delta>'' g})", "hence \"value_flow \\<Delta> g = value_flow \\<Delta>'' (split g)\""], ["proof (prove)\nusing this:\n  flow \\<Delta> g\n\ngoal (1 subgoal):\n 1. value_flow \\<Delta> g = value_flow \\<Delta>'' (split g)", "by simp"], ["proof (state)\nthis:\n  value_flow \\<Delta> g = value_flow \\<Delta>'' (split g)\n\ngoal (1 subgoal):\n 1. \\<And>g.\n       flow \\<Delta> g \\<Longrightarrow>\n       value_flow \\<Delta> g\n       \\<le> \\<Squnion> (value_flow \\<Delta>'' ` {g. flow \\<Delta>'' g})", "also"], ["proof (state)\nthis:\n  value_flow \\<Delta> g = value_flow \\<Delta>'' (split g)\n\ngoal (1 subgoal):\n 1. \\<And>g.\n       flow \\<Delta> g \\<Longrightarrow>\n       value_flow \\<Delta> g\n       \\<le> \\<Squnion> (value_flow \\<Delta>'' ` {g. flow \\<Delta>'' g})", "{"], ["proof (state)\nthis:\n  value_flow \\<Delta> g = value_flow \\<Delta>'' (split g)\n\ngoal (1 subgoal):\n 1. \\<And>g.\n       flow \\<Delta> g \\<Longrightarrow>\n       value_flow \\<Delta> g\n       \\<le> \\<Squnion> (value_flow \\<Delta>'' ` {g. flow \\<Delta>'' g})", "from g"], ["proof (chain)\npicking this:\n  flow \\<Delta> g", "have \"flow \\<Delta>'' (split g)\""], ["proof (prove)\nusing this:\n  flow \\<Delta> g\n\ngoal (1 subgoal):\n 1. flow \\<Delta>'' (split g)", "by simp"], ["proof (state)\nthis:\n  flow \\<Delta>'' (split g)\n\ngoal (1 subgoal):\n 1. \\<And>g.\n       flow \\<Delta> g \\<Longrightarrow>\n       value_flow \\<Delta> g\n       \\<le> \\<Squnion> (value_flow \\<Delta>'' ` {g. flow \\<Delta>'' g})", "}"], ["proof (state)\nthis:\n  flow \\<Delta>'' (split g)\n\ngoal (1 subgoal):\n 1. \\<And>g.\n       flow \\<Delta> g \\<Longrightarrow>\n       value_flow \\<Delta> g\n       \\<le> \\<Squnion> (value_flow \\<Delta>'' ` {g. flow \\<Delta>'' g})", "then"], ["proof (chain)\npicking this:\n  flow \\<Delta>'' (split g)", "have \"\\<dots> \\<le> ?lhs\""], ["proof (prove)\nusing this:\n  flow \\<Delta>'' (split g)\n\ngoal (1 subgoal):\n 1. value_flow \\<Delta>'' (split g)\n    \\<le> \\<Squnion> (value_flow \\<Delta>'' ` {g. flow \\<Delta>'' g})", "by(blast intro: SUP_upper2)"], ["proof (state)\nthis:\n  value_flow \\<Delta>'' (split g)\n  \\<le> \\<Squnion> (value_flow \\<Delta>'' ` {g. flow \\<Delta>'' g})\n\ngoal (1 subgoal):\n 1. \\<And>g.\n       flow \\<Delta> g \\<Longrightarrow>\n       value_flow \\<Delta> g\n       \\<le> \\<Squnion> (value_flow \\<Delta>'' ` {g. flow \\<Delta>'' g})", "finally"], ["proof (chain)\npicking this:\n  value_flow \\<Delta> g\n  \\<le> \\<Squnion> (value_flow \\<Delta>'' ` {g. flow \\<Delta>'' g})", "show \"value_flow \\<Delta> g \\<le> ?lhs\""], ["proof (prove)\nusing this:\n  value_flow \\<Delta> g\n  \\<le> \\<Squnion> (value_flow \\<Delta>'' ` {g. flow \\<Delta>'' g})\n\ngoal (1 subgoal):\n 1. value_flow \\<Delta> g\n    \\<le> \\<Squnion> (value_flow \\<Delta>'' ` {g. flow \\<Delta>'' g})", "."], ["proof (state)\nthis:\n  value_flow \\<Delta> g\n  \\<le> \\<Squnion> (value_flow \\<Delta>'' ` {g. flow \\<Delta>'' g})\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<Squnion> (value_flow \\<Delta>'' ` {g. flow \\<Delta>'' g}) =\n  \\<Squnion> (value_flow \\<Delta> ` {g. flow \\<Delta> g})\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       flow \\<Delta> f \\<and>\n       value_flow \\<Delta> f = \\<alpha> \\<and>\n       (\\<forall>x. d_IN f x \\<le> value_flow \\<Delta> f)", "with real"], ["proof (chain)\npicking this:\n  \\<alpha> = ennreal \\<alpha>'\n  \\<Squnion> (value_flow \\<Delta>'' ` {g. flow \\<Delta>'' g}) =\n  \\<Squnion> (value_flow \\<Delta> ` {g. flow \\<Delta> g})", "have eq: \"(SUP g \\<in> {g. flow \\<Delta>'' g}. value_flow \\<Delta>'' g) = ennreal \\<alpha>'\""], ["proof (prove)\nusing this:\n  \\<alpha> = ennreal \\<alpha>'\n  \\<Squnion> (value_flow \\<Delta>'' ` {g. flow \\<Delta>'' g}) =\n  \\<Squnion> (value_flow \\<Delta> ` {g. flow \\<Delta> g})\n\ngoal (1 subgoal):\n 1. \\<Squnion> (value_flow \\<Delta>'' ` {g. flow \\<Delta>'' g}) =\n    ennreal \\<alpha>'", "by(simp add: \\<alpha>_def)"], ["proof (state)\nthis:\n  \\<Squnion> (value_flow \\<Delta>'' ` {g. flow \\<Delta>'' g}) =\n  ennreal \\<alpha>'\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       flow \\<Delta> f \\<and>\n       value_flow \\<Delta> f = \\<alpha> \\<and>\n       (\\<forall>x. d_IN f x \\<le> value_flow \\<Delta> f)", "from \\<Delta>''.ex_max_flow'[OF wf_\\<Delta>'' source_out' nontrivial' eq]"], ["proof (chain)\npicking this:\n  0 \\<le> \\<alpha>' \\<Longrightarrow>\n  \\<exists>f.\n     flow \\<Delta>'' f \\<and>\n     value_flow \\<Delta>'' f =\n     \\<Squnion> (value_flow \\<Delta>'' ` {g. flow \\<Delta>'' g}) \\<and>\n     (\\<forall>x. d_IN f x \\<le> value_flow \\<Delta>'' f)", "obtain f where f: \"flow \\<Delta>'' f\"\n    and \"value_flow \\<Delta>'' f = \\<alpha>\"\n    and IN: \"\\<And>x. d_IN f x \\<le> value_flow \\<Delta>'' f\""], ["proof (prove)\nusing this:\n  0 \\<le> \\<alpha>' \\<Longrightarrow>\n  \\<exists>f.\n     flow \\<Delta>'' f \\<and>\n     value_flow \\<Delta>'' f =\n     \\<Squnion> (value_flow \\<Delta>'' ` {g. flow \\<Delta>'' g}) \\<and>\n     (\\<forall>x. d_IN f x \\<le> value_flow \\<Delta>'' f)\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        \\<lbrakk>flow \\<Delta>'' f; value_flow \\<Delta>'' f = \\<alpha>;\n         \\<And>x. d_IN f x \\<le> value_flow \\<Delta>'' f\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding eq real"], ["proof (prove)\nusing this:\n  0 \\<le> \\<alpha>' \\<Longrightarrow>\n  \\<exists>f.\n     flow \\<Delta>'' f \\<and>\n     value_flow \\<Delta>'' f = ennreal \\<alpha>' \\<and>\n     (\\<forall>x. d_IN f x \\<le> value_flow \\<Delta>'' f)\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        \\<lbrakk>flow \\<Delta>'' f;\n         value_flow \\<Delta>'' f = ennreal \\<alpha>';\n         \\<And>x. d_IN f x \\<le> value_flow \\<Delta>'' f\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using nn"], ["proof (prove)\nusing this:\n  0 \\<le> \\<alpha>' \\<Longrightarrow>\n  \\<exists>f.\n     flow \\<Delta>'' f \\<and>\n     value_flow \\<Delta>'' f = ennreal \\<alpha>' \\<and>\n     (\\<forall>x. d_IN f x \\<le> value_flow \\<Delta>'' f)\n  0 \\<le> \\<alpha>'\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        \\<lbrakk>flow \\<Delta>'' f;\n         value_flow \\<Delta>'' f = ennreal \\<alpha>';\n         \\<And>x. d_IN f x \\<le> value_flow \\<Delta>'' f\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  flow \\<Delta>'' f\n  value_flow \\<Delta>'' f = \\<alpha>\n  d_IN f ?x \\<le> value_flow \\<Delta>'' f\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       flow \\<Delta> f \\<and>\n       value_flow \\<Delta> f = \\<alpha> \\<and>\n       (\\<forall>x. d_IN f x \\<le> value_flow \\<Delta> f)", "hence \"flow \\<Delta> (collect f)\" and \"value_flow \\<Delta> (collect f) = \\<alpha>\""], ["proof (prove)\nusing this:\n  flow \\<Delta>'' f\n  value_flow \\<Delta>'' f = \\<alpha>\n  d_IN f ?x \\<le> value_flow \\<Delta>'' f\n\ngoal (1 subgoal):\n 1. flow \\<Delta> (\\<lambda>(x, y). f (Edge x y, Vertex y)) &&&\n    value_flow \\<Delta> (\\<lambda>(x, y). f (Edge x y, Vertex y)) = \\<alpha>", "by(simp_all add: value_collect)"], ["proof (state)\nthis:\n  flow \\<Delta> (\\<lambda>(x, y). f (Edge x y, Vertex y))\n  value_flow \\<Delta> (\\<lambda>(x, y). f (Edge x y, Vertex y)) = \\<alpha>\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       flow \\<Delta> f \\<and>\n       value_flow \\<Delta> f = \\<alpha> \\<and>\n       (\\<forall>x. d_IN f x \\<le> value_flow \\<Delta> f)", "moreover"], ["proof (state)\nthis:\n  flow \\<Delta> (\\<lambda>(x, y). f (Edge x y, Vertex y))\n  value_flow \\<Delta> (\\<lambda>(x, y). f (Edge x y, Vertex y)) = \\<alpha>\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       flow \\<Delta> f \\<and>\n       value_flow \\<Delta> f = \\<alpha> \\<and>\n       (\\<forall>x. d_IN f x \\<le> value_flow \\<Delta> f)", "{"], ["proof (state)\nthis:\n  flow \\<Delta> (\\<lambda>(x, y). f (Edge x y, Vertex y))\n  value_flow \\<Delta> (\\<lambda>(x, y). f (Edge x y, Vertex y)) = \\<alpha>\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       flow \\<Delta> f \\<and>\n       value_flow \\<Delta> f = \\<alpha> \\<and>\n       (\\<forall>x. d_IN f x \\<le> value_flow \\<Delta> f)", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>f.\n       flow \\<Delta> f \\<and>\n       value_flow \\<Delta> f = \\<alpha> \\<and>\n       (\\<forall>x. d_IN f x \\<le> value_flow \\<Delta> f)", "have \"d_IN (collect f) x = (\\<Sum>\\<^sup>+ y\\<in>range (\\<lambda>y. Edge y x). f (y, Vertex x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN (\\<lambda>(x, y). f (Edge x y, Vertex y)) x =\n    (\\<Sum>\\<^sup>+ y\\<in>range (\\<lambda>y. Edge y x). f (y, Vertex x))", "by(simp add: nn_integral_count_space_reindex d_IN_def)"], ["proof (state)\nthis:\n  d_IN (\\<lambda>(x, y). f (Edge x y, Vertex y)) x =\n  (\\<Sum>\\<^sup>+ y\\<in>range (\\<lambda>y. Edge y x). f (y, Vertex x))\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       flow \\<Delta> f \\<and>\n       value_flow \\<Delta> f = \\<alpha> \\<and>\n       (\\<forall>x. d_IN f x \\<le> value_flow \\<Delta> f)", "also"], ["proof (state)\nthis:\n  d_IN (\\<lambda>(x, y). f (Edge x y, Vertex y)) x =\n  (\\<Sum>\\<^sup>+ y\\<in>range (\\<lambda>y. Edge y x). f (y, Vertex x))\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       flow \\<Delta> f \\<and>\n       value_flow \\<Delta> f = \\<alpha> \\<and>\n       (\\<forall>x. d_IN f x \\<le> value_flow \\<Delta> f)", "have \"\\<dots> \\<le> d_IN f (Vertex x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y\\<in>range (\\<lambda>y. Edge y x). f (y, Vertex x))\n    \\<le> d_IN f (Vertex x)", "unfolding d_IN_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y\\<in>range (\\<lambda>y. Edge y x). f (y, Vertex x))\n    \\<le> (\\<Sum>\\<^sup>+ x. f (x, Vertex x))", "by (auto intro!: nn_integral_mono simp add: nn_integral_count_space_indicator split: split_indicator)"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y\\<in>range (\\<lambda>y. Edge y x). f (y, Vertex x))\n  \\<le> d_IN f (Vertex x)\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       flow \\<Delta> f \\<and>\n       value_flow \\<Delta> f = \\<alpha> \\<and>\n       (\\<forall>x. d_IN f x \\<le> value_flow \\<Delta> f)", "also"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y\\<in>range (\\<lambda>y. Edge y x). f (y, Vertex x))\n  \\<le> d_IN f (Vertex x)\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       flow \\<Delta> f \\<and>\n       value_flow \\<Delta> f = \\<alpha> \\<and>\n       (\\<forall>x. d_IN f x \\<le> value_flow \\<Delta> f)", "have \"\\<dots> \\<le> value_flow \\<Delta> (collect f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN f (Vertex x)\n    \\<le> value_flow \\<Delta> (\\<lambda>(x, y). f (Edge x y, Vertex y))", "using IN[of \"Vertex x\"] f"], ["proof (prove)\nusing this:\n  d_IN f (Vertex x) \\<le> value_flow \\<Delta>'' f\n  flow \\<Delta>'' f\n\ngoal (1 subgoal):\n 1. d_IN f (Vertex x)\n    \\<le> value_flow \\<Delta> (\\<lambda>(x, y). f (Edge x y, Vertex y))", "by(simp add: value_collect)"], ["proof (state)\nthis:\n  d_IN f (Vertex x)\n  \\<le> value_flow \\<Delta> (\\<lambda>(x, y). f (Edge x y, Vertex y))\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       flow \\<Delta> f \\<and>\n       value_flow \\<Delta> f = \\<alpha> \\<and>\n       (\\<forall>x. d_IN f x \\<le> value_flow \\<Delta> f)", "also"], ["proof (state)\nthis:\n  d_IN f (Vertex x)\n  \\<le> value_flow \\<Delta> (\\<lambda>(x, y). f (Edge x y, Vertex y))\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       flow \\<Delta> f \\<and>\n       value_flow \\<Delta> f = \\<alpha> \\<and>\n       (\\<forall>x. d_IN f x \\<le> value_flow \\<Delta> f)", "note calculation"], ["proof (state)\nthis:\n  d_IN (\\<lambda>(x, y). f (Edge x y, Vertex y)) x\n  \\<le> value_flow \\<Delta> (\\<lambda>(x, y). f (Edge x y, Vertex y))\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       flow \\<Delta> f \\<and>\n       value_flow \\<Delta> f = \\<alpha> \\<and>\n       (\\<forall>x. d_IN f x \\<le> value_flow \\<Delta> f)", "}"], ["proof (state)\nthis:\n  d_IN (\\<lambda>(x, y). f (Edge x y, Vertex y)) ?xa2\n  \\<le> value_flow \\<Delta> (\\<lambda>(x, y). f (Edge x y, Vertex y))\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       flow \\<Delta> f \\<and>\n       value_flow \\<Delta> f = \\<alpha> \\<and>\n       (\\<forall>x. d_IN f x \\<le> value_flow \\<Delta> f)", "ultimately"], ["proof (chain)\npicking this:\n  flow \\<Delta> (\\<lambda>(x, y). f (Edge x y, Vertex y))\n  value_flow \\<Delta> (\\<lambda>(x, y). f (Edge x y, Vertex y)) = \\<alpha>\n  d_IN (\\<lambda>(x, y). f (Edge x y, Vertex y)) ?xa2\n  \\<le> value_flow \\<Delta> (\\<lambda>(x, y). f (Edge x y, Vertex y))", "show ?thesis"], ["proof (prove)\nusing this:\n  flow \\<Delta> (\\<lambda>(x, y). f (Edge x y, Vertex y))\n  value_flow \\<Delta> (\\<lambda>(x, y). f (Edge x y, Vertex y)) = \\<alpha>\n  d_IN (\\<lambda>(x, y). f (Edge x y, Vertex y)) ?xa2\n  \\<le> value_flow \\<Delta> (\\<lambda>(x, y). f (Edge x y, Vertex y))\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       flow \\<Delta> f \\<and>\n       value_flow \\<Delta> f = \\<alpha> \\<and>\n       (\\<forall>x. d_IN f x \\<le> value_flow \\<Delta> f)", "by blast"], ["proof (state)\nthis:\n  \\<exists>f.\n     flow \\<Delta> f \\<and>\n     value_flow \\<Delta> f = \\<alpha> \\<and>\n     (\\<forall>x. d_IN f x \\<le> value_flow \\<Delta> f)\n\ngoal:\nNo subgoals!", "qed"], ["", "context begin \\<comment> \\<open>We eliminate the assumption of only one edge leaving the source by introducing a new source vertex.\\<close>"], ["", "private"], ["", "datatype (plugins del: transfer size) 'v' node = SOURCE | Inner (inner: 'v')"], ["", "private"], ["", "lemma not_Inner_conv: \"x \\<notin> range Inner \\<longleftrightarrow> x = SOURCE\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<notin> range Inner) = (x = SOURCE)", "by(cases x) auto"], ["", "private"], ["", "lemma inj_on_Inner [simp]: \"inj_on Inner A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on Inner A", "by(simp add: inj_on_def)"], ["", "private"], ["", "inductive edge' :: \"'v node \\<Rightarrow> 'v node \\<Rightarrow> bool\"\nwhere\n  SOURCE: \"edge' SOURCE (Inner (source \\<Delta>))\"\n| Inner: \"edge \\<Delta> x y \\<Longrightarrow> edge' (Inner x) (Inner y)\""], ["", "private"], ["", "inductive_simps edge'_simps [simp]:\n  \"edge' SOURCE x\"\n  \"edge' (Inner y) x\"\n  \"edge' y SOURCE\"\n  \"edge' y (Inner x)\""], ["", "private"], ["", "fun capacity' :: \"'v node flow\"\nwhere\n  \"capacity' (SOURCE, Inner x) = (if x = source \\<Delta> then \\<alpha> else 0)\"\n| \"capacity' (Inner x, Inner y) = capacity \\<Delta> (x, y)\"\n| \"capacity' _ = 0\""], ["", "private"], ["", "lemma capacity'_source_in [simp]: \"capacity' (y, Inner (source \\<Delta>)) = (if y = SOURCE then \\<alpha> else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. capacity' (y, Inner (source \\<Delta>)) =\n    (if y = SOURCE then \\<alpha> else 0)", "by(cases y)(simp_all add: capacity_outside source_in)"], ["", "private"], ["", "definition \\<Delta>' :: \"'v node network\"\nwhere \"\\<Delta>' = \\<lparr>edge = edge', capacity = capacity', source = SOURCE, sink = Inner (sink \\<Delta>)\\<rparr>\""], ["", "private"], ["", "lemma \\<Delta>'_sel [simp]:\n  \"edge \\<Delta>' = edge'\"\n  \"capacity \\<Delta>' = capacity'\"\n  \"source \\<Delta>' = SOURCE\"\n  \"sink \\<Delta>' = Inner (sink \\<Delta>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (edge \\<Delta>' = edge' &&& capacity \\<Delta>' = capacity') &&&\n    source \\<Delta>' = SOURCE &&& sink \\<Delta>' = Inner (sink \\<Delta>)", "by(simp_all add: \\<Delta>'_def)"], ["", "private"], ["", "lemma \"\\<^bold>E_\\<Delta>'\": \"\\<^bold>E\\<^bsub>\\<Delta>'\\<^esub> = {(SOURCE, Inner (source \\<Delta>))} \\<union> (\\<lambda>(x, y). (Inner x, Inner y)) ` \\<^bold>E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<^bold>E\\<^bsub>\\<Delta>'\\<^esub> =\n    {(SOURCE, Inner (source \\<Delta>))} \\<union>\n    (\\<lambda>(x, y). (Inner x, Inner y)) ` \\<^bold>E", "by(auto elim: edge'.cases)"], ["", "private"], ["", "lemma \\<Delta>'_countable_network:\n  assumes \"\\<alpha> \\<noteq> \\<top>\"\n  shows \"countable_network \\<Delta>'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. countable_network \\<Delta>'", "proof"], ["proof (state)\ngoal (4 subgoals):\n 1. countable \\<^bold>E\\<^bsub>\\<Delta>'\\<^esub>\n 2. source \\<Delta>' \\<noteq> sink \\<Delta>'\n 3. \\<And>e.\n       e \\<notin> \\<^bold>E\\<^bsub>\\<Delta>'\\<^esub> \\<Longrightarrow>\n       capacity \\<Delta>' e = 0\n 4. \\<And>e. capacity \\<Delta>' e \\<noteq> \\<top>", "show \"countable \\<^bold>E\\<^bsub>\\<Delta>'\\<^esub>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. countable \\<^bold>E\\<^bsub>\\<Delta>'\\<^esub>", "unfolding \"\\<^bold>E_\\<Delta>'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. countable\n     ({(SOURCE, Inner (source \\<Delta>))} \\<union>\n      (\\<lambda>(x, y). (Inner x, Inner y)) ` \\<^bold>E)", "by simp"], ["proof (state)\nthis:\n  countable \\<^bold>E\\<^bsub>\\<Delta>'\\<^esub>\n\ngoal (3 subgoals):\n 1. source \\<Delta>' \\<noteq> sink \\<Delta>'\n 2. \\<And>e.\n       e \\<notin> \\<^bold>E\\<^bsub>\\<Delta>'\\<^esub> \\<Longrightarrow>\n       capacity \\<Delta>' e = 0\n 3. \\<And>e. capacity \\<Delta>' e \\<noteq> \\<top>", "show \"source \\<Delta>' \\<noteq> sink \\<Delta>'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. source \\<Delta>' \\<noteq> sink \\<Delta>'", "by simp"], ["proof (state)\nthis:\n  source \\<Delta>' \\<noteq> sink \\<Delta>'\n\ngoal (2 subgoals):\n 1. \\<And>e.\n       e \\<notin> \\<^bold>E\\<^bsub>\\<Delta>'\\<^esub> \\<Longrightarrow>\n       capacity \\<Delta>' e = 0\n 2. \\<And>e. capacity \\<Delta>' e \\<noteq> \\<top>", "show \"capacity \\<Delta>' e = 0\" if \"e \\<notin> \\<^bold>E\\<^bsub>\\<Delta>'\\<^esub>\" for e"], ["proof (prove)\ngoal (1 subgoal):\n 1. capacity \\<Delta>' e = 0", "using that"], ["proof (prove)\nusing this:\n  e \\<notin> \\<^bold>E\\<^bsub>\\<Delta>'\\<^esub>\n\ngoal (1 subgoal):\n 1. capacity \\<Delta>' e = 0", "unfolding \"\\<^bold>E_\\<Delta>'\""], ["proof (prove)\nusing this:\n  e \\<notin> {(SOURCE, Inner (source \\<Delta>))} \\<union>\n             (\\<lambda>(x, y). (Inner x, Inner y)) ` \\<^bold>E\n\ngoal (1 subgoal):\n 1. capacity \\<Delta>' e = 0", "by(cases e rule: capacity'.cases)(auto intro: capacity_outside)"], ["proof (state)\nthis:\n  ?e \\<notin> \\<^bold>E\\<^bsub>\\<Delta>'\\<^esub> \\<Longrightarrow>\n  capacity \\<Delta>' ?e = 0\n\ngoal (1 subgoal):\n 1. \\<And>e. capacity \\<Delta>' e \\<noteq> \\<top>", "show \"capacity \\<Delta>' e \\<noteq> \\<top>\" for e"], ["proof (prove)\ngoal (1 subgoal):\n 1. capacity \\<Delta>' e \\<noteq> \\<top>", "by(cases e rule: capacity'.cases)(simp_all add: assms)"], ["proof (state)\nthis:\n  capacity \\<Delta>' ?e \\<noteq> \\<top>\n\ngoal:\nNo subgoals!", "qed"], ["", "private"], ["", "lemma \\<Delta>'_flow_attainability:\n  assumes \"\\<alpha> \\<noteq> \\<top>\"\n  shows \"flow_attainability \\<Delta>'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. flow_attainability \\<Delta>'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. flow_attainability \\<Delta>'", "interpret \\<Delta>': countable_network \\<Delta>'"], ["proof (prove)\ngoal (1 subgoal):\n 1. countable_network \\<Delta>'", "using assms"], ["proof (prove)\nusing this:\n  \\<alpha> \\<noteq> \\<top>\n\ngoal (1 subgoal):\n 1. countable_network \\<Delta>'", "by(rule \\<Delta>'_countable_network)"], ["proof (state)\ngoal (1 subgoal):\n 1. flow_attainability \\<Delta>'", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. flow_attainability \\<Delta>'", "proof"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x.\n       x \\<noteq> sink \\<Delta>' \\<Longrightarrow>\n       d_IN (capacity \\<Delta>') x \\<noteq> \\<top> \\<or>\n       d_OUT (capacity \\<Delta>') x \\<noteq> \\<top>\n 2. \\<And>x. \\<not> edge \\<Delta>' x x\n 3. \\<And>x. \\<not> edge \\<Delta>' x (source \\<Delta>')", "show \"d_IN (capacity \\<Delta>') x \\<noteq> \\<top> \\<or> d_OUT (capacity \\<Delta>') x \\<noteq> \\<top>\" if sink: \"x \\<noteq> sink \\<Delta>'\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN (capacity \\<Delta>') x \\<noteq> \\<top> \\<or>\n    d_OUT (capacity \\<Delta>') x \\<noteq> \\<top>", "proof(cases x)"], ["proof (state)\ngoal (2 subgoals):\n 1. x = SOURCE \\<Longrightarrow>\n    d_IN (capacity \\<Delta>') x \\<noteq> \\<top> \\<or>\n    d_OUT (capacity \\<Delta>') x \\<noteq> \\<top>\n 2. \\<And>x2.\n       x = Inner x2 \\<Longrightarrow>\n       d_IN (capacity \\<Delta>') x \\<noteq> \\<top> \\<or>\n       d_OUT (capacity \\<Delta>') x \\<noteq> \\<top>", "case (Inner x')"], ["proof (state)\nthis:\n  x = Inner x'\n\ngoal (2 subgoals):\n 1. x = SOURCE \\<Longrightarrow>\n    d_IN (capacity \\<Delta>') x \\<noteq> \\<top> \\<or>\n    d_OUT (capacity \\<Delta>') x \\<noteq> \\<top>\n 2. \\<And>x2.\n       x = Inner x2 \\<Longrightarrow>\n       d_IN (capacity \\<Delta>') x \\<noteq> \\<top> \\<or>\n       d_OUT (capacity \\<Delta>') x \\<noteq> \\<top>", "consider (source) \"x' = source \\<Delta>\" | (IN) \"x' \\<noteq> source \\<Delta>\" \"d_IN (capacity \\<Delta>) x' \\<noteq> \\<top>\" | (OUT) \"d_OUT (capacity \\<Delta>) x' \\<noteq> \\<top>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x' = source \\<Delta> \\<Longrightarrow> thesis;\n     \\<lbrakk>x' \\<noteq> source \\<Delta>;\n      d_IN (capacity \\<Delta>) x' \\<noteq> \\<top>\\<rbrakk>\n     \\<Longrightarrow> thesis;\n     d_OUT (capacity \\<Delta>) x' \\<noteq> \\<top> \\<Longrightarrow>\n     thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "using finite_capacity[of x'] sink Inner"], ["proof (prove)\nusing this:\n  x' \\<noteq> sink \\<Delta> \\<Longrightarrow>\n  d_IN (capacity \\<Delta>) x' \\<noteq> \\<top> \\<or>\n  d_OUT (capacity \\<Delta>) x' \\<noteq> \\<top>\n  x \\<noteq> sink \\<Delta>'\n  x = Inner x'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x' = source \\<Delta> \\<Longrightarrow> thesis;\n     \\<lbrakk>x' \\<noteq> source \\<Delta>;\n      d_IN (capacity \\<Delta>) x' \\<noteq> \\<top>\\<rbrakk>\n     \\<Longrightarrow> thesis;\n     d_OUT (capacity \\<Delta>) x' \\<noteq> \\<top> \\<Longrightarrow>\n     thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by(auto)"], ["proof (state)\nthis:\n  \\<lbrakk>x' = source \\<Delta> \\<Longrightarrow> ?thesis;\n   \\<lbrakk>x' \\<noteq> source \\<Delta>;\n    d_IN (capacity \\<Delta>) x' \\<noteq> \\<top>\\<rbrakk>\n   \\<Longrightarrow> ?thesis;\n   d_OUT (capacity \\<Delta>) x' \\<noteq> \\<top> \\<Longrightarrow>\n   ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (2 subgoals):\n 1. x = SOURCE \\<Longrightarrow>\n    d_IN (capacity \\<Delta>') x \\<noteq> \\<top> \\<or>\n    d_OUT (capacity \\<Delta>') x \\<noteq> \\<top>\n 2. \\<And>x2.\n       x = Inner x2 \\<Longrightarrow>\n       d_IN (capacity \\<Delta>') x \\<noteq> \\<top> \\<or>\n       d_OUT (capacity \\<Delta>') x \\<noteq> \\<top>", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>x' = source \\<Delta> \\<Longrightarrow> ?thesis;\n   \\<lbrakk>x' \\<noteq> source \\<Delta>;\n    d_IN (capacity \\<Delta>) x' \\<noteq> \\<top>\\<rbrakk>\n   \\<Longrightarrow> ?thesis;\n   d_OUT (capacity \\<Delta>) x' \\<noteq> \\<top> \\<Longrightarrow>\n   ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. d_IN (capacity \\<Delta>') x \\<noteq> \\<top> \\<or>\n    d_OUT (capacity \\<Delta>') x \\<noteq> \\<top>", "proof(cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. x' = source \\<Delta> \\<Longrightarrow>\n    d_IN (capacity \\<Delta>') x \\<noteq> \\<top> \\<or>\n    d_OUT (capacity \\<Delta>') x \\<noteq> \\<top>\n 2. \\<lbrakk>x' \\<noteq> source \\<Delta>;\n     d_IN (capacity \\<Delta>) x' \\<noteq> \\<top>\\<rbrakk>\n    \\<Longrightarrow> d_IN (capacity \\<Delta>') x \\<noteq> \\<top> \\<or>\n                      d_OUT (capacity \\<Delta>') x \\<noteq> \\<top>\n 3. d_OUT (capacity \\<Delta>) x' \\<noteq> \\<top> \\<Longrightarrow>\n    d_IN (capacity \\<Delta>') x \\<noteq> \\<top> \\<or>\n    d_OUT (capacity \\<Delta>') x \\<noteq> \\<top>", "case source"], ["proof (state)\nthis:\n  x' = source \\<Delta>\n\ngoal (3 subgoals):\n 1. x' = source \\<Delta> \\<Longrightarrow>\n    d_IN (capacity \\<Delta>') x \\<noteq> \\<top> \\<or>\n    d_OUT (capacity \\<Delta>') x \\<noteq> \\<top>\n 2. \\<lbrakk>x' \\<noteq> source \\<Delta>;\n     d_IN (capacity \\<Delta>) x' \\<noteq> \\<top>\\<rbrakk>\n    \\<Longrightarrow> d_IN (capacity \\<Delta>') x \\<noteq> \\<top> \\<or>\n                      d_OUT (capacity \\<Delta>') x \\<noteq> \\<top>\n 3. d_OUT (capacity \\<Delta>) x' \\<noteq> \\<top> \\<Longrightarrow>\n    d_IN (capacity \\<Delta>') x \\<noteq> \\<top> \\<or>\n    d_OUT (capacity \\<Delta>') x \\<noteq> \\<top>", "with Inner"], ["proof (chain)\npicking this:\n  x = Inner x'\n  x' = source \\<Delta>", "have \"d_IN (capacity \\<Delta>') x = (\\<Sum>\\<^sup>+ y. \\<alpha> * indicator {SOURCE :: 'v node} y)\""], ["proof (prove)\nusing this:\n  x = Inner x'\n  x' = source \\<Delta>\n\ngoal (1 subgoal):\n 1. d_IN (capacity \\<Delta>') x =\n    \\<integral>\\<^sup>+y\\<in>{SOURCE}. \\<alpha>\\<partial>count_space UNIV", "unfolding d_IN_def"], ["proof (prove)\nusing this:\n  x = Inner x'\n  x' = source \\<Delta>\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ xa. capacity \\<Delta>' (xa, x)) =\n    \\<integral>\\<^sup>+y\\<in>{SOURCE}. \\<alpha>\\<partial>count_space UNIV", "by(intro nn_integral_cong)(simp split: split_indicator)"], ["proof (state)\nthis:\n  d_IN (capacity \\<Delta>') x =\n  \\<integral>\\<^sup>+y\\<in>{SOURCE}. \\<alpha>\\<partial>count_space UNIV\n\ngoal (3 subgoals):\n 1. x' = source \\<Delta> \\<Longrightarrow>\n    d_IN (capacity \\<Delta>') x \\<noteq> \\<top> \\<or>\n    d_OUT (capacity \\<Delta>') x \\<noteq> \\<top>\n 2. \\<lbrakk>x' \\<noteq> source \\<Delta>;\n     d_IN (capacity \\<Delta>) x' \\<noteq> \\<top>\\<rbrakk>\n    \\<Longrightarrow> d_IN (capacity \\<Delta>') x \\<noteq> \\<top> \\<or>\n                      d_OUT (capacity \\<Delta>') x \\<noteq> \\<top>\n 3. d_OUT (capacity \\<Delta>) x' \\<noteq> \\<top> \\<Longrightarrow>\n    d_IN (capacity \\<Delta>') x \\<noteq> \\<top> \\<or>\n    d_OUT (capacity \\<Delta>') x \\<noteq> \\<top>", "also"], ["proof (state)\nthis:\n  d_IN (capacity \\<Delta>') x =\n  \\<integral>\\<^sup>+y\\<in>{SOURCE}. \\<alpha>\\<partial>count_space UNIV\n\ngoal (3 subgoals):\n 1. x' = source \\<Delta> \\<Longrightarrow>\n    d_IN (capacity \\<Delta>') x \\<noteq> \\<top> \\<or>\n    d_OUT (capacity \\<Delta>') x \\<noteq> \\<top>\n 2. \\<lbrakk>x' \\<noteq> source \\<Delta>;\n     d_IN (capacity \\<Delta>) x' \\<noteq> \\<top>\\<rbrakk>\n    \\<Longrightarrow> d_IN (capacity \\<Delta>') x \\<noteq> \\<top> \\<or>\n                      d_OUT (capacity \\<Delta>') x \\<noteq> \\<top>\n 3. d_OUT (capacity \\<Delta>) x' \\<noteq> \\<top> \\<Longrightarrow>\n    d_IN (capacity \\<Delta>') x \\<noteq> \\<top> \\<or>\n    d_OUT (capacity \\<Delta>') x \\<noteq> \\<top>", "have \"\\<dots> = \\<alpha>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+y\\<in>{SOURCE}. \\<alpha>\\<partial>count_space UNIV =\n    \\<alpha>", "by(simp add: max_def)"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+y\\<in>{SOURCE}. \\<alpha>\\<partial>count_space UNIV =\n  \\<alpha>\n\ngoal (3 subgoals):\n 1. x' = source \\<Delta> \\<Longrightarrow>\n    d_IN (capacity \\<Delta>') x \\<noteq> \\<top> \\<or>\n    d_OUT (capacity \\<Delta>') x \\<noteq> \\<top>\n 2. \\<lbrakk>x' \\<noteq> source \\<Delta>;\n     d_IN (capacity \\<Delta>) x' \\<noteq> \\<top>\\<rbrakk>\n    \\<Longrightarrow> d_IN (capacity \\<Delta>') x \\<noteq> \\<top> \\<or>\n                      d_OUT (capacity \\<Delta>') x \\<noteq> \\<top>\n 3. d_OUT (capacity \\<Delta>) x' \\<noteq> \\<top> \\<Longrightarrow>\n    d_IN (capacity \\<Delta>') x \\<noteq> \\<top> \\<or>\n    d_OUT (capacity \\<Delta>') x \\<noteq> \\<top>", "finally"], ["proof (chain)\npicking this:\n  d_IN (capacity \\<Delta>') x = \\<alpha>", "show ?thesis"], ["proof (prove)\nusing this:\n  d_IN (capacity \\<Delta>') x = \\<alpha>\n\ngoal (1 subgoal):\n 1. d_IN (capacity \\<Delta>') x \\<noteq> \\<top> \\<or>\n    d_OUT (capacity \\<Delta>') x \\<noteq> \\<top>", "using assms"], ["proof (prove)\nusing this:\n  d_IN (capacity \\<Delta>') x = \\<alpha>\n  \\<alpha> \\<noteq> \\<top>\n\ngoal (1 subgoal):\n 1. d_IN (capacity \\<Delta>') x \\<noteq> \\<top> \\<or>\n    d_OUT (capacity \\<Delta>') x \\<noteq> \\<top>", "by simp"], ["proof (state)\nthis:\n  d_IN (capacity \\<Delta>') x \\<noteq> \\<top> \\<or>\n  d_OUT (capacity \\<Delta>') x \\<noteq> \\<top>\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x' \\<noteq> source \\<Delta>;\n     d_IN (capacity \\<Delta>) x' \\<noteq> \\<top>\\<rbrakk>\n    \\<Longrightarrow> d_IN (capacity \\<Delta>') x \\<noteq> \\<top> \\<or>\n                      d_OUT (capacity \\<Delta>') x \\<noteq> \\<top>\n 2. d_OUT (capacity \\<Delta>) x' \\<noteq> \\<top> \\<Longrightarrow>\n    d_IN (capacity \\<Delta>') x \\<noteq> \\<top> \\<or>\n    d_OUT (capacity \\<Delta>') x \\<noteq> \\<top>", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>x' \\<noteq> source \\<Delta>;\n     d_IN (capacity \\<Delta>) x' \\<noteq> \\<top>\\<rbrakk>\n    \\<Longrightarrow> d_IN (capacity \\<Delta>') x \\<noteq> \\<top> \\<or>\n                      d_OUT (capacity \\<Delta>') x \\<noteq> \\<top>\n 2. d_OUT (capacity \\<Delta>) x' \\<noteq> \\<top> \\<Longrightarrow>\n    d_IN (capacity \\<Delta>') x \\<noteq> \\<top> \\<or>\n    d_OUT (capacity \\<Delta>') x \\<noteq> \\<top>", "case IN"], ["proof (state)\nthis:\n  x' \\<noteq> source \\<Delta>\n  d_IN (capacity \\<Delta>) x' \\<noteq> \\<top>\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x' \\<noteq> source \\<Delta>;\n     d_IN (capacity \\<Delta>) x' \\<noteq> \\<top>\\<rbrakk>\n    \\<Longrightarrow> d_IN (capacity \\<Delta>') x \\<noteq> \\<top> \\<or>\n                      d_OUT (capacity \\<Delta>') x \\<noteq> \\<top>\n 2. d_OUT (capacity \\<Delta>) x' \\<noteq> \\<top> \\<Longrightarrow>\n    d_IN (capacity \\<Delta>') x \\<noteq> \\<top> \\<or>\n    d_OUT (capacity \\<Delta>') x \\<noteq> \\<top>", "with Inner"], ["proof (chain)\npicking this:\n  x = Inner x'\n  x' \\<noteq> source \\<Delta>\n  d_IN (capacity \\<Delta>) x' \\<noteq> \\<top>", "have \"d_IN (capacity \\<Delta>') x = (\\<Sum>\\<^sup>+ y\\<in>range Inner. capacity \\<Delta> (node.inner y, x'))\""], ["proof (prove)\nusing this:\n  x = Inner x'\n  x' \\<noteq> source \\<Delta>\n  d_IN (capacity \\<Delta>) x' \\<noteq> \\<top>\n\ngoal (1 subgoal):\n 1. d_IN (capacity \\<Delta>') x =\n    (\\<Sum>\\<^sup>+ y\\<in>range Inner. capacity \\<Delta> (node.inner y, x'))", "by(auto simp add: d_IN_def nn_integral_count_space_indicator not_Inner_conv intro!: nn_integral_cong split: split_indicator)"], ["proof (state)\nthis:\n  d_IN (capacity \\<Delta>') x =\n  (\\<Sum>\\<^sup>+ y\\<in>range Inner. capacity \\<Delta> (node.inner y, x'))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x' \\<noteq> source \\<Delta>;\n     d_IN (capacity \\<Delta>) x' \\<noteq> \\<top>\\<rbrakk>\n    \\<Longrightarrow> d_IN (capacity \\<Delta>') x \\<noteq> \\<top> \\<or>\n                      d_OUT (capacity \\<Delta>') x \\<noteq> \\<top>\n 2. d_OUT (capacity \\<Delta>) x' \\<noteq> \\<top> \\<Longrightarrow>\n    d_IN (capacity \\<Delta>') x \\<noteq> \\<top> \\<or>\n    d_OUT (capacity \\<Delta>') x \\<noteq> \\<top>", "also"], ["proof (state)\nthis:\n  d_IN (capacity \\<Delta>') x =\n  (\\<Sum>\\<^sup>+ y\\<in>range Inner. capacity \\<Delta> (node.inner y, x'))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x' \\<noteq> source \\<Delta>;\n     d_IN (capacity \\<Delta>) x' \\<noteq> \\<top>\\<rbrakk>\n    \\<Longrightarrow> d_IN (capacity \\<Delta>') x \\<noteq> \\<top> \\<or>\n                      d_OUT (capacity \\<Delta>') x \\<noteq> \\<top>\n 2. d_OUT (capacity \\<Delta>) x' \\<noteq> \\<top> \\<Longrightarrow>\n    d_IN (capacity \\<Delta>') x \\<noteq> \\<top> \\<or>\n    d_OUT (capacity \\<Delta>') x \\<noteq> \\<top>", "have \"\\<dots> = d_IN (capacity \\<Delta>) x'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y\\<in>range Inner.\n       capacity \\<Delta> (node.inner y, x')) =\n    d_IN (capacity \\<Delta>) x'", "unfolding d_IN_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y\\<in>range Inner.\n       capacity \\<Delta> (node.inner y, x')) =\n    (\\<Sum>\\<^sup>+ x. capacity \\<Delta> (x, x'))", "by(simp add: nn_integral_count_space_reindex)"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y\\<in>range Inner. capacity \\<Delta> (node.inner y, x')) =\n  d_IN (capacity \\<Delta>) x'\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x' \\<noteq> source \\<Delta>;\n     d_IN (capacity \\<Delta>) x' \\<noteq> \\<top>\\<rbrakk>\n    \\<Longrightarrow> d_IN (capacity \\<Delta>') x \\<noteq> \\<top> \\<or>\n                      d_OUT (capacity \\<Delta>') x \\<noteq> \\<top>\n 2. d_OUT (capacity \\<Delta>) x' \\<noteq> \\<top> \\<Longrightarrow>\n    d_IN (capacity \\<Delta>') x \\<noteq> \\<top> \\<or>\n    d_OUT (capacity \\<Delta>') x \\<noteq> \\<top>", "finally"], ["proof (chain)\npicking this:\n  d_IN (capacity \\<Delta>') x = d_IN (capacity \\<Delta>) x'", "show ?thesis"], ["proof (prove)\nusing this:\n  d_IN (capacity \\<Delta>') x = d_IN (capacity \\<Delta>) x'\n\ngoal (1 subgoal):\n 1. d_IN (capacity \\<Delta>') x \\<noteq> \\<top> \\<or>\n    d_OUT (capacity \\<Delta>') x \\<noteq> \\<top>", "using Inner sink IN"], ["proof (prove)\nusing this:\n  d_IN (capacity \\<Delta>') x = d_IN (capacity \\<Delta>) x'\n  x = Inner x'\n  x \\<noteq> sink \\<Delta>'\n  x' \\<noteq> source \\<Delta>\n  d_IN (capacity \\<Delta>) x' \\<noteq> \\<top>\n\ngoal (1 subgoal):\n 1. d_IN (capacity \\<Delta>') x \\<noteq> \\<top> \\<or>\n    d_OUT (capacity \\<Delta>') x \\<noteq> \\<top>", "by(simp)"], ["proof (state)\nthis:\n  d_IN (capacity \\<Delta>') x \\<noteq> \\<top> \\<or>\n  d_OUT (capacity \\<Delta>') x \\<noteq> \\<top>\n\ngoal (1 subgoal):\n 1. d_OUT (capacity \\<Delta>) x' \\<noteq> \\<top> \\<Longrightarrow>\n    d_IN (capacity \\<Delta>') x \\<noteq> \\<top> \\<or>\n    d_OUT (capacity \\<Delta>') x \\<noteq> \\<top>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. d_OUT (capacity \\<Delta>) x' \\<noteq> \\<top> \\<Longrightarrow>\n    d_IN (capacity \\<Delta>') x \\<noteq> \\<top> \\<or>\n    d_OUT (capacity \\<Delta>') x \\<noteq> \\<top>", "case OUT"], ["proof (state)\nthis:\n  d_OUT (capacity \\<Delta>) x' \\<noteq> \\<top>\n\ngoal (1 subgoal):\n 1. d_OUT (capacity \\<Delta>) x' \\<noteq> \\<top> \\<Longrightarrow>\n    d_IN (capacity \\<Delta>') x \\<noteq> \\<top> \\<or>\n    d_OUT (capacity \\<Delta>') x \\<noteq> \\<top>", "from Inner"], ["proof (chain)\npicking this:\n  x = Inner x'", "have \"d_OUT (capacity \\<Delta>') x = (\\<Sum>\\<^sup>+ y\\<in>range Inner. capacity \\<Delta> (x', node.inner y))\""], ["proof (prove)\nusing this:\n  x = Inner x'\n\ngoal (1 subgoal):\n 1. d_OUT (capacity \\<Delta>') x =\n    (\\<Sum>\\<^sup>+ y\\<in>range Inner. capacity \\<Delta> (x', node.inner y))", "by(auto simp add: d_OUT_def nn_integral_count_space_indicator not_Inner_conv intro!: nn_integral_cong split: split_indicator)"], ["proof (state)\nthis:\n  d_OUT (capacity \\<Delta>') x =\n  (\\<Sum>\\<^sup>+ y\\<in>range Inner. capacity \\<Delta> (x', node.inner y))\n\ngoal (1 subgoal):\n 1. d_OUT (capacity \\<Delta>) x' \\<noteq> \\<top> \\<Longrightarrow>\n    d_IN (capacity \\<Delta>') x \\<noteq> \\<top> \\<or>\n    d_OUT (capacity \\<Delta>') x \\<noteq> \\<top>", "also"], ["proof (state)\nthis:\n  d_OUT (capacity \\<Delta>') x =\n  (\\<Sum>\\<^sup>+ y\\<in>range Inner. capacity \\<Delta> (x', node.inner y))\n\ngoal (1 subgoal):\n 1. d_OUT (capacity \\<Delta>) x' \\<noteq> \\<top> \\<Longrightarrow>\n    d_IN (capacity \\<Delta>') x \\<noteq> \\<top> \\<or>\n    d_OUT (capacity \\<Delta>') x \\<noteq> \\<top>", "have \"\\<dots> = d_OUT (capacity \\<Delta>) x'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y\\<in>range Inner.\n       capacity \\<Delta> (x', node.inner y)) =\n    d_OUT (capacity \\<Delta>) x'", "by(simp add: d_OUT_def nn_integral_count_space_reindex)"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y\\<in>range Inner. capacity \\<Delta> (x', node.inner y)) =\n  d_OUT (capacity \\<Delta>) x'\n\ngoal (1 subgoal):\n 1. d_OUT (capacity \\<Delta>) x' \\<noteq> \\<top> \\<Longrightarrow>\n    d_IN (capacity \\<Delta>') x \\<noteq> \\<top> \\<or>\n    d_OUT (capacity \\<Delta>') x \\<noteq> \\<top>", "finally"], ["proof (chain)\npicking this:\n  d_OUT (capacity \\<Delta>') x = d_OUT (capacity \\<Delta>) x'", "show ?thesis"], ["proof (prove)\nusing this:\n  d_OUT (capacity \\<Delta>') x = d_OUT (capacity \\<Delta>) x'\n\ngoal (1 subgoal):\n 1. d_IN (capacity \\<Delta>') x \\<noteq> \\<top> \\<or>\n    d_OUT (capacity \\<Delta>') x \\<noteq> \\<top>", "using OUT"], ["proof (prove)\nusing this:\n  d_OUT (capacity \\<Delta>') x = d_OUT (capacity \\<Delta>) x'\n  d_OUT (capacity \\<Delta>) x' \\<noteq> \\<top>\n\ngoal (1 subgoal):\n 1. d_IN (capacity \\<Delta>') x \\<noteq> \\<top> \\<or>\n    d_OUT (capacity \\<Delta>') x \\<noteq> \\<top>", "by auto"], ["proof (state)\nthis:\n  d_IN (capacity \\<Delta>') x \\<noteq> \\<top> \\<or>\n  d_OUT (capacity \\<Delta>') x \\<noteq> \\<top>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  d_IN (capacity \\<Delta>') x \\<noteq> \\<top> \\<or>\n  d_OUT (capacity \\<Delta>') x \\<noteq> \\<top>\n\ngoal (1 subgoal):\n 1. x = SOURCE \\<Longrightarrow>\n    d_IN (capacity \\<Delta>') x \\<noteq> \\<top> \\<or>\n    d_OUT (capacity \\<Delta>') x \\<noteq> \\<top>", "qed(simp add: d_IN_def)"], ["proof (state)\nthis:\n  ?x \\<noteq> sink \\<Delta>' \\<Longrightarrow>\n  d_IN (capacity \\<Delta>') ?x \\<noteq> \\<top> \\<or>\n  d_OUT (capacity \\<Delta>') ?x \\<noteq> \\<top>\n\ngoal (2 subgoals):\n 1. \\<And>x. \\<not> edge \\<Delta>' x x\n 2. \\<And>x. \\<not> edge \\<Delta>' x (source \\<Delta>')", "show \"\\<not> edge \\<Delta>' x x\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> edge \\<Delta>' x x", "by(cases x)(simp_all add: no_loop)"], ["proof (state)\nthis:\n  \\<not> edge \\<Delta>' ?x ?x\n\ngoal (1 subgoal):\n 1. \\<And>x. \\<not> edge \\<Delta>' x (source \\<Delta>')", "show \"\\<not> edge \\<Delta>' x (source \\<Delta>')\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> edge \\<Delta>' x (source \\<Delta>')", "by simp"], ["proof (state)\nthis:\n  \\<not> edge \\<Delta>' ?x (source \\<Delta>')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  flow_attainability \\<Delta>'\n\ngoal:\nNo subgoals!", "qed"], ["", "private"], ["", "fun lift :: \"'v flow \\<Rightarrow> 'v node flow\"\nwhere\n  \"lift f (SOURCE, Inner y) = (if y = source \\<Delta> then value_flow \\<Delta> f else 0)\"\n| \"lift f (Inner x, Inner y) = f (x, y)\"\n| \"lift f _ = 0\""], ["", "private"], ["", "lemma d_OUT_lift_Inner [simp]: \"d_OUT (lift f) (Inner x) = d_OUT f x\" (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT (lift f) (Inner x) = d_OUT f x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. d_OUT (lift f) (Inner x) = d_OUT f x", "have \"?lhs = (\\<Sum>\\<^sup>+ y\\<in>range Inner. lift f (Inner x, y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT (lift f) (Inner x) =\n    (\\<Sum>\\<^sup>+ y\\<in>range Inner. lift f (Inner x, y))", "by(auto simp add: d_OUT_def nn_integral_count_space_indicator not_Inner_conv intro!: nn_integral_cong split: split_indicator)"], ["proof (state)\nthis:\n  d_OUT (lift f) (Inner x) =\n  (\\<Sum>\\<^sup>+ y\\<in>range Inner. lift f (Inner x, y))\n\ngoal (1 subgoal):\n 1. d_OUT (lift f) (Inner x) = d_OUT f x", "also"], ["proof (state)\nthis:\n  d_OUT (lift f) (Inner x) =\n  (\\<Sum>\\<^sup>+ y\\<in>range Inner. lift f (Inner x, y))\n\ngoal (1 subgoal):\n 1. d_OUT (lift f) (Inner x) = d_OUT f x", "have \"\\<dots> = ?rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y\\<in>range Inner. lift f (Inner x, y)) = d_OUT f x", "by(simp add: nn_integral_count_space_reindex d_OUT_def)"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y\\<in>range Inner. lift f (Inner x, y)) = d_OUT f x\n\ngoal (1 subgoal):\n 1. d_OUT (lift f) (Inner x) = d_OUT f x", "finally"], ["proof (chain)\npicking this:\n  d_OUT (lift f) (Inner x) = d_OUT f x", "show ?thesis"], ["proof (prove)\nusing this:\n  d_OUT (lift f) (Inner x) = d_OUT f x\n\ngoal (1 subgoal):\n 1. d_OUT (lift f) (Inner x) = d_OUT f x", "."], ["proof (state)\nthis:\n  d_OUT (lift f) (Inner x) = d_OUT f x\n\ngoal:\nNo subgoals!", "qed"], ["", "private"], ["", "lemma d_OUT_lift_SOURCE [simp]: \"d_OUT (lift f) SOURCE = value_flow \\<Delta> f\" (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT (lift f) SOURCE = value_flow \\<Delta> f", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. d_OUT (lift f) SOURCE = value_flow \\<Delta> f", "have \"?lhs = (\\<Sum>\\<^sup>+ y. lift f (SOURCE, y) * indicator {Inner (source \\<Delta>)} y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT (lift f) SOURCE =\n    \\<integral>\\<^sup>+y\\<in>{Inner (source \\<Delta>)}. lift f (SOURCE, y)\n    \\<partial>count_space UNIV", "unfolding d_OUT_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y. lift f (SOURCE, y)) =\n    \\<integral>\\<^sup>+y\\<in>{Inner (source \\<Delta>)}. lift f (SOURCE, y)\n    \\<partial>count_space UNIV", "by(rule nn_integral_cong)(case_tac x; simp)"], ["proof (state)\nthis:\n  d_OUT (lift f) SOURCE =\n  \\<integral>\\<^sup>+y\\<in>{Inner (source \\<Delta>)}. lift f (SOURCE, y)\n  \\<partial>count_space UNIV\n\ngoal (1 subgoal):\n 1. d_OUT (lift f) SOURCE = value_flow \\<Delta> f", "also"], ["proof (state)\nthis:\n  d_OUT (lift f) SOURCE =\n  \\<integral>\\<^sup>+y\\<in>{Inner (source \\<Delta>)}. lift f (SOURCE, y)\n  \\<partial>count_space UNIV\n\ngoal (1 subgoal):\n 1. d_OUT (lift f) SOURCE = value_flow \\<Delta> f", "have \"\\<dots> = ?rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+y\\<in>{Inner (source \\<Delta>)}. lift f (SOURCE, y)\n    \\<partial>count_space UNIV =\n    value_flow \\<Delta> f", "by(simp add: nn_integral_count_space_indicator max_def)"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+y\\<in>{Inner (source \\<Delta>)}. lift f (SOURCE, y)\n  \\<partial>count_space UNIV =\n  value_flow \\<Delta> f\n\ngoal (1 subgoal):\n 1. d_OUT (lift f) SOURCE = value_flow \\<Delta> f", "finally"], ["proof (chain)\npicking this:\n  d_OUT (lift f) SOURCE = value_flow \\<Delta> f", "show ?thesis"], ["proof (prove)\nusing this:\n  d_OUT (lift f) SOURCE = value_flow \\<Delta> f\n\ngoal (1 subgoal):\n 1. d_OUT (lift f) SOURCE = value_flow \\<Delta> f", "."], ["proof (state)\nthis:\n  d_OUT (lift f) SOURCE = value_flow \\<Delta> f\n\ngoal:\nNo subgoals!", "qed"], ["", "private"], ["", "lemma d_IN_lift_Inner [simp]:\n  assumes \"x \\<noteq> source \\<Delta>\"\n  shows \"d_IN (lift f) (Inner x) = d_IN f x\" (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN (lift f) (Inner x) = d_IN f x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. d_IN (lift f) (Inner x) = d_IN f x", "have \"?lhs = (\\<Sum>\\<^sup>+ y\\<in>range Inner. lift f (y, Inner x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN (lift f) (Inner x) =\n    (\\<Sum>\\<^sup>+ y\\<in>range Inner. lift f (y, Inner x))", "using assms"], ["proof (prove)\nusing this:\n  x \\<noteq> source \\<Delta>\n\ngoal (1 subgoal):\n 1. d_IN (lift f) (Inner x) =\n    (\\<Sum>\\<^sup>+ y\\<in>range Inner. lift f (y, Inner x))", "by(auto simp add: d_IN_def nn_integral_count_space_indicator not_Inner_conv intro!: nn_integral_cong split: split_indicator)"], ["proof (state)\nthis:\n  d_IN (lift f) (Inner x) =\n  (\\<Sum>\\<^sup>+ y\\<in>range Inner. lift f (y, Inner x))\n\ngoal (1 subgoal):\n 1. d_IN (lift f) (Inner x) = d_IN f x", "also"], ["proof (state)\nthis:\n  d_IN (lift f) (Inner x) =\n  (\\<Sum>\\<^sup>+ y\\<in>range Inner. lift f (y, Inner x))\n\ngoal (1 subgoal):\n 1. d_IN (lift f) (Inner x) = d_IN f x", "have \"\\<dots> = ?rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y\\<in>range Inner. lift f (y, Inner x)) = d_IN f x", "by(simp add: nn_integral_count_space_reindex d_IN_def)"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y\\<in>range Inner. lift f (y, Inner x)) = d_IN f x\n\ngoal (1 subgoal):\n 1. d_IN (lift f) (Inner x) = d_IN f x", "finally"], ["proof (chain)\npicking this:\n  d_IN (lift f) (Inner x) = d_IN f x", "show ?thesis"], ["proof (prove)\nusing this:\n  d_IN (lift f) (Inner x) = d_IN f x\n\ngoal (1 subgoal):\n 1. d_IN (lift f) (Inner x) = d_IN f x", "."], ["proof (state)\nthis:\n  d_IN (lift f) (Inner x) = d_IN f x\n\ngoal:\nNo subgoals!", "qed"], ["", "private"], ["", "lemma d_IN_lift_source [simp]: \"d_IN (lift f) (Inner (source \\<Delta>)) = value_flow \\<Delta> f + d_IN f (source \\<Delta>)\" (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN (lift f) (Inner (source \\<Delta>)) =\n    value_flow \\<Delta> f + d_IN f (source \\<Delta>)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. d_IN (lift f) (Inner (source \\<Delta>)) =\n    value_flow \\<Delta> f + d_IN f (source \\<Delta>)", "have \"?lhs = (\\<Sum>\\<^sup>+ y. lift f (y, Inner (source \\<Delta>)) * indicator {SOURCE} y) + (\\<Sum>\\<^sup>+ y\\<in>range Inner. lift f (y, Inner (source \\<Delta>)))\"\n    (is \"_ = ?SOURCE + ?rest\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN (lift f) (Inner (source \\<Delta>)) =\n    (\\<integral>\\<^sup>+y\\<in>{SOURCE}. lift f (y, Inner (source \\<Delta>))\n     \\<partial>count_space UNIV) +\n    (\\<Sum>\\<^sup>+ y\\<in>range Inner. lift f (y, Inner (source \\<Delta>)))", "unfolding d_IN_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ x. lift f (x, Inner (source \\<Delta>))) =\n    (\\<integral>\\<^sup>+y\\<in>{SOURCE}. lift f (y, Inner (source \\<Delta>))\n     \\<partial>count_space UNIV) +\n    (\\<Sum>\\<^sup>+ y\\<in>range Inner. lift f (y, Inner (source \\<Delta>)))", "apply(subst nn_integral_count_space_indicator, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ x. lift f (x, Inner (source \\<Delta>))) =\n    (\\<integral>\\<^sup>+y\\<in>{SOURCE}. lift f (y, Inner (source \\<Delta>))\n     \\<partial>count_space UNIV) +\n    (\\<integral>\\<^sup>+x\\<in>range Inner.\n                        lift f (x, Inner (source \\<Delta>))\n     \\<partial>count_space UNIV)", "apply(subst nn_integral_add[symmetric])"], ["proof (prove)\ngoal (3 subgoals):\n 1. (\\<lambda>y. lift f (y, Inner (source \\<Delta>)) * indicator {SOURCE} y)\n    \\<in> borel_measurable (count_space UNIV)\n 2. (\\<lambda>x.\n        lift f (x, Inner (source \\<Delta>)) * indicator (range Inner) x)\n    \\<in> borel_measurable (count_space UNIV)\n 3. (\\<Sum>\\<^sup>+ x. lift f (x, Inner (source \\<Delta>))) =\n    (\\<Sum>\\<^sup>+ x.\n       lift f (x, Inner (source \\<Delta>)) * indicator {SOURCE} x +\n       lift f (x, Inner (source \\<Delta>)) * indicator (range Inner) x)", "apply(auto simp add: AE_count_space max_def not_Inner_conv split: split_indicator intro!: nn_integral_cong)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  d_IN (lift f) (Inner (source \\<Delta>)) =\n  (\\<integral>\\<^sup>+y\\<in>{SOURCE}. lift f (y, Inner (source \\<Delta>))\n   \\<partial>count_space UNIV) +\n  (\\<Sum>\\<^sup>+ y\\<in>range Inner. lift f (y, Inner (source \\<Delta>)))\n\ngoal (1 subgoal):\n 1. d_IN (lift f) (Inner (source \\<Delta>)) =\n    value_flow \\<Delta> f + d_IN f (source \\<Delta>)", "also"], ["proof (state)\nthis:\n  d_IN (lift f) (Inner (source \\<Delta>)) =\n  (\\<integral>\\<^sup>+y\\<in>{SOURCE}. lift f (y, Inner (source \\<Delta>))\n   \\<partial>count_space UNIV) +\n  (\\<Sum>\\<^sup>+ y\\<in>range Inner. lift f (y, Inner (source \\<Delta>)))\n\ngoal (1 subgoal):\n 1. d_IN (lift f) (Inner (source \\<Delta>)) =\n    value_flow \\<Delta> f + d_IN f (source \\<Delta>)", "have \"?rest = d_IN f (source \\<Delta>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y\\<in>range Inner.\n       lift f (y, Inner (source \\<Delta>))) =\n    d_IN f (source \\<Delta>)", "by(simp add: nn_integral_count_space_reindex d_IN_def)"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y\\<in>range Inner. lift f (y, Inner (source \\<Delta>))) =\n  d_IN f (source \\<Delta>)\n\ngoal (1 subgoal):\n 1. d_IN (lift f) (Inner (source \\<Delta>)) =\n    value_flow \\<Delta> f + d_IN f (source \\<Delta>)", "also"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y\\<in>range Inner. lift f (y, Inner (source \\<Delta>))) =\n  d_IN f (source \\<Delta>)\n\ngoal (1 subgoal):\n 1. d_IN (lift f) (Inner (source \\<Delta>)) =\n    value_flow \\<Delta> f + d_IN f (source \\<Delta>)", "have \"?SOURCE = value_flow \\<Delta> f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+y\\<in>{SOURCE}. lift f (y, Inner (source \\<Delta>))\n    \\<partial>count_space UNIV =\n    value_flow \\<Delta> f", "by(simp add: max_def one_ennreal_def[symmetric] )"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+y\\<in>{SOURCE}. lift f (y, Inner (source \\<Delta>))\n  \\<partial>count_space UNIV =\n  value_flow \\<Delta> f\n\ngoal (1 subgoal):\n 1. d_IN (lift f) (Inner (source \\<Delta>)) =\n    value_flow \\<Delta> f + d_IN f (source \\<Delta>)", "finally"], ["proof (chain)\npicking this:\n  d_IN (lift f) (Inner (source \\<Delta>)) =\n  value_flow \\<Delta> f + d_IN f (source \\<Delta>)", "show ?thesis"], ["proof (prove)\nusing this:\n  d_IN (lift f) (Inner (source \\<Delta>)) =\n  value_flow \\<Delta> f + d_IN f (source \\<Delta>)\n\ngoal (1 subgoal):\n 1. d_IN (lift f) (Inner (source \\<Delta>)) =\n    value_flow \\<Delta> f + d_IN f (source \\<Delta>)", "."], ["proof (state)\nthis:\n  d_IN (lift f) (Inner (source \\<Delta>)) =\n  value_flow \\<Delta> f + d_IN f (source \\<Delta>)\n\ngoal:\nNo subgoals!", "qed"], ["", "private"], ["", "lemma flow_lift [simp]:\n  assumes \"flow \\<Delta> f\"\n  shows \"flow \\<Delta>' (lift f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. flow \\<Delta>' (lift f)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>e. lift f e \\<le> capacity \\<Delta>' e\n 2. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>';\n        x \\<noteq> sink \\<Delta>'\\<rbrakk>\n       \\<Longrightarrow> KIR (lift f) x", "show \"lift f e \\<le> capacity \\<Delta>' e\" for e"], ["proof (prove)\ngoal (1 subgoal):\n 1. lift f e \\<le> capacity \\<Delta>' e", "by(cases e rule: capacity'.cases)(auto intro: flowD_capacity[OF assms] simp add: \\<alpha>_def intro: SUP_upper2 assms)"], ["proof (state)\nthis:\n  lift f ?e \\<le> capacity \\<Delta>' ?e\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>';\n        x \\<noteq> sink \\<Delta>'\\<rbrakk>\n       \\<Longrightarrow> KIR (lift f) x", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>';\n        x \\<noteq> sink \\<Delta>'\\<rbrakk>\n       \\<Longrightarrow> KIR (lift f) x", "assume x: \"x \\<noteq> source \\<Delta>'\" \"x \\<noteq> sink \\<Delta>'\""], ["proof (state)\nthis:\n  x \\<noteq> source \\<Delta>'\n  x \\<noteq> sink \\<Delta>'\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>';\n        x \\<noteq> sink \\<Delta>'\\<rbrakk>\n       \\<Longrightarrow> KIR (lift f) x", "then"], ["proof (chain)\npicking this:\n  x \\<noteq> source \\<Delta>'\n  x \\<noteq> sink \\<Delta>'", "obtain x' where x': \"x = Inner x'\""], ["proof (prove)\nusing this:\n  x \\<noteq> source \\<Delta>'\n  x \\<noteq> sink \\<Delta>'\n\ngoal (1 subgoal):\n 1. (\\<And>x'. x = Inner x' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases x) auto"], ["proof (state)\nthis:\n  x = Inner x'\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>';\n        x \\<noteq> sink \\<Delta>'\\<rbrakk>\n       \\<Longrightarrow> KIR (lift f) x", "then"], ["proof (chain)\npicking this:\n  x = Inner x'", "show \"KIR (lift f) x\""], ["proof (prove)\nusing this:\n  x = Inner x'\n\ngoal (1 subgoal):\n 1. KIR (lift f) x", "using x"], ["proof (prove)\nusing this:\n  x = Inner x'\n  x \\<noteq> source \\<Delta>'\n  x \\<noteq> sink \\<Delta>'\n\ngoal (1 subgoal):\n 1. KIR (lift f) x", "by(cases \"x' = source \\<Delta>\")(auto simp add: flowD_source_IN[OF assms] dest: flowD_KIR[OF assms])"], ["proof (state)\nthis:\n  KIR (lift f) x\n\ngoal:\nNo subgoals!", "qed"], ["", "private"], ["", "abbreviation (input) unlift :: \"'v node flow \\<Rightarrow> 'v flow\"\nwhere \"unlift f \\<equiv> (\\<lambda>(x, y). f (Inner x, Inner y))\""], ["", "private"], ["", "lemma flow_unlift [simp]:\n  assumes f: \"flow \\<Delta>' f\"\n  shows \"flow \\<Delta> (unlift f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. flow \\<Delta> (\\<lambda>(x, y). f (Inner x, Inner y))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>e.\n       (case e of (x, y) \\<Rightarrow> f (Inner x, Inner y))\n       \\<le> capacity \\<Delta> e\n 2. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>;\n        x \\<noteq> sink \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> KIR (\\<lambda>(x, y). f (Inner x, Inner y)) x", "show \"unlift f e \\<le> capacity \\<Delta> e\" for e"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case e of (x, y) \\<Rightarrow> f (Inner x, Inner y))\n    \\<le> capacity \\<Delta> e", "using flowD_capacity[OF f, of \"map_prod Inner Inner e\"]"], ["proof (prove)\nusing this:\n  f (map_prod Inner Inner e)\n  \\<le> capacity \\<Delta>' (map_prod Inner Inner e)\n\ngoal (1 subgoal):\n 1. (case e of (x, y) \\<Rightarrow> f (Inner x, Inner y))\n    \\<le> capacity \\<Delta> e", "by(cases e)(simp)"], ["proof (state)\nthis:\n  (case ?e of (x, y) \\<Rightarrow> f (Inner x, Inner y))\n  \\<le> capacity \\<Delta> ?e\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>;\n        x \\<noteq> sink \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> KIR (\\<lambda>(x, y). f (Inner x, Inner y)) x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>;\n        x \\<noteq> sink \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> KIR (\\<lambda>(x, y). f (Inner x, Inner y)) x", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>;\n        x \\<noteq> sink \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> KIR (\\<lambda>(x, y). f (Inner x, Inner y)) x", "assume x: \"x \\<noteq> source \\<Delta>\" \"x \\<noteq> sink \\<Delta>\""], ["proof (state)\nthis:\n  x \\<noteq> source \\<Delta>\n  x \\<noteq> sink \\<Delta>\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>;\n        x \\<noteq> sink \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> KIR (\\<lambda>(x, y). f (Inner x, Inner y)) x", "have \"d_OUT (unlift f) x = (\\<Sum>\\<^sup>+ y\\<in>range Inner. f (Inner x, y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT (\\<lambda>(x, y). f (Inner x, Inner y)) x =\n    (\\<Sum>\\<^sup>+ y\\<in>range Inner. f (Inner x, y))", "by(simp add: nn_integral_count_space_reindex d_OUT_def)"], ["proof (state)\nthis:\n  d_OUT (\\<lambda>(x, y). f (Inner x, Inner y)) x =\n  (\\<Sum>\\<^sup>+ y\\<in>range Inner. f (Inner x, y))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>;\n        x \\<noteq> sink \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> KIR (\\<lambda>(x, y). f (Inner x, Inner y)) x", "also"], ["proof (state)\nthis:\n  d_OUT (\\<lambda>(x, y). f (Inner x, Inner y)) x =\n  (\\<Sum>\\<^sup>+ y\\<in>range Inner. f (Inner x, y))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>;\n        x \\<noteq> sink \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> KIR (\\<lambda>(x, y). f (Inner x, Inner y)) x", "have \"\\<dots> = d_OUT f (Inner x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y\\<in>range Inner. f (Inner x, y)) = d_OUT f (Inner x)", "using flowD_capacity[OF f, of \"(Inner x, SOURCE)\"]"], ["proof (prove)\nusing this:\n  f (Inner x, SOURCE) \\<le> capacity \\<Delta>' (Inner x, SOURCE)\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y\\<in>range Inner. f (Inner x, y)) = d_OUT f (Inner x)", "by(auto simp add: nn_integral_count_space_indicator d_OUT_def not_Inner_conv intro!: nn_integral_cong split: split_indicator)"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y\\<in>range Inner. f (Inner x, y)) = d_OUT f (Inner x)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>;\n        x \\<noteq> sink \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> KIR (\\<lambda>(x, y). f (Inner x, Inner y)) x", "also"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y\\<in>range Inner. f (Inner x, y)) = d_OUT f (Inner x)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>;\n        x \\<noteq> sink \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> KIR (\\<lambda>(x, y). f (Inner x, Inner y)) x", "have \"\\<dots> = d_IN f (Inner x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. KIR f (Inner x)", "using x flowD_KIR[OF f, of \"Inner x\"]"], ["proof (prove)\nusing this:\n  x \\<noteq> source \\<Delta>\n  x \\<noteq> sink \\<Delta>\n  \\<lbrakk>Inner x \\<noteq> source \\<Delta>';\n   Inner x \\<noteq> sink \\<Delta>'\\<rbrakk>\n  \\<Longrightarrow> KIR f (Inner x)\n\ngoal (1 subgoal):\n 1. KIR f (Inner x)", "by(simp)"], ["proof (state)\nthis:\n  KIR f (Inner x)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>;\n        x \\<noteq> sink \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> KIR (\\<lambda>(x, y). f (Inner x, Inner y)) x", "also"], ["proof (state)\nthis:\n  KIR f (Inner x)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>;\n        x \\<noteq> sink \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> KIR (\\<lambda>(x, y). f (Inner x, Inner y)) x", "have \"\\<dots> = (\\<Sum>\\<^sup>+ y\\<in>range Inner. f (y, Inner x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN f (Inner x) = (\\<Sum>\\<^sup>+ y\\<in>range Inner. f (y, Inner x))", "using x flowD_capacity[OF f, of \"(SOURCE, Inner x)\"]"], ["proof (prove)\nusing this:\n  x \\<noteq> source \\<Delta>\n  x \\<noteq> sink \\<Delta>\n  f (SOURCE, Inner x) \\<le> capacity \\<Delta>' (SOURCE, Inner x)\n\ngoal (1 subgoal):\n 1. d_IN f (Inner x) = (\\<Sum>\\<^sup>+ y\\<in>range Inner. f (y, Inner x))", "by(auto simp add: nn_integral_count_space_indicator d_IN_def not_Inner_conv intro!: nn_integral_cong split: split_indicator)"], ["proof (state)\nthis:\n  d_IN f (Inner x) = (\\<Sum>\\<^sup>+ y\\<in>range Inner. f (y, Inner x))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>;\n        x \\<noteq> sink \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> KIR (\\<lambda>(x, y). f (Inner x, Inner y)) x", "also"], ["proof (state)\nthis:\n  d_IN f (Inner x) = (\\<Sum>\\<^sup>+ y\\<in>range Inner. f (y, Inner x))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>;\n        x \\<noteq> sink \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> KIR (\\<lambda>(x, y). f (Inner x, Inner y)) x", "have \"\\<dots> = d_IN (unlift f) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y\\<in>range Inner. f (y, Inner x)) =\n    d_IN (\\<lambda>(x, y). f (Inner x, Inner y)) x", "by(simp add: nn_integral_count_space_reindex d_IN_def)"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y\\<in>range Inner. f (y, Inner x)) =\n  d_IN (\\<lambda>(x, y). f (Inner x, Inner y)) x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>;\n        x \\<noteq> sink \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> KIR (\\<lambda>(x, y). f (Inner x, Inner y)) x", "finally"], ["proof (chain)\npicking this:\n  KIR (\\<lambda>(x, y). f (Inner x, Inner y)) x", "show \"KIR (unlift f) x\""], ["proof (prove)\nusing this:\n  KIR (\\<lambda>(x, y). f (Inner x, Inner y)) x\n\ngoal (1 subgoal):\n 1. KIR (\\<lambda>(x, y). f (Inner x, Inner y)) x", "."], ["proof (state)\nthis:\n  KIR (\\<lambda>(x, y). f (Inner x, Inner y)) x\n\ngoal:\nNo subgoals!", "qed"], ["", "private"], ["", "lemma value_unlift:\n  assumes f: \"flow \\<Delta>' f\"\n  shows \"value_flow \\<Delta> (unlift f) = value_flow \\<Delta>' f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. value_flow \\<Delta> (\\<lambda>(x, y). f (Inner x, Inner y)) =\n    value_flow \\<Delta>' f", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. value_flow \\<Delta> (\\<lambda>(x, y). f (Inner x, Inner y)) =\n    value_flow \\<Delta>' f", "have \"value_flow \\<Delta> (unlift f) = (\\<Sum>\\<^sup>+ y\\<in>range Inner. f (Inner (source \\<Delta>), y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. value_flow \\<Delta> (\\<lambda>(x, y). f (Inner x, Inner y)) =\n    (\\<Sum>\\<^sup>+ y\\<in>range Inner. f (Inner (source \\<Delta>), y))", "by(simp add: nn_integral_count_space_reindex d_OUT_def)"], ["proof (state)\nthis:\n  value_flow \\<Delta> (\\<lambda>(x, y). f (Inner x, Inner y)) =\n  (\\<Sum>\\<^sup>+ y\\<in>range Inner. f (Inner (source \\<Delta>), y))\n\ngoal (1 subgoal):\n 1. value_flow \\<Delta> (\\<lambda>(x, y). f (Inner x, Inner y)) =\n    value_flow \\<Delta>' f", "also"], ["proof (state)\nthis:\n  value_flow \\<Delta> (\\<lambda>(x, y). f (Inner x, Inner y)) =\n  (\\<Sum>\\<^sup>+ y\\<in>range Inner. f (Inner (source \\<Delta>), y))\n\ngoal (1 subgoal):\n 1. value_flow \\<Delta> (\\<lambda>(x, y). f (Inner x, Inner y)) =\n    value_flow \\<Delta>' f", "have \"\\<dots> = d_OUT f (Inner (source \\<Delta>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y\\<in>range Inner. f (Inner (source \\<Delta>), y)) =\n    d_OUT f (Inner (source \\<Delta>))", "using flowD_capacity[OF f, of \"(Inner (source \\<Delta>), SOURCE)\"]"], ["proof (prove)\nusing this:\n  f (Inner (source \\<Delta>), SOURCE)\n  \\<le> capacity \\<Delta>' (Inner (source \\<Delta>), SOURCE)\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y\\<in>range Inner. f (Inner (source \\<Delta>), y)) =\n    d_OUT f (Inner (source \\<Delta>))", "by(auto simp add: nn_integral_count_space_indicator d_OUT_def not_Inner_conv intro!: nn_integral_cong split: split_indicator)"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y\\<in>range Inner. f (Inner (source \\<Delta>), y)) =\n  d_OUT f (Inner (source \\<Delta>))\n\ngoal (1 subgoal):\n 1. value_flow \\<Delta> (\\<lambda>(x, y). f (Inner x, Inner y)) =\n    value_flow \\<Delta>' f", "also"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y\\<in>range Inner. f (Inner (source \\<Delta>), y)) =\n  d_OUT f (Inner (source \\<Delta>))\n\ngoal (1 subgoal):\n 1. value_flow \\<Delta> (\\<lambda>(x, y). f (Inner x, Inner y)) =\n    value_flow \\<Delta>' f", "have \"\\<dots> = d_IN f (Inner (source \\<Delta>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. KIR f (Inner (source \\<Delta>))", "using flowD_KIR[OF f, of \"Inner (source \\<Delta>)\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>Inner (source \\<Delta>) \\<noteq> source \\<Delta>';\n   Inner (source \\<Delta>) \\<noteq> sink \\<Delta>'\\<rbrakk>\n  \\<Longrightarrow> KIR f (Inner (source \\<Delta>))\n\ngoal (1 subgoal):\n 1. KIR f (Inner (source \\<Delta>))", "by(simp)"], ["proof (state)\nthis:\n  KIR f (Inner (source \\<Delta>))\n\ngoal (1 subgoal):\n 1. value_flow \\<Delta> (\\<lambda>(x, y). f (Inner x, Inner y)) =\n    value_flow \\<Delta>' f", "also"], ["proof (state)\nthis:\n  KIR f (Inner (source \\<Delta>))\n\ngoal (1 subgoal):\n 1. value_flow \\<Delta> (\\<lambda>(x, y). f (Inner x, Inner y)) =\n    value_flow \\<Delta>' f", "have \"\\<dots> = (\\<Sum>\\<^sup>+ y. f (y, Inner (source \\<Delta>)) * indicator {SOURCE} y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN f (Inner (source \\<Delta>)) =\n    \\<integral>\\<^sup>+y\\<in>{SOURCE}. f (y, Inner (source \\<Delta>))\n    \\<partial>count_space UNIV", "unfolding d_IN_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ x. f (x, Inner (source \\<Delta>))) =\n    \\<integral>\\<^sup>+y\\<in>{SOURCE}. f (y, Inner (source \\<Delta>))\n    \\<partial>count_space UNIV", "using flowD_capacity[OF f, of \"(x, Inner (source \\<Delta>))\" for x]"], ["proof (prove)\nusing this:\n  f (?x2, Inner (source \\<Delta>))\n  \\<le> capacity \\<Delta>' (?x2, Inner (source \\<Delta>))\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ x. f (x, Inner (source \\<Delta>))) =\n    \\<integral>\\<^sup>+y\\<in>{SOURCE}. f (y, Inner (source \\<Delta>))\n    \\<partial>count_space UNIV", "by(intro nn_integral_cong)(auto intro!: antisym split: split_indicator if_split_asm elim: meta_allE)"], ["proof (state)\nthis:\n  d_IN f (Inner (source \\<Delta>)) =\n  \\<integral>\\<^sup>+y\\<in>{SOURCE}. f (y, Inner (source \\<Delta>))\n  \\<partial>count_space UNIV\n\ngoal (1 subgoal):\n 1. value_flow \\<Delta> (\\<lambda>(x, y). f (Inner x, Inner y)) =\n    value_flow \\<Delta>' f", "also"], ["proof (state)\nthis:\n  d_IN f (Inner (source \\<Delta>)) =\n  \\<integral>\\<^sup>+y\\<in>{SOURCE}. f (y, Inner (source \\<Delta>))\n  \\<partial>count_space UNIV\n\ngoal (1 subgoal):\n 1. value_flow \\<Delta> (\\<lambda>(x, y). f (Inner x, Inner y)) =\n    value_flow \\<Delta>' f", "have \"\\<dots> = f (SOURCE, Inner (source \\<Delta>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+y\\<in>{SOURCE}. f (y, Inner (source \\<Delta>))\n    \\<partial>count_space UNIV =\n    f (SOURCE, Inner (source \\<Delta>))", "by simp"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+y\\<in>{SOURCE}. f (y, Inner (source \\<Delta>))\n  \\<partial>count_space UNIV =\n  f (SOURCE, Inner (source \\<Delta>))\n\ngoal (1 subgoal):\n 1. value_flow \\<Delta> (\\<lambda>(x, y). f (Inner x, Inner y)) =\n    value_flow \\<Delta>' f", "also"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+y\\<in>{SOURCE}. f (y, Inner (source \\<Delta>))\n  \\<partial>count_space UNIV =\n  f (SOURCE, Inner (source \\<Delta>))\n\ngoal (1 subgoal):\n 1. value_flow \\<Delta> (\\<lambda>(x, y). f (Inner x, Inner y)) =\n    value_flow \\<Delta>' f", "have \"\\<dots> = (\\<Sum>\\<^sup>+ y. f (SOURCE, y) * indicator {Inner (source \\<Delta>)} y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f (SOURCE, Inner (source \\<Delta>)) =\n    \\<integral>\\<^sup>+y\\<in>{Inner (source \\<Delta>)}. f (SOURCE, y)\n    \\<partial>count_space UNIV", "by(simp add: one_ennreal_def[symmetric])"], ["proof (state)\nthis:\n  f (SOURCE, Inner (source \\<Delta>)) =\n  \\<integral>\\<^sup>+y\\<in>{Inner (source \\<Delta>)}. f (SOURCE, y)\n  \\<partial>count_space UNIV\n\ngoal (1 subgoal):\n 1. value_flow \\<Delta> (\\<lambda>(x, y). f (Inner x, Inner y)) =\n    value_flow \\<Delta>' f", "also"], ["proof (state)\nthis:\n  f (SOURCE, Inner (source \\<Delta>)) =\n  \\<integral>\\<^sup>+y\\<in>{Inner (source \\<Delta>)}. f (SOURCE, y)\n  \\<partial>count_space UNIV\n\ngoal (1 subgoal):\n 1. value_flow \\<Delta> (\\<lambda>(x, y). f (Inner x, Inner y)) =\n    value_flow \\<Delta>' f", "have \"\\<dots> = value_flow \\<Delta>' f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+y\\<in>{Inner (source \\<Delta>)}. f (SOURCE, y)\n    \\<partial>count_space UNIV =\n    value_flow \\<Delta>' f", "unfolding d_OUT_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+y\\<in>{Inner (source \\<Delta>)}. f (SOURCE, y)\n    \\<partial>count_space UNIV =\n    (\\<Sum>\\<^sup>+ y. f (source \\<Delta>', y))", "unfolding d_OUT_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+y\\<in>{Inner (source \\<Delta>)}. f (SOURCE, y)\n    \\<partial>count_space UNIV =\n    (\\<Sum>\\<^sup>+ y. f (source \\<Delta>', y))", "using flowD_capacity[OF f, of \"(SOURCE, Inner x)\" for x] flowD_capacity[OF f, of \"(SOURCE, SOURCE)\"]"], ["proof (prove)\nusing this:\n  f (SOURCE, Inner ?x2) \\<le> capacity \\<Delta>' (SOURCE, Inner ?x2)\n  f (SOURCE, SOURCE) \\<le> capacity \\<Delta>' (SOURCE, SOURCE)\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+y\\<in>{Inner (source \\<Delta>)}. f (SOURCE, y)\n    \\<partial>count_space UNIV =\n    (\\<Sum>\\<^sup>+ y. f (source \\<Delta>', y))", "apply(intro nn_integral_cong)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>x.\n                   f (SOURCE, Inner x)\n                   \\<le> capacity \\<Delta>' (SOURCE, Inner x);\n        f (SOURCE, SOURCE) \\<le> capacity \\<Delta>' (SOURCE, SOURCE);\n        x \\<in> space (count_space UNIV)\\<rbrakk>\n       \\<Longrightarrow> f (SOURCE, x) *\n                         indicator {Inner (source \\<Delta>)} x =\n                         f (source \\<Delta>', x)", "apply(case_tac x)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>x.\n                   f (SOURCE, Inner x)\n                   \\<le> capacity \\<Delta>' (SOURCE, Inner x);\n        f (SOURCE, SOURCE) \\<le> capacity \\<Delta>' (SOURCE, SOURCE);\n        x \\<in> space (count_space UNIV); x = SOURCE\\<rbrakk>\n       \\<Longrightarrow> f (SOURCE, x) *\n                         indicator {Inner (source \\<Delta>)} x =\n                         f (source \\<Delta>', x)\n 2. \\<And>x x2.\n       \\<lbrakk>\\<And>x.\n                   f (SOURCE, Inner x)\n                   \\<le> capacity \\<Delta>' (SOURCE, Inner x);\n        f (SOURCE, SOURCE) \\<le> capacity \\<Delta>' (SOURCE, SOURCE);\n        x \\<in> space (count_space UNIV); x = Inner x2\\<rbrakk>\n       \\<Longrightarrow> f (SOURCE, x) *\n                         indicator {Inner (source \\<Delta>)} x =\n                         f (source \\<Delta>', x)", "apply(auto intro!: antisym split: split_indicator if_split_asm elim: meta_allE)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+y\\<in>{Inner (source \\<Delta>)}. f (SOURCE, y)\n  \\<partial>count_space UNIV =\n  value_flow \\<Delta>' f\n\ngoal (1 subgoal):\n 1. value_flow \\<Delta> (\\<lambda>(x, y). f (Inner x, Inner y)) =\n    value_flow \\<Delta>' f", "finally"], ["proof (chain)\npicking this:\n  value_flow \\<Delta> (\\<lambda>(x, y). f (Inner x, Inner y)) =\n  value_flow \\<Delta>' f", "show ?thesis"], ["proof (prove)\nusing this:\n  value_flow \\<Delta> (\\<lambda>(x, y). f (Inner x, Inner y)) =\n  value_flow \\<Delta>' f\n\ngoal (1 subgoal):\n 1. value_flow \\<Delta> (\\<lambda>(x, y). f (Inner x, Inner y)) =\n    value_flow \\<Delta>' f", "."], ["proof (state)\nthis:\n  value_flow \\<Delta> (\\<lambda>(x, y). f (Inner x, Inner y)) =\n  value_flow \\<Delta>' f\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem ex_max_flow:\n  \"\\<exists>f. flow \\<Delta> f \\<and> value_flow \\<Delta> f = \\<alpha> \\<and> (\\<forall>x. d_IN f x \\<le> value_flow \\<Delta> f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>f.\n       flow \\<Delta> f \\<and>\n       value_flow \\<Delta> f = \\<alpha> \\<and>\n       (\\<forall>x. d_IN f x \\<le> value_flow \\<Delta> f)", "proof(cases \"\\<alpha>\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>r.\n       \\<lbrakk>0 \\<le> r; \\<alpha> = ennreal r\\<rbrakk>\n       \\<Longrightarrow> \\<exists>f.\n                            flow \\<Delta> f \\<and>\n                            value_flow \\<Delta> f = \\<alpha> \\<and>\n                            (\\<forall>x.\n                                d_IN f x \\<le> value_flow \\<Delta> f)\n 2. \\<alpha> = \\<top> \\<Longrightarrow>\n    \\<exists>f.\n       flow \\<Delta> f \\<and>\n       value_flow \\<Delta> f = \\<alpha> \\<and>\n       (\\<forall>x. d_IN f x \\<le> value_flow \\<Delta> f)", "case (real \\<alpha>')"], ["proof (state)\nthis:\n  0 \\<le> \\<alpha>'\n  \\<alpha> = ennreal \\<alpha>'\n\ngoal (2 subgoals):\n 1. \\<And>r.\n       \\<lbrakk>0 \\<le> r; \\<alpha> = ennreal r\\<rbrakk>\n       \\<Longrightarrow> \\<exists>f.\n                            flow \\<Delta> f \\<and>\n                            value_flow \\<Delta> f = \\<alpha> \\<and>\n                            (\\<forall>x.\n                                d_IN f x \\<le> value_flow \\<Delta> f)\n 2. \\<alpha> = \\<top> \\<Longrightarrow>\n    \\<exists>f.\n       flow \\<Delta> f \\<and>\n       value_flow \\<Delta> f = \\<alpha> \\<and>\n       (\\<forall>x. d_IN f x \\<le> value_flow \\<Delta> f)", "hence \\<alpha>: \"\\<alpha> \\<noteq> \\<top>\""], ["proof (prove)\nusing this:\n  0 \\<le> \\<alpha>'\n  \\<alpha> = ennreal \\<alpha>'\n\ngoal (1 subgoal):\n 1. \\<alpha> \\<noteq> \\<top>", "by simp"], ["proof (state)\nthis:\n  \\<alpha> \\<noteq> \\<top>\n\ngoal (2 subgoals):\n 1. \\<And>r.\n       \\<lbrakk>0 \\<le> r; \\<alpha> = ennreal r\\<rbrakk>\n       \\<Longrightarrow> \\<exists>f.\n                            flow \\<Delta> f \\<and>\n                            value_flow \\<Delta> f = \\<alpha> \\<and>\n                            (\\<forall>x.\n                                d_IN f x \\<le> value_flow \\<Delta> f)\n 2. \\<alpha> = \\<top> \\<Longrightarrow>\n    \\<exists>f.\n       flow \\<Delta> f \\<and>\n       value_flow \\<Delta> f = \\<alpha> \\<and>\n       (\\<forall>x. d_IN f x \\<le> value_flow \\<Delta> f)", "then"], ["proof (chain)\npicking this:\n  \\<alpha> \\<noteq> \\<top>", "interpret \\<Delta>': flow_attainability \\<Delta>'"], ["proof (prove)\nusing this:\n  \\<alpha> \\<noteq> \\<top>\n\ngoal (1 subgoal):\n 1. flow_attainability \\<Delta>'", "by(rule \\<Delta>'_flow_attainability)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>r.\n       \\<lbrakk>0 \\<le> r; \\<alpha> = ennreal r\\<rbrakk>\n       \\<Longrightarrow> \\<exists>f.\n                            flow \\<Delta> f \\<and>\n                            value_flow \\<Delta> f = \\<alpha> \\<and>\n                            (\\<forall>x.\n                                d_IN f x \\<le> value_flow \\<Delta> f)\n 2. \\<alpha> = \\<top> \\<Longrightarrow>\n    \\<exists>f.\n       flow \\<Delta> f \\<and>\n       value_flow \\<Delta> f = \\<alpha> \\<and>\n       (\\<forall>x. d_IN f x \\<le> value_flow \\<Delta> f)", "have source_out: \"edge \\<Delta>' (source \\<Delta>') y \\<longleftrightarrow> y = Inner (source \\<Delta>)\" for y"], ["proof (prove)\ngoal (1 subgoal):\n 1. edge \\<Delta>' (source \\<Delta>') y = (y = Inner (source \\<Delta>))", "by(auto)"], ["proof (state)\nthis:\n  edge \\<Delta>' (source \\<Delta>') ?y = (?y = Inner (source \\<Delta>))\n\ngoal (2 subgoals):\n 1. \\<And>r.\n       \\<lbrakk>0 \\<le> r; \\<alpha> = ennreal r\\<rbrakk>\n       \\<Longrightarrow> \\<exists>f.\n                            flow \\<Delta> f \\<and>\n                            value_flow \\<Delta> f = \\<alpha> \\<and>\n                            (\\<forall>x.\n                                d_IN f x \\<le> value_flow \\<Delta> f)\n 2. \\<alpha> = \\<top> \\<Longrightarrow>\n    \\<exists>f.\n       flow \\<Delta> f \\<and>\n       value_flow \\<Delta> f = \\<alpha> \\<and>\n       (\\<forall>x. d_IN f x \\<le> value_flow \\<Delta> f)", "have nontrivial: \"\\<^bold>E\\<^bsub>\\<Delta>'\\<^esub> \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<^bold>E\\<^bsub>\\<Delta>'\\<^esub> \\<noteq> {}", "by(auto intro: edge'.intros)"], ["proof (state)\nthis:\n  \\<^bold>E\\<^bsub>\\<Delta>'\\<^esub> \\<noteq> {}\n\ngoal (2 subgoals):\n 1. \\<And>r.\n       \\<lbrakk>0 \\<le> r; \\<alpha> = ennreal r\\<rbrakk>\n       \\<Longrightarrow> \\<exists>f.\n                            flow \\<Delta> f \\<and>\n                            value_flow \\<Delta> f = \\<alpha> \\<and>\n                            (\\<forall>x.\n                                d_IN f x \\<le> value_flow \\<Delta> f)\n 2. \\<alpha> = \\<top> \\<Longrightarrow>\n    \\<exists>f.\n       flow \\<Delta> f \\<and>\n       value_flow \\<Delta> f = \\<alpha> \\<and>\n       (\\<forall>x. d_IN f x \\<le> value_flow \\<Delta> f)", "have eq: \"(SUP g \\<in> {g. flow \\<Delta>' g}. value_flow \\<Delta>' g) = (SUP g \\<in> {g. flow \\<Delta> g}. value_flow \\<Delta> g)\" (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Squnion> (value_flow \\<Delta>' ` {g. flow \\<Delta>' g}) =\n    \\<Squnion> (value_flow \\<Delta> ` {g. flow \\<Delta> g})", "proof(intro antisym SUP_least; unfold mem_Collect_eq)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>g.\n       flow \\<Delta>' g \\<Longrightarrow>\n       value_flow \\<Delta>' g\n       \\<le> \\<Squnion> (value_flow \\<Delta> ` {g. flow \\<Delta> g})\n 2. \\<And>g.\n       flow \\<Delta> g \\<Longrightarrow>\n       value_flow \\<Delta> g\n       \\<le> \\<Squnion> (value_flow \\<Delta>' ` {g. flow \\<Delta>' g})", "fix g"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>g.\n       flow \\<Delta>' g \\<Longrightarrow>\n       value_flow \\<Delta>' g\n       \\<le> \\<Squnion> (value_flow \\<Delta> ` {g. flow \\<Delta> g})\n 2. \\<And>g.\n       flow \\<Delta> g \\<Longrightarrow>\n       value_flow \\<Delta> g\n       \\<le> \\<Squnion> (value_flow \\<Delta>' ` {g. flow \\<Delta>' g})", "assume g: \"flow \\<Delta>' g\""], ["proof (state)\nthis:\n  flow \\<Delta>' g\n\ngoal (2 subgoals):\n 1. \\<And>g.\n       flow \\<Delta>' g \\<Longrightarrow>\n       value_flow \\<Delta>' g\n       \\<le> \\<Squnion> (value_flow \\<Delta> ` {g. flow \\<Delta> g})\n 2. \\<And>g.\n       flow \\<Delta> g \\<Longrightarrow>\n       value_flow \\<Delta> g\n       \\<le> \\<Squnion> (value_flow \\<Delta>' ` {g. flow \\<Delta>' g})", "hence \"value_flow \\<Delta>' g = value_flow \\<Delta> (unlift g)\""], ["proof (prove)\nusing this:\n  flow \\<Delta>' g\n\ngoal (1 subgoal):\n 1. value_flow \\<Delta>' g =\n    value_flow \\<Delta> (\\<lambda>(x, y). g (Inner x, Inner y))", "by(simp add: value_unlift)"], ["proof (state)\nthis:\n  value_flow \\<Delta>' g =\n  value_flow \\<Delta> (\\<lambda>(x, y). g (Inner x, Inner y))\n\ngoal (2 subgoals):\n 1. \\<And>g.\n       flow \\<Delta>' g \\<Longrightarrow>\n       value_flow \\<Delta>' g\n       \\<le> \\<Squnion> (value_flow \\<Delta> ` {g. flow \\<Delta> g})\n 2. \\<And>g.\n       flow \\<Delta> g \\<Longrightarrow>\n       value_flow \\<Delta> g\n       \\<le> \\<Squnion> (value_flow \\<Delta>' ` {g. flow \\<Delta>' g})", "also"], ["proof (state)\nthis:\n  value_flow \\<Delta>' g =\n  value_flow \\<Delta> (\\<lambda>(x, y). g (Inner x, Inner y))\n\ngoal (2 subgoals):\n 1. \\<And>g.\n       flow \\<Delta>' g \\<Longrightarrow>\n       value_flow \\<Delta>' g\n       \\<le> \\<Squnion> (value_flow \\<Delta> ` {g. flow \\<Delta> g})\n 2. \\<And>g.\n       flow \\<Delta> g \\<Longrightarrow>\n       value_flow \\<Delta> g\n       \\<le> \\<Squnion> (value_flow \\<Delta>' ` {g. flow \\<Delta>' g})", "{"], ["proof (state)\nthis:\n  value_flow \\<Delta>' g =\n  value_flow \\<Delta> (\\<lambda>(x, y). g (Inner x, Inner y))\n\ngoal (2 subgoals):\n 1. \\<And>g.\n       flow \\<Delta>' g \\<Longrightarrow>\n       value_flow \\<Delta>' g\n       \\<le> \\<Squnion> (value_flow \\<Delta> ` {g. flow \\<Delta> g})\n 2. \\<And>g.\n       flow \\<Delta> g \\<Longrightarrow>\n       value_flow \\<Delta> g\n       \\<le> \\<Squnion> (value_flow \\<Delta>' ` {g. flow \\<Delta>' g})", "from g"], ["proof (chain)\npicking this:\n  flow \\<Delta>' g", "have \"flow \\<Delta> (unlift g)\""], ["proof (prove)\nusing this:\n  flow \\<Delta>' g\n\ngoal (1 subgoal):\n 1. flow \\<Delta> (\\<lambda>(x, y). g (Inner x, Inner y))", "by simp"], ["proof (state)\nthis:\n  flow \\<Delta> (\\<lambda>(x, y). g (Inner x, Inner y))\n\ngoal (2 subgoals):\n 1. \\<And>g.\n       flow \\<Delta>' g \\<Longrightarrow>\n       value_flow \\<Delta>' g\n       \\<le> \\<Squnion> (value_flow \\<Delta> ` {g. flow \\<Delta> g})\n 2. \\<And>g.\n       flow \\<Delta> g \\<Longrightarrow>\n       value_flow \\<Delta> g\n       \\<le> \\<Squnion> (value_flow \\<Delta>' ` {g. flow \\<Delta>' g})", "}"], ["proof (state)\nthis:\n  flow \\<Delta> (\\<lambda>(x, y). g (Inner x, Inner y))\n\ngoal (2 subgoals):\n 1. \\<And>g.\n       flow \\<Delta>' g \\<Longrightarrow>\n       value_flow \\<Delta>' g\n       \\<le> \\<Squnion> (value_flow \\<Delta> ` {g. flow \\<Delta> g})\n 2. \\<And>g.\n       flow \\<Delta> g \\<Longrightarrow>\n       value_flow \\<Delta> g\n       \\<le> \\<Squnion> (value_flow \\<Delta>' ` {g. flow \\<Delta>' g})", "then"], ["proof (chain)\npicking this:\n  flow \\<Delta> (\\<lambda>(x, y). g (Inner x, Inner y))", "have \"\\<dots> \\<le> ?rhs\""], ["proof (prove)\nusing this:\n  flow \\<Delta> (\\<lambda>(x, y). g (Inner x, Inner y))\n\ngoal (1 subgoal):\n 1. value_flow \\<Delta> (\\<lambda>(x, y). g (Inner x, Inner y))\n    \\<le> \\<Squnion> (value_flow \\<Delta> ` {g. flow \\<Delta> g})", "by(blast intro: SUP_upper2)"], ["proof (state)\nthis:\n  value_flow \\<Delta> (\\<lambda>(x, y). g (Inner x, Inner y))\n  \\<le> \\<Squnion> (value_flow \\<Delta> ` {g. flow \\<Delta> g})\n\ngoal (2 subgoals):\n 1. \\<And>g.\n       flow \\<Delta>' g \\<Longrightarrow>\n       value_flow \\<Delta>' g\n       \\<le> \\<Squnion> (value_flow \\<Delta> ` {g. flow \\<Delta> g})\n 2. \\<And>g.\n       flow \\<Delta> g \\<Longrightarrow>\n       value_flow \\<Delta> g\n       \\<le> \\<Squnion> (value_flow \\<Delta>' ` {g. flow \\<Delta>' g})", "finally"], ["proof (chain)\npicking this:\n  value_flow \\<Delta>' g\n  \\<le> \\<Squnion> (value_flow \\<Delta> ` {g. flow \\<Delta> g})", "show \"value_flow \\<Delta>' g \\<le> \\<dots>\""], ["proof (prove)\nusing this:\n  value_flow \\<Delta>' g\n  \\<le> \\<Squnion> (value_flow \\<Delta> ` {g. flow \\<Delta> g})\n\ngoal (1 subgoal):\n 1. value_flow \\<Delta>' g\n    \\<le> \\<Squnion> (value_flow \\<Delta> ` {g. flow \\<Delta> g})", "."], ["proof (state)\nthis:\n  value_flow \\<Delta>' g\n  \\<le> \\<Squnion> (value_flow \\<Delta> ` {g. flow \\<Delta> g})\n\ngoal (1 subgoal):\n 1. \\<And>g.\n       flow \\<Delta> g \\<Longrightarrow>\n       value_flow \\<Delta> g\n       \\<le> \\<Squnion> (value_flow \\<Delta>' ` {g. flow \\<Delta>' g})", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>g.\n       flow \\<Delta> g \\<Longrightarrow>\n       value_flow \\<Delta> g\n       \\<le> \\<Squnion> (value_flow \\<Delta>' ` {g. flow \\<Delta>' g})", "fix g"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>g.\n       flow \\<Delta> g \\<Longrightarrow>\n       value_flow \\<Delta> g\n       \\<le> \\<Squnion> (value_flow \\<Delta>' ` {g. flow \\<Delta>' g})", "assume g: \"flow \\<Delta> g\""], ["proof (state)\nthis:\n  flow \\<Delta> g\n\ngoal (1 subgoal):\n 1. \\<And>g.\n       flow \\<Delta> g \\<Longrightarrow>\n       value_flow \\<Delta> g\n       \\<le> \\<Squnion> (value_flow \\<Delta>' ` {g. flow \\<Delta>' g})", "hence \"value_flow \\<Delta> g = value_flow \\<Delta>' (lift g)\""], ["proof (prove)\nusing this:\n  flow \\<Delta> g\n\ngoal (1 subgoal):\n 1. value_flow \\<Delta> g = value_flow \\<Delta>' (lift g)", "by simp"], ["proof (state)\nthis:\n  value_flow \\<Delta> g = value_flow \\<Delta>' (lift g)\n\ngoal (1 subgoal):\n 1. \\<And>g.\n       flow \\<Delta> g \\<Longrightarrow>\n       value_flow \\<Delta> g\n       \\<le> \\<Squnion> (value_flow \\<Delta>' ` {g. flow \\<Delta>' g})", "also"], ["proof (state)\nthis:\n  value_flow \\<Delta> g = value_flow \\<Delta>' (lift g)\n\ngoal (1 subgoal):\n 1. \\<And>g.\n       flow \\<Delta> g \\<Longrightarrow>\n       value_flow \\<Delta> g\n       \\<le> \\<Squnion> (value_flow \\<Delta>' ` {g. flow \\<Delta>' g})", "{"], ["proof (state)\nthis:\n  value_flow \\<Delta> g = value_flow \\<Delta>' (lift g)\n\ngoal (1 subgoal):\n 1. \\<And>g.\n       flow \\<Delta> g \\<Longrightarrow>\n       value_flow \\<Delta> g\n       \\<le> \\<Squnion> (value_flow \\<Delta>' ` {g. flow \\<Delta>' g})", "from g"], ["proof (chain)\npicking this:\n  flow \\<Delta> g", "have \"flow \\<Delta>' (lift g)\""], ["proof (prove)\nusing this:\n  flow \\<Delta> g\n\ngoal (1 subgoal):\n 1. flow \\<Delta>' (lift g)", "by simp"], ["proof (state)\nthis:\n  flow \\<Delta>' (lift g)\n\ngoal (1 subgoal):\n 1. \\<And>g.\n       flow \\<Delta> g \\<Longrightarrow>\n       value_flow \\<Delta> g\n       \\<le> \\<Squnion> (value_flow \\<Delta>' ` {g. flow \\<Delta>' g})", "}"], ["proof (state)\nthis:\n  flow \\<Delta>' (lift g)\n\ngoal (1 subgoal):\n 1. \\<And>g.\n       flow \\<Delta> g \\<Longrightarrow>\n       value_flow \\<Delta> g\n       \\<le> \\<Squnion> (value_flow \\<Delta>' ` {g. flow \\<Delta>' g})", "then"], ["proof (chain)\npicking this:\n  flow \\<Delta>' (lift g)", "have \"\\<dots> \\<le> ?lhs\""], ["proof (prove)\nusing this:\n  flow \\<Delta>' (lift g)\n\ngoal (1 subgoal):\n 1. value_flow \\<Delta>' (lift g)\n    \\<le> \\<Squnion> (value_flow \\<Delta>' ` {g. flow \\<Delta>' g})", "by(blast intro: SUP_upper2)"], ["proof (state)\nthis:\n  value_flow \\<Delta>' (lift g)\n  \\<le> \\<Squnion> (value_flow \\<Delta>' ` {g. flow \\<Delta>' g})\n\ngoal (1 subgoal):\n 1. \\<And>g.\n       flow \\<Delta> g \\<Longrightarrow>\n       value_flow \\<Delta> g\n       \\<le> \\<Squnion> (value_flow \\<Delta>' ` {g. flow \\<Delta>' g})", "finally"], ["proof (chain)\npicking this:\n  value_flow \\<Delta> g\n  \\<le> \\<Squnion> (value_flow \\<Delta>' ` {g. flow \\<Delta>' g})", "show \"value_flow \\<Delta> g \\<le> ?lhs\""], ["proof (prove)\nusing this:\n  value_flow \\<Delta> g\n  \\<le> \\<Squnion> (value_flow \\<Delta>' ` {g. flow \\<Delta>' g})\n\ngoal (1 subgoal):\n 1. value_flow \\<Delta> g\n    \\<le> \\<Squnion> (value_flow \\<Delta>' ` {g. flow \\<Delta>' g})", "."], ["proof (state)\nthis:\n  value_flow \\<Delta> g\n  \\<le> \\<Squnion> (value_flow \\<Delta>' ` {g. flow \\<Delta>' g})\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<Squnion> (value_flow \\<Delta>' ` {g. flow \\<Delta>' g}) =\n  \\<Squnion> (value_flow \\<Delta> ` {g. flow \\<Delta> g})\n\ngoal (2 subgoals):\n 1. \\<And>r.\n       \\<lbrakk>0 \\<le> r; \\<alpha> = ennreal r\\<rbrakk>\n       \\<Longrightarrow> \\<exists>f.\n                            flow \\<Delta> f \\<and>\n                            value_flow \\<Delta> f = \\<alpha> \\<and>\n                            (\\<forall>x.\n                                d_IN f x \\<le> value_flow \\<Delta> f)\n 2. \\<alpha> = \\<top> \\<Longrightarrow>\n    \\<exists>f.\n       flow \\<Delta> f \\<and>\n       value_flow \\<Delta> f = \\<alpha> \\<and>\n       (\\<forall>x. d_IN f x \\<le> value_flow \\<Delta> f)", "also"], ["proof (state)\nthis:\n  \\<Squnion> (value_flow \\<Delta>' ` {g. flow \\<Delta>' g}) =\n  \\<Squnion> (value_flow \\<Delta> ` {g. flow \\<Delta> g})\n\ngoal (2 subgoals):\n 1. \\<And>r.\n       \\<lbrakk>0 \\<le> r; \\<alpha> = ennreal r\\<rbrakk>\n       \\<Longrightarrow> \\<exists>f.\n                            flow \\<Delta> f \\<and>\n                            value_flow \\<Delta> f = \\<alpha> \\<and>\n                            (\\<forall>x.\n                                d_IN f x \\<le> value_flow \\<Delta> f)\n 2. \\<alpha> = \\<top> \\<Longrightarrow>\n    \\<exists>f.\n       flow \\<Delta> f \\<and>\n       value_flow \\<Delta> f = \\<alpha> \\<and>\n       (\\<forall>x. d_IN f x \\<le> value_flow \\<Delta> f)", "have \"\\<dots> = ennreal \\<alpha>'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Squnion> (value_flow \\<Delta> ` {g. flow \\<Delta> g}) =\n    ennreal \\<alpha>'", "using real"], ["proof (prove)\nusing this:\n  0 \\<le> \\<alpha>'\n  \\<alpha> = ennreal \\<alpha>'\n\ngoal (1 subgoal):\n 1. \\<Squnion> (value_flow \\<Delta> ` {g. flow \\<Delta> g}) =\n    ennreal \\<alpha>'", "by(simp add: \\<alpha>_def)"], ["proof (state)\nthis:\n  \\<Squnion> (value_flow \\<Delta> ` {g. flow \\<Delta> g}) =\n  ennreal \\<alpha>'\n\ngoal (2 subgoals):\n 1. \\<And>r.\n       \\<lbrakk>0 \\<le> r; \\<alpha> = ennreal r\\<rbrakk>\n       \\<Longrightarrow> \\<exists>f.\n                            flow \\<Delta> f \\<and>\n                            value_flow \\<Delta> f = \\<alpha> \\<and>\n                            (\\<forall>x.\n                                d_IN f x \\<le> value_flow \\<Delta> f)\n 2. \\<alpha> = \\<top> \\<Longrightarrow>\n    \\<exists>f.\n       flow \\<Delta> f \\<and>\n       value_flow \\<Delta> f = \\<alpha> \\<and>\n       (\\<forall>x. d_IN f x \\<le> value_flow \\<Delta> f)", "finally"], ["proof (chain)\npicking this:\n  \\<Squnion> (value_flow \\<Delta>' ` {g. flow \\<Delta>' g}) =\n  ennreal \\<alpha>'", "obtain f where f: \"flow \\<Delta>' f\"\n    and value_f: \"value_flow \\<Delta>' f = (\\<Squnion>g\\<in>{g. flow \\<Delta>' g}. value_flow \\<Delta>' g)\"\n    and IN_f: \"\\<And>x. d_IN f x \\<le> value_flow \\<Delta>' f\""], ["proof (prove)\nusing this:\n  \\<Squnion> (value_flow \\<Delta>' ` {g. flow \\<Delta>' g}) =\n  ennreal \\<alpha>'\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        \\<lbrakk>flow \\<Delta>' f;\n         value_flow \\<Delta>' f =\n         \\<Squnion> (value_flow \\<Delta>' ` {g. flow \\<Delta>' g});\n         \\<And>x. d_IN f x \\<le> value_flow \\<Delta>' f\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>0 \\<le> \\<alpha>'\\<close>"], ["proof (prove)\nusing this:\n  \\<Squnion> (value_flow \\<Delta>' ` {g. flow \\<Delta>' g}) =\n  ennreal \\<alpha>'\n  0 \\<le> \\<alpha>'\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        \\<lbrakk>flow \\<Delta>' f;\n         value_flow \\<Delta>' f =\n         \\<Squnion> (value_flow \\<Delta>' ` {g. flow \\<Delta>' g});\n         \\<And>x. d_IN f x \\<le> value_flow \\<Delta>' f\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(blast dest: \\<Delta>'.ex_max_flow''[OF source_out nontrivial])"], ["proof (state)\nthis:\n  flow \\<Delta>' f\n  value_flow \\<Delta>' f =\n  \\<Squnion> (value_flow \\<Delta>' ` {g. flow \\<Delta>' g})\n  d_IN f ?x \\<le> value_flow \\<Delta>' f\n\ngoal (2 subgoals):\n 1. \\<And>r.\n       \\<lbrakk>0 \\<le> r; \\<alpha> = ennreal r\\<rbrakk>\n       \\<Longrightarrow> \\<exists>f.\n                            flow \\<Delta> f \\<and>\n                            value_flow \\<Delta> f = \\<alpha> \\<and>\n                            (\\<forall>x.\n                                d_IN f x \\<le> value_flow \\<Delta> f)\n 2. \\<alpha> = \\<top> \\<Longrightarrow>\n    \\<exists>f.\n       flow \\<Delta> f \\<and>\n       value_flow \\<Delta> f = \\<alpha> \\<and>\n       (\\<forall>x. d_IN f x \\<le> value_flow \\<Delta> f)", "have \"flow \\<Delta> (unlift f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. flow \\<Delta> (\\<lambda>(x, y). f (Inner x, Inner y))", "using f"], ["proof (prove)\nusing this:\n  flow \\<Delta>' f\n\ngoal (1 subgoal):\n 1. flow \\<Delta> (\\<lambda>(x, y). f (Inner x, Inner y))", "by simp"], ["proof (state)\nthis:\n  flow \\<Delta> (\\<lambda>(x, y). f (Inner x, Inner y))\n\ngoal (2 subgoals):\n 1. \\<And>r.\n       \\<lbrakk>0 \\<le> r; \\<alpha> = ennreal r\\<rbrakk>\n       \\<Longrightarrow> \\<exists>f.\n                            flow \\<Delta> f \\<and>\n                            value_flow \\<Delta> f = \\<alpha> \\<and>\n                            (\\<forall>x.\n                                d_IN f x \\<le> value_flow \\<Delta> f)\n 2. \\<alpha> = \\<top> \\<Longrightarrow>\n    \\<exists>f.\n       flow \\<Delta> f \\<and>\n       value_flow \\<Delta> f = \\<alpha> \\<and>\n       (\\<forall>x. d_IN f x \\<le> value_flow \\<Delta> f)", "moreover"], ["proof (state)\nthis:\n  flow \\<Delta> (\\<lambda>(x, y). f (Inner x, Inner y))\n\ngoal (2 subgoals):\n 1. \\<And>r.\n       \\<lbrakk>0 \\<le> r; \\<alpha> = ennreal r\\<rbrakk>\n       \\<Longrightarrow> \\<exists>f.\n                            flow \\<Delta> f \\<and>\n                            value_flow \\<Delta> f = \\<alpha> \\<and>\n                            (\\<forall>x.\n                                d_IN f x \\<le> value_flow \\<Delta> f)\n 2. \\<alpha> = \\<top> \\<Longrightarrow>\n    \\<exists>f.\n       flow \\<Delta> f \\<and>\n       value_flow \\<Delta> f = \\<alpha> \\<and>\n       (\\<forall>x. d_IN f x \\<le> value_flow \\<Delta> f)", "have \"value_flow \\<Delta> (unlift f) = \\<alpha>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. value_flow \\<Delta> (\\<lambda>(x, y). f (Inner x, Inner y)) = \\<alpha>", "using f eq value_f"], ["proof (prove)\nusing this:\n  flow \\<Delta>' f\n  \\<Squnion> (value_flow \\<Delta>' ` {g. flow \\<Delta>' g}) =\n  \\<Squnion> (value_flow \\<Delta> ` {g. flow \\<Delta> g})\n  value_flow \\<Delta>' f =\n  \\<Squnion> (value_flow \\<Delta>' ` {g. flow \\<Delta>' g})\n\ngoal (1 subgoal):\n 1. value_flow \\<Delta> (\\<lambda>(x, y). f (Inner x, Inner y)) = \\<alpha>", "by(simp add: value_unlift \\<alpha>_def)"], ["proof (state)\nthis:\n  value_flow \\<Delta> (\\<lambda>(x, y). f (Inner x, Inner y)) = \\<alpha>\n\ngoal (2 subgoals):\n 1. \\<And>r.\n       \\<lbrakk>0 \\<le> r; \\<alpha> = ennreal r\\<rbrakk>\n       \\<Longrightarrow> \\<exists>f.\n                            flow \\<Delta> f \\<and>\n                            value_flow \\<Delta> f = \\<alpha> \\<and>\n                            (\\<forall>x.\n                                d_IN f x \\<le> value_flow \\<Delta> f)\n 2. \\<alpha> = \\<top> \\<Longrightarrow>\n    \\<exists>f.\n       flow \\<Delta> f \\<and>\n       value_flow \\<Delta> f = \\<alpha> \\<and>\n       (\\<forall>x. d_IN f x \\<le> value_flow \\<Delta> f)", "moreover"], ["proof (state)\nthis:\n  value_flow \\<Delta> (\\<lambda>(x, y). f (Inner x, Inner y)) = \\<alpha>\n\ngoal (2 subgoals):\n 1. \\<And>r.\n       \\<lbrakk>0 \\<le> r; \\<alpha> = ennreal r\\<rbrakk>\n       \\<Longrightarrow> \\<exists>f.\n                            flow \\<Delta> f \\<and>\n                            value_flow \\<Delta> f = \\<alpha> \\<and>\n                            (\\<forall>x.\n                                d_IN f x \\<le> value_flow \\<Delta> f)\n 2. \\<alpha> = \\<top> \\<Longrightarrow>\n    \\<exists>f.\n       flow \\<Delta> f \\<and>\n       value_flow \\<Delta> f = \\<alpha> \\<and>\n       (\\<forall>x. d_IN f x \\<le> value_flow \\<Delta> f)", "{"], ["proof (state)\nthis:\n  value_flow \\<Delta> (\\<lambda>(x, y). f (Inner x, Inner y)) = \\<alpha>\n\ngoal (2 subgoals):\n 1. \\<And>r.\n       \\<lbrakk>0 \\<le> r; \\<alpha> = ennreal r\\<rbrakk>\n       \\<Longrightarrow> \\<exists>f.\n                            flow \\<Delta> f \\<and>\n                            value_flow \\<Delta> f = \\<alpha> \\<and>\n                            (\\<forall>x.\n                                d_IN f x \\<le> value_flow \\<Delta> f)\n 2. \\<alpha> = \\<top> \\<Longrightarrow>\n    \\<exists>f.\n       flow \\<Delta> f \\<and>\n       value_flow \\<Delta> f = \\<alpha> \\<and>\n       (\\<forall>x. d_IN f x \\<le> value_flow \\<Delta> f)", "fix x"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>r.\n       \\<lbrakk>0 \\<le> r; \\<alpha> = ennreal r\\<rbrakk>\n       \\<Longrightarrow> \\<exists>f.\n                            flow \\<Delta> f \\<and>\n                            value_flow \\<Delta> f = \\<alpha> \\<and>\n                            (\\<forall>x.\n                                d_IN f x \\<le> value_flow \\<Delta> f)\n 2. \\<alpha> = \\<top> \\<Longrightarrow>\n    \\<exists>f.\n       flow \\<Delta> f \\<and>\n       value_flow \\<Delta> f = \\<alpha> \\<and>\n       (\\<forall>x. d_IN f x \\<le> value_flow \\<Delta> f)", "have \"d_IN (unlift f) x = (\\<Sum>\\<^sup>+ y\\<in>range Inner. f (y, Inner x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN (\\<lambda>(x, y). f (Inner x, Inner y)) x =\n    (\\<Sum>\\<^sup>+ y\\<in>range Inner. f (y, Inner x))", "by(simp add: nn_integral_count_space_reindex d_IN_def)"], ["proof (state)\nthis:\n  d_IN (\\<lambda>(x, y). f (Inner x, Inner y)) x =\n  (\\<Sum>\\<^sup>+ y\\<in>range Inner. f (y, Inner x))\n\ngoal (2 subgoals):\n 1. \\<And>r.\n       \\<lbrakk>0 \\<le> r; \\<alpha> = ennreal r\\<rbrakk>\n       \\<Longrightarrow> \\<exists>f.\n                            flow \\<Delta> f \\<and>\n                            value_flow \\<Delta> f = \\<alpha> \\<and>\n                            (\\<forall>x.\n                                d_IN f x \\<le> value_flow \\<Delta> f)\n 2. \\<alpha> = \\<top> \\<Longrightarrow>\n    \\<exists>f.\n       flow \\<Delta> f \\<and>\n       value_flow \\<Delta> f = \\<alpha> \\<and>\n       (\\<forall>x. d_IN f x \\<le> value_flow \\<Delta> f)", "also"], ["proof (state)\nthis:\n  d_IN (\\<lambda>(x, y). f (Inner x, Inner y)) x =\n  (\\<Sum>\\<^sup>+ y\\<in>range Inner. f (y, Inner x))\n\ngoal (2 subgoals):\n 1. \\<And>r.\n       \\<lbrakk>0 \\<le> r; \\<alpha> = ennreal r\\<rbrakk>\n       \\<Longrightarrow> \\<exists>f.\n                            flow \\<Delta> f \\<and>\n                            value_flow \\<Delta> f = \\<alpha> \\<and>\n                            (\\<forall>x.\n                                d_IN f x \\<le> value_flow \\<Delta> f)\n 2. \\<alpha> = \\<top> \\<Longrightarrow>\n    \\<exists>f.\n       flow \\<Delta> f \\<and>\n       value_flow \\<Delta> f = \\<alpha> \\<and>\n       (\\<forall>x. d_IN f x \\<le> value_flow \\<Delta> f)", "have \"\\<dots> \\<le> d_IN f (Inner x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y\\<in>range Inner. f (y, Inner x))\n    \\<le> d_IN f (Inner x)", "unfolding d_IN_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y\\<in>range Inner. f (y, Inner x))\n    \\<le> (\\<Sum>\\<^sup>+ xa. f (xa, Inner x))", "by(auto intro!: nn_integral_mono simp add: nn_integral_count_space_indicator split: split_indicator)"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y\\<in>range Inner. f (y, Inner x)) \\<le> d_IN f (Inner x)\n\ngoal (2 subgoals):\n 1. \\<And>r.\n       \\<lbrakk>0 \\<le> r; \\<alpha> = ennreal r\\<rbrakk>\n       \\<Longrightarrow> \\<exists>f.\n                            flow \\<Delta> f \\<and>\n                            value_flow \\<Delta> f = \\<alpha> \\<and>\n                            (\\<forall>x.\n                                d_IN f x \\<le> value_flow \\<Delta> f)\n 2. \\<alpha> = \\<top> \\<Longrightarrow>\n    \\<exists>f.\n       flow \\<Delta> f \\<and>\n       value_flow \\<Delta> f = \\<alpha> \\<and>\n       (\\<forall>x. d_IN f x \\<le> value_flow \\<Delta> f)", "also"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y\\<in>range Inner. f (y, Inner x)) \\<le> d_IN f (Inner x)\n\ngoal (2 subgoals):\n 1. \\<And>r.\n       \\<lbrakk>0 \\<le> r; \\<alpha> = ennreal r\\<rbrakk>\n       \\<Longrightarrow> \\<exists>f.\n                            flow \\<Delta> f \\<and>\n                            value_flow \\<Delta> f = \\<alpha> \\<and>\n                            (\\<forall>x.\n                                d_IN f x \\<le> value_flow \\<Delta> f)\n 2. \\<alpha> = \\<top> \\<Longrightarrow>\n    \\<exists>f.\n       flow \\<Delta> f \\<and>\n       value_flow \\<Delta> f = \\<alpha> \\<and>\n       (\\<forall>x. d_IN f x \\<le> value_flow \\<Delta> f)", "have \"\\<dots> \\<le> value_flow \\<Delta> (unlift f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN f (Inner x)\n    \\<le> value_flow \\<Delta> (\\<lambda>(x, y). f (Inner x, Inner y))", "using IN_f[of \"Inner x\"] f"], ["proof (prove)\nusing this:\n  d_IN f (Inner x) \\<le> value_flow \\<Delta>' f\n  flow \\<Delta>' f\n\ngoal (1 subgoal):\n 1. d_IN f (Inner x)\n    \\<le> value_flow \\<Delta> (\\<lambda>(x, y). f (Inner x, Inner y))", "by(simp add: value_unlift)"], ["proof (state)\nthis:\n  d_IN f (Inner x)\n  \\<le> value_flow \\<Delta> (\\<lambda>(x, y). f (Inner x, Inner y))\n\ngoal (2 subgoals):\n 1. \\<And>r.\n       \\<lbrakk>0 \\<le> r; \\<alpha> = ennreal r\\<rbrakk>\n       \\<Longrightarrow> \\<exists>f.\n                            flow \\<Delta> f \\<and>\n                            value_flow \\<Delta> f = \\<alpha> \\<and>\n                            (\\<forall>x.\n                                d_IN f x \\<le> value_flow \\<Delta> f)\n 2. \\<alpha> = \\<top> \\<Longrightarrow>\n    \\<exists>f.\n       flow \\<Delta> f \\<and>\n       value_flow \\<Delta> f = \\<alpha> \\<and>\n       (\\<forall>x. d_IN f x \\<le> value_flow \\<Delta> f)", "also"], ["proof (state)\nthis:\n  d_IN f (Inner x)\n  \\<le> value_flow \\<Delta> (\\<lambda>(x, y). f (Inner x, Inner y))\n\ngoal (2 subgoals):\n 1. \\<And>r.\n       \\<lbrakk>0 \\<le> r; \\<alpha> = ennreal r\\<rbrakk>\n       \\<Longrightarrow> \\<exists>f.\n                            flow \\<Delta> f \\<and>\n                            value_flow \\<Delta> f = \\<alpha> \\<and>\n                            (\\<forall>x.\n                                d_IN f x \\<le> value_flow \\<Delta> f)\n 2. \\<alpha> = \\<top> \\<Longrightarrow>\n    \\<exists>f.\n       flow \\<Delta> f \\<and>\n       value_flow \\<Delta> f = \\<alpha> \\<and>\n       (\\<forall>x. d_IN f x \\<le> value_flow \\<Delta> f)", "note calculation"], ["proof (state)\nthis:\n  d_IN (\\<lambda>(x, y). f (Inner x, Inner y)) x\n  \\<le> value_flow \\<Delta> (\\<lambda>(x, y). f (Inner x, Inner y))\n\ngoal (2 subgoals):\n 1. \\<And>r.\n       \\<lbrakk>0 \\<le> r; \\<alpha> = ennreal r\\<rbrakk>\n       \\<Longrightarrow> \\<exists>f.\n                            flow \\<Delta> f \\<and>\n                            value_flow \\<Delta> f = \\<alpha> \\<and>\n                            (\\<forall>x.\n                                d_IN f x \\<le> value_flow \\<Delta> f)\n 2. \\<alpha> = \\<top> \\<Longrightarrow>\n    \\<exists>f.\n       flow \\<Delta> f \\<and>\n       value_flow \\<Delta> f = \\<alpha> \\<and>\n       (\\<forall>x. d_IN f x \\<le> value_flow \\<Delta> f)", "}"], ["proof (state)\nthis:\n  d_IN (\\<lambda>(x, y). f (Inner x, Inner y)) ?x2\n  \\<le> value_flow \\<Delta> (\\<lambda>(x, y). f (Inner x, Inner y))\n\ngoal (2 subgoals):\n 1. \\<And>r.\n       \\<lbrakk>0 \\<le> r; \\<alpha> = ennreal r\\<rbrakk>\n       \\<Longrightarrow> \\<exists>f.\n                            flow \\<Delta> f \\<and>\n                            value_flow \\<Delta> f = \\<alpha> \\<and>\n                            (\\<forall>x.\n                                d_IN f x \\<le> value_flow \\<Delta> f)\n 2. \\<alpha> = \\<top> \\<Longrightarrow>\n    \\<exists>f.\n       flow \\<Delta> f \\<and>\n       value_flow \\<Delta> f = \\<alpha> \\<and>\n       (\\<forall>x. d_IN f x \\<le> value_flow \\<Delta> f)", "ultimately"], ["proof (chain)\npicking this:\n  flow \\<Delta> (\\<lambda>(x, y). f (Inner x, Inner y))\n  value_flow \\<Delta> (\\<lambda>(x, y). f (Inner x, Inner y)) = \\<alpha>\n  d_IN (\\<lambda>(x, y). f (Inner x, Inner y)) ?x2\n  \\<le> value_flow \\<Delta> (\\<lambda>(x, y). f (Inner x, Inner y))", "show ?thesis"], ["proof (prove)\nusing this:\n  flow \\<Delta> (\\<lambda>(x, y). f (Inner x, Inner y))\n  value_flow \\<Delta> (\\<lambda>(x, y). f (Inner x, Inner y)) = \\<alpha>\n  d_IN (\\<lambda>(x, y). f (Inner x, Inner y)) ?x2\n  \\<le> value_flow \\<Delta> (\\<lambda>(x, y). f (Inner x, Inner y))\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       flow \\<Delta> f \\<and>\n       value_flow \\<Delta> f = \\<alpha> \\<and>\n       (\\<forall>x. d_IN f x \\<le> value_flow \\<Delta> f)", "by blast"], ["proof (state)\nthis:\n  \\<exists>f.\n     flow \\<Delta> f \\<and>\n     value_flow \\<Delta> f = \\<alpha> \\<and>\n     (\\<forall>x. d_IN f x \\<le> value_flow \\<Delta> f)\n\ngoal (1 subgoal):\n 1. \\<alpha> = \\<top> \\<Longrightarrow>\n    \\<exists>f.\n       flow \\<Delta> f \\<and>\n       value_flow \\<Delta> f = \\<alpha> \\<and>\n       (\\<forall>x. d_IN f x \\<le> value_flow \\<Delta> f)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<alpha> = \\<top> \\<Longrightarrow>\n    \\<exists>f.\n       flow \\<Delta> f \\<and>\n       value_flow \\<Delta> f = \\<alpha> \\<and>\n       (\\<forall>x. d_IN f x \\<le> value_flow \\<Delta> f)", "case top"], ["proof (state)\nthis:\n  \\<alpha> = \\<top>\n\ngoal (1 subgoal):\n 1. \\<alpha> = \\<top> \\<Longrightarrow>\n    \\<exists>f.\n       flow \\<Delta> f \\<and>\n       value_flow \\<Delta> f = \\<alpha> \\<and>\n       (\\<forall>x. d_IN f x \\<le> value_flow \\<Delta> f)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>f.\n       flow \\<Delta> f \\<and>\n       value_flow \\<Delta> f = \\<alpha> \\<and>\n       (\\<forall>x. d_IN f x \\<le> value_flow \\<Delta> f)", "proof(cases \"\\<exists>f. flow \\<Delta> f \\<and> value_flow \\<Delta> f = \\<top>\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>f.\n       flow \\<Delta> f \\<and>\n       value_flow \\<Delta> f = \\<top> \\<Longrightarrow>\n    \\<exists>f.\n       flow \\<Delta> f \\<and>\n       value_flow \\<Delta> f = \\<alpha> \\<and>\n       (\\<forall>x. d_IN f x \\<le> value_flow \\<Delta> f)\n 2. \\<nexists>f.\n       flow \\<Delta> f \\<and>\n       value_flow \\<Delta> f = \\<top> \\<Longrightarrow>\n    \\<exists>f.\n       flow \\<Delta> f \\<and>\n       value_flow \\<Delta> f = \\<alpha> \\<and>\n       (\\<forall>x. d_IN f x \\<le> value_flow \\<Delta> f)", "case True"], ["proof (state)\nthis:\n  \\<exists>f. flow \\<Delta> f \\<and> value_flow \\<Delta> f = \\<top>\n\ngoal (2 subgoals):\n 1. \\<exists>f.\n       flow \\<Delta> f \\<and>\n       value_flow \\<Delta> f = \\<top> \\<Longrightarrow>\n    \\<exists>f.\n       flow \\<Delta> f \\<and>\n       value_flow \\<Delta> f = \\<alpha> \\<and>\n       (\\<forall>x. d_IN f x \\<le> value_flow \\<Delta> f)\n 2. \\<nexists>f.\n       flow \\<Delta> f \\<and>\n       value_flow \\<Delta> f = \\<top> \\<Longrightarrow>\n    \\<exists>f.\n       flow \\<Delta> f \\<and>\n       value_flow \\<Delta> f = \\<alpha> \\<and>\n       (\\<forall>x. d_IN f x \\<le> value_flow \\<Delta> f)", "with top"], ["proof (chain)\npicking this:\n  \\<alpha> = \\<top>\n  \\<exists>f. flow \\<Delta> f \\<and> value_flow \\<Delta> f = \\<top>", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<alpha> = \\<top>\n  \\<exists>f. flow \\<Delta> f \\<and> value_flow \\<Delta> f = \\<top>\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       flow \\<Delta> f \\<and>\n       value_flow \\<Delta> f = \\<alpha> \\<and>\n       (\\<forall>x. d_IN f x \\<le> value_flow \\<Delta> f)", "by auto"], ["proof (state)\nthis:\n  \\<exists>f.\n     flow \\<Delta> f \\<and>\n     value_flow \\<Delta> f = \\<alpha> \\<and>\n     (\\<forall>x. d_IN f x \\<le> value_flow \\<Delta> f)\n\ngoal (1 subgoal):\n 1. \\<nexists>f.\n       flow \\<Delta> f \\<and>\n       value_flow \\<Delta> f = \\<top> \\<Longrightarrow>\n    \\<exists>f.\n       flow \\<Delta> f \\<and>\n       value_flow \\<Delta> f = \\<alpha> \\<and>\n       (\\<forall>x. d_IN f x \\<le> value_flow \\<Delta> f)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<nexists>f.\n       flow \\<Delta> f \\<and>\n       value_flow \\<Delta> f = \\<top> \\<Longrightarrow>\n    \\<exists>f.\n       flow \\<Delta> f \\<and>\n       value_flow \\<Delta> f = \\<alpha> \\<and>\n       (\\<forall>x. d_IN f x \\<le> value_flow \\<Delta> f)", "case False"], ["proof (state)\nthis:\n  \\<nexists>f. flow \\<Delta> f \\<and> value_flow \\<Delta> f = \\<top>\n\ngoal (1 subgoal):\n 1. \\<nexists>f.\n       flow \\<Delta> f \\<and>\n       value_flow \\<Delta> f = \\<top> \\<Longrightarrow>\n    \\<exists>f.\n       flow \\<Delta> f \\<and>\n       value_flow \\<Delta> f = \\<alpha> \\<and>\n       (\\<forall>x. d_IN f x \\<le> value_flow \\<Delta> f)", "hence real: \"\\<forall>f. \\<alpha> = \\<top> \\<longrightarrow> flow \\<Delta> f \\<longrightarrow> value_flow \\<Delta> f < \\<alpha>\""], ["proof (prove)\nusing this:\n  \\<nexists>f. flow \\<Delta> f \\<and> value_flow \\<Delta> f = \\<top>\n\ngoal (1 subgoal):\n 1. \\<forall>f.\n       \\<alpha> = \\<top> \\<longrightarrow>\n       flow \\<Delta> f \\<longrightarrow> value_flow \\<Delta> f < \\<alpha>", "using top"], ["proof (prove)\nusing this:\n  \\<nexists>f. flow \\<Delta> f \\<and> value_flow \\<Delta> f = \\<top>\n  \\<alpha> = \\<top>\n\ngoal (1 subgoal):\n 1. \\<forall>f.\n       \\<alpha> = \\<top> \\<longrightarrow>\n       flow \\<Delta> f \\<longrightarrow> value_flow \\<Delta> f < \\<alpha>", "by (auto simp: less_top)"], ["proof (state)\nthis:\n  \\<forall>f.\n     \\<alpha> = \\<top> \\<longrightarrow>\n     flow \\<Delta> f \\<longrightarrow> value_flow \\<Delta> f < \\<alpha>\n\ngoal (1 subgoal):\n 1. \\<nexists>f.\n       flow \\<Delta> f \\<and>\n       value_flow \\<Delta> f = \\<top> \\<Longrightarrow>\n    \\<exists>f.\n       flow \\<Delta> f \\<and>\n       value_flow \\<Delta> f = \\<alpha> \\<and>\n       (\\<forall>x. d_IN f x \\<le> value_flow \\<Delta> f)", "{"], ["proof (state)\nthis:\n  \\<forall>f.\n     \\<alpha> = \\<top> \\<longrightarrow>\n     flow \\<Delta> f \\<longrightarrow> value_flow \\<Delta> f < \\<alpha>\n\ngoal (1 subgoal):\n 1. \\<nexists>f.\n       flow \\<Delta> f \\<and>\n       value_flow \\<Delta> f = \\<top> \\<Longrightarrow>\n    \\<exists>f.\n       flow \\<Delta> f \\<and>\n       value_flow \\<Delta> f = \\<alpha> \\<and>\n       (\\<forall>x. d_IN f x \\<le> value_flow \\<Delta> f)", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<nexists>f.\n       flow \\<Delta> f \\<and>\n       value_flow \\<Delta> f = \\<top> \\<Longrightarrow>\n    \\<exists>f.\n       flow \\<Delta> f \\<and>\n       value_flow \\<Delta> f = \\<alpha> \\<and>\n       (\\<forall>x. d_IN f x \\<le> value_flow \\<Delta> f)", "have \"2 * 2 ^ i < \\<alpha>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * 2 ^ i < \\<alpha>", "using top"], ["proof (prove)\nusing this:\n  \\<alpha> = \\<top>\n\ngoal (1 subgoal):\n 1. 2 * 2 ^ i < \\<alpha>", "by (simp_all add: ennreal_mult_less_top power_less_top_ennreal)"], ["proof (state)\nthis:\n  2 * 2 ^ i < \\<alpha>\n\ngoal (1 subgoal):\n 1. \\<nexists>f.\n       flow \\<Delta> f \\<and>\n       value_flow \\<Delta> f = \\<top> \\<Longrightarrow>\n    \\<exists>f.\n       flow \\<Delta> f \\<and>\n       value_flow \\<Delta> f = \\<alpha> \\<and>\n       (\\<forall>x. d_IN f x \\<le> value_flow \\<Delta> f)", "from flow_by_value[OF this real]"], ["proof (chain)\npicking this:\n  (\\<And>f.\n      \\<lbrakk>flow \\<Delta> f; value_flow \\<Delta> f = 2 * 2 ^ i\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis", "have \"\\<exists>f. flow \\<Delta> f \\<and> value_flow \\<Delta> f = 2 * 2 ^ i\""], ["proof (prove)\nusing this:\n  (\\<And>f.\n      \\<lbrakk>flow \\<Delta> f; value_flow \\<Delta> f = 2 * 2 ^ i\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. \\<exists>f. flow \\<Delta> f \\<and> value_flow \\<Delta> f = 2 * 2 ^ i", "by blast"], ["proof (state)\nthis:\n  \\<exists>f. flow \\<Delta> f \\<and> value_flow \\<Delta> f = 2 * 2 ^ i\n\ngoal (1 subgoal):\n 1. \\<nexists>f.\n       flow \\<Delta> f \\<and>\n       value_flow \\<Delta> f = \\<top> \\<Longrightarrow>\n    \\<exists>f.\n       flow \\<Delta> f \\<and>\n       value_flow \\<Delta> f = \\<alpha> \\<and>\n       (\\<forall>x. d_IN f x \\<le> value_flow \\<Delta> f)", "}"], ["proof (state)\nthis:\n  \\<exists>f. flow \\<Delta> f \\<and> value_flow \\<Delta> f = 2 * 2 ^ ?i2\n\ngoal (1 subgoal):\n 1. \\<nexists>f.\n       flow \\<Delta> f \\<and>\n       value_flow \\<Delta> f = \\<top> \\<Longrightarrow>\n    \\<exists>f.\n       flow \\<Delta> f \\<and>\n       value_flow \\<Delta> f = \\<alpha> \\<and>\n       (\\<forall>x. d_IN f x \\<le> value_flow \\<Delta> f)", "then"], ["proof (chain)\npicking this:\n  \\<exists>f. flow \\<Delta> f \\<and> value_flow \\<Delta> f = 2 * 2 ^ ?i2", "obtain f_i where f_i: \"\\<And>i. flow \\<Delta> (f_i i)\"\n      and value_i: \"\\<And>i. value_flow \\<Delta> (f_i i) = 2 * 2 ^ i\""], ["proof (prove)\nusing this:\n  \\<exists>f. flow \\<Delta> f \\<and> value_flow \\<Delta> f = 2 * 2 ^ ?i2\n\ngoal (1 subgoal):\n 1. (\\<And>f_i.\n        \\<lbrakk>\\<And>i. flow \\<Delta> (f_i i);\n         \\<And>i. value_flow \\<Delta> (f_i i) = 2 * 2 ^ i\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  flow \\<Delta> (f_i ?i)\n  value_flow \\<Delta> (f_i ?i) = 2 * 2 ^ ?i\n\ngoal (1 subgoal):\n 1. \\<nexists>f.\n       flow \\<Delta> f \\<and>\n       value_flow \\<Delta> f = \\<top> \\<Longrightarrow>\n    \\<exists>f.\n       flow \\<Delta> f \\<and>\n       value_flow \\<Delta> f = \\<alpha> \\<and>\n       (\\<forall>x. d_IN f x \\<le> value_flow \\<Delta> f)", "define f where \"f e = (\\<Sum>\\<^sup>+ i. f_i i e / (2 * 2 ^ i))\" for e"], ["proof (state)\nthis:\n  f ?e = (\\<Sum>\\<^sup>+ i. f_i i ?e / (2 * 2 ^ i))\n\ngoal (1 subgoal):\n 1. \\<nexists>f.\n       flow \\<Delta> f \\<and>\n       value_flow \\<Delta> f = \\<top> \\<Longrightarrow>\n    \\<exists>f.\n       flow \\<Delta> f \\<and>\n       value_flow \\<Delta> f = \\<alpha> \\<and>\n       (\\<forall>x. d_IN f x \\<le> value_flow \\<Delta> f)", "have \"flow \\<Delta> f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. flow \\<Delta> f", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>e. f e \\<le> capacity \\<Delta> e\n 2. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>;\n        x \\<noteq> sink \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> KIR f x", "fix e"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>e. f e \\<le> capacity \\<Delta> e\n 2. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>;\n        x \\<noteq> sink \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> KIR f x", "have \"f e \\<le> (\\<Sum>\\<^sup>+ i. (SUP i. f_i i e) / (2 * 2 ^ i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f e \\<le> (\\<Sum>\\<^sup>+ i. (\\<Squnion>i. f_i i e) / (2 * 2 ^ i))", "unfolding f_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ i. f_i i e / (2 * 2 ^ i))\n    \\<le> (\\<Sum>\\<^sup>+ i. (\\<Squnion>i. f_i i e) / (2 * 2 ^ i))", "by(rule nn_integral_mono)(auto intro!: divide_right_mono_ennreal SUP_upper)"], ["proof (state)\nthis:\n  f e \\<le> (\\<Sum>\\<^sup>+ i. (\\<Squnion>i. f_i i e) / (2 * 2 ^ i))\n\ngoal (2 subgoals):\n 1. \\<And>e. f e \\<le> capacity \\<Delta> e\n 2. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>;\n        x \\<noteq> sink \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> KIR f x", "also"], ["proof (state)\nthis:\n  f e \\<le> (\\<Sum>\\<^sup>+ i. (\\<Squnion>i. f_i i e) / (2 * 2 ^ i))\n\ngoal (2 subgoals):\n 1. \\<And>e. f e \\<le> capacity \\<Delta> e\n 2. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>;\n        x \\<noteq> sink \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> KIR f x", "have \"\\<dots> = (SUP i. f_i i e) / 2 * (\\<Sum>\\<^sup>+ i. 1 / 2 ^ i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ i. (\\<Squnion>i. f_i i e) / (2 * 2 ^ i)) =\n    (\\<Squnion>i. f_i i e) / 2 * (\\<Sum>\\<^sup>+ i. 1 / 2 ^ i)", "apply(subst nn_integral_cmult[symmetric])"], ["proof (prove)\ngoal (2 subgoals):\n 1. (\\<lambda>i. 1 / 2 ^ i) \\<in> borel_measurable (count_space UNIV)\n 2. (\\<Sum>\\<^sup>+ i. (\\<Squnion>i. f_i i e) / (2 * 2 ^ i)) =\n    (\\<Sum>\\<^sup>+ x. (\\<Squnion>i. f_i i e) / 2 * (1 / 2 ^ x))", "apply(auto intro!: nn_integral_cong intro: SUP_upper2\n          simp: divide_ennreal_def ennreal_inverse_mult power_less_top_ennreal mult_ac)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ i. (\\<Squnion>i. f_i i e) / (2 * 2 ^ i)) =\n  (\\<Squnion>i. f_i i e) / 2 * (\\<Sum>\\<^sup>+ i. 1 / 2 ^ i)\n\ngoal (2 subgoals):\n 1. \\<And>e. f e \\<le> capacity \\<Delta> e\n 2. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>;\n        x \\<noteq> sink \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> KIR f x", "also"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ i. (\\<Squnion>i. f_i i e) / (2 * 2 ^ i)) =\n  (\\<Squnion>i. f_i i e) / 2 * (\\<Sum>\\<^sup>+ i. 1 / 2 ^ i)\n\ngoal (2 subgoals):\n 1. \\<And>e. f e \\<le> capacity \\<Delta> e\n 2. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>;\n        x \\<noteq> sink \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> KIR f x", "have \"(\\<Sum>\\<^sup>+ i. 1 / 2 ^ i) = (\\<Sum>i. ennreal ((1 / 2) ^ i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ i. 1 / 2 ^ i) = (\\<Sum>i. ennreal ((1 / 2) ^ i))", "by(simp add: nn_integral_count_space_nat power_divide divide_ennreal[symmetric] ennreal_power[symmetric])"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ i. 1 / 2 ^ i) = (\\<Sum>i. ennreal ((1 / 2) ^ i))\n\ngoal (2 subgoals):\n 1. \\<And>e. f e \\<le> capacity \\<Delta> e\n 2. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>;\n        x \\<noteq> sink \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> KIR f x", "also"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ i. 1 / 2 ^ i) = (\\<Sum>i. ennreal ((1 / 2) ^ i))\n\ngoal (2 subgoals):\n 1. \\<And>e. f e \\<le> capacity \\<Delta> e\n 2. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>;\n        x \\<noteq> sink \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> KIR f x", "have \"\\<dots> = ennreal (\\<Sum>i. (1 / 2) ^ i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i. ennreal ((1 / 2) ^ i)) = ennreal (\\<Sum>i. (1 / 2) ^ i)", "by(intro suminf_ennreal2 complete_algebra_summable_geometric) simp_all"], ["proof (state)\nthis:\n  (\\<Sum>i. ennreal ((1 / 2) ^ i)) = ennreal (\\<Sum>i. (1 / 2) ^ i)\n\ngoal (2 subgoals):\n 1. \\<And>e. f e \\<le> capacity \\<Delta> e\n 2. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>;\n        x \\<noteq> sink \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> KIR f x", "also"], ["proof (state)\nthis:\n  (\\<Sum>i. ennreal ((1 / 2) ^ i)) = ennreal (\\<Sum>i. (1 / 2) ^ i)\n\ngoal (2 subgoals):\n 1. \\<And>e. f e \\<le> capacity \\<Delta> e\n 2. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>;\n        x \\<noteq> sink \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> KIR f x", "have \"\\<dots> = 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ennreal (\\<Sum>i. (1 / 2) ^ i) = 2", "by(subst suminf_geometric; simp)"], ["proof (state)\nthis:\n  ennreal (\\<Sum>i. (1 / 2) ^ i) = 2\n\ngoal (2 subgoals):\n 1. \\<And>e. f e \\<le> capacity \\<Delta> e\n 2. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>;\n        x \\<noteq> sink \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> KIR f x", "also"], ["proof (state)\nthis:\n  ennreal (\\<Sum>i. (1 / 2) ^ i) = 2\n\ngoal (2 subgoals):\n 1. \\<And>e. f e \\<le> capacity \\<Delta> e\n 2. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>;\n        x \\<noteq> sink \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> KIR f x", "have \"(SUP i. f_i i e) / 2 * 2 = (SUP i. f_i i e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Squnion>i. f_i i e) / 2 * 2 = (\\<Squnion>i. f_i i e)", "by (simp add: ennreal_divide_times)"], ["proof (state)\nthis:\n  (\\<Squnion>i. f_i i e) / 2 * 2 = (\\<Squnion>i. f_i i e)\n\ngoal (2 subgoals):\n 1. \\<And>e. f e \\<le> capacity \\<Delta> e\n 2. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>;\n        x \\<noteq> sink \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> KIR f x", "also"], ["proof (state)\nthis:\n  (\\<Squnion>i. f_i i e) / 2 * 2 = (\\<Squnion>i. f_i i e)\n\ngoal (2 subgoals):\n 1. \\<And>e. f e \\<le> capacity \\<Delta> e\n 2. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>;\n        x \\<noteq> sink \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> KIR f x", "have \"\\<dots> \\<le> capacity \\<Delta> e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Squnion>i. f_i i e) \\<le> capacity \\<Delta> e", "by(rule SUP_least)(rule flowD_capacity[OF f_i])"], ["proof (state)\nthis:\n  (\\<Squnion>i. f_i i e) \\<le> capacity \\<Delta> e\n\ngoal (2 subgoals):\n 1. \\<And>e. f e \\<le> capacity \\<Delta> e\n 2. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>;\n        x \\<noteq> sink \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> KIR f x", "finally"], ["proof (chain)\npicking this:\n  f e \\<le> capacity \\<Delta> e", "show \"f e \\<le> capacity \\<Delta> e\""], ["proof (prove)\nusing this:\n  f e \\<le> capacity \\<Delta> e\n\ngoal (1 subgoal):\n 1. f e \\<le> capacity \\<Delta> e", "."], ["proof (state)\nthis:\n  f e \\<le> capacity \\<Delta> e\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>;\n        x \\<noteq> sink \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> KIR f x", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>;\n        x \\<noteq> sink \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> KIR f x", "assume x: \"x \\<noteq> source \\<Delta>\" \"x \\<noteq> sink \\<Delta>\""], ["proof (state)\nthis:\n  x \\<noteq> source \\<Delta>\n  x \\<noteq> sink \\<Delta>\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>;\n        x \\<noteq> sink \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> KIR f x", "have \"d_OUT f x = (\\<Sum>\\<^sup>+ i\\<in>UNIV. \\<Sum>\\<^sup>+ y. f_i i (x, y) / (2 * 2 ^ i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT f x =\n    (\\<Sum>\\<^sup>+ i. \\<Sum>\\<^sup>+ y. f_i i (x, y) / (2 * 2 ^ i))", "unfolding d_OUT_def f_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y. \\<Sum>\\<^sup>+ i. f_i i (x, y) / (2 * 2 ^ i)) =\n    (\\<Sum>\\<^sup>+ i. \\<Sum>\\<^sup>+ y. f_i i (x, y) / (2 * 2 ^ i))", "by(subst nn_integral_snd_count_space[where f=\"case_prod _\", simplified])\n          (simp add: nn_integral_fst_count_space[where f=\"case_prod _\", simplified])"], ["proof (state)\nthis:\n  d_OUT f x =\n  (\\<Sum>\\<^sup>+ i. \\<Sum>\\<^sup>+ y. f_i i (x, y) / (2 * 2 ^ i))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>;\n        x \\<noteq> sink \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> KIR f x", "also"], ["proof (state)\nthis:\n  d_OUT f x =\n  (\\<Sum>\\<^sup>+ i. \\<Sum>\\<^sup>+ y. f_i i (x, y) / (2 * 2 ^ i))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>;\n        x \\<noteq> sink \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> KIR f x", "have \"\\<dots> = (\\<Sum>\\<^sup>+ i. d_OUT (f_i i) x / (2 * 2 ^ i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ i. \\<Sum>\\<^sup>+ y. f_i i (x, y) / (2 * 2 ^ i)) =\n    (\\<Sum>\\<^sup>+ i. d_OUT (f_i i) x / (2 * 2 ^ i))", "unfolding d_OUT_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ i. \\<Sum>\\<^sup>+ y. f_i i (x, y) / (2 * 2 ^ i)) =\n    (\\<Sum>\\<^sup>+ i. (\\<Sum>\\<^sup>+ y. f_i i (x, y)) / (2 * 2 ^ i))", "by(simp add: nn_integral_divide)"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ i. \\<Sum>\\<^sup>+ y. f_i i (x, y) / (2 * 2 ^ i)) =\n  (\\<Sum>\\<^sup>+ i. d_OUT (f_i i) x / (2 * 2 ^ i))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>;\n        x \\<noteq> sink \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> KIR f x", "also"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ i. \\<Sum>\\<^sup>+ y. f_i i (x, y) / (2 * 2 ^ i)) =\n  (\\<Sum>\\<^sup>+ i. d_OUT (f_i i) x / (2 * 2 ^ i))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>;\n        x \\<noteq> sink \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> KIR f x", "have \"\\<dots> = (\\<Sum>\\<^sup>+ i. d_IN (f_i i) x / (2 * 2 ^ i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ i. d_OUT (f_i i) x / (2 * 2 ^ i)) =\n    (\\<Sum>\\<^sup>+ i. d_IN (f_i i) x / (2 * 2 ^ i))", "by(simp add: flowD_KIR[OF f_i, OF x])"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ i. d_OUT (f_i i) x / (2 * 2 ^ i)) =\n  (\\<Sum>\\<^sup>+ i. d_IN (f_i i) x / (2 * 2 ^ i))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>;\n        x \\<noteq> sink \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> KIR f x", "also"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ i. d_OUT (f_i i) x / (2 * 2 ^ i)) =\n  (\\<Sum>\\<^sup>+ i. d_IN (f_i i) x / (2 * 2 ^ i))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>;\n        x \\<noteq> sink \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> KIR f x", "have \"\\<dots> = (\\<Sum>\\<^sup>+ i\\<in>UNIV. \\<Sum>\\<^sup>+ y. f_i i (y, x) / (2 * 2 ^ i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ i. d_IN (f_i i) x / (2 * 2 ^ i)) =\n    (\\<Sum>\\<^sup>+ i. \\<Sum>\\<^sup>+ y. f_i i (y, x) / (2 * 2 ^ i))", "by(simp add: nn_integral_divide d_IN_def)"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ i. d_IN (f_i i) x / (2 * 2 ^ i)) =\n  (\\<Sum>\\<^sup>+ i. \\<Sum>\\<^sup>+ y. f_i i (y, x) / (2 * 2 ^ i))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>;\n        x \\<noteq> sink \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> KIR f x", "also"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ i. d_IN (f_i i) x / (2 * 2 ^ i)) =\n  (\\<Sum>\\<^sup>+ i. \\<Sum>\\<^sup>+ y. f_i i (y, x) / (2 * 2 ^ i))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>;\n        x \\<noteq> sink \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> KIR f x", "have \"\\<dots> = d_IN f x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ i. \\<Sum>\\<^sup>+ y. f_i i (y, x) / (2 * 2 ^ i)) =\n    d_IN f x", "unfolding d_IN_def f_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ i. \\<Sum>\\<^sup>+ y. f_i i (y, x) / (2 * 2 ^ i)) =\n    (\\<Sum>\\<^sup>+ xa. \\<Sum>\\<^sup>+ i. f_i i (xa, x) / (2 * 2 ^ i))", "by(subst nn_integral_snd_count_space[where f=\"case_prod _\", simplified])\n          (simp add: nn_integral_fst_count_space[where f=\"case_prod _\", simplified])"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ i. \\<Sum>\\<^sup>+ y. f_i i (y, x) / (2 * 2 ^ i)) =\n  d_IN f x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>;\n        x \\<noteq> sink \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> KIR f x", "finally"], ["proof (chain)\npicking this:\n  KIR f x", "show \"KIR f x\""], ["proof (prove)\nusing this:\n  KIR f x\n\ngoal (1 subgoal):\n 1. KIR f x", "."], ["proof (state)\nthis:\n  KIR f x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  flow \\<Delta> f\n\ngoal (1 subgoal):\n 1. \\<nexists>f.\n       flow \\<Delta> f \\<and>\n       value_flow \\<Delta> f = \\<top> \\<Longrightarrow>\n    \\<exists>f.\n       flow \\<Delta> f \\<and>\n       value_flow \\<Delta> f = \\<alpha> \\<and>\n       (\\<forall>x. d_IN f x \\<le> value_flow \\<Delta> f)", "moreover"], ["proof (state)\nthis:\n  flow \\<Delta> f\n\ngoal (1 subgoal):\n 1. \\<nexists>f.\n       flow \\<Delta> f \\<and>\n       value_flow \\<Delta> f = \\<top> \\<Longrightarrow>\n    \\<exists>f.\n       flow \\<Delta> f \\<and>\n       value_flow \\<Delta> f = \\<alpha> \\<and>\n       (\\<forall>x. d_IN f x \\<le> value_flow \\<Delta> f)", "{"], ["proof (state)\nthis:\n  flow \\<Delta> f\n\ngoal (1 subgoal):\n 1. \\<nexists>f.\n       flow \\<Delta> f \\<and>\n       value_flow \\<Delta> f = \\<top> \\<Longrightarrow>\n    \\<exists>f.\n       flow \\<Delta> f \\<and>\n       value_flow \\<Delta> f = \\<alpha> \\<and>\n       (\\<forall>x. d_IN f x \\<le> value_flow \\<Delta> f)", "have \"value_flow \\<Delta> f = (\\<Sum>\\<^sup>+ i. value_flow \\<Delta> (f_i i) / (2 * 2 ^ i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. value_flow \\<Delta> f =\n    (\\<Sum>\\<^sup>+ i. value_flow \\<Delta> (f_i i) / (2 * 2 ^ i))", "unfolding d_OUT_def f_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y.\n       \\<Sum>\\<^sup>+ i. f_i i (source \\<Delta>, y) / (2 * 2 ^ i)) =\n    (\\<Sum>\\<^sup>+ i.\n       (\\<Sum>\\<^sup>+ y. f_i i (source \\<Delta>, y)) / (2 * 2 ^ i))", "by(subst nn_integral_snd_count_space[where f=\"case_prod _\", simplified])\n          (simp add: nn_integral_fst_count_space[where f=\"case_prod _\", simplified] nn_integral_divide[symmetric])"], ["proof (state)\nthis:\n  value_flow \\<Delta> f =\n  (\\<Sum>\\<^sup>+ i. value_flow \\<Delta> (f_i i) / (2 * 2 ^ i))\n\ngoal (1 subgoal):\n 1. \\<nexists>f.\n       flow \\<Delta> f \\<and>\n       value_flow \\<Delta> f = \\<top> \\<Longrightarrow>\n    \\<exists>f.\n       flow \\<Delta> f \\<and>\n       value_flow \\<Delta> f = \\<alpha> \\<and>\n       (\\<forall>x. d_IN f x \\<le> value_flow \\<Delta> f)", "also"], ["proof (state)\nthis:\n  value_flow \\<Delta> f =\n  (\\<Sum>\\<^sup>+ i. value_flow \\<Delta> (f_i i) / (2 * 2 ^ i))\n\ngoal (1 subgoal):\n 1. \\<nexists>f.\n       flow \\<Delta> f \\<and>\n       value_flow \\<Delta> f = \\<top> \\<Longrightarrow>\n    \\<exists>f.\n       flow \\<Delta> f \\<and>\n       value_flow \\<Delta> f = \\<alpha> \\<and>\n       (\\<forall>x. d_IN f x \\<le> value_flow \\<Delta> f)", "have \"\\<dots> = \\<top>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ i. value_flow \\<Delta> (f_i i) / (2 * 2 ^ i)) = \\<top>", "by(simp add: value_i ennreal_mult_less_top power_less_top_ennreal)"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ i. value_flow \\<Delta> (f_i i) / (2 * 2 ^ i)) = \\<top>\n\ngoal (1 subgoal):\n 1. \\<nexists>f.\n       flow \\<Delta> f \\<and>\n       value_flow \\<Delta> f = \\<top> \\<Longrightarrow>\n    \\<exists>f.\n       flow \\<Delta> f \\<and>\n       value_flow \\<Delta> f = \\<alpha> \\<and>\n       (\\<forall>x. d_IN f x \\<le> value_flow \\<Delta> f)", "finally"], ["proof (chain)\npicking this:\n  value_flow \\<Delta> f = \\<top>", "have \"value_flow \\<Delta> f = \\<top>\""], ["proof (prove)\nusing this:\n  value_flow \\<Delta> f = \\<top>\n\ngoal (1 subgoal):\n 1. value_flow \\<Delta> f = \\<top>", "."], ["proof (state)\nthis:\n  value_flow \\<Delta> f = \\<top>\n\ngoal (1 subgoal):\n 1. \\<nexists>f.\n       flow \\<Delta> f \\<and>\n       value_flow \\<Delta> f = \\<top> \\<Longrightarrow>\n    \\<exists>f.\n       flow \\<Delta> f \\<and>\n       value_flow \\<Delta> f = \\<alpha> \\<and>\n       (\\<forall>x. d_IN f x \\<le> value_flow \\<Delta> f)", "}"], ["proof (state)\nthis:\n  value_flow \\<Delta> f = \\<top>\n\ngoal (1 subgoal):\n 1. \\<nexists>f.\n       flow \\<Delta> f \\<and>\n       value_flow \\<Delta> f = \\<top> \\<Longrightarrow>\n    \\<exists>f.\n       flow \\<Delta> f \\<and>\n       value_flow \\<Delta> f = \\<alpha> \\<and>\n       (\\<forall>x. d_IN f x \\<le> value_flow \\<Delta> f)", "ultimately"], ["proof (chain)\npicking this:\n  flow \\<Delta> f\n  value_flow \\<Delta> f = \\<top>", "show ?thesis"], ["proof (prove)\nusing this:\n  flow \\<Delta> f\n  value_flow \\<Delta> f = \\<top>\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       flow \\<Delta> f \\<and>\n       value_flow \\<Delta> f = \\<alpha> \\<and>\n       (\\<forall>x. d_IN f x \\<le> value_flow \\<Delta> f)", "using top"], ["proof (prove)\nusing this:\n  flow \\<Delta> f\n  value_flow \\<Delta> f = \\<top>\n  \\<alpha> = \\<top>\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       flow \\<Delta> f \\<and>\n       value_flow \\<Delta> f = \\<alpha> \\<and>\n       (\\<forall>x. d_IN f x \\<le> value_flow \\<Delta> f)", "by auto"], ["proof (state)\nthis:\n  \\<exists>f.\n     flow \\<Delta> f \\<and>\n     value_flow \\<Delta> f = \\<alpha> \\<and>\n     (\\<forall>x. d_IN f x \\<le> value_flow \\<Delta> f)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>f.\n     flow \\<Delta> f \\<and>\n     value_flow \\<Delta> f = \\<alpha> \\<and>\n     (\\<forall>x. d_IN f x \\<le> value_flow \\<Delta> f)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "end"], ["", "end"], ["", "end"]]}