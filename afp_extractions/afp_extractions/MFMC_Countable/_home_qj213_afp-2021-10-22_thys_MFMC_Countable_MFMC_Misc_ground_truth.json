{"file_name": "/home/qj213/afp-2021-10-22/thys/MFMC_Countable/MFMC_Misc.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/MFMC_Countable", "problem_names": ["lemmas disjE [consumes 1, case_names left right, cases pred] = disjE", "lemma inj_on_Pair2 [simp]: \"inj_on (Pair x) A\"", "lemma inj_on_Pair1 [simp]: \"inj_on (\\<lambda>x. (x, y)) A\"", "lemma inj_map_prod': \"\\<lbrakk> inj f; inj g \\<rbrakk> \\<Longrightarrow> inj_on (map_prod f g) X\"", "lemma not_range_Inr: \"x \\<notin> range Inr \\<longleftrightarrow> x \\<in> range Inl\"", "lemma not_range_Inl: \"x \\<notin> range Inl \\<longleftrightarrow> x \\<in> range Inr\"", "lemma Chains_into_chain: \"M \\<in> Chains {(x, y). R x y} \\<Longrightarrow> Complete_Partial_Order.chain R M\"", "lemma chain_dual: \"Complete_Partial_Order.chain (\\<ge>) = Complete_Partial_Order.chain (\\<le>)\"", "lemma Cauchy_real_Suc_diff:\n  fixes X :: \"nat \\<Rightarrow> real\" and x :: real\n  assumes bounded: \"\\<And>n. \\<bar>f (Suc n) - f n\\<bar> \\<le> (c / x ^ n)\"\n  and x: \"1 < x\"\n  shows \"Cauchy f\"", "lemma complete_lattice_ccpo_dual:\n  \"class.ccpo Inf (\\<ge>) ((>) :: _ :: complete_lattice \\<Rightarrow> _)\"", "lemma card_eq_1_iff: \"card A = Suc 0 \\<longleftrightarrow> (\\<exists>x. A = {x})\"", "lemma nth_rotate1: \"n < length xs \\<Longrightarrow> rotate1 xs ! n = xs ! (Suc n mod length xs)\"", "lemma set_zip_rightI: \"\\<lbrakk> x \\<in> set ys; length xs \\<ge> length ys \\<rbrakk> \\<Longrightarrow> \\<exists>z. (z, x) \\<in> set (zip xs ys)\"", "lemma map_eq_append_conv:\n  \"map f xs = ys @ zs \\<longleftrightarrow> (\\<exists>ys' zs'. xs = ys' @ zs' \\<and> ys = map f ys' \\<and> zs = map f zs')\"", "lemma rotate1_append:\n  \"rotate1 (xs @ ys) = (if xs = [] then rotate1 ys else tl xs @ ys @ [hd xs])\"", "lemma in_set_tlD: \"x \\<in> set (tl xs) \\<Longrightarrow> x \\<in> set xs\"", "lemma countable_converseI:\n  assumes \"countable A\"\n  shows \"countable (converse A)\"", "lemma countable_converse [simp]: \"countable (converse A) \\<longleftrightarrow> countable A\"", "lemma nn_integral_count_space_reindex:\n  \"inj_on f A \\<Longrightarrow>(\\<integral>\\<^sup>+ y. g y \\<partial>count_space (f ` A)) = (\\<integral>\\<^sup>+ x. g (f x) \\<partial>count_space A)\"", "lemma in_restrict_rel_iff: \"(x, y) \\<in> restrict_rel A R \\<longleftrightarrow> (x, y) \\<in> R \\<and> x \\<in> A \\<and> y \\<in> A\"", "lemma restrict_relE: \"\\<lbrakk> (x, y) \\<in> restrict_rel A R; \\<lbrakk> (x, y) \\<in> R; x \\<in> A; y \\<in> A \\<rbrakk> \\<Longrightarrow> thesis \\<rbrakk> \\<Longrightarrow> thesis\"", "lemma restrict_relI [intro!]: \"\\<lbrakk> (x, y) \\<in> R; x \\<in> A; y \\<in> A \\<rbrakk> \\<Longrightarrow> (x, y) \\<in> restrict_rel A R\"", "lemma Field_restrict_rel_subset: \"Field (restrict_rel A R) \\<subseteq> A \\<inter> Field R\"", "lemma Field_restrict_rel [simp]: \"Refl R \\<Longrightarrow> Field (restrict_rel A R) = A \\<inter> Field R\"", "lemma Partial_order_restrict_rel:\n  assumes \"Partial_order R\"\n  shows \"Partial_order (restrict_rel A R)\"", "lemma Chains_restrict_relD: \"M \\<in> Chains (restrict_rel A leq) \\<Longrightarrow> M \\<in> Chains leq\"", "lemma bourbaki_witt_fixpoint_restrict_rel:\n  assumes leq: \"Partial_order leq\"\n  and chain_Field: \"\\<And>M. \\<lbrakk> M \\<in> Chains (restrict_rel A leq); M \\<noteq> {} \\<rbrakk> \\<Longrightarrow> lub M \\<in> A\"\n  and lub_least: \"\\<And>M z. \\<lbrakk> M \\<in> Chains leq; M \\<noteq> {}; \\<And>x. x \\<in> M \\<Longrightarrow> (x, z) \\<in> leq \\<rbrakk> \\<Longrightarrow> (lub M, z) \\<in> leq\"\n  and lub_upper: \"\\<And>M z. \\<lbrakk> M \\<in> Chains leq; z \\<in> M \\<rbrakk> \\<Longrightarrow> (z, lub M) \\<in> leq\"\n  and increasing: \"\\<And>x. \\<lbrakk> x \\<in> A; x \\<in> Field leq \\<rbrakk> \\<Longrightarrow> (x, f x) \\<in> leq \\<and> f x \\<in> A\"\n  shows \"bourbaki_witt_fixpoint lub (restrict_rel A leq) f\"", "lemma Field_le [simp]: \"Field {(x :: _ :: preorder, y). x \\<le> y} = UNIV\"", "lemma Field_ge [simp]: \"Field {(x :: _ :: preorder, y). y \\<le> x} = UNIV\"", "lemma refl_le [simp]: \"refl {(x :: _ :: preorder, y). x \\<le> y}\"", "lemma refl_ge [simp]: \"refl {(x :: _ :: preorder, y). y \\<le> x}\"", "lemma partial_order_le [simp]: \"partial_order_on UNIV {(x :: _ :: order, x'). x \\<le> x'}\"", "lemma partial_order_ge [simp]: \"partial_order_on UNIV {(x :: _ :: order, x'). x' \\<le> x}\"", "lemma incseq_chain_range: \"incseq f \\<Longrightarrow> Complete_Partial_Order.chain (\\<le>) (range f)\""], "translations": [["", "lemmas disjE [consumes 1, case_names left right, cases pred] = disjE"], ["", "lemma inj_on_Pair2 [simp]: \"inj_on (Pair x) A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on (Pair x) A", "by(simp add: inj_on_def)"], ["", "lemma inj_on_Pair1 [simp]: \"inj_on (\\<lambda>x. (x, y)) A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on (\\<lambda>x. (x, y)) A", "by(simp add: inj_on_def)"], ["", "lemma inj_map_prod': \"\\<lbrakk> inj f; inj g \\<rbrakk> \\<Longrightarrow> inj_on (map_prod f g) X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>inj f; inj g\\<rbrakk> \\<Longrightarrow> inj_on (map_prod f g) X", "by(rule subset_inj_on[OF prod.inj_map subset_UNIV])"], ["", "lemma not_range_Inr: \"x \\<notin> range Inr \\<longleftrightarrow> x \\<in> range Inl\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<notin> range Inr) = (x \\<in> range Inl)", "by(cases x) auto"], ["", "lemma not_range_Inl: \"x \\<notin> range Inl \\<longleftrightarrow> x \\<in> range Inr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<notin> range Inl) = (x \\<in> range Inr)", "by(cases x) auto"], ["", "lemma Chains_into_chain: \"M \\<in> Chains {(x, y). R x y} \\<Longrightarrow> Complete_Partial_Order.chain R M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M \\<in> Chains {(x, y). R x y} \\<Longrightarrow>\n    Complete_Partial_Order.chain R M", "by(simp add: Chains_def chain_def)"], ["", "lemma chain_dual: \"Complete_Partial_Order.chain (\\<ge>) = Complete_Partial_Order.chain (\\<le>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Complete_Partial_Order.chain (\\<lambda>x y. y \\<le> x) =\n    Complete_Partial_Order.chain (\\<le>)", "by(auto simp add: fun_eq_iff chain_def)"], ["", "lemma Cauchy_real_Suc_diff:\n  fixes X :: \"nat \\<Rightarrow> real\" and x :: real\n  assumes bounded: \"\\<And>n. \\<bar>f (Suc n) - f n\\<bar> \\<le> (c / x ^ n)\"\n  and x: \"1 < x\"\n  shows \"Cauchy f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Cauchy f", "proof(cases \"c > 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 < c \\<Longrightarrow> Cauchy f\n 2. \\<not> 0 < c \\<Longrightarrow> Cauchy f", "case c: True"], ["proof (state)\nthis:\n  0 < c\n\ngoal (2 subgoals):\n 1. 0 < c \\<Longrightarrow> Cauchy f\n 2. \\<not> 0 < c \\<Longrightarrow> Cauchy f", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. Cauchy f", "proof(rule metric_CauchyI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>e.\n       0 < e \\<Longrightarrow>\n       \\<exists>M. \\<forall>m\\<ge>M. \\<forall>n\\<ge>M. dist (f m) (f n) < e", "fix \\<epsilon> :: real"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>e.\n       0 < e \\<Longrightarrow>\n       \\<exists>M. \\<forall>m\\<ge>M. \\<forall>n\\<ge>M. dist (f m) (f n) < e", "assume \"0 < \\<epsilon>\""], ["proof (state)\nthis:\n  0 < \\<epsilon>\n\ngoal (1 subgoal):\n 1. \\<And>e.\n       0 < e \\<Longrightarrow>\n       \\<exists>M. \\<forall>m\\<ge>M. \\<forall>n\\<ge>M. dist (f m) (f n) < e", "from bounded[of 0] x"], ["proof (chain)\npicking this:\n  \\<bar>f (Suc 0) - f 0\\<bar> \\<le> c / x ^ 0\n  1 < x", "have c_nonneg: \"0 \\<le> c\""], ["proof (prove)\nusing this:\n  \\<bar>f (Suc 0) - f 0\\<bar> \\<le> c / x ^ 0\n  1 < x\n\ngoal (1 subgoal):\n 1. 0 \\<le> c", "by simp"], ["proof (state)\nthis:\n  0 \\<le> c\n\ngoal (1 subgoal):\n 1. \\<And>e.\n       0 < e \\<Longrightarrow>\n       \\<exists>M. \\<forall>m\\<ge>M. \\<forall>n\\<ge>M. dist (f m) (f n) < e", "from x"], ["proof (chain)\npicking this:\n  1 < x", "have \"0 < ln x\""], ["proof (prove)\nusing this:\n  1 < x\n\ngoal (1 subgoal):\n 1. 0 < ln x", "by simp"], ["proof (state)\nthis:\n  0 < ln x\n\ngoal (1 subgoal):\n 1. \\<And>e.\n       0 < e \\<Longrightarrow>\n       \\<exists>M. \\<forall>m\\<ge>M. \\<forall>n\\<ge>M. dist (f m) (f n) < e", "from reals_Archimedean3[OF this]"], ["proof (chain)\npicking this:\n  \\<forall>y. \\<exists>n. y < real n * ln x", "obtain M :: nat\n      where \"ln (c * x) - ln (\\<epsilon> * (x - 1)) < real M * ln x\""], ["proof (prove)\nusing this:\n  \\<forall>y. \\<exists>n. y < real n * ln x\n\ngoal (1 subgoal):\n 1. (\\<And>M.\n        ln (c * x) - ln (\\<epsilon> * (x - 1))\n        < real M * ln x \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  ln (c * x) - ln (\\<epsilon> * (x - 1)) < real M * ln x\n\ngoal (1 subgoal):\n 1. \\<And>e.\n       0 < e \\<Longrightarrow>\n       \\<exists>M. \\<forall>m\\<ge>M. \\<forall>n\\<ge>M. dist (f m) (f n) < e", "hence \"exp (ln (c * x) - ln (\\<epsilon> * (x - 1))) < exp (real M * ln x)\""], ["proof (prove)\nusing this:\n  ln (c * x) - ln (\\<epsilon> * (x - 1)) < real M * ln x\n\ngoal (1 subgoal):\n 1. exp (ln (c * x) - ln (\\<epsilon> * (x - 1))) < exp (real M * ln x)", "by(rule exp_less_mono)"], ["proof (state)\nthis:\n  exp (ln (c * x) - ln (\\<epsilon> * (x - 1))) < exp (real M * ln x)\n\ngoal (1 subgoal):\n 1. \\<And>e.\n       0 < e \\<Longrightarrow>\n       \\<exists>M. \\<forall>m\\<ge>M. \\<forall>n\\<ge>M. dist (f m) (f n) < e", "hence M: \"c * (1 / x) ^ M / (1 - 1 / x) < \\<epsilon>\""], ["proof (prove)\nusing this:\n  exp (ln (c * x) - ln (\\<epsilon> * (x - 1))) < exp (real M * ln x)\n\ngoal (1 subgoal):\n 1. c * (1 / x) ^ M / (1 - 1 / x) < \\<epsilon>", "using \\<open>0 < \\<epsilon>\\<close> x c"], ["proof (prove)\nusing this:\n  exp (ln (c * x) - ln (\\<epsilon> * (x - 1))) < exp (real M * ln x)\n  0 < \\<epsilon>\n  1 < x\n  0 < c\n\ngoal (1 subgoal):\n 1. c * (1 / x) ^ M / (1 - 1 / x) < \\<epsilon>", "by (simp add: exp_diff exp_of_nat_mult field_simps del: ln_mult)"], ["proof (state)\nthis:\n  c * (1 / x) ^ M / (1 - 1 / x) < \\<epsilon>\n\ngoal (1 subgoal):\n 1. \\<And>e.\n       0 < e \\<Longrightarrow>\n       \\<exists>M. \\<forall>m\\<ge>M. \\<forall>n\\<ge>M. dist (f m) (f n) < e", "{"], ["proof (state)\nthis:\n  c * (1 / x) ^ M / (1 - 1 / x) < \\<epsilon>\n\ngoal (1 subgoal):\n 1. \\<And>e.\n       0 < e \\<Longrightarrow>\n       \\<exists>M. \\<forall>m\\<ge>M. \\<forall>n\\<ge>M. dist (f m) (f n) < e", "fix n m :: nat"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>e.\n       0 < e \\<Longrightarrow>\n       \\<exists>M. \\<forall>m\\<ge>M. \\<forall>n\\<ge>M. dist (f m) (f n) < e", "assume \"n \\<ge> M\" \"m \\<ge> M\""], ["proof (state)\nthis:\n  M \\<le> n\n  M \\<le> m\n\ngoal (1 subgoal):\n 1. \\<And>e.\n       0 < e \\<Longrightarrow>\n       \\<exists>M. \\<forall>m\\<ge>M. \\<forall>n\\<ge>M. dist (f m) (f n) < e", "then"], ["proof (chain)\npicking this:\n  M \\<le> n\n  M \\<le> m", "have \"\\<bar>f m - f n\\<bar> \\<le> c * ((1 / x) ^ M - (1 / x) ^ max m n) / (1 - 1 / x)\""], ["proof (prove)\nusing this:\n  M \\<le> n\n  M \\<le> m\n\ngoal (1 subgoal):\n 1. \\<bar>f m - f n\\<bar>\n    \\<le> c * ((1 / x) ^ M - (1 / x) ^ max m n) / (1 - 1 / x)", "proof(induction n m rule: linorder_wlog)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<le> b; M \\<le> a; M \\<le> b\\<rbrakk>\n       \\<Longrightarrow> \\<bar>f b - f a\\<bar>\n                         \\<le> c * ((1 / x) ^ M - (1 / x) ^ max b a) /\n                               (1 - 1 / x)\n 2. \\<And>a b.\n       \\<lbrakk>\\<lbrakk>M \\<le> b; M \\<le> a\\<rbrakk>\n                \\<Longrightarrow> \\<bar>f a - f b\\<bar>\n                                  \\<le> c *\n  ((1 / x) ^ M - (1 / x) ^ max a b) /\n  (1 - 1 / x);\n        M \\<le> a; M \\<le> b\\<rbrakk>\n       \\<Longrightarrow> \\<bar>f b - f a\\<bar>\n                         \\<le> c * ((1 / x) ^ M - (1 / x) ^ max b a) /\n                               (1 - 1 / x)", "case sym"], ["proof (state)\nthis:\n  \\<lbrakk>M \\<le> b_; M \\<le> a_\\<rbrakk>\n  \\<Longrightarrow> \\<bar>f a_ - f b_\\<bar>\n                    \\<le> c * ((1 / x) ^ M - (1 / x) ^ max a_ b_) /\n                          (1 - 1 / x)\n  M \\<le> a_\n  M \\<le> b_\n\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<le> b; M \\<le> a; M \\<le> b\\<rbrakk>\n       \\<Longrightarrow> \\<bar>f b - f a\\<bar>\n                         \\<le> c * ((1 / x) ^ M - (1 / x) ^ max b a) /\n                               (1 - 1 / x)\n 2. \\<And>a b.\n       \\<lbrakk>\\<lbrakk>M \\<le> b; M \\<le> a\\<rbrakk>\n                \\<Longrightarrow> \\<bar>f a - f b\\<bar>\n                                  \\<le> c *\n  ((1 / x) ^ M - (1 / x) ^ max a b) /\n  (1 - 1 / x);\n        M \\<le> a; M \\<le> b\\<rbrakk>\n       \\<Longrightarrow> \\<bar>f b - f a\\<bar>\n                         \\<le> c * ((1 / x) ^ M - (1 / x) ^ max b a) /\n                               (1 - 1 / x)", "thus ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>M \\<le> b_; M \\<le> a_\\<rbrakk>\n  \\<Longrightarrow> \\<bar>f a_ - f b_\\<bar>\n                    \\<le> c * ((1 / x) ^ M - (1 / x) ^ max a_ b_) /\n                          (1 - 1 / x)\n  M \\<le> a_\n  M \\<le> b_\n\ngoal (1 subgoal):\n 1. \\<bar>f b_ - f a_\\<bar>\n    \\<le> c * ((1 / x) ^ M - (1 / x) ^ max b_ a_) / (1 - 1 / x)", "by(simp add: abs_minus_commute max.commute min.commute)"], ["proof (state)\nthis:\n  \\<bar>f b_ - f a_\\<bar>\n  \\<le> c * ((1 / x) ^ M - (1 / x) ^ max b_ a_) / (1 - 1 / x)\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<le> b; M \\<le> a; M \\<le> b\\<rbrakk>\n       \\<Longrightarrow> \\<bar>f b - f a\\<bar>\n                         \\<le> c * ((1 / x) ^ M - (1 / x) ^ max b a) /\n                               (1 - 1 / x)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<le> b; M \\<le> a; M \\<le> b\\<rbrakk>\n       \\<Longrightarrow> \\<bar>f b - f a\\<bar>\n                         \\<le> c * ((1 / x) ^ M - (1 / x) ^ max b a) /\n                               (1 - 1 / x)", "case (le m n)"], ["proof (state)\nthis:\n  m \\<le> n\n  M \\<le> m\n  M \\<le> n\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<le> b; M \\<le> a; M \\<le> b\\<rbrakk>\n       \\<Longrightarrow> \\<bar>f b - f a\\<bar>\n                         \\<le> c * ((1 / x) ^ M - (1 / x) ^ max b a) /\n                               (1 - 1 / x)", "then"], ["proof (chain)\npicking this:\n  m \\<le> n\n  M \\<le> m\n  M \\<le> n", "show ?case"], ["proof (prove)\nusing this:\n  m \\<le> n\n  M \\<le> m\n  M \\<le> n\n\ngoal (1 subgoal):\n 1. \\<bar>f n - f m\\<bar>\n    \\<le> c * ((1 / x) ^ M - (1 / x) ^ max n m) / (1 - 1 / x)", "proof(induction k\\<equiv>\"n - m\" arbitrary: n m)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n m.\n       \\<lbrakk>0 = n - m; m \\<le> n; M \\<le> m; M \\<le> n\\<rbrakk>\n       \\<Longrightarrow> \\<bar>f n - f m\\<bar>\n                         \\<le> c * ((1 / x) ^ M - (1 / x) ^ max n m) /\n                               (1 - 1 / x)\n 2. \\<And>k n m.\n       \\<lbrakk>\\<And>n m.\n                   \\<lbrakk>k = n - m; m \\<le> n; M \\<le> m;\n                    M \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> \\<bar>f n - f m\\<bar>\n                                     \\<le> c *\n     ((1 / x) ^ M - (1 / x) ^ max n m) /\n     (1 - 1 / x);\n        Suc k = n - m; m \\<le> n; M \\<le> m; M \\<le> n\\<rbrakk>\n       \\<Longrightarrow> \\<bar>f n - f m\\<bar>\n                         \\<le> c * ((1 / x) ^ M - (1 / x) ^ max n m) /\n                               (1 - 1 / x)", "case 0"], ["proof (state)\nthis:\n  0 = n - m\n  m \\<le> n\n  M \\<le> m\n  M \\<le> n\n\ngoal (2 subgoals):\n 1. \\<And>n m.\n       \\<lbrakk>0 = n - m; m \\<le> n; M \\<le> m; M \\<le> n\\<rbrakk>\n       \\<Longrightarrow> \\<bar>f n - f m\\<bar>\n                         \\<le> c * ((1 / x) ^ M - (1 / x) ^ max n m) /\n                               (1 - 1 / x)\n 2. \\<And>k n m.\n       \\<lbrakk>\\<And>n m.\n                   \\<lbrakk>k = n - m; m \\<le> n; M \\<le> m;\n                    M \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> \\<bar>f n - f m\\<bar>\n                                     \\<le> c *\n     ((1 / x) ^ M - (1 / x) ^ max n m) /\n     (1 - 1 / x);\n        Suc k = n - m; m \\<le> n; M \\<le> m; M \\<le> n\\<rbrakk>\n       \\<Longrightarrow> \\<bar>f n - f m\\<bar>\n                         \\<le> c * ((1 / x) ^ M - (1 / x) ^ max n m) /\n                               (1 - 1 / x)", "thus ?case"], ["proof (prove)\nusing this:\n  0 = n - m\n  m \\<le> n\n  M \\<le> m\n  M \\<le> n\n\ngoal (1 subgoal):\n 1. \\<bar>f n - f m\\<bar>\n    \\<le> c * ((1 / x) ^ M - (1 / x) ^ max n m) / (1 - 1 / x)", "using x c_nonneg"], ["proof (prove)\nusing this:\n  0 = n - m\n  m \\<le> n\n  M \\<le> m\n  M \\<le> n\n  1 < x\n  0 \\<le> c\n\ngoal (1 subgoal):\n 1. \\<bar>f n - f m\\<bar>\n    \\<le> c * ((1 / x) ^ M - (1 / x) ^ max n m) / (1 - 1 / x)", "by(simp add: field_simps mult_left_mono)"], ["proof (state)\nthis:\n  \\<bar>f n - f m\\<bar>\n  \\<le> c * ((1 / x) ^ M - (1 / x) ^ max n m) / (1 - 1 / x)\n\ngoal (1 subgoal):\n 1. \\<And>k n m.\n       \\<lbrakk>\\<And>n m.\n                   \\<lbrakk>k = n - m; m \\<le> n; M \\<le> m;\n                    M \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> \\<bar>f n - f m\\<bar>\n                                     \\<le> c *\n     ((1 / x) ^ M - (1 / x) ^ max n m) /\n     (1 - 1 / x);\n        Suc k = n - m; m \\<le> n; M \\<le> m; M \\<le> n\\<rbrakk>\n       \\<Longrightarrow> \\<bar>f n - f m\\<bar>\n                         \\<le> c * ((1 / x) ^ M - (1 / x) ^ max n m) /\n                               (1 - 1 / x)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k n m.\n       \\<lbrakk>\\<And>n m.\n                   \\<lbrakk>k = n - m; m \\<le> n; M \\<le> m;\n                    M \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> \\<bar>f n - f m\\<bar>\n                                     \\<le> c *\n     ((1 / x) ^ M - (1 / x) ^ max n m) /\n     (1 - 1 / x);\n        Suc k = n - m; m \\<le> n; M \\<le> m; M \\<le> n\\<rbrakk>\n       \\<Longrightarrow> \\<bar>f n - f m\\<bar>\n                         \\<le> c * ((1 / x) ^ M - (1 / x) ^ max n m) /\n                               (1 - 1 / x)", "case (Suc k m n)"], ["proof (state)\nthis:\n  \\<lbrakk>k = ?n - ?m; ?m \\<le> ?n; M \\<le> ?m; M \\<le> ?n\\<rbrakk>\n  \\<Longrightarrow> \\<bar>f ?n - f ?m\\<bar>\n                    \\<le> c * ((1 / x) ^ M - (1 / x) ^ max ?n ?m) /\n                          (1 - 1 / x)\n  Suc k = m - n\n  n \\<le> m\n  M \\<le> n\n  M \\<le> m\n\ngoal (1 subgoal):\n 1. \\<And>k n m.\n       \\<lbrakk>\\<And>n m.\n                   \\<lbrakk>k = n - m; m \\<le> n; M \\<le> m;\n                    M \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> \\<bar>f n - f m\\<bar>\n                                     \\<le> c *\n     ((1 / x) ^ M - (1 / x) ^ max n m) /\n     (1 - 1 / x);\n        Suc k = n - m; m \\<le> n; M \\<le> m; M \\<le> n\\<rbrakk>\n       \\<Longrightarrow> \\<bar>f n - f m\\<bar>\n                         \\<le> c * ((1 / x) ^ M - (1 / x) ^ max n m) /\n                               (1 - 1 / x)", "from \\<open>Suc k = _\\<close>"], ["proof (chain)\npicking this:\n  Suc k = m - n", "obtain m' where m: \"m = Suc m'\""], ["proof (prove)\nusing this:\n  Suc k = m - n\n\ngoal (1 subgoal):\n 1. (\\<And>m'. m = Suc m' \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by(cases m) simp_all"], ["proof (state)\nthis:\n  m = Suc m'\n\ngoal (1 subgoal):\n 1. \\<And>k n m.\n       \\<lbrakk>\\<And>n m.\n                   \\<lbrakk>k = n - m; m \\<le> n; M \\<le> m;\n                    M \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> \\<bar>f n - f m\\<bar>\n                                     \\<le> c *\n     ((1 / x) ^ M - (1 / x) ^ max n m) /\n     (1 - 1 / x);\n        Suc k = n - m; m \\<le> n; M \\<le> m; M \\<le> n\\<rbrakk>\n       \\<Longrightarrow> \\<bar>f n - f m\\<bar>\n                         \\<le> c * ((1 / x) ^ M - (1 / x) ^ max n m) /\n                               (1 - 1 / x)", "with \\<open>Suc k = _\\<close> Suc.prems"], ["proof (chain)\npicking this:\n  Suc k = m - n\n  n \\<le> m\n  M \\<le> n\n  M \\<le> m\n  m = Suc m'", "have \"k = m' - n\" \"n \\<le> m'\" \"M \\<le> n\" \"M \\<le> m'\""], ["proof (prove)\nusing this:\n  Suc k = m - n\n  n \\<le> m\n  M \\<le> n\n  M \\<le> m\n  m = Suc m'\n\ngoal (1 subgoal):\n 1. (k = m' - n &&& n \\<le> m') &&& M \\<le> n &&& M \\<le> m'", "by simp_all"], ["proof (state)\nthis:\n  k = m' - n\n  n \\<le> m'\n  M \\<le> n\n  M \\<le> m'\n\ngoal (1 subgoal):\n 1. \\<And>k n m.\n       \\<lbrakk>\\<And>n m.\n                   \\<lbrakk>k = n - m; m \\<le> n; M \\<le> m;\n                    M \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> \\<bar>f n - f m\\<bar>\n                                     \\<le> c *\n     ((1 / x) ^ M - (1 / x) ^ max n m) /\n     (1 - 1 / x);\n        Suc k = n - m; m \\<le> n; M \\<le> m; M \\<le> n\\<rbrakk>\n       \\<Longrightarrow> \\<bar>f n - f m\\<bar>\n                         \\<le> c * ((1 / x) ^ M - (1 / x) ^ max n m) /\n                               (1 - 1 / x)", "hence \"\\<bar>f m' - f n\\<bar> \\<le> c * ((1 / x) ^ M - (1 / x) ^ (max m' n)) / (1 - 1 / x)\""], ["proof (prove)\nusing this:\n  k = m' - n\n  n \\<le> m'\n  M \\<le> n\n  M \\<le> m'\n\ngoal (1 subgoal):\n 1. \\<bar>f m' - f n\\<bar>\n    \\<le> c * ((1 / x) ^ M - (1 / x) ^ max m' n) / (1 - 1 / x)", "by(rule Suc)"], ["proof (state)\nthis:\n  \\<bar>f m' - f n\\<bar>\n  \\<le> c * ((1 / x) ^ M - (1 / x) ^ max m' n) / (1 - 1 / x)\n\ngoal (1 subgoal):\n 1. \\<And>k n m.\n       \\<lbrakk>\\<And>n m.\n                   \\<lbrakk>k = n - m; m \\<le> n; M \\<le> m;\n                    M \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> \\<bar>f n - f m\\<bar>\n                                     \\<le> c *\n     ((1 / x) ^ M - (1 / x) ^ max n m) /\n     (1 - 1 / x);\n        Suc k = n - m; m \\<le> n; M \\<le> m; M \\<le> n\\<rbrakk>\n       \\<Longrightarrow> \\<bar>f n - f m\\<bar>\n                         \\<le> c * ((1 / x) ^ M - (1 / x) ^ max n m) /\n                               (1 - 1 / x)", "also"], ["proof (state)\nthis:\n  \\<bar>f m' - f n\\<bar>\n  \\<le> c * ((1 / x) ^ M - (1 / x) ^ max m' n) / (1 - 1 / x)\n\ngoal (1 subgoal):\n 1. \\<And>k n m.\n       \\<lbrakk>\\<And>n m.\n                   \\<lbrakk>k = n - m; m \\<le> n; M \\<le> m;\n                    M \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> \\<bar>f n - f m\\<bar>\n                                     \\<le> c *\n     ((1 / x) ^ M - (1 / x) ^ max n m) /\n     (1 - 1 / x);\n        Suc k = n - m; m \\<le> n; M \\<le> m; M \\<le> n\\<rbrakk>\n       \\<Longrightarrow> \\<bar>f n - f m\\<bar>\n                         \\<le> c * ((1 / x) ^ M - (1 / x) ^ max n m) /\n                               (1 - 1 / x)", "have \"\\<dots> = c * ((1 / x) ^ M - (1 / x) ^ m') / (1 - 1 / x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c * ((1 / x) ^ M - (1 / x) ^ max m' n) / (1 - 1 / x) =\n    c * ((1 / x) ^ M - (1 / x) ^ m') / (1 - 1 / x)", "using \\<open>n \\<le> m'\\<close>"], ["proof (prove)\nusing this:\n  n \\<le> m'\n\ngoal (1 subgoal):\n 1. c * ((1 / x) ^ M - (1 / x) ^ max m' n) / (1 - 1 / x) =\n    c * ((1 / x) ^ M - (1 / x) ^ m') / (1 - 1 / x)", "by(simp add: max_def)"], ["proof (state)\nthis:\n  c * ((1 / x) ^ M - (1 / x) ^ max m' n) / (1 - 1 / x) =\n  c * ((1 / x) ^ M - (1 / x) ^ m') / (1 - 1 / x)\n\ngoal (1 subgoal):\n 1. \\<And>k n m.\n       \\<lbrakk>\\<And>n m.\n                   \\<lbrakk>k = n - m; m \\<le> n; M \\<le> m;\n                    M \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> \\<bar>f n - f m\\<bar>\n                                     \\<le> c *\n     ((1 / x) ^ M - (1 / x) ^ max n m) /\n     (1 - 1 / x);\n        Suc k = n - m; m \\<le> n; M \\<le> m; M \\<le> n\\<rbrakk>\n       \\<Longrightarrow> \\<bar>f n - f m\\<bar>\n                         \\<le> c * ((1 / x) ^ M - (1 / x) ^ max n m) /\n                               (1 - 1 / x)", "moreover"], ["proof (state)\nthis:\n  c * ((1 / x) ^ M - (1 / x) ^ max m' n) / (1 - 1 / x) =\n  c * ((1 / x) ^ M - (1 / x) ^ m') / (1 - 1 / x)\n\ngoal (1 subgoal):\n 1. \\<And>k n m.\n       \\<lbrakk>\\<And>n m.\n                   \\<lbrakk>k = n - m; m \\<le> n; M \\<le> m;\n                    M \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> \\<bar>f n - f m\\<bar>\n                                     \\<le> c *\n     ((1 / x) ^ M - (1 / x) ^ max n m) /\n     (1 - 1 / x);\n        Suc k = n - m; m \\<le> n; M \\<le> m; M \\<le> n\\<rbrakk>\n       \\<Longrightarrow> \\<bar>f n - f m\\<bar>\n                         \\<le> c * ((1 / x) ^ M - (1 / x) ^ max n m) /\n                               (1 - 1 / x)", "from bounded"], ["proof (chain)\npicking this:\n  \\<bar>f (Suc ?n) - f ?n\\<bar> \\<le> c / x ^ ?n", "have \"\\<bar>f m - f m'\\<bar> \\<le> (c / x ^ m')\""], ["proof (prove)\nusing this:\n  \\<bar>f (Suc ?n) - f ?n\\<bar> \\<le> c / x ^ ?n\n\ngoal (1 subgoal):\n 1. \\<bar>f m - f m'\\<bar> \\<le> c / x ^ m'", "by(simp add: m)"], ["proof (state)\nthis:\n  \\<bar>f m - f m'\\<bar> \\<le> c / x ^ m'\n\ngoal (1 subgoal):\n 1. \\<And>k n m.\n       \\<lbrakk>\\<And>n m.\n                   \\<lbrakk>k = n - m; m \\<le> n; M \\<le> m;\n                    M \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> \\<bar>f n - f m\\<bar>\n                                     \\<le> c *\n     ((1 / x) ^ M - (1 / x) ^ max n m) /\n     (1 - 1 / x);\n        Suc k = n - m; m \\<le> n; M \\<le> m; M \\<le> n\\<rbrakk>\n       \\<Longrightarrow> \\<bar>f n - f m\\<bar>\n                         \\<le> c * ((1 / x) ^ M - (1 / x) ^ max n m) /\n                               (1 - 1 / x)", "ultimately"], ["proof (chain)\npicking this:\n  \\<bar>f m' - f n\\<bar>\n  \\<le> c * ((1 / x) ^ M - (1 / x) ^ max m' n) / (1 - 1 / x)\n  c * ((1 / x) ^ M - (1 / x) ^ max m' n) / (1 - 1 / x) =\n  c * ((1 / x) ^ M - (1 / x) ^ m') / (1 - 1 / x)\n  \\<bar>f m - f m'\\<bar> \\<le> c / x ^ m'", "have \"\\<bar>f m' - f n\\<bar> + \\<bar>f m - f m'\\<bar> \\<le> c * ((1 / x) ^ M - (1 / x) ^ m') / (1 - 1 / x) + \\<dots>\""], ["proof (prove)\nusing this:\n  \\<bar>f m' - f n\\<bar>\n  \\<le> c * ((1 / x) ^ M - (1 / x) ^ max m' n) / (1 - 1 / x)\n  c * ((1 / x) ^ M - (1 / x) ^ max m' n) / (1 - 1 / x) =\n  c * ((1 / x) ^ M - (1 / x) ^ m') / (1 - 1 / x)\n  \\<bar>f m - f m'\\<bar> \\<le> c / x ^ m'\n\ngoal (1 subgoal):\n 1. \\<bar>f m' - f n\\<bar> + \\<bar>f m - f m'\\<bar>\n    \\<le> c * ((1 / x) ^ M - (1 / x) ^ m') / (1 - 1 / x) + c / x ^ m'", "by simp"], ["proof (state)\nthis:\n  \\<bar>f m' - f n\\<bar> + \\<bar>f m - f m'\\<bar>\n  \\<le> c * ((1 / x) ^ M - (1 / x) ^ m') / (1 - 1 / x) + c / x ^ m'\n\ngoal (1 subgoal):\n 1. \\<And>k n m.\n       \\<lbrakk>\\<And>n m.\n                   \\<lbrakk>k = n - m; m \\<le> n; M \\<le> m;\n                    M \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> \\<bar>f n - f m\\<bar>\n                                     \\<le> c *\n     ((1 / x) ^ M - (1 / x) ^ max n m) /\n     (1 - 1 / x);\n        Suc k = n - m; m \\<le> n; M \\<le> m; M \\<le> n\\<rbrakk>\n       \\<Longrightarrow> \\<bar>f n - f m\\<bar>\n                         \\<le> c * ((1 / x) ^ M - (1 / x) ^ max n m) /\n                               (1 - 1 / x)", "also"], ["proof (state)\nthis:\n  \\<bar>f m' - f n\\<bar> + \\<bar>f m - f m'\\<bar>\n  \\<le> c * ((1 / x) ^ M - (1 / x) ^ m') / (1 - 1 / x) + c / x ^ m'\n\ngoal (1 subgoal):\n 1. \\<And>k n m.\n       \\<lbrakk>\\<And>n m.\n                   \\<lbrakk>k = n - m; m \\<le> n; M \\<le> m;\n                    M \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> \\<bar>f n - f m\\<bar>\n                                     \\<le> c *\n     ((1 / x) ^ M - (1 / x) ^ max n m) /\n     (1 - 1 / x);\n        Suc k = n - m; m \\<le> n; M \\<le> m; M \\<le> n\\<rbrakk>\n       \\<Longrightarrow> \\<bar>f n - f m\\<bar>\n                         \\<le> c * ((1 / x) ^ M - (1 / x) ^ max n m) /\n                               (1 - 1 / x)", "have \"\\<dots> \\<le> c * ((1 / x) ^ M - (1 / x) ^ m) / (1 - 1 / x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c * ((1 / x) ^ M - (1 / x) ^ m') / (1 - 1 / x) + c / x ^ m'\n    \\<le> c * ((1 / x) ^ M - (1 / x) ^ m) / (1 - 1 / x)", "using m x"], ["proof (prove)\nusing this:\n  m = Suc m'\n  1 < x\n\ngoal (1 subgoal):\n 1. c * ((1 / x) ^ M - (1 / x) ^ m') / (1 - 1 / x) + c / x ^ m'\n    \\<le> c * ((1 / x) ^ M - (1 / x) ^ m) / (1 - 1 / x)", "by(simp add: field_simps)"], ["proof (state)\nthis:\n  c * ((1 / x) ^ M - (1 / x) ^ m') / (1 - 1 / x) + c / x ^ m'\n  \\<le> c * ((1 / x) ^ M - (1 / x) ^ m) / (1 - 1 / x)\n\ngoal (1 subgoal):\n 1. \\<And>k n m.\n       \\<lbrakk>\\<And>n m.\n                   \\<lbrakk>k = n - m; m \\<le> n; M \\<le> m;\n                    M \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> \\<bar>f n - f m\\<bar>\n                                     \\<le> c *\n     ((1 / x) ^ M - (1 / x) ^ max n m) /\n     (1 - 1 / x);\n        Suc k = n - m; m \\<le> n; M \\<le> m; M \\<le> n\\<rbrakk>\n       \\<Longrightarrow> \\<bar>f n - f m\\<bar>\n                         \\<le> c * ((1 / x) ^ M - (1 / x) ^ max n m) /\n                               (1 - 1 / x)", "also"], ["proof (state)\nthis:\n  c * ((1 / x) ^ M - (1 / x) ^ m') / (1 - 1 / x) + c / x ^ m'\n  \\<le> c * ((1 / x) ^ M - (1 / x) ^ m) / (1 - 1 / x)\n\ngoal (1 subgoal):\n 1. \\<And>k n m.\n       \\<lbrakk>\\<And>n m.\n                   \\<lbrakk>k = n - m; m \\<le> n; M \\<le> m;\n                    M \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> \\<bar>f n - f m\\<bar>\n                                     \\<le> c *\n     ((1 / x) ^ M - (1 / x) ^ max n m) /\n     (1 - 1 / x);\n        Suc k = n - m; m \\<le> n; M \\<le> m; M \\<le> n\\<rbrakk>\n       \\<Longrightarrow> \\<bar>f n - f m\\<bar>\n                         \\<le> c * ((1 / x) ^ M - (1 / x) ^ max n m) /\n                               (1 - 1 / x)", "have \"\\<bar>f m - f n\\<bar> \\<le> \\<bar>f m' - f n\\<bar> + \\<bar>f m - f m'\\<bar>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>f m - f n\\<bar>\n    \\<le> \\<bar>f m' - f n\\<bar> + \\<bar>f m - f m'\\<bar>", "using abs_triangle_ineq4[of \"f m' - f n\" \"f m - f m'\"]"], ["proof (prove)\nusing this:\n  \\<bar>f m' - f n - (f m - f m')\\<bar>\n  \\<le> \\<bar>f m' - f n\\<bar> + \\<bar>f m - f m'\\<bar>\n\ngoal (1 subgoal):\n 1. \\<bar>f m - f n\\<bar>\n    \\<le> \\<bar>f m' - f n\\<bar> + \\<bar>f m - f m'\\<bar>", "by simp"], ["proof (state)\nthis:\n  \\<bar>f m - f n\\<bar>\n  \\<le> \\<bar>f m' - f n\\<bar> + \\<bar>f m - f m'\\<bar>\n\ngoal (1 subgoal):\n 1. \\<And>k n m.\n       \\<lbrakk>\\<And>n m.\n                   \\<lbrakk>k = n - m; m \\<le> n; M \\<le> m;\n                    M \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> \\<bar>f n - f m\\<bar>\n                                     \\<le> c *\n     ((1 / x) ^ M - (1 / x) ^ max n m) /\n     (1 - 1 / x);\n        Suc k = n - m; m \\<le> n; M \\<le> m; M \\<le> n\\<rbrakk>\n       \\<Longrightarrow> \\<bar>f n - f m\\<bar>\n                         \\<le> c * ((1 / x) ^ M - (1 / x) ^ max n m) /\n                               (1 - 1 / x)", "ultimately"], ["proof (chain)\npicking this:\n  \\<bar>f m' - f n\\<bar> + \\<bar>f m - f m'\\<bar>\n  \\<le> c * ((1 / x) ^ M - (1 / x) ^ m) / (1 - 1 / x)\n  \\<bar>f m - f n\\<bar>\n  \\<le> \\<bar>f m' - f n\\<bar> + \\<bar>f m - f m'\\<bar>", "show ?case"], ["proof (prove)\nusing this:\n  \\<bar>f m' - f n\\<bar> + \\<bar>f m - f m'\\<bar>\n  \\<le> c * ((1 / x) ^ M - (1 / x) ^ m) / (1 - 1 / x)\n  \\<bar>f m - f n\\<bar>\n  \\<le> \\<bar>f m' - f n\\<bar> + \\<bar>f m - f m'\\<bar>\n\ngoal (1 subgoal):\n 1. \\<bar>f m - f n\\<bar>\n    \\<le> c * ((1 / x) ^ M - (1 / x) ^ max m n) / (1 - 1 / x)", "using \\<open>n \\<le> m\\<close>"], ["proof (prove)\nusing this:\n  \\<bar>f m' - f n\\<bar> + \\<bar>f m - f m'\\<bar>\n  \\<le> c * ((1 / x) ^ M - (1 / x) ^ m) / (1 - 1 / x)\n  \\<bar>f m - f n\\<bar>\n  \\<le> \\<bar>f m' - f n\\<bar> + \\<bar>f m - f m'\\<bar>\n  n \\<le> m\n\ngoal (1 subgoal):\n 1. \\<bar>f m - f n\\<bar>\n    \\<le> c * ((1 / x) ^ M - (1 / x) ^ max m n) / (1 - 1 / x)", "by(simp add: max_def)"], ["proof (state)\nthis:\n  \\<bar>f m - f n\\<bar>\n  \\<le> c * ((1 / x) ^ M - (1 / x) ^ max m n) / (1 - 1 / x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<bar>f n - f m\\<bar>\n  \\<le> c * ((1 / x) ^ M - (1 / x) ^ max n m) / (1 - 1 / x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<bar>f m - f n\\<bar>\n  \\<le> c * ((1 / x) ^ M - (1 / x) ^ max m n) / (1 - 1 / x)\n\ngoal (1 subgoal):\n 1. \\<And>e.\n       0 < e \\<Longrightarrow>\n       \\<exists>M. \\<forall>m\\<ge>M. \\<forall>n\\<ge>M. dist (f m) (f n) < e", "also"], ["proof (state)\nthis:\n  \\<bar>f m - f n\\<bar>\n  \\<le> c * ((1 / x) ^ M - (1 / x) ^ max m n) / (1 - 1 / x)\n\ngoal (1 subgoal):\n 1. \\<And>e.\n       0 < e \\<Longrightarrow>\n       \\<exists>M. \\<forall>m\\<ge>M. \\<forall>n\\<ge>M. dist (f m) (f n) < e", "have \"\\<dots> < c * (1 / x) ^ M / (1 - 1 / x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c * ((1 / x) ^ M - (1 / x) ^ max m n) / (1 - 1 / x)\n    < c * (1 / x) ^ M / (1 - 1 / x)", "using x c"], ["proof (prove)\nusing this:\n  1 < x\n  0 < c\n\ngoal (1 subgoal):\n 1. c * ((1 / x) ^ M - (1 / x) ^ max m n) / (1 - 1 / x)\n    < c * (1 / x) ^ M / (1 - 1 / x)", "by(auto simp add: field_simps)"], ["proof (state)\nthis:\n  c * ((1 / x) ^ M - (1 / x) ^ max m n) / (1 - 1 / x)\n  < c * (1 / x) ^ M / (1 - 1 / x)\n\ngoal (1 subgoal):\n 1. \\<And>e.\n       0 < e \\<Longrightarrow>\n       \\<exists>M. \\<forall>m\\<ge>M. \\<forall>n\\<ge>M. dist (f m) (f n) < e", "also"], ["proof (state)\nthis:\n  c * ((1 / x) ^ M - (1 / x) ^ max m n) / (1 - 1 / x)\n  < c * (1 / x) ^ M / (1 - 1 / x)\n\ngoal (1 subgoal):\n 1. \\<And>e.\n       0 < e \\<Longrightarrow>\n       \\<exists>M. \\<forall>m\\<ge>M. \\<forall>n\\<ge>M. dist (f m) (f n) < e", "have \"\\<dots> < \\<epsilon>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c * (1 / x) ^ M / (1 - 1 / x) < \\<epsilon>", "using M"], ["proof (prove)\nusing this:\n  c * (1 / x) ^ M / (1 - 1 / x) < \\<epsilon>\n\ngoal (1 subgoal):\n 1. c * (1 / x) ^ M / (1 - 1 / x) < \\<epsilon>", "."], ["proof (state)\nthis:\n  c * (1 / x) ^ M / (1 - 1 / x) < \\<epsilon>\n\ngoal (1 subgoal):\n 1. \\<And>e.\n       0 < e \\<Longrightarrow>\n       \\<exists>M. \\<forall>m\\<ge>M. \\<forall>n\\<ge>M. dist (f m) (f n) < e", "finally"], ["proof (chain)\npicking this:\n  \\<bar>f m - f n\\<bar> < \\<epsilon>", "have \"\\<bar>f m - f n\\<bar> < \\<epsilon>\""], ["proof (prove)\nusing this:\n  \\<bar>f m - f n\\<bar> < \\<epsilon>\n\ngoal (1 subgoal):\n 1. \\<bar>f m - f n\\<bar> < \\<epsilon>", "."], ["proof (state)\nthis:\n  \\<bar>f m - f n\\<bar> < \\<epsilon>\n\ngoal (1 subgoal):\n 1. \\<And>e.\n       0 < e \\<Longrightarrow>\n       \\<exists>M. \\<forall>m\\<ge>M. \\<forall>n\\<ge>M. dist (f m) (f n) < e", "}"], ["proof (state)\nthis:\n  \\<lbrakk>M \\<le> ?n2; M \\<le> ?m2\\<rbrakk>\n  \\<Longrightarrow> \\<bar>f ?m2 - f ?n2\\<bar> < \\<epsilon>\n\ngoal (1 subgoal):\n 1. \\<And>e.\n       0 < e \\<Longrightarrow>\n       \\<exists>M. \\<forall>m\\<ge>M. \\<forall>n\\<ge>M. dist (f m) (f n) < e", "thus \"\\<exists>M. \\<forall>m\\<ge>M. \\<forall>n\\<ge>M. dist (f m) (f n) < \\<epsilon>\""], ["proof (prove)\nusing this:\n  \\<lbrakk>M \\<le> ?n2; M \\<le> ?m2\\<rbrakk>\n  \\<Longrightarrow> \\<bar>f ?m2 - f ?n2\\<bar> < \\<epsilon>\n\ngoal (1 subgoal):\n 1. \\<exists>M.\n       \\<forall>m\\<ge>M. \\<forall>n\\<ge>M. dist (f m) (f n) < \\<epsilon>", "unfolding dist_real_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>M \\<le> ?n2; M \\<le> ?m2\\<rbrakk>\n  \\<Longrightarrow> \\<bar>f ?m2 - f ?n2\\<bar> < \\<epsilon>\n\ngoal (1 subgoal):\n 1. \\<exists>M.\n       \\<forall>m\\<ge>M.\n          \\<forall>n\\<ge>M. \\<bar>f m - f n\\<bar> < \\<epsilon>", "by blast"], ["proof (state)\nthis:\n  \\<exists>M.\n     \\<forall>m\\<ge>M. \\<forall>n\\<ge>M. dist (f m) (f n) < \\<epsilon>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Cauchy f\n\ngoal (1 subgoal):\n 1. \\<not> 0 < c \\<Longrightarrow> Cauchy f", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> 0 < c \\<Longrightarrow> Cauchy f", "case False"], ["proof (state)\nthis:\n  \\<not> 0 < c\n\ngoal (1 subgoal):\n 1. \\<not> 0 < c \\<Longrightarrow> Cauchy f", "with bounded[of 0]"], ["proof (chain)\npicking this:\n  \\<bar>f (Suc 0) - f 0\\<bar> \\<le> c / x ^ 0\n  \\<not> 0 < c", "have [simp]: \"c = 0\""], ["proof (prove)\nusing this:\n  \\<bar>f (Suc 0) - f 0\\<bar> \\<le> c / x ^ 0\n  \\<not> 0 < c\n\ngoal (1 subgoal):\n 1. c = 0", "by simp"], ["proof (state)\nthis:\n  c = 0\n\ngoal (1 subgoal):\n 1. \\<not> 0 < c \\<Longrightarrow> Cauchy f", "have eq: \"f m = f 0\" for m"], ["proof (prove)\ngoal (1 subgoal):\n 1. f m = f 0", "proof(induction m)"], ["proof (state)\ngoal (2 subgoals):\n 1. f 0 = f 0\n 2. \\<And>m. f m = f 0 \\<Longrightarrow> f (Suc m) = f 0", "case (Suc m)"], ["proof (state)\nthis:\n  f m = f 0\n\ngoal (2 subgoals):\n 1. f 0 = f 0\n 2. \\<And>m. f m = f 0 \\<Longrightarrow> f (Suc m) = f 0", "from bounded[of m] Suc.IH"], ["proof (chain)\npicking this:\n  \\<bar>f (Suc m) - f m\\<bar> \\<le> c / x ^ m\n  f m = f 0", "show ?case"], ["proof (prove)\nusing this:\n  \\<bar>f (Suc m) - f m\\<bar> \\<le> c / x ^ m\n  f m = f 0\n\ngoal (1 subgoal):\n 1. f (Suc m) = f 0", "by simp"], ["proof (state)\nthis:\n  f (Suc m) = f 0\n\ngoal (1 subgoal):\n 1. f 0 = f 0", "qed simp"], ["proof (state)\nthis:\n  f ?m = f 0\n\ngoal (1 subgoal):\n 1. \\<not> 0 < c \\<Longrightarrow> Cauchy f", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. Cauchy f", "by(rule metric_CauchyI)(subst (1 2) eq; simp)"], ["proof (state)\nthis:\n  Cauchy f\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma complete_lattice_ccpo_dual:\n  \"class.ccpo Inf (\\<ge>) ((>) :: _ :: complete_lattice \\<Rightarrow> _)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. class.ccpo Inf (\\<lambda>x y. y \\<le> x) (\\<lambda>x y. y < x)", "by(unfold_locales)(auto intro: Inf_lower Inf_greatest)"], ["", "lemma card_eq_1_iff: \"card A = Suc 0 \\<longleftrightarrow> (\\<exists>x. A = {x})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (card A = Suc 0) = (\\<exists>x. A = {x})", "using card_eq_SucD"], ["proof (prove)\nusing this:\n  card ?A = Suc ?k \\<Longrightarrow>\n  \\<exists>b B.\n     ?A = insert b B \\<and>\n     b \\<notin> B \\<and>\n     card B = ?k \\<and> (?k = 0 \\<longrightarrow> B = {})\n\ngoal (1 subgoal):\n 1. (card A = Suc 0) = (\\<exists>x. A = {x})", "by auto"], ["", "lemma nth_rotate1: \"n < length xs \\<Longrightarrow> rotate1 xs ! n = xs ! (Suc n mod length xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n < length xs \\<Longrightarrow>\n    rotate1 xs ! n = xs ! (Suc n mod length xs)", "apply(cases xs; clarsimp simp add: nth_append not_less)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>n < Suc (length list); xs = a # list;\n        length list \\<le> n\\<rbrakk>\n       \\<Longrightarrow> a = (a # list) ! (Suc n mod Suc (length list))", "apply(subgoal_tac \"n = length list\"; simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma set_zip_rightI: \"\\<lbrakk> x \\<in> set ys; length xs \\<ge> length ys \\<rbrakk> \\<Longrightarrow> \\<exists>z. (z, x) \\<in> set (zip xs ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> set ys; length ys \\<le> length xs\\<rbrakk>\n    \\<Longrightarrow> \\<exists>z. (z, x) \\<in> set (zip xs ys)", "by(fastforce simp add: in_set_zip in_set_conv_nth simp del: length_greater_0_conv intro!: nth_zip conjI[rotated])"], ["", "lemma map_eq_append_conv:\n  \"map f xs = ys @ zs \\<longleftrightarrow> (\\<exists>ys' zs'. xs = ys' @ zs' \\<and> ys = map f ys' \\<and> zs = map f zs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (map f xs = ys @ zs) =\n    (\\<exists>ys' zs'.\n        xs = ys' @ zs' \\<and> ys = map f ys' \\<and> zs = map f zs')", "by(auto 4 4 intro: exI[where x=\"take (length ys) xs\"] exI[where x=\"drop (length ys) xs\"] simp add: append_eq_conv_conj take_map drop_map dest: sym)"], ["", "lemma rotate1_append:\n  \"rotate1 (xs @ ys) = (if xs = [] then rotate1 ys else tl xs @ ys @ [hd xs])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rotate1 (xs @ ys) =\n    (if xs = [] then rotate1 ys else tl xs @ ys @ [hd xs])", "by(clarsimp simp add: neq_Nil_conv)"], ["", "lemma in_set_tlD: \"x \\<in> set (tl xs) \\<Longrightarrow> x \\<in> set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> set (tl xs) \\<Longrightarrow> x \\<in> set xs", "by(cases xs) simp_all"], ["", "lemma countable_converseI:\n  assumes \"countable A\"\n  shows \"countable (converse A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. countable (A\\<inverse>)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. countable (A\\<inverse>)", "have \"converse A = prod.swap ` A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A\\<inverse> = prod.swap ` A", "by auto"], ["proof (state)\nthis:\n  A\\<inverse> = prod.swap ` A\n\ngoal (1 subgoal):\n 1. countable (A\\<inverse>)", "then"], ["proof (chain)\npicking this:\n  A\\<inverse> = prod.swap ` A", "show ?thesis"], ["proof (prove)\nusing this:\n  A\\<inverse> = prod.swap ` A\n\ngoal (1 subgoal):\n 1. countable (A\\<inverse>)", "using assms"], ["proof (prove)\nusing this:\n  A\\<inverse> = prod.swap ` A\n  countable A\n\ngoal (1 subgoal):\n 1. countable (A\\<inverse>)", "by simp"], ["proof (state)\nthis:\n  countable (A\\<inverse>)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma countable_converse [simp]: \"countable (converse A) \\<longleftrightarrow> countable A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. countable (A\\<inverse>) = countable A", "using countable_converseI[of A] countable_converseI[of \"converse A\"]"], ["proof (prove)\nusing this:\n  countable A \\<Longrightarrow> countable (A\\<inverse>)\n  countable (A\\<inverse>) \\<Longrightarrow>\n  countable ((A\\<inverse>)\\<inverse>)\n\ngoal (1 subgoal):\n 1. countable (A\\<inverse>) = countable A", "by auto"], ["", "lemma nn_integral_count_space_reindex:\n  \"inj_on f A \\<Longrightarrow>(\\<integral>\\<^sup>+ y. g y \\<partial>count_space (f ` A)) = (\\<integral>\\<^sup>+ x. g (f x) \\<partial>count_space A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on f A \\<Longrightarrow>\n    integral\\<^sup>N (count_space (f ` A)) g =\n    \\<integral>\\<^sup>+ x. g (f x) \\<partial>count_space A", "by(simp add: embed_measure_count_space'[symmetric] nn_integral_embed_measure' measurable_embed_measure1)"], ["", "syntax\n  \"_nn_sum\" :: \"pttrn \\<Rightarrow> 'a set \\<Rightarrow> 'b \\<Rightarrow> 'b::comm_monoid_add\"  (\"(2\\<Sum>\\<^sup>+ _\\<in>_./ _)\" [0, 51, 10] 10)\n  \"_nn_sum_UNIV\" :: \"pttrn \\<Rightarrow> 'b \\<Rightarrow> 'b::comm_monoid_add\" (\"(2\\<Sum>\\<^sup>+ _./ _)\" [0, 10] 10)"], ["", "translations\n  \"\\<Sum>\\<^sup>+ i\\<in>A. b\" \\<rightleftharpoons> \"CONST nn_integral (CONST count_space A) (\\<lambda>i. b)\"\n  \"\\<Sum>\\<^sup>+ i. b\" \\<rightleftharpoons> \"\\<Sum>\\<^sup>+ i\\<in>CONST UNIV. b\""], ["", "inductive_simps rtrancl_path_simps:\n  \"rtrancl_path R x [] y\"\n  \"rtrancl_path R x (a # bs) y\""], ["", "definition restrict_rel :: \"'a set \\<Rightarrow> ('a \\<times> 'a) set \\<Rightarrow> ('a \\<times> 'a) set\"\nwhere \"restrict_rel A R = {(x, y)\\<in>R. x \\<in> A \\<and> y \\<in> A}\""], ["", "lemma in_restrict_rel_iff: \"(x, y) \\<in> restrict_rel A R \\<longleftrightarrow> (x, y) \\<in> R \\<and> x \\<in> A \\<and> y \\<in> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((x, y) \\<in> restrict_rel A R) =\n    ((x, y) \\<in> R \\<and> x \\<in> A \\<and> y \\<in> A)", "by(simp add: restrict_rel_def)"], ["", "lemma restrict_relE: \"\\<lbrakk> (x, y) \\<in> restrict_rel A R; \\<lbrakk> (x, y) \\<in> R; x \\<in> A; y \\<in> A \\<rbrakk> \\<Longrightarrow> thesis \\<rbrakk> \\<Longrightarrow> thesis\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(x, y) \\<in> restrict_rel A R;\n     \\<lbrakk>(x, y) \\<in> R; x \\<in> A; y \\<in> A\\<rbrakk>\n     \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by(simp add: restrict_rel_def)"], ["", "lemma restrict_relI [intro!]: \"\\<lbrakk> (x, y) \\<in> R; x \\<in> A; y \\<in> A \\<rbrakk> \\<Longrightarrow> (x, y) \\<in> restrict_rel A R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(x, y) \\<in> R; x \\<in> A; y \\<in> A\\<rbrakk>\n    \\<Longrightarrow> (x, y) \\<in> restrict_rel A R", "by(simp add: restrict_rel_def)"], ["", "lemma Field_restrict_rel_subset: \"Field (restrict_rel A R) \\<subseteq> A \\<inter> Field R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Field (restrict_rel A R) \\<subseteq> A \\<inter> Field R", "by(auto simp add: Field_def in_restrict_rel_iff)"], ["", "lemma Field_restrict_rel [simp]: \"Refl R \\<Longrightarrow> Field (restrict_rel A R) = A \\<inter> Field R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Refl R \\<Longrightarrow> Field (restrict_rel A R) = A \\<inter> Field R", "using Field_restrict_rel_subset[of A R]"], ["proof (prove)\nusing this:\n  Field (restrict_rel A R) \\<subseteq> A \\<inter> Field R\n\ngoal (1 subgoal):\n 1. Refl R \\<Longrightarrow> Field (restrict_rel A R) = A \\<inter> Field R", "by auto (auto simp add: Field_def dest: refl_onD)"], ["", "lemma Partial_order_restrict_rel:\n  assumes \"Partial_order R\"\n  shows \"Partial_order (restrict_rel A R)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Partial_order (restrict_rel A R)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Partial_order (restrict_rel A R)", "from assms"], ["proof (chain)\npicking this:\n  Partial_order R", "have \"Refl R\""], ["proof (prove)\nusing this:\n  Partial_order R\n\ngoal (1 subgoal):\n 1. Refl R", "by(simp add: order_on_defs)"], ["proof (state)\nthis:\n  Refl R\n\ngoal (1 subgoal):\n 1. Partial_order (restrict_rel A R)", "from Field_restrict_rel[OF this, of A] assms"], ["proof (chain)\npicking this:\n  Field (restrict_rel A R) = A \\<inter> Field R\n  Partial_order R", "show ?thesis"], ["proof (prove)\nusing this:\n  Field (restrict_rel A R) = A \\<inter> Field R\n  Partial_order R\n\ngoal (1 subgoal):\n 1. Partial_order (restrict_rel A R)", "by(simp add: order_on_defs trans_def antisym_def)\n      (auto intro: FieldI1 FieldI2 intro!: refl_onI simp add: in_restrict_rel_iff elim: refl_onD)"], ["proof (state)\nthis:\n  Partial_order (restrict_rel A R)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Chains_restrict_relD: \"M \\<in> Chains (restrict_rel A leq) \\<Longrightarrow> M \\<in> Chains leq\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M \\<in> Chains (restrict_rel A leq) \\<Longrightarrow> M \\<in> Chains leq", "by(auto simp add: Chains_def in_restrict_rel_iff)"], ["", "lemma bourbaki_witt_fixpoint_restrict_rel:\n  assumes leq: \"Partial_order leq\"\n  and chain_Field: \"\\<And>M. \\<lbrakk> M \\<in> Chains (restrict_rel A leq); M \\<noteq> {} \\<rbrakk> \\<Longrightarrow> lub M \\<in> A\"\n  and lub_least: \"\\<And>M z. \\<lbrakk> M \\<in> Chains leq; M \\<noteq> {}; \\<And>x. x \\<in> M \\<Longrightarrow> (x, z) \\<in> leq \\<rbrakk> \\<Longrightarrow> (lub M, z) \\<in> leq\"\n  and lub_upper: \"\\<And>M z. \\<lbrakk> M \\<in> Chains leq; z \\<in> M \\<rbrakk> \\<Longrightarrow> (z, lub M) \\<in> leq\"\n  and increasing: \"\\<And>x. \\<lbrakk> x \\<in> A; x \\<in> Field leq \\<rbrakk> \\<Longrightarrow> (x, f x) \\<in> leq \\<and> f x \\<in> A\"\n  shows \"bourbaki_witt_fixpoint lub (restrict_rel A leq) f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bourbaki_witt_fixpoint lub (restrict_rel A leq) f", "proof"], ["proof (state)\ngoal (5 subgoals):\n 1. Partial_order (restrict_rel A leq)\n 2. \\<And>M z.\n       \\<lbrakk>M \\<in> Chains (restrict_rel A leq); M \\<noteq> {};\n        \\<And>x.\n           x \\<in> M \\<Longrightarrow>\n           (x, z) \\<in> restrict_rel A leq\\<rbrakk>\n       \\<Longrightarrow> (lub M, z) \\<in> restrict_rel A leq\n 3. \\<And>M x.\n       \\<lbrakk>M \\<in> Chains (restrict_rel A leq); x \\<in> M\\<rbrakk>\n       \\<Longrightarrow> (x, lub M) \\<in> restrict_rel A leq\n 4. \\<And>M.\n       \\<lbrakk>M \\<in> Chains (restrict_rel A leq); M \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> lub M \\<in> Field (restrict_rel A leq)\n 5. \\<And>x.\n       x \\<in> Field (restrict_rel A leq) \\<Longrightarrow>\n       (x, f x) \\<in> restrict_rel A leq", "show \"Partial_order (restrict_rel A leq)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Partial_order (restrict_rel A leq)", "using leq"], ["proof (prove)\nusing this:\n  Partial_order leq\n\ngoal (1 subgoal):\n 1. Partial_order (restrict_rel A leq)", "by(rule Partial_order_restrict_rel)"], ["proof (state)\nthis:\n  Partial_order (restrict_rel A leq)\n\ngoal (4 subgoals):\n 1. \\<And>M z.\n       \\<lbrakk>M \\<in> Chains (restrict_rel A leq); M \\<noteq> {};\n        \\<And>x.\n           x \\<in> M \\<Longrightarrow>\n           (x, z) \\<in> restrict_rel A leq\\<rbrakk>\n       \\<Longrightarrow> (lub M, z) \\<in> restrict_rel A leq\n 2. \\<And>M x.\n       \\<lbrakk>M \\<in> Chains (restrict_rel A leq); x \\<in> M\\<rbrakk>\n       \\<Longrightarrow> (x, lub M) \\<in> restrict_rel A leq\n 3. \\<And>M.\n       \\<lbrakk>M \\<in> Chains (restrict_rel A leq); M \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> lub M \\<in> Field (restrict_rel A leq)\n 4. \\<And>x.\n       x \\<in> Field (restrict_rel A leq) \\<Longrightarrow>\n       (x, f x) \\<in> restrict_rel A leq", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>M z.\n       \\<lbrakk>M \\<in> Chains (restrict_rel A leq); M \\<noteq> {};\n        \\<And>x.\n           x \\<in> M \\<Longrightarrow>\n           (x, z) \\<in> restrict_rel A leq\\<rbrakk>\n       \\<Longrightarrow> (lub M, z) \\<in> restrict_rel A leq\n 2. \\<And>M x.\n       \\<lbrakk>M \\<in> Chains (restrict_rel A leq); x \\<in> M\\<rbrakk>\n       \\<Longrightarrow> (x, lub M) \\<in> restrict_rel A leq\n 3. \\<And>M.\n       \\<lbrakk>M \\<in> Chains (restrict_rel A leq); M \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> lub M \\<in> Field (restrict_rel A leq)\n 4. \\<And>x.\n       x \\<in> Field (restrict_rel A leq) \\<Longrightarrow>\n       (x, f x) \\<in> restrict_rel A leq", "from leq"], ["proof (chain)\npicking this:\n  Partial_order leq", "have Refl: \"Refl leq\""], ["proof (prove)\nusing this:\n  Partial_order leq\n\ngoal (1 subgoal):\n 1. Refl leq", "by(simp add: order_on_defs)"], ["proof (state)\nthis:\n  Refl leq\n\ngoal (4 subgoals):\n 1. \\<And>M z.\n       \\<lbrakk>M \\<in> Chains (restrict_rel A leq); M \\<noteq> {};\n        \\<And>x.\n           x \\<in> M \\<Longrightarrow>\n           (x, z) \\<in> restrict_rel A leq\\<rbrakk>\n       \\<Longrightarrow> (lub M, z) \\<in> restrict_rel A leq\n 2. \\<And>M x.\n       \\<lbrakk>M \\<in> Chains (restrict_rel A leq); x \\<in> M\\<rbrakk>\n       \\<Longrightarrow> (x, lub M) \\<in> restrict_rel A leq\n 3. \\<And>M.\n       \\<lbrakk>M \\<in> Chains (restrict_rel A leq); M \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> lub M \\<in> Field (restrict_rel A leq)\n 4. \\<And>x.\n       x \\<in> Field (restrict_rel A leq) \\<Longrightarrow>\n       (x, f x) \\<in> restrict_rel A leq", "{"], ["proof (state)\nthis:\n  Refl leq\n\ngoal (4 subgoals):\n 1. \\<And>M z.\n       \\<lbrakk>M \\<in> Chains (restrict_rel A leq); M \\<noteq> {};\n        \\<And>x.\n           x \\<in> M \\<Longrightarrow>\n           (x, z) \\<in> restrict_rel A leq\\<rbrakk>\n       \\<Longrightarrow> (lub M, z) \\<in> restrict_rel A leq\n 2. \\<And>M x.\n       \\<lbrakk>M \\<in> Chains (restrict_rel A leq); x \\<in> M\\<rbrakk>\n       \\<Longrightarrow> (x, lub M) \\<in> restrict_rel A leq\n 3. \\<And>M.\n       \\<lbrakk>M \\<in> Chains (restrict_rel A leq); M \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> lub M \\<in> Field (restrict_rel A leq)\n 4. \\<And>x.\n       x \\<in> Field (restrict_rel A leq) \\<Longrightarrow>\n       (x, f x) \\<in> restrict_rel A leq", "fix M z"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>M z.\n       \\<lbrakk>M \\<in> Chains (restrict_rel A leq); M \\<noteq> {};\n        \\<And>x.\n           x \\<in> M \\<Longrightarrow>\n           (x, z) \\<in> restrict_rel A leq\\<rbrakk>\n       \\<Longrightarrow> (lub M, z) \\<in> restrict_rel A leq\n 2. \\<And>M x.\n       \\<lbrakk>M \\<in> Chains (restrict_rel A leq); x \\<in> M\\<rbrakk>\n       \\<Longrightarrow> (x, lub M) \\<in> restrict_rel A leq\n 3. \\<And>M.\n       \\<lbrakk>M \\<in> Chains (restrict_rel A leq); M \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> lub M \\<in> Field (restrict_rel A leq)\n 4. \\<And>x.\n       x \\<in> Field (restrict_rel A leq) \\<Longrightarrow>\n       (x, f x) \\<in> restrict_rel A leq", "assume M: \"M \\<in> Chains (restrict_rel A leq)\""], ["proof (state)\nthis:\n  M \\<in> Chains (restrict_rel A leq)\n\ngoal (4 subgoals):\n 1. \\<And>M z.\n       \\<lbrakk>M \\<in> Chains (restrict_rel A leq); M \\<noteq> {};\n        \\<And>x.\n           x \\<in> M \\<Longrightarrow>\n           (x, z) \\<in> restrict_rel A leq\\<rbrakk>\n       \\<Longrightarrow> (lub M, z) \\<in> restrict_rel A leq\n 2. \\<And>M x.\n       \\<lbrakk>M \\<in> Chains (restrict_rel A leq); x \\<in> M\\<rbrakk>\n       \\<Longrightarrow> (x, lub M) \\<in> restrict_rel A leq\n 3. \\<And>M.\n       \\<lbrakk>M \\<in> Chains (restrict_rel A leq); M \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> lub M \\<in> Field (restrict_rel A leq)\n 4. \\<And>x.\n       x \\<in> Field (restrict_rel A leq) \\<Longrightarrow>\n       (x, f x) \\<in> restrict_rel A leq", "presume z: \"z \\<in> M\""], ["proof (state)\nthis:\n  z \\<in> M\n\ngoal (4 subgoals):\n 1. \\<And>M z.\n       \\<lbrakk>M \\<in> Chains (restrict_rel A leq); M \\<noteq> {};\n        \\<And>x.\n           x \\<in> M \\<Longrightarrow>\n           (x, z) \\<in> restrict_rel A leq\\<rbrakk>\n       \\<Longrightarrow> (lub M, z) \\<in> restrict_rel A leq\n 2. \\<And>M x.\n       \\<lbrakk>M \\<in> Chains (restrict_rel A leq); x \\<in> M\\<rbrakk>\n       \\<Longrightarrow> (x, lub M) \\<in> restrict_rel A leq\n 3. \\<And>M.\n       \\<lbrakk>M \\<in> Chains (restrict_rel A leq); M \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> lub M \\<in> Field (restrict_rel A leq)\n 4. \\<And>x.\n       x \\<in> Field (restrict_rel A leq) \\<Longrightarrow>\n       (x, f x) \\<in> restrict_rel A leq", "hence \"M \\<noteq> {}\""], ["proof (prove)\nusing this:\n  z \\<in> M\n\ngoal (1 subgoal):\n 1. M \\<noteq> {}", "by auto"], ["proof (state)\nthis:\n  M \\<noteq> {}\n\ngoal (4 subgoals):\n 1. \\<And>M z.\n       \\<lbrakk>M \\<in> Chains (restrict_rel A leq); M \\<noteq> {};\n        \\<And>x.\n           x \\<in> M \\<Longrightarrow>\n           (x, z) \\<in> restrict_rel A leq\\<rbrakk>\n       \\<Longrightarrow> (lub M, z) \\<in> restrict_rel A leq\n 2. \\<And>M x.\n       \\<lbrakk>M \\<in> Chains (restrict_rel A leq); x \\<in> M\\<rbrakk>\n       \\<Longrightarrow> (x, lub M) \\<in> restrict_rel A leq\n 3. \\<And>M.\n       \\<lbrakk>M \\<in> Chains (restrict_rel A leq); M \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> lub M \\<in> Field (restrict_rel A leq)\n 4. \\<And>x.\n       x \\<in> Field (restrict_rel A leq) \\<Longrightarrow>\n       (x, f x) \\<in> restrict_rel A leq", "with M"], ["proof (chain)\npicking this:\n  M \\<in> Chains (restrict_rel A leq)\n  M \\<noteq> {}", "have lubA: \"lub M \\<in> A\""], ["proof (prove)\nusing this:\n  M \\<in> Chains (restrict_rel A leq)\n  M \\<noteq> {}\n\ngoal (1 subgoal):\n 1. lub M \\<in> A", "by(rule chain_Field)"], ["proof (state)\nthis:\n  lub M \\<in> A\n\ngoal (4 subgoals):\n 1. \\<And>M z.\n       \\<lbrakk>M \\<in> Chains (restrict_rel A leq); M \\<noteq> {};\n        \\<And>x.\n           x \\<in> M \\<Longrightarrow>\n           (x, z) \\<in> restrict_rel A leq\\<rbrakk>\n       \\<Longrightarrow> (lub M, z) \\<in> restrict_rel A leq\n 2. \\<And>M x.\n       \\<lbrakk>M \\<in> Chains (restrict_rel A leq); x \\<in> M\\<rbrakk>\n       \\<Longrightarrow> (x, lub M) \\<in> restrict_rel A leq\n 3. \\<And>M.\n       \\<lbrakk>M \\<in> Chains (restrict_rel A leq); M \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> lub M \\<in> Field (restrict_rel A leq)\n 4. \\<And>x.\n       x \\<in> Field (restrict_rel A leq) \\<Longrightarrow>\n       (x, f x) \\<in> restrict_rel A leq", "from M"], ["proof (chain)\npicking this:\n  M \\<in> Chains (restrict_rel A leq)", "have M': \"M \\<in> Chains leq\""], ["proof (prove)\nusing this:\n  M \\<in> Chains (restrict_rel A leq)\n\ngoal (1 subgoal):\n 1. M \\<in> Chains leq", "by(rule Chains_restrict_relD)"], ["proof (state)\nthis:\n  M \\<in> Chains leq\n\ngoal (4 subgoals):\n 1. \\<And>M z.\n       \\<lbrakk>M \\<in> Chains (restrict_rel A leq); M \\<noteq> {};\n        \\<And>x.\n           x \\<in> M \\<Longrightarrow>\n           (x, z) \\<in> restrict_rel A leq\\<rbrakk>\n       \\<Longrightarrow> (lub M, z) \\<in> restrict_rel A leq\n 2. \\<And>M x.\n       \\<lbrakk>M \\<in> Chains (restrict_rel A leq); x \\<in> M\\<rbrakk>\n       \\<Longrightarrow> (x, lub M) \\<in> restrict_rel A leq\n 3. \\<And>M.\n       \\<lbrakk>M \\<in> Chains (restrict_rel A leq); M \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> lub M \\<in> Field (restrict_rel A leq)\n 4. \\<And>x.\n       x \\<in> Field (restrict_rel A leq) \\<Longrightarrow>\n       (x, f x) \\<in> restrict_rel A leq", "then"], ["proof (chain)\npicking this:\n  M \\<in> Chains leq", "have *: \"(z, lub M) \\<in> leq\""], ["proof (prove)\nusing this:\n  M \\<in> Chains leq\n\ngoal (1 subgoal):\n 1. (z, lub M) \\<in> leq", "using z"], ["proof (prove)\nusing this:\n  M \\<in> Chains leq\n  z \\<in> M\n\ngoal (1 subgoal):\n 1. (z, lub M) \\<in> leq", "by(rule lub_upper)"], ["proof (state)\nthis:\n  (z, lub M) \\<in> leq\n\ngoal (4 subgoals):\n 1. \\<And>M z.\n       \\<lbrakk>M \\<in> Chains (restrict_rel A leq); M \\<noteq> {};\n        \\<And>x.\n           x \\<in> M \\<Longrightarrow>\n           (x, z) \\<in> restrict_rel A leq\\<rbrakk>\n       \\<Longrightarrow> (lub M, z) \\<in> restrict_rel A leq\n 2. \\<And>M x.\n       \\<lbrakk>M \\<in> Chains (restrict_rel A leq); x \\<in> M\\<rbrakk>\n       \\<Longrightarrow> (x, lub M) \\<in> restrict_rel A leq\n 3. \\<And>M.\n       \\<lbrakk>M \\<in> Chains (restrict_rel A leq); M \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> lub M \\<in> Field (restrict_rel A leq)\n 4. \\<And>x.\n       x \\<in> Field (restrict_rel A leq) \\<Longrightarrow>\n       (x, f x) \\<in> restrict_rel A leq", "hence \"lub M \\<in> Field leq\""], ["proof (prove)\nusing this:\n  (z, lub M) \\<in> leq\n\ngoal (1 subgoal):\n 1. lub M \\<in> Field leq", "by(rule FieldI2)"], ["proof (state)\nthis:\n  lub M \\<in> Field leq\n\ngoal (4 subgoals):\n 1. \\<And>M z.\n       \\<lbrakk>M \\<in> Chains (restrict_rel A leq); M \\<noteq> {};\n        \\<And>x.\n           x \\<in> M \\<Longrightarrow>\n           (x, z) \\<in> restrict_rel A leq\\<rbrakk>\n       \\<Longrightarrow> (lub M, z) \\<in> restrict_rel A leq\n 2. \\<And>M x.\n       \\<lbrakk>M \\<in> Chains (restrict_rel A leq); x \\<in> M\\<rbrakk>\n       \\<Longrightarrow> (x, lub M) \\<in> restrict_rel A leq\n 3. \\<And>M.\n       \\<lbrakk>M \\<in> Chains (restrict_rel A leq); M \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> lub M \\<in> Field (restrict_rel A leq)\n 4. \\<And>x.\n       x \\<in> Field (restrict_rel A leq) \\<Longrightarrow>\n       (x, f x) \\<in> restrict_rel A leq", "with lubA"], ["proof (chain)\npicking this:\n  lub M \\<in> A\n  lub M \\<in> Field leq", "show \"lub M \\<in> Field (restrict_rel A leq)\""], ["proof (prove)\nusing this:\n  lub M \\<in> A\n  lub M \\<in> Field leq\n\ngoal (1 subgoal):\n 1. lub M \\<in> Field (restrict_rel A leq)", "by(simp add: Field_restrict_rel[OF Refl])"], ["proof (state)\nthis:\n  lub M \\<in> Field (restrict_rel A leq)\n\ngoal (4 subgoals):\n 1. \\<And>M z.\n       \\<lbrakk>M \\<in> Chains (restrict_rel A leq); M \\<noteq> {};\n        \\<And>x.\n           x \\<in> M \\<Longrightarrow>\n           (x, z) \\<in> restrict_rel A leq\\<rbrakk>\n       \\<Longrightarrow> (lub M, z) \\<in> restrict_rel A leq\n 2. \\<And>M x.\n       \\<lbrakk>M \\<in> Chains (restrict_rel A leq); x \\<in> M\\<rbrakk>\n       \\<Longrightarrow> (x, lub M) \\<in> restrict_rel A leq\n 3. \\<And>M.\n       \\<lbrakk>M \\<in> Chains (restrict_rel A leq); M \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> ?z5 M \\<in> M\n 4. \\<And>x.\n       x \\<in> Field (restrict_rel A leq) \\<Longrightarrow>\n       (x, f x) \\<in> restrict_rel A leq", "from Chains_FieldD[OF M z]"], ["proof (chain)\npicking this:\n  z \\<in> Field (restrict_rel A leq)", "have \"z \\<in> A\""], ["proof (prove)\nusing this:\n  z \\<in> Field (restrict_rel A leq)\n\ngoal (1 subgoal):\n 1. z \\<in> A", "by(simp add: Field_restrict_rel[OF Refl])"], ["proof (state)\nthis:\n  z \\<in> A\n\ngoal (4 subgoals):\n 1. \\<And>M z.\n       \\<lbrakk>M \\<in> Chains (restrict_rel A leq); M \\<noteq> {};\n        \\<And>x.\n           x \\<in> M \\<Longrightarrow>\n           (x, z) \\<in> restrict_rel A leq\\<rbrakk>\n       \\<Longrightarrow> (lub M, z) \\<in> restrict_rel A leq\n 2. \\<And>M x.\n       \\<lbrakk>M \\<in> Chains (restrict_rel A leq); x \\<in> M\\<rbrakk>\n       \\<Longrightarrow> (x, lub M) \\<in> restrict_rel A leq\n 3. \\<And>M.\n       \\<lbrakk>M \\<in> Chains (restrict_rel A leq); M \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> ?z5 M \\<in> M\n 4. \\<And>x.\n       x \\<in> Field (restrict_rel A leq) \\<Longrightarrow>\n       (x, f x) \\<in> restrict_rel A leq", "with * lubA"], ["proof (chain)\npicking this:\n  (z, lub M) \\<in> leq\n  lub M \\<in> A\n  z \\<in> A", "show \"(z, lub M ) \\<in> restrict_rel A leq\""], ["proof (prove)\nusing this:\n  (z, lub M) \\<in> leq\n  lub M \\<in> A\n  z \\<in> A\n\ngoal (1 subgoal):\n 1. (z, lub M) \\<in> restrict_rel A leq", "by auto"], ["proof (state)\nthis:\n  (z, lub M) \\<in> restrict_rel A leq\n\ngoal (4 subgoals):\n 1. \\<And>M z.\n       \\<lbrakk>M \\<in> Chains (restrict_rel A leq); M \\<noteq> {};\n        \\<And>x.\n           x \\<in> M \\<Longrightarrow>\n           (x, z) \\<in> restrict_rel A leq\\<rbrakk>\n       \\<Longrightarrow> (lub M, z) \\<in> restrict_rel A leq\n 2. \\<And>M x.\n       \\<lbrakk>M \\<in> Chains (restrict_rel A leq); x \\<in> M\\<rbrakk>\n       \\<Longrightarrow> x \\<in> M\n 3. \\<And>M.\n       \\<lbrakk>M \\<in> Chains (restrict_rel A leq); M \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> ?z5 M \\<in> M\n 4. \\<And>x.\n       x \\<in> Field (restrict_rel A leq) \\<Longrightarrow>\n       (x, f x) \\<in> restrict_rel A leq", "fix z"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>M z.\n       \\<lbrakk>M \\<in> Chains (restrict_rel A leq); M \\<noteq> {};\n        \\<And>x.\n           x \\<in> M \\<Longrightarrow>\n           (x, z) \\<in> restrict_rel A leq\\<rbrakk>\n       \\<Longrightarrow> (lub M, z) \\<in> restrict_rel A leq\n 2. \\<And>M x.\n       \\<lbrakk>M \\<in> Chains (restrict_rel A leq); x \\<in> M\\<rbrakk>\n       \\<Longrightarrow> x \\<in> M\n 3. \\<And>M.\n       \\<lbrakk>M \\<in> Chains (restrict_rel A leq); M \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> ?z5 M \\<in> M\n 4. \\<And>x.\n       x \\<in> Field (restrict_rel A leq) \\<Longrightarrow>\n       (x, f x) \\<in> restrict_rel A leq", "assume upper: \"\\<And>x. x \\<in> M \\<Longrightarrow> (x, z) \\<in> restrict_rel A leq\""], ["proof (state)\nthis:\n  ?x \\<in> M \\<Longrightarrow> (?x, z) \\<in> restrict_rel A leq\n\ngoal (4 subgoals):\n 1. \\<And>M z.\n       \\<lbrakk>M \\<in> Chains (restrict_rel A leq); M \\<noteq> {};\n        \\<And>x.\n           x \\<in> M \\<Longrightarrow>\n           (x, z) \\<in> restrict_rel A leq\\<rbrakk>\n       \\<Longrightarrow> (lub M, z) \\<in> restrict_rel A leq\n 2. \\<And>M x.\n       \\<lbrakk>M \\<in> Chains (restrict_rel A leq); x \\<in> M\\<rbrakk>\n       \\<Longrightarrow> x \\<in> M\n 3. \\<And>M.\n       \\<lbrakk>M \\<in> Chains (restrict_rel A leq); M \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> ?z5 M \\<in> M\n 4. \\<And>x.\n       x \\<in> Field (restrict_rel A leq) \\<Longrightarrow>\n       (x, f x) \\<in> restrict_rel A leq", "from upper[OF z]"], ["proof (chain)\npicking this:\n  (z__, z) \\<in> restrict_rel A leq", "have \"z \\<in> Field (restrict_rel A leq)\""], ["proof (prove)\nusing this:\n  (z__, z) \\<in> restrict_rel A leq\n\ngoal (1 subgoal):\n 1. z \\<in> Field (restrict_rel A leq)", "by(auto simp add: Field_def)"], ["proof (state)\nthis:\n  z \\<in> Field (restrict_rel A leq)\n\ngoal (4 subgoals):\n 1. \\<And>M z.\n       \\<lbrakk>M \\<in> Chains (restrict_rel A leq); M \\<noteq> {};\n        \\<And>x.\n           x \\<in> M \\<Longrightarrow>\n           (x, z) \\<in> restrict_rel A leq\\<rbrakk>\n       \\<Longrightarrow> (lub M, z) \\<in> restrict_rel A leq\n 2. \\<And>M x.\n       \\<lbrakk>M \\<in> Chains (restrict_rel A leq); x \\<in> M\\<rbrakk>\n       \\<Longrightarrow> x \\<in> M\n 3. \\<And>M.\n       \\<lbrakk>M \\<in> Chains (restrict_rel A leq); M \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> ?z5 M \\<in> M\n 4. \\<And>x.\n       x \\<in> Field (restrict_rel A leq) \\<Longrightarrow>\n       (x, f x) \\<in> restrict_rel A leq", "with Field_restrict_rel_subset[of A leq]"], ["proof (chain)\npicking this:\n  Field (restrict_rel A leq) \\<subseteq> A \\<inter> Field leq\n  z \\<in> Field (restrict_rel A leq)", "have \"z \\<in> A\""], ["proof (prove)\nusing this:\n  Field (restrict_rel A leq) \\<subseteq> A \\<inter> Field leq\n  z \\<in> Field (restrict_rel A leq)\n\ngoal (1 subgoal):\n 1. z \\<in> A", "by blast"], ["proof (state)\nthis:\n  z \\<in> A\n\ngoal (4 subgoals):\n 1. \\<And>M z.\n       \\<lbrakk>M \\<in> Chains (restrict_rel A leq); M \\<noteq> {};\n        \\<And>x.\n           x \\<in> M \\<Longrightarrow>\n           (x, z) \\<in> restrict_rel A leq\\<rbrakk>\n       \\<Longrightarrow> (lub M, z) \\<in> restrict_rel A leq\n 2. \\<And>M x.\n       \\<lbrakk>M \\<in> Chains (restrict_rel A leq); x \\<in> M\\<rbrakk>\n       \\<Longrightarrow> x \\<in> M\n 3. \\<And>M.\n       \\<lbrakk>M \\<in> Chains (restrict_rel A leq); M \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> ?z5 M \\<in> M\n 4. \\<And>x.\n       x \\<in> Field (restrict_rel A leq) \\<Longrightarrow>\n       (x, f x) \\<in> restrict_rel A leq", "moreover"], ["proof (state)\nthis:\n  z \\<in> A\n\ngoal (4 subgoals):\n 1. \\<And>M z.\n       \\<lbrakk>M \\<in> Chains (restrict_rel A leq); M \\<noteq> {};\n        \\<And>x.\n           x \\<in> M \\<Longrightarrow>\n           (x, z) \\<in> restrict_rel A leq\\<rbrakk>\n       \\<Longrightarrow> (lub M, z) \\<in> restrict_rel A leq\n 2. \\<And>M x.\n       \\<lbrakk>M \\<in> Chains (restrict_rel A leq); x \\<in> M\\<rbrakk>\n       \\<Longrightarrow> x \\<in> M\n 3. \\<And>M.\n       \\<lbrakk>M \\<in> Chains (restrict_rel A leq); M \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> ?z5 M \\<in> M\n 4. \\<And>x.\n       x \\<in> Field (restrict_rel A leq) \\<Longrightarrow>\n       (x, f x) \\<in> restrict_rel A leq", "from lub_least[OF M' \\<open>M \\<noteq> {}\\<close>] upper"], ["proof (chain)\npicking this:\n  (\\<And>x. x \\<in> M \\<Longrightarrow> (x, ?z) \\<in> leq) \\<Longrightarrow>\n  (lub M, ?z) \\<in> leq\n  ?x \\<in> M \\<Longrightarrow> (?x, z) \\<in> restrict_rel A leq", "have \"(lub M, z) \\<in> leq\""], ["proof (prove)\nusing this:\n  (\\<And>x. x \\<in> M \\<Longrightarrow> (x, ?z) \\<in> leq) \\<Longrightarrow>\n  (lub M, ?z) \\<in> leq\n  ?x \\<in> M \\<Longrightarrow> (?x, z) \\<in> restrict_rel A leq\n\ngoal (1 subgoal):\n 1. (lub M, z) \\<in> leq", "by(auto simp add: in_restrict_rel_iff)"], ["proof (state)\nthis:\n  (lub M, z) \\<in> leq\n\ngoal (4 subgoals):\n 1. \\<And>M z.\n       \\<lbrakk>M \\<in> Chains (restrict_rel A leq); M \\<noteq> {};\n        \\<And>x.\n           x \\<in> M \\<Longrightarrow>\n           (x, z) \\<in> restrict_rel A leq\\<rbrakk>\n       \\<Longrightarrow> (lub M, z) \\<in> restrict_rel A leq\n 2. \\<And>M x.\n       \\<lbrakk>M \\<in> Chains (restrict_rel A leq); x \\<in> M\\<rbrakk>\n       \\<Longrightarrow> x \\<in> M\n 3. \\<And>M.\n       \\<lbrakk>M \\<in> Chains (restrict_rel A leq); M \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> ?z5 M \\<in> M\n 4. \\<And>x.\n       x \\<in> Field (restrict_rel A leq) \\<Longrightarrow>\n       (x, f x) \\<in> restrict_rel A leq", "ultimately"], ["proof (chain)\npicking this:\n  z \\<in> A\n  (lub M, z) \\<in> leq", "show \"(lub M, z) \\<in> restrict_rel A leq\""], ["proof (prove)\nusing this:\n  z \\<in> A\n  (lub M, z) \\<in> leq\n\ngoal (1 subgoal):\n 1. (lub M, z) \\<in> restrict_rel A leq", "using lubA"], ["proof (prove)\nusing this:\n  z \\<in> A\n  (lub M, z) \\<in> leq\n  lub M \\<in> A\n\ngoal (1 subgoal):\n 1. (lub M, z) \\<in> restrict_rel A leq", "by(simp add: in_restrict_rel_iff)"], ["proof (state)\nthis:\n  (lub M, z) \\<in> restrict_rel A leq\n\ngoal (4 subgoals):\n 1. \\<And>M z.\n       \\<lbrakk>M \\<in> Chains (restrict_rel A leq); M \\<noteq> {};\n        \\<And>x.\n           x \\<in> M \\<Longrightarrow>\n           (x, z) \\<in> restrict_rel A leq\\<rbrakk>\n       \\<Longrightarrow> ?z19 M z \\<in> M\n 2. \\<And>M x.\n       \\<lbrakk>M \\<in> Chains (restrict_rel A leq); x \\<in> M\\<rbrakk>\n       \\<Longrightarrow> x \\<in> M\n 3. \\<And>M.\n       \\<lbrakk>M \\<in> Chains (restrict_rel A leq); M \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> ?z5 M \\<in> M\n 4. \\<And>x.\n       x \\<in> Field (restrict_rel A leq) \\<Longrightarrow>\n       (x, f x) \\<in> restrict_rel A leq", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?M2 \\<in> Chains (restrict_rel A leq); ?z2 \\<in> ?M2;\n   \\<And>x.\n      x \\<in> ?M2 \\<Longrightarrow>\n      (x, ?za2) \\<in> restrict_rel A leq\\<rbrakk>\n  \\<Longrightarrow> (lub ?M2, ?za2) \\<in> restrict_rel A leq\n\ngoal (4 subgoals):\n 1. \\<And>M z.\n       \\<lbrakk>M \\<in> Chains (restrict_rel A leq); M \\<noteq> {};\n        \\<And>x.\n           x \\<in> M \\<Longrightarrow>\n           (x, z) \\<in> restrict_rel A leq\\<rbrakk>\n       \\<Longrightarrow> ?z19 M z \\<in> M\n 2. \\<And>M x.\n       \\<lbrakk>M \\<in> Chains (restrict_rel A leq); x \\<in> M\\<rbrakk>\n       \\<Longrightarrow> x \\<in> M\n 3. \\<And>M.\n       \\<lbrakk>M \\<in> Chains (restrict_rel A leq); M \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> ?z5 M \\<in> M\n 4. \\<And>x.\n       x \\<in> Field (restrict_rel A leq) \\<Longrightarrow>\n       (x, f x) \\<in> restrict_rel A leq", "{"], ["proof (state)\nthis:\n  \\<lbrakk>?M2 \\<in> Chains (restrict_rel A leq); ?z2 \\<in> ?M2;\n   \\<And>x.\n      x \\<in> ?M2 \\<Longrightarrow>\n      (x, ?za2) \\<in> restrict_rel A leq\\<rbrakk>\n  \\<Longrightarrow> (lub ?M2, ?za2) \\<in> restrict_rel A leq\n\ngoal (4 subgoals):\n 1. \\<And>M z.\n       \\<lbrakk>M \\<in> Chains (restrict_rel A leq); M \\<noteq> {};\n        \\<And>x.\n           x \\<in> M \\<Longrightarrow>\n           (x, z) \\<in> restrict_rel A leq\\<rbrakk>\n       \\<Longrightarrow> ?z19 M z \\<in> M\n 2. \\<And>M x.\n       \\<lbrakk>M \\<in> Chains (restrict_rel A leq); x \\<in> M\\<rbrakk>\n       \\<Longrightarrow> x \\<in> M\n 3. \\<And>M.\n       \\<lbrakk>M \\<in> Chains (restrict_rel A leq); M \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> ?z5 M \\<in> M\n 4. \\<And>x.\n       x \\<in> Field (restrict_rel A leq) \\<Longrightarrow>\n       (x, f x) \\<in> restrict_rel A leq", "fix x"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>M z.\n       \\<lbrakk>M \\<in> Chains (restrict_rel A leq); M \\<noteq> {};\n        \\<And>x.\n           x \\<in> M \\<Longrightarrow>\n           (x, z) \\<in> restrict_rel A leq\\<rbrakk>\n       \\<Longrightarrow> ?z19 M z \\<in> M\n 2. \\<And>M x.\n       \\<lbrakk>M \\<in> Chains (restrict_rel A leq); x \\<in> M\\<rbrakk>\n       \\<Longrightarrow> x \\<in> M\n 3. \\<And>M.\n       \\<lbrakk>M \\<in> Chains (restrict_rel A leq); M \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> ?z5 M \\<in> M\n 4. \\<And>x.\n       x \\<in> Field (restrict_rel A leq) \\<Longrightarrow>\n       (x, f x) \\<in> restrict_rel A leq", "assume \"x \\<in> Field (restrict_rel A leq)\""], ["proof (state)\nthis:\n  x \\<in> Field (restrict_rel A leq)\n\ngoal (4 subgoals):\n 1. \\<And>M z.\n       \\<lbrakk>M \\<in> Chains (restrict_rel A leq); M \\<noteq> {};\n        \\<And>x.\n           x \\<in> M \\<Longrightarrow>\n           (x, z) \\<in> restrict_rel A leq\\<rbrakk>\n       \\<Longrightarrow> ?z19 M z \\<in> M\n 2. \\<And>M x.\n       \\<lbrakk>M \\<in> Chains (restrict_rel A leq); x \\<in> M\\<rbrakk>\n       \\<Longrightarrow> x \\<in> M\n 3. \\<And>M.\n       \\<lbrakk>M \\<in> Chains (restrict_rel A leq); M \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> ?z5 M \\<in> M\n 4. \\<And>x.\n       x \\<in> Field (restrict_rel A leq) \\<Longrightarrow>\n       (x, f x) \\<in> restrict_rel A leq", "hence \"x \\<in> A\" \"x \\<in> Field leq\""], ["proof (prove)\nusing this:\n  x \\<in> Field (restrict_rel A leq)\n\ngoal (1 subgoal):\n 1. x \\<in> A &&& x \\<in> Field leq", "by(simp_all add: Field_restrict_rel[OF Refl])"], ["proof (state)\nthis:\n  x \\<in> A\n  x \\<in> Field leq\n\ngoal (4 subgoals):\n 1. \\<And>M z.\n       \\<lbrakk>M \\<in> Chains (restrict_rel A leq); M \\<noteq> {};\n        \\<And>x.\n           x \\<in> M \\<Longrightarrow>\n           (x, z) \\<in> restrict_rel A leq\\<rbrakk>\n       \\<Longrightarrow> ?z19 M z \\<in> M\n 2. \\<And>M x.\n       \\<lbrakk>M \\<in> Chains (restrict_rel A leq); x \\<in> M\\<rbrakk>\n       \\<Longrightarrow> x \\<in> M\n 3. \\<And>M.\n       \\<lbrakk>M \\<in> Chains (restrict_rel A leq); M \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> ?z5 M \\<in> M\n 4. \\<And>x.\n       x \\<in> Field (restrict_rel A leq) \\<Longrightarrow>\n       (x, f x) \\<in> restrict_rel A leq", "with increasing[OF this]"], ["proof (chain)\npicking this:\n  (x, f x) \\<in> leq \\<and> f x \\<in> A\n  x \\<in> A\n  x \\<in> Field leq", "show \"(x, f x) \\<in> restrict_rel A leq\""], ["proof (prove)\nusing this:\n  (x, f x) \\<in> leq \\<and> f x \\<in> A\n  x \\<in> A\n  x \\<in> Field leq\n\ngoal (1 subgoal):\n 1. (x, f x) \\<in> restrict_rel A leq", "by auto"], ["proof (state)\nthis:\n  (x, f x) \\<in> restrict_rel A leq\n\ngoal (3 subgoals):\n 1. \\<And>M z.\n       \\<lbrakk>M \\<in> Chains (restrict_rel A leq); M \\<noteq> {};\n        \\<And>x.\n           x \\<in> M \\<Longrightarrow>\n           (x, z) \\<in> restrict_rel A leq\\<rbrakk>\n       \\<Longrightarrow> ?z19 M z \\<in> M\n 2. \\<And>M x.\n       \\<lbrakk>M \\<in> Chains (restrict_rel A leq); x \\<in> M\\<rbrakk>\n       \\<Longrightarrow> x \\<in> M\n 3. \\<And>M.\n       \\<lbrakk>M \\<in> Chains (restrict_rel A leq); M \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> ?z5 M \\<in> M", "}"], ["proof (state)\nthis:\n  ?x2 \\<in> Field (restrict_rel A leq) \\<Longrightarrow>\n  (?x2, f ?x2) \\<in> restrict_rel A leq\n\ngoal (3 subgoals):\n 1. \\<And>M z.\n       \\<lbrakk>M \\<in> Chains (restrict_rel A leq); M \\<noteq> {};\n        \\<And>x.\n           x \\<in> M \\<Longrightarrow>\n           (x, z) \\<in> restrict_rel A leq\\<rbrakk>\n       \\<Longrightarrow> ?z19 M z \\<in> M\n 2. \\<And>M x.\n       \\<lbrakk>M \\<in> Chains (restrict_rel A leq); x \\<in> M\\<rbrakk>\n       \\<Longrightarrow> x \\<in> M\n 3. \\<And>M.\n       \\<lbrakk>M \\<in> Chains (restrict_rel A leq); M \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> ?z5 M \\<in> M", "show \"(SOME x. x \\<in> M) \\<in> M\" \"(SOME x. x \\<in> M) \\<in> M\" if \"M \\<noteq> {}\" for M :: \"'a set\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (SOME x. x \\<in> M) \\<in> M &&& (SOME x. x \\<in> M) \\<in> M", "using that"], ["proof (prove)\nusing this:\n  M \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (SOME x. x \\<in> M) \\<in> M &&& (SOME x. x \\<in> M) \\<in> M", "by(auto intro: someI)"], ["proof (state)\nthis:\n  ?M \\<noteq> {} \\<Longrightarrow> (SOME x. x \\<in> ?M) \\<in> ?M\n  ?M \\<noteq> {} \\<Longrightarrow> (SOME x. x \\<in> ?M) \\<in> ?M\n\ngoal (1 subgoal):\n 1. \\<And>M x.\n       \\<lbrakk>M \\<in> Chains (restrict_rel A leq); x \\<in> M\\<rbrakk>\n       \\<Longrightarrow> x \\<in> M", "qed"], ["", "lemma Field_le [simp]: \"Field {(x :: _ :: preorder, y). x \\<le> y} = UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Field {(x, y). x \\<le> y} = UNIV", "by(auto intro: FieldI1)"], ["", "lemma Field_ge [simp]: \"Field {(x :: _ :: preorder, y). y \\<le> x} = UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Field {(x, y). y \\<le> x} = UNIV", "by(auto intro: FieldI1)"], ["", "lemma refl_le [simp]: \"refl {(x :: _ :: preorder, y). x \\<le> y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. refl {(x, y). x \\<le> y}", "by(auto intro!: refl_onI simp add: Field_def)"], ["", "lemma refl_ge [simp]: \"refl {(x :: _ :: preorder, y). y \\<le> x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. refl {(x, y). y \\<le> x}", "by(auto intro!: refl_onI simp add: Field_def)"], ["", "lemma partial_order_le [simp]: \"partial_order_on UNIV {(x :: _ :: order, x'). x \\<le> x'}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. partial_order_on UNIV {(x, x'). x \\<le> x'}", "by(auto simp add: order_on_defs trans_def antisym_def)"], ["", "lemma partial_order_ge [simp]: \"partial_order_on UNIV {(x :: _ :: order, x'). x' \\<le> x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. partial_order_on UNIV {(x, x'). x' \\<le> x}", "by(auto simp add: order_on_defs trans_def antisym_def)"], ["", "lemma incseq_chain_range: \"incseq f \\<Longrightarrow> Complete_Partial_Order.chain (\\<le>) (range f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. incseq f \\<Longrightarrow>\n    Complete_Partial_Order.chain (\\<le>) (range f)", "apply(rule chainI; clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa xb.\n       \\<lbrakk>incseq f; \\<not> f xb \\<le> f xa\\<rbrakk>\n       \\<Longrightarrow> f xa \\<le> f xb", "using linear"], ["proof (prove)\nusing this:\n  ?x \\<le> ?y \\<or> ?y \\<le> ?x\n\ngoal (1 subgoal):\n 1. \\<And>xa xb.\n       \\<lbrakk>incseq f; \\<not> f xb \\<le> f xa\\<rbrakk>\n       \\<Longrightarrow> f xa \\<le> f xb", "by (auto dest: incseqD)"], ["", "end"]]}