{"file_name": "/home/qj213/afp-2021-10-22/thys/MFMC_Countable/MFMC_Finite.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/MFMC_Countable", "problem_names": ["lemma outgoing_outside: \"x \\<notin> V \\<Longrightarrow> outgoing x = {}\"", "lemma incoming_outside: \"x \\<notin> V \\<Longrightarrow> incoming x = {}\"", "lemma conservation: \"\\<lbrakk> x \\<noteq> s; x \\<noteq> t \\<rbrakk> \\<Longrightarrow> sum f (incoming x) = sum f (outgoing x)\"", "lemma augmenting_path_imp_shortest: \n  \"isAugmentingPath p \\<Longrightarrow> \\<exists>p. Graph.isShortestPath cf s p t\"", "lemma shortest_is_augmenting: \n  \"Graph.isShortestPath cf s p t \\<Longrightarrow> isAugmentingPath p\"", "lemma shortest_augmenting_path:\n  assumes \"NFlow c s t f\" \n  and \"\\<exists>p. NPreflow.isAugmentingPath c s t f p\"\n  shows \"Graph.isShortestPath (residualGraph c f) s (shortest_augmenting_path f) t\"", "lemma max_flow:\n  \"NFlow c s t max_flow\" (is ?thesis1)\n  \"\\<not> (\\<exists>p. NPreflow.isAugmentingPath c s t max_flow p)\" (is ?thesis2)"], "translations": [["", "lemma outgoing_outside: \"x \\<notin> V \\<Longrightarrow> outgoing x = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> V \\<Longrightarrow> outgoing x = {}", "by(auto simp add: outgoing_def V_def)"], ["", "lemma incoming_outside: \"x \\<notin> V \\<Longrightarrow> incoming x = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> V \\<Longrightarrow> incoming x = {}", "by(auto simp add: incoming_def V_def)"], ["", "end"], ["", "context NFlow begin"], ["", "lemma conservation: \"\\<lbrakk> x \\<noteq> s; x \\<noteq> t \\<rbrakk> \\<Longrightarrow> sum f (incoming x) = sum f (outgoing x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> s; x \\<noteq> t\\<rbrakk>\n    \\<Longrightarrow> sum f (incoming x) = sum f (outgoing x)", "by(cases \"x \\<in> V\")(auto simp add: conservation_const outgoing_outside incoming_outside)"], ["", "lemma augmenting_path_imp_shortest: \n  \"isAugmentingPath p \\<Longrightarrow> \\<exists>p. Graph.isShortestPath cf s p t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isAugmentingPath p \\<Longrightarrow> \\<exists>p. cf.isShortestPath s p t", "using Graph.obtain_shortest_path"], ["proof (prove)\nusing this:\n  \\<lbrakk>Graph.connected ?c ?u ?v;\n   \\<And>p.\n      Graph.isShortestPath ?c ?u p ?v \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. isAugmentingPath p \\<Longrightarrow> \\<exists>p. cf.isShortestPath s p t", "unfolding isAugmentingPath_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>Graph.connected ?c ?u ?v;\n   \\<And>p.\n      Graph.isShortestPath ?c ?u p ?v \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. cf.isSimplePath s p t \\<Longrightarrow>\n    \\<exists>p. cf.isShortestPath s p t", "by (fastforce simp: Graph.isSimplePath_def Graph.connected_def)"], ["", "lemma shortest_is_augmenting: \n  \"Graph.isShortestPath cf s p t \\<Longrightarrow> isAugmentingPath p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cf.isShortestPath s p t \\<Longrightarrow> isAugmentingPath p", "unfolding isAugmentingPath_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. cf.isShortestPath s p t \\<Longrightarrow> cf.isSimplePath s p t", "using Graph.shortestPath_is_simple"], ["proof (prove)\nusing this:\n  Graph.isShortestPath ?c ?s ?p ?t \\<Longrightarrow>\n  Graph.isSimplePath ?c ?s ?p ?t\n\ngoal (1 subgoal):\n 1. cf.isShortestPath s p t \\<Longrightarrow> cf.isSimplePath s p t", "by (fastforce)"], ["", "definition \"augment_with_path p \\<equiv> augment (augmentingFlow p)\""], ["", "end"], ["", "context Network begin"], ["", "definition \"shortest_augmenting_path f = (SOME p. Graph.isShortestPath (residualGraph c f) s p t)\""], ["", "lemma shortest_augmenting_path:\n  assumes \"NFlow c s t f\" \n  and \"\\<exists>p. NPreflow.isAugmentingPath c s t f p\"\n  shows \"Graph.isShortestPath (residualGraph c f) s (shortest_augmenting_path f) t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Graph.isShortestPath (cf_of f) s (shortest_augmenting_path f) t", "using assms"], ["proof (prove)\nusing this:\n  NFlow c s t f\n  \\<exists>p. NPreflow.isAugmentingPath c s t f p\n\ngoal (1 subgoal):\n 1. Graph.isShortestPath (cf_of f) s (shortest_augmenting_path f) t", "unfolding shortest_augmenting_path_def"], ["proof (prove)\nusing this:\n  NFlow c s t f\n  \\<exists>p. NPreflow.isAugmentingPath c s t f p\n\ngoal (1 subgoal):\n 1. Graph.isShortestPath (cf_of f) s\n     (SOME p. Graph.isShortestPath (cf_of f) s p t) t", "by clarify(rule someI_ex, rule NFlow.augmenting_path_imp_shortest)"], ["", "definition max_flow where\n  \"max_flow = while\n     (\\<lambda>f. \\<exists>p. NPreflow.isAugmentingPath c s t f p)\n     (\\<lambda>f. NFlow.augment_with_path c f (shortest_augmenting_path f)) (\\<lambda>_. 0)\""], ["", "lemma max_flow:\n  \"NFlow c s t max_flow\" (is ?thesis1)\n  \"\\<not> (\\<exists>p. NPreflow.isAugmentingPath c s t max_flow p)\" (is ?thesis2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. NFlow c s t max_flow &&&\n    \\<nexists>p. NPreflow.isAugmentingPath c s t max_flow p", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. NFlow c s t max_flow\n 2. \\<nexists>p. NPreflow.isAugmentingPath c s t max_flow p", "have \"NFlow c s t (\\<lambda>_. 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. NFlow c s t (\\<lambda>_. 0::'capacity)", "by unfold_locales(simp_all add: cap_non_negative)"], ["proof (state)\nthis:\n  NFlow c s t (\\<lambda>_. 0::'capacity)\n\ngoal (2 subgoals):\n 1. NFlow c s t max_flow\n 2. \\<nexists>p. NPreflow.isAugmentingPath c s t max_flow p", "moreover"], ["proof (state)\nthis:\n  NFlow c s t (\\<lambda>_. 0::'capacity)\n\ngoal (2 subgoals):\n 1. NFlow c s t max_flow\n 2. \\<nexists>p. NPreflow.isAugmentingPath c s t max_flow p", "have \"NFlow c s t (NFlow.augment_with_path c f (shortest_augmenting_path f))\"\n    if \"NFlow c s t f\" and \"\\<exists>p. NPreflow.isAugmentingPath c s t f p\" for f"], ["proof (prove)\ngoal (1 subgoal):\n 1. NFlow c s t (NFlow.augment_with_path c f (shortest_augmenting_path f))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. NFlow c s t (NFlow.augment_with_path c f (shortest_augmenting_path f))", "interpret NFlow c s t f"], ["proof (prove)\ngoal (1 subgoal):\n 1. NFlow c s t f", "using that(1)"], ["proof (prove)\nusing this:\n  NFlow c s t f\n\ngoal (1 subgoal):\n 1. NFlow c s t f", "."], ["proof (state)\ngoal (1 subgoal):\n 1. NFlow c s t (augment_with_path (shortest_augmenting_path f))", "interpret F: Flow c s t \"NFlow.augment c f (NPreflow.augmentingFlow c f (shortest_augmenting_path f))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Flow c s t (augment (augmentingFlow (shortest_augmenting_path f)))", "by(intro augment_flow_presv augFlow_resFlow shortest_is_augmenting shortest_augmenting_path[OF that])"], ["proof (state)\ngoal (1 subgoal):\n 1. NFlow c s t (augment_with_path (shortest_augmenting_path f))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. NFlow c s t (augment_with_path (shortest_augmenting_path f))", "using that"], ["proof (prove)\nusing this:\n  NFlow c s t f\n  Ex isAugmentingPath\n\ngoal (1 subgoal):\n 1. NFlow c s t (augment_with_path (shortest_augmenting_path f))", "by(simp add: NFlow.augment_with_path_def)(unfold_locales)"], ["proof (state)\nthis:\n  NFlow c s t (augment_with_path (shortest_augmenting_path f))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>NFlow c s t ?f;\n   \\<exists>p. NPreflow.isAugmentingPath c s t ?f p\\<rbrakk>\n  \\<Longrightarrow> NFlow c s t\n                     (NFlow.augment_with_path c ?f\n                       (shortest_augmenting_path ?f))\n\ngoal (2 subgoals):\n 1. NFlow c s t max_flow\n 2. \\<nexists>p. NPreflow.isAugmentingPath c s t max_flow p", "ultimately"], ["proof (chain)\npicking this:\n  NFlow c s t (\\<lambda>_. 0::'capacity)\n  \\<lbrakk>NFlow c s t ?f;\n   \\<exists>p. NPreflow.isAugmentingPath c s t ?f p\\<rbrakk>\n  \\<Longrightarrow> NFlow c s t\n                     (NFlow.augment_with_path c ?f\n                       (shortest_augmenting_path ?f))", "have \"NFlow c s t max_flow \\<and> \\<not> (\\<exists>p. NPreflow.isAugmentingPath c s t max_flow p)\""], ["proof (prove)\nusing this:\n  NFlow c s t (\\<lambda>_. 0::'capacity)\n  \\<lbrakk>NFlow c s t ?f;\n   \\<exists>p. NPreflow.isAugmentingPath c s t ?f p\\<rbrakk>\n  \\<Longrightarrow> NFlow c s t\n                     (NFlow.augment_with_path c ?f\n                       (shortest_augmenting_path ?f))\n\ngoal (1 subgoal):\n 1. NFlow c s t max_flow \\<and>\n    (\\<nexists>p. NPreflow.isAugmentingPath c s t max_flow p)", "unfolding max_flow_def"], ["proof (prove)\nusing this:\n  NFlow c s t (\\<lambda>_. 0::'capacity)\n  \\<lbrakk>NFlow c s t ?f;\n   \\<exists>p. NPreflow.isAugmentingPath c s t ?f p\\<rbrakk>\n  \\<Longrightarrow> NFlow c s t\n                     (NFlow.augment_with_path c ?f\n                       (shortest_augmenting_path ?f))\n\ngoal (1 subgoal):\n 1. NFlow c s t\n     (while (\\<lambda>f. Ex (NPreflow.isAugmentingPath c s t f))\n       (\\<lambda>f.\n           NFlow.augment_with_path c f (shortest_augmenting_path f))\n       (\\<lambda>_. 0::'capacity)) \\<and>\n    (\\<nexists>p.\n        NPreflow.isAugmentingPath c s t\n         (while (\\<lambda>f. Ex (NPreflow.isAugmentingPath c s t f))\n           (\\<lambda>f.\n               NFlow.augment_with_path c f (shortest_augmenting_path f))\n           (\\<lambda>_. 0::'capacity))\n         p)", "by(rule while_rule[where P=\"NFlow c s t\" and r=\"measure (\\<lambda>f. ek_analysis_defs.ekMeasure (residualGraph c f) s t)\"])\n      (auto intro: shortest_augmenting_path NFlow.shortest_path_decr_ek_measure simp add: NFlow.augment_with_path_def)"], ["proof (state)\nthis:\n  NFlow c s t max_flow \\<and>\n  (\\<nexists>p. NPreflow.isAugmentingPath c s t max_flow p)\n\ngoal (2 subgoals):\n 1. NFlow c s t max_flow\n 2. \\<nexists>p. NPreflow.isAugmentingPath c s t max_flow p", "thus ?thesis1 ?thesis2"], ["proof (prove)\nusing this:\n  NFlow c s t max_flow \\<and>\n  (\\<nexists>p. NPreflow.isAugmentingPath c s t max_flow p)\n\ngoal (1 subgoal):\n 1. NFlow c s t max_flow &&&\n    \\<nexists>p. NPreflow.isAugmentingPath c s t max_flow p", "by simp_all"], ["proof (state)\nthis:\n  NFlow c s t max_flow\n  \\<nexists>p. NPreflow.isAugmentingPath c s t max_flow p\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "end"]]}