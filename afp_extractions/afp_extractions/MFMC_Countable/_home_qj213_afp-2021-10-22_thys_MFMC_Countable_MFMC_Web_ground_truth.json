{"file_name": "/home/qj213/afp-2021-10-22/thys/MFMC_Countable/MFMC_Web.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/MFMC_Countable", "problem_names": ["lemma vertex_weight_update [simp]: \"vertex (weight_update f \\<Gamma>) = vertex \\<Gamma>\"", "lemma currentD_weight_OUT: \"current \\<Gamma> f \\<Longrightarrow> d_OUT f x \\<le> weight \\<Gamma> x\"", "lemma currentD_weight_IN: \"current \\<Gamma> f \\<Longrightarrow> d_IN f x \\<le> weight \\<Gamma> x\"", "lemma currentD_OUT_IN: \"\\<lbrakk> current \\<Gamma> f; x \\<notin> A \\<Gamma> \\<rbrakk> \\<Longrightarrow> d_OUT f x \\<le> d_IN f x\"", "lemma currentD_IN: \"\\<lbrakk> current \\<Gamma> f; a \\<in> A \\<Gamma> \\<rbrakk> \\<Longrightarrow> d_IN f a = 0\"", "lemma currentD_OUT: \"\\<lbrakk> current \\<Gamma> f; b \\<in> B \\<Gamma> \\<rbrakk> \\<Longrightarrow> d_OUT f b = 0\"", "lemma currentD_outside: \"\\<lbrakk> current \\<Gamma> f; \\<not> edge \\<Gamma> x y \\<rbrakk> \\<Longrightarrow> f (x, y) = 0\"", "lemma currentD_outside': \"\\<lbrakk> current \\<Gamma> f; e \\<notin> \\<^bold>E\\<^bsub>\\<Gamma>\\<^esub> \\<rbrakk> \\<Longrightarrow> f e = 0\"", "lemma currentD_OUT_eq_0:\n  assumes \"current \\<Gamma> f\"\n  shows \"d_OUT f x = 0 \\<longleftrightarrow> (\\<forall>y. f (x, y) = 0)\"", "lemma currentD_IN_eq_0:\n  assumes \"current \\<Gamma> f\"\n  shows \"d_IN f x = 0 \\<longleftrightarrow> (\\<forall>y. f (y, x) = 0)\"", "lemma current_support_flow:\n  fixes \\<Gamma> (structure)\n  assumes \"current \\<Gamma> f\"\n  shows \"support_flow f \\<subseteq> \\<^bold>E\"", "lemma currentD_outside_IN: \"\\<lbrakk> current \\<Gamma> f; x \\<notin> \\<^bold>V\\<^bsub>\\<Gamma>\\<^esub> \\<rbrakk> \\<Longrightarrow> d_IN f x = 0\"", "lemma currentD_outside_OUT: \"\\<lbrakk> current \\<Gamma> f; x \\<notin> \\<^bold>V\\<^bsub>\\<Gamma>\\<^esub> \\<rbrakk> \\<Longrightarrow> d_OUT f x = 0\"", "lemma currentD_weight_in: \"current \\<Gamma> h \\<Longrightarrow> h (x, y) \\<le> weight \\<Gamma> y\"", "lemma currentD_weight_out: \"current \\<Gamma> h \\<Longrightarrow> h (x, y) \\<le> weight \\<Gamma> x\"", "lemma current_leI:\n  fixes \\<Gamma> (structure)\n  assumes f: \"current \\<Gamma> f\"\n  and le: \"\\<And>e. g e \\<le> f e\"\n  and OUT_IN: \"\\<And>x. x \\<notin> A \\<Gamma> \\<Longrightarrow> d_OUT g x \\<le> d_IN g x\"\n  shows \"current \\<Gamma> g\"", "lemma current_weight_mono:\n  \"\\<lbrakk> current \\<Gamma> f; edge \\<Gamma> = edge \\<Gamma>'; A \\<Gamma> = A \\<Gamma>'; B \\<Gamma> = B \\<Gamma>'; \\<And>x. weight \\<Gamma> x \\<le> weight \\<Gamma>' x \\<rbrakk>\n  \\<Longrightarrow> current \\<Gamma>' f\"", "lemma SINK_0 [simp]: \"SINK zero_current = UNIV\"", "lemma current_0 [simp]: \"current \\<Gamma> zero_current\"", "lemma web_flowD_current: \"web_flow \\<Gamma> f \\<Longrightarrow> current \\<Gamma> f\"", "lemma web_flowD_KIR: \"\\<lbrakk> web_flow \\<Gamma> f; x \\<notin> A \\<Gamma>; x \\<notin> B \\<Gamma> \\<rbrakk> \\<Longrightarrow> KIR f x\"", "lemma SAT_0 [simp]: \"SAT \\<Gamma> zero_current = A \\<Gamma> \\<union> {x. weight \\<Gamma> x \\<le> 0}\"", "lemma SAT_mono:\n  assumes \"\\<And>e. f e \\<le> g e\"\n  shows \"SAT \\<Gamma> f \\<subseteq> SAT \\<Gamma> g\"", "lemma SAT_Sup_upper: \"f \\<in> Y \\<Longrightarrow> SAT \\<Gamma> f \\<subseteq> SAT \\<Gamma> (Sup Y)\"", "lemma currentD_SAT:\n  assumes \"current \\<Gamma> f\"\n  shows \"x \\<in> SAT \\<Gamma> f \\<longleftrightarrow> x \\<in> A \\<Gamma> \\<or> d_IN f x = weight \\<Gamma> x\"", "lemma separating_networkI [intro?]:\n  \"(\\<And>p. path \\<Delta> (source \\<Delta>) p (sink \\<Delta>) \\<Longrightarrow> (\\<exists>z \\<in> set p. z \\<in> S) \\<or> source \\<Delta> \\<in> S)\n  \\<Longrightarrow> separating_network \\<Delta> S\"", "lemma separatingD:\n  \"\\<And>A B. \\<lbrakk> separating_gen G A B S; path G x p y; x \\<in> A; y \\<in> B \\<rbrakk> \\<Longrightarrow> (\\<exists>z \\<in> set p. z \\<in> S) \\<or> x \\<in> S\"", "lemma separating_left [simp]: \"\\<And>A B. A \\<subseteq> A' \\<Longrightarrow> separating_gen \\<Gamma> A B A'\"", "lemma separating_weakening:\n  \"\\<And>A B. \\<lbrakk> separating_gen G A B S; S \\<subseteq> S' \\<rbrakk> \\<Longrightarrow> separating_gen G A B S'\"", "lemma essential_weight_update [simp]:\n  \"essential (weight_update f G) = essential G\"", "lemma not_essentialD:\n  \"\\<And>B. \\<lbrakk> \\<not> essential G B S x; path G x p y; y \\<in> B \\<rbrakk> \\<Longrightarrow> x \\<noteq> y \\<and> (\\<exists>z\\<in>set p. z \\<noteq> x \\<and> z \\<in> S)\"", "lemma essentialE [elim?, consumes 1, case_names essential, cases pred: essential]:\n  \"\\<And>B. \\<lbrakk> essential G B S x; \\<And>p y. \\<lbrakk> path G x p y; y \\<in> B; \\<And>z. \\<lbrakk> x \\<noteq> y; z \\<in> set p \\<rbrakk> \\<Longrightarrow> z = x \\<or> z \\<notin> S \\<rbrakk> \\<Longrightarrow> thesis \\<rbrakk> \\<Longrightarrow> thesis\"", "lemma essentialI [intro?]:\n  \"\\<And>B. \\<lbrakk> path G x p y; y \\<in> B; \\<And>z. \\<lbrakk> x \\<noteq> y; z \\<in> set p \\<rbrakk> \\<Longrightarrow> z = x \\<or> z \\<notin> S \\<rbrakk> \\<Longrightarrow> essential G B S x\"", "lemma essential_vertex: \"\\<And>B. \\<lbrakk> essential G B S x; x \\<notin> B \\<rbrakk> \\<Longrightarrow>vertex G x\"", "lemma essential_BI: \"\\<And>B. x \\<in> B \\<Longrightarrow> essential G B S x\"", "lemma \\<E>_E [elim?, consumes 1, case_names \\<E>, cases set: essential_web]:\n  fixes \\<Gamma> (structure)\n  assumes \"x \\<in> \\<E> S\"\n  obtains p y where \"path \\<Gamma> x p y\" \"y \\<in> B \\<Gamma>\" \"\\<And>z. \\<lbrakk> x \\<noteq> y; z \\<in> set p \\<rbrakk> \\<Longrightarrow> z = x \\<or> z \\<notin> S\"", "lemma essential_mono: \"\\<And>B. \\<lbrakk> essential G B S x; S' \\<subseteq> S \\<rbrakk> \\<Longrightarrow> essential G B S' x\"", "lemma separating_essential: \\<comment> \\<open>Lem. 3.4 (cf. Lem. 2.14 in [5])\\<close>\n  fixes G A B S\n  assumes \"separating_gen G A B S\"\n  shows \"separating_gen G A B {x\\<in>S. essential G B S x}\" (is \"separating_gen _ _ _ ?E\")", "lemma roofedI [intro?]:\n  \"\\<And>B. (\\<And>p y. \\<lbrakk> path G x p y; y \\<in> B \\<rbrakk> \\<Longrightarrow> (\\<exists>z\\<in>set p. z \\<in> S) \\<or> x \\<in> S) \\<Longrightarrow> x \\<in> roofed_gen G B S\"", "lemma not_roofedE: fixes B\n  assumes \"x \\<notin> roofed_gen G B S\"\n  obtains p y where \"path G x p y\" \"y \\<in> B\" \"\\<And>z. z \\<in> set (x # p) \\<Longrightarrow> z \\<notin> S\"", "lemma roofed_greater: \"\\<And>B. S \\<subseteq> roofed_gen G B S\"", "lemma roofed_greaterI: \"\\<And>B. x \\<in> S \\<Longrightarrow> x \\<in> roofed_gen G B S\"", "lemma roofed_mono: \"\\<And>B. S \\<subseteq> S' \\<Longrightarrow> roofed_gen G B S \\<subseteq> roofed_gen G B S'\"", "lemma in_roofed_mono: \"\\<And>B. \\<lbrakk> x \\<in> roofed_gen G B S; S \\<subseteq> S' \\<rbrakk> \\<Longrightarrow> x \\<in> roofed_gen G B S'\"", "lemma roofedD: \"\\<And>B. \\<lbrakk> x \\<in> roofed_gen G B S; path G x p y; y \\<in> B \\<rbrakk> \\<Longrightarrow> (\\<exists>z\\<in>set p. z \\<in> S) \\<or> x \\<in> S\"", "lemma separating_RF_A:\n  fixes A B\n  assumes \"separating_gen G A B X\"\n  shows \"A \\<subseteq> roofed_gen G B X\"", "lemma roofed_idem: fixes B shows \"roofed_gen G B (roofed_gen G B S) = roofed_gen G B S\"", "lemma in_roofed_mono': \"\\<And>B. \\<lbrakk> x \\<in> roofed_gen G B S; S \\<subseteq> roofed_gen G B S' \\<rbrakk> \\<Longrightarrow> x \\<in> roofed_gen G B S'\"", "lemma roofed_mono': \"\\<And>B. S \\<subseteq> roofed_gen G B S' \\<Longrightarrow> roofed_gen G B S \\<subseteq> roofed_gen G B S'\"", "lemma roofed_idem_Un1: fixes B shows \"roofed_gen G B (roofed_gen G B S \\<union> T) = roofed_gen G B (S \\<union> T)\"", "lemma roofed_UN: fixes A B\n  shows \"roofed_gen G B (\\<Union>i\\<in>A. roofed_gen G B (X i)) = roofed_gen G B (\\<Union>i\\<in>A. X i)\" (is \"?lhs = ?rhs\")", "lemma RF_essential: fixes \\<Gamma> (structure) shows \"RF (\\<E> S) = RF S\"", "lemma essentialE_RF:\n  fixes \\<Gamma> (structure) and B\n  assumes \"essential \\<Gamma> B S x\"\n  obtains p y where \"path \\<Gamma> x p y\" \"y \\<in> B\" \"distinct (x # p)\" \"\\<And>z. z \\<in> set p \\<Longrightarrow> z \\<notin> roofed_gen \\<Gamma> B S\"", "lemma \\<E>_E_RF:\n  fixes \\<Gamma> (structure)\n  assumes \"x \\<in> \\<E> S\"\n  obtains p y where \"path \\<Gamma> x p y\" \"y \\<in> B \\<Gamma>\" \"distinct (x # p)\" \"\\<And>z. z \\<in> set p \\<Longrightarrow> z \\<notin> RF S\"", "lemma in_roofed_essentialD:\n  fixes \\<Gamma> (structure)\n  assumes RF: \"x \\<in> RF S\"\n  and ess: \"essential \\<Gamma> (B \\<Gamma>) S x\"\n  shows \"x \\<in> S\"", "lemma separating_RF: fixes \\<Gamma> (structure) shows \"separating \\<Gamma> (RF S) \\<longleftrightarrow> separating \\<Gamma> S\"", "lemma roofed_circI: fixes \\<Gamma> (structure) shows\n  \"\\<lbrakk> x \\<in> RF T; x \\<in> T \\<Longrightarrow> \\<not> essential \\<Gamma> (B \\<Gamma>) T x \\<rbrakk> \\<Longrightarrow> x \\<in> RF\\<^sup>\\<circ> T\"", "lemma roofed_circE:\n  fixes \\<Gamma> (structure)\n  assumes \"x \\<in> RF\\<^sup>\\<circ> T\"\n  obtains \"x \\<in> RF T\" \"\\<not> essential \\<Gamma> (B \\<Gamma>) T x\"", "lemma \\<E>_\\<E>: fixes \\<Gamma> (structure) shows \"\\<E> (\\<E> S) = \\<E> S\"", "lemma roofed_circ_essential: fixes \\<Gamma> (structure) shows \"RF\\<^sup>\\<circ> (\\<E> S) = RF\\<^sup>\\<circ> S\"", "lemma essential_RF: fixes B\n  shows \"essential G B (roofed_gen G B S) = essential G B S\"  (is \"essential _ _ ?RF = _\")", "lemma \\<E>_RF: fixes \\<Gamma> (structure) shows \"\\<E> (RF S) = \\<E> S\"", "lemma essential_\\<E>: fixes \\<Gamma> (structure) shows \"essential \\<Gamma> (B \\<Gamma>) (\\<E> S) = essential \\<Gamma> (B \\<Gamma>) S\"", "lemma RF_in_B: fixes \\<Gamma> (structure) shows \"x \\<in> B \\<Gamma> \\<Longrightarrow> x \\<in> RF S \\<longleftrightarrow> x \\<in> S\"", "lemma RF_circ_edge_forward:\n  fixes \\<Gamma> (structure)\n  assumes x: \"x \\<in> RF\\<^sup>\\<circ> S\"\n  and edge: \"edge \\<Gamma> x y\"\n  shows \"y \\<in> RF S\"", "lemma wave_0 [simp]: \"wave \\<Gamma> zero_current\"", "lemma waveD_separating: \"wave \\<Gamma> f \\<Longrightarrow> separating \\<Gamma> (TER\\<^bsub>\\<Gamma>\\<^esub> f)\"", "lemma waveD_OUT: \"\\<lbrakk> wave \\<Gamma> f; x \\<notin> RF\\<^bsub>\\<Gamma>\\<^esub> (TER\\<^bsub>\\<Gamma>\\<^esub> f) \\<rbrakk> \\<Longrightarrow> d_OUT f x = 0\"", "lemma wave_A_in_RF: fixes \\<Gamma> (structure)\n  shows \"\\<lbrakk> wave \\<Gamma> f; x \\<in> A \\<Gamma> \\<rbrakk> \\<Longrightarrow> x \\<in> RF (TER f)\"", "lemma wave_not_RF_IN_zero:\n  fixes \\<Gamma> (structure)\n  assumes f: \"current \\<Gamma> f\"\n  and w: \"wave \\<Gamma> f\"\n  and x: \"x \\<notin> RF (TER f)\"\n  shows \"d_IN f x = 0\"", "lemma current_Sup:\n  fixes \\<Gamma> (structure)\n  assumes chain: \"Complete_Partial_Order.chain (\\<le>) Y\"\n  and Y: \"Y \\<noteq> {}\"\n  and current: \"\\<And>f. f \\<in> Y \\<Longrightarrow> current \\<Gamma> f\"\n  and countable [simp]: \"countable (support_flow (Sup Y))\"\n  shows \"current \\<Gamma> (Sup Y)\"", "lemma wave_lub: \\<comment> \\<open>Lemma 4.3\\<close>\n  fixes \\<Gamma> (structure)\n  assumes chain: \"Complete_Partial_Order.chain (\\<le>) Y\"\n  and Y: \"Y \\<noteq> {}\"\n  and wave: \"\\<And>f. f \\<in> Y \\<Longrightarrow> wave \\<Gamma> f\"\n  and countable [simp]: \"countable (support_flow (Sup Y))\"\n  shows \"wave \\<Gamma> (Sup Y)\"", "lemma ex_maximal_wave: \\<comment> \\<open>Corollary 4.4\\<close>\n  fixes \\<Gamma> (structure)\n  assumes countable: \"countable \\<^bold>E\"\n  shows \"\\<exists>f. current \\<Gamma> f \\<and> wave \\<Gamma> f \\<and> (\\<forall>w. current \\<Gamma> w \\<and> wave \\<Gamma> w \\<and> f \\<le> w \\<longrightarrow> f = w)\"", "lemma essential_leI:\n  fixes \\<Gamma> (structure)\n  assumes g: \"current \\<Gamma> g\" and w: \"wave \\<Gamma> g\"\n  and le: \"\\<And>e. f e \\<le> g e\"\n  and x: \"x \\<in> \\<E> (TER g)\"\n  shows \"essential \\<Gamma> (B \\<Gamma>) (TER f) x\"", "lemma essential_eq_leI:\n  fixes \\<Gamma> (structure)\n  assumes g: \"current \\<Gamma> g\" and w: \"wave \\<Gamma> g\"\n  and le: \"\\<And>e. f e \\<le> g e\"\n  and subset: \"\\<E> (TER g) \\<subseteq> TER f\"\n  shows \"\\<E> (TER f) = \\<E> (TER g)\"", "lemma hindrance_into_hindrance_by:\n  assumes \"hindrance \\<Gamma> f\"\n  shows \"\\<exists>\\<epsilon>>0. hindrance_by \\<Gamma> f \\<epsilon>\"", "lemma hindrance_by_into_hindrance: \"hindrance_by \\<Gamma> f \\<epsilon> \\<Longrightarrow> hindrance \\<Gamma> f\"", "lemma hindrance_conv_hindrance_by: \"hindrance \\<Gamma> f \\<longleftrightarrow> (\\<exists>\\<epsilon>>0. hindrance_by \\<Gamma> f \\<epsilon>)\"", "lemma hindered_into_hindered_by: \"hindered \\<Gamma> \\<Longrightarrow> \\<exists>\\<epsilon>>0. hindered_by \\<Gamma> \\<epsilon>\"", "lemma hindered_by_into_hindered: \"hindered_by \\<Gamma> \\<epsilon> \\<Longrightarrow> hindered \\<Gamma>\"", "lemma hindered_conv_hindered_by: \"hindered \\<Gamma> \\<longleftrightarrow> (\\<exists>\\<epsilon>>0. hindered_by \\<Gamma> \\<epsilon>)\"", "lemma looseD_hindrance: \"loose \\<Gamma> \\<Longrightarrow> \\<not> hindrance \\<Gamma> zero_current\"", "lemma looseD_wave:\n  \"\\<lbrakk> loose \\<Gamma>; current \\<Gamma> f; wave \\<Gamma> f \\<rbrakk> \\<Longrightarrow> f = zero_current\"", "lemma loose_unhindered:\n  fixes \\<Gamma> (structure)\n  assumes \"loose \\<Gamma>\"\n  shows \"\\<not> hindered \\<Gamma>\"", "lemma essential_eq: \"essential \\<Gamma> = essential \\<Gamma>'\"", "lemma TER_eq: \"TER\\<^bsub>\\<Gamma>\\<^esub> f = TER\\<^bsub>\\<Gamma>'\\<^esub> f\"", "lemma separating_eq: \"separating_gen \\<Gamma> = separating_gen \\<Gamma>'\"", "lemma roofed_eq: \"\\<And>B. roofed_gen \\<Gamma> B S = roofed_gen \\<Gamma>' B S\"", "lemma wave_eq_web: \\<comment> \\<open>Observation 4.6\\<close>\n  \"wave \\<Gamma> f \\<longleftrightarrow> wave \\<Gamma>' f\"", "lemma current_mono_web: \"current \\<Gamma>' f \\<Longrightarrow> current \\<Gamma> f\"", "lemma hindrance_mono_web: \"hindrance \\<Gamma>' f \\<Longrightarrow> hindrance \\<Gamma> f\"", "lemma hindered_mono_web: \"hindered \\<Gamma>' \\<Longrightarrow> hindered \\<Gamma>\"", "lemma orthogonal_currentD_SAT: \"\\<lbrakk> orthogonal_current \\<Gamma> f S; x \\<in> S \\<rbrakk> \\<Longrightarrow> x \\<in> SAT \\<Gamma> f\"", "lemma orthogonal_currentD_A: \"\\<lbrakk> orthogonal_current \\<Gamma> f S; x \\<in> S; x \\<in> A \\<Gamma>; x \\<notin> B \\<Gamma> \\<rbrakk> \\<Longrightarrow> d_OUT f x = weight \\<Gamma> x\"", "lemma orthogonal_currentD_in: \"\\<lbrakk> orthogonal_current \\<Gamma> f S; v \\<in> RF\\<^bsub>\\<Gamma>\\<^esub> S; u \\<notin> RF\\<^sup>\\<circ>\\<^bsub>\\<Gamma>\\<^esub> S \\<rbrakk> \\<Longrightarrow> f (u, v) = 0\"", "lemma linkageD: \"\\<lbrakk> linkage \\<Gamma> f; x \\<in> A \\<Gamma> \\<rbrakk> \\<Longrightarrow> d_OUT f x = weight \\<Gamma> x\"", "lemma assumes \"trimming g\"\n  shows trimmingD_current: \"current \\<Gamma> g\"\n  and trimmingD_wave: \"wave \\<Gamma> g\"\n  and trimmingD_le: \"\\<And>e. g e \\<le> f e\"\n  and trimmingD_KIR: \"\\<lbrakk> x \\<in> RF\\<^sup>\\<circ> (TER f); x \\<notin> A \\<Gamma> \\<rbrakk> \\<Longrightarrow> KIR g x\"\n  and trimmingD_\\<E>: \"\\<E> (TER g) - A \\<Gamma> = \\<E> (TER f) - A \\<Gamma>\"", "lemma ex_trimming: \\<comment> \\<open>Lemma 4.8\\<close>\n  assumes f: \"current \\<Gamma> f\"\n  and w: \"wave \\<Gamma> f\"\n  and countable: \"countable \\<^bold>E\"\n  and weight_finite: \"\\<And>x. weight \\<Gamma> x \\<noteq> \\<top>\"\n  shows \"\\<exists>g. trimming g\"", "lemma trimming_\\<E>:\n  fixes \\<Gamma> (structure)\n  assumes w: \"wave \\<Gamma> f\" and trimming: \"trimming \\<Gamma> f g\"\n  shows \"\\<E> (TER f) = \\<E> (TER g)\"", "lemma quotient_web_sel [simp]:\n  fixes \\<Gamma> (structure) shows\n  \"edge (quotient_web \\<Gamma> f) x y \\<longleftrightarrow> edge \\<Gamma> x y \\<and> x \\<notin> RF\\<^sup>\\<circ> (TER f) \\<and> y \\<notin> RF (TER f)\"\n  \"weight (quotient_web \\<Gamma> f) x = (if x \\<in> RF\\<^sup>\\<circ> (TER f) \\<or> x \\<in> TER\\<^bsub>\\<Gamma>\\<^esub> f \\<inter> B \\<Gamma> then 0 else weight \\<Gamma> x)\"\n  \"A (quotient_web \\<Gamma> f) = \\<E> (TER f)- (B \\<Gamma> - A \\<Gamma>)\"\n  \"B (quotient_web \\<Gamma> f) = B \\<Gamma>\"\n  \"web.more (quotient_web \\<Gamma> f) = web.more \\<Gamma>\"", "lemma vertex_quotient_webD: fixes \\<Gamma> (structure) shows\n  \"vertex (quotient_web \\<Gamma> f) x \\<Longrightarrow> vertex \\<Gamma> x \\<and> x \\<notin> RF\\<^sup>\\<circ> (TER f)\"", "lemma path_quotient_web:\n  fixes \\<Gamma> (structure)\n  assumes \"path \\<Gamma> x p y\"\n  and \"x \\<notin> RF\\<^sup>\\<circ> (TER f)\"\n  and \"\\<And>z. z \\<in> set p \\<Longrightarrow> z \\<notin> RF (TER f)\"\n  shows \"path (quotient_web \\<Gamma> f) x p y\"", "lemma restrict_current_simps [simp]: fixes \\<Gamma> (structure) shows\n  \"(g \\<upharpoonleft> \\<Gamma> / f) (x, y) = (g (x, y) * indicator (- RF\\<^sup>\\<circ> (TER f)) x * indicator (- RF (TER f)) y)\"", "lemma d_OUT_restrict_current_outside: fixes \\<Gamma> (structure) shows\n  \"x \\<in> RF\\<^sup>\\<circ> (TER f) \\<Longrightarrow> d_OUT (g \\<upharpoonleft> \\<Gamma> / f) x = 0\"", "lemma d_IN_restrict_current_outside: fixes \\<Gamma> (structure) shows\n  \"x \\<in> RF (TER f) \\<Longrightarrow> d_IN (g \\<upharpoonleft> \\<Gamma> / f) x = 0\"", "lemma restrict_current_le: \"(g \\<upharpoonleft> \\<Gamma> / f) e \\<le> g e\"", "lemma d_OUT_restrict_current_le: \"d_OUT (g \\<upharpoonleft> \\<Gamma> / f) x \\<le> d_OUT g x\"", "lemma d_IN_restrict_current_le: \"d_IN (g \\<upharpoonleft> \\<Gamma> / f) x \\<le> d_IN g x\"", "lemma restrict_current_IN_not_RF:\n  fixes \\<Gamma> (structure)\n  assumes g: \"current \\<Gamma> g\"\n  and x: \"x \\<notin> RF (TER f)\"\n  shows \"d_IN (g \\<upharpoonleft> \\<Gamma> / f) x = d_IN g x\"", "lemma restrict_current_IN_A:\n  \"a \\<in> A (quotient_web \\<Gamma> f) \\<Longrightarrow> d_IN (g \\<upharpoonleft> \\<Gamma> / f) a = 0\"", "lemma restrict_current_nonneg: \"0 \\<le> g e \\<Longrightarrow> 0 \\<le> (g \\<upharpoonleft> \\<Gamma> / f) e\"", "lemma in_SINK_restrict_current: \"x \\<in> SINK g \\<Longrightarrow> x \\<in> SINK (g \\<upharpoonleft> \\<Gamma> / f)\"", "lemma SAT_restrict_current:\n  fixes \\<Gamma> (structure)\n  assumes f: \"current \\<Gamma> f\"\n  and g: \"current \\<Gamma> g\"\n  shows \"SAT (quotient_web \\<Gamma> f) (g \\<upharpoonleft> \\<Gamma> / f) = RF (TER f) \\<union> (SAT \\<Gamma> g - A \\<Gamma>)\" (is \"SAT ?\\<Gamma> ?g = ?rhs\")", "lemma current_restrict_current:\n  fixes \\<Gamma> (structure)\n  assumes w: \"wave \\<Gamma> f\"\n  and g: \"current \\<Gamma> g\"\n  shows \"current (quotient_web \\<Gamma> f) (g \\<upharpoonleft> \\<Gamma> / f)\" (is \"current ?\\<Gamma> ?g\")", "lemma TER_restrict_current:\n  fixes \\<Gamma> (structure)\n  assumes f: \"current \\<Gamma> f\"\n  and w: \"wave \\<Gamma> f\"\n  and g: \"current \\<Gamma> g\"\n  shows \"TER g \\<subseteq> TER\\<^bsub>quotient_web \\<Gamma> f\\<^esub> (g \\<upharpoonleft> \\<Gamma> / f)\" (is \"_ \\<subseteq> ?TER\" is \"_ \\<subseteq> TER\\<^bsub>?\\<Gamma>\\<^esub> ?g\")", "lemma wave_restrict_current:\n  fixes \\<Gamma> (structure)\n  assumes f: \"current \\<Gamma> f\"\n  and w: \"wave \\<Gamma> f\"\n  and g: \"current \\<Gamma> g\"\n  and w': \"wave \\<Gamma> g\"\n  shows \"wave (quotient_web \\<Gamma> f) (g \\<upharpoonleft> \\<Gamma> / f)\" (is \"wave ?\\<Gamma> ?g\")", "lemma plus_current_simps [simp]: \"plus_current f g e = f e + g e\"", "lemma plus_zero_current [simp]: \"plus_current f zero_current = f\"", "lemma support_flow_plus_current: \"support_flow (plus_current f g) \\<subseteq> support_flow f \\<union> support_flow g\"", "lemma OUT_plus_current: \"d_OUT (plus_current f g) x = (if x \\<in> RF\\<^sup>\\<circ> (TER f) then d_OUT f x else d_OUT g x)\" (is \"d_OUT ?g _ = _\")", "lemma IN_plus_current: \"d_IN (plus_current f g) x = (if x \\<in> RF (TER f) then d_IN f x else d_IN g x)\" (is \"d_IN ?g _ = _\")", "lemma in_TER_plus_current:\n  assumes RF: \"x \\<notin> RF\\<^sup>\\<circ> (TER f)\"\n  and x: \"x \\<in> TER\\<^bsub>quotient_web \\<Gamma> f\\<^esub> g\" (is \"_ \\<in> ?TER _\")\n  shows \"x \\<in> TER (plus_current f g)\"  (is \"_ \\<in> TER ?g\")", "lemma current_plus_current: \"current \\<Gamma> (plus_current f g)\" (is \"current _ ?g\")", "lemma separating_TER_plus_current:\n  assumes x: \"x \\<in> RF (TER f)\" and y: \"y \\<in> B \\<Gamma>\" and p: \"path \\<Gamma> x p y\"\n  shows \"(\\<exists>z\\<in>set p. z \\<in> TER (plus_current f g)) \\<or> x \\<in> TER (plus_current f g)\" (is \"_ \\<or> _ \\<in> TER ?g\")", "lemma wave_plus_current: \"wave \\<Gamma> (plus_current f g)\" (is \"wave _ ?g\")", "lemma loose_quotient_web:\n  fixes \\<Gamma> :: \"('v, 'more) web_scheme\" (structure)\n  assumes weight_finite: \"\\<And>x. weight \\<Gamma> x \\<noteq> \\<top>\"\n  and f: \"current \\<Gamma> f\"\n  and w: \"wave \\<Gamma> f\"\n  and maximal: \"\\<And>w. \\<lbrakk> current \\<Gamma> w; wave \\<Gamma> w; f \\<le> w \\<rbrakk> \\<Longrightarrow> f = w\"\n  shows \"loose (quotient_web \\<Gamma> f)\" (is \"loose ?\\<Gamma>\")", "lemma quotient_web_trimming:\n  fixes \\<Gamma> (structure)\n  assumes w: \"wave \\<Gamma> f\"\n  and trimming: \"trimming \\<Gamma> f g\"\n  shows \"quotient_web \\<Gamma> f = quotient_web \\<Gamma> g\" (is \"?lhs = ?rhs\")", "lemma web_weight_update:\n  assumes \"\\<And>x. \\<not> vertex \\<Gamma> x \\<Longrightarrow> w x = 0\"\n  and \"\\<And>x. w x \\<noteq> \\<top>\"\n  shows \"web (\\<Gamma>\\<lparr>weight := w\\<rparr>)\"", "lemma currentI [intro?]:\n  assumes \"\\<And>x. d_OUT f x \\<le> weight \\<Gamma> x\"\n  and \"\\<And>x. d_IN f x \\<le> weight \\<Gamma> x\"\n  and OUT_IN: \"\\<And>x. \\<lbrakk> x \\<notin> A \\<Gamma>; x \\<notin> B \\<Gamma> \\<rbrakk> \\<Longrightarrow> d_OUT f x \\<le> d_IN f x\"\n  and outside: \"\\<And>e. e \\<notin> \\<^bold>E \\<Longrightarrow> f e = 0\"\n  shows \"current \\<Gamma> f\"", "lemma currentD_finite_IN:\n  assumes f: \"current \\<Gamma> f\"\n  shows \"d_IN f x \\<noteq> \\<top>\"", "lemma currentD_finite_OUT:\n  assumes f: \"current \\<Gamma> f\"\n  shows \"d_OUT f x \\<noteq> \\<top>\"", "lemma currentD_finite:\n  assumes f: \"current \\<Gamma> f\"\n  shows \"f e \\<noteq> \\<top>\"", "lemma web_quotient_web: \"web (quotient_web \\<Gamma> f)\" (is \"web ?\\<Gamma>\")", "lemma countable_V [simp]: \"countable \\<^bold>V\"", "lemma countable_web_quotient_web: \"countable_web (quotient_web \\<Gamma> f)\" (is \"countable_web ?\\<Gamma>\")", "lemma minus_web_sel [simp]:\n  \"edge (\\<Gamma> \\<ominus> f) = edge \\<Gamma>\"\n  \"weight (\\<Gamma> \\<ominus> f) x = (if x \\<in> A \\<Gamma> then weight \\<Gamma> x - d_OUT f x else weight \\<Gamma> x + d_OUT f x - d_IN f x)\"\n  \"A (\\<Gamma> \\<ominus> f) = A \\<Gamma>\"\n  \"B (\\<Gamma> \\<ominus> f) = B \\<Gamma>\"\n  \"\\<^bold>V\\<^bsub>\\<Gamma> \\<ominus> f\\<^esub> = \\<^bold>V\\<^bsub>\\<Gamma>\\<^esub>\"\n  \"\\<^bold>E\\<^bsub>\\<Gamma> \\<ominus> f\\<^esub> = \\<^bold>E\\<^bsub>\\<Gamma>\\<^esub>\"\n  \"web.more (\\<Gamma> \\<ominus> f) = web.more \\<Gamma>\"", "lemma vertex_minus_web [simp]: \"vertex (\\<Gamma> \\<ominus> f) = vertex \\<Gamma>\"", "lemma roofed_gen_minus_web [simp]: \"roofed_gen (\\<Gamma> \\<ominus> f) = roofed_gen \\<Gamma>\"", "lemma minus_zero_current [simp]: \"\\<Gamma> \\<ominus> zero_current = \\<Gamma>\"", "lemma (in web) web_minus_web:\n  assumes f: \"current \\<Gamma> f\"\n  shows \"web (\\<Gamma> \\<ominus> f)\"", "lemma not_vertex: \"\\<lbrakk> x \\<notin> A \\<Gamma>; x \\<notin> B \\<Gamma> \\<rbrakk> \\<Longrightarrow> \\<not> vertex \\<Gamma> x\"", "lemma no_loop: \"\\<not> edge \\<Gamma> x x\"", "lemma edge_antiparallel: \"edge \\<Gamma> x y \\<Longrightarrow> \\<not> edge \\<Gamma> y x\"", "lemma A_in: \"x \\<in> A \\<Gamma> \\<Longrightarrow> \\<not> edge \\<Gamma> y x\"", "lemma B_out: \"x \\<in> B \\<Gamma> \\<Longrightarrow> \\<not> edge \\<Gamma> x y\"", "lemma currentD_OUT':\n  assumes f: \"current \\<Gamma> f\"\n  and x: \"x \\<notin> A \\<Gamma>\"\n  shows \"d_OUT f x = 0\"", "lemma currentD_IN':\n  assumes f: \"current \\<Gamma> f\"\n  and x: \"x \\<notin> B \\<Gamma>\"\n  shows \"d_IN f x = 0\"", "lemma current_bipartiteI [intro?]:\n  assumes OUT: \"\\<And>x. d_OUT f x \\<le> weight \\<Gamma> x\"\n  and IN: \"\\<And>x. d_IN f x \\<le> weight \\<Gamma> x\"\n  and outside: \"\\<And>e. e \\<notin> \\<^bold>E \\<Longrightarrow> f e = 0\"\n  shows \"current \\<Gamma> f\"", "lemma wave_bipartiteI [intro?]:\n  assumes sep: \"separating \\<Gamma> (TER f)\"\n  and f: \"current \\<Gamma> f\"\n  shows \"wave \\<Gamma> f\"", "lemma web_flow_iff: \"web_flow \\<Gamma> f \\<longleftrightarrow> current \\<Gamma> f\""], "translations": [["", "lemma vertex_weight_update [simp]: \"vertex (weight_update f \\<Gamma>) = vertex \\<Gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vertex (weight_update f \\<Gamma>) = vertex \\<Gamma>", "by(simp add: vertex_def fun_eq_iff)"], ["", "type_synonym 'v current = \"'v edge \\<Rightarrow> ennreal\""], ["", "inductive current :: \"('v, 'more) web_scheme \\<Rightarrow> 'v current \\<Rightarrow> bool\"\n  for \\<Gamma> f\nwhere\n  current:\n  \"\\<lbrakk> \\<And>x. d_OUT f x \\<le> weight \\<Gamma> x;\n     \\<And>x. d_IN f x \\<le> weight \\<Gamma> x;\n     \\<And>x. x \\<notin> A \\<Gamma> \\<Longrightarrow> d_OUT f x \\<le> d_IN f x;\n     \\<And>a. a \\<in> A \\<Gamma> \\<Longrightarrow> d_IN f a = 0;\n     \\<And>b. b \\<in> B \\<Gamma> \\<Longrightarrow> d_OUT f b = 0;\n     \\<And>e. e \\<notin> \\<^bold>E\\<^bsub>\\<Gamma>\\<^esub> \\<Longrightarrow> f e = 0 \\<rbrakk>\n  \\<Longrightarrow> current \\<Gamma> f\""], ["", "lemma currentD_weight_OUT: \"current \\<Gamma> f \\<Longrightarrow> d_OUT f x \\<le> weight \\<Gamma> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. current \\<Gamma> f \\<Longrightarrow> d_OUT f x \\<le> weight \\<Gamma> x", "by(simp add: current.simps)"], ["", "lemma currentD_weight_IN: \"current \\<Gamma> f \\<Longrightarrow> d_IN f x \\<le> weight \\<Gamma> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. current \\<Gamma> f \\<Longrightarrow> d_IN f x \\<le> weight \\<Gamma> x", "by(simp add: current.simps)"], ["", "lemma currentD_OUT_IN: \"\\<lbrakk> current \\<Gamma> f; x \\<notin> A \\<Gamma> \\<rbrakk> \\<Longrightarrow> d_OUT f x \\<le> d_IN f x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>current \\<Gamma> f; x \\<notin> A \\<Gamma>\\<rbrakk>\n    \\<Longrightarrow> d_OUT f x \\<le> d_IN f x", "by(simp add: current.simps)"], ["", "lemma currentD_IN: \"\\<lbrakk> current \\<Gamma> f; a \\<in> A \\<Gamma> \\<rbrakk> \\<Longrightarrow> d_IN f a = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>current \\<Gamma> f; a \\<in> A \\<Gamma>\\<rbrakk>\n    \\<Longrightarrow> d_IN f a = 0", "by(simp add: current.simps)"], ["", "lemma currentD_OUT: \"\\<lbrakk> current \\<Gamma> f; b \\<in> B \\<Gamma> \\<rbrakk> \\<Longrightarrow> d_OUT f b = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>current \\<Gamma> f; b \\<in> B \\<Gamma>\\<rbrakk>\n    \\<Longrightarrow> d_OUT f b = 0", "by(simp add: current.simps)"], ["", "lemma currentD_outside: \"\\<lbrakk> current \\<Gamma> f; \\<not> edge \\<Gamma> x y \\<rbrakk> \\<Longrightarrow> f (x, y) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>current \\<Gamma> f; \\<not> edge \\<Gamma> x y\\<rbrakk>\n    \\<Longrightarrow> f (x, y) = 0", "by(blast elim: current.cases)"], ["", "lemma currentD_outside': \"\\<lbrakk> current \\<Gamma> f; e \\<notin> \\<^bold>E\\<^bsub>\\<Gamma>\\<^esub> \\<rbrakk> \\<Longrightarrow> f e = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>current \\<Gamma> f;\n     e \\<notin> \\<^bold>E\\<^bsub>\\<Gamma>\\<^esub>\\<rbrakk>\n    \\<Longrightarrow> f e = 0", "by(blast elim: current.cases)"], ["", "lemma currentD_OUT_eq_0:\n  assumes \"current \\<Gamma> f\"\n  shows \"d_OUT f x = 0 \\<longleftrightarrow> (\\<forall>y. f (x, y) = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (d_OUT f x = 0) = (\\<forall>y. f (x, y) = 0)", "by(simp add: d_OUT_def nn_integral_0_iff emeasure_count_space_eq_0)"], ["", "lemma currentD_IN_eq_0:\n  assumes \"current \\<Gamma> f\"\n  shows \"d_IN f x = 0 \\<longleftrightarrow> (\\<forall>y. f (y, x) = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (d_IN f x = 0) = (\\<forall>y. f (y, x) = 0)", "by(simp add: d_IN_def nn_integral_0_iff emeasure_count_space_eq_0)"], ["", "lemma current_support_flow:\n  fixes \\<Gamma> (structure)\n  assumes \"current \\<Gamma> f\"\n  shows \"support_flow f \\<subseteq> \\<^bold>E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. support_flow f \\<subseteq> \\<^bold>E", "using currentD_outside[OF assms]"], ["proof (prove)\nusing this:\n  \\<not> edge \\<Gamma> ?x ?y \\<Longrightarrow> f (?x, ?y) = 0\n\ngoal (1 subgoal):\n 1. support_flow f \\<subseteq> \\<^bold>E", "by(auto simp add: support_flow.simps intro: ccontr)"], ["", "lemma currentD_outside_IN: \"\\<lbrakk> current \\<Gamma> f; x \\<notin> \\<^bold>V\\<^bsub>\\<Gamma>\\<^esub> \\<rbrakk> \\<Longrightarrow> d_IN f x = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>current \\<Gamma> f;\n     x \\<notin> \\<^bold>V\\<^bsub>\\<Gamma>\\<^esub>\\<rbrakk>\n    \\<Longrightarrow> d_IN f x = 0", "by(auto simp add: d_IN_def vertex_def nn_integral_0_iff  AE_count_space emeasure_count_space_eq_0 dest: currentD_outside)"], ["", "lemma currentD_outside_OUT: \"\\<lbrakk> current \\<Gamma> f; x \\<notin> \\<^bold>V\\<^bsub>\\<Gamma>\\<^esub> \\<rbrakk> \\<Longrightarrow> d_OUT f x = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>current \\<Gamma> f;\n     x \\<notin> \\<^bold>V\\<^bsub>\\<Gamma>\\<^esub>\\<rbrakk>\n    \\<Longrightarrow> d_OUT f x = 0", "by(auto simp add: d_OUT_def vertex_def nn_integral_0_iff  AE_count_space emeasure_count_space_eq_0 dest: currentD_outside)"], ["", "lemma currentD_weight_in: \"current \\<Gamma> h \\<Longrightarrow> h (x, y) \\<le> weight \\<Gamma> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. current \\<Gamma> h \\<Longrightarrow> h (x, y) \\<le> weight \\<Gamma> y", "by (metis order_trans d_IN_ge_point currentD_weight_IN)"], ["", "lemma currentD_weight_out: \"current \\<Gamma> h \\<Longrightarrow> h (x, y) \\<le> weight \\<Gamma> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. current \\<Gamma> h \\<Longrightarrow> h (x, y) \\<le> weight \\<Gamma> x", "by (metis order_trans d_OUT_ge_point currentD_weight_OUT)"], ["", "lemma current_leI:\n  fixes \\<Gamma> (structure)\n  assumes f: \"current \\<Gamma> f\"\n  and le: \"\\<And>e. g e \\<le> f e\"\n  and OUT_IN: \"\\<And>x. x \\<notin> A \\<Gamma> \\<Longrightarrow> d_OUT g x \\<le> d_IN g x\"\n  shows \"current \\<Gamma> g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. current \\<Gamma> g", "proof"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>x. d_OUT g x \\<le> weight \\<Gamma> x\n 2. \\<And>x. d_IN g x \\<le> weight \\<Gamma> x\n 3. \\<And>x.\n       x \\<notin> A \\<Gamma> \\<Longrightarrow> d_OUT g x \\<le> d_IN g x\n 4. \\<And>a. a \\<in> A \\<Gamma> \\<Longrightarrow> d_IN g a = 0\n 5. \\<And>b. b \\<in> B \\<Gamma> \\<Longrightarrow> d_OUT g b = 0\n 6. \\<And>e. e \\<notin> \\<^bold>E \\<Longrightarrow> g e = 0", "show \"d_OUT g x \\<le> weight \\<Gamma> x\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT g x \\<le> weight \\<Gamma> x", "using d_OUT_mono[of g x f, OF le] currentD_weight_OUT[OF f]"], ["proof (prove)\nusing this:\n  d_OUT g x \\<le> d_OUT f x\n  d_OUT f ?x \\<le> weight \\<Gamma> ?x\n\ngoal (1 subgoal):\n 1. d_OUT g x \\<le> weight \\<Gamma> x", "by(rule order_trans)"], ["proof (state)\nthis:\n  d_OUT g ?x \\<le> weight \\<Gamma> ?x\n\ngoal (5 subgoals):\n 1. \\<And>x. d_IN g x \\<le> weight \\<Gamma> x\n 2. \\<And>x.\n       x \\<notin> A \\<Gamma> \\<Longrightarrow> d_OUT g x \\<le> d_IN g x\n 3. \\<And>a. a \\<in> A \\<Gamma> \\<Longrightarrow> d_IN g a = 0\n 4. \\<And>b. b \\<in> B \\<Gamma> \\<Longrightarrow> d_OUT g b = 0\n 5. \\<And>e. e \\<notin> \\<^bold>E \\<Longrightarrow> g e = 0", "show \"d_IN g x \\<le> weight \\<Gamma> x\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN g x \\<le> weight \\<Gamma> x", "using d_IN_mono[of g x f, OF le] currentD_weight_IN[OF f]"], ["proof (prove)\nusing this:\n  d_IN g x \\<le> d_IN f x\n  d_IN f ?x \\<le> weight \\<Gamma> ?x\n\ngoal (1 subgoal):\n 1. d_IN g x \\<le> weight \\<Gamma> x", "by(rule order_trans)"], ["proof (state)\nthis:\n  d_IN g ?x \\<le> weight \\<Gamma> ?x\n\ngoal (4 subgoals):\n 1. \\<And>x.\n       x \\<notin> A \\<Gamma> \\<Longrightarrow> d_OUT g x \\<le> d_IN g x\n 2. \\<And>a. a \\<in> A \\<Gamma> \\<Longrightarrow> d_IN g a = 0\n 3. \\<And>b. b \\<in> B \\<Gamma> \\<Longrightarrow> d_OUT g b = 0\n 4. \\<And>e. e \\<notin> \\<^bold>E \\<Longrightarrow> g e = 0", "show \"d_IN g a = 0\" if \"a \\<in> A \\<Gamma>\" for a"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN g a = 0", "using d_IN_mono[of g a f, OF le] currentD_IN[OF f that]"], ["proof (prove)\nusing this:\n  d_IN g a \\<le> d_IN f a\n  d_IN f a = 0\n\ngoal (1 subgoal):\n 1. d_IN g a = 0", "by auto"], ["proof (state)\nthis:\n  ?a \\<in> A \\<Gamma> \\<Longrightarrow> d_IN g ?a = 0\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       x \\<notin> A \\<Gamma> \\<Longrightarrow> d_OUT g x \\<le> d_IN g x\n 2. \\<And>b. b \\<in> B \\<Gamma> \\<Longrightarrow> d_OUT g b = 0\n 3. \\<And>e. e \\<notin> \\<^bold>E \\<Longrightarrow> g e = 0", "show \"d_OUT g b = 0\" if \"b \\<in> B \\<Gamma>\" for b"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT g b = 0", "using d_OUT_mono[of g b f, OF le] currentD_OUT[OF f that]"], ["proof (prove)\nusing this:\n  d_OUT g b \\<le> d_OUT f b\n  d_OUT f b = 0\n\ngoal (1 subgoal):\n 1. d_OUT g b = 0", "by auto"], ["proof (state)\nthis:\n  ?b \\<in> B \\<Gamma> \\<Longrightarrow> d_OUT g ?b = 0\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<notin> A \\<Gamma> \\<Longrightarrow> d_OUT g x \\<le> d_IN g x\n 2. \\<And>e. e \\<notin> \\<^bold>E \\<Longrightarrow> g e = 0", "show \"g e = 0\" if \"e \\<notin> \\<^bold>E\" for e"], ["proof (prove)\ngoal (1 subgoal):\n 1. g e = 0", "using currentD_outside'[OF f that] le[of e]"], ["proof (prove)\nusing this:\n  f e = 0\n  g e \\<le> f e\n\ngoal (1 subgoal):\n 1. g e = 0", "by simp"], ["proof (state)\nthis:\n  ?e \\<notin> \\<^bold>E \\<Longrightarrow> g ?e = 0\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<notin> A \\<Gamma> \\<Longrightarrow> d_OUT g x \\<le> d_IN g x", "qed(blast intro: OUT_IN)+"], ["", "lemma current_weight_mono:\n  \"\\<lbrakk> current \\<Gamma> f; edge \\<Gamma> = edge \\<Gamma>'; A \\<Gamma> = A \\<Gamma>'; B \\<Gamma> = B \\<Gamma>'; \\<And>x. weight \\<Gamma> x \\<le> weight \\<Gamma>' x \\<rbrakk>\n  \\<Longrightarrow> current \\<Gamma>' f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>current \\<Gamma> f; edge \\<Gamma> = edge \\<Gamma>';\n     A \\<Gamma> = A \\<Gamma>'; B \\<Gamma> = B \\<Gamma>';\n     \\<And>x. weight \\<Gamma> x \\<le> weight \\<Gamma>' x\\<rbrakk>\n    \\<Longrightarrow> current \\<Gamma>' f", "by(auto 4 3 elim!: current.cases intro!: current.intros intro: order_trans)"], ["", "abbreviation (input) zero_current :: \"'v current\"\nwhere \"zero_current \\<equiv> \\<lambda>_. 0\""], ["", "lemma SINK_0 [simp]: \"SINK zero_current = UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SINK (\\<lambda>_. 0) = UNIV", "by(auto simp add: SINK.simps)"], ["", "lemma current_0 [simp]: \"current \\<Gamma> zero_current\""], ["proof (prove)\ngoal (1 subgoal):\n 1. current \\<Gamma> (\\<lambda>_. 0)", "by(auto simp add: current.simps)"], ["", "inductive web_flow :: \"('v, 'more) web_scheme \\<Rightarrow> 'v current \\<Rightarrow> bool\"\n  for \\<Gamma> (structure) and f\nwhere\n  web_flow: \"\\<lbrakk> current \\<Gamma> f; \\<And>x. \\<lbrakk> x \\<in> \\<^bold>V; x \\<notin> A \\<Gamma>; x \\<notin> B \\<Gamma> \\<rbrakk> \\<Longrightarrow> KIR f x \\<rbrakk> \\<Longrightarrow> web_flow \\<Gamma> f\""], ["", "lemma web_flowD_current: \"web_flow \\<Gamma> f \\<Longrightarrow> current \\<Gamma> f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. web_flow \\<Gamma> f \\<Longrightarrow> current \\<Gamma> f", "by(erule web_flow.cases)"], ["", "lemma web_flowD_KIR: \"\\<lbrakk> web_flow \\<Gamma> f; x \\<notin> A \\<Gamma>; x \\<notin> B \\<Gamma> \\<rbrakk> \\<Longrightarrow> KIR f x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>web_flow \\<Gamma> f; x \\<notin> A \\<Gamma>;\n     x \\<notin> B \\<Gamma>\\<rbrakk>\n    \\<Longrightarrow> KIR f x", "apply(cases \"x \\<in> \\<^bold>V\\<^bsub>\\<Gamma>\\<^esub>\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>web_flow \\<Gamma> f; x \\<notin> A \\<Gamma>;\n     x \\<notin> B \\<Gamma>;\n     x \\<in> \\<^bold>V\\<^bsub>\\<Gamma>\\<^esub>\\<rbrakk>\n    \\<Longrightarrow> KIR f x\n 2. \\<lbrakk>web_flow \\<Gamma> f; x \\<notin> A \\<Gamma>;\n     x \\<notin> B \\<Gamma>;\n     x \\<notin> \\<^bold>V\\<^bsub>\\<Gamma>\\<^esub>\\<rbrakk>\n    \\<Longrightarrow> KIR f x", "apply(fastforce elim!: web_flow.cases)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>web_flow \\<Gamma> f; x \\<notin> A \\<Gamma>;\n     x \\<notin> B \\<Gamma>;\n     x \\<notin> \\<^bold>V\\<^bsub>\\<Gamma>\\<^esub>\\<rbrakk>\n    \\<Longrightarrow> KIR f x", "apply(auto simp add: vertex_def d_OUT_def d_IN_def elim!: web_flow.cases)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<notin> A \\<Gamma>; x \\<notin> B \\<Gamma>;\n     current \\<Gamma> f;\n     \\<forall>x.\n        (Domainp (edge \\<Gamma>) x \\<longrightarrow>\n         x \\<notin> A \\<Gamma> \\<longrightarrow>\n         x \\<notin> B \\<Gamma> \\<longrightarrow>\n         (\\<Sum>\\<^sup>+ y. f (x, y)) =\n         (\\<Sum>\\<^sup>+ xa. f (xa, x))) \\<and>\n        (Rangep (edge \\<Gamma>) x \\<longrightarrow>\n         x \\<notin> A \\<Gamma> \\<longrightarrow>\n         x \\<notin> B \\<Gamma> \\<longrightarrow>\n         (\\<Sum>\\<^sup>+ y. f (x, y)) = (\\<Sum>\\<^sup>+ xa. f (xa, x)));\n     \\<not> Domainp (edge \\<Gamma>) x;\n     \\<not> Rangep (edge \\<Gamma>) x\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>\\<^sup>+ y. f (x, y)) =\n                      (\\<Sum>\\<^sup>+ xa. f (xa, x))", "apply(subst (1 2) currentD_outside[of _ f]; auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection \\<open>Saturated and terminal vertices\\<close>"], ["", "inductive_set SAT :: \"('v, 'more) web_scheme \\<Rightarrow> 'v current \\<Rightarrow> 'v set\"\n  for \\<Gamma> f\nwhere\n  A: \"x \\<in> A \\<Gamma> \\<Longrightarrow> x \\<in> SAT \\<Gamma> f\"\n| IN: \"d_IN f x \\<ge> weight \\<Gamma> x \\<Longrightarrow> x \\<in> SAT \\<Gamma> f\"\n  \\<comment> \\<open>We use @{text \"\\<ge> weight\"} such that @{text SAT} is monotone w.r.t. increasing currents\\<close>"], ["", "lemma SAT_0 [simp]: \"SAT \\<Gamma> zero_current = A \\<Gamma> \\<union> {x. weight \\<Gamma> x \\<le> 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SAT \\<Gamma> (\\<lambda>_. 0) =\n    A \\<Gamma> \\<union> {x. weight \\<Gamma> x \\<le> 0}", "by(auto simp add: SAT.simps)"], ["", "lemma SAT_mono:\n  assumes \"\\<And>e. f e \\<le> g e\"\n  shows \"SAT \\<Gamma> f \\<subseteq> SAT \\<Gamma> g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SAT \\<Gamma> f \\<subseteq> SAT \\<Gamma> g", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> SAT \\<Gamma> f \\<Longrightarrow> x \\<in> SAT \\<Gamma> g", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> SAT \\<Gamma> f \\<Longrightarrow> x \\<in> SAT \\<Gamma> g", "assume \"x \\<in> SAT \\<Gamma> f\""], ["proof (state)\nthis:\n  x \\<in> SAT \\<Gamma> f\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> SAT \\<Gamma> f \\<Longrightarrow> x \\<in> SAT \\<Gamma> g", "thus \"x \\<in> SAT \\<Gamma> g\""], ["proof (prove)\nusing this:\n  x \\<in> SAT \\<Gamma> f\n\ngoal (1 subgoal):\n 1. x \\<in> SAT \\<Gamma> g", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<in> A \\<Gamma> \\<Longrightarrow> x \\<in> SAT \\<Gamma> g\n 2. weight \\<Gamma> x \\<le> d_IN f x \\<Longrightarrow>\n    x \\<in> SAT \\<Gamma> g", "case IN"], ["proof (state)\nthis:\n  weight \\<Gamma> x \\<le> d_IN f x\n\ngoal (2 subgoals):\n 1. x \\<in> A \\<Gamma> \\<Longrightarrow> x \\<in> SAT \\<Gamma> g\n 2. weight \\<Gamma> x \\<le> d_IN f x \\<Longrightarrow>\n    x \\<in> SAT \\<Gamma> g", "also"], ["proof (state)\nthis:\n  weight \\<Gamma> x \\<le> d_IN f x\n\ngoal (2 subgoals):\n 1. x \\<in> A \\<Gamma> \\<Longrightarrow> x \\<in> SAT \\<Gamma> g\n 2. weight \\<Gamma> x \\<le> d_IN f x \\<Longrightarrow>\n    x \\<in> SAT \\<Gamma> g", "have \"d_IN f x \\<le> d_IN g x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN f x \\<le> d_IN g x", "using assms"], ["proof (prove)\nusing this:\n  f ?e \\<le> g ?e\n\ngoal (1 subgoal):\n 1. d_IN f x \\<le> d_IN g x", "by(rule d_IN_mono)"], ["proof (state)\nthis:\n  d_IN f x \\<le> d_IN g x\n\ngoal (2 subgoals):\n 1. x \\<in> A \\<Gamma> \\<Longrightarrow> x \\<in> SAT \\<Gamma> g\n 2. weight \\<Gamma> x \\<le> d_IN f x \\<Longrightarrow>\n    x \\<in> SAT \\<Gamma> g", "finally"], ["proof (chain)\npicking this:\n  weight \\<Gamma> x \\<le> d_IN g x", "show ?thesis"], ["proof (prove)\nusing this:\n  weight \\<Gamma> x \\<le> d_IN g x\n\ngoal (1 subgoal):\n 1. x \\<in> SAT \\<Gamma> g", ".."], ["proof (state)\nthis:\n  x \\<in> SAT \\<Gamma> g\n\ngoal (1 subgoal):\n 1. x \\<in> A \\<Gamma> \\<Longrightarrow> x \\<in> SAT \\<Gamma> g", "qed(rule SAT.A)"], ["proof (state)\nthis:\n  x \\<in> SAT \\<Gamma> g\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma SAT_Sup_upper: \"f \\<in> Y \\<Longrightarrow> SAT \\<Gamma> f \\<subseteq> SAT \\<Gamma> (Sup Y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<in> Y \\<Longrightarrow>\n    SAT \\<Gamma> f \\<subseteq> SAT \\<Gamma> (\\<Squnion> Y)", "by(rule SAT_mono)(rule Sup_upper[THEN le_funD])"], ["", "lemma currentD_SAT:\n  assumes \"current \\<Gamma> f\"\n  shows \"x \\<in> SAT \\<Gamma> f \\<longleftrightarrow> x \\<in> A \\<Gamma> \\<or> d_IN f x = weight \\<Gamma> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<in> SAT \\<Gamma> f) =\n    (x \\<in> A \\<Gamma> \\<or> d_IN f x = weight \\<Gamma> x)", "using currentD_weight_IN[OF assms, of x]"], ["proof (prove)\nusing this:\n  d_IN f x \\<le> weight \\<Gamma> x\n\ngoal (1 subgoal):\n 1. (x \\<in> SAT \\<Gamma> f) =\n    (x \\<in> A \\<Gamma> \\<or> d_IN f x = weight \\<Gamma> x)", "by(auto simp add: SAT.simps)"], ["", "abbreviation terminal :: \"('v, 'more) web_scheme \\<Rightarrow> 'v current \\<Rightarrow> 'v set\" (\"TER\\<index>\")\nwhere \"terminal \\<Gamma> f \\<equiv> SAT \\<Gamma> f \\<inter> SINK f\""], ["", "subsection \\<open>Separation\\<close>"], ["", "inductive separating_gen :: \"('v, 'more) graph_scheme \\<Rightarrow> 'v set \\<Rightarrow> 'v set \\<Rightarrow> 'v set \\<Rightarrow> bool\"\n  for G A B S\nwhere separating:\n  \"(\\<And>x y p. \\<lbrakk> x \\<in> A; y \\<in> B; path G x p y \\<rbrakk> \\<Longrightarrow> (\\<exists>z \\<in> set p. z \\<in> S) \\<or> x \\<in> S)\n  \\<Longrightarrow> separating_gen G A B S\""], ["", "abbreviation separating :: \"('v, 'more) web_scheme \\<Rightarrow> 'v set \\<Rightarrow> bool\"\nwhere \"separating \\<Gamma> \\<equiv> separating_gen \\<Gamma> (A \\<Gamma>) (B \\<Gamma>)\""], ["", "abbreviation separating_network :: \"('v, 'more) network_scheme \\<Rightarrow> 'v set \\<Rightarrow> bool\"\nwhere \"separating_network \\<Delta> \\<equiv> separating_gen \\<Delta> {source \\<Delta>} {sink \\<Delta>}\""], ["", "lemma separating_networkI [intro?]:\n  \"(\\<And>p. path \\<Delta> (source \\<Delta>) p (sink \\<Delta>) \\<Longrightarrow> (\\<exists>z \\<in> set p. z \\<in> S) \\<or> source \\<Delta> \\<in> S)\n  \\<Longrightarrow> separating_network \\<Delta> S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>p.\n        path \\<Delta> (source \\<Delta>) p (sink \\<Delta>) \\<Longrightarrow>\n        (\\<exists>z\\<in>set p. z \\<in> S) \\<or>\n        source \\<Delta> \\<in> S) \\<Longrightarrow>\n    separating_network \\<Delta> S", "by(auto intro: separating)"], ["", "lemma separatingD:\n  \"\\<And>A B. \\<lbrakk> separating_gen G A B S; path G x p y; x \\<in> A; y \\<in> B \\<rbrakk> \\<Longrightarrow> (\\<exists>z \\<in> set p. z \\<in> S) \\<or> x \\<in> S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>A B.\n       \\<lbrakk>separating_gen G A B S; path G x p y; x \\<in> A;\n        y \\<in> B\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>z\\<in>set p. z \\<in> S) \\<or> x \\<in> S", "by(blast elim: separating_gen.cases)"], ["", "lemma separating_left [simp]: \"\\<And>A B. A \\<subseteq> A' \\<Longrightarrow> separating_gen \\<Gamma> A B A'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>A B.\n       A \\<subseteq> A' \\<Longrightarrow> separating_gen \\<Gamma> A B A'", "by(auto simp add: separating_gen.simps)"], ["", "lemma separating_weakening:\n  \"\\<And>A B. \\<lbrakk> separating_gen G A B S; S \\<subseteq> S' \\<rbrakk> \\<Longrightarrow> separating_gen G A B S'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>A B.\n       \\<lbrakk>separating_gen G A B S; S \\<subseteq> S'\\<rbrakk>\n       \\<Longrightarrow> separating_gen G A B S'", "by(rule separating; drule (3) separatingD; blast)"], ["", "definition essential :: \"('v, 'more) graph_scheme \\<Rightarrow> 'v set \\<Rightarrow> 'v set \\<Rightarrow> 'v \\<Rightarrow> bool\"\nwhere \\<comment> \\<open>Should we allow only simple paths here?\\<close>\n  \"\\<And>B. essential G B S x \\<longleftrightarrow> (\\<exists>p. \\<exists>y\\<in>B. path G x p y \\<and> (x \\<noteq> y \\<longrightarrow> (\\<forall>z\\<in>set p. z = x \\<or> z \\<notin> S)))\""], ["", "abbreviation essential_web :: \"('v, 'more) web_scheme \\<Rightarrow> 'v set \\<Rightarrow> 'v set\" (\"\\<E>\\<index>\")\nwhere \"essential_web \\<Gamma> S \\<equiv> {x\\<in>S. essential \\<Gamma> (B \\<Gamma>) S x}\""], ["", "lemma essential_weight_update [simp]:\n  \"essential (weight_update f G) = essential G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. essential (weight_update f G) = essential G", "by(simp add: essential_def fun_eq_iff)"], ["", "lemma not_essentialD:\n  \"\\<And>B. \\<lbrakk> \\<not> essential G B S x; path G x p y; y \\<in> B \\<rbrakk> \\<Longrightarrow> x \\<noteq> y \\<and> (\\<exists>z\\<in>set p. z \\<noteq> x \\<and> z \\<in> S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>B.\n       \\<lbrakk>\\<not> essential G B S x; path G x p y; y \\<in> B\\<rbrakk>\n       \\<Longrightarrow> x \\<noteq> y \\<and>\n                         (\\<exists>z\\<in>set p.\n                             z \\<noteq> x \\<and> z \\<in> S)", "by(simp add: essential_def)"], ["", "lemma essentialE [elim?, consumes 1, case_names essential, cases pred: essential]:\n  \"\\<And>B. \\<lbrakk> essential G B S x; \\<And>p y. \\<lbrakk> path G x p y; y \\<in> B; \\<And>z. \\<lbrakk> x \\<noteq> y; z \\<in> set p \\<rbrakk> \\<Longrightarrow> z = x \\<or> z \\<notin> S \\<rbrakk> \\<Longrightarrow> thesis \\<rbrakk> \\<Longrightarrow> thesis\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>B.\n       \\<lbrakk>essential G B S x;\n        \\<And>p y.\n           \\<lbrakk>path G x p y; y \\<in> B;\n            \\<And>z.\n               \\<lbrakk>x \\<noteq> y; z \\<in> set p\\<rbrakk>\n               \\<Longrightarrow> z = x \\<or> z \\<notin> S\\<rbrakk>\n           \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis", "by(auto simp add: essential_def)"], ["", "lemma essentialI [intro?]:\n  \"\\<And>B. \\<lbrakk> path G x p y; y \\<in> B; \\<And>z. \\<lbrakk> x \\<noteq> y; z \\<in> set p \\<rbrakk> \\<Longrightarrow> z = x \\<or> z \\<notin> S \\<rbrakk> \\<Longrightarrow> essential G B S x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>B.\n       \\<lbrakk>path G x p y; y \\<in> B;\n        \\<And>z.\n           \\<lbrakk>x \\<noteq> y; z \\<in> set p\\<rbrakk>\n           \\<Longrightarrow> z = x \\<or> z \\<notin> S\\<rbrakk>\n       \\<Longrightarrow> essential G B S x", "by(auto simp add: essential_def)"], ["", "lemma essential_vertex: \"\\<And>B. \\<lbrakk> essential G B S x; x \\<notin> B \\<rbrakk> \\<Longrightarrow>vertex G x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>B.\n       \\<lbrakk>essential G B S x; x \\<notin> B\\<rbrakk>\n       \\<Longrightarrow> vertex G x", "by(auto elim!: essentialE simp add: vertex_def elim: rtrancl_path.cases)"], ["", "lemma essential_BI: \"\\<And>B. x \\<in> B \\<Longrightarrow> essential G B S x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>B. x \\<in> B \\<Longrightarrow> essential G B S x", "by(auto simp add: essential_def intro: rtrancl_path.base)"], ["", "lemma \\<E>_E [elim?, consumes 1, case_names \\<E>, cases set: essential_web]:\n  fixes \\<Gamma> (structure)\n  assumes \"x \\<in> \\<E> S\"\n  obtains p y where \"path \\<Gamma> x p y\" \"y \\<in> B \\<Gamma>\" \"\\<And>z. \\<lbrakk> x \\<noteq> y; z \\<in> set p \\<rbrakk> \\<Longrightarrow> z = x \\<or> z \\<notin> S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>p y.\n        \\<lbrakk>path \\<Gamma> x p y; y \\<in> B \\<Gamma>;\n         \\<And>z.\n            \\<lbrakk>x \\<noteq> y; z \\<in> set p\\<rbrakk>\n            \\<Longrightarrow> z = x \\<or> z \\<notin> S\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  x \\<in> \\<E> S\n\ngoal (1 subgoal):\n 1. (\\<And>p y.\n        \\<lbrakk>path \\<Gamma> x p y; y \\<in> B \\<Gamma>;\n         \\<And>z.\n            \\<lbrakk>x \\<noteq> y; z \\<in> set p\\<rbrakk>\n            \\<Longrightarrow> z = x \\<or> z \\<notin> S\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto elim: essentialE)"], ["", "lemma essential_mono: \"\\<And>B. \\<lbrakk> essential G B S x; S' \\<subseteq> S \\<rbrakk> \\<Longrightarrow> essential G B S' x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>B.\n       \\<lbrakk>essential G B S x; S' \\<subseteq> S\\<rbrakk>\n       \\<Longrightarrow> essential G B S' x", "by(auto simp add: essential_def)"], ["", "lemma separating_essential: \\<comment> \\<open>Lem. 3.4 (cf. Lem. 2.14 in [5])\\<close>\n  fixes G A B S\n  assumes \"separating_gen G A B S\"\n  shows \"separating_gen G A B {x\\<in>S. essential G B S x}\" (is \"separating_gen _ _ _ ?E\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. separating_gen G A B {x \\<in> S. essential G B S x}", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y p.\n       \\<lbrakk>x \\<in> A; y \\<in> B; path G x p y\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>z\\<in>set p.\n                             z \\<in> {x \\<in> S. essential G B S x}) \\<or>\n                         x \\<in> {x \\<in> S. essential G B S x}", "fix x y p"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y p.\n       \\<lbrakk>x \\<in> A; y \\<in> B; path G x p y\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>z\\<in>set p.\n                             z \\<in> {x \\<in> S. essential G B S x}) \\<or>\n                         x \\<in> {x \\<in> S. essential G B S x}", "assume x: \"x \\<in> A\" and y: \"y \\<in> B\" and p: \"path G x p y\""], ["proof (state)\nthis:\n  x \\<in> A\n  y \\<in> B\n  path G x p y\n\ngoal (1 subgoal):\n 1. \\<And>x y p.\n       \\<lbrakk>x \\<in> A; y \\<in> B; path G x p y\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>z\\<in>set p.\n                             z \\<in> {x \\<in> S. essential G B S x}) \\<or>\n                         x \\<in> {x \\<in> S. essential G B S x}", "from separatingD[OF assms p x y]"], ["proof (chain)\npicking this:\n  (\\<exists>z\\<in>set p. z \\<in> S) \\<or> x \\<in> S", "have \"\\<exists>z \\<in> set (x # p). z \\<in> S\""], ["proof (prove)\nusing this:\n  (\\<exists>z\\<in>set p. z \\<in> S) \\<or> x \\<in> S\n\ngoal (1 subgoal):\n 1. \\<exists>z\\<in>set (x # p). z \\<in> S", "by auto"], ["proof (state)\nthis:\n  \\<exists>z\\<in>set (x # p). z \\<in> S\n\ngoal (1 subgoal):\n 1. \\<And>x y p.\n       \\<lbrakk>x \\<in> A; y \\<in> B; path G x p y\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>z\\<in>set p.\n                             z \\<in> {x \\<in> S. essential G B S x}) \\<or>\n                         x \\<in> {x \\<in> S. essential G B S x}", "from split_list_last_prop[OF this]"], ["proof (chain)\npicking this:\n  \\<exists>ys xa zs.\n     x # p = ys @ xa # zs \\<and>\n     xa \\<in> S \\<and> (\\<forall>z\\<in>set zs. z \\<notin> S)", "obtain ys z zs where decomp: \"x # p = ys @ z # zs\"\n    and z: \"z \\<in> S\" and last: \"\\<And>z. z \\<in> set zs \\<Longrightarrow> z \\<notin> S\""], ["proof (prove)\nusing this:\n  \\<exists>ys xa zs.\n     x # p = ys @ xa # zs \\<and>\n     xa \\<in> S \\<and> (\\<forall>z\\<in>set zs. z \\<notin> S)\n\ngoal (1 subgoal):\n 1. (\\<And>ys z zs.\n        \\<lbrakk>x # p = ys @ z # zs; z \\<in> S;\n         \\<And>z. z \\<in> set zs \\<Longrightarrow> z \\<notin> S\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  x # p = ys @ z # zs\n  z \\<in> S\n  ?z \\<in> set zs \\<Longrightarrow> ?z \\<notin> S\n\ngoal (1 subgoal):\n 1. \\<And>x y p.\n       \\<lbrakk>x \\<in> A; y \\<in> B; path G x p y\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>z\\<in>set p.\n                             z \\<in> {x \\<in> S. essential G B S x}) \\<or>\n                         x \\<in> {x \\<in> S. essential G B S x}", "from decomp"], ["proof (chain)\npicking this:\n  x # p = ys @ z # zs", "consider (empty) \"ys = []\" \"x = z\" \"p = zs\"\n    | (Cons) ys' where \"ys = x # ys'\" \"p = ys' @ z # zs\""], ["proof (prove)\nusing this:\n  x # p = ys @ z # zs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>ys = []; x = z; p = zs\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     \\<And>ys'.\n        \\<lbrakk>ys = x # ys'; p = ys' @ z # zs\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by(auto simp add: Cons_eq_append_conv)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<lbrakk>ys = []; x = z; p = zs\\<rbrakk>\n           \\<Longrightarrow> ?thesis;\n   \\<And>ys'.\n      \\<lbrakk>ys = x # ys'; p = ys' @ z # zs\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. \\<And>x y p.\n       \\<lbrakk>x \\<in> A; y \\<in> B; path G x p y\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>z\\<in>set p.\n                             z \\<in> {x \\<in> S. essential G B S x}) \\<or>\n                         x \\<in> {x \\<in> S. essential G B S x}", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<lbrakk>ys = []; x = z; p = zs\\<rbrakk>\n           \\<Longrightarrow> ?thesis;\n   \\<And>ys'.\n      \\<lbrakk>ys = x # ys'; p = ys' @ z # zs\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis", "show \"(\\<exists>z\\<in>set p. z \\<in> ?E) \\<or> x \\<in> ?E\""], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<lbrakk>ys = []; x = z; p = zs\\<rbrakk>\n           \\<Longrightarrow> ?thesis;\n   \\<And>ys'.\n      \\<lbrakk>ys = x # ys'; p = ys' @ z # zs\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (\\<exists>z\\<in>set p. z \\<in> {x \\<in> S. essential G B S x}) \\<or>\n    x \\<in> {x \\<in> S. essential G B S x}", "proof(cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>ys = []; x = z; p = zs\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>z\\<in>set p.\n                          z \\<in> {x \\<in> S. essential G B S x}) \\<or>\n                      x \\<in> {x \\<in> S. essential G B S x}\n 2. \\<And>ys'.\n       \\<lbrakk>ys = x # ys'; p = ys' @ z # zs\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>z\\<in>set p.\n                             z \\<in> {x \\<in> S. essential G B S x}) \\<or>\n                         x \\<in> {x \\<in> S. essential G B S x}", "case empty"], ["proof (state)\nthis:\n  ys = []\n  x = z\n  p = zs\n\ngoal (2 subgoals):\n 1. \\<lbrakk>ys = []; x = z; p = zs\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>z\\<in>set p.\n                          z \\<in> {x \\<in> S. essential G B S x}) \\<or>\n                      x \\<in> {x \\<in> S. essential G B S x}\n 2. \\<And>ys'.\n       \\<lbrakk>ys = x # ys'; p = ys' @ z # zs\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>z\\<in>set p.\n                             z \\<in> {x \\<in> S. essential G B S x}) \\<or>\n                         x \\<in> {x \\<in> S. essential G B S x}", "hence \"x \\<in> ?E\""], ["proof (prove)\nusing this:\n  ys = []\n  x = z\n  p = zs\n\ngoal (1 subgoal):\n 1. x \\<in> {x \\<in> S. essential G B S x}", "using z p last y"], ["proof (prove)\nusing this:\n  ys = []\n  x = z\n  p = zs\n  z \\<in> S\n  path G x p y\n  ?z \\<in> set zs \\<Longrightarrow> ?z \\<notin> S\n  y \\<in> B\n\ngoal (1 subgoal):\n 1. x \\<in> {x \\<in> S. essential G B S x}", "by(auto simp add: essential_def)"], ["proof (state)\nthis:\n  x \\<in> {x \\<in> S. essential G B S x}\n\ngoal (2 subgoals):\n 1. \\<lbrakk>ys = []; x = z; p = zs\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>z\\<in>set p.\n                          z \\<in> {x \\<in> S. essential G B S x}) \\<or>\n                      x \\<in> {x \\<in> S. essential G B S x}\n 2. \\<And>ys'.\n       \\<lbrakk>ys = x # ys'; p = ys' @ z # zs\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>z\\<in>set p.\n                             z \\<in> {x \\<in> S. essential G B S x}) \\<or>\n                         x \\<in> {x \\<in> S. essential G B S x}", "thus ?thesis"], ["proof (prove)\nusing this:\n  x \\<in> {x \\<in> S. essential G B S x}\n\ngoal (1 subgoal):\n 1. (\\<exists>z\\<in>set p. z \\<in> {x \\<in> S. essential G B S x}) \\<or>\n    x \\<in> {x \\<in> S. essential G B S x}", ".."], ["proof (state)\nthis:\n  (\\<exists>z\\<in>set p. z \\<in> {x \\<in> S. essential G B S x}) \\<or>\n  x \\<in> {x \\<in> S. essential G B S x}\n\ngoal (1 subgoal):\n 1. \\<And>ys'.\n       \\<lbrakk>ys = x # ys'; p = ys' @ z # zs\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>z\\<in>set p.\n                             z \\<in> {x \\<in> S. essential G B S x}) \\<or>\n                         x \\<in> {x \\<in> S. essential G B S x}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ys'.\n       \\<lbrakk>ys = x # ys'; p = ys' @ z # zs\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>z\\<in>set p.\n                             z \\<in> {x \\<in> S. essential G B S x}) \\<or>\n                         x \\<in> {x \\<in> S. essential G B S x}", "case (Cons ys')"], ["proof (state)\nthis:\n  ys = x # ys'\n  p = ys' @ z # zs\n\ngoal (1 subgoal):\n 1. \\<And>ys'.\n       \\<lbrakk>ys = x # ys'; p = ys' @ z # zs\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>z\\<in>set p.\n                             z \\<in> {x \\<in> S. essential G B S x}) \\<or>\n                         x \\<in> {x \\<in> S. essential G B S x}", "from p"], ["proof (chain)\npicking this:\n  path G x p y", "have \"path G z zs y\""], ["proof (prove)\nusing this:\n  path G x p y\n\ngoal (1 subgoal):\n 1. path G z zs y", "unfolding Cons"], ["proof (prove)\nusing this:\n  path G x (ys' @ z # zs) y\n\ngoal (1 subgoal):\n 1. path G z zs y", "by(rule rtrancl_path_appendE)"], ["proof (state)\nthis:\n  path G z zs y\n\ngoal (1 subgoal):\n 1. \\<And>ys'.\n       \\<lbrakk>ys = x # ys'; p = ys' @ z # zs\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>z\\<in>set p.\n                             z \\<in> {x \\<in> S. essential G B S x}) \\<or>\n                         x \\<in> {x \\<in> S. essential G B S x}", "hence \"z \\<in> ?E\""], ["proof (prove)\nusing this:\n  path G z zs y\n\ngoal (1 subgoal):\n 1. z \\<in> {x \\<in> S. essential G B S x}", "using z y last"], ["proof (prove)\nusing this:\n  path G z zs y\n  z \\<in> S\n  y \\<in> B\n  ?z \\<in> set zs \\<Longrightarrow> ?z \\<notin> S\n\ngoal (1 subgoal):\n 1. z \\<in> {x \\<in> S. essential G B S x}", "by(auto simp add: essential_def)"], ["proof (state)\nthis:\n  z \\<in> {x \\<in> S. essential G B S x}\n\ngoal (1 subgoal):\n 1. \\<And>ys'.\n       \\<lbrakk>ys = x # ys'; p = ys' @ z # zs\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>z\\<in>set p.\n                             z \\<in> {x \\<in> S. essential G B S x}) \\<or>\n                         x \\<in> {x \\<in> S. essential G B S x}", "thus ?thesis"], ["proof (prove)\nusing this:\n  z \\<in> {x \\<in> S. essential G B S x}\n\ngoal (1 subgoal):\n 1. (\\<exists>z\\<in>set p. z \\<in> {x \\<in> S. essential G B S x}) \\<or>\n    x \\<in> {x \\<in> S. essential G B S x}", "using Cons"], ["proof (prove)\nusing this:\n  z \\<in> {x \\<in> S. essential G B S x}\n  ys = x # ys'\n  p = ys' @ z # zs\n\ngoal (1 subgoal):\n 1. (\\<exists>z\\<in>set p. z \\<in> {x \\<in> S. essential G B S x}) \\<or>\n    x \\<in> {x \\<in> S. essential G B S x}", "by auto"], ["proof (state)\nthis:\n  (\\<exists>z\\<in>set p. z \\<in> {x \\<in> S. essential G B S x}) \\<or>\n  x \\<in> {x \\<in> S. essential G B S x}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<exists>z\\<in>set p. z \\<in> {x \\<in> S. essential G B S x}) \\<or>\n  x \\<in> {x \\<in> S. essential G B S x}\n\ngoal:\nNo subgoals!", "qed"], ["", "definition roofed_gen :: \"('v, 'more) graph_scheme \\<Rightarrow> 'v set \\<Rightarrow> 'v set \\<Rightarrow> 'v set\"\nwhere roofed_def: \"\\<And>B. roofed_gen G B S = {x. \\<forall>p. \\<forall>y\\<in>B. path G x p y \\<longrightarrow> (\\<exists>z\\<in>set p. z \\<in> S) \\<or> x \\<in> S}\""], ["", "abbreviation roofed :: \"('v, 'more) web_scheme \\<Rightarrow> 'v set \\<Rightarrow> 'v set\" (\"RF\\<index>\")\nwhere \"roofed \\<Gamma> \\<equiv> roofed_gen \\<Gamma> (B \\<Gamma>)\""], ["", "abbreviation roofed_network :: \"('v, 'more) network_scheme \\<Rightarrow> 'v set \\<Rightarrow> 'v set\" (\"RF\\<^sup>N\\<index>\")\nwhere \"roofed_network \\<Delta> \\<equiv> roofed_gen \\<Delta> {sink \\<Delta>}\""], ["", "lemma roofedI [intro?]:\n  \"\\<And>B. (\\<And>p y. \\<lbrakk> path G x p y; y \\<in> B \\<rbrakk> \\<Longrightarrow> (\\<exists>z\\<in>set p. z \\<in> S) \\<or> x \\<in> S) \\<Longrightarrow> x \\<in> roofed_gen G B S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>B.\n       (\\<And>p y.\n           \\<lbrakk>path G x p y; y \\<in> B\\<rbrakk>\n           \\<Longrightarrow> (\\<exists>z\\<in>set p. z \\<in> S) \\<or>\n                             x \\<in> S) \\<Longrightarrow>\n       x \\<in> roofed_gen G B S", "by(auto simp add: roofed_def)"], ["", "lemma not_roofedE: fixes B\n  assumes \"x \\<notin> roofed_gen G B S\"\n  obtains p y where \"path G x p y\" \"y \\<in> B\" \"\\<And>z. z \\<in> set (x # p) \\<Longrightarrow> z \\<notin> S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>p y.\n        \\<lbrakk>path G x p y; y \\<in> B;\n         \\<And>z.\n            z \\<in> set (x # p) \\<Longrightarrow> z \\<notin> S\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  x \\<notin> roofed_gen G B S\n\ngoal (1 subgoal):\n 1. (\\<And>p y.\n        \\<lbrakk>path G x p y; y \\<in> B;\n         \\<And>z.\n            z \\<in> set (x # p) \\<Longrightarrow> z \\<notin> S\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto simp add: roofed_def)"], ["", "lemma roofed_greater: \"\\<And>B. S \\<subseteq> roofed_gen G B S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>B. S \\<subseteq> roofed_gen G B S", "by(auto simp add: roofed_def)"], ["", "lemma roofed_greaterI: \"\\<And>B. x \\<in> S \\<Longrightarrow> x \\<in> roofed_gen G B S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>B. x \\<in> S \\<Longrightarrow> x \\<in> roofed_gen G B S", "using roofed_greater[of S G]"], ["proof (prove)\nusing this:\n  S \\<subseteq> roofed_gen G ?B S\n\ngoal (1 subgoal):\n 1. \\<And>B. x \\<in> S \\<Longrightarrow> x \\<in> roofed_gen G B S", "by blast"], ["", "lemma roofed_mono: \"\\<And>B. S \\<subseteq> S' \\<Longrightarrow> roofed_gen G B S \\<subseteq> roofed_gen G B S'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>B.\n       S \\<subseteq> S' \\<Longrightarrow>\n       roofed_gen G B S \\<subseteq> roofed_gen G B S'", "by(fastforce simp add: roofed_def)"], ["", "lemma in_roofed_mono: \"\\<And>B. \\<lbrakk> x \\<in> roofed_gen G B S; S \\<subseteq> S' \\<rbrakk> \\<Longrightarrow> x \\<in> roofed_gen G B S'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>B.\n       \\<lbrakk>x \\<in> roofed_gen G B S; S \\<subseteq> S'\\<rbrakk>\n       \\<Longrightarrow> x \\<in> roofed_gen G B S'", "using roofed_mono[THEN subsetD]"], ["proof (prove)\nusing this:\n  \\<lbrakk>?S1 \\<subseteq> ?S'1; ?c \\<in> roofed_gen ?G1 ?B1 ?S1\\<rbrakk>\n  \\<Longrightarrow> ?c \\<in> roofed_gen ?G1 ?B1 ?S'1\n\ngoal (1 subgoal):\n 1. \\<And>B.\n       \\<lbrakk>x \\<in> roofed_gen G B S; S \\<subseteq> S'\\<rbrakk>\n       \\<Longrightarrow> x \\<in> roofed_gen G B S'", "."], ["", "lemma roofedD: \"\\<And>B. \\<lbrakk> x \\<in> roofed_gen G B S; path G x p y; y \\<in> B \\<rbrakk> \\<Longrightarrow> (\\<exists>z\\<in>set p. z \\<in> S) \\<or> x \\<in> S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>B.\n       \\<lbrakk>x \\<in> roofed_gen G B S; path G x p y; y \\<in> B\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>z\\<in>set p. z \\<in> S) \\<or> x \\<in> S", "unfolding roofed_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>B.\n       \\<lbrakk>x \\<in> {x. \\<forall>p.\n                               \\<forall>y\\<in>B.\n                                  path G x p y \\<longrightarrow>\n                                  (\\<exists>z\\<in>set p. z \\<in> S) \\<or>\n                                  x \\<in> S};\n        path G x p y; y \\<in> B\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>z\\<in>set p. z \\<in> S) \\<or> x \\<in> S", "by blast"], ["", "lemma separating_RF_A:\n  fixes A B\n  assumes \"separating_gen G A B X\"\n  shows \"A \\<subseteq> roofed_gen G B X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<subseteq> roofed_gen G B X", "by(rule subsetI roofedI)+(erule separatingD[OF assms])"], ["", "lemma roofed_idem: fixes B shows \"roofed_gen G B (roofed_gen G B S) = roofed_gen G B S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. roofed_gen G B (roofed_gen G B S) = roofed_gen G B S", "proof(rule equalityI subsetI roofedI)+"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x p y.\n       \\<lbrakk>x \\<in> roofed_gen G B (roofed_gen G B S); path G x p y;\n        y \\<in> B\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>z\\<in>set p. z \\<in> S) \\<or> x \\<in> S\n 2. roofed_gen G B S \\<subseteq> roofed_gen G B (roofed_gen G B S)", "fix x p y"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x p y.\n       \\<lbrakk>x \\<in> roofed_gen G B (roofed_gen G B S); path G x p y;\n        y \\<in> B\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>z\\<in>set p. z \\<in> S) \\<or> x \\<in> S\n 2. roofed_gen G B S \\<subseteq> roofed_gen G B (roofed_gen G B S)", "assume x: \"x \\<in> roofed_gen G B (roofed_gen G B S)\" and p: \"path G x p y\" and y: \"y \\<in> B\""], ["proof (state)\nthis:\n  x \\<in> roofed_gen G B (roofed_gen G B S)\n  path G x p y\n  y \\<in> B\n\ngoal (2 subgoals):\n 1. \\<And>x p y.\n       \\<lbrakk>x \\<in> roofed_gen G B (roofed_gen G B S); path G x p y;\n        y \\<in> B\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>z\\<in>set p. z \\<in> S) \\<or> x \\<in> S\n 2. roofed_gen G B S \\<subseteq> roofed_gen G B (roofed_gen G B S)", "from roofedD[OF x p y]"], ["proof (chain)\npicking this:\n  (\\<exists>z\\<in>set p. z \\<in> roofed_gen G B S) \\<or>\n  x \\<in> roofed_gen G B S", "obtain z where *: \"z \\<in> set (x # p)\" and z: \"z \\<in> roofed_gen G B S\""], ["proof (prove)\nusing this:\n  (\\<exists>z\\<in>set p. z \\<in> roofed_gen G B S) \\<or>\n  x \\<in> roofed_gen G B S\n\ngoal (1 subgoal):\n 1. (\\<And>z.\n        \\<lbrakk>z \\<in> set (x # p); z \\<in> roofed_gen G B S\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  z \\<in> set (x # p)\n  z \\<in> roofed_gen G B S\n\ngoal (2 subgoals):\n 1. \\<And>x p y.\n       \\<lbrakk>x \\<in> roofed_gen G B (roofed_gen G B S); path G x p y;\n        y \\<in> B\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>z\\<in>set p. z \\<in> S) \\<or> x \\<in> S\n 2. roofed_gen G B S \\<subseteq> roofed_gen G B (roofed_gen G B S)", "from split_list[OF *]"], ["proof (chain)\npicking this:\n  \\<exists>ys zs. x # p = ys @ z # zs", "obtain ys zs where split: \"x # p = ys @ z # zs\""], ["proof (prove)\nusing this:\n  \\<exists>ys zs. x # p = ys @ z # zs\n\ngoal (1 subgoal):\n 1. (\\<And>ys zs.\n        x # p = ys @ z # zs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  x # p = ys @ z # zs\n\ngoal (2 subgoals):\n 1. \\<And>x p y.\n       \\<lbrakk>x \\<in> roofed_gen G B (roofed_gen G B S); path G x p y;\n        y \\<in> B\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>z\\<in>set p. z \\<in> S) \\<or> x \\<in> S\n 2. roofed_gen G B S \\<subseteq> roofed_gen G B (roofed_gen G B S)", "with p"], ["proof (chain)\npicking this:\n  path G x p y\n  x # p = ys @ z # zs", "have p': \"path G z zs y\""], ["proof (prove)\nusing this:\n  path G x p y\n  x # p = ys @ z # zs\n\ngoal (1 subgoal):\n 1. path G z zs y", "by(auto simp add: Cons_eq_append_conv elim: rtrancl_path_appendE)"], ["proof (state)\nthis:\n  path G z zs y\n\ngoal (2 subgoals):\n 1. \\<And>x p y.\n       \\<lbrakk>x \\<in> roofed_gen G B (roofed_gen G B S); path G x p y;\n        y \\<in> B\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>z\\<in>set p. z \\<in> S) \\<or> x \\<in> S\n 2. roofed_gen G B S \\<subseteq> roofed_gen G B (roofed_gen G B S)", "from roofedD[OF z p' y] split"], ["proof (chain)\npicking this:\n  (\\<exists>z\\<in>set zs. z \\<in> S) \\<or> z \\<in> S\n  x # p = ys @ z # zs", "show \"(\\<exists>z\\<in>set p. z \\<in> S) \\<or> x \\<in> S\""], ["proof (prove)\nusing this:\n  (\\<exists>z\\<in>set zs. z \\<in> S) \\<or> z \\<in> S\n  x # p = ys @ z # zs\n\ngoal (1 subgoal):\n 1. (\\<exists>z\\<in>set p. z \\<in> S) \\<or> x \\<in> S", "by(auto simp add: Cons_eq_append_conv)"], ["proof (state)\nthis:\n  (\\<exists>z\\<in>set p. z \\<in> S) \\<or> x \\<in> S\n\ngoal (1 subgoal):\n 1. roofed_gen G B S \\<subseteq> roofed_gen G B (roofed_gen G B S)", "qed(rule roofed_mono roofed_greater)+"], ["", "lemma in_roofed_mono': \"\\<And>B. \\<lbrakk> x \\<in> roofed_gen G B S; S \\<subseteq> roofed_gen G B S' \\<rbrakk> \\<Longrightarrow> x \\<in> roofed_gen G B S'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>B.\n       \\<lbrakk>x \\<in> roofed_gen G B S;\n        S \\<subseteq> roofed_gen G B S'\\<rbrakk>\n       \\<Longrightarrow> x \\<in> roofed_gen G B S'", "by(subst roofed_idem[symmetric])(erule in_roofed_mono)"], ["", "lemma roofed_mono': \"\\<And>B. S \\<subseteq> roofed_gen G B S' \\<Longrightarrow> roofed_gen G B S \\<subseteq> roofed_gen G B S'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>B.\n       S \\<subseteq> roofed_gen G B S' \\<Longrightarrow>\n       roofed_gen G B S \\<subseteq> roofed_gen G B S'", "by(rule subsetI)(rule in_roofed_mono')"], ["", "lemma roofed_idem_Un1: fixes B shows \"roofed_gen G B (roofed_gen G B S \\<union> T) = roofed_gen G B (S \\<union> T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. roofed_gen G B (roofed_gen G B S \\<union> T) =\n    roofed_gen G B (S \\<union> T)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. roofed_gen G B (roofed_gen G B S \\<union> T) =\n    roofed_gen G B (S \\<union> T)", "have \"S \\<subseteq> T \\<union> roofed_gen G B S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S \\<subseteq> T \\<union> roofed_gen G B S", "by (metis (no_types) UnCI roofed_greater subsetCE subsetI)"], ["proof (state)\nthis:\n  S \\<subseteq> T \\<union> roofed_gen G B S\n\ngoal (1 subgoal):\n 1. roofed_gen G B (roofed_gen G B S \\<union> T) =\n    roofed_gen G B (S \\<union> T)", "then"], ["proof (chain)\npicking this:\n  S \\<subseteq> T \\<union> roofed_gen G B S", "have \"S \\<union> T \\<subseteq> T \\<union> roofed_gen G B S \\<and> T \\<union> roofed_gen G B S \\<subseteq> roofed_gen G B (S \\<union> T)\""], ["proof (prove)\nusing this:\n  S \\<subseteq> T \\<union> roofed_gen G B S\n\ngoal (1 subgoal):\n 1. S \\<union> T \\<subseteq> T \\<union> roofed_gen G B S \\<and>\n    T \\<union> roofed_gen G B S \\<subseteq> roofed_gen G B (S \\<union> T)", "by (metis (no_types) Un_subset_iff Un_upper2 roofed_greater roofed_mono sup.commute)"], ["proof (state)\nthis:\n  S \\<union> T \\<subseteq> T \\<union> roofed_gen G B S \\<and>\n  T \\<union> roofed_gen G B S \\<subseteq> roofed_gen G B (S \\<union> T)\n\ngoal (1 subgoal):\n 1. roofed_gen G B (roofed_gen G B S \\<union> T) =\n    roofed_gen G B (S \\<union> T)", "then"], ["proof (chain)\npicking this:\n  S \\<union> T \\<subseteq> T \\<union> roofed_gen G B S \\<and>\n  T \\<union> roofed_gen G B S \\<subseteq> roofed_gen G B (S \\<union> T)", "show ?thesis"], ["proof (prove)\nusing this:\n  S \\<union> T \\<subseteq> T \\<union> roofed_gen G B S \\<and>\n  T \\<union> roofed_gen G B S \\<subseteq> roofed_gen G B (S \\<union> T)\n\ngoal (1 subgoal):\n 1. roofed_gen G B (roofed_gen G B S \\<union> T) =\n    roofed_gen G B (S \\<union> T)", "by (metis (no_types) roofed_idem roofed_mono subset_antisym sup.commute)"], ["proof (state)\nthis:\n  roofed_gen G B (roofed_gen G B S \\<union> T) =\n  roofed_gen G B (S \\<union> T)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma roofed_UN: fixes A B\n  shows \"roofed_gen G B (\\<Union>i\\<in>A. roofed_gen G B (X i)) = roofed_gen G B (\\<Union>i\\<in>A. X i)\" (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. roofed_gen G B (\\<Union>i\\<in>A. roofed_gen G B (X i)) =\n    roofed_gen G B (\\<Union> (X ` A))", "proof(rule equalityI)"], ["proof (state)\ngoal (2 subgoals):\n 1. roofed_gen G B (\\<Union>i\\<in>A. roofed_gen G B (X i))\n    \\<subseteq> roofed_gen G B (\\<Union> (X ` A))\n 2. roofed_gen G B (\\<Union> (X ` A))\n    \\<subseteq> roofed_gen G B (\\<Union>i\\<in>A. roofed_gen G B (X i))", "show \"?rhs \\<subseteq> ?lhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. roofed_gen G B (\\<Union> (X ` A))\n    \\<subseteq> roofed_gen G B (\\<Union>i\\<in>A. roofed_gen G B (X i))", "by(rule roofed_mono)(blast intro: roofed_greaterI)"], ["proof (state)\nthis:\n  roofed_gen G B (\\<Union> (X ` A))\n  \\<subseteq> roofed_gen G B (\\<Union>i\\<in>A. roofed_gen G B (X i))\n\ngoal (1 subgoal):\n 1. roofed_gen G B (\\<Union>i\\<in>A. roofed_gen G B (X i))\n    \\<subseteq> roofed_gen G B (\\<Union> (X ` A))", "show \"?lhs \\<subseteq> ?rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. roofed_gen G B (\\<Union>i\\<in>A. roofed_gen G B (X i))\n    \\<subseteq> roofed_gen G B (\\<Union> (X ` A))", "by(rule roofed_mono')(blast intro: in_roofed_mono)"], ["proof (state)\nthis:\n  roofed_gen G B (\\<Union>i\\<in>A. roofed_gen G B (X i))\n  \\<subseteq> roofed_gen G B (\\<Union> (X ` A))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma RF_essential: fixes \\<Gamma> (structure) shows \"RF (\\<E> S) = RF S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RF (\\<E> S) = RF S", "proof(intro set_eqI iffI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> RF (\\<E> S) \\<Longrightarrow> x \\<in> RF S\n 2. \\<And>x. x \\<in> RF S \\<Longrightarrow> x \\<in> RF (\\<E> S)", "fix x"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> RF (\\<E> S) \\<Longrightarrow> x \\<in> RF S\n 2. \\<And>x. x \\<in> RF S \\<Longrightarrow> x \\<in> RF (\\<E> S)", "assume RF: \"x \\<in> RF S\""], ["proof (state)\nthis:\n  x \\<in> RF S\n\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> RF (\\<E> S) \\<Longrightarrow> x \\<in> RF S\n 2. \\<And>x. x \\<in> RF S \\<Longrightarrow> x \\<in> RF (\\<E> S)", "show \"x \\<in> RF (\\<E> S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> RF (\\<E> S)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p y.\n       \\<lbrakk>path \\<Gamma> x p y; y \\<in> B \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>z\\<in>set p. z \\<in> \\<E> S) \\<or>\n                         x \\<in> \\<E> S", "fix p y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p y.\n       \\<lbrakk>path \\<Gamma> x p y; y \\<in> B \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>z\\<in>set p. z \\<in> \\<E> S) \\<or>\n                         x \\<in> \\<E> S", "assume p: \"path \\<Gamma> x p y\" and y: \"y \\<in> B \\<Gamma>\""], ["proof (state)\nthis:\n  path \\<Gamma> x p y\n  y \\<in> B \\<Gamma>\n\ngoal (1 subgoal):\n 1. \\<And>p y.\n       \\<lbrakk>path \\<Gamma> x p y; y \\<in> B \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>z\\<in>set p. z \\<in> \\<E> S) \\<or>\n                         x \\<in> \\<E> S", "from roofedD[OF RF this]"], ["proof (chain)\npicking this:\n  (\\<exists>z\\<in>set p. z \\<in> S) \\<or> x \\<in> S", "have \"\\<exists>z\\<in>set (x # p). z \\<in> S\""], ["proof (prove)\nusing this:\n  (\\<exists>z\\<in>set p. z \\<in> S) \\<or> x \\<in> S\n\ngoal (1 subgoal):\n 1. \\<exists>z\\<in>set (x # p). z \\<in> S", "by auto"], ["proof (state)\nthis:\n  \\<exists>z\\<in>set (x # p). z \\<in> S\n\ngoal (1 subgoal):\n 1. \\<And>p y.\n       \\<lbrakk>path \\<Gamma> x p y; y \\<in> B \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>z\\<in>set p. z \\<in> \\<E> S) \\<or>\n                         x \\<in> \\<E> S", "from split_list_last_prop[OF this]"], ["proof (chain)\npicking this:\n  \\<exists>ys xa zs.\n     x # p = ys @ xa # zs \\<and>\n     xa \\<in> S \\<and> (\\<forall>z\\<in>set zs. z \\<notin> S)", "obtain ys z zs where decomp: \"x # p = ys @ z # zs\"\n      and z: \"z \\<in> S\" and last: \"\\<And>z. z \\<in> set zs \\<Longrightarrow> z \\<notin> S\""], ["proof (prove)\nusing this:\n  \\<exists>ys xa zs.\n     x # p = ys @ xa # zs \\<and>\n     xa \\<in> S \\<and> (\\<forall>z\\<in>set zs. z \\<notin> S)\n\ngoal (1 subgoal):\n 1. (\\<And>ys z zs.\n        \\<lbrakk>x # p = ys @ z # zs; z \\<in> S;\n         \\<And>z. z \\<in> set zs \\<Longrightarrow> z \\<notin> S\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  x # p = ys @ z # zs\n  z \\<in> S\n  ?z \\<in> set zs \\<Longrightarrow> ?z \\<notin> S\n\ngoal (1 subgoal):\n 1. \\<And>p y.\n       \\<lbrakk>path \\<Gamma> x p y; y \\<in> B \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>z\\<in>set p. z \\<in> \\<E> S) \\<or>\n                         x \\<in> \\<E> S", "from decomp"], ["proof (chain)\npicking this:\n  x # p = ys @ z # zs", "consider (empty) \"ys = []\" \"x = z\" \"p = zs\"\n      | (Cons) ys' where \"ys = x # ys'\" \"p = ys' @ z # zs\""], ["proof (prove)\nusing this:\n  x # p = ys @ z # zs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>ys = []; x = z; p = zs\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     \\<And>ys'.\n        \\<lbrakk>ys = x # ys'; p = ys' @ z # zs\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by(auto simp add: Cons_eq_append_conv)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<lbrakk>ys = []; x = z; p = zs\\<rbrakk>\n           \\<Longrightarrow> ?thesis;\n   \\<And>ys'.\n      \\<lbrakk>ys = x # ys'; p = ys' @ z # zs\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. \\<And>p y.\n       \\<lbrakk>path \\<Gamma> x p y; y \\<in> B \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>z\\<in>set p. z \\<in> \\<E> S) \\<or>\n                         x \\<in> \\<E> S", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<lbrakk>ys = []; x = z; p = zs\\<rbrakk>\n           \\<Longrightarrow> ?thesis;\n   \\<And>ys'.\n      \\<lbrakk>ys = x # ys'; p = ys' @ z # zs\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis", "show \"(\\<exists>z\\<in>set p. z \\<in> \\<E> S) \\<or> x \\<in> \\<E> S\""], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<lbrakk>ys = []; x = z; p = zs\\<rbrakk>\n           \\<Longrightarrow> ?thesis;\n   \\<And>ys'.\n      \\<lbrakk>ys = x # ys'; p = ys' @ z # zs\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (\\<exists>z\\<in>set p. z \\<in> \\<E> S) \\<or> x \\<in> \\<E> S", "proof(cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>ys = []; x = z; p = zs\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>z\\<in>set p. z \\<in> \\<E> S) \\<or>\n                      x \\<in> \\<E> S\n 2. \\<And>ys'.\n       \\<lbrakk>ys = x # ys'; p = ys' @ z # zs\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>z\\<in>set p. z \\<in> \\<E> S) \\<or>\n                         x \\<in> \\<E> S", "case empty"], ["proof (state)\nthis:\n  ys = []\n  x = z\n  p = zs\n\ngoal (2 subgoals):\n 1. \\<lbrakk>ys = []; x = z; p = zs\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>z\\<in>set p. z \\<in> \\<E> S) \\<or>\n                      x \\<in> \\<E> S\n 2. \\<And>ys'.\n       \\<lbrakk>ys = x # ys'; p = ys' @ z # zs\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>z\\<in>set p. z \\<in> \\<E> S) \\<or>\n                         x \\<in> \\<E> S", "hence \"x \\<in> \\<E> S\""], ["proof (prove)\nusing this:\n  ys = []\n  x = z\n  p = zs\n\ngoal (1 subgoal):\n 1. x \\<in> \\<E> S", "using z p last y"], ["proof (prove)\nusing this:\n  ys = []\n  x = z\n  p = zs\n  z \\<in> S\n  path \\<Gamma> x p y\n  ?z \\<in> set zs \\<Longrightarrow> ?z \\<notin> S\n  y \\<in> B \\<Gamma>\n\ngoal (1 subgoal):\n 1. x \\<in> \\<E> S", "by(auto simp add: essential_def)"], ["proof (state)\nthis:\n  x \\<in> \\<E> S\n\ngoal (2 subgoals):\n 1. \\<lbrakk>ys = []; x = z; p = zs\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>z\\<in>set p. z \\<in> \\<E> S) \\<or>\n                      x \\<in> \\<E> S\n 2. \\<And>ys'.\n       \\<lbrakk>ys = x # ys'; p = ys' @ z # zs\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>z\\<in>set p. z \\<in> \\<E> S) \\<or>\n                         x \\<in> \\<E> S", "thus ?thesis"], ["proof (prove)\nusing this:\n  x \\<in> \\<E> S\n\ngoal (1 subgoal):\n 1. (\\<exists>z\\<in>set p. z \\<in> \\<E> S) \\<or> x \\<in> \\<E> S", ".."], ["proof (state)\nthis:\n  (\\<exists>z\\<in>set p. z \\<in> \\<E> S) \\<or> x \\<in> \\<E> S\n\ngoal (1 subgoal):\n 1. \\<And>ys'.\n       \\<lbrakk>ys = x # ys'; p = ys' @ z # zs\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>z\\<in>set p. z \\<in> \\<E> S) \\<or>\n                         x \\<in> \\<E> S", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ys'.\n       \\<lbrakk>ys = x # ys'; p = ys' @ z # zs\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>z\\<in>set p. z \\<in> \\<E> S) \\<or>\n                         x \\<in> \\<E> S", "case (Cons ys')"], ["proof (state)\nthis:\n  ys = x # ys'\n  p = ys' @ z # zs\n\ngoal (1 subgoal):\n 1. \\<And>ys'.\n       \\<lbrakk>ys = x # ys'; p = ys' @ z # zs\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>z\\<in>set p. z \\<in> \\<E> S) \\<or>\n                         x \\<in> \\<E> S", "from p"], ["proof (chain)\npicking this:\n  path \\<Gamma> x p y", "have \"path \\<Gamma> z zs y\""], ["proof (prove)\nusing this:\n  path \\<Gamma> x p y\n\ngoal (1 subgoal):\n 1. path \\<Gamma> z zs y", "unfolding Cons"], ["proof (prove)\nusing this:\n  path \\<Gamma> x (ys' @ z # zs) y\n\ngoal (1 subgoal):\n 1. path \\<Gamma> z zs y", "by(rule rtrancl_path_appendE)"], ["proof (state)\nthis:\n  path \\<Gamma> z zs y\n\ngoal (1 subgoal):\n 1. \\<And>ys'.\n       \\<lbrakk>ys = x # ys'; p = ys' @ z # zs\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>z\\<in>set p. z \\<in> \\<E> S) \\<or>\n                         x \\<in> \\<E> S", "hence \"z \\<in> \\<E> S\""], ["proof (prove)\nusing this:\n  path \\<Gamma> z zs y\n\ngoal (1 subgoal):\n 1. z \\<in> \\<E> S", "using z y last"], ["proof (prove)\nusing this:\n  path \\<Gamma> z zs y\n  z \\<in> S\n  y \\<in> B \\<Gamma>\n  ?z \\<in> set zs \\<Longrightarrow> ?z \\<notin> S\n\ngoal (1 subgoal):\n 1. z \\<in> \\<E> S", "by(auto simp add: essential_def)"], ["proof (state)\nthis:\n  z \\<in> \\<E> S\n\ngoal (1 subgoal):\n 1. \\<And>ys'.\n       \\<lbrakk>ys = x # ys'; p = ys' @ z # zs\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>z\\<in>set p. z \\<in> \\<E> S) \\<or>\n                         x \\<in> \\<E> S", "thus ?thesis"], ["proof (prove)\nusing this:\n  z \\<in> \\<E> S\n\ngoal (1 subgoal):\n 1. (\\<exists>z\\<in>set p. z \\<in> \\<E> S) \\<or> x \\<in> \\<E> S", "using Cons"], ["proof (prove)\nusing this:\n  z \\<in> \\<E> S\n  ys = x # ys'\n  p = ys' @ z # zs\n\ngoal (1 subgoal):\n 1. (\\<exists>z\\<in>set p. z \\<in> \\<E> S) \\<or> x \\<in> \\<E> S", "by auto"], ["proof (state)\nthis:\n  (\\<exists>z\\<in>set p. z \\<in> \\<E> S) \\<or> x \\<in> \\<E> S\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<exists>z\\<in>set p. z \\<in> \\<E> S) \\<or> x \\<in> \\<E> S\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x \\<in> RF (\\<E> S)\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> RF (\\<E> S) \\<Longrightarrow> x \\<in> RF S", "qed(blast intro: in_roofed_mono)"], ["", "lemma essentialE_RF:\n  fixes \\<Gamma> (structure) and B\n  assumes \"essential \\<Gamma> B S x\"\n  obtains p y where \"path \\<Gamma> x p y\" \"y \\<in> B\" \"distinct (x # p)\" \"\\<And>z. z \\<in> set p \\<Longrightarrow> z \\<notin> roofed_gen \\<Gamma> B S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>p y.\n        \\<lbrakk>path \\<Gamma> x p y; y \\<in> B; distinct (x # p);\n         \\<And>z.\n            z \\<in> set p \\<Longrightarrow>\n            z \\<notin> roofed_gen \\<Gamma> B S\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>p y.\n        \\<lbrakk>path \\<Gamma> x p y; y \\<in> B; distinct (x # p);\n         \\<And>z.\n            z \\<in> set p \\<Longrightarrow>\n            z \\<notin> roofed_gen \\<Gamma> B S\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from assms"], ["proof (chain)\npicking this:\n  essential \\<Gamma> B S x", "obtain p y where p: \"path \\<Gamma> x p y\" and y: \"y \\<in> B\"\n    and bypass: \"\\<And>z. \\<lbrakk> x \\<noteq> y; z \\<in> set p \\<rbrakk> \\<Longrightarrow> z = x \\<or> z \\<notin> S\""], ["proof (prove)\nusing this:\n  essential \\<Gamma> B S x\n\ngoal (1 subgoal):\n 1. (\\<And>p y.\n        \\<lbrakk>path \\<Gamma> x p y; y \\<in> B;\n         \\<And>z.\n            \\<lbrakk>x \\<noteq> y; z \\<in> set p\\<rbrakk>\n            \\<Longrightarrow> z = x \\<or> z \\<notin> S\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(rule essentialE) blast"], ["proof (state)\nthis:\n  path \\<Gamma> x p y\n  y \\<in> B\n  \\<lbrakk>x \\<noteq> y; ?z \\<in> set p\\<rbrakk>\n  \\<Longrightarrow> ?z = x \\<or> ?z \\<notin> S\n\ngoal (1 subgoal):\n 1. (\\<And>p y.\n        \\<lbrakk>path \\<Gamma> x p y; y \\<in> B; distinct (x # p);\n         \\<And>z.\n            z \\<in> set p \\<Longrightarrow>\n            z \\<notin> roofed_gen \\<Gamma> B S\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from p"], ["proof (chain)\npicking this:\n  path \\<Gamma> x p y", "obtain p' where p': \"path \\<Gamma> x p' y\" and distinct: \"distinct (x # p')\"\n    and subset: \"set p' \\<subseteq> set p\""], ["proof (prove)\nusing this:\n  path \\<Gamma> x p y\n\ngoal (1 subgoal):\n 1. (\\<And>p'.\n        \\<lbrakk>path \\<Gamma> x p' y; distinct (x # p');\n         set p' \\<subseteq> set p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(rule rtrancl_path_distinct)"], ["proof (state)\nthis:\n  path \\<Gamma> x p' y\n  distinct (x # p')\n  set p' \\<subseteq> set p\n\ngoal (1 subgoal):\n 1. (\\<And>p y.\n        \\<lbrakk>path \\<Gamma> x p y; y \\<in> B; distinct (x # p);\n         \\<And>z.\n            z \\<in> set p \\<Longrightarrow>\n            z \\<notin> roofed_gen \\<Gamma> B S\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "{"], ["proof (state)\nthis:\n  path \\<Gamma> x p' y\n  distinct (x # p')\n  set p' \\<subseteq> set p\n\ngoal (1 subgoal):\n 1. (\\<And>p y.\n        \\<lbrakk>path \\<Gamma> x p y; y \\<in> B; distinct (x # p);\n         \\<And>z.\n            z \\<in> set p \\<Longrightarrow>\n            z \\<notin> roofed_gen \\<Gamma> B S\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "fix z"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>p y.\n        \\<lbrakk>path \\<Gamma> x p y; y \\<in> B; distinct (x # p);\n         \\<And>z.\n            z \\<in> set p \\<Longrightarrow>\n            z \\<notin> roofed_gen \\<Gamma> B S\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "assume z: \"z \\<in> set p'\""], ["proof (state)\nthis:\n  z \\<in> set p'\n\ngoal (1 subgoal):\n 1. (\\<And>p y.\n        \\<lbrakk>path \\<Gamma> x p y; y \\<in> B; distinct (x # p);\n         \\<And>z.\n            z \\<in> set p \\<Longrightarrow>\n            z \\<notin> roofed_gen \\<Gamma> B S\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "hence \"y \\<in> set p'\""], ["proof (prove)\nusing this:\n  z \\<in> set p'\n\ngoal (1 subgoal):\n 1. y \\<in> set p'", "using rtrancl_path_last[OF p', symmetric] p'"], ["proof (prove)\nusing this:\n  z \\<in> set p'\n  p' \\<noteq> [] \\<Longrightarrow> y = last p'\n  path \\<Gamma> x p' y\n\ngoal (1 subgoal):\n 1. y \\<in> set p'", "by(auto elim: rtrancl_path.cases intro: last_in_set)"], ["proof (state)\nthis:\n  y \\<in> set p'\n\ngoal (1 subgoal):\n 1. (\\<And>p y.\n        \\<lbrakk>path \\<Gamma> x p y; y \\<in> B; distinct (x # p);\n         \\<And>z.\n            z \\<in> set p \\<Longrightarrow>\n            z \\<notin> roofed_gen \\<Gamma> B S\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "with distinct z subset"], ["proof (chain)\npicking this:\n  distinct (x # p')\n  z \\<in> set p'\n  set p' \\<subseteq> set p\n  y \\<in> set p'", "have neq: \"x \\<noteq> y\" and \"z \\<in> set p\""], ["proof (prove)\nusing this:\n  distinct (x # p')\n  z \\<in> set p'\n  set p' \\<subseteq> set p\n  y \\<in> set p'\n\ngoal (1 subgoal):\n 1. x \\<noteq> y &&& z \\<in> set p", "by(auto)"], ["proof (state)\nthis:\n  x \\<noteq> y\n  z \\<in> set p\n\ngoal (1 subgoal):\n 1. (\\<And>p y.\n        \\<lbrakk>path \\<Gamma> x p y; y \\<in> B; distinct (x # p);\n         \\<And>z.\n            z \\<in> set p \\<Longrightarrow>\n            z \\<notin> roofed_gen \\<Gamma> B S\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from bypass[OF this] z distinct"], ["proof (chain)\npicking this:\n  z = x \\<or> z \\<notin> S\n  z \\<in> set p'\n  distinct (x # p')", "have \"z \\<notin> S\""], ["proof (prove)\nusing this:\n  z = x \\<or> z \\<notin> S\n  z \\<in> set p'\n  distinct (x # p')\n\ngoal (1 subgoal):\n 1. z \\<notin> S", "by auto"], ["proof (state)\nthis:\n  z \\<notin> S\n\ngoal (1 subgoal):\n 1. (\\<And>p y.\n        \\<lbrakk>path \\<Gamma> x p y; y \\<in> B; distinct (x # p);\n         \\<And>z.\n            z \\<in> set p \\<Longrightarrow>\n            z \\<notin> roofed_gen \\<Gamma> B S\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"z \\<notin> roofed_gen \\<Gamma> B S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z \\<notin> roofed_gen \\<Gamma> B S", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. z \\<in> roofed_gen \\<Gamma> B S \\<Longrightarrow> False", "assume z': \"z \\<in> roofed_gen \\<Gamma> B S\""], ["proof (state)\nthis:\n  z \\<in> roofed_gen \\<Gamma> B S\n\ngoal (1 subgoal):\n 1. z \\<in> roofed_gen \\<Gamma> B S \\<Longrightarrow> False", "from split_list[OF z]"], ["proof (chain)\npicking this:\n  \\<exists>ys zs. p' = ys @ z # zs", "obtain ys zs where decomp: \"p' = ys @ z # zs\""], ["proof (prove)\nusing this:\n  \\<exists>ys zs. p' = ys @ z # zs\n\ngoal (1 subgoal):\n 1. (\\<And>ys zs.\n        p' = ys @ z # zs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  p' = ys @ z # zs\n\ngoal (1 subgoal):\n 1. z \\<in> roofed_gen \\<Gamma> B S \\<Longrightarrow> False", "with p'"], ["proof (chain)\npicking this:\n  path \\<Gamma> x p' y\n  p' = ys @ z # zs", "have \"path \\<Gamma> z zs y\""], ["proof (prove)\nusing this:\n  path \\<Gamma> x p' y\n  p' = ys @ z # zs\n\ngoal (1 subgoal):\n 1. path \\<Gamma> z zs y", "by(auto elim: rtrancl_path_appendE)"], ["proof (state)\nthis:\n  path \\<Gamma> z zs y\n\ngoal (1 subgoal):\n 1. z \\<in> roofed_gen \\<Gamma> B S \\<Longrightarrow> False", "from roofedD[OF z' this y] \\<open>z \\<notin> S\\<close>"], ["proof (chain)\npicking this:\n  (\\<exists>z\\<in>set zs. z \\<in> S) \\<or> z \\<in> S\n  z \\<notin> S", "obtain z' where \"z' \\<in> set zs\" \"z' \\<in> S\""], ["proof (prove)\nusing this:\n  (\\<exists>z\\<in>set zs. z \\<in> S) \\<or> z \\<in> S\n  z \\<notin> S\n\ngoal (1 subgoal):\n 1. (\\<And>z'.\n        \\<lbrakk>z' \\<in> set zs; z' \\<in> S\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  z' \\<in> set zs\n  z' \\<in> S\n\ngoal (1 subgoal):\n 1. z \\<in> roofed_gen \\<Gamma> B S \\<Longrightarrow> False", "with bypass[of z'] neq decomp subset distinct"], ["proof (chain)\npicking this:\n  \\<lbrakk>x \\<noteq> y; z' \\<in> set p\\<rbrakk>\n  \\<Longrightarrow> z' = x \\<or> z' \\<notin> S\n  x \\<noteq> y\n  p' = ys @ z # zs\n  set p' \\<subseteq> set p\n  distinct (x # p')\n  z' \\<in> set zs\n  z' \\<in> S", "show False"], ["proof (prove)\nusing this:\n  \\<lbrakk>x \\<noteq> y; z' \\<in> set p\\<rbrakk>\n  \\<Longrightarrow> z' = x \\<or> z' \\<notin> S\n  x \\<noteq> y\n  p' = ys @ z # zs\n  set p' \\<subseteq> set p\n  distinct (x # p')\n  z' \\<in> set zs\n  z' \\<in> S\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  z \\<notin> roofed_gen \\<Gamma> B S\n\ngoal (1 subgoal):\n 1. (\\<And>p y.\n        \\<lbrakk>path \\<Gamma> x p y; y \\<in> B; distinct (x # p);\n         \\<And>z.\n            z \\<in> set p \\<Longrightarrow>\n            z \\<notin> roofed_gen \\<Gamma> B S\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "}"], ["proof (state)\nthis:\n  ?z2 \\<in> set p' \\<Longrightarrow> ?z2 \\<notin> roofed_gen \\<Gamma> B S\n\ngoal (1 subgoal):\n 1. (\\<And>p y.\n        \\<lbrakk>path \\<Gamma> x p y; y \\<in> B; distinct (x # p);\n         \\<And>z.\n            z \\<in> set p \\<Longrightarrow>\n            z \\<notin> roofed_gen \\<Gamma> B S\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "with p' y distinct"], ["proof (chain)\npicking this:\n  path \\<Gamma> x p' y\n  y \\<in> B\n  distinct (x # p')\n  ?z2 \\<in> set p' \\<Longrightarrow> ?z2 \\<notin> roofed_gen \\<Gamma> B S", "show thesis"], ["proof (prove)\nusing this:\n  path \\<Gamma> x p' y\n  y \\<in> B\n  distinct (x # p')\n  ?z2 \\<in> set p' \\<Longrightarrow> ?z2 \\<notin> roofed_gen \\<Gamma> B S\n\ngoal (1 subgoal):\n 1. thesis", ".."], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma \\<E>_E_RF:\n  fixes \\<Gamma> (structure)\n  assumes \"x \\<in> \\<E> S\"\n  obtains p y where \"path \\<Gamma> x p y\" \"y \\<in> B \\<Gamma>\" \"distinct (x # p)\" \"\\<And>z. z \\<in> set p \\<Longrightarrow> z \\<notin> RF S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>p y.\n        \\<lbrakk>path \\<Gamma> x p y; y \\<in> B \\<Gamma>; distinct (x # p);\n         \\<And>z. z \\<in> set p \\<Longrightarrow> z \\<notin> RF S\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  x \\<in> \\<E> S\n\ngoal (1 subgoal):\n 1. (\\<And>p y.\n        \\<lbrakk>path \\<Gamma> x p y; y \\<in> B \\<Gamma>; distinct (x # p);\n         \\<And>z. z \\<in> set p \\<Longrightarrow> z \\<notin> RF S\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto elim: essentialE_RF)"], ["", "lemma in_roofed_essentialD:\n  fixes \\<Gamma> (structure)\n  assumes RF: \"x \\<in> RF S\"\n  and ess: \"essential \\<Gamma> (B \\<Gamma>) S x\"\n  shows \"x \\<in> S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> S", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<in> S", "from ess"], ["proof (chain)\npicking this:\n  essential \\<Gamma> (B \\<Gamma>) S x", "obtain p y where p: \"path \\<Gamma> x p y\" and y: \"y \\<in> B \\<Gamma>\" and \"distinct (x # p)\"\n    and bypass: \"\\<And>z. z \\<in> set p \\<Longrightarrow> z \\<notin> S\""], ["proof (prove)\nusing this:\n  essential \\<Gamma> (B \\<Gamma>) S x\n\ngoal (1 subgoal):\n 1. (\\<And>p y.\n        \\<lbrakk>path \\<Gamma> x p y; y \\<in> B \\<Gamma>; distinct (x # p);\n         \\<And>z. z \\<in> set p \\<Longrightarrow> z \\<notin> S\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(rule essentialE_RF)(auto intro: roofed_greaterI)"], ["proof (state)\nthis:\n  path \\<Gamma> x p y\n  y \\<in> B \\<Gamma>\n  distinct (x # p)\n  ?z \\<in> set p \\<Longrightarrow> ?z \\<notin> S\n\ngoal (1 subgoal):\n 1. x \\<in> S", "from roofedD[OF RF p y] bypass"], ["proof (chain)\npicking this:\n  (\\<exists>z\\<in>set p. z \\<in> S) \\<or> x \\<in> S\n  ?z \\<in> set p \\<Longrightarrow> ?z \\<notin> S", "show \"x \\<in> S\""], ["proof (prove)\nusing this:\n  (\\<exists>z\\<in>set p. z \\<in> S) \\<or> x \\<in> S\n  ?z \\<in> set p \\<Longrightarrow> ?z \\<notin> S\n\ngoal (1 subgoal):\n 1. x \\<in> S", "by auto"], ["proof (state)\nthis:\n  x \\<in> S\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma separating_RF: fixes \\<Gamma> (structure) shows \"separating \\<Gamma> (RF S) \\<longleftrightarrow> separating \\<Gamma> S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. separating \\<Gamma> (RF S) = separating \\<Gamma> S", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. separating \\<Gamma> (RF S) \\<Longrightarrow> separating \\<Gamma> S\n 2. separating \\<Gamma> S \\<Longrightarrow> separating \\<Gamma> (RF S)", "assume sep: \"separating \\<Gamma> (RF S)\""], ["proof (state)\nthis:\n  separating \\<Gamma> (RF S)\n\ngoal (2 subgoals):\n 1. separating \\<Gamma> (RF S) \\<Longrightarrow> separating \\<Gamma> S\n 2. separating \\<Gamma> S \\<Longrightarrow> separating \\<Gamma> (RF S)", "show \"separating \\<Gamma> S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. separating \\<Gamma> S", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y p.\n       \\<lbrakk>x \\<in> A \\<Gamma>; y \\<in> B \\<Gamma>;\n        path \\<Gamma> x p y\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>z\\<in>set p. z \\<in> S) \\<or> x \\<in> S", "fix x y p"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y p.\n       \\<lbrakk>x \\<in> A \\<Gamma>; y \\<in> B \\<Gamma>;\n        path \\<Gamma> x p y\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>z\\<in>set p. z \\<in> S) \\<or> x \\<in> S", "assume p: \"path \\<Gamma> x p y\" and x: \"x \\<in> A \\<Gamma>\" and y: \"y \\<in> B \\<Gamma>\""], ["proof (state)\nthis:\n  path \\<Gamma> x p y\n  x \\<in> A \\<Gamma>\n  y \\<in> B \\<Gamma>\n\ngoal (1 subgoal):\n 1. \\<And>x y p.\n       \\<lbrakk>x \\<in> A \\<Gamma>; y \\<in> B \\<Gamma>;\n        path \\<Gamma> x p y\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>z\\<in>set p. z \\<in> S) \\<or> x \\<in> S", "from separatingD[OF sep p x y]"], ["proof (chain)\npicking this:\n  (\\<exists>z\\<in>set p. z \\<in> RF S) \\<or> x \\<in> RF S", "have \"\\<exists>z \\<in> set (x # p). z \\<in> RF S\""], ["proof (prove)\nusing this:\n  (\\<exists>z\\<in>set p. z \\<in> RF S) \\<or> x \\<in> RF S\n\ngoal (1 subgoal):\n 1. \\<exists>z\\<in>set (x # p). z \\<in> RF S", "by auto"], ["proof (state)\nthis:\n  \\<exists>z\\<in>set (x # p). z \\<in> RF S\n\ngoal (1 subgoal):\n 1. \\<And>x y p.\n       \\<lbrakk>x \\<in> A \\<Gamma>; y \\<in> B \\<Gamma>;\n        path \\<Gamma> x p y\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>z\\<in>set p. z \\<in> S) \\<or> x \\<in> S", "from split_list_last_prop[OF this]"], ["proof (chain)\npicking this:\n  \\<exists>ys xa zs.\n     x # p = ys @ xa # zs \\<and>\n     xa \\<in> RF S \\<and> (\\<forall>z\\<in>set zs. z \\<notin> RF S)", "obtain ys z zs where split: \"x # p = ys @ z # zs\"\n      and z: \"z \\<in> RF S\" and bypass: \"\\<And>z'. z' \\<in> set zs \\<Longrightarrow> z' \\<notin> RF S\""], ["proof (prove)\nusing this:\n  \\<exists>ys xa zs.\n     x # p = ys @ xa # zs \\<and>\n     xa \\<in> RF S \\<and> (\\<forall>z\\<in>set zs. z \\<notin> RF S)\n\ngoal (1 subgoal):\n 1. (\\<And>ys z zs.\n        \\<lbrakk>x # p = ys @ z # zs; z \\<in> RF S;\n         \\<And>z'.\n            z' \\<in> set zs \\<Longrightarrow> z' \\<notin> RF S\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  x # p = ys @ z # zs\n  z \\<in> RF S\n  ?z' \\<in> set zs \\<Longrightarrow> ?z' \\<notin> RF S\n\ngoal (1 subgoal):\n 1. \\<And>x y p.\n       \\<lbrakk>x \\<in> A \\<Gamma>; y \\<in> B \\<Gamma>;\n        path \\<Gamma> x p y\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>z\\<in>set p. z \\<in> S) \\<or> x \\<in> S", "from p split"], ["proof (chain)\npicking this:\n  path \\<Gamma> x p y\n  x # p = ys @ z # zs", "have \"path \\<Gamma> z zs y\""], ["proof (prove)\nusing this:\n  path \\<Gamma> x p y\n  x # p = ys @ z # zs\n\ngoal (1 subgoal):\n 1. path \\<Gamma> z zs y", "by(cases ys)(auto elim: rtrancl_path_appendE)"], ["proof (state)\nthis:\n  path \\<Gamma> z zs y\n\ngoal (1 subgoal):\n 1. \\<And>x y p.\n       \\<lbrakk>x \\<in> A \\<Gamma>; y \\<in> B \\<Gamma>;\n        path \\<Gamma> x p y\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>z\\<in>set p. z \\<in> S) \\<or> x \\<in> S", "hence \"essential \\<Gamma> (B \\<Gamma>) S z\""], ["proof (prove)\nusing this:\n  path \\<Gamma> z zs y\n\ngoal (1 subgoal):\n 1. essential \\<Gamma> (B \\<Gamma>) S z", "using y"], ["proof (prove)\nusing this:\n  path \\<Gamma> z zs y\n  y \\<in> B \\<Gamma>\n\ngoal (1 subgoal):\n 1. essential \\<Gamma> (B \\<Gamma>) S z", "by(rule essentialI)(auto dest: bypass intro: roofed_greaterI)"], ["proof (state)\nthis:\n  essential \\<Gamma> (B \\<Gamma>) S z\n\ngoal (1 subgoal):\n 1. \\<And>x y p.\n       \\<lbrakk>x \\<in> A \\<Gamma>; y \\<in> B \\<Gamma>;\n        path \\<Gamma> x p y\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>z\\<in>set p. z \\<in> S) \\<or> x \\<in> S", "with z"], ["proof (chain)\npicking this:\n  z \\<in> RF S\n  essential \\<Gamma> (B \\<Gamma>) S z", "have \"z \\<in> S\""], ["proof (prove)\nusing this:\n  z \\<in> RF S\n  essential \\<Gamma> (B \\<Gamma>) S z\n\ngoal (1 subgoal):\n 1. z \\<in> S", "by(rule in_roofed_essentialD)"], ["proof (state)\nthis:\n  z \\<in> S\n\ngoal (1 subgoal):\n 1. \\<And>x y p.\n       \\<lbrakk>x \\<in> A \\<Gamma>; y \\<in> B \\<Gamma>;\n        path \\<Gamma> x p y\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>z\\<in>set p. z \\<in> S) \\<or> x \\<in> S", "with split"], ["proof (chain)\npicking this:\n  x # p = ys @ z # zs\n  z \\<in> S", "show \"(\\<exists>z\\<in>set p. z \\<in> S) \\<or> x \\<in> S\""], ["proof (prove)\nusing this:\n  x # p = ys @ z # zs\n  z \\<in> S\n\ngoal (1 subgoal):\n 1. (\\<exists>z\\<in>set p. z \\<in> S) \\<or> x \\<in> S", "by(cases ys)auto"], ["proof (state)\nthis:\n  (\\<exists>z\\<in>set p. z \\<in> S) \\<or> x \\<in> S\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  separating \\<Gamma> S\n\ngoal (1 subgoal):\n 1. separating \\<Gamma> S \\<Longrightarrow> separating \\<Gamma> (RF S)", "qed(blast intro: roofed_greaterI separating_weakening)"], ["", "definition roofed_circ :: \"('v, 'more) web_scheme \\<Rightarrow> 'v set \\<Rightarrow> 'v set\" (\"RF\\<^sup>\\<circ>\\<index>\")\nwhere \"roofed_circ \\<Gamma> S = roofed \\<Gamma> S - \\<E>\\<^bsub>\\<Gamma>\\<^esub> S\""], ["", "lemma roofed_circI: fixes \\<Gamma> (structure) shows\n  \"\\<lbrakk> x \\<in> RF T; x \\<in> T \\<Longrightarrow> \\<not> essential \\<Gamma> (B \\<Gamma>) T x \\<rbrakk> \\<Longrightarrow> x \\<in> RF\\<^sup>\\<circ> T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> RF T;\n     x \\<in> T \\<Longrightarrow>\n     \\<not> essential \\<Gamma> (B \\<Gamma>) T x\\<rbrakk>\n    \\<Longrightarrow> x \\<in> RF\\<^sup>\\<circ> T", "by(simp add: roofed_circ_def)"], ["", "lemma roofed_circE:\n  fixes \\<Gamma> (structure)\n  assumes \"x \\<in> RF\\<^sup>\\<circ> T\"\n  obtains \"x \\<in> RF T\" \"\\<not> essential \\<Gamma> (B \\<Gamma>) T x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>x \\<in> RF T;\n      \\<not> essential \\<Gamma> (B \\<Gamma>) T x\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  x \\<in> RF\\<^sup>\\<circ> T\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>x \\<in> RF T;\n      \\<not> essential \\<Gamma> (B \\<Gamma>) T x\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto simp add: roofed_circ_def intro: in_roofed_essentialD)"], ["", "lemma \\<E>_\\<E>: fixes \\<Gamma> (structure) shows \"\\<E> (\\<E> S) = \\<E> S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<E> (\\<E> S) = \\<E> S", "by(auto intro: essential_mono)"], ["", "lemma roofed_circ_essential: fixes \\<Gamma> (structure) shows \"RF\\<^sup>\\<circ> (\\<E> S) = RF\\<^sup>\\<circ> S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RF\\<^sup>\\<circ> (\\<E> S) = RF\\<^sup>\\<circ> S", "unfolding roofed_circ_def RF_essential \\<E>_\\<E>"], ["proof (prove)\ngoal (1 subgoal):\n 1. RF S - \\<E> S = RF S - \\<E> S", ".."], ["", "lemma essential_RF: fixes B\n  shows \"essential G B (roofed_gen G B S) = essential G B S\"  (is \"essential _ _ ?RF = _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. essential G B (roofed_gen G B S) = essential G B S", "proof(intro ext iffI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       essential G B (roofed_gen G B S) x \\<Longrightarrow>\n       essential G B S x\n 2. \\<And>x.\n       essential G B S x \\<Longrightarrow>\n       essential G B (roofed_gen G B S) x", "show \"essential G B S x\" if \"essential G B ?RF x\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. essential G B S x", "using that"], ["proof (prove)\nusing this:\n  essential G B (roofed_gen G B S) x\n\ngoal (1 subgoal):\n 1. essential G B S x", "by(rule essential_mono)(blast intro: roofed_greaterI)"], ["proof (state)\nthis:\n  essential G B (roofed_gen G B S) ?x \\<Longrightarrow> essential G B S ?x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       essential G B S x \\<Longrightarrow>\n       essential G B (roofed_gen G B S) x", "show \"essential G B ?RF x\" if \"essential G B S x\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. essential G B (roofed_gen G B S) x", "using that"], ["proof (prove)\nusing this:\n  essential G B S x\n\ngoal (1 subgoal):\n 1. essential G B (roofed_gen G B S) x", "by(rule essentialE_RF)(erule (1) essentialI, blast)"], ["proof (state)\nthis:\n  essential G B S ?x \\<Longrightarrow> essential G B (roofed_gen G B S) ?x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma \\<E>_RF: fixes \\<Gamma> (structure) shows \"\\<E> (RF S) = \\<E> S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<E> (RF S) = \\<E> S", "by(auto dest: in_roofed_essentialD simp add: essential_RF intro: roofed_greaterI)"], ["", "lemma essential_\\<E>: fixes \\<Gamma> (structure) shows \"essential \\<Gamma> (B \\<Gamma>) (\\<E> S) = essential \\<Gamma> (B \\<Gamma>) S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. essential \\<Gamma> (B \\<Gamma>) (\\<E> S) =\n    essential \\<Gamma> (B \\<Gamma>) S", "by(subst essential_RF[symmetric])(simp only: RF_essential essential_RF)"], ["", "lemma RF_in_B: fixes \\<Gamma> (structure) shows \"x \\<in> B \\<Gamma> \\<Longrightarrow> x \\<in> RF S \\<longleftrightarrow> x \\<in> S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> B \\<Gamma> \\<Longrightarrow> (x \\<in> RF S) = (x \\<in> S)", "by(auto intro: roofed_greaterI dest: roofedD[OF _ rtrancl_path.base])"], ["", "lemma RF_circ_edge_forward:\n  fixes \\<Gamma> (structure)\n  assumes x: \"x \\<in> RF\\<^sup>\\<circ> S\"\n  and edge: \"edge \\<Gamma> x y\"\n  shows \"y \\<in> RF S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<in> RF S", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p ya.\n       \\<lbrakk>path \\<Gamma> y p ya; ya \\<in> B \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>z\\<in>set p. z \\<in> S) \\<or> y \\<in> S", "fix p z"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p ya.\n       \\<lbrakk>path \\<Gamma> y p ya; ya \\<in> B \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>z\\<in>set p. z \\<in> S) \\<or> y \\<in> S", "assume p: \"path \\<Gamma> y p z\" and z: \"z \\<in> B \\<Gamma>\""], ["proof (state)\nthis:\n  path \\<Gamma> y p z\n  z \\<in> B \\<Gamma>\n\ngoal (1 subgoal):\n 1. \\<And>p ya.\n       \\<lbrakk>path \\<Gamma> y p ya; ya \\<in> B \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>z\\<in>set p. z \\<in> S) \\<or> y \\<in> S", "from x"], ["proof (chain)\npicking this:\n  x \\<in> RF\\<^sup>\\<circ> S", "have rf: \"x \\<in> RF S\" and ness: \"x \\<notin> \\<E> S\""], ["proof (prove)\nusing this:\n  x \\<in> RF\\<^sup>\\<circ> S\n\ngoal (1 subgoal):\n 1. x \\<in> RF S &&& x \\<notin> \\<E> S", "by(auto elim: roofed_circE)"], ["proof (state)\nthis:\n  x \\<in> RF S\n  x \\<notin> \\<E> S\n\ngoal (1 subgoal):\n 1. \\<And>p ya.\n       \\<lbrakk>path \\<Gamma> y p ya; ya \\<in> B \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>z\\<in>set p. z \\<in> S) \\<or> y \\<in> S", "show \"(\\<exists>z\\<in>set p. z \\<in> S) \\<or> y \\<in> S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>z\\<in>set p. z \\<in> S) \\<or> y \\<in> S", "proof(cases \"\\<exists>z'\\<in>set (y # p). z' \\<in> S\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>z'\\<in>set (y # p). z' \\<in> S \\<Longrightarrow>\n    (\\<exists>z\\<in>set p. z \\<in> S) \\<or> y \\<in> S\n 2. \\<not> (\\<exists>z'\\<in>set (y # p). z' \\<in> S) \\<Longrightarrow>\n    (\\<exists>z\\<in>set p. z \\<in> S) \\<or> y \\<in> S", "case False"], ["proof (state)\nthis:\n  \\<not> (\\<exists>z'\\<in>set (y # p). z' \\<in> S)\n\ngoal (2 subgoals):\n 1. \\<exists>z'\\<in>set (y # p). z' \\<in> S \\<Longrightarrow>\n    (\\<exists>z\\<in>set p. z \\<in> S) \\<or> y \\<in> S\n 2. \\<not> (\\<exists>z'\\<in>set (y # p). z' \\<in> S) \\<Longrightarrow>\n    (\\<exists>z\\<in>set p. z \\<in> S) \\<or> y \\<in> S", "from edge p"], ["proof (chain)\npicking this:\n  edge \\<Gamma> x y\n  path \\<Gamma> y p z", "have p': \"path \\<Gamma> x (y # p) z\""], ["proof (prove)\nusing this:\n  edge \\<Gamma> x y\n  path \\<Gamma> y p z\n\ngoal (1 subgoal):\n 1. path \\<Gamma> x (y # p) z", ".."], ["proof (state)\nthis:\n  path \\<Gamma> x (y # p) z\n\ngoal (2 subgoals):\n 1. \\<exists>z'\\<in>set (y # p). z' \\<in> S \\<Longrightarrow>\n    (\\<exists>z\\<in>set p. z \\<in> S) \\<or> y \\<in> S\n 2. \\<not> (\\<exists>z'\\<in>set (y # p). z' \\<in> S) \\<Longrightarrow>\n    (\\<exists>z\\<in>set p. z \\<in> S) \\<or> y \\<in> S", "from roofedD[OF rf this z] False"], ["proof (chain)\npicking this:\n  (\\<exists>z\\<in>set (y # p). z \\<in> S) \\<or> x \\<in> S\n  \\<not> (\\<exists>z'\\<in>set (y # p). z' \\<in> S)", "have \"x \\<in> S\""], ["proof (prove)\nusing this:\n  (\\<exists>z\\<in>set (y # p). z \\<in> S) \\<or> x \\<in> S\n  \\<not> (\\<exists>z'\\<in>set (y # p). z' \\<in> S)\n\ngoal (1 subgoal):\n 1. x \\<in> S", "by auto"], ["proof (state)\nthis:\n  x \\<in> S\n\ngoal (2 subgoals):\n 1. \\<exists>z'\\<in>set (y # p). z' \\<in> S \\<Longrightarrow>\n    (\\<exists>z\\<in>set p. z \\<in> S) \\<or> y \\<in> S\n 2. \\<not> (\\<exists>z'\\<in>set (y # p). z' \\<in> S) \\<Longrightarrow>\n    (\\<exists>z\\<in>set p. z \\<in> S) \\<or> y \\<in> S", "moreover"], ["proof (state)\nthis:\n  x \\<in> S\n\ngoal (2 subgoals):\n 1. \\<exists>z'\\<in>set (y # p). z' \\<in> S \\<Longrightarrow>\n    (\\<exists>z\\<in>set p. z \\<in> S) \\<or> y \\<in> S\n 2. \\<not> (\\<exists>z'\\<in>set (y # p). z' \\<in> S) \\<Longrightarrow>\n    (\\<exists>z\\<in>set p. z \\<in> S) \\<or> y \\<in> S", "have \"essential \\<Gamma> (B \\<Gamma>) S x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. essential \\<Gamma> (B \\<Gamma>) S x", "using p' False z"], ["proof (prove)\nusing this:\n  path \\<Gamma> x (y # p) z\n  \\<not> (\\<exists>z'\\<in>set (y # p). z' \\<in> S)\n  z \\<in> B \\<Gamma>\n\ngoal (1 subgoal):\n 1. essential \\<Gamma> (B \\<Gamma>) S x", "by(auto intro!: essentialI)"], ["proof (state)\nthis:\n  essential \\<Gamma> (B \\<Gamma>) S x\n\ngoal (2 subgoals):\n 1. \\<exists>z'\\<in>set (y # p). z' \\<in> S \\<Longrightarrow>\n    (\\<exists>z\\<in>set p. z \\<in> S) \\<or> y \\<in> S\n 2. \\<not> (\\<exists>z'\\<in>set (y # p). z' \\<in> S) \\<Longrightarrow>\n    (\\<exists>z\\<in>set p. z \\<in> S) \\<or> y \\<in> S", "ultimately"], ["proof (chain)\npicking this:\n  x \\<in> S\n  essential \\<Gamma> (B \\<Gamma>) S x", "have \"x \\<in> \\<E> S\""], ["proof (prove)\nusing this:\n  x \\<in> S\n  essential \\<Gamma> (B \\<Gamma>) S x\n\ngoal (1 subgoal):\n 1. x \\<in> \\<E> S", "by simp"], ["proof (state)\nthis:\n  x \\<in> \\<E> S\n\ngoal (2 subgoals):\n 1. \\<exists>z'\\<in>set (y # p). z' \\<in> S \\<Longrightarrow>\n    (\\<exists>z\\<in>set p. z \\<in> S) \\<or> y \\<in> S\n 2. \\<not> (\\<exists>z'\\<in>set (y # p). z' \\<in> S) \\<Longrightarrow>\n    (\\<exists>z\\<in>set p. z \\<in> S) \\<or> y \\<in> S", "with ness"], ["proof (chain)\npicking this:\n  x \\<notin> \\<E> S\n  x \\<in> \\<E> S", "show ?thesis"], ["proof (prove)\nusing this:\n  x \\<notin> \\<E> S\n  x \\<in> \\<E> S\n\ngoal (1 subgoal):\n 1. (\\<exists>z\\<in>set p. z \\<in> S) \\<or> y \\<in> S", "by contradiction"], ["proof (state)\nthis:\n  (\\<exists>z\\<in>set p. z \\<in> S) \\<or> y \\<in> S\n\ngoal (1 subgoal):\n 1. \\<exists>z'\\<in>set (y # p). z' \\<in> S \\<Longrightarrow>\n    (\\<exists>z\\<in>set p. z \\<in> S) \\<or> y \\<in> S", "qed auto"], ["proof (state)\nthis:\n  (\\<exists>z\\<in>set p. z \\<in> S) \\<or> y \\<in> S\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Waves\\<close>"], ["", "inductive wave :: \"('v, 'more) web_scheme \\<Rightarrow> 'v current \\<Rightarrow> bool\"\n  for \\<Gamma> (structure) and f\nwhere\n  wave:\n  \"\\<lbrakk> separating \\<Gamma> (TER f);\n     \\<And>x. x \\<notin> RF (TER f) \\<Longrightarrow> d_OUT f x = 0 \\<rbrakk>\n  \\<Longrightarrow> wave \\<Gamma> f\""], ["", "lemma wave_0 [simp]: \"wave \\<Gamma> zero_current\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wave \\<Gamma> (\\<lambda>_. 0)", "by rule simp_all"], ["", "lemma waveD_separating: \"wave \\<Gamma> f \\<Longrightarrow> separating \\<Gamma> (TER\\<^bsub>\\<Gamma>\\<^esub> f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wave \\<Gamma> f \\<Longrightarrow>\n    separating \\<Gamma> (TER\\<^bsub>\\<Gamma>\\<^esub> f)", "by(simp add: wave.simps)"], ["", "lemma waveD_OUT: \"\\<lbrakk> wave \\<Gamma> f; x \\<notin> RF\\<^bsub>\\<Gamma>\\<^esub> (TER\\<^bsub>\\<Gamma>\\<^esub> f) \\<rbrakk> \\<Longrightarrow> d_OUT f x = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wave \\<Gamma> f;\n     x \\<notin> RF\\<^bsub>\\<Gamma>\\<^esub>\n                 (TER\\<^bsub>\\<Gamma>\\<^esub> f)\\<rbrakk>\n    \\<Longrightarrow> d_OUT f x = 0", "by(simp add: wave.simps)"], ["", "lemma wave_A_in_RF: fixes \\<Gamma> (structure)\n  shows \"\\<lbrakk> wave \\<Gamma> f; x \\<in> A \\<Gamma> \\<rbrakk> \\<Longrightarrow> x \\<in> RF (TER f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wave \\<Gamma> f; x \\<in> A \\<Gamma>\\<rbrakk>\n    \\<Longrightarrow> x \\<in> RF (TER f)", "by(auto intro!: roofedI dest!: waveD_separating separatingD)"], ["", "lemma wave_not_RF_IN_zero:\n  fixes \\<Gamma> (structure)\n  assumes f: \"current \\<Gamma> f\"\n  and w: \"wave \\<Gamma> f\"\n  and x: \"x \\<notin> RF (TER f)\"\n  shows \"d_IN f x = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN f x = 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. d_IN f x = 0", "from x"], ["proof (chain)\npicking this:\n  x \\<notin> RF (TER f)", "obtain p z where z: \"z \\<in> B \\<Gamma>\" and p: \"path \\<Gamma> x p z\"\n    and bypass: \"\\<And>z. z \\<in> set p \\<Longrightarrow> z \\<notin> TER f\" \"x \\<notin> TER f\""], ["proof (prove)\nusing this:\n  x \\<notin> RF (TER f)\n\ngoal (1 subgoal):\n 1. (\\<And>z p.\n        \\<lbrakk>z \\<in> B \\<Gamma>; path \\<Gamma> x p z;\n         \\<And>z. z \\<in> set p \\<Longrightarrow> z \\<notin> TER f;\n         x \\<notin> TER f\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(clarsimp simp add: roofed_def)"], ["proof (state)\nthis:\n  z \\<in> B \\<Gamma>\n  path \\<Gamma> x p z\n  ?z \\<in> set p \\<Longrightarrow> ?z \\<notin> TER f\n  x \\<notin> TER f\n\ngoal (1 subgoal):\n 1. d_IN f x = 0", "have \"f (y, x) = 0\" for y"], ["proof (prove)\ngoal (1 subgoal):\n 1. f (y, x) = 0", "proof(cases \"edge \\<Gamma> y x\")"], ["proof (state)\ngoal (2 subgoals):\n 1. edge \\<Gamma> y x \\<Longrightarrow> f (y, x) = 0\n 2. \\<not> edge \\<Gamma> y x \\<Longrightarrow> f (y, x) = 0", "case edge: True"], ["proof (state)\nthis:\n  edge \\<Gamma> y x\n\ngoal (2 subgoals):\n 1. edge \\<Gamma> y x \\<Longrightarrow> f (y, x) = 0\n 2. \\<not> edge \\<Gamma> y x \\<Longrightarrow> f (y, x) = 0", "have \"d_OUT f y = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT f y = 0", "proof(cases \"y \\<in> TER f\")"], ["proof (state)\ngoal (2 subgoals):\n 1. y \\<in> TER f \\<Longrightarrow> d_OUT f y = 0\n 2. y \\<notin> TER f \\<Longrightarrow> d_OUT f y = 0", "case False"], ["proof (state)\nthis:\n  y \\<notin> TER f\n\ngoal (2 subgoals):\n 1. y \\<in> TER f \\<Longrightarrow> d_OUT f y = 0\n 2. y \\<notin> TER f \\<Longrightarrow> d_OUT f y = 0", "with z p bypass edge"], ["proof (chain)\npicking this:\n  z \\<in> B \\<Gamma>\n  path \\<Gamma> x p z\n  ?z \\<in> set p \\<Longrightarrow> ?z \\<notin> TER f\n  x \\<notin> TER f\n  edge \\<Gamma> y x\n  y \\<notin> TER f", "have \"y \\<notin> RF (TER f)\""], ["proof (prove)\nusing this:\n  z \\<in> B \\<Gamma>\n  path \\<Gamma> x p z\n  ?z \\<in> set p \\<Longrightarrow> ?z \\<notin> TER f\n  x \\<notin> TER f\n  edge \\<Gamma> y x\n  y \\<notin> TER f\n\ngoal (1 subgoal):\n 1. y \\<notin> RF (TER f)", "by(auto simp add: roofed_def intro: rtrancl_path.step intro!: exI rev_bexI)"], ["proof (state)\nthis:\n  y \\<notin> RF (TER f)\n\ngoal (2 subgoals):\n 1. y \\<in> TER f \\<Longrightarrow> d_OUT f y = 0\n 2. y \\<notin> TER f \\<Longrightarrow> d_OUT f y = 0", "thus \"d_OUT f y = 0\""], ["proof (prove)\nusing this:\n  y \\<notin> RF (TER f)\n\ngoal (1 subgoal):\n 1. d_OUT f y = 0", "by(rule waveD_OUT[OF w])"], ["proof (state)\nthis:\n  d_OUT f y = 0\n\ngoal (1 subgoal):\n 1. y \\<in> TER f \\<Longrightarrow> d_OUT f y = 0", "qed(auto simp add: SINK.simps)"], ["proof (state)\nthis:\n  d_OUT f y = 0\n\ngoal (2 subgoals):\n 1. edge \\<Gamma> y x \\<Longrightarrow> f (y, x) = 0\n 2. \\<not> edge \\<Gamma> y x \\<Longrightarrow> f (y, x) = 0", "moreover"], ["proof (state)\nthis:\n  d_OUT f y = 0\n\ngoal (2 subgoals):\n 1. edge \\<Gamma> y x \\<Longrightarrow> f (y, x) = 0\n 2. \\<not> edge \\<Gamma> y x \\<Longrightarrow> f (y, x) = 0", "have \"f (y, x) \\<le> d_OUT f y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f (y, x) \\<le> d_OUT f y", "by (rule d_OUT_ge_point)"], ["proof (state)\nthis:\n  f (y, x) \\<le> d_OUT f y\n\ngoal (2 subgoals):\n 1. edge \\<Gamma> y x \\<Longrightarrow> f (y, x) = 0\n 2. \\<not> edge \\<Gamma> y x \\<Longrightarrow> f (y, x) = 0", "ultimately"], ["proof (chain)\npicking this:\n  d_OUT f y = 0\n  f (y, x) \\<le> d_OUT f y", "show ?thesis"], ["proof (prove)\nusing this:\n  d_OUT f y = 0\n  f (y, x) \\<le> d_OUT f y\n\ngoal (1 subgoal):\n 1. f (y, x) = 0", "by simp"], ["proof (state)\nthis:\n  f (y, x) = 0\n\ngoal (1 subgoal):\n 1. \\<not> edge \\<Gamma> y x \\<Longrightarrow> f (y, x) = 0", "qed(simp add: currentD_outside[OF f])"], ["proof (state)\nthis:\n  f (?y, x) = 0\n\ngoal (1 subgoal):\n 1. d_IN f x = 0", "then"], ["proof (chain)\npicking this:\n  f (?y, x) = 0", "show \"d_IN f x = 0\""], ["proof (prove)\nusing this:\n  f (?y, x) = 0\n\ngoal (1 subgoal):\n 1. d_IN f x = 0", "unfolding d_IN_def"], ["proof (prove)\nusing this:\n  f (?y, x) = 0\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ xa. f (xa, x)) = 0", "by(simp add: nn_integral_0_iff emeasure_count_space_eq_0)"], ["proof (state)\nthis:\n  d_IN f x = 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma current_Sup:\n  fixes \\<Gamma> (structure)\n  assumes chain: \"Complete_Partial_Order.chain (\\<le>) Y\"\n  and Y: \"Y \\<noteq> {}\"\n  and current: \"\\<And>f. f \\<in> Y \\<Longrightarrow> current \\<Gamma> f\"\n  and countable [simp]: \"countable (support_flow (Sup Y))\"\n  shows \"current \\<Gamma> (Sup Y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. current \\<Gamma> (\\<Squnion> Y)", "proof(rule, goal_cases)"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>x. d_OUT (\\<Squnion> Y) x \\<le> weight \\<Gamma> x\n 2. \\<And>x. d_IN (\\<Squnion> Y) x \\<le> weight \\<Gamma> x\n 3. \\<And>x.\n       x \\<notin> A \\<Gamma> \\<Longrightarrow>\n       d_OUT (\\<Squnion> Y) x \\<le> d_IN (\\<Squnion> Y) x\n 4. \\<And>a. a \\<in> A \\<Gamma> \\<Longrightarrow> d_IN (\\<Squnion> Y) a = 0\n 5. \\<And>b. b \\<in> B \\<Gamma> \\<Longrightarrow> d_OUT (\\<Squnion> Y) b = 0\n 6. \\<And>e. e \\<notin> \\<^bold>E \\<Longrightarrow> (\\<Squnion> Y) e = 0", "case (1 x)"], ["proof (state)\nthis:\n  \n\ngoal (6 subgoals):\n 1. \\<And>x. d_OUT (\\<Squnion> Y) x \\<le> weight \\<Gamma> x\n 2. \\<And>x. d_IN (\\<Squnion> Y) x \\<le> weight \\<Gamma> x\n 3. \\<And>x.\n       x \\<notin> A \\<Gamma> \\<Longrightarrow>\n       d_OUT (\\<Squnion> Y) x \\<le> d_IN (\\<Squnion> Y) x\n 4. \\<And>a. a \\<in> A \\<Gamma> \\<Longrightarrow> d_IN (\\<Squnion> Y) a = 0\n 5. \\<And>b. b \\<in> B \\<Gamma> \\<Longrightarrow> d_OUT (\\<Squnion> Y) b = 0\n 6. \\<And>e. e \\<notin> \\<^bold>E \\<Longrightarrow> (\\<Squnion> Y) e = 0", "have \"d_OUT (Sup Y) x = (SUP f\\<in>Y. d_OUT f x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT (\\<Squnion> Y) x = (\\<Squnion>f\\<in>Y. d_OUT f x)", "using chain Y"], ["proof (prove)\nusing this:\n  Complete_Partial_Order.chain (\\<le>) Y\n  Y \\<noteq> {}\n\ngoal (1 subgoal):\n 1. d_OUT (\\<Squnion> Y) x = (\\<Squnion>f\\<in>Y. d_OUT f x)", "by(simp add: d_OUT_Sup)"], ["proof (state)\nthis:\n  d_OUT (\\<Squnion> Y) x = (\\<Squnion>f\\<in>Y. d_OUT f x)\n\ngoal (6 subgoals):\n 1. \\<And>x. d_OUT (\\<Squnion> Y) x \\<le> weight \\<Gamma> x\n 2. \\<And>x. d_IN (\\<Squnion> Y) x \\<le> weight \\<Gamma> x\n 3. \\<And>x.\n       x \\<notin> A \\<Gamma> \\<Longrightarrow>\n       d_OUT (\\<Squnion> Y) x \\<le> d_IN (\\<Squnion> Y) x\n 4. \\<And>a. a \\<in> A \\<Gamma> \\<Longrightarrow> d_IN (\\<Squnion> Y) a = 0\n 5. \\<And>b. b \\<in> B \\<Gamma> \\<Longrightarrow> d_OUT (\\<Squnion> Y) b = 0\n 6. \\<And>e. e \\<notin> \\<^bold>E \\<Longrightarrow> (\\<Squnion> Y) e = 0", "also"], ["proof (state)\nthis:\n  d_OUT (\\<Squnion> Y) x = (\\<Squnion>f\\<in>Y. d_OUT f x)\n\ngoal (6 subgoals):\n 1. \\<And>x. d_OUT (\\<Squnion> Y) x \\<le> weight \\<Gamma> x\n 2. \\<And>x. d_IN (\\<Squnion> Y) x \\<le> weight \\<Gamma> x\n 3. \\<And>x.\n       x \\<notin> A \\<Gamma> \\<Longrightarrow>\n       d_OUT (\\<Squnion> Y) x \\<le> d_IN (\\<Squnion> Y) x\n 4. \\<And>a. a \\<in> A \\<Gamma> \\<Longrightarrow> d_IN (\\<Squnion> Y) a = 0\n 5. \\<And>b. b \\<in> B \\<Gamma> \\<Longrightarrow> d_OUT (\\<Squnion> Y) b = 0\n 6. \\<And>e. e \\<notin> \\<^bold>E \\<Longrightarrow> (\\<Squnion> Y) e = 0", "have \"\\<dots> \\<le> weight \\<Gamma> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Squnion>f\\<in>Y. d_OUT f x) \\<le> weight \\<Gamma> x", "using 1"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Squnion>f\\<in>Y. d_OUT f x) \\<le> weight \\<Gamma> x", "by(intro SUP_least)(auto dest!: current currentD_weight_OUT)"], ["proof (state)\nthis:\n  (\\<Squnion>f\\<in>Y. d_OUT f x) \\<le> weight \\<Gamma> x\n\ngoal (6 subgoals):\n 1. \\<And>x. d_OUT (\\<Squnion> Y) x \\<le> weight \\<Gamma> x\n 2. \\<And>x. d_IN (\\<Squnion> Y) x \\<le> weight \\<Gamma> x\n 3. \\<And>x.\n       x \\<notin> A \\<Gamma> \\<Longrightarrow>\n       d_OUT (\\<Squnion> Y) x \\<le> d_IN (\\<Squnion> Y) x\n 4. \\<And>a. a \\<in> A \\<Gamma> \\<Longrightarrow> d_IN (\\<Squnion> Y) a = 0\n 5. \\<And>b. b \\<in> B \\<Gamma> \\<Longrightarrow> d_OUT (\\<Squnion> Y) b = 0\n 6. \\<And>e. e \\<notin> \\<^bold>E \\<Longrightarrow> (\\<Squnion> Y) e = 0", "finally"], ["proof (chain)\npicking this:\n  d_OUT (\\<Squnion> Y) x \\<le> weight \\<Gamma> x", "show ?case"], ["proof (prove)\nusing this:\n  d_OUT (\\<Squnion> Y) x \\<le> weight \\<Gamma> x\n\ngoal (1 subgoal):\n 1. d_OUT (\\<Squnion> Y) x \\<le> weight \\<Gamma> x", "."], ["proof (state)\nthis:\n  d_OUT (\\<Squnion> Y) x \\<le> weight \\<Gamma> x\n\ngoal (5 subgoals):\n 1. \\<And>x. d_IN (\\<Squnion> Y) x \\<le> weight \\<Gamma> x\n 2. \\<And>x.\n       x \\<notin> A \\<Gamma> \\<Longrightarrow>\n       d_OUT (\\<Squnion> Y) x \\<le> d_IN (\\<Squnion> Y) x\n 3. \\<And>a. a \\<in> A \\<Gamma> \\<Longrightarrow> d_IN (\\<Squnion> Y) a = 0\n 4. \\<And>b. b \\<in> B \\<Gamma> \\<Longrightarrow> d_OUT (\\<Squnion> Y) b = 0\n 5. \\<And>e. e \\<notin> \\<^bold>E \\<Longrightarrow> (\\<Squnion> Y) e = 0", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>x. d_IN (\\<Squnion> Y) x \\<le> weight \\<Gamma> x\n 2. \\<And>x.\n       x \\<notin> A \\<Gamma> \\<Longrightarrow>\n       d_OUT (\\<Squnion> Y) x \\<le> d_IN (\\<Squnion> Y) x\n 3. \\<And>a. a \\<in> A \\<Gamma> \\<Longrightarrow> d_IN (\\<Squnion> Y) a = 0\n 4. \\<And>b. b \\<in> B \\<Gamma> \\<Longrightarrow> d_OUT (\\<Squnion> Y) b = 0\n 5. \\<And>e. e \\<notin> \\<^bold>E \\<Longrightarrow> (\\<Squnion> Y) e = 0", "case (2 x)"], ["proof (state)\nthis:\n  \n\ngoal (5 subgoals):\n 1. \\<And>x. d_IN (\\<Squnion> Y) x \\<le> weight \\<Gamma> x\n 2. \\<And>x.\n       x \\<notin> A \\<Gamma> \\<Longrightarrow>\n       d_OUT (\\<Squnion> Y) x \\<le> d_IN (\\<Squnion> Y) x\n 3. \\<And>a. a \\<in> A \\<Gamma> \\<Longrightarrow> d_IN (\\<Squnion> Y) a = 0\n 4. \\<And>b. b \\<in> B \\<Gamma> \\<Longrightarrow> d_OUT (\\<Squnion> Y) b = 0\n 5. \\<And>e. e \\<notin> \\<^bold>E \\<Longrightarrow> (\\<Squnion> Y) e = 0", "have \"d_IN (Sup Y) x = (SUP f\\<in>Y. d_IN f x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN (\\<Squnion> Y) x = (\\<Squnion>f\\<in>Y. d_IN f x)", "using chain Y"], ["proof (prove)\nusing this:\n  Complete_Partial_Order.chain (\\<le>) Y\n  Y \\<noteq> {}\n\ngoal (1 subgoal):\n 1. d_IN (\\<Squnion> Y) x = (\\<Squnion>f\\<in>Y. d_IN f x)", "by(simp add: d_IN_Sup)"], ["proof (state)\nthis:\n  d_IN (\\<Squnion> Y) x = (\\<Squnion>f\\<in>Y. d_IN f x)\n\ngoal (5 subgoals):\n 1. \\<And>x. d_IN (\\<Squnion> Y) x \\<le> weight \\<Gamma> x\n 2. \\<And>x.\n       x \\<notin> A \\<Gamma> \\<Longrightarrow>\n       d_OUT (\\<Squnion> Y) x \\<le> d_IN (\\<Squnion> Y) x\n 3. \\<And>a. a \\<in> A \\<Gamma> \\<Longrightarrow> d_IN (\\<Squnion> Y) a = 0\n 4. \\<And>b. b \\<in> B \\<Gamma> \\<Longrightarrow> d_OUT (\\<Squnion> Y) b = 0\n 5. \\<And>e. e \\<notin> \\<^bold>E \\<Longrightarrow> (\\<Squnion> Y) e = 0", "also"], ["proof (state)\nthis:\n  d_IN (\\<Squnion> Y) x = (\\<Squnion>f\\<in>Y. d_IN f x)\n\ngoal (5 subgoals):\n 1. \\<And>x. d_IN (\\<Squnion> Y) x \\<le> weight \\<Gamma> x\n 2. \\<And>x.\n       x \\<notin> A \\<Gamma> \\<Longrightarrow>\n       d_OUT (\\<Squnion> Y) x \\<le> d_IN (\\<Squnion> Y) x\n 3. \\<And>a. a \\<in> A \\<Gamma> \\<Longrightarrow> d_IN (\\<Squnion> Y) a = 0\n 4. \\<And>b. b \\<in> B \\<Gamma> \\<Longrightarrow> d_OUT (\\<Squnion> Y) b = 0\n 5. \\<And>e. e \\<notin> \\<^bold>E \\<Longrightarrow> (\\<Squnion> Y) e = 0", "have \"\\<dots> \\<le> weight \\<Gamma> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Squnion>f\\<in>Y. d_IN f x) \\<le> weight \\<Gamma> x", "using 2"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Squnion>f\\<in>Y. d_IN f x) \\<le> weight \\<Gamma> x", "by(intro SUP_least)(auto dest!: current currentD_weight_IN)"], ["proof (state)\nthis:\n  (\\<Squnion>f\\<in>Y. d_IN f x) \\<le> weight \\<Gamma> x\n\ngoal (5 subgoals):\n 1. \\<And>x. d_IN (\\<Squnion> Y) x \\<le> weight \\<Gamma> x\n 2. \\<And>x.\n       x \\<notin> A \\<Gamma> \\<Longrightarrow>\n       d_OUT (\\<Squnion> Y) x \\<le> d_IN (\\<Squnion> Y) x\n 3. \\<And>a. a \\<in> A \\<Gamma> \\<Longrightarrow> d_IN (\\<Squnion> Y) a = 0\n 4. \\<And>b. b \\<in> B \\<Gamma> \\<Longrightarrow> d_OUT (\\<Squnion> Y) b = 0\n 5. \\<And>e. e \\<notin> \\<^bold>E \\<Longrightarrow> (\\<Squnion> Y) e = 0", "finally"], ["proof (chain)\npicking this:\n  d_IN (\\<Squnion> Y) x \\<le> weight \\<Gamma> x", "show ?case"], ["proof (prove)\nusing this:\n  d_IN (\\<Squnion> Y) x \\<le> weight \\<Gamma> x\n\ngoal (1 subgoal):\n 1. d_IN (\\<Squnion> Y) x \\<le> weight \\<Gamma> x", "."], ["proof (state)\nthis:\n  d_IN (\\<Squnion> Y) x \\<le> weight \\<Gamma> x\n\ngoal (4 subgoals):\n 1. \\<And>x.\n       x \\<notin> A \\<Gamma> \\<Longrightarrow>\n       d_OUT (\\<Squnion> Y) x \\<le> d_IN (\\<Squnion> Y) x\n 2. \\<And>a. a \\<in> A \\<Gamma> \\<Longrightarrow> d_IN (\\<Squnion> Y) a = 0\n 3. \\<And>b. b \\<in> B \\<Gamma> \\<Longrightarrow> d_OUT (\\<Squnion> Y) b = 0\n 4. \\<And>e. e \\<notin> \\<^bold>E \\<Longrightarrow> (\\<Squnion> Y) e = 0", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x.\n       x \\<notin> A \\<Gamma> \\<Longrightarrow>\n       d_OUT (\\<Squnion> Y) x \\<le> d_IN (\\<Squnion> Y) x\n 2. \\<And>a. a \\<in> A \\<Gamma> \\<Longrightarrow> d_IN (\\<Squnion> Y) a = 0\n 3. \\<And>b. b \\<in> B \\<Gamma> \\<Longrightarrow> d_OUT (\\<Squnion> Y) b = 0\n 4. \\<And>e. e \\<notin> \\<^bold>E \\<Longrightarrow> (\\<Squnion> Y) e = 0", "case (3 x)"], ["proof (state)\nthis:\n  x \\<notin> A \\<Gamma>\n\ngoal (4 subgoals):\n 1. \\<And>x.\n       x \\<notin> A \\<Gamma> \\<Longrightarrow>\n       d_OUT (\\<Squnion> Y) x \\<le> d_IN (\\<Squnion> Y) x\n 2. \\<And>a. a \\<in> A \\<Gamma> \\<Longrightarrow> d_IN (\\<Squnion> Y) a = 0\n 3. \\<And>b. b \\<in> B \\<Gamma> \\<Longrightarrow> d_OUT (\\<Squnion> Y) b = 0\n 4. \\<And>e. e \\<notin> \\<^bold>E \\<Longrightarrow> (\\<Squnion> Y) e = 0", "have \"d_OUT (Sup Y) x = (SUP f\\<in>Y. d_OUT f x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT (\\<Squnion> Y) x = (\\<Squnion>f\\<in>Y. d_OUT f x)", "using chain Y"], ["proof (prove)\nusing this:\n  Complete_Partial_Order.chain (\\<le>) Y\n  Y \\<noteq> {}\n\ngoal (1 subgoal):\n 1. d_OUT (\\<Squnion> Y) x = (\\<Squnion>f\\<in>Y. d_OUT f x)", "by(simp add: d_OUT_Sup)"], ["proof (state)\nthis:\n  d_OUT (\\<Squnion> Y) x = (\\<Squnion>f\\<in>Y. d_OUT f x)\n\ngoal (4 subgoals):\n 1. \\<And>x.\n       x \\<notin> A \\<Gamma> \\<Longrightarrow>\n       d_OUT (\\<Squnion> Y) x \\<le> d_IN (\\<Squnion> Y) x\n 2. \\<And>a. a \\<in> A \\<Gamma> \\<Longrightarrow> d_IN (\\<Squnion> Y) a = 0\n 3. \\<And>b. b \\<in> B \\<Gamma> \\<Longrightarrow> d_OUT (\\<Squnion> Y) b = 0\n 4. \\<And>e. e \\<notin> \\<^bold>E \\<Longrightarrow> (\\<Squnion> Y) e = 0", "also"], ["proof (state)\nthis:\n  d_OUT (\\<Squnion> Y) x = (\\<Squnion>f\\<in>Y. d_OUT f x)\n\ngoal (4 subgoals):\n 1. \\<And>x.\n       x \\<notin> A \\<Gamma> \\<Longrightarrow>\n       d_OUT (\\<Squnion> Y) x \\<le> d_IN (\\<Squnion> Y) x\n 2. \\<And>a. a \\<in> A \\<Gamma> \\<Longrightarrow> d_IN (\\<Squnion> Y) a = 0\n 3. \\<And>b. b \\<in> B \\<Gamma> \\<Longrightarrow> d_OUT (\\<Squnion> Y) b = 0\n 4. \\<And>e. e \\<notin> \\<^bold>E \\<Longrightarrow> (\\<Squnion> Y) e = 0", "have \"\\<dots> \\<le> (SUP f\\<in>Y. d_IN f x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Squnion>f\\<in>Y. d_OUT f x) \\<le> (\\<Squnion>f\\<in>Y. d_IN f x)", "using 3"], ["proof (prove)\nusing this:\n  x \\<notin> A \\<Gamma>\n\ngoal (1 subgoal):\n 1. (\\<Squnion>f\\<in>Y. d_OUT f x) \\<le> (\\<Squnion>f\\<in>Y. d_IN f x)", "by(intro SUP_mono)(auto dest: current currentD_OUT_IN)"], ["proof (state)\nthis:\n  (\\<Squnion>f\\<in>Y. d_OUT f x) \\<le> (\\<Squnion>f\\<in>Y. d_IN f x)\n\ngoal (4 subgoals):\n 1. \\<And>x.\n       x \\<notin> A \\<Gamma> \\<Longrightarrow>\n       d_OUT (\\<Squnion> Y) x \\<le> d_IN (\\<Squnion> Y) x\n 2. \\<And>a. a \\<in> A \\<Gamma> \\<Longrightarrow> d_IN (\\<Squnion> Y) a = 0\n 3. \\<And>b. b \\<in> B \\<Gamma> \\<Longrightarrow> d_OUT (\\<Squnion> Y) b = 0\n 4. \\<And>e. e \\<notin> \\<^bold>E \\<Longrightarrow> (\\<Squnion> Y) e = 0", "also"], ["proof (state)\nthis:\n  (\\<Squnion>f\\<in>Y. d_OUT f x) \\<le> (\\<Squnion>f\\<in>Y. d_IN f x)\n\ngoal (4 subgoals):\n 1. \\<And>x.\n       x \\<notin> A \\<Gamma> \\<Longrightarrow>\n       d_OUT (\\<Squnion> Y) x \\<le> d_IN (\\<Squnion> Y) x\n 2. \\<And>a. a \\<in> A \\<Gamma> \\<Longrightarrow> d_IN (\\<Squnion> Y) a = 0\n 3. \\<And>b. b \\<in> B \\<Gamma> \\<Longrightarrow> d_OUT (\\<Squnion> Y) b = 0\n 4. \\<And>e. e \\<notin> \\<^bold>E \\<Longrightarrow> (\\<Squnion> Y) e = 0", "have \"\\<dots> = d_IN (Sup Y) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Squnion>f\\<in>Y. d_IN f x) = d_IN (\\<Squnion> Y) x", "using chain Y"], ["proof (prove)\nusing this:\n  Complete_Partial_Order.chain (\\<le>) Y\n  Y \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<Squnion>f\\<in>Y. d_IN f x) = d_IN (\\<Squnion> Y) x", "by(simp add: d_IN_Sup)"], ["proof (state)\nthis:\n  (\\<Squnion>f\\<in>Y. d_IN f x) = d_IN (\\<Squnion> Y) x\n\ngoal (4 subgoals):\n 1. \\<And>x.\n       x \\<notin> A \\<Gamma> \\<Longrightarrow>\n       d_OUT (\\<Squnion> Y) x \\<le> d_IN (\\<Squnion> Y) x\n 2. \\<And>a. a \\<in> A \\<Gamma> \\<Longrightarrow> d_IN (\\<Squnion> Y) a = 0\n 3. \\<And>b. b \\<in> B \\<Gamma> \\<Longrightarrow> d_OUT (\\<Squnion> Y) b = 0\n 4. \\<And>e. e \\<notin> \\<^bold>E \\<Longrightarrow> (\\<Squnion> Y) e = 0", "finally"], ["proof (chain)\npicking this:\n  d_OUT (\\<Squnion> Y) x \\<le> d_IN (\\<Squnion> Y) x", "show ?case"], ["proof (prove)\nusing this:\n  d_OUT (\\<Squnion> Y) x \\<le> d_IN (\\<Squnion> Y) x\n\ngoal (1 subgoal):\n 1. d_OUT (\\<Squnion> Y) x \\<le> d_IN (\\<Squnion> Y) x", "."], ["proof (state)\nthis:\n  d_OUT (\\<Squnion> Y) x \\<le> d_IN (\\<Squnion> Y) x\n\ngoal (3 subgoals):\n 1. \\<And>a. a \\<in> A \\<Gamma> \\<Longrightarrow> d_IN (\\<Squnion> Y) a = 0\n 2. \\<And>b. b \\<in> B \\<Gamma> \\<Longrightarrow> d_OUT (\\<Squnion> Y) b = 0\n 3. \\<And>e. e \\<notin> \\<^bold>E \\<Longrightarrow> (\\<Squnion> Y) e = 0", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>a. a \\<in> A \\<Gamma> \\<Longrightarrow> d_IN (\\<Squnion> Y) a = 0\n 2. \\<And>b. b \\<in> B \\<Gamma> \\<Longrightarrow> d_OUT (\\<Squnion> Y) b = 0\n 3. \\<And>e. e \\<notin> \\<^bold>E \\<Longrightarrow> (\\<Squnion> Y) e = 0", "case (4 a)"], ["proof (state)\nthis:\n  a \\<in> A \\<Gamma>\n\ngoal (3 subgoals):\n 1. \\<And>a. a \\<in> A \\<Gamma> \\<Longrightarrow> d_IN (\\<Squnion> Y) a = 0\n 2. \\<And>b. b \\<in> B \\<Gamma> \\<Longrightarrow> d_OUT (\\<Squnion> Y) b = 0\n 3. \\<And>e. e \\<notin> \\<^bold>E \\<Longrightarrow> (\\<Squnion> Y) e = 0", "have \"d_IN (Sup Y) a = (SUP f\\<in>Y. d_IN f a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN (\\<Squnion> Y) a = (\\<Squnion>f\\<in>Y. d_IN f a)", "using chain Y"], ["proof (prove)\nusing this:\n  Complete_Partial_Order.chain (\\<le>) Y\n  Y \\<noteq> {}\n\ngoal (1 subgoal):\n 1. d_IN (\\<Squnion> Y) a = (\\<Squnion>f\\<in>Y. d_IN f a)", "by(simp add: d_IN_Sup)"], ["proof (state)\nthis:\n  d_IN (\\<Squnion> Y) a = (\\<Squnion>f\\<in>Y. d_IN f a)\n\ngoal (3 subgoals):\n 1. \\<And>a. a \\<in> A \\<Gamma> \\<Longrightarrow> d_IN (\\<Squnion> Y) a = 0\n 2. \\<And>b. b \\<in> B \\<Gamma> \\<Longrightarrow> d_OUT (\\<Squnion> Y) b = 0\n 3. \\<And>e. e \\<notin> \\<^bold>E \\<Longrightarrow> (\\<Squnion> Y) e = 0", "also"], ["proof (state)\nthis:\n  d_IN (\\<Squnion> Y) a = (\\<Squnion>f\\<in>Y. d_IN f a)\n\ngoal (3 subgoals):\n 1. \\<And>a. a \\<in> A \\<Gamma> \\<Longrightarrow> d_IN (\\<Squnion> Y) a = 0\n 2. \\<And>b. b \\<in> B \\<Gamma> \\<Longrightarrow> d_OUT (\\<Squnion> Y) b = 0\n 3. \\<And>e. e \\<notin> \\<^bold>E \\<Longrightarrow> (\\<Squnion> Y) e = 0", "have \"\\<dots> = (SUP f\\<in>Y. 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Squnion>f\\<in>Y. d_IN f a) = (\\<Squnion>f\\<in>Y. 0)", "using 4"], ["proof (prove)\nusing this:\n  a \\<in> A \\<Gamma>\n\ngoal (1 subgoal):\n 1. (\\<Squnion>f\\<in>Y. d_IN f a) = (\\<Squnion>f\\<in>Y. 0)", "by(intro SUP_cong)(auto dest!: current currentD_IN)"], ["proof (state)\nthis:\n  (\\<Squnion>f\\<in>Y. d_IN f a) = (\\<Squnion>f\\<in>Y. 0)\n\ngoal (3 subgoals):\n 1. \\<And>a. a \\<in> A \\<Gamma> \\<Longrightarrow> d_IN (\\<Squnion> Y) a = 0\n 2. \\<And>b. b \\<in> B \\<Gamma> \\<Longrightarrow> d_OUT (\\<Squnion> Y) b = 0\n 3. \\<And>e. e \\<notin> \\<^bold>E \\<Longrightarrow> (\\<Squnion> Y) e = 0", "also"], ["proof (state)\nthis:\n  (\\<Squnion>f\\<in>Y. d_IN f a) = (\\<Squnion>f\\<in>Y. 0)\n\ngoal (3 subgoals):\n 1. \\<And>a. a \\<in> A \\<Gamma> \\<Longrightarrow> d_IN (\\<Squnion> Y) a = 0\n 2. \\<And>b. b \\<in> B \\<Gamma> \\<Longrightarrow> d_OUT (\\<Squnion> Y) b = 0\n 3. \\<And>e. e \\<notin> \\<^bold>E \\<Longrightarrow> (\\<Squnion> Y) e = 0", "have \"\\<dots> = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Squnion>f\\<in>Y. 0) = 0", "using Y"], ["proof (prove)\nusing this:\n  Y \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<Squnion>f\\<in>Y. 0) = 0", "by simp"], ["proof (state)\nthis:\n  (\\<Squnion>f\\<in>Y. 0) = 0\n\ngoal (3 subgoals):\n 1. \\<And>a. a \\<in> A \\<Gamma> \\<Longrightarrow> d_IN (\\<Squnion> Y) a = 0\n 2. \\<And>b. b \\<in> B \\<Gamma> \\<Longrightarrow> d_OUT (\\<Squnion> Y) b = 0\n 3. \\<And>e. e \\<notin> \\<^bold>E \\<Longrightarrow> (\\<Squnion> Y) e = 0", "finally"], ["proof (chain)\npicking this:\n  d_IN (\\<Squnion> Y) a = 0", "show ?case"], ["proof (prove)\nusing this:\n  d_IN (\\<Squnion> Y) a = 0\n\ngoal (1 subgoal):\n 1. d_IN (\\<Squnion> Y) a = 0", "."], ["proof (state)\nthis:\n  d_IN (\\<Squnion> Y) a = 0\n\ngoal (2 subgoals):\n 1. \\<And>b. b \\<in> B \\<Gamma> \\<Longrightarrow> d_OUT (\\<Squnion> Y) b = 0\n 2. \\<And>e. e \\<notin> \\<^bold>E \\<Longrightarrow> (\\<Squnion> Y) e = 0", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>b. b \\<in> B \\<Gamma> \\<Longrightarrow> d_OUT (\\<Squnion> Y) b = 0\n 2. \\<And>e. e \\<notin> \\<^bold>E \\<Longrightarrow> (\\<Squnion> Y) e = 0", "case (5 b)"], ["proof (state)\nthis:\n  b \\<in> B \\<Gamma>\n\ngoal (2 subgoals):\n 1. \\<And>b. b \\<in> B \\<Gamma> \\<Longrightarrow> d_OUT (\\<Squnion> Y) b = 0\n 2. \\<And>e. e \\<notin> \\<^bold>E \\<Longrightarrow> (\\<Squnion> Y) e = 0", "have \"d_OUT (Sup Y) b = (SUP f\\<in>Y. d_OUT f b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT (\\<Squnion> Y) b = (\\<Squnion>f\\<in>Y. d_OUT f b)", "using chain Y"], ["proof (prove)\nusing this:\n  Complete_Partial_Order.chain (\\<le>) Y\n  Y \\<noteq> {}\n\ngoal (1 subgoal):\n 1. d_OUT (\\<Squnion> Y) b = (\\<Squnion>f\\<in>Y. d_OUT f b)", "by(simp add: d_OUT_Sup)"], ["proof (state)\nthis:\n  d_OUT (\\<Squnion> Y) b = (\\<Squnion>f\\<in>Y. d_OUT f b)\n\ngoal (2 subgoals):\n 1. \\<And>b. b \\<in> B \\<Gamma> \\<Longrightarrow> d_OUT (\\<Squnion> Y) b = 0\n 2. \\<And>e. e \\<notin> \\<^bold>E \\<Longrightarrow> (\\<Squnion> Y) e = 0", "also"], ["proof (state)\nthis:\n  d_OUT (\\<Squnion> Y) b = (\\<Squnion>f\\<in>Y. d_OUT f b)\n\ngoal (2 subgoals):\n 1. \\<And>b. b \\<in> B \\<Gamma> \\<Longrightarrow> d_OUT (\\<Squnion> Y) b = 0\n 2. \\<And>e. e \\<notin> \\<^bold>E \\<Longrightarrow> (\\<Squnion> Y) e = 0", "have \"\\<dots> = (SUP f\\<in>Y. 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Squnion>f\\<in>Y. d_OUT f b) = (\\<Squnion>f\\<in>Y. 0)", "using 5"], ["proof (prove)\nusing this:\n  b \\<in> B \\<Gamma>\n\ngoal (1 subgoal):\n 1. (\\<Squnion>f\\<in>Y. d_OUT f b) = (\\<Squnion>f\\<in>Y. 0)", "by(intro SUP_cong)(auto dest!: current currentD_OUT)"], ["proof (state)\nthis:\n  (\\<Squnion>f\\<in>Y. d_OUT f b) = (\\<Squnion>f\\<in>Y. 0)\n\ngoal (2 subgoals):\n 1. \\<And>b. b \\<in> B \\<Gamma> \\<Longrightarrow> d_OUT (\\<Squnion> Y) b = 0\n 2. \\<And>e. e \\<notin> \\<^bold>E \\<Longrightarrow> (\\<Squnion> Y) e = 0", "also"], ["proof (state)\nthis:\n  (\\<Squnion>f\\<in>Y. d_OUT f b) = (\\<Squnion>f\\<in>Y. 0)\n\ngoal (2 subgoals):\n 1. \\<And>b. b \\<in> B \\<Gamma> \\<Longrightarrow> d_OUT (\\<Squnion> Y) b = 0\n 2. \\<And>e. e \\<notin> \\<^bold>E \\<Longrightarrow> (\\<Squnion> Y) e = 0", "have \"\\<dots> = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Squnion>f\\<in>Y. 0) = 0", "using Y"], ["proof (prove)\nusing this:\n  Y \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<Squnion>f\\<in>Y. 0) = 0", "by simp"], ["proof (state)\nthis:\n  (\\<Squnion>f\\<in>Y. 0) = 0\n\ngoal (2 subgoals):\n 1. \\<And>b. b \\<in> B \\<Gamma> \\<Longrightarrow> d_OUT (\\<Squnion> Y) b = 0\n 2. \\<And>e. e \\<notin> \\<^bold>E \\<Longrightarrow> (\\<Squnion> Y) e = 0", "finally"], ["proof (chain)\npicking this:\n  d_OUT (\\<Squnion> Y) b = 0", "show ?case"], ["proof (prove)\nusing this:\n  d_OUT (\\<Squnion> Y) b = 0\n\ngoal (1 subgoal):\n 1. d_OUT (\\<Squnion> Y) b = 0", "."], ["proof (state)\nthis:\n  d_OUT (\\<Squnion> Y) b = 0\n\ngoal (1 subgoal):\n 1. \\<And>e. e \\<notin> \\<^bold>E \\<Longrightarrow> (\\<Squnion> Y) e = 0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>e. e \\<notin> \\<^bold>E \\<Longrightarrow> (\\<Squnion> Y) e = 0", "fix e"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>e. e \\<notin> \\<^bold>E \\<Longrightarrow> (\\<Squnion> Y) e = 0", "assume \"e \\<notin> \\<^bold>E\""], ["proof (state)\nthis:\n  e \\<notin> \\<^bold>E\n\ngoal (1 subgoal):\n 1. \\<And>e. e \\<notin> \\<^bold>E \\<Longrightarrow> (\\<Squnion> Y) e = 0", "from currentD_outside'[OF current this]"], ["proof (chain)\npicking this:\n  ?f \\<in> Y \\<Longrightarrow> ?f e = 0", "have \"f e = 0\" if \"f \\<in> Y\" for f"], ["proof (prove)\nusing this:\n  ?f \\<in> Y \\<Longrightarrow> ?f e = 0\n\ngoal (1 subgoal):\n 1. f e = 0", "using that"], ["proof (prove)\nusing this:\n  ?f \\<in> Y \\<Longrightarrow> ?f e = 0\n  f \\<in> Y\n\ngoal (1 subgoal):\n 1. f e = 0", "by simp"], ["proof (state)\nthis:\n  ?f \\<in> Y \\<Longrightarrow> ?f e = 0\n\ngoal (1 subgoal):\n 1. \\<And>e. e \\<notin> \\<^bold>E \\<Longrightarrow> (\\<Squnion> Y) e = 0", "hence \"Sup Y e = (SUP _\\<in>Y. 0)\""], ["proof (prove)\nusing this:\n  ?f \\<in> Y \\<Longrightarrow> ?f e = 0\n\ngoal (1 subgoal):\n 1. (\\<Squnion> Y) e = (\\<Squnion>_\\<in>Y. 0)", "by(auto intro: SUP_cong)"], ["proof (state)\nthis:\n  (\\<Squnion> Y) e = (\\<Squnion>_\\<in>Y. 0)\n\ngoal (1 subgoal):\n 1. \\<And>e. e \\<notin> \\<^bold>E \\<Longrightarrow> (\\<Squnion> Y) e = 0", "then"], ["proof (chain)\npicking this:\n  (\\<Squnion> Y) e = (\\<Squnion>_\\<in>Y. 0)", "show \"Sup Y e = 0\""], ["proof (prove)\nusing this:\n  (\\<Squnion> Y) e = (\\<Squnion>_\\<in>Y. 0)\n\ngoal (1 subgoal):\n 1. (\\<Squnion> Y) e = 0", "using Y"], ["proof (prove)\nusing this:\n  (\\<Squnion> Y) e = (\\<Squnion>_\\<in>Y. 0)\n  Y \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<Squnion> Y) e = 0", "by(simp)"], ["proof (state)\nthis:\n  (\\<Squnion> Y) e = 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma wave_lub: \\<comment> \\<open>Lemma 4.3\\<close>\n  fixes \\<Gamma> (structure)\n  assumes chain: \"Complete_Partial_Order.chain (\\<le>) Y\"\n  and Y: \"Y \\<noteq> {}\"\n  and wave: \"\\<And>f. f \\<in> Y \\<Longrightarrow> wave \\<Gamma> f\"\n  and countable [simp]: \"countable (support_flow (Sup Y))\"\n  shows \"wave \\<Gamma> (Sup Y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wave \\<Gamma> (\\<Squnion> Y)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. separating \\<Gamma> (TER (\\<Squnion> Y))\n 2. \\<And>x.\n       x \\<notin> RF (TER (\\<Squnion> Y)) \\<Longrightarrow>\n       d_OUT (\\<Squnion> Y) x = 0", "{"], ["proof (state)\ngoal (2 subgoals):\n 1. separating \\<Gamma> (TER (\\<Squnion> Y))\n 2. \\<And>x.\n       x \\<notin> RF (TER (\\<Squnion> Y)) \\<Longrightarrow>\n       d_OUT (\\<Squnion> Y) x = 0", "fix x y p"], ["proof (state)\ngoal (2 subgoals):\n 1. separating \\<Gamma> (TER (\\<Squnion> Y))\n 2. \\<And>x.\n       x \\<notin> RF (TER (\\<Squnion> Y)) \\<Longrightarrow>\n       d_OUT (\\<Squnion> Y) x = 0", "assume p: \"path \\<Gamma> x p y\" and y: \"y \\<in> B \\<Gamma>\""], ["proof (state)\nthis:\n  path \\<Gamma> x p y\n  y \\<in> B \\<Gamma>\n\ngoal (2 subgoals):\n 1. separating \\<Gamma> (TER (\\<Squnion> Y))\n 2. \\<And>x.\n       x \\<notin> RF (TER (\\<Squnion> Y)) \\<Longrightarrow>\n       d_OUT (\\<Squnion> Y) x = 0", "define P where \"P = {x} \\<union> set p\""], ["proof (state)\nthis:\n  P = {x} \\<union> set p\n\ngoal (2 subgoals):\n 1. separating \\<Gamma> (TER (\\<Squnion> Y))\n 2. \\<And>x.\n       x \\<notin> RF (TER (\\<Squnion> Y)) \\<Longrightarrow>\n       d_OUT (\\<Squnion> Y) x = 0", "let ?f = \"\\<lambda>f. SINK f \\<inter> P\""], ["proof (state)\ngoal (2 subgoals):\n 1. separating \\<Gamma> (TER (\\<Squnion> Y))\n 2. \\<And>x.\n       x \\<notin> RF (TER (\\<Squnion> Y)) \\<Longrightarrow>\n       d_OUT (\\<Squnion> Y) x = 0", "have \"Complete_Partial_Order.chain (\\<supseteq>) (?f ` Y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Complete_Partial_Order.chain (\\<lambda>x y. y \\<subseteq> x)\n     ((\\<lambda>f. SINK f \\<inter> P) ` Y)", "using chain"], ["proof (prove)\nusing this:\n  Complete_Partial_Order.chain (\\<le>) Y\n\ngoal (1 subgoal):\n 1. Complete_Partial_Order.chain (\\<lambda>x y. y \\<subseteq> x)\n     ((\\<lambda>f. SINK f \\<inter> P) ` Y)", "by(rule chain_imageI)(auto dest: SINK_mono')"], ["proof (state)\nthis:\n  Complete_Partial_Order.chain (\\<lambda>x y. y \\<subseteq> x)\n   ((\\<lambda>f. SINK f \\<inter> P) ` Y)\n\ngoal (2 subgoals):\n 1. separating \\<Gamma> (TER (\\<Squnion> Y))\n 2. \\<And>x.\n       x \\<notin> RF (TER (\\<Squnion> Y)) \\<Longrightarrow>\n       d_OUT (\\<Squnion> Y) x = 0", "moreover"], ["proof (state)\nthis:\n  Complete_Partial_Order.chain (\\<lambda>x y. y \\<subseteq> x)\n   ((\\<lambda>f. SINK f \\<inter> P) ` Y)\n\ngoal (2 subgoals):\n 1. separating \\<Gamma> (TER (\\<Squnion> Y))\n 2. \\<And>x.\n       x \\<notin> RF (TER (\\<Squnion> Y)) \\<Longrightarrow>\n       d_OUT (\\<Squnion> Y) x = 0", "have \"\\<dots> \\<subseteq> Pow P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>f. SINK f \\<inter> P) ` Y \\<subseteq> Pow P", "by auto"], ["proof (state)\nthis:\n  (\\<lambda>f. SINK f \\<inter> P) ` Y \\<subseteq> Pow P\n\ngoal (2 subgoals):\n 1. separating \\<Gamma> (TER (\\<Squnion> Y))\n 2. \\<And>x.\n       x \\<notin> RF (TER (\\<Squnion> Y)) \\<Longrightarrow>\n       d_OUT (\\<Squnion> Y) x = 0", "hence \"finite (?f ` Y)\""], ["proof (prove)\nusing this:\n  (\\<lambda>f. SINK f \\<inter> P) ` Y \\<subseteq> Pow P\n\ngoal (1 subgoal):\n 1. finite ((\\<lambda>f. SINK f \\<inter> P) ` Y)", "by(rule finite_subset)(simp add: P_def)"], ["proof (state)\nthis:\n  finite ((\\<lambda>f. SINK f \\<inter> P) ` Y)\n\ngoal (2 subgoals):\n 1. separating \\<Gamma> (TER (\\<Squnion> Y))\n 2. \\<And>x.\n       x \\<notin> RF (TER (\\<Squnion> Y)) \\<Longrightarrow>\n       d_OUT (\\<Squnion> Y) x = 0", "ultimately"], ["proof (chain)\npicking this:\n  Complete_Partial_Order.chain (\\<lambda>x y. y \\<subseteq> x)\n   ((\\<lambda>f. SINK f \\<inter> P) ` Y)\n  finite ((\\<lambda>f. SINK f \\<inter> P) ` Y)", "have \"(\\<Inter>(?f ` Y)) \\<in> ?f ` Y\""], ["proof (prove)\nusing this:\n  Complete_Partial_Order.chain (\\<lambda>x y. y \\<subseteq> x)\n   ((\\<lambda>f. SINK f \\<inter> P) ` Y)\n  finite ((\\<lambda>f. SINK f \\<inter> P) ` Y)\n\ngoal (1 subgoal):\n 1. (\\<Inter>f\\<in>Y. SINK f \\<inter> P)\n    \\<in> (\\<lambda>f. SINK f \\<inter> P) ` Y", "by(rule ccpo.in_chain_finite[OF complete_lattice_ccpo_dual])(simp add: Y)"], ["proof (state)\nthis:\n  (\\<Inter>f\\<in>Y. SINK f \\<inter> P)\n  \\<in> (\\<lambda>f. SINK f \\<inter> P) ` Y\n\ngoal (2 subgoals):\n 1. separating \\<Gamma> (TER (\\<Squnion> Y))\n 2. \\<And>x.\n       x \\<notin> RF (TER (\\<Squnion> Y)) \\<Longrightarrow>\n       d_OUT (\\<Squnion> Y) x = 0", "then"], ["proof (chain)\npicking this:\n  (\\<Inter>f\\<in>Y. SINK f \\<inter> P)\n  \\<in> (\\<lambda>f. SINK f \\<inter> P) ` Y", "obtain f where f: \"f \\<in> Y\" and eq: \"\\<Inter>(?f ` Y) = ?f f\""], ["proof (prove)\nusing this:\n  (\\<Inter>f\\<in>Y. SINK f \\<inter> P)\n  \\<in> (\\<lambda>f. SINK f \\<inter> P) ` Y\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        \\<lbrakk>f \\<in> Y;\n         (\\<Inter>f\\<in>Y. SINK f \\<inter> P) = SINK f \\<inter> P\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by clarify"], ["proof (state)\nthis:\n  f \\<in> Y\n  (\\<Inter>f\\<in>Y. SINK f \\<inter> P) = SINK f \\<inter> P\n\ngoal (2 subgoals):\n 1. separating \\<Gamma> (TER (\\<Squnion> Y))\n 2. \\<And>x.\n       x \\<notin> RF (TER (\\<Squnion> Y)) \\<Longrightarrow>\n       d_OUT (\\<Squnion> Y) x = 0", "hence *: \"(\\<Inter>f\\<in>Y. SINK f) \\<inter> P = SINK f \\<inter> P\""], ["proof (prove)\nusing this:\n  f \\<in> Y\n  (\\<Inter>f\\<in>Y. SINK f \\<inter> P) = SINK f \\<inter> P\n\ngoal (1 subgoal):\n 1. \\<Inter> (SINK ` Y) \\<inter> P = SINK f \\<inter> P", "by(clarsimp simp add: prod_lub_def Y)+"], ["proof (state)\nthis:\n  \\<Inter> (SINK ` Y) \\<inter> P = SINK f \\<inter> P\n\ngoal (2 subgoals):\n 1. separating \\<Gamma> (TER (\\<Squnion> Y))\n 2. \\<And>x.\n       x \\<notin> RF (TER (\\<Squnion> Y)) \\<Longrightarrow>\n       d_OUT (\\<Squnion> Y) x = 0", "{"], ["proof (state)\nthis:\n  \\<Inter> (SINK ` Y) \\<inter> P = SINK f \\<inter> P\n\ngoal (2 subgoals):\n 1. separating \\<Gamma> (TER (\\<Squnion> Y))\n 2. \\<And>x.\n       x \\<notin> RF (TER (\\<Squnion> Y)) \\<Longrightarrow>\n       d_OUT (\\<Squnion> Y) x = 0", "fix g"], ["proof (state)\ngoal (2 subgoals):\n 1. separating \\<Gamma> (TER (\\<Squnion> Y))\n 2. \\<And>x.\n       x \\<notin> RF (TER (\\<Squnion> Y)) \\<Longrightarrow>\n       d_OUT (\\<Squnion> Y) x = 0", "assume \"g \\<in> Y\" \"f \\<le> g\""], ["proof (state)\nthis:\n  g \\<in> Y\n  f \\<le> g\n\ngoal (2 subgoals):\n 1. separating \\<Gamma> (TER (\\<Squnion> Y))\n 2. \\<And>x.\n       x \\<notin> RF (TER (\\<Squnion> Y)) \\<Longrightarrow>\n       d_OUT (\\<Squnion> Y) x = 0", "with *"], ["proof (chain)\npicking this:\n  \\<Inter> (SINK ` Y) \\<inter> P = SINK f \\<inter> P\n  g \\<in> Y\n  f \\<le> g", "have \"(\\<Inter>f\\<in>Y. SINK f) \\<inter> P = SINK g \\<inter> P\""], ["proof (prove)\nusing this:\n  \\<Inter> (SINK ` Y) \\<inter> P = SINK f \\<inter> P\n  g \\<in> Y\n  f \\<le> g\n\ngoal (1 subgoal):\n 1. \\<Inter> (SINK ` Y) \\<inter> P = SINK g \\<inter> P", "by(blast dest: SINK_mono')"], ["proof (state)\nthis:\n  \\<Inter> (SINK ` Y) \\<inter> P = SINK g \\<inter> P\n\ngoal (2 subgoals):\n 1. separating \\<Gamma> (TER (\\<Squnion> Y))\n 2. \\<And>x.\n       x \\<notin> RF (TER (\\<Squnion> Y)) \\<Longrightarrow>\n       d_OUT (\\<Squnion> Y) x = 0", "then"], ["proof (chain)\npicking this:\n  \\<Inter> (SINK ` Y) \\<inter> P = SINK g \\<inter> P", "have \"TER (Sup Y) \\<inter> P \\<supseteq> TER g \\<inter> P\""], ["proof (prove)\nusing this:\n  \\<Inter> (SINK ` Y) \\<inter> P = SINK g \\<inter> P\n\ngoal (1 subgoal):\n 1. TER g \\<inter> P \\<subseteq> TER (\\<Squnion> Y) \\<inter> P", "using SAT_Sup_upper[OF \\<open>g \\<in> Y\\<close>, of \\<Gamma>] SINK_Sup[OF chain Y countable]"], ["proof (prove)\nusing this:\n  \\<Inter> (SINK ` Y) \\<inter> P = SINK g \\<inter> P\n  SAT \\<Gamma> g \\<subseteq> SAT \\<Gamma> (\\<Squnion> Y)\n  SINK (\\<Squnion> Y) = \\<Inter> (SINK ` Y)\n\ngoal (1 subgoal):\n 1. TER g \\<inter> P \\<subseteq> TER (\\<Squnion> Y) \\<inter> P", "by blast"], ["proof (state)\nthis:\n  TER g \\<inter> P \\<subseteq> TER (\\<Squnion> Y) \\<inter> P\n\ngoal (2 subgoals):\n 1. separating \\<Gamma> (TER (\\<Squnion> Y))\n 2. \\<And>x.\n       x \\<notin> RF (TER (\\<Squnion> Y)) \\<Longrightarrow>\n       d_OUT (\\<Squnion> Y) x = 0", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?g2 \\<in> Y; f \\<le> ?g2\\<rbrakk>\n  \\<Longrightarrow> TER ?g2 \\<inter> P\n                    \\<subseteq> TER (\\<Squnion> Y) \\<inter> P\n\ngoal (2 subgoals):\n 1. separating \\<Gamma> (TER (\\<Squnion> Y))\n 2. \\<And>x.\n       x \\<notin> RF (TER (\\<Squnion> Y)) \\<Longrightarrow>\n       d_OUT (\\<Squnion> Y) x = 0", "with f"], ["proof (chain)\npicking this:\n  f \\<in> Y\n  \\<lbrakk>?g2 \\<in> Y; f \\<le> ?g2\\<rbrakk>\n  \\<Longrightarrow> TER ?g2 \\<inter> P\n                    \\<subseteq> TER (\\<Squnion> Y) \\<inter> P", "have \"\\<exists>f\\<in>Y. \\<forall>g\\<in>Y. g \\<ge> f \\<longrightarrow> TER g \\<inter> P \\<subseteq> TER (Sup Y) \\<inter> P\""], ["proof (prove)\nusing this:\n  f \\<in> Y\n  \\<lbrakk>?g2 \\<in> Y; f \\<le> ?g2\\<rbrakk>\n  \\<Longrightarrow> TER ?g2 \\<inter> P\n                    \\<subseteq> TER (\\<Squnion> Y) \\<inter> P\n\ngoal (1 subgoal):\n 1. \\<exists>f\\<in>Y.\n       \\<forall>g\\<in>Y.\n          f \\<le> g \\<longrightarrow>\n          TER g \\<inter> P \\<subseteq> TER (\\<Squnion> Y) \\<inter> P", "by blast"], ["proof (state)\nthis:\n  \\<exists>f\\<in>Y.\n     \\<forall>g\\<in>Y.\n        f \\<le> g \\<longrightarrow>\n        TER g \\<inter> P \\<subseteq> TER (\\<Squnion> Y) \\<inter> P\n\ngoal (2 subgoals):\n 1. separating \\<Gamma> (TER (\\<Squnion> Y))\n 2. \\<And>x.\n       x \\<notin> RF (TER (\\<Squnion> Y)) \\<Longrightarrow>\n       d_OUT (\\<Squnion> Y) x = 0", "}"], ["proof (state)\nthis:\n  \\<lbrakk>path \\<Gamma> ?x2 ?p2 ?y2; ?y2 \\<in> B \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>f\\<in>Y.\n                       \\<forall>g\\<in>Y.\n                          f \\<le> g \\<longrightarrow>\n                          TER g \\<inter> ({?x2} \\<union> set ?p2)\n                          \\<subseteq> TER (\\<Squnion> Y) \\<inter>\n({?x2} \\<union> set ?p2)\n\ngoal (2 subgoals):\n 1. separating \\<Gamma> (TER (\\<Squnion> Y))\n 2. \\<And>x.\n       x \\<notin> RF (TER (\\<Squnion> Y)) \\<Longrightarrow>\n       d_OUT (\\<Squnion> Y) x = 0", "note subset = this"], ["proof (state)\nthis:\n  \\<lbrakk>path \\<Gamma> ?x2 ?p2 ?y2; ?y2 \\<in> B \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>f\\<in>Y.\n                       \\<forall>g\\<in>Y.\n                          f \\<le> g \\<longrightarrow>\n                          TER g \\<inter> ({?x2} \\<union> set ?p2)\n                          \\<subseteq> TER (\\<Squnion> Y) \\<inter>\n({?x2} \\<union> set ?p2)\n\ngoal (2 subgoals):\n 1. separating \\<Gamma> (TER (\\<Squnion> Y))\n 2. \\<And>x.\n       x \\<notin> RF (TER (\\<Squnion> Y)) \\<Longrightarrow>\n       d_OUT (\\<Squnion> Y) x = 0", "show \"separating \\<Gamma> (TER (Sup Y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. separating \\<Gamma> (TER (\\<Squnion> Y))", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y p.\n       \\<lbrakk>x \\<in> A \\<Gamma>; y \\<in> B \\<Gamma>;\n        path \\<Gamma> x p y\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>z\\<in>set p.\n                             z \\<in> TER (\\<Squnion> Y)) \\<or>\n                         x \\<in> TER (\\<Squnion> Y)", "fix x y p"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y p.\n       \\<lbrakk>x \\<in> A \\<Gamma>; y \\<in> B \\<Gamma>;\n        path \\<Gamma> x p y\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>z\\<in>set p.\n                             z \\<in> TER (\\<Squnion> Y)) \\<or>\n                         x \\<in> TER (\\<Squnion> Y)", "assume *: \"path \\<Gamma> x p y\" \"y \\<in> B \\<Gamma>\" and \"x \\<in> A \\<Gamma>\""], ["proof (state)\nthis:\n  path \\<Gamma> x p y\n  y \\<in> B \\<Gamma>\n  x \\<in> A \\<Gamma>\n\ngoal (1 subgoal):\n 1. \\<And>x y p.\n       \\<lbrakk>x \\<in> A \\<Gamma>; y \\<in> B \\<Gamma>;\n        path \\<Gamma> x p y\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>z\\<in>set p.\n                             z \\<in> TER (\\<Squnion> Y)) \\<or>\n                         x \\<in> TER (\\<Squnion> Y)", "let ?P = \"{x} \\<union> set p\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y p.\n       \\<lbrakk>x \\<in> A \\<Gamma>; y \\<in> B \\<Gamma>;\n        path \\<Gamma> x p y\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>z\\<in>set p.\n                             z \\<in> TER (\\<Squnion> Y)) \\<or>\n                         x \\<in> TER (\\<Squnion> Y)", "from subset[OF *]"], ["proof (chain)\npicking this:\n  \\<exists>f\\<in>Y.\n     \\<forall>g\\<in>Y.\n        f \\<le> g \\<longrightarrow>\n        TER g \\<inter> ({x} \\<union> set p)\n        \\<subseteq> TER (\\<Squnion> Y) \\<inter> ({x} \\<union> set p)", "obtain f where f:\"f \\<in> Y\"\n      and subset: \"TER f \\<inter> ?P \\<subseteq> TER (Sup Y) \\<inter> ?P\""], ["proof (prove)\nusing this:\n  \\<exists>f\\<in>Y.\n     \\<forall>g\\<in>Y.\n        f \\<le> g \\<longrightarrow>\n        TER g \\<inter> ({x} \\<union> set p)\n        \\<subseteq> TER (\\<Squnion> Y) \\<inter> ({x} \\<union> set p)\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        \\<lbrakk>f \\<in> Y;\n         TER f \\<inter> ({x} \\<union> set p)\n         \\<subseteq> TER (\\<Squnion> Y) \\<inter>\n                     ({x} \\<union> set p)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  f \\<in> Y\n  TER f \\<inter> ({x} \\<union> set p)\n  \\<subseteq> TER (\\<Squnion> Y) \\<inter> ({x} \\<union> set p)\n\ngoal (1 subgoal):\n 1. \\<And>x y p.\n       \\<lbrakk>x \\<in> A \\<Gamma>; y \\<in> B \\<Gamma>;\n        path \\<Gamma> x p y\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>z\\<in>set p.\n                             z \\<in> TER (\\<Squnion> Y)) \\<or>\n                         x \\<in> TER (\\<Squnion> Y)", "from wave[OF f]"], ["proof (chain)\npicking this:\n  wave \\<Gamma> f", "have \"TER f \\<inter> ?P \\<noteq> {}\""], ["proof (prove)\nusing this:\n  wave \\<Gamma> f\n\ngoal (1 subgoal):\n 1. TER f \\<inter> ({x} \\<union> set p) \\<noteq> {}", "using * \\<open>x \\<in> A \\<Gamma>\\<close>"], ["proof (prove)\nusing this:\n  wave \\<Gamma> f\n  path \\<Gamma> x p y\n  y \\<in> B \\<Gamma>\n  x \\<in> A \\<Gamma>\n\ngoal (1 subgoal):\n 1. TER f \\<inter> ({x} \\<union> set p) \\<noteq> {}", "by(auto simp add: wave.simps dest: separatingD)"], ["proof (state)\nthis:\n  TER f \\<inter> ({x} \\<union> set p) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<And>x y p.\n       \\<lbrakk>x \\<in> A \\<Gamma>; y \\<in> B \\<Gamma>;\n        path \\<Gamma> x p y\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>z\\<in>set p.\n                             z \\<in> TER (\\<Squnion> Y)) \\<or>\n                         x \\<in> TER (\\<Squnion> Y)", "with subset"], ["proof (chain)\npicking this:\n  TER f \\<inter> ({x} \\<union> set p)\n  \\<subseteq> TER (\\<Squnion> Y) \\<inter> ({x} \\<union> set p)\n  TER f \\<inter> ({x} \\<union> set p) \\<noteq> {}", "show \" (\\<exists>z\\<in>set p. z \\<in> TER (Sup Y)) \\<or> x \\<in> TER (Sup Y)\""], ["proof (prove)\nusing this:\n  TER f \\<inter> ({x} \\<union> set p)\n  \\<subseteq> TER (\\<Squnion> Y) \\<inter> ({x} \\<union> set p)\n  TER f \\<inter> ({x} \\<union> set p) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<exists>z\\<in>set p. z \\<in> TER (\\<Squnion> Y)) \\<or>\n    x \\<in> TER (\\<Squnion> Y)", "by blast"], ["proof (state)\nthis:\n  (\\<exists>z\\<in>set p. z \\<in> TER (\\<Squnion> Y)) \\<or>\n  x \\<in> TER (\\<Squnion> Y)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  separating \\<Gamma> (TER (\\<Squnion> Y))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<notin> RF (TER (\\<Squnion> Y)) \\<Longrightarrow>\n       d_OUT (\\<Squnion> Y) x = 0", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<notin> RF (TER (\\<Squnion> Y)) \\<Longrightarrow>\n       d_OUT (\\<Squnion> Y) x = 0", "assume \"x \\<notin> RF (TER (Sup Y))\""], ["proof (state)\nthis:\n  x \\<notin> RF (TER (\\<Squnion> Y))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<notin> RF (TER (\\<Squnion> Y)) \\<Longrightarrow>\n       d_OUT (\\<Squnion> Y) x = 0", "then"], ["proof (chain)\npicking this:\n  x \\<notin> RF (TER (\\<Squnion> Y))", "obtain p y where y: \"y \\<in> B \\<Gamma>\"\n    and p: \"path \\<Gamma> x p y\"\n    and ter: \"TER (Sup Y) \\<inter> ({x} \\<union> set p) = {}\""], ["proof (prove)\nusing this:\n  x \\<notin> RF (TER (\\<Squnion> Y))\n\ngoal (1 subgoal):\n 1. (\\<And>y p.\n        \\<lbrakk>y \\<in> B \\<Gamma>; path \\<Gamma> x p y;\n         TER (\\<Squnion> Y) \\<inter> ({x} \\<union> set p) = {}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto simp add: roofed_def)"], ["proof (state)\nthis:\n  y \\<in> B \\<Gamma>\n  path \\<Gamma> x p y\n  TER (\\<Squnion> Y) \\<inter> ({x} \\<union> set p) = {}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<notin> RF (TER (\\<Squnion> Y)) \\<Longrightarrow>\n       d_OUT (\\<Squnion> Y) x = 0", "let ?P = \"{x} \\<union> set p\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<notin> RF (TER (\\<Squnion> Y)) \\<Longrightarrow>\n       d_OUT (\\<Squnion> Y) x = 0", "from subset[OF p y]"], ["proof (chain)\npicking this:\n  \\<exists>f\\<in>Y.\n     \\<forall>g\\<in>Y.\n        f \\<le> g \\<longrightarrow>\n        TER g \\<inter> ({x} \\<union> set p)\n        \\<subseteq> TER (\\<Squnion> Y) \\<inter> ({x} \\<union> set p)", "obtain f where f: \"f \\<in> Y\"\n    and subset: \"\\<And>g. \\<lbrakk> g \\<in> Y; f \\<le> g \\<rbrakk> \\<Longrightarrow> TER g \\<inter> ?P \\<subseteq> TER (Sup Y) \\<inter> ?P\""], ["proof (prove)\nusing this:\n  \\<exists>f\\<in>Y.\n     \\<forall>g\\<in>Y.\n        f \\<le> g \\<longrightarrow>\n        TER g \\<inter> ({x} \\<union> set p)\n        \\<subseteq> TER (\\<Squnion> Y) \\<inter> ({x} \\<union> set p)\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        \\<lbrakk>f \\<in> Y;\n         \\<And>g.\n            \\<lbrakk>g \\<in> Y; f \\<le> g\\<rbrakk>\n            \\<Longrightarrow> TER g \\<inter> ({x} \\<union> set p)\n                              \\<subseteq> TER (\\<Squnion> Y) \\<inter>\n    ({x} \\<union> set p)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  f \\<in> Y\n  \\<lbrakk>?g \\<in> Y; f \\<le> ?g\\<rbrakk>\n  \\<Longrightarrow> TER ?g \\<inter> ({x} \\<union> set p)\n                    \\<subseteq> TER (\\<Squnion> Y) \\<inter>\n                                ({x} \\<union> set p)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<notin> RF (TER (\\<Squnion> Y)) \\<Longrightarrow>\n       d_OUT (\\<Squnion> Y) x = 0", "{"], ["proof (state)\nthis:\n  f \\<in> Y\n  \\<lbrakk>?g \\<in> Y; f \\<le> ?g\\<rbrakk>\n  \\<Longrightarrow> TER ?g \\<inter> ({x} \\<union> set p)\n                    \\<subseteq> TER (\\<Squnion> Y) \\<inter>\n                                ({x} \\<union> set p)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<notin> RF (TER (\\<Squnion> Y)) \\<Longrightarrow>\n       d_OUT (\\<Squnion> Y) x = 0", "fix g"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<notin> RF (TER (\\<Squnion> Y)) \\<Longrightarrow>\n       d_OUT (\\<Squnion> Y) x = 0", "assume g: \"g \\<in> Y\""], ["proof (state)\nthis:\n  g \\<in> Y\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<notin> RF (TER (\\<Squnion> Y)) \\<Longrightarrow>\n       d_OUT (\\<Squnion> Y) x = 0", "with chain f"], ["proof (chain)\npicking this:\n  Complete_Partial_Order.chain (\\<le>) Y\n  f \\<in> Y\n  g \\<in> Y", "have \"f \\<le> g \\<or> g \\<le> f\""], ["proof (prove)\nusing this:\n  Complete_Partial_Order.chain (\\<le>) Y\n  f \\<in> Y\n  g \\<in> Y\n\ngoal (1 subgoal):\n 1. f \\<le> g \\<or> g \\<le> f", "by(rule chainD)"], ["proof (state)\nthis:\n  f \\<le> g \\<or> g \\<le> f\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<notin> RF (TER (\\<Squnion> Y)) \\<Longrightarrow>\n       d_OUT (\\<Squnion> Y) x = 0", "hence \"d_OUT g x = 0\""], ["proof (prove)\nusing this:\n  f \\<le> g \\<or> g \\<le> f\n\ngoal (1 subgoal):\n 1. d_OUT g x = 0", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. f \\<le> g \\<Longrightarrow> d_OUT g x = 0\n 2. g \\<le> f \\<Longrightarrow> d_OUT g x = 0", "assume \"f \\<le> g\""], ["proof (state)\nthis:\n  f \\<le> g\n\ngoal (2 subgoals):\n 1. f \\<le> g \\<Longrightarrow> d_OUT g x = 0\n 2. g \\<le> f \\<Longrightarrow> d_OUT g x = 0", "from subset[OF g this] ter"], ["proof (chain)\npicking this:\n  TER g \\<inter> ({x} \\<union> set p)\n  \\<subseteq> TER (\\<Squnion> Y) \\<inter> ({x} \\<union> set p)\n  TER (\\<Squnion> Y) \\<inter> ({x} \\<union> set p) = {}", "have \"TER g \\<inter> ?P = {}\""], ["proof (prove)\nusing this:\n  TER g \\<inter> ({x} \\<union> set p)\n  \\<subseteq> TER (\\<Squnion> Y) \\<inter> ({x} \\<union> set p)\n  TER (\\<Squnion> Y) \\<inter> ({x} \\<union> set p) = {}\n\ngoal (1 subgoal):\n 1. TER g \\<inter> ({x} \\<union> set p) = {}", "by blast"], ["proof (state)\nthis:\n  TER g \\<inter> ({x} \\<union> set p) = {}\n\ngoal (2 subgoals):\n 1. f \\<le> g \\<Longrightarrow> d_OUT g x = 0\n 2. g \\<le> f \\<Longrightarrow> d_OUT g x = 0", "with p y"], ["proof (chain)\npicking this:\n  path \\<Gamma> x p y\n  y \\<in> B \\<Gamma>\n  TER g \\<inter> ({x} \\<union> set p) = {}", "have \"x \\<notin> RF (TER g)\""], ["proof (prove)\nusing this:\n  path \\<Gamma> x p y\n  y \\<in> B \\<Gamma>\n  TER g \\<inter> ({x} \\<union> set p) = {}\n\ngoal (1 subgoal):\n 1. x \\<notin> RF (TER g)", "by(auto simp add: roofed_def)"], ["proof (state)\nthis:\n  x \\<notin> RF (TER g)\n\ngoal (2 subgoals):\n 1. f \\<le> g \\<Longrightarrow> d_OUT g x = 0\n 2. g \\<le> f \\<Longrightarrow> d_OUT g x = 0", "with wave[OF g]"], ["proof (chain)\npicking this:\n  wave \\<Gamma> g\n  x \\<notin> RF (TER g)", "show ?thesis"], ["proof (prove)\nusing this:\n  wave \\<Gamma> g\n  x \\<notin> RF (TER g)\n\ngoal (1 subgoal):\n 1. d_OUT g x = 0", "by(blast elim: wave.cases)"], ["proof (state)\nthis:\n  d_OUT g x = 0\n\ngoal (1 subgoal):\n 1. g \\<le> f \\<Longrightarrow> d_OUT g x = 0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. g \\<le> f \\<Longrightarrow> d_OUT g x = 0", "assume \"g \\<le> f\""], ["proof (state)\nthis:\n  g \\<le> f\n\ngoal (1 subgoal):\n 1. g \\<le> f \\<Longrightarrow> d_OUT g x = 0", "from subset ter f"], ["proof (chain)\npicking this:\n  \\<lbrakk>?g \\<in> Y; f \\<le> ?g\\<rbrakk>\n  \\<Longrightarrow> TER ?g \\<inter> ({x} \\<union> set p)\n                    \\<subseteq> TER (\\<Squnion> Y) \\<inter>\n                                ({x} \\<union> set p)\n  TER (\\<Squnion> Y) \\<inter> ({x} \\<union> set p) = {}\n  f \\<in> Y", "have \"TER f \\<inter> ?P = {}\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?g \\<in> Y; f \\<le> ?g\\<rbrakk>\n  \\<Longrightarrow> TER ?g \\<inter> ({x} \\<union> set p)\n                    \\<subseteq> TER (\\<Squnion> Y) \\<inter>\n                                ({x} \\<union> set p)\n  TER (\\<Squnion> Y) \\<inter> ({x} \\<union> set p) = {}\n  f \\<in> Y\n\ngoal (1 subgoal):\n 1. TER f \\<inter> ({x} \\<union> set p) = {}", "by blast"], ["proof (state)\nthis:\n  TER f \\<inter> ({x} \\<union> set p) = {}\n\ngoal (1 subgoal):\n 1. g \\<le> f \\<Longrightarrow> d_OUT g x = 0", "with y p"], ["proof (chain)\npicking this:\n  y \\<in> B \\<Gamma>\n  path \\<Gamma> x p y\n  TER f \\<inter> ({x} \\<union> set p) = {}", "have \"x \\<notin> RF (TER f)\""], ["proof (prove)\nusing this:\n  y \\<in> B \\<Gamma>\n  path \\<Gamma> x p y\n  TER f \\<inter> ({x} \\<union> set p) = {}\n\ngoal (1 subgoal):\n 1. x \\<notin> RF (TER f)", "by(auto simp add: roofed_def)"], ["proof (state)\nthis:\n  x \\<notin> RF (TER f)\n\ngoal (1 subgoal):\n 1. g \\<le> f \\<Longrightarrow> d_OUT g x = 0", "with wave[OF f]"], ["proof (chain)\npicking this:\n  wave \\<Gamma> f\n  x \\<notin> RF (TER f)", "have \"d_OUT f x = 0\""], ["proof (prove)\nusing this:\n  wave \\<Gamma> f\n  x \\<notin> RF (TER f)\n\ngoal (1 subgoal):\n 1. d_OUT f x = 0", "by(blast elim: wave.cases)"], ["proof (state)\nthis:\n  d_OUT f x = 0\n\ngoal (1 subgoal):\n 1. g \\<le> f \\<Longrightarrow> d_OUT g x = 0", "moreover"], ["proof (state)\nthis:\n  d_OUT f x = 0\n\ngoal (1 subgoal):\n 1. g \\<le> f \\<Longrightarrow> d_OUT g x = 0", "have \"d_OUT g x \\<le> d_OUT f x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT g x \\<le> d_OUT f x", "using \\<open>g \\<le> f\\<close>[THEN le_funD]"], ["proof (prove)\nusing this:\n  g ?x \\<le> f ?x\n\ngoal (1 subgoal):\n 1. d_OUT g x \\<le> d_OUT f x", "by(rule d_OUT_mono)"], ["proof (state)\nthis:\n  d_OUT g x \\<le> d_OUT f x\n\ngoal (1 subgoal):\n 1. g \\<le> f \\<Longrightarrow> d_OUT g x = 0", "ultimately"], ["proof (chain)\npicking this:\n  d_OUT f x = 0\n  d_OUT g x \\<le> d_OUT f x", "show ?thesis"], ["proof (prove)\nusing this:\n  d_OUT f x = 0\n  d_OUT g x \\<le> d_OUT f x\n\ngoal (1 subgoal):\n 1. d_OUT g x = 0", "by simp"], ["proof (state)\nthis:\n  d_OUT g x = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  d_OUT g x = 0\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<notin> RF (TER (\\<Squnion> Y)) \\<Longrightarrow>\n       d_OUT (\\<Squnion> Y) x = 0", "}"], ["proof (state)\nthis:\n  ?g2 \\<in> Y \\<Longrightarrow> d_OUT ?g2 x = 0\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<notin> RF (TER (\\<Squnion> Y)) \\<Longrightarrow>\n       d_OUT (\\<Squnion> Y) x = 0", "thus \"d_OUT (Sup Y) x = 0\""], ["proof (prove)\nusing this:\n  ?g2 \\<in> Y \\<Longrightarrow> d_OUT ?g2 x = 0\n\ngoal (1 subgoal):\n 1. d_OUT (\\<Squnion> Y) x = 0", "using chain Y"], ["proof (prove)\nusing this:\n  ?g2 \\<in> Y \\<Longrightarrow> d_OUT ?g2 x = 0\n  Complete_Partial_Order.chain (\\<le>) Y\n  Y \\<noteq> {}\n\ngoal (1 subgoal):\n 1. d_OUT (\\<Squnion> Y) x = 0", "by(simp add: d_OUT_Sup)"], ["proof (state)\nthis:\n  d_OUT (\\<Squnion> Y) x = 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ex_maximal_wave: \\<comment> \\<open>Corollary 4.4\\<close>\n  fixes \\<Gamma> (structure)\n  assumes countable: \"countable \\<^bold>E\"\n  shows \"\\<exists>f. current \\<Gamma> f \\<and> wave \\<Gamma> f \\<and> (\\<forall>w. current \\<Gamma> w \\<and> wave \\<Gamma> w \\<and> f \\<le> w \\<longrightarrow> f = w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>f.\n       current \\<Gamma> f \\<and>\n       wave \\<Gamma> f \\<and>\n       (\\<forall>w.\n           current \\<Gamma> w \\<and>\n           wave \\<Gamma> w \\<and> f \\<le> w \\<longrightarrow>\n           f = w)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>f.\n       current \\<Gamma> f \\<and>\n       wave \\<Gamma> f \\<and>\n       (\\<forall>w.\n           current \\<Gamma> w \\<and>\n           wave \\<Gamma> w \\<and> f \\<le> w \\<longrightarrow>\n           f = w)", "define Field_r where \"Field_r = {f. current \\<Gamma> f \\<and> wave \\<Gamma> f}\""], ["proof (state)\nthis:\n  Field_r = {f. current \\<Gamma> f \\<and> wave \\<Gamma> f}\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       current \\<Gamma> f \\<and>\n       wave \\<Gamma> f \\<and>\n       (\\<forall>w.\n           current \\<Gamma> w \\<and>\n           wave \\<Gamma> w \\<and> f \\<le> w \\<longrightarrow>\n           f = w)", "define r where \"r = {(f, g). f \\<in> Field_r \\<and> g \\<in> Field_r \\<and> f \\<le> g}\""], ["proof (state)\nthis:\n  r = {(f, g). f \\<in> Field_r \\<and> g \\<in> Field_r \\<and> f \\<le> g}\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       current \\<Gamma> f \\<and>\n       wave \\<Gamma> f \\<and>\n       (\\<forall>w.\n           current \\<Gamma> w \\<and>\n           wave \\<Gamma> w \\<and> f \\<le> w \\<longrightarrow>\n           f = w)", "have Field_r: \"Field r = Field_r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Field r = Field_r", "by(auto simp add: Field_def r_def)"], ["proof (state)\nthis:\n  Field r = Field_r\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       current \\<Gamma> f \\<and>\n       wave \\<Gamma> f \\<and>\n       (\\<forall>w.\n           current \\<Gamma> w \\<and>\n           wave \\<Gamma> w \\<and> f \\<le> w \\<longrightarrow>\n           f = w)", "have \"Partial_order r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Partial_order r", "unfolding order_on_defs"], ["proof (prove)\ngoal (1 subgoal):\n 1. (Refl r \\<and> trans r) \\<and> antisym r", "by(auto intro!: refl_onI transI antisymI simp add: Field_r r_def Field_def)"], ["proof (state)\nthis:\n  Partial_order r\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       current \\<Gamma> f \\<and>\n       wave \\<Gamma> f \\<and>\n       (\\<forall>w.\n           current \\<Gamma> w \\<and>\n           wave \\<Gamma> w \\<and> f \\<le> w \\<longrightarrow>\n           f = w)", "hence \"\\<exists>m\\<in>Field r. \\<forall>a\\<in>Field r. (m, a) \\<in> r \\<longrightarrow> a = m\""], ["proof (prove)\nusing this:\n  Partial_order r\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<in>Field r.\n       \\<forall>a\\<in>Field r. (m, a) \\<in> r \\<longrightarrow> a = m", "proof(rule Zorns_po_lemma)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>C.\n       C \\<in> Chains r \\<Longrightarrow>\n       \\<exists>u\\<in>Field r. \\<forall>a\\<in>C. (a, u) \\<in> r", "fix Y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>C.\n       C \\<in> Chains r \\<Longrightarrow>\n       \\<exists>u\\<in>Field r. \\<forall>a\\<in>C. (a, u) \\<in> r", "assume \"Y \\<in> Chains r\""], ["proof (state)\nthis:\n  Y \\<in> Chains r\n\ngoal (1 subgoal):\n 1. \\<And>C.\n       C \\<in> Chains r \\<Longrightarrow>\n       \\<exists>u\\<in>Field r. \\<forall>a\\<in>C. (a, u) \\<in> r", "hence Y: \"Complete_Partial_Order.chain (\\<le>) Y\"\n      and w: \"\\<And>f. f \\<in> Y \\<Longrightarrow> wave \\<Gamma> f\"\n      and f: \"\\<And>f. f \\<in> Y \\<Longrightarrow> current \\<Gamma> f\""], ["proof (prove)\nusing this:\n  Y \\<in> Chains r\n\ngoal (1 subgoal):\n 1. Complete_Partial_Order.chain (\\<le>) Y &&&\n    (\\<And>f. f \\<in> Y \\<Longrightarrow> wave \\<Gamma> f) &&&\n    (\\<And>f. f \\<in> Y \\<Longrightarrow> current \\<Gamma> f)", "by(auto simp add: Chains_def r_def chain_def Field_r_def)"], ["proof (state)\nthis:\n  Complete_Partial_Order.chain (\\<le>) Y\n  ?f \\<in> Y \\<Longrightarrow> wave \\<Gamma> ?f\n  ?f \\<in> Y \\<Longrightarrow> current \\<Gamma> ?f\n\ngoal (1 subgoal):\n 1. \\<And>C.\n       C \\<in> Chains r \\<Longrightarrow>\n       \\<exists>u\\<in>Field r. \\<forall>a\\<in>C. (a, u) \\<in> r", "show \"\\<exists>w \\<in> Field r. \\<forall>f \\<in> Y. (f, w) \\<in> r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>w\\<in>Field r. \\<forall>f\\<in>Y. (f, w) \\<in> r", "proof(cases \"Y = {}\")"], ["proof (state)\ngoal (2 subgoals):\n 1. Y = {} \\<Longrightarrow>\n    \\<exists>w\\<in>Field r. \\<forall>f\\<in>Y. (f, w) \\<in> r\n 2. Y \\<noteq> {} \\<Longrightarrow>\n    \\<exists>w\\<in>Field r. \\<forall>f\\<in>Y. (f, w) \\<in> r", "case True"], ["proof (state)\nthis:\n  Y = {}\n\ngoal (2 subgoals):\n 1. Y = {} \\<Longrightarrow>\n    \\<exists>w\\<in>Field r. \\<forall>f\\<in>Y. (f, w) \\<in> r\n 2. Y \\<noteq> {} \\<Longrightarrow>\n    \\<exists>w\\<in>Field r. \\<forall>f\\<in>Y. (f, w) \\<in> r", "have \"zero_current \\<in> Field r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>_. 0) \\<in> Field r", "by(simp add: Field_r Field_r_def)"], ["proof (state)\nthis:\n  (\\<lambda>_. 0) \\<in> Field r\n\ngoal (2 subgoals):\n 1. Y = {} \\<Longrightarrow>\n    \\<exists>w\\<in>Field r. \\<forall>f\\<in>Y. (f, w) \\<in> r\n 2. Y \\<noteq> {} \\<Longrightarrow>\n    \\<exists>w\\<in>Field r. \\<forall>f\\<in>Y. (f, w) \\<in> r", "with True"], ["proof (chain)\npicking this:\n  Y = {}\n  (\\<lambda>_. 0) \\<in> Field r", "show ?thesis"], ["proof (prove)\nusing this:\n  Y = {}\n  (\\<lambda>_. 0) \\<in> Field r\n\ngoal (1 subgoal):\n 1. \\<exists>w\\<in>Field r. \\<forall>f\\<in>Y. (f, w) \\<in> r", "by blast"], ["proof (state)\nthis:\n  \\<exists>w\\<in>Field r. \\<forall>f\\<in>Y. (f, w) \\<in> r\n\ngoal (1 subgoal):\n 1. Y \\<noteq> {} \\<Longrightarrow>\n    \\<exists>w\\<in>Field r. \\<forall>f\\<in>Y. (f, w) \\<in> r", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. Y \\<noteq> {} \\<Longrightarrow>\n    \\<exists>w\\<in>Field r. \\<forall>f\\<in>Y. (f, w) \\<in> r", "case False"], ["proof (state)\nthis:\n  Y \\<noteq> {}\n\ngoal (1 subgoal):\n 1. Y \\<noteq> {} \\<Longrightarrow>\n    \\<exists>w\\<in>Field r. \\<forall>f\\<in>Y. (f, w) \\<in> r", "have \"support_flow (Sup Y) \\<subseteq> \\<^bold>E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. support_flow (\\<Squnion> Y) \\<subseteq> \\<^bold>E", "by(auto simp add: support_flow_Sup elim!: support_flow.cases dest!: f dest: currentD_outside)"], ["proof (state)\nthis:\n  support_flow (\\<Squnion> Y) \\<subseteq> \\<^bold>E\n\ngoal (1 subgoal):\n 1. Y \\<noteq> {} \\<Longrightarrow>\n    \\<exists>w\\<in>Field r. \\<forall>f\\<in>Y. (f, w) \\<in> r", "hence c: \"countable (support_flow (Sup Y))\""], ["proof (prove)\nusing this:\n  support_flow (\\<Squnion> Y) \\<subseteq> \\<^bold>E\n\ngoal (1 subgoal):\n 1. countable (support_flow (\\<Squnion> Y))", "using countable"], ["proof (prove)\nusing this:\n  support_flow (\\<Squnion> Y) \\<subseteq> \\<^bold>E\n  countable \\<^bold>E\n\ngoal (1 subgoal):\n 1. countable (support_flow (\\<Squnion> Y))", "by(rule countable_subset)"], ["proof (state)\nthis:\n  countable (support_flow (\\<Squnion> Y))\n\ngoal (1 subgoal):\n 1. Y \\<noteq> {} \\<Longrightarrow>\n    \\<exists>w\\<in>Field r. \\<forall>f\\<in>Y. (f, w) \\<in> r", "with Y False f w"], ["proof (chain)\npicking this:\n  Complete_Partial_Order.chain (\\<le>) Y\n  Y \\<noteq> {}\n  ?f \\<in> Y \\<Longrightarrow> current \\<Gamma> ?f\n  ?f \\<in> Y \\<Longrightarrow> wave \\<Gamma> ?f\n  countable (support_flow (\\<Squnion> Y))", "have \"Sup Y \\<in> Field r\""], ["proof (prove)\nusing this:\n  Complete_Partial_Order.chain (\\<le>) Y\n  Y \\<noteq> {}\n  ?f \\<in> Y \\<Longrightarrow> current \\<Gamma> ?f\n  ?f \\<in> Y \\<Longrightarrow> wave \\<Gamma> ?f\n  countable (support_flow (\\<Squnion> Y))\n\ngoal (1 subgoal):\n 1. \\<Squnion> Y \\<in> Field r", "unfolding Field_r Field_r_def"], ["proof (prove)\nusing this:\n  Complete_Partial_Order.chain (\\<le>) Y\n  Y \\<noteq> {}\n  ?f \\<in> Y \\<Longrightarrow> current \\<Gamma> ?f\n  ?f \\<in> Y \\<Longrightarrow> wave \\<Gamma> ?f\n  countable (support_flow (\\<Squnion> Y))\n\ngoal (1 subgoal):\n 1. \\<Squnion> Y \\<in> {f. current \\<Gamma> f \\<and> wave \\<Gamma> f}", "by(blast intro: wave_lub current_Sup)"], ["proof (state)\nthis:\n  \\<Squnion> Y \\<in> Field r\n\ngoal (1 subgoal):\n 1. Y \\<noteq> {} \\<Longrightarrow>\n    \\<exists>w\\<in>Field r. \\<forall>f\\<in>Y. (f, w) \\<in> r", "moreover"], ["proof (state)\nthis:\n  \\<Squnion> Y \\<in> Field r\n\ngoal (1 subgoal):\n 1. Y \\<noteq> {} \\<Longrightarrow>\n    \\<exists>w\\<in>Field r. \\<forall>f\\<in>Y. (f, w) \\<in> r", "then"], ["proof (chain)\npicking this:\n  \\<Squnion> Y \\<in> Field r", "have \"(f, Sup Y) \\<in> r\" if \"f \\<in> Y\" for f"], ["proof (prove)\nusing this:\n  \\<Squnion> Y \\<in> Field r\n\ngoal (1 subgoal):\n 1. (f, \\<Squnion> Y) \\<in> r", "using w[OF that] f[OF that] that"], ["proof (prove)\nusing this:\n  \\<Squnion> Y \\<in> Field r\n  wave \\<Gamma> f\n  current \\<Gamma> f\n  f \\<in> Y\n\ngoal (1 subgoal):\n 1. (f, \\<Squnion> Y) \\<in> r", "unfolding Field_r"], ["proof (prove)\nusing this:\n  \\<Squnion> Y \\<in> Field_r\n  wave \\<Gamma> f\n  current \\<Gamma> f\n  f \\<in> Y\n\ngoal (1 subgoal):\n 1. (f, \\<Squnion> Y) \\<in> r", "by(auto simp add: r_def Field_r_def intro: Sup_upper)"], ["proof (state)\nthis:\n  ?f \\<in> Y \\<Longrightarrow> (?f, \\<Squnion> Y) \\<in> r\n\ngoal (1 subgoal):\n 1. Y \\<noteq> {} \\<Longrightarrow>\n    \\<exists>w\\<in>Field r. \\<forall>f\\<in>Y. (f, w) \\<in> r", "ultimately"], ["proof (chain)\npicking this:\n  \\<Squnion> Y \\<in> Field r\n  ?f \\<in> Y \\<Longrightarrow> (?f, \\<Squnion> Y) \\<in> r", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<Squnion> Y \\<in> Field r\n  ?f \\<in> Y \\<Longrightarrow> (?f, \\<Squnion> Y) \\<in> r\n\ngoal (1 subgoal):\n 1. \\<exists>w\\<in>Field r. \\<forall>f\\<in>Y. (f, w) \\<in> r", "by blast"], ["proof (state)\nthis:\n  \\<exists>w\\<in>Field r. \\<forall>f\\<in>Y. (f, w) \\<in> r\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>w\\<in>Field r. \\<forall>f\\<in>Y. (f, w) \\<in> r\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>m\\<in>Field r.\n     \\<forall>a\\<in>Field r. (m, a) \\<in> r \\<longrightarrow> a = m\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       current \\<Gamma> f \\<and>\n       wave \\<Gamma> f \\<and>\n       (\\<forall>w.\n           current \\<Gamma> w \\<and>\n           wave \\<Gamma> w \\<and> f \\<le> w \\<longrightarrow>\n           f = w)", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>m\\<in>Field r.\n     \\<forall>a\\<in>Field r. (m, a) \\<in> r \\<longrightarrow> a = m\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       current \\<Gamma> f \\<and>\n       wave \\<Gamma> f \\<and>\n       (\\<forall>w.\n           current \\<Gamma> w \\<and>\n           wave \\<Gamma> w \\<and> f \\<le> w \\<longrightarrow>\n           f = w)", "by(simp add: Field_r Field_r_def)(auto simp add: r_def Field_r_def)"], ["proof (state)\nthis:\n  \\<exists>f.\n     current \\<Gamma> f \\<and>\n     wave \\<Gamma> f \\<and>\n     (\\<forall>w.\n         current \\<Gamma> w \\<and>\n         wave \\<Gamma> w \\<and> f \\<le> w \\<longrightarrow>\n         f = w)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma essential_leI:\n  fixes \\<Gamma> (structure)\n  assumes g: \"current \\<Gamma> g\" and w: \"wave \\<Gamma> g\"\n  and le: \"\\<And>e. f e \\<le> g e\"\n  and x: \"x \\<in> \\<E> (TER g)\"\n  shows \"essential \\<Gamma> (B \\<Gamma>) (TER f) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. essential \\<Gamma> (B \\<Gamma>) (TER f) x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. essential \\<Gamma> (B \\<Gamma>) (TER f) x", "from x"], ["proof (chain)\npicking this:\n  x \\<in> \\<E> (TER g)", "obtain p y where p: \"path \\<Gamma> x p y\" and y: \"y \\<in> B \\<Gamma>\" and distinct: \"distinct (x # p)\"\n    and bypass: \"\\<And>z. z \\<in> set p \\<Longrightarrow> z \\<notin> RF (TER g)\""], ["proof (prove)\nusing this:\n  x \\<in> \\<E> (TER g)\n\ngoal (1 subgoal):\n 1. (\\<And>p y.\n        \\<lbrakk>path \\<Gamma> x p y; y \\<in> B \\<Gamma>; distinct (x # p);\n         \\<And>z.\n            z \\<in> set p \\<Longrightarrow> z \\<notin> RF (TER g)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(rule \\<E>_E_RF) blast"], ["proof (state)\nthis:\n  path \\<Gamma> x p y\n  y \\<in> B \\<Gamma>\n  distinct (x # p)\n  ?z \\<in> set p \\<Longrightarrow> ?z \\<notin> RF (TER g)\n\ngoal (1 subgoal):\n 1. essential \\<Gamma> (B \\<Gamma>) (TER f) x", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. essential \\<Gamma> (B \\<Gamma>) (TER f) x", "using p y"], ["proof (prove)\nusing this:\n  path \\<Gamma> x p y\n  y \\<in> B \\<Gamma>\n\ngoal (1 subgoal):\n 1. essential \\<Gamma> (B \\<Gamma>) (TER f) x", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>z.\n       \\<lbrakk>x \\<noteq> y; z \\<in> set p\\<rbrakk>\n       \\<Longrightarrow> z = x \\<or> z \\<notin> TER f", "fix z"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>z.\n       \\<lbrakk>x \\<noteq> y; z \\<in> set p\\<rbrakk>\n       \\<Longrightarrow> z = x \\<or> z \\<notin> TER f", "assume \"z \\<in> set p\""], ["proof (state)\nthis:\n  z \\<in> set p\n\ngoal (1 subgoal):\n 1. \\<And>z.\n       \\<lbrakk>x \\<noteq> y; z \\<in> set p\\<rbrakk>\n       \\<Longrightarrow> z = x \\<or> z \\<notin> TER f", "hence z: \"z \\<notin> RF (TER g)\""], ["proof (prove)\nusing this:\n  z \\<in> set p\n\ngoal (1 subgoal):\n 1. z \\<notin> RF (TER g)", "by(auto dest: bypass)"], ["proof (state)\nthis:\n  z \\<notin> RF (TER g)\n\ngoal (1 subgoal):\n 1. \\<And>z.\n       \\<lbrakk>x \\<noteq> y; z \\<in> set p\\<rbrakk>\n       \\<Longrightarrow> z = x \\<or> z \\<notin> TER f", "with w"], ["proof (chain)\npicking this:\n  wave \\<Gamma> g\n  z \\<notin> RF (TER g)", "have OUT: \"d_OUT g z = 0\" and IN: \"d_IN g z = 0\""], ["proof (prove)\nusing this:\n  wave \\<Gamma> g\n  z \\<notin> RF (TER g)\n\ngoal (1 subgoal):\n 1. d_OUT g z = 0 &&& d_IN g z = 0", "by(rule waveD_OUT wave_not_RF_IN_zero[OF g])+"], ["proof (state)\nthis:\n  d_OUT g z = 0\n  d_IN g z = 0\n\ngoal (1 subgoal):\n 1. \\<And>z.\n       \\<lbrakk>x \\<noteq> y; z \\<in> set p\\<rbrakk>\n       \\<Longrightarrow> z = x \\<or> z \\<notin> TER f", "with z"], ["proof (chain)\npicking this:\n  z \\<notin> RF (TER g)\n  d_OUT g z = 0\n  d_IN g z = 0", "have \"z \\<notin> A \\<Gamma>\" \"weight \\<Gamma> z > 0\""], ["proof (prove)\nusing this:\n  z \\<notin> RF (TER g)\n  d_OUT g z = 0\n  d_IN g z = 0\n\ngoal (1 subgoal):\n 1. z \\<notin> A \\<Gamma> &&& 0 < weight \\<Gamma> z", "by(auto intro!: roofed_greaterI simp add: SAT.simps SINK.simps)"], ["proof (state)\nthis:\n  z \\<notin> A \\<Gamma>\n  0 < weight \\<Gamma> z\n\ngoal (1 subgoal):\n 1. \\<And>z.\n       \\<lbrakk>x \\<noteq> y; z \\<in> set p\\<rbrakk>\n       \\<Longrightarrow> z = x \\<or> z \\<notin> TER f", "moreover"], ["proof (state)\nthis:\n  z \\<notin> A \\<Gamma>\n  0 < weight \\<Gamma> z\n\ngoal (1 subgoal):\n 1. \\<And>z.\n       \\<lbrakk>x \\<noteq> y; z \\<in> set p\\<rbrakk>\n       \\<Longrightarrow> z = x \\<or> z \\<notin> TER f", "from IN d_IN_mono[of f z g, OF le]"], ["proof (chain)\npicking this:\n  d_IN g z = 0\n  d_IN f z \\<le> d_IN g z", "have \"d_IN f z \\<le> 0\""], ["proof (prove)\nusing this:\n  d_IN g z = 0\n  d_IN f z \\<le> d_IN g z\n\ngoal (1 subgoal):\n 1. d_IN f z \\<le> 0", "by(simp)"], ["proof (state)\nthis:\n  d_IN f z \\<le> 0\n\ngoal (1 subgoal):\n 1. \\<And>z.\n       \\<lbrakk>x \\<noteq> y; z \\<in> set p\\<rbrakk>\n       \\<Longrightarrow> z = x \\<or> z \\<notin> TER f", "ultimately"], ["proof (chain)\npicking this:\n  z \\<notin> A \\<Gamma>\n  0 < weight \\<Gamma> z\n  d_IN f z \\<le> 0", "have \"z \\<notin> TER f\""], ["proof (prove)\nusing this:\n  z \\<notin> A \\<Gamma>\n  0 < weight \\<Gamma> z\n  d_IN f z \\<le> 0\n\ngoal (1 subgoal):\n 1. z \\<notin> TER f", "by(auto simp add: SAT.simps)"], ["proof (state)\nthis:\n  z \\<notin> TER f\n\ngoal (1 subgoal):\n 1. \\<And>z.\n       \\<lbrakk>x \\<noteq> y; z \\<in> set p\\<rbrakk>\n       \\<Longrightarrow> z = x \\<or> z \\<notin> TER f", "then"], ["proof (chain)\npicking this:\n  z \\<notin> TER f", "show \"z = x \\<or> z \\<notin> TER f\""], ["proof (prove)\nusing this:\n  z \\<notin> TER f\n\ngoal (1 subgoal):\n 1. z = x \\<or> z \\<notin> TER f", "by simp"], ["proof (state)\nthis:\n  z = x \\<or> z \\<notin> TER f\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  essential \\<Gamma> (B \\<Gamma>) (TER f) x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma essential_eq_leI:\n  fixes \\<Gamma> (structure)\n  assumes g: \"current \\<Gamma> g\" and w: \"wave \\<Gamma> g\"\n  and le: \"\\<And>e. f e \\<le> g e\"\n  and subset: \"\\<E> (TER g) \\<subseteq> TER f\"\n  shows \"\\<E> (TER f) = \\<E> (TER g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<E> (TER f) = \\<E> (TER g)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<E> (TER f) \\<subseteq> \\<E> (TER g)\n 2. \\<E> (TER g) \\<subseteq> \\<E> (TER f)", "show subset: \"\\<E> (TER g) \\<subseteq> \\<E> (TER f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<E> (TER g) \\<subseteq> \\<E> (TER f)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> \\<E> (TER g) \\<Longrightarrow> x \\<in> \\<E> (TER f)", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> \\<E> (TER g) \\<Longrightarrow> x \\<in> \\<E> (TER f)", "assume x: \"x \\<in> \\<E> (TER g)\""], ["proof (state)\nthis:\n  x \\<in> \\<E> (TER g)\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> \\<E> (TER g) \\<Longrightarrow> x \\<in> \\<E> (TER f)", "hence \"x \\<in> TER f\""], ["proof (prove)\nusing this:\n  x \\<in> \\<E> (TER g)\n\ngoal (1 subgoal):\n 1. x \\<in> TER f", "using subset"], ["proof (prove)\nusing this:\n  x \\<in> \\<E> (TER g)\n  \\<E> (TER g) \\<subseteq> TER f\n\ngoal (1 subgoal):\n 1. x \\<in> TER f", "by blast"], ["proof (state)\nthis:\n  x \\<in> TER f\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> \\<E> (TER g) \\<Longrightarrow> x \\<in> \\<E> (TER f)", "moreover"], ["proof (state)\nthis:\n  x \\<in> TER f\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> \\<E> (TER g) \\<Longrightarrow> x \\<in> \\<E> (TER f)", "have \"essential \\<Gamma> (B \\<Gamma>) (TER f) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. essential \\<Gamma> (B \\<Gamma>) (TER f) x", "using g w le x"], ["proof (prove)\nusing this:\n  current \\<Gamma> g\n  wave \\<Gamma> g\n  f ?e \\<le> g ?e\n  x \\<in> \\<E> (TER g)\n\ngoal (1 subgoal):\n 1. essential \\<Gamma> (B \\<Gamma>) (TER f) x", "by(rule essential_leI)"], ["proof (state)\nthis:\n  essential \\<Gamma> (B \\<Gamma>) (TER f) x\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> \\<E> (TER g) \\<Longrightarrow> x \\<in> \\<E> (TER f)", "ultimately"], ["proof (chain)\npicking this:\n  x \\<in> TER f\n  essential \\<Gamma> (B \\<Gamma>) (TER f) x", "show \"x \\<in> \\<E> (TER f)\""], ["proof (prove)\nusing this:\n  x \\<in> TER f\n  essential \\<Gamma> (B \\<Gamma>) (TER f) x\n\ngoal (1 subgoal):\n 1. x \\<in> \\<E> (TER f)", "by simp"], ["proof (state)\nthis:\n  x \\<in> \\<E> (TER f)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<E> (TER g) \\<subseteq> \\<E> (TER f)\n\ngoal (1 subgoal):\n 1. \\<E> (TER f) \\<subseteq> \\<E> (TER g)", "show \"\\<dots> \\<subseteq> \\<E> (TER g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<E> (TER f) \\<subseteq> \\<E> (TER g)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> \\<E> (TER f) \\<Longrightarrow> x \\<in> \\<E> (TER g)", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> \\<E> (TER f) \\<Longrightarrow> x \\<in> \\<E> (TER g)", "assume x: \"x \\<in> \\<E> (TER f)\""], ["proof (state)\nthis:\n  x \\<in> \\<E> (TER f)\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> \\<E> (TER f) \\<Longrightarrow> x \\<in> \\<E> (TER g)", "hence \"x \\<in> TER f\""], ["proof (prove)\nusing this:\n  x \\<in> \\<E> (TER f)\n\ngoal (1 subgoal):\n 1. x \\<in> TER f", "by auto"], ["proof (state)\nthis:\n  x \\<in> TER f\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> \\<E> (TER f) \\<Longrightarrow> x \\<in> \\<E> (TER g)", "hence \"x \\<in> RF (TER g)\""], ["proof (prove)\nusing this:\n  x \\<in> TER f\n\ngoal (1 subgoal):\n 1. x \\<in> RF (TER g)", "proof(rule contrapos_pp)"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<notin> RF (TER g) \\<Longrightarrow> x \\<notin> TER f", "assume x: \"x \\<notin> RF (TER g)\""], ["proof (state)\nthis:\n  x \\<notin> RF (TER g)\n\ngoal (1 subgoal):\n 1. x \\<notin> RF (TER g) \\<Longrightarrow> x \\<notin> TER f", "with w"], ["proof (chain)\npicking this:\n  wave \\<Gamma> g\n  x \\<notin> RF (TER g)", "have OUT: \"d_OUT g x = 0\" and IN: \"d_IN g x = 0\""], ["proof (prove)\nusing this:\n  wave \\<Gamma> g\n  x \\<notin> RF (TER g)\n\ngoal (1 subgoal):\n 1. d_OUT g x = 0 &&& d_IN g x = 0", "by(rule waveD_OUT wave_not_RF_IN_zero[OF g])+"], ["proof (state)\nthis:\n  d_OUT g x = 0\n  d_IN g x = 0\n\ngoal (1 subgoal):\n 1. x \\<notin> RF (TER g) \\<Longrightarrow> x \\<notin> TER f", "with x"], ["proof (chain)\npicking this:\n  x \\<notin> RF (TER g)\n  d_OUT g x = 0\n  d_IN g x = 0", "have \"x \\<notin> A \\<Gamma>\" \"weight \\<Gamma> x > 0\""], ["proof (prove)\nusing this:\n  x \\<notin> RF (TER g)\n  d_OUT g x = 0\n  d_IN g x = 0\n\ngoal (1 subgoal):\n 1. x \\<notin> A \\<Gamma> &&& 0 < weight \\<Gamma> x", "by(auto intro!: roofed_greaterI simp add: SAT.simps SINK.simps)"], ["proof (state)\nthis:\n  x \\<notin> A \\<Gamma>\n  0 < weight \\<Gamma> x\n\ngoal (1 subgoal):\n 1. x \\<notin> RF (TER g) \\<Longrightarrow> x \\<notin> TER f", "moreover"], ["proof (state)\nthis:\n  x \\<notin> A \\<Gamma>\n  0 < weight \\<Gamma> x\n\ngoal (1 subgoal):\n 1. x \\<notin> RF (TER g) \\<Longrightarrow> x \\<notin> TER f", "from IN d_IN_mono[of f x g, OF le]"], ["proof (chain)\npicking this:\n  d_IN g x = 0\n  d_IN f x \\<le> d_IN g x", "have \"d_IN f x \\<le> 0\""], ["proof (prove)\nusing this:\n  d_IN g x = 0\n  d_IN f x \\<le> d_IN g x\n\ngoal (1 subgoal):\n 1. d_IN f x \\<le> 0", "by(simp)"], ["proof (state)\nthis:\n  d_IN f x \\<le> 0\n\ngoal (1 subgoal):\n 1. x \\<notin> RF (TER g) \\<Longrightarrow> x \\<notin> TER f", "ultimately"], ["proof (chain)\npicking this:\n  x \\<notin> A \\<Gamma>\n  0 < weight \\<Gamma> x\n  d_IN f x \\<le> 0", "show \"x \\<notin> TER f\""], ["proof (prove)\nusing this:\n  x \\<notin> A \\<Gamma>\n  0 < weight \\<Gamma> x\n  d_IN f x \\<le> 0\n\ngoal (1 subgoal):\n 1. x \\<notin> TER f", "by(auto simp add: SAT.simps)"], ["proof (state)\nthis:\n  x \\<notin> TER f\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x \\<in> RF (TER g)\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> \\<E> (TER f) \\<Longrightarrow> x \\<in> \\<E> (TER g)", "moreover"], ["proof (state)\nthis:\n  x \\<in> RF (TER g)\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> \\<E> (TER f) \\<Longrightarrow> x \\<in> \\<E> (TER g)", "have \"x \\<notin> RF\\<^sup>\\<circ> (TER g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> RF\\<^sup>\\<circ> (TER g)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<in> RF\\<^sup>\\<circ> (TER g) \\<Longrightarrow> False", "assume \"x \\<in> RF\\<^sup>\\<circ> (TER g)\""], ["proof (state)\nthis:\n  x \\<in> RF\\<^sup>\\<circ> (TER g)\n\ngoal (1 subgoal):\n 1. x \\<in> RF\\<^sup>\\<circ> (TER g) \\<Longrightarrow> False", "hence RF: \"x \\<in> RF (\\<E> (TER g))\" and not_E: \"x \\<notin> \\<E> (TER g)\""], ["proof (prove)\nusing this:\n  x \\<in> RF\\<^sup>\\<circ> (TER g)\n\ngoal (1 subgoal):\n 1. x \\<in> RF (\\<E> (TER g)) &&& x \\<notin> \\<E> (TER g)", "unfolding RF_essential"], ["proof (prove)\nusing this:\n  x \\<in> RF\\<^sup>\\<circ> (TER g)\n\ngoal (1 subgoal):\n 1. x \\<in> RF (TER g) &&& x \\<notin> \\<E> (TER g)", "by(simp_all add: roofed_circ_def)"], ["proof (state)\nthis:\n  x \\<in> RF (\\<E> (TER g))\n  x \\<notin> \\<E> (TER g)\n\ngoal (1 subgoal):\n 1. x \\<in> RF\\<^sup>\\<circ> (TER g) \\<Longrightarrow> False", "from x"], ["proof (chain)\npicking this:\n  x \\<in> \\<E> (TER f)", "obtain p y where p: \"path \\<Gamma> x p y\" and y: \"y \\<in> B \\<Gamma>\" and distinct: \"distinct (x # p)\"\n        and bypass: \"\\<And>z. z \\<in> set p \\<Longrightarrow> z \\<notin> RF (TER f)\""], ["proof (prove)\nusing this:\n  x \\<in> \\<E> (TER f)\n\ngoal (1 subgoal):\n 1. (\\<And>p y.\n        \\<lbrakk>path \\<Gamma> x p y; y \\<in> B \\<Gamma>; distinct (x # p);\n         \\<And>z.\n            z \\<in> set p \\<Longrightarrow> z \\<notin> RF (TER f)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(rule \\<E>_E_RF) blast"], ["proof (state)\nthis:\n  path \\<Gamma> x p y\n  y \\<in> B \\<Gamma>\n  distinct (x # p)\n  ?z \\<in> set p \\<Longrightarrow> ?z \\<notin> RF (TER f)\n\ngoal (1 subgoal):\n 1. x \\<in> RF\\<^sup>\\<circ> (TER g) \\<Longrightarrow> False", "from roofedD[OF RF p y] not_E"], ["proof (chain)\npicking this:\n  (\\<exists>z\\<in>set p. z \\<in> \\<E> (TER g)) \\<or> x \\<in> \\<E> (TER g)\n  x \\<notin> \\<E> (TER g)", "obtain z where \"z \\<in> set p\" \"z \\<in> \\<E> (TER g)\""], ["proof (prove)\nusing this:\n  (\\<exists>z\\<in>set p. z \\<in> \\<E> (TER g)) \\<or> x \\<in> \\<E> (TER g)\n  x \\<notin> \\<E> (TER g)\n\ngoal (1 subgoal):\n 1. (\\<And>z.\n        \\<lbrakk>z \\<in> set p; z \\<in> \\<E> (TER g)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  z \\<in> set p\n  z \\<in> \\<E> (TER g)\n\ngoal (1 subgoal):\n 1. x \\<in> RF\\<^sup>\\<circ> (TER g) \\<Longrightarrow> False", "with subset bypass[of z]"], ["proof (chain)\npicking this:\n  \\<E> (TER g) \\<subseteq> \\<E> (TER f)\n  z \\<in> set p \\<Longrightarrow> z \\<notin> RF (TER f)\n  z \\<in> set p\n  z \\<in> \\<E> (TER g)", "show False"], ["proof (prove)\nusing this:\n  \\<E> (TER g) \\<subseteq> \\<E> (TER f)\n  z \\<in> set p \\<Longrightarrow> z \\<notin> RF (TER f)\n  z \\<in> set p\n  z \\<in> \\<E> (TER g)\n\ngoal (1 subgoal):\n 1. False", "by(auto intro: roofed_greaterI)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x \\<notin> RF\\<^sup>\\<circ> (TER g)\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> \\<E> (TER f) \\<Longrightarrow> x \\<in> \\<E> (TER g)", "ultimately"], ["proof (chain)\npicking this:\n  x \\<in> RF (TER g)\n  x \\<notin> RF\\<^sup>\\<circ> (TER g)", "show \"x \\<in> \\<E> (TER g)\""], ["proof (prove)\nusing this:\n  x \\<in> RF (TER g)\n  x \\<notin> RF\\<^sup>\\<circ> (TER g)\n\ngoal (1 subgoal):\n 1. x \\<in> \\<E> (TER g)", "by(simp add: roofed_circ_def)"], ["proof (state)\nthis:\n  x \\<in> \\<E> (TER g)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<E> (TER f) \\<subseteq> \\<E> (TER g)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Hindrances and looseness\\<close>"], ["", "inductive hindrance_by :: \"('v, 'more) web_scheme \\<Rightarrow> 'v current \\<Rightarrow> ennreal \\<Rightarrow> bool\"\n  for \\<Gamma> (structure) and f and \\<epsilon>\nwhere\n  hindrance_by:\n  \"\\<lbrakk> a \\<in> A \\<Gamma>; a \\<notin> \\<E> (TER f); d_OUT f a < weight \\<Gamma> a; \\<epsilon> < weight \\<Gamma> a - d_OUT f a \\<rbrakk> \\<Longrightarrow> hindrance_by \\<Gamma> f \\<epsilon>\""], ["", "inductive hindrance :: \"('v, 'more) web_scheme \\<Rightarrow> 'v current \\<Rightarrow> bool\"\n  for \\<Gamma> (structure) and f\nwhere\n  hindrance:\n  \"\\<lbrakk> a \\<in> A \\<Gamma>; a \\<notin> \\<E> (TER f); d_OUT f a < weight \\<Gamma> a \\<rbrakk> \\<Longrightarrow> hindrance \\<Gamma> f\""], ["", "inductive hindered :: \"('v, 'more) web_scheme \\<Rightarrow> bool\"\n  for \\<Gamma> (structure)\nwhere hindered: \"\\<lbrakk> hindrance \\<Gamma> f; current \\<Gamma> f; wave \\<Gamma> f \\<rbrakk> \\<Longrightarrow> hindered \\<Gamma>\""], ["", "inductive hindered_by :: \"('v, 'more) web_scheme \\<Rightarrow> ennreal \\<Rightarrow> bool\"\n  for \\<Gamma> (structure) and \\<epsilon>\nwhere hindered_by: \"\\<lbrakk> hindrance_by \\<Gamma> f \\<epsilon>; current \\<Gamma> f; wave \\<Gamma> f \\<rbrakk> \\<Longrightarrow> hindered_by \\<Gamma> \\<epsilon>\""], ["", "lemma hindrance_into_hindrance_by:\n  assumes \"hindrance \\<Gamma> f\"\n  shows \"\\<exists>\\<epsilon>>0. hindrance_by \\<Gamma> f \\<epsilon>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>\\<epsilon>>0. hindrance_by \\<Gamma> f \\<epsilon>", "using assms"], ["proof (prove)\nusing this:\n  hindrance \\<Gamma> f\n\ngoal (1 subgoal):\n 1. \\<exists>\\<epsilon>>0. hindrance_by \\<Gamma> f \\<epsilon>", "proof cases"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>a \\<in> A \\<Gamma>;\n        a \\<notin> \\<E>\\<^bsub>\\<Gamma>\\<^esub>\n                    (TER\\<^bsub>\\<Gamma>\\<^esub> f);\n        d_OUT f a < weight \\<Gamma> a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<epsilon>>0.\n                            hindrance_by \\<Gamma> f \\<epsilon>", "case (hindrance a)"], ["proof (state)\nthis:\n  a \\<in> A \\<Gamma>\n  a \\<notin> \\<E>\\<^bsub>\\<Gamma>\\<^esub> (TER\\<^bsub>\\<Gamma>\\<^esub> f)\n  d_OUT f a < weight \\<Gamma> a\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>a \\<in> A \\<Gamma>;\n        a \\<notin> \\<E>\\<^bsub>\\<Gamma>\\<^esub>\n                    (TER\\<^bsub>\\<Gamma>\\<^esub> f);\n        d_OUT f a < weight \\<Gamma> a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<epsilon>>0.\n                            hindrance_by \\<Gamma> f \\<epsilon>", "let ?\\<epsilon> = \"if weight \\<Gamma> a = \\<top> then 1 else (weight \\<Gamma> a - d_OUT f a) / 2\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>a \\<in> A \\<Gamma>;\n        a \\<notin> \\<E>\\<^bsub>\\<Gamma>\\<^esub>\n                    (TER\\<^bsub>\\<Gamma>\\<^esub> f);\n        d_OUT f a < weight \\<Gamma> a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<epsilon>>0.\n                            hindrance_by \\<Gamma> f \\<epsilon>", "from \\<open>d_OUT f a < weight \\<Gamma> a\\<close>"], ["proof (chain)\npicking this:\n  d_OUT f a < weight \\<Gamma> a", "have \"weight \\<Gamma> a - d_OUT f a > 0\" \"weight \\<Gamma> a \\<noteq> \\<top> \\<Longrightarrow> weight \\<Gamma> a - d_OUT f a < \\<top>\""], ["proof (prove)\nusing this:\n  d_OUT f a < weight \\<Gamma> a\n\ngoal (1 subgoal):\n 1. 0 < weight \\<Gamma> a - d_OUT f a &&&\n    (weight \\<Gamma> a \\<noteq> \\<top> \\<Longrightarrow>\n     weight \\<Gamma> a - d_OUT f a < \\<top>)", "by(simp_all add: diff_gr0_ennreal less_top diff_less_top_ennreal)"], ["proof (state)\nthis:\n  0 < weight \\<Gamma> a - d_OUT f a\n  weight \\<Gamma> a \\<noteq> \\<top> \\<Longrightarrow>\n  weight \\<Gamma> a - d_OUT f a < \\<top>\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>a \\<in> A \\<Gamma>;\n        a \\<notin> \\<E>\\<^bsub>\\<Gamma>\\<^esub>\n                    (TER\\<^bsub>\\<Gamma>\\<^esub> f);\n        d_OUT f a < weight \\<Gamma> a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<epsilon>>0.\n                            hindrance_by \\<Gamma> f \\<epsilon>", "from ennreal_mult_strict_left_mono[of 1 2, OF _ this]"], ["proof (chain)\npicking this:\n  \\<lbrakk>1 < 2; weight \\<Gamma> a \\<noteq> \\<top>\\<rbrakk>\n  \\<Longrightarrow> (weight \\<Gamma> a - d_OUT f a) * 1\n                    < (weight \\<Gamma> a - d_OUT f a) * 2", "have \"0 < ?\\<epsilon>\" and \"?\\<epsilon> < weight \\<Gamma> a - d_OUT f a\""], ["proof (prove)\nusing this:\n  \\<lbrakk>1 < 2; weight \\<Gamma> a \\<noteq> \\<top>\\<rbrakk>\n  \\<Longrightarrow> (weight \\<Gamma> a - d_OUT f a) * 1\n                    < (weight \\<Gamma> a - d_OUT f a) * 2\n\ngoal (1 subgoal):\n 1. 0 < (if weight \\<Gamma> a = \\<top> then 1\n         else (weight \\<Gamma> a - d_OUT f a) / 2) &&&\n    (if weight \\<Gamma> a = \\<top> then 1\n     else (weight \\<Gamma> a - d_OUT f a) / 2)\n    < weight \\<Gamma> a - d_OUT f a", "using \\<open>d_OUT f a < weight \\<Gamma> a\\<close>"], ["proof (prove)\nusing this:\n  \\<lbrakk>1 < 2; weight \\<Gamma> a \\<noteq> \\<top>\\<rbrakk>\n  \\<Longrightarrow> (weight \\<Gamma> a - d_OUT f a) * 1\n                    < (weight \\<Gamma> a - d_OUT f a) * 2\n  d_OUT f a < weight \\<Gamma> a\n\ngoal (1 subgoal):\n 1. 0 < (if weight \\<Gamma> a = \\<top> then 1\n         else (weight \\<Gamma> a - d_OUT f a) / 2) &&&\n    (if weight \\<Gamma> a = \\<top> then 1\n     else (weight \\<Gamma> a - d_OUT f a) / 2)\n    < weight \\<Gamma> a - d_OUT f a", "by(auto intro!: diff_gr0_ennreal simp: ennreal_zero_less_divide divide_less_ennreal)"], ["proof (state)\nthis:\n  0 < (if weight \\<Gamma> a = \\<top> then 1\n       else (weight \\<Gamma> a - d_OUT f a) / 2)\n  (if weight \\<Gamma> a = \\<top> then 1\n   else (weight \\<Gamma> a - d_OUT f a) / 2)\n  < weight \\<Gamma> a - d_OUT f a\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>a \\<in> A \\<Gamma>;\n        a \\<notin> \\<E>\\<^bsub>\\<Gamma>\\<^esub>\n                    (TER\\<^bsub>\\<Gamma>\\<^esub> f);\n        d_OUT f a < weight \\<Gamma> a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<epsilon>>0.\n                            hindrance_by \\<Gamma> f \\<epsilon>", "with hindrance"], ["proof (chain)\npicking this:\n  a \\<in> A \\<Gamma>\n  a \\<notin> \\<E>\\<^bsub>\\<Gamma>\\<^esub> (TER\\<^bsub>\\<Gamma>\\<^esub> f)\n  d_OUT f a < weight \\<Gamma> a\n  0 < (if weight \\<Gamma> a = \\<top> then 1\n       else (weight \\<Gamma> a - d_OUT f a) / 2)\n  (if weight \\<Gamma> a = \\<top> then 1\n   else (weight \\<Gamma> a - d_OUT f a) / 2)\n  < weight \\<Gamma> a - d_OUT f a", "show ?thesis"], ["proof (prove)\nusing this:\n  a \\<in> A \\<Gamma>\n  a \\<notin> \\<E>\\<^bsub>\\<Gamma>\\<^esub> (TER\\<^bsub>\\<Gamma>\\<^esub> f)\n  d_OUT f a < weight \\<Gamma> a\n  0 < (if weight \\<Gamma> a = \\<top> then 1\n       else (weight \\<Gamma> a - d_OUT f a) / 2)\n  (if weight \\<Gamma> a = \\<top> then 1\n   else (weight \\<Gamma> a - d_OUT f a) / 2)\n  < weight \\<Gamma> a - d_OUT f a\n\ngoal (1 subgoal):\n 1. \\<exists>\\<epsilon>>0. hindrance_by \\<Gamma> f \\<epsilon>", "by(auto intro!: hindrance_by.intros)"], ["proof (state)\nthis:\n  \\<exists>\\<epsilon>>0. hindrance_by \\<Gamma> f \\<epsilon>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma hindrance_by_into_hindrance: \"hindrance_by \\<Gamma> f \\<epsilon> \\<Longrightarrow> hindrance \\<Gamma> f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hindrance_by \\<Gamma> f \\<epsilon> \\<Longrightarrow>\n    hindrance \\<Gamma> f", "by(blast elim: hindrance_by.cases intro: hindrance.intros)"], ["", "lemma hindrance_conv_hindrance_by: \"hindrance \\<Gamma> f \\<longleftrightarrow> (\\<exists>\\<epsilon>>0. hindrance_by \\<Gamma> f \\<epsilon>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hindrance \\<Gamma> f =\n    (\\<exists>\\<epsilon>>0. hindrance_by \\<Gamma> f \\<epsilon>)", "by(blast intro: hindrance_into_hindrance_by hindrance_by_into_hindrance)"], ["", "lemma hindered_into_hindered_by: \"hindered \\<Gamma> \\<Longrightarrow> \\<exists>\\<epsilon>>0. hindered_by \\<Gamma> \\<epsilon>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hindered \\<Gamma> \\<Longrightarrow>\n    \\<exists>\\<epsilon>>0. hindered_by \\<Gamma> \\<epsilon>", "by(blast intro: hindered_by.intros elim: hindered.cases dest: hindrance_into_hindrance_by)"], ["", "lemma hindered_by_into_hindered: \"hindered_by \\<Gamma> \\<epsilon> \\<Longrightarrow> hindered \\<Gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hindered_by \\<Gamma> \\<epsilon> \\<Longrightarrow> hindered \\<Gamma>", "by(blast elim: hindered_by.cases intro: hindered.intros dest: hindrance_by_into_hindrance)"], ["", "lemma hindered_conv_hindered_by: \"hindered \\<Gamma> \\<longleftrightarrow> (\\<exists>\\<epsilon>>0. hindered_by \\<Gamma> \\<epsilon>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hindered \\<Gamma> =\n    (\\<exists>\\<epsilon>>0. hindered_by \\<Gamma> \\<epsilon>)", "by(blast intro: hindered_into_hindered_by hindered_by_into_hindered)"], ["", "inductive loose :: \"('v, 'more) web_scheme \\<Rightarrow> bool\"\n  for \\<Gamma>\nwhere\n  loose: \"\\<lbrakk> \\<And>f. \\<lbrakk> current \\<Gamma> f; wave \\<Gamma> f \\<rbrakk> \\<Longrightarrow> f = zero_current; \\<not> hindrance \\<Gamma> zero_current \\<rbrakk>\n  \\<Longrightarrow> loose \\<Gamma>\""], ["", "lemma looseD_hindrance: \"loose \\<Gamma> \\<Longrightarrow> \\<not> hindrance \\<Gamma> zero_current\""], ["proof (prove)\ngoal (1 subgoal):\n 1. loose \\<Gamma> \\<Longrightarrow>\n    \\<not> hindrance \\<Gamma> (\\<lambda>_. 0)", "by(simp add: loose.simps)"], ["", "lemma looseD_wave:\n  \"\\<lbrakk> loose \\<Gamma>; current \\<Gamma> f; wave \\<Gamma> f \\<rbrakk> \\<Longrightarrow> f = zero_current\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>loose \\<Gamma>; current \\<Gamma> f; wave \\<Gamma> f\\<rbrakk>\n    \\<Longrightarrow> f = (\\<lambda>_. 0)", "by(simp add: loose.simps)"], ["", "lemma loose_unhindered:\n  fixes \\<Gamma> (structure)\n  assumes \"loose \\<Gamma>\"\n  shows \"\\<not> hindered \\<Gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> hindered \\<Gamma>", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. hindered \\<Gamma> \\<Longrightarrow> False", "apply(erule hindered.cases)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<lbrakk>hindrance \\<Gamma> f; current \\<Gamma> f;\n        wave \\<Gamma> f\\<rbrakk>\n       \\<Longrightarrow> False", "apply(frule (1) looseD_wave[OF assms])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<lbrakk>hindrance \\<Gamma> f; current \\<Gamma> f; wave \\<Gamma> f;\n        f = (\\<lambda>_. 0)\\<rbrakk>\n       \\<Longrightarrow> False", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<lbrakk>hindrance \\<Gamma> (\\<lambda>_. 0);\n        f = (\\<lambda>_. 0)\\<rbrakk>\n       \\<Longrightarrow> False", "using looseD_hindrance[OF assms]"], ["proof (prove)\nusing this:\n  \\<not> hindrance \\<Gamma> (\\<lambda>_. 0)\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<lbrakk>hindrance \\<Gamma> (\\<lambda>_. 0);\n        f = (\\<lambda>_. 0)\\<rbrakk>\n       \\<Longrightarrow> False", "by simp"], ["", "context\n  fixes \\<Gamma> \\<Gamma>' :: \"('v, 'more) web_scheme\"\n  assumes [simp]: \"edge \\<Gamma> = edge \\<Gamma>'\" \"A \\<Gamma> = A \\<Gamma>'\" \"B \\<Gamma> = B \\<Gamma>'\"\n  and weight_eq: \"\\<And>x. x \\<notin> A \\<Gamma>' \\<Longrightarrow> weight \\<Gamma> x = weight \\<Gamma>' x\"\n  and weight_le: \"\\<And>a. a \\<in> A \\<Gamma>' \\<Longrightarrow> weight \\<Gamma> a \\<ge> weight \\<Gamma>' a\"\nbegin"], ["", "private"], ["", "lemma essential_eq: \"essential \\<Gamma> = essential \\<Gamma>'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. essential \\<Gamma> = essential \\<Gamma>'", "by(simp add: fun_eq_iff essential_def)"], ["", "qualified"], ["", "lemma TER_eq: \"TER\\<^bsub>\\<Gamma>\\<^esub> f = TER\\<^bsub>\\<Gamma>'\\<^esub> f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. TER\\<^bsub>\\<Gamma>\\<^esub> f = TER\\<^bsub>\\<Gamma>'\\<^esub> f", "apply(auto simp add: SINK.simps SAT.simps)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>d_OUT f x = 0; \\<not> weight \\<Gamma>' x \\<le> d_IN f x;\n        weight \\<Gamma> x \\<le> d_IN f x\\<rbrakk>\n       \\<Longrightarrow> x \\<in> A \\<Gamma>'\n 2. \\<And>x.\n       \\<lbrakk>d_OUT f x = 0; \\<not> weight \\<Gamma> x \\<le> d_IN f x;\n        weight \\<Gamma>' x \\<le> d_IN f x\\<rbrakk>\n       \\<Longrightarrow> x \\<in> A \\<Gamma>'", "apply(erule contrapos_np; drule weight_eq; simp)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "qualified"], ["", "lemma separating_eq: \"separating_gen \\<Gamma> = separating_gen \\<Gamma>'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. separating_gen \\<Gamma> = separating_gen \\<Gamma>'", "by(intro ext iffI; rule separating_gen.intros; drule separatingD; simp)"], ["", "qualified"], ["", "lemma roofed_eq: \"\\<And>B. roofed_gen \\<Gamma> B S = roofed_gen \\<Gamma>' B S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>B. roofed_gen \\<Gamma> B S = roofed_gen \\<Gamma>' B S", "by(simp add: roofed_def)"], ["", "lemma wave_eq_web: \\<comment> \\<open>Observation 4.6\\<close>\n  \"wave \\<Gamma> f \\<longleftrightarrow> wave \\<Gamma>' f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wave \\<Gamma> f = wave \\<Gamma>' f", "by(simp add: wave.simps separating_eq TER_eq roofed_eq)"], ["", "lemma current_mono_web: \"current \\<Gamma>' f \\<Longrightarrow> current \\<Gamma> f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. current \\<Gamma>' f \\<Longrightarrow> current \\<Gamma> f", "apply(rule current, simp_all add: currentD_OUT_IN currentD_IN currentD_OUT  currentD_outside')"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       current \\<Gamma>' f \\<Longrightarrow>\n       d_OUT f x \\<le> weight \\<Gamma> x\n 2. \\<And>x.\n       current \\<Gamma>' f \\<Longrightarrow>\n       d_IN f x \\<le> weight \\<Gamma> x", "subgoal for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. current \\<Gamma>' f \\<Longrightarrow> d_OUT f x \\<le> weight \\<Gamma> x", "by(cases \"x \\<in> A \\<Gamma>'\")(auto dest!: weight_eq weight_le dest: currentD_weight_OUT intro: order_trans)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       current \\<Gamma>' f \\<Longrightarrow>\n       d_IN f x \\<le> weight \\<Gamma> x", "subgoal for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. current \\<Gamma>' f \\<Longrightarrow> d_IN f x \\<le> weight \\<Gamma> x", "by(cases \"x \\<in> A \\<Gamma>'\")(auto dest!: weight_eq weight_le dest: currentD_weight_IN intro: order_trans)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma hindrance_mono_web: \"hindrance \\<Gamma>' f \\<Longrightarrow> hindrance \\<Gamma> f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hindrance \\<Gamma>' f \\<Longrightarrow> hindrance \\<Gamma> f", "apply(erule hindrance.cases)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>a \\<in> A \\<Gamma>';\n        a \\<notin> \\<E>\\<^bsub>\\<Gamma>'\\<^esub>\n                    (TER\\<^bsub>\\<Gamma>'\\<^esub> f);\n        d_OUT f a < weight \\<Gamma>' a\\<rbrakk>\n       \\<Longrightarrow> hindrance \\<Gamma> f", "apply(rule hindrance)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>a \\<in> A \\<Gamma>';\n        a \\<notin> \\<E>\\<^bsub>\\<Gamma>'\\<^esub>\n                    (TER\\<^bsub>\\<Gamma>'\\<^esub> f);\n        d_OUT f a < weight \\<Gamma>' a\\<rbrakk>\n       \\<Longrightarrow> ?a2 a \\<in> A \\<Gamma>\n 2. \\<And>a.\n       \\<lbrakk>a \\<in> A \\<Gamma>';\n        a \\<notin> \\<E>\\<^bsub>\\<Gamma>'\\<^esub>\n                    (TER\\<^bsub>\\<Gamma>'\\<^esub> f);\n        d_OUT f a < weight \\<Gamma>' a\\<rbrakk>\n       \\<Longrightarrow> ?a2 a\n                         \\<notin> \\<E>\\<^bsub>\\<Gamma>\\<^esub>\n                                   (TER\\<^bsub>\\<Gamma>\\<^esub> f)\n 3. \\<And>a.\n       \\<lbrakk>a \\<in> A \\<Gamma>';\n        a \\<notin> \\<E>\\<^bsub>\\<Gamma>'\\<^esub>\n                    (TER\\<^bsub>\\<Gamma>'\\<^esub> f);\n        d_OUT f a < weight \\<Gamma>' a\\<rbrakk>\n       \\<Longrightarrow> d_OUT f (?a2 a) < weight \\<Gamma> (?a2 a)", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>a \\<in> A \\<Gamma>';\n        a \\<notin> \\<E>\\<^bsub>\\<Gamma>'\\<^esub>\n                    (TER\\<^bsub>\\<Gamma>'\\<^esub> f);\n        d_OUT f a < weight \\<Gamma>' a\\<rbrakk>\n       \\<Longrightarrow> a \\<notin> \\<E>\\<^bsub>\\<Gamma>\\<^esub>\n                                     (TER\\<^bsub>\\<Gamma>\\<^esub> f)\n 2. \\<And>a.\n       \\<lbrakk>a \\<in> A \\<Gamma>';\n        a \\<notin> \\<E>\\<^bsub>\\<Gamma>'\\<^esub>\n                    (TER\\<^bsub>\\<Gamma>'\\<^esub> f);\n        d_OUT f a < weight \\<Gamma>' a\\<rbrakk>\n       \\<Longrightarrow> d_OUT f a < weight \\<Gamma> a", "apply(unfold TER_eq, simp add: essential_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>a \\<in> A \\<Gamma>';\n        a \\<notin> \\<E>\\<^bsub>\\<Gamma>'\\<^esub>\n                    (TER\\<^bsub>\\<Gamma>'\\<^esub> f);\n        d_OUT f a < weight \\<Gamma>' a\\<rbrakk>\n       \\<Longrightarrow> d_OUT f a < weight \\<Gamma> a", "apply(auto dest!: weight_le)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma hindered_mono_web: \"hindered \\<Gamma>' \\<Longrightarrow> hindered \\<Gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hindered \\<Gamma>' \\<Longrightarrow> hindered \\<Gamma>", "apply(erule hindered.cases)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<lbrakk>hindrance \\<Gamma>' f; current \\<Gamma>' f;\n        wave \\<Gamma>' f\\<rbrakk>\n       \\<Longrightarrow> hindered \\<Gamma>", "apply(rule hindered.intros)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>f.\n       \\<lbrakk>hindrance \\<Gamma>' f; current \\<Gamma>' f;\n        wave \\<Gamma>' f\\<rbrakk>\n       \\<Longrightarrow> hindrance \\<Gamma> (?f2 f)\n 2. \\<And>f.\n       \\<lbrakk>hindrance \\<Gamma>' f; current \\<Gamma>' f;\n        wave \\<Gamma>' f\\<rbrakk>\n       \\<Longrightarrow> current \\<Gamma> (?f2 f)\n 3. \\<And>f.\n       \\<lbrakk>hindrance \\<Gamma>' f; current \\<Gamma>' f;\n        wave \\<Gamma>' f\\<rbrakk>\n       \\<Longrightarrow> wave \\<Gamma> (?f2 f)", "apply(erule hindrance_mono_web)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>f.\n       \\<lbrakk>hindrance \\<Gamma>' f; current \\<Gamma>' f;\n        wave \\<Gamma>' f\\<rbrakk>\n       \\<Longrightarrow> current \\<Gamma> f\n 2. \\<And>f.\n       \\<lbrakk>hindrance \\<Gamma>' f; current \\<Gamma>' f;\n        wave \\<Gamma>' f\\<rbrakk>\n       \\<Longrightarrow> wave \\<Gamma> f", "apply(erule current_mono_web)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<lbrakk>hindrance \\<Gamma>' f; current \\<Gamma>' f;\n        wave \\<Gamma>' f\\<rbrakk>\n       \\<Longrightarrow> wave \\<Gamma> f", "apply(simp add: wave_eq_web)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "subsection \\<open>Linkage\\<close>"], ["", "text \\<open>\n  The following definition of orthogonality is stronger than the original definition 3.5 in\n  @{cite AharoniBergerGeorgakopoulusPerlsteinSpruessel2011JCT} in that the outflow from any\n  \\<open>A\\<close>-vertices in the set must saturate the vertex; @{term \"S \\<subseteq> SAT \\<Gamma> f\"} is not enough.\n\n  With the original definition of orthogonal current, the reduction from networks to webs fails because\n  the induced flow need not saturate edges going out of the source. Consider the network with three\n  nodes \\<open>s\\<close>, \\<open>x\\<close>, and \\<open>t\\<close> and edges \\<open>(s, x)\\<close> and \\<open>(x, t)\\<close> with\n  capacity \\<open>1\\<close>. Then, the corresponding web has the vertices \\<open>(s, x)\\<close> and\n  \\<open>(x, t)\\<close> and one edge from \\<open>(s, x)\\<close> to \\<open>(x, t)\\<close>. Clearly, the zero current\n  @{term [source] zero_current} is a web-flow and \\<open>TER zero_current = {(s, x)}\\<close>, which is essential.\n  Moreover, @{term [source] zero_current} and \\<open>{(s, x)}\\<close> are orthogonal because\n  @{term [source] zero_current} trivially saturates \\<open>(s, x)\\<close> as this is a vertex in \\<open>A\\<close>.\n\\<close>"], ["", "inductive orthogonal_current :: \"('v, 'more) web_scheme \\<Rightarrow> 'v current \\<Rightarrow> 'v set \\<Rightarrow> bool\"\n  for \\<Gamma> (structure) and f S\nwhere orthogonal_current:\n  \"\\<lbrakk> \\<And>x. \\<lbrakk> x \\<in> S; x \\<notin> A \\<Gamma> \\<rbrakk> \\<Longrightarrow> weight \\<Gamma> x \\<le> d_IN f x;\n     \\<And>x. \\<lbrakk> x \\<in> S; x \\<in> A \\<Gamma>; x \\<notin> B \\<Gamma> \\<rbrakk> \\<Longrightarrow> d_OUT f x = weight \\<Gamma> x;\n    \\<And>u v. \\<lbrakk> v \\<in> RF S; u \\<notin> RF\\<^sup>\\<circ> S \\<rbrakk> \\<Longrightarrow> f (u, v) = 0 \\<rbrakk>\n  \\<Longrightarrow> orthogonal_current \\<Gamma> f S\""], ["", "lemma orthogonal_currentD_SAT: \"\\<lbrakk> orthogonal_current \\<Gamma> f S; x \\<in> S \\<rbrakk> \\<Longrightarrow> x \\<in> SAT \\<Gamma> f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>orthogonal_current \\<Gamma> f S; x \\<in> S\\<rbrakk>\n    \\<Longrightarrow> x \\<in> SAT \\<Gamma> f", "by(auto elim!: orthogonal_current.cases intro: SAT.intros)"], ["", "lemma orthogonal_currentD_A: \"\\<lbrakk> orthogonal_current \\<Gamma> f S; x \\<in> S; x \\<in> A \\<Gamma>; x \\<notin> B \\<Gamma> \\<rbrakk> \\<Longrightarrow> d_OUT f x = weight \\<Gamma> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>orthogonal_current \\<Gamma> f S; x \\<in> S; x \\<in> A \\<Gamma>;\n     x \\<notin> B \\<Gamma>\\<rbrakk>\n    \\<Longrightarrow> d_OUT f x = weight \\<Gamma> x", "by(auto elim: orthogonal_current.cases)"], ["", "lemma orthogonal_currentD_in: \"\\<lbrakk> orthogonal_current \\<Gamma> f S; v \\<in> RF\\<^bsub>\\<Gamma>\\<^esub> S; u \\<notin> RF\\<^sup>\\<circ>\\<^bsub>\\<Gamma>\\<^esub> S \\<rbrakk> \\<Longrightarrow> f (u, v) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>orthogonal_current \\<Gamma> f S;\n     v \\<in> RF\\<^bsub>\\<Gamma>\\<^esub> S;\n     u \\<notin> RF\\<^sup>\\<circ>\\<^bsub>\\<Gamma>\\<^esub> S\\<rbrakk>\n    \\<Longrightarrow> f (u, v) = 0", "by(auto elim: orthogonal_current.cases)"], ["", "inductive linkage :: \"('v, 'more) web_scheme \\<Rightarrow> 'v current \\<Rightarrow> bool\"\n  for \\<Gamma> f\nwhere \\<comment> \\<open>Omit the condition @{const web_flow}\\<close>\n  linkage: \"(\\<And>x. x \\<in> A \\<Gamma> \\<Longrightarrow> d_OUT f x = weight \\<Gamma> x) \\<Longrightarrow> linkage \\<Gamma> f\""], ["", "lemma linkageD: \"\\<lbrakk> linkage \\<Gamma> f; x \\<in> A \\<Gamma> \\<rbrakk> \\<Longrightarrow> d_OUT f x = weight \\<Gamma> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>linkage \\<Gamma> f; x \\<in> A \\<Gamma>\\<rbrakk>\n    \\<Longrightarrow> d_OUT f x = weight \\<Gamma> x", "by(rule linkage.cases)"], ["", "abbreviation linkable :: \"('v, 'more) web_scheme \\<Rightarrow> bool\"\nwhere \"linkable \\<Gamma> \\<equiv> \\<exists>f. web_flow \\<Gamma> f \\<and> linkage \\<Gamma> f\""], ["", "subsection \\<open>Trimming\\<close>"], ["", "context\n  fixes \\<Gamma> :: \"('v, 'more) web_scheme\" (structure)\n  and f :: \"'v current\"\nbegin"], ["", "inductive trimming :: \"'v current \\<Rightarrow> bool\"\n  for g\nwhere\n  trimming:\n  \\<comment> \\<open>omits the condition that @{term f} is a wave\\<close>\n  \"\\<lbrakk> current \\<Gamma> g; wave \\<Gamma> g; g \\<le> f; \\<And>x. \\<lbrakk> x \\<in> RF\\<^sup>\\<circ> (TER f); x \\<notin> A \\<Gamma> \\<rbrakk> \\<Longrightarrow> KIR g x; \\<E> (TER g) - A \\<Gamma> = \\<E> (TER f) - A \\<Gamma> \\<rbrakk>\n  \\<Longrightarrow> trimming g\""], ["", "lemma assumes \"trimming g\"\n  shows trimmingD_current: \"current \\<Gamma> g\"\n  and trimmingD_wave: \"wave \\<Gamma> g\"\n  and trimmingD_le: \"\\<And>e. g e \\<le> f e\"\n  and trimmingD_KIR: \"\\<lbrakk> x \\<in> RF\\<^sup>\\<circ> (TER f); x \\<notin> A \\<Gamma> \\<rbrakk> \\<Longrightarrow> KIR g x\"\n  and trimmingD_\\<E>: \"\\<E> (TER g) - A \\<Gamma> = \\<E> (TER f) - A \\<Gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (current \\<Gamma> g &&& wave \\<Gamma> g) &&&\n    (\\<And>e. g e \\<le> f e) &&&\n    (\\<lbrakk>x \\<in> RF\\<^sup>\\<circ> (TER f);\n      x \\<notin> A \\<Gamma>\\<rbrakk>\n     \\<Longrightarrow> KIR g x) &&&\n    \\<E> (TER g) - A \\<Gamma> = \\<E> (TER f) - A \\<Gamma>", "using assms"], ["proof (prove)\nusing this:\n  local.trimming g\n\ngoal (1 subgoal):\n 1. (current \\<Gamma> g &&& wave \\<Gamma> g) &&&\n    (\\<And>e. g e \\<le> f e) &&&\n    (\\<lbrakk>x \\<in> RF\\<^sup>\\<circ> (TER f);\n      x \\<notin> A \\<Gamma>\\<rbrakk>\n     \\<Longrightarrow> KIR g x) &&&\n    \\<E> (TER g) - A \\<Gamma> = \\<E> (TER f) - A \\<Gamma>", "by(blast elim: trimming.cases dest: le_funD)+"], ["", "lemma ex_trimming: \\<comment> \\<open>Lemma 4.8\\<close>\n  assumes f: \"current \\<Gamma> f\"\n  and w: \"wave \\<Gamma> f\"\n  and countable: \"countable \\<^bold>E\"\n  and weight_finite: \"\\<And>x. weight \\<Gamma> x \\<noteq> \\<top>\"\n  shows \"\\<exists>g. trimming g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ex local.trimming", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Ex local.trimming", "define F where \"F = {g. current \\<Gamma> g \\<and> wave \\<Gamma> g \\<and> g \\<le> f \\<and> \\<E> (TER g) = \\<E> (TER f)}\""], ["proof (state)\nthis:\n  F =\n  {g. current \\<Gamma> g \\<and>\n      wave \\<Gamma> g \\<and> g \\<le> f \\<and> \\<E> (TER g) = \\<E> (TER f)}\n\ngoal (1 subgoal):\n 1. Ex local.trimming", "define leq where \"leq = restrict_rel F {(g, g'). g' \\<le> g}\""], ["proof (state)\nthis:\n  leq = restrict_rel F {(g, g'). g' \\<le> g}\n\ngoal (1 subgoal):\n 1. Ex local.trimming", "have in_F [simp]: \"g \\<in> F \\<longleftrightarrow> current \\<Gamma> g \\<and> wave \\<Gamma> g \\<and> (\\<forall>e. g e \\<le> f e) \\<and> \\<E> (TER g) = \\<E> (TER f)\" for g"], ["proof (prove)\ngoal (1 subgoal):\n 1. (g \\<in> F) =\n    (current \\<Gamma> g \\<and>\n     wave \\<Gamma> g \\<and>\n     (\\<forall>e. g e \\<le> f e) \\<and> \\<E> (TER g) = \\<E> (TER f))", "by(simp add: F_def le_fun_def)"], ["proof (state)\nthis:\n  (?g \\<in> F) =\n  (current \\<Gamma> ?g \\<and>\n   wave \\<Gamma> ?g \\<and>\n   (\\<forall>e. ?g e \\<le> f e) \\<and> \\<E> (TER ?g) = \\<E> (TER f))\n\ngoal (1 subgoal):\n 1. Ex local.trimming", "have f_finite [simp]: \"f e \\<noteq> \\<top>\" for e"], ["proof (prove)\ngoal (1 subgoal):\n 1. f e \\<noteq> \\<top>", "proof(cases e)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b. e = (a, b) \\<Longrightarrow> f e \\<noteq> \\<top>", "case (Pair x y)"], ["proof (state)\nthis:\n  e = (x, y)\n\ngoal (1 subgoal):\n 1. \\<And>a b. e = (a, b) \\<Longrightarrow> f e \\<noteq> \\<top>", "have \"f (x, y) \\<le> d_IN f y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f (x, y) \\<le> d_IN f y", "by (rule d_IN_ge_point)"], ["proof (state)\nthis:\n  f (x, y) \\<le> d_IN f y\n\ngoal (1 subgoal):\n 1. \\<And>a b. e = (a, b) \\<Longrightarrow> f e \\<noteq> \\<top>", "also"], ["proof (state)\nthis:\n  f (x, y) \\<le> d_IN f y\n\ngoal (1 subgoal):\n 1. \\<And>a b. e = (a, b) \\<Longrightarrow> f e \\<noteq> \\<top>", "have \"\\<dots> \\<le> weight \\<Gamma> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN f y \\<le> weight \\<Gamma> y", "by(rule currentD_weight_IN[OF f])"], ["proof (state)\nthis:\n  d_IN f y \\<le> weight \\<Gamma> y\n\ngoal (1 subgoal):\n 1. \\<And>a b. e = (a, b) \\<Longrightarrow> f e \\<noteq> \\<top>", "also"], ["proof (state)\nthis:\n  d_IN f y \\<le> weight \\<Gamma> y\n\ngoal (1 subgoal):\n 1. \\<And>a b. e = (a, b) \\<Longrightarrow> f e \\<noteq> \\<top>", "have \"\\<dots> < \\<top>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. weight \\<Gamma> y < \\<top>", "by(simp add: weight_finite less_top[symmetric])"], ["proof (state)\nthis:\n  weight \\<Gamma> y < \\<top>\n\ngoal (1 subgoal):\n 1. \\<And>a b. e = (a, b) \\<Longrightarrow> f e \\<noteq> \\<top>", "finally"], ["proof (chain)\npicking this:\n  f (x, y) < \\<top>", "show ?thesis"], ["proof (prove)\nusing this:\n  f (x, y) < \\<top>\n\ngoal (1 subgoal):\n 1. f e \\<noteq> \\<top>", "using Pair"], ["proof (prove)\nusing this:\n  f (x, y) < \\<top>\n  e = (x, y)\n\ngoal (1 subgoal):\n 1. f e \\<noteq> \\<top>", "by simp"], ["proof (state)\nthis:\n  f e \\<noteq> \\<top>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  f ?e \\<noteq> \\<top>\n\ngoal (1 subgoal):\n 1. Ex local.trimming", "have chainD: \"Inf M \\<in> F\" if M: \"M \\<in> Chains leq\" and nempty: \"M \\<noteq> {}\" for M"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Sqinter> M \\<in> F", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Sqinter> M \\<in> F", "from nempty"], ["proof (chain)\npicking this:\n  M \\<noteq> {}", "obtain g0 where g0: \"g0 \\<in> M\""], ["proof (prove)\nusing this:\n  M \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>g0. g0 \\<in> M \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  g0 \\<in> M\n\ngoal (1 subgoal):\n 1. \\<Sqinter> M \\<in> F", "have g0_le_f: \"g0 e \\<le> f e\" and g: \"current \\<Gamma> g0\" and w0: \"wave \\<Gamma> g0\" for e"], ["proof (prove)\ngoal (1 subgoal):\n 1. g0 e \\<le> f e &&& current \\<Gamma> g0 &&& wave \\<Gamma> g0", "using Chains_FieldD[OF M g0]"], ["proof (prove)\nusing this:\n  g0 \\<in> Field leq\n\ngoal (1 subgoal):\n 1. g0 e \\<le> f e &&& current \\<Gamma> g0 &&& wave \\<Gamma> g0", "by(cases e, auto simp add: leq_def)"], ["proof (state)\nthis:\n  g0 ?e \\<le> f ?e\n  current \\<Gamma> g0\n  wave \\<Gamma> g0\n\ngoal (1 subgoal):\n 1. \\<Sqinter> M \\<in> F", "have finite_OUT: \"d_OUT f x \\<noteq> \\<top>\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT f x \\<noteq> \\<top>", "using weight_finite[of x]"], ["proof (prove)\nusing this:\n  weight \\<Gamma> x \\<noteq> \\<top>\n\ngoal (1 subgoal):\n 1. d_OUT f x \\<noteq> \\<top>", "by(rule neq_top_trans)(rule currentD_weight_OUT[OF f])"], ["proof (state)\nthis:\n  d_OUT f ?x \\<noteq> \\<top>\n\ngoal (1 subgoal):\n 1. \\<Sqinter> M \\<in> F", "have finite_IN: \"d_IN f x \\<noteq> \\<top>\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN f x \\<noteq> \\<top>", "using weight_finite[of x]"], ["proof (prove)\nusing this:\n  weight \\<Gamma> x \\<noteq> \\<top>\n\ngoal (1 subgoal):\n 1. d_IN f x \\<noteq> \\<top>", "by(rule neq_top_trans)(rule currentD_weight_IN[OF f])"], ["proof (state)\nthis:\n  d_IN f ?x \\<noteq> \\<top>\n\ngoal (1 subgoal):\n 1. \\<Sqinter> M \\<in> F", "from M"], ["proof (chain)\npicking this:\n  M \\<in> Chains leq", "have \"M \\<in> Chains {(g, g'). g' \\<le> g}\""], ["proof (prove)\nusing this:\n  M \\<in> Chains leq\n\ngoal (1 subgoal):\n 1. M \\<in> Chains {(g, g'). g' \\<le> g}", "by(rule mono_Chains[THEN subsetD, rotated])(auto simp add: leq_def in_restrict_rel_iff)"], ["proof (state)\nthis:\n  M \\<in> Chains {(g, g'). g' \\<le> g}\n\ngoal (1 subgoal):\n 1. \\<Sqinter> M \\<in> F", "then"], ["proof (chain)\npicking this:\n  M \\<in> Chains {(g, g'). g' \\<le> g}", "have chain: \"Complete_Partial_Order.chain (\\<ge>) M\""], ["proof (prove)\nusing this:\n  M \\<in> Chains {(g, g'). g' \\<le> g}\n\ngoal (1 subgoal):\n 1. Complete_Partial_Order.chain (\\<lambda>x y. y \\<le> x) M", "by(rule Chains_into_chain)"], ["proof (state)\nthis:\n  Complete_Partial_Order.chain (\\<lambda>x y. y \\<le> x) M\n\ngoal (1 subgoal):\n 1. \\<Sqinter> M \\<in> F", "hence chain': \"Complete_Partial_Order.chain (\\<le>) M\""], ["proof (prove)\nusing this:\n  Complete_Partial_Order.chain (\\<lambda>x y. y \\<le> x) M\n\ngoal (1 subgoal):\n 1. Complete_Partial_Order.chain (\\<le>) M", "by(simp add: chain_dual)"], ["proof (state)\nthis:\n  Complete_Partial_Order.chain (\\<le>) M\n\ngoal (1 subgoal):\n 1. \\<Sqinter> M \\<in> F", "have countable': \"countable (support_flow f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. countable (support_flow f)", "using current_support_flow[OF f]"], ["proof (prove)\nusing this:\n  support_flow f \\<subseteq> \\<^bold>E\n\ngoal (1 subgoal):\n 1. countable (support_flow f)", "by(rule countable_subset)(rule countable)"], ["proof (state)\nthis:\n  countable (support_flow f)\n\ngoal (1 subgoal):\n 1. \\<Sqinter> M \\<in> F", "have OUT_M: \"d_OUT (Inf M) x = (INF g\\<in>M. d_OUT g x)\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT (\\<Sqinter> M) x = (\\<Sqinter>g\\<in>M. d_OUT g x)", "using chain' nempty countable' _ finite_OUT"], ["proof (prove)\nusing this:\n  Complete_Partial_Order.chain (\\<le>) M\n  M \\<noteq> {}\n  countable (support_flow f)\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  d_OUT f ?x \\<noteq> \\<top>\n\ngoal (1 subgoal):\n 1. d_OUT (\\<Sqinter> M) x = (\\<Sqinter>g\\<in>M. d_OUT g x)", "by(rule d_OUT_Inf)(auto dest!: Chains_FieldD[OF M]  simp add: leq_def)"], ["proof (state)\nthis:\n  d_OUT (\\<Sqinter> M) ?x = (\\<Sqinter>g\\<in>M. d_OUT g ?x)\n\ngoal (1 subgoal):\n 1. \\<Sqinter> M \\<in> F", "have IN_M: \"d_IN (Inf M) x = (INF g\\<in>M. d_IN g x)\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN (\\<Sqinter> M) x = (\\<Sqinter>g\\<in>M. d_IN g x)", "using chain' nempty countable' _ finite_IN"], ["proof (prove)\nusing this:\n  Complete_Partial_Order.chain (\\<le>) M\n  M \\<noteq> {}\n  countable (support_flow f)\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  d_IN f ?x \\<noteq> \\<top>\n\ngoal (1 subgoal):\n 1. d_IN (\\<Sqinter> M) x = (\\<Sqinter>g\\<in>M. d_IN g x)", "by(rule d_IN_Inf)(auto dest!: Chains_FieldD[OF M]  simp add: leq_def)"], ["proof (state)\nthis:\n  d_IN (\\<Sqinter> M) ?x = (\\<Sqinter>g\\<in>M. d_IN g ?x)\n\ngoal (1 subgoal):\n 1. \\<Sqinter> M \\<in> F", "have c: \"current \\<Gamma> (Inf M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. current \\<Gamma> (\\<Sqinter> M)", "using g"], ["proof (prove)\nusing this:\n  current \\<Gamma> g0\n\ngoal (1 subgoal):\n 1. current \\<Gamma> (\\<Sqinter> M)", "proof(rule current_leI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>e. (\\<Sqinter> M) e \\<le> g0 e\n 2. \\<And>x.\n       x \\<notin> A \\<Gamma> \\<Longrightarrow>\n       d_OUT (\\<Sqinter> M) x \\<le> d_IN (\\<Sqinter> M) x", "show \"(Inf M) e \\<le> g0 e\" for e"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sqinter> M) e \\<le> g0 e", "using g0"], ["proof (prove)\nusing this:\n  g0 \\<in> M\n\ngoal (1 subgoal):\n 1. (\\<Sqinter> M) e \\<le> g0 e", "by(auto intro: INF_lower)"], ["proof (state)\nthis:\n  (\\<Sqinter> M) ?e \\<le> g0 ?e\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<notin> A \\<Gamma> \\<Longrightarrow>\n       d_OUT (\\<Sqinter> M) x \\<le> d_IN (\\<Sqinter> M) x", "show \"d_OUT (\\<Sqinter>M) x \\<le> d_IN (\\<Sqinter>M) x\" if \"x \\<notin> A \\<Gamma>\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT (\\<Sqinter> M) x \\<le> d_IN (\\<Sqinter> M) x", "by(auto 4 4 simp add: IN_M OUT_M leq_def intro!: INF_mono dest: Chains_FieldD[OF M] intro: currentD_OUT_IN[OF _ that])"], ["proof (state)\nthis:\n  ?x \\<notin> A \\<Gamma> \\<Longrightarrow>\n  d_OUT (\\<Sqinter> M) ?x \\<le> d_IN (\\<Sqinter> M) ?x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  current \\<Gamma> (\\<Sqinter> M)\n\ngoal (1 subgoal):\n 1. \\<Sqinter> M \\<in> F", "have INF_le_f: \"Inf M e \\<le> f e\" for e"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sqinter> M) e \\<le> f e", "using g0"], ["proof (prove)\nusing this:\n  g0 \\<in> M\n\ngoal (1 subgoal):\n 1. (\\<Sqinter> M) e \\<le> f e", "by(auto intro!: INF_lower2 g0_le_f)"], ["proof (state)\nthis:\n  (\\<Sqinter> M) ?e \\<le> f ?e\n\ngoal (1 subgoal):\n 1. \\<Sqinter> M \\<in> F", "have eq: \"\\<E> (TER (Inf M)) = \\<E> (TER f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<E> (TER (\\<Sqinter> M)) = \\<E> (TER f)", "using f w INF_le_f"], ["proof (prove)\nusing this:\n  current \\<Gamma> f\n  wave \\<Gamma> f\n  (\\<Sqinter> M) ?e \\<le> f ?e\n\ngoal (1 subgoal):\n 1. \\<E> (TER (\\<Sqinter> M)) = \\<E> (TER f)", "proof(rule essential_eq_leI; intro subsetI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>current \\<Gamma> f; wave \\<Gamma> f;\n        \\<And>e. (\\<Sqinter> M) e \\<le> f e; x \\<in> \\<E> (TER f)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> TER (\\<Sqinter> M)", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>current \\<Gamma> f; wave \\<Gamma> f;\n        \\<And>e. (\\<Sqinter> M) e \\<le> f e; x \\<in> \\<E> (TER f)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> TER (\\<Sqinter> M)", "assume x: \"x \\<in> \\<E> (TER f)\""], ["proof (state)\nthis:\n  x \\<in> \\<E> (TER f)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>current \\<Gamma> f; wave \\<Gamma> f;\n        \\<And>e. (\\<Sqinter> M) e \\<le> f e; x \\<in> \\<E> (TER f)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> TER (\\<Sqinter> M)", "hence \"x \\<in> SINK (Inf M)\""], ["proof (prove)\nusing this:\n  x \\<in> \\<E> (TER f)\n\ngoal (1 subgoal):\n 1. x \\<in> SINK (\\<Sqinter> M)", "using d_OUT_mono[of \"Inf M\" x f, OF INF_le_f]"], ["proof (prove)\nusing this:\n  x \\<in> \\<E> (TER f)\n  d_OUT (\\<Sqinter> M) x \\<le> d_OUT f x\n\ngoal (1 subgoal):\n 1. x \\<in> SINK (\\<Sqinter> M)", "by(auto simp add: SINK.simps)"], ["proof (state)\nthis:\n  x \\<in> SINK (\\<Sqinter> M)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>current \\<Gamma> f; wave \\<Gamma> f;\n        \\<And>e. (\\<Sqinter> M) e \\<le> f e; x \\<in> \\<E> (TER f)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> TER (\\<Sqinter> M)", "moreover"], ["proof (state)\nthis:\n  x \\<in> SINK (\\<Sqinter> M)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>current \\<Gamma> f; wave \\<Gamma> f;\n        \\<And>e. (\\<Sqinter> M) e \\<le> f e; x \\<in> \\<E> (TER f)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> TER (\\<Sqinter> M)", "from x"], ["proof (chain)\npicking this:\n  x \\<in> \\<E> (TER f)", "have \"x \\<in> SAT \\<Gamma> g\" if \"g \\<in> M\" for g"], ["proof (prove)\nusing this:\n  x \\<in> \\<E> (TER f)\n\ngoal (1 subgoal):\n 1. x \\<in> SAT \\<Gamma> g", "using Chains_FieldD[OF M that]"], ["proof (prove)\nusing this:\n  x \\<in> \\<E> (TER f)\n  g \\<in> Field leq\n\ngoal (1 subgoal):\n 1. x \\<in> SAT \\<Gamma> g", "by(auto simp add: leq_def)"], ["proof (state)\nthis:\n  ?g \\<in> M \\<Longrightarrow> x \\<in> SAT \\<Gamma> ?g\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>current \\<Gamma> f; wave \\<Gamma> f;\n        \\<And>e. (\\<Sqinter> M) e \\<le> f e; x \\<in> \\<E> (TER f)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> TER (\\<Sqinter> M)", "hence \"x \\<in> SAT \\<Gamma> (Inf M)\""], ["proof (prove)\nusing this:\n  ?g \\<in> M \\<Longrightarrow> x \\<in> SAT \\<Gamma> ?g\n\ngoal (1 subgoal):\n 1. x \\<in> SAT \\<Gamma> (\\<Sqinter> M)", "by(auto simp add: SAT.simps IN_M intro!: INF_greatest)"], ["proof (state)\nthis:\n  x \\<in> SAT \\<Gamma> (\\<Sqinter> M)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>current \\<Gamma> f; wave \\<Gamma> f;\n        \\<And>e. (\\<Sqinter> M) e \\<le> f e; x \\<in> \\<E> (TER f)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> TER (\\<Sqinter> M)", "ultimately"], ["proof (chain)\npicking this:\n  x \\<in> SINK (\\<Sqinter> M)\n  x \\<in> SAT \\<Gamma> (\\<Sqinter> M)", "show \"x \\<in> TER (Inf M)\""], ["proof (prove)\nusing this:\n  x \\<in> SINK (\\<Sqinter> M)\n  x \\<in> SAT \\<Gamma> (\\<Sqinter> M)\n\ngoal (1 subgoal):\n 1. x \\<in> TER (\\<Sqinter> M)", "by auto"], ["proof (state)\nthis:\n  x \\<in> TER (\\<Sqinter> M)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<E> (TER (\\<Sqinter> M)) = \\<E> (TER f)\n\ngoal (1 subgoal):\n 1. \\<Sqinter> M \\<in> F", "have w': \"wave \\<Gamma> (Inf M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wave \\<Gamma> (\\<Sqinter> M)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. separating \\<Gamma> (TER (\\<Sqinter> M))\n 2. \\<And>x.\n       x \\<notin> RF (TER (\\<Sqinter> M)) \\<Longrightarrow>\n       d_OUT (\\<Sqinter> M) x = 0", "have \"separating \\<Gamma> (\\<E> (TER f))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. separating \\<Gamma> (\\<E> (TER f))", "by(rule separating_essential)(rule waveD_separating[OF w])"], ["proof (state)\nthis:\n  separating \\<Gamma> (\\<E> (TER f))\n\ngoal (2 subgoals):\n 1. separating \\<Gamma> (TER (\\<Sqinter> M))\n 2. \\<And>x.\n       x \\<notin> RF (TER (\\<Sqinter> M)) \\<Longrightarrow>\n       d_OUT (\\<Sqinter> M) x = 0", "then"], ["proof (chain)\npicking this:\n  separating \\<Gamma> (\\<E> (TER f))", "show \"separating \\<Gamma> (TER (Inf M))\""], ["proof (prove)\nusing this:\n  separating \\<Gamma> (\\<E> (TER f))\n\ngoal (1 subgoal):\n 1. separating \\<Gamma> (TER (\\<Sqinter> M))", "unfolding eq[symmetric]"], ["proof (prove)\nusing this:\n  separating \\<Gamma> (\\<E> (TER (\\<Sqinter> M)))\n\ngoal (1 subgoal):\n 1. separating \\<Gamma> (TER (\\<Sqinter> M))", "by(rule separating_weakening) auto"], ["proof (state)\nthis:\n  separating \\<Gamma> (TER (\\<Sqinter> M))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<notin> RF (TER (\\<Sqinter> M)) \\<Longrightarrow>\n       d_OUT (\\<Sqinter> M) x = 0", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<notin> RF (TER (\\<Sqinter> M)) \\<Longrightarrow>\n       d_OUT (\\<Sqinter> M) x = 0", "assume \"x \\<notin> RF (TER (Inf M))\""], ["proof (state)\nthis:\n  x \\<notin> RF (TER (\\<Sqinter> M))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<notin> RF (TER (\\<Sqinter> M)) \\<Longrightarrow>\n       d_OUT (\\<Sqinter> M) x = 0", "hence \"x \\<notin> RF (\\<E> (TER (Inf M)))\""], ["proof (prove)\nusing this:\n  x \\<notin> RF (TER (\\<Sqinter> M))\n\ngoal (1 subgoal):\n 1. x \\<notin> RF (\\<E> (TER (\\<Sqinter> M)))", "unfolding RF_essential"], ["proof (prove)\nusing this:\n  x \\<notin> RF (TER (\\<Sqinter> M))\n\ngoal (1 subgoal):\n 1. x \\<notin> RF (TER (\\<Sqinter> M))", "."], ["proof (state)\nthis:\n  x \\<notin> RF (\\<E> (TER (\\<Sqinter> M)))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<notin> RF (TER (\\<Sqinter> M)) \\<Longrightarrow>\n       d_OUT (\\<Sqinter> M) x = 0", "hence \"x \\<notin> RF (TER f)\""], ["proof (prove)\nusing this:\n  x \\<notin> RF (\\<E> (TER (\\<Sqinter> M)))\n\ngoal (1 subgoal):\n 1. x \\<notin> RF (TER f)", "unfolding eq RF_essential"], ["proof (prove)\nusing this:\n  x \\<notin> RF (TER f)\n\ngoal (1 subgoal):\n 1. x \\<notin> RF (TER f)", "."], ["proof (state)\nthis:\n  x \\<notin> RF (TER f)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<notin> RF (TER (\\<Sqinter> M)) \\<Longrightarrow>\n       d_OUT (\\<Sqinter> M) x = 0", "hence \"d_OUT f x = 0\""], ["proof (prove)\nusing this:\n  x \\<notin> RF (TER f)\n\ngoal (1 subgoal):\n 1. d_OUT f x = 0", "by(rule waveD_OUT[OF w])"], ["proof (state)\nthis:\n  d_OUT f x = 0\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<notin> RF (TER (\\<Sqinter> M)) \\<Longrightarrow>\n       d_OUT (\\<Sqinter> M) x = 0", "with d_OUT_mono[of _ x f, OF INF_le_f]"], ["proof (chain)\npicking this:\n  d_OUT (\\<Sqinter> M) x \\<le> d_OUT f x\n  d_OUT f x = 0", "show \"d_OUT (Inf M) x = 0\""], ["proof (prove)\nusing this:\n  d_OUT (\\<Sqinter> M) x \\<le> d_OUT f x\n  d_OUT f x = 0\n\ngoal (1 subgoal):\n 1. d_OUT (\\<Sqinter> M) x = 0", "by (metis le_zero_eq)"], ["proof (state)\nthis:\n  d_OUT (\\<Sqinter> M) x = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  wave \\<Gamma> (\\<Sqinter> M)\n\ngoal (1 subgoal):\n 1. \\<Sqinter> M \\<in> F", "from c w' INF_le_f eq"], ["proof (chain)\npicking this:\n  current \\<Gamma> (\\<Sqinter> M)\n  wave \\<Gamma> (\\<Sqinter> M)\n  (\\<Sqinter> M) ?e \\<le> f ?e\n  \\<E> (TER (\\<Sqinter> M)) = \\<E> (TER f)", "show ?thesis"], ["proof (prove)\nusing this:\n  current \\<Gamma> (\\<Sqinter> M)\n  wave \\<Gamma> (\\<Sqinter> M)\n  (\\<Sqinter> M) ?e \\<le> f ?e\n  \\<E> (TER (\\<Sqinter> M)) = \\<E> (TER f)\n\ngoal (1 subgoal):\n 1. \\<Sqinter> M \\<in> F", "by simp"], ["proof (state)\nthis:\n  \\<Sqinter> M \\<in> F\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>?M \\<in> Chains leq; ?M \\<noteq> {}\\<rbrakk>\n  \\<Longrightarrow> \\<Sqinter> ?M \\<in> F\n\ngoal (1 subgoal):\n 1. Ex local.trimming", "define trim1\n    where \"trim1 g =\n      (if trimming g then g\n        else let z = SOME z. z \\<in> RF\\<^sup>\\<circ> (TER g) \\<and> z \\<notin> A \\<Gamma> \\<and> \\<not> KIR g z;\n            factor = d_OUT g z / d_IN g z\n          in (\\<lambda>(y, x). (if x = z then factor else 1) * g (y, x)))\" for g"], ["proof (state)\nthis:\n  trim1 ?g =\n  (if local.trimming ?g then ?g\n   else let z = SOME z.\n                   z \\<in> RF\\<^sup>\\<circ> (TER ?g) \\<and>\n                   z \\<notin> A \\<Gamma> \\<and>\n                   d_OUT ?g z \\<noteq> d_IN ?g z;\n            factor = d_OUT ?g z / d_IN ?g z\n        in (\\<lambda>(y, x). (if x = z then factor else 1) * ?g (y, x)))\n\ngoal (1 subgoal):\n 1. Ex local.trimming", "have increasing: \"trim1 g \\<le> g \\<and> trim1 g \\<in> F\" if \"g \\<in> F\" for g"], ["proof (prove)\ngoal (1 subgoal):\n 1. trim1 g \\<le> g \\<and> trim1 g \\<in> F", "proof(cases \"trimming g\")"], ["proof (state)\ngoal (2 subgoals):\n 1. local.trimming g \\<Longrightarrow>\n    trim1 g \\<le> g \\<and> trim1 g \\<in> F\n 2. \\<not> local.trimming g \\<Longrightarrow>\n    trim1 g \\<le> g \\<and> trim1 g \\<in> F", "case True"], ["proof (state)\nthis:\n  local.trimming g\n\ngoal (2 subgoals):\n 1. local.trimming g \\<Longrightarrow>\n    trim1 g \\<le> g \\<and> trim1 g \\<in> F\n 2. \\<not> local.trimming g \\<Longrightarrow>\n    trim1 g \\<le> g \\<and> trim1 g \\<in> F", "thus ?thesis"], ["proof (prove)\nusing this:\n  local.trimming g\n\ngoal (1 subgoal):\n 1. trim1 g \\<le> g \\<and> trim1 g \\<in> F", "using that"], ["proof (prove)\nusing this:\n  local.trimming g\n  g \\<in> F\n\ngoal (1 subgoal):\n 1. trim1 g \\<le> g \\<and> trim1 g \\<in> F", "by(simp add: trim1_def)"], ["proof (state)\nthis:\n  trim1 g \\<le> g \\<and> trim1 g \\<in> F\n\ngoal (1 subgoal):\n 1. \\<not> local.trimming g \\<Longrightarrow>\n    trim1 g \\<le> g \\<and> trim1 g \\<in> F", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> local.trimming g \\<Longrightarrow>\n    trim1 g \\<le> g \\<and> trim1 g \\<in> F", "case False"], ["proof (state)\nthis:\n  \\<not> local.trimming g\n\ngoal (1 subgoal):\n 1. \\<not> local.trimming g \\<Longrightarrow>\n    trim1 g \\<le> g \\<and> trim1 g \\<in> F", "let ?P = \"\\<lambda>z. z \\<in> RF\\<^sup>\\<circ> (TER g) \\<and> z \\<notin> A \\<Gamma> \\<and> \\<not> KIR g z\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> local.trimming g \\<Longrightarrow>\n    trim1 g \\<le> g \\<and> trim1 g \\<in> F", "define z where \"z = Eps ?P\""], ["proof (state)\nthis:\n  z =\n  (SOME z.\n      z \\<in> RF\\<^sup>\\<circ> (TER g) \\<and>\n      z \\<notin> A \\<Gamma> \\<and> d_OUT g z \\<noteq> d_IN g z)\n\ngoal (1 subgoal):\n 1. \\<not> local.trimming g \\<Longrightarrow>\n    trim1 g \\<le> g \\<and> trim1 g \\<in> F", "from that"], ["proof (chain)\npicking this:\n  g \\<in> F", "have g: \"current \\<Gamma> g\" and w': \"wave \\<Gamma> g\" and le_f: \"\\<And>e. g e \\<le> f e\"\n      and \\<E>: \"\\<E> (TER g) = \\<E> (TER f)\""], ["proof (prove)\nusing this:\n  g \\<in> F\n\ngoal (1 subgoal):\n 1. (current \\<Gamma> g &&& wave \\<Gamma> g) &&&\n    (\\<And>e. g e \\<le> f e) &&& \\<E> (TER g) = \\<E> (TER f)", "by(auto simp add: le_fun_def)"], ["proof (state)\nthis:\n  current \\<Gamma> g\n  wave \\<Gamma> g\n  g ?e \\<le> f ?e\n  \\<E> (TER g) = \\<E> (TER f)\n\ngoal (1 subgoal):\n 1. \\<not> local.trimming g \\<Longrightarrow>\n    trim1 g \\<le> g \\<and> trim1 g \\<in> F", "{"], ["proof (state)\nthis:\n  current \\<Gamma> g\n  wave \\<Gamma> g\n  g ?e \\<le> f ?e\n  \\<E> (TER g) = \\<E> (TER f)\n\ngoal (1 subgoal):\n 1. \\<not> local.trimming g \\<Longrightarrow>\n    trim1 g \\<le> g \\<and> trim1 g \\<in> F", "with False"], ["proof (chain)\npicking this:\n  \\<not> local.trimming g\n  current \\<Gamma> g\n  wave \\<Gamma> g\n  g ?e \\<le> f ?e\n  \\<E> (TER g) = \\<E> (TER f)", "obtain z where z: \"z \\<in> RF\\<^sup>\\<circ> (TER f)\" and A: \"z \\<notin> A \\<Gamma>\" and neq: \"d_OUT g z \\<noteq> d_IN g z\""], ["proof (prove)\nusing this:\n  \\<not> local.trimming g\n  current \\<Gamma> g\n  wave \\<Gamma> g\n  g ?e \\<le> f ?e\n  \\<E> (TER g) = \\<E> (TER f)\n\ngoal (1 subgoal):\n 1. (\\<And>z.\n        \\<lbrakk>z \\<in> RF\\<^sup>\\<circ> (TER f); z \\<notin> A \\<Gamma>;\n         d_OUT g z \\<noteq> d_IN g z\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto simp add: trimming.simps le_fun_def)"], ["proof (state)\nthis:\n  z \\<in> RF\\<^sup>\\<circ> (TER f)\n  z \\<notin> A \\<Gamma>\n  d_OUT g z \\<noteq> d_IN g z\n\ngoal (1 subgoal):\n 1. \\<not> local.trimming g \\<Longrightarrow>\n    trim1 g \\<le> g \\<and> trim1 g \\<in> F", "from z"], ["proof (chain)\npicking this:\n  z \\<in> RF\\<^sup>\\<circ> (TER f)", "have \"z \\<in> RF\\<^sup>\\<circ> (\\<E> (TER f))\""], ["proof (prove)\nusing this:\n  z \\<in> RF\\<^sup>\\<circ> (TER f)\n\ngoal (1 subgoal):\n 1. z \\<in> RF\\<^sup>\\<circ> (\\<E> (TER f))", "unfolding roofed_circ_essential"], ["proof (prove)\nusing this:\n  z \\<in> RF\\<^sup>\\<circ> (TER f)\n\ngoal (1 subgoal):\n 1. z \\<in> RF\\<^sup>\\<circ> (TER f)", "."], ["proof (state)\nthis:\n  z \\<in> RF\\<^sup>\\<circ> (\\<E> (TER f))\n\ngoal (1 subgoal):\n 1. \\<not> local.trimming g \\<Longrightarrow>\n    trim1 g \\<le> g \\<and> trim1 g \\<in> F", "with \\<E> roofed_circ_essential[of \\<Gamma> \"TER g\"]"], ["proof (chain)\npicking this:\n  \\<E> (TER g) = \\<E> (TER f)\n  RF\\<^sup>\\<circ> (\\<E> (TER g)) = RF\\<^sup>\\<circ> (TER g)\n  z \\<in> RF\\<^sup>\\<circ> (\\<E> (TER f))", "have \"z \\<in> RF\\<^sup>\\<circ> (TER g)\""], ["proof (prove)\nusing this:\n  \\<E> (TER g) = \\<E> (TER f)\n  RF\\<^sup>\\<circ> (\\<E> (TER g)) = RF\\<^sup>\\<circ> (TER g)\n  z \\<in> RF\\<^sup>\\<circ> (\\<E> (TER f))\n\ngoal (1 subgoal):\n 1. z \\<in> RF\\<^sup>\\<circ> (TER g)", "by simp"], ["proof (state)\nthis:\n  z \\<in> RF\\<^sup>\\<circ> (TER g)\n\ngoal (1 subgoal):\n 1. \\<not> local.trimming g \\<Longrightarrow>\n    trim1 g \\<le> g \\<and> trim1 g \\<in> F", "with A neq"], ["proof (chain)\npicking this:\n  z \\<notin> A \\<Gamma>\n  d_OUT g z \\<noteq> d_IN g z\n  z \\<in> RF\\<^sup>\\<circ> (TER g)", "have \"\\<exists>x. ?P x\""], ["proof (prove)\nusing this:\n  z \\<notin> A \\<Gamma>\n  d_OUT g z \\<noteq> d_IN g z\n  z \\<in> RF\\<^sup>\\<circ> (TER g)\n\ngoal (1 subgoal):\n 1. \\<exists>x.\n       x \\<in> RF\\<^sup>\\<circ> (TER g) \\<and>\n       x \\<notin> A \\<Gamma> \\<and> d_OUT g x \\<noteq> d_IN g x", "by auto"], ["proof (state)\nthis:\n  \\<exists>x.\n     x \\<in> RF\\<^sup>\\<circ> (TER g) \\<and>\n     x \\<notin> A \\<Gamma> \\<and> d_OUT g x \\<noteq> d_IN g x\n\ngoal (1 subgoal):\n 1. \\<not> local.trimming g \\<Longrightarrow>\n    trim1 g \\<le> g \\<and> trim1 g \\<in> F", "}"], ["proof (state)\nthis:\n  \\<exists>x.\n     x \\<in> RF\\<^sup>\\<circ> (TER g) \\<and>\n     x \\<notin> A \\<Gamma> \\<and> d_OUT g x \\<noteq> d_IN g x\n\ngoal (1 subgoal):\n 1. \\<not> local.trimming g \\<Longrightarrow>\n    trim1 g \\<le> g \\<and> trim1 g \\<in> F", "hence \"?P z\""], ["proof (prove)\nusing this:\n  \\<exists>x.\n     x \\<in> RF\\<^sup>\\<circ> (TER g) \\<and>\n     x \\<notin> A \\<Gamma> \\<and> d_OUT g x \\<noteq> d_IN g x\n\ngoal (1 subgoal):\n 1. z \\<in> RF\\<^sup>\\<circ> (TER g) \\<and>\n    z \\<notin> A \\<Gamma> \\<and> d_OUT g z \\<noteq> d_IN g z", "unfolding z_def"], ["proof (prove)\nusing this:\n  \\<exists>x.\n     x \\<in> RF\\<^sup>\\<circ> (TER g) \\<and>\n     x \\<notin> A \\<Gamma> \\<and> d_OUT g x \\<noteq> d_IN g x\n\ngoal (1 subgoal):\n 1. (SOME z.\n        z \\<in> RF\\<^sup>\\<circ> (TER g) \\<and>\n        z \\<notin> A \\<Gamma> \\<and> d_OUT g z \\<noteq> d_IN g z)\n    \\<in> RF\\<^sup>\\<circ> (TER g) \\<and>\n    (SOME z.\n        z \\<in> RF\\<^sup>\\<circ> (TER g) \\<and>\n        z \\<notin> A \\<Gamma> \\<and> d_OUT g z \\<noteq> d_IN g z)\n    \\<notin> A \\<Gamma> \\<and>\n    d_OUT g\n     (SOME z.\n         z \\<in> RF\\<^sup>\\<circ> (TER g) \\<and>\n         z \\<notin> A \\<Gamma> \\<and> d_OUT g z \\<noteq> d_IN g z) \\<noteq>\n    d_IN g\n     (SOME z.\n         z \\<in> RF\\<^sup>\\<circ> (TER g) \\<and>\n         z \\<notin> A \\<Gamma> \\<and> d_OUT g z \\<noteq> d_IN g z)", "by(rule someI_ex)"], ["proof (state)\nthis:\n  z \\<in> RF\\<^sup>\\<circ> (TER g) \\<and>\n  z \\<notin> A \\<Gamma> \\<and> d_OUT g z \\<noteq> d_IN g z\n\ngoal (1 subgoal):\n 1. \\<not> local.trimming g \\<Longrightarrow>\n    trim1 g \\<le> g \\<and> trim1 g \\<in> F", "hence RF: \"z \\<in> RF\\<^sup>\\<circ> (TER g)\" and A: \"z \\<notin> A \\<Gamma>\" and neq: \"d_OUT g z \\<noteq> d_IN g z\""], ["proof (prove)\nusing this:\n  z \\<in> RF\\<^sup>\\<circ> (TER g) \\<and>\n  z \\<notin> A \\<Gamma> \\<and> d_OUT g z \\<noteq> d_IN g z\n\ngoal (1 subgoal):\n 1. z \\<in> RF\\<^sup>\\<circ> (TER g) &&&\n    z \\<notin> A \\<Gamma> &&& d_OUT g z \\<noteq> d_IN g z", "by simp_all"], ["proof (state)\nthis:\n  z \\<in> RF\\<^sup>\\<circ> (TER g)\n  z \\<notin> A \\<Gamma>\n  d_OUT g z \\<noteq> d_IN g z\n\ngoal (1 subgoal):\n 1. \\<not> local.trimming g \\<Longrightarrow>\n    trim1 g \\<le> g \\<and> trim1 g \\<in> F", "let ?factor = \"d_OUT g z / d_IN g z\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> local.trimming g \\<Longrightarrow>\n    trim1 g \\<le> g \\<and> trim1 g \\<in> F", "have trim1 [simp]: \"trim1 g (y, x) = (if x = z then ?factor else 1) * g (y, x)\" for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. trim1 g (y, x) = (if x = z then d_OUT g z / d_IN g z else 1) * g (y, x)", "using False"], ["proof (prove)\nusing this:\n  \\<not> local.trimming g\n\ngoal (1 subgoal):\n 1. trim1 g (y, x) = (if x = z then d_OUT g z / d_IN g z else 1) * g (y, x)", "by(auto simp add: trim1_def z_def Let_def)"], ["proof (state)\nthis:\n  trim1 g (?y, ?x) =\n  (if ?x = z then d_OUT g z / d_IN g z else 1) * g (?y, ?x)\n\ngoal (1 subgoal):\n 1. \\<not> local.trimming g \\<Longrightarrow>\n    trim1 g \\<le> g \\<and> trim1 g \\<in> F", "from currentD_OUT_IN[OF g A] neq"], ["proof (chain)\npicking this:\n  d_OUT g z \\<le> d_IN g z\n  d_OUT g z \\<noteq> d_IN g z", "have less: \"d_OUT g z < d_IN g z\""], ["proof (prove)\nusing this:\n  d_OUT g z \\<le> d_IN g z\n  d_OUT g z \\<noteq> d_IN g z\n\ngoal (1 subgoal):\n 1. d_OUT g z < d_IN g z", "by auto"], ["proof (state)\nthis:\n  d_OUT g z < d_IN g z\n\ngoal (1 subgoal):\n 1. \\<not> local.trimming g \\<Longrightarrow>\n    trim1 g \\<le> g \\<and> trim1 g \\<in> F", "hence \"?factor \\<le> 1\" (is \"?factor \\<le> _\")"], ["proof (prove)\nusing this:\n  d_OUT g z < d_IN g z\n\ngoal (1 subgoal):\n 1. d_OUT g z / d_IN g z \\<le> 1", "by (auto intro!: divide_le_posI_ennreal simp: zero_less_iff_neq_zero)"], ["proof (state)\nthis:\n  d_OUT g z / d_IN g z \\<le> 1\n\ngoal (1 subgoal):\n 1. \\<not> local.trimming g \\<Longrightarrow>\n    trim1 g \\<le> g \\<and> trim1 g \\<in> F", "hence le': \"?factor * g (y, x) \\<le> 1 * g (y, x)\" for y x"], ["proof (prove)\nusing this:\n  d_OUT g z / d_IN g z \\<le> 1\n\ngoal (1 subgoal):\n 1. d_OUT g z / d_IN g z * g (y, x) \\<le> 1 * g (y, x)", "by(rule mult_right_mono) simp"], ["proof (state)\nthis:\n  d_OUT g z / d_IN g z * g (?y, ?x) \\<le> 1 * g (?y, ?x)\n\ngoal (1 subgoal):\n 1. \\<not> local.trimming g \\<Longrightarrow>\n    trim1 g \\<le> g \\<and> trim1 g \\<in> F", "hence le: \"trim1 g e \\<le> g e\" for e"], ["proof (prove)\nusing this:\n  d_OUT g z / d_IN g z * g (?y, ?x) \\<le> 1 * g (?y, ?x)\n\ngoal (1 subgoal):\n 1. trim1 g e \\<le> g e", "by(cases e)simp"], ["proof (state)\nthis:\n  trim1 g ?e \\<le> g ?e\n\ngoal (1 subgoal):\n 1. \\<not> local.trimming g \\<Longrightarrow>\n    trim1 g \\<le> g \\<and> trim1 g \\<in> F", "moreover"], ["proof (state)\nthis:\n  trim1 g ?e \\<le> g ?e\n\ngoal (1 subgoal):\n 1. \\<not> local.trimming g \\<Longrightarrow>\n    trim1 g \\<le> g \\<and> trim1 g \\<in> F", "{"], ["proof (state)\nthis:\n  trim1 g ?e \\<le> g ?e\n\ngoal (1 subgoal):\n 1. \\<not> local.trimming g \\<Longrightarrow>\n    trim1 g \\<le> g \\<and> trim1 g \\<in> F", "have c: \"current \\<Gamma> (trim1 g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. current \\<Gamma> (trim1 g)", "using g le"], ["proof (prove)\nusing this:\n  current \\<Gamma> g\n  trim1 g ?e \\<le> g ?e\n\ngoal (1 subgoal):\n 1. current \\<Gamma> (trim1 g)", "proof(rule current_leI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<notin> A \\<Gamma> \\<Longrightarrow>\n       d_OUT (trim1 g) x \\<le> d_IN (trim1 g) x", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<notin> A \\<Gamma> \\<Longrightarrow>\n       d_OUT (trim1 g) x \\<le> d_IN (trim1 g) x", "assume x: \"x \\<notin> A \\<Gamma>\""], ["proof (state)\nthis:\n  x \\<notin> A \\<Gamma>\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<notin> A \\<Gamma> \\<Longrightarrow>\n       d_OUT (trim1 g) x \\<le> d_IN (trim1 g) x", "have \"d_OUT (trim1 g) x \\<le> d_OUT g x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT (trim1 g) x \\<le> d_OUT g x", "unfolding d_OUT_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y. trim1 g (x, y)) \\<le> (\\<Sum>\\<^sup>+ y. g (x, y))", "using le'"], ["proof (prove)\nusing this:\n  d_OUT g z / d_IN g z * g (?y, ?x) \\<le> 1 * g (?y, ?x)\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y. trim1 g (x, y)) \\<le> (\\<Sum>\\<^sup>+ y. g (x, y))", "by(auto intro: nn_integral_mono)"], ["proof (state)\nthis:\n  d_OUT (trim1 g) x \\<le> d_OUT g x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<notin> A \\<Gamma> \\<Longrightarrow>\n       d_OUT (trim1 g) x \\<le> d_IN (trim1 g) x", "also"], ["proof (state)\nthis:\n  d_OUT (trim1 g) x \\<le> d_OUT g x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<notin> A \\<Gamma> \\<Longrightarrow>\n       d_OUT (trim1 g) x \\<le> d_IN (trim1 g) x", "have \"\\<dots> \\<le> d_IN (trim1 g) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT g x \\<le> d_IN (trim1 g) x", "proof(cases \"x = z\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x = z \\<Longrightarrow> d_OUT g x \\<le> d_IN (trim1 g) x\n 2. x \\<noteq> z \\<Longrightarrow> d_OUT g x \\<le> d_IN (trim1 g) x", "case True"], ["proof (state)\nthis:\n  x = z\n\ngoal (2 subgoals):\n 1. x = z \\<Longrightarrow> d_OUT g x \\<le> d_IN (trim1 g) x\n 2. x \\<noteq> z \\<Longrightarrow> d_OUT g x \\<le> d_IN (trim1 g) x", "have \"d_OUT g x = d_IN (trim1 g) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT g x = d_IN (trim1 g) x", "unfolding d_IN_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT g x = (\\<Sum>\\<^sup>+ xa. trim1 g (xa, x))", "using True currentD_weight_IN[OF g, of x] currentD_OUT_IN[OF g x]"], ["proof (prove)\nusing this:\n  x = z\n  d_IN g x \\<le> weight \\<Gamma> x\n  d_OUT g x \\<le> d_IN g x\n\ngoal (1 subgoal):\n 1. d_OUT g x = (\\<Sum>\\<^sup>+ xa. trim1 g (xa, x))", "apply (cases \"d_IN g x = 0\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x = z; d_IN g x \\<le> weight \\<Gamma> x;\n     d_OUT g x \\<le> d_IN g x; d_IN g x = 0\\<rbrakk>\n    \\<Longrightarrow> d_OUT g x = (\\<Sum>\\<^sup>+ xa. trim1 g (xa, x))\n 2. \\<lbrakk>x = z; d_IN g x \\<le> weight \\<Gamma> x;\n     d_OUT g x \\<le> d_IN g x; d_IN g x \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> d_OUT g x = (\\<Sum>\\<^sup>+ xa. trim1 g (xa, x))", "apply(auto simp add: nn_integral_divide nn_integral_cmult d_IN_def[symmetric] ennreal_divide_times)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x = z; d_IN g z \\<le> weight \\<Gamma> z;\n     d_OUT g z \\<le> d_IN g z; d_IN g z \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> d_OUT g z = d_OUT g z * (d_IN g z / d_IN g z)", "apply (subst ennreal_divide_self)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>x = z; d_IN g z \\<le> weight \\<Gamma> z;\n     d_OUT g z \\<le> d_IN g z; d_IN g z \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> d_IN g z \\<noteq> 0\n 2. \\<lbrakk>x = z; d_IN g z \\<le> weight \\<Gamma> z;\n     d_OUT g z \\<le> d_IN g z; d_IN g z \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> d_IN g z < \\<top>\n 3. \\<lbrakk>x = z; d_IN g z \\<le> weight \\<Gamma> z;\n     d_OUT g z \\<le> d_IN g z; d_IN g z \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> d_OUT g z = d_OUT g z * 1", "apply (auto simp: less_top[symmetric] top_unique weight_finite)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  d_OUT g x = d_IN (trim1 g) x\n\ngoal (2 subgoals):\n 1. x = z \\<Longrightarrow> d_OUT g x \\<le> d_IN (trim1 g) x\n 2. x \\<noteq> z \\<Longrightarrow> d_OUT g x \\<le> d_IN (trim1 g) x", "thus ?thesis"], ["proof (prove)\nusing this:\n  d_OUT g x = d_IN (trim1 g) x\n\ngoal (1 subgoal):\n 1. d_OUT g x \\<le> d_IN (trim1 g) x", "by simp"], ["proof (state)\nthis:\n  d_OUT g x \\<le> d_IN (trim1 g) x\n\ngoal (1 subgoal):\n 1. x \\<noteq> z \\<Longrightarrow> d_OUT g x \\<le> d_IN (trim1 g) x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<noteq> z \\<Longrightarrow> d_OUT g x \\<le> d_IN (trim1 g) x", "case False"], ["proof (state)\nthis:\n  x \\<noteq> z\n\ngoal (1 subgoal):\n 1. x \\<noteq> z \\<Longrightarrow> d_OUT g x \\<le> d_IN (trim1 g) x", "have \"d_OUT g x \\<le> d_IN g x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT g x \\<le> d_IN g x", "using x"], ["proof (prove)\nusing this:\n  x \\<notin> A \\<Gamma>\n\ngoal (1 subgoal):\n 1. d_OUT g x \\<le> d_IN g x", "by(rule currentD_OUT_IN[OF g])"], ["proof (state)\nthis:\n  d_OUT g x \\<le> d_IN g x\n\ngoal (1 subgoal):\n 1. x \\<noteq> z \\<Longrightarrow> d_OUT g x \\<le> d_IN (trim1 g) x", "also"], ["proof (state)\nthis:\n  d_OUT g x \\<le> d_IN g x\n\ngoal (1 subgoal):\n 1. x \\<noteq> z \\<Longrightarrow> d_OUT g x \\<le> d_IN (trim1 g) x", "have \"\\<dots> \\<le> d_IN (trim1 g) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN g x \\<le> d_IN (trim1 g) x", "unfolding d_IN_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ xa. g (xa, x))\n    \\<le> (\\<Sum>\\<^sup>+ xa. trim1 g (xa, x))", "using False"], ["proof (prove)\nusing this:\n  x \\<noteq> z\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ xa. g (xa, x))\n    \\<le> (\\<Sum>\\<^sup>+ xa. trim1 g (xa, x))", "by(auto intro!: nn_integral_mono)"], ["proof (state)\nthis:\n  d_IN g x \\<le> d_IN (trim1 g) x\n\ngoal (1 subgoal):\n 1. x \\<noteq> z \\<Longrightarrow> d_OUT g x \\<le> d_IN (trim1 g) x", "finally"], ["proof (chain)\npicking this:\n  d_OUT g x \\<le> d_IN (trim1 g) x", "show ?thesis"], ["proof (prove)\nusing this:\n  d_OUT g x \\<le> d_IN (trim1 g) x\n\ngoal (1 subgoal):\n 1. d_OUT g x \\<le> d_IN (trim1 g) x", "."], ["proof (state)\nthis:\n  d_OUT g x \\<le> d_IN (trim1 g) x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  d_OUT g x \\<le> d_IN (trim1 g) x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<notin> A \\<Gamma> \\<Longrightarrow>\n       d_OUT (trim1 g) x \\<le> d_IN (trim1 g) x", "finally"], ["proof (chain)\npicking this:\n  d_OUT (trim1 g) x \\<le> d_IN (trim1 g) x", "show \"d_OUT (trim1 g) x \\<le> d_IN (trim1 g) x\""], ["proof (prove)\nusing this:\n  d_OUT (trim1 g) x \\<le> d_IN (trim1 g) x\n\ngoal (1 subgoal):\n 1. d_OUT (trim1 g) x \\<le> d_IN (trim1 g) x", "."], ["proof (state)\nthis:\n  d_OUT (trim1 g) x \\<le> d_IN (trim1 g) x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  current \\<Gamma> (trim1 g)\n\ngoal (1 subgoal):\n 1. \\<not> local.trimming g \\<Longrightarrow>\n    trim1 g \\<le> g \\<and> trim1 g \\<in> F", "moreover"], ["proof (state)\nthis:\n  current \\<Gamma> (trim1 g)\n\ngoal (1 subgoal):\n 1. \\<not> local.trimming g \\<Longrightarrow>\n    trim1 g \\<le> g \\<and> trim1 g \\<in> F", "have le_f: \"trim1 g \\<le> f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trim1 g \\<le> f", "using le le_f"], ["proof (prove)\nusing this:\n  trim1 g ?e \\<le> g ?e\n  g ?e \\<le> f ?e\n\ngoal (1 subgoal):\n 1. trim1 g \\<le> f", "by(blast intro: le_funI order_trans)"], ["proof (state)\nthis:\n  trim1 g \\<le> f\n\ngoal (1 subgoal):\n 1. \\<not> local.trimming g \\<Longrightarrow>\n    trim1 g \\<le> g \\<and> trim1 g \\<in> F", "moreover"], ["proof (state)\nthis:\n  trim1 g \\<le> f\n\ngoal (1 subgoal):\n 1. \\<not> local.trimming g \\<Longrightarrow>\n    trim1 g \\<le> g \\<and> trim1 g \\<in> F", "have eq: \"\\<E> (TER (trim1 g)) = \\<E> (TER f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<E> (TER (trim1 g)) = \\<E> (TER f)", "unfolding \\<E>[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<E> (TER (trim1 g)) = \\<E> (TER g)", "using g w' le"], ["proof (prove)\nusing this:\n  current \\<Gamma> g\n  wave \\<Gamma> g\n  trim1 g ?e \\<le> g ?e\n\ngoal (1 subgoal):\n 1. \\<E> (TER (trim1 g)) = \\<E> (TER g)", "proof(rule essential_eq_leI; intro subsetI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>current \\<Gamma> g; wave \\<Gamma> g;\n        \\<And>e. trim1 g e \\<le> g e; x \\<in> \\<E> (TER g)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> TER (trim1 g)", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>current \\<Gamma> g; wave \\<Gamma> g;\n        \\<And>e. trim1 g e \\<le> g e; x \\<in> \\<E> (TER g)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> TER (trim1 g)", "assume x: \"x \\<in> \\<E> (TER g)\""], ["proof (state)\nthis:\n  x \\<in> \\<E> (TER g)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>current \\<Gamma> g; wave \\<Gamma> g;\n        \\<And>e. trim1 g e \\<le> g e; x \\<in> \\<E> (TER g)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> TER (trim1 g)", "hence \"x \\<in> SINK (trim1 g)\""], ["proof (prove)\nusing this:\n  x \\<in> \\<E> (TER g)\n\ngoal (1 subgoal):\n 1. x \\<in> SINK (trim1 g)", "using d_OUT_mono[of \"trim1 g\" x g, OF le]"], ["proof (prove)\nusing this:\n  x \\<in> \\<E> (TER g)\n  d_OUT (trim1 g) x \\<le> d_OUT g x\n\ngoal (1 subgoal):\n 1. x \\<in> SINK (trim1 g)", "by(auto simp add: SINK.simps)"], ["proof (state)\nthis:\n  x \\<in> SINK (trim1 g)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>current \\<Gamma> g; wave \\<Gamma> g;\n        \\<And>e. trim1 g e \\<le> g e; x \\<in> \\<E> (TER g)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> TER (trim1 g)", "moreover"], ["proof (state)\nthis:\n  x \\<in> SINK (trim1 g)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>current \\<Gamma> g; wave \\<Gamma> g;\n        \\<And>e. trim1 g e \\<le> g e; x \\<in> \\<E> (TER g)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> TER (trim1 g)", "from x"], ["proof (chain)\npicking this:\n  x \\<in> \\<E> (TER g)", "have \"x \\<noteq> z\""], ["proof (prove)\nusing this:\n  x \\<in> \\<E> (TER g)\n\ngoal (1 subgoal):\n 1. x \\<noteq> z", "using RF"], ["proof (prove)\nusing this:\n  x \\<in> \\<E> (TER g)\n  z \\<in> RF\\<^sup>\\<circ> (TER g)\n\ngoal (1 subgoal):\n 1. x \\<noteq> z", "by(auto simp add: roofed_circ_def)"], ["proof (state)\nthis:\n  x \\<noteq> z\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>current \\<Gamma> g; wave \\<Gamma> g;\n        \\<And>e. trim1 g e \\<le> g e; x \\<in> \\<E> (TER g)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> TER (trim1 g)", "hence \"d_IN (trim1 g) x = d_IN g x\""], ["proof (prove)\nusing this:\n  x \\<noteq> z\n\ngoal (1 subgoal):\n 1. d_IN (trim1 g) x = d_IN g x", "unfolding d_IN_def"], ["proof (prove)\nusing this:\n  x \\<noteq> z\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ xa. trim1 g (xa, x)) = (\\<Sum>\\<^sup>+ xa. g (xa, x))", "by simp"], ["proof (state)\nthis:\n  d_IN (trim1 g) x = d_IN g x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>current \\<Gamma> g; wave \\<Gamma> g;\n        \\<And>e. trim1 g e \\<le> g e; x \\<in> \\<E> (TER g)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> TER (trim1 g)", "with \\<open>x \\<in> \\<E> (TER g)\\<close>"], ["proof (chain)\npicking this:\n  x \\<in> \\<E> (TER g)\n  d_IN (trim1 g) x = d_IN g x", "have \"x \\<in> SAT \\<Gamma> (trim1 g)\""], ["proof (prove)\nusing this:\n  x \\<in> \\<E> (TER g)\n  d_IN (trim1 g) x = d_IN g x\n\ngoal (1 subgoal):\n 1. x \\<in> SAT \\<Gamma> (trim1 g)", "by(auto simp add: SAT.simps)"], ["proof (state)\nthis:\n  x \\<in> SAT \\<Gamma> (trim1 g)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>current \\<Gamma> g; wave \\<Gamma> g;\n        \\<And>e. trim1 g e \\<le> g e; x \\<in> \\<E> (TER g)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> TER (trim1 g)", "ultimately"], ["proof (chain)\npicking this:\n  x \\<in> SINK (trim1 g)\n  x \\<in> SAT \\<Gamma> (trim1 g)", "show \"x \\<in> TER (trim1 g)\""], ["proof (prove)\nusing this:\n  x \\<in> SINK (trim1 g)\n  x \\<in> SAT \\<Gamma> (trim1 g)\n\ngoal (1 subgoal):\n 1. x \\<in> TER (trim1 g)", "by auto"], ["proof (state)\nthis:\n  x \\<in> TER (trim1 g)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<E> (TER (trim1 g)) = \\<E> (TER f)\n\ngoal (1 subgoal):\n 1. \\<not> local.trimming g \\<Longrightarrow>\n    trim1 g \\<le> g \\<and> trim1 g \\<in> F", "moreover"], ["proof (state)\nthis:\n  \\<E> (TER (trim1 g)) = \\<E> (TER f)\n\ngoal (1 subgoal):\n 1. \\<not> local.trimming g \\<Longrightarrow>\n    trim1 g \\<le> g \\<and> trim1 g \\<in> F", "have \"wave \\<Gamma> (trim1 g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wave \\<Gamma> (trim1 g)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. separating \\<Gamma> (TER (trim1 g))\n 2. \\<And>x.\n       x \\<notin> RF (TER (trim1 g)) \\<Longrightarrow> d_OUT (trim1 g) x = 0", "have \"separating \\<Gamma> (\\<E> (TER f))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. separating \\<Gamma> (\\<E> (TER f))", "by(rule separating_essential)(rule waveD_separating[OF w])"], ["proof (state)\nthis:\n  separating \\<Gamma> (\\<E> (TER f))\n\ngoal (2 subgoals):\n 1. separating \\<Gamma> (TER (trim1 g))\n 2. \\<And>x.\n       x \\<notin> RF (TER (trim1 g)) \\<Longrightarrow> d_OUT (trim1 g) x = 0", "then"], ["proof (chain)\npicking this:\n  separating \\<Gamma> (\\<E> (TER f))", "show \"separating \\<Gamma> (TER (trim1 g))\""], ["proof (prove)\nusing this:\n  separating \\<Gamma> (\\<E> (TER f))\n\ngoal (1 subgoal):\n 1. separating \\<Gamma> (TER (trim1 g))", "unfolding eq[symmetric]"], ["proof (prove)\nusing this:\n  separating \\<Gamma> (\\<E> (TER (trim1 g)))\n\ngoal (1 subgoal):\n 1. separating \\<Gamma> (TER (trim1 g))", "by(rule separating_weakening) auto"], ["proof (state)\nthis:\n  separating \\<Gamma> (TER (trim1 g))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<notin> RF (TER (trim1 g)) \\<Longrightarrow> d_OUT (trim1 g) x = 0", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<notin> RF (TER (trim1 g)) \\<Longrightarrow> d_OUT (trim1 g) x = 0", "assume \"x \\<notin> RF (TER (trim1 g))\""], ["proof (state)\nthis:\n  x \\<notin> RF (TER (trim1 g))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<notin> RF (TER (trim1 g)) \\<Longrightarrow> d_OUT (trim1 g) x = 0", "hence \"x \\<notin> RF (\\<E> (TER (trim1 g)))\""], ["proof (prove)\nusing this:\n  x \\<notin> RF (TER (trim1 g))\n\ngoal (1 subgoal):\n 1. x \\<notin> RF (\\<E> (TER (trim1 g)))", "unfolding RF_essential"], ["proof (prove)\nusing this:\n  x \\<notin> RF (TER (trim1 g))\n\ngoal (1 subgoal):\n 1. x \\<notin> RF (TER (trim1 g))", "."], ["proof (state)\nthis:\n  x \\<notin> RF (\\<E> (TER (trim1 g)))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<notin> RF (TER (trim1 g)) \\<Longrightarrow> d_OUT (trim1 g) x = 0", "hence \"x \\<notin> RF (TER f)\""], ["proof (prove)\nusing this:\n  x \\<notin> RF (\\<E> (TER (trim1 g)))\n\ngoal (1 subgoal):\n 1. x \\<notin> RF (TER f)", "unfolding eq RF_essential"], ["proof (prove)\nusing this:\n  x \\<notin> RF (TER f)\n\ngoal (1 subgoal):\n 1. x \\<notin> RF (TER f)", "."], ["proof (state)\nthis:\n  x \\<notin> RF (TER f)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<notin> RF (TER (trim1 g)) \\<Longrightarrow> d_OUT (trim1 g) x = 0", "hence \"d_OUT f x = 0\""], ["proof (prove)\nusing this:\n  x \\<notin> RF (TER f)\n\ngoal (1 subgoal):\n 1. d_OUT f x = 0", "by(rule waveD_OUT[OF w])"], ["proof (state)\nthis:\n  d_OUT f x = 0\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<notin> RF (TER (trim1 g)) \\<Longrightarrow> d_OUT (trim1 g) x = 0", "with d_OUT_mono[of _ x f, OF le_f[THEN le_funD]]"], ["proof (chain)\npicking this:\n  d_OUT (trim1 g) x \\<le> d_OUT f x\n  d_OUT f x = 0", "show \"d_OUT (trim1 g) x = 0\""], ["proof (prove)\nusing this:\n  d_OUT (trim1 g) x \\<le> d_OUT f x\n  d_OUT f x = 0\n\ngoal (1 subgoal):\n 1. d_OUT (trim1 g) x = 0", "by (metis le_zero_eq)"], ["proof (state)\nthis:\n  d_OUT (trim1 g) x = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  wave \\<Gamma> (trim1 g)\n\ngoal (1 subgoal):\n 1. \\<not> local.trimming g \\<Longrightarrow>\n    trim1 g \\<le> g \\<and> trim1 g \\<in> F", "ultimately"], ["proof (chain)\npicking this:\n  current \\<Gamma> (trim1 g)\n  trim1 g \\<le> f\n  \\<E> (TER (trim1 g)) = \\<E> (TER f)\n  wave \\<Gamma> (trim1 g)", "have \"trim1 g \\<in> F\""], ["proof (prove)\nusing this:\n  current \\<Gamma> (trim1 g)\n  trim1 g \\<le> f\n  \\<E> (TER (trim1 g)) = \\<E> (TER f)\n  wave \\<Gamma> (trim1 g)\n\ngoal (1 subgoal):\n 1. trim1 g \\<in> F", "by(simp add: F_def)"], ["proof (state)\nthis:\n  trim1 g \\<in> F\n\ngoal (1 subgoal):\n 1. \\<not> local.trimming g \\<Longrightarrow>\n    trim1 g \\<le> g \\<and> trim1 g \\<in> F", "}"], ["proof (state)\nthis:\n  trim1 g \\<in> F\n\ngoal (1 subgoal):\n 1. \\<not> local.trimming g \\<Longrightarrow>\n    trim1 g \\<le> g \\<and> trim1 g \\<in> F", "ultimately"], ["proof (chain)\npicking this:\n  trim1 g ?e \\<le> g ?e\n  trim1 g \\<in> F", "show ?thesis"], ["proof (prove)\nusing this:\n  trim1 g ?e \\<le> g ?e\n  trim1 g \\<in> F\n\ngoal (1 subgoal):\n 1. trim1 g \\<le> g \\<and> trim1 g \\<in> F", "using that"], ["proof (prove)\nusing this:\n  trim1 g ?e \\<le> g ?e\n  trim1 g \\<in> F\n  g \\<in> F\n\ngoal (1 subgoal):\n 1. trim1 g \\<le> g \\<and> trim1 g \\<in> F", "by(simp add: le_fun_def del: trim1)"], ["proof (state)\nthis:\n  trim1 g \\<le> g \\<and> trim1 g \\<in> F\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?g \\<in> F \\<Longrightarrow> trim1 ?g \\<le> ?g \\<and> trim1 ?g \\<in> F\n\ngoal (1 subgoal):\n 1. Ex local.trimming", "have \"bourbaki_witt_fixpoint Inf leq trim1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bourbaki_witt_fixpoint Inf leq trim1", "using chainD increasing"], ["proof (prove)\nusing this:\n  \\<lbrakk>?M \\<in> Chains leq; ?M \\<noteq> {}\\<rbrakk>\n  \\<Longrightarrow> \\<Sqinter> ?M \\<in> F\n  ?g \\<in> F \\<Longrightarrow> trim1 ?g \\<le> ?g \\<and> trim1 ?g \\<in> F\n\ngoal (1 subgoal):\n 1. bourbaki_witt_fixpoint Inf leq trim1", "unfolding leq_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>?M \\<in> Chains (restrict_rel F {(g, g'). g' \\<le> g});\n   ?M \\<noteq> {}\\<rbrakk>\n  \\<Longrightarrow> \\<Sqinter> ?M \\<in> F\n  ?g \\<in> F \\<Longrightarrow> trim1 ?g \\<le> ?g \\<and> trim1 ?g \\<in> F\n\ngoal (1 subgoal):\n 1. bourbaki_witt_fixpoint Inf (restrict_rel F {(g, g'). g' \\<le> g}) trim1", "by(intro bourbaki_witt_fixpoint_restrict_rel)(auto intro: Inf_greatest Inf_lower)"], ["proof (state)\nthis:\n  bourbaki_witt_fixpoint Inf leq trim1\n\ngoal (1 subgoal):\n 1. Ex local.trimming", "then"], ["proof (chain)\npicking this:\n  bourbaki_witt_fixpoint Inf leq trim1", "interpret bourbaki_witt_fixpoint Inf leq trim1"], ["proof (prove)\nusing this:\n  bourbaki_witt_fixpoint Inf leq trim1\n\ngoal (1 subgoal):\n 1. bourbaki_witt_fixpoint Inf leq trim1", "."], ["proof (state)\ngoal (1 subgoal):\n 1. Ex local.trimming", "have f_Field: \"f \\<in> Field leq\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<in> Field leq", "using f w"], ["proof (prove)\nusing this:\n  current \\<Gamma> f\n  wave \\<Gamma> f\n\ngoal (1 subgoal):\n 1. f \\<in> Field leq", "by(simp add: leq_def)"], ["proof (state)\nthis:\n  f \\<in> Field leq\n\ngoal (1 subgoal):\n 1. Ex local.trimming", "define g where \"g = fixp_above f\""], ["proof (state)\nthis:\n  g = fixp_above f\n\ngoal (1 subgoal):\n 1. Ex local.trimming", "have \"g \\<in> Field leq\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g \\<in> Field leq", "using f_Field"], ["proof (prove)\nusing this:\n  f \\<in> Field leq\n\ngoal (1 subgoal):\n 1. g \\<in> Field leq", "unfolding g_def"], ["proof (prove)\nusing this:\n  f \\<in> Field leq\n\ngoal (1 subgoal):\n 1. fixp_above f \\<in> Field leq", "by(rule fixp_above_Field)"], ["proof (state)\nthis:\n  g \\<in> Field leq\n\ngoal (1 subgoal):\n 1. Ex local.trimming", "hence le_f: \"g \\<le> f\"\n    and g: \"current \\<Gamma> g\"\n    and w': \"wave \\<Gamma> g\"\n    and TER: \"\\<E> (TER g) = \\<E> (TER f)\""], ["proof (prove)\nusing this:\n  g \\<in> Field leq\n\ngoal (1 subgoal):\n 1. (g \\<le> f &&& current \\<Gamma> g) &&&\n    wave \\<Gamma> g &&& \\<E> (TER g) = \\<E> (TER f)", "by(auto simp add: leq_def intro: le_funI)"], ["proof (state)\nthis:\n  g \\<le> f\n  current \\<Gamma> g\n  wave \\<Gamma> g\n  \\<E> (TER g) = \\<E> (TER f)\n\ngoal (1 subgoal):\n 1. Ex local.trimming", "have \"trimming g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.trimming g", "proof(rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> local.trimming g \\<Longrightarrow> False", "let ?P = \"\\<lambda>x. x \\<in> RF\\<^sup>\\<circ> (TER g) \\<and> x \\<notin> A \\<Gamma> \\<and> \\<not> KIR g x\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> local.trimming g \\<Longrightarrow> False", "define x where \"x = Eps ?P\""], ["proof (state)\nthis:\n  x =\n  (SOME x.\n      x \\<in> RF\\<^sup>\\<circ> (TER g) \\<and>\n      x \\<notin> A \\<Gamma> \\<and> d_OUT g x \\<noteq> d_IN g x)\n\ngoal (1 subgoal):\n 1. \\<not> local.trimming g \\<Longrightarrow> False", "assume False: \"\\<not> ?thesis\""], ["proof (state)\nthis:\n  \\<not> local.trimming g\n\ngoal (1 subgoal):\n 1. \\<not> local.trimming g \\<Longrightarrow> False", "hence \"\\<exists>x. ?P x\""], ["proof (prove)\nusing this:\n  \\<not> local.trimming g\n\ngoal (1 subgoal):\n 1. \\<exists>x.\n       x \\<in> RF\\<^sup>\\<circ> (TER g) \\<and>\n       x \\<notin> A \\<Gamma> \\<and> d_OUT g x \\<noteq> d_IN g x", "using le_f g w' TER"], ["proof (prove)\nusing this:\n  \\<not> local.trimming g\n  g \\<le> f\n  current \\<Gamma> g\n  wave \\<Gamma> g\n  \\<E> (TER g) = \\<E> (TER f)\n\ngoal (1 subgoal):\n 1. \\<exists>x.\n       x \\<in> RF\\<^sup>\\<circ> (TER g) \\<and>\n       x \\<notin> A \\<Gamma> \\<and> d_OUT g x \\<noteq> d_IN g x", "by(auto simp add: trimming.simps roofed_circ_essential[of \\<Gamma> \"TER g\", symmetric] roofed_circ_essential[of \\<Gamma> \"TER f\", symmetric])"], ["proof (state)\nthis:\n  \\<exists>x.\n     x \\<in> RF\\<^sup>\\<circ> (TER g) \\<and>\n     x \\<notin> A \\<Gamma> \\<and> d_OUT g x \\<noteq> d_IN g x\n\ngoal (1 subgoal):\n 1. \\<not> local.trimming g \\<Longrightarrow> False", "hence \"?P x\""], ["proof (prove)\nusing this:\n  \\<exists>x.\n     x \\<in> RF\\<^sup>\\<circ> (TER g) \\<and>\n     x \\<notin> A \\<Gamma> \\<and> d_OUT g x \\<noteq> d_IN g x\n\ngoal (1 subgoal):\n 1. x \\<in> RF\\<^sup>\\<circ> (TER g) \\<and>\n    x \\<notin> A \\<Gamma> \\<and> d_OUT g x \\<noteq> d_IN g x", "unfolding x_def"], ["proof (prove)\nusing this:\n  \\<exists>x.\n     x \\<in> RF\\<^sup>\\<circ> (TER g) \\<and>\n     x \\<notin> A \\<Gamma> \\<and> d_OUT g x \\<noteq> d_IN g x\n\ngoal (1 subgoal):\n 1. (SOME x.\n        x \\<in> RF\\<^sup>\\<circ> (TER g) \\<and>\n        x \\<notin> A \\<Gamma> \\<and> d_OUT g x \\<noteq> d_IN g x)\n    \\<in> RF\\<^sup>\\<circ> (TER g) \\<and>\n    (SOME x.\n        x \\<in> RF\\<^sup>\\<circ> (TER g) \\<and>\n        x \\<notin> A \\<Gamma> \\<and> d_OUT g x \\<noteq> d_IN g x)\n    \\<notin> A \\<Gamma> \\<and>\n    d_OUT g\n     (SOME x.\n         x \\<in> RF\\<^sup>\\<circ> (TER g) \\<and>\n         x \\<notin> A \\<Gamma> \\<and> d_OUT g x \\<noteq> d_IN g x) \\<noteq>\n    d_IN g\n     (SOME x.\n         x \\<in> RF\\<^sup>\\<circ> (TER g) \\<and>\n         x \\<notin> A \\<Gamma> \\<and> d_OUT g x \\<noteq> d_IN g x)", "by(rule someI_ex)"], ["proof (state)\nthis:\n  x \\<in> RF\\<^sup>\\<circ> (TER g) \\<and>\n  x \\<notin> A \\<Gamma> \\<and> d_OUT g x \\<noteq> d_IN g x\n\ngoal (1 subgoal):\n 1. \\<not> local.trimming g \\<Longrightarrow> False", "hence x: \"x \\<in> RF\\<^sup>\\<circ> (TER g)\" and A: \"x \\<notin> A \\<Gamma>\" and neq: \"d_OUT g x \\<noteq> d_IN g x\""], ["proof (prove)\nusing this:\n  x \\<in> RF\\<^sup>\\<circ> (TER g) \\<and>\n  x \\<notin> A \\<Gamma> \\<and> d_OUT g x \\<noteq> d_IN g x\n\ngoal (1 subgoal):\n 1. x \\<in> RF\\<^sup>\\<circ> (TER g) &&&\n    x \\<notin> A \\<Gamma> &&& d_OUT g x \\<noteq> d_IN g x", "by simp_all"], ["proof (state)\nthis:\n  x \\<in> RF\\<^sup>\\<circ> (TER g)\n  x \\<notin> A \\<Gamma>\n  d_OUT g x \\<noteq> d_IN g x\n\ngoal (1 subgoal):\n 1. \\<not> local.trimming g \\<Longrightarrow> False", "from neq"], ["proof (chain)\npicking this:\n  d_OUT g x \\<noteq> d_IN g x", "have \"\\<exists>y. edge \\<Gamma> y x \\<and> g (y, x) > 0\""], ["proof (prove)\nusing this:\n  d_OUT g x \\<noteq> d_IN g x\n\ngoal (1 subgoal):\n 1. \\<exists>y. edge \\<Gamma> y x \\<and> 0 < g (y, x)", "proof(rule contrapos_np)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<nexists>y. edge \\<Gamma> y x \\<and> 0 < g (y, x) \\<Longrightarrow>\n    KIR g x", "assume \"\\<not> ?thesis\""], ["proof (state)\nthis:\n  \\<nexists>y. edge \\<Gamma> y x \\<and> 0 < g (y, x)\n\ngoal (1 subgoal):\n 1. \\<nexists>y. edge \\<Gamma> y x \\<and> 0 < g (y, x) \\<Longrightarrow>\n    KIR g x", "hence \"d_IN g x = 0\""], ["proof (prove)\nusing this:\n  \\<nexists>y. edge \\<Gamma> y x \\<and> 0 < g (y, x)\n\ngoal (1 subgoal):\n 1. d_IN g x = 0", "using currentD_outside[OF g, of _ x]"], ["proof (prove)\nusing this:\n  \\<nexists>y. edge \\<Gamma> y x \\<and> 0 < g (y, x)\n  \\<not> edge \\<Gamma> ?x x \\<Longrightarrow> g (?x, x) = 0\n\ngoal (1 subgoal):\n 1. d_IN g x = 0", "by(force simp add: d_IN_def nn_integral_0_iff_AE AE_count_space not_less)"], ["proof (state)\nthis:\n  d_IN g x = 0\n\ngoal (1 subgoal):\n 1. \\<nexists>y. edge \\<Gamma> y x \\<and> 0 < g (y, x) \\<Longrightarrow>\n    KIR g x", "with currentD_OUT_IN[OF g A]"], ["proof (chain)\npicking this:\n  d_OUT g x \\<le> d_IN g x\n  d_IN g x = 0", "show \"KIR g x\""], ["proof (prove)\nusing this:\n  d_OUT g x \\<le> d_IN g x\n  d_IN g x = 0\n\ngoal (1 subgoal):\n 1. KIR g x", "by simp"], ["proof (state)\nthis:\n  KIR g x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>y. edge \\<Gamma> y x \\<and> 0 < g (y, x)\n\ngoal (1 subgoal):\n 1. \\<not> local.trimming g \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<exists>y. edge \\<Gamma> y x \\<and> 0 < g (y, x)", "obtain y where y: \"edge \\<Gamma> y x\" and gr0: \"g (y, x) > 0\""], ["proof (prove)\nusing this:\n  \\<exists>y. edge \\<Gamma> y x \\<and> 0 < g (y, x)\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>edge \\<Gamma> y x; 0 < g (y, x)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  edge \\<Gamma> y x\n  0 < g (y, x)\n\ngoal (1 subgoal):\n 1. \\<not> local.trimming g \\<Longrightarrow> False", "have [simp]: \"g (y, x) \\<noteq> \\<top>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g (y, x) \\<noteq> \\<top>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. g (y, x) \\<noteq> \\<top>", "have \"g (y, x) \\<le> d_OUT g y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g (y, x) \\<le> d_OUT g y", "by (rule d_OUT_ge_point)"], ["proof (state)\nthis:\n  g (y, x) \\<le> d_OUT g y\n\ngoal (1 subgoal):\n 1. g (y, x) \\<noteq> \\<top>", "also"], ["proof (state)\nthis:\n  g (y, x) \\<le> d_OUT g y\n\ngoal (1 subgoal):\n 1. g (y, x) \\<noteq> \\<top>", "have \"\\<dots> \\<le> weight \\<Gamma> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT g y \\<le> weight \\<Gamma> y", "by(rule currentD_weight_OUT[OF g])"], ["proof (state)\nthis:\n  d_OUT g y \\<le> weight \\<Gamma> y\n\ngoal (1 subgoal):\n 1. g (y, x) \\<noteq> \\<top>", "also"], ["proof (state)\nthis:\n  d_OUT g y \\<le> weight \\<Gamma> y\n\ngoal (1 subgoal):\n 1. g (y, x) \\<noteq> \\<top>", "have \"\\<dots> < \\<top>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. weight \\<Gamma> y < \\<top>", "by(simp add: weight_finite less_top[symmetric])"], ["proof (state)\nthis:\n  weight \\<Gamma> y < \\<top>\n\ngoal (1 subgoal):\n 1. g (y, x) \\<noteq> \\<top>", "finally"], ["proof (chain)\npicking this:\n  g (y, x) < \\<top>", "show ?thesis"], ["proof (prove)\nusing this:\n  g (y, x) < \\<top>\n\ngoal (1 subgoal):\n 1. g (y, x) \\<noteq> \\<top>", "by simp"], ["proof (state)\nthis:\n  g (y, x) \\<noteq> \\<top>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  g (y, x) \\<noteq> \\<top>\n\ngoal (1 subgoal):\n 1. \\<not> local.trimming g \\<Longrightarrow> False", "from neq"], ["proof (chain)\npicking this:\n  d_OUT g x \\<noteq> d_IN g x", "have factor: \"d_OUT g x / d_IN g x \\<noteq> 1\""], ["proof (prove)\nusing this:\n  d_OUT g x \\<noteq> d_IN g x\n\ngoal (1 subgoal):\n 1. d_OUT g x / d_IN g x \\<noteq> 1", "by (simp add: divide_eq_1_ennreal)"], ["proof (state)\nthis:\n  d_OUT g x / d_IN g x \\<noteq> 1\n\ngoal (1 subgoal):\n 1. \\<not> local.trimming g \\<Longrightarrow> False", "have \"trim1 g (y, x) = g (y, x) * (d_OUT g x / d_IN g x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trim1 g (y, x) = g (y, x) * (d_OUT g x / d_IN g x)", "by(clarsimp simp add: False trim1_def Let_def x_def[symmetric] mult.commute)"], ["proof (state)\nthis:\n  trim1 g (y, x) = g (y, x) * (d_OUT g x / d_IN g x)\n\ngoal (1 subgoal):\n 1. \\<not> local.trimming g \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  trim1 g (y, x) = g (y, x) * (d_OUT g x / d_IN g x)\n\ngoal (1 subgoal):\n 1. \\<not> local.trimming g \\<Longrightarrow> False", "have \"\\<dots> \\<noteq> g (y, x) * 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g (y, x) * (d_OUT g x / d_IN g x) \\<noteq> g (y, x) * 1", "unfolding ennreal_mult_cancel_left"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (g (y, x) = \\<top> \\<and>\n            d_OUT g x / d_IN g x \\<noteq> 0 \\<and> 1 \\<noteq> 0 \\<or>\n            g (y, x) = 0 \\<or> d_OUT g x / d_IN g x = 1)", "using gr0 factor"], ["proof (prove)\nusing this:\n  0 < g (y, x)\n  d_OUT g x / d_IN g x \\<noteq> 1\n\ngoal (1 subgoal):\n 1. \\<not> (g (y, x) = \\<top> \\<and>\n            d_OUT g x / d_IN g x \\<noteq> 0 \\<and> 1 \\<noteq> 0 \\<or>\n            g (y, x) = 0 \\<or> d_OUT g x / d_IN g x = 1)", "by auto"], ["proof (state)\nthis:\n  g (y, x) * (d_OUT g x / d_IN g x) \\<noteq> g (y, x) * 1\n\ngoal (1 subgoal):\n 1. \\<not> local.trimming g \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  trim1 g (y, x) = g (y, x) * (d_OUT g x / d_IN g x)\n  g (y, x) * (d_OUT g x / d_IN g x) \\<noteq> g (y, x) * 1", "have \"trim1 g (y, x) \\<noteq> g (y, x)\""], ["proof (prove)\nusing this:\n  trim1 g (y, x) = g (y, x) * (d_OUT g x / d_IN g x)\n  g (y, x) * (d_OUT g x / d_IN g x) \\<noteq> g (y, x) * 1\n\ngoal (1 subgoal):\n 1. trim1 g (y, x) \\<noteq> g (y, x)", "by auto"], ["proof (state)\nthis:\n  trim1 g (y, x) \\<noteq> g (y, x)\n\ngoal (1 subgoal):\n 1. \\<not> local.trimming g \\<Longrightarrow> False", "hence \"trim1 g \\<noteq> g\""], ["proof (prove)\nusing this:\n  trim1 g (y, x) \\<noteq> g (y, x)\n\ngoal (1 subgoal):\n 1. trim1 g \\<noteq> g", "by(auto simp add: fun_eq_iff)"], ["proof (state)\nthis:\n  trim1 g \\<noteq> g\n\ngoal (1 subgoal):\n 1. \\<not> local.trimming g \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  trim1 g \\<noteq> g\n\ngoal (1 subgoal):\n 1. \\<not> local.trimming g \\<Longrightarrow> False", "have \"trim1 g = g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trim1 g = g", "using f_Field"], ["proof (prove)\nusing this:\n  f \\<in> Field leq\n\ngoal (1 subgoal):\n 1. trim1 g = g", "unfolding g_def"], ["proof (prove)\nusing this:\n  f \\<in> Field leq\n\ngoal (1 subgoal):\n 1. trim1 (fixp_above f) = fixp_above f", "by(rule fixp_above_unfold[symmetric])"], ["proof (state)\nthis:\n  trim1 g = g\n\ngoal (1 subgoal):\n 1. \\<not> local.trimming g \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  trim1 g \\<noteq> g\n  trim1 g = g", "show False"], ["proof (prove)\nusing this:\n  trim1 g \\<noteq> g\n  trim1 g = g\n\ngoal (1 subgoal):\n 1. False", "by contradiction"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  local.trimming g\n\ngoal (1 subgoal):\n 1. Ex local.trimming", "then"], ["proof (chain)\npicking this:\n  local.trimming g", "show ?thesis"], ["proof (prove)\nusing this:\n  local.trimming g\n\ngoal (1 subgoal):\n 1. Ex local.trimming", "by blast"], ["proof (state)\nthis:\n  Ex local.trimming\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "lemma trimming_\\<E>:\n  fixes \\<Gamma> (structure)\n  assumes w: \"wave \\<Gamma> f\" and trimming: \"trimming \\<Gamma> f g\"\n  shows \"\\<E> (TER f) = \\<E> (TER g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<E> (TER f) = \\<E> (TER g)", "proof(rule set_eqI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. (x \\<in> \\<E> (TER f)) = (x \\<in> \\<E> (TER g))", "show \"x \\<in> \\<E> (TER f) \\<longleftrightarrow> x \\<in> \\<E> (TER g)\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<in> \\<E> (TER f)) = (x \\<in> \\<E> (TER g))", "proof(cases \"x \\<in> A \\<Gamma>\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<in> A \\<Gamma> \\<Longrightarrow>\n    (x \\<in> \\<E> (TER f)) = (x \\<in> \\<E> (TER g))\n 2. x \\<notin> A \\<Gamma> \\<Longrightarrow>\n    (x \\<in> \\<E> (TER f)) = (x \\<in> \\<E> (TER g))", "case False"], ["proof (state)\nthis:\n  x \\<notin> A \\<Gamma>\n\ngoal (2 subgoals):\n 1. x \\<in> A \\<Gamma> \\<Longrightarrow>\n    (x \\<in> \\<E> (TER f)) = (x \\<in> \\<E> (TER g))\n 2. x \\<notin> A \\<Gamma> \\<Longrightarrow>\n    (x \\<in> \\<E> (TER f)) = (x \\<in> \\<E> (TER g))", "thus ?thesis"], ["proof (prove)\nusing this:\n  x \\<notin> A \\<Gamma>\n\ngoal (1 subgoal):\n 1. (x \\<in> \\<E> (TER f)) = (x \\<in> \\<E> (TER g))", "using trimmingD_\\<E>[OF trimming]"], ["proof (prove)\nusing this:\n  x \\<notin> A \\<Gamma>\n  \\<E> (TER g) - A \\<Gamma> = \\<E> (TER f) - A \\<Gamma>\n\ngoal (1 subgoal):\n 1. (x \\<in> \\<E> (TER f)) = (x \\<in> \\<E> (TER g))", "by blast"], ["proof (state)\nthis:\n  (x \\<in> \\<E> (TER f)) = (x \\<in> \\<E> (TER g))\n\ngoal (1 subgoal):\n 1. x \\<in> A \\<Gamma> \\<Longrightarrow>\n    (x \\<in> \\<E> (TER f)) = (x \\<in> \\<E> (TER g))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<in> A \\<Gamma> \\<Longrightarrow>\n    (x \\<in> \\<E> (TER f)) = (x \\<in> \\<E> (TER g))", "case True"], ["proof (state)\nthis:\n  x \\<in> A \\<Gamma>\n\ngoal (1 subgoal):\n 1. x \\<in> A \\<Gamma> \\<Longrightarrow>\n    (x \\<in> \\<E> (TER f)) = (x \\<in> \\<E> (TER g))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<in> \\<E> (TER f)) = (x \\<in> \\<E> (TER g))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<in> \\<E> (TER f) \\<Longrightarrow> x \\<in> \\<E> (TER g)\n 2. x \\<in> \\<E> (TER g) \\<Longrightarrow> x \\<in> \\<E> (TER f)", "assume x: \"x \\<in> \\<E> (TER f)\""], ["proof (state)\nthis:\n  x \\<in> \\<E> (TER f)\n\ngoal (2 subgoals):\n 1. x \\<in> \\<E> (TER f) \\<Longrightarrow> x \\<in> \\<E> (TER g)\n 2. x \\<in> \\<E> (TER g) \\<Longrightarrow> x \\<in> \\<E> (TER f)", "hence \"x \\<in> TER g\""], ["proof (prove)\nusing this:\n  x \\<in> \\<E> (TER f)\n\ngoal (1 subgoal):\n 1. x \\<in> TER g", "using d_OUT_mono[of g x f, OF trimmingD_le[OF trimming]] True"], ["proof (prove)\nusing this:\n  x \\<in> \\<E> (TER f)\n  d_OUT g x \\<le> d_OUT f x\n  x \\<in> A \\<Gamma>\n\ngoal (1 subgoal):\n 1. x \\<in> TER g", "by(simp add: SINK.simps SAT.A)"], ["proof (state)\nthis:\n  x \\<in> TER g\n\ngoal (2 subgoals):\n 1. x \\<in> \\<E> (TER f) \\<Longrightarrow> x \\<in> \\<E> (TER g)\n 2. x \\<in> \\<E> (TER g) \\<Longrightarrow> x \\<in> \\<E> (TER f)", "moreover"], ["proof (state)\nthis:\n  x \\<in> TER g\n\ngoal (2 subgoals):\n 1. x \\<in> \\<E> (TER f) \\<Longrightarrow> x \\<in> \\<E> (TER g)\n 2. x \\<in> \\<E> (TER g) \\<Longrightarrow> x \\<in> \\<E> (TER f)", "from x"], ["proof (chain)\npicking this:\n  x \\<in> \\<E> (TER f)", "have \"essential \\<Gamma> (B \\<Gamma>) (TER f) x\""], ["proof (prove)\nusing this:\n  x \\<in> \\<E> (TER f)\n\ngoal (1 subgoal):\n 1. essential \\<Gamma> (B \\<Gamma>) (TER f) x", "by simp"], ["proof (state)\nthis:\n  essential \\<Gamma> (B \\<Gamma>) (TER f) x\n\ngoal (2 subgoals):\n 1. x \\<in> \\<E> (TER f) \\<Longrightarrow> x \\<in> \\<E> (TER g)\n 2. x \\<in> \\<E> (TER g) \\<Longrightarrow> x \\<in> \\<E> (TER f)", "then"], ["proof (chain)\npicking this:\n  essential \\<Gamma> (B \\<Gamma>) (TER f) x", "obtain p y where p: \"path \\<Gamma> x p y\" and y: \"y \\<in> B \\<Gamma>\"\n        and bypass: \"\\<And>z. z \\<in> set p \\<Longrightarrow> z \\<notin> RF (TER f)\""], ["proof (prove)\nusing this:\n  essential \\<Gamma> (B \\<Gamma>) (TER f) x\n\ngoal (1 subgoal):\n 1. (\\<And>p y.\n        \\<lbrakk>path \\<Gamma> x p y; y \\<in> B \\<Gamma>;\n         \\<And>z.\n            z \\<in> set p \\<Longrightarrow> z \\<notin> RF (TER f)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(rule essentialE_RF) blast"], ["proof (state)\nthis:\n  path \\<Gamma> x p y\n  y \\<in> B \\<Gamma>\n  ?z \\<in> set p \\<Longrightarrow> ?z \\<notin> RF (TER f)\n\ngoal (2 subgoals):\n 1. x \\<in> \\<E> (TER f) \\<Longrightarrow> x \\<in> \\<E> (TER g)\n 2. x \\<in> \\<E> (TER g) \\<Longrightarrow> x \\<in> \\<E> (TER f)", "from p y"], ["proof (chain)\npicking this:\n  path \\<Gamma> x p y\n  y \\<in> B \\<Gamma>", "have \"essential \\<Gamma> (B \\<Gamma>) (\\<E> (TER g)) x\""], ["proof (prove)\nusing this:\n  path \\<Gamma> x p y\n  y \\<in> B \\<Gamma>\n\ngoal (1 subgoal):\n 1. essential \\<Gamma> (B \\<Gamma>) (\\<E> (TER g)) x", "proof(rule essentialI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>z.\n       \\<lbrakk>x \\<noteq> y; z \\<in> set p\\<rbrakk>\n       \\<Longrightarrow> z = x \\<or> z \\<notin> \\<E> (TER g)", "fix z"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>z.\n       \\<lbrakk>x \\<noteq> y; z \\<in> set p\\<rbrakk>\n       \\<Longrightarrow> z = x \\<or> z \\<notin> \\<E> (TER g)", "assume \"z \\<in> set p\""], ["proof (state)\nthis:\n  z \\<in> set p\n\ngoal (1 subgoal):\n 1. \\<And>z.\n       \\<lbrakk>x \\<noteq> y; z \\<in> set p\\<rbrakk>\n       \\<Longrightarrow> z = x \\<or> z \\<notin> \\<E> (TER g)", "hence z: \"z \\<notin> RF (TER f)\""], ["proof (prove)\nusing this:\n  z \\<in> set p\n\ngoal (1 subgoal):\n 1. z \\<notin> RF (TER f)", "by(rule bypass)"], ["proof (state)\nthis:\n  z \\<notin> RF (TER f)\n\ngoal (1 subgoal):\n 1. \\<And>z.\n       \\<lbrakk>x \\<noteq> y; z \\<in> set p\\<rbrakk>\n       \\<Longrightarrow> z = x \\<or> z \\<notin> \\<E> (TER g)", "with waveD_separating[OF w, THEN separating_RF_A]"], ["proof (chain)\npicking this:\n  A \\<Gamma> \\<subseteq> RF (TER f)\n  z \\<notin> RF (TER f)", "have \"z \\<notin> A \\<Gamma>\""], ["proof (prove)\nusing this:\n  A \\<Gamma> \\<subseteq> RF (TER f)\n  z \\<notin> RF (TER f)\n\ngoal (1 subgoal):\n 1. z \\<notin> A \\<Gamma>", "by blast"], ["proof (state)\nthis:\n  z \\<notin> A \\<Gamma>\n\ngoal (1 subgoal):\n 1. \\<And>z.\n       \\<lbrakk>x \\<noteq> y; z \\<in> set p\\<rbrakk>\n       \\<Longrightarrow> z = x \\<or> z \\<notin> \\<E> (TER g)", "with z"], ["proof (chain)\npicking this:\n  z \\<notin> RF (TER f)\n  z \\<notin> A \\<Gamma>", "have \"z \\<notin> \\<E> (TER g)\""], ["proof (prove)\nusing this:\n  z \\<notin> RF (TER f)\n  z \\<notin> A \\<Gamma>\n\ngoal (1 subgoal):\n 1. z \\<notin> \\<E> (TER g)", "using trimmingD_\\<E>[OF trimming]"], ["proof (prove)\nusing this:\n  z \\<notin> RF (TER f)\n  z \\<notin> A \\<Gamma>\n  \\<E> (TER g) - A \\<Gamma> = \\<E> (TER f) - A \\<Gamma>\n\ngoal (1 subgoal):\n 1. z \\<notin> \\<E> (TER g)", "by(auto intro: roofed_greaterI)"], ["proof (state)\nthis:\n  z \\<notin> \\<E> (TER g)\n\ngoal (1 subgoal):\n 1. \\<And>z.\n       \\<lbrakk>x \\<noteq> y; z \\<in> set p\\<rbrakk>\n       \\<Longrightarrow> z = x \\<or> z \\<notin> \\<E> (TER g)", "thus \"z = x \\<or> z \\<notin> \\<E> (TER g)\""], ["proof (prove)\nusing this:\n  z \\<notin> \\<E> (TER g)\n\ngoal (1 subgoal):\n 1. z = x \\<or> z \\<notin> \\<E> (TER g)", ".."], ["proof (state)\nthis:\n  z = x \\<or> z \\<notin> \\<E> (TER g)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  essential \\<Gamma> (B \\<Gamma>) (\\<E> (TER g)) x\n\ngoal (2 subgoals):\n 1. x \\<in> \\<E> (TER f) \\<Longrightarrow> x \\<in> \\<E> (TER g)\n 2. x \\<in> \\<E> (TER g) \\<Longrightarrow> x \\<in> \\<E> (TER f)", "ultimately"], ["proof (chain)\npicking this:\n  x \\<in> TER g\n  essential \\<Gamma> (B \\<Gamma>) (\\<E> (TER g)) x", "show \"x \\<in> \\<E> (TER g)\""], ["proof (prove)\nusing this:\n  x \\<in> TER g\n  essential \\<Gamma> (B \\<Gamma>) (\\<E> (TER g)) x\n\ngoal (1 subgoal):\n 1. x \\<in> \\<E> (TER g)", "unfolding essential_\\<E>"], ["proof (prove)\nusing this:\n  x \\<in> TER g\n  essential \\<Gamma> (B \\<Gamma>) (TER g) x\n\ngoal (1 subgoal):\n 1. x \\<in> \\<E> (TER g)", "by simp"], ["proof (state)\nthis:\n  x \\<in> \\<E> (TER g)\n\ngoal (1 subgoal):\n 1. x \\<in> \\<E> (TER g) \\<Longrightarrow> x \\<in> \\<E> (TER f)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<in> \\<E> (TER g) \\<Longrightarrow> x \\<in> \\<E> (TER f)", "assume \"x \\<in> \\<E> (TER g)\""], ["proof (state)\nthis:\n  x \\<in> \\<E> (TER g)\n\ngoal (1 subgoal):\n 1. x \\<in> \\<E> (TER g) \\<Longrightarrow> x \\<in> \\<E> (TER f)", "then"], ["proof (chain)\npicking this:\n  x \\<in> \\<E> (TER g)", "obtain p y where p: \"path \\<Gamma> x p y\" and y: \"y \\<in> B \\<Gamma>\"\n        and bypass: \"\\<And>z. z \\<in> set p \\<Longrightarrow> z \\<notin> RF (TER g)\""], ["proof (prove)\nusing this:\n  x \\<in> \\<E> (TER g)\n\ngoal (1 subgoal):\n 1. (\\<And>p y.\n        \\<lbrakk>path \\<Gamma> x p y; y \\<in> B \\<Gamma>;\n         \\<And>z.\n            z \\<in> set p \\<Longrightarrow> z \\<notin> RF (TER g)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(rule \\<E>_E_RF) blast"], ["proof (state)\nthis:\n  path \\<Gamma> x p y\n  y \\<in> B \\<Gamma>\n  ?z \\<in> set p \\<Longrightarrow> ?z \\<notin> RF (TER g)\n\ngoal (1 subgoal):\n 1. x \\<in> \\<E> (TER g) \\<Longrightarrow> x \\<in> \\<E> (TER f)", "have z: \"z \\<notin> \\<E> (TER f)\" if \"z \\<in> set p\" for z"], ["proof (prove)\ngoal (1 subgoal):\n 1. z \\<notin> \\<E> (TER f)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. z \\<notin> \\<E> (TER f)", "from that"], ["proof (chain)\npicking this:\n  z \\<in> set p", "have z: \"z \\<notin> RF (TER g)\""], ["proof (prove)\nusing this:\n  z \\<in> set p\n\ngoal (1 subgoal):\n 1. z \\<notin> RF (TER g)", "by(rule bypass)"], ["proof (state)\nthis:\n  z \\<notin> RF (TER g)\n\ngoal (1 subgoal):\n 1. z \\<notin> \\<E> (TER f)", "with waveD_separating[OF trimmingD_wave[OF trimming], THEN separating_RF_A]"], ["proof (chain)\npicking this:\n  A \\<Gamma> \\<subseteq> RF (TER g)\n  z \\<notin> RF (TER g)", "have \"z \\<notin> A \\<Gamma>\""], ["proof (prove)\nusing this:\n  A \\<Gamma> \\<subseteq> RF (TER g)\n  z \\<notin> RF (TER g)\n\ngoal (1 subgoal):\n 1. z \\<notin> A \\<Gamma>", "by blast"], ["proof (state)\nthis:\n  z \\<notin> A \\<Gamma>\n\ngoal (1 subgoal):\n 1. z \\<notin> \\<E> (TER f)", "with z"], ["proof (chain)\npicking this:\n  z \\<notin> RF (TER g)\n  z \\<notin> A \\<Gamma>", "show \"z \\<notin> \\<E> (TER f)\""], ["proof (prove)\nusing this:\n  z \\<notin> RF (TER g)\n  z \\<notin> A \\<Gamma>\n\ngoal (1 subgoal):\n 1. z \\<notin> \\<E> (TER f)", "using trimmingD_\\<E>[OF trimming]"], ["proof (prove)\nusing this:\n  z \\<notin> RF (TER g)\n  z \\<notin> A \\<Gamma>\n  \\<E> (TER g) - A \\<Gamma> = \\<E> (TER f) - A \\<Gamma>\n\ngoal (1 subgoal):\n 1. z \\<notin> \\<E> (TER f)", "by(auto intro: roofed_greaterI)"], ["proof (state)\nthis:\n  z \\<notin> \\<E> (TER f)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?z \\<in> set p \\<Longrightarrow> ?z \\<notin> \\<E> (TER f)\n\ngoal (1 subgoal):\n 1. x \\<in> \\<E> (TER g) \\<Longrightarrow> x \\<in> \\<E> (TER f)", "then"], ["proof (chain)\npicking this:\n  ?z \\<in> set p \\<Longrightarrow> ?z \\<notin> \\<E> (TER f)", "have \"essential \\<Gamma> (B \\<Gamma>) (\\<E> (TER f)) x\""], ["proof (prove)\nusing this:\n  ?z \\<in> set p \\<Longrightarrow> ?z \\<notin> \\<E> (TER f)\n\ngoal (1 subgoal):\n 1. essential \\<Gamma> (B \\<Gamma>) (\\<E> (TER f)) x", "by(intro essentialI[OF p y]) auto"], ["proof (state)\nthis:\n  essential \\<Gamma> (B \\<Gamma>) (\\<E> (TER f)) x\n\ngoal (1 subgoal):\n 1. x \\<in> \\<E> (TER g) \\<Longrightarrow> x \\<in> \\<E> (TER f)", "moreover"], ["proof (state)\nthis:\n  essential \\<Gamma> (B \\<Gamma>) (\\<E> (TER f)) x\n\ngoal (1 subgoal):\n 1. x \\<in> \\<E> (TER g) \\<Longrightarrow> x \\<in> \\<E> (TER f)", "have \"x \\<in> TER f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> TER f", "using waveD_separating[THEN separating_essential, THEN separatingD, OF w p True y] z"], ["proof (prove)\nusing this:\n  (\\<exists>z\\<in>set p. z \\<in> \\<E> (TER f)) \\<or> x \\<in> \\<E> (TER f)\n  ?z \\<in> set p \\<Longrightarrow> ?z \\<notin> \\<E> (TER f)\n\ngoal (1 subgoal):\n 1. x \\<in> TER f", "by auto"], ["proof (state)\nthis:\n  x \\<in> TER f\n\ngoal (1 subgoal):\n 1. x \\<in> \\<E> (TER g) \\<Longrightarrow> x \\<in> \\<E> (TER f)", "ultimately"], ["proof (chain)\npicking this:\n  essential \\<Gamma> (B \\<Gamma>) (\\<E> (TER f)) x\n  x \\<in> TER f", "show \"x \\<in> \\<E> (TER f)\""], ["proof (prove)\nusing this:\n  essential \\<Gamma> (B \\<Gamma>) (\\<E> (TER f)) x\n  x \\<in> TER f\n\ngoal (1 subgoal):\n 1. x \\<in> \\<E> (TER f)", "unfolding essential_\\<E>"], ["proof (prove)\nusing this:\n  essential \\<Gamma> (B \\<Gamma>) (TER f) x\n  x \\<in> TER f\n\ngoal (1 subgoal):\n 1. x \\<in> \\<E> (TER f)", "by simp"], ["proof (state)\nthis:\n  x \\<in> \\<E> (TER f)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (x \\<in> \\<E> (TER f)) = (x \\<in> \\<E> (TER g))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (?x \\<in> \\<E> (TER f)) = (?x \\<in> \\<E> (TER g))\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Composition of waves via quotients\\<close>"], ["", "definition quotient_web :: \"('v, 'more) web_scheme \\<Rightarrow> 'v current \\<Rightarrow> ('v, 'more) web_scheme\"\nwhere \\<comment> \\<open>Modifications to original Definition 4.9: No incoming edges to nodes in @{const A},\n  @{term \"B \\<Gamma> - A \\<Gamma>\"} is not part of @{const A} such that @{const A} contains only vertices\n  is disjoint from @{const B}. The weight of vertices in @{const B} saturated by @{term f} is\n  therefore set to @{term \"0 :: ennreal\"}.\\<close>\n  \"quotient_web \\<Gamma> f =\n   \\<lparr>edge = \\<lambda>x y. edge \\<Gamma> x y \\<and> x \\<notin> roofed_circ \\<Gamma> (TER\\<^bsub>\\<Gamma>\\<^esub> f) \\<and> y \\<notin> roofed \\<Gamma> (TER\\<^bsub>\\<Gamma>\\<^esub> f),\n    weight = \\<lambda>x. if x \\<in> RF\\<^sup>\\<circ>\\<^bsub>\\<Gamma>\\<^esub> (TER\\<^bsub>\\<Gamma>\\<^esub> f) \\<or> x \\<in> TER\\<^bsub>\\<Gamma>\\<^esub> f \\<inter> B \\<Gamma> then 0 else weight \\<Gamma> x,\n    A = \\<E>\\<^bsub>\\<Gamma>\\<^esub> (TER\\<^bsub>\\<Gamma>\\<^esub> f) - (B \\<Gamma> - A \\<Gamma>),\n    B = B \\<Gamma>,\n    \\<dots> = web.more \\<Gamma>\\<rparr>\""], ["", "lemma quotient_web_sel [simp]:\n  fixes \\<Gamma> (structure) shows\n  \"edge (quotient_web \\<Gamma> f) x y \\<longleftrightarrow> edge \\<Gamma> x y \\<and> x \\<notin> RF\\<^sup>\\<circ> (TER f) \\<and> y \\<notin> RF (TER f)\"\n  \"weight (quotient_web \\<Gamma> f) x = (if x \\<in> RF\\<^sup>\\<circ> (TER f) \\<or> x \\<in> TER\\<^bsub>\\<Gamma>\\<^esub> f \\<inter> B \\<Gamma> then 0 else weight \\<Gamma> x)\"\n  \"A (quotient_web \\<Gamma> f) = \\<E> (TER f)- (B \\<Gamma> - A \\<Gamma>)\"\n  \"B (quotient_web \\<Gamma> f) = B \\<Gamma>\"\n  \"web.more (quotient_web \\<Gamma> f) = web.more \\<Gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (edge (quotient_web \\<Gamma> f) x y =\n     (edge \\<Gamma> x y \\<and>\n      x \\<notin> RF\\<^sup>\\<circ> (TER f) \\<and> y \\<notin> RF (TER f)) &&&\n     weight (quotient_web \\<Gamma> f) x =\n     (if x \\<in> RF\\<^sup>\\<circ> (TER f) \\<or>\n         x \\<in> TER f \\<inter> B \\<Gamma>\n      then 0 else weight \\<Gamma> x)) &&&\n    A (quotient_web \\<Gamma> f) =\n    \\<E> (TER f) - (B \\<Gamma> - A \\<Gamma>) &&&\n    B (quotient_web \\<Gamma> f) = B \\<Gamma> &&&\n    web.more (quotient_web \\<Gamma> f) = web.more \\<Gamma>", "by(simp_all add: quotient_web_def)"], ["", "lemma vertex_quotient_webD: fixes \\<Gamma> (structure) shows\n  \"vertex (quotient_web \\<Gamma> f) x \\<Longrightarrow> vertex \\<Gamma> x \\<and> x \\<notin> RF\\<^sup>\\<circ> (TER f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vertex (quotient_web \\<Gamma> f) x \\<Longrightarrow>\n    vertex \\<Gamma> x \\<and> x \\<notin> RF\\<^sup>\\<circ> (TER f)", "by(auto simp add: vertex_def roofed_circ_def)"], ["", "lemma path_quotient_web:\n  fixes \\<Gamma> (structure)\n  assumes \"path \\<Gamma> x p y\"\n  and \"x \\<notin> RF\\<^sup>\\<circ> (TER f)\"\n  and \"\\<And>z. z \\<in> set p \\<Longrightarrow> z \\<notin> RF (TER f)\"\n  shows \"path (quotient_web \\<Gamma> f) x p y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path (quotient_web \\<Gamma> f) x p y", "using assms"], ["proof (prove)\nusing this:\n  path \\<Gamma> x p y\n  x \\<notin> RF\\<^sup>\\<circ> (TER f)\n  ?z \\<in> set p \\<Longrightarrow> ?z \\<notin> RF (TER f)\n\ngoal (1 subgoal):\n 1. path (quotient_web \\<Gamma> f) x p y", "by(induction)(auto intro: rtrancl_path.intros simp add: roofed_circ_def)"], ["", "definition restrict_current :: \"('v, 'more) web_scheme \\<Rightarrow> 'v current \\<Rightarrow> 'v current \\<Rightarrow> 'v current\"\nwhere \"restrict_current \\<Gamma> f g = (\\<lambda>(x, y). g (x, y) * indicator (- RF\\<^sup>\\<circ>\\<^bsub>\\<Gamma>\\<^esub> (TER\\<^bsub>\\<Gamma>\\<^esub> f)) x * indicator (- RF\\<^bsub>\\<Gamma>\\<^esub> (TER\\<^bsub>\\<Gamma>\\<^esub> f)) y)\""], ["", "abbreviation restrict_curr :: \"'v current \\<Rightarrow> ('v, 'more) web_scheme \\<Rightarrow> 'v current \\<Rightarrow> 'v current\" (\"_ \\<upharpoonleft> _ '/ _\" [100, 0, 100] 100)\nwhere \"restrict_curr g \\<Gamma> f \\<equiv> restrict_current \\<Gamma> f g\""], ["", "lemma restrict_current_simps [simp]: fixes \\<Gamma> (structure) shows\n  \"(g \\<upharpoonleft> \\<Gamma> / f) (x, y) = (g (x, y) * indicator (- RF\\<^sup>\\<circ> (TER f)) x * indicator (- RF (TER f)) y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (g \\<upharpoonleft> \\<Gamma> / f) (x, y) =\n    g (x, y) * indicator (- RF\\<^sup>\\<circ> (TER f)) x *\n    indicator (- RF (TER f)) y", "by(simp add: restrict_current_def)"], ["", "lemma d_OUT_restrict_current_outside: fixes \\<Gamma> (structure) shows\n  \"x \\<in> RF\\<^sup>\\<circ> (TER f) \\<Longrightarrow> d_OUT (g \\<upharpoonleft> \\<Gamma> / f) x = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> RF\\<^sup>\\<circ> (TER f) \\<Longrightarrow>\n    d_OUT (g \\<upharpoonleft> \\<Gamma> / f) x = 0", "by(simp add: d_OUT_def)"], ["", "lemma d_IN_restrict_current_outside: fixes \\<Gamma> (structure) shows\n  \"x \\<in> RF (TER f) \\<Longrightarrow> d_IN (g \\<upharpoonleft> \\<Gamma> / f) x = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> RF (TER f) \\<Longrightarrow>\n    d_IN (g \\<upharpoonleft> \\<Gamma> / f) x = 0", "by(simp add: d_IN_def)"], ["", "lemma restrict_current_le: \"(g \\<upharpoonleft> \\<Gamma> / f) e \\<le> g e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (g \\<upharpoonleft> \\<Gamma> / f) e \\<le> g e", "by(cases e)(clarsimp split: split_indicator)"], ["", "lemma d_OUT_restrict_current_le: \"d_OUT (g \\<upharpoonleft> \\<Gamma> / f) x \\<le> d_OUT g x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT (g \\<upharpoonleft> \\<Gamma> / f) x \\<le> d_OUT g x", "unfolding d_OUT_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y. (g \\<upharpoonleft> \\<Gamma> / f) (x, y))\n    \\<le> (\\<Sum>\\<^sup>+ y. g (x, y))", "by(rule nn_integral_mono, simp split: split_indicator)"], ["", "lemma d_IN_restrict_current_le: \"d_IN (g \\<upharpoonleft> \\<Gamma> / f) x \\<le> d_IN g x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN (g \\<upharpoonleft> \\<Gamma> / f) x \\<le> d_IN g x", "unfolding d_IN_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ xa. (g \\<upharpoonleft> \\<Gamma> / f) (xa, x))\n    \\<le> (\\<Sum>\\<^sup>+ xa. g (xa, x))", "by(rule nn_integral_mono, simp split: split_indicator)"], ["", "lemma restrict_current_IN_not_RF:\n  fixes \\<Gamma> (structure)\n  assumes g: \"current \\<Gamma> g\"\n  and x: \"x \\<notin> RF (TER f)\"\n  shows \"d_IN (g \\<upharpoonleft> \\<Gamma> / f) x = d_IN g x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN (g \\<upharpoonleft> \\<Gamma> / f) x = d_IN g x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. d_IN (g \\<upharpoonleft> \\<Gamma> / f) x = d_IN g x", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. d_IN (g \\<upharpoonleft> \\<Gamma> / f) x = d_IN g x", "fix y"], ["proof (state)\ngoal (1 subgoal):\n 1. d_IN (g \\<upharpoonleft> \\<Gamma> / f) x = d_IN g x", "assume y: \"y \\<in> RF\\<^sup>\\<circ> (TER f)\""], ["proof (state)\nthis:\n  y \\<in> RF\\<^sup>\\<circ> (TER f)\n\ngoal (1 subgoal):\n 1. d_IN (g \\<upharpoonleft> \\<Gamma> / f) x = d_IN g x", "have \"g (y, x) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g (y, x) = 0", "proof(cases \"edge \\<Gamma> y x\")"], ["proof (state)\ngoal (2 subgoals):\n 1. edge \\<Gamma> y x \\<Longrightarrow> g (y, x) = 0\n 2. \\<not> edge \\<Gamma> y x \\<Longrightarrow> g (y, x) = 0", "case True"], ["proof (state)\nthis:\n  edge \\<Gamma> y x\n\ngoal (2 subgoals):\n 1. edge \\<Gamma> y x \\<Longrightarrow> g (y, x) = 0\n 2. \\<not> edge \\<Gamma> y x \\<Longrightarrow> g (y, x) = 0", "from y"], ["proof (chain)\npicking this:\n  y \\<in> RF\\<^sup>\\<circ> (TER f)", "have y': \"y \\<in> RF (TER f)\" and essential: \"y \\<notin> \\<E> (TER f)\""], ["proof (prove)\nusing this:\n  y \\<in> RF\\<^sup>\\<circ> (TER f)\n\ngoal (1 subgoal):\n 1. y \\<in> RF (TER f) &&& y \\<notin> \\<E> (TER f)", "by(simp_all add: roofed_circ_def)"], ["proof (state)\nthis:\n  y \\<in> RF (TER f)\n  y \\<notin> \\<E> (TER f)\n\ngoal (2 subgoals):\n 1. edge \\<Gamma> y x \\<Longrightarrow> g (y, x) = 0\n 2. \\<not> edge \\<Gamma> y x \\<Longrightarrow> g (y, x) = 0", "moreover"], ["proof (state)\nthis:\n  y \\<in> RF (TER f)\n  y \\<notin> \\<E> (TER f)\n\ngoal (2 subgoals):\n 1. edge \\<Gamma> y x \\<Longrightarrow> g (y, x) = 0\n 2. \\<not> edge \\<Gamma> y x \\<Longrightarrow> g (y, x) = 0", "from x"], ["proof (chain)\npicking this:\n  x \\<notin> RF (TER f)", "obtain p z where z: \"z \\<in> B \\<Gamma>\" and p: \"path \\<Gamma> x p z\"\n        and bypass: \"\\<And>z. z \\<in> set p \\<Longrightarrow> z \\<notin> TER f\" \"x \\<notin> TER f\""], ["proof (prove)\nusing this:\n  x \\<notin> RF (TER f)\n\ngoal (1 subgoal):\n 1. (\\<And>z p.\n        \\<lbrakk>z \\<in> B \\<Gamma>; path \\<Gamma> x p z;\n         \\<And>z. z \\<in> set p \\<Longrightarrow> z \\<notin> TER f;\n         x \\<notin> TER f\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(clarsimp simp add: roofed_def)"], ["proof (state)\nthis:\n  z \\<in> B \\<Gamma>\n  path \\<Gamma> x p z\n  ?z \\<in> set p \\<Longrightarrow> ?z \\<notin> TER f\n  x \\<notin> TER f\n\ngoal (2 subgoals):\n 1. edge \\<Gamma> y x \\<Longrightarrow> g (y, x) = 0\n 2. \\<not> edge \\<Gamma> y x \\<Longrightarrow> g (y, x) = 0", "from roofedD[OF y' rtrancl_path.step, OF True p z] bypass"], ["proof (chain)\npicking this:\n  (\\<exists>z\\<in>set (x # p). z \\<in> TER f) \\<or> y \\<in> TER f\n  ?z \\<in> set p \\<Longrightarrow> ?z \\<notin> TER f\n  x \\<notin> TER f", "have \"x \\<in> TER f \\<or> y \\<in> TER f\""], ["proof (prove)\nusing this:\n  (\\<exists>z\\<in>set (x # p). z \\<in> TER f) \\<or> y \\<in> TER f\n  ?z \\<in> set p \\<Longrightarrow> ?z \\<notin> TER f\n  x \\<notin> TER f\n\ngoal (1 subgoal):\n 1. x \\<in> TER f \\<or> y \\<in> TER f", "by auto"], ["proof (state)\nthis:\n  x \\<in> TER f \\<or> y \\<in> TER f\n\ngoal (2 subgoals):\n 1. edge \\<Gamma> y x \\<Longrightarrow> g (y, x) = 0\n 2. \\<not> edge \\<Gamma> y x \\<Longrightarrow> g (y, x) = 0", "with roofed_greater[THEN subsetD, of x \"TER f\" \\<Gamma>] x"], ["proof (chain)\npicking this:\n  x \\<in> TER f \\<Longrightarrow> x \\<in> roofed_gen \\<Gamma> ?B1 (TER f)\n  x \\<notin> RF (TER f)\n  x \\<in> TER f \\<or> y \\<in> TER f", "have \"x \\<notin> TER f\" \"y \\<in> TER f\""], ["proof (prove)\nusing this:\n  x \\<in> TER f \\<Longrightarrow> x \\<in> roofed_gen \\<Gamma> ?B1 (TER f)\n  x \\<notin> RF (TER f)\n  x \\<in> TER f \\<or> y \\<in> TER f\n\ngoal (1 subgoal):\n 1. x \\<notin> TER f &&& y \\<in> TER f", "by auto"], ["proof (state)\nthis:\n  x \\<notin> TER f\n  y \\<in> TER f\n\ngoal (2 subgoals):\n 1. edge \\<Gamma> y x \\<Longrightarrow> g (y, x) = 0\n 2. \\<not> edge \\<Gamma> y x \\<Longrightarrow> g (y, x) = 0", "with essential bypass"], ["proof (chain)\npicking this:\n  y \\<notin> \\<E> (TER f)\n  ?z \\<in> set p \\<Longrightarrow> ?z \\<notin> TER f\n  x \\<notin> TER f\n  x \\<notin> TER f\n  y \\<in> TER f", "have False"], ["proof (prove)\nusing this:\n  y \\<notin> \\<E> (TER f)\n  ?z \\<in> set p \\<Longrightarrow> ?z \\<notin> TER f\n  x \\<notin> TER f\n  x \\<notin> TER f\n  y \\<in> TER f\n\ngoal (1 subgoal):\n 1. False", "by(auto dest!: not_essentialD[OF _ rtrancl_path.step, OF _ True p z])"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. edge \\<Gamma> y x \\<Longrightarrow> g (y, x) = 0\n 2. \\<not> edge \\<Gamma> y x \\<Longrightarrow> g (y, x) = 0", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. g (y, x) = 0", ".."], ["proof (state)\nthis:\n  g (y, x) = 0\n\ngoal (1 subgoal):\n 1. \\<not> edge \\<Gamma> y x \\<Longrightarrow> g (y, x) = 0", "qed(simp add: currentD_outside[OF g])"], ["proof (state)\nthis:\n  g (y, x) = 0\n\ngoal (1 subgoal):\n 1. d_IN (g \\<upharpoonleft> \\<Gamma> / f) x = d_IN g x", "}"], ["proof (state)\nthis:\n  ?y2 \\<in> RF\\<^sup>\\<circ> (TER f) \\<Longrightarrow> g (?y2, x) = 0\n\ngoal (1 subgoal):\n 1. d_IN (g \\<upharpoonleft> \\<Gamma> / f) x = d_IN g x", "then"], ["proof (chain)\npicking this:\n  ?y2 \\<in> RF\\<^sup>\\<circ> (TER f) \\<Longrightarrow> g (?y2, x) = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  ?y2 \\<in> RF\\<^sup>\\<circ> (TER f) \\<Longrightarrow> g (?y2, x) = 0\n\ngoal (1 subgoal):\n 1. d_IN (g \\<upharpoonleft> \\<Gamma> / f) x = d_IN g x", "unfolding d_IN_def"], ["proof (prove)\nusing this:\n  ?y2 \\<in> RF\\<^sup>\\<circ> (TER f) \\<Longrightarrow> g (?y2, x) = 0\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ xa. (g \\<upharpoonleft> \\<Gamma> / f) (xa, x)) =\n    (\\<Sum>\\<^sup>+ xa. g (xa, x))", "using x"], ["proof (prove)\nusing this:\n  ?y2 \\<in> RF\\<^sup>\\<circ> (TER f) \\<Longrightarrow> g (?y2, x) = 0\n  x \\<notin> RF (TER f)\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ xa. (g \\<upharpoonleft> \\<Gamma> / f) (xa, x)) =\n    (\\<Sum>\\<^sup>+ xa. g (xa, x))", "by(auto intro!: nn_integral_cong split: split_indicator)"], ["proof (state)\nthis:\n  d_IN (g \\<upharpoonleft> \\<Gamma> / f) x = d_IN g x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma restrict_current_IN_A:\n  \"a \\<in> A (quotient_web \\<Gamma> f) \\<Longrightarrow> d_IN (g \\<upharpoonleft> \\<Gamma> / f) a = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<in> A (quotient_web \\<Gamma> f) \\<Longrightarrow>\n    d_IN (g \\<upharpoonleft> \\<Gamma> / f) a = 0", "by(simp add: d_IN_restrict_current_outside roofed_greaterI)"], ["", "lemma restrict_current_nonneg: \"0 \\<le> g e \\<Longrightarrow> 0 \\<le> (g \\<upharpoonleft> \\<Gamma> / f) e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> g e \\<Longrightarrow>\n    0 \\<le> (g \\<upharpoonleft> \\<Gamma> / f) e", "by(cases e) simp"], ["", "lemma in_SINK_restrict_current: \"x \\<in> SINK g \\<Longrightarrow> x \\<in> SINK (g \\<upharpoonleft> \\<Gamma> / f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> SINK g \\<Longrightarrow>\n    x \\<in> SINK (g \\<upharpoonleft> \\<Gamma> / f)", "using d_OUT_restrict_current_le[of \\<Gamma> f g x]"], ["proof (prove)\nusing this:\n  d_OUT (g \\<upharpoonleft> \\<Gamma> / f) x \\<le> d_OUT g x\n\ngoal (1 subgoal):\n 1. x \\<in> SINK g \\<Longrightarrow>\n    x \\<in> SINK (g \\<upharpoonleft> \\<Gamma> / f)", "by(simp add: SINK.simps)"], ["", "lemma SAT_restrict_current:\n  fixes \\<Gamma> (structure)\n  assumes f: \"current \\<Gamma> f\"\n  and g: \"current \\<Gamma> g\"\n  shows \"SAT (quotient_web \\<Gamma> f) (g \\<upharpoonleft> \\<Gamma> / f) = RF (TER f) \\<union> (SAT \\<Gamma> g - A \\<Gamma>)\" (is \"SAT ?\\<Gamma> ?g = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. SAT (quotient_web \\<Gamma> f) (g \\<upharpoonleft> \\<Gamma> / f) =\n    RF (TER f) \\<union> (SAT \\<Gamma> g - A \\<Gamma>)", "proof(intro set_eqI iffI; (elim UnE DiffE)?)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x.\n       x \\<in> SAT (quotient_web \\<Gamma> f)\n                (g \\<upharpoonleft> \\<Gamma> / f) \\<Longrightarrow>\n       x \\<in> RF (TER f) \\<union> (SAT \\<Gamma> g - A \\<Gamma>)\n 2. \\<And>x.\n       x \\<in> RF (TER f) \\<Longrightarrow>\n       x \\<in> SAT (quotient_web \\<Gamma> f)\n                (g \\<upharpoonleft> \\<Gamma> / f)\n 3. \\<And>x.\n       \\<lbrakk>x \\<in> SAT \\<Gamma> g; x \\<notin> A \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> x \\<in> SAT (quotient_web \\<Gamma> f)\n                                  (g \\<upharpoonleft> \\<Gamma> / f)", "show \"x \\<in> ?rhs\" if \"x \\<in> SAT ?\\<Gamma> ?g\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> RF (TER f) \\<union> (SAT \\<Gamma> g - A \\<Gamma>)", "using that"], ["proof (prove)\nusing this:\n  x \\<in> SAT (quotient_web \\<Gamma> f) (g \\<upharpoonleft> \\<Gamma> / f)\n\ngoal (1 subgoal):\n 1. x \\<in> RF (TER f) \\<union> (SAT \\<Gamma> g - A \\<Gamma>)", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<in> A (quotient_web \\<Gamma> f) \\<Longrightarrow>\n    x \\<in> RF (TER f) \\<union> (SAT \\<Gamma> g - A \\<Gamma>)\n 2. weight (quotient_web \\<Gamma> f) x\n    \\<le> d_IN (g \\<upharpoonleft> \\<Gamma> / f) x \\<Longrightarrow>\n    x \\<in> RF (TER f) \\<union> (SAT \\<Gamma> g - A \\<Gamma>)", "case IN"], ["proof (state)\nthis:\n  weight (quotient_web \\<Gamma> f) x\n  \\<le> d_IN (g \\<upharpoonleft> \\<Gamma> / f) x\n\ngoal (2 subgoals):\n 1. x \\<in> A (quotient_web \\<Gamma> f) \\<Longrightarrow>\n    x \\<in> RF (TER f) \\<union> (SAT \\<Gamma> g - A \\<Gamma>)\n 2. weight (quotient_web \\<Gamma> f) x\n    \\<le> d_IN (g \\<upharpoonleft> \\<Gamma> / f) x \\<Longrightarrow>\n    x \\<in> RF (TER f) \\<union> (SAT \\<Gamma> g - A \\<Gamma>)", "thus ?thesis"], ["proof (prove)\nusing this:\n  weight (quotient_web \\<Gamma> f) x\n  \\<le> d_IN (g \\<upharpoonleft> \\<Gamma> / f) x\n\ngoal (1 subgoal):\n 1. x \\<in> RF (TER f) \\<union> (SAT \\<Gamma> g - A \\<Gamma>)", "using currentD_weight_OUT[OF f, of x]"], ["proof (prove)\nusing this:\n  weight (quotient_web \\<Gamma> f) x\n  \\<le> d_IN (g \\<upharpoonleft> \\<Gamma> / f) x\n  d_OUT f x \\<le> weight \\<Gamma> x\n\ngoal (1 subgoal):\n 1. x \\<in> RF (TER f) \\<union> (SAT \\<Gamma> g - A \\<Gamma>)", "by(cases \"x \\<in> RF (TER f)\")(auto simp add: d_IN_restrict_current_outside roofed_circ_def restrict_current_IN_not_RF[OF g] SAT.IN currentD_IN[OF g] roofed_greaterI SAT.A SINK.simps RF_in_B split: if_split_asm intro: essentialI[OF rtrancl_path.base])"], ["proof (state)\nthis:\n  x \\<in> RF (TER f) \\<union> (SAT \\<Gamma> g - A \\<Gamma>)\n\ngoal (1 subgoal):\n 1. x \\<in> A (quotient_web \\<Gamma> f) \\<Longrightarrow>\n    x \\<in> RF (TER f) \\<union> (SAT \\<Gamma> g - A \\<Gamma>)", "qed(simp add: roofed_greaterI)"], ["proof (state)\nthis:\n  ?x \\<in> SAT (quotient_web \\<Gamma> f)\n            (g \\<upharpoonleft> \\<Gamma> / f) \\<Longrightarrow>\n  ?x \\<in> RF (TER f) \\<union> (SAT \\<Gamma> g - A \\<Gamma>)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> RF (TER f) \\<Longrightarrow>\n       x \\<in> SAT (quotient_web \\<Gamma> f)\n                (g \\<upharpoonleft> \\<Gamma> / f)\n 2. \\<And>x.\n       \\<lbrakk>x \\<in> SAT \\<Gamma> g; x \\<notin> A \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> x \\<in> SAT (quotient_web \\<Gamma> f)\n                                  (g \\<upharpoonleft> \\<Gamma> / f)", "show \"x \\<in> SAT ?\\<Gamma> ?g\" if \"x \\<in> RF (TER f)\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> SAT (quotient_web \\<Gamma> f) (g \\<upharpoonleft> \\<Gamma> / f)", "using that"], ["proof (prove)\nusing this:\n  x \\<in> RF (TER f)\n\ngoal (1 subgoal):\n 1. x \\<in> SAT (quotient_web \\<Gamma> f) (g \\<upharpoonleft> \\<Gamma> / f)", "by(auto simp add: SAT.simps roofed_circ_def d_IN_restrict_current_outside)"], ["proof (state)\nthis:\n  ?x \\<in> RF (TER f) \\<Longrightarrow>\n  ?x \\<in> SAT (quotient_web \\<Gamma> f) (g \\<upharpoonleft> \\<Gamma> / f)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> SAT \\<Gamma> g; x \\<notin> A \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> x \\<in> SAT (quotient_web \\<Gamma> f)\n                                  (g \\<upharpoonleft> \\<Gamma> / f)", "show \"x \\<in> SAT ?\\<Gamma> ?g\" if \"x \\<in> SAT \\<Gamma> g\" \"x \\<notin> A \\<Gamma>\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> SAT (quotient_web \\<Gamma> f) (g \\<upharpoonleft> \\<Gamma> / f)", "using that"], ["proof (prove)\nusing this:\n  x \\<in> SAT \\<Gamma> g\n  x \\<notin> A \\<Gamma>\n\ngoal (1 subgoal):\n 1. x \\<in> SAT (quotient_web \\<Gamma> f) (g \\<upharpoonleft> \\<Gamma> / f)", "by(auto simp add: SAT.simps roofed_circ_def d_IN_restrict_current_outside restrict_current_IN_not_RF[OF g])"], ["proof (state)\nthis:\n  \\<lbrakk>?x \\<in> SAT \\<Gamma> g; ?x \\<notin> A \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> ?x \\<in> SAT (quotient_web \\<Gamma> f)\n                              (g \\<upharpoonleft> \\<Gamma> / f)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma current_restrict_current:\n  fixes \\<Gamma> (structure)\n  assumes w: \"wave \\<Gamma> f\"\n  and g: \"current \\<Gamma> g\"\n  shows \"current (quotient_web \\<Gamma> f) (g \\<upharpoonleft> \\<Gamma> / f)\" (is \"current ?\\<Gamma> ?g\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. current (quotient_web \\<Gamma> f) (g \\<upharpoonleft> \\<Gamma> / f)", "proof"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>x.\n       d_OUT (g \\<upharpoonleft> \\<Gamma> / f) x\n       \\<le> weight (quotient_web \\<Gamma> f) x\n 2. \\<And>x.\n       d_IN (g \\<upharpoonleft> \\<Gamma> / f) x\n       \\<le> weight (quotient_web \\<Gamma> f) x\n 3. \\<And>x.\n       x \\<notin> A (quotient_web \\<Gamma> f) \\<Longrightarrow>\n       d_OUT (g \\<upharpoonleft> \\<Gamma> / f) x\n       \\<le> d_IN (g \\<upharpoonleft> \\<Gamma> / f) x\n 4. \\<And>a.\n       a \\<in> A (quotient_web \\<Gamma> f) \\<Longrightarrow>\n       d_IN (g \\<upharpoonleft> \\<Gamma> / f) a = 0\n 5. \\<And>b.\n       b \\<in> B (quotient_web \\<Gamma> f) \\<Longrightarrow>\n       d_OUT (g \\<upharpoonleft> \\<Gamma> / f) b = 0\n 6. \\<And>e.\n       e \\<notin> \\<^bold>E\\<^bsub>quotient_web \\<Gamma> f\\<^esub> \\<Longrightarrow>\n       (g \\<upharpoonleft> \\<Gamma> / f) e = 0", "show \"d_OUT ?g x \\<le> weight ?\\<Gamma> x\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT (g \\<upharpoonleft> \\<Gamma> / f) x\n    \\<le> weight (quotient_web \\<Gamma> f) x", "using d_OUT_restrict_current_le[of \\<Gamma> f g x] currentD_weight_OUT[OF g, of x] currentD_OUT[OF g, of x]"], ["proof (prove)\nusing this:\n  d_OUT (g \\<upharpoonleft> \\<Gamma> / f) x \\<le> d_OUT g x\n  d_OUT g x \\<le> weight \\<Gamma> x\n  x \\<in> B \\<Gamma> \\<Longrightarrow> d_OUT g x = 0\n\ngoal (1 subgoal):\n 1. d_OUT (g \\<upharpoonleft> \\<Gamma> / f) x\n    \\<le> weight (quotient_web \\<Gamma> f) x", "by(auto simp add: d_OUT_restrict_current_outside)"], ["proof (state)\nthis:\n  d_OUT (g \\<upharpoonleft> \\<Gamma> / f) ?x\n  \\<le> weight (quotient_web \\<Gamma> f) ?x\n\ngoal (5 subgoals):\n 1. \\<And>x.\n       d_IN (g \\<upharpoonleft> \\<Gamma> / f) x\n       \\<le> weight (quotient_web \\<Gamma> f) x\n 2. \\<And>x.\n       x \\<notin> A (quotient_web \\<Gamma> f) \\<Longrightarrow>\n       d_OUT (g \\<upharpoonleft> \\<Gamma> / f) x\n       \\<le> d_IN (g \\<upharpoonleft> \\<Gamma> / f) x\n 3. \\<And>a.\n       a \\<in> A (quotient_web \\<Gamma> f) \\<Longrightarrow>\n       d_IN (g \\<upharpoonleft> \\<Gamma> / f) a = 0\n 4. \\<And>b.\n       b \\<in> B (quotient_web \\<Gamma> f) \\<Longrightarrow>\n       d_OUT (g \\<upharpoonleft> \\<Gamma> / f) b = 0\n 5. \\<And>e.\n       e \\<notin> \\<^bold>E\\<^bsub>quotient_web \\<Gamma> f\\<^esub> \\<Longrightarrow>\n       (g \\<upharpoonleft> \\<Gamma> / f) e = 0", "show \"d_IN ?g x \\<le> weight ?\\<Gamma> x\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN (g \\<upharpoonleft> \\<Gamma> / f) x\n    \\<le> weight (quotient_web \\<Gamma> f) x", "using d_IN_restrict_current_le[of \\<Gamma> f g x] currentD_weight_IN[OF g, of x]"], ["proof (prove)\nusing this:\n  d_IN (g \\<upharpoonleft> \\<Gamma> / f) x \\<le> d_IN g x\n  d_IN g x \\<le> weight \\<Gamma> x\n\ngoal (1 subgoal):\n 1. d_IN (g \\<upharpoonleft> \\<Gamma> / f) x\n    \\<le> weight (quotient_web \\<Gamma> f) x", "by(auto simp add: d_IN_restrict_current_outside roofed_circ_def)\n      (subst d_IN_restrict_current_outside[of x \\<Gamma> f g]; simp add: roofed_greaterI)"], ["proof (state)\nthis:\n  d_IN (g \\<upharpoonleft> \\<Gamma> / f) ?x\n  \\<le> weight (quotient_web \\<Gamma> f) ?x\n\ngoal (4 subgoals):\n 1. \\<And>x.\n       x \\<notin> A (quotient_web \\<Gamma> f) \\<Longrightarrow>\n       d_OUT (g \\<upharpoonleft> \\<Gamma> / f) x\n       \\<le> d_IN (g \\<upharpoonleft> \\<Gamma> / f) x\n 2. \\<And>a.\n       a \\<in> A (quotient_web \\<Gamma> f) \\<Longrightarrow>\n       d_IN (g \\<upharpoonleft> \\<Gamma> / f) a = 0\n 3. \\<And>b.\n       b \\<in> B (quotient_web \\<Gamma> f) \\<Longrightarrow>\n       d_OUT (g \\<upharpoonleft> \\<Gamma> / f) b = 0\n 4. \\<And>e.\n       e \\<notin> \\<^bold>E\\<^bsub>quotient_web \\<Gamma> f\\<^esub> \\<Longrightarrow>\n       (g \\<upharpoonleft> \\<Gamma> / f) e = 0", "fix x"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x.\n       x \\<notin> A (quotient_web \\<Gamma> f) \\<Longrightarrow>\n       d_OUT (g \\<upharpoonleft> \\<Gamma> / f) x\n       \\<le> d_IN (g \\<upharpoonleft> \\<Gamma> / f) x\n 2. \\<And>a.\n       a \\<in> A (quotient_web \\<Gamma> f) \\<Longrightarrow>\n       d_IN (g \\<upharpoonleft> \\<Gamma> / f) a = 0\n 3. \\<And>b.\n       b \\<in> B (quotient_web \\<Gamma> f) \\<Longrightarrow>\n       d_OUT (g \\<upharpoonleft> \\<Gamma> / f) b = 0\n 4. \\<And>e.\n       e \\<notin> \\<^bold>E\\<^bsub>quotient_web \\<Gamma> f\\<^esub> \\<Longrightarrow>\n       (g \\<upharpoonleft> \\<Gamma> / f) e = 0", "assume \"x \\<notin> A ?\\<Gamma>\""], ["proof (state)\nthis:\n  x \\<notin> A (quotient_web \\<Gamma> f)\n\ngoal (4 subgoals):\n 1. \\<And>x.\n       x \\<notin> A (quotient_web \\<Gamma> f) \\<Longrightarrow>\n       d_OUT (g \\<upharpoonleft> \\<Gamma> / f) x\n       \\<le> d_IN (g \\<upharpoonleft> \\<Gamma> / f) x\n 2. \\<And>a.\n       a \\<in> A (quotient_web \\<Gamma> f) \\<Longrightarrow>\n       d_IN (g \\<upharpoonleft> \\<Gamma> / f) a = 0\n 3. \\<And>b.\n       b \\<in> B (quotient_web \\<Gamma> f) \\<Longrightarrow>\n       d_OUT (g \\<upharpoonleft> \\<Gamma> / f) b = 0\n 4. \\<And>e.\n       e \\<notin> \\<^bold>E\\<^bsub>quotient_web \\<Gamma> f\\<^esub> \\<Longrightarrow>\n       (g \\<upharpoonleft> \\<Gamma> / f) e = 0", "hence x: \"x \\<notin> \\<E> (TER f) - B \\<Gamma>\""], ["proof (prove)\nusing this:\n  x \\<notin> A (quotient_web \\<Gamma> f)\n\ngoal (1 subgoal):\n 1. x \\<notin> \\<E> (TER f) - B \\<Gamma>", "by simp"], ["proof (state)\nthis:\n  x \\<notin> \\<E> (TER f) - B \\<Gamma>\n\ngoal (4 subgoals):\n 1. \\<And>x.\n       x \\<notin> A (quotient_web \\<Gamma> f) \\<Longrightarrow>\n       d_OUT (g \\<upharpoonleft> \\<Gamma> / f) x\n       \\<le> d_IN (g \\<upharpoonleft> \\<Gamma> / f) x\n 2. \\<And>a.\n       a \\<in> A (quotient_web \\<Gamma> f) \\<Longrightarrow>\n       d_IN (g \\<upharpoonleft> \\<Gamma> / f) a = 0\n 3. \\<And>b.\n       b \\<in> B (quotient_web \\<Gamma> f) \\<Longrightarrow>\n       d_OUT (g \\<upharpoonleft> \\<Gamma> / f) b = 0\n 4. \\<And>e.\n       e \\<notin> \\<^bold>E\\<^bsub>quotient_web \\<Gamma> f\\<^esub> \\<Longrightarrow>\n       (g \\<upharpoonleft> \\<Gamma> / f) e = 0", "show \"d_OUT ?g x \\<le> d_IN ?g x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT (g \\<upharpoonleft> \\<Gamma> / f) x\n    \\<le> d_IN (g \\<upharpoonleft> \\<Gamma> / f) x", "proof(cases \"x \\<in> RF (TER f)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<in> RF (TER f) \\<Longrightarrow>\n    d_OUT (g \\<upharpoonleft> \\<Gamma> / f) x\n    \\<le> d_IN (g \\<upharpoonleft> \\<Gamma> / f) x\n 2. x \\<notin> RF (TER f) \\<Longrightarrow>\n    d_OUT (g \\<upharpoonleft> \\<Gamma> / f) x\n    \\<le> d_IN (g \\<upharpoonleft> \\<Gamma> / f) x", "case True"], ["proof (state)\nthis:\n  x \\<in> RF (TER f)\n\ngoal (2 subgoals):\n 1. x \\<in> RF (TER f) \\<Longrightarrow>\n    d_OUT (g \\<upharpoonleft> \\<Gamma> / f) x\n    \\<le> d_IN (g \\<upharpoonleft> \\<Gamma> / f) x\n 2. x \\<notin> RF (TER f) \\<Longrightarrow>\n    d_OUT (g \\<upharpoonleft> \\<Gamma> / f) x\n    \\<le> d_IN (g \\<upharpoonleft> \\<Gamma> / f) x", "with x"], ["proof (chain)\npicking this:\n  x \\<notin> \\<E> (TER f) - B \\<Gamma>\n  x \\<in> RF (TER f)", "have \"x \\<in> RF\\<^sup>\\<circ> (TER f) \\<union> B \\<Gamma>\""], ["proof (prove)\nusing this:\n  x \\<notin> \\<E> (TER f) - B \\<Gamma>\n  x \\<in> RF (TER f)\n\ngoal (1 subgoal):\n 1. x \\<in> RF\\<^sup>\\<circ> (TER f) \\<union> B \\<Gamma>", "by(simp add: roofed_circ_def)"], ["proof (state)\nthis:\n  x \\<in> RF\\<^sup>\\<circ> (TER f) \\<union> B \\<Gamma>\n\ngoal (2 subgoals):\n 1. x \\<in> RF (TER f) \\<Longrightarrow>\n    d_OUT (g \\<upharpoonleft> \\<Gamma> / f) x\n    \\<le> d_IN (g \\<upharpoonleft> \\<Gamma> / f) x\n 2. x \\<notin> RF (TER f) \\<Longrightarrow>\n    d_OUT (g \\<upharpoonleft> \\<Gamma> / f) x\n    \\<le> d_IN (g \\<upharpoonleft> \\<Gamma> / f) x", "with True"], ["proof (chain)\npicking this:\n  x \\<in> RF (TER f)\n  x \\<in> RF\\<^sup>\\<circ> (TER f) \\<union> B \\<Gamma>", "show ?thesis"], ["proof (prove)\nusing this:\n  x \\<in> RF (TER f)\n  x \\<in> RF\\<^sup>\\<circ> (TER f) \\<union> B \\<Gamma>\n\ngoal (1 subgoal):\n 1. d_OUT (g \\<upharpoonleft> \\<Gamma> / f) x\n    \\<le> d_IN (g \\<upharpoonleft> \\<Gamma> / f) x", "using currentD_OUT[OF g, of x] d_OUT_restrict_current_le[of \\<Gamma> f g x]"], ["proof (prove)\nusing this:\n  x \\<in> RF (TER f)\n  x \\<in> RF\\<^sup>\\<circ> (TER f) \\<union> B \\<Gamma>\n  x \\<in> B \\<Gamma> \\<Longrightarrow> d_OUT g x = 0\n  d_OUT (g \\<upharpoonleft> \\<Gamma> / f) x \\<le> d_OUT g x\n\ngoal (1 subgoal):\n 1. d_OUT (g \\<upharpoonleft> \\<Gamma> / f) x\n    \\<le> d_IN (g \\<upharpoonleft> \\<Gamma> / f) x", "by(auto simp add: d_OUT_restrict_current_outside d_IN_restrict_current_outside)"], ["proof (state)\nthis:\n  d_OUT (g \\<upharpoonleft> \\<Gamma> / f) x\n  \\<le> d_IN (g \\<upharpoonleft> \\<Gamma> / f) x\n\ngoal (1 subgoal):\n 1. x \\<notin> RF (TER f) \\<Longrightarrow>\n    d_OUT (g \\<upharpoonleft> \\<Gamma> / f) x\n    \\<le> d_IN (g \\<upharpoonleft> \\<Gamma> / f) x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<notin> RF (TER f) \\<Longrightarrow>\n    d_OUT (g \\<upharpoonleft> \\<Gamma> / f) x\n    \\<le> d_IN (g \\<upharpoonleft> \\<Gamma> / f) x", "case False"], ["proof (state)\nthis:\n  x \\<notin> RF (TER f)\n\ngoal (1 subgoal):\n 1. x \\<notin> RF (TER f) \\<Longrightarrow>\n    d_OUT (g \\<upharpoonleft> \\<Gamma> / f) x\n    \\<le> d_IN (g \\<upharpoonleft> \\<Gamma> / f) x", "then"], ["proof (chain)\npicking this:\n  x \\<notin> RF (TER f)", "obtain p z where z: \"z \\<in> B \\<Gamma>\" and p: \"path \\<Gamma> x p z\"\n      and bypass: \"\\<And>z. z \\<in> set p \\<Longrightarrow> z \\<notin> TER f\" \"x \\<notin> TER f\""], ["proof (prove)\nusing this:\n  x \\<notin> RF (TER f)\n\ngoal (1 subgoal):\n 1. (\\<And>z p.\n        \\<lbrakk>z \\<in> B \\<Gamma>; path \\<Gamma> x p z;\n         \\<And>z. z \\<in> set p \\<Longrightarrow> z \\<notin> TER f;\n         x \\<notin> TER f\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(clarsimp simp add: roofed_def)"], ["proof (state)\nthis:\n  z \\<in> B \\<Gamma>\n  path \\<Gamma> x p z\n  ?z \\<in> set p \\<Longrightarrow> ?z \\<notin> TER f\n  x \\<notin> TER f\n\ngoal (1 subgoal):\n 1. x \\<notin> RF (TER f) \\<Longrightarrow>\n    d_OUT (g \\<upharpoonleft> \\<Gamma> / f) x\n    \\<le> d_IN (g \\<upharpoonleft> \\<Gamma> / f) x", "from g False"], ["proof (chain)\npicking this:\n  current \\<Gamma> g\n  x \\<notin> RF (TER f)", "have \"d_IN ?g x = d_IN g x\""], ["proof (prove)\nusing this:\n  current \\<Gamma> g\n  x \\<notin> RF (TER f)\n\ngoal (1 subgoal):\n 1. d_IN (g \\<upharpoonleft> \\<Gamma> / f) x = d_IN g x", "by(rule restrict_current_IN_not_RF)"], ["proof (state)\nthis:\n  d_IN (g \\<upharpoonleft> \\<Gamma> / f) x = d_IN g x\n\ngoal (1 subgoal):\n 1. x \\<notin> RF (TER f) \\<Longrightarrow>\n    d_OUT (g \\<upharpoonleft> \\<Gamma> / f) x\n    \\<le> d_IN (g \\<upharpoonleft> \\<Gamma> / f) x", "moreover"], ["proof (state)\nthis:\n  d_IN (g \\<upharpoonleft> \\<Gamma> / f) x = d_IN g x\n\ngoal (1 subgoal):\n 1. x \\<notin> RF (TER f) \\<Longrightarrow>\n    d_OUT (g \\<upharpoonleft> \\<Gamma> / f) x\n    \\<le> d_IN (g \\<upharpoonleft> \\<Gamma> / f) x", "have \"d_OUT ?g x \\<le> d_OUT g x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT (g \\<upharpoonleft> \\<Gamma> / f) x \\<le> d_OUT g x", "by(rule d_OUT_mono restrict_current_le)+"], ["proof (state)\nthis:\n  d_OUT (g \\<upharpoonleft> \\<Gamma> / f) x \\<le> d_OUT g x\n\ngoal (1 subgoal):\n 1. x \\<notin> RF (TER f) \\<Longrightarrow>\n    d_OUT (g \\<upharpoonleft> \\<Gamma> / f) x\n    \\<le> d_IN (g \\<upharpoonleft> \\<Gamma> / f) x", "moreover"], ["proof (state)\nthis:\n  d_OUT (g \\<upharpoonleft> \\<Gamma> / f) x \\<le> d_OUT g x\n\ngoal (1 subgoal):\n 1. x \\<notin> RF (TER f) \\<Longrightarrow>\n    d_OUT (g \\<upharpoonleft> \\<Gamma> / f) x\n    \\<le> d_IN (g \\<upharpoonleft> \\<Gamma> / f) x", "have \"x \\<notin> A \\<Gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> A \\<Gamma>", "using separatingD[OF waveD_separating[OF w] p _ z] bypass"], ["proof (prove)\nusing this:\n  x \\<in> A \\<Gamma> \\<Longrightarrow>\n  (\\<exists>z\\<in>set p. z \\<in> TER f) \\<or> x \\<in> TER f\n  ?z \\<in> set p \\<Longrightarrow> ?z \\<notin> TER f\n  x \\<notin> TER f\n\ngoal (1 subgoal):\n 1. x \\<notin> A \\<Gamma>", "by blast"], ["proof (state)\nthis:\n  x \\<notin> A \\<Gamma>\n\ngoal (1 subgoal):\n 1. x \\<notin> RF (TER f) \\<Longrightarrow>\n    d_OUT (g \\<upharpoonleft> \\<Gamma> / f) x\n    \\<le> d_IN (g \\<upharpoonleft> \\<Gamma> / f) x", "note currentD_OUT_IN[OF g this]"], ["proof (state)\nthis:\n  d_OUT g x \\<le> d_IN g x\n\ngoal (1 subgoal):\n 1. x \\<notin> RF (TER f) \\<Longrightarrow>\n    d_OUT (g \\<upharpoonleft> \\<Gamma> / f) x\n    \\<le> d_IN (g \\<upharpoonleft> \\<Gamma> / f) x", "ultimately"], ["proof (chain)\npicking this:\n  d_IN (g \\<upharpoonleft> \\<Gamma> / f) x = d_IN g x\n  d_OUT (g \\<upharpoonleft> \\<Gamma> / f) x \\<le> d_OUT g x\n  d_OUT g x \\<le> d_IN g x", "show ?thesis"], ["proof (prove)\nusing this:\n  d_IN (g \\<upharpoonleft> \\<Gamma> / f) x = d_IN g x\n  d_OUT (g \\<upharpoonleft> \\<Gamma> / f) x \\<le> d_OUT g x\n  d_OUT g x \\<le> d_IN g x\n\ngoal (1 subgoal):\n 1. d_OUT (g \\<upharpoonleft> \\<Gamma> / f) x\n    \\<le> d_IN (g \\<upharpoonleft> \\<Gamma> / f) x", "by simp"], ["proof (state)\nthis:\n  d_OUT (g \\<upharpoonleft> \\<Gamma> / f) x\n  \\<le> d_IN (g \\<upharpoonleft> \\<Gamma> / f) x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  d_OUT (g \\<upharpoonleft> \\<Gamma> / f) x\n  \\<le> d_IN (g \\<upharpoonleft> \\<Gamma> / f) x\n\ngoal (3 subgoals):\n 1. \\<And>a.\n       a \\<in> A (quotient_web \\<Gamma> f) \\<Longrightarrow>\n       d_IN (g \\<upharpoonleft> \\<Gamma> / f) a = 0\n 2. \\<And>b.\n       b \\<in> B (quotient_web \\<Gamma> f) \\<Longrightarrow>\n       d_OUT (g \\<upharpoonleft> \\<Gamma> / f) b = 0\n 3. \\<And>e.\n       e \\<notin> \\<^bold>E\\<^bsub>quotient_web \\<Gamma> f\\<^esub> \\<Longrightarrow>\n       (g \\<upharpoonleft> \\<Gamma> / f) e = 0", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>a.\n       a \\<in> A (quotient_web \\<Gamma> f) \\<Longrightarrow>\n       d_IN (g \\<upharpoonleft> \\<Gamma> / f) a = 0\n 2. \\<And>b.\n       b \\<in> B (quotient_web \\<Gamma> f) \\<Longrightarrow>\n       d_OUT (g \\<upharpoonleft> \\<Gamma> / f) b = 0\n 3. \\<And>e.\n       e \\<notin> \\<^bold>E\\<^bsub>quotient_web \\<Gamma> f\\<^esub> \\<Longrightarrow>\n       (g \\<upharpoonleft> \\<Gamma> / f) e = 0", "show \"d_IN ?g a = 0\" if \"a \\<in> A ?\\<Gamma>\" for a"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN (g \\<upharpoonleft> \\<Gamma> / f) a = 0", "using that"], ["proof (prove)\nusing this:\n  a \\<in> A (quotient_web \\<Gamma> f)\n\ngoal (1 subgoal):\n 1. d_IN (g \\<upharpoonleft> \\<Gamma> / f) a = 0", "by(rule restrict_current_IN_A)"], ["proof (state)\nthis:\n  ?a \\<in> A (quotient_web \\<Gamma> f) \\<Longrightarrow>\n  d_IN (g \\<upharpoonleft> \\<Gamma> / f) ?a = 0\n\ngoal (2 subgoals):\n 1. \\<And>b.\n       b \\<in> B (quotient_web \\<Gamma> f) \\<Longrightarrow>\n       d_OUT (g \\<upharpoonleft> \\<Gamma> / f) b = 0\n 2. \\<And>e.\n       e \\<notin> \\<^bold>E\\<^bsub>quotient_web \\<Gamma> f\\<^esub> \\<Longrightarrow>\n       (g \\<upharpoonleft> \\<Gamma> / f) e = 0", "show \"d_OUT ?g b = 0\" if \"b \\<in> B ?\\<Gamma>\" for b"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT (g \\<upharpoonleft> \\<Gamma> / f) b = 0", "using d_OUT_restrict_current_le[of \\<Gamma> f g b] currentD_OUT[OF g, of b] that"], ["proof (prove)\nusing this:\n  d_OUT (g \\<upharpoonleft> \\<Gamma> / f) b \\<le> d_OUT g b\n  b \\<in> B \\<Gamma> \\<Longrightarrow> d_OUT g b = 0\n  b \\<in> B (quotient_web \\<Gamma> f)\n\ngoal (1 subgoal):\n 1. d_OUT (g \\<upharpoonleft> \\<Gamma> / f) b = 0", "by simp"], ["proof (state)\nthis:\n  ?b \\<in> B (quotient_web \\<Gamma> f) \\<Longrightarrow>\n  d_OUT (g \\<upharpoonleft> \\<Gamma> / f) ?b = 0\n\ngoal (1 subgoal):\n 1. \\<And>e.\n       e \\<notin> \\<^bold>E\\<^bsub>quotient_web \\<Gamma> f\\<^esub> \\<Longrightarrow>\n       (g \\<upharpoonleft> \\<Gamma> / f) e = 0", "show \"?g e = 0\" if \"e \\<notin> \\<^bold>E\\<^bsub>?\\<Gamma>\\<^esub>\" for e"], ["proof (prove)\ngoal (1 subgoal):\n 1. (g \\<upharpoonleft> \\<Gamma> / f) e = 0", "using that currentD_outside'[OF g, of e]"], ["proof (prove)\nusing this:\n  e \\<notin> \\<^bold>E\\<^bsub>quotient_web \\<Gamma> f\\<^esub>\n  e \\<notin> \\<^bold>E \\<Longrightarrow> g e = 0\n\ngoal (1 subgoal):\n 1. (g \\<upharpoonleft> \\<Gamma> / f) e = 0", "by(cases e)(auto split: split_indicator)"], ["proof (state)\nthis:\n  ?e \\<notin> \\<^bold>E\\<^bsub>quotient_web \\<Gamma> f\\<^esub> \\<Longrightarrow>\n  (g \\<upharpoonleft> \\<Gamma> / f) ?e = 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma TER_restrict_current:\n  fixes \\<Gamma> (structure)\n  assumes f: \"current \\<Gamma> f\"\n  and w: \"wave \\<Gamma> f\"\n  and g: \"current \\<Gamma> g\"\n  shows \"TER g \\<subseteq> TER\\<^bsub>quotient_web \\<Gamma> f\\<^esub> (g \\<upharpoonleft> \\<Gamma> / f)\" (is \"_ \\<subseteq> ?TER\" is \"_ \\<subseteq> TER\\<^bsub>?\\<Gamma>\\<^esub> ?g\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. TER g\n    \\<subseteq> TER\\<^bsub>quotient_web \\<Gamma> f\\<^esub>\n                 (g \\<upharpoonleft> \\<Gamma> / f)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> TER g \\<Longrightarrow>\n       x \\<in> TER\\<^bsub>quotient_web \\<Gamma> f\\<^esub>\n                (g \\<upharpoonleft> \\<Gamma> / f)", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> TER g \\<Longrightarrow>\n       x \\<in> TER\\<^bsub>quotient_web \\<Gamma> f\\<^esub>\n                (g \\<upharpoonleft> \\<Gamma> / f)", "assume x: \"x \\<in> TER g\""], ["proof (state)\nthis:\n  x \\<in> TER g\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> TER g \\<Longrightarrow>\n       x \\<in> TER\\<^bsub>quotient_web \\<Gamma> f\\<^esub>\n                (g \\<upharpoonleft> \\<Gamma> / f)", "hence \"x \\<in> SINK ?g\""], ["proof (prove)\nusing this:\n  x \\<in> TER g\n\ngoal (1 subgoal):\n 1. x \\<in> SINK (g \\<upharpoonleft> \\<Gamma> / f)", "by(simp add: in_SINK_restrict_current)"], ["proof (state)\nthis:\n  x \\<in> SINK (g \\<upharpoonleft> \\<Gamma> / f)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> TER g \\<Longrightarrow>\n       x \\<in> TER\\<^bsub>quotient_web \\<Gamma> f\\<^esub>\n                (g \\<upharpoonleft> \\<Gamma> / f)", "moreover"], ["proof (state)\nthis:\n  x \\<in> SINK (g \\<upharpoonleft> \\<Gamma> / f)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> TER g \\<Longrightarrow>\n       x \\<in> TER\\<^bsub>quotient_web \\<Gamma> f\\<^esub>\n                (g \\<upharpoonleft> \\<Gamma> / f)", "have \"x \\<in> RF (TER f)\" if \"x \\<in> A \\<Gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> RF (TER f)", "using waveD_separating[OF w, THEN separatingD, OF _ that]"], ["proof (prove)\nusing this:\n  \\<lbrakk>path \\<Gamma> x ?p ?y; ?y \\<in> B \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> (\\<exists>z\\<in>set ?p. z \\<in> TER f) \\<or>\n                    x \\<in> TER f\n\ngoal (1 subgoal):\n 1. x \\<in> RF (TER f)", "by(rule roofedI)"], ["proof (state)\nthis:\n  x \\<in> A \\<Gamma> \\<Longrightarrow> x \\<in> RF (TER f)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> TER g \\<Longrightarrow>\n       x \\<in> TER\\<^bsub>quotient_web \\<Gamma> f\\<^esub>\n                (g \\<upharpoonleft> \\<Gamma> / f)", "then"], ["proof (chain)\npicking this:\n  x \\<in> A \\<Gamma> \\<Longrightarrow> x \\<in> RF (TER f)", "have \"x \\<in> SAT ?\\<Gamma> ?g\""], ["proof (prove)\nusing this:\n  x \\<in> A \\<Gamma> \\<Longrightarrow> x \\<in> RF (TER f)\n\ngoal (1 subgoal):\n 1. x \\<in> SAT (quotient_web \\<Gamma> f) (g \\<upharpoonleft> \\<Gamma> / f)", "using SAT_restrict_current[OF f g] x"], ["proof (prove)\nusing this:\n  x \\<in> A \\<Gamma> \\<Longrightarrow> x \\<in> RF (TER f)\n  SAT (quotient_web \\<Gamma> f) (g \\<upharpoonleft> \\<Gamma> / f) =\n  RF (TER f) \\<union> (SAT \\<Gamma> g - A \\<Gamma>)\n  x \\<in> TER g\n\ngoal (1 subgoal):\n 1. x \\<in> SAT (quotient_web \\<Gamma> f) (g \\<upharpoonleft> \\<Gamma> / f)", "by auto"], ["proof (state)\nthis:\n  x \\<in> SAT (quotient_web \\<Gamma> f) (g \\<upharpoonleft> \\<Gamma> / f)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> TER g \\<Longrightarrow>\n       x \\<in> TER\\<^bsub>quotient_web \\<Gamma> f\\<^esub>\n                (g \\<upharpoonleft> \\<Gamma> / f)", "ultimately"], ["proof (chain)\npicking this:\n  x \\<in> SINK (g \\<upharpoonleft> \\<Gamma> / f)\n  x \\<in> SAT (quotient_web \\<Gamma> f) (g \\<upharpoonleft> \\<Gamma> / f)", "show \"x \\<in> ?TER\""], ["proof (prove)\nusing this:\n  x \\<in> SINK (g \\<upharpoonleft> \\<Gamma> / f)\n  x \\<in> SAT (quotient_web \\<Gamma> f) (g \\<upharpoonleft> \\<Gamma> / f)\n\ngoal (1 subgoal):\n 1. x \\<in> TER\\<^bsub>quotient_web \\<Gamma> f\\<^esub>\n             (g \\<upharpoonleft> \\<Gamma> / f)", "by simp"], ["proof (state)\nthis:\n  x \\<in> TER\\<^bsub>quotient_web \\<Gamma> f\\<^esub>\n           (g \\<upharpoonleft> \\<Gamma> / f)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma wave_restrict_current:\n  fixes \\<Gamma> (structure)\n  assumes f: \"current \\<Gamma> f\"\n  and w: \"wave \\<Gamma> f\"\n  and g: \"current \\<Gamma> g\"\n  and w': \"wave \\<Gamma> g\"\n  shows \"wave (quotient_web \\<Gamma> f) (g \\<upharpoonleft> \\<Gamma> / f)\" (is \"wave ?\\<Gamma> ?g\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. wave (quotient_web \\<Gamma> f) (g \\<upharpoonleft> \\<Gamma> / f)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. separating (quotient_web \\<Gamma> f)\n     (TER\\<^bsub>quotient_web \\<Gamma> f\\<^esub>\n       (g \\<upharpoonleft> \\<Gamma> / f))\n 2. \\<And>x.\n       x \\<notin> RF\\<^bsub>quotient_web \\<Gamma> f\\<^esub>\n                   (TER\\<^bsub>quotient_web \\<Gamma> f\\<^esub>\n                     (g \\<upharpoonleft> \\<Gamma> / f)) \\<Longrightarrow>\n       d_OUT (g \\<upharpoonleft> \\<Gamma> / f) x = 0", "show \"separating ?\\<Gamma> (TER\\<^bsub>?\\<Gamma>\\<^esub> ?g)\" (is \"separating _ ?TER\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. separating (quotient_web \\<Gamma> f)\n     (TER\\<^bsub>quotient_web \\<Gamma> f\\<^esub>\n       (g \\<upharpoonleft> \\<Gamma> / f))", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y p.\n       \\<lbrakk>x \\<in> A (quotient_web \\<Gamma> f);\n        y \\<in> B (quotient_web \\<Gamma> f);\n        path (quotient_web \\<Gamma> f) x p y\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>z\\<in>set p.\n                             z \\<in> TER\\<^bsub>quotient_web \\<Gamma> f\\<^esub>\n(g \\<upharpoonleft> \\<Gamma> / f)) \\<or>\n                         x \\<in> TER\\<^bsub>quotient_web \\<Gamma> f\\<^esub>\n                                  (g \\<upharpoonleft> \\<Gamma> / f)", "fix x y p"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y p.\n       \\<lbrakk>x \\<in> A (quotient_web \\<Gamma> f);\n        y \\<in> B (quotient_web \\<Gamma> f);\n        path (quotient_web \\<Gamma> f) x p y\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>z\\<in>set p.\n                             z \\<in> TER\\<^bsub>quotient_web \\<Gamma> f\\<^esub>\n(g \\<upharpoonleft> \\<Gamma> / f)) \\<or>\n                         x \\<in> TER\\<^bsub>quotient_web \\<Gamma> f\\<^esub>\n                                  (g \\<upharpoonleft> \\<Gamma> / f)", "assume \"x \\<in> A ?\\<Gamma>\" \"y \\<in> B ?\\<Gamma>\" and p: \"path ?\\<Gamma> x p y\""], ["proof (state)\nthis:\n  x \\<in> A (quotient_web \\<Gamma> f)\n  y \\<in> B (quotient_web \\<Gamma> f)\n  path (quotient_web \\<Gamma> f) x p y\n\ngoal (1 subgoal):\n 1. \\<And>x y p.\n       \\<lbrakk>x \\<in> A (quotient_web \\<Gamma> f);\n        y \\<in> B (quotient_web \\<Gamma> f);\n        path (quotient_web \\<Gamma> f) x p y\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>z\\<in>set p.\n                             z \\<in> TER\\<^bsub>quotient_web \\<Gamma> f\\<^esub>\n(g \\<upharpoonleft> \\<Gamma> / f)) \\<or>\n                         x \\<in> TER\\<^bsub>quotient_web \\<Gamma> f\\<^esub>\n                                  (g \\<upharpoonleft> \\<Gamma> / f)", "hence x: \"x \\<in> \\<E> (TER f)\" and y: \"y \\<in> B \\<Gamma>\" and SAT: \"x \\<in> SAT ?\\<Gamma> ?g\""], ["proof (prove)\nusing this:\n  x \\<in> A (quotient_web \\<Gamma> f)\n  y \\<in> B (quotient_web \\<Gamma> f)\n  path (quotient_web \\<Gamma> f) x p y\n\ngoal (1 subgoal):\n 1. x \\<in> \\<E> (TER f) &&&\n    y \\<in> B \\<Gamma> &&&\n    x \\<in> SAT (quotient_web \\<Gamma> f) (g \\<upharpoonleft> \\<Gamma> / f)", "by(simp_all add: SAT.A)"], ["proof (state)\nthis:\n  x \\<in> \\<E> (TER f)\n  y \\<in> B \\<Gamma>\n  x \\<in> SAT (quotient_web \\<Gamma> f) (g \\<upharpoonleft> \\<Gamma> / f)\n\ngoal (1 subgoal):\n 1. \\<And>x y p.\n       \\<lbrakk>x \\<in> A (quotient_web \\<Gamma> f);\n        y \\<in> B (quotient_web \\<Gamma> f);\n        path (quotient_web \\<Gamma> f) x p y\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>z\\<in>set p.\n                             z \\<in> TER\\<^bsub>quotient_web \\<Gamma> f\\<^esub>\n(g \\<upharpoonleft> \\<Gamma> / f)) \\<or>\n                         x \\<in> TER\\<^bsub>quotient_web \\<Gamma> f\\<^esub>\n                                  (g \\<upharpoonleft> \\<Gamma> / f)", "from p"], ["proof (chain)\npicking this:\n  path (quotient_web \\<Gamma> f) x p y", "have p': \"path \\<Gamma> x p y\""], ["proof (prove)\nusing this:\n  path (quotient_web \\<Gamma> f) x p y\n\ngoal (1 subgoal):\n 1. path \\<Gamma> x p y", "by(rule rtrancl_path_mono) simp"], ["proof (state)\nthis:\n  path \\<Gamma> x p y\n\ngoal (1 subgoal):\n 1. \\<And>x y p.\n       \\<lbrakk>x \\<in> A (quotient_web \\<Gamma> f);\n        y \\<in> B (quotient_web \\<Gamma> f);\n        path (quotient_web \\<Gamma> f) x p y\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>z\\<in>set p.\n                             z \\<in> TER\\<^bsub>quotient_web \\<Gamma> f\\<^esub>\n(g \\<upharpoonleft> \\<Gamma> / f)) \\<or>\n                         x \\<in> TER\\<^bsub>quotient_web \\<Gamma> f\\<^esub>\n                                  (g \\<upharpoonleft> \\<Gamma> / f)", "{"], ["proof (state)\nthis:\n  path \\<Gamma> x p y\n\ngoal (1 subgoal):\n 1. \\<And>x y p.\n       \\<lbrakk>x \\<in> A (quotient_web \\<Gamma> f);\n        y \\<in> B (quotient_web \\<Gamma> f);\n        path (quotient_web \\<Gamma> f) x p y\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>z\\<in>set p.\n                             z \\<in> TER\\<^bsub>quotient_web \\<Gamma> f\\<^esub>\n(g \\<upharpoonleft> \\<Gamma> / f)) \\<or>\n                         x \\<in> TER\\<^bsub>quotient_web \\<Gamma> f\\<^esub>\n                                  (g \\<upharpoonleft> \\<Gamma> / f)", "assume \"x \\<notin> ?TER\""], ["proof (state)\nthis:\n  x \\<notin> TER\\<^bsub>quotient_web \\<Gamma> f\\<^esub>\n              (g \\<upharpoonleft> \\<Gamma> / f)\n\ngoal (1 subgoal):\n 1. \\<And>x y p.\n       \\<lbrakk>x \\<in> A (quotient_web \\<Gamma> f);\n        y \\<in> B (quotient_web \\<Gamma> f);\n        path (quotient_web \\<Gamma> f) x p y\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>z\\<in>set p.\n                             z \\<in> TER\\<^bsub>quotient_web \\<Gamma> f\\<^esub>\n(g \\<upharpoonleft> \\<Gamma> / f)) \\<or>\n                         x \\<in> TER\\<^bsub>quotient_web \\<Gamma> f\\<^esub>\n                                  (g \\<upharpoonleft> \\<Gamma> / f)", "hence \"x \\<notin> SINK ?g\""], ["proof (prove)\nusing this:\n  x \\<notin> TER\\<^bsub>quotient_web \\<Gamma> f\\<^esub>\n              (g \\<upharpoonleft> \\<Gamma> / f)\n\ngoal (1 subgoal):\n 1. x \\<notin> SINK (g \\<upharpoonleft> \\<Gamma> / f)", "using SAT"], ["proof (prove)\nusing this:\n  x \\<notin> TER\\<^bsub>quotient_web \\<Gamma> f\\<^esub>\n              (g \\<upharpoonleft> \\<Gamma> / f)\n  x \\<in> SAT (quotient_web \\<Gamma> f) (g \\<upharpoonleft> \\<Gamma> / f)\n\ngoal (1 subgoal):\n 1. x \\<notin> SINK (g \\<upharpoonleft> \\<Gamma> / f)", "by(simp)"], ["proof (state)\nthis:\n  x \\<notin> SINK (g \\<upharpoonleft> \\<Gamma> / f)\n\ngoal (1 subgoal):\n 1. \\<And>x y p.\n       \\<lbrakk>x \\<in> A (quotient_web \\<Gamma> f);\n        y \\<in> B (quotient_web \\<Gamma> f);\n        path (quotient_web \\<Gamma> f) x p y\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>z\\<in>set p.\n                             z \\<in> TER\\<^bsub>quotient_web \\<Gamma> f\\<^esub>\n(g \\<upharpoonleft> \\<Gamma> / f)) \\<or>\n                         x \\<in> TER\\<^bsub>quotient_web \\<Gamma> f\\<^esub>\n                                  (g \\<upharpoonleft> \\<Gamma> / f)", "hence \"x \\<notin> SINK g\""], ["proof (prove)\nusing this:\n  x \\<notin> SINK (g \\<upharpoonleft> \\<Gamma> / f)\n\ngoal (1 subgoal):\n 1. x \\<notin> SINK g", "using d_OUT_restrict_current_le[of \\<Gamma> f g x]"], ["proof (prove)\nusing this:\n  x \\<notin> SINK (g \\<upharpoonleft> \\<Gamma> / f)\n  d_OUT (g \\<upharpoonleft> \\<Gamma> / f) x \\<le> d_OUT g x\n\ngoal (1 subgoal):\n 1. x \\<notin> SINK g", "by(auto simp add: SINK.simps)"], ["proof (state)\nthis:\n  x \\<notin> SINK g\n\ngoal (1 subgoal):\n 1. \\<And>x y p.\n       \\<lbrakk>x \\<in> A (quotient_web \\<Gamma> f);\n        y \\<in> B (quotient_web \\<Gamma> f);\n        path (quotient_web \\<Gamma> f) x p y\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>z\\<in>set p.\n                             z \\<in> TER\\<^bsub>quotient_web \\<Gamma> f\\<^esub>\n(g \\<upharpoonleft> \\<Gamma> / f)) \\<or>\n                         x \\<in> TER\\<^bsub>quotient_web \\<Gamma> f\\<^esub>\n                                  (g \\<upharpoonleft> \\<Gamma> / f)", "hence \"x \\<in> RF (TER g)\""], ["proof (prove)\nusing this:\n  x \\<notin> SINK g\n\ngoal (1 subgoal):\n 1. x \\<in> RF (TER g)", "using waveD_OUT[OF w']"], ["proof (prove)\nusing this:\n  x \\<notin> SINK g\n  ?x \\<notin> RF (TER g) \\<Longrightarrow> d_OUT g ?x = 0\n\ngoal (1 subgoal):\n 1. x \\<in> RF (TER g)", "by(auto simp add: SINK.simps)"], ["proof (state)\nthis:\n  x \\<in> RF (TER g)\n\ngoal (1 subgoal):\n 1. \\<And>x y p.\n       \\<lbrakk>x \\<in> A (quotient_web \\<Gamma> f);\n        y \\<in> B (quotient_web \\<Gamma> f);\n        path (quotient_web \\<Gamma> f) x p y\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>z\\<in>set p.\n                             z \\<in> TER\\<^bsub>quotient_web \\<Gamma> f\\<^esub>\n(g \\<upharpoonleft> \\<Gamma> / f)) \\<or>\n                         x \\<in> TER\\<^bsub>quotient_web \\<Gamma> f\\<^esub>\n                                  (g \\<upharpoonleft> \\<Gamma> / f)", "from roofedD[OF this p' y] \\<open>x \\<notin> SINK g\\<close>"], ["proof (chain)\npicking this:\n  (\\<exists>z\\<in>set p. z \\<in> TER g) \\<or> x \\<in> TER g\n  x \\<notin> SINK g", "have \"(\\<exists>z\\<in>set p. z \\<in> ?TER)\""], ["proof (prove)\nusing this:\n  (\\<exists>z\\<in>set p. z \\<in> TER g) \\<or> x \\<in> TER g\n  x \\<notin> SINK g\n\ngoal (1 subgoal):\n 1. \\<exists>z\\<in>set p.\n       z \\<in> TER\\<^bsub>quotient_web \\<Gamma> f\\<^esub>\n                (g \\<upharpoonleft> \\<Gamma> / f)", "using TER_restrict_current[OF f w g]"], ["proof (prove)\nusing this:\n  (\\<exists>z\\<in>set p. z \\<in> TER g) \\<or> x \\<in> TER g\n  x \\<notin> SINK g\n  TER g\n  \\<subseteq> TER\\<^bsub>quotient_web \\<Gamma> f\\<^esub>\n               (g \\<upharpoonleft> \\<Gamma> / f)\n\ngoal (1 subgoal):\n 1. \\<exists>z\\<in>set p.\n       z \\<in> TER\\<^bsub>quotient_web \\<Gamma> f\\<^esub>\n                (g \\<upharpoonleft> \\<Gamma> / f)", "by blast"], ["proof (state)\nthis:\n  \\<exists>z\\<in>set p.\n     z \\<in> TER\\<^bsub>quotient_web \\<Gamma> f\\<^esub>\n              (g \\<upharpoonleft> \\<Gamma> / f)\n\ngoal (1 subgoal):\n 1. \\<And>x y p.\n       \\<lbrakk>x \\<in> A (quotient_web \\<Gamma> f);\n        y \\<in> B (quotient_web \\<Gamma> f);\n        path (quotient_web \\<Gamma> f) x p y\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>z\\<in>set p.\n                             z \\<in> TER\\<^bsub>quotient_web \\<Gamma> f\\<^esub>\n(g \\<upharpoonleft> \\<Gamma> / f)) \\<or>\n                         x \\<in> TER\\<^bsub>quotient_web \\<Gamma> f\\<^esub>\n                                  (g \\<upharpoonleft> \\<Gamma> / f)", "}"], ["proof (state)\nthis:\n  x \\<notin> TER\\<^bsub>quotient_web \\<Gamma> f\\<^esub>\n              (g \\<upharpoonleft> \\<Gamma> / f) \\<Longrightarrow>\n  \\<exists>z\\<in>set p.\n     z \\<in> TER\\<^bsub>quotient_web \\<Gamma> f\\<^esub>\n              (g \\<upharpoonleft> \\<Gamma> / f)\n\ngoal (1 subgoal):\n 1. \\<And>x y p.\n       \\<lbrakk>x \\<in> A (quotient_web \\<Gamma> f);\n        y \\<in> B (quotient_web \\<Gamma> f);\n        path (quotient_web \\<Gamma> f) x p y\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>z\\<in>set p.\n                             z \\<in> TER\\<^bsub>quotient_web \\<Gamma> f\\<^esub>\n(g \\<upharpoonleft> \\<Gamma> / f)) \\<or>\n                         x \\<in> TER\\<^bsub>quotient_web \\<Gamma> f\\<^esub>\n                                  (g \\<upharpoonleft> \\<Gamma> / f)", "then"], ["proof (chain)\npicking this:\n  x \\<notin> TER\\<^bsub>quotient_web \\<Gamma> f\\<^esub>\n              (g \\<upharpoonleft> \\<Gamma> / f) \\<Longrightarrow>\n  \\<exists>z\\<in>set p.\n     z \\<in> TER\\<^bsub>quotient_web \\<Gamma> f\\<^esub>\n              (g \\<upharpoonleft> \\<Gamma> / f)", "show \"(\\<exists>z\\<in>set p. z \\<in> ?TER) \\<or> x \\<in> ?TER\""], ["proof (prove)\nusing this:\n  x \\<notin> TER\\<^bsub>quotient_web \\<Gamma> f\\<^esub>\n              (g \\<upharpoonleft> \\<Gamma> / f) \\<Longrightarrow>\n  \\<exists>z\\<in>set p.\n     z \\<in> TER\\<^bsub>quotient_web \\<Gamma> f\\<^esub>\n              (g \\<upharpoonleft> \\<Gamma> / f)\n\ngoal (1 subgoal):\n 1. (\\<exists>z\\<in>set p.\n        z \\<in> TER\\<^bsub>quotient_web \\<Gamma> f\\<^esub>\n                 (g \\<upharpoonleft> \\<Gamma> / f)) \\<or>\n    x \\<in> TER\\<^bsub>quotient_web \\<Gamma> f\\<^esub>\n             (g \\<upharpoonleft> \\<Gamma> / f)", "by blast"], ["proof (state)\nthis:\n  (\\<exists>z\\<in>set p.\n      z \\<in> TER\\<^bsub>quotient_web \\<Gamma> f\\<^esub>\n               (g \\<upharpoonleft> \\<Gamma> / f)) \\<or>\n  x \\<in> TER\\<^bsub>quotient_web \\<Gamma> f\\<^esub>\n           (g \\<upharpoonleft> \\<Gamma> / f)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  separating (quotient_web \\<Gamma> f)\n   (TER\\<^bsub>quotient_web \\<Gamma> f\\<^esub>\n     (g \\<upharpoonleft> \\<Gamma> / f))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<notin> RF\\<^bsub>quotient_web \\<Gamma> f\\<^esub>\n                   (TER\\<^bsub>quotient_web \\<Gamma> f\\<^esub>\n                     (g \\<upharpoonleft> \\<Gamma> / f)) \\<Longrightarrow>\n       d_OUT (g \\<upharpoonleft> \\<Gamma> / f) x = 0", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<notin> RF\\<^bsub>quotient_web \\<Gamma> f\\<^esub>\n                   (TER\\<^bsub>quotient_web \\<Gamma> f\\<^esub>\n                     (g \\<upharpoonleft> \\<Gamma> / f)) \\<Longrightarrow>\n       d_OUT (g \\<upharpoonleft> \\<Gamma> / f) x = 0", "assume \"x \\<notin> RF\\<^bsub>?\\<Gamma>\\<^esub> ?TER\""], ["proof (state)\nthis:\n  x \\<notin> RF\\<^bsub>quotient_web \\<Gamma> f\\<^esub>\n              (TER\\<^bsub>quotient_web \\<Gamma> f\\<^esub>\n                (g \\<upharpoonleft> \\<Gamma> / f))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<notin> RF\\<^bsub>quotient_web \\<Gamma> f\\<^esub>\n                   (TER\\<^bsub>quotient_web \\<Gamma> f\\<^esub>\n                     (g \\<upharpoonleft> \\<Gamma> / f)) \\<Longrightarrow>\n       d_OUT (g \\<upharpoonleft> \\<Gamma> / f) x = 0", "hence \"x \\<notin> RF (TER g)\""], ["proof (prove)\nusing this:\n  x \\<notin> RF\\<^bsub>quotient_web \\<Gamma> f\\<^esub>\n              (TER\\<^bsub>quotient_web \\<Gamma> f\\<^esub>\n                (g \\<upharpoonleft> \\<Gamma> / f))\n\ngoal (1 subgoal):\n 1. x \\<notin> RF (TER g)", "proof(rule contrapos_nn)"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<in> RF (TER g) \\<Longrightarrow>\n    x \\<in> RF\\<^bsub>quotient_web \\<Gamma> f\\<^esub>\n             (TER\\<^bsub>quotient_web \\<Gamma> f\\<^esub>\n               (g \\<upharpoonleft> \\<Gamma> / f))", "assume *: \"x \\<in> RF (TER g)\""], ["proof (state)\nthis:\n  x \\<in> RF (TER g)\n\ngoal (1 subgoal):\n 1. x \\<in> RF (TER g) \\<Longrightarrow>\n    x \\<in> RF\\<^bsub>quotient_web \\<Gamma> f\\<^esub>\n             (TER\\<^bsub>quotient_web \\<Gamma> f\\<^esub>\n               (g \\<upharpoonleft> \\<Gamma> / f))", "show \"x \\<in> RF\\<^bsub>?\\<Gamma>\\<^esub> ?TER\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> RF\\<^bsub>quotient_web \\<Gamma> f\\<^esub>\n             (TER\\<^bsub>quotient_web \\<Gamma> f\\<^esub>\n               (g \\<upharpoonleft> \\<Gamma> / f))", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p y.\n       \\<lbrakk>path (quotient_web \\<Gamma> f) x p y;\n        y \\<in> B (quotient_web \\<Gamma> f)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>z\\<in>set p.\n                             z \\<in> TER\\<^bsub>quotient_web \\<Gamma> f\\<^esub>\n(g \\<upharpoonleft> \\<Gamma> / f)) \\<or>\n                         x \\<in> TER\\<^bsub>quotient_web \\<Gamma> f\\<^esub>\n                                  (g \\<upharpoonleft> \\<Gamma> / f)", "fix p y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p y.\n       \\<lbrakk>path (quotient_web \\<Gamma> f) x p y;\n        y \\<in> B (quotient_web \\<Gamma> f)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>z\\<in>set p.\n                             z \\<in> TER\\<^bsub>quotient_web \\<Gamma> f\\<^esub>\n(g \\<upharpoonleft> \\<Gamma> / f)) \\<or>\n                         x \\<in> TER\\<^bsub>quotient_web \\<Gamma> f\\<^esub>\n                                  (g \\<upharpoonleft> \\<Gamma> / f)", "assume \"path ?\\<Gamma> x p y\" \"y \\<in> B ?\\<Gamma>\""], ["proof (state)\nthis:\n  path (quotient_web \\<Gamma> f) x p y\n  y \\<in> B (quotient_web \\<Gamma> f)\n\ngoal (1 subgoal):\n 1. \\<And>p y.\n       \\<lbrakk>path (quotient_web \\<Gamma> f) x p y;\n        y \\<in> B (quotient_web \\<Gamma> f)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>z\\<in>set p.\n                             z \\<in> TER\\<^bsub>quotient_web \\<Gamma> f\\<^esub>\n(g \\<upharpoonleft> \\<Gamma> / f)) \\<or>\n                         x \\<in> TER\\<^bsub>quotient_web \\<Gamma> f\\<^esub>\n                                  (g \\<upharpoonleft> \\<Gamma> / f)", "hence \"path \\<Gamma> x p y\" \"y \\<in> B \\<Gamma>\""], ["proof (prove)\nusing this:\n  path (quotient_web \\<Gamma> f) x p y\n  y \\<in> B (quotient_web \\<Gamma> f)\n\ngoal (1 subgoal):\n 1. path \\<Gamma> x p y &&& y \\<in> B \\<Gamma>", "by(auto elim: rtrancl_path_mono)"], ["proof (state)\nthis:\n  path \\<Gamma> x p y\n  y \\<in> B \\<Gamma>\n\ngoal (1 subgoal):\n 1. \\<And>p y.\n       \\<lbrakk>path (quotient_web \\<Gamma> f) x p y;\n        y \\<in> B (quotient_web \\<Gamma> f)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>z\\<in>set p.\n                             z \\<in> TER\\<^bsub>quotient_web \\<Gamma> f\\<^esub>\n(g \\<upharpoonleft> \\<Gamma> / f)) \\<or>\n                         x \\<in> TER\\<^bsub>quotient_web \\<Gamma> f\\<^esub>\n                                  (g \\<upharpoonleft> \\<Gamma> / f)", "from roofedD[OF * this]"], ["proof (chain)\npicking this:\n  (\\<exists>z\\<in>set p. z \\<in> TER g) \\<or> x \\<in> TER g", "show \"(\\<exists>z\\<in>set p. z \\<in> ?TER) \\<or> x \\<in> ?TER\""], ["proof (prove)\nusing this:\n  (\\<exists>z\\<in>set p. z \\<in> TER g) \\<or> x \\<in> TER g\n\ngoal (1 subgoal):\n 1. (\\<exists>z\\<in>set p.\n        z \\<in> TER\\<^bsub>quotient_web \\<Gamma> f\\<^esub>\n                 (g \\<upharpoonleft> \\<Gamma> / f)) \\<or>\n    x \\<in> TER\\<^bsub>quotient_web \\<Gamma> f\\<^esub>\n             (g \\<upharpoonleft> \\<Gamma> / f)", "using TER_restrict_current[OF f w g]"], ["proof (prove)\nusing this:\n  (\\<exists>z\\<in>set p. z \\<in> TER g) \\<or> x \\<in> TER g\n  TER g\n  \\<subseteq> TER\\<^bsub>quotient_web \\<Gamma> f\\<^esub>\n               (g \\<upharpoonleft> \\<Gamma> / f)\n\ngoal (1 subgoal):\n 1. (\\<exists>z\\<in>set p.\n        z \\<in> TER\\<^bsub>quotient_web \\<Gamma> f\\<^esub>\n                 (g \\<upharpoonleft> \\<Gamma> / f)) \\<or>\n    x \\<in> TER\\<^bsub>quotient_web \\<Gamma> f\\<^esub>\n             (g \\<upharpoonleft> \\<Gamma> / f)", "by blast"], ["proof (state)\nthis:\n  (\\<exists>z\\<in>set p.\n      z \\<in> TER\\<^bsub>quotient_web \\<Gamma> f\\<^esub>\n               (g \\<upharpoonleft> \\<Gamma> / f)) \\<or>\n  x \\<in> TER\\<^bsub>quotient_web \\<Gamma> f\\<^esub>\n           (g \\<upharpoonleft> \\<Gamma> / f)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x \\<in> RF\\<^bsub>quotient_web \\<Gamma> f\\<^esub>\n           (TER\\<^bsub>quotient_web \\<Gamma> f\\<^esub>\n             (g \\<upharpoonleft> \\<Gamma> / f))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x \\<notin> RF (TER g)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<notin> RF\\<^bsub>quotient_web \\<Gamma> f\\<^esub>\n                   (TER\\<^bsub>quotient_web \\<Gamma> f\\<^esub>\n                     (g \\<upharpoonleft> \\<Gamma> / f)) \\<Longrightarrow>\n       d_OUT (g \\<upharpoonleft> \\<Gamma> / f) x = 0", "with w'"], ["proof (chain)\npicking this:\n  wave \\<Gamma> g\n  x \\<notin> RF (TER g)", "have \"d_OUT g x = 0\""], ["proof (prove)\nusing this:\n  wave \\<Gamma> g\n  x \\<notin> RF (TER g)\n\ngoal (1 subgoal):\n 1. d_OUT g x = 0", "by(rule waveD_OUT)"], ["proof (state)\nthis:\n  d_OUT g x = 0\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<notin> RF\\<^bsub>quotient_web \\<Gamma> f\\<^esub>\n                   (TER\\<^bsub>quotient_web \\<Gamma> f\\<^esub>\n                     (g \\<upharpoonleft> \\<Gamma> / f)) \\<Longrightarrow>\n       d_OUT (g \\<upharpoonleft> \\<Gamma> / f) x = 0", "with d_OUT_restrict_current_le[of \\<Gamma> f g x]"], ["proof (chain)\npicking this:\n  d_OUT (g \\<upharpoonleft> \\<Gamma> / f) x \\<le> d_OUT g x\n  d_OUT g x = 0", "show \"d_OUT ?g x = 0\""], ["proof (prove)\nusing this:\n  d_OUT (g \\<upharpoonleft> \\<Gamma> / f) x \\<le> d_OUT g x\n  d_OUT g x = 0\n\ngoal (1 subgoal):\n 1. d_OUT (g \\<upharpoonleft> \\<Gamma> / f) x = 0", "by simp"], ["proof (state)\nthis:\n  d_OUT (g \\<upharpoonleft> \\<Gamma> / f) x = 0\n\ngoal:\nNo subgoals!", "qed"], ["", "definition plus_current :: \"'v current \\<Rightarrow> 'v current \\<Rightarrow> 'v current\"\nwhere \"plus_current f g = (\\<lambda>e. f e + g e)\""], ["", "lemma plus_current_simps [simp]: \"plus_current f g e = f e + g e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. plus_current f g e = f e + g e", "by(simp add: plus_current_def)"], ["", "lemma plus_zero_current [simp]: \"plus_current f zero_current = f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. plus_current f (\\<lambda>_. 0) = f", "by(simp add: fun_eq_iff)"], ["", "lemma support_flow_plus_current: \"support_flow (plus_current f g) \\<subseteq> support_flow f \\<union> support_flow g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. support_flow (plus_current f g)\n    \\<subseteq> support_flow f \\<union> support_flow g", "by(clarsimp simp add: support_flow.simps)"], ["", "context\n  fixes \\<Gamma> :: \"('v, 'more) web_scheme\" (structure) and f g\n  assumes f: \"current \\<Gamma> f\"\n  and w: \"wave \\<Gamma> f\"\n  and g: \"current (quotient_web \\<Gamma> f) g\"\nbegin"], ["", "lemma OUT_plus_current: \"d_OUT (plus_current f g) x = (if x \\<in> RF\\<^sup>\\<circ> (TER f) then d_OUT f x else d_OUT g x)\" (is \"d_OUT ?g _ = _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT (plus_current f g) x =\n    (if x \\<in> RF\\<^sup>\\<circ> (TER f) then d_OUT f x else d_OUT g x)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. d_OUT (plus_current f g) x =\n    (if x \\<in> RF\\<^sup>\\<circ> (TER f) then d_OUT f x else d_OUT g x)", "have \"d_OUT ?g x = d_OUT f x + d_OUT g x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT (plus_current f g) x = d_OUT f x + d_OUT g x", "unfolding plus_current_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT (\\<lambda>e. f e + g e) x = d_OUT f x + d_OUT g x", "by(subst d_OUT_add) simp_all"], ["proof (state)\nthis:\n  d_OUT (plus_current f g) x = d_OUT f x + d_OUT g x\n\ngoal (1 subgoal):\n 1. d_OUT (plus_current f g) x =\n    (if x \\<in> RF\\<^sup>\\<circ> (TER f) then d_OUT f x else d_OUT g x)", "also"], ["proof (state)\nthis:\n  d_OUT (plus_current f g) x = d_OUT f x + d_OUT g x\n\ngoal (1 subgoal):\n 1. d_OUT (plus_current f g) x =\n    (if x \\<in> RF\\<^sup>\\<circ> (TER f) then d_OUT f x else d_OUT g x)", "have \"\\<dots> = (if x \\<in> RF\\<^sup>\\<circ> (TER f) then d_OUT f x else d_OUT g x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT f x + d_OUT g x =\n    (if x \\<in> RF\\<^sup>\\<circ> (TER f) then d_OUT f x else d_OUT g x)", "proof(cases \"x \\<in> RF\\<^sup>\\<circ> (TER f)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<in> RF\\<^sup>\\<circ> (TER f) \\<Longrightarrow>\n    d_OUT f x + d_OUT g x =\n    (if x \\<in> RF\\<^sup>\\<circ> (TER f) then d_OUT f x else d_OUT g x)\n 2. x \\<notin> RF\\<^sup>\\<circ> (TER f) \\<Longrightarrow>\n    d_OUT f x + d_OUT g x =\n    (if x \\<in> RF\\<^sup>\\<circ> (TER f) then d_OUT f x else d_OUT g x)", "case True"], ["proof (state)\nthis:\n  x \\<in> RF\\<^sup>\\<circ> (TER f)\n\ngoal (2 subgoals):\n 1. x \\<in> RF\\<^sup>\\<circ> (TER f) \\<Longrightarrow>\n    d_OUT f x + d_OUT g x =\n    (if x \\<in> RF\\<^sup>\\<circ> (TER f) then d_OUT f x else d_OUT g x)\n 2. x \\<notin> RF\\<^sup>\\<circ> (TER f) \\<Longrightarrow>\n    d_OUT f x + d_OUT g x =\n    (if x \\<in> RF\\<^sup>\\<circ> (TER f) then d_OUT f x else d_OUT g x)", "hence \"d_OUT g x = 0\""], ["proof (prove)\nusing this:\n  x \\<in> RF\\<^sup>\\<circ> (TER f)\n\ngoal (1 subgoal):\n 1. d_OUT g x = 0", "by(intro currentD_outside_OUT[OF g])(auto dest: vertex_quotient_webD)"], ["proof (state)\nthis:\n  d_OUT g x = 0\n\ngoal (2 subgoals):\n 1. x \\<in> RF\\<^sup>\\<circ> (TER f) \\<Longrightarrow>\n    d_OUT f x + d_OUT g x =\n    (if x \\<in> RF\\<^sup>\\<circ> (TER f) then d_OUT f x else d_OUT g x)\n 2. x \\<notin> RF\\<^sup>\\<circ> (TER f) \\<Longrightarrow>\n    d_OUT f x + d_OUT g x =\n    (if x \\<in> RF\\<^sup>\\<circ> (TER f) then d_OUT f x else d_OUT g x)", "thus ?thesis"], ["proof (prove)\nusing this:\n  d_OUT g x = 0\n\ngoal (1 subgoal):\n 1. d_OUT f x + d_OUT g x =\n    (if x \\<in> RF\\<^sup>\\<circ> (TER f) then d_OUT f x else d_OUT g x)", "using True"], ["proof (prove)\nusing this:\n  d_OUT g x = 0\n  x \\<in> RF\\<^sup>\\<circ> (TER f)\n\ngoal (1 subgoal):\n 1. d_OUT f x + d_OUT g x =\n    (if x \\<in> RF\\<^sup>\\<circ> (TER f) then d_OUT f x else d_OUT g x)", "by simp"], ["proof (state)\nthis:\n  d_OUT f x + d_OUT g x =\n  (if x \\<in> RF\\<^sup>\\<circ> (TER f) then d_OUT f x else d_OUT g x)\n\ngoal (1 subgoal):\n 1. x \\<notin> RF\\<^sup>\\<circ> (TER f) \\<Longrightarrow>\n    d_OUT f x + d_OUT g x =\n    (if x \\<in> RF\\<^sup>\\<circ> (TER f) then d_OUT f x else d_OUT g x)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<notin> RF\\<^sup>\\<circ> (TER f) \\<Longrightarrow>\n    d_OUT f x + d_OUT g x =\n    (if x \\<in> RF\\<^sup>\\<circ> (TER f) then d_OUT f x else d_OUT g x)", "case False"], ["proof (state)\nthis:\n  x \\<notin> RF\\<^sup>\\<circ> (TER f)\n\ngoal (1 subgoal):\n 1. x \\<notin> RF\\<^sup>\\<circ> (TER f) \\<Longrightarrow>\n    d_OUT f x + d_OUT g x =\n    (if x \\<in> RF\\<^sup>\\<circ> (TER f) then d_OUT f x else d_OUT g x)", "hence \"d_OUT f x = 0\""], ["proof (prove)\nusing this:\n  x \\<notin> RF\\<^sup>\\<circ> (TER f)\n\ngoal (1 subgoal):\n 1. d_OUT f x = 0", "by(auto simp add: roofed_circ_def SINK.simps dest: waveD_OUT[OF w])"], ["proof (state)\nthis:\n  d_OUT f x = 0\n\ngoal (1 subgoal):\n 1. x \\<notin> RF\\<^sup>\\<circ> (TER f) \\<Longrightarrow>\n    d_OUT f x + d_OUT g x =\n    (if x \\<in> RF\\<^sup>\\<circ> (TER f) then d_OUT f x else d_OUT g x)", "with False"], ["proof (chain)\npicking this:\n  x \\<notin> RF\\<^sup>\\<circ> (TER f)\n  d_OUT f x = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  x \\<notin> RF\\<^sup>\\<circ> (TER f)\n  d_OUT f x = 0\n\ngoal (1 subgoal):\n 1. d_OUT f x + d_OUT g x =\n    (if x \\<in> RF\\<^sup>\\<circ> (TER f) then d_OUT f x else d_OUT g x)", "by simp"], ["proof (state)\nthis:\n  d_OUT f x + d_OUT g x =\n  (if x \\<in> RF\\<^sup>\\<circ> (TER f) then d_OUT f x else d_OUT g x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  d_OUT f x + d_OUT g x =\n  (if x \\<in> RF\\<^sup>\\<circ> (TER f) then d_OUT f x else d_OUT g x)\n\ngoal (1 subgoal):\n 1. d_OUT (plus_current f g) x =\n    (if x \\<in> RF\\<^sup>\\<circ> (TER f) then d_OUT f x else d_OUT g x)", "finally"], ["proof (chain)\npicking this:\n  d_OUT (plus_current f g) x =\n  (if x \\<in> RF\\<^sup>\\<circ> (TER f) then d_OUT f x else d_OUT g x)", "show ?thesis"], ["proof (prove)\nusing this:\n  d_OUT (plus_current f g) x =\n  (if x \\<in> RF\\<^sup>\\<circ> (TER f) then d_OUT f x else d_OUT g x)\n\ngoal (1 subgoal):\n 1. d_OUT (plus_current f g) x =\n    (if x \\<in> RF\\<^sup>\\<circ> (TER f) then d_OUT f x else d_OUT g x)", "."], ["proof (state)\nthis:\n  d_OUT (plus_current f g) x =\n  (if x \\<in> RF\\<^sup>\\<circ> (TER f) then d_OUT f x else d_OUT g x)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma IN_plus_current: \"d_IN (plus_current f g) x = (if x \\<in> RF (TER f) then d_IN f x else d_IN g x)\" (is \"d_IN ?g _ = _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN (plus_current f g) x =\n    (if x \\<in> RF (TER f) then d_IN f x else d_IN g x)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. d_IN (plus_current f g) x =\n    (if x \\<in> RF (TER f) then d_IN f x else d_IN g x)", "have \"d_IN ?g x = d_IN f x + d_IN g x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN (plus_current f g) x = d_IN f x + d_IN g x", "unfolding plus_current_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN (\\<lambda>e. f e + g e) x = d_IN f x + d_IN g x", "by(subst d_IN_add) simp_all"], ["proof (state)\nthis:\n  d_IN (plus_current f g) x = d_IN f x + d_IN g x\n\ngoal (1 subgoal):\n 1. d_IN (plus_current f g) x =\n    (if x \\<in> RF (TER f) then d_IN f x else d_IN g x)", "also"], ["proof (state)\nthis:\n  d_IN (plus_current f g) x = d_IN f x + d_IN g x\n\ngoal (1 subgoal):\n 1. d_IN (plus_current f g) x =\n    (if x \\<in> RF (TER f) then d_IN f x else d_IN g x)", "consider (RF) \"x \\<in> RF (TER f) - (B \\<Gamma> - A \\<Gamma>)\" | (B) \"x \\<in> RF (TER f)\" \"x \\<in> B \\<Gamma> - A \\<Gamma>\" | (beyond) \"x \\<notin> RF (TER f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> RF (TER f) -\n                     (B \\<Gamma> - A \\<Gamma>) \\<Longrightarrow>\n             thesis;\n     \\<lbrakk>x \\<in> RF (TER f); x \\<in> B \\<Gamma> - A \\<Gamma>\\<rbrakk>\n     \\<Longrightarrow> thesis;\n     x \\<notin> RF (TER f) \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by blast"], ["proof (state)\nthis:\n  \\<lbrakk>x \\<in> RF (TER f) - (B \\<Gamma> - A \\<Gamma>) \\<Longrightarrow>\n           ?thesis;\n   \\<lbrakk>x \\<in> RF (TER f); x \\<in> B \\<Gamma> - A \\<Gamma>\\<rbrakk>\n   \\<Longrightarrow> ?thesis;\n   x \\<notin> RF (TER f) \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. d_IN (plus_current f g) x =\n    (if x \\<in> RF (TER f) then d_IN f x else d_IN g x)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>x \\<in> RF (TER f) - (B \\<Gamma> - A \\<Gamma>) \\<Longrightarrow>\n           ?thesis;\n   \\<lbrakk>x \\<in> RF (TER f); x \\<in> B \\<Gamma> - A \\<Gamma>\\<rbrakk>\n   \\<Longrightarrow> ?thesis;\n   x \\<notin> RF (TER f) \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis", "have \"d_IN f x + d_IN g x = (if x \\<in> RF (TER f) then d_IN f x else d_IN g x)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>x \\<in> RF (TER f) - (B \\<Gamma> - A \\<Gamma>) \\<Longrightarrow>\n           ?thesis;\n   \\<lbrakk>x \\<in> RF (TER f); x \\<in> B \\<Gamma> - A \\<Gamma>\\<rbrakk>\n   \\<Longrightarrow> ?thesis;\n   x \\<notin> RF (TER f) \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. d_IN f x + d_IN g x =\n    (if x \\<in> RF (TER f) then d_IN f x else d_IN g x)", "proof(cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. x \\<in> RF (TER f) - (B \\<Gamma> - A \\<Gamma>) \\<Longrightarrow>\n    d_IN f x + d_IN g x =\n    (if x \\<in> RF (TER f) then d_IN f x else d_IN g x)\n 2. \\<lbrakk>x \\<in> RF (TER f); x \\<in> B \\<Gamma> - A \\<Gamma>\\<rbrakk>\n    \\<Longrightarrow> d_IN f x + d_IN g x =\n                      (if x \\<in> RF (TER f) then d_IN f x else d_IN g x)\n 3. x \\<notin> RF (TER f) \\<Longrightarrow>\n    d_IN f x + d_IN g x =\n    (if x \\<in> RF (TER f) then d_IN f x else d_IN g x)", "case RF"], ["proof (state)\nthis:\n  x \\<in> RF (TER f) - (B \\<Gamma> - A \\<Gamma>)\n\ngoal (3 subgoals):\n 1. x \\<in> RF (TER f) - (B \\<Gamma> - A \\<Gamma>) \\<Longrightarrow>\n    d_IN f x + d_IN g x =\n    (if x \\<in> RF (TER f) then d_IN f x else d_IN g x)\n 2. \\<lbrakk>x \\<in> RF (TER f); x \\<in> B \\<Gamma> - A \\<Gamma>\\<rbrakk>\n    \\<Longrightarrow> d_IN f x + d_IN g x =\n                      (if x \\<in> RF (TER f) then d_IN f x else d_IN g x)\n 3. x \\<notin> RF (TER f) \\<Longrightarrow>\n    d_IN f x + d_IN g x =\n    (if x \\<in> RF (TER f) then d_IN f x else d_IN g x)", "hence \"d_IN g x = 0\""], ["proof (prove)\nusing this:\n  x \\<in> RF (TER f) - (B \\<Gamma> - A \\<Gamma>)\n\ngoal (1 subgoal):\n 1. d_IN g x = 0", "by(cases \"x \\<in> \\<E> (TER f)\")(auto intro: currentD_outside_IN[OF g] currentD_IN[OF g] dest!: vertex_quotient_webD simp add: roofed_circ_def)"], ["proof (state)\nthis:\n  d_IN g x = 0\n\ngoal (3 subgoals):\n 1. x \\<in> RF (TER f) - (B \\<Gamma> - A \\<Gamma>) \\<Longrightarrow>\n    d_IN f x + d_IN g x =\n    (if x \\<in> RF (TER f) then d_IN f x else d_IN g x)\n 2. \\<lbrakk>x \\<in> RF (TER f); x \\<in> B \\<Gamma> - A \\<Gamma>\\<rbrakk>\n    \\<Longrightarrow> d_IN f x + d_IN g x =\n                      (if x \\<in> RF (TER f) then d_IN f x else d_IN g x)\n 3. x \\<notin> RF (TER f) \\<Longrightarrow>\n    d_IN f x + d_IN g x =\n    (if x \\<in> RF (TER f) then d_IN f x else d_IN g x)", "thus ?thesis"], ["proof (prove)\nusing this:\n  d_IN g x = 0\n\ngoal (1 subgoal):\n 1. d_IN f x + d_IN g x =\n    (if x \\<in> RF (TER f) then d_IN f x else d_IN g x)", "using RF"], ["proof (prove)\nusing this:\n  d_IN g x = 0\n  x \\<in> RF (TER f) - (B \\<Gamma> - A \\<Gamma>)\n\ngoal (1 subgoal):\n 1. d_IN f x + d_IN g x =\n    (if x \\<in> RF (TER f) then d_IN f x else d_IN g x)", "by simp"], ["proof (state)\nthis:\n  d_IN f x + d_IN g x = (if x \\<in> RF (TER f) then d_IN f x else d_IN g x)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<in> RF (TER f); x \\<in> B \\<Gamma> - A \\<Gamma>\\<rbrakk>\n    \\<Longrightarrow> d_IN f x + d_IN g x =\n                      (if x \\<in> RF (TER f) then d_IN f x else d_IN g x)\n 2. x \\<notin> RF (TER f) \\<Longrightarrow>\n    d_IN f x + d_IN g x =\n    (if x \\<in> RF (TER f) then d_IN f x else d_IN g x)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<in> RF (TER f); x \\<in> B \\<Gamma> - A \\<Gamma>\\<rbrakk>\n    \\<Longrightarrow> d_IN f x + d_IN g x =\n                      (if x \\<in> RF (TER f) then d_IN f x else d_IN g x)\n 2. x \\<notin> RF (TER f) \\<Longrightarrow>\n    d_IN f x + d_IN g x =\n    (if x \\<in> RF (TER f) then d_IN f x else d_IN g x)", "case B"], ["proof (state)\nthis:\n  x \\<in> RF (TER f)\n  x \\<in> B \\<Gamma> - A \\<Gamma>\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<in> RF (TER f); x \\<in> B \\<Gamma> - A \\<Gamma>\\<rbrakk>\n    \\<Longrightarrow> d_IN f x + d_IN g x =\n                      (if x \\<in> RF (TER f) then d_IN f x else d_IN g x)\n 2. x \\<notin> RF (TER f) \\<Longrightarrow>\n    d_IN f x + d_IN g x =\n    (if x \\<in> RF (TER f) then d_IN f x else d_IN g x)", "hence \"d_IN g x = 0\""], ["proof (prove)\nusing this:\n  x \\<in> RF (TER f)\n  x \\<in> B \\<Gamma> - A \\<Gamma>\n\ngoal (1 subgoal):\n 1. d_IN g x = 0", "using currentD_outside_IN[OF g, of x] currentD_weight_IN[OF g, of x]"], ["proof (prove)\nusing this:\n  x \\<in> RF (TER f)\n  x \\<in> B \\<Gamma> - A \\<Gamma>\n  x \\<notin> \\<^bold>V\\<^bsub>quotient_web \\<Gamma> f\\<^esub> \\<Longrightarrow>\n  d_IN g x = 0\n  d_IN g x \\<le> weight (quotient_web \\<Gamma> f) x\n\ngoal (1 subgoal):\n 1. d_IN g x = 0", "by(auto dest: vertex_quotient_webD simp add: roofed_circ_def)"], ["proof (state)\nthis:\n  d_IN g x = 0\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<in> RF (TER f); x \\<in> B \\<Gamma> - A \\<Gamma>\\<rbrakk>\n    \\<Longrightarrow> d_IN f x + d_IN g x =\n                      (if x \\<in> RF (TER f) then d_IN f x else d_IN g x)\n 2. x \\<notin> RF (TER f) \\<Longrightarrow>\n    d_IN f x + d_IN g x =\n    (if x \\<in> RF (TER f) then d_IN f x else d_IN g x)", "with B"], ["proof (chain)\npicking this:\n  x \\<in> RF (TER f)\n  x \\<in> B \\<Gamma> - A \\<Gamma>\n  d_IN g x = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  x \\<in> RF (TER f)\n  x \\<in> B \\<Gamma> - A \\<Gamma>\n  d_IN g x = 0\n\ngoal (1 subgoal):\n 1. d_IN f x + d_IN g x =\n    (if x \\<in> RF (TER f) then d_IN f x else d_IN g x)", "by simp"], ["proof (state)\nthis:\n  d_IN f x + d_IN g x = (if x \\<in> RF (TER f) then d_IN f x else d_IN g x)\n\ngoal (1 subgoal):\n 1. x \\<notin> RF (TER f) \\<Longrightarrow>\n    d_IN f x + d_IN g x =\n    (if x \\<in> RF (TER f) then d_IN f x else d_IN g x)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<notin> RF (TER f) \\<Longrightarrow>\n    d_IN f x + d_IN g x =\n    (if x \\<in> RF (TER f) then d_IN f x else d_IN g x)", "case beyond"], ["proof (state)\nthis:\n  x \\<notin> RF (TER f)\n\ngoal (1 subgoal):\n 1. x \\<notin> RF (TER f) \\<Longrightarrow>\n    d_IN f x + d_IN g x =\n    (if x \\<in> RF (TER f) then d_IN f x else d_IN g x)", "from f w beyond"], ["proof (chain)\npicking this:\n  current \\<Gamma> f\n  wave \\<Gamma> f\n  x \\<notin> RF (TER f)", "have \"d_IN f x = 0\""], ["proof (prove)\nusing this:\n  current \\<Gamma> f\n  wave \\<Gamma> f\n  x \\<notin> RF (TER f)\n\ngoal (1 subgoal):\n 1. d_IN f x = 0", "by(rule wave_not_RF_IN_zero)"], ["proof (state)\nthis:\n  d_IN f x = 0\n\ngoal (1 subgoal):\n 1. x \\<notin> RF (TER f) \\<Longrightarrow>\n    d_IN f x + d_IN g x =\n    (if x \\<in> RF (TER f) then d_IN f x else d_IN g x)", "with beyond"], ["proof (chain)\npicking this:\n  x \\<notin> RF (TER f)\n  d_IN f x = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  x \\<notin> RF (TER f)\n  d_IN f x = 0\n\ngoal (1 subgoal):\n 1. d_IN f x + d_IN g x =\n    (if x \\<in> RF (TER f) then d_IN f x else d_IN g x)", "by simp"], ["proof (state)\nthis:\n  d_IN f x + d_IN g x = (if x \\<in> RF (TER f) then d_IN f x else d_IN g x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  d_IN f x + d_IN g x = (if x \\<in> RF (TER f) then d_IN f x else d_IN g x)\n\ngoal (1 subgoal):\n 1. d_IN (plus_current f g) x =\n    (if x \\<in> RF (TER f) then d_IN f x else d_IN g x)", "finally"], ["proof (chain)\npicking this:\n  d_IN (plus_current f g) x =\n  (if x \\<in> RF (TER f) then d_IN f x else d_IN g x)", "show ?thesis"], ["proof (prove)\nusing this:\n  d_IN (plus_current f g) x =\n  (if x \\<in> RF (TER f) then d_IN f x else d_IN g x)\n\ngoal (1 subgoal):\n 1. d_IN (plus_current f g) x =\n    (if x \\<in> RF (TER f) then d_IN f x else d_IN g x)", "."], ["proof (state)\nthis:\n  d_IN (plus_current f g) x =\n  (if x \\<in> RF (TER f) then d_IN f x else d_IN g x)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma in_TER_plus_current:\n  assumes RF: \"x \\<notin> RF\\<^sup>\\<circ> (TER f)\"\n  and x: \"x \\<in> TER\\<^bsub>quotient_web \\<Gamma> f\\<^esub> g\" (is \"_ \\<in> ?TER _\")\n  shows \"x \\<in> TER (plus_current f g)\"  (is \"_ \\<in> TER ?g\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> TER (plus_current f g)", "proof(cases \"x \\<in> \\<E> (TER f) - (B \\<Gamma> - A \\<Gamma>)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<in> \\<E> (TER f) - (B \\<Gamma> - A \\<Gamma>) \\<Longrightarrow>\n    x \\<in> TER (plus_current f g)\n 2. x \\<notin> \\<E> (TER f) - (B \\<Gamma> - A \\<Gamma>) \\<Longrightarrow>\n    x \\<in> TER (plus_current f g)", "case True"], ["proof (state)\nthis:\n  x \\<in> \\<E> (TER f) - (B \\<Gamma> - A \\<Gamma>)\n\ngoal (2 subgoals):\n 1. x \\<in> \\<E> (TER f) - (B \\<Gamma> - A \\<Gamma>) \\<Longrightarrow>\n    x \\<in> TER (plus_current f g)\n 2. x \\<notin> \\<E> (TER f) - (B \\<Gamma> - A \\<Gamma>) \\<Longrightarrow>\n    x \\<in> TER (plus_current f g)", "with x"], ["proof (chain)\npicking this:\n  x \\<in> TER\\<^bsub>quotient_web \\<Gamma> f\\<^esub> g\n  x \\<in> \\<E> (TER f) - (B \\<Gamma> - A \\<Gamma>)", "show ?thesis"], ["proof (prove)\nusing this:\n  x \\<in> TER\\<^bsub>quotient_web \\<Gamma> f\\<^esub> g\n  x \\<in> \\<E> (TER f) - (B \\<Gamma> - A \\<Gamma>)\n\ngoal (1 subgoal):\n 1. x \\<in> TER (plus_current f g)", "using currentD_IN[OF g, of x]"], ["proof (prove)\nusing this:\n  x \\<in> TER\\<^bsub>quotient_web \\<Gamma> f\\<^esub> g\n  x \\<in> \\<E> (TER f) - (B \\<Gamma> - A \\<Gamma>)\n  x \\<in> A (quotient_web \\<Gamma> f) \\<Longrightarrow> d_IN g x = 0\n\ngoal (1 subgoal):\n 1. x \\<in> TER (plus_current f g)", "by(fastforce intro: roofed_greaterI SAT.intros simp add: SINK.simps OUT_plus_current IN_plus_current elim!: SAT.cases)"], ["proof (state)\nthis:\n  x \\<in> TER (plus_current f g)\n\ngoal (1 subgoal):\n 1. x \\<notin> \\<E> (TER f) - (B \\<Gamma> - A \\<Gamma>) \\<Longrightarrow>\n    x \\<in> TER (plus_current f g)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<notin> \\<E> (TER f) - (B \\<Gamma> - A \\<Gamma>) \\<Longrightarrow>\n    x \\<in> TER (plus_current f g)", "case *: False"], ["proof (state)\nthis:\n  x \\<notin> \\<E> (TER f) - (B \\<Gamma> - A \\<Gamma>)\n\ngoal (1 subgoal):\n 1. x \\<notin> \\<E> (TER f) - (B \\<Gamma> - A \\<Gamma>) \\<Longrightarrow>\n    x \\<in> TER (plus_current f g)", "have \"x \\<in> SAT \\<Gamma> ?g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> SAT \\<Gamma> (plus_current f g)", "proof(cases \"x \\<in> B \\<Gamma> - A \\<Gamma>\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<in> B \\<Gamma> - A \\<Gamma> \\<Longrightarrow>\n    x \\<in> SAT \\<Gamma> (plus_current f g)\n 2. x \\<notin> B \\<Gamma> - A \\<Gamma> \\<Longrightarrow>\n    x \\<in> SAT \\<Gamma> (plus_current f g)", "case False"], ["proof (state)\nthis:\n  x \\<notin> B \\<Gamma> - A \\<Gamma>\n\ngoal (2 subgoals):\n 1. x \\<in> B \\<Gamma> - A \\<Gamma> \\<Longrightarrow>\n    x \\<in> SAT \\<Gamma> (plus_current f g)\n 2. x \\<notin> B \\<Gamma> - A \\<Gamma> \\<Longrightarrow>\n    x \\<in> SAT \\<Gamma> (plus_current f g)", "with x RF *"], ["proof (chain)\npicking this:\n  x \\<in> TER\\<^bsub>quotient_web \\<Gamma> f\\<^esub> g\n  x \\<notin> RF\\<^sup>\\<circ> (TER f)\n  x \\<notin> \\<E> (TER f) - (B \\<Gamma> - A \\<Gamma>)\n  x \\<notin> B \\<Gamma> - A \\<Gamma>", "have \"weight \\<Gamma> x \\<le> d_IN g x\""], ["proof (prove)\nusing this:\n  x \\<in> TER\\<^bsub>quotient_web \\<Gamma> f\\<^esub> g\n  x \\<notin> RF\\<^sup>\\<circ> (TER f)\n  x \\<notin> \\<E> (TER f) - (B \\<Gamma> - A \\<Gamma>)\n  x \\<notin> B \\<Gamma> - A \\<Gamma>\n\ngoal (1 subgoal):\n 1. weight \\<Gamma> x \\<le> d_IN g x", "by(auto elim!: SAT.cases split: if_split_asm simp add: essential_BI)"], ["proof (state)\nthis:\n  weight \\<Gamma> x \\<le> d_IN g x\n\ngoal (2 subgoals):\n 1. x \\<in> B \\<Gamma> - A \\<Gamma> \\<Longrightarrow>\n    x \\<in> SAT \\<Gamma> (plus_current f g)\n 2. x \\<notin> B \\<Gamma> - A \\<Gamma> \\<Longrightarrow>\n    x \\<in> SAT \\<Gamma> (plus_current f g)", "also"], ["proof (state)\nthis:\n  weight \\<Gamma> x \\<le> d_IN g x\n\ngoal (2 subgoals):\n 1. x \\<in> B \\<Gamma> - A \\<Gamma> \\<Longrightarrow>\n    x \\<in> SAT \\<Gamma> (plus_current f g)\n 2. x \\<notin> B \\<Gamma> - A \\<Gamma> \\<Longrightarrow>\n    x \\<in> SAT \\<Gamma> (plus_current f g)", "have \"\\<dots> \\<le> d_IN ?g x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN g x \\<le> d_IN (plus_current f g) x", "unfolding plus_current_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN g x \\<le> d_IN (\\<lambda>e. f e + g e) x", "by(intro d_IN_mono) simp"], ["proof (state)\nthis:\n  d_IN g x \\<le> d_IN (plus_current f g) x\n\ngoal (2 subgoals):\n 1. x \\<in> B \\<Gamma> - A \\<Gamma> \\<Longrightarrow>\n    x \\<in> SAT \\<Gamma> (plus_current f g)\n 2. x \\<notin> B \\<Gamma> - A \\<Gamma> \\<Longrightarrow>\n    x \\<in> SAT \\<Gamma> (plus_current f g)", "finally"], ["proof (chain)\npicking this:\n  weight \\<Gamma> x \\<le> d_IN (plus_current f g) x", "show ?thesis"], ["proof (prove)\nusing this:\n  weight \\<Gamma> x \\<le> d_IN (plus_current f g) x\n\ngoal (1 subgoal):\n 1. x \\<in> SAT \\<Gamma> (plus_current f g)", ".."], ["proof (state)\nthis:\n  x \\<in> SAT \\<Gamma> (plus_current f g)\n\ngoal (1 subgoal):\n 1. x \\<in> B \\<Gamma> - A \\<Gamma> \\<Longrightarrow>\n    x \\<in> SAT \\<Gamma> (plus_current f g)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<in> B \\<Gamma> - A \\<Gamma> \\<Longrightarrow>\n    x \\<in> SAT \\<Gamma> (plus_current f g)", "case True"], ["proof (state)\nthis:\n  x \\<in> B \\<Gamma> - A \\<Gamma>\n\ngoal (1 subgoal):\n 1. x \\<in> B \\<Gamma> - A \\<Gamma> \\<Longrightarrow>\n    x \\<in> SAT \\<Gamma> (plus_current f g)", "with * x"], ["proof (chain)\npicking this:\n  x \\<notin> \\<E> (TER f) - (B \\<Gamma> - A \\<Gamma>)\n  x \\<in> TER\\<^bsub>quotient_web \\<Gamma> f\\<^esub> g\n  x \\<in> B \\<Gamma> - A \\<Gamma>", "have \"weight \\<Gamma> x \\<le> d_IN ?g x\""], ["proof (prove)\nusing this:\n  x \\<notin> \\<E> (TER f) - (B \\<Gamma> - A \\<Gamma>)\n  x \\<in> TER\\<^bsub>quotient_web \\<Gamma> f\\<^esub> g\n  x \\<in> B \\<Gamma> - A \\<Gamma>\n\ngoal (1 subgoal):\n 1. weight \\<Gamma> x \\<le> d_IN (plus_current f g) x", "using currentD_OUT[OF f, of x]"], ["proof (prove)\nusing this:\n  x \\<notin> \\<E> (TER f) - (B \\<Gamma> - A \\<Gamma>)\n  x \\<in> TER\\<^bsub>quotient_web \\<Gamma> f\\<^esub> g\n  x \\<in> B \\<Gamma> - A \\<Gamma>\n  x \\<in> B \\<Gamma> \\<Longrightarrow> d_OUT f x = 0\n\ngoal (1 subgoal):\n 1. weight \\<Gamma> x \\<le> d_IN (plus_current f g) x", "by(auto simp add: IN_plus_current RF_in_B SINK.simps roofed_circ_def elim!: SAT.cases split: if_split_asm)"], ["proof (state)\nthis:\n  weight \\<Gamma> x \\<le> d_IN (plus_current f g) x\n\ngoal (1 subgoal):\n 1. x \\<in> B \\<Gamma> - A \\<Gamma> \\<Longrightarrow>\n    x \\<in> SAT \\<Gamma> (plus_current f g)", "thus ?thesis"], ["proof (prove)\nusing this:\n  weight \\<Gamma> x \\<le> d_IN (plus_current f g) x\n\ngoal (1 subgoal):\n 1. x \\<in> SAT \\<Gamma> (plus_current f g)", ".."], ["proof (state)\nthis:\n  x \\<in> SAT \\<Gamma> (plus_current f g)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x \\<in> SAT \\<Gamma> (plus_current f g)\n\ngoal (1 subgoal):\n 1. x \\<notin> \\<E> (TER f) - (B \\<Gamma> - A \\<Gamma>) \\<Longrightarrow>\n    x \\<in> TER (plus_current f g)", "moreover"], ["proof (state)\nthis:\n  x \\<in> SAT \\<Gamma> (plus_current f g)\n\ngoal (1 subgoal):\n 1. x \\<notin> \\<E> (TER f) - (B \\<Gamma> - A \\<Gamma>) \\<Longrightarrow>\n    x \\<in> TER (plus_current f g)", "have \"x \\<in> SINK ?g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> SINK (plus_current f g)", "using x"], ["proof (prove)\nusing this:\n  x \\<in> TER\\<^bsub>quotient_web \\<Gamma> f\\<^esub> g\n\ngoal (1 subgoal):\n 1. x \\<in> SINK (plus_current f g)", "by(simp add: SINK.simps OUT_plus_current RF)"], ["proof (state)\nthis:\n  x \\<in> SINK (plus_current f g)\n\ngoal (1 subgoal):\n 1. x \\<notin> \\<E> (TER f) - (B \\<Gamma> - A \\<Gamma>) \\<Longrightarrow>\n    x \\<in> TER (plus_current f g)", "ultimately"], ["proof (chain)\npicking this:\n  x \\<in> SAT \\<Gamma> (plus_current f g)\n  x \\<in> SINK (plus_current f g)", "show ?thesis"], ["proof (prove)\nusing this:\n  x \\<in> SAT \\<Gamma> (plus_current f g)\n  x \\<in> SINK (plus_current f g)\n\ngoal (1 subgoal):\n 1. x \\<in> TER (plus_current f g)", "by simp"], ["proof (state)\nthis:\n  x \\<in> TER (plus_current f g)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma current_plus_current: \"current \\<Gamma> (plus_current f g)\" (is \"current _ ?g\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. current \\<Gamma> (plus_current f g)", "proof"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>x. d_OUT (plus_current f g) x \\<le> weight \\<Gamma> x\n 2. \\<And>x. d_IN (plus_current f g) x \\<le> weight \\<Gamma> x\n 3. \\<And>x.\n       x \\<notin> A \\<Gamma> \\<Longrightarrow>\n       d_OUT (plus_current f g) x \\<le> d_IN (plus_current f g) x\n 4. \\<And>a.\n       a \\<in> A \\<Gamma> \\<Longrightarrow> d_IN (plus_current f g) a = 0\n 5. \\<And>b.\n       b \\<in> B \\<Gamma> \\<Longrightarrow> d_OUT (plus_current f g) b = 0\n 6. \\<And>e. e \\<notin> \\<^bold>E \\<Longrightarrow> plus_current f g e = 0", "show \"d_OUT ?g x \\<le> weight \\<Gamma> x\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT (plus_current f g) x \\<le> weight \\<Gamma> x", "using currentD_weight_OUT[OF g, of x] currentD_weight_OUT[OF f, of x]"], ["proof (prove)\nusing this:\n  d_OUT g x \\<le> weight (quotient_web \\<Gamma> f) x\n  d_OUT f x \\<le> weight \\<Gamma> x\n\ngoal (1 subgoal):\n 1. d_OUT (plus_current f g) x \\<le> weight \\<Gamma> x", "by(auto simp add: OUT_plus_current split: if_split_asm elim: order_trans)"], ["proof (state)\nthis:\n  d_OUT (plus_current f g) ?x \\<le> weight \\<Gamma> ?x\n\ngoal (5 subgoals):\n 1. \\<And>x. d_IN (plus_current f g) x \\<le> weight \\<Gamma> x\n 2. \\<And>x.\n       x \\<notin> A \\<Gamma> \\<Longrightarrow>\n       d_OUT (plus_current f g) x \\<le> d_IN (plus_current f g) x\n 3. \\<And>a.\n       a \\<in> A \\<Gamma> \\<Longrightarrow> d_IN (plus_current f g) a = 0\n 4. \\<And>b.\n       b \\<in> B \\<Gamma> \\<Longrightarrow> d_OUT (plus_current f g) b = 0\n 5. \\<And>e. e \\<notin> \\<^bold>E \\<Longrightarrow> plus_current f g e = 0", "show \"d_IN ?g x \\<le> weight \\<Gamma> x\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN (plus_current f g) x \\<le> weight \\<Gamma> x", "using currentD_weight_IN[OF f, of x] currentD_weight_IN[OF g, of x]"], ["proof (prove)\nusing this:\n  d_IN f x \\<le> weight \\<Gamma> x\n  d_IN g x \\<le> weight (quotient_web \\<Gamma> f) x\n\ngoal (1 subgoal):\n 1. d_IN (plus_current f g) x \\<le> weight \\<Gamma> x", "by(auto simp add: IN_plus_current roofed_circ_def split: if_split_asm elim: order_trans)"], ["proof (state)\nthis:\n  d_IN (plus_current f g) ?x \\<le> weight \\<Gamma> ?x\n\ngoal (4 subgoals):\n 1. \\<And>x.\n       x \\<notin> A \\<Gamma> \\<Longrightarrow>\n       d_OUT (plus_current f g) x \\<le> d_IN (plus_current f g) x\n 2. \\<And>a.\n       a \\<in> A \\<Gamma> \\<Longrightarrow> d_IN (plus_current f g) a = 0\n 3. \\<And>b.\n       b \\<in> B \\<Gamma> \\<Longrightarrow> d_OUT (plus_current f g) b = 0\n 4. \\<And>e. e \\<notin> \\<^bold>E \\<Longrightarrow> plus_current f g e = 0", "show \"d_OUT ?g x \\<le> d_IN ?g x\" if \"x \\<notin> A \\<Gamma>\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT (plus_current f g) x \\<le> d_IN (plus_current f g) x", "proof(cases \"x \\<in> \\<E> (TER f)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<in> \\<E> (TER f) \\<Longrightarrow>\n    d_OUT (plus_current f g) x \\<le> d_IN (plus_current f g) x\n 2. x \\<notin> \\<E> (TER f) \\<Longrightarrow>\n    d_OUT (plus_current f g) x \\<le> d_IN (plus_current f g) x", "case False"], ["proof (state)\nthis:\n  x \\<notin> \\<E> (TER f)\n\ngoal (2 subgoals):\n 1. x \\<in> \\<E> (TER f) \\<Longrightarrow>\n    d_OUT (plus_current f g) x \\<le> d_IN (plus_current f g) x\n 2. x \\<notin> \\<E> (TER f) \\<Longrightarrow>\n    d_OUT (plus_current f g) x \\<le> d_IN (plus_current f g) x", "thus ?thesis"], ["proof (prove)\nusing this:\n  x \\<notin> \\<E> (TER f)\n\ngoal (1 subgoal):\n 1. d_OUT (plus_current f g) x \\<le> d_IN (plus_current f g) x", "using currentD_OUT_IN[OF f that] currentD_OUT_IN[OF g, of x] that"], ["proof (prove)\nusing this:\n  x \\<notin> \\<E> (TER f)\n  d_OUT f x \\<le> d_IN f x\n  x \\<notin> A (quotient_web \\<Gamma> f) \\<Longrightarrow>\n  d_OUT g x \\<le> d_IN g x\n  x \\<notin> A \\<Gamma>\n\ngoal (1 subgoal):\n 1. d_OUT (plus_current f g) x \\<le> d_IN (plus_current f g) x", "by(auto simp add: OUT_plus_current IN_plus_current roofed_circ_def SINK.simps)"], ["proof (state)\nthis:\n  d_OUT (plus_current f g) x \\<le> d_IN (plus_current f g) x\n\ngoal (1 subgoal):\n 1. x \\<in> \\<E> (TER f) \\<Longrightarrow>\n    d_OUT (plus_current f g) x \\<le> d_IN (plus_current f g) x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<in> \\<E> (TER f) \\<Longrightarrow>\n    d_OUT (plus_current f g) x \\<le> d_IN (plus_current f g) x", "case True"], ["proof (state)\nthis:\n  x \\<in> \\<E> (TER f)\n\ngoal (1 subgoal):\n 1. x \\<in> \\<E> (TER f) \\<Longrightarrow>\n    d_OUT (plus_current f g) x \\<le> d_IN (plus_current f g) x", "with that"], ["proof (chain)\npicking this:\n  x \\<notin> A \\<Gamma>\n  x \\<in> \\<E> (TER f)", "have \"d_OUT f x = 0\" \"weight \\<Gamma> x \\<le> d_IN f x\""], ["proof (prove)\nusing this:\n  x \\<notin> A \\<Gamma>\n  x \\<in> \\<E> (TER f)\n\ngoal (1 subgoal):\n 1. d_OUT f x = 0 &&& weight \\<Gamma> x \\<le> d_IN f x", "by(auto simp add: SINK.simps elim: SAT.cases)"], ["proof (state)\nthis:\n  d_OUT f x = 0\n  weight \\<Gamma> x \\<le> d_IN f x\n\ngoal (1 subgoal):\n 1. x \\<in> \\<E> (TER f) \\<Longrightarrow>\n    d_OUT (plus_current f g) x \\<le> d_IN (plus_current f g) x", "thus ?thesis"], ["proof (prove)\nusing this:\n  d_OUT f x = 0\n  weight \\<Gamma> x \\<le> d_IN f x\n\ngoal (1 subgoal):\n 1. d_OUT (plus_current f g) x \\<le> d_IN (plus_current f g) x", "using that True currentD_OUT_IN[OF g, of x] currentD_weight_OUT[OF g, of x]"], ["proof (prove)\nusing this:\n  d_OUT f x = 0\n  weight \\<Gamma> x \\<le> d_IN f x\n  x \\<notin> A \\<Gamma>\n  x \\<in> \\<E> (TER f)\n  x \\<notin> A (quotient_web \\<Gamma> f) \\<Longrightarrow>\n  d_OUT g x \\<le> d_IN g x\n  d_OUT g x \\<le> weight (quotient_web \\<Gamma> f) x\n\ngoal (1 subgoal):\n 1. d_OUT (plus_current f g) x \\<le> d_IN (plus_current f g) x", "by(auto simp add: OUT_plus_current IN_plus_current roofed_circ_def intro: roofed_greaterI split: if_split_asm)"], ["proof (state)\nthis:\n  d_OUT (plus_current f g) x \\<le> d_IN (plus_current f g) x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?x \\<notin> A \\<Gamma> \\<Longrightarrow>\n  d_OUT (plus_current f g) ?x \\<le> d_IN (plus_current f g) ?x\n\ngoal (3 subgoals):\n 1. \\<And>a.\n       a \\<in> A \\<Gamma> \\<Longrightarrow> d_IN (plus_current f g) a = 0\n 2. \\<And>b.\n       b \\<in> B \\<Gamma> \\<Longrightarrow> d_OUT (plus_current f g) b = 0\n 3. \\<And>e. e \\<notin> \\<^bold>E \\<Longrightarrow> plus_current f g e = 0", "show \"d_IN ?g a = 0\" if \"a \\<in> A \\<Gamma>\" for a"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN (plus_current f g) a = 0", "using wave_A_in_RF[OF w that] currentD_IN[OF f that]"], ["proof (prove)\nusing this:\n  a \\<in> RF (TER f)\n  d_IN f a = 0\n\ngoal (1 subgoal):\n 1. d_IN (plus_current f g) a = 0", "by(simp add: IN_plus_current)"], ["proof (state)\nthis:\n  ?a \\<in> A \\<Gamma> \\<Longrightarrow> d_IN (plus_current f g) ?a = 0\n\ngoal (2 subgoals):\n 1. \\<And>b.\n       b \\<in> B \\<Gamma> \\<Longrightarrow> d_OUT (plus_current f g) b = 0\n 2. \\<And>e. e \\<notin> \\<^bold>E \\<Longrightarrow> plus_current f g e = 0", "show \"d_OUT ?g b = 0\" if \"b \\<in> B \\<Gamma>\" for b"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT (plus_current f g) b = 0", "using that currentD_OUT[OF f that] currentD_OUT[OF g, of b] that"], ["proof (prove)\nusing this:\n  b \\<in> B \\<Gamma>\n  d_OUT f b = 0\n  b \\<in> B (quotient_web \\<Gamma> f) \\<Longrightarrow> d_OUT g b = 0\n  b \\<in> B \\<Gamma>\n\ngoal (1 subgoal):\n 1. d_OUT (plus_current f g) b = 0", "by(auto simp add: OUT_plus_current SINK.simps roofed_circ_def intro: roofed_greaterI)"], ["proof (state)\nthis:\n  ?b \\<in> B \\<Gamma> \\<Longrightarrow> d_OUT (plus_current f g) ?b = 0\n\ngoal (1 subgoal):\n 1. \\<And>e. e \\<notin> \\<^bold>E \\<Longrightarrow> plus_current f g e = 0", "show \"?g e = 0\" if \"e \\<notin> \\<^bold>E\" for e"], ["proof (prove)\ngoal (1 subgoal):\n 1. plus_current f g e = 0", "using currentD_outside'[OF f, of e] currentD_outside'[OF g, of e] that"], ["proof (prove)\nusing this:\n  e \\<notin> \\<^bold>E \\<Longrightarrow> f e = 0\n  e \\<notin> \\<^bold>E\\<^bsub>quotient_web \\<Gamma> f\\<^esub> \\<Longrightarrow>\n  g e = 0\n  e \\<notin> \\<^bold>E\n\ngoal (1 subgoal):\n 1. plus_current f g e = 0", "by(cases e) auto"], ["proof (state)\nthis:\n  ?e \\<notin> \\<^bold>E \\<Longrightarrow> plus_current f g ?e = 0\n\ngoal:\nNo subgoals!", "qed"], ["", "context\n  assumes w': \"wave (quotient_web \\<Gamma> f) g\"\nbegin"], ["", "lemma separating_TER_plus_current:\n  assumes x: \"x \\<in> RF (TER f)\" and y: \"y \\<in> B \\<Gamma>\" and p: \"path \\<Gamma> x p y\"\n  shows \"(\\<exists>z\\<in>set p. z \\<in> TER (plus_current f g)) \\<or> x \\<in> TER (plus_current f g)\" (is \"_ \\<or> _ \\<in> TER ?g\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>z\\<in>set p. z \\<in> TER (plus_current f g)) \\<or>\n    x \\<in> TER (plus_current f g)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<exists>z\\<in>set p. z \\<in> TER (plus_current f g)) \\<or>\n    x \\<in> TER (plus_current f g)", "from x"], ["proof (chain)\npicking this:\n  x \\<in> RF (TER f)", "have \"x \\<in> RF (\\<E> (TER f))\""], ["proof (prove)\nusing this:\n  x \\<in> RF (TER f)\n\ngoal (1 subgoal):\n 1. x \\<in> RF (\\<E> (TER f))", "unfolding RF_essential"], ["proof (prove)\nusing this:\n  x \\<in> RF (TER f)\n\ngoal (1 subgoal):\n 1. x \\<in> RF (TER f)", "."], ["proof (state)\nthis:\n  x \\<in> RF (\\<E> (TER f))\n\ngoal (1 subgoal):\n 1. (\\<exists>z\\<in>set p. z \\<in> TER (plus_current f g)) \\<or>\n    x \\<in> TER (plus_current f g)", "from roofedD[OF this p y]"], ["proof (chain)\npicking this:\n  (\\<exists>z\\<in>set p. z \\<in> \\<E> (TER f)) \\<or> x \\<in> \\<E> (TER f)", "have \"\\<exists>z\\<in>set (x # p). z \\<in> \\<E> (TER f)\""], ["proof (prove)\nusing this:\n  (\\<exists>z\\<in>set p. z \\<in> \\<E> (TER f)) \\<or> x \\<in> \\<E> (TER f)\n\ngoal (1 subgoal):\n 1. \\<exists>z\\<in>set (x # p). z \\<in> \\<E> (TER f)", "by auto"], ["proof (state)\nthis:\n  \\<exists>z\\<in>set (x # p). z \\<in> \\<E> (TER f)\n\ngoal (1 subgoal):\n 1. (\\<exists>z\\<in>set p. z \\<in> TER (plus_current f g)) \\<or>\n    x \\<in> TER (plus_current f g)", "from split_list_last_prop[OF this]"], ["proof (chain)\npicking this:\n  \\<exists>ys xa zs.\n     x # p = ys @ xa # zs \\<and>\n     xa \\<in> \\<E> (TER f) \\<and>\n     (\\<forall>z\\<in>set zs. z \\<notin> \\<E> (TER f))", "obtain ys z zs\n    where decomp: \"x # p = ys @ z # zs\" and z: \"z \\<in> \\<E> (TER f)\"\n    and outside: \"\\<And>z. z \\<in> set zs \\<Longrightarrow> z \\<notin> \\<E> (TER f)\""], ["proof (prove)\nusing this:\n  \\<exists>ys xa zs.\n     x # p = ys @ xa # zs \\<and>\n     xa \\<in> \\<E> (TER f) \\<and>\n     (\\<forall>z\\<in>set zs. z \\<notin> \\<E> (TER f))\n\ngoal (1 subgoal):\n 1. (\\<And>ys z zs.\n        \\<lbrakk>x # p = ys @ z # zs; z \\<in> \\<E> (TER f);\n         \\<And>z.\n            z \\<in> set zs \\<Longrightarrow>\n            z \\<notin> \\<E> (TER f)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  x # p = ys @ z # zs\n  z \\<in> \\<E> (TER f)\n  ?z \\<in> set zs \\<Longrightarrow> ?z \\<notin> \\<E> (TER f)\n\ngoal (1 subgoal):\n 1. (\\<exists>z\\<in>set p. z \\<in> TER (plus_current f g)) \\<or>\n    x \\<in> TER (plus_current f g)", "have zs: \"path \\<Gamma> z zs y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path \\<Gamma> z zs y", "using decomp p"], ["proof (prove)\nusing this:\n  x # p = ys @ z # zs\n  path \\<Gamma> x p y\n\ngoal (1 subgoal):\n 1. path \\<Gamma> z zs y", "by(cases ys)(auto elim: rtrancl_path_appendE)"], ["proof (state)\nthis:\n  path \\<Gamma> z zs y\n\ngoal (1 subgoal):\n 1. (\\<exists>z\\<in>set p. z \\<in> TER (plus_current f g)) \\<or>\n    x \\<in> TER (plus_current f g)", "moreover"], ["proof (state)\nthis:\n  path \\<Gamma> z zs y\n\ngoal (1 subgoal):\n 1. (\\<exists>z\\<in>set p. z \\<in> TER (plus_current f g)) \\<or>\n    x \\<in> TER (plus_current f g)", "have \"z \\<notin> RF\\<^sup>\\<circ> (TER f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z \\<notin> RF\\<^sup>\\<circ> (TER f)", "using z"], ["proof (prove)\nusing this:\n  z \\<in> \\<E> (TER f)\n\ngoal (1 subgoal):\n 1. z \\<notin> RF\\<^sup>\\<circ> (TER f)", "by(simp add: roofed_circ_def)"], ["proof (state)\nthis:\n  z \\<notin> RF\\<^sup>\\<circ> (TER f)\n\ngoal (1 subgoal):\n 1. (\\<exists>z\\<in>set p. z \\<in> TER (plus_current f g)) \\<or>\n    x \\<in> TER (plus_current f g)", "moreover"], ["proof (state)\nthis:\n  z \\<notin> RF\\<^sup>\\<circ> (TER f)\n\ngoal (1 subgoal):\n 1. (\\<exists>z\\<in>set p. z \\<in> TER (plus_current f g)) \\<or>\n    x \\<in> TER (plus_current f g)", "have RF: \"z' \\<notin> RF (TER f)\" if \"z' \\<in> set zs\" for z'"], ["proof (prove)\ngoal (1 subgoal):\n 1. z' \\<notin> RF (TER f)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. z' \\<in> RF (TER f) \\<Longrightarrow> False", "assume \"z' \\<in> RF (TER f)\""], ["proof (state)\nthis:\n  z' \\<in> RF (TER f)\n\ngoal (1 subgoal):\n 1. z' \\<in> RF (TER f) \\<Longrightarrow> False", "hence z': \"z' \\<in> RF (\\<E> (TER f))\""], ["proof (prove)\nusing this:\n  z' \\<in> RF (TER f)\n\ngoal (1 subgoal):\n 1. z' \\<in> RF (\\<E> (TER f))", "by(simp only: RF_essential)"], ["proof (state)\nthis:\n  z' \\<in> RF (\\<E> (TER f))\n\ngoal (1 subgoal):\n 1. z' \\<in> RF (TER f) \\<Longrightarrow> False", "from split_list[OF that]"], ["proof (chain)\npicking this:\n  \\<exists>ys zsa. zs = ys @ z' # zsa", "obtain ys' zs' where decomp': \"zs = ys' @ z' # zs'\""], ["proof (prove)\nusing this:\n  \\<exists>ys zsa. zs = ys @ z' # zsa\n\ngoal (1 subgoal):\n 1. (\\<And>ys' zs'.\n        zs = ys' @ z' # zs' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  zs = ys' @ z' # zs'\n\ngoal (1 subgoal):\n 1. z' \\<in> RF (TER f) \\<Longrightarrow> False", "with zs"], ["proof (chain)\npicking this:\n  path \\<Gamma> z zs y\n  zs = ys' @ z' # zs'", "have \"path \\<Gamma> z' zs' y\""], ["proof (prove)\nusing this:\n  path \\<Gamma> z zs y\n  zs = ys' @ z' # zs'\n\ngoal (1 subgoal):\n 1. path \\<Gamma> z' zs' y", "by(auto elim: rtrancl_path_appendE)"], ["proof (state)\nthis:\n  path \\<Gamma> z' zs' y\n\ngoal (1 subgoal):\n 1. z' \\<in> RF (TER f) \\<Longrightarrow> False", "from roofedD[OF z' this y] outside decomp'"], ["proof (chain)\npicking this:\n  (\\<exists>z\\<in>set zs'. z \\<in> \\<E> (TER f)) \\<or> z' \\<in> \\<E> (TER f)\n  ?z \\<in> set zs \\<Longrightarrow> ?z \\<notin> \\<E> (TER f)\n  zs = ys' @ z' # zs'", "show False"], ["proof (prove)\nusing this:\n  (\\<exists>z\\<in>set zs'. z \\<in> \\<E> (TER f)) \\<or> z' \\<in> \\<E> (TER f)\n  ?z \\<in> set zs \\<Longrightarrow> ?z \\<notin> \\<E> (TER f)\n  zs = ys' @ z' # zs'\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?z' \\<in> set zs \\<Longrightarrow> ?z' \\<notin> RF (TER f)\n\ngoal (1 subgoal):\n 1. (\\<exists>z\\<in>set p. z \\<in> TER (plus_current f g)) \\<or>\n    x \\<in> TER (plus_current f g)", "ultimately"], ["proof (chain)\npicking this:\n  path \\<Gamma> z zs y\n  z \\<notin> RF\\<^sup>\\<circ> (TER f)\n  ?z' \\<in> set zs \\<Longrightarrow> ?z' \\<notin> RF (TER f)", "have p': \"path (quotient_web \\<Gamma> f) z zs y\""], ["proof (prove)\nusing this:\n  path \\<Gamma> z zs y\n  z \\<notin> RF\\<^sup>\\<circ> (TER f)\n  ?z' \\<in> set zs \\<Longrightarrow> ?z' \\<notin> RF (TER f)\n\ngoal (1 subgoal):\n 1. path (quotient_web \\<Gamma> f) z zs y", "by(rule path_quotient_web)"], ["proof (state)\nthis:\n  path (quotient_web \\<Gamma> f) z zs y\n\ngoal (1 subgoal):\n 1. (\\<exists>z\\<in>set p. z \\<in> TER (plus_current f g)) \\<or>\n    x \\<in> TER (plus_current f g)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>z\\<in>set p. z \\<in> TER (plus_current f g)) \\<or>\n    x \\<in> TER (plus_current f g)", "proof(cases \"z \\<in> B \\<Gamma> - A \\<Gamma>\")"], ["proof (state)\ngoal (2 subgoals):\n 1. z \\<in> B \\<Gamma> - A \\<Gamma> \\<Longrightarrow>\n    (\\<exists>z\\<in>set p. z \\<in> TER (plus_current f g)) \\<or>\n    x \\<in> TER (plus_current f g)\n 2. z \\<notin> B \\<Gamma> - A \\<Gamma> \\<Longrightarrow>\n    (\\<exists>z\\<in>set p. z \\<in> TER (plus_current f g)) \\<or>\n    x \\<in> TER (plus_current f g)", "case False"], ["proof (state)\nthis:\n  z \\<notin> B \\<Gamma> - A \\<Gamma>\n\ngoal (2 subgoals):\n 1. z \\<in> B \\<Gamma> - A \\<Gamma> \\<Longrightarrow>\n    (\\<exists>z\\<in>set p. z \\<in> TER (plus_current f g)) \\<or>\n    x \\<in> TER (plus_current f g)\n 2. z \\<notin> B \\<Gamma> - A \\<Gamma> \\<Longrightarrow>\n    (\\<exists>z\\<in>set p. z \\<in> TER (plus_current f g)) \\<or>\n    x \\<in> TER (plus_current f g)", "with separatingD[OF waveD_separating[OF w'] p'] z y"], ["proof (chain)\npicking this:\n  \\<lbrakk>z \\<in> A (quotient_web \\<Gamma> f);\n   y \\<in> B (quotient_web \\<Gamma> f)\\<rbrakk>\n  \\<Longrightarrow> (\\<exists>z\\<in>set zs.\n                        z \\<in> TER\\<^bsub>quotient_web \\<Gamma> f\\<^esub>\n                                 g) \\<or>\n                    z \\<in> TER\\<^bsub>quotient_web \\<Gamma> f\\<^esub> g\n  z \\<in> \\<E> (TER f)\n  y \\<in> B \\<Gamma>\n  z \\<notin> B \\<Gamma> - A \\<Gamma>", "obtain z' where z': \"z' \\<in> set (z # zs)\" and TER: \"z' \\<in> TER\\<^bsub>quotient_web \\<Gamma> f\\<^esub> g\""], ["proof (prove)\nusing this:\n  \\<lbrakk>z \\<in> A (quotient_web \\<Gamma> f);\n   y \\<in> B (quotient_web \\<Gamma> f)\\<rbrakk>\n  \\<Longrightarrow> (\\<exists>z\\<in>set zs.\n                        z \\<in> TER\\<^bsub>quotient_web \\<Gamma> f\\<^esub>\n                                 g) \\<or>\n                    z \\<in> TER\\<^bsub>quotient_web \\<Gamma> f\\<^esub> g\n  z \\<in> \\<E> (TER f)\n  y \\<in> B \\<Gamma>\n  z \\<notin> B \\<Gamma> - A \\<Gamma>\n\ngoal (1 subgoal):\n 1. (\\<And>z'.\n        \\<lbrakk>z' \\<in> set (z # zs);\n         z' \\<in> TER\\<^bsub>quotient_web \\<Gamma> f\\<^esub> g\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  z' \\<in> set (z # zs)\n  z' \\<in> TER\\<^bsub>quotient_web \\<Gamma> f\\<^esub> g\n\ngoal (2 subgoals):\n 1. z \\<in> B \\<Gamma> - A \\<Gamma> \\<Longrightarrow>\n    (\\<exists>z\\<in>set p. z \\<in> TER (plus_current f g)) \\<or>\n    x \\<in> TER (plus_current f g)\n 2. z \\<notin> B \\<Gamma> - A \\<Gamma> \\<Longrightarrow>\n    (\\<exists>z\\<in>set p. z \\<in> TER (plus_current f g)) \\<or>\n    x \\<in> TER (plus_current f g)", "hence \"z' \\<in> TER ?g\""], ["proof (prove)\nusing this:\n  z' \\<in> set (z # zs)\n  z' \\<in> TER\\<^bsub>quotient_web \\<Gamma> f\\<^esub> g\n\ngoal (1 subgoal):\n 1. z' \\<in> TER (plus_current f g)", "using in_TER_plus_current[of z'] RF[of z'] \\<open>z \\<notin> RF\\<^sup>\\<circ> (TER f)\\<close>"], ["proof (prove)\nusing this:\n  z' \\<in> set (z # zs)\n  z' \\<in> TER\\<^bsub>quotient_web \\<Gamma> f\\<^esub> g\n  \\<lbrakk>z' \\<notin> RF\\<^sup>\\<circ> (TER f);\n   z' \\<in> TER\\<^bsub>quotient_web \\<Gamma> f\\<^esub> g\\<rbrakk>\n  \\<Longrightarrow> z' \\<in> TER (plus_current f g)\n  z' \\<in> set zs \\<Longrightarrow> z' \\<notin> RF (TER f)\n  z \\<notin> RF\\<^sup>\\<circ> (TER f)\n\ngoal (1 subgoal):\n 1. z' \\<in> TER (plus_current f g)", "by(auto simp add: roofed_circ_def)"], ["proof (state)\nthis:\n  z' \\<in> TER (plus_current f g)\n\ngoal (2 subgoals):\n 1. z \\<in> B \\<Gamma> - A \\<Gamma> \\<Longrightarrow>\n    (\\<exists>z\\<in>set p. z \\<in> TER (plus_current f g)) \\<or>\n    x \\<in> TER (plus_current f g)\n 2. z \\<notin> B \\<Gamma> - A \\<Gamma> \\<Longrightarrow>\n    (\\<exists>z\\<in>set p. z \\<in> TER (plus_current f g)) \\<or>\n    x \\<in> TER (plus_current f g)", "with decomp z'"], ["proof (chain)\npicking this:\n  x # p = ys @ z # zs\n  z' \\<in> set (z # zs)\n  z' \\<in> TER (plus_current f g)", "show ?thesis"], ["proof (prove)\nusing this:\n  x # p = ys @ z # zs\n  z' \\<in> set (z # zs)\n  z' \\<in> TER (plus_current f g)\n\ngoal (1 subgoal):\n 1. (\\<exists>z\\<in>set p. z \\<in> TER (plus_current f g)) \\<or>\n    x \\<in> TER (plus_current f g)", "by(cases ys) auto"], ["proof (state)\nthis:\n  (\\<exists>z\\<in>set p. z \\<in> TER (plus_current f g)) \\<or>\n  x \\<in> TER (plus_current f g)\n\ngoal (1 subgoal):\n 1. z \\<in> B \\<Gamma> - A \\<Gamma> \\<Longrightarrow>\n    (\\<exists>z\\<in>set p. z \\<in> TER (plus_current f g)) \\<or>\n    x \\<in> TER (plus_current f g)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. z \\<in> B \\<Gamma> - A \\<Gamma> \\<Longrightarrow>\n    (\\<exists>z\\<in>set p. z \\<in> TER (plus_current f g)) \\<or>\n    x \\<in> TER (plus_current f g)", "case True"], ["proof (state)\nthis:\n  z \\<in> B \\<Gamma> - A \\<Gamma>\n\ngoal (1 subgoal):\n 1. z \\<in> B \\<Gamma> - A \\<Gamma> \\<Longrightarrow>\n    (\\<exists>z\\<in>set p. z \\<in> TER (plus_current f g)) \\<or>\n    x \\<in> TER (plus_current f g)", "hence \"z \\<in> TER ?g\""], ["proof (prove)\nusing this:\n  z \\<in> B \\<Gamma> - A \\<Gamma>\n\ngoal (1 subgoal):\n 1. z \\<in> TER (plus_current f g)", "using currentD_OUT[OF current_plus_current, of z] z"], ["proof (prove)\nusing this:\n  z \\<in> B \\<Gamma> - A \\<Gamma>\n  z \\<in> B \\<Gamma> \\<Longrightarrow> d_OUT (plus_current f g) z = 0\n  z \\<in> \\<E> (TER f)\n\ngoal (1 subgoal):\n 1. z \\<in> TER (plus_current f g)", "by(auto simp add: SINK.simps SAT.simps IN_plus_current intro: roofed_greaterI)"], ["proof (state)\nthis:\n  z \\<in> TER (plus_current f g)\n\ngoal (1 subgoal):\n 1. z \\<in> B \\<Gamma> - A \\<Gamma> \\<Longrightarrow>\n    (\\<exists>z\\<in>set p. z \\<in> TER (plus_current f g)) \\<or>\n    x \\<in> TER (plus_current f g)", "then"], ["proof (chain)\npicking this:\n  z \\<in> TER (plus_current f g)", "show ?thesis"], ["proof (prove)\nusing this:\n  z \\<in> TER (plus_current f g)\n\ngoal (1 subgoal):\n 1. (\\<exists>z\\<in>set p. z \\<in> TER (plus_current f g)) \\<or>\n    x \\<in> TER (plus_current f g)", "using decomp"], ["proof (prove)\nusing this:\n  z \\<in> TER (plus_current f g)\n  x # p = ys @ z # zs\n\ngoal (1 subgoal):\n 1. (\\<exists>z\\<in>set p. z \\<in> TER (plus_current f g)) \\<or>\n    x \\<in> TER (plus_current f g)", "by(cases ys) auto"], ["proof (state)\nthis:\n  (\\<exists>z\\<in>set p. z \\<in> TER (plus_current f g)) \\<or>\n  x \\<in> TER (plus_current f g)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<exists>z\\<in>set p. z \\<in> TER (plus_current f g)) \\<or>\n  x \\<in> TER (plus_current f g)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma wave_plus_current: \"wave \\<Gamma> (plus_current f g)\" (is \"wave _ ?g\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. wave \\<Gamma> (plus_current f g)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. separating \\<Gamma> (TER (plus_current f g))\n 2. \\<And>x.\n       x \\<notin> RF (TER (plus_current f g)) \\<Longrightarrow>\n       d_OUT (plus_current f g) x = 0", "let ?\\<Gamma> = \"quotient_web \\<Gamma> f\""], ["proof (state)\ngoal (2 subgoals):\n 1. separating \\<Gamma> (TER (plus_current f g))\n 2. \\<And>x.\n       x \\<notin> RF (TER (plus_current f g)) \\<Longrightarrow>\n       d_OUT (plus_current f g) x = 0", "let ?TER = \"TER\\<^bsub>?\\<Gamma>\\<^esub>\""], ["proof (state)\ngoal (2 subgoals):\n 1. separating \\<Gamma> (TER (plus_current f g))\n 2. \\<And>x.\n       x \\<notin> RF (TER (plus_current f g)) \\<Longrightarrow>\n       d_OUT (plus_current f g) x = 0", "show \"separating \\<Gamma> (TER ?g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. separating \\<Gamma> (TER (plus_current f g))", "using separating_TER_plus_current[OF wave_A_in_RF[OF w]]"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<in> A \\<Gamma>; ?y \\<in> B \\<Gamma>;\n   path \\<Gamma> ?x ?p ?y\\<rbrakk>\n  \\<Longrightarrow> (\\<exists>z\\<in>set ?p.\n                        z \\<in> TER (plus_current f g)) \\<or>\n                    ?x \\<in> TER (plus_current f g)\n\ngoal (1 subgoal):\n 1. separating \\<Gamma> (TER (plus_current f g))", "by(rule separating)"], ["proof (state)\nthis:\n  separating \\<Gamma> (TER (plus_current f g))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<notin> RF (TER (plus_current f g)) \\<Longrightarrow>\n       d_OUT (plus_current f g) x = 0", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<notin> RF (TER (plus_current f g)) \\<Longrightarrow>\n       d_OUT (plus_current f g) x = 0", "assume x: \"x \\<notin> RF (TER ?g)\""], ["proof (state)\nthis:\n  x \\<notin> RF (TER (plus_current f g))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<notin> RF (TER (plus_current f g)) \\<Longrightarrow>\n       d_OUT (plus_current f g) x = 0", "hence \"x \\<notin> RF (TER f)\""], ["proof (prove)\nusing this:\n  x \\<notin> RF (TER (plus_current f g))\n\ngoal (1 subgoal):\n 1. x \\<notin> RF (TER f)", "by(rule contrapos_nn)(rule roofedI, rule separating_TER_plus_current)"], ["proof (state)\nthis:\n  x \\<notin> RF (TER f)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<notin> RF (TER (plus_current f g)) \\<Longrightarrow>\n       d_OUT (plus_current f g) x = 0", "hence *: \"x \\<notin> RF\\<^sup>\\<circ> (TER f)\""], ["proof (prove)\nusing this:\n  x \\<notin> RF (TER f)\n\ngoal (1 subgoal):\n 1. x \\<notin> RF\\<^sup>\\<circ> (TER f)", "by(simp add: roofed_circ_def)"], ["proof (state)\nthis:\n  x \\<notin> RF\\<^sup>\\<circ> (TER f)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<notin> RF (TER (plus_current f g)) \\<Longrightarrow>\n       d_OUT (plus_current f g) x = 0", "moreover"], ["proof (state)\nthis:\n  x \\<notin> RF\\<^sup>\\<circ> (TER f)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<notin> RF (TER (plus_current f g)) \\<Longrightarrow>\n       d_OUT (plus_current f g) x = 0", "have \"x \\<notin> RF\\<^bsub>?\\<Gamma>\\<^esub> (?TER g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> RF\\<^bsub>quotient_web \\<Gamma> f\\<^esub>\n                (TER\\<^bsub>quotient_web \\<Gamma> f\\<^esub> g)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<in> RF\\<^bsub>quotient_web \\<Gamma> f\\<^esub>\n             (TER\\<^bsub>quotient_web \\<Gamma> f\\<^esub>\n               g) \\<Longrightarrow>\n    False", "assume RF': \"x \\<in> RF\\<^bsub>?\\<Gamma>\\<^esub> (?TER g)\""], ["proof (state)\nthis:\n  x \\<in> RF\\<^bsub>quotient_web \\<Gamma> f\\<^esub>\n           (TER\\<^bsub>quotient_web \\<Gamma> f\\<^esub> g)\n\ngoal (1 subgoal):\n 1. x \\<in> RF\\<^bsub>quotient_web \\<Gamma> f\\<^esub>\n             (TER\\<^bsub>quotient_web \\<Gamma> f\\<^esub>\n               g) \\<Longrightarrow>\n    False", "from x"], ["proof (chain)\npicking this:\n  x \\<notin> RF (TER (plus_current f g))", "obtain p y where y: \"y \\<in> B \\<Gamma>\" and p: \"path \\<Gamma> x p y\"\n      and bypass: \"\\<And>z. z \\<in> set p \\<Longrightarrow> z \\<notin> TER ?g\" and x': \"x \\<notin> TER ?g\""], ["proof (prove)\nusing this:\n  x \\<notin> RF (TER (plus_current f g))\n\ngoal (1 subgoal):\n 1. (\\<And>y p.\n        \\<lbrakk>y \\<in> B \\<Gamma>; path \\<Gamma> x p y;\n         \\<And>z.\n            z \\<in> set p \\<Longrightarrow>\n            z \\<notin> TER (plus_current f g);\n         x \\<notin> TER (plus_current f g)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto simp add: roofed_def)"], ["proof (state)\nthis:\n  y \\<in> B \\<Gamma>\n  path \\<Gamma> x p y\n  ?z \\<in> set p \\<Longrightarrow> ?z \\<notin> TER (plus_current f g)\n  x \\<notin> TER (plus_current f g)\n\ngoal (1 subgoal):\n 1. x \\<in> RF\\<^bsub>quotient_web \\<Gamma> f\\<^esub>\n             (TER\\<^bsub>quotient_web \\<Gamma> f\\<^esub>\n               g) \\<Longrightarrow>\n    False", "have RF: \"z \\<notin> RF (TER f)\" if \"z \\<in> set p\" for z"], ["proof (prove)\ngoal (1 subgoal):\n 1. z \\<notin> RF (TER f)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. z \\<in> RF (TER f) \\<Longrightarrow> False", "assume z: \"z \\<in> RF (TER f)\""], ["proof (state)\nthis:\n  z \\<in> RF (TER f)\n\ngoal (1 subgoal):\n 1. z \\<in> RF (TER f) \\<Longrightarrow> False", "from split_list[OF that]"], ["proof (chain)\npicking this:\n  \\<exists>ys zs. p = ys @ z # zs", "obtain ys' zs' where decomp: \"p = ys' @ z # zs'\""], ["proof (prove)\nusing this:\n  \\<exists>ys zs. p = ys @ z # zs\n\ngoal (1 subgoal):\n 1. (\\<And>ys' zs'.\n        p = ys' @ z # zs' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  p = ys' @ z # zs'\n\ngoal (1 subgoal):\n 1. z \\<in> RF (TER f) \\<Longrightarrow> False", "with p"], ["proof (chain)\npicking this:\n  path \\<Gamma> x p y\n  p = ys' @ z # zs'", "have \"path \\<Gamma> z zs' y\""], ["proof (prove)\nusing this:\n  path \\<Gamma> x p y\n  p = ys' @ z # zs'\n\ngoal (1 subgoal):\n 1. path \\<Gamma> z zs' y", "by(auto elim: rtrancl_path_appendE)"], ["proof (state)\nthis:\n  path \\<Gamma> z zs' y\n\ngoal (1 subgoal):\n 1. z \\<in> RF (TER f) \\<Longrightarrow> False", "from separating_TER_plus_current[OF z y this] decomp bypass"], ["proof (chain)\npicking this:\n  (\\<exists>z\\<in>set zs'. z \\<in> TER (plus_current f g)) \\<or>\n  z \\<in> TER (plus_current f g)\n  p = ys' @ z # zs'\n  ?z \\<in> set p \\<Longrightarrow> ?z \\<notin> TER (plus_current f g)", "show False"], ["proof (prove)\nusing this:\n  (\\<exists>z\\<in>set zs'. z \\<in> TER (plus_current f g)) \\<or>\n  z \\<in> TER (plus_current f g)\n  p = ys' @ z # zs'\n  ?z \\<in> set p \\<Longrightarrow> ?z \\<notin> TER (plus_current f g)\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?z \\<in> set p \\<Longrightarrow> ?z \\<notin> RF (TER f)\n\ngoal (1 subgoal):\n 1. x \\<in> RF\\<^bsub>quotient_web \\<Gamma> f\\<^esub>\n             (TER\\<^bsub>quotient_web \\<Gamma> f\\<^esub>\n               g) \\<Longrightarrow>\n    False", "with p"], ["proof (chain)\npicking this:\n  path \\<Gamma> x p y\n  ?z \\<in> set p \\<Longrightarrow> ?z \\<notin> RF (TER f)", "have \"path ?\\<Gamma> x p y\""], ["proof (prove)\nusing this:\n  path \\<Gamma> x p y\n  ?z \\<in> set p \\<Longrightarrow> ?z \\<notin> RF (TER f)\n\ngoal (1 subgoal):\n 1. path (quotient_web \\<Gamma> f) x p y", "using *"], ["proof (prove)\nusing this:\n  path \\<Gamma> x p y\n  ?z \\<in> set p \\<Longrightarrow> ?z \\<notin> RF (TER f)\n  x \\<notin> RF\\<^sup>\\<circ> (TER f)\n\ngoal (1 subgoal):\n 1. path (quotient_web \\<Gamma> f) x p y", "by(induction)(auto intro: rtrancl_path.intros simp add: roofed_circ_def)"], ["proof (state)\nthis:\n  path (quotient_web \\<Gamma> f) x p y\n\ngoal (1 subgoal):\n 1. x \\<in> RF\\<^bsub>quotient_web \\<Gamma> f\\<^esub>\n             (TER\\<^bsub>quotient_web \\<Gamma> f\\<^esub>\n               g) \\<Longrightarrow>\n    False", "from roofedD[OF RF' this] y"], ["proof (chain)\npicking this:\n  y \\<in> B (quotient_web \\<Gamma> f) \\<Longrightarrow>\n  (\\<exists>z\\<in>set p.\n      z \\<in> TER\\<^bsub>quotient_web \\<Gamma> f\\<^esub> g) \\<or>\n  x \\<in> TER\\<^bsub>quotient_web \\<Gamma> f\\<^esub> g\n  y \\<in> B \\<Gamma>", "consider (x) \"x \\<in> ?TER g\" | (z) z where \"z \\<in> set p\" \"z \\<in> ?TER g\""], ["proof (prove)\nusing this:\n  y \\<in> B (quotient_web \\<Gamma> f) \\<Longrightarrow>\n  (\\<exists>z\\<in>set p.\n      z \\<in> TER\\<^bsub>quotient_web \\<Gamma> f\\<^esub> g) \\<or>\n  x \\<in> TER\\<^bsub>quotient_web \\<Gamma> f\\<^esub> g\n  y \\<in> B \\<Gamma>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> TER\\<^bsub>quotient_web \\<Gamma> f\\<^esub>\n                      g \\<Longrightarrow>\n             thesis;\n     \\<And>z.\n        \\<lbrakk>z \\<in> set p;\n         z \\<in> TER\\<^bsub>quotient_web \\<Gamma> f\\<^esub> g\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>x \\<in> TER\\<^bsub>quotient_web \\<Gamma> f\\<^esub>\n                    g \\<Longrightarrow>\n           ?thesis;\n   \\<And>z.\n      \\<lbrakk>z \\<in> set p;\n       z \\<in> TER\\<^bsub>quotient_web \\<Gamma> f\\<^esub> g\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. x \\<in> RF\\<^bsub>quotient_web \\<Gamma> f\\<^esub>\n             (TER\\<^bsub>quotient_web \\<Gamma> f\\<^esub>\n               g) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>x \\<in> TER\\<^bsub>quotient_web \\<Gamma> f\\<^esub>\n                    g \\<Longrightarrow>\n           ?thesis;\n   \\<And>z.\n      \\<lbrakk>z \\<in> set p;\n       z \\<in> TER\\<^bsub>quotient_web \\<Gamma> f\\<^esub> g\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis", "show False"], ["proof (prove)\nusing this:\n  \\<lbrakk>x \\<in> TER\\<^bsub>quotient_web \\<Gamma> f\\<^esub>\n                    g \\<Longrightarrow>\n           ?thesis;\n   \\<And>z.\n      \\<lbrakk>z \\<in> set p;\n       z \\<in> TER\\<^bsub>quotient_web \\<Gamma> f\\<^esub> g\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. False", "proof(cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<in> TER\\<^bsub>quotient_web \\<Gamma> f\\<^esub> g \\<Longrightarrow>\n    False\n 2. \\<And>z.\n       \\<lbrakk>z \\<in> set p;\n        z \\<in> TER\\<^bsub>quotient_web \\<Gamma> f\\<^esub> g\\<rbrakk>\n       \\<Longrightarrow> False", "case x"], ["proof (state)\nthis:\n  x \\<in> TER\\<^bsub>quotient_web \\<Gamma> f\\<^esub> g\n\ngoal (2 subgoals):\n 1. x \\<in> TER\\<^bsub>quotient_web \\<Gamma> f\\<^esub> g \\<Longrightarrow>\n    False\n 2. \\<And>z.\n       \\<lbrakk>z \\<in> set p;\n        z \\<in> TER\\<^bsub>quotient_web \\<Gamma> f\\<^esub> g\\<rbrakk>\n       \\<Longrightarrow> False", "with *"], ["proof (chain)\npicking this:\n  x \\<notin> RF\\<^sup>\\<circ> (TER f)\n  x \\<in> TER\\<^bsub>quotient_web \\<Gamma> f\\<^esub> g", "have \"x \\<in> TER ?g\""], ["proof (prove)\nusing this:\n  x \\<notin> RF\\<^sup>\\<circ> (TER f)\n  x \\<in> TER\\<^bsub>quotient_web \\<Gamma> f\\<^esub> g\n\ngoal (1 subgoal):\n 1. x \\<in> TER (plus_current f g)", "by(rule in_TER_plus_current)"], ["proof (state)\nthis:\n  x \\<in> TER (plus_current f g)\n\ngoal (2 subgoals):\n 1. x \\<in> TER\\<^bsub>quotient_web \\<Gamma> f\\<^esub> g \\<Longrightarrow>\n    False\n 2. \\<And>z.\n       \\<lbrakk>z \\<in> set p;\n        z \\<in> TER\\<^bsub>quotient_web \\<Gamma> f\\<^esub> g\\<rbrakk>\n       \\<Longrightarrow> False", "with x'"], ["proof (chain)\npicking this:\n  x \\<notin> TER (plus_current f g)\n  x \\<in> TER (plus_current f g)", "show False"], ["proof (prove)\nusing this:\n  x \\<notin> TER (plus_current f g)\n  x \\<in> TER (plus_current f g)\n\ngoal (1 subgoal):\n 1. False", "by contradiction"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<And>z.\n       \\<lbrakk>z \\<in> set p;\n        z \\<in> TER\\<^bsub>quotient_web \\<Gamma> f\\<^esub> g\\<rbrakk>\n       \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>z.\n       \\<lbrakk>z \\<in> set p;\n        z \\<in> TER\\<^bsub>quotient_web \\<Gamma> f\\<^esub> g\\<rbrakk>\n       \\<Longrightarrow> False", "case (z z)"], ["proof (state)\nthis:\n  z \\<in> set p\n  z \\<in> TER\\<^bsub>quotient_web \\<Gamma> f\\<^esub> g\n\ngoal (1 subgoal):\n 1. \\<And>z.\n       \\<lbrakk>z \\<in> set p;\n        z \\<in> TER\\<^bsub>quotient_web \\<Gamma> f\\<^esub> g\\<rbrakk>\n       \\<Longrightarrow> False", "from z(1)"], ["proof (chain)\npicking this:\n  z \\<in> set p", "have \"z \\<notin> RF (TER f)\""], ["proof (prove)\nusing this:\n  z \\<in> set p\n\ngoal (1 subgoal):\n 1. z \\<notin> RF (TER f)", "by(rule RF)"], ["proof (state)\nthis:\n  z \\<notin> RF (TER f)\n\ngoal (1 subgoal):\n 1. \\<And>z.\n       \\<lbrakk>z \\<in> set p;\n        z \\<in> TER\\<^bsub>quotient_web \\<Gamma> f\\<^esub> g\\<rbrakk>\n       \\<Longrightarrow> False", "hence \"z \\<notin> RF\\<^sup>\\<circ> (TER f)\""], ["proof (prove)\nusing this:\n  z \\<notin> RF (TER f)\n\ngoal (1 subgoal):\n 1. z \\<notin> RF\\<^sup>\\<circ> (TER f)", "by(simp add: roofed_circ_def)"], ["proof (state)\nthis:\n  z \\<notin> RF\\<^sup>\\<circ> (TER f)\n\ngoal (1 subgoal):\n 1. \\<And>z.\n       \\<lbrakk>z \\<in> set p;\n        z \\<in> TER\\<^bsub>quotient_web \\<Gamma> f\\<^esub> g\\<rbrakk>\n       \\<Longrightarrow> False", "hence \"z \\<in> TER ?g\""], ["proof (prove)\nusing this:\n  z \\<notin> RF\\<^sup>\\<circ> (TER f)\n\ngoal (1 subgoal):\n 1. z \\<in> TER (plus_current f g)", "using z(2)"], ["proof (prove)\nusing this:\n  z \\<notin> RF\\<^sup>\\<circ> (TER f)\n  z \\<in> TER\\<^bsub>quotient_web \\<Gamma> f\\<^esub> g\n\ngoal (1 subgoal):\n 1. z \\<in> TER (plus_current f g)", "by(rule in_TER_plus_current)"], ["proof (state)\nthis:\n  z \\<in> TER (plus_current f g)\n\ngoal (1 subgoal):\n 1. \\<And>z.\n       \\<lbrakk>z \\<in> set p;\n        z \\<in> TER\\<^bsub>quotient_web \\<Gamma> f\\<^esub> g\\<rbrakk>\n       \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  z \\<in> TER (plus_current f g)\n\ngoal (1 subgoal):\n 1. \\<And>z.\n       \\<lbrakk>z \\<in> set p;\n        z \\<in> TER\\<^bsub>quotient_web \\<Gamma> f\\<^esub> g\\<rbrakk>\n       \\<Longrightarrow> False", "from z(1)"], ["proof (chain)\npicking this:\n  z \\<in> set p", "have \"z \\<notin> TER ?g\""], ["proof (prove)\nusing this:\n  z \\<in> set p\n\ngoal (1 subgoal):\n 1. z \\<notin> TER (plus_current f g)", "by(rule bypass)"], ["proof (state)\nthis:\n  z \\<notin> TER (plus_current f g)\n\ngoal (1 subgoal):\n 1. \\<And>z.\n       \\<lbrakk>z \\<in> set p;\n        z \\<in> TER\\<^bsub>quotient_web \\<Gamma> f\\<^esub> g\\<rbrakk>\n       \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  z \\<in> TER (plus_current f g)\n  z \\<notin> TER (plus_current f g)", "show False"], ["proof (prove)\nusing this:\n  z \\<in> TER (plus_current f g)\n  z \\<notin> TER (plus_current f g)\n\ngoal (1 subgoal):\n 1. False", "by contradiction"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x \\<notin> RF\\<^bsub>quotient_web \\<Gamma> f\\<^esub>\n              (TER\\<^bsub>quotient_web \\<Gamma> f\\<^esub> g)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<notin> RF (TER (plus_current f g)) \\<Longrightarrow>\n       d_OUT (plus_current f g) x = 0", "with w'"], ["proof (chain)\npicking this:\n  wave (quotient_web \\<Gamma> f) g\n  x \\<notin> RF\\<^bsub>quotient_web \\<Gamma> f\\<^esub>\n              (TER\\<^bsub>quotient_web \\<Gamma> f\\<^esub> g)", "have \"d_OUT g x = 0\""], ["proof (prove)\nusing this:\n  wave (quotient_web \\<Gamma> f) g\n  x \\<notin> RF\\<^bsub>quotient_web \\<Gamma> f\\<^esub>\n              (TER\\<^bsub>quotient_web \\<Gamma> f\\<^esub> g)\n\ngoal (1 subgoal):\n 1. d_OUT g x = 0", "by(rule waveD_OUT)"], ["proof (state)\nthis:\n  d_OUT g x = 0\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<notin> RF (TER (plus_current f g)) \\<Longrightarrow>\n       d_OUT (plus_current f g) x = 0", "ultimately"], ["proof (chain)\npicking this:\n  x \\<notin> RF\\<^sup>\\<circ> (TER f)\n  d_OUT g x = 0", "show \"d_OUT ?g x = 0\""], ["proof (prove)\nusing this:\n  x \\<notin> RF\\<^sup>\\<circ> (TER f)\n  d_OUT g x = 0\n\ngoal (1 subgoal):\n 1. d_OUT (plus_current f g) x = 0", "by(simp add: OUT_plus_current)"], ["proof (state)\nthis:\n  d_OUT (plus_current f g) x = 0\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "end"], ["", "lemma loose_quotient_web:\n  fixes \\<Gamma> :: \"('v, 'more) web_scheme\" (structure)\n  assumes weight_finite: \"\\<And>x. weight \\<Gamma> x \\<noteq> \\<top>\"\n  and f: \"current \\<Gamma> f\"\n  and w: \"wave \\<Gamma> f\"\n  and maximal: \"\\<And>w. \\<lbrakk> current \\<Gamma> w; wave \\<Gamma> w; f \\<le> w \\<rbrakk> \\<Longrightarrow> f = w\"\n  shows \"loose (quotient_web \\<Gamma> f)\" (is \"loose ?\\<Gamma>\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. loose (quotient_web \\<Gamma> f)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>fa.\n       \\<lbrakk>current (quotient_web \\<Gamma> f) fa;\n        wave (quotient_web \\<Gamma> f) fa\\<rbrakk>\n       \\<Longrightarrow> fa = (\\<lambda>_. 0)\n 2. \\<not> hindrance (quotient_web \\<Gamma> f) (\\<lambda>_. 0)", "fix g"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>fa.\n       \\<lbrakk>current (quotient_web \\<Gamma> f) fa;\n        wave (quotient_web \\<Gamma> f) fa\\<rbrakk>\n       \\<Longrightarrow> fa = (\\<lambda>_. 0)\n 2. \\<not> hindrance (quotient_web \\<Gamma> f) (\\<lambda>_. 0)", "assume g: \"current ?\\<Gamma> g\" and w': \"wave ?\\<Gamma> g\""], ["proof (state)\nthis:\n  current (quotient_web \\<Gamma> f) g\n  wave (quotient_web \\<Gamma> f) g\n\ngoal (2 subgoals):\n 1. \\<And>fa.\n       \\<lbrakk>current (quotient_web \\<Gamma> f) fa;\n        wave (quotient_web \\<Gamma> f) fa\\<rbrakk>\n       \\<Longrightarrow> fa = (\\<lambda>_. 0)\n 2. \\<not> hindrance (quotient_web \\<Gamma> f) (\\<lambda>_. 0)", "let ?g = \"plus_current f g\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>fa.\n       \\<lbrakk>current (quotient_web \\<Gamma> f) fa;\n        wave (quotient_web \\<Gamma> f) fa\\<rbrakk>\n       \\<Longrightarrow> fa = (\\<lambda>_. 0)\n 2. \\<not> hindrance (quotient_web \\<Gamma> f) (\\<lambda>_. 0)", "from f w g"], ["proof (chain)\npicking this:\n  current \\<Gamma> f\n  wave \\<Gamma> f\n  current (quotient_web \\<Gamma> f) g", "have \"current \\<Gamma> ?g\" \"wave \\<Gamma> ?g\""], ["proof (prove)\nusing this:\n  current \\<Gamma> f\n  wave \\<Gamma> f\n  current (quotient_web \\<Gamma> f) g\n\ngoal (1 subgoal):\n 1. current \\<Gamma> (plus_current f g) &&& wave \\<Gamma> (plus_current f g)", "by(rule current_plus_current wave_plus_current)+ (rule w')"], ["proof (state)\nthis:\n  current \\<Gamma> (plus_current f g)\n  wave \\<Gamma> (plus_current f g)\n\ngoal (2 subgoals):\n 1. \\<And>fa.\n       \\<lbrakk>current (quotient_web \\<Gamma> f) fa;\n        wave (quotient_web \\<Gamma> f) fa\\<rbrakk>\n       \\<Longrightarrow> fa = (\\<lambda>_. 0)\n 2. \\<not> hindrance (quotient_web \\<Gamma> f) (\\<lambda>_. 0)", "moreover"], ["proof (state)\nthis:\n  current \\<Gamma> (plus_current f g)\n  wave \\<Gamma> (plus_current f g)\n\ngoal (2 subgoals):\n 1. \\<And>fa.\n       \\<lbrakk>current (quotient_web \\<Gamma> f) fa;\n        wave (quotient_web \\<Gamma> f) fa\\<rbrakk>\n       \\<Longrightarrow> fa = (\\<lambda>_. 0)\n 2. \\<not> hindrance (quotient_web \\<Gamma> f) (\\<lambda>_. 0)", "have \"f \\<le> ?g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<le> plus_current f g", "by(clarsimp simp add: le_fun_def add_eq_0_iff_both_eq_0)"], ["proof (state)\nthis:\n  f \\<le> plus_current f g\n\ngoal (2 subgoals):\n 1. \\<And>fa.\n       \\<lbrakk>current (quotient_web \\<Gamma> f) fa;\n        wave (quotient_web \\<Gamma> f) fa\\<rbrakk>\n       \\<Longrightarrow> fa = (\\<lambda>_. 0)\n 2. \\<not> hindrance (quotient_web \\<Gamma> f) (\\<lambda>_. 0)", "ultimately"], ["proof (chain)\npicking this:\n  current \\<Gamma> (plus_current f g)\n  wave \\<Gamma> (plus_current f g)\n  f \\<le> plus_current f g", "have eq: \"f = ?g\""], ["proof (prove)\nusing this:\n  current \\<Gamma> (plus_current f g)\n  wave \\<Gamma> (plus_current f g)\n  f \\<le> plus_current f g\n\ngoal (1 subgoal):\n 1. f = plus_current f g", "by(rule maximal)"], ["proof (state)\nthis:\n  f = plus_current f g\n\ngoal (2 subgoals):\n 1. \\<And>fa.\n       \\<lbrakk>current (quotient_web \\<Gamma> f) fa;\n        wave (quotient_web \\<Gamma> f) fa\\<rbrakk>\n       \\<Longrightarrow> fa = (\\<lambda>_. 0)\n 2. \\<not> hindrance (quotient_web \\<Gamma> f) (\\<lambda>_. 0)", "have \"g e = 0\" for e"], ["proof (prove)\ngoal (1 subgoal):\n 1. g e = 0", "proof(cases e)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b. e = (a, b) \\<Longrightarrow> g e = 0", "case (Pair x y)"], ["proof (state)\nthis:\n  e = (x, y)\n\ngoal (1 subgoal):\n 1. \\<And>a b. e = (a, b) \\<Longrightarrow> g e = 0", "have \"f e \\<le> d_OUT f x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f e \\<le> d_OUT f x", "unfolding Pair"], ["proof (prove)\ngoal (1 subgoal):\n 1. f (x, y) \\<le> d_OUT f x", "by (rule d_OUT_ge_point)"], ["proof (state)\nthis:\n  f e \\<le> d_OUT f x\n\ngoal (1 subgoal):\n 1. \\<And>a b. e = (a, b) \\<Longrightarrow> g e = 0", "also"], ["proof (state)\nthis:\n  f e \\<le> d_OUT f x\n\ngoal (1 subgoal):\n 1. \\<And>a b. e = (a, b) \\<Longrightarrow> g e = 0", "have \"\\<dots> \\<le> weight \\<Gamma> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT f x \\<le> weight \\<Gamma> x", "by(rule currentD_weight_OUT[OF f])"], ["proof (state)\nthis:\n  d_OUT f x \\<le> weight \\<Gamma> x\n\ngoal (1 subgoal):\n 1. \\<And>a b. e = (a, b) \\<Longrightarrow> g e = 0", "also"], ["proof (state)\nthis:\n  d_OUT f x \\<le> weight \\<Gamma> x\n\ngoal (1 subgoal):\n 1. \\<And>a b. e = (a, b) \\<Longrightarrow> g e = 0", "have \"\\<dots> < \\<top>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. weight \\<Gamma> x < \\<top>", "by(simp add: weight_finite less_top[symmetric])"], ["proof (state)\nthis:\n  weight \\<Gamma> x < \\<top>\n\ngoal (1 subgoal):\n 1. \\<And>a b. e = (a, b) \\<Longrightarrow> g e = 0", "finally"], ["proof (chain)\npicking this:\n  f e < \\<top>", "show \"g e = 0\""], ["proof (prove)\nusing this:\n  f e < \\<top>\n\ngoal (1 subgoal):\n 1. g e = 0", "using Pair eq[THEN fun_cong, of e]"], ["proof (prove)\nusing this:\n  f e < \\<top>\n  e = (x, y)\n  f e = plus_current f g e\n\ngoal (1 subgoal):\n 1. g e = 0", "by(cases \"f e\" \"g e\" rule: ennreal2_cases)(simp_all add: fun_eq_iff)"], ["proof (state)\nthis:\n  g e = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  g ?e = 0\n\ngoal (2 subgoals):\n 1. \\<And>fa.\n       \\<lbrakk>current (quotient_web \\<Gamma> f) fa;\n        wave (quotient_web \\<Gamma> f) fa\\<rbrakk>\n       \\<Longrightarrow> fa = (\\<lambda>_. 0)\n 2. \\<not> hindrance (quotient_web \\<Gamma> f) (\\<lambda>_. 0)", "thus \"g = (\\<lambda>_. 0)\""], ["proof (prove)\nusing this:\n  g ?e = 0\n\ngoal (1 subgoal):\n 1. g = (\\<lambda>_. 0)", "by(simp add: fun_eq_iff)"], ["proof (state)\nthis:\n  g = (\\<lambda>_. 0)\n\ngoal (1 subgoal):\n 1. \\<not> hindrance (quotient_web \\<Gamma> f) (\\<lambda>_. 0)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> hindrance (quotient_web \\<Gamma> f) (\\<lambda>_. 0)", "have 0: \"current ?\\<Gamma> zero_current\""], ["proof (prove)\ngoal (1 subgoal):\n 1. current (quotient_web \\<Gamma> f) (\\<lambda>_. 0)", "by(simp add: )"], ["proof (state)\nthis:\n  current (quotient_web \\<Gamma> f) (\\<lambda>_. 0)\n\ngoal (1 subgoal):\n 1. \\<not> hindrance (quotient_web \\<Gamma> f) (\\<lambda>_. 0)", "show \"\\<not> hindrance ?\\<Gamma> zero_current\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> hindrance (quotient_web \\<Gamma> f) (\\<lambda>_. 0)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. hindrance (quotient_web \\<Gamma> f) (\\<lambda>_. 0) \\<Longrightarrow>\n    False", "assume \"hindrance ?\\<Gamma> zero_current\""], ["proof (state)\nthis:\n  hindrance (quotient_web \\<Gamma> f) (\\<lambda>_. 0)\n\ngoal (1 subgoal):\n 1. hindrance (quotient_web \\<Gamma> f) (\\<lambda>_. 0) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  hindrance (quotient_web \\<Gamma> f) (\\<lambda>_. 0)", "obtain x where a: \"x \\<in> A ?\\<Gamma>\" and \\<E>: \"x \\<notin> \\<E>\\<^bsub>?\\<Gamma>\\<^esub> (TER\\<^bsub>?\\<Gamma>\\<^esub> zero_current)\"\n      and \"d_OUT zero_current x < weight ?\\<Gamma> x\""], ["proof (prove)\nusing this:\n  hindrance (quotient_web \\<Gamma> f) (\\<lambda>_. 0)\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>x \\<in> A (quotient_web \\<Gamma> f);\n         x \\<notin> \\<E>\\<^bsub>quotient_web \\<Gamma> f\\<^esub>\n                     (TER\\<^bsub>quotient_web \\<Gamma> f\\<^esub>\n                       (\\<lambda>_. 0));\n         d_OUT (\\<lambda>_. 0) x\n         < weight (quotient_web \\<Gamma> f) x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by cases"], ["proof (state)\nthis:\n  x \\<in> A (quotient_web \\<Gamma> f)\n  x \\<notin> \\<E>\\<^bsub>quotient_web \\<Gamma> f\\<^esub>\n              (TER\\<^bsub>quotient_web \\<Gamma> f\\<^esub> (\\<lambda>_. 0))\n  d_OUT (\\<lambda>_. 0) x < weight (quotient_web \\<Gamma> f) x\n\ngoal (1 subgoal):\n 1. hindrance (quotient_web \\<Gamma> f) (\\<lambda>_. 0) \\<Longrightarrow>\n    False", "from a"], ["proof (chain)\npicking this:\n  x \\<in> A (quotient_web \\<Gamma> f)", "have \"x \\<in> \\<E> (TER f)\""], ["proof (prove)\nusing this:\n  x \\<in> A (quotient_web \\<Gamma> f)\n\ngoal (1 subgoal):\n 1. x \\<in> \\<E> (TER f)", "by simp"], ["proof (state)\nthis:\n  x \\<in> \\<E> (TER f)\n\ngoal (1 subgoal):\n 1. hindrance (quotient_web \\<Gamma> f) (\\<lambda>_. 0) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  x \\<in> \\<E> (TER f)", "obtain p y where p: \"path \\<Gamma> x p y\" and y: \"y \\<in> B \\<Gamma>\"\n      and bypass: \"\\<And>z. \\<lbrakk>x \\<noteq> y; z \\<in> set p\\<rbrakk> \\<Longrightarrow> z = x \\<or> z \\<notin> TER f\""], ["proof (prove)\nusing this:\n  x \\<in> \\<E> (TER f)\n\ngoal (1 subgoal):\n 1. (\\<And>p y.\n        \\<lbrakk>path \\<Gamma> x p y; y \\<in> B \\<Gamma>;\n         \\<And>z.\n            \\<lbrakk>x \\<noteq> y; z \\<in> set p\\<rbrakk>\n            \\<Longrightarrow> z = x \\<or> z \\<notin> TER f\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(rule \\<E>_E) blast"], ["proof (state)\nthis:\n  path \\<Gamma> x p y\n  y \\<in> B \\<Gamma>\n  \\<lbrakk>x \\<noteq> y; ?z \\<in> set p\\<rbrakk>\n  \\<Longrightarrow> ?z = x \\<or> ?z \\<notin> TER f\n\ngoal (1 subgoal):\n 1. hindrance (quotient_web \\<Gamma> f) (\\<lambda>_. 0) \\<Longrightarrow>\n    False", "from p"], ["proof (chain)\npicking this:\n  path \\<Gamma> x p y", "obtain p' where p': \"path \\<Gamma> x p' y\" and distinct: \"distinct (x # p')\"\n      and subset: \"set p' \\<subseteq> set p\""], ["proof (prove)\nusing this:\n  path \\<Gamma> x p y\n\ngoal (1 subgoal):\n 1. (\\<And>p'.\n        \\<lbrakk>path \\<Gamma> x p' y; distinct (x # p');\n         set p' \\<subseteq> set p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto elim: rtrancl_path_distinct)"], ["proof (state)\nthis:\n  path \\<Gamma> x p' y\n  distinct (x # p')\n  set p' \\<subseteq> set p\n\ngoal (1 subgoal):\n 1. hindrance (quotient_web \\<Gamma> f) (\\<lambda>_. 0) \\<Longrightarrow>\n    False", "note p'"], ["proof (state)\nthis:\n  path \\<Gamma> x p' y\n\ngoal (1 subgoal):\n 1. hindrance (quotient_web \\<Gamma> f) (\\<lambda>_. 0) \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  path \\<Gamma> x p' y\n\ngoal (1 subgoal):\n 1. hindrance (quotient_web \\<Gamma> f) (\\<lambda>_. 0) \\<Longrightarrow>\n    False", "have RF: \"z \\<notin> RF (TER f)\" if \"z \\<in> set p'\" for z"], ["proof (prove)\ngoal (1 subgoal):\n 1. z \\<notin> RF (TER f)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. z \\<in> RF (TER f) \\<Longrightarrow> False", "assume z: \"z \\<in> RF (TER f)\""], ["proof (state)\nthis:\n  z \\<in> RF (TER f)\n\ngoal (1 subgoal):\n 1. z \\<in> RF (TER f) \\<Longrightarrow> False", "from split_list[OF that]"], ["proof (chain)\npicking this:\n  \\<exists>ys zs. p' = ys @ z # zs", "obtain ys zs where decomp: \"p' = ys @ z # zs\""], ["proof (prove)\nusing this:\n  \\<exists>ys zs. p' = ys @ z # zs\n\ngoal (1 subgoal):\n 1. (\\<And>ys zs.\n        p' = ys @ z # zs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  p' = ys @ z # zs\n\ngoal (1 subgoal):\n 1. z \\<in> RF (TER f) \\<Longrightarrow> False", "with p'"], ["proof (chain)\npicking this:\n  path \\<Gamma> x p' y\n  p' = ys @ z # zs", "have \"y \\<in> set p'\""], ["proof (prove)\nusing this:\n  path \\<Gamma> x p' y\n  p' = ys @ z # zs\n\ngoal (1 subgoal):\n 1. y \\<in> set p'", "by(auto dest!: rtrancl_path_last intro: last_in_set)"], ["proof (state)\nthis:\n  y \\<in> set p'\n\ngoal (1 subgoal):\n 1. z \\<in> RF (TER f) \\<Longrightarrow> False", "with distinct"], ["proof (chain)\npicking this:\n  distinct (x # p')\n  y \\<in> set p'", "have neq: \"x \\<noteq> y\""], ["proof (prove)\nusing this:\n  distinct (x # p')\n  y \\<in> set p'\n\ngoal (1 subgoal):\n 1. x \\<noteq> y", "by auto"], ["proof (state)\nthis:\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. z \\<in> RF (TER f) \\<Longrightarrow> False", "from decomp p'"], ["proof (chain)\npicking this:\n  p' = ys @ z # zs\n  path \\<Gamma> x p' y", "have \"path \\<Gamma> z zs y\""], ["proof (prove)\nusing this:\n  p' = ys @ z # zs\n  path \\<Gamma> x p' y\n\ngoal (1 subgoal):\n 1. path \\<Gamma> z zs y", "by(auto elim: rtrancl_path_appendE)"], ["proof (state)\nthis:\n  path \\<Gamma> z zs y\n\ngoal (1 subgoal):\n 1. z \\<in> RF (TER f) \\<Longrightarrow> False", "from roofedD[OF z this y]"], ["proof (chain)\npicking this:\n  (\\<exists>z\\<in>set zs. z \\<in> TER f) \\<or> z \\<in> TER f", "obtain z' where \"z' \\<in> set (z # zs)\" \"z' \\<in> TER f\""], ["proof (prove)\nusing this:\n  (\\<exists>z\\<in>set zs. z \\<in> TER f) \\<or> z \\<in> TER f\n\ngoal (1 subgoal):\n 1. (\\<And>z'.\n        \\<lbrakk>z' \\<in> set (z # zs); z' \\<in> TER f\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  z' \\<in> set (z # zs)\n  z' \\<in> TER f\n\ngoal (1 subgoal):\n 1. z \\<in> RF (TER f) \\<Longrightarrow> False", "with distinct decomp subset bypass[OF neq]"], ["proof (chain)\npicking this:\n  distinct (x # p')\n  p' = ys @ z # zs\n  set p' \\<subseteq> set p\n  ?z \\<in> set p \\<Longrightarrow> ?z = x \\<or> ?z \\<notin> TER f\n  z' \\<in> set (z # zs)\n  z' \\<in> TER f", "show False"], ["proof (prove)\nusing this:\n  distinct (x # p')\n  p' = ys @ z # zs\n  set p' \\<subseteq> set p\n  ?z \\<in> set p \\<Longrightarrow> ?z = x \\<or> ?z \\<notin> TER f\n  z' \\<in> set (z # zs)\n  z' \\<in> TER f\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?z \\<in> set p' \\<Longrightarrow> ?z \\<notin> RF (TER f)\n\ngoal (1 subgoal):\n 1. hindrance (quotient_web \\<Gamma> f) (\\<lambda>_. 0) \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  ?z \\<in> set p' \\<Longrightarrow> ?z \\<notin> RF (TER f)\n\ngoal (1 subgoal):\n 1. hindrance (quotient_web \\<Gamma> f) (\\<lambda>_. 0) \\<Longrightarrow>\n    False", "have \"x \\<notin> RF\\<^sup>\\<circ> (TER f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> RF\\<^sup>\\<circ> (TER f)", "using \\<open>x \\<in> \\<E> (TER f)\\<close>"], ["proof (prove)\nusing this:\n  x \\<in> \\<E> (TER f)\n\ngoal (1 subgoal):\n 1. x \\<notin> RF\\<^sup>\\<circ> (TER f)", "by(simp add: roofed_circ_def)"], ["proof (state)\nthis:\n  x \\<notin> RF\\<^sup>\\<circ> (TER f)\n\ngoal (1 subgoal):\n 1. hindrance (quotient_web \\<Gamma> f) (\\<lambda>_. 0) \\<Longrightarrow>\n    False", "ultimately"], ["proof (chain)\npicking this:\n  path \\<Gamma> x p' y\n  ?z \\<in> set p' \\<Longrightarrow> ?z \\<notin> RF (TER f)\n  x \\<notin> RF\\<^sup>\\<circ> (TER f)", "have p'': \"path ?\\<Gamma> x p' y\""], ["proof (prove)\nusing this:\n  path \\<Gamma> x p' y\n  ?z \\<in> set p' \\<Longrightarrow> ?z \\<notin> RF (TER f)\n  x \\<notin> RF\\<^sup>\\<circ> (TER f)\n\ngoal (1 subgoal):\n 1. path (quotient_web \\<Gamma> f) x p' y", "by(induction)(auto intro: rtrancl_path.intros simp add: roofed_circ_def)"], ["proof (state)\nthis:\n  path (quotient_web \\<Gamma> f) x p' y\n\ngoal (1 subgoal):\n 1. hindrance (quotient_web \\<Gamma> f) (\\<lambda>_. 0) \\<Longrightarrow>\n    False", "from a \\<E>"], ["proof (chain)\npicking this:\n  x \\<in> A (quotient_web \\<Gamma> f)\n  x \\<notin> \\<E>\\<^bsub>quotient_web \\<Gamma> f\\<^esub>\n              (TER\\<^bsub>quotient_web \\<Gamma> f\\<^esub> (\\<lambda>_. 0))", "have \"\\<not> essential ?\\<Gamma> (B ?\\<Gamma>) (TER\\<^bsub>?\\<Gamma>\\<^esub> zero_current) x\""], ["proof (prove)\nusing this:\n  x \\<in> A (quotient_web \\<Gamma> f)\n  x \\<notin> \\<E>\\<^bsub>quotient_web \\<Gamma> f\\<^esub>\n              (TER\\<^bsub>quotient_web \\<Gamma> f\\<^esub> (\\<lambda>_. 0))\n\ngoal (1 subgoal):\n 1. \\<not> essential (quotient_web \\<Gamma> f) (B (quotient_web \\<Gamma> f))\n            (TER\\<^bsub>quotient_web \\<Gamma> f\\<^esub> (\\<lambda>_. 0)) x", "by simp"], ["proof (state)\nthis:\n  \\<not> essential (quotient_web \\<Gamma> f) (B (quotient_web \\<Gamma> f))\n          (TER\\<^bsub>quotient_web \\<Gamma> f\\<^esub> (\\<lambda>_. 0)) x\n\ngoal (1 subgoal):\n 1. hindrance (quotient_web \\<Gamma> f) (\\<lambda>_. 0) \\<Longrightarrow>\n    False", "from not_essentialD[OF this p''] y"], ["proof (chain)\npicking this:\n  y \\<in> B (quotient_web \\<Gamma> f) \\<Longrightarrow>\n  x \\<noteq> y \\<and>\n  (\\<exists>z\\<in>set p'.\n      z \\<noteq> x \\<and>\n      z \\<in> TER\\<^bsub>quotient_web \\<Gamma> f\\<^esub> (\\<lambda>_. 0))\n  y \\<in> B \\<Gamma>", "obtain z where neq: \"x \\<noteq> y\"\n      and \"z \\<in> set p'\" \"z \\<noteq> x\" \"z \\<in> TER\\<^bsub>?\\<Gamma>\\<^esub> zero_current\""], ["proof (prove)\nusing this:\n  y \\<in> B (quotient_web \\<Gamma> f) \\<Longrightarrow>\n  x \\<noteq> y \\<and>\n  (\\<exists>z\\<in>set p'.\n      z \\<noteq> x \\<and>\n      z \\<in> TER\\<^bsub>quotient_web \\<Gamma> f\\<^esub> (\\<lambda>_. 0))\n  y \\<in> B \\<Gamma>\n\ngoal (1 subgoal):\n 1. (\\<And>z.\n        \\<lbrakk>x \\<noteq> y; z \\<in> set p'; z \\<noteq> x;\n         z \\<in> TER\\<^bsub>quotient_web \\<Gamma> f\\<^esub>\n                  (\\<lambda>_. 0)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  x \\<noteq> y\n  z \\<in> set p'\n  z \\<noteq> x\n  z \\<in> TER\\<^bsub>quotient_web \\<Gamma> f\\<^esub> (\\<lambda>_. 0)\n\ngoal (1 subgoal):\n 1. hindrance (quotient_web \\<Gamma> f) (\\<lambda>_. 0) \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  x \\<noteq> y\n  z \\<in> set p'\n  z \\<noteq> x\n  z \\<in> TER\\<^bsub>quotient_web \\<Gamma> f\\<^esub> (\\<lambda>_. 0)\n\ngoal (1 subgoal):\n 1. hindrance (quotient_web \\<Gamma> f) (\\<lambda>_. 0) \\<Longrightarrow>\n    False", "with subset RF[of z]"], ["proof (chain)\npicking this:\n  set p' \\<subseteq> set p\n  z \\<in> set p' \\<Longrightarrow> z \\<notin> RF (TER f)\n  x \\<noteq> y\n  z \\<in> set p'\n  z \\<noteq> x\n  z \\<in> TER\\<^bsub>quotient_web \\<Gamma> f\\<^esub> (\\<lambda>_. 0)", "have \"z \\<in> TER f\""], ["proof (prove)\nusing this:\n  set p' \\<subseteq> set p\n  z \\<in> set p' \\<Longrightarrow> z \\<notin> RF (TER f)\n  x \\<noteq> y\n  z \\<in> set p'\n  z \\<noteq> x\n  z \\<in> TER\\<^bsub>quotient_web \\<Gamma> f\\<^esub> (\\<lambda>_. 0)\n\ngoal (1 subgoal):\n 1. z \\<in> TER f", "using currentD_weight_OUT[OF f, of z] currentD_weight_IN[OF f, of z]"], ["proof (prove)\nusing this:\n  set p' \\<subseteq> set p\n  z \\<in> set p' \\<Longrightarrow> z \\<notin> RF (TER f)\n  x \\<noteq> y\n  z \\<in> set p'\n  z \\<noteq> x\n  z \\<in> TER\\<^bsub>quotient_web \\<Gamma> f\\<^esub> (\\<lambda>_. 0)\n  d_OUT f z \\<le> weight \\<Gamma> z\n  d_IN f z \\<le> weight \\<Gamma> z\n\ngoal (1 subgoal):\n 1. z \\<in> TER f", "by(auto simp add: roofed_circ_def SINK.simps intro: SAT.IN split: if_split_asm)"], ["proof (state)\nthis:\n  z \\<in> TER f\n\ngoal (1 subgoal):\n 1. hindrance (quotient_web \\<Gamma> f) (\\<lambda>_. 0) \\<Longrightarrow>\n    False", "ultimately"], ["proof (chain)\npicking this:\n  x \\<noteq> y\n  z \\<in> set p'\n  z \\<noteq> x\n  z \\<in> TER\\<^bsub>quotient_web \\<Gamma> f\\<^esub> (\\<lambda>_. 0)\n  z \\<in> TER f", "show False"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  z \\<in> set p'\n  z \\<noteq> x\n  z \\<in> TER\\<^bsub>quotient_web \\<Gamma> f\\<^esub> (\\<lambda>_. 0)\n  z \\<in> TER f\n\ngoal (1 subgoal):\n 1. False", "using bypass[of z] subset"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  z \\<in> set p'\n  z \\<noteq> x\n  z \\<in> TER\\<^bsub>quotient_web \\<Gamma> f\\<^esub> (\\<lambda>_. 0)\n  z \\<in> TER f\n  \\<lbrakk>x \\<noteq> y; z \\<in> set p\\<rbrakk>\n  \\<Longrightarrow> z = x \\<or> z \\<notin> TER f\n  set p' \\<subseteq> set p\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> hindrance (quotient_web \\<Gamma> f) (\\<lambda>_. 0)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma quotient_web_trimming:\n  fixes \\<Gamma> (structure)\n  assumes w: \"wave \\<Gamma> f\"\n  and trimming: \"trimming \\<Gamma> f g\"\n  shows \"quotient_web \\<Gamma> f = quotient_web \\<Gamma> g\" (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. quotient_web \\<Gamma> f = quotient_web \\<Gamma> g", "proof(rule web.equality)"], ["proof (state)\ngoal (5 subgoals):\n 1. edge (quotient_web \\<Gamma> f) = edge (quotient_web \\<Gamma> g)\n 2. weight (quotient_web \\<Gamma> f) = weight (quotient_web \\<Gamma> g)\n 3. A (quotient_web \\<Gamma> f) = A (quotient_web \\<Gamma> g)\n 4. B (quotient_web \\<Gamma> f) = B (quotient_web \\<Gamma> g)\n 5. web.more (quotient_web \\<Gamma> f) = web.more (quotient_web \\<Gamma> g)", "from trimming"], ["proof (chain)\npicking this:\n  trimming \\<Gamma> f g", "have \\<E>: \"\\<E> (TER g) - A \\<Gamma> = \\<E> (TER f) - A \\<Gamma>\""], ["proof (prove)\nusing this:\n  trimming \\<Gamma> f g\n\ngoal (1 subgoal):\n 1. \\<E> (TER g) - A \\<Gamma> = \\<E> (TER f) - A \\<Gamma>", "by cases"], ["proof (state)\nthis:\n  \\<E> (TER g) - A \\<Gamma> = \\<E> (TER f) - A \\<Gamma>\n\ngoal (5 subgoals):\n 1. edge (quotient_web \\<Gamma> f) = edge (quotient_web \\<Gamma> g)\n 2. weight (quotient_web \\<Gamma> f) = weight (quotient_web \\<Gamma> g)\n 3. A (quotient_web \\<Gamma> f) = A (quotient_web \\<Gamma> g)\n 4. B (quotient_web \\<Gamma> f) = B (quotient_web \\<Gamma> g)\n 5. web.more (quotient_web \\<Gamma> f) = web.more (quotient_web \\<Gamma> g)", "have RF: \"RF (TER g) = RF (TER f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RF (TER g) = RF (TER f)", "by(subst (1 2) RF_essential[symmetric])(simp only: trimming_\\<E>[OF w trimming])"], ["proof (state)\nthis:\n  RF (TER g) = RF (TER f)\n\ngoal (5 subgoals):\n 1. edge (quotient_web \\<Gamma> f) = edge (quotient_web \\<Gamma> g)\n 2. weight (quotient_web \\<Gamma> f) = weight (quotient_web \\<Gamma> g)\n 3. A (quotient_web \\<Gamma> f) = A (quotient_web \\<Gamma> g)\n 4. B (quotient_web \\<Gamma> f) = B (quotient_web \\<Gamma> g)\n 5. web.more (quotient_web \\<Gamma> f) = web.more (quotient_web \\<Gamma> g)", "have RFc: \"RF\\<^sup>\\<circ> (TER g) = RF\\<^sup>\\<circ> (TER f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RF\\<^sup>\\<circ> (TER g) = RF\\<^sup>\\<circ> (TER f)", "by(subst (1 2) roofed_circ_essential[symmetric])(simp only: trimming_\\<E>[OF w trimming])"], ["proof (state)\nthis:\n  RF\\<^sup>\\<circ> (TER g) = RF\\<^sup>\\<circ> (TER f)\n\ngoal (5 subgoals):\n 1. edge (quotient_web \\<Gamma> f) = edge (quotient_web \\<Gamma> g)\n 2. weight (quotient_web \\<Gamma> f) = weight (quotient_web \\<Gamma> g)\n 3. A (quotient_web \\<Gamma> f) = A (quotient_web \\<Gamma> g)\n 4. B (quotient_web \\<Gamma> f) = B (quotient_web \\<Gamma> g)\n 5. web.more (quotient_web \\<Gamma> f) = web.more (quotient_web \\<Gamma> g)", "show \"edge ?lhs = edge ?rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. edge (quotient_web \\<Gamma> f) = edge (quotient_web \\<Gamma> g)", "by(rule ext)+(simp add: RF RFc)"], ["proof (state)\nthis:\n  edge (quotient_web \\<Gamma> f) = edge (quotient_web \\<Gamma> g)\n\ngoal (4 subgoals):\n 1. weight (quotient_web \\<Gamma> f) = weight (quotient_web \\<Gamma> g)\n 2. A (quotient_web \\<Gamma> f) = A (quotient_web \\<Gamma> g)\n 3. B (quotient_web \\<Gamma> f) = B (quotient_web \\<Gamma> g)\n 4. web.more (quotient_web \\<Gamma> f) = web.more (quotient_web \\<Gamma> g)", "have \"weight ?lhs = (\\<lambda>x. if x \\<in> RF\\<^sup>\\<circ> (TER g) \\<or> x \\<in> RF (TER g) \\<inter> B \\<Gamma> then 0 else weight \\<Gamma> x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. weight (quotient_web \\<Gamma> f) =\n    (\\<lambda>x.\n        if x \\<in> RF\\<^sup>\\<circ> (TER g) \\<or>\n           x \\<in> RF (TER g) \\<inter> B \\<Gamma>\n        then 0 else weight \\<Gamma> x)", "unfolding RF RFc"], ["proof (prove)\ngoal (1 subgoal):\n 1. weight (quotient_web \\<Gamma> f) =\n    (\\<lambda>x.\n        if x \\<in> RF\\<^sup>\\<circ> (TER f) \\<or>\n           x \\<in> RF (TER f) \\<inter> B \\<Gamma>\n        then 0 else weight \\<Gamma> x)", "by(auto simp add: fun_eq_iff RF_in_B)"], ["proof (state)\nthis:\n  weight (quotient_web \\<Gamma> f) =\n  (\\<lambda>x.\n      if x \\<in> RF\\<^sup>\\<circ> (TER g) \\<or>\n         x \\<in> RF (TER g) \\<inter> B \\<Gamma>\n      then 0 else weight \\<Gamma> x)\n\ngoal (4 subgoals):\n 1. weight (quotient_web \\<Gamma> f) = weight (quotient_web \\<Gamma> g)\n 2. A (quotient_web \\<Gamma> f) = A (quotient_web \\<Gamma> g)\n 3. B (quotient_web \\<Gamma> f) = B (quotient_web \\<Gamma> g)\n 4. web.more (quotient_web \\<Gamma> f) = web.more (quotient_web \\<Gamma> g)", "also"], ["proof (state)\nthis:\n  weight (quotient_web \\<Gamma> f) =\n  (\\<lambda>x.\n      if x \\<in> RF\\<^sup>\\<circ> (TER g) \\<or>\n         x \\<in> RF (TER g) \\<inter> B \\<Gamma>\n      then 0 else weight \\<Gamma> x)\n\ngoal (4 subgoals):\n 1. weight (quotient_web \\<Gamma> f) = weight (quotient_web \\<Gamma> g)\n 2. A (quotient_web \\<Gamma> f) = A (quotient_web \\<Gamma> g)\n 3. B (quotient_web \\<Gamma> f) = B (quotient_web \\<Gamma> g)\n 4. web.more (quotient_web \\<Gamma> f) = web.more (quotient_web \\<Gamma> g)", "have \"\\<dots> = weight ?rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x.\n        if x \\<in> RF\\<^sup>\\<circ> (TER g) \\<or>\n           x \\<in> RF (TER g) \\<inter> B \\<Gamma>\n        then 0 else weight \\<Gamma> x) =\n    weight (quotient_web \\<Gamma> g)", "by(auto simp add: fun_eq_iff RF_in_B)"], ["proof (state)\nthis:\n  (\\<lambda>x.\n      if x \\<in> RF\\<^sup>\\<circ> (TER g) \\<or>\n         x \\<in> RF (TER g) \\<inter> B \\<Gamma>\n      then 0 else weight \\<Gamma> x) =\n  weight (quotient_web \\<Gamma> g)\n\ngoal (4 subgoals):\n 1. weight (quotient_web \\<Gamma> f) = weight (quotient_web \\<Gamma> g)\n 2. A (quotient_web \\<Gamma> f) = A (quotient_web \\<Gamma> g)\n 3. B (quotient_web \\<Gamma> f) = B (quotient_web \\<Gamma> g)\n 4. web.more (quotient_web \\<Gamma> f) = web.more (quotient_web \\<Gamma> g)", "finally"], ["proof (chain)\npicking this:\n  weight (quotient_web \\<Gamma> f) = weight (quotient_web \\<Gamma> g)", "show \"weight ?lhs = weight ?rhs\""], ["proof (prove)\nusing this:\n  weight (quotient_web \\<Gamma> f) = weight (quotient_web \\<Gamma> g)\n\ngoal (1 subgoal):\n 1. weight (quotient_web \\<Gamma> f) = weight (quotient_web \\<Gamma> g)", "."], ["proof (state)\nthis:\n  weight (quotient_web \\<Gamma> f) = weight (quotient_web \\<Gamma> g)\n\ngoal (3 subgoals):\n 1. A (quotient_web \\<Gamma> f) = A (quotient_web \\<Gamma> g)\n 2. B (quotient_web \\<Gamma> f) = B (quotient_web \\<Gamma> g)\n 3. web.more (quotient_web \\<Gamma> f) = web.more (quotient_web \\<Gamma> g)", "show \"A ?lhs = A ?rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A (quotient_web \\<Gamma> f) = A (quotient_web \\<Gamma> g)", "unfolding quotient_web_sel trimming_\\<E>[OF w trimming]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<E> (TER g) - (B \\<Gamma> - A \\<Gamma>) =\n    \\<E> (TER g) - (B \\<Gamma> - A \\<Gamma>)", ".."], ["proof (state)\nthis:\n  A (quotient_web \\<Gamma> f) = A (quotient_web \\<Gamma> g)\n\ngoal (2 subgoals):\n 1. B (quotient_web \\<Gamma> f) = B (quotient_web \\<Gamma> g)\n 2. web.more (quotient_web \\<Gamma> f) = web.more (quotient_web \\<Gamma> g)", "qed simp_all"], ["", "subsection \\<open>Well-formed webs\\<close>"], ["", "locale web =\n  fixes \\<Gamma> :: \"('v, 'more) web_scheme\" (structure)\n  assumes A_in: \"x \\<in> A \\<Gamma> \\<Longrightarrow> \\<not> edge \\<Gamma> y x\"\n  and B_out: \"x \\<in> B \\<Gamma> \\<Longrightarrow> \\<not> edge \\<Gamma> x y\"\n  and A_vertex: \"A \\<Gamma> \\<subseteq> \\<^bold>V\"\n  and disjoint: \"A \\<Gamma> \\<inter> B \\<Gamma> = {}\"\n  and no_loop: \"\\<And>x. \\<not> edge \\<Gamma> x x\"\n  and weight_outside: \"\\<And>x. x \\<notin> \\<^bold>V \\<Longrightarrow> weight \\<Gamma> x = 0\"\n  and weight_finite [simp]: \"\\<And>x. weight \\<Gamma> x \\<noteq> \\<top>\"\nbegin"], ["", "lemma web_weight_update:\n  assumes \"\\<And>x. \\<not> vertex \\<Gamma> x \\<Longrightarrow> w x = 0\"\n  and \"\\<And>x. w x \\<noteq> \\<top>\"\n  shows \"web (\\<Gamma>\\<lparr>weight := w\\<rparr>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. web (\\<Gamma>\\<lparr>weight := w\\<rparr>)", "by unfold_locales(simp_all add: A_in B_out A_vertex disjoint no_loop assms)"], ["", "lemma currentI [intro?]:\n  assumes \"\\<And>x. d_OUT f x \\<le> weight \\<Gamma> x\"\n  and \"\\<And>x. d_IN f x \\<le> weight \\<Gamma> x\"\n  and OUT_IN: \"\\<And>x. \\<lbrakk> x \\<notin> A \\<Gamma>; x \\<notin> B \\<Gamma> \\<rbrakk> \\<Longrightarrow> d_OUT f x \\<le> d_IN f x\"\n  and outside: \"\\<And>e. e \\<notin> \\<^bold>E \\<Longrightarrow> f e = 0\"\n  shows \"current \\<Gamma> f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. current \\<Gamma> f", "proof"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>x. d_OUT f x \\<le> weight \\<Gamma> x\n 2. \\<And>x. d_IN f x \\<le> weight \\<Gamma> x\n 3. \\<And>x.\n       x \\<notin> A \\<Gamma> \\<Longrightarrow> d_OUT f x \\<le> d_IN f x\n 4. \\<And>a. a \\<in> A \\<Gamma> \\<Longrightarrow> d_IN f a = 0\n 5. \\<And>b. b \\<in> B \\<Gamma> \\<Longrightarrow> d_OUT f b = 0\n 6. \\<And>e. e \\<notin> \\<^bold>E \\<Longrightarrow> f e = 0", "show \"d_IN f a = 0\" if \"a \\<in> A \\<Gamma>\" for a"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN f a = 0", "using that"], ["proof (prove)\nusing this:\n  a \\<in> A \\<Gamma>\n\ngoal (1 subgoal):\n 1. d_IN f a = 0", "by(auto simp add: d_IN_def nn_integral_0_iff emeasure_count_space_eq_0 A_in intro: outside)"], ["proof (state)\nthis:\n  ?a \\<in> A \\<Gamma> \\<Longrightarrow> d_IN f ?a = 0\n\ngoal (5 subgoals):\n 1. \\<And>x. d_OUT f x \\<le> weight \\<Gamma> x\n 2. \\<And>x. d_IN f x \\<le> weight \\<Gamma> x\n 3. \\<And>x.\n       x \\<notin> A \\<Gamma> \\<Longrightarrow> d_OUT f x \\<le> d_IN f x\n 4. \\<And>b. b \\<in> B \\<Gamma> \\<Longrightarrow> d_OUT f b = 0\n 5. \\<And>e. e \\<notin> \\<^bold>E \\<Longrightarrow> f e = 0", "show \"d_OUT f b = 0\" if \"b \\<in> B \\<Gamma>\" for b"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT f b = 0", "using that"], ["proof (prove)\nusing this:\n  b \\<in> B \\<Gamma>\n\ngoal (1 subgoal):\n 1. d_OUT f b = 0", "by(auto simp add: d_OUT_def nn_integral_0_iff emeasure_count_space_eq_0 B_out intro: outside)"], ["proof (state)\nthis:\n  ?b \\<in> B \\<Gamma> \\<Longrightarrow> d_OUT f ?b = 0\n\ngoal (4 subgoals):\n 1. \\<And>x. d_OUT f x \\<le> weight \\<Gamma> x\n 2. \\<And>x. d_IN f x \\<le> weight \\<Gamma> x\n 3. \\<And>x.\n       x \\<notin> A \\<Gamma> \\<Longrightarrow> d_OUT f x \\<le> d_IN f x\n 4. \\<And>e. e \\<notin> \\<^bold>E \\<Longrightarrow> f e = 0", "then"], ["proof (chain)\npicking this:\n  ?b \\<in> B \\<Gamma> \\<Longrightarrow> d_OUT f ?b = 0", "show \"d_OUT f x \\<le> d_IN f x\" if \"x \\<notin> A \\<Gamma>\" for x"], ["proof (prove)\nusing this:\n  ?b \\<in> B \\<Gamma> \\<Longrightarrow> d_OUT f ?b = 0\n\ngoal (1 subgoal):\n 1. d_OUT f x \\<le> d_IN f x", "using OUT_IN[OF that]"], ["proof (prove)\nusing this:\n  ?b \\<in> B \\<Gamma> \\<Longrightarrow> d_OUT f ?b = 0\n  x \\<notin> B \\<Gamma> \\<Longrightarrow> d_OUT f x \\<le> d_IN f x\n\ngoal (1 subgoal):\n 1. d_OUT f x \\<le> d_IN f x", "by(cases \"x \\<in> B \\<Gamma>\") auto"], ["proof (state)\nthis:\n  ?x \\<notin> A \\<Gamma> \\<Longrightarrow> d_OUT f ?x \\<le> d_IN f ?x\n\ngoal (3 subgoals):\n 1. \\<And>x. d_OUT f x \\<le> weight \\<Gamma> x\n 2. \\<And>x. d_IN f x \\<le> weight \\<Gamma> x\n 3. \\<And>e. e \\<notin> \\<^bold>E \\<Longrightarrow> f e = 0", "qed(blast intro: assms)+"], ["", "lemma currentD_finite_IN:\n  assumes f: \"current \\<Gamma> f\"\n  shows \"d_IN f x \\<noteq> \\<top>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN f x \\<noteq> \\<top>", "proof(cases \"x \\<in> \\<^bold>V\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<in> \\<^bold>V \\<Longrightarrow> d_IN f x \\<noteq> \\<top>\n 2. x \\<notin> \\<^bold>V \\<Longrightarrow> d_IN f x \\<noteq> \\<top>", "case True"], ["proof (state)\nthis:\n  x \\<in> \\<^bold>V\n\ngoal (2 subgoals):\n 1. x \\<in> \\<^bold>V \\<Longrightarrow> d_IN f x \\<noteq> \\<top>\n 2. x \\<notin> \\<^bold>V \\<Longrightarrow> d_IN f x \\<noteq> \\<top>", "have \"d_IN f x \\<le> weight \\<Gamma> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN f x \\<le> weight \\<Gamma> x", "using f"], ["proof (prove)\nusing this:\n  current \\<Gamma> f\n\ngoal (1 subgoal):\n 1. d_IN f x \\<le> weight \\<Gamma> x", "by(rule currentD_weight_IN)"], ["proof (state)\nthis:\n  d_IN f x \\<le> weight \\<Gamma> x\n\ngoal (2 subgoals):\n 1. x \\<in> \\<^bold>V \\<Longrightarrow> d_IN f x \\<noteq> \\<top>\n 2. x \\<notin> \\<^bold>V \\<Longrightarrow> d_IN f x \\<noteq> \\<top>", "also"], ["proof (state)\nthis:\n  d_IN f x \\<le> weight \\<Gamma> x\n\ngoal (2 subgoals):\n 1. x \\<in> \\<^bold>V \\<Longrightarrow> d_IN f x \\<noteq> \\<top>\n 2. x \\<notin> \\<^bold>V \\<Longrightarrow> d_IN f x \\<noteq> \\<top>", "have \"\\<dots> < \\<top>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. weight \\<Gamma> x < \\<top>", "using True weight_finite[of x]"], ["proof (prove)\nusing this:\n  x \\<in> \\<^bold>V\n  weight \\<Gamma> x \\<noteq> \\<top>\n\ngoal (1 subgoal):\n 1. weight \\<Gamma> x < \\<top>", "by (simp add: less_top[symmetric])"], ["proof (state)\nthis:\n  weight \\<Gamma> x < \\<top>\n\ngoal (2 subgoals):\n 1. x \\<in> \\<^bold>V \\<Longrightarrow> d_IN f x \\<noteq> \\<top>\n 2. x \\<notin> \\<^bold>V \\<Longrightarrow> d_IN f x \\<noteq> \\<top>", "finally"], ["proof (chain)\npicking this:\n  d_IN f x < \\<top>", "show ?thesis"], ["proof (prove)\nusing this:\n  d_IN f x < \\<top>\n\ngoal (1 subgoal):\n 1. d_IN f x \\<noteq> \\<top>", "by simp"], ["proof (state)\nthis:\n  d_IN f x \\<noteq> \\<top>\n\ngoal (1 subgoal):\n 1. x \\<notin> \\<^bold>V \\<Longrightarrow> d_IN f x \\<noteq> \\<top>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<notin> \\<^bold>V \\<Longrightarrow> d_IN f x \\<noteq> \\<top>", "case False"], ["proof (state)\nthis:\n  x \\<notin> \\<^bold>V\n\ngoal (1 subgoal):\n 1. x \\<notin> \\<^bold>V \\<Longrightarrow> d_IN f x \\<noteq> \\<top>", "then"], ["proof (chain)\npicking this:\n  x \\<notin> \\<^bold>V", "have \"d_IN f x = 0\""], ["proof (prove)\nusing this:\n  x \\<notin> \\<^bold>V\n\ngoal (1 subgoal):\n 1. d_IN f x = 0", "by(auto simp add: d_IN_def nn_integral_0_iff emeasure_count_space_eq_0 vertex_def intro: currentD_outside[OF f])"], ["proof (state)\nthis:\n  d_IN f x = 0\n\ngoal (1 subgoal):\n 1. x \\<notin> \\<^bold>V \\<Longrightarrow> d_IN f x \\<noteq> \\<top>", "thus ?thesis"], ["proof (prove)\nusing this:\n  d_IN f x = 0\n\ngoal (1 subgoal):\n 1. d_IN f x \\<noteq> \\<top>", "by simp"], ["proof (state)\nthis:\n  d_IN f x \\<noteq> \\<top>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma currentD_finite_OUT:\n  assumes f: \"current \\<Gamma> f\"\n  shows \"d_OUT f x \\<noteq> \\<top>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT f x \\<noteq> \\<top>", "proof(cases \"x \\<in> \\<^bold>V\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<in> \\<^bold>V \\<Longrightarrow> d_OUT f x \\<noteq> \\<top>\n 2. x \\<notin> \\<^bold>V \\<Longrightarrow> d_OUT f x \\<noteq> \\<top>", "case True"], ["proof (state)\nthis:\n  x \\<in> \\<^bold>V\n\ngoal (2 subgoals):\n 1. x \\<in> \\<^bold>V \\<Longrightarrow> d_OUT f x \\<noteq> \\<top>\n 2. x \\<notin> \\<^bold>V \\<Longrightarrow> d_OUT f x \\<noteq> \\<top>", "have \"d_OUT f x \\<le> weight \\<Gamma> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT f x \\<le> weight \\<Gamma> x", "using f"], ["proof (prove)\nusing this:\n  current \\<Gamma> f\n\ngoal (1 subgoal):\n 1. d_OUT f x \\<le> weight \\<Gamma> x", "by(rule currentD_weight_OUT)"], ["proof (state)\nthis:\n  d_OUT f x \\<le> weight \\<Gamma> x\n\ngoal (2 subgoals):\n 1. x \\<in> \\<^bold>V \\<Longrightarrow> d_OUT f x \\<noteq> \\<top>\n 2. x \\<notin> \\<^bold>V \\<Longrightarrow> d_OUT f x \\<noteq> \\<top>", "also"], ["proof (state)\nthis:\n  d_OUT f x \\<le> weight \\<Gamma> x\n\ngoal (2 subgoals):\n 1. x \\<in> \\<^bold>V \\<Longrightarrow> d_OUT f x \\<noteq> \\<top>\n 2. x \\<notin> \\<^bold>V \\<Longrightarrow> d_OUT f x \\<noteq> \\<top>", "have \"\\<dots> < \\<top>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. weight \\<Gamma> x < \\<top>", "using True weight_finite[of x]"], ["proof (prove)\nusing this:\n  x \\<in> \\<^bold>V\n  weight \\<Gamma> x \\<noteq> \\<top>\n\ngoal (1 subgoal):\n 1. weight \\<Gamma> x < \\<top>", "by (simp add: less_top[symmetric])"], ["proof (state)\nthis:\n  weight \\<Gamma> x < \\<top>\n\ngoal (2 subgoals):\n 1. x \\<in> \\<^bold>V \\<Longrightarrow> d_OUT f x \\<noteq> \\<top>\n 2. x \\<notin> \\<^bold>V \\<Longrightarrow> d_OUT f x \\<noteq> \\<top>", "finally"], ["proof (chain)\npicking this:\n  d_OUT f x < \\<top>", "show ?thesis"], ["proof (prove)\nusing this:\n  d_OUT f x < \\<top>\n\ngoal (1 subgoal):\n 1. d_OUT f x \\<noteq> \\<top>", "by simp"], ["proof (state)\nthis:\n  d_OUT f x \\<noteq> \\<top>\n\ngoal (1 subgoal):\n 1. x \\<notin> \\<^bold>V \\<Longrightarrow> d_OUT f x \\<noteq> \\<top>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<notin> \\<^bold>V \\<Longrightarrow> d_OUT f x \\<noteq> \\<top>", "case False"], ["proof (state)\nthis:\n  x \\<notin> \\<^bold>V\n\ngoal (1 subgoal):\n 1. x \\<notin> \\<^bold>V \\<Longrightarrow> d_OUT f x \\<noteq> \\<top>", "then"], ["proof (chain)\npicking this:\n  x \\<notin> \\<^bold>V", "have \"d_OUT f x = 0\""], ["proof (prove)\nusing this:\n  x \\<notin> \\<^bold>V\n\ngoal (1 subgoal):\n 1. d_OUT f x = 0", "by(auto simp add: d_OUT_def nn_integral_0_iff emeasure_count_space_eq_0 vertex_def intro: currentD_outside[OF f])"], ["proof (state)\nthis:\n  d_OUT f x = 0\n\ngoal (1 subgoal):\n 1. x \\<notin> \\<^bold>V \\<Longrightarrow> d_OUT f x \\<noteq> \\<top>", "thus ?thesis"], ["proof (prove)\nusing this:\n  d_OUT f x = 0\n\ngoal (1 subgoal):\n 1. d_OUT f x \\<noteq> \\<top>", "by simp"], ["proof (state)\nthis:\n  d_OUT f x \\<noteq> \\<top>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma currentD_finite:\n  assumes f: \"current \\<Gamma> f\"\n  shows \"f e \\<noteq> \\<top>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f e \\<noteq> \\<top>", "proof(cases e)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b. e = (a, b) \\<Longrightarrow> f e \\<noteq> \\<top>", "case (Pair x y)"], ["proof (state)\nthis:\n  e = (x, y)\n\ngoal (1 subgoal):\n 1. \\<And>a b. e = (a, b) \\<Longrightarrow> f e \\<noteq> \\<top>", "have \"f (x, y) \\<le> d_OUT f x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f (x, y) \\<le> d_OUT f x", "by (rule d_OUT_ge_point)"], ["proof (state)\nthis:\n  f (x, y) \\<le> d_OUT f x\n\ngoal (1 subgoal):\n 1. \\<And>a b. e = (a, b) \\<Longrightarrow> f e \\<noteq> \\<top>", "also"], ["proof (state)\nthis:\n  f (x, y) \\<le> d_OUT f x\n\ngoal (1 subgoal):\n 1. \\<And>a b. e = (a, b) \\<Longrightarrow> f e \\<noteq> \\<top>", "have \"\\<dots> < \\<top>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT f x < \\<top>", "using currentD_finite_OUT[OF f]"], ["proof (prove)\nusing this:\n  d_OUT f ?x \\<noteq> \\<top>\n\ngoal (1 subgoal):\n 1. d_OUT f x < \\<top>", "by (simp add: less_top[symmetric])"], ["proof (state)\nthis:\n  d_OUT f x < \\<top>\n\ngoal (1 subgoal):\n 1. \\<And>a b. e = (a, b) \\<Longrightarrow> f e \\<noteq> \\<top>", "finally"], ["proof (chain)\npicking this:\n  f (x, y) < \\<top>", "show ?thesis"], ["proof (prove)\nusing this:\n  f (x, y) < \\<top>\n\ngoal (1 subgoal):\n 1. f e \\<noteq> \\<top>", "by(simp add: Pair)"], ["proof (state)\nthis:\n  f e \\<noteq> \\<top>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma web_quotient_web: \"web (quotient_web \\<Gamma> f)\" (is \"web ?\\<Gamma>\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. web (quotient_web \\<Gamma> f)", "proof"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>x y.\n       x \\<in> A (quotient_web \\<Gamma> f) \\<Longrightarrow>\n       \\<not> edge (quotient_web \\<Gamma> f) y x\n 2. \\<And>x y.\n       x \\<in> B (quotient_web \\<Gamma> f) \\<Longrightarrow>\n       \\<not> edge (quotient_web \\<Gamma> f) x y\n 3. A (quotient_web \\<Gamma> f)\n    \\<subseteq> \\<^bold>V\\<^bsub>quotient_web \\<Gamma> f\\<^esub>\n 4. A (quotient_web \\<Gamma> f) \\<inter> B (quotient_web \\<Gamma> f) = {}\n 5. \\<And>x. \\<not> edge (quotient_web \\<Gamma> f) x x\n 6. \\<And>x.\n       x \\<notin> \\<^bold>V\\<^bsub>quotient_web \\<Gamma> f\\<^esub> \\<Longrightarrow>\n       weight (quotient_web \\<Gamma> f) x = 0\n 7. \\<And>x. weight (quotient_web \\<Gamma> f) x \\<noteq> \\<top>", "show \"\\<not> edge ?\\<Gamma> y x\" if \"x \\<in> A ?\\<Gamma>\" for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> edge (quotient_web \\<Gamma> f) y x", "using that"], ["proof (prove)\nusing this:\n  x \\<in> A (quotient_web \\<Gamma> f)\n\ngoal (1 subgoal):\n 1. \\<not> edge (quotient_web \\<Gamma> f) y x", "by(auto intro: roofed_greaterI)"], ["proof (state)\nthis:\n  ?x \\<in> A (quotient_web \\<Gamma> f) \\<Longrightarrow>\n  \\<not> edge (quotient_web \\<Gamma> f) ?y ?x\n\ngoal (6 subgoals):\n 1. \\<And>x y.\n       x \\<in> B (quotient_web \\<Gamma> f) \\<Longrightarrow>\n       \\<not> edge (quotient_web \\<Gamma> f) x y\n 2. A (quotient_web \\<Gamma> f)\n    \\<subseteq> \\<^bold>V\\<^bsub>quotient_web \\<Gamma> f\\<^esub>\n 3. A (quotient_web \\<Gamma> f) \\<inter> B (quotient_web \\<Gamma> f) = {}\n 4. \\<And>x. \\<not> edge (quotient_web \\<Gamma> f) x x\n 5. \\<And>x.\n       x \\<notin> \\<^bold>V\\<^bsub>quotient_web \\<Gamma> f\\<^esub> \\<Longrightarrow>\n       weight (quotient_web \\<Gamma> f) x = 0\n 6. \\<And>x. weight (quotient_web \\<Gamma> f) x \\<noteq> \\<top>", "show \"\\<not> edge ?\\<Gamma> x y\" if \"x \\<in> B ?\\<Gamma>\" for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> edge (quotient_web \\<Gamma> f) x y", "using that"], ["proof (prove)\nusing this:\n  x \\<in> B (quotient_web \\<Gamma> f)\n\ngoal (1 subgoal):\n 1. \\<not> edge (quotient_web \\<Gamma> f) x y", "by(auto simp add: B_out)"], ["proof (state)\nthis:\n  ?x \\<in> B (quotient_web \\<Gamma> f) \\<Longrightarrow>\n  \\<not> edge (quotient_web \\<Gamma> f) ?x ?y\n\ngoal (5 subgoals):\n 1. A (quotient_web \\<Gamma> f)\n    \\<subseteq> \\<^bold>V\\<^bsub>quotient_web \\<Gamma> f\\<^esub>\n 2. A (quotient_web \\<Gamma> f) \\<inter> B (quotient_web \\<Gamma> f) = {}\n 3. \\<And>x. \\<not> edge (quotient_web \\<Gamma> f) x x\n 4. \\<And>x.\n       x \\<notin> \\<^bold>V\\<^bsub>quotient_web \\<Gamma> f\\<^esub> \\<Longrightarrow>\n       weight (quotient_web \\<Gamma> f) x = 0\n 5. \\<And>x. weight (quotient_web \\<Gamma> f) x \\<noteq> \\<top>", "show \"A ?\\<Gamma> \\<inter> B ?\\<Gamma> = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A (quotient_web \\<Gamma> f) \\<inter> B (quotient_web \\<Gamma> f) = {}", "using disjoint"], ["proof (prove)\nusing this:\n  A \\<Gamma> \\<inter> B \\<Gamma> = {}\n\ngoal (1 subgoal):\n 1. A (quotient_web \\<Gamma> f) \\<inter> B (quotient_web \\<Gamma> f) = {}", "by auto"], ["proof (state)\nthis:\n  A (quotient_web \\<Gamma> f) \\<inter> B (quotient_web \\<Gamma> f) = {}\n\ngoal (4 subgoals):\n 1. A (quotient_web \\<Gamma> f)\n    \\<subseteq> \\<^bold>V\\<^bsub>quotient_web \\<Gamma> f\\<^esub>\n 2. \\<And>x. \\<not> edge (quotient_web \\<Gamma> f) x x\n 3. \\<And>x.\n       x \\<notin> \\<^bold>V\\<^bsub>quotient_web \\<Gamma> f\\<^esub> \\<Longrightarrow>\n       weight (quotient_web \\<Gamma> f) x = 0\n 4. \\<And>x. weight (quotient_web \\<Gamma> f) x \\<noteq> \\<top>", "show \"A ?\\<Gamma> \\<subseteq> \\<^bold>V\\<^bsub>?\\<Gamma>\\<^esub>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A (quotient_web \\<Gamma> f)\n    \\<subseteq> \\<^bold>V\\<^bsub>quotient_web \\<Gamma> f\\<^esub>", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> A (quotient_web \\<Gamma> f) \\<Longrightarrow>\n       x \\<in> \\<^bold>V\\<^bsub>quotient_web \\<Gamma> f\\<^esub>", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> A (quotient_web \\<Gamma> f) \\<Longrightarrow>\n       x \\<in> \\<^bold>V\\<^bsub>quotient_web \\<Gamma> f\\<^esub>", "assume \"x \\<in> A ?\\<Gamma>\""], ["proof (state)\nthis:\n  x \\<in> A (quotient_web \\<Gamma> f)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> A (quotient_web \\<Gamma> f) \\<Longrightarrow>\n       x \\<in> \\<^bold>V\\<^bsub>quotient_web \\<Gamma> f\\<^esub>", "hence \\<E>: \"x \\<in> \\<E> (TER f)\" and x: \"x \\<notin> B \\<Gamma>\""], ["proof (prove)\nusing this:\n  x \\<in> A (quotient_web \\<Gamma> f)\n\ngoal (1 subgoal):\n 1. x \\<in> \\<E> (TER f) &&& x \\<notin> B \\<Gamma>", "using disjoint"], ["proof (prove)\nusing this:\n  x \\<in> A (quotient_web \\<Gamma> f)\n  A \\<Gamma> \\<inter> B \\<Gamma> = {}\n\ngoal (1 subgoal):\n 1. x \\<in> \\<E> (TER f) &&& x \\<notin> B \\<Gamma>", "by auto"], ["proof (state)\nthis:\n  x \\<in> \\<E> (TER f)\n  x \\<notin> B \\<Gamma>\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> A (quotient_web \\<Gamma> f) \\<Longrightarrow>\n       x \\<in> \\<^bold>V\\<^bsub>quotient_web \\<Gamma> f\\<^esub>", "from this(1)"], ["proof (chain)\npicking this:\n  x \\<in> \\<E> (TER f)", "obtain p y where p: \"path \\<Gamma> x p y\" and y: \"y \\<in> B \\<Gamma>\" and bypass: \"\\<And>z. z \\<in> set p \\<Longrightarrow> z \\<notin> RF (TER f)\""], ["proof (prove)\nusing this:\n  x \\<in> \\<E> (TER f)\n\ngoal (1 subgoal):\n 1. (\\<And>p y.\n        \\<lbrakk>path \\<Gamma> x p y; y \\<in> B \\<Gamma>;\n         \\<And>z.\n            z \\<in> set p \\<Longrightarrow> z \\<notin> RF (TER f)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(rule \\<E>_E_RF) blast"], ["proof (state)\nthis:\n  path \\<Gamma> x p y\n  y \\<in> B \\<Gamma>\n  ?z \\<in> set p \\<Longrightarrow> ?z \\<notin> RF (TER f)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> A (quotient_web \\<Gamma> f) \\<Longrightarrow>\n       x \\<in> \\<^bold>V\\<^bsub>quotient_web \\<Gamma> f\\<^esub>", "from p y x"], ["proof (chain)\npicking this:\n  path \\<Gamma> x p y\n  y \\<in> B \\<Gamma>\n  x \\<notin> B \\<Gamma>", "have \"p \\<noteq> []\""], ["proof (prove)\nusing this:\n  path \\<Gamma> x p y\n  y \\<in> B \\<Gamma>\n  x \\<notin> B \\<Gamma>\n\ngoal (1 subgoal):\n 1. p \\<noteq> []", "by(auto simp add: rtrancl_path_simps)"], ["proof (state)\nthis:\n  p \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> A (quotient_web \\<Gamma> f) \\<Longrightarrow>\n       x \\<in> \\<^bold>V\\<^bsub>quotient_web \\<Gamma> f\\<^esub>", "with rtrancl_path_nth[OF p, of 0]"], ["proof (chain)\npicking this:\n  0 < length p \\<Longrightarrow> edge \\<Gamma> ((x # p) ! 0) (p ! 0)\n  p \\<noteq> []", "have \"edge \\<Gamma> x (p ! 0)\""], ["proof (prove)\nusing this:\n  0 < length p \\<Longrightarrow> edge \\<Gamma> ((x # p) ! 0) (p ! 0)\n  p \\<noteq> []\n\ngoal (1 subgoal):\n 1. edge \\<Gamma> x (p ! 0)", "by simp"], ["proof (state)\nthis:\n  edge \\<Gamma> x (p ! 0)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> A (quotient_web \\<Gamma> f) \\<Longrightarrow>\n       x \\<in> \\<^bold>V\\<^bsub>quotient_web \\<Gamma> f\\<^esub>", "moreover"], ["proof (state)\nthis:\n  edge \\<Gamma> x (p ! 0)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> A (quotient_web \\<Gamma> f) \\<Longrightarrow>\n       x \\<in> \\<^bold>V\\<^bsub>quotient_web \\<Gamma> f\\<^esub>", "have \"x \\<notin> RF\\<^sup>\\<circ> (TER f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> RF\\<^sup>\\<circ> (TER f)", "using \\<E>"], ["proof (prove)\nusing this:\n  x \\<in> \\<E> (TER f)\n\ngoal (1 subgoal):\n 1. x \\<notin> RF\\<^sup>\\<circ> (TER f)", "by(simp add: roofed_circ_def)"], ["proof (state)\nthis:\n  x \\<notin> RF\\<^sup>\\<circ> (TER f)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> A (quotient_web \\<Gamma> f) \\<Longrightarrow>\n       x \\<in> \\<^bold>V\\<^bsub>quotient_web \\<Gamma> f\\<^esub>", "moreover"], ["proof (state)\nthis:\n  x \\<notin> RF\\<^sup>\\<circ> (TER f)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> A (quotient_web \\<Gamma> f) \\<Longrightarrow>\n       x \\<in> \\<^bold>V\\<^bsub>quotient_web \\<Gamma> f\\<^esub>", "have \"p ! 0 \\<notin> RF (TER f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p ! 0 \\<notin> RF (TER f)", "using bypass \\<open>p \\<noteq> []\\<close>"], ["proof (prove)\nusing this:\n  ?z \\<in> set p \\<Longrightarrow> ?z \\<notin> RF (TER f)\n  p \\<noteq> []\n\ngoal (1 subgoal):\n 1. p ! 0 \\<notin> RF (TER f)", "by auto"], ["proof (state)\nthis:\n  p ! 0 \\<notin> RF (TER f)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> A (quotient_web \\<Gamma> f) \\<Longrightarrow>\n       x \\<in> \\<^bold>V\\<^bsub>quotient_web \\<Gamma> f\\<^esub>", "ultimately"], ["proof (chain)\npicking this:\n  edge \\<Gamma> x (p ! 0)\n  x \\<notin> RF\\<^sup>\\<circ> (TER f)\n  p ! 0 \\<notin> RF (TER f)", "have \"edge ?\\<Gamma> x (p ! 0)\""], ["proof (prove)\nusing this:\n  edge \\<Gamma> x (p ! 0)\n  x \\<notin> RF\\<^sup>\\<circ> (TER f)\n  p ! 0 \\<notin> RF (TER f)\n\ngoal (1 subgoal):\n 1. edge (quotient_web \\<Gamma> f) x (p ! 0)", "by simp"], ["proof (state)\nthis:\n  edge (quotient_web \\<Gamma> f) x (p ! 0)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> A (quotient_web \\<Gamma> f) \\<Longrightarrow>\n       x \\<in> \\<^bold>V\\<^bsub>quotient_web \\<Gamma> f\\<^esub>", "thus \"x \\<in> \\<^bold>V\\<^bsub>?\\<Gamma>\\<^esub>\""], ["proof (prove)\nusing this:\n  edge (quotient_web \\<Gamma> f) x (p ! 0)\n\ngoal (1 subgoal):\n 1. x \\<in> \\<^bold>V\\<^bsub>quotient_web \\<Gamma> f\\<^esub>", "by(auto intro: vertexI1)"], ["proof (state)\nthis:\n  x \\<in> \\<^bold>V\\<^bsub>quotient_web \\<Gamma> f\\<^esub>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  A (quotient_web \\<Gamma> f)\n  \\<subseteq> \\<^bold>V\\<^bsub>quotient_web \\<Gamma> f\\<^esub>\n\ngoal (3 subgoals):\n 1. \\<And>x. \\<not> edge (quotient_web \\<Gamma> f) x x\n 2. \\<And>x.\n       x \\<notin> \\<^bold>V\\<^bsub>quotient_web \\<Gamma> f\\<^esub> \\<Longrightarrow>\n       weight (quotient_web \\<Gamma> f) x = 0\n 3. \\<And>x. weight (quotient_web \\<Gamma> f) x \\<noteq> \\<top>", "show \"\\<not> edge ?\\<Gamma> x x\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> edge (quotient_web \\<Gamma> f) x x", "by(simp add: no_loop)"], ["proof (state)\nthis:\n  \\<not> edge (quotient_web \\<Gamma> f) ?x ?x\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<notin> \\<^bold>V\\<^bsub>quotient_web \\<Gamma> f\\<^esub> \\<Longrightarrow>\n       weight (quotient_web \\<Gamma> f) x = 0\n 2. \\<And>x. weight (quotient_web \\<Gamma> f) x \\<noteq> \\<top>", "show \"weight ?\\<Gamma> x = 0\" if \"x \\<notin> \\<^bold>V\\<^bsub>?\\<Gamma>\\<^esub>\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. weight (quotient_web \\<Gamma> f) x = 0", "proof(cases \"x \\<in> RF\\<^sup>\\<circ> (TER f) \\<or> x \\<in> TER f \\<inter> B \\<Gamma>\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<in> RF\\<^sup>\\<circ> (TER f) \\<or>\n    x \\<in> TER f \\<inter> B \\<Gamma> \\<Longrightarrow>\n    weight (quotient_web \\<Gamma> f) x = 0\n 2. \\<not> (x \\<in> RF\\<^sup>\\<circ> (TER f) \\<or>\n            x \\<in> TER f \\<inter> B \\<Gamma>) \\<Longrightarrow>\n    weight (quotient_web \\<Gamma> f) x = 0", "case True"], ["proof (state)\nthis:\n  x \\<in> RF\\<^sup>\\<circ> (TER f) \\<or> x \\<in> TER f \\<inter> B \\<Gamma>\n\ngoal (2 subgoals):\n 1. x \\<in> RF\\<^sup>\\<circ> (TER f) \\<or>\n    x \\<in> TER f \\<inter> B \\<Gamma> \\<Longrightarrow>\n    weight (quotient_web \\<Gamma> f) x = 0\n 2. \\<not> (x \\<in> RF\\<^sup>\\<circ> (TER f) \\<or>\n            x \\<in> TER f \\<inter> B \\<Gamma>) \\<Longrightarrow>\n    weight (quotient_web \\<Gamma> f) x = 0", "thus ?thesis"], ["proof (prove)\nusing this:\n  x \\<in> RF\\<^sup>\\<circ> (TER f) \\<or> x \\<in> TER f \\<inter> B \\<Gamma>\n\ngoal (1 subgoal):\n 1. weight (quotient_web \\<Gamma> f) x = 0", "by simp"], ["proof (state)\nthis:\n  weight (quotient_web \\<Gamma> f) x = 0\n\ngoal (1 subgoal):\n 1. \\<not> (x \\<in> RF\\<^sup>\\<circ> (TER f) \\<or>\n            x \\<in> TER f \\<inter> B \\<Gamma>) \\<Longrightarrow>\n    weight (quotient_web \\<Gamma> f) x = 0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (x \\<in> RF\\<^sup>\\<circ> (TER f) \\<or>\n            x \\<in> TER f \\<inter> B \\<Gamma>) \\<Longrightarrow>\n    weight (quotient_web \\<Gamma> f) x = 0", "case False"], ["proof (state)\nthis:\n  \\<not> (x \\<in> RF\\<^sup>\\<circ> (TER f) \\<or>\n          x \\<in> TER f \\<inter> B \\<Gamma>)\n\ngoal (1 subgoal):\n 1. \\<not> (x \\<in> RF\\<^sup>\\<circ> (TER f) \\<or>\n            x \\<in> TER f \\<inter> B \\<Gamma>) \\<Longrightarrow>\n    weight (quotient_web \\<Gamma> f) x = 0", "hence RF: \"x \\<notin> RF\\<^sup>\\<circ> (TER f)\" and B: \"x \\<in> B \\<Gamma> \\<Longrightarrow> x \\<notin> TER f\""], ["proof (prove)\nusing this:\n  \\<not> (x \\<in> RF\\<^sup>\\<circ> (TER f) \\<or>\n          x \\<in> TER f \\<inter> B \\<Gamma>)\n\ngoal (1 subgoal):\n 1. x \\<notin> RF\\<^sup>\\<circ> (TER f) &&&\n    (x \\<in> B \\<Gamma> \\<Longrightarrow> x \\<notin> TER f)", "by auto"], ["proof (state)\nthis:\n  x \\<notin> RF\\<^sup>\\<circ> (TER f)\n  x \\<in> B \\<Gamma> \\<Longrightarrow> x \\<notin> TER f\n\ngoal (1 subgoal):\n 1. \\<not> (x \\<in> RF\\<^sup>\\<circ> (TER f) \\<or>\n            x \\<in> TER f \\<inter> B \\<Gamma>) \\<Longrightarrow>\n    weight (quotient_web \\<Gamma> f) x = 0", "from RF"], ["proof (chain)\npicking this:\n  x \\<notin> RF\\<^sup>\\<circ> (TER f)", "obtain p y where p: \"path \\<Gamma> x p y\" and y: \"y \\<in> B \\<Gamma>\" and bypass: \"\\<And>z. z \\<in> set p \\<Longrightarrow> z \\<notin> RF (TER f)\""], ["proof (prove)\nusing this:\n  x \\<notin> RF\\<^sup>\\<circ> (TER f)\n\ngoal (1 subgoal):\n 1. (\\<And>p y.\n        \\<lbrakk>path \\<Gamma> x p y; y \\<in> B \\<Gamma>;\n         \\<And>z.\n            z \\<in> set p \\<Longrightarrow> z \\<notin> RF (TER f)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "apply(cases \"x \\<notin> RF (RF (TER f))\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>p y.\n                \\<lbrakk>path \\<Gamma> x p y; y \\<in> B \\<Gamma>;\n                 \\<And>z.\n                    z \\<in> set p \\<Longrightarrow>\n                    z \\<notin> RF (TER f)\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     x \\<notin> RF\\<^sup>\\<circ> (TER f);\n     x \\<notin> RF (RF (TER f))\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>p y.\n                \\<lbrakk>path \\<Gamma> x p y; y \\<in> B \\<Gamma>;\n                 \\<And>z.\n                    z \\<in> set p \\<Longrightarrow>\n                    z \\<notin> RF (TER f)\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     x \\<notin> RF\\<^sup>\\<circ> (TER f);\n     \\<not> x \\<notin> RF (RF (TER f))\\<rbrakk>\n    \\<Longrightarrow> thesis", "apply(auto elim!: not_roofedE)[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>p y.\n                \\<lbrakk>path \\<Gamma> x p y; y \\<in> B \\<Gamma>;\n                 \\<And>z.\n                    z \\<in> set p \\<Longrightarrow>\n                    z \\<notin> RF (TER f)\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     x \\<notin> RF\\<^sup>\\<circ> (TER f);\n     \\<not> x \\<notin> RF (RF (TER f))\\<rbrakk>\n    \\<Longrightarrow> thesis", "apply(auto simp add: roofed_circ_def roofed_idem elim: essentialE_RF)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  path \\<Gamma> x p y\n  y \\<in> B \\<Gamma>\n  ?z \\<in> set p \\<Longrightarrow> ?z \\<notin> RF (TER f)\n\ngoal (1 subgoal):\n 1. \\<not> (x \\<in> RF\\<^sup>\\<circ> (TER f) \\<or>\n            x \\<in> TER f \\<inter> B \\<Gamma>) \\<Longrightarrow>\n    weight (quotient_web \\<Gamma> f) x = 0", "from that"], ["proof (chain)\npicking this:\n  x \\<notin> \\<^bold>V\\<^bsub>quotient_web \\<Gamma> f\\<^esub>", "have \"p = []\""], ["proof (prove)\nusing this:\n  x \\<notin> \\<^bold>V\\<^bsub>quotient_web \\<Gamma> f\\<^esub>\n\ngoal (1 subgoal):\n 1. p = []", "using p y B RF bypass"], ["proof (prove)\nusing this:\n  x \\<notin> \\<^bold>V\\<^bsub>quotient_web \\<Gamma> f\\<^esub>\n  path \\<Gamma> x p y\n  y \\<in> B \\<Gamma>\n  x \\<in> B \\<Gamma> \\<Longrightarrow> x \\<notin> TER f\n  x \\<notin> RF\\<^sup>\\<circ> (TER f)\n  ?z \\<in> set p \\<Longrightarrow> ?z \\<notin> RF (TER f)\n\ngoal (1 subgoal):\n 1. p = []", "by(auto 4 3 simp add: vertex_def dest!: rtrancl_path_nth[where i=0])"], ["proof (state)\nthis:\n  p = []\n\ngoal (1 subgoal):\n 1. \\<not> (x \\<in> RF\\<^sup>\\<circ> (TER f) \\<or>\n            x \\<in> TER f \\<inter> B \\<Gamma>) \\<Longrightarrow>\n    weight (quotient_web \\<Gamma> f) x = 0", "with p"], ["proof (chain)\npicking this:\n  path \\<Gamma> x p y\n  p = []", "have xy: \"x = y\""], ["proof (prove)\nusing this:\n  path \\<Gamma> x p y\n  p = []\n\ngoal (1 subgoal):\n 1. x = y", "by(simp add: rtrancl_path_simps)"], ["proof (state)\nthis:\n  x = y\n\ngoal (1 subgoal):\n 1. \\<not> (x \\<in> RF\\<^sup>\\<circ> (TER f) \\<or>\n            x \\<in> TER f \\<inter> B \\<Gamma>) \\<Longrightarrow>\n    weight (quotient_web \\<Gamma> f) x = 0", "with B y"], ["proof (chain)\npicking this:\n  x \\<in> B \\<Gamma> \\<Longrightarrow> x \\<notin> TER f\n  y \\<in> B \\<Gamma>\n  x = y", "have \"x \\<notin> TER f\""], ["proof (prove)\nusing this:\n  x \\<in> B \\<Gamma> \\<Longrightarrow> x \\<notin> TER f\n  y \\<in> B \\<Gamma>\n  x = y\n\ngoal (1 subgoal):\n 1. x \\<notin> TER f", "by simp"], ["proof (state)\nthis:\n  x \\<notin> TER f\n\ngoal (1 subgoal):\n 1. \\<not> (x \\<in> RF\\<^sup>\\<circ> (TER f) \\<or>\n            x \\<in> TER f \\<inter> B \\<Gamma>) \\<Longrightarrow>\n    weight (quotient_web \\<Gamma> f) x = 0", "hence RF': \"x \\<notin> RF (TER f)\""], ["proof (prove)\nusing this:\n  x \\<notin> TER f\n\ngoal (1 subgoal):\n 1. x \\<notin> RF (TER f)", "using xy y"], ["proof (prove)\nusing this:\n  x \\<notin> TER f\n  x = y\n  y \\<in> B \\<Gamma>\n\ngoal (1 subgoal):\n 1. x \\<notin> RF (TER f)", "by(subst RF_in_B) auto"], ["proof (state)\nthis:\n  x \\<notin> RF (TER f)\n\ngoal (1 subgoal):\n 1. \\<not> (x \\<in> RF\\<^sup>\\<circ> (TER f) \\<or>\n            x \\<in> TER f \\<inter> B \\<Gamma>) \\<Longrightarrow>\n    weight (quotient_web \\<Gamma> f) x = 0", "have \"\\<not> vertex \\<Gamma> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> vertex \\<Gamma> x", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. vertex \\<Gamma> x \\<Longrightarrow> False", "assume \"vertex \\<Gamma> x\""], ["proof (state)\nthis:\n  vertex \\<Gamma> x\n\ngoal (1 subgoal):\n 1. vertex \\<Gamma> x \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  vertex \\<Gamma> x", "obtain x' where \"edge \\<Gamma> x' x\""], ["proof (prove)\nusing this:\n  vertex \\<Gamma> x\n\ngoal (1 subgoal):\n 1. (\\<And>x'.\n        edge \\<Gamma> x' x \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using xy y"], ["proof (prove)\nusing this:\n  vertex \\<Gamma> x\n  x = y\n  y \\<in> B \\<Gamma>\n\ngoal (1 subgoal):\n 1. (\\<And>x'.\n        edge \\<Gamma> x' x \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto simp add: vertex_def B_out)"], ["proof (state)\nthis:\n  edge \\<Gamma> x' x\n\ngoal (1 subgoal):\n 1. vertex \\<Gamma> x \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  edge \\<Gamma> x' x\n\ngoal (1 subgoal):\n 1. vertex \\<Gamma> x \\<Longrightarrow> False", "hence \"x' \\<notin> RF\\<^sup>\\<circ> (TER f)\""], ["proof (prove)\nusing this:\n  edge \\<Gamma> x' x\n\ngoal (1 subgoal):\n 1. x' \\<notin> RF\\<^sup>\\<circ> (TER f)", "using RF'"], ["proof (prove)\nusing this:\n  edge \\<Gamma> x' x\n  x \\<notin> RF (TER f)\n\ngoal (1 subgoal):\n 1. x' \\<notin> RF\\<^sup>\\<circ> (TER f)", "by(auto dest: RF_circ_edge_forward)"], ["proof (state)\nthis:\n  x' \\<notin> RF\\<^sup>\\<circ> (TER f)\n\ngoal (1 subgoal):\n 1. vertex \\<Gamma> x \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  edge \\<Gamma> x' x\n  x' \\<notin> RF\\<^sup>\\<circ> (TER f)", "have \"edge ?\\<Gamma> x' x\""], ["proof (prove)\nusing this:\n  edge \\<Gamma> x' x\n  x' \\<notin> RF\\<^sup>\\<circ> (TER f)\n\ngoal (1 subgoal):\n 1. edge (quotient_web \\<Gamma> f) x' x", "using RF'"], ["proof (prove)\nusing this:\n  edge \\<Gamma> x' x\n  x' \\<notin> RF\\<^sup>\\<circ> (TER f)\n  x \\<notin> RF (TER f)\n\ngoal (1 subgoal):\n 1. edge (quotient_web \\<Gamma> f) x' x", "by simp"], ["proof (state)\nthis:\n  edge (quotient_web \\<Gamma> f) x' x\n\ngoal (1 subgoal):\n 1. vertex \\<Gamma> x \\<Longrightarrow> False", "hence \"vertex ?\\<Gamma> x\""], ["proof (prove)\nusing this:\n  edge (quotient_web \\<Gamma> f) x' x\n\ngoal (1 subgoal):\n 1. vertex (quotient_web \\<Gamma> f) x", "by(rule vertexI2)"], ["proof (state)\nthis:\n  vertex (quotient_web \\<Gamma> f) x\n\ngoal (1 subgoal):\n 1. vertex \\<Gamma> x \\<Longrightarrow> False", "with that"], ["proof (chain)\npicking this:\n  x \\<notin> \\<^bold>V\\<^bsub>quotient_web \\<Gamma> f\\<^esub>\n  vertex (quotient_web \\<Gamma> f) x", "show False"], ["proof (prove)\nusing this:\n  x \\<notin> \\<^bold>V\\<^bsub>quotient_web \\<Gamma> f\\<^esub>\n  vertex (quotient_web \\<Gamma> f) x\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> vertex \\<Gamma> x\n\ngoal (1 subgoal):\n 1. \\<not> (x \\<in> RF\\<^sup>\\<circ> (TER f) \\<or>\n            x \\<in> TER f \\<inter> B \\<Gamma>) \\<Longrightarrow>\n    weight (quotient_web \\<Gamma> f) x = 0", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> vertex \\<Gamma> x\n\ngoal (1 subgoal):\n 1. weight (quotient_web \\<Gamma> f) x = 0", "by(simp add: weight_outside)"], ["proof (state)\nthis:\n  weight (quotient_web \\<Gamma> f) x = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?x \\<notin> \\<^bold>V\\<^bsub>quotient_web \\<Gamma> f\\<^esub> \\<Longrightarrow>\n  weight (quotient_web \\<Gamma> f) ?x = 0\n\ngoal (1 subgoal):\n 1. \\<And>x. weight (quotient_web \\<Gamma> f) x \\<noteq> \\<top>", "show \"weight ?\\<Gamma> x \\<noteq> \\<top>\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. weight (quotient_web \\<Gamma> f) x \\<noteq> \\<top>", "by simp"], ["proof (state)\nthis:\n  weight (quotient_web \\<Gamma> f) ?x \\<noteq> \\<top>\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "locale countable_web = web \\<Gamma>\n  for \\<Gamma> :: \"('v, 'more) web_scheme\" (structure)\n  +\n  assumes countable [simp]: \"countable \\<^bold>E\"\nbegin"], ["", "lemma countable_V [simp]: \"countable \\<^bold>V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. countable \\<^bold>V", "by(simp add: \"\\<^bold>V_def\")"], ["", "lemma countable_web_quotient_web: \"countable_web (quotient_web \\<Gamma> f)\" (is \"countable_web ?\\<Gamma>\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. countable_web (quotient_web \\<Gamma> f)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. countable_web (quotient_web \\<Gamma> f)", "interpret r: web ?\\<Gamma>"], ["proof (prove)\ngoal (1 subgoal):\n 1. web (quotient_web \\<Gamma> f)", "by(rule web_quotient_web)"], ["proof (state)\ngoal (1 subgoal):\n 1. countable_web (quotient_web \\<Gamma> f)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. countable_web (quotient_web \\<Gamma> f)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. countable \\<^bold>E\\<^bsub>quotient_web \\<Gamma> f\\<^esub>", "have \"\\<^bold>E\\<^bsub>?\\<Gamma>\\<^esub> \\<subseteq> \\<^bold>E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<^bold>E\\<^bsub>quotient_web \\<Gamma> f\\<^esub> \\<subseteq> \\<^bold>E", "by auto"], ["proof (state)\nthis:\n  \\<^bold>E\\<^bsub>quotient_web \\<Gamma> f\\<^esub> \\<subseteq> \\<^bold>E\n\ngoal (1 subgoal):\n 1. countable \\<^bold>E\\<^bsub>quotient_web \\<Gamma> f\\<^esub>", "then"], ["proof (chain)\npicking this:\n  \\<^bold>E\\<^bsub>quotient_web \\<Gamma> f\\<^esub> \\<subseteq> \\<^bold>E", "show \"countable \\<^bold>E\\<^bsub>?\\<Gamma>\\<^esub>\""], ["proof (prove)\nusing this:\n  \\<^bold>E\\<^bsub>quotient_web \\<Gamma> f\\<^esub> \\<subseteq> \\<^bold>E\n\ngoal (1 subgoal):\n 1. countable \\<^bold>E\\<^bsub>quotient_web \\<Gamma> f\\<^esub>", "by(rule countable_subset) simp"], ["proof (state)\nthis:\n  countable \\<^bold>E\\<^bsub>quotient_web \\<Gamma> f\\<^esub>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  countable_web (quotient_web \\<Gamma> f)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "subsection \\<open>Subtraction of a wave\\<close>"], ["", "definition minus_web :: \"('v, 'more) web_scheme \\<Rightarrow> 'v current \\<Rightarrow> ('v, 'more) web_scheme\" (infixl \"\\<ominus>\" 65) \\<comment> \\<open>Definition 6.6\\<close>\nwhere \"\\<Gamma> \\<ominus> f = \\<Gamma>\\<lparr>weight := \\<lambda>x. if x \\<in> A \\<Gamma> then weight \\<Gamma> x - d_OUT f x else weight \\<Gamma> x + d_OUT f x - d_IN f x\\<rparr>\""], ["", "lemma minus_web_sel [simp]:\n  \"edge (\\<Gamma> \\<ominus> f) = edge \\<Gamma>\"\n  \"weight (\\<Gamma> \\<ominus> f) x = (if x \\<in> A \\<Gamma> then weight \\<Gamma> x - d_OUT f x else weight \\<Gamma> x + d_OUT f x - d_IN f x)\"\n  \"A (\\<Gamma> \\<ominus> f) = A \\<Gamma>\"\n  \"B (\\<Gamma> \\<ominus> f) = B \\<Gamma>\"\n  \"\\<^bold>V\\<^bsub>\\<Gamma> \\<ominus> f\\<^esub> = \\<^bold>V\\<^bsub>\\<Gamma>\\<^esub>\"\n  \"\\<^bold>E\\<^bsub>\\<Gamma> \\<ominus> f\\<^esub> = \\<^bold>E\\<^bsub>\\<Gamma>\\<^esub>\"\n  \"web.more (\\<Gamma> \\<ominus> f) = web.more \\<Gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (edge (\\<Gamma> \\<ominus> f) = edge \\<Gamma> &&&\n     weight (\\<Gamma> \\<ominus> f) x =\n     (if x \\<in> A \\<Gamma> then weight \\<Gamma> x - d_OUT f x\n      else weight \\<Gamma> x + d_OUT f x - d_IN f x) &&&\n     A (\\<Gamma> \\<ominus> f) = A \\<Gamma>) &&&\n    (B (\\<Gamma> \\<ominus> f) = B \\<Gamma> &&&\n     \\<^bold>V\\<^bsub>\\<Gamma> \\<ominus> f\\<^esub> =\n     \\<^bold>V\\<^bsub>\\<Gamma>\\<^esub>) &&&\n    \\<^bold>E\\<^bsub>\\<Gamma> \\<ominus> f\\<^esub> =\n    \\<^bold>E\\<^bsub>\\<Gamma>\\<^esub> &&&\n    web.more (\\<Gamma> \\<ominus> f) = web.more \\<Gamma>", "by(auto simp add: minus_web_def vertex_def)"], ["", "lemma vertex_minus_web [simp]: \"vertex (\\<Gamma> \\<ominus> f) = vertex \\<Gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vertex (\\<Gamma> \\<ominus> f) = vertex \\<Gamma>", "by(simp add: vertex_def fun_eq_iff)"], ["", "lemma roofed_gen_minus_web [simp]: \"roofed_gen (\\<Gamma> \\<ominus> f) = roofed_gen \\<Gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. roofed_gen (\\<Gamma> \\<ominus> f) = roofed_gen \\<Gamma>", "by(simp add: fun_eq_iff roofed_def)"], ["", "lemma minus_zero_current [simp]: \"\\<Gamma> \\<ominus> zero_current = \\<Gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma> \\<ominus> (\\<lambda>_. 0) = \\<Gamma>", "by(rule web.equality)(simp_all add: fun_eq_iff)"], ["", "lemma (in web) web_minus_web:\n  assumes f: \"current \\<Gamma> f\"\n  shows \"web (\\<Gamma> \\<ominus> f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. web (\\<Gamma> \\<ominus> f)", "unfolding minus_web_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. web (\\<Gamma>\n         \\<lparr>weight :=\n                   \\<lambda>x.\n                      if x \\<in> A \\<Gamma>\n                      then weight \\<Gamma> x - d_OUT f x\n                      else weight \\<Gamma> x + d_OUT f x - d_IN f x\\<rparr>)", "apply(rule web_weight_update)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<not> vertex \\<Gamma> x \\<Longrightarrow>\n       (if x \\<in> A \\<Gamma> then weight \\<Gamma> x - d_OUT f x\n        else weight \\<Gamma> x + d_OUT f x - d_IN f x) =\n       0\n 2. \\<And>x.\n       (if x \\<in> A \\<Gamma> then weight \\<Gamma> x - d_OUT f x\n        else weight \\<Gamma> x + d_OUT f x - d_IN f x) \\<noteq>\n       \\<top>", "apply(auto simp: weight_outside currentD_weight_IN[OF f] currentD_outside_OUT[OF f]\n                 currentD_outside_IN[OF f] currentD_weight_OUT[OF f] currentD_finite_OUT[OF f])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection \\<open>Bipartite webs\\<close>"], ["", "locale countable_bipartite_web =\n  fixes \\<Gamma> :: \"('v, 'more) web_scheme\" (structure)\n  assumes bipartite_V: \"\\<^bold>V \\<subseteq> A \\<Gamma> \\<union> B \\<Gamma>\"\n  and A_vertex: \"A \\<Gamma> \\<subseteq> \\<^bold>V\"\n  and bipartite_E: \"edge \\<Gamma> x y \\<Longrightarrow> x \\<in> A \\<Gamma> \\<and> y \\<in> B \\<Gamma>\"\n  and disjoint: \"A \\<Gamma> \\<inter> B \\<Gamma> = {}\"\n  and weight_outside: \"\\<And>x. x \\<notin> \\<^bold>V \\<Longrightarrow> weight \\<Gamma> x = 0\"\n  and weight_finite [simp]: \"\\<And>x. weight \\<Gamma> x \\<noteq> \\<top>\"\n  and countable_E [simp]: \"countable \\<^bold>E\"\nbegin"], ["", "lemma not_vertex: \"\\<lbrakk> x \\<notin> A \\<Gamma>; x \\<notin> B \\<Gamma> \\<rbrakk> \\<Longrightarrow> \\<not> vertex \\<Gamma> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<notin> A \\<Gamma>; x \\<notin> B \\<Gamma>\\<rbrakk>\n    \\<Longrightarrow> \\<not> vertex \\<Gamma> x", "using bipartite_V"], ["proof (prove)\nusing this:\n  \\<^bold>V \\<subseteq> A \\<Gamma> \\<union> B \\<Gamma>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<notin> A \\<Gamma>; x \\<notin> B \\<Gamma>\\<rbrakk>\n    \\<Longrightarrow> \\<not> vertex \\<Gamma> x", "by blast"], ["", "lemma no_loop: \"\\<not> edge \\<Gamma> x x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> edge \\<Gamma> x x", "using disjoint"], ["proof (prove)\nusing this:\n  A \\<Gamma> \\<inter> B \\<Gamma> = {}\n\ngoal (1 subgoal):\n 1. \\<not> edge \\<Gamma> x x", "by(auto dest: bipartite_E)"], ["", "lemma edge_antiparallel: \"edge \\<Gamma> x y \\<Longrightarrow> \\<not> edge \\<Gamma> y x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. edge \\<Gamma> x y \\<Longrightarrow> \\<not> edge \\<Gamma> y x", "using disjoint"], ["proof (prove)\nusing this:\n  A \\<Gamma> \\<inter> B \\<Gamma> = {}\n\ngoal (1 subgoal):\n 1. edge \\<Gamma> x y \\<Longrightarrow> \\<not> edge \\<Gamma> y x", "by(auto dest: bipartite_E)"], ["", "lemma A_in: \"x \\<in> A \\<Gamma> \\<Longrightarrow> \\<not> edge \\<Gamma> y x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> A \\<Gamma> \\<Longrightarrow> \\<not> edge \\<Gamma> y x", "using disjoint"], ["proof (prove)\nusing this:\n  A \\<Gamma> \\<inter> B \\<Gamma> = {}\n\ngoal (1 subgoal):\n 1. x \\<in> A \\<Gamma> \\<Longrightarrow> \\<not> edge \\<Gamma> y x", "by(auto dest: bipartite_E)"], ["", "lemma B_out: \"x \\<in> B \\<Gamma> \\<Longrightarrow> \\<not> edge \\<Gamma> x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> B \\<Gamma> \\<Longrightarrow> \\<not> edge \\<Gamma> x y", "using disjoint"], ["proof (prove)\nusing this:\n  A \\<Gamma> \\<inter> B \\<Gamma> = {}\n\ngoal (1 subgoal):\n 1. x \\<in> B \\<Gamma> \\<Longrightarrow> \\<not> edge \\<Gamma> x y", "by(auto dest: bipartite_E)"], ["", "sublocale countable_web"], ["proof (prove)\ngoal (1 subgoal):\n 1. countable_web \\<Gamma>", "using disjoint"], ["proof (prove)\nusing this:\n  A \\<Gamma> \\<inter> B \\<Gamma> = {}\n\ngoal (1 subgoal):\n 1. countable_web \\<Gamma>", "by(unfold_locales)(auto simp add: A_in B_out A_vertex no_loop weight_outside)"], ["", "lemma currentD_OUT':\n  assumes f: \"current \\<Gamma> f\"\n  and x: \"x \\<notin> A \\<Gamma>\"\n  shows \"d_OUT f x = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT f x = 0", "using currentD_outside_OUT[OF f, of x] x currentD_OUT[OF f, of x] bipartite_V"], ["proof (prove)\nusing this:\n  x \\<notin> \\<^bold>V \\<Longrightarrow> d_OUT f x = 0\n  x \\<notin> A \\<Gamma>\n  x \\<in> B \\<Gamma> \\<Longrightarrow> d_OUT f x = 0\n  \\<^bold>V \\<subseteq> A \\<Gamma> \\<union> B \\<Gamma>\n\ngoal (1 subgoal):\n 1. d_OUT f x = 0", "by auto"], ["", "lemma currentD_IN':\n  assumes f: \"current \\<Gamma> f\"\n  and x: \"x \\<notin> B \\<Gamma>\"\n  shows \"d_IN f x = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN f x = 0", "using currentD_outside_IN[OF f, of x] x currentD_IN[OF f, of x] bipartite_V"], ["proof (prove)\nusing this:\n  x \\<notin> \\<^bold>V \\<Longrightarrow> d_IN f x = 0\n  x \\<notin> B \\<Gamma>\n  x \\<in> A \\<Gamma> \\<Longrightarrow> d_IN f x = 0\n  \\<^bold>V \\<subseteq> A \\<Gamma> \\<union> B \\<Gamma>\n\ngoal (1 subgoal):\n 1. d_IN f x = 0", "by auto"], ["", "lemma current_bipartiteI [intro?]:\n  assumes OUT: \"\\<And>x. d_OUT f x \\<le> weight \\<Gamma> x\"\n  and IN: \"\\<And>x. d_IN f x \\<le> weight \\<Gamma> x\"\n  and outside: \"\\<And>e. e \\<notin> \\<^bold>E \\<Longrightarrow> f e = 0\"\n  shows \"current \\<Gamma> f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. current \\<Gamma> f", "proof"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x. d_OUT f x \\<le> weight \\<Gamma> x\n 2. \\<And>x. d_IN f x \\<le> weight \\<Gamma> x\n 3. \\<And>x.\n       \\<lbrakk>x \\<notin> A \\<Gamma>; x \\<notin> B \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> d_OUT f x \\<le> d_IN f x\n 4. \\<And>e. e \\<notin> \\<^bold>E \\<Longrightarrow> f e = 0", "fix x"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x. d_OUT f x \\<le> weight \\<Gamma> x\n 2. \\<And>x. d_IN f x \\<le> weight \\<Gamma> x\n 3. \\<And>x.\n       \\<lbrakk>x \\<notin> A \\<Gamma>; x \\<notin> B \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> d_OUT f x \\<le> d_IN f x\n 4. \\<And>e. e \\<notin> \\<^bold>E \\<Longrightarrow> f e = 0", "assume \"x \\<notin> A \\<Gamma>\" \"x \\<notin> B \\<Gamma>\""], ["proof (state)\nthis:\n  x \\<notin> A \\<Gamma>\n  x \\<notin> B \\<Gamma>\n\ngoal (4 subgoals):\n 1. \\<And>x. d_OUT f x \\<le> weight \\<Gamma> x\n 2. \\<And>x. d_IN f x \\<le> weight \\<Gamma> x\n 3. \\<And>x.\n       \\<lbrakk>x \\<notin> A \\<Gamma>; x \\<notin> B \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> d_OUT f x \\<le> d_IN f x\n 4. \\<And>e. e \\<notin> \\<^bold>E \\<Longrightarrow> f e = 0", "hence \"d_OUT f x = 0\""], ["proof (prove)\nusing this:\n  x \\<notin> A \\<Gamma>\n  x \\<notin> B \\<Gamma>\n\ngoal (1 subgoal):\n 1. d_OUT f x = 0", "by(auto simp add: d_OUT_def nn_integral_0_iff emeasure_count_space_eq_0 intro!: outside dest: bipartite_E)"], ["proof (state)\nthis:\n  d_OUT f x = 0\n\ngoal (4 subgoals):\n 1. \\<And>x. d_OUT f x \\<le> weight \\<Gamma> x\n 2. \\<And>x. d_IN f x \\<le> weight \\<Gamma> x\n 3. \\<And>x.\n       \\<lbrakk>x \\<notin> A \\<Gamma>; x \\<notin> B \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> d_OUT f x \\<le> d_IN f x\n 4. \\<And>e. e \\<notin> \\<^bold>E \\<Longrightarrow> f e = 0", "then"], ["proof (chain)\npicking this:\n  d_OUT f x = 0", "show \"d_OUT f x \\<le> d_IN f x\""], ["proof (prove)\nusing this:\n  d_OUT f x = 0\n\ngoal (1 subgoal):\n 1. d_OUT f x \\<le> d_IN f x", "by simp"], ["proof (state)\nthis:\n  d_OUT f x \\<le> d_IN f x\n\ngoal (3 subgoals):\n 1. \\<And>x. d_OUT f x \\<le> weight \\<Gamma> x\n 2. \\<And>x. d_IN f x \\<le> weight \\<Gamma> x\n 3. \\<And>e. e \\<notin> \\<^bold>E \\<Longrightarrow> f e = 0", "qed(rule OUT IN outside)+"], ["", "lemma wave_bipartiteI [intro?]:\n  assumes sep: \"separating \\<Gamma> (TER f)\"\n  and f: \"current \\<Gamma> f\"\n  shows \"wave \\<Gamma> f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wave \\<Gamma> f", "using sep"], ["proof (prove)\nusing this:\n  separating \\<Gamma> (TER f)\n\ngoal (1 subgoal):\n 1. wave \\<Gamma> f", "proof(rule wave.intros)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<notin> RF (TER f) \\<Longrightarrow> d_OUT f x = 0", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<notin> RF (TER f) \\<Longrightarrow> d_OUT f x = 0", "assume \"x \\<notin> RF (TER f)\""], ["proof (state)\nthis:\n  x \\<notin> RF (TER f)\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<notin> RF (TER f) \\<Longrightarrow> d_OUT f x = 0", "then"], ["proof (chain)\npicking this:\n  x \\<notin> RF (TER f)", "consider \"x \\<notin> \\<^bold>V\" | \"x \\<in> \\<^bold>V\" \"x \\<in> B \\<Gamma>\""], ["proof (prove)\nusing this:\n  x \\<notin> RF (TER f)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<notin> \\<^bold>V \\<Longrightarrow> thesis;\n     \\<lbrakk>x \\<in> \\<^bold>V; x \\<in> B \\<Gamma>\\<rbrakk>\n     \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "using separating_RF_A[OF sep] bipartite_V"], ["proof (prove)\nusing this:\n  x \\<notin> RF (TER f)\n  A \\<Gamma> \\<subseteq> RF (TER f)\n  \\<^bold>V \\<subseteq> A \\<Gamma> \\<union> B \\<Gamma>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<notin> \\<^bold>V \\<Longrightarrow> thesis;\n     \\<lbrakk>x \\<in> \\<^bold>V; x \\<in> B \\<Gamma>\\<rbrakk>\n     \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>x \\<notin> \\<^bold>V \\<Longrightarrow> ?thesis;\n   \\<lbrakk>x \\<in> \\<^bold>V; x \\<in> B \\<Gamma>\\<rbrakk>\n   \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<notin> RF (TER f) \\<Longrightarrow> d_OUT f x = 0", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>x \\<notin> \\<^bold>V \\<Longrightarrow> ?thesis;\n   \\<lbrakk>x \\<in> \\<^bold>V; x \\<in> B \\<Gamma>\\<rbrakk>\n   \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis", "show \"d_OUT f x = 0\""], ["proof (prove)\nusing this:\n  \\<lbrakk>x \\<notin> \\<^bold>V \\<Longrightarrow> ?thesis;\n   \\<lbrakk>x \\<in> \\<^bold>V; x \\<in> B \\<Gamma>\\<rbrakk>\n   \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. d_OUT f x = 0", "using currentD_OUT[OF f, of x] currentD_outside_OUT[OF f, of x]"], ["proof (prove)\nusing this:\n  \\<lbrakk>x \\<notin> \\<^bold>V \\<Longrightarrow> ?thesis;\n   \\<lbrakk>x \\<in> \\<^bold>V; x \\<in> B \\<Gamma>\\<rbrakk>\n   \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  x \\<in> B \\<Gamma> \\<Longrightarrow> d_OUT f x = 0\n  x \\<notin> \\<^bold>V \\<Longrightarrow> d_OUT f x = 0\n\ngoal (1 subgoal):\n 1. d_OUT f x = 0", "by cases auto"], ["proof (state)\nthis:\n  d_OUT f x = 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma web_flow_iff: \"web_flow \\<Gamma> f \\<longleftrightarrow> current \\<Gamma> f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. web_flow \\<Gamma> f = current \\<Gamma> f", "using bipartite_V"], ["proof (prove)\nusing this:\n  \\<^bold>V \\<subseteq> A \\<Gamma> \\<union> B \\<Gamma>\n\ngoal (1 subgoal):\n 1. web_flow \\<Gamma> f = current \\<Gamma> f", "by(auto simp add: web_flow.simps)"], ["", "end"], ["", "end"]]}