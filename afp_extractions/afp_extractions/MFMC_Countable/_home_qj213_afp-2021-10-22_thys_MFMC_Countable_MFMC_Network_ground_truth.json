{"file_name": "/home/qj213/afp-2021-10-22/thys/MFMC_Countable/MFMC_Network.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/MFMC_Countable", "problem_names": ["lemma vertexI:\n  shows vertexI1: \"edge \\<Gamma> x y \\<Longrightarrow> vertex \\<Gamma> x\"\n  and vertexI2: \"edge \\<Gamma> x y \\<Longrightarrow> vertex \\<Gamma> y\"", "lemma \"\\<^bold>V_def\": \"\\<^bold>V\\<^bsub>G\\<^esub> = fst ` \\<^bold>E\\<^bsub>G\\<^esub> \\<union> snd ` \\<^bold>E\\<^bsub>G\\<^esub>\"", "lemma countable_cycles [simp]:\n  assumes \"countable (\\<^bold>V\\<^bsub>G\\<^esub>)\"\n  shows \"countable (cycles G)\"", "lemma cycle_edges_not_Nil: \"cycle G p \\<Longrightarrow> cycle_edges p \\<noteq> []\"", "lemma distinct_cycle_edges:\n  \"cycle G p \\<Longrightarrow> distinct (cycle_edges p)\"", "lemma cycle_enter_leave_same:\n  assumes \"cycle G p\"\n  shows \"card (set [(x', y) \\<leftarrow> cycle_edges p. x' = x]) = card (set [(x', y) \\<leftarrow> cycle_edges p. y = x])\"\n  (is \"?lhs = ?rhs\")", "lemma cycle_leave_ex_enter:\n  assumes \"cycle G p\" and \"(x, y) \\<in> set (cycle_edges p)\"\n  shows \"\\<exists>z. (z, x) \\<in> set (cycle_edges p)\"", "lemma cycle_edges_edges:\n  assumes \"cycle G p\"\n  shows \"set (cycle_edges p) \\<subseteq> \\<^bold>E\\<^bsub>G\\<^esub>\"", "lemma support_flow_conv: \"support_flow f = {e. f e > 0}\"", "lemma not_in_support_flowD: \"x \\<notin> support_flow f \\<Longrightarrow> f x = 0\"", "lemma d_OUT_mono: \"(\\<And>y. f (x, y) \\<le> g (x, y)) \\<Longrightarrow> d_OUT f x \\<le> d_OUT g x\"", "lemma d_IN_mono: \"(\\<And>x. f (x, y) \\<le> g (x, y)) \\<Longrightarrow> d_IN f y \\<le> d_IN g y\"", "lemma d_OUT_0 [simp]: \"d_OUT (\\<lambda>_. 0) x = 0\"", "lemma d_IN_0 [simp]: \"d_IN (\\<lambda>_. 0) x = 0\"", "lemma d_OUT_add: \"d_OUT (\\<lambda>e. f e + g e) x = d_OUT f x + d_OUT g x\"", "lemma d_IN_add: \"d_IN (\\<lambda>e. f e + g e) x = d_IN f x + d_IN g x\"", "lemma d_OUT_cmult: \"d_OUT (\\<lambda>e. c * f e) x = c * d_OUT f x\"", "lemma d_IN_cmult: \"d_IN (\\<lambda>e. c * f e) x = c * d_IN f x\"", "lemma d_OUT_ge_point: \"f (x, y) \\<le> d_OUT f x\"", "lemma d_IN_ge_point: \"f (y, x) \\<le> d_IN f x\"", "lemma d_OUT_monotone_convergence_SUP:\n  assumes \"incseq (\\<lambda>n y. f n (x, y))\"\n  shows \"d_OUT (\\<lambda>e. SUP n. f n e) x = (SUP n. d_OUT (f n) x)\"", "lemma d_IN_monotone_convergence_SUP:\n  assumes \"incseq (\\<lambda>n x. f n (x, y))\"\n  shows \"d_IN (\\<lambda>e. SUP n. f n e) y = (SUP n. d_IN (f n) y)\"", "lemma d_OUT_diff:\n  assumes \"\\<And>y. g (x, y) \\<le> f (x, y)\" \"d_OUT g x \\<noteq> \\<top>\"\n  shows \"d_OUT (\\<lambda>e. f e - g e) x = d_OUT f x - d_OUT g x\"", "lemma d_IN_diff:\n  assumes \"\\<And>x. g (x, y) \\<le> f (x, y)\" \"d_IN g y \\<noteq> \\<top>\"\n  shows \"d_IN (\\<lambda>e. f e - g e) y = d_IN f y - d_IN g y\"", "lemma fixes G (structure)\n  shows d_OUT_alt_def: \"(\\<And>y. (x, y) \\<notin> \\<^bold>E \\<Longrightarrow> g (x, y) = 0) \\<Longrightarrow> d_OUT g x = (\\<Sum>\\<^sup>+  y\\<in>\\<^bold>O\\<^bold>U\\<^bold>T x. g (x, y))\"\n  and d_IN_alt_def: \"(\\<And>x. (x, y) \\<notin> \\<^bold>E \\<Longrightarrow> g (x, y) = 0) \\<Longrightarrow> d_IN g y = (\\<Sum>\\<^sup>+ x\\<in>\\<^bold>I\\<^bold>N y. g (x, y))\"", "lemma d_OUT_alt_def2: \"d_OUT g x = (\\<Sum>\\<^sup>+ y\\<in>{y. (x, y) \\<in> support_flow g}. g (x, y))\"\n  and d_IN_alt_def2: \"d_IN g y = (\\<Sum>\\<^sup>+ x\\<in>{x. (x, y) \\<in> support_flow g}. g (x, y))\"", "lemma SINK_mono:\n  assumes \"\\<And>e. f e \\<le> g e\"\n  shows \"SINK g \\<subseteq> SINK f\"", "lemma SINK_mono': \"f \\<le> g \\<Longrightarrow> SINK g \\<subseteq> SINK f\"", "lemma support_flow_Sup: \"support_flow (Sup Y) = (\\<Union>f\\<in>Y. support_flow f)\"", "lemma\n  assumes chain: \"Complete_Partial_Order.chain (\\<le>) Y\"\n  and Y: \"Y \\<noteq> {}\"\n  and countable: \"countable (support_flow (Sup Y))\"\n  shows d_OUT_Sup: \"d_OUT (Sup Y) x = (SUP f\\<in>Y. d_OUT f x)\" (is \"?OUT x\" is \"?lhs1 x = ?rhs1 x\")\n  and d_IN_Sup: \"d_IN (Sup Y) y = (SUP f\\<in>Y. d_IN f y)\" (is \"?IN\" is \"?lhs2 = ?rhs2\")\n  and SINK_Sup: \"SINK (Sup Y) = (\\<Inter>f\\<in>Y. SINK f)\" (is \"?SINK\")", "lemma\n  assumes chain: \"Complete_Partial_Order.chain (\\<le>) Y\"\n  and Y: \"Y \\<noteq> {}\"\n  and countable: \"countable (support_flow f)\"\n  and bounded: \"\\<And>g e. g \\<in> Y \\<Longrightarrow> g e \\<le> f e\"\n  shows d_OUT_Inf: \"d_OUT f x \\<noteq> top \\<Longrightarrow> d_OUT (Inf Y) x = (INF g\\<in>Y. d_OUT g x)\" (is \"_ \\<Longrightarrow> ?OUT\" is \"_ \\<Longrightarrow> ?lhs1 = ?rhs1\")\n  and d_IN_Inf: \"d_IN f x \\<noteq> top \\<Longrightarrow> d_IN (Inf Y) x = (INF g\\<in>Y. d_IN g x)\" (is \"_ \\<Longrightarrow> ?IN\" is \"_ \\<Longrightarrow> ?lhs2 = ?rhs2\")", "lemma flowD_capacity: \"flow \\<Delta> f \\<Longrightarrow> f e \\<le> capacity \\<Delta> e\"", "lemma flowD_KIR: \"\\<lbrakk> flow \\<Delta> f; x \\<noteq> source \\<Delta>; x \\<noteq> sink \\<Delta> \\<rbrakk> \\<Longrightarrow> KIR f x\"", "lemma flowD_capacity_OUT: \"flow \\<Delta> f \\<Longrightarrow> d_OUT f x \\<le> d_OUT (capacity \\<Delta>) x\"", "lemma flowD_capacity_IN: \"flow \\<Delta> f \\<Longrightarrow> d_IN f x \\<le> d_IN (capacity \\<Delta>) x\"", "lemma orthogonalD_out:\n  \"\\<lbrakk> orthogonal \\<Delta> f S; edge \\<Delta> x y; x \\<in> S; y \\<notin> S \\<rbrakk> \\<Longrightarrow> f (x, y) = capacity \\<Delta> (x, y)\"", "lemma orthogonalD_in:\n  \"\\<lbrakk> orthogonal \\<Delta> f S; edge \\<Delta> x y; x \\<notin> S; y \\<in> S \\<rbrakk> \\<Longrightarrow> f (x, y) = 0\"", "lemma sink_neq_source [simp]: \"sink \\<Delta> \\<noteq> source \\<Delta>\"", "lemma countable_V [simp]: \"countable \\<^bold>V\"", "lemma flowD_outside:\n  assumes g: \"flow \\<Delta> g\"\n  shows \"e \\<notin> \\<^bold>E \\<Longrightarrow> g e = 0\"", "lemma flowD_finite:\n  assumes \"flow \\<Delta> g\"\n  shows \"g e \\<noteq> \\<top>\"", "lemma zero_flow [simp]: \"flow \\<Delta> (\\<lambda>_. 0)\"", "lemma split_Vertex1_eq_0I: \"(\\<And>z. y \\<noteq> Edge x z) \\<Longrightarrow> split f (Vertex x, y) = 0\"", "lemma split_Vertex2_eq_0I: \"(\\<And>z. y \\<noteq> Edge z x) \\<Longrightarrow> split f (y, Vertex x) = 0\"", "lemma split_Edge1_eq_0I: \"(\\<And>z. y \\<noteq> Vertex x) \\<Longrightarrow> split f (Edge z x, y) = 0\"", "lemma split_Edge2_eq_0I: \"(\\<And>z. y \\<noteq> Vertex x) \\<Longrightarrow> split f (y, Edge x z) = 0\"", "lemma \\<Delta>''_sel [simp]:\n  \"edge \\<Delta>'' = edg\"\n  \"capacity \\<Delta>'' = split (capacity \\<Delta>)\"\n  \"source \\<Delta>'' = Vertex (source \\<Delta>)\"\n  \"sink \\<Delta>'' = Vertex (sink \\<Delta>)\"", "lemma \"\\<^bold>E_\\<Delta>''\": \"\\<^bold>E\\<^bsub>\\<Delta>''\\<^esub> = (\\<lambda>(x, y). (Vertex x, Edge x y)) ` \\<^bold>E \\<union> (\\<lambda>(x, y). (Edge x y, Vertex y)) ` \\<^bold>E\"", "lemma \"\\<^bold>V_\\<Delta>''\": \"\\<^bold>V\\<^bsub>\\<Delta>''\\<^esub> = Vertex ` \\<^bold>V \\<union> case_prod Edge ` \\<^bold>E\"", "lemma inj_on_Edge1 [simp]: \"inj_on (\\<lambda>x. Edge x y) A\"", "lemma inj_on_Edge2 [simp]: \"inj_on (Edge x) A\"", "lemma d_IN_split_Vertex [simp]: \"d_IN (split f) (Vertex x) = d_IN f x\" (is \"?lhs = ?rhs\")", "lemma d_OUT_split_Vertex [simp]: \"d_OUT (split f) (Vertex x) = d_OUT f x\" (is \"?lhs = ?rhs\")", "lemma d_IN_split_Edge [simp]: \"d_IN (split f) (Edge x y) = max 0 (f (x, y))\" (is \"?lhs = ?rhs\")", "lemma d_OUT_split_Edge [simp]: \"d_OUT (split f) (Edge x y) = max 0 (f (x, y))\" (is \"?lhs = ?rhs\")", "lemma \\<Delta>''_countable_network: \"countable_network \\<Delta>''\"", "lemma flow_split [simp]:\n  assumes \"flow \\<Delta> f\"\n  shows \"flow \\<Delta>'' (split f)\"", "lemma d_OUT_collect:\n  assumes f: \"flow \\<Delta>'' f\"\n  shows \"d_OUT (collect f) x = d_OUT f (Vertex x)\"", "lemma flow_collect [simp]:\n  assumes f: \"flow \\<Delta>'' f\"\n  shows \"flow \\<Delta> (collect f)\"", "lemma value_collect: \"flow \\<Delta>'' f \\<Longrightarrow> value_flow \\<Delta> (collect f) = value_flow \\<Delta>'' f\""], "translations": [["", "lemma vertexI:\n  shows vertexI1: \"edge \\<Gamma> x y \\<Longrightarrow> vertex \\<Gamma> x\"\n  and vertexI2: \"edge \\<Gamma> x y \\<Longrightarrow> vertex \\<Gamma> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (edge \\<Gamma> x y \\<Longrightarrow> vertex \\<Gamma> x) &&&\n    (edge \\<Gamma> x y \\<Longrightarrow> vertex \\<Gamma> y)", "by(auto simp add: vertex_def)"], ["", "abbreviation vertices :: \"('v, 'more) graph_scheme \\<Rightarrow> 'v set\" (\"\\<^bold>V\\<index>\")\nwhere \"\\<^bold>V\\<^bsub>G\\<^esub> \\<equiv> Collect (vertex G)\""], ["", "lemma \"\\<^bold>V_def\": \"\\<^bold>V\\<^bsub>G\\<^esub> = fst ` \\<^bold>E\\<^bsub>G\\<^esub> \\<union> snd ` \\<^bold>E\\<^bsub>G\\<^esub>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<^bold>V\\<^bsub>G\\<^esub> =\n    fst ` \\<^bold>E\\<^bsub>G\\<^esub> \\<union>\n    snd ` \\<^bold>E\\<^bsub>G\\<^esub>", "by(auto 4 3 simp add: vertex_def intro: rev_image_eqI prod.expand)"], ["", "type_synonym 'v path = \"'v list\""], ["", "abbreviation path :: \"('v, 'more) graph_scheme \\<Rightarrow> 'v \\<Rightarrow> 'v path \\<Rightarrow> 'v \\<Rightarrow> bool\"\nwhere \"path G \\<equiv> rtrancl_path (edge G)\""], ["", "inductive cycle :: \"('v, 'more) graph_scheme \\<Rightarrow> 'v path \\<Rightarrow> bool\"\n  for G\nwhere \\<comment> \\<open>Cycles must not pass through the same node multiple times. Otherwise, the cycle might\n  enter a node via two different edges and leave it via just one edge. Thus, the clean-up lemma\n  would not hold any more.\\<close>\n  cycle: \"\\<lbrakk> path G v p v; p \\<noteq> []; distinct p \\<rbrakk> \\<Longrightarrow> cycle G p\""], ["", "inductive_simps cycle_Nil [simp]: \"cycle G Nil\""], ["", "abbreviation cycles :: \"('v, 'more) graph_scheme \\<Rightarrow> 'v path set\"\nwhere \"cycles G \\<equiv> Collect (cycle G)\""], ["", "lemma countable_cycles [simp]:\n  assumes \"countable (\\<^bold>V\\<^bsub>G\\<^esub>)\"\n  shows \"countable (cycles G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. countable (cycles G)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. countable (cycles G)", "have \"cycles G \\<subseteq> lists \\<^bold>V\\<^bsub>G\\<^esub>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cycles G \\<subseteq> lists \\<^bold>V\\<^bsub>G\\<^esub>", "by(auto elim!: cycle.cases dest: rtrancl_path_Range_end rtrancl_path_Range simp add: vertex_def)"], ["proof (state)\nthis:\n  cycles G \\<subseteq> lists \\<^bold>V\\<^bsub>G\\<^esub>\n\ngoal (1 subgoal):\n 1. countable (cycles G)", "thus ?thesis"], ["proof (prove)\nusing this:\n  cycles G \\<subseteq> lists \\<^bold>V\\<^bsub>G\\<^esub>\n\ngoal (1 subgoal):\n 1. countable (cycles G)", "by(rule countable_subset)(simp add: assms)"], ["proof (state)\nthis:\n  countable (cycles G)\n\ngoal:\nNo subgoals!", "qed"], ["", "definition cycle_edges :: \"'v path \\<Rightarrow> 'v edge list\"\nwhere \"cycle_edges p = zip p (rotate1 p)\""], ["", "lemma cycle_edges_not_Nil: \"cycle G p \\<Longrightarrow> cycle_edges p \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cycle G p \\<Longrightarrow> cycle_edges p \\<noteq> []", "by(auto simp add: cycle_edges_def cycle.simps neq_Nil_conv zip_Cons1 split: list.split)"], ["", "lemma distinct_cycle_edges:\n  \"cycle G p \\<Longrightarrow> distinct (cycle_edges p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cycle G p \\<Longrightarrow> distinct (cycle_edges p)", "by(erule cycle.cases)(simp add: cycle_edges_def distinct_zipI2)"], ["", "lemma cycle_enter_leave_same:\n  assumes \"cycle G p\"\n  shows \"card (set [(x', y) \\<leftarrow> cycle_edges p. x' = x]) = card (set [(x', y) \\<leftarrow> cycle_edges p. y = x])\"\n  (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. card (set (filter (\\<lambda>(x', y). x' = x) (cycle_edges p))) =\n    card (set (filter (\\<lambda>(x', y). y = x) (cycle_edges p)))", "using assms"], ["proof (prove)\nusing this:\n  cycle G p\n\ngoal (1 subgoal):\n 1. card (set (filter (\\<lambda>(x', y). x' = x) (cycle_edges p))) =\n    card (set (filter (\\<lambda>(x', y). y = x) (cycle_edges p)))", "proof cases"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<lbrakk>path G v p v; p \\<noteq> []; distinct p\\<rbrakk>\n       \\<Longrightarrow> card\n                          (set (filter (\\<lambda>(x', y). x' = x)\n                                 (cycle_edges p))) =\n                         card\n                          (set (filter (\\<lambda>(x', y). y = x)\n                                 (cycle_edges p)))", "case (cycle v)"], ["proof (state)\nthis:\n  path G v p v\n  p \\<noteq> []\n  distinct p\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<lbrakk>path G v p v; p \\<noteq> []; distinct p\\<rbrakk>\n       \\<Longrightarrow> card\n                          (set (filter (\\<lambda>(x', y). x' = x)\n                                 (cycle_edges p))) =\n                         card\n                          (set (filter (\\<lambda>(x', y). y = x)\n                                 (cycle_edges p)))", "from distinct_cycle_edges[OF assms]"], ["proof (chain)\npicking this:\n  distinct (cycle_edges p)", "have \"?lhs = length [x' \\<leftarrow> map fst (cycle_edges p). x' = x]\""], ["proof (prove)\nusing this:\n  distinct (cycle_edges p)\n\ngoal (1 subgoal):\n 1. card (set (filter (\\<lambda>(x', y). x' = x) (cycle_edges p))) =\n    length (filter (\\<lambda>x'. x' = x) (map fst (cycle_edges p)))", "by(subst distinct_card; simp add: filter_map o_def split_def)"], ["proof (state)\nthis:\n  card (set (filter (\\<lambda>(x', y). x' = x) (cycle_edges p))) =\n  length (filter (\\<lambda>x'. x' = x) (map fst (cycle_edges p)))\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<lbrakk>path G v p v; p \\<noteq> []; distinct p\\<rbrakk>\n       \\<Longrightarrow> card\n                          (set (filter (\\<lambda>(x', y). x' = x)\n                                 (cycle_edges p))) =\n                         card\n                          (set (filter (\\<lambda>(x', y). y = x)\n                                 (cycle_edges p)))", "also"], ["proof (state)\nthis:\n  card (set (filter (\\<lambda>(x', y). x' = x) (cycle_edges p))) =\n  length (filter (\\<lambda>x'. x' = x) (map fst (cycle_edges p)))\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<lbrakk>path G v p v; p \\<noteq> []; distinct p\\<rbrakk>\n       \\<Longrightarrow> card\n                          (set (filter (\\<lambda>(x', y). x' = x)\n                                 (cycle_edges p))) =\n                         card\n                          (set (filter (\\<lambda>(x', y). y = x)\n                                 (cycle_edges p)))", "have \"\\<dots> = (if x \\<in> set p then 1 else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (filter (\\<lambda>x'. x' = x) (map fst (cycle_edges p))) =\n    (if x \\<in> set p then 1 else 0)", "using cycle"], ["proof (prove)\nusing this:\n  path G v p v\n  p \\<noteq> []\n  distinct p\n\ngoal (1 subgoal):\n 1. length (filter (\\<lambda>x'. x' = x) (map fst (cycle_edges p))) =\n    (if x \\<in> set p then 1 else 0)", "by(auto simp add: cycle_edges_def filter_empty_conv length_filter_conv_card card_eq_1_iff in_set_conv_nth dest: nth_eq_iff_index_eq)"], ["proof (state)\nthis:\n  length (filter (\\<lambda>x'. x' = x) (map fst (cycle_edges p))) =\n  (if x \\<in> set p then 1 else 0)\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<lbrakk>path G v p v; p \\<noteq> []; distinct p\\<rbrakk>\n       \\<Longrightarrow> card\n                          (set (filter (\\<lambda>(x', y). x' = x)\n                                 (cycle_edges p))) =\n                         card\n                          (set (filter (\\<lambda>(x', y). y = x)\n                                 (cycle_edges p)))", "also"], ["proof (state)\nthis:\n  length (filter (\\<lambda>x'. x' = x) (map fst (cycle_edges p))) =\n  (if x \\<in> set p then 1 else 0)\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<lbrakk>path G v p v; p \\<noteq> []; distinct p\\<rbrakk>\n       \\<Longrightarrow> card\n                          (set (filter (\\<lambda>(x', y). x' = x)\n                                 (cycle_edges p))) =\n                         card\n                          (set (filter (\\<lambda>(x', y). y = x)\n                                 (cycle_edges p)))", "have \"\\<dots> = length [y \\<leftarrow> map snd (cycle_edges p). y = x]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if x \\<in> set p then 1 else 0) =\n    length (filter (\\<lambda>y. y = x) (map snd (cycle_edges p)))", "using cycle"], ["proof (prove)\nusing this:\n  path G v p v\n  p \\<noteq> []\n  distinct p\n\ngoal (1 subgoal):\n 1. (if x \\<in> set p then 1 else 0) =\n    length (filter (\\<lambda>y. y = x) (map snd (cycle_edges p)))", "apply(auto simp add: cycle_edges_def filter_empty_conv Suc_length_conv intro!: exI[where x=x])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>path G v p v; p \\<noteq> []; distinct p; x \\<in> set p\\<rbrakk>\n    \\<Longrightarrow> filter (\\<lambda>y. y = x) (rotate1 p) = [x]", "apply(drule split_list_first)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>path G v p v; p \\<noteq> []; distinct p;\n     \\<exists>ys zs. p = ys @ x # zs \\<and> x \\<notin> set ys\\<rbrakk>\n    \\<Longrightarrow> filter (\\<lambda>y. y = x) (rotate1 p) = [x]", "apply(auto dest: split_list_first simp add: append_eq_Cons_conv rotate1_append filter_empty_conv split: if_split_asm dest: in_set_tlD)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (if x \\<in> set p then 1 else 0) =\n  length (filter (\\<lambda>y. y = x) (map snd (cycle_edges p)))\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<lbrakk>path G v p v; p \\<noteq> []; distinct p\\<rbrakk>\n       \\<Longrightarrow> card\n                          (set (filter (\\<lambda>(x', y). x' = x)\n                                 (cycle_edges p))) =\n                         card\n                          (set (filter (\\<lambda>(x', y). y = x)\n                                 (cycle_edges p)))", "also"], ["proof (state)\nthis:\n  (if x \\<in> set p then 1 else 0) =\n  length (filter (\\<lambda>y. y = x) (map snd (cycle_edges p)))\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<lbrakk>path G v p v; p \\<noteq> []; distinct p\\<rbrakk>\n       \\<Longrightarrow> card\n                          (set (filter (\\<lambda>(x', y). x' = x)\n                                 (cycle_edges p))) =\n                         card\n                          (set (filter (\\<lambda>(x', y). y = x)\n                                 (cycle_edges p)))", "have \"\\<dots> = ?rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (filter (\\<lambda>y. y = x) (map snd (cycle_edges p))) =\n    card (set (filter (\\<lambda>(x', y). y = x) (cycle_edges p)))", "using distinct_cycle_edges[OF assms]"], ["proof (prove)\nusing this:\n  distinct (cycle_edges p)\n\ngoal (1 subgoal):\n 1. length (filter (\\<lambda>y. y = x) (map snd (cycle_edges p))) =\n    card (set (filter (\\<lambda>(x', y). y = x) (cycle_edges p)))", "by(subst distinct_card; simp add: filter_map o_def split_def)"], ["proof (state)\nthis:\n  length (filter (\\<lambda>y. y = x) (map snd (cycle_edges p))) =\n  card (set (filter (\\<lambda>(x', y). y = x) (cycle_edges p)))\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<lbrakk>path G v p v; p \\<noteq> []; distinct p\\<rbrakk>\n       \\<Longrightarrow> card\n                          (set (filter (\\<lambda>(x', y). x' = x)\n                                 (cycle_edges p))) =\n                         card\n                          (set (filter (\\<lambda>(x', y). y = x)\n                                 (cycle_edges p)))", "finally"], ["proof (chain)\npicking this:\n  card (set (filter (\\<lambda>(x', y). x' = x) (cycle_edges p))) =\n  card (set (filter (\\<lambda>(x', y). y = x) (cycle_edges p)))", "show ?thesis"], ["proof (prove)\nusing this:\n  card (set (filter (\\<lambda>(x', y). x' = x) (cycle_edges p))) =\n  card (set (filter (\\<lambda>(x', y). y = x) (cycle_edges p)))\n\ngoal (1 subgoal):\n 1. card (set (filter (\\<lambda>(x', y). x' = x) (cycle_edges p))) =\n    card (set (filter (\\<lambda>(x', y). y = x) (cycle_edges p)))", "."], ["proof (state)\nthis:\n  card (set (filter (\\<lambda>(x', y). x' = x) (cycle_edges p))) =\n  card (set (filter (\\<lambda>(x', y). y = x) (cycle_edges p)))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cycle_leave_ex_enter:\n  assumes \"cycle G p\" and \"(x, y) \\<in> set (cycle_edges p)\"\n  shows \"\\<exists>z. (z, x) \\<in> set (cycle_edges p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>z. (z, x) \\<in> set (cycle_edges p)", "using assms"], ["proof (prove)\nusing this:\n  cycle G p\n  (x, y) \\<in> set (cycle_edges p)\n\ngoal (1 subgoal):\n 1. \\<exists>z. (z, x) \\<in> set (cycle_edges p)", "by(cases)(auto 4 3 simp add: cycle_edges_def cong: conj_cong split: if_split_asm intro: set_zip_rightI dest: set_zip_leftD)"], ["", "lemma cycle_edges_edges:\n  assumes \"cycle G p\"\n  shows \"set (cycle_edges p) \\<subseteq> \\<^bold>E\\<^bsub>G\\<^esub>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (cycle_edges p) \\<subseteq> \\<^bold>E\\<^bsub>G\\<^esub>", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (cycle_edges p) \\<Longrightarrow>\n       x \\<in> \\<^bold>E\\<^bsub>G\\<^esub>", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (cycle_edges p) \\<Longrightarrow>\n       x \\<in> \\<^bold>E\\<^bsub>G\\<^esub>", "assume \"x \\<in> set (cycle_edges p)\""], ["proof (state)\nthis:\n  x \\<in> set (cycle_edges p)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (cycle_edges p) \\<Longrightarrow>\n       x \\<in> \\<^bold>E\\<^bsub>G\\<^esub>", "then"], ["proof (chain)\npicking this:\n  x \\<in> set (cycle_edges p)", "obtain i where x: \"x = (p ! i, rotate1 p ! i)\" and i: \"i < length p\""], ["proof (prove)\nusing this:\n  x \\<in> set (cycle_edges p)\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>x = (p ! i, rotate1 p ! i); i < length p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto simp add: cycle_edges_def set_zip)"], ["proof (state)\nthis:\n  x = (p ! i, rotate1 p ! i)\n  i < length p\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (cycle_edges p) \\<Longrightarrow>\n       x \\<in> \\<^bold>E\\<^bsub>G\\<^esub>", "from assms"], ["proof (chain)\npicking this:\n  cycle G p", "obtain v where p: \"path G v p v\" and \"p \\<noteq> []\" and \"distinct p\""], ["proof (prove)\nusing this:\n  cycle G p\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<lbrakk>path G v p v; p \\<noteq> []; distinct p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by cases"], ["proof (state)\nthis:\n  path G v p v\n  p \\<noteq> []\n  distinct p\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (cycle_edges p) \\<Longrightarrow>\n       x \\<in> \\<^bold>E\\<^bsub>G\\<^esub>", "let ?i = \"Suc i mod length p\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (cycle_edges p) \\<Longrightarrow>\n       x \\<in> \\<^bold>E\\<^bsub>G\\<^esub>", "have \"?i < length p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc i mod length p < length p", "by (simp add: \\<open>p \\<noteq> []\\<close>)"], ["proof (state)\nthis:\n  Suc i mod length p < length p\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (cycle_edges p) \\<Longrightarrow>\n       x \\<in> \\<^bold>E\\<^bsub>G\\<^esub>", "note rtrancl_path_nth[OF p this]"], ["proof (state)\nthis:\n  edge G ((v # p) ! (Suc i mod length p)) (p ! (Suc i mod length p))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (cycle_edges p) \\<Longrightarrow>\n       x \\<in> \\<^bold>E\\<^bsub>G\\<^esub>", "also"], ["proof (state)\nthis:\n  edge G ((v # p) ! (Suc i mod length p)) (p ! (Suc i mod length p))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (cycle_edges p) \\<Longrightarrow>\n       x \\<in> \\<^bold>E\\<^bsub>G\\<^esub>", "have \"(v # p) ! ?i = p ! i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (v # p) ! (Suc i mod length p) = p ! i", "proof(cases \"Suc i < length p\")"], ["proof (state)\ngoal (2 subgoals):\n 1. Suc i < length p \\<Longrightarrow>\n    (v # p) ! (Suc i mod length p) = p ! i\n 2. \\<not> Suc i < length p \\<Longrightarrow>\n    (v # p) ! (Suc i mod length p) = p ! i", "case True"], ["proof (state)\nthis:\n  Suc i < length p\n\ngoal (2 subgoals):\n 1. Suc i < length p \\<Longrightarrow>\n    (v # p) ! (Suc i mod length p) = p ! i\n 2. \\<not> Suc i < length p \\<Longrightarrow>\n    (v # p) ! (Suc i mod length p) = p ! i", "thus ?thesis"], ["proof (prove)\nusing this:\n  Suc i < length p\n\ngoal (1 subgoal):\n 1. (v # p) ! (Suc i mod length p) = p ! i", "by simp"], ["proof (state)\nthis:\n  (v # p) ! (Suc i mod length p) = p ! i\n\ngoal (1 subgoal):\n 1. \\<not> Suc i < length p \\<Longrightarrow>\n    (v # p) ! (Suc i mod length p) = p ! i", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> Suc i < length p \\<Longrightarrow>\n    (v # p) ! (Suc i mod length p) = p ! i", "case False"], ["proof (state)\nthis:\n  \\<not> Suc i < length p\n\ngoal (1 subgoal):\n 1. \\<not> Suc i < length p \\<Longrightarrow>\n    (v # p) ! (Suc i mod length p) = p ! i", "with i"], ["proof (chain)\npicking this:\n  i < length p\n  \\<not> Suc i < length p", "have \"Suc i = length p\""], ["proof (prove)\nusing this:\n  i < length p\n  \\<not> Suc i < length p\n\ngoal (1 subgoal):\n 1. Suc i = length p", "by simp"], ["proof (state)\nthis:\n  Suc i = length p\n\ngoal (1 subgoal):\n 1. \\<not> Suc i < length p \\<Longrightarrow>\n    (v # p) ! (Suc i mod length p) = p ! i", "moreover"], ["proof (state)\nthis:\n  Suc i = length p\n\ngoal (1 subgoal):\n 1. \\<not> Suc i < length p \\<Longrightarrow>\n    (v # p) ! (Suc i mod length p) = p ! i", "from p \\<open>p \\<noteq> []\\<close>"], ["proof (chain)\npicking this:\n  path G v p v\n  p \\<noteq> []", "have \"last p = v\""], ["proof (prove)\nusing this:\n  path G v p v\n  p \\<noteq> []\n\ngoal (1 subgoal):\n 1. last p = v", "by(rule rtrancl_path_last)"], ["proof (state)\nthis:\n  last p = v\n\ngoal (1 subgoal):\n 1. \\<not> Suc i < length p \\<Longrightarrow>\n    (v # p) ! (Suc i mod length p) = p ! i", "ultimately"], ["proof (chain)\npicking this:\n  Suc i = length p\n  last p = v", "show ?thesis"], ["proof (prove)\nusing this:\n  Suc i = length p\n  last p = v\n\ngoal (1 subgoal):\n 1. (v # p) ! (Suc i mod length p) = p ! i", "using \\<open>p \\<noteq> []\\<close>"], ["proof (prove)\nusing this:\n  Suc i = length p\n  last p = v\n  p \\<noteq> []\n\ngoal (1 subgoal):\n 1. (v # p) ! (Suc i mod length p) = p ! i", "by(simp add: last_conv_nth)(metis diff_Suc_Suc diff_zero)"], ["proof (state)\nthis:\n  (v # p) ! (Suc i mod length p) = p ! i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (v # p) ! (Suc i mod length p) = p ! i\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (cycle_edges p) \\<Longrightarrow>\n       x \\<in> \\<^bold>E\\<^bsub>G\\<^esub>", "also"], ["proof (state)\nthis:\n  (v # p) ! (Suc i mod length p) = p ! i\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (cycle_edges p) \\<Longrightarrow>\n       x \\<in> \\<^bold>E\\<^bsub>G\\<^esub>", "have \"p ! ?i = rotate1 p ! i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p ! (Suc i mod length p) = rotate1 p ! i", "using i"], ["proof (prove)\nusing this:\n  i < length p\n\ngoal (1 subgoal):\n 1. p ! (Suc i mod length p) = rotate1 p ! i", "by(simp add: nth_rotate1)"], ["proof (state)\nthis:\n  p ! (Suc i mod length p) = rotate1 p ! i\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (cycle_edges p) \\<Longrightarrow>\n       x \\<in> \\<^bold>E\\<^bsub>G\\<^esub>", "finally"], ["proof (chain)\npicking this:\n  edge G (p ! i) (rotate1 p ! i)", "show \"x \\<in> \\<^bold>E\\<^bsub>G\\<^esub>\""], ["proof (prove)\nusing this:\n  edge G (p ! i) (rotate1 p ! i)\n\ngoal (1 subgoal):\n 1. x \\<in> \\<^bold>E\\<^bsub>G\\<^esub>", "by(simp add: x)"], ["proof (state)\nthis:\n  x \\<in> \\<^bold>E\\<^bsub>G\\<^esub>\n\ngoal:\nNo subgoals!", "qed"], ["", "section \\<open>Network and Flow\\<close>"], ["", "record 'v network = \"'v graph\" +\n  capacity :: \"'v edge \\<Rightarrow> ennreal\"\n  source :: \"'v\"\n  sink :: \"'v\""], ["", "type_synonym 'v flow = \"'v edge \\<Rightarrow> ennreal\""], ["", "inductive_set support_flow :: \"'v flow \\<Rightarrow> 'v edge set\"\n  for f\nwhere \"f e > 0 \\<Longrightarrow> e \\<in> support_flow f\""], ["", "lemma support_flow_conv: \"support_flow f = {e. f e > 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. support_flow f = {e. 0 < f e}", "by(auto simp add: support_flow.simps)"], ["", "lemma not_in_support_flowD: \"x \\<notin> support_flow f \\<Longrightarrow> f x = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> support_flow f \\<Longrightarrow> f x = 0", "by(simp add: support_flow_conv)"], ["", "definition d_OUT :: \"'v flow \\<Rightarrow> 'v \\<Rightarrow> ennreal\"\nwhere \"d_OUT g x = (\\<Sum>\\<^sup>+ y. g (x, y))\""], ["", "definition d_IN :: \"'v flow \\<Rightarrow> 'v \\<Rightarrow> ennreal\"\nwhere \"d_IN g y = (\\<Sum>\\<^sup>+ x. g (x, y))\""], ["", "lemma d_OUT_mono: \"(\\<And>y. f (x, y) \\<le> g (x, y)) \\<Longrightarrow> d_OUT f x \\<le> d_OUT g x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>y. f (x, y) \\<le> g (x, y)) \\<Longrightarrow>\n    d_OUT f x \\<le> d_OUT g x", "by(auto simp add: d_OUT_def le_fun_def intro: nn_integral_mono)"], ["", "lemma d_IN_mono: \"(\\<And>x. f (x, y) \\<le> g (x, y)) \\<Longrightarrow> d_IN f y \\<le> d_IN g y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x. f (x, y) \\<le> g (x, y)) \\<Longrightarrow>\n    d_IN f y \\<le> d_IN g y", "by(auto simp add: d_IN_def le_fun_def intro: nn_integral_mono)"], ["", "lemma d_OUT_0 [simp]: \"d_OUT (\\<lambda>_. 0) x = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT (\\<lambda>_. 0) x = 0", "by(simp add: d_OUT_def)"], ["", "lemma d_IN_0 [simp]: \"d_IN (\\<lambda>_. 0) x = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN (\\<lambda>_. 0) x = 0", "by(simp add: d_IN_def)"], ["", "lemma d_OUT_add: \"d_OUT (\\<lambda>e. f e + g e) x = d_OUT f x + d_OUT g x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT (\\<lambda>e. f e + g e) x = d_OUT f x + d_OUT g x", "unfolding d_OUT_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y. f (x, y) + g (x, y)) =\n    (\\<Sum>\\<^sup>+ y. f (x, y)) + (\\<Sum>\\<^sup>+ y. g (x, y))", "by(simp add: nn_integral_add)"], ["", "lemma d_IN_add: \"d_IN (\\<lambda>e. f e + g e) x = d_IN f x + d_IN g x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN (\\<lambda>e. f e + g e) x = d_IN f x + d_IN g x", "unfolding d_IN_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ xa. f (xa, x) + g (xa, x)) =\n    (\\<Sum>\\<^sup>+ xa. f (xa, x)) + (\\<Sum>\\<^sup>+ xa. g (xa, x))", "by(simp add: nn_integral_add)"], ["", "lemma d_OUT_cmult: \"d_OUT (\\<lambda>e. c * f e) x = c * d_OUT f x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT (\\<lambda>e. c * f e) x = c * d_OUT f x", "by(simp add: d_OUT_def nn_integral_cmult)"], ["", "lemma d_IN_cmult: \"d_IN (\\<lambda>e. c * f e) x = c * d_IN f x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN (\\<lambda>e. c * f e) x = c * d_IN f x", "by(simp add: d_IN_def nn_integral_cmult)"], ["", "lemma d_OUT_ge_point: \"f (x, y) \\<le> d_OUT f x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f (x, y) \\<le> d_OUT f x", "by(auto simp add: d_OUT_def intro!: nn_integral_ge_point)"], ["", "lemma d_IN_ge_point: \"f (y, x) \\<le> d_IN f x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f (y, x) \\<le> d_IN f x", "by(auto simp add: d_IN_def intro!: nn_integral_ge_point)"], ["", "lemma d_OUT_monotone_convergence_SUP:\n  assumes \"incseq (\\<lambda>n y. f n (x, y))\"\n  shows \"d_OUT (\\<lambda>e. SUP n. f n e) x = (SUP n. d_OUT (f n) x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT (\\<lambda>e. \\<Squnion>n. f n e) x = (\\<Squnion>n. d_OUT (f n) x)", "unfolding d_OUT_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y. \\<Squnion>n. f n (x, y)) =\n    (\\<Squnion>n. \\<Sum>\\<^sup>+ y. f n (x, y))", "by(rule nn_integral_monotone_convergence_SUP[OF assms]) simp"], ["", "lemma d_IN_monotone_convergence_SUP:\n  assumes \"incseq (\\<lambda>n x. f n (x, y))\"\n  shows \"d_IN (\\<lambda>e. SUP n. f n e) y = (SUP n. d_IN (f n) y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN (\\<lambda>e. \\<Squnion>n. f n e) y = (\\<Squnion>n. d_IN (f n) y)", "unfolding d_IN_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ x. \\<Squnion>n. f n (x, y)) =\n    (\\<Squnion>n. \\<Sum>\\<^sup>+ x. f n (x, y))", "by(rule nn_integral_monotone_convergence_SUP[OF assms]) simp"], ["", "lemma d_OUT_diff:\n  assumes \"\\<And>y. g (x, y) \\<le> f (x, y)\" \"d_OUT g x \\<noteq> \\<top>\"\n  shows \"d_OUT (\\<lambda>e. f e - g e) x = d_OUT f x - d_OUT g x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT (\\<lambda>e. f e - g e) x = d_OUT f x - d_OUT g x", "using assms"], ["proof (prove)\nusing this:\n  g (x, ?y) \\<le> f (x, ?y)\n  d_OUT g x \\<noteq> \\<top>\n\ngoal (1 subgoal):\n 1. d_OUT (\\<lambda>e. f e - g e) x = d_OUT f x - d_OUT g x", "by(simp add: nn_integral_diff d_OUT_def)"], ["", "lemma d_IN_diff:\n  assumes \"\\<And>x. g (x, y) \\<le> f (x, y)\" \"d_IN g y \\<noteq> \\<top>\"\n  shows \"d_IN (\\<lambda>e. f e - g e) y = d_IN f y - d_IN g y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN (\\<lambda>e. f e - g e) y = d_IN f y - d_IN g y", "using assms"], ["proof (prove)\nusing this:\n  g (?x, y) \\<le> f (?x, y)\n  d_IN g y \\<noteq> \\<top>\n\ngoal (1 subgoal):\n 1. d_IN (\\<lambda>e. f e - g e) y = d_IN f y - d_IN g y", "by(simp add: nn_integral_diff d_IN_def)"], ["", "lemma fixes G (structure)\n  shows d_OUT_alt_def: \"(\\<And>y. (x, y) \\<notin> \\<^bold>E \\<Longrightarrow> g (x, y) = 0) \\<Longrightarrow> d_OUT g x = (\\<Sum>\\<^sup>+  y\\<in>\\<^bold>O\\<^bold>U\\<^bold>T x. g (x, y))\"\n  and d_IN_alt_def: \"(\\<And>x. (x, y) \\<notin> \\<^bold>E \\<Longrightarrow> g (x, y) = 0) \\<Longrightarrow> d_IN g y = (\\<Sum>\\<^sup>+ x\\<in>\\<^bold>I\\<^bold>N y. g (x, y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<And>y.\n         (x, y) \\<notin> \\<^bold>E \\<Longrightarrow>\n         g (x, y) = 0) \\<Longrightarrow>\n     d_OUT g x =\n     (\\<Sum>\\<^sup>+ y\\<in>\\<^bold>O\\<^bold>U\\<^bold>T x. g (x, y))) &&&\n    ((\\<And>x.\n         (x, y) \\<notin> \\<^bold>E \\<Longrightarrow>\n         g (x, y) = 0) \\<Longrightarrow>\n     d_IN g y = (\\<Sum>\\<^sup>+ x\\<in>\\<^bold>I\\<^bold>N y. g (x, y)))", "unfolding d_OUT_def d_IN_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<And>y.\n         (x, y) \\<notin> \\<^bold>E \\<Longrightarrow>\n         g (x, y) = 0) \\<Longrightarrow>\n     (\\<Sum>\\<^sup>+ y. g (x, y)) =\n     (\\<Sum>\\<^sup>+ y\\<in>\\<^bold>O\\<^bold>U\\<^bold>T x. g (x, y))) &&&\n    ((\\<And>x.\n         (x, y) \\<notin> \\<^bold>E \\<Longrightarrow>\n         g (x, y) = 0) \\<Longrightarrow>\n     (\\<Sum>\\<^sup>+ x. g (x, y)) =\n     (\\<Sum>\\<^sup>+ x\\<in>\\<^bold>I\\<^bold>N y. g (x, y)))", "by(fastforce simp add: max_def d_OUT_def d_IN_def nn_integral_count_space_indicator outgoing_def incoming_def intro!: nn_integral_cong split: split_indicator)+"], ["", "lemma d_OUT_alt_def2: \"d_OUT g x = (\\<Sum>\\<^sup>+ y\\<in>{y. (x, y) \\<in> support_flow g}. g (x, y))\"\n  and d_IN_alt_def2: \"d_IN g y = (\\<Sum>\\<^sup>+ x\\<in>{x. (x, y) \\<in> support_flow g}. g (x, y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT g x =\n    (\\<Sum>\\<^sup>+ y\\<in>{y. (x, y) \\<in> support_flow g}. g (x, y)) &&&\n    d_IN g y =\n    (\\<Sum>\\<^sup>+ x\\<in>{x. (x, y) \\<in> support_flow g}. g (x, y))", "unfolding d_OUT_def d_IN_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y. g (x, y)) =\n    (\\<Sum>\\<^sup>+ y\\<in>{y. (x, y) \\<in> support_flow g}. g (x, y)) &&&\n    (\\<Sum>\\<^sup>+ x. g (x, y)) =\n    (\\<Sum>\\<^sup>+ x\\<in>{x. (x, y) \\<in> support_flow g}. g (x, y))", "by(auto simp add: max_def d_OUT_def d_IN_def nn_integral_count_space_indicator outgoing_def incoming_def support_flow.simps intro!: nn_integral_cong split: split_indicator)+"], ["", "definition d_diff :: \"('v edge \\<Rightarrow> ennreal) \\<Rightarrow> 'v \\<Rightarrow> ennreal\"\nwhere \"d_diff g x = d_OUT g x - d_IN g x\""], ["", "abbreviation KIR :: \"('v edge \\<Rightarrow> ennreal) \\<Rightarrow> 'v \\<Rightarrow> bool\"\nwhere \"KIR f x \\<equiv> d_OUT f x = d_IN f x\""], ["", "inductive_set SINK :: \"('v edge \\<Rightarrow> ennreal) \\<Rightarrow> 'v set\"\n  for f\nwhere SINK: \"d_OUT f x = 0 \\<Longrightarrow> x \\<in> SINK f\""], ["", "lemma SINK_mono:\n  assumes \"\\<And>e. f e \\<le> g e\"\n  shows \"SINK g \\<subseteq> SINK f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SINK g \\<subseteq> SINK f", "proof(rule subsetI; erule SINK.cases; hypsubst)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa. d_OUT g xa = 0 \\<Longrightarrow> xa \\<in> SINK f", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa. d_OUT g xa = 0 \\<Longrightarrow> xa \\<in> SINK f", "assume \"d_OUT g x = 0\""], ["proof (state)\nthis:\n  d_OUT g x = 0\n\ngoal (1 subgoal):\n 1. \\<And>x xa. d_OUT g xa = 0 \\<Longrightarrow> xa \\<in> SINK f", "moreover"], ["proof (state)\nthis:\n  d_OUT g x = 0\n\ngoal (1 subgoal):\n 1. \\<And>x xa. d_OUT g xa = 0 \\<Longrightarrow> xa \\<in> SINK f", "have \"d_OUT f x \\<le> d_OUT g x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT f x \\<le> d_OUT g x", "using assms"], ["proof (prove)\nusing this:\n  f ?e \\<le> g ?e\n\ngoal (1 subgoal):\n 1. d_OUT f x \\<le> d_OUT g x", "by(rule d_OUT_mono)"], ["proof (state)\nthis:\n  d_OUT f x \\<le> d_OUT g x\n\ngoal (1 subgoal):\n 1. \\<And>x xa. d_OUT g xa = 0 \\<Longrightarrow> xa \\<in> SINK f", "ultimately"], ["proof (chain)\npicking this:\n  d_OUT g x = 0\n  d_OUT f x \\<le> d_OUT g x", "have \"d_OUT f x = 0\""], ["proof (prove)\nusing this:\n  d_OUT g x = 0\n  d_OUT f x \\<le> d_OUT g x\n\ngoal (1 subgoal):\n 1. d_OUT f x = 0", "by simp"], ["proof (state)\nthis:\n  d_OUT f x = 0\n\ngoal (1 subgoal):\n 1. \\<And>x xa. d_OUT g xa = 0 \\<Longrightarrow> xa \\<in> SINK f", "thus \"x \\<in> SINK f\""], ["proof (prove)\nusing this:\n  d_OUT f x = 0\n\ngoal (1 subgoal):\n 1. x \\<in> SINK f", ".."], ["proof (state)\nthis:\n  x \\<in> SINK f\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma SINK_mono': \"f \\<le> g \\<Longrightarrow> SINK g \\<subseteq> SINK f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<le> g \\<Longrightarrow> SINK g \\<subseteq> SINK f", "by(rule SINK_mono)(rule le_funD)"], ["", "lemma support_flow_Sup: \"support_flow (Sup Y) = (\\<Union>f\\<in>Y. support_flow f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. support_flow (\\<Squnion> Y) = \\<Union> (support_flow ` Y)", "by(auto simp add: support_flow_conv less_SUP_iff)"], ["", "lemma\n  assumes chain: \"Complete_Partial_Order.chain (\\<le>) Y\"\n  and Y: \"Y \\<noteq> {}\"\n  and countable: \"countable (support_flow (Sup Y))\"\n  shows d_OUT_Sup: \"d_OUT (Sup Y) x = (SUP f\\<in>Y. d_OUT f x)\" (is \"?OUT x\" is \"?lhs1 x = ?rhs1 x\")\n  and d_IN_Sup: \"d_IN (Sup Y) y = (SUP f\\<in>Y. d_IN f y)\" (is \"?IN\" is \"?lhs2 = ?rhs2\")\n  and SINK_Sup: \"SINK (Sup Y) = (\\<Inter>f\\<in>Y. SINK f)\" (is \"?SINK\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT (\\<Squnion> Y) x = (\\<Squnion>f\\<in>Y. d_OUT f x) &&&\n    d_IN (\\<Squnion> Y) y = (\\<Squnion>f\\<in>Y. d_IN f y) &&&\n    SINK (\\<Squnion> Y) = \\<Inter> (SINK ` Y)", "proof -"], ["proof (state)\ngoal (3 subgoals):\n 1. d_OUT (\\<Squnion> Y) x = (\\<Squnion>f\\<in>Y. d_OUT f x)\n 2. d_IN (\\<Squnion> Y) y = (\\<Squnion>f\\<in>Y. d_IN f y)\n 3. SINK (\\<Squnion> Y) = \\<Inter> (SINK ` Y)", "have chain': \"Complete_Partial_Order.chain (\\<le>) ((\\<lambda>f y. f (x, y)) ` Y)\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. Complete_Partial_Order.chain (\\<le>) ((\\<lambda>f y. f (x, y)) ` Y)", "using chain"], ["proof (prove)\nusing this:\n  Complete_Partial_Order.chain (\\<le>) Y\n\ngoal (1 subgoal):\n 1. Complete_Partial_Order.chain (\\<le>) ((\\<lambda>f y. f (x, y)) ` Y)", "by(rule chain_imageI)(simp add: le_fun_def)"], ["proof (state)\nthis:\n  Complete_Partial_Order.chain (\\<le>) ((\\<lambda>f y. f (?x, y)) ` Y)\n\ngoal (3 subgoals):\n 1. d_OUT (\\<Squnion> Y) x = (\\<Squnion>f\\<in>Y. d_OUT f x)\n 2. d_IN (\\<Squnion> Y) y = (\\<Squnion>f\\<in>Y. d_IN f y)\n 3. SINK (\\<Squnion> Y) = \\<Inter> (SINK ` Y)", "have countable': \"countable {y. (x, y) \\<in> support_flow (Sup Y)}\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. countable {y. (x, y) \\<in> support_flow (\\<Squnion> Y)}", "using _ countable[THEN countable_image[where f=snd]]"], ["proof (prove)\nusing this:\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  countable (snd ` support_flow (\\<Squnion> Y))\n\ngoal (1 subgoal):\n 1. countable {y. (x, y) \\<in> support_flow (\\<Squnion> Y)}", "by(rule countable_subset)(auto intro: prod.expand rev_image_eqI)"], ["proof (state)\nthis:\n  countable {y. (?x, y) \\<in> support_flow (\\<Squnion> Y)}\n\ngoal (3 subgoals):\n 1. d_OUT (\\<Squnion> Y) x = (\\<Squnion>f\\<in>Y. d_OUT f x)\n 2. d_IN (\\<Squnion> Y) y = (\\<Squnion>f\\<in>Y. d_IN f y)\n 3. SINK (\\<Squnion> Y) = \\<Inter> (SINK ` Y)", "{"], ["proof (state)\nthis:\n  countable {y. (?x, y) \\<in> support_flow (\\<Squnion> Y)}\n\ngoal (3 subgoals):\n 1. d_OUT (\\<Squnion> Y) x = (\\<Squnion>f\\<in>Y. d_OUT f x)\n 2. d_IN (\\<Squnion> Y) y = (\\<Squnion>f\\<in>Y. d_IN f y)\n 3. SINK (\\<Squnion> Y) = \\<Inter> (SINK ` Y)", "fix x"], ["proof (state)\ngoal (3 subgoals):\n 1. d_OUT (\\<Squnion> Y) x = (\\<Squnion>f\\<in>Y. d_OUT f x)\n 2. d_IN (\\<Squnion> Y) y = (\\<Squnion>f\\<in>Y. d_IN f y)\n 3. SINK (\\<Squnion> Y) = \\<Inter> (SINK ` Y)", "have \"?lhs1 x = (\\<Sum>\\<^sup>+ y\\<in>{y. (x, y) \\<in> support_flow (Sup Y)}. SUP f\\<in>Y. f (x, y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT (\\<Squnion> Y) x =\n    (\\<Sum>\\<^sup>+ y\\<in>{y. (x, y) \\<in> support_flow (\\<Squnion> Y)}.\n       \\<Squnion>f\\<in>Y. f (x, y))", "by(subst d_OUT_alt_def2; simp)"], ["proof (state)\nthis:\n  d_OUT (\\<Squnion> Y) x =\n  (\\<Sum>\\<^sup>+ y\\<in>{y. (x, y) \\<in> support_flow (\\<Squnion> Y)}.\n     \\<Squnion>f\\<in>Y. f (x, y))\n\ngoal (3 subgoals):\n 1. d_OUT (\\<Squnion> Y) x = (\\<Squnion>f\\<in>Y. d_OUT f x)\n 2. d_IN (\\<Squnion> Y) y = (\\<Squnion>f\\<in>Y. d_IN f y)\n 3. SINK (\\<Squnion> Y) = \\<Inter> (SINK ` Y)", "also"], ["proof (state)\nthis:\n  d_OUT (\\<Squnion> Y) x =\n  (\\<Sum>\\<^sup>+ y\\<in>{y. (x, y) \\<in> support_flow (\\<Squnion> Y)}.\n     \\<Squnion>f\\<in>Y. f (x, y))\n\ngoal (3 subgoals):\n 1. d_OUT (\\<Squnion> Y) x = (\\<Squnion>f\\<in>Y. d_OUT f x)\n 2. d_IN (\\<Squnion> Y) y = (\\<Squnion>f\\<in>Y. d_IN f y)\n 3. SINK (\\<Squnion> Y) = \\<Inter> (SINK ` Y)", "have \"\\<dots> = (SUP f\\<in>Y. \\<Sum>\\<^sup>+ y\\<in>{y. (x, y) \\<in> support_flow (Sup Y)}. f (x, y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y\\<in>{y. (x, y) \\<in> support_flow (\\<Squnion> Y)}.\n       \\<Squnion>f\\<in>Y. f (x, y)) =\n    (\\<Squnion>f\\<in>Y.\n        \\<Sum>\\<^sup>+ y\\<in>{y. (x, y) \\<in> support_flow (\\<Squnion> Y)}.\n          f (x, y))", "using Y"], ["proof (prove)\nusing this:\n  Y \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y\\<in>{y. (x, y) \\<in> support_flow (\\<Squnion> Y)}.\n       \\<Squnion>f\\<in>Y. f (x, y)) =\n    (\\<Squnion>f\\<in>Y.\n        \\<Sum>\\<^sup>+ y\\<in>{y. (x, y) \\<in> support_flow (\\<Squnion> Y)}.\n          f (x, y))", "by(rule nn_integral_monotone_convergence_SUP_countable)(auto simp add: chain' intro: countable')"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y\\<in>{y. (x, y) \\<in> support_flow (\\<Squnion> Y)}.\n     \\<Squnion>f\\<in>Y. f (x, y)) =\n  (\\<Squnion>f\\<in>Y.\n      \\<Sum>\\<^sup>+ y\\<in>{y. (x, y) \\<in> support_flow (\\<Squnion> Y)}.\n        f (x, y))\n\ngoal (3 subgoals):\n 1. d_OUT (\\<Squnion> Y) x = (\\<Squnion>f\\<in>Y. d_OUT f x)\n 2. d_IN (\\<Squnion> Y) y = (\\<Squnion>f\\<in>Y. d_IN f y)\n 3. SINK (\\<Squnion> Y) = \\<Inter> (SINK ` Y)", "also"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y\\<in>{y. (x, y) \\<in> support_flow (\\<Squnion> Y)}.\n     \\<Squnion>f\\<in>Y. f (x, y)) =\n  (\\<Squnion>f\\<in>Y.\n      \\<Sum>\\<^sup>+ y\\<in>{y. (x, y) \\<in> support_flow (\\<Squnion> Y)}.\n        f (x, y))\n\ngoal (3 subgoals):\n 1. d_OUT (\\<Squnion> Y) x = (\\<Squnion>f\\<in>Y. d_OUT f x)\n 2. d_IN (\\<Squnion> Y) y = (\\<Squnion>f\\<in>Y. d_IN f y)\n 3. SINK (\\<Squnion> Y) = \\<Inter> (SINK ` Y)", "have \"\\<dots> = ?rhs1 x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Squnion>f\\<in>Y.\n        \\<Sum>\\<^sup>+ y\\<in>{y. (x, y) \\<in> support_flow (\\<Squnion> Y)}.\n          f (x, y)) =\n    (\\<Squnion>f\\<in>Y. d_OUT f x)", "unfolding d_OUT_alt_def2"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Squnion>f\\<in>Y.\n        \\<Sum>\\<^sup>+ y\\<in>{y. (x, y) \\<in> support_flow (\\<Squnion> Y)}.\n          f (x, y)) =\n    (\\<Squnion>f\\<in>Y.\n        \\<Sum>\\<^sup>+ y\\<in>{y. (x, y) \\<in> support_flow f}. f (x, y))", "by(auto 4 3 simp add: support_flow_Sup max_def nn_integral_count_space_indicator intro!: nn_integral_cong SUP_cong split: split_indicator dest: not_in_support_flowD)"], ["proof (state)\nthis:\n  (\\<Squnion>f\\<in>Y.\n      \\<Sum>\\<^sup>+ y\\<in>{y. (x, y) \\<in> support_flow (\\<Squnion> Y)}.\n        f (x, y)) =\n  (\\<Squnion>f\\<in>Y. d_OUT f x)\n\ngoal (3 subgoals):\n 1. d_OUT (\\<Squnion> Y) x = (\\<Squnion>f\\<in>Y. d_OUT f x)\n 2. d_IN (\\<Squnion> Y) y = (\\<Squnion>f\\<in>Y. d_IN f y)\n 3. SINK (\\<Squnion> Y) = \\<Inter> (SINK ` Y)", "finally"], ["proof (chain)\npicking this:\n  d_OUT (\\<Squnion> Y) x = (\\<Squnion>f\\<in>Y. d_OUT f x)", "show \"?OUT x\""], ["proof (prove)\nusing this:\n  d_OUT (\\<Squnion> Y) x = (\\<Squnion>f\\<in>Y. d_OUT f x)\n\ngoal (1 subgoal):\n 1. d_OUT (\\<Squnion> Y) x = (\\<Squnion>f\\<in>Y. d_OUT f x)", "."], ["proof (state)\nthis:\n  d_OUT (\\<Squnion> Y) x = (\\<Squnion>f\\<in>Y. d_OUT f x)\n\ngoal (2 subgoals):\n 1. d_IN (\\<Squnion> Y) y = (\\<Squnion>f\\<in>Y. d_IN f y)\n 2. SINK (\\<Squnion> Y) = \\<Inter> (SINK ` Y)", "}"], ["proof (state)\nthis:\n  d_OUT (\\<Squnion> Y) ?xa2 = (\\<Squnion>f\\<in>Y. d_OUT f ?xa2)\n\ngoal (2 subgoals):\n 1. d_IN (\\<Squnion> Y) y = (\\<Squnion>f\\<in>Y. d_IN f y)\n 2. SINK (\\<Squnion> Y) = \\<Inter> (SINK ` Y)", "note out = this"], ["proof (state)\nthis:\n  d_OUT (\\<Squnion> Y) ?xa2 = (\\<Squnion>f\\<in>Y. d_OUT f ?xa2)\n\ngoal (2 subgoals):\n 1. d_IN (\\<Squnion> Y) y = (\\<Squnion>f\\<in>Y. d_IN f y)\n 2. SINK (\\<Squnion> Y) = \\<Inter> (SINK ` Y)", "have chain'': \"Complete_Partial_Order.chain (\\<le>) ((\\<lambda>f x. f (x, y)) ` Y)\" for y"], ["proof (prove)\ngoal (1 subgoal):\n 1. Complete_Partial_Order.chain (\\<le>) ((\\<lambda>f x. f (x, y)) ` Y)", "using chain"], ["proof (prove)\nusing this:\n  Complete_Partial_Order.chain (\\<le>) Y\n\ngoal (1 subgoal):\n 1. Complete_Partial_Order.chain (\\<le>) ((\\<lambda>f x. f (x, y)) ` Y)", "by(rule chain_imageI)(simp add: le_fun_def)"], ["proof (state)\nthis:\n  Complete_Partial_Order.chain (\\<le>) ((\\<lambda>f x. f (x, ?y)) ` Y)\n\ngoal (2 subgoals):\n 1. d_IN (\\<Squnion> Y) y = (\\<Squnion>f\\<in>Y. d_IN f y)\n 2. SINK (\\<Squnion> Y) = \\<Inter> (SINK ` Y)", "have countable'': \"countable {x. (x, y) \\<in> support_flow (Sup Y)}\" for y"], ["proof (prove)\ngoal (1 subgoal):\n 1. countable {x. (x, y) \\<in> support_flow (\\<Squnion> Y)}", "using _ countable[THEN countable_image[where f=fst]]"], ["proof (prove)\nusing this:\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  countable (fst ` support_flow (\\<Squnion> Y))\n\ngoal (1 subgoal):\n 1. countable {x. (x, y) \\<in> support_flow (\\<Squnion> Y)}", "by(rule countable_subset)(auto intro: prod.expand rev_image_eqI)"], ["proof (state)\nthis:\n  countable {x. (x, ?y) \\<in> support_flow (\\<Squnion> Y)}\n\ngoal (2 subgoals):\n 1. d_IN (\\<Squnion> Y) y = (\\<Squnion>f\\<in>Y. d_IN f y)\n 2. SINK (\\<Squnion> Y) = \\<Inter> (SINK ` Y)", "have \"?lhs2 = (\\<Sum>\\<^sup>+ x\\<in>{x. (x, y) \\<in> support_flow (Sup Y)}. SUP f\\<in>Y. f (x, y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN (\\<Squnion> Y) y =\n    (\\<Sum>\\<^sup>+ x\\<in>{x. (x, y) \\<in> support_flow (\\<Squnion> Y)}.\n       \\<Squnion>f\\<in>Y. f (x, y))", "by(subst d_IN_alt_def2; simp)"], ["proof (state)\nthis:\n  d_IN (\\<Squnion> Y) y =\n  (\\<Sum>\\<^sup>+ x\\<in>{x. (x, y) \\<in> support_flow (\\<Squnion> Y)}.\n     \\<Squnion>f\\<in>Y. f (x, y))\n\ngoal (2 subgoals):\n 1. d_IN (\\<Squnion> Y) y = (\\<Squnion>f\\<in>Y. d_IN f y)\n 2. SINK (\\<Squnion> Y) = \\<Inter> (SINK ` Y)", "also"], ["proof (state)\nthis:\n  d_IN (\\<Squnion> Y) y =\n  (\\<Sum>\\<^sup>+ x\\<in>{x. (x, y) \\<in> support_flow (\\<Squnion> Y)}.\n     \\<Squnion>f\\<in>Y. f (x, y))\n\ngoal (2 subgoals):\n 1. d_IN (\\<Squnion> Y) y = (\\<Squnion>f\\<in>Y. d_IN f y)\n 2. SINK (\\<Squnion> Y) = \\<Inter> (SINK ` Y)", "have \"\\<dots> = (SUP f\\<in>Y. \\<Sum>\\<^sup>+ x\\<in>{x. (x, y) \\<in> support_flow (Sup Y)}. f (x, y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ x\\<in>{x. (x, y) \\<in> support_flow (\\<Squnion> Y)}.\n       \\<Squnion>f\\<in>Y. f (x, y)) =\n    (\\<Squnion>f\\<in>Y.\n        \\<Sum>\\<^sup>+ x\\<in>{x. (x, y) \\<in> support_flow (\\<Squnion> Y)}.\n          f (x, y))", "using Y"], ["proof (prove)\nusing this:\n  Y \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ x\\<in>{x. (x, y) \\<in> support_flow (\\<Squnion> Y)}.\n       \\<Squnion>f\\<in>Y. f (x, y)) =\n    (\\<Squnion>f\\<in>Y.\n        \\<Sum>\\<^sup>+ x\\<in>{x. (x, y) \\<in> support_flow (\\<Squnion> Y)}.\n          f (x, y))", "by(rule nn_integral_monotone_convergence_SUP_countable)(simp_all add: chain'' countable'')"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ x\\<in>{x. (x, y) \\<in> support_flow (\\<Squnion> Y)}.\n     \\<Squnion>f\\<in>Y. f (x, y)) =\n  (\\<Squnion>f\\<in>Y.\n      \\<Sum>\\<^sup>+ x\\<in>{x. (x, y) \\<in> support_flow (\\<Squnion> Y)}.\n        f (x, y))\n\ngoal (2 subgoals):\n 1. d_IN (\\<Squnion> Y) y = (\\<Squnion>f\\<in>Y. d_IN f y)\n 2. SINK (\\<Squnion> Y) = \\<Inter> (SINK ` Y)", "also"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ x\\<in>{x. (x, y) \\<in> support_flow (\\<Squnion> Y)}.\n     \\<Squnion>f\\<in>Y. f (x, y)) =\n  (\\<Squnion>f\\<in>Y.\n      \\<Sum>\\<^sup>+ x\\<in>{x. (x, y) \\<in> support_flow (\\<Squnion> Y)}.\n        f (x, y))\n\ngoal (2 subgoals):\n 1. d_IN (\\<Squnion> Y) y = (\\<Squnion>f\\<in>Y. d_IN f y)\n 2. SINK (\\<Squnion> Y) = \\<Inter> (SINK ` Y)", "have \"\\<dots> = ?rhs2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Squnion>f\\<in>Y.\n        \\<Sum>\\<^sup>+ x\\<in>{x. (x, y) \\<in> support_flow (\\<Squnion> Y)}.\n          f (x, y)) =\n    (\\<Squnion>f\\<in>Y. d_IN f y)", "unfolding d_IN_alt_def2"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Squnion>f\\<in>Y.\n        \\<Sum>\\<^sup>+ x\\<in>{x. (x, y) \\<in> support_flow (\\<Squnion> Y)}.\n          f (x, y)) =\n    (\\<Squnion>f\\<in>Y.\n        \\<Sum>\\<^sup>+ x\\<in>{x. (x, y) \\<in> support_flow f}. f (x, y))", "by(auto 4 3 simp add: support_flow_Sup max_def nn_integral_count_space_indicator intro!: nn_integral_cong SUP_cong split: split_indicator dest: not_in_support_flowD)"], ["proof (state)\nthis:\n  (\\<Squnion>f\\<in>Y.\n      \\<Sum>\\<^sup>+ x\\<in>{x. (x, y) \\<in> support_flow (\\<Squnion> Y)}.\n        f (x, y)) =\n  (\\<Squnion>f\\<in>Y. d_IN f y)\n\ngoal (2 subgoals):\n 1. d_IN (\\<Squnion> Y) y = (\\<Squnion>f\\<in>Y. d_IN f y)\n 2. SINK (\\<Squnion> Y) = \\<Inter> (SINK ` Y)", "finally"], ["proof (chain)\npicking this:\n  d_IN (\\<Squnion> Y) y = (\\<Squnion>f\\<in>Y. d_IN f y)", "show ?IN"], ["proof (prove)\nusing this:\n  d_IN (\\<Squnion> Y) y = (\\<Squnion>f\\<in>Y. d_IN f y)\n\ngoal (1 subgoal):\n 1. d_IN (\\<Squnion> Y) y = (\\<Squnion>f\\<in>Y. d_IN f y)", "."], ["proof (state)\nthis:\n  d_IN (\\<Squnion> Y) y = (\\<Squnion>f\\<in>Y. d_IN f y)\n\ngoal (1 subgoal):\n 1. SINK (\\<Squnion> Y) = \\<Inter> (SINK ` Y)", "show ?SINK"], ["proof (prove)\ngoal (1 subgoal):\n 1. SINK (\\<Squnion> Y) = \\<Inter> (SINK ` Y)", "by(rule set_eqI)(simp add: SINK.simps out Y bot_ennreal[symmetric])"], ["proof (state)\nthis:\n  SINK (\\<Squnion> Y) = \\<Inter> (SINK ` Y)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma\n  assumes chain: \"Complete_Partial_Order.chain (\\<le>) Y\"\n  and Y: \"Y \\<noteq> {}\"\n  and countable: \"countable (support_flow f)\"\n  and bounded: \"\\<And>g e. g \\<in> Y \\<Longrightarrow> g e \\<le> f e\"\n  shows d_OUT_Inf: \"d_OUT f x \\<noteq> top \\<Longrightarrow> d_OUT (Inf Y) x = (INF g\\<in>Y. d_OUT g x)\" (is \"_ \\<Longrightarrow> ?OUT\" is \"_ \\<Longrightarrow> ?lhs1 = ?rhs1\")\n  and d_IN_Inf: \"d_IN f x \\<noteq> top \\<Longrightarrow> d_IN (Inf Y) x = (INF g\\<in>Y. d_IN g x)\" (is \"_ \\<Longrightarrow> ?IN\" is \"_ \\<Longrightarrow> ?lhs2 = ?rhs2\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (d_OUT f x \\<noteq> \\<top> \\<Longrightarrow>\n     d_OUT (\\<Sqinter> Y) x = (\\<Sqinter>g\\<in>Y. d_OUT g x)) &&&\n    (d_IN f x \\<noteq> \\<top> \\<Longrightarrow>\n     d_IN (\\<Sqinter> Y) x = (\\<Sqinter>g\\<in>Y. d_IN g x))", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. d_OUT f x \\<noteq> \\<top> \\<Longrightarrow>\n    d_OUT (\\<Sqinter> Y) x = (\\<Sqinter>g\\<in>Y. d_OUT g x)\n 2. d_IN f x \\<noteq> \\<top> \\<Longrightarrow>\n    d_IN (\\<Sqinter> Y) x = (\\<Sqinter>g\\<in>Y. d_IN g x)", "text \\<open>We take a detour here via suprema because we have more theorems about @{const nn_integral}\n    with suprema than with infinma.\\<close>"], ["proof (state)\ngoal (2 subgoals):\n 1. d_OUT f x \\<noteq> \\<top> \\<Longrightarrow>\n    d_OUT (\\<Sqinter> Y) x = (\\<Sqinter>g\\<in>Y. d_OUT g x)\n 2. d_IN f x \\<noteq> \\<top> \\<Longrightarrow>\n    d_IN (\\<Sqinter> Y) x = (\\<Sqinter>g\\<in>Y. d_IN g x)", "from Y"], ["proof (chain)\npicking this:\n  Y \\<noteq> {}", "obtain g0 where g0: \"g0 \\<in> Y\""], ["proof (prove)\nusing this:\n  Y \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>g0. g0 \\<in> Y \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  g0 \\<in> Y\n\ngoal (2 subgoals):\n 1. d_OUT f x \\<noteq> \\<top> \\<Longrightarrow>\n    d_OUT (\\<Sqinter> Y) x = (\\<Sqinter>g\\<in>Y. d_OUT g x)\n 2. d_IN f x \\<noteq> \\<top> \\<Longrightarrow>\n    d_IN (\\<Sqinter> Y) x = (\\<Sqinter>g\\<in>Y. d_IN g x)", "have g0_le_f: \"g0 e \\<le> f e\" for e"], ["proof (prove)\ngoal (1 subgoal):\n 1. g0 e \\<le> f e", "by(rule bounded[OF g0])"], ["proof (state)\nthis:\n  g0 ?e \\<le> f ?e\n\ngoal (2 subgoals):\n 1. d_OUT f x \\<noteq> \\<top> \\<Longrightarrow>\n    d_OUT (\\<Sqinter> Y) x = (\\<Sqinter>g\\<in>Y. d_OUT g x)\n 2. d_IN f x \\<noteq> \\<top> \\<Longrightarrow>\n    d_IN (\\<Sqinter> Y) x = (\\<Sqinter>g\\<in>Y. d_IN g x)", "have \"support_flow (SUP g\\<in>Y. (\\<lambda>e. f e - g e)) \\<subseteq> support_flow f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. support_flow (\\<Squnion>g\\<in>Y. (\\<lambda>e. f e - g e))\n    \\<subseteq> support_flow f", "by(clarsimp simp add: support_flow.simps less_SUP_iff elim!: less_le_trans intro!: diff_le_self_ennreal)"], ["proof (state)\nthis:\n  support_flow (\\<Squnion>g\\<in>Y. (\\<lambda>e. f e - g e))\n  \\<subseteq> support_flow f\n\ngoal (2 subgoals):\n 1. d_OUT f x \\<noteq> \\<top> \\<Longrightarrow>\n    d_OUT (\\<Sqinter> Y) x = (\\<Sqinter>g\\<in>Y. d_OUT g x)\n 2. d_IN f x \\<noteq> \\<top> \\<Longrightarrow>\n    d_IN (\\<Sqinter> Y) x = (\\<Sqinter>g\\<in>Y. d_IN g x)", "then"], ["proof (chain)\npicking this:\n  support_flow (\\<Squnion>g\\<in>Y. (\\<lambda>e. f e - g e))\n  \\<subseteq> support_flow f", "have countable': \"countable (support_flow (SUP g\\<in>Y. (\\<lambda>e. f e - g e)))\""], ["proof (prove)\nusing this:\n  support_flow (\\<Squnion>g\\<in>Y. (\\<lambda>e. f e - g e))\n  \\<subseteq> support_flow f\n\ngoal (1 subgoal):\n 1. countable (support_flow (\\<Squnion>g\\<in>Y. (\\<lambda>e. f e - g e)))", "by(rule countable_subset)(rule countable)"], ["proof (state)\nthis:\n  countable (support_flow (\\<Squnion>g\\<in>Y. (\\<lambda>e. f e - g e)))\n\ngoal (2 subgoals):\n 1. d_OUT f x \\<noteq> \\<top> \\<Longrightarrow>\n    d_OUT (\\<Sqinter> Y) x = (\\<Sqinter>g\\<in>Y. d_OUT g x)\n 2. d_IN f x \\<noteq> \\<top> \\<Longrightarrow>\n    d_IN (\\<Sqinter> Y) x = (\\<Sqinter>g\\<in>Y. d_IN g x)", "have \"Complete_Partial_Order.chain (\\<ge>) Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Complete_Partial_Order.chain (\\<lambda>x y. y \\<le> x) Y", "using chain"], ["proof (prove)\nusing this:\n  Complete_Partial_Order.chain (\\<le>) Y\n\ngoal (1 subgoal):\n 1. Complete_Partial_Order.chain (\\<lambda>x y. y \\<le> x) Y", "by(simp add: chain_dual)"], ["proof (state)\nthis:\n  Complete_Partial_Order.chain (\\<lambda>x y. y \\<le> x) Y\n\ngoal (2 subgoals):\n 1. d_OUT f x \\<noteq> \\<top> \\<Longrightarrow>\n    d_OUT (\\<Sqinter> Y) x = (\\<Sqinter>g\\<in>Y. d_OUT g x)\n 2. d_IN f x \\<noteq> \\<top> \\<Longrightarrow>\n    d_IN (\\<Sqinter> Y) x = (\\<Sqinter>g\\<in>Y. d_IN g x)", "hence chain': \"Complete_Partial_Order.chain (\\<le>) ((\\<lambda>g e. f e - g e) ` Y)\""], ["proof (prove)\nusing this:\n  Complete_Partial_Order.chain (\\<lambda>x y. y \\<le> x) Y\n\ngoal (1 subgoal):\n 1. Complete_Partial_Order.chain (\\<le>) ((\\<lambda>g e. f e - g e) ` Y)", "by(rule chain_imageI)(auto simp add: le_fun_def intro: ennreal_minus_mono)"], ["proof (state)\nthis:\n  Complete_Partial_Order.chain (\\<le>) ((\\<lambda>g e. f e - g e) ` Y)\n\ngoal (2 subgoals):\n 1. d_OUT f x \\<noteq> \\<top> \\<Longrightarrow>\n    d_OUT (\\<Sqinter> Y) x = (\\<Sqinter>g\\<in>Y. d_OUT g x)\n 2. d_IN f x \\<noteq> \\<top> \\<Longrightarrow>\n    d_IN (\\<Sqinter> Y) x = (\\<Sqinter>g\\<in>Y. d_IN g x)", "{"], ["proof (state)\nthis:\n  Complete_Partial_Order.chain (\\<le>) ((\\<lambda>g e. f e - g e) ` Y)\n\ngoal (2 subgoals):\n 1. d_OUT f x \\<noteq> \\<top> \\<Longrightarrow>\n    d_OUT (\\<Sqinter> Y) x = (\\<Sqinter>g\\<in>Y. d_OUT g x)\n 2. d_IN f x \\<noteq> \\<top> \\<Longrightarrow>\n    d_IN (\\<Sqinter> Y) x = (\\<Sqinter>g\\<in>Y. d_IN g x)", "assume finite: \"d_OUT f x \\<noteq> top\""], ["proof (state)\nthis:\n  d_OUT f x \\<noteq> \\<top>\n\ngoal (2 subgoals):\n 1. d_OUT f x \\<noteq> \\<top> \\<Longrightarrow>\n    d_OUT (\\<Sqinter> Y) x = (\\<Sqinter>g\\<in>Y. d_OUT g x)\n 2. d_IN f x \\<noteq> \\<top> \\<Longrightarrow>\n    d_IN (\\<Sqinter> Y) x = (\\<Sqinter>g\\<in>Y. d_IN g x)", "have finite' [simp]: \"f (x, y) \\<noteq> \\<top>\" for y"], ["proof (prove)\ngoal (1 subgoal):\n 1. f (x, y) \\<noteq> \\<top>", "using finite"], ["proof (prove)\nusing this:\n  d_OUT f x \\<noteq> \\<top>\n\ngoal (1 subgoal):\n 1. f (x, y) \\<noteq> \\<top>", "by(rule neq_top_trans) (rule d_OUT_ge_point)"], ["proof (state)\nthis:\n  f (x, ?y) \\<noteq> \\<top>\n\ngoal (2 subgoals):\n 1. d_OUT f x \\<noteq> \\<top> \\<Longrightarrow>\n    d_OUT (\\<Sqinter> Y) x = (\\<Sqinter>g\\<in>Y. d_OUT g x)\n 2. d_IN f x \\<noteq> \\<top> \\<Longrightarrow>\n    d_IN (\\<Sqinter> Y) x = (\\<Sqinter>g\\<in>Y. d_IN g x)", "have finite'_g: \"g (x, y) \\<noteq> \\<top>\" if \"g \\<in> Y\" for g y"], ["proof (prove)\ngoal (1 subgoal):\n 1. g (x, y) \\<noteq> \\<top>", "using finite'[of y]"], ["proof (prove)\nusing this:\n  f (x, y) \\<noteq> \\<top>\n\ngoal (1 subgoal):\n 1. g (x, y) \\<noteq> \\<top>", "by(rule neq_top_trans)(rule bounded[OF that])"], ["proof (state)\nthis:\n  ?g \\<in> Y \\<Longrightarrow> ?g (x, ?y) \\<noteq> \\<top>\n\ngoal (2 subgoals):\n 1. d_OUT f x \\<noteq> \\<top> \\<Longrightarrow>\n    d_OUT (\\<Sqinter> Y) x = (\\<Sqinter>g\\<in>Y. d_OUT g x)\n 2. d_IN f x \\<noteq> \\<top> \\<Longrightarrow>\n    d_IN (\\<Sqinter> Y) x = (\\<Sqinter>g\\<in>Y. d_IN g x)", "have finite1: \"(\\<Sum>\\<^sup>+ y. f (x, y) - (INF g\\<in>Y. g (x, y))) \\<noteq> top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y. f (x, y) - (\\<Sqinter>g\\<in>Y. g (x, y))) \\<noteq>\n    \\<top>", "using finite"], ["proof (prove)\nusing this:\n  d_OUT f x \\<noteq> \\<top>\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y. f (x, y) - (\\<Sqinter>g\\<in>Y. g (x, y))) \\<noteq>\n    \\<top>", "by(rule neq_top_trans)(auto simp add: d_OUT_def intro!: nn_integral_mono)"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y. f (x, y) - (\\<Sqinter>g\\<in>Y. g (x, y))) \\<noteq>\n  \\<top>\n\ngoal (2 subgoals):\n 1. d_OUT f x \\<noteq> \\<top> \\<Longrightarrow>\n    d_OUT (\\<Sqinter> Y) x = (\\<Sqinter>g\\<in>Y. d_OUT g x)\n 2. d_IN f x \\<noteq> \\<top> \\<Longrightarrow>\n    d_IN (\\<Sqinter> Y) x = (\\<Sqinter>g\\<in>Y. d_IN g x)", "have finite2: \"d_OUT g x \\<noteq> top\" if \"g \\<in> Y\" for g"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT g x \\<noteq> \\<top>", "using finite"], ["proof (prove)\nusing this:\n  d_OUT f x \\<noteq> \\<top>\n\ngoal (1 subgoal):\n 1. d_OUT g x \\<noteq> \\<top>", "by(rule neq_top_trans)(auto intro: d_OUT_mono bounded[OF that])"], ["proof (state)\nthis:\n  ?g \\<in> Y \\<Longrightarrow> d_OUT ?g x \\<noteq> \\<top>\n\ngoal (2 subgoals):\n 1. d_OUT f x \\<noteq> \\<top> \\<Longrightarrow>\n    d_OUT (\\<Sqinter> Y) x = (\\<Sqinter>g\\<in>Y. d_OUT g x)\n 2. d_IN f x \\<noteq> \\<top> \\<Longrightarrow>\n    d_IN (\\<Sqinter> Y) x = (\\<Sqinter>g\\<in>Y. d_IN g x)", "have bounded1: \"(\\<Sqinter>g\\<in>Y. d_OUT g x) \\<le> d_OUT f x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sqinter>g\\<in>Y. d_OUT g x) \\<le> d_OUT f x", "using Y"], ["proof (prove)\nusing this:\n  Y \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<Sqinter>g\\<in>Y. d_OUT g x) \\<le> d_OUT f x", "by (blast intro: INF_lower2 d_OUT_mono bounded)"], ["proof (state)\nthis:\n  (\\<Sqinter>g\\<in>Y. d_OUT g x) \\<le> d_OUT f x\n\ngoal (2 subgoals):\n 1. d_OUT f x \\<noteq> \\<top> \\<Longrightarrow>\n    d_OUT (\\<Sqinter> Y) x = (\\<Sqinter>g\\<in>Y. d_OUT g x)\n 2. d_IN f x \\<noteq> \\<top> \\<Longrightarrow>\n    d_IN (\\<Sqinter> Y) x = (\\<Sqinter>g\\<in>Y. d_IN g x)", "have \"?lhs1 = (\\<Sum>\\<^sup>+ y. INF g\\<in>Y. g (x, y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT (\\<Sqinter> Y) x = (\\<Sum>\\<^sup>+ y. \\<Sqinter>g\\<in>Y. g (x, y))", "by(simp add: d_OUT_def)"], ["proof (state)\nthis:\n  d_OUT (\\<Sqinter> Y) x = (\\<Sum>\\<^sup>+ y. \\<Sqinter>g\\<in>Y. g (x, y))\n\ngoal (2 subgoals):\n 1. d_OUT f x \\<noteq> \\<top> \\<Longrightarrow>\n    d_OUT (\\<Sqinter> Y) x = (\\<Sqinter>g\\<in>Y. d_OUT g x)\n 2. d_IN f x \\<noteq> \\<top> \\<Longrightarrow>\n    d_IN (\\<Sqinter> Y) x = (\\<Sqinter>g\\<in>Y. d_IN g x)", "also"], ["proof (state)\nthis:\n  d_OUT (\\<Sqinter> Y) x = (\\<Sum>\\<^sup>+ y. \\<Sqinter>g\\<in>Y. g (x, y))\n\ngoal (2 subgoals):\n 1. d_OUT f x \\<noteq> \\<top> \\<Longrightarrow>\n    d_OUT (\\<Sqinter> Y) x = (\\<Sqinter>g\\<in>Y. d_OUT g x)\n 2. d_IN f x \\<noteq> \\<top> \\<Longrightarrow>\n    d_IN (\\<Sqinter> Y) x = (\\<Sqinter>g\\<in>Y. d_IN g x)", "have \"\\<dots> = d_OUT f x - (\\<Sum>\\<^sup>+ y. f (x, y) - (INF g\\<in>Y. g (x, y)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y. \\<Sqinter>g\\<in>Y. g (x, y)) =\n    d_OUT f x - (\\<Sum>\\<^sup>+ y. f (x, y) - (\\<Sqinter>g\\<in>Y. g (x, y)))", "unfolding d_OUT_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y. \\<Sqinter>g\\<in>Y. g (x, y)) =\n    (\\<Sum>\\<^sup>+ y. f (x, y)) -\n    (\\<Sum>\\<^sup>+ y. f (x, y) - (\\<Sqinter>g\\<in>Y. g (x, y)))", "using finite1 g0_le_f"], ["proof (prove)\nusing this:\n  (\\<Sum>\\<^sup>+ y. f (x, y) - (\\<Sqinter>g\\<in>Y. g (x, y))) \\<noteq>\n  \\<top>\n  g0 ?e \\<le> f ?e\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y. \\<Sqinter>g\\<in>Y. g (x, y)) =\n    (\\<Sum>\\<^sup>+ y. f (x, y)) -\n    (\\<Sum>\\<^sup>+ y. f (x, y) - (\\<Sqinter>g\\<in>Y. g (x, y)))", "apply(subst nn_integral_diff[symmetric])"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>(\\<Sum>\\<^sup>+ y.\n                f (x, y) - (\\<Sqinter>g\\<in>Y. g (x, y))) \\<noteq>\n             \\<top>;\n     \\<And>e. g0 e \\<le> f e\\<rbrakk>\n    \\<Longrightarrow> (\\<lambda>y. f (x, y))\n                      \\<in> borel_measurable (count_space UNIV)\n 2. \\<lbrakk>(\\<Sum>\\<^sup>+ y.\n                f (x, y) - (\\<Sqinter>g\\<in>Y. g (x, y))) \\<noteq>\n             \\<top>;\n     \\<And>e. g0 e \\<le> f e\\<rbrakk>\n    \\<Longrightarrow> (\\<lambda>y. f (x, y) - (\\<Sqinter>g\\<in>Y. g (x, y)))\n                      \\<in> borel_measurable (count_space UNIV)\n 3. \\<lbrakk>(\\<Sum>\\<^sup>+ y.\n                f (x, y) - (\\<Sqinter>g\\<in>Y. g (x, y))) \\<noteq>\n             \\<top>;\n     \\<And>e. g0 e \\<le> f e\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>\\<^sup>+ y.\n                         f (x, y) - (\\<Sqinter>g\\<in>Y. g (x, y))) \\<noteq>\n                      \\<infinity>\n 4. \\<lbrakk>(\\<Sum>\\<^sup>+ y.\n                f (x, y) - (\\<Sqinter>g\\<in>Y. g (x, y))) \\<noteq>\n             \\<top>;\n     \\<And>e. g0 e \\<le> f e\\<rbrakk>\n    \\<Longrightarrow> AE xa in count_space\n                                UNIV. f (x, xa) -\n(\\<Sqinter>g\\<in>Y. g (x, xa))\n\\<le> f (x, xa)\n 5. \\<lbrakk>(\\<Sum>\\<^sup>+ y.\n                f (x, y) - (\\<Sqinter>g\\<in>Y. g (x, y))) \\<noteq>\n             \\<top>;\n     \\<And>e. g0 e \\<le> f e\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>\\<^sup>+ y. \\<Sqinter>g\\<in>Y. g (x, y)) =\n                      (\\<Sum>\\<^sup>+ xa.\n                         f (x, xa) -\n                         (f (x, xa) - (\\<Sqinter>g\\<in>Y. g (x, xa))))", "apply(auto simp add: AE_count_space intro!: diff_le_self_ennreal INF_lower2[OF g0] nn_integral_cong diff_diff_ennreal[symmetric])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y. \\<Sqinter>g\\<in>Y. g (x, y)) =\n  d_OUT f x - (\\<Sum>\\<^sup>+ y. f (x, y) - (\\<Sqinter>g\\<in>Y. g (x, y)))\n\ngoal (2 subgoals):\n 1. d_OUT f x \\<noteq> \\<top> \\<Longrightarrow>\n    d_OUT (\\<Sqinter> Y) x = (\\<Sqinter>g\\<in>Y. d_OUT g x)\n 2. d_IN f x \\<noteq> \\<top> \\<Longrightarrow>\n    d_IN (\\<Sqinter> Y) x = (\\<Sqinter>g\\<in>Y. d_IN g x)", "also"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y. \\<Sqinter>g\\<in>Y. g (x, y)) =\n  d_OUT f x - (\\<Sum>\\<^sup>+ y. f (x, y) - (\\<Sqinter>g\\<in>Y. g (x, y)))\n\ngoal (2 subgoals):\n 1. d_OUT f x \\<noteq> \\<top> \\<Longrightarrow>\n    d_OUT (\\<Sqinter> Y) x = (\\<Sqinter>g\\<in>Y. d_OUT g x)\n 2. d_IN f x \\<noteq> \\<top> \\<Longrightarrow>\n    d_IN (\\<Sqinter> Y) x = (\\<Sqinter>g\\<in>Y. d_IN g x)", "have \"(\\<Sum>\\<^sup>+ y. f (x, y) - (INF g\\<in>Y. g (x, y))) = d_OUT (\\<lambda>e. SUP g\\<in>Y. f e - g e) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y. f (x, y) - (\\<Sqinter>g\\<in>Y. g (x, y))) =\n    d_OUT (\\<lambda>e. \\<Squnion>g\\<in>Y. f e - g e) x", "unfolding d_OUT_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y. f (x, y) - (\\<Sqinter>g\\<in>Y. g (x, y))) =\n    (\\<Sum>\\<^sup>+ y. \\<Squnion>g\\<in>Y. f (x, y) - g (x, y))", "by(subst SUP_const_minus_ennreal)(simp_all add: Y)"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y. f (x, y) - (\\<Sqinter>g\\<in>Y. g (x, y))) =\n  d_OUT (\\<lambda>e. \\<Squnion>g\\<in>Y. f e - g e) x\n\ngoal (2 subgoals):\n 1. d_OUT f x \\<noteq> \\<top> \\<Longrightarrow>\n    d_OUT (\\<Sqinter> Y) x = (\\<Sqinter>g\\<in>Y. d_OUT g x)\n 2. d_IN f x \\<noteq> \\<top> \\<Longrightarrow>\n    d_IN (\\<Sqinter> Y) x = (\\<Sqinter>g\\<in>Y. d_IN g x)", "also"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y. f (x, y) - (\\<Sqinter>g\\<in>Y. g (x, y))) =\n  d_OUT (\\<lambda>e. \\<Squnion>g\\<in>Y. f e - g e) x\n\ngoal (2 subgoals):\n 1. d_OUT f x \\<noteq> \\<top> \\<Longrightarrow>\n    d_OUT (\\<Sqinter> Y) x = (\\<Sqinter>g\\<in>Y. d_OUT g x)\n 2. d_IN f x \\<noteq> \\<top> \\<Longrightarrow>\n    d_IN (\\<Sqinter> Y) x = (\\<Sqinter>g\\<in>Y. d_IN g x)", "have \"\\<dots> = (SUP h\\<in>(\\<lambda>g e. f e - g e) ` Y. d_OUT h x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT (\\<lambda>e. \\<Squnion>g\\<in>Y. f e - g e) x =\n    (\\<Squnion>h\\<in>(\\<lambda>g e. f e - g e) ` Y. d_OUT h x)", "using countable' chain' Y"], ["proof (prove)\nusing this:\n  countable (support_flow (\\<Squnion>g\\<in>Y. (\\<lambda>e. f e - g e)))\n  Complete_Partial_Order.chain (\\<le>) ((\\<lambda>g e. f e - g e) ` Y)\n  Y \\<noteq> {}\n\ngoal (1 subgoal):\n 1. d_OUT (\\<lambda>e. \\<Squnion>g\\<in>Y. f e - g e) x =\n    (\\<Squnion>h\\<in>(\\<lambda>g e. f e - g e) ` Y. d_OUT h x)", "by(subst d_OUT_Sup[symmetric])(simp_all add: SUP_apply[abs_def])"], ["proof (state)\nthis:\n  d_OUT (\\<lambda>e. \\<Squnion>g\\<in>Y. f e - g e) x =\n  (\\<Squnion>h\\<in>(\\<lambda>g e. f e - g e) ` Y. d_OUT h x)\n\ngoal (2 subgoals):\n 1. d_OUT f x \\<noteq> \\<top> \\<Longrightarrow>\n    d_OUT (\\<Sqinter> Y) x = (\\<Sqinter>g\\<in>Y. d_OUT g x)\n 2. d_IN f x \\<noteq> \\<top> \\<Longrightarrow>\n    d_IN (\\<Sqinter> Y) x = (\\<Sqinter>g\\<in>Y. d_IN g x)", "also"], ["proof (state)\nthis:\n  d_OUT (\\<lambda>e. \\<Squnion>g\\<in>Y. f e - g e) x =\n  (\\<Squnion>h\\<in>(\\<lambda>g e. f e - g e) ` Y. d_OUT h x)\n\ngoal (2 subgoals):\n 1. d_OUT f x \\<noteq> \\<top> \\<Longrightarrow>\n    d_OUT (\\<Sqinter> Y) x = (\\<Sqinter>g\\<in>Y. d_OUT g x)\n 2. d_IN f x \\<noteq> \\<top> \\<Longrightarrow>\n    d_IN (\\<Sqinter> Y) x = (\\<Sqinter>g\\<in>Y. d_IN g x)", "have \"\\<dots> = (SUP g\\<in>Y. d_OUT (\\<lambda>e. f e - g e) x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Squnion>h\\<in>(\\<lambda>g e. f e - g e) ` Y. d_OUT h x) =\n    (\\<Squnion>g\\<in>Y. d_OUT (\\<lambda>e. f e - g e) x)", "unfolding image_image"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Squnion>xa\\<in>Y. d_OUT (\\<lambda>e. f e - xa e) x) =\n    (\\<Squnion>g\\<in>Y. d_OUT (\\<lambda>e. f e - g e) x)", ".."], ["proof (state)\nthis:\n  (\\<Squnion>h\\<in>(\\<lambda>g e. f e - g e) ` Y. d_OUT h x) =\n  (\\<Squnion>g\\<in>Y. d_OUT (\\<lambda>e. f e - g e) x)\n\ngoal (2 subgoals):\n 1. d_OUT f x \\<noteq> \\<top> \\<Longrightarrow>\n    d_OUT (\\<Sqinter> Y) x = (\\<Sqinter>g\\<in>Y. d_OUT g x)\n 2. d_IN f x \\<noteq> \\<top> \\<Longrightarrow>\n    d_IN (\\<Sqinter> Y) x = (\\<Sqinter>g\\<in>Y. d_IN g x)", "also"], ["proof (state)\nthis:\n  (\\<Squnion>h\\<in>(\\<lambda>g e. f e - g e) ` Y. d_OUT h x) =\n  (\\<Squnion>g\\<in>Y. d_OUT (\\<lambda>e. f e - g e) x)\n\ngoal (2 subgoals):\n 1. d_OUT f x \\<noteq> \\<top> \\<Longrightarrow>\n    d_OUT (\\<Sqinter> Y) x = (\\<Sqinter>g\\<in>Y. d_OUT g x)\n 2. d_IN f x \\<noteq> \\<top> \\<Longrightarrow>\n    d_IN (\\<Sqinter> Y) x = (\\<Sqinter>g\\<in>Y. d_IN g x)", "have \"\\<dots> = (SUP g\\<in>Y. d_OUT f x - d_OUT g x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Squnion>g\\<in>Y. d_OUT (\\<lambda>e. f e - g e) x) =\n    (\\<Squnion>g\\<in>Y. d_OUT f x - d_OUT g x)", "by(rule SUP_cong[OF refl] d_OUT_diff)+(auto intro: bounded simp add: finite2)"], ["proof (state)\nthis:\n  (\\<Squnion>g\\<in>Y. d_OUT (\\<lambda>e. f e - g e) x) =\n  (\\<Squnion>g\\<in>Y. d_OUT f x - d_OUT g x)\n\ngoal (2 subgoals):\n 1. d_OUT f x \\<noteq> \\<top> \\<Longrightarrow>\n    d_OUT (\\<Sqinter> Y) x = (\\<Sqinter>g\\<in>Y. d_OUT g x)\n 2. d_IN f x \\<noteq> \\<top> \\<Longrightarrow>\n    d_IN (\\<Sqinter> Y) x = (\\<Sqinter>g\\<in>Y. d_IN g x)", "also"], ["proof (state)\nthis:\n  (\\<Squnion>g\\<in>Y. d_OUT (\\<lambda>e. f e - g e) x) =\n  (\\<Squnion>g\\<in>Y. d_OUT f x - d_OUT g x)\n\ngoal (2 subgoals):\n 1. d_OUT f x \\<noteq> \\<top> \\<Longrightarrow>\n    d_OUT (\\<Sqinter> Y) x = (\\<Sqinter>g\\<in>Y. d_OUT g x)\n 2. d_IN f x \\<noteq> \\<top> \\<Longrightarrow>\n    d_IN (\\<Sqinter> Y) x = (\\<Sqinter>g\\<in>Y. d_IN g x)", "have \"\\<dots> = d_OUT f x - ?rhs1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Squnion>g\\<in>Y. d_OUT f x - d_OUT g x) =\n    d_OUT f x - (\\<Sqinter>g\\<in>Y. d_OUT g x)", "by(subst SUP_const_minus_ennreal)(simp_all add: Y)"], ["proof (state)\nthis:\n  (\\<Squnion>g\\<in>Y. d_OUT f x - d_OUT g x) =\n  d_OUT f x - (\\<Sqinter>g\\<in>Y. d_OUT g x)\n\ngoal (2 subgoals):\n 1. d_OUT f x \\<noteq> \\<top> \\<Longrightarrow>\n    d_OUT (\\<Sqinter> Y) x = (\\<Sqinter>g\\<in>Y. d_OUT g x)\n 2. d_IN f x \\<noteq> \\<top> \\<Longrightarrow>\n    d_IN (\\<Sqinter> Y) x = (\\<Sqinter>g\\<in>Y. d_IN g x)", "also"], ["proof (state)\nthis:\n  (\\<Squnion>g\\<in>Y. d_OUT f x - d_OUT g x) =\n  d_OUT f x - (\\<Sqinter>g\\<in>Y. d_OUT g x)\n\ngoal (2 subgoals):\n 1. d_OUT f x \\<noteq> \\<top> \\<Longrightarrow>\n    d_OUT (\\<Sqinter> Y) x = (\\<Sqinter>g\\<in>Y. d_OUT g x)\n 2. d_IN f x \\<noteq> \\<top> \\<Longrightarrow>\n    d_IN (\\<Sqinter> Y) x = (\\<Sqinter>g\\<in>Y. d_IN g x)", "have \"d_OUT f x - \\<dots> = ?rhs1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT f x - (d_OUT f x - (\\<Sqinter>g\\<in>Y. d_OUT g x)) =\n    (\\<Sqinter>g\\<in>Y. d_OUT g x)", "using Y"], ["proof (prove)\nusing this:\n  Y \\<noteq> {}\n\ngoal (1 subgoal):\n 1. d_OUT f x - (d_OUT f x - (\\<Sqinter>g\\<in>Y. d_OUT g x)) =\n    (\\<Sqinter>g\\<in>Y. d_OUT g x)", "by(subst diff_diff_ennreal)(simp_all add: bounded1 finite)"], ["proof (state)\nthis:\n  d_OUT f x - (d_OUT f x - (\\<Sqinter>g\\<in>Y. d_OUT g x)) =\n  (\\<Sqinter>g\\<in>Y. d_OUT g x)\n\ngoal (2 subgoals):\n 1. d_OUT f x \\<noteq> \\<top> \\<Longrightarrow>\n    d_OUT (\\<Sqinter> Y) x = (\\<Sqinter>g\\<in>Y. d_OUT g x)\n 2. d_IN f x \\<noteq> \\<top> \\<Longrightarrow>\n    d_IN (\\<Sqinter> Y) x = (\\<Sqinter>g\\<in>Y. d_IN g x)", "finally"], ["proof (chain)\npicking this:\n  d_OUT (\\<Sqinter> Y) x = (\\<Sqinter>g\\<in>Y. d_OUT g x)", "show ?OUT"], ["proof (prove)\nusing this:\n  d_OUT (\\<Sqinter> Y) x = (\\<Sqinter>g\\<in>Y. d_OUT g x)\n\ngoal (1 subgoal):\n 1. d_OUT (\\<Sqinter> Y) x = (\\<Sqinter>g\\<in>Y. d_OUT g x)", "."], ["proof (state)\nthis:\n  d_OUT (\\<Sqinter> Y) x = (\\<Sqinter>g\\<in>Y. d_OUT g x)\n\ngoal (1 subgoal):\n 1. d_IN f x \\<noteq> \\<top> \\<Longrightarrow>\n    d_IN (\\<Sqinter> Y) x = (\\<Sqinter>g\\<in>Y. d_IN g x)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. d_IN f x \\<noteq> \\<top> \\<Longrightarrow>\n    d_IN (\\<Sqinter> Y) x = (\\<Sqinter>g\\<in>Y. d_IN g x)", "assume finite: \"d_IN f x \\<noteq> top\""], ["proof (state)\nthis:\n  d_IN f x \\<noteq> \\<top>\n\ngoal (1 subgoal):\n 1. d_IN f x \\<noteq> \\<top> \\<Longrightarrow>\n    d_IN (\\<Sqinter> Y) x = (\\<Sqinter>g\\<in>Y. d_IN g x)", "have finite' [simp]: \"f (y, x) \\<noteq> \\<top>\" for y"], ["proof (prove)\ngoal (1 subgoal):\n 1. f (y, x) \\<noteq> \\<top>", "using finite"], ["proof (prove)\nusing this:\n  d_IN f x \\<noteq> \\<top>\n\ngoal (1 subgoal):\n 1. f (y, x) \\<noteq> \\<top>", "by(rule neq_top_trans) (rule d_IN_ge_point)"], ["proof (state)\nthis:\n  f (?y, x) \\<noteq> \\<top>\n\ngoal (1 subgoal):\n 1. d_IN f x \\<noteq> \\<top> \\<Longrightarrow>\n    d_IN (\\<Sqinter> Y) x = (\\<Sqinter>g\\<in>Y. d_IN g x)", "have finite'_g: \"g (y, x) \\<noteq> \\<top>\" if \"g \\<in> Y\" for g y"], ["proof (prove)\ngoal (1 subgoal):\n 1. g (y, x) \\<noteq> \\<top>", "using finite'[of y]"], ["proof (prove)\nusing this:\n  f (y, x) \\<noteq> \\<top>\n\ngoal (1 subgoal):\n 1. g (y, x) \\<noteq> \\<top>", "by(rule neq_top_trans)(rule bounded[OF that])"], ["proof (state)\nthis:\n  ?g \\<in> Y \\<Longrightarrow> ?g (?y, x) \\<noteq> \\<top>\n\ngoal (1 subgoal):\n 1. d_IN f x \\<noteq> \\<top> \\<Longrightarrow>\n    d_IN (\\<Sqinter> Y) x = (\\<Sqinter>g\\<in>Y. d_IN g x)", "have finite1: \"(\\<Sum>\\<^sup>+ y. f (y, x) - (INF g\\<in>Y. g (y, x))) \\<noteq> top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y. f (y, x) - (\\<Sqinter>g\\<in>Y. g (y, x))) \\<noteq>\n    \\<top>", "using finite"], ["proof (prove)\nusing this:\n  d_IN f x \\<noteq> \\<top>\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y. f (y, x) - (\\<Sqinter>g\\<in>Y. g (y, x))) \\<noteq>\n    \\<top>", "by(rule neq_top_trans)(auto simp add: d_IN_def diff_le_self_ennreal intro!: nn_integral_mono)"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y. f (y, x) - (\\<Sqinter>g\\<in>Y. g (y, x))) \\<noteq>\n  \\<top>\n\ngoal (1 subgoal):\n 1. d_IN f x \\<noteq> \\<top> \\<Longrightarrow>\n    d_IN (\\<Sqinter> Y) x = (\\<Sqinter>g\\<in>Y. d_IN g x)", "have finite2: \"d_IN g x \\<noteq> top\" if \"g \\<in> Y\" for g"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN g x \\<noteq> \\<top>", "using finite"], ["proof (prove)\nusing this:\n  d_IN f x \\<noteq> \\<top>\n\ngoal (1 subgoal):\n 1. d_IN g x \\<noteq> \\<top>", "by(rule neq_top_trans)(auto intro: d_IN_mono bounded[OF that])"], ["proof (state)\nthis:\n  ?g \\<in> Y \\<Longrightarrow> d_IN ?g x \\<noteq> \\<top>\n\ngoal (1 subgoal):\n 1. d_IN f x \\<noteq> \\<top> \\<Longrightarrow>\n    d_IN (\\<Sqinter> Y) x = (\\<Sqinter>g\\<in>Y. d_IN g x)", "have bounded1: \"(\\<Sqinter>g\\<in>Y. d_IN g x) \\<le> d_IN f x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sqinter>g\\<in>Y. d_IN g x) \\<le> d_IN f x", "using Y"], ["proof (prove)\nusing this:\n  Y \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<Sqinter>g\\<in>Y. d_IN g x) \\<le> d_IN f x", "by (blast intro: INF_lower2 d_IN_mono bounded)"], ["proof (state)\nthis:\n  (\\<Sqinter>g\\<in>Y. d_IN g x) \\<le> d_IN f x\n\ngoal (1 subgoal):\n 1. d_IN f x \\<noteq> \\<top> \\<Longrightarrow>\n    d_IN (\\<Sqinter> Y) x = (\\<Sqinter>g\\<in>Y. d_IN g x)", "have \"?lhs2 = (\\<Sum>\\<^sup>+ y. INF g\\<in>Y. g (y, x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN (\\<Sqinter> Y) x = (\\<Sum>\\<^sup>+ y. \\<Sqinter>g\\<in>Y. g (y, x))", "by(simp add: d_IN_def)"], ["proof (state)\nthis:\n  d_IN (\\<Sqinter> Y) x = (\\<Sum>\\<^sup>+ y. \\<Sqinter>g\\<in>Y. g (y, x))\n\ngoal (1 subgoal):\n 1. d_IN f x \\<noteq> \\<top> \\<Longrightarrow>\n    d_IN (\\<Sqinter> Y) x = (\\<Sqinter>g\\<in>Y. d_IN g x)", "also"], ["proof (state)\nthis:\n  d_IN (\\<Sqinter> Y) x = (\\<Sum>\\<^sup>+ y. \\<Sqinter>g\\<in>Y. g (y, x))\n\ngoal (1 subgoal):\n 1. d_IN f x \\<noteq> \\<top> \\<Longrightarrow>\n    d_IN (\\<Sqinter> Y) x = (\\<Sqinter>g\\<in>Y. d_IN g x)", "have \"\\<dots> = d_IN f x - (\\<Sum>\\<^sup>+ y. f (y, x) - (INF g\\<in>Y. g (y, x)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y. \\<Sqinter>g\\<in>Y. g (y, x)) =\n    d_IN f x - (\\<Sum>\\<^sup>+ y. f (y, x) - (\\<Sqinter>g\\<in>Y. g (y, x)))", "unfolding d_IN_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y. \\<Sqinter>g\\<in>Y. g (y, x)) =\n    (\\<Sum>\\<^sup>+ xa. f (xa, x)) -\n    (\\<Sum>\\<^sup>+ y. f (y, x) - (\\<Sqinter>g\\<in>Y. g (y, x)))", "using finite1 g0_le_f"], ["proof (prove)\nusing this:\n  (\\<Sum>\\<^sup>+ y. f (y, x) - (\\<Sqinter>g\\<in>Y. g (y, x))) \\<noteq>\n  \\<top>\n  g0 ?e \\<le> f ?e\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y. \\<Sqinter>g\\<in>Y. g (y, x)) =\n    (\\<Sum>\\<^sup>+ xa. f (xa, x)) -\n    (\\<Sum>\\<^sup>+ y. f (y, x) - (\\<Sqinter>g\\<in>Y. g (y, x)))", "apply(subst nn_integral_diff[symmetric])"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>(\\<Sum>\\<^sup>+ y.\n                f (y, x) - (\\<Sqinter>g\\<in>Y. g (y, x))) \\<noteq>\n             \\<top>;\n     \\<And>e. g0 e \\<le> f e\\<rbrakk>\n    \\<Longrightarrow> (\\<lambda>xa. f (xa, x))\n                      \\<in> borel_measurable (count_space UNIV)\n 2. \\<lbrakk>(\\<Sum>\\<^sup>+ y.\n                f (y, x) - (\\<Sqinter>g\\<in>Y. g (y, x))) \\<noteq>\n             \\<top>;\n     \\<And>e. g0 e \\<le> f e\\<rbrakk>\n    \\<Longrightarrow> (\\<lambda>y. f (y, x) - (\\<Sqinter>g\\<in>Y. g (y, x)))\n                      \\<in> borel_measurable (count_space UNIV)\n 3. \\<lbrakk>(\\<Sum>\\<^sup>+ y.\n                f (y, x) - (\\<Sqinter>g\\<in>Y. g (y, x))) \\<noteq>\n             \\<top>;\n     \\<And>e. g0 e \\<le> f e\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>\\<^sup>+ y.\n                         f (y, x) - (\\<Sqinter>g\\<in>Y. g (y, x))) \\<noteq>\n                      \\<infinity>\n 4. \\<lbrakk>(\\<Sum>\\<^sup>+ y.\n                f (y, x) - (\\<Sqinter>g\\<in>Y. g (y, x))) \\<noteq>\n             \\<top>;\n     \\<And>e. g0 e \\<le> f e\\<rbrakk>\n    \\<Longrightarrow> AE xa in count_space\n                                UNIV. f (xa, x) -\n(\\<Sqinter>g\\<in>Y. g (xa, x))\n\\<le> f (xa, x)\n 5. \\<lbrakk>(\\<Sum>\\<^sup>+ y.\n                f (y, x) - (\\<Sqinter>g\\<in>Y. g (y, x))) \\<noteq>\n             \\<top>;\n     \\<And>e. g0 e \\<le> f e\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>\\<^sup>+ y. \\<Sqinter>g\\<in>Y. g (y, x)) =\n                      (\\<Sum>\\<^sup>+ xa.\n                         f (xa, x) -\n                         (f (xa, x) - (\\<Sqinter>g\\<in>Y. g (xa, x))))", "apply(auto simp add: AE_count_space intro!: diff_le_self_ennreal INF_lower2[OF g0] nn_integral_cong diff_diff_ennreal[symmetric])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y. \\<Sqinter>g\\<in>Y. g (y, x)) =\n  d_IN f x - (\\<Sum>\\<^sup>+ y. f (y, x) - (\\<Sqinter>g\\<in>Y. g (y, x)))\n\ngoal (1 subgoal):\n 1. d_IN f x \\<noteq> \\<top> \\<Longrightarrow>\n    d_IN (\\<Sqinter> Y) x = (\\<Sqinter>g\\<in>Y. d_IN g x)", "also"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y. \\<Sqinter>g\\<in>Y. g (y, x)) =\n  d_IN f x - (\\<Sum>\\<^sup>+ y. f (y, x) - (\\<Sqinter>g\\<in>Y. g (y, x)))\n\ngoal (1 subgoal):\n 1. d_IN f x \\<noteq> \\<top> \\<Longrightarrow>\n    d_IN (\\<Sqinter> Y) x = (\\<Sqinter>g\\<in>Y. d_IN g x)", "have \"(\\<Sum>\\<^sup>+ y. f (y, x) - (INF g\\<in>Y. g (y, x))) = d_IN (\\<lambda>e. SUP g\\<in>Y. f e - g e) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y. f (y, x) - (\\<Sqinter>g\\<in>Y. g (y, x))) =\n    d_IN (\\<lambda>e. \\<Squnion>g\\<in>Y. f e - g e) x", "unfolding d_IN_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y. f (y, x) - (\\<Sqinter>g\\<in>Y. g (y, x))) =\n    (\\<Sum>\\<^sup>+ xa. \\<Squnion>g\\<in>Y. f (xa, x) - g (xa, x))", "by(subst SUP_const_minus_ennreal)(simp_all add: Y)"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y. f (y, x) - (\\<Sqinter>g\\<in>Y. g (y, x))) =\n  d_IN (\\<lambda>e. \\<Squnion>g\\<in>Y. f e - g e) x\n\ngoal (1 subgoal):\n 1. d_IN f x \\<noteq> \\<top> \\<Longrightarrow>\n    d_IN (\\<Sqinter> Y) x = (\\<Sqinter>g\\<in>Y. d_IN g x)", "also"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y. f (y, x) - (\\<Sqinter>g\\<in>Y. g (y, x))) =\n  d_IN (\\<lambda>e. \\<Squnion>g\\<in>Y. f e - g e) x\n\ngoal (1 subgoal):\n 1. d_IN f x \\<noteq> \\<top> \\<Longrightarrow>\n    d_IN (\\<Sqinter> Y) x = (\\<Sqinter>g\\<in>Y. d_IN g x)", "have \"\\<dots> = (SUP h\\<in>(\\<lambda>g e. f e - g e) ` Y. d_IN h x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN (\\<lambda>e. \\<Squnion>g\\<in>Y. f e - g e) x =\n    (\\<Squnion>h\\<in>(\\<lambda>g e. f e - g e) ` Y. d_IN h x)", "using countable' chain' Y"], ["proof (prove)\nusing this:\n  countable (support_flow (\\<Squnion>g\\<in>Y. (\\<lambda>e. f e - g e)))\n  Complete_Partial_Order.chain (\\<le>) ((\\<lambda>g e. f e - g e) ` Y)\n  Y \\<noteq> {}\n\ngoal (1 subgoal):\n 1. d_IN (\\<lambda>e. \\<Squnion>g\\<in>Y. f e - g e) x =\n    (\\<Squnion>h\\<in>(\\<lambda>g e. f e - g e) ` Y. d_IN h x)", "by(subst d_IN_Sup[symmetric])(simp_all add: SUP_apply[abs_def])"], ["proof (state)\nthis:\n  d_IN (\\<lambda>e. \\<Squnion>g\\<in>Y. f e - g e) x =\n  (\\<Squnion>h\\<in>(\\<lambda>g e. f e - g e) ` Y. d_IN h x)\n\ngoal (1 subgoal):\n 1. d_IN f x \\<noteq> \\<top> \\<Longrightarrow>\n    d_IN (\\<Sqinter> Y) x = (\\<Sqinter>g\\<in>Y. d_IN g x)", "also"], ["proof (state)\nthis:\n  d_IN (\\<lambda>e. \\<Squnion>g\\<in>Y. f e - g e) x =\n  (\\<Squnion>h\\<in>(\\<lambda>g e. f e - g e) ` Y. d_IN h x)\n\ngoal (1 subgoal):\n 1. d_IN f x \\<noteq> \\<top> \\<Longrightarrow>\n    d_IN (\\<Sqinter> Y) x = (\\<Sqinter>g\\<in>Y. d_IN g x)", "have \"\\<dots> = (SUP g\\<in>Y. d_IN (\\<lambda>e. f e - g e) x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Squnion>h\\<in>(\\<lambda>g e. f e - g e) ` Y. d_IN h x) =\n    (\\<Squnion>g\\<in>Y. d_IN (\\<lambda>e. f e - g e) x)", "unfolding image_image"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Squnion>xa\\<in>Y. d_IN (\\<lambda>e. f e - xa e) x) =\n    (\\<Squnion>g\\<in>Y. d_IN (\\<lambda>e. f e - g e) x)", ".."], ["proof (state)\nthis:\n  (\\<Squnion>h\\<in>(\\<lambda>g e. f e - g e) ` Y. d_IN h x) =\n  (\\<Squnion>g\\<in>Y. d_IN (\\<lambda>e. f e - g e) x)\n\ngoal (1 subgoal):\n 1. d_IN f x \\<noteq> \\<top> \\<Longrightarrow>\n    d_IN (\\<Sqinter> Y) x = (\\<Sqinter>g\\<in>Y. d_IN g x)", "also"], ["proof (state)\nthis:\n  (\\<Squnion>h\\<in>(\\<lambda>g e. f e - g e) ` Y. d_IN h x) =\n  (\\<Squnion>g\\<in>Y. d_IN (\\<lambda>e. f e - g e) x)\n\ngoal (1 subgoal):\n 1. d_IN f x \\<noteq> \\<top> \\<Longrightarrow>\n    d_IN (\\<Sqinter> Y) x = (\\<Sqinter>g\\<in>Y. d_IN g x)", "have \"\\<dots> = (SUP g\\<in>Y. d_IN f x - d_IN g x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Squnion>g\\<in>Y. d_IN (\\<lambda>e. f e - g e) x) =\n    (\\<Squnion>g\\<in>Y. d_IN f x - d_IN g x)", "by(rule SUP_cong[OF refl] d_IN_diff)+(auto intro: bounded simp add: finite2)"], ["proof (state)\nthis:\n  (\\<Squnion>g\\<in>Y. d_IN (\\<lambda>e. f e - g e) x) =\n  (\\<Squnion>g\\<in>Y. d_IN f x - d_IN g x)\n\ngoal (1 subgoal):\n 1. d_IN f x \\<noteq> \\<top> \\<Longrightarrow>\n    d_IN (\\<Sqinter> Y) x = (\\<Sqinter>g\\<in>Y. d_IN g x)", "also"], ["proof (state)\nthis:\n  (\\<Squnion>g\\<in>Y. d_IN (\\<lambda>e. f e - g e) x) =\n  (\\<Squnion>g\\<in>Y. d_IN f x - d_IN g x)\n\ngoal (1 subgoal):\n 1. d_IN f x \\<noteq> \\<top> \\<Longrightarrow>\n    d_IN (\\<Sqinter> Y) x = (\\<Sqinter>g\\<in>Y. d_IN g x)", "have \"\\<dots> = d_IN f x - ?rhs2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Squnion>g\\<in>Y. d_IN f x - d_IN g x) =\n    d_IN f x - (\\<Sqinter>g\\<in>Y. d_IN g x)", "by(subst SUP_const_minus_ennreal)(simp_all add: Y)"], ["proof (state)\nthis:\n  (\\<Squnion>g\\<in>Y. d_IN f x - d_IN g x) =\n  d_IN f x - (\\<Sqinter>g\\<in>Y. d_IN g x)\n\ngoal (1 subgoal):\n 1. d_IN f x \\<noteq> \\<top> \\<Longrightarrow>\n    d_IN (\\<Sqinter> Y) x = (\\<Sqinter>g\\<in>Y. d_IN g x)", "also"], ["proof (state)\nthis:\n  (\\<Squnion>g\\<in>Y. d_IN f x - d_IN g x) =\n  d_IN f x - (\\<Sqinter>g\\<in>Y. d_IN g x)\n\ngoal (1 subgoal):\n 1. d_IN f x \\<noteq> \\<top> \\<Longrightarrow>\n    d_IN (\\<Sqinter> Y) x = (\\<Sqinter>g\\<in>Y. d_IN g x)", "have \"d_IN f x - \\<dots> = ?rhs2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN f x - (d_IN f x - (\\<Sqinter>g\\<in>Y. d_IN g x)) =\n    (\\<Sqinter>g\\<in>Y. d_IN g x)", "by(subst diff_diff_ennreal)(simp_all add: finite bounded1)"], ["proof (state)\nthis:\n  d_IN f x - (d_IN f x - (\\<Sqinter>g\\<in>Y. d_IN g x)) =\n  (\\<Sqinter>g\\<in>Y. d_IN g x)\n\ngoal (1 subgoal):\n 1. d_IN f x \\<noteq> \\<top> \\<Longrightarrow>\n    d_IN (\\<Sqinter> Y) x = (\\<Sqinter>g\\<in>Y. d_IN g x)", "finally"], ["proof (chain)\npicking this:\n  d_IN (\\<Sqinter> Y) x = (\\<Sqinter>g\\<in>Y. d_IN g x)", "show ?IN"], ["proof (prove)\nusing this:\n  d_IN (\\<Sqinter> Y) x = (\\<Sqinter>g\\<in>Y. d_IN g x)\n\ngoal (1 subgoal):\n 1. d_IN (\\<Sqinter> Y) x = (\\<Sqinter>g\\<in>Y. d_IN g x)", "."], ["proof (state)\nthis:\n  d_IN (\\<Sqinter> Y) x = (\\<Sqinter>g\\<in>Y. d_IN g x)\n\ngoal:\nNo subgoals!", "}"], ["proof (state)\nthis:\n  d_IN f x \\<noteq> \\<top> \\<Longrightarrow>\n  d_IN (\\<Sqinter> Y) x = (\\<Sqinter>g\\<in>Y. d_IN g x)\n\ngoal:\nNo subgoals!", "qed"], ["", "inductive flow :: \"('v, 'more) network_scheme \\<Rightarrow> 'v flow \\<Rightarrow> bool\"\n  for \\<Delta> (structure) and f\nwhere\n  flow: \"\\<lbrakk> \\<And>e. f e \\<le> capacity \\<Delta> e;\n     \\<And>x. \\<lbrakk> x \\<noteq> source \\<Delta>; x \\<noteq> sink \\<Delta> \\<rbrakk> \\<Longrightarrow> KIR f x \\<rbrakk>\n  \\<Longrightarrow> flow \\<Delta> f\""], ["", "lemma flowD_capacity: \"flow \\<Delta> f \\<Longrightarrow> f e \\<le> capacity \\<Delta> e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. flow \\<Delta> f \\<Longrightarrow> f e \\<le> capacity \\<Delta> e", "by(cases e)(simp add: flow.simps)"], ["", "lemma flowD_KIR: \"\\<lbrakk> flow \\<Delta> f; x \\<noteq> source \\<Delta>; x \\<noteq> sink \\<Delta> \\<rbrakk> \\<Longrightarrow> KIR f x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>flow \\<Delta> f; x \\<noteq> source \\<Delta>;\n     x \\<noteq> sink \\<Delta>\\<rbrakk>\n    \\<Longrightarrow> KIR f x", "by(simp add: flow.simps)"], ["", "lemma flowD_capacity_OUT: \"flow \\<Delta> f \\<Longrightarrow> d_OUT f x \\<le> d_OUT (capacity \\<Delta>) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. flow \\<Delta> f \\<Longrightarrow>\n    d_OUT f x \\<le> d_OUT (capacity \\<Delta>) x", "by(rule d_OUT_mono)(erule flowD_capacity)"], ["", "lemma flowD_capacity_IN: \"flow \\<Delta> f \\<Longrightarrow> d_IN f x \\<le> d_IN (capacity \\<Delta>) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. flow \\<Delta> f \\<Longrightarrow>\n    d_IN f x \\<le> d_IN (capacity \\<Delta>) x", "by(rule d_IN_mono)(erule flowD_capacity)"], ["", "abbreviation value_flow :: \"('v, 'more) network_scheme \\<Rightarrow> ('v edge \\<Rightarrow> ennreal) \\<Rightarrow> ennreal\"\nwhere \"value_flow \\<Delta> f \\<equiv> d_OUT f (source \\<Delta>)\""], ["", "subsection \\<open>Cut\\<close>"], ["", "type_synonym 'v cut = \"'v set\""], ["", "inductive cut :: \"('v, 'more) network_scheme \\<Rightarrow> 'v cut \\<Rightarrow> bool\"\n  for \\<Delta> and S\nwhere cut: \"\\<lbrakk> source \\<Delta> \\<in> S; sink \\<Delta> \\<notin> S \\<rbrakk> \\<Longrightarrow> cut \\<Delta> S\""], ["", "inductive orthogonal :: \"('v, 'more) network_scheme \\<Rightarrow> 'v flow \\<Rightarrow> 'v cut \\<Rightarrow> bool\"\n  for \\<Delta> f S\nwhere\n  \"\\<lbrakk> \\<And>x y. \\<lbrakk> edge \\<Delta> x y; x \\<in> S; y \\<notin> S \\<rbrakk> \\<Longrightarrow> f (x, y) = capacity \\<Delta> (x, y);\n     \\<And>x y. \\<lbrakk> edge \\<Delta> x y; x \\<notin> S; y \\<in> S \\<rbrakk> \\<Longrightarrow> f (x, y) = 0 \\<rbrakk>\n  \\<Longrightarrow> orthogonal \\<Delta> f S\""], ["", "lemma orthogonalD_out:\n  \"\\<lbrakk> orthogonal \\<Delta> f S; edge \\<Delta> x y; x \\<in> S; y \\<notin> S \\<rbrakk> \\<Longrightarrow> f (x, y) = capacity \\<Delta> (x, y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>orthogonal \\<Delta> f S; edge \\<Delta> x y; x \\<in> S;\n     y \\<notin> S\\<rbrakk>\n    \\<Longrightarrow> f (x, y) = capacity \\<Delta> (x, y)", "by(simp add: orthogonal.simps)"], ["", "lemma orthogonalD_in:\n  \"\\<lbrakk> orthogonal \\<Delta> f S; edge \\<Delta> x y; x \\<notin> S; y \\<in> S \\<rbrakk> \\<Longrightarrow> f (x, y) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>orthogonal \\<Delta> f S; edge \\<Delta> x y; x \\<notin> S;\n     y \\<in> S\\<rbrakk>\n    \\<Longrightarrow> f (x, y) = 0", "by(simp add: orthogonal.simps)"], ["", "subsection \\<open>Countable network\\<close>"], ["", "locale countable_network =\n  fixes \\<Delta> :: \"('v, 'more) network_scheme\" (structure)\n  assumes countable_E [simp]: \"countable \\<^bold>E\"\n  and source_neq_sink [simp]: \"source \\<Delta> \\<noteq> sink \\<Delta>\"\n  and capacity_outside: \"e \\<notin> \\<^bold>E \\<Longrightarrow> capacity \\<Delta> e = 0\"\n  and capacity_finite [simp]: \"capacity \\<Delta> e \\<noteq> \\<top>\"\nbegin"], ["", "lemma sink_neq_source [simp]: \"sink \\<Delta> \\<noteq> source \\<Delta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sink \\<Delta> \\<noteq> source \\<Delta>", "using source_neq_sink[symmetric]"], ["proof (prove)\nusing this:\n  sink \\<Delta> \\<noteq> source \\<Delta>\n\ngoal (1 subgoal):\n 1. sink \\<Delta> \\<noteq> source \\<Delta>", "."], ["", "lemma countable_V [simp]: \"countable \\<^bold>V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. countable \\<^bold>V", "unfolding \"\\<^bold>V_def\""], ["proof (prove)\ngoal (1 subgoal):\n 1. countable (fst ` \\<^bold>E \\<union> snd ` \\<^bold>E)", "using countable_E"], ["proof (prove)\nusing this:\n  countable \\<^bold>E\n\ngoal (1 subgoal):\n 1. countable (fst ` \\<^bold>E \\<union> snd ` \\<^bold>E)", "by auto"], ["", "lemma flowD_outside:\n  assumes g: \"flow \\<Delta> g\"\n  shows \"e \\<notin> \\<^bold>E \\<Longrightarrow> g e = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. e \\<notin> \\<^bold>E \\<Longrightarrow> g e = 0", "using flowD_capacity[OF g, of e] capacity_outside[of e]"], ["proof (prove)\nusing this:\n  g e \\<le> capacity \\<Delta> e\n  e \\<notin> \\<^bold>E \\<Longrightarrow> capacity \\<Delta> e = 0\n\ngoal (1 subgoal):\n 1. e \\<notin> \\<^bold>E \\<Longrightarrow> g e = 0", "by simp"], ["", "lemma flowD_finite:\n  assumes \"flow \\<Delta> g\"\n  shows \"g e \\<noteq> \\<top>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g e \\<noteq> \\<top>", "using flowD_capacity[OF assms, of e]"], ["proof (prove)\nusing this:\n  g e \\<le> capacity \\<Delta> e\n\ngoal (1 subgoal):\n 1. g e \\<noteq> \\<top>", "by (auto simp: top_unique)"], ["", "lemma zero_flow [simp]: \"flow \\<Delta> (\\<lambda>_. 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. flow \\<Delta> (\\<lambda>_. 0)", "by(rule flow.intros) simp_all"], ["", "end"], ["", "subsection \\<open>Reduction for avoiding antiparallel edges\\<close>"], ["", "locale antiparallel_edges = countable_network \\<Delta>\n  for \\<Delta> :: \"('v, 'more) network_scheme\" (structure)\nbegin"], ["", "text \\<open>We eliminate the assumption of antiparallel edges by adding a vertex for every edge.\n  Thus, antiparallel edges are split up into a cycle of 4 edges. This idea already appears in\n  @{cite Aharoni1983EJC}.\\<close>"], ["", "datatype (plugins del: transfer size) 'v' vertex = Vertex 'v' | Edge 'v' 'v'"], ["", "inductive edg :: \"'v vertex \\<Rightarrow> 'v vertex \\<Rightarrow> bool\"\nwhere\n  OUT: \"edge \\<Delta> x y \\<Longrightarrow> edg (Vertex x) (Edge x y)\"\n| IN: \"edge \\<Delta> x y \\<Longrightarrow> edg (Edge x y) (Vertex y)\""], ["", "inductive_simps edg_simps [simp]:\n  \"edg (Vertex x) v\"\n  \"edg (Edge x y) v\"\n  \"edg v (Vertex x)\"\n  \"edg v (Edge x y)\""], ["", "fun split :: \"'v flow \\<Rightarrow> 'v vertex flow\"\nwhere\n  \"split f (Vertex x, Edge x' y) = (if x' = x then f (x, y) else 0)\"\n| \"split f (Edge x y', Vertex y) = (if y' = y then f (x, y) else 0)\"\n| \"split f _ = 0\""], ["", "lemma split_Vertex1_eq_0I: \"(\\<And>z. y \\<noteq> Edge x z) \\<Longrightarrow> split f (Vertex x, y) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>z. y \\<noteq> Edge x z) \\<Longrightarrow>\n    split f (Vertex x, y) = 0", "by(cases y) auto"], ["", "lemma split_Vertex2_eq_0I: \"(\\<And>z. y \\<noteq> Edge z x) \\<Longrightarrow> split f (y, Vertex x) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>z. y \\<noteq> Edge z x) \\<Longrightarrow>\n    split f (y, Vertex x) = 0", "by(cases y) simp_all"], ["", "lemma split_Edge1_eq_0I: \"(\\<And>z. y \\<noteq> Vertex x) \\<Longrightarrow> split f (Edge z x, y) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>z. y \\<noteq> Vertex x) \\<Longrightarrow>\n    split f (Edge z x, y) = 0", "by(cases y) simp_all"], ["", "lemma split_Edge2_eq_0I: \"(\\<And>z. y \\<noteq> Vertex x) \\<Longrightarrow> split f (y, Edge x z) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>z. y \\<noteq> Vertex x) \\<Longrightarrow>\n    split f (y, Edge x z) = 0", "by(cases y) simp_all"], ["", "definition \\<Delta>'' :: \"'v vertex network\"\nwhere \"\\<Delta>'' = \\<lparr>edge = edg, capacity = split (capacity \\<Delta>), source = Vertex (source \\<Delta>), sink = Vertex (sink \\<Delta>)\\<rparr>\""], ["", "lemma \\<Delta>''_sel [simp]:\n  \"edge \\<Delta>'' = edg\"\n  \"capacity \\<Delta>'' = split (capacity \\<Delta>)\"\n  \"source \\<Delta>'' = Vertex (source \\<Delta>)\"\n  \"sink \\<Delta>'' = Vertex (sink \\<Delta>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (edge \\<Delta>'' = edg &&&\n     capacity \\<Delta>'' = split (capacity \\<Delta>)) &&&\n    source \\<Delta>'' = Vertex (source \\<Delta>) &&&\n    sink \\<Delta>'' = Vertex (sink \\<Delta>)", "by(simp_all add: \\<Delta>''_def)"], ["", "lemma \"\\<^bold>E_\\<Delta>''\": \"\\<^bold>E\\<^bsub>\\<Delta>''\\<^esub> = (\\<lambda>(x, y). (Vertex x, Edge x y)) ` \\<^bold>E \\<union> (\\<lambda>(x, y). (Edge x y, Vertex y)) ` \\<^bold>E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<^bold>E\\<^bsub>\\<Delta>''\\<^esub> =\n    (\\<lambda>(x, y). (Vertex x, Edge x y)) ` \\<^bold>E \\<union>\n    (\\<lambda>(x, y). (Edge x y, Vertex y)) ` \\<^bold>E", "by(auto elim: edg.cases)"], ["", "lemma \"\\<^bold>V_\\<Delta>''\": \"\\<^bold>V\\<^bsub>\\<Delta>''\\<^esub> = Vertex ` \\<^bold>V \\<union> case_prod Edge ` \\<^bold>E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<^bold>V\\<^bsub>\\<Delta>''\\<^esub> =\n    Vertex ` \\<^bold>V \\<union> (\\<lambda>(x, y). Edge x y) ` \\<^bold>E", "by(auto 4 4 simp add: vertex_def elim!: edg.cases)"], ["", "lemma inj_on_Edge1 [simp]: \"inj_on (\\<lambda>x. Edge x y) A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on (\\<lambda>x. Edge x y) A", "by(simp add: inj_on_def)"], ["", "lemma inj_on_Edge2 [simp]: \"inj_on (Edge x) A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on (Edge x) A", "by(simp add: inj_on_def)"], ["", "lemma d_IN_split_Vertex [simp]: \"d_IN (split f) (Vertex x) = d_IN f x\" (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN (split f) (Vertex x) = d_IN f x", "proof(rule trans)"], ["proof (state)\ngoal (2 subgoals):\n 1. d_IN (split f) (Vertex x) = ?s\n 2. ?s = d_IN f x", "show \"?lhs = (\\<Sum>\\<^sup>+ v'\\<in>range (\\<lambda>y. Edge y x). split f (v', Vertex x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN (split f) (Vertex x) =\n    (\\<Sum>\\<^sup>+ v'\\<in>range (\\<lambda>y. Edge y x).\n       split f (v', Vertex x))", "by(auto intro!: nn_integral_cong split_Vertex2_eq_0I simp add: d_IN_def nn_integral_count_space_indicator split: split_indicator)"], ["proof (state)\nthis:\n  d_IN (split f) (Vertex x) =\n  (\\<Sum>\\<^sup>+ v'\\<in>range (\\<lambda>y. Edge y x).\n     split f (v', Vertex x))\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ v'\\<in>range (\\<lambda>y. Edge y x).\n       split f (v', Vertex x)) =\n    d_IN f x", "show \"\\<dots> = ?rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ v'\\<in>range (\\<lambda>y. Edge y x).\n       split f (v', Vertex x)) =\n    d_IN f x", "by(simp add: nn_integral_count_space_reindex d_IN_def)"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ v'\\<in>range (\\<lambda>y. Edge y x).\n     split f (v', Vertex x)) =\n  d_IN f x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma d_OUT_split_Vertex [simp]: \"d_OUT (split f) (Vertex x) = d_OUT f x\" (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT (split f) (Vertex x) = d_OUT f x", "proof(rule trans)"], ["proof (state)\ngoal (2 subgoals):\n 1. d_OUT (split f) (Vertex x) = ?s\n 2. ?s = d_OUT f x", "show \"?lhs = (\\<Sum>\\<^sup>+ v'\\<in>range (Edge x). split f (Vertex x, v'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT (split f) (Vertex x) =\n    (\\<Sum>\\<^sup>+ v'\\<in>range (Edge x). split f (Vertex x, v'))", "by(auto intro!: nn_integral_cong split_Vertex1_eq_0I simp add: d_OUT_def nn_integral_count_space_indicator split: split_indicator)"], ["proof (state)\nthis:\n  d_OUT (split f) (Vertex x) =\n  (\\<Sum>\\<^sup>+ v'\\<in>range (Edge x). split f (Vertex x, v'))\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ v'\\<in>range (Edge x). split f (Vertex x, v')) =\n    d_OUT f x", "show \"\\<dots> = ?rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ v'\\<in>range (Edge x). split f (Vertex x, v')) =\n    d_OUT f x", "by(simp add: nn_integral_count_space_reindex d_OUT_def)"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ v'\\<in>range (Edge x). split f (Vertex x, v')) = d_OUT f x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma d_IN_split_Edge [simp]: \"d_IN (split f) (Edge x y) = max 0 (f (x, y))\" (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN (split f) (Edge x y) = max 0 (f (x, y))", "proof(rule trans)"], ["proof (state)\ngoal (2 subgoals):\n 1. d_IN (split f) (Edge x y) = ?s\n 2. ?s = max 0 (f (x, y))", "show \"?lhs = (\\<Sum>\\<^sup>+ v'. split f (v', Edge x y) * indicator {Vertex x} v')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN (split f) (Edge x y) =\n    \\<integral>\\<^sup>+v'\\<in>{Vertex x}. split f (v', Edge x y)\n    \\<partial>count_space UNIV", "unfolding d_IN_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ xa. split f (xa, Edge x y)) =\n    \\<integral>\\<^sup>+v'\\<in>{Vertex x}. split f (v', Edge x y)\n    \\<partial>count_space UNIV", "by(rule nn_integral_cong)(simp add: split_Edge2_eq_0I split: split_indicator)"], ["proof (state)\nthis:\n  d_IN (split f) (Edge x y) =\n  \\<integral>\\<^sup>+v'\\<in>{Vertex x}. split f (v', Edge x y)\n  \\<partial>count_space UNIV\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+v'\\<in>{Vertex x}. split f (v', Edge x y)\n    \\<partial>count_space UNIV =\n    max 0 (f (x, y))", "show \"\\<dots> = ?rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+v'\\<in>{Vertex x}. split f (v', Edge x y)\n    \\<partial>count_space UNIV =\n    max 0 (f (x, y))", "by(simp add: max_def)"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+v'\\<in>{Vertex x}. split f (v', Edge x y)\n  \\<partial>count_space UNIV =\n  max 0 (f (x, y))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma d_OUT_split_Edge [simp]: \"d_OUT (split f) (Edge x y) = max 0 (f (x, y))\" (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT (split f) (Edge x y) = max 0 (f (x, y))", "proof(rule trans)"], ["proof (state)\ngoal (2 subgoals):\n 1. d_OUT (split f) (Edge x y) = ?s\n 2. ?s = max 0 (f (x, y))", "show \"?lhs = (\\<Sum>\\<^sup>+ v'. split f (Edge x y, v') * indicator {Vertex y} v')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT (split f) (Edge x y) =\n    \\<integral>\\<^sup>+v'\\<in>{Vertex y}. split f (Edge x y, v')\n    \\<partial>count_space UNIV", "unfolding d_OUT_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ ya. split f (Edge x y, ya)) =\n    \\<integral>\\<^sup>+v'\\<in>{Vertex y}. split f (Edge x y, v')\n    \\<partial>count_space UNIV", "by(rule nn_integral_cong)(simp add: split_Edge1_eq_0I split: split_indicator)"], ["proof (state)\nthis:\n  d_OUT (split f) (Edge x y) =\n  \\<integral>\\<^sup>+v'\\<in>{Vertex y}. split f (Edge x y, v')\n  \\<partial>count_space UNIV\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+v'\\<in>{Vertex y}. split f (Edge x y, v')\n    \\<partial>count_space UNIV =\n    max 0 (f (x, y))", "show \"\\<dots> = ?rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+v'\\<in>{Vertex y}. split f (Edge x y, v')\n    \\<partial>count_space UNIV =\n    max 0 (f (x, y))", "by(simp add: max_def)"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+v'\\<in>{Vertex y}. split f (Edge x y, v')\n  \\<partial>count_space UNIV =\n  max 0 (f (x, y))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma \\<Delta>''_countable_network: \"countable_network \\<Delta>''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. countable_network \\<Delta>''", "proof"], ["proof (state)\ngoal (4 subgoals):\n 1. countable \\<^bold>E\\<^bsub>\\<Delta>''\\<^esub>\n 2. source \\<Delta>'' \\<noteq> sink \\<Delta>''\n 3. \\<And>e.\n       e \\<notin> \\<^bold>E\\<^bsub>\\<Delta>''\\<^esub> \\<Longrightarrow>\n       capacity \\<Delta>'' e = 0\n 4. \\<And>e. capacity \\<Delta>'' e \\<noteq> \\<top>", "show \"countable \\<^bold>E\\<^bsub>\\<Delta>''\\<^esub>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. countable \\<^bold>E\\<^bsub>\\<Delta>''\\<^esub>", "unfolding \"\\<^bold>E_\\<Delta>''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. countable\n     ((\\<lambda>(x, y). (Vertex x, Edge x y)) ` \\<^bold>E \\<union>\n      (\\<lambda>(x, y). (Edge x y, Vertex y)) ` \\<^bold>E)", "by(simp)"], ["proof (state)\nthis:\n  countable \\<^bold>E\\<^bsub>\\<Delta>''\\<^esub>\n\ngoal (3 subgoals):\n 1. source \\<Delta>'' \\<noteq> sink \\<Delta>''\n 2. \\<And>e.\n       e \\<notin> \\<^bold>E\\<^bsub>\\<Delta>''\\<^esub> \\<Longrightarrow>\n       capacity \\<Delta>'' e = 0\n 3. \\<And>e. capacity \\<Delta>'' e \\<noteq> \\<top>", "show \"source \\<Delta>'' \\<noteq> sink \\<Delta>''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. source \\<Delta>'' \\<noteq> sink \\<Delta>''", "by auto"], ["proof (state)\nthis:\n  source \\<Delta>'' \\<noteq> sink \\<Delta>''\n\ngoal (2 subgoals):\n 1. \\<And>e.\n       e \\<notin> \\<^bold>E\\<^bsub>\\<Delta>''\\<^esub> \\<Longrightarrow>\n       capacity \\<Delta>'' e = 0\n 2. \\<And>e. capacity \\<Delta>'' e \\<noteq> \\<top>", "show \"capacity \\<Delta>'' e = 0\" if \"e \\<notin> \\<^bold>E\\<^bsub>\\<Delta>''\\<^esub>\" for e"], ["proof (prove)\ngoal (1 subgoal):\n 1. capacity \\<Delta>'' e = 0", "using that"], ["proof (prove)\nusing this:\n  e \\<notin> \\<^bold>E\\<^bsub>\\<Delta>''\\<^esub>\n\ngoal (1 subgoal):\n 1. capacity \\<Delta>'' e = 0", "by(cases \"(capacity \\<Delta>, e)\" rule: split.cases)(auto simp add: capacity_outside)"], ["proof (state)\nthis:\n  ?e \\<notin> \\<^bold>E\\<^bsub>\\<Delta>''\\<^esub> \\<Longrightarrow>\n  capacity \\<Delta>'' ?e = 0\n\ngoal (1 subgoal):\n 1. \\<And>e. capacity \\<Delta>'' e \\<noteq> \\<top>", "show \"capacity \\<Delta>'' e \\<noteq> top\" for e"], ["proof (prove)\ngoal (1 subgoal):\n 1. capacity \\<Delta>'' e \\<noteq> \\<top>", "by(cases \"(capacity \\<Delta>, e)\" rule: split.cases)(auto)"], ["proof (state)\nthis:\n  capacity \\<Delta>'' ?e \\<noteq> \\<top>\n\ngoal:\nNo subgoals!", "qed"], ["", "interpretation \\<Delta>'': countable_network \\<Delta>''"], ["proof (prove)\ngoal (1 subgoal):\n 1. countable_network \\<Delta>''", "by(rule \\<Delta>''_countable_network)"], ["", "lemma flow_split [simp]:\n  assumes \"flow \\<Delta> f\"\n  shows \"flow \\<Delta>'' (split f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. flow \\<Delta>'' (split f)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>e. split f e \\<le> capacity \\<Delta>'' e\n 2. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>'';\n        x \\<noteq> sink \\<Delta>''\\<rbrakk>\n       \\<Longrightarrow> KIR (split f) x", "show \"split f e \\<le> capacity \\<Delta>'' e\" for e"], ["proof (prove)\ngoal (1 subgoal):\n 1. split f e \\<le> capacity \\<Delta>'' e", "by(cases \"(f, e)\" rule: split.cases)(auto intro: flowD_capacity[OF assms] intro: SUP_upper2 assms)"], ["proof (state)\nthis:\n  split f ?e \\<le> capacity \\<Delta>'' ?e\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>'';\n        x \\<noteq> sink \\<Delta>''\\<rbrakk>\n       \\<Longrightarrow> KIR (split f) x", "show \"KIR (split f) x\" if \"x \\<noteq> source \\<Delta>''\" \"x \\<noteq> sink \\<Delta>''\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. KIR (split f) x", "using that"], ["proof (prove)\nusing this:\n  x \\<noteq> source \\<Delta>''\n  x \\<noteq> sink \\<Delta>''\n\ngoal (1 subgoal):\n 1. KIR (split f) x", "by(cases \"x\")(auto dest: flowD_KIR[OF assms])"], ["proof (state)\nthis:\n  \\<lbrakk>?x \\<noteq> source \\<Delta>'';\n   ?x \\<noteq> sink \\<Delta>''\\<rbrakk>\n  \\<Longrightarrow> KIR (split f) ?x\n\ngoal:\nNo subgoals!", "qed"], ["", "abbreviation (input) collect :: \"'v vertex flow \\<Rightarrow> 'v flow\"\nwhere \"collect f \\<equiv> (\\<lambda>(x, y). f (Edge x y, Vertex y))\""], ["", "lemma d_OUT_collect:\n  assumes f: \"flow \\<Delta>'' f\"\n  shows \"d_OUT (collect f) x = d_OUT f (Vertex x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT (\\<lambda>(x, y). f (Edge x y, Vertex y)) x = d_OUT f (Vertex x)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. d_OUT (\\<lambda>(x, y). f (Edge x y, Vertex y)) x = d_OUT f (Vertex x)", "have \"d_OUT (collect f) x = (\\<Sum>\\<^sup>+ y. f (Edge x y, Vertex y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT (\\<lambda>(x, y). f (Edge x y, Vertex y)) x =\n    (\\<Sum>\\<^sup>+ y. f (Edge x y, Vertex y))", "by(simp add: nn_integral_count_space_reindex d_OUT_def)"], ["proof (state)\nthis:\n  d_OUT (\\<lambda>(x, y). f (Edge x y, Vertex y)) x =\n  (\\<Sum>\\<^sup>+ y. f (Edge x y, Vertex y))\n\ngoal (1 subgoal):\n 1. d_OUT (\\<lambda>(x, y). f (Edge x y, Vertex y)) x = d_OUT f (Vertex x)", "also"], ["proof (state)\nthis:\n  d_OUT (\\<lambda>(x, y). f (Edge x y, Vertex y)) x =\n  (\\<Sum>\\<^sup>+ y. f (Edge x y, Vertex y))\n\ngoal (1 subgoal):\n 1. d_OUT (\\<lambda>(x, y). f (Edge x y, Vertex y)) x = d_OUT f (Vertex x)", "have \"\\<dots> = (\\<Sum>\\<^sup>+ y\\<in>range (Edge x). f (Vertex x, y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y. f (Edge x y, Vertex y)) =\n    (\\<Sum>\\<^sup>+ y\\<in>range (Edge x). f (Vertex x, y))", "proof(clarsimp simp add: nn_integral_count_space_reindex intro!: nn_integral_cong)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa. f (Edge x xa, Vertex xa) = f (Vertex x, Edge x xa)", "fix y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa. f (Edge x xa, Vertex xa) = f (Vertex x, Edge x xa)", "have \"(\\<Sum>\\<^sup>+ z. f (Edge x y, z) * indicator {Vertex y} z) = d_OUT f (Edge x y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+z\\<in>{Vertex y}. f (Edge x y, z)\n    \\<partial>count_space UNIV =\n    d_OUT f (Edge x y)", "unfolding d_OUT_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+z\\<in>{Vertex y}. f (Edge x y, z)\n    \\<partial>count_space UNIV =\n    (\\<Sum>\\<^sup>+ ya. f (Edge x y, ya))", "by(rule nn_integral_cong)(simp split: split_indicator add: \\<Delta>''.flowD_outside[OF f])"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+z\\<in>{Vertex y}. f (Edge x y, z)\n  \\<partial>count_space UNIV =\n  d_OUT f (Edge x y)\n\ngoal (1 subgoal):\n 1. \\<And>xa. f (Edge x xa, Vertex xa) = f (Vertex x, Edge x xa)", "also"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+z\\<in>{Vertex y}. f (Edge x y, z)\n  \\<partial>count_space UNIV =\n  d_OUT f (Edge x y)\n\ngoal (1 subgoal):\n 1. \\<And>xa. f (Edge x xa, Vertex xa) = f (Vertex x, Edge x xa)", "have \"\\<dots> = d_IN f (Edge x y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. KIR f (Edge x y)", "using f"], ["proof (prove)\nusing this:\n  flow \\<Delta>'' f\n\ngoal (1 subgoal):\n 1. KIR f (Edge x y)", "by(rule flowD_KIR) simp_all"], ["proof (state)\nthis:\n  KIR f (Edge x y)\n\ngoal (1 subgoal):\n 1. \\<And>xa. f (Edge x xa, Vertex xa) = f (Vertex x, Edge x xa)", "also"], ["proof (state)\nthis:\n  KIR f (Edge x y)\n\ngoal (1 subgoal):\n 1. \\<And>xa. f (Edge x xa, Vertex xa) = f (Vertex x, Edge x xa)", "have \"\\<dots> = (\\<Sum>\\<^sup>+ z. f (z, Edge x y) * indicator {Vertex x} z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN f (Edge x y) =\n    \\<integral>\\<^sup>+z\\<in>{Vertex x}. f (z, Edge x y)\n    \\<partial>count_space UNIV", "unfolding d_IN_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ xa. f (xa, Edge x y)) =\n    \\<integral>\\<^sup>+z\\<in>{Vertex x}. f (z, Edge x y)\n    \\<partial>count_space UNIV", "by(rule nn_integral_cong)(simp split: split_indicator add: \\<Delta>''.flowD_outside[OF f])"], ["proof (state)\nthis:\n  d_IN f (Edge x y) =\n  \\<integral>\\<^sup>+z\\<in>{Vertex x}. f (z, Edge x y)\n  \\<partial>count_space UNIV\n\ngoal (1 subgoal):\n 1. \\<And>xa. f (Edge x xa, Vertex xa) = f (Vertex x, Edge x xa)", "finally"], ["proof (chain)\npicking this:\n  \\<integral>\\<^sup>+z\\<in>{Vertex y}. f (Edge x y, z)\n  \\<partial>count_space UNIV =\n  \\<integral>\\<^sup>+z\\<in>{Vertex x}. f (z, Edge x y)\n  \\<partial>count_space UNIV", "show \"f (Edge x y, Vertex y) = f (Vertex x, Edge x y)\""], ["proof (prove)\nusing this:\n  \\<integral>\\<^sup>+z\\<in>{Vertex y}. f (Edge x y, z)\n  \\<partial>count_space UNIV =\n  \\<integral>\\<^sup>+z\\<in>{Vertex x}. f (z, Edge x y)\n  \\<partial>count_space UNIV\n\ngoal (1 subgoal):\n 1. f (Edge x y, Vertex y) = f (Vertex x, Edge x y)", "by(simp add: max_def)"], ["proof (state)\nthis:\n  f (Edge x y, Vertex y) = f (Vertex x, Edge x y)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y. f (Edge x y, Vertex y)) =\n  (\\<Sum>\\<^sup>+ y\\<in>range (Edge x). f (Vertex x, y))\n\ngoal (1 subgoal):\n 1. d_OUT (\\<lambda>(x, y). f (Edge x y, Vertex y)) x = d_OUT f (Vertex x)", "also"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y. f (Edge x y, Vertex y)) =\n  (\\<Sum>\\<^sup>+ y\\<in>range (Edge x). f (Vertex x, y))\n\ngoal (1 subgoal):\n 1. d_OUT (\\<lambda>(x, y). f (Edge x y, Vertex y)) x = d_OUT f (Vertex x)", "have \"\\<dots> = d_OUT f (Vertex x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y\\<in>range (Edge x). f (Vertex x, y)) =\n    d_OUT f (Vertex x)", "by(auto intro!: nn_integral_cong \\<Delta>''.flowD_outside[OF f] simp add: nn_integral_count_space_indicator d_OUT_def split: split_indicator)"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y\\<in>range (Edge x). f (Vertex x, y)) =\n  d_OUT f (Vertex x)\n\ngoal (1 subgoal):\n 1. d_OUT (\\<lambda>(x, y). f (Edge x y, Vertex y)) x = d_OUT f (Vertex x)", "finally"], ["proof (chain)\npicking this:\n  d_OUT (\\<lambda>(x, y). f (Edge x y, Vertex y)) x = d_OUT f (Vertex x)", "show ?thesis"], ["proof (prove)\nusing this:\n  d_OUT (\\<lambda>(x, y). f (Edge x y, Vertex y)) x = d_OUT f (Vertex x)\n\ngoal (1 subgoal):\n 1. d_OUT (\\<lambda>(x, y). f (Edge x y, Vertex y)) x = d_OUT f (Vertex x)", "."], ["proof (state)\nthis:\n  d_OUT (\\<lambda>(x, y). f (Edge x y, Vertex y)) x = d_OUT f (Vertex x)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma flow_collect [simp]:\n  assumes f: \"flow \\<Delta>'' f\"\n  shows \"flow \\<Delta> (collect f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. flow \\<Delta> (\\<lambda>(x, y). f (Edge x y, Vertex y))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>e.\n       (case e of (x, y) \\<Rightarrow> f (Edge x y, Vertex y))\n       \\<le> capacity \\<Delta> e\n 2. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>;\n        x \\<noteq> sink \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> KIR (\\<lambda>(x, y). f (Edge x y, Vertex y)) x", "show \"collect f e \\<le> capacity \\<Delta> e\" for e"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case e of (x, y) \\<Rightarrow> f (Edge x y, Vertex y))\n    \\<le> capacity \\<Delta> e", "using flowD_capacity[OF f, of \"(case_prod Edge e, Vertex (snd e))\"]"], ["proof (prove)\nusing this:\n  f (case e of (x, xa) \\<Rightarrow> Edge x xa, Vertex (snd e))\n  \\<le> capacity \\<Delta>''\n         (case e of (x, xa) \\<Rightarrow> Edge x xa, Vertex (snd e))\n\ngoal (1 subgoal):\n 1. (case e of (x, y) \\<Rightarrow> f (Edge x y, Vertex y))\n    \\<le> capacity \\<Delta> e", "by(cases e)(simp)"], ["proof (state)\nthis:\n  (case ?e of (x, y) \\<Rightarrow> f (Edge x y, Vertex y))\n  \\<le> capacity \\<Delta> ?e\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>;\n        x \\<noteq> sink \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> KIR (\\<lambda>(x, y). f (Edge x y, Vertex y)) x", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>;\n        x \\<noteq> sink \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> KIR (\\<lambda>(x, y). f (Edge x y, Vertex y)) x", "assume x: \"x \\<noteq> source \\<Delta>\" \"x \\<noteq> sink \\<Delta>\""], ["proof (state)\nthis:\n  x \\<noteq> source \\<Delta>\n  x \\<noteq> sink \\<Delta>\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>;\n        x \\<noteq> sink \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> KIR (\\<lambda>(x, y). f (Edge x y, Vertex y)) x", "have \"d_OUT (collect f) x = d_OUT f (Vertex x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT (\\<lambda>(x, y). f (Edge x y, Vertex y)) x = d_OUT f (Vertex x)", "using f"], ["proof (prove)\nusing this:\n  flow \\<Delta>'' f\n\ngoal (1 subgoal):\n 1. d_OUT (\\<lambda>(x, y). f (Edge x y, Vertex y)) x = d_OUT f (Vertex x)", "by(rule d_OUT_collect)"], ["proof (state)\nthis:\n  d_OUT (\\<lambda>(x, y). f (Edge x y, Vertex y)) x = d_OUT f (Vertex x)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>;\n        x \\<noteq> sink \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> KIR (\\<lambda>(x, y). f (Edge x y, Vertex y)) x", "also"], ["proof (state)\nthis:\n  d_OUT (\\<lambda>(x, y). f (Edge x y, Vertex y)) x = d_OUT f (Vertex x)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>;\n        x \\<noteq> sink \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> KIR (\\<lambda>(x, y). f (Edge x y, Vertex y)) x", "have \"\\<dots> = d_IN f (Vertex x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. KIR f (Vertex x)", "using x flowD_KIR[OF f, of \"Vertex x\"]"], ["proof (prove)\nusing this:\n  x \\<noteq> source \\<Delta>\n  x \\<noteq> sink \\<Delta>\n  \\<lbrakk>Vertex x \\<noteq> source \\<Delta>'';\n   Vertex x \\<noteq> sink \\<Delta>''\\<rbrakk>\n  \\<Longrightarrow> KIR f (Vertex x)\n\ngoal (1 subgoal):\n 1. KIR f (Vertex x)", "by(simp)"], ["proof (state)\nthis:\n  KIR f (Vertex x)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>;\n        x \\<noteq> sink \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> KIR (\\<lambda>(x, y). f (Edge x y, Vertex y)) x", "also"], ["proof (state)\nthis:\n  KIR f (Vertex x)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>;\n        x \\<noteq> sink \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> KIR (\\<lambda>(x, y). f (Edge x y, Vertex y)) x", "have \"\\<dots> = (\\<Sum>\\<^sup>+ y\\<in>range (\\<lambda>z. Edge z x). f (y, Vertex x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN f (Vertex x) =\n    (\\<Sum>\\<^sup>+ y\\<in>range (\\<lambda>z. Edge z x). f (y, Vertex x))", "by(auto intro!: nn_integral_cong \\<Delta>''.flowD_outside[OF f] simp add: nn_integral_count_space_indicator d_IN_def split: split_indicator)"], ["proof (state)\nthis:\n  d_IN f (Vertex x) =\n  (\\<Sum>\\<^sup>+ y\\<in>range (\\<lambda>z. Edge z x). f (y, Vertex x))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>;\n        x \\<noteq> sink \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> KIR (\\<lambda>(x, y). f (Edge x y, Vertex y)) x", "also"], ["proof (state)\nthis:\n  d_IN f (Vertex x) =\n  (\\<Sum>\\<^sup>+ y\\<in>range (\\<lambda>z. Edge z x). f (y, Vertex x))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>;\n        x \\<noteq> sink \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> KIR (\\<lambda>(x, y). f (Edge x y, Vertex y)) x", "have \"\\<dots> = d_IN (collect f) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y\\<in>range (\\<lambda>z. Edge z x). f (y, Vertex x)) =\n    d_IN (\\<lambda>(x, y). f (Edge x y, Vertex y)) x", "by(simp add: nn_integral_count_space_reindex d_IN_def)"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y\\<in>range (\\<lambda>z. Edge z x). f (y, Vertex x)) =\n  d_IN (\\<lambda>(x, y). f (Edge x y, Vertex y)) x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Delta>;\n        x \\<noteq> sink \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> KIR (\\<lambda>(x, y). f (Edge x y, Vertex y)) x", "finally"], ["proof (chain)\npicking this:\n  KIR (\\<lambda>(x, y). f (Edge x y, Vertex y)) x", "show \"KIR (collect f) x\""], ["proof (prove)\nusing this:\n  KIR (\\<lambda>(x, y). f (Edge x y, Vertex y)) x\n\ngoal (1 subgoal):\n 1. KIR (\\<lambda>(x, y). f (Edge x y, Vertex y)) x", "."], ["proof (state)\nthis:\n  KIR (\\<lambda>(x, y). f (Edge x y, Vertex y)) x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma value_collect: \"flow \\<Delta>'' f \\<Longrightarrow> value_flow \\<Delta> (collect f) = value_flow \\<Delta>'' f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. flow \\<Delta>'' f \\<Longrightarrow>\n    value_flow \\<Delta> (\\<lambda>(x, y). f (Edge x y, Vertex y)) =\n    value_flow \\<Delta>'' f", "by(simp add: d_OUT_collect)"], ["", "end"], ["", "end"]]}