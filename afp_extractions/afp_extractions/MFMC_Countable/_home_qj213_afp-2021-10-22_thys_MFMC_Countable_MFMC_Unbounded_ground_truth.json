{"file_name": "/home/qj213/afp-2021-10-22/thys/MFMC_Countable/MFMC_Unbounded.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/MFMC_Countable", "problem_names": ["lemma SINK_plus_current: \"SINK (plus_current f g) = SINK f \\<inter> SINK g\"", "lemma d_OUT_plus_web:\n  fixes \\<Gamma> (structure)\n  shows \"d_OUT (f \\<frown> g) x = d_OUT f x + d_OUT (g \\<upharpoonleft> \\<Gamma> / f) x\" (is \"?lhs = ?rhs\")", "lemma d_IN_plus_web:\n  fixes \\<Gamma> (structure)\n  shows \"d_IN (f \\<frown> g) y = d_IN f y + d_IN (g \\<upharpoonleft> \\<Gamma> / f) y\" (is \"?lhs = ?rhs\")", "lemma plus_web_greater: \"f e \\<le> (f \\<frown>\\<^bsub>\\<Gamma>\\<^esub> g) e\"", "lemma current_plus_web:\n  fixes \\<Gamma> (structure)\n  shows \"\\<lbrakk> current \\<Gamma> f; wave \\<Gamma> f; current \\<Gamma> g \\<rbrakk> \\<Longrightarrow> current \\<Gamma> (f \\<frown> g)\"", "lemma RF_f: \"x \\<notin> RF\\<^sup>\\<circ> (TER f)\"", "lemma RF_g: \"x \\<notin> RF\\<^sup>\\<circ> (TER g)\"", "lemma TER_plus_web_aux:\n  assumes SINK: \"x \\<in> SINK (g \\<upharpoonleft> \\<Gamma> / f)\" (is \"_ \\<in> SINK ?g\")\n  shows \"x \\<in> TER (f \\<frown> g)\"", "lemma SINK_TER_in'':\n  assumes \"\\<And>x. x \\<notin> RF (TER g) \\<Longrightarrow> d_OUT g x = 0\"\n  shows \"x \\<in> SINK g\"", "lemma wave_plus: \"wave (quotient_web \\<Gamma> f) (g \\<upharpoonleft> \\<Gamma> / f) \\<Longrightarrow> wave \\<Gamma> (f \\<frown> g)\"", "lemma TER_plus_web'':\n  assumes \"\\<And>x. x \\<notin> RF (TER g) \\<Longrightarrow> d_OUT g x = 0\"\n  shows \"\\<E> (TER f \\<union> TER g) \\<subseteq> TER (f \\<frown> g)\"", "lemma TER_plus_web': \"wave \\<Gamma> g \\<Longrightarrow> \\<E> (TER f \\<union> TER g) \\<subseteq> TER (f \\<frown> g)\"", "lemma wave_plus': \"wave \\<Gamma> g \\<Longrightarrow> wave \\<Gamma> (f \\<frown> g)\"", "lemma RF_TER_plus_web:\n  fixes \\<Gamma> (structure)\n  assumes f: \"current \\<Gamma> f\"\n  and w: \"wave \\<Gamma> f\"\n  and g: \"current \\<Gamma> g\"\n  and w': \"wave \\<Gamma> g\"\n  shows \"RF (TER (f \\<frown> g)) = RF (TER f \\<union> TER g)\"", "lemma RF_TER_Sup:\n  fixes \\<Gamma> (structure)\n  assumes f: \"\\<And>f. f \\<in> Y \\<Longrightarrow> current \\<Gamma> f\"\n  and w: \"\\<And>f. f \\<in> Y \\<Longrightarrow> wave \\<Gamma> f\"\n  and Y: \"Complete_Partial_Order.chain (\\<le>) Y\" \"Y \\<noteq> {}\" \"countable (support_flow (Sup Y))\"\n  shows \"RF (TER (Sup Y)) = RF (\\<Union>f\\<in>Y. TER f)\"", "lemma u_A: \"x \\<in> A \\<Gamma> \\<Longrightarrow> u x = 0\"", "lemma u_finite: \"u y \\<noteq> \\<top>\"", "lemma hindered_reduce: \\<comment> \\<open>Lemma 6.7\\<close>\n  assumes u: \"u \\<le> weight \\<Gamma>\"\n  assumes hindered_by: \"hindered_by (\\<Gamma>\\<lparr>weight := weight \\<Gamma> - u\\<rparr>) \\<epsilon>\" (is \"hindered_by ?\\<Gamma> _\")\n  shows \"hindered \\<Gamma>\"", "lemma reduce_weight_sel [simp]:\n  \"edge (reduce_weight \\<Gamma> x r) = edge \\<Gamma>\"\n  \"A (reduce_weight \\<Gamma> x r) = A \\<Gamma>\"\n  \"B (reduce_weight \\<Gamma> x r) = B \\<Gamma>\"\n  \"vertex (reduce_weight \\<Gamma> x r) = vertex \\<Gamma>\"\n  \"weight (reduce_weight \\<Gamma> x r) y = (if x = y then weight \\<Gamma> x - r else weight \\<Gamma> y)\"\n  \"web.more (reduce_weight \\<Gamma> x r) = web.more \\<Gamma>\"", "lemma essential_reduce_weight [simp]: \"essential (reduce_weight \\<Gamma> x r) = essential \\<Gamma>\"", "lemma roofed_reduce_weight [simp]: \"roofed_gen (reduce_weight \\<Gamma> x r) = roofed_gen \\<Gamma>\"", "lemma notin_range_Inner:  \"x \\<notin> range Inner \\<longleftrightarrow> x = SOURCE \\<or> x = SINK\"", "lemma inj_Inner [simp]: \"\\<And>A. inj_on Inner A\"", "lemma unhinder_bipartite:\n  assumes h: \"\\<And>n :: nat. current \\<Gamma> (h n)\"\n  and SAT: \"\\<And>n. (B \\<Gamma> \\<inter> \\<^bold>V) - {b} \\<subseteq> SAT \\<Gamma> (h n)\"\n  and b: \"b \\<in> B \\<Gamma>\"\n  and IN: \"(SUP n. d_IN (h n) b) = weight \\<Gamma> b\"\n  and h0_b: \"\\<And>n. d_IN (h 0) b \\<le> d_IN (h n) b\"\n  and b_V: \"b \\<in> \\<^bold>V\"\n  shows \"\\<exists>h'. current \\<Gamma> h' \\<and> wave \\<Gamma> h' \\<and> B \\<Gamma> \\<inter> \\<^bold>V \\<subseteq> SAT \\<Gamma> h'\"", "lemma countable_bipartite_web_reduce_weight:\n  assumes \"weight \\<Gamma> x \\<ge> w\"\n  shows \"countable_bipartite_web (reduce_weight \\<Gamma> x w)\"", "lemma unhinder: \\<comment> \\<open>Lemma 6.9\\<close>\n  assumes loose: \"loose \\<Gamma>\"\n  and b: \"b \\<in> B \\<Gamma>\"\n  and wb: \"weight \\<Gamma> b > 0\"\n  and \\<delta>: \"\\<delta> > 0\"\n  shows \"\\<exists>\\<epsilon>>0. \\<epsilon> < \\<delta> \\<and> \\<not> hindered (reduce_weight \\<Gamma> b \\<epsilon>)\"", "lemma web_flow_iff: \"web_flow \\<Gamma> f \\<longleftrightarrow> current \\<Gamma> f\"", "lemma countable_bipartite_web_minus_web:\n  assumes f: \"current \\<Gamma> f\"\n  shows \"countable_bipartite_web (\\<Gamma> \\<ominus> f)\"", "lemma current_plus_current_minus:\n  assumes f: \"current \\<Gamma> f\"\n  and g: \"current (\\<Gamma> \\<ominus> f) g\"\n  shows \"current \\<Gamma> (plus_current f g)\" (is \"current _ ?fg\")", "lemma wave_plus_current_minus:\n  assumes f: \"current \\<Gamma> f\"\n  and w: \"wave \\<Gamma> f\"\n  and g: \"current (\\<Gamma> \\<ominus> f) g\"\n  and w': \"wave (\\<Gamma> \\<ominus> f) g\"\n  shows \"wave \\<Gamma> (plus_current f g)\" (is \"wave _ ?fg\")", "lemma minus_plus_current:\n  assumes f: \"current \\<Gamma> f\"\n  and g: \"current (\\<Gamma> \\<ominus> f) g\"\n  shows \"\\<Gamma> \\<ominus> plus_current f g = \\<Gamma> \\<ominus> f \\<ominus> g\" (is \"?lhs = ?rhs\")", "lemma unhindered_minus_web:\n  assumes unhindered: \"\\<not> hindered \\<Gamma>\"\n  and f: \"current \\<Gamma> f\"\n  and w: \"wave \\<Gamma> f\"\n  shows \"\\<not> hindered (\\<Gamma> \\<ominus> f)\"", "lemma loose_minus_web:\n  assumes unhindered: \"\\<not> hindered \\<Gamma>\"\n  and f: \"current \\<Gamma> f\"\n  and w: \"wave \\<Gamma> f\"\n  and maximal: \"\\<And>w. \\<lbrakk> current \\<Gamma> w; wave \\<Gamma> w; f \\<le> w \\<rbrakk> \\<Longrightarrow> f = w\"\n  shows \"loose (\\<Gamma> \\<ominus> f)\" (is \"loose ?\\<Gamma>\")", "lemma weight_minus_web:\n  assumes f: \"current \\<Gamma> f\"\n  shows \"weight (\\<Gamma> \\<ominus> f) x = (if x \\<in> A \\<Gamma> then weight \\<Gamma> x - d_OUT f x else weight \\<Gamma> x - d_IN f x)\"", "lemma (in -) separating_minus_web [simp]: \"separating_gen (G \\<ominus> f) = separating_gen G\"", "lemma current_minus:\n  assumes f: \"current \\<Gamma> f\"\n  and g: \"current \\<Gamma> g\"\n  and le: \"\\<And>e. g e \\<le> f e\"\n  shows \"current (\\<Gamma> \\<ominus> g) (f - g)\"", "lemma\n  assumes w: \"wave \\<Gamma> f\"\n  and g: \"current \\<Gamma> g\"\n  and le: \"\\<And>e. g e \\<le> f e\"\n  shows wave_minus: \"wave (\\<Gamma> \\<ominus> g) (f - g)\"\n  and TER_minus: \"TER f \\<subseteq> TER\\<^bsub>\\<Gamma> \\<ominus> g\\<^esub> (f - g)\"", "lemma (in -) essential_minus_web [simp]: \"essential (\\<Gamma> \\<ominus> f) = essential \\<Gamma>\"", "lemma (in -) RF_in_essential: fixes B shows \"essential \\<Gamma> B S x \\<Longrightarrow> x \\<in> roofed_gen \\<Gamma> B S \\<longleftrightarrow> x \\<in> S\"", "lemma (in -) d_OUT_fun_upd:\n  assumes \"f (x, y) \\<noteq> \\<top>\" \"f (x, y) \\<ge> 0\" \"k \\<noteq> \\<top>\" \"k \\<ge> 0\"\n  shows \"d_OUT (f((x, y) := k)) x' = (if x = x' then d_OUT f x - f (x, y) + k else d_OUT f x')\"\n  (is \"?lhs = ?rhs\")", "lemma unhindered_saturate1: \\<comment> \\<open>Lemma 6.10\\<close>\n  assumes unhindered: \"\\<not> hindered \\<Gamma>\"\n  and a: \"a \\<in> A \\<Gamma>\"\n  shows \"\\<exists>f. current \\<Gamma> f \\<and> d_OUT f a = weight \\<Gamma> a \\<and> \\<not> hindered (\\<Gamma> \\<ominus> f)\"", "theorem unhindered_linkable:\n  assumes unhindered: \"\\<not> hindered \\<Gamma>\"\n  shows \"linkable \\<Gamma>\"", "theorem loose_linkable: \\<comment> \\<open>Theorem 6.2\\<close>\n  assumes \"loose \\<Gamma>\"\n  shows \"linkable \\<Gamma>\"", "lemma ex_orthogonal_current: \\<comment> \\<open>Lemma 4.15\\<close>\n  \"\\<exists>f S. web_flow \\<Gamma> f \\<and> separating \\<Gamma> S \\<and> orthogonal_current \\<Gamma> f S\"", "lemma max_flow_min_cut':\n  assumes source_in: \"\\<And>x. \\<not> edge \\<Delta> x (source \\<Delta>)\"\n  and sink_out: \"\\<And>y. \\<not> edge \\<Delta> (sink \\<Delta>) y\"\n  and undead: \"\\<And>x y. edge \\<Delta> x y \\<Longrightarrow> (\\<exists>z. edge \\<Delta> y z) \\<or> (\\<exists>z. edge \\<Delta> z x)\"\n  and source_sink: \"\\<not> edge \\<Delta> (source \\<Delta>) (sink \\<Delta>)\"\n  and no_loop: \"\\<And>x. \\<not> edge \\<Delta> x x\"\n  and capacity_pos: \"\\<And>e. e \\<in> \\<^bold>E \\<Longrightarrow> capacity \\<Delta> e > 0\"\n  shows \"\\<exists>f S. flow \\<Delta> f \\<and> cut \\<Delta> S \\<and> orthogonal \\<Delta> f S\"", "lemma max_flow_min_cut'':\n  assumes sink_out: \"\\<And>y. \\<not> edge \\<Delta> (sink \\<Delta>) y\"\n  and source_in: \"\\<And>x. \\<not> edge \\<Delta> x (source \\<Delta>)\"\n  and no_loop: \"\\<And>x. \\<not> edge \\<Delta> x x\"\n  and capacity_pos: \"\\<And>e. e \\<in> \\<^bold>E \\<Longrightarrow> capacity \\<Delta> e > 0\"\n  shows \"\\<exists>f S. flow \\<Delta> f \\<and> cut \\<Delta> S \\<and> orthogonal \\<Delta> f S\"", "lemma max_flow_min_cut''':\n  assumes sink_out: \"\\<And>y. \\<not> edge \\<Delta> (sink \\<Delta>) y\"\n  and source_in: \"\\<And>x. \\<not> edge \\<Delta> x (source \\<Delta>)\"\n  and capacity_pos: \"\\<And>e. e \\<in> \\<^bold>E \\<Longrightarrow> capacity \\<Delta> e > 0\"\n  shows \"\\<exists>f S. flow \\<Delta> f \\<and> cut \\<Delta> S \\<and> orthogonal \\<Delta> f S\"", "theorem max_flow_min_cut:\n  \"\\<exists>f S. flow \\<Delta> f \\<and> cut \\<Delta> S \\<and> orthogonal \\<Delta> f S\""], "translations": [["", "lemma SINK_plus_current: \"SINK (plus_current f g) = SINK f \\<inter> SINK g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SINK (plus_current f g) = SINK f \\<inter> SINK g", "by(auto simp add: SINK.simps set_eq_iff d_OUT_def nn_integral_0_iff emeasure_count_space_eq_0 add_eq_0_iff_both_eq_0)"], ["", "abbreviation plus_web :: \"('v, 'more) web_scheme \\<Rightarrow> 'v current \\<Rightarrow> 'v current \\<Rightarrow> 'v current\" (\"_ \\<frown>\\<index> _\" [66, 66] 65)\nwhere \"plus_web \\<Gamma> f g \\<equiv> plus_current f (g \\<upharpoonleft> \\<Gamma> / f)\""], ["", "lemma d_OUT_plus_web:\n  fixes \\<Gamma> (structure)\n  shows \"d_OUT (f \\<frown> g) x = d_OUT f x + d_OUT (g \\<upharpoonleft> \\<Gamma> / f) x\" (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT (f \\<frown> g) x =\n    d_OUT f x + d_OUT (g \\<upharpoonleft> \\<Gamma> / f) x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. d_OUT (f \\<frown> g) x =\n    d_OUT f x + d_OUT (g \\<upharpoonleft> \\<Gamma> / f) x", "have \"?lhs = d_OUT f x + (\\<Sum>\\<^sup>+ y. (if x \\<in> RF\\<^sup>\\<circ> (TER f) then 0 else g (x, y) * indicator (- RF (TER f)) y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT (f \\<frown> g) x =\n    d_OUT f x +\n    (\\<Sum>\\<^sup>+ y.\n       if x \\<in> RF\\<^sup>\\<circ> (TER f) then 0\n       else g (x, y) * indicator (- RF (TER f)) y)", "unfolding d_OUT_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y. (f \\<frown> g) (x, y)) =\n    (\\<Sum>\\<^sup>+ y. f (x, y)) +\n    (\\<Sum>\\<^sup>+ y.\n       if x \\<in> RF\\<^sup>\\<circ> (TER f) then 0\n       else g (x, y) * indicator (- RF (TER f)) y)", "by(subst nn_integral_add[symmetric])(auto intro!: nn_integral_cong split: split_indicator)"], ["proof (state)\nthis:\n  d_OUT (f \\<frown> g) x =\n  d_OUT f x +\n  (\\<Sum>\\<^sup>+ y.\n     if x \\<in> RF\\<^sup>\\<circ> (TER f) then 0\n     else g (x, y) * indicator (- RF (TER f)) y)\n\ngoal (1 subgoal):\n 1. d_OUT (f \\<frown> g) x =\n    d_OUT f x + d_OUT (g \\<upharpoonleft> \\<Gamma> / f) x", "also"], ["proof (state)\nthis:\n  d_OUT (f \\<frown> g) x =\n  d_OUT f x +\n  (\\<Sum>\\<^sup>+ y.\n     if x \\<in> RF\\<^sup>\\<circ> (TER f) then 0\n     else g (x, y) * indicator (- RF (TER f)) y)\n\ngoal (1 subgoal):\n 1. d_OUT (f \\<frown> g) x =\n    d_OUT f x + d_OUT (g \\<upharpoonleft> \\<Gamma> / f) x", "have \"\\<dots> = ?rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT f x +\n    (\\<Sum>\\<^sup>+ y.\n       if x \\<in> RF\\<^sup>\\<circ> (TER f) then 0\n       else g (x, y) * indicator (- RF (TER f)) y) =\n    d_OUT f x + d_OUT (g \\<upharpoonleft> \\<Gamma> / f) x", "by(auto simp add: d_OUT_def intro!: arg_cong2[where f=\"(+)\"] nn_integral_cong)"], ["proof (state)\nthis:\n  d_OUT f x +\n  (\\<Sum>\\<^sup>+ y.\n     if x \\<in> RF\\<^sup>\\<circ> (TER f) then 0\n     else g (x, y) * indicator (- RF (TER f)) y) =\n  d_OUT f x + d_OUT (g \\<upharpoonleft> \\<Gamma> / f) x\n\ngoal (1 subgoal):\n 1. d_OUT (f \\<frown> g) x =\n    d_OUT f x + d_OUT (g \\<upharpoonleft> \\<Gamma> / f) x", "finally"], ["proof (chain)\npicking this:\n  d_OUT (f \\<frown> g) x =\n  d_OUT f x + d_OUT (g \\<upharpoonleft> \\<Gamma> / f) x", "show \"?thesis\""], ["proof (prove)\nusing this:\n  d_OUT (f \\<frown> g) x =\n  d_OUT f x + d_OUT (g \\<upharpoonleft> \\<Gamma> / f) x\n\ngoal (1 subgoal):\n 1. d_OUT (f \\<frown> g) x =\n    d_OUT f x + d_OUT (g \\<upharpoonleft> \\<Gamma> / f) x", "."], ["proof (state)\nthis:\n  d_OUT (f \\<frown> g) x =\n  d_OUT f x + d_OUT (g \\<upharpoonleft> \\<Gamma> / f) x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma d_IN_plus_web:\n  fixes \\<Gamma> (structure)\n  shows \"d_IN (f \\<frown> g) y = d_IN f y + d_IN (g \\<upharpoonleft> \\<Gamma> / f) y\" (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN (f \\<frown> g) y =\n    d_IN f y + d_IN (g \\<upharpoonleft> \\<Gamma> / f) y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. d_IN (f \\<frown> g) y =\n    d_IN f y + d_IN (g \\<upharpoonleft> \\<Gamma> / f) y", "have \"?lhs = d_IN f y + (\\<Sum>\\<^sup>+ x. (if y \\<in> RF (TER f) then 0 else g (x, y) * indicator (- RF\\<^sup>\\<circ> (TER f)) x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN (f \\<frown> g) y =\n    d_IN f y +\n    (\\<Sum>\\<^sup>+ x.\n       if y \\<in> RF (TER f) then 0\n       else g (x, y) * indicator (- RF\\<^sup>\\<circ> (TER f)) x)", "unfolding d_IN_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ x. (f \\<frown> g) (x, y)) =\n    (\\<Sum>\\<^sup>+ x. f (x, y)) +\n    (\\<Sum>\\<^sup>+ x.\n       if y \\<in> RF (TER f) then 0\n       else g (x, y) * indicator (- RF\\<^sup>\\<circ> (TER f)) x)", "by(subst nn_integral_add[symmetric])(auto intro!: nn_integral_cong split: split_indicator)"], ["proof (state)\nthis:\n  d_IN (f \\<frown> g) y =\n  d_IN f y +\n  (\\<Sum>\\<^sup>+ x.\n     if y \\<in> RF (TER f) then 0\n     else g (x, y) * indicator (- RF\\<^sup>\\<circ> (TER f)) x)\n\ngoal (1 subgoal):\n 1. d_IN (f \\<frown> g) y =\n    d_IN f y + d_IN (g \\<upharpoonleft> \\<Gamma> / f) y", "also"], ["proof (state)\nthis:\n  d_IN (f \\<frown> g) y =\n  d_IN f y +\n  (\\<Sum>\\<^sup>+ x.\n     if y \\<in> RF (TER f) then 0\n     else g (x, y) * indicator (- RF\\<^sup>\\<circ> (TER f)) x)\n\ngoal (1 subgoal):\n 1. d_IN (f \\<frown> g) y =\n    d_IN f y + d_IN (g \\<upharpoonleft> \\<Gamma> / f) y", "have \"\\<dots> = ?rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN f y +\n    (\\<Sum>\\<^sup>+ x.\n       if y \\<in> RF (TER f) then 0\n       else g (x, y) * indicator (- RF\\<^sup>\\<circ> (TER f)) x) =\n    d_IN f y + d_IN (g \\<upharpoonleft> \\<Gamma> / f) y", "by(auto simp add: d_IN_def intro!: arg_cong2[where f=\"(+)\"] nn_integral_cong)"], ["proof (state)\nthis:\n  d_IN f y +\n  (\\<Sum>\\<^sup>+ x.\n     if y \\<in> RF (TER f) then 0\n     else g (x, y) * indicator (- RF\\<^sup>\\<circ> (TER f)) x) =\n  d_IN f y + d_IN (g \\<upharpoonleft> \\<Gamma> / f) y\n\ngoal (1 subgoal):\n 1. d_IN (f \\<frown> g) y =\n    d_IN f y + d_IN (g \\<upharpoonleft> \\<Gamma> / f) y", "finally"], ["proof (chain)\npicking this:\n  d_IN (f \\<frown> g) y =\n  d_IN f y + d_IN (g \\<upharpoonleft> \\<Gamma> / f) y", "show ?thesis"], ["proof (prove)\nusing this:\n  d_IN (f \\<frown> g) y =\n  d_IN f y + d_IN (g \\<upharpoonleft> \\<Gamma> / f) y\n\ngoal (1 subgoal):\n 1. d_IN (f \\<frown> g) y =\n    d_IN f y + d_IN (g \\<upharpoonleft> \\<Gamma> / f) y", "."], ["proof (state)\nthis:\n  d_IN (f \\<frown> g) y =\n  d_IN f y + d_IN (g \\<upharpoonleft> \\<Gamma> / f) y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma plus_web_greater: \"f e \\<le> (f \\<frown>\\<^bsub>\\<Gamma>\\<^esub> g) e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f e \\<le> (f \\<frown>\\<^bsub>\\<Gamma>\\<^esub> g) e", "by(cases e)(auto split: split_indicator)"], ["", "lemma current_plus_web:\n  fixes \\<Gamma> (structure)\n  shows \"\\<lbrakk> current \\<Gamma> f; wave \\<Gamma> f; current \\<Gamma> g \\<rbrakk> \\<Longrightarrow> current \\<Gamma> (f \\<frown> g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>current \\<Gamma> f; wave \\<Gamma> f;\n     current \\<Gamma> g\\<rbrakk>\n    \\<Longrightarrow> current \\<Gamma> (f \\<frown> g)", "by(blast intro: current_plus_current current_restrict_current)"], ["", "context\n  fixes \\<Gamma> :: \"('v, 'more) web_scheme\" (structure)\n  and f g :: \"'v current\"\n  assumes f: \"current \\<Gamma> f\"\n  and w: \"wave \\<Gamma> f\"\n  and g: \"current \\<Gamma> g\"\nbegin"], ["", "context\n  fixes x :: \"'v\"\n  assumes x: \"x \\<in> \\<E> (TER f \\<union> TER g)\"\nbegin"], ["", "qualified"], ["", "lemma RF_f: \"x \\<notin> RF\\<^sup>\\<circ> (TER f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> RF\\<^sup>\\<circ> (TER f)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<in> RF\\<^sup>\\<circ> (TER f) \\<Longrightarrow> False", "assume *: \"x \\<in> RF\\<^sup>\\<circ> (TER f)\""], ["proof (state)\nthis:\n  x \\<in> RF\\<^sup>\\<circ> (TER f)\n\ngoal (1 subgoal):\n 1. x \\<in> RF\\<^sup>\\<circ> (TER f) \\<Longrightarrow> False", "from x"], ["proof (chain)\npicking this:\n  x \\<in> \\<E> (TER f \\<union> TER g)", "obtain p y where p: \"path \\<Gamma> x p y\" and y: \"y \\<in> B \\<Gamma>\"\n    and bypass: \"\\<And>z. \\<lbrakk>x \\<noteq> y; z \\<in> set p\\<rbrakk> \\<Longrightarrow> z = x \\<or> z \\<notin> TER f \\<union> TER g\""], ["proof (prove)\nusing this:\n  x \\<in> \\<E> (TER f \\<union> TER g)\n\ngoal (1 subgoal):\n 1. (\\<And>p y.\n        \\<lbrakk>path \\<Gamma> x p y; y \\<in> B \\<Gamma>;\n         \\<And>z.\n            \\<lbrakk>x \\<noteq> y; z \\<in> set p\\<rbrakk>\n            \\<Longrightarrow> z = x \\<or>\n                              z \\<notin> TER f \\<union> TER g\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(rule \\<E>_E) blast"], ["proof (state)\nthis:\n  path \\<Gamma> x p y\n  y \\<in> B \\<Gamma>\n  \\<lbrakk>x \\<noteq> y; ?z \\<in> set p\\<rbrakk>\n  \\<Longrightarrow> ?z = x \\<or> ?z \\<notin> TER f \\<union> TER g\n\ngoal (1 subgoal):\n 1. x \\<in> RF\\<^sup>\\<circ> (TER f) \\<Longrightarrow> False", "from rtrancl_path_distinct[OF p]"], ["proof (chain)\npicking this:\n  (\\<And>xs'.\n      \\<lbrakk>path \\<Gamma> x xs' y; distinct (x # xs');\n       set xs' \\<subseteq> set p\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis", "obtain p'\n    where p: \"path \\<Gamma> x p' y\" and p': \"set p' \\<subseteq> set p\" and distinct: \"distinct (x # p')\""], ["proof (prove)\nusing this:\n  (\\<And>xs'.\n      \\<lbrakk>path \\<Gamma> x xs' y; distinct (x # xs');\n       set xs' \\<subseteq> set p\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>p'.\n        \\<lbrakk>path \\<Gamma> x p' y; set p' \\<subseteq> set p;\n         distinct (x # p')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "."], ["proof (state)\nthis:\n  path \\<Gamma> x p' y\n  set p' \\<subseteq> set p\n  distinct (x # p')\n\ngoal (1 subgoal):\n 1. x \\<in> RF\\<^sup>\\<circ> (TER f) \\<Longrightarrow> False", "from *"], ["proof (chain)\npicking this:\n  x \\<in> RF\\<^sup>\\<circ> (TER f)", "have x': \"x \\<in> RF (TER f)\" and \\<E>: \"x \\<notin> \\<E> (TER f)\""], ["proof (prove)\nusing this:\n  x \\<in> RF\\<^sup>\\<circ> (TER f)\n\ngoal (1 subgoal):\n 1. x \\<in> RF (TER f) &&& x \\<notin> \\<E> (TER f)", "by(auto simp add: roofed_circ_def)"], ["proof (state)\nthis:\n  x \\<in> RF (TER f)\n  x \\<notin> \\<E> (TER f)\n\ngoal (1 subgoal):\n 1. x \\<in> RF\\<^sup>\\<circ> (TER f) \\<Longrightarrow> False", "hence \"x \\<notin> TER f\""], ["proof (prove)\nusing this:\n  x \\<in> RF (TER f)\n  x \\<notin> \\<E> (TER f)\n\ngoal (1 subgoal):\n 1. x \\<notin> TER f", "using not_essentialD[OF _ p y] p' bypass"], ["proof (prove)\nusing this:\n  x \\<in> RF (TER f)\n  x \\<notin> \\<E> (TER f)\n  \\<not> essential \\<Gamma> (B \\<Gamma>) ?S x \\<Longrightarrow>\n  x \\<noteq> y \\<and>\n  (\\<exists>z\\<in>set p'. z \\<noteq> x \\<and> z \\<in> ?S)\n  set p' \\<subseteq> set p\n  \\<lbrakk>x \\<noteq> y; ?z \\<in> set p\\<rbrakk>\n  \\<Longrightarrow> ?z = x \\<or> ?z \\<notin> TER f \\<union> TER g\n\ngoal (1 subgoal):\n 1. x \\<notin> TER f", "by blast"], ["proof (state)\nthis:\n  x \\<notin> TER f\n\ngoal (1 subgoal):\n 1. x \\<in> RF\\<^sup>\\<circ> (TER f) \\<Longrightarrow> False", "with roofedD[OF x' p y]"], ["proof (chain)\npicking this:\n  (\\<exists>z\\<in>set p'. z \\<in> TER f) \\<or> x \\<in> TER f\n  x \\<notin> TER f", "obtain z where z: \"z \\<in> set p'\" \"z \\<in> TER f\""], ["proof (prove)\nusing this:\n  (\\<exists>z\\<in>set p'. z \\<in> TER f) \\<or> x \\<in> TER f\n  x \\<notin> TER f\n\ngoal (1 subgoal):\n 1. (\\<And>z.\n        \\<lbrakk>z \\<in> set p'; z \\<in> TER f\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  z \\<in> set p'\n  z \\<in> TER f\n\ngoal (1 subgoal):\n 1. x \\<in> RF\\<^sup>\\<circ> (TER f) \\<Longrightarrow> False", "with p"], ["proof (chain)\npicking this:\n  path \\<Gamma> x p' y\n  z \\<in> set p'\n  z \\<in> TER f", "have \"y \\<in> set p'\""], ["proof (prove)\nusing this:\n  path \\<Gamma> x p' y\n  z \\<in> set p'\n  z \\<in> TER f\n\ngoal (1 subgoal):\n 1. y \\<in> set p'", "by(auto dest!: rtrancl_path_last intro: last_in_set)"], ["proof (state)\nthis:\n  y \\<in> set p'\n\ngoal (1 subgoal):\n 1. x \\<in> RF\\<^sup>\\<circ> (TER f) \\<Longrightarrow> False", "with distinct"], ["proof (chain)\npicking this:\n  distinct (x # p')\n  y \\<in> set p'", "have \"x \\<noteq> y\""], ["proof (prove)\nusing this:\n  distinct (x # p')\n  y \\<in> set p'\n\ngoal (1 subgoal):\n 1. x \\<noteq> y", "by auto"], ["proof (state)\nthis:\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. x \\<in> RF\\<^sup>\\<circ> (TER f) \\<Longrightarrow> False", "with bypass z p' distinct"], ["proof (chain)\npicking this:\n  \\<lbrakk>x \\<noteq> y; ?z \\<in> set p\\<rbrakk>\n  \\<Longrightarrow> ?z = x \\<or> ?z \\<notin> TER f \\<union> TER g\n  z \\<in> set p'\n  z \\<in> TER f\n  set p' \\<subseteq> set p\n  distinct (x # p')\n  x \\<noteq> y", "show False"], ["proof (prove)\nusing this:\n  \\<lbrakk>x \\<noteq> y; ?z \\<in> set p\\<rbrakk>\n  \\<Longrightarrow> ?z = x \\<or> ?z \\<notin> TER f \\<union> TER g\n  z \\<in> set p'\n  z \\<in> TER f\n  set p' \\<subseteq> set p\n  distinct (x # p')\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "private"], ["", "lemma RF_g: \"x \\<notin> RF\\<^sup>\\<circ> (TER g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> RF\\<^sup>\\<circ> (TER g)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<in> RF\\<^sup>\\<circ> (TER g) \\<Longrightarrow> False", "assume *: \"x \\<in> RF\\<^sup>\\<circ> (TER g)\""], ["proof (state)\nthis:\n  x \\<in> RF\\<^sup>\\<circ> (TER g)\n\ngoal (1 subgoal):\n 1. x \\<in> RF\\<^sup>\\<circ> (TER g) \\<Longrightarrow> False", "from x"], ["proof (chain)\npicking this:\n  x \\<in> \\<E> (TER f \\<union> TER g)", "obtain p y where p: \"path \\<Gamma> x p y\" and y: \"y \\<in> B \\<Gamma>\"\n    and bypass: \"\\<And>z. \\<lbrakk>x \\<noteq> y; z \\<in> set p\\<rbrakk> \\<Longrightarrow> z = x \\<or> z \\<notin> TER f \\<union> TER g\""], ["proof (prove)\nusing this:\n  x \\<in> \\<E> (TER f \\<union> TER g)\n\ngoal (1 subgoal):\n 1. (\\<And>p y.\n        \\<lbrakk>path \\<Gamma> x p y; y \\<in> B \\<Gamma>;\n         \\<And>z.\n            \\<lbrakk>x \\<noteq> y; z \\<in> set p\\<rbrakk>\n            \\<Longrightarrow> z = x \\<or>\n                              z \\<notin> TER f \\<union> TER g\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(rule \\<E>_E) blast"], ["proof (state)\nthis:\n  path \\<Gamma> x p y\n  y \\<in> B \\<Gamma>\n  \\<lbrakk>x \\<noteq> y; ?z \\<in> set p\\<rbrakk>\n  \\<Longrightarrow> ?z = x \\<or> ?z \\<notin> TER f \\<union> TER g\n\ngoal (1 subgoal):\n 1. x \\<in> RF\\<^sup>\\<circ> (TER g) \\<Longrightarrow> False", "from rtrancl_path_distinct[OF p]"], ["proof (chain)\npicking this:\n  (\\<And>xs'.\n      \\<lbrakk>path \\<Gamma> x xs' y; distinct (x # xs');\n       set xs' \\<subseteq> set p\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis", "obtain p'\n    where p: \"path \\<Gamma> x p' y\" and p': \"set p' \\<subseteq> set p\" and distinct: \"distinct (x # p')\""], ["proof (prove)\nusing this:\n  (\\<And>xs'.\n      \\<lbrakk>path \\<Gamma> x xs' y; distinct (x # xs');\n       set xs' \\<subseteq> set p\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>p'.\n        \\<lbrakk>path \\<Gamma> x p' y; set p' \\<subseteq> set p;\n         distinct (x # p')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "."], ["proof (state)\nthis:\n  path \\<Gamma> x p' y\n  set p' \\<subseteq> set p\n  distinct (x # p')\n\ngoal (1 subgoal):\n 1. x \\<in> RF\\<^sup>\\<circ> (TER g) \\<Longrightarrow> False", "from *"], ["proof (chain)\npicking this:\n  x \\<in> RF\\<^sup>\\<circ> (TER g)", "have x': \"x \\<in> RF (TER g)\" and \\<E>: \"x \\<notin> \\<E> (TER g)\""], ["proof (prove)\nusing this:\n  x \\<in> RF\\<^sup>\\<circ> (TER g)\n\ngoal (1 subgoal):\n 1. x \\<in> RF (TER g) &&& x \\<notin> \\<E> (TER g)", "by(auto simp add: roofed_circ_def)"], ["proof (state)\nthis:\n  x \\<in> RF (TER g)\n  x \\<notin> \\<E> (TER g)\n\ngoal (1 subgoal):\n 1. x \\<in> RF\\<^sup>\\<circ> (TER g) \\<Longrightarrow> False", "hence \"x \\<notin> TER g\""], ["proof (prove)\nusing this:\n  x \\<in> RF (TER g)\n  x \\<notin> \\<E> (TER g)\n\ngoal (1 subgoal):\n 1. x \\<notin> TER g", "using not_essentialD[OF _ p y] p' bypass"], ["proof (prove)\nusing this:\n  x \\<in> RF (TER g)\n  x \\<notin> \\<E> (TER g)\n  \\<not> essential \\<Gamma> (B \\<Gamma>) ?S x \\<Longrightarrow>\n  x \\<noteq> y \\<and>\n  (\\<exists>z\\<in>set p'. z \\<noteq> x \\<and> z \\<in> ?S)\n  set p' \\<subseteq> set p\n  \\<lbrakk>x \\<noteq> y; ?z \\<in> set p\\<rbrakk>\n  \\<Longrightarrow> ?z = x \\<or> ?z \\<notin> TER f \\<union> TER g\n\ngoal (1 subgoal):\n 1. x \\<notin> TER g", "by blast"], ["proof (state)\nthis:\n  x \\<notin> TER g\n\ngoal (1 subgoal):\n 1. x \\<in> RF\\<^sup>\\<circ> (TER g) \\<Longrightarrow> False", "with roofedD[OF x' p y]"], ["proof (chain)\npicking this:\n  (\\<exists>z\\<in>set p'. z \\<in> TER g) \\<or> x \\<in> TER g\n  x \\<notin> TER g", "obtain z where z: \"z \\<in> set p'\" \"z \\<in> TER g\""], ["proof (prove)\nusing this:\n  (\\<exists>z\\<in>set p'. z \\<in> TER g) \\<or> x \\<in> TER g\n  x \\<notin> TER g\n\ngoal (1 subgoal):\n 1. (\\<And>z.\n        \\<lbrakk>z \\<in> set p'; z \\<in> TER g\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  z \\<in> set p'\n  z \\<in> TER g\n\ngoal (1 subgoal):\n 1. x \\<in> RF\\<^sup>\\<circ> (TER g) \\<Longrightarrow> False", "with p"], ["proof (chain)\npicking this:\n  path \\<Gamma> x p' y\n  z \\<in> set p'\n  z \\<in> TER g", "have \"y \\<in> set p'\""], ["proof (prove)\nusing this:\n  path \\<Gamma> x p' y\n  z \\<in> set p'\n  z \\<in> TER g\n\ngoal (1 subgoal):\n 1. y \\<in> set p'", "by(auto dest!: rtrancl_path_last intro: last_in_set)"], ["proof (state)\nthis:\n  y \\<in> set p'\n\ngoal (1 subgoal):\n 1. x \\<in> RF\\<^sup>\\<circ> (TER g) \\<Longrightarrow> False", "with distinct"], ["proof (chain)\npicking this:\n  distinct (x # p')\n  y \\<in> set p'", "have \"x \\<noteq> y\""], ["proof (prove)\nusing this:\n  distinct (x # p')\n  y \\<in> set p'\n\ngoal (1 subgoal):\n 1. x \\<noteq> y", "by auto"], ["proof (state)\nthis:\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. x \\<in> RF\\<^sup>\\<circ> (TER g) \\<Longrightarrow> False", "with bypass z p' distinct"], ["proof (chain)\npicking this:\n  \\<lbrakk>x \\<noteq> y; ?z \\<in> set p\\<rbrakk>\n  \\<Longrightarrow> ?z = x \\<or> ?z \\<notin> TER f \\<union> TER g\n  z \\<in> set p'\n  z \\<in> TER g\n  set p' \\<subseteq> set p\n  distinct (x # p')\n  x \\<noteq> y", "show False"], ["proof (prove)\nusing this:\n  \\<lbrakk>x \\<noteq> y; ?z \\<in> set p\\<rbrakk>\n  \\<Longrightarrow> ?z = x \\<or> ?z \\<notin> TER f \\<union> TER g\n  z \\<in> set p'\n  z \\<in> TER g\n  set p' \\<subseteq> set p\n  distinct (x # p')\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma TER_plus_web_aux:\n  assumes SINK: \"x \\<in> SINK (g \\<upharpoonleft> \\<Gamma> / f)\" (is \"_ \\<in> SINK ?g\")\n  shows \"x \\<in> TER (f \\<frown> g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> TER (f \\<frown> g)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<in> SAT \\<Gamma> (f \\<frown> g)\n 2. x \\<in> SINK (f \\<frown> g)", "from x"], ["proof (chain)\npicking this:\n  x \\<in> \\<E> (TER f \\<union> TER g)", "obtain p y where p: \"path \\<Gamma> x p y\" and y: \"y \\<in> B \\<Gamma>\"\n    and bypass: \"\\<And>z. \\<lbrakk>x \\<noteq> y; z \\<in> set p\\<rbrakk> \\<Longrightarrow> z = x \\<or> z \\<notin> TER f \\<union> TER g\""], ["proof (prove)\nusing this:\n  x \\<in> \\<E> (TER f \\<union> TER g)\n\ngoal (1 subgoal):\n 1. (\\<And>p y.\n        \\<lbrakk>path \\<Gamma> x p y; y \\<in> B \\<Gamma>;\n         \\<And>z.\n            \\<lbrakk>x \\<noteq> y; z \\<in> set p\\<rbrakk>\n            \\<Longrightarrow> z = x \\<or>\n                              z \\<notin> TER f \\<union> TER g\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(rule \\<E>_E) blast"], ["proof (state)\nthis:\n  path \\<Gamma> x p y\n  y \\<in> B \\<Gamma>\n  \\<lbrakk>x \\<noteq> y; ?z \\<in> set p\\<rbrakk>\n  \\<Longrightarrow> ?z = x \\<or> ?z \\<notin> TER f \\<union> TER g\n\ngoal (2 subgoals):\n 1. x \\<in> SAT \\<Gamma> (f \\<frown> g)\n 2. x \\<in> SINK (f \\<frown> g)", "from rtrancl_path_distinct[OF p]"], ["proof (chain)\npicking this:\n  (\\<And>xs'.\n      \\<lbrakk>path \\<Gamma> x xs' y; distinct (x # xs');\n       set xs' \\<subseteq> set p\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis", "obtain p'\n    where p: \"path \\<Gamma> x p' y\" and p': \"set p' \\<subseteq> set p\" and distinct: \"distinct (x # p')\""], ["proof (prove)\nusing this:\n  (\\<And>xs'.\n      \\<lbrakk>path \\<Gamma> x xs' y; distinct (x # xs');\n       set xs' \\<subseteq> set p\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>p'.\n        \\<lbrakk>path \\<Gamma> x p' y; set p' \\<subseteq> set p;\n         distinct (x # p')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "."], ["proof (state)\nthis:\n  path \\<Gamma> x p' y\n  set p' \\<subseteq> set p\n  distinct (x # p')\n\ngoal (2 subgoals):\n 1. x \\<in> SAT \\<Gamma> (f \\<frown> g)\n 2. x \\<in> SINK (f \\<frown> g)", "from RF_f"], ["proof (chain)\npicking this:\n  x \\<notin> RF\\<^sup>\\<circ> (TER f)", "have \"x \\<in> SINK f\""], ["proof (prove)\nusing this:\n  x \\<notin> RF\\<^sup>\\<circ> (TER f)\n\ngoal (1 subgoal):\n 1. x \\<in> SINK f", "by(auto simp add: roofed_circ_def SINK.simps dest: waveD_OUT[OF w])"], ["proof (state)\nthis:\n  x \\<in> SINK f\n\ngoal (2 subgoals):\n 1. x \\<in> SAT \\<Gamma> (f \\<frown> g)\n 2. x \\<in> SINK (f \\<frown> g)", "thus \"x \\<in> SINK (f \\<frown> g)\""], ["proof (prove)\nusing this:\n  x \\<in> SINK f\n\ngoal (1 subgoal):\n 1. x \\<in> SINK (f \\<frown> g)", "using SINK"], ["proof (prove)\nusing this:\n  x \\<in> SINK f\n  x \\<in> SINK (g \\<upharpoonleft> \\<Gamma> / f)\n\ngoal (1 subgoal):\n 1. x \\<in> SINK (f \\<frown> g)", "by(simp add: SINK.simps d_OUT_plus_web)"], ["proof (state)\nthis:\n  x \\<in> SINK (f \\<frown> g)\n\ngoal (1 subgoal):\n 1. x \\<in> SAT \\<Gamma> (f \\<frown> g)", "show \"x \\<in> SAT \\<Gamma> (f \\<frown> g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> SAT \\<Gamma> (f \\<frown> g)", "proof(cases \"x \\<in> TER f\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<in> TER f \\<Longrightarrow> x \\<in> SAT \\<Gamma> (f \\<frown> g)\n 2. x \\<notin> TER f \\<Longrightarrow> x \\<in> SAT \\<Gamma> (f \\<frown> g)", "case True"], ["proof (state)\nthis:\n  x \\<in> TER f\n\ngoal (2 subgoals):\n 1. x \\<in> TER f \\<Longrightarrow> x \\<in> SAT \\<Gamma> (f \\<frown> g)\n 2. x \\<notin> TER f \\<Longrightarrow> x \\<in> SAT \\<Gamma> (f \\<frown> g)", "hence \"x \\<in> SAT \\<Gamma> f\""], ["proof (prove)\nusing this:\n  x \\<in> TER f\n\ngoal (1 subgoal):\n 1. x \\<in> SAT \\<Gamma> f", "by simp"], ["proof (state)\nthis:\n  x \\<in> SAT \\<Gamma> f\n\ngoal (2 subgoals):\n 1. x \\<in> TER f \\<Longrightarrow> x \\<in> SAT \\<Gamma> (f \\<frown> g)\n 2. x \\<notin> TER f \\<Longrightarrow> x \\<in> SAT \\<Gamma> (f \\<frown> g)", "moreover"], ["proof (state)\nthis:\n  x \\<in> SAT \\<Gamma> f\n\ngoal (2 subgoals):\n 1. x \\<in> TER f \\<Longrightarrow> x \\<in> SAT \\<Gamma> (f \\<frown> g)\n 2. x \\<notin> TER f \\<Longrightarrow> x \\<in> SAT \\<Gamma> (f \\<frown> g)", "have \"\\<dots> \\<subseteq> SAT \\<Gamma> (f \\<frown> g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SAT \\<Gamma> f \\<subseteq> SAT \\<Gamma> (f \\<frown> g)", "by(rule SAT_mono plus_web_greater)+"], ["proof (state)\nthis:\n  SAT \\<Gamma> f \\<subseteq> SAT \\<Gamma> (f \\<frown> g)\n\ngoal (2 subgoals):\n 1. x \\<in> TER f \\<Longrightarrow> x \\<in> SAT \\<Gamma> (f \\<frown> g)\n 2. x \\<notin> TER f \\<Longrightarrow> x \\<in> SAT \\<Gamma> (f \\<frown> g)", "ultimately"], ["proof (chain)\npicking this:\n  x \\<in> SAT \\<Gamma> f\n  SAT \\<Gamma> f \\<subseteq> SAT \\<Gamma> (f \\<frown> g)", "show ?thesis"], ["proof (prove)\nusing this:\n  x \\<in> SAT \\<Gamma> f\n  SAT \\<Gamma> f \\<subseteq> SAT \\<Gamma> (f \\<frown> g)\n\ngoal (1 subgoal):\n 1. x \\<in> SAT \\<Gamma> (f \\<frown> g)", "by blast"], ["proof (state)\nthis:\n  x \\<in> SAT \\<Gamma> (f \\<frown> g)\n\ngoal (1 subgoal):\n 1. x \\<notin> TER f \\<Longrightarrow> x \\<in> SAT \\<Gamma> (f \\<frown> g)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<notin> TER f \\<Longrightarrow> x \\<in> SAT \\<Gamma> (f \\<frown> g)", "case False"], ["proof (state)\nthis:\n  x \\<notin> TER f\n\ngoal (1 subgoal):\n 1. x \\<notin> TER f \\<Longrightarrow> x \\<in> SAT \\<Gamma> (f \\<frown> g)", "with x"], ["proof (chain)\npicking this:\n  x \\<in> \\<E> (TER f \\<union> TER g)\n  x \\<notin> TER f", "have \"x \\<in> TER g\""], ["proof (prove)\nusing this:\n  x \\<in> \\<E> (TER f \\<union> TER g)\n  x \\<notin> TER f\n\ngoal (1 subgoal):\n 1. x \\<in> TER g", "by auto"], ["proof (state)\nthis:\n  x \\<in> TER g\n\ngoal (1 subgoal):\n 1. x \\<notin> TER f \\<Longrightarrow> x \\<in> SAT \\<Gamma> (f \\<frown> g)", "from False RF_f"], ["proof (chain)\npicking this:\n  x \\<notin> TER f\n  x \\<notin> RF\\<^sup>\\<circ> (TER f)", "have \"x \\<notin> RF (TER f)\""], ["proof (prove)\nusing this:\n  x \\<notin> TER f\n  x \\<notin> RF\\<^sup>\\<circ> (TER f)\n\ngoal (1 subgoal):\n 1. x \\<notin> RF (TER f)", "by(auto simp add: roofed_circ_def)"], ["proof (state)\nthis:\n  x \\<notin> RF (TER f)\n\ngoal (1 subgoal):\n 1. x \\<notin> TER f \\<Longrightarrow> x \\<in> SAT \\<Gamma> (f \\<frown> g)", "moreover"], ["proof (state)\nthis:\n  x \\<notin> RF (TER f)\n\ngoal (1 subgoal):\n 1. x \\<notin> TER f \\<Longrightarrow> x \\<in> SAT \\<Gamma> (f \\<frown> g)", "{"], ["proof (state)\nthis:\n  x \\<notin> RF (TER f)\n\ngoal (1 subgoal):\n 1. x \\<notin> TER f \\<Longrightarrow> x \\<in> SAT \\<Gamma> (f \\<frown> g)", "fix z"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<notin> TER f \\<Longrightarrow> x \\<in> SAT \\<Gamma> (f \\<frown> g)", "assume z: \"z \\<in> RF\\<^sup>\\<circ> (TER f)\""], ["proof (state)\nthis:\n  z \\<in> RF\\<^sup>\\<circ> (TER f)\n\ngoal (1 subgoal):\n 1. x \\<notin> TER f \\<Longrightarrow> x \\<in> SAT \\<Gamma> (f \\<frown> g)", "have \"(z, x) \\<notin> \\<^bold>E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (z, x) \\<notin> \\<^bold>E", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. (z, x) \\<in> \\<^bold>E \\<Longrightarrow> False", "assume \"(z, x) \\<in> \\<^bold>E\""], ["proof (state)\nthis:\n  (z, x) \\<in> \\<^bold>E\n\ngoal (1 subgoal):\n 1. (z, x) \\<in> \\<^bold>E \\<Longrightarrow> False", "hence path': \"path \\<Gamma> z (x # p') y\""], ["proof (prove)\nusing this:\n  (z, x) \\<in> \\<^bold>E\n\ngoal (1 subgoal):\n 1. path \\<Gamma> z (x # p') y", "using p"], ["proof (prove)\nusing this:\n  (z, x) \\<in> \\<^bold>E\n  path \\<Gamma> x p' y\n\ngoal (1 subgoal):\n 1. path \\<Gamma> z (x # p') y", "by(simp add: rtrancl_path.step)"], ["proof (state)\nthis:\n  path \\<Gamma> z (x # p') y\n\ngoal (1 subgoal):\n 1. (z, x) \\<in> \\<^bold>E \\<Longrightarrow> False", "from z"], ["proof (chain)\npicking this:\n  z \\<in> RF\\<^sup>\\<circ> (TER f)", "have \"z \\<in> RF (TER f)\""], ["proof (prove)\nusing this:\n  z \\<in> RF\\<^sup>\\<circ> (TER f)\n\ngoal (1 subgoal):\n 1. z \\<in> RF (TER f)", "by(simp add: roofed_circ_def)"], ["proof (state)\nthis:\n  z \\<in> RF (TER f)\n\ngoal (1 subgoal):\n 1. (z, x) \\<in> \\<^bold>E \\<Longrightarrow> False", "from roofedD[OF this path' y] False"], ["proof (chain)\npicking this:\n  (\\<exists>z\\<in>set (x # p'). z \\<in> TER f) \\<or> z \\<in> TER f\n  x \\<notin> TER f", "consider (path) z' where  \"z' \\<in> set p'\" \"z' \\<in> TER f\" | (TER) \"z \\<in> TER f\""], ["proof (prove)\nusing this:\n  (\\<exists>z\\<in>set (x # p'). z \\<in> TER f) \\<or> z \\<in> TER f\n  x \\<notin> TER f\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>z'.\n                \\<lbrakk>z' \\<in> set p'; z' \\<in> TER f\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     z \\<in> TER f \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>\\<And>z'.\n              \\<lbrakk>z' \\<in> set p'; z' \\<in> TER f\\<rbrakk>\n              \\<Longrightarrow> ?thesis;\n   z \\<in> TER f \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (z, x) \\<in> \\<^bold>E \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<And>z'.\n              \\<lbrakk>z' \\<in> set p'; z' \\<in> TER f\\<rbrakk>\n              \\<Longrightarrow> ?thesis;\n   z \\<in> TER f \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis", "show False"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>z'.\n              \\<lbrakk>z' \\<in> set p'; z' \\<in> TER f\\<rbrakk>\n              \\<Longrightarrow> ?thesis;\n   z \\<in> TER f \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. False", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>z'.\n       \\<lbrakk>z' \\<in> set p'; z' \\<in> TER f\\<rbrakk>\n       \\<Longrightarrow> False\n 2. z \\<in> TER f \\<Longrightarrow> False", "{"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>z'.\n       \\<lbrakk>z' \\<in> set p'; z' \\<in> TER f\\<rbrakk>\n       \\<Longrightarrow> False\n 2. z \\<in> TER f \\<Longrightarrow> False", "case (path z')"], ["proof (state)\nthis:\n  z' \\<in> set p'\n  z' \\<in> TER f\n\ngoal (2 subgoals):\n 1. \\<And>z'.\n       \\<lbrakk>z' \\<in> set p'; z' \\<in> TER f\\<rbrakk>\n       \\<Longrightarrow> False\n 2. z \\<in> TER f \\<Longrightarrow> False", "with p distinct"], ["proof (chain)\npicking this:\n  path \\<Gamma> x p' y\n  distinct (x # p')\n  z' \\<in> set p'\n  z' \\<in> TER f", "have \"x \\<noteq> y\""], ["proof (prove)\nusing this:\n  path \\<Gamma> x p' y\n  distinct (x # p')\n  z' \\<in> set p'\n  z' \\<in> TER f\n\ngoal (1 subgoal):\n 1. x \\<noteq> y", "by(auto 4 3 intro: last_in_set elim: rtrancl_path.cases dest: rtrancl_path_last[symmetric])"], ["proof (state)\nthis:\n  x \\<noteq> y\n\ngoal (2 subgoals):\n 1. \\<And>z'.\n       \\<lbrakk>z' \\<in> set p'; z' \\<in> TER f\\<rbrakk>\n       \\<Longrightarrow> False\n 2. z \\<in> TER f \\<Longrightarrow> False", "from bypass[OF this, of z'] path False p'"], ["proof (chain)\npicking this:\n  z' \\<in> set p \\<Longrightarrow>\n  z' = x \\<or> z' \\<notin> TER f \\<union> TER g\n  z' \\<in> set p'\n  z' \\<in> TER f\n  x \\<notin> TER f\n  set p' \\<subseteq> set p", "show False"], ["proof (prove)\nusing this:\n  z' \\<in> set p \\<Longrightarrow>\n  z' = x \\<or> z' \\<notin> TER f \\<union> TER g\n  z' \\<in> set p'\n  z' \\<in> TER f\n  x \\<notin> TER f\n  set p' \\<subseteq> set p\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. z \\<in> TER f \\<Longrightarrow> False", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?z'2 \\<in> set p'; ?z'2 \\<in> TER f\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. z \\<in> TER f \\<Longrightarrow> False", "note that = this"], ["proof (state)\nthis:\n  \\<lbrakk>?z'2 \\<in> set p'; ?z'2 \\<in> TER f\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. z \\<in> TER f \\<Longrightarrow> False", "case TER"], ["proof (state)\nthis:\n  z \\<in> TER f\n\ngoal (1 subgoal):\n 1. z \\<in> TER f \\<Longrightarrow> False", "with z"], ["proof (chain)\npicking this:\n  z \\<in> RF\\<^sup>\\<circ> (TER f)\n  z \\<in> TER f", "have \"\\<not> essential \\<Gamma> (B \\<Gamma>) (TER f) z\""], ["proof (prove)\nusing this:\n  z \\<in> RF\\<^sup>\\<circ> (TER f)\n  z \\<in> TER f\n\ngoal (1 subgoal):\n 1. \\<not> essential \\<Gamma> (B \\<Gamma>) (TER f) z", "by(simp add: roofed_circ_def)"], ["proof (state)\nthis:\n  \\<not> essential \\<Gamma> (B \\<Gamma>) (TER f) z\n\ngoal (1 subgoal):\n 1. z \\<in> TER f \\<Longrightarrow> False", "from not_essentialD[OF this path' y] False"], ["proof (chain)\npicking this:\n  z \\<noteq> y \\<and>\n  (\\<exists>za\\<in>set (x # p'). za \\<noteq> z \\<and> za \\<in> TER f)\n  x \\<notin> TER f", "obtain z' where \"z' \\<in> set p'\" \"z' \\<in> TER f\""], ["proof (prove)\nusing this:\n  z \\<noteq> y \\<and>\n  (\\<exists>za\\<in>set (x # p'). za \\<noteq> z \\<and> za \\<in> TER f)\n  x \\<notin> TER f\n\ngoal (1 subgoal):\n 1. (\\<And>z'.\n        \\<lbrakk>z' \\<in> set p'; z' \\<in> TER f\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  z' \\<in> set p'\n  z' \\<in> TER f\n\ngoal (1 subgoal):\n 1. z \\<in> TER f \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  z' \\<in> set p'\n  z' \\<in> TER f\n\ngoal (1 subgoal):\n 1. False", "by(rule that)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (z, x) \\<notin> \\<^bold>E\n\ngoal (1 subgoal):\n 1. x \\<notin> TER f \\<Longrightarrow> x \\<in> SAT \\<Gamma> (f \\<frown> g)", "}"], ["proof (state)\nthis:\n  ?z2 \\<in> RF\\<^sup>\\<circ> (TER f) \\<Longrightarrow>\n  (?z2, x) \\<notin> \\<^bold>E\n\ngoal (1 subgoal):\n 1. x \\<notin> TER f \\<Longrightarrow> x \\<in> SAT \\<Gamma> (f \\<frown> g)", "ultimately"], ["proof (chain)\npicking this:\n  x \\<notin> RF (TER f)\n  ?z2 \\<in> RF\\<^sup>\\<circ> (TER f) \\<Longrightarrow>\n  (?z2, x) \\<notin> \\<^bold>E", "have \"d_IN ?g x = d_IN g x\""], ["proof (prove)\nusing this:\n  x \\<notin> RF (TER f)\n  ?z2 \\<in> RF\\<^sup>\\<circ> (TER f) \\<Longrightarrow>\n  (?z2, x) \\<notin> \\<^bold>E\n\ngoal (1 subgoal):\n 1. d_IN (g \\<upharpoonleft> \\<Gamma> / f) x = d_IN g x", "unfolding d_IN_def"], ["proof (prove)\nusing this:\n  x \\<notin> RF (TER f)\n  ?z2 \\<in> RF\\<^sup>\\<circ> (TER f) \\<Longrightarrow>\n  (?z2, x) \\<notin> \\<^bold>E\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ xa. (g \\<upharpoonleft> \\<Gamma> / f) (xa, x)) =\n    (\\<Sum>\\<^sup>+ xa. g (xa, x))", "by(intro nn_integral_cong)(clarsimp split: split_indicator simp add: currentD_outside[OF g])"], ["proof (state)\nthis:\n  d_IN (g \\<upharpoonleft> \\<Gamma> / f) x = d_IN g x\n\ngoal (1 subgoal):\n 1. x \\<notin> TER f \\<Longrightarrow> x \\<in> SAT \\<Gamma> (f \\<frown> g)", "hence \"d_IN (f \\<frown> g) x \\<ge> d_IN g x\""], ["proof (prove)\nusing this:\n  d_IN (g \\<upharpoonleft> \\<Gamma> / f) x = d_IN g x\n\ngoal (1 subgoal):\n 1. d_IN g x \\<le> d_IN (f \\<frown> g) x", "by(simp add: d_IN_plus_web)"], ["proof (state)\nthis:\n  d_IN g x \\<le> d_IN (f \\<frown> g) x\n\ngoal (1 subgoal):\n 1. x \\<notin> TER f \\<Longrightarrow> x \\<in> SAT \\<Gamma> (f \\<frown> g)", "with \\<open>x \\<in> TER g\\<close>"], ["proof (chain)\npicking this:\n  x \\<in> TER g\n  d_IN g x \\<le> d_IN (f \\<frown> g) x", "show ?thesis"], ["proof (prove)\nusing this:\n  x \\<in> TER g\n  d_IN g x \\<le> d_IN (f \\<frown> g) x\n\ngoal (1 subgoal):\n 1. x \\<in> SAT \\<Gamma> (f \\<frown> g)", "by(auto elim!: SAT.cases intro: SAT.intros)"], ["proof (state)\nthis:\n  x \\<in> SAT \\<Gamma> (f \\<frown> g)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x \\<in> SAT \\<Gamma> (f \\<frown> g)\n\ngoal:\nNo subgoals!", "qed"], ["", "qualified"], ["", "lemma SINK_TER_in'':\n  assumes \"\\<And>x. x \\<notin> RF (TER g) \\<Longrightarrow> d_OUT g x = 0\"\n  shows \"x \\<in> SINK g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> SINK g", "using RF_g"], ["proof (prove)\nusing this:\n  x \\<notin> RF\\<^sup>\\<circ> (TER g)\n\ngoal (1 subgoal):\n 1. x \\<in> SINK g", "by(auto simp add: roofed_circ_def SINK.simps assms)"], ["", "end"], ["", "lemma wave_plus: \"wave (quotient_web \\<Gamma> f) (g \\<upharpoonleft> \\<Gamma> / f) \\<Longrightarrow> wave \\<Gamma> (f \\<frown> g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wave (quotient_web \\<Gamma> f)\n     (g \\<upharpoonleft> \\<Gamma> / f) \\<Longrightarrow>\n    wave \\<Gamma> (f \\<frown> g)", "using f w"], ["proof (prove)\nusing this:\n  current \\<Gamma> f\n  wave \\<Gamma> f\n\ngoal (1 subgoal):\n 1. wave (quotient_web \\<Gamma> f)\n     (g \\<upharpoonleft> \\<Gamma> / f) \\<Longrightarrow>\n    wave \\<Gamma> (f \\<frown> g)", "by(rule wave_plus_current)(rule current_restrict_current[OF w g])"], ["", "lemma TER_plus_web'':\n  assumes \"\\<And>x. x \\<notin> RF (TER g) \\<Longrightarrow> d_OUT g x = 0\"\n  shows \"\\<E> (TER f \\<union> TER g) \\<subseteq> TER (f \\<frown> g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<E> (TER f \\<union> TER g) \\<subseteq> TER (f \\<frown> g)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<E> (TER f \\<union> TER g) \\<Longrightarrow>\n       x \\<in> TER (f \\<frown> g)", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<E> (TER f \\<union> TER g) \\<Longrightarrow>\n       x \\<in> TER (f \\<frown> g)", "assume *: \"x \\<in> \\<E> (TER f \\<union> TER g)\""], ["proof (state)\nthis:\n  x \\<in> \\<E> (TER f \\<union> TER g)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<E> (TER f \\<union> TER g) \\<Longrightarrow>\n       x \\<in> TER (f \\<frown> g)", "moreover"], ["proof (state)\nthis:\n  x \\<in> \\<E> (TER f \\<union> TER g)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<E> (TER f \\<union> TER g) \\<Longrightarrow>\n       x \\<in> TER (f \\<frown> g)", "have \"x \\<in> SINK (g \\<upharpoonleft> \\<Gamma> / f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> SINK (g \\<upharpoonleft> \\<Gamma> / f)", "by(rule in_SINK_restrict_current)(rule MFMC_Unbounded.SINK_TER_in''[OF f w g * assms])"], ["proof (state)\nthis:\n  x \\<in> SINK (g \\<upharpoonleft> \\<Gamma> / f)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<E> (TER f \\<union> TER g) \\<Longrightarrow>\n       x \\<in> TER (f \\<frown> g)", "ultimately"], ["proof (chain)\npicking this:\n  x \\<in> \\<E> (TER f \\<union> TER g)\n  x \\<in> SINK (g \\<upharpoonleft> \\<Gamma> / f)", "show \"x \\<in> TER (f \\<frown> g)\""], ["proof (prove)\nusing this:\n  x \\<in> \\<E> (TER f \\<union> TER g)\n  x \\<in> SINK (g \\<upharpoonleft> \\<Gamma> / f)\n\ngoal (1 subgoal):\n 1. x \\<in> TER (f \\<frown> g)", "by(rule TER_plus_web_aux)"], ["proof (state)\nthis:\n  x \\<in> TER (f \\<frown> g)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma TER_plus_web': \"wave \\<Gamma> g \\<Longrightarrow> \\<E> (TER f \\<union> TER g) \\<subseteq> TER (f \\<frown> g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wave \\<Gamma> g \\<Longrightarrow>\n    \\<E> (TER f \\<union> TER g) \\<subseteq> TER (f \\<frown> g)", "by(rule TER_plus_web'')(rule waveD_OUT)"], ["", "lemma wave_plus': \"wave \\<Gamma> g \\<Longrightarrow> wave \\<Gamma> (f \\<frown> g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wave \\<Gamma> g \\<Longrightarrow> wave \\<Gamma> (f \\<frown> g)", "by(rule wave_plus)(rule wave_restrict_current[OF f w g])"], ["", "end"], ["", "lemma RF_TER_plus_web:\n  fixes \\<Gamma> (structure)\n  assumes f: \"current \\<Gamma> f\"\n  and w: \"wave \\<Gamma> f\"\n  and g: \"current \\<Gamma> g\"\n  and w': \"wave \\<Gamma> g\"\n  shows \"RF (TER (f \\<frown> g)) = RF (TER f \\<union> TER g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RF (TER (f \\<frown> g)) = RF (TER f \\<union> TER g)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. RF (TER (f \\<frown> g)) \\<subseteq> RF (TER f \\<union> TER g)\n 2. RF (TER f \\<union> TER g) \\<subseteq> RF (TER (f \\<frown> g))", "have \"RF (\\<E> (TER f \\<union> TER g)) \\<subseteq> RF (TER (f \\<frown> g))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RF (\\<E> (TER f \\<union> TER g)) \\<subseteq> RF (TER (f \\<frown> g))", "by(rule roofed_mono)(rule TER_plus_web'[OF f w g w'])"], ["proof (state)\nthis:\n  RF (\\<E> (TER f \\<union> TER g)) \\<subseteq> RF (TER (f \\<frown> g))\n\ngoal (2 subgoals):\n 1. RF (TER (f \\<frown> g)) \\<subseteq> RF (TER f \\<union> TER g)\n 2. RF (TER f \\<union> TER g) \\<subseteq> RF (TER (f \\<frown> g))", "also"], ["proof (state)\nthis:\n  RF (\\<E> (TER f \\<union> TER g)) \\<subseteq> RF (TER (f \\<frown> g))\n\ngoal (2 subgoals):\n 1. RF (TER (f \\<frown> g)) \\<subseteq> RF (TER f \\<union> TER g)\n 2. RF (TER f \\<union> TER g) \\<subseteq> RF (TER (f \\<frown> g))", "have \"RF (\\<E> (TER f \\<union> TER g)) = RF (TER f \\<union> TER g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RF (\\<E> (TER f \\<union> TER g)) = RF (TER f \\<union> TER g)", "by(rule RF_essential)"], ["proof (state)\nthis:\n  RF (\\<E> (TER f \\<union> TER g)) = RF (TER f \\<union> TER g)\n\ngoal (2 subgoals):\n 1. RF (TER (f \\<frown> g)) \\<subseteq> RF (TER f \\<union> TER g)\n 2. RF (TER f \\<union> TER g) \\<subseteq> RF (TER (f \\<frown> g))", "finally"], ["proof (chain)\npicking this:\n  RF (TER f \\<union> TER g) \\<subseteq> RF (TER (f \\<frown> g))", "show \"\\<dots> \\<subseteq> RF (TER (f \\<frown> g))\""], ["proof (prove)\nusing this:\n  RF (TER f \\<union> TER g) \\<subseteq> RF (TER (f \\<frown> g))\n\ngoal (1 subgoal):\n 1. RF (TER f \\<union> TER g) \\<subseteq> RF (TER (f \\<frown> g))", "."], ["proof (state)\nthis:\n  RF (TER f \\<union> TER g) \\<subseteq> RF (TER (f \\<frown> g))\n\ngoal (1 subgoal):\n 1. RF (TER (f \\<frown> g)) \\<subseteq> RF (TER f \\<union> TER g)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. RF (TER (f \\<frown> g)) \\<subseteq> RF (TER f \\<union> TER g)", "have fg: \"current \\<Gamma> (f \\<frown> g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. current \\<Gamma> (f \\<frown> g)", "using f w g"], ["proof (prove)\nusing this:\n  current \\<Gamma> f\n  wave \\<Gamma> f\n  current \\<Gamma> g\n\ngoal (1 subgoal):\n 1. current \\<Gamma> (f \\<frown> g)", "by(rule current_plus_web)"], ["proof (state)\nthis:\n  current \\<Gamma> (f \\<frown> g)\n\ngoal (1 subgoal):\n 1. RF (TER (f \\<frown> g)) \\<subseteq> RF (TER f \\<union> TER g)", "show \"RF (TER (f \\<frown> g)) \\<subseteq> RF (TER f \\<union> TER g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RF (TER (f \\<frown> g)) \\<subseteq> RF (TER f \\<union> TER g)", "proof(intro subsetI roofedI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x p y.\n       \\<lbrakk>x \\<in> RF (TER (f \\<frown> g)); path \\<Gamma> x p y;\n        y \\<in> B \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>z\\<in>set p.\n                             z \\<in> TER f \\<union> TER g) \\<or>\n                         x \\<in> TER f \\<union> TER g", "fix x p y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x p y.\n       \\<lbrakk>x \\<in> RF (TER (f \\<frown> g)); path \\<Gamma> x p y;\n        y \\<in> B \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>z\\<in>set p.\n                             z \\<in> TER f \\<union> TER g) \\<or>\n                         x \\<in> TER f \\<union> TER g", "assume RF: \"x \\<in> RF (TER (f \\<frown> g))\" and p: \"path \\<Gamma> x p y\" and y: \"y \\<in> B \\<Gamma>\""], ["proof (state)\nthis:\n  x \\<in> RF (TER (f \\<frown> g))\n  path \\<Gamma> x p y\n  y \\<in> B \\<Gamma>\n\ngoal (1 subgoal):\n 1. \\<And>x p y.\n       \\<lbrakk>x \\<in> RF (TER (f \\<frown> g)); path \\<Gamma> x p y;\n        y \\<in> B \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>z\\<in>set p.\n                             z \\<in> TER f \\<union> TER g) \\<or>\n                         x \\<in> TER f \\<union> TER g", "from roofedD[OF RF p y]"], ["proof (chain)\npicking this:\n  (\\<exists>z\\<in>set p. z \\<in> TER (f \\<frown> g)) \\<or>\n  x \\<in> TER (f \\<frown> g)", "obtain z where z: \"z \\<in> set (x # p)\" and TER: \"z \\<in> TER (f \\<frown> g)\""], ["proof (prove)\nusing this:\n  (\\<exists>z\\<in>set p. z \\<in> TER (f \\<frown> g)) \\<or>\n  x \\<in> TER (f \\<frown> g)\n\ngoal (1 subgoal):\n 1. (\\<And>z.\n        \\<lbrakk>z \\<in> set (x # p); z \\<in> TER (f \\<frown> g)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  z \\<in> set (x # p)\n  z \\<in> TER (f \\<frown> g)\n\ngoal (1 subgoal):\n 1. \\<And>x p y.\n       \\<lbrakk>x \\<in> RF (TER (f \\<frown> g)); path \\<Gamma> x p y;\n        y \\<in> B \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>z\\<in>set p.\n                             z \\<in> TER f \\<union> TER g) \\<or>\n                         x \\<in> TER f \\<union> TER g", "from TER"], ["proof (chain)\npicking this:\n  z \\<in> TER (f \\<frown> g)", "have SINK: \"z \\<in> SINK f\""], ["proof (prove)\nusing this:\n  z \\<in> TER (f \\<frown> g)\n\ngoal (1 subgoal):\n 1. z \\<in> SINK f", "by(auto simp add: SINK.simps d_OUT_plus_web add_eq_0_iff_both_eq_0)"], ["proof (state)\nthis:\n  z \\<in> SINK f\n\ngoal (1 subgoal):\n 1. \\<And>x p y.\n       \\<lbrakk>x \\<in> RF (TER (f \\<frown> g)); path \\<Gamma> x p y;\n        y \\<in> B \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>z\\<in>set p.\n                             z \\<in> TER f \\<union> TER g) \\<or>\n                         x \\<in> TER f \\<union> TER g", "from TER"], ["proof (chain)\npicking this:\n  z \\<in> TER (f \\<frown> g)", "have \"z \\<in> SAT \\<Gamma> (f \\<frown> g)\""], ["proof (prove)\nusing this:\n  z \\<in> TER (f \\<frown> g)\n\ngoal (1 subgoal):\n 1. z \\<in> SAT \\<Gamma> (f \\<frown> g)", "by simp"], ["proof (state)\nthis:\n  z \\<in> SAT \\<Gamma> (f \\<frown> g)\n\ngoal (1 subgoal):\n 1. \\<And>x p y.\n       \\<lbrakk>x \\<in> RF (TER (f \\<frown> g)); path \\<Gamma> x p y;\n        y \\<in> B \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>z\\<in>set p.\n                             z \\<in> TER f \\<union> TER g) \\<or>\n                         x \\<in> TER f \\<union> TER g", "hence SAT: \"z \\<in> SAT \\<Gamma> f \\<union> SAT \\<Gamma> g\""], ["proof (prove)\nusing this:\n  z \\<in> SAT \\<Gamma> (f \\<frown> g)\n\ngoal (1 subgoal):\n 1. z \\<in> SAT \\<Gamma> f \\<union> SAT \\<Gamma> g", "by(cases \"z \\<in> RF (TER f)\")(auto simp add: currentD_SAT[OF f] currentD_SAT[OF g] currentD_SAT[OF fg] d_IN_plus_web d_IN_restrict_current_outside restrict_current_IN_not_RF[OF g] wave_not_RF_IN_zero[OF f w])"], ["proof (state)\nthis:\n  z \\<in> SAT \\<Gamma> f \\<union> SAT \\<Gamma> g\n\ngoal (1 subgoal):\n 1. \\<And>x p y.\n       \\<lbrakk>x \\<in> RF (TER (f \\<frown> g)); path \\<Gamma> x p y;\n        y \\<in> B \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>z\\<in>set p.\n                             z \\<in> TER f \\<union> TER g) \\<or>\n                         x \\<in> TER f \\<union> TER g", "show \"(\\<exists>z\\<in>set p. z \\<in> TER f \\<union> TER g) \\<or> x \\<in> TER f \\<union> TER g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>z\\<in>set p. z \\<in> TER f \\<union> TER g) \\<or>\n    x \\<in> TER f \\<union> TER g", "proof(cases \"z \\<in> RF (TER g)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. z \\<in> RF (TER g) \\<Longrightarrow>\n    (\\<exists>z\\<in>set p. z \\<in> TER f \\<union> TER g) \\<or>\n    x \\<in> TER f \\<union> TER g\n 2. z \\<notin> RF (TER g) \\<Longrightarrow>\n    (\\<exists>z\\<in>set p. z \\<in> TER f \\<union> TER g) \\<or>\n    x \\<in> TER f \\<union> TER g", "case False"], ["proof (state)\nthis:\n  z \\<notin> RF (TER g)\n\ngoal (2 subgoals):\n 1. z \\<in> RF (TER g) \\<Longrightarrow>\n    (\\<exists>z\\<in>set p. z \\<in> TER f \\<union> TER g) \\<or>\n    x \\<in> TER f \\<union> TER g\n 2. z \\<notin> RF (TER g) \\<Longrightarrow>\n    (\\<exists>z\\<in>set p. z \\<in> TER f \\<union> TER g) \\<or>\n    x \\<in> TER f \\<union> TER g", "hence \"z \\<in> SINK g\""], ["proof (prove)\nusing this:\n  z \\<notin> RF (TER g)\n\ngoal (1 subgoal):\n 1. z \\<in> SINK g", "by(simp add: SINK.simps waveD_OUT[OF w'])"], ["proof (state)\nthis:\n  z \\<in> SINK g\n\ngoal (2 subgoals):\n 1. z \\<in> RF (TER g) \\<Longrightarrow>\n    (\\<exists>z\\<in>set p. z \\<in> TER f \\<union> TER g) \\<or>\n    x \\<in> TER f \\<union> TER g\n 2. z \\<notin> RF (TER g) \\<Longrightarrow>\n    (\\<exists>z\\<in>set p. z \\<in> TER f \\<union> TER g) \\<or>\n    x \\<in> TER f \\<union> TER g", "with SINK SAT"], ["proof (chain)\npicking this:\n  z \\<in> SINK f\n  z \\<in> SAT \\<Gamma> f \\<union> SAT \\<Gamma> g\n  z \\<in> SINK g", "have \"z \\<in> TER f \\<union> TER g\""], ["proof (prove)\nusing this:\n  z \\<in> SINK f\n  z \\<in> SAT \\<Gamma> f \\<union> SAT \\<Gamma> g\n  z \\<in> SINK g\n\ngoal (1 subgoal):\n 1. z \\<in> TER f \\<union> TER g", "by auto"], ["proof (state)\nthis:\n  z \\<in> TER f \\<union> TER g\n\ngoal (2 subgoals):\n 1. z \\<in> RF (TER g) \\<Longrightarrow>\n    (\\<exists>z\\<in>set p. z \\<in> TER f \\<union> TER g) \\<or>\n    x \\<in> TER f \\<union> TER g\n 2. z \\<notin> RF (TER g) \\<Longrightarrow>\n    (\\<exists>z\\<in>set p. z \\<in> TER f \\<union> TER g) \\<or>\n    x \\<in> TER f \\<union> TER g", "thus ?thesis"], ["proof (prove)\nusing this:\n  z \\<in> TER f \\<union> TER g\n\ngoal (1 subgoal):\n 1. (\\<exists>z\\<in>set p. z \\<in> TER f \\<union> TER g) \\<or>\n    x \\<in> TER f \\<union> TER g", "using z"], ["proof (prove)\nusing this:\n  z \\<in> TER f \\<union> TER g\n  z \\<in> set (x # p)\n\ngoal (1 subgoal):\n 1. (\\<exists>z\\<in>set p. z \\<in> TER f \\<union> TER g) \\<or>\n    x \\<in> TER f \\<union> TER g", "by auto"], ["proof (state)\nthis:\n  (\\<exists>z\\<in>set p. z \\<in> TER f \\<union> TER g) \\<or>\n  x \\<in> TER f \\<union> TER g\n\ngoal (1 subgoal):\n 1. z \\<in> RF (TER g) \\<Longrightarrow>\n    (\\<exists>z\\<in>set p. z \\<in> TER f \\<union> TER g) \\<or>\n    x \\<in> TER f \\<union> TER g", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. z \\<in> RF (TER g) \\<Longrightarrow>\n    (\\<exists>z\\<in>set p. z \\<in> TER f \\<union> TER g) \\<or>\n    x \\<in> TER f \\<union> TER g", "case True"], ["proof (state)\nthis:\n  z \\<in> RF (TER g)\n\ngoal (1 subgoal):\n 1. z \\<in> RF (TER g) \\<Longrightarrow>\n    (\\<exists>z\\<in>set p. z \\<in> TER f \\<union> TER g) \\<or>\n    x \\<in> TER f \\<union> TER g", "from split_list[OF z]"], ["proof (chain)\npicking this:\n  \\<exists>ys zs. x # p = ys @ z # zs", "obtain ys zs where split: \"x # p = ys @ z # zs\""], ["proof (prove)\nusing this:\n  \\<exists>ys zs. x # p = ys @ z # zs\n\ngoal (1 subgoal):\n 1. (\\<And>ys zs.\n        x # p = ys @ z # zs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  x # p = ys @ z # zs\n\ngoal (1 subgoal):\n 1. z \\<in> RF (TER g) \\<Longrightarrow>\n    (\\<exists>z\\<in>set p. z \\<in> TER f \\<union> TER g) \\<or>\n    x \\<in> TER f \\<union> TER g", "with p"], ["proof (chain)\npicking this:\n  path \\<Gamma> x p y\n  x # p = ys @ z # zs", "have \"path \\<Gamma> z zs y\""], ["proof (prove)\nusing this:\n  path \\<Gamma> x p y\n  x # p = ys @ z # zs\n\ngoal (1 subgoal):\n 1. path \\<Gamma> z zs y", "by(auto elim: rtrancl_path_appendE simp add: Cons_eq_append_conv)"], ["proof (state)\nthis:\n  path \\<Gamma> z zs y\n\ngoal (1 subgoal):\n 1. z \\<in> RF (TER g) \\<Longrightarrow>\n    (\\<exists>z\\<in>set p. z \\<in> TER f \\<union> TER g) \\<or>\n    x \\<in> TER f \\<union> TER g", "from roofedD[OF True this y] split"], ["proof (chain)\npicking this:\n  (\\<exists>z\\<in>set zs. z \\<in> TER g) \\<or> z \\<in> TER g\n  x # p = ys @ z # zs", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<exists>z\\<in>set zs. z \\<in> TER g) \\<or> z \\<in> TER g\n  x # p = ys @ z # zs\n\ngoal (1 subgoal):\n 1. (\\<exists>z\\<in>set p. z \\<in> TER f \\<union> TER g) \\<or>\n    x \\<in> TER f \\<union> TER g", "by(auto simp add: Cons_eq_append_conv)"], ["proof (state)\nthis:\n  (\\<exists>z\\<in>set p. z \\<in> TER f \\<union> TER g) \\<or>\n  x \\<in> TER f \\<union> TER g\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<exists>z\\<in>set p. z \\<in> TER f \\<union> TER g) \\<or>\n  x \\<in> TER f \\<union> TER g\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  RF (TER (f \\<frown> g)) \\<subseteq> RF (TER f \\<union> TER g)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma RF_TER_Sup:\n  fixes \\<Gamma> (structure)\n  assumes f: \"\\<And>f. f \\<in> Y \\<Longrightarrow> current \\<Gamma> f\"\n  and w: \"\\<And>f. f \\<in> Y \\<Longrightarrow> wave \\<Gamma> f\"\n  and Y: \"Complete_Partial_Order.chain (\\<le>) Y\" \"Y \\<noteq> {}\" \"countable (support_flow (Sup Y))\"\n  shows \"RF (TER (Sup Y)) = RF (\\<Union>f\\<in>Y. TER f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RF (TER (\\<Squnion> Y)) = RF (\\<Union> (TER ` Y))", "proof(rule set_eqI iffI)+"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> RF (TER (\\<Squnion> Y)) \\<Longrightarrow>\n       x \\<in> RF (\\<Union> (TER ` Y))\n 2. \\<And>x.\n       x \\<in> RF (\\<Union> (TER ` Y)) \\<Longrightarrow>\n       x \\<in> RF (TER (\\<Squnion> Y))", "fix x"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> RF (TER (\\<Squnion> Y)) \\<Longrightarrow>\n       x \\<in> RF (\\<Union> (TER ` Y))\n 2. \\<And>x.\n       x \\<in> RF (\\<Union> (TER ` Y)) \\<Longrightarrow>\n       x \\<in> RF (TER (\\<Squnion> Y))", "assume x: \"x \\<in> RF (TER (Sup Y))\""], ["proof (state)\nthis:\n  x \\<in> RF (TER (\\<Squnion> Y))\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> RF (TER (\\<Squnion> Y)) \\<Longrightarrow>\n       x \\<in> RF (\\<Union> (TER ` Y))\n 2. \\<And>x.\n       x \\<in> RF (\\<Union> (TER ` Y)) \\<Longrightarrow>\n       x \\<in> RF (TER (\\<Squnion> Y))", "have \"x \\<in> RF (RF (\\<Union>f\\<in>Y. TER f))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> RF (RF (\\<Union> (TER ` Y)))", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p y.\n       \\<lbrakk>path \\<Gamma> x p y; y \\<in> B \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>z\\<in>set p.\n                             z \\<in> RF (\\<Union> (TER ` Y))) \\<or>\n                         x \\<in> RF (\\<Union> (TER ` Y))", "fix p y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p y.\n       \\<lbrakk>path \\<Gamma> x p y; y \\<in> B \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>z\\<in>set p.\n                             z \\<in> RF (\\<Union> (TER ` Y))) \\<or>\n                         x \\<in> RF (\\<Union> (TER ` Y))", "assume p: \"path \\<Gamma> x p y\" and y: \"y \\<in> B \\<Gamma>\""], ["proof (state)\nthis:\n  path \\<Gamma> x p y\n  y \\<in> B \\<Gamma>\n\ngoal (1 subgoal):\n 1. \\<And>p y.\n       \\<lbrakk>path \\<Gamma> x p y; y \\<in> B \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>z\\<in>set p.\n                             z \\<in> RF (\\<Union> (TER ` Y))) \\<or>\n                         x \\<in> RF (\\<Union> (TER ` Y))", "from roofedD[OF x p y]"], ["proof (chain)\npicking this:\n  (\\<exists>z\\<in>set p. z \\<in> TER (\\<Squnion> Y)) \\<or>\n  x \\<in> TER (\\<Squnion> Y)", "obtain z where z: \"z \\<in> set (x # p)\" and TER: \"z \\<in> TER (Sup Y)\""], ["proof (prove)\nusing this:\n  (\\<exists>z\\<in>set p. z \\<in> TER (\\<Squnion> Y)) \\<or>\n  x \\<in> TER (\\<Squnion> Y)\n\ngoal (1 subgoal):\n 1. (\\<And>z.\n        \\<lbrakk>z \\<in> set (x # p); z \\<in> TER (\\<Squnion> Y)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  z \\<in> set (x # p)\n  z \\<in> TER (\\<Squnion> Y)\n\ngoal (1 subgoal):\n 1. \\<And>p y.\n       \\<lbrakk>path \\<Gamma> x p y; y \\<in> B \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>z\\<in>set p.\n                             z \\<in> RF (\\<Union> (TER ` Y))) \\<or>\n                         x \\<in> RF (\\<Union> (TER ` Y))", "from TER"], ["proof (chain)\npicking this:\n  z \\<in> TER (\\<Squnion> Y)", "have SINK: \"z \\<in> SINK f\" if \"f \\<in> Y\" for f"], ["proof (prove)\nusing this:\n  z \\<in> TER (\\<Squnion> Y)\n\ngoal (1 subgoal):\n 1. z \\<in> SINK f", "using that"], ["proof (prove)\nusing this:\n  z \\<in> TER (\\<Squnion> Y)\n  f \\<in> Y\n\ngoal (1 subgoal):\n 1. z \\<in> SINK f", "by(auto simp add: SINK_Sup[OF Y])"], ["proof (state)\nthis:\n  ?f \\<in> Y \\<Longrightarrow> z \\<in> SINK ?f\n\ngoal (1 subgoal):\n 1. \\<And>p y.\n       \\<lbrakk>path \\<Gamma> x p y; y \\<in> B \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>z\\<in>set p.\n                             z \\<in> RF (\\<Union> (TER ` Y))) \\<or>\n                         x \\<in> RF (\\<Union> (TER ` Y))", "from Y(2)"], ["proof (chain)\npicking this:\n  Y \\<noteq> {}", "obtain f where y: \"f \\<in> Y\""], ["proof (prove)\nusing this:\n  Y \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>f. f \\<in> Y \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by blast"], ["proof (state)\nthis:\n  f \\<in> Y\n\ngoal (1 subgoal):\n 1. \\<And>p y.\n       \\<lbrakk>path \\<Gamma> x p y; y \\<in> B \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>z\\<in>set p.\n                             z \\<in> RF (\\<Union> (TER ` Y))) \\<or>\n                         x \\<in> RF (\\<Union> (TER ` Y))", "show \"(\\<exists>z\\<in>set p. z \\<in> RF (\\<Union>f\\<in>Y. TER f)) \\<or> x \\<in> RF (\\<Union>f\\<in>Y. TER f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>z\\<in>set p. z \\<in> RF (\\<Union> (TER ` Y))) \\<or>\n    x \\<in> RF (\\<Union> (TER ` Y))", "proof(cases \"\\<exists>f\\<in>Y. z \\<in> RF (TER f)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>f\\<in>Y. z \\<in> RF (TER f) \\<Longrightarrow>\n    (\\<exists>z\\<in>set p. z \\<in> RF (\\<Union> (TER ` Y))) \\<or>\n    x \\<in> RF (\\<Union> (TER ` Y))\n 2. \\<not> (\\<exists>f\\<in>Y. z \\<in> RF (TER f)) \\<Longrightarrow>\n    (\\<exists>z\\<in>set p. z \\<in> RF (\\<Union> (TER ` Y))) \\<or>\n    x \\<in> RF (\\<Union> (TER ` Y))", "case True"], ["proof (state)\nthis:\n  \\<exists>f\\<in>Y. z \\<in> RF (TER f)\n\ngoal (2 subgoals):\n 1. \\<exists>f\\<in>Y. z \\<in> RF (TER f) \\<Longrightarrow>\n    (\\<exists>z\\<in>set p. z \\<in> RF (\\<Union> (TER ` Y))) \\<or>\n    x \\<in> RF (\\<Union> (TER ` Y))\n 2. \\<not> (\\<exists>f\\<in>Y. z \\<in> RF (TER f)) \\<Longrightarrow>\n    (\\<exists>z\\<in>set p. z \\<in> RF (\\<Union> (TER ` Y))) \\<or>\n    x \\<in> RF (\\<Union> (TER ` Y))", "then"], ["proof (chain)\npicking this:\n  \\<exists>f\\<in>Y. z \\<in> RF (TER f)", "obtain f where fY: \"f \\<in> Y\" and zf: \"z \\<in> RF (TER f)\""], ["proof (prove)\nusing this:\n  \\<exists>f\\<in>Y. z \\<in> RF (TER f)\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        \\<lbrakk>f \\<in> Y; z \\<in> RF (TER f)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  f \\<in> Y\n  z \\<in> RF (TER f)\n\ngoal (2 subgoals):\n 1. \\<exists>f\\<in>Y. z \\<in> RF (TER f) \\<Longrightarrow>\n    (\\<exists>z\\<in>set p. z \\<in> RF (\\<Union> (TER ` Y))) \\<or>\n    x \\<in> RF (\\<Union> (TER ` Y))\n 2. \\<not> (\\<exists>f\\<in>Y. z \\<in> RF (TER f)) \\<Longrightarrow>\n    (\\<exists>z\\<in>set p. z \\<in> RF (\\<Union> (TER ` Y))) \\<or>\n    x \\<in> RF (\\<Union> (TER ` Y))", "from zf"], ["proof (chain)\npicking this:\n  z \\<in> RF (TER f)", "have \"z \\<in> RF (\\<Union>f\\<in>Y. TER f)\""], ["proof (prove)\nusing this:\n  z \\<in> RF (TER f)\n\ngoal (1 subgoal):\n 1. z \\<in> RF (\\<Union> (TER ` Y))", "by(rule in_roofed_mono)(auto intro: fY)"], ["proof (state)\nthis:\n  z \\<in> RF (\\<Union> (TER ` Y))\n\ngoal (2 subgoals):\n 1. \\<exists>f\\<in>Y. z \\<in> RF (TER f) \\<Longrightarrow>\n    (\\<exists>z\\<in>set p. z \\<in> RF (\\<Union> (TER ` Y))) \\<or>\n    x \\<in> RF (\\<Union> (TER ` Y))\n 2. \\<not> (\\<exists>f\\<in>Y. z \\<in> RF (TER f)) \\<Longrightarrow>\n    (\\<exists>z\\<in>set p. z \\<in> RF (\\<Union> (TER ` Y))) \\<or>\n    x \\<in> RF (\\<Union> (TER ` Y))", "with z"], ["proof (chain)\npicking this:\n  z \\<in> set (x # p)\n  z \\<in> RF (\\<Union> (TER ` Y))", "show ?thesis"], ["proof (prove)\nusing this:\n  z \\<in> set (x # p)\n  z \\<in> RF (\\<Union> (TER ` Y))\n\ngoal (1 subgoal):\n 1. (\\<exists>z\\<in>set p. z \\<in> RF (\\<Union> (TER ` Y))) \\<or>\n    x \\<in> RF (\\<Union> (TER ` Y))", "by auto"], ["proof (state)\nthis:\n  (\\<exists>z\\<in>set p. z \\<in> RF (\\<Union> (TER ` Y))) \\<or>\n  x \\<in> RF (\\<Union> (TER ` Y))\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>f\\<in>Y. z \\<in> RF (TER f)) \\<Longrightarrow>\n    (\\<exists>z\\<in>set p. z \\<in> RF (\\<Union> (TER ` Y))) \\<or>\n    x \\<in> RF (\\<Union> (TER ` Y))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>f\\<in>Y. z \\<in> RF (TER f)) \\<Longrightarrow>\n    (\\<exists>z\\<in>set p. z \\<in> RF (\\<Union> (TER ` Y))) \\<or>\n    x \\<in> RF (\\<Union> (TER ` Y))", "case False"], ["proof (state)\nthis:\n  \\<not> (\\<exists>f\\<in>Y. z \\<in> RF (TER f))\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>f\\<in>Y. z \\<in> RF (TER f)) \\<Longrightarrow>\n    (\\<exists>z\\<in>set p. z \\<in> RF (\\<Union> (TER ` Y))) \\<or>\n    x \\<in> RF (\\<Union> (TER ` Y))", "hence *: \"d_IN f z = 0\" if \"f \\<in> Y\" for f"], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>f\\<in>Y. z \\<in> RF (TER f))\n\ngoal (1 subgoal):\n 1. d_IN f z = 0", "using that"], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>f\\<in>Y. z \\<in> RF (TER f))\n  f \\<in> Y\n\ngoal (1 subgoal):\n 1. d_IN f z = 0", "by(auto intro: wave_not_RF_IN_zero[OF f w])"], ["proof (state)\nthis:\n  ?f \\<in> Y \\<Longrightarrow> d_IN ?f z = 0\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>f\\<in>Y. z \\<in> RF (TER f)) \\<Longrightarrow>\n    (\\<exists>z\\<in>set p. z \\<in> RF (\\<Union> (TER ` Y))) \\<or>\n    x \\<in> RF (\\<Union> (TER ` Y))", "hence \"d_IN (Sup Y) z = 0\""], ["proof (prove)\nusing this:\n  ?f \\<in> Y \\<Longrightarrow> d_IN ?f z = 0\n\ngoal (1 subgoal):\n 1. d_IN (\\<Squnion> Y) z = 0", "using Y(2)"], ["proof (prove)\nusing this:\n  ?f \\<in> Y \\<Longrightarrow> d_IN ?f z = 0\n  Y \\<noteq> {}\n\ngoal (1 subgoal):\n 1. d_IN (\\<Squnion> Y) z = 0", "by(simp add: d_IN_Sup[OF Y])"], ["proof (state)\nthis:\n  d_IN (\\<Squnion> Y) z = 0\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>f\\<in>Y. z \\<in> RF (TER f)) \\<Longrightarrow>\n    (\\<exists>z\\<in>set p. z \\<in> RF (\\<Union> (TER ` Y))) \\<or>\n    x \\<in> RF (\\<Union> (TER ` Y))", "with TER"], ["proof (chain)\npicking this:\n  z \\<in> TER (\\<Squnion> Y)\n  d_IN (\\<Squnion> Y) z = 0", "have \"z \\<in> SAT \\<Gamma> f\""], ["proof (prove)\nusing this:\n  z \\<in> TER (\\<Squnion> Y)\n  d_IN (\\<Squnion> Y) z = 0\n\ngoal (1 subgoal):\n 1. z \\<in> SAT \\<Gamma> f", "using *[OF y]"], ["proof (prove)\nusing this:\n  z \\<in> TER (\\<Squnion> Y)\n  d_IN (\\<Squnion> Y) z = 0\n  d_IN f z = 0\n\ngoal (1 subgoal):\n 1. z \\<in> SAT \\<Gamma> f", "by(simp add: SAT.simps)"], ["proof (state)\nthis:\n  z \\<in> SAT \\<Gamma> f\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>f\\<in>Y. z \\<in> RF (TER f)) \\<Longrightarrow>\n    (\\<exists>z\\<in>set p. z \\<in> RF (\\<Union> (TER ` Y))) \\<or>\n    x \\<in> RF (\\<Union> (TER ` Y))", "with SINK[OF y]"], ["proof (chain)\npicking this:\n  z \\<in> SINK f\n  z \\<in> SAT \\<Gamma> f", "have \"z \\<in> TER f\""], ["proof (prove)\nusing this:\n  z \\<in> SINK f\n  z \\<in> SAT \\<Gamma> f\n\ngoal (1 subgoal):\n 1. z \\<in> TER f", "by simp"], ["proof (state)\nthis:\n  z \\<in> TER f\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>f\\<in>Y. z \\<in> RF (TER f)) \\<Longrightarrow>\n    (\\<exists>z\\<in>set p. z \\<in> RF (\\<Union> (TER ` Y))) \\<or>\n    x \\<in> RF (\\<Union> (TER ` Y))", "with z y"], ["proof (chain)\npicking this:\n  z \\<in> set (x # p)\n  f \\<in> Y\n  z \\<in> TER f", "show ?thesis"], ["proof (prove)\nusing this:\n  z \\<in> set (x # p)\n  f \\<in> Y\n  z \\<in> TER f\n\ngoal (1 subgoal):\n 1. (\\<exists>z\\<in>set p. z \\<in> RF (\\<Union> (TER ` Y))) \\<or>\n    x \\<in> RF (\\<Union> (TER ` Y))", "by(auto intro: roofed_greaterI)"], ["proof (state)\nthis:\n  (\\<exists>z\\<in>set p. z \\<in> RF (\\<Union> (TER ` Y))) \\<or>\n  x \\<in> RF (\\<Union> (TER ` Y))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<exists>z\\<in>set p. z \\<in> RF (\\<Union> (TER ` Y))) \\<or>\n  x \\<in> RF (\\<Union> (TER ` Y))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x \\<in> RF (RF (\\<Union> (TER ` Y)))\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> RF (TER (\\<Squnion> Y)) \\<Longrightarrow>\n       x \\<in> RF (\\<Union> (TER ` Y))\n 2. \\<And>x.\n       x \\<in> RF (\\<Union> (TER ` Y)) \\<Longrightarrow>\n       x \\<in> RF (TER (\\<Squnion> Y))", "then"], ["proof (chain)\npicking this:\n  x \\<in> RF (RF (\\<Union> (TER ` Y)))", "show \"x \\<in> RF (\\<Union>f\\<in>Y. TER f)\""], ["proof (prove)\nusing this:\n  x \\<in> RF (RF (\\<Union> (TER ` Y)))\n\ngoal (1 subgoal):\n 1. x \\<in> RF (\\<Union> (TER ` Y))", "unfolding roofed_idem"], ["proof (prove)\nusing this:\n  x \\<in> RF (\\<Union> (TER ` Y))\n\ngoal (1 subgoal):\n 1. x \\<in> RF (\\<Union> (TER ` Y))", "."], ["proof (state)\nthis:\n  x \\<in> RF (\\<Union> (TER ` Y))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> RF (\\<Union> (TER ` Y)) \\<Longrightarrow>\n       x \\<in> RF (TER (\\<Squnion> Y))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> RF (\\<Union> (TER ` Y)) \\<Longrightarrow>\n       x \\<in> RF (TER (\\<Squnion> Y))", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> RF (\\<Union> (TER ` Y)) \\<Longrightarrow>\n       x \\<in> RF (TER (\\<Squnion> Y))", "assume x: \"x \\<in> RF (\\<Union>f\\<in>Y. TER f)\""], ["proof (state)\nthis:\n  x \\<in> RF (\\<Union> (TER ` Y))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> RF (\\<Union> (TER ` Y)) \\<Longrightarrow>\n       x \\<in> RF (TER (\\<Squnion> Y))", "have \"x \\<in> RF (RF (TER (\\<Squnion>Y)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> RF (RF (TER (\\<Squnion> Y)))", "proof(rule roofedI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p y.\n       \\<lbrakk>path \\<Gamma> x p y; y \\<in> B \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>z\\<in>set p.\n                             z \\<in> RF (TER (\\<Squnion> Y))) \\<or>\n                         x \\<in> RF (TER (\\<Squnion> Y))", "fix p y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p y.\n       \\<lbrakk>path \\<Gamma> x p y; y \\<in> B \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>z\\<in>set p.\n                             z \\<in> RF (TER (\\<Squnion> Y))) \\<or>\n                         x \\<in> RF (TER (\\<Squnion> Y))", "assume p: \"path \\<Gamma> x p y\" and y: \"y \\<in> B \\<Gamma>\""], ["proof (state)\nthis:\n  path \\<Gamma> x p y\n  y \\<in> B \\<Gamma>\n\ngoal (1 subgoal):\n 1. \\<And>p y.\n       \\<lbrakk>path \\<Gamma> x p y; y \\<in> B \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>z\\<in>set p.\n                             z \\<in> RF (TER (\\<Squnion> Y))) \\<or>\n                         x \\<in> RF (TER (\\<Squnion> Y))", "from roofedD[OF x p y]"], ["proof (chain)\npicking this:\n  (\\<exists>z\\<in>set p. z \\<in> \\<Union> (TER ` Y)) \\<or>\n  x \\<in> \\<Union> (TER ` Y)", "obtain z f where *: \"z \\<in> set (x # p)\"\n      and **: \"f \\<in> Y\" and TER: \"z \\<in> TER f\""], ["proof (prove)\nusing this:\n  (\\<exists>z\\<in>set p. z \\<in> \\<Union> (TER ` Y)) \\<or>\n  x \\<in> \\<Union> (TER ` Y)\n\ngoal (1 subgoal):\n 1. (\\<And>z f.\n        \\<lbrakk>z \\<in> set (x # p); f \\<in> Y; z \\<in> TER f\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  z \\<in> set (x # p)\n  f \\<in> Y\n  z \\<in> TER f\n\ngoal (1 subgoal):\n 1. \\<And>p y.\n       \\<lbrakk>path \\<Gamma> x p y; y \\<in> B \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>z\\<in>set p.\n                             z \\<in> RF (TER (\\<Squnion> Y))) \\<or>\n                         x \\<in> RF (TER (\\<Squnion> Y))", "have \"z \\<in> RF (TER (Sup Y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z \\<in> RF (TER (\\<Squnion> Y))", "proof(rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. z \\<notin> RF (TER (\\<Squnion> Y)) \\<Longrightarrow> False", "assume z: \"z \\<notin> RF (TER (Sup Y))\""], ["proof (state)\nthis:\n  z \\<notin> RF (TER (\\<Squnion> Y))\n\ngoal (1 subgoal):\n 1. z \\<notin> RF (TER (\\<Squnion> Y)) \\<Longrightarrow> False", "have \"wave \\<Gamma> (Sup Y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wave \\<Gamma> (\\<Squnion> Y)", "using Y(1-2) w Y(3)"], ["proof (prove)\nusing this:\n  Complete_Partial_Order.chain (\\<le>) Y\n  Y \\<noteq> {}\n  ?f \\<in> Y \\<Longrightarrow> wave \\<Gamma> ?f\n  countable (support_flow (\\<Squnion> Y))\n\ngoal (1 subgoal):\n 1. wave \\<Gamma> (\\<Squnion> Y)", "by(rule wave_lub)"], ["proof (state)\nthis:\n  wave \\<Gamma> (\\<Squnion> Y)\n\ngoal (1 subgoal):\n 1. z \\<notin> RF (TER (\\<Squnion> Y)) \\<Longrightarrow> False", "hence \"d_OUT (Sup Y) z = 0\""], ["proof (prove)\nusing this:\n  wave \\<Gamma> (\\<Squnion> Y)\n\ngoal (1 subgoal):\n 1. d_OUT (\\<Squnion> Y) z = 0", "using z"], ["proof (prove)\nusing this:\n  wave \\<Gamma> (\\<Squnion> Y)\n  z \\<notin> RF (TER (\\<Squnion> Y))\n\ngoal (1 subgoal):\n 1. d_OUT (\\<Squnion> Y) z = 0", "by(rule waveD_OUT)"], ["proof (state)\nthis:\n  d_OUT (\\<Squnion> Y) z = 0\n\ngoal (1 subgoal):\n 1. z \\<notin> RF (TER (\\<Squnion> Y)) \\<Longrightarrow> False", "hence \"z \\<in> SINK (Sup Y)\""], ["proof (prove)\nusing this:\n  d_OUT (\\<Squnion> Y) z = 0\n\ngoal (1 subgoal):\n 1. z \\<in> SINK (\\<Squnion> Y)", "by(simp add: SINK.simps)"], ["proof (state)\nthis:\n  z \\<in> SINK (\\<Squnion> Y)\n\ngoal (1 subgoal):\n 1. z \\<notin> RF (TER (\\<Squnion> Y)) \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  z \\<in> SINK (\\<Squnion> Y)\n\ngoal (1 subgoal):\n 1. z \\<notin> RF (TER (\\<Squnion> Y)) \\<Longrightarrow> False", "have \"z \\<in> SAT \\<Gamma> (Sup Y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z \\<in> SAT \\<Gamma> (\\<Squnion> Y)", "using TER SAT_Sup_upper[OF **, of \\<Gamma>]"], ["proof (prove)\nusing this:\n  z \\<in> TER f\n  SAT \\<Gamma> f \\<subseteq> SAT \\<Gamma> (\\<Squnion> Y)\n\ngoal (1 subgoal):\n 1. z \\<in> SAT \\<Gamma> (\\<Squnion> Y)", "by blast"], ["proof (state)\nthis:\n  z \\<in> SAT \\<Gamma> (\\<Squnion> Y)\n\ngoal (1 subgoal):\n 1. z \\<notin> RF (TER (\\<Squnion> Y)) \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  z \\<in> SINK (\\<Squnion> Y)\n  z \\<in> SAT \\<Gamma> (\\<Squnion> Y)", "have \"z \\<in> TER (Sup Y)\""], ["proof (prove)\nusing this:\n  z \\<in> SINK (\\<Squnion> Y)\n  z \\<in> SAT \\<Gamma> (\\<Squnion> Y)\n\ngoal (1 subgoal):\n 1. z \\<in> TER (\\<Squnion> Y)", "by simp"], ["proof (state)\nthis:\n  z \\<in> TER (\\<Squnion> Y)\n\ngoal (1 subgoal):\n 1. z \\<notin> RF (TER (\\<Squnion> Y)) \\<Longrightarrow> False", "hence \"z \\<in> RF (TER (Sup Y))\""], ["proof (prove)\nusing this:\n  z \\<in> TER (\\<Squnion> Y)\n\ngoal (1 subgoal):\n 1. z \\<in> RF (TER (\\<Squnion> Y))", "by(rule roofed_greaterI)"], ["proof (state)\nthis:\n  z \\<in> RF (TER (\\<Squnion> Y))\n\ngoal (1 subgoal):\n 1. z \\<notin> RF (TER (\\<Squnion> Y)) \\<Longrightarrow> False", "with z"], ["proof (chain)\npicking this:\n  z \\<notin> RF (TER (\\<Squnion> Y))\n  z \\<in> RF (TER (\\<Squnion> Y))", "show False"], ["proof (prove)\nusing this:\n  z \\<notin> RF (TER (\\<Squnion> Y))\n  z \\<in> RF (TER (\\<Squnion> Y))\n\ngoal (1 subgoal):\n 1. False", "by contradiction"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  z \\<in> RF (TER (\\<Squnion> Y))\n\ngoal (1 subgoal):\n 1. \\<And>p y.\n       \\<lbrakk>path \\<Gamma> x p y; y \\<in> B \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>z\\<in>set p.\n                             z \\<in> RF (TER (\\<Squnion> Y))) \\<or>\n                         x \\<in> RF (TER (\\<Squnion> Y))", "thus \"(\\<exists>z\\<in>set p. z \\<in> RF (TER (Sup Y))) \\<or> x \\<in> RF (TER (Sup Y))\""], ["proof (prove)\nusing this:\n  z \\<in> RF (TER (\\<Squnion> Y))\n\ngoal (1 subgoal):\n 1. (\\<exists>z\\<in>set p. z \\<in> RF (TER (\\<Squnion> Y))) \\<or>\n    x \\<in> RF (TER (\\<Squnion> Y))", "using *"], ["proof (prove)\nusing this:\n  z \\<in> RF (TER (\\<Squnion> Y))\n  z \\<in> set (x # p)\n\ngoal (1 subgoal):\n 1. (\\<exists>z\\<in>set p. z \\<in> RF (TER (\\<Squnion> Y))) \\<or>\n    x \\<in> RF (TER (\\<Squnion> Y))", "by auto"], ["proof (state)\nthis:\n  (\\<exists>z\\<in>set p. z \\<in> RF (TER (\\<Squnion> Y))) \\<or>\n  x \\<in> RF (TER (\\<Squnion> Y))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x \\<in> RF (RF (TER (\\<Squnion> Y)))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> RF (\\<Union> (TER ` Y)) \\<Longrightarrow>\n       x \\<in> RF (TER (\\<Squnion> Y))", "then"], ["proof (chain)\npicking this:\n  x \\<in> RF (RF (TER (\\<Squnion> Y)))", "show \"x \\<in> RF (TER (\\<Squnion>Y))\""], ["proof (prove)\nusing this:\n  x \\<in> RF (RF (TER (\\<Squnion> Y)))\n\ngoal (1 subgoal):\n 1. x \\<in> RF (TER (\\<Squnion> Y))", "unfolding roofed_idem"], ["proof (prove)\nusing this:\n  x \\<in> RF (TER (\\<Squnion> Y))\n\ngoal (1 subgoal):\n 1. x \\<in> RF (TER (\\<Squnion> Y))", "."], ["proof (state)\nthis:\n  x \\<in> RF (TER (\\<Squnion> Y))\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Hindered webs with reduced weights\\<close>"], ["", "context countable_bipartite_web begin"], ["", "context\n  fixes u :: \"'v \\<Rightarrow> ennreal\"\n  and \\<epsilon>\n  defines \"\\<epsilon> \\<equiv> (\\<integral>\\<^sup>+ y. u y \\<partial>count_space (B \\<Gamma>))\"\n  assumes u_outside: \"\\<And>x. x \\<notin> B \\<Gamma> \\<Longrightarrow> u x = 0\"\n  and finite_\\<epsilon>: \"\\<epsilon> \\<noteq> \\<top>\"\nbegin"], ["", "private"], ["", "lemma u_A: \"x \\<in> A \\<Gamma> \\<Longrightarrow> u x = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> A \\<Gamma> \\<Longrightarrow> u x = 0", "using u_outside[of x] disjoint"], ["proof (prove)\nusing this:\n  x \\<notin> B \\<Gamma> \\<Longrightarrow> u x = 0\n  A \\<Gamma> \\<inter> B \\<Gamma> = {}\n\ngoal (1 subgoal):\n 1. x \\<in> A \\<Gamma> \\<Longrightarrow> u x = 0", "by auto"], ["", "private"], ["", "lemma u_finite: \"u y \\<noteq> \\<top>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u y \\<noteq> \\<top>", "proof(cases \"y \\<in> B \\<Gamma>\")"], ["proof (state)\ngoal (2 subgoals):\n 1. y \\<in> B \\<Gamma> \\<Longrightarrow> u y \\<noteq> \\<top>\n 2. y \\<notin> B \\<Gamma> \\<Longrightarrow> u y \\<noteq> \\<top>", "case True"], ["proof (state)\nthis:\n  y \\<in> B \\<Gamma>\n\ngoal (2 subgoals):\n 1. y \\<in> B \\<Gamma> \\<Longrightarrow> u y \\<noteq> \\<top>\n 2. y \\<notin> B \\<Gamma> \\<Longrightarrow> u y \\<noteq> \\<top>", "have \"u y \\<le> \\<epsilon>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u y \\<le> \\<epsilon>", "unfolding \\<epsilon>_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. u y \\<le> integral\\<^sup>N (count_space (B \\<Gamma>)) u", "by(rule nn_integral_ge_point)(simp add: True)"], ["proof (state)\nthis:\n  u y \\<le> \\<epsilon>\n\ngoal (2 subgoals):\n 1. y \\<in> B \\<Gamma> \\<Longrightarrow> u y \\<noteq> \\<top>\n 2. y \\<notin> B \\<Gamma> \\<Longrightarrow> u y \\<noteq> \\<top>", "also"], ["proof (state)\nthis:\n  u y \\<le> \\<epsilon>\n\ngoal (2 subgoals):\n 1. y \\<in> B \\<Gamma> \\<Longrightarrow> u y \\<noteq> \\<top>\n 2. y \\<notin> B \\<Gamma> \\<Longrightarrow> u y \\<noteq> \\<top>", "have \"\\<dots> < \\<top>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<epsilon> < \\<top>", "using finite_\\<epsilon>"], ["proof (prove)\nusing this:\n  \\<epsilon> \\<noteq> \\<top>\n\ngoal (1 subgoal):\n 1. \\<epsilon> < \\<top>", "by (simp add: less_top[symmetric])"], ["proof (state)\nthis:\n  \\<epsilon> < \\<top>\n\ngoal (2 subgoals):\n 1. y \\<in> B \\<Gamma> \\<Longrightarrow> u y \\<noteq> \\<top>\n 2. y \\<notin> B \\<Gamma> \\<Longrightarrow> u y \\<noteq> \\<top>", "finally"], ["proof (chain)\npicking this:\n  u y < \\<top>", "show ?thesis"], ["proof (prove)\nusing this:\n  u y < \\<top>\n\ngoal (1 subgoal):\n 1. u y \\<noteq> \\<top>", "by simp"], ["proof (state)\nthis:\n  u y \\<noteq> \\<top>\n\ngoal (1 subgoal):\n 1. y \\<notin> B \\<Gamma> \\<Longrightarrow> u y \\<noteq> \\<top>", "qed(simp add: u_outside)"], ["", "lemma hindered_reduce: \\<comment> \\<open>Lemma 6.7\\<close>\n  assumes u: \"u \\<le> weight \\<Gamma>\"\n  assumes hindered_by: \"hindered_by (\\<Gamma>\\<lparr>weight := weight \\<Gamma> - u\\<rparr>) \\<epsilon>\" (is \"hindered_by ?\\<Gamma> _\")\n  shows \"hindered \\<Gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hindered \\<Gamma>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. hindered \\<Gamma>", "note [simp] = u_finite"], ["proof (state)\nthis:\n  u ?y \\<noteq> \\<top>\n\ngoal (1 subgoal):\n 1. hindered \\<Gamma>", "let ?TER = \"TER\\<^bsub>?\\<Gamma>\\<^esub>\""], ["proof (state)\ngoal (1 subgoal):\n 1. hindered \\<Gamma>", "from hindered_by"], ["proof (chain)\npicking this:\n  hindered_by (\\<Gamma>\\<lparr>weight := weight \\<Gamma> - u\\<rparr>)\n   \\<epsilon>", "obtain f\n    where hindrance_by: \"hindrance_by ?\\<Gamma> f \\<epsilon>\"\n    and f: \"current ?\\<Gamma> f\"\n    and w: \"wave ?\\<Gamma> f\""], ["proof (prove)\nusing this:\n  hindered_by (\\<Gamma>\\<lparr>weight := weight \\<Gamma> - u\\<rparr>)\n   \\<epsilon>\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        \\<lbrakk>hindrance_by\n                  (\\<Gamma>\\<lparr>weight := weight \\<Gamma> - u\\<rparr>) f\n                  \\<epsilon>;\n         current (\\<Gamma>\\<lparr>weight := weight \\<Gamma> - u\\<rparr>) f;\n         wave (\\<Gamma>\\<lparr>weight := weight \\<Gamma> - u\\<rparr>)\n          f\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by cases"], ["proof (state)\nthis:\n  hindrance_by (\\<Gamma>\\<lparr>weight := weight \\<Gamma> - u\\<rparr>) f\n   \\<epsilon>\n  current (\\<Gamma>\\<lparr>weight := weight \\<Gamma> - u\\<rparr>) f\n  wave (\\<Gamma>\\<lparr>weight := weight \\<Gamma> - u\\<rparr>) f\n\ngoal (1 subgoal):\n 1. hindered \\<Gamma>", "from hindrance_by"], ["proof (chain)\npicking this:\n  hindrance_by (\\<Gamma>\\<lparr>weight := weight \\<Gamma> - u\\<rparr>) f\n   \\<epsilon>", "obtain a where a: \"a \\<in> A \\<Gamma>\" \"a \\<notin> \\<E>\\<^bsub>?\\<Gamma>\\<^esub> (?TER f)\"\n    and a_le: \"d_OUT f a < weight \\<Gamma> a\"\n    and \\<epsilon>_less: \"weight \\<Gamma> a - d_OUT f a > \\<epsilon>\"\n    and \\<epsilon>_nonneg: \"\\<epsilon> \\<ge> 0\""], ["proof (prove)\nusing this:\n  hindrance_by (\\<Gamma>\\<lparr>weight := weight \\<Gamma> - u\\<rparr>) f\n   \\<epsilon>\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>a \\<in> A \\<Gamma>;\n         a \\<notin> \\<E>\\<^bsub>\\<Gamma>\\<lparr>weight := weight \\<Gamma> - u\\<rparr>\\<^esub>\n                     (TER\\<^bsub>\\<Gamma>\\<lparr>weight := weight \\<Gamma> - u\\<rparr>\\<^esub>\n                       f);\n         d_OUT f a < weight \\<Gamma> a;\n         \\<epsilon> < weight \\<Gamma> a - d_OUT f a;\n         0 \\<le> \\<epsilon>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto simp add: u_A hindrance_by.simps)"], ["proof (state)\nthis:\n  a \\<in> A \\<Gamma>\n  a \\<notin> \\<E>\\<^bsub>\\<Gamma>\\<lparr>weight := weight \\<Gamma> - u\\<rparr>\\<^esub>\n              (TER\\<^bsub>\\<Gamma>\\<lparr>weight := weight \\<Gamma> - u\\<rparr>\\<^esub>\n                f)\n  d_OUT f a < weight \\<Gamma> a\n  \\<epsilon> < weight \\<Gamma> a - d_OUT f a\n  0 \\<le> \\<epsilon>\n\ngoal (1 subgoal):\n 1. hindered \\<Gamma>", "from f"], ["proof (chain)\npicking this:\n  current (\\<Gamma>\\<lparr>weight := weight \\<Gamma> - u\\<rparr>) f", "have f': \"current \\<Gamma> f\""], ["proof (prove)\nusing this:\n  current (\\<Gamma>\\<lparr>weight := weight \\<Gamma> - u\\<rparr>) f\n\ngoal (1 subgoal):\n 1. current \\<Gamma> f", "by(rule current_weight_mono)(auto intro: diff_le_self_ennreal)"], ["proof (state)\nthis:\n  current \\<Gamma> f\n\ngoal (1 subgoal):\n 1. hindered \\<Gamma>", "write Some (\"\\<langle>_\\<rangle>\")"], ["proof (state)\ngoal (1 subgoal):\n 1. hindered \\<Gamma>", "define edge'\n    where \"edge' xo yo =\n      (case (xo, yo) of\n        (None, Some y) \\<Rightarrow> y \\<in> \\<^bold>V \\<and> y \\<notin> A \\<Gamma>\n      | (Some x, Some y) \\<Rightarrow> edge \\<Gamma> x y \\<or> edge \\<Gamma> y x\n      | _ \\<Rightarrow> False)\" for xo yo"], ["proof (state)\nthis:\n  edge' ?xo ?yo =\n  (case (?xo, ?yo) of (None, None) \\<Rightarrow> False\n   | (None, \\<langle>y\\<rangle>) \\<Rightarrow>\n       y \\<in> \\<^bold>V \\<and> y \\<notin> A \\<Gamma>\n   | (\\<langle>x\\<rangle>, None) \\<Rightarrow> False\n   | (\\<langle>x\\<rangle>, \\<langle>y\\<rangle>) \\<Rightarrow>\n       edge \\<Gamma> x y \\<or> edge \\<Gamma> y x)\n\ngoal (1 subgoal):\n 1. hindered \\<Gamma>", "define cap\n    where \"cap e =\n      (case e of\n        (None, Some y) \\<Rightarrow> if y \\<in> \\<^bold>V then u y else 0\n      | (Some x, Some y) \\<Rightarrow> if edge \\<Gamma> x y \\<and> x \\<noteq> a then f (x, y) else if edge \\<Gamma> y x then max (weight \\<Gamma> x) (weight \\<Gamma> y) + 1 else 0\n      | _ \\<Rightarrow> 0)\" for e"], ["proof (state)\nthis:\n  cap ?e =\n  (case ?e of (None, None) \\<Rightarrow> 0\n   | (None, \\<langle>y\\<rangle>) \\<Rightarrow>\n       if y \\<in> \\<^bold>V then u y else 0\n   | (\\<langle>x\\<rangle>, None) \\<Rightarrow> 0\n   | (\\<langle>x\\<rangle>, \\<langle>y\\<rangle>) \\<Rightarrow>\n       if edge \\<Gamma> x y \\<and> x \\<noteq> a then f (x, y)\n       else if edge \\<Gamma> y x\n            then max (weight \\<Gamma> x) (weight \\<Gamma> y) + 1 else 0)\n\ngoal (1 subgoal):\n 1. hindered \\<Gamma>", "define \\<Psi> where \"\\<Psi> = \\<lparr>edge = edge', capacity = cap, source = None, sink = Some a\\<rparr>\""], ["proof (state)\nthis:\n  \\<Psi> =\n  \\<lparr>edge = edge', capacity = cap, source = None,\n     sink = \\<langle>a\\<rangle>\\<rparr>\n\ngoal (1 subgoal):\n 1. hindered \\<Gamma>", "have edge'_simps [simp]:\n    \"edge' None \\<langle>y\\<rangle> \\<longleftrightarrow> y \\<in> \\<^bold>V \\<and> y \\<notin> A \\<Gamma>\"\n    \"edge' xo None \\<longleftrightarrow> False\"\n    \"edge' \\<langle>x\\<rangle> \\<langle>y\\<rangle> \\<longleftrightarrow> edge \\<Gamma> x y \\<or> edge \\<Gamma> y x\"\n    for xo x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. edge' None \\<langle>y\\<rangle> =\n    (y \\<in> \\<^bold>V \\<and> y \\<notin> A \\<Gamma>) &&&\n    edge' xo None = False &&&\n    edge' \\<langle>x\\<rangle> \\<langle>y\\<rangle> =\n    (edge \\<Gamma> x y \\<or> edge \\<Gamma> y x)", "by(simp_all add: edge'_def split: option.split)"], ["proof (state)\nthis:\n  edge' None \\<langle>?y\\<rangle> =\n  (?y \\<in> \\<^bold>V \\<and> ?y \\<notin> A \\<Gamma>)\n  edge' ?xo None = False\n  edge' \\<langle>?x\\<rangle> \\<langle>?y\\<rangle> =\n  (edge \\<Gamma> ?x ?y \\<or> edge \\<Gamma> ?y ?x)\n\ngoal (1 subgoal):\n 1. hindered \\<Gamma>", "have edge_None1E [elim!]: thesis if \"edge' None y\" \"\\<And>z. \\<lbrakk> y = \\<langle>z\\<rangle>; z \\<in> \\<^bold>V; z \\<notin> A \\<Gamma> \\<rbrakk> \\<Longrightarrow> thesis\" for y thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "using that"], ["proof (prove)\nusing this:\n  edge' None y\n  \\<lbrakk>y = \\<langle>?z\\<rangle>; ?z \\<in> \\<^bold>V;\n   ?z \\<notin> A \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "by(simp add: edge'_def split: option.split_asm sum.split_asm)"], ["proof (state)\nthis:\n  \\<lbrakk>edge' None ?y;\n   \\<And>z.\n      \\<lbrakk>?y = \\<langle>z\\<rangle>; z \\<in> \\<^bold>V;\n       z \\<notin> A \\<Gamma>\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. hindered \\<Gamma>", "have edge_Some1E [elim!]: thesis if \"edge' \\<langle>x\\<rangle> y\" \"\\<And>z. \\<lbrakk> y = \\<langle>z\\<rangle>; edge \\<Gamma> x z \\<or> edge \\<Gamma> z x \\<rbrakk> \\<Longrightarrow> thesis\" for x y thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "using that"], ["proof (prove)\nusing this:\n  edge' \\<langle>x\\<rangle> y\n  \\<lbrakk>y = \\<langle>?z\\<rangle>;\n   edge \\<Gamma> x ?z \\<or> edge \\<Gamma> ?z x\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "by(simp add: edge'_def split: option.split_asm sum.split_asm)"], ["proof (state)\nthis:\n  \\<lbrakk>edge' \\<langle>?x\\<rangle> ?y;\n   \\<And>z.\n      \\<lbrakk>?y = \\<langle>z\\<rangle>;\n       edge \\<Gamma> ?x z \\<or> edge \\<Gamma> z ?x\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. hindered \\<Gamma>", "have edge_Some2E [elim!]: thesis if \"edge' x \\<langle>y\\<rangle>\" \"\\<lbrakk> x = None; y \\<in> \\<^bold>V; y \\<notin> A \\<Gamma> \\<rbrakk> \\<Longrightarrow> thesis\" \"\\<And>z. \\<lbrakk> x = \\<langle>z\\<rangle>; edge \\<Gamma> z y \\<or> edge \\<Gamma> y z \\<rbrakk> \\<Longrightarrow> thesis\" for x y thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "using that"], ["proof (prove)\nusing this:\n  edge' x \\<langle>y\\<rangle>\n  \\<lbrakk>x = None; y \\<in> \\<^bold>V; y \\<notin> A \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> thesis\n  \\<lbrakk>x = \\<langle>?z\\<rangle>;\n   edge \\<Gamma> ?z y \\<or> edge \\<Gamma> y ?z\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "by(simp add: edge'_def split: option.split_asm sum.split_asm)"], ["proof (state)\nthis:\n  \\<lbrakk>edge' ?x \\<langle>?y\\<rangle>;\n   \\<lbrakk>?x = None; ?y \\<in> \\<^bold>V; ?y \\<notin> A \\<Gamma>\\<rbrakk>\n   \\<Longrightarrow> ?thesis;\n   \\<And>z.\n      \\<lbrakk>?x = \\<langle>z\\<rangle>;\n       edge \\<Gamma> z ?y \\<or> edge \\<Gamma> ?y z\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. hindered \\<Gamma>", "have cap_simps [simp]:\n    \"cap (None, \\<langle>y\\<rangle>) = (if y \\<in> \\<^bold>V then u y else 0)\"\n    \"cap (xo, None) = 0\"\n    \"cap (\\<langle>x\\<rangle>, \\<langle>y\\<rangle>) =\n    (if edge \\<Gamma> x y \\<and> x \\<noteq> a then f (x, y) else if edge \\<Gamma> y x then max (weight \\<Gamma> x) (weight \\<Gamma> y) + 1 else 0)\"\n    for xo x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. cap (None, \\<langle>y\\<rangle>) =\n    (if y \\<in> \\<^bold>V then u y else 0) &&&\n    cap (xo, None) = 0 &&&\n    cap (\\<langle>x\\<rangle>, \\<langle>y\\<rangle>) =\n    (if edge \\<Gamma> x y \\<and> x \\<noteq> a then f (x, y)\n     else if edge \\<Gamma> y x\n          then max (weight \\<Gamma> x) (weight \\<Gamma> y) + 1 else 0)", "by(simp_all add: cap_def split: option.split)"], ["proof (state)\nthis:\n  cap (None, \\<langle>?y\\<rangle>) =\n  (if ?y \\<in> \\<^bold>V then u ?y else 0)\n  cap (?xo, None) = 0\n  cap (\\<langle>?x\\<rangle>, \\<langle>?y\\<rangle>) =\n  (if edge \\<Gamma> ?x ?y \\<and> ?x \\<noteq> a then f (?x, ?y)\n   else if edge \\<Gamma> ?y ?x\n        then max (weight \\<Gamma> ?x) (weight \\<Gamma> ?y) + 1 else 0)\n\ngoal (1 subgoal):\n 1. hindered \\<Gamma>", "have \\<Psi>_sel [simp]:\n    \"edge \\<Psi> = edge'\"\n    \"capacity \\<Psi> = cap\"\n    \"source \\<Psi> = None\"\n    \"sink \\<Psi> = \\<langle>a\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (edge \\<Psi> = edge' &&& capacity \\<Psi> = cap) &&&\n    source \\<Psi> = None &&& sink \\<Psi> = \\<langle>a\\<rangle>", "by(simp_all add: \\<Psi>_def)"], ["proof (state)\nthis:\n  edge \\<Psi> = edge'\n  capacity \\<Psi> = cap\n  source \\<Psi> = None\n  sink \\<Psi> = \\<langle>a\\<rangle>\n\ngoal (1 subgoal):\n 1. hindered \\<Gamma>", "have cap_outside1: \"\\<not> vertex \\<Gamma> x \\<Longrightarrow> cap (\\<langle>x\\<rangle>, y) = 0\" for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> vertex \\<Gamma> x \\<Longrightarrow>\n    cap (\\<langle>x\\<rangle>, y) = 0", "by(cases y)(auto simp add: vertex_def)"], ["proof (state)\nthis:\n  \\<not> vertex \\<Gamma> ?x \\<Longrightarrow>\n  cap (\\<langle>?x\\<rangle>, ?y) = 0\n\ngoal (1 subgoal):\n 1. hindered \\<Gamma>", "have capacity_A_weight: \"d_OUT cap \\<langle>x\\<rangle> \\<le> weight \\<Gamma> x\" if \"x \\<in> A \\<Gamma>\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT cap \\<langle>x\\<rangle> \\<le> weight \\<Gamma> x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. d_OUT cap \\<langle>x\\<rangle> \\<le> weight \\<Gamma> x", "have \"d_OUT cap \\<langle>x\\<rangle> \\<le> (\\<Sum>\\<^sup>+ y\\<in>range Some. f (x, the y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT cap \\<langle>x\\<rangle>\n    \\<le> (\\<Sum>\\<^sup>+ y\\<in>range Some. f (x, the y))", "using that disjoint a(1)"], ["proof (prove)\nusing this:\n  x \\<in> A \\<Gamma>\n  A \\<Gamma> \\<inter> B \\<Gamma> = {}\n  a \\<in> A \\<Gamma>\n\ngoal (1 subgoal):\n 1. d_OUT cap \\<langle>x\\<rangle>\n    \\<le> (\\<Sum>\\<^sup>+ y\\<in>range Some. f (x, the y))", "unfolding d_OUT_def"], ["proof (prove)\nusing this:\n  x \\<in> A \\<Gamma>\n  A \\<Gamma> \\<inter> B \\<Gamma> = {}\n  a \\<in> A \\<Gamma>\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y. cap (\\<langle>x\\<rangle>, y))\n    \\<le> (\\<Sum>\\<^sup>+ y\\<in>range Some. f (x, the y))", "by(auto 4 4 intro!: nn_integral_mono simp add: nn_integral_count_space_indicator notin_range_Some currentD_outside[OF f] split: split_indicator dest: edge_antiparallel bipartite_E)"], ["proof (state)\nthis:\n  d_OUT cap \\<langle>x\\<rangle>\n  \\<le> (\\<Sum>\\<^sup>+ y\\<in>range Some. f (x, the y))\n\ngoal (1 subgoal):\n 1. d_OUT cap \\<langle>x\\<rangle> \\<le> weight \\<Gamma> x", "also"], ["proof (state)\nthis:\n  d_OUT cap \\<langle>x\\<rangle>\n  \\<le> (\\<Sum>\\<^sup>+ y\\<in>range Some. f (x, the y))\n\ngoal (1 subgoal):\n 1. d_OUT cap \\<langle>x\\<rangle> \\<le> weight \\<Gamma> x", "have \"\\<dots> = d_OUT f x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y\\<in>range Some. f (x, the y)) = d_OUT f x", "by(simp add: d_OUT_def nn_integral_count_space_reindex)"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y\\<in>range Some. f (x, the y)) = d_OUT f x\n\ngoal (1 subgoal):\n 1. d_OUT cap \\<langle>x\\<rangle> \\<le> weight \\<Gamma> x", "also"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y\\<in>range Some. f (x, the y)) = d_OUT f x\n\ngoal (1 subgoal):\n 1. d_OUT cap \\<langle>x\\<rangle> \\<le> weight \\<Gamma> x", "have \"\\<dots> \\<le> weight \\<Gamma> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT f x \\<le> weight \\<Gamma> x", "using f'"], ["proof (prove)\nusing this:\n  current \\<Gamma> f\n\ngoal (1 subgoal):\n 1. d_OUT f x \\<le> weight \\<Gamma> x", "by(rule currentD_weight_OUT)"], ["proof (state)\nthis:\n  d_OUT f x \\<le> weight \\<Gamma> x\n\ngoal (1 subgoal):\n 1. d_OUT cap \\<langle>x\\<rangle> \\<le> weight \\<Gamma> x", "finally"], ["proof (chain)\npicking this:\n  d_OUT cap \\<langle>x\\<rangle> \\<le> weight \\<Gamma> x", "show ?thesis"], ["proof (prove)\nusing this:\n  d_OUT cap \\<langle>x\\<rangle> \\<le> weight \\<Gamma> x\n\ngoal (1 subgoal):\n 1. d_OUT cap \\<langle>x\\<rangle> \\<le> weight \\<Gamma> x", "."], ["proof (state)\nthis:\n  d_OUT cap \\<langle>x\\<rangle> \\<le> weight \\<Gamma> x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?x \\<in> A \\<Gamma> \\<Longrightarrow>\n  d_OUT cap \\<langle>?x\\<rangle> \\<le> weight \\<Gamma> ?x\n\ngoal (1 subgoal):\n 1. hindered \\<Gamma>", "have flow_attainability: \"flow_attainability \\<Psi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. flow_attainability \\<Psi>", "proof"], ["proof (state)\ngoal (7 subgoals):\n 1. countable \\<^bold>E\\<^bsub>\\<Psi>\\<^esub>\n 2. source \\<Psi> \\<noteq> sink \\<Psi>\n 3. \\<And>e.\n       e \\<notin> \\<^bold>E\\<^bsub>\\<Psi>\\<^esub> \\<Longrightarrow>\n       capacity \\<Psi> e = 0\n 4. \\<And>e. capacity \\<Psi> e \\<noteq> \\<top>\n 5. \\<And>x.\n       x \\<noteq> sink \\<Psi> \\<Longrightarrow>\n       d_IN (capacity \\<Psi>) x \\<noteq> \\<top> \\<or>\n       d_OUT (capacity \\<Psi>) x \\<noteq> \\<top>\n 6. \\<And>x. \\<not> edge \\<Psi> x x\n 7. \\<And>x. \\<not> edge \\<Psi> x (source \\<Psi>)", "have \"\\<^bold>E\\<^bsub>\\<Psi>\\<^esub> = (\\<lambda>(x, y). (\\<langle>x\\<rangle>, \\<langle>y\\<rangle>)) ` \\<^bold>E \\<union> (\\<lambda>(x, y). (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>)) ` \\<^bold>E \\<union> (\\<lambda>x. (None, \\<langle>x\\<rangle>)) ` (\\<^bold>V \\<inter> - A \\<Gamma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<^bold>E\\<^bsub>\\<Psi>\\<^esub> =\n    (\\<lambda>(x, y). (\\<langle>x\\<rangle>, \\<langle>y\\<rangle>)) `\n    \\<^bold>E \\<union>\n    (\\<lambda>(x, y). (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>)) `\n    \\<^bold>E \\<union>\n    (\\<lambda>x. (None, \\<langle>x\\<rangle>)) `\n    (\\<^bold>V \\<inter> - A \\<Gamma>)", "by(auto simp add: edge'_def split: option.split_asm)"], ["proof (state)\nthis:\n  \\<^bold>E\\<^bsub>\\<Psi>\\<^esub> =\n  (\\<lambda>(x, y). (\\<langle>x\\<rangle>, \\<langle>y\\<rangle>)) `\n  \\<^bold>E \\<union>\n  (\\<lambda>(x, y). (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>)) `\n  \\<^bold>E \\<union>\n  (\\<lambda>x. (None, \\<langle>x\\<rangle>)) `\n  (\\<^bold>V \\<inter> - A \\<Gamma>)\n\ngoal (7 subgoals):\n 1. countable \\<^bold>E\\<^bsub>\\<Psi>\\<^esub>\n 2. source \\<Psi> \\<noteq> sink \\<Psi>\n 3. \\<And>e.\n       e \\<notin> \\<^bold>E\\<^bsub>\\<Psi>\\<^esub> \\<Longrightarrow>\n       capacity \\<Psi> e = 0\n 4. \\<And>e. capacity \\<Psi> e \\<noteq> \\<top>\n 5. \\<And>x.\n       x \\<noteq> sink \\<Psi> \\<Longrightarrow>\n       d_IN (capacity \\<Psi>) x \\<noteq> \\<top> \\<or>\n       d_OUT (capacity \\<Psi>) x \\<noteq> \\<top>\n 6. \\<And>x. \\<not> edge \\<Psi> x x\n 7. \\<And>x. \\<not> edge \\<Psi> x (source \\<Psi>)", "thus \"countable \\<^bold>E\\<^bsub>\\<Psi>\\<^esub>\""], ["proof (prove)\nusing this:\n  \\<^bold>E\\<^bsub>\\<Psi>\\<^esub> =\n  (\\<lambda>(x, y). (\\<langle>x\\<rangle>, \\<langle>y\\<rangle>)) `\n  \\<^bold>E \\<union>\n  (\\<lambda>(x, y). (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>)) `\n  \\<^bold>E \\<union>\n  (\\<lambda>x. (None, \\<langle>x\\<rangle>)) `\n  (\\<^bold>V \\<inter> - A \\<Gamma>)\n\ngoal (1 subgoal):\n 1. countable \\<^bold>E\\<^bsub>\\<Psi>\\<^esub>", "by simp"], ["proof (state)\nthis:\n  countable \\<^bold>E\\<^bsub>\\<Psi>\\<^esub>\n\ngoal (6 subgoals):\n 1. source \\<Psi> \\<noteq> sink \\<Psi>\n 2. \\<And>e.\n       e \\<notin> \\<^bold>E\\<^bsub>\\<Psi>\\<^esub> \\<Longrightarrow>\n       capacity \\<Psi> e = 0\n 3. \\<And>e. capacity \\<Psi> e \\<noteq> \\<top>\n 4. \\<And>x.\n       x \\<noteq> sink \\<Psi> \\<Longrightarrow>\n       d_IN (capacity \\<Psi>) x \\<noteq> \\<top> \\<or>\n       d_OUT (capacity \\<Psi>) x \\<noteq> \\<top>\n 5. \\<And>x. \\<not> edge \\<Psi> x x\n 6. \\<And>x. \\<not> edge \\<Psi> x (source \\<Psi>)", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. source \\<Psi> \\<noteq> sink \\<Psi>\n 2. \\<And>e.\n       e \\<notin> \\<^bold>E\\<^bsub>\\<Psi>\\<^esub> \\<Longrightarrow>\n       capacity \\<Psi> e = 0\n 3. \\<And>e. capacity \\<Psi> e \\<noteq> \\<top>\n 4. \\<And>x.\n       x \\<noteq> sink \\<Psi> \\<Longrightarrow>\n       d_IN (capacity \\<Psi>) x \\<noteq> \\<top> \\<or>\n       d_OUT (capacity \\<Psi>) x \\<noteq> \\<top>\n 5. \\<And>x. \\<not> edge \\<Psi> x x\n 6. \\<And>x. \\<not> edge \\<Psi> x (source \\<Psi>)", "fix v"], ["proof (state)\ngoal (6 subgoals):\n 1. source \\<Psi> \\<noteq> sink \\<Psi>\n 2. \\<And>e.\n       e \\<notin> \\<^bold>E\\<^bsub>\\<Psi>\\<^esub> \\<Longrightarrow>\n       capacity \\<Psi> e = 0\n 3. \\<And>e. capacity \\<Psi> e \\<noteq> \\<top>\n 4. \\<And>x.\n       x \\<noteq> sink \\<Psi> \\<Longrightarrow>\n       d_IN (capacity \\<Psi>) x \\<noteq> \\<top> \\<or>\n       d_OUT (capacity \\<Psi>) x \\<noteq> \\<top>\n 5. \\<And>x. \\<not> edge \\<Psi> x x\n 6. \\<And>x. \\<not> edge \\<Psi> x (source \\<Psi>)", "assume \"v \\<noteq> sink \\<Psi>\""], ["proof (state)\nthis:\n  v \\<noteq> sink \\<Psi>\n\ngoal (6 subgoals):\n 1. source \\<Psi> \\<noteq> sink \\<Psi>\n 2. \\<And>e.\n       e \\<notin> \\<^bold>E\\<^bsub>\\<Psi>\\<^esub> \\<Longrightarrow>\n       capacity \\<Psi> e = 0\n 3. \\<And>e. capacity \\<Psi> e \\<noteq> \\<top>\n 4. \\<And>x.\n       x \\<noteq> sink \\<Psi> \\<Longrightarrow>\n       d_IN (capacity \\<Psi>) x \\<noteq> \\<top> \\<or>\n       d_OUT (capacity \\<Psi>) x \\<noteq> \\<top>\n 5. \\<And>x. \\<not> edge \\<Psi> x x\n 6. \\<And>x. \\<not> edge \\<Psi> x (source \\<Psi>)", "consider (sink) \"v = None\" | (A) x where \"v = \\<langle>x\\<rangle>\" \"x \\<in> A \\<Gamma>\"\n      | (B) y where \"v = \\<langle>y\\<rangle>\" \"y \\<notin> A \\<Gamma>\" \"y \\<in> \\<^bold>V\" | (outside) x where \"v = \\<langle>x\\<rangle>\" \"x \\<notin> \\<^bold>V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>v = None \\<Longrightarrow> thesis;\n     \\<And>x.\n        \\<lbrakk>v = \\<langle>x\\<rangle>; x \\<in> A \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<And>y.\n        \\<lbrakk>v = \\<langle>y\\<rangle>; y \\<notin> A \\<Gamma>;\n         y \\<in> \\<^bold>V\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<And>x.\n        \\<lbrakk>v = \\<langle>x\\<rangle>; x \\<notin> \\<^bold>V\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by(cases v) auto"], ["proof (state)\nthis:\n  \\<lbrakk>v = None \\<Longrightarrow> ?thesis;\n   \\<And>x.\n      \\<lbrakk>v = \\<langle>x\\<rangle>; x \\<in> A \\<Gamma>\\<rbrakk>\n      \\<Longrightarrow> ?thesis;\n   \\<And>y.\n      \\<lbrakk>v = \\<langle>y\\<rangle>; y \\<notin> A \\<Gamma>;\n       y \\<in> \\<^bold>V\\<rbrakk>\n      \\<Longrightarrow> ?thesis;\n   \\<And>x.\n      \\<lbrakk>v = \\<langle>x\\<rangle>; x \\<notin> \\<^bold>V\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (6 subgoals):\n 1. source \\<Psi> \\<noteq> sink \\<Psi>\n 2. \\<And>e.\n       e \\<notin> \\<^bold>E\\<^bsub>\\<Psi>\\<^esub> \\<Longrightarrow>\n       capacity \\<Psi> e = 0\n 3. \\<And>e. capacity \\<Psi> e \\<noteq> \\<top>\n 4. \\<And>x.\n       x \\<noteq> sink \\<Psi> \\<Longrightarrow>\n       d_IN (capacity \\<Psi>) x \\<noteq> \\<top> \\<or>\n       d_OUT (capacity \\<Psi>) x \\<noteq> \\<top>\n 5. \\<And>x. \\<not> edge \\<Psi> x x\n 6. \\<And>x. \\<not> edge \\<Psi> x (source \\<Psi>)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>v = None \\<Longrightarrow> ?thesis;\n   \\<And>x.\n      \\<lbrakk>v = \\<langle>x\\<rangle>; x \\<in> A \\<Gamma>\\<rbrakk>\n      \\<Longrightarrow> ?thesis;\n   \\<And>y.\n      \\<lbrakk>v = \\<langle>y\\<rangle>; y \\<notin> A \\<Gamma>;\n       y \\<in> \\<^bold>V\\<rbrakk>\n      \\<Longrightarrow> ?thesis;\n   \\<And>x.\n      \\<lbrakk>v = \\<langle>x\\<rangle>; x \\<notin> \\<^bold>V\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis", "show \"d_IN (capacity \\<Psi>) v \\<noteq> \\<top> \\<or> d_OUT (capacity \\<Psi>) v \\<noteq> \\<top>\""], ["proof (prove)\nusing this:\n  \\<lbrakk>v = None \\<Longrightarrow> ?thesis;\n   \\<And>x.\n      \\<lbrakk>v = \\<langle>x\\<rangle>; x \\<in> A \\<Gamma>\\<rbrakk>\n      \\<Longrightarrow> ?thesis;\n   \\<And>y.\n      \\<lbrakk>v = \\<langle>y\\<rangle>; y \\<notin> A \\<Gamma>;\n       y \\<in> \\<^bold>V\\<rbrakk>\n      \\<Longrightarrow> ?thesis;\n   \\<And>x.\n      \\<lbrakk>v = \\<langle>x\\<rangle>; x \\<notin> \\<^bold>V\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. d_IN (capacity \\<Psi>) v \\<noteq> \\<top> \\<or>\n    d_OUT (capacity \\<Psi>) v \\<noteq> \\<top>", "proof cases"], ["proof (state)\ngoal (4 subgoals):\n 1. v = None \\<Longrightarrow>\n    d_IN (capacity \\<Psi>) v \\<noteq> \\<top> \\<or>\n    d_OUT (capacity \\<Psi>) v \\<noteq> \\<top>\n 2. \\<And>x.\n       \\<lbrakk>v = \\<langle>x\\<rangle>; x \\<in> A \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> d_IN (capacity \\<Psi>) v \\<noteq> \\<top> \\<or>\n                         d_OUT (capacity \\<Psi>) v \\<noteq> \\<top>\n 3. \\<And>y.\n       \\<lbrakk>v = \\<langle>y\\<rangle>; y \\<notin> A \\<Gamma>;\n        y \\<in> \\<^bold>V\\<rbrakk>\n       \\<Longrightarrow> d_IN (capacity \\<Psi>) v \\<noteq> \\<top> \\<or>\n                         d_OUT (capacity \\<Psi>) v \\<noteq> \\<top>\n 4. \\<And>x.\n       \\<lbrakk>v = \\<langle>x\\<rangle>; x \\<notin> \\<^bold>V\\<rbrakk>\n       \\<Longrightarrow> d_IN (capacity \\<Psi>) v \\<noteq> \\<top> \\<or>\n                         d_OUT (capacity \\<Psi>) v \\<noteq> \\<top>", "case sink"], ["proof (state)\nthis:\n  v = None\n\ngoal (4 subgoals):\n 1. v = None \\<Longrightarrow>\n    d_IN (capacity \\<Psi>) v \\<noteq> \\<top> \\<or>\n    d_OUT (capacity \\<Psi>) v \\<noteq> \\<top>\n 2. \\<And>x.\n       \\<lbrakk>v = \\<langle>x\\<rangle>; x \\<in> A \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> d_IN (capacity \\<Psi>) v \\<noteq> \\<top> \\<or>\n                         d_OUT (capacity \\<Psi>) v \\<noteq> \\<top>\n 3. \\<And>y.\n       \\<lbrakk>v = \\<langle>y\\<rangle>; y \\<notin> A \\<Gamma>;\n        y \\<in> \\<^bold>V\\<rbrakk>\n       \\<Longrightarrow> d_IN (capacity \\<Psi>) v \\<noteq> \\<top> \\<or>\n                         d_OUT (capacity \\<Psi>) v \\<noteq> \\<top>\n 4. \\<And>x.\n       \\<lbrakk>v = \\<langle>x\\<rangle>; x \\<notin> \\<^bold>V\\<rbrakk>\n       \\<Longrightarrow> d_IN (capacity \\<Psi>) v \\<noteq> \\<top> \\<or>\n                         d_OUT (capacity \\<Psi>) v \\<noteq> \\<top>", "thus ?thesis"], ["proof (prove)\nusing this:\n  v = None\n\ngoal (1 subgoal):\n 1. d_IN (capacity \\<Psi>) v \\<noteq> \\<top> \\<or>\n    d_OUT (capacity \\<Psi>) v \\<noteq> \\<top>", "by(simp add: d_IN_def)"], ["proof (state)\nthis:\n  d_IN (capacity \\<Psi>) v \\<noteq> \\<top> \\<or>\n  d_OUT (capacity \\<Psi>) v \\<noteq> \\<top>\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>v = \\<langle>x\\<rangle>; x \\<in> A \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> d_IN (capacity \\<Psi>) v \\<noteq> \\<top> \\<or>\n                         d_OUT (capacity \\<Psi>) v \\<noteq> \\<top>\n 2. \\<And>y.\n       \\<lbrakk>v = \\<langle>y\\<rangle>; y \\<notin> A \\<Gamma>;\n        y \\<in> \\<^bold>V\\<rbrakk>\n       \\<Longrightarrow> d_IN (capacity \\<Psi>) v \\<noteq> \\<top> \\<or>\n                         d_OUT (capacity \\<Psi>) v \\<noteq> \\<top>\n 3. \\<And>x.\n       \\<lbrakk>v = \\<langle>x\\<rangle>; x \\<notin> \\<^bold>V\\<rbrakk>\n       \\<Longrightarrow> d_IN (capacity \\<Psi>) v \\<noteq> \\<top> \\<or>\n                         d_OUT (capacity \\<Psi>) v \\<noteq> \\<top>", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>v = \\<langle>x\\<rangle>; x \\<in> A \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> d_IN (capacity \\<Psi>) v \\<noteq> \\<top> \\<or>\n                         d_OUT (capacity \\<Psi>) v \\<noteq> \\<top>\n 2. \\<And>y.\n       \\<lbrakk>v = \\<langle>y\\<rangle>; y \\<notin> A \\<Gamma>;\n        y \\<in> \\<^bold>V\\<rbrakk>\n       \\<Longrightarrow> d_IN (capacity \\<Psi>) v \\<noteq> \\<top> \\<or>\n                         d_OUT (capacity \\<Psi>) v \\<noteq> \\<top>\n 3. \\<And>x.\n       \\<lbrakk>v = \\<langle>x\\<rangle>; x \\<notin> \\<^bold>V\\<rbrakk>\n       \\<Longrightarrow> d_IN (capacity \\<Psi>) v \\<noteq> \\<top> \\<or>\n                         d_OUT (capacity \\<Psi>) v \\<noteq> \\<top>", "case (A x)"], ["proof (state)\nthis:\n  v = \\<langle>x\\<rangle>\n  x \\<in> A \\<Gamma>\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>v = \\<langle>x\\<rangle>; x \\<in> A \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> d_IN (capacity \\<Psi>) v \\<noteq> \\<top> \\<or>\n                         d_OUT (capacity \\<Psi>) v \\<noteq> \\<top>\n 2. \\<And>y.\n       \\<lbrakk>v = \\<langle>y\\<rangle>; y \\<notin> A \\<Gamma>;\n        y \\<in> \\<^bold>V\\<rbrakk>\n       \\<Longrightarrow> d_IN (capacity \\<Psi>) v \\<noteq> \\<top> \\<or>\n                         d_OUT (capacity \\<Psi>) v \\<noteq> \\<top>\n 3. \\<And>x.\n       \\<lbrakk>v = \\<langle>x\\<rangle>; x \\<notin> \\<^bold>V\\<rbrakk>\n       \\<Longrightarrow> d_IN (capacity \\<Psi>) v \\<noteq> \\<top> \\<or>\n                         d_OUT (capacity \\<Psi>) v \\<noteq> \\<top>", "thus ?thesis"], ["proof (prove)\nusing this:\n  v = \\<langle>x\\<rangle>\n  x \\<in> A \\<Gamma>\n\ngoal (1 subgoal):\n 1. d_IN (capacity \\<Psi>) v \\<noteq> \\<top> \\<or>\n    d_OUT (capacity \\<Psi>) v \\<noteq> \\<top>", "using capacity_A_weight[of x]"], ["proof (prove)\nusing this:\n  v = \\<langle>x\\<rangle>\n  x \\<in> A \\<Gamma>\n  x \\<in> A \\<Gamma> \\<Longrightarrow>\n  d_OUT cap \\<langle>x\\<rangle> \\<le> weight \\<Gamma> x\n\ngoal (1 subgoal):\n 1. d_IN (capacity \\<Psi>) v \\<noteq> \\<top> \\<or>\n    d_OUT (capacity \\<Psi>) v \\<noteq> \\<top>", "by (auto simp: top_unique)"], ["proof (state)\nthis:\n  d_IN (capacity \\<Psi>) v \\<noteq> \\<top> \\<or>\n  d_OUT (capacity \\<Psi>) v \\<noteq> \\<top>\n\ngoal (2 subgoals):\n 1. \\<And>y.\n       \\<lbrakk>v = \\<langle>y\\<rangle>; y \\<notin> A \\<Gamma>;\n        y \\<in> \\<^bold>V\\<rbrakk>\n       \\<Longrightarrow> d_IN (capacity \\<Psi>) v \\<noteq> \\<top> \\<or>\n                         d_OUT (capacity \\<Psi>) v \\<noteq> \\<top>\n 2. \\<And>x.\n       \\<lbrakk>v = \\<langle>x\\<rangle>; x \\<notin> \\<^bold>V\\<rbrakk>\n       \\<Longrightarrow> d_IN (capacity \\<Psi>) v \\<noteq> \\<top> \\<or>\n                         d_OUT (capacity \\<Psi>) v \\<noteq> \\<top>", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>y.\n       \\<lbrakk>v = \\<langle>y\\<rangle>; y \\<notin> A \\<Gamma>;\n        y \\<in> \\<^bold>V\\<rbrakk>\n       \\<Longrightarrow> d_IN (capacity \\<Psi>) v \\<noteq> \\<top> \\<or>\n                         d_OUT (capacity \\<Psi>) v \\<noteq> \\<top>\n 2. \\<And>x.\n       \\<lbrakk>v = \\<langle>x\\<rangle>; x \\<notin> \\<^bold>V\\<rbrakk>\n       \\<Longrightarrow> d_IN (capacity \\<Psi>) v \\<noteq> \\<top> \\<or>\n                         d_OUT (capacity \\<Psi>) v \\<noteq> \\<top>", "case (B y)"], ["proof (state)\nthis:\n  v = \\<langle>y\\<rangle>\n  y \\<notin> A \\<Gamma>\n  y \\<in> \\<^bold>V\n\ngoal (2 subgoals):\n 1. \\<And>y.\n       \\<lbrakk>v = \\<langle>y\\<rangle>; y \\<notin> A \\<Gamma>;\n        y \\<in> \\<^bold>V\\<rbrakk>\n       \\<Longrightarrow> d_IN (capacity \\<Psi>) v \\<noteq> \\<top> \\<or>\n                         d_OUT (capacity \\<Psi>) v \\<noteq> \\<top>\n 2. \\<And>x.\n       \\<lbrakk>v = \\<langle>x\\<rangle>; x \\<notin> \\<^bold>V\\<rbrakk>\n       \\<Longrightarrow> d_IN (capacity \\<Psi>) v \\<noteq> \\<top> \\<or>\n                         d_OUT (capacity \\<Psi>) v \\<noteq> \\<top>", "have \"d_IN (capacity \\<Psi>) v \\<le> (\\<Sum>\\<^sup>+ x. f (the x, y) * indicator (range Some) x + u y * indicator {None} x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN (capacity \\<Psi>) v\n    \\<le> (\\<Sum>\\<^sup>+ x.\n             f (the x, y) * indicator (range Some) x +\n             u y * indicator {None} x)", "using B disjoint bipartite_V a(1)"], ["proof (prove)\nusing this:\n  v = \\<langle>y\\<rangle>\n  y \\<notin> A \\<Gamma>\n  y \\<in> \\<^bold>V\n  A \\<Gamma> \\<inter> B \\<Gamma> = {}\n  \\<^bold>V \\<subseteq> A \\<Gamma> \\<union> B \\<Gamma>\n  a \\<in> A \\<Gamma>\n\ngoal (1 subgoal):\n 1. d_IN (capacity \\<Psi>) v\n    \\<le> (\\<Sum>\\<^sup>+ x.\n             f (the x, y) * indicator (range Some) x +\n             u y * indicator {None} x)", "unfolding d_IN_def"], ["proof (prove)\nusing this:\n  v = \\<langle>y\\<rangle>\n  y \\<notin> A \\<Gamma>\n  y \\<in> \\<^bold>V\n  A \\<Gamma> \\<inter> B \\<Gamma> = {}\n  \\<^bold>V \\<subseteq> A \\<Gamma> \\<union> B \\<Gamma>\n  a \\<in> A \\<Gamma>\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ x. capacity \\<Psi> (x, v))\n    \\<le> (\\<Sum>\\<^sup>+ x.\n             f (the x, y) * indicator (range Some) x +\n             u y * indicator {None} x)", "by(auto 4 4 intro!: nn_integral_mono simp add: nn_integral_count_space_indicator notin_range_Some currentD_outside[OF f] split: split_indicator dest: edge_antiparallel bipartite_E)"], ["proof (state)\nthis:\n  d_IN (capacity \\<Psi>) v\n  \\<le> (\\<Sum>\\<^sup>+ x.\n           f (the x, y) * indicator (range Some) x +\n           u y * indicator {None} x)\n\ngoal (2 subgoals):\n 1. \\<And>y.\n       \\<lbrakk>v = \\<langle>y\\<rangle>; y \\<notin> A \\<Gamma>;\n        y \\<in> \\<^bold>V\\<rbrakk>\n       \\<Longrightarrow> d_IN (capacity \\<Psi>) v \\<noteq> \\<top> \\<or>\n                         d_OUT (capacity \\<Psi>) v \\<noteq> \\<top>\n 2. \\<And>x.\n       \\<lbrakk>v = \\<langle>x\\<rangle>; x \\<notin> \\<^bold>V\\<rbrakk>\n       \\<Longrightarrow> d_IN (capacity \\<Psi>) v \\<noteq> \\<top> \\<or>\n                         d_OUT (capacity \\<Psi>) v \\<noteq> \\<top>", "also"], ["proof (state)\nthis:\n  d_IN (capacity \\<Psi>) v\n  \\<le> (\\<Sum>\\<^sup>+ x.\n           f (the x, y) * indicator (range Some) x +\n           u y * indicator {None} x)\n\ngoal (2 subgoals):\n 1. \\<And>y.\n       \\<lbrakk>v = \\<langle>y\\<rangle>; y \\<notin> A \\<Gamma>;\n        y \\<in> \\<^bold>V\\<rbrakk>\n       \\<Longrightarrow> d_IN (capacity \\<Psi>) v \\<noteq> \\<top> \\<or>\n                         d_OUT (capacity \\<Psi>) v \\<noteq> \\<top>\n 2. \\<And>x.\n       \\<lbrakk>v = \\<langle>x\\<rangle>; x \\<notin> \\<^bold>V\\<rbrakk>\n       \\<Longrightarrow> d_IN (capacity \\<Psi>) v \\<noteq> \\<top> \\<or>\n                         d_OUT (capacity \\<Psi>) v \\<noteq> \\<top>", "have \"\\<dots> = (\\<Sum>\\<^sup>+ x\\<in>range Some. f (the x, y)) + u y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ x.\n       f (the x, y) * indicator (range Some) x + u y * indicator {None} x) =\n    (\\<Sum>\\<^sup>+ x\\<in>range Some. f (the x, y)) + u y", "by(subst nn_integral_add)(simp_all add: nn_integral_count_space_indicator)"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ x.\n     f (the x, y) * indicator (range Some) x + u y * indicator {None} x) =\n  (\\<Sum>\\<^sup>+ x\\<in>range Some. f (the x, y)) + u y\n\ngoal (2 subgoals):\n 1. \\<And>y.\n       \\<lbrakk>v = \\<langle>y\\<rangle>; y \\<notin> A \\<Gamma>;\n        y \\<in> \\<^bold>V\\<rbrakk>\n       \\<Longrightarrow> d_IN (capacity \\<Psi>) v \\<noteq> \\<top> \\<or>\n                         d_OUT (capacity \\<Psi>) v \\<noteq> \\<top>\n 2. \\<And>x.\n       \\<lbrakk>v = \\<langle>x\\<rangle>; x \\<notin> \\<^bold>V\\<rbrakk>\n       \\<Longrightarrow> d_IN (capacity \\<Psi>) v \\<noteq> \\<top> \\<or>\n                         d_OUT (capacity \\<Psi>) v \\<noteq> \\<top>", "also"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ x.\n     f (the x, y) * indicator (range Some) x + u y * indicator {None} x) =\n  (\\<Sum>\\<^sup>+ x\\<in>range Some. f (the x, y)) + u y\n\ngoal (2 subgoals):\n 1. \\<And>y.\n       \\<lbrakk>v = \\<langle>y\\<rangle>; y \\<notin> A \\<Gamma>;\n        y \\<in> \\<^bold>V\\<rbrakk>\n       \\<Longrightarrow> d_IN (capacity \\<Psi>) v \\<noteq> \\<top> \\<or>\n                         d_OUT (capacity \\<Psi>) v \\<noteq> \\<top>\n 2. \\<And>x.\n       \\<lbrakk>v = \\<langle>x\\<rangle>; x \\<notin> \\<^bold>V\\<rbrakk>\n       \\<Longrightarrow> d_IN (capacity \\<Psi>) v \\<noteq> \\<top> \\<or>\n                         d_OUT (capacity \\<Psi>) v \\<noteq> \\<top>", "have \"\\<dots> = d_IN f y + u y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ x\\<in>range Some. f (the x, y)) + u y = d_IN f y + u y", "by(simp add: d_IN_def nn_integral_count_space_reindex)"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ x\\<in>range Some. f (the x, y)) + u y = d_IN f y + u y\n\ngoal (2 subgoals):\n 1. \\<And>y.\n       \\<lbrakk>v = \\<langle>y\\<rangle>; y \\<notin> A \\<Gamma>;\n        y \\<in> \\<^bold>V\\<rbrakk>\n       \\<Longrightarrow> d_IN (capacity \\<Psi>) v \\<noteq> \\<top> \\<or>\n                         d_OUT (capacity \\<Psi>) v \\<noteq> \\<top>\n 2. \\<And>x.\n       \\<lbrakk>v = \\<langle>x\\<rangle>; x \\<notin> \\<^bold>V\\<rbrakk>\n       \\<Longrightarrow> d_IN (capacity \\<Psi>) v \\<noteq> \\<top> \\<or>\n                         d_OUT (capacity \\<Psi>) v \\<noteq> \\<top>", "also"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ x\\<in>range Some. f (the x, y)) + u y = d_IN f y + u y\n\ngoal (2 subgoals):\n 1. \\<And>y.\n       \\<lbrakk>v = \\<langle>y\\<rangle>; y \\<notin> A \\<Gamma>;\n        y \\<in> \\<^bold>V\\<rbrakk>\n       \\<Longrightarrow> d_IN (capacity \\<Psi>) v \\<noteq> \\<top> \\<or>\n                         d_OUT (capacity \\<Psi>) v \\<noteq> \\<top>\n 2. \\<And>x.\n       \\<lbrakk>v = \\<langle>x\\<rangle>; x \\<notin> \\<^bold>V\\<rbrakk>\n       \\<Longrightarrow> d_IN (capacity \\<Psi>) v \\<noteq> \\<top> \\<or>\n                         d_OUT (capacity \\<Psi>) v \\<noteq> \\<top>", "have \"d_IN f y \\<le> weight \\<Gamma> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN f y \\<le> weight \\<Gamma> y", "using f'"], ["proof (prove)\nusing this:\n  current \\<Gamma> f\n\ngoal (1 subgoal):\n 1. d_IN f y \\<le> weight \\<Gamma> y", "by(rule currentD_weight_IN)"], ["proof (state)\nthis:\n  d_IN f y \\<le> weight \\<Gamma> y\n\ngoal (2 subgoals):\n 1. \\<And>y.\n       \\<lbrakk>v = \\<langle>y\\<rangle>; y \\<notin> A \\<Gamma>;\n        y \\<in> \\<^bold>V\\<rbrakk>\n       \\<Longrightarrow> d_IN (capacity \\<Psi>) v \\<noteq> \\<top> \\<or>\n                         d_OUT (capacity \\<Psi>) v \\<noteq> \\<top>\n 2. \\<And>x.\n       \\<lbrakk>v = \\<langle>x\\<rangle>; x \\<notin> \\<^bold>V\\<rbrakk>\n       \\<Longrightarrow> d_IN (capacity \\<Psi>) v \\<noteq> \\<top> \\<or>\n                         d_OUT (capacity \\<Psi>) v \\<noteq> \\<top>", "finally"], ["proof (chain)\npicking this:\n  (\\<And>x ya.\n      x \\<le> ya \\<Longrightarrow> x + u y \\<le> ya + u y) \\<Longrightarrow>\n  d_IN (capacity \\<Psi>) v \\<le> weight \\<Gamma> y + u y", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<And>x ya.\n      x \\<le> ya \\<Longrightarrow> x + u y \\<le> ya + u y) \\<Longrightarrow>\n  d_IN (capacity \\<Psi>) v \\<le> weight \\<Gamma> y + u y\n\ngoal (1 subgoal):\n 1. d_IN (capacity \\<Psi>) v \\<noteq> \\<top> \\<or>\n    d_OUT (capacity \\<Psi>) v \\<noteq> \\<top>", "by(auto simp add: add_right_mono top_unique split: if_split_asm)"], ["proof (state)\nthis:\n  d_IN (capacity \\<Psi>) v \\<noteq> \\<top> \\<or>\n  d_OUT (capacity \\<Psi>) v \\<noteq> \\<top>\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>v = \\<langle>x\\<rangle>; x \\<notin> \\<^bold>V\\<rbrakk>\n       \\<Longrightarrow> d_IN (capacity \\<Psi>) v \\<noteq> \\<top> \\<or>\n                         d_OUT (capacity \\<Psi>) v \\<noteq> \\<top>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>v = \\<langle>x\\<rangle>; x \\<notin> \\<^bold>V\\<rbrakk>\n       \\<Longrightarrow> d_IN (capacity \\<Psi>) v \\<noteq> \\<top> \\<or>\n                         d_OUT (capacity \\<Psi>) v \\<noteq> \\<top>", "case outside"], ["proof (state)\nthis:\n  v = \\<langle>x\\<rangle>\n  x \\<notin> \\<^bold>V\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>v = \\<langle>x\\<rangle>; x \\<notin> \\<^bold>V\\<rbrakk>\n       \\<Longrightarrow> d_IN (capacity \\<Psi>) v \\<noteq> \\<top> \\<or>\n                         d_OUT (capacity \\<Psi>) v \\<noteq> \\<top>", "hence \"d_OUT (capacity \\<Psi>) v = 0\""], ["proof (prove)\nusing this:\n  v = \\<langle>x\\<rangle>\n  x \\<notin> \\<^bold>V\n\ngoal (1 subgoal):\n 1. d_OUT (capacity \\<Psi>) v = 0", "by(auto simp add: d_OUT_def nn_integral_0_iff_AE AE_count_space cap_def vertex_def split: option.split)"], ["proof (state)\nthis:\n  d_OUT (capacity \\<Psi>) v = 0\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>v = \\<langle>x\\<rangle>; x \\<notin> \\<^bold>V\\<rbrakk>\n       \\<Longrightarrow> d_IN (capacity \\<Psi>) v \\<noteq> \\<top> \\<or>\n                         d_OUT (capacity \\<Psi>) v \\<noteq> \\<top>", "thus ?thesis"], ["proof (prove)\nusing this:\n  d_OUT (capacity \\<Psi>) v = 0\n\ngoal (1 subgoal):\n 1. d_IN (capacity \\<Psi>) v \\<noteq> \\<top> \\<or>\n    d_OUT (capacity \\<Psi>) v \\<noteq> \\<top>", "by simp"], ["proof (state)\nthis:\n  d_IN (capacity \\<Psi>) v \\<noteq> \\<top> \\<or>\n  d_OUT (capacity \\<Psi>) v \\<noteq> \\<top>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  d_IN (capacity \\<Psi>) v \\<noteq> \\<top> \\<or>\n  d_OUT (capacity \\<Psi>) v \\<noteq> \\<top>\n\ngoal (5 subgoals):\n 1. source \\<Psi> \\<noteq> sink \\<Psi>\n 2. \\<And>e.\n       e \\<notin> \\<^bold>E\\<^bsub>\\<Psi>\\<^esub> \\<Longrightarrow>\n       capacity \\<Psi> e = 0\n 3. \\<And>e. capacity \\<Psi> e \\<noteq> \\<top>\n 4. \\<And>x. \\<not> edge \\<Psi> x x\n 5. \\<And>x. \\<not> edge \\<Psi> x (source \\<Psi>)", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. source \\<Psi> \\<noteq> sink \\<Psi>\n 2. \\<And>e.\n       e \\<notin> \\<^bold>E\\<^bsub>\\<Psi>\\<^esub> \\<Longrightarrow>\n       capacity \\<Psi> e = 0\n 3. \\<And>e. capacity \\<Psi> e \\<noteq> \\<top>\n 4. \\<And>x. \\<not> edge \\<Psi> x x\n 5. \\<And>x. \\<not> edge \\<Psi> x (source \\<Psi>)", "show \"capacity \\<Psi> e \\<noteq> \\<top>\" for e"], ["proof (prove)\ngoal (1 subgoal):\n 1. capacity \\<Psi> e \\<noteq> \\<top>", "using weight_finite"], ["proof (prove)\nusing this:\n  weight \\<Gamma> ?x \\<noteq> \\<top>\n\ngoal (1 subgoal):\n 1. capacity \\<Psi> e \\<noteq> \\<top>", "by(auto simp add: cap_def max_def vertex_def currentD_finite[OF f'] split: option.split prod.split simp del: weight_finite)"], ["proof (state)\nthis:\n  capacity \\<Psi> ?e \\<noteq> \\<top>\n\ngoal (4 subgoals):\n 1. source \\<Psi> \\<noteq> sink \\<Psi>\n 2. \\<And>e.\n       e \\<notin> \\<^bold>E\\<^bsub>\\<Psi>\\<^esub> \\<Longrightarrow>\n       capacity \\<Psi> e = 0\n 3. \\<And>x. \\<not> edge \\<Psi> x x\n 4. \\<And>x. \\<not> edge \\<Psi> x (source \\<Psi>)", "show \"capacity \\<Psi> e = 0\" if \"e \\<notin> \\<^bold>E\\<^bsub>\\<Psi>\\<^esub>\" for e"], ["proof (prove)\ngoal (1 subgoal):\n 1. capacity \\<Psi> e = 0", "using that bipartite_V disjoint"], ["proof (prove)\nusing this:\n  e \\<notin> \\<^bold>E\\<^bsub>\\<Psi>\\<^esub>\n  \\<^bold>V \\<subseteq> A \\<Gamma> \\<union> B \\<Gamma>\n  A \\<Gamma> \\<inter> B \\<Gamma> = {}\n\ngoal (1 subgoal):\n 1. capacity \\<Psi> e = 0", "by(auto simp add: cap_def max_def intro: u_outside split: option.split prod.split)"], ["proof (state)\nthis:\n  ?e \\<notin> \\<^bold>E\\<^bsub>\\<Psi>\\<^esub> \\<Longrightarrow>\n  capacity \\<Psi> ?e = 0\n\ngoal (3 subgoals):\n 1. source \\<Psi> \\<noteq> sink \\<Psi>\n 2. \\<And>x. \\<not> edge \\<Psi> x x\n 3. \\<And>x. \\<not> edge \\<Psi> x (source \\<Psi>)", "show \"\\<not> edge \\<Psi> x (source \\<Psi>)\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> edge \\<Psi> x (source \\<Psi>)", "by simp"], ["proof (state)\nthis:\n  \\<not> edge \\<Psi> ?x (source \\<Psi>)\n\ngoal (2 subgoals):\n 1. source \\<Psi> \\<noteq> sink \\<Psi>\n 2. \\<And>x. \\<not> edge \\<Psi> x x", "show \"\\<not> edge \\<Psi> x x\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> edge \\<Psi> x x", "by(cases x)(simp_all add: no_loop)"], ["proof (state)\nthis:\n  \\<not> edge \\<Psi> ?x ?x\n\ngoal (1 subgoal):\n 1. source \\<Psi> \\<noteq> sink \\<Psi>", "show \"source \\<Psi> \\<noteq> sink \\<Psi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. source \\<Psi> \\<noteq> sink \\<Psi>", "by simp"], ["proof (state)\nthis:\n  source \\<Psi> \\<noteq> sink \\<Psi>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  flow_attainability \\<Psi>\n\ngoal (1 subgoal):\n 1. hindered \\<Gamma>", "then"], ["proof (chain)\npicking this:\n  flow_attainability \\<Psi>", "interpret \\<Psi>: flow_attainability \"\\<Psi>\""], ["proof (prove)\nusing this:\n  flow_attainability \\<Psi>\n\ngoal (1 subgoal):\n 1. flow_attainability \\<Psi>", "."], ["proof (state)\ngoal (1 subgoal):\n 1. hindered \\<Gamma>", "define \\<alpha> where \"\\<alpha> = (\\<Squnion>g\\<in>{g. flow \\<Psi> g}. value_flow \\<Psi> g)\""], ["proof (state)\nthis:\n  \\<alpha> = \\<Squnion> (value_flow \\<Psi> ` {g. flow \\<Psi> g})\n\ngoal (1 subgoal):\n 1. hindered \\<Gamma>", "have \\<alpha>_le: \"\\<alpha> \\<le> \\<epsilon>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha> \\<le> \\<epsilon>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<alpha> \\<le> \\<epsilon>", "have \"\\<alpha> \\<le> d_OUT cap None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha> \\<le> d_OUT cap None", "unfolding \\<alpha>_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Squnion> (value_flow \\<Psi> ` Collect (flow \\<Psi>))\n    \\<le> d_OUT cap None", "by(rule SUP_least)(auto intro!: d_OUT_mono dest: flowD_capacity)"], ["proof (state)\nthis:\n  \\<alpha> \\<le> d_OUT cap None\n\ngoal (1 subgoal):\n 1. \\<alpha> \\<le> \\<epsilon>", "also"], ["proof (state)\nthis:\n  \\<alpha> \\<le> d_OUT cap None\n\ngoal (1 subgoal):\n 1. \\<alpha> \\<le> \\<epsilon>", "have \"\\<dots> \\<le> \\<integral>\\<^sup>+ y. cap (None, y) \\<partial>count_space (range Some)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT cap None \\<le> (\\<Sum>\\<^sup>+ y\\<in>range Some. cap (None, y))", "unfolding d_OUT_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y. cap (None, y))\n    \\<le> (\\<Sum>\\<^sup>+ y\\<in>range Some. cap (None, y))", "by(auto simp add: nn_integral_count_space_indicator notin_range_Some intro!: nn_integral_mono split: split_indicator)"], ["proof (state)\nthis:\n  d_OUT cap None \\<le> (\\<Sum>\\<^sup>+ y\\<in>range Some. cap (None, y))\n\ngoal (1 subgoal):\n 1. \\<alpha> \\<le> \\<epsilon>", "also"], ["proof (state)\nthis:\n  d_OUT cap None \\<le> (\\<Sum>\\<^sup>+ y\\<in>range Some. cap (None, y))\n\ngoal (1 subgoal):\n 1. \\<alpha> \\<le> \\<epsilon>", "have \"\\<dots> \\<le> \\<epsilon>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y\\<in>range Some. cap (None, y)) \\<le> \\<epsilon>", "unfolding \\<epsilon>_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y\\<in>range Some. cap (None, y))\n    \\<le> integral\\<^sup>N (count_space (B \\<Gamma>)) u", "by (subst (2) nn_integral_count_space_indicator, auto simp add: nn_integral_count_space_reindex u_outside intro!: nn_integral_mono split: split_indicator)"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y\\<in>range Some. cap (None, y)) \\<le> \\<epsilon>\n\ngoal (1 subgoal):\n 1. \\<alpha> \\<le> \\<epsilon>", "finally"], ["proof (chain)\npicking this:\n  \\<alpha> \\<le> \\<epsilon>", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<alpha> \\<le> \\<epsilon>\n\ngoal (1 subgoal):\n 1. \\<alpha> \\<le> \\<epsilon>", "by simp"], ["proof (state)\nthis:\n  \\<alpha> \\<le> \\<epsilon>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<alpha> \\<le> \\<epsilon>\n\ngoal (1 subgoal):\n 1. hindered \\<Gamma>", "then"], ["proof (chain)\npicking this:\n  \\<alpha> \\<le> \\<epsilon>", "have finite_flow: \"\\<alpha> \\<noteq> \\<top>\""], ["proof (prove)\nusing this:\n  \\<alpha> \\<le> \\<epsilon>\n\ngoal (1 subgoal):\n 1. \\<alpha> \\<noteq> \\<top>", "using finite_\\<epsilon>"], ["proof (prove)\nusing this:\n  \\<alpha> \\<le> \\<epsilon>\n  \\<epsilon> \\<noteq> \\<top>\n\ngoal (1 subgoal):\n 1. \\<alpha> \\<noteq> \\<top>", "by (auto simp: top_unique)"], ["proof (state)\nthis:\n  \\<alpha> \\<noteq> \\<top>\n\ngoal (1 subgoal):\n 1. hindered \\<Gamma>", "from \\<Psi>.ex_max_flow"], ["proof (chain)\npicking this:\n  \\<exists>f.\n     flow \\<Psi> f \\<and>\n     value_flow \\<Psi> f =\n     \\<Squnion> (value_flow \\<Psi> ` {g. flow \\<Psi> g}) \\<and>\n     (\\<forall>x. d_IN f x \\<le> value_flow \\<Psi> f)", "obtain j where j: \"flow \\<Psi> j\"\n    and value_j: \"value_flow \\<Psi> j = \\<alpha>\"\n    and IN_j: \"\\<And>x. d_IN j x \\<le> \\<alpha>\""], ["proof (prove)\nusing this:\n  \\<exists>f.\n     flow \\<Psi> f \\<and>\n     value_flow \\<Psi> f =\n     \\<Squnion> (value_flow \\<Psi> ` {g. flow \\<Psi> g}) \\<and>\n     (\\<forall>x. d_IN f x \\<le> value_flow \\<Psi> f)\n\ngoal (1 subgoal):\n 1. (\\<And>j.\n        \\<lbrakk>flow \\<Psi> j; value_flow \\<Psi> j = \\<alpha>;\n         \\<And>x. d_IN j x \\<le> \\<alpha>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding \\<alpha>_def"], ["proof (prove)\nusing this:\n  \\<exists>f.\n     flow \\<Psi> f \\<and>\n     value_flow \\<Psi> f =\n     \\<Squnion> (value_flow \\<Psi> ` {g. flow \\<Psi> g}) \\<and>\n     (\\<forall>x. d_IN f x \\<le> value_flow \\<Psi> f)\n\ngoal (1 subgoal):\n 1. (\\<And>j.\n        \\<lbrakk>flow \\<Psi> j;\n         value_flow \\<Psi> j =\n         \\<Squnion> (value_flow \\<Psi> ` Collect (flow \\<Psi>));\n         \\<And>x.\n            d_IN j x\n            \\<le> \\<Squnion> (value_flow \\<Psi> `\n                              Collect (flow \\<Psi>))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  flow \\<Psi> j\n  value_flow \\<Psi> j = \\<alpha>\n  d_IN j ?x \\<le> \\<alpha>\n\ngoal (1 subgoal):\n 1. hindered \\<Gamma>", "have j_le_f: \"j (Some x, Some y) \\<le> f (x, y)\" if \"edge \\<Gamma> x y\" for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. j (\\<langle>x\\<rangle>, \\<langle>y\\<rangle>) \\<le> f (x, y)", "using that flowD_capacity[OF j, of \"(Some x, Some y)\"] a(1) disjoint"], ["proof (prove)\nusing this:\n  edge \\<Gamma> x y\n  j (\\<langle>x\\<rangle>, \\<langle>y\\<rangle>)\n  \\<le> capacity \\<Psi> (\\<langle>x\\<rangle>, \\<langle>y\\<rangle>)\n  a \\<in> A \\<Gamma>\n  A \\<Gamma> \\<inter> B \\<Gamma> = {}\n\ngoal (1 subgoal):\n 1. j (\\<langle>x\\<rangle>, \\<langle>y\\<rangle>) \\<le> f (x, y)", "by(auto split: if_split_asm dest: bipartite_E intro: order_trans)"], ["proof (state)\nthis:\n  edge \\<Gamma> ?x ?y \\<Longrightarrow>\n  j (\\<langle>?x\\<rangle>, \\<langle>?y\\<rangle>) \\<le> f (?x, ?y)\n\ngoal (1 subgoal):\n 1. hindered \\<Gamma>", "have IN_j_finite [simp]: \"d_IN j x \\<noteq> \\<top>\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN j x \\<noteq> \\<top>", "using finite_flow"], ["proof (prove)\nusing this:\n  \\<alpha> \\<noteq> \\<top>\n\ngoal (1 subgoal):\n 1. d_IN j x \\<noteq> \\<top>", "by(rule neq_top_trans)(simp add: IN_j)"], ["proof (state)\nthis:\n  d_IN j ?x \\<noteq> \\<top>\n\ngoal (1 subgoal):\n 1. hindered \\<Gamma>", "have j_finite[simp]: \"j (x, y) < \\<top>\" for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. j (x, y) < \\<top>", "by (rule le_less_trans[OF d_IN_ge_point]) (simp add: IN_j_finite[of y] less_top[symmetric])"], ["proof (state)\nthis:\n  j (?x, ?y) < \\<top>\n\ngoal (1 subgoal):\n 1. hindered \\<Gamma>", "have OUT_j_finite: \"d_OUT j x \\<noteq> \\<top>\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT j x \\<noteq> \\<top>", "proof(cases \"x = source \\<Psi> \\<or> x = sink \\<Psi>\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x = source \\<Psi> \\<or> x = sink \\<Psi> \\<Longrightarrow>\n    d_OUT j x \\<noteq> \\<top>\n 2. \\<not> (x = source \\<Psi> \\<or> x = sink \\<Psi>) \\<Longrightarrow>\n    d_OUT j x \\<noteq> \\<top>", "case True"], ["proof (state)\nthis:\n  x = source \\<Psi> \\<or> x = sink \\<Psi>\n\ngoal (2 subgoals):\n 1. x = source \\<Psi> \\<or> x = sink \\<Psi> \\<Longrightarrow>\n    d_OUT j x \\<noteq> \\<top>\n 2. \\<not> (x = source \\<Psi> \\<or> x = sink \\<Psi>) \\<Longrightarrow>\n    d_OUT j x \\<noteq> \\<top>", "thus ?thesis"], ["proof (prove)\nusing this:\n  x = source \\<Psi> \\<or> x = sink \\<Psi>\n\ngoal (1 subgoal):\n 1. d_OUT j x \\<noteq> \\<top>", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. x = source \\<Psi> \\<Longrightarrow> d_OUT j x \\<noteq> \\<top>\n 2. x = sink \\<Psi> \\<Longrightarrow> d_OUT j x \\<noteq> \\<top>", "case left"], ["proof (state)\nthis:\n  x = source \\<Psi>\n\ngoal (2 subgoals):\n 1. x = source \\<Psi> \\<Longrightarrow> d_OUT j x \\<noteq> \\<top>\n 2. x = sink \\<Psi> \\<Longrightarrow> d_OUT j x \\<noteq> \\<top>", "thus ?thesis"], ["proof (prove)\nusing this:\n  x = source \\<Psi>\n\ngoal (1 subgoal):\n 1. d_OUT j x \\<noteq> \\<top>", "using finite_flow value_j"], ["proof (prove)\nusing this:\n  x = source \\<Psi>\n  \\<alpha> \\<noteq> \\<top>\n  value_flow \\<Psi> j = \\<alpha>\n\ngoal (1 subgoal):\n 1. d_OUT j x \\<noteq> \\<top>", "by simp"], ["proof (state)\nthis:\n  d_OUT j x \\<noteq> \\<top>\n\ngoal (1 subgoal):\n 1. x = sink \\<Psi> \\<Longrightarrow> d_OUT j x \\<noteq> \\<top>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x = sink \\<Psi> \\<Longrightarrow> d_OUT j x \\<noteq> \\<top>", "case right"], ["proof (state)\nthis:\n  x = sink \\<Psi>\n\ngoal (1 subgoal):\n 1. x = sink \\<Psi> \\<Longrightarrow> d_OUT j x \\<noteq> \\<top>", "have \"d_OUT (capacity \\<Psi>) \\<langle>a\\<rangle> \\<noteq> \\<top>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT (capacity \\<Psi>) \\<langle>a\\<rangle> \\<noteq> \\<top>", "using capacity_A_weight[of a] a(1)"], ["proof (prove)\nusing this:\n  a \\<in> A \\<Gamma> \\<Longrightarrow>\n  d_OUT cap \\<langle>a\\<rangle> \\<le> weight \\<Gamma> a\n  a \\<in> A \\<Gamma>\n\ngoal (1 subgoal):\n 1. d_OUT (capacity \\<Psi>) \\<langle>a\\<rangle> \\<noteq> \\<top>", "by(auto simp: top_unique)"], ["proof (state)\nthis:\n  d_OUT (capacity \\<Psi>) \\<langle>a\\<rangle> \\<noteq> \\<top>\n\ngoal (1 subgoal):\n 1. x = sink \\<Psi> \\<Longrightarrow> d_OUT j x \\<noteq> \\<top>", "thus ?thesis"], ["proof (prove)\nusing this:\n  d_OUT (capacity \\<Psi>) \\<langle>a\\<rangle> \\<noteq> \\<top>\n\ngoal (1 subgoal):\n 1. d_OUT j x \\<noteq> \\<top>", "unfolding right[simplified]"], ["proof (prove)\nusing this:\n  d_OUT (capacity \\<Psi>) \\<langle>a\\<rangle> \\<noteq> \\<top>\n\ngoal (1 subgoal):\n 1. d_OUT j \\<langle>a\\<rangle> \\<noteq> \\<top>", "by(rule neq_top_trans)(rule d_OUT_mono flowD_capacity[OF j])+"], ["proof (state)\nthis:\n  d_OUT j x \\<noteq> \\<top>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  d_OUT j x \\<noteq> \\<top>\n\ngoal (1 subgoal):\n 1. \\<not> (x = source \\<Psi> \\<or> x = sink \\<Psi>) \\<Longrightarrow>\n    d_OUT j x \\<noteq> \\<top>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (x = source \\<Psi> \\<or> x = sink \\<Psi>) \\<Longrightarrow>\n    d_OUT j x \\<noteq> \\<top>", "case False"], ["proof (state)\nthis:\n  \\<not> (x = source \\<Psi> \\<or> x = sink \\<Psi>)\n\ngoal (1 subgoal):\n 1. \\<not> (x = source \\<Psi> \\<or> x = sink \\<Psi>) \\<Longrightarrow>\n    d_OUT j x \\<noteq> \\<top>", "then"], ["proof (chain)\npicking this:\n  \\<not> (x = source \\<Psi> \\<or> x = sink \\<Psi>)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> (x = source \\<Psi> \\<or> x = sink \\<Psi>)\n\ngoal (1 subgoal):\n 1. d_OUT j x \\<noteq> \\<top>", "by(simp add: flowD_KIR[OF j])"], ["proof (state)\nthis:\n  d_OUT j x \\<noteq> \\<top>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  d_OUT j ?x \\<noteq> \\<top>\n\ngoal (1 subgoal):\n 1. hindered \\<Gamma>", "have IN_j_le_weight: \"d_IN j \\<langle>x\\<rangle> \\<le> weight \\<Gamma> x\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN j \\<langle>x\\<rangle> \\<le> weight \\<Gamma> x", "proof(cases \"x \\<in> A \\<Gamma>\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<in> A \\<Gamma> \\<Longrightarrow>\n    d_IN j \\<langle>x\\<rangle> \\<le> weight \\<Gamma> x\n 2. x \\<notin> A \\<Gamma> \\<Longrightarrow>\n    d_IN j \\<langle>x\\<rangle> \\<le> weight \\<Gamma> x", "case xA: True"], ["proof (state)\nthis:\n  x \\<in> A \\<Gamma>\n\ngoal (2 subgoals):\n 1. x \\<in> A \\<Gamma> \\<Longrightarrow>\n    d_IN j \\<langle>x\\<rangle> \\<le> weight \\<Gamma> x\n 2. x \\<notin> A \\<Gamma> \\<Longrightarrow>\n    d_IN j \\<langle>x\\<rangle> \\<le> weight \\<Gamma> x", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN j \\<langle>x\\<rangle> \\<le> weight \\<Gamma> x", "proof(cases \"x = a\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x = a \\<Longrightarrow>\n    d_IN j \\<langle>x\\<rangle> \\<le> weight \\<Gamma> x\n 2. x \\<noteq> a \\<Longrightarrow>\n    d_IN j \\<langle>x\\<rangle> \\<le> weight \\<Gamma> x", "case True"], ["proof (state)\nthis:\n  x = a\n\ngoal (2 subgoals):\n 1. x = a \\<Longrightarrow>\n    d_IN j \\<langle>x\\<rangle> \\<le> weight \\<Gamma> x\n 2. x \\<noteq> a \\<Longrightarrow>\n    d_IN j \\<langle>x\\<rangle> \\<le> weight \\<Gamma> x", "have \"d_IN j \\<langle>x\\<rangle> \\<le> \\<alpha>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN j \\<langle>x\\<rangle> \\<le> \\<alpha>", "by(rule IN_j)"], ["proof (state)\nthis:\n  d_IN j \\<langle>x\\<rangle> \\<le> \\<alpha>\n\ngoal (2 subgoals):\n 1. x = a \\<Longrightarrow>\n    d_IN j \\<langle>x\\<rangle> \\<le> weight \\<Gamma> x\n 2. x \\<noteq> a \\<Longrightarrow>\n    d_IN j \\<langle>x\\<rangle> \\<le> weight \\<Gamma> x", "also"], ["proof (state)\nthis:\n  d_IN j \\<langle>x\\<rangle> \\<le> \\<alpha>\n\ngoal (2 subgoals):\n 1. x = a \\<Longrightarrow>\n    d_IN j \\<langle>x\\<rangle> \\<le> weight \\<Gamma> x\n 2. x \\<noteq> a \\<Longrightarrow>\n    d_IN j \\<langle>x\\<rangle> \\<le> weight \\<Gamma> x", "have \"\\<dots> \\<le> \\<epsilon>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha> \\<le> \\<epsilon>", "by(rule \\<alpha>_le)"], ["proof (state)\nthis:\n  \\<alpha> \\<le> \\<epsilon>\n\ngoal (2 subgoals):\n 1. x = a \\<Longrightarrow>\n    d_IN j \\<langle>x\\<rangle> \\<le> weight \\<Gamma> x\n 2. x \\<noteq> a \\<Longrightarrow>\n    d_IN j \\<langle>x\\<rangle> \\<le> weight \\<Gamma> x", "also"], ["proof (state)\nthis:\n  \\<alpha> \\<le> \\<epsilon>\n\ngoal (2 subgoals):\n 1. x = a \\<Longrightarrow>\n    d_IN j \\<langle>x\\<rangle> \\<le> weight \\<Gamma> x\n 2. x \\<noteq> a \\<Longrightarrow>\n    d_IN j \\<langle>x\\<rangle> \\<le> weight \\<Gamma> x", "have \"\\<epsilon> < weight \\<Gamma> a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<epsilon> < weight \\<Gamma> a", "using \\<epsilon>_less diff_le_self_ennreal less_le_trans"], ["proof (prove)\nusing this:\n  \\<epsilon> < weight \\<Gamma> a - d_OUT f a\n  ?a - ?b \\<le> ?a\n  \\<lbrakk>?x < ?y; ?y \\<le> ?z\\<rbrakk> \\<Longrightarrow> ?x < ?z\n\ngoal (1 subgoal):\n 1. \\<epsilon> < weight \\<Gamma> a", "by blast"], ["proof (state)\nthis:\n  \\<epsilon> < weight \\<Gamma> a\n\ngoal (2 subgoals):\n 1. x = a \\<Longrightarrow>\n    d_IN j \\<langle>x\\<rangle> \\<le> weight \\<Gamma> x\n 2. x \\<noteq> a \\<Longrightarrow>\n    d_IN j \\<langle>x\\<rangle> \\<le> weight \\<Gamma> x", "finally"], ["proof (chain)\npicking this:\n  d_IN j \\<langle>x\\<rangle> < weight \\<Gamma> a", "show ?thesis"], ["proof (prove)\nusing this:\n  d_IN j \\<langle>x\\<rangle> < weight \\<Gamma> a\n\ngoal (1 subgoal):\n 1. d_IN j \\<langle>x\\<rangle> \\<le> weight \\<Gamma> x", "using True"], ["proof (prove)\nusing this:\n  d_IN j \\<langle>x\\<rangle> < weight \\<Gamma> a\n  x = a\n\ngoal (1 subgoal):\n 1. d_IN j \\<langle>x\\<rangle> \\<le> weight \\<Gamma> x", "by(auto intro: order.strict_implies_order)"], ["proof (state)\nthis:\n  d_IN j \\<langle>x\\<rangle> \\<le> weight \\<Gamma> x\n\ngoal (1 subgoal):\n 1. x \\<noteq> a \\<Longrightarrow>\n    d_IN j \\<langle>x\\<rangle> \\<le> weight \\<Gamma> x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<noteq> a \\<Longrightarrow>\n    d_IN j \\<langle>x\\<rangle> \\<le> weight \\<Gamma> x", "case False"], ["proof (state)\nthis:\n  x \\<noteq> a\n\ngoal (1 subgoal):\n 1. x \\<noteq> a \\<Longrightarrow>\n    d_IN j \\<langle>x\\<rangle> \\<le> weight \\<Gamma> x", "have \"d_IN j \\<langle>x\\<rangle> = d_OUT j \\<langle>x\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN j \\<langle>x\\<rangle> = d_OUT j \\<langle>x\\<rangle>", "using flowD_KIR[OF j, of \"Some x\"] False"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<langle>x\\<rangle> \\<noteq> source \\<Psi>;\n   \\<langle>x\\<rangle> \\<noteq> sink \\<Psi>\\<rbrakk>\n  \\<Longrightarrow> KIR j \\<langle>x\\<rangle>\n  x \\<noteq> a\n\ngoal (1 subgoal):\n 1. d_IN j \\<langle>x\\<rangle> = d_OUT j \\<langle>x\\<rangle>", "by simp"], ["proof (state)\nthis:\n  d_IN j \\<langle>x\\<rangle> = d_OUT j \\<langle>x\\<rangle>\n\ngoal (1 subgoal):\n 1. x \\<noteq> a \\<Longrightarrow>\n    d_IN j \\<langle>x\\<rangle> \\<le> weight \\<Gamma> x", "also"], ["proof (state)\nthis:\n  d_IN j \\<langle>x\\<rangle> = d_OUT j \\<langle>x\\<rangle>\n\ngoal (1 subgoal):\n 1. x \\<noteq> a \\<Longrightarrow>\n    d_IN j \\<langle>x\\<rangle> \\<le> weight \\<Gamma> x", "have \"\\<dots> \\<le> d_OUT cap \\<langle>x\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT j \\<langle>x\\<rangle> \\<le> d_OUT cap \\<langle>x\\<rangle>", "using flowD_capacity[OF j]"], ["proof (prove)\nusing this:\n  j ?e \\<le> capacity \\<Psi> ?e\n\ngoal (1 subgoal):\n 1. d_OUT j \\<langle>x\\<rangle> \\<le> d_OUT cap \\<langle>x\\<rangle>", "by(auto intro: d_OUT_mono)"], ["proof (state)\nthis:\n  d_OUT j \\<langle>x\\<rangle> \\<le> d_OUT cap \\<langle>x\\<rangle>\n\ngoal (1 subgoal):\n 1. x \\<noteq> a \\<Longrightarrow>\n    d_IN j \\<langle>x\\<rangle> \\<le> weight \\<Gamma> x", "also"], ["proof (state)\nthis:\n  d_OUT j \\<langle>x\\<rangle> \\<le> d_OUT cap \\<langle>x\\<rangle>\n\ngoal (1 subgoal):\n 1. x \\<noteq> a \\<Longrightarrow>\n    d_IN j \\<langle>x\\<rangle> \\<le> weight \\<Gamma> x", "have \"\\<dots> \\<le> weight \\<Gamma> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT cap \\<langle>x\\<rangle> \\<le> weight \\<Gamma> x", "using xA"], ["proof (prove)\nusing this:\n  x \\<in> A \\<Gamma>\n\ngoal (1 subgoal):\n 1. d_OUT cap \\<langle>x\\<rangle> \\<le> weight \\<Gamma> x", "by(rule capacity_A_weight)"], ["proof (state)\nthis:\n  d_OUT cap \\<langle>x\\<rangle> \\<le> weight \\<Gamma> x\n\ngoal (1 subgoal):\n 1. x \\<noteq> a \\<Longrightarrow>\n    d_IN j \\<langle>x\\<rangle> \\<le> weight \\<Gamma> x", "finally"], ["proof (chain)\npicking this:\n  d_IN j \\<langle>x\\<rangle> \\<le> weight \\<Gamma> x", "show ?thesis"], ["proof (prove)\nusing this:\n  d_IN j \\<langle>x\\<rangle> \\<le> weight \\<Gamma> x\n\ngoal (1 subgoal):\n 1. d_IN j \\<langle>x\\<rangle> \\<le> weight \\<Gamma> x", "."], ["proof (state)\nthis:\n  d_IN j \\<langle>x\\<rangle> \\<le> weight \\<Gamma> x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  d_IN j \\<langle>x\\<rangle> \\<le> weight \\<Gamma> x\n\ngoal (1 subgoal):\n 1. x \\<notin> A \\<Gamma> \\<Longrightarrow>\n    d_IN j \\<langle>x\\<rangle> \\<le> weight \\<Gamma> x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<notin> A \\<Gamma> \\<Longrightarrow>\n    d_IN j \\<langle>x\\<rangle> \\<le> weight \\<Gamma> x", "case xA: False"], ["proof (state)\nthis:\n  x \\<notin> A \\<Gamma>\n\ngoal (1 subgoal):\n 1. x \\<notin> A \\<Gamma> \\<Longrightarrow>\n    d_IN j \\<langle>x\\<rangle> \\<le> weight \\<Gamma> x", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN j \\<langle>x\\<rangle> \\<le> weight \\<Gamma> x", "proof(cases \"x \\<in> B \\<Gamma>\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<in> B \\<Gamma> \\<Longrightarrow>\n    d_IN j \\<langle>x\\<rangle> \\<le> weight \\<Gamma> x\n 2. x \\<notin> B \\<Gamma> \\<Longrightarrow>\n    d_IN j \\<langle>x\\<rangle> \\<le> weight \\<Gamma> x", "case True"], ["proof (state)\nthis:\n  x \\<in> B \\<Gamma>\n\ngoal (2 subgoals):\n 1. x \\<in> B \\<Gamma> \\<Longrightarrow>\n    d_IN j \\<langle>x\\<rangle> \\<le> weight \\<Gamma> x\n 2. x \\<notin> B \\<Gamma> \\<Longrightarrow>\n    d_IN j \\<langle>x\\<rangle> \\<le> weight \\<Gamma> x", "have \"d_IN j \\<langle>x\\<rangle> \\<le> d_IN cap \\<langle>x\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN j \\<langle>x\\<rangle> \\<le> d_IN cap \\<langle>x\\<rangle>", "using flowD_capacity[OF j]"], ["proof (prove)\nusing this:\n  j ?e \\<le> capacity \\<Psi> ?e\n\ngoal (1 subgoal):\n 1. d_IN j \\<langle>x\\<rangle> \\<le> d_IN cap \\<langle>x\\<rangle>", "by(auto intro: d_IN_mono)"], ["proof (state)\nthis:\n  d_IN j \\<langle>x\\<rangle> \\<le> d_IN cap \\<langle>x\\<rangle>\n\ngoal (2 subgoals):\n 1. x \\<in> B \\<Gamma> \\<Longrightarrow>\n    d_IN j \\<langle>x\\<rangle> \\<le> weight \\<Gamma> x\n 2. x \\<notin> B \\<Gamma> \\<Longrightarrow>\n    d_IN j \\<langle>x\\<rangle> \\<le> weight \\<Gamma> x", "also"], ["proof (state)\nthis:\n  d_IN j \\<langle>x\\<rangle> \\<le> d_IN cap \\<langle>x\\<rangle>\n\ngoal (2 subgoals):\n 1. x \\<in> B \\<Gamma> \\<Longrightarrow>\n    d_IN j \\<langle>x\\<rangle> \\<le> weight \\<Gamma> x\n 2. x \\<notin> B \\<Gamma> \\<Longrightarrow>\n    d_IN j \\<langle>x\\<rangle> \\<le> weight \\<Gamma> x", "have \"\\<dots> \\<le> (\\<Sum>\\<^sup>+ z. f (the z, x) * indicator (range Some) z) + (\\<Sum>\\<^sup>+ z :: 'v option. u x * indicator {None} z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN cap \\<langle>x\\<rangle>\n    \\<le> (\\<integral>\\<^sup>+z\\<in>range Some. f (the z, x)\n           \\<partial>count_space UNIV) +\n          (\\<integral>\\<^sup>+z\\<in>{None}. u x\\<partial>count_space UNIV)", "using True disjoint"], ["proof (prove)\nusing this:\n  x \\<in> B \\<Gamma>\n  A \\<Gamma> \\<inter> B \\<Gamma> = {}\n\ngoal (1 subgoal):\n 1. d_IN cap \\<langle>x\\<rangle>\n    \\<le> (\\<integral>\\<^sup>+z\\<in>range Some. f (the z, x)\n           \\<partial>count_space UNIV) +\n          (\\<integral>\\<^sup>+z\\<in>{None}. u x\\<partial>count_space UNIV)", "by(subst nn_integral_add[symmetric])(auto simp add: vertex_def currentD_outside[OF f] d_IN_def B_out intro!: nn_integral_mono split: split_indicator)"], ["proof (state)\nthis:\n  d_IN cap \\<langle>x\\<rangle>\n  \\<le> (\\<integral>\\<^sup>+z\\<in>range Some. f (the z, x)\n         \\<partial>count_space UNIV) +\n        (\\<integral>\\<^sup>+z\\<in>{None}. u x\\<partial>count_space UNIV)\n\ngoal (2 subgoals):\n 1. x \\<in> B \\<Gamma> \\<Longrightarrow>\n    d_IN j \\<langle>x\\<rangle> \\<le> weight \\<Gamma> x\n 2. x \\<notin> B \\<Gamma> \\<Longrightarrow>\n    d_IN j \\<langle>x\\<rangle> \\<le> weight \\<Gamma> x", "also"], ["proof (state)\nthis:\n  d_IN cap \\<langle>x\\<rangle>\n  \\<le> (\\<integral>\\<^sup>+z\\<in>range Some. f (the z, x)\n         \\<partial>count_space UNIV) +\n        (\\<integral>\\<^sup>+z\\<in>{None}. u x\\<partial>count_space UNIV)\n\ngoal (2 subgoals):\n 1. x \\<in> B \\<Gamma> \\<Longrightarrow>\n    d_IN j \\<langle>x\\<rangle> \\<le> weight \\<Gamma> x\n 2. x \\<notin> B \\<Gamma> \\<Longrightarrow>\n    d_IN j \\<langle>x\\<rangle> \\<le> weight \\<Gamma> x", "have \"\\<dots> = d_IN f x + u x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<integral>\\<^sup>+z\\<in>range Some. f (the z, x)\n     \\<partial>count_space UNIV) +\n    (\\<integral>\\<^sup>+z\\<in>{None}. u x\\<partial>count_space UNIV) =\n    d_IN f x + u x", "by(simp add: nn_integral_count_space_indicator[symmetric] nn_integral_count_space_reindex d_IN_def)"], ["proof (state)\nthis:\n  (\\<integral>\\<^sup>+z\\<in>range Some. f (the z, x)\n   \\<partial>count_space UNIV) +\n  (\\<integral>\\<^sup>+z\\<in>{None}. u x\\<partial>count_space UNIV) =\n  d_IN f x + u x\n\ngoal (2 subgoals):\n 1. x \\<in> B \\<Gamma> \\<Longrightarrow>\n    d_IN j \\<langle>x\\<rangle> \\<le> weight \\<Gamma> x\n 2. x \\<notin> B \\<Gamma> \\<Longrightarrow>\n    d_IN j \\<langle>x\\<rangle> \\<le> weight \\<Gamma> x", "also"], ["proof (state)\nthis:\n  (\\<integral>\\<^sup>+z\\<in>range Some. f (the z, x)\n   \\<partial>count_space UNIV) +\n  (\\<integral>\\<^sup>+z\\<in>{None}. u x\\<partial>count_space UNIV) =\n  d_IN f x + u x\n\ngoal (2 subgoals):\n 1. x \\<in> B \\<Gamma> \\<Longrightarrow>\n    d_IN j \\<langle>x\\<rangle> \\<le> weight \\<Gamma> x\n 2. x \\<notin> B \\<Gamma> \\<Longrightarrow>\n    d_IN j \\<langle>x\\<rangle> \\<le> weight \\<Gamma> x", "have \"\\<dots> \\<le> weight \\<Gamma> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN f x + u x \\<le> weight \\<Gamma> x", "using currentD_weight_IN[OF f, of x] u_finite[of x]"], ["proof (prove)\nusing this:\n  d_IN f x\n  \\<le> weight (\\<Gamma>\\<lparr>weight := weight \\<Gamma> - u\\<rparr>) x\n  u x \\<noteq> \\<top>\n\ngoal (1 subgoal):\n 1. d_IN f x + u x \\<le> weight \\<Gamma> x", "using \\<epsilon>_less u"], ["proof (prove)\nusing this:\n  d_IN f x\n  \\<le> weight (\\<Gamma>\\<lparr>weight := weight \\<Gamma> - u\\<rparr>) x\n  u x \\<noteq> \\<top>\n  \\<epsilon> < weight \\<Gamma> a - d_OUT f a\n  u \\<le> weight \\<Gamma>\n\ngoal (1 subgoal):\n 1. d_IN f x + u x \\<le> weight \\<Gamma> x", "by (auto simp add: ennreal_le_minus_iff le_fun_def)"], ["proof (state)\nthis:\n  d_IN f x + u x \\<le> weight \\<Gamma> x\n\ngoal (2 subgoals):\n 1. x \\<in> B \\<Gamma> \\<Longrightarrow>\n    d_IN j \\<langle>x\\<rangle> \\<le> weight \\<Gamma> x\n 2. x \\<notin> B \\<Gamma> \\<Longrightarrow>\n    d_IN j \\<langle>x\\<rangle> \\<le> weight \\<Gamma> x", "finally"], ["proof (chain)\npicking this:\n  d_IN j \\<langle>x\\<rangle> \\<le> weight \\<Gamma> x", "show ?thesis"], ["proof (prove)\nusing this:\n  d_IN j \\<langle>x\\<rangle> \\<le> weight \\<Gamma> x\n\ngoal (1 subgoal):\n 1. d_IN j \\<langle>x\\<rangle> \\<le> weight \\<Gamma> x", "."], ["proof (state)\nthis:\n  d_IN j \\<langle>x\\<rangle> \\<le> weight \\<Gamma> x\n\ngoal (1 subgoal):\n 1. x \\<notin> B \\<Gamma> \\<Longrightarrow>\n    d_IN j \\<langle>x\\<rangle> \\<le> weight \\<Gamma> x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<notin> B \\<Gamma> \\<Longrightarrow>\n    d_IN j \\<langle>x\\<rangle> \\<le> weight \\<Gamma> x", "case False"], ["proof (state)\nthis:\n  x \\<notin> B \\<Gamma>\n\ngoal (1 subgoal):\n 1. x \\<notin> B \\<Gamma> \\<Longrightarrow>\n    d_IN j \\<langle>x\\<rangle> \\<le> weight \\<Gamma> x", "with xA"], ["proof (chain)\npicking this:\n  x \\<notin> A \\<Gamma>\n  x \\<notin> B \\<Gamma>", "have \"x \\<notin> \\<^bold>V\""], ["proof (prove)\nusing this:\n  x \\<notin> A \\<Gamma>\n  x \\<notin> B \\<Gamma>\n\ngoal (1 subgoal):\n 1. x \\<notin> \\<^bold>V", "using bipartite_V"], ["proof (prove)\nusing this:\n  x \\<notin> A \\<Gamma>\n  x \\<notin> B \\<Gamma>\n  \\<^bold>V \\<subseteq> A \\<Gamma> \\<union> B \\<Gamma>\n\ngoal (1 subgoal):\n 1. x \\<notin> \\<^bold>V", "by blast"], ["proof (state)\nthis:\n  x \\<notin> \\<^bold>V\n\ngoal (1 subgoal):\n 1. x \\<notin> B \\<Gamma> \\<Longrightarrow>\n    d_IN j \\<langle>x\\<rangle> \\<le> weight \\<Gamma> x", "then"], ["proof (chain)\npicking this:\n  x \\<notin> \\<^bold>V", "have \"d_IN j \\<langle>x\\<rangle> = 0\""], ["proof (prove)\nusing this:\n  x \\<notin> \\<^bold>V\n\ngoal (1 subgoal):\n 1. d_IN j \\<langle>x\\<rangle> = 0", "using False"], ["proof (prove)\nusing this:\n  x \\<notin> \\<^bold>V\n  x \\<notin> B \\<Gamma>\n\ngoal (1 subgoal):\n 1. d_IN j \\<langle>x\\<rangle> = 0", "by(auto simp add: d_IN_def nn_integral_0_iff emeasure_count_space_eq_0 vertex_def edge'_def split: option.split_asm intro!: \\<Psi>.flowD_outside[OF j])"], ["proof (state)\nthis:\n  d_IN j \\<langle>x\\<rangle> = 0\n\ngoal (1 subgoal):\n 1. x \\<notin> B \\<Gamma> \\<Longrightarrow>\n    d_IN j \\<langle>x\\<rangle> \\<le> weight \\<Gamma> x", "then"], ["proof (chain)\npicking this:\n  d_IN j \\<langle>x\\<rangle> = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  d_IN j \\<langle>x\\<rangle> = 0\n\ngoal (1 subgoal):\n 1. d_IN j \\<langle>x\\<rangle> \\<le> weight \\<Gamma> x", "by simp"], ["proof (state)\nthis:\n  d_IN j \\<langle>x\\<rangle> \\<le> weight \\<Gamma> x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  d_IN j \\<langle>x\\<rangle> \\<le> weight \\<Gamma> x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  d_IN j \\<langle>?x\\<rangle> \\<le> weight \\<Gamma> ?x\n\ngoal (1 subgoal):\n 1. hindered \\<Gamma>", "let ?j = \"j \\<circ> map_prod Some Some \\<circ> prod.swap\""], ["proof (state)\ngoal (1 subgoal):\n 1. hindered \\<Gamma>", "have finite_j_OUT: \"(\\<Sum>\\<^sup>+ y\\<in>\\<^bold>O\\<^bold>U\\<^bold>T x. j (\\<langle>x\\<rangle>, \\<langle>y\\<rangle>)) \\<noteq> \\<top>\" (is \"?j_OUT \\<noteq> _\") if \"x \\<in> A \\<Gamma>\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y\\<in>\\<^bold>O\\<^bold>U\\<^bold>T x.\n       j (\\<langle>x\\<rangle>, \\<langle>y\\<rangle>)) \\<noteq>\n    \\<top>", "using currentD_finite_OUT[OF f', of x]"], ["proof (prove)\nusing this:\n  d_OUT f x \\<noteq> \\<top>\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y\\<in>\\<^bold>O\\<^bold>U\\<^bold>T x.\n       j (\\<langle>x\\<rangle>, \\<langle>y\\<rangle>)) \\<noteq>\n    \\<top>", "by(rule neq_top_trans)(auto intro!: nn_integral_mono j_le_f simp add: d_OUT_def nn_integral_count_space_indicator outgoing_def split: split_indicator)"], ["proof (state)\nthis:\n  ?x \\<in> A \\<Gamma> \\<Longrightarrow>\n  (\\<Sum>\\<^sup>+ y\\<in>\\<^bold>O\\<^bold>U\\<^bold>T ?x.\n     j (\\<langle>?x\\<rangle>, \\<langle>y\\<rangle>)) \\<noteq>\n  \\<top>\n\ngoal (1 subgoal):\n 1. hindered \\<Gamma>", "have j_OUT_eq: \"?j_OUT x = d_OUT j \\<langle>x\\<rangle>\" if \"x \\<in> A \\<Gamma>\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y\\<in>\\<^bold>O\\<^bold>U\\<^bold>T x.\n       j (\\<langle>x\\<rangle>, \\<langle>y\\<rangle>)) =\n    d_OUT j \\<langle>x\\<rangle>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y\\<in>\\<^bold>O\\<^bold>U\\<^bold>T x.\n       j (\\<langle>x\\<rangle>, \\<langle>y\\<rangle>)) =\n    d_OUT j \\<langle>x\\<rangle>", "have \"?j_OUT x = (\\<Sum>\\<^sup>+ y\\<in>range Some. j (Some x, y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y\\<in>\\<^bold>O\\<^bold>U\\<^bold>T x.\n       j (\\<langle>x\\<rangle>, \\<langle>y\\<rangle>)) =\n    (\\<Sum>\\<^sup>+ y\\<in>range Some. j (\\<langle>x\\<rangle>, y))", "using that disjoint"], ["proof (prove)\nusing this:\n  x \\<in> A \\<Gamma>\n  A \\<Gamma> \\<inter> B \\<Gamma> = {}\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y\\<in>\\<^bold>O\\<^bold>U\\<^bold>T x.\n       j (\\<langle>x\\<rangle>, \\<langle>y\\<rangle>)) =\n    (\\<Sum>\\<^sup>+ y\\<in>range Some. j (\\<langle>x\\<rangle>, y))", "by(simp add: nn_integral_count_space_reindex)(auto 4 4 simp add: nn_integral_count_space_indicator outgoing_def intro!: nn_integral_cong \\<Psi>.flowD_outside[OF j] dest: bipartite_E split: split_indicator)"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y\\<in>\\<^bold>O\\<^bold>U\\<^bold>T x.\n     j (\\<langle>x\\<rangle>, \\<langle>y\\<rangle>)) =\n  (\\<Sum>\\<^sup>+ y\\<in>range Some. j (\\<langle>x\\<rangle>, y))\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y\\<in>\\<^bold>O\\<^bold>U\\<^bold>T x.\n       j (\\<langle>x\\<rangle>, \\<langle>y\\<rangle>)) =\n    d_OUT j \\<langle>x\\<rangle>", "also"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y\\<in>\\<^bold>O\\<^bold>U\\<^bold>T x.\n     j (\\<langle>x\\<rangle>, \\<langle>y\\<rangle>)) =\n  (\\<Sum>\\<^sup>+ y\\<in>range Some. j (\\<langle>x\\<rangle>, y))\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y\\<in>\\<^bold>O\\<^bold>U\\<^bold>T x.\n       j (\\<langle>x\\<rangle>, \\<langle>y\\<rangle>)) =\n    d_OUT j \\<langle>x\\<rangle>", "have \"\\<dots> = d_OUT j \\<langle>x\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y\\<in>range Some. j (\\<langle>x\\<rangle>, y)) =\n    d_OUT j \\<langle>x\\<rangle>", "by(auto simp add: d_OUT_def nn_integral_count_space_indicator notin_range_Some intro!: nn_integral_cong \\<Psi>.flowD_outside[OF j] split: split_indicator)"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y\\<in>range Some. j (\\<langle>x\\<rangle>, y)) =\n  d_OUT j \\<langle>x\\<rangle>\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y\\<in>\\<^bold>O\\<^bold>U\\<^bold>T x.\n       j (\\<langle>x\\<rangle>, \\<langle>y\\<rangle>)) =\n    d_OUT j \\<langle>x\\<rangle>", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>\\<^sup>+ y\\<in>\\<^bold>O\\<^bold>U\\<^bold>T x.\n     j (\\<langle>x\\<rangle>, \\<langle>y\\<rangle>)) =\n  d_OUT j \\<langle>x\\<rangle>", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<Sum>\\<^sup>+ y\\<in>\\<^bold>O\\<^bold>U\\<^bold>T x.\n     j (\\<langle>x\\<rangle>, \\<langle>y\\<rangle>)) =\n  d_OUT j \\<langle>x\\<rangle>\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y\\<in>\\<^bold>O\\<^bold>U\\<^bold>T x.\n       j (\\<langle>x\\<rangle>, \\<langle>y\\<rangle>)) =\n    d_OUT j \\<langle>x\\<rangle>", "."], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y\\<in>\\<^bold>O\\<^bold>U\\<^bold>T x.\n     j (\\<langle>x\\<rangle>, \\<langle>y\\<rangle>)) =\n  d_OUT j \\<langle>x\\<rangle>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?x \\<in> A \\<Gamma> \\<Longrightarrow>\n  (\\<Sum>\\<^sup>+ y\\<in>\\<^bold>O\\<^bold>U\\<^bold>T ?x.\n     j (\\<langle>?x\\<rangle>, \\<langle>y\\<rangle>)) =\n  d_OUT j \\<langle>?x\\<rangle>\n\ngoal (1 subgoal):\n 1. hindered \\<Gamma>", "define g where \"g = f \\<oplus> ?j\""], ["proof (state)\nthis:\n  g = f \\<oplus> (j \\<circ> map_prod Some Some \\<circ> prod.swap)\n\ngoal (1 subgoal):\n 1. hindered \\<Gamma>", "have g_simps: \"g (x, y) = (f \\<oplus> ?j) (x, y)\" for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. g (x, y) =\n    (f \\<oplus> (j \\<circ> map_prod Some Some \\<circ> prod.swap)) (x, y)", "by(simp add: g_def)"], ["proof (state)\nthis:\n  g (?x, ?y) =\n  (f \\<oplus> (j \\<circ> map_prod Some Some \\<circ> prod.swap)) (?x, ?y)\n\ngoal (1 subgoal):\n 1. hindered \\<Gamma>", "have OUT_g_A: \"d_OUT g x = d_OUT f x + d_IN j \\<langle>x\\<rangle> - d_OUT j \\<langle>x\\<rangle>\" if \"x \\<in> A \\<Gamma>\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT g x =\n    d_OUT f x + d_IN j \\<langle>x\\<rangle> - d_OUT j \\<langle>x\\<rangle>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. d_OUT g x =\n    d_OUT f x + d_IN j \\<langle>x\\<rangle> - d_OUT j \\<langle>x\\<rangle>", "have \"d_OUT g x = (\\<Sum>\\<^sup>+ y\\<in>\\<^bold>O\\<^bold>U\\<^bold>T x. f (x, y) + j (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>) - j (\\<langle>x\\<rangle>, \\<langle>y\\<rangle>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT g x =\n    (\\<Sum>\\<^sup>+ y\\<in>\\<^bold>O\\<^bold>U\\<^bold>T x.\n       f (x, y) + j (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>) -\n       j (\\<langle>x\\<rangle>, \\<langle>y\\<rangle>))", "by(auto simp add: d_OUT_def g_simps currentD_outside[OF f'] outgoing_def nn_integral_count_space_indicator intro!: nn_integral_cong)"], ["proof (state)\nthis:\n  d_OUT g x =\n  (\\<Sum>\\<^sup>+ y\\<in>\\<^bold>O\\<^bold>U\\<^bold>T x.\n     f (x, y) + j (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>) -\n     j (\\<langle>x\\<rangle>, \\<langle>y\\<rangle>))\n\ngoal (1 subgoal):\n 1. d_OUT g x =\n    d_OUT f x + d_IN j \\<langle>x\\<rangle> - d_OUT j \\<langle>x\\<rangle>", "also"], ["proof (state)\nthis:\n  d_OUT g x =\n  (\\<Sum>\\<^sup>+ y\\<in>\\<^bold>O\\<^bold>U\\<^bold>T x.\n     f (x, y) + j (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>) -\n     j (\\<langle>x\\<rangle>, \\<langle>y\\<rangle>))\n\ngoal (1 subgoal):\n 1. d_OUT g x =\n    d_OUT f x + d_IN j \\<langle>x\\<rangle> - d_OUT j \\<langle>x\\<rangle>", "have \"\\<dots> = (\\<Sum>\\<^sup>+ y\\<in>\\<^bold>O\\<^bold>U\\<^bold>T x. f (x, y) + j (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>)) - (\\<Sum>\\<^sup>+ y\\<in>\\<^bold>O\\<^bold>U\\<^bold>T x. j (\\<langle>x\\<rangle>, \\<langle>y\\<rangle>))\"\n      (is \"_ = _ - ?j_OUT\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y\\<in>\\<^bold>O\\<^bold>U\\<^bold>T x.\n       f (x, y) + j (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>) -\n       j (\\<langle>x\\<rangle>, \\<langle>y\\<rangle>)) =\n    (\\<Sum>\\<^sup>+ y\\<in>\\<^bold>O\\<^bold>U\\<^bold>T x.\n       f (x, y) + j (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>)) -\n    (\\<Sum>\\<^sup>+ y\\<in>\\<^bold>O\\<^bold>U\\<^bold>T x.\n       j (\\<langle>x\\<rangle>, \\<langle>y\\<rangle>))", "using finite_j_OUT[OF that]"], ["proof (prove)\nusing this:\n  (\\<Sum>\\<^sup>+ y\\<in>\\<^bold>O\\<^bold>U\\<^bold>T x.\n     j (\\<langle>x\\<rangle>, \\<langle>y\\<rangle>)) \\<noteq>\n  \\<top>\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y\\<in>\\<^bold>O\\<^bold>U\\<^bold>T x.\n       f (x, y) + j (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>) -\n       j (\\<langle>x\\<rangle>, \\<langle>y\\<rangle>)) =\n    (\\<Sum>\\<^sup>+ y\\<in>\\<^bold>O\\<^bold>U\\<^bold>T x.\n       f (x, y) + j (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>)) -\n    (\\<Sum>\\<^sup>+ y\\<in>\\<^bold>O\\<^bold>U\\<^bold>T x.\n       j (\\<langle>x\\<rangle>, \\<langle>y\\<rangle>))", "by(subst nn_integral_diff)(auto simp add: AE_count_space outgoing_def intro!: order_trans[OF j_le_f])"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y\\<in>\\<^bold>O\\<^bold>U\\<^bold>T x.\n     f (x, y) + j (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>) -\n     j (\\<langle>x\\<rangle>, \\<langle>y\\<rangle>)) =\n  (\\<Sum>\\<^sup>+ y\\<in>\\<^bold>O\\<^bold>U\\<^bold>T x.\n     f (x, y) + j (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>)) -\n  (\\<Sum>\\<^sup>+ y\\<in>\\<^bold>O\\<^bold>U\\<^bold>T x.\n     j (\\<langle>x\\<rangle>, \\<langle>y\\<rangle>))\n\ngoal (1 subgoal):\n 1. d_OUT g x =\n    d_OUT f x + d_IN j \\<langle>x\\<rangle> - d_OUT j \\<langle>x\\<rangle>", "also"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y\\<in>\\<^bold>O\\<^bold>U\\<^bold>T x.\n     f (x, y) + j (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>) -\n     j (\\<langle>x\\<rangle>, \\<langle>y\\<rangle>)) =\n  (\\<Sum>\\<^sup>+ y\\<in>\\<^bold>O\\<^bold>U\\<^bold>T x.\n     f (x, y) + j (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>)) -\n  (\\<Sum>\\<^sup>+ y\\<in>\\<^bold>O\\<^bold>U\\<^bold>T x.\n     j (\\<langle>x\\<rangle>, \\<langle>y\\<rangle>))\n\ngoal (1 subgoal):\n 1. d_OUT g x =\n    d_OUT f x + d_IN j \\<langle>x\\<rangle> - d_OUT j \\<langle>x\\<rangle>", "have \"\\<dots> = (\\<Sum>\\<^sup>+ y\\<in>\\<^bold>O\\<^bold>U\\<^bold>T x. f (x, y)) + (\\<Sum>\\<^sup>+ y\\<in>\\<^bold>O\\<^bold>U\\<^bold>T x. j (Some y, Some x)) - ?j_OUT\"\n      (is \"_ = ?f + ?j_IN - _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y\\<in>\\<^bold>O\\<^bold>U\\<^bold>T x.\n       f (x, y) + j (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>)) -\n    (\\<Sum>\\<^sup>+ y\\<in>\\<^bold>O\\<^bold>U\\<^bold>T x.\n       j (\\<langle>x\\<rangle>, \\<langle>y\\<rangle>)) =\n    (\\<Sum>\\<^sup>+ y\\<in>\\<^bold>O\\<^bold>U\\<^bold>T x. f (x, y)) +\n    (\\<Sum>\\<^sup>+ y\\<in>\\<^bold>O\\<^bold>U\\<^bold>T x.\n       j (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>)) -\n    (\\<Sum>\\<^sup>+ y\\<in>\\<^bold>O\\<^bold>U\\<^bold>T x.\n       j (\\<langle>x\\<rangle>, \\<langle>y\\<rangle>))", "by(subst nn_integral_add) simp_all"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y\\<in>\\<^bold>O\\<^bold>U\\<^bold>T x.\n     f (x, y) + j (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>)) -\n  (\\<Sum>\\<^sup>+ y\\<in>\\<^bold>O\\<^bold>U\\<^bold>T x.\n     j (\\<langle>x\\<rangle>, \\<langle>y\\<rangle>)) =\n  (\\<Sum>\\<^sup>+ y\\<in>\\<^bold>O\\<^bold>U\\<^bold>T x. f (x, y)) +\n  (\\<Sum>\\<^sup>+ y\\<in>\\<^bold>O\\<^bold>U\\<^bold>T x.\n     j (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>)) -\n  (\\<Sum>\\<^sup>+ y\\<in>\\<^bold>O\\<^bold>U\\<^bold>T x.\n     j (\\<langle>x\\<rangle>, \\<langle>y\\<rangle>))\n\ngoal (1 subgoal):\n 1. d_OUT g x =\n    d_OUT f x + d_IN j \\<langle>x\\<rangle> - d_OUT j \\<langle>x\\<rangle>", "also"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y\\<in>\\<^bold>O\\<^bold>U\\<^bold>T x.\n     f (x, y) + j (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>)) -\n  (\\<Sum>\\<^sup>+ y\\<in>\\<^bold>O\\<^bold>U\\<^bold>T x.\n     j (\\<langle>x\\<rangle>, \\<langle>y\\<rangle>)) =\n  (\\<Sum>\\<^sup>+ y\\<in>\\<^bold>O\\<^bold>U\\<^bold>T x. f (x, y)) +\n  (\\<Sum>\\<^sup>+ y\\<in>\\<^bold>O\\<^bold>U\\<^bold>T x.\n     j (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>)) -\n  (\\<Sum>\\<^sup>+ y\\<in>\\<^bold>O\\<^bold>U\\<^bold>T x.\n     j (\\<langle>x\\<rangle>, \\<langle>y\\<rangle>))\n\ngoal (1 subgoal):\n 1. d_OUT g x =\n    d_OUT f x + d_IN j \\<langle>x\\<rangle> - d_OUT j \\<langle>x\\<rangle>", "have \"?f = d_OUT f x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y\\<in>\\<^bold>O\\<^bold>U\\<^bold>T x. f (x, y)) =\n    d_OUT f x", "by(subst d_OUT_alt_def[where G=\\<Gamma>])(simp_all add: currentD_outside[OF f])"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y\\<in>\\<^bold>O\\<^bold>U\\<^bold>T x. f (x, y)) = d_OUT f x\n\ngoal (1 subgoal):\n 1. d_OUT g x =\n    d_OUT f x + d_IN j \\<langle>x\\<rangle> - d_OUT j \\<langle>x\\<rangle>", "also"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y\\<in>\\<^bold>O\\<^bold>U\\<^bold>T x. f (x, y)) = d_OUT f x\n\ngoal (1 subgoal):\n 1. d_OUT g x =\n    d_OUT f x + d_IN j \\<langle>x\\<rangle> - d_OUT j \\<langle>x\\<rangle>", "have \"?j_OUT = d_OUT j \\<langle>x\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y\\<in>\\<^bold>O\\<^bold>U\\<^bold>T x.\n       j (\\<langle>x\\<rangle>, \\<langle>y\\<rangle>)) =\n    d_OUT j \\<langle>x\\<rangle>", "using that"], ["proof (prove)\nusing this:\n  x \\<in> A \\<Gamma>\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y\\<in>\\<^bold>O\\<^bold>U\\<^bold>T x.\n       j (\\<langle>x\\<rangle>, \\<langle>y\\<rangle>)) =\n    d_OUT j \\<langle>x\\<rangle>", "by(rule j_OUT_eq)"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y\\<in>\\<^bold>O\\<^bold>U\\<^bold>T x.\n     j (\\<langle>x\\<rangle>, \\<langle>y\\<rangle>)) =\n  d_OUT j \\<langle>x\\<rangle>\n\ngoal (1 subgoal):\n 1. d_OUT g x =\n    d_OUT f x + d_IN j \\<langle>x\\<rangle> - d_OUT j \\<langle>x\\<rangle>", "also"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y\\<in>\\<^bold>O\\<^bold>U\\<^bold>T x.\n     j (\\<langle>x\\<rangle>, \\<langle>y\\<rangle>)) =\n  d_OUT j \\<langle>x\\<rangle>\n\ngoal (1 subgoal):\n 1. d_OUT g x =\n    d_OUT f x + d_IN j \\<langle>x\\<rangle> - d_OUT j \\<langle>x\\<rangle>", "have \"?j_IN = (\\<Sum>\\<^sup>+ y\\<in>range Some. j (y, \\<langle>x\\<rangle>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y\\<in>\\<^bold>O\\<^bold>U\\<^bold>T x.\n       j (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>)) =\n    (\\<Sum>\\<^sup>+ y\\<in>range Some. j (y, \\<langle>x\\<rangle>))", "using that disjoint"], ["proof (prove)\nusing this:\n  x \\<in> A \\<Gamma>\n  A \\<Gamma> \\<inter> B \\<Gamma> = {}\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y\\<in>\\<^bold>O\\<^bold>U\\<^bold>T x.\n       j (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>)) =\n    (\\<Sum>\\<^sup>+ y\\<in>range Some. j (y, \\<langle>x\\<rangle>))", "by(simp add: nn_integral_count_space_reindex)(auto 4 4 simp add: nn_integral_count_space_indicator outgoing_def intro!: nn_integral_cong \\<Psi>.flowD_outside[OF j] split: split_indicator dest: bipartite_E)"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y\\<in>\\<^bold>O\\<^bold>U\\<^bold>T x.\n     j (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>)) =\n  (\\<Sum>\\<^sup>+ y\\<in>range Some. j (y, \\<langle>x\\<rangle>))\n\ngoal (1 subgoal):\n 1. d_OUT g x =\n    d_OUT f x + d_IN j \\<langle>x\\<rangle> - d_OUT j \\<langle>x\\<rangle>", "also"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y\\<in>\\<^bold>O\\<^bold>U\\<^bold>T x.\n     j (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>)) =\n  (\\<Sum>\\<^sup>+ y\\<in>range Some. j (y, \\<langle>x\\<rangle>))\n\ngoal (1 subgoal):\n 1. d_OUT g x =\n    d_OUT f x + d_IN j \\<langle>x\\<rangle> - d_OUT j \\<langle>x\\<rangle>", "have \"\\<dots> = d_IN j (Some x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y\\<in>range Some. j (y, \\<langle>x\\<rangle>)) =\n    d_IN j \\<langle>x\\<rangle>", "using that disjoint"], ["proof (prove)\nusing this:\n  x \\<in> A \\<Gamma>\n  A \\<Gamma> \\<inter> B \\<Gamma> = {}\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y\\<in>range Some. j (y, \\<langle>x\\<rangle>)) =\n    d_IN j \\<langle>x\\<rangle>", "by(auto 4 3 simp add: d_IN_def nn_integral_count_space_indicator notin_range_Some intro!: nn_integral_cong \\<Psi>.flowD_outside[OF j] split: split_indicator)"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y\\<in>range Some. j (y, \\<langle>x\\<rangle>)) =\n  d_IN j \\<langle>x\\<rangle>\n\ngoal (1 subgoal):\n 1. d_OUT g x =\n    d_OUT f x + d_IN j \\<langle>x\\<rangle> - d_OUT j \\<langle>x\\<rangle>", "finally"], ["proof (chain)\npicking this:\n  d_OUT g x =\n  d_OUT f x + d_IN j \\<langle>x\\<rangle> - d_OUT j \\<langle>x\\<rangle>", "show ?thesis"], ["proof (prove)\nusing this:\n  d_OUT g x =\n  d_OUT f x + d_IN j \\<langle>x\\<rangle> - d_OUT j \\<langle>x\\<rangle>\n\ngoal (1 subgoal):\n 1. d_OUT g x =\n    d_OUT f x + d_IN j \\<langle>x\\<rangle> - d_OUT j \\<langle>x\\<rangle>", "by simp"], ["proof (state)\nthis:\n  d_OUT g x =\n  d_OUT f x + d_IN j \\<langle>x\\<rangle> - d_OUT j \\<langle>x\\<rangle>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?x \\<in> A \\<Gamma> \\<Longrightarrow>\n  d_OUT g ?x =\n  d_OUT f ?x + d_IN j \\<langle>?x\\<rangle> - d_OUT j \\<langle>?x\\<rangle>\n\ngoal (1 subgoal):\n 1. hindered \\<Gamma>", "have OUT_g_B: \"d_OUT g x = 0\" if \"x \\<notin> A \\<Gamma>\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT g x = 0", "using disjoint that"], ["proof (prove)\nusing this:\n  A \\<Gamma> \\<inter> B \\<Gamma> = {}\n  x \\<notin> A \\<Gamma>\n\ngoal (1 subgoal):\n 1. d_OUT g x = 0", "by(auto simp add: d_OUT_def nn_integral_0_iff_AE AE_count_space g_simps dest: bipartite_E)"], ["proof (state)\nthis:\n  ?x \\<notin> A \\<Gamma> \\<Longrightarrow> d_OUT g ?x = 0\n\ngoal (1 subgoal):\n 1. hindered \\<Gamma>", "have OUT_g_a: \"d_OUT g a < weight \\<Gamma> a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT g a < weight \\<Gamma> a", "using a(1)"], ["proof (prove)\nusing this:\n  a \\<in> A \\<Gamma>\n\ngoal (1 subgoal):\n 1. d_OUT g a < weight \\<Gamma> a", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. a \\<in> A \\<Gamma> \\<Longrightarrow> d_OUT g a < weight \\<Gamma> a", "have \"d_OUT g a = d_OUT f a + d_IN j \\<langle>a\\<rangle> - d_OUT j \\<langle>a\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT g a =\n    d_OUT f a + d_IN j \\<langle>a\\<rangle> - d_OUT j \\<langle>a\\<rangle>", "using a(1)"], ["proof (prove)\nusing this:\n  a \\<in> A \\<Gamma>\n\ngoal (1 subgoal):\n 1. d_OUT g a =\n    d_OUT f a + d_IN j \\<langle>a\\<rangle> - d_OUT j \\<langle>a\\<rangle>", "by(rule OUT_g_A)"], ["proof (state)\nthis:\n  d_OUT g a =\n  d_OUT f a + d_IN j \\<langle>a\\<rangle> - d_OUT j \\<langle>a\\<rangle>\n\ngoal (1 subgoal):\n 1. a \\<in> A \\<Gamma> \\<Longrightarrow> d_OUT g a < weight \\<Gamma> a", "also"], ["proof (state)\nthis:\n  d_OUT g a =\n  d_OUT f a + d_IN j \\<langle>a\\<rangle> - d_OUT j \\<langle>a\\<rangle>\n\ngoal (1 subgoal):\n 1. a \\<in> A \\<Gamma> \\<Longrightarrow> d_OUT g a < weight \\<Gamma> a", "have \"\\<dots> \\<le> d_OUT f a + d_IN j \\<langle>a\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT f a + d_IN j \\<langle>a\\<rangle> - d_OUT j \\<langle>a\\<rangle>\n    \\<le> d_OUT f a + d_IN j \\<langle>a\\<rangle>", "by(rule diff_le_self_ennreal)"], ["proof (state)\nthis:\n  d_OUT f a + d_IN j \\<langle>a\\<rangle> - d_OUT j \\<langle>a\\<rangle>\n  \\<le> d_OUT f a + d_IN j \\<langle>a\\<rangle>\n\ngoal (1 subgoal):\n 1. a \\<in> A \\<Gamma> \\<Longrightarrow> d_OUT g a < weight \\<Gamma> a", "also"], ["proof (state)\nthis:\n  d_OUT f a + d_IN j \\<langle>a\\<rangle> - d_OUT j \\<langle>a\\<rangle>\n  \\<le> d_OUT f a + d_IN j \\<langle>a\\<rangle>\n\ngoal (1 subgoal):\n 1. a \\<in> A \\<Gamma> \\<Longrightarrow> d_OUT g a < weight \\<Gamma> a", "have \"\\<dots> < weight \\<Gamma> a + d_IN j \\<langle>a\\<rangle> - \\<epsilon>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT f a + d_IN j \\<langle>a\\<rangle>\n    < weight \\<Gamma> a + d_IN j \\<langle>a\\<rangle> - \\<epsilon>", "using finite_\\<epsilon> \\<epsilon>_less currentD_finite_OUT[OF f']"], ["proof (prove)\nusing this:\n  \\<epsilon> \\<noteq> \\<top>\n  \\<epsilon> < weight \\<Gamma> a - d_OUT f a\n  d_OUT f ?x \\<noteq> \\<top>\n\ngoal (1 subgoal):\n 1. d_OUT f a + d_IN j \\<langle>a\\<rangle>\n    < weight \\<Gamma> a + d_IN j \\<langle>a\\<rangle> - \\<epsilon>", "by (simp add: less_diff_eq_ennreal less_top ac_simps)"], ["proof (state)\nthis:\n  d_OUT f a + d_IN j \\<langle>a\\<rangle>\n  < weight \\<Gamma> a + d_IN j \\<langle>a\\<rangle> - \\<epsilon>\n\ngoal (1 subgoal):\n 1. a \\<in> A \\<Gamma> \\<Longrightarrow> d_OUT g a < weight \\<Gamma> a", "also"], ["proof (state)\nthis:\n  d_OUT f a + d_IN j \\<langle>a\\<rangle>\n  < weight \\<Gamma> a + d_IN j \\<langle>a\\<rangle> - \\<epsilon>\n\ngoal (1 subgoal):\n 1. a \\<in> A \\<Gamma> \\<Longrightarrow> d_OUT g a < weight \\<Gamma> a", "have \"\\<dots> \\<le> weight \\<Gamma> a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. weight \\<Gamma> a + d_IN j \\<langle>a\\<rangle> - \\<epsilon>\n    \\<le> weight \\<Gamma> a", "using IN_j[THEN order_trans, OF \\<alpha>_le]"], ["proof (prove)\nusing this:\n  d_IN j ?x1 \\<le> \\<epsilon>\n\ngoal (1 subgoal):\n 1. weight \\<Gamma> a + d_IN j \\<langle>a\\<rangle> - \\<epsilon>\n    \\<le> weight \\<Gamma> a", "by (simp add: ennreal_minus_le_iff)"], ["proof (state)\nthis:\n  weight \\<Gamma> a + d_IN j \\<langle>a\\<rangle> - \\<epsilon>\n  \\<le> weight \\<Gamma> a\n\ngoal (1 subgoal):\n 1. a \\<in> A \\<Gamma> \\<Longrightarrow> d_OUT g a < weight \\<Gamma> a", "finally"], ["proof (chain)\npicking this:\n  d_OUT g a < weight \\<Gamma> a", "show ?thesis"], ["proof (prove)\nusing this:\n  d_OUT g a < weight \\<Gamma> a\n\ngoal (1 subgoal):\n 1. d_OUT g a < weight \\<Gamma> a", "."], ["proof (state)\nthis:\n  d_OUT g a < weight \\<Gamma> a\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  d_OUT g a < weight \\<Gamma> a\n\ngoal (1 subgoal):\n 1. hindered \\<Gamma>", "have OUT_jj: \"d_OUT ?j x = d_IN j \\<langle>x\\<rangle> - j (None, \\<langle>x\\<rangle>)\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT (j \\<circ> map_prod Some Some \\<circ> prod.swap) x =\n    d_IN j \\<langle>x\\<rangle> - j (None, \\<langle>x\\<rangle>)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. d_OUT (j \\<circ> map_prod Some Some \\<circ> prod.swap) x =\n    d_IN j \\<langle>x\\<rangle> - j (None, \\<langle>x\\<rangle>)", "have \"d_OUT ?j x = (\\<Sum>\\<^sup>+ y\\<in>range Some. j (y, \\<langle>x\\<rangle>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT (j \\<circ> map_prod Some Some \\<circ> prod.swap) x =\n    (\\<Sum>\\<^sup>+ y\\<in>range Some. j (y, \\<langle>x\\<rangle>))", "by(simp add: d_OUT_def nn_integral_count_space_reindex)"], ["proof (state)\nthis:\n  d_OUT (j \\<circ> map_prod Some Some \\<circ> prod.swap) x =\n  (\\<Sum>\\<^sup>+ y\\<in>range Some. j (y, \\<langle>x\\<rangle>))\n\ngoal (1 subgoal):\n 1. d_OUT (j \\<circ> map_prod Some Some \\<circ> prod.swap) x =\n    d_IN j \\<langle>x\\<rangle> - j (None, \\<langle>x\\<rangle>)", "also"], ["proof (state)\nthis:\n  d_OUT (j \\<circ> map_prod Some Some \\<circ> prod.swap) x =\n  (\\<Sum>\\<^sup>+ y\\<in>range Some. j (y, \\<langle>x\\<rangle>))\n\ngoal (1 subgoal):\n 1. d_OUT (j \\<circ> map_prod Some Some \\<circ> prod.swap) x =\n    d_IN j \\<langle>x\\<rangle> - j (None, \\<langle>x\\<rangle>)", "have \"\\<dots> = d_IN j \\<langle>x\\<rangle> - (\\<Sum>\\<^sup>+ y. j (y, \\<langle>x\\<rangle>) * indicator {None} y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y\\<in>range Some. j (y, \\<langle>x\\<rangle>)) =\n    d_IN j \\<langle>x\\<rangle> -\n    (\\<integral>\\<^sup>+y\\<in>{None}. j (y, \\<langle>x\\<rangle>)\n     \\<partial>count_space UNIV)", "unfolding d_IN_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y\\<in>range Some. j (y, \\<langle>x\\<rangle>)) =\n    (\\<Sum>\\<^sup>+ xa. j (xa, \\<langle>x\\<rangle>)) -\n    (\\<integral>\\<^sup>+y\\<in>{None}. j (y, \\<langle>x\\<rangle>)\n     \\<partial>count_space UNIV)", "by(subst nn_integral_diff[symmetric])(auto simp add: max_def \\<Psi>.flowD_finite[OF j] AE_count_space nn_integral_count_space_indicator split: split_indicator intro!: nn_integral_cong)"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y\\<in>range Some. j (y, \\<langle>x\\<rangle>)) =\n  d_IN j \\<langle>x\\<rangle> -\n  (\\<integral>\\<^sup>+y\\<in>{None}. j (y, \\<langle>x\\<rangle>)\n   \\<partial>count_space UNIV)\n\ngoal (1 subgoal):\n 1. d_OUT (j \\<circ> map_prod Some Some \\<circ> prod.swap) x =\n    d_IN j \\<langle>x\\<rangle> - j (None, \\<langle>x\\<rangle>)", "also"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y\\<in>range Some. j (y, \\<langle>x\\<rangle>)) =\n  d_IN j \\<langle>x\\<rangle> -\n  (\\<integral>\\<^sup>+y\\<in>{None}. j (y, \\<langle>x\\<rangle>)\n   \\<partial>count_space UNIV)\n\ngoal (1 subgoal):\n 1. d_OUT (j \\<circ> map_prod Some Some \\<circ> prod.swap) x =\n    d_IN j \\<langle>x\\<rangle> - j (None, \\<langle>x\\<rangle>)", "have \"\\<dots> = d_IN j \\<langle>x\\<rangle> - j (None, \\<langle>x\\<rangle>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN j \\<langle>x\\<rangle> -\n    (\\<integral>\\<^sup>+y\\<in>{None}. j (y, \\<langle>x\\<rangle>)\n     \\<partial>count_space UNIV) =\n    d_IN j \\<langle>x\\<rangle> - j (None, \\<langle>x\\<rangle>)", "by(simp add: max_def)"], ["proof (state)\nthis:\n  d_IN j \\<langle>x\\<rangle> -\n  (\\<integral>\\<^sup>+y\\<in>{None}. j (y, \\<langle>x\\<rangle>)\n   \\<partial>count_space UNIV) =\n  d_IN j \\<langle>x\\<rangle> - j (None, \\<langle>x\\<rangle>)\n\ngoal (1 subgoal):\n 1. d_OUT (j \\<circ> map_prod Some Some \\<circ> prod.swap) x =\n    d_IN j \\<langle>x\\<rangle> - j (None, \\<langle>x\\<rangle>)", "finally"], ["proof (chain)\npicking this:\n  d_OUT (j \\<circ> map_prod Some Some \\<circ> prod.swap) x =\n  d_IN j \\<langle>x\\<rangle> - j (None, \\<langle>x\\<rangle>)", "show ?thesis"], ["proof (prove)\nusing this:\n  d_OUT (j \\<circ> map_prod Some Some \\<circ> prod.swap) x =\n  d_IN j \\<langle>x\\<rangle> - j (None, \\<langle>x\\<rangle>)\n\ngoal (1 subgoal):\n 1. d_OUT (j \\<circ> map_prod Some Some \\<circ> prod.swap) x =\n    d_IN j \\<langle>x\\<rangle> - j (None, \\<langle>x\\<rangle>)", "."], ["proof (state)\nthis:\n  d_OUT (j \\<circ> map_prod Some Some \\<circ> prod.swap) x =\n  d_IN j \\<langle>x\\<rangle> - j (None, \\<langle>x\\<rangle>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  d_OUT (j \\<circ> map_prod Some Some \\<circ> prod.swap) ?x =\n  d_IN j \\<langle>?x\\<rangle> - j (None, \\<langle>?x\\<rangle>)\n\ngoal (1 subgoal):\n 1. hindered \\<Gamma>", "have OUT_jj_finite [simp]: \"d_OUT ?j x \\<noteq> \\<top>\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT (j \\<circ> map_prod Some Some \\<circ> prod.swap) x \\<noteq> \\<top>", "by(simp add: OUT_jj)"], ["proof (state)\nthis:\n  d_OUT (j \\<circ> map_prod Some Some \\<circ> prod.swap) ?x \\<noteq> \\<top>\n\ngoal (1 subgoal):\n 1. hindered \\<Gamma>", "have IN_g: \"d_IN g x = d_IN f x + j (None, \\<langle>x\\<rangle>)\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN g x = d_IN f x + j (None, \\<langle>x\\<rangle>)", "proof(cases \"x \\<in> B \\<Gamma>\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<in> B \\<Gamma> \\<Longrightarrow>\n    d_IN g x = d_IN f x + j (None, \\<langle>x\\<rangle>)\n 2. x \\<notin> B \\<Gamma> \\<Longrightarrow>\n    d_IN g x = d_IN f x + j (None, \\<langle>x\\<rangle>)", "case True"], ["proof (state)\nthis:\n  x \\<in> B \\<Gamma>\n\ngoal (2 subgoals):\n 1. x \\<in> B \\<Gamma> \\<Longrightarrow>\n    d_IN g x = d_IN f x + j (None, \\<langle>x\\<rangle>)\n 2. x \\<notin> B \\<Gamma> \\<Longrightarrow>\n    d_IN g x = d_IN f x + j (None, \\<langle>x\\<rangle>)", "have finite: \"(\\<Sum>\\<^sup>+ y\\<in>\\<^bold>I\\<^bold>N x. j (Some y, Some x)) \\<noteq> \\<top>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y\\<in>\\<^bold>I\\<^bold>N x.\n       j (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>)) \\<noteq>\n    \\<top>", "using currentD_finite_IN[OF f', of x]"], ["proof (prove)\nusing this:\n  d_IN f x \\<noteq> \\<top>\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y\\<in>\\<^bold>I\\<^bold>N x.\n       j (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>)) \\<noteq>\n    \\<top>", "by(rule neq_top_trans)(auto intro!: nn_integral_mono j_le_f simp add: d_IN_def nn_integral_count_space_indicator incoming_def split: split_indicator)"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y\\<in>\\<^bold>I\\<^bold>N x.\n     j (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>)) \\<noteq>\n  \\<top>\n\ngoal (2 subgoals):\n 1. x \\<in> B \\<Gamma> \\<Longrightarrow>\n    d_IN g x = d_IN f x + j (None, \\<langle>x\\<rangle>)\n 2. x \\<notin> B \\<Gamma> \\<Longrightarrow>\n    d_IN g x = d_IN f x + j (None, \\<langle>x\\<rangle>)", "have \"d_IN g x = d_IN (f \\<oplus> ?j) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN g x =\n    d_IN (f \\<oplus> (j \\<circ> map_prod Some Some \\<circ> prod.swap)) x", "by(simp add: g_def)"], ["proof (state)\nthis:\n  d_IN g x =\n  d_IN (f \\<oplus> (j \\<circ> map_prod Some Some \\<circ> prod.swap)) x\n\ngoal (2 subgoals):\n 1. x \\<in> B \\<Gamma> \\<Longrightarrow>\n    d_IN g x = d_IN f x + j (None, \\<langle>x\\<rangle>)\n 2. x \\<notin> B \\<Gamma> \\<Longrightarrow>\n    d_IN g x = d_IN f x + j (None, \\<langle>x\\<rangle>)", "also"], ["proof (state)\nthis:\n  d_IN g x =\n  d_IN (f \\<oplus> (j \\<circ> map_prod Some Some \\<circ> prod.swap)) x\n\ngoal (2 subgoals):\n 1. x \\<in> B \\<Gamma> \\<Longrightarrow>\n    d_IN g x = d_IN f x + j (None, \\<langle>x\\<rangle>)\n 2. x \\<notin> B \\<Gamma> \\<Longrightarrow>\n    d_IN g x = d_IN f x + j (None, \\<langle>x\\<rangle>)", "have \"\\<dots> = (\\<Sum>\\<^sup>+ y\\<in>\\<^bold>I\\<^bold>N x. f (y, x) + j (Some x, Some y) - j (Some y, Some x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN (f \\<oplus> (j \\<circ> map_prod Some Some \\<circ> prod.swap)) x =\n    (\\<Sum>\\<^sup>+ y\\<in>\\<^bold>I\\<^bold>N x.\n       f (y, x) + j (\\<langle>x\\<rangle>, \\<langle>y\\<rangle>) -\n       j (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>))", "by(auto simp add: d_IN_def currentD_outside[OF f'] incoming_def nn_integral_count_space_indicator intro!: nn_integral_cong)"], ["proof (state)\nthis:\n  d_IN (f \\<oplus> (j \\<circ> map_prod Some Some \\<circ> prod.swap)) x =\n  (\\<Sum>\\<^sup>+ y\\<in>\\<^bold>I\\<^bold>N x.\n     f (y, x) + j (\\<langle>x\\<rangle>, \\<langle>y\\<rangle>) -\n     j (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>))\n\ngoal (2 subgoals):\n 1. x \\<in> B \\<Gamma> \\<Longrightarrow>\n    d_IN g x = d_IN f x + j (None, \\<langle>x\\<rangle>)\n 2. x \\<notin> B \\<Gamma> \\<Longrightarrow>\n    d_IN g x = d_IN f x + j (None, \\<langle>x\\<rangle>)", "also"], ["proof (state)\nthis:\n  d_IN (f \\<oplus> (j \\<circ> map_prod Some Some \\<circ> prod.swap)) x =\n  (\\<Sum>\\<^sup>+ y\\<in>\\<^bold>I\\<^bold>N x.\n     f (y, x) + j (\\<langle>x\\<rangle>, \\<langle>y\\<rangle>) -\n     j (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>))\n\ngoal (2 subgoals):\n 1. x \\<in> B \\<Gamma> \\<Longrightarrow>\n    d_IN g x = d_IN f x + j (None, \\<langle>x\\<rangle>)\n 2. x \\<notin> B \\<Gamma> \\<Longrightarrow>\n    d_IN g x = d_IN f x + j (None, \\<langle>x\\<rangle>)", "have \"\\<dots> = (\\<Sum>\\<^sup>+ y\\<in>\\<^bold>I\\<^bold>N x. f (y, x) + j (Some x, Some y)) - (\\<Sum>\\<^sup>+ y\\<in>\\<^bold>I\\<^bold>N x. j (Some y, Some x))\"\n      (is \"_ = _ - ?j_IN\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y\\<in>\\<^bold>I\\<^bold>N x.\n       f (y, x) + j (\\<langle>x\\<rangle>, \\<langle>y\\<rangle>) -\n       j (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>)) =\n    (\\<Sum>\\<^sup>+ y\\<in>\\<^bold>I\\<^bold>N x.\n       f (y, x) + j (\\<langle>x\\<rangle>, \\<langle>y\\<rangle>)) -\n    (\\<Sum>\\<^sup>+ y\\<in>\\<^bold>I\\<^bold>N x.\n       j (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>))", "using finite"], ["proof (prove)\nusing this:\n  (\\<Sum>\\<^sup>+ y\\<in>\\<^bold>I\\<^bold>N x.\n     j (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>)) \\<noteq>\n  \\<top>\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y\\<in>\\<^bold>I\\<^bold>N x.\n       f (y, x) + j (\\<langle>x\\<rangle>, \\<langle>y\\<rangle>) -\n       j (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>)) =\n    (\\<Sum>\\<^sup>+ y\\<in>\\<^bold>I\\<^bold>N x.\n       f (y, x) + j (\\<langle>x\\<rangle>, \\<langle>y\\<rangle>)) -\n    (\\<Sum>\\<^sup>+ y\\<in>\\<^bold>I\\<^bold>N x.\n       j (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>))", "by(subst nn_integral_diff)(auto simp add: AE_count_space incoming_def intro!: order_trans[OF j_le_f])"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y\\<in>\\<^bold>I\\<^bold>N x.\n     f (y, x) + j (\\<langle>x\\<rangle>, \\<langle>y\\<rangle>) -\n     j (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>)) =\n  (\\<Sum>\\<^sup>+ y\\<in>\\<^bold>I\\<^bold>N x.\n     f (y, x) + j (\\<langle>x\\<rangle>, \\<langle>y\\<rangle>)) -\n  (\\<Sum>\\<^sup>+ y\\<in>\\<^bold>I\\<^bold>N x.\n     j (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>))\n\ngoal (2 subgoals):\n 1. x \\<in> B \\<Gamma> \\<Longrightarrow>\n    d_IN g x = d_IN f x + j (None, \\<langle>x\\<rangle>)\n 2. x \\<notin> B \\<Gamma> \\<Longrightarrow>\n    d_IN g x = d_IN f x + j (None, \\<langle>x\\<rangle>)", "also"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y\\<in>\\<^bold>I\\<^bold>N x.\n     f (y, x) + j (\\<langle>x\\<rangle>, \\<langle>y\\<rangle>) -\n     j (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>)) =\n  (\\<Sum>\\<^sup>+ y\\<in>\\<^bold>I\\<^bold>N x.\n     f (y, x) + j (\\<langle>x\\<rangle>, \\<langle>y\\<rangle>)) -\n  (\\<Sum>\\<^sup>+ y\\<in>\\<^bold>I\\<^bold>N x.\n     j (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>))\n\ngoal (2 subgoals):\n 1. x \\<in> B \\<Gamma> \\<Longrightarrow>\n    d_IN g x = d_IN f x + j (None, \\<langle>x\\<rangle>)\n 2. x \\<notin> B \\<Gamma> \\<Longrightarrow>\n    d_IN g x = d_IN f x + j (None, \\<langle>x\\<rangle>)", "have \"\\<dots> = (\\<Sum>\\<^sup>+ y\\<in>\\<^bold>I\\<^bold>N x. f (y, x)) + (\\<Sum>\\<^sup>+ y\\<in>\\<^bold>I\\<^bold>N x. j (Some x, Some y)) - ?j_IN\"\n      (is \"_ = ?f + ?j_OUT - _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y\\<in>\\<^bold>I\\<^bold>N x.\n       f (y, x) + j (\\<langle>x\\<rangle>, \\<langle>y\\<rangle>)) -\n    (\\<Sum>\\<^sup>+ y\\<in>\\<^bold>I\\<^bold>N x.\n       j (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>)) =\n    (\\<Sum>\\<^sup>+ y\\<in>\\<^bold>I\\<^bold>N x. f (y, x)) +\n    (\\<Sum>\\<^sup>+ y\\<in>\\<^bold>I\\<^bold>N x.\n       j (\\<langle>x\\<rangle>, \\<langle>y\\<rangle>)) -\n    (\\<Sum>\\<^sup>+ y\\<in>\\<^bold>I\\<^bold>N x.\n       j (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>))", "by(subst nn_integral_add) simp_all"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y\\<in>\\<^bold>I\\<^bold>N x.\n     f (y, x) + j (\\<langle>x\\<rangle>, \\<langle>y\\<rangle>)) -\n  (\\<Sum>\\<^sup>+ y\\<in>\\<^bold>I\\<^bold>N x.\n     j (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>)) =\n  (\\<Sum>\\<^sup>+ y\\<in>\\<^bold>I\\<^bold>N x. f (y, x)) +\n  (\\<Sum>\\<^sup>+ y\\<in>\\<^bold>I\\<^bold>N x.\n     j (\\<langle>x\\<rangle>, \\<langle>y\\<rangle>)) -\n  (\\<Sum>\\<^sup>+ y\\<in>\\<^bold>I\\<^bold>N x.\n     j (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>))\n\ngoal (2 subgoals):\n 1. x \\<in> B \\<Gamma> \\<Longrightarrow>\n    d_IN g x = d_IN f x + j (None, \\<langle>x\\<rangle>)\n 2. x \\<notin> B \\<Gamma> \\<Longrightarrow>\n    d_IN g x = d_IN f x + j (None, \\<langle>x\\<rangle>)", "also"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y\\<in>\\<^bold>I\\<^bold>N x.\n     f (y, x) + j (\\<langle>x\\<rangle>, \\<langle>y\\<rangle>)) -\n  (\\<Sum>\\<^sup>+ y\\<in>\\<^bold>I\\<^bold>N x.\n     j (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>)) =\n  (\\<Sum>\\<^sup>+ y\\<in>\\<^bold>I\\<^bold>N x. f (y, x)) +\n  (\\<Sum>\\<^sup>+ y\\<in>\\<^bold>I\\<^bold>N x.\n     j (\\<langle>x\\<rangle>, \\<langle>y\\<rangle>)) -\n  (\\<Sum>\\<^sup>+ y\\<in>\\<^bold>I\\<^bold>N x.\n     j (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>))\n\ngoal (2 subgoals):\n 1. x \\<in> B \\<Gamma> \\<Longrightarrow>\n    d_IN g x = d_IN f x + j (None, \\<langle>x\\<rangle>)\n 2. x \\<notin> B \\<Gamma> \\<Longrightarrow>\n    d_IN g x = d_IN f x + j (None, \\<langle>x\\<rangle>)", "have \"?f = d_IN f x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y\\<in>\\<^bold>I\\<^bold>N x. f (y, x)) = d_IN f x", "by(subst d_IN_alt_def[where G=\\<Gamma>])(simp_all add: currentD_outside[OF f])"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y\\<in>\\<^bold>I\\<^bold>N x. f (y, x)) = d_IN f x\n\ngoal (2 subgoals):\n 1. x \\<in> B \\<Gamma> \\<Longrightarrow>\n    d_IN g x = d_IN f x + j (None, \\<langle>x\\<rangle>)\n 2. x \\<notin> B \\<Gamma> \\<Longrightarrow>\n    d_IN g x = d_IN f x + j (None, \\<langle>x\\<rangle>)", "also"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y\\<in>\\<^bold>I\\<^bold>N x. f (y, x)) = d_IN f x\n\ngoal (2 subgoals):\n 1. x \\<in> B \\<Gamma> \\<Longrightarrow>\n    d_IN g x = d_IN f x + j (None, \\<langle>x\\<rangle>)\n 2. x \\<notin> B \\<Gamma> \\<Longrightarrow>\n    d_IN g x = d_IN f x + j (None, \\<langle>x\\<rangle>)", "have \"?j_OUT = (\\<Sum>\\<^sup>+ y\\<in>range Some. j (Some x, y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y\\<in>\\<^bold>I\\<^bold>N x.\n       j (\\<langle>x\\<rangle>, \\<langle>y\\<rangle>)) =\n    (\\<Sum>\\<^sup>+ y\\<in>range Some. j (\\<langle>x\\<rangle>, y))", "using True disjoint"], ["proof (prove)\nusing this:\n  x \\<in> B \\<Gamma>\n  A \\<Gamma> \\<inter> B \\<Gamma> = {}\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y\\<in>\\<^bold>I\\<^bold>N x.\n       j (\\<langle>x\\<rangle>, \\<langle>y\\<rangle>)) =\n    (\\<Sum>\\<^sup>+ y\\<in>range Some. j (\\<langle>x\\<rangle>, y))", "by(simp add: nn_integral_count_space_reindex)(auto 4 4 simp add: nn_integral_count_space_indicator incoming_def intro!: nn_integral_cong \\<Psi>.flowD_outside[OF j] split: split_indicator dest: bipartite_E)"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y\\<in>\\<^bold>I\\<^bold>N x.\n     j (\\<langle>x\\<rangle>, \\<langle>y\\<rangle>)) =\n  (\\<Sum>\\<^sup>+ y\\<in>range Some. j (\\<langle>x\\<rangle>, y))\n\ngoal (2 subgoals):\n 1. x \\<in> B \\<Gamma> \\<Longrightarrow>\n    d_IN g x = d_IN f x + j (None, \\<langle>x\\<rangle>)\n 2. x \\<notin> B \\<Gamma> \\<Longrightarrow>\n    d_IN g x = d_IN f x + j (None, \\<langle>x\\<rangle>)", "also"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y\\<in>\\<^bold>I\\<^bold>N x.\n     j (\\<langle>x\\<rangle>, \\<langle>y\\<rangle>)) =\n  (\\<Sum>\\<^sup>+ y\\<in>range Some. j (\\<langle>x\\<rangle>, y))\n\ngoal (2 subgoals):\n 1. x \\<in> B \\<Gamma> \\<Longrightarrow>\n    d_IN g x = d_IN f x + j (None, \\<langle>x\\<rangle>)\n 2. x \\<notin> B \\<Gamma> \\<Longrightarrow>\n    d_IN g x = d_IN f x + j (None, \\<langle>x\\<rangle>)", "have \"\\<dots> = d_OUT j (Some x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y\\<in>range Some. j (\\<langle>x\\<rangle>, y)) =\n    d_OUT j \\<langle>x\\<rangle>", "using disjoint"], ["proof (prove)\nusing this:\n  A \\<Gamma> \\<inter> B \\<Gamma> = {}\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y\\<in>range Some. j (\\<langle>x\\<rangle>, y)) =\n    d_OUT j \\<langle>x\\<rangle>", "by(auto 4 3 simp add: d_OUT_def nn_integral_count_space_indicator notin_range_Some intro!: nn_integral_cong \\<Psi>.flowD_outside[OF j] split: split_indicator)"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y\\<in>range Some. j (\\<langle>x\\<rangle>, y)) =\n  d_OUT j \\<langle>x\\<rangle>\n\ngoal (2 subgoals):\n 1. x \\<in> B \\<Gamma> \\<Longrightarrow>\n    d_IN g x = d_IN f x + j (None, \\<langle>x\\<rangle>)\n 2. x \\<notin> B \\<Gamma> \\<Longrightarrow>\n    d_IN g x = d_IN f x + j (None, \\<langle>x\\<rangle>)", "also"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y\\<in>range Some. j (\\<langle>x\\<rangle>, y)) =\n  d_OUT j \\<langle>x\\<rangle>\n\ngoal (2 subgoals):\n 1. x \\<in> B \\<Gamma> \\<Longrightarrow>\n    d_IN g x = d_IN f x + j (None, \\<langle>x\\<rangle>)\n 2. x \\<notin> B \\<Gamma> \\<Longrightarrow>\n    d_IN g x = d_IN f x + j (None, \\<langle>x\\<rangle>)", "have \"\\<dots> = d_IN j (Some x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. KIR j \\<langle>x\\<rangle>", "using flowD_KIR[OF j, of \"Some x\"] True a disjoint"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<langle>x\\<rangle> \\<noteq> source \\<Psi>;\n   \\<langle>x\\<rangle> \\<noteq> sink \\<Psi>\\<rbrakk>\n  \\<Longrightarrow> KIR j \\<langle>x\\<rangle>\n  x \\<in> B \\<Gamma>\n  a \\<in> A \\<Gamma>\n  a \\<notin> \\<E>\\<^bsub>\\<Gamma>\\<lparr>weight := weight \\<Gamma> - u\\<rparr>\\<^esub>\n              (TER\\<^bsub>\\<Gamma>\\<lparr>weight := weight \\<Gamma> - u\\<rparr>\\<^esub>\n                f)\n  A \\<Gamma> \\<inter> B \\<Gamma> = {}\n\ngoal (1 subgoal):\n 1. KIR j \\<langle>x\\<rangle>", "by auto"], ["proof (state)\nthis:\n  KIR j \\<langle>x\\<rangle>\n\ngoal (2 subgoals):\n 1. x \\<in> B \\<Gamma> \\<Longrightarrow>\n    d_IN g x = d_IN f x + j (None, \\<langle>x\\<rangle>)\n 2. x \\<notin> B \\<Gamma> \\<Longrightarrow>\n    d_IN g x = d_IN f x + j (None, \\<langle>x\\<rangle>)", "also"], ["proof (state)\nthis:\n  KIR j \\<langle>x\\<rangle>\n\ngoal (2 subgoals):\n 1. x \\<in> B \\<Gamma> \\<Longrightarrow>\n    d_IN g x = d_IN f x + j (None, \\<langle>x\\<rangle>)\n 2. x \\<notin> B \\<Gamma> \\<Longrightarrow>\n    d_IN g x = d_IN f x + j (None, \\<langle>x\\<rangle>)", "have \"?j_IN = (\\<Sum>\\<^sup>+ y\\<in>range Some. j (y, Some x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y\\<in>\\<^bold>I\\<^bold>N x.\n       j (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>)) =\n    (\\<Sum>\\<^sup>+ y\\<in>range Some. j (y, \\<langle>x\\<rangle>))", "using True disjoint"], ["proof (prove)\nusing this:\n  x \\<in> B \\<Gamma>\n  A \\<Gamma> \\<inter> B \\<Gamma> = {}\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y\\<in>\\<^bold>I\\<^bold>N x.\n       j (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>)) =\n    (\\<Sum>\\<^sup>+ y\\<in>range Some. j (y, \\<langle>x\\<rangle>))", "by(simp add: nn_integral_count_space_reindex)(auto 4 4 simp add: nn_integral_count_space_indicator incoming_def intro!: nn_integral_cong \\<Psi>.flowD_outside[OF j] dest: bipartite_E split: split_indicator)"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y\\<in>\\<^bold>I\\<^bold>N x.\n     j (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>)) =\n  (\\<Sum>\\<^sup>+ y\\<in>range Some. j (y, \\<langle>x\\<rangle>))\n\ngoal (2 subgoals):\n 1. x \\<in> B \\<Gamma> \\<Longrightarrow>\n    d_IN g x = d_IN f x + j (None, \\<langle>x\\<rangle>)\n 2. x \\<notin> B \\<Gamma> \\<Longrightarrow>\n    d_IN g x = d_IN f x + j (None, \\<langle>x\\<rangle>)", "also"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y\\<in>\\<^bold>I\\<^bold>N x.\n     j (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>)) =\n  (\\<Sum>\\<^sup>+ y\\<in>range Some. j (y, \\<langle>x\\<rangle>))\n\ngoal (2 subgoals):\n 1. x \\<in> B \\<Gamma> \\<Longrightarrow>\n    d_IN g x = d_IN f x + j (None, \\<langle>x\\<rangle>)\n 2. x \\<notin> B \\<Gamma> \\<Longrightarrow>\n    d_IN g x = d_IN f x + j (None, \\<langle>x\\<rangle>)", "have \"\\<dots> = d_IN j (Some x) - (\\<Sum>\\<^sup>+ y :: 'v option. j (None, Some x) * indicator {None} y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y\\<in>range Some. j (y, \\<langle>x\\<rangle>)) =\n    d_IN j \\<langle>x\\<rangle> -\n    (\\<integral>\\<^sup>+y\\<in>{None}. j (None, \\<langle>x\\<rangle>)\n     \\<partial>count_space UNIV)", "unfolding d_IN_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y\\<in>range Some. j (y, \\<langle>x\\<rangle>)) =\n    (\\<Sum>\\<^sup>+ xa. j (xa, \\<langle>x\\<rangle>)) -\n    (\\<integral>\\<^sup>+y\\<in>{None}. j (None, \\<langle>x\\<rangle>)\n     \\<partial>count_space UNIV)", "using flowD_capacity[OF j, of \"(None, Some x)\"]"], ["proof (prove)\nusing this:\n  j (None, \\<langle>x\\<rangle>)\n  \\<le> capacity \\<Psi> (None, \\<langle>x\\<rangle>)\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y\\<in>range Some. j (y, \\<langle>x\\<rangle>)) =\n    (\\<Sum>\\<^sup>+ xa. j (xa, \\<langle>x\\<rangle>)) -\n    (\\<integral>\\<^sup>+y\\<in>{None}. j (None, \\<langle>x\\<rangle>)\n     \\<partial>count_space UNIV)", "by(subst nn_integral_diff[symmetric])\n        (auto simp add: nn_integral_count_space_indicator AE_count_space top_unique image_iff\n              intro!: nn_integral_cong ennreal_diff_self split: split_indicator if_split_asm)"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y\\<in>range Some. j (y, \\<langle>x\\<rangle>)) =\n  d_IN j \\<langle>x\\<rangle> -\n  (\\<integral>\\<^sup>+y\\<in>{None}. j (None, \\<langle>x\\<rangle>)\n   \\<partial>count_space UNIV)\n\ngoal (2 subgoals):\n 1. x \\<in> B \\<Gamma> \\<Longrightarrow>\n    d_IN g x = d_IN f x + j (None, \\<langle>x\\<rangle>)\n 2. x \\<notin> B \\<Gamma> \\<Longrightarrow>\n    d_IN g x = d_IN f x + j (None, \\<langle>x\\<rangle>)", "also"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y\\<in>range Some. j (y, \\<langle>x\\<rangle>)) =\n  d_IN j \\<langle>x\\<rangle> -\n  (\\<integral>\\<^sup>+y\\<in>{None}. j (None, \\<langle>x\\<rangle>)\n   \\<partial>count_space UNIV)\n\ngoal (2 subgoals):\n 1. x \\<in> B \\<Gamma> \\<Longrightarrow>\n    d_IN g x = d_IN f x + j (None, \\<langle>x\\<rangle>)\n 2. x \\<notin> B \\<Gamma> \\<Longrightarrow>\n    d_IN g x = d_IN f x + j (None, \\<langle>x\\<rangle>)", "have \"d_IN f x + d_IN j (Some x) - \\<dots> = d_IN f x + j (None, Some x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN f x + d_IN j \\<langle>x\\<rangle> -\n    (d_IN j \\<langle>x\\<rangle> -\n     (\\<integral>\\<^sup>+y\\<in>{None}. j (None, \\<langle>x\\<rangle>)\n      \\<partial>count_space UNIV)) =\n    d_IN f x + j (None, \\<langle>x\\<rangle>)", "using ennreal_add_diff_cancel_right[OF IN_j_finite[of \"Some x\"], of \"d_IN f x + j (None, Some x)\"]"], ["proof (prove)\nusing this:\n  d_IN f x + j (None, \\<langle>x\\<rangle>) + d_IN j \\<langle>x\\<rangle> -\n  d_IN j \\<langle>x\\<rangle> =\n  d_IN f x + j (None, \\<langle>x\\<rangle>)\n\ngoal (1 subgoal):\n 1. d_IN f x + d_IN j \\<langle>x\\<rangle> -\n    (d_IN j \\<langle>x\\<rangle> -\n     (\\<integral>\\<^sup>+y\\<in>{None}. j (None, \\<langle>x\\<rangle>)\n      \\<partial>count_space UNIV)) =\n    d_IN f x + j (None, \\<langle>x\\<rangle>)", "apply(subst diff_diff_ennreal')"], ["proof (prove)\ngoal (3 subgoals):\n 1. d_IN f x + j (None, \\<langle>x\\<rangle>) + d_IN j \\<langle>x\\<rangle> -\n    d_IN j \\<langle>x\\<rangle> =\n    d_IN f x + j (None, \\<langle>x\\<rangle>) \\<Longrightarrow>\n    \\<integral>\\<^sup>+y\\<in>{None}. j (None, \\<langle>x\\<rangle>)\n    \\<partial>count_space UNIV\n    \\<le> d_IN j \\<langle>x\\<rangle>\n 2. d_IN f x + j (None, \\<langle>x\\<rangle>) + d_IN j \\<langle>x\\<rangle> -\n    d_IN j \\<langle>x\\<rangle> =\n    d_IN f x + j (None, \\<langle>x\\<rangle>) \\<Longrightarrow>\n    d_IN j \\<langle>x\\<rangle> -\n    (\\<integral>\\<^sup>+y\\<in>{None}. j (None, \\<langle>x\\<rangle>)\n     \\<partial>count_space UNIV)\n    \\<le> d_IN f x + d_IN j \\<langle>x\\<rangle>\n 3. d_IN f x + j (None, \\<langle>x\\<rangle>) + d_IN j \\<langle>x\\<rangle> -\n    d_IN j \\<langle>x\\<rangle> =\n    d_IN f x + j (None, \\<langle>x\\<rangle>) \\<Longrightarrow>\n    d_IN f x + d_IN j \\<langle>x\\<rangle> +\n    (\\<integral>\\<^sup>+y\\<in>{None}. j (None, \\<langle>x\\<rangle>)\n     \\<partial>count_space UNIV) -\n    d_IN j \\<langle>x\\<rangle> =\n    d_IN f x + j (None, \\<langle>x\\<rangle>)", "apply(auto simp add: d_IN_def intro!: nn_integral_ge_point ennreal_diff_le_mono_left)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ xa. f (xa, x)) + j (None, \\<langle>x\\<rangle>) +\n    (\\<Sum>\\<^sup>+ xa. j (xa, \\<langle>x\\<rangle>)) -\n    (\\<Sum>\\<^sup>+ xa. j (xa, \\<langle>x\\<rangle>)) =\n    (\\<Sum>\\<^sup>+ xa. f (xa, x)) +\n    j (None, \\<langle>x\\<rangle>) \\<Longrightarrow>\n    (\\<Sum>\\<^sup>+ xa. f (xa, x)) +\n    (\\<Sum>\\<^sup>+ xa. j (xa, \\<langle>x\\<rangle>)) +\n    j (None, \\<langle>x\\<rangle>) -\n    (\\<Sum>\\<^sup>+ xa. j (xa, \\<langle>x\\<rangle>)) =\n    (\\<Sum>\\<^sup>+ xa. f (xa, x)) + j (None, \\<langle>x\\<rangle>)", "apply(simp add: ac_simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  d_IN f x + d_IN j \\<langle>x\\<rangle> -\n  (d_IN j \\<langle>x\\<rangle> -\n   (\\<integral>\\<^sup>+y\\<in>{None}. j (None, \\<langle>x\\<rangle>)\n    \\<partial>count_space UNIV)) =\n  d_IN f x + j (None, \\<langle>x\\<rangle>)\n\ngoal (2 subgoals):\n 1. x \\<in> B \\<Gamma> \\<Longrightarrow>\n    d_IN g x = d_IN f x + j (None, \\<langle>x\\<rangle>)\n 2. x \\<notin> B \\<Gamma> \\<Longrightarrow>\n    d_IN g x = d_IN f x + j (None, \\<langle>x\\<rangle>)", "finally"], ["proof (chain)\npicking this:\n  d_IN g x = d_IN f x + j (None, \\<langle>x\\<rangle>)", "show ?thesis"], ["proof (prove)\nusing this:\n  d_IN g x = d_IN f x + j (None, \\<langle>x\\<rangle>)\n\ngoal (1 subgoal):\n 1. d_IN g x = d_IN f x + j (None, \\<langle>x\\<rangle>)", "."], ["proof (state)\nthis:\n  d_IN g x = d_IN f x + j (None, \\<langle>x\\<rangle>)\n\ngoal (1 subgoal):\n 1. x \\<notin> B \\<Gamma> \\<Longrightarrow>\n    d_IN g x = d_IN f x + j (None, \\<langle>x\\<rangle>)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<notin> B \\<Gamma> \\<Longrightarrow>\n    d_IN g x = d_IN f x + j (None, \\<langle>x\\<rangle>)", "case False"], ["proof (state)\nthis:\n  x \\<notin> B \\<Gamma>\n\ngoal (1 subgoal):\n 1. x \\<notin> B \\<Gamma> \\<Longrightarrow>\n    d_IN g x = d_IN f x + j (None, \\<langle>x\\<rangle>)", "hence \"d_IN g x = 0\" \"d_IN f x = 0\" \"j (None, \\<langle>x\\<rangle>) = 0\""], ["proof (prove)\nusing this:\n  x \\<notin> B \\<Gamma>\n\ngoal (1 subgoal):\n 1. d_IN g x = 0 &&& d_IN f x = 0 &&& j (None, \\<langle>x\\<rangle>) = 0", "using disjoint currentD_IN[OF f', of x] bipartite_V currentD_outside_IN[OF f'] u_outside[OF False] flowD_capacity[OF j, of \"(None, \\<langle>x\\<rangle>)\"]"], ["proof (prove)\nusing this:\n  x \\<notin> B \\<Gamma>\n  A \\<Gamma> \\<inter> B \\<Gamma> = {}\n  x \\<in> A \\<Gamma> \\<Longrightarrow> d_IN f x = 0\n  \\<^bold>V \\<subseteq> A \\<Gamma> \\<union> B \\<Gamma>\n  ?x \\<notin> \\<^bold>V \\<Longrightarrow> d_IN f ?x = 0\n  u x = 0\n  j (None, \\<langle>x\\<rangle>)\n  \\<le> capacity \\<Psi> (None, \\<langle>x\\<rangle>)\n\ngoal (1 subgoal):\n 1. d_IN g x = 0 &&& d_IN f x = 0 &&& j (None, \\<langle>x\\<rangle>) = 0", "by(cases \"vertex \\<Gamma> x\"; auto simp add: d_IN_def nn_integral_0_iff_AE AE_count_space g_simps dest: bipartite_E split: if_split_asm)+"], ["proof (state)\nthis:\n  d_IN g x = 0\n  d_IN f x = 0\n  j (None, \\<langle>x\\<rangle>) = 0\n\ngoal (1 subgoal):\n 1. x \\<notin> B \\<Gamma> \\<Longrightarrow>\n    d_IN g x = d_IN f x + j (None, \\<langle>x\\<rangle>)", "thus ?thesis"], ["proof (prove)\nusing this:\n  d_IN g x = 0\n  d_IN f x = 0\n  j (None, \\<langle>x\\<rangle>) = 0\n\ngoal (1 subgoal):\n 1. d_IN g x = d_IN f x + j (None, \\<langle>x\\<rangle>)", "by simp"], ["proof (state)\nthis:\n  d_IN g x = d_IN f x + j (None, \\<langle>x\\<rangle>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  d_IN g ?x = d_IN f ?x + j (None, \\<langle>?x\\<rangle>)\n\ngoal (1 subgoal):\n 1. hindered \\<Gamma>", "have g: \"current \\<Gamma> g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. current \\<Gamma> g", "proof"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x. d_OUT g x \\<le> weight \\<Gamma> x\n 2. \\<And>x. d_IN g x \\<le> weight \\<Gamma> x\n 3. \\<And>e. e \\<notin> \\<^bold>E \\<Longrightarrow> g e = 0", "show \"d_OUT g x \\<le> weight \\<Gamma> x\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT g x \\<le> weight \\<Gamma> x", "proof(cases \"x \\<in> A \\<Gamma>\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<in> A \\<Gamma> \\<Longrightarrow> d_OUT g x \\<le> weight \\<Gamma> x\n 2. x \\<notin> A \\<Gamma> \\<Longrightarrow>\n    d_OUT g x \\<le> weight \\<Gamma> x", "case False"], ["proof (state)\nthis:\n  x \\<notin> A \\<Gamma>\n\ngoal (2 subgoals):\n 1. x \\<in> A \\<Gamma> \\<Longrightarrow> d_OUT g x \\<le> weight \\<Gamma> x\n 2. x \\<notin> A \\<Gamma> \\<Longrightarrow>\n    d_OUT g x \\<le> weight \\<Gamma> x", "thus ?thesis"], ["proof (prove)\nusing this:\n  x \\<notin> A \\<Gamma>\n\ngoal (1 subgoal):\n 1. d_OUT g x \\<le> weight \\<Gamma> x", "by(simp add: OUT_g_B)"], ["proof (state)\nthis:\n  d_OUT g x \\<le> weight \\<Gamma> x\n\ngoal (1 subgoal):\n 1. x \\<in> A \\<Gamma> \\<Longrightarrow> d_OUT g x \\<le> weight \\<Gamma> x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<in> A \\<Gamma> \\<Longrightarrow> d_OUT g x \\<le> weight \\<Gamma> x", "case True"], ["proof (state)\nthis:\n  x \\<in> A \\<Gamma>\n\ngoal (1 subgoal):\n 1. x \\<in> A \\<Gamma> \\<Longrightarrow> d_OUT g x \\<le> weight \\<Gamma> x", "with OUT_g_a"], ["proof (chain)\npicking this:\n  d_OUT g a < weight \\<Gamma> a\n  x \\<in> A \\<Gamma>", "show ?thesis"], ["proof (prove)\nusing this:\n  d_OUT g a < weight \\<Gamma> a\n  x \\<in> A \\<Gamma>\n\ngoal (1 subgoal):\n 1. d_OUT g x \\<le> weight \\<Gamma> x", "by(cases \"x = a\")(simp_all add: OUT_g_A flowD_KIR[OF j] currentD_weight_OUT[OF f'])"], ["proof (state)\nthis:\n  d_OUT g x \\<le> weight \\<Gamma> x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  d_OUT g ?x \\<le> weight \\<Gamma> ?x\n\ngoal (2 subgoals):\n 1. \\<And>x. d_IN g x \\<le> weight \\<Gamma> x\n 2. \\<And>e. e \\<notin> \\<^bold>E \\<Longrightarrow> g e = 0", "show \"d_IN g x \\<le> weight \\<Gamma> x\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN g x \\<le> weight \\<Gamma> x", "proof(cases \"x \\<in> B \\<Gamma>\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<in> B \\<Gamma> \\<Longrightarrow> d_IN g x \\<le> weight \\<Gamma> x\n 2. x \\<notin> B \\<Gamma> \\<Longrightarrow> d_IN g x \\<le> weight \\<Gamma> x", "case False"], ["proof (state)\nthis:\n  x \\<notin> B \\<Gamma>\n\ngoal (2 subgoals):\n 1. x \\<in> B \\<Gamma> \\<Longrightarrow> d_IN g x \\<le> weight \\<Gamma> x\n 2. x \\<notin> B \\<Gamma> \\<Longrightarrow> d_IN g x \\<le> weight \\<Gamma> x", "hence \"d_IN g x = 0\""], ["proof (prove)\nusing this:\n  x \\<notin> B \\<Gamma>\n\ngoal (1 subgoal):\n 1. d_IN g x = 0", "using disjoint"], ["proof (prove)\nusing this:\n  x \\<notin> B \\<Gamma>\n  A \\<Gamma> \\<inter> B \\<Gamma> = {}\n\ngoal (1 subgoal):\n 1. d_IN g x = 0", "by(auto simp add: d_IN_def nn_integral_0_iff_AE AE_count_space g_simps dest: bipartite_E)"], ["proof (state)\nthis:\n  d_IN g x = 0\n\ngoal (2 subgoals):\n 1. x \\<in> B \\<Gamma> \\<Longrightarrow> d_IN g x \\<le> weight \\<Gamma> x\n 2. x \\<notin> B \\<Gamma> \\<Longrightarrow> d_IN g x \\<le> weight \\<Gamma> x", "thus ?thesis"], ["proof (prove)\nusing this:\n  d_IN g x = 0\n\ngoal (1 subgoal):\n 1. d_IN g x \\<le> weight \\<Gamma> x", "by simp"], ["proof (state)\nthis:\n  d_IN g x \\<le> weight \\<Gamma> x\n\ngoal (1 subgoal):\n 1. x \\<in> B \\<Gamma> \\<Longrightarrow> d_IN g x \\<le> weight \\<Gamma> x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<in> B \\<Gamma> \\<Longrightarrow> d_IN g x \\<le> weight \\<Gamma> x", "case True"], ["proof (state)\nthis:\n  x \\<in> B \\<Gamma>\n\ngoal (1 subgoal):\n 1. x \\<in> B \\<Gamma> \\<Longrightarrow> d_IN g x \\<le> weight \\<Gamma> x", "have \"d_IN g x \\<le> (weight \\<Gamma> x - u x) + u x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN g x \\<le> weight \\<Gamma> x - u x + u x", "unfolding IN_g"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN f x + j (None, \\<langle>x\\<rangle>)\n    \\<le> weight \\<Gamma> x - u x + u x", "using currentD_weight_IN[OF f, of x] flowD_capacity[OF j, of \"(None, Some x)\"] True bipartite_V"], ["proof (prove)\nusing this:\n  d_IN f x\n  \\<le> weight (\\<Gamma>\\<lparr>weight := weight \\<Gamma> - u\\<rparr>) x\n  j (None, \\<langle>x\\<rangle>)\n  \\<le> capacity \\<Psi> (None, \\<langle>x\\<rangle>)\n  x \\<in> B \\<Gamma>\n  \\<^bold>V \\<subseteq> A \\<Gamma> \\<union> B \\<Gamma>\n\ngoal (1 subgoal):\n 1. d_IN f x + j (None, \\<langle>x\\<rangle>)\n    \\<le> weight \\<Gamma> x - u x + u x", "by(intro add_mono)(simp_all split: if_split_asm)"], ["proof (state)\nthis:\n  d_IN g x \\<le> weight \\<Gamma> x - u x + u x\n\ngoal (1 subgoal):\n 1. x \\<in> B \\<Gamma> \\<Longrightarrow> d_IN g x \\<le> weight \\<Gamma> x", "also"], ["proof (state)\nthis:\n  d_IN g x \\<le> weight \\<Gamma> x - u x + u x\n\ngoal (1 subgoal):\n 1. x \\<in> B \\<Gamma> \\<Longrightarrow> d_IN g x \\<le> weight \\<Gamma> x", "have \"\\<dots> = weight \\<Gamma> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. weight \\<Gamma> x - u x + u x = weight \\<Gamma> x", "using u"], ["proof (prove)\nusing this:\n  u \\<le> weight \\<Gamma>\n\ngoal (1 subgoal):\n 1. weight \\<Gamma> x - u x + u x = weight \\<Gamma> x", "by (intro diff_add_cancel_ennreal) (simp add: le_fun_def)"], ["proof (state)\nthis:\n  weight \\<Gamma> x - u x + u x = weight \\<Gamma> x\n\ngoal (1 subgoal):\n 1. x \\<in> B \\<Gamma> \\<Longrightarrow> d_IN g x \\<le> weight \\<Gamma> x", "finally"], ["proof (chain)\npicking this:\n  d_IN g x \\<le> weight \\<Gamma> x", "show ?thesis"], ["proof (prove)\nusing this:\n  d_IN g x \\<le> weight \\<Gamma> x\n\ngoal (1 subgoal):\n 1. d_IN g x \\<le> weight \\<Gamma> x", "."], ["proof (state)\nthis:\n  d_IN g x \\<le> weight \\<Gamma> x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  d_IN g ?x \\<le> weight \\<Gamma> ?x\n\ngoal (1 subgoal):\n 1. \\<And>e. e \\<notin> \\<^bold>E \\<Longrightarrow> g e = 0", "show \"g e = 0\" if \"e \\<notin> \\<^bold>E\" for e"], ["proof (prove)\ngoal (1 subgoal):\n 1. g e = 0", "using that"], ["proof (prove)\nusing this:\n  e \\<notin> \\<^bold>E\n\ngoal (1 subgoal):\n 1. g e = 0", "by(cases e)(auto simp add: g_simps)"], ["proof (state)\nthis:\n  ?e \\<notin> \\<^bold>E \\<Longrightarrow> g ?e = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  current \\<Gamma> g\n\ngoal (1 subgoal):\n 1. hindered \\<Gamma>", "define cap' where \"cap' = (\\<lambda>(x, y). if edge \\<Gamma> x y then g (x, y) else if edge \\<Gamma> y x then 1 else 0)\""], ["proof (state)\nthis:\n  cap' =\n  (\\<lambda>(x, y).\n      if edge \\<Gamma> x y then g (x, y)\n      else if edge \\<Gamma> y x then 1 else 0)\n\ngoal (1 subgoal):\n 1. hindered \\<Gamma>", "have cap'_simps [simp]: \"cap' (x, y) = (if edge \\<Gamma> x y then g (x, y) else if edge \\<Gamma> y x then 1 else 0)\"\n    for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. cap' (x, y) =\n    (if edge \\<Gamma> x y then g (x, y)\n     else if edge \\<Gamma> y x then 1 else 0)", "by(simp add: cap'_def)"], ["proof (state)\nthis:\n  cap' (?x, ?y) =\n  (if edge \\<Gamma> ?x ?y then g (?x, ?y)\n   else if edge \\<Gamma> ?y ?x then 1 else 0)\n\ngoal (1 subgoal):\n 1. hindered \\<Gamma>", "define G where \"G = \\<lparr>edge = \\<lambda>x y. cap' (x, y) > 0\\<rparr>\""], ["proof (state)\nthis:\n  G = \\<lparr>edge = \\<lambda>x y. 0 < cap' (x, y)\\<rparr>\n\ngoal (1 subgoal):\n 1. hindered \\<Gamma>", "have G_sel [simp]: \"edge G x y \\<longleftrightarrow> cap' (x, y) > 0\" for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. edge G x y = (0 < cap' (x, y))", "by(simp add: G_def)"], ["proof (state)\nthis:\n  edge G ?x ?y = (0 < cap' (?x, ?y))\n\ngoal (1 subgoal):\n 1. hindered \\<Gamma>", "define reachable where \"reachable x = (edge G)\\<^sup>*\\<^sup>* x a\" for x"], ["proof (state)\nthis:\n  reachable ?x = (edge G)\\<^sup>*\\<^sup>* ?x a\n\ngoal (1 subgoal):\n 1. hindered \\<Gamma>", "have reachable_alt_def: \"reachable \\<equiv> \\<lambda>x. \\<exists>p. path G x p a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reachable \\<equiv> \\<lambda>x. \\<exists>p. path G x p a", "by(simp add: reachable_def [abs_def] rtranclp_eq_rtrancl_path)"], ["proof (state)\nthis:\n  reachable \\<equiv> \\<lambda>x. \\<exists>p. path G x p a\n\ngoal (1 subgoal):\n 1. hindered \\<Gamma>", "have [simp]: \"reachable a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reachable a", "by(auto simp add: reachable_def)"], ["proof (state)\nthis:\n  reachable a\n\ngoal (1 subgoal):\n 1. hindered \\<Gamma>", "have AB_edge: \"edge G x y\" if \"edge \\<Gamma> y x\" for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. edge G x y", "using that"], ["proof (prove)\nusing this:\n  edge \\<Gamma> y x\n\ngoal (1 subgoal):\n 1. edge G x y", "by(auto dest: edge_antiparallel simp add: min_def le_neq_trans add_eq_0_iff_both_eq_0)"], ["proof (state)\nthis:\n  edge \\<Gamma> ?y ?x \\<Longrightarrow> edge G ?x ?y\n\ngoal (1 subgoal):\n 1. hindered \\<Gamma>", "have reachable_AB: \"reachable y\" if \"reachable x\" \"(x, y) \\<in> \\<^bold>E\" for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. reachable y", "using that"], ["proof (prove)\nusing this:\n  reachable x\n  (x, y) \\<in> \\<^bold>E\n\ngoal (1 subgoal):\n 1. reachable y", "by(auto simp add: reachable_def simp del: G_sel dest!: AB_edge intro: rtrancl_path.step)"], ["proof (state)\nthis:\n  \\<lbrakk>reachable ?x; (?x, ?y) \\<in> \\<^bold>E\\<rbrakk>\n  \\<Longrightarrow> reachable ?y\n\ngoal (1 subgoal):\n 1. hindered \\<Gamma>", "have reachable_BA: \"g (x, y) = 0\" if \"reachable y\" \"(x, y) \\<in> \\<^bold>E\" \"\\<not> reachable x\" for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. g (x, y) = 0", "proof(rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. g (x, y) \\<noteq> 0 \\<Longrightarrow> False", "assume \"g (x, y) \\<noteq> 0\""], ["proof (state)\nthis:\n  g (x, y) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. g (x, y) \\<noteq> 0 \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  g (x, y) \\<noteq> 0", "have \"g (x, y) > 0\""], ["proof (prove)\nusing this:\n  g (x, y) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 0 < g (x, y)", "by (simp add: zero_less_iff_neq_zero)"], ["proof (state)\nthis:\n  0 < g (x, y)\n\ngoal (1 subgoal):\n 1. g (x, y) \\<noteq> 0 \\<Longrightarrow> False", "hence \"edge G x y\""], ["proof (prove)\nusing this:\n  0 < g (x, y)\n\ngoal (1 subgoal):\n 1. edge G x y", "using that"], ["proof (prove)\nusing this:\n  0 < g (x, y)\n  reachable y\n  (x, y) \\<in> \\<^bold>E\n  \\<not> reachable x\n\ngoal (1 subgoal):\n 1. edge G x y", "by simp"], ["proof (state)\nthis:\n  edge G x y\n\ngoal (1 subgoal):\n 1. g (x, y) \\<noteq> 0 \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  edge G x y", "have \"reachable x\""], ["proof (prove)\nusing this:\n  edge G x y\n\ngoal (1 subgoal):\n 1. reachable x", "using \\<open>reachable y\\<close>"], ["proof (prove)\nusing this:\n  edge G x y\n  reachable y\n\ngoal (1 subgoal):\n 1. reachable x", "unfolding reachable_def"], ["proof (prove)\nusing this:\n  edge G x y\n  (edge G)\\<^sup>*\\<^sup>* y a\n\ngoal (1 subgoal):\n 1. (edge G)\\<^sup>*\\<^sup>* x a", "by(rule converse_rtranclp_into_rtranclp)"], ["proof (state)\nthis:\n  reachable x\n\ngoal (1 subgoal):\n 1. g (x, y) \\<noteq> 0 \\<Longrightarrow> False", "with \\<open>\\<not> reachable x\\<close>"], ["proof (chain)\npicking this:\n  \\<not> reachable x\n  reachable x", "show False"], ["proof (prove)\nusing this:\n  \\<not> reachable x\n  reachable x\n\ngoal (1 subgoal):\n 1. False", "by contradiction"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>reachable ?y; (?x, ?y) \\<in> \\<^bold>E;\n   \\<not> reachable ?x\\<rbrakk>\n  \\<Longrightarrow> g (?x, ?y) = 0\n\ngoal (1 subgoal):\n 1. hindered \\<Gamma>", "have reachable_V: \"vertex \\<Gamma> x\" if \"reachable x\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. vertex \\<Gamma> x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. vertex \\<Gamma> x", "from that"], ["proof (chain)\npicking this:\n  reachable x", "obtain p where p: \"path G x p a\""], ["proof (prove)\nusing this:\n  reachable x\n\ngoal (1 subgoal):\n 1. (\\<And>p. path G x p a \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding reachable_alt_def"], ["proof (prove)\nusing this:\n  \\<exists>p. path G x p a\n\ngoal (1 subgoal):\n 1. (\\<And>p. path G x p a \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  path G x p a\n\ngoal (1 subgoal):\n 1. vertex \\<Gamma> x", "then"], ["proof (chain)\npicking this:\n  path G x p a", "show ?thesis"], ["proof (prove)\nusing this:\n  path G x p a\n\ngoal (1 subgoal):\n 1. vertex \\<Gamma> x", "using rtrancl_path_nth[OF p, of 0] a(1) A_vertex"], ["proof (prove)\nusing this:\n  path G x p a\n  0 < length p \\<Longrightarrow> edge G ((x # p) ! 0) (p ! 0)\n  a \\<in> A \\<Gamma>\n  A \\<Gamma> \\<subseteq> \\<^bold>V\n\ngoal (1 subgoal):\n 1. vertex \\<Gamma> x", "by(cases \"p = []\")(auto 4 3 simp add: vertex_def elim: rtrancl_path.cases split: if_split_asm)"], ["proof (state)\nthis:\n  vertex \\<Gamma> x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  reachable ?x \\<Longrightarrow> vertex \\<Gamma> ?x\n\ngoal (1 subgoal):\n 1. hindered \\<Gamma>", "have finite_j_IN: \"(\\<integral>\\<^sup>+ y. j (Some y, Some x) \\<partial>count_space (\\<^bold>I\\<^bold>N x)) \\<noteq> \\<top>\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y\\<in>\\<^bold>I\\<^bold>N x.\n       j (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>)) \\<noteq>\n    \\<top>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y\\<in>\\<^bold>I\\<^bold>N x.\n       j (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>)) \\<noteq>\n    \\<top>", "have \"(\\<integral>\\<^sup>+ y. j (Some y, Some x) \\<partial>count_space (\\<^bold>I\\<^bold>N x)) \\<le> d_IN f x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y\\<in>\\<^bold>I\\<^bold>N x.\n       j (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>))\n    \\<le> d_IN f x", "by(auto intro!: nn_integral_mono j_le_f simp add: d_IN_def nn_integral_count_space_indicator incoming_def split: split_indicator)"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y\\<in>\\<^bold>I\\<^bold>N x.\n     j (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>))\n  \\<le> d_IN f x\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y\\<in>\\<^bold>I\\<^bold>N x.\n       j (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>)) \\<noteq>\n    \\<top>", "thus ?thesis"], ["proof (prove)\nusing this:\n  (\\<Sum>\\<^sup>+ y\\<in>\\<^bold>I\\<^bold>N x.\n     j (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>))\n  \\<le> d_IN f x\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y\\<in>\\<^bold>I\\<^bold>N x.\n       j (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>)) \\<noteq>\n    \\<top>", "using currentD_finite_IN[OF f', of x]"], ["proof (prove)\nusing this:\n  (\\<Sum>\\<^sup>+ y\\<in>\\<^bold>I\\<^bold>N x.\n     j (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>))\n  \\<le> d_IN f x\n  d_IN f x \\<noteq> \\<top>\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y\\<in>\\<^bold>I\\<^bold>N x.\n       j (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>)) \\<noteq>\n    \\<top>", "by (auto simp: top_unique)"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y\\<in>\\<^bold>I\\<^bold>N x.\n     j (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>)) \\<noteq>\n  \\<top>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y\\<in>\\<^bold>I\\<^bold>N ?x.\n     j (\\<langle>y\\<rangle>, \\<langle>?x\\<rangle>)) \\<noteq>\n  \\<top>\n\ngoal (1 subgoal):\n 1. hindered \\<Gamma>", "have j_outside: \"j (x, y) = 0\" if \"\\<not> edge \\<Psi> x y\" for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. j (x, y) = 0", "using that flowD_capacity[OF j, of \"(x, y)\"] \\<Psi>.capacity_outside[of \"(x, y)\"]"], ["proof (prove)\nusing this:\n  \\<not> edge \\<Psi> x y\n  j (x, y) \\<le> capacity \\<Psi> (x, y)\n  (x, y) \\<notin> \\<^bold>E\\<^bsub>\\<Psi>\\<^esub> \\<Longrightarrow>\n  capacity \\<Psi> (x, y) = 0\n\ngoal (1 subgoal):\n 1. j (x, y) = 0", "by(auto)"], ["proof (state)\nthis:\n  \\<not> edge \\<Psi> ?x ?y \\<Longrightarrow> j (?x, ?y) = 0\n\ngoal (1 subgoal):\n 1. hindered \\<Gamma>", "define h where \"h = (\\<lambda>(x, y). if reachable x \\<and> reachable y then g (x, y) else 0)\""], ["proof (state)\nthis:\n  h =\n  (\\<lambda>(x, y). if reachable x \\<and> reachable y then g (x, y) else 0)\n\ngoal (1 subgoal):\n 1. hindered \\<Gamma>", "have h_simps [simp]: \"h (x, y) = (if reachable x \\<and> reachable y then g (x, y) else 0)\" for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. h (x, y) = (if reachable x \\<and> reachable y then g (x, y) else 0)", "by(simp add: h_def)"], ["proof (state)\nthis:\n  h (?x, ?y) = (if reachable ?x \\<and> reachable ?y then g (?x, ?y) else 0)\n\ngoal (1 subgoal):\n 1. hindered \\<Gamma>", "have h_le_g: \"h e \\<le> g e\" for e"], ["proof (prove)\ngoal (1 subgoal):\n 1. h e \\<le> g e", "by(cases e) simp"], ["proof (state)\nthis:\n  h ?e \\<le> g ?e\n\ngoal (1 subgoal):\n 1. hindered \\<Gamma>", "have OUT_h: \"d_OUT h x = (if reachable x then d_OUT g x else 0)\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT h x = (if reachable x then d_OUT g x else 0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. d_OUT h x = (if reachable x then d_OUT g x else 0)", "have \"d_OUT h x = (\\<Sum>\\<^sup>+ y\\<in>\\<^bold>O\\<^bold>U\\<^bold>T x. h (x, y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT h x =\n    (\\<Sum>\\<^sup>+ y\\<in>\\<^bold>O\\<^bold>U\\<^bold>T x. h (x, y))", "using h_le_g currentD_outside[OF g]"], ["proof (prove)\nusing this:\n  h ?e \\<le> g ?e\n  \\<not> edge \\<Gamma> ?x ?y \\<Longrightarrow> g (?x, ?y) = 0\n\ngoal (1 subgoal):\n 1. d_OUT h x =\n    (\\<Sum>\\<^sup>+ y\\<in>\\<^bold>O\\<^bold>U\\<^bold>T x. h (x, y))", "by(intro d_OUT_alt_def) auto"], ["proof (state)\nthis:\n  d_OUT h x = (\\<Sum>\\<^sup>+ y\\<in>\\<^bold>O\\<^bold>U\\<^bold>T x. h (x, y))\n\ngoal (1 subgoal):\n 1. d_OUT h x = (if reachable x then d_OUT g x else 0)", "also"], ["proof (state)\nthis:\n  d_OUT h x = (\\<Sum>\\<^sup>+ y\\<in>\\<^bold>O\\<^bold>U\\<^bold>T x. h (x, y))\n\ngoal (1 subgoal):\n 1. d_OUT h x = (if reachable x then d_OUT g x else 0)", "have \"\\<dots> = (\\<Sum>\\<^sup>+ y\\<in>\\<^bold>O\\<^bold>U\\<^bold>T x. if reachable x then g (x, y) else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y\\<in>\\<^bold>O\\<^bold>U\\<^bold>T x. h (x, y)) =\n    (\\<Sum>\\<^sup>+ y\\<in>\\<^bold>O\\<^bold>U\\<^bold>T x.\n       if reachable x then g (x, y) else 0)", "by(auto intro!: nn_integral_cong simp add: outgoing_def dest: reachable_AB)"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y\\<in>\\<^bold>O\\<^bold>U\\<^bold>T x. h (x, y)) =\n  (\\<Sum>\\<^sup>+ y\\<in>\\<^bold>O\\<^bold>U\\<^bold>T x.\n     if reachable x then g (x, y) else 0)\n\ngoal (1 subgoal):\n 1. d_OUT h x = (if reachable x then d_OUT g x else 0)", "also"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y\\<in>\\<^bold>O\\<^bold>U\\<^bold>T x. h (x, y)) =\n  (\\<Sum>\\<^sup>+ y\\<in>\\<^bold>O\\<^bold>U\\<^bold>T x.\n     if reachable x then g (x, y) else 0)\n\ngoal (1 subgoal):\n 1. d_OUT h x = (if reachable x then d_OUT g x else 0)", "have \"\\<dots> = (if reachable x then d_OUT g x else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y\\<in>\\<^bold>O\\<^bold>U\\<^bold>T x.\n       if reachable x then g (x, y) else 0) =\n    (if reachable x then d_OUT g x else 0)", "by(auto intro!: d_OUT_alt_def[symmetric] currentD_outside[OF g])"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y\\<in>\\<^bold>O\\<^bold>U\\<^bold>T x.\n     if reachable x then g (x, y) else 0) =\n  (if reachable x then d_OUT g x else 0)\n\ngoal (1 subgoal):\n 1. d_OUT h x = (if reachable x then d_OUT g x else 0)", "finally"], ["proof (chain)\npicking this:\n  d_OUT h x = (if reachable x then d_OUT g x else 0)", "show ?thesis"], ["proof (prove)\nusing this:\n  d_OUT h x = (if reachable x then d_OUT g x else 0)\n\ngoal (1 subgoal):\n 1. d_OUT h x = (if reachable x then d_OUT g x else 0)", "."], ["proof (state)\nthis:\n  d_OUT h x = (if reachable x then d_OUT g x else 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  d_OUT h ?x = (if reachable ?x then d_OUT g ?x else 0)\n\ngoal (1 subgoal):\n 1. hindered \\<Gamma>", "have IN_h: \"d_IN h x = (if reachable x then d_IN g x else 0)\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN h x = (if reachable x then d_IN g x else 0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. d_IN h x = (if reachable x then d_IN g x else 0)", "have \"d_IN h x = (\\<Sum>\\<^sup>+ y\\<in>\\<^bold>I\\<^bold>N x. h (y, x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN h x = (\\<Sum>\\<^sup>+ y\\<in>\\<^bold>I\\<^bold>N x. h (y, x))", "using h_le_g currentD_outside[OF g]"], ["proof (prove)\nusing this:\n  h ?e \\<le> g ?e\n  \\<not> edge \\<Gamma> ?x ?y \\<Longrightarrow> g (?x, ?y) = 0\n\ngoal (1 subgoal):\n 1. d_IN h x = (\\<Sum>\\<^sup>+ y\\<in>\\<^bold>I\\<^bold>N x. h (y, x))", "by(intro d_IN_alt_def) auto"], ["proof (state)\nthis:\n  d_IN h x = (\\<Sum>\\<^sup>+ y\\<in>\\<^bold>I\\<^bold>N x. h (y, x))\n\ngoal (1 subgoal):\n 1. d_IN h x = (if reachable x then d_IN g x else 0)", "also"], ["proof (state)\nthis:\n  d_IN h x = (\\<Sum>\\<^sup>+ y\\<in>\\<^bold>I\\<^bold>N x. h (y, x))\n\ngoal (1 subgoal):\n 1. d_IN h x = (if reachable x then d_IN g x else 0)", "have \"\\<dots> = (\\<Sum>\\<^sup>+ y\\<in>\\<^bold>I\\<^bold>N x. if reachable x then g (y, x) else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y\\<in>\\<^bold>I\\<^bold>N x. h (y, x)) =\n    (\\<Sum>\\<^sup>+ y\\<in>\\<^bold>I\\<^bold>N x.\n       if reachable x then g (y, x) else 0)", "by(auto intro!: nn_integral_cong simp add: incoming_def dest: reachable_BA)"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y\\<in>\\<^bold>I\\<^bold>N x. h (y, x)) =\n  (\\<Sum>\\<^sup>+ y\\<in>\\<^bold>I\\<^bold>N x.\n     if reachable x then g (y, x) else 0)\n\ngoal (1 subgoal):\n 1. d_IN h x = (if reachable x then d_IN g x else 0)", "also"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y\\<in>\\<^bold>I\\<^bold>N x. h (y, x)) =\n  (\\<Sum>\\<^sup>+ y\\<in>\\<^bold>I\\<^bold>N x.\n     if reachable x then g (y, x) else 0)\n\ngoal (1 subgoal):\n 1. d_IN h x = (if reachable x then d_IN g x else 0)", "have \"\\<dots> = (if reachable x then d_IN g x else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y\\<in>\\<^bold>I\\<^bold>N x.\n       if reachable x then g (y, x) else 0) =\n    (if reachable x then d_IN g x else 0)", "by(auto intro!: d_IN_alt_def[symmetric] currentD_outside[OF g])"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y\\<in>\\<^bold>I\\<^bold>N x.\n     if reachable x then g (y, x) else 0) =\n  (if reachable x then d_IN g x else 0)\n\ngoal (1 subgoal):\n 1. d_IN h x = (if reachable x then d_IN g x else 0)", "finally"], ["proof (chain)\npicking this:\n  d_IN h x = (if reachable x then d_IN g x else 0)", "show ?thesis"], ["proof (prove)\nusing this:\n  d_IN h x = (if reachable x then d_IN g x else 0)\n\ngoal (1 subgoal):\n 1. d_IN h x = (if reachable x then d_IN g x else 0)", "."], ["proof (state)\nthis:\n  d_IN h x = (if reachable x then d_IN g x else 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  d_IN h ?x = (if reachable ?x then d_IN g ?x else 0)\n\ngoal (1 subgoal):\n 1. hindered \\<Gamma>", "have h: \"current \\<Gamma> h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. current \\<Gamma> h", "using g h_le_g"], ["proof (prove)\nusing this:\n  current \\<Gamma> g\n  h ?e \\<le> g ?e\n\ngoal (1 subgoal):\n 1. current \\<Gamma> h", "proof(rule current_leI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<notin> A \\<Gamma> \\<Longrightarrow> d_OUT h x \\<le> d_IN h x", "show \"d_OUT h x \\<le> d_IN h x\" if \"x \\<notin> A \\<Gamma>\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT h x \\<le> d_IN h x", "by(simp add: OUT_h IN_h currentD_OUT_IN[OF g that])"], ["proof (state)\nthis:\n  ?x \\<notin> A \\<Gamma> \\<Longrightarrow> d_OUT h ?x \\<le> d_IN h ?x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  current \\<Gamma> h\n\ngoal (1 subgoal):\n 1. hindered \\<Gamma>", "have reachable_full: \"j (None, \\<langle>y\\<rangle>) = u y\" if reach: \"reachable y\" for y"], ["proof (prove)\ngoal (1 subgoal):\n 1. j (None, \\<langle>y\\<rangle>) = u y", "proof(rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. j (None, \\<langle>y\\<rangle>) \\<noteq> u y \\<Longrightarrow> False", "assume \"j (None, \\<langle>y\\<rangle>) \\<noteq> u y\""], ["proof (state)\nthis:\n  j (None, \\<langle>y\\<rangle>) \\<noteq> u y\n\ngoal (1 subgoal):\n 1. j (None, \\<langle>y\\<rangle>) \\<noteq> u y \\<Longrightarrow> False", "with flowD_capacity[OF j, of \"(None, \\<langle>y\\<rangle>)\"]"], ["proof (chain)\npicking this:\n  j (None, \\<langle>y\\<rangle>)\n  \\<le> capacity \\<Psi> (None, \\<langle>y\\<rangle>)\n  j (None, \\<langle>y\\<rangle>) \\<noteq> u y", "have le: \"j (None, \\<langle>y\\<rangle>) < u y\""], ["proof (prove)\nusing this:\n  j (None, \\<langle>y\\<rangle>)\n  \\<le> capacity \\<Psi> (None, \\<langle>y\\<rangle>)\n  j (None, \\<langle>y\\<rangle>) \\<noteq> u y\n\ngoal (1 subgoal):\n 1. j (None, \\<langle>y\\<rangle>) < u y", "by(auto split: if_split_asm simp add: u_outside \\<Psi>.flowD_outside[OF j] zero_less_iff_neq_zero)"], ["proof (state)\nthis:\n  j (None, \\<langle>y\\<rangle>) < u y\n\ngoal (1 subgoal):\n 1. j (None, \\<langle>y\\<rangle>) \\<noteq> u y \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  j (None, \\<langle>y\\<rangle>) < u y", "obtain y: \"y \\<in> B \\<Gamma>\" and uy: \"u y > 0\""], ["proof (prove)\nusing this:\n  j (None, \\<langle>y\\<rangle>) < u y\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>y \\<in> B \\<Gamma>; 0 < u y\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using u_outside[of y]"], ["proof (prove)\nusing this:\n  j (None, \\<langle>y\\<rangle>) < u y\n  y \\<notin> B \\<Gamma> \\<Longrightarrow> u y = 0\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>y \\<in> B \\<Gamma>; 0 < u y\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases \"y \\<in> B \\<Gamma>\"; cases \"u y = 0\") (auto simp add: zero_less_iff_neq_zero)"], ["proof (state)\nthis:\n  y \\<in> B \\<Gamma>\n  0 < u y\n\ngoal (1 subgoal):\n 1. j (None, \\<langle>y\\<rangle>) \\<noteq> u y \\<Longrightarrow> False", "from reach"], ["proof (chain)\npicking this:\n  reachable y", "obtain q where q: \"path G y q a\" and distinct: \"distinct (y # q)\""], ["proof (prove)\nusing this:\n  reachable y\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        \\<lbrakk>path G y q a; distinct (y # q)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding reachable_alt_def"], ["proof (prove)\nusing this:\n  \\<exists>p. path G y p a\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        \\<lbrakk>path G y q a; distinct (y # q)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto elim: rtrancl_path_distinct)"], ["proof (state)\nthis:\n  path G y q a\n  distinct (y # q)\n\ngoal (1 subgoal):\n 1. j (None, \\<langle>y\\<rangle>) \\<noteq> u y \\<Longrightarrow> False", "have q_Nil: \"q \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q \\<noteq> []", "using q a(1) disjoint y"], ["proof (prove)\nusing this:\n  path G y q a\n  a \\<in> A \\<Gamma>\n  A \\<Gamma> \\<inter> B \\<Gamma> = {}\n  y \\<in> B \\<Gamma>\n\ngoal (1 subgoal):\n 1. q \\<noteq> []", "by(auto elim!: rtrancl_path.cases)"], ["proof (state)\nthis:\n  q \\<noteq> []\n\ngoal (1 subgoal):\n 1. j (None, \\<langle>y\\<rangle>) \\<noteq> u y \\<Longrightarrow> False", "let ?E = \"zip (y # q) q\""], ["proof (state)\ngoal (1 subgoal):\n 1. j (None, \\<langle>y\\<rangle>) \\<noteq> u y \\<Longrightarrow> False", "define E where \"E = (None, Some y) # map (map_prod Some Some) ?E\""], ["proof (state)\nthis:\n  E = (None, \\<langle>y\\<rangle>) # map (map_prod Some Some) (zip (y # q) q)\n\ngoal (1 subgoal):\n 1. j (None, \\<langle>y\\<rangle>) \\<noteq> u y \\<Longrightarrow> False", "define \\<zeta> where \"\\<zeta> = Min (insert (u y - j (None, Some y)) (cap' ` set ?E))\""], ["proof (state)\nthis:\n  \\<zeta> =\n  Min (insert (u y - j (None, \\<langle>y\\<rangle>))\n        (cap' ` set (zip (y # q) q)))\n\ngoal (1 subgoal):\n 1. j (None, \\<langle>y\\<rangle>) \\<noteq> u y \\<Longrightarrow> False", "let ?j' = \"\\<lambda>e. (if e \\<in> set E then \\<zeta> else 0) + j e\""], ["proof (state)\ngoal (1 subgoal):\n 1. j (None, \\<langle>y\\<rangle>) \\<noteq> u y \\<Longrightarrow> False", "define j' where \"j' = cleanup ?j'\""], ["proof (state)\nthis:\n  j' = cleanup (\\<lambda>e. (if e \\<in> set E then \\<zeta> else 0) + j e)\n\ngoal (1 subgoal):\n 1. j (None, \\<langle>y\\<rangle>) \\<noteq> u y \\<Longrightarrow> False", "have j_free: \"0 < cap' e\" if \"e \\<in> set ?E\" for e"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < cap' e", "using that"], ["proof (prove)\nusing this:\n  e \\<in> set (zip (y # q) q)\n\ngoal (1 subgoal):\n 1. 0 < cap' e", "unfolding E_def list.sel"], ["proof (prove)\nusing this:\n  e \\<in> set (zip (y # q) q)\n\ngoal (1 subgoal):\n 1. 0 < cap' e", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. e \\<in> set (zip (y # q) q) \\<Longrightarrow> 0 < cap' e", "from that"], ["proof (chain)\npicking this:\n  e \\<in> set (zip (y # q) q)", "obtain i where e: \"e = ((y # q) ! i, q ! i)\"\n        and i: \"i < length q\""], ["proof (prove)\nusing this:\n  e \\<in> set (zip (y # q) q)\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>e = ((y # q) ! i, q ! i); i < length q\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto simp add: set_zip)"], ["proof (state)\nthis:\n  e = ((y # q) ! i, q ! i)\n  i < length q\n\ngoal (1 subgoal):\n 1. e \\<in> set (zip (y # q) q) \\<Longrightarrow> 0 < cap' e", "have e': \"edge G ((y # q) ! i) (q ! i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. edge G ((y # q) ! i) (q ! i)", "using q i"], ["proof (prove)\nusing this:\n  path G y q a\n  i < length q\n\ngoal (1 subgoal):\n 1. edge G ((y # q) ! i) (q ! i)", "by(rule rtrancl_path_nth)"], ["proof (state)\nthis:\n  edge G ((y # q) ! i) (q ! i)\n\ngoal (1 subgoal):\n 1. e \\<in> set (zip (y # q) q) \\<Longrightarrow> 0 < cap' e", "thus ?thesis"], ["proof (prove)\nusing this:\n  edge G ((y # q) ! i) (q ! i)\n\ngoal (1 subgoal):\n 1. 0 < cap' e", "using e"], ["proof (prove)\nusing this:\n  edge G ((y # q) ! i) (q ! i)\n  e = ((y # q) ! i, q ! i)\n\ngoal (1 subgoal):\n 1. 0 < cap' e", "by(simp)"], ["proof (state)\nthis:\n  0 < cap' e\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?e \\<in> set (zip (y # q) q) \\<Longrightarrow> 0 < cap' ?e\n\ngoal (1 subgoal):\n 1. j (None, \\<langle>y\\<rangle>) \\<noteq> u y \\<Longrightarrow> False", "have \\<zeta>_pos: \"0 < \\<zeta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < \\<zeta>", "unfolding \\<zeta>_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < Min (insert (u y - j (None, \\<langle>y\\<rangle>))\n              (cap' ` set (zip (y # q) q)))", "using le"], ["proof (prove)\nusing this:\n  j (None, \\<langle>y\\<rangle>) < u y\n\ngoal (1 subgoal):\n 1. 0 < Min (insert (u y - j (None, \\<langle>y\\<rangle>))\n              (cap' ` set (zip (y # q) q)))", "by(auto intro: j_free diff_gr0_ennreal)"], ["proof (state)\nthis:\n  0 < \\<zeta>\n\ngoal (1 subgoal):\n 1. j (None, \\<langle>y\\<rangle>) \\<noteq> u y \\<Longrightarrow> False", "have \\<zeta>_le: \"\\<zeta> \\<le> cap' e\" if \"e \\<in> set ?E\" for e"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<zeta> \\<le> cap' e", "using that"], ["proof (prove)\nusing this:\n  e \\<in> set (zip (y # q) q)\n\ngoal (1 subgoal):\n 1. \\<zeta> \\<le> cap' e", "unfolding \\<zeta>_def"], ["proof (prove)\nusing this:\n  e \\<in> set (zip (y # q) q)\n\ngoal (1 subgoal):\n 1. Min (insert (u y - j (None, \\<langle>y\\<rangle>))\n          (cap' ` set (zip (y # q) q)))\n    \\<le> cap' e", "by auto"], ["proof (state)\nthis:\n  ?e \\<in> set (zip (y # q) q) \\<Longrightarrow> \\<zeta> \\<le> cap' ?e\n\ngoal (1 subgoal):\n 1. j (None, \\<langle>y\\<rangle>) \\<noteq> u y \\<Longrightarrow> False", "have finite_\\<zeta> [simplified]: \"\\<zeta> < \\<top>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<zeta> < \\<top>", "unfolding \\<zeta>_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Min (insert (u y - j (None, \\<langle>y\\<rangle>))\n          (cap' ` set (zip (y # q) q)))\n    < \\<top>", "by(intro Min_less_iff[THEN iffD2])(auto simp add: less_top[symmetric])"], ["proof (state)\nthis:\n  \\<zeta> < \\<top>\n\ngoal (1 subgoal):\n 1. j (None, \\<langle>y\\<rangle>) \\<noteq> u y \\<Longrightarrow> False", "have E_antiparallel: \"(x', y') \\<in> set ?E \\<Longrightarrow> (y', x') \\<notin> set ?E\" for x' y'"], ["proof (prove)\ngoal (1 subgoal):\n 1. (x', y') \\<in> set (zip (y # q) q) \\<Longrightarrow>\n    (y', x') \\<notin> set (zip (y # q) q)", "using distinct"], ["proof (prove)\nusing this:\n  distinct (y # q)\n\ngoal (1 subgoal):\n 1. (x', y') \\<in> set (zip (y # q) q) \\<Longrightarrow>\n    (y', x') \\<notin> set (zip (y # q) q)", "apply(auto simp add: in_set_zip nth_Cons in_set_conv_nth)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i ia.\n       \\<lbrakk>\\<forall>i<length q. q ! i \\<noteq> y; distinct q;\n        i < length q; ia < length q;\n        y' = (case ia of 0 \\<Rightarrow> y | Suc x \\<Rightarrow> q ! x);\n        x' = q ! ia;\n        (case i of 0 \\<Rightarrow> y | Suc x \\<Rightarrow> q ! x) = q ! ia;\n        q ! i =\n        (case ia of 0 \\<Rightarrow> y | Suc x \\<Rightarrow> q ! x)\\<rbrakk>\n       \\<Longrightarrow> False", "apply(auto simp add: distinct_conv_nth split: nat.split_asm)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x2 x2a.\n       \\<lbrakk>q ! Suc x2a = q ! x2; \\<forall>i<length q. q ! i \\<noteq> y;\n        \\<forall>i<length q.\n           \\<forall>j<length q.\n              i \\<noteq> j \\<longrightarrow> q ! i \\<noteq> q ! j;\n        Suc x2a < length q; Suc x2 < length q; y' = q ! x2; x' = q ! Suc x2;\n        q ! x2a = q ! Suc x2\\<rbrakk>\n       \\<Longrightarrow> False", "by (metis Suc_lessD less_Suc_eq less_irrefl_nat)"], ["proof (state)\nthis:\n  (?x', ?y') \\<in> set (zip (y # q) q) \\<Longrightarrow>\n  (?y', ?x') \\<notin> set (zip (y # q) q)\n\ngoal (1 subgoal):\n 1. j (None, \\<langle>y\\<rangle>) \\<noteq> u y \\<Longrightarrow> False", "have OUT_j': \"d_OUT ?j' x' = \\<zeta> * card (set [(x'', y) \\<leftarrow> E. x'' = x']) + d_OUT j x'\" for x'"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT (\\<lambda>e. (if e \\<in> set E then \\<zeta> else 0) + j e) x' =\n    \\<zeta> * of_nat (card (set (filter (\\<lambda>(x'', y). x'' = x') E))) +\n    d_OUT j x'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. d_OUT (\\<lambda>e. (if e \\<in> set E then \\<zeta> else 0) + j e) x' =\n    \\<zeta> * of_nat (card (set (filter (\\<lambda>(x'', y). x'' = x') E))) +\n    d_OUT j x'", "have \"d_OUT ?j' x' = d_OUT (\\<lambda>e. if e \\<in> set E then \\<zeta> else 0) x' + d_OUT j x'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT (\\<lambda>e. (if e \\<in> set E then \\<zeta> else 0) + j e) x' =\n    d_OUT (\\<lambda>e. if e \\<in> set E then \\<zeta> else 0) x' + d_OUT j x'", "using \\<zeta>_pos"], ["proof (prove)\nusing this:\n  0 < \\<zeta>\n\ngoal (1 subgoal):\n 1. d_OUT (\\<lambda>e. (if e \\<in> set E then \\<zeta> else 0) + j e) x' =\n    d_OUT (\\<lambda>e. if e \\<in> set E then \\<zeta> else 0) x' + d_OUT j x'", "by(intro d_OUT_add)"], ["proof (state)\nthis:\n  d_OUT (\\<lambda>e. (if e \\<in> set E then \\<zeta> else 0) + j e) x' =\n  d_OUT (\\<lambda>e. if e \\<in> set E then \\<zeta> else 0) x' + d_OUT j x'\n\ngoal (1 subgoal):\n 1. d_OUT (\\<lambda>e. (if e \\<in> set E then \\<zeta> else 0) + j e) x' =\n    \\<zeta> * of_nat (card (set (filter (\\<lambda>(x'', y). x'' = x') E))) +\n    d_OUT j x'", "also"], ["proof (state)\nthis:\n  d_OUT (\\<lambda>e. (if e \\<in> set E then \\<zeta> else 0) + j e) x' =\n  d_OUT (\\<lambda>e. if e \\<in> set E then \\<zeta> else 0) x' + d_OUT j x'\n\ngoal (1 subgoal):\n 1. d_OUT (\\<lambda>e. (if e \\<in> set E then \\<zeta> else 0) + j e) x' =\n    \\<zeta> * of_nat (card (set (filter (\\<lambda>(x'', y). x'' = x') E))) +\n    d_OUT j x'", "have \"d_OUT (\\<lambda>e. if e \\<in> set E then \\<zeta> else 0) x' = \\<integral>\\<^sup>+ y. \\<zeta> * indicator (set E) (x', y) \\<partial>count_space UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT (\\<lambda>e. if e \\<in> set E then \\<zeta> else 0) x' =\n    (\\<Sum>\\<^sup>+ y. \\<zeta> * indicator (set E) (x', y))", "unfolding d_OUT_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y. if (x', y) \\<in> set E then \\<zeta> else 0) =\n    (\\<Sum>\\<^sup>+ y. \\<zeta> * indicator (set E) (x', y))", "by(rule nn_integral_cong)(simp)"], ["proof (state)\nthis:\n  d_OUT (\\<lambda>e. if e \\<in> set E then \\<zeta> else 0) x' =\n  (\\<Sum>\\<^sup>+ y. \\<zeta> * indicator (set E) (x', y))\n\ngoal (1 subgoal):\n 1. d_OUT (\\<lambda>e. (if e \\<in> set E then \\<zeta> else 0) + j e) x' =\n    \\<zeta> * of_nat (card (set (filter (\\<lambda>(x'', y). x'' = x') E))) +\n    d_OUT j x'", "also"], ["proof (state)\nthis:\n  d_OUT (\\<lambda>e. if e \\<in> set E then \\<zeta> else 0) x' =\n  (\\<Sum>\\<^sup>+ y. \\<zeta> * indicator (set E) (x', y))\n\ngoal (1 subgoal):\n 1. d_OUT (\\<lambda>e. (if e \\<in> set E then \\<zeta> else 0) + j e) x' =\n    \\<zeta> * of_nat (card (set (filter (\\<lambda>(x'', y). x'' = x') E))) +\n    d_OUT j x'", "have \"\\<dots> = (\\<integral>\\<^sup>+ e. \\<zeta> * indicator (set E) e \\<partial>embed_measure (count_space UNIV) (Pair x'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y. \\<zeta> * indicator (set E) (x', y)) =\n    \\<integral>\\<^sup>+e\\<in>set E. \\<zeta>\n    \\<partial>embed_measure (count_space UNIV) (Pair x')", "by(simp add: measurable_embed_measure1 nn_integral_embed_measure)"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y. \\<zeta> * indicator (set E) (x', y)) =\n  \\<integral>\\<^sup>+e\\<in>set E. \\<zeta>\n  \\<partial>embed_measure (count_space UNIV) (Pair x')\n\ngoal (1 subgoal):\n 1. d_OUT (\\<lambda>e. (if e \\<in> set E then \\<zeta> else 0) + j e) x' =\n    \\<zeta> * of_nat (card (set (filter (\\<lambda>(x'', y). x'' = x') E))) +\n    d_OUT j x'", "also"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y. \\<zeta> * indicator (set E) (x', y)) =\n  \\<integral>\\<^sup>+e\\<in>set E. \\<zeta>\n  \\<partial>embed_measure (count_space UNIV) (Pair x')\n\ngoal (1 subgoal):\n 1. d_OUT (\\<lambda>e. (if e \\<in> set E then \\<zeta> else 0) + j e) x' =\n    \\<zeta> * of_nat (card (set (filter (\\<lambda>(x'', y). x'' = x') E))) +\n    d_OUT j x'", "have \"\\<dots> = (\\<integral>\\<^sup>+ e. \\<zeta> * indicator (set [(x'', y) \\<leftarrow> E. x'' = x']) e \\<partial>count_space UNIV)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+e\\<in>set E. \\<zeta>\n    \\<partial>embed_measure (count_space UNIV) (Pair x') =\n    \\<integral>\\<^sup>+e\\<in>set (filter (\\<lambda>(x'', y). x'' = x') E).\n                       \\<zeta>\n    \\<partial>count_space UNIV", "by(auto simp add: embed_measure_count_space' nn_integral_count_space_indicator intro!: nn_integral_cong split: split_indicator)"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+e\\<in>set E. \\<zeta>\n  \\<partial>embed_measure (count_space UNIV) (Pair x') =\n  \\<integral>\\<^sup>+e\\<in>set (filter (\\<lambda>(x'', y). x'' = x') E).\n                     \\<zeta>\n  \\<partial>count_space UNIV\n\ngoal (1 subgoal):\n 1. d_OUT (\\<lambda>e. (if e \\<in> set E then \\<zeta> else 0) + j e) x' =\n    \\<zeta> * of_nat (card (set (filter (\\<lambda>(x'', y). x'' = x') E))) +\n    d_OUT j x'", "also"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+e\\<in>set E. \\<zeta>\n  \\<partial>embed_measure (count_space UNIV) (Pair x') =\n  \\<integral>\\<^sup>+e\\<in>set (filter (\\<lambda>(x'', y). x'' = x') E).\n                     \\<zeta>\n  \\<partial>count_space UNIV\n\ngoal (1 subgoal):\n 1. d_OUT (\\<lambda>e. (if e \\<in> set E then \\<zeta> else 0) + j e) x' =\n    \\<zeta> * of_nat (card (set (filter (\\<lambda>(x'', y). x'' = x') E))) +\n    d_OUT j x'", "have \"\\<dots> = \\<zeta> * card (set [(x'', y) \\<leftarrow> E. x'' = x'])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+e\\<in>set (filter (\\<lambda>(x'', y). x'' = x') E).\n                       \\<zeta>\n    \\<partial>count_space UNIV =\n    \\<zeta> * of_nat (card (set (filter (\\<lambda>(x'', y). x'' = x') E)))", "using \\<zeta>_pos"], ["proof (prove)\nusing this:\n  0 < \\<zeta>\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+e\\<in>set (filter (\\<lambda>(x'', y). x'' = x') E).\n                       \\<zeta>\n    \\<partial>count_space UNIV =\n    \\<zeta> * of_nat (card (set (filter (\\<lambda>(x'', y). x'' = x') E)))", "by(simp add: nn_integral_cmult)"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+e\\<in>set (filter (\\<lambda>(x'', y). x'' = x') E).\n                     \\<zeta>\n  \\<partial>count_space UNIV =\n  \\<zeta> * of_nat (card (set (filter (\\<lambda>(x'', y). x'' = x') E)))\n\ngoal (1 subgoal):\n 1. d_OUT (\\<lambda>e. (if e \\<in> set E then \\<zeta> else 0) + j e) x' =\n    \\<zeta> * of_nat (card (set (filter (\\<lambda>(x'', y). x'' = x') E))) +\n    d_OUT j x'", "finally"], ["proof (chain)\npicking this:\n  d_OUT (\\<lambda>e. (if e \\<in> set E then \\<zeta> else 0) + j e) x' =\n  \\<zeta> * of_nat (card (set (filter (\\<lambda>(x'', y). x'' = x') E))) +\n  d_OUT j x'", "show ?thesis"], ["proof (prove)\nusing this:\n  d_OUT (\\<lambda>e. (if e \\<in> set E then \\<zeta> else 0) + j e) x' =\n  \\<zeta> * of_nat (card (set (filter (\\<lambda>(x'', y). x'' = x') E))) +\n  d_OUT j x'\n\ngoal (1 subgoal):\n 1. d_OUT (\\<lambda>e. (if e \\<in> set E then \\<zeta> else 0) + j e) x' =\n    \\<zeta> * of_nat (card (set (filter (\\<lambda>(x'', y). x'' = x') E))) +\n    d_OUT j x'", "."], ["proof (state)\nthis:\n  d_OUT (\\<lambda>e. (if e \\<in> set E then \\<zeta> else 0) + j e) x' =\n  \\<zeta> * of_nat (card (set (filter (\\<lambda>(x'', y). x'' = x') E))) +\n  d_OUT j x'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  d_OUT (\\<lambda>e. (if e \\<in> set E then \\<zeta> else 0) + j e) ?x' =\n  \\<zeta> * of_nat (card (set (filter (\\<lambda>(x'', y). x'' = ?x') E))) +\n  d_OUT j ?x'\n\ngoal (1 subgoal):\n 1. j (None, \\<langle>y\\<rangle>) \\<noteq> u y \\<Longrightarrow> False", "have IN_j': \"d_IN ?j' x' = \\<zeta> * card (set [(y, x'') \\<leftarrow> E. x'' = x']) + d_IN j x'\" for x'"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN (\\<lambda>e. (if e \\<in> set E then \\<zeta> else 0) + j e) x' =\n    \\<zeta> * of_nat (card (set (filter (\\<lambda>(y, x''). x'' = x') E))) +\n    d_IN j x'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. d_IN (\\<lambda>e. (if e \\<in> set E then \\<zeta> else 0) + j e) x' =\n    \\<zeta> * of_nat (card (set (filter (\\<lambda>(y, x''). x'' = x') E))) +\n    d_IN j x'", "have \"d_IN ?j' x' = d_IN (\\<lambda>e. if e \\<in> set E then \\<zeta> else 0) x' + d_IN j x'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN (\\<lambda>e. (if e \\<in> set E then \\<zeta> else 0) + j e) x' =\n    d_IN (\\<lambda>e. if e \\<in> set E then \\<zeta> else 0) x' + d_IN j x'", "using \\<zeta>_pos"], ["proof (prove)\nusing this:\n  0 < \\<zeta>\n\ngoal (1 subgoal):\n 1. d_IN (\\<lambda>e. (if e \\<in> set E then \\<zeta> else 0) + j e) x' =\n    d_IN (\\<lambda>e. if e \\<in> set E then \\<zeta> else 0) x' + d_IN j x'", "by(intro d_IN_add)"], ["proof (state)\nthis:\n  d_IN (\\<lambda>e. (if e \\<in> set E then \\<zeta> else 0) + j e) x' =\n  d_IN (\\<lambda>e. if e \\<in> set E then \\<zeta> else 0) x' + d_IN j x'\n\ngoal (1 subgoal):\n 1. d_IN (\\<lambda>e. (if e \\<in> set E then \\<zeta> else 0) + j e) x' =\n    \\<zeta> * of_nat (card (set (filter (\\<lambda>(y, x''). x'' = x') E))) +\n    d_IN j x'", "also"], ["proof (state)\nthis:\n  d_IN (\\<lambda>e. (if e \\<in> set E then \\<zeta> else 0) + j e) x' =\n  d_IN (\\<lambda>e. if e \\<in> set E then \\<zeta> else 0) x' + d_IN j x'\n\ngoal (1 subgoal):\n 1. d_IN (\\<lambda>e. (if e \\<in> set E then \\<zeta> else 0) + j e) x' =\n    \\<zeta> * of_nat (card (set (filter (\\<lambda>(y, x''). x'' = x') E))) +\n    d_IN j x'", "have \"d_IN (\\<lambda>e. if e \\<in> set E then \\<zeta> else 0) x' = \\<integral>\\<^sup>+ y. \\<zeta> * indicator (set E) (y, x') \\<partial>count_space UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN (\\<lambda>e. if e \\<in> set E then \\<zeta> else 0) x' =\n    (\\<Sum>\\<^sup>+ y. \\<zeta> * indicator (set E) (y, x'))", "unfolding d_IN_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ x. if (x, x') \\<in> set E then \\<zeta> else 0) =\n    (\\<Sum>\\<^sup>+ y. \\<zeta> * indicator (set E) (y, x'))", "by(rule nn_integral_cong)(simp)"], ["proof (state)\nthis:\n  d_IN (\\<lambda>e. if e \\<in> set E then \\<zeta> else 0) x' =\n  (\\<Sum>\\<^sup>+ y. \\<zeta> * indicator (set E) (y, x'))\n\ngoal (1 subgoal):\n 1. d_IN (\\<lambda>e. (if e \\<in> set E then \\<zeta> else 0) + j e) x' =\n    \\<zeta> * of_nat (card (set (filter (\\<lambda>(y, x''). x'' = x') E))) +\n    d_IN j x'", "also"], ["proof (state)\nthis:\n  d_IN (\\<lambda>e. if e \\<in> set E then \\<zeta> else 0) x' =\n  (\\<Sum>\\<^sup>+ y. \\<zeta> * indicator (set E) (y, x'))\n\ngoal (1 subgoal):\n 1. d_IN (\\<lambda>e. (if e \\<in> set E then \\<zeta> else 0) + j e) x' =\n    \\<zeta> * of_nat (card (set (filter (\\<lambda>(y, x''). x'' = x') E))) +\n    d_IN j x'", "have \"\\<dots> = (\\<integral>\\<^sup>+ e. \\<zeta> * indicator (set E) e \\<partial>embed_measure (count_space UNIV) (\\<lambda>y. (y, x')))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y. \\<zeta> * indicator (set E) (y, x')) =\n    \\<integral>\\<^sup>+e\\<in>set E. \\<zeta>\n    \\<partial>embed_measure (count_space UNIV) (\\<lambda>y. (y, x'))", "by(simp add: measurable_embed_measure1 nn_integral_embed_measure)"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y. \\<zeta> * indicator (set E) (y, x')) =\n  \\<integral>\\<^sup>+e\\<in>set E. \\<zeta>\n  \\<partial>embed_measure (count_space UNIV) (\\<lambda>y. (y, x'))\n\ngoal (1 subgoal):\n 1. d_IN (\\<lambda>e. (if e \\<in> set E then \\<zeta> else 0) + j e) x' =\n    \\<zeta> * of_nat (card (set (filter (\\<lambda>(y, x''). x'' = x') E))) +\n    d_IN j x'", "also"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y. \\<zeta> * indicator (set E) (y, x')) =\n  \\<integral>\\<^sup>+e\\<in>set E. \\<zeta>\n  \\<partial>embed_measure (count_space UNIV) (\\<lambda>y. (y, x'))\n\ngoal (1 subgoal):\n 1. d_IN (\\<lambda>e. (if e \\<in> set E then \\<zeta> else 0) + j e) x' =\n    \\<zeta> * of_nat (card (set (filter (\\<lambda>(y, x''). x'' = x') E))) +\n    d_IN j x'", "have \"\\<dots> = (\\<integral>\\<^sup>+ e. \\<zeta> * indicator (set [(y, x'') \\<leftarrow> E. x'' = x']) e \\<partial>count_space UNIV)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+e\\<in>set E. \\<zeta>\n    \\<partial>embed_measure (count_space UNIV) (\\<lambda>y. (y, x')) =\n    \\<integral>\\<^sup>+e\\<in>set (filter (\\<lambda>(y, x''). x'' = x') E).\n                       \\<zeta>\n    \\<partial>count_space UNIV", "by(auto simp add: embed_measure_count_space' nn_integral_count_space_indicator intro!: nn_integral_cong split: split_indicator)"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+e\\<in>set E. \\<zeta>\n  \\<partial>embed_measure (count_space UNIV) (\\<lambda>y. (y, x')) =\n  \\<integral>\\<^sup>+e\\<in>set (filter (\\<lambda>(y, x''). x'' = x') E).\n                     \\<zeta>\n  \\<partial>count_space UNIV\n\ngoal (1 subgoal):\n 1. d_IN (\\<lambda>e. (if e \\<in> set E then \\<zeta> else 0) + j e) x' =\n    \\<zeta> * of_nat (card (set (filter (\\<lambda>(y, x''). x'' = x') E))) +\n    d_IN j x'", "also"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+e\\<in>set E. \\<zeta>\n  \\<partial>embed_measure (count_space UNIV) (\\<lambda>y. (y, x')) =\n  \\<integral>\\<^sup>+e\\<in>set (filter (\\<lambda>(y, x''). x'' = x') E).\n                     \\<zeta>\n  \\<partial>count_space UNIV\n\ngoal (1 subgoal):\n 1. d_IN (\\<lambda>e. (if e \\<in> set E then \\<zeta> else 0) + j e) x' =\n    \\<zeta> * of_nat (card (set (filter (\\<lambda>(y, x''). x'' = x') E))) +\n    d_IN j x'", "have \"\\<dots> = \\<zeta> * card (set [(y, x'') \\<leftarrow> E. x'' = x'])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+e\\<in>set (filter (\\<lambda>(y, x''). x'' = x') E).\n                       \\<zeta>\n    \\<partial>count_space UNIV =\n    \\<zeta> * of_nat (card (set (filter (\\<lambda>(y, x''). x'' = x') E)))", "using \\<zeta>_pos"], ["proof (prove)\nusing this:\n  0 < \\<zeta>\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+e\\<in>set (filter (\\<lambda>(y, x''). x'' = x') E).\n                       \\<zeta>\n    \\<partial>count_space UNIV =\n    \\<zeta> * of_nat (card (set (filter (\\<lambda>(y, x''). x'' = x') E)))", "by(auto simp add: nn_integral_cmult)"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+e\\<in>set (filter (\\<lambda>(y, x''). x'' = x') E).\n                     \\<zeta>\n  \\<partial>count_space UNIV =\n  \\<zeta> * of_nat (card (set (filter (\\<lambda>(y, x''). x'' = x') E)))\n\ngoal (1 subgoal):\n 1. d_IN (\\<lambda>e. (if e \\<in> set E then \\<zeta> else 0) + j e) x' =\n    \\<zeta> * of_nat (card (set (filter (\\<lambda>(y, x''). x'' = x') E))) +\n    d_IN j x'", "finally"], ["proof (chain)\npicking this:\n  d_IN (\\<lambda>e. (if e \\<in> set E then \\<zeta> else 0) + j e) x' =\n  \\<zeta> * of_nat (card (set (filter (\\<lambda>(y, x''). x'' = x') E))) +\n  d_IN j x'", "show ?thesis"], ["proof (prove)\nusing this:\n  d_IN (\\<lambda>e. (if e \\<in> set E then \\<zeta> else 0) + j e) x' =\n  \\<zeta> * of_nat (card (set (filter (\\<lambda>(y, x''). x'' = x') E))) +\n  d_IN j x'\n\ngoal (1 subgoal):\n 1. d_IN (\\<lambda>e. (if e \\<in> set E then \\<zeta> else 0) + j e) x' =\n    \\<zeta> * of_nat (card (set (filter (\\<lambda>(y, x''). x'' = x') E))) +\n    d_IN j x'", "."], ["proof (state)\nthis:\n  d_IN (\\<lambda>e. (if e \\<in> set E then \\<zeta> else 0) + j e) x' =\n  \\<zeta> * of_nat (card (set (filter (\\<lambda>(y, x''). x'' = x') E))) +\n  d_IN j x'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  d_IN (\\<lambda>e. (if e \\<in> set E then \\<zeta> else 0) + j e) ?x' =\n  \\<zeta> * of_nat (card (set (filter (\\<lambda>(y, x''). x'' = ?x') E))) +\n  d_IN j ?x'\n\ngoal (1 subgoal):\n 1. j (None, \\<langle>y\\<rangle>) \\<noteq> u y \\<Longrightarrow> False", "have j': \"flow \\<Psi> j'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. flow \\<Psi> j'", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>e. j' e \\<le> capacity \\<Psi> e\n 2. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Psi>; x \\<noteq> sink \\<Psi>\\<rbrakk>\n       \\<Longrightarrow> KIR j' x", "fix e :: \"'v option edge\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>e. j' e \\<le> capacity \\<Psi> e\n 2. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Psi>; x \\<noteq> sink \\<Psi>\\<rbrakk>\n       \\<Longrightarrow> KIR j' x", "consider (None) \"e = (None, Some y)\"\n        | (Some) x y where \"e = (Some x, Some y)\" \"(x, y) \\<in> set ?E\"\n        | (old) x y where \"e = (Some x, Some y)\" \"(x, y) \\<notin> set ?E\"\n        | y' where \"e = (None, Some y')\" \"y \\<noteq> y'\"\n        | \"e = (None, None)\" | x where \"e = (Some x, None)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>e = (None, \\<langle>y\\<rangle>) \\<Longrightarrow> thesis;\n     \\<And>x ya.\n        \\<lbrakk>e = (\\<langle>x\\<rangle>, \\<langle>ya\\<rangle>);\n         (x, ya) \\<in> set (zip (y # q) q)\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<And>x ya.\n        \\<lbrakk>e = (\\<langle>x\\<rangle>, \\<langle>ya\\<rangle>);\n         (x, ya) \\<notin> set (zip (y # q) q)\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<And>y'.\n        \\<lbrakk>e = (None, \\<langle>y'\\<rangle>); y \\<noteq> y'\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     e = (None, None) \\<Longrightarrow> thesis;\n     \\<And>x.\n        e = (\\<langle>x\\<rangle>, None) \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by(cases e; case_tac a; case_tac b)(auto)"], ["proof (state)\nthis:\n  \\<lbrakk>e = (None, \\<langle>y\\<rangle>) \\<Longrightarrow> ?thesis;\n   \\<And>x ya.\n      \\<lbrakk>e = (\\<langle>x\\<rangle>, \\<langle>ya\\<rangle>);\n       (x, ya) \\<in> set (zip (y # q) q)\\<rbrakk>\n      \\<Longrightarrow> ?thesis;\n   \\<And>x ya.\n      \\<lbrakk>e = (\\<langle>x\\<rangle>, \\<langle>ya\\<rangle>);\n       (x, ya) \\<notin> set (zip (y # q) q)\\<rbrakk>\n      \\<Longrightarrow> ?thesis;\n   \\<And>y'.\n      \\<lbrakk>e = (None, \\<langle>y'\\<rangle>); y \\<noteq> y'\\<rbrakk>\n      \\<Longrightarrow> ?thesis;\n   e = (None, None) \\<Longrightarrow> ?thesis;\n   \\<And>x.\n      e = (\\<langle>x\\<rangle>, None) \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (2 subgoals):\n 1. \\<And>e. j' e \\<le> capacity \\<Psi> e\n 2. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Psi>; x \\<noteq> sink \\<Psi>\\<rbrakk>\n       \\<Longrightarrow> KIR j' x", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>e = (None, \\<langle>y\\<rangle>) \\<Longrightarrow> ?thesis;\n   \\<And>x ya.\n      \\<lbrakk>e = (\\<langle>x\\<rangle>, \\<langle>ya\\<rangle>);\n       (x, ya) \\<in> set (zip (y # q) q)\\<rbrakk>\n      \\<Longrightarrow> ?thesis;\n   \\<And>x ya.\n      \\<lbrakk>e = (\\<langle>x\\<rangle>, \\<langle>ya\\<rangle>);\n       (x, ya) \\<notin> set (zip (y # q) q)\\<rbrakk>\n      \\<Longrightarrow> ?thesis;\n   \\<And>y'.\n      \\<lbrakk>e = (None, \\<langle>y'\\<rangle>); y \\<noteq> y'\\<rbrakk>\n      \\<Longrightarrow> ?thesis;\n   e = (None, None) \\<Longrightarrow> ?thesis;\n   \\<And>x.\n      e = (\\<langle>x\\<rangle>, None) \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis", "show \"j' e \\<le> capacity \\<Psi> e\""], ["proof (prove)\nusing this:\n  \\<lbrakk>e = (None, \\<langle>y\\<rangle>) \\<Longrightarrow> ?thesis;\n   \\<And>x ya.\n      \\<lbrakk>e = (\\<langle>x\\<rangle>, \\<langle>ya\\<rangle>);\n       (x, ya) \\<in> set (zip (y # q) q)\\<rbrakk>\n      \\<Longrightarrow> ?thesis;\n   \\<And>x ya.\n      \\<lbrakk>e = (\\<langle>x\\<rangle>, \\<langle>ya\\<rangle>);\n       (x, ya) \\<notin> set (zip (y # q) q)\\<rbrakk>\n      \\<Longrightarrow> ?thesis;\n   \\<And>y'.\n      \\<lbrakk>e = (None, \\<langle>y'\\<rangle>); y \\<noteq> y'\\<rbrakk>\n      \\<Longrightarrow> ?thesis;\n   e = (None, None) \\<Longrightarrow> ?thesis;\n   \\<And>x.\n      e = (\\<langle>x\\<rangle>, None) \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. j' e \\<le> capacity \\<Psi> e", "using uy \\<zeta>_pos flowD_capacity[OF j, of e]"], ["proof (prove)\nusing this:\n  \\<lbrakk>e = (None, \\<langle>y\\<rangle>) \\<Longrightarrow> ?thesis;\n   \\<And>x ya.\n      \\<lbrakk>e = (\\<langle>x\\<rangle>, \\<langle>ya\\<rangle>);\n       (x, ya) \\<in> set (zip (y # q) q)\\<rbrakk>\n      \\<Longrightarrow> ?thesis;\n   \\<And>x ya.\n      \\<lbrakk>e = (\\<langle>x\\<rangle>, \\<langle>ya\\<rangle>);\n       (x, ya) \\<notin> set (zip (y # q) q)\\<rbrakk>\n      \\<Longrightarrow> ?thesis;\n   \\<And>y'.\n      \\<lbrakk>e = (None, \\<langle>y'\\<rangle>); y \\<noteq> y'\\<rbrakk>\n      \\<Longrightarrow> ?thesis;\n   e = (None, None) \\<Longrightarrow> ?thesis;\n   \\<And>x.\n      e = (\\<langle>x\\<rangle>, None) \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  0 < u y\n  0 < \\<zeta>\n  j e \\<le> capacity \\<Psi> e\n\ngoal (1 subgoal):\n 1. j' e \\<le> capacity \\<Psi> e", "proof(cases)"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<lbrakk>0 < u y; 0 < \\<zeta>; j e \\<le> capacity \\<Psi> e;\n     e = (None, \\<langle>y\\<rangle>)\\<rbrakk>\n    \\<Longrightarrow> j' e \\<le> capacity \\<Psi> e\n 2. \\<And>x ya.\n       \\<lbrakk>0 < u y; 0 < \\<zeta>; j e \\<le> capacity \\<Psi> e;\n        e = (\\<langle>x\\<rangle>, \\<langle>ya\\<rangle>);\n        (x, ya) \\<in> set (zip (y # q) q)\\<rbrakk>\n       \\<Longrightarrow> j' e \\<le> capacity \\<Psi> e\n 3. \\<And>x ya.\n       \\<lbrakk>0 < u y; 0 < \\<zeta>; j e \\<le> capacity \\<Psi> e;\n        e = (\\<langle>x\\<rangle>, \\<langle>ya\\<rangle>);\n        (x, ya) \\<notin> set (zip (y # q) q)\\<rbrakk>\n       \\<Longrightarrow> j' e \\<le> capacity \\<Psi> e\n 4. \\<And>y'.\n       \\<lbrakk>0 < u y; 0 < \\<zeta>; j e \\<le> capacity \\<Psi> e;\n        e = (None, \\<langle>y'\\<rangle>); y \\<noteq> y'\\<rbrakk>\n       \\<Longrightarrow> j' e \\<le> capacity \\<Psi> e\n 5. \\<lbrakk>0 < u y; 0 < \\<zeta>; j e \\<le> capacity \\<Psi> e;\n     e = (None, None)\\<rbrakk>\n    \\<Longrightarrow> j' e \\<le> capacity \\<Psi> e\n 6. \\<And>x.\n       \\<lbrakk>0 < u y; 0 < \\<zeta>; j e \\<le> capacity \\<Psi> e;\n        e = (\\<langle>x\\<rangle>, None)\\<rbrakk>\n       \\<Longrightarrow> j' e \\<le> capacity \\<Psi> e", "case None"], ["proof (state)\nthis:\n  e = (None, \\<langle>y\\<rangle>)\n\ngoal (6 subgoals):\n 1. \\<lbrakk>0 < u y; 0 < \\<zeta>; j e \\<le> capacity \\<Psi> e;\n     e = (None, \\<langle>y\\<rangle>)\\<rbrakk>\n    \\<Longrightarrow> j' e \\<le> capacity \\<Psi> e\n 2. \\<And>x ya.\n       \\<lbrakk>0 < u y; 0 < \\<zeta>; j e \\<le> capacity \\<Psi> e;\n        e = (\\<langle>x\\<rangle>, \\<langle>ya\\<rangle>);\n        (x, ya) \\<in> set (zip (y # q) q)\\<rbrakk>\n       \\<Longrightarrow> j' e \\<le> capacity \\<Psi> e\n 3. \\<And>x ya.\n       \\<lbrakk>0 < u y; 0 < \\<zeta>; j e \\<le> capacity \\<Psi> e;\n        e = (\\<langle>x\\<rangle>, \\<langle>ya\\<rangle>);\n        (x, ya) \\<notin> set (zip (y # q) q)\\<rbrakk>\n       \\<Longrightarrow> j' e \\<le> capacity \\<Psi> e\n 4. \\<And>y'.\n       \\<lbrakk>0 < u y; 0 < \\<zeta>; j e \\<le> capacity \\<Psi> e;\n        e = (None, \\<langle>y'\\<rangle>); y \\<noteq> y'\\<rbrakk>\n       \\<Longrightarrow> j' e \\<le> capacity \\<Psi> e\n 5. \\<lbrakk>0 < u y; 0 < \\<zeta>; j e \\<le> capacity \\<Psi> e;\n     e = (None, None)\\<rbrakk>\n    \\<Longrightarrow> j' e \\<le> capacity \\<Psi> e\n 6. \\<And>x.\n       \\<lbrakk>0 < u y; 0 < \\<zeta>; j e \\<le> capacity \\<Psi> e;\n        e = (\\<langle>x\\<rangle>, None)\\<rbrakk>\n       \\<Longrightarrow> j' e \\<le> capacity \\<Psi> e", "have \"\\<zeta> \\<le> u y - j (None, Some y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<zeta> \\<le> u y - j (None, \\<langle>y\\<rangle>)", "by(simp add: \\<zeta>_def)"], ["proof (state)\nthis:\n  \\<zeta> \\<le> u y - j (None, \\<langle>y\\<rangle>)\n\ngoal (6 subgoals):\n 1. \\<lbrakk>0 < u y; 0 < \\<zeta>; j e \\<le> capacity \\<Psi> e;\n     e = (None, \\<langle>y\\<rangle>)\\<rbrakk>\n    \\<Longrightarrow> j' e \\<le> capacity \\<Psi> e\n 2. \\<And>x ya.\n       \\<lbrakk>0 < u y; 0 < \\<zeta>; j e \\<le> capacity \\<Psi> e;\n        e = (\\<langle>x\\<rangle>, \\<langle>ya\\<rangle>);\n        (x, ya) \\<in> set (zip (y # q) q)\\<rbrakk>\n       \\<Longrightarrow> j' e \\<le> capacity \\<Psi> e\n 3. \\<And>x ya.\n       \\<lbrakk>0 < u y; 0 < \\<zeta>; j e \\<le> capacity \\<Psi> e;\n        e = (\\<langle>x\\<rangle>, \\<langle>ya\\<rangle>);\n        (x, ya) \\<notin> set (zip (y # q) q)\\<rbrakk>\n       \\<Longrightarrow> j' e \\<le> capacity \\<Psi> e\n 4. \\<And>y'.\n       \\<lbrakk>0 < u y; 0 < \\<zeta>; j e \\<le> capacity \\<Psi> e;\n        e = (None, \\<langle>y'\\<rangle>); y \\<noteq> y'\\<rbrakk>\n       \\<Longrightarrow> j' e \\<le> capacity \\<Psi> e\n 5. \\<lbrakk>0 < u y; 0 < \\<zeta>; j e \\<le> capacity \\<Psi> e;\n     e = (None, None)\\<rbrakk>\n    \\<Longrightarrow> j' e \\<le> capacity \\<Psi> e\n 6. \\<And>x.\n       \\<lbrakk>0 < u y; 0 < \\<zeta>; j e \\<le> capacity \\<Psi> e;\n        e = (\\<langle>x\\<rangle>, None)\\<rbrakk>\n       \\<Longrightarrow> j' e \\<le> capacity \\<Psi> e", "then"], ["proof (chain)\npicking this:\n  \\<zeta> \\<le> u y - j (None, \\<langle>y\\<rangle>)", "have \"\\<zeta> + j (None, Some y) \\<le> u y\""], ["proof (prove)\nusing this:\n  \\<zeta> \\<le> u y - j (None, \\<langle>y\\<rangle>)\n\ngoal (1 subgoal):\n 1. \\<zeta> + j (None, \\<langle>y\\<rangle>) \\<le> u y", "using \\<zeta>_pos"], ["proof (prove)\nusing this:\n  \\<zeta> \\<le> u y - j (None, \\<langle>y\\<rangle>)\n  0 < \\<zeta>\n\ngoal (1 subgoal):\n 1. \\<zeta> + j (None, \\<langle>y\\<rangle>) \\<le> u y", "by (auto simp add: ennreal_le_minus_iff)"], ["proof (state)\nthis:\n  \\<zeta> + j (None, \\<langle>y\\<rangle>) \\<le> u y\n\ngoal (6 subgoals):\n 1. \\<lbrakk>0 < u y; 0 < \\<zeta>; j e \\<le> capacity \\<Psi> e;\n     e = (None, \\<langle>y\\<rangle>)\\<rbrakk>\n    \\<Longrightarrow> j' e \\<le> capacity \\<Psi> e\n 2. \\<And>x ya.\n       \\<lbrakk>0 < u y; 0 < \\<zeta>; j e \\<le> capacity \\<Psi> e;\n        e = (\\<langle>x\\<rangle>, \\<langle>ya\\<rangle>);\n        (x, ya) \\<in> set (zip (y # q) q)\\<rbrakk>\n       \\<Longrightarrow> j' e \\<le> capacity \\<Psi> e\n 3. \\<And>x ya.\n       \\<lbrakk>0 < u y; 0 < \\<zeta>; j e \\<le> capacity \\<Psi> e;\n        e = (\\<langle>x\\<rangle>, \\<langle>ya\\<rangle>);\n        (x, ya) \\<notin> set (zip (y # q) q)\\<rbrakk>\n       \\<Longrightarrow> j' e \\<le> capacity \\<Psi> e\n 4. \\<And>y'.\n       \\<lbrakk>0 < u y; 0 < \\<zeta>; j e \\<le> capacity \\<Psi> e;\n        e = (None, \\<langle>y'\\<rangle>); y \\<noteq> y'\\<rbrakk>\n       \\<Longrightarrow> j' e \\<le> capacity \\<Psi> e\n 5. \\<lbrakk>0 < u y; 0 < \\<zeta>; j e \\<le> capacity \\<Psi> e;\n     e = (None, None)\\<rbrakk>\n    \\<Longrightarrow> j' e \\<le> capacity \\<Psi> e\n 6. \\<And>x.\n       \\<lbrakk>0 < u y; 0 < \\<zeta>; j e \\<le> capacity \\<Psi> e;\n        e = (\\<langle>x\\<rangle>, None)\\<rbrakk>\n       \\<Longrightarrow> j' e \\<le> capacity \\<Psi> e", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<zeta> + j (None, \\<langle>y\\<rangle>) \\<le> u y\n\ngoal (1 subgoal):\n 1. j' e \\<le> capacity \\<Psi> e", "using reachable_V[OF reach] None \\<Psi>.flowD_outside[OF j, of \"(Some y, None)\"] uy"], ["proof (prove)\nusing this:\n  \\<zeta> + j (None, \\<langle>y\\<rangle>) \\<le> u y\n  vertex \\<Gamma> y\n  e = (None, \\<langle>y\\<rangle>)\n  (\\<langle>y\\<rangle>, None)\n  \\<notin> \\<^bold>E\\<^bsub>\\<Psi>\\<^esub> \\<Longrightarrow>\n  j (\\<langle>y\\<rangle>, None) = 0\n  0 < u y\n\ngoal (1 subgoal):\n 1. j' e \\<le> capacity \\<Psi> e", "by(auto simp add: j'_def E_def)"], ["proof (state)\nthis:\n  j' e \\<le> capacity \\<Psi> e\n\ngoal (5 subgoals):\n 1. \\<And>x ya.\n       \\<lbrakk>0 < u y; 0 < \\<zeta>; j e \\<le> capacity \\<Psi> e;\n        e = (\\<langle>x\\<rangle>, \\<langle>ya\\<rangle>);\n        (x, ya) \\<in> set (zip (y # q) q)\\<rbrakk>\n       \\<Longrightarrow> j' e \\<le> capacity \\<Psi> e\n 2. \\<And>x ya.\n       \\<lbrakk>0 < u y; 0 < \\<zeta>; j e \\<le> capacity \\<Psi> e;\n        e = (\\<langle>x\\<rangle>, \\<langle>ya\\<rangle>);\n        (x, ya) \\<notin> set (zip (y # q) q)\\<rbrakk>\n       \\<Longrightarrow> j' e \\<le> capacity \\<Psi> e\n 3. \\<And>y'.\n       \\<lbrakk>0 < u y; 0 < \\<zeta>; j e \\<le> capacity \\<Psi> e;\n        e = (None, \\<langle>y'\\<rangle>); y \\<noteq> y'\\<rbrakk>\n       \\<Longrightarrow> j' e \\<le> capacity \\<Psi> e\n 4. \\<lbrakk>0 < u y; 0 < \\<zeta>; j e \\<le> capacity \\<Psi> e;\n     e = (None, None)\\<rbrakk>\n    \\<Longrightarrow> j' e \\<le> capacity \\<Psi> e\n 5. \\<And>x.\n       \\<lbrakk>0 < u y; 0 < \\<zeta>; j e \\<le> capacity \\<Psi> e;\n        e = (\\<langle>x\\<rangle>, None)\\<rbrakk>\n       \\<Longrightarrow> j' e \\<le> capacity \\<Psi> e", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>x ya.\n       \\<lbrakk>0 < u y; 0 < \\<zeta>; j e \\<le> capacity \\<Psi> e;\n        e = (\\<langle>x\\<rangle>, \\<langle>ya\\<rangle>);\n        (x, ya) \\<in> set (zip (y # q) q)\\<rbrakk>\n       \\<Longrightarrow> j' e \\<le> capacity \\<Psi> e\n 2. \\<And>x ya.\n       \\<lbrakk>0 < u y; 0 < \\<zeta>; j e \\<le> capacity \\<Psi> e;\n        e = (\\<langle>x\\<rangle>, \\<langle>ya\\<rangle>);\n        (x, ya) \\<notin> set (zip (y # q) q)\\<rbrakk>\n       \\<Longrightarrow> j' e \\<le> capacity \\<Psi> e\n 3. \\<And>y'.\n       \\<lbrakk>0 < u y; 0 < \\<zeta>; j e \\<le> capacity \\<Psi> e;\n        e = (None, \\<langle>y'\\<rangle>); y \\<noteq> y'\\<rbrakk>\n       \\<Longrightarrow> j' e \\<le> capacity \\<Psi> e\n 4. \\<lbrakk>0 < u y; 0 < \\<zeta>; j e \\<le> capacity \\<Psi> e;\n     e = (None, None)\\<rbrakk>\n    \\<Longrightarrow> j' e \\<le> capacity \\<Psi> e\n 5. \\<And>x.\n       \\<lbrakk>0 < u y; 0 < \\<zeta>; j e \\<le> capacity \\<Psi> e;\n        e = (\\<langle>x\\<rangle>, None)\\<rbrakk>\n       \\<Longrightarrow> j' e \\<le> capacity \\<Psi> e", "case (Some x' y')"], ["proof (state)\nthis:\n  e = (\\<langle>x'\\<rangle>, \\<langle>y'\\<rangle>)\n  (x', y') \\<in> set (zip (y # q) q)\n\ngoal (5 subgoals):\n 1. \\<And>x ya.\n       \\<lbrakk>0 < u y; 0 < \\<zeta>; j e \\<le> capacity \\<Psi> e;\n        e = (\\<langle>x\\<rangle>, \\<langle>ya\\<rangle>);\n        (x, ya) \\<in> set (zip (y # q) q)\\<rbrakk>\n       \\<Longrightarrow> j' e \\<le> capacity \\<Psi> e\n 2. \\<And>x ya.\n       \\<lbrakk>0 < u y; 0 < \\<zeta>; j e \\<le> capacity \\<Psi> e;\n        e = (\\<langle>x\\<rangle>, \\<langle>ya\\<rangle>);\n        (x, ya) \\<notin> set (zip (y # q) q)\\<rbrakk>\n       \\<Longrightarrow> j' e \\<le> capacity \\<Psi> e\n 3. \\<And>y'.\n       \\<lbrakk>0 < u y; 0 < \\<zeta>; j e \\<le> capacity \\<Psi> e;\n        e = (None, \\<langle>y'\\<rangle>); y \\<noteq> y'\\<rbrakk>\n       \\<Longrightarrow> j' e \\<le> capacity \\<Psi> e\n 4. \\<lbrakk>0 < u y; 0 < \\<zeta>; j e \\<le> capacity \\<Psi> e;\n     e = (None, None)\\<rbrakk>\n    \\<Longrightarrow> j' e \\<le> capacity \\<Psi> e\n 5. \\<And>x.\n       \\<lbrakk>0 < u y; 0 < \\<zeta>; j e \\<le> capacity \\<Psi> e;\n        e = (\\<langle>x\\<rangle>, None)\\<rbrakk>\n       \\<Longrightarrow> j' e \\<le> capacity \\<Psi> e", "have e: \"\\<zeta> \\<le> cap' (x', y')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<zeta> \\<le> cap' (x', y')", "using Some(2)"], ["proof (prove)\nusing this:\n  (x', y') \\<in> set (zip (y # q) q)\n\ngoal (1 subgoal):\n 1. \\<zeta> \\<le> cap' (x', y')", "by(rule \\<zeta>_le)"], ["proof (state)\nthis:\n  \\<zeta> \\<le> cap' (x', y')\n\ngoal (5 subgoals):\n 1. \\<And>x ya.\n       \\<lbrakk>0 < u y; 0 < \\<zeta>; j e \\<le> capacity \\<Psi> e;\n        e = (\\<langle>x\\<rangle>, \\<langle>ya\\<rangle>);\n        (x, ya) \\<in> set (zip (y # q) q)\\<rbrakk>\n       \\<Longrightarrow> j' e \\<le> capacity \\<Psi> e\n 2. \\<And>x ya.\n       \\<lbrakk>0 < u y; 0 < \\<zeta>; j e \\<le> capacity \\<Psi> e;\n        e = (\\<langle>x\\<rangle>, \\<langle>ya\\<rangle>);\n        (x, ya) \\<notin> set (zip (y # q) q)\\<rbrakk>\n       \\<Longrightarrow> j' e \\<le> capacity \\<Psi> e\n 3. \\<And>y'.\n       \\<lbrakk>0 < u y; 0 < \\<zeta>; j e \\<le> capacity \\<Psi> e;\n        e = (None, \\<langle>y'\\<rangle>); y \\<noteq> y'\\<rbrakk>\n       \\<Longrightarrow> j' e \\<le> capacity \\<Psi> e\n 4. \\<lbrakk>0 < u y; 0 < \\<zeta>; j e \\<le> capacity \\<Psi> e;\n     e = (None, None)\\<rbrakk>\n    \\<Longrightarrow> j' e \\<le> capacity \\<Psi> e\n 5. \\<And>x.\n       \\<lbrakk>0 < u y; 0 < \\<zeta>; j e \\<le> capacity \\<Psi> e;\n        e = (\\<langle>x\\<rangle>, None)\\<rbrakk>\n       \\<Longrightarrow> j' e \\<le> capacity \\<Psi> e", "then"], ["proof (chain)\npicking this:\n  \\<zeta> \\<le> cap' (x', y')", "consider (backward) \"edge \\<Gamma> x' y'\" \"x' \\<noteq> a\" | (forward) \"edge \\<Gamma> y' x'\" \"\\<not> edge \\<Gamma> x' y'\"\n          | (a') \"edge \\<Gamma> x' y'\" \"x' = a\""], ["proof (prove)\nusing this:\n  \\<zeta> \\<le> cap' (x', y')\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>edge \\<Gamma> x' y'; x' \\<noteq> a\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     \\<lbrakk>edge \\<Gamma> y' x'; \\<not> edge \\<Gamma> x' y'\\<rbrakk>\n     \\<Longrightarrow> thesis;\n     \\<lbrakk>edge \\<Gamma> x' y'; x' = a\\<rbrakk>\n     \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "using Some \\<zeta>_pos"], ["proof (prove)\nusing this:\n  \\<zeta> \\<le> cap' (x', y')\n  e = (\\<langle>x'\\<rangle>, \\<langle>y'\\<rangle>)\n  (x', y') \\<in> set (zip (y # q) q)\n  0 < \\<zeta>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>edge \\<Gamma> x' y'; x' \\<noteq> a\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     \\<lbrakk>edge \\<Gamma> y' x'; \\<not> edge \\<Gamma> x' y'\\<rbrakk>\n     \\<Longrightarrow> thesis;\n     \\<lbrakk>edge \\<Gamma> x' y'; x' = a\\<rbrakk>\n     \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by(auto split: if_split_asm)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<lbrakk>edge \\<Gamma> x' y'; x' \\<noteq> a\\<rbrakk>\n           \\<Longrightarrow> ?thesis;\n   \\<lbrakk>edge \\<Gamma> y' x'; \\<not> edge \\<Gamma> x' y'\\<rbrakk>\n   \\<Longrightarrow> ?thesis;\n   \\<lbrakk>edge \\<Gamma> x' y'; x' = a\\<rbrakk>\n   \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (5 subgoals):\n 1. \\<And>x ya.\n       \\<lbrakk>0 < u y; 0 < \\<zeta>; j e \\<le> capacity \\<Psi> e;\n        e = (\\<langle>x\\<rangle>, \\<langle>ya\\<rangle>);\n        (x, ya) \\<in> set (zip (y # q) q)\\<rbrakk>\n       \\<Longrightarrow> j' e \\<le> capacity \\<Psi> e\n 2. \\<And>x ya.\n       \\<lbrakk>0 < u y; 0 < \\<zeta>; j e \\<le> capacity \\<Psi> e;\n        e = (\\<langle>x\\<rangle>, \\<langle>ya\\<rangle>);\n        (x, ya) \\<notin> set (zip (y # q) q)\\<rbrakk>\n       \\<Longrightarrow> j' e \\<le> capacity \\<Psi> e\n 3. \\<And>y'.\n       \\<lbrakk>0 < u y; 0 < \\<zeta>; j e \\<le> capacity \\<Psi> e;\n        e = (None, \\<langle>y'\\<rangle>); y \\<noteq> y'\\<rbrakk>\n       \\<Longrightarrow> j' e \\<le> capacity \\<Psi> e\n 4. \\<lbrakk>0 < u y; 0 < \\<zeta>; j e \\<le> capacity \\<Psi> e;\n     e = (None, None)\\<rbrakk>\n    \\<Longrightarrow> j' e \\<le> capacity \\<Psi> e\n 5. \\<And>x.\n       \\<lbrakk>0 < u y; 0 < \\<zeta>; j e \\<le> capacity \\<Psi> e;\n        e = (\\<langle>x\\<rangle>, None)\\<rbrakk>\n       \\<Longrightarrow> j' e \\<le> capacity \\<Psi> e", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<lbrakk>edge \\<Gamma> x' y'; x' \\<noteq> a\\<rbrakk>\n           \\<Longrightarrow> ?thesis;\n   \\<lbrakk>edge \\<Gamma> y' x'; \\<not> edge \\<Gamma> x' y'\\<rbrakk>\n   \\<Longrightarrow> ?thesis;\n   \\<lbrakk>edge \\<Gamma> x' y'; x' = a\\<rbrakk>\n   \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<lbrakk>edge \\<Gamma> x' y'; x' \\<noteq> a\\<rbrakk>\n           \\<Longrightarrow> ?thesis;\n   \\<lbrakk>edge \\<Gamma> y' x'; \\<not> edge \\<Gamma> x' y'\\<rbrakk>\n   \\<Longrightarrow> ?thesis;\n   \\<lbrakk>edge \\<Gamma> x' y'; x' = a\\<rbrakk>\n   \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. j' e \\<le> capacity \\<Psi> e", "proof cases"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>edge \\<Gamma> x' y'; x' \\<noteq> a\\<rbrakk>\n    \\<Longrightarrow> j' e \\<le> capacity \\<Psi> e\n 2. \\<lbrakk>edge \\<Gamma> y' x'; \\<not> edge \\<Gamma> x' y'\\<rbrakk>\n    \\<Longrightarrow> j' e \\<le> capacity \\<Psi> e\n 3. \\<lbrakk>edge \\<Gamma> x' y'; x' = a\\<rbrakk>\n    \\<Longrightarrow> j' e \\<le> capacity \\<Psi> e", "case backward"], ["proof (state)\nthis:\n  edge \\<Gamma> x' y'\n  x' \\<noteq> a\n\ngoal (3 subgoals):\n 1. \\<lbrakk>edge \\<Gamma> x' y'; x' \\<noteq> a\\<rbrakk>\n    \\<Longrightarrow> j' e \\<le> capacity \\<Psi> e\n 2. \\<lbrakk>edge \\<Gamma> y' x'; \\<not> edge \\<Gamma> x' y'\\<rbrakk>\n    \\<Longrightarrow> j' e \\<le> capacity \\<Psi> e\n 3. \\<lbrakk>edge \\<Gamma> x' y'; x' = a\\<rbrakk>\n    \\<Longrightarrow> j' e \\<le> capacity \\<Psi> e", "have \"\\<zeta> \\<le> f (x', y') + j (Some y', Some x') - j (Some x', Some y')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<zeta>\n    \\<le> f (x', y') + j (\\<langle>y'\\<rangle>, \\<langle>x'\\<rangle>) -\n          j (\\<langle>x'\\<rangle>, \\<langle>y'\\<rangle>)", "using e backward Some(1)"], ["proof (prove)\nusing this:\n  \\<zeta> \\<le> cap' (x', y')\n  edge \\<Gamma> x' y'\n  x' \\<noteq> a\n  e = (\\<langle>x'\\<rangle>, \\<langle>y'\\<rangle>)\n\ngoal (1 subgoal):\n 1. \\<zeta>\n    \\<le> f (x', y') + j (\\<langle>y'\\<rangle>, \\<langle>x'\\<rangle>) -\n          j (\\<langle>x'\\<rangle>, \\<langle>y'\\<rangle>)", "by(simp add: g_simps)"], ["proof (state)\nthis:\n  \\<zeta>\n  \\<le> f (x', y') + j (\\<langle>y'\\<rangle>, \\<langle>x'\\<rangle>) -\n        j (\\<langle>x'\\<rangle>, \\<langle>y'\\<rangle>)\n\ngoal (3 subgoals):\n 1. \\<lbrakk>edge \\<Gamma> x' y'; x' \\<noteq> a\\<rbrakk>\n    \\<Longrightarrow> j' e \\<le> capacity \\<Psi> e\n 2. \\<lbrakk>edge \\<Gamma> y' x'; \\<not> edge \\<Gamma> x' y'\\<rbrakk>\n    \\<Longrightarrow> j' e \\<le> capacity \\<Psi> e\n 3. \\<lbrakk>edge \\<Gamma> x' y'; x' = a\\<rbrakk>\n    \\<Longrightarrow> j' e \\<le> capacity \\<Psi> e", "hence \"\\<zeta> + j (Some x', Some y') - j (Some y', Some x') \\<le> (f (x', y') + j (Some y', Some x') - j (Some x', Some y')) + j (Some x', Some y') - j (Some y', Some x')\""], ["proof (prove)\nusing this:\n  \\<zeta>\n  \\<le> f (x', y') + j (\\<langle>y'\\<rangle>, \\<langle>x'\\<rangle>) -\n        j (\\<langle>x'\\<rangle>, \\<langle>y'\\<rangle>)\n\ngoal (1 subgoal):\n 1. \\<zeta> + j (\\<langle>x'\\<rangle>, \\<langle>y'\\<rangle>) -\n    j (\\<langle>y'\\<rangle>, \\<langle>x'\\<rangle>)\n    \\<le> f (x', y') + j (\\<langle>y'\\<rangle>, \\<langle>x'\\<rangle>) -\n          j (\\<langle>x'\\<rangle>, \\<langle>y'\\<rangle>) +\n          j (\\<langle>x'\\<rangle>, \\<langle>y'\\<rangle>) -\n          j (\\<langle>y'\\<rangle>, \\<langle>x'\\<rangle>)", "by(intro ennreal_minus_mono add_right_mono) simp_all"], ["proof (state)\nthis:\n  \\<zeta> + j (\\<langle>x'\\<rangle>, \\<langle>y'\\<rangle>) -\n  j (\\<langle>y'\\<rangle>, \\<langle>x'\\<rangle>)\n  \\<le> f (x', y') + j (\\<langle>y'\\<rangle>, \\<langle>x'\\<rangle>) -\n        j (\\<langle>x'\\<rangle>, \\<langle>y'\\<rangle>) +\n        j (\\<langle>x'\\<rangle>, \\<langle>y'\\<rangle>) -\n        j (\\<langle>y'\\<rangle>, \\<langle>x'\\<rangle>)\n\ngoal (3 subgoals):\n 1. \\<lbrakk>edge \\<Gamma> x' y'; x' \\<noteq> a\\<rbrakk>\n    \\<Longrightarrow> j' e \\<le> capacity \\<Psi> e\n 2. \\<lbrakk>edge \\<Gamma> y' x'; \\<not> edge \\<Gamma> x' y'\\<rbrakk>\n    \\<Longrightarrow> j' e \\<le> capacity \\<Psi> e\n 3. \\<lbrakk>edge \\<Gamma> x' y'; x' = a\\<rbrakk>\n    \\<Longrightarrow> j' e \\<le> capacity \\<Psi> e", "also"], ["proof (state)\nthis:\n  \\<zeta> + j (\\<langle>x'\\<rangle>, \\<langle>y'\\<rangle>) -\n  j (\\<langle>y'\\<rangle>, \\<langle>x'\\<rangle>)\n  \\<le> f (x', y') + j (\\<langle>y'\\<rangle>, \\<langle>x'\\<rangle>) -\n        j (\\<langle>x'\\<rangle>, \\<langle>y'\\<rangle>) +\n        j (\\<langle>x'\\<rangle>, \\<langle>y'\\<rangle>) -\n        j (\\<langle>y'\\<rangle>, \\<langle>x'\\<rangle>)\n\ngoal (3 subgoals):\n 1. \\<lbrakk>edge \\<Gamma> x' y'; x' \\<noteq> a\\<rbrakk>\n    \\<Longrightarrow> j' e \\<le> capacity \\<Psi> e\n 2. \\<lbrakk>edge \\<Gamma> y' x'; \\<not> edge \\<Gamma> x' y'\\<rbrakk>\n    \\<Longrightarrow> j' e \\<le> capacity \\<Psi> e\n 3. \\<lbrakk>edge \\<Gamma> x' y'; x' = a\\<rbrakk>\n    \\<Longrightarrow> j' e \\<le> capacity \\<Psi> e", "have \"\\<dots> = f (x', y')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f (x', y') + j (\\<langle>y'\\<rangle>, \\<langle>x'\\<rangle>) -\n    j (\\<langle>x'\\<rangle>, \\<langle>y'\\<rangle>) +\n    j (\\<langle>x'\\<rangle>, \\<langle>y'\\<rangle>) -\n    j (\\<langle>y'\\<rangle>, \\<langle>x'\\<rangle>) =\n    f (x', y')", "using j_le_f[OF \\<open>edge \\<Gamma> x' y'\\<close>]"], ["proof (prove)\nusing this:\n  j (\\<langle>x'\\<rangle>, \\<langle>y'\\<rangle>) \\<le> f (x', y')\n\ngoal (1 subgoal):\n 1. f (x', y') + j (\\<langle>y'\\<rangle>, \\<langle>x'\\<rangle>) -\n    j (\\<langle>x'\\<rangle>, \\<langle>y'\\<rangle>) +\n    j (\\<langle>x'\\<rangle>, \\<langle>y'\\<rangle>) -\n    j (\\<langle>y'\\<rangle>, \\<langle>x'\\<rangle>) =\n    f (x', y')", "by(simp_all add: add_increasing2 less_top diff_add_assoc2_ennreal)"], ["proof (state)\nthis:\n  f (x', y') + j (\\<langle>y'\\<rangle>, \\<langle>x'\\<rangle>) -\n  j (\\<langle>x'\\<rangle>, \\<langle>y'\\<rangle>) +\n  j (\\<langle>x'\\<rangle>, \\<langle>y'\\<rangle>) -\n  j (\\<langle>y'\\<rangle>, \\<langle>x'\\<rangle>) =\n  f (x', y')\n\ngoal (3 subgoals):\n 1. \\<lbrakk>edge \\<Gamma> x' y'; x' \\<noteq> a\\<rbrakk>\n    \\<Longrightarrow> j' e \\<le> capacity \\<Psi> e\n 2. \\<lbrakk>edge \\<Gamma> y' x'; \\<not> edge \\<Gamma> x' y'\\<rbrakk>\n    \\<Longrightarrow> j' e \\<le> capacity \\<Psi> e\n 3. \\<lbrakk>edge \\<Gamma> x' y'; x' = a\\<rbrakk>\n    \\<Longrightarrow> j' e \\<le> capacity \\<Psi> e", "finally"], ["proof (chain)\npicking this:\n  \\<zeta> + j (\\<langle>x'\\<rangle>, \\<langle>y'\\<rangle>) -\n  j (\\<langle>y'\\<rangle>, \\<langle>x'\\<rangle>)\n  \\<le> f (x', y')", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<zeta> + j (\\<langle>x'\\<rangle>, \\<langle>y'\\<rangle>) -\n  j (\\<langle>y'\\<rangle>, \\<langle>x'\\<rangle>)\n  \\<le> f (x', y')\n\ngoal (1 subgoal):\n 1. j' e \\<le> capacity \\<Psi> e", "using Some backward"], ["proof (prove)\nusing this:\n  \\<zeta> + j (\\<langle>x'\\<rangle>, \\<langle>y'\\<rangle>) -\n  j (\\<langle>y'\\<rangle>, \\<langle>x'\\<rangle>)\n  \\<le> f (x', y')\n  e = (\\<langle>x'\\<rangle>, \\<langle>y'\\<rangle>)\n  (x', y') \\<in> set (zip (y # q) q)\n  edge \\<Gamma> x' y'\n  x' \\<noteq> a\n\ngoal (1 subgoal):\n 1. j' e \\<le> capacity \\<Psi> e", "by(auto simp add: j'_def E_def dest: in_set_tlD E_antiparallel)"], ["proof (state)\nthis:\n  j' e \\<le> capacity \\<Psi> e\n\ngoal (2 subgoals):\n 1. \\<lbrakk>edge \\<Gamma> y' x'; \\<not> edge \\<Gamma> x' y'\\<rbrakk>\n    \\<Longrightarrow> j' e \\<le> capacity \\<Psi> e\n 2. \\<lbrakk>edge \\<Gamma> x' y'; x' = a\\<rbrakk>\n    \\<Longrightarrow> j' e \\<le> capacity \\<Psi> e", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>edge \\<Gamma> y' x'; \\<not> edge \\<Gamma> x' y'\\<rbrakk>\n    \\<Longrightarrow> j' e \\<le> capacity \\<Psi> e\n 2. \\<lbrakk>edge \\<Gamma> x' y'; x' = a\\<rbrakk>\n    \\<Longrightarrow> j' e \\<le> capacity \\<Psi> e", "case forward"], ["proof (state)\nthis:\n  edge \\<Gamma> y' x'\n  \\<not> edge \\<Gamma> x' y'\n\ngoal (2 subgoals):\n 1. \\<lbrakk>edge \\<Gamma> y' x'; \\<not> edge \\<Gamma> x' y'\\<rbrakk>\n    \\<Longrightarrow> j' e \\<le> capacity \\<Psi> e\n 2. \\<lbrakk>edge \\<Gamma> x' y'; x' = a\\<rbrakk>\n    \\<Longrightarrow> j' e \\<le> capacity \\<Psi> e", "have \"\\<zeta> + j (Some x', Some y') - j (Some y', Some x') \\<le> \\<zeta> + j (Some x', Some y')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<zeta> + j (\\<langle>x'\\<rangle>, \\<langle>y'\\<rangle>) -\n    j (\\<langle>y'\\<rangle>, \\<langle>x'\\<rangle>)\n    \\<le> \\<zeta> + j (\\<langle>x'\\<rangle>, \\<langle>y'\\<rangle>)", "by(rule diff_le_self_ennreal)"], ["proof (state)\nthis:\n  \\<zeta> + j (\\<langle>x'\\<rangle>, \\<langle>y'\\<rangle>) -\n  j (\\<langle>y'\\<rangle>, \\<langle>x'\\<rangle>)\n  \\<le> \\<zeta> + j (\\<langle>x'\\<rangle>, \\<langle>y'\\<rangle>)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>edge \\<Gamma> y' x'; \\<not> edge \\<Gamma> x' y'\\<rbrakk>\n    \\<Longrightarrow> j' e \\<le> capacity \\<Psi> e\n 2. \\<lbrakk>edge \\<Gamma> x' y'; x' = a\\<rbrakk>\n    \\<Longrightarrow> j' e \\<le> capacity \\<Psi> e", "also"], ["proof (state)\nthis:\n  \\<zeta> + j (\\<langle>x'\\<rangle>, \\<langle>y'\\<rangle>) -\n  j (\\<langle>y'\\<rangle>, \\<langle>x'\\<rangle>)\n  \\<le> \\<zeta> + j (\\<langle>x'\\<rangle>, \\<langle>y'\\<rangle>)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>edge \\<Gamma> y' x'; \\<not> edge \\<Gamma> x' y'\\<rbrakk>\n    \\<Longrightarrow> j' e \\<le> capacity \\<Psi> e\n 2. \\<lbrakk>edge \\<Gamma> x' y'; x' = a\\<rbrakk>\n    \\<Longrightarrow> j' e \\<le> capacity \\<Psi> e", "have \"j (Some x', Some y') \\<le> d_IN j (Some y')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j (\\<langle>x'\\<rangle>, \\<langle>y'\\<rangle>)\n    \\<le> d_IN j \\<langle>y'\\<rangle>", "by(rule d_IN_ge_point)"], ["proof (state)\nthis:\n  j (\\<langle>x'\\<rangle>, \\<langle>y'\\<rangle>)\n  \\<le> d_IN j \\<langle>y'\\<rangle>\n\ngoal (2 subgoals):\n 1. \\<lbrakk>edge \\<Gamma> y' x'; \\<not> edge \\<Gamma> x' y'\\<rbrakk>\n    \\<Longrightarrow> j' e \\<le> capacity \\<Psi> e\n 2. \\<lbrakk>edge \\<Gamma> x' y'; x' = a\\<rbrakk>\n    \\<Longrightarrow> j' e \\<le> capacity \\<Psi> e", "also"], ["proof (state)\nthis:\n  j (\\<langle>x'\\<rangle>, \\<langle>y'\\<rangle>)\n  \\<le> d_IN j \\<langle>y'\\<rangle>\n\ngoal (2 subgoals):\n 1. \\<lbrakk>edge \\<Gamma> y' x'; \\<not> edge \\<Gamma> x' y'\\<rbrakk>\n    \\<Longrightarrow> j' e \\<le> capacity \\<Psi> e\n 2. \\<lbrakk>edge \\<Gamma> x' y'; x' = a\\<rbrakk>\n    \\<Longrightarrow> j' e \\<le> capacity \\<Psi> e", "have \"\\<dots> \\<le> weight \\<Gamma> y'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN j \\<langle>y'\\<rangle> \\<le> weight \\<Gamma> y'", "by(rule IN_j_le_weight)"], ["proof (state)\nthis:\n  d_IN j \\<langle>y'\\<rangle> \\<le> weight \\<Gamma> y'\n\ngoal (2 subgoals):\n 1. \\<lbrakk>edge \\<Gamma> y' x'; \\<not> edge \\<Gamma> x' y'\\<rbrakk>\n    \\<Longrightarrow> j' e \\<le> capacity \\<Psi> e\n 2. \\<lbrakk>edge \\<Gamma> x' y'; x' = a\\<rbrakk>\n    \\<Longrightarrow> j' e \\<le> capacity \\<Psi> e", "also"], ["proof (state)\nthis:\n  d_IN j \\<langle>y'\\<rangle> \\<le> weight \\<Gamma> y'\n\ngoal (2 subgoals):\n 1. \\<lbrakk>edge \\<Gamma> y' x'; \\<not> edge \\<Gamma> x' y'\\<rbrakk>\n    \\<Longrightarrow> j' e \\<le> capacity \\<Psi> e\n 2. \\<lbrakk>edge \\<Gamma> x' y'; x' = a\\<rbrakk>\n    \\<Longrightarrow> j' e \\<le> capacity \\<Psi> e", "have \"\\<zeta> \\<le> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<zeta> \\<le> 1", "using e forward"], ["proof (prove)\nusing this:\n  \\<zeta> \\<le> cap' (x', y')\n  edge \\<Gamma> y' x'\n  \\<not> edge \\<Gamma> x' y'\n\ngoal (1 subgoal):\n 1. \\<zeta> \\<le> 1", "by simp"], ["proof (state)\nthis:\n  \\<zeta> \\<le> 1\n\ngoal (2 subgoals):\n 1. \\<lbrakk>edge \\<Gamma> y' x'; \\<not> edge \\<Gamma> x' y'\\<rbrakk>\n    \\<Longrightarrow> j' e \\<le> capacity \\<Psi> e\n 2. \\<lbrakk>edge \\<Gamma> x' y'; x' = a\\<rbrakk>\n    \\<Longrightarrow> j' e \\<le> capacity \\<Psi> e", "finally"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<And>x y.\n              x \\<le> y \\<Longrightarrow> \\<zeta> + x \\<le> \\<zeta> + y;\n   \\<And>x y. x \\<le> y \\<Longrightarrow> \\<zeta> + x \\<le> \\<zeta> + y;\n   \\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      x + weight \\<Gamma> y' \\<le> y + weight \\<Gamma> y'\\<rbrakk>\n  \\<Longrightarrow> \\<zeta> +\n                    j (\\<langle>x'\\<rangle>, \\<langle>y'\\<rangle>) -\n                    j (\\<langle>y'\\<rangle>, \\<langle>x'\\<rangle>)\n                    \\<le> 1 + weight \\<Gamma> y'", "have \"\\<zeta> + j (Some x', Some y') - j (Some y', Some x') \\<le> max (weight \\<Gamma> x') (weight \\<Gamma> y') + 1\""], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>x y.\n              x \\<le> y \\<Longrightarrow> \\<zeta> + x \\<le> \\<zeta> + y;\n   \\<And>x y. x \\<le> y \\<Longrightarrow> \\<zeta> + x \\<le> \\<zeta> + y;\n   \\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      x + weight \\<Gamma> y' \\<le> y + weight \\<Gamma> y'\\<rbrakk>\n  \\<Longrightarrow> \\<zeta> +\n                    j (\\<langle>x'\\<rangle>, \\<langle>y'\\<rangle>) -\n                    j (\\<langle>y'\\<rangle>, \\<langle>x'\\<rangle>)\n                    \\<le> 1 + weight \\<Gamma> y'\n\ngoal (1 subgoal):\n 1. \\<zeta> + j (\\<langle>x'\\<rangle>, \\<langle>y'\\<rangle>) -\n    j (\\<langle>y'\\<rangle>, \\<langle>x'\\<rangle>)\n    \\<le> max (weight \\<Gamma> x') (weight \\<Gamma> y') + 1", "by(simp add: add_left_mono add_right_mono max_def)(metis (no_types, lifting) add.commute add_right_mono less_imp_le less_le_trans not_le)"], ["proof (state)\nthis:\n  \\<zeta> + j (\\<langle>x'\\<rangle>, \\<langle>y'\\<rangle>) -\n  j (\\<langle>y'\\<rangle>, \\<langle>x'\\<rangle>)\n  \\<le> max (weight \\<Gamma> x') (weight \\<Gamma> y') + 1\n\ngoal (2 subgoals):\n 1. \\<lbrakk>edge \\<Gamma> y' x'; \\<not> edge \\<Gamma> x' y'\\<rbrakk>\n    \\<Longrightarrow> j' e \\<le> capacity \\<Psi> e\n 2. \\<lbrakk>edge \\<Gamma> x' y'; x' = a\\<rbrakk>\n    \\<Longrightarrow> j' e \\<le> capacity \\<Psi> e", "then"], ["proof (chain)\npicking this:\n  \\<zeta> + j (\\<langle>x'\\<rangle>, \\<langle>y'\\<rangle>) -\n  j (\\<langle>y'\\<rangle>, \\<langle>x'\\<rangle>)\n  \\<le> max (weight \\<Gamma> x') (weight \\<Gamma> y') + 1", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<zeta> + j (\\<langle>x'\\<rangle>, \\<langle>y'\\<rangle>) -\n  j (\\<langle>y'\\<rangle>, \\<langle>x'\\<rangle>)\n  \\<le> max (weight \\<Gamma> x') (weight \\<Gamma> y') + 1\n\ngoal (1 subgoal):\n 1. j' e \\<le> capacity \\<Psi> e", "using Some forward e"], ["proof (prove)\nusing this:\n  \\<zeta> + j (\\<langle>x'\\<rangle>, \\<langle>y'\\<rangle>) -\n  j (\\<langle>y'\\<rangle>, \\<langle>x'\\<rangle>)\n  \\<le> max (weight \\<Gamma> x') (weight \\<Gamma> y') + 1\n  e = (\\<langle>x'\\<rangle>, \\<langle>y'\\<rangle>)\n  (x', y') \\<in> set (zip (y # q) q)\n  edge \\<Gamma> y' x'\n  \\<not> edge \\<Gamma> x' y'\n  \\<zeta> \\<le> cap' (x', y')\n\ngoal (1 subgoal):\n 1. j' e \\<le> capacity \\<Psi> e", "by(auto simp add: j'_def E_def max_def dest: in_set_tlD E_antiparallel)"], ["proof (state)\nthis:\n  j' e \\<le> capacity \\<Psi> e\n\ngoal (1 subgoal):\n 1. \\<lbrakk>edge \\<Gamma> x' y'; x' = a\\<rbrakk>\n    \\<Longrightarrow> j' e \\<le> capacity \\<Psi> e", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>edge \\<Gamma> x' y'; x' = a\\<rbrakk>\n    \\<Longrightarrow> j' e \\<le> capacity \\<Psi> e", "case a'"], ["proof (state)\nthis:\n  edge \\<Gamma> x' y'\n  x' = a\n\ngoal (1 subgoal):\n 1. \\<lbrakk>edge \\<Gamma> x' y'; x' = a\\<rbrakk>\n    \\<Longrightarrow> j' e \\<le> capacity \\<Psi> e", "with Some"], ["proof (chain)\npicking this:\n  e = (\\<langle>x'\\<rangle>, \\<langle>y'\\<rangle>)\n  (x', y') \\<in> set (zip (y # q) q)\n  edge \\<Gamma> x' y'\n  x' = a", "have \"a \\<in> set (map fst (zip (y # q) q))\""], ["proof (prove)\nusing this:\n  e = (\\<langle>x'\\<rangle>, \\<langle>y'\\<rangle>)\n  (x', y') \\<in> set (zip (y # q) q)\n  edge \\<Gamma> x' y'\n  x' = a\n\ngoal (1 subgoal):\n 1. a \\<in> set (map fst (zip (y # q) q))", "by(auto intro: rev_image_eqI)"], ["proof (state)\nthis:\n  a \\<in> set (map fst (zip (y # q) q))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>edge \\<Gamma> x' y'; x' = a\\<rbrakk>\n    \\<Longrightarrow> j' e \\<le> capacity \\<Psi> e", "also"], ["proof (state)\nthis:\n  a \\<in> set (map fst (zip (y # q) q))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>edge \\<Gamma> x' y'; x' = a\\<rbrakk>\n    \\<Longrightarrow> j' e \\<le> capacity \\<Psi> e", "have \"map fst (zip (y # q) q) = butlast (y # q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map fst (zip (y # q) q) = butlast (y # q)", "by(induction q arbitrary: y) auto"], ["proof (state)\nthis:\n  map fst (zip (y # q) q) = butlast (y # q)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>edge \\<Gamma> x' y'; x' = a\\<rbrakk>\n    \\<Longrightarrow> j' e \\<le> capacity \\<Psi> e", "finally"], ["proof (chain)\npicking this:\n  a \\<in> set (butlast (y # q))", "have False"], ["proof (prove)\nusing this:\n  a \\<in> set (butlast (y # q))\n\ngoal (1 subgoal):\n 1. False", "using rtrancl_path_last[OF q q_Nil] distinct q_Nil"], ["proof (prove)\nusing this:\n  a \\<in> set (butlast (y # q))\n  last q = a\n  distinct (y # q)\n  q \\<noteq> []\n\ngoal (1 subgoal):\n 1. False", "by(cases q rule: rev_cases) auto"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<lbrakk>edge \\<Gamma> x' y'; x' = a\\<rbrakk>\n    \\<Longrightarrow> j' e \\<le> capacity \\<Psi> e", "then"], ["proof (chain)\npicking this:\n  False", "show ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. j' e \\<le> capacity \\<Psi> e", ".."], ["proof (state)\nthis:\n  j' e \\<le> capacity \\<Psi> e\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  j' e \\<le> capacity \\<Psi> e\n\ngoal (4 subgoals):\n 1. \\<And>x ya.\n       \\<lbrakk>0 < u y; 0 < \\<zeta>; j e \\<le> capacity \\<Psi> e;\n        e = (\\<langle>x\\<rangle>, \\<langle>ya\\<rangle>);\n        (x, ya) \\<notin> set (zip (y # q) q)\\<rbrakk>\n       \\<Longrightarrow> j' e \\<le> capacity \\<Psi> e\n 2. \\<And>y'.\n       \\<lbrakk>0 < u y; 0 < \\<zeta>; j e \\<le> capacity \\<Psi> e;\n        e = (None, \\<langle>y'\\<rangle>); y \\<noteq> y'\\<rbrakk>\n       \\<Longrightarrow> j' e \\<le> capacity \\<Psi> e\n 3. \\<lbrakk>0 < u y; 0 < \\<zeta>; j e \\<le> capacity \\<Psi> e;\n     e = (None, None)\\<rbrakk>\n    \\<Longrightarrow> j' e \\<le> capacity \\<Psi> e\n 4. \\<And>x.\n       \\<lbrakk>0 < u y; 0 < \\<zeta>; j e \\<le> capacity \\<Psi> e;\n        e = (\\<langle>x\\<rangle>, None)\\<rbrakk>\n       \\<Longrightarrow> j' e \\<le> capacity \\<Psi> e", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x ya.\n       \\<lbrakk>0 < u y; 0 < \\<zeta>; j e \\<le> capacity \\<Psi> e;\n        e = (\\<langle>x\\<rangle>, \\<langle>ya\\<rangle>);\n        (x, ya) \\<notin> set (zip (y # q) q)\\<rbrakk>\n       \\<Longrightarrow> j' e \\<le> capacity \\<Psi> e\n 2. \\<And>y'.\n       \\<lbrakk>0 < u y; 0 < \\<zeta>; j e \\<le> capacity \\<Psi> e;\n        e = (None, \\<langle>y'\\<rangle>); y \\<noteq> y'\\<rbrakk>\n       \\<Longrightarrow> j' e \\<le> capacity \\<Psi> e\n 3. \\<lbrakk>0 < u y; 0 < \\<zeta>; j e \\<le> capacity \\<Psi> e;\n     e = (None, None)\\<rbrakk>\n    \\<Longrightarrow> j' e \\<le> capacity \\<Psi> e\n 4. \\<And>x.\n       \\<lbrakk>0 < u y; 0 < \\<zeta>; j e \\<le> capacity \\<Psi> e;\n        e = (\\<langle>x\\<rangle>, None)\\<rbrakk>\n       \\<Longrightarrow> j' e \\<le> capacity \\<Psi> e", "case (old x' y')"], ["proof (state)\nthis:\n  e = (\\<langle>x'\\<rangle>, \\<langle>y'\\<rangle>)\n  (x', y') \\<notin> set (zip (y # q) q)\n\ngoal (4 subgoals):\n 1. \\<And>x ya.\n       \\<lbrakk>0 < u y; 0 < \\<zeta>; j e \\<le> capacity \\<Psi> e;\n        e = (\\<langle>x\\<rangle>, \\<langle>ya\\<rangle>);\n        (x, ya) \\<notin> set (zip (y # q) q)\\<rbrakk>\n       \\<Longrightarrow> j' e \\<le> capacity \\<Psi> e\n 2. \\<And>y'.\n       \\<lbrakk>0 < u y; 0 < \\<zeta>; j e \\<le> capacity \\<Psi> e;\n        e = (None, \\<langle>y'\\<rangle>); y \\<noteq> y'\\<rbrakk>\n       \\<Longrightarrow> j' e \\<le> capacity \\<Psi> e\n 3. \\<lbrakk>0 < u y; 0 < \\<zeta>; j e \\<le> capacity \\<Psi> e;\n     e = (None, None)\\<rbrakk>\n    \\<Longrightarrow> j' e \\<le> capacity \\<Psi> e\n 4. \\<And>x.\n       \\<lbrakk>0 < u y; 0 < \\<zeta>; j e \\<le> capacity \\<Psi> e;\n        e = (\\<langle>x\\<rangle>, None)\\<rbrakk>\n       \\<Longrightarrow> j' e \\<le> capacity \\<Psi> e", "hence \"j' e \\<le> j e\""], ["proof (prove)\nusing this:\n  e = (\\<langle>x'\\<rangle>, \\<langle>y'\\<rangle>)\n  (x', y') \\<notin> set (zip (y # q) q)\n\ngoal (1 subgoal):\n 1. j' e \\<le> j e", "using \\<zeta>_pos"], ["proof (prove)\nusing this:\n  e = (\\<langle>x'\\<rangle>, \\<langle>y'\\<rangle>)\n  (x', y') \\<notin> set (zip (y # q) q)\n  0 < \\<zeta>\n\ngoal (1 subgoal):\n 1. j' e \\<le> j e", "by(auto simp add: j'_def E_def intro!: diff_le_self_ennreal)"], ["proof (state)\nthis:\n  j' e \\<le> j e\n\ngoal (4 subgoals):\n 1. \\<And>x ya.\n       \\<lbrakk>0 < u y; 0 < \\<zeta>; j e \\<le> capacity \\<Psi> e;\n        e = (\\<langle>x\\<rangle>, \\<langle>ya\\<rangle>);\n        (x, ya) \\<notin> set (zip (y # q) q)\\<rbrakk>\n       \\<Longrightarrow> j' e \\<le> capacity \\<Psi> e\n 2. \\<And>y'.\n       \\<lbrakk>0 < u y; 0 < \\<zeta>; j e \\<le> capacity \\<Psi> e;\n        e = (None, \\<langle>y'\\<rangle>); y \\<noteq> y'\\<rbrakk>\n       \\<Longrightarrow> j' e \\<le> capacity \\<Psi> e\n 3. \\<lbrakk>0 < u y; 0 < \\<zeta>; j e \\<le> capacity \\<Psi> e;\n     e = (None, None)\\<rbrakk>\n    \\<Longrightarrow> j' e \\<le> capacity \\<Psi> e\n 4. \\<And>x.\n       \\<lbrakk>0 < u y; 0 < \\<zeta>; j e \\<le> capacity \\<Psi> e;\n        e = (\\<langle>x\\<rangle>, None)\\<rbrakk>\n       \\<Longrightarrow> j' e \\<le> capacity \\<Psi> e", "also"], ["proof (state)\nthis:\n  j' e \\<le> j e\n\ngoal (4 subgoals):\n 1. \\<And>x ya.\n       \\<lbrakk>0 < u y; 0 < \\<zeta>; j e \\<le> capacity \\<Psi> e;\n        e = (\\<langle>x\\<rangle>, \\<langle>ya\\<rangle>);\n        (x, ya) \\<notin> set (zip (y # q) q)\\<rbrakk>\n       \\<Longrightarrow> j' e \\<le> capacity \\<Psi> e\n 2. \\<And>y'.\n       \\<lbrakk>0 < u y; 0 < \\<zeta>; j e \\<le> capacity \\<Psi> e;\n        e = (None, \\<langle>y'\\<rangle>); y \\<noteq> y'\\<rbrakk>\n       \\<Longrightarrow> j' e \\<le> capacity \\<Psi> e\n 3. \\<lbrakk>0 < u y; 0 < \\<zeta>; j e \\<le> capacity \\<Psi> e;\n     e = (None, None)\\<rbrakk>\n    \\<Longrightarrow> j' e \\<le> capacity \\<Psi> e\n 4. \\<And>x.\n       \\<lbrakk>0 < u y; 0 < \\<zeta>; j e \\<le> capacity \\<Psi> e;\n        e = (\\<langle>x\\<rangle>, None)\\<rbrakk>\n       \\<Longrightarrow> j' e \\<le> capacity \\<Psi> e", "have \"j e \\<le> capacity \\<Psi> e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j e \\<le> capacity \\<Psi> e", "using j"], ["proof (prove)\nusing this:\n  flow \\<Psi> j\n\ngoal (1 subgoal):\n 1. j e \\<le> capacity \\<Psi> e", "by(rule flowD_capacity)"], ["proof (state)\nthis:\n  j e \\<le> capacity \\<Psi> e\n\ngoal (4 subgoals):\n 1. \\<And>x ya.\n       \\<lbrakk>0 < u y; 0 < \\<zeta>; j e \\<le> capacity \\<Psi> e;\n        e = (\\<langle>x\\<rangle>, \\<langle>ya\\<rangle>);\n        (x, ya) \\<notin> set (zip (y # q) q)\\<rbrakk>\n       \\<Longrightarrow> j' e \\<le> capacity \\<Psi> e\n 2. \\<And>y'.\n       \\<lbrakk>0 < u y; 0 < \\<zeta>; j e \\<le> capacity \\<Psi> e;\n        e = (None, \\<langle>y'\\<rangle>); y \\<noteq> y'\\<rbrakk>\n       \\<Longrightarrow> j' e \\<le> capacity \\<Psi> e\n 3. \\<lbrakk>0 < u y; 0 < \\<zeta>; j e \\<le> capacity \\<Psi> e;\n     e = (None, None)\\<rbrakk>\n    \\<Longrightarrow> j' e \\<le> capacity \\<Psi> e\n 4. \\<And>x.\n       \\<lbrakk>0 < u y; 0 < \\<zeta>; j e \\<le> capacity \\<Psi> e;\n        e = (\\<langle>x\\<rangle>, None)\\<rbrakk>\n       \\<Longrightarrow> j' e \\<le> capacity \\<Psi> e", "finally"], ["proof (chain)\npicking this:\n  j' e \\<le> capacity \\<Psi> e", "show ?thesis"], ["proof (prove)\nusing this:\n  j' e \\<le> capacity \\<Psi> e\n\ngoal (1 subgoal):\n 1. j' e \\<le> capacity \\<Psi> e", "."], ["proof (state)\nthis:\n  j' e \\<le> capacity \\<Psi> e\n\ngoal (3 subgoals):\n 1. \\<And>y'.\n       \\<lbrakk>0 < u y; 0 < \\<zeta>; j e \\<le> capacity \\<Psi> e;\n        e = (None, \\<langle>y'\\<rangle>); y \\<noteq> y'\\<rbrakk>\n       \\<Longrightarrow> j' e \\<le> capacity \\<Psi> e\n 2. \\<lbrakk>0 < u y; 0 < \\<zeta>; j e \\<le> capacity \\<Psi> e;\n     e = (None, None)\\<rbrakk>\n    \\<Longrightarrow> j' e \\<le> capacity \\<Psi> e\n 3. \\<And>x.\n       \\<lbrakk>0 < u y; 0 < \\<zeta>; j e \\<le> capacity \\<Psi> e;\n        e = (\\<langle>x\\<rangle>, None)\\<rbrakk>\n       \\<Longrightarrow> j' e \\<le> capacity \\<Psi> e", "qed(auto simp add: j'_def E_def \\<Psi>.flowD_outside[OF j] uy)"], ["proof (state)\nthis:\n  j' e \\<le> capacity \\<Psi> e\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Psi>; x \\<noteq> sink \\<Psi>\\<rbrakk>\n       \\<Longrightarrow> KIR j' x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Psi>; x \\<noteq> sink \\<Psi>\\<rbrakk>\n       \\<Longrightarrow> KIR j' x", "fix x'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Psi>; x \\<noteq> sink \\<Psi>\\<rbrakk>\n       \\<Longrightarrow> KIR j' x", "assume x': \"x' \\<noteq> source \\<Psi>\" \"x' \\<noteq> sink \\<Psi>\""], ["proof (state)\nthis:\n  x' \\<noteq> source \\<Psi>\n  x' \\<noteq> sink \\<Psi>\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Psi>; x \\<noteq> sink \\<Psi>\\<rbrakk>\n       \\<Longrightarrow> KIR j' x", "then"], ["proof (chain)\npicking this:\n  x' \\<noteq> source \\<Psi>\n  x' \\<noteq> sink \\<Psi>", "obtain x'' where x'': \"x' = Some x''\""], ["proof (prove)\nusing this:\n  x' \\<noteq> source \\<Psi>\n  x' \\<noteq> sink \\<Psi>\n\ngoal (1 subgoal):\n 1. (\\<And>x''.\n        x' = \\<langle>x''\\<rangle> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  x' = \\<langle>x''\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Psi>; x \\<noteq> sink \\<Psi>\\<rbrakk>\n       \\<Longrightarrow> KIR j' x", "have \"d_OUT ?j' x' = \\<zeta> * card (set [(x'', y) \\<leftarrow> E. x'' = x']) + d_OUT j x'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT (\\<lambda>e. (if e \\<in> set E then \\<zeta> else 0) + j e) x' =\n    \\<zeta> * of_nat (card (set (filter (\\<lambda>(x'', y). x'' = x') E))) +\n    d_OUT j x'", "by(rule OUT_j')"], ["proof (state)\nthis:\n  d_OUT (\\<lambda>e. (if e \\<in> set E then \\<zeta> else 0) + j e) x' =\n  \\<zeta> * of_nat (card (set (filter (\\<lambda>(x'', y). x'' = x') E))) +\n  d_OUT j x'\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Psi>; x \\<noteq> sink \\<Psi>\\<rbrakk>\n       \\<Longrightarrow> KIR j' x", "also"], ["proof (state)\nthis:\n  d_OUT (\\<lambda>e. (if e \\<in> set E then \\<zeta> else 0) + j e) x' =\n  \\<zeta> * of_nat (card (set (filter (\\<lambda>(x'', y). x'' = x') E))) +\n  d_OUT j x'\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Psi>; x \\<noteq> sink \\<Psi>\\<rbrakk>\n       \\<Longrightarrow> KIR j' x", "have \"card (set [(x'', y) \\<leftarrow> E. x'' = x']) = card (set [(y, x'') \\<leftarrow> E. x'' = x'])\" (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. card (set (filter (\\<lambda>(x'', y). x'' = x') E)) =\n    card (set (filter (\\<lambda>(y, x''). x'' = x') E))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. card (set (filter (\\<lambda>(x'', y). x'' = x') E)) =\n    card (set (filter (\\<lambda>(y, x''). x'' = x') E))", "have \"?lhs = length [(x'', y) \\<leftarrow> E. x'' = x']\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (set (filter (\\<lambda>(x'', y). x'' = x') E)) =\n    length (filter (\\<lambda>(x'', y). x'' = x') E)", "using distinct"], ["proof (prove)\nusing this:\n  distinct (y # q)\n\ngoal (1 subgoal):\n 1. card (set (filter (\\<lambda>(x'', y). x'' = x') E)) =\n    length (filter (\\<lambda>(x'', y). x'' = x') E)", "by(subst distinct_card)(auto simp add: E_def filter_map distinct_map inj_map_prod' distinct_zipI1)"], ["proof (state)\nthis:\n  card (set (filter (\\<lambda>(x'', y). x'' = x') E)) =\n  length (filter (\\<lambda>(x'', y). x'' = x') E)\n\ngoal (1 subgoal):\n 1. card (set (filter (\\<lambda>(x'', y). x'' = x') E)) =\n    card (set (filter (\\<lambda>(y, x''). x'' = x') E))", "also"], ["proof (state)\nthis:\n  card (set (filter (\\<lambda>(x'', y). x'' = x') E)) =\n  length (filter (\\<lambda>(x'', y). x'' = x') E)\n\ngoal (1 subgoal):\n 1. card (set (filter (\\<lambda>(x'', y). x'' = x') E)) =\n    card (set (filter (\\<lambda>(y, x''). x'' = x') E))", "have \"\\<dots> = length [x''' \\<leftarrow> map fst ?E. x''' = x'']\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (filter (\\<lambda>(x'', y). x'' = x') E) =\n    length (filter (\\<lambda>x'''. x''' = x'') (map fst (zip (y # q) q)))", "by(simp add: E_def x'' split_beta cong: filter_cong)"], ["proof (state)\nthis:\n  length (filter (\\<lambda>(x'', y). x'' = x') E) =\n  length (filter (\\<lambda>x'''. x''' = x'') (map fst (zip (y # q) q)))\n\ngoal (1 subgoal):\n 1. card (set (filter (\\<lambda>(x'', y). x'' = x') E)) =\n    card (set (filter (\\<lambda>(y, x''). x'' = x') E))", "also"], ["proof (state)\nthis:\n  length (filter (\\<lambda>(x'', y). x'' = x') E) =\n  length (filter (\\<lambda>x'''. x''' = x'') (map fst (zip (y # q) q)))\n\ngoal (1 subgoal):\n 1. card (set (filter (\\<lambda>(x'', y). x'' = x') E)) =\n    card (set (filter (\\<lambda>(y, x''). x'' = x') E))", "have \"map fst ?E = butlast (y # q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map fst (zip (y # q) q) = butlast (y # q)", "by(induction q arbitrary: y) simp_all"], ["proof (state)\nthis:\n  map fst (zip (y # q) q) = butlast (y # q)\n\ngoal (1 subgoal):\n 1. card (set (filter (\\<lambda>(x'', y). x'' = x') E)) =\n    card (set (filter (\\<lambda>(y, x''). x'' = x') E))", "also"], ["proof (state)\nthis:\n  map fst (zip (y # q) q) = butlast (y # q)\n\ngoal (1 subgoal):\n 1. card (set (filter (\\<lambda>(x'', y). x'' = x') E)) =\n    card (set (filter (\\<lambda>(y, x''). x'' = x') E))", "have \"[x''' \\<leftarrow> butlast (y # q). x''' = x''] = [x''' \\<leftarrow> y # q. x''' = x'']\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filter (\\<lambda>x'''. x''' = x'') (butlast (y # q)) =\n    filter (\\<lambda>x'''. x''' = x'') (y # q)", "using q_Nil rtrancl_path_last[OF q q_Nil] x' x''"], ["proof (prove)\nusing this:\n  q \\<noteq> []\n  last q = a\n  x' \\<noteq> source \\<Psi>\n  x' \\<noteq> sink \\<Psi>\n  x' = \\<langle>x''\\<rangle>\n\ngoal (1 subgoal):\n 1. filter (\\<lambda>x'''. x''' = x'') (butlast (y # q)) =\n    filter (\\<lambda>x'''. x''' = x'') (y # q)", "by(cases q rule: rev_cases) simp_all"], ["proof (state)\nthis:\n  filter (\\<lambda>x'''. x''' = x'') (butlast (y # q)) =\n  filter (\\<lambda>x'''. x''' = x'') (y # q)\n\ngoal (1 subgoal):\n 1. card (set (filter (\\<lambda>(x'', y). x'' = x') E)) =\n    card (set (filter (\\<lambda>(y, x''). x'' = x') E))", "also"], ["proof (state)\nthis:\n  filter (\\<lambda>x'''. x''' = x'') (butlast (y # q)) =\n  filter (\\<lambda>x'''. x''' = x'') (y # q)\n\ngoal (1 subgoal):\n 1. card (set (filter (\\<lambda>(x'', y). x'' = x') E)) =\n    card (set (filter (\\<lambda>(y, x''). x'' = x') E))", "have \"q = map snd ?E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q = map snd (zip (y # q) q)", "by(induction q arbitrary: y) auto"], ["proof (state)\nthis:\n  q = map snd (zip (y # q) q)\n\ngoal (1 subgoal):\n 1. card (set (filter (\\<lambda>(x'', y). x'' = x') E)) =\n    card (set (filter (\\<lambda>(y, x''). x'' = x') E))", "also"], ["proof (state)\nthis:\n  q = map snd (zip (y # q) q)\n\ngoal (1 subgoal):\n 1. card (set (filter (\\<lambda>(x'', y). x'' = x') E)) =\n    card (set (filter (\\<lambda>(y, x''). x'' = x') E))", "have \"length [x''' \\<leftarrow> y # \\<dots>. x''' = x''] = length [x'' \\<leftarrow> map snd E. x'' = x']\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length\n     (filter (\\<lambda>x'''. x''' = x'') (y # map snd (zip (y # q) q))) =\n    length (filter (\\<lambda>x''. x'' = x') (map snd E))", "using x''"], ["proof (prove)\nusing this:\n  x' = \\<langle>x''\\<rangle>\n\ngoal (1 subgoal):\n 1. length\n     (filter (\\<lambda>x'''. x''' = x'') (y # map snd (zip (y # q) q))) =\n    length (filter (\\<lambda>x''. x'' = x') (map snd E))", "by(simp add: E_def cong: filter_cong)"], ["proof (state)\nthis:\n  length\n   (filter (\\<lambda>x'''. x''' = x'') (y # map snd (zip (y # q) q))) =\n  length (filter (\\<lambda>x''. x'' = x') (map snd E))\n\ngoal (1 subgoal):\n 1. card (set (filter (\\<lambda>(x'', y). x'' = x') E)) =\n    card (set (filter (\\<lambda>(y, x''). x'' = x') E))", "also"], ["proof (state)\nthis:\n  length\n   (filter (\\<lambda>x'''. x''' = x'') (y # map snd (zip (y # q) q))) =\n  length (filter (\\<lambda>x''. x'' = x') (map snd E))\n\ngoal (1 subgoal):\n 1. card (set (filter (\\<lambda>(x'', y). x'' = x') E)) =\n    card (set (filter (\\<lambda>(y, x''). x'' = x') E))", "have \"\\<dots> = length [(y, x'') \\<leftarrow> E. x'' = x']\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (filter (\\<lambda>x''. x'' = x') (map snd E)) =\n    length (filter (\\<lambda>(y, x''). x'' = x') E)", "by(simp cong: filter_cong add: split_beta)"], ["proof (state)\nthis:\n  length (filter (\\<lambda>x''. x'' = x') (map snd E)) =\n  length (filter (\\<lambda>(y, x''). x'' = x') E)\n\ngoal (1 subgoal):\n 1. card (set (filter (\\<lambda>(x'', y). x'' = x') E)) =\n    card (set (filter (\\<lambda>(y, x''). x'' = x') E))", "also"], ["proof (state)\nthis:\n  length (filter (\\<lambda>x''. x'' = x') (map snd E)) =\n  length (filter (\\<lambda>(y, x''). x'' = x') E)\n\ngoal (1 subgoal):\n 1. card (set (filter (\\<lambda>(x'', y). x'' = x') E)) =\n    card (set (filter (\\<lambda>(y, x''). x'' = x') E))", "have \"\\<dots> = ?rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (filter (\\<lambda>(y, x''). x'' = x') E) =\n    card (set (filter (\\<lambda>(y, x''). x'' = x') E))", "using distinct"], ["proof (prove)\nusing this:\n  distinct (y # q)\n\ngoal (1 subgoal):\n 1. length (filter (\\<lambda>(y, x''). x'' = x') E) =\n    card (set (filter (\\<lambda>(y, x''). x'' = x') E))", "by(subst distinct_card)(auto simp add: E_def filter_map distinct_map inj_map_prod' distinct_zipI1)"], ["proof (state)\nthis:\n  length (filter (\\<lambda>(y, x''). x'' = x') E) =\n  card (set (filter (\\<lambda>(y, x''). x'' = x') E))\n\ngoal (1 subgoal):\n 1. card (set (filter (\\<lambda>(x'', y). x'' = x') E)) =\n    card (set (filter (\\<lambda>(y, x''). x'' = x') E))", "finally"], ["proof (chain)\npicking this:\n  card\n   (set (filter (\\<lambda>a. case a of (x'', y) \\<Rightarrow> x'' = x')\n          E)) =\n  card (set (filter (\\<lambda>(y, x''). x'' = x') E))", "show ?thesis"], ["proof (prove)\nusing this:\n  card\n   (set (filter (\\<lambda>a. case a of (x'', y) \\<Rightarrow> x'' = x')\n          E)) =\n  card (set (filter (\\<lambda>(y, x''). x'' = x') E))\n\ngoal (1 subgoal):\n 1. card (set (filter (\\<lambda>(x'', y). x'' = x') E)) =\n    card (set (filter (\\<lambda>(y, x''). x'' = x') E))", "."], ["proof (state)\nthis:\n  card (set (filter (\\<lambda>(x'', y). x'' = x') E)) =\n  card (set (filter (\\<lambda>(y, x''). x'' = x') E))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  card (set (filter (\\<lambda>(x'', y). x'' = x') E)) =\n  card (set (filter (\\<lambda>(y, x''). x'' = x') E))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Psi>; x \\<noteq> sink \\<Psi>\\<rbrakk>\n       \\<Longrightarrow> KIR j' x", "also"], ["proof (state)\nthis:\n  card (set (filter (\\<lambda>(x'', y). x'' = x') E)) =\n  card (set (filter (\\<lambda>(y, x''). x'' = x') E))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Psi>; x \\<noteq> sink \\<Psi>\\<rbrakk>\n       \\<Longrightarrow> KIR j' x", "have \"\\<zeta> * \\<dots> + d_OUT j x' =  d_IN ?j' x'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<zeta> * of_nat (card (set (filter (\\<lambda>(y, x''). x'' = x') E))) +\n    d_OUT j x' =\n    d_IN (\\<lambda>e. (if e \\<in> set E then \\<zeta> else 0) + j e) x'", "unfolding flowD_KIR[OF j x']"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<zeta> * of_nat (card (set (filter (\\<lambda>(y, x''). x'' = x') E))) +\n    d_IN j x' =\n    d_IN (\\<lambda>e. (if e \\<in> set E then \\<zeta> else 0) + j e) x'", "by(rule IN_j'[symmetric])"], ["proof (state)\nthis:\n  \\<zeta> * of_nat (card (set (filter (\\<lambda>(y, x''). x'' = x') E))) +\n  d_OUT j x' =\n  d_IN (\\<lambda>e. (if e \\<in> set E then \\<zeta> else 0) + j e) x'\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Psi>; x \\<noteq> sink \\<Psi>\\<rbrakk>\n       \\<Longrightarrow> KIR j' x", "also"], ["proof (state)\nthis:\n  \\<zeta> * of_nat (card (set (filter (\\<lambda>(y, x''). x'' = x') E))) +\n  d_OUT j x' =\n  d_IN (\\<lambda>e. (if e \\<in> set E then \\<zeta> else 0) + j e) x'\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Psi>; x \\<noteq> sink \\<Psi>\\<rbrakk>\n       \\<Longrightarrow> KIR j' x", "have \"d_IN ?j' x' \\<noteq> \\<top>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN (\\<lambda>e. (if e \\<in> set E then \\<zeta> else 0) + j e)\n     x' \\<noteq>\n    \\<top>", "using \\<Psi>.flowD_finite_IN[OF j x'(2)] finite_\\<zeta> IN_j'[of x']"], ["proof (prove)\nusing this:\n  d_IN j x' \\<noteq> \\<top>\n  \\<zeta> < \\<top>\n  d_IN (\\<lambda>e. (if e \\<in> set E then \\<zeta> else 0) + j e) x' =\n  \\<zeta> * of_nat (card (set (filter (\\<lambda>(y, x''). x'' = x') E))) +\n  d_IN j x'\n\ngoal (1 subgoal):\n 1. d_IN (\\<lambda>e. (if e \\<in> set E then \\<zeta> else 0) + j e)\n     x' \\<noteq>\n    \\<top>", "by (auto simp: top_add ennreal_mult_eq_top_iff)"], ["proof (state)\nthis:\n  d_IN (\\<lambda>e. (if e \\<in> set E then \\<zeta> else 0) + j e)\n   x' \\<noteq>\n  \\<top>\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Psi>; x \\<noteq> sink \\<Psi>\\<rbrakk>\n       \\<Longrightarrow> KIR j' x", "ultimately"], ["proof (chain)\npicking this:\n  KIR (\\<lambda>e. (if e \\<in> set E then \\<zeta> else 0) + j e) x'\n  d_IN (\\<lambda>e. (if e \\<in> set E then \\<zeta> else 0) + j e)\n   x' \\<noteq>\n  \\<top>", "show \"KIR j' x'\""], ["proof (prove)\nusing this:\n  KIR (\\<lambda>e. (if e \\<in> set E then \\<zeta> else 0) + j e) x'\n  d_IN (\\<lambda>e. (if e \\<in> set E then \\<zeta> else 0) + j e)\n   x' \\<noteq>\n  \\<top>\n\ngoal (1 subgoal):\n 1. KIR j' x'", "unfolding j'_def"], ["proof (prove)\nusing this:\n  KIR (\\<lambda>e. (if e \\<in> set E then \\<zeta> else 0) + j e) x'\n  d_IN (\\<lambda>e. (if e \\<in> set E then \\<zeta> else 0) + j e)\n   x' \\<noteq>\n  \\<top>\n\ngoal (1 subgoal):\n 1. KIR (cleanup (\\<lambda>e. (if e \\<in> set E then \\<zeta> else 0) + j e))\n     x'", "by(rule KIR_cleanup)"], ["proof (state)\nthis:\n  KIR j' x'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  flow \\<Psi> j'\n\ngoal (1 subgoal):\n 1. j (None, \\<langle>y\\<rangle>) \\<noteq> u y \\<Longrightarrow> False", "hence \"value_flow \\<Psi> j' \\<le> \\<alpha>\""], ["proof (prove)\nusing this:\n  flow \\<Psi> j'\n\ngoal (1 subgoal):\n 1. value_flow \\<Psi> j' \\<le> \\<alpha>", "unfolding \\<alpha>_def"], ["proof (prove)\nusing this:\n  flow \\<Psi> j'\n\ngoal (1 subgoal):\n 1. value_flow \\<Psi> j'\n    \\<le> \\<Squnion> (value_flow \\<Psi> ` Collect (flow \\<Psi>))", "by(auto intro: SUP_upper)"], ["proof (state)\nthis:\n  value_flow \\<Psi> j' \\<le> \\<alpha>\n\ngoal (1 subgoal):\n 1. j (None, \\<langle>y\\<rangle>) \\<noteq> u y \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  value_flow \\<Psi> j' \\<le> \\<alpha>\n\ngoal (1 subgoal):\n 1. j (None, \\<langle>y\\<rangle>) \\<noteq> u y \\<Longrightarrow> False", "have \"value_flow \\<Psi> j' > value_flow \\<Psi> j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. value_flow \\<Psi> j < value_flow \\<Psi> j'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. value_flow \\<Psi> j < value_flow \\<Psi> j'", "have \"value_flow \\<Psi> j + 0 < value_flow \\<Psi> j + \\<zeta> * 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. value_flow \\<Psi> j + 0 < value_flow \\<Psi> j + \\<zeta> * 1", "using \\<zeta>_pos value_j finite_flow"], ["proof (prove)\nusing this:\n  0 < \\<zeta>\n  value_flow \\<Psi> j = \\<alpha>\n  \\<alpha> \\<noteq> \\<top>\n\ngoal (1 subgoal):\n 1. value_flow \\<Psi> j + 0 < value_flow \\<Psi> j + \\<zeta> * 1", "by simp"], ["proof (state)\nthis:\n  value_flow \\<Psi> j + 0 < value_flow \\<Psi> j + \\<zeta> * 1\n\ngoal (1 subgoal):\n 1. value_flow \\<Psi> j < value_flow \\<Psi> j'", "also"], ["proof (state)\nthis:\n  value_flow \\<Psi> j + 0 < value_flow \\<Psi> j + \\<zeta> * 1\n\ngoal (1 subgoal):\n 1. value_flow \\<Psi> j < value_flow \\<Psi> j'", "have \"[(x', y') \\<leftarrow> E. x' = None] = [(None, Some y)]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filter (\\<lambda>(x', y'). x' = None) E = [(None, \\<langle>y\\<rangle>)]", "using q_Nil"], ["proof (prove)\nusing this:\n  q \\<noteq> []\n\ngoal (1 subgoal):\n 1. filter (\\<lambda>(x', y'). x' = None) E = [(None, \\<langle>y\\<rangle>)]", "by(cases q)(auto simp add: E_def filter_map cong: filter_cong split_beta)"], ["proof (state)\nthis:\n  filter (\\<lambda>(x', y'). x' = None) E = [(None, \\<langle>y\\<rangle>)]\n\ngoal (1 subgoal):\n 1. value_flow \\<Psi> j < value_flow \\<Psi> j'", "hence \"\\<zeta> * 1 \\<le> \\<zeta> * card (set [(x', y') \\<leftarrow> E. x' = None])\""], ["proof (prove)\nusing this:\n  filter (\\<lambda>(x', y'). x' = None) E = [(None, \\<langle>y\\<rangle>)]\n\ngoal (1 subgoal):\n 1. \\<zeta> * 1\n    \\<le> \\<zeta> *\n          of_nat (card (set (filter (\\<lambda>(x', y'). x' = None) E)))", "using \\<zeta>_pos"], ["proof (prove)\nusing this:\n  filter (\\<lambda>(x', y'). x' = None) E = [(None, \\<langle>y\\<rangle>)]\n  0 < \\<zeta>\n\ngoal (1 subgoal):\n 1. \\<zeta> * 1\n    \\<le> \\<zeta> *\n          of_nat (card (set (filter (\\<lambda>(x', y'). x' = None) E)))", "by(intro mult_left_mono)(auto simp add: E_def real_of_nat_ge_one_iff neq_Nil_conv card.insert_remove)"], ["proof (state)\nthis:\n  \\<zeta> * 1\n  \\<le> \\<zeta> *\n        of_nat (card (set (filter (\\<lambda>(x', y'). x' = None) E)))\n\ngoal (1 subgoal):\n 1. value_flow \\<Psi> j < value_flow \\<Psi> j'", "also"], ["proof (state)\nthis:\n  \\<zeta> * 1\n  \\<le> \\<zeta> *\n        of_nat (card (set (filter (\\<lambda>(x', y'). x' = None) E)))\n\ngoal (1 subgoal):\n 1. value_flow \\<Psi> j < value_flow \\<Psi> j'", "have \"value_flow \\<Psi> j + \\<dots> = value_flow \\<Psi> ?j'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. value_flow \\<Psi> j +\n    \\<zeta> *\n    of_nat (card (set (filter (\\<lambda>(x', y'). x' = None) E))) =\n    value_flow \\<Psi>\n     (\\<lambda>e. (if e \\<in> set E then \\<zeta> else 0) + j e)", "using OUT_j'"], ["proof (prove)\nusing this:\n  d_OUT (\\<lambda>e. (if e \\<in> set E then \\<zeta> else 0) + j e) ?x' =\n  \\<zeta> * of_nat (card (set (filter (\\<lambda>(x'', y). x'' = ?x') E))) +\n  d_OUT j ?x'\n\ngoal (1 subgoal):\n 1. value_flow \\<Psi> j +\n    \\<zeta> *\n    of_nat (card (set (filter (\\<lambda>(x', y'). x' = None) E))) =\n    value_flow \\<Psi>\n     (\\<lambda>e. (if e \\<in> set E then \\<zeta> else 0) + j e)", "by(simp add: add.commute)"], ["proof (state)\nthis:\n  value_flow \\<Psi> j +\n  \\<zeta> * of_nat (card (set (filter (\\<lambda>(x', y'). x' = None) E))) =\n  value_flow \\<Psi>\n   (\\<lambda>e. (if e \\<in> set E then \\<zeta> else 0) + j e)\n\ngoal (1 subgoal):\n 1. value_flow \\<Psi> j < value_flow \\<Psi> j'", "also"], ["proof (state)\nthis:\n  value_flow \\<Psi> j +\n  \\<zeta> * of_nat (card (set (filter (\\<lambda>(x', y'). x' = None) E))) =\n  value_flow \\<Psi>\n   (\\<lambda>e. (if e \\<in> set E then \\<zeta> else 0) + j e)\n\ngoal (1 subgoal):\n 1. value_flow \\<Psi> j < value_flow \\<Psi> j'", "have \"\\<dots> = value_flow \\<Psi> j'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. value_flow \\<Psi>\n     (\\<lambda>e. (if e \\<in> set E then \\<zeta> else 0) + j e) =\n    value_flow \\<Psi> j'", "unfolding j'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. value_flow \\<Psi>\n     (\\<lambda>e. (if e \\<in> set E then \\<zeta> else 0) + j e) =\n    value_flow \\<Psi>\n     (cleanup (\\<lambda>e. (if e \\<in> set E then \\<zeta> else 0) + j e))", "by(subst value_flow_cleanup)(auto simp add: E_def \\<Psi>.flowD_outside[OF j])"], ["proof (state)\nthis:\n  value_flow \\<Psi>\n   (\\<lambda>e. (if e \\<in> set E then \\<zeta> else 0) + j e) =\n  value_flow \\<Psi> j'\n\ngoal (1 subgoal):\n 1. value_flow \\<Psi> j < value_flow \\<Psi> j'", "finally"], ["proof (chain)\npicking this:\n  (\\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      value_flow \\<Psi> j + x\n      \\<le> value_flow \\<Psi> j + y) \\<Longrightarrow>\n  value_flow \\<Psi> j + 0 < value_flow \\<Psi> j'", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      value_flow \\<Psi> j + x\n      \\<le> value_flow \\<Psi> j + y) \\<Longrightarrow>\n  value_flow \\<Psi> j + 0 < value_flow \\<Psi> j'\n\ngoal (1 subgoal):\n 1. value_flow \\<Psi> j < value_flow \\<Psi> j'", "by(simp add: add_left_mono)"], ["proof (state)\nthis:\n  value_flow \\<Psi> j < value_flow \\<Psi> j'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  value_flow \\<Psi> j < value_flow \\<Psi> j'\n\ngoal (1 subgoal):\n 1. j (None, \\<langle>y\\<rangle>) \\<noteq> u y \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  value_flow \\<Psi> j' \\<le> \\<alpha>\n  value_flow \\<Psi> j < value_flow \\<Psi> j'", "show False"], ["proof (prove)\nusing this:\n  value_flow \\<Psi> j' \\<le> \\<alpha>\n  value_flow \\<Psi> j < value_flow \\<Psi> j'\n\ngoal (1 subgoal):\n 1. False", "using finite_flow \\<zeta>_pos value_j"], ["proof (prove)\nusing this:\n  value_flow \\<Psi> j' \\<le> \\<alpha>\n  value_flow \\<Psi> j < value_flow \\<Psi> j'\n  \\<alpha> \\<noteq> \\<top>\n  0 < \\<zeta>\n  value_flow \\<Psi> j = \\<alpha>\n\ngoal (1 subgoal):\n 1. False", "by(cases \"value_flow \\<Psi> j\" \\<zeta> rule: ennreal2_cases) simp_all"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  reachable ?y \\<Longrightarrow> j (None, \\<langle>?y\\<rangle>) = u ?y\n\ngoal (1 subgoal):\n 1. hindered \\<Gamma>", "have sep_h: \"y \\<in> TER h\" if reach: \"reachable y\" and y: \"y \\<in> B \\<Gamma>\" and TER: \"y \\<in> ?TER f\" for y"], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<in> TER h", "proof(rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. y \\<notin> TER h \\<Longrightarrow> False", "assume y': \"y \\<notin> TER h\""], ["proof (state)\nthis:\n  y \\<notin> TER h\n\ngoal (1 subgoal):\n 1. y \\<notin> TER h \\<Longrightarrow> False", "from y a(1) disjoint"], ["proof (chain)\npicking this:\n  y \\<in> B \\<Gamma>\n  a \\<in> A \\<Gamma>\n  A \\<Gamma> \\<inter> B \\<Gamma> = {}", "have yna: \"y \\<noteq> a\""], ["proof (prove)\nusing this:\n  y \\<in> B \\<Gamma>\n  a \\<in> A \\<Gamma>\n  A \\<Gamma> \\<inter> B \\<Gamma> = {}\n\ngoal (1 subgoal):\n 1. y \\<noteq> a", "by auto"], ["proof (state)\nthis:\n  y \\<noteq> a\n\ngoal (1 subgoal):\n 1. y \\<notin> TER h \\<Longrightarrow> False", "from reach"], ["proof (chain)\npicking this:\n  reachable y", "obtain p' where \"path G y p' a\""], ["proof (prove)\nusing this:\n  reachable y\n\ngoal (1 subgoal):\n 1. (\\<And>p'. path G y p' a \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding reachable_alt_def"], ["proof (prove)\nusing this:\n  \\<exists>p. path G y p a\n\ngoal (1 subgoal):\n 1. (\\<And>p'. path G y p' a \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  path G y p' a\n\ngoal (1 subgoal):\n 1. y \\<notin> TER h \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  path G y p' a", "obtain p' where p': \"path G y p' a\" and distinct: \"distinct (y # p')\""], ["proof (prove)\nusing this:\n  path G y p' a\n\ngoal (1 subgoal):\n 1. (\\<And>p'.\n        \\<lbrakk>path G y p' a; distinct (y # p')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(rule rtrancl_path_distinct)"], ["proof (state)\nthis:\n  path G y p' a\n  distinct (y # p')\n\ngoal (1 subgoal):\n 1. y \\<notin> TER h \\<Longrightarrow> False", "have SINK: \"y \\<in> SINK h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<in> SINK h", "using y disjoint"], ["proof (prove)\nusing this:\n  y \\<in> B \\<Gamma>\n  A \\<Gamma> \\<inter> B \\<Gamma> = {}\n\ngoal (1 subgoal):\n 1. y \\<in> SINK h", "by(auto simp add: SINK.simps d_OUT_def nn_integral_0_iff emeasure_count_space_eq_0 intro: currentD_outside[OF g] dest: bipartite_E)"], ["proof (state)\nthis:\n  y \\<in> SINK h\n\ngoal (1 subgoal):\n 1. y \\<notin> TER h \\<Longrightarrow> False", "have hg: \"d_IN h y = d_IN g y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN h y = d_IN g y", "using reach"], ["proof (prove)\nusing this:\n  reachable y\n\ngoal (1 subgoal):\n 1. d_IN h y = d_IN g y", "by(simp add: IN_h)"], ["proof (state)\nthis:\n  d_IN h y = d_IN g y\n\ngoal (1 subgoal):\n 1. y \\<notin> TER h \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  d_IN h y = d_IN g y\n\ngoal (1 subgoal):\n 1. y \\<notin> TER h \\<Longrightarrow> False", "have \"\\<dots> = d_IN f y + j (None, Some y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN g y = d_IN f y + j (None, \\<langle>y\\<rangle>)", "by(simp add: IN_g)"], ["proof (state)\nthis:\n  d_IN g y = d_IN f y + j (None, \\<langle>y\\<rangle>)\n\ngoal (1 subgoal):\n 1. y \\<notin> TER h \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  d_IN g y = d_IN f y + j (None, \\<langle>y\\<rangle>)\n\ngoal (1 subgoal):\n 1. y \\<notin> TER h \\<Longrightarrow> False", "have \"d_IN f y = weight \\<Gamma> y - u y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN f y = weight \\<Gamma> y - u y", "using currentD_weight_IN[OF f, of y] y disjoint TER"], ["proof (prove)\nusing this:\n  d_IN f y\n  \\<le> weight (\\<Gamma>\\<lparr>weight := weight \\<Gamma> - u\\<rparr>) y\n  y \\<in> B \\<Gamma>\n  A \\<Gamma> \\<inter> B \\<Gamma> = {}\n  y \\<in> TER\\<^bsub>\\<Gamma>\\<lparr>weight := weight \\<Gamma> - u\\<rparr>\\<^esub>\n           f\n\ngoal (1 subgoal):\n 1. d_IN f y = weight \\<Gamma> y - u y", "by(auto elim!: SAT.cases)"], ["proof (state)\nthis:\n  d_IN f y = weight \\<Gamma> y - u y\n\ngoal (1 subgoal):\n 1. y \\<notin> TER h \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  d_IN f y = weight \\<Gamma> y - u y\n\ngoal (1 subgoal):\n 1. y \\<notin> TER h \\<Longrightarrow> False", "have \"d_IN h y < weight \\<Gamma> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN h y < weight \\<Gamma> y", "using y' currentD_weight_IN[OF g, of y] y disjoint SINK"], ["proof (prove)\nusing this:\n  y \\<notin> TER h\n  d_IN g y \\<le> weight \\<Gamma> y\n  y \\<in> B \\<Gamma>\n  A \\<Gamma> \\<inter> B \\<Gamma> = {}\n  y \\<in> SINK h\n\ngoal (1 subgoal):\n 1. d_IN h y < weight \\<Gamma> y", "by(auto intro: SAT.intros)"], ["proof (state)\nthis:\n  d_IN h y < weight \\<Gamma> y\n\ngoal (1 subgoal):\n 1. y \\<notin> TER h \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  d_IN h y = weight \\<Gamma> y - u y + j (None, \\<langle>y\\<rangle>)\n  d_IN h y < weight \\<Gamma> y", "have le: \"j (None, Some y) < u y\""], ["proof (prove)\nusing this:\n  d_IN h y = weight \\<Gamma> y - u y + j (None, \\<langle>y\\<rangle>)\n  d_IN h y < weight \\<Gamma> y\n\ngoal (1 subgoal):\n 1. j (None, \\<langle>y\\<rangle>) < u y", "by(cases \"weight \\<Gamma> y\" \"u y\" \"j (None, Some y)\" rule: ennreal3_cases; cases \"u y \\<le> weight \\<Gamma> y\")\n        (auto simp: ennreal_minus ennreal_plus[symmetric] add_top ennreal_less_iff ennreal_neg simp del: ennreal_plus)"], ["proof (state)\nthis:\n  j (None, \\<langle>y\\<rangle>) < u y\n\ngoal (1 subgoal):\n 1. y \\<notin> TER h \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  j (None, \\<langle>y\\<rangle>) < u y\n\ngoal (1 subgoal):\n 1. y \\<notin> TER h \\<Longrightarrow> False", "from reach"], ["proof (chain)\npicking this:\n  reachable y", "have \"j (None, \\<langle>y\\<rangle>) = u y\""], ["proof (prove)\nusing this:\n  reachable y\n\ngoal (1 subgoal):\n 1. j (None, \\<langle>y\\<rangle>) = u y", "by(rule reachable_full)"], ["proof (state)\nthis:\n  j (None, \\<langle>y\\<rangle>) = u y\n\ngoal (1 subgoal):\n 1. y \\<notin> TER h \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  j (None, \\<langle>y\\<rangle>) < u y\n  j (None, \\<langle>y\\<rangle>) = u y", "show False"], ["proof (prove)\nusing this:\n  j (None, \\<langle>y\\<rangle>) < u y\n  j (None, \\<langle>y\\<rangle>) = u y\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>reachable ?y; ?y \\<in> B \\<Gamma>;\n   ?y \\<in> TER\\<^bsub>\\<Gamma>\\<lparr>weight := weight \\<Gamma> - u\\<rparr>\\<^esub>\n             f\\<rbrakk>\n  \\<Longrightarrow> ?y \\<in> TER h\n\ngoal (1 subgoal):\n 1. hindered \\<Gamma>", "have w': \"wave \\<Gamma> h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wave \\<Gamma> h", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. separating \\<Gamma> (TER h)\n 2. current \\<Gamma> h", "show sep: \"separating \\<Gamma> (TER h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. separating \\<Gamma> (TER h)", "proof(rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> separating \\<Gamma> (TER h) \\<Longrightarrow> False", "assume \"\\<not> ?thesis\""], ["proof (state)\nthis:\n  \\<not> separating \\<Gamma> (TER h)\n\ngoal (1 subgoal):\n 1. \\<not> separating \\<Gamma> (TER h) \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<not> separating \\<Gamma> (TER h)", "obtain x p y where x: \"x \\<in> A \\<Gamma>\" and y: \"y \\<in> B \\<Gamma>\" and p: \"path \\<Gamma> x p y\"\n        and x': \"x \\<notin> TER h\" and bypass: \"\\<And>z. z \\<in> set p \\<Longrightarrow> z \\<notin> TER h\""], ["proof (prove)\nusing this:\n  \\<not> separating \\<Gamma> (TER h)\n\ngoal (1 subgoal):\n 1. (\\<And>x y p.\n        \\<lbrakk>x \\<in> A \\<Gamma>; y \\<in> B \\<Gamma>;\n         path \\<Gamma> x p y; x \\<notin> TER h;\n         \\<And>z. z \\<in> set p \\<Longrightarrow> z \\<notin> TER h\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto simp add: separating_gen.simps)"], ["proof (state)\nthis:\n  x \\<in> A \\<Gamma>\n  y \\<in> B \\<Gamma>\n  path \\<Gamma> x p y\n  x \\<notin> TER h\n  ?z \\<in> set p \\<Longrightarrow> ?z \\<notin> TER h\n\ngoal (1 subgoal):\n 1. \\<not> separating \\<Gamma> (TER h) \\<Longrightarrow> False", "from p disjoint x y"], ["proof (chain)\npicking this:\n  path \\<Gamma> x p y\n  A \\<Gamma> \\<inter> B \\<Gamma> = {}\n  x \\<in> A \\<Gamma>\n  y \\<in> B \\<Gamma>", "have p_eq: \"p = [y]\" and edge: \"(x, y) \\<in> \\<^bold>E\""], ["proof (prove)\nusing this:\n  path \\<Gamma> x p y\n  A \\<Gamma> \\<inter> B \\<Gamma> = {}\n  x \\<in> A \\<Gamma>\n  y \\<in> B \\<Gamma>\n\ngoal (1 subgoal):\n 1. p = [y] &&& (x, y) \\<in> \\<^bold>E", "by -(erule rtrancl_path.cases, auto dest: bipartite_E)+"], ["proof (state)\nthis:\n  p = [y]\n  (x, y) \\<in> \\<^bold>E\n\ngoal (1 subgoal):\n 1. \\<not> separating \\<Gamma> (TER h) \\<Longrightarrow> False", "from p_eq bypass"], ["proof (chain)\npicking this:\n  p = [y]\n  ?z \\<in> set p \\<Longrightarrow> ?z \\<notin> TER h", "have y': \"y \\<notin> TER h\""], ["proof (prove)\nusing this:\n  p = [y]\n  ?z \\<in> set p \\<Longrightarrow> ?z \\<notin> TER h\n\ngoal (1 subgoal):\n 1. y \\<notin> TER h", "by simp"], ["proof (state)\nthis:\n  y \\<notin> TER h\n\ngoal (1 subgoal):\n 1. \\<not> separating \\<Gamma> (TER h) \\<Longrightarrow> False", "have \"reachable x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reachable x", "using x'"], ["proof (prove)\nusing this:\n  x \\<notin> TER h\n\ngoal (1 subgoal):\n 1. reachable x", "by(rule contrapos_np)(simp add: SINK.simps d_OUT_def SAT.A x)"], ["proof (state)\nthis:\n  reachable x\n\ngoal (1 subgoal):\n 1. \\<not> separating \\<Gamma> (TER h) \\<Longrightarrow> False", "hence reach: \"reachable y\""], ["proof (prove)\nusing this:\n  reachable x\n\ngoal (1 subgoal):\n 1. reachable y", "using edge"], ["proof (prove)\nusing this:\n  reachable x\n  (x, y) \\<in> \\<^bold>E\n\ngoal (1 subgoal):\n 1. reachable y", "by(rule reachable_AB)"], ["proof (state)\nthis:\n  reachable y\n\ngoal (1 subgoal):\n 1. \\<not> separating \\<Gamma> (TER h) \\<Longrightarrow> False", "have *: \"x \\<notin> \\<E>\\<^bsub>?\\<Gamma>\\<^esub> (?TER f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> \\<E>\\<^bsub>\\<Gamma>\\<lparr>weight := weight \\<Gamma> - u\\<rparr>\\<^esub>\n                (TER\\<^bsub>\\<Gamma>\\<lparr>weight := weight \\<Gamma> - u\\<rparr>\\<^esub>\n                  f)", "using x'"], ["proof (prove)\nusing this:\n  x \\<notin> TER h\n\ngoal (1 subgoal):\n 1. x \\<notin> \\<E>\\<^bsub>\\<Gamma>\\<lparr>weight := weight \\<Gamma> - u\\<rparr>\\<^esub>\n                (TER\\<^bsub>\\<Gamma>\\<lparr>weight := weight \\<Gamma> - u\\<rparr>\\<^esub>\n                  f)", "proof(rule contrapos_nn)"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<in> \\<E>\\<^bsub>\\<Gamma>\\<lparr>weight := weight \\<Gamma> - u\\<rparr>\\<^esub>\n             (TER\\<^bsub>\\<Gamma>\\<lparr>weight := weight \\<Gamma> - u\\<rparr>\\<^esub>\n               f) \\<Longrightarrow>\n    x \\<in> TER h", "assume *: \"x \\<in> \\<E>\\<^bsub>?\\<Gamma>\\<^esub> (?TER f)\""], ["proof (state)\nthis:\n  x \\<in> \\<E>\\<^bsub>\\<Gamma>\\<lparr>weight := weight \\<Gamma> - u\\<rparr>\\<^esub>\n           (TER\\<^bsub>\\<Gamma>\\<lparr>weight := weight \\<Gamma> - u\\<rparr>\\<^esub>\n             f)\n\ngoal (1 subgoal):\n 1. x \\<in> \\<E>\\<^bsub>\\<Gamma>\\<lparr>weight := weight \\<Gamma> - u\\<rparr>\\<^esub>\n             (TER\\<^bsub>\\<Gamma>\\<lparr>weight := weight \\<Gamma> - u\\<rparr>\\<^esub>\n               f) \\<Longrightarrow>\n    x \\<in> TER h", "have \"d_OUT h x \\<le> d_OUT g x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT h x \\<le> d_OUT g x", "using h_le_g"], ["proof (prove)\nusing this:\n  h ?e \\<le> g ?e\n\ngoal (1 subgoal):\n 1. d_OUT h x \\<le> d_OUT g x", "by(rule d_OUT_mono)"], ["proof (state)\nthis:\n  d_OUT h x \\<le> d_OUT g x\n\ngoal (1 subgoal):\n 1. x \\<in> \\<E>\\<^bsub>\\<Gamma>\\<lparr>weight := weight \\<Gamma> - u\\<rparr>\\<^esub>\n             (TER\\<^bsub>\\<Gamma>\\<lparr>weight := weight \\<Gamma> - u\\<rparr>\\<^esub>\n               f) \\<Longrightarrow>\n    x \\<in> TER h", "also"], ["proof (state)\nthis:\n  d_OUT h x \\<le> d_OUT g x\n\ngoal (1 subgoal):\n 1. x \\<in> \\<E>\\<^bsub>\\<Gamma>\\<lparr>weight := weight \\<Gamma> - u\\<rparr>\\<^esub>\n             (TER\\<^bsub>\\<Gamma>\\<lparr>weight := weight \\<Gamma> - u\\<rparr>\\<^esub>\n               f) \\<Longrightarrow>\n    x \\<in> TER h", "from *"], ["proof (chain)\npicking this:\n  x \\<in> \\<E>\\<^bsub>\\<Gamma>\\<lparr>weight := weight \\<Gamma> - u\\<rparr>\\<^esub>\n           (TER\\<^bsub>\\<Gamma>\\<lparr>weight := weight \\<Gamma> - u\\<rparr>\\<^esub>\n             f)", "have \"x \\<noteq> a\""], ["proof (prove)\nusing this:\n  x \\<in> \\<E>\\<^bsub>\\<Gamma>\\<lparr>weight := weight \\<Gamma> - u\\<rparr>\\<^esub>\n           (TER\\<^bsub>\\<Gamma>\\<lparr>weight := weight \\<Gamma> - u\\<rparr>\\<^esub>\n             f)\n\ngoal (1 subgoal):\n 1. x \\<noteq> a", "using a"], ["proof (prove)\nusing this:\n  x \\<in> \\<E>\\<^bsub>\\<Gamma>\\<lparr>weight := weight \\<Gamma> - u\\<rparr>\\<^esub>\n           (TER\\<^bsub>\\<Gamma>\\<lparr>weight := weight \\<Gamma> - u\\<rparr>\\<^esub>\n             f)\n  a \\<in> A \\<Gamma>\n  a \\<notin> \\<E>\\<^bsub>\\<Gamma>\\<lparr>weight := weight \\<Gamma> - u\\<rparr>\\<^esub>\n              (TER\\<^bsub>\\<Gamma>\\<lparr>weight := weight \\<Gamma> - u\\<rparr>\\<^esub>\n                f)\n\ngoal (1 subgoal):\n 1. x \\<noteq> a", "by auto"], ["proof (state)\nthis:\n  x \\<noteq> a\n\ngoal (1 subgoal):\n 1. x \\<in> \\<E>\\<^bsub>\\<Gamma>\\<lparr>weight := weight \\<Gamma> - u\\<rparr>\\<^esub>\n             (TER\\<^bsub>\\<Gamma>\\<lparr>weight := weight \\<Gamma> - u\\<rparr>\\<^esub>\n               f) \\<Longrightarrow>\n    x \\<in> TER h", "then"], ["proof (chain)\npicking this:\n  x \\<noteq> a", "have \"d_OUT j (Some x) = d_IN j (Some x)\""], ["proof (prove)\nusing this:\n  x \\<noteq> a\n\ngoal (1 subgoal):\n 1. KIR j \\<langle>x\\<rangle>", "by(auto intro: flowD_KIR[OF j])"], ["proof (state)\nthis:\n  KIR j \\<langle>x\\<rangle>\n\ngoal (1 subgoal):\n 1. x \\<in> \\<E>\\<^bsub>\\<Gamma>\\<lparr>weight := weight \\<Gamma> - u\\<rparr>\\<^esub>\n             (TER\\<^bsub>\\<Gamma>\\<lparr>weight := weight \\<Gamma> - u\\<rparr>\\<^esub>\n               f) \\<Longrightarrow>\n    x \\<in> TER h", "hence \"d_OUT g x \\<le> d_OUT f x\""], ["proof (prove)\nusing this:\n  KIR j \\<langle>x\\<rangle>\n\ngoal (1 subgoal):\n 1. d_OUT g x \\<le> d_OUT f x", "using OUT_g_A[OF x] IN_j[of \"Some x\"] finite_flow"], ["proof (prove)\nusing this:\n  KIR j \\<langle>x\\<rangle>\n  d_OUT g x =\n  d_OUT f x + d_IN j \\<langle>x\\<rangle> - d_OUT j \\<langle>x\\<rangle>\n  d_IN j \\<langle>x\\<rangle> \\<le> \\<alpha>\n  \\<alpha> \\<noteq> \\<top>\n\ngoal (1 subgoal):\n 1. d_OUT g x \\<le> d_OUT f x", "by(auto split: if_split_asm)"], ["proof (state)\nthis:\n  d_OUT g x \\<le> d_OUT f x\n\ngoal (1 subgoal):\n 1. x \\<in> \\<E>\\<^bsub>\\<Gamma>\\<lparr>weight := weight \\<Gamma> - u\\<rparr>\\<^esub>\n             (TER\\<^bsub>\\<Gamma>\\<lparr>weight := weight \\<Gamma> - u\\<rparr>\\<^esub>\n               f) \\<Longrightarrow>\n    x \\<in> TER h", "also"], ["proof (state)\nthis:\n  d_OUT g x \\<le> d_OUT f x\n\ngoal (1 subgoal):\n 1. x \\<in> \\<E>\\<^bsub>\\<Gamma>\\<lparr>weight := weight \\<Gamma> - u\\<rparr>\\<^esub>\n             (TER\\<^bsub>\\<Gamma>\\<lparr>weight := weight \\<Gamma> - u\\<rparr>\\<^esub>\n               f) \\<Longrightarrow>\n    x \\<in> TER h", "have \"\\<dots> = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT f x = 0", "using *"], ["proof (prove)\nusing this:\n  x \\<in> \\<E>\\<^bsub>\\<Gamma>\\<lparr>weight := weight \\<Gamma> - u\\<rparr>\\<^esub>\n           (TER\\<^bsub>\\<Gamma>\\<lparr>weight := weight \\<Gamma> - u\\<rparr>\\<^esub>\n             f)\n\ngoal (1 subgoal):\n 1. d_OUT f x = 0", "by(auto elim: SINK.cases)"], ["proof (state)\nthis:\n  d_OUT f x = 0\n\ngoal (1 subgoal):\n 1. x \\<in> \\<E>\\<^bsub>\\<Gamma>\\<lparr>weight := weight \\<Gamma> - u\\<rparr>\\<^esub>\n             (TER\\<^bsub>\\<Gamma>\\<lparr>weight := weight \\<Gamma> - u\\<rparr>\\<^esub>\n               f) \\<Longrightarrow>\n    x \\<in> TER h", "finally"], ["proof (chain)\npicking this:\n  d_OUT h x \\<le> 0", "have \"x \\<in> SINK h\""], ["proof (prove)\nusing this:\n  d_OUT h x \\<le> 0\n\ngoal (1 subgoal):\n 1. x \\<in> SINK h", "by(simp add: SINK.simps)"], ["proof (state)\nthis:\n  x \\<in> SINK h\n\ngoal (1 subgoal):\n 1. x \\<in> \\<E>\\<^bsub>\\<Gamma>\\<lparr>weight := weight \\<Gamma> - u\\<rparr>\\<^esub>\n             (TER\\<^bsub>\\<Gamma>\\<lparr>weight := weight \\<Gamma> - u\\<rparr>\\<^esub>\n               f) \\<Longrightarrow>\n    x \\<in> TER h", "with x"], ["proof (chain)\npicking this:\n  x \\<in> A \\<Gamma>\n  x \\<in> SINK h", "show \"x \\<in> TER h\""], ["proof (prove)\nusing this:\n  x \\<in> A \\<Gamma>\n  x \\<in> SINK h\n\ngoal (1 subgoal):\n 1. x \\<in> TER h", "by(simp add: SAT.A)"], ["proof (state)\nthis:\n  x \\<in> TER h\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x \\<notin> \\<E>\\<^bsub>\\<Gamma>\\<lparr>weight := weight \\<Gamma> - u\\<rparr>\\<^esub>\n              (TER\\<^bsub>\\<Gamma>\\<lparr>weight := weight \\<Gamma> - u\\<rparr>\\<^esub>\n                f)\n\ngoal (1 subgoal):\n 1. \\<not> separating \\<Gamma> (TER h) \\<Longrightarrow> False", "from p p_eq x y"], ["proof (chain)\npicking this:\n  path \\<Gamma> x p y\n  p = [y]\n  x \\<in> A \\<Gamma>\n  y \\<in> B \\<Gamma>", "have \"path ?\\<Gamma> x [y] y\" \"x \\<in> A ?\\<Gamma>\" \"y \\<in> B ?\\<Gamma>\""], ["proof (prove)\nusing this:\n  path \\<Gamma> x p y\n  p = [y]\n  x \\<in> A \\<Gamma>\n  y \\<in> B \\<Gamma>\n\ngoal (1 subgoal):\n 1. path (\\<Gamma>\\<lparr>weight := weight \\<Gamma> - u\\<rparr>) x [y] y &&&\n    x \\<in> A (\\<Gamma>\\<lparr>weight := weight \\<Gamma> - u\\<rparr>) &&&\n    y \\<in> B (\\<Gamma>\\<lparr>weight := weight \\<Gamma> - u\\<rparr>)", "by simp_all"], ["proof (state)\nthis:\n  path (\\<Gamma>\\<lparr>weight := weight \\<Gamma> - u\\<rparr>) x [y] y\n  x \\<in> A (\\<Gamma>\\<lparr>weight := weight \\<Gamma> - u\\<rparr>)\n  y \\<in> B (\\<Gamma>\\<lparr>weight := weight \\<Gamma> - u\\<rparr>)\n\ngoal (1 subgoal):\n 1. \\<not> separating \\<Gamma> (TER h) \\<Longrightarrow> False", "from * separatingD[OF separating_essential, OF waveD_separating, OF w this]"], ["proof (chain)\npicking this:\n  x \\<notin> \\<E>\\<^bsub>\\<Gamma>\\<lparr>weight := weight \\<Gamma> - u\\<rparr>\\<^esub>\n              (TER\\<^bsub>\\<Gamma>\\<lparr>weight := weight \\<Gamma> - u\\<rparr>\\<^esub>\n                f)\n  (\\<exists>z\\<in>set [y].\n      z \\<in> \\<E>\\<^bsub>\\<Gamma>\\<lparr>weight := weight \\<Gamma> - u\\<rparr>\\<^esub>\n               (TER\\<^bsub>\\<Gamma>\\<lparr>weight := weight \\<Gamma> - u\\<rparr>\\<^esub>\n                 f)) \\<or>\n  x \\<in> \\<E>\\<^bsub>\\<Gamma>\\<lparr>weight := weight \\<Gamma> - u\\<rparr>\\<^esub>\n           (TER\\<^bsub>\\<Gamma>\\<lparr>weight := weight \\<Gamma> - u\\<rparr>\\<^esub>\n             f)", "have \"y \\<in> ?TER f\""], ["proof (prove)\nusing this:\n  x \\<notin> \\<E>\\<^bsub>\\<Gamma>\\<lparr>weight := weight \\<Gamma> - u\\<rparr>\\<^esub>\n              (TER\\<^bsub>\\<Gamma>\\<lparr>weight := weight \\<Gamma> - u\\<rparr>\\<^esub>\n                f)\n  (\\<exists>z\\<in>set [y].\n      z \\<in> \\<E>\\<^bsub>\\<Gamma>\\<lparr>weight := weight \\<Gamma> - u\\<rparr>\\<^esub>\n               (TER\\<^bsub>\\<Gamma>\\<lparr>weight := weight \\<Gamma> - u\\<rparr>\\<^esub>\n                 f)) \\<or>\n  x \\<in> \\<E>\\<^bsub>\\<Gamma>\\<lparr>weight := weight \\<Gamma> - u\\<rparr>\\<^esub>\n           (TER\\<^bsub>\\<Gamma>\\<lparr>weight := weight \\<Gamma> - u\\<rparr>\\<^esub>\n             f)\n\ngoal (1 subgoal):\n 1. y \\<in> TER\\<^bsub>\\<Gamma>\\<lparr>weight := weight \\<Gamma> - u\\<rparr>\\<^esub>\n             f", "by auto"], ["proof (state)\nthis:\n  y \\<in> TER\\<^bsub>\\<Gamma>\\<lparr>weight := weight \\<Gamma> - u\\<rparr>\\<^esub>\n           f\n\ngoal (1 subgoal):\n 1. \\<not> separating \\<Gamma> (TER h) \\<Longrightarrow> False", "with reach y"], ["proof (chain)\npicking this:\n  reachable y\n  y \\<in> B \\<Gamma>\n  y \\<in> TER\\<^bsub>\\<Gamma>\\<lparr>weight := weight \\<Gamma> - u\\<rparr>\\<^esub>\n           f", "have \"y \\<in> TER h\""], ["proof (prove)\nusing this:\n  reachable y\n  y \\<in> B \\<Gamma>\n  y \\<in> TER\\<^bsub>\\<Gamma>\\<lparr>weight := weight \\<Gamma> - u\\<rparr>\\<^esub>\n           f\n\ngoal (1 subgoal):\n 1. y \\<in> TER h", "by(rule sep_h)"], ["proof (state)\nthis:\n  y \\<in> TER h\n\ngoal (1 subgoal):\n 1. \\<not> separating \\<Gamma> (TER h) \\<Longrightarrow> False", "with y'"], ["proof (chain)\npicking this:\n  y \\<notin> TER h\n  y \\<in> TER h", "show False"], ["proof (prove)\nusing this:\n  y \\<notin> TER h\n  y \\<in> TER h\n\ngoal (1 subgoal):\n 1. False", "by contradiction"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  separating \\<Gamma> (TER h)\n\ngoal (1 subgoal):\n 1. current \\<Gamma> h", "qed(rule h)"], ["proof (state)\nthis:\n  wave \\<Gamma> h\n\ngoal (1 subgoal):\n 1. hindered \\<Gamma>", "have OUT_g_a: \"d_OUT g a = d_OUT h a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT g a = d_OUT h a", "by(simp add: OUT_h)"], ["proof (state)\nthis:\n  d_OUT g a = d_OUT h a\n\ngoal (1 subgoal):\n 1. hindered \\<Gamma>", "have \"a \\<notin> \\<E> (TER h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<notin> \\<E> (TER h)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. a \\<in> \\<E> (TER h) \\<Longrightarrow> False", "assume *: \"a \\<in> \\<E> (TER h)\""], ["proof (state)\nthis:\n  a \\<in> \\<E> (TER h)\n\ngoal (1 subgoal):\n 1. a \\<in> \\<E> (TER h) \\<Longrightarrow> False", "have \"j (Some a, Some y) = 0\" for y"], ["proof (prove)\ngoal (1 subgoal):\n 1. j (\\<langle>a\\<rangle>, \\<langle>y\\<rangle>) = 0", "using flowD_capacity[OF j, of \"(Some a, Some y)\"] a(1) disjoint"], ["proof (prove)\nusing this:\n  j (\\<langle>a\\<rangle>, \\<langle>y\\<rangle>)\n  \\<le> capacity \\<Psi> (\\<langle>a\\<rangle>, \\<langle>y\\<rangle>)\n  a \\<in> A \\<Gamma>\n  A \\<Gamma> \\<inter> B \\<Gamma> = {}\n\ngoal (1 subgoal):\n 1. j (\\<langle>a\\<rangle>, \\<langle>y\\<rangle>) = 0", "by(auto split: if_split_asm dest: bipartite_E)"], ["proof (state)\nthis:\n  j (\\<langle>a\\<rangle>, \\<langle>?y\\<rangle>) = 0\n\ngoal (1 subgoal):\n 1. a \\<in> \\<E> (TER h) \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  j (\\<langle>a\\<rangle>, \\<langle>?y\\<rangle>) = 0", "have \"d_OUT f a \\<le> d_OUT g a\""], ["proof (prove)\nusing this:\n  j (\\<langle>a\\<rangle>, \\<langle>?y\\<rangle>) = 0\n\ngoal (1 subgoal):\n 1. d_OUT f a \\<le> d_OUT g a", "unfolding d_OUT_def\n      \\<comment> \\<open>This step requires that @{term j} does not decrease the outflow of @{term a}. That's\n          why we set the capacity of the outgoing edges from @{term \"Some a\"} in @{term \\<Psi>} to @{term \"0 :: ennreal\"}\\<close>"], ["proof (prove)\nusing this:\n  j (\\<langle>a\\<rangle>, \\<langle>?y\\<rangle>) = 0\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y. f (a, y)) \\<le> (\\<Sum>\\<^sup>+ y. g (a, y))", "by(intro nn_integral_mono)(auto simp add: g_simps currentD_outside[OF f] intro: )"], ["proof (state)\nthis:\n  d_OUT f a \\<le> d_OUT g a\n\ngoal (1 subgoal):\n 1. a \\<in> \\<E> (TER h) \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  d_OUT f a \\<le> d_OUT g a", "have \"a \\<in> SINK f\""], ["proof (prove)\nusing this:\n  d_OUT f a \\<le> d_OUT g a\n\ngoal (1 subgoal):\n 1. a \\<in> SINK f", "using OUT_g_a *"], ["proof (prove)\nusing this:\n  d_OUT f a \\<le> d_OUT g a\n  d_OUT g a = d_OUT h a\n  a \\<in> \\<E> (TER h)\n\ngoal (1 subgoal):\n 1. a \\<in> SINK f", "by(simp add: SINK.simps)"], ["proof (state)\nthis:\n  a \\<in> SINK f\n\ngoal (1 subgoal):\n 1. a \\<in> \\<E> (TER h) \\<Longrightarrow> False", "with a(1)"], ["proof (chain)\npicking this:\n  a \\<in> A \\<Gamma>\n  a \\<in> SINK f", "have \"a \\<in> ?TER f\""], ["proof (prove)\nusing this:\n  a \\<in> A \\<Gamma>\n  a \\<in> SINK f\n\ngoal (1 subgoal):\n 1. a \\<in> TER\\<^bsub>\\<Gamma>\\<lparr>weight := weight \\<Gamma> - u\\<rparr>\\<^esub>\n             f", "by(auto intro: SAT.A)"], ["proof (state)\nthis:\n  a \\<in> TER\\<^bsub>\\<Gamma>\\<lparr>weight := weight \\<Gamma> - u\\<rparr>\\<^esub>\n           f\n\ngoal (1 subgoal):\n 1. a \\<in> \\<E> (TER h) \\<Longrightarrow> False", "with a(2)"], ["proof (chain)\npicking this:\n  a \\<notin> \\<E>\\<^bsub>\\<Gamma>\\<lparr>weight := weight \\<Gamma> - u\\<rparr>\\<^esub>\n              (TER\\<^bsub>\\<Gamma>\\<lparr>weight := weight \\<Gamma> - u\\<rparr>\\<^esub>\n                f)\n  a \\<in> TER\\<^bsub>\\<Gamma>\\<lparr>weight := weight \\<Gamma> - u\\<rparr>\\<^esub>\n           f", "have a': \"\\<not> essential \\<Gamma> (B \\<Gamma>) (?TER f) a\""], ["proof (prove)\nusing this:\n  a \\<notin> \\<E>\\<^bsub>\\<Gamma>\\<lparr>weight := weight \\<Gamma> - u\\<rparr>\\<^esub>\n              (TER\\<^bsub>\\<Gamma>\\<lparr>weight := weight \\<Gamma> - u\\<rparr>\\<^esub>\n                f)\n  a \\<in> TER\\<^bsub>\\<Gamma>\\<lparr>weight := weight \\<Gamma> - u\\<rparr>\\<^esub>\n           f\n\ngoal (1 subgoal):\n 1. \\<not> essential \\<Gamma> (B \\<Gamma>)\n            (TER\\<^bsub>\\<Gamma>\\<lparr>weight := weight \\<Gamma> - u\\<rparr>\\<^esub>\n              f)\n            a", "by simp"], ["proof (state)\nthis:\n  \\<not> essential \\<Gamma> (B \\<Gamma>)\n          (TER\\<^bsub>\\<Gamma>\\<lparr>weight := weight \\<Gamma> - u\\<rparr>\\<^esub>\n            f)\n          a\n\ngoal (1 subgoal):\n 1. a \\<in> \\<E> (TER h) \\<Longrightarrow> False", "from *"], ["proof (chain)\npicking this:\n  a \\<in> \\<E> (TER h)", "obtain y where ay: \"edge \\<Gamma> a y\" and y: \"y \\<in> B \\<Gamma>\" and y': \"y \\<notin> TER h\""], ["proof (prove)\nusing this:\n  a \\<in> \\<E> (TER h)\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>edge \\<Gamma> a y; y \\<in> B \\<Gamma>;\n         y \\<notin> TER h\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using disjoint a(1)"], ["proof (prove)\nusing this:\n  a \\<in> \\<E> (TER h)\n  A \\<Gamma> \\<inter> B \\<Gamma> = {}\n  a \\<in> A \\<Gamma>\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>edge \\<Gamma> a y; y \\<in> B \\<Gamma>;\n         y \\<notin> TER h\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto 4 4 simp add: essential_def elim: rtrancl_path.cases dest: bipartite_E)"], ["proof (state)\nthis:\n  edge \\<Gamma> a y\n  y \\<in> B \\<Gamma>\n  y \\<notin> TER h\n\ngoal (1 subgoal):\n 1. a \\<in> \\<E> (TER h) \\<Longrightarrow> False", "from not_essentialD[OF a' rtrancl_path.step, OF ay rtrancl_path.base y]"], ["proof (chain)\npicking this:\n  a \\<noteq> y \\<and>\n  (\\<exists>z\\<in>set [y].\n      z \\<noteq> a \\<and>\n      z \\<in> TER\\<^bsub>\\<Gamma>\\<lparr>weight := weight \\<Gamma> - u\\<rparr>\\<^esub>\n               f)", "have TER: \"y \\<in> ?TER f\""], ["proof (prove)\nusing this:\n  a \\<noteq> y \\<and>\n  (\\<exists>z\\<in>set [y].\n      z \\<noteq> a \\<and>\n      z \\<in> TER\\<^bsub>\\<Gamma>\\<lparr>weight := weight \\<Gamma> - u\\<rparr>\\<^esub>\n               f)\n\ngoal (1 subgoal):\n 1. y \\<in> TER\\<^bsub>\\<Gamma>\\<lparr>weight := weight \\<Gamma> - u\\<rparr>\\<^esub>\n             f", "by simp"], ["proof (state)\nthis:\n  y \\<in> TER\\<^bsub>\\<Gamma>\\<lparr>weight := weight \\<Gamma> - u\\<rparr>\\<^esub>\n           f\n\ngoal (1 subgoal):\n 1. a \\<in> \\<E> (TER h) \\<Longrightarrow> False", "have \"reachable y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reachable y", "using \\<open>reachable a\\<close>"], ["proof (prove)\nusing this:\n  reachable a\n\ngoal (1 subgoal):\n 1. reachable y", "by(rule reachable_AB)(simp add: ay)"], ["proof (state)\nthis:\n  reachable y\n\ngoal (1 subgoal):\n 1. a \\<in> \\<E> (TER h) \\<Longrightarrow> False", "hence \"y \\<in> TER h\""], ["proof (prove)\nusing this:\n  reachable y\n\ngoal (1 subgoal):\n 1. y \\<in> TER h", "using y TER"], ["proof (prove)\nusing this:\n  reachable y\n  y \\<in> B \\<Gamma>\n  y \\<in> TER\\<^bsub>\\<Gamma>\\<lparr>weight := weight \\<Gamma> - u\\<rparr>\\<^esub>\n           f\n\ngoal (1 subgoal):\n 1. y \\<in> TER h", "by(rule sep_h)"], ["proof (state)\nthis:\n  y \\<in> TER h\n\ngoal (1 subgoal):\n 1. a \\<in> \\<E> (TER h) \\<Longrightarrow> False", "with y'"], ["proof (chain)\npicking this:\n  y \\<notin> TER h\n  y \\<in> TER h", "show False"], ["proof (prove)\nusing this:\n  y \\<notin> TER h\n  y \\<in> TER h\n\ngoal (1 subgoal):\n 1. False", "by contradiction"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  a \\<notin> \\<E> (TER h)\n\ngoal (1 subgoal):\n 1. hindered \\<Gamma>", "with \\<open>a \\<in> A \\<Gamma>\\<close>"], ["proof (chain)\npicking this:\n  a \\<in> A \\<Gamma>\n  a \\<notin> \\<E> (TER h)", "have \"hindrance \\<Gamma> h\""], ["proof (prove)\nusing this:\n  a \\<in> A \\<Gamma>\n  a \\<notin> \\<E> (TER h)\n\ngoal (1 subgoal):\n 1. hindrance \\<Gamma> h", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. d_OUT h a < weight \\<Gamma> a", "have \"d_OUT h a = d_OUT g a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT h a = d_OUT g a", "by(simp add: OUT_g_a)"], ["proof (state)\nthis:\n  d_OUT h a = d_OUT g a\n\ngoal (1 subgoal):\n 1. d_OUT h a < weight \\<Gamma> a", "also"], ["proof (state)\nthis:\n  d_OUT h a = d_OUT g a\n\ngoal (1 subgoal):\n 1. d_OUT h a < weight \\<Gamma> a", "have \"\\<dots> \\<le> d_OUT f a + \\<integral>\\<^sup>+ y. j (Some y, Some a) \\<partial>count_space UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT g a\n    \\<le> d_OUT f a +\n          (\\<Sum>\\<^sup>+ y. j (\\<langle>y\\<rangle>, \\<langle>a\\<rangle>))", "unfolding d_OUT_def d_IN_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y. g (a, y))\n    \\<le> (\\<Sum>\\<^sup>+ y. f (a, y)) +\n          (\\<Sum>\\<^sup>+ y. j (\\<langle>y\\<rangle>, \\<langle>a\\<rangle>))", "by(subst nn_integral_add[symmetric])(auto simp add: g_simps intro!: nn_integral_mono diff_le_self_ennreal)"], ["proof (state)\nthis:\n  d_OUT g a\n  \\<le> d_OUT f a +\n        (\\<Sum>\\<^sup>+ y. j (\\<langle>y\\<rangle>, \\<langle>a\\<rangle>))\n\ngoal (1 subgoal):\n 1. d_OUT h a < weight \\<Gamma> a", "also"], ["proof (state)\nthis:\n  d_OUT g a\n  \\<le> d_OUT f a +\n        (\\<Sum>\\<^sup>+ y. j (\\<langle>y\\<rangle>, \\<langle>a\\<rangle>))\n\ngoal (1 subgoal):\n 1. d_OUT h a < weight \\<Gamma> a", "have \"(\\<integral>\\<^sup>+ y. j (Some y, Some a) \\<partial>count_space UNIV) = (\\<integral>\\<^sup>+ y. j (y, Some a) \\<partial>embed_measure (count_space UNIV) Some)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y. j (\\<langle>y\\<rangle>, \\<langle>a\\<rangle>)) =\n    \\<integral>\\<^sup>+ y. j (y, \\<langle>a\\<rangle>)\n                       \\<partial>embed_measure (count_space UNIV) Some", "by(simp add: nn_integral_embed_measure measurable_embed_measure1)"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y. j (\\<langle>y\\<rangle>, \\<langle>a\\<rangle>)) =\n  \\<integral>\\<^sup>+ y. j (y, \\<langle>a\\<rangle>)\n                     \\<partial>embed_measure (count_space UNIV) Some\n\ngoal (1 subgoal):\n 1. d_OUT h a < weight \\<Gamma> a", "also"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y. j (\\<langle>y\\<rangle>, \\<langle>a\\<rangle>)) =\n  \\<integral>\\<^sup>+ y. j (y, \\<langle>a\\<rangle>)\n                     \\<partial>embed_measure (count_space UNIV) Some\n\ngoal (1 subgoal):\n 1. d_OUT h a < weight \\<Gamma> a", "have \"\\<dots> \\<le> d_IN j (Some a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ y. j (y, \\<langle>a\\<rangle>)\n                       \\<partial>embed_measure (count_space UNIV) Some\n    \\<le> d_IN j \\<langle>a\\<rangle>", "unfolding d_IN_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ y. j (y, \\<langle>a\\<rangle>)\n                       \\<partial>embed_measure (count_space UNIV) Some\n    \\<le> (\\<Sum>\\<^sup>+ x. j (x, \\<langle>a\\<rangle>))", "by(auto simp add: embed_measure_count_space nn_integral_count_space_indicator intro!: nn_integral_mono split: split_indicator)"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ y. j (y, \\<langle>a\\<rangle>)\n                     \\<partial>embed_measure (count_space UNIV) Some\n  \\<le> d_IN j \\<langle>a\\<rangle>\n\ngoal (1 subgoal):\n 1. d_OUT h a < weight \\<Gamma> a", "also"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ y. j (y, \\<langle>a\\<rangle>)\n                     \\<partial>embed_measure (count_space UNIV) Some\n  \\<le> d_IN j \\<langle>a\\<rangle>\n\ngoal (1 subgoal):\n 1. d_OUT h a < weight \\<Gamma> a", "have \"\\<dots> \\<le> \\<alpha>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN j \\<langle>a\\<rangle> \\<le> \\<alpha>", "by(rule IN_j)"], ["proof (state)\nthis:\n  d_IN j \\<langle>a\\<rangle> \\<le> \\<alpha>\n\ngoal (1 subgoal):\n 1. d_OUT h a < weight \\<Gamma> a", "also"], ["proof (state)\nthis:\n  d_IN j \\<langle>a\\<rangle> \\<le> \\<alpha>\n\ngoal (1 subgoal):\n 1. d_OUT h a < weight \\<Gamma> a", "have \"\\<dots> \\<le> \\<epsilon>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha> \\<le> \\<epsilon>", "by(rule \\<alpha>_le)"], ["proof (state)\nthis:\n  \\<alpha> \\<le> \\<epsilon>\n\ngoal (1 subgoal):\n 1. d_OUT h a < weight \\<Gamma> a", "also"], ["proof (state)\nthis:\n  \\<alpha> \\<le> \\<epsilon>\n\ngoal (1 subgoal):\n 1. d_OUT h a < weight \\<Gamma> a", "have \"d_OUT f a + \\<dots> < d_OUT f a + (weight \\<Gamma> a - d_OUT f a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT f a + \\<epsilon> < d_OUT f a + (weight \\<Gamma> a - d_OUT f a)", "using \\<epsilon>_less"], ["proof (prove)\nusing this:\n  \\<epsilon> < weight \\<Gamma> a - d_OUT f a\n\ngoal (1 subgoal):\n 1. d_OUT f a + \\<epsilon> < d_OUT f a + (weight \\<Gamma> a - d_OUT f a)", "using currentD_finite_OUT[OF f']"], ["proof (prove)\nusing this:\n  \\<epsilon> < weight \\<Gamma> a - d_OUT f a\n  d_OUT f ?x \\<noteq> \\<top>\n\ngoal (1 subgoal):\n 1. d_OUT f a + \\<epsilon> < d_OUT f a + (weight \\<Gamma> a - d_OUT f a)", "by (simp add: ennreal_add_left_cancel_less)"], ["proof (state)\nthis:\n  d_OUT f a + \\<epsilon> < d_OUT f a + (weight \\<Gamma> a - d_OUT f a)\n\ngoal (1 subgoal):\n 1. d_OUT h a < weight \\<Gamma> a", "also"], ["proof (state)\nthis:\n  d_OUT f a + \\<epsilon> < d_OUT f a + (weight \\<Gamma> a - d_OUT f a)\n\ngoal (1 subgoal):\n 1. d_OUT h a < weight \\<Gamma> a", "have \"\\<dots> = weight \\<Gamma> a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT f a + (weight \\<Gamma> a - d_OUT f a) = weight \\<Gamma> a", "using a_le"], ["proof (prove)\nusing this:\n  d_OUT f a < weight \\<Gamma> a\n\ngoal (1 subgoal):\n 1. d_OUT f a + (weight \\<Gamma> a - d_OUT f a) = weight \\<Gamma> a", "by simp"], ["proof (state)\nthis:\n  d_OUT f a + (weight \\<Gamma> a - d_OUT f a) = weight \\<Gamma> a\n\ngoal (1 subgoal):\n 1. d_OUT h a < weight \\<Gamma> a", "finally"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<And>x y.\n              x \\<le> y \\<Longrightarrow> d_OUT f a + x \\<le> d_OUT f a + y;\n   \\<And>x y. x \\<le> y \\<Longrightarrow> d_OUT f a + x \\<le> d_OUT f a + y;\n   \\<And>x y.\n      x \\<le> y \\<Longrightarrow> d_OUT f a + x \\<le> d_OUT f a + y\\<rbrakk>\n  \\<Longrightarrow> d_OUT h a < weight \\<Gamma> a", "show \"d_OUT h a < weight \\<Gamma> a\""], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>x y.\n              x \\<le> y \\<Longrightarrow> d_OUT f a + x \\<le> d_OUT f a + y;\n   \\<And>x y. x \\<le> y \\<Longrightarrow> d_OUT f a + x \\<le> d_OUT f a + y;\n   \\<And>x y.\n      x \\<le> y \\<Longrightarrow> d_OUT f a + x \\<le> d_OUT f a + y\\<rbrakk>\n  \\<Longrightarrow> d_OUT h a < weight \\<Gamma> a\n\ngoal (1 subgoal):\n 1. d_OUT h a < weight \\<Gamma> a", "by(simp add: add_left_mono)"], ["proof (state)\nthis:\n  d_OUT h a < weight \\<Gamma> a\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  hindrance \\<Gamma> h\n\ngoal (1 subgoal):\n 1. hindered \\<Gamma>", "then"], ["proof (chain)\npicking this:\n  hindrance \\<Gamma> h", "show ?thesis"], ["proof (prove)\nusing this:\n  hindrance \\<Gamma> h\n\ngoal (1 subgoal):\n 1. hindered \\<Gamma>", "using h w'"], ["proof (prove)\nusing this:\n  hindrance \\<Gamma> h\n  current \\<Gamma> h\n  wave \\<Gamma> h\n\ngoal (1 subgoal):\n 1. hindered \\<Gamma>", "by(blast intro: hindered.intros)"], ["proof (state)\nthis:\n  hindered \\<Gamma>\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "corollary hindered_reduce_current: \\<comment> \\<open>Corollary 6.8\\<close>\n  fixes \\<epsilon> g\n  defines \"\\<epsilon> \\<equiv> \\<Sum>\\<^sup>+ x\\<in>B \\<Gamma>. d_IN g x - d_OUT g x\"\n  assumes g: \"current \\<Gamma> g\"\n  and \\<epsilon>_finite: \"\\<epsilon> \\<noteq> \\<top>\"\n  and hindered: \"hindered_by (\\<Gamma> \\<ominus> g) \\<epsilon>\"\n  shows \"hindered \\<Gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hindered \\<Gamma>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. hindered \\<Gamma>", "define \\<Gamma>' where \"\\<Gamma>' = \\<Gamma>\\<lparr>weight := \\<lambda>x. if x \\<in> A \\<Gamma> then weight \\<Gamma> x - d_OUT g x else weight \\<Gamma> x\\<rparr>\""], ["proof (state)\nthis:\n  \\<Gamma>' = \\<Gamma>\n  \\<lparr>weight :=\n            \\<lambda>x.\n               if x \\<in> A \\<Gamma> then weight \\<Gamma> x - d_OUT g x\n               else weight \\<Gamma> x\\<rparr>\n\ngoal (1 subgoal):\n 1. hindered \\<Gamma>", "have \\<Gamma>'_sel [simp]:\n    \"edge \\<Gamma>' = edge \\<Gamma>\"\n    \"A \\<Gamma>' = A \\<Gamma>\"\n    \"B \\<Gamma>' = B \\<Gamma>\"\n    \"weight \\<Gamma>' x = (if x \\<in> A \\<Gamma> then weight \\<Gamma> x - d_OUT g x else weight \\<Gamma> x)\"\n    \"vertex \\<Gamma>' = vertex \\<Gamma>\"\n    \"web.more \\<Gamma>' = web.more \\<Gamma>\"\n    for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. (edge \\<Gamma>' = edge \\<Gamma> &&&\n     A \\<Gamma>' = A \\<Gamma> &&& B \\<Gamma>' = B \\<Gamma>) &&&\n    weight \\<Gamma>' x =\n    (if x \\<in> A \\<Gamma> then weight \\<Gamma> x - d_OUT g x\n     else weight \\<Gamma> x) &&&\n    vertex \\<Gamma>' = vertex \\<Gamma> &&&\n    web.more \\<Gamma>' = web.more \\<Gamma>", "by(simp_all add: \\<Gamma>'_def)"], ["proof (state)\nthis:\n  edge \\<Gamma>' = edge \\<Gamma>\n  A \\<Gamma>' = A \\<Gamma>\n  B \\<Gamma>' = B \\<Gamma>\n  weight \\<Gamma>' ?x =\n  (if ?x \\<in> A \\<Gamma> then weight \\<Gamma> ?x - d_OUT g ?x\n   else weight \\<Gamma> ?x)\n  vertex \\<Gamma>' = vertex \\<Gamma>\n  web.more \\<Gamma>' = web.more \\<Gamma>\n\ngoal (1 subgoal):\n 1. hindered \\<Gamma>", "have \"countable_bipartite_web \\<Gamma>'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. countable_bipartite_web \\<Gamma>'", "by unfold_locales(simp_all add: A_in B_out A_vertex disjoint bipartite_V no_loop weight_outside currentD_outside_OUT[OF g]  currentD_weight_OUT[OF g] edge_antiparallel, rule bipartite_E)"], ["proof (state)\nthis:\n  countable_bipartite_web \\<Gamma>'\n\ngoal (1 subgoal):\n 1. hindered \\<Gamma>", "then"], ["proof (chain)\npicking this:\n  countable_bipartite_web \\<Gamma>'", "interpret \\<Gamma>': countable_bipartite_web \\<Gamma>'"], ["proof (prove)\nusing this:\n  countable_bipartite_web \\<Gamma>'\n\ngoal (1 subgoal):\n 1. countable_bipartite_web \\<Gamma>'", "."], ["proof (state)\ngoal (1 subgoal):\n 1. hindered \\<Gamma>", "let ?u = \"\\<lambda>x. (d_IN g x - d_OUT g x) * indicator (- A \\<Gamma>) x\""], ["proof (state)\ngoal (1 subgoal):\n 1. hindered \\<Gamma>", "have \"hindered \\<Gamma>'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hindered \\<Gamma>'", "proof(rule \\<Gamma>'.hindered_reduce)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x. x \\<notin> B \\<Gamma>' \\<Longrightarrow> ?u x = 0\n 2. integral\\<^sup>N (count_space (B \\<Gamma>')) ?u \\<noteq> \\<top>\n 3. ?u \\<le> weight \\<Gamma>'\n 4. hindered_by (\\<Gamma>'\\<lparr>weight := weight \\<Gamma>' - ?u\\<rparr>)\n     (integral\\<^sup>N (count_space (B \\<Gamma>')) ?u)", "show \"?u x = 0\" if \"x \\<notin> B \\<Gamma>'\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. (d_IN g x - d_OUT g x) * indicator (- A \\<Gamma>) x = 0", "using that bipartite_V"], ["proof (prove)\nusing this:\n  x \\<notin> B \\<Gamma>'\n  \\<^bold>V \\<subseteq> A \\<Gamma> \\<union> B \\<Gamma>\n\ngoal (1 subgoal):\n 1. (d_IN g x - d_OUT g x) * indicator (- A \\<Gamma>) x = 0", "by(cases \"vertex \\<Gamma>' x\")(auto simp add: currentD_outside_OUT[OF g] currentD_outside_IN[OF g])"], ["proof (state)\nthis:\n  ?x \\<notin> B \\<Gamma>' \\<Longrightarrow>\n  (d_IN g ?x - d_OUT g ?x) * indicator (- A \\<Gamma>) ?x = 0\n\ngoal (3 subgoals):\n 1. \\<integral>\\<^sup>+y\\<in>- A \\<Gamma>. (d_IN g y - d_OUT g y)\n    \\<partial>count_space (B \\<Gamma>') \\<noteq>\n    \\<top>\n 2. (\\<lambda>x. (d_IN g x - d_OUT g x) * indicator (- A \\<Gamma>) x)\n    \\<le> weight \\<Gamma>'\n 3. hindered_by\n     (\\<Gamma>'\n      \\<lparr>weight :=\n                weight \\<Gamma>' -\n                (\\<lambda>x.\n                    (d_IN g x - d_OUT g x) *\n                    indicator (- A \\<Gamma>) x)\\<rparr>)\n     (\\<integral>\\<^sup>+y\\<in>- A \\<Gamma>. (d_IN g y - d_OUT g y)\n      \\<partial>count_space (B \\<Gamma>'))", "have *: \"(\\<Sum>\\<^sup>+ x\\<in>B \\<Gamma>'. ?u x) = \\<epsilon>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+x\\<in>- A \\<Gamma>. (d_IN g x - d_OUT g x)\n    \\<partial>count_space (B \\<Gamma>') =\n    \\<epsilon>", "using disjoint"], ["proof (prove)\nusing this:\n  A \\<Gamma> \\<inter> B \\<Gamma> = {}\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+x\\<in>- A \\<Gamma>. (d_IN g x - d_OUT g x)\n    \\<partial>count_space (B \\<Gamma>') =\n    \\<epsilon>", "by(auto intro!: nn_integral_cong simp add: \\<epsilon>_def nn_integral_count_space_indicator currentD_outside_OUT[OF g] currentD_outside_IN[OF g] not_vertex split: split_indicator)"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+x\\<in>- A \\<Gamma>. (d_IN g x - d_OUT g x)\n  \\<partial>count_space (B \\<Gamma>') =\n  \\<epsilon>\n\ngoal (3 subgoals):\n 1. \\<integral>\\<^sup>+y\\<in>- A \\<Gamma>. (d_IN g y - d_OUT g y)\n    \\<partial>count_space (B \\<Gamma>') \\<noteq>\n    \\<top>\n 2. (\\<lambda>x. (d_IN g x - d_OUT g x) * indicator (- A \\<Gamma>) x)\n    \\<le> weight \\<Gamma>'\n 3. hindered_by\n     (\\<Gamma>'\n      \\<lparr>weight :=\n                weight \\<Gamma>' -\n                (\\<lambda>x.\n                    (d_IN g x - d_OUT g x) *\n                    indicator (- A \\<Gamma>) x)\\<rparr>)\n     (\\<integral>\\<^sup>+y\\<in>- A \\<Gamma>. (d_IN g y - d_OUT g y)\n      \\<partial>count_space (B \\<Gamma>'))", "thus \"(\\<Sum>\\<^sup>+ x\\<in>B \\<Gamma>'. ?u x) \\<noteq> \\<top>\""], ["proof (prove)\nusing this:\n  \\<integral>\\<^sup>+x\\<in>- A \\<Gamma>. (d_IN g x - d_OUT g x)\n  \\<partial>count_space (B \\<Gamma>') =\n  \\<epsilon>\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+x\\<in>- A \\<Gamma>. (d_IN g x - d_OUT g x)\n    \\<partial>count_space (B \\<Gamma>') \\<noteq>\n    \\<top>", "using \\<epsilon>_finite"], ["proof (prove)\nusing this:\n  \\<integral>\\<^sup>+x\\<in>- A \\<Gamma>. (d_IN g x - d_OUT g x)\n  \\<partial>count_space (B \\<Gamma>') =\n  \\<epsilon>\n  \\<epsilon> \\<noteq> \\<top>\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+x\\<in>- A \\<Gamma>. (d_IN g x - d_OUT g x)\n    \\<partial>count_space (B \\<Gamma>') \\<noteq>\n    \\<top>", "by simp"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+x\\<in>- A \\<Gamma>. (d_IN g x - d_OUT g x)\n  \\<partial>count_space (B \\<Gamma>') \\<noteq>\n  \\<top>\n\ngoal (2 subgoals):\n 1. (\\<lambda>x. (d_IN g x - d_OUT g x) * indicator (- A \\<Gamma>) x)\n    \\<le> weight \\<Gamma>'\n 2. hindered_by\n     (\\<Gamma>'\n      \\<lparr>weight :=\n                weight \\<Gamma>' -\n                (\\<lambda>x.\n                    (d_IN g x - d_OUT g x) *\n                    indicator (- A \\<Gamma>) x)\\<rparr>)\n     (\\<integral>\\<^sup>+y\\<in>- A \\<Gamma>. (d_IN g y - d_OUT g y)\n      \\<partial>count_space (B \\<Gamma>'))", "have **: \"\\<Gamma>'\\<lparr>weight := weight \\<Gamma>' - ?u\\<rparr> = \\<Gamma> \\<ominus> g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>'\n    \\<lparr>weight :=\n              weight \\<Gamma>' -\n              (\\<lambda>x.\n                  (d_IN g x - d_OUT g x) *\n                  indicator (- A \\<Gamma>) x)\\<rparr> =\n    \\<Gamma> \\<ominus> g", "using currentD_weight_IN[OF g] currentD_OUT_IN[OF g] currentD_IN[OF g] currentD_finite_OUT[OF g]"], ["proof (prove)\nusing this:\n  d_IN g ?x \\<le> weight \\<Gamma> ?x\n  ?x \\<notin> A \\<Gamma> \\<Longrightarrow> d_OUT g ?x \\<le> d_IN g ?x\n  ?a \\<in> A \\<Gamma> \\<Longrightarrow> d_IN g ?a = 0\n  d_OUT g ?x \\<noteq> \\<top>\n\ngoal (1 subgoal):\n 1. \\<Gamma>'\n    \\<lparr>weight :=\n              weight \\<Gamma>' -\n              (\\<lambda>x.\n                  (d_IN g x - d_OUT g x) *\n                  indicator (- A \\<Gamma>) x)\\<rparr> =\n    \\<Gamma> \\<ominus> g", "by(intro web.equality)(simp_all add: fun_eq_iff diff_diff_ennreal' ennreal_diff_le_mono_left)"], ["proof (state)\nthis:\n  \\<Gamma>'\n  \\<lparr>weight :=\n            weight \\<Gamma>' -\n            (\\<lambda>x.\n                (d_IN g x - d_OUT g x) *\n                indicator (- A \\<Gamma>) x)\\<rparr> =\n  \\<Gamma> \\<ominus> g\n\ngoal (2 subgoals):\n 1. (\\<lambda>x. (d_IN g x - d_OUT g x) * indicator (- A \\<Gamma>) x)\n    \\<le> weight \\<Gamma>'\n 2. hindered_by\n     (\\<Gamma>'\n      \\<lparr>weight :=\n                weight \\<Gamma>' -\n                (\\<lambda>x.\n                    (d_IN g x - d_OUT g x) *\n                    indicator (- A \\<Gamma>) x)\\<rparr>)\n     (\\<integral>\\<^sup>+y\\<in>- A \\<Gamma>. (d_IN g y - d_OUT g y)\n      \\<partial>count_space (B \\<Gamma>'))", "show \"hindered_by (\\<Gamma>'\\<lparr>weight := weight \\<Gamma>' - ?u\\<rparr>) (\\<Sum>\\<^sup>+ x\\<in>B \\<Gamma>'. ?u x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hindered_by\n     (\\<Gamma>'\n      \\<lparr>weight :=\n                weight \\<Gamma>' -\n                (\\<lambda>x.\n                    (d_IN g x - d_OUT g x) *\n                    indicator (- A \\<Gamma>) x)\\<rparr>)\n     (\\<integral>\\<^sup>+x\\<in>- A \\<Gamma>. (d_IN g x - d_OUT g x)\n      \\<partial>count_space (B \\<Gamma>'))", "unfolding * **"], ["proof (prove)\ngoal (1 subgoal):\n 1. hindered_by (\\<Gamma> \\<ominus> g) \\<epsilon>", "by(fact hindered)"], ["proof (state)\nthis:\n  hindered_by\n   (\\<Gamma>'\n    \\<lparr>weight :=\n              weight \\<Gamma>' -\n              (\\<lambda>x.\n                  (d_IN g x - d_OUT g x) *\n                  indicator (- A \\<Gamma>) x)\\<rparr>)\n   (\\<integral>\\<^sup>+x\\<in>- A \\<Gamma>. (d_IN g x - d_OUT g x)\n    \\<partial>count_space (B \\<Gamma>'))\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. (d_IN g x - d_OUT g x) * indicator (- A \\<Gamma>) x)\n    \\<le> weight \\<Gamma>'", "show \"(\\<lambda>x. (d_IN g x - d_OUT g x) * indicator (- A \\<Gamma>) x) \\<le> weight \\<Gamma>'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. (d_IN g x - d_OUT g x) * indicator (- A \\<Gamma>) x)\n    \\<le> weight \\<Gamma>'", "using currentD_weight_IN[OF g]"], ["proof (prove)\nusing this:\n  d_IN g ?x \\<le> weight \\<Gamma> ?x\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. (d_IN g x - d_OUT g x) * indicator (- A \\<Gamma>) x)\n    \\<le> weight \\<Gamma>'", "by (simp add: le_fun_def ennreal_diff_le_mono_left)"], ["proof (state)\nthis:\n  (\\<lambda>x. (d_IN g x - d_OUT g x) * indicator (- A \\<Gamma>) x)\n  \\<le> weight \\<Gamma>'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  hindered \\<Gamma>'\n\ngoal (1 subgoal):\n 1. hindered \\<Gamma>", "then"], ["proof (chain)\npicking this:\n  hindered \\<Gamma>'", "show ?thesis"], ["proof (prove)\nusing this:\n  hindered \\<Gamma>'\n\ngoal (1 subgoal):\n 1. hindered \\<Gamma>", "by(rule hindered_mono_web[rotated -1]) simp_all"], ["proof (state)\nthis:\n  hindered \\<Gamma>\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "subsection \\<open>Reduced weight in a loose web\\<close>"], ["", "definition reduce_weight :: \"('v, 'more) web_scheme \\<Rightarrow> 'v \\<Rightarrow> real \\<Rightarrow> ('v, 'more) web_scheme\"\nwhere \"reduce_weight \\<Gamma> x r = \\<Gamma>\\<lparr>weight := \\<lambda>y. weight \\<Gamma> y - (if x = y then r else 0)\\<rparr>\""], ["", "lemma reduce_weight_sel [simp]:\n  \"edge (reduce_weight \\<Gamma> x r) = edge \\<Gamma>\"\n  \"A (reduce_weight \\<Gamma> x r) = A \\<Gamma>\"\n  \"B (reduce_weight \\<Gamma> x r) = B \\<Gamma>\"\n  \"vertex (reduce_weight \\<Gamma> x r) = vertex \\<Gamma>\"\n  \"weight (reduce_weight \\<Gamma> x r) y = (if x = y then weight \\<Gamma> x - r else weight \\<Gamma> y)\"\n  \"web.more (reduce_weight \\<Gamma> x r) = web.more \\<Gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (edge (reduce_weight \\<Gamma> x r) = edge \\<Gamma> &&&\n     A (reduce_weight \\<Gamma> x r) = A \\<Gamma> &&&\n     B (reduce_weight \\<Gamma> x r) = B \\<Gamma>) &&&\n    vertex (reduce_weight \\<Gamma> x r) = vertex \\<Gamma> &&&\n    weight (reduce_weight \\<Gamma> x r) y =\n    (if x = y then weight \\<Gamma> x - ennreal r else weight \\<Gamma> y) &&&\n    web.more (reduce_weight \\<Gamma> x r) = web.more \\<Gamma>", "by(simp_all add: reduce_weight_def zero_ennreal_def[symmetric] vertex_def fun_eq_iff)"], ["", "lemma essential_reduce_weight [simp]: \"essential (reduce_weight \\<Gamma> x r) = essential \\<Gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. essential (reduce_weight \\<Gamma> x r) = essential \\<Gamma>", "by(simp add: fun_eq_iff essential_def)"], ["", "lemma roofed_reduce_weight [simp]: \"roofed_gen (reduce_weight \\<Gamma> x r) = roofed_gen \\<Gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. roofed_gen (reduce_weight \\<Gamma> x r) = roofed_gen \\<Gamma>", "by(simp add: fun_eq_iff roofed_def)"], ["", "context countable_bipartite_web begin"], ["", "context begin"], ["", "private"], ["", "datatype (plugins del: transfer size) 'a vertex = SOURCE | SINK | Inner (inner: 'a)"], ["", "private"], ["", "lemma notin_range_Inner:  \"x \\<notin> range Inner \\<longleftrightarrow> x = SOURCE \\<or> x = SINK\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<notin> range Inner) = (x = SOURCE \\<or> x = vertex.SINK)", "by(cases x) auto"], ["", "private"], ["", "lemma inj_Inner [simp]: \"\\<And>A. inj_on Inner A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>A. inj_on Inner A", "by(simp add: inj_on_def)"], ["", "lemma unhinder_bipartite:\n  assumes h: \"\\<And>n :: nat. current \\<Gamma> (h n)\"\n  and SAT: \"\\<And>n. (B \\<Gamma> \\<inter> \\<^bold>V) - {b} \\<subseteq> SAT \\<Gamma> (h n)\"\n  and b: \"b \\<in> B \\<Gamma>\"\n  and IN: \"(SUP n. d_IN (h n) b) = weight \\<Gamma> b\"\n  and h0_b: \"\\<And>n. d_IN (h 0) b \\<le> d_IN (h n) b\"\n  and b_V: \"b \\<in> \\<^bold>V\"\n  shows \"\\<exists>h'. current \\<Gamma> h' \\<and> wave \\<Gamma> h' \\<and> B \\<Gamma> \\<inter> \\<^bold>V \\<subseteq> SAT \\<Gamma> h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>h'.\n       current \\<Gamma> h' \\<and>\n       wave \\<Gamma> h' \\<and>\n       B \\<Gamma> \\<inter> \\<^bold>V \\<subseteq> SAT \\<Gamma> h'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>h'.\n       current \\<Gamma> h' \\<and>\n       wave \\<Gamma> h' \\<and>\n       B \\<Gamma> \\<inter> \\<^bold>V \\<subseteq> SAT \\<Gamma> h'", "write Inner (\"\\<langle>_\\<rangle>\")"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>h'.\n       current \\<Gamma> h' \\<and>\n       wave \\<Gamma> h' \\<and>\n       B \\<Gamma> \\<inter> \\<^bold>V \\<subseteq> SAT \\<Gamma> h'", "define edge'\n    where \"edge' xo yo =\n      (case (xo, yo) of\n        (\\<langle>x\\<rangle>, \\<langle>y\\<rangle>) \\<Rightarrow> edge \\<Gamma> x y \\<or> edge \\<Gamma> y x\n      | (\\<langle>x\\<rangle>, SINK) \\<Rightarrow> x \\<in> A \\<Gamma>\n      | (SOURCE, \\<langle>y\\<rangle>) \\<Rightarrow> y = b\n      | (SINK, \\<langle>x\\<rangle>) \\<Rightarrow> x \\<in> A \\<Gamma>\n      | _ \\<Rightarrow> False)\" for xo yo"], ["proof (state)\nthis:\n  edge' ?xo ?yo =\n  (case (?xo, ?yo) of (SOURCE, \\<langle>y\\<rangle>) \\<Rightarrow> y = b\n   | (SOURCE, _) \\<Rightarrow> False\n   | (vertex.SINK, \\<langle>x\\<rangle>) \\<Rightarrow> x \\<in> A \\<Gamma>\n   | (vertex.SINK, _) \\<Rightarrow> False\n   | (\\<langle>x\\<rangle>, SOURCE) \\<Rightarrow> False\n   | (\\<langle>x\\<rangle>, vertex.SINK) \\<Rightarrow> x \\<in> A \\<Gamma>\n   | (\\<langle>x\\<rangle>, \\<langle>y\\<rangle>) \\<Rightarrow>\n       edge \\<Gamma> x y \\<or> edge \\<Gamma> y x)\n\ngoal (1 subgoal):\n 1. \\<exists>h'.\n       current \\<Gamma> h' \\<and>\n       wave \\<Gamma> h' \\<and>\n       B \\<Gamma> \\<inter> \\<^bold>V \\<subseteq> SAT \\<Gamma> h'", "have edge'_simps [simp]:\n    \"edge' \\<langle>x\\<rangle> \\<langle>y\\<rangle> \\<longleftrightarrow> edge \\<Gamma> x y \\<or> edge \\<Gamma> y x\"\n    \"edge' \\<langle>x\\<rangle> SINK \\<longleftrightarrow> x \\<in> A \\<Gamma>\"\n    \"edge' SOURCE yo \\<longleftrightarrow> yo = \\<langle>b\\<rangle>\"\n    \"edge' SINK \\<langle>x\\<rangle> \\<longleftrightarrow> x \\<in> A \\<Gamma>\"\n    \"edge' SINK SINK \\<longleftrightarrow> False\"\n    \"edge' xo SOURCE \\<longleftrightarrow> False\"\n    for x y yo xo"], ["proof (prove)\ngoal (1 subgoal):\n 1. (edge' \\<langle>x\\<rangle> \\<langle>y\\<rangle> =\n     (edge \\<Gamma> x y \\<or> edge \\<Gamma> y x) &&&\n     edge' \\<langle>x\\<rangle> vertex.SINK = (x \\<in> A \\<Gamma>) &&&\n     edge' SOURCE yo = (yo = \\<langle>b\\<rangle>)) &&&\n    edge' vertex.SINK \\<langle>x\\<rangle> = (x \\<in> A \\<Gamma>) &&&\n    edge' vertex.SINK vertex.SINK = False &&& edge' xo SOURCE = False", "by(simp_all add: edge'_def split: vertex.split)"], ["proof (state)\nthis:\n  edge' \\<langle>?x\\<rangle> \\<langle>?y\\<rangle> =\n  (edge \\<Gamma> ?x ?y \\<or> edge \\<Gamma> ?y ?x)\n  edge' \\<langle>?x\\<rangle> vertex.SINK = (?x \\<in> A \\<Gamma>)\n  edge' SOURCE ?yo = (?yo = \\<langle>b\\<rangle>)\n  edge' vertex.SINK \\<langle>?x\\<rangle> = (?x \\<in> A \\<Gamma>)\n  edge' vertex.SINK vertex.SINK = False\n  edge' ?xo SOURCE = False\n\ngoal (1 subgoal):\n 1. \\<exists>h'.\n       current \\<Gamma> h' \\<and>\n       wave \\<Gamma> h' \\<and>\n       B \\<Gamma> \\<inter> \\<^bold>V \\<subseteq> SAT \\<Gamma> h'", "have edge'E: \"thesis\" if \"edge' xo yo\"\n    \"\\<And>x y. \\<lbrakk> xo = \\<langle>x\\<rangle>; yo = \\<langle>y\\<rangle>; edge \\<Gamma> x y \\<or> edge \\<Gamma> y x \\<rbrakk> \\<Longrightarrow> thesis\"\n    \"\\<And>x. \\<lbrakk> xo = \\<langle>x\\<rangle>; yo = SINK; x \\<in> A \\<Gamma> \\<rbrakk> \\<Longrightarrow> thesis\"\n    \"\\<And>x. \\<lbrakk> xo = SOURCE; yo = \\<langle>b\\<rangle> \\<rbrakk> \\<Longrightarrow> thesis\"\n    \"\\<And>y. \\<lbrakk> xo = SINK; yo = \\<langle>y\\<rangle>; y \\<in> A \\<Gamma> \\<rbrakk> \\<Longrightarrow> thesis\"\n    for xo yo thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "using that"], ["proof (prove)\nusing this:\n  edge' xo yo\n  \\<lbrakk>xo = \\<langle>?x\\<rangle>; yo = \\<langle>?y\\<rangle>;\n   edge \\<Gamma> ?x ?y \\<or> edge \\<Gamma> ?y ?x\\<rbrakk>\n  \\<Longrightarrow> thesis\n  \\<lbrakk>xo = \\<langle>?x\\<rangle>; yo = vertex.SINK;\n   ?x \\<in> A \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> thesis\n  \\<lbrakk>xo = SOURCE; yo = \\<langle>b\\<rangle>\\<rbrakk>\n  \\<Longrightarrow> thesis\n  \\<lbrakk>xo = vertex.SINK; yo = \\<langle>?y\\<rangle>;\n   ?y \\<in> A \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "by(auto simp add: edge'_def split: option.split_asm vertex.split_asm)"], ["proof (state)\nthis:\n  \\<lbrakk>edge' ?xo ?yo;\n   \\<And>x y.\n      \\<lbrakk>?xo = \\<langle>x\\<rangle>; ?yo = \\<langle>y\\<rangle>;\n       edge \\<Gamma> x y \\<or> edge \\<Gamma> y x\\<rbrakk>\n      \\<Longrightarrow> ?thesis;\n   \\<And>x.\n      \\<lbrakk>?xo = \\<langle>x\\<rangle>; ?yo = vertex.SINK;\n       x \\<in> A \\<Gamma>\\<rbrakk>\n      \\<Longrightarrow> ?thesis;\n   \\<And>x.\n      \\<lbrakk>?xo = SOURCE; ?yo = \\<langle>b\\<rangle>\\<rbrakk>\n      \\<Longrightarrow> ?thesis;\n   \\<And>y.\n      \\<lbrakk>?xo = vertex.SINK; ?yo = \\<langle>y\\<rangle>;\n       y \\<in> A \\<Gamma>\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. \\<exists>h'.\n       current \\<Gamma> h' \\<and>\n       wave \\<Gamma> h' \\<and>\n       B \\<Gamma> \\<inter> \\<^bold>V \\<subseteq> SAT \\<Gamma> h'", "have edge'_Inner1 [elim!]: \"thesis\" if \"edge' \\<langle>x\\<rangle> yo\"\n    \"\\<And>y. \\<lbrakk> yo = \\<langle>y\\<rangle>; edge \\<Gamma> x y \\<or> edge \\<Gamma> y x \\<rbrakk> \\<Longrightarrow> thesis\"\n    \"\\<lbrakk> yo = SINK; x \\<in> A \\<Gamma> \\<rbrakk> \\<Longrightarrow> thesis\"\n    for x yo thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "using that"], ["proof (prove)\nusing this:\n  edge' \\<langle>x\\<rangle> yo\n  \\<lbrakk>yo = \\<langle>?y1\\<rangle>;\n   edge \\<Gamma> x ?y1 \\<or> edge \\<Gamma> ?y1 x\\<rbrakk>\n  \\<Longrightarrow> thesis\n  \\<lbrakk>yo = vertex.SINK; x \\<in> A \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "by(auto elim: edge'E)"], ["proof (state)\nthis:\n  \\<lbrakk>edge' \\<langle>?x1\\<rangle> ?yo1;\n   \\<And>y.\n      \\<lbrakk>?yo1 = \\<langle>y\\<rangle>;\n       edge \\<Gamma> ?x1 y \\<or> edge \\<Gamma> y ?x1\\<rbrakk>\n      \\<Longrightarrow> ?thesis1;\n   \\<lbrakk>?yo1 = vertex.SINK; ?x1 \\<in> A \\<Gamma>\\<rbrakk>\n   \\<Longrightarrow> ?thesis1\\<rbrakk>\n  \\<Longrightarrow> ?thesis1\n\ngoal (1 subgoal):\n 1. \\<exists>h'.\n       current \\<Gamma> h' \\<and>\n       wave \\<Gamma> h' \\<and>\n       B \\<Gamma> \\<inter> \\<^bold>V \\<subseteq> SAT \\<Gamma> h'", "have edge'_Inner2 [elim!]: \"thesis\" if \"edge' xo \\<langle>y\\<rangle>\"\n    \"\\<And>x. \\<lbrakk> xo = \\<langle>x\\<rangle>; edge \\<Gamma> x y \\<or> edge \\<Gamma> y x \\<rbrakk> \\<Longrightarrow> thesis\"\n    \"\\<lbrakk> xo = SOURCE; y = b \\<rbrakk> \\<Longrightarrow> thesis\"\n    \"\\<lbrakk> xo = SINK; y \\<in> A \\<Gamma> \\<rbrakk> \\<Longrightarrow> thesis\"\n    for xo y thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "using that"], ["proof (prove)\nusing this:\n  edge' xo \\<langle>y\\<rangle>\n  \\<lbrakk>xo = \\<langle>?x1\\<rangle>;\n   edge \\<Gamma> ?x1 y \\<or> edge \\<Gamma> y ?x1\\<rbrakk>\n  \\<Longrightarrow> thesis\n  \\<lbrakk>xo = SOURCE; y = b\\<rbrakk> \\<Longrightarrow> thesis\n  \\<lbrakk>xo = vertex.SINK; y \\<in> A \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "by(auto elim: edge'E)"], ["proof (state)\nthis:\n  \\<lbrakk>edge' ?xo1 \\<langle>?y1\\<rangle>;\n   \\<And>x.\n      \\<lbrakk>?xo1 = \\<langle>x\\<rangle>;\n       edge \\<Gamma> x ?y1 \\<or> edge \\<Gamma> ?y1 x\\<rbrakk>\n      \\<Longrightarrow> ?thesis1;\n   \\<lbrakk>?xo1 = SOURCE; ?y1 = b\\<rbrakk> \\<Longrightarrow> ?thesis1;\n   \\<lbrakk>?xo1 = vertex.SINK; ?y1 \\<in> A \\<Gamma>\\<rbrakk>\n   \\<Longrightarrow> ?thesis1\\<rbrakk>\n  \\<Longrightarrow> ?thesis1\n\ngoal (1 subgoal):\n 1. \\<exists>h'.\n       current \\<Gamma> h' \\<and>\n       wave \\<Gamma> h' \\<and>\n       B \\<Gamma> \\<inter> \\<^bold>V \\<subseteq> SAT \\<Gamma> h'", "have edge'_SINK1 [elim!]: \"thesis\" if \"edge' SINK yo\"\n    \"\\<And>y. \\<lbrakk> yo = \\<langle>y\\<rangle>; y \\<in> A \\<Gamma> \\<rbrakk> \\<Longrightarrow> thesis\"\n    for yo thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "using that"], ["proof (prove)\nusing this:\n  edge' vertex.SINK yo\n  \\<lbrakk>yo = \\<langle>?y1\\<rangle>; ?y1 \\<in> A \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "by(auto elim: edge'E)"], ["proof (state)\nthis:\n  \\<lbrakk>edge' vertex.SINK ?yo1;\n   \\<And>y.\n      \\<lbrakk>?yo1 = \\<langle>y\\<rangle>; y \\<in> A \\<Gamma>\\<rbrakk>\n      \\<Longrightarrow> ?thesis1\\<rbrakk>\n  \\<Longrightarrow> ?thesis1\n\ngoal (1 subgoal):\n 1. \\<exists>h'.\n       current \\<Gamma> h' \\<and>\n       wave \\<Gamma> h' \\<and>\n       B \\<Gamma> \\<inter> \\<^bold>V \\<subseteq> SAT \\<Gamma> h'", "have edge'_SINK2 [elim!]: \"thesis\" if \"edge' xo SINK\"\n    \"\\<And>x. \\<lbrakk> xo = \\<langle>x\\<rangle>; x \\<in> A \\<Gamma> \\<rbrakk> \\<Longrightarrow> thesis\"\n    for xo thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "using that"], ["proof (prove)\nusing this:\n  edge' xo vertex.SINK\n  \\<lbrakk>xo = \\<langle>?x1\\<rangle>; ?x1 \\<in> A \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "by(auto elim: edge'E)"], ["proof (state)\nthis:\n  \\<lbrakk>edge' ?xo1 vertex.SINK;\n   \\<And>x.\n      \\<lbrakk>?xo1 = \\<langle>x\\<rangle>; x \\<in> A \\<Gamma>\\<rbrakk>\n      \\<Longrightarrow> ?thesis1\\<rbrakk>\n  \\<Longrightarrow> ?thesis1\n\ngoal (1 subgoal):\n 1. \\<exists>h'.\n       current \\<Gamma> h' \\<and>\n       wave \\<Gamma> h' \\<and>\n       B \\<Gamma> \\<inter> \\<^bold>V \\<subseteq> SAT \\<Gamma> h'", "define cap\n    where \"cap xoyo =\n      (case xoyo of\n        (\\<langle>x\\<rangle>, \\<langle>y\\<rangle>) \\<Rightarrow> if edge \\<Gamma> x y then h 0 (x, y) else if edge \\<Gamma> y x then max (weight \\<Gamma> x) (weight \\<Gamma> y) else 0\n      | (\\<langle>x\\<rangle>, SINK) \\<Rightarrow> if x \\<in> A \\<Gamma> then weight \\<Gamma> x - d_OUT (h 0) x else 0\n      | (SOURCE, yo) \\<Rightarrow> if yo = \\<langle>b\\<rangle> then weight \\<Gamma> b - d_IN (h 0) b else 0\n      | (SINK, \\<langle>y\\<rangle>) \\<Rightarrow> if y \\<in> A \\<Gamma> then weight \\<Gamma> y else 0\n      | _ \\<Rightarrow> 0)\" for xoyo"], ["proof (state)\nthis:\n  cap ?xoyo =\n  (case ?xoyo of\n   (SOURCE, yo) \\<Rightarrow>\n     if yo = \\<langle>b\\<rangle> then weight \\<Gamma> b - d_IN (h 0) b\n     else 0\n   | (vertex.SINK, \\<langle>y\\<rangle>) \\<Rightarrow>\n       if y \\<in> A \\<Gamma> then weight \\<Gamma> y else 0\n   | (vertex.SINK, _) \\<Rightarrow> 0\n   | (\\<langle>x\\<rangle>, SOURCE) \\<Rightarrow> 0\n   | (\\<langle>x\\<rangle>, vertex.SINK) \\<Rightarrow>\n       if x \\<in> A \\<Gamma> then weight \\<Gamma> x - d_OUT (h 0) x else 0\n   | (\\<langle>x\\<rangle>, \\<langle>y\\<rangle>) \\<Rightarrow>\n       if edge \\<Gamma> x y then h 0 (x, y)\n       else if edge \\<Gamma> y x\n            then max (weight \\<Gamma> x) (weight \\<Gamma> y) else 0)\n\ngoal (1 subgoal):\n 1. \\<exists>h'.\n       current \\<Gamma> h' \\<and>\n       wave \\<Gamma> h' \\<and>\n       B \\<Gamma> \\<inter> \\<^bold>V \\<subseteq> SAT \\<Gamma> h'", "have cap_simps [simp]:\n    \"cap (\\<langle>x\\<rangle>, \\<langle>y\\<rangle>) = (if edge \\<Gamma> x y then h 0 (x, y) else if edge \\<Gamma> y x then max (weight \\<Gamma> x) (weight \\<Gamma> y) else 0)\"\n    \"cap (\\<langle>x\\<rangle>, SINK) = (if x \\<in> A \\<Gamma> then weight \\<Gamma> x - d_OUT (h 0) x else 0)\"\n    \"cap (SOURCE, yo) = (if yo = \\<langle>b\\<rangle> then weight \\<Gamma> b - d_IN (h 0) b else 0)\"\n    \"cap (SINK, \\<langle>y\\<rangle>) = (if y \\<in> A \\<Gamma> then weight \\<Gamma> y else 0)\"\n    \"cap (SINK, SINK) = 0\"\n    \"cap (xo, SOURCE) = 0\"\n    for x y yo xo"], ["proof (prove)\ngoal (1 subgoal):\n 1. (cap (\\<langle>x\\<rangle>, \\<langle>y\\<rangle>) =\n     (if edge \\<Gamma> x y then h 0 (x, y)\n      else if edge \\<Gamma> y x\n           then max (weight \\<Gamma> x) (weight \\<Gamma> y) else 0) &&&\n     cap (\\<langle>x\\<rangle>, vertex.SINK) =\n     (if x \\<in> A \\<Gamma> then weight \\<Gamma> x - d_OUT (h 0) x\n      else 0) &&&\n     cap (SOURCE, yo) =\n     (if yo = \\<langle>b\\<rangle> then weight \\<Gamma> b - d_IN (h 0) b\n      else 0)) &&&\n    cap (vertex.SINK, \\<langle>y\\<rangle>) =\n    (if y \\<in> A \\<Gamma> then weight \\<Gamma> y else 0) &&&\n    cap (vertex.SINK, vertex.SINK) = 0 &&& cap (xo, SOURCE) = 0", "by(simp_all add: cap_def split: vertex.split)"], ["proof (state)\nthis:\n  cap (\\<langle>?x1\\<rangle>, \\<langle>?y1\\<rangle>) =\n  (if edge \\<Gamma> ?x1 ?y1 then h 0 (?x1, ?y1)\n   else if edge \\<Gamma> ?y1 ?x1\n        then max (weight \\<Gamma> ?x1) (weight \\<Gamma> ?y1) else 0)\n  cap (\\<langle>?x1\\<rangle>, vertex.SINK) =\n  (if ?x1 \\<in> A \\<Gamma> then weight \\<Gamma> ?x1 - d_OUT (h 0) ?x1\n   else 0)\n  cap (SOURCE, ?yo1) =\n  (if ?yo1 = \\<langle>b\\<rangle> then weight \\<Gamma> b - d_IN (h 0) b\n   else 0)\n  cap (vertex.SINK, \\<langle>?y1\\<rangle>) =\n  (if ?y1 \\<in> A \\<Gamma> then weight \\<Gamma> ?y1 else 0)\n  cap (vertex.SINK, vertex.SINK) = 0\n  cap (?xo1, SOURCE) = 0\n\ngoal (1 subgoal):\n 1. \\<exists>h'.\n       current \\<Gamma> h' \\<and>\n       wave \\<Gamma> h' \\<and>\n       B \\<Gamma> \\<inter> \\<^bold>V \\<subseteq> SAT \\<Gamma> h'", "define \\<Psi> where \"\\<Psi> = \\<lparr>edge = edge', capacity = cap, source = SOURCE, sink = SINK\\<rparr>\""], ["proof (state)\nthis:\n  \\<Psi> =\n  \\<lparr>edge = edge', capacity = cap, source = SOURCE,\n     sink = vertex.SINK\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<exists>h'.\n       current \\<Gamma> h' \\<and>\n       wave \\<Gamma> h' \\<and>\n       B \\<Gamma> \\<inter> \\<^bold>V \\<subseteq> SAT \\<Gamma> h'", "have \\<Psi>_sel [simp]:\n    \"edge \\<Psi> = edge'\"\n    \"capacity \\<Psi> = cap\"\n    \"source \\<Psi> = SOURCE\"\n    \"sink \\<Psi> = SINK\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (edge \\<Psi> = edge' &&& capacity \\<Psi> = cap) &&&\n    source \\<Psi> = SOURCE &&& sink \\<Psi> = vertex.SINK", "by(simp_all add: \\<Psi>_def)"], ["proof (state)\nthis:\n  edge \\<Psi> = edge'\n  capacity \\<Psi> = cap\n  source \\<Psi> = SOURCE\n  sink \\<Psi> = vertex.SINK\n\ngoal (1 subgoal):\n 1. \\<exists>h'.\n       current \\<Gamma> h' \\<and>\n       wave \\<Gamma> h' \\<and>\n       B \\<Gamma> \\<inter> \\<^bold>V \\<subseteq> SAT \\<Gamma> h'", "have cap_outside1: \"\\<not> vertex \\<Gamma> x \\<Longrightarrow> cap (\\<langle>x\\<rangle>, y) = 0\" for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> vertex \\<Gamma> x \\<Longrightarrow>\n    cap (\\<langle>x\\<rangle>, y) = 0", "using A_vertex"], ["proof (prove)\nusing this:\n  A \\<Gamma> \\<subseteq> \\<^bold>V\n\ngoal (1 subgoal):\n 1. \\<not> vertex \\<Gamma> x \\<Longrightarrow>\n    cap (\\<langle>x\\<rangle>, y) = 0", "by(cases y)(auto simp add: vertex_def)"], ["proof (state)\nthis:\n  \\<not> vertex \\<Gamma> ?x1 \\<Longrightarrow>\n  cap (\\<langle>?x1\\<rangle>, ?y1) = 0\n\ngoal (1 subgoal):\n 1. \\<exists>h'.\n       current \\<Gamma> h' \\<and>\n       wave \\<Gamma> h' \\<and>\n       B \\<Gamma> \\<inter> \\<^bold>V \\<subseteq> SAT \\<Gamma> h'", "have capacity_A_weight: \"d_OUT cap \\<langle>x\\<rangle> \\<le> 2 * weight \\<Gamma> x\" if \"x \\<in> A \\<Gamma>\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT cap \\<langle>x\\<rangle> \\<le> 2 * weight \\<Gamma> x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. d_OUT cap \\<langle>x\\<rangle> \\<le> 2 * weight \\<Gamma> x", "have \"d_OUT cap \\<langle>x\\<rangle> \\<le> (\\<Sum>\\<^sup>+ y. h 0 (x, inner y) * indicator (range Inner) y + weight \\<Gamma> x * indicator {SINK} y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT cap \\<langle>x\\<rangle>\n    \\<le> (\\<Sum>\\<^sup>+ y.\n             h 0 (x, vertex.inner y) * indicator (range Inner) y +\n             weight \\<Gamma> x * indicator {vertex.SINK} y)", "using that disjoint"], ["proof (prove)\nusing this:\n  x \\<in> A \\<Gamma>\n  A \\<Gamma> \\<inter> B \\<Gamma> = {}\n\ngoal (1 subgoal):\n 1. d_OUT cap \\<langle>x\\<rangle>\n    \\<le> (\\<Sum>\\<^sup>+ y.\n             h 0 (x, vertex.inner y) * indicator (range Inner) y +\n             weight \\<Gamma> x * indicator {vertex.SINK} y)", "unfolding d_OUT_def"], ["proof (prove)\nusing this:\n  x \\<in> A \\<Gamma>\n  A \\<Gamma> \\<inter> B \\<Gamma> = {}\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y. cap (\\<langle>x\\<rangle>, y))\n    \\<le> (\\<Sum>\\<^sup>+ y.\n             h 0 (x, vertex.inner y) * indicator (range Inner) y +\n             weight \\<Gamma> x * indicator {vertex.SINK} y)", "by(auto intro!: nn_integral_mono diff_le_self_ennreal simp add: A_in notin_range_Inner  split: split_indicator)"], ["proof (state)\nthis:\n  d_OUT cap \\<langle>x\\<rangle>\n  \\<le> (\\<Sum>\\<^sup>+ y.\n           h 0 (x, vertex.inner y) * indicator (range Inner) y +\n           weight \\<Gamma> x * indicator {vertex.SINK} y)\n\ngoal (1 subgoal):\n 1. d_OUT cap \\<langle>x\\<rangle> \\<le> 2 * weight \\<Gamma> x", "also"], ["proof (state)\nthis:\n  d_OUT cap \\<langle>x\\<rangle>\n  \\<le> (\\<Sum>\\<^sup>+ y.\n           h 0 (x, vertex.inner y) * indicator (range Inner) y +\n           weight \\<Gamma> x * indicator {vertex.SINK} y)\n\ngoal (1 subgoal):\n 1. d_OUT cap \\<langle>x\\<rangle> \\<le> 2 * weight \\<Gamma> x", "have \"\\<dots> = (\\<Sum>\\<^sup>+ y\\<in>range Inner. h 0 (x, inner y)) + weight \\<Gamma> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y.\n       h 0 (x, vertex.inner y) * indicator (range Inner) y +\n       weight \\<Gamma> x * indicator {vertex.SINK} y) =\n    (\\<Sum>\\<^sup>+ y\\<in>range Inner. h 0 (x, vertex.inner y)) +\n    weight \\<Gamma> x", "by(auto simp add: nn_integral_count_space_indicator nn_integral_add)"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y.\n     h 0 (x, vertex.inner y) * indicator (range Inner) y +\n     weight \\<Gamma> x * indicator {vertex.SINK} y) =\n  (\\<Sum>\\<^sup>+ y\\<in>range Inner. h 0 (x, vertex.inner y)) +\n  weight \\<Gamma> x\n\ngoal (1 subgoal):\n 1. d_OUT cap \\<langle>x\\<rangle> \\<le> 2 * weight \\<Gamma> x", "also"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y.\n     h 0 (x, vertex.inner y) * indicator (range Inner) y +\n     weight \\<Gamma> x * indicator {vertex.SINK} y) =\n  (\\<Sum>\\<^sup>+ y\\<in>range Inner. h 0 (x, vertex.inner y)) +\n  weight \\<Gamma> x\n\ngoal (1 subgoal):\n 1. d_OUT cap \\<langle>x\\<rangle> \\<le> 2 * weight \\<Gamma> x", "have \"(\\<Sum>\\<^sup>+ y\\<in>range Inner. h 0 (x, inner y)) = d_OUT (h 0) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y\\<in>range Inner. h 0 (x, vertex.inner y)) =\n    d_OUT (h 0) x", "by(simp add: d_OUT_def nn_integral_count_space_reindex)"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y\\<in>range Inner. h 0 (x, vertex.inner y)) =\n  d_OUT (h 0) x\n\ngoal (1 subgoal):\n 1. d_OUT cap \\<langle>x\\<rangle> \\<le> 2 * weight \\<Gamma> x", "also"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y\\<in>range Inner. h 0 (x, vertex.inner y)) =\n  d_OUT (h 0) x\n\ngoal (1 subgoal):\n 1. d_OUT cap \\<langle>x\\<rangle> \\<le> 2 * weight \\<Gamma> x", "have \"\\<dots> \\<le> weight \\<Gamma> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT (h 0) x \\<le> weight \\<Gamma> x", "using h"], ["proof (prove)\nusing this:\n  current \\<Gamma> (h ?n)\n\ngoal (1 subgoal):\n 1. d_OUT (h 0) x \\<le> weight \\<Gamma> x", "by(rule currentD_weight_OUT)"], ["proof (state)\nthis:\n  d_OUT (h 0) x \\<le> weight \\<Gamma> x\n\ngoal (1 subgoal):\n 1. d_OUT cap \\<langle>x\\<rangle> \\<le> 2 * weight \\<Gamma> x", "finally"], ["proof (chain)\npicking this:\n  (\\<And>xa y.\n      xa \\<le> y \\<Longrightarrow>\n      xa + weight \\<Gamma> x \\<le> y + weight \\<Gamma> x) \\<Longrightarrow>\n  d_OUT cap \\<langle>x\\<rangle> \\<le> weight \\<Gamma> x + weight \\<Gamma> x", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<And>xa y.\n      xa \\<le> y \\<Longrightarrow>\n      xa + weight \\<Gamma> x \\<le> y + weight \\<Gamma> x) \\<Longrightarrow>\n  d_OUT cap \\<langle>x\\<rangle> \\<le> weight \\<Gamma> x + weight \\<Gamma> x\n\ngoal (1 subgoal):\n 1. d_OUT cap \\<langle>x\\<rangle> \\<le> 2 * weight \\<Gamma> x", "unfolding one_add_one[symmetric] distrib_right"], ["proof (prove)\nusing this:\n  (\\<And>xa y.\n      xa \\<le> y \\<Longrightarrow>\n      xa + weight \\<Gamma> x \\<le> y + weight \\<Gamma> x) \\<Longrightarrow>\n  d_OUT cap \\<langle>x\\<rangle> \\<le> weight \\<Gamma> x + weight \\<Gamma> x\n\ngoal (1 subgoal):\n 1. d_OUT cap \\<langle>x\\<rangle>\n    \\<le> 1 * weight \\<Gamma> x + 1 * weight \\<Gamma> x", "by(simp add: add_right_mono)"], ["proof (state)\nthis:\n  d_OUT cap \\<langle>x\\<rangle> \\<le> 2 * weight \\<Gamma> x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?x1 \\<in> A \\<Gamma> \\<Longrightarrow>\n  d_OUT cap \\<langle>?x1\\<rangle> \\<le> 2 * weight \\<Gamma> ?x1\n\ngoal (1 subgoal):\n 1. \\<exists>h'.\n       current \\<Gamma> h' \\<and>\n       wave \\<Gamma> h' \\<and>\n       B \\<Gamma> \\<inter> \\<^bold>V \\<subseteq> SAT \\<Gamma> h'", "have flow_attainability: \"flow_attainability \\<Psi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. flow_attainability \\<Psi>", "proof"], ["proof (state)\ngoal (7 subgoals):\n 1. countable \\<^bold>E\\<^bsub>\\<Psi>\\<^esub>\n 2. source \\<Psi> \\<noteq> sink \\<Psi>\n 3. \\<And>e.\n       e \\<notin> \\<^bold>E\\<^bsub>\\<Psi>\\<^esub> \\<Longrightarrow>\n       capacity \\<Psi> e = 0\n 4. \\<And>e. capacity \\<Psi> e \\<noteq> \\<top>\n 5. \\<And>x.\n       x \\<noteq> sink \\<Psi> \\<Longrightarrow>\n       d_IN (capacity \\<Psi>) x \\<noteq> \\<top> \\<or>\n       d_OUT (capacity \\<Psi>) x \\<noteq> \\<top>\n 6. \\<And>x. \\<not> edge \\<Psi> x x\n 7. \\<And>x. \\<not> edge \\<Psi> x (source \\<Psi>)", "have \"\\<^bold>E\\<^bsub>\\<Psi>\\<^esub> \\<subseteq> (\\<lambda>(x, y). (\\<langle>x\\<rangle>, \\<langle>y\\<rangle>)) ` \\<^bold>E \\<union> (\\<lambda>(x, y). (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>)) ` \\<^bold>E \\<union> (\\<lambda>x. (\\<langle>x\\<rangle>, SINK)) ` A \\<Gamma> \\<union> (\\<lambda>x. (SINK, \\<langle>x\\<rangle>)) ` A \\<Gamma> \\<union> {(SOURCE, \\<langle>b\\<rangle>)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<^bold>E\\<^bsub>\\<Psi>\\<^esub>\n    \\<subseteq> (\\<lambda>(x, y).\n                    (\\<langle>x\\<rangle>, \\<langle>y\\<rangle>)) `\n                \\<^bold>E \\<union>\n                (\\<lambda>(x, y).\n                    (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>)) `\n                \\<^bold>E \\<union>\n                (\\<lambda>x. (\\<langle>x\\<rangle>, vertex.SINK)) `\n                A \\<Gamma> \\<union>\n                (\\<lambda>x. (vertex.SINK, \\<langle>x\\<rangle>)) `\n                A \\<Gamma> \\<union>\n                {(SOURCE, \\<langle>b\\<rangle>)}", "by(auto simp add: edge'_def split: vertex.split_asm)"], ["proof (state)\nthis:\n  \\<^bold>E\\<^bsub>\\<Psi>\\<^esub>\n  \\<subseteq> (\\<lambda>(x, y).\n                  (\\<langle>x\\<rangle>, \\<langle>y\\<rangle>)) `\n              \\<^bold>E \\<union>\n              (\\<lambda>(x, y).\n                  (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>)) `\n              \\<^bold>E \\<union>\n              (\\<lambda>x. (\\<langle>x\\<rangle>, vertex.SINK)) `\n              A \\<Gamma> \\<union>\n              (\\<lambda>x. (vertex.SINK, \\<langle>x\\<rangle>)) `\n              A \\<Gamma> \\<union>\n              {(SOURCE, \\<langle>b\\<rangle>)}\n\ngoal (7 subgoals):\n 1. countable \\<^bold>E\\<^bsub>\\<Psi>\\<^esub>\n 2. source \\<Psi> \\<noteq> sink \\<Psi>\n 3. \\<And>e.\n       e \\<notin> \\<^bold>E\\<^bsub>\\<Psi>\\<^esub> \\<Longrightarrow>\n       capacity \\<Psi> e = 0\n 4. \\<And>e. capacity \\<Psi> e \\<noteq> \\<top>\n 5. \\<And>x.\n       x \\<noteq> sink \\<Psi> \\<Longrightarrow>\n       d_IN (capacity \\<Psi>) x \\<noteq> \\<top> \\<or>\n       d_OUT (capacity \\<Psi>) x \\<noteq> \\<top>\n 6. \\<And>x. \\<not> edge \\<Psi> x x\n 7. \\<And>x. \\<not> edge \\<Psi> x (source \\<Psi>)", "moreover"], ["proof (state)\nthis:\n  \\<^bold>E\\<^bsub>\\<Psi>\\<^esub>\n  \\<subseteq> (\\<lambda>(x, y).\n                  (\\<langle>x\\<rangle>, \\<langle>y\\<rangle>)) `\n              \\<^bold>E \\<union>\n              (\\<lambda>(x, y).\n                  (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>)) `\n              \\<^bold>E \\<union>\n              (\\<lambda>x. (\\<langle>x\\<rangle>, vertex.SINK)) `\n              A \\<Gamma> \\<union>\n              (\\<lambda>x. (vertex.SINK, \\<langle>x\\<rangle>)) `\n              A \\<Gamma> \\<union>\n              {(SOURCE, \\<langle>b\\<rangle>)}\n\ngoal (7 subgoals):\n 1. countable \\<^bold>E\\<^bsub>\\<Psi>\\<^esub>\n 2. source \\<Psi> \\<noteq> sink \\<Psi>\n 3. \\<And>e.\n       e \\<notin> \\<^bold>E\\<^bsub>\\<Psi>\\<^esub> \\<Longrightarrow>\n       capacity \\<Psi> e = 0\n 4. \\<And>e. capacity \\<Psi> e \\<noteq> \\<top>\n 5. \\<And>x.\n       x \\<noteq> sink \\<Psi> \\<Longrightarrow>\n       d_IN (capacity \\<Psi>) x \\<noteq> \\<top> \\<or>\n       d_OUT (capacity \\<Psi>) x \\<noteq> \\<top>\n 6. \\<And>x. \\<not> edge \\<Psi> x x\n 7. \\<And>x. \\<not> edge \\<Psi> x (source \\<Psi>)", "have \"countable (A \\<Gamma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. countable (A \\<Gamma>)", "using A_vertex"], ["proof (prove)\nusing this:\n  A \\<Gamma> \\<subseteq> \\<^bold>V\n\ngoal (1 subgoal):\n 1. countable (A \\<Gamma>)", "by(rule countable_subset) simp"], ["proof (state)\nthis:\n  countable (A \\<Gamma>)\n\ngoal (7 subgoals):\n 1. countable \\<^bold>E\\<^bsub>\\<Psi>\\<^esub>\n 2. source \\<Psi> \\<noteq> sink \\<Psi>\n 3. \\<And>e.\n       e \\<notin> \\<^bold>E\\<^bsub>\\<Psi>\\<^esub> \\<Longrightarrow>\n       capacity \\<Psi> e = 0\n 4. \\<And>e. capacity \\<Psi> e \\<noteq> \\<top>\n 5. \\<And>x.\n       x \\<noteq> sink \\<Psi> \\<Longrightarrow>\n       d_IN (capacity \\<Psi>) x \\<noteq> \\<top> \\<or>\n       d_OUT (capacity \\<Psi>) x \\<noteq> \\<top>\n 6. \\<And>x. \\<not> edge \\<Psi> x x\n 7. \\<And>x. \\<not> edge \\<Psi> x (source \\<Psi>)", "ultimately"], ["proof (chain)\npicking this:\n  \\<^bold>E\\<^bsub>\\<Psi>\\<^esub>\n  \\<subseteq> (\\<lambda>(x, y).\n                  (\\<langle>x\\<rangle>, \\<langle>y\\<rangle>)) `\n              \\<^bold>E \\<union>\n              (\\<lambda>(x, y).\n                  (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>)) `\n              \\<^bold>E \\<union>\n              (\\<lambda>x. (\\<langle>x\\<rangle>, vertex.SINK)) `\n              A \\<Gamma> \\<union>\n              (\\<lambda>x. (vertex.SINK, \\<langle>x\\<rangle>)) `\n              A \\<Gamma> \\<union>\n              {(SOURCE, \\<langle>b\\<rangle>)}\n  countable (A \\<Gamma>)", "show \"countable \\<^bold>E\\<^bsub>\\<Psi>\\<^esub>\""], ["proof (prove)\nusing this:\n  \\<^bold>E\\<^bsub>\\<Psi>\\<^esub>\n  \\<subseteq> (\\<lambda>(x, y).\n                  (\\<langle>x\\<rangle>, \\<langle>y\\<rangle>)) `\n              \\<^bold>E \\<union>\n              (\\<lambda>(x, y).\n                  (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>)) `\n              \\<^bold>E \\<union>\n              (\\<lambda>x. (\\<langle>x\\<rangle>, vertex.SINK)) `\n              A \\<Gamma> \\<union>\n              (\\<lambda>x. (vertex.SINK, \\<langle>x\\<rangle>)) `\n              A \\<Gamma> \\<union>\n              {(SOURCE, \\<langle>b\\<rangle>)}\n  countable (A \\<Gamma>)\n\ngoal (1 subgoal):\n 1. countable \\<^bold>E\\<^bsub>\\<Psi>\\<^esub>", "by(auto elim: countable_subset)"], ["proof (state)\nthis:\n  countable \\<^bold>E\\<^bsub>\\<Psi>\\<^esub>\n\ngoal (6 subgoals):\n 1. source \\<Psi> \\<noteq> sink \\<Psi>\n 2. \\<And>e.\n       e \\<notin> \\<^bold>E\\<^bsub>\\<Psi>\\<^esub> \\<Longrightarrow>\n       capacity \\<Psi> e = 0\n 3. \\<And>e. capacity \\<Psi> e \\<noteq> \\<top>\n 4. \\<And>x.\n       x \\<noteq> sink \\<Psi> \\<Longrightarrow>\n       d_IN (capacity \\<Psi>) x \\<noteq> \\<top> \\<or>\n       d_OUT (capacity \\<Psi>) x \\<noteq> \\<top>\n 5. \\<And>x. \\<not> edge \\<Psi> x x\n 6. \\<And>x. \\<not> edge \\<Psi> x (source \\<Psi>)", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. source \\<Psi> \\<noteq> sink \\<Psi>\n 2. \\<And>e.\n       e \\<notin> \\<^bold>E\\<^bsub>\\<Psi>\\<^esub> \\<Longrightarrow>\n       capacity \\<Psi> e = 0\n 3. \\<And>e. capacity \\<Psi> e \\<noteq> \\<top>\n 4. \\<And>x.\n       x \\<noteq> sink \\<Psi> \\<Longrightarrow>\n       d_IN (capacity \\<Psi>) x \\<noteq> \\<top> \\<or>\n       d_OUT (capacity \\<Psi>) x \\<noteq> \\<top>\n 5. \\<And>x. \\<not> edge \\<Psi> x x\n 6. \\<And>x. \\<not> edge \\<Psi> x (source \\<Psi>)", "fix v"], ["proof (state)\ngoal (6 subgoals):\n 1. source \\<Psi> \\<noteq> sink \\<Psi>\n 2. \\<And>e.\n       e \\<notin> \\<^bold>E\\<^bsub>\\<Psi>\\<^esub> \\<Longrightarrow>\n       capacity \\<Psi> e = 0\n 3. \\<And>e. capacity \\<Psi> e \\<noteq> \\<top>\n 4. \\<And>x.\n       x \\<noteq> sink \\<Psi> \\<Longrightarrow>\n       d_IN (capacity \\<Psi>) x \\<noteq> \\<top> \\<or>\n       d_OUT (capacity \\<Psi>) x \\<noteq> \\<top>\n 5. \\<And>x. \\<not> edge \\<Psi> x x\n 6. \\<And>x. \\<not> edge \\<Psi> x (source \\<Psi>)", "assume \"v \\<noteq> sink \\<Psi>\""], ["proof (state)\nthis:\n  v \\<noteq> sink \\<Psi>\n\ngoal (6 subgoals):\n 1. source \\<Psi> \\<noteq> sink \\<Psi>\n 2. \\<And>e.\n       e \\<notin> \\<^bold>E\\<^bsub>\\<Psi>\\<^esub> \\<Longrightarrow>\n       capacity \\<Psi> e = 0\n 3. \\<And>e. capacity \\<Psi> e \\<noteq> \\<top>\n 4. \\<And>x.\n       x \\<noteq> sink \\<Psi> \\<Longrightarrow>\n       d_IN (capacity \\<Psi>) x \\<noteq> \\<top> \\<or>\n       d_OUT (capacity \\<Psi>) x \\<noteq> \\<top>\n 5. \\<And>x. \\<not> edge \\<Psi> x x\n 6. \\<And>x. \\<not> edge \\<Psi> x (source \\<Psi>)", "then"], ["proof (chain)\npicking this:\n  v \\<noteq> sink \\<Psi>", "consider (source) \"v = SOURCE\" | (A) x where \"v = \\<langle>x\\<rangle>\" \"x \\<in> A \\<Gamma>\"\n      | (B) y where \"v = \\<langle>y\\<rangle>\" \"y \\<notin> A \\<Gamma>\" \"y \\<in> \\<^bold>V\" | (outside) x where \"v = \\<langle>x\\<rangle>\" \"x \\<notin> \\<^bold>V\""], ["proof (prove)\nusing this:\n  v \\<noteq> sink \\<Psi>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>v = SOURCE \\<Longrightarrow> thesis;\n     \\<And>x.\n        \\<lbrakk>v = \\<langle>x\\<rangle>; x \\<in> A \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<And>y.\n        \\<lbrakk>v = \\<langle>y\\<rangle>; y \\<notin> A \\<Gamma>;\n         y \\<in> \\<^bold>V\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<And>x.\n        \\<lbrakk>v = \\<langle>x\\<rangle>; x \\<notin> \\<^bold>V\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by(cases v) auto"], ["proof (state)\nthis:\n  \\<lbrakk>v = SOURCE \\<Longrightarrow> ?thesis1;\n   \\<And>x.\n      \\<lbrakk>v = \\<langle>x\\<rangle>; x \\<in> A \\<Gamma>\\<rbrakk>\n      \\<Longrightarrow> ?thesis1;\n   \\<And>y.\n      \\<lbrakk>v = \\<langle>y\\<rangle>; y \\<notin> A \\<Gamma>;\n       y \\<in> \\<^bold>V\\<rbrakk>\n      \\<Longrightarrow> ?thesis1;\n   \\<And>x.\n      \\<lbrakk>v = \\<langle>x\\<rangle>; x \\<notin> \\<^bold>V\\<rbrakk>\n      \\<Longrightarrow> ?thesis1\\<rbrakk>\n  \\<Longrightarrow> ?thesis1\n\ngoal (6 subgoals):\n 1. source \\<Psi> \\<noteq> sink \\<Psi>\n 2. \\<And>e.\n       e \\<notin> \\<^bold>E\\<^bsub>\\<Psi>\\<^esub> \\<Longrightarrow>\n       capacity \\<Psi> e = 0\n 3. \\<And>e. capacity \\<Psi> e \\<noteq> \\<top>\n 4. \\<And>x.\n       x \\<noteq> sink \\<Psi> \\<Longrightarrow>\n       d_IN (capacity \\<Psi>) x \\<noteq> \\<top> \\<or>\n       d_OUT (capacity \\<Psi>) x \\<noteq> \\<top>\n 5. \\<And>x. \\<not> edge \\<Psi> x x\n 6. \\<And>x. \\<not> edge \\<Psi> x (source \\<Psi>)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>v = SOURCE \\<Longrightarrow> ?thesis1;\n   \\<And>x.\n      \\<lbrakk>v = \\<langle>x\\<rangle>; x \\<in> A \\<Gamma>\\<rbrakk>\n      \\<Longrightarrow> ?thesis1;\n   \\<And>y.\n      \\<lbrakk>v = \\<langle>y\\<rangle>; y \\<notin> A \\<Gamma>;\n       y \\<in> \\<^bold>V\\<rbrakk>\n      \\<Longrightarrow> ?thesis1;\n   \\<And>x.\n      \\<lbrakk>v = \\<langle>x\\<rangle>; x \\<notin> \\<^bold>V\\<rbrakk>\n      \\<Longrightarrow> ?thesis1\\<rbrakk>\n  \\<Longrightarrow> ?thesis1", "show \"d_IN (capacity \\<Psi>) v \\<noteq> \\<top> \\<or> d_OUT (capacity \\<Psi>) v \\<noteq> \\<top>\""], ["proof (prove)\nusing this:\n  \\<lbrakk>v = SOURCE \\<Longrightarrow> ?thesis1;\n   \\<And>x.\n      \\<lbrakk>v = \\<langle>x\\<rangle>; x \\<in> A \\<Gamma>\\<rbrakk>\n      \\<Longrightarrow> ?thesis1;\n   \\<And>y.\n      \\<lbrakk>v = \\<langle>y\\<rangle>; y \\<notin> A \\<Gamma>;\n       y \\<in> \\<^bold>V\\<rbrakk>\n      \\<Longrightarrow> ?thesis1;\n   \\<And>x.\n      \\<lbrakk>v = \\<langle>x\\<rangle>; x \\<notin> \\<^bold>V\\<rbrakk>\n      \\<Longrightarrow> ?thesis1\\<rbrakk>\n  \\<Longrightarrow> ?thesis1\n\ngoal (1 subgoal):\n 1. d_IN (capacity \\<Psi>) v \\<noteq> \\<top> \\<or>\n    d_OUT (capacity \\<Psi>) v \\<noteq> \\<top>", "proof cases"], ["proof (state)\ngoal (4 subgoals):\n 1. v = SOURCE \\<Longrightarrow>\n    d_IN (capacity \\<Psi>) v \\<noteq> \\<top> \\<or>\n    d_OUT (capacity \\<Psi>) v \\<noteq> \\<top>\n 2. \\<And>x.\n       \\<lbrakk>v = \\<langle>x\\<rangle>; x \\<in> A \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> d_IN (capacity \\<Psi>) v \\<noteq> \\<top> \\<or>\n                         d_OUT (capacity \\<Psi>) v \\<noteq> \\<top>\n 3. \\<And>y.\n       \\<lbrakk>v = \\<langle>y\\<rangle>; y \\<notin> A \\<Gamma>;\n        y \\<in> \\<^bold>V\\<rbrakk>\n       \\<Longrightarrow> d_IN (capacity \\<Psi>) v \\<noteq> \\<top> \\<or>\n                         d_OUT (capacity \\<Psi>) v \\<noteq> \\<top>\n 4. \\<And>x.\n       \\<lbrakk>v = \\<langle>x\\<rangle>; x \\<notin> \\<^bold>V\\<rbrakk>\n       \\<Longrightarrow> d_IN (capacity \\<Psi>) v \\<noteq> \\<top> \\<or>\n                         d_OUT (capacity \\<Psi>) v \\<noteq> \\<top>", "case source"], ["proof (state)\nthis:\n  v = SOURCE\n\ngoal (4 subgoals):\n 1. v = SOURCE \\<Longrightarrow>\n    d_IN (capacity \\<Psi>) v \\<noteq> \\<top> \\<or>\n    d_OUT (capacity \\<Psi>) v \\<noteq> \\<top>\n 2. \\<And>x.\n       \\<lbrakk>v = \\<langle>x\\<rangle>; x \\<in> A \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> d_IN (capacity \\<Psi>) v \\<noteq> \\<top> \\<or>\n                         d_OUT (capacity \\<Psi>) v \\<noteq> \\<top>\n 3. \\<And>y.\n       \\<lbrakk>v = \\<langle>y\\<rangle>; y \\<notin> A \\<Gamma>;\n        y \\<in> \\<^bold>V\\<rbrakk>\n       \\<Longrightarrow> d_IN (capacity \\<Psi>) v \\<noteq> \\<top> \\<or>\n                         d_OUT (capacity \\<Psi>) v \\<noteq> \\<top>\n 4. \\<And>x.\n       \\<lbrakk>v = \\<langle>x\\<rangle>; x \\<notin> \\<^bold>V\\<rbrakk>\n       \\<Longrightarrow> d_IN (capacity \\<Psi>) v \\<noteq> \\<top> \\<or>\n                         d_OUT (capacity \\<Psi>) v \\<noteq> \\<top>", "thus ?thesis"], ["proof (prove)\nusing this:\n  v = SOURCE\n\ngoal (1 subgoal):\n 1. d_IN (capacity \\<Psi>) v \\<noteq> \\<top> \\<or>\n    d_OUT (capacity \\<Psi>) v \\<noteq> \\<top>", "by(simp add: d_IN_def)"], ["proof (state)\nthis:\n  d_IN (capacity \\<Psi>) v \\<noteq> \\<top> \\<or>\n  d_OUT (capacity \\<Psi>) v \\<noteq> \\<top>\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>v = \\<langle>x\\<rangle>; x \\<in> A \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> d_IN (capacity \\<Psi>) v \\<noteq> \\<top> \\<or>\n                         d_OUT (capacity \\<Psi>) v \\<noteq> \\<top>\n 2. \\<And>y.\n       \\<lbrakk>v = \\<langle>y\\<rangle>; y \\<notin> A \\<Gamma>;\n        y \\<in> \\<^bold>V\\<rbrakk>\n       \\<Longrightarrow> d_IN (capacity \\<Psi>) v \\<noteq> \\<top> \\<or>\n                         d_OUT (capacity \\<Psi>) v \\<noteq> \\<top>\n 3. \\<And>x.\n       \\<lbrakk>v = \\<langle>x\\<rangle>; x \\<notin> \\<^bold>V\\<rbrakk>\n       \\<Longrightarrow> d_IN (capacity \\<Psi>) v \\<noteq> \\<top> \\<or>\n                         d_OUT (capacity \\<Psi>) v \\<noteq> \\<top>", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>v = \\<langle>x\\<rangle>; x \\<in> A \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> d_IN (capacity \\<Psi>) v \\<noteq> \\<top> \\<or>\n                         d_OUT (capacity \\<Psi>) v \\<noteq> \\<top>\n 2. \\<And>y.\n       \\<lbrakk>v = \\<langle>y\\<rangle>; y \\<notin> A \\<Gamma>;\n        y \\<in> \\<^bold>V\\<rbrakk>\n       \\<Longrightarrow> d_IN (capacity \\<Psi>) v \\<noteq> \\<top> \\<or>\n                         d_OUT (capacity \\<Psi>) v \\<noteq> \\<top>\n 3. \\<And>x.\n       \\<lbrakk>v = \\<langle>x\\<rangle>; x \\<notin> \\<^bold>V\\<rbrakk>\n       \\<Longrightarrow> d_IN (capacity \\<Psi>) v \\<noteq> \\<top> \\<or>\n                         d_OUT (capacity \\<Psi>) v \\<noteq> \\<top>", "case (A x)"], ["proof (state)\nthis:\n  v = \\<langle>x\\<rangle>\n  x \\<in> A \\<Gamma>\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>v = \\<langle>x\\<rangle>; x \\<in> A \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> d_IN (capacity \\<Psi>) v \\<noteq> \\<top> \\<or>\n                         d_OUT (capacity \\<Psi>) v \\<noteq> \\<top>\n 2. \\<And>y.\n       \\<lbrakk>v = \\<langle>y\\<rangle>; y \\<notin> A \\<Gamma>;\n        y \\<in> \\<^bold>V\\<rbrakk>\n       \\<Longrightarrow> d_IN (capacity \\<Psi>) v \\<noteq> \\<top> \\<or>\n                         d_OUT (capacity \\<Psi>) v \\<noteq> \\<top>\n 3. \\<And>x.\n       \\<lbrakk>v = \\<langle>x\\<rangle>; x \\<notin> \\<^bold>V\\<rbrakk>\n       \\<Longrightarrow> d_IN (capacity \\<Psi>) v \\<noteq> \\<top> \\<or>\n                         d_OUT (capacity \\<Psi>) v \\<noteq> \\<top>", "thus ?thesis"], ["proof (prove)\nusing this:\n  v = \\<langle>x\\<rangle>\n  x \\<in> A \\<Gamma>\n\ngoal (1 subgoal):\n 1. d_IN (capacity \\<Psi>) v \\<noteq> \\<top> \\<or>\n    d_OUT (capacity \\<Psi>) v \\<noteq> \\<top>", "using capacity_A_weight[of x]"], ["proof (prove)\nusing this:\n  v = \\<langle>x\\<rangle>\n  x \\<in> A \\<Gamma>\n  x \\<in> A \\<Gamma> \\<Longrightarrow>\n  d_OUT cap \\<langle>x\\<rangle> \\<le> 2 * weight \\<Gamma> x\n\ngoal (1 subgoal):\n 1. d_IN (capacity \\<Psi>) v \\<noteq> \\<top> \\<or>\n    d_OUT (capacity \\<Psi>) v \\<noteq> \\<top>", "by (auto simp: top_unique ennreal_mult_eq_top_iff)"], ["proof (state)\nthis:\n  d_IN (capacity \\<Psi>) v \\<noteq> \\<top> \\<or>\n  d_OUT (capacity \\<Psi>) v \\<noteq> \\<top>\n\ngoal (2 subgoals):\n 1. \\<And>y.\n       \\<lbrakk>v = \\<langle>y\\<rangle>; y \\<notin> A \\<Gamma>;\n        y \\<in> \\<^bold>V\\<rbrakk>\n       \\<Longrightarrow> d_IN (capacity \\<Psi>) v \\<noteq> \\<top> \\<or>\n                         d_OUT (capacity \\<Psi>) v \\<noteq> \\<top>\n 2. \\<And>x.\n       \\<lbrakk>v = \\<langle>x\\<rangle>; x \\<notin> \\<^bold>V\\<rbrakk>\n       \\<Longrightarrow> d_IN (capacity \\<Psi>) v \\<noteq> \\<top> \\<or>\n                         d_OUT (capacity \\<Psi>) v \\<noteq> \\<top>", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>y.\n       \\<lbrakk>v = \\<langle>y\\<rangle>; y \\<notin> A \\<Gamma>;\n        y \\<in> \\<^bold>V\\<rbrakk>\n       \\<Longrightarrow> d_IN (capacity \\<Psi>) v \\<noteq> \\<top> \\<or>\n                         d_OUT (capacity \\<Psi>) v \\<noteq> \\<top>\n 2. \\<And>x.\n       \\<lbrakk>v = \\<langle>x\\<rangle>; x \\<notin> \\<^bold>V\\<rbrakk>\n       \\<Longrightarrow> d_IN (capacity \\<Psi>) v \\<noteq> \\<top> \\<or>\n                         d_OUT (capacity \\<Psi>) v \\<noteq> \\<top>", "case (B y)"], ["proof (state)\nthis:\n  v = \\<langle>y\\<rangle>\n  y \\<notin> A \\<Gamma>\n  y \\<in> \\<^bold>V\n\ngoal (2 subgoals):\n 1. \\<And>y.\n       \\<lbrakk>v = \\<langle>y\\<rangle>; y \\<notin> A \\<Gamma>;\n        y \\<in> \\<^bold>V\\<rbrakk>\n       \\<Longrightarrow> d_IN (capacity \\<Psi>) v \\<noteq> \\<top> \\<or>\n                         d_OUT (capacity \\<Psi>) v \\<noteq> \\<top>\n 2. \\<And>x.\n       \\<lbrakk>v = \\<langle>x\\<rangle>; x \\<notin> \\<^bold>V\\<rbrakk>\n       \\<Longrightarrow> d_IN (capacity \\<Psi>) v \\<noteq> \\<top> \\<or>\n                         d_OUT (capacity \\<Psi>) v \\<noteq> \\<top>", "have \"d_IN (capacity \\<Psi>) v \\<le> (\\<Sum>\\<^sup>+ x. h 0 (inner x, y) * indicator (range Inner) x + weight \\<Gamma> b * indicator {SOURCE} x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN (capacity \\<Psi>) v\n    \\<le> (\\<Sum>\\<^sup>+ x.\n             h 0 (vertex.inner x, y) * indicator (range Inner) x +\n             weight \\<Gamma> b * indicator {SOURCE} x)", "using B bipartite_V"], ["proof (prove)\nusing this:\n  v = \\<langle>y\\<rangle>\n  y \\<notin> A \\<Gamma>\n  y \\<in> \\<^bold>V\n  \\<^bold>V \\<subseteq> A \\<Gamma> \\<union> B \\<Gamma>\n\ngoal (1 subgoal):\n 1. d_IN (capacity \\<Psi>) v\n    \\<le> (\\<Sum>\\<^sup>+ x.\n             h 0 (vertex.inner x, y) * indicator (range Inner) x +\n             weight \\<Gamma> b * indicator {SOURCE} x)", "by(auto 4 4 intro!: nn_integral_mono simp add: diff_le_self_ennreal   d_IN_def notin_range_Inner nn_integral_count_space_indicator currentD_outside[OF h] split: split_indicator dest: bipartite_E)"], ["proof (state)\nthis:\n  d_IN (capacity \\<Psi>) v\n  \\<le> (\\<Sum>\\<^sup>+ x.\n           h 0 (vertex.inner x, y) * indicator (range Inner) x +\n           weight \\<Gamma> b * indicator {SOURCE} x)\n\ngoal (2 subgoals):\n 1. \\<And>y.\n       \\<lbrakk>v = \\<langle>y\\<rangle>; y \\<notin> A \\<Gamma>;\n        y \\<in> \\<^bold>V\\<rbrakk>\n       \\<Longrightarrow> d_IN (capacity \\<Psi>) v \\<noteq> \\<top> \\<or>\n                         d_OUT (capacity \\<Psi>) v \\<noteq> \\<top>\n 2. \\<And>x.\n       \\<lbrakk>v = \\<langle>x\\<rangle>; x \\<notin> \\<^bold>V\\<rbrakk>\n       \\<Longrightarrow> d_IN (capacity \\<Psi>) v \\<noteq> \\<top> \\<or>\n                         d_OUT (capacity \\<Psi>) v \\<noteq> \\<top>", "also"], ["proof (state)\nthis:\n  d_IN (capacity \\<Psi>) v\n  \\<le> (\\<Sum>\\<^sup>+ x.\n           h 0 (vertex.inner x, y) * indicator (range Inner) x +\n           weight \\<Gamma> b * indicator {SOURCE} x)\n\ngoal (2 subgoals):\n 1. \\<And>y.\n       \\<lbrakk>v = \\<langle>y\\<rangle>; y \\<notin> A \\<Gamma>;\n        y \\<in> \\<^bold>V\\<rbrakk>\n       \\<Longrightarrow> d_IN (capacity \\<Psi>) v \\<noteq> \\<top> \\<or>\n                         d_OUT (capacity \\<Psi>) v \\<noteq> \\<top>\n 2. \\<And>x.\n       \\<lbrakk>v = \\<langle>x\\<rangle>; x \\<notin> \\<^bold>V\\<rbrakk>\n       \\<Longrightarrow> d_IN (capacity \\<Psi>) v \\<noteq> \\<top> \\<or>\n                         d_OUT (capacity \\<Psi>) v \\<noteq> \\<top>", "have \"\\<dots> = (\\<Sum>\\<^sup>+ x\\<in>range Inner. h 0 (inner x, y)) + weight \\<Gamma> b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ x.\n       h 0 (vertex.inner x, y) * indicator (range Inner) x +\n       weight \\<Gamma> b * indicator {SOURCE} x) =\n    (\\<Sum>\\<^sup>+ x\\<in>range Inner. h 0 (vertex.inner x, y)) +\n    weight \\<Gamma> b", "by(simp add: nn_integral_add nn_integral_count_space_indicator)"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ x.\n     h 0 (vertex.inner x, y) * indicator (range Inner) x +\n     weight \\<Gamma> b * indicator {SOURCE} x) =\n  (\\<Sum>\\<^sup>+ x\\<in>range Inner. h 0 (vertex.inner x, y)) +\n  weight \\<Gamma> b\n\ngoal (2 subgoals):\n 1. \\<And>y.\n       \\<lbrakk>v = \\<langle>y\\<rangle>; y \\<notin> A \\<Gamma>;\n        y \\<in> \\<^bold>V\\<rbrakk>\n       \\<Longrightarrow> d_IN (capacity \\<Psi>) v \\<noteq> \\<top> \\<or>\n                         d_OUT (capacity \\<Psi>) v \\<noteq> \\<top>\n 2. \\<And>x.\n       \\<lbrakk>v = \\<langle>x\\<rangle>; x \\<notin> \\<^bold>V\\<rbrakk>\n       \\<Longrightarrow> d_IN (capacity \\<Psi>) v \\<noteq> \\<top> \\<or>\n                         d_OUT (capacity \\<Psi>) v \\<noteq> \\<top>", "also"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ x.\n     h 0 (vertex.inner x, y) * indicator (range Inner) x +\n     weight \\<Gamma> b * indicator {SOURCE} x) =\n  (\\<Sum>\\<^sup>+ x\\<in>range Inner. h 0 (vertex.inner x, y)) +\n  weight \\<Gamma> b\n\ngoal (2 subgoals):\n 1. \\<And>y.\n       \\<lbrakk>v = \\<langle>y\\<rangle>; y \\<notin> A \\<Gamma>;\n        y \\<in> \\<^bold>V\\<rbrakk>\n       \\<Longrightarrow> d_IN (capacity \\<Psi>) v \\<noteq> \\<top> \\<or>\n                         d_OUT (capacity \\<Psi>) v \\<noteq> \\<top>\n 2. \\<And>x.\n       \\<lbrakk>v = \\<langle>x\\<rangle>; x \\<notin> \\<^bold>V\\<rbrakk>\n       \\<Longrightarrow> d_IN (capacity \\<Psi>) v \\<noteq> \\<top> \\<or>\n                         d_OUT (capacity \\<Psi>) v \\<noteq> \\<top>", "have \"(\\<Sum>\\<^sup>+ x\\<in>range Inner. h 0 (inner x, y)) = d_IN (h 0) y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ x\\<in>range Inner. h 0 (vertex.inner x, y)) =\n    d_IN (h 0) y", "by(simp add: d_IN_def nn_integral_count_space_reindex)"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ x\\<in>range Inner. h 0 (vertex.inner x, y)) = d_IN (h 0) y\n\ngoal (2 subgoals):\n 1. \\<And>y.\n       \\<lbrakk>v = \\<langle>y\\<rangle>; y \\<notin> A \\<Gamma>;\n        y \\<in> \\<^bold>V\\<rbrakk>\n       \\<Longrightarrow> d_IN (capacity \\<Psi>) v \\<noteq> \\<top> \\<or>\n                         d_OUT (capacity \\<Psi>) v \\<noteq> \\<top>\n 2. \\<And>x.\n       \\<lbrakk>v = \\<langle>x\\<rangle>; x \\<notin> \\<^bold>V\\<rbrakk>\n       \\<Longrightarrow> d_IN (capacity \\<Psi>) v \\<noteq> \\<top> \\<or>\n                         d_OUT (capacity \\<Psi>) v \\<noteq> \\<top>", "also"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ x\\<in>range Inner. h 0 (vertex.inner x, y)) = d_IN (h 0) y\n\ngoal (2 subgoals):\n 1. \\<And>y.\n       \\<lbrakk>v = \\<langle>y\\<rangle>; y \\<notin> A \\<Gamma>;\n        y \\<in> \\<^bold>V\\<rbrakk>\n       \\<Longrightarrow> d_IN (capacity \\<Psi>) v \\<noteq> \\<top> \\<or>\n                         d_OUT (capacity \\<Psi>) v \\<noteq> \\<top>\n 2. \\<And>x.\n       \\<lbrakk>v = \\<langle>x\\<rangle>; x \\<notin> \\<^bold>V\\<rbrakk>\n       \\<Longrightarrow> d_IN (capacity \\<Psi>) v \\<noteq> \\<top> \\<or>\n                         d_OUT (capacity \\<Psi>) v \\<noteq> \\<top>", "have \"d_IN (h 0) y \\<le> weight \\<Gamma> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN (h 0) y \\<le> weight \\<Gamma> y", "using h"], ["proof (prove)\nusing this:\n  current \\<Gamma> (h ?n)\n\ngoal (1 subgoal):\n 1. d_IN (h 0) y \\<le> weight \\<Gamma> y", "by(rule currentD_weight_IN)"], ["proof (state)\nthis:\n  d_IN (h 0) y \\<le> weight \\<Gamma> y\n\ngoal (2 subgoals):\n 1. \\<And>y.\n       \\<lbrakk>v = \\<langle>y\\<rangle>; y \\<notin> A \\<Gamma>;\n        y \\<in> \\<^bold>V\\<rbrakk>\n       \\<Longrightarrow> d_IN (capacity \\<Psi>) v \\<noteq> \\<top> \\<or>\n                         d_OUT (capacity \\<Psi>) v \\<noteq> \\<top>\n 2. \\<And>x.\n       \\<lbrakk>v = \\<langle>x\\<rangle>; x \\<notin> \\<^bold>V\\<rbrakk>\n       \\<Longrightarrow> d_IN (capacity \\<Psi>) v \\<noteq> \\<top> \\<or>\n                         d_OUT (capacity \\<Psi>) v \\<noteq> \\<top>", "finally"], ["proof (chain)\npicking this:\n  (\\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      x + weight \\<Gamma> b \\<le> y + weight \\<Gamma> b) \\<Longrightarrow>\n  d_IN (capacity \\<Psi>) v \\<le> weight \\<Gamma> y + weight \\<Gamma> b", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      x + weight \\<Gamma> b \\<le> y + weight \\<Gamma> b) \\<Longrightarrow>\n  d_IN (capacity \\<Psi>) v \\<le> weight \\<Gamma> y + weight \\<Gamma> b\n\ngoal (1 subgoal):\n 1. d_IN (capacity \\<Psi>) v \\<noteq> \\<top> \\<or>\n    d_OUT (capacity \\<Psi>) v \\<noteq> \\<top>", "by(auto simp add: top_unique add_right_mono split: if_split_asm)"], ["proof (state)\nthis:\n  d_IN (capacity \\<Psi>) v \\<noteq> \\<top> \\<or>\n  d_OUT (capacity \\<Psi>) v \\<noteq> \\<top>\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>v = \\<langle>x\\<rangle>; x \\<notin> \\<^bold>V\\<rbrakk>\n       \\<Longrightarrow> d_IN (capacity \\<Psi>) v \\<noteq> \\<top> \\<or>\n                         d_OUT (capacity \\<Psi>) v \\<noteq> \\<top>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>v = \\<langle>x\\<rangle>; x \\<notin> \\<^bold>V\\<rbrakk>\n       \\<Longrightarrow> d_IN (capacity \\<Psi>) v \\<noteq> \\<top> \\<or>\n                         d_OUT (capacity \\<Psi>) v \\<noteq> \\<top>", "case outside"], ["proof (state)\nthis:\n  v = \\<langle>x\\<rangle>\n  x \\<notin> \\<^bold>V\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>v = \\<langle>x\\<rangle>; x \\<notin> \\<^bold>V\\<rbrakk>\n       \\<Longrightarrow> d_IN (capacity \\<Psi>) v \\<noteq> \\<top> \\<or>\n                         d_OUT (capacity \\<Psi>) v \\<noteq> \\<top>", "hence \"d_OUT (capacity \\<Psi>) v = 0\""], ["proof (prove)\nusing this:\n  v = \\<langle>x\\<rangle>\n  x \\<notin> \\<^bold>V\n\ngoal (1 subgoal):\n 1. d_OUT (capacity \\<Psi>) v = 0", "using A_vertex"], ["proof (prove)\nusing this:\n  v = \\<langle>x\\<rangle>\n  x \\<notin> \\<^bold>V\n  A \\<Gamma> \\<subseteq> \\<^bold>V\n\ngoal (1 subgoal):\n 1. d_OUT (capacity \\<Psi>) v = 0", "by(auto simp add: d_OUT_def nn_integral_0_iff_AE AE_count_space cap_def vertex_def split: vertex.split)"], ["proof (state)\nthis:\n  d_OUT (capacity \\<Psi>) v = 0\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>v = \\<langle>x\\<rangle>; x \\<notin> \\<^bold>V\\<rbrakk>\n       \\<Longrightarrow> d_IN (capacity \\<Psi>) v \\<noteq> \\<top> \\<or>\n                         d_OUT (capacity \\<Psi>) v \\<noteq> \\<top>", "thus ?thesis"], ["proof (prove)\nusing this:\n  d_OUT (capacity \\<Psi>) v = 0\n\ngoal (1 subgoal):\n 1. d_IN (capacity \\<Psi>) v \\<noteq> \\<top> \\<or>\n    d_OUT (capacity \\<Psi>) v \\<noteq> \\<top>", "by simp"], ["proof (state)\nthis:\n  d_IN (capacity \\<Psi>) v \\<noteq> \\<top> \\<or>\n  d_OUT (capacity \\<Psi>) v \\<noteq> \\<top>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  d_IN (capacity \\<Psi>) v \\<noteq> \\<top> \\<or>\n  d_OUT (capacity \\<Psi>) v \\<noteq> \\<top>\n\ngoal (5 subgoals):\n 1. source \\<Psi> \\<noteq> sink \\<Psi>\n 2. \\<And>e.\n       e \\<notin> \\<^bold>E\\<^bsub>\\<Psi>\\<^esub> \\<Longrightarrow>\n       capacity \\<Psi> e = 0\n 3. \\<And>e. capacity \\<Psi> e \\<noteq> \\<top>\n 4. \\<And>x. \\<not> edge \\<Psi> x x\n 5. \\<And>x. \\<not> edge \\<Psi> x (source \\<Psi>)", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. source \\<Psi> \\<noteq> sink \\<Psi>\n 2. \\<And>e.\n       e \\<notin> \\<^bold>E\\<^bsub>\\<Psi>\\<^esub> \\<Longrightarrow>\n       capacity \\<Psi> e = 0\n 3. \\<And>e. capacity \\<Psi> e \\<noteq> \\<top>\n 4. \\<And>x. \\<not> edge \\<Psi> x x\n 5. \\<And>x. \\<not> edge \\<Psi> x (source \\<Psi>)", "show \"capacity \\<Psi> e \\<noteq> \\<top>\" for e"], ["proof (prove)\ngoal (1 subgoal):\n 1. capacity \\<Psi> e \\<noteq> \\<top>", "by(auto simp add: cap_def max_def vertex_def currentD_finite[OF h] split: vertex.split prod.split)"], ["proof (state)\nthis:\n  capacity \\<Psi> ?e1 \\<noteq> \\<top>\n\ngoal (4 subgoals):\n 1. source \\<Psi> \\<noteq> sink \\<Psi>\n 2. \\<And>e.\n       e \\<notin> \\<^bold>E\\<^bsub>\\<Psi>\\<^esub> \\<Longrightarrow>\n       capacity \\<Psi> e = 0\n 3. \\<And>x. \\<not> edge \\<Psi> x x\n 4. \\<And>x. \\<not> edge \\<Psi> x (source \\<Psi>)", "show \"capacity \\<Psi> e = 0\" if \"e \\<notin> \\<^bold>E\\<^bsub>\\<Psi>\\<^esub>\" for e"], ["proof (prove)\ngoal (1 subgoal):\n 1. capacity \\<Psi> e = 0", "using that"], ["proof (prove)\nusing this:\n  e \\<notin> \\<^bold>E\\<^bsub>\\<Psi>\\<^esub>\n\ngoal (1 subgoal):\n 1. capacity \\<Psi> e = 0", "by(auto simp add: cap_def max_def split: prod.split; split vertex.split)+"], ["proof (state)\nthis:\n  ?e1 \\<notin> \\<^bold>E\\<^bsub>\\<Psi>\\<^esub> \\<Longrightarrow>\n  capacity \\<Psi> ?e1 = 0\n\ngoal (3 subgoals):\n 1. source \\<Psi> \\<noteq> sink \\<Psi>\n 2. \\<And>x. \\<not> edge \\<Psi> x x\n 3. \\<And>x. \\<not> edge \\<Psi> x (source \\<Psi>)", "show \"\\<not> edge \\<Psi> x (source \\<Psi>)\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> edge \\<Psi> x (source \\<Psi>)", "using b"], ["proof (prove)\nusing this:\n  b \\<in> B \\<Gamma>\n\ngoal (1 subgoal):\n 1. \\<not> edge \\<Psi> x (source \\<Psi>)", "by(auto simp add: B_out)"], ["proof (state)\nthis:\n  \\<not> edge \\<Psi> ?x1 (source \\<Psi>)\n\ngoal (2 subgoals):\n 1. source \\<Psi> \\<noteq> sink \\<Psi>\n 2. \\<And>x. \\<not> edge \\<Psi> x x", "show \"\\<not> edge \\<Psi> x x\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> edge \\<Psi> x x", "by(cases x)(simp_all add: no_loop)"], ["proof (state)\nthis:\n  \\<not> edge \\<Psi> ?x1 ?x1\n\ngoal (1 subgoal):\n 1. source \\<Psi> \\<noteq> sink \\<Psi>", "show \"source \\<Psi> \\<noteq> sink \\<Psi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. source \\<Psi> \\<noteq> sink \\<Psi>", "by simp"], ["proof (state)\nthis:\n  source \\<Psi> \\<noteq> sink \\<Psi>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  flow_attainability \\<Psi>\n\ngoal (1 subgoal):\n 1. \\<exists>h'.\n       current \\<Gamma> h' \\<and>\n       wave \\<Gamma> h' \\<and>\n       B \\<Gamma> \\<inter> \\<^bold>V \\<subseteq> SAT \\<Gamma> h'", "then"], ["proof (chain)\npicking this:\n  flow_attainability \\<Psi>", "interpret \\<Psi>: flow_attainability \"\\<Psi>\""], ["proof (prove)\nusing this:\n  flow_attainability \\<Psi>\n\ngoal (1 subgoal):\n 1. flow_attainability \\<Psi>", "."], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>h'.\n       current \\<Gamma> h' \\<and>\n       wave \\<Gamma> h' \\<and>\n       B \\<Gamma> \\<inter> \\<^bold>V \\<subseteq> SAT \\<Gamma> h'", "define \\<alpha> where \"\\<alpha> = (SUP f\\<in>{f. flow \\<Psi> f}. value_flow \\<Psi> f)\""], ["proof (state)\nthis:\n  \\<alpha> = \\<Squnion> (value_flow \\<Psi> ` {f. flow \\<Psi> f})\n\ngoal (1 subgoal):\n 1. \\<exists>h'.\n       current \\<Gamma> h' \\<and>\n       wave \\<Gamma> h' \\<and>\n       B \\<Gamma> \\<inter> \\<^bold>V \\<subseteq> SAT \\<Gamma> h'", "define f\n    where \"f n xoyo =\n    (case xoyo of\n      (\\<langle>x\\<rangle>, \\<langle>y\\<rangle>) \\<Rightarrow> if edge \\<Gamma> x y then h 0 (x, y) - h n (x, y) else if edge \\<Gamma> y x then h n (y, x) - h 0 (y, x) else 0\n    | (SOURCE, \\<langle>y\\<rangle>) \\<Rightarrow> if y = b then d_IN (h n) b - d_IN (h 0) b else 0\n    | (\\<langle>x\\<rangle>, SINK) \\<Rightarrow> if x \\<in> A \\<Gamma> then d_OUT (h n) x - d_OUT (h 0) x else 0\n    | (SINK, \\<langle>y\\<rangle>) \\<Rightarrow> if y \\<in> A \\<Gamma> then d_OUT (h 0) y - d_OUT (h n) y else 0\n    | _ \\<Rightarrow> 0)\" for n xoyo"], ["proof (state)\nthis:\n  f ?n ?xoyo =\n  (case ?xoyo of\n   (SOURCE, \\<langle>y\\<rangle>) \\<Rightarrow>\n     if y = b then d_IN (h ?n) b - d_IN (h 0) b else 0\n   | (SOURCE, _) \\<Rightarrow> 0\n   | (vertex.SINK, \\<langle>y\\<rangle>) \\<Rightarrow>\n       if y \\<in> A \\<Gamma> then d_OUT (h 0) y - d_OUT (h ?n) y else 0\n   | (vertex.SINK, _) \\<Rightarrow> 0\n   | (\\<langle>x\\<rangle>, SOURCE) \\<Rightarrow> 0\n   | (\\<langle>x\\<rangle>, vertex.SINK) \\<Rightarrow>\n       if x \\<in> A \\<Gamma> then d_OUT (h ?n) x - d_OUT (h 0) x else 0\n   | (\\<langle>x\\<rangle>, \\<langle>y\\<rangle>) \\<Rightarrow>\n       if edge \\<Gamma> x y then h 0 (x, y) - h ?n (x, y)\n       else if edge \\<Gamma> y x then h ?n (y, x) - h 0 (y, x) else 0)\n\ngoal (1 subgoal):\n 1. \\<exists>h'.\n       current \\<Gamma> h' \\<and>\n       wave \\<Gamma> h' \\<and>\n       B \\<Gamma> \\<inter> \\<^bold>V \\<subseteq> SAT \\<Gamma> h'", "have f_cases: thesis if \"\\<And>x y. e = (\\<langle>x\\<rangle>, \\<langle>y\\<rangle>) \\<Longrightarrow> thesis\" \"\\<And>y. e = (SOURCE, \\<langle>y\\<rangle>) \\<Longrightarrow> thesis\"\n    \"\\<And>x. e = (\\<langle>x\\<rangle>, SINK) \\<Longrightarrow> thesis\" \"\\<And>y. e = (SINK, \\<langle>y\\<rangle>) \\<Longrightarrow> thesis\" \"e = (SINK, SINK) \\<Longrightarrow> thesis\"\n    \"\\<And>xo. e = (xo, SOURCE) \\<Longrightarrow> thesis\" \"e = (SOURCE, SINK) \\<Longrightarrow> thesis\"\n    for e :: \"'v vertex edge\" and thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "using that"], ["proof (prove)\nusing this:\n  e = (\\<langle>?x1\\<rangle>, \\<langle>?y1\\<rangle>) \\<Longrightarrow>\n  thesis\n  e = (SOURCE, \\<langle>?y1\\<rangle>) \\<Longrightarrow> thesis\n  e = (\\<langle>?x1\\<rangle>, vertex.SINK) \\<Longrightarrow> thesis\n  e = (vertex.SINK, \\<langle>?y1\\<rangle>) \\<Longrightarrow> thesis\n  e = (vertex.SINK, vertex.SINK) \\<Longrightarrow> thesis\n  e = (?xo1, SOURCE) \\<Longrightarrow> thesis\n  e = (SOURCE, vertex.SINK) \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "by(cases e; cases \"fst e\" \"snd e\" rule: vertex.exhaust[case_product vertex.exhaust]) simp_all"], ["proof (state)\nthis:\n  \\<lbrakk>\\<And>x y.\n              ?e1 =\n              (\\<langle>x\\<rangle>, \\<langle>y\\<rangle>) \\<Longrightarrow>\n              ?thesis1;\n   \\<And>y. ?e1 = (SOURCE, \\<langle>y\\<rangle>) \\<Longrightarrow> ?thesis1;\n   \\<And>x.\n      ?e1 = (\\<langle>x\\<rangle>, vertex.SINK) \\<Longrightarrow> ?thesis1;\n   \\<And>y.\n      ?e1 = (vertex.SINK, \\<langle>y\\<rangle>) \\<Longrightarrow> ?thesis1;\n   ?e1 = (vertex.SINK, vertex.SINK) \\<Longrightarrow> ?thesis1;\n   \\<And>xo. ?e1 = (xo, SOURCE) \\<Longrightarrow> ?thesis1;\n   ?e1 = (SOURCE, vertex.SINK) \\<Longrightarrow> ?thesis1\\<rbrakk>\n  \\<Longrightarrow> ?thesis1\n\ngoal (1 subgoal):\n 1. \\<exists>h'.\n       current \\<Gamma> h' \\<and>\n       wave \\<Gamma> h' \\<and>\n       B \\<Gamma> \\<inter> \\<^bold>V \\<subseteq> SAT \\<Gamma> h'", "have f_simps [simp]:\n    \"f n (\\<langle>x\\<rangle>, \\<langle>y\\<rangle>) = (if edge \\<Gamma> x y then h 0 (x, y) - h n (x, y) else if edge \\<Gamma> y x then h n (y, x) - h 0 (y, x) else 0)\"\n    \"f n (SOURCE, \\<langle>y\\<rangle>) = (if y = b then d_IN (h n) b - d_IN (h 0) b else 0)\"\n    \"f n (\\<langle>x\\<rangle>, SINK) = (if x \\<in> A \\<Gamma> then d_OUT (h n) x - d_OUT (h 0) x else 0)\"\n    \"f n (SINK, \\<langle>y\\<rangle>) = (if y \\<in> A \\<Gamma> then d_OUT (h 0) y - d_OUT (h n) y else 0)\"\n    \"f n (SOURCE, SINK) = 0\"\n    \"f n (SINK, SINK) = 0\"\n    \"f n (xo, SOURCE) = 0\"\n    for n x y xo"], ["proof (prove)\ngoal (1 subgoal):\n 1. (f n (\\<langle>x\\<rangle>, \\<langle>y\\<rangle>) =\n     (if edge \\<Gamma> x y then h 0 (x, y) - h n (x, y)\n      else if edge \\<Gamma> y x then h n (y, x) - h 0 (y, x) else 0) &&&\n     f n (SOURCE, \\<langle>y\\<rangle>) =\n     (if y = b then d_IN (h n) b - d_IN (h 0) b else 0) &&&\n     f n (\\<langle>x\\<rangle>, vertex.SINK) =\n     (if x \\<in> A \\<Gamma> then d_OUT (h n) x - d_OUT (h 0) x else 0)) &&&\n    (f n (vertex.SINK, \\<langle>y\\<rangle>) =\n     (if y \\<in> A \\<Gamma> then d_OUT (h 0) y - d_OUT (h n) y else 0) &&&\n     f n (SOURCE, vertex.SINK) = 0) &&&\n    f n (vertex.SINK, vertex.SINK) = 0 &&& f n (xo, SOURCE) = 0", "by(simp_all add: f_def split: vertex.split)"], ["proof (state)\nthis:\n  f ?n1 (\\<langle>?x1\\<rangle>, \\<langle>?y1\\<rangle>) =\n  (if edge \\<Gamma> ?x1 ?y1 then h 0 (?x1, ?y1) - h ?n1 (?x1, ?y1)\n   else if edge \\<Gamma> ?y1 ?x1 then h ?n1 (?y1, ?x1) - h 0 (?y1, ?x1)\n        else 0)\n  f ?n1 (SOURCE, \\<langle>?y1\\<rangle>) =\n  (if ?y1 = b then d_IN (h ?n1) b - d_IN (h 0) b else 0)\n  f ?n1 (\\<langle>?x1\\<rangle>, vertex.SINK) =\n  (if ?x1 \\<in> A \\<Gamma> then d_OUT (h ?n1) ?x1 - d_OUT (h 0) ?x1 else 0)\n  f ?n1 (vertex.SINK, \\<langle>?y1\\<rangle>) =\n  (if ?y1 \\<in> A \\<Gamma> then d_OUT (h 0) ?y1 - d_OUT (h ?n1) ?y1 else 0)\n  f ?n1 (SOURCE, vertex.SINK) = 0\n  f ?n1 (vertex.SINK, vertex.SINK) = 0\n  f ?n1 (?xo1, SOURCE) = 0\n\ngoal (1 subgoal):\n 1. \\<exists>h'.\n       current \\<Gamma> h' \\<and>\n       wave \\<Gamma> h' \\<and>\n       B \\<Gamma> \\<inter> \\<^bold>V \\<subseteq> SAT \\<Gamma> h'", "have OUT_f_SOURCE: \"d_OUT (f n) SOURCE = d_IN (h n) b - d_IN (h 0) b\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT (f n) SOURCE = d_IN (h n) b - d_IN (h 0) b", "proof(rule trans)"], ["proof (state)\ngoal (2 subgoals):\n 1. d_OUT (f n) SOURCE = ?s\n 2. ?s = d_IN (h n) b - d_IN (h 0) b", "show \"d_OUT (f n) SOURCE = (\\<Sum>\\<^sup>+ y. f n (SOURCE, y) * indicator {\\<langle>b\\<rangle>} y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT (f n) SOURCE =\n    \\<integral>\\<^sup>+y\\<in>{\\<langle>b\\<rangle>}. f n (SOURCE, y)\n    \\<partial>count_space UNIV", "unfolding d_OUT_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y. f n (SOURCE, y)) =\n    \\<integral>\\<^sup>+y\\<in>{\\<langle>b\\<rangle>}. f n (SOURCE, y)\n    \\<partial>count_space UNIV", "apply(rule nn_integral_cong)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> space (count_space UNIV) \\<Longrightarrow>\n       f n (SOURCE, x) = f n (SOURCE, x) * indicator {\\<langle>b\\<rangle>} x", "subgoal for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> space (count_space UNIV) \\<Longrightarrow>\n    f n (SOURCE, x) = f n (SOURCE, x) * indicator {\\<langle>b\\<rangle>} x", "by(cases x) auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  d_OUT (f n) SOURCE =\n  \\<integral>\\<^sup>+y\\<in>{\\<langle>b\\<rangle>}. f n (SOURCE, y)\n  \\<partial>count_space UNIV\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+y\\<in>{\\<langle>b\\<rangle>}. f n (SOURCE, y)\n    \\<partial>count_space UNIV =\n    d_IN (h n) b - d_IN (h 0) b", "show \"\\<dots> = d_IN (h n) b - d_IN (h 0) b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+y\\<in>{\\<langle>b\\<rangle>}. f n (SOURCE, y)\n    \\<partial>count_space UNIV =\n    d_IN (h n) b - d_IN (h 0) b", "using h0_b[of n]"], ["proof (prove)\nusing this:\n  d_IN (h 0) b \\<le> d_IN (h n) b\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+y\\<in>{\\<langle>b\\<rangle>}. f n (SOURCE, y)\n    \\<partial>count_space UNIV =\n    d_IN (h n) b - d_IN (h 0) b", "by(auto simp add: max_def)"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+y\\<in>{\\<langle>b\\<rangle>}. f n (SOURCE, y)\n  \\<partial>count_space UNIV =\n  d_IN (h n) b - d_IN (h 0) b\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  d_OUT (f ?n1) SOURCE = d_IN (h ?n1) b - d_IN (h 0) b\n\ngoal (1 subgoal):\n 1. \\<exists>h'.\n       current \\<Gamma> h' \\<and>\n       wave \\<Gamma> h' \\<and>\n       B \\<Gamma> \\<inter> \\<^bold>V \\<subseteq> SAT \\<Gamma> h'", "have OUT_f_outside: \"d_OUT (f n) \\<langle>x\\<rangle> = 0\" if \"x \\<notin> \\<^bold>V\" for x n"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT (f n) \\<langle>x\\<rangle> = 0", "using A_vertex that"], ["proof (prove)\nusing this:\n  A \\<Gamma> \\<subseteq> \\<^bold>V\n  x \\<notin> \\<^bold>V\n\ngoal (1 subgoal):\n 1. d_OUT (f n) \\<langle>x\\<rangle> = 0", "apply(clarsimp simp add: d_OUT_def nn_integral_0_iff emeasure_count_space_eq_0)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>A \\<Gamma> \\<subseteq> \\<^bold>V;\n        \\<not> vertex \\<Gamma> x\\<rbrakk>\n       \\<Longrightarrow> f n (\\<langle>x\\<rangle>, xa) = 0", "subgoal for y"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<Gamma> \\<subseteq> \\<^bold>V;\n     \\<not> vertex \\<Gamma> x\\<rbrakk>\n    \\<Longrightarrow> f n (\\<langle>x\\<rangle>, y) = 0", "by(cases y)(auto simp add: vertex_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  ?x1 \\<notin> \\<^bold>V \\<Longrightarrow>\n  d_OUT (f ?n1) \\<langle>?x1\\<rangle> = 0\n\ngoal (1 subgoal):\n 1. \\<exists>h'.\n       current \\<Gamma> h' \\<and>\n       wave \\<Gamma> h' \\<and>\n       B \\<Gamma> \\<inter> \\<^bold>V \\<subseteq> SAT \\<Gamma> h'", "have IN_f_outside: \"d_IN (f n) \\<langle>x\\<rangle> = 0\" if \"x \\<notin> \\<^bold>V\" for x n"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN (f n) \\<langle>x\\<rangle> = 0", "using b_V that"], ["proof (prove)\nusing this:\n  b \\<in> \\<^bold>V\n  x \\<notin> \\<^bold>V\n\ngoal (1 subgoal):\n 1. d_IN (f n) \\<langle>x\\<rangle> = 0", "apply(clarsimp simp add: d_IN_def nn_integral_0_iff emeasure_count_space_eq_0)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>vertex \\<Gamma> b; \\<not> vertex \\<Gamma> x\\<rbrakk>\n       \\<Longrightarrow> f n (xa, \\<langle>x\\<rangle>) = 0", "subgoal for y"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>vertex \\<Gamma> b; \\<not> vertex \\<Gamma> x\\<rbrakk>\n    \\<Longrightarrow> f n (y, \\<langle>x\\<rangle>) = 0", "by(cases y)(auto simp add: currentD_outside_OUT[OF h] vertex_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  ?x1 \\<notin> \\<^bold>V \\<Longrightarrow>\n  d_IN (f ?n1) \\<langle>?x1\\<rangle> = 0\n\ngoal (1 subgoal):\n 1. \\<exists>h'.\n       current \\<Gamma> h' \\<and>\n       wave \\<Gamma> h' \\<and>\n       B \\<Gamma> \\<inter> \\<^bold>V \\<subseteq> SAT \\<Gamma> h'", "have f: \"flow \\<Psi> (f n)\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. flow \\<Psi> (f n)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>e. f n e \\<le> capacity \\<Psi> e\n 2. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Psi>; x \\<noteq> sink \\<Psi>\\<rbrakk>\n       \\<Longrightarrow> KIR (f n) x", "show f_le: \"f n e \\<le> capacity \\<Psi> e\" for e"], ["proof (prove)\ngoal (1 subgoal):\n 1. f n e \\<le> capacity \\<Psi> e", "using currentD_weight_out[OF h] currentD_weight_IN[OF h] currentD_weight_OUT[OF h]"], ["proof (prove)\nusing this:\n  h ?n1 (?x, ?y) \\<le> weight \\<Gamma> ?x\n  d_IN (h ?n1) ?x \\<le> weight \\<Gamma> ?x\n  d_OUT (h ?n1) ?x \\<le> weight \\<Gamma> ?x\n\ngoal (1 subgoal):\n 1. f n e \\<le> capacity \\<Psi> e", "by(cases e rule: f_cases)\n        (auto dest: edge_antiparallel simp add: not_le le_max_iff_disj intro: ennreal_minus_mono ennreal_diff_le_mono_left)"], ["proof (state)\nthis:\n  f n ?e1 \\<le> capacity \\<Psi> ?e1\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Psi>; x \\<noteq> sink \\<Psi>\\<rbrakk>\n       \\<Longrightarrow> KIR (f n) x", "fix xo"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Psi>; x \\<noteq> sink \\<Psi>\\<rbrakk>\n       \\<Longrightarrow> KIR (f n) x", "assume \"xo \\<noteq> source \\<Psi>\" \"xo \\<noteq> sink \\<Psi>\""], ["proof (state)\nthis:\n  xo \\<noteq> source \\<Psi>\n  xo \\<noteq> sink \\<Psi>\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Psi>; x \\<noteq> sink \\<Psi>\\<rbrakk>\n       \\<Longrightarrow> KIR (f n) x", "then"], ["proof (chain)\npicking this:\n  xo \\<noteq> source \\<Psi>\n  xo \\<noteq> sink \\<Psi>", "consider (A) x where \"xo = \\<langle>x\\<rangle>\" \"x \\<in> A \\<Gamma>\" | (B) x where \"xo = \\<langle>x\\<rangle>\" \"x \\<in> B \\<Gamma>\" \"x \\<in> \\<^bold>V\"\n      | (outside) x where \"xo = \\<langle>x\\<rangle>\" \"x \\<notin> \\<^bold>V\""], ["proof (prove)\nusing this:\n  xo \\<noteq> source \\<Psi>\n  xo \\<noteq> sink \\<Psi>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x.\n                \\<lbrakk>xo = \\<langle>x\\<rangle>;\n                 x \\<in> A \\<Gamma>\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<And>x.\n        \\<lbrakk>xo = \\<langle>x\\<rangle>; x \\<in> B \\<Gamma>;\n         x \\<in> \\<^bold>V\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<And>x.\n        \\<lbrakk>xo = \\<langle>x\\<rangle>; x \\<notin> \\<^bold>V\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "using bipartite_V"], ["proof (prove)\nusing this:\n  xo \\<noteq> source \\<Psi>\n  xo \\<noteq> sink \\<Psi>\n  \\<^bold>V \\<subseteq> A \\<Gamma> \\<union> B \\<Gamma>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x.\n                \\<lbrakk>xo = \\<langle>x\\<rangle>;\n                 x \\<in> A \\<Gamma>\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<And>x.\n        \\<lbrakk>xo = \\<langle>x\\<rangle>; x \\<in> B \\<Gamma>;\n         x \\<in> \\<^bold>V\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<And>x.\n        \\<lbrakk>xo = \\<langle>x\\<rangle>; x \\<notin> \\<^bold>V\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by(cases xo) auto"], ["proof (state)\nthis:\n  \\<lbrakk>\\<And>x.\n              \\<lbrakk>xo = \\<langle>x\\<rangle>; x \\<in> A \\<Gamma>\\<rbrakk>\n              \\<Longrightarrow> ?thesis1;\n   \\<And>x.\n      \\<lbrakk>xo = \\<langle>x\\<rangle>; x \\<in> B \\<Gamma>;\n       x \\<in> \\<^bold>V\\<rbrakk>\n      \\<Longrightarrow> ?thesis1;\n   \\<And>x.\n      \\<lbrakk>xo = \\<langle>x\\<rangle>; x \\<notin> \\<^bold>V\\<rbrakk>\n      \\<Longrightarrow> ?thesis1\\<rbrakk>\n  \\<Longrightarrow> ?thesis1\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> source \\<Psi>; x \\<noteq> sink \\<Psi>\\<rbrakk>\n       \\<Longrightarrow> KIR (f n) x", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<And>x.\n              \\<lbrakk>xo = \\<langle>x\\<rangle>; x \\<in> A \\<Gamma>\\<rbrakk>\n              \\<Longrightarrow> ?thesis1;\n   \\<And>x.\n      \\<lbrakk>xo = \\<langle>x\\<rangle>; x \\<in> B \\<Gamma>;\n       x \\<in> \\<^bold>V\\<rbrakk>\n      \\<Longrightarrow> ?thesis1;\n   \\<And>x.\n      \\<lbrakk>xo = \\<langle>x\\<rangle>; x \\<notin> \\<^bold>V\\<rbrakk>\n      \\<Longrightarrow> ?thesis1\\<rbrakk>\n  \\<Longrightarrow> ?thesis1", "show \"KIR (f n) xo\""], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>x.\n              \\<lbrakk>xo = \\<langle>x\\<rangle>; x \\<in> A \\<Gamma>\\<rbrakk>\n              \\<Longrightarrow> ?thesis1;\n   \\<And>x.\n      \\<lbrakk>xo = \\<langle>x\\<rangle>; x \\<in> B \\<Gamma>;\n       x \\<in> \\<^bold>V\\<rbrakk>\n      \\<Longrightarrow> ?thesis1;\n   \\<And>x.\n      \\<lbrakk>xo = \\<langle>x\\<rangle>; x \\<notin> \\<^bold>V\\<rbrakk>\n      \\<Longrightarrow> ?thesis1\\<rbrakk>\n  \\<Longrightarrow> ?thesis1\n\ngoal (1 subgoal):\n 1. KIR (f n) xo", "proof cases"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>xo = \\<langle>x\\<rangle>; x \\<in> A \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> KIR (f n) xo\n 2. \\<And>x.\n       \\<lbrakk>xo = \\<langle>x\\<rangle>; x \\<in> B \\<Gamma>;\n        x \\<in> \\<^bold>V\\<rbrakk>\n       \\<Longrightarrow> KIR (f n) xo\n 3. \\<And>x.\n       \\<lbrakk>xo = \\<langle>x\\<rangle>; x \\<notin> \\<^bold>V\\<rbrakk>\n       \\<Longrightarrow> KIR (f n) xo", "case outside"], ["proof (state)\nthis:\n  xo = \\<langle>x\\<rangle>\n  x \\<notin> \\<^bold>V\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>xo = \\<langle>x\\<rangle>; x \\<in> A \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> KIR (f n) xo\n 2. \\<And>x.\n       \\<lbrakk>xo = \\<langle>x\\<rangle>; x \\<in> B \\<Gamma>;\n        x \\<in> \\<^bold>V\\<rbrakk>\n       \\<Longrightarrow> KIR (f n) xo\n 3. \\<And>x.\n       \\<lbrakk>xo = \\<langle>x\\<rangle>; x \\<notin> \\<^bold>V\\<rbrakk>\n       \\<Longrightarrow> KIR (f n) xo", "thus ?thesis"], ["proof (prove)\nusing this:\n  xo = \\<langle>x\\<rangle>\n  x \\<notin> \\<^bold>V\n\ngoal (1 subgoal):\n 1. KIR (f n) xo", "by(simp add: OUT_f_outside IN_f_outside)"], ["proof (state)\nthis:\n  KIR (f n) xo\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>xo = \\<langle>x\\<rangle>; x \\<in> A \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> KIR (f n) xo\n 2. \\<And>x.\n       \\<lbrakk>xo = \\<langle>x\\<rangle>; x \\<in> B \\<Gamma>;\n        x \\<in> \\<^bold>V\\<rbrakk>\n       \\<Longrightarrow> KIR (f n) xo", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>xo = \\<langle>x\\<rangle>; x \\<in> A \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> KIR (f n) xo\n 2. \\<And>x.\n       \\<lbrakk>xo = \\<langle>x\\<rangle>; x \\<in> B \\<Gamma>;\n        x \\<in> \\<^bold>V\\<rbrakk>\n       \\<Longrightarrow> KIR (f n) xo", "case A"], ["proof (state)\nthis:\n  xo = \\<langle>x\\<rangle>\n  x \\<in> A \\<Gamma>\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>xo = \\<langle>x\\<rangle>; x \\<in> A \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> KIR (f n) xo\n 2. \\<And>x.\n       \\<lbrakk>xo = \\<langle>x\\<rangle>; x \\<in> B \\<Gamma>;\n        x \\<in> \\<^bold>V\\<rbrakk>\n       \\<Longrightarrow> KIR (f n) xo", "have finite1: \"(\\<Sum>\\<^sup>+ y. h n (x, y) * indicator A y) \\<noteq> \\<top>\" for A n"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+y\\<in>A. h n (x, y)\n    \\<partial>count_space UNIV \\<noteq>\n    \\<top>", "using currentD_finite_OUT[OF h, of n x, unfolded d_OUT_def]"], ["proof (prove)\nusing this:\n  (\\<Sum>\\<^sup>+ y. h n (x, y)) \\<noteq> \\<top>\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+y\\<in>A. h n (x, y)\n    \\<partial>count_space UNIV \\<noteq>\n    \\<top>", "by(rule neq_top_trans)(auto intro!: nn_integral_mono simp add: split: split_indicator)"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+y\\<in>?A1. h ?n1 (x, y)\n  \\<partial>count_space UNIV \\<noteq>\n  \\<top>\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>xo = \\<langle>x\\<rangle>; x \\<in> A \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> KIR (f n) xo\n 2. \\<And>x.\n       \\<lbrakk>xo = \\<langle>x\\<rangle>; x \\<in> B \\<Gamma>;\n        x \\<in> \\<^bold>V\\<rbrakk>\n       \\<Longrightarrow> KIR (f n) xo", "let ?h0_ge_hn = \"{y. h 0 (x, y) \\<ge> h n (x, y)}\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>xo = \\<langle>x\\<rangle>; x \\<in> A \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> KIR (f n) xo\n 2. \\<And>x.\n       \\<lbrakk>xo = \\<langle>x\\<rangle>; x \\<in> B \\<Gamma>;\n        x \\<in> \\<^bold>V\\<rbrakk>\n       \\<Longrightarrow> KIR (f n) xo", "let ?h0_lt_hn = \"{y. h 0 (x, y) < h n (x, y)}\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>xo = \\<langle>x\\<rangle>; x \\<in> A \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> KIR (f n) xo\n 2. \\<And>x.\n       \\<lbrakk>xo = \\<langle>x\\<rangle>; x \\<in> B \\<Gamma>;\n        x \\<in> \\<^bold>V\\<rbrakk>\n       \\<Longrightarrow> KIR (f n) xo", "have \"d_OUT (f n) \\<langle>x\\<rangle> = (\\<Sum>\\<^sup>+ y. f n (\\<langle>x\\<rangle>, y) * indicator (range Inner) y + f n (\\<langle>x\\<rangle>, y) * indicator {SINK} y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT (f n) \\<langle>x\\<rangle> =\n    (\\<Sum>\\<^sup>+ y.\n       f n (\\<langle>x\\<rangle>, y) * indicator (range Inner) y +\n       f n (\\<langle>x\\<rangle>, y) * indicator {vertex.SINK} y)", "unfolding d_OUT_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y. f n (\\<langle>x\\<rangle>, y)) =\n    (\\<Sum>\\<^sup>+ y.\n       f n (\\<langle>x\\<rangle>, y) * indicator (range Inner) y +\n       f n (\\<langle>x\\<rangle>, y) * indicator {vertex.SINK} y)", "by(intro nn_integral_cong)(auto split: split_indicator simp add: notin_range_Inner)"], ["proof (state)\nthis:\n  d_OUT (f n) \\<langle>x\\<rangle> =\n  (\\<Sum>\\<^sup>+ y.\n     f n (\\<langle>x\\<rangle>, y) * indicator (range Inner) y +\n     f n (\\<langle>x\\<rangle>, y) * indicator {vertex.SINK} y)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>xo = \\<langle>x\\<rangle>; x \\<in> A \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> KIR (f n) xo\n 2. \\<And>x.\n       \\<lbrakk>xo = \\<langle>x\\<rangle>; x \\<in> B \\<Gamma>;\n        x \\<in> \\<^bold>V\\<rbrakk>\n       \\<Longrightarrow> KIR (f n) xo", "also"], ["proof (state)\nthis:\n  d_OUT (f n) \\<langle>x\\<rangle> =\n  (\\<Sum>\\<^sup>+ y.\n     f n (\\<langle>x\\<rangle>, y) * indicator (range Inner) y +\n     f n (\\<langle>x\\<rangle>, y) * indicator {vertex.SINK} y)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>xo = \\<langle>x\\<rangle>; x \\<in> A \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> KIR (f n) xo\n 2. \\<And>x.\n       \\<lbrakk>xo = \\<langle>x\\<rangle>; x \\<in> B \\<Gamma>;\n        x \\<in> \\<^bold>V\\<rbrakk>\n       \\<Longrightarrow> KIR (f n) xo", "have \"\\<dots> = (\\<Sum>\\<^sup>+ y\\<in>range Inner. f n (\\<langle>x\\<rangle>, y)) + f n (\\<langle>x\\<rangle>, SINK)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y.\n       f n (\\<langle>x\\<rangle>, y) * indicator (range Inner) y +\n       f n (\\<langle>x\\<rangle>, y) * indicator {vertex.SINK} y) =\n    (\\<Sum>\\<^sup>+ y\\<in>range Inner. f n (\\<langle>x\\<rangle>, y)) +\n    f n (\\<langle>x\\<rangle>, vertex.SINK)", "by(simp add: nn_integral_add nn_integral_count_space_indicator max.left_commute max.commute)"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y.\n     f n (\\<langle>x\\<rangle>, y) * indicator (range Inner) y +\n     f n (\\<langle>x\\<rangle>, y) * indicator {vertex.SINK} y) =\n  (\\<Sum>\\<^sup>+ y\\<in>range Inner. f n (\\<langle>x\\<rangle>, y)) +\n  f n (\\<langle>x\\<rangle>, vertex.SINK)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>xo = \\<langle>x\\<rangle>; x \\<in> A \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> KIR (f n) xo\n 2. \\<And>x.\n       \\<lbrakk>xo = \\<langle>x\\<rangle>; x \\<in> B \\<Gamma>;\n        x \\<in> \\<^bold>V\\<rbrakk>\n       \\<Longrightarrow> KIR (f n) xo", "also"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y.\n     f n (\\<langle>x\\<rangle>, y) * indicator (range Inner) y +\n     f n (\\<langle>x\\<rangle>, y) * indicator {vertex.SINK} y) =\n  (\\<Sum>\\<^sup>+ y\\<in>range Inner. f n (\\<langle>x\\<rangle>, y)) +\n  f n (\\<langle>x\\<rangle>, vertex.SINK)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>xo = \\<langle>x\\<rangle>; x \\<in> A \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> KIR (f n) xo\n 2. \\<And>x.\n       \\<lbrakk>xo = \\<langle>x\\<rangle>; x \\<in> B \\<Gamma>;\n        x \\<in> \\<^bold>V\\<rbrakk>\n       \\<Longrightarrow> KIR (f n) xo", "have \"(\\<Sum>\\<^sup>+ y\\<in>range Inner. f n (\\<langle>x\\<rangle>, y)) = (\\<Sum>\\<^sup>+ y. h 0 (x, y) - h n (x, y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y\\<in>range Inner. f n (\\<langle>x\\<rangle>, y)) =\n    (\\<Sum>\\<^sup>+ y. h 0 (x, y) - h n (x, y))", "using A"], ["proof (prove)\nusing this:\n  xo = \\<langle>x\\<rangle>\n  x \\<in> A \\<Gamma>\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y\\<in>range Inner. f n (\\<langle>x\\<rangle>, y)) =\n    (\\<Sum>\\<^sup>+ y. h 0 (x, y) - h n (x, y))", "apply(simp add: nn_integral_count_space_reindex cong: nn_integral_cong_simp outgoing_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>xo = \\<langle>x\\<rangle>; x \\<in> A \\<Gamma>\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>\\<^sup>+ xa.\n                         if edge \\<Gamma> x xa\n                         then h 0 (x, xa) - h n (x, xa)\n                         else if edge \\<Gamma> xa x\n                              then h n (xa, x) - h 0 (xa, x) else 0) =\n                      (\\<Sum>\\<^sup>+ y. h 0 (x, y) - h n (x, y))", "apply(auto simp add: nn_integral_count_space_indicator outgoing_def A_in max.absorb1 currentD_outside[OF h] intro!: nn_integral_cong split: split_indicator dest: edge_antiparallel)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y\\<in>range Inner. f n (\\<langle>x\\<rangle>, y)) =\n  (\\<Sum>\\<^sup>+ y. h 0 (x, y) - h n (x, y))\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>xo = \\<langle>x\\<rangle>; x \\<in> A \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> KIR (f n) xo\n 2. \\<And>x.\n       \\<lbrakk>xo = \\<langle>x\\<rangle>; x \\<in> B \\<Gamma>;\n        x \\<in> \\<^bold>V\\<rbrakk>\n       \\<Longrightarrow> KIR (f n) xo", "also"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y\\<in>range Inner. f n (\\<langle>x\\<rangle>, y)) =\n  (\\<Sum>\\<^sup>+ y. h 0 (x, y) - h n (x, y))\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>xo = \\<langle>x\\<rangle>; x \\<in> A \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> KIR (f n) xo\n 2. \\<And>x.\n       \\<lbrakk>xo = \\<langle>x\\<rangle>; x \\<in> B \\<Gamma>;\n        x \\<in> \\<^bold>V\\<rbrakk>\n       \\<Longrightarrow> KIR (f n) xo", "have \"\\<dots> = (\\<Sum>\\<^sup>+ y. h 0 (x, y) * indicator ?h0_ge_hn y) - (\\<Sum>\\<^sup>+ y. h n (x, y) * indicator ?h0_ge_hn y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y. h 0 (x, y) - h n (x, y)) =\n    (\\<integral>\\<^sup>+y\\<in>{y. h n (x, y) \\<le> h 0 (x, y)}. h 0 (x, y)\n     \\<partial>count_space UNIV) -\n    (\\<integral>\\<^sup>+y\\<in>{y. h n (x, y) \\<le> h 0 (x, y)}. h n (x, y)\n     \\<partial>count_space UNIV)", "apply(subst nn_integral_diff[symmetric])"], ["proof (prove)\ngoal (5 subgoals):\n 1. (\\<lambda>y. h 0 (x, y) * indicator {y. h n (x, y) \\<le> h 0 (x, y)} y)\n    \\<in> borel_measurable (count_space UNIV)\n 2. (\\<lambda>y. h n (x, y) * indicator {y. h n (x, y) \\<le> h 0 (x, y)} y)\n    \\<in> borel_measurable (count_space UNIV)\n 3. \\<integral>\\<^sup>+y\\<in>{y. h n (x, y) \\<le> h 0 (x, y)}. h n (x, y)\n    \\<partial>count_space UNIV \\<noteq>\n    \\<infinity>\n 4. AE xa in count_space\n              UNIV. h n (x, xa) *\n                    indicator {y. h n (x, y) \\<le> h 0 (x, y)} xa\n                    \\<le> h 0 (x, xa) *\n                          indicator {y. h n (x, y) \\<le> h 0 (x, y)} xa\n 5. (\\<Sum>\\<^sup>+ y. h 0 (x, y) - h n (x, y)) =\n    (\\<Sum>\\<^sup>+ xa.\n       h 0 (x, xa) * indicator {y. h n (x, y) \\<le> h 0 (x, y)} xa -\n       h n (x, xa) * indicator {y. h n (x, y) \\<le> h 0 (x, y)} xa)", "apply(simp_all add: AE_count_space finite1 split: split_indicator)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y. h 0 (x, y) - h n (x, y)) =\n    (\\<Sum>\\<^sup>+ xa.\n       h 0 (x, xa) * indicator {y. h n (x, y) \\<le> h 0 (x, y)} xa -\n       h n (x, xa) * indicator {y. h n (x, y) \\<le> h 0 (x, y)} xa)", "apply(rule nn_integral_cong; auto simp add: max_def not_le split: split_indicator)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       h 0 (x, xa) < h n (x, xa) \\<Longrightarrow>\n       h 0 (x, xa) - h n (x, xa) = 0", "by (metis diff_eq_0_ennreal le_less not_le top_greatest)"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y. h 0 (x, y) - h n (x, y)) =\n  (\\<integral>\\<^sup>+y\\<in>{y. h n (x, y) \\<le> h 0 (x, y)}. h 0 (x, y)\n   \\<partial>count_space UNIV) -\n  (\\<integral>\\<^sup>+y\\<in>{y. h n (x, y) \\<le> h 0 (x, y)}. h n (x, y)\n   \\<partial>count_space UNIV)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>xo = \\<langle>x\\<rangle>; x \\<in> A \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> KIR (f n) xo\n 2. \\<And>x.\n       \\<lbrakk>xo = \\<langle>x\\<rangle>; x \\<in> B \\<Gamma>;\n        x \\<in> \\<^bold>V\\<rbrakk>\n       \\<Longrightarrow> KIR (f n) xo", "also"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y. h 0 (x, y) - h n (x, y)) =\n  (\\<integral>\\<^sup>+y\\<in>{y. h n (x, y) \\<le> h 0 (x, y)}. h 0 (x, y)\n   \\<partial>count_space UNIV) -\n  (\\<integral>\\<^sup>+y\\<in>{y. h n (x, y) \\<le> h 0 (x, y)}. h n (x, y)\n   \\<partial>count_space UNIV)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>xo = \\<langle>x\\<rangle>; x \\<in> A \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> KIR (f n) xo\n 2. \\<And>x.\n       \\<lbrakk>xo = \\<langle>x\\<rangle>; x \\<in> B \\<Gamma>;\n        x \\<in> \\<^bold>V\\<rbrakk>\n       \\<Longrightarrow> KIR (f n) xo", "have \"(\\<Sum>\\<^sup>+ y. h n (x, y) * indicator ?h0_ge_hn y) = d_OUT (h n) x - (\\<Sum>\\<^sup>+ y. h n (x, y) * indicator ?h0_lt_hn y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+y\\<in>{y. h n (x, y) \\<le> h 0 (x, y)}. h n (x, y)\n    \\<partial>count_space UNIV =\n    d_OUT (h n) x -\n    (\\<integral>\\<^sup>+y\\<in>{y. h 0 (x, y) < h n (x, y)}. h n (x, y)\n     \\<partial>count_space UNIV)", "unfolding d_OUT_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+y\\<in>{y. h n (x, y) \\<le> h 0 (x, y)}. h n (x, y)\n    \\<partial>count_space UNIV =\n    (\\<Sum>\\<^sup>+ y. h n (x, y)) -\n    (\\<integral>\\<^sup>+y\\<in>{y. h 0 (x, y) < h n (x, y)}. h n (x, y)\n     \\<partial>count_space UNIV)", "apply(subst nn_integral_diff[symmetric])"], ["proof (prove)\ngoal (5 subgoals):\n 1. (\\<lambda>y. h n (x, y)) \\<in> borel_measurable (count_space UNIV)\n 2. (\\<lambda>y. h n (x, y) * indicator {y. h 0 (x, y) < h n (x, y)} y)\n    \\<in> borel_measurable (count_space UNIV)\n 3. \\<integral>\\<^sup>+y\\<in>{y. h 0 (x, y) < h n (x, y)}. h n (x, y)\n    \\<partial>count_space UNIV \\<noteq>\n    \\<infinity>\n 4. AE xa in count_space\n              UNIV. h n (x, xa) * indicator {y. h 0 (x, y) < h n (x, y)} xa\n                    \\<le> h n (x, xa)\n 5. \\<integral>\\<^sup>+y\\<in>{y. h n (x, y) \\<le> h 0 (x, y)}. h n (x, y)\n    \\<partial>count_space UNIV =\n    (\\<Sum>\\<^sup>+ xa.\n       h n (x, xa) -\n       h n (x, xa) * indicator {y. h 0 (x, y) < h n (x, y)} xa)", "apply(auto simp add: AE_count_space finite1 currentD_finite[OF h] split: split_indicator intro!: nn_integral_cong)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+y\\<in>{y. h n (x, y) \\<le> h 0 (x, y)}. h n (x, y)\n  \\<partial>count_space UNIV =\n  d_OUT (h n) x -\n  (\\<integral>\\<^sup>+y\\<in>{y. h 0 (x, y) < h n (x, y)}. h n (x, y)\n   \\<partial>count_space UNIV)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>xo = \\<langle>x\\<rangle>; x \\<in> A \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> KIR (f n) xo\n 2. \\<And>x.\n       \\<lbrakk>xo = \\<langle>x\\<rangle>; x \\<in> B \\<Gamma>;\n        x \\<in> \\<^bold>V\\<rbrakk>\n       \\<Longrightarrow> KIR (f n) xo", "also"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+y\\<in>{y. h n (x, y) \\<le> h 0 (x, y)}. h n (x, y)\n  \\<partial>count_space UNIV =\n  d_OUT (h n) x -\n  (\\<integral>\\<^sup>+y\\<in>{y. h 0 (x, y) < h n (x, y)}. h n (x, y)\n   \\<partial>count_space UNIV)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>xo = \\<langle>x\\<rangle>; x \\<in> A \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> KIR (f n) xo\n 2. \\<And>x.\n       \\<lbrakk>xo = \\<langle>x\\<rangle>; x \\<in> B \\<Gamma>;\n        x \\<in> \\<^bold>V\\<rbrakk>\n       \\<Longrightarrow> KIR (f n) xo", "have \"(\\<Sum>\\<^sup>+ y. h 0 (x, y) * indicator ?h0_ge_hn y) - \\<dots> + f n (\\<langle>x\\<rangle>, SINK) =\n        (\\<Sum>\\<^sup>+ y. h 0 (x, y) * indicator ?h0_ge_hn y) + (\\<Sum>\\<^sup>+ y. h n (x, y) * indicator ?h0_lt_hn y) - min (d_OUT (h n) x) (d_OUT (h 0) x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<integral>\\<^sup>+y\\<in>{y. h n (x, y) \\<le> h 0 (x, y)}. h 0 (x, y)\n     \\<partial>count_space UNIV) -\n    (d_OUT (h n) x -\n     (\\<integral>\\<^sup>+y\\<in>{y. h 0 (x, y) < h n (x, y)}. h n (x, y)\n      \\<partial>count_space UNIV)) +\n    f n (\\<langle>x\\<rangle>, vertex.SINK) =\n    (\\<integral>\\<^sup>+y\\<in>{y. h n (x, y) \\<le> h 0 (x, y)}. h 0 (x, y)\n     \\<partial>count_space UNIV) +\n    (\\<integral>\\<^sup>+y\\<in>{y. h 0 (x, y) < h n (x, y)}. h n (x, y)\n     \\<partial>count_space UNIV) -\n    min (d_OUT (h n) x) (d_OUT (h 0) x)", "using finite1[of n \"{_}\"] A finite1[of n UNIV]"], ["proof (prove)\nusing this:\n  \\<integral>\\<^sup>+y\\<in>{?uu4}. h n (x, y)\n  \\<partial>count_space UNIV \\<noteq>\n  \\<top>\n  xo = \\<langle>x\\<rangle>\n  x \\<in> A \\<Gamma>\n  \\<integral>\\<^sup>+y\\<in>UNIV. h n (x, y)\n  \\<partial>count_space UNIV \\<noteq>\n  \\<top>\n\ngoal (1 subgoal):\n 1. (\\<integral>\\<^sup>+y\\<in>{y. h n (x, y) \\<le> h 0 (x, y)}. h 0 (x, y)\n     \\<partial>count_space UNIV) -\n    (d_OUT (h n) x -\n     (\\<integral>\\<^sup>+y\\<in>{y. h 0 (x, y) < h n (x, y)}. h n (x, y)\n      \\<partial>count_space UNIV)) +\n    f n (\\<langle>x\\<rangle>, vertex.SINK) =\n    (\\<integral>\\<^sup>+y\\<in>{y. h n (x, y) \\<le> h 0 (x, y)}. h 0 (x, y)\n     \\<partial>count_space UNIV) +\n    (\\<integral>\\<^sup>+y\\<in>{y. h 0 (x, y) < h n (x, y)}. h n (x, y)\n     \\<partial>count_space UNIV) -\n    min (d_OUT (h n) x) (d_OUT (h 0) x)", "apply (subst diff_diff_ennreal')"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<And>uu.\n                \\<integral>\\<^sup>+y\\<in>{uu}. h n (x, y)\n                \\<partial>count_space UNIV \\<noteq>\n                \\<top>;\n     xo = \\<langle>x\\<rangle>; x \\<in> A \\<Gamma>;\n     \\<integral>\\<^sup>+y\\<in>UNIV. h n (x, y)\n     \\<partial>count_space UNIV \\<noteq>\n     \\<top>\\<rbrakk>\n    \\<Longrightarrow> \\<integral>\\<^sup>+y\\<in>{y. h 0 (x, y) < h n (x, y)}.\n   h n (x, y)\n                      \\<partial>count_space UNIV\n                      \\<le> d_OUT (h n) x\n 2. \\<lbrakk>\\<And>uu.\n                \\<integral>\\<^sup>+y\\<in>{uu}. h n (x, y)\n                \\<partial>count_space UNIV \\<noteq>\n                \\<top>;\n     xo = \\<langle>x\\<rangle>; x \\<in> A \\<Gamma>;\n     \\<integral>\\<^sup>+y\\<in>UNIV. h n (x, y)\n     \\<partial>count_space UNIV \\<noteq>\n     \\<top>\\<rbrakk>\n    \\<Longrightarrow> d_OUT (h n) x -\n                      (\\<integral>\\<^sup>+y\\<in>{y.\n           h 0 (x, y) < h n (x, y)}.\n    h n (x, y)\n                       \\<partial>count_space UNIV)\n                      \\<le> \\<integral>\\<^sup>+y\\<in>{y.\n                h n (x, y) \\<le> h 0 (x, y)}.\n         h 0 (x, y)\n                            \\<partial>count_space UNIV\n 3. \\<lbrakk>\\<And>uu.\n                \\<integral>\\<^sup>+y\\<in>{uu}. h n (x, y)\n                \\<partial>count_space UNIV \\<noteq>\n                \\<top>;\n     xo = \\<langle>x\\<rangle>; x \\<in> A \\<Gamma>;\n     \\<integral>\\<^sup>+y\\<in>UNIV. h n (x, y)\n     \\<partial>count_space UNIV \\<noteq>\n     \\<top>\\<rbrakk>\n    \\<Longrightarrow> (\\<integral>\\<^sup>+y\\<in>{y.\n           h n (x, y) \\<le> h 0 (x, y)}.\n    h 0 (x, y)\n                       \\<partial>count_space UNIV) +\n                      (\\<integral>\\<^sup>+y\\<in>{y.\n           h 0 (x, y) < h n (x, y)}.\n    h n (x, y)\n                       \\<partial>count_space UNIV) -\n                      d_OUT (h n) x +\n                      f n (\\<langle>x\\<rangle>, vertex.SINK) =\n                      (\\<integral>\\<^sup>+y\\<in>{y.\n           h n (x, y) \\<le> h 0 (x, y)}.\n    h 0 (x, y)\n                       \\<partial>count_space UNIV) +\n                      (\\<integral>\\<^sup>+y\\<in>{y.\n           h 0 (x, y) < h n (x, y)}.\n    h n (x, y)\n                       \\<partial>count_space UNIV) -\n                      min (d_OUT (h n) x) (d_OUT (h 0) x)", "apply (auto simp: d_OUT_def finite1 AE_count_space nn_integral_diff[symmetric] top_unique nn_integral_add[symmetric]\n                    split: split_indicator intro!: nn_integral_mono ennreal_diff_self)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>uu. h n (x, uu) \\<noteq> \\<top>;\n     xo = \\<langle>x\\<rangle>; x \\<in> A \\<Gamma>;\n     (\\<Sum>\\<^sup>+ y. h n (x, y)) \\<noteq> \\<top>\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>\\<^sup>+ xa.\n                         h 0 (x, xa) *\n                         indicator {y. h n (x, y) \\<le> h 0 (x, y)} xa +\n                         h n (x, xa) *\n                         indicator {y. h 0 (x, y) < h n (x, y)} xa) -\n                      (\\<Sum>\\<^sup>+ y. h n (x, y)) +\n                      ((\\<Sum>\\<^sup>+ y. h n (x, y)) -\n                       (\\<Sum>\\<^sup>+ y. h 0 (x, y))) =\n                      (\\<Sum>\\<^sup>+ xa.\n                         h 0 (x, xa) *\n                         indicator {y. h n (x, y) \\<le> h 0 (x, y)} xa +\n                         h n (x, xa) *\n                         indicator {y. h 0 (x, y) < h n (x, y)} xa) -\n                      min (\\<Sum>\\<^sup>+ y. h n (x, y))\n                       (\\<Sum>\\<^sup>+ y. h 0 (x, y))", "apply (simp add: min_def not_le diff_eq_0_ennreal finite1 less_top[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>uu. h n (x, uu) \\<noteq> \\<top>;\n     xo = \\<langle>x\\<rangle>; x \\<in> A \\<Gamma>;\n     (\\<Sum>\\<^sup>+ y. h n (x, y)) \\<noteq> \\<top>\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>\\<^sup>+ y. h 0 (x, y))\n                      < (\\<Sum>\\<^sup>+ y. h n (x, y)) \\<longrightarrow>\n                      (\\<Sum>\\<^sup>+ xa.\n                         h 0 (x, xa) *\n                         indicator {y. h n (x, y) \\<le> h 0 (x, y)} xa +\n                         h n (x, xa) *\n                         indicator {y. h 0 (x, y) < h n (x, y)} xa) -\n                      (\\<Sum>\\<^sup>+ y. h n (x, y)) +\n                      ((\\<Sum>\\<^sup>+ y. h n (x, y)) -\n                       (\\<Sum>\\<^sup>+ y. h 0 (x, y))) =\n                      (\\<Sum>\\<^sup>+ xa.\n                         h 0 (x, xa) *\n                         indicator {y. h n (x, y) \\<le> h 0 (x, y)} xa +\n                         h n (x, xa) *\n                         indicator {y. h 0 (x, y) < h n (x, y)} xa) -\n                      (\\<Sum>\\<^sup>+ y. h 0 (x, y))", "apply (subst diff_add_assoc2_ennreal)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>uu. h n (x, uu) \\<noteq> \\<top>;\n     xo = \\<langle>x\\<rangle>; x \\<in> A \\<Gamma>;\n     (\\<Sum>\\<^sup>+ y. h n (x, y)) \\<noteq> \\<top>\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>\\<^sup>+ y. h n (x, y))\n                      \\<le> (\\<Sum>\\<^sup>+ xa.\n                               h 0 (x, xa) *\n                               indicator {y. h n (x, y) \\<le> h 0 (x, y)}\n                                xa +\n                               h n (x, xa) *\n                               indicator {y. h 0 (x, y) < h n (x, y)} xa)\n 2. \\<lbrakk>\\<And>uu. h n (x, uu) \\<noteq> \\<top>;\n     xo = \\<langle>x\\<rangle>; x \\<in> A \\<Gamma>;\n     (\\<Sum>\\<^sup>+ y. h n (x, y)) \\<noteq> \\<top>\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>\\<^sup>+ y. h 0 (x, y))\n                      < (\\<Sum>\\<^sup>+ y. h n (x, y)) \\<longrightarrow>\n                      (\\<Sum>\\<^sup>+ xa.\n                         h 0 (x, xa) *\n                         indicator {y. h n (x, y) \\<le> h 0 (x, y)} xa +\n                         h n (x, xa) *\n                         indicator {y. h 0 (x, y) < h n (x, y)} xa) +\n                      ((\\<Sum>\\<^sup>+ y. h n (x, y)) -\n                       (\\<Sum>\\<^sup>+ y. h 0 (x, y))) -\n                      (\\<Sum>\\<^sup>+ y. h n (x, y)) =\n                      (\\<Sum>\\<^sup>+ xa.\n                         h 0 (x, xa) *\n                         indicator {y. h n (x, y) \\<le> h 0 (x, y)} xa +\n                         h n (x, xa) *\n                         indicator {y. h 0 (x, y) < h n (x, y)} xa) -\n                      (\\<Sum>\\<^sup>+ y. h 0 (x, y))", "apply (auto simp: add_diff_eq_ennreal intro!: nn_integral_mono split: split_indicator)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>uu. h n (x, uu) \\<noteq> \\<top>;\n     xo = \\<langle>x\\<rangle>; x \\<in> A \\<Gamma>;\n     (\\<Sum>\\<^sup>+ y. h n (x, y)) \\<noteq> \\<top>;\n     (\\<Sum>\\<^sup>+ y. h 0 (x, y))\n     < (\\<Sum>\\<^sup>+ y. h n (x, y))\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>\\<^sup>+ xa.\n                         h 0 (x, xa) *\n                         indicator {y. h n (x, y) \\<le> h 0 (x, y)} xa +\n                         h n (x, xa) *\n                         indicator {y. h 0 (x, y) < h n (x, y)} xa) +\n                      (\\<Sum>\\<^sup>+ y. h n (x, y)) -\n                      (\\<Sum>\\<^sup>+ y. h 0 (x, y)) -\n                      (\\<Sum>\\<^sup>+ y. h n (x, y)) =\n                      (\\<Sum>\\<^sup>+ xa.\n                         h 0 (x, xa) *\n                         indicator {y. h n (x, y) \\<le> h 0 (x, y)} xa +\n                         h n (x, xa) *\n                         indicator {y. h 0 (x, y) < h n (x, y)} xa) -\n                      (\\<Sum>\\<^sup>+ y. h 0 (x, y))", "apply (subst diff_diff_commute_ennreal)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>uu. h n (x, uu) \\<noteq> \\<top>;\n     xo = \\<langle>x\\<rangle>; x \\<in> A \\<Gamma>;\n     (\\<Sum>\\<^sup>+ y. h n (x, y)) \\<noteq> \\<top>;\n     (\\<Sum>\\<^sup>+ y. h 0 (x, y))\n     < (\\<Sum>\\<^sup>+ y. h n (x, y))\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>\\<^sup>+ xa.\n                         h 0 (x, xa) *\n                         indicator {y. h n (x, y) \\<le> h 0 (x, y)} xa +\n                         h n (x, xa) *\n                         indicator {y. h 0 (x, y) < h n (x, y)} xa) +\n                      (\\<Sum>\\<^sup>+ y. h n (x, y)) -\n                      (\\<Sum>\\<^sup>+ y. h n (x, y)) -\n                      (\\<Sum>\\<^sup>+ y. h 0 (x, y)) =\n                      (\\<Sum>\\<^sup>+ xa.\n                         h 0 (x, xa) *\n                         indicator {y. h n (x, y) \\<le> h 0 (x, y)} xa +\n                         h n (x, xa) *\n                         indicator {y. h 0 (x, y) < h n (x, y)} xa) -\n                      (\\<Sum>\\<^sup>+ y. h 0 (x, y))", "apply (simp add: ennreal_add_diff_cancel )"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (\\<integral>\\<^sup>+y\\<in>{y. h n (x, y) \\<le> h 0 (x, y)}. h 0 (x, y)\n   \\<partial>count_space UNIV) -\n  (d_OUT (h n) x -\n   (\\<integral>\\<^sup>+y\\<in>{y. h 0 (x, y) < h n (x, y)}. h n (x, y)\n    \\<partial>count_space UNIV)) +\n  f n (\\<langle>x\\<rangle>, vertex.SINK) =\n  (\\<integral>\\<^sup>+y\\<in>{y. h n (x, y) \\<le> h 0 (x, y)}. h 0 (x, y)\n   \\<partial>count_space UNIV) +\n  (\\<integral>\\<^sup>+y\\<in>{y. h 0 (x, y) < h n (x, y)}. h n (x, y)\n   \\<partial>count_space UNIV) -\n  min (d_OUT (h n) x) (d_OUT (h 0) x)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>xo = \\<langle>x\\<rangle>; x \\<in> A \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> KIR (f n) xo\n 2. \\<And>x.\n       \\<lbrakk>xo = \\<langle>x\\<rangle>; x \\<in> B \\<Gamma>;\n        x \\<in> \\<^bold>V\\<rbrakk>\n       \\<Longrightarrow> KIR (f n) xo", "also"], ["proof (state)\nthis:\n  (\\<integral>\\<^sup>+y\\<in>{y. h n (x, y) \\<le> h 0 (x, y)}. h 0 (x, y)\n   \\<partial>count_space UNIV) -\n  (d_OUT (h n) x -\n   (\\<integral>\\<^sup>+y\\<in>{y. h 0 (x, y) < h n (x, y)}. h n (x, y)\n    \\<partial>count_space UNIV)) +\n  f n (\\<langle>x\\<rangle>, vertex.SINK) =\n  (\\<integral>\\<^sup>+y\\<in>{y. h n (x, y) \\<le> h 0 (x, y)}. h 0 (x, y)\n   \\<partial>count_space UNIV) +\n  (\\<integral>\\<^sup>+y\\<in>{y. h 0 (x, y) < h n (x, y)}. h n (x, y)\n   \\<partial>count_space UNIV) -\n  min (d_OUT (h n) x) (d_OUT (h 0) x)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>xo = \\<langle>x\\<rangle>; x \\<in> A \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> KIR (f n) xo\n 2. \\<And>x.\n       \\<lbrakk>xo = \\<langle>x\\<rangle>; x \\<in> B \\<Gamma>;\n        x \\<in> \\<^bold>V\\<rbrakk>\n       \\<Longrightarrow> KIR (f n) xo", "have \"\\<dots> = (\\<Sum>\\<^sup>+ y. h n (x, y) * indicator ?h0_lt_hn y) - (d_OUT (h 0) x - (\\<Sum>\\<^sup>+ y. h 0 (x, y) * indicator ?h0_ge_hn y)) + f n (SINK, \\<langle>x\\<rangle>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<integral>\\<^sup>+y\\<in>{y. h n (x, y) \\<le> h 0 (x, y)}. h 0 (x, y)\n     \\<partial>count_space UNIV) +\n    (\\<integral>\\<^sup>+y\\<in>{y. h 0 (x, y) < h n (x, y)}. h n (x, y)\n     \\<partial>count_space UNIV) -\n    min (d_OUT (h n) x) (d_OUT (h 0) x) =\n    (\\<integral>\\<^sup>+y\\<in>{y. h 0 (x, y) < h n (x, y)}. h n (x, y)\n     \\<partial>count_space UNIV) -\n    (d_OUT (h 0) x -\n     (\\<integral>\\<^sup>+y\\<in>{y. h n (x, y) \\<le> h 0 (x, y)}. h 0 (x, y)\n      \\<partial>count_space UNIV)) +\n    f n (vertex.SINK, \\<langle>x\\<rangle>)", "apply(rule sym)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<integral>\\<^sup>+y\\<in>{y. h 0 (x, y) < h n (x, y)}. h n (x, y)\n     \\<partial>count_space UNIV) -\n    (d_OUT (h 0) x -\n     (\\<integral>\\<^sup>+y\\<in>{y. h n (x, y) \\<le> h 0 (x, y)}. h 0 (x, y)\n      \\<partial>count_space UNIV)) +\n    f n (vertex.SINK, \\<langle>x\\<rangle>) =\n    (\\<integral>\\<^sup>+y\\<in>{y. h n (x, y) \\<le> h 0 (x, y)}. h 0 (x, y)\n     \\<partial>count_space UNIV) +\n    (\\<integral>\\<^sup>+y\\<in>{y. h 0 (x, y) < h n (x, y)}. h n (x, y)\n     \\<partial>count_space UNIV) -\n    min (d_OUT (h n) x) (d_OUT (h 0) x)", "using finite1[of 0 \"{_}\"] A finite1[of 0 UNIV]"], ["proof (prove)\nusing this:\n  \\<integral>\\<^sup>+y\\<in>{?uu4}. h 0 (x, y)\n  \\<partial>count_space UNIV \\<noteq>\n  \\<top>\n  xo = \\<langle>x\\<rangle>\n  x \\<in> A \\<Gamma>\n  \\<integral>\\<^sup>+y\\<in>UNIV. h 0 (x, y)\n  \\<partial>count_space UNIV \\<noteq>\n  \\<top>\n\ngoal (1 subgoal):\n 1. (\\<integral>\\<^sup>+y\\<in>{y. h 0 (x, y) < h n (x, y)}. h n (x, y)\n     \\<partial>count_space UNIV) -\n    (d_OUT (h 0) x -\n     (\\<integral>\\<^sup>+y\\<in>{y. h n (x, y) \\<le> h 0 (x, y)}. h 0 (x, y)\n      \\<partial>count_space UNIV)) +\n    f n (vertex.SINK, \\<langle>x\\<rangle>) =\n    (\\<integral>\\<^sup>+y\\<in>{y. h n (x, y) \\<le> h 0 (x, y)}. h 0 (x, y)\n     \\<partial>count_space UNIV) +\n    (\\<integral>\\<^sup>+y\\<in>{y. h 0 (x, y) < h n (x, y)}. h n (x, y)\n     \\<partial>count_space UNIV) -\n    min (d_OUT (h n) x) (d_OUT (h 0) x)", "apply (subst diff_diff_ennreal')"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<And>uu.\n                \\<integral>\\<^sup>+y\\<in>{uu}. h 0 (x, y)\n                \\<partial>count_space UNIV \\<noteq>\n                \\<top>;\n     xo = \\<langle>x\\<rangle>; x \\<in> A \\<Gamma>;\n     \\<integral>\\<^sup>+y\\<in>UNIV. h 0 (x, y)\n     \\<partial>count_space UNIV \\<noteq>\n     \\<top>\\<rbrakk>\n    \\<Longrightarrow> \\<integral>\\<^sup>+y\\<in>{y.\n          h n (x, y) \\<le> h 0 (x, y)}.\n   h 0 (x, y)\n                      \\<partial>count_space UNIV\n                      \\<le> d_OUT (h 0) x\n 2. \\<lbrakk>\\<And>uu.\n                \\<integral>\\<^sup>+y\\<in>{uu}. h 0 (x, y)\n                \\<partial>count_space UNIV \\<noteq>\n                \\<top>;\n     xo = \\<langle>x\\<rangle>; x \\<in> A \\<Gamma>;\n     \\<integral>\\<^sup>+y\\<in>UNIV. h 0 (x, y)\n     \\<partial>count_space UNIV \\<noteq>\n     \\<top>\\<rbrakk>\n    \\<Longrightarrow> d_OUT (h 0) x -\n                      (\\<integral>\\<^sup>+y\\<in>{y.\n           h n (x, y) \\<le> h 0 (x, y)}.\n    h 0 (x, y)\n                       \\<partial>count_space UNIV)\n                      \\<le> \\<integral>\\<^sup>+y\\<in>{y.\n                h 0 (x, y) < h n (x, y)}.\n         h n (x, y)\n                            \\<partial>count_space UNIV\n 3. \\<lbrakk>\\<And>uu.\n                \\<integral>\\<^sup>+y\\<in>{uu}. h 0 (x, y)\n                \\<partial>count_space UNIV \\<noteq>\n                \\<top>;\n     xo = \\<langle>x\\<rangle>; x \\<in> A \\<Gamma>;\n     \\<integral>\\<^sup>+y\\<in>UNIV. h 0 (x, y)\n     \\<partial>count_space UNIV \\<noteq>\n     \\<top>\\<rbrakk>\n    \\<Longrightarrow> (\\<integral>\\<^sup>+y\\<in>{y.\n           h 0 (x, y) < h n (x, y)}.\n    h n (x, y)\n                       \\<partial>count_space UNIV) +\n                      (\\<integral>\\<^sup>+y\\<in>{y.\n           h n (x, y) \\<le> h 0 (x, y)}.\n    h 0 (x, y)\n                       \\<partial>count_space UNIV) -\n                      d_OUT (h 0) x +\n                      f n (vertex.SINK, \\<langle>x\\<rangle>) =\n                      (\\<integral>\\<^sup>+y\\<in>{y.\n           h n (x, y) \\<le> h 0 (x, y)}.\n    h 0 (x, y)\n                       \\<partial>count_space UNIV) +\n                      (\\<integral>\\<^sup>+y\\<in>{y.\n           h 0 (x, y) < h n (x, y)}.\n    h n (x, y)\n                       \\<partial>count_space UNIV) -\n                      min (d_OUT (h n) x) (d_OUT (h 0) x)", "apply (auto simp: d_OUT_def finite1 AE_count_space nn_integral_diff[symmetric] top_unique nn_integral_add[symmetric]\n                    split: split_indicator intro!: nn_integral_mono ennreal_diff_self)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>uu. h 0 (x, uu) \\<noteq> \\<top>;\n     xo = \\<langle>x\\<rangle>; x \\<in> A \\<Gamma>;\n     (\\<Sum>\\<^sup>+ y. h 0 (x, y)) \\<noteq> \\<top>\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>\\<^sup>+ xa.\n                         h n (x, xa) *\n                         indicator {y. h 0 (x, y) < h n (x, y)} xa +\n                         h 0 (x, xa) *\n                         indicator {y. h n (x, y) \\<le> h 0 (x, y)} xa) -\n                      (\\<Sum>\\<^sup>+ y. h 0 (x, y)) +\n                      ((\\<Sum>\\<^sup>+ y. h 0 (x, y)) -\n                       (\\<Sum>\\<^sup>+ y. h n (x, y))) =\n                      (\\<Sum>\\<^sup>+ xa.\n                         h 0 (x, xa) *\n                         indicator {y. h n (x, y) \\<le> h 0 (x, y)} xa +\n                         h n (x, xa) *\n                         indicator {y. h 0 (x, y) < h n (x, y)} xa) -\n                      min (\\<Sum>\\<^sup>+ y. h n (x, y))\n                       (\\<Sum>\\<^sup>+ y. h 0 (x, y))", "apply (simp add: min_def not_le diff_eq_0_ennreal finite1 less_top[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>uu. h 0 (x, uu) \\<noteq> \\<top>;\n     xo = \\<langle>x\\<rangle>; x \\<in> A \\<Gamma>;\n     (\\<Sum>\\<^sup>+ y. h 0 (x, y)) \\<noteq> \\<top>\\<rbrakk>\n    \\<Longrightarrow> ((\\<Sum>\\<^sup>+ y. h n (x, y))\n                       \\<le> (\\<Sum>\\<^sup>+ y.\n                                h 0 (x, y)) \\<longrightarrow>\n                       (\\<Sum>\\<^sup>+ xa.\n                          h n (x, xa) *\n                          indicator {y. h 0 (x, y) < h n (x, y)} xa +\n                          h 0 (x, xa) *\n                          indicator {y. h n (x, y) \\<le> h 0 (x, y)} xa) -\n                       (\\<Sum>\\<^sup>+ y. h 0 (x, y)) +\n                       ((\\<Sum>\\<^sup>+ y. h 0 (x, y)) -\n                        (\\<Sum>\\<^sup>+ y. h n (x, y))) =\n                       (\\<Sum>\\<^sup>+ xa.\n                          h 0 (x, xa) *\n                          indicator {y. h n (x, y) \\<le> h 0 (x, y)} xa +\n                          h n (x, xa) *\n                          indicator {y. h 0 (x, y) < h n (x, y)} xa) -\n                       (\\<Sum>\\<^sup>+ y. h n (x, y))) \\<and>\n                      ((\\<Sum>\\<^sup>+ y. h 0 (x, y))\n                       < (\\<Sum>\\<^sup>+ y. h n (x, y)) \\<longrightarrow>\n                       (\\<Sum>\\<^sup>+ xa.\n                          h n (x, xa) *\n                          indicator {y. h 0 (x, y) < h n (x, y)} xa +\n                          h 0 (x, xa) *\n                          indicator {y. h n (x, y) \\<le> h 0 (x, y)} xa) -\n                       (\\<Sum>\\<^sup>+ y. h 0 (x, y)) =\n                       (\\<Sum>\\<^sup>+ xa.\n                          h 0 (x, xa) *\n                          indicator {y. h n (x, y) \\<le> h 0 (x, y)} xa +\n                          h n (x, xa) *\n                          indicator {y. h 0 (x, y) < h n (x, y)} xa) -\n                       (\\<Sum>\\<^sup>+ y. h 0 (x, y)))", "apply (subst diff_add_assoc2_ennreal)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>uu. h 0 (x, uu) \\<noteq> \\<top>;\n     xo = \\<langle>x\\<rangle>; x \\<in> A \\<Gamma>;\n     (\\<Sum>\\<^sup>+ y. h 0 (x, y)) \\<noteq> \\<top>\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>\\<^sup>+ y. h 0 (x, y))\n                      \\<le> (\\<Sum>\\<^sup>+ xa.\n                               h n (x, xa) *\n                               indicator {y. h 0 (x, y) < h n (x, y)} xa +\n                               h 0 (x, xa) *\n                               indicator {y. h n (x, y) \\<le> h 0 (x, y)}\n                                xa)\n 2. \\<lbrakk>\\<And>uu. h 0 (x, uu) \\<noteq> \\<top>;\n     xo = \\<langle>x\\<rangle>; x \\<in> A \\<Gamma>;\n     (\\<Sum>\\<^sup>+ y. h 0 (x, y)) \\<noteq> \\<top>\\<rbrakk>\n    \\<Longrightarrow> ((\\<Sum>\\<^sup>+ y. h n (x, y))\n                       \\<le> (\\<Sum>\\<^sup>+ y.\n                                h 0 (x, y)) \\<longrightarrow>\n                       (\\<Sum>\\<^sup>+ xa.\n                          h n (x, xa) *\n                          indicator {y. h 0 (x, y) < h n (x, y)} xa +\n                          h 0 (x, xa) *\n                          indicator {y. h n (x, y) \\<le> h 0 (x, y)} xa) +\n                       ((\\<Sum>\\<^sup>+ y. h 0 (x, y)) -\n                        (\\<Sum>\\<^sup>+ y. h n (x, y))) -\n                       (\\<Sum>\\<^sup>+ y. h 0 (x, y)) =\n                       (\\<Sum>\\<^sup>+ xa.\n                          h 0 (x, xa) *\n                          indicator {y. h n (x, y) \\<le> h 0 (x, y)} xa +\n                          h n (x, xa) *\n                          indicator {y. h 0 (x, y) < h n (x, y)} xa) -\n                       (\\<Sum>\\<^sup>+ y. h n (x, y))) \\<and>\n                      ((\\<Sum>\\<^sup>+ y. h 0 (x, y))\n                       < (\\<Sum>\\<^sup>+ y. h n (x, y)) \\<longrightarrow>\n                       (\\<Sum>\\<^sup>+ xa.\n                          h n (x, xa) *\n                          indicator {y. h 0 (x, y) < h n (x, y)} xa +\n                          h 0 (x, xa) *\n                          indicator {y. h n (x, y) \\<le> h 0 (x, y)} xa) -\n                       (\\<Sum>\\<^sup>+ y. h 0 (x, y)) =\n                       (\\<Sum>\\<^sup>+ xa.\n                          h 0 (x, xa) *\n                          indicator {y. h n (x, y) \\<le> h 0 (x, y)} xa +\n                          h n (x, xa) *\n                          indicator {y. h 0 (x, y) < h n (x, y)} xa) -\n                       (\\<Sum>\\<^sup>+ y. h 0 (x, y)))", "apply (auto simp: add_diff_eq_ennreal intro!: nn_integral_mono split: split_indicator)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>uu. h 0 (x, uu) \\<noteq> \\<top>;\n     xo = \\<langle>x\\<rangle>; x \\<in> A \\<Gamma>;\n     (\\<Sum>\\<^sup>+ y. h 0 (x, y)) \\<noteq> \\<top>;\n     (\\<Sum>\\<^sup>+ y. h n (x, y))\n     \\<le> (\\<Sum>\\<^sup>+ y. h 0 (x, y))\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>\\<^sup>+ xa.\n                         h n (x, xa) *\n                         indicator {y. h 0 (x, y) < h n (x, y)} xa +\n                         h 0 (x, xa) *\n                         indicator {y. h n (x, y) \\<le> h 0 (x, y)} xa) +\n                      (\\<Sum>\\<^sup>+ y. h 0 (x, y)) -\n                      (\\<Sum>\\<^sup>+ y. h n (x, y)) -\n                      (\\<Sum>\\<^sup>+ y. h 0 (x, y)) =\n                      (\\<Sum>\\<^sup>+ xa.\n                         h 0 (x, xa) *\n                         indicator {y. h n (x, y) \\<le> h 0 (x, y)} xa +\n                         h n (x, xa) *\n                         indicator {y. h 0 (x, y) < h n (x, y)} xa) -\n                      (\\<Sum>\\<^sup>+ y. h n (x, y))\n 2. \\<lbrakk>\\<And>uu. h 0 (x, uu) \\<noteq> \\<top>;\n     xo = \\<langle>x\\<rangle>; x \\<in> A \\<Gamma>;\n     (\\<Sum>\\<^sup>+ y. h 0 (x, y)) \\<noteq> \\<top>;\n     (\\<Sum>\\<^sup>+ y. h 0 (x, y))\n     < (\\<Sum>\\<^sup>+ y. h n (x, y))\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>\\<^sup>+ xa.\n                         h n (x, xa) *\n                         indicator {y. h 0 (x, y) < h n (x, y)} xa +\n                         h 0 (x, xa) *\n                         indicator {y. h n (x, y) \\<le> h 0 (x, y)} xa) -\n                      (\\<Sum>\\<^sup>+ y. h 0 (x, y)) =\n                      (\\<Sum>\\<^sup>+ xa.\n                         h 0 (x, xa) *\n                         indicator {y. h n (x, y) \\<le> h 0 (x, y)} xa +\n                         h n (x, xa) *\n                         indicator {y. h 0 (x, y) < h n (x, y)} xa) -\n                      (\\<Sum>\\<^sup>+ y. h 0 (x, y))", "apply (subst diff_diff_commute_ennreal)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>uu. h 0 (x, uu) \\<noteq> \\<top>;\n     xo = \\<langle>x\\<rangle>; x \\<in> A \\<Gamma>;\n     (\\<Sum>\\<^sup>+ y. h 0 (x, y)) \\<noteq> \\<top>;\n     (\\<Sum>\\<^sup>+ y. h n (x, y))\n     \\<le> (\\<Sum>\\<^sup>+ y. h 0 (x, y))\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>\\<^sup>+ xa.\n                         h n (x, xa) *\n                         indicator {y. h 0 (x, y) < h n (x, y)} xa +\n                         h 0 (x, xa) *\n                         indicator {y. h n (x, y) \\<le> h 0 (x, y)} xa) +\n                      (\\<Sum>\\<^sup>+ y. h 0 (x, y)) -\n                      (\\<Sum>\\<^sup>+ y. h 0 (x, y)) -\n                      (\\<Sum>\\<^sup>+ y. h n (x, y)) =\n                      (\\<Sum>\\<^sup>+ xa.\n                         h 0 (x, xa) *\n                         indicator {y. h n (x, y) \\<le> h 0 (x, y)} xa +\n                         h n (x, xa) *\n                         indicator {y. h 0 (x, y) < h n (x, y)} xa) -\n                      (\\<Sum>\\<^sup>+ y. h n (x, y))\n 2. \\<lbrakk>\\<And>uu. h 0 (x, uu) \\<noteq> \\<top>;\n     xo = \\<langle>x\\<rangle>; x \\<in> A \\<Gamma>;\n     (\\<Sum>\\<^sup>+ y. h 0 (x, y)) \\<noteq> \\<top>;\n     (\\<Sum>\\<^sup>+ y. h 0 (x, y))\n     < (\\<Sum>\\<^sup>+ y. h n (x, y))\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>\\<^sup>+ xa.\n                         h n (x, xa) *\n                         indicator {y. h 0 (x, y) < h n (x, y)} xa +\n                         h 0 (x, xa) *\n                         indicator {y. h n (x, y) \\<le> h 0 (x, y)} xa) -\n                      (\\<Sum>\\<^sup>+ y. h 0 (x, y)) =\n                      (\\<Sum>\\<^sup>+ xa.\n                         h 0 (x, xa) *\n                         indicator {y. h n (x, y) \\<le> h 0 (x, y)} xa +\n                         h n (x, xa) *\n                         indicator {y. h 0 (x, y) < h n (x, y)} xa) -\n                      (\\<Sum>\\<^sup>+ y. h 0 (x, y))", "apply (simp_all add: ennreal_add_diff_cancel ac_simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (\\<integral>\\<^sup>+y\\<in>{y. h n (x, y) \\<le> h 0 (x, y)}. h 0 (x, y)\n   \\<partial>count_space UNIV) +\n  (\\<integral>\\<^sup>+y\\<in>{y. h 0 (x, y) < h n (x, y)}. h n (x, y)\n   \\<partial>count_space UNIV) -\n  min (d_OUT (h n) x) (d_OUT (h 0) x) =\n  (\\<integral>\\<^sup>+y\\<in>{y. h 0 (x, y) < h n (x, y)}. h n (x, y)\n   \\<partial>count_space UNIV) -\n  (d_OUT (h 0) x -\n   (\\<integral>\\<^sup>+y\\<in>{y. h n (x, y) \\<le> h 0 (x, y)}. h 0 (x, y)\n    \\<partial>count_space UNIV)) +\n  f n (vertex.SINK, \\<langle>x\\<rangle>)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>xo = \\<langle>x\\<rangle>; x \\<in> A \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> KIR (f n) xo\n 2. \\<And>x.\n       \\<lbrakk>xo = \\<langle>x\\<rangle>; x \\<in> B \\<Gamma>;\n        x \\<in> \\<^bold>V\\<rbrakk>\n       \\<Longrightarrow> KIR (f n) xo", "also"], ["proof (state)\nthis:\n  (\\<integral>\\<^sup>+y\\<in>{y. h n (x, y) \\<le> h 0 (x, y)}. h 0 (x, y)\n   \\<partial>count_space UNIV) +\n  (\\<integral>\\<^sup>+y\\<in>{y. h 0 (x, y) < h n (x, y)}. h n (x, y)\n   \\<partial>count_space UNIV) -\n  min (d_OUT (h n) x) (d_OUT (h 0) x) =\n  (\\<integral>\\<^sup>+y\\<in>{y. h 0 (x, y) < h n (x, y)}. h n (x, y)\n   \\<partial>count_space UNIV) -\n  (d_OUT (h 0) x -\n   (\\<integral>\\<^sup>+y\\<in>{y. h n (x, y) \\<le> h 0 (x, y)}. h 0 (x, y)\n    \\<partial>count_space UNIV)) +\n  f n (vertex.SINK, \\<langle>x\\<rangle>)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>xo = \\<langle>x\\<rangle>; x \\<in> A \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> KIR (f n) xo\n 2. \\<And>x.\n       \\<lbrakk>xo = \\<langle>x\\<rangle>; x \\<in> B \\<Gamma>;\n        x \\<in> \\<^bold>V\\<rbrakk>\n       \\<Longrightarrow> KIR (f n) xo", "have \"d_OUT (h 0) x - (\\<Sum>\\<^sup>+ y. h 0 (x, y) * indicator ?h0_ge_hn y) = (\\<Sum>\\<^sup>+ y. h 0 (x, y) * indicator ?h0_lt_hn y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT (h 0) x -\n    (\\<integral>\\<^sup>+y\\<in>{y. h n (x, y) \\<le> h 0 (x, y)}. h 0 (x, y)\n     \\<partial>count_space UNIV) =\n    \\<integral>\\<^sup>+y\\<in>{y. h 0 (x, y) < h n (x, y)}. h 0 (x, y)\n    \\<partial>count_space UNIV", "unfolding d_OUT_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y. h 0 (x, y)) -\n    (\\<integral>\\<^sup>+y\\<in>{y. h n (x, y) \\<le> h 0 (x, y)}. h 0 (x, y)\n     \\<partial>count_space UNIV) =\n    \\<integral>\\<^sup>+y\\<in>{y. h 0 (x, y) < h n (x, y)}. h 0 (x, y)\n    \\<partial>count_space UNIV", "apply(subst nn_integral_diff[symmetric])"], ["proof (prove)\ngoal (5 subgoals):\n 1. (\\<lambda>y. h 0 (x, y)) \\<in> borel_measurable (count_space UNIV)\n 2. (\\<lambda>y. h 0 (x, y) * indicator {y. h n (x, y) \\<le> h 0 (x, y)} y)\n    \\<in> borel_measurable (count_space UNIV)\n 3. \\<integral>\\<^sup>+y\\<in>{y. h n (x, y) \\<le> h 0 (x, y)}. h 0 (x, y)\n    \\<partial>count_space UNIV \\<noteq>\n    \\<infinity>\n 4. AE xa in count_space\n              UNIV. h 0 (x, xa) *\n                    indicator {y. h n (x, y) \\<le> h 0 (x, y)} xa\n                    \\<le> h 0 (x, xa)\n 5. (\\<Sum>\\<^sup>+ xa.\n       h 0 (x, xa) -\n       h 0 (x, xa) * indicator {y. h n (x, y) \\<le> h 0 (x, y)} xa) =\n    \\<integral>\\<^sup>+y\\<in>{y. h 0 (x, y) < h n (x, y)}. h 0 (x, y)\n    \\<partial>count_space UNIV", "apply(auto simp add: AE_count_space finite1 currentD_finite[OF h] split: split_indicator intro!: nn_integral_cong)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  d_OUT (h 0) x -\n  (\\<integral>\\<^sup>+y\\<in>{y. h n (x, y) \\<le> h 0 (x, y)}. h 0 (x, y)\n   \\<partial>count_space UNIV) =\n  \\<integral>\\<^sup>+y\\<in>{y. h 0 (x, y) < h n (x, y)}. h 0 (x, y)\n  \\<partial>count_space UNIV\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>xo = \\<langle>x\\<rangle>; x \\<in> A \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> KIR (f n) xo\n 2. \\<And>x.\n       \\<lbrakk>xo = \\<langle>x\\<rangle>; x \\<in> B \\<Gamma>;\n        x \\<in> \\<^bold>V\\<rbrakk>\n       \\<Longrightarrow> KIR (f n) xo", "also"], ["proof (state)\nthis:\n  d_OUT (h 0) x -\n  (\\<integral>\\<^sup>+y\\<in>{y. h n (x, y) \\<le> h 0 (x, y)}. h 0 (x, y)\n   \\<partial>count_space UNIV) =\n  \\<integral>\\<^sup>+y\\<in>{y. h 0 (x, y) < h n (x, y)}. h 0 (x, y)\n  \\<partial>count_space UNIV\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>xo = \\<langle>x\\<rangle>; x \\<in> A \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> KIR (f n) xo\n 2. \\<And>x.\n       \\<lbrakk>xo = \\<langle>x\\<rangle>; x \\<in> B \\<Gamma>;\n        x \\<in> \\<^bold>V\\<rbrakk>\n       \\<Longrightarrow> KIR (f n) xo", "have \"(\\<Sum>\\<^sup>+ y. h n (x, y) * indicator ?h0_lt_hn y) - \\<dots> = (\\<Sum>\\<^sup>+ y. h n (x, y) - h 0 (x, y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<integral>\\<^sup>+y\\<in>{y. h 0 (x, y) < h n (x, y)}. h n (x, y)\n     \\<partial>count_space UNIV) -\n    (\\<integral>\\<^sup>+y\\<in>{y. h 0 (x, y) < h n (x, y)}. h 0 (x, y)\n     \\<partial>count_space UNIV) =\n    (\\<Sum>\\<^sup>+ y. h n (x, y) - h 0 (x, y))", "apply(subst nn_integral_diff[symmetric])"], ["proof (prove)\ngoal (5 subgoals):\n 1. (\\<lambda>y. h n (x, y) * indicator {y. h 0 (x, y) < h n (x, y)} y)\n    \\<in> borel_measurable (count_space UNIV)\n 2. (\\<lambda>y. h 0 (x, y) * indicator {y. h 0 (x, y) < h n (x, y)} y)\n    \\<in> borel_measurable (count_space UNIV)\n 3. \\<integral>\\<^sup>+y\\<in>{y. h 0 (x, y) < h n (x, y)}. h 0 (x, y)\n    \\<partial>count_space UNIV \\<noteq>\n    \\<infinity>\n 4. AE xa in count_space\n              UNIV. h 0 (x, xa) * indicator {y. h 0 (x, y) < h n (x, y)} xa\n                    \\<le> h n (x, xa) *\n                          indicator {y. h 0 (x, y) < h n (x, y)} xa\n 5. (\\<Sum>\\<^sup>+ xa.\n       h n (x, xa) * indicator {y. h 0 (x, y) < h n (x, y)} xa -\n       h 0 (x, xa) * indicator {y. h 0 (x, y) < h n (x, y)} xa) =\n    (\\<Sum>\\<^sup>+ y. h n (x, y) - h 0 (x, y))", "apply(simp_all add: AE_count_space finite1 order.strict_implies_order split: split_indicator)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ xa.\n       h n (x, xa) * indicator {y. h 0 (x, y) < h n (x, y)} xa -\n       h 0 (x, xa) * indicator {y. h 0 (x, y) < h n (x, y)} xa) =\n    (\\<Sum>\\<^sup>+ y. h n (x, y) - h 0 (x, y))", "apply(rule nn_integral_cong; auto simp add: currentD_finite[OF h] top_unique less_top[symmetric] not_less split: split_indicator intro!: diff_eq_0_ennreal)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (\\<integral>\\<^sup>+y\\<in>{y. h 0 (x, y) < h n (x, y)}. h n (x, y)\n   \\<partial>count_space UNIV) -\n  (\\<integral>\\<^sup>+y\\<in>{y. h 0 (x, y) < h n (x, y)}. h 0 (x, y)\n   \\<partial>count_space UNIV) =\n  (\\<Sum>\\<^sup>+ y. h n (x, y) - h 0 (x, y))\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>xo = \\<langle>x\\<rangle>; x \\<in> A \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> KIR (f n) xo\n 2. \\<And>x.\n       \\<lbrakk>xo = \\<langle>x\\<rangle>; x \\<in> B \\<Gamma>;\n        x \\<in> \\<^bold>V\\<rbrakk>\n       \\<Longrightarrow> KIR (f n) xo", "also"], ["proof (state)\nthis:\n  (\\<integral>\\<^sup>+y\\<in>{y. h 0 (x, y) < h n (x, y)}. h n (x, y)\n   \\<partial>count_space UNIV) -\n  (\\<integral>\\<^sup>+y\\<in>{y. h 0 (x, y) < h n (x, y)}. h 0 (x, y)\n   \\<partial>count_space UNIV) =\n  (\\<Sum>\\<^sup>+ y. h n (x, y) - h 0 (x, y))\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>xo = \\<langle>x\\<rangle>; x \\<in> A \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> KIR (f n) xo\n 2. \\<And>x.\n       \\<lbrakk>xo = \\<langle>x\\<rangle>; x \\<in> B \\<Gamma>;\n        x \\<in> \\<^bold>V\\<rbrakk>\n       \\<Longrightarrow> KIR (f n) xo", "have \"\\<dots> = (\\<Sum>\\<^sup>+ y\\<in>range Inner. f n (y, \\<langle>x\\<rangle>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y. h n (x, y) - h 0 (x, y)) =\n    (\\<Sum>\\<^sup>+ y\\<in>range Inner. f n (y, \\<langle>x\\<rangle>))", "using A"], ["proof (prove)\nusing this:\n  xo = \\<langle>x\\<rangle>\n  x \\<in> A \\<Gamma>\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y. h n (x, y) - h 0 (x, y)) =\n    (\\<Sum>\\<^sup>+ y\\<in>range Inner. f n (y, \\<langle>x\\<rangle>))", "apply(simp add: nn_integral_count_space_reindex cong: nn_integral_cong_simp outgoing_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>xo = \\<langle>x\\<rangle>; x \\<in> A \\<Gamma>\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>\\<^sup>+ y. h n (x, y) - h 0 (x, y)) =\n                      (\\<Sum>\\<^sup>+ xa.\n                         if edge \\<Gamma> xa x\n                         then h 0 (xa, x) - h n (xa, x)\n                         else if edge \\<Gamma> x xa\n                              then h n (x, xa) - h 0 (x, xa) else 0)", "apply(auto simp add: nn_integral_count_space_indicator outgoing_def A_in max.commute currentD_outside[OF h] intro!: nn_integral_cong split: split_indicator dest: edge_antiparallel)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y. h n (x, y) - h 0 (x, y)) =\n  (\\<Sum>\\<^sup>+ y\\<in>range Inner. f n (y, \\<langle>x\\<rangle>))\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>xo = \\<langle>x\\<rangle>; x \\<in> A \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> KIR (f n) xo\n 2. \\<And>x.\n       \\<lbrakk>xo = \\<langle>x\\<rangle>; x \\<in> B \\<Gamma>;\n        x \\<in> \\<^bold>V\\<rbrakk>\n       \\<Longrightarrow> KIR (f n) xo", "also"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y. h n (x, y) - h 0 (x, y)) =\n  (\\<Sum>\\<^sup>+ y\\<in>range Inner. f n (y, \\<langle>x\\<rangle>))\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>xo = \\<langle>x\\<rangle>; x \\<in> A \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> KIR (f n) xo\n 2. \\<And>x.\n       \\<lbrakk>xo = \\<langle>x\\<rangle>; x \\<in> B \\<Gamma>;\n        x \\<in> \\<^bold>V\\<rbrakk>\n       \\<Longrightarrow> KIR (f n) xo", "have \"\\<dots> + f n (SINK, \\<langle>x\\<rangle>) = (\\<Sum>\\<^sup>+ y. f n (y, \\<langle>x\\<rangle>) * indicator (range Inner) y + f n (y, \\<langle>x\\<rangle>) * indicator {SINK} y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y\\<in>range Inner. f n (y, \\<langle>x\\<rangle>)) +\n    f n (vertex.SINK, \\<langle>x\\<rangle>) =\n    (\\<Sum>\\<^sup>+ y.\n       f n (y, \\<langle>x\\<rangle>) * indicator (range Inner) y +\n       f n (y, \\<langle>x\\<rangle>) * indicator {vertex.SINK} y)", "by(simp add: nn_integral_add nn_integral_count_space_indicator)"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y\\<in>range Inner. f n (y, \\<langle>x\\<rangle>)) +\n  f n (vertex.SINK, \\<langle>x\\<rangle>) =\n  (\\<Sum>\\<^sup>+ y.\n     f n (y, \\<langle>x\\<rangle>) * indicator (range Inner) y +\n     f n (y, \\<langle>x\\<rangle>) * indicator {vertex.SINK} y)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>xo = \\<langle>x\\<rangle>; x \\<in> A \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> KIR (f n) xo\n 2. \\<And>x.\n       \\<lbrakk>xo = \\<langle>x\\<rangle>; x \\<in> B \\<Gamma>;\n        x \\<in> \\<^bold>V\\<rbrakk>\n       \\<Longrightarrow> KIR (f n) xo", "also"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y\\<in>range Inner. f n (y, \\<langle>x\\<rangle>)) +\n  f n (vertex.SINK, \\<langle>x\\<rangle>) =\n  (\\<Sum>\\<^sup>+ y.\n     f n (y, \\<langle>x\\<rangle>) * indicator (range Inner) y +\n     f n (y, \\<langle>x\\<rangle>) * indicator {vertex.SINK} y)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>xo = \\<langle>x\\<rangle>; x \\<in> A \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> KIR (f n) xo\n 2. \\<And>x.\n       \\<lbrakk>xo = \\<langle>x\\<rangle>; x \\<in> B \\<Gamma>;\n        x \\<in> \\<^bold>V\\<rbrakk>\n       \\<Longrightarrow> KIR (f n) xo", "have \"\\<dots> = d_IN (f n) \\<langle>x\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y.\n       f n (y, \\<langle>x\\<rangle>) * indicator (range Inner) y +\n       f n (y, \\<langle>x\\<rangle>) * indicator {vertex.SINK} y) =\n    d_IN (f n) \\<langle>x\\<rangle>", "using A b disjoint"], ["proof (prove)\nusing this:\n  xo = \\<langle>x\\<rangle>\n  x \\<in> A \\<Gamma>\n  b \\<in> B \\<Gamma>\n  A \\<Gamma> \\<inter> B \\<Gamma> = {}\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y.\n       f n (y, \\<langle>x\\<rangle>) * indicator (range Inner) y +\n       f n (y, \\<langle>x\\<rangle>) * indicator {vertex.SINK} y) =\n    d_IN (f n) \\<langle>x\\<rangle>", "unfolding d_IN_def"], ["proof (prove)\nusing this:\n  xo = \\<langle>x\\<rangle>\n  x \\<in> A \\<Gamma>\n  b \\<in> B \\<Gamma>\n  A \\<Gamma> \\<inter> B \\<Gamma> = {}\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y.\n       f n (y, \\<langle>x\\<rangle>) * indicator (range Inner) y +\n       f n (y, \\<langle>x\\<rangle>) * indicator {vertex.SINK} y) =\n    (\\<Sum>\\<^sup>+ xa. f n (xa, \\<langle>x\\<rangle>))", "by(intro nn_integral_cong)(auto split: split_indicator simp add: notin_range_Inner)"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y.\n     f n (y, \\<langle>x\\<rangle>) * indicator (range Inner) y +\n     f n (y, \\<langle>x\\<rangle>) * indicator {vertex.SINK} y) =\n  d_IN (f n) \\<langle>x\\<rangle>\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>xo = \\<langle>x\\<rangle>; x \\<in> A \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> KIR (f n) xo\n 2. \\<And>x.\n       \\<lbrakk>xo = \\<langle>x\\<rangle>; x \\<in> B \\<Gamma>;\n        x \\<in> \\<^bold>V\\<rbrakk>\n       \\<Longrightarrow> KIR (f n) xo", "finally"], ["proof (chain)\npicking this:\n  KIR (f n) \\<langle>x\\<rangle>", "show ?thesis"], ["proof (prove)\nusing this:\n  KIR (f n) \\<langle>x\\<rangle>\n\ngoal (1 subgoal):\n 1. KIR (f n) xo", "using A"], ["proof (prove)\nusing this:\n  KIR (f n) \\<langle>x\\<rangle>\n  xo = \\<langle>x\\<rangle>\n  x \\<in> A \\<Gamma>\n\ngoal (1 subgoal):\n 1. KIR (f n) xo", "by simp"], ["proof (state)\nthis:\n  KIR (f n) xo\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>xo = \\<langle>x\\<rangle>; x \\<in> B \\<Gamma>;\n        x \\<in> \\<^bold>V\\<rbrakk>\n       \\<Longrightarrow> KIR (f n) xo", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>xo = \\<langle>x\\<rangle>; x \\<in> B \\<Gamma>;\n        x \\<in> \\<^bold>V\\<rbrakk>\n       \\<Longrightarrow> KIR (f n) xo", "case (B x)"], ["proof (state)\nthis:\n  xo = \\<langle>x\\<rangle>\n  x \\<in> B \\<Gamma>\n  x \\<in> \\<^bold>V\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>xo = \\<langle>x\\<rangle>; x \\<in> B \\<Gamma>;\n        x \\<in> \\<^bold>V\\<rbrakk>\n       \\<Longrightarrow> KIR (f n) xo", "have finite1: \"(\\<Sum>\\<^sup>+ y. h n (y, x) * indicator A y) \\<noteq> \\<top>\" for A n"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+y\\<in>A. h n (y, x)\n    \\<partial>count_space UNIV \\<noteq>\n    \\<top>", "using currentD_finite_IN[OF h, of n x, unfolded d_IN_def]"], ["proof (prove)\nusing this:\n  (\\<Sum>\\<^sup>+ xa. h n (xa, x)) \\<noteq> \\<top>\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+y\\<in>A. h n (y, x)\n    \\<partial>count_space UNIV \\<noteq>\n    \\<top>", "by(rule neq_top_trans)(auto intro!: nn_integral_mono split: split_indicator)"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+y\\<in>?A1. h ?n1 (y, x)\n  \\<partial>count_space UNIV \\<noteq>\n  \\<top>\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>xo = \\<langle>x\\<rangle>; x \\<in> B \\<Gamma>;\n        x \\<in> \\<^bold>V\\<rbrakk>\n       \\<Longrightarrow> KIR (f n) xo", "have finite_h[simp]: \"h n (y, x) < \\<top>\" for y n"], ["proof (prove)\ngoal (1 subgoal):\n 1. h n (y, x) < \\<top>", "using finite1[of n \"{y}\"]"], ["proof (prove)\nusing this:\n  \\<integral>\\<^sup>+y\\<in>{y}. h n (y, x)\n  \\<partial>count_space UNIV \\<noteq>\n  \\<top>\n\ngoal (1 subgoal):\n 1. h n (y, x) < \\<top>", "by (simp add: less_top)"], ["proof (state)\nthis:\n  h ?n1 (?y1, x) < \\<top>\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>xo = \\<langle>x\\<rangle>; x \\<in> B \\<Gamma>;\n        x \\<in> \\<^bold>V\\<rbrakk>\n       \\<Longrightarrow> KIR (f n) xo", "let ?h0_gt_hn = \"{y. h 0 (y, x) > h n (y, x)}\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>xo = \\<langle>x\\<rangle>; x \\<in> B \\<Gamma>;\n        x \\<in> \\<^bold>V\\<rbrakk>\n       \\<Longrightarrow> KIR (f n) xo", "let ?h0_le_hn = \"{y. h 0 (y, x) \\<le> h n (y, x)}\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>xo = \\<langle>x\\<rangle>; x \\<in> B \\<Gamma>;\n        x \\<in> \\<^bold>V\\<rbrakk>\n       \\<Longrightarrow> KIR (f n) xo", "have eq: \"d_IN (h 0) x + f n (SOURCE, \\<langle>x\\<rangle>) = d_IN (h n) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN (h 0) x + f n (SOURCE, \\<langle>x\\<rangle>) = d_IN (h n) x", "proof(cases \"x = b\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x = b \\<Longrightarrow>\n    d_IN (h 0) x + f n (SOURCE, \\<langle>x\\<rangle>) = d_IN (h n) x\n 2. x \\<noteq> b \\<Longrightarrow>\n    d_IN (h 0) x + f n (SOURCE, \\<langle>x\\<rangle>) = d_IN (h n) x", "case True"], ["proof (state)\nthis:\n  x = b\n\ngoal (2 subgoals):\n 1. x = b \\<Longrightarrow>\n    d_IN (h 0) x + f n (SOURCE, \\<langle>x\\<rangle>) = d_IN (h n) x\n 2. x \\<noteq> b \\<Longrightarrow>\n    d_IN (h 0) x + f n (SOURCE, \\<langle>x\\<rangle>) = d_IN (h n) x", "with currentD_finite_IN[OF h, of _ b]"], ["proof (chain)\npicking this:\n  d_IN (h ?n1) b \\<noteq> \\<top>\n  x = b", "show ?thesis"], ["proof (prove)\nusing this:\n  d_IN (h ?n1) b \\<noteq> \\<top>\n  x = b\n\ngoal (1 subgoal):\n 1. d_IN (h 0) x + f n (SOURCE, \\<langle>x\\<rangle>) = d_IN (h n) x", "by(simp add: add_diff_self_ennreal h0_b)"], ["proof (state)\nthis:\n  d_IN (h 0) x + f n (SOURCE, \\<langle>x\\<rangle>) = d_IN (h n) x\n\ngoal (1 subgoal):\n 1. x \\<noteq> b \\<Longrightarrow>\n    d_IN (h 0) x + f n (SOURCE, \\<langle>x\\<rangle>) = d_IN (h n) x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<noteq> b \\<Longrightarrow>\n    d_IN (h 0) x + f n (SOURCE, \\<langle>x\\<rangle>) = d_IN (h n) x", "case False"], ["proof (state)\nthis:\n  x \\<noteq> b\n\ngoal (1 subgoal):\n 1. x \\<noteq> b \\<Longrightarrow>\n    d_IN (h 0) x + f n (SOURCE, \\<langle>x\\<rangle>) = d_IN (h n) x", "with B SAT"], ["proof (chain)\npicking this:\n  xo = \\<langle>x\\<rangle>\n  x \\<in> B \\<Gamma>\n  x \\<in> \\<^bold>V\n  B \\<Gamma> \\<inter> \\<^bold>V - {b} \\<subseteq> SAT \\<Gamma> (h ?n)\n  x \\<noteq> b", "have \"x \\<in> SAT \\<Gamma> (h n)\" \"x \\<in> SAT \\<Gamma> (h 0)\""], ["proof (prove)\nusing this:\n  xo = \\<langle>x\\<rangle>\n  x \\<in> B \\<Gamma>\n  x \\<in> \\<^bold>V\n  B \\<Gamma> \\<inter> \\<^bold>V - {b} \\<subseteq> SAT \\<Gamma> (h ?n)\n  x \\<noteq> b\n\ngoal (1 subgoal):\n 1. x \\<in> SAT \\<Gamma> (h n) &&& x \\<in> SAT \\<Gamma> (h 0)", "by auto"], ["proof (state)\nthis:\n  x \\<in> SAT \\<Gamma> (h n)\n  x \\<in> SAT \\<Gamma> (h 0)\n\ngoal (1 subgoal):\n 1. x \\<noteq> b \\<Longrightarrow>\n    d_IN (h 0) x + f n (SOURCE, \\<langle>x\\<rangle>) = d_IN (h n) x", "with B disjoint"], ["proof (chain)\npicking this:\n  xo = \\<langle>x\\<rangle>\n  x \\<in> B \\<Gamma>\n  x \\<in> \\<^bold>V\n  A \\<Gamma> \\<inter> B \\<Gamma> = {}\n  x \\<in> SAT \\<Gamma> (h n)\n  x \\<in> SAT \\<Gamma> (h 0)", "have \"d_IN (h n) x = d_IN (h 0) x\""], ["proof (prove)\nusing this:\n  xo = \\<langle>x\\<rangle>\n  x \\<in> B \\<Gamma>\n  x \\<in> \\<^bold>V\n  A \\<Gamma> \\<inter> B \\<Gamma> = {}\n  x \\<in> SAT \\<Gamma> (h n)\n  x \\<in> SAT \\<Gamma> (h 0)\n\ngoal (1 subgoal):\n 1. d_IN (h n) x = d_IN (h 0) x", "by(auto simp add: currentD_SAT[OF h])"], ["proof (state)\nthis:\n  d_IN (h n) x = d_IN (h 0) x\n\ngoal (1 subgoal):\n 1. x \\<noteq> b \\<Longrightarrow>\n    d_IN (h 0) x + f n (SOURCE, \\<langle>x\\<rangle>) = d_IN (h n) x", "thus ?thesis"], ["proof (prove)\nusing this:\n  d_IN (h n) x = d_IN (h 0) x\n\ngoal (1 subgoal):\n 1. d_IN (h 0) x + f n (SOURCE, \\<langle>x\\<rangle>) = d_IN (h n) x", "using False"], ["proof (prove)\nusing this:\n  d_IN (h n) x = d_IN (h 0) x\n  x \\<noteq> b\n\ngoal (1 subgoal):\n 1. d_IN (h 0) x + f n (SOURCE, \\<langle>x\\<rangle>) = d_IN (h n) x", "by(simp add: currentD_finite_IN[OF h])"], ["proof (state)\nthis:\n  d_IN (h 0) x + f n (SOURCE, \\<langle>x\\<rangle>) = d_IN (h n) x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  d_IN (h 0) x + f n (SOURCE, \\<langle>x\\<rangle>) = d_IN (h n) x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>xo = \\<langle>x\\<rangle>; x \\<in> B \\<Gamma>;\n        x \\<in> \\<^bold>V\\<rbrakk>\n       \\<Longrightarrow> KIR (f n) xo", "have \"d_IN (f n) \\<langle>x\\<rangle> = (\\<Sum>\\<^sup>+ y. f n (y, \\<langle>x\\<rangle>) * indicator (range Inner) y + f n (y, \\<langle>x\\<rangle>) * indicator {SOURCE} y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN (f n) \\<langle>x\\<rangle> =\n    (\\<Sum>\\<^sup>+ y.\n       f n (y, \\<langle>x\\<rangle>) * indicator (range Inner) y +\n       f n (y, \\<langle>x\\<rangle>) * indicator {SOURCE} y)", "using B disjoint"], ["proof (prove)\nusing this:\n  xo = \\<langle>x\\<rangle>\n  x \\<in> B \\<Gamma>\n  x \\<in> \\<^bold>V\n  A \\<Gamma> \\<inter> B \\<Gamma> = {}\n\ngoal (1 subgoal):\n 1. d_IN (f n) \\<langle>x\\<rangle> =\n    (\\<Sum>\\<^sup>+ y.\n       f n (y, \\<langle>x\\<rangle>) * indicator (range Inner) y +\n       f n (y, \\<langle>x\\<rangle>) * indicator {SOURCE} y)", "unfolding d_IN_def"], ["proof (prove)\nusing this:\n  xo = \\<langle>x\\<rangle>\n  x \\<in> B \\<Gamma>\n  x \\<in> \\<^bold>V\n  A \\<Gamma> \\<inter> B \\<Gamma> = {}\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ xa. f n (xa, \\<langle>x\\<rangle>)) =\n    (\\<Sum>\\<^sup>+ y.\n       f n (y, \\<langle>x\\<rangle>) * indicator (range Inner) y +\n       f n (y, \\<langle>x\\<rangle>) * indicator {SOURCE} y)", "by(intro nn_integral_cong)(auto split: split_indicator simp add: notin_range_Inner)"], ["proof (state)\nthis:\n  d_IN (f n) \\<langle>x\\<rangle> =\n  (\\<Sum>\\<^sup>+ y.\n     f n (y, \\<langle>x\\<rangle>) * indicator (range Inner) y +\n     f n (y, \\<langle>x\\<rangle>) * indicator {SOURCE} y)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>xo = \\<langle>x\\<rangle>; x \\<in> B \\<Gamma>;\n        x \\<in> \\<^bold>V\\<rbrakk>\n       \\<Longrightarrow> KIR (f n) xo", "also"], ["proof (state)\nthis:\n  d_IN (f n) \\<langle>x\\<rangle> =\n  (\\<Sum>\\<^sup>+ y.\n     f n (y, \\<langle>x\\<rangle>) * indicator (range Inner) y +\n     f n (y, \\<langle>x\\<rangle>) * indicator {SOURCE} y)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>xo = \\<langle>x\\<rangle>; x \\<in> B \\<Gamma>;\n        x \\<in> \\<^bold>V\\<rbrakk>\n       \\<Longrightarrow> KIR (f n) xo", "have \"\\<dots> = (\\<Sum>\\<^sup>+ y\\<in>range Inner. f n (y, \\<langle>x\\<rangle>)) + f n (SOURCE, \\<langle>x\\<rangle>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y.\n       f n (y, \\<langle>x\\<rangle>) * indicator (range Inner) y +\n       f n (y, \\<langle>x\\<rangle>) * indicator {SOURCE} y) =\n    (\\<Sum>\\<^sup>+ y\\<in>range Inner. f n (y, \\<langle>x\\<rangle>)) +\n    f n (SOURCE, \\<langle>x\\<rangle>)", "using h0_b[of n]"], ["proof (prove)\nusing this:\n  d_IN (h 0) b \\<le> d_IN (h n) b\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y.\n       f n (y, \\<langle>x\\<rangle>) * indicator (range Inner) y +\n       f n (y, \\<langle>x\\<rangle>) * indicator {SOURCE} y) =\n    (\\<Sum>\\<^sup>+ y\\<in>range Inner. f n (y, \\<langle>x\\<rangle>)) +\n    f n (SOURCE, \\<langle>x\\<rangle>)", "by(simp add: nn_integral_add nn_integral_count_space_indicator max_def)"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y.\n     f n (y, \\<langle>x\\<rangle>) * indicator (range Inner) y +\n     f n (y, \\<langle>x\\<rangle>) * indicator {SOURCE} y) =\n  (\\<Sum>\\<^sup>+ y\\<in>range Inner. f n (y, \\<langle>x\\<rangle>)) +\n  f n (SOURCE, \\<langle>x\\<rangle>)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>xo = \\<langle>x\\<rangle>; x \\<in> B \\<Gamma>;\n        x \\<in> \\<^bold>V\\<rbrakk>\n       \\<Longrightarrow> KIR (f n) xo", "also"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y.\n     f n (y, \\<langle>x\\<rangle>) * indicator (range Inner) y +\n     f n (y, \\<langle>x\\<rangle>) * indicator {SOURCE} y) =\n  (\\<Sum>\\<^sup>+ y\\<in>range Inner. f n (y, \\<langle>x\\<rangle>)) +\n  f n (SOURCE, \\<langle>x\\<rangle>)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>xo = \\<langle>x\\<rangle>; x \\<in> B \\<Gamma>;\n        x \\<in> \\<^bold>V\\<rbrakk>\n       \\<Longrightarrow> KIR (f n) xo", "have \"(\\<Sum>\\<^sup>+ y\\<in>range Inner. f n (y, \\<langle>x\\<rangle>)) = (\\<Sum>\\<^sup>+ y. h 0 (y, x) - h n (y, x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y\\<in>range Inner. f n (y, \\<langle>x\\<rangle>)) =\n    (\\<Sum>\\<^sup>+ y. h 0 (y, x) - h n (y, x))", "using B disjoint"], ["proof (prove)\nusing this:\n  xo = \\<langle>x\\<rangle>\n  x \\<in> B \\<Gamma>\n  x \\<in> \\<^bold>V\n  A \\<Gamma> \\<inter> B \\<Gamma> = {}\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y\\<in>range Inner. f n (y, \\<langle>x\\<rangle>)) =\n    (\\<Sum>\\<^sup>+ y. h 0 (y, x) - h n (y, x))", "apply(simp add: nn_integral_count_space_reindex cong: nn_integral_cong_simp outgoing_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>xo = \\<langle>x\\<rangle>; x \\<in> B \\<Gamma>;\n     vertex \\<Gamma> x; A \\<Gamma> \\<inter> B \\<Gamma> = {}\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>\\<^sup>+ xa.\n                         if edge \\<Gamma> xa x\n                         then h 0 (xa, x) - h n (xa, x)\n                         else if edge \\<Gamma> x xa\n                              then h n (x, xa) - h 0 (x, xa) else 0) =\n                      (\\<Sum>\\<^sup>+ y. h 0 (y, x) - h n (y, x))", "apply(auto simp add: nn_integral_count_space_indicator outgoing_def B_out max.commute currentD_outside[OF h] intro!: nn_integral_cong split: split_indicator dest: edge_antiparallel)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y\\<in>range Inner. f n (y, \\<langle>x\\<rangle>)) =\n  (\\<Sum>\\<^sup>+ y. h 0 (y, x) - h n (y, x))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>xo = \\<langle>x\\<rangle>; x \\<in> B \\<Gamma>;\n        x \\<in> \\<^bold>V\\<rbrakk>\n       \\<Longrightarrow> KIR (f n) xo", "also"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y\\<in>range Inner. f n (y, \\<langle>x\\<rangle>)) =\n  (\\<Sum>\\<^sup>+ y. h 0 (y, x) - h n (y, x))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>xo = \\<langle>x\\<rangle>; x \\<in> B \\<Gamma>;\n        x \\<in> \\<^bold>V\\<rbrakk>\n       \\<Longrightarrow> KIR (f n) xo", "have \"\\<dots> = (\\<Sum>\\<^sup>+ y. h 0 (y, x) * indicator ?h0_gt_hn y) - (\\<Sum>\\<^sup>+ y. h n (y, x) * indicator ?h0_gt_hn y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y. h 0 (y, x) - h n (y, x)) =\n    (\\<integral>\\<^sup>+y\\<in>{y. h n (y, x) < h 0 (y, x)}. h 0 (y, x)\n     \\<partial>count_space UNIV) -\n    (\\<integral>\\<^sup>+y\\<in>{y. h n (y, x) < h 0 (y, x)}. h n (y, x)\n     \\<partial>count_space UNIV)", "apply(subst nn_integral_diff[symmetric])"], ["proof (prove)\ngoal (5 subgoals):\n 1. (\\<lambda>y. h 0 (y, x) * indicator {y. h n (y, x) < h 0 (y, x)} y)\n    \\<in> borel_measurable (count_space UNIV)\n 2. (\\<lambda>y. h n (y, x) * indicator {y. h n (y, x) < h 0 (y, x)} y)\n    \\<in> borel_measurable (count_space UNIV)\n 3. \\<integral>\\<^sup>+y\\<in>{y. h n (y, x) < h 0 (y, x)}. h n (y, x)\n    \\<partial>count_space UNIV \\<noteq>\n    \\<infinity>\n 4. AE xa in count_space\n              UNIV. h n (xa, x) * indicator {y. h n (y, x) < h 0 (y, x)} xa\n                    \\<le> h 0 (xa, x) *\n                          indicator {y. h n (y, x) < h 0 (y, x)} xa\n 5. (\\<Sum>\\<^sup>+ y. h 0 (y, x) - h n (y, x)) =\n    (\\<Sum>\\<^sup>+ xa.\n       h 0 (xa, x) * indicator {y. h n (y, x) < h 0 (y, x)} xa -\n       h n (xa, x) * indicator {y. h n (y, x) < h 0 (y, x)} xa)", "apply(simp_all add: AE_count_space finite1 order.strict_implies_order split: split_indicator)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y. h 0 (y, x) - h n (y, x)) =\n    (\\<Sum>\\<^sup>+ xa.\n       h 0 (xa, x) * indicator {y. h n (y, x) < h 0 (y, x)} xa -\n       h n (xa, x) * indicator {y. h n (y, x) < h 0 (y, x)} xa)", "apply(rule nn_integral_cong; auto simp add: currentD_finite[OF h] top_unique less_top[symmetric] not_less split: split_indicator intro!: diff_eq_0_ennreal)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y. h 0 (y, x) - h n (y, x)) =\n  (\\<integral>\\<^sup>+y\\<in>{y. h n (y, x) < h 0 (y, x)}. h 0 (y, x)\n   \\<partial>count_space UNIV) -\n  (\\<integral>\\<^sup>+y\\<in>{y. h n (y, x) < h 0 (y, x)}. h n (y, x)\n   \\<partial>count_space UNIV)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>xo = \\<langle>x\\<rangle>; x \\<in> B \\<Gamma>;\n        x \\<in> \\<^bold>V\\<rbrakk>\n       \\<Longrightarrow> KIR (f n) xo", "also"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y. h 0 (y, x) - h n (y, x)) =\n  (\\<integral>\\<^sup>+y\\<in>{y. h n (y, x) < h 0 (y, x)}. h 0 (y, x)\n   \\<partial>count_space UNIV) -\n  (\\<integral>\\<^sup>+y\\<in>{y. h n (y, x) < h 0 (y, x)}. h n (y, x)\n   \\<partial>count_space UNIV)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>xo = \\<langle>x\\<rangle>; x \\<in> B \\<Gamma>;\n        x \\<in> \\<^bold>V\\<rbrakk>\n       \\<Longrightarrow> KIR (f n) xo", "have eq_h_0: \"(\\<Sum>\\<^sup>+ y. h 0 (y, x) * indicator ?h0_gt_hn y) = d_IN (h 0) x - (\\<Sum>\\<^sup>+ y. h 0 (y, x) * indicator ?h0_le_hn y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+y\\<in>{y. h n (y, x) < h 0 (y, x)}. h 0 (y, x)\n    \\<partial>count_space UNIV =\n    d_IN (h 0) x -\n    (\\<integral>\\<^sup>+y\\<in>{y. h 0 (y, x) \\<le> h n (y, x)}. h 0 (y, x)\n     \\<partial>count_space UNIV)", "unfolding d_IN_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+y\\<in>{y. h n (y, x) < h 0 (y, x)}. h 0 (y, x)\n    \\<partial>count_space UNIV =\n    (\\<Sum>\\<^sup>+ xa. h 0 (xa, x)) -\n    (\\<integral>\\<^sup>+y\\<in>{y. h 0 (y, x) \\<le> h n (y, x)}. h 0 (y, x)\n     \\<partial>count_space UNIV)", "apply(subst nn_integral_diff[symmetric])"], ["proof (prove)\ngoal (5 subgoals):\n 1. (\\<lambda>xa. h 0 (xa, x)) \\<in> borel_measurable (count_space UNIV)\n 2. (\\<lambda>y. h 0 (y, x) * indicator {y. h 0 (y, x) \\<le> h n (y, x)} y)\n    \\<in> borel_measurable (count_space UNIV)\n 3. \\<integral>\\<^sup>+y\\<in>{y. h 0 (y, x) \\<le> h n (y, x)}. h 0 (y, x)\n    \\<partial>count_space UNIV \\<noteq>\n    \\<infinity>\n 4. AE xa in count_space\n              UNIV. h 0 (xa, x) *\n                    indicator {y. h 0 (y, x) \\<le> h n (y, x)} xa\n                    \\<le> h 0 (xa, x)\n 5. \\<integral>\\<^sup>+y\\<in>{y. h n (y, x) < h 0 (y, x)}. h 0 (y, x)\n    \\<partial>count_space UNIV =\n    (\\<Sum>\\<^sup>+ xa.\n       h 0 (xa, x) -\n       h 0 (xa, x) * indicator {y. h 0 (y, x) \\<le> h n (y, x)} xa)", "apply(auto simp add: AE_count_space finite1 currentD_finite[OF h] split: split_indicator intro!: nn_integral_cong)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+y\\<in>{y. h n (y, x) < h 0 (y, x)}. h 0 (y, x)\n  \\<partial>count_space UNIV =\n  d_IN (h 0) x -\n  (\\<integral>\\<^sup>+y\\<in>{y. h 0 (y, x) \\<le> h n (y, x)}. h 0 (y, x)\n   \\<partial>count_space UNIV)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>xo = \\<langle>x\\<rangle>; x \\<in> B \\<Gamma>;\n        x \\<in> \\<^bold>V\\<rbrakk>\n       \\<Longrightarrow> KIR (f n) xo", "also"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+y\\<in>{y. h n (y, x) < h 0 (y, x)}. h 0 (y, x)\n  \\<partial>count_space UNIV =\n  d_IN (h 0) x -\n  (\\<integral>\\<^sup>+y\\<in>{y. h 0 (y, x) \\<le> h n (y, x)}. h 0 (y, x)\n   \\<partial>count_space UNIV)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>xo = \\<langle>x\\<rangle>; x \\<in> B \\<Gamma>;\n        x \\<in> \\<^bold>V\\<rbrakk>\n       \\<Longrightarrow> KIR (f n) xo", "have eq_h_n: \"(\\<Sum>\\<^sup>+ y. h n (y, x) * indicator ?h0_gt_hn y) = d_IN (h n) x - (\\<Sum>\\<^sup>+ y. h n (y, x) * indicator ?h0_le_hn y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+y\\<in>{y. h n (y, x) < h 0 (y, x)}. h n (y, x)\n    \\<partial>count_space UNIV =\n    d_IN (h n) x -\n    (\\<integral>\\<^sup>+y\\<in>{y. h 0 (y, x) \\<le> h n (y, x)}. h n (y, x)\n     \\<partial>count_space UNIV)", "unfolding d_IN_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+y\\<in>{y. h n (y, x) < h 0 (y, x)}. h n (y, x)\n    \\<partial>count_space UNIV =\n    (\\<Sum>\\<^sup>+ xa. h n (xa, x)) -\n    (\\<integral>\\<^sup>+y\\<in>{y. h 0 (y, x) \\<le> h n (y, x)}. h n (y, x)\n     \\<partial>count_space UNIV)", "apply(subst nn_integral_diff[symmetric])"], ["proof (prove)\ngoal (5 subgoals):\n 1. (\\<lambda>xa. h n (xa, x)) \\<in> borel_measurable (count_space UNIV)\n 2. (\\<lambda>y. h n (y, x) * indicator {y. h 0 (y, x) \\<le> h n (y, x)} y)\n    \\<in> borel_measurable (count_space UNIV)\n 3. \\<integral>\\<^sup>+y\\<in>{y. h 0 (y, x) \\<le> h n (y, x)}. h n (y, x)\n    \\<partial>count_space UNIV \\<noteq>\n    \\<infinity>\n 4. AE xa in count_space\n              UNIV. h n (xa, x) *\n                    indicator {y. h 0 (y, x) \\<le> h n (y, x)} xa\n                    \\<le> h n (xa, x)\n 5. \\<integral>\\<^sup>+y\\<in>{y. h n (y, x) < h 0 (y, x)}. h n (y, x)\n    \\<partial>count_space UNIV =\n    (\\<Sum>\\<^sup>+ xa.\n       h n (xa, x) -\n       h n (xa, x) * indicator {y. h 0 (y, x) \\<le> h n (y, x)} xa)", "apply(auto simp add: AE_count_space finite1 currentD_finite[OF h] split: split_indicator intro!: nn_integral_cong)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+y\\<in>{y. h n (y, x) < h 0 (y, x)}. h n (y, x)\n  \\<partial>count_space UNIV =\n  d_IN (h n) x -\n  (\\<integral>\\<^sup>+y\\<in>{y. h 0 (y, x) \\<le> h n (y, x)}. h n (y, x)\n   \\<partial>count_space UNIV)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>xo = \\<langle>x\\<rangle>; x \\<in> B \\<Gamma>;\n        x \\<in> \\<^bold>V\\<rbrakk>\n       \\<Longrightarrow> KIR (f n) xo", "also"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+y\\<in>{y. h n (y, x) < h 0 (y, x)}. h n (y, x)\n  \\<partial>count_space UNIV =\n  d_IN (h n) x -\n  (\\<integral>\\<^sup>+y\\<in>{y. h 0 (y, x) \\<le> h n (y, x)}. h n (y, x)\n   \\<partial>count_space UNIV)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>xo = \\<langle>x\\<rangle>; x \\<in> B \\<Gamma>;\n        x \\<in> \\<^bold>V\\<rbrakk>\n       \\<Longrightarrow> KIR (f n) xo", "have \"d_IN (h 0) x - (\\<Sum>\\<^sup>+ y. h 0 (y, x) * indicator ?h0_le_hn y) - (d_IN (h n) x - (\\<Sum>\\<^sup>+ y. h n (y, x) * indicator ?h0_le_hn y)) + f n (SOURCE, \\<langle>x\\<rangle>) =\n                (\\<Sum>\\<^sup>+ y. h n (y, x) * indicator ?h0_le_hn y) - (\\<Sum>\\<^sup>+ y. h 0 (y, x) * indicator ?h0_le_hn y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN (h 0) x -\n    (\\<integral>\\<^sup>+y\\<in>{y. h 0 (y, x) \\<le> h n (y, x)}. h 0 (y, x)\n     \\<partial>count_space UNIV) -\n    (d_IN (h n) x -\n     (\\<integral>\\<^sup>+y\\<in>{y. h 0 (y, x) \\<le> h n (y, x)}. h n (y, x)\n      \\<partial>count_space UNIV)) +\n    f n (SOURCE, \\<langle>x\\<rangle>) =\n    (\\<integral>\\<^sup>+y\\<in>{y. h 0 (y, x) \\<le> h n (y, x)}. h n (y, x)\n     \\<partial>count_space UNIV) -\n    (\\<integral>\\<^sup>+y\\<in>{y. h 0 (y, x) \\<le> h n (y, x)}. h 0 (y, x)\n     \\<partial>count_space UNIV)", "apply (subst diff_add_assoc2_ennreal)"], ["proof (prove)\ngoal (2 subgoals):\n 1. d_IN (h n) x -\n    (\\<integral>\\<^sup>+y\\<in>{y. h 0 (y, x) \\<le> h n (y, x)}. h n (y, x)\n     \\<partial>count_space UNIV)\n    \\<le> d_IN (h 0) x -\n          (\\<integral>\\<^sup>+y\\<in>{y. h 0 (y, x) \\<le> h n (y, x)}.\n                              h 0 (y, x)\n           \\<partial>count_space UNIV)\n 2. d_IN (h 0) x -\n    (\\<integral>\\<^sup>+y\\<in>{y. h 0 (y, x) \\<le> h n (y, x)}. h 0 (y, x)\n     \\<partial>count_space UNIV) +\n    f n (SOURCE, \\<langle>x\\<rangle>) -\n    (d_IN (h n) x -\n     (\\<integral>\\<^sup>+y\\<in>{y. h 0 (y, x) \\<le> h n (y, x)}. h n (y, x)\n      \\<partial>count_space UNIV)) =\n    (\\<integral>\\<^sup>+y\\<in>{y. h 0 (y, x) \\<le> h n (y, x)}. h n (y, x)\n     \\<partial>count_space UNIV) -\n    (\\<integral>\\<^sup>+y\\<in>{y. h 0 (y, x) \\<le> h n (y, x)}. h 0 (y, x)\n     \\<partial>count_space UNIV)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN (h n) x -\n    (\\<integral>\\<^sup>+y\\<in>{y. h 0 (y, x) \\<le> h n (y, x)}. h n (y, x)\n     \\<partial>count_space UNIV)\n    \\<le> d_IN (h 0) x -\n          (\\<integral>\\<^sup>+y\\<in>{y. h 0 (y, x) \\<le> h n (y, x)}.\n                              h 0 (y, x)\n           \\<partial>count_space UNIV)", "by (auto simp add: eq_h_0[symmetric] eq_h_n[symmetric] split: split_indicator intro!: nn_integral_mono)"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN (h 0) x -\n    (\\<integral>\\<^sup>+y\\<in>{y. h 0 (y, x) \\<le> h n (y, x)}. h 0 (y, x)\n     \\<partial>count_space UNIV) +\n    f n (SOURCE, \\<langle>x\\<rangle>) -\n    (d_IN (h n) x -\n     (\\<integral>\\<^sup>+y\\<in>{y. h 0 (y, x) \\<le> h n (y, x)}. h n (y, x)\n      \\<partial>count_space UNIV)) =\n    (\\<integral>\\<^sup>+y\\<in>{y. h 0 (y, x) \\<le> h n (y, x)}. h n (y, x)\n     \\<partial>count_space UNIV) -\n    (\\<integral>\\<^sup>+y\\<in>{y. h 0 (y, x) \\<le> h n (y, x)}. h 0 (y, x)\n     \\<partial>count_space UNIV)", "apply (subst diff_add_assoc2_ennreal)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<integral>\\<^sup>+y\\<in>{y. h 0 (y, x) \\<le> h n (y, x)}. h 0 (y, x)\n    \\<partial>count_space UNIV\n    \\<le> d_IN (h 0) x\n 2. d_IN (h 0) x + f n (SOURCE, \\<langle>x\\<rangle>) -\n    (\\<integral>\\<^sup>+y\\<in>{y. h 0 (y, x) \\<le> h n (y, x)}. h 0 (y, x)\n     \\<partial>count_space UNIV) -\n    (d_IN (h n) x -\n     (\\<integral>\\<^sup>+y\\<in>{y. h 0 (y, x) \\<le> h n (y, x)}. h n (y, x)\n      \\<partial>count_space UNIV)) =\n    (\\<integral>\\<^sup>+y\\<in>{y. h 0 (y, x) \\<le> h n (y, x)}. h n (y, x)\n     \\<partial>count_space UNIV) -\n    (\\<integral>\\<^sup>+y\\<in>{y. h 0 (y, x) \\<le> h n (y, x)}. h 0 (y, x)\n     \\<partial>count_space UNIV)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+y\\<in>{y. h 0 (y, x) \\<le> h n (y, x)}. h 0 (y, x)\n    \\<partial>count_space UNIV\n    \\<le> d_IN (h 0) x", "by (auto simp: d_IN_def split: split_indicator intro!: nn_integral_mono)"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN (h 0) x + f n (SOURCE, \\<langle>x\\<rangle>) -\n    (\\<integral>\\<^sup>+y\\<in>{y. h 0 (y, x) \\<le> h n (y, x)}. h 0 (y, x)\n     \\<partial>count_space UNIV) -\n    (d_IN (h n) x -\n     (\\<integral>\\<^sup>+y\\<in>{y. h 0 (y, x) \\<le> h n (y, x)}. h n (y, x)\n      \\<partial>count_space UNIV)) =\n    (\\<integral>\\<^sup>+y\\<in>{y. h 0 (y, x) \\<le> h n (y, x)}. h n (y, x)\n     \\<partial>count_space UNIV) -\n    (\\<integral>\\<^sup>+y\\<in>{y. h 0 (y, x) \\<le> h n (y, x)}. h 0 (y, x)\n     \\<partial>count_space UNIV)", "apply (subst diff_diff_commute_ennreal)"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN (h 0) x + f n (SOURCE, \\<langle>x\\<rangle>) -\n    (d_IN (h n) x -\n     (\\<integral>\\<^sup>+y\\<in>{y. h 0 (y, x) \\<le> h n (y, x)}. h n (y, x)\n      \\<partial>count_space UNIV)) -\n    (\\<integral>\\<^sup>+y\\<in>{y. h 0 (y, x) \\<le> h n (y, x)}. h 0 (y, x)\n     \\<partial>count_space UNIV) =\n    (\\<integral>\\<^sup>+y\\<in>{y. h 0 (y, x) \\<le> h n (y, x)}. h n (y, x)\n     \\<partial>count_space UNIV) -\n    (\\<integral>\\<^sup>+y\\<in>{y. h 0 (y, x) \\<le> h n (y, x)}. h 0 (y, x)\n     \\<partial>count_space UNIV)", "apply (subst diff_diff_ennreal')"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<integral>\\<^sup>+y\\<in>{y. h 0 (y, x) \\<le> h n (y, x)}. h n (y, x)\n    \\<partial>count_space UNIV\n    \\<le> d_IN (h n) x\n 2. d_IN (h n) x -\n    (\\<integral>\\<^sup>+y\\<in>{y. h 0 (y, x) \\<le> h n (y, x)}. h n (y, x)\n     \\<partial>count_space UNIV)\n    \\<le> d_IN (h 0) x + f n (SOURCE, \\<langle>x\\<rangle>)\n 3. d_IN (h 0) x + f n (SOURCE, \\<langle>x\\<rangle>) +\n    (\\<integral>\\<^sup>+y\\<in>{y. h 0 (y, x) \\<le> h n (y, x)}. h n (y, x)\n     \\<partial>count_space UNIV) -\n    d_IN (h n) x -\n    (\\<integral>\\<^sup>+y\\<in>{y. h 0 (y, x) \\<le> h n (y, x)}. h 0 (y, x)\n     \\<partial>count_space UNIV) =\n    (\\<integral>\\<^sup>+y\\<in>{y. h 0 (y, x) \\<le> h n (y, x)}. h n (y, x)\n     \\<partial>count_space UNIV) -\n    (\\<integral>\\<^sup>+y\\<in>{y. h 0 (y, x) \\<le> h n (y, x)}. h 0 (y, x)\n     \\<partial>count_space UNIV)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+y\\<in>{y. h 0 (y, x) \\<le> h n (y, x)}. h n (y, x)\n    \\<partial>count_space UNIV\n    \\<le> d_IN (h n) x", "by (auto simp: d_IN_def split: split_indicator intro!: nn_integral_mono) []"], ["proof (prove)\ngoal (2 subgoals):\n 1. d_IN (h n) x -\n    (\\<integral>\\<^sup>+y\\<in>{y. h 0 (y, x) \\<le> h n (y, x)}. h n (y, x)\n     \\<partial>count_space UNIV)\n    \\<le> d_IN (h 0) x + f n (SOURCE, \\<langle>x\\<rangle>)\n 2. d_IN (h 0) x + f n (SOURCE, \\<langle>x\\<rangle>) +\n    (\\<integral>\\<^sup>+y\\<in>{y. h 0 (y, x) \\<le> h n (y, x)}. h n (y, x)\n     \\<partial>count_space UNIV) -\n    d_IN (h n) x -\n    (\\<integral>\\<^sup>+y\\<in>{y. h 0 (y, x) \\<le> h n (y, x)}. h 0 (y, x)\n     \\<partial>count_space UNIV) =\n    (\\<integral>\\<^sup>+y\\<in>{y. h 0 (y, x) \\<le> h n (y, x)}. h n (y, x)\n     \\<partial>count_space UNIV) -\n    (\\<integral>\\<^sup>+y\\<in>{y. h 0 (y, x) \\<le> h n (y, x)}. h 0 (y, x)\n     \\<partial>count_space UNIV)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN (h n) x -\n    (\\<integral>\\<^sup>+y\\<in>{y. h 0 (y, x) \\<le> h n (y, x)}. h n (y, x)\n     \\<partial>count_space UNIV)\n    \\<le> d_IN (h 0) x + f n (SOURCE, \\<langle>x\\<rangle>)", "unfolding eq_h_n[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+y\\<in>{y. h n (y, x) < h 0 (y, x)}. h n (y, x)\n    \\<partial>count_space UNIV\n    \\<le> d_IN (h 0) x + f n (SOURCE, \\<langle>x\\<rangle>)", "by (rule add_increasing2)\n             (auto simp add: d_IN_def split: split_indicator intro!: nn_integral_mono)"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN (h 0) x + f n (SOURCE, \\<langle>x\\<rangle>) +\n    (\\<integral>\\<^sup>+y\\<in>{y. h 0 (y, x) \\<le> h n (y, x)}. h n (y, x)\n     \\<partial>count_space UNIV) -\n    d_IN (h n) x -\n    (\\<integral>\\<^sup>+y\\<in>{y. h 0 (y, x) \\<le> h n (y, x)}. h 0 (y, x)\n     \\<partial>count_space UNIV) =\n    (\\<integral>\\<^sup>+y\\<in>{y. h 0 (y, x) \\<le> h n (y, x)}. h n (y, x)\n     \\<partial>count_space UNIV) -\n    (\\<integral>\\<^sup>+y\\<in>{y. h 0 (y, x) \\<le> h n (y, x)}. h 0 (y, x)\n     \\<partial>count_space UNIV)", "apply (subst diff_add_assoc2_ennreal[symmetric])"], ["proof (prove)\ngoal (2 subgoals):\n 1. d_IN (h n) x \\<le> d_IN (h 0) x + f n (SOURCE, \\<langle>x\\<rangle>)\n 2. d_IN (h 0) x + f n (SOURCE, \\<langle>x\\<rangle>) - d_IN (h n) x +\n    (\\<integral>\\<^sup>+y\\<in>{y. h 0 (y, x) \\<le> h n (y, x)}. h n (y, x)\n     \\<partial>count_space UNIV) -\n    (\\<integral>\\<^sup>+y\\<in>{y. h 0 (y, x) \\<le> h n (y, x)}. h 0 (y, x)\n     \\<partial>count_space UNIV) =\n    (\\<integral>\\<^sup>+y\\<in>{y. h 0 (y, x) \\<le> h n (y, x)}. h n (y, x)\n     \\<partial>count_space UNIV) -\n    (\\<integral>\\<^sup>+y\\<in>{y. h 0 (y, x) \\<le> h n (y, x)}. h 0 (y, x)\n     \\<partial>count_space UNIV)", "unfolding eq"], ["proof (prove)\ngoal (2 subgoals):\n 1. d_IN (h n) x \\<le> d_IN (h n) x\n 2. d_IN (h n) x - d_IN (h n) x +\n    (\\<integral>\\<^sup>+y\\<in>{y. h 0 (y, x) \\<le> h n (y, x)}. h n (y, x)\n     \\<partial>count_space UNIV) -\n    (\\<integral>\\<^sup>+y\\<in>{y. h 0 (y, x) \\<le> h n (y, x)}. h 0 (y, x)\n     \\<partial>count_space UNIV) =\n    (\\<integral>\\<^sup>+y\\<in>{y. h 0 (y, x) \\<le> h n (y, x)}. h n (y, x)\n     \\<partial>count_space UNIV) -\n    (\\<integral>\\<^sup>+y\\<in>{y. h 0 (y, x) \\<le> h n (y, x)}. h 0 (y, x)\n     \\<partial>count_space UNIV)", "using currentD_finite_IN[OF h]"], ["proof (prove)\nusing this:\n  d_IN (h ?n1) ?x \\<noteq> \\<top>\n\ngoal (2 subgoals):\n 1. d_IN (h n) x \\<le> d_IN (h n) x\n 2. d_IN (h n) x - d_IN (h n) x +\n    (\\<integral>\\<^sup>+y\\<in>{y. h 0 (y, x) \\<le> h n (y, x)}. h n (y, x)\n     \\<partial>count_space UNIV) -\n    (\\<integral>\\<^sup>+y\\<in>{y. h 0 (y, x) \\<le> h n (y, x)}. h 0 (y, x)\n     \\<partial>count_space UNIV) =\n    (\\<integral>\\<^sup>+y\\<in>{y. h 0 (y, x) \\<le> h n (y, x)}. h n (y, x)\n     \\<partial>count_space UNIV) -\n    (\\<integral>\\<^sup>+y\\<in>{y. h 0 (y, x) \\<le> h n (y, x)}. h 0 (y, x)\n     \\<partial>count_space UNIV)", "apply simp_all"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  d_IN (h 0) x -\n  (\\<integral>\\<^sup>+y\\<in>{y. h 0 (y, x) \\<le> h n (y, x)}. h 0 (y, x)\n   \\<partial>count_space UNIV) -\n  (d_IN (h n) x -\n   (\\<integral>\\<^sup>+y\\<in>{y. h 0 (y, x) \\<le> h n (y, x)}. h n (y, x)\n    \\<partial>count_space UNIV)) +\n  f n (SOURCE, \\<langle>x\\<rangle>) =\n  (\\<integral>\\<^sup>+y\\<in>{y. h 0 (y, x) \\<le> h n (y, x)}. h n (y, x)\n   \\<partial>count_space UNIV) -\n  (\\<integral>\\<^sup>+y\\<in>{y. h 0 (y, x) \\<le> h n (y, x)}. h 0 (y, x)\n   \\<partial>count_space UNIV)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>xo = \\<langle>x\\<rangle>; x \\<in> B \\<Gamma>;\n        x \\<in> \\<^bold>V\\<rbrakk>\n       \\<Longrightarrow> KIR (f n) xo", "also"], ["proof (state)\nthis:\n  d_IN (h 0) x -\n  (\\<integral>\\<^sup>+y\\<in>{y. h 0 (y, x) \\<le> h n (y, x)}. h 0 (y, x)\n   \\<partial>count_space UNIV) -\n  (d_IN (h n) x -\n   (\\<integral>\\<^sup>+y\\<in>{y. h 0 (y, x) \\<le> h n (y, x)}. h n (y, x)\n    \\<partial>count_space UNIV)) +\n  f n (SOURCE, \\<langle>x\\<rangle>) =\n  (\\<integral>\\<^sup>+y\\<in>{y. h 0 (y, x) \\<le> h n (y, x)}. h n (y, x)\n   \\<partial>count_space UNIV) -\n  (\\<integral>\\<^sup>+y\\<in>{y. h 0 (y, x) \\<le> h n (y, x)}. h 0 (y, x)\n   \\<partial>count_space UNIV)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>xo = \\<langle>x\\<rangle>; x \\<in> B \\<Gamma>;\n        x \\<in> \\<^bold>V\\<rbrakk>\n       \\<Longrightarrow> KIR (f n) xo", "have \"(\\<Sum>\\<^sup>+ y. h n (y, x) * indicator ?h0_le_hn y) - (\\<Sum>\\<^sup>+ y. h 0 (y, x) * indicator ?h0_le_hn y) = (\\<Sum>\\<^sup>+ y. h n (y, x) - h 0 (y, x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<integral>\\<^sup>+y\\<in>{y. h 0 (y, x) \\<le> h n (y, x)}. h n (y, x)\n     \\<partial>count_space UNIV) -\n    (\\<integral>\\<^sup>+y\\<in>{y. h 0 (y, x) \\<le> h n (y, x)}. h 0 (y, x)\n     \\<partial>count_space UNIV) =\n    (\\<Sum>\\<^sup>+ y. h n (y, x) - h 0 (y, x))", "apply(subst nn_integral_diff[symmetric])"], ["proof (prove)\ngoal (5 subgoals):\n 1. (\\<lambda>y. h n (y, x) * indicator {y. h 0 (y, x) \\<le> h n (y, x)} y)\n    \\<in> borel_measurable (count_space UNIV)\n 2. (\\<lambda>y. h 0 (y, x) * indicator {y. h 0 (y, x) \\<le> h n (y, x)} y)\n    \\<in> borel_measurable (count_space UNIV)\n 3. \\<integral>\\<^sup>+y\\<in>{y. h 0 (y, x) \\<le> h n (y, x)}. h 0 (y, x)\n    \\<partial>count_space UNIV \\<noteq>\n    \\<infinity>\n 4. AE xa in count_space\n              UNIV. h 0 (xa, x) *\n                    indicator {y. h 0 (y, x) \\<le> h n (y, x)} xa\n                    \\<le> h n (xa, x) *\n                          indicator {y. h 0 (y, x) \\<le> h n (y, x)} xa\n 5. (\\<Sum>\\<^sup>+ xa.\n       h n (xa, x) * indicator {y. h 0 (y, x) \\<le> h n (y, x)} xa -\n       h 0 (xa, x) * indicator {y. h 0 (y, x) \\<le> h n (y, x)} xa) =\n    (\\<Sum>\\<^sup>+ y. h n (y, x) - h 0 (y, x))", "apply(simp_all add: AE_count_space max_def finite1 split: split_indicator)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ xa.\n       h n (xa, x) * indicator {y. h 0 (y, x) \\<le> h n (y, x)} xa -\n       h 0 (xa, x) * indicator {y. h 0 (y, x) \\<le> h n (y, x)} xa) =\n    (\\<Sum>\\<^sup>+ y. h n (y, x) - h 0 (y, x))", "apply(rule nn_integral_cong; auto simp add: not_le split: split_indicator)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       h n (xa, x) < h 0 (xa, x) \\<Longrightarrow>\n       h n (xa, x) - h 0 (xa, x) = 0", "by (metis diff_eq_0_ennreal le_less not_le top_greatest)"], ["proof (state)\nthis:\n  (\\<integral>\\<^sup>+y\\<in>{y. h 0 (y, x) \\<le> h n (y, x)}. h n (y, x)\n   \\<partial>count_space UNIV) -\n  (\\<integral>\\<^sup>+y\\<in>{y. h 0 (y, x) \\<le> h n (y, x)}. h 0 (y, x)\n   \\<partial>count_space UNIV) =\n  (\\<Sum>\\<^sup>+ y. h n (y, x) - h 0 (y, x))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>xo = \\<langle>x\\<rangle>; x \\<in> B \\<Gamma>;\n        x \\<in> \\<^bold>V\\<rbrakk>\n       \\<Longrightarrow> KIR (f n) xo", "also"], ["proof (state)\nthis:\n  (\\<integral>\\<^sup>+y\\<in>{y. h 0 (y, x) \\<le> h n (y, x)}. h n (y, x)\n   \\<partial>count_space UNIV) -\n  (\\<integral>\\<^sup>+y\\<in>{y. h 0 (y, x) \\<le> h n (y, x)}. h 0 (y, x)\n   \\<partial>count_space UNIV) =\n  (\\<Sum>\\<^sup>+ y. h n (y, x) - h 0 (y, x))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>xo = \\<langle>x\\<rangle>; x \\<in> B \\<Gamma>;\n        x \\<in> \\<^bold>V\\<rbrakk>\n       \\<Longrightarrow> KIR (f n) xo", "have \"\\<dots> = (\\<Sum>\\<^sup>+ y\\<in>range Inner. f n (\\<langle>x\\<rangle>, y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y. h n (y, x) - h 0 (y, x)) =\n    (\\<Sum>\\<^sup>+ y\\<in>range Inner. f n (\\<langle>x\\<rangle>, y))", "using B disjoint"], ["proof (prove)\nusing this:\n  xo = \\<langle>x\\<rangle>\n  x \\<in> B \\<Gamma>\n  x \\<in> \\<^bold>V\n  A \\<Gamma> \\<inter> B \\<Gamma> = {}\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y. h n (y, x) - h 0 (y, x)) =\n    (\\<Sum>\\<^sup>+ y\\<in>range Inner. f n (\\<langle>x\\<rangle>, y))", "apply(simp add: nn_integral_count_space_reindex cong: nn_integral_cong_simp outgoing_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>xo = \\<langle>x\\<rangle>; x \\<in> B \\<Gamma>;\n     vertex \\<Gamma> x; A \\<Gamma> \\<inter> B \\<Gamma> = {}\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>\\<^sup>+ y. h n (y, x) - h 0 (y, x)) =\n                      (\\<Sum>\\<^sup>+ xa.\n                         if edge \\<Gamma> x xa\n                         then h 0 (x, xa) - h n (x, xa)\n                         else if edge \\<Gamma> xa x\n                              then h n (xa, x) - h 0 (xa, x) else 0)", "apply(auto simp add: B_out currentD_outside[OF h] max.commute intro!: nn_integral_cong split: split_indicator dest: edge_antiparallel)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y. h n (y, x) - h 0 (y, x)) =\n  (\\<Sum>\\<^sup>+ y\\<in>range Inner. f n (\\<langle>x\\<rangle>, y))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>xo = \\<langle>x\\<rangle>; x \\<in> B \\<Gamma>;\n        x \\<in> \\<^bold>V\\<rbrakk>\n       \\<Longrightarrow> KIR (f n) xo", "also"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y. h n (y, x) - h 0 (y, x)) =\n  (\\<Sum>\\<^sup>+ y\\<in>range Inner. f n (\\<langle>x\\<rangle>, y))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>xo = \\<langle>x\\<rangle>; x \\<in> B \\<Gamma>;\n        x \\<in> \\<^bold>V\\<rbrakk>\n       \\<Longrightarrow> KIR (f n) xo", "have \"\\<dots> = (\\<Sum>\\<^sup>+ y. f n (\\<langle>x\\<rangle>, y) * indicator (range Inner) y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y\\<in>range Inner. f n (\\<langle>x\\<rangle>, y)) =\n    \\<integral>\\<^sup>+y\\<in>range Inner. f n (\\<langle>x\\<rangle>, y)\n    \\<partial>count_space UNIV", "by(simp add: nn_integral_add nn_integral_count_space_indicator max.left_commute max.commute)"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y\\<in>range Inner. f n (\\<langle>x\\<rangle>, y)) =\n  \\<integral>\\<^sup>+y\\<in>range Inner. f n (\\<langle>x\\<rangle>, y)\n  \\<partial>count_space UNIV\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>xo = \\<langle>x\\<rangle>; x \\<in> B \\<Gamma>;\n        x \\<in> \\<^bold>V\\<rbrakk>\n       \\<Longrightarrow> KIR (f n) xo", "also"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y\\<in>range Inner. f n (\\<langle>x\\<rangle>, y)) =\n  \\<integral>\\<^sup>+y\\<in>range Inner. f n (\\<langle>x\\<rangle>, y)\n  \\<partial>count_space UNIV\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>xo = \\<langle>x\\<rangle>; x \\<in> B \\<Gamma>;\n        x \\<in> \\<^bold>V\\<rbrakk>\n       \\<Longrightarrow> KIR (f n) xo", "have \"\\<dots> = d_OUT (f n) \\<langle>x\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+y\\<in>range Inner. f n (\\<langle>x\\<rangle>, y)\n    \\<partial>count_space UNIV =\n    d_OUT (f n) \\<langle>x\\<rangle>", "using B disjoint"], ["proof (prove)\nusing this:\n  xo = \\<langle>x\\<rangle>\n  x \\<in> B \\<Gamma>\n  x \\<in> \\<^bold>V\n  A \\<Gamma> \\<inter> B \\<Gamma> = {}\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+y\\<in>range Inner. f n (\\<langle>x\\<rangle>, y)\n    \\<partial>count_space UNIV =\n    d_OUT (f n) \\<langle>x\\<rangle>", "unfolding d_OUT_def"], ["proof (prove)\nusing this:\n  xo = \\<langle>x\\<rangle>\n  x \\<in> B \\<Gamma>\n  x \\<in> \\<^bold>V\n  A \\<Gamma> \\<inter> B \\<Gamma> = {}\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+y\\<in>range Inner. f n (\\<langle>x\\<rangle>, y)\n    \\<partial>count_space UNIV =\n    (\\<Sum>\\<^sup>+ y. f n (\\<langle>x\\<rangle>, y))", "by(intro nn_integral_cong)(auto split: split_indicator simp add: notin_range_Inner)"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+y\\<in>range Inner. f n (\\<langle>x\\<rangle>, y)\n  \\<partial>count_space UNIV =\n  d_OUT (f n) \\<langle>x\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>xo = \\<langle>x\\<rangle>; x \\<in> B \\<Gamma>;\n        x \\<in> \\<^bold>V\\<rbrakk>\n       \\<Longrightarrow> KIR (f n) xo", "finally"], ["proof (chain)\npicking this:\n  d_IN (f n) \\<langle>x\\<rangle> = d_OUT (f n) \\<langle>x\\<rangle>", "show ?thesis"], ["proof (prove)\nusing this:\n  d_IN (f n) \\<langle>x\\<rangle> = d_OUT (f n) \\<langle>x\\<rangle>\n\ngoal (1 subgoal):\n 1. KIR (f n) xo", "using B"], ["proof (prove)\nusing this:\n  d_IN (f n) \\<langle>x\\<rangle> = d_OUT (f n) \\<langle>x\\<rangle>\n  xo = \\<langle>x\\<rangle>\n  x \\<in> B \\<Gamma>\n  x \\<in> \\<^bold>V\n\ngoal (1 subgoal):\n 1. KIR (f n) xo", "by(simp)"], ["proof (state)\nthis:\n  KIR (f n) xo\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  KIR (f n) xo\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  flow \\<Psi> (f ?n1)\n\ngoal (1 subgoal):\n 1. \\<exists>h'.\n       current \\<Gamma> h' \\<and>\n       wave \\<Gamma> h' \\<and>\n       B \\<Gamma> \\<inter> \\<^bold>V \\<subseteq> SAT \\<Gamma> h'", "have \"weight \\<Gamma> b - d_IN (h 0) b = (SUP n. value_flow \\<Psi> (f n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. weight \\<Gamma> b - d_IN (h 0) b =\n    (\\<Squnion>n. value_flow \\<Psi> (f n))", "using OUT_f_SOURCE currentD_finite_IN[OF h, of 0 b] IN"], ["proof (prove)\nusing this:\n  d_OUT (f ?n1) SOURCE = d_IN (h ?n1) b - d_IN (h 0) b\n  d_IN (h 0) b \\<noteq> \\<top>\n  (\\<Squnion>n. d_IN (h n) b) = weight \\<Gamma> b\n\ngoal (1 subgoal):\n 1. weight \\<Gamma> b - d_IN (h 0) b =\n    (\\<Squnion>n. value_flow \\<Psi> (f n))", "by (simp add: SUP_diff_ennreal less_top)"], ["proof (state)\nthis:\n  weight \\<Gamma> b - d_IN (h 0) b = (\\<Squnion>n. value_flow \\<Psi> (f n))\n\ngoal (1 subgoal):\n 1. \\<exists>h'.\n       current \\<Gamma> h' \\<and>\n       wave \\<Gamma> h' \\<and>\n       B \\<Gamma> \\<inter> \\<^bold>V \\<subseteq> SAT \\<Gamma> h'", "also"], ["proof (state)\nthis:\n  weight \\<Gamma> b - d_IN (h 0) b = (\\<Squnion>n. value_flow \\<Psi> (f n))\n\ngoal (1 subgoal):\n 1. \\<exists>h'.\n       current \\<Gamma> h' \\<and>\n       wave \\<Gamma> h' \\<and>\n       B \\<Gamma> \\<inter> \\<^bold>V \\<subseteq> SAT \\<Gamma> h'", "have \"(SUP n. value_flow \\<Psi> (f n)) \\<le> \\<alpha>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Squnion>n. value_flow \\<Psi> (f n)) \\<le> \\<alpha>", "unfolding \\<alpha>_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Squnion>n. value_flow \\<Psi> (f n))\n    \\<le> \\<Squnion> (value_flow \\<Psi> ` Collect (flow \\<Psi>))", "apply(rule SUP_least)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       n \\<in> UNIV \\<Longrightarrow>\n       value_flow \\<Psi> (f n)\n       \\<le> \\<Squnion> (value_flow \\<Psi> ` Collect (flow \\<Psi>))", "apply(rule SUP_upper)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n. n \\<in> UNIV \\<Longrightarrow> f n \\<in> Collect (flow \\<Psi>)", "apply(simp add: f)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (\\<Squnion>n. value_flow \\<Psi> (f n)) \\<le> \\<alpha>\n\ngoal (1 subgoal):\n 1. \\<exists>h'.\n       current \\<Gamma> h' \\<and>\n       wave \\<Gamma> h' \\<and>\n       B \\<Gamma> \\<inter> \\<^bold>V \\<subseteq> SAT \\<Gamma> h'", "also"], ["proof (state)\nthis:\n  (\\<Squnion>n. value_flow \\<Psi> (f n)) \\<le> \\<alpha>\n\ngoal (1 subgoal):\n 1. \\<exists>h'.\n       current \\<Gamma> h' \\<and>\n       wave \\<Gamma> h' \\<and>\n       B \\<Gamma> \\<inter> \\<^bold>V \\<subseteq> SAT \\<Gamma> h'", "have \"\\<alpha> \\<le> weight \\<Gamma> b - d_IN (h 0) b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha> \\<le> weight \\<Gamma> b - d_IN (h 0) b", "unfolding \\<alpha>_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Squnion> (value_flow \\<Psi> ` Collect (flow \\<Psi>))\n    \\<le> weight \\<Gamma> b - d_IN (h 0) b", "proof(rule SUP_least; clarsimp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f.\n       flow \\<Psi> f \\<Longrightarrow>\n       d_OUT f SOURCE \\<le> weight \\<Gamma> b - d_IN (h 0) b", "fix f"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f.\n       flow \\<Psi> f \\<Longrightarrow>\n       d_OUT f SOURCE \\<le> weight \\<Gamma> b - d_IN (h 0) b", "assume f: \"flow \\<Psi> f\""], ["proof (state)\nthis:\n  flow \\<Psi> f\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       flow \\<Psi> f \\<Longrightarrow>\n       d_OUT f SOURCE \\<le> weight \\<Gamma> b - d_IN (h 0) b", "have \"d_OUT f SOURCE = (\\<Sum>\\<^sup>+ y. f (SOURCE, y) * indicator {\\<langle>b\\<rangle>} y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT f SOURCE =\n    \\<integral>\\<^sup>+y\\<in>{\\<langle>b\\<rangle>}. f (SOURCE, y)\n    \\<partial>count_space UNIV", "unfolding d_OUT_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y. f (SOURCE, y)) =\n    \\<integral>\\<^sup>+y\\<in>{\\<langle>b\\<rangle>}. f (SOURCE, y)\n    \\<partial>count_space UNIV", "apply(rule nn_integral_cong)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> space (count_space UNIV) \\<Longrightarrow>\n       f (SOURCE, x) = f (SOURCE, x) * indicator {\\<langle>b\\<rangle>} x", "subgoal for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> space (count_space UNIV) \\<Longrightarrow>\n    f (SOURCE, x) = f (SOURCE, x) * indicator {\\<langle>b\\<rangle>} x", "using flowD_capacity[OF f, of \"(SOURCE, x)\"]"], ["proof (prove)\nusing this:\n  f (SOURCE, x) \\<le> capacity \\<Psi> (SOURCE, x)\n\ngoal (1 subgoal):\n 1. x \\<in> space (count_space UNIV) \\<Longrightarrow>\n    f (SOURCE, x) = f (SOURCE, x) * indicator {\\<langle>b\\<rangle>} x", "by(auto split: split_indicator)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  d_OUT f SOURCE =\n  \\<integral>\\<^sup>+y\\<in>{\\<langle>b\\<rangle>}. f (SOURCE, y)\n  \\<partial>count_space UNIV\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       flow \\<Psi> f \\<Longrightarrow>\n       d_OUT f SOURCE \\<le> weight \\<Gamma> b - d_IN (h 0) b", "also"], ["proof (state)\nthis:\n  d_OUT f SOURCE =\n  \\<integral>\\<^sup>+y\\<in>{\\<langle>b\\<rangle>}. f (SOURCE, y)\n  \\<partial>count_space UNIV\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       flow \\<Psi> f \\<Longrightarrow>\n       d_OUT f SOURCE \\<le> weight \\<Gamma> b - d_IN (h 0) b", "have \"\\<dots> = f (SOURCE, \\<langle>b\\<rangle>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+y\\<in>{\\<langle>b\\<rangle>}. f (SOURCE, y)\n    \\<partial>count_space UNIV =\n    f (SOURCE, \\<langle>b\\<rangle>)", "by(simp add: max_def)"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+y\\<in>{\\<langle>b\\<rangle>}. f (SOURCE, y)\n  \\<partial>count_space UNIV =\n  f (SOURCE, \\<langle>b\\<rangle>)\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       flow \\<Psi> f \\<Longrightarrow>\n       d_OUT f SOURCE \\<le> weight \\<Gamma> b - d_IN (h 0) b", "also"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+y\\<in>{\\<langle>b\\<rangle>}. f (SOURCE, y)\n  \\<partial>count_space UNIV =\n  f (SOURCE, \\<langle>b\\<rangle>)\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       flow \\<Psi> f \\<Longrightarrow>\n       d_OUT f SOURCE \\<le> weight \\<Gamma> b - d_IN (h 0) b", "have \"\\<dots> \\<le> weight \\<Gamma> b - d_IN (h 0) b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f (SOURCE, \\<langle>b\\<rangle>) \\<le> weight \\<Gamma> b - d_IN (h 0) b", "using flowD_capacity[OF f, of \"(SOURCE, \\<langle>b\\<rangle>)\"]"], ["proof (prove)\nusing this:\n  f (SOURCE, \\<langle>b\\<rangle>)\n  \\<le> capacity \\<Psi> (SOURCE, \\<langle>b\\<rangle>)\n\ngoal (1 subgoal):\n 1. f (SOURCE, \\<langle>b\\<rangle>) \\<le> weight \\<Gamma> b - d_IN (h 0) b", "by simp"], ["proof (state)\nthis:\n  f (SOURCE, \\<langle>b\\<rangle>) \\<le> weight \\<Gamma> b - d_IN (h 0) b\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       flow \\<Psi> f \\<Longrightarrow>\n       d_OUT f SOURCE \\<le> weight \\<Gamma> b - d_IN (h 0) b", "finally"], ["proof (chain)\npicking this:\n  d_OUT f SOURCE \\<le> weight \\<Gamma> b - d_IN (h 0) b", "show \"d_OUT f SOURCE \\<le> \\<dots>\""], ["proof (prove)\nusing this:\n  d_OUT f SOURCE \\<le> weight \\<Gamma> b - d_IN (h 0) b\n\ngoal (1 subgoal):\n 1. d_OUT f SOURCE \\<le> weight \\<Gamma> b - d_IN (h 0) b", "."], ["proof (state)\nthis:\n  d_OUT f SOURCE \\<le> weight \\<Gamma> b - d_IN (h 0) b\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<alpha> \\<le> weight \\<Gamma> b - d_IN (h 0) b\n\ngoal (1 subgoal):\n 1. \\<exists>h'.\n       current \\<Gamma> h' \\<and>\n       wave \\<Gamma> h' \\<and>\n       B \\<Gamma> \\<inter> \\<^bold>V \\<subseteq> SAT \\<Gamma> h'", "ultimately"], ["proof (chain)\npicking this:\n  weight \\<Gamma> b - d_IN (h 0) b \\<le> \\<alpha>\n  \\<alpha> \\<le> weight \\<Gamma> b - d_IN (h 0) b", "have \\<alpha>: \"\\<alpha> = weight \\<Gamma> b - d_IN (h 0) b\""], ["proof (prove)\nusing this:\n  weight \\<Gamma> b - d_IN (h 0) b \\<le> \\<alpha>\n  \\<alpha> \\<le> weight \\<Gamma> b - d_IN (h 0) b\n\ngoal (1 subgoal):\n 1. \\<alpha> = weight \\<Gamma> b - d_IN (h 0) b", "by(rule antisym[rotated])"], ["proof (state)\nthis:\n  \\<alpha> = weight \\<Gamma> b - d_IN (h 0) b\n\ngoal (1 subgoal):\n 1. \\<exists>h'.\n       current \\<Gamma> h' \\<and>\n       wave \\<Gamma> h' \\<and>\n       B \\<Gamma> \\<inter> \\<^bold>V \\<subseteq> SAT \\<Gamma> h'", "hence \\<alpha>_finite: \"\\<alpha> \\<noteq> \\<top>\""], ["proof (prove)\nusing this:\n  \\<alpha> = weight \\<Gamma> b - d_IN (h 0) b\n\ngoal (1 subgoal):\n 1. \\<alpha> \\<noteq> \\<top>", "by simp"], ["proof (state)\nthis:\n  \\<alpha> \\<noteq> \\<top>\n\ngoal (1 subgoal):\n 1. \\<exists>h'.\n       current \\<Gamma> h' \\<and>\n       wave \\<Gamma> h' \\<and>\n       B \\<Gamma> \\<inter> \\<^bold>V \\<subseteq> SAT \\<Gamma> h'", "from \\<Psi>.ex_max_flow"], ["proof (chain)\npicking this:\n  \\<exists>f.\n     flow \\<Psi> f \\<and>\n     value_flow \\<Psi> f =\n     \\<Squnion> (value_flow \\<Psi> ` {g. flow \\<Psi> g}) \\<and>\n     (\\<forall>x. d_IN f x \\<le> value_flow \\<Psi> f)", "obtain g where g: \"flow \\<Psi> g\"\n    and value_g: \"value_flow \\<Psi> g = \\<alpha>\"\n    and IN_g: \"\\<And>x. d_IN g x \\<le> value_flow \\<Psi> g\""], ["proof (prove)\nusing this:\n  \\<exists>f.\n     flow \\<Psi> f \\<and>\n     value_flow \\<Psi> f =\n     \\<Squnion> (value_flow \\<Psi> ` {g. flow \\<Psi> g}) \\<and>\n     (\\<forall>x. d_IN f x \\<le> value_flow \\<Psi> f)\n\ngoal (1 subgoal):\n 1. (\\<And>g.\n        \\<lbrakk>flow \\<Psi> g; value_flow \\<Psi> g = \\<alpha>;\n         \\<And>x. d_IN g x \\<le> value_flow \\<Psi> g\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding \\<alpha>_def"], ["proof (prove)\nusing this:\n  \\<exists>f.\n     flow \\<Psi> f \\<and>\n     value_flow \\<Psi> f =\n     \\<Squnion> (value_flow \\<Psi> ` {g. flow \\<Psi> g}) \\<and>\n     (\\<forall>x. d_IN f x \\<le> value_flow \\<Psi> f)\n\ngoal (1 subgoal):\n 1. (\\<And>g.\n        \\<lbrakk>flow \\<Psi> g;\n         value_flow \\<Psi> g =\n         \\<Squnion> (value_flow \\<Psi> ` Collect (flow \\<Psi>));\n         \\<And>x. d_IN g x \\<le> value_flow \\<Psi> g\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  flow \\<Psi> g\n  value_flow \\<Psi> g = \\<alpha>\n  d_IN g ?x1 \\<le> value_flow \\<Psi> g\n\ngoal (1 subgoal):\n 1. \\<exists>h'.\n       current \\<Gamma> h' \\<and>\n       wave \\<Gamma> h' \\<and>\n       B \\<Gamma> \\<inter> \\<^bold>V \\<subseteq> SAT \\<Gamma> h'", "have g_le_h0: \"g (\\<langle>x\\<rangle>, \\<langle>y\\<rangle>) \\<le> h 0 (x, y)\" if \"edge \\<Gamma> x y\" for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. g (\\<langle>x\\<rangle>, \\<langle>y\\<rangle>) \\<le> h 0 (x, y)", "using flowD_capacity[OF g, of \"(\\<langle>x\\<rangle>, \\<langle>y\\<rangle>)\"] that"], ["proof (prove)\nusing this:\n  g (\\<langle>x\\<rangle>, \\<langle>y\\<rangle>)\n  \\<le> capacity \\<Psi> (\\<langle>x\\<rangle>, \\<langle>y\\<rangle>)\n  edge \\<Gamma> x y\n\ngoal (1 subgoal):\n 1. g (\\<langle>x\\<rangle>, \\<langle>y\\<rangle>) \\<le> h 0 (x, y)", "by simp"], ["proof (state)\nthis:\n  edge \\<Gamma> ?x1 ?y1 \\<Longrightarrow>\n  g (\\<langle>?x1\\<rangle>, \\<langle>?y1\\<rangle>) \\<le> h 0 (?x1, ?y1)\n\ngoal (1 subgoal):\n 1. \\<exists>h'.\n       current \\<Gamma> h' \\<and>\n       wave \\<Gamma> h' \\<and>\n       B \\<Gamma> \\<inter> \\<^bold>V \\<subseteq> SAT \\<Gamma> h'", "note [simp] = \\<Psi>.flowD_finite[OF g]"], ["proof (state)\nthis:\n  g ?e \\<noteq> \\<top>\n\ngoal (1 subgoal):\n 1. \\<exists>h'.\n       current \\<Gamma> h' \\<and>\n       wave \\<Gamma> h' \\<and>\n       B \\<Gamma> \\<inter> \\<^bold>V \\<subseteq> SAT \\<Gamma> h'", "have g_SOURCE: \"g (SOURCE, \\<langle>x\\<rangle>) = (if x = b then \\<alpha> else 0)\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. g (SOURCE, \\<langle>x\\<rangle>) = (if x = b then \\<alpha> else 0)", "proof(cases \"x = b\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x = b \\<Longrightarrow>\n    g (SOURCE, \\<langle>x\\<rangle>) = (if x = b then \\<alpha> else 0)\n 2. x \\<noteq> b \\<Longrightarrow>\n    g (SOURCE, \\<langle>x\\<rangle>) = (if x = b then \\<alpha> else 0)", "case True"], ["proof (state)\nthis:\n  x = b\n\ngoal (2 subgoals):\n 1. x = b \\<Longrightarrow>\n    g (SOURCE, \\<langle>x\\<rangle>) = (if x = b then \\<alpha> else 0)\n 2. x \\<noteq> b \\<Longrightarrow>\n    g (SOURCE, \\<langle>x\\<rangle>) = (if x = b then \\<alpha> else 0)", "have \"g (SOURCE, \\<langle>x\\<rangle>) = (\\<Sum>\\<^sup>+ y. g (SOURCE, y) * indicator {\\<langle>x\\<rangle>} y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g (SOURCE, \\<langle>x\\<rangle>) =\n    \\<integral>\\<^sup>+y\\<in>{\\<langle>x\\<rangle>}. g (SOURCE, y)\n    \\<partial>count_space UNIV", "by(simp add: max_def)"], ["proof (state)\nthis:\n  g (SOURCE, \\<langle>x\\<rangle>) =\n  \\<integral>\\<^sup>+y\\<in>{\\<langle>x\\<rangle>}. g (SOURCE, y)\n  \\<partial>count_space UNIV\n\ngoal (2 subgoals):\n 1. x = b \\<Longrightarrow>\n    g (SOURCE, \\<langle>x\\<rangle>) = (if x = b then \\<alpha> else 0)\n 2. x \\<noteq> b \\<Longrightarrow>\n    g (SOURCE, \\<langle>x\\<rangle>) = (if x = b then \\<alpha> else 0)", "also"], ["proof (state)\nthis:\n  g (SOURCE, \\<langle>x\\<rangle>) =\n  \\<integral>\\<^sup>+y\\<in>{\\<langle>x\\<rangle>}. g (SOURCE, y)\n  \\<partial>count_space UNIV\n\ngoal (2 subgoals):\n 1. x = b \\<Longrightarrow>\n    g (SOURCE, \\<langle>x\\<rangle>) = (if x = b then \\<alpha> else 0)\n 2. x \\<noteq> b \\<Longrightarrow>\n    g (SOURCE, \\<langle>x\\<rangle>) = (if x = b then \\<alpha> else 0)", "have \"\\<dots> = value_flow \\<Psi> g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+y\\<in>{\\<langle>x\\<rangle>}. g (SOURCE, y)\n    \\<partial>count_space UNIV =\n    value_flow \\<Psi> g", "unfolding d_OUT_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+y\\<in>{\\<langle>x\\<rangle>}. g (SOURCE, y)\n    \\<partial>count_space UNIV =\n    (\\<Sum>\\<^sup>+ y. g (source \\<Psi>, y))", "using True"], ["proof (prove)\nusing this:\n  x = b\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+y\\<in>{\\<langle>x\\<rangle>}. g (SOURCE, y)\n    \\<partial>count_space UNIV =\n    (\\<Sum>\\<^sup>+ y. g (source \\<Psi>, y))", "by(intro nn_integral_cong)(auto split: split_indicator intro: \\<Psi>.flowD_outside[OF g])"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+y\\<in>{\\<langle>x\\<rangle>}. g (SOURCE, y)\n  \\<partial>count_space UNIV =\n  value_flow \\<Psi> g\n\ngoal (2 subgoals):\n 1. x = b \\<Longrightarrow>\n    g (SOURCE, \\<langle>x\\<rangle>) = (if x = b then \\<alpha> else 0)\n 2. x \\<noteq> b \\<Longrightarrow>\n    g (SOURCE, \\<langle>x\\<rangle>) = (if x = b then \\<alpha> else 0)", "finally"], ["proof (chain)\npicking this:\n  g (SOURCE, \\<langle>x\\<rangle>) = value_flow \\<Psi> g", "show ?thesis"], ["proof (prove)\nusing this:\n  g (SOURCE, \\<langle>x\\<rangle>) = value_flow \\<Psi> g\n\ngoal (1 subgoal):\n 1. g (SOURCE, \\<langle>x\\<rangle>) = (if x = b then \\<alpha> else 0)", "using value_g"], ["proof (prove)\nusing this:\n  g (SOURCE, \\<langle>x\\<rangle>) = value_flow \\<Psi> g\n  value_flow \\<Psi> g = \\<alpha>\n\ngoal (1 subgoal):\n 1. g (SOURCE, \\<langle>x\\<rangle>) = (if x = b then \\<alpha> else 0)", "by(simp add: True)"], ["proof (state)\nthis:\n  g (SOURCE, \\<langle>x\\<rangle>) = (if x = b then \\<alpha> else 0)\n\ngoal (1 subgoal):\n 1. x \\<noteq> b \\<Longrightarrow>\n    g (SOURCE, \\<langle>x\\<rangle>) = (if x = b then \\<alpha> else 0)", "qed(simp add: \\<Psi>.flowD_outside[OF g])"], ["proof (state)\nthis:\n  g (SOURCE, \\<langle>?x1\\<rangle>) = (if ?x1 = b then \\<alpha> else 0)\n\ngoal (1 subgoal):\n 1. \\<exists>h'.\n       current \\<Gamma> h' \\<and>\n       wave \\<Gamma> h' \\<and>\n       B \\<Gamma> \\<inter> \\<^bold>V \\<subseteq> SAT \\<Gamma> h'", "let ?g = \"\\<lambda>(x, y). g (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>h'.\n       current \\<Gamma> h' \\<and>\n       wave \\<Gamma> h' \\<and>\n       B \\<Gamma> \\<inter> \\<^bold>V \\<subseteq> SAT \\<Gamma> h'", "define h' where \"h' = h 0 \\<oplus> ?g\""], ["proof (state)\nthis:\n  h' =\n  h 0 \\<oplus>\n  (\\<lambda>(x, y). g (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>))\n\ngoal (1 subgoal):\n 1. \\<exists>h'.\n       current \\<Gamma> h' \\<and>\n       wave \\<Gamma> h' \\<and>\n       B \\<Gamma> \\<inter> \\<^bold>V \\<subseteq> SAT \\<Gamma> h'", "have h'_simps: \"h' (x, y) = (if edge \\<Gamma> x y then h 0 (x, y) + g (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>) - g (\\<langle>x\\<rangle>, \\<langle>y\\<rangle>) else 0)\" for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. h' (x, y) =\n    (if edge \\<Gamma> x y\n     then h 0 (x, y) + g (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>) -\n          g (\\<langle>x\\<rangle>, \\<langle>y\\<rangle>)\n     else 0)", "by(simp add: h'_def)"], ["proof (state)\nthis:\n  h' (?x1, ?y1) =\n  (if edge \\<Gamma> ?x1 ?y1\n   then h 0 (?x1, ?y1) + g (\\<langle>?y1\\<rangle>, \\<langle>?x1\\<rangle>) -\n        g (\\<langle>?x1\\<rangle>, \\<langle>?y1\\<rangle>)\n   else 0)\n\ngoal (1 subgoal):\n 1. \\<exists>h'.\n       current \\<Gamma> h' \\<and>\n       wave \\<Gamma> h' \\<and>\n       B \\<Gamma> \\<inter> \\<^bold>V \\<subseteq> SAT \\<Gamma> h'", "have OUT_h'_B [simp]: \"d_OUT h' x = 0\" if \"x \\<in> B \\<Gamma>\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT h' x = 0", "using that"], ["proof (prove)\nusing this:\n  x \\<in> B \\<Gamma>\n\ngoal (1 subgoal):\n 1. d_OUT h' x = 0", "unfolding d_OUT_def"], ["proof (prove)\nusing this:\n  x \\<in> B \\<Gamma>\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y. h' (x, y)) = 0", "by(simp add: nn_integral_0_iff emeasure_count_space_eq_0)(simp add: h'_simps B_out)"], ["proof (state)\nthis:\n  ?x1 \\<in> B \\<Gamma> \\<Longrightarrow> d_OUT h' ?x1 = 0\n\ngoal (1 subgoal):\n 1. \\<exists>h'.\n       current \\<Gamma> h' \\<and>\n       wave \\<Gamma> h' \\<and>\n       B \\<Gamma> \\<inter> \\<^bold>V \\<subseteq> SAT \\<Gamma> h'", "have IN_h'_A [simp]: \"d_IN h' x = 0\" if \"x \\<in> A \\<Gamma>\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN h' x = 0", "using that"], ["proof (prove)\nusing this:\n  x \\<in> A \\<Gamma>\n\ngoal (1 subgoal):\n 1. d_IN h' x = 0", "unfolding d_IN_def"], ["proof (prove)\nusing this:\n  x \\<in> A \\<Gamma>\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ xa. h' (xa, x)) = 0", "by(simp add: nn_integral_0_iff emeasure_count_space_eq_0)(simp add: h'_simps A_in)"], ["proof (state)\nthis:\n  ?x1 \\<in> A \\<Gamma> \\<Longrightarrow> d_IN h' ?x1 = 0\n\ngoal (1 subgoal):\n 1. \\<exists>h'.\n       current \\<Gamma> h' \\<and>\n       wave \\<Gamma> h' \\<and>\n       B \\<Gamma> \\<inter> \\<^bold>V \\<subseteq> SAT \\<Gamma> h'", "have h'_outside: \"h' e = 0\" if \"e \\<notin> \\<^bold>E\" for e"], ["proof (prove)\ngoal (1 subgoal):\n 1. h' e = 0", "unfolding h'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (h 0 \\<oplus>\n     (\\<lambda>(x, y). g (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>)))\n     e =\n    0", "using that"], ["proof (prove)\nusing this:\n  e \\<notin> \\<^bold>E\n\ngoal (1 subgoal):\n 1. (h 0 \\<oplus>\n     (\\<lambda>(x, y). g (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>)))\n     e =\n    0", "by(rule plus_flow_outside)"], ["proof (state)\nthis:\n  ?e1 \\<notin> \\<^bold>E \\<Longrightarrow> h' ?e1 = 0\n\ngoal (1 subgoal):\n 1. \\<exists>h'.\n       current \\<Gamma> h' \\<and>\n       wave \\<Gamma> h' \\<and>\n       B \\<Gamma> \\<inter> \\<^bold>V \\<subseteq> SAT \\<Gamma> h'", "have OUT_h'_outside: \"d_OUT h' x = 0\" and IN_h'_outside: \"d_IN h' x = 0\" if \"x \\<notin> \\<^bold>V\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT h' x = 0 &&& d_IN h' x = 0", "using that"], ["proof (prove)\nusing this:\n  x \\<notin> \\<^bold>V\n\ngoal (1 subgoal):\n 1. d_OUT h' x = 0 &&& d_IN h' x = 0", "by(auto simp add: d_OUT_def d_IN_def nn_integral_0_iff emeasure_count_space_eq_0 vertex_def intro: h'_outside)"], ["proof (state)\nthis:\n  ?x1 \\<notin> \\<^bold>V \\<Longrightarrow> d_OUT h' ?x1 = 0\n  ?x1 \\<notin> \\<^bold>V \\<Longrightarrow> d_IN h' ?x1 = 0\n\ngoal (1 subgoal):\n 1. \\<exists>h'.\n       current \\<Gamma> h' \\<and>\n       wave \\<Gamma> h' \\<and>\n       B \\<Gamma> \\<inter> \\<^bold>V \\<subseteq> SAT \\<Gamma> h'", "have g_le_OUT: \"g (SINK, \\<langle>x\\<rangle>) \\<le> d_OUT g \\<langle>x\\<rangle>\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. g (vertex.SINK, \\<langle>x\\<rangle>) \\<le> d_OUT g \\<langle>x\\<rangle>", "by (subst flowD_KIR[OF g]) (simp_all add: d_IN_ge_point)"], ["proof (state)\nthis:\n  g (vertex.SINK, \\<langle>?x1\\<rangle>) \\<le> d_OUT g \\<langle>?x1\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<exists>h'.\n       current \\<Gamma> h' \\<and>\n       wave \\<Gamma> h' \\<and>\n       B \\<Gamma> \\<inter> \\<^bold>V \\<subseteq> SAT \\<Gamma> h'", "have OUT_g_A: \"d_OUT ?g x = d_OUT g \\<langle>x\\<rangle> - g (SINK, \\<langle>x\\<rangle>)\" if \"x \\<in> A \\<Gamma>\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT (\\<lambda>(x, y). g (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>))\n     x =\n    d_OUT g \\<langle>x\\<rangle> - g (vertex.SINK, \\<langle>x\\<rangle>)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. d_OUT (\\<lambda>(x, y). g (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>))\n     x =\n    d_OUT g \\<langle>x\\<rangle> - g (vertex.SINK, \\<langle>x\\<rangle>)", "have \"d_OUT ?g x = (\\<Sum>\\<^sup>+ y\\<in>range Inner. g (y, \\<langle>x\\<rangle>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT (\\<lambda>(x, y). g (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>))\n     x =\n    (\\<Sum>\\<^sup>+ y\\<in>range Inner. g (y, \\<langle>x\\<rangle>))", "by(simp add: nn_integral_count_space_reindex d_OUT_def)"], ["proof (state)\nthis:\n  d_OUT (\\<lambda>(x, y). g (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>)) x =\n  (\\<Sum>\\<^sup>+ y\\<in>range Inner. g (y, \\<langle>x\\<rangle>))\n\ngoal (1 subgoal):\n 1. d_OUT (\\<lambda>(x, y). g (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>))\n     x =\n    d_OUT g \\<langle>x\\<rangle> - g (vertex.SINK, \\<langle>x\\<rangle>)", "also"], ["proof (state)\nthis:\n  d_OUT (\\<lambda>(x, y). g (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>)) x =\n  (\\<Sum>\\<^sup>+ y\\<in>range Inner. g (y, \\<langle>x\\<rangle>))\n\ngoal (1 subgoal):\n 1. d_OUT (\\<lambda>(x, y). g (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>))\n     x =\n    d_OUT g \\<langle>x\\<rangle> - g (vertex.SINK, \\<langle>x\\<rangle>)", "have \"\\<dots> = d_IN g \\<langle>x\\<rangle> - (\\<Sum>\\<^sup>+ y. g (y, \\<langle>x\\<rangle>) * indicator {SINK} y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y\\<in>range Inner. g (y, \\<langle>x\\<rangle>)) =\n    d_IN g \\<langle>x\\<rangle> -\n    (\\<integral>\\<^sup>+y\\<in>{vertex.SINK}. g (y, \\<langle>x\\<rangle>)\n     \\<partial>count_space UNIV)", "unfolding d_IN_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y\\<in>range Inner. g (y, \\<langle>x\\<rangle>)) =\n    (\\<Sum>\\<^sup>+ xa. g (xa, \\<langle>x\\<rangle>)) -\n    (\\<integral>\\<^sup>+y\\<in>{vertex.SINK}. g (y, \\<langle>x\\<rangle>)\n     \\<partial>count_space UNIV)", "using that b disjoint flowD_capacity[OF g, of \"(SOURCE, \\<langle>x\\<rangle>)\"]"], ["proof (prove)\nusing this:\n  x \\<in> A \\<Gamma>\n  b \\<in> B \\<Gamma>\n  A \\<Gamma> \\<inter> B \\<Gamma> = {}\n  g (SOURCE, \\<langle>x\\<rangle>)\n  \\<le> capacity \\<Psi> (SOURCE, \\<langle>x\\<rangle>)\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y\\<in>range Inner. g (y, \\<langle>x\\<rangle>)) =\n    (\\<Sum>\\<^sup>+ xa. g (xa, \\<langle>x\\<rangle>)) -\n    (\\<integral>\\<^sup>+y\\<in>{vertex.SINK}. g (y, \\<langle>x\\<rangle>)\n     \\<partial>count_space UNIV)", "by(subst nn_integral_diff[symmetric])\n        (auto simp add: nn_integral_count_space_indicator notin_range_Inner max_def intro!: nn_integral_cong split: split_indicator if_split_asm)"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y\\<in>range Inner. g (y, \\<langle>x\\<rangle>)) =\n  d_IN g \\<langle>x\\<rangle> -\n  (\\<integral>\\<^sup>+y\\<in>{vertex.SINK}. g (y, \\<langle>x\\<rangle>)\n   \\<partial>count_space UNIV)\n\ngoal (1 subgoal):\n 1. d_OUT (\\<lambda>(x, y). g (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>))\n     x =\n    d_OUT g \\<langle>x\\<rangle> - g (vertex.SINK, \\<langle>x\\<rangle>)", "also"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y\\<in>range Inner. g (y, \\<langle>x\\<rangle>)) =\n  d_IN g \\<langle>x\\<rangle> -\n  (\\<integral>\\<^sup>+y\\<in>{vertex.SINK}. g (y, \\<langle>x\\<rangle>)\n   \\<partial>count_space UNIV)\n\ngoal (1 subgoal):\n 1. d_OUT (\\<lambda>(x, y). g (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>))\n     x =\n    d_OUT g \\<langle>x\\<rangle> - g (vertex.SINK, \\<langle>x\\<rangle>)", "have \"\\<dots> = d_OUT g \\<langle>x\\<rangle> - g (SINK, \\<langle>x\\<rangle>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN g \\<langle>x\\<rangle> -\n    (\\<integral>\\<^sup>+y\\<in>{vertex.SINK}. g (y, \\<langle>x\\<rangle>)\n     \\<partial>count_space UNIV) =\n    d_OUT g \\<langle>x\\<rangle> - g (vertex.SINK, \\<langle>x\\<rangle>)", "by(simp add: flowD_KIR[OF g] max_def)"], ["proof (state)\nthis:\n  d_IN g \\<langle>x\\<rangle> -\n  (\\<integral>\\<^sup>+y\\<in>{vertex.SINK}. g (y, \\<langle>x\\<rangle>)\n   \\<partial>count_space UNIV) =\n  d_OUT g \\<langle>x\\<rangle> - g (vertex.SINK, \\<langle>x\\<rangle>)\n\ngoal (1 subgoal):\n 1. d_OUT (\\<lambda>(x, y). g (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>))\n     x =\n    d_OUT g \\<langle>x\\<rangle> - g (vertex.SINK, \\<langle>x\\<rangle>)", "finally"], ["proof (chain)\npicking this:\n  d_OUT (\\<lambda>(x, y). g (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>)) x =\n  d_OUT g \\<langle>x\\<rangle> - g (vertex.SINK, \\<langle>x\\<rangle>)", "show ?thesis"], ["proof (prove)\nusing this:\n  d_OUT (\\<lambda>(x, y). g (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>)) x =\n  d_OUT g \\<langle>x\\<rangle> - g (vertex.SINK, \\<langle>x\\<rangle>)\n\ngoal (1 subgoal):\n 1. d_OUT (\\<lambda>(x, y). g (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>))\n     x =\n    d_OUT g \\<langle>x\\<rangle> - g (vertex.SINK, \\<langle>x\\<rangle>)", "."], ["proof (state)\nthis:\n  d_OUT (\\<lambda>(x, y). g (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>)) x =\n  d_OUT g \\<langle>x\\<rangle> - g (vertex.SINK, \\<langle>x\\<rangle>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?x1 \\<in> A \\<Gamma> \\<Longrightarrow>\n  d_OUT (\\<lambda>(x, y). g (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>))\n   ?x1 =\n  d_OUT g \\<langle>?x1\\<rangle> - g (vertex.SINK, \\<langle>?x1\\<rangle>)\n\ngoal (1 subgoal):\n 1. \\<exists>h'.\n       current \\<Gamma> h' \\<and>\n       wave \\<Gamma> h' \\<and>\n       B \\<Gamma> \\<inter> \\<^bold>V \\<subseteq> SAT \\<Gamma> h'", "have IN_g_A: \"d_IN ?g x = d_OUT g \\<langle>x\\<rangle> - g (\\<langle>x\\<rangle>, SINK)\" if \"x \\<in> A \\<Gamma>\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN (\\<lambda>(x, y). g (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>)) x =\n    d_OUT g \\<langle>x\\<rangle> - g (\\<langle>x\\<rangle>, vertex.SINK)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. d_IN (\\<lambda>(x, y). g (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>)) x =\n    d_OUT g \\<langle>x\\<rangle> - g (\\<langle>x\\<rangle>, vertex.SINK)", "have \"d_IN ?g x = (\\<Sum>\\<^sup>+ y\\<in>range Inner. g (\\<langle>x\\<rangle>, y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN (\\<lambda>(x, y). g (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>)) x =\n    (\\<Sum>\\<^sup>+ y\\<in>range Inner. g (\\<langle>x\\<rangle>, y))", "by(simp add: nn_integral_count_space_reindex d_IN_def)"], ["proof (state)\nthis:\n  d_IN (\\<lambda>(x, y). g (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>)) x =\n  (\\<Sum>\\<^sup>+ y\\<in>range Inner. g (\\<langle>x\\<rangle>, y))\n\ngoal (1 subgoal):\n 1. d_IN (\\<lambda>(x, y). g (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>)) x =\n    d_OUT g \\<langle>x\\<rangle> - g (\\<langle>x\\<rangle>, vertex.SINK)", "also"], ["proof (state)\nthis:\n  d_IN (\\<lambda>(x, y). g (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>)) x =\n  (\\<Sum>\\<^sup>+ y\\<in>range Inner. g (\\<langle>x\\<rangle>, y))\n\ngoal (1 subgoal):\n 1. d_IN (\\<lambda>(x, y). g (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>)) x =\n    d_OUT g \\<langle>x\\<rangle> - g (\\<langle>x\\<rangle>, vertex.SINK)", "have \"\\<dots> = d_OUT g \\<langle>x\\<rangle> - (\\<Sum>\\<^sup>+ y. g (\\<langle>x\\<rangle>, y) * indicator {SINK} y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y\\<in>range Inner. g (\\<langle>x\\<rangle>, y)) =\n    d_OUT g \\<langle>x\\<rangle> -\n    (\\<integral>\\<^sup>+y\\<in>{vertex.SINK}. g (\\<langle>x\\<rangle>, y)\n     \\<partial>count_space UNIV)", "unfolding d_OUT_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y\\<in>range Inner. g (\\<langle>x\\<rangle>, y)) =\n    (\\<Sum>\\<^sup>+ y. g (\\<langle>x\\<rangle>, y)) -\n    (\\<integral>\\<^sup>+y\\<in>{vertex.SINK}. g (\\<langle>x\\<rangle>, y)\n     \\<partial>count_space UNIV)", "using that b disjoint flowD_capacity[OF g, of \"(\\<langle>x\\<rangle>, SOURCE)\"]"], ["proof (prove)\nusing this:\n  x \\<in> A \\<Gamma>\n  b \\<in> B \\<Gamma>\n  A \\<Gamma> \\<inter> B \\<Gamma> = {}\n  g (\\<langle>x\\<rangle>, SOURCE)\n  \\<le> capacity \\<Psi> (\\<langle>x\\<rangle>, SOURCE)\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y\\<in>range Inner. g (\\<langle>x\\<rangle>, y)) =\n    (\\<Sum>\\<^sup>+ y. g (\\<langle>x\\<rangle>, y)) -\n    (\\<integral>\\<^sup>+y\\<in>{vertex.SINK}. g (\\<langle>x\\<rangle>, y)\n     \\<partial>count_space UNIV)", "by(subst nn_integral_diff[symmetric])\n        (auto simp add: nn_integral_count_space_indicator notin_range_Inner max_def intro!: nn_integral_cong split: split_indicator if_split_asm)"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y\\<in>range Inner. g (\\<langle>x\\<rangle>, y)) =\n  d_OUT g \\<langle>x\\<rangle> -\n  (\\<integral>\\<^sup>+y\\<in>{vertex.SINK}. g (\\<langle>x\\<rangle>, y)\n   \\<partial>count_space UNIV)\n\ngoal (1 subgoal):\n 1. d_IN (\\<lambda>(x, y). g (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>)) x =\n    d_OUT g \\<langle>x\\<rangle> - g (\\<langle>x\\<rangle>, vertex.SINK)", "also"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y\\<in>range Inner. g (\\<langle>x\\<rangle>, y)) =\n  d_OUT g \\<langle>x\\<rangle> -\n  (\\<integral>\\<^sup>+y\\<in>{vertex.SINK}. g (\\<langle>x\\<rangle>, y)\n   \\<partial>count_space UNIV)\n\ngoal (1 subgoal):\n 1. d_IN (\\<lambda>(x, y). g (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>)) x =\n    d_OUT g \\<langle>x\\<rangle> - g (\\<langle>x\\<rangle>, vertex.SINK)", "have \"\\<dots> = d_OUT g \\<langle>x\\<rangle> - g (\\<langle>x\\<rangle>, SINK)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT g \\<langle>x\\<rangle> -\n    (\\<integral>\\<^sup>+y\\<in>{vertex.SINK}. g (\\<langle>x\\<rangle>, y)\n     \\<partial>count_space UNIV) =\n    d_OUT g \\<langle>x\\<rangle> - g (\\<langle>x\\<rangle>, vertex.SINK)", "by(simp add: max_def)"], ["proof (state)\nthis:\n  d_OUT g \\<langle>x\\<rangle> -\n  (\\<integral>\\<^sup>+y\\<in>{vertex.SINK}. g (\\<langle>x\\<rangle>, y)\n   \\<partial>count_space UNIV) =\n  d_OUT g \\<langle>x\\<rangle> - g (\\<langle>x\\<rangle>, vertex.SINK)\n\ngoal (1 subgoal):\n 1. d_IN (\\<lambda>(x, y). g (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>)) x =\n    d_OUT g \\<langle>x\\<rangle> - g (\\<langle>x\\<rangle>, vertex.SINK)", "finally"], ["proof (chain)\npicking this:\n  d_IN (\\<lambda>(x, y). g (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>)) x =\n  d_OUT g \\<langle>x\\<rangle> - g (\\<langle>x\\<rangle>, vertex.SINK)", "show ?thesis"], ["proof (prove)\nusing this:\n  d_IN (\\<lambda>(x, y). g (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>)) x =\n  d_OUT g \\<langle>x\\<rangle> - g (\\<langle>x\\<rangle>, vertex.SINK)\n\ngoal (1 subgoal):\n 1. d_IN (\\<lambda>(x, y). g (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>)) x =\n    d_OUT g \\<langle>x\\<rangle> - g (\\<langle>x\\<rangle>, vertex.SINK)", "."], ["proof (state)\nthis:\n  d_IN (\\<lambda>(x, y). g (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>)) x =\n  d_OUT g \\<langle>x\\<rangle> - g (\\<langle>x\\<rangle>, vertex.SINK)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?x1 \\<in> A \\<Gamma> \\<Longrightarrow>\n  d_IN (\\<lambda>(x, y). g (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>)) ?x1 =\n  d_OUT g \\<langle>?x1\\<rangle> - g (\\<langle>?x1\\<rangle>, vertex.SINK)\n\ngoal (1 subgoal):\n 1. \\<exists>h'.\n       current \\<Gamma> h' \\<and>\n       wave \\<Gamma> h' \\<and>\n       B \\<Gamma> \\<inter> \\<^bold>V \\<subseteq> SAT \\<Gamma> h'", "have OUT_g_B: \"d_OUT ?g x = d_IN g \\<langle>x\\<rangle> - g (SOURCE, \\<langle>x\\<rangle>)\" if \"x \\<in> B \\<Gamma>\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT (\\<lambda>(x, y). g (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>))\n     x =\n    d_IN g \\<langle>x\\<rangle> - g (SOURCE, \\<langle>x\\<rangle>)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. d_OUT (\\<lambda>(x, y). g (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>))\n     x =\n    d_IN g \\<langle>x\\<rangle> - g (SOURCE, \\<langle>x\\<rangle>)", "have \"d_OUT ?g x = (\\<Sum>\\<^sup>+ y\\<in>range Inner. g (y, \\<langle>x\\<rangle>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT (\\<lambda>(x, y). g (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>))\n     x =\n    (\\<Sum>\\<^sup>+ y\\<in>range Inner. g (y, \\<langle>x\\<rangle>))", "by(simp add: nn_integral_count_space_reindex d_OUT_def)"], ["proof (state)\nthis:\n  d_OUT (\\<lambda>(x, y). g (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>)) x =\n  (\\<Sum>\\<^sup>+ y\\<in>range Inner. g (y, \\<langle>x\\<rangle>))\n\ngoal (1 subgoal):\n 1. d_OUT (\\<lambda>(x, y). g (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>))\n     x =\n    d_IN g \\<langle>x\\<rangle> - g (SOURCE, \\<langle>x\\<rangle>)", "also"], ["proof (state)\nthis:\n  d_OUT (\\<lambda>(x, y). g (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>)) x =\n  (\\<Sum>\\<^sup>+ y\\<in>range Inner. g (y, \\<langle>x\\<rangle>))\n\ngoal (1 subgoal):\n 1. d_OUT (\\<lambda>(x, y). g (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>))\n     x =\n    d_IN g \\<langle>x\\<rangle> - g (SOURCE, \\<langle>x\\<rangle>)", "have \"\\<dots> = d_IN g \\<langle>x\\<rangle> - (\\<Sum>\\<^sup>+ y. g (y, \\<langle>x\\<rangle>) * indicator {SOURCE} y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y\\<in>range Inner. g (y, \\<langle>x\\<rangle>)) =\n    d_IN g \\<langle>x\\<rangle> -\n    (\\<integral>\\<^sup>+y\\<in>{SOURCE}. g (y, \\<langle>x\\<rangle>)\n     \\<partial>count_space UNIV)", "unfolding d_IN_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y\\<in>range Inner. g (y, \\<langle>x\\<rangle>)) =\n    (\\<Sum>\\<^sup>+ xa. g (xa, \\<langle>x\\<rangle>)) -\n    (\\<integral>\\<^sup>+y\\<in>{SOURCE}. g (y, \\<langle>x\\<rangle>)\n     \\<partial>count_space UNIV)", "using that b disjoint flowD_capacity[OF g, of \"(SINK, \\<langle>x\\<rangle>)\"]"], ["proof (prove)\nusing this:\n  x \\<in> B \\<Gamma>\n  b \\<in> B \\<Gamma>\n  A \\<Gamma> \\<inter> B \\<Gamma> = {}\n  g (vertex.SINK, \\<langle>x\\<rangle>)\n  \\<le> capacity \\<Psi> (vertex.SINK, \\<langle>x\\<rangle>)\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y\\<in>range Inner. g (y, \\<langle>x\\<rangle>)) =\n    (\\<Sum>\\<^sup>+ xa. g (xa, \\<langle>x\\<rangle>)) -\n    (\\<integral>\\<^sup>+y\\<in>{SOURCE}. g (y, \\<langle>x\\<rangle>)\n     \\<partial>count_space UNIV)", "by(subst nn_integral_diff[symmetric])\n        (auto simp add: nn_integral_count_space_indicator notin_range_Inner max_def intro!: nn_integral_cong split: split_indicator if_split_asm)"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y\\<in>range Inner. g (y, \\<langle>x\\<rangle>)) =\n  d_IN g \\<langle>x\\<rangle> -\n  (\\<integral>\\<^sup>+y\\<in>{SOURCE}. g (y, \\<langle>x\\<rangle>)\n   \\<partial>count_space UNIV)\n\ngoal (1 subgoal):\n 1. d_OUT (\\<lambda>(x, y). g (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>))\n     x =\n    d_IN g \\<langle>x\\<rangle> - g (SOURCE, \\<langle>x\\<rangle>)", "also"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y\\<in>range Inner. g (y, \\<langle>x\\<rangle>)) =\n  d_IN g \\<langle>x\\<rangle> -\n  (\\<integral>\\<^sup>+y\\<in>{SOURCE}. g (y, \\<langle>x\\<rangle>)\n   \\<partial>count_space UNIV)\n\ngoal (1 subgoal):\n 1. d_OUT (\\<lambda>(x, y). g (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>))\n     x =\n    d_IN g \\<langle>x\\<rangle> - g (SOURCE, \\<langle>x\\<rangle>)", "have \"\\<dots> = d_IN g \\<langle>x\\<rangle> - g (SOURCE, \\<langle>x\\<rangle>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN g \\<langle>x\\<rangle> -\n    (\\<integral>\\<^sup>+y\\<in>{SOURCE}. g (y, \\<langle>x\\<rangle>)\n     \\<partial>count_space UNIV) =\n    d_IN g \\<langle>x\\<rangle> - g (SOURCE, \\<langle>x\\<rangle>)", "by(simp add: max_def)"], ["proof (state)\nthis:\n  d_IN g \\<langle>x\\<rangle> -\n  (\\<integral>\\<^sup>+y\\<in>{SOURCE}. g (y, \\<langle>x\\<rangle>)\n   \\<partial>count_space UNIV) =\n  d_IN g \\<langle>x\\<rangle> - g (SOURCE, \\<langle>x\\<rangle>)\n\ngoal (1 subgoal):\n 1. d_OUT (\\<lambda>(x, y). g (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>))\n     x =\n    d_IN g \\<langle>x\\<rangle> - g (SOURCE, \\<langle>x\\<rangle>)", "finally"], ["proof (chain)\npicking this:\n  d_OUT (\\<lambda>(x, y). g (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>)) x =\n  d_IN g \\<langle>x\\<rangle> - g (SOURCE, \\<langle>x\\<rangle>)", "show ?thesis"], ["proof (prove)\nusing this:\n  d_OUT (\\<lambda>(x, y). g (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>)) x =\n  d_IN g \\<langle>x\\<rangle> - g (SOURCE, \\<langle>x\\<rangle>)\n\ngoal (1 subgoal):\n 1. d_OUT (\\<lambda>(x, y). g (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>))\n     x =\n    d_IN g \\<langle>x\\<rangle> - g (SOURCE, \\<langle>x\\<rangle>)", "."], ["proof (state)\nthis:\n  d_OUT (\\<lambda>(x, y). g (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>)) x =\n  d_IN g \\<langle>x\\<rangle> - g (SOURCE, \\<langle>x\\<rangle>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?x1 \\<in> B \\<Gamma> \\<Longrightarrow>\n  d_OUT (\\<lambda>(x, y). g (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>))\n   ?x1 =\n  d_IN g \\<langle>?x1\\<rangle> - g (SOURCE, \\<langle>?x1\\<rangle>)\n\ngoal (1 subgoal):\n 1. \\<exists>h'.\n       current \\<Gamma> h' \\<and>\n       wave \\<Gamma> h' \\<and>\n       B \\<Gamma> \\<inter> \\<^bold>V \\<subseteq> SAT \\<Gamma> h'", "have IN_g_B: \"d_IN ?g x = d_OUT g \\<langle>x\\<rangle>\" if \"x \\<in> B \\<Gamma>\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN (\\<lambda>(x, y). g (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>)) x =\n    d_OUT g \\<langle>x\\<rangle>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. d_IN (\\<lambda>(x, y). g (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>)) x =\n    d_OUT g \\<langle>x\\<rangle>", "have \"d_IN ?g x = (\\<Sum>\\<^sup>+ y\\<in>range Inner. g (\\<langle>x\\<rangle>, y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN (\\<lambda>(x, y). g (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>)) x =\n    (\\<Sum>\\<^sup>+ y\\<in>range Inner. g (\\<langle>x\\<rangle>, y))", "by(simp add: nn_integral_count_space_reindex d_IN_def)"], ["proof (state)\nthis:\n  d_IN (\\<lambda>(x, y). g (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>)) x =\n  (\\<Sum>\\<^sup>+ y\\<in>range Inner. g (\\<langle>x\\<rangle>, y))\n\ngoal (1 subgoal):\n 1. d_IN (\\<lambda>(x, y). g (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>)) x =\n    d_OUT g \\<langle>x\\<rangle>", "also"], ["proof (state)\nthis:\n  d_IN (\\<lambda>(x, y). g (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>)) x =\n  (\\<Sum>\\<^sup>+ y\\<in>range Inner. g (\\<langle>x\\<rangle>, y))\n\ngoal (1 subgoal):\n 1. d_IN (\\<lambda>(x, y). g (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>)) x =\n    d_OUT g \\<langle>x\\<rangle>", "have \"\\<dots> = d_OUT g \\<langle>x\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y\\<in>range Inner. g (\\<langle>x\\<rangle>, y)) =\n    d_OUT g \\<langle>x\\<rangle>", "unfolding d_OUT_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y\\<in>range Inner. g (\\<langle>x\\<rangle>, y)) =\n    (\\<Sum>\\<^sup>+ y. g (\\<langle>x\\<rangle>, y))", "using that disjoint"], ["proof (prove)\nusing this:\n  x \\<in> B \\<Gamma>\n  A \\<Gamma> \\<inter> B \\<Gamma> = {}\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y\\<in>range Inner. g (\\<langle>x\\<rangle>, y)) =\n    (\\<Sum>\\<^sup>+ y. g (\\<langle>x\\<rangle>, y))", "by(auto 4 3 simp add: nn_integral_count_space_indicator notin_range_Inner intro!: nn_integral_cong \\<Psi>.flowD_outside[OF g] split: split_indicator)"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y\\<in>range Inner. g (\\<langle>x\\<rangle>, y)) =\n  d_OUT g \\<langle>x\\<rangle>\n\ngoal (1 subgoal):\n 1. d_IN (\\<lambda>(x, y). g (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>)) x =\n    d_OUT g \\<langle>x\\<rangle>", "finally"], ["proof (chain)\npicking this:\n  d_IN (\\<lambda>(x, y). g (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>)) x =\n  d_OUT g \\<langle>x\\<rangle>", "show ?thesis"], ["proof (prove)\nusing this:\n  d_IN (\\<lambda>(x, y). g (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>)) x =\n  d_OUT g \\<langle>x\\<rangle>\n\ngoal (1 subgoal):\n 1. d_IN (\\<lambda>(x, y). g (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>)) x =\n    d_OUT g \\<langle>x\\<rangle>", "."], ["proof (state)\nthis:\n  d_IN (\\<lambda>(x, y). g (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>)) x =\n  d_OUT g \\<langle>x\\<rangle>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?x1 \\<in> B \\<Gamma> \\<Longrightarrow>\n  d_IN (\\<lambda>(x, y). g (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>)) ?x1 =\n  d_OUT g \\<langle>?x1\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<exists>h'.\n       current \\<Gamma> h' \\<and>\n       wave \\<Gamma> h' \\<and>\n       B \\<Gamma> \\<inter> \\<^bold>V \\<subseteq> SAT \\<Gamma> h'", "have finite_g_IN: \"d_IN ?g x \\<noteq> \\<top>\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN (\\<lambda>(x, y). g (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>))\n     x \\<noteq>\n    \\<top>", "using \\<alpha>_finite"], ["proof (prove)\nusing this:\n  \\<alpha> \\<noteq> \\<top>\n\ngoal (1 subgoal):\n 1. d_IN (\\<lambda>(x, y). g (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>))\n     x \\<noteq>\n    \\<top>", "proof(rule neq_top_trans)"], ["proof (state)\ngoal (1 subgoal):\n 1. d_IN (\\<lambda>(x, y). g (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>)) x\n    \\<le> \\<alpha>", "have \"d_IN ?g x = (\\<Sum>\\<^sup>+ y\\<in>range Inner. g (\\<langle>x\\<rangle>, y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN (\\<lambda>(x, y). g (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>)) x =\n    (\\<Sum>\\<^sup>+ y\\<in>range Inner. g (\\<langle>x\\<rangle>, y))", "by(auto simp add: d_IN_def nn_integral_count_space_reindex)"], ["proof (state)\nthis:\n  d_IN (\\<lambda>(x, y). g (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>)) x =\n  (\\<Sum>\\<^sup>+ y\\<in>range Inner. g (\\<langle>x\\<rangle>, y))\n\ngoal (1 subgoal):\n 1. d_IN (\\<lambda>(x, y). g (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>)) x\n    \\<le> \\<alpha>", "also"], ["proof (state)\nthis:\n  d_IN (\\<lambda>(x, y). g (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>)) x =\n  (\\<Sum>\\<^sup>+ y\\<in>range Inner. g (\\<langle>x\\<rangle>, y))\n\ngoal (1 subgoal):\n 1. d_IN (\\<lambda>(x, y). g (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>)) x\n    \\<le> \\<alpha>", "have \"\\<dots> \\<le> d_OUT g \\<langle>x\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y\\<in>range Inner. g (\\<langle>x\\<rangle>, y))\n    \\<le> d_OUT g \\<langle>x\\<rangle>", "unfolding d_OUT_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y\\<in>range Inner. g (\\<langle>x\\<rangle>, y))\n    \\<le> (\\<Sum>\\<^sup>+ y. g (\\<langle>x\\<rangle>, y))", "by(auto simp add: nn_integral_count_space_indicator intro!: nn_integral_mono split: split_indicator)"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y\\<in>range Inner. g (\\<langle>x\\<rangle>, y))\n  \\<le> d_OUT g \\<langle>x\\<rangle>\n\ngoal (1 subgoal):\n 1. d_IN (\\<lambda>(x, y). g (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>)) x\n    \\<le> \\<alpha>", "also"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y\\<in>range Inner. g (\\<langle>x\\<rangle>, y))\n  \\<le> d_OUT g \\<langle>x\\<rangle>\n\ngoal (1 subgoal):\n 1. d_IN (\\<lambda>(x, y). g (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>)) x\n    \\<le> \\<alpha>", "have \"\\<dots> = d_IN g \\<langle>x\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. KIR g \\<langle>x\\<rangle>", "by(rule flowD_KIR[OF g]) simp_all"], ["proof (state)\nthis:\n  KIR g \\<langle>x\\<rangle>\n\ngoal (1 subgoal):\n 1. d_IN (\\<lambda>(x, y). g (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>)) x\n    \\<le> \\<alpha>", "also"], ["proof (state)\nthis:\n  KIR g \\<langle>x\\<rangle>\n\ngoal (1 subgoal):\n 1. d_IN (\\<lambda>(x, y). g (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>)) x\n    \\<le> \\<alpha>", "have \"\\<dots> \\<le> \\<alpha>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN g \\<langle>x\\<rangle> \\<le> \\<alpha>", "using IN_g value_g"], ["proof (prove)\nusing this:\n  d_IN g ?x1 \\<le> value_flow \\<Psi> g\n  value_flow \\<Psi> g = \\<alpha>\n\ngoal (1 subgoal):\n 1. d_IN g \\<langle>x\\<rangle> \\<le> \\<alpha>", "by simp"], ["proof (state)\nthis:\n  d_IN g \\<langle>x\\<rangle> \\<le> \\<alpha>\n\ngoal (1 subgoal):\n 1. d_IN (\\<lambda>(x, y). g (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>)) x\n    \\<le> \\<alpha>", "finally"], ["proof (chain)\npicking this:\n  d_IN (\\<lambda>(x, y). g (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>)) x\n  \\<le> \\<alpha>", "show \"d_IN ?g x \\<le> \\<alpha>\""], ["proof (prove)\nusing this:\n  d_IN (\\<lambda>(x, y). g (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>)) x\n  \\<le> \\<alpha>\n\ngoal (1 subgoal):\n 1. d_IN (\\<lambda>(x, y). g (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>)) x\n    \\<le> \\<alpha>", "."], ["proof (state)\nthis:\n  d_IN (\\<lambda>(x, y). g (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>)) x\n  \\<le> \\<alpha>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  d_IN (\\<lambda>(x, y). g (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>))\n   ?x1 \\<noteq>\n  \\<top>\n\ngoal (1 subgoal):\n 1. \\<exists>h'.\n       current \\<Gamma> h' \\<and>\n       wave \\<Gamma> h' \\<and>\n       B \\<Gamma> \\<inter> \\<^bold>V \\<subseteq> SAT \\<Gamma> h'", "have OUT_h'_A: \"d_OUT h' x = d_OUT (h 0) x + g (\\<langle>x\\<rangle>, SINK) - g (SINK, \\<langle>x\\<rangle>)\" if \"x \\<in> A \\<Gamma>\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT h' x =\n    d_OUT (h 0) x + g (\\<langle>x\\<rangle>, vertex.SINK) -\n    g (vertex.SINK, \\<langle>x\\<rangle>)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. d_OUT h' x =\n    d_OUT (h 0) x + g (\\<langle>x\\<rangle>, vertex.SINK) -\n    g (vertex.SINK, \\<langle>x\\<rangle>)", "have \"d_OUT h' x = d_OUT (h 0) x + (\\<Sum>\\<^sup>+ y. ?g (x, y) * indicator \\<^bold>E (x, y)) - (\\<Sum>\\<^sup>+ y. ?g (y, x) * indicator \\<^bold>E (x, y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT h' x =\n    d_OUT (h 0) x +\n    (\\<Sum>\\<^sup>+ y.\n       (case (x, y) of\n        (x, y) \\<Rightarrow> g (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>)) *\n       indicator \\<^bold>E (x, y)) -\n    (\\<Sum>\\<^sup>+ y.\n       (case (y, x) of\n        (x, y) \\<Rightarrow> g (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>)) *\n       indicator \\<^bold>E (x, y))", "unfolding h'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT\n     (h 0 \\<oplus>\n      (\\<lambda>(x, y). g (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>)))\n     x =\n    d_OUT (h 0) x +\n    (\\<Sum>\\<^sup>+ y.\n       (case (x, y) of\n        (x, y) \\<Rightarrow> g (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>)) *\n       indicator \\<^bold>E (x, y)) -\n    (\\<Sum>\\<^sup>+ y.\n       (case (y, x) of\n        (x, y) \\<Rightarrow> g (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>)) *\n       indicator \\<^bold>E (x, y))", "apply(subst OUT_plus_flow[of \\<Gamma> \"h 0\" ?g, OF currentD_outside'[OF h]])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>e. e \\<notin> \\<^bold>E \\<Longrightarrow> e \\<notin> \\<^bold>E\n 2. \\<And>x y.\n       edge \\<Gamma> x y \\<Longrightarrow>\n       (case (y, x) of\n        (x, y) \\<Rightarrow> g (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>))\n       \\<le> h 0 (x, y)\n 3. d_IN (\\<lambda>(x, y). g (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>))\n     x \\<noteq>\n    \\<top>\n 4. d_OUT (h 0) x +\n    (\\<Sum>\\<^sup>+ y.\n       (case (x, y) of\n        (x, y) \\<Rightarrow> g (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>)) *\n       indicator \\<^bold>E (x, y)) -\n    (\\<Sum>\\<^sup>+ y.\n       (case (y, x) of\n        (x, y) \\<Rightarrow> g (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>)) *\n       indicator \\<^bold>E (x, y)) =\n    d_OUT (h 0) x +\n    (\\<Sum>\\<^sup>+ y.\n       (case (x, y) of\n        (x, y) \\<Rightarrow> g (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>)) *\n       indicator \\<^bold>E (x, y)) -\n    (\\<Sum>\\<^sup>+ y.\n       (case (y, x) of\n        (x, y) \\<Rightarrow> g (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>)) *\n       indicator \\<^bold>E (x, y))", "apply(auto simp add: g_le_h0 finite_g_IN)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  d_OUT h' x =\n  d_OUT (h 0) x +\n  (\\<Sum>\\<^sup>+ y.\n     (case (x, y) of\n      (x, y) \\<Rightarrow> g (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>)) *\n     indicator \\<^bold>E (x, y)) -\n  (\\<Sum>\\<^sup>+ y.\n     (case (y, x) of\n      (x, y) \\<Rightarrow> g (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>)) *\n     indicator \\<^bold>E (x, y))\n\ngoal (1 subgoal):\n 1. d_OUT h' x =\n    d_OUT (h 0) x + g (\\<langle>x\\<rangle>, vertex.SINK) -\n    g (vertex.SINK, \\<langle>x\\<rangle>)", "also"], ["proof (state)\nthis:\n  d_OUT h' x =\n  d_OUT (h 0) x +\n  (\\<Sum>\\<^sup>+ y.\n     (case (x, y) of\n      (x, y) \\<Rightarrow> g (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>)) *\n     indicator \\<^bold>E (x, y)) -\n  (\\<Sum>\\<^sup>+ y.\n     (case (y, x) of\n      (x, y) \\<Rightarrow> g (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>)) *\n     indicator \\<^bold>E (x, y))\n\ngoal (1 subgoal):\n 1. d_OUT h' x =\n    d_OUT (h 0) x + g (\\<langle>x\\<rangle>, vertex.SINK) -\n    g (vertex.SINK, \\<langle>x\\<rangle>)", "have \"(\\<Sum>\\<^sup>+ y. ?g (x, y) * indicator \\<^bold>E (x, y)) = d_OUT ?g x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y.\n       (case (x, y) of\n        (x, y) \\<Rightarrow> g (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>)) *\n       indicator \\<^bold>E (x, y)) =\n    d_OUT (\\<lambda>(x, y). g (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>)) x", "unfolding d_OUT_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y.\n       (case (x, y) of\n        (x, y) \\<Rightarrow> g (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>)) *\n       indicator \\<^bold>E (x, y)) =\n    (\\<Sum>\\<^sup>+ y.\n       case (x, y) of\n       (x, y) \\<Rightarrow> g (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>))", "using that"], ["proof (prove)\nusing this:\n  x \\<in> A \\<Gamma>\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y.\n       (case (x, y) of\n        (x, y) \\<Rightarrow> g (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>)) *\n       indicator \\<^bold>E (x, y)) =\n    (\\<Sum>\\<^sup>+ y.\n       case (x, y) of\n       (x, y) \\<Rightarrow> g (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>))", "by(auto simp add: A_in split: split_indicator intro!: nn_integral_cong \\<Psi>.flowD_outside[OF g])"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y.\n     (case (x, y) of\n      (x, y) \\<Rightarrow> g (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>)) *\n     indicator \\<^bold>E (x, y)) =\n  d_OUT (\\<lambda>(x, y). g (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>)) x\n\ngoal (1 subgoal):\n 1. d_OUT h' x =\n    d_OUT (h 0) x + g (\\<langle>x\\<rangle>, vertex.SINK) -\n    g (vertex.SINK, \\<langle>x\\<rangle>)", "also"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y.\n     (case (x, y) of\n      (x, y) \\<Rightarrow> g (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>)) *\n     indicator \\<^bold>E (x, y)) =\n  d_OUT (\\<lambda>(x, y). g (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>)) x\n\ngoal (1 subgoal):\n 1. d_OUT h' x =\n    d_OUT (h 0) x + g (\\<langle>x\\<rangle>, vertex.SINK) -\n    g (vertex.SINK, \\<langle>x\\<rangle>)", "have \"\\<dots>  = d_OUT g \\<langle>x\\<rangle> - g (SINK, \\<langle>x\\<rangle>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT (\\<lambda>(x, y). g (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>))\n     x =\n    d_OUT g \\<langle>x\\<rangle> - g (vertex.SINK, \\<langle>x\\<rangle>)", "using that"], ["proof (prove)\nusing this:\n  x \\<in> A \\<Gamma>\n\ngoal (1 subgoal):\n 1. d_OUT (\\<lambda>(x, y). g (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>))\n     x =\n    d_OUT g \\<langle>x\\<rangle> - g (vertex.SINK, \\<langle>x\\<rangle>)", "by(rule OUT_g_A)"], ["proof (state)\nthis:\n  d_OUT (\\<lambda>(x, y). g (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>)) x =\n  d_OUT g \\<langle>x\\<rangle> - g (vertex.SINK, \\<langle>x\\<rangle>)\n\ngoal (1 subgoal):\n 1. d_OUT h' x =\n    d_OUT (h 0) x + g (\\<langle>x\\<rangle>, vertex.SINK) -\n    g (vertex.SINK, \\<langle>x\\<rangle>)", "also"], ["proof (state)\nthis:\n  d_OUT (\\<lambda>(x, y). g (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>)) x =\n  d_OUT g \\<langle>x\\<rangle> - g (vertex.SINK, \\<langle>x\\<rangle>)\n\ngoal (1 subgoal):\n 1. d_OUT h' x =\n    d_OUT (h 0) x + g (\\<langle>x\\<rangle>, vertex.SINK) -\n    g (vertex.SINK, \\<langle>x\\<rangle>)", "have \"(\\<Sum>\\<^sup>+ y. ?g (y, x) * indicator \\<^bold>E (x, y)) = d_IN ?g x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y.\n       (case (y, x) of\n        (x, y) \\<Rightarrow> g (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>)) *\n       indicator \\<^bold>E (x, y)) =\n    d_IN (\\<lambda>(x, y). g (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>)) x", "using that"], ["proof (prove)\nusing this:\n  x \\<in> A \\<Gamma>\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y.\n       (case (y, x) of\n        (x, y) \\<Rightarrow> g (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>)) *\n       indicator \\<^bold>E (x, y)) =\n    d_IN (\\<lambda>(x, y). g (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>)) x", "unfolding d_IN_def"], ["proof (prove)\nusing this:\n  x \\<in> A \\<Gamma>\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y.\n       (case (y, x) of\n        (x, y) \\<Rightarrow> g (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>)) *\n       indicator \\<^bold>E (x, y)) =\n    (\\<Sum>\\<^sup>+ xa.\n       case (xa, x) of\n       (x, y) \\<Rightarrow> g (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>))", "by(auto simp add: A_in split: split_indicator intro!: nn_integral_cong \\<Psi>.flowD_outside[OF g])"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y.\n     (case (y, x) of\n      (x, y) \\<Rightarrow> g (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>)) *\n     indicator \\<^bold>E (x, y)) =\n  d_IN (\\<lambda>(x, y). g (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>)) x\n\ngoal (1 subgoal):\n 1. d_OUT h' x =\n    d_OUT (h 0) x + g (\\<langle>x\\<rangle>, vertex.SINK) -\n    g (vertex.SINK, \\<langle>x\\<rangle>)", "also"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y.\n     (case (y, x) of\n      (x, y) \\<Rightarrow> g (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>)) *\n     indicator \\<^bold>E (x, y)) =\n  d_IN (\\<lambda>(x, y). g (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>)) x\n\ngoal (1 subgoal):\n 1. d_OUT h' x =\n    d_OUT (h 0) x + g (\\<langle>x\\<rangle>, vertex.SINK) -\n    g (vertex.SINK, \\<langle>x\\<rangle>)", "have \"\\<dots> = d_OUT g \\<langle>x\\<rangle> - g (\\<langle>x\\<rangle>, SINK)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN (\\<lambda>(x, y). g (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>)) x =\n    d_OUT g \\<langle>x\\<rangle> - g (\\<langle>x\\<rangle>, vertex.SINK)", "using that"], ["proof (prove)\nusing this:\n  x \\<in> A \\<Gamma>\n\ngoal (1 subgoal):\n 1. d_IN (\\<lambda>(x, y). g (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>)) x =\n    d_OUT g \\<langle>x\\<rangle> - g (\\<langle>x\\<rangle>, vertex.SINK)", "by(rule IN_g_A)"], ["proof (state)\nthis:\n  d_IN (\\<lambda>(x, y). g (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>)) x =\n  d_OUT g \\<langle>x\\<rangle> - g (\\<langle>x\\<rangle>, vertex.SINK)\n\ngoal (1 subgoal):\n 1. d_OUT h' x =\n    d_OUT (h 0) x + g (\\<langle>x\\<rangle>, vertex.SINK) -\n    g (vertex.SINK, \\<langle>x\\<rangle>)", "also"], ["proof (state)\nthis:\n  d_IN (\\<lambda>(x, y). g (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>)) x =\n  d_OUT g \\<langle>x\\<rangle> - g (\\<langle>x\\<rangle>, vertex.SINK)\n\ngoal (1 subgoal):\n 1. d_OUT h' x =\n    d_OUT (h 0) x + g (\\<langle>x\\<rangle>, vertex.SINK) -\n    g (vertex.SINK, \\<langle>x\\<rangle>)", "have \"d_OUT (h 0) x + (d_OUT g \\<langle>x\\<rangle> - g (SINK, \\<langle>x\\<rangle>)) - \\<dots> = d_OUT (h 0) x + g (\\<langle>x\\<rangle>, SINK) - g (SINK, \\<langle>x\\<rangle>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT (h 0) x +\n    (d_OUT g \\<langle>x\\<rangle> - g (vertex.SINK, \\<langle>x\\<rangle>)) -\n    (d_OUT g \\<langle>x\\<rangle> - g (\\<langle>x\\<rangle>, vertex.SINK)) =\n    d_OUT (h 0) x + g (\\<langle>x\\<rangle>, vertex.SINK) -\n    g (vertex.SINK, \\<langle>x\\<rangle>)", "apply(simp add: g_le_OUT add_diff_eq_ennreal d_OUT_ge_point)"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT (h 0) x + d_OUT g \\<langle>x\\<rangle> -\n    g (vertex.SINK, \\<langle>x\\<rangle>) -\n    (d_OUT g \\<langle>x\\<rangle> - g (\\<langle>x\\<rangle>, vertex.SINK)) =\n    d_OUT (h 0) x + g (\\<langle>x\\<rangle>, vertex.SINK) -\n    g (vertex.SINK, \\<langle>x\\<rangle>)", "apply(subst diff_diff_commute_ennreal)"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT (h 0) x + d_OUT g \\<langle>x\\<rangle> -\n    (d_OUT g \\<langle>x\\<rangle> - g (\\<langle>x\\<rangle>, vertex.SINK)) -\n    g (vertex.SINK, \\<langle>x\\<rangle>) =\n    d_OUT (h 0) x + g (\\<langle>x\\<rangle>, vertex.SINK) -\n    g (vertex.SINK, \\<langle>x\\<rangle>)", "apply(simp add: add_increasing d_OUT_ge_point g_le_OUT diff_diff_ennreal')"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT (h 0) x + d_OUT g \\<langle>x\\<rangle> +\n    g (\\<langle>x\\<rangle>, vertex.SINK) -\n    d_OUT g \\<langle>x\\<rangle> -\n    g (vertex.SINK, \\<langle>x\\<rangle>) =\n    d_OUT (h 0) x + g (\\<langle>x\\<rangle>, vertex.SINK) -\n    g (vertex.SINK, \\<langle>x\\<rangle>)", "apply(subst add.assoc)"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT (h 0) x +\n    (d_OUT g \\<langle>x\\<rangle> + g (\\<langle>x\\<rangle>, vertex.SINK)) -\n    d_OUT g \\<langle>x\\<rangle> -\n    g (vertex.SINK, \\<langle>x\\<rangle>) =\n    d_OUT (h 0) x + g (\\<langle>x\\<rangle>, vertex.SINK) -\n    g (vertex.SINK, \\<langle>x\\<rangle>)", "apply(subst (2) add.commute)"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT (h 0) x +\n    (g (\\<langle>x\\<rangle>, vertex.SINK) + d_OUT g \\<langle>x\\<rangle>) -\n    d_OUT g \\<langle>x\\<rangle> -\n    g (vertex.SINK, \\<langle>x\\<rangle>) =\n    d_OUT (h 0) x + g (\\<langle>x\\<rangle>, vertex.SINK) -\n    g (vertex.SINK, \\<langle>x\\<rangle>)", "apply(subst add.assoc[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT (h 0) x + g (\\<langle>x\\<rangle>, vertex.SINK) +\n    d_OUT g \\<langle>x\\<rangle> -\n    d_OUT g \\<langle>x\\<rangle> -\n    g (vertex.SINK, \\<langle>x\\<rangle>) =\n    d_OUT (h 0) x + g (\\<langle>x\\<rangle>, vertex.SINK) -\n    g (vertex.SINK, \\<langle>x\\<rangle>)", "apply(subst ennreal_add_diff_cancel_right)"], ["proof (prove)\ngoal (2 subgoals):\n 1. d_OUT g \\<langle>x\\<rangle> \\<noteq> \\<top>\n 2. d_OUT (h 0) x + g (\\<langle>x\\<rangle>, vertex.SINK) -\n    g (vertex.SINK, \\<langle>x\\<rangle>) =\n    d_OUT (h 0) x + g (\\<langle>x\\<rangle>, vertex.SINK) -\n    g (vertex.SINK, \\<langle>x\\<rangle>)", "apply(simp_all add: \\<Psi>.flowD_finite_OUT[OF g])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  d_OUT (h 0) x +\n  (d_OUT g \\<langle>x\\<rangle> - g (vertex.SINK, \\<langle>x\\<rangle>)) -\n  (d_OUT g \\<langle>x\\<rangle> - g (\\<langle>x\\<rangle>, vertex.SINK)) =\n  d_OUT (h 0) x + g (\\<langle>x\\<rangle>, vertex.SINK) -\n  g (vertex.SINK, \\<langle>x\\<rangle>)\n\ngoal (1 subgoal):\n 1. d_OUT h' x =\n    d_OUT (h 0) x + g (\\<langle>x\\<rangle>, vertex.SINK) -\n    g (vertex.SINK, \\<langle>x\\<rangle>)", "finally"], ["proof (chain)\npicking this:\n  d_OUT h' x =\n  d_OUT (h 0) x + g (\\<langle>x\\<rangle>, vertex.SINK) -\n  g (vertex.SINK, \\<langle>x\\<rangle>)", "show ?thesis"], ["proof (prove)\nusing this:\n  d_OUT h' x =\n  d_OUT (h 0) x + g (\\<langle>x\\<rangle>, vertex.SINK) -\n  g (vertex.SINK, \\<langle>x\\<rangle>)\n\ngoal (1 subgoal):\n 1. d_OUT h' x =\n    d_OUT (h 0) x + g (\\<langle>x\\<rangle>, vertex.SINK) -\n    g (vertex.SINK, \\<langle>x\\<rangle>)", "."], ["proof (state)\nthis:\n  d_OUT h' x =\n  d_OUT (h 0) x + g (\\<langle>x\\<rangle>, vertex.SINK) -\n  g (vertex.SINK, \\<langle>x\\<rangle>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?x1 \\<in> A \\<Gamma> \\<Longrightarrow>\n  d_OUT h' ?x1 =\n  d_OUT (h 0) ?x1 + g (\\<langle>?x1\\<rangle>, vertex.SINK) -\n  g (vertex.SINK, \\<langle>?x1\\<rangle>)\n\ngoal (1 subgoal):\n 1. \\<exists>h'.\n       current \\<Gamma> h' \\<and>\n       wave \\<Gamma> h' \\<and>\n       B \\<Gamma> \\<inter> \\<^bold>V \\<subseteq> SAT \\<Gamma> h'", "have finite_g_OUT: \"d_OUT ?g x \\<noteq> \\<top>\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT (\\<lambda>(x, y). g (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>))\n     x \\<noteq>\n    \\<top>", "using \\<alpha>_finite"], ["proof (prove)\nusing this:\n  \\<alpha> \\<noteq> \\<top>\n\ngoal (1 subgoal):\n 1. d_OUT (\\<lambda>(x, y). g (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>))\n     x \\<noteq>\n    \\<top>", "proof(rule neq_top_trans)"], ["proof (state)\ngoal (1 subgoal):\n 1. d_OUT (\\<lambda>(x, y). g (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>)) x\n    \\<le> \\<alpha>", "have \"d_OUT ?g x = (\\<Sum>\\<^sup>+ y\\<in>range Inner. g (y, \\<langle>x\\<rangle>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT (\\<lambda>(x, y). g (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>))\n     x =\n    (\\<Sum>\\<^sup>+ y\\<in>range Inner. g (y, \\<langle>x\\<rangle>))", "by(auto simp add: d_OUT_def nn_integral_count_space_reindex)"], ["proof (state)\nthis:\n  d_OUT (\\<lambda>(x, y). g (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>)) x =\n  (\\<Sum>\\<^sup>+ y\\<in>range Inner. g (y, \\<langle>x\\<rangle>))\n\ngoal (1 subgoal):\n 1. d_OUT (\\<lambda>(x, y). g (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>)) x\n    \\<le> \\<alpha>", "also"], ["proof (state)\nthis:\n  d_OUT (\\<lambda>(x, y). g (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>)) x =\n  (\\<Sum>\\<^sup>+ y\\<in>range Inner. g (y, \\<langle>x\\<rangle>))\n\ngoal (1 subgoal):\n 1. d_OUT (\\<lambda>(x, y). g (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>)) x\n    \\<le> \\<alpha>", "have \"\\<dots> \\<le> d_IN g \\<langle>x\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y\\<in>range Inner. g (y, \\<langle>x\\<rangle>))\n    \\<le> d_IN g \\<langle>x\\<rangle>", "unfolding d_IN_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y\\<in>range Inner. g (y, \\<langle>x\\<rangle>))\n    \\<le> (\\<Sum>\\<^sup>+ xa. g (xa, \\<langle>x\\<rangle>))", "by(auto simp add: nn_integral_count_space_indicator intro!: nn_integral_mono split: split_indicator)"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y\\<in>range Inner. g (y, \\<langle>x\\<rangle>))\n  \\<le> d_IN g \\<langle>x\\<rangle>\n\ngoal (1 subgoal):\n 1. d_OUT (\\<lambda>(x, y). g (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>)) x\n    \\<le> \\<alpha>", "also"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y\\<in>range Inner. g (y, \\<langle>x\\<rangle>))\n  \\<le> d_IN g \\<langle>x\\<rangle>\n\ngoal (1 subgoal):\n 1. d_OUT (\\<lambda>(x, y). g (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>)) x\n    \\<le> \\<alpha>", "have \"\\<dots> \\<le> \\<alpha>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN g \\<langle>x\\<rangle> \\<le> \\<alpha>", "using IN_g value_g"], ["proof (prove)\nusing this:\n  d_IN g ?x1 \\<le> value_flow \\<Psi> g\n  value_flow \\<Psi> g = \\<alpha>\n\ngoal (1 subgoal):\n 1. d_IN g \\<langle>x\\<rangle> \\<le> \\<alpha>", "by simp"], ["proof (state)\nthis:\n  d_IN g \\<langle>x\\<rangle> \\<le> \\<alpha>\n\ngoal (1 subgoal):\n 1. d_OUT (\\<lambda>(x, y). g (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>)) x\n    \\<le> \\<alpha>", "finally"], ["proof (chain)\npicking this:\n  d_OUT (\\<lambda>(x, y). g (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>)) x\n  \\<le> \\<alpha>", "show \"d_OUT ?g x \\<le> \\<alpha>\""], ["proof (prove)\nusing this:\n  d_OUT (\\<lambda>(x, y). g (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>)) x\n  \\<le> \\<alpha>\n\ngoal (1 subgoal):\n 1. d_OUT (\\<lambda>(x, y). g (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>)) x\n    \\<le> \\<alpha>", "."], ["proof (state)\nthis:\n  d_OUT (\\<lambda>(x, y). g (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>)) x\n  \\<le> \\<alpha>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  d_OUT (\\<lambda>(x, y). g (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>))\n   ?x1 \\<noteq>\n  \\<top>\n\ngoal (1 subgoal):\n 1. \\<exists>h'.\n       current \\<Gamma> h' \\<and>\n       wave \\<Gamma> h' \\<and>\n       B \\<Gamma> \\<inter> \\<^bold>V \\<subseteq> SAT \\<Gamma> h'", "have IN_h'_B: \"d_IN h' x = d_IN (h 0) x + g (SOURCE, \\<langle>x\\<rangle>)\" if \"x \\<in> B \\<Gamma>\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN h' x = d_IN (h 0) x + g (SOURCE, \\<langle>x\\<rangle>)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. d_IN h' x = d_IN (h 0) x + g (SOURCE, \\<langle>x\\<rangle>)", "have g_le: \"g (SOURCE, \\<langle>x\\<rangle>) \\<le> d_IN g \\<langle>x\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g (SOURCE, \\<langle>x\\<rangle>) \\<le> d_IN g \\<langle>x\\<rangle>", "by (rule d_IN_ge_point)"], ["proof (state)\nthis:\n  g (SOURCE, \\<langle>x\\<rangle>) \\<le> d_IN g \\<langle>x\\<rangle>\n\ngoal (1 subgoal):\n 1. d_IN h' x = d_IN (h 0) x + g (SOURCE, \\<langle>x\\<rangle>)", "have \"d_IN h' x = d_IN (h 0) x + (\\<Sum>\\<^sup>+ y. g (\\<langle>x\\<rangle>, \\<langle>y\\<rangle>) * indicator \\<^bold>E (y, x)) - (\\<Sum>\\<^sup>+ y. g (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>) * indicator \\<^bold>E (y, x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN h' x =\n    d_IN (h 0) x +\n    (\\<Sum>\\<^sup>+ y.\n       g (\\<langle>x\\<rangle>, \\<langle>y\\<rangle>) *\n       indicator \\<^bold>E (y, x)) -\n    (\\<Sum>\\<^sup>+ y.\n       g (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>) *\n       indicator \\<^bold>E (y, x))", "unfolding h'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN\n     (h 0 \\<oplus>\n      (\\<lambda>(x, y). g (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>)))\n     x =\n    d_IN (h 0) x +\n    (\\<Sum>\\<^sup>+ y.\n       g (\\<langle>x\\<rangle>, \\<langle>y\\<rangle>) *\n       indicator \\<^bold>E (y, x)) -\n    (\\<Sum>\\<^sup>+ y.\n       g (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>) *\n       indicator \\<^bold>E (y, x))", "by(subst IN_plus_flow[of \\<Gamma> \"h 0\" ?g, OF currentD_outside'[OF h]])\n        (auto simp add: g_le_h0 finite_g_OUT)"], ["proof (state)\nthis:\n  d_IN h' x =\n  d_IN (h 0) x +\n  (\\<Sum>\\<^sup>+ y.\n     g (\\<langle>x\\<rangle>, \\<langle>y\\<rangle>) *\n     indicator \\<^bold>E (y, x)) -\n  (\\<Sum>\\<^sup>+ y.\n     g (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>) *\n     indicator \\<^bold>E (y, x))\n\ngoal (1 subgoal):\n 1. d_IN h' x = d_IN (h 0) x + g (SOURCE, \\<langle>x\\<rangle>)", "also"], ["proof (state)\nthis:\n  d_IN h' x =\n  d_IN (h 0) x +\n  (\\<Sum>\\<^sup>+ y.\n     g (\\<langle>x\\<rangle>, \\<langle>y\\<rangle>) *\n     indicator \\<^bold>E (y, x)) -\n  (\\<Sum>\\<^sup>+ y.\n     g (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>) *\n     indicator \\<^bold>E (y, x))\n\ngoal (1 subgoal):\n 1. d_IN h' x = d_IN (h 0) x + g (SOURCE, \\<langle>x\\<rangle>)", "have \"(\\<Sum>\\<^sup>+ y. g (\\<langle>x\\<rangle>, \\<langle>y\\<rangle>) * indicator \\<^bold>E (y, x)) = d_IN ?g x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y.\n       g (\\<langle>x\\<rangle>, \\<langle>y\\<rangle>) *\n       indicator \\<^bold>E (y, x)) =\n    d_IN (\\<lambda>(x, y). g (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>)) x", "unfolding d_IN_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y.\n       g (\\<langle>x\\<rangle>, \\<langle>y\\<rangle>) *\n       indicator \\<^bold>E (y, x)) =\n    (\\<Sum>\\<^sup>+ xa.\n       case (xa, x) of\n       (x, y) \\<Rightarrow> g (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>))", "using that"], ["proof (prove)\nusing this:\n  x \\<in> B \\<Gamma>\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y.\n       g (\\<langle>x\\<rangle>, \\<langle>y\\<rangle>) *\n       indicator \\<^bold>E (y, x)) =\n    (\\<Sum>\\<^sup>+ xa.\n       case (xa, x) of\n       (x, y) \\<Rightarrow> g (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>))", "by(intro nn_integral_cong)(auto split: split_indicator intro!: \\<Psi>.flowD_outside[OF g] simp add: B_out)"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y.\n     g (\\<langle>x\\<rangle>, \\<langle>y\\<rangle>) *\n     indicator \\<^bold>E (y, x)) =\n  d_IN (\\<lambda>(x, y). g (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>)) x\n\ngoal (1 subgoal):\n 1. d_IN h' x = d_IN (h 0) x + g (SOURCE, \\<langle>x\\<rangle>)", "also"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y.\n     g (\\<langle>x\\<rangle>, \\<langle>y\\<rangle>) *\n     indicator \\<^bold>E (y, x)) =\n  d_IN (\\<lambda>(x, y). g (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>)) x\n\ngoal (1 subgoal):\n 1. d_IN h' x = d_IN (h 0) x + g (SOURCE, \\<langle>x\\<rangle>)", "have \"\\<dots> = d_OUT g \\<langle>x\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN (\\<lambda>(x, y). g (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>)) x =\n    d_OUT g \\<langle>x\\<rangle>", "using that"], ["proof (prove)\nusing this:\n  x \\<in> B \\<Gamma>\n\ngoal (1 subgoal):\n 1. d_IN (\\<lambda>(x, y). g (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>)) x =\n    d_OUT g \\<langle>x\\<rangle>", "by(rule IN_g_B)"], ["proof (state)\nthis:\n  d_IN (\\<lambda>(x, y). g (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>)) x =\n  d_OUT g \\<langle>x\\<rangle>\n\ngoal (1 subgoal):\n 1. d_IN h' x = d_IN (h 0) x + g (SOURCE, \\<langle>x\\<rangle>)", "also"], ["proof (state)\nthis:\n  d_IN (\\<lambda>(x, y). g (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>)) x =\n  d_OUT g \\<langle>x\\<rangle>\n\ngoal (1 subgoal):\n 1. d_IN h' x = d_IN (h 0) x + g (SOURCE, \\<langle>x\\<rangle>)", "have \"(\\<Sum>\\<^sup>+ y. g (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>) * indicator \\<^bold>E (y, x)) = d_OUT ?g x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y.\n       g (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>) *\n       indicator \\<^bold>E (y, x)) =\n    d_OUT (\\<lambda>(x, y). g (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>)) x", "unfolding d_OUT_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y.\n       g (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>) *\n       indicator \\<^bold>E (y, x)) =\n    (\\<Sum>\\<^sup>+ y.\n       case (x, y) of\n       (x, y) \\<Rightarrow> g (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>))", "using that"], ["proof (prove)\nusing this:\n  x \\<in> B \\<Gamma>\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y.\n       g (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>) *\n       indicator \\<^bold>E (y, x)) =\n    (\\<Sum>\\<^sup>+ y.\n       case (x, y) of\n       (x, y) \\<Rightarrow> g (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>))", "by(intro nn_integral_cong)(auto split: split_indicator intro!: \\<Psi>.flowD_outside[OF g] simp add: B_out)"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y.\n     g (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>) *\n     indicator \\<^bold>E (y, x)) =\n  d_OUT (\\<lambda>(x, y). g (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>)) x\n\ngoal (1 subgoal):\n 1. d_IN h' x = d_IN (h 0) x + g (SOURCE, \\<langle>x\\<rangle>)", "also"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y.\n     g (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>) *\n     indicator \\<^bold>E (y, x)) =\n  d_OUT (\\<lambda>(x, y). g (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>)) x\n\ngoal (1 subgoal):\n 1. d_IN h' x = d_IN (h 0) x + g (SOURCE, \\<langle>x\\<rangle>)", "have \"\\<dots> = d_IN g \\<langle>x\\<rangle> - g (SOURCE, \\<langle>x\\<rangle>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT (\\<lambda>(x, y). g (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>))\n     x =\n    d_IN g \\<langle>x\\<rangle> - g (SOURCE, \\<langle>x\\<rangle>)", "using that"], ["proof (prove)\nusing this:\n  x \\<in> B \\<Gamma>\n\ngoal (1 subgoal):\n 1. d_OUT (\\<lambda>(x, y). g (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>))\n     x =\n    d_IN g \\<langle>x\\<rangle> - g (SOURCE, \\<langle>x\\<rangle>)", "by(rule OUT_g_B)"], ["proof (state)\nthis:\n  d_OUT (\\<lambda>(x, y). g (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>)) x =\n  d_IN g \\<langle>x\\<rangle> - g (SOURCE, \\<langle>x\\<rangle>)\n\ngoal (1 subgoal):\n 1. d_IN h' x = d_IN (h 0) x + g (SOURCE, \\<langle>x\\<rangle>)", "also"], ["proof (state)\nthis:\n  d_OUT (\\<lambda>(x, y). g (\\<langle>y\\<rangle>, \\<langle>x\\<rangle>)) x =\n  d_IN g \\<langle>x\\<rangle> - g (SOURCE, \\<langle>x\\<rangle>)\n\ngoal (1 subgoal):\n 1. d_IN h' x = d_IN (h 0) x + g (SOURCE, \\<langle>x\\<rangle>)", "have \"d_IN (h 0) x + d_OUT g \\<langle>x\\<rangle> - \\<dots> = d_IN (h 0) x + g (SOURCE, \\<langle>x\\<rangle>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN (h 0) x + d_OUT g \\<langle>x\\<rangle> -\n    (d_IN g \\<langle>x\\<rangle> - g (SOURCE, \\<langle>x\\<rangle>)) =\n    d_IN (h 0) x + g (SOURCE, \\<langle>x\\<rangle>)", "using \\<Psi>.flowD_finite_IN[OF g] g_le"], ["proof (prove)\nusing this:\n  ?x \\<noteq> sink \\<Psi> \\<Longrightarrow> d_IN g ?x \\<noteq> \\<top>\n  g (SOURCE, \\<langle>x\\<rangle>) \\<le> d_IN g \\<langle>x\\<rangle>\n\ngoal (1 subgoal):\n 1. d_IN (h 0) x + d_OUT g \\<langle>x\\<rangle> -\n    (d_IN g \\<langle>x\\<rangle> - g (SOURCE, \\<langle>x\\<rangle>)) =\n    d_IN (h 0) x + g (SOURCE, \\<langle>x\\<rangle>)", "by(cases \"d_IN (h 0) x\"; cases \"d_IN g \\<langle>x\\<rangle>\"; cases \"d_IN g \\<langle>x\\<rangle>\"; cases \"g (SOURCE, \\<langle>x\\<rangle>)\")\n        (auto simp: flowD_KIR[OF g] top_add ennreal_minus_if ennreal_plus_if simp del: ennreal_plus)"], ["proof (state)\nthis:\n  d_IN (h 0) x + d_OUT g \\<langle>x\\<rangle> -\n  (d_IN g \\<langle>x\\<rangle> - g (SOURCE, \\<langle>x\\<rangle>)) =\n  d_IN (h 0) x + g (SOURCE, \\<langle>x\\<rangle>)\n\ngoal (1 subgoal):\n 1. d_IN h' x = d_IN (h 0) x + g (SOURCE, \\<langle>x\\<rangle>)", "finally"], ["proof (chain)\npicking this:\n  d_IN h' x = d_IN (h 0) x + g (SOURCE, \\<langle>x\\<rangle>)", "show ?thesis"], ["proof (prove)\nusing this:\n  d_IN h' x = d_IN (h 0) x + g (SOURCE, \\<langle>x\\<rangle>)\n\ngoal (1 subgoal):\n 1. d_IN h' x = d_IN (h 0) x + g (SOURCE, \\<langle>x\\<rangle>)", "."], ["proof (state)\nthis:\n  d_IN h' x = d_IN (h 0) x + g (SOURCE, \\<langle>x\\<rangle>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?x1 \\<in> B \\<Gamma> \\<Longrightarrow>\n  d_IN h' ?x1 = d_IN (h 0) ?x1 + g (SOURCE, \\<langle>?x1\\<rangle>)\n\ngoal (1 subgoal):\n 1. \\<exists>h'.\n       current \\<Gamma> h' \\<and>\n       wave \\<Gamma> h' \\<and>\n       B \\<Gamma> \\<inter> \\<^bold>V \\<subseteq> SAT \\<Gamma> h'", "have h': \"current \\<Gamma> h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. current \\<Gamma> h'", "proof"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x. d_OUT h' x \\<le> weight \\<Gamma> x\n 2. \\<And>x. d_IN h' x \\<le> weight \\<Gamma> x\n 3. \\<And>e. e \\<notin> \\<^bold>E \\<Longrightarrow> h' e = 0", "fix x"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x. d_OUT h' x \\<le> weight \\<Gamma> x\n 2. \\<And>x. d_IN h' x \\<le> weight \\<Gamma> x\n 3. \\<And>e. e \\<notin> \\<^bold>E \\<Longrightarrow> h' e = 0", "consider (A) \"x \\<in> A \\<Gamma>\" | (B) \"x \\<in> B \\<Gamma>\" | (outside) \"x \\<notin> \\<^bold>V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> A \\<Gamma> \\<Longrightarrow> thesis;\n     x \\<in> B \\<Gamma> \\<Longrightarrow> thesis;\n     x \\<notin> \\<^bold>V \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "using bipartite_V"], ["proof (prove)\nusing this:\n  \\<^bold>V \\<subseteq> A \\<Gamma> \\<union> B \\<Gamma>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> A \\<Gamma> \\<Longrightarrow> thesis;\n     x \\<in> B \\<Gamma> \\<Longrightarrow> thesis;\n     x \\<notin> \\<^bold>V \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>x \\<in> A \\<Gamma> \\<Longrightarrow> ?thesis1;\n   x \\<in> B \\<Gamma> \\<Longrightarrow> ?thesis1;\n   x \\<notin> \\<^bold>V \\<Longrightarrow> ?thesis1\\<rbrakk>\n  \\<Longrightarrow> ?thesis1\n\ngoal (3 subgoals):\n 1. \\<And>x. d_OUT h' x \\<le> weight \\<Gamma> x\n 2. \\<And>x. d_IN h' x \\<le> weight \\<Gamma> x\n 3. \\<And>e. e \\<notin> \\<^bold>E \\<Longrightarrow> h' e = 0", "note cases = this"], ["proof (state)\nthis:\n  \\<lbrakk>x \\<in> A \\<Gamma> \\<Longrightarrow> ?thesis1;\n   x \\<in> B \\<Gamma> \\<Longrightarrow> ?thesis1;\n   x \\<notin> \\<^bold>V \\<Longrightarrow> ?thesis1\\<rbrakk>\n  \\<Longrightarrow> ?thesis1\n\ngoal (3 subgoals):\n 1. \\<And>x. d_OUT h' x \\<le> weight \\<Gamma> x\n 2. \\<And>x. d_IN h' x \\<le> weight \\<Gamma> x\n 3. \\<And>e. e \\<notin> \\<^bold>E \\<Longrightarrow> h' e = 0", "show \"d_OUT h' x \\<le> weight \\<Gamma> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT h' x \\<le> weight \\<Gamma> x", "proof(cases rule: cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. x \\<in> A \\<Gamma> \\<Longrightarrow> d_OUT h' x \\<le> weight \\<Gamma> x\n 2. x \\<in> B \\<Gamma> \\<Longrightarrow> d_OUT h' x \\<le> weight \\<Gamma> x\n 3. x \\<notin> \\<^bold>V \\<Longrightarrow>\n    d_OUT h' x \\<le> weight \\<Gamma> x", "case A"], ["proof (state)\nthis:\n  x \\<in> A \\<Gamma>\n\ngoal (3 subgoals):\n 1. x \\<in> A \\<Gamma> \\<Longrightarrow> d_OUT h' x \\<le> weight \\<Gamma> x\n 2. x \\<in> B \\<Gamma> \\<Longrightarrow> d_OUT h' x \\<le> weight \\<Gamma> x\n 3. x \\<notin> \\<^bold>V \\<Longrightarrow>\n    d_OUT h' x \\<le> weight \\<Gamma> x", "then"], ["proof (chain)\npicking this:\n  x \\<in> A \\<Gamma>", "have \"d_OUT h' x = d_OUT (h 0) x + g (\\<langle>x\\<rangle>, SINK) - g (SINK, \\<langle>x\\<rangle>)\""], ["proof (prove)\nusing this:\n  x \\<in> A \\<Gamma>\n\ngoal (1 subgoal):\n 1. d_OUT h' x =\n    d_OUT (h 0) x + g (\\<langle>x\\<rangle>, vertex.SINK) -\n    g (vertex.SINK, \\<langle>x\\<rangle>)", "by(simp add: OUT_h'_A)"], ["proof (state)\nthis:\n  d_OUT h' x =\n  d_OUT (h 0) x + g (\\<langle>x\\<rangle>, vertex.SINK) -\n  g (vertex.SINK, \\<langle>x\\<rangle>)\n\ngoal (3 subgoals):\n 1. x \\<in> A \\<Gamma> \\<Longrightarrow> d_OUT h' x \\<le> weight \\<Gamma> x\n 2. x \\<in> B \\<Gamma> \\<Longrightarrow> d_OUT h' x \\<le> weight \\<Gamma> x\n 3. x \\<notin> \\<^bold>V \\<Longrightarrow>\n    d_OUT h' x \\<le> weight \\<Gamma> x", "also"], ["proof (state)\nthis:\n  d_OUT h' x =\n  d_OUT (h 0) x + g (\\<langle>x\\<rangle>, vertex.SINK) -\n  g (vertex.SINK, \\<langle>x\\<rangle>)\n\ngoal (3 subgoals):\n 1. x \\<in> A \\<Gamma> \\<Longrightarrow> d_OUT h' x \\<le> weight \\<Gamma> x\n 2. x \\<in> B \\<Gamma> \\<Longrightarrow> d_OUT h' x \\<le> weight \\<Gamma> x\n 3. x \\<notin> \\<^bold>V \\<Longrightarrow>\n    d_OUT h' x \\<le> weight \\<Gamma> x", "have \"\\<dots> \\<le> d_OUT (h 0) x + g (\\<langle>x\\<rangle>, SINK)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT (h 0) x + g (\\<langle>x\\<rangle>, vertex.SINK) -\n    g (vertex.SINK, \\<langle>x\\<rangle>)\n    \\<le> d_OUT (h 0) x + g (\\<langle>x\\<rangle>, vertex.SINK)", "by(rule diff_le_self_ennreal)"], ["proof (state)\nthis:\n  d_OUT (h 0) x + g (\\<langle>x\\<rangle>, vertex.SINK) -\n  g (vertex.SINK, \\<langle>x\\<rangle>)\n  \\<le> d_OUT (h 0) x + g (\\<langle>x\\<rangle>, vertex.SINK)\n\ngoal (3 subgoals):\n 1. x \\<in> A \\<Gamma> \\<Longrightarrow> d_OUT h' x \\<le> weight \\<Gamma> x\n 2. x \\<in> B \\<Gamma> \\<Longrightarrow> d_OUT h' x \\<le> weight \\<Gamma> x\n 3. x \\<notin> \\<^bold>V \\<Longrightarrow>\n    d_OUT h' x \\<le> weight \\<Gamma> x", "also"], ["proof (state)\nthis:\n  d_OUT (h 0) x + g (\\<langle>x\\<rangle>, vertex.SINK) -\n  g (vertex.SINK, \\<langle>x\\<rangle>)\n  \\<le> d_OUT (h 0) x + g (\\<langle>x\\<rangle>, vertex.SINK)\n\ngoal (3 subgoals):\n 1. x \\<in> A \\<Gamma> \\<Longrightarrow> d_OUT h' x \\<le> weight \\<Gamma> x\n 2. x \\<in> B \\<Gamma> \\<Longrightarrow> d_OUT h' x \\<le> weight \\<Gamma> x\n 3. x \\<notin> \\<^bold>V \\<Longrightarrow>\n    d_OUT h' x \\<le> weight \\<Gamma> x", "have \"g (\\<langle>x\\<rangle>, SINK) \\<le> weight \\<Gamma> x - d_OUT (h 0) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g (\\<langle>x\\<rangle>, vertex.SINK)\n    \\<le> weight \\<Gamma> x - d_OUT (h 0) x", "using flowD_capacity[OF g, of \"(\\<langle>x\\<rangle>, SINK)\"] A"], ["proof (prove)\nusing this:\n  g (\\<langle>x\\<rangle>, vertex.SINK)\n  \\<le> capacity \\<Psi> (\\<langle>x\\<rangle>, vertex.SINK)\n  x \\<in> A \\<Gamma>\n\ngoal (1 subgoal):\n 1. g (\\<langle>x\\<rangle>, vertex.SINK)\n    \\<le> weight \\<Gamma> x - d_OUT (h 0) x", "by simp"], ["proof (state)\nthis:\n  g (\\<langle>x\\<rangle>, vertex.SINK)\n  \\<le> weight \\<Gamma> x - d_OUT (h 0) x\n\ngoal (3 subgoals):\n 1. x \\<in> A \\<Gamma> \\<Longrightarrow> d_OUT h' x \\<le> weight \\<Gamma> x\n 2. x \\<in> B \\<Gamma> \\<Longrightarrow> d_OUT h' x \\<le> weight \\<Gamma> x\n 3. x \\<notin> \\<^bold>V \\<Longrightarrow>\n    d_OUT h' x \\<le> weight \\<Gamma> x", "also"], ["proof (state)\nthis:\n  g (\\<langle>x\\<rangle>, vertex.SINK)\n  \\<le> weight \\<Gamma> x - d_OUT (h 0) x\n\ngoal (3 subgoals):\n 1. x \\<in> A \\<Gamma> \\<Longrightarrow> d_OUT h' x \\<le> weight \\<Gamma> x\n 2. x \\<in> B \\<Gamma> \\<Longrightarrow> d_OUT h' x \\<le> weight \\<Gamma> x\n 3. x \\<notin> \\<^bold>V \\<Longrightarrow>\n    d_OUT h' x \\<le> weight \\<Gamma> x", "have \"d_OUT (h 0) x + \\<dots> = weight \\<Gamma> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT (h 0) x + (weight \\<Gamma> x - d_OUT (h 0) x) = weight \\<Gamma> x", "by(simp add: add_diff_eq_ennreal add_diff_inverse_ennreal  currentD_finite_OUT[OF h] currentD_weight_OUT[OF h])"], ["proof (state)\nthis:\n  d_OUT (h 0) x + (weight \\<Gamma> x - d_OUT (h 0) x) = weight \\<Gamma> x\n\ngoal (3 subgoals):\n 1. x \\<in> A \\<Gamma> \\<Longrightarrow> d_OUT h' x \\<le> weight \\<Gamma> x\n 2. x \\<in> B \\<Gamma> \\<Longrightarrow> d_OUT h' x \\<le> weight \\<Gamma> x\n 3. x \\<notin> \\<^bold>V \\<Longrightarrow>\n    d_OUT h' x \\<le> weight \\<Gamma> x", "finally"], ["proof (chain)\npicking this:\n  (\\<And>xa y.\n      xa \\<le> y \\<Longrightarrow>\n      d_OUT (h 0) x + xa \\<le> d_OUT (h 0) x + y) \\<Longrightarrow>\n  d_OUT h' x \\<le> weight \\<Gamma> x", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<And>xa y.\n      xa \\<le> y \\<Longrightarrow>\n      d_OUT (h 0) x + xa \\<le> d_OUT (h 0) x + y) \\<Longrightarrow>\n  d_OUT h' x \\<le> weight \\<Gamma> x\n\ngoal (1 subgoal):\n 1. d_OUT h' x \\<le> weight \\<Gamma> x", "by(simp add: add_left_mono)"], ["proof (state)\nthis:\n  d_OUT h' x \\<le> weight \\<Gamma> x\n\ngoal (2 subgoals):\n 1. x \\<in> B \\<Gamma> \\<Longrightarrow> d_OUT h' x \\<le> weight \\<Gamma> x\n 2. x \\<notin> \\<^bold>V \\<Longrightarrow>\n    d_OUT h' x \\<le> weight \\<Gamma> x", "qed(simp_all add: OUT_h'_outside )"], ["proof (state)\nthis:\n  d_OUT h' x \\<le> weight \\<Gamma> x\n\ngoal (2 subgoals):\n 1. \\<And>x. d_IN h' x \\<le> weight \\<Gamma> x\n 2. \\<And>e. e \\<notin> \\<^bold>E \\<Longrightarrow> h' e = 0", "show \"d_IN h' x \\<le> weight \\<Gamma> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN h' x \\<le> weight \\<Gamma> x", "proof(cases rule: cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. x \\<in> A \\<Gamma> \\<Longrightarrow> d_IN h' x \\<le> weight \\<Gamma> x\n 2. x \\<in> B \\<Gamma> \\<Longrightarrow> d_IN h' x \\<le> weight \\<Gamma> x\n 3. x \\<notin> \\<^bold>V \\<Longrightarrow> d_IN h' x \\<le> weight \\<Gamma> x", "case B"], ["proof (state)\nthis:\n  x \\<in> B \\<Gamma>\n\ngoal (3 subgoals):\n 1. x \\<in> A \\<Gamma> \\<Longrightarrow> d_IN h' x \\<le> weight \\<Gamma> x\n 2. x \\<in> B \\<Gamma> \\<Longrightarrow> d_IN h' x \\<le> weight \\<Gamma> x\n 3. x \\<notin> \\<^bold>V \\<Longrightarrow> d_IN h' x \\<le> weight \\<Gamma> x", "hence \"d_IN h' x = d_IN (h 0) x + g (SOURCE, \\<langle>x\\<rangle>)\""], ["proof (prove)\nusing this:\n  x \\<in> B \\<Gamma>\n\ngoal (1 subgoal):\n 1. d_IN h' x = d_IN (h 0) x + g (SOURCE, \\<langle>x\\<rangle>)", "by(rule IN_h'_B)"], ["proof (state)\nthis:\n  d_IN h' x = d_IN (h 0) x + g (SOURCE, \\<langle>x\\<rangle>)\n\ngoal (3 subgoals):\n 1. x \\<in> A \\<Gamma> \\<Longrightarrow> d_IN h' x \\<le> weight \\<Gamma> x\n 2. x \\<in> B \\<Gamma> \\<Longrightarrow> d_IN h' x \\<le> weight \\<Gamma> x\n 3. x \\<notin> \\<^bold>V \\<Longrightarrow> d_IN h' x \\<le> weight \\<Gamma> x", "also"], ["proof (state)\nthis:\n  d_IN h' x = d_IN (h 0) x + g (SOURCE, \\<langle>x\\<rangle>)\n\ngoal (3 subgoals):\n 1. x \\<in> A \\<Gamma> \\<Longrightarrow> d_IN h' x \\<le> weight \\<Gamma> x\n 2. x \\<in> B \\<Gamma> \\<Longrightarrow> d_IN h' x \\<le> weight \\<Gamma> x\n 3. x \\<notin> \\<^bold>V \\<Longrightarrow> d_IN h' x \\<le> weight \\<Gamma> x", "have \"\\<dots> \\<le> weight \\<Gamma> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN (h 0) x + g (SOURCE, \\<langle>x\\<rangle>) \\<le> weight \\<Gamma> x", "by(simp add: g_SOURCE \\<alpha> currentD_weight_IN[OF h] add_diff_eq_ennreal add_diff_inverse_ennreal currentD_finite_IN[OF h])"], ["proof (state)\nthis:\n  d_IN (h 0) x + g (SOURCE, \\<langle>x\\<rangle>) \\<le> weight \\<Gamma> x\n\ngoal (3 subgoals):\n 1. x \\<in> A \\<Gamma> \\<Longrightarrow> d_IN h' x \\<le> weight \\<Gamma> x\n 2. x \\<in> B \\<Gamma> \\<Longrightarrow> d_IN h' x \\<le> weight \\<Gamma> x\n 3. x \\<notin> \\<^bold>V \\<Longrightarrow> d_IN h' x \\<le> weight \\<Gamma> x", "finally"], ["proof (chain)\npicking this:\n  d_IN h' x \\<le> weight \\<Gamma> x", "show ?thesis"], ["proof (prove)\nusing this:\n  d_IN h' x \\<le> weight \\<Gamma> x\n\ngoal (1 subgoal):\n 1. d_IN h' x \\<le> weight \\<Gamma> x", "."], ["proof (state)\nthis:\n  d_IN h' x \\<le> weight \\<Gamma> x\n\ngoal (2 subgoals):\n 1. x \\<in> A \\<Gamma> \\<Longrightarrow> d_IN h' x \\<le> weight \\<Gamma> x\n 2. x \\<notin> \\<^bold>V \\<Longrightarrow> d_IN h' x \\<le> weight \\<Gamma> x", "qed(simp_all add:  IN_h'_outside)"], ["proof (state)\nthis:\n  d_IN h' x \\<le> weight \\<Gamma> x\n\ngoal (1 subgoal):\n 1. \\<And>e. e \\<notin> \\<^bold>E \\<Longrightarrow> h' e = 0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>e. e \\<notin> \\<^bold>E \\<Longrightarrow> h' e = 0", "show \"h' e = 0\" if \"e \\<notin> \\<^bold>E\" for e"], ["proof (prove)\ngoal (1 subgoal):\n 1. h' e = 0", "using that"], ["proof (prove)\nusing this:\n  e \\<notin> \\<^bold>E\n\ngoal (1 subgoal):\n 1. h' e = 0", "by(simp split: prod.split_asm add: h'_simps)"], ["proof (state)\nthis:\n  ?e1 \\<notin> \\<^bold>E \\<Longrightarrow> h' ?e1 = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  current \\<Gamma> h'\n\ngoal (1 subgoal):\n 1. \\<exists>h'.\n       current \\<Gamma> h' \\<and>\n       wave \\<Gamma> h' \\<and>\n       B \\<Gamma> \\<inter> \\<^bold>V \\<subseteq> SAT \\<Gamma> h'", "moreover"], ["proof (state)\nthis:\n  current \\<Gamma> h'\n\ngoal (1 subgoal):\n 1. \\<exists>h'.\n       current \\<Gamma> h' \\<and>\n       wave \\<Gamma> h' \\<and>\n       B \\<Gamma> \\<inter> \\<^bold>V \\<subseteq> SAT \\<Gamma> h'", "have SAT_h': \"B \\<Gamma> \\<inter> \\<^bold>V \\<subseteq> SAT \\<Gamma> h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B \\<Gamma> \\<inter> \\<^bold>V \\<subseteq> SAT \\<Gamma> h'", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> B \\<Gamma> \\<inter> \\<^bold>V \\<Longrightarrow>\n       x \\<in> SAT \\<Gamma> h'", "show \"x \\<in> SAT \\<Gamma> h'\" if \"x \\<in> B \\<Gamma> \\<inter> \\<^bold>V\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> SAT \\<Gamma> h'", "using that"], ["proof (prove)\nusing this:\n  x \\<in> B \\<Gamma> \\<inter> \\<^bold>V\n\ngoal (1 subgoal):\n 1. x \\<in> SAT \\<Gamma> h'", "proof(cases \"x = b\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<in> B \\<Gamma> \\<inter> \\<^bold>V; x = b\\<rbrakk>\n    \\<Longrightarrow> x \\<in> SAT \\<Gamma> h'\n 2. \\<lbrakk>x \\<in> B \\<Gamma> \\<inter> \\<^bold>V; x \\<noteq> b\\<rbrakk>\n    \\<Longrightarrow> x \\<in> SAT \\<Gamma> h'", "case True"], ["proof (state)\nthis:\n  x = b\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<in> B \\<Gamma> \\<inter> \\<^bold>V; x = b\\<rbrakk>\n    \\<Longrightarrow> x \\<in> SAT \\<Gamma> h'\n 2. \\<lbrakk>x \\<in> B \\<Gamma> \\<inter> \\<^bold>V; x \\<noteq> b\\<rbrakk>\n    \\<Longrightarrow> x \\<in> SAT \\<Gamma> h'", "have \"d_IN h' x = weight \\<Gamma> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN h' x = weight \\<Gamma> x", "using that True"], ["proof (prove)\nusing this:\n  x \\<in> B \\<Gamma> \\<inter> \\<^bold>V\n  x = b\n\ngoal (1 subgoal):\n 1. d_IN h' x = weight \\<Gamma> x", "by(simp add: IN_h'_B g_SOURCE \\<alpha> currentD_weight_IN[OF h] add_diff_eq_ennreal add_diff_inverse_ennreal currentD_finite_IN[OF h])"], ["proof (state)\nthis:\n  d_IN h' x = weight \\<Gamma> x\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<in> B \\<Gamma> \\<inter> \\<^bold>V; x = b\\<rbrakk>\n    \\<Longrightarrow> x \\<in> SAT \\<Gamma> h'\n 2. \\<lbrakk>x \\<in> B \\<Gamma> \\<inter> \\<^bold>V; x \\<noteq> b\\<rbrakk>\n    \\<Longrightarrow> x \\<in> SAT \\<Gamma> h'", "thus ?thesis"], ["proof (prove)\nusing this:\n  d_IN h' x = weight \\<Gamma> x\n\ngoal (1 subgoal):\n 1. x \\<in> SAT \\<Gamma> h'", "by(simp add: SAT.simps)"], ["proof (state)\nthis:\n  x \\<in> SAT \\<Gamma> h'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> B \\<Gamma> \\<inter> \\<^bold>V; x \\<noteq> b\\<rbrakk>\n    \\<Longrightarrow> x \\<in> SAT \\<Gamma> h'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> B \\<Gamma> \\<inter> \\<^bold>V; x \\<noteq> b\\<rbrakk>\n    \\<Longrightarrow> x \\<in> SAT \\<Gamma> h'", "case False"], ["proof (state)\nthis:\n  x \\<noteq> b\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> B \\<Gamma> \\<inter> \\<^bold>V; x \\<noteq> b\\<rbrakk>\n    \\<Longrightarrow> x \\<in> SAT \\<Gamma> h'", "have \"d_IN h' x = d_IN (h 0) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN h' x = d_IN (h 0) x", "using that False"], ["proof (prove)\nusing this:\n  x \\<in> B \\<Gamma> \\<inter> \\<^bold>V\n  x \\<noteq> b\n\ngoal (1 subgoal):\n 1. d_IN h' x = d_IN (h 0) x", "by(simp add: IN_h'_B g_SOURCE)"], ["proof (state)\nthis:\n  d_IN h' x = d_IN (h 0) x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> B \\<Gamma> \\<inter> \\<^bold>V; x \\<noteq> b\\<rbrakk>\n    \\<Longrightarrow> x \\<in> SAT \\<Gamma> h'", "also"], ["proof (state)\nthis:\n  d_IN h' x = d_IN (h 0) x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> B \\<Gamma> \\<inter> \\<^bold>V; x \\<noteq> b\\<rbrakk>\n    \\<Longrightarrow> x \\<in> SAT \\<Gamma> h'", "have \"\\<dots> = weight \\<Gamma> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN (h 0) x = weight \\<Gamma> x", "using SAT[of 0, THEN subsetD, of x] False that currentD_SAT[OF h, of x 0] disjoint"], ["proof (prove)\nusing this:\n  x \\<in> B \\<Gamma> \\<inter> \\<^bold>V - {b} \\<Longrightarrow>\n  x \\<in> SAT \\<Gamma> (h 0)\n  x \\<noteq> b\n  x \\<in> B \\<Gamma> \\<inter> \\<^bold>V\n  (x \\<in> SAT \\<Gamma> (h 0)) =\n  (x \\<in> A \\<Gamma> \\<or> d_IN (h 0) x = weight \\<Gamma> x)\n  A \\<Gamma> \\<inter> B \\<Gamma> = {}\n\ngoal (1 subgoal):\n 1. d_IN (h 0) x = weight \\<Gamma> x", "by auto"], ["proof (state)\nthis:\n  d_IN (h 0) x = weight \\<Gamma> x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> B \\<Gamma> \\<inter> \\<^bold>V; x \\<noteq> b\\<rbrakk>\n    \\<Longrightarrow> x \\<in> SAT \\<Gamma> h'", "finally"], ["proof (chain)\npicking this:\n  d_IN h' x = weight \\<Gamma> x", "show ?thesis"], ["proof (prove)\nusing this:\n  d_IN h' x = weight \\<Gamma> x\n\ngoal (1 subgoal):\n 1. x \\<in> SAT \\<Gamma> h'", "by(simp add: SAT.simps)"], ["proof (state)\nthis:\n  x \\<in> SAT \\<Gamma> h'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?x1 \\<in> B \\<Gamma> \\<inter> \\<^bold>V \\<Longrightarrow>\n  ?x1 \\<in> SAT \\<Gamma> h'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  B \\<Gamma> \\<inter> \\<^bold>V \\<subseteq> SAT \\<Gamma> h'\n\ngoal (1 subgoal):\n 1. \\<exists>h'.\n       current \\<Gamma> h' \\<and>\n       wave \\<Gamma> h' \\<and>\n       B \\<Gamma> \\<inter> \\<^bold>V \\<subseteq> SAT \\<Gamma> h'", "moreover"], ["proof (state)\nthis:\n  B \\<Gamma> \\<inter> \\<^bold>V \\<subseteq> SAT \\<Gamma> h'\n\ngoal (1 subgoal):\n 1. \\<exists>h'.\n       current \\<Gamma> h' \\<and>\n       wave \\<Gamma> h' \\<and>\n       B \\<Gamma> \\<inter> \\<^bold>V \\<subseteq> SAT \\<Gamma> h'", "have \"wave \\<Gamma> h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wave \\<Gamma> h'", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. separating \\<Gamma> (TER h')\n 2. current \\<Gamma> h'", "have \"separating \\<Gamma> (B \\<Gamma> \\<inter> \\<^bold>V)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. separating \\<Gamma> (B \\<Gamma> \\<inter> \\<^bold>V)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y p.\n       \\<lbrakk>x \\<in> A \\<Gamma>; y \\<in> B \\<Gamma>;\n        path \\<Gamma> x p y\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>z\\<in>set p.\n                             z \\<in> B \\<Gamma> \\<inter> \\<^bold>V) \\<or>\n                         x \\<in> B \\<Gamma> \\<inter> \\<^bold>V", "fix x y p"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y p.\n       \\<lbrakk>x \\<in> A \\<Gamma>; y \\<in> B \\<Gamma>;\n        path \\<Gamma> x p y\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>z\\<in>set p.\n                             z \\<in> B \\<Gamma> \\<inter> \\<^bold>V) \\<or>\n                         x \\<in> B \\<Gamma> \\<inter> \\<^bold>V", "assume x: \"x \\<in> A \\<Gamma>\" and y: \"y \\<in> B \\<Gamma>\" and p: \"path \\<Gamma> x p y\""], ["proof (state)\nthis:\n  x \\<in> A \\<Gamma>\n  y \\<in> B \\<Gamma>\n  path \\<Gamma> x p y\n\ngoal (1 subgoal):\n 1. \\<And>x y p.\n       \\<lbrakk>x \\<in> A \\<Gamma>; y \\<in> B \\<Gamma>;\n        path \\<Gamma> x p y\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>z\\<in>set p.\n                             z \\<in> B \\<Gamma> \\<inter> \\<^bold>V) \\<or>\n                         x \\<in> B \\<Gamma> \\<inter> \\<^bold>V", "hence Nil: \"p \\<noteq> []\""], ["proof (prove)\nusing this:\n  x \\<in> A \\<Gamma>\n  y \\<in> B \\<Gamma>\n  path \\<Gamma> x p y\n\ngoal (1 subgoal):\n 1. p \\<noteq> []", "using disjoint"], ["proof (prove)\nusing this:\n  x \\<in> A \\<Gamma>\n  y \\<in> B \\<Gamma>\n  path \\<Gamma> x p y\n  A \\<Gamma> \\<inter> B \\<Gamma> = {}\n\ngoal (1 subgoal):\n 1. p \\<noteq> []", "by(auto simp add: rtrancl_path_simps)"], ["proof (state)\nthis:\n  p \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>x y p.\n       \\<lbrakk>x \\<in> A \\<Gamma>; y \\<in> B \\<Gamma>;\n        path \\<Gamma> x p y\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>z\\<in>set p.\n                             z \\<in> B \\<Gamma> \\<inter> \\<^bold>V) \\<or>\n                         x \\<in> B \\<Gamma> \\<inter> \\<^bold>V", "from rtrancl_path_last[OF p Nil] last_in_set[OF Nil] y rtrancl_path_Range[OF p, of y]"], ["proof (chain)\npicking this:\n  last p = y\n  last p \\<in> set p\n  y \\<in> B \\<Gamma>\n  y \\<in> set p \\<Longrightarrow> Rangep (edge \\<Gamma>) y", "show \"(\\<exists>z\\<in>set p. z \\<in> B \\<Gamma> \\<inter> \\<^bold>V) \\<or> x \\<in> B \\<Gamma> \\<inter> \\<^bold>V\""], ["proof (prove)\nusing this:\n  last p = y\n  last p \\<in> set p\n  y \\<in> B \\<Gamma>\n  y \\<in> set p \\<Longrightarrow> Rangep (edge \\<Gamma>) y\n\ngoal (1 subgoal):\n 1. (\\<exists>z\\<in>set p. z \\<in> B \\<Gamma> \\<inter> \\<^bold>V) \\<or>\n    x \\<in> B \\<Gamma> \\<inter> \\<^bold>V", "by(auto intro: vertexI2)"], ["proof (state)\nthis:\n  (\\<exists>z\\<in>set p. z \\<in> B \\<Gamma> \\<inter> \\<^bold>V) \\<or>\n  x \\<in> B \\<Gamma> \\<inter> \\<^bold>V\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  separating \\<Gamma> (B \\<Gamma> \\<inter> \\<^bold>V)\n\ngoal (2 subgoals):\n 1. separating \\<Gamma> (TER h')\n 2. current \\<Gamma> h'", "moreover"], ["proof (state)\nthis:\n  separating \\<Gamma> (B \\<Gamma> \\<inter> \\<^bold>V)\n\ngoal (2 subgoals):\n 1. separating \\<Gamma> (TER h')\n 2. current \\<Gamma> h'", "have TER: \"B \\<Gamma> \\<inter> \\<^bold>V \\<subseteq> TER h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B \\<Gamma> \\<inter> \\<^bold>V \\<subseteq> TER h'", "using SAT_h'"], ["proof (prove)\nusing this:\n  B \\<Gamma> \\<inter> \\<^bold>V \\<subseteq> SAT \\<Gamma> h'\n\ngoal (1 subgoal):\n 1. B \\<Gamma> \\<inter> \\<^bold>V \\<subseteq> TER h'", "by(auto simp add: SINK)"], ["proof (state)\nthis:\n  B \\<Gamma> \\<inter> \\<^bold>V \\<subseteq> TER h'\n\ngoal (2 subgoals):\n 1. separating \\<Gamma> (TER h')\n 2. current \\<Gamma> h'", "ultimately"], ["proof (chain)\npicking this:\n  separating \\<Gamma> (B \\<Gamma> \\<inter> \\<^bold>V)\n  B \\<Gamma> \\<inter> \\<^bold>V \\<subseteq> TER h'", "show \"separating \\<Gamma> (TER h')\""], ["proof (prove)\nusing this:\n  separating \\<Gamma> (B \\<Gamma> \\<inter> \\<^bold>V)\n  B \\<Gamma> \\<inter> \\<^bold>V \\<subseteq> TER h'\n\ngoal (1 subgoal):\n 1. separating \\<Gamma> (TER h')", "by(rule separating_weakening)"], ["proof (state)\nthis:\n  separating \\<Gamma> (TER h')\n\ngoal (1 subgoal):\n 1. current \\<Gamma> h'", "qed(rule h')"], ["proof (state)\nthis:\n  wave \\<Gamma> h'\n\ngoal (1 subgoal):\n 1. \\<exists>h'.\n       current \\<Gamma> h' \\<and>\n       wave \\<Gamma> h' \\<and>\n       B \\<Gamma> \\<inter> \\<^bold>V \\<subseteq> SAT \\<Gamma> h'", "ultimately"], ["proof (chain)\npicking this:\n  current \\<Gamma> h'\n  B \\<Gamma> \\<inter> \\<^bold>V \\<subseteq> SAT \\<Gamma> h'\n  wave \\<Gamma> h'", "show ?thesis"], ["proof (prove)\nusing this:\n  current \\<Gamma> h'\n  B \\<Gamma> \\<inter> \\<^bold>V \\<subseteq> SAT \\<Gamma> h'\n  wave \\<Gamma> h'\n\ngoal (1 subgoal):\n 1. \\<exists>h'.\n       current \\<Gamma> h' \\<and>\n       wave \\<Gamma> h' \\<and>\n       B \\<Gamma> \\<inter> \\<^bold>V \\<subseteq> SAT \\<Gamma> h'", "by blast"], ["proof (state)\nthis:\n  \\<exists>h'.\n     current \\<Gamma> h' \\<and>\n     wave \\<Gamma> h' \\<and>\n     B \\<Gamma> \\<inter> \\<^bold>V \\<subseteq> SAT \\<Gamma> h'\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "lemma countable_bipartite_web_reduce_weight:\n  assumes \"weight \\<Gamma> x \\<ge> w\"\n  shows \"countable_bipartite_web (reduce_weight \\<Gamma> x w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. countable_bipartite_web (reduce_weight \\<Gamma> x w)", "using bipartite_V A_vertex bipartite_E disjoint assms"], ["proof (prove)\nusing this:\n  \\<^bold>V \\<subseteq> A \\<Gamma> \\<union> B \\<Gamma>\n  A \\<Gamma> \\<subseteq> \\<^bold>V\n  edge \\<Gamma> ?x ?y \\<Longrightarrow>\n  ?x \\<in> A \\<Gamma> \\<and> ?y \\<in> B \\<Gamma>\n  A \\<Gamma> \\<inter> B \\<Gamma> = {}\n  ennreal w \\<le> weight \\<Gamma> x\n\ngoal (1 subgoal):\n 1. countable_bipartite_web (reduce_weight \\<Gamma> x w)", "by unfold_locales (auto 4 3 simp add: weight_outside )"], ["", "lemma unhinder: \\<comment> \\<open>Lemma 6.9\\<close>\n  assumes loose: \"loose \\<Gamma>\"\n  and b: \"b \\<in> B \\<Gamma>\"\n  and wb: \"weight \\<Gamma> b > 0\"\n  and \\<delta>: \"\\<delta> > 0\"\n  shows \"\\<exists>\\<epsilon>>0. \\<epsilon> < \\<delta> \\<and> \\<not> hindered (reduce_weight \\<Gamma> b \\<epsilon>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>\\<epsilon>>0.\n       \\<epsilon> < \\<delta> \\<and>\n       \\<not> hindered (reduce_weight \\<Gamma> b \\<epsilon>)", "proof(rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>\\<epsilon>>0.\n               \\<epsilon> < \\<delta> \\<and>\n               \\<not> hindered\n                       (reduce_weight \\<Gamma> b\n                         \\<epsilon>)) \\<Longrightarrow>\n    False", "assume \"\\<not> ?thesis\""], ["proof (state)\nthis:\n  \\<not> (\\<exists>\\<epsilon>>0.\n             \\<epsilon> < \\<delta> \\<and>\n             \\<not> hindered (reduce_weight \\<Gamma> b \\<epsilon>))\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>\\<epsilon>>0.\n               \\<epsilon> < \\<delta> \\<and>\n               \\<not> hindered\n                       (reduce_weight \\<Gamma> b\n                         \\<epsilon>)) \\<Longrightarrow>\n    False", "hence hindered: \"hindered (reduce_weight \\<Gamma> b \\<epsilon>)\" if \"\\<epsilon> > 0\" \"\\<epsilon> < \\<delta>\" for \\<epsilon>"], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>\\<epsilon>>0.\n             \\<epsilon> < \\<delta> \\<and>\n             \\<not> hindered (reduce_weight \\<Gamma> b \\<epsilon>))\n\ngoal (1 subgoal):\n 1. hindered (reduce_weight \\<Gamma> b \\<epsilon>)", "using that"], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>\\<epsilon>>0.\n             \\<epsilon> < \\<delta> \\<and>\n             \\<not> hindered (reduce_weight \\<Gamma> b \\<epsilon>))\n  0 < \\<epsilon>\n  \\<epsilon> < \\<delta>\n\ngoal (1 subgoal):\n 1. hindered (reduce_weight \\<Gamma> b \\<epsilon>)", "by simp"], ["proof (state)\nthis:\n  \\<lbrakk>0 < ?\\<epsilon>; ?\\<epsilon> < \\<delta>\\<rbrakk>\n  \\<Longrightarrow> hindered (reduce_weight \\<Gamma> b ?\\<epsilon>)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>\\<epsilon>>0.\n               \\<epsilon> < \\<delta> \\<and>\n               \\<not> hindered\n                       (reduce_weight \\<Gamma> b\n                         \\<epsilon>)) \\<Longrightarrow>\n    False", "from b disjoint"], ["proof (chain)\npicking this:\n  b \\<in> B \\<Gamma>\n  A \\<Gamma> \\<inter> B \\<Gamma> = {}", "have bnA: \"b \\<notin> A \\<Gamma>\""], ["proof (prove)\nusing this:\n  b \\<in> B \\<Gamma>\n  A \\<Gamma> \\<inter> B \\<Gamma> = {}\n\ngoal (1 subgoal):\n 1. b \\<notin> A \\<Gamma>", "by blast"], ["proof (state)\nthis:\n  b \\<notin> A \\<Gamma>\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>\\<epsilon>>0.\n               \\<epsilon> < \\<delta> \\<and>\n               \\<not> hindered\n                       (reduce_weight \\<Gamma> b\n                         \\<epsilon>)) \\<Longrightarrow>\n    False", "define wb where \"wb = enn2real (weight \\<Gamma> b)\""], ["proof (state)\nthis:\n  wb = enn2real (weight \\<Gamma> b)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>\\<epsilon>>0.\n               \\<epsilon> < \\<delta> \\<and>\n               \\<not> hindered\n                       (reduce_weight \\<Gamma> b\n                         \\<epsilon>)) \\<Longrightarrow>\n    False", "have wb_conv: \"weight \\<Gamma> b = ennreal wb\""], ["proof (prove)\ngoal (1 subgoal):\n 1. weight \\<Gamma> b = ennreal wb", "by(simp add: wb_def less_top[symmetric])"], ["proof (state)\nthis:\n  weight \\<Gamma> b = ennreal wb\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>\\<epsilon>>0.\n               \\<epsilon> < \\<delta> \\<and>\n               \\<not> hindered\n                       (reduce_weight \\<Gamma> b\n                         \\<epsilon>)) \\<Longrightarrow>\n    False", "have wb_pos: \"wb > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < wb", "using wb"], ["proof (prove)\nusing this:\n  0 < weight \\<Gamma> b\n\ngoal (1 subgoal):\n 1. 0 < wb", "by(simp add: wb_conv)"], ["proof (state)\nthis:\n  0 < wb\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>\\<epsilon>>0.\n               \\<epsilon> < \\<delta> \\<and>\n               \\<not> hindered\n                       (reduce_weight \\<Gamma> b\n                         \\<epsilon>)) \\<Longrightarrow>\n    False", "define \\<epsilon> where \"\\<epsilon> n = min \\<delta> wb / (n + 2)\" for n :: nat"], ["proof (state)\nthis:\n  \\<epsilon> ?n = min \\<delta> wb / real (?n + 2)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>\\<epsilon>>0.\n               \\<epsilon> < \\<delta> \\<and>\n               \\<not> hindered\n                       (reduce_weight \\<Gamma> b\n                         \\<epsilon>)) \\<Longrightarrow>\n    False", "have \\<epsilon>_pos: \"\\<epsilon> n > 0\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < \\<epsilon> n", "using wb_pos \\<delta>"], ["proof (prove)\nusing this:\n  0 < wb\n  0 < \\<delta>\n\ngoal (1 subgoal):\n 1. 0 < \\<epsilon> n", "by(simp add: \\<epsilon>_def)"], ["proof (state)\nthis:\n  0 < \\<epsilon> ?n\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>\\<epsilon>>0.\n               \\<epsilon> < \\<delta> \\<and>\n               \\<not> hindered\n                       (reduce_weight \\<Gamma> b\n                         \\<epsilon>)) \\<Longrightarrow>\n    False", "have \\<epsilon>_nonneg: \"0 \\<le> \\<epsilon> n\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> \\<epsilon> n", "using \\<epsilon>_pos[of n]"], ["proof (prove)\nusing this:\n  0 < \\<epsilon> n\n\ngoal (1 subgoal):\n 1. 0 \\<le> \\<epsilon> n", "by simp"], ["proof (state)\nthis:\n  0 \\<le> \\<epsilon> ?n\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>\\<epsilon>>0.\n               \\<epsilon> < \\<delta> \\<and>\n               \\<not> hindered\n                       (reduce_weight \\<Gamma> b\n                         \\<epsilon>)) \\<Longrightarrow>\n    False", "have *: \"\\<epsilon> n \\<le> min wb \\<delta> / 2\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<epsilon> n \\<le> min wb \\<delta> / 2", "using wb_pos \\<delta>"], ["proof (prove)\nusing this:\n  0 < wb\n  0 < \\<delta>\n\ngoal (1 subgoal):\n 1. \\<epsilon> n \\<le> min wb \\<delta> / 2", "by(auto simp add: \\<epsilon>_def field_simps min_def)"], ["proof (state)\nthis:\n  \\<epsilon> ?n \\<le> min wb \\<delta> / 2\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>\\<epsilon>>0.\n               \\<epsilon> < \\<delta> \\<and>\n               \\<not> hindered\n                       (reduce_weight \\<Gamma> b\n                         \\<epsilon>)) \\<Longrightarrow>\n    False", "have \\<epsilon>_le: \"\\<epsilon> n \\<le> wb\" and \\<epsilon>_less: \"\\<epsilon> n < wb\" and \\<epsilon>_less_\\<delta>: \"\\<epsilon> n < \\<delta>\" and \\<epsilon>_le': \"\\<epsilon> n \\<le> wb / 2\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<epsilon> n \\<le> wb &&& \\<epsilon> n < wb) &&&\n    \\<epsilon> n < \\<delta> &&& \\<epsilon> n \\<le> wb / 2", "using *[of n] \\<epsilon>_pos[of n]"], ["proof (prove)\nusing this:\n  \\<epsilon> n \\<le> min wb \\<delta> / 2\n  0 < \\<epsilon> n\n\ngoal (1 subgoal):\n 1. (\\<epsilon> n \\<le> wb &&& \\<epsilon> n < wb) &&&\n    \\<epsilon> n < \\<delta> &&& \\<epsilon> n \\<le> wb / 2", "by(auto)"], ["proof (state)\nthis:\n  \\<epsilon> ?n \\<le> wb\n  \\<epsilon> ?n < wb\n  \\<epsilon> ?n < \\<delta>\n  \\<epsilon> ?n \\<le> wb / 2\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>\\<epsilon>>0.\n               \\<epsilon> < \\<delta> \\<and>\n               \\<not> hindered\n                       (reduce_weight \\<Gamma> b\n                         \\<epsilon>)) \\<Longrightarrow>\n    False", "define \\<Gamma>' where \"\\<Gamma>' n = reduce_weight \\<Gamma> b (\\<epsilon> n)\" for n :: nat"], ["proof (state)\nthis:\n  \\<Gamma>' ?n = reduce_weight \\<Gamma> b (\\<epsilon> ?n)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>\\<epsilon>>0.\n               \\<epsilon> < \\<delta> \\<and>\n               \\<not> hindered\n                       (reduce_weight \\<Gamma> b\n                         \\<epsilon>)) \\<Longrightarrow>\n    False", "have \\<Gamma>'_sel [simp]:\n    \"edge (\\<Gamma>' n) = edge \\<Gamma>\"\n    \"A (\\<Gamma>' n) = A \\<Gamma>\"\n    \"B (\\<Gamma>' n) = B \\<Gamma>\"\n    \"weight (\\<Gamma>' n) x = weight \\<Gamma> x - (if x = b then \\<epsilon> n else 0)\"\n    \"essential (\\<Gamma>' n) = essential \\<Gamma>\"\n    \"roofed_gen (\\<Gamma>' n) = roofed_gen \\<Gamma>\"\n    for n x"], ["proof (prove)\ngoal (1 subgoal):\n 1. (edge (\\<Gamma>' n) = edge \\<Gamma> &&&\n     A (\\<Gamma>' n) = A \\<Gamma> &&& B (\\<Gamma>' n) = B \\<Gamma>) &&&\n    weight (\\<Gamma>' n) x =\n    weight \\<Gamma> x - ennreal (if x = b then \\<epsilon> n else 0) &&&\n    essential (\\<Gamma>' n) = essential \\<Gamma> &&&\n    roofed_gen (\\<Gamma>' n) = roofed_gen \\<Gamma>", "by(simp_all add: \\<Gamma>'_def)"], ["proof (state)\nthis:\n  edge (\\<Gamma>' ?n) = edge \\<Gamma>\n  A (\\<Gamma>' ?n) = A \\<Gamma>\n  B (\\<Gamma>' ?n) = B \\<Gamma>\n  weight (\\<Gamma>' ?n) ?x =\n  weight \\<Gamma> ?x - ennreal (if ?x = b then \\<epsilon> ?n else 0)\n  essential (\\<Gamma>' ?n) = essential \\<Gamma>\n  roofed_gen (\\<Gamma>' ?n) = roofed_gen \\<Gamma>\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>\\<epsilon>>0.\n               \\<epsilon> < \\<delta> \\<and>\n               \\<not> hindered\n                       (reduce_weight \\<Gamma> b\n                         \\<epsilon>)) \\<Longrightarrow>\n    False", "have vertex_\\<Gamma>' [simp]: \"vertex (\\<Gamma>' n) = vertex \\<Gamma>\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. vertex (\\<Gamma>' n) = vertex \\<Gamma>", "by(simp add: vertex_def fun_eq_iff)"], ["proof (state)\nthis:\n  vertex (\\<Gamma>' ?n) = vertex \\<Gamma>\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>\\<epsilon>>0.\n               \\<epsilon> < \\<delta> \\<and>\n               \\<not> hindered\n                       (reduce_weight \\<Gamma> b\n                         \\<epsilon>)) \\<Longrightarrow>\n    False", "from wb"], ["proof (chain)\npicking this:\n  0 < weight \\<Gamma> b", "have \"b \\<in> \\<^bold>V\""], ["proof (prove)\nusing this:\n  0 < weight \\<Gamma> b\n\ngoal (1 subgoal):\n 1. b \\<in> \\<^bold>V", "using weight_outside[of b]"], ["proof (prove)\nusing this:\n  0 < weight \\<Gamma> b\n  b \\<notin> \\<^bold>V \\<Longrightarrow> weight \\<Gamma> b = 0\n\ngoal (1 subgoal):\n 1. b \\<in> \\<^bold>V", "by(auto intro: ccontr)"], ["proof (state)\nthis:\n  b \\<in> \\<^bold>V\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>\\<epsilon>>0.\n               \\<epsilon> < \\<delta> \\<and>\n               \\<not> hindered\n                       (reduce_weight \\<Gamma> b\n                         \\<epsilon>)) \\<Longrightarrow>\n    False", "interpret \\<Gamma>': countable_bipartite_web \"\\<Gamma>' n\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. countable_bipartite_web (\\<Gamma>' n)", "unfolding \\<Gamma>'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. countable_bipartite_web (reduce_weight \\<Gamma> b (\\<epsilon> n))", "using wb_pos"], ["proof (prove)\nusing this:\n  0 < wb\n\ngoal (1 subgoal):\n 1. countable_bipartite_web (reduce_weight \\<Gamma> b (\\<epsilon> n))", "by(intro countable_bipartite_web_reduce_weight)(simp_all add: wb_conv \\<epsilon>_le \\<epsilon>_nonneg)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>\\<epsilon>>0.\n               \\<epsilon> < \\<delta> \\<and>\n               \\<not> hindered\n                       (reduce_weight \\<Gamma> b\n                         \\<epsilon>)) \\<Longrightarrow>\n    False", "obtain g where g: \"\\<And>n. current (\\<Gamma>' n) (g n)\"\n    and w: \"\\<And>n. wave (\\<Gamma>' n) (g n)\"\n    and hind: \"\\<And>n. hindrance (\\<Gamma>' n) (g n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>g.\n        \\<lbrakk>\\<And>n. current (\\<Gamma>' n) (g n);\n         \\<And>n. wave (\\<Gamma>' n) (g n);\n         \\<And>n. hindrance (\\<Gamma>' n) (g n)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using hindered[OF \\<epsilon>_pos, unfolded wb_conv ennreal_less_iff, OF \\<epsilon>_less_\\<delta>]"], ["proof (prove)\nusing this:\n  hindered (reduce_weight \\<Gamma> b (\\<epsilon> ?n1))\n\ngoal (1 subgoal):\n 1. (\\<And>g.\n        \\<lbrakk>\\<And>n. current (\\<Gamma>' n) (g n);\n         \\<And>n. wave (\\<Gamma>' n) (g n);\n         \\<And>n. hindrance (\\<Gamma>' n) (g n)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding hindered.simps \\<Gamma>'_def"], ["proof (prove)\nusing this:\n  \\<exists>f.\n     hindrance (reduce_weight \\<Gamma> b (\\<epsilon> ?n1)) f \\<and>\n     current (reduce_weight \\<Gamma> b (\\<epsilon> ?n1)) f \\<and>\n     wave (reduce_weight \\<Gamma> b (\\<epsilon> ?n1)) f\n\ngoal (1 subgoal):\n 1. (\\<And>g.\n        \\<lbrakk>\\<And>n.\n                    current (reduce_weight \\<Gamma> b (\\<epsilon> n)) (g n);\n         \\<And>n. wave (reduce_weight \\<Gamma> b (\\<epsilon> n)) (g n);\n         \\<And>n.\n            hindrance (reduce_weight \\<Gamma> b (\\<epsilon> n))\n             (g n)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by atomize_elim metis"], ["proof (state)\nthis:\n  current (\\<Gamma>' ?n) (g ?n)\n  wave (\\<Gamma>' ?n) (g ?n)\n  hindrance (\\<Gamma>' ?n) (g ?n)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>\\<epsilon>>0.\n               \\<epsilon> < \\<delta> \\<and>\n               \\<not> hindered\n                       (reduce_weight \\<Gamma> b\n                         \\<epsilon>)) \\<Longrightarrow>\n    False", "from g"], ["proof (chain)\npicking this:\n  current (\\<Gamma>' ?n) (g ?n)", "have g\\<Gamma>: \"current \\<Gamma> (g n)\" for n"], ["proof (prove)\nusing this:\n  current (\\<Gamma>' ?n) (g ?n)\n\ngoal (1 subgoal):\n 1. current \\<Gamma> (g n)", "by(rule current_weight_mono)(auto simp add: \\<epsilon>_nonneg diff_le_self_ennreal)"], ["proof (state)\nthis:\n  current \\<Gamma> (g ?n)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>\\<epsilon>>0.\n               \\<epsilon> < \\<delta> \\<and>\n               \\<not> hindered\n                       (reduce_weight \\<Gamma> b\n                         \\<epsilon>)) \\<Longrightarrow>\n    False", "note [simp] = currentD_finite[OF g\\<Gamma>]"], ["proof (state)\nthis:\n  g ?n1 ?e \\<noteq> \\<top>\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>\\<epsilon>>0.\n               \\<epsilon> < \\<delta> \\<and>\n               \\<not> hindered\n                       (reduce_weight \\<Gamma> b\n                         \\<epsilon>)) \\<Longrightarrow>\n    False", "have b_TER: \"b \\<in> TER\\<^bsub>\\<Gamma>' n\\<^esub> (g n)\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. b \\<in> TER\\<^bsub>\\<Gamma>' n\\<^esub> (g n)", "proof(rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. b \\<notin> TER\\<^bsub>\\<Gamma>' n\\<^esub> (g n) \\<Longrightarrow> False", "assume b': \"b \\<notin> TER\\<^bsub>\\<Gamma>' n\\<^esub> (g n)\""], ["proof (state)\nthis:\n  b \\<notin> TER\\<^bsub>\\<Gamma>' n\\<^esub> (g n)\n\ngoal (1 subgoal):\n 1. b \\<notin> TER\\<^bsub>\\<Gamma>' n\\<^esub> (g n) \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  b \\<notin> TER\\<^bsub>\\<Gamma>' n\\<^esub> (g n)", "have TER: \"TER\\<^bsub>\\<Gamma>' n\\<^esub> (g n) = TER (g n)\""], ["proof (prove)\nusing this:\n  b \\<notin> TER\\<^bsub>\\<Gamma>' n\\<^esub> (g n)\n\ngoal (1 subgoal):\n 1. TER\\<^bsub>\\<Gamma>' n\\<^esub> (g n) = TER (g n)", "using b \\<epsilon>_nonneg[of n]"], ["proof (prove)\nusing this:\n  b \\<notin> TER\\<^bsub>\\<Gamma>' n\\<^esub> (g n)\n  b \\<in> B \\<Gamma>\n  0 \\<le> \\<epsilon> n\n\ngoal (1 subgoal):\n 1. TER\\<^bsub>\\<Gamma>' n\\<^esub> (g n) = TER (g n)", "by(auto simp add: SAT.simps split: if_split_asm intro: ennreal_diff_le_mono_left)"], ["proof (state)\nthis:\n  TER\\<^bsub>\\<Gamma>' n\\<^esub> (g n) = TER (g n)\n\ngoal (1 subgoal):\n 1. b \\<notin> TER\\<^bsub>\\<Gamma>' n\\<^esub> (g n) \\<Longrightarrow> False", "from w[of n] TER"], ["proof (chain)\npicking this:\n  wave (\\<Gamma>' n) (g n)\n  TER\\<^bsub>\\<Gamma>' n\\<^esub> (g n) = TER (g n)", "have \"wave \\<Gamma> (g n)\""], ["proof (prove)\nusing this:\n  wave (\\<Gamma>' n) (g n)\n  TER\\<^bsub>\\<Gamma>' n\\<^esub> (g n) = TER (g n)\n\ngoal (1 subgoal):\n 1. wave \\<Gamma> (g n)", "by(simp add: wave.simps separating_gen.simps)"], ["proof (state)\nthis:\n  wave \\<Gamma> (g n)\n\ngoal (1 subgoal):\n 1. b \\<notin> TER\\<^bsub>\\<Gamma>' n\\<^esub> (g n) \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  wave \\<Gamma> (g n)\n\ngoal (1 subgoal):\n 1. b \\<notin> TER\\<^bsub>\\<Gamma>' n\\<^esub> (g n) \\<Longrightarrow> False", "have \"hindrance \\<Gamma> (g n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hindrance \\<Gamma> (g n)", "using hind[of n] TER bnA b'"], ["proof (prove)\nusing this:\n  hindrance (\\<Gamma>' n) (g n)\n  TER\\<^bsub>\\<Gamma>' n\\<^esub> (g n) = TER (g n)\n  b \\<notin> A \\<Gamma>\n  b \\<notin> TER\\<^bsub>\\<Gamma>' n\\<^esub> (g n)\n\ngoal (1 subgoal):\n 1. hindrance \\<Gamma> (g n)", "by(auto simp add: hindrance.simps split: if_split_asm)"], ["proof (state)\nthis:\n  hindrance \\<Gamma> (g n)\n\ngoal (1 subgoal):\n 1. b \\<notin> TER\\<^bsub>\\<Gamma>' n\\<^esub> (g n) \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  wave \\<Gamma> (g n)\n  hindrance \\<Gamma> (g n)", "show False"], ["proof (prove)\nusing this:\n  wave \\<Gamma> (g n)\n  hindrance \\<Gamma> (g n)\n\ngoal (1 subgoal):\n 1. False", "using loose_unhindered[OF loose] g\\<Gamma>[of n]"], ["proof (prove)\nusing this:\n  wave \\<Gamma> (g n)\n  hindrance \\<Gamma> (g n)\n  \\<not> hindered \\<Gamma>\n  current \\<Gamma> (g n)\n\ngoal (1 subgoal):\n 1. False", "by(auto intro: hindered.intros)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  b \\<in> TER\\<^bsub>\\<Gamma>' ?n\\<^esub> (g ?n)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>\\<epsilon>>0.\n               \\<epsilon> < \\<delta> \\<and>\n               \\<not> hindered\n                       (reduce_weight \\<Gamma> b\n                         \\<epsilon>)) \\<Longrightarrow>\n    False", "have IN_g_b: \"d_IN (g n) b = weight \\<Gamma> b - \\<epsilon> n\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN (g n) b = weight \\<Gamma> b - ennreal (\\<epsilon> n)", "using b_TER[of n] bnA"], ["proof (prove)\nusing this:\n  b \\<in> TER\\<^bsub>\\<Gamma>' n\\<^esub> (g n)\n  b \\<notin> A \\<Gamma>\n\ngoal (1 subgoal):\n 1. d_IN (g n) b = weight \\<Gamma> b - ennreal (\\<epsilon> n)", "by(auto simp add: currentD_SAT[OF g])"], ["proof (state)\nthis:\n  d_IN (g ?n) b = weight \\<Gamma> b - ennreal (\\<epsilon> ?n)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>\\<epsilon>>0.\n               \\<epsilon> < \\<delta> \\<and>\n               \\<not> hindered\n                       (reduce_weight \\<Gamma> b\n                         \\<epsilon>)) \\<Longrightarrow>\n    False", "define factor where \"factor n = (wb - \\<epsilon> 0) / (wb - \\<epsilon> n)\" for n"], ["proof (state)\nthis:\n  factor ?n = (wb - \\<epsilon> 0) / (wb - \\<epsilon> ?n)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>\\<epsilon>>0.\n               \\<epsilon> < \\<delta> \\<and>\n               \\<not> hindered\n                       (reduce_weight \\<Gamma> b\n                         \\<epsilon>)) \\<Longrightarrow>\n    False", "have factor_le_1: \"factor n \\<le> 1\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. factor n \\<le> 1", "using wb_pos \\<delta> \\<epsilon>_less[of n]"], ["proof (prove)\nusing this:\n  0 < wb\n  0 < \\<delta>\n  \\<epsilon> n < wb\n\ngoal (1 subgoal):\n 1. factor n \\<le> 1", "by(auto simp add: factor_def field_simps \\<epsilon>_def min_def)"], ["proof (state)\nthis:\n  factor ?n \\<le> 1\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>\\<epsilon>>0.\n               \\<epsilon> < \\<delta> \\<and>\n               \\<not> hindered\n                       (reduce_weight \\<Gamma> b\n                         \\<epsilon>)) \\<Longrightarrow>\n    False", "have factor_pos: \"0 < factor n\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < factor n", "using wb_pos \\<delta> * \\<epsilon>_less"], ["proof (prove)\nusing this:\n  0 < wb\n  0 < \\<delta>\n  \\<epsilon> ?n \\<le> min wb \\<delta> / 2\n  \\<epsilon> ?n < wb\n\ngoal (1 subgoal):\n 1. 0 < factor n", "by(simp add: factor_def field_simps)"], ["proof (state)\nthis:\n  0 < factor ?n\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>\\<epsilon>>0.\n               \\<epsilon> < \\<delta> \\<and>\n               \\<not> hindered\n                       (reduce_weight \\<Gamma> b\n                         \\<epsilon>)) \\<Longrightarrow>\n    False", "have factor: \"(wb - \\<epsilon> n) * factor n = wb - \\<epsilon> 0\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. (wb - \\<epsilon> n) * factor n = wb - \\<epsilon> 0", "using \\<epsilon>_less[of n]"], ["proof (prove)\nusing this:\n  \\<epsilon> n < wb\n\ngoal (1 subgoal):\n 1. (wb - \\<epsilon> n) * factor n = wb - \\<epsilon> 0", "by(simp add: factor_def field_simps)"], ["proof (state)\nthis:\n  (wb - \\<epsilon> ?n) * factor ?n = wb - \\<epsilon> 0\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>\\<epsilon>>0.\n               \\<epsilon> < \\<delta> \\<and>\n               \\<not> hindered\n                       (reduce_weight \\<Gamma> b\n                         \\<epsilon>)) \\<Longrightarrow>\n    False", "define g' where \"g' = (\\<lambda>n (x, y). if y = b then g n (x, y) * factor n else g n (x, y))\""], ["proof (state)\nthis:\n  g' =\n  (\\<lambda>n (x, y).\n      if y = b then g n (x, y) * ennreal (factor n) else g n (x, y))\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>\\<epsilon>>0.\n               \\<epsilon> < \\<delta> \\<and>\n               \\<not> hindered\n                       (reduce_weight \\<Gamma> b\n                         \\<epsilon>)) \\<Longrightarrow>\n    False", "have g'_simps: \"g' n (x, y) = (if y = b then g n (x, y) * factor n else g n (x, y))\" for n x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. g' n (x, y) =\n    (if y = b then g n (x, y) * ennreal (factor n) else g n (x, y))", "by(simp add: g'_def)"], ["proof (state)\nthis:\n  g' ?n (?x, ?y) =\n  (if ?y = b then g ?n (?x, ?y) * ennreal (factor ?n) else g ?n (?x, ?y))\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>\\<epsilon>>0.\n               \\<epsilon> < \\<delta> \\<and>\n               \\<not> hindered\n                       (reduce_weight \\<Gamma> b\n                         \\<epsilon>)) \\<Longrightarrow>\n    False", "have g'_le_g: \"g' n e \\<le> g n e\" for n e"], ["proof (prove)\ngoal (1 subgoal):\n 1. g' n e \\<le> g n e", "using factor_le_1[of n]"], ["proof (prove)\nusing this:\n  factor n \\<le> 1\n\ngoal (1 subgoal):\n 1. g' n e \\<le> g n e", "by(cases e \"g n e\" rule: prod.exhaust[case_product ennreal_cases])\n      (auto simp add: g'_simps field_simps mult_left_le)"], ["proof (state)\nthis:\n  g' ?n ?e \\<le> g ?n ?e\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>\\<epsilon>>0.\n               \\<epsilon> < \\<delta> \\<and>\n               \\<not> hindered\n                       (reduce_weight \\<Gamma> b\n                         \\<epsilon>)) \\<Longrightarrow>\n    False", "have \"4 + (n * 6 + n * (n * 2)) \\<noteq> (0 :: real)\" for n :: nat"], ["proof (prove)\ngoal (1 subgoal):\n 1. real (4 + (n * 6 + n * (n * 2))) \\<noteq> 0", "by(metis (mono_tags, hide_lams) add_is_0 of_nat_eq_0_iff of_nat_numeral zero_neq_numeral)"], ["proof (state)\nthis:\n  real (4 + (?n * 6 + ?n * (?n * 2))) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>\\<epsilon>>0.\n               \\<epsilon> < \\<delta> \\<and>\n               \\<not> hindered\n                       (reduce_weight \\<Gamma> b\n                         \\<epsilon>)) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  real (4 + (?n * 6 + ?n * (?n * 2))) \\<noteq> 0", "have IN_g': \"d_IN (g' n) x = (if x = b then weight \\<Gamma> b - \\<epsilon> 0 else d_IN (g n) x)\" for x n"], ["proof (prove)\nusing this:\n  real (4 + (?n * 6 + ?n * (?n * 2))) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. d_IN (g' n) x =\n    (if x = b then weight \\<Gamma> b - ennreal (\\<epsilon> 0)\n     else d_IN (g n) x)", "using b_TER[of n] bnA factor_pos[of n] factor[of n] wb_pos \\<delta>"], ["proof (prove)\nusing this:\n  real (4 + (?n * 6 + ?n * (?n * 2))) \\<noteq> 0\n  b \\<in> TER\\<^bsub>\\<Gamma>' n\\<^esub> (g n)\n  b \\<notin> A \\<Gamma>\n  0 < factor n\n  (wb - \\<epsilon> n) * factor n = wb - \\<epsilon> 0\n  0 < wb\n  0 < \\<delta>\n\ngoal (1 subgoal):\n 1. d_IN (g' n) x =\n    (if x = b then weight \\<Gamma> b - ennreal (\\<epsilon> 0)\n     else d_IN (g n) x)", "by(auto simp add: d_IN_def g'_simps nn_integral_divide nn_integral_cmult currentD_SAT[OF g] wb_conv \\<epsilon>_def field_simps\n                      ennreal_minus ennreal_mult'[symmetric] intro!: arg_cong[where f=ennreal])"], ["proof (state)\nthis:\n  d_IN (g' ?n) ?x =\n  (if ?x = b then weight \\<Gamma> b - ennreal (\\<epsilon> 0)\n   else d_IN (g ?n) ?x)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>\\<epsilon>>0.\n               \\<epsilon> < \\<delta> \\<and>\n               \\<not> hindered\n                       (reduce_weight \\<Gamma> b\n                         \\<epsilon>)) \\<Longrightarrow>\n    False", "have OUT_g': \"d_OUT (g' n) x = d_OUT (g n) x - g n (x, b) * (1 - factor n)\" for n x"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT (g' n) x = d_OUT (g n) x - g n (x, b) * ennreal (1 - factor n)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. d_OUT (g' n) x = d_OUT (g n) x - g n (x, b) * ennreal (1 - factor n)", "have \"d_OUT (g' n) x = (\\<Sum>\\<^sup>+ y. g n (x, y)) - (\\<Sum>\\<^sup>+ y. (g n (x, y) * (1 - factor n)) * indicator {b} y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT (g' n) x =\n    (\\<Sum>\\<^sup>+ y. g n (x, y)) -\n    (\\<integral>\\<^sup>+y\\<in>{b}. (g n (x, y) * ennreal (1 - factor n))\n     \\<partial>count_space UNIV)", "using factor_le_1[of n] factor_pos[of n]"], ["proof (prove)\nusing this:\n  factor n \\<le> 1\n  0 < factor n\n\ngoal (1 subgoal):\n 1. d_OUT (g' n) x =\n    (\\<Sum>\\<^sup>+ y. g n (x, y)) -\n    (\\<integral>\\<^sup>+y\\<in>{b}. (g n (x, y) * ennreal (1 - factor n))\n     \\<partial>count_space UNIV)", "apply(cases \"g n (x, b)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>r.\n       \\<lbrakk>factor n \\<le> 1; 0 < factor n; 0 \\<le> r;\n        g n (x, b) = ennreal r\\<rbrakk>\n       \\<Longrightarrow> d_OUT (g' n) x =\n                         (\\<Sum>\\<^sup>+ y. g n (x, y)) -\n                         (\\<integral>\\<^sup>+y\\<in>{b}.\n       (g n (x, y) * ennreal (1 - factor n))\n                          \\<partial>count_space UNIV)\n 2. \\<lbrakk>factor n \\<le> 1; 0 < factor n; g n (x, b) = \\<top>\\<rbrakk>\n    \\<Longrightarrow> d_OUT (g' n) x =\n                      (\\<Sum>\\<^sup>+ y. g n (x, y)) -\n                      (\\<integral>\\<^sup>+y\\<in>{b}.\n    (g n (x, y) * ennreal (1 - factor n))\n                       \\<partial>count_space UNIV)", "apply(subst nn_integral_diff[symmetric])"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>r.\n       \\<lbrakk>factor n \\<le> 1; 0 < factor n; 0 \\<le> r;\n        g n (x, b) = ennreal r\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>y. g n (x, y))\n                         \\<in> borel_measurable (count_space UNIV)\n 2. \\<And>r.\n       \\<lbrakk>factor n \\<le> 1; 0 < factor n; 0 \\<le> r;\n        g n (x, b) = ennreal r\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>y.\n                             g n (x, y) * ennreal (1 - factor n) *\n                             indicator {b} y)\n                         \\<in> borel_measurable (count_space UNIV)\n 3. \\<And>r.\n       \\<lbrakk>factor n \\<le> 1; 0 < factor n; 0 \\<le> r;\n        g n (x, b) = ennreal r\\<rbrakk>\n       \\<Longrightarrow> \\<integral>\\<^sup>+y\\<in>{b}.\n      (g n (x, y) * ennreal (1 - factor n))\n                         \\<partial>count_space UNIV \\<noteq>\n                         \\<infinity>\n 4. \\<And>r.\n       \\<lbrakk>factor n \\<le> 1; 0 < factor n; 0 \\<le> r;\n        g n (x, b) = ennreal r\\<rbrakk>\n       \\<Longrightarrow> AE xa in count_space\n                                   UNIV. g n (x, xa) *\n   ennreal (1 - factor n) *\n   indicator {b} xa\n   \\<le> g n (x, xa)\n 5. \\<And>r.\n       \\<lbrakk>factor n \\<le> 1; 0 < factor n; 0 \\<le> r;\n        g n (x, b) = ennreal r\\<rbrakk>\n       \\<Longrightarrow> d_OUT (g' n) x =\n                         (\\<Sum>\\<^sup>+ xa.\n                            g n (x, xa) -\n                            g n (x, xa) * ennreal (1 - factor n) *\n                            indicator {b} xa)\n 6. \\<lbrakk>factor n \\<le> 1; 0 < factor n; g n (x, b) = \\<top>\\<rbrakk>\n    \\<Longrightarrow> d_OUT (g' n) x =\n                      (\\<Sum>\\<^sup>+ y. g n (x, y)) -\n                      (\\<integral>\\<^sup>+y\\<in>{b}.\n    (g n (x, y) * ennreal (1 - factor n))\n                       \\<partial>count_space UNIV)", "apply(auto simp add: g'_simps nn_integral_divide d_OUT_def AE_count_space mult_left_le ennreal_mult_eq_top_iff\n                           ennreal_mult'[symmetric] ennreal_minus_if\n                 intro!: nn_integral_cong split: split_indicator)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>r.\n       \\<lbrakk>factor n \\<le> 1; 0 < factor n; 0 \\<le> r;\n        g n (x, b) = ennreal r\\<rbrakk>\n       \\<Longrightarrow> r * factor n = r - r * (1 - factor n)", "apply(simp_all add: field_simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  d_OUT (g' n) x =\n  (\\<Sum>\\<^sup>+ y. g n (x, y)) -\n  (\\<integral>\\<^sup>+y\\<in>{b}. (g n (x, y) * ennreal (1 - factor n))\n   \\<partial>count_space UNIV)\n\ngoal (1 subgoal):\n 1. d_OUT (g' n) x = d_OUT (g n) x - g n (x, b) * ennreal (1 - factor n)", "also"], ["proof (state)\nthis:\n  d_OUT (g' n) x =\n  (\\<Sum>\\<^sup>+ y. g n (x, y)) -\n  (\\<integral>\\<^sup>+y\\<in>{b}. (g n (x, y) * ennreal (1 - factor n))\n   \\<partial>count_space UNIV)\n\ngoal (1 subgoal):\n 1. d_OUT (g' n) x = d_OUT (g n) x - g n (x, b) * ennreal (1 - factor n)", "have \"\\<dots> = d_OUT (g n) x - g n (x, b) * (1 - factor n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y. g n (x, y)) -\n    (\\<integral>\\<^sup>+y\\<in>{b}. (g n (x, y) * ennreal (1 - factor n))\n     \\<partial>count_space UNIV) =\n    d_OUT (g n) x - g n (x, b) * ennreal (1 - factor n)", "using factor_le_1[of n]"], ["proof (prove)\nusing this:\n  factor n \\<le> 1\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y. g n (x, y)) -\n    (\\<integral>\\<^sup>+y\\<in>{b}. (g n (x, y) * ennreal (1 - factor n))\n     \\<partial>count_space UNIV) =\n    d_OUT (g n) x - g n (x, b) * ennreal (1 - factor n)", "by(subst nn_integral_indicator_singleton)(simp_all add: d_OUT_def field_simps)"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y. g n (x, y)) -\n  (\\<integral>\\<^sup>+y\\<in>{b}. (g n (x, y) * ennreal (1 - factor n))\n   \\<partial>count_space UNIV) =\n  d_OUT (g n) x - g n (x, b) * ennreal (1 - factor n)\n\ngoal (1 subgoal):\n 1. d_OUT (g' n) x = d_OUT (g n) x - g n (x, b) * ennreal (1 - factor n)", "finally"], ["proof (chain)\npicking this:\n  d_OUT (g' n) x = d_OUT (g n) x - g n (x, b) * ennreal (1 - factor n)", "show ?thesis"], ["proof (prove)\nusing this:\n  d_OUT (g' n) x = d_OUT (g n) x - g n (x, b) * ennreal (1 - factor n)\n\ngoal (1 subgoal):\n 1. d_OUT (g' n) x = d_OUT (g n) x - g n (x, b) * ennreal (1 - factor n)", "."], ["proof (state)\nthis:\n  d_OUT (g' n) x = d_OUT (g n) x - g n (x, b) * ennreal (1 - factor n)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  d_OUT (g' ?n) ?x =\n  d_OUT (g ?n) ?x - g ?n (?x, b) * ennreal (1 - factor ?n)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>\\<epsilon>>0.\n               \\<epsilon> < \\<delta> \\<and>\n               \\<not> hindered\n                       (reduce_weight \\<Gamma> b\n                         \\<epsilon>)) \\<Longrightarrow>\n    False", "have g': \"current (\\<Gamma>' 0) (g' n)\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. current (\\<Gamma>' 0) (g' n)", "proof"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x. d_OUT (g' n) x \\<le> weight (\\<Gamma>' 0) x\n 2. \\<And>x. d_IN (g' n) x \\<le> weight (\\<Gamma>' 0) x\n 3. \\<And>e.\n       e \\<notin> \\<^bold>E\\<^bsub>\\<Gamma>' 0\\<^esub> \\<Longrightarrow>\n       g' n e = 0", "show \"d_OUT (g' n) x \\<le> weight (\\<Gamma>' 0) x\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT (g' n) x \\<le> weight (\\<Gamma>' 0) x", "using b_TER[of n] currentD_weight_OUT[OF g, of n x] \\<epsilon>_le[of 0] factor_le_1[of n]"], ["proof (prove)\nusing this:\n  b \\<in> TER\\<^bsub>\\<Gamma>' n\\<^esub> (g n)\n  d_OUT (g n) x \\<le> weight (\\<Gamma>' n) x\n  \\<epsilon> 0 \\<le> wb\n  factor n \\<le> 1\n\ngoal (1 subgoal):\n 1. d_OUT (g' n) x \\<le> weight (\\<Gamma>' 0) x", "by(auto simp add: OUT_g' SINK.simps ennreal_diff_le_mono_left)"], ["proof (state)\nthis:\n  d_OUT (g' n) ?x \\<le> weight (\\<Gamma>' 0) ?x\n\ngoal (2 subgoals):\n 1. \\<And>x. d_IN (g' n) x \\<le> weight (\\<Gamma>' 0) x\n 2. \\<And>e.\n       e \\<notin> \\<^bold>E\\<^bsub>\\<Gamma>' 0\\<^esub> \\<Longrightarrow>\n       g' n e = 0", "show \"d_IN (g' n) x \\<le> weight (\\<Gamma>' 0) x\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN (g' n) x \\<le> weight (\\<Gamma>' 0) x", "using d_IN_mono[of \"g' n\" x, OF g'_le_g] currentD_weight_IN[OF g, of n x] b_TER[of n] b"], ["proof (prove)\nusing this:\n  d_IN (g' n) x \\<le> d_IN (g n) x\n  d_IN (g n) x \\<le> weight (\\<Gamma>' n) x\n  b \\<in> TER\\<^bsub>\\<Gamma>' n\\<^esub> (g n)\n  b \\<in> B \\<Gamma>\n\ngoal (1 subgoal):\n 1. d_IN (g' n) x \\<le> weight (\\<Gamma>' 0) x", "by(auto simp add: IN_g' SAT.simps wb_conv \\<epsilon>_def)"], ["proof (state)\nthis:\n  d_IN (g' n) ?x \\<le> weight (\\<Gamma>' 0) ?x\n\ngoal (1 subgoal):\n 1. \\<And>e.\n       e \\<notin> \\<^bold>E\\<^bsub>\\<Gamma>' 0\\<^esub> \\<Longrightarrow>\n       g' n e = 0", "show \"g' n e = 0\" if \"e \\<notin> \\<^bold>E\\<^bsub>\\<Gamma>' 0\\<^esub>\" for e"], ["proof (prove)\ngoal (1 subgoal):\n 1. g' n e = 0", "using that"], ["proof (prove)\nusing this:\n  e \\<notin> \\<^bold>E\\<^bsub>\\<Gamma>' 0\\<^esub>\n\ngoal (1 subgoal):\n 1. g' n e = 0", "by(cases e)(clarsimp simp add: g'_simps currentD_outside[OF g])"], ["proof (state)\nthis:\n  ?e \\<notin> \\<^bold>E\\<^bsub>\\<Gamma>' 0\\<^esub> \\<Longrightarrow>\n  g' n ?e = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  current (\\<Gamma>' 0) (g' ?n)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>\\<epsilon>>0.\n               \\<epsilon> < \\<delta> \\<and>\n               \\<not> hindered\n                       (reduce_weight \\<Gamma> b\n                         \\<epsilon>)) \\<Longrightarrow>\n    False", "have SINK_g': \"SINK (g n) = SINK (g' n)\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. SINK (g n) = SINK (g' n)", "using factor_pos[of n]"], ["proof (prove)\nusing this:\n  0 < factor n\n\ngoal (1 subgoal):\n 1. SINK (g n) = SINK (g' n)", "by(auto simp add: SINK.simps currentD_OUT_eq_0[OF g] currentD_OUT_eq_0[OF g'] g'_simps split: if_split_asm)"], ["proof (state)\nthis:\n  SINK (g ?n) = SINK (g' ?n)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>\\<epsilon>>0.\n               \\<epsilon> < \\<delta> \\<and>\n               \\<not> hindered\n                       (reduce_weight \\<Gamma> b\n                         \\<epsilon>)) \\<Longrightarrow>\n    False", "have SAT_g': \"SAT (\\<Gamma>' n) (g n) = SAT (\\<Gamma>' 0) (g' n)\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. SAT (\\<Gamma>' n) (g n) = SAT (\\<Gamma>' 0) (g' n)", "using b_TER[of n] \\<epsilon>_le'[of 0]"], ["proof (prove)\nusing this:\n  b \\<in> TER\\<^bsub>\\<Gamma>' n\\<^esub> (g n)\n  \\<epsilon> 0 \\<le> wb / 2\n\ngoal (1 subgoal):\n 1. SAT (\\<Gamma>' n) (g n) = SAT (\\<Gamma>' 0) (g' n)", "by(auto simp add: SAT.simps wb_conv IN_g' IN_g_b)"], ["proof (state)\nthis:\n  SAT (\\<Gamma>' ?n) (g ?n) = SAT (\\<Gamma>' 0) (g' ?n)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>\\<epsilon>>0.\n               \\<epsilon> < \\<delta> \\<and>\n               \\<not> hindered\n                       (reduce_weight \\<Gamma> b\n                         \\<epsilon>)) \\<Longrightarrow>\n    False", "have TER_g': \"TER\\<^bsub>\\<Gamma>' n\\<^esub> (g n) = TER\\<^bsub>\\<Gamma>' 0\\<^esub> (g' n)\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. TER\\<^bsub>\\<Gamma>' n\\<^esub> (g n) =\n    TER\\<^bsub>\\<Gamma>' 0\\<^esub> (g' n)", "using b_TER[of n]"], ["proof (prove)\nusing this:\n  b \\<in> TER\\<^bsub>\\<Gamma>' n\\<^esub> (g n)\n\ngoal (1 subgoal):\n 1. TER\\<^bsub>\\<Gamma>' n\\<^esub> (g n) =\n    TER\\<^bsub>\\<Gamma>' 0\\<^esub> (g' n)", "by(auto simp add: SAT.simps SINK_g' OUT_g' IN_g' wb_conv \\<epsilon>_def)"], ["proof (state)\nthis:\n  TER\\<^bsub>\\<Gamma>' ?n\\<^esub> (g ?n) =\n  TER\\<^bsub>\\<Gamma>' 0\\<^esub> (g' ?n)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>\\<epsilon>>0.\n               \\<epsilon> < \\<delta> \\<and>\n               \\<not> hindered\n                       (reduce_weight \\<Gamma> b\n                         \\<epsilon>)) \\<Longrightarrow>\n    False", "have w': \"wave (\\<Gamma>' 0) (g' n)\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. wave (\\<Gamma>' 0) (g' n)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. separating (\\<Gamma>' 0) (TER\\<^bsub>\\<Gamma>' 0\\<^esub> (g' n))\n 2. current (\\<Gamma>' 0) (g' n)", "have \"separating (\\<Gamma>' 0) (TER\\<^bsub>\\<Gamma>' n\\<^esub> (g n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. separating (\\<Gamma>' 0) (TER\\<^bsub>\\<Gamma>' n\\<^esub> (g n))", "using waveD_separating[OF w, of n]"], ["proof (prove)\nusing this:\n  separating (\\<Gamma>' n) (TER\\<^bsub>\\<Gamma>' n\\<^esub> (g n))\n\ngoal (1 subgoal):\n 1. separating (\\<Gamma>' 0) (TER\\<^bsub>\\<Gamma>' n\\<^esub> (g n))", "by(simp add: separating_gen.simps)"], ["proof (state)\nthis:\n  separating (\\<Gamma>' 0) (TER\\<^bsub>\\<Gamma>' n\\<^esub> (g n))\n\ngoal (2 subgoals):\n 1. separating (\\<Gamma>' 0) (TER\\<^bsub>\\<Gamma>' 0\\<^esub> (g' n))\n 2. current (\\<Gamma>' 0) (g' n)", "then"], ["proof (chain)\npicking this:\n  separating (\\<Gamma>' 0) (TER\\<^bsub>\\<Gamma>' n\\<^esub> (g n))", "show \"separating (\\<Gamma>' 0) (TER\\<^bsub>\\<Gamma>' 0\\<^esub> (g' n))\""], ["proof (prove)\nusing this:\n  separating (\\<Gamma>' 0) (TER\\<^bsub>\\<Gamma>' n\\<^esub> (g n))\n\ngoal (1 subgoal):\n 1. separating (\\<Gamma>' 0) (TER\\<^bsub>\\<Gamma>' 0\\<^esub> (g' n))", "unfolding TER_g'"], ["proof (prove)\nusing this:\n  separating (\\<Gamma>' 0) (TER\\<^bsub>\\<Gamma>' 0\\<^esub> (g' n))\n\ngoal (1 subgoal):\n 1. separating (\\<Gamma>' 0) (TER\\<^bsub>\\<Gamma>' 0\\<^esub> (g' n))", "."], ["proof (state)\nthis:\n  separating (\\<Gamma>' 0) (TER\\<^bsub>\\<Gamma>' 0\\<^esub> (g' n))\n\ngoal (1 subgoal):\n 1. current (\\<Gamma>' 0) (g' n)", "qed(rule g')"], ["proof (state)\nthis:\n  wave (\\<Gamma>' 0) (g' ?n)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>\\<epsilon>>0.\n               \\<epsilon> < \\<delta> \\<and>\n               \\<not> hindered\n                       (reduce_weight \\<Gamma> b\n                         \\<epsilon>)) \\<Longrightarrow>\n    False", "define f where \"f = rec_nat (g 0) (\\<lambda>n rec. rec \\<frown>\\<^bsub>\\<Gamma>' 0\\<^esub> g' (n + 1))\""], ["proof (state)\nthis:\n  f =\n  rec_nat (g 0)\n   (\\<lambda>n rec. rec \\<frown>\\<^bsub>\\<Gamma>' 0\\<^esub> g' (n + 1))\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>\\<epsilon>>0.\n               \\<epsilon> < \\<delta> \\<and>\n               \\<not> hindered\n                       (reduce_weight \\<Gamma> b\n                         \\<epsilon>)) \\<Longrightarrow>\n    False", "have f_simps [simp]:\n    \"f 0 = g 0\"\n    \"f (Suc n) = f n \\<frown>\\<^bsub>\\<Gamma>' 0\\<^esub> g' (n + 1)\"\n    for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. f 0 = g 0 &&&\n    f (Suc n) = f n \\<frown>\\<^bsub>\\<Gamma>' 0\\<^esub> g' (n + 1)", "by(simp_all add: f_def)"], ["proof (state)\nthis:\n  f 0 = g 0\n  f (Suc ?n) = f ?n \\<frown>\\<^bsub>\\<Gamma>' 0\\<^esub> g' (?n + 1)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>\\<epsilon>>0.\n               \\<epsilon> < \\<delta> \\<and>\n               \\<not> hindered\n                       (reduce_weight \\<Gamma> b\n                         \\<epsilon>)) \\<Longrightarrow>\n    False", "have f: \"current (\\<Gamma>' 0) (f n)\" and fw: \"wave (\\<Gamma>' 0) (f n)\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. current (\\<Gamma>' 0) (f n) &&& wave (\\<Gamma>' 0) (f n)", "proof(induction n)"], ["proof (state)\ngoal (4 subgoals):\n 1. current (\\<Gamma>' 0) (f 0)\n 2. wave (\\<Gamma>' 0) (f 0)\n 3. \\<And>n.\n       \\<lbrakk>current (\\<Gamma>' 0) (f n);\n        wave (\\<Gamma>' 0) (f n)\\<rbrakk>\n       \\<Longrightarrow> current (\\<Gamma>' 0) (f (Suc n))\n 4. \\<And>n.\n       \\<lbrakk>current (\\<Gamma>' 0) (f n);\n        wave (\\<Gamma>' 0) (f n)\\<rbrakk>\n       \\<Longrightarrow> wave (\\<Gamma>' 0) (f (Suc n))", "case (Suc n)"], ["proof (state)\nthis:\n  current (\\<Gamma>' 0) (f n)\n  wave (\\<Gamma>' 0) (f n)\n\ngoal (4 subgoals):\n 1. current (\\<Gamma>' 0) (f 0)\n 2. wave (\\<Gamma>' 0) (f 0)\n 3. \\<And>n.\n       \\<lbrakk>current (\\<Gamma>' 0) (f n);\n        wave (\\<Gamma>' 0) (f n)\\<rbrakk>\n       \\<Longrightarrow> current (\\<Gamma>' 0) (f (Suc n))\n 4. \\<And>n.\n       \\<lbrakk>current (\\<Gamma>' 0) (f n);\n        wave (\\<Gamma>' 0) (f n)\\<rbrakk>\n       \\<Longrightarrow> wave (\\<Gamma>' 0) (f (Suc n))", "{"], ["proof (state)\nthis:\n  current (\\<Gamma>' 0) (f n)\n  wave (\\<Gamma>' 0) (f n)\n\ngoal (4 subgoals):\n 1. current (\\<Gamma>' 0) (f 0)\n 2. wave (\\<Gamma>' 0) (f 0)\n 3. \\<And>n.\n       \\<lbrakk>current (\\<Gamma>' 0) (f n);\n        wave (\\<Gamma>' 0) (f n)\\<rbrakk>\n       \\<Longrightarrow> current (\\<Gamma>' 0) (f (Suc n))\n 4. \\<And>n.\n       \\<lbrakk>current (\\<Gamma>' 0) (f n);\n        wave (\\<Gamma>' 0) (f n)\\<rbrakk>\n       \\<Longrightarrow> wave (\\<Gamma>' 0) (f (Suc n))", "case 1"], ["proof (state)\nthis:\n  \n\ngoal (4 subgoals):\n 1. current (\\<Gamma>' 0) (f 0)\n 2. wave (\\<Gamma>' 0) (f 0)\n 3. \\<And>n.\n       \\<lbrakk>current (\\<Gamma>' 0) (f n);\n        wave (\\<Gamma>' 0) (f n)\\<rbrakk>\n       \\<Longrightarrow> current (\\<Gamma>' 0) (f (Suc n))\n 4. \\<And>n.\n       \\<lbrakk>current (\\<Gamma>' 0) (f n);\n        wave (\\<Gamma>' 0) (f n)\\<rbrakk>\n       \\<Longrightarrow> wave (\\<Gamma>' 0) (f (Suc n))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. current (\\<Gamma>' 0) (f (Suc n))", "unfolding f_simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. current (\\<Gamma>' 0)\n     (f n \\<frown>\\<^bsub>\\<Gamma>' 0\\<^esub> g' (n + 1))", "using Suc.IH g'"], ["proof (prove)\nusing this:\n  current (\\<Gamma>' 0) (f n)\n  wave (\\<Gamma>' 0) (f n)\n  current (\\<Gamma>' 0) (g' ?n)\n\ngoal (1 subgoal):\n 1. current (\\<Gamma>' 0)\n     (f n \\<frown>\\<^bsub>\\<Gamma>' 0\\<^esub> g' (n + 1))", "by(rule current_plus_web)"], ["proof (state)\nthis:\n  current (\\<Gamma>' 0) (f (Suc n))\n\ngoal (3 subgoals):\n 1. current (\\<Gamma>' 0) (f 0)\n 2. wave (\\<Gamma>' 0) (f 0)\n 3. \\<And>n.\n       \\<lbrakk>current (\\<Gamma>' 0) (f n);\n        wave (\\<Gamma>' 0) (f n)\\<rbrakk>\n       \\<Longrightarrow> wave (\\<Gamma>' 0) (f (Suc n))", "}"], ["proof (state)\nthis:\n  current (\\<Gamma>' 0) (f (Suc n))\n\ngoal (3 subgoals):\n 1. current (\\<Gamma>' 0) (f 0)\n 2. wave (\\<Gamma>' 0) (f 0)\n 3. \\<And>n.\n       \\<lbrakk>current (\\<Gamma>' 0) (f n);\n        wave (\\<Gamma>' 0) (f n)\\<rbrakk>\n       \\<Longrightarrow> wave (\\<Gamma>' 0) (f (Suc n))", "{"], ["proof (state)\nthis:\n  current (\\<Gamma>' 0) (f (Suc n))\n\ngoal (3 subgoals):\n 1. current (\\<Gamma>' 0) (f 0)\n 2. wave (\\<Gamma>' 0) (f 0)\n 3. \\<And>n.\n       \\<lbrakk>current (\\<Gamma>' 0) (f n);\n        wave (\\<Gamma>' 0) (f n)\\<rbrakk>\n       \\<Longrightarrow> wave (\\<Gamma>' 0) (f (Suc n))", "case 2"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. current (\\<Gamma>' 0) (f 0)\n 2. wave (\\<Gamma>' 0) (f 0)\n 3. \\<And>n.\n       \\<lbrakk>current (\\<Gamma>' 0) (f n);\n        wave (\\<Gamma>' 0) (f n)\\<rbrakk>\n       \\<Longrightarrow> wave (\\<Gamma>' 0) (f (Suc n))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. wave (\\<Gamma>' 0) (f (Suc n))", "unfolding f_simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. wave (\\<Gamma>' 0) (f n \\<frown>\\<^bsub>\\<Gamma>' 0\\<^esub> g' (n + 1))", "using Suc.IH g' w'"], ["proof (prove)\nusing this:\n  current (\\<Gamma>' 0) (f n)\n  wave (\\<Gamma>' 0) (f n)\n  current (\\<Gamma>' 0) (g' ?n)\n  wave (\\<Gamma>' 0) (g' ?n)\n\ngoal (1 subgoal):\n 1. wave (\\<Gamma>' 0) (f n \\<frown>\\<^bsub>\\<Gamma>' 0\\<^esub> g' (n + 1))", "by(rule wave_plus')"], ["proof (state)\nthis:\n  wave (\\<Gamma>' 0) (f (Suc n))\n\ngoal (2 subgoals):\n 1. current (\\<Gamma>' 0) (f 0)\n 2. wave (\\<Gamma>' 0) (f 0)", "}"], ["proof (state)\nthis:\n  wave (\\<Gamma>' 0) (f (Suc n))\n\ngoal (2 subgoals):\n 1. current (\\<Gamma>' 0) (f 0)\n 2. wave (\\<Gamma>' 0) (f 0)", "qed(simp_all add: g w)"], ["proof (state)\nthis:\n  current (\\<Gamma>' 0) (f ?n)\n  wave (\\<Gamma>' 0) (f ?n)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>\\<epsilon>>0.\n               \\<epsilon> < \\<delta> \\<and>\n               \\<not> hindered\n                       (reduce_weight \\<Gamma> b\n                         \\<epsilon>)) \\<Longrightarrow>\n    False", "have f_inc: \"n \\<le> m \\<Longrightarrow> f n \\<le> f m\" for n m"], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<le> m \\<Longrightarrow> f n \\<le> f m", "proof(induction m rule: dec_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. f n \\<le> f n\n 2. \\<And>n.\n       \\<lbrakk>n \\<le> n; n < m; f n \\<le> f n\\<rbrakk>\n       \\<Longrightarrow> f n \\<le> f (Suc n)", "case (step k)"], ["proof (state)\nthis:\n  n \\<le> k\n  k < m\n  f n \\<le> f k\n\ngoal (2 subgoals):\n 1. f n \\<le> f n\n 2. \\<And>n.\n       \\<lbrakk>n \\<le> n; n < m; f n \\<le> f n\\<rbrakk>\n       \\<Longrightarrow> f n \\<le> f (Suc n)", "note step.IH"], ["proof (state)\nthis:\n  f n \\<le> f k\n\ngoal (2 subgoals):\n 1. f n \\<le> f n\n 2. \\<And>n.\n       \\<lbrakk>n \\<le> n; n < m; f n \\<le> f n\\<rbrakk>\n       \\<Longrightarrow> f n \\<le> f (Suc n)", "also"], ["proof (state)\nthis:\n  f n \\<le> f k\n\ngoal (2 subgoals):\n 1. f n \\<le> f n\n 2. \\<And>n.\n       \\<lbrakk>n \\<le> n; n < m; f n \\<le> f n\\<rbrakk>\n       \\<Longrightarrow> f n \\<le> f (Suc n)", "have \"f k \\<le> (f k \\<frown>\\<^bsub>\\<Gamma>' 0\\<^esub> g' (k + 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f k \\<le> f k \\<frown>\\<^bsub>\\<Gamma>' 0\\<^esub> g' (k + 1)", "by(rule le_funI plus_web_greater)+"], ["proof (state)\nthis:\n  f k \\<le> f k \\<frown>\\<^bsub>\\<Gamma>' 0\\<^esub> g' (k + 1)\n\ngoal (2 subgoals):\n 1. f n \\<le> f n\n 2. \\<And>n.\n       \\<lbrakk>n \\<le> n; n < m; f n \\<le> f n\\<rbrakk>\n       \\<Longrightarrow> f n \\<le> f (Suc n)", "also"], ["proof (state)\nthis:\n  f k \\<le> f k \\<frown>\\<^bsub>\\<Gamma>' 0\\<^esub> g' (k + 1)\n\ngoal (2 subgoals):\n 1. f n \\<le> f n\n 2. \\<And>n.\n       \\<lbrakk>n \\<le> n; n < m; f n \\<le> f n\\<rbrakk>\n       \\<Longrightarrow> f n \\<le> f (Suc n)", "have \"\\<dots> = f (Suc k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f k \\<frown>\\<^bsub>\\<Gamma>' 0\\<^esub> g' (k + 1) = f (Suc k)", "by simp"], ["proof (state)\nthis:\n  f k \\<frown>\\<^bsub>\\<Gamma>' 0\\<^esub> g' (k + 1) = f (Suc k)\n\ngoal (2 subgoals):\n 1. f n \\<le> f n\n 2. \\<And>n.\n       \\<lbrakk>n \\<le> n; n < m; f n \\<le> f n\\<rbrakk>\n       \\<Longrightarrow> f n \\<le> f (Suc n)", "finally"], ["proof (chain)\npicking this:\n  f n \\<le> f (Suc k)", "show ?case"], ["proof (prove)\nusing this:\n  f n \\<le> f (Suc k)\n\ngoal (1 subgoal):\n 1. f n \\<le> f (Suc k)", "."], ["proof (state)\nthis:\n  f n \\<le> f (Suc k)\n\ngoal (1 subgoal):\n 1. f n \\<le> f n", "qed simp"], ["proof (state)\nthis:\n  ?n \\<le> ?m \\<Longrightarrow> f ?n \\<le> f ?m\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>\\<epsilon>>0.\n               \\<epsilon> < \\<delta> \\<and>\n               \\<not> hindered\n                       (reduce_weight \\<Gamma> b\n                         \\<epsilon>)) \\<Longrightarrow>\n    False", "have chain_f: \"Complete_Partial_Order.chain (\\<le>) (range f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Complete_Partial_Order.chain (\\<le>) (range f)", "by(rule chain_imageI[where le_a=\"(\\<le>)\"])(simp_all add: f_inc)"], ["proof (state)\nthis:\n  Complete_Partial_Order.chain (\\<le>) (range f)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>\\<epsilon>>0.\n               \\<epsilon> < \\<delta> \\<and>\n               \\<not> hindered\n                       (reduce_weight \\<Gamma> b\n                         \\<epsilon>)) \\<Longrightarrow>\n    False", "have \"countable (support_flow (f n))\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. countable (support_flow (f n))", "using current_support_flow[OF f, of n]"], ["proof (prove)\nusing this:\n  support_flow (f n) \\<subseteq> \\<^bold>E\\<^bsub>\\<Gamma>' 0\\<^esub>\n\ngoal (1 subgoal):\n 1. countable (support_flow (f n))", "by(rule countable_subset) simp"], ["proof (state)\nthis:\n  countable (support_flow (f ?n))\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>\\<epsilon>>0.\n               \\<epsilon> < \\<delta> \\<and>\n               \\<not> hindered\n                       (reduce_weight \\<Gamma> b\n                         \\<epsilon>)) \\<Longrightarrow>\n    False", "hence supp_f: \"countable (support_flow (SUP n. f n))\""], ["proof (prove)\nusing this:\n  countable (support_flow (f ?n))\n\ngoal (1 subgoal):\n 1. countable (support_flow (\\<Squnion> range f))", "by(subst support_flow_Sup)simp"], ["proof (state)\nthis:\n  countable (support_flow (\\<Squnion> range f))\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>\\<epsilon>>0.\n               \\<epsilon> < \\<delta> \\<and>\n               \\<not> hindered\n                       (reduce_weight \\<Gamma> b\n                         \\<epsilon>)) \\<Longrightarrow>\n    False", "have RF_f: \"RF (TER\\<^bsub>\\<Gamma>' 0\\<^esub> (f n)) = RF (\\<Union>i\\<le>n. TER\\<^bsub>\\<Gamma>' 0\\<^esub> (g' i))\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. RF (TER\\<^bsub>\\<Gamma>' 0\\<^esub> (f n)) =\n    RF (\\<Union>i\\<le>n. TER\\<^bsub>\\<Gamma>' 0\\<^esub> (g' i))", "proof(induction n)"], ["proof (state)\ngoal (2 subgoals):\n 1. RF (TER\\<^bsub>\\<Gamma>' 0\\<^esub> (f 0)) =\n    RF (\\<Union>i\\<le>0. TER\\<^bsub>\\<Gamma>' 0\\<^esub> (g' i))\n 2. \\<And>n.\n       RF (TER\\<^bsub>\\<Gamma>' 0\\<^esub> (f n)) =\n       RF (\\<Union>i\\<le>n.\n              TER\\<^bsub>\\<Gamma>' 0\\<^esub> (g' i)) \\<Longrightarrow>\n       RF (TER\\<^bsub>\\<Gamma>' 0\\<^esub> (f (Suc n))) =\n       RF (\\<Union>i\\<le>Suc n. TER\\<^bsub>\\<Gamma>' 0\\<^esub> (g' i))", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. RF (TER\\<^bsub>\\<Gamma>' 0\\<^esub> (f 0)) =\n    RF (\\<Union>i\\<le>0. TER\\<^bsub>\\<Gamma>' 0\\<^esub> (g' i))\n 2. \\<And>n.\n       RF (TER\\<^bsub>\\<Gamma>' 0\\<^esub> (f n)) =\n       RF (\\<Union>i\\<le>n.\n              TER\\<^bsub>\\<Gamma>' 0\\<^esub> (g' i)) \\<Longrightarrow>\n       RF (TER\\<^bsub>\\<Gamma>' 0\\<^esub> (f (Suc n))) =\n       RF (\\<Union>i\\<le>Suc n. TER\\<^bsub>\\<Gamma>' 0\\<^esub> (g' i))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. RF (TER\\<^bsub>\\<Gamma>' 0\\<^esub> (f 0)) =\n    RF (\\<Union>i\\<le>0. TER\\<^bsub>\\<Gamma>' 0\\<^esub> (g' i))", "by(simp add: TER_g')"], ["proof (state)\nthis:\n  RF (TER\\<^bsub>\\<Gamma>' 0\\<^esub> (f 0)) =\n  RF (\\<Union>i\\<le>0. TER\\<^bsub>\\<Gamma>' 0\\<^esub> (g' i))\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       RF (TER\\<^bsub>\\<Gamma>' 0\\<^esub> (f n)) =\n       RF (\\<Union>i\\<le>n.\n              TER\\<^bsub>\\<Gamma>' 0\\<^esub> (g' i)) \\<Longrightarrow>\n       RF (TER\\<^bsub>\\<Gamma>' 0\\<^esub> (f (Suc n))) =\n       RF (\\<Union>i\\<le>Suc n. TER\\<^bsub>\\<Gamma>' 0\\<^esub> (g' i))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       RF (TER\\<^bsub>\\<Gamma>' 0\\<^esub> (f n)) =\n       RF (\\<Union>i\\<le>n.\n              TER\\<^bsub>\\<Gamma>' 0\\<^esub> (g' i)) \\<Longrightarrow>\n       RF (TER\\<^bsub>\\<Gamma>' 0\\<^esub> (f (Suc n))) =\n       RF (\\<Union>i\\<le>Suc n. TER\\<^bsub>\\<Gamma>' 0\\<^esub> (g' i))", "case (Suc n)"], ["proof (state)\nthis:\n  RF (TER\\<^bsub>\\<Gamma>' 0\\<^esub> (f n)) =\n  RF (\\<Union>i\\<le>n. TER\\<^bsub>\\<Gamma>' 0\\<^esub> (g' i))\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       RF (TER\\<^bsub>\\<Gamma>' 0\\<^esub> (f n)) =\n       RF (\\<Union>i\\<le>n.\n              TER\\<^bsub>\\<Gamma>' 0\\<^esub> (g' i)) \\<Longrightarrow>\n       RF (TER\\<^bsub>\\<Gamma>' 0\\<^esub> (f (Suc n))) =\n       RF (\\<Union>i\\<le>Suc n. TER\\<^bsub>\\<Gamma>' 0\\<^esub> (g' i))", "have \"RF (TER\\<^bsub>\\<Gamma>' 0\\<^esub> (f (Suc n))) = RF\\<^bsub>\\<Gamma>' 0\\<^esub> (TER\\<^bsub>\\<Gamma>' 0\\<^esub> (f n \\<frown>\\<^bsub>\\<Gamma>' 0\\<^esub> g' (n + 1)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RF (TER\\<^bsub>\\<Gamma>' 0\\<^esub> (f (Suc n))) =\n    RF\\<^bsub>\\<Gamma>' 0\\<^esub>\n     (TER\\<^bsub>\\<Gamma>' 0\\<^esub>\n       (f n \\<frown>\\<^bsub>\\<Gamma>' 0\\<^esub> g' (n + 1)))", "by simp"], ["proof (state)\nthis:\n  RF (TER\\<^bsub>\\<Gamma>' 0\\<^esub> (f (Suc n))) =\n  RF\\<^bsub>\\<Gamma>' 0\\<^esub>\n   (TER\\<^bsub>\\<Gamma>' 0\\<^esub>\n     (f n \\<frown>\\<^bsub>\\<Gamma>' 0\\<^esub> g' (n + 1)))\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       RF (TER\\<^bsub>\\<Gamma>' 0\\<^esub> (f n)) =\n       RF (\\<Union>i\\<le>n.\n              TER\\<^bsub>\\<Gamma>' 0\\<^esub> (g' i)) \\<Longrightarrow>\n       RF (TER\\<^bsub>\\<Gamma>' 0\\<^esub> (f (Suc n))) =\n       RF (\\<Union>i\\<le>Suc n. TER\\<^bsub>\\<Gamma>' 0\\<^esub> (g' i))", "also"], ["proof (state)\nthis:\n  RF (TER\\<^bsub>\\<Gamma>' 0\\<^esub> (f (Suc n))) =\n  RF\\<^bsub>\\<Gamma>' 0\\<^esub>\n   (TER\\<^bsub>\\<Gamma>' 0\\<^esub>\n     (f n \\<frown>\\<^bsub>\\<Gamma>' 0\\<^esub> g' (n + 1)))\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       RF (TER\\<^bsub>\\<Gamma>' 0\\<^esub> (f n)) =\n       RF (\\<Union>i\\<le>n.\n              TER\\<^bsub>\\<Gamma>' 0\\<^esub> (g' i)) \\<Longrightarrow>\n       RF (TER\\<^bsub>\\<Gamma>' 0\\<^esub> (f (Suc n))) =\n       RF (\\<Union>i\\<le>Suc n. TER\\<^bsub>\\<Gamma>' 0\\<^esub> (g' i))", "have \"\\<dots> = RF\\<^bsub>\\<Gamma>' 0\\<^esub> (TER\\<^bsub>\\<Gamma>' 0\\<^esub> (f n) \\<union> TER\\<^bsub>\\<Gamma>' 0\\<^esub> (g' (n + 1)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RF\\<^bsub>\\<Gamma>' 0\\<^esub>\n     (TER\\<^bsub>\\<Gamma>' 0\\<^esub>\n       (f n \\<frown>\\<^bsub>\\<Gamma>' 0\\<^esub> g' (n + 1))) =\n    RF\\<^bsub>\\<Gamma>' 0\\<^esub>\n     (TER\\<^bsub>\\<Gamma>' 0\\<^esub> (f n) \\<union>\n      TER\\<^bsub>\\<Gamma>' 0\\<^esub> (g' (n + 1)))", "using f fw g' w'"], ["proof (prove)\nusing this:\n  current (\\<Gamma>' 0) (f ?n)\n  wave (\\<Gamma>' 0) (f ?n)\n  current (\\<Gamma>' 0) (g' ?n)\n  wave (\\<Gamma>' 0) (g' ?n)\n\ngoal (1 subgoal):\n 1. RF\\<^bsub>\\<Gamma>' 0\\<^esub>\n     (TER\\<^bsub>\\<Gamma>' 0\\<^esub>\n       (f n \\<frown>\\<^bsub>\\<Gamma>' 0\\<^esub> g' (n + 1))) =\n    RF\\<^bsub>\\<Gamma>' 0\\<^esub>\n     (TER\\<^bsub>\\<Gamma>' 0\\<^esub> (f n) \\<union>\n      TER\\<^bsub>\\<Gamma>' 0\\<^esub> (g' (n + 1)))", "by(rule RF_TER_plus_web)"], ["proof (state)\nthis:\n  RF\\<^bsub>\\<Gamma>' 0\\<^esub>\n   (TER\\<^bsub>\\<Gamma>' 0\\<^esub>\n     (f n \\<frown>\\<^bsub>\\<Gamma>' 0\\<^esub> g' (n + 1))) =\n  RF\\<^bsub>\\<Gamma>' 0\\<^esub>\n   (TER\\<^bsub>\\<Gamma>' 0\\<^esub> (f n) \\<union>\n    TER\\<^bsub>\\<Gamma>' 0\\<^esub> (g' (n + 1)))\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       RF (TER\\<^bsub>\\<Gamma>' 0\\<^esub> (f n)) =\n       RF (\\<Union>i\\<le>n.\n              TER\\<^bsub>\\<Gamma>' 0\\<^esub> (g' i)) \\<Longrightarrow>\n       RF (TER\\<^bsub>\\<Gamma>' 0\\<^esub> (f (Suc n))) =\n       RF (\\<Union>i\\<le>Suc n. TER\\<^bsub>\\<Gamma>' 0\\<^esub> (g' i))", "also"], ["proof (state)\nthis:\n  RF\\<^bsub>\\<Gamma>' 0\\<^esub>\n   (TER\\<^bsub>\\<Gamma>' 0\\<^esub>\n     (f n \\<frown>\\<^bsub>\\<Gamma>' 0\\<^esub> g' (n + 1))) =\n  RF\\<^bsub>\\<Gamma>' 0\\<^esub>\n   (TER\\<^bsub>\\<Gamma>' 0\\<^esub> (f n) \\<union>\n    TER\\<^bsub>\\<Gamma>' 0\\<^esub> (g' (n + 1)))\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       RF (TER\\<^bsub>\\<Gamma>' 0\\<^esub> (f n)) =\n       RF (\\<Union>i\\<le>n.\n              TER\\<^bsub>\\<Gamma>' 0\\<^esub> (g' i)) \\<Longrightarrow>\n       RF (TER\\<^bsub>\\<Gamma>' 0\\<^esub> (f (Suc n))) =\n       RF (\\<Union>i\\<le>Suc n. TER\\<^bsub>\\<Gamma>' 0\\<^esub> (g' i))", "have \"\\<dots> = RF\\<^bsub>\\<Gamma>' 0\\<^esub> (RF\\<^bsub>\\<Gamma>' 0\\<^esub> (TER\\<^bsub>\\<Gamma>' 0\\<^esub> (f n)) \\<union> TER\\<^bsub>\\<Gamma>' 0\\<^esub> (g' (n + 1)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RF\\<^bsub>\\<Gamma>' 0\\<^esub>\n     (TER\\<^bsub>\\<Gamma>' 0\\<^esub> (f n) \\<union>\n      TER\\<^bsub>\\<Gamma>' 0\\<^esub> (g' (n + 1))) =\n    RF\\<^bsub>\\<Gamma>' 0\\<^esub>\n     (RF\\<^bsub>\\<Gamma>' 0\\<^esub>\n       (TER\\<^bsub>\\<Gamma>' 0\\<^esub> (f n)) \\<union>\n      TER\\<^bsub>\\<Gamma>' 0\\<^esub> (g' (n + 1)))", "by(simp add: roofed_idem_Un1)"], ["proof (state)\nthis:\n  RF\\<^bsub>\\<Gamma>' 0\\<^esub>\n   (TER\\<^bsub>\\<Gamma>' 0\\<^esub> (f n) \\<union>\n    TER\\<^bsub>\\<Gamma>' 0\\<^esub> (g' (n + 1))) =\n  RF\\<^bsub>\\<Gamma>' 0\\<^esub>\n   (RF\\<^bsub>\\<Gamma>' 0\\<^esub>\n     (TER\\<^bsub>\\<Gamma>' 0\\<^esub> (f n)) \\<union>\n    TER\\<^bsub>\\<Gamma>' 0\\<^esub> (g' (n + 1)))\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       RF (TER\\<^bsub>\\<Gamma>' 0\\<^esub> (f n)) =\n       RF (\\<Union>i\\<le>n.\n              TER\\<^bsub>\\<Gamma>' 0\\<^esub> (g' i)) \\<Longrightarrow>\n       RF (TER\\<^bsub>\\<Gamma>' 0\\<^esub> (f (Suc n))) =\n       RF (\\<Union>i\\<le>Suc n. TER\\<^bsub>\\<Gamma>' 0\\<^esub> (g' i))", "also"], ["proof (state)\nthis:\n  RF\\<^bsub>\\<Gamma>' 0\\<^esub>\n   (TER\\<^bsub>\\<Gamma>' 0\\<^esub> (f n) \\<union>\n    TER\\<^bsub>\\<Gamma>' 0\\<^esub> (g' (n + 1))) =\n  RF\\<^bsub>\\<Gamma>' 0\\<^esub>\n   (RF\\<^bsub>\\<Gamma>' 0\\<^esub>\n     (TER\\<^bsub>\\<Gamma>' 0\\<^esub> (f n)) \\<union>\n    TER\\<^bsub>\\<Gamma>' 0\\<^esub> (g' (n + 1)))\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       RF (TER\\<^bsub>\\<Gamma>' 0\\<^esub> (f n)) =\n       RF (\\<Union>i\\<le>n.\n              TER\\<^bsub>\\<Gamma>' 0\\<^esub> (g' i)) \\<Longrightarrow>\n       RF (TER\\<^bsub>\\<Gamma>' 0\\<^esub> (f (Suc n))) =\n       RF (\\<Union>i\\<le>Suc n. TER\\<^bsub>\\<Gamma>' 0\\<^esub> (g' i))", "have \"RF\\<^bsub>\\<Gamma>' 0\\<^esub> (TER\\<^bsub>\\<Gamma>' 0\\<^esub> (f n)) = RF\\<^bsub>\\<Gamma>' 0\\<^esub> (\\<Union>i\\<le>n. TER\\<^bsub>\\<Gamma>' 0\\<^esub> (g' i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RF\\<^bsub>\\<Gamma>' 0\\<^esub> (TER\\<^bsub>\\<Gamma>' 0\\<^esub> (f n)) =\n    RF\\<^bsub>\\<Gamma>' 0\\<^esub>\n     (\\<Union>i\\<le>n. TER\\<^bsub>\\<Gamma>' 0\\<^esub> (g' i))", "by(simp add: Suc.IH)"], ["proof (state)\nthis:\n  RF\\<^bsub>\\<Gamma>' 0\\<^esub> (TER\\<^bsub>\\<Gamma>' 0\\<^esub> (f n)) =\n  RF\\<^bsub>\\<Gamma>' 0\\<^esub>\n   (\\<Union>i\\<le>n. TER\\<^bsub>\\<Gamma>' 0\\<^esub> (g' i))\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       RF (TER\\<^bsub>\\<Gamma>' 0\\<^esub> (f n)) =\n       RF (\\<Union>i\\<le>n.\n              TER\\<^bsub>\\<Gamma>' 0\\<^esub> (g' i)) \\<Longrightarrow>\n       RF (TER\\<^bsub>\\<Gamma>' 0\\<^esub> (f (Suc n))) =\n       RF (\\<Union>i\\<le>Suc n. TER\\<^bsub>\\<Gamma>' 0\\<^esub> (g' i))", "also"], ["proof (state)\nthis:\n  RF\\<^bsub>\\<Gamma>' 0\\<^esub> (TER\\<^bsub>\\<Gamma>' 0\\<^esub> (f n)) =\n  RF\\<^bsub>\\<Gamma>' 0\\<^esub>\n   (\\<Union>i\\<le>n. TER\\<^bsub>\\<Gamma>' 0\\<^esub> (g' i))\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       RF (TER\\<^bsub>\\<Gamma>' 0\\<^esub> (f n)) =\n       RF (\\<Union>i\\<le>n.\n              TER\\<^bsub>\\<Gamma>' 0\\<^esub> (g' i)) \\<Longrightarrow>\n       RF (TER\\<^bsub>\\<Gamma>' 0\\<^esub> (f (Suc n))) =\n       RF (\\<Union>i\\<le>Suc n. TER\\<^bsub>\\<Gamma>' 0\\<^esub> (g' i))", "have \"RF\\<^bsub>\\<Gamma>' 0\\<^esub> (\\<dots> \\<union> TER\\<^bsub>\\<Gamma>' 0\\<^esub> (g' (n + 1))) = RF\\<^bsub>\\<Gamma>' 0\\<^esub> ((\\<Union>i\\<le>n. TER\\<^bsub>\\<Gamma>' 0\\<^esub> (g' i)) \\<union> TER\\<^bsub>\\<Gamma>' 0\\<^esub> (g' (n + 1)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RF\\<^bsub>\\<Gamma>' 0\\<^esub>\n     (RF\\<^bsub>\\<Gamma>' 0\\<^esub>\n       (\\<Union>i\\<le>n. TER\\<^bsub>\\<Gamma>' 0\\<^esub> (g' i)) \\<union>\n      TER\\<^bsub>\\<Gamma>' 0\\<^esub> (g' (n + 1))) =\n    RF\\<^bsub>\\<Gamma>' 0\\<^esub>\n     ((\\<Union>i\\<le>n. TER\\<^bsub>\\<Gamma>' 0\\<^esub> (g' i)) \\<union>\n      TER\\<^bsub>\\<Gamma>' 0\\<^esub> (g' (n + 1)))", "by(simp add: roofed_idem_Un1)"], ["proof (state)\nthis:\n  RF\\<^bsub>\\<Gamma>' 0\\<^esub>\n   (RF\\<^bsub>\\<Gamma>' 0\\<^esub>\n     (\\<Union>i\\<le>n. TER\\<^bsub>\\<Gamma>' 0\\<^esub> (g' i)) \\<union>\n    TER\\<^bsub>\\<Gamma>' 0\\<^esub> (g' (n + 1))) =\n  RF\\<^bsub>\\<Gamma>' 0\\<^esub>\n   ((\\<Union>i\\<le>n. TER\\<^bsub>\\<Gamma>' 0\\<^esub> (g' i)) \\<union>\n    TER\\<^bsub>\\<Gamma>' 0\\<^esub> (g' (n + 1)))\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       RF (TER\\<^bsub>\\<Gamma>' 0\\<^esub> (f n)) =\n       RF (\\<Union>i\\<le>n.\n              TER\\<^bsub>\\<Gamma>' 0\\<^esub> (g' i)) \\<Longrightarrow>\n       RF (TER\\<^bsub>\\<Gamma>' 0\\<^esub> (f (Suc n))) =\n       RF (\\<Union>i\\<le>Suc n. TER\\<^bsub>\\<Gamma>' 0\\<^esub> (g' i))", "also"], ["proof (state)\nthis:\n  RF\\<^bsub>\\<Gamma>' 0\\<^esub>\n   (RF\\<^bsub>\\<Gamma>' 0\\<^esub>\n     (\\<Union>i\\<le>n. TER\\<^bsub>\\<Gamma>' 0\\<^esub> (g' i)) \\<union>\n    TER\\<^bsub>\\<Gamma>' 0\\<^esub> (g' (n + 1))) =\n  RF\\<^bsub>\\<Gamma>' 0\\<^esub>\n   ((\\<Union>i\\<le>n. TER\\<^bsub>\\<Gamma>' 0\\<^esub> (g' i)) \\<union>\n    TER\\<^bsub>\\<Gamma>' 0\\<^esub> (g' (n + 1)))\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       RF (TER\\<^bsub>\\<Gamma>' 0\\<^esub> (f n)) =\n       RF (\\<Union>i\\<le>n.\n              TER\\<^bsub>\\<Gamma>' 0\\<^esub> (g' i)) \\<Longrightarrow>\n       RF (TER\\<^bsub>\\<Gamma>' 0\\<^esub> (f (Suc n))) =\n       RF (\\<Union>i\\<le>Suc n. TER\\<^bsub>\\<Gamma>' 0\\<^esub> (g' i))", "have \"(\\<Union>i\\<le>n. TER\\<^bsub>\\<Gamma>' 0\\<^esub> (g' i)) \\<union> TER\\<^bsub>\\<Gamma>' 0\\<^esub> (g' (n + 1)) = (\\<Union>i\\<le>Suc n. TER\\<^bsub>\\<Gamma>' 0\\<^esub> (g' i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>i\\<le>n. TER\\<^bsub>\\<Gamma>' 0\\<^esub> (g' i)) \\<union>\n    TER\\<^bsub>\\<Gamma>' 0\\<^esub> (g' (n + 1)) =\n    (\\<Union>i\\<le>Suc n. TER\\<^bsub>\\<Gamma>' 0\\<^esub> (g' i))", "unfolding atMost_Suc UN_insert"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>i\\<le>n. TER\\<^bsub>\\<Gamma>' 0\\<^esub> (g' i)) \\<union>\n    TER\\<^bsub>\\<Gamma>' 0\\<^esub> (g' (n + 1)) =\n    TER\\<^bsub>\\<Gamma>' 0\\<^esub> (g' (Suc n)) \\<union>\n    (\\<Union>i\\<le>n. TER\\<^bsub>\\<Gamma>' 0\\<^esub> (g' i))", "by(simp add: Un_commute)"], ["proof (state)\nthis:\n  (\\<Union>i\\<le>n. TER\\<^bsub>\\<Gamma>' 0\\<^esub> (g' i)) \\<union>\n  TER\\<^bsub>\\<Gamma>' 0\\<^esub> (g' (n + 1)) =\n  (\\<Union>i\\<le>Suc n. TER\\<^bsub>\\<Gamma>' 0\\<^esub> (g' i))\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       RF (TER\\<^bsub>\\<Gamma>' 0\\<^esub> (f n)) =\n       RF (\\<Union>i\\<le>n.\n              TER\\<^bsub>\\<Gamma>' 0\\<^esub> (g' i)) \\<Longrightarrow>\n       RF (TER\\<^bsub>\\<Gamma>' 0\\<^esub> (f (Suc n))) =\n       RF (\\<Union>i\\<le>Suc n. TER\\<^bsub>\\<Gamma>' 0\\<^esub> (g' i))", "finally"], ["proof (chain)\npicking this:\n  RF (TER\\<^bsub>\\<Gamma>' 0\\<^esub> (f (Suc n))) =\n  RF\\<^bsub>\\<Gamma>' 0\\<^esub>\n   (\\<Union>i\\<le>Suc n. TER\\<^bsub>\\<Gamma>' 0\\<^esub> (g' i))", "show ?case"], ["proof (prove)\nusing this:\n  RF (TER\\<^bsub>\\<Gamma>' 0\\<^esub> (f (Suc n))) =\n  RF\\<^bsub>\\<Gamma>' 0\\<^esub>\n   (\\<Union>i\\<le>Suc n. TER\\<^bsub>\\<Gamma>' 0\\<^esub> (g' i))\n\ngoal (1 subgoal):\n 1. RF (TER\\<^bsub>\\<Gamma>' 0\\<^esub> (f (Suc n))) =\n    RF (\\<Union>i\\<le>Suc n. TER\\<^bsub>\\<Gamma>' 0\\<^esub> (g' i))", "by simp"], ["proof (state)\nthis:\n  RF (TER\\<^bsub>\\<Gamma>' 0\\<^esub> (f (Suc n))) =\n  RF (\\<Union>i\\<le>Suc n. TER\\<^bsub>\\<Gamma>' 0\\<^esub> (g' i))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  RF (TER\\<^bsub>\\<Gamma>' 0\\<^esub> (f ?n)) =\n  RF (\\<Union>i\\<le>?n. TER\\<^bsub>\\<Gamma>' 0\\<^esub> (g' i))\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>\\<epsilon>>0.\n               \\<epsilon> < \\<delta> \\<and>\n               \\<not> hindered\n                       (reduce_weight \\<Gamma> b\n                         \\<epsilon>)) \\<Longrightarrow>\n    False", "define g\\<omega> where \"g\\<omega> = (SUP n. f n)\""], ["proof (state)\nthis:\n  g\\<omega> = \\<Squnion> range f\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>\\<epsilon>>0.\n               \\<epsilon> < \\<delta> \\<and>\n               \\<not> hindered\n                       (reduce_weight \\<Gamma> b\n                         \\<epsilon>)) \\<Longrightarrow>\n    False", "have g\\<omega>: \"current (\\<Gamma>' 0) g\\<omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. current (\\<Gamma>' 0) g\\<omega>", "unfolding g\\<omega>_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. current (\\<Gamma>' 0) (\\<Squnion> range f)", "using chain_f"], ["proof (prove)\nusing this:\n  Complete_Partial_Order.chain (\\<le>) (range f)\n\ngoal (1 subgoal):\n 1. current (\\<Gamma>' 0) (\\<Squnion> range f)", "by(rule current_Sup)(auto simp add: f supp_f)"], ["proof (state)\nthis:\n  current (\\<Gamma>' 0) g\\<omega>\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>\\<epsilon>>0.\n               \\<epsilon> < \\<delta> \\<and>\n               \\<not> hindered\n                       (reduce_weight \\<Gamma> b\n                         \\<epsilon>)) \\<Longrightarrow>\n    False", "have w\\<omega>: \"wave (\\<Gamma>' 0) g\\<omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wave (\\<Gamma>' 0) g\\<omega>", "unfolding g\\<omega>_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. wave (\\<Gamma>' 0) (\\<Squnion> range f)", "using chain_f"], ["proof (prove)\nusing this:\n  Complete_Partial_Order.chain (\\<le>) (range f)\n\ngoal (1 subgoal):\n 1. wave (\\<Gamma>' 0) (\\<Squnion> range f)", "by(rule wave_lub)(auto simp add: fw  supp_f)"], ["proof (state)\nthis:\n  wave (\\<Gamma>' 0) g\\<omega>\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>\\<epsilon>>0.\n               \\<epsilon> < \\<delta> \\<and>\n               \\<not> hindered\n                       (reduce_weight \\<Gamma> b\n                         \\<epsilon>)) \\<Longrightarrow>\n    False", "from g\\<omega>"], ["proof (chain)\npicking this:\n  current (\\<Gamma>' 0) g\\<omega>", "have g\\<omega>': \"current (\\<Gamma>' n) g\\<omega>\" for n"], ["proof (prove)\nusing this:\n  current (\\<Gamma>' 0) g\\<omega>\n\ngoal (1 subgoal):\n 1. current (\\<Gamma>' n) g\\<omega>", "using wb_pos \\<delta>"], ["proof (prove)\nusing this:\n  current (\\<Gamma>' 0) g\\<omega>\n  0 < wb\n  0 < \\<delta>\n\ngoal (1 subgoal):\n 1. current (\\<Gamma>' n) g\\<omega>", "by(elim current_weight_mono)(auto simp add: \\<epsilon>_le wb_conv \\<epsilon>_def field_simps ennreal_minus_if min_le_iff_disj)"], ["proof (state)\nthis:\n  current (\\<Gamma>' ?n) g\\<omega>\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>\\<epsilon>>0.\n               \\<epsilon> < \\<delta> \\<and>\n               \\<not> hindered\n                       (reduce_weight \\<Gamma> b\n                         \\<epsilon>)) \\<Longrightarrow>\n    False", "have SINK_g\\<omega>: \"SINK g\\<omega> = (\\<Inter>n. SINK (f n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SINK g\\<omega> = (\\<Inter>n. SINK (f n))", "unfolding g\\<omega>_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. SINK (\\<Squnion> range f) = (\\<Inter>n. SINK (f n))", "by(subst SINK_Sup[OF chain_f])(simp_all add: supp_f)"], ["proof (state)\nthis:\n  SINK g\\<omega> = (\\<Inter>n. SINK (f n))\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>\\<epsilon>>0.\n               \\<epsilon> < \\<delta> \\<and>\n               \\<not> hindered\n                       (reduce_weight \\<Gamma> b\n                         \\<epsilon>)) \\<Longrightarrow>\n    False", "have SAT_g\\<omega>: \"SAT (\\<Gamma>' 0) (f n) \\<subseteq> SAT (\\<Gamma>' 0) g\\<omega>\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. SAT (\\<Gamma>' 0) (f n) \\<subseteq> SAT (\\<Gamma>' 0) g\\<omega>", "unfolding g\\<omega>_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. SAT (\\<Gamma>' 0) (f n)\n    \\<subseteq> SAT (\\<Gamma>' 0) (\\<Squnion> range f)", "by(rule SAT_Sup_upper) simp"], ["proof (state)\nthis:\n  SAT (\\<Gamma>' 0) (f ?n) \\<subseteq> SAT (\\<Gamma>' 0) g\\<omega>\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>\\<epsilon>>0.\n               \\<epsilon> < \\<delta> \\<and>\n               \\<not> hindered\n                       (reduce_weight \\<Gamma> b\n                         \\<epsilon>)) \\<Longrightarrow>\n    False", "have g_b_out: \"g n (b, x) = 0\" for n x"], ["proof (prove)\ngoal (1 subgoal):\n 1. g n (b, x) = 0", "using b_TER[of n]"], ["proof (prove)\nusing this:\n  b \\<in> TER\\<^bsub>\\<Gamma>' n\\<^esub> (g n)\n\ngoal (1 subgoal):\n 1. g n (b, x) = 0", "by(simp add: SINK.simps currentD_OUT_eq_0[OF g])"], ["proof (state)\nthis:\n  g ?n (b, ?x) = 0\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>\\<epsilon>>0.\n               \\<epsilon> < \\<delta> \\<and>\n               \\<not> hindered\n                       (reduce_weight \\<Gamma> b\n                         \\<epsilon>)) \\<Longrightarrow>\n    False", "have g'_b_out: \"g' n (b, x) = 0\" for n x"], ["proof (prove)\ngoal (1 subgoal):\n 1. g' n (b, x) = 0", "by(simp add: g'_simps g_b_out)"], ["proof (state)\nthis:\n  g' ?n (b, ?x) = 0\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>\\<epsilon>>0.\n               \\<epsilon> < \\<delta> \\<and>\n               \\<not> hindered\n                       (reduce_weight \\<Gamma> b\n                         \\<epsilon>)) \\<Longrightarrow>\n    False", "have \"f n (b, x) = 0\" for n x"], ["proof (prove)\ngoal (1 subgoal):\n 1. f n (b, x) = 0", "by(induction n)(simp_all add: g_b_out g'_b_out)"], ["proof (state)\nthis:\n  f ?n (b, ?x) = 0\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>\\<epsilon>>0.\n               \\<epsilon> < \\<delta> \\<and>\n               \\<not> hindered\n                       (reduce_weight \\<Gamma> b\n                         \\<epsilon>)) \\<Longrightarrow>\n    False", "hence b_SINK_f: \"b \\<in> SINK (f n)\" for n"], ["proof (prove)\nusing this:\n  f ?n (b, ?x) = 0\n\ngoal (1 subgoal):\n 1. b \\<in> SINK (f n)", "by(simp add: SINK.simps d_OUT_def)"], ["proof (state)\nthis:\n  b \\<in> SINK (f ?n)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>\\<epsilon>>0.\n               \\<epsilon> < \\<delta> \\<and>\n               \\<not> hindered\n                       (reduce_weight \\<Gamma> b\n                         \\<epsilon>)) \\<Longrightarrow>\n    False", "hence b_SINK_g\\<omega>: \"b \\<in> SINK g\\<omega>\""], ["proof (prove)\nusing this:\n  b \\<in> SINK (f ?n)\n\ngoal (1 subgoal):\n 1. b \\<in> SINK g\\<omega>", "by(simp add: SINK_g\\<omega>)"], ["proof (state)\nthis:\n  b \\<in> SINK g\\<omega>\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>\\<epsilon>>0.\n               \\<epsilon> < \\<delta> \\<and>\n               \\<not> hindered\n                       (reduce_weight \\<Gamma> b\n                         \\<epsilon>)) \\<Longrightarrow>\n    False", "have RF_circ: \"RF\\<^sup>\\<circ>\\<^bsub>\\<Gamma>' n\\<^esub> (TER\\<^bsub>\\<Gamma>' 0\\<^esub> (g' n)) = RF\\<^sup>\\<circ>\\<^bsub>\\<Gamma>' 0\\<^esub> (TER\\<^bsub>\\<Gamma>' 0\\<^esub> (g' n))\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. RF\\<^sup>\\<circ>\\<^bsub>\\<Gamma>' n\\<^esub>\n     (TER\\<^bsub>\\<Gamma>' 0\\<^esub> (g' n)) =\n    RF\\<^sup>\\<circ>\\<^bsub>\\<Gamma>' 0\\<^esub>\n     (TER\\<^bsub>\\<Gamma>' 0\\<^esub> (g' n))", "by(simp add: roofed_circ_def)"], ["proof (state)\nthis:\n  RF\\<^sup>\\<circ>\\<^bsub>\\<Gamma>' ?n\\<^esub>\n   (TER\\<^bsub>\\<Gamma>' 0\\<^esub> (g' ?n)) =\n  RF\\<^sup>\\<circ>\\<^bsub>\\<Gamma>' 0\\<^esub>\n   (TER\\<^bsub>\\<Gamma>' 0\\<^esub> (g' ?n))\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>\\<epsilon>>0.\n               \\<epsilon> < \\<delta> \\<and>\n               \\<not> hindered\n                       (reduce_weight \\<Gamma> b\n                         \\<epsilon>)) \\<Longrightarrow>\n    False", "have edge_restrict_\\<Gamma>': \"edge (quotient_web (\\<Gamma>' 0) (g' n)) = edge (quotient_web (\\<Gamma>' n) (g n))\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. edge (quotient_web (\\<Gamma>' 0) (g' n)) =\n    edge (quotient_web (\\<Gamma>' n) (g n))", "by(simp add: fun_eq_iff TER_g' RF_circ)"], ["proof (state)\nthis:\n  edge (quotient_web (\\<Gamma>' 0) (g' ?n)) =\n  edge (quotient_web (\\<Gamma>' ?n) (g ?n))\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>\\<epsilon>>0.\n               \\<epsilon> < \\<delta> \\<and>\n               \\<not> hindered\n                       (reduce_weight \\<Gamma> b\n                         \\<epsilon>)) \\<Longrightarrow>\n    False", "have restrict_curr_g': \"f \\<upharpoonleft> \\<Gamma>' 0 / g' n = f \\<upharpoonleft> \\<Gamma>' n / g n\" for n f"], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<upharpoonleft> \\<Gamma>' 0 / g' n =\n    f \\<upharpoonleft> \\<Gamma>' n / g n", "by(simp add: restrict_current_def RF_circ TER_g')"], ["proof (state)\nthis:\n  ?f \\<upharpoonleft> \\<Gamma>' 0 / g' ?n =\n  ?f \\<upharpoonleft> \\<Gamma>' ?n / g ?n\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>\\<epsilon>>0.\n               \\<epsilon> < \\<delta> \\<and>\n               \\<not> hindered\n                       (reduce_weight \\<Gamma> b\n                         \\<epsilon>)) \\<Longrightarrow>\n    False", "have RF_restrict: \"roofed_gen (quotient_web (\\<Gamma>' n) (g n)) = roofed_gen (quotient_web (\\<Gamma>' 0) (g' n))\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. roofed_gen (quotient_web (\\<Gamma>' n) (g n)) =\n    roofed_gen (quotient_web (\\<Gamma>' 0) (g' n))", "by(simp add: roofed_def fun_eq_iff edge_restrict_\\<Gamma>')"], ["proof (state)\nthis:\n  roofed_gen (quotient_web (\\<Gamma>' ?n) (g ?n)) =\n  roofed_gen (quotient_web (\\<Gamma>' 0) (g' ?n))\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>\\<epsilon>>0.\n               \\<epsilon> < \\<delta> \\<and>\n               \\<not> hindered\n                       (reduce_weight \\<Gamma> b\n                         \\<epsilon>)) \\<Longrightarrow>\n    False", "have g\\<omega>r': \"current (quotient_web (\\<Gamma>' 0) (g' n)) (g\\<omega> \\<upharpoonleft> \\<Gamma>' 0 / g' n)\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. current (quotient_web (\\<Gamma>' 0) (g' n))\n     (g\\<omega> \\<upharpoonleft> \\<Gamma>' 0 / g' n)", "using w' g\\<omega>"], ["proof (prove)\nusing this:\n  wave (\\<Gamma>' 0) (g' ?n)\n  current (\\<Gamma>' 0) g\\<omega>\n\ngoal (1 subgoal):\n 1. current (quotient_web (\\<Gamma>' 0) (g' n))\n     (g\\<omega> \\<upharpoonleft> \\<Gamma>' 0 / g' n)", "by(rule current_restrict_current)"], ["proof (state)\nthis:\n  current (quotient_web (\\<Gamma>' 0) (g' ?n))\n   (g\\<omega> \\<upharpoonleft> \\<Gamma>' 0 / g' ?n)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>\\<epsilon>>0.\n               \\<epsilon> < \\<delta> \\<and>\n               \\<not> hindered\n                       (reduce_weight \\<Gamma> b\n                         \\<epsilon>)) \\<Longrightarrow>\n    False", "have g\\<omega>r: \"current (quotient_web (\\<Gamma>' n) (g n)) (g\\<omega> \\<upharpoonleft> \\<Gamma>' n / g n)\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. current (quotient_web (\\<Gamma>' n) (g n))\n     (g\\<omega> \\<upharpoonleft> \\<Gamma>' n / g n)", "using w g\\<omega>'"], ["proof (prove)\nusing this:\n  wave (\\<Gamma>' ?n) (g ?n)\n  current (\\<Gamma>' ?n) g\\<omega>\n\ngoal (1 subgoal):\n 1. current (quotient_web (\\<Gamma>' n) (g n))\n     (g\\<omega> \\<upharpoonleft> \\<Gamma>' n / g n)", "by(rule current_restrict_current)"], ["proof (state)\nthis:\n  current (quotient_web (\\<Gamma>' ?n) (g ?n))\n   (g\\<omega> \\<upharpoonleft> \\<Gamma>' ?n / g ?n)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>\\<epsilon>>0.\n               \\<epsilon> < \\<delta> \\<and>\n               \\<not> hindered\n                       (reduce_weight \\<Gamma> b\n                         \\<epsilon>)) \\<Longrightarrow>\n    False", "have w\\<omega>r: \"wave (quotient_web (\\<Gamma>' n) (g n)) (g\\<omega> \\<upharpoonleft> \\<Gamma>' n / g n)\" (is \"wave ?\\<Gamma>' ?g\\<omega>\") for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. wave (quotient_web (\\<Gamma>' n) (g n))\n     (g\\<omega> \\<upharpoonleft> \\<Gamma>' n / g n)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. separating (quotient_web (\\<Gamma>' n) (g n))\n     (TER\\<^bsub>quotient_web (\\<Gamma>' n) (g n)\\<^esub>\n       (g\\<omega> \\<upharpoonleft> \\<Gamma>' n / g n))\n 2. \\<And>x.\n       x \\<notin> RF\\<^bsub>quotient_web (\\<Gamma>' n) (g n)\\<^esub>\n                   (TER\\<^bsub>quotient_web (\\<Gamma>' n) (g n)\\<^esub>\n                     (g\\<omega> \\<upharpoonleft> \\<Gamma>'\n            n / g n)) \\<Longrightarrow>\n       d_OUT (g\\<omega> \\<upharpoonleft> \\<Gamma>' n / g n) x = 0", "have *: \"wave (quotient_web (\\<Gamma>' 0) (g' n)) (g\\<omega> \\<upharpoonleft> \\<Gamma>' 0 / g' n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wave (quotient_web (\\<Gamma>' 0) (g' n))\n     (g\\<omega> \\<upharpoonleft> \\<Gamma>' 0 / g' n)", "using g' w' g\\<omega> w\\<omega>"], ["proof (prove)\nusing this:\n  current (\\<Gamma>' 0) (g' ?n)\n  wave (\\<Gamma>' 0) (g' ?n)\n  current (\\<Gamma>' 0) g\\<omega>\n  wave (\\<Gamma>' 0) g\\<omega>\n\ngoal (1 subgoal):\n 1. wave (quotient_web (\\<Gamma>' 0) (g' n))\n     (g\\<omega> \\<upharpoonleft> \\<Gamma>' 0 / g' n)", "by(rule wave_restrict_current)"], ["proof (state)\nthis:\n  wave (quotient_web (\\<Gamma>' 0) (g' n))\n   (g\\<omega> \\<upharpoonleft> \\<Gamma>' 0 / g' n)\n\ngoal (2 subgoals):\n 1. separating (quotient_web (\\<Gamma>' n) (g n))\n     (TER\\<^bsub>quotient_web (\\<Gamma>' n) (g n)\\<^esub>\n       (g\\<omega> \\<upharpoonleft> \\<Gamma>' n / g n))\n 2. \\<And>x.\n       x \\<notin> RF\\<^bsub>quotient_web (\\<Gamma>' n) (g n)\\<^esub>\n                   (TER\\<^bsub>quotient_web (\\<Gamma>' n) (g n)\\<^esub>\n                     (g\\<omega> \\<upharpoonleft> \\<Gamma>'\n            n / g n)) \\<Longrightarrow>\n       d_OUT (g\\<omega> \\<upharpoonleft> \\<Gamma>' n / g n) x = 0", "have \"d_IN (g\\<omega> \\<upharpoonleft> \\<Gamma>' n / g n) b = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN (g\\<omega> \\<upharpoonleft> \\<Gamma>' n / g n) b = 0", "by(rule d_IN_restrict_current_outside roofed_greaterI b_TER)+"], ["proof (state)\nthis:\n  d_IN (g\\<omega> \\<upharpoonleft> \\<Gamma>' n / g n) b = 0\n\ngoal (2 subgoals):\n 1. separating (quotient_web (\\<Gamma>' n) (g n))\n     (TER\\<^bsub>quotient_web (\\<Gamma>' n) (g n)\\<^esub>\n       (g\\<omega> \\<upharpoonleft> \\<Gamma>' n / g n))\n 2. \\<And>x.\n       x \\<notin> RF\\<^bsub>quotient_web (\\<Gamma>' n) (g n)\\<^esub>\n                   (TER\\<^bsub>quotient_web (\\<Gamma>' n) (g n)\\<^esub>\n                     (g\\<omega> \\<upharpoonleft> \\<Gamma>'\n            n / g n)) \\<Longrightarrow>\n       d_OUT (g\\<omega> \\<upharpoonleft> \\<Gamma>' n / g n) x = 0", "hence SAT_subset: \"SAT (quotient_web (\\<Gamma>' 0) (g' n)) (g\\<omega> \\<upharpoonleft> \\<Gamma>' n / g n) \\<subseteq> SAT ?\\<Gamma>' (g\\<omega> \\<upharpoonleft> \\<Gamma>' n / g n)\""], ["proof (prove)\nusing this:\n  d_IN (g\\<omega> \\<upharpoonleft> \\<Gamma>' n / g n) b = 0\n\ngoal (1 subgoal):\n 1. SAT (quotient_web (\\<Gamma>' 0) (g' n))\n     (g\\<omega> \\<upharpoonleft> \\<Gamma>' n / g n)\n    \\<subseteq> SAT (quotient_web (\\<Gamma>' n) (g n))\n                 (g\\<omega> \\<upharpoonleft> \\<Gamma>' n / g n)", "using b_TER[of n] wb_pos"], ["proof (prove)\nusing this:\n  d_IN (g\\<omega> \\<upharpoonleft> \\<Gamma>' n / g n) b = 0\n  b \\<in> TER\\<^bsub>\\<Gamma>' n\\<^esub> (g n)\n  0 < wb\n\ngoal (1 subgoal):\n 1. SAT (quotient_web (\\<Gamma>' 0) (g' n))\n     (g\\<omega> \\<upharpoonleft> \\<Gamma>' n / g n)\n    \\<subseteq> SAT (quotient_web (\\<Gamma>' n) (g n))\n                 (g\\<omega> \\<upharpoonleft> \\<Gamma>' n / g n)", "by(auto simp add: SAT.simps TER_g' RF_circ wb_conv \\<epsilon>_def field_simps\n                        ennreal_minus_if split: if_split_asm)"], ["proof (state)\nthis:\n  SAT (quotient_web (\\<Gamma>' 0) (g' n))\n   (g\\<omega> \\<upharpoonleft> \\<Gamma>' n / g n)\n  \\<subseteq> SAT (quotient_web (\\<Gamma>' n) (g n))\n               (g\\<omega> \\<upharpoonleft> \\<Gamma>' n / g n)\n\ngoal (2 subgoals):\n 1. separating (quotient_web (\\<Gamma>' n) (g n))\n     (TER\\<^bsub>quotient_web (\\<Gamma>' n) (g n)\\<^esub>\n       (g\\<omega> \\<upharpoonleft> \\<Gamma>' n / g n))\n 2. \\<And>x.\n       x \\<notin> RF\\<^bsub>quotient_web (\\<Gamma>' n) (g n)\\<^esub>\n                   (TER\\<^bsub>quotient_web (\\<Gamma>' n) (g n)\\<^esub>\n                     (g\\<omega> \\<upharpoonleft> \\<Gamma>'\n            n / g n)) \\<Longrightarrow>\n       d_OUT (g\\<omega> \\<upharpoonleft> \\<Gamma>' n / g n) x = 0", "hence TER_subset: \"TER\\<^bsub>quotient_web (\\<Gamma>' 0) (g' n)\\<^esub> (g\\<omega> \\<upharpoonleft> \\<Gamma>' n / g n) \\<subseteq> TER\\<^bsub>?\\<Gamma>'\\<^esub> (g\\<omega> \\<upharpoonleft> \\<Gamma>' n / g n)\""], ["proof (prove)\nusing this:\n  SAT (quotient_web (\\<Gamma>' 0) (g' n))\n   (g\\<omega> \\<upharpoonleft> \\<Gamma>' n / g n)\n  \\<subseteq> SAT (quotient_web (\\<Gamma>' n) (g n))\n               (g\\<omega> \\<upharpoonleft> \\<Gamma>' n / g n)\n\ngoal (1 subgoal):\n 1. TER\\<^bsub>quotient_web (\\<Gamma>' 0) (g' n)\\<^esub>\n     (g\\<omega> \\<upharpoonleft> \\<Gamma>' n / g n)\n    \\<subseteq> TER\\<^bsub>quotient_web (\\<Gamma>' n) (g n)\\<^esub>\n                 (g\\<omega> \\<upharpoonleft> \\<Gamma>' n / g n)", "using SINK_g'"], ["proof (prove)\nusing this:\n  SAT (quotient_web (\\<Gamma>' 0) (g' n))\n   (g\\<omega> \\<upharpoonleft> \\<Gamma>' n / g n)\n  \\<subseteq> SAT (quotient_web (\\<Gamma>' n) (g n))\n               (g\\<omega> \\<upharpoonleft> \\<Gamma>' n / g n)\n  SINK (g ?n) = SINK (g' ?n)\n\ngoal (1 subgoal):\n 1. TER\\<^bsub>quotient_web (\\<Gamma>' 0) (g' n)\\<^esub>\n     (g\\<omega> \\<upharpoonleft> \\<Gamma>' n / g n)\n    \\<subseteq> TER\\<^bsub>quotient_web (\\<Gamma>' n) (g n)\\<^esub>\n                 (g\\<omega> \\<upharpoonleft> \\<Gamma>' n / g n)", "by(auto simp add: restrict_curr_g')"], ["proof (state)\nthis:\n  TER\\<^bsub>quotient_web (\\<Gamma>' 0) (g' n)\\<^esub>\n   (g\\<omega> \\<upharpoonleft> \\<Gamma>' n / g n)\n  \\<subseteq> TER\\<^bsub>quotient_web (\\<Gamma>' n) (g n)\\<^esub>\n               (g\\<omega> \\<upharpoonleft> \\<Gamma>' n / g n)\n\ngoal (2 subgoals):\n 1. separating (quotient_web (\\<Gamma>' n) (g n))\n     (TER\\<^bsub>quotient_web (\\<Gamma>' n) (g n)\\<^esub>\n       (g\\<omega> \\<upharpoonleft> \\<Gamma>' n / g n))\n 2. \\<And>x.\n       x \\<notin> RF\\<^bsub>quotient_web (\\<Gamma>' n) (g n)\\<^esub>\n                   (TER\\<^bsub>quotient_web (\\<Gamma>' n) (g n)\\<^esub>\n                     (g\\<omega> \\<upharpoonleft> \\<Gamma>'\n            n / g n)) \\<Longrightarrow>\n       d_OUT (g\\<omega> \\<upharpoonleft> \\<Gamma>' n / g n) x = 0", "show \"separating ?\\<Gamma>' (TER\\<^bsub>?\\<Gamma>'\\<^esub> ?g\\<omega>)\" (is \"separating _ ?TER\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. separating (quotient_web (\\<Gamma>' n) (g n))\n     (TER\\<^bsub>quotient_web (\\<Gamma>' n) (g n)\\<^esub>\n       (g\\<omega> \\<upharpoonleft> \\<Gamma>' n / g n))", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y p.\n       \\<lbrakk>x \\<in> A (quotient_web (\\<Gamma>' n) (g n));\n        y \\<in> B (quotient_web (\\<Gamma>' n) (g n));\n        path (quotient_web (\\<Gamma>' n) (g n)) x p y\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>z\\<in>set p.\n                             z \\<in> TER\\<^bsub>quotient_web (\\<Gamma>' n) (g n)\\<^esub>\n(g\\<omega> \\<upharpoonleft> \\<Gamma>' n / g n)) \\<or>\n                         x \\<in> TER\\<^bsub>quotient_web (\\<Gamma>' n) (g n)\\<^esub>\n                                  (g\\<omega> \\<upharpoonleft> \\<Gamma>'\n                         n / g n)", "fix x y p"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y p.\n       \\<lbrakk>x \\<in> A (quotient_web (\\<Gamma>' n) (g n));\n        y \\<in> B (quotient_web (\\<Gamma>' n) (g n));\n        path (quotient_web (\\<Gamma>' n) (g n)) x p y\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>z\\<in>set p.\n                             z \\<in> TER\\<^bsub>quotient_web (\\<Gamma>' n) (g n)\\<^esub>\n(g\\<omega> \\<upharpoonleft> \\<Gamma>' n / g n)) \\<or>\n                         x \\<in> TER\\<^bsub>quotient_web (\\<Gamma>' n) (g n)\\<^esub>\n                                  (g\\<omega> \\<upharpoonleft> \\<Gamma>'\n                         n / g n)", "assume xy: \"x \\<in> A ?\\<Gamma>'\" \"y \\<in> B ?\\<Gamma>'\" and p: \"path ?\\<Gamma>' x p y\""], ["proof (state)\nthis:\n  x \\<in> A (quotient_web (\\<Gamma>' n) (g n))\n  y \\<in> B (quotient_web (\\<Gamma>' n) (g n))\n  path (quotient_web (\\<Gamma>' n) (g n)) x p y\n\ngoal (1 subgoal):\n 1. \\<And>x y p.\n       \\<lbrakk>x \\<in> A (quotient_web (\\<Gamma>' n) (g n));\n        y \\<in> B (quotient_web (\\<Gamma>' n) (g n));\n        path (quotient_web (\\<Gamma>' n) (g n)) x p y\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>z\\<in>set p.\n                             z \\<in> TER\\<^bsub>quotient_web (\\<Gamma>' n) (g n)\\<^esub>\n(g\\<omega> \\<upharpoonleft> \\<Gamma>' n / g n)) \\<or>\n                         x \\<in> TER\\<^bsub>quotient_web (\\<Gamma>' n) (g n)\\<^esub>\n                                  (g\\<omega> \\<upharpoonleft> \\<Gamma>'\n                         n / g n)", "from p"], ["proof (chain)\npicking this:\n  path (quotient_web (\\<Gamma>' n) (g n)) x p y", "have p': \"path (quotient_web (\\<Gamma>' 0) (g' n)) x p y\""], ["proof (prove)\nusing this:\n  path (quotient_web (\\<Gamma>' n) (g n)) x p y\n\ngoal (1 subgoal):\n 1. path (quotient_web (\\<Gamma>' 0) (g' n)) x p y", "by(simp add: edge_restrict_\\<Gamma>')"], ["proof (state)\nthis:\n  path (quotient_web (\\<Gamma>' 0) (g' n)) x p y\n\ngoal (1 subgoal):\n 1. \\<And>x y p.\n       \\<lbrakk>x \\<in> A (quotient_web (\\<Gamma>' n) (g n));\n        y \\<in> B (quotient_web (\\<Gamma>' n) (g n));\n        path (quotient_web (\\<Gamma>' n) (g n)) x p y\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>z\\<in>set p.\n                             z \\<in> TER\\<^bsub>quotient_web (\\<Gamma>' n) (g n)\\<^esub>\n(g\\<omega> \\<upharpoonleft> \\<Gamma>' n / g n)) \\<or>\n                         x \\<in> TER\\<^bsub>quotient_web (\\<Gamma>' n) (g n)\\<^esub>\n                                  (g\\<omega> \\<upharpoonleft> \\<Gamma>'\n                         n / g n)", "with waveD_separating[OF *, THEN separatingD, simplified, OF p'] TER_g'[of n] SINK_g' SAT_g' restrict_curr_g' SAT_subset xy"], ["proof (chain)\npicking this:\n  \\<lbrakk>x \\<in> SAT (\\<Gamma>' 0) (g' n) \\<and>\n           x \\<in> SINK (g' n) \\<and>\n           essential \\<Gamma> (B \\<Gamma>)\n            (TER\\<^bsub>\\<Gamma>' 0\\<^esub> (g' n)) x \\<and>\n           (x \\<in> B \\<Gamma> \\<longrightarrow> x \\<in> A \\<Gamma>);\n   y \\<in> B \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> (\\<exists>z\\<in>set p.\n                        z \\<in> SAT (quotient_web (\\<Gamma>' 0) (g' n))\n                                 (g\\<omega> \\<upharpoonleft> \\<Gamma>'\n                        0 / g' n) \\<and>\n                        z \\<in> SINK\n                                 (g\\<omega> \\<upharpoonleft> \\<Gamma>'\n                        0 / g' n)) \\<or>\n                    x \\<in> SAT (quotient_web (\\<Gamma>' 0) (g' n))\n                             (g\\<omega> \\<upharpoonleft> \\<Gamma>'\n                    0 / g' n) \\<and>\n                    x \\<in> SINK\n                             (g\\<omega> \\<upharpoonleft> \\<Gamma>' 0 / g' n)\n  TER\\<^bsub>\\<Gamma>' n\\<^esub> (g n) =\n  TER\\<^bsub>\\<Gamma>' 0\\<^esub> (g' n)\n  SINK (g ?n) = SINK (g' ?n)\n  SAT (\\<Gamma>' ?n) (g ?n) = SAT (\\<Gamma>' 0) (g' ?n)\n  ?f \\<upharpoonleft> \\<Gamma>' 0 / g' ?n =\n  ?f \\<upharpoonleft> \\<Gamma>' ?n / g ?n\n  SAT (quotient_web (\\<Gamma>' 0) (g' n))\n   (g\\<omega> \\<upharpoonleft> \\<Gamma>' n / g n)\n  \\<subseteq> SAT (quotient_web (\\<Gamma>' n) (g n))\n               (g\\<omega> \\<upharpoonleft> \\<Gamma>' n / g n)\n  x \\<in> A (quotient_web (\\<Gamma>' n) (g n))\n  y \\<in> B (quotient_web (\\<Gamma>' n) (g n))\n  path (quotient_web (\\<Gamma>' 0) (g' n)) x p y", "show \"(\\<exists>z\\<in>set p. z \\<in> ?TER) \\<or> x \\<in> ?TER\""], ["proof (prove)\nusing this:\n  \\<lbrakk>x \\<in> SAT (\\<Gamma>' 0) (g' n) \\<and>\n           x \\<in> SINK (g' n) \\<and>\n           essential \\<Gamma> (B \\<Gamma>)\n            (TER\\<^bsub>\\<Gamma>' 0\\<^esub> (g' n)) x \\<and>\n           (x \\<in> B \\<Gamma> \\<longrightarrow> x \\<in> A \\<Gamma>);\n   y \\<in> B \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> (\\<exists>z\\<in>set p.\n                        z \\<in> SAT (quotient_web (\\<Gamma>' 0) (g' n))\n                                 (g\\<omega> \\<upharpoonleft> \\<Gamma>'\n                        0 / g' n) \\<and>\n                        z \\<in> SINK\n                                 (g\\<omega> \\<upharpoonleft> \\<Gamma>'\n                        0 / g' n)) \\<or>\n                    x \\<in> SAT (quotient_web (\\<Gamma>' 0) (g' n))\n                             (g\\<omega> \\<upharpoonleft> \\<Gamma>'\n                    0 / g' n) \\<and>\n                    x \\<in> SINK\n                             (g\\<omega> \\<upharpoonleft> \\<Gamma>' 0 / g' n)\n  TER\\<^bsub>\\<Gamma>' n\\<^esub> (g n) =\n  TER\\<^bsub>\\<Gamma>' 0\\<^esub> (g' n)\n  SINK (g ?n) = SINK (g' ?n)\n  SAT (\\<Gamma>' ?n) (g ?n) = SAT (\\<Gamma>' 0) (g' ?n)\n  ?f \\<upharpoonleft> \\<Gamma>' 0 / g' ?n =\n  ?f \\<upharpoonleft> \\<Gamma>' ?n / g ?n\n  SAT (quotient_web (\\<Gamma>' 0) (g' n))\n   (g\\<omega> \\<upharpoonleft> \\<Gamma>' n / g n)\n  \\<subseteq> SAT (quotient_web (\\<Gamma>' n) (g n))\n               (g\\<omega> \\<upharpoonleft> \\<Gamma>' n / g n)\n  x \\<in> A (quotient_web (\\<Gamma>' n) (g n))\n  y \\<in> B (quotient_web (\\<Gamma>' n) (g n))\n  path (quotient_web (\\<Gamma>' 0) (g' n)) x p y\n\ngoal (1 subgoal):\n 1. (\\<exists>z\\<in>set p.\n        z \\<in> TER\\<^bsub>quotient_web (\\<Gamma>' n) (g n)\\<^esub>\n                 (g\\<omega> \\<upharpoonleft> \\<Gamma>' n / g n)) \\<or>\n    x \\<in> TER\\<^bsub>quotient_web (\\<Gamma>' n) (g n)\\<^esub>\n             (g\\<omega> \\<upharpoonleft> \\<Gamma>' n / g n)", "by auto"], ["proof (state)\nthis:\n  (\\<exists>z\\<in>set p.\n      z \\<in> TER\\<^bsub>quotient_web (\\<Gamma>' n) (g n)\\<^esub>\n               (g\\<omega> \\<upharpoonleft> \\<Gamma>' n / g n)) \\<or>\n  x \\<in> TER\\<^bsub>quotient_web (\\<Gamma>' n) (g n)\\<^esub>\n           (g\\<omega> \\<upharpoonleft> \\<Gamma>' n / g n)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  separating (quotient_web (\\<Gamma>' n) (g n))\n   (TER\\<^bsub>quotient_web (\\<Gamma>' n) (g n)\\<^esub>\n     (g\\<omega> \\<upharpoonleft> \\<Gamma>' n / g n))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<notin> RF\\<^bsub>quotient_web (\\<Gamma>' n) (g n)\\<^esub>\n                   (TER\\<^bsub>quotient_web (\\<Gamma>' n) (g n)\\<^esub>\n                     (g\\<omega> \\<upharpoonleft> \\<Gamma>'\n            n / g n)) \\<Longrightarrow>\n       d_OUT (g\\<omega> \\<upharpoonleft> \\<Gamma>' n / g n) x = 0", "show \"d_OUT (g\\<omega> \\<upharpoonleft> \\<Gamma>' n / g n) x = 0\" if \"x \\<notin> RF\\<^bsub>?\\<Gamma>'\\<^esub> ?TER\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT (g\\<omega> \\<upharpoonleft> \\<Gamma>' n / g n) x = 0", "unfolding restrict_curr_g'[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT (g\\<omega> \\<upharpoonleft> \\<Gamma>' 0 / g' n) x = 0", "using TER_subset that"], ["proof (prove)\nusing this:\n  TER\\<^bsub>quotient_web (\\<Gamma>' 0) (g' n)\\<^esub>\n   (g\\<omega> \\<upharpoonleft> \\<Gamma>' n / g n)\n  \\<subseteq> TER\\<^bsub>quotient_web (\\<Gamma>' n) (g n)\\<^esub>\n               (g\\<omega> \\<upharpoonleft> \\<Gamma>' n / g n)\n  x \\<notin> RF\\<^bsub>quotient_web (\\<Gamma>' n) (g n)\\<^esub>\n              (TER\\<^bsub>quotient_web (\\<Gamma>' n) (g n)\\<^esub>\n                (g\\<omega> \\<upharpoonleft> \\<Gamma>' n / g n))\n\ngoal (1 subgoal):\n 1. d_OUT (g\\<omega> \\<upharpoonleft> \\<Gamma>' 0 / g' n) x = 0", "by(intro waveD_OUT[OF *])(auto simp add: TER_g' restrict_curr_g' RF_restrict intro: in_roofed_mono)"], ["proof (state)\nthis:\n  ?x \\<notin> RF\\<^bsub>quotient_web (\\<Gamma>' n) (g n)\\<^esub>\n               (TER\\<^bsub>quotient_web (\\<Gamma>' n) (g n)\\<^esub>\n                 (g\\<omega> \\<upharpoonleft> \\<Gamma>'\n        n / g n)) \\<Longrightarrow>\n  d_OUT (g\\<omega> \\<upharpoonleft> \\<Gamma>' n / g n) ?x = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  wave (quotient_web (\\<Gamma>' ?n) (g ?n))\n   (g\\<omega> \\<upharpoonleft> \\<Gamma>' ?n / g ?n)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>\\<epsilon>>0.\n               \\<epsilon> < \\<delta> \\<and>\n               \\<not> hindered\n                       (reduce_weight \\<Gamma> b\n                         \\<epsilon>)) \\<Longrightarrow>\n    False", "have RF_g\\<omega>: \"RF (TER\\<^bsub>\\<Gamma>' 0\\<^esub> g\\<omega>) = RF (\\<Union>n. TER\\<^bsub>\\<Gamma>' 0\\<^esub> (g' n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RF (TER\\<^bsub>\\<Gamma>' 0\\<^esub> g\\<omega>) =\n    RF (\\<Union>n. TER\\<^bsub>\\<Gamma>' 0\\<^esub> (g' n))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. RF (TER\\<^bsub>\\<Gamma>' 0\\<^esub> g\\<omega>) =\n    RF (\\<Union>n. TER\\<^bsub>\\<Gamma>' 0\\<^esub> (g' n))", "have \"RF\\<^bsub>\\<Gamma>' 0\\<^esub> (TER\\<^bsub>\\<Gamma>' 0\\<^esub> g\\<omega>) = RF (\\<Union>i. TER\\<^bsub>\\<Gamma>' 0\\<^esub> (f i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RF\\<^bsub>\\<Gamma>' 0\\<^esub>\n     (TER\\<^bsub>\\<Gamma>' 0\\<^esub> g\\<omega>) =\n    RF (\\<Union>i. TER\\<^bsub>\\<Gamma>' 0\\<^esub> (f i))", "unfolding g\\<omega>_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. RF\\<^bsub>\\<Gamma>' 0\\<^esub>\n     (TER\\<^bsub>\\<Gamma>' 0\\<^esub> (\\<Squnion> range f)) =\n    RF (\\<Union>i. TER\\<^bsub>\\<Gamma>' 0\\<^esub> (f i))", "by(subst RF_TER_Sup[OF _ _ chain_f])(auto simp add: f fw supp_f)"], ["proof (state)\nthis:\n  RF\\<^bsub>\\<Gamma>' 0\\<^esub> (TER\\<^bsub>\\<Gamma>' 0\\<^esub> g\\<omega>) =\n  RF (\\<Union>i. TER\\<^bsub>\\<Gamma>' 0\\<^esub> (f i))\n\ngoal (1 subgoal):\n 1. RF (TER\\<^bsub>\\<Gamma>' 0\\<^esub> g\\<omega>) =\n    RF (\\<Union>n. TER\\<^bsub>\\<Gamma>' 0\\<^esub> (g' n))", "also"], ["proof (state)\nthis:\n  RF\\<^bsub>\\<Gamma>' 0\\<^esub> (TER\\<^bsub>\\<Gamma>' 0\\<^esub> g\\<omega>) =\n  RF (\\<Union>i. TER\\<^bsub>\\<Gamma>' 0\\<^esub> (f i))\n\ngoal (1 subgoal):\n 1. RF (TER\\<^bsub>\\<Gamma>' 0\\<^esub> g\\<omega>) =\n    RF (\\<Union>n. TER\\<^bsub>\\<Gamma>' 0\\<^esub> (g' n))", "have \"\\<dots> = RF (\\<Union>i. RF (TER\\<^bsub>\\<Gamma>' 0\\<^esub> (f i)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RF (\\<Union>i. TER\\<^bsub>\\<Gamma>' 0\\<^esub> (f i)) =\n    RF (\\<Union>i. RF (TER\\<^bsub>\\<Gamma>' 0\\<^esub> (f i)))", "by(simp add: roofed_UN)"], ["proof (state)\nthis:\n  RF (\\<Union>i. TER\\<^bsub>\\<Gamma>' 0\\<^esub> (f i)) =\n  RF (\\<Union>i. RF (TER\\<^bsub>\\<Gamma>' 0\\<^esub> (f i)))\n\ngoal (1 subgoal):\n 1. RF (TER\\<^bsub>\\<Gamma>' 0\\<^esub> g\\<omega>) =\n    RF (\\<Union>n. TER\\<^bsub>\\<Gamma>' 0\\<^esub> (g' n))", "also"], ["proof (state)\nthis:\n  RF (\\<Union>i. TER\\<^bsub>\\<Gamma>' 0\\<^esub> (f i)) =\n  RF (\\<Union>i. RF (TER\\<^bsub>\\<Gamma>' 0\\<^esub> (f i)))\n\ngoal (1 subgoal):\n 1. RF (TER\\<^bsub>\\<Gamma>' 0\\<^esub> g\\<omega>) =\n    RF (\\<Union>n. TER\\<^bsub>\\<Gamma>' 0\\<^esub> (g' n))", "have \"\\<dots> = RF (\\<Union>i. \\<Union>j\\<le>i. TER\\<^bsub>\\<Gamma>' 0\\<^esub> (g' j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RF (\\<Union>i. RF (TER\\<^bsub>\\<Gamma>' 0\\<^esub> (f i))) =\n    RF (\\<Union>i. \\<Union>j\\<le>i. TER\\<^bsub>\\<Gamma>' 0\\<^esub> (g' j))", "unfolding RF_f roofed_UN"], ["proof (prove)\ngoal (1 subgoal):\n 1. RF (\\<Union>i. \\<Union>i\\<le>i. TER\\<^bsub>\\<Gamma>' 0\\<^esub> (g' i)) =\n    RF (\\<Union>i. \\<Union>j\\<le>i. TER\\<^bsub>\\<Gamma>' 0\\<^esub> (g' j))", "by simp"], ["proof (state)\nthis:\n  RF (\\<Union>i. RF (TER\\<^bsub>\\<Gamma>' 0\\<^esub> (f i))) =\n  RF (\\<Union>i. \\<Union>j\\<le>i. TER\\<^bsub>\\<Gamma>' 0\\<^esub> (g' j))\n\ngoal (1 subgoal):\n 1. RF (TER\\<^bsub>\\<Gamma>' 0\\<^esub> g\\<omega>) =\n    RF (\\<Union>n. TER\\<^bsub>\\<Gamma>' 0\\<^esub> (g' n))", "also"], ["proof (state)\nthis:\n  RF (\\<Union>i. RF (TER\\<^bsub>\\<Gamma>' 0\\<^esub> (f i))) =\n  RF (\\<Union>i. \\<Union>j\\<le>i. TER\\<^bsub>\\<Gamma>' 0\\<^esub> (g' j))\n\ngoal (1 subgoal):\n 1. RF (TER\\<^bsub>\\<Gamma>' 0\\<^esub> g\\<omega>) =\n    RF (\\<Union>n. TER\\<^bsub>\\<Gamma>' 0\\<^esub> (g' n))", "have \"(\\<Union>i. \\<Union>j\\<le>i. TER\\<^bsub>\\<Gamma>' 0\\<^esub> (g' j)) = (\\<Union>i. TER\\<^bsub>\\<Gamma>' 0\\<^esub> (g' i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>i. \\<Union>j\\<le>i. TER\\<^bsub>\\<Gamma>' 0\\<^esub> (g' j)) =\n    (\\<Union>i. TER\\<^bsub>\\<Gamma>' 0\\<^esub> (g' i))", "by auto"], ["proof (state)\nthis:\n  (\\<Union>i. \\<Union>j\\<le>i. TER\\<^bsub>\\<Gamma>' 0\\<^esub> (g' j)) =\n  (\\<Union>i. TER\\<^bsub>\\<Gamma>' 0\\<^esub> (g' i))\n\ngoal (1 subgoal):\n 1. RF (TER\\<^bsub>\\<Gamma>' 0\\<^esub> g\\<omega>) =\n    RF (\\<Union>n. TER\\<^bsub>\\<Gamma>' 0\\<^esub> (g' n))", "finally"], ["proof (chain)\npicking this:\n  RF\\<^bsub>\\<Gamma>' 0\\<^esub> (TER\\<^bsub>\\<Gamma>' 0\\<^esub> g\\<omega>) =\n  RF (\\<Union>i. TER\\<^bsub>\\<Gamma>' 0\\<^esub> (g' i))", "show ?thesis"], ["proof (prove)\nusing this:\n  RF\\<^bsub>\\<Gamma>' 0\\<^esub> (TER\\<^bsub>\\<Gamma>' 0\\<^esub> g\\<omega>) =\n  RF (\\<Union>i. TER\\<^bsub>\\<Gamma>' 0\\<^esub> (g' i))\n\ngoal (1 subgoal):\n 1. RF (TER\\<^bsub>\\<Gamma>' 0\\<^esub> g\\<omega>) =\n    RF (\\<Union>n. TER\\<^bsub>\\<Gamma>' 0\\<^esub> (g' n))", "by simp"], ["proof (state)\nthis:\n  RF (TER\\<^bsub>\\<Gamma>' 0\\<^esub> g\\<omega>) =\n  RF (\\<Union>n. TER\\<^bsub>\\<Gamma>' 0\\<^esub> (g' n))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  RF (TER\\<^bsub>\\<Gamma>' 0\\<^esub> g\\<omega>) =\n  RF (\\<Union>n. TER\\<^bsub>\\<Gamma>' 0\\<^esub> (g' n))\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>\\<epsilon>>0.\n               \\<epsilon> < \\<delta> \\<and>\n               \\<not> hindered\n                       (reduce_weight \\<Gamma> b\n                         \\<epsilon>)) \\<Longrightarrow>\n    False", "have SAT_plus_\\<omega>: \"SAT (\\<Gamma>' n) (g n \\<frown>\\<^bsub>\\<Gamma>' n\\<^esub> g\\<omega>) = SAT (\\<Gamma>' 0) (g' n \\<frown>\\<^bsub>\\<Gamma>' 0\\<^esub> g\\<omega>)\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. SAT (\\<Gamma>' n) (g n \\<frown>\\<^bsub>\\<Gamma>' n\\<^esub> g\\<omega>) =\n    SAT (\\<Gamma>' 0) (g' n \\<frown>\\<^bsub>\\<Gamma>' 0\\<^esub> g\\<omega>)", "apply(intro set_eqI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (x \\<in> SAT (\\<Gamma>' n)\n                 (g n \\<frown>\\<^bsub>\\<Gamma>' n\\<^esub> g\\<omega>)) =\n       (x \\<in> SAT (\\<Gamma>' 0)\n                 (g' n \\<frown>\\<^bsub>\\<Gamma>' 0\\<^esub> g\\<omega>))", "apply(simp add: SAT.simps IN_plus_current[OF g w g\\<omega>r] IN_plus_current[OF g' w' g\\<omega>r'] TER_g')"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (x = b \\<longrightarrow>\n        (b \\<in> RF (TER\\<^bsub>\\<Gamma>' 0\\<^esub>\n                      (g' n)) \\<longrightarrow>\n         (b \\<in> A \\<Gamma> \\<or>\n          weight \\<Gamma> b - ennreal (\\<epsilon> n) \\<le> d_IN (g n) b) =\n         (b \\<in> A \\<Gamma> \\<or>\n          weight \\<Gamma> b - ennreal (\\<epsilon> 0)\n          \\<le> d_IN (g' n) b)) \\<and>\n        (b \\<notin> RF (TER\\<^bsub>\\<Gamma>' 0\\<^esub>\n                         (g' n)) \\<longrightarrow>\n         (b \\<in> A \\<Gamma> \\<or>\n          weight \\<Gamma> b - ennreal (\\<epsilon> n)\n          \\<le> d_IN (g\\<omega> \\<upharpoonleft> \\<Gamma>' n / g n) b) =\n         (b \\<in> A \\<Gamma> \\<or>\n          weight \\<Gamma> b - ennreal (\\<epsilon> 0)\n          \\<le> d_IN (g\\<omega> \\<upharpoonleft> \\<Gamma>' 0 / g' n)\n                 b))) \\<and>\n       (x \\<noteq> b \\<longrightarrow>\n        (x \\<in> RF (TER\\<^bsub>\\<Gamma>' 0\\<^esub>\n                      (g' n)) \\<longrightarrow>\n         (x \\<in> A \\<Gamma> \\<or> weight \\<Gamma> x \\<le> d_IN (g n) x) =\n         (x \\<in> A \\<Gamma> \\<or>\n          weight \\<Gamma> x \\<le> d_IN (g' n) x)) \\<and>\n        (x \\<notin> RF (TER\\<^bsub>\\<Gamma>' 0\\<^esub>\n                         (g' n)) \\<longrightarrow>\n         (x \\<in> A \\<Gamma> \\<or>\n          weight \\<Gamma> x\n          \\<le> d_IN (g\\<omega> \\<upharpoonleft> \\<Gamma>' n / g n) x) =\n         (x \\<in> A \\<Gamma> \\<or>\n          weight \\<Gamma> x\n          \\<le> d_IN (g\\<omega> \\<upharpoonleft> \\<Gamma>' 0 / g' n) x)))", "apply(cases \"d_IN (g\\<omega> \\<upharpoonleft> \\<Gamma>' n / g n) b\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x r.\n       \\<lbrakk>0 \\<le> r;\n        d_IN (g\\<omega> \\<upharpoonleft> \\<Gamma>' n / g n) b =\n        ennreal r\\<rbrakk>\n       \\<Longrightarrow> (x = b \\<longrightarrow>\n                          (b \\<in> RF (TER\\<^bsub>\\<Gamma>' 0\\<^esub>\n  (g' n)) \\<longrightarrow>\n                           (b \\<in> A \\<Gamma> \\<or>\n                            weight \\<Gamma> b - ennreal (\\<epsilon> n)\n                            \\<le> d_IN (g n) b) =\n                           (b \\<in> A \\<Gamma> \\<or>\n                            weight \\<Gamma> b - ennreal (\\<epsilon> 0)\n                            \\<le> d_IN (g' n) b)) \\<and>\n                          (b \\<notin> RF\n (TER\\<^bsub>\\<Gamma>' 0\\<^esub> (g' n)) \\<longrightarrow>\n                           (b \\<in> A \\<Gamma> \\<or>\n                            weight \\<Gamma> b - ennreal (\\<epsilon> n)\n                            \\<le> d_IN\n                                   (g\\<omega> \\<upharpoonleft> \\<Gamma>'\n                          n / g n)\n                                   b) =\n                           (b \\<in> A \\<Gamma> \\<or>\n                            weight \\<Gamma> b - ennreal (\\<epsilon> 0)\n                            \\<le> d_IN\n                                   (g\\<omega> \\<upharpoonleft> \\<Gamma>'\n                          0 / g' n)\n                                   b))) \\<and>\n                         (x \\<noteq> b \\<longrightarrow>\n                          (x \\<in> RF (TER\\<^bsub>\\<Gamma>' 0\\<^esub>\n  (g' n)) \\<longrightarrow>\n                           (x \\<in> A \\<Gamma> \\<or>\n                            weight \\<Gamma> x \\<le> d_IN (g n) x) =\n                           (x \\<in> A \\<Gamma> \\<or>\n                            weight \\<Gamma> x \\<le> d_IN (g' n) x)) \\<and>\n                          (x \\<notin> RF\n (TER\\<^bsub>\\<Gamma>' 0\\<^esub> (g' n)) \\<longrightarrow>\n                           (x \\<in> A \\<Gamma> \\<or>\n                            weight \\<Gamma> x\n                            \\<le> d_IN\n                                   (g\\<omega> \\<upharpoonleft> \\<Gamma>'\n                          n / g n)\n                                   x) =\n                           (x \\<in> A \\<Gamma> \\<or>\n                            weight \\<Gamma> x\n                            \\<le> d_IN\n                                   (g\\<omega> \\<upharpoonleft> \\<Gamma>'\n                          0 / g' n)\n                                   x)))\n 2. \\<And>x.\n       d_IN (g\\<omega> \\<upharpoonleft> \\<Gamma>' n / g n) b =\n       \\<top> \\<Longrightarrow>\n       (x = b \\<longrightarrow>\n        (b \\<in> RF (TER\\<^bsub>\\<Gamma>' 0\\<^esub>\n                      (g' n)) \\<longrightarrow>\n         (b \\<in> A \\<Gamma> \\<or>\n          weight \\<Gamma> b - ennreal (\\<epsilon> n) \\<le> d_IN (g n) b) =\n         (b \\<in> A \\<Gamma> \\<or>\n          weight \\<Gamma> b - ennreal (\\<epsilon> 0)\n          \\<le> d_IN (g' n) b)) \\<and>\n        (b \\<notin> RF (TER\\<^bsub>\\<Gamma>' 0\\<^esub>\n                         (g' n)) \\<longrightarrow>\n         (b \\<in> A \\<Gamma> \\<or>\n          weight \\<Gamma> b - ennreal (\\<epsilon> n)\n          \\<le> d_IN (g\\<omega> \\<upharpoonleft> \\<Gamma>' n / g n) b) =\n         (b \\<in> A \\<Gamma> \\<or>\n          weight \\<Gamma> b - ennreal (\\<epsilon> 0)\n          \\<le> d_IN (g\\<omega> \\<upharpoonleft> \\<Gamma>' 0 / g' n)\n                 b))) \\<and>\n       (x \\<noteq> b \\<longrightarrow>\n        (x \\<in> RF (TER\\<^bsub>\\<Gamma>' 0\\<^esub>\n                      (g' n)) \\<longrightarrow>\n         (x \\<in> A \\<Gamma> \\<or> weight \\<Gamma> x \\<le> d_IN (g n) x) =\n         (x \\<in> A \\<Gamma> \\<or>\n          weight \\<Gamma> x \\<le> d_IN (g' n) x)) \\<and>\n        (x \\<notin> RF (TER\\<^bsub>\\<Gamma>' 0\\<^esub>\n                         (g' n)) \\<longrightarrow>\n         (x \\<in> A \\<Gamma> \\<or>\n          weight \\<Gamma> x\n          \\<le> d_IN (g\\<omega> \\<upharpoonleft> \\<Gamma>' n / g n) x) =\n         (x \\<in> A \\<Gamma> \\<or>\n          weight \\<Gamma> x\n          \\<le> d_IN (g\\<omega> \\<upharpoonleft> \\<Gamma>' 0 / g' n) x)))", "apply(auto simp add: SAT.simps wb_conv d_IN_plus_web IN_g')"], ["proof (prove)\ngoal (9 subgoals):\n 1. \\<And>r.\n       \\<lbrakk>0 \\<le> r;\n        d_IN (g\\<omega> \\<upharpoonleft> \\<Gamma>' n / g n) b = ennreal r;\n        b \\<in> RF (TER\\<^bsub>\\<Gamma>' 0\\<^esub> (g' n));\n        \\<not> ennreal wb - ennreal (\\<epsilon> n)\n               \\<le> d_IN (g n) b\\<rbrakk>\n       \\<Longrightarrow> b \\<in> A \\<Gamma>\n 2. \\<And>r.\n       \\<lbrakk>0 \\<le> r;\n        d_IN (g\\<omega> \\<upharpoonleft> \\<Gamma>' n / g n) b = ennreal r;\n        b \\<notin> RF (TER\\<^bsub>\\<Gamma>' 0\\<^esub> (g' n));\n        \\<not> ennreal wb - ennreal (\\<epsilon> 0)\n               \\<le> d_IN (g\\<omega> \\<upharpoonleft> \\<Gamma>' 0 / g' n) b;\n        ennreal wb - ennreal (\\<epsilon> n) \\<le> ennreal r\\<rbrakk>\n       \\<Longrightarrow> b \\<in> A \\<Gamma>\n 3. \\<And>r.\n       \\<lbrakk>0 \\<le> r;\n        d_IN (g\\<omega> \\<upharpoonleft> \\<Gamma>' n / g n) b = ennreal r;\n        b \\<notin> RF (TER\\<^bsub>\\<Gamma>' 0\\<^esub> (g' n));\n        \\<not> ennreal wb - ennreal (\\<epsilon> n) \\<le> ennreal r;\n        ennreal wb - ennreal (\\<epsilon> 0)\n        \\<le> d_IN (g\\<omega> \\<upharpoonleft> \\<Gamma>' 0 / g' n)\n               b\\<rbrakk>\n       \\<Longrightarrow> b \\<in> A \\<Gamma>\n 4. \\<And>x r.\n       \\<lbrakk>0 \\<le> r;\n        d_IN (g\\<omega> \\<upharpoonleft> \\<Gamma>' n / g n) b = ennreal r;\n        x \\<noteq> b; x \\<notin> RF (TER\\<^bsub>\\<Gamma>' 0\\<^esub> (g' n));\n        \\<not> weight \\<Gamma> x\n               \\<le> d_IN (g\\<omega> \\<upharpoonleft> \\<Gamma>' 0 / g' n) x;\n        weight \\<Gamma> x\n        \\<le> d_IN (g\\<omega> \\<upharpoonleft> \\<Gamma>' n / g n) x\\<rbrakk>\n       \\<Longrightarrow> x \\<in> A \\<Gamma>\n 5. \\<And>x r.\n       \\<lbrakk>0 \\<le> r;\n        d_IN (g\\<omega> \\<upharpoonleft> \\<Gamma>' n / g n) b = ennreal r;\n        x \\<noteq> b; x \\<notin> RF (TER\\<^bsub>\\<Gamma>' 0\\<^esub> (g' n));\n        \\<not> weight \\<Gamma> x\n               \\<le> d_IN (g\\<omega> \\<upharpoonleft> \\<Gamma>' n / g n) x;\n        weight \\<Gamma> x\n        \\<le> d_IN (g\\<omega> \\<upharpoonleft> \\<Gamma>' 0 / g' n)\n               x\\<rbrakk>\n       \\<Longrightarrow> x \\<in> A \\<Gamma>\n 6. \\<lbrakk>d_IN (g\\<omega> \\<upharpoonleft> \\<Gamma>' n / g n) b = \\<top>;\n     b \\<in> RF (TER\\<^bsub>\\<Gamma>' 0\\<^esub> (g' n));\n     \\<not> ennreal wb - ennreal (\\<epsilon> n) \\<le> d_IN (g n) b\\<rbrakk>\n    \\<Longrightarrow> b \\<in> A \\<Gamma>\n 7. \\<lbrakk>d_IN (g\\<omega> \\<upharpoonleft> \\<Gamma>' n / g n) b = \\<top>;\n     b \\<notin> RF (TER\\<^bsub>\\<Gamma>' 0\\<^esub> (g' n));\n     \\<not> ennreal wb - ennreal (\\<epsilon> 0)\n            \\<le> d_IN (g\\<omega> \\<upharpoonleft> \\<Gamma>' 0 / g' n)\n                   b\\<rbrakk>\n    \\<Longrightarrow> b \\<in> A \\<Gamma>\n 8. \\<And>x.\n       \\<lbrakk>d_IN (g\\<omega> \\<upharpoonleft> \\<Gamma>' n / g n) b =\n                \\<top>;\n        x \\<noteq> b; x \\<notin> RF (TER\\<^bsub>\\<Gamma>' 0\\<^esub> (g' n));\n        \\<not> weight \\<Gamma> x\n               \\<le> d_IN (g\\<omega> \\<upharpoonleft> \\<Gamma>' 0 / g' n) x;\n        weight \\<Gamma> x\n        \\<le> d_IN (g\\<omega> \\<upharpoonleft> \\<Gamma>' n / g n) x\\<rbrakk>\n       \\<Longrightarrow> x \\<in> A \\<Gamma>\n 9. \\<And>x.\n       \\<lbrakk>d_IN (g\\<omega> \\<upharpoonleft> \\<Gamma>' n / g n) b =\n                \\<top>;\n        x \\<noteq> b; x \\<notin> RF (TER\\<^bsub>\\<Gamma>' 0\\<^esub> (g' n));\n        \\<not> weight \\<Gamma> x\n               \\<le> d_IN (g\\<omega> \\<upharpoonleft> \\<Gamma>' n / g n) x;\n        weight \\<Gamma> x\n        \\<le> d_IN (g\\<omega> \\<upharpoonleft> \\<Gamma>' 0 / g' n)\n               x\\<rbrakk>\n       \\<Longrightarrow> x \\<in> A \\<Gamma>", "apply(simp_all add: wb_conv IN_g_b restrict_curr_g' \\<epsilon>_def field_simps)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>r.\n       \\<lbrakk>0 \\<le> r;\n        d_IN (g\\<omega> \\<upharpoonleft> \\<Gamma>' n / g n) b = ennreal r;\n        b \\<notin> RF (TER\\<^bsub>\\<Gamma>' 0\\<^esub> (g' n));\n        \\<not> ennreal wb - ennreal (min \\<delta> wb / 2) \\<le> ennreal r;\n        ennreal wb - ennreal (min \\<delta> wb / (real n + 2))\n        \\<le> ennreal r\\<rbrakk>\n       \\<Longrightarrow> b \\<in> A \\<Gamma>\n 2. \\<And>r.\n       \\<lbrakk>0 \\<le> r;\n        d_IN (g\\<omega> \\<upharpoonleft> \\<Gamma>' n / g n) b = ennreal r;\n        b \\<notin> RF (TER\\<^bsub>\\<Gamma>' 0\\<^esub> (g' n));\n        \\<not> ennreal wb - ennreal (min \\<delta> wb / (real n + 2))\n               \\<le> ennreal r;\n        ennreal wb - ennreal (min \\<delta> wb / 2) \\<le> ennreal r\\<rbrakk>\n       \\<Longrightarrow> b \\<in> A \\<Gamma>", "apply(metis TER_g' b_TER roofed_greaterI)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  SAT (\\<Gamma>' ?n) (g ?n \\<frown>\\<^bsub>\\<Gamma>' ?n\\<^esub> g\\<omega>) =\n  SAT (\\<Gamma>' 0) (g' ?n \\<frown>\\<^bsub>\\<Gamma>' 0\\<^esub> g\\<omega>)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>\\<epsilon>>0.\n               \\<epsilon> < \\<delta> \\<and>\n               \\<not> hindered\n                       (reduce_weight \\<Gamma> b\n                         \\<epsilon>)) \\<Longrightarrow>\n    False", "have SINK_plus_\\<omega>: \"SINK (g n \\<frown>\\<^bsub>\\<Gamma>' n\\<^esub> g\\<omega>) = SINK (g' n \\<frown>\\<^bsub>\\<Gamma>' 0\\<^esub> g\\<omega>)\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. SINK (g n \\<frown>\\<^bsub>\\<Gamma>' n\\<^esub> g\\<omega>) =\n    SINK (g' n \\<frown>\\<^bsub>\\<Gamma>' 0\\<^esub> g\\<omega>)", "apply(rule set_eqI; simp add: SINK.simps OUT_plus_current[OF g w g\\<omega>r] OUT_plus_current[OF g' w'] current_restrict_current[OF w' g\\<omega>])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (x \\<in> RF\\<^sup>\\<circ>\\<^bsub>\\<Gamma>' n\\<^esub>\n                 (TER\\<^bsub>\\<Gamma>' n\\<^esub> (g n)) \\<longrightarrow>\n        (x \\<in> RF\\<^sup>\\<circ>\\<^bsub>\\<Gamma>' 0\\<^esub>\n                  (TER\\<^bsub>\\<Gamma>' 0\\<^esub> (g' n)) \\<longrightarrow>\n         (d_OUT (g n) x = 0) = (d_OUT (g' n) x = 0)) \\<and>\n        (x \\<notin> RF\\<^sup>\\<circ>\\<^bsub>\\<Gamma>' 0\\<^esub>\n                     (TER\\<^bsub>\\<Gamma>' 0\\<^esub>\n                       (g' n)) \\<longrightarrow>\n         (d_OUT (g n) x = 0) =\n         (d_OUT (g\\<omega> \\<upharpoonleft> \\<Gamma>' 0 / g' n) x =\n          0))) \\<and>\n       (x \\<notin> RF\\<^sup>\\<circ>\\<^bsub>\\<Gamma>' n\\<^esub>\n                    (TER\\<^bsub>\\<Gamma>' n\\<^esub> (g n)) \\<longrightarrow>\n        (x \\<in> RF\\<^sup>\\<circ>\\<^bsub>\\<Gamma>' 0\\<^esub>\n                  (TER\\<^bsub>\\<Gamma>' 0\\<^esub> (g' n)) \\<longrightarrow>\n         (d_OUT (g\\<omega> \\<upharpoonleft> \\<Gamma>' n / g n) x = 0) =\n         (d_OUT (g' n) x = 0)) \\<and>\n        (x \\<notin> RF\\<^sup>\\<circ>\\<^bsub>\\<Gamma>' 0\\<^esub>\n                     (TER\\<^bsub>\\<Gamma>' 0\\<^esub>\n                       (g' n)) \\<longrightarrow>\n         (d_OUT (g\\<omega> \\<upharpoonleft> \\<Gamma>' n / g n) x = 0) =\n         (d_OUT (g\\<omega> \\<upharpoonleft> \\<Gamma>' 0 / g' n) x = 0)))", "using factor_pos[of n]"], ["proof (prove)\nusing this:\n  0 < factor n\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       (x \\<in> RF\\<^sup>\\<circ>\\<^bsub>\\<Gamma>' n\\<^esub>\n                 (TER\\<^bsub>\\<Gamma>' n\\<^esub> (g n)) \\<longrightarrow>\n        (x \\<in> RF\\<^sup>\\<circ>\\<^bsub>\\<Gamma>' 0\\<^esub>\n                  (TER\\<^bsub>\\<Gamma>' 0\\<^esub> (g' n)) \\<longrightarrow>\n         (d_OUT (g n) x = 0) = (d_OUT (g' n) x = 0)) \\<and>\n        (x \\<notin> RF\\<^sup>\\<circ>\\<^bsub>\\<Gamma>' 0\\<^esub>\n                     (TER\\<^bsub>\\<Gamma>' 0\\<^esub>\n                       (g' n)) \\<longrightarrow>\n         (d_OUT (g n) x = 0) =\n         (d_OUT (g\\<omega> \\<upharpoonleft> \\<Gamma>' 0 / g' n) x =\n          0))) \\<and>\n       (x \\<notin> RF\\<^sup>\\<circ>\\<^bsub>\\<Gamma>' n\\<^esub>\n                    (TER\\<^bsub>\\<Gamma>' n\\<^esub> (g n)) \\<longrightarrow>\n        (x \\<in> RF\\<^sup>\\<circ>\\<^bsub>\\<Gamma>' 0\\<^esub>\n                  (TER\\<^bsub>\\<Gamma>' 0\\<^esub> (g' n)) \\<longrightarrow>\n         (d_OUT (g\\<omega> \\<upharpoonleft> \\<Gamma>' n / g n) x = 0) =\n         (d_OUT (g' n) x = 0)) \\<and>\n        (x \\<notin> RF\\<^sup>\\<circ>\\<^bsub>\\<Gamma>' 0\\<^esub>\n                     (TER\\<^bsub>\\<Gamma>' 0\\<^esub>\n                       (g' n)) \\<longrightarrow>\n         (d_OUT (g\\<omega> \\<upharpoonleft> \\<Gamma>' n / g n) x = 0) =\n         (d_OUT (g\\<omega> \\<upharpoonleft> \\<Gamma>' 0 / g' n) x = 0)))", "by(auto simp add: RF_circ TER_g' restrict_curr_g' currentD_OUT_eq_0[OF g] currentD_OUT_eq_0[OF g'] g'_simps split: if_split_asm)"], ["proof (state)\nthis:\n  SINK (g ?n \\<frown>\\<^bsub>\\<Gamma>' ?n\\<^esub> g\\<omega>) =\n  SINK (g' ?n \\<frown>\\<^bsub>\\<Gamma>' 0\\<^esub> g\\<omega>)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>\\<epsilon>>0.\n               \\<epsilon> < \\<delta> \\<and>\n               \\<not> hindered\n                       (reduce_weight \\<Gamma> b\n                         \\<epsilon>)) \\<Longrightarrow>\n    False", "have TER_plus_\\<omega>: \"TER\\<^bsub>\\<Gamma>' n\\<^esub> (g n \\<frown>\\<^bsub>\\<Gamma>' n\\<^esub> g\\<omega>) = TER\\<^bsub>\\<Gamma>' 0\\<^esub> (g' n \\<frown>\\<^bsub>\\<Gamma>' 0\\<^esub> g\\<omega>)\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. TER\\<^bsub>\\<Gamma>' n\\<^esub>\n     (g n \\<frown>\\<^bsub>\\<Gamma>' n\\<^esub> g\\<omega>) =\n    TER\\<^bsub>\\<Gamma>' 0\\<^esub>\n     (g' n \\<frown>\\<^bsub>\\<Gamma>' 0\\<^esub> g\\<omega>)", "by(rule set_eqI iffI)+(simp_all add: SAT_plus_\\<omega> SINK_plus_\\<omega>)"], ["proof (state)\nthis:\n  TER\\<^bsub>\\<Gamma>' ?n\\<^esub>\n   (g ?n \\<frown>\\<^bsub>\\<Gamma>' ?n\\<^esub> g\\<omega>) =\n  TER\\<^bsub>\\<Gamma>' 0\\<^esub>\n   (g' ?n \\<frown>\\<^bsub>\\<Gamma>' 0\\<^esub> g\\<omega>)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>\\<epsilon>>0.\n               \\<epsilon> < \\<delta> \\<and>\n               \\<not> hindered\n                       (reduce_weight \\<Gamma> b\n                         \\<epsilon>)) \\<Longrightarrow>\n    False", "define h where \"h n = g n \\<frown>\\<^bsub>\\<Gamma>' n\\<^esub> g\\<omega>\" for n"], ["proof (state)\nthis:\n  h ?n = g ?n \\<frown>\\<^bsub>\\<Gamma>' ?n\\<^esub> g\\<omega>\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>\\<epsilon>>0.\n               \\<epsilon> < \\<delta> \\<and>\n               \\<not> hindered\n                       (reduce_weight \\<Gamma> b\n                         \\<epsilon>)) \\<Longrightarrow>\n    False", "have h: \"current (\\<Gamma>' n) (h n)\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. current (\\<Gamma>' n) (h n)", "unfolding h_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. current (\\<Gamma>' n)\n     (g n \\<frown>\\<^bsub>\\<Gamma>' n\\<^esub> g\\<omega>)", "using g w"], ["proof (prove)\nusing this:\n  current (\\<Gamma>' ?n) (g ?n)\n  wave (\\<Gamma>' ?n) (g ?n)\n\ngoal (1 subgoal):\n 1. current (\\<Gamma>' n)\n     (g n \\<frown>\\<^bsub>\\<Gamma>' n\\<^esub> g\\<omega>)", "by(rule current_plus_current)(rule current_restrict_current[OF w g\\<omega>'])"], ["proof (state)\nthis:\n  current (\\<Gamma>' ?n) (h ?n)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>\\<epsilon>>0.\n               \\<epsilon> < \\<delta> \\<and>\n               \\<not> hindered\n                       (reduce_weight \\<Gamma> b\n                         \\<epsilon>)) \\<Longrightarrow>\n    False", "have hw: \"wave (\\<Gamma>' n) (h n)\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. wave (\\<Gamma>' n) (h n)", "unfolding h_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. wave (\\<Gamma>' n) (g n \\<frown>\\<^bsub>\\<Gamma>' n\\<^esub> g\\<omega>)", "using g w g\\<omega>' w\\<omega>r"], ["proof (prove)\nusing this:\n  current (\\<Gamma>' ?n) (g ?n)\n  wave (\\<Gamma>' ?n) (g ?n)\n  current (\\<Gamma>' ?n) g\\<omega>\n  wave (quotient_web (\\<Gamma>' ?n) (g ?n))\n   (g\\<omega> \\<upharpoonleft> \\<Gamma>' ?n / g ?n)\n\ngoal (1 subgoal):\n 1. wave (\\<Gamma>' n) (g n \\<frown>\\<^bsub>\\<Gamma>' n\\<^esub> g\\<omega>)", "by(rule wave_plus)"], ["proof (state)\nthis:\n  wave (\\<Gamma>' ?n) (h ?n)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>\\<epsilon>>0.\n               \\<epsilon> < \\<delta> \\<and>\n               \\<not> hindered\n                       (reduce_weight \\<Gamma> b\n                         \\<epsilon>)) \\<Longrightarrow>\n    False", "define T where \"T = TER\\<^bsub>\\<Gamma>' 0\\<^esub> g\\<omega>\""], ["proof (state)\nthis:\n  T = TER\\<^bsub>\\<Gamma>' 0\\<^esub> g\\<omega>\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>\\<epsilon>>0.\n               \\<epsilon> < \\<delta> \\<and>\n               \\<not> hindered\n                       (reduce_weight \\<Gamma> b\n                         \\<epsilon>)) \\<Longrightarrow>\n    False", "have RF_h: \"RF (TER\\<^bsub>\\<Gamma>' n\\<^esub> (h n)) = RF T\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. RF (TER\\<^bsub>\\<Gamma>' n\\<^esub> (h n)) = RF T", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. RF (TER\\<^bsub>\\<Gamma>' n\\<^esub> (h n)) = RF T", "have \"RF\\<^bsub>\\<Gamma>' 0\\<^esub> (TER\\<^bsub>\\<Gamma>' n\\<^esub> (h n)) = RF\\<^bsub>\\<Gamma>' 0\\<^esub> (RF\\<^bsub>\\<Gamma>' 0\\<^esub> (TER\\<^bsub>\\<Gamma>' 0\\<^esub> g\\<omega>) \\<union> TER\\<^bsub>\\<Gamma>' 0\\<^esub> (g' n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RF\\<^bsub>\\<Gamma>' 0\\<^esub> (TER\\<^bsub>\\<Gamma>' n\\<^esub> (h n)) =\n    RF\\<^bsub>\\<Gamma>' 0\\<^esub>\n     (RF\\<^bsub>\\<Gamma>' 0\\<^esub>\n       (TER\\<^bsub>\\<Gamma>' 0\\<^esub> g\\<omega>) \\<union>\n      TER\\<^bsub>\\<Gamma>' 0\\<^esub> (g' n))", "unfolding h_def TER_plus_\\<omega> RF_TER_plus_web[OF g' w' g\\<omega> w\\<omega>] roofed_idem_Un1"], ["proof (prove)\ngoal (1 subgoal):\n 1. RF\\<^bsub>\\<Gamma>' 0\\<^esub>\n     (TER\\<^bsub>\\<Gamma>' 0\\<^esub> (g' n) \\<union>\n      TER\\<^bsub>\\<Gamma>' 0\\<^esub> g\\<omega>) =\n    RF\\<^bsub>\\<Gamma>' 0\\<^esub>\n     (TER\\<^bsub>\\<Gamma>' 0\\<^esub> g\\<omega> \\<union>\n      TER\\<^bsub>\\<Gamma>' 0\\<^esub> (g' n))", "by(simp add: Un_commute)"], ["proof (state)\nthis:\n  RF\\<^bsub>\\<Gamma>' 0\\<^esub> (TER\\<^bsub>\\<Gamma>' n\\<^esub> (h n)) =\n  RF\\<^bsub>\\<Gamma>' 0\\<^esub>\n   (RF\\<^bsub>\\<Gamma>' 0\\<^esub>\n     (TER\\<^bsub>\\<Gamma>' 0\\<^esub> g\\<omega>) \\<union>\n    TER\\<^bsub>\\<Gamma>' 0\\<^esub> (g' n))\n\ngoal (1 subgoal):\n 1. RF (TER\\<^bsub>\\<Gamma>' n\\<^esub> (h n)) = RF T", "also"], ["proof (state)\nthis:\n  RF\\<^bsub>\\<Gamma>' 0\\<^esub> (TER\\<^bsub>\\<Gamma>' n\\<^esub> (h n)) =\n  RF\\<^bsub>\\<Gamma>' 0\\<^esub>\n   (RF\\<^bsub>\\<Gamma>' 0\\<^esub>\n     (TER\\<^bsub>\\<Gamma>' 0\\<^esub> g\\<omega>) \\<union>\n    TER\\<^bsub>\\<Gamma>' 0\\<^esub> (g' n))\n\ngoal (1 subgoal):\n 1. RF (TER\\<^bsub>\\<Gamma>' n\\<^esub> (h n)) = RF T", "have \"\\<dots> = RF ((\\<Union>n. TER\\<^bsub>\\<Gamma>' 0\\<^esub> (g' n)) \\<union> TER\\<^bsub>\\<Gamma>' 0\\<^esub> (g' n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RF\\<^bsub>\\<Gamma>' 0\\<^esub>\n     (RF\\<^bsub>\\<Gamma>' 0\\<^esub>\n       (TER\\<^bsub>\\<Gamma>' 0\\<^esub> g\\<omega>) \\<union>\n      TER\\<^bsub>\\<Gamma>' 0\\<^esub> (g' n)) =\n    RF ((\\<Union>n. TER\\<^bsub>\\<Gamma>' 0\\<^esub> (g' n)) \\<union>\n        TER\\<^bsub>\\<Gamma>' 0\\<^esub> (g' n))", "by(simp add: RF_g\\<omega> roofed_idem_Un1)"], ["proof (state)\nthis:\n  RF\\<^bsub>\\<Gamma>' 0\\<^esub>\n   (RF\\<^bsub>\\<Gamma>' 0\\<^esub>\n     (TER\\<^bsub>\\<Gamma>' 0\\<^esub> g\\<omega>) \\<union>\n    TER\\<^bsub>\\<Gamma>' 0\\<^esub> (g' n)) =\n  RF ((\\<Union>n. TER\\<^bsub>\\<Gamma>' 0\\<^esub> (g' n)) \\<union>\n      TER\\<^bsub>\\<Gamma>' 0\\<^esub> (g' n))\n\ngoal (1 subgoal):\n 1. RF (TER\\<^bsub>\\<Gamma>' n\\<^esub> (h n)) = RF T", "also"], ["proof (state)\nthis:\n  RF\\<^bsub>\\<Gamma>' 0\\<^esub>\n   (RF\\<^bsub>\\<Gamma>' 0\\<^esub>\n     (TER\\<^bsub>\\<Gamma>' 0\\<^esub> g\\<omega>) \\<union>\n    TER\\<^bsub>\\<Gamma>' 0\\<^esub> (g' n)) =\n  RF ((\\<Union>n. TER\\<^bsub>\\<Gamma>' 0\\<^esub> (g' n)) \\<union>\n      TER\\<^bsub>\\<Gamma>' 0\\<^esub> (g' n))\n\ngoal (1 subgoal):\n 1. RF (TER\\<^bsub>\\<Gamma>' n\\<^esub> (h n)) = RF T", "have \"\\<dots> = RF\\<^bsub>\\<Gamma>' 0\\<^esub> T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RF ((\\<Union>n. TER\\<^bsub>\\<Gamma>' 0\\<^esub> (g' n)) \\<union>\n        TER\\<^bsub>\\<Gamma>' 0\\<^esub> (g' n)) =\n    RF\\<^bsub>\\<Gamma>' 0\\<^esub> T", "unfolding T_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. RF ((\\<Union>n. TER\\<^bsub>\\<Gamma>' 0\\<^esub> (g' n)) \\<union>\n        TER\\<^bsub>\\<Gamma>' 0\\<^esub> (g' n)) =\n    RF\\<^bsub>\\<Gamma>' 0\\<^esub> (TER\\<^bsub>\\<Gamma>' 0\\<^esub> g\\<omega>)", "by(auto simp add: RF_g\\<omega> intro!: arg_cong2[where f=roofed] del: equalityI) auto"], ["proof (state)\nthis:\n  RF ((\\<Union>n. TER\\<^bsub>\\<Gamma>' 0\\<^esub> (g' n)) \\<union>\n      TER\\<^bsub>\\<Gamma>' 0\\<^esub> (g' n)) =\n  RF\\<^bsub>\\<Gamma>' 0\\<^esub> T\n\ngoal (1 subgoal):\n 1. RF (TER\\<^bsub>\\<Gamma>' n\\<^esub> (h n)) = RF T", "finally"], ["proof (chain)\npicking this:\n  RF\\<^bsub>\\<Gamma>' 0\\<^esub> (TER\\<^bsub>\\<Gamma>' n\\<^esub> (h n)) =\n  RF\\<^bsub>\\<Gamma>' 0\\<^esub> T", "show ?thesis"], ["proof (prove)\nusing this:\n  RF\\<^bsub>\\<Gamma>' 0\\<^esub> (TER\\<^bsub>\\<Gamma>' n\\<^esub> (h n)) =\n  RF\\<^bsub>\\<Gamma>' 0\\<^esub> T\n\ngoal (1 subgoal):\n 1. RF (TER\\<^bsub>\\<Gamma>' n\\<^esub> (h n)) = RF T", "by simp"], ["proof (state)\nthis:\n  RF (TER\\<^bsub>\\<Gamma>' n\\<^esub> (h n)) = RF T\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  RF (TER\\<^bsub>\\<Gamma>' ?n\\<^esub> (h ?n)) = RF T\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>\\<epsilon>>0.\n               \\<epsilon> < \\<delta> \\<and>\n               \\<not> hindered\n                       (reduce_weight \\<Gamma> b\n                         \\<epsilon>)) \\<Longrightarrow>\n    False", "have OUT_h_nT: \"d_OUT (h n) x = 0\" if \"x \\<notin> RF T\" for n x"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT (h n) x = 0", "by(rule waveD_OUT[OF hw])(simp add: RF_h that)"], ["proof (state)\nthis:\n  ?x \\<notin> RF T \\<Longrightarrow> d_OUT (h ?n) ?x = 0\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>\\<epsilon>>0.\n               \\<epsilon> < \\<delta> \\<and>\n               \\<not> hindered\n                       (reduce_weight \\<Gamma> b\n                         \\<epsilon>)) \\<Longrightarrow>\n    False", "have IN_h_nT: \"d_IN (h n) x = 0\" if \"x \\<notin> RF T\" for n x"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN (h n) x = 0", "by(rule wave_not_RF_IN_zero[OF h hw])(simp add: RF_h that)"], ["proof (state)\nthis:\n  ?x \\<notin> RF T \\<Longrightarrow> d_IN (h ?n) ?x = 0\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>\\<epsilon>>0.\n               \\<epsilon> < \\<delta> \\<and>\n               \\<not> hindered\n                       (reduce_weight \\<Gamma> b\n                         \\<epsilon>)) \\<Longrightarrow>\n    False", "have OUT_h_b: \"d_OUT (h n) b = 0\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT (h n) b = 0", "using b_TER[of n] b_SINK_g\\<omega>[THEN in_SINK_restrict_current]"], ["proof (prove)\nusing this:\n  b \\<in> TER\\<^bsub>\\<Gamma>' n\\<^esub> (g n)\n  b \\<in> SINK (g\\<omega> \\<upharpoonleft> ?\\<Gamma> / ?f)\n\ngoal (1 subgoal):\n 1. d_OUT (h n) b = 0", "by(auto simp add: h_def OUT_plus_current[OF g w g\\<omega>r] SINK.simps)"], ["proof (state)\nthis:\n  d_OUT (h ?n) b = 0\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>\\<epsilon>>0.\n               \\<epsilon> < \\<delta> \\<and>\n               \\<not> hindered\n                       (reduce_weight \\<Gamma> b\n                         \\<epsilon>)) \\<Longrightarrow>\n    False", "have OUT_h_\\<E>: \"d_OUT (h n) x = 0\" if \"x \\<in> \\<E> T\" for x n"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT (h n) x = 0", "using that"], ["proof (prove)\nusing this:\n  x \\<in> \\<E> T\n\ngoal (1 subgoal):\n 1. d_OUT (h n) x = 0", "apply(subst (asm) \\<E>_RF[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> \\<E> (RF T) \\<Longrightarrow> d_OUT (h n) x = 0", "apply(subst (asm) (1 2) RF_h[symmetric, of n])"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> \\<E>\n             (RF (TER\\<^bsub>\\<Gamma>' n\\<^esub> (h n))) \\<Longrightarrow>\n    d_OUT (h n) x = 0", "apply(subst (asm) \\<E>_RF)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> \\<E> (TER\\<^bsub>\\<Gamma>' n\\<^esub> (h n)) \\<Longrightarrow>\n    d_OUT (h n) x = 0", "apply(simp add: SINK.simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  ?x \\<in> \\<E> T \\<Longrightarrow> d_OUT (h ?n) ?x = 0\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>\\<epsilon>>0.\n               \\<epsilon> < \\<delta> \\<and>\n               \\<not> hindered\n                       (reduce_weight \\<Gamma> b\n                         \\<epsilon>)) \\<Longrightarrow>\n    False", "have IN_h_\\<E>: \"d_IN (h n) x = weight (\\<Gamma>' n) x\" if \"x \\<in> \\<E> T\" \"x \\<notin> A \\<Gamma>\" for x n"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN (h n) x = weight (\\<Gamma>' n) x", "using that"], ["proof (prove)\nusing this:\n  x \\<in> \\<E> T\n  x \\<notin> A \\<Gamma>\n\ngoal (1 subgoal):\n 1. d_IN (h n) x = weight (\\<Gamma>' n) x", "apply(subst (asm) \\<E>_RF[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> \\<E> (RF T); x \\<notin> A \\<Gamma>\\<rbrakk>\n    \\<Longrightarrow> d_IN (h n) x = weight (\\<Gamma>' n) x", "apply(subst (asm) (1 2) RF_h[symmetric, of n])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> \\<E> (RF (TER\\<^bsub>\\<Gamma>' n\\<^esub> (h n)));\n     x \\<notin> A \\<Gamma>\\<rbrakk>\n    \\<Longrightarrow> d_IN (h n) x = weight (\\<Gamma>' n) x", "apply(subst (asm) \\<E>_RF)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> \\<E> (TER\\<^bsub>\\<Gamma>' n\\<^esub> (h n));\n     x \\<notin> A \\<Gamma>\\<rbrakk>\n    \\<Longrightarrow> d_IN (h n) x = weight (\\<Gamma>' n) x", "apply(simp add: currentD_SAT[OF h])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<lbrakk>?x \\<in> \\<E> T; ?x \\<notin> A \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> d_IN (h ?n) ?x = weight (\\<Gamma>' ?n) ?x\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>\\<epsilon>>0.\n               \\<epsilon> < \\<delta> \\<and>\n               \\<not> hindered\n                       (reduce_weight \\<Gamma> b\n                         \\<epsilon>)) \\<Longrightarrow>\n    False", "have b_SAT: \"b \\<in> SAT (\\<Gamma>' 0) (h 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b \\<in> SAT (\\<Gamma>' 0) (h 0)", "using b_TER[of 0]"], ["proof (prove)\nusing this:\n  b \\<in> TER\\<^bsub>\\<Gamma>' 0\\<^esub> (g 0)\n\ngoal (1 subgoal):\n 1. b \\<in> SAT (\\<Gamma>' 0) (h 0)", "by(auto simp add: h_def SAT.simps d_IN_plus_web intro: order_trans)"], ["proof (state)\nthis:\n  b \\<in> SAT (\\<Gamma>' 0) (h 0)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>\\<epsilon>>0.\n               \\<epsilon> < \\<delta> \\<and>\n               \\<not> hindered\n                       (reduce_weight \\<Gamma> b\n                         \\<epsilon>)) \\<Longrightarrow>\n    False", "have b_T: \"b \\<in> T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b \\<in> T", "using b_SINK_g\\<omega> b_TER"], ["proof (prove)\nusing this:\n  b \\<in> SINK g\\<omega>\n  b \\<in> TER\\<^bsub>\\<Gamma>' ?n\\<^esub> (g ?n)\n\ngoal (1 subgoal):\n 1. b \\<in> T", "by(simp add: T_def)(metis SAT_g\\<omega> subsetD f_simps(1))"], ["proof (state)\nthis:\n  b \\<in> T\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>\\<epsilon>>0.\n               \\<epsilon> < \\<delta> \\<and>\n               \\<not> hindered\n                       (reduce_weight \\<Gamma> b\n                         \\<epsilon>)) \\<Longrightarrow>\n    False", "have essential: \"b \\<in> \\<E> T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b \\<in> \\<E> T", "proof(rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. b \\<notin> \\<E> T \\<Longrightarrow> False", "assume \"b \\<notin> \\<E> T\""], ["proof (state)\nthis:\n  b \\<notin> \\<E> T\n\ngoal (1 subgoal):\n 1. b \\<notin> \\<E> T \\<Longrightarrow> False", "hence b: \"b \\<notin> \\<E> (TER\\<^bsub>\\<Gamma>' 0\\<^esub> (h 0))\""], ["proof (prove)\nusing this:\n  b \\<notin> \\<E> T\n\ngoal (1 subgoal):\n 1. b \\<notin> \\<E> (TER\\<^bsub>\\<Gamma>' 0\\<^esub> (h 0))", "proof(rule contrapos_nn)"], ["proof (state)\ngoal (1 subgoal):\n 1. b \\<in> \\<E> (TER\\<^bsub>\\<Gamma>' 0\\<^esub> (h 0)) \\<Longrightarrow>\n    b \\<in> \\<E> T", "assume \"b \\<in> \\<E> (TER\\<^bsub>\\<Gamma>' 0\\<^esub> (h 0))\""], ["proof (state)\nthis:\n  b \\<in> \\<E> (TER\\<^bsub>\\<Gamma>' 0\\<^esub> (h 0))\n\ngoal (1 subgoal):\n 1. b \\<in> \\<E> (TER\\<^bsub>\\<Gamma>' 0\\<^esub> (h 0)) \\<Longrightarrow>\n    b \\<in> \\<E> T", "then"], ["proof (chain)\npicking this:\n  b \\<in> \\<E> (TER\\<^bsub>\\<Gamma>' 0\\<^esub> (h 0))", "obtain p y where p: \"path \\<Gamma> b p y\" and y: \"y \\<in> B \\<Gamma>\" and distinct: \"distinct (b # p)\"\n        and bypass: \"\\<And>z. z \\<in> set p \\<Longrightarrow> z \\<notin> RF (TER\\<^bsub>\\<Gamma>' 0\\<^esub> (h 0))\""], ["proof (prove)\nusing this:\n  b \\<in> \\<E> (TER\\<^bsub>\\<Gamma>' 0\\<^esub> (h 0))\n\ngoal (1 subgoal):\n 1. (\\<And>p y.\n        \\<lbrakk>path \\<Gamma> b p y; y \\<in> B \\<Gamma>; distinct (b # p);\n         \\<And>z.\n            z \\<in> set p \\<Longrightarrow>\n            z \\<notin> RF (TER\\<^bsub>\\<Gamma>' 0\\<^esub> (h 0))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(rule \\<E>_E_RF) auto"], ["proof (state)\nthis:\n  path \\<Gamma> b p y\n  y \\<in> B \\<Gamma>\n  distinct (b # p)\n  ?z \\<in> set p \\<Longrightarrow>\n  ?z \\<notin> RF (TER\\<^bsub>\\<Gamma>' 0\\<^esub> (h 0))\n\ngoal (1 subgoal):\n 1. b \\<in> \\<E> (TER\\<^bsub>\\<Gamma>' 0\\<^esub> (h 0)) \\<Longrightarrow>\n    b \\<in> \\<E> T", "from bypass"], ["proof (chain)\npicking this:\n  ?z \\<in> set p \\<Longrightarrow>\n  ?z \\<notin> RF (TER\\<^bsub>\\<Gamma>' 0\\<^esub> (h 0))", "have bypass': \"\\<And>z. z \\<in> set p \\<Longrightarrow> z \\<notin> T\""], ["proof (prove)\nusing this:\n  ?z \\<in> set p \\<Longrightarrow>\n  ?z \\<notin> RF (TER\\<^bsub>\\<Gamma>' 0\\<^esub> (h 0))\n\ngoal (1 subgoal):\n 1. \\<And>z. z \\<in> set p \\<Longrightarrow> z \\<notin> T", "unfolding RF_h"], ["proof (prove)\nusing this:\n  ?z \\<in> set p \\<Longrightarrow> ?z \\<notin> RF T\n\ngoal (1 subgoal):\n 1. \\<And>z. z \\<in> set p \\<Longrightarrow> z \\<notin> T", "by(auto intro: roofed_greaterI)"], ["proof (state)\nthis:\n  ?z \\<in> set p \\<Longrightarrow> ?z \\<notin> T\n\ngoal (1 subgoal):\n 1. b \\<in> \\<E> (TER\\<^bsub>\\<Gamma>' 0\\<^esub> (h 0)) \\<Longrightarrow>\n    b \\<in> \\<E> T", "have \"essential \\<Gamma> (B \\<Gamma>) T b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. essential \\<Gamma> (B \\<Gamma>) T b", "using p y"], ["proof (prove)\nusing this:\n  path \\<Gamma> b p y\n  y \\<in> B \\<Gamma>\n\ngoal (1 subgoal):\n 1. essential \\<Gamma> (B \\<Gamma>) T b", "by(rule essentialI)(auto dest: bypass')"], ["proof (state)\nthis:\n  essential \\<Gamma> (B \\<Gamma>) T b\n\ngoal (1 subgoal):\n 1. b \\<in> \\<E> (TER\\<^bsub>\\<Gamma>' 0\\<^esub> (h 0)) \\<Longrightarrow>\n    b \\<in> \\<E> T", "then"], ["proof (chain)\npicking this:\n  essential \\<Gamma> (B \\<Gamma>) T b", "show \"b \\<in> \\<E> T\""], ["proof (prove)\nusing this:\n  essential \\<Gamma> (B \\<Gamma>) T b\n\ngoal (1 subgoal):\n 1. b \\<in> \\<E> T", "using b_T"], ["proof (prove)\nusing this:\n  essential \\<Gamma> (B \\<Gamma>) T b\n  b \\<in> T\n\ngoal (1 subgoal):\n 1. b \\<in> \\<E> T", "by simp"], ["proof (state)\nthis:\n  b \\<in> \\<E> T\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  b \\<notin> \\<E> (TER\\<^bsub>\\<Gamma>' 0\\<^esub> (h 0))\n\ngoal (1 subgoal):\n 1. b \\<notin> \\<E> T \\<Longrightarrow> False", "have h0: \"current \\<Gamma> (h 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. current \\<Gamma> (h 0)", "using h[of 0]"], ["proof (prove)\nusing this:\n  current (\\<Gamma>' 0) (h 0)\n\ngoal (1 subgoal):\n 1. current \\<Gamma> (h 0)", "by(rule current_weight_mono)(simp_all add: wb_conv \\<epsilon>_nonneg)"], ["proof (state)\nthis:\n  current \\<Gamma> (h 0)\n\ngoal (1 subgoal):\n 1. b \\<notin> \\<E> T \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  current \\<Gamma> (h 0)\n\ngoal (1 subgoal):\n 1. b \\<notin> \\<E> T \\<Longrightarrow> False", "have \"wave \\<Gamma> (h 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wave \\<Gamma> (h 0)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. separating \\<Gamma> (TER (h 0))\n 2. current \\<Gamma> (h 0)", "have \"separating (\\<Gamma>' 0) (\\<E>\\<^bsub>\\<Gamma>' 0\\<^esub> (TER\\<^bsub>\\<Gamma>' 0\\<^esub> (h 0)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. separating (\\<Gamma>' 0)\n     (\\<E>\\<^bsub>\\<Gamma>' 0\\<^esub>\n       (TER\\<^bsub>\\<Gamma>' 0\\<^esub> (h 0)))", "by(rule separating_essential)(rule waveD_separating[OF hw])"], ["proof (state)\nthis:\n  separating (\\<Gamma>' 0)\n   (\\<E>\\<^bsub>\\<Gamma>' 0\\<^esub> (TER\\<^bsub>\\<Gamma>' 0\\<^esub> (h 0)))\n\ngoal (2 subgoals):\n 1. separating \\<Gamma> (TER (h 0))\n 2. current \\<Gamma> (h 0)", "then"], ["proof (chain)\npicking this:\n  separating (\\<Gamma>' 0)\n   (\\<E>\\<^bsub>\\<Gamma>' 0\\<^esub> (TER\\<^bsub>\\<Gamma>' 0\\<^esub> (h 0)))", "have \"separating \\<Gamma> (\\<E> (TER\\<^bsub>\\<Gamma>' 0\\<^esub> (h 0)))\""], ["proof (prove)\nusing this:\n  separating (\\<Gamma>' 0)\n   (\\<E>\\<^bsub>\\<Gamma>' 0\\<^esub> (TER\\<^bsub>\\<Gamma>' 0\\<^esub> (h 0)))\n\ngoal (1 subgoal):\n 1. separating \\<Gamma> (\\<E> (TER\\<^bsub>\\<Gamma>' 0\\<^esub> (h 0)))", "by(simp add: separating_gen.simps)"], ["proof (state)\nthis:\n  separating \\<Gamma> (\\<E> (TER\\<^bsub>\\<Gamma>' 0\\<^esub> (h 0)))\n\ngoal (2 subgoals):\n 1. separating \\<Gamma> (TER (h 0))\n 2. current \\<Gamma> (h 0)", "moreover"], ["proof (state)\nthis:\n  separating \\<Gamma> (\\<E> (TER\\<^bsub>\\<Gamma>' 0\\<^esub> (h 0)))\n\ngoal (2 subgoals):\n 1. separating \\<Gamma> (TER (h 0))\n 2. current \\<Gamma> (h 0)", "have subset: \"\\<E> (TER\\<^bsub>\\<Gamma>' 0\\<^esub> (h 0)) \\<subseteq> TER (h 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<E> (TER\\<^bsub>\\<Gamma>' 0\\<^esub> (h 0)) \\<subseteq> TER (h 0)", "using \\<epsilon>_nonneg[of 0] b"], ["proof (prove)\nusing this:\n  0 \\<le> \\<epsilon> 0\n  b \\<notin> \\<E> (TER\\<^bsub>\\<Gamma>' 0\\<^esub> (h 0))\n\ngoal (1 subgoal):\n 1. \\<E> (TER\\<^bsub>\\<Gamma>' 0\\<^esub> (h 0)) \\<subseteq> TER (h 0)", "by(auto simp add: SAT.simps wb_conv split: if_split_asm)"], ["proof (state)\nthis:\n  \\<E> (TER\\<^bsub>\\<Gamma>' 0\\<^esub> (h 0)) \\<subseteq> TER (h 0)\n\ngoal (2 subgoals):\n 1. separating \\<Gamma> (TER (h 0))\n 2. current \\<Gamma> (h 0)", "ultimately"], ["proof (chain)\npicking this:\n  separating \\<Gamma> (\\<E> (TER\\<^bsub>\\<Gamma>' 0\\<^esub> (h 0)))\n  \\<E> (TER\\<^bsub>\\<Gamma>' 0\\<^esub> (h 0)) \\<subseteq> TER (h 0)", "show \"separating \\<Gamma> (TER (h 0))\""], ["proof (prove)\nusing this:\n  separating \\<Gamma> (\\<E> (TER\\<^bsub>\\<Gamma>' 0\\<^esub> (h 0)))\n  \\<E> (TER\\<^bsub>\\<Gamma>' 0\\<^esub> (h 0)) \\<subseteq> TER (h 0)\n\ngoal (1 subgoal):\n 1. separating \\<Gamma> (TER (h 0))", "by(rule separating_weakening)"], ["proof (state)\nthis:\n  separating \\<Gamma> (TER (h 0))\n\ngoal (1 subgoal):\n 1. current \\<Gamma> (h 0)", "qed(rule h0)"], ["proof (state)\nthis:\n  wave \\<Gamma> (h 0)\n\ngoal (1 subgoal):\n 1. b \\<notin> \\<E> T \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  current \\<Gamma> (h 0)\n  wave \\<Gamma> (h 0)", "have \"h 0 = zero_current\""], ["proof (prove)\nusing this:\n  current \\<Gamma> (h 0)\n  wave \\<Gamma> (h 0)\n\ngoal (1 subgoal):\n 1. h 0 = (\\<lambda>_. 0)", "by(rule looseD_wave[OF loose])"], ["proof (state)\nthis:\n  h 0 = (\\<lambda>_. 0)\n\ngoal (1 subgoal):\n 1. b \\<notin> \\<E> T \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  h 0 = (\\<lambda>_. 0)", "have \"d_IN (h 0) b = 0\""], ["proof (prove)\nusing this:\n  h 0 = (\\<lambda>_. 0)\n\ngoal (1 subgoal):\n 1. d_IN (h 0) b = 0", "by(simp)"], ["proof (state)\nthis:\n  d_IN (h 0) b = 0\n\ngoal (1 subgoal):\n 1. b \\<notin> \\<E> T \\<Longrightarrow> False", "with b_SAT wb \\<open>b \\<notin> A \\<Gamma>\\<close>"], ["proof (chain)\npicking this:\n  b \\<in> SAT (\\<Gamma>' 0) (h 0)\n  0 < weight \\<Gamma> b\n  b \\<notin> A \\<Gamma>\n  d_IN (h 0) b = 0", "show False"], ["proof (prove)\nusing this:\n  b \\<in> SAT (\\<Gamma>' 0) (h 0)\n  0 < weight \\<Gamma> b\n  b \\<notin> A \\<Gamma>\n  d_IN (h 0) b = 0\n\ngoal (1 subgoal):\n 1. False", "by(simp add: SAT.simps wb_conv \\<epsilon>_def ennreal_minus_if split: if_split_asm)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  b \\<in> \\<E> T\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>\\<epsilon>>0.\n               \\<epsilon> < \\<delta> \\<and>\n               \\<not> hindered\n                       (reduce_weight \\<Gamma> b\n                         \\<epsilon>)) \\<Longrightarrow>\n    False", "define S where \"S = {x \\<in> RF (T \\<inter> B \\<Gamma>) \\<inter> A \\<Gamma>. essential \\<Gamma> (T \\<inter> B \\<Gamma>) (RF (T \\<inter> B \\<Gamma>) \\<inter> A \\<Gamma>) x}\""], ["proof (state)\nthis:\n  S =\n  {x \\<in> RF (T \\<inter> B \\<Gamma>) \\<inter> A \\<Gamma>.\n   essential \\<Gamma> (T \\<inter> B \\<Gamma>)\n    (RF (T \\<inter> B \\<Gamma>) \\<inter> A \\<Gamma>) x}\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>\\<epsilon>>0.\n               \\<epsilon> < \\<delta> \\<and>\n               \\<not> hindered\n                       (reduce_weight \\<Gamma> b\n                         \\<epsilon>)) \\<Longrightarrow>\n    False", "define \\<Gamma>_h where \"\\<Gamma>_h = \\<lparr> edge = \\<lambda>x y. edge \\<Gamma> x y \\<and> x \\<in> S \\<and> y \\<in> T \\<and> y \\<in> B \\<Gamma>, weight = \\<lambda>x. weight \\<Gamma> x * indicator (S \\<union> T \\<inter> B \\<Gamma>) x, A = S, B = T \\<inter> B \\<Gamma>\\<rparr>\""], ["proof (state)\nthis:\n  \\<Gamma>_h =\n  \\<lparr>edge =\n            \\<lambda>x y.\n               edge \\<Gamma> x y \\<and>\n               x \\<in> S \\<and> y \\<in> T \\<and> y \\<in> B \\<Gamma>,\n     weight =\n       \\<lambda>x.\n          weight \\<Gamma> x *\n          indicator (S \\<union> T \\<inter> B \\<Gamma>) x,\n     A = S, B = T \\<inter> B \\<Gamma>\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>\\<epsilon>>0.\n               \\<epsilon> < \\<delta> \\<and>\n               \\<not> hindered\n                       (reduce_weight \\<Gamma> b\n                         \\<epsilon>)) \\<Longrightarrow>\n    False", "have \\<Gamma>_h_sel [simp]:\n    \"edge \\<Gamma>_h x y \\<longleftrightarrow> edge \\<Gamma> x y \\<and> x \\<in> S \\<and> y \\<in> T \\<and> y \\<in> B \\<Gamma>\"\n    \"A \\<Gamma>_h = S\"\n    \"B \\<Gamma>_h = T \\<inter> B \\<Gamma>\"\n    \"weight \\<Gamma>_h x = weight \\<Gamma> x * indicator (S \\<union> T \\<inter> B \\<Gamma>) x\"\n    for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. (edge \\<Gamma>_h x y =\n     (edge \\<Gamma> x y \\<and>\n      x \\<in> S \\<and> y \\<in> T \\<and> y \\<in> B \\<Gamma>) &&&\n     A \\<Gamma>_h = S) &&&\n    B \\<Gamma>_h = T \\<inter> B \\<Gamma> &&&\n    weight \\<Gamma>_h x =\n    weight \\<Gamma> x * indicator (S \\<union> T \\<inter> B \\<Gamma>) x", "by(simp_all add: \\<Gamma>_h_def)"], ["proof (state)\nthis:\n  edge \\<Gamma>_h ?x ?y =\n  (edge \\<Gamma> ?x ?y \\<and>\n   ?x \\<in> S \\<and> ?y \\<in> T \\<and> ?y \\<in> B \\<Gamma>)\n  A \\<Gamma>_h = S\n  B \\<Gamma>_h = T \\<inter> B \\<Gamma>\n  weight \\<Gamma>_h ?x =\n  weight \\<Gamma> ?x * indicator (S \\<union> T \\<inter> B \\<Gamma>) ?x\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>\\<epsilon>>0.\n               \\<epsilon> < \\<delta> \\<and>\n               \\<not> hindered\n                       (reduce_weight \\<Gamma> b\n                         \\<epsilon>)) \\<Longrightarrow>\n    False", "have vertex_\\<Gamma>_hD: \"x \\<in> S \\<union> (T \\<inter> B \\<Gamma>)\" if \"vertex \\<Gamma>_h x\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> S \\<union> T \\<inter> B \\<Gamma>", "using that"], ["proof (prove)\nusing this:\n  vertex \\<Gamma>_h x\n\ngoal (1 subgoal):\n 1. x \\<in> S \\<union> T \\<inter> B \\<Gamma>", "by(auto simp add: vertex_def)"], ["proof (state)\nthis:\n  vertex \\<Gamma>_h ?x \\<Longrightarrow>\n  ?x \\<in> S \\<union> T \\<inter> B \\<Gamma>\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>\\<epsilon>>0.\n               \\<epsilon> < \\<delta> \\<and>\n               \\<not> hindered\n                       (reduce_weight \\<Gamma> b\n                         \\<epsilon>)) \\<Longrightarrow>\n    False", "have S_vertex: \"vertex \\<Gamma>_h x\" if \"x \\<in> S\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. vertex \\<Gamma>_h x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. vertex \\<Gamma>_h x", "from that"], ["proof (chain)\npicking this:\n  x \\<in> S", "have a: \"x \\<in> A \\<Gamma>\" and RF: \"x \\<in> RF (T \\<inter> B \\<Gamma>)\" and ess: \"essential \\<Gamma> (T \\<inter> B \\<Gamma>) (RF (T \\<inter> B \\<Gamma>) \\<inter> A \\<Gamma>) x\""], ["proof (prove)\nusing this:\n  x \\<in> S\n\ngoal (1 subgoal):\n 1. x \\<in> A \\<Gamma> &&&\n    x \\<in> RF (T \\<inter> B \\<Gamma>) &&&\n    essential \\<Gamma> (T \\<inter> B \\<Gamma>)\n     (RF (T \\<inter> B \\<Gamma>) \\<inter> A \\<Gamma>) x", "by(simp_all add: S_def)"], ["proof (state)\nthis:\n  x \\<in> A \\<Gamma>\n  x \\<in> RF (T \\<inter> B \\<Gamma>)\n  essential \\<Gamma> (T \\<inter> B \\<Gamma>)\n   (RF (T \\<inter> B \\<Gamma>) \\<inter> A \\<Gamma>) x\n\ngoal (1 subgoal):\n 1. vertex \\<Gamma>_h x", "from ess"], ["proof (chain)\npicking this:\n  essential \\<Gamma> (T \\<inter> B \\<Gamma>)\n   (RF (T \\<inter> B \\<Gamma>) \\<inter> A \\<Gamma>) x", "obtain p y where p: \"path \\<Gamma> x p y\" and y: \"y \\<in> B \\<Gamma>\" and yT: \"y \\<in> T\"\n      and bypass: \"\\<And>z. z \\<in> set p \\<Longrightarrow> z \\<notin> RF (T \\<inter> B \\<Gamma>) \\<inter> A \\<Gamma>\""], ["proof (prove)\nusing this:\n  essential \\<Gamma> (T \\<inter> B \\<Gamma>)\n   (RF (T \\<inter> B \\<Gamma>) \\<inter> A \\<Gamma>) x\n\ngoal (1 subgoal):\n 1. (\\<And>p y.\n        \\<lbrakk>path \\<Gamma> x p y; y \\<in> B \\<Gamma>; y \\<in> T;\n         \\<And>z.\n            z \\<in> set p \\<Longrightarrow>\n            z \\<notin> RF (T \\<inter> B \\<Gamma>) \\<inter>\n                       A \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(rule essentialE_RF)(auto intro: roofed_greaterI)"], ["proof (state)\nthis:\n  path \\<Gamma> x p y\n  y \\<in> B \\<Gamma>\n  y \\<in> T\n  ?z \\<in> set p \\<Longrightarrow>\n  ?z \\<notin> RF (T \\<inter> B \\<Gamma>) \\<inter> A \\<Gamma>\n\ngoal (1 subgoal):\n 1. vertex \\<Gamma>_h x", "from p a y disjoint"], ["proof (chain)\npicking this:\n  path \\<Gamma> x p y\n  x \\<in> A \\<Gamma>\n  y \\<in> B \\<Gamma>\n  A \\<Gamma> \\<inter> B \\<Gamma> = {}", "have \"edge \\<Gamma> x y\""], ["proof (prove)\nusing this:\n  path \\<Gamma> x p y\n  x \\<in> A \\<Gamma>\n  y \\<in> B \\<Gamma>\n  A \\<Gamma> \\<inter> B \\<Gamma> = {}\n\ngoal (1 subgoal):\n 1. edge \\<Gamma> x y", "by(cases)(auto 4 3 elim: rtrancl_path.cases dest: bipartite_E)"], ["proof (state)\nthis:\n  edge \\<Gamma> x y\n\ngoal (1 subgoal):\n 1. vertex \\<Gamma>_h x", "with that y yT"], ["proof (chain)\npicking this:\n  x \\<in> S\n  y \\<in> B \\<Gamma>\n  y \\<in> T\n  edge \\<Gamma> x y", "show ?thesis"], ["proof (prove)\nusing this:\n  x \\<in> S\n  y \\<in> B \\<Gamma>\n  y \\<in> T\n  edge \\<Gamma> x y\n\ngoal (1 subgoal):\n 1. vertex \\<Gamma>_h x", "by(auto intro!: vertexI1)"], ["proof (state)\nthis:\n  vertex \\<Gamma>_h x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?x \\<in> S \\<Longrightarrow> vertex \\<Gamma>_h ?x\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>\\<epsilon>>0.\n               \\<epsilon> < \\<delta> \\<and>\n               \\<not> hindered\n                       (reduce_weight \\<Gamma> b\n                         \\<epsilon>)) \\<Longrightarrow>\n    False", "have OUT_not_S: \"d_OUT (h n) x = 0\" if \"x \\<notin> S\" for x n"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT (h n) x = 0", "proof(rule classical)"], ["proof (state)\ngoal (1 subgoal):\n 1. d_OUT (h n) x \\<noteq> 0 \\<Longrightarrow> d_OUT (h n) x = 0", "assume *: \"d_OUT (h n) x \\<noteq> 0\""], ["proof (state)\nthis:\n  d_OUT (h n) x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. d_OUT (h n) x \\<noteq> 0 \\<Longrightarrow> d_OUT (h n) x = 0", "consider (A) \"x \\<in> A \\<Gamma>\" | (B) \"x \\<in> B \\<Gamma>\" | (outside) \"x \\<notin> A \\<Gamma>\" \"x \\<notin> B \\<Gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> A \\<Gamma> \\<Longrightarrow> thesis;\n     x \\<in> B \\<Gamma> \\<Longrightarrow> thesis;\n     \\<lbrakk>x \\<notin> A \\<Gamma>; x \\<notin> B \\<Gamma>\\<rbrakk>\n     \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by blast"], ["proof (state)\nthis:\n  \\<lbrakk>x \\<in> A \\<Gamma> \\<Longrightarrow> ?thesis;\n   x \\<in> B \\<Gamma> \\<Longrightarrow> ?thesis;\n   \\<lbrakk>x \\<notin> A \\<Gamma>; x \\<notin> B \\<Gamma>\\<rbrakk>\n   \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. d_OUT (h n) x \\<noteq> 0 \\<Longrightarrow> d_OUT (h n) x = 0", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>x \\<in> A \\<Gamma> \\<Longrightarrow> ?thesis;\n   x \\<in> B \\<Gamma> \\<Longrightarrow> ?thesis;\n   \\<lbrakk>x \\<notin> A \\<Gamma>; x \\<notin> B \\<Gamma>\\<rbrakk>\n   \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>x \\<in> A \\<Gamma> \\<Longrightarrow> ?thesis;\n   x \\<in> B \\<Gamma> \\<Longrightarrow> ?thesis;\n   \\<lbrakk>x \\<notin> A \\<Gamma>; x \\<notin> B \\<Gamma>\\<rbrakk>\n   \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. d_OUT (h n) x = 0", "proof cases"], ["proof (state)\ngoal (3 subgoals):\n 1. x \\<in> A \\<Gamma> \\<Longrightarrow> d_OUT (h n) x = 0\n 2. x \\<in> B \\<Gamma> \\<Longrightarrow> d_OUT (h n) x = 0\n 3. \\<lbrakk>x \\<notin> A \\<Gamma>; x \\<notin> B \\<Gamma>\\<rbrakk>\n    \\<Longrightarrow> d_OUT (h n) x = 0", "case B"], ["proof (state)\nthis:\n  x \\<in> B \\<Gamma>\n\ngoal (3 subgoals):\n 1. x \\<in> A \\<Gamma> \\<Longrightarrow> d_OUT (h n) x = 0\n 2. x \\<in> B \\<Gamma> \\<Longrightarrow> d_OUT (h n) x = 0\n 3. \\<lbrakk>x \\<notin> A \\<Gamma>; x \\<notin> B \\<Gamma>\\<rbrakk>\n    \\<Longrightarrow> d_OUT (h n) x = 0", "with currentD_OUT[OF h, of x n]"], ["proof (chain)\npicking this:\n  x \\<in> B (\\<Gamma>' n) \\<Longrightarrow> d_OUT (h n) x = 0\n  x \\<in> B \\<Gamma>", "show ?thesis"], ["proof (prove)\nusing this:\n  x \\<in> B (\\<Gamma>' n) \\<Longrightarrow> d_OUT (h n) x = 0\n  x \\<in> B \\<Gamma>\n\ngoal (1 subgoal):\n 1. d_OUT (h n) x = 0", "by simp"], ["proof (state)\nthis:\n  d_OUT (h n) x = 0\n\ngoal (2 subgoals):\n 1. x \\<in> A \\<Gamma> \\<Longrightarrow> d_OUT (h n) x = 0\n 2. \\<lbrakk>x \\<notin> A \\<Gamma>; x \\<notin> B \\<Gamma>\\<rbrakk>\n    \\<Longrightarrow> d_OUT (h n) x = 0", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<in> A \\<Gamma> \\<Longrightarrow> d_OUT (h n) x = 0\n 2. \\<lbrakk>x \\<notin> A \\<Gamma>; x \\<notin> B \\<Gamma>\\<rbrakk>\n    \\<Longrightarrow> d_OUT (h n) x = 0", "case outside"], ["proof (state)\nthis:\n  x \\<notin> A \\<Gamma>\n  x \\<notin> B \\<Gamma>\n\ngoal (2 subgoals):\n 1. x \\<in> A \\<Gamma> \\<Longrightarrow> d_OUT (h n) x = 0\n 2. \\<lbrakk>x \\<notin> A \\<Gamma>; x \\<notin> B \\<Gamma>\\<rbrakk>\n    \\<Longrightarrow> d_OUT (h n) x = 0", "with currentD_outside_OUT[OF h, of x n]"], ["proof (chain)\npicking this:\n  x \\<notin> \\<^bold>V\\<^bsub>\\<Gamma>' n\\<^esub> \\<Longrightarrow>\n  d_OUT (h n) x = 0\n  x \\<notin> A \\<Gamma>\n  x \\<notin> B \\<Gamma>", "show ?thesis"], ["proof (prove)\nusing this:\n  x \\<notin> \\<^bold>V\\<^bsub>\\<Gamma>' n\\<^esub> \\<Longrightarrow>\n  d_OUT (h n) x = 0\n  x \\<notin> A \\<Gamma>\n  x \\<notin> B \\<Gamma>\n\ngoal (1 subgoal):\n 1. d_OUT (h n) x = 0", "by(simp add: not_vertex)"], ["proof (state)\nthis:\n  d_OUT (h n) x = 0\n\ngoal (1 subgoal):\n 1. x \\<in> A \\<Gamma> \\<Longrightarrow> d_OUT (h n) x = 0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<in> A \\<Gamma> \\<Longrightarrow> d_OUT (h n) x = 0", "case A"], ["proof (state)\nthis:\n  x \\<in> A \\<Gamma>\n\ngoal (1 subgoal):\n 1. x \\<in> A \\<Gamma> \\<Longrightarrow> d_OUT (h n) x = 0", "from *"], ["proof (chain)\npicking this:\n  d_OUT (h n) x \\<noteq> 0", "obtain y where xy: \"h n (x, y) \\<noteq> 0\""], ["proof (prove)\nusing this:\n  d_OUT (h n) x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        h n (x, y) \\<noteq> 0 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using currentD_OUT_eq_0[OF h, of n x]"], ["proof (prove)\nusing this:\n  d_OUT (h n) x \\<noteq> 0\n  (d_OUT (h n) x = 0) = (\\<forall>y. h n (x, y) = 0)\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        h n (x, y) \\<noteq> 0 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  h n (x, y) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. x \\<in> A \\<Gamma> \\<Longrightarrow> d_OUT (h n) x = 0", "then"], ["proof (chain)\npicking this:\n  h n (x, y) \\<noteq> 0", "have edge: \"edge \\<Gamma> x y\""], ["proof (prove)\nusing this:\n  h n (x, y) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. edge \\<Gamma> x y", "using currentD_outside[OF h]"], ["proof (prove)\nusing this:\n  h n (x, y) \\<noteq> 0\n  \\<not> edge (\\<Gamma>' ?n1) ?x ?y \\<Longrightarrow> h ?n1 (?x, ?y) = 0\n\ngoal (1 subgoal):\n 1. edge \\<Gamma> x y", "by(auto)"], ["proof (state)\nthis:\n  edge \\<Gamma> x y\n\ngoal (1 subgoal):\n 1. x \\<in> A \\<Gamma> \\<Longrightarrow> d_OUT (h n) x = 0", "hence p: \"path \\<Gamma> x [y] y\""], ["proof (prove)\nusing this:\n  edge \\<Gamma> x y\n\ngoal (1 subgoal):\n 1. path \\<Gamma> x [y] y", "by(simp add: rtrancl_path_simps)"], ["proof (state)\nthis:\n  path \\<Gamma> x [y] y\n\ngoal (1 subgoal):\n 1. x \\<in> A \\<Gamma> \\<Longrightarrow> d_OUT (h n) x = 0", "from bipartite_E[OF edge]"], ["proof (chain)\npicking this:\n  x \\<in> A \\<Gamma> \\<and> y \\<in> B \\<Gamma>", "have x: \"x \\<in> A \\<Gamma>\" and y: \"y \\<in> B \\<Gamma>\""], ["proof (prove)\nusing this:\n  x \\<in> A \\<Gamma> \\<and> y \\<in> B \\<Gamma>\n\ngoal (1 subgoal):\n 1. x \\<in> A \\<Gamma> &&& y \\<in> B \\<Gamma>", "by simp_all"], ["proof (state)\nthis:\n  x \\<in> A \\<Gamma>\n  y \\<in> B \\<Gamma>\n\ngoal (1 subgoal):\n 1. x \\<in> A \\<Gamma> \\<Longrightarrow> d_OUT (h n) x = 0", "moreover"], ["proof (state)\nthis:\n  x \\<in> A \\<Gamma>\n  y \\<in> B \\<Gamma>\n\ngoal (1 subgoal):\n 1. x \\<in> A \\<Gamma> \\<Longrightarrow> d_OUT (h n) x = 0", "have \"x \\<in> RF (RF (T \\<inter> B \\<Gamma>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> RF (RF (T \\<inter> B \\<Gamma>))", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p y.\n       \\<lbrakk>path \\<Gamma> x p y; y \\<in> B \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>z\\<in>set p.\n                             z \\<in> RF (T \\<inter> B \\<Gamma>)) \\<or>\n                         x \\<in> RF (T \\<inter> B \\<Gamma>)", "fix p y'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p y.\n       \\<lbrakk>path \\<Gamma> x p y; y \\<in> B \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>z\\<in>set p.\n                             z \\<in> RF (T \\<inter> B \\<Gamma>)) \\<or>\n                         x \\<in> RF (T \\<inter> B \\<Gamma>)", "assume p: \"path \\<Gamma> x p y'\" and y': \"y' \\<in> B \\<Gamma>\""], ["proof (state)\nthis:\n  path \\<Gamma> x p y'\n  y' \\<in> B \\<Gamma>\n\ngoal (1 subgoal):\n 1. \\<And>p y.\n       \\<lbrakk>path \\<Gamma> x p y; y \\<in> B \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>z\\<in>set p.\n                             z \\<in> RF (T \\<inter> B \\<Gamma>)) \\<or>\n                         x \\<in> RF (T \\<inter> B \\<Gamma>)", "from p x y' disjoint"], ["proof (chain)\npicking this:\n  path \\<Gamma> x p y'\n  x \\<in> A \\<Gamma>\n  y' \\<in> B \\<Gamma>\n  A \\<Gamma> \\<inter> B \\<Gamma> = {}", "have py: \"p = [y']\""], ["proof (prove)\nusing this:\n  path \\<Gamma> x p y'\n  x \\<in> A \\<Gamma>\n  y' \\<in> B \\<Gamma>\n  A \\<Gamma> \\<inter> B \\<Gamma> = {}\n\ngoal (1 subgoal):\n 1. p = [y']", "by(cases)(auto 4 3 elim: rtrancl_path.cases dest: bipartite_E)"], ["proof (state)\nthis:\n  p = [y']\n\ngoal (1 subgoal):\n 1. \\<And>p y.\n       \\<lbrakk>path \\<Gamma> x p y; y \\<in> B \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>z\\<in>set p.\n                             z \\<in> RF (T \\<inter> B \\<Gamma>)) \\<or>\n                         x \\<in> RF (T \\<inter> B \\<Gamma>)", "have \"separating (\\<Gamma>' 0) (RF\\<^bsub>\\<Gamma>' 0\\<^esub> (TER\\<^bsub>\\<Gamma>' 0\\<^esub> (h 0)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. separating (\\<Gamma>' 0)\n     (RF\\<^bsub>\\<Gamma>' 0\\<^esub> (TER\\<^bsub>\\<Gamma>' 0\\<^esub> (h 0)))", "unfolding separating_RF"], ["proof (prove)\ngoal (1 subgoal):\n 1. separating (\\<Gamma>' 0) (TER\\<^bsub>\\<Gamma>' 0\\<^esub> (h 0))", "by(rule waveD_separating[OF hw])"], ["proof (state)\nthis:\n  separating (\\<Gamma>' 0)\n   (RF\\<^bsub>\\<Gamma>' 0\\<^esub> (TER\\<^bsub>\\<Gamma>' 0\\<^esub> (h 0)))\n\ngoal (1 subgoal):\n 1. \\<And>p y.\n       \\<lbrakk>path \\<Gamma> x p y; y \\<in> B \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>z\\<in>set p.\n                             z \\<in> RF (T \\<inter> B \\<Gamma>)) \\<or>\n                         x \\<in> RF (T \\<inter> B \\<Gamma>)", "from separatingD[OF this, of x p y'] py p x y'"], ["proof (chain)\npicking this:\n  \\<lbrakk>path (\\<Gamma>' 0) x p y'; x \\<in> A (\\<Gamma>' 0);\n   y' \\<in> B (\\<Gamma>' 0)\\<rbrakk>\n  \\<Longrightarrow> (\\<exists>z\\<in>set p.\n                        z \\<in> RF\\<^bsub>\\<Gamma>' 0\\<^esub>\n                                 (TER\\<^bsub>\\<Gamma>' 0\\<^esub>\n                                   (h 0))) \\<or>\n                    x \\<in> RF\\<^bsub>\\<Gamma>' 0\\<^esub>\n                             (TER\\<^bsub>\\<Gamma>' 0\\<^esub> (h 0))\n  p = [y']\n  path \\<Gamma> x p y'\n  x \\<in> A \\<Gamma>\n  y' \\<in> B \\<Gamma>", "have \"x \\<in> RF T \\<or> y' \\<in> RF T\""], ["proof (prove)\nusing this:\n  \\<lbrakk>path (\\<Gamma>' 0) x p y'; x \\<in> A (\\<Gamma>' 0);\n   y' \\<in> B (\\<Gamma>' 0)\\<rbrakk>\n  \\<Longrightarrow> (\\<exists>z\\<in>set p.\n                        z \\<in> RF\\<^bsub>\\<Gamma>' 0\\<^esub>\n                                 (TER\\<^bsub>\\<Gamma>' 0\\<^esub>\n                                   (h 0))) \\<or>\n                    x \\<in> RF\\<^bsub>\\<Gamma>' 0\\<^esub>\n                             (TER\\<^bsub>\\<Gamma>' 0\\<^esub> (h 0))\n  p = [y']\n  path \\<Gamma> x p y'\n  x \\<in> A \\<Gamma>\n  y' \\<in> B \\<Gamma>\n\ngoal (1 subgoal):\n 1. x \\<in> RF T \\<or> y' \\<in> RF T", "by(auto simp add: RF_h)"], ["proof (state)\nthis:\n  x \\<in> RF T \\<or> y' \\<in> RF T\n\ngoal (1 subgoal):\n 1. \\<And>p y.\n       \\<lbrakk>path \\<Gamma> x p y; y \\<in> B \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>z\\<in>set p.\n                             z \\<in> RF (T \\<inter> B \\<Gamma>)) \\<or>\n                         x \\<in> RF (T \\<inter> B \\<Gamma>)", "thus \"(\\<exists>z\\<in>set p. z \\<in> RF (T \\<inter> B \\<Gamma>)) \\<or> x \\<in> RF (T \\<inter> B \\<Gamma>)\""], ["proof (prove)\nusing this:\n  x \\<in> RF T \\<or> y' \\<in> RF T\n\ngoal (1 subgoal):\n 1. (\\<exists>z\\<in>set p. z \\<in> RF (T \\<inter> B \\<Gamma>)) \\<or>\n    x \\<in> RF (T \\<inter> B \\<Gamma>)", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<in> RF T \\<Longrightarrow>\n    (\\<exists>z\\<in>set p. z \\<in> RF (T \\<inter> B \\<Gamma>)) \\<or>\n    x \\<in> RF (T \\<inter> B \\<Gamma>)\n 2. y' \\<in> RF T \\<Longrightarrow>\n    (\\<exists>z\\<in>set p. z \\<in> RF (T \\<inter> B \\<Gamma>)) \\<or>\n    x \\<in> RF (T \\<inter> B \\<Gamma>)", "case right"], ["proof (state)\nthis:\n  y' \\<in> RF T\n\ngoal (2 subgoals):\n 1. x \\<in> RF T \\<Longrightarrow>\n    (\\<exists>z\\<in>set p. z \\<in> RF (T \\<inter> B \\<Gamma>)) \\<or>\n    x \\<in> RF (T \\<inter> B \\<Gamma>)\n 2. y' \\<in> RF T \\<Longrightarrow>\n    (\\<exists>z\\<in>set p. z \\<in> RF (T \\<inter> B \\<Gamma>)) \\<or>\n    x \\<in> RF (T \\<inter> B \\<Gamma>)", "with y' py"], ["proof (chain)\npicking this:\n  y' \\<in> B \\<Gamma>\n  p = [y']\n  y' \\<in> RF T", "show ?thesis"], ["proof (prove)\nusing this:\n  y' \\<in> B \\<Gamma>\n  p = [y']\n  y' \\<in> RF T\n\ngoal (1 subgoal):\n 1. (\\<exists>z\\<in>set p. z \\<in> RF (T \\<inter> B \\<Gamma>)) \\<or>\n    x \\<in> RF (T \\<inter> B \\<Gamma>)", "by(simp add: RF_in_B)"], ["proof (state)\nthis:\n  (\\<exists>z\\<in>set p. z \\<in> RF (T \\<inter> B \\<Gamma>)) \\<or>\n  x \\<in> RF (T \\<inter> B \\<Gamma>)\n\ngoal (1 subgoal):\n 1. x \\<in> RF T \\<Longrightarrow>\n    (\\<exists>z\\<in>set p. z \\<in> RF (T \\<inter> B \\<Gamma>)) \\<or>\n    x \\<in> RF (T \\<inter> B \\<Gamma>)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<in> RF T \\<Longrightarrow>\n    (\\<exists>z\\<in>set p. z \\<in> RF (T \\<inter> B \\<Gamma>)) \\<or>\n    x \\<in> RF (T \\<inter> B \\<Gamma>)", "case left"], ["proof (state)\nthis:\n  x \\<in> RF T\n\ngoal (1 subgoal):\n 1. x \\<in> RF T \\<Longrightarrow>\n    (\\<exists>z\\<in>set p. z \\<in> RF (T \\<inter> B \\<Gamma>)) \\<or>\n    x \\<in> RF (T \\<inter> B \\<Gamma>)", "have \"x \\<notin> \\<E> T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> \\<E> T", "using OUT_h_\\<E>[of x n] xy"], ["proof (prove)\nusing this:\n  x \\<in> \\<E> T \\<Longrightarrow> d_OUT (h n) x = 0\n  h n (x, y) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. x \\<notin> \\<E> T", "by(auto simp add: currentD_OUT_eq_0[OF h])"], ["proof (state)\nthis:\n  x \\<notin> \\<E> T\n\ngoal (1 subgoal):\n 1. x \\<in> RF T \\<Longrightarrow>\n    (\\<exists>z\\<in>set p. z \\<in> RF (T \\<inter> B \\<Gamma>)) \\<or>\n    x \\<in> RF (T \\<inter> B \\<Gamma>)", "with left"], ["proof (chain)\npicking this:\n  x \\<in> RF T\n  x \\<notin> \\<E> T", "have \"x \\<in> RF\\<^sup>\\<circ> T\""], ["proof (prove)\nusing this:\n  x \\<in> RF T\n  x \\<notin> \\<E> T\n\ngoal (1 subgoal):\n 1. x \\<in> RF\\<^sup>\\<circ> T", "by(simp add: roofed_circ_def)"], ["proof (state)\nthis:\n  x \\<in> RF\\<^sup>\\<circ> T\n\ngoal (1 subgoal):\n 1. x \\<in> RF T \\<Longrightarrow>\n    (\\<exists>z\\<in>set p. z \\<in> RF (T \\<inter> B \\<Gamma>)) \\<or>\n    x \\<in> RF (T \\<inter> B \\<Gamma>)", "from RF_circ_edge_forward[OF this, of y'] p py"], ["proof (chain)\npicking this:\n  edge \\<Gamma> x y' \\<Longrightarrow> y' \\<in> RF T\n  path \\<Gamma> x p y'\n  p = [y']", "have \"y' \\<in> RF T\""], ["proof (prove)\nusing this:\n  edge \\<Gamma> x y' \\<Longrightarrow> y' \\<in> RF T\n  path \\<Gamma> x p y'\n  p = [y']\n\ngoal (1 subgoal):\n 1. y' \\<in> RF T", "by(simp add: rtrancl_path_simps)"], ["proof (state)\nthis:\n  y' \\<in> RF T\n\ngoal (1 subgoal):\n 1. x \\<in> RF T \\<Longrightarrow>\n    (\\<exists>z\\<in>set p. z \\<in> RF (T \\<inter> B \\<Gamma>)) \\<or>\n    x \\<in> RF (T \\<inter> B \\<Gamma>)", "with y'"], ["proof (chain)\npicking this:\n  y' \\<in> B \\<Gamma>\n  y' \\<in> RF T", "have \"y' \\<in> T\""], ["proof (prove)\nusing this:\n  y' \\<in> B \\<Gamma>\n  y' \\<in> RF T\n\ngoal (1 subgoal):\n 1. y' \\<in> T", "by(simp add: RF_in_B)"], ["proof (state)\nthis:\n  y' \\<in> T\n\ngoal (1 subgoal):\n 1. x \\<in> RF T \\<Longrightarrow>\n    (\\<exists>z\\<in>set p. z \\<in> RF (T \\<inter> B \\<Gamma>)) \\<or>\n    x \\<in> RF (T \\<inter> B \\<Gamma>)", "with y'"], ["proof (chain)\npicking this:\n  y' \\<in> B \\<Gamma>\n  y' \\<in> T", "show ?thesis"], ["proof (prove)\nusing this:\n  y' \\<in> B \\<Gamma>\n  y' \\<in> T\n\ngoal (1 subgoal):\n 1. (\\<exists>z\\<in>set p. z \\<in> RF (T \\<inter> B \\<Gamma>)) \\<or>\n    x \\<in> RF (T \\<inter> B \\<Gamma>)", "using py"], ["proof (prove)\nusing this:\n  y' \\<in> B \\<Gamma>\n  y' \\<in> T\n  p = [y']\n\ngoal (1 subgoal):\n 1. (\\<exists>z\\<in>set p. z \\<in> RF (T \\<inter> B \\<Gamma>)) \\<or>\n    x \\<in> RF (T \\<inter> B \\<Gamma>)", "by(auto intro: roofed_greaterI)"], ["proof (state)\nthis:\n  (\\<exists>z\\<in>set p. z \\<in> RF (T \\<inter> B \\<Gamma>)) \\<or>\n  x \\<in> RF (T \\<inter> B \\<Gamma>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<exists>z\\<in>set p. z \\<in> RF (T \\<inter> B \\<Gamma>)) \\<or>\n  x \\<in> RF (T \\<inter> B \\<Gamma>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x \\<in> RF (RF (T \\<inter> B \\<Gamma>))\n\ngoal (1 subgoal):\n 1. x \\<in> A \\<Gamma> \\<Longrightarrow> d_OUT (h n) x = 0", "moreover"], ["proof (state)\nthis:\n  x \\<in> RF (RF (T \\<inter> B \\<Gamma>))\n\ngoal (1 subgoal):\n 1. x \\<in> A \\<Gamma> \\<Longrightarrow> d_OUT (h n) x = 0", "have \"y \\<in> T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<in> T", "using IN_h_nT[of y n] y xy"], ["proof (prove)\nusing this:\n  y \\<notin> RF T \\<Longrightarrow> d_IN (h n) y = 0\n  y \\<in> B \\<Gamma>\n  h n (x, y) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. y \\<in> T", "by(auto simp add: RF_in_B currentD_IN_eq_0[OF h])"], ["proof (state)\nthis:\n  y \\<in> T\n\ngoal (1 subgoal):\n 1. x \\<in> A \\<Gamma> \\<Longrightarrow> d_OUT (h n) x = 0", "with p x y disjoint"], ["proof (chain)\npicking this:\n  path \\<Gamma> x [y] y\n  x \\<in> A \\<Gamma>\n  y \\<in> B \\<Gamma>\n  A \\<Gamma> \\<inter> B \\<Gamma> = {}\n  y \\<in> T", "have \"essential \\<Gamma> (T \\<inter> B \\<Gamma>) (RF (T \\<inter> B \\<Gamma>) \\<inter> A \\<Gamma>) x\""], ["proof (prove)\nusing this:\n  path \\<Gamma> x [y] y\n  x \\<in> A \\<Gamma>\n  y \\<in> B \\<Gamma>\n  A \\<Gamma> \\<inter> B \\<Gamma> = {}\n  y \\<in> T\n\ngoal (1 subgoal):\n 1. essential \\<Gamma> (T \\<inter> B \\<Gamma>)\n     (RF (T \\<inter> B \\<Gamma>) \\<inter> A \\<Gamma>) x", "by(auto intro!: essentialI)"], ["proof (state)\nthis:\n  essential \\<Gamma> (T \\<inter> B \\<Gamma>)\n   (RF (T \\<inter> B \\<Gamma>) \\<inter> A \\<Gamma>) x\n\ngoal (1 subgoal):\n 1. x \\<in> A \\<Gamma> \\<Longrightarrow> d_OUT (h n) x = 0", "ultimately"], ["proof (chain)\npicking this:\n  x \\<in> A \\<Gamma>\n  y \\<in> B \\<Gamma>\n  x \\<in> RF (RF (T \\<inter> B \\<Gamma>))\n  essential \\<Gamma> (T \\<inter> B \\<Gamma>)\n   (RF (T \\<inter> B \\<Gamma>) \\<inter> A \\<Gamma>) x", "have \"x \\<in> S\""], ["proof (prove)\nusing this:\n  x \\<in> A \\<Gamma>\n  y \\<in> B \\<Gamma>\n  x \\<in> RF (RF (T \\<inter> B \\<Gamma>))\n  essential \\<Gamma> (T \\<inter> B \\<Gamma>)\n   (RF (T \\<inter> B \\<Gamma>) \\<inter> A \\<Gamma>) x\n\ngoal (1 subgoal):\n 1. x \\<in> S", "unfolding roofed_idem"], ["proof (prove)\nusing this:\n  x \\<in> A \\<Gamma>\n  y \\<in> B \\<Gamma>\n  x \\<in> RF (T \\<inter> B \\<Gamma>)\n  essential \\<Gamma> (T \\<inter> B \\<Gamma>)\n   (RF (T \\<inter> B \\<Gamma>) \\<inter> A \\<Gamma>) x\n\ngoal (1 subgoal):\n 1. x \\<in> S", "by(simp add: S_def)"], ["proof (state)\nthis:\n  x \\<in> S\n\ngoal (1 subgoal):\n 1. x \\<in> A \\<Gamma> \\<Longrightarrow> d_OUT (h n) x = 0", "with that"], ["proof (chain)\npicking this:\n  x \\<notin> S\n  x \\<in> S", "show ?thesis"], ["proof (prove)\nusing this:\n  x \\<notin> S\n  x \\<in> S\n\ngoal (1 subgoal):\n 1. d_OUT (h n) x = 0", "by contradiction"], ["proof (state)\nthis:\n  d_OUT (h n) x = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  d_OUT (h n) x = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?x \\<notin> S \\<Longrightarrow> d_OUT (h ?n) ?x = 0\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>\\<epsilon>>0.\n               \\<epsilon> < \\<delta> \\<and>\n               \\<not> hindered\n                       (reduce_weight \\<Gamma> b\n                         \\<epsilon>)) \\<Longrightarrow>\n    False", "have B_vertex: \"vertex \\<Gamma>_h y\" if T: \"y \\<in> T\" and B: \"y \\<in> B \\<Gamma>\" and w: \"weight \\<Gamma> y > 0\" for y"], ["proof (prove)\ngoal (1 subgoal):\n 1. vertex \\<Gamma>_h y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. vertex \\<Gamma>_h y", "from T B disjoint \\<epsilon>_less[of 0] w"], ["proof (chain)\npicking this:\n  y \\<in> T\n  y \\<in> B \\<Gamma>\n  A \\<Gamma> \\<inter> B \\<Gamma> = {}\n  \\<epsilon> 0 < wb\n  0 < weight \\<Gamma> y", "have \"d_IN (h 0) y > 0\""], ["proof (prove)\nusing this:\n  y \\<in> T\n  y \\<in> B \\<Gamma>\n  A \\<Gamma> \\<inter> B \\<Gamma> = {}\n  \\<epsilon> 0 < wb\n  0 < weight \\<Gamma> y\n\ngoal (1 subgoal):\n 1. 0 < d_IN (h 0) y", "using IN_h_\\<E>[of y 0]"], ["proof (prove)\nusing this:\n  y \\<in> T\n  y \\<in> B \\<Gamma>\n  A \\<Gamma> \\<inter> B \\<Gamma> = {}\n  \\<epsilon> 0 < wb\n  0 < weight \\<Gamma> y\n  \\<lbrakk>y \\<in> \\<E> T; y \\<notin> A \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> d_IN (h 0) y = weight (\\<Gamma>' 0) y\n\ngoal (1 subgoal):\n 1. 0 < d_IN (h 0) y", "by(cases \"y \\<in> A \\<Gamma>\")(auto simp add: essential_BI wb_conv ennreal_minus_if)"], ["proof (state)\nthis:\n  0 < d_IN (h 0) y\n\ngoal (1 subgoal):\n 1. vertex \\<Gamma>_h y", "then"], ["proof (chain)\npicking this:\n  0 < d_IN (h 0) y", "obtain x where xy: \"h 0 (x, y) \\<noteq> 0\""], ["proof (prove)\nusing this:\n  0 < d_IN (h 0) y\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        h 0 (x, y) \\<noteq> 0 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using currentD_IN_eq_0[OF h, of 0 y]"], ["proof (prove)\nusing this:\n  0 < d_IN (h 0) y\n  (d_IN (h 0) y = 0) = (\\<forall>ya. h 0 (ya, y) = 0)\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        h 0 (x, y) \\<noteq> 0 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto)"], ["proof (state)\nthis:\n  h 0 (x, y) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. vertex \\<Gamma>_h y", "then"], ["proof (chain)\npicking this:\n  h 0 (x, y) \\<noteq> 0", "have edge: \"edge \\<Gamma> x y\""], ["proof (prove)\nusing this:\n  h 0 (x, y) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. edge \\<Gamma> x y", "using currentD_outside[OF h]"], ["proof (prove)\nusing this:\n  h 0 (x, y) \\<noteq> 0\n  \\<not> edge (\\<Gamma>' ?n1) ?x ?y \\<Longrightarrow> h ?n1 (?x, ?y) = 0\n\ngoal (1 subgoal):\n 1. edge \\<Gamma> x y", "by(auto)"], ["proof (state)\nthis:\n  edge \\<Gamma> x y\n\ngoal (1 subgoal):\n 1. vertex \\<Gamma>_h y", "from xy"], ["proof (chain)\npicking this:\n  h 0 (x, y) \\<noteq> 0", "have \"d_OUT (h 0) x \\<noteq> 0\""], ["proof (prove)\nusing this:\n  h 0 (x, y) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. d_OUT (h 0) x \\<noteq> 0", "by(auto simp add: currentD_OUT_eq_0[OF h])"], ["proof (state)\nthis:\n  d_OUT (h 0) x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. vertex \\<Gamma>_h y", "hence \"x \\<in> S\""], ["proof (prove)\nusing this:\n  d_OUT (h 0) x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. x \\<in> S", "using OUT_not_S[of x 0]"], ["proof (prove)\nusing this:\n  d_OUT (h 0) x \\<noteq> 0\n  x \\<notin> S \\<Longrightarrow> d_OUT (h 0) x = 0\n\ngoal (1 subgoal):\n 1. x \\<in> S", "by(auto)"], ["proof (state)\nthis:\n  x \\<in> S\n\ngoal (1 subgoal):\n 1. vertex \\<Gamma>_h y", "with edge T B"], ["proof (chain)\npicking this:\n  edge \\<Gamma> x y\n  y \\<in> T\n  y \\<in> B \\<Gamma>\n  x \\<in> S", "show ?thesis"], ["proof (prove)\nusing this:\n  edge \\<Gamma> x y\n  y \\<in> T\n  y \\<in> B \\<Gamma>\n  x \\<in> S\n\ngoal (1 subgoal):\n 1. vertex \\<Gamma>_h y", "by(simp add: vertexI2)"], ["proof (state)\nthis:\n  vertex \\<Gamma>_h y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>?y \\<in> T; ?y \\<in> B \\<Gamma>; 0 < weight \\<Gamma> ?y\\<rbrakk>\n  \\<Longrightarrow> vertex \\<Gamma>_h ?y\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>\\<epsilon>>0.\n               \\<epsilon> < \\<delta> \\<and>\n               \\<not> hindered\n                       (reduce_weight \\<Gamma> b\n                         \\<epsilon>)) \\<Longrightarrow>\n    False", "have \\<Gamma>_h: \"countable_bipartite_web \\<Gamma>_h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. countable_bipartite_web \\<Gamma>_h", "proof"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<^bold>V\\<^bsub>\\<Gamma>_h\\<^esub>\n    \\<subseteq> A \\<Gamma>_h \\<union> B \\<Gamma>_h\n 2. A \\<Gamma>_h \\<subseteq> \\<^bold>V\\<^bsub>\\<Gamma>_h\\<^esub>\n 3. \\<And>x y.\n       edge \\<Gamma>_h x y \\<Longrightarrow>\n       x \\<in> A \\<Gamma>_h \\<and> y \\<in> B \\<Gamma>_h\n 4. A \\<Gamma>_h \\<inter> B \\<Gamma>_h = {}\n 5. \\<And>x.\n       x \\<notin> \\<^bold>V\\<^bsub>\\<Gamma>_h\\<^esub> \\<Longrightarrow>\n       weight \\<Gamma>_h x = 0\n 6. \\<And>x. weight \\<Gamma>_h x \\<noteq> \\<top>\n 7. countable \\<^bold>E\\<^bsub>\\<Gamma>_h\\<^esub>", "show \"\\<^bold>V\\<^bsub>\\<Gamma>_h\\<^esub> \\<subseteq> A \\<Gamma>_h \\<union> B \\<Gamma>_h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<^bold>V\\<^bsub>\\<Gamma>_h\\<^esub>\n    \\<subseteq> A \\<Gamma>_h \\<union> B \\<Gamma>_h", "by(auto simp add: vertex_def)"], ["proof (state)\nthis:\n  \\<^bold>V\\<^bsub>\\<Gamma>_h\\<^esub>\n  \\<subseteq> A \\<Gamma>_h \\<union> B \\<Gamma>_h\n\ngoal (6 subgoals):\n 1. A \\<Gamma>_h \\<subseteq> \\<^bold>V\\<^bsub>\\<Gamma>_h\\<^esub>\n 2. \\<And>x y.\n       edge \\<Gamma>_h x y \\<Longrightarrow>\n       x \\<in> A \\<Gamma>_h \\<and> y \\<in> B \\<Gamma>_h\n 3. A \\<Gamma>_h \\<inter> B \\<Gamma>_h = {}\n 4. \\<And>x.\n       x \\<notin> \\<^bold>V\\<^bsub>\\<Gamma>_h\\<^esub> \\<Longrightarrow>\n       weight \\<Gamma>_h x = 0\n 5. \\<And>x. weight \\<Gamma>_h x \\<noteq> \\<top>\n 6. countable \\<^bold>E\\<^bsub>\\<Gamma>_h\\<^esub>", "show \"A \\<Gamma>_h \\<subseteq> \\<^bold>V\\<^bsub>\\<Gamma>_h\\<^esub>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<Gamma>_h \\<subseteq> \\<^bold>V\\<^bsub>\\<Gamma>_h\\<^esub>", "using S_vertex"], ["proof (prove)\nusing this:\n  ?x \\<in> S \\<Longrightarrow> vertex \\<Gamma>_h ?x\n\ngoal (1 subgoal):\n 1. A \\<Gamma>_h \\<subseteq> \\<^bold>V\\<^bsub>\\<Gamma>_h\\<^esub>", "by auto"], ["proof (state)\nthis:\n  A \\<Gamma>_h \\<subseteq> \\<^bold>V\\<^bsub>\\<Gamma>_h\\<^esub>\n\ngoal (5 subgoals):\n 1. \\<And>x y.\n       edge \\<Gamma>_h x y \\<Longrightarrow>\n       x \\<in> A \\<Gamma>_h \\<and> y \\<in> B \\<Gamma>_h\n 2. A \\<Gamma>_h \\<inter> B \\<Gamma>_h = {}\n 3. \\<And>x.\n       x \\<notin> \\<^bold>V\\<^bsub>\\<Gamma>_h\\<^esub> \\<Longrightarrow>\n       weight \\<Gamma>_h x = 0\n 4. \\<And>x. weight \\<Gamma>_h x \\<noteq> \\<top>\n 5. countable \\<^bold>E\\<^bsub>\\<Gamma>_h\\<^esub>", "show \"x \\<in> A \\<Gamma>_h \\<and> y \\<in> B \\<Gamma>_h\" if \"edge \\<Gamma>_h x y\" for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> A \\<Gamma>_h \\<and> y \\<in> B \\<Gamma>_h", "using that"], ["proof (prove)\nusing this:\n  edge \\<Gamma>_h x y\n\ngoal (1 subgoal):\n 1. x \\<in> A \\<Gamma>_h \\<and> y \\<in> B \\<Gamma>_h", "by auto"], ["proof (state)\nthis:\n  edge \\<Gamma>_h ?x ?y \\<Longrightarrow>\n  ?x \\<in> A \\<Gamma>_h \\<and> ?y \\<in> B \\<Gamma>_h\n\ngoal (4 subgoals):\n 1. A \\<Gamma>_h \\<inter> B \\<Gamma>_h = {}\n 2. \\<And>x.\n       x \\<notin> \\<^bold>V\\<^bsub>\\<Gamma>_h\\<^esub> \\<Longrightarrow>\n       weight \\<Gamma>_h x = 0\n 3. \\<And>x. weight \\<Gamma>_h x \\<noteq> \\<top>\n 4. countable \\<^bold>E\\<^bsub>\\<Gamma>_h\\<^esub>", "show \"A \\<Gamma>_h \\<inter> B \\<Gamma>_h = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<Gamma>_h \\<inter> B \\<Gamma>_h = {}", "using disjoint"], ["proof (prove)\nusing this:\n  A \\<Gamma> \\<inter> B \\<Gamma> = {}\n\ngoal (1 subgoal):\n 1. A \\<Gamma>_h \\<inter> B \\<Gamma>_h = {}", "by(auto simp add: S_def)"], ["proof (state)\nthis:\n  A \\<Gamma>_h \\<inter> B \\<Gamma>_h = {}\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       x \\<notin> \\<^bold>V\\<^bsub>\\<Gamma>_h\\<^esub> \\<Longrightarrow>\n       weight \\<Gamma>_h x = 0\n 2. \\<And>x. weight \\<Gamma>_h x \\<noteq> \\<top>\n 3. countable \\<^bold>E\\<^bsub>\\<Gamma>_h\\<^esub>", "have \"\\<^bold>E\\<^bsub>\\<Gamma>_h\\<^esub> \\<subseteq> \\<^bold>E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<^bold>E\\<^bsub>\\<Gamma>_h\\<^esub> \\<subseteq> \\<^bold>E", "by auto"], ["proof (state)\nthis:\n  \\<^bold>E\\<^bsub>\\<Gamma>_h\\<^esub> \\<subseteq> \\<^bold>E\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       x \\<notin> \\<^bold>V\\<^bsub>\\<Gamma>_h\\<^esub> \\<Longrightarrow>\n       weight \\<Gamma>_h x = 0\n 2. \\<And>x. weight \\<Gamma>_h x \\<noteq> \\<top>\n 3. countable \\<^bold>E\\<^bsub>\\<Gamma>_h\\<^esub>", "thus \"countable \\<^bold>E\\<^bsub>\\<Gamma>_h\\<^esub>\""], ["proof (prove)\nusing this:\n  \\<^bold>E\\<^bsub>\\<Gamma>_h\\<^esub> \\<subseteq> \\<^bold>E\n\ngoal (1 subgoal):\n 1. countable \\<^bold>E\\<^bsub>\\<Gamma>_h\\<^esub>", "by(rule countable_subset) simp"], ["proof (state)\nthis:\n  countable \\<^bold>E\\<^bsub>\\<Gamma>_h\\<^esub>\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<notin> \\<^bold>V\\<^bsub>\\<Gamma>_h\\<^esub> \\<Longrightarrow>\n       weight \\<Gamma>_h x = 0\n 2. \\<And>x. weight \\<Gamma>_h x \\<noteq> \\<top>", "show \"weight \\<Gamma>_h x \\<noteq> \\<top>\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. weight \\<Gamma>_h x \\<noteq> \\<top>", "by(simp split: split_indicator)"], ["proof (state)\nthis:\n  weight \\<Gamma>_h ?x \\<noteq> \\<top>\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<notin> \\<^bold>V\\<^bsub>\\<Gamma>_h\\<^esub> \\<Longrightarrow>\n       weight \\<Gamma>_h x = 0", "show \"weight \\<Gamma>_h x = 0\" if \"x \\<notin> \\<^bold>V\\<^bsub>\\<Gamma>_h\\<^esub>\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. weight \\<Gamma>_h x = 0", "using that S_vertex B_vertex[of x]"], ["proof (prove)\nusing this:\n  x \\<notin> \\<^bold>V\\<^bsub>\\<Gamma>_h\\<^esub>\n  ?x \\<in> S \\<Longrightarrow> vertex \\<Gamma>_h ?x\n  \\<lbrakk>x \\<in> T; x \\<in> B \\<Gamma>; 0 < weight \\<Gamma> x\\<rbrakk>\n  \\<Longrightarrow> vertex \\<Gamma>_h x\n\ngoal (1 subgoal):\n 1. weight \\<Gamma>_h x = 0", "by(cases \"weight \\<Gamma>_h x > 0\")(auto split: split_indicator)"], ["proof (state)\nthis:\n  ?x \\<notin> \\<^bold>V\\<^bsub>\\<Gamma>_h\\<^esub> \\<Longrightarrow>\n  weight \\<Gamma>_h ?x = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  countable_bipartite_web \\<Gamma>_h\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>\\<epsilon>>0.\n               \\<epsilon> < \\<delta> \\<and>\n               \\<not> hindered\n                       (reduce_weight \\<Gamma> b\n                         \\<epsilon>)) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  countable_bipartite_web \\<Gamma>_h", "interpret \\<Gamma>_h: countable_bipartite_web \\<Gamma>_h"], ["proof (prove)\nusing this:\n  countable_bipartite_web \\<Gamma>_h\n\ngoal (1 subgoal):\n 1. countable_bipartite_web \\<Gamma>_h", "."], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>\\<epsilon>>0.\n               \\<epsilon> < \\<delta> \\<and>\n               \\<not> hindered\n                       (reduce_weight \\<Gamma> b\n                         \\<epsilon>)) \\<Longrightarrow>\n    False", "have essential_T: \"essential \\<Gamma> (B \\<Gamma>) T = essential \\<Gamma> (B \\<Gamma>) (TER\\<^bsub>\\<Gamma>' 0\\<^esub> (h 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. essential \\<Gamma> (B \\<Gamma>) T =\n    essential \\<Gamma> (B \\<Gamma>) (TER\\<^bsub>\\<Gamma>' 0\\<^esub> (h 0))", "proof(rule ext iffI)+"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       essential \\<Gamma> (B \\<Gamma>) T x \\<Longrightarrow>\n       essential \\<Gamma> (B \\<Gamma>)\n        (TER\\<^bsub>\\<Gamma>' 0\\<^esub> (h 0)) x\n 2. \\<And>x.\n       essential \\<Gamma> (B \\<Gamma>)\n        (TER\\<^bsub>\\<Gamma>' 0\\<^esub> (h 0)) x \\<Longrightarrow>\n       essential \\<Gamma> (B \\<Gamma>) T x", "fix x"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       essential \\<Gamma> (B \\<Gamma>) T x \\<Longrightarrow>\n       essential \\<Gamma> (B \\<Gamma>)\n        (TER\\<^bsub>\\<Gamma>' 0\\<^esub> (h 0)) x\n 2. \\<And>x.\n       essential \\<Gamma> (B \\<Gamma>)\n        (TER\\<^bsub>\\<Gamma>' 0\\<^esub> (h 0)) x \\<Longrightarrow>\n       essential \\<Gamma> (B \\<Gamma>) T x", "assume \"essential \\<Gamma> (B \\<Gamma>) T x\""], ["proof (state)\nthis:\n  essential \\<Gamma> (B \\<Gamma>) T x\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       essential \\<Gamma> (B \\<Gamma>) T x \\<Longrightarrow>\n       essential \\<Gamma> (B \\<Gamma>)\n        (TER\\<^bsub>\\<Gamma>' 0\\<^esub> (h 0)) x\n 2. \\<And>x.\n       essential \\<Gamma> (B \\<Gamma>)\n        (TER\\<^bsub>\\<Gamma>' 0\\<^esub> (h 0)) x \\<Longrightarrow>\n       essential \\<Gamma> (B \\<Gamma>) T x", "then"], ["proof (chain)\npicking this:\n  essential \\<Gamma> (B \\<Gamma>) T x", "obtain p y where p: \"path \\<Gamma> x p y\" and y: \"y \\<in> B \\<Gamma>\" and distinct: \"distinct (x # p)\"\n      and bypass: \"\\<And>z. z \\<in> set p \\<Longrightarrow> z \\<notin> RF T\""], ["proof (prove)\nusing this:\n  essential \\<Gamma> (B \\<Gamma>) T x\n\ngoal (1 subgoal):\n 1. (\\<And>p y.\n        \\<lbrakk>path \\<Gamma> x p y; y \\<in> B \\<Gamma>; distinct (x # p);\n         \\<And>z. z \\<in> set p \\<Longrightarrow> z \\<notin> RF T\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(rule essentialE_RF)auto"], ["proof (state)\nthis:\n  path \\<Gamma> x p y\n  y \\<in> B \\<Gamma>\n  distinct (x # p)\n  ?z \\<in> set p \\<Longrightarrow> ?z \\<notin> RF T\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       essential \\<Gamma> (B \\<Gamma>) T x \\<Longrightarrow>\n       essential \\<Gamma> (B \\<Gamma>)\n        (TER\\<^bsub>\\<Gamma>' 0\\<^esub> (h 0)) x\n 2. \\<And>x.\n       essential \\<Gamma> (B \\<Gamma>)\n        (TER\\<^bsub>\\<Gamma>' 0\\<^esub> (h 0)) x \\<Longrightarrow>\n       essential \\<Gamma> (B \\<Gamma>) T x", "from bypass"], ["proof (chain)\npicking this:\n  ?z \\<in> set p \\<Longrightarrow> ?z \\<notin> RF T", "have bypass': \"\\<And>z. z \\<in> set p \\<Longrightarrow> z \\<notin> TER\\<^bsub>\\<Gamma>' 0\\<^esub> (h 0)\""], ["proof (prove)\nusing this:\n  ?z \\<in> set p \\<Longrightarrow> ?z \\<notin> RF T\n\ngoal (1 subgoal):\n 1. \\<And>z.\n       z \\<in> set p \\<Longrightarrow>\n       z \\<notin> TER\\<^bsub>\\<Gamma>' 0\\<^esub> (h 0)", "unfolding RF_h[of 0, symmetric]"], ["proof (prove)\nusing this:\n  ?z \\<in> set p \\<Longrightarrow>\n  ?z \\<notin> RF (TER\\<^bsub>\\<Gamma>' 0\\<^esub> (h 0))\n\ngoal (1 subgoal):\n 1. \\<And>z.\n       z \\<in> set p \\<Longrightarrow>\n       z \\<notin> TER\\<^bsub>\\<Gamma>' 0\\<^esub> (h 0)", "by(blast intro: roofed_greaterI)"], ["proof (state)\nthis:\n  ?z \\<in> set p \\<Longrightarrow>\n  ?z \\<notin> TER\\<^bsub>\\<Gamma>' 0\\<^esub> (h 0)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       essential \\<Gamma> (B \\<Gamma>) T x \\<Longrightarrow>\n       essential \\<Gamma> (B \\<Gamma>)\n        (TER\\<^bsub>\\<Gamma>' 0\\<^esub> (h 0)) x\n 2. \\<And>x.\n       essential \\<Gamma> (B \\<Gamma>)\n        (TER\\<^bsub>\\<Gamma>' 0\\<^esub> (h 0)) x \\<Longrightarrow>\n       essential \\<Gamma> (B \\<Gamma>) T x", "show \"essential \\<Gamma> (B \\<Gamma>) (TER\\<^bsub>\\<Gamma>' 0\\<^esub> (h 0)) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. essential \\<Gamma> (B \\<Gamma>) (TER\\<^bsub>\\<Gamma>' 0\\<^esub> (h 0)) x", "using p y"], ["proof (prove)\nusing this:\n  path \\<Gamma> x p y\n  y \\<in> B \\<Gamma>\n\ngoal (1 subgoal):\n 1. essential \\<Gamma> (B \\<Gamma>) (TER\\<^bsub>\\<Gamma>' 0\\<^esub> (h 0)) x", "by(blast intro: essentialI dest: bypass')"], ["proof (state)\nthis:\n  essential \\<Gamma> (B \\<Gamma>) (TER\\<^bsub>\\<Gamma>' 0\\<^esub> (h 0)) x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       essential \\<Gamma> (B \\<Gamma>)\n        (TER\\<^bsub>\\<Gamma>' 0\\<^esub> (h 0)) x \\<Longrightarrow>\n       essential \\<Gamma> (B \\<Gamma>) T x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       essential \\<Gamma> (B \\<Gamma>)\n        (TER\\<^bsub>\\<Gamma>' 0\\<^esub> (h 0)) x \\<Longrightarrow>\n       essential \\<Gamma> (B \\<Gamma>) T x", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       essential \\<Gamma> (B \\<Gamma>)\n        (TER\\<^bsub>\\<Gamma>' 0\\<^esub> (h 0)) x \\<Longrightarrow>\n       essential \\<Gamma> (B \\<Gamma>) T x", "assume \"essential \\<Gamma> (B \\<Gamma>) (TER\\<^bsub>\\<Gamma>' 0\\<^esub> (h 0)) x\""], ["proof (state)\nthis:\n  essential \\<Gamma> (B \\<Gamma>) (TER\\<^bsub>\\<Gamma>' 0\\<^esub> (h 0)) x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       essential \\<Gamma> (B \\<Gamma>)\n        (TER\\<^bsub>\\<Gamma>' 0\\<^esub> (h 0)) x \\<Longrightarrow>\n       essential \\<Gamma> (B \\<Gamma>) T x", "then"], ["proof (chain)\npicking this:\n  essential \\<Gamma> (B \\<Gamma>) (TER\\<^bsub>\\<Gamma>' 0\\<^esub> (h 0)) x", "obtain p y where p: \"path \\<Gamma> x p y\" and y: \"y \\<in> B \\<Gamma>\" and distinct: \"distinct (x # p)\"\n      and bypass: \"\\<And>z. z \\<in> set p \\<Longrightarrow> z \\<notin> RF (TER\\<^bsub>\\<Gamma>' 0\\<^esub> (h 0))\""], ["proof (prove)\nusing this:\n  essential \\<Gamma> (B \\<Gamma>) (TER\\<^bsub>\\<Gamma>' 0\\<^esub> (h 0)) x\n\ngoal (1 subgoal):\n 1. (\\<And>p y.\n        \\<lbrakk>path \\<Gamma> x p y; y \\<in> B \\<Gamma>; distinct (x # p);\n         \\<And>z.\n            z \\<in> set p \\<Longrightarrow>\n            z \\<notin> RF (TER\\<^bsub>\\<Gamma>' 0\\<^esub> (h 0))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(rule essentialE_RF)auto"], ["proof (state)\nthis:\n  path \\<Gamma> x p y\n  y \\<in> B \\<Gamma>\n  distinct (x # p)\n  ?z \\<in> set p \\<Longrightarrow>\n  ?z \\<notin> RF (TER\\<^bsub>\\<Gamma>' 0\\<^esub> (h 0))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       essential \\<Gamma> (B \\<Gamma>)\n        (TER\\<^bsub>\\<Gamma>' 0\\<^esub> (h 0)) x \\<Longrightarrow>\n       essential \\<Gamma> (B \\<Gamma>) T x", "from bypass"], ["proof (chain)\npicking this:\n  ?z \\<in> set p \\<Longrightarrow>\n  ?z \\<notin> RF (TER\\<^bsub>\\<Gamma>' 0\\<^esub> (h 0))", "have bypass': \"\\<And>z. z \\<in> set p \\<Longrightarrow> z \\<notin> T\""], ["proof (prove)\nusing this:\n  ?z \\<in> set p \\<Longrightarrow>\n  ?z \\<notin> RF (TER\\<^bsub>\\<Gamma>' 0\\<^esub> (h 0))\n\ngoal (1 subgoal):\n 1. \\<And>z. z \\<in> set p \\<Longrightarrow> z \\<notin> T", "unfolding RF_h[of 0]"], ["proof (prove)\nusing this:\n  ?z \\<in> set p \\<Longrightarrow> ?z \\<notin> RF T\n\ngoal (1 subgoal):\n 1. \\<And>z. z \\<in> set p \\<Longrightarrow> z \\<notin> T", "by(blast intro: roofed_greaterI)"], ["proof (state)\nthis:\n  ?z \\<in> set p \\<Longrightarrow> ?z \\<notin> T\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       essential \\<Gamma> (B \\<Gamma>)\n        (TER\\<^bsub>\\<Gamma>' 0\\<^esub> (h 0)) x \\<Longrightarrow>\n       essential \\<Gamma> (B \\<Gamma>) T x", "show \"essential \\<Gamma> (B \\<Gamma>) T x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. essential \\<Gamma> (B \\<Gamma>) T x", "using p y"], ["proof (prove)\nusing this:\n  path \\<Gamma> x p y\n  y \\<in> B \\<Gamma>\n\ngoal (1 subgoal):\n 1. essential \\<Gamma> (B \\<Gamma>) T x", "by(blast intro: essentialI dest: bypass')"], ["proof (state)\nthis:\n  essential \\<Gamma> (B \\<Gamma>) T x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  essential \\<Gamma> (B \\<Gamma>) T =\n  essential \\<Gamma> (B \\<Gamma>) (TER\\<^bsub>\\<Gamma>' 0\\<^esub> (h 0))\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>\\<epsilon>>0.\n               \\<epsilon> < \\<delta> \\<and>\n               \\<not> hindered\n                       (reduce_weight \\<Gamma> b\n                         \\<epsilon>)) \\<Longrightarrow>\n    False", "have h': \"current \\<Gamma>_h (h n)\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. current \\<Gamma>_h (h n)", "proof"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x. d_OUT (h n) x \\<le> weight \\<Gamma>_h x\n 2. \\<And>x. d_IN (h n) x \\<le> weight \\<Gamma>_h x\n 3. \\<And>e.\n       e \\<notin> \\<^bold>E\\<^bsub>\\<Gamma>_h\\<^esub> \\<Longrightarrow>\n       h n e = 0", "show \"d_OUT (h n) x \\<le> weight \\<Gamma>_h x\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT (h n) x \\<le> weight \\<Gamma>_h x", "using currentD_weight_OUT[OF h, of n x] \\<epsilon>_nonneg[of n] \\<Gamma>'.currentD_OUT'[OF h, of x n] OUT_not_S"], ["proof (prove)\nusing this:\n  d_OUT (h n) x \\<le> weight (\\<Gamma>' n) x\n  0 \\<le> \\<epsilon> n\n  x \\<notin> A (\\<Gamma>' n) \\<Longrightarrow> d_OUT (h n) x = 0\n  ?x \\<notin> S \\<Longrightarrow> d_OUT (h ?n) ?x = 0\n\ngoal (1 subgoal):\n 1. d_OUT (h n) x \\<le> weight \\<Gamma>_h x", "by(auto split: split_indicator if_split_asm elim: order_trans intro: diff_le_self_ennreal in_roofed_mono simp add: OUT_h_b  roofed_circ_def)"], ["proof (state)\nthis:\n  d_OUT (h n) ?x \\<le> weight \\<Gamma>_h ?x\n\ngoal (2 subgoals):\n 1. \\<And>x. d_IN (h n) x \\<le> weight \\<Gamma>_h x\n 2. \\<And>e.\n       e \\<notin> \\<^bold>E\\<^bsub>\\<Gamma>_h\\<^esub> \\<Longrightarrow>\n       h n e = 0", "show \"d_IN (h n) x \\<le> weight \\<Gamma>_h x\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN (h n) x \\<le> weight \\<Gamma>_h x", "using currentD_weight_IN[OF h, of n x] currentD_IN[OF h, of x n] \\<epsilon>_nonneg[of n] b_T b \\<Gamma>'.currentD_IN'[OF h, of x n] IN_h_nT[of x n]"], ["proof (prove)\nusing this:\n  d_IN (h n) x \\<le> weight (\\<Gamma>' n) x\n  x \\<in> A (\\<Gamma>' n) \\<Longrightarrow> d_IN (h n) x = 0\n  0 \\<le> \\<epsilon> n\n  b \\<in> T\n  b \\<in> B \\<Gamma>\n  x \\<notin> B (\\<Gamma>' n) \\<Longrightarrow> d_IN (h n) x = 0\n  x \\<notin> RF T \\<Longrightarrow> d_IN (h n) x = 0\n\ngoal (1 subgoal):\n 1. d_IN (h n) x \\<le> weight \\<Gamma>_h x", "by(cases \"x \\<in> B \\<Gamma>\")(auto 4 3 split: split_indicator split: if_split_asm elim: order_trans intro: diff_le_self_ennreal simp add: S_def  roofed_circ_def RF_in_B)"], ["proof (state)\nthis:\n  d_IN (h n) ?x \\<le> weight \\<Gamma>_h ?x\n\ngoal (1 subgoal):\n 1. \\<And>e.\n       e \\<notin> \\<^bold>E\\<^bsub>\\<Gamma>_h\\<^esub> \\<Longrightarrow>\n       h n e = 0", "show \"h n e = 0\" if \"e \\<notin> \\<^bold>E\\<^bsub>\\<Gamma>_h\\<^esub>\" for e"], ["proof (prove)\ngoal (1 subgoal):\n 1. h n e = 0", "using that OUT_not_S[of \"fst e\" n] currentD_outside'[OF h, of e n] \\<Gamma>'.currentD_IN'[OF h, of \"snd e\" n] disjoint"], ["proof (prove)\nusing this:\n  e \\<notin> \\<^bold>E\\<^bsub>\\<Gamma>_h\\<^esub>\n  fst e \\<notin> S \\<Longrightarrow> d_OUT (h n) (fst e) = 0\n  e \\<notin> \\<^bold>E\\<^bsub>\\<Gamma>' n\\<^esub> \\<Longrightarrow>\n  h n e = 0\n  snd e \\<notin> B (\\<Gamma>' n) \\<Longrightarrow> d_IN (h n) (snd e) = 0\n  A \\<Gamma> \\<inter> B \\<Gamma> = {}\n\ngoal (1 subgoal):\n 1. h n e = 0", "apply(cases \"e \\<in> \\<^bold>E\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>e \\<notin> \\<^bold>E\\<^bsub>\\<Gamma>_h\\<^esub>;\n     fst e \\<notin> S \\<Longrightarrow> d_OUT (h n) (fst e) = 0;\n     e \\<notin> \\<^bold>E\\<^bsub>\\<Gamma>' n\\<^esub> \\<Longrightarrow>\n     h n e = 0;\n     snd e \\<notin> B (\\<Gamma>' n) \\<Longrightarrow>\n     d_IN (h n) (snd e) = 0;\n     A \\<Gamma> \\<inter> B \\<Gamma> = {}; e \\<in> \\<^bold>E\\<rbrakk>\n    \\<Longrightarrow> h n e = 0\n 2. \\<lbrakk>e \\<notin> \\<^bold>E\\<^bsub>\\<Gamma>_h\\<^esub>;\n     fst e \\<notin> S \\<Longrightarrow> d_OUT (h n) (fst e) = 0;\n     e \\<notin> \\<^bold>E\\<^bsub>\\<Gamma>' n\\<^esub> \\<Longrightarrow>\n     h n e = 0;\n     snd e \\<notin> B (\\<Gamma>' n) \\<Longrightarrow>\n     d_IN (h n) (snd e) = 0;\n     A \\<Gamma> \\<inter> B \\<Gamma> = {}; e \\<notin> \\<^bold>E\\<rbrakk>\n    \\<Longrightarrow> h n e = 0", "apply(auto split: prod.split_asm simp add: currentD_OUT_eq_0[OF h] currentD_IN_eq_0[OF h])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<lbrakk>x1 \\<notin> S \\<Longrightarrow> \\<forall>y. h n (x1, y) = 0;\n        x2 \\<notin> B \\<Gamma> \\<Longrightarrow>\n        \\<forall>y. h n (y, x2) = 0;\n        A \\<Gamma> \\<inter> B \\<Gamma> = {}; edge \\<Gamma> x1 x2;\n        e = (x1, x2); x2 \\<notin> T\\<rbrakk>\n       \\<Longrightarrow> h n (x1, x2) = 0", "apply(cases \"fst e \\<in> S\"; clarsimp simp add: S_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<lbrakk>x2 \\<notin> B \\<Gamma> \\<Longrightarrow>\n                \\<forall>y. h n (y, x2) = 0;\n        A \\<Gamma> \\<inter> B \\<Gamma> = {}; edge \\<Gamma> x1 x2;\n        e = (x1, x2); x2 \\<notin> T; x1 \\<in> RF (T \\<inter> B \\<Gamma>);\n        x1 \\<in> A \\<Gamma>;\n        essential \\<Gamma> (T \\<inter> B \\<Gamma>)\n         (RF (T \\<inter> B \\<Gamma>) \\<inter> A \\<Gamma>) x1\\<rbrakk>\n       \\<Longrightarrow> h n (x1, x2) = 0", "apply(frule RF_circ_edge_forward[rotated])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1 x2.\n       \\<lbrakk>x2 \\<notin> B \\<Gamma> \\<Longrightarrow>\n                \\<forall>y. h n (y, x2) = 0;\n        A \\<Gamma> \\<inter> B \\<Gamma> = {}; edge \\<Gamma> x1 x2;\n        e = (x1, x2); x2 \\<notin> T; x1 \\<in> RF (T \\<inter> B \\<Gamma>);\n        x1 \\<in> A \\<Gamma>;\n        essential \\<Gamma> (T \\<inter> B \\<Gamma>)\n         (RF (T \\<inter> B \\<Gamma>) \\<inter> A \\<Gamma>) x1\\<rbrakk>\n       \\<Longrightarrow> x1 \\<in> RF\\<^sup>\\<circ> (?S105 x1 x2)\n 2. \\<And>x1 x2.\n       \\<lbrakk>x2 \\<notin> B \\<Gamma> \\<Longrightarrow>\n                \\<forall>y. h n (y, x2) = 0;\n        A \\<Gamma> \\<inter> B \\<Gamma> = {}; edge \\<Gamma> x1 x2;\n        e = (x1, x2); x2 \\<notin> T; x1 \\<in> RF (T \\<inter> B \\<Gamma>);\n        x1 \\<in> A \\<Gamma>;\n        essential \\<Gamma> (T \\<inter> B \\<Gamma>)\n         (RF (T \\<inter> B \\<Gamma>) \\<inter> A \\<Gamma>) x1;\n        x2 \\<in> RF (?S105 x1 x2)\\<rbrakk>\n       \\<Longrightarrow> h n (x1, x2) = 0", "apply(erule roofed_circI, blast)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<lbrakk>x2 \\<notin> B \\<Gamma> \\<Longrightarrow>\n                \\<forall>y. h n (y, x2) = 0;\n        A \\<Gamma> \\<inter> B \\<Gamma> = {}; edge \\<Gamma> x1 x2;\n        e = (x1, x2); x2 \\<notin> T; x1 \\<in> RF (T \\<inter> B \\<Gamma>);\n        x1 \\<in> A \\<Gamma>;\n        essential \\<Gamma> (T \\<inter> B \\<Gamma>)\n         (RF (T \\<inter> B \\<Gamma>) \\<inter> A \\<Gamma>) x1;\n        x2 \\<in> RF (T \\<inter> B \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> h n (x1, x2) = 0", "apply(drule bipartite_E)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<lbrakk>x2 \\<notin> B \\<Gamma> \\<Longrightarrow>\n                \\<forall>y. h n (y, x2) = 0;\n        A \\<Gamma> \\<inter> B \\<Gamma> = {}; e = (x1, x2); x2 \\<notin> T;\n        x1 \\<in> RF (T \\<inter> B \\<Gamma>); x1 \\<in> A \\<Gamma>;\n        essential \\<Gamma> (T \\<inter> B \\<Gamma>)\n         (RF (T \\<inter> B \\<Gamma>) \\<inter> A \\<Gamma>) x1;\n        x2 \\<in> RF (T \\<inter> B \\<Gamma>);\n        x1 \\<in> A \\<Gamma> \\<and> x2 \\<in> B \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> h n (x1, x2) = 0", "apply(simp add: RF_in_B)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  ?e \\<notin> \\<^bold>E\\<^bsub>\\<Gamma>_h\\<^esub> \\<Longrightarrow>\n  h n ?e = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  current \\<Gamma>_h (h ?n)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>\\<epsilon>>0.\n               \\<epsilon> < \\<delta> \\<and>\n               \\<not> hindered\n                       (reduce_weight \\<Gamma> b\n                         \\<epsilon>)) \\<Longrightarrow>\n    False", "have SAT_h': \"B \\<Gamma>_h \\<inter> \\<^bold>V\\<^bsub>\\<Gamma>_h\\<^esub> - {b} \\<subseteq> SAT \\<Gamma>_h (h n)\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. B \\<Gamma>_h \\<inter> \\<^bold>V\\<^bsub>\\<Gamma>_h\\<^esub> - {b}\n    \\<subseteq> SAT \\<Gamma>_h (h n)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> B \\<Gamma>_h \\<inter> \\<^bold>V\\<^bsub>\\<Gamma>_h\\<^esub> -\n               {b} \\<Longrightarrow>\n       x \\<in> SAT \\<Gamma>_h (h n)", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> B \\<Gamma>_h \\<inter> \\<^bold>V\\<^bsub>\\<Gamma>_h\\<^esub> -\n               {b} \\<Longrightarrow>\n       x \\<in> SAT \\<Gamma>_h (h n)", "assume \"x \\<in> B \\<Gamma>_h \\<inter> \\<^bold>V\\<^bsub>\\<Gamma>_h\\<^esub> - {b}\""], ["proof (state)\nthis:\n  x \\<in> B \\<Gamma>_h \\<inter> \\<^bold>V\\<^bsub>\\<Gamma>_h\\<^esub> - {b}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> B \\<Gamma>_h \\<inter> \\<^bold>V\\<^bsub>\\<Gamma>_h\\<^esub> -\n               {b} \\<Longrightarrow>\n       x \\<in> SAT \\<Gamma>_h (h n)", "then"], ["proof (chain)\npicking this:\n  x \\<in> B \\<Gamma>_h \\<inter> \\<^bold>V\\<^bsub>\\<Gamma>_h\\<^esub> - {b}", "have x: \"x \\<in> T\" and B: \"x \\<in> B \\<Gamma>\" and b: \"x \\<noteq> b\" and vertex: \"x \\<in> \\<^bold>V\\<^bsub>\\<Gamma>_h\\<^esub>\""], ["proof (prove)\nusing this:\n  x \\<in> B \\<Gamma>_h \\<inter> \\<^bold>V\\<^bsub>\\<Gamma>_h\\<^esub> - {b}\n\ngoal (1 subgoal):\n 1. (x \\<in> T &&& x \\<in> B \\<Gamma>) &&&\n    x \\<noteq> b &&& x \\<in> \\<^bold>V\\<^bsub>\\<Gamma>_h\\<^esub>", "by auto"], ["proof (state)\nthis:\n  x \\<in> T\n  x \\<in> B \\<Gamma>\n  x \\<noteq> b\n  x \\<in> \\<^bold>V\\<^bsub>\\<Gamma>_h\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> B \\<Gamma>_h \\<inter> \\<^bold>V\\<^bsub>\\<Gamma>_h\\<^esub> -\n               {b} \\<Longrightarrow>\n       x \\<in> SAT \\<Gamma>_h (h n)", "from B disjoint"], ["proof (chain)\npicking this:\n  x \\<in> B \\<Gamma>\n  A \\<Gamma> \\<inter> B \\<Gamma> = {}", "have xnA: \"x \\<notin> A \\<Gamma>\""], ["proof (prove)\nusing this:\n  x \\<in> B \\<Gamma>\n  A \\<Gamma> \\<inter> B \\<Gamma> = {}\n\ngoal (1 subgoal):\n 1. x \\<notin> A \\<Gamma>", "by blast"], ["proof (state)\nthis:\n  x \\<notin> A \\<Gamma>\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> B \\<Gamma>_h \\<inter> \\<^bold>V\\<^bsub>\\<Gamma>_h\\<^esub> -\n               {b} \\<Longrightarrow>\n       x \\<in> SAT \\<Gamma>_h (h n)", "from x B"], ["proof (chain)\npicking this:\n  x \\<in> T\n  x \\<in> B \\<Gamma>", "have \"x \\<in> \\<E> T\""], ["proof (prove)\nusing this:\n  x \\<in> T\n  x \\<in> B \\<Gamma>\n\ngoal (1 subgoal):\n 1. x \\<in> \\<E> T", "by(simp add: essential_BI)"], ["proof (state)\nthis:\n  x \\<in> \\<E> T\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> B \\<Gamma>_h \\<inter> \\<^bold>V\\<^bsub>\\<Gamma>_h\\<^esub> -\n               {b} \\<Longrightarrow>\n       x \\<in> SAT \\<Gamma>_h (h n)", "hence \"d_IN (h n) x = weight (\\<Gamma>' n) x\""], ["proof (prove)\nusing this:\n  x \\<in> \\<E> T\n\ngoal (1 subgoal):\n 1. d_IN (h n) x = weight (\\<Gamma>' n) x", "using xnA"], ["proof (prove)\nusing this:\n  x \\<in> \\<E> T\n  x \\<notin> A \\<Gamma>\n\ngoal (1 subgoal):\n 1. d_IN (h n) x = weight (\\<Gamma>' n) x", "by(rule IN_h_\\<E>)"], ["proof (state)\nthis:\n  d_IN (h n) x = weight (\\<Gamma>' n) x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> B \\<Gamma>_h \\<inter> \\<^bold>V\\<^bsub>\\<Gamma>_h\\<^esub> -\n               {b} \\<Longrightarrow>\n       x \\<in> SAT \\<Gamma>_h (h n)", "with xnA b x B"], ["proof (chain)\npicking this:\n  x \\<notin> A \\<Gamma>\n  x \\<noteq> b\n  x \\<in> T\n  x \\<in> B \\<Gamma>\n  d_IN (h n) x = weight (\\<Gamma>' n) x", "show \"x \\<in> SAT \\<Gamma>_h (h n)\""], ["proof (prove)\nusing this:\n  x \\<notin> A \\<Gamma>\n  x \\<noteq> b\n  x \\<in> T\n  x \\<in> B \\<Gamma>\n  d_IN (h n) x = weight (\\<Gamma>' n) x\n\ngoal (1 subgoal):\n 1. x \\<in> SAT \\<Gamma>_h (h n)", "by(simp add: currentD_SAT[OF h'])"], ["proof (state)\nthis:\n  x \\<in> SAT \\<Gamma>_h (h n)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  B \\<Gamma>_h \\<inter> \\<^bold>V\\<^bsub>\\<Gamma>_h\\<^esub> - {b}\n  \\<subseteq> SAT \\<Gamma>_h (h ?n)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>\\<epsilon>>0.\n               \\<epsilon> < \\<delta> \\<and>\n               \\<not> hindered\n                       (reduce_weight \\<Gamma> b\n                         \\<epsilon>)) \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  B \\<Gamma>_h \\<inter> \\<^bold>V\\<^bsub>\\<Gamma>_h\\<^esub> - {b}\n  \\<subseteq> SAT \\<Gamma>_h (h ?n)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>\\<epsilon>>0.\n               \\<epsilon> < \\<delta> \\<and>\n               \\<not> hindered\n                       (reduce_weight \\<Gamma> b\n                         \\<epsilon>)) \\<Longrightarrow>\n    False", "have \"b \\<in> B \\<Gamma>_h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b \\<in> B \\<Gamma>_h", "using b essential"], ["proof (prove)\nusing this:\n  b \\<in> B \\<Gamma>\n  b \\<in> \\<E> T\n\ngoal (1 subgoal):\n 1. b \\<in> B \\<Gamma>_h", "by simp"], ["proof (state)\nthis:\n  b \\<in> B \\<Gamma>_h\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>\\<epsilon>>0.\n               \\<epsilon> < \\<delta> \\<and>\n               \\<not> hindered\n                       (reduce_weight \\<Gamma> b\n                         \\<epsilon>)) \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  b \\<in> B \\<Gamma>_h\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>\\<epsilon>>0.\n               \\<epsilon> < \\<delta> \\<and>\n               \\<not> hindered\n                       (reduce_weight \\<Gamma> b\n                         \\<epsilon>)) \\<Longrightarrow>\n    False", "have \"(\\<lambda>n. min \\<delta> wb * (1 / (real (n + 2)))) \\<longlonglongrightarrow> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n. min \\<delta> wb * (1 / real (n + 2)))\n    \\<longlonglongrightarrow> 0", "apply(rule LIMSEQ_ignore_initial_segment)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>a. min \\<delta> wb * (1 / real a)) \\<longlonglongrightarrow> 0", "apply(rule tendsto_mult_right_zero)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. 1 / real x) \\<longlonglongrightarrow> 0", "apply(rule lim_1_over_real_power[where s=1, simplified])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (\\<lambda>n. min \\<delta> wb * (1 / real (n + 2)))\n  \\<longlonglongrightarrow> 0\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>\\<epsilon>>0.\n               \\<epsilon> < \\<delta> \\<and>\n               \\<not> hindered\n                       (reduce_weight \\<Gamma> b\n                         \\<epsilon>)) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  (\\<lambda>n. min \\<delta> wb * (1 / real (n + 2)))\n  \\<longlonglongrightarrow> 0", "have \"(INF n. ennreal (\\<epsilon> n)) = 0\""], ["proof (prove)\nusing this:\n  (\\<lambda>n. min \\<delta> wb * (1 / real (n + 2)))\n  \\<longlonglongrightarrow> 0\n\ngoal (1 subgoal):\n 1. (\\<Sqinter>n. ennreal (\\<epsilon> n)) = 0", "using wb_pos \\<delta>"], ["proof (prove)\nusing this:\n  (\\<lambda>n. min \\<delta> wb * (1 / real (n + 2)))\n  \\<longlonglongrightarrow> 0\n  0 < wb\n  0 < \\<delta>\n\ngoal (1 subgoal):\n 1. (\\<Sqinter>n. ennreal (\\<epsilon> n)) = 0", "apply(simp add: \\<epsilon>_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<lambda>n. min \\<delta> wb / (2 + real n))\n             \\<longlonglongrightarrow> 0;\n     0 < wb; 0 < \\<delta>\\<rbrakk>\n    \\<Longrightarrow> (\\<Sqinter>x.\n                          ennreal (min \\<delta> wb / (2 + real x))) =\n                      0", "apply(rule INF_Lim)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>(\\<lambda>n. min \\<delta> wb / (2 + real n))\n             \\<longlonglongrightarrow> 0;\n     0 < wb; 0 < \\<delta>\\<rbrakk>\n    \\<Longrightarrow> decseq\n                       (\\<lambda>n.\n                           ennreal (min \\<delta> wb / (2 + real n)))\n 2. \\<lbrakk>(\\<lambda>n. min \\<delta> wb / (2 + real n))\n             \\<longlonglongrightarrow> 0;\n     0 < wb; 0 < \\<delta>\\<rbrakk>\n    \\<Longrightarrow> (\\<lambda>n. ennreal (min \\<delta> wb / (2 + real n)))\n                      \\<longlonglongrightarrow> 0", "apply(rule decseq_SucI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>(\\<lambda>n. min \\<delta> wb / (2 + real n))\n                \\<longlonglongrightarrow> 0;\n        0 < wb; 0 < \\<delta>\\<rbrakk>\n       \\<Longrightarrow> ennreal (min \\<delta> wb / (2 + real (Suc n)))\n                         \\<le> ennreal (min \\<delta> wb / (2 + real n))\n 2. \\<lbrakk>(\\<lambda>n. min \\<delta> wb / (2 + real n))\n             \\<longlonglongrightarrow> 0;\n     0 < wb; 0 < \\<delta>\\<rbrakk>\n    \\<Longrightarrow> (\\<lambda>n. ennreal (min \\<delta> wb / (2 + real n)))\n                      \\<longlonglongrightarrow> 0", "apply(simp add: field_simps min_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<lambda>n. min \\<delta> wb / (2 + real n))\n             \\<longlonglongrightarrow> 0;\n     0 < wb; 0 < \\<delta>\\<rbrakk>\n    \\<Longrightarrow> (\\<lambda>n. ennreal (min \\<delta> wb / (2 + real n)))\n                      \\<longlonglongrightarrow> 0", "apply(simp add: add.commute ennreal_0[symmetric] del: ennreal_0)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (\\<Sqinter>n. ennreal (\\<epsilon> n)) = 0\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>\\<epsilon>>0.\n               \\<epsilon> < \\<delta> \\<and>\n               \\<not> hindered\n                       (reduce_weight \\<Gamma> b\n                         \\<epsilon>)) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  (\\<Sqinter>n. ennreal (\\<epsilon> n)) = 0", "have \"(SUP n. d_IN (h n) b) = weight \\<Gamma>_h b\""], ["proof (prove)\nusing this:\n  (\\<Sqinter>n. ennreal (\\<epsilon> n)) = 0\n\ngoal (1 subgoal):\n 1. (\\<Squnion>n. d_IN (h n) b) = weight \\<Gamma>_h b", "using essential b bnA wb IN_h_\\<E>[of b]"], ["proof (prove)\nusing this:\n  (\\<Sqinter>n. ennreal (\\<epsilon> n)) = 0\n  b \\<in> \\<E> T\n  b \\<in> B \\<Gamma>\n  b \\<notin> A \\<Gamma>\n  0 < weight \\<Gamma> b\n  \\<lbrakk>b \\<in> \\<E> T; b \\<notin> A \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> d_IN (h ?n) b = weight (\\<Gamma>' ?n) b\n\ngoal (1 subgoal):\n 1. (\\<Squnion>n. d_IN (h n) b) = weight \\<Gamma>_h b", "by(simp add: SUP_const_minus_ennreal)"], ["proof (state)\nthis:\n  (\\<Squnion>n. d_IN (h n) b) = weight \\<Gamma>_h b\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>\\<epsilon>>0.\n               \\<epsilon> < \\<delta> \\<and>\n               \\<not> hindered\n                       (reduce_weight \\<Gamma> b\n                         \\<epsilon>)) \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  (\\<Squnion>n. d_IN (h n) b) = weight \\<Gamma>_h b\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>\\<epsilon>>0.\n               \\<epsilon> < \\<delta> \\<and>\n               \\<not> hindered\n                       (reduce_weight \\<Gamma> b\n                         \\<epsilon>)) \\<Longrightarrow>\n    False", "have \"d_IN (h 0) b \\<le> d_IN (h n) b\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN (h 0) b \\<le> d_IN (h n) b", "using essential b bnA wb_pos \\<delta> IN_h_\\<E>[of b]"], ["proof (prove)\nusing this:\n  b \\<in> \\<E> T\n  b \\<in> B \\<Gamma>\n  b \\<notin> A \\<Gamma>\n  0 < wb\n  0 < \\<delta>\n  \\<lbrakk>b \\<in> \\<E> T; b \\<notin> A \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> d_IN (h ?n) b = weight (\\<Gamma>' ?n) b\n\ngoal (1 subgoal):\n 1. d_IN (h 0) b \\<le> d_IN (h n) b", "by(simp add: wb_conv \\<epsilon>_def field_simps ennreal_minus_if min_le_iff_disj)"], ["proof (state)\nthis:\n  d_IN (h 0) b \\<le> d_IN (h ?n) b\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>\\<epsilon>>0.\n               \\<epsilon> < \\<delta> \\<and>\n               \\<not> hindered\n                       (reduce_weight \\<Gamma> b\n                         \\<epsilon>)) \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  d_IN (h 0) b \\<le> d_IN (h ?n) b\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>\\<epsilon>>0.\n               \\<epsilon> < \\<delta> \\<and>\n               \\<not> hindered\n                       (reduce_weight \\<Gamma> b\n                         \\<epsilon>)) \\<Longrightarrow>\n    False", "have b_V: \"b \\<in> \\<^bold>V\\<^bsub>\\<Gamma>_h\\<^esub>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b \\<in> \\<^bold>V\\<^bsub>\\<Gamma>_h\\<^esub>", "using b wb essential"], ["proof (prove)\nusing this:\n  b \\<in> B \\<Gamma>\n  0 < weight \\<Gamma> b\n  b \\<in> \\<E> T\n\ngoal (1 subgoal):\n 1. b \\<in> \\<^bold>V\\<^bsub>\\<Gamma>_h\\<^esub>", "by(auto dest: B_vertex)"], ["proof (state)\nthis:\n  b \\<in> \\<^bold>V\\<^bsub>\\<Gamma>_h\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>\\<epsilon>>0.\n               \\<epsilon> < \\<delta> \\<and>\n               \\<not> hindered\n                       (reduce_weight \\<Gamma> b\n                         \\<epsilon>)) \\<Longrightarrow>\n    False", "ultimately"], ["proof (chain)\npicking this:\n  B \\<Gamma>_h \\<inter> \\<^bold>V\\<^bsub>\\<Gamma>_h\\<^esub> - {b}\n  \\<subseteq> SAT \\<Gamma>_h (h ?n)\n  b \\<in> B \\<Gamma>_h\n  (\\<Squnion>n. d_IN (h n) b) = weight \\<Gamma>_h b\n  d_IN (h 0) b \\<le> d_IN (h ?n) b\n  b \\<in> \\<^bold>V\\<^bsub>\\<Gamma>_h\\<^esub>", "have \"\\<exists>h'. current \\<Gamma>_h h' \\<and> wave \\<Gamma>_h h' \\<and> B \\<Gamma>_h \\<inter> \\<^bold>V\\<^bsub>\\<Gamma>_h\\<^esub> \\<subseteq> SAT \\<Gamma>_h h'\""], ["proof (prove)\nusing this:\n  B \\<Gamma>_h \\<inter> \\<^bold>V\\<^bsub>\\<Gamma>_h\\<^esub> - {b}\n  \\<subseteq> SAT \\<Gamma>_h (h ?n)\n  b \\<in> B \\<Gamma>_h\n  (\\<Squnion>n. d_IN (h n) b) = weight \\<Gamma>_h b\n  d_IN (h 0) b \\<le> d_IN (h ?n) b\n  b \\<in> \\<^bold>V\\<^bsub>\\<Gamma>_h\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<exists>h'.\n       current \\<Gamma>_h h' \\<and>\n       wave \\<Gamma>_h h' \\<and>\n       B \\<Gamma>_h \\<inter> \\<^bold>V\\<^bsub>\\<Gamma>_h\\<^esub>\n       \\<subseteq> SAT \\<Gamma>_h h'", "by(rule \\<Gamma>_h.unhinder_bipartite[OF h'])"], ["proof (state)\nthis:\n  \\<exists>h'.\n     current \\<Gamma>_h h' \\<and>\n     wave \\<Gamma>_h h' \\<and>\n     B \\<Gamma>_h \\<inter> \\<^bold>V\\<^bsub>\\<Gamma>_h\\<^esub>\n     \\<subseteq> SAT \\<Gamma>_h h'\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>\\<epsilon>>0.\n               \\<epsilon> < \\<delta> \\<and>\n               \\<not> hindered\n                       (reduce_weight \\<Gamma> b\n                         \\<epsilon>)) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<exists>h'.\n     current \\<Gamma>_h h' \\<and>\n     wave \\<Gamma>_h h' \\<and>\n     B \\<Gamma>_h \\<inter> \\<^bold>V\\<^bsub>\\<Gamma>_h\\<^esub>\n     \\<subseteq> SAT \\<Gamma>_h h'", "obtain h' where h': \"current \\<Gamma>_h h'\" and h'w: \"wave \\<Gamma>_h h'\"\n    and B_SAT': \"B \\<Gamma>_h \\<inter> \\<^bold>V\\<^bsub>\\<Gamma>_h\\<^esub> \\<subseteq> SAT \\<Gamma>_h h'\""], ["proof (prove)\nusing this:\n  \\<exists>h'.\n     current \\<Gamma>_h h' \\<and>\n     wave \\<Gamma>_h h' \\<and>\n     B \\<Gamma>_h \\<inter> \\<^bold>V\\<^bsub>\\<Gamma>_h\\<^esub>\n     \\<subseteq> SAT \\<Gamma>_h h'\n\ngoal (1 subgoal):\n 1. (\\<And>h'.\n        \\<lbrakk>current \\<Gamma>_h h'; wave \\<Gamma>_h h';\n         B \\<Gamma>_h \\<inter> \\<^bold>V\\<^bsub>\\<Gamma>_h\\<^esub>\n         \\<subseteq> SAT \\<Gamma>_h h'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  current \\<Gamma>_h h'\n  wave \\<Gamma>_h h'\n  B \\<Gamma>_h \\<inter> \\<^bold>V\\<^bsub>\\<Gamma>_h\\<^esub>\n  \\<subseteq> SAT \\<Gamma>_h h'\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>\\<epsilon>>0.\n               \\<epsilon> < \\<delta> \\<and>\n               \\<not> hindered\n                       (reduce_weight \\<Gamma> b\n                         \\<epsilon>)) \\<Longrightarrow>\n    False", "have h'': \"current \\<Gamma> h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. current \\<Gamma> h'", "proof"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x. d_OUT h' x \\<le> weight \\<Gamma> x\n 2. \\<And>x. d_IN h' x \\<le> weight \\<Gamma> x\n 3. \\<And>e. e \\<notin> \\<^bold>E \\<Longrightarrow> h' e = 0", "show \"d_OUT h' x \\<le> weight \\<Gamma> x\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT h' x \\<le> weight \\<Gamma> x", "using currentD_weight_OUT[OF h', of x]"], ["proof (prove)\nusing this:\n  d_OUT h' x \\<le> weight \\<Gamma>_h x\n\ngoal (1 subgoal):\n 1. d_OUT h' x \\<le> weight \\<Gamma> x", "by(auto split: split_indicator_asm elim: order_trans intro: )"], ["proof (state)\nthis:\n  d_OUT h' ?x \\<le> weight \\<Gamma> ?x\n\ngoal (2 subgoals):\n 1. \\<And>x. d_IN h' x \\<le> weight \\<Gamma> x\n 2. \\<And>e. e \\<notin> \\<^bold>E \\<Longrightarrow> h' e = 0", "show \"d_IN h' x \\<le> weight \\<Gamma> x\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN h' x \\<le> weight \\<Gamma> x", "using currentD_weight_IN[OF h', of x]"], ["proof (prove)\nusing this:\n  d_IN h' x \\<le> weight \\<Gamma>_h x\n\ngoal (1 subgoal):\n 1. d_IN h' x \\<le> weight \\<Gamma> x", "by(auto split: split_indicator_asm elim: order_trans intro: )"], ["proof (state)\nthis:\n  d_IN h' ?x \\<le> weight \\<Gamma> ?x\n\ngoal (1 subgoal):\n 1. \\<And>e. e \\<notin> \\<^bold>E \\<Longrightarrow> h' e = 0", "show \"h' e = 0\" if \"e \\<notin> \\<^bold>E\" for e"], ["proof (prove)\ngoal (1 subgoal):\n 1. h' e = 0", "using currentD_outside'[OF h', of e] that"], ["proof (prove)\nusing this:\n  e \\<notin> \\<^bold>E\\<^bsub>\\<Gamma>_h\\<^esub> \\<Longrightarrow> h' e = 0\n  e \\<notin> \\<^bold>E\n\ngoal (1 subgoal):\n 1. h' e = 0", "by auto"], ["proof (state)\nthis:\n  ?e \\<notin> \\<^bold>E \\<Longrightarrow> h' ?e = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  current \\<Gamma> h'\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>\\<epsilon>>0.\n               \\<epsilon> < \\<delta> \\<and>\n               \\<not> hindered\n                       (reduce_weight \\<Gamma> b\n                         \\<epsilon>)) \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  current \\<Gamma> h'\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>\\<epsilon>>0.\n               \\<epsilon> < \\<delta> \\<and>\n               \\<not> hindered\n                       (reduce_weight \\<Gamma> b\n                         \\<epsilon>)) \\<Longrightarrow>\n    False", "have \"wave \\<Gamma> h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wave \\<Gamma> h'", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. separating \\<Gamma> (TER h')\n 2. current \\<Gamma> h'", "have \"separating (\\<Gamma>' 0) T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. separating (\\<Gamma>' 0) T", "unfolding T_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. separating (\\<Gamma>' 0) (TER\\<^bsub>\\<Gamma>' 0\\<^esub> g\\<omega>)", "by(rule waveD_separating[OF w\\<omega>])"], ["proof (state)\nthis:\n  separating (\\<Gamma>' 0) T\n\ngoal (2 subgoals):\n 1. separating \\<Gamma> (TER h')\n 2. current \\<Gamma> h'", "hence \"separating \\<Gamma> T\""], ["proof (prove)\nusing this:\n  separating (\\<Gamma>' 0) T\n\ngoal (1 subgoal):\n 1. separating \\<Gamma> T", "by(simp add: separating_gen.simps)"], ["proof (state)\nthis:\n  separating \\<Gamma> T\n\ngoal (2 subgoals):\n 1. separating \\<Gamma> (TER h')\n 2. current \\<Gamma> h'", "hence *: \"separating \\<Gamma> (\\<E> T)\""], ["proof (prove)\nusing this:\n  separating \\<Gamma> T\n\ngoal (1 subgoal):\n 1. separating \\<Gamma> (\\<E> T)", "by(rule separating_essential)"], ["proof (state)\nthis:\n  separating \\<Gamma> (\\<E> T)\n\ngoal (2 subgoals):\n 1. separating \\<Gamma> (TER h')\n 2. current \\<Gamma> h'", "show \"separating \\<Gamma> (TER h')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. separating \\<Gamma> (TER h')", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y p.\n       \\<lbrakk>x \\<in> A \\<Gamma>; y \\<in> B \\<Gamma>;\n        path \\<Gamma> x p y\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>z\\<in>set p. z \\<in> TER h') \\<or>\n                         x \\<in> TER h'", "fix x p y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y p.\n       \\<lbrakk>x \\<in> A \\<Gamma>; y \\<in> B \\<Gamma>;\n        path \\<Gamma> x p y\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>z\\<in>set p. z \\<in> TER h') \\<or>\n                         x \\<in> TER h'", "assume x: \"x \\<in> A \\<Gamma>\" and p: \"path \\<Gamma> x p y\" and y: \"y \\<in> B \\<Gamma>\""], ["proof (state)\nthis:\n  x \\<in> A \\<Gamma>\n  path \\<Gamma> x p y\n  y \\<in> B \\<Gamma>\n\ngoal (1 subgoal):\n 1. \\<And>x y p.\n       \\<lbrakk>x \\<in> A \\<Gamma>; y \\<in> B \\<Gamma>;\n        path \\<Gamma> x p y\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>z\\<in>set p. z \\<in> TER h') \\<or>\n                         x \\<in> TER h'", "from p x y disjoint"], ["proof (chain)\npicking this:\n  path \\<Gamma> x p y\n  x \\<in> A \\<Gamma>\n  y \\<in> B \\<Gamma>\n  A \\<Gamma> \\<inter> B \\<Gamma> = {}", "have py: \"p = [y]\""], ["proof (prove)\nusing this:\n  path \\<Gamma> x p y\n  x \\<in> A \\<Gamma>\n  y \\<in> B \\<Gamma>\n  A \\<Gamma> \\<inter> B \\<Gamma> = {}\n\ngoal (1 subgoal):\n 1. p = [y]", "by(cases)(auto 4 3 elim: rtrancl_path.cases dest: bipartite_E)"], ["proof (state)\nthis:\n  p = [y]\n\ngoal (1 subgoal):\n 1. \\<And>x y p.\n       \\<lbrakk>x \\<in> A \\<Gamma>; y \\<in> B \\<Gamma>;\n        path \\<Gamma> x p y\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>z\\<in>set p. z \\<in> TER h') \\<or>\n                         x \\<in> TER h'", "from separatingD[OF * p x y] py"], ["proof (chain)\npicking this:\n  (\\<exists>z\\<in>set p. z \\<in> \\<E> T) \\<or> x \\<in> \\<E> T\n  p = [y]", "have \"x \\<in> \\<E> T \\<or> y \\<in> \\<E> T\""], ["proof (prove)\nusing this:\n  (\\<exists>z\\<in>set p. z \\<in> \\<E> T) \\<or> x \\<in> \\<E> T\n  p = [y]\n\ngoal (1 subgoal):\n 1. x \\<in> \\<E> T \\<or> y \\<in> \\<E> T", "by auto"], ["proof (state)\nthis:\n  x \\<in> \\<E> T \\<or> y \\<in> \\<E> T\n\ngoal (1 subgoal):\n 1. \\<And>x y p.\n       \\<lbrakk>x \\<in> A \\<Gamma>; y \\<in> B \\<Gamma>;\n        path \\<Gamma> x p y\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>z\\<in>set p. z \\<in> TER h') \\<or>\n                         x \\<in> TER h'", "then"], ["proof (chain)\npicking this:\n  x \\<in> \\<E> T \\<or> y \\<in> \\<E> T", "show \"(\\<exists>z\\<in>set p. z \\<in> TER h') \\<or> x \\<in> TER h'\""], ["proof (prove)\nusing this:\n  x \\<in> \\<E> T \\<or> y \\<in> \\<E> T\n\ngoal (1 subgoal):\n 1. (\\<exists>z\\<in>set p. z \\<in> TER h') \\<or> x \\<in> TER h'", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<in> \\<E> T \\<Longrightarrow>\n    (\\<exists>z\\<in>set p. z \\<in> TER h') \\<or> x \\<in> TER h'\n 2. y \\<in> \\<E> T \\<Longrightarrow>\n    (\\<exists>z\\<in>set p. z \\<in> TER h') \\<or> x \\<in> TER h'", "case left"], ["proof (state)\nthis:\n  x \\<in> \\<E> T\n\ngoal (2 subgoals):\n 1. x \\<in> \\<E> T \\<Longrightarrow>\n    (\\<exists>z\\<in>set p. z \\<in> TER h') \\<or> x \\<in> TER h'\n 2. y \\<in> \\<E> T \\<Longrightarrow>\n    (\\<exists>z\\<in>set p. z \\<in> TER h') \\<or> x \\<in> TER h'", "then"], ["proof (chain)\npicking this:\n  x \\<in> \\<E> T", "have \"x \\<notin> \\<^bold>V\\<^bsub>\\<Gamma>_h\\<^esub>\""], ["proof (prove)\nusing this:\n  x \\<in> \\<E> T\n\ngoal (1 subgoal):\n 1. x \\<notin> \\<^bold>V\\<^bsub>\\<Gamma>_h\\<^esub>", "using x disjoint"], ["proof (prove)\nusing this:\n  x \\<in> \\<E> T\n  x \\<in> A \\<Gamma>\n  A \\<Gamma> \\<inter> B \\<Gamma> = {}\n\ngoal (1 subgoal):\n 1. x \\<notin> \\<^bold>V\\<^bsub>\\<Gamma>_h\\<^esub>", "by(auto 4 4 dest!: vertex_\\<Gamma>_hD simp add: S_def elim: essentialE_RF intro!: roofed_greaterI dest: roofedD)"], ["proof (state)\nthis:\n  x \\<notin> \\<^bold>V\\<^bsub>\\<Gamma>_h\\<^esub>\n\ngoal (2 subgoals):\n 1. x \\<in> \\<E> T \\<Longrightarrow>\n    (\\<exists>z\\<in>set p. z \\<in> TER h') \\<or> x \\<in> TER h'\n 2. y \\<in> \\<E> T \\<Longrightarrow>\n    (\\<exists>z\\<in>set p. z \\<in> TER h') \\<or> x \\<in> TER h'", "hence \"d_OUT h' x = 0\""], ["proof (prove)\nusing this:\n  x \\<notin> \\<^bold>V\\<^bsub>\\<Gamma>_h\\<^esub>\n\ngoal (1 subgoal):\n 1. d_OUT h' x = 0", "by(intro currentD_outside_OUT[OF h'])"], ["proof (state)\nthis:\n  d_OUT h' x = 0\n\ngoal (2 subgoals):\n 1. x \\<in> \\<E> T \\<Longrightarrow>\n    (\\<exists>z\\<in>set p. z \\<in> TER h') \\<or> x \\<in> TER h'\n 2. y \\<in> \\<E> T \\<Longrightarrow>\n    (\\<exists>z\\<in>set p. z \\<in> TER h') \\<or> x \\<in> TER h'", "with x"], ["proof (chain)\npicking this:\n  x \\<in> A \\<Gamma>\n  d_OUT h' x = 0", "have \"x \\<in> TER h'\""], ["proof (prove)\nusing this:\n  x \\<in> A \\<Gamma>\n  d_OUT h' x = 0\n\ngoal (1 subgoal):\n 1. x \\<in> TER h'", "by(auto simp add: SAT.A SINK.simps)"], ["proof (state)\nthis:\n  x \\<in> TER h'\n\ngoal (2 subgoals):\n 1. x \\<in> \\<E> T \\<Longrightarrow>\n    (\\<exists>z\\<in>set p. z \\<in> TER h') \\<or> x \\<in> TER h'\n 2. y \\<in> \\<E> T \\<Longrightarrow>\n    (\\<exists>z\\<in>set p. z \\<in> TER h') \\<or> x \\<in> TER h'", "thus ?thesis"], ["proof (prove)\nusing this:\n  x \\<in> TER h'\n\ngoal (1 subgoal):\n 1. (\\<exists>z\\<in>set p. z \\<in> TER h') \\<or> x \\<in> TER h'", ".."], ["proof (state)\nthis:\n  (\\<exists>z\\<in>set p. z \\<in> TER h') \\<or> x \\<in> TER h'\n\ngoal (1 subgoal):\n 1. y \\<in> \\<E> T \\<Longrightarrow>\n    (\\<exists>z\\<in>set p. z \\<in> TER h') \\<or> x \\<in> TER h'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. y \\<in> \\<E> T \\<Longrightarrow>\n    (\\<exists>z\\<in>set p. z \\<in> TER h') \\<or> x \\<in> TER h'", "case right"], ["proof (state)\nthis:\n  y \\<in> \\<E> T\n\ngoal (1 subgoal):\n 1. y \\<in> \\<E> T \\<Longrightarrow>\n    (\\<exists>z\\<in>set p. z \\<in> TER h') \\<or> x \\<in> TER h'", "have \"y \\<in> SAT \\<Gamma> h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<in> SAT \\<Gamma> h'", "proof(cases \"weight \\<Gamma> y > 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 < weight \\<Gamma> y \\<Longrightarrow> y \\<in> SAT \\<Gamma> h'\n 2. \\<not> 0 < weight \\<Gamma> y \\<Longrightarrow> y \\<in> SAT \\<Gamma> h'", "case True"], ["proof (state)\nthis:\n  0 < weight \\<Gamma> y\n\ngoal (2 subgoals):\n 1. 0 < weight \\<Gamma> y \\<Longrightarrow> y \\<in> SAT \\<Gamma> h'\n 2. \\<not> 0 < weight \\<Gamma> y \\<Longrightarrow> y \\<in> SAT \\<Gamma> h'", "with py x y right"], ["proof (chain)\npicking this:\n  p = [y]\n  x \\<in> A \\<Gamma>\n  y \\<in> B \\<Gamma>\n  y \\<in> \\<E> T\n  0 < weight \\<Gamma> y", "have \"vertex \\<Gamma>_h y\""], ["proof (prove)\nusing this:\n  p = [y]\n  x \\<in> A \\<Gamma>\n  y \\<in> B \\<Gamma>\n  y \\<in> \\<E> T\n  0 < weight \\<Gamma> y\n\ngoal (1 subgoal):\n 1. vertex \\<Gamma>_h y", "by(auto intro: B_vertex)"], ["proof (state)\nthis:\n  vertex \\<Gamma>_h y\n\ngoal (2 subgoals):\n 1. 0 < weight \\<Gamma> y \\<Longrightarrow> y \\<in> SAT \\<Gamma> h'\n 2. \\<not> 0 < weight \\<Gamma> y \\<Longrightarrow> y \\<in> SAT \\<Gamma> h'", "hence \"y \\<in> SAT \\<Gamma>_h h'\""], ["proof (prove)\nusing this:\n  vertex \\<Gamma>_h y\n\ngoal (1 subgoal):\n 1. y \\<in> SAT \\<Gamma>_h h'", "using B_SAT' right y"], ["proof (prove)\nusing this:\n  vertex \\<Gamma>_h y\n  B \\<Gamma>_h \\<inter> \\<^bold>V\\<^bsub>\\<Gamma>_h\\<^esub>\n  \\<subseteq> SAT \\<Gamma>_h h'\n  y \\<in> \\<E> T\n  y \\<in> B \\<Gamma>\n\ngoal (1 subgoal):\n 1. y \\<in> SAT \\<Gamma>_h h'", "by auto"], ["proof (state)\nthis:\n  y \\<in> SAT \\<Gamma>_h h'\n\ngoal (2 subgoals):\n 1. 0 < weight \\<Gamma> y \\<Longrightarrow> y \\<in> SAT \\<Gamma> h'\n 2. \\<not> 0 < weight \\<Gamma> y \\<Longrightarrow> y \\<in> SAT \\<Gamma> h'", "with right y disjoint"], ["proof (chain)\npicking this:\n  y \\<in> \\<E> T\n  y \\<in> B \\<Gamma>\n  A \\<Gamma> \\<inter> B \\<Gamma> = {}\n  y \\<in> SAT \\<Gamma>_h h'", "show ?thesis"], ["proof (prove)\nusing this:\n  y \\<in> \\<E> T\n  y \\<in> B \\<Gamma>\n  A \\<Gamma> \\<inter> B \\<Gamma> = {}\n  y \\<in> SAT \\<Gamma>_h h'\n\ngoal (1 subgoal):\n 1. y \\<in> SAT \\<Gamma> h'", "by(auto simp add: currentD_SAT[OF h'] currentD_SAT[OF h''] S_def)"], ["proof (state)\nthis:\n  y \\<in> SAT \\<Gamma> h'\n\ngoal (1 subgoal):\n 1. \\<not> 0 < weight \\<Gamma> y \\<Longrightarrow> y \\<in> SAT \\<Gamma> h'", "qed(auto simp add: SAT.simps)"], ["proof (state)\nthis:\n  y \\<in> SAT \\<Gamma> h'\n\ngoal (1 subgoal):\n 1. y \\<in> \\<E> T \\<Longrightarrow>\n    (\\<exists>z\\<in>set p. z \\<in> TER h') \\<or> x \\<in> TER h'", "with currentD_OUT[OF h', of y] y right"], ["proof (chain)\npicking this:\n  y \\<in> B \\<Gamma>_h \\<Longrightarrow> d_OUT h' y = 0\n  y \\<in> B \\<Gamma>\n  y \\<in> \\<E> T\n  y \\<in> SAT \\<Gamma> h'", "have \"y \\<in> TER h'\""], ["proof (prove)\nusing this:\n  y \\<in> B \\<Gamma>_h \\<Longrightarrow> d_OUT h' y = 0\n  y \\<in> B \\<Gamma>\n  y \\<in> \\<E> T\n  y \\<in> SAT \\<Gamma> h'\n\ngoal (1 subgoal):\n 1. y \\<in> TER h'", "by(auto simp add: SINK)"], ["proof (state)\nthis:\n  y \\<in> TER h'\n\ngoal (1 subgoal):\n 1. y \\<in> \\<E> T \\<Longrightarrow>\n    (\\<exists>z\\<in>set p. z \\<in> TER h') \\<or> x \\<in> TER h'", "thus ?thesis"], ["proof (prove)\nusing this:\n  y \\<in> TER h'\n\ngoal (1 subgoal):\n 1. (\\<exists>z\\<in>set p. z \\<in> TER h') \\<or> x \\<in> TER h'", "using py"], ["proof (prove)\nusing this:\n  y \\<in> TER h'\n  p = [y]\n\ngoal (1 subgoal):\n 1. (\\<exists>z\\<in>set p. z \\<in> TER h') \\<or> x \\<in> TER h'", "by simp"], ["proof (state)\nthis:\n  (\\<exists>z\\<in>set p. z \\<in> TER h') \\<or> x \\<in> TER h'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<exists>z\\<in>set p. z \\<in> TER h') \\<or> x \\<in> TER h'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  separating \\<Gamma> (TER h')\n\ngoal (1 subgoal):\n 1. current \\<Gamma> h'", "qed(rule h'')"], ["proof (state)\nthis:\n  wave \\<Gamma> h'\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>\\<epsilon>>0.\n               \\<epsilon> < \\<delta> \\<and>\n               \\<not> hindered\n                       (reduce_weight \\<Gamma> b\n                         \\<epsilon>)) \\<Longrightarrow>\n    False", "ultimately"], ["proof (chain)\npicking this:\n  current \\<Gamma> h'\n  wave \\<Gamma> h'", "have \"h' = zero_current\""], ["proof (prove)\nusing this:\n  current \\<Gamma> h'\n  wave \\<Gamma> h'\n\ngoal (1 subgoal):\n 1. h' = (\\<lambda>_. 0)", "by(rule looseD_wave[OF loose])"], ["proof (state)\nthis:\n  h' = (\\<lambda>_. 0)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>\\<epsilon>>0.\n               \\<epsilon> < \\<delta> \\<and>\n               \\<not> hindered\n                       (reduce_weight \\<Gamma> b\n                         \\<epsilon>)) \\<Longrightarrow>\n    False", "hence \"d_IN h' b = 0\""], ["proof (prove)\nusing this:\n  h' = (\\<lambda>_. 0)\n\ngoal (1 subgoal):\n 1. d_IN h' b = 0", "by simp"], ["proof (state)\nthis:\n  d_IN h' b = 0\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>\\<epsilon>>0.\n               \\<epsilon> < \\<delta> \\<and>\n               \\<not> hindered\n                       (reduce_weight \\<Gamma> b\n                         \\<epsilon>)) \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  d_IN h' b = 0\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>\\<epsilon>>0.\n               \\<epsilon> < \\<delta> \\<and>\n               \\<not> hindered\n                       (reduce_weight \\<Gamma> b\n                         \\<epsilon>)) \\<Longrightarrow>\n    False", "from essential b b_V B_SAT'"], ["proof (chain)\npicking this:\n  b \\<in> \\<E> T\n  b \\<in> B \\<Gamma>\n  b \\<in> \\<^bold>V\\<^bsub>\\<Gamma>_h\\<^esub>\n  B \\<Gamma>_h \\<inter> \\<^bold>V\\<^bsub>\\<Gamma>_h\\<^esub>\n  \\<subseteq> SAT \\<Gamma>_h h'", "have \"b \\<in> SAT \\<Gamma>_h h'\""], ["proof (prove)\nusing this:\n  b \\<in> \\<E> T\n  b \\<in> B \\<Gamma>\n  b \\<in> \\<^bold>V\\<^bsub>\\<Gamma>_h\\<^esub>\n  B \\<Gamma>_h \\<inter> \\<^bold>V\\<^bsub>\\<Gamma>_h\\<^esub>\n  \\<subseteq> SAT \\<Gamma>_h h'\n\ngoal (1 subgoal):\n 1. b \\<in> SAT \\<Gamma>_h h'", "by(auto)"], ["proof (state)\nthis:\n  b \\<in> SAT \\<Gamma>_h h'\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>\\<epsilon>>0.\n               \\<epsilon> < \\<delta> \\<and>\n               \\<not> hindered\n                       (reduce_weight \\<Gamma> b\n                         \\<epsilon>)) \\<Longrightarrow>\n    False", "ultimately"], ["proof (chain)\npicking this:\n  d_IN h' b = 0\n  b \\<in> SAT \\<Gamma>_h h'", "show False"], ["proof (prove)\nusing this:\n  d_IN h' b = 0\n  b \\<in> SAT \\<Gamma>_h h'\n\ngoal (1 subgoal):\n 1. False", "using wb b essential disjoint"], ["proof (prove)\nusing this:\n  d_IN h' b = 0\n  b \\<in> SAT \\<Gamma>_h h'\n  0 < weight \\<Gamma> b\n  b \\<in> B \\<Gamma>\n  b \\<in> \\<E> T\n  A \\<Gamma> \\<inter> B \\<Gamma> = {}\n\ngoal (1 subgoal):\n 1. False", "by(auto simp add: SAT.simps S_def)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "subsection \\<open>Single-vertex saturation in unhindered bipartite webs\\<close>"], ["", "text \\<open>\n  The proof of lemma 6.10 in @{cite \"AharoniBergerGeorgakopoulusPerlsteinSpruessel2011JCT\"} is flawed.\n  The transfinite steps (taking the least upper bound) only preserves unhinderedness, but not looseness.\n  However, the single steps to non-limit ordinals assumes that \\<open>\\<Omega> - f\\<^sub>i\\<close> is loose in order to\n  apply Lemma 6.9.\n\n  Counterexample: The bipartite web with three nodes \\<open>a\\<^sub>1\\<close>, \\<open>a\\<^sub>2\\<close>, \\<open>a\\<^sub>3\\<close> in \\<open>A\\<close>\n  and two nodes \\<open>b\\<^sub>1\\<close>, \\<open>b\\<^sub>2\\<close> in \\<open>B\\<close> and edges \\<open>(a\\<^sub>1, b\\<^sub>1)\\<close>, \\<open>(a\\<^sub>2, b\\<^sub>1)\\<close>,\n  \\<open>(a\\<^sub>2, b\\<^sub>2)\\<close>, \\<open>(a\\<^sub>3, b\\<^sub>2)\\<close> and weights \\<open>a\\<^sub>1 = a\\<^sub>3 = 1\\<close> and \\<open>a\\<^sub>2 = 2\\<close> and\n  \\<open>b\\<^sub>1 = 3\\<close> and \\<open>b\\<^sub>2 = 2\\<close>.\n  Then, we can get a sequence of weight reductions on \\<open>b\\<^sub>2\\<close> from \\<open>2\\<close> to \\<open>1.5\\<close>,\n  \\<open>1.25\\<close>, \\<open>1.125\\<close>, etc. with limit \\<open>1\\<close>.\n  All maximal waves in the restricted webs in the sequence are @{term [source] zero_current}, so in\n  the limit, we get \\<open>k = 0\\<close> and \\<open>\\<epsilon> = 1\\<close> for \\<open>a\\<^sub>2\\<close> and \\<open>b\\<^sub>2\\<close>. Now, the\n  restricted web for the two is not loose because it contains the wave which assigns 1 to \\<open>(a\\<^sub>3, b\\<^sub>2)\\<close>.\n\n  We prove a stronger version which only assumes and ensures on unhinderedness.\n\\<close>"], ["", "context countable_bipartite_web begin"], ["", "lemma web_flow_iff: \"web_flow \\<Gamma> f \\<longleftrightarrow> current \\<Gamma> f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. web_flow \\<Gamma> f = current \\<Gamma> f", "using bipartite_V"], ["proof (prove)\nusing this:\n  \\<^bold>V \\<subseteq> A \\<Gamma> \\<union> B \\<Gamma>\n\ngoal (1 subgoal):\n 1. web_flow \\<Gamma> f = current \\<Gamma> f", "by(auto simp add: web_flow.simps)"], ["", "lemma countable_bipartite_web_minus_web:\n  assumes f: \"current \\<Gamma> f\"\n  shows \"countable_bipartite_web (\\<Gamma> \\<ominus> f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. countable_bipartite_web (\\<Gamma> \\<ominus> f)", "using bipartite_V A_vertex bipartite_E disjoint currentD_finite_OUT[OF f] currentD_weight_OUT[OF f] currentD_weight_IN[OF f] currentD_outside_OUT[OF f] currentD_outside_IN[OF f]"], ["proof (prove)\nusing this:\n  \\<^bold>V \\<subseteq> A \\<Gamma> \\<union> B \\<Gamma>\n  A \\<Gamma> \\<subseteq> \\<^bold>V\n  edge \\<Gamma> ?x ?y \\<Longrightarrow>\n  ?x \\<in> A \\<Gamma> \\<and> ?y \\<in> B \\<Gamma>\n  A \\<Gamma> \\<inter> B \\<Gamma> = {}\n  d_OUT f ?x \\<noteq> \\<top>\n  d_OUT f ?x \\<le> weight \\<Gamma> ?x\n  d_IN f ?x \\<le> weight \\<Gamma> ?x\n  ?x \\<notin> \\<^bold>V \\<Longrightarrow> d_OUT f ?x = 0\n  ?x \\<notin> \\<^bold>V \\<Longrightarrow> d_IN f ?x = 0\n\ngoal (1 subgoal):\n 1. countable_bipartite_web (\\<Gamma> \\<ominus> f)", "by unfold_locales (auto simp add:  weight_outside)"], ["", "lemma current_plus_current_minus:\n  assumes f: \"current \\<Gamma> f\"\n  and g: \"current (\\<Gamma> \\<ominus> f) g\"\n  shows \"current \\<Gamma> (plus_current f g)\" (is \"current _ ?fg\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. current \\<Gamma> (plus_current f g)", "proof"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x. d_OUT (plus_current f g) x \\<le> weight \\<Gamma> x\n 2. \\<And>x. d_IN (plus_current f g) x \\<le> weight \\<Gamma> x\n 3. \\<And>e. e \\<notin> \\<^bold>E \\<Longrightarrow> plus_current f g e = 0", "interpret \\<Gamma>: countable_bipartite_web \"\\<Gamma> \\<ominus> f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. countable_bipartite_web (\\<Gamma> \\<ominus> f)", "using f"], ["proof (prove)\nusing this:\n  current \\<Gamma> f\n\ngoal (1 subgoal):\n 1. countable_bipartite_web (\\<Gamma> \\<ominus> f)", "by(rule countable_bipartite_web_minus_web)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x. d_OUT (plus_current f g) x \\<le> weight \\<Gamma> x\n 2. \\<And>x. d_IN (plus_current f g) x \\<le> weight \\<Gamma> x\n 3. \\<And>e. e \\<notin> \\<^bold>E \\<Longrightarrow> plus_current f g e = 0", "show \"d_OUT ?fg x \\<le> weight \\<Gamma> x\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT (plus_current f g) x \\<le> weight \\<Gamma> x", "using currentD_weight_OUT[OF g, of x] currentD_OUT[OF g, of x] currentD_finite_OUT[OF f, of x] currentD_OUT[OF f, of x] currentD_outside_IN[OF f, of x] currentD_outside_OUT[OF f, of x] currentD_weight_OUT[OF f, of x]"], ["proof (prove)\nusing this:\n  d_OUT g x \\<le> weight (\\<Gamma> \\<ominus> f) x\n  x \\<in> B (\\<Gamma> \\<ominus> f) \\<Longrightarrow> d_OUT g x = 0\n  d_OUT f x \\<noteq> \\<top>\n  x \\<in> B \\<Gamma> \\<Longrightarrow> d_OUT f x = 0\n  x \\<notin> \\<^bold>V \\<Longrightarrow> d_IN f x = 0\n  x \\<notin> \\<^bold>V \\<Longrightarrow> d_OUT f x = 0\n  d_OUT f x \\<le> weight \\<Gamma> x\n\ngoal (1 subgoal):\n 1. d_OUT (plus_current f g) x \\<le> weight \\<Gamma> x", "by(cases \"x \\<in> A \\<Gamma> \\<or> x \\<in> B \\<Gamma>\")(auto simp add: add.commute d_OUT_def nn_integral_add not_vertex ennreal_le_minus_iff split: if_split_asm)"], ["proof (state)\nthis:\n  d_OUT (plus_current f g) ?x \\<le> weight \\<Gamma> ?x\n\ngoal (2 subgoals):\n 1. \\<And>x. d_IN (plus_current f g) x \\<le> weight \\<Gamma> x\n 2. \\<And>e. e \\<notin> \\<^bold>E \\<Longrightarrow> plus_current f g e = 0", "show \"d_IN ?fg x \\<le> weight \\<Gamma> x\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN (plus_current f g) x \\<le> weight \\<Gamma> x", "using currentD_weight_IN[OF g, of x] currentD_IN[OF g, of x] currentD_finite_IN[OF f, of x] currentD_OUT[OF f, of x] currentD_outside_IN[OF f, of x] currentD_outside_OUT[OF f, of x] currentD_weight_IN[OF f, of x]"], ["proof (prove)\nusing this:\n  d_IN g x \\<le> weight (\\<Gamma> \\<ominus> f) x\n  x \\<in> A (\\<Gamma> \\<ominus> f) \\<Longrightarrow> d_IN g x = 0\n  d_IN f x \\<noteq> \\<top>\n  x \\<in> B \\<Gamma> \\<Longrightarrow> d_OUT f x = 0\n  x \\<notin> \\<^bold>V \\<Longrightarrow> d_IN f x = 0\n  x \\<notin> \\<^bold>V \\<Longrightarrow> d_OUT f x = 0\n  d_IN f x \\<le> weight \\<Gamma> x\n\ngoal (1 subgoal):\n 1. d_IN (plus_current f g) x \\<le> weight \\<Gamma> x", "by(cases \"x \\<in> A \\<Gamma> \\<or> x \\<in> B \\<Gamma>\")(auto simp add: add.commute  d_IN_def nn_integral_add not_vertex ennreal_le_minus_iff split: if_split_asm)"], ["proof (state)\nthis:\n  d_IN (plus_current f g) ?x \\<le> weight \\<Gamma> ?x\n\ngoal (1 subgoal):\n 1. \\<And>e. e \\<notin> \\<^bold>E \\<Longrightarrow> plus_current f g e = 0", "show \"?fg e = 0\" if \"e \\<notin> \\<^bold>E\" for e"], ["proof (prove)\ngoal (1 subgoal):\n 1. plus_current f g e = 0", "using that currentD_outside'[OF f, of e] currentD_outside'[OF g, of e]"], ["proof (prove)\nusing this:\n  e \\<notin> \\<^bold>E\n  e \\<notin> \\<^bold>E \\<Longrightarrow> f e = 0\n  e \\<notin> \\<^bold>E\\<^bsub>\\<Gamma> \\<ominus> f\\<^esub> \\<Longrightarrow>\n  g e = 0\n\ngoal (1 subgoal):\n 1. plus_current f g e = 0", "by(cases e) simp"], ["proof (state)\nthis:\n  ?e \\<notin> \\<^bold>E \\<Longrightarrow> plus_current f g ?e = 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma wave_plus_current_minus:\n  assumes f: \"current \\<Gamma> f\"\n  and w: \"wave \\<Gamma> f\"\n  and g: \"current (\\<Gamma> \\<ominus> f) g\"\n  and w': \"wave (\\<Gamma> \\<ominus> f) g\"\n  shows \"wave \\<Gamma> (plus_current f g)\" (is \"wave _ ?fg\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. wave \\<Gamma> (plus_current f g)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. separating \\<Gamma> (TER (plus_current f g))\n 2. current \\<Gamma> (plus_current f g)", "show fg: \"current \\<Gamma> ?fg\""], ["proof (prove)\ngoal (1 subgoal):\n 1. current \\<Gamma> (plus_current f g)", "using f g"], ["proof (prove)\nusing this:\n  current \\<Gamma> f\n  current (\\<Gamma> \\<ominus> f) g\n\ngoal (1 subgoal):\n 1. current \\<Gamma> (plus_current f g)", "by(rule current_plus_current_minus)"], ["proof (state)\nthis:\n  current \\<Gamma> (plus_current f g)\n\ngoal (1 subgoal):\n 1. separating \\<Gamma> (TER (plus_current f g))", "show sep: \"separating \\<Gamma> (TER ?fg)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. separating \\<Gamma> (TER (plus_current f g))", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y p.\n       \\<lbrakk>x \\<in> A \\<Gamma>; y \\<in> B \\<Gamma>;\n        path \\<Gamma> x p y\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>z\\<in>set p.\n                             z \\<in> TER (plus_current f g)) \\<or>\n                         x \\<in> TER (plus_current f g)", "fix x p y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y p.\n       \\<lbrakk>x \\<in> A \\<Gamma>; y \\<in> B \\<Gamma>;\n        path \\<Gamma> x p y\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>z\\<in>set p.\n                             z \\<in> TER (plus_current f g)) \\<or>\n                         x \\<in> TER (plus_current f g)", "assume x: \"x \\<in> A \\<Gamma>\" and p: \"path \\<Gamma> x p y\" and y: \"y \\<in> B \\<Gamma>\""], ["proof (state)\nthis:\n  x \\<in> A \\<Gamma>\n  path \\<Gamma> x p y\n  y \\<in> B \\<Gamma>\n\ngoal (1 subgoal):\n 1. \\<And>x y p.\n       \\<lbrakk>x \\<in> A \\<Gamma>; y \\<in> B \\<Gamma>;\n        path \\<Gamma> x p y\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>z\\<in>set p.\n                             z \\<in> TER (plus_current f g)) \\<or>\n                         x \\<in> TER (plus_current f g)", "from p x y disjoint"], ["proof (chain)\npicking this:\n  path \\<Gamma> x p y\n  x \\<in> A \\<Gamma>\n  y \\<in> B \\<Gamma>\n  A \\<Gamma> \\<inter> B \\<Gamma> = {}", "have py: \"p = [y]\""], ["proof (prove)\nusing this:\n  path \\<Gamma> x p y\n  x \\<in> A \\<Gamma>\n  y \\<in> B \\<Gamma>\n  A \\<Gamma> \\<inter> B \\<Gamma> = {}\n\ngoal (1 subgoal):\n 1. p = [y]", "by(cases)(auto 4 3 elim: rtrancl_path.cases dest: bipartite_E)"], ["proof (state)\nthis:\n  p = [y]\n\ngoal (1 subgoal):\n 1. \\<And>x y p.\n       \\<lbrakk>x \\<in> A \\<Gamma>; y \\<in> B \\<Gamma>;\n        path \\<Gamma> x p y\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>z\\<in>set p.\n                             z \\<in> TER (plus_current f g)) \\<or>\n                         x \\<in> TER (plus_current f g)", "with waveD_separating[THEN separatingD, OF w p x y]"], ["proof (chain)\npicking this:\n  (\\<exists>z\\<in>set p. z \\<in> TER f) \\<or> x \\<in> TER f\n  p = [y]", "have \"x \\<in> TER f \\<or> y \\<in> TER f\""], ["proof (prove)\nusing this:\n  (\\<exists>z\\<in>set p. z \\<in> TER f) \\<or> x \\<in> TER f\n  p = [y]\n\ngoal (1 subgoal):\n 1. x \\<in> TER f \\<or> y \\<in> TER f", "by auto"], ["proof (state)\nthis:\n  x \\<in> TER f \\<or> y \\<in> TER f\n\ngoal (1 subgoal):\n 1. \\<And>x y p.\n       \\<lbrakk>x \\<in> A \\<Gamma>; y \\<in> B \\<Gamma>;\n        path \\<Gamma> x p y\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>z\\<in>set p.\n                             z \\<in> TER (plus_current f g)) \\<or>\n                         x \\<in> TER (plus_current f g)", "thus \"(\\<exists>z\\<in>set p. z \\<in> TER ?fg) \\<or> x \\<in> TER ?fg\""], ["proof (prove)\nusing this:\n  x \\<in> TER f \\<or> y \\<in> TER f\n\ngoal (1 subgoal):\n 1. (\\<exists>z\\<in>set p. z \\<in> TER (plus_current f g)) \\<or>\n    x \\<in> TER (plus_current f g)", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<in> TER f \\<Longrightarrow>\n    (\\<exists>z\\<in>set p. z \\<in> TER (plus_current f g)) \\<or>\n    x \\<in> TER (plus_current f g)\n 2. y \\<in> TER f \\<Longrightarrow>\n    (\\<exists>z\\<in>set p. z \\<in> TER (plus_current f g)) \\<or>\n    x \\<in> TER (plus_current f g)", "case right"], ["proof (state)\nthis:\n  y \\<in> TER f\n\ngoal (2 subgoals):\n 1. x \\<in> TER f \\<Longrightarrow>\n    (\\<exists>z\\<in>set p. z \\<in> TER (plus_current f g)) \\<or>\n    x \\<in> TER (plus_current f g)\n 2. y \\<in> TER f \\<Longrightarrow>\n    (\\<exists>z\\<in>set p. z \\<in> TER (plus_current f g)) \\<or>\n    x \\<in> TER (plus_current f g)", "with y disjoint"], ["proof (chain)\npicking this:\n  y \\<in> B \\<Gamma>\n  A \\<Gamma> \\<inter> B \\<Gamma> = {}\n  y \\<in> TER f", "have \"y \\<in> TER ?fg\""], ["proof (prove)\nusing this:\n  y \\<in> B \\<Gamma>\n  A \\<Gamma> \\<inter> B \\<Gamma> = {}\n  y \\<in> TER f\n\ngoal (1 subgoal):\n 1. y \\<in> TER (plus_current f g)", "using currentD_OUT[OF fg y]"], ["proof (prove)\nusing this:\n  y \\<in> B \\<Gamma>\n  A \\<Gamma> \\<inter> B \\<Gamma> = {}\n  y \\<in> TER f\n  d_OUT (plus_current f g) y = 0\n\ngoal (1 subgoal):\n 1. y \\<in> TER (plus_current f g)", "by(auto simp add: SAT.simps SINK.simps d_IN_def nn_integral_add not_le add_increasing2)"], ["proof (state)\nthis:\n  y \\<in> TER (plus_current f g)\n\ngoal (2 subgoals):\n 1. x \\<in> TER f \\<Longrightarrow>\n    (\\<exists>z\\<in>set p. z \\<in> TER (plus_current f g)) \\<or>\n    x \\<in> TER (plus_current f g)\n 2. y \\<in> TER f \\<Longrightarrow>\n    (\\<exists>z\\<in>set p. z \\<in> TER (plus_current f g)) \\<or>\n    x \\<in> TER (plus_current f g)", "thus ?thesis"], ["proof (prove)\nusing this:\n  y \\<in> TER (plus_current f g)\n\ngoal (1 subgoal):\n 1. (\\<exists>z\\<in>set p. z \\<in> TER (plus_current f g)) \\<or>\n    x \\<in> TER (plus_current f g)", "using py"], ["proof (prove)\nusing this:\n  y \\<in> TER (plus_current f g)\n  p = [y]\n\ngoal (1 subgoal):\n 1. (\\<exists>z\\<in>set p. z \\<in> TER (plus_current f g)) \\<or>\n    x \\<in> TER (plus_current f g)", "by simp"], ["proof (state)\nthis:\n  (\\<exists>z\\<in>set p. z \\<in> TER (plus_current f g)) \\<or>\n  x \\<in> TER (plus_current f g)\n\ngoal (1 subgoal):\n 1. x \\<in> TER f \\<Longrightarrow>\n    (\\<exists>z\\<in>set p. z \\<in> TER (plus_current f g)) \\<or>\n    x \\<in> TER (plus_current f g)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<in> TER f \\<Longrightarrow>\n    (\\<exists>z\\<in>set p. z \\<in> TER (plus_current f g)) \\<or>\n    x \\<in> TER (plus_current f g)", "case x': left"], ["proof (state)\nthis:\n  x \\<in> TER f\n\ngoal (1 subgoal):\n 1. x \\<in> TER f \\<Longrightarrow>\n    (\\<exists>z\\<in>set p. z \\<in> TER (plus_current f g)) \\<or>\n    x \\<in> TER (plus_current f g)", "from p"], ["proof (chain)\npicking this:\n  path \\<Gamma> x p y", "have \"path (\\<Gamma> \\<ominus> f) x p y\""], ["proof (prove)\nusing this:\n  path \\<Gamma> x p y\n\ngoal (1 subgoal):\n 1. path (\\<Gamma> \\<ominus> f) x p y", "by simp"], ["proof (state)\nthis:\n  path (\\<Gamma> \\<ominus> f) x p y\n\ngoal (1 subgoal):\n 1. x \\<in> TER f \\<Longrightarrow>\n    (\\<exists>z\\<in>set p. z \\<in> TER (plus_current f g)) \\<or>\n    x \\<in> TER (plus_current f g)", "from waveD_separating[THEN separatingD, OF w' this] x y py"], ["proof (chain)\npicking this:\n  \\<lbrakk>x \\<in> A (\\<Gamma> \\<ominus> f);\n   y \\<in> B (\\<Gamma> \\<ominus> f)\\<rbrakk>\n  \\<Longrightarrow> (\\<exists>z\\<in>set p.\n                        z \\<in> TER\\<^bsub>\\<Gamma> \\<ominus> f\\<^esub>\n                                 g) \\<or>\n                    x \\<in> TER\\<^bsub>\\<Gamma> \\<ominus> f\\<^esub> g\n  x \\<in> A \\<Gamma>\n  y \\<in> B \\<Gamma>\n  p = [y]", "have \"x \\<in> TER\\<^bsub>\\<Gamma> \\<ominus> f\\<^esub> g \\<or> y \\<in> TER\\<^bsub>\\<Gamma> \\<ominus> f\\<^esub> g\""], ["proof (prove)\nusing this:\n  \\<lbrakk>x \\<in> A (\\<Gamma> \\<ominus> f);\n   y \\<in> B (\\<Gamma> \\<ominus> f)\\<rbrakk>\n  \\<Longrightarrow> (\\<exists>z\\<in>set p.\n                        z \\<in> TER\\<^bsub>\\<Gamma> \\<ominus> f\\<^esub>\n                                 g) \\<or>\n                    x \\<in> TER\\<^bsub>\\<Gamma> \\<ominus> f\\<^esub> g\n  x \\<in> A \\<Gamma>\n  y \\<in> B \\<Gamma>\n  p = [y]\n\ngoal (1 subgoal):\n 1. x \\<in> TER\\<^bsub>\\<Gamma> \\<ominus> f\\<^esub> g \\<or>\n    y \\<in> TER\\<^bsub>\\<Gamma> \\<ominus> f\\<^esub> g", "by auto"], ["proof (state)\nthis:\n  x \\<in> TER\\<^bsub>\\<Gamma> \\<ominus> f\\<^esub> g \\<or>\n  y \\<in> TER\\<^bsub>\\<Gamma> \\<ominus> f\\<^esub> g\n\ngoal (1 subgoal):\n 1. x \\<in> TER f \\<Longrightarrow>\n    (\\<exists>z\\<in>set p. z \\<in> TER (plus_current f g)) \\<or>\n    x \\<in> TER (plus_current f g)", "thus ?thesis"], ["proof (prove)\nusing this:\n  x \\<in> TER\\<^bsub>\\<Gamma> \\<ominus> f\\<^esub> g \\<or>\n  y \\<in> TER\\<^bsub>\\<Gamma> \\<ominus> f\\<^esub> g\n\ngoal (1 subgoal):\n 1. (\\<exists>z\\<in>set p. z \\<in> TER (plus_current f g)) \\<or>\n    x \\<in> TER (plus_current f g)", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<in> TER\\<^bsub>\\<Gamma> \\<ominus> f\\<^esub> g \\<Longrightarrow>\n    (\\<exists>z\\<in>set p. z \\<in> TER (plus_current f g)) \\<or>\n    x \\<in> TER (plus_current f g)\n 2. y \\<in> TER\\<^bsub>\\<Gamma> \\<ominus> f\\<^esub> g \\<Longrightarrow>\n    (\\<exists>z\\<in>set p. z \\<in> TER (plus_current f g)) \\<or>\n    x \\<in> TER (plus_current f g)", "case left"], ["proof (state)\nthis:\n  x \\<in> TER\\<^bsub>\\<Gamma> \\<ominus> f\\<^esub> g\n\ngoal (2 subgoals):\n 1. x \\<in> TER\\<^bsub>\\<Gamma> \\<ominus> f\\<^esub> g \\<Longrightarrow>\n    (\\<exists>z\\<in>set p. z \\<in> TER (plus_current f g)) \\<or>\n    x \\<in> TER (plus_current f g)\n 2. y \\<in> TER\\<^bsub>\\<Gamma> \\<ominus> f\\<^esub> g \\<Longrightarrow>\n    (\\<exists>z\\<in>set p. z \\<in> TER (plus_current f g)) \\<or>\n    x \\<in> TER (plus_current f g)", "hence \"x \\<in> TER ?fg\""], ["proof (prove)\nusing this:\n  x \\<in> TER\\<^bsub>\\<Gamma> \\<ominus> f\\<^esub> g\n\ngoal (1 subgoal):\n 1. x \\<in> TER (plus_current f g)", "using x x'"], ["proof (prove)\nusing this:\n  x \\<in> TER\\<^bsub>\\<Gamma> \\<ominus> f\\<^esub> g\n  x \\<in> A \\<Gamma>\n  x \\<in> TER f\n\ngoal (1 subgoal):\n 1. x \\<in> TER (plus_current f g)", "by(auto simp add: SAT.simps SINK.simps d_OUT_def nn_integral_add)"], ["proof (state)\nthis:\n  x \\<in> TER (plus_current f g)\n\ngoal (2 subgoals):\n 1. x \\<in> TER\\<^bsub>\\<Gamma> \\<ominus> f\\<^esub> g \\<Longrightarrow>\n    (\\<exists>z\\<in>set p. z \\<in> TER (plus_current f g)) \\<or>\n    x \\<in> TER (plus_current f g)\n 2. y \\<in> TER\\<^bsub>\\<Gamma> \\<ominus> f\\<^esub> g \\<Longrightarrow>\n    (\\<exists>z\\<in>set p. z \\<in> TER (plus_current f g)) \\<or>\n    x \\<in> TER (plus_current f g)", "thus ?thesis"], ["proof (prove)\nusing this:\n  x \\<in> TER (plus_current f g)\n\ngoal (1 subgoal):\n 1. (\\<exists>z\\<in>set p. z \\<in> TER (plus_current f g)) \\<or>\n    x \\<in> TER (plus_current f g)", ".."], ["proof (state)\nthis:\n  (\\<exists>z\\<in>set p. z \\<in> TER (plus_current f g)) \\<or>\n  x \\<in> TER (plus_current f g)\n\ngoal (1 subgoal):\n 1. y \\<in> TER\\<^bsub>\\<Gamma> \\<ominus> f\\<^esub> g \\<Longrightarrow>\n    (\\<exists>z\\<in>set p. z \\<in> TER (plus_current f g)) \\<or>\n    x \\<in> TER (plus_current f g)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. y \\<in> TER\\<^bsub>\\<Gamma> \\<ominus> f\\<^esub> g \\<Longrightarrow>\n    (\\<exists>z\\<in>set p. z \\<in> TER (plus_current f g)) \\<or>\n    x \\<in> TER (plus_current f g)", "case right"], ["proof (state)\nthis:\n  y \\<in> TER\\<^bsub>\\<Gamma> \\<ominus> f\\<^esub> g\n\ngoal (1 subgoal):\n 1. y \\<in> TER\\<^bsub>\\<Gamma> \\<ominus> f\\<^esub> g \\<Longrightarrow>\n    (\\<exists>z\\<in>set p. z \\<in> TER (plus_current f g)) \\<or>\n    x \\<in> TER (plus_current f g)", "hence \"y \\<in> TER ?fg\""], ["proof (prove)\nusing this:\n  y \\<in> TER\\<^bsub>\\<Gamma> \\<ominus> f\\<^esub> g\n\ngoal (1 subgoal):\n 1. y \\<in> TER (plus_current f g)", "using disjoint y currentD_OUT[OF fg y] currentD_OUT[OF f y] currentD_finite_IN[OF f, of y]"], ["proof (prove)\nusing this:\n  y \\<in> TER\\<^bsub>\\<Gamma> \\<ominus> f\\<^esub> g\n  A \\<Gamma> \\<inter> B \\<Gamma> = {}\n  y \\<in> B \\<Gamma>\n  d_OUT (plus_current f g) y = 0\n  d_OUT f y = 0\n  d_IN f y \\<noteq> \\<top>\n\ngoal (1 subgoal):\n 1. y \\<in> TER (plus_current f g)", "by(auto simp add: add.commute SINK.simps SAT.simps d_IN_def nn_integral_add ennreal_minus_le_iff split: if_split_asm)"], ["proof (state)\nthis:\n  y \\<in> TER (plus_current f g)\n\ngoal (1 subgoal):\n 1. y \\<in> TER\\<^bsub>\\<Gamma> \\<ominus> f\\<^esub> g \\<Longrightarrow>\n    (\\<exists>z\\<in>set p. z \\<in> TER (plus_current f g)) \\<or>\n    x \\<in> TER (plus_current f g)", "with py"], ["proof (chain)\npicking this:\n  p = [y]\n  y \\<in> TER (plus_current f g)", "show ?thesis"], ["proof (prove)\nusing this:\n  p = [y]\n  y \\<in> TER (plus_current f g)\n\ngoal (1 subgoal):\n 1. (\\<exists>z\\<in>set p. z \\<in> TER (plus_current f g)) \\<or>\n    x \\<in> TER (plus_current f g)", "by auto"], ["proof (state)\nthis:\n  (\\<exists>z\\<in>set p. z \\<in> TER (plus_current f g)) \\<or>\n  x \\<in> TER (plus_current f g)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<exists>z\\<in>set p. z \\<in> TER (plus_current f g)) \\<or>\n  x \\<in> TER (plus_current f g)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<exists>z\\<in>set p. z \\<in> TER (plus_current f g)) \\<or>\n  x \\<in> TER (plus_current f g)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  separating \\<Gamma> (TER (plus_current f g))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma minus_plus_current:\n  assumes f: \"current \\<Gamma> f\"\n  and g: \"current (\\<Gamma> \\<ominus> f) g\"\n  shows \"\\<Gamma> \\<ominus> plus_current f g = \\<Gamma> \\<ominus> f \\<ominus> g\" (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma> \\<ominus> plus_current f g = \\<Gamma> \\<ominus> f \\<ominus> g", "proof(rule web.equality)"], ["proof (state)\ngoal (5 subgoals):\n 1. edge (\\<Gamma> \\<ominus> plus_current f g) =\n    edge (\\<Gamma> \\<ominus> f \\<ominus> g)\n 2. weight (\\<Gamma> \\<ominus> plus_current f g) =\n    weight (\\<Gamma> \\<ominus> f \\<ominus> g)\n 3. A (\\<Gamma> \\<ominus> plus_current f g) =\n    A (\\<Gamma> \\<ominus> f \\<ominus> g)\n 4. B (\\<Gamma> \\<ominus> plus_current f g) =\n    B (\\<Gamma> \\<ominus> f \\<ominus> g)\n 5. web.more (\\<Gamma> \\<ominus> plus_current f g) =\n    web.more (\\<Gamma> \\<ominus> f \\<ominus> g)", "have \"weight ?lhs x = weight ?rhs x\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. weight (\\<Gamma> \\<ominus> plus_current f g) x =\n    weight (\\<Gamma> \\<ominus> f \\<ominus> g) x", "using currentD_weight_IN[OF f, of x] currentD_weight_IN[OF g, of x]"], ["proof (prove)\nusing this:\n  d_IN f x \\<le> weight \\<Gamma> x\n  d_IN g x \\<le> weight (\\<Gamma> \\<ominus> f) x\n\ngoal (1 subgoal):\n 1. weight (\\<Gamma> \\<ominus> plus_current f g) x =\n    weight (\\<Gamma> \\<ominus> f \\<ominus> g) x", "by (auto simp add: d_IN_def d_OUT_def nn_integral_add diff_add_eq_diff_diff_swap_ennreal add_increasing2 diff_add_assoc2_ennreal add.assoc)"], ["proof (state)\nthis:\n  weight (\\<Gamma> \\<ominus> plus_current f g) ?x =\n  weight (\\<Gamma> \\<ominus> f \\<ominus> g) ?x\n\ngoal (5 subgoals):\n 1. edge (\\<Gamma> \\<ominus> plus_current f g) =\n    edge (\\<Gamma> \\<ominus> f \\<ominus> g)\n 2. weight (\\<Gamma> \\<ominus> plus_current f g) =\n    weight (\\<Gamma> \\<ominus> f \\<ominus> g)\n 3. A (\\<Gamma> \\<ominus> plus_current f g) =\n    A (\\<Gamma> \\<ominus> f \\<ominus> g)\n 4. B (\\<Gamma> \\<ominus> plus_current f g) =\n    B (\\<Gamma> \\<ominus> f \\<ominus> g)\n 5. web.more (\\<Gamma> \\<ominus> plus_current f g) =\n    web.more (\\<Gamma> \\<ominus> f \\<ominus> g)", "thus \"weight ?lhs = weight ?rhs\""], ["proof (prove)\nusing this:\n  weight (\\<Gamma> \\<ominus> plus_current f g) ?x =\n  weight (\\<Gamma> \\<ominus> f \\<ominus> g) ?x\n\ngoal (1 subgoal):\n 1. weight (\\<Gamma> \\<ominus> plus_current f g) =\n    weight (\\<Gamma> \\<ominus> f \\<ominus> g)", ".."], ["proof (state)\nthis:\n  weight (\\<Gamma> \\<ominus> plus_current f g) =\n  weight (\\<Gamma> \\<ominus> f \\<ominus> g)\n\ngoal (4 subgoals):\n 1. edge (\\<Gamma> \\<ominus> plus_current f g) =\n    edge (\\<Gamma> \\<ominus> f \\<ominus> g)\n 2. A (\\<Gamma> \\<ominus> plus_current f g) =\n    A (\\<Gamma> \\<ominus> f \\<ominus> g)\n 3. B (\\<Gamma> \\<ominus> plus_current f g) =\n    B (\\<Gamma> \\<ominus> f \\<ominus> g)\n 4. web.more (\\<Gamma> \\<ominus> plus_current f g) =\n    web.more (\\<Gamma> \\<ominus> f \\<ominus> g)", "qed simp_all"], ["", "lemma unhindered_minus_web:\n  assumes unhindered: \"\\<not> hindered \\<Gamma>\"\n  and f: \"current \\<Gamma> f\"\n  and w: \"wave \\<Gamma> f\"\n  shows \"\\<not> hindered (\\<Gamma> \\<ominus> f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> hindered (\\<Gamma> \\<ominus> f)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. hindered (\\<Gamma> \\<ominus> f) \\<Longrightarrow> False", "assume \"hindered (\\<Gamma> \\<ominus> f)\""], ["proof (state)\nthis:\n  hindered (\\<Gamma> \\<ominus> f)\n\ngoal (1 subgoal):\n 1. hindered (\\<Gamma> \\<ominus> f) \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  hindered (\\<Gamma> \\<ominus> f)", "obtain g where g: \"current (\\<Gamma> \\<ominus> f) g\"\n    and w': \"wave (\\<Gamma> \\<ominus> f) g\"\n    and hind: \"hindrance (\\<Gamma> \\<ominus> f) g\""], ["proof (prove)\nusing this:\n  hindered (\\<Gamma> \\<ominus> f)\n\ngoal (1 subgoal):\n 1. (\\<And>g.\n        \\<lbrakk>current (\\<Gamma> \\<ominus> f) g;\n         wave (\\<Gamma> \\<ominus> f) g;\n         hindrance (\\<Gamma> \\<ominus> f) g\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by cases"], ["proof (state)\nthis:\n  current (\\<Gamma> \\<ominus> f) g\n  wave (\\<Gamma> \\<ominus> f) g\n  hindrance (\\<Gamma> \\<ominus> f) g\n\ngoal (1 subgoal):\n 1. hindered (\\<Gamma> \\<ominus> f) \\<Longrightarrow> False", "let ?fg = \"plus_current f g\""], ["proof (state)\ngoal (1 subgoal):\n 1. hindered (\\<Gamma> \\<ominus> f) \\<Longrightarrow> False", "have fg: \"current \\<Gamma> ?fg\""], ["proof (prove)\ngoal (1 subgoal):\n 1. current \\<Gamma> (plus_current f g)", "using f g"], ["proof (prove)\nusing this:\n  current \\<Gamma> f\n  current (\\<Gamma> \\<ominus> f) g\n\ngoal (1 subgoal):\n 1. current \\<Gamma> (plus_current f g)", "by(rule current_plus_current_minus)"], ["proof (state)\nthis:\n  current \\<Gamma> (plus_current f g)\n\ngoal (1 subgoal):\n 1. hindered (\\<Gamma> \\<ominus> f) \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  current \\<Gamma> (plus_current f g)\n\ngoal (1 subgoal):\n 1. hindered (\\<Gamma> \\<ominus> f) \\<Longrightarrow> False", "have \"wave \\<Gamma> ?fg\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wave \\<Gamma> (plus_current f g)", "using f w g w'"], ["proof (prove)\nusing this:\n  current \\<Gamma> f\n  wave \\<Gamma> f\n  current (\\<Gamma> \\<ominus> f) g\n  wave (\\<Gamma> \\<ominus> f) g\n\ngoal (1 subgoal):\n 1. wave \\<Gamma> (plus_current f g)", "by(rule wave_plus_current_minus)"], ["proof (state)\nthis:\n  wave \\<Gamma> (plus_current f g)\n\ngoal (1 subgoal):\n 1. hindered (\\<Gamma> \\<ominus> f) \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  wave \\<Gamma> (plus_current f g)\n\ngoal (1 subgoal):\n 1. hindered (\\<Gamma> \\<ominus> f) \\<Longrightarrow> False", "from hind"], ["proof (chain)\npicking this:\n  hindrance (\\<Gamma> \\<ominus> f) g", "obtain a where a: \"a \\<in> A \\<Gamma>\" and n\\<E>: \"a \\<notin> \\<E>\\<^bsub>\\<Gamma> \\<ominus> f\\<^esub> (TER\\<^bsub>\\<Gamma> \\<ominus> f\\<^esub> g)\"\n    and wa: \"d_OUT g a < weight (\\<Gamma> \\<ominus> f) a\""], ["proof (prove)\nusing this:\n  hindrance (\\<Gamma> \\<ominus> f) g\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>a \\<in> A \\<Gamma>;\n         a \\<notin> \\<E>\\<^bsub>\\<Gamma> \\<ominus> f\\<^esub>\n                     (TER\\<^bsub>\\<Gamma> \\<ominus> f\\<^esub> g);\n         d_OUT g a < weight (\\<Gamma> \\<ominus> f) a\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by cases auto"], ["proof (state)\nthis:\n  a \\<in> A \\<Gamma>\n  a \\<notin> \\<E>\\<^bsub>\\<Gamma> \\<ominus> f\\<^esub>\n              (TER\\<^bsub>\\<Gamma> \\<ominus> f\\<^esub> g)\n  d_OUT g a < weight (\\<Gamma> \\<ominus> f) a\n\ngoal (1 subgoal):\n 1. hindered (\\<Gamma> \\<ominus> f) \\<Longrightarrow> False", "from a"], ["proof (chain)\npicking this:\n  a \\<in> A \\<Gamma>", "have \"hindrance \\<Gamma> ?fg\""], ["proof (prove)\nusing this:\n  a \\<in> A \\<Gamma>\n\ngoal (1 subgoal):\n 1. hindrance \\<Gamma> (plus_current f g)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. a \\<notin> \\<E> (TER (plus_current f g))\n 2. d_OUT (plus_current f g) a < weight \\<Gamma> a", "show \"a \\<notin> \\<E> (TER ?fg)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<notin> \\<E> (TER (plus_current f g))", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. a \\<in> \\<E> (TER (plus_current f g)) \\<Longrightarrow> False", "assume \\<E>: \"a \\<in> \\<E> (TER ?fg)\""], ["proof (state)\nthis:\n  a \\<in> \\<E> (TER (plus_current f g))\n\ngoal (1 subgoal):\n 1. a \\<in> \\<E> (TER (plus_current f g)) \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  a \\<in> \\<E> (TER (plus_current f g))", "obtain p y where p: \"path \\<Gamma> a p y\" and y: \"y \\<in> B \\<Gamma>\"\n        and bypass: \"\\<And>z. z \\<in> set p \\<Longrightarrow> z \\<notin> RF (TER ?fg)\""], ["proof (prove)\nusing this:\n  a \\<in> \\<E> (TER (plus_current f g))\n\ngoal (1 subgoal):\n 1. (\\<And>p y.\n        \\<lbrakk>path \\<Gamma> a p y; y \\<in> B \\<Gamma>;\n         \\<And>z.\n            z \\<in> set p \\<Longrightarrow>\n            z \\<notin> RF (TER (plus_current f g))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(rule \\<E>_E_RF) blast"], ["proof (state)\nthis:\n  path \\<Gamma> a p y\n  y \\<in> B \\<Gamma>\n  ?z \\<in> set p \\<Longrightarrow> ?z \\<notin> RF (TER (plus_current f g))\n\ngoal (1 subgoal):\n 1. a \\<in> \\<E> (TER (plus_current f g)) \\<Longrightarrow> False", "from p a y disjoint"], ["proof (chain)\npicking this:\n  path \\<Gamma> a p y\n  a \\<in> A \\<Gamma>\n  y \\<in> B \\<Gamma>\n  A \\<Gamma> \\<inter> B \\<Gamma> = {}", "have py: \"p = [y]\""], ["proof (prove)\nusing this:\n  path \\<Gamma> a p y\n  a \\<in> A \\<Gamma>\n  y \\<in> B \\<Gamma>\n  A \\<Gamma> \\<inter> B \\<Gamma> = {}\n\ngoal (1 subgoal):\n 1. p = [y]", "by(cases)(auto 4 3 elim: rtrancl_path.cases dest: bipartite_E)"], ["proof (state)\nthis:\n  p = [y]\n\ngoal (1 subgoal):\n 1. a \\<in> \\<E> (TER (plus_current f g)) \\<Longrightarrow> False", "from bypass[of y] py"], ["proof (chain)\npicking this:\n  y \\<in> set p \\<Longrightarrow> y \\<notin> RF (TER (plus_current f g))\n  p = [y]", "have \"y \\<notin> TER ?fg\""], ["proof (prove)\nusing this:\n  y \\<in> set p \\<Longrightarrow> y \\<notin> RF (TER (plus_current f g))\n  p = [y]\n\ngoal (1 subgoal):\n 1. y \\<notin> TER (plus_current f g)", "by(auto intro: roofed_greaterI)"], ["proof (state)\nthis:\n  y \\<notin> TER (plus_current f g)\n\ngoal (1 subgoal):\n 1. a \\<in> \\<E> (TER (plus_current f g)) \\<Longrightarrow> False", "with currentD_OUT[OF fg y]"], ["proof (chain)\npicking this:\n  d_OUT (plus_current f g) y = 0\n  y \\<notin> TER (plus_current f g)", "have \"y \\<notin> SAT \\<Gamma> ?fg\""], ["proof (prove)\nusing this:\n  d_OUT (plus_current f g) y = 0\n  y \\<notin> TER (plus_current f g)\n\ngoal (1 subgoal):\n 1. y \\<notin> SAT \\<Gamma> (plus_current f g)", "by(auto simp add: SINK.simps)"], ["proof (state)\nthis:\n  y \\<notin> SAT \\<Gamma> (plus_current f g)\n\ngoal (1 subgoal):\n 1. a \\<in> \\<E> (TER (plus_current f g)) \\<Longrightarrow> False", "hence \"y \\<notin> SAT (\\<Gamma> \\<ominus> f) g\""], ["proof (prove)\nusing this:\n  y \\<notin> SAT \\<Gamma> (plus_current f g)\n\ngoal (1 subgoal):\n 1. y \\<notin> SAT (\\<Gamma> \\<ominus> f) g", "using y currentD_OUT[OF f y] currentD_finite_IN[OF f, of y]"], ["proof (prove)\nusing this:\n  y \\<notin> SAT \\<Gamma> (plus_current f g)\n  y \\<in> B \\<Gamma>\n  d_OUT f y = 0\n  d_IN f y \\<noteq> \\<top>\n\ngoal (1 subgoal):\n 1. y \\<notin> SAT (\\<Gamma> \\<ominus> f) g", "by(auto simp add: SAT.simps d_IN_def nn_integral_add ennreal_minus_le_iff add.commute)"], ["proof (state)\nthis:\n  y \\<notin> SAT (\\<Gamma> \\<ominus> f) g\n\ngoal (1 subgoal):\n 1. a \\<in> \\<E> (TER (plus_current f g)) \\<Longrightarrow> False", "hence \"essential (\\<Gamma> \\<ominus> f) (B (\\<Gamma> \\<ominus> f)) (TER\\<^bsub>\\<Gamma> \\<ominus> f\\<^esub> g) a\""], ["proof (prove)\nusing this:\n  y \\<notin> SAT (\\<Gamma> \\<ominus> f) g\n\ngoal (1 subgoal):\n 1. essential (\\<Gamma> \\<ominus> f) (B (\\<Gamma> \\<ominus> f))\n     (TER\\<^bsub>\\<Gamma> \\<ominus> f\\<^esub> g) a", "using p py y"], ["proof (prove)\nusing this:\n  y \\<notin> SAT (\\<Gamma> \\<ominus> f) g\n  path \\<Gamma> a p y\n  p = [y]\n  y \\<in> B \\<Gamma>\n\ngoal (1 subgoal):\n 1. essential (\\<Gamma> \\<ominus> f) (B (\\<Gamma> \\<ominus> f))\n     (TER\\<^bsub>\\<Gamma> \\<ominus> f\\<^esub> g) a", "by(auto intro!: essentialI)"], ["proof (state)\nthis:\n  essential (\\<Gamma> \\<ominus> f) (B (\\<Gamma> \\<ominus> f))\n   (TER\\<^bsub>\\<Gamma> \\<ominus> f\\<^esub> g) a\n\ngoal (1 subgoal):\n 1. a \\<in> \\<E> (TER (plus_current f g)) \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  essential (\\<Gamma> \\<ominus> f) (B (\\<Gamma> \\<ominus> f))\n   (TER\\<^bsub>\\<Gamma> \\<ominus> f\\<^esub> g) a\n\ngoal (1 subgoal):\n 1. a \\<in> \\<E> (TER (plus_current f g)) \\<Longrightarrow> False", "from \\<E> a"], ["proof (chain)\npicking this:\n  a \\<in> \\<E> (TER (plus_current f g))\n  a \\<in> A \\<Gamma>", "have \"a \\<in> TER\\<^bsub>\\<Gamma> \\<ominus> f\\<^esub> g\""], ["proof (prove)\nusing this:\n  a \\<in> \\<E> (TER (plus_current f g))\n  a \\<in> A \\<Gamma>\n\ngoal (1 subgoal):\n 1. a \\<in> TER\\<^bsub>\\<Gamma> \\<ominus> f\\<^esub> g", "by(auto simp add: SAT.A SINK_plus_current)"], ["proof (state)\nthis:\n  a \\<in> TER\\<^bsub>\\<Gamma> \\<ominus> f\\<^esub> g\n\ngoal (1 subgoal):\n 1. a \\<in> \\<E> (TER (plus_current f g)) \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  essential (\\<Gamma> \\<ominus> f) (B (\\<Gamma> \\<ominus> f))\n   (TER\\<^bsub>\\<Gamma> \\<ominus> f\\<^esub> g) a\n  a \\<in> TER\\<^bsub>\\<Gamma> \\<ominus> f\\<^esub> g", "have \"a \\<in> \\<E>\\<^bsub>\\<Gamma> \\<ominus> f\\<^esub> (TER\\<^bsub>\\<Gamma> \\<ominus> f\\<^esub> g)\""], ["proof (prove)\nusing this:\n  essential (\\<Gamma> \\<ominus> f) (B (\\<Gamma> \\<ominus> f))\n   (TER\\<^bsub>\\<Gamma> \\<ominus> f\\<^esub> g) a\n  a \\<in> TER\\<^bsub>\\<Gamma> \\<ominus> f\\<^esub> g\n\ngoal (1 subgoal):\n 1. a \\<in> \\<E>\\<^bsub>\\<Gamma> \\<ominus> f\\<^esub>\n             (TER\\<^bsub>\\<Gamma> \\<ominus> f\\<^esub> g)", "by blast"], ["proof (state)\nthis:\n  a \\<in> \\<E>\\<^bsub>\\<Gamma> \\<ominus> f\\<^esub>\n           (TER\\<^bsub>\\<Gamma> \\<ominus> f\\<^esub> g)\n\ngoal (1 subgoal):\n 1. a \\<in> \\<E> (TER (plus_current f g)) \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  a \\<in> \\<E>\\<^bsub>\\<Gamma> \\<ominus> f\\<^esub>\n           (TER\\<^bsub>\\<Gamma> \\<ominus> f\\<^esub> g)\n\ngoal (1 subgoal):\n 1. False", "using n\\<E>"], ["proof (prove)\nusing this:\n  a \\<in> \\<E>\\<^bsub>\\<Gamma> \\<ominus> f\\<^esub>\n           (TER\\<^bsub>\\<Gamma> \\<ominus> f\\<^esub> g)\n  a \\<notin> \\<E>\\<^bsub>\\<Gamma> \\<ominus> f\\<^esub>\n              (TER\\<^bsub>\\<Gamma> \\<ominus> f\\<^esub> g)\n\ngoal (1 subgoal):\n 1. False", "by contradiction"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  a \\<notin> \\<E> (TER (plus_current f g))\n\ngoal (1 subgoal):\n 1. d_OUT (plus_current f g) a < weight \\<Gamma> a", "show \"d_OUT ?fg a < weight \\<Gamma> a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT (plus_current f g) a < weight \\<Gamma> a", "using a wa currentD_finite_OUT[OF f, of a]"], ["proof (prove)\nusing this:\n  a \\<in> A \\<Gamma>\n  d_OUT g a < weight (\\<Gamma> \\<ominus> f) a\n  d_OUT f a \\<noteq> \\<top>\n\ngoal (1 subgoal):\n 1. d_OUT (plus_current f g) a < weight \\<Gamma> a", "by(simp add: d_OUT_def less_diff_eq_ennreal less_top add.commute nn_integral_add)"], ["proof (state)\nthis:\n  d_OUT (plus_current f g) a < weight \\<Gamma> a\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  hindrance \\<Gamma> (plus_current f g)\n\ngoal (1 subgoal):\n 1. hindered (\\<Gamma> \\<ominus> f) \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  current \\<Gamma> (plus_current f g)\n  wave \\<Gamma> (plus_current f g)\n  hindrance \\<Gamma> (plus_current f g)", "have \"hindered \\<Gamma>\""], ["proof (prove)\nusing this:\n  current \\<Gamma> (plus_current f g)\n  wave \\<Gamma> (plus_current f g)\n  hindrance \\<Gamma> (plus_current f g)\n\ngoal (1 subgoal):\n 1. hindered \\<Gamma>", "by(blast intro: hindered.intros)"], ["proof (state)\nthis:\n  hindered \\<Gamma>\n\ngoal (1 subgoal):\n 1. hindered (\\<Gamma> \\<ominus> f) \\<Longrightarrow> False", "with unhindered"], ["proof (chain)\npicking this:\n  \\<not> hindered \\<Gamma>\n  hindered \\<Gamma>", "show False"], ["proof (prove)\nusing this:\n  \\<not> hindered \\<Gamma>\n  hindered \\<Gamma>\n\ngoal (1 subgoal):\n 1. False", "by contradiction"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma loose_minus_web:\n  assumes unhindered: \"\\<not> hindered \\<Gamma>\"\n  and f: \"current \\<Gamma> f\"\n  and w: \"wave \\<Gamma> f\"\n  and maximal: \"\\<And>w. \\<lbrakk> current \\<Gamma> w; wave \\<Gamma> w; f \\<le> w \\<rbrakk> \\<Longrightarrow> f = w\"\n  shows \"loose (\\<Gamma> \\<ominus> f)\" (is \"loose ?\\<Gamma>\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. loose (\\<Gamma> \\<ominus> f)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>fa.\n       \\<lbrakk>current (\\<Gamma> \\<ominus> f) fa;\n        wave (\\<Gamma> \\<ominus> f) fa\\<rbrakk>\n       \\<Longrightarrow> fa = (\\<lambda>_. 0)\n 2. \\<not> hindrance (\\<Gamma> \\<ominus> f) (\\<lambda>_. 0)", "fix g"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>fa.\n       \\<lbrakk>current (\\<Gamma> \\<ominus> f) fa;\n        wave (\\<Gamma> \\<ominus> f) fa\\<rbrakk>\n       \\<Longrightarrow> fa = (\\<lambda>_. 0)\n 2. \\<not> hindrance (\\<Gamma> \\<ominus> f) (\\<lambda>_. 0)", "assume g: \"current ?\\<Gamma> g\" and w': \"wave ?\\<Gamma> g\""], ["proof (state)\nthis:\n  current (\\<Gamma> \\<ominus> f) g\n  wave (\\<Gamma> \\<ominus> f) g\n\ngoal (2 subgoals):\n 1. \\<And>fa.\n       \\<lbrakk>current (\\<Gamma> \\<ominus> f) fa;\n        wave (\\<Gamma> \\<ominus> f) fa\\<rbrakk>\n       \\<Longrightarrow> fa = (\\<lambda>_. 0)\n 2. \\<not> hindrance (\\<Gamma> \\<ominus> f) (\\<lambda>_. 0)", "let ?g = \"plus_current f g\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>fa.\n       \\<lbrakk>current (\\<Gamma> \\<ominus> f) fa;\n        wave (\\<Gamma> \\<ominus> f) fa\\<rbrakk>\n       \\<Longrightarrow> fa = (\\<lambda>_. 0)\n 2. \\<not> hindrance (\\<Gamma> \\<ominus> f) (\\<lambda>_. 0)", "from f g"], ["proof (chain)\npicking this:\n  current \\<Gamma> f\n  current (\\<Gamma> \\<ominus> f) g", "have \"current \\<Gamma> ?g\""], ["proof (prove)\nusing this:\n  current \\<Gamma> f\n  current (\\<Gamma> \\<ominus> f) g\n\ngoal (1 subgoal):\n 1. current \\<Gamma> (plus_current f g)", "by(rule current_plus_current_minus)"], ["proof (state)\nthis:\n  current \\<Gamma> (plus_current f g)\n\ngoal (2 subgoals):\n 1. \\<And>fa.\n       \\<lbrakk>current (\\<Gamma> \\<ominus> f) fa;\n        wave (\\<Gamma> \\<ominus> f) fa\\<rbrakk>\n       \\<Longrightarrow> fa = (\\<lambda>_. 0)\n 2. \\<not> hindrance (\\<Gamma> \\<ominus> f) (\\<lambda>_. 0)", "moreover"], ["proof (state)\nthis:\n  current \\<Gamma> (plus_current f g)\n\ngoal (2 subgoals):\n 1. \\<And>fa.\n       \\<lbrakk>current (\\<Gamma> \\<ominus> f) fa;\n        wave (\\<Gamma> \\<ominus> f) fa\\<rbrakk>\n       \\<Longrightarrow> fa = (\\<lambda>_. 0)\n 2. \\<not> hindrance (\\<Gamma> \\<ominus> f) (\\<lambda>_. 0)", "from f w g w'"], ["proof (chain)\npicking this:\n  current \\<Gamma> f\n  wave \\<Gamma> f\n  current (\\<Gamma> \\<ominus> f) g\n  wave (\\<Gamma> \\<ominus> f) g", "have \"wave \\<Gamma> ?g\""], ["proof (prove)\nusing this:\n  current \\<Gamma> f\n  wave \\<Gamma> f\n  current (\\<Gamma> \\<ominus> f) g\n  wave (\\<Gamma> \\<ominus> f) g\n\ngoal (1 subgoal):\n 1. wave \\<Gamma> (plus_current f g)", "by(rule wave_plus_current_minus)"], ["proof (state)\nthis:\n  wave \\<Gamma> (plus_current f g)\n\ngoal (2 subgoals):\n 1. \\<And>fa.\n       \\<lbrakk>current (\\<Gamma> \\<ominus> f) fa;\n        wave (\\<Gamma> \\<ominus> f) fa\\<rbrakk>\n       \\<Longrightarrow> fa = (\\<lambda>_. 0)\n 2. \\<not> hindrance (\\<Gamma> \\<ominus> f) (\\<lambda>_. 0)", "moreover"], ["proof (state)\nthis:\n  wave \\<Gamma> (plus_current f g)\n\ngoal (2 subgoals):\n 1. \\<And>fa.\n       \\<lbrakk>current (\\<Gamma> \\<ominus> f) fa;\n        wave (\\<Gamma> \\<ominus> f) fa\\<rbrakk>\n       \\<Longrightarrow> fa = (\\<lambda>_. 0)\n 2. \\<not> hindrance (\\<Gamma> \\<ominus> f) (\\<lambda>_. 0)", "have \"f \\<le> ?g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<le> plus_current f g", "by(clarsimp simp add: le_fun_def)"], ["proof (state)\nthis:\n  f \\<le> plus_current f g\n\ngoal (2 subgoals):\n 1. \\<And>fa.\n       \\<lbrakk>current (\\<Gamma> \\<ominus> f) fa;\n        wave (\\<Gamma> \\<ominus> f) fa\\<rbrakk>\n       \\<Longrightarrow> fa = (\\<lambda>_. 0)\n 2. \\<not> hindrance (\\<Gamma> \\<ominus> f) (\\<lambda>_. 0)", "ultimately"], ["proof (chain)\npicking this:\n  current \\<Gamma> (plus_current f g)\n  wave \\<Gamma> (plus_current f g)\n  f \\<le> plus_current f g", "have eq: \"f = ?g\""], ["proof (prove)\nusing this:\n  current \\<Gamma> (plus_current f g)\n  wave \\<Gamma> (plus_current f g)\n  f \\<le> plus_current f g\n\ngoal (1 subgoal):\n 1. f = plus_current f g", "by(rule maximal)"], ["proof (state)\nthis:\n  f = plus_current f g\n\ngoal (2 subgoals):\n 1. \\<And>fa.\n       \\<lbrakk>current (\\<Gamma> \\<ominus> f) fa;\n        wave (\\<Gamma> \\<ominus> f) fa\\<rbrakk>\n       \\<Longrightarrow> fa = (\\<lambda>_. 0)\n 2. \\<not> hindrance (\\<Gamma> \\<ominus> f) (\\<lambda>_. 0)", "have \"g e = 0\" for e"], ["proof (prove)\ngoal (1 subgoal):\n 1. g e = 0", "proof(cases e)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b. e = (a, b) \\<Longrightarrow> g e = 0", "case (Pair x y)"], ["proof (state)\nthis:\n  e = (x, y)\n\ngoal (1 subgoal):\n 1. \\<And>a b. e = (a, b) \\<Longrightarrow> g e = 0", "have \"f e \\<le> d_OUT f x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f e \\<le> d_OUT f x", "unfolding d_OUT_def Pair"], ["proof (prove)\ngoal (1 subgoal):\n 1. f (x, y) \\<le> (\\<Sum>\\<^sup>+ y. f (x, y))", "by(rule nn_integral_ge_point) simp"], ["proof (state)\nthis:\n  f e \\<le> d_OUT f x\n\ngoal (1 subgoal):\n 1. \\<And>a b. e = (a, b) \\<Longrightarrow> g e = 0", "also"], ["proof (state)\nthis:\n  f e \\<le> d_OUT f x\n\ngoal (1 subgoal):\n 1. \\<And>a b. e = (a, b) \\<Longrightarrow> g e = 0", "have \"\\<dots> \\<le> weight \\<Gamma> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT f x \\<le> weight \\<Gamma> x", "by(rule currentD_weight_OUT[OF f])"], ["proof (state)\nthis:\n  d_OUT f x \\<le> weight \\<Gamma> x\n\ngoal (1 subgoal):\n 1. \\<And>a b. e = (a, b) \\<Longrightarrow> g e = 0", "also"], ["proof (state)\nthis:\n  d_OUT f x \\<le> weight \\<Gamma> x\n\ngoal (1 subgoal):\n 1. \\<And>a b. e = (a, b) \\<Longrightarrow> g e = 0", "have \"\\<dots> < \\<top>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. weight \\<Gamma> x < \\<top>", "by(simp add: less_top[symmetric])"], ["proof (state)\nthis:\n  weight \\<Gamma> x < \\<top>\n\ngoal (1 subgoal):\n 1. \\<And>a b. e = (a, b) \\<Longrightarrow> g e = 0", "finally"], ["proof (chain)\npicking this:\n  f e < \\<top>", "show \"g e = 0\""], ["proof (prove)\nusing this:\n  f e < \\<top>\n\ngoal (1 subgoal):\n 1. g e = 0", "using Pair eq[THEN fun_cong, of e]"], ["proof (prove)\nusing this:\n  f e < \\<top>\n  e = (x, y)\n  f e = plus_current f g e\n\ngoal (1 subgoal):\n 1. g e = 0", "by(cases \"f e\" \"g e\" rule: ennreal2_cases)(simp_all add: fun_eq_iff)"], ["proof (state)\nthis:\n  g e = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  g ?e = 0\n\ngoal (2 subgoals):\n 1. \\<And>fa.\n       \\<lbrakk>current (\\<Gamma> \\<ominus> f) fa;\n        wave (\\<Gamma> \\<ominus> f) fa\\<rbrakk>\n       \\<Longrightarrow> fa = (\\<lambda>_. 0)\n 2. \\<not> hindrance (\\<Gamma> \\<ominus> f) (\\<lambda>_. 0)", "thus \"g = (\\<lambda>_. 0)\""], ["proof (prove)\nusing this:\n  g ?e = 0\n\ngoal (1 subgoal):\n 1. g = (\\<lambda>_. 0)", "by(simp add: fun_eq_iff)"], ["proof (state)\nthis:\n  g = (\\<lambda>_. 0)\n\ngoal (1 subgoal):\n 1. \\<not> hindrance (\\<Gamma> \\<ominus> f) (\\<lambda>_. 0)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> hindrance (\\<Gamma> \\<ominus> f) (\\<lambda>_. 0)", "show \"\\<not> hindrance ?\\<Gamma> zero_current\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> hindrance (\\<Gamma> \\<ominus> f) (\\<lambda>_. 0)", "using unhindered"], ["proof (prove)\nusing this:\n  \\<not> hindered \\<Gamma>\n\ngoal (1 subgoal):\n 1. \\<not> hindrance (\\<Gamma> \\<ominus> f) (\\<lambda>_. 0)", "proof(rule contrapos_nn)"], ["proof (state)\ngoal (1 subgoal):\n 1. hindrance (\\<Gamma> \\<ominus> f) (\\<lambda>_. 0) \\<Longrightarrow>\n    hindered \\<Gamma>", "assume \"hindrance ?\\<Gamma> zero_current\""], ["proof (state)\nthis:\n  hindrance (\\<Gamma> \\<ominus> f) (\\<lambda>_. 0)\n\ngoal (1 subgoal):\n 1. hindrance (\\<Gamma> \\<ominus> f) (\\<lambda>_. 0) \\<Longrightarrow>\n    hindered \\<Gamma>", "then"], ["proof (chain)\npicking this:\n  hindrance (\\<Gamma> \\<ominus> f) (\\<lambda>_. 0)", "obtain x where a: \"x \\<in> A ?\\<Gamma>\" and \\<E>: \"x \\<notin> \\<E>\\<^bsub>?\\<Gamma>\\<^esub> (TER\\<^bsub>?\\<Gamma>\\<^esub> zero_current)\"\n      and weight: \"d_OUT zero_current x < weight ?\\<Gamma> x\""], ["proof (prove)\nusing this:\n  hindrance (\\<Gamma> \\<ominus> f) (\\<lambda>_. 0)\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>x \\<in> A (\\<Gamma> \\<ominus> f);\n         x \\<notin> \\<E>\\<^bsub>\\<Gamma> \\<ominus> f\\<^esub>\n                     (TER\\<^bsub>\\<Gamma> \\<ominus> f\\<^esub>\n                       (\\<lambda>_. 0));\n         d_OUT (\\<lambda>_. 0) x < weight (\\<Gamma> \\<ominus> f) x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by cases"], ["proof (state)\nthis:\n  x \\<in> A (\\<Gamma> \\<ominus> f)\n  x \\<notin> \\<E>\\<^bsub>\\<Gamma> \\<ominus> f\\<^esub>\n              (TER\\<^bsub>\\<Gamma> \\<ominus> f\\<^esub> (\\<lambda>_. 0))\n  d_OUT (\\<lambda>_. 0) x < weight (\\<Gamma> \\<ominus> f) x\n\ngoal (1 subgoal):\n 1. hindrance (\\<Gamma> \\<ominus> f) (\\<lambda>_. 0) \\<Longrightarrow>\n    hindered \\<Gamma>", "have \"hindrance \\<Gamma> f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hindrance \\<Gamma> f", "proof"], ["proof (state)\ngoal (3 subgoals):\n 1. ?a \\<in> A \\<Gamma>\n 2. ?a \\<notin> \\<E> (TER f)\n 3. d_OUT f ?a < weight \\<Gamma> ?a", "show a': \"x \\<in> A \\<Gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> A \\<Gamma>", "using a"], ["proof (prove)\nusing this:\n  x \\<in> A (\\<Gamma> \\<ominus> f)\n\ngoal (1 subgoal):\n 1. x \\<in> A \\<Gamma>", "by simp"], ["proof (state)\nthis:\n  x \\<in> A \\<Gamma>\n\ngoal (2 subgoals):\n 1. x \\<notin> \\<E> (TER f)\n 2. d_OUT f x < weight \\<Gamma> x", "with weight"], ["proof (chain)\npicking this:\n  d_OUT (\\<lambda>_. 0) x < weight (\\<Gamma> \\<ominus> f) x\n  x \\<in> A \\<Gamma>", "show \"d_OUT f x < weight \\<Gamma> x\""], ["proof (prove)\nusing this:\n  d_OUT (\\<lambda>_. 0) x < weight (\\<Gamma> \\<ominus> f) x\n  x \\<in> A \\<Gamma>\n\ngoal (1 subgoal):\n 1. d_OUT f x < weight \\<Gamma> x", "by(simp add: less_diff_eq_ennreal less_top[symmetric] currentD_finite_OUT[OF f])"], ["proof (state)\nthis:\n  d_OUT f x < weight \\<Gamma> x\n\ngoal (1 subgoal):\n 1. x \\<notin> \\<E> (TER f)", "show \"x \\<notin> \\<E> (TER f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> \\<E> (TER f)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<in> \\<E> (TER f) \\<Longrightarrow> False", "assume \"x \\<in> \\<E> (TER f)\""], ["proof (state)\nthis:\n  x \\<in> \\<E> (TER f)\n\ngoal (1 subgoal):\n 1. x \\<in> \\<E> (TER f) \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  x \\<in> \\<E> (TER f)", "obtain p y where p: \"path \\<Gamma> x p y\" and y: \"y \\<in> B \\<Gamma>\"\n          and bypass: \"\\<And>z. z \\<in> set p \\<Longrightarrow> z \\<notin> RF (TER f)\""], ["proof (prove)\nusing this:\n  x \\<in> \\<E> (TER f)\n\ngoal (1 subgoal):\n 1. (\\<And>p y.\n        \\<lbrakk>path \\<Gamma> x p y; y \\<in> B \\<Gamma>;\n         \\<And>z.\n            z \\<in> set p \\<Longrightarrow> z \\<notin> RF (TER f)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(rule \\<E>_E_RF) auto"], ["proof (state)\nthis:\n  path \\<Gamma> x p y\n  y \\<in> B \\<Gamma>\n  ?z \\<in> set p \\<Longrightarrow> ?z \\<notin> RF (TER f)\n\ngoal (1 subgoal):\n 1. x \\<in> \\<E> (TER f) \\<Longrightarrow> False", "from p a' y disjoint"], ["proof (chain)\npicking this:\n  path \\<Gamma> x p y\n  x \\<in> A \\<Gamma>\n  y \\<in> B \\<Gamma>\n  A \\<Gamma> \\<inter> B \\<Gamma> = {}", "have py: \"p = [y]\""], ["proof (prove)\nusing this:\n  path \\<Gamma> x p y\n  x \\<in> A \\<Gamma>\n  y \\<in> B \\<Gamma>\n  A \\<Gamma> \\<inter> B \\<Gamma> = {}\n\ngoal (1 subgoal):\n 1. p = [y]", "by(cases)(auto 4 3 elim: rtrancl_path.cases dest: bipartite_E)"], ["proof (state)\nthis:\n  p = [y]\n\ngoal (1 subgoal):\n 1. x \\<in> \\<E> (TER f) \\<Longrightarrow> False", "hence \"y \\<notin> (TER f)\""], ["proof (prove)\nusing this:\n  p = [y]\n\ngoal (1 subgoal):\n 1. y \\<notin> TER f", "using bypass[of y]"], ["proof (prove)\nusing this:\n  p = [y]\n  y \\<in> set p \\<Longrightarrow> y \\<notin> RF (TER f)\n\ngoal (1 subgoal):\n 1. y \\<notin> TER f", "by(auto intro: roofed_greaterI)"], ["proof (state)\nthis:\n  y \\<notin> TER f\n\ngoal (1 subgoal):\n 1. x \\<in> \\<E> (TER f) \\<Longrightarrow> False", "hence \"weight ?\\<Gamma> y > 0\""], ["proof (prove)\nusing this:\n  y \\<notin> TER f\n\ngoal (1 subgoal):\n 1. 0 < weight (\\<Gamma> \\<ominus> f) y", "using currentD_OUT[OF f y] disjoint y"], ["proof (prove)\nusing this:\n  y \\<notin> TER f\n  d_OUT f y = 0\n  A \\<Gamma> \\<inter> B \\<Gamma> = {}\n  y \\<in> B \\<Gamma>\n\ngoal (1 subgoal):\n 1. 0 < weight (\\<Gamma> \\<ominus> f) y", "by(auto simp add: SINK.simps SAT.simps diff_gr0_ennreal)"], ["proof (state)\nthis:\n  0 < weight (\\<Gamma> \\<ominus> f) y\n\ngoal (1 subgoal):\n 1. x \\<in> \\<E> (TER f) \\<Longrightarrow> False", "hence \"y \\<notin> TER\\<^bsub>?\\<Gamma>\\<^esub> zero_current\""], ["proof (prove)\nusing this:\n  0 < weight (\\<Gamma> \\<ominus> f) y\n\ngoal (1 subgoal):\n 1. y \\<notin> TER\\<^bsub>\\<Gamma> \\<ominus> f\\<^esub> (\\<lambda>_. 0)", "using y disjoint"], ["proof (prove)\nusing this:\n  0 < weight (\\<Gamma> \\<ominus> f) y\n  y \\<in> B \\<Gamma>\n  A \\<Gamma> \\<inter> B \\<Gamma> = {}\n\ngoal (1 subgoal):\n 1. y \\<notin> TER\\<^bsub>\\<Gamma> \\<ominus> f\\<^esub> (\\<lambda>_. 0)", "by(auto)"], ["proof (state)\nthis:\n  y \\<notin> TER\\<^bsub>\\<Gamma> \\<ominus> f\\<^esub> (\\<lambda>_. 0)\n\ngoal (1 subgoal):\n 1. x \\<in> \\<E> (TER f) \\<Longrightarrow> False", "hence \"essential ?\\<Gamma> (B ?\\<Gamma>) (TER\\<^bsub>?\\<Gamma>\\<^esub> zero_current) x\""], ["proof (prove)\nusing this:\n  y \\<notin> TER\\<^bsub>\\<Gamma> \\<ominus> f\\<^esub> (\\<lambda>_. 0)\n\ngoal (1 subgoal):\n 1. essential (\\<Gamma> \\<ominus> f) (B (\\<Gamma> \\<ominus> f))\n     (TER\\<^bsub>\\<Gamma> \\<ominus> f\\<^esub> (\\<lambda>_. 0)) x", "using p y py"], ["proof (prove)\nusing this:\n  y \\<notin> TER\\<^bsub>\\<Gamma> \\<ominus> f\\<^esub> (\\<lambda>_. 0)\n  path \\<Gamma> x p y\n  y \\<in> B \\<Gamma>\n  p = [y]\n\ngoal (1 subgoal):\n 1. essential (\\<Gamma> \\<ominus> f) (B (\\<Gamma> \\<ominus> f))\n     (TER\\<^bsub>\\<Gamma> \\<ominus> f\\<^esub> (\\<lambda>_. 0)) x", "by(auto intro!: essentialI)"], ["proof (state)\nthis:\n  essential (\\<Gamma> \\<ominus> f) (B (\\<Gamma> \\<ominus> f))\n   (TER\\<^bsub>\\<Gamma> \\<ominus> f\\<^esub> (\\<lambda>_. 0)) x\n\ngoal (1 subgoal):\n 1. x \\<in> \\<E> (TER f) \\<Longrightarrow> False", "with a"], ["proof (chain)\npicking this:\n  x \\<in> A (\\<Gamma> \\<ominus> f)\n  essential (\\<Gamma> \\<ominus> f) (B (\\<Gamma> \\<ominus> f))\n   (TER\\<^bsub>\\<Gamma> \\<ominus> f\\<^esub> (\\<lambda>_. 0)) x", "have \"x \\<in> \\<E>\\<^bsub>?\\<Gamma>\\<^esub> (TER\\<^bsub>?\\<Gamma>\\<^esub> zero_current)\""], ["proof (prove)\nusing this:\n  x \\<in> A (\\<Gamma> \\<ominus> f)\n  essential (\\<Gamma> \\<ominus> f) (B (\\<Gamma> \\<ominus> f))\n   (TER\\<^bsub>\\<Gamma> \\<ominus> f\\<^esub> (\\<lambda>_. 0)) x\n\ngoal (1 subgoal):\n 1. x \\<in> \\<E>\\<^bsub>\\<Gamma> \\<ominus> f\\<^esub>\n             (TER\\<^bsub>\\<Gamma> \\<ominus> f\\<^esub> (\\<lambda>_. 0))", "by simp"], ["proof (state)\nthis:\n  x \\<in> \\<E>\\<^bsub>\\<Gamma> \\<ominus> f\\<^esub>\n           (TER\\<^bsub>\\<Gamma> \\<ominus> f\\<^esub> (\\<lambda>_. 0))\n\ngoal (1 subgoal):\n 1. x \\<in> \\<E> (TER f) \\<Longrightarrow> False", "with \\<E>"], ["proof (chain)\npicking this:\n  x \\<notin> \\<E>\\<^bsub>\\<Gamma> \\<ominus> f\\<^esub>\n              (TER\\<^bsub>\\<Gamma> \\<ominus> f\\<^esub> (\\<lambda>_. 0))\n  x \\<in> \\<E>\\<^bsub>\\<Gamma> \\<ominus> f\\<^esub>\n           (TER\\<^bsub>\\<Gamma> \\<ominus> f\\<^esub> (\\<lambda>_. 0))", "show False"], ["proof (prove)\nusing this:\n  x \\<notin> \\<E>\\<^bsub>\\<Gamma> \\<ominus> f\\<^esub>\n              (TER\\<^bsub>\\<Gamma> \\<ominus> f\\<^esub> (\\<lambda>_. 0))\n  x \\<in> \\<E>\\<^bsub>\\<Gamma> \\<ominus> f\\<^esub>\n           (TER\\<^bsub>\\<Gamma> \\<ominus> f\\<^esub> (\\<lambda>_. 0))\n\ngoal (1 subgoal):\n 1. False", "by contradiction"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x \\<notin> \\<E> (TER f)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  hindrance \\<Gamma> f\n\ngoal (1 subgoal):\n 1. hindrance (\\<Gamma> \\<ominus> f) (\\<lambda>_. 0) \\<Longrightarrow>\n    hindered \\<Gamma>", "thus \"hindered \\<Gamma>\""], ["proof (prove)\nusing this:\n  hindrance \\<Gamma> f\n\ngoal (1 subgoal):\n 1. hindered \\<Gamma>", "using f w"], ["proof (prove)\nusing this:\n  hindrance \\<Gamma> f\n  current \\<Gamma> f\n  wave \\<Gamma> f\n\ngoal (1 subgoal):\n 1. hindered \\<Gamma>", ".."], ["proof (state)\nthis:\n  hindered \\<Gamma>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> hindrance (\\<Gamma> \\<ominus> f) (\\<lambda>_. 0)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma weight_minus_web:\n  assumes f: \"current \\<Gamma> f\"\n  shows \"weight (\\<Gamma> \\<ominus> f) x = (if x \\<in> A \\<Gamma> then weight \\<Gamma> x - d_OUT f x else weight \\<Gamma> x - d_IN f x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. weight (\\<Gamma> \\<ominus> f) x =\n    (if x \\<in> A \\<Gamma> then weight \\<Gamma> x - d_OUT f x\n     else weight \\<Gamma> x - d_IN f x)", "proof(cases \"x \\<in> B \\<Gamma>\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<in> B \\<Gamma> \\<Longrightarrow>\n    weight (\\<Gamma> \\<ominus> f) x =\n    (if x \\<in> A \\<Gamma> then weight \\<Gamma> x - d_OUT f x\n     else weight \\<Gamma> x - d_IN f x)\n 2. x \\<notin> B \\<Gamma> \\<Longrightarrow>\n    weight (\\<Gamma> \\<ominus> f) x =\n    (if x \\<in> A \\<Gamma> then weight \\<Gamma> x - d_OUT f x\n     else weight \\<Gamma> x - d_IN f x)", "case True"], ["proof (state)\nthis:\n  x \\<in> B \\<Gamma>\n\ngoal (2 subgoals):\n 1. x \\<in> B \\<Gamma> \\<Longrightarrow>\n    weight (\\<Gamma> \\<ominus> f) x =\n    (if x \\<in> A \\<Gamma> then weight \\<Gamma> x - d_OUT f x\n     else weight \\<Gamma> x - d_IN f x)\n 2. x \\<notin> B \\<Gamma> \\<Longrightarrow>\n    weight (\\<Gamma> \\<ominus> f) x =\n    (if x \\<in> A \\<Gamma> then weight \\<Gamma> x - d_OUT f x\n     else weight \\<Gamma> x - d_IN f x)", "with currentD_OUT[OF f True] disjoint"], ["proof (chain)\npicking this:\n  d_OUT f x = 0\n  A \\<Gamma> \\<inter> B \\<Gamma> = {}\n  x \\<in> B \\<Gamma>", "show ?thesis"], ["proof (prove)\nusing this:\n  d_OUT f x = 0\n  A \\<Gamma> \\<inter> B \\<Gamma> = {}\n  x \\<in> B \\<Gamma>\n\ngoal (1 subgoal):\n 1. weight (\\<Gamma> \\<ominus> f) x =\n    (if x \\<in> A \\<Gamma> then weight \\<Gamma> x - d_OUT f x\n     else weight \\<Gamma> x - d_IN f x)", "by auto"], ["proof (state)\nthis:\n  weight (\\<Gamma> \\<ominus> f) x =\n  (if x \\<in> A \\<Gamma> then weight \\<Gamma> x - d_OUT f x\n   else weight \\<Gamma> x - d_IN f x)\n\ngoal (1 subgoal):\n 1. x \\<notin> B \\<Gamma> \\<Longrightarrow>\n    weight (\\<Gamma> \\<ominus> f) x =\n    (if x \\<in> A \\<Gamma> then weight \\<Gamma> x - d_OUT f x\n     else weight \\<Gamma> x - d_IN f x)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<notin> B \\<Gamma> \\<Longrightarrow>\n    weight (\\<Gamma> \\<ominus> f) x =\n    (if x \\<in> A \\<Gamma> then weight \\<Gamma> x - d_OUT f x\n     else weight \\<Gamma> x - d_IN f x)", "case False"], ["proof (state)\nthis:\n  x \\<notin> B \\<Gamma>\n\ngoal (1 subgoal):\n 1. x \\<notin> B \\<Gamma> \\<Longrightarrow>\n    weight (\\<Gamma> \\<ominus> f) x =\n    (if x \\<in> A \\<Gamma> then weight \\<Gamma> x - d_OUT f x\n     else weight \\<Gamma> x - d_IN f x)", "hence \"d_IN f x = 0\" \"d_OUT f x = 0\" if \"x \\<notin> A \\<Gamma>\""], ["proof (prove)\nusing this:\n  x \\<notin> B \\<Gamma>\n\ngoal (1 subgoal):\n 1. d_IN f x = 0 &&& d_OUT f x = 0", "using currentD_outside_OUT[OF f, of x] currentD_outside_IN[OF f, of x] bipartite_V that"], ["proof (prove)\nusing this:\n  x \\<notin> B \\<Gamma>\n  x \\<notin> \\<^bold>V \\<Longrightarrow> d_OUT f x = 0\n  x \\<notin> \\<^bold>V \\<Longrightarrow> d_IN f x = 0\n  \\<^bold>V \\<subseteq> A \\<Gamma> \\<union> B \\<Gamma>\n  x \\<notin> A \\<Gamma>\n\ngoal (1 subgoal):\n 1. d_IN f x = 0 &&& d_OUT f x = 0", "by auto"], ["proof (state)\nthis:\n  x \\<notin> A \\<Gamma> \\<Longrightarrow> d_IN f x = 0\n  x \\<notin> A \\<Gamma> \\<Longrightarrow> d_OUT f x = 0\n\ngoal (1 subgoal):\n 1. x \\<notin> B \\<Gamma> \\<Longrightarrow>\n    weight (\\<Gamma> \\<ominus> f) x =\n    (if x \\<in> A \\<Gamma> then weight \\<Gamma> x - d_OUT f x\n     else weight \\<Gamma> x - d_IN f x)", "then"], ["proof (chain)\npicking this:\n  x \\<notin> A \\<Gamma> \\<Longrightarrow> d_IN f x = 0\n  x \\<notin> A \\<Gamma> \\<Longrightarrow> d_OUT f x = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  x \\<notin> A \\<Gamma> \\<Longrightarrow> d_IN f x = 0\n  x \\<notin> A \\<Gamma> \\<Longrightarrow> d_OUT f x = 0\n\ngoal (1 subgoal):\n 1. weight (\\<Gamma> \\<ominus> f) x =\n    (if x \\<in> A \\<Gamma> then weight \\<Gamma> x - d_OUT f x\n     else weight \\<Gamma> x - d_IN f x)", "by simp"], ["proof (state)\nthis:\n  weight (\\<Gamma> \\<ominus> f) x =\n  (if x \\<in> A \\<Gamma> then weight \\<Gamma> x - d_OUT f x\n   else weight \\<Gamma> x - d_IN f x)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in -) separating_minus_web [simp]: \"separating_gen (G \\<ominus> f) = separating_gen G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. separating_gen (G \\<ominus> f) = separating_gen G", "by(simp add: separating_gen.simps fun_eq_iff)"], ["", "lemma current_minus:\n  assumes f: \"current \\<Gamma> f\"\n  and g: \"current \\<Gamma> g\"\n  and le: \"\\<And>e. g e \\<le> f e\"\n  shows \"current (\\<Gamma> \\<ominus> g) (f - g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. current (\\<Gamma> \\<ominus> g) (f - g)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. current (\\<Gamma> \\<ominus> g) (f - g)", "interpret \\<Gamma>: countable_bipartite_web \"\\<Gamma> \\<ominus> g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. countable_bipartite_web (\\<Gamma> \\<ominus> g)", "using g"], ["proof (prove)\nusing this:\n  current \\<Gamma> g\n\ngoal (1 subgoal):\n 1. countable_bipartite_web (\\<Gamma> \\<ominus> g)", "by(rule countable_bipartite_web_minus_web)"], ["proof (state)\ngoal (1 subgoal):\n 1. current (\\<Gamma> \\<ominus> g) (f - g)", "note [simp del] = minus_web_sel(2)\n    and [simp] = weight_minus_web[OF g]"], ["proof (state)\nthis:\n  weight (?\\<Gamma> \\<ominus> ?f) ?x =\n  (if ?x \\<in> A ?\\<Gamma> then weight ?\\<Gamma> ?x - d_OUT ?f ?x\n   else weight ?\\<Gamma> ?x + d_OUT ?f ?x - d_IN ?f ?x)\n  weight (\\<Gamma> \\<ominus> g) ?x =\n  (if ?x \\<in> A \\<Gamma> then weight \\<Gamma> ?x - d_OUT g ?x\n   else weight \\<Gamma> ?x - d_IN g ?x)\n\ngoal (1 subgoal):\n 1. current (\\<Gamma> \\<ominus> g) (f - g)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. current (\\<Gamma> \\<ominus> g) (f - g)", "proof"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x. d_OUT (f - g) x \\<le> weight (\\<Gamma> \\<ominus> g) x\n 2. \\<And>x. d_IN (f - g) x \\<le> weight (\\<Gamma> \\<ominus> g) x\n 3. \\<And>e.\n       e \\<notin> \\<^bold>E\\<^bsub>\\<Gamma> \\<ominus> g\\<^esub> \\<Longrightarrow>\n       (f - g) e = 0", "show \"d_OUT (f - g) x \\<le> weight (\\<Gamma> \\<ominus> g) x\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT (f - g) x \\<le> weight (\\<Gamma> \\<ominus> g) x", "unfolding fun_diff_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT (\\<lambda>x. f x - g x) x \\<le> weight (\\<Gamma> \\<ominus> g) x", "using currentD_weight_OUT[OF f, of x] currentD_weight_IN[OF g, of x]"], ["proof (prove)\nusing this:\n  d_OUT f x \\<le> weight \\<Gamma> x\n  d_IN g x \\<le> weight \\<Gamma> x\n\ngoal (1 subgoal):\n 1. d_OUT (\\<lambda>x. f x - g x) x \\<le> weight (\\<Gamma> \\<ominus> g) x", "by(subst d_OUT_diff)(simp_all add: le currentD_finite_OUT[OF g] currentD_OUT'[OF f] currentD_OUT'[OF g] ennreal_minus_mono)"], ["proof (state)\nthis:\n  d_OUT (f - g) ?x \\<le> weight (\\<Gamma> \\<ominus> g) ?x\n\ngoal (2 subgoals):\n 1. \\<And>x. d_IN (f - g) x \\<le> weight (\\<Gamma> \\<ominus> g) x\n 2. \\<And>e.\n       e \\<notin> \\<^bold>E\\<^bsub>\\<Gamma> \\<ominus> g\\<^esub> \\<Longrightarrow>\n       (f - g) e = 0", "show \"d_IN (f - g) x \\<le> weight (\\<Gamma> \\<ominus> g) x\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN (f - g) x \\<le> weight (\\<Gamma> \\<ominus> g) x", "unfolding fun_diff_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN (\\<lambda>x. f x - g x) x \\<le> weight (\\<Gamma> \\<ominus> g) x", "using currentD_weight_IN[OF f, of x] currentD_weight_OUT[OF g, of x]"], ["proof (prove)\nusing this:\n  d_IN f x \\<le> weight \\<Gamma> x\n  d_OUT g x \\<le> weight \\<Gamma> x\n\ngoal (1 subgoal):\n 1. d_IN (\\<lambda>x. f x - g x) x \\<le> weight (\\<Gamma> \\<ominus> g) x", "by(subst d_IN_diff)(simp_all add: le currentD_finite_IN[OF g] currentD_IN[OF f] currentD_IN[OF g] ennreal_minus_mono)"], ["proof (state)\nthis:\n  d_IN (f - g) ?x \\<le> weight (\\<Gamma> \\<ominus> g) ?x\n\ngoal (1 subgoal):\n 1. \\<And>e.\n       e \\<notin> \\<^bold>E\\<^bsub>\\<Gamma> \\<ominus> g\\<^esub> \\<Longrightarrow>\n       (f - g) e = 0", "show \"(f - g) e = 0\" if \"e \\<notin> \\<^bold>E\\<^bsub>\\<Gamma> \\<ominus> g\\<^esub>\" for e"], ["proof (prove)\ngoal (1 subgoal):\n 1. (f - g) e = 0", "using that currentD_outside'[OF f] currentD_outside'[OF g]"], ["proof (prove)\nusing this:\n  e \\<notin> \\<^bold>E\\<^bsub>\\<Gamma> \\<ominus> g\\<^esub>\n  ?e \\<notin> \\<^bold>E \\<Longrightarrow> f ?e = 0\n  ?e \\<notin> \\<^bold>E \\<Longrightarrow> g ?e = 0\n\ngoal (1 subgoal):\n 1. (f - g) e = 0", "by simp"], ["proof (state)\nthis:\n  ?e \\<notin> \\<^bold>E\\<^bsub>\\<Gamma> \\<ominus> g\\<^esub> \\<Longrightarrow>\n  (f - g) ?e = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  current (\\<Gamma> \\<ominus> g) (f - g)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma\n  assumes w: \"wave \\<Gamma> f\"\n  and g: \"current \\<Gamma> g\"\n  and le: \"\\<And>e. g e \\<le> f e\"\n  shows wave_minus: \"wave (\\<Gamma> \\<ominus> g) (f - g)\"\n  and TER_minus: \"TER f \\<subseteq> TER\\<^bsub>\\<Gamma> \\<ominus> g\\<^esub> (f - g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wave (\\<Gamma> \\<ominus> g) (f - g) &&&\n    TER f \\<subseteq> TER\\<^bsub>\\<Gamma> \\<ominus> g\\<^esub> (f - g)", "proof"], ["proof (state)\ngoal (3 subgoals):\n 1. separating (\\<Gamma> \\<ominus> g)\n     (TER\\<^bsub>\\<Gamma> \\<ominus> g\\<^esub> (f - g))\n 2. \\<And>x.\n       x \\<notin> RF\\<^bsub>\\<Gamma> \\<ominus> g\\<^esub>\n                   (TER\\<^bsub>\\<Gamma> \\<ominus> g\\<^esub>\n                     (f - g)) \\<Longrightarrow>\n       d_OUT (f - g) x = 0\n 3. TER f \\<subseteq> TER\\<^bsub>\\<Gamma> \\<ominus> g\\<^esub> (f - g)", "have \"x \\<in> SINK f \\<Longrightarrow> x \\<in> SINK (f - g)\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> SINK f \\<Longrightarrow> x \\<in> SINK (f - g)", "using d_OUT_mono[of g _ f, OF le, of x]"], ["proof (prove)\nusing this:\n  d_OUT g x \\<le> d_OUT f x\n\ngoal (1 subgoal):\n 1. x \\<in> SINK f \\<Longrightarrow> x \\<in> SINK (f - g)", "by(auto simp add: SINK.simps fun_diff_def d_OUT_diff le currentD_finite_OUT[OF g])"], ["proof (state)\nthis:\n  ?x \\<in> SINK f \\<Longrightarrow> ?x \\<in> SINK (f - g)\n\ngoal (3 subgoals):\n 1. separating (\\<Gamma> \\<ominus> g)\n     (TER\\<^bsub>\\<Gamma> \\<ominus> g\\<^esub> (f - g))\n 2. \\<And>x.\n       x \\<notin> RF\\<^bsub>\\<Gamma> \\<ominus> g\\<^esub>\n                   (TER\\<^bsub>\\<Gamma> \\<ominus> g\\<^esub>\n                     (f - g)) \\<Longrightarrow>\n       d_OUT (f - g) x = 0\n 3. TER f \\<subseteq> TER\\<^bsub>\\<Gamma> \\<ominus> g\\<^esub> (f - g)", "moreover"], ["proof (state)\nthis:\n  ?x \\<in> SINK f \\<Longrightarrow> ?x \\<in> SINK (f - g)\n\ngoal (3 subgoals):\n 1. separating (\\<Gamma> \\<ominus> g)\n     (TER\\<^bsub>\\<Gamma> \\<ominus> g\\<^esub> (f - g))\n 2. \\<And>x.\n       x \\<notin> RF\\<^bsub>\\<Gamma> \\<ominus> g\\<^esub>\n                   (TER\\<^bsub>\\<Gamma> \\<ominus> g\\<^esub>\n                     (f - g)) \\<Longrightarrow>\n       d_OUT (f - g) x = 0\n 3. TER f \\<subseteq> TER\\<^bsub>\\<Gamma> \\<ominus> g\\<^esub> (f - g)", "have \"x \\<in> SAT \\<Gamma> f \\<Longrightarrow> x \\<in> SAT (\\<Gamma> \\<ominus> g) (f - g)\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> SAT \\<Gamma> f \\<Longrightarrow>\n    x \\<in> SAT (\\<Gamma> \\<ominus> g) (f - g)", "by(auto simp add: SAT.simps currentD_OUT'[OF g] fun_diff_def d_IN_diff le currentD_finite_IN[OF g] ennreal_minus_mono)"], ["proof (state)\nthis:\n  ?x \\<in> SAT \\<Gamma> f \\<Longrightarrow>\n  ?x \\<in> SAT (\\<Gamma> \\<ominus> g) (f - g)\n\ngoal (3 subgoals):\n 1. separating (\\<Gamma> \\<ominus> g)\n     (TER\\<^bsub>\\<Gamma> \\<ominus> g\\<^esub> (f - g))\n 2. \\<And>x.\n       x \\<notin> RF\\<^bsub>\\<Gamma> \\<ominus> g\\<^esub>\n                   (TER\\<^bsub>\\<Gamma> \\<ominus> g\\<^esub>\n                     (f - g)) \\<Longrightarrow>\n       d_OUT (f - g) x = 0\n 3. TER f \\<subseteq> TER\\<^bsub>\\<Gamma> \\<ominus> g\\<^esub> (f - g)", "ultimately"], ["proof (chain)\npicking this:\n  ?x \\<in> SINK f \\<Longrightarrow> ?x \\<in> SINK (f - g)\n  ?x \\<in> SAT \\<Gamma> f \\<Longrightarrow>\n  ?x \\<in> SAT (\\<Gamma> \\<ominus> g) (f - g)", "show TER: \"TER f \\<subseteq> TER\\<^bsub>\\<Gamma> \\<ominus> g\\<^esub> (f - g)\""], ["proof (prove)\nusing this:\n  ?x \\<in> SINK f \\<Longrightarrow> ?x \\<in> SINK (f - g)\n  ?x \\<in> SAT \\<Gamma> f \\<Longrightarrow>\n  ?x \\<in> SAT (\\<Gamma> \\<ominus> g) (f - g)\n\ngoal (1 subgoal):\n 1. TER f \\<subseteq> TER\\<^bsub>\\<Gamma> \\<ominus> g\\<^esub> (f - g)", "by(auto)"], ["proof (state)\nthis:\n  TER f \\<subseteq> TER\\<^bsub>\\<Gamma> \\<ominus> g\\<^esub> (f - g)\n\ngoal (2 subgoals):\n 1. separating (\\<Gamma> \\<ominus> g)\n     (TER\\<^bsub>\\<Gamma> \\<ominus> g\\<^esub> (f - g))\n 2. \\<And>x.\n       x \\<notin> RF\\<^bsub>\\<Gamma> \\<ominus> g\\<^esub>\n                   (TER\\<^bsub>\\<Gamma> \\<ominus> g\\<^esub>\n                     (f - g)) \\<Longrightarrow>\n       d_OUT (f - g) x = 0", "from w"], ["proof (chain)\npicking this:\n  wave \\<Gamma> f", "have \"separating \\<Gamma> (TER f)\""], ["proof (prove)\nusing this:\n  wave \\<Gamma> f\n\ngoal (1 subgoal):\n 1. separating \\<Gamma> (TER f)", "by(rule waveD_separating)"], ["proof (state)\nthis:\n  separating \\<Gamma> (TER f)\n\ngoal (2 subgoals):\n 1. separating (\\<Gamma> \\<ominus> g)\n     (TER\\<^bsub>\\<Gamma> \\<ominus> g\\<^esub> (f - g))\n 2. \\<And>x.\n       x \\<notin> RF\\<^bsub>\\<Gamma> \\<ominus> g\\<^esub>\n                   (TER\\<^bsub>\\<Gamma> \\<ominus> g\\<^esub>\n                     (f - g)) \\<Longrightarrow>\n       d_OUT (f - g) x = 0", "thus \"separating (\\<Gamma> \\<ominus> g) (TER\\<^bsub>\\<Gamma> \\<ominus> g\\<^esub> (f - g))\""], ["proof (prove)\nusing this:\n  separating \\<Gamma> (TER f)\n\ngoal (1 subgoal):\n 1. separating (\\<Gamma> \\<ominus> g)\n     (TER\\<^bsub>\\<Gamma> \\<ominus> g\\<^esub> (f - g))", "using TER"], ["proof (prove)\nusing this:\n  separating \\<Gamma> (TER f)\n  TER f \\<subseteq> TER\\<^bsub>\\<Gamma> \\<ominus> g\\<^esub> (f - g)\n\ngoal (1 subgoal):\n 1. separating (\\<Gamma> \\<ominus> g)\n     (TER\\<^bsub>\\<Gamma> \\<ominus> g\\<^esub> (f - g))", "by(simp add: separating_weakening)"], ["proof (state)\nthis:\n  separating (\\<Gamma> \\<ominus> g)\n   (TER\\<^bsub>\\<Gamma> \\<ominus> g\\<^esub> (f - g))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<notin> RF\\<^bsub>\\<Gamma> \\<ominus> g\\<^esub>\n                   (TER\\<^bsub>\\<Gamma> \\<ominus> g\\<^esub>\n                     (f - g)) \\<Longrightarrow>\n       d_OUT (f - g) x = 0", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<notin> RF\\<^bsub>\\<Gamma> \\<ominus> g\\<^esub>\n                   (TER\\<^bsub>\\<Gamma> \\<ominus> g\\<^esub>\n                     (f - g)) \\<Longrightarrow>\n       d_OUT (f - g) x = 0", "assume \"x \\<notin> RF\\<^bsub>\\<Gamma> \\<ominus> g\\<^esub> (TER\\<^bsub>\\<Gamma> \\<ominus> g\\<^esub> (f - g))\""], ["proof (state)\nthis:\n  x \\<notin> RF\\<^bsub>\\<Gamma> \\<ominus> g\\<^esub>\n              (TER\\<^bsub>\\<Gamma> \\<ominus> g\\<^esub> (f - g))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<notin> RF\\<^bsub>\\<Gamma> \\<ominus> g\\<^esub>\n                   (TER\\<^bsub>\\<Gamma> \\<ominus> g\\<^esub>\n                     (f - g)) \\<Longrightarrow>\n       d_OUT (f - g) x = 0", "hence \"x \\<notin> RF (TER f)\""], ["proof (prove)\nusing this:\n  x \\<notin> RF\\<^bsub>\\<Gamma> \\<ominus> g\\<^esub>\n              (TER\\<^bsub>\\<Gamma> \\<ominus> g\\<^esub> (f - g))\n\ngoal (1 subgoal):\n 1. x \\<notin> RF (TER f)", "using TER"], ["proof (prove)\nusing this:\n  x \\<notin> RF\\<^bsub>\\<Gamma> \\<ominus> g\\<^esub>\n              (TER\\<^bsub>\\<Gamma> \\<ominus> g\\<^esub> (f - g))\n  TER f \\<subseteq> TER\\<^bsub>\\<Gamma> \\<ominus> g\\<^esub> (f - g)\n\ngoal (1 subgoal):\n 1. x \\<notin> RF (TER f)", "by(auto intro: in_roofed_mono)"], ["proof (state)\nthis:\n  x \\<notin> RF (TER f)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<notin> RF\\<^bsub>\\<Gamma> \\<ominus> g\\<^esub>\n                   (TER\\<^bsub>\\<Gamma> \\<ominus> g\\<^esub>\n                     (f - g)) \\<Longrightarrow>\n       d_OUT (f - g) x = 0", "hence \"d_OUT f x = 0\""], ["proof (prove)\nusing this:\n  x \\<notin> RF (TER f)\n\ngoal (1 subgoal):\n 1. d_OUT f x = 0", "by(rule waveD_OUT[OF w])"], ["proof (state)\nthis:\n  d_OUT f x = 0\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<notin> RF\\<^bsub>\\<Gamma> \\<ominus> g\\<^esub>\n                   (TER\\<^bsub>\\<Gamma> \\<ominus> g\\<^esub>\n                     (f - g)) \\<Longrightarrow>\n       d_OUT (f - g) x = 0", "moreover"], ["proof (state)\nthis:\n  d_OUT f x = 0\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<notin> RF\\<^bsub>\\<Gamma> \\<ominus> g\\<^esub>\n                   (TER\\<^bsub>\\<Gamma> \\<ominus> g\\<^esub>\n                     (f - g)) \\<Longrightarrow>\n       d_OUT (f - g) x = 0", "have \"0 \\<le> f e\" for e"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> f e", "using le[of e]"], ["proof (prove)\nusing this:\n  g e \\<le> f e\n\ngoal (1 subgoal):\n 1. 0 \\<le> f e", "by simp"], ["proof (state)\nthis:\n  0 \\<le> f ?e\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<notin> RF\\<^bsub>\\<Gamma> \\<ominus> g\\<^esub>\n                   (TER\\<^bsub>\\<Gamma> \\<ominus> g\\<^esub>\n                     (f - g)) \\<Longrightarrow>\n       d_OUT (f - g) x = 0", "ultimately"], ["proof (chain)\npicking this:\n  d_OUT f x = 0\n  0 \\<le> f ?e", "show \"d_OUT (f - g) x = 0\""], ["proof (prove)\nusing this:\n  d_OUT f x = 0\n  0 \\<le> f ?e\n\ngoal (1 subgoal):\n 1. d_OUT (f - g) x = 0", "unfolding d_OUT_def"], ["proof (prove)\nusing this:\n  (\\<Sum>\\<^sup>+ y. f (x, y)) = 0\n  0 \\<le> f ?e\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y. (f - g) (x, y)) = 0", "by(simp add: nn_integral_0_iff emeasure_count_space_eq_0)"], ["proof (state)\nthis:\n  d_OUT (f - g) x = 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in -) essential_minus_web [simp]: \"essential (\\<Gamma> \\<ominus> f) = essential \\<Gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. essential (\\<Gamma> \\<ominus> f) = essential \\<Gamma>", "by(simp add: essential_def fun_eq_iff)"], ["", "lemma (in -) RF_in_essential: fixes B shows \"essential \\<Gamma> B S x \\<Longrightarrow> x \\<in> roofed_gen \\<Gamma> B S \\<longleftrightarrow> x \\<in> S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. essential \\<Gamma> B S x \\<Longrightarrow>\n    (x \\<in> roofed_gen \\<Gamma> B S) = (x \\<in> S)", "by(auto intro: roofed_greaterI elim!: essentialE_RF dest: roofedD)"], ["", "lemma (in -) d_OUT_fun_upd:\n  assumes \"f (x, y) \\<noteq> \\<top>\" \"f (x, y) \\<ge> 0\" \"k \\<noteq> \\<top>\" \"k \\<ge> 0\"\n  shows \"d_OUT (f((x, y) := k)) x' = (if x = x' then d_OUT f x - f (x, y) + k else d_OUT f x')\"\n  (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT (f((x, y) := k)) x' =\n    (if x = x' then d_OUT f x - f (x, y) + k else d_OUT f x')", "proof(cases \"x = x'\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x = x' \\<Longrightarrow>\n    d_OUT (f((x, y) := k)) x' =\n    (if x = x' then d_OUT f x - f (x, y) + k else d_OUT f x')\n 2. x \\<noteq> x' \\<Longrightarrow>\n    d_OUT (f((x, y) := k)) x' =\n    (if x = x' then d_OUT f x - f (x, y) + k else d_OUT f x')", "case True"], ["proof (state)\nthis:\n  x = x'\n\ngoal (2 subgoals):\n 1. x = x' \\<Longrightarrow>\n    d_OUT (f((x, y) := k)) x' =\n    (if x = x' then d_OUT f x - f (x, y) + k else d_OUT f x')\n 2. x \\<noteq> x' \\<Longrightarrow>\n    d_OUT (f((x, y) := k)) x' =\n    (if x = x' then d_OUT f x - f (x, y) + k else d_OUT f x')", "have \"?lhs = (\\<Sum>\\<^sup>+ y'. f (x, y') + k * indicator {y} y') - (\\<Sum>\\<^sup>+ y'. f (x, y') * indicator {y} y')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT (f((x, y) := k)) x' =\n    (\\<Sum>\\<^sup>+ y'. f (x, y') + k * indicator {y} y') -\n    (\\<integral>\\<^sup>+y'\\<in>{y}. f (x, y')\\<partial>count_space UNIV)", "unfolding d_OUT_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ ya. (f((x, y) := k)) (x', ya)) =\n    (\\<Sum>\\<^sup>+ y'. f (x, y') + k * indicator {y} y') -\n    (\\<integral>\\<^sup>+y'\\<in>{y}. f (x, y')\\<partial>count_space UNIV)", "using assms True"], ["proof (prove)\nusing this:\n  f (x, y) \\<noteq> \\<top>\n  0 \\<le> f (x, y)\n  k \\<noteq> \\<top>\n  0 \\<le> k\n  x = x'\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ ya. (f((x, y) := k)) (x', ya)) =\n    (\\<Sum>\\<^sup>+ y'. f (x, y') + k * indicator {y} y') -\n    (\\<integral>\\<^sup>+y'\\<in>{y}. f (x, y')\\<partial>count_space UNIV)", "by(subst nn_integral_diff[symmetric])\n      (auto intro!: nn_integral_cong simp add: AE_count_space split: split_indicator)"], ["proof (state)\nthis:\n  d_OUT (f((x, y) := k)) x' =\n  (\\<Sum>\\<^sup>+ y'. f (x, y') + k * indicator {y} y') -\n  (\\<integral>\\<^sup>+y'\\<in>{y}. f (x, y')\\<partial>count_space UNIV)\n\ngoal (2 subgoals):\n 1. x = x' \\<Longrightarrow>\n    d_OUT (f((x, y) := k)) x' =\n    (if x = x' then d_OUT f x - f (x, y) + k else d_OUT f x')\n 2. x \\<noteq> x' \\<Longrightarrow>\n    d_OUT (f((x, y) := k)) x' =\n    (if x = x' then d_OUT f x - f (x, y) + k else d_OUT f x')", "also"], ["proof (state)\nthis:\n  d_OUT (f((x, y) := k)) x' =\n  (\\<Sum>\\<^sup>+ y'. f (x, y') + k * indicator {y} y') -\n  (\\<integral>\\<^sup>+y'\\<in>{y}. f (x, y')\\<partial>count_space UNIV)\n\ngoal (2 subgoals):\n 1. x = x' \\<Longrightarrow>\n    d_OUT (f((x, y) := k)) x' =\n    (if x = x' then d_OUT f x - f (x, y) + k else d_OUT f x')\n 2. x \\<noteq> x' \\<Longrightarrow>\n    d_OUT (f((x, y) := k)) x' =\n    (if x = x' then d_OUT f x - f (x, y) + k else d_OUT f x')", "have \"(\\<Sum>\\<^sup>+ y'. f (x, y') + k * indicator {y} y') = d_OUT f x + (\\<Sum>\\<^sup>+ y'. k * indicator {y} y')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y'. f (x, y') + k * indicator {y} y') =\n    d_OUT f x + (\\<integral>\\<^sup>+y'\\<in>{y}. k\\<partial>count_space UNIV)", "unfolding d_OUT_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y'. f (x, y') + k * indicator {y} y') =\n    (\\<Sum>\\<^sup>+ y. f (x, y)) +\n    (\\<integral>\\<^sup>+y'\\<in>{y}. k\\<partial>count_space UNIV)", "using assms"], ["proof (prove)\nusing this:\n  f (x, y) \\<noteq> \\<top>\n  0 \\<le> f (x, y)\n  k \\<noteq> \\<top>\n  0 \\<le> k\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y'. f (x, y') + k * indicator {y} y') =\n    (\\<Sum>\\<^sup>+ y. f (x, y)) +\n    (\\<integral>\\<^sup>+y'\\<in>{y}. k\\<partial>count_space UNIV)", "by(subst nn_integral_add[symmetric])\n      (auto intro!: nn_integral_cong split: split_indicator)"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y'. f (x, y') + k * indicator {y} y') =\n  d_OUT f x + (\\<integral>\\<^sup>+y'\\<in>{y}. k\\<partial>count_space UNIV)\n\ngoal (2 subgoals):\n 1. x = x' \\<Longrightarrow>\n    d_OUT (f((x, y) := k)) x' =\n    (if x = x' then d_OUT f x - f (x, y) + k else d_OUT f x')\n 2. x \\<noteq> x' \\<Longrightarrow>\n    d_OUT (f((x, y) := k)) x' =\n    (if x = x' then d_OUT f x - f (x, y) + k else d_OUT f x')", "also"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y'. f (x, y') + k * indicator {y} y') =\n  d_OUT f x + (\\<integral>\\<^sup>+y'\\<in>{y}. k\\<partial>count_space UNIV)\n\ngoal (2 subgoals):\n 1. x = x' \\<Longrightarrow>\n    d_OUT (f((x, y) := k)) x' =\n    (if x = x' then d_OUT f x - f (x, y) + k else d_OUT f x')\n 2. x \\<noteq> x' \\<Longrightarrow>\n    d_OUT (f((x, y) := k)) x' =\n    (if x = x' then d_OUT f x - f (x, y) + k else d_OUT f x')", "have \"\\<dots> - (\\<Sum>\\<^sup>+ y'. f (x, y') * indicator {y} y') = ?rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT f x +\n    (\\<integral>\\<^sup>+y'\\<in>{y}. k\\<partial>count_space UNIV) -\n    (\\<integral>\\<^sup>+y'\\<in>{y}. f (x, y')\\<partial>count_space UNIV) =\n    (if x = x' then d_OUT f x - f (x, y) + k else d_OUT f x')", "using True assms"], ["proof (prove)\nusing this:\n  x = x'\n  f (x, y) \\<noteq> \\<top>\n  0 \\<le> f (x, y)\n  k \\<noteq> \\<top>\n  0 \\<le> k\n\ngoal (1 subgoal):\n 1. d_OUT f x +\n    (\\<integral>\\<^sup>+y'\\<in>{y}. k\\<partial>count_space UNIV) -\n    (\\<integral>\\<^sup>+y'\\<in>{y}. f (x, y')\\<partial>count_space UNIV) =\n    (if x = x' then d_OUT f x - f (x, y) + k else d_OUT f x')", "by(subst diff_add_assoc2_ennreal[symmetric])(auto simp add: d_OUT_def intro!: nn_integral_ge_point)"], ["proof (state)\nthis:\n  d_OUT f x + (\\<integral>\\<^sup>+y'\\<in>{y}. k\\<partial>count_space UNIV) -\n  (\\<integral>\\<^sup>+y'\\<in>{y}. f (x, y')\\<partial>count_space UNIV) =\n  (if x = x' then d_OUT f x - f (x, y) + k else d_OUT f x')\n\ngoal (2 subgoals):\n 1. x = x' \\<Longrightarrow>\n    d_OUT (f((x, y) := k)) x' =\n    (if x = x' then d_OUT f x - f (x, y) + k else d_OUT f x')\n 2. x \\<noteq> x' \\<Longrightarrow>\n    d_OUT (f((x, y) := k)) x' =\n    (if x = x' then d_OUT f x - f (x, y) + k else d_OUT f x')", "finally"], ["proof (chain)\npicking this:\n  d_OUT (f((x, y) := k)) x' =\n  (if x = x' then d_OUT f x - f (x, y) + k else d_OUT f x')", "show ?thesis"], ["proof (prove)\nusing this:\n  d_OUT (f((x, y) := k)) x' =\n  (if x = x' then d_OUT f x - f (x, y) + k else d_OUT f x')\n\ngoal (1 subgoal):\n 1. d_OUT (f((x, y) := k)) x' =\n    (if x = x' then d_OUT f x - f (x, y) + k else d_OUT f x')", "."], ["proof (state)\nthis:\n  d_OUT (f((x, y) := k)) x' =\n  (if x = x' then d_OUT f x - f (x, y) + k else d_OUT f x')\n\ngoal (1 subgoal):\n 1. x \\<noteq> x' \\<Longrightarrow>\n    d_OUT (f((x, y) := k)) x' =\n    (if x = x' then d_OUT f x - f (x, y) + k else d_OUT f x')", "qed(simp add: d_OUT_def)"], ["", "lemma unhindered_saturate1: \\<comment> \\<open>Lemma 6.10\\<close>\n  assumes unhindered: \"\\<not> hindered \\<Gamma>\"\n  and a: \"a \\<in> A \\<Gamma>\"\n  shows \"\\<exists>f. current \\<Gamma> f \\<and> d_OUT f a = weight \\<Gamma> a \\<and> \\<not> hindered (\\<Gamma> \\<ominus> f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>f.\n       current \\<Gamma> f \\<and>\n       d_OUT f a = weight \\<Gamma> a \\<and>\n       \\<not> hindered (\\<Gamma> \\<ominus> f)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>f.\n       current \\<Gamma> f \\<and>\n       d_OUT f a = weight \\<Gamma> a \\<and>\n       \\<not> hindered (\\<Gamma> \\<ominus> f)", "from a A_vertex"], ["proof (chain)\npicking this:\n  a \\<in> A \\<Gamma>\n  A \\<Gamma> \\<subseteq> \\<^bold>V", "have a_vertex: \"vertex \\<Gamma> a\""], ["proof (prove)\nusing this:\n  a \\<in> A \\<Gamma>\n  A \\<Gamma> \\<subseteq> \\<^bold>V\n\ngoal (1 subgoal):\n 1. vertex \\<Gamma> a", "by auto"], ["proof (state)\nthis:\n  vertex \\<Gamma> a\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       current \\<Gamma> f \\<and>\n       d_OUT f a = weight \\<Gamma> a \\<and>\n       \\<not> hindered (\\<Gamma> \\<ominus> f)", "from unhindered"], ["proof (chain)\npicking this:\n  \\<not> hindered \\<Gamma>", "have \"\\<not> hindrance \\<Gamma> zero_current\""], ["proof (prove)\nusing this:\n  \\<not> hindered \\<Gamma>\n\ngoal (1 subgoal):\n 1. \\<not> hindrance \\<Gamma> (\\<lambda>_. 0)", "by(auto intro!: hindered.intros simp add: )"], ["proof (state)\nthis:\n  \\<not> hindrance \\<Gamma> (\\<lambda>_. 0)\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       current \\<Gamma> f \\<and>\n       d_OUT f a = weight \\<Gamma> a \\<and>\n       \\<not> hindered (\\<Gamma> \\<ominus> f)", "then"], ["proof (chain)\npicking this:\n  \\<not> hindrance \\<Gamma> (\\<lambda>_. 0)", "have a_\\<E>: \"a \\<in> \\<E> (A \\<Gamma>)\" if \"weight \\<Gamma> a > 0\""], ["proof (prove)\nusing this:\n  \\<not> hindrance \\<Gamma> (\\<lambda>_. 0)\n\ngoal (1 subgoal):\n 1. a \\<in> \\<E> (A \\<Gamma>)", "proof(rule contrapos_np)"], ["proof (state)\ngoal (1 subgoal):\n 1. a \\<notin> \\<E> (A \\<Gamma>) \\<Longrightarrow>\n    hindrance \\<Gamma> (\\<lambda>_. 0)", "assume \"a \\<notin> \\<E> (A \\<Gamma>)\""], ["proof (state)\nthis:\n  a \\<notin> \\<E> (A \\<Gamma>)\n\ngoal (1 subgoal):\n 1. a \\<notin> \\<E> (A \\<Gamma>) \\<Longrightarrow>\n    hindrance \\<Gamma> (\\<lambda>_. 0)", "with a"], ["proof (chain)\npicking this:\n  a \\<in> A \\<Gamma>\n  a \\<notin> \\<E> (A \\<Gamma>)", "have \"\\<not> essential \\<Gamma> (B \\<Gamma>) (A \\<Gamma>) a\""], ["proof (prove)\nusing this:\n  a \\<in> A \\<Gamma>\n  a \\<notin> \\<E> (A \\<Gamma>)\n\ngoal (1 subgoal):\n 1. \\<not> essential \\<Gamma> (B \\<Gamma>) (A \\<Gamma>) a", "by simp"], ["proof (state)\nthis:\n  \\<not> essential \\<Gamma> (B \\<Gamma>) (A \\<Gamma>) a\n\ngoal (1 subgoal):\n 1. a \\<notin> \\<E> (A \\<Gamma>) \\<Longrightarrow>\n    hindrance \\<Gamma> (\\<lambda>_. 0)", "hence \"\\<not> essential \\<Gamma> (B \\<Gamma>) (A \\<Gamma> \\<union> {x. weight \\<Gamma> x \\<le> 0}) a\""], ["proof (prove)\nusing this:\n  \\<not> essential \\<Gamma> (B \\<Gamma>) (A \\<Gamma>) a\n\ngoal (1 subgoal):\n 1. \\<not> essential \\<Gamma> (B \\<Gamma>)\n            (A \\<Gamma> \\<union> {x. weight \\<Gamma> x \\<le> 0}) a", "by(rule contrapos_nn)(erule essential_mono; simp)"], ["proof (state)\nthis:\n  \\<not> essential \\<Gamma> (B \\<Gamma>)\n          (A \\<Gamma> \\<union> {x. weight \\<Gamma> x \\<le> 0}) a\n\ngoal (1 subgoal):\n 1. a \\<notin> \\<E> (A \\<Gamma>) \\<Longrightarrow>\n    hindrance \\<Gamma> (\\<lambda>_. 0)", "with a that"], ["proof (chain)\npicking this:\n  a \\<in> A \\<Gamma>\n  0 < weight \\<Gamma> a\n  \\<not> essential \\<Gamma> (B \\<Gamma>)\n          (A \\<Gamma> \\<union> {x. weight \\<Gamma> x \\<le> 0}) a", "show \"hindrance \\<Gamma> zero_current\""], ["proof (prove)\nusing this:\n  a \\<in> A \\<Gamma>\n  0 < weight \\<Gamma> a\n  \\<not> essential \\<Gamma> (B \\<Gamma>)\n          (A \\<Gamma> \\<union> {x. weight \\<Gamma> x \\<le> 0}) a\n\ngoal (1 subgoal):\n 1. hindrance \\<Gamma> (\\<lambda>_. 0)", "by(auto intro: hindrance)"], ["proof (state)\nthis:\n  hindrance \\<Gamma> (\\<lambda>_. 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  0 < weight \\<Gamma> a \\<Longrightarrow> a \\<in> \\<E> (A \\<Gamma>)\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       current \\<Gamma> f \\<and>\n       d_OUT f a = weight \\<Gamma> a \\<and>\n       \\<not> hindered (\\<Gamma> \\<ominus> f)", "define F where \"F = (\\<lambda>(\\<epsilon>, h :: 'v current). plus_current \\<epsilon> h)\""], ["proof (state)\nthis:\n  F = (\\<lambda>(\\<epsilon>, h). plus_current \\<epsilon> h)\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       current \\<Gamma> f \\<and>\n       d_OUT f a = weight \\<Gamma> a \\<and>\n       \\<not> hindered (\\<Gamma> \\<ominus> f)", "have F_simps: \"F (\\<epsilon>, h) = plus_current \\<epsilon> h\" for \\<epsilon> h"], ["proof (prove)\ngoal (1 subgoal):\n 1. F (\\<epsilon>, h) = plus_current \\<epsilon> h", "by(simp add: F_def)"], ["proof (state)\nthis:\n  F (?\\<epsilon>, ?h) = plus_current ?\\<epsilon> ?h\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       current \\<Gamma> f \\<and>\n       d_OUT f a = weight \\<Gamma> a \\<and>\n       \\<not> hindered (\\<Gamma> \\<ominus> f)", "define Fld where \"Fld = {(\\<epsilon>, h).\n     current \\<Gamma> \\<epsilon> \\<and> (\\<forall>x. x \\<noteq> a \\<longrightarrow> d_OUT \\<epsilon> x = 0) \\<and>\n     current (\\<Gamma> \\<ominus> \\<epsilon>) h \\<and> wave (\\<Gamma> \\<ominus> \\<epsilon>) h \\<and>\n     \\<not> hindered (\\<Gamma> \\<ominus> F (\\<epsilon>, h))}\""], ["proof (state)\nthis:\n  Fld =\n  {(\\<epsilon>, h).\n   current \\<Gamma> \\<epsilon> \\<and>\n   (\\<forall>x.\n       x \\<noteq> a \\<longrightarrow> d_OUT \\<epsilon> x = 0) \\<and>\n   current (\\<Gamma> \\<ominus> \\<epsilon>) h \\<and>\n   wave (\\<Gamma> \\<ominus> \\<epsilon>) h \\<and>\n   \\<not> hindered (\\<Gamma> \\<ominus> F (\\<epsilon>, h))}\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       current \\<Gamma> f \\<and>\n       d_OUT f a = weight \\<Gamma> a \\<and>\n       \\<not> hindered (\\<Gamma> \\<ominus> f)", "define leq where \"leq = restrict_rel Fld {(f, f'). f \\<le> f'}\""], ["proof (state)\nthis:\n  leq = restrict_rel Fld {(f, f'). f \\<le> f'}\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       current \\<Gamma> f \\<and>\n       d_OUT f a = weight \\<Gamma> a \\<and>\n       \\<not> hindered (\\<Gamma> \\<ominus> f)", "have Fld: \"Field leq = Fld\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Field leq = Fld", "by(auto simp add: leq_def)"], ["proof (state)\nthis:\n  Field leq = Fld\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       current \\<Gamma> f \\<and>\n       d_OUT f a = weight \\<Gamma> a \\<and>\n       \\<not> hindered (\\<Gamma> \\<ominus> f)", "have F_I [intro?]: \"(\\<epsilon>, h) \\<in> Field leq\"\n    if \"current \\<Gamma> \\<epsilon>\" and \"\\<And>x. x \\<noteq> a \\<Longrightarrow> d_OUT \\<epsilon> x = 0\"\n    and \"current (\\<Gamma> \\<ominus> \\<epsilon>) h\" and \"wave (\\<Gamma> \\<ominus> \\<epsilon>) h\"\n    and \"\\<not> hindered (\\<Gamma> \\<ominus> F (\\<epsilon>, h))\"\n    for \\<epsilon> h"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<epsilon>, h) \\<in> Field leq", "using that"], ["proof (prove)\nusing this:\n  current \\<Gamma> \\<epsilon>\n  ?x \\<noteq> a \\<Longrightarrow> d_OUT \\<epsilon> ?x = 0\n  current (\\<Gamma> \\<ominus> \\<epsilon>) h\n  wave (\\<Gamma> \\<ominus> \\<epsilon>) h\n  \\<not> hindered (\\<Gamma> \\<ominus> F (\\<epsilon>, h))\n\ngoal (1 subgoal):\n 1. (\\<epsilon>, h) \\<in> Field leq", "by(simp add: Fld Fld_def)"], ["proof (state)\nthis:\n  \\<lbrakk>current \\<Gamma> ?\\<epsilon>;\n   \\<And>x. x \\<noteq> a \\<Longrightarrow> d_OUT ?\\<epsilon> x = 0;\n   current (\\<Gamma> \\<ominus> ?\\<epsilon>) ?h;\n   wave (\\<Gamma> \\<ominus> ?\\<epsilon>) ?h;\n   \\<not> hindered (\\<Gamma> \\<ominus> F (?\\<epsilon>, ?h))\\<rbrakk>\n  \\<Longrightarrow> (?\\<epsilon>, ?h) \\<in> Field leq\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       current \\<Gamma> f \\<and>\n       d_OUT f a = weight \\<Gamma> a \\<and>\n       \\<not> hindered (\\<Gamma> \\<ominus> f)", "have \\<epsilon>_curr: \"current \\<Gamma> \\<epsilon>\" if \"(\\<epsilon>, h) \\<in> Field leq\" for \\<epsilon> h"], ["proof (prove)\ngoal (1 subgoal):\n 1. current \\<Gamma> \\<epsilon>", "using that"], ["proof (prove)\nusing this:\n  (\\<epsilon>, h) \\<in> Field leq\n\ngoal (1 subgoal):\n 1. current \\<Gamma> \\<epsilon>", "by(simp add: Fld Fld_def)"], ["proof (state)\nthis:\n  (?\\<epsilon>, ?h) \\<in> Field leq \\<Longrightarrow>\n  current \\<Gamma> ?\\<epsilon>\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       current \\<Gamma> f \\<and>\n       d_OUT f a = weight \\<Gamma> a \\<and>\n       \\<not> hindered (\\<Gamma> \\<ominus> f)", "have OUT_\\<epsilon>: \"\\<And>x. x \\<noteq> a \\<Longrightarrow> d_OUT \\<epsilon> x = 0\" if \"(\\<epsilon>, h) \\<in> Field leq\" for \\<epsilon> h"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<noteq> a \\<Longrightarrow> d_OUT \\<epsilon> x = 0", "using that"], ["proof (prove)\nusing this:\n  (\\<epsilon>, h) \\<in> Field leq\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<noteq> a \\<Longrightarrow> d_OUT \\<epsilon> x = 0", "by(simp add: Fld Fld_def)"], ["proof (state)\nthis:\n  \\<lbrakk>(?\\<epsilon>1, ?h1) \\<in> Field leq; ?x \\<noteq> a\\<rbrakk>\n  \\<Longrightarrow> d_OUT ?\\<epsilon>1 ?x = 0\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       current \\<Gamma> f \\<and>\n       d_OUT f a = weight \\<Gamma> a \\<and>\n       \\<not> hindered (\\<Gamma> \\<ominus> f)", "have h: \"current (\\<Gamma> \\<ominus> \\<epsilon>) h\" if \"(\\<epsilon>, h) \\<in> Field leq\" for \\<epsilon> h"], ["proof (prove)\ngoal (1 subgoal):\n 1. current (\\<Gamma> \\<ominus> \\<epsilon>) h", "using that"], ["proof (prove)\nusing this:\n  (\\<epsilon>, h) \\<in> Field leq\n\ngoal (1 subgoal):\n 1. current (\\<Gamma> \\<ominus> \\<epsilon>) h", "by(simp add: Fld Fld_def)"], ["proof (state)\nthis:\n  (?\\<epsilon>, ?h) \\<in> Field leq \\<Longrightarrow>\n  current (\\<Gamma> \\<ominus> ?\\<epsilon>) ?h\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       current \\<Gamma> f \\<and>\n       d_OUT f a = weight \\<Gamma> a \\<and>\n       \\<not> hindered (\\<Gamma> \\<ominus> f)", "have h_w: \"wave (\\<Gamma> \\<ominus> \\<epsilon>) h\" if \"(\\<epsilon>, h) \\<in> Field leq\" for \\<epsilon> h"], ["proof (prove)\ngoal (1 subgoal):\n 1. wave (\\<Gamma> \\<ominus> \\<epsilon>) h", "using that"], ["proof (prove)\nusing this:\n  (\\<epsilon>, h) \\<in> Field leq\n\ngoal (1 subgoal):\n 1. wave (\\<Gamma> \\<ominus> \\<epsilon>) h", "by(simp add: Fld Fld_def)"], ["proof (state)\nthis:\n  (?\\<epsilon>, ?h) \\<in> Field leq \\<Longrightarrow>\n  wave (\\<Gamma> \\<ominus> ?\\<epsilon>) ?h\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       current \\<Gamma> f \\<and>\n       d_OUT f a = weight \\<Gamma> a \\<and>\n       \\<not> hindered (\\<Gamma> \\<ominus> f)", "have unhindered': \"\\<not> hindered (\\<Gamma> \\<ominus> F \\<epsilon>h)\" if \"\\<epsilon>h \\<in> Field leq\" for \\<epsilon>h"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> hindered (\\<Gamma> \\<ominus> F \\<epsilon>h)", "using that"], ["proof (prove)\nusing this:\n  \\<epsilon>h \\<in> Field leq\n\ngoal (1 subgoal):\n 1. \\<not> hindered (\\<Gamma> \\<ominus> F \\<epsilon>h)", "by(simp add: Fld Fld_def split: prod.split_asm)"], ["proof (state)\nthis:\n  ?\\<epsilon>h \\<in> Field leq \\<Longrightarrow>\n  \\<not> hindered (\\<Gamma> \\<ominus> F ?\\<epsilon>h)\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       current \\<Gamma> f \\<and>\n       d_OUT f a = weight \\<Gamma> a \\<and>\n       \\<not> hindered (\\<Gamma> \\<ominus> f)", "have f: \"current \\<Gamma> (F \\<epsilon>h)\" if \"\\<epsilon>h \\<in> Field leq\" for \\<epsilon>h"], ["proof (prove)\ngoal (1 subgoal):\n 1. current \\<Gamma> (F \\<epsilon>h)", "using \\<epsilon>_curr h that"], ["proof (prove)\nusing this:\n  (?\\<epsilon>, ?h) \\<in> Field leq \\<Longrightarrow>\n  current \\<Gamma> ?\\<epsilon>\n  (?\\<epsilon>, ?h) \\<in> Field leq \\<Longrightarrow>\n  current (\\<Gamma> \\<ominus> ?\\<epsilon>) ?h\n  \\<epsilon>h \\<in> Field leq\n\ngoal (1 subgoal):\n 1. current \\<Gamma> (F \\<epsilon>h)", "by(cases \\<epsilon>h)(simp add: F_simps current_plus_current_minus)"], ["proof (state)\nthis:\n  ?\\<epsilon>h \\<in> Field leq \\<Longrightarrow>\n  current \\<Gamma> (F ?\\<epsilon>h)\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       current \\<Gamma> f \\<and>\n       d_OUT f a = weight \\<Gamma> a \\<and>\n       \\<not> hindered (\\<Gamma> \\<ominus> f)", "have out_\\<epsilon>: \"\\<epsilon> (x, y) = 0\" if \"(\\<epsilon>, h) \\<in> Field leq\" \"x \\<noteq> a\" for \\<epsilon> h x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<epsilon> (x, y) = 0", "proof(rule antisym)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<epsilon> (x, y) \\<le> 0\n 2. 0 \\<le> \\<epsilon> (x, y)", "have \"\\<epsilon> (x, y) \\<le> d_OUT \\<epsilon> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<epsilon> (x, y) \\<le> d_OUT \\<epsilon> x", "unfolding d_OUT_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<epsilon> (x, y) \\<le> (\\<Sum>\\<^sup>+ y. \\<epsilon> (x, y))", "by(rule nn_integral_ge_point) simp"], ["proof (state)\nthis:\n  \\<epsilon> (x, y) \\<le> d_OUT \\<epsilon> x\n\ngoal (2 subgoals):\n 1. \\<epsilon> (x, y) \\<le> 0\n 2. 0 \\<le> \\<epsilon> (x, y)", "with OUT_\\<epsilon>[OF that]"], ["proof (chain)\npicking this:\n  d_OUT \\<epsilon> x = 0\n  \\<epsilon> (x, y) \\<le> d_OUT \\<epsilon> x", "show \"\\<epsilon> (x, y) \\<le> 0\""], ["proof (prove)\nusing this:\n  d_OUT \\<epsilon> x = 0\n  \\<epsilon> (x, y) \\<le> d_OUT \\<epsilon> x\n\ngoal (1 subgoal):\n 1. \\<epsilon> (x, y) \\<le> 0", "by simp"], ["proof (state)\nthis:\n  \\<epsilon> (x, y) \\<le> 0\n\ngoal (1 subgoal):\n 1. 0 \\<le> \\<epsilon> (x, y)", "qed simp"], ["proof (state)\nthis:\n  \\<lbrakk>(?\\<epsilon>, ?h) \\<in> Field leq; ?x \\<noteq> a\\<rbrakk>\n  \\<Longrightarrow> ?\\<epsilon> (?x, ?y) = 0\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       current \\<Gamma> f \\<and>\n       d_OUT f a = weight \\<Gamma> a \\<and>\n       \\<not> hindered (\\<Gamma> \\<ominus> f)", "have IN_\\<epsilon>: \"d_IN \\<epsilon> x = \\<epsilon> (a, x)\" if \"(\\<epsilon>, h) \\<in> Field leq\" for \\<epsilon> h x"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN \\<epsilon> x = \\<epsilon> (a, x)", "proof(rule trans)"], ["proof (state)\ngoal (2 subgoals):\n 1. d_IN \\<epsilon> x = ?s\n 2. ?s = \\<epsilon> (a, x)", "show \"d_IN \\<epsilon> x = (\\<Sum>\\<^sup>+ y. \\<epsilon> (y, x) * indicator {a} y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN \\<epsilon> x =\n    \\<integral>\\<^sup>+y\\<in>{a}. \\<epsilon> (y, x)\n    \\<partial>count_space UNIV", "unfolding d_IN_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ xa. \\<epsilon> (xa, x)) =\n    \\<integral>\\<^sup>+y\\<in>{a}. \\<epsilon> (y, x)\n    \\<partial>count_space UNIV", "by(rule nn_integral_cong)(simp add: out_\\<epsilon>[OF that] split: split_indicator)"], ["proof (state)\nthis:\n  d_IN \\<epsilon> x =\n  \\<integral>\\<^sup>+y\\<in>{a}. \\<epsilon> (y, x)\\<partial>count_space UNIV\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+y\\<in>{a}. \\<epsilon> (y, x)\n    \\<partial>count_space UNIV =\n    \\<epsilon> (a, x)", "qed(simp add: max_def \\<epsilon>_curr[OF that])"], ["proof (state)\nthis:\n  (?\\<epsilon>, ?h) \\<in> Field leq \\<Longrightarrow>\n  d_IN ?\\<epsilon> ?x = ?\\<epsilon> (a, ?x)\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       current \\<Gamma> f \\<and>\n       d_OUT f a = weight \\<Gamma> a \\<and>\n       \\<not> hindered (\\<Gamma> \\<ominus> f)", "have leqI: \"((\\<epsilon>, h), (\\<epsilon>', h')) \\<in> leq\" if \"\\<epsilon> \\<le> \\<epsilon>'\" \"h \\<le> h'\" \"(\\<epsilon>, h) \\<in> Field leq\" \"(\\<epsilon>', h') \\<in> Field leq\" for \\<epsilon> h \\<epsilon>' h'"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<epsilon>, h), \\<epsilon>', h') \\<in> leq", "using that"], ["proof (prove)\nusing this:\n  \\<epsilon> \\<le> \\<epsilon>'\n  h \\<le> h'\n  (\\<epsilon>, h) \\<in> Field leq\n  (\\<epsilon>', h') \\<in> Field leq\n\ngoal (1 subgoal):\n 1. ((\\<epsilon>, h), \\<epsilon>', h') \\<in> leq", "unfolding Fld"], ["proof (prove)\nusing this:\n  \\<epsilon> \\<le> \\<epsilon>'\n  h \\<le> h'\n  (\\<epsilon>, h) \\<in> Fld\n  (\\<epsilon>', h') \\<in> Fld\n\ngoal (1 subgoal):\n 1. ((\\<epsilon>, h), \\<epsilon>', h') \\<in> leq", "by(simp add: leq_def in_restrict_rel_iff)"], ["proof (state)\nthis:\n  \\<lbrakk>?\\<epsilon> \\<le> ?\\<epsilon>'; ?h \\<le> ?h';\n   (?\\<epsilon>, ?h) \\<in> Field leq;\n   (?\\<epsilon>', ?h') \\<in> Field leq\\<rbrakk>\n  \\<Longrightarrow> ((?\\<epsilon>, ?h), ?\\<epsilon>', ?h') \\<in> leq\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       current \\<Gamma> f \\<and>\n       d_OUT f a = weight \\<Gamma> a \\<and>\n       \\<not> hindered (\\<Gamma> \\<ominus> f)", "have chain_Field: \"Sup M \\<in> Field leq\" if M: \"M \\<in> Chains leq\" and nempty: \"M \\<noteq> {}\" for M"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Squnion> M \\<in> Field leq", "unfolding Sup_prod_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Squnion> (fst ` M), \\<Squnion> (snd ` M)) \\<in> Field leq", "proof"], ["proof (state)\ngoal (5 subgoals):\n 1. current \\<Gamma> (\\<Squnion> (fst ` M))\n 2. \\<And>x.\n       x \\<noteq> a \\<Longrightarrow> d_OUT (\\<Squnion> (fst ` M)) x = 0\n 3. current (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)) (\\<Squnion> (snd ` M))\n 4. wave (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)) (\\<Squnion> (snd ` M))\n 5. \\<not> hindered\n            (\\<Gamma> \\<ominus>\n             F (\\<Squnion> (fst ` M), \\<Squnion> (snd ` M)))", "from nempty"], ["proof (chain)\npicking this:\n  M \\<noteq> {}", "obtain \\<epsilon> h where in_M: \"(\\<epsilon>, h) \\<in> M\""], ["proof (prove)\nusing this:\n  M \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>\\<epsilon> h.\n        (\\<epsilon>, h) \\<in> M \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  (\\<epsilon>, h) \\<in> M\n\ngoal (5 subgoals):\n 1. current \\<Gamma> (\\<Squnion> (fst ` M))\n 2. \\<And>x.\n       x \\<noteq> a \\<Longrightarrow> d_OUT (\\<Squnion> (fst ` M)) x = 0\n 3. current (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)) (\\<Squnion> (snd ` M))\n 4. wave (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)) (\\<Squnion> (snd ` M))\n 5. \\<not> hindered\n            (\\<Gamma> \\<ominus>\n             F (\\<Squnion> (fst ` M), \\<Squnion> (snd ` M)))", "with M"], ["proof (chain)\npicking this:\n  M \\<in> Chains leq\n  (\\<epsilon>, h) \\<in> M", "have Field: \"(\\<epsilon>, h) \\<in> Field leq\""], ["proof (prove)\nusing this:\n  M \\<in> Chains leq\n  (\\<epsilon>, h) \\<in> M\n\ngoal (1 subgoal):\n 1. (\\<epsilon>, h) \\<in> Field leq", "by(rule Chains_FieldD)"], ["proof (state)\nthis:\n  (\\<epsilon>, h) \\<in> Field leq\n\ngoal (5 subgoals):\n 1. current \\<Gamma> (\\<Squnion> (fst ` M))\n 2. \\<And>x.\n       x \\<noteq> a \\<Longrightarrow> d_OUT (\\<Squnion> (fst ` M)) x = 0\n 3. current (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)) (\\<Squnion> (snd ` M))\n 4. wave (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)) (\\<Squnion> (snd ` M))\n 5. \\<not> hindered\n            (\\<Gamma> \\<ominus>\n             F (\\<Squnion> (fst ` M), \\<Squnion> (snd ` M)))", "from M"], ["proof (chain)\npicking this:\n  M \\<in> Chains leq", "have chain: \"Complete_Partial_Order.chain (\\<lambda>\\<epsilon> \\<epsilon>'. (\\<epsilon>, \\<epsilon>') \\<in> leq) M\""], ["proof (prove)\nusing this:\n  M \\<in> Chains leq\n\ngoal (1 subgoal):\n 1. Complete_Partial_Order.chain\n     (\\<lambda>\\<epsilon> \\<epsilon>'. (\\<epsilon>, \\<epsilon>') \\<in> leq)\n     M", "by(intro Chains_into_chain) simp"], ["proof (state)\nthis:\n  Complete_Partial_Order.chain\n   (\\<lambda>\\<epsilon> \\<epsilon>'. (\\<epsilon>, \\<epsilon>') \\<in> leq) M\n\ngoal (5 subgoals):\n 1. current \\<Gamma> (\\<Squnion> (fst ` M))\n 2. \\<And>x.\n       x \\<noteq> a \\<Longrightarrow> d_OUT (\\<Squnion> (fst ` M)) x = 0\n 3. current (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)) (\\<Squnion> (snd ` M))\n 4. wave (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)) (\\<Squnion> (snd ` M))\n 5. \\<not> hindered\n            (\\<Gamma> \\<ominus>\n             F (\\<Squnion> (fst ` M), \\<Squnion> (snd ` M)))", "hence chain': \"Complete_Partial_Order.chain (\\<le>) M\""], ["proof (prove)\nusing this:\n  Complete_Partial_Order.chain\n   (\\<lambda>\\<epsilon> \\<epsilon>'. (\\<epsilon>, \\<epsilon>') \\<in> leq) M\n\ngoal (1 subgoal):\n 1. Complete_Partial_Order.chain (\\<le>) M", "by(auto simp add: chain_def leq_def in_restrict_rel_iff)"], ["proof (state)\nthis:\n  Complete_Partial_Order.chain (\\<le>) M\n\ngoal (5 subgoals):\n 1. current \\<Gamma> (\\<Squnion> (fst ` M))\n 2. \\<And>x.\n       x \\<noteq> a \\<Longrightarrow> d_OUT (\\<Squnion> (fst ` M)) x = 0\n 3. current (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)) (\\<Squnion> (snd ` M))\n 4. wave (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)) (\\<Squnion> (snd ` M))\n 5. \\<not> hindered\n            (\\<Gamma> \\<ominus>\n             F (\\<Squnion> (fst ` M), \\<Squnion> (snd ` M)))", "hence chain1: \"Complete_Partial_Order.chain (\\<le>) (fst ` M)\"\n      and chain2: \"Complete_Partial_Order.chain (\\<le>) (snd ` M)\""], ["proof (prove)\nusing this:\n  Complete_Partial_Order.chain (\\<le>) M\n\ngoal (1 subgoal):\n 1. Complete_Partial_Order.chain (\\<le>) (fst ` M) &&&\n    Complete_Partial_Order.chain (\\<le>) (snd ` M)", "by(rule chain_imageI; auto)+"], ["proof (state)\nthis:\n  Complete_Partial_Order.chain (\\<le>) (fst ` M)\n  Complete_Partial_Order.chain (\\<le>) (snd ` M)\n\ngoal (5 subgoals):\n 1. current \\<Gamma> (\\<Squnion> (fst ` M))\n 2. \\<And>x.\n       x \\<noteq> a \\<Longrightarrow> d_OUT (\\<Squnion> (fst ` M)) x = 0\n 3. current (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)) (\\<Squnion> (snd ` M))\n 4. wave (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)) (\\<Squnion> (snd ` M))\n 5. \\<not> hindered\n            (\\<Gamma> \\<ominus>\n             F (\\<Squnion> (fst ` M), \\<Squnion> (snd ` M)))", "have outside1: \"Sup (fst ` M) (x, y) = 0\" if \"\\<not> edge \\<Gamma> x y\" for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Squnion> (fst ` M)) (x, y) = 0", "using that"], ["proof (prove)\nusing this:\n  \\<not> edge \\<Gamma> x y\n\ngoal (1 subgoal):\n 1. (\\<Squnion> (fst ` M)) (x, y) = 0", "by(auto intro!: SUP_eq_const simp add: nempty dest!: Chains_FieldD[OF M] \\<epsilon>_curr currentD_outside)"], ["proof (state)\nthis:\n  \\<not> edge \\<Gamma> ?x ?y \\<Longrightarrow>\n  (\\<Squnion> (fst ` M)) (?x, ?y) = 0\n\ngoal (5 subgoals):\n 1. current \\<Gamma> (\\<Squnion> (fst ` M))\n 2. \\<And>x.\n       x \\<noteq> a \\<Longrightarrow> d_OUT (\\<Squnion> (fst ` M)) x = 0\n 3. current (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)) (\\<Squnion> (snd ` M))\n 4. wave (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)) (\\<Squnion> (snd ` M))\n 5. \\<not> hindered\n            (\\<Gamma> \\<ominus>\n             F (\\<Squnion> (fst ` M), \\<Squnion> (snd ` M)))", "then"], ["proof (chain)\npicking this:\n  \\<not> edge \\<Gamma> ?x ?y \\<Longrightarrow>\n  (\\<Squnion> (fst ` M)) (?x, ?y) = 0", "have \"support_flow (Sup (fst ` M)) \\<subseteq> \\<^bold>E\""], ["proof (prove)\nusing this:\n  \\<not> edge \\<Gamma> ?x ?y \\<Longrightarrow>\n  (\\<Squnion> (fst ` M)) (?x, ?y) = 0\n\ngoal (1 subgoal):\n 1. support_flow (\\<Squnion> (fst ` M)) \\<subseteq> \\<^bold>E", "by(auto elim!: support_flow.cases intro: ccontr)"], ["proof (state)\nthis:\n  support_flow (\\<Squnion> (fst ` M)) \\<subseteq> \\<^bold>E\n\ngoal (5 subgoals):\n 1. current \\<Gamma> (\\<Squnion> (fst ` M))\n 2. \\<And>x.\n       x \\<noteq> a \\<Longrightarrow> d_OUT (\\<Squnion> (fst ` M)) x = 0\n 3. current (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)) (\\<Squnion> (snd ` M))\n 4. wave (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)) (\\<Squnion> (snd ` M))\n 5. \\<not> hindered\n            (\\<Gamma> \\<ominus>\n             F (\\<Squnion> (fst ` M), \\<Squnion> (snd ` M)))", "hence supp_flow1: \"countable (support_flow (Sup (fst ` M)))\""], ["proof (prove)\nusing this:\n  support_flow (\\<Squnion> (fst ` M)) \\<subseteq> \\<^bold>E\n\ngoal (1 subgoal):\n 1. countable (support_flow (\\<Squnion> (fst ` M)))", "by(rule countable_subset) simp"], ["proof (state)\nthis:\n  countable (support_flow (\\<Squnion> (fst ` M)))\n\ngoal (5 subgoals):\n 1. current \\<Gamma> (\\<Squnion> (fst ` M))\n 2. \\<And>x.\n       x \\<noteq> a \\<Longrightarrow> d_OUT (\\<Squnion> (fst ` M)) x = 0\n 3. current (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)) (\\<Squnion> (snd ` M))\n 4. wave (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)) (\\<Squnion> (snd ` M))\n 5. \\<not> hindered\n            (\\<Gamma> \\<ominus>\n             F (\\<Squnion> (fst ` M), \\<Squnion> (snd ` M)))", "show SM1: \"current \\<Gamma> (Sup (fst ` M))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. current \\<Gamma> (\\<Squnion> (fst ` M))", "by(rule current_Sup[OF chain1 _ _ supp_flow1])(auto dest: Chains_FieldD[OF M, THEN \\<epsilon>_curr] simp add: nempty)"], ["proof (state)\nthis:\n  current \\<Gamma> (\\<Squnion> (fst ` M))\n\ngoal (4 subgoals):\n 1. \\<And>x.\n       x \\<noteq> a \\<Longrightarrow> d_OUT (\\<Squnion> (fst ` M)) x = 0\n 2. current (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)) (\\<Squnion> (snd ` M))\n 3. wave (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)) (\\<Squnion> (snd ` M))\n 4. \\<not> hindered\n            (\\<Gamma> \\<ominus>\n             F (\\<Squnion> (fst ` M), \\<Squnion> (snd ` M)))", "show OUT1_na: \"d_OUT (Sup (fst ` M)) x = 0\" if \"x \\<noteq> a\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT (\\<Squnion> (fst ` M)) x = 0", "using that"], ["proof (prove)\nusing this:\n  x \\<noteq> a\n\ngoal (1 subgoal):\n 1. d_OUT (\\<Squnion> (fst ` M)) x = 0", "by(subst d_OUT_Sup[OF chain1 _ supp_flow1])(auto simp add: nempty intro!: SUP_eq_const dest: Chains_FieldD[OF M, THEN OUT_\\<epsilon>])"], ["proof (state)\nthis:\n  ?x \\<noteq> a \\<Longrightarrow> d_OUT (\\<Squnion> (fst ` M)) ?x = 0\n\ngoal (3 subgoals):\n 1. current (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)) (\\<Squnion> (snd ` M))\n 2. wave (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)) (\\<Squnion> (snd ` M))\n 3. \\<not> hindered\n            (\\<Gamma> \\<ominus>\n             F (\\<Squnion> (fst ` M), \\<Squnion> (snd ` M)))", "interpret SM1: countable_bipartite_web \"\\<Gamma> \\<ominus> Sup (fst ` M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. countable_bipartite_web (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M))", "using SM1"], ["proof (prove)\nusing this:\n  current \\<Gamma> (\\<Squnion> (fst ` M))\n\ngoal (1 subgoal):\n 1. countable_bipartite_web (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M))", "by(rule countable_bipartite_web_minus_web)"], ["proof (state)\ngoal (3 subgoals):\n 1. current (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)) (\\<Squnion> (snd ` M))\n 2. wave (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)) (\\<Squnion> (snd ` M))\n 3. \\<not> hindered\n            (\\<Gamma> \\<ominus>\n             F (\\<Squnion> (fst ` M), \\<Squnion> (snd ` M)))", "let ?h = \"Sup (snd ` M)\""], ["proof (state)\ngoal (3 subgoals):\n 1. current (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)) (\\<Squnion> (snd ` M))\n 2. wave (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)) (\\<Squnion> (snd ` M))\n 3. \\<not> hindered\n            (\\<Gamma> \\<ominus>\n             F (\\<Squnion> (fst ` M), \\<Squnion> (snd ` M)))", "have outside2: \"?h (x, y) = 0\" if \"\\<not> edge \\<Gamma> x y\" for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Squnion> (snd ` M)) (x, y) = 0", "using that"], ["proof (prove)\nusing this:\n  \\<not> edge \\<Gamma> x y\n\ngoal (1 subgoal):\n 1. (\\<Squnion> (snd ` M)) (x, y) = 0", "by(auto intro!: SUP_eq_const simp add: nempty dest!: Chains_FieldD[OF M] h currentD_outside)"], ["proof (state)\nthis:\n  \\<not> edge \\<Gamma> ?x ?y \\<Longrightarrow>\n  (\\<Squnion> (snd ` M)) (?x, ?y) = 0\n\ngoal (3 subgoals):\n 1. current (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)) (\\<Squnion> (snd ` M))\n 2. wave (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)) (\\<Squnion> (snd ` M))\n 3. \\<not> hindered\n            (\\<Gamma> \\<ominus>\n             F (\\<Squnion> (fst ` M), \\<Squnion> (snd ` M)))", "then"], ["proof (chain)\npicking this:\n  \\<not> edge \\<Gamma> ?x ?y \\<Longrightarrow>\n  (\\<Squnion> (snd ` M)) (?x, ?y) = 0", "have \"support_flow ?h \\<subseteq> \\<^bold>E\""], ["proof (prove)\nusing this:\n  \\<not> edge \\<Gamma> ?x ?y \\<Longrightarrow>\n  (\\<Squnion> (snd ` M)) (?x, ?y) = 0\n\ngoal (1 subgoal):\n 1. support_flow (\\<Squnion> (snd ` M)) \\<subseteq> \\<^bold>E", "by(auto elim!: support_flow.cases intro: ccontr)"], ["proof (state)\nthis:\n  support_flow (\\<Squnion> (snd ` M)) \\<subseteq> \\<^bold>E\n\ngoal (3 subgoals):\n 1. current (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)) (\\<Squnion> (snd ` M))\n 2. wave (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)) (\\<Squnion> (snd ` M))\n 3. \\<not> hindered\n            (\\<Gamma> \\<ominus>\n             F (\\<Squnion> (fst ` M), \\<Squnion> (snd ` M)))", "hence supp_flow2: \"countable (support_flow ?h)\""], ["proof (prove)\nusing this:\n  support_flow (\\<Squnion> (snd ` M)) \\<subseteq> \\<^bold>E\n\ngoal (1 subgoal):\n 1. countable (support_flow (\\<Squnion> (snd ` M)))", "by(rule countable_subset) simp"], ["proof (state)\nthis:\n  countable (support_flow (\\<Squnion> (snd ` M)))\n\ngoal (3 subgoals):\n 1. current (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)) (\\<Squnion> (snd ` M))\n 2. wave (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)) (\\<Squnion> (snd ` M))\n 3. \\<not> hindered\n            (\\<Gamma> \\<ominus>\n             F (\\<Squnion> (fst ` M), \\<Squnion> (snd ` M)))", "have OUT1: \"d_OUT (Sup (fst ` M)) x = (SUP (\\<epsilon>, h)\\<in>M. d_OUT \\<epsilon> x)\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT (\\<Squnion> (fst ` M)) x =\n    (\\<Squnion>(\\<epsilon>, h)\\<in>M. d_OUT \\<epsilon> x)", "by (subst d_OUT_Sup [OF chain1 _ supp_flow1])\n        (simp_all add: nempty split_beta image_comp)"], ["proof (state)\nthis:\n  d_OUT (\\<Squnion> (fst ` M)) ?x =\n  (\\<Squnion>(\\<epsilon>, h)\\<in>M. d_OUT \\<epsilon> ?x)\n\ngoal (3 subgoals):\n 1. current (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)) (\\<Squnion> (snd ` M))\n 2. wave (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)) (\\<Squnion> (snd ` M))\n 3. \\<not> hindered\n            (\\<Gamma> \\<ominus>\n             F (\\<Squnion> (fst ` M), \\<Squnion> (snd ` M)))", "have OUT1': \"d_OUT (Sup (fst ` M)) x = (if x = a then SUP (\\<epsilon>, h)\\<in>M. d_OUT \\<epsilon> a else 0)\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT (\\<Squnion> (fst ` M)) x =\n    (if x = a then \\<Squnion>(\\<epsilon>, h)\\<in>M. d_OUT \\<epsilon> a\n     else 0)", "unfolding OUT1"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Squnion>(\\<epsilon>, h)\\<in>M. d_OUT \\<epsilon> x) =\n    (if x = a then \\<Squnion>(\\<epsilon>, h)\\<in>M. d_OUT \\<epsilon> a\n     else 0)", "by(auto intro!: SUP_eq_const simp add: nempty OUT_\\<epsilon> dest!: Chains_FieldD[OF M])"], ["proof (state)\nthis:\n  d_OUT (\\<Squnion> (fst ` M)) ?x =\n  (if ?x = a then \\<Squnion>(\\<epsilon>, h)\\<in>M. d_OUT \\<epsilon> a\n   else 0)\n\ngoal (3 subgoals):\n 1. current (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)) (\\<Squnion> (snd ` M))\n 2. wave (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)) (\\<Squnion> (snd ` M))\n 3. \\<not> hindered\n            (\\<Gamma> \\<ominus>\n             F (\\<Squnion> (fst ` M), \\<Squnion> (snd ` M)))", "have OUT1_le: \"(\\<Squnion>\\<epsilon>h\\<in>M. d_OUT (fst \\<epsilon>h) x) \\<le> weight \\<Gamma> x\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Squnion>\\<epsilon>h\\<in>M. d_OUT (fst \\<epsilon>h) x)\n    \\<le> weight \\<Gamma> x", "using currentD_weight_OUT[OF SM1, of x] OUT1[of x]"], ["proof (prove)\nusing this:\n  d_OUT (\\<Squnion> (fst ` M)) x \\<le> weight \\<Gamma> x\n  d_OUT (\\<Squnion> (fst ` M)) x =\n  (\\<Squnion>(\\<epsilon>, h)\\<in>M. d_OUT \\<epsilon> x)\n\ngoal (1 subgoal):\n 1. (\\<Squnion>\\<epsilon>h\\<in>M. d_OUT (fst \\<epsilon>h) x)\n    \\<le> weight \\<Gamma> x", "by(simp add: split_beta)"], ["proof (state)\nthis:\n  (\\<Squnion>\\<epsilon>h\\<in>M. d_OUT (fst \\<epsilon>h) ?x)\n  \\<le> weight \\<Gamma> ?x\n\ngoal (3 subgoals):\n 1. current (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)) (\\<Squnion> (snd ` M))\n 2. wave (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)) (\\<Squnion> (snd ` M))\n 3. \\<not> hindered\n            (\\<Gamma> \\<ominus>\n             F (\\<Squnion> (fst ` M), \\<Squnion> (snd ` M)))", "have OUT1_nonneg: \"0 \\<le> (\\<Squnion>\\<epsilon>h\\<in>M. d_OUT (fst \\<epsilon>h) x)\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> (\\<Squnion>\\<epsilon>h\\<in>M. d_OUT (fst \\<epsilon>h) x)", "using in_M"], ["proof (prove)\nusing this:\n  (\\<epsilon>, h) \\<in> M\n\ngoal (1 subgoal):\n 1. 0 \\<le> (\\<Squnion>\\<epsilon>h\\<in>M. d_OUT (fst \\<epsilon>h) x)", "by(rule SUP_upper2)(simp add: )"], ["proof (state)\nthis:\n  0 \\<le> (\\<Squnion>\\<epsilon>h\\<in>M. d_OUT (fst \\<epsilon>h) ?x)\n\ngoal (3 subgoals):\n 1. current (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)) (\\<Squnion> (snd ` M))\n 2. wave (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)) (\\<Squnion> (snd ` M))\n 3. \\<not> hindered\n            (\\<Gamma> \\<ominus>\n             F (\\<Squnion> (fst ` M), \\<Squnion> (snd ` M)))", "have IN1: \"d_IN (Sup (fst ` M)) x = (SUP (\\<epsilon>, h)\\<in>M. d_IN \\<epsilon> x)\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN (\\<Squnion> (fst ` M)) x =\n    (\\<Squnion>(\\<epsilon>, h)\\<in>M. d_IN \\<epsilon> x)", "by (subst d_IN_Sup [OF chain1 _ supp_flow1])\n        (simp_all add: nempty split_beta image_comp)"], ["proof (state)\nthis:\n  d_IN (\\<Squnion> (fst ` M)) ?x =\n  (\\<Squnion>(\\<epsilon>, h)\\<in>M. d_IN \\<epsilon> ?x)\n\ngoal (3 subgoals):\n 1. current (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)) (\\<Squnion> (snd ` M))\n 2. wave (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)) (\\<Squnion> (snd ` M))\n 3. \\<not> hindered\n            (\\<Gamma> \\<ominus>\n             F (\\<Squnion> (fst ` M), \\<Squnion> (snd ` M)))", "have IN1_le: \"(\\<Squnion>\\<epsilon>h\\<in>M. d_IN (fst \\<epsilon>h) x) \\<le> weight \\<Gamma> x\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Squnion>\\<epsilon>h\\<in>M. d_IN (fst \\<epsilon>h) x)\n    \\<le> weight \\<Gamma> x", "using currentD_weight_IN[OF SM1, of x] IN1[of x]"], ["proof (prove)\nusing this:\n  d_IN (\\<Squnion> (fst ` M)) x \\<le> weight \\<Gamma> x\n  d_IN (\\<Squnion> (fst ` M)) x =\n  (\\<Squnion>(\\<epsilon>, h)\\<in>M. d_IN \\<epsilon> x)\n\ngoal (1 subgoal):\n 1. (\\<Squnion>\\<epsilon>h\\<in>M. d_IN (fst \\<epsilon>h) x)\n    \\<le> weight \\<Gamma> x", "by(simp add: split_beta)"], ["proof (state)\nthis:\n  (\\<Squnion>\\<epsilon>h\\<in>M. d_IN (fst \\<epsilon>h) ?x)\n  \\<le> weight \\<Gamma> ?x\n\ngoal (3 subgoals):\n 1. current (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)) (\\<Squnion> (snd ` M))\n 2. wave (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)) (\\<Squnion> (snd ` M))\n 3. \\<not> hindered\n            (\\<Gamma> \\<ominus>\n             F (\\<Squnion> (fst ` M), \\<Squnion> (snd ` M)))", "have IN1_nonneg: \"0 \\<le> (\\<Squnion>\\<epsilon>h\\<in>M. d_IN (fst \\<epsilon>h) x)\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> (\\<Squnion>\\<epsilon>h\\<in>M. d_IN (fst \\<epsilon>h) x)", "using in_M"], ["proof (prove)\nusing this:\n  (\\<epsilon>, h) \\<in> M\n\ngoal (1 subgoal):\n 1. 0 \\<le> (\\<Squnion>\\<epsilon>h\\<in>M. d_IN (fst \\<epsilon>h) x)", "by(rule SUP_upper2) simp"], ["proof (state)\nthis:\n  0 \\<le> (\\<Squnion>\\<epsilon>h\\<in>M. d_IN (fst \\<epsilon>h) ?x)\n\ngoal (3 subgoals):\n 1. current (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)) (\\<Squnion> (snd ` M))\n 2. wave (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)) (\\<Squnion> (snd ` M))\n 3. \\<not> hindered\n            (\\<Gamma> \\<ominus>\n             F (\\<Squnion> (fst ` M), \\<Squnion> (snd ` M)))", "have IN1': \"d_IN (Sup (fst ` M)) x = (SUP (\\<epsilon>, h)\\<in>M. \\<epsilon> (a, x))\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN (\\<Squnion> (fst ` M)) x =\n    (\\<Squnion>(\\<epsilon>, h)\\<in>M. \\<epsilon> (a, x))", "unfolding IN1"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Squnion>(\\<epsilon>, h)\\<in>M. d_IN \\<epsilon> x) =\n    (\\<Squnion>(\\<epsilon>, h)\\<in>M. \\<epsilon> (a, x))", "by(rule SUP_cong[OF refl])(auto dest!: Chains_FieldD[OF M] IN_\\<epsilon>)"], ["proof (state)\nthis:\n  d_IN (\\<Squnion> (fst ` M)) ?x =\n  (\\<Squnion>(\\<epsilon>, h)\\<in>M. \\<epsilon> (a, ?x))\n\ngoal (3 subgoals):\n 1. current (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)) (\\<Squnion> (snd ` M))\n 2. wave (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)) (\\<Squnion> (snd ` M))\n 3. \\<not> hindered\n            (\\<Gamma> \\<ominus>\n             F (\\<Squnion> (fst ` M), \\<Squnion> (snd ` M)))", "have directed: \"\\<exists>\\<epsilon>k''\\<in>M. F (snd \\<epsilon>k) + F (fst \\<epsilon>k') \\<le> F (snd \\<epsilon>k'') + F (fst \\<epsilon>k'')\"\n      if mono: \"\\<And>f g. (\\<And>z. f z \\<le> g z) \\<Longrightarrow> F f \\<le> F g\" \"\\<epsilon>k \\<in> M\" \"\\<epsilon>k' \\<in> M\"\n      for \\<epsilon>k \\<epsilon>k' and F :: \"_ \\<Rightarrow> ennreal\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>\\<epsilon>k''\\<in>M.\n       F (snd \\<epsilon>k) + F (fst \\<epsilon>k')\n       \\<le> F (snd \\<epsilon>k'') + F (fst \\<epsilon>k'')", "using chainD[OF chain that(2-3)]"], ["proof (prove)\nusing this:\n  (\\<epsilon>k, \\<epsilon>k') \\<in> leq \\<or>\n  (\\<epsilon>k', \\<epsilon>k) \\<in> leq\n\ngoal (1 subgoal):\n 1. \\<exists>\\<epsilon>k''\\<in>M.\n       F (snd \\<epsilon>k) + F (fst \\<epsilon>k')\n       \\<le> F (snd \\<epsilon>k'') + F (fst \\<epsilon>k'')", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<epsilon>k, \\<epsilon>k') \\<in> leq \\<Longrightarrow>\n    \\<exists>\\<epsilon>k''\\<in>M.\n       F (snd \\<epsilon>k) + F (fst \\<epsilon>k')\n       \\<le> F (snd \\<epsilon>k'') + F (fst \\<epsilon>k'')\n 2. (\\<epsilon>k', \\<epsilon>k) \\<in> leq \\<Longrightarrow>\n    \\<exists>\\<epsilon>k''\\<in>M.\n       F (snd \\<epsilon>k) + F (fst \\<epsilon>k')\n       \\<le> F (snd \\<epsilon>k'') + F (fst \\<epsilon>k'')", "case left"], ["proof (state)\nthis:\n  (\\<epsilon>k, \\<epsilon>k') \\<in> leq\n\ngoal (2 subgoals):\n 1. (\\<epsilon>k, \\<epsilon>k') \\<in> leq \\<Longrightarrow>\n    \\<exists>\\<epsilon>k''\\<in>M.\n       F (snd \\<epsilon>k) + F (fst \\<epsilon>k')\n       \\<le> F (snd \\<epsilon>k'') + F (fst \\<epsilon>k'')\n 2. (\\<epsilon>k', \\<epsilon>k) \\<in> leq \\<Longrightarrow>\n    \\<exists>\\<epsilon>k''\\<in>M.\n       F (snd \\<epsilon>k) + F (fst \\<epsilon>k')\n       \\<le> F (snd \\<epsilon>k'') + F (fst \\<epsilon>k'')", "hence \"snd \\<epsilon>k \\<le> snd \\<epsilon>k'\""], ["proof (prove)\nusing this:\n  (\\<epsilon>k, \\<epsilon>k') \\<in> leq\n\ngoal (1 subgoal):\n 1. snd \\<epsilon>k \\<le> snd \\<epsilon>k'", "by(simp add: leq_def less_eq_prod_def in_restrict_rel_iff)"], ["proof (state)\nthis:\n  snd \\<epsilon>k \\<le> snd \\<epsilon>k'\n\ngoal (2 subgoals):\n 1. (\\<epsilon>k, \\<epsilon>k') \\<in> leq \\<Longrightarrow>\n    \\<exists>\\<epsilon>k''\\<in>M.\n       F (snd \\<epsilon>k) + F (fst \\<epsilon>k')\n       \\<le> F (snd \\<epsilon>k'') + F (fst \\<epsilon>k'')\n 2. (\\<epsilon>k', \\<epsilon>k) \\<in> leq \\<Longrightarrow>\n    \\<exists>\\<epsilon>k''\\<in>M.\n       F (snd \\<epsilon>k) + F (fst \\<epsilon>k')\n       \\<le> F (snd \\<epsilon>k'') + F (fst \\<epsilon>k'')", "hence \"F (snd \\<epsilon>k) + F (fst \\<epsilon>k') \\<le> F (snd \\<epsilon>k') + F (fst \\<epsilon>k')\""], ["proof (prove)\nusing this:\n  snd \\<epsilon>k \\<le> snd \\<epsilon>k'\n\ngoal (1 subgoal):\n 1. F (snd \\<epsilon>k) + F (fst \\<epsilon>k')\n    \\<le> F (snd \\<epsilon>k') + F (fst \\<epsilon>k')", "by(intro add_right_mono mono)(clarsimp simp add: le_fun_def)"], ["proof (state)\nthis:\n  F (snd \\<epsilon>k) + F (fst \\<epsilon>k')\n  \\<le> F (snd \\<epsilon>k') + F (fst \\<epsilon>k')\n\ngoal (2 subgoals):\n 1. (\\<epsilon>k, \\<epsilon>k') \\<in> leq \\<Longrightarrow>\n    \\<exists>\\<epsilon>k''\\<in>M.\n       F (snd \\<epsilon>k) + F (fst \\<epsilon>k')\n       \\<le> F (snd \\<epsilon>k'') + F (fst \\<epsilon>k'')\n 2. (\\<epsilon>k', \\<epsilon>k) \\<in> leq \\<Longrightarrow>\n    \\<exists>\\<epsilon>k''\\<in>M.\n       F (snd \\<epsilon>k) + F (fst \\<epsilon>k')\n       \\<le> F (snd \\<epsilon>k'') + F (fst \\<epsilon>k'')", "with that"], ["proof (chain)\npicking this:\n  (\\<And>z. ?f z \\<le> ?g z) \\<Longrightarrow> F ?f \\<le> F ?g\n  \\<epsilon>k \\<in> M\n  \\<epsilon>k' \\<in> M\n  F (snd \\<epsilon>k) + F (fst \\<epsilon>k')\n  \\<le> F (snd \\<epsilon>k') + F (fst \\<epsilon>k')", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<And>z. ?f z \\<le> ?g z) \\<Longrightarrow> F ?f \\<le> F ?g\n  \\<epsilon>k \\<in> M\n  \\<epsilon>k' \\<in> M\n  F (snd \\<epsilon>k) + F (fst \\<epsilon>k')\n  \\<le> F (snd \\<epsilon>k') + F (fst \\<epsilon>k')\n\ngoal (1 subgoal):\n 1. \\<exists>\\<epsilon>k''\\<in>M.\n       F (snd \\<epsilon>k) + F (fst \\<epsilon>k')\n       \\<le> F (snd \\<epsilon>k'') + F (fst \\<epsilon>k'')", "by blast"], ["proof (state)\nthis:\n  \\<exists>\\<epsilon>k''\\<in>M.\n     F (snd \\<epsilon>k) + F (fst \\<epsilon>k')\n     \\<le> F (snd \\<epsilon>k'') + F (fst \\<epsilon>k'')\n\ngoal (1 subgoal):\n 1. (\\<epsilon>k', \\<epsilon>k) \\<in> leq \\<Longrightarrow>\n    \\<exists>\\<epsilon>k''\\<in>M.\n       F (snd \\<epsilon>k) + F (fst \\<epsilon>k')\n       \\<le> F (snd \\<epsilon>k'') + F (fst \\<epsilon>k'')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<epsilon>k', \\<epsilon>k) \\<in> leq \\<Longrightarrow>\n    \\<exists>\\<epsilon>k''\\<in>M.\n       F (snd \\<epsilon>k) + F (fst \\<epsilon>k')\n       \\<le> F (snd \\<epsilon>k'') + F (fst \\<epsilon>k'')", "case right"], ["proof (state)\nthis:\n  (\\<epsilon>k', \\<epsilon>k) \\<in> leq\n\ngoal (1 subgoal):\n 1. (\\<epsilon>k', \\<epsilon>k) \\<in> leq \\<Longrightarrow>\n    \\<exists>\\<epsilon>k''\\<in>M.\n       F (snd \\<epsilon>k) + F (fst \\<epsilon>k')\n       \\<le> F (snd \\<epsilon>k'') + F (fst \\<epsilon>k'')", "hence \"fst \\<epsilon>k' \\<le> fst \\<epsilon>k\""], ["proof (prove)\nusing this:\n  (\\<epsilon>k', \\<epsilon>k) \\<in> leq\n\ngoal (1 subgoal):\n 1. fst \\<epsilon>k' \\<le> fst \\<epsilon>k", "by(simp add: leq_def less_eq_prod_def in_restrict_rel_iff)"], ["proof (state)\nthis:\n  fst \\<epsilon>k' \\<le> fst \\<epsilon>k\n\ngoal (1 subgoal):\n 1. (\\<epsilon>k', \\<epsilon>k) \\<in> leq \\<Longrightarrow>\n    \\<exists>\\<epsilon>k''\\<in>M.\n       F (snd \\<epsilon>k) + F (fst \\<epsilon>k')\n       \\<le> F (snd \\<epsilon>k'') + F (fst \\<epsilon>k'')", "hence \"F (snd \\<epsilon>k) + F (fst \\<epsilon>k') \\<le> F (snd \\<epsilon>k) + F (fst \\<epsilon>k)\""], ["proof (prove)\nusing this:\n  fst \\<epsilon>k' \\<le> fst \\<epsilon>k\n\ngoal (1 subgoal):\n 1. F (snd \\<epsilon>k) + F (fst \\<epsilon>k')\n    \\<le> F (snd \\<epsilon>k) + F (fst \\<epsilon>k)", "by(intro add_left_mono mono)(clarsimp simp add: le_fun_def)"], ["proof (state)\nthis:\n  F (snd \\<epsilon>k) + F (fst \\<epsilon>k')\n  \\<le> F (snd \\<epsilon>k) + F (fst \\<epsilon>k)\n\ngoal (1 subgoal):\n 1. (\\<epsilon>k', \\<epsilon>k) \\<in> leq \\<Longrightarrow>\n    \\<exists>\\<epsilon>k''\\<in>M.\n       F (snd \\<epsilon>k) + F (fst \\<epsilon>k')\n       \\<le> F (snd \\<epsilon>k'') + F (fst \\<epsilon>k'')", "with that"], ["proof (chain)\npicking this:\n  (\\<And>z. ?f z \\<le> ?g z) \\<Longrightarrow> F ?f \\<le> F ?g\n  \\<epsilon>k \\<in> M\n  \\<epsilon>k' \\<in> M\n  F (snd \\<epsilon>k) + F (fst \\<epsilon>k')\n  \\<le> F (snd \\<epsilon>k) + F (fst \\<epsilon>k)", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<And>z. ?f z \\<le> ?g z) \\<Longrightarrow> F ?f \\<le> F ?g\n  \\<epsilon>k \\<in> M\n  \\<epsilon>k' \\<in> M\n  F (snd \\<epsilon>k) + F (fst \\<epsilon>k')\n  \\<le> F (snd \\<epsilon>k) + F (fst \\<epsilon>k)\n\ngoal (1 subgoal):\n 1. \\<exists>\\<epsilon>k''\\<in>M.\n       F (snd \\<epsilon>k) + F (fst \\<epsilon>k')\n       \\<le> F (snd \\<epsilon>k'') + F (fst \\<epsilon>k'')", "by blast"], ["proof (state)\nthis:\n  \\<exists>\\<epsilon>k''\\<in>M.\n     F (snd \\<epsilon>k) + F (fst \\<epsilon>k')\n     \\<le> F (snd \\<epsilon>k'') + F (fst \\<epsilon>k'')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>\\<And>f g.\n              (\\<And>z. f z \\<le> g z) \\<Longrightarrow> ?F f \\<le> ?F g;\n   ?\\<epsilon>k \\<in> M; ?\\<epsilon>k' \\<in> M\\<rbrakk>\n  \\<Longrightarrow> \\<exists>\\<epsilon>k''\\<in>M.\n                       ?F (snd ?\\<epsilon>k) + ?F (fst ?\\<epsilon>k')\n                       \\<le> ?F (snd \\<epsilon>k'') + ?F (fst \\<epsilon>k'')\n\ngoal (3 subgoals):\n 1. current (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)) (\\<Squnion> (snd ` M))\n 2. wave (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)) (\\<Squnion> (snd ` M))\n 3. \\<not> hindered\n            (\\<Gamma> \\<ominus>\n             F (\\<Squnion> (fst ` M), \\<Squnion> (snd ` M)))", "have directed_OUT: \"\\<exists>\\<epsilon>k''\\<in>M. d_OUT (snd \\<epsilon>k) x + d_OUT (fst \\<epsilon>k') x \\<le> d_OUT (snd \\<epsilon>k'') x + d_OUT (fst \\<epsilon>k'') x\"\n      if \"\\<epsilon>k \\<in> M\" \"\\<epsilon>k' \\<in> M\" for x \\<epsilon>k \\<epsilon>k'"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>\\<epsilon>k''\\<in>M.\n       d_OUT (snd \\<epsilon>k) x + d_OUT (fst \\<epsilon>k') x\n       \\<le> d_OUT (snd \\<epsilon>k'') x + d_OUT (fst \\<epsilon>k'') x", "by(rule directed; rule d_OUT_mono that)"], ["proof (state)\nthis:\n  \\<lbrakk>?\\<epsilon>k \\<in> M; ?\\<epsilon>k' \\<in> M\\<rbrakk>\n  \\<Longrightarrow> \\<exists>\\<epsilon>k''\\<in>M.\n                       d_OUT (snd ?\\<epsilon>k) ?x +\n                       d_OUT (fst ?\\<epsilon>k') ?x\n                       \\<le> d_OUT (snd \\<epsilon>k'') ?x +\n                             d_OUT (fst \\<epsilon>k'') ?x\n\ngoal (3 subgoals):\n 1. current (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)) (\\<Squnion> (snd ` M))\n 2. wave (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)) (\\<Squnion> (snd ` M))\n 3. \\<not> hindered\n            (\\<Gamma> \\<ominus>\n             F (\\<Squnion> (fst ` M), \\<Squnion> (snd ` M)))", "have directed_IN: \"\\<exists>\\<epsilon>k''\\<in>M. d_IN (snd \\<epsilon>k) x + d_IN (fst \\<epsilon>k') x \\<le> d_IN (snd \\<epsilon>k'') x + d_IN (fst \\<epsilon>k'') x\"\n      if \"\\<epsilon>k \\<in> M\" \"\\<epsilon>k' \\<in> M\" for x \\<epsilon>k \\<epsilon>k'"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>\\<epsilon>k''\\<in>M.\n       d_IN (snd \\<epsilon>k) x + d_IN (fst \\<epsilon>k') x\n       \\<le> d_IN (snd \\<epsilon>k'') x + d_IN (fst \\<epsilon>k'') x", "by(rule directed; rule d_IN_mono that)"], ["proof (state)\nthis:\n  \\<lbrakk>?\\<epsilon>k \\<in> M; ?\\<epsilon>k' \\<in> M\\<rbrakk>\n  \\<Longrightarrow> \\<exists>\\<epsilon>k''\\<in>M.\n                       d_IN (snd ?\\<epsilon>k) ?x +\n                       d_IN (fst ?\\<epsilon>k') ?x\n                       \\<le> d_IN (snd \\<epsilon>k'') ?x +\n                             d_IN (fst \\<epsilon>k'') ?x\n\ngoal (3 subgoals):\n 1. current (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)) (\\<Squnion> (snd ` M))\n 2. wave (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)) (\\<Squnion> (snd ` M))\n 3. \\<not> hindered\n            (\\<Gamma> \\<ominus>\n             F (\\<Squnion> (fst ` M), \\<Squnion> (snd ` M)))", "let ?\\<Gamma> = \"\\<Gamma> \\<ominus> Sup (fst ` M)\""], ["proof (state)\ngoal (3 subgoals):\n 1. current (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)) (\\<Squnion> (snd ` M))\n 2. wave (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)) (\\<Squnion> (snd ` M))\n 3. \\<not> hindered\n            (\\<Gamma> \\<ominus>\n             F (\\<Squnion> (fst ` M), \\<Squnion> (snd ` M)))", "have hM2: \"current ?\\<Gamma> h\" if \\<epsilon>h: \"(\\<epsilon>, h) \\<in> M\" for \\<epsilon> h"], ["proof (prove)\ngoal (1 subgoal):\n 1. current (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)) h", "proof"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x.\n       d_OUT h x \\<le> weight (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)) x\n 2. \\<And>x.\n       d_IN h x \\<le> weight (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)) x\n 3. \\<And>e.\n       e \\<notin> \\<^bold>E\\<^bsub>\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)\\<^esub> \\<Longrightarrow>\n       h e = 0", "from \\<epsilon>h"], ["proof (chain)\npicking this:\n  (\\<epsilon>, h) \\<in> M", "have Field: \"(\\<epsilon>, h) \\<in> Field leq\""], ["proof (prove)\nusing this:\n  (\\<epsilon>, h) \\<in> M\n\ngoal (1 subgoal):\n 1. (\\<epsilon>, h) \\<in> Field leq", "by(rule Chains_FieldD[OF M])"], ["proof (state)\nthis:\n  (\\<epsilon>, h) \\<in> Field leq\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       d_OUT h x \\<le> weight (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)) x\n 2. \\<And>x.\n       d_IN h x \\<le> weight (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)) x\n 3. \\<And>e.\n       e \\<notin> \\<^bold>E\\<^bsub>\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)\\<^esub> \\<Longrightarrow>\n       h e = 0", "then"], ["proof (chain)\npicking this:\n  (\\<epsilon>, h) \\<in> Field leq", "have H: \"current (\\<Gamma> \\<ominus> \\<epsilon>) h\" and \\<epsilon>_curr': \"current \\<Gamma> \\<epsilon>\""], ["proof (prove)\nusing this:\n  (\\<epsilon>, h) \\<in> Field leq\n\ngoal (1 subgoal):\n 1. current (\\<Gamma> \\<ominus> \\<epsilon>) h &&&\n    current \\<Gamma> \\<epsilon>", "by(rule h \\<epsilon>_curr)+"], ["proof (state)\nthis:\n  current (\\<Gamma> \\<ominus> \\<epsilon>) h\n  current \\<Gamma> \\<epsilon>\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       d_OUT h x \\<le> weight (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)) x\n 2. \\<And>x.\n       d_IN h x \\<le> weight (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)) x\n 3. \\<And>e.\n       e \\<notin> \\<^bold>E\\<^bsub>\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)\\<^esub> \\<Longrightarrow>\n       h e = 0", "from \\<epsilon>_curr'"], ["proof (chain)\npicking this:\n  current \\<Gamma> \\<epsilon>", "interpret \\<Gamma>: countable_bipartite_web \"\\<Gamma> \\<ominus> \\<epsilon>\""], ["proof (prove)\nusing this:\n  current \\<Gamma> \\<epsilon>\n\ngoal (1 subgoal):\n 1. countable_bipartite_web (\\<Gamma> \\<ominus> \\<epsilon>)", "by(rule countable_bipartite_web_minus_web)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x.\n       d_OUT h x \\<le> weight (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)) x\n 2. \\<And>x.\n       d_IN h x \\<le> weight (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)) x\n 3. \\<And>e.\n       e \\<notin> \\<^bold>E\\<^bsub>\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)\\<^esub> \\<Longrightarrow>\n       h e = 0", "fix x"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x.\n       d_OUT h x \\<le> weight (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)) x\n 2. \\<And>x.\n       d_IN h x \\<le> weight (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)) x\n 3. \\<And>e.\n       e \\<notin> \\<^bold>E\\<^bsub>\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)\\<^esub> \\<Longrightarrow>\n       h e = 0", "have \"d_OUT h x \\<le> d_OUT ?h x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT h x \\<le> d_OUT (\\<Squnion> (snd ` M)) x", "using \\<epsilon>h"], ["proof (prove)\nusing this:\n  (\\<epsilon>, h) \\<in> M\n\ngoal (1 subgoal):\n 1. d_OUT h x \\<le> d_OUT (\\<Squnion> (snd ` M)) x", "by(intro d_OUT_mono)(auto intro: SUP_upper2)"], ["proof (state)\nthis:\n  d_OUT h x \\<le> d_OUT (\\<Squnion> (snd ` M)) x\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       d_OUT h x \\<le> weight (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)) x\n 2. \\<And>x.\n       d_IN h x \\<le> weight (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)) x\n 3. \\<And>e.\n       e \\<notin> \\<^bold>E\\<^bsub>\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)\\<^esub> \\<Longrightarrow>\n       h e = 0", "also"], ["proof (state)\nthis:\n  d_OUT h x \\<le> d_OUT (\\<Squnion> (snd ` M)) x\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       d_OUT h x \\<le> weight (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)) x\n 2. \\<And>x.\n       d_IN h x \\<le> weight (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)) x\n 3. \\<And>e.\n       e \\<notin> \\<^bold>E\\<^bsub>\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)\\<^esub> \\<Longrightarrow>\n       h e = 0", "have OUT: \"\\<dots> = (SUP h\\<in>snd ` M. d_OUT h x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT (\\<Squnion> (snd ` M)) x = (\\<Squnion>h\\<in>snd ` M. d_OUT h x)", "using chain2 _ supp_flow2"], ["proof (prove)\nusing this:\n  Complete_Partial_Order.chain (\\<le>) (snd ` M)\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  countable (support_flow (\\<Squnion> (snd ` M)))\n\ngoal (1 subgoal):\n 1. d_OUT (\\<Squnion> (snd ` M)) x = (\\<Squnion>h\\<in>snd ` M. d_OUT h x)", "by(rule d_OUT_Sup)(simp_all add: nempty)"], ["proof (state)\nthis:\n  d_OUT (\\<Squnion> (snd ` M)) x = (\\<Squnion>h\\<in>snd ` M. d_OUT h x)\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       d_OUT h x \\<le> weight (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)) x\n 2. \\<And>x.\n       d_IN h x \\<le> weight (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)) x\n 3. \\<And>e.\n       e \\<notin> \\<^bold>E\\<^bsub>\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)\\<^esub> \\<Longrightarrow>\n       h e = 0", "also"], ["proof (state)\nthis:\n  d_OUT (\\<Squnion> (snd ` M)) x = (\\<Squnion>h\\<in>snd ` M. d_OUT h x)\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       d_OUT h x \\<le> weight (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)) x\n 2. \\<And>x.\n       d_IN h x \\<le> weight (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)) x\n 3. \\<And>e.\n       e \\<notin> \\<^bold>E\\<^bsub>\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)\\<^esub> \\<Longrightarrow>\n       h e = 0", "have \"\\<dots> = \\<dots> + (SUP \\<epsilon>\\<in>fst ` M. d_OUT \\<epsilon> x) - (SUP \\<epsilon>\\<in>fst ` M. d_OUT \\<epsilon> x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Squnion>h\\<in>snd ` M. d_OUT h x) =\n    (\\<Squnion>h\\<in>snd ` M. d_OUT h x) +\n    (\\<Squnion>\\<epsilon>\\<in>fst ` M. d_OUT \\<epsilon> x) -\n    (\\<Squnion>\\<epsilon>\\<in>fst ` M. d_OUT \\<epsilon> x)", "using OUT1_le[of x]"], ["proof (prove)\nusing this:\n  (\\<Squnion>\\<epsilon>h\\<in>M. d_OUT (fst \\<epsilon>h) x)\n  \\<le> weight \\<Gamma> x\n\ngoal (1 subgoal):\n 1. (\\<Squnion>h\\<in>snd ` M. d_OUT h x) =\n    (\\<Squnion>h\\<in>snd ` M. d_OUT h x) +\n    (\\<Squnion>\\<epsilon>\\<in>fst ` M. d_OUT \\<epsilon> x) -\n    (\\<Squnion>\\<epsilon>\\<in>fst ` M. d_OUT \\<epsilon> x)", "by (intro ennreal_add_diff_cancel_right[symmetric] neq_top_trans[OF weight_finite, of _ x])\n          (simp add: image_comp)"], ["proof (state)\nthis:\n  (\\<Squnion>h\\<in>snd ` M. d_OUT h x) =\n  (\\<Squnion>h\\<in>snd ` M. d_OUT h x) +\n  (\\<Squnion>\\<epsilon>\\<in>fst ` M. d_OUT \\<epsilon> x) -\n  (\\<Squnion>\\<epsilon>\\<in>fst ` M. d_OUT \\<epsilon> x)\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       d_OUT h x \\<le> weight (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)) x\n 2. \\<And>x.\n       d_IN h x \\<le> weight (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)) x\n 3. \\<And>e.\n       e \\<notin> \\<^bold>E\\<^bsub>\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)\\<^esub> \\<Longrightarrow>\n       h e = 0", "also"], ["proof (state)\nthis:\n  (\\<Squnion>h\\<in>snd ` M. d_OUT h x) =\n  (\\<Squnion>h\\<in>snd ` M. d_OUT h x) +\n  (\\<Squnion>\\<epsilon>\\<in>fst ` M. d_OUT \\<epsilon> x) -\n  (\\<Squnion>\\<epsilon>\\<in>fst ` M. d_OUT \\<epsilon> x)\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       d_OUT h x \\<le> weight (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)) x\n 2. \\<And>x.\n       d_IN h x \\<le> weight (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)) x\n 3. \\<And>e.\n       e \\<notin> \\<^bold>E\\<^bsub>\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)\\<^esub> \\<Longrightarrow>\n       h e = 0", "have \"\\<dots> = (SUP (\\<epsilon>, k)\\<in>M. d_OUT k x + d_OUT \\<epsilon> x) - (SUP \\<epsilon>\\<in>fst ` M. d_OUT \\<epsilon> x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Squnion>h\\<in>snd ` M. d_OUT h x) +\n    (\\<Squnion>\\<epsilon>\\<in>fst ` M. d_OUT \\<epsilon> x) -\n    (\\<Squnion>\\<epsilon>\\<in>fst ` M. d_OUT \\<epsilon> x) =\n    (\\<Squnion>(\\<epsilon>, k)\\<in>M. d_OUT k x + d_OUT \\<epsilon> x) -\n    (\\<Squnion>\\<epsilon>\\<in>fst ` M. d_OUT \\<epsilon> x)", "unfolding split_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Squnion>h\\<in>snd ` M. d_OUT h x) +\n    (\\<Squnion>\\<epsilon>\\<in>fst ` M. d_OUT \\<epsilon> x) -\n    (\\<Squnion>\\<epsilon>\\<in>fst ` M. d_OUT \\<epsilon> x) =\n    (\\<Squnion>p\\<in>M. d_OUT (snd p) x + d_OUT (fst p) x) -\n    (\\<Squnion>\\<epsilon>\\<in>fst ` M. d_OUT \\<epsilon> x)", "by (subst SUP_add_directed_ennreal[OF directed_OUT])\n          (simp_all add: image_comp)"], ["proof (state)\nthis:\n  (\\<Squnion>h\\<in>snd ` M. d_OUT h x) +\n  (\\<Squnion>\\<epsilon>\\<in>fst ` M. d_OUT \\<epsilon> x) -\n  (\\<Squnion>\\<epsilon>\\<in>fst ` M. d_OUT \\<epsilon> x) =\n  (\\<Squnion>(\\<epsilon>, k)\\<in>M. d_OUT k x + d_OUT \\<epsilon> x) -\n  (\\<Squnion>\\<epsilon>\\<in>fst ` M. d_OUT \\<epsilon> x)\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       d_OUT h x \\<le> weight (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)) x\n 2. \\<And>x.\n       d_IN h x \\<le> weight (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)) x\n 3. \\<And>e.\n       e \\<notin> \\<^bold>E\\<^bsub>\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)\\<^esub> \\<Longrightarrow>\n       h e = 0", "also"], ["proof (state)\nthis:\n  (\\<Squnion>h\\<in>snd ` M. d_OUT h x) +\n  (\\<Squnion>\\<epsilon>\\<in>fst ` M. d_OUT \\<epsilon> x) -\n  (\\<Squnion>\\<epsilon>\\<in>fst ` M. d_OUT \\<epsilon> x) =\n  (\\<Squnion>(\\<epsilon>, k)\\<in>M. d_OUT k x + d_OUT \\<epsilon> x) -\n  (\\<Squnion>\\<epsilon>\\<in>fst ` M. d_OUT \\<epsilon> x)\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       d_OUT h x \\<le> weight (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)) x\n 2. \\<And>x.\n       d_IN h x \\<le> weight (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)) x\n 3. \\<And>e.\n       e \\<notin> \\<^bold>E\\<^bsub>\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)\\<^esub> \\<Longrightarrow>\n       h e = 0", "have \"(SUP (\\<epsilon>, k)\\<in>M. d_OUT k x + d_OUT \\<epsilon> x) \\<le> weight \\<Gamma> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Squnion>(\\<epsilon>, k)\\<in>M. d_OUT k x + d_OUT \\<epsilon> x)\n    \\<le> weight \\<Gamma> x", "apply(clarsimp dest!: Chains_FieldD[OF M] intro!: SUP_least)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) \\<in> Field leq \\<Longrightarrow>\n       d_OUT b x + d_OUT a x \\<le> weight \\<Gamma> x", "subgoal premises that for \\<epsilon> h"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT h x + d_OUT \\<epsilon> x \\<le> weight \\<Gamma> x", "using currentD_weight_OUT[OF h[OF that], of x] currentD_weight_OUT[OF \\<epsilon>_curr[OF that], of x]\n             countable_bipartite_web_minus_web[OF \\<epsilon>_curr, THEN countable_bipartite_web.currentD_OUT', OF that h[OF that], where x=x]"], ["proof (prove)\nusing this:\n  d_OUT h x \\<le> weight (\\<Gamma> \\<ominus> \\<epsilon>) x\n  d_OUT \\<epsilon> x \\<le> weight \\<Gamma> x\n  x \\<notin> A (\\<Gamma> \\<ominus> \\<epsilon>) \\<Longrightarrow>\n  d_OUT h x = 0\n\ngoal (1 subgoal):\n 1. d_OUT h x + d_OUT \\<epsilon> x \\<le> weight \\<Gamma> x", "by (auto simp add: ennreal_le_minus_iff split: if_split_asm)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (\\<Squnion>(\\<epsilon>, k)\\<in>M. d_OUT k x + d_OUT \\<epsilon> x)\n  \\<le> weight \\<Gamma> x\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       d_OUT h x \\<le> weight (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)) x\n 2. \\<And>x.\n       d_IN h x \\<le> weight (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)) x\n 3. \\<And>e.\n       e \\<notin> \\<^bold>E\\<^bsub>\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)\\<^esub> \\<Longrightarrow>\n       h e = 0", "also"], ["proof (state)\nthis:\n  (\\<Squnion>(\\<epsilon>, k)\\<in>M. d_OUT k x + d_OUT \\<epsilon> x)\n  \\<le> weight \\<Gamma> x\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       d_OUT h x \\<le> weight (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)) x\n 2. \\<And>x.\n       d_IN h x \\<le> weight (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)) x\n 3. \\<And>e.\n       e \\<notin> \\<^bold>E\\<^bsub>\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)\\<^esub> \\<Longrightarrow>\n       h e = 0", "have \"(SUP \\<epsilon>\\<in>fst ` M. d_OUT \\<epsilon> x) = d_OUT (Sup (fst ` M)) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Squnion>\\<epsilon>\\<in>fst ` M. d_OUT \\<epsilon> x) =\n    d_OUT (\\<Squnion> (fst ` M)) x", "using OUT1"], ["proof (prove)\nusing this:\n  d_OUT (\\<Squnion> (fst ` M)) ?x =\n  (\\<Squnion>(\\<epsilon>, h)\\<in>M. d_OUT \\<epsilon> ?x)\n\ngoal (1 subgoal):\n 1. (\\<Squnion>\\<epsilon>\\<in>fst ` M. d_OUT \\<epsilon> x) =\n    d_OUT (\\<Squnion> (fst ` M)) x", "by (simp add: split_beta image_comp)"], ["proof (state)\nthis:\n  (\\<Squnion>\\<epsilon>\\<in>fst ` M. d_OUT \\<epsilon> x) =\n  d_OUT (\\<Squnion> (fst ` M)) x\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       d_OUT h x \\<le> weight (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)) x\n 2. \\<And>x.\n       d_IN h x \\<le> weight (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)) x\n 3. \\<And>e.\n       e \\<notin> \\<^bold>E\\<^bsub>\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)\\<^esub> \\<Longrightarrow>\n       h e = 0", "finally"], ["proof (chain)\npicking this:\n  (\\<And>xa y.\n      xa \\<le> y \\<Longrightarrow>\n      xa - (\\<Squnion>\\<epsilon>\\<in>fst ` M. d_OUT \\<epsilon> x)\n      \\<le> y -\n            (\\<Squnion>\\<epsilon>\\<in>fst ` M.\n                d_OUT \\<epsilon> x)) \\<Longrightarrow>\n  d_OUT h x \\<le> weight \\<Gamma> x - d_OUT (\\<Squnion> (fst ` M)) x", "show \"d_OUT h x \\<le> weight ?\\<Gamma> x\""], ["proof (prove)\nusing this:\n  (\\<And>xa y.\n      xa \\<le> y \\<Longrightarrow>\n      xa - (\\<Squnion>\\<epsilon>\\<in>fst ` M. d_OUT \\<epsilon> x)\n      \\<le> y -\n            (\\<Squnion>\\<epsilon>\\<in>fst ` M.\n                d_OUT \\<epsilon> x)) \\<Longrightarrow>\n  d_OUT h x \\<le> weight \\<Gamma> x - d_OUT (\\<Squnion> (fst ` M)) x\n\ngoal (1 subgoal):\n 1. d_OUT h x \\<le> weight (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)) x", "using \\<Gamma>.currentD_OUT'[OF h[OF Field], of x] currentD_weight_IN[OF SM1, of x]"], ["proof (prove)\nusing this:\n  (\\<And>xa y.\n      xa \\<le> y \\<Longrightarrow>\n      xa - (\\<Squnion>\\<epsilon>\\<in>fst ` M. d_OUT \\<epsilon> x)\n      \\<le> y -\n            (\\<Squnion>\\<epsilon>\\<in>fst ` M.\n                d_OUT \\<epsilon> x)) \\<Longrightarrow>\n  d_OUT h x \\<le> weight \\<Gamma> x - d_OUT (\\<Squnion> (fst ` M)) x\n  x \\<notin> A (\\<Gamma> \\<ominus> \\<epsilon>) \\<Longrightarrow>\n  d_OUT h x = 0\n  d_IN (\\<Squnion> (fst ` M)) x \\<le> weight \\<Gamma> x\n\ngoal (1 subgoal):\n 1. d_OUT h x \\<le> weight (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)) x", "by(auto simp add: ennreal_minus_mono)"], ["proof (state)\nthis:\n  d_OUT h x \\<le> weight (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)) x\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       d_IN h x \\<le> weight (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)) x\n 2. \\<And>e.\n       e \\<notin> \\<^bold>E\\<^bsub>\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)\\<^esub> \\<Longrightarrow>\n       h e = 0", "have \"d_IN h x \\<le> d_IN ?h x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN h x \\<le> d_IN (\\<Squnion> (snd ` M)) x", "using \\<epsilon>h"], ["proof (prove)\nusing this:\n  (\\<epsilon>, h) \\<in> M\n\ngoal (1 subgoal):\n 1. d_IN h x \\<le> d_IN (\\<Squnion> (snd ` M)) x", "by(intro d_IN_mono)(auto intro: SUP_upper2)"], ["proof (state)\nthis:\n  d_IN h x \\<le> d_IN (\\<Squnion> (snd ` M)) x\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       d_IN h x \\<le> weight (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)) x\n 2. \\<And>e.\n       e \\<notin> \\<^bold>E\\<^bsub>\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)\\<^esub> \\<Longrightarrow>\n       h e = 0", "also"], ["proof (state)\nthis:\n  d_IN h x \\<le> d_IN (\\<Squnion> (snd ` M)) x\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       d_IN h x \\<le> weight (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)) x\n 2. \\<And>e.\n       e \\<notin> \\<^bold>E\\<^bsub>\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)\\<^esub> \\<Longrightarrow>\n       h e = 0", "have IN: \"\\<dots> = (SUP h\\<in>snd ` M. d_IN h x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN (\\<Squnion> (snd ` M)) x = (\\<Squnion>h\\<in>snd ` M. d_IN h x)", "using chain2 _ supp_flow2"], ["proof (prove)\nusing this:\n  Complete_Partial_Order.chain (\\<le>) (snd ` M)\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  countable (support_flow (\\<Squnion> (snd ` M)))\n\ngoal (1 subgoal):\n 1. d_IN (\\<Squnion> (snd ` M)) x = (\\<Squnion>h\\<in>snd ` M. d_IN h x)", "by(rule d_IN_Sup)(simp_all add: nempty)"], ["proof (state)\nthis:\n  d_IN (\\<Squnion> (snd ` M)) x = (\\<Squnion>h\\<in>snd ` M. d_IN h x)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       d_IN h x \\<le> weight (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)) x\n 2. \\<And>e.\n       e \\<notin> \\<^bold>E\\<^bsub>\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)\\<^esub> \\<Longrightarrow>\n       h e = 0", "also"], ["proof (state)\nthis:\n  d_IN (\\<Squnion> (snd ` M)) x = (\\<Squnion>h\\<in>snd ` M. d_IN h x)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       d_IN h x \\<le> weight (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)) x\n 2. \\<And>e.\n       e \\<notin> \\<^bold>E\\<^bsub>\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)\\<^esub> \\<Longrightarrow>\n       h e = 0", "have \"\\<dots> = \\<dots> + (SUP \\<epsilon>\\<in>fst ` M. d_IN \\<epsilon> x) - (SUP \\<epsilon>\\<in>fst ` M. d_IN \\<epsilon> x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Squnion>h\\<in>snd ` M. d_IN h x) =\n    (\\<Squnion>h\\<in>snd ` M. d_IN h x) +\n    (\\<Squnion>\\<epsilon>\\<in>fst ` M. d_IN \\<epsilon> x) -\n    (\\<Squnion>\\<epsilon>\\<in>fst ` M. d_IN \\<epsilon> x)", "using IN1_le[of x]"], ["proof (prove)\nusing this:\n  (\\<Squnion>\\<epsilon>h\\<in>M. d_IN (fst \\<epsilon>h) x)\n  \\<le> weight \\<Gamma> x\n\ngoal (1 subgoal):\n 1. (\\<Squnion>h\\<in>snd ` M. d_IN h x) =\n    (\\<Squnion>h\\<in>snd ` M. d_IN h x) +\n    (\\<Squnion>\\<epsilon>\\<in>fst ` M. d_IN \\<epsilon> x) -\n    (\\<Squnion>\\<epsilon>\\<in>fst ` M. d_IN \\<epsilon> x)", "by (intro ennreal_add_diff_cancel_right [symmetric] neq_top_trans [OF weight_finite, of _ x])\n          (simp add: image_comp)"], ["proof (state)\nthis:\n  (\\<Squnion>h\\<in>snd ` M. d_IN h x) =\n  (\\<Squnion>h\\<in>snd ` M. d_IN h x) +\n  (\\<Squnion>\\<epsilon>\\<in>fst ` M. d_IN \\<epsilon> x) -\n  (\\<Squnion>\\<epsilon>\\<in>fst ` M. d_IN \\<epsilon> x)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       d_IN h x \\<le> weight (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)) x\n 2. \\<And>e.\n       e \\<notin> \\<^bold>E\\<^bsub>\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)\\<^esub> \\<Longrightarrow>\n       h e = 0", "also"], ["proof (state)\nthis:\n  (\\<Squnion>h\\<in>snd ` M. d_IN h x) =\n  (\\<Squnion>h\\<in>snd ` M. d_IN h x) +\n  (\\<Squnion>\\<epsilon>\\<in>fst ` M. d_IN \\<epsilon> x) -\n  (\\<Squnion>\\<epsilon>\\<in>fst ` M. d_IN \\<epsilon> x)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       d_IN h x \\<le> weight (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)) x\n 2. \\<And>e.\n       e \\<notin> \\<^bold>E\\<^bsub>\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)\\<^esub> \\<Longrightarrow>\n       h e = 0", "have \"\\<dots> = (SUP (\\<epsilon>, k)\\<in>M. d_IN k x + d_IN \\<epsilon> x) - (SUP \\<epsilon>\\<in>fst ` M. d_IN \\<epsilon> x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Squnion>h\\<in>snd ` M. d_IN h x) +\n    (\\<Squnion>\\<epsilon>\\<in>fst ` M. d_IN \\<epsilon> x) -\n    (\\<Squnion>\\<epsilon>\\<in>fst ` M. d_IN \\<epsilon> x) =\n    (\\<Squnion>(\\<epsilon>, k)\\<in>M. d_IN k x + d_IN \\<epsilon> x) -\n    (\\<Squnion>\\<epsilon>\\<in>fst ` M. d_IN \\<epsilon> x)", "unfolding split_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Squnion>h\\<in>snd ` M. d_IN h x) +\n    (\\<Squnion>\\<epsilon>\\<in>fst ` M. d_IN \\<epsilon> x) -\n    (\\<Squnion>\\<epsilon>\\<in>fst ` M. d_IN \\<epsilon> x) =\n    (\\<Squnion>p\\<in>M. d_IN (snd p) x + d_IN (fst p) x) -\n    (\\<Squnion>\\<epsilon>\\<in>fst ` M. d_IN \\<epsilon> x)", "by (subst SUP_add_directed_ennreal [OF directed_IN])\n          (simp_all add: image_comp)"], ["proof (state)\nthis:\n  (\\<Squnion>h\\<in>snd ` M. d_IN h x) +\n  (\\<Squnion>\\<epsilon>\\<in>fst ` M. d_IN \\<epsilon> x) -\n  (\\<Squnion>\\<epsilon>\\<in>fst ` M. d_IN \\<epsilon> x) =\n  (\\<Squnion>(\\<epsilon>, k)\\<in>M. d_IN k x + d_IN \\<epsilon> x) -\n  (\\<Squnion>\\<epsilon>\\<in>fst ` M. d_IN \\<epsilon> x)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       d_IN h x \\<le> weight (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)) x\n 2. \\<And>e.\n       e \\<notin> \\<^bold>E\\<^bsub>\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)\\<^esub> \\<Longrightarrow>\n       h e = 0", "also"], ["proof (state)\nthis:\n  (\\<Squnion>h\\<in>snd ` M. d_IN h x) +\n  (\\<Squnion>\\<epsilon>\\<in>fst ` M. d_IN \\<epsilon> x) -\n  (\\<Squnion>\\<epsilon>\\<in>fst ` M. d_IN \\<epsilon> x) =\n  (\\<Squnion>(\\<epsilon>, k)\\<in>M. d_IN k x + d_IN \\<epsilon> x) -\n  (\\<Squnion>\\<epsilon>\\<in>fst ` M. d_IN \\<epsilon> x)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       d_IN h x \\<le> weight (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)) x\n 2. \\<And>e.\n       e \\<notin> \\<^bold>E\\<^bsub>\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)\\<^esub> \\<Longrightarrow>\n       h e = 0", "have \"(SUP (\\<epsilon>, k)\\<in>M. d_IN k x + d_IN \\<epsilon> x) \\<le> weight \\<Gamma> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Squnion>(\\<epsilon>, k)\\<in>M. d_IN k x + d_IN \\<epsilon> x)\n    \\<le> weight \\<Gamma> x", "apply(clarsimp dest!: Chains_FieldD[OF M] intro!: SUP_least)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) \\<in> Field leq \\<Longrightarrow>\n       d_IN b x + d_IN a x \\<le> weight \\<Gamma> x", "subgoal premises that for \\<epsilon> h"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN h x + d_IN \\<epsilon> x \\<le> weight \\<Gamma> x", "using currentD_weight_OUT[OF h, OF that, where x=x] currentD_weight_IN[OF h, OF that, where x=x]\n            countable_bipartite_web_minus_web[OF \\<epsilon>_curr, THEN countable_bipartite_web.currentD_OUT', OF that h[OF that], where x=x]\n            currentD_OUT'[OF \\<epsilon>_curr, OF that, where x=x] currentD_IN[OF \\<epsilon>_curr, OF that, of x] currentD_weight_IN[OF \\<epsilon>_curr, OF that, where x=x]"], ["proof (prove)\nusing this:\n  d_OUT h x \\<le> weight (\\<Gamma> \\<ominus> \\<epsilon>) x\n  d_IN h x \\<le> weight (\\<Gamma> \\<ominus> \\<epsilon>) x\n  x \\<notin> A (\\<Gamma> \\<ominus> \\<epsilon>) \\<Longrightarrow>\n  d_OUT h x = 0\n  x \\<notin> A \\<Gamma> \\<Longrightarrow> d_OUT \\<epsilon> x = 0\n  x \\<in> A \\<Gamma> \\<Longrightarrow> d_IN \\<epsilon> x = 0\n  d_IN \\<epsilon> x \\<le> weight \\<Gamma> x\n\ngoal (1 subgoal):\n 1. d_IN h x + d_IN \\<epsilon> x \\<le> weight \\<Gamma> x", "by (auto simp add: ennreal_le_minus_iff image_comp\n                     split: if_split_asm intro: add_increasing2 order_trans [rotated])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (\\<Squnion>(\\<epsilon>, k)\\<in>M. d_IN k x + d_IN \\<epsilon> x)\n  \\<le> weight \\<Gamma> x\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       d_IN h x \\<le> weight (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)) x\n 2. \\<And>e.\n       e \\<notin> \\<^bold>E\\<^bsub>\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)\\<^esub> \\<Longrightarrow>\n       h e = 0", "also"], ["proof (state)\nthis:\n  (\\<Squnion>(\\<epsilon>, k)\\<in>M. d_IN k x + d_IN \\<epsilon> x)\n  \\<le> weight \\<Gamma> x\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       d_IN h x \\<le> weight (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)) x\n 2. \\<And>e.\n       e \\<notin> \\<^bold>E\\<^bsub>\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)\\<^esub> \\<Longrightarrow>\n       h e = 0", "have \"(SUP \\<epsilon>\\<in>fst ` M. d_IN \\<epsilon> x) = d_IN (Sup (fst ` M)) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Squnion>\\<epsilon>\\<in>fst ` M. d_IN \\<epsilon> x) =\n    d_IN (\\<Squnion> (fst ` M)) x", "using IN1"], ["proof (prove)\nusing this:\n  d_IN (\\<Squnion> (fst ` M)) ?x =\n  (\\<Squnion>(\\<epsilon>, h)\\<in>M. d_IN \\<epsilon> ?x)\n\ngoal (1 subgoal):\n 1. (\\<Squnion>\\<epsilon>\\<in>fst ` M. d_IN \\<epsilon> x) =\n    d_IN (\\<Squnion> (fst ` M)) x", "by (simp add: split_beta image_comp)"], ["proof (state)\nthis:\n  (\\<Squnion>\\<epsilon>\\<in>fst ` M. d_IN \\<epsilon> x) =\n  d_IN (\\<Squnion> (fst ` M)) x\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       d_IN h x \\<le> weight (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)) x\n 2. \\<And>e.\n       e \\<notin> \\<^bold>E\\<^bsub>\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)\\<^esub> \\<Longrightarrow>\n       h e = 0", "finally"], ["proof (chain)\npicking this:\n  (\\<And>xa y.\n      xa \\<le> y \\<Longrightarrow>\n      xa - (\\<Squnion>\\<epsilon>\\<in>fst ` M. d_IN \\<epsilon> x)\n      \\<le> y -\n            (\\<Squnion>\\<epsilon>\\<in>fst ` M.\n                d_IN \\<epsilon> x)) \\<Longrightarrow>\n  d_IN h x \\<le> weight \\<Gamma> x - d_IN (\\<Squnion> (fst ` M)) x", "show \"d_IN h x \\<le> weight ?\\<Gamma> x\""], ["proof (prove)\nusing this:\n  (\\<And>xa y.\n      xa \\<le> y \\<Longrightarrow>\n      xa - (\\<Squnion>\\<epsilon>\\<in>fst ` M. d_IN \\<epsilon> x)\n      \\<le> y -\n            (\\<Squnion>\\<epsilon>\\<in>fst ` M.\n                d_IN \\<epsilon> x)) \\<Longrightarrow>\n  d_IN h x \\<le> weight \\<Gamma> x - d_IN (\\<Squnion> (fst ` M)) x\n\ngoal (1 subgoal):\n 1. d_IN h x \\<le> weight (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)) x", "using currentD_IN[OF h[OF Field], of x] currentD_weight_OUT[OF SM1, of x]"], ["proof (prove)\nusing this:\n  (\\<And>xa y.\n      xa \\<le> y \\<Longrightarrow>\n      xa - (\\<Squnion>\\<epsilon>\\<in>fst ` M. d_IN \\<epsilon> x)\n      \\<le> y -\n            (\\<Squnion>\\<epsilon>\\<in>fst ` M.\n                d_IN \\<epsilon> x)) \\<Longrightarrow>\n  d_IN h x \\<le> weight \\<Gamma> x - d_IN (\\<Squnion> (fst ` M)) x\n  x \\<in> A (\\<Gamma> \\<ominus> \\<epsilon>) \\<Longrightarrow> d_IN h x = 0\n  d_OUT (\\<Squnion> (fst ` M)) x \\<le> weight \\<Gamma> x\n\ngoal (1 subgoal):\n 1. d_IN h x \\<le> weight (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)) x", "by(auto simp add: ennreal_minus_mono)\n          (auto simp add: ennreal_le_minus_iff add_increasing2)"], ["proof (state)\nthis:\n  d_IN h x \\<le> weight (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)) x\n\ngoal (1 subgoal):\n 1. \\<And>e.\n       e \\<notin> \\<^bold>E\\<^bsub>\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)\\<^esub> \\<Longrightarrow>\n       h e = 0", "show \"h e = 0\" if \"e \\<notin> \\<^bold>E\\<^bsub>?\\<Gamma>\\<^esub>\" for e"], ["proof (prove)\ngoal (1 subgoal):\n 1. h e = 0", "using currentD_outside'[OF H, of e] that"], ["proof (prove)\nusing this:\n  e \\<notin> \\<^bold>E\\<^bsub>\\<Gamma> \\<ominus> \\<epsilon>\\<^esub> \\<Longrightarrow>\n  h e = 0\n  e \\<notin> \\<^bold>E\\<^bsub>\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)\\<^esub>\n\ngoal (1 subgoal):\n 1. h e = 0", "by simp"], ["proof (state)\nthis:\n  ?e \\<notin> \\<^bold>E\\<^bsub>\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)\\<^esub> \\<Longrightarrow>\n  h ?e = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (?\\<epsilon>, ?h) \\<in> M \\<Longrightarrow>\n  current (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)) ?h\n\ngoal (3 subgoals):\n 1. current (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)) (\\<Squnion> (snd ` M))\n 2. wave (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)) (\\<Squnion> (snd ` M))\n 3. \\<not> hindered\n            (\\<Gamma> \\<ominus>\n             F (\\<Squnion> (fst ` M), \\<Squnion> (snd ` M)))", "from nempty"], ["proof (chain)\npicking this:\n  M \\<noteq> {}", "have \"snd ` M \\<noteq> {}\""], ["proof (prove)\nusing this:\n  M \\<noteq> {}\n\ngoal (1 subgoal):\n 1. snd ` M \\<noteq> {}", "by simp"], ["proof (state)\nthis:\n  snd ` M \\<noteq> {}\n\ngoal (3 subgoals):\n 1. current (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)) (\\<Squnion> (snd ` M))\n 2. wave (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)) (\\<Squnion> (snd ` M))\n 3. \\<not> hindered\n            (\\<Gamma> \\<ominus>\n             F (\\<Squnion> (fst ` M), \\<Squnion> (snd ` M)))", "from chain2 this _ supp_flow2"], ["proof (chain)\npicking this:\n  Complete_Partial_Order.chain (\\<le>) (snd ` M)\n  snd ` M \\<noteq> {}\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  countable (support_flow (\\<Squnion> (snd ` M)))", "show current: \"current ?\\<Gamma> ?h\""], ["proof (prove)\nusing this:\n  Complete_Partial_Order.chain (\\<le>) (snd ` M)\n  snd ` M \\<noteq> {}\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  countable (support_flow (\\<Squnion> (snd ` M)))\n\ngoal (1 subgoal):\n 1. current (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)) (\\<Squnion> (snd ` M))", "by(rule current_Sup)(clarify; rule hM2; simp)"], ["proof (state)\nthis:\n  current (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)) (\\<Squnion> (snd ` M))\n\ngoal (2 subgoals):\n 1. wave (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)) (\\<Squnion> (snd ` M))\n 2. \\<not> hindered\n            (\\<Gamma> \\<ominus>\n             F (\\<Squnion> (fst ` M), \\<Squnion> (snd ` M)))", "have wM: \"wave ?\\<Gamma> h\" if \"(\\<epsilon>, h) \\<in> M\" for \\<epsilon> h"], ["proof (prove)\ngoal (1 subgoal):\n 1. wave (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)) h", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. separating (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M))\n     (TER\\<^bsub>\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)\\<^esub> h)\n 2. current (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)) h", "let ?\\<Gamma>' = \"\\<Gamma> \\<ominus> \\<epsilon>\""], ["proof (state)\ngoal (2 subgoals):\n 1. separating (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M))\n     (TER\\<^bsub>\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)\\<^esub> h)\n 2. current (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)) h", "have subset: \"TER\\<^bsub>?\\<Gamma>'\\<^esub> h \\<subseteq> TER\\<^bsub>?\\<Gamma>\\<^esub> h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. TER\\<^bsub>\\<Gamma> \\<ominus> \\<epsilon>\\<^esub> h\n    \\<subseteq> TER\\<^bsub>\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)\\<^esub> h", "using currentD_OUT'[OF SM1] currentD_OUT'[OF \\<epsilon>_curr[OF Chains_FieldD[OF M that]]] that"], ["proof (prove)\nusing this:\n  ?x \\<notin> A \\<Gamma> \\<Longrightarrow>\n  d_OUT (\\<Squnion> (fst ` M)) ?x = 0\n  ?x \\<notin> A \\<Gamma> \\<Longrightarrow> d_OUT \\<epsilon> ?x = 0\n  (\\<epsilon>, h) \\<in> M\n\ngoal (1 subgoal):\n 1. TER\\<^bsub>\\<Gamma> \\<ominus> \\<epsilon>\\<^esub> h\n    \\<subseteq> TER\\<^bsub>\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)\\<^esub> h", "by(auto 4 7 elim!: SAT.cases intro: SAT.intros elim!: order_trans[rotated] intro: ennreal_minus_mono d_IN_mono intro!: SUP_upper2 split: if_split_asm)"], ["proof (state)\nthis:\n  TER\\<^bsub>\\<Gamma> \\<ominus> \\<epsilon>\\<^esub> h\n  \\<subseteq> TER\\<^bsub>\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)\\<^esub> h\n\ngoal (2 subgoals):\n 1. separating (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M))\n     (TER\\<^bsub>\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)\\<^esub> h)\n 2. current (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)) h", "from h_w[OF Chains_FieldD[OF M], OF that]"], ["proof (chain)\npicking this:\n  wave (\\<Gamma> \\<ominus> \\<epsilon>) h", "have \"separating ?\\<Gamma>' (TER\\<^bsub>?\\<Gamma>'\\<^esub> h)\""], ["proof (prove)\nusing this:\n  wave (\\<Gamma> \\<ominus> \\<epsilon>) h\n\ngoal (1 subgoal):\n 1. separating (\\<Gamma> \\<ominus> \\<epsilon>)\n     (TER\\<^bsub>\\<Gamma> \\<ominus> \\<epsilon>\\<^esub> h)", "by(rule waveD_separating)"], ["proof (state)\nthis:\n  separating (\\<Gamma> \\<ominus> \\<epsilon>)\n   (TER\\<^bsub>\\<Gamma> \\<ominus> \\<epsilon>\\<^esub> h)\n\ngoal (2 subgoals):\n 1. separating (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M))\n     (TER\\<^bsub>\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)\\<^esub> h)\n 2. current (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)) h", "then"], ["proof (chain)\npicking this:\n  separating (\\<Gamma> \\<ominus> \\<epsilon>)\n   (TER\\<^bsub>\\<Gamma> \\<ominus> \\<epsilon>\\<^esub> h)", "show \"separating ?\\<Gamma> (TER\\<^bsub>?\\<Gamma>\\<^esub> h)\""], ["proof (prove)\nusing this:\n  separating (\\<Gamma> \\<ominus> \\<epsilon>)\n   (TER\\<^bsub>\\<Gamma> \\<ominus> \\<epsilon>\\<^esub> h)\n\ngoal (1 subgoal):\n 1. separating (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M))\n     (TER\\<^bsub>\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)\\<^esub> h)", "using subset"], ["proof (prove)\nusing this:\n  separating (\\<Gamma> \\<ominus> \\<epsilon>)\n   (TER\\<^bsub>\\<Gamma> \\<ominus> \\<epsilon>\\<^esub> h)\n  TER\\<^bsub>\\<Gamma> \\<ominus> \\<epsilon>\\<^esub> h\n  \\<subseteq> TER\\<^bsub>\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)\\<^esub> h\n\ngoal (1 subgoal):\n 1. separating (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M))\n     (TER\\<^bsub>\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)\\<^esub> h)", "by(auto intro: separating_weakening)"], ["proof (state)\nthis:\n  separating (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M))\n   (TER\\<^bsub>\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)\\<^esub> h)\n\ngoal (1 subgoal):\n 1. current (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)) h", "qed(rule hM2[OF that])"], ["proof (state)\nthis:\n  (?\\<epsilon>, ?h) \\<in> M \\<Longrightarrow>\n  wave (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)) ?h\n\ngoal (2 subgoals):\n 1. wave (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)) (\\<Squnion> (snd ` M))\n 2. \\<not> hindered\n            (\\<Gamma> \\<ominus>\n             F (\\<Squnion> (fst ` M), \\<Squnion> (snd ` M)))", "show wave: \"wave ?\\<Gamma> ?h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wave (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)) (\\<Squnion> (snd ` M))", "using chain2 \\<open>snd ` M \\<noteq> {}\\<close> _ supp_flow2"], ["proof (prove)\nusing this:\n  Complete_Partial_Order.chain (\\<le>) (snd ` M)\n  snd ` M \\<noteq> {}\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  countable (support_flow (\\<Squnion> (snd ` M)))\n\ngoal (1 subgoal):\n 1. wave (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)) (\\<Squnion> (snd ` M))", "by(rule wave_lub)(clarify; rule wM; simp)"], ["proof (state)\nthis:\n  wave (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)) (\\<Squnion> (snd ` M))\n\ngoal (1 subgoal):\n 1. \\<not> hindered\n            (\\<Gamma> \\<ominus>\n             F (\\<Squnion> (fst ` M), \\<Squnion> (snd ` M)))", "define f where \"f = F (Sup (fst ` M), Sup (snd ` M))\""], ["proof (state)\nthis:\n  f = F (\\<Squnion> (fst ` M), \\<Squnion> (snd ` M))\n\ngoal (1 subgoal):\n 1. \\<not> hindered\n            (\\<Gamma> \\<ominus>\n             F (\\<Squnion> (fst ` M), \\<Squnion> (snd ` M)))", "have supp_flow: \"countable (support_flow f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. countable (support_flow f)", "using supp_flow1 supp_flow2 support_flow_plus_current[of \"Sup (fst ` M)\" ?h]"], ["proof (prove)\nusing this:\n  countable (support_flow (\\<Squnion> (fst ` M)))\n  countable (support_flow (\\<Squnion> (snd ` M)))\n  support_flow (plus_current (\\<Squnion> (fst ` M)) (\\<Squnion> (snd ` M)))\n  \\<subseteq> support_flow (\\<Squnion> (fst ` M)) \\<union>\n              support_flow (\\<Squnion> (snd ` M))\n\ngoal (1 subgoal):\n 1. countable (support_flow f)", "unfolding f_def F_simps"], ["proof (prove)\nusing this:\n  countable (support_flow (\\<Squnion> (fst ` M)))\n  countable (support_flow (\\<Squnion> (snd ` M)))\n  support_flow (plus_current (\\<Squnion> (fst ` M)) (\\<Squnion> (snd ` M)))\n  \\<subseteq> support_flow (\\<Squnion> (fst ` M)) \\<union>\n              support_flow (\\<Squnion> (snd ` M))\n\ngoal (1 subgoal):\n 1. countable\n     (support_flow\n       (plus_current (\\<Squnion> (fst ` M)) (\\<Squnion> (snd ` M))))", "by(blast intro: countable_subset)"], ["proof (state)\nthis:\n  countable (support_flow f)\n\ngoal (1 subgoal):\n 1. \\<not> hindered\n            (\\<Gamma> \\<ominus>\n             F (\\<Squnion> (fst ` M), \\<Squnion> (snd ` M)))", "have f_alt: \"f = Sup ((\\<lambda>(\\<epsilon>, h). plus_current \\<epsilon> h) ` M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f = (\\<Squnion>(\\<epsilon>, h)\\<in>M. plus_current \\<epsilon> h)", "apply (simp add: fun_eq_iff split_def f_def nempty F_def image_comp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a b.\n       (\\<Squnion>x\\<in>M. fst x (a, b)) +\n       (\\<Squnion>x\\<in>M. snd x (a, b)) =\n       (\\<Squnion>x\\<in>M. fst x (a, b) + snd x (a, b))", "apply (subst (1 2) add.commute)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a b.\n       (\\<Squnion>x\\<in>M. snd x (a, b)) +\n       (\\<Squnion>x\\<in>M. fst x (a, b)) =\n       (\\<Squnion>x\\<in>M. snd x (a, b) + fst x (a, b))", "apply (subst SUP_add_directed_ennreal)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>b aa i j.\n       \\<lbrakk>i \\<in> M; j \\<in> M\\<rbrakk>\n       \\<Longrightarrow> \\<exists>k\\<in>M.\n                            snd i (aa, b) + fst j (aa, b)\n                            \\<le> snd k (aa, b) + fst k (aa, b)\n 2. \\<forall>a b.\n       (\\<Squnion>x\\<in>M. snd x (a, b)) +\n       (\\<Squnion>x\\<in>M. fst x (a, b)) =\n       (\\<Squnion>i\\<in>M. snd i (a, b)) + (\\<Squnion>i\\<in>M. fst i (a, b))", "apply (rule directed)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>b aa i j f g.\n       \\<lbrakk>i \\<in> M; j \\<in> M; \\<And>z. f z \\<le> g z\\<rbrakk>\n       \\<Longrightarrow> f (aa, b) \\<le> g (aa, b)\n 2. \\<And>b aa i j.\n       \\<lbrakk>i \\<in> M; j \\<in> M\\<rbrakk> \\<Longrightarrow> i \\<in> M\n 3. \\<And>b aa i j.\n       \\<lbrakk>i \\<in> M; j \\<in> M\\<rbrakk> \\<Longrightarrow> j \\<in> M\n 4. \\<forall>a b.\n       (\\<Squnion>x\\<in>M. snd x (a, b)) +\n       (\\<Squnion>x\\<in>M. fst x (a, b)) =\n       (\\<Squnion>i\\<in>M. snd i (a, b)) + (\\<Squnion>i\\<in>M. fst i (a, b))", "apply (auto dest!: Chains_FieldD [OF M])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  f = (\\<Squnion>(\\<epsilon>, h)\\<in>M. plus_current \\<epsilon> h)\n\ngoal (1 subgoal):\n 1. \\<not> hindered\n            (\\<Gamma> \\<ominus>\n             F (\\<Squnion> (fst ` M), \\<Squnion> (snd ` M)))", "have f_curr: \"current \\<Gamma> f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. current \\<Gamma> f", "unfolding f_def F_simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. current \\<Gamma>\n     (plus_current (\\<Squnion> (fst ` M)) (\\<Squnion> (snd ` M)))", "using SM1 current"], ["proof (prove)\nusing this:\n  current \\<Gamma> (\\<Squnion> (fst ` M))\n  current (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)) (\\<Squnion> (snd ` M))\n\ngoal (1 subgoal):\n 1. current \\<Gamma>\n     (plus_current (\\<Squnion> (fst ` M)) (\\<Squnion> (snd ` M)))", "by(rule current_plus_current_minus)"], ["proof (state)\nthis:\n  current \\<Gamma> f\n\ngoal (1 subgoal):\n 1. \\<not> hindered\n            (\\<Gamma> \\<ominus>\n             F (\\<Squnion> (fst ` M), \\<Squnion> (snd ` M)))", "have IN_f: \"d_IN f x = d_IN (Sup (fst ` M)) x + d_IN (Sup (snd ` M)) x\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN f x = d_IN (\\<Squnion> (fst ` M)) x + d_IN (\\<Squnion> (snd ` M)) x", "unfolding f_def F_simps plus_current_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN (\\<lambda>e. (\\<Squnion> (fst ` M)) e + (\\<Squnion> (snd ` M)) e)\n     x =\n    d_IN (\\<Squnion> (fst ` M)) x + d_IN (\\<Squnion> (snd ` M)) x", "by(rule d_IN_add SM1 current)+"], ["proof (state)\nthis:\n  d_IN f ?x =\n  d_IN (\\<Squnion> (fst ` M)) ?x + d_IN (\\<Squnion> (snd ` M)) ?x\n\ngoal (1 subgoal):\n 1. \\<not> hindered\n            (\\<Gamma> \\<ominus>\n             F (\\<Squnion> (fst ` M), \\<Squnion> (snd ` M)))", "have OUT_f: \"d_OUT f x = d_OUT (Sup (fst ` M)) x + d_OUT (Sup (snd ` M)) x\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT f x =\n    d_OUT (\\<Squnion> (fst ` M)) x + d_OUT (\\<Squnion> (snd ` M)) x", "unfolding f_def F_simps plus_current_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT (\\<lambda>e. (\\<Squnion> (fst ` M)) e + (\\<Squnion> (snd ` M)) e)\n     x =\n    d_OUT (\\<Squnion> (fst ` M)) x + d_OUT (\\<Squnion> (snd ` M)) x", "by(rule d_OUT_add SM1 current)+"], ["proof (state)\nthis:\n  d_OUT f ?x =\n  d_OUT (\\<Squnion> (fst ` M)) ?x + d_OUT (\\<Squnion> (snd ` M)) ?x\n\ngoal (1 subgoal):\n 1. \\<not> hindered\n            (\\<Gamma> \\<ominus>\n             F (\\<Squnion> (fst ` M), \\<Squnion> (snd ` M)))", "show \"\\<not> hindered (\\<Gamma> \\<ominus> f)\" (is \"\\<not> hindered ?\\<Omega>\") \\<comment> \\<open>Assertion 6.11\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> hindered (\\<Gamma> \\<ominus> f)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. hindered (\\<Gamma> \\<ominus> f) \\<Longrightarrow> False", "assume hindered: \"hindered ?\\<Omega>\""], ["proof (state)\nthis:\n  hindered (\\<Gamma> \\<ominus> f)\n\ngoal (1 subgoal):\n 1. hindered (\\<Gamma> \\<ominus> f) \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  hindered (\\<Gamma> \\<ominus> f)", "obtain g where g: \"current ?\\<Omega> g\" and g_w: \"wave ?\\<Omega> g\" and hindrance: \"hindrance ?\\<Omega> g\""], ["proof (prove)\nusing this:\n  hindered (\\<Gamma> \\<ominus> f)\n\ngoal (1 subgoal):\n 1. (\\<And>g.\n        \\<lbrakk>current (\\<Gamma> \\<ominus> f) g;\n         wave (\\<Gamma> \\<ominus> f) g;\n         hindrance (\\<Gamma> \\<ominus> f) g\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by cases"], ["proof (state)\nthis:\n  current (\\<Gamma> \\<ominus> f) g\n  wave (\\<Gamma> \\<ominus> f) g\n  hindrance (\\<Gamma> \\<ominus> f) g\n\ngoal (1 subgoal):\n 1. hindered (\\<Gamma> \\<ominus> f) \\<Longrightarrow> False", "from hindrance"], ["proof (chain)\npicking this:\n  hindrance (\\<Gamma> \\<ominus> f) g", "obtain z where z: \"z \\<in> A \\<Gamma>\" and z\\<E>: \"z \\<notin> \\<E>\\<^bsub>?\\<Omega>\\<^esub> (TER\\<^bsub>?\\<Omega>\\<^esub> g)\"\n        and OUT_z: \"d_OUT g z < weight ?\\<Omega> z\""], ["proof (prove)\nusing this:\n  hindrance (\\<Gamma> \\<ominus> f) g\n\ngoal (1 subgoal):\n 1. (\\<And>z.\n        \\<lbrakk>z \\<in> A \\<Gamma>;\n         z \\<notin> \\<E>\\<^bsub>\\<Gamma> \\<ominus> f\\<^esub>\n                     (TER\\<^bsub>\\<Gamma> \\<ominus> f\\<^esub> g);\n         d_OUT g z < weight (\\<Gamma> \\<ominus> f) z\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by cases auto"], ["proof (state)\nthis:\n  z \\<in> A \\<Gamma>\n  z \\<notin> \\<E>\\<^bsub>\\<Gamma> \\<ominus> f\\<^esub>\n              (TER\\<^bsub>\\<Gamma> \\<ominus> f\\<^esub> g)\n  d_OUT g z < weight (\\<Gamma> \\<ominus> f) z\n\ngoal (1 subgoal):\n 1. hindered (\\<Gamma> \\<ominus> f) \\<Longrightarrow> False", "define \\<delta> where \"\\<delta> = weight ?\\<Omega> z - d_OUT g z\""], ["proof (state)\nthis:\n  \\<delta> = weight (\\<Gamma> \\<ominus> f) z - d_OUT g z\n\ngoal (1 subgoal):\n 1. hindered (\\<Gamma> \\<ominus> f) \\<Longrightarrow> False", "have \\<delta>_pos: \"\\<delta> > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < \\<delta>", "using OUT_z"], ["proof (prove)\nusing this:\n  d_OUT g z < weight (\\<Gamma> \\<ominus> f) z\n\ngoal (1 subgoal):\n 1. 0 < \\<delta>", "by(simp add: \\<delta>_def diff_gr0_ennreal del: minus_web_sel)"], ["proof (state)\nthis:\n  0 < \\<delta>\n\ngoal (1 subgoal):\n 1. hindered (\\<Gamma> \\<ominus> f) \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  0 < \\<delta>", "have \\<delta>_finite[simp]: \"\\<delta> \\<noteq> \\<top>\""], ["proof (prove)\nusing this:\n  0 < \\<delta>\n\ngoal (1 subgoal):\n 1. \\<delta> \\<noteq> \\<top>", "using z"], ["proof (prove)\nusing this:\n  0 < \\<delta>\n  z \\<in> A \\<Gamma>\n\ngoal (1 subgoal):\n 1. \\<delta> \\<noteq> \\<top>", "by(simp_all add: \\<delta>_def)"], ["proof (state)\nthis:\n  \\<delta> \\<noteq> \\<top>\n\ngoal (1 subgoal):\n 1. hindered (\\<Gamma> \\<ominus> f) \\<Longrightarrow> False", "have \"\\<exists>(\\<epsilon>, h) \\<in> M. d_OUT f a < d_OUT (plus_current \\<epsilon> h) a + \\<delta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>(\\<epsilon>, h)\\<in>M.\n       d_OUT f a < d_OUT (plus_current \\<epsilon> h) a + \\<delta>", "proof(rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>(\\<epsilon>, h)\\<in>M.\n               d_OUT f a\n               < d_OUT (plus_current \\<epsilon> h) a +\n                 \\<delta>) \\<Longrightarrow>\n    False", "assume \"\\<not> ?thesis\""], ["proof (state)\nthis:\n  \\<not> (\\<exists>(\\<epsilon>, h)\\<in>M.\n             d_OUT f a < d_OUT (plus_current \\<epsilon> h) a + \\<delta>)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>(\\<epsilon>, h)\\<in>M.\n               d_OUT f a\n               < d_OUT (plus_current \\<epsilon> h) a +\n                 \\<delta>) \\<Longrightarrow>\n    False", "hence greater: \"d_OUT (plus_current \\<epsilon> h) a + \\<delta> \\<le> d_OUT f a\" if \"(\\<epsilon>, h) \\<in> M\" for \\<epsilon> h"], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>(\\<epsilon>, h)\\<in>M.\n             d_OUT f a < d_OUT (plus_current \\<epsilon> h) a + \\<delta>)\n\ngoal (1 subgoal):\n 1. d_OUT (plus_current \\<epsilon> h) a + \\<delta> \\<le> d_OUT f a", "using that"], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>(\\<epsilon>, h)\\<in>M.\n             d_OUT f a < d_OUT (plus_current \\<epsilon> h) a + \\<delta>)\n  (\\<epsilon>, h) \\<in> M\n\ngoal (1 subgoal):\n 1. d_OUT (plus_current \\<epsilon> h) a + \\<delta> \\<le> d_OUT f a", "by auto"], ["proof (state)\nthis:\n  (?\\<epsilon>, ?h) \\<in> M \\<Longrightarrow>\n  d_OUT (plus_current ?\\<epsilon> ?h) a + \\<delta> \\<le> d_OUT f a\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>(\\<epsilon>, h)\\<in>M.\n               d_OUT f a\n               < d_OUT (plus_current \\<epsilon> h) a +\n                 \\<delta>) \\<Longrightarrow>\n    False", "have chain'': \"Complete_Partial_Order.chain (\\<le>) ((\\<lambda>(\\<epsilon>, h). plus_current \\<epsilon> h) ` M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Complete_Partial_Order.chain (\\<le>)\n     ((\\<lambda>(\\<epsilon>, h). plus_current \\<epsilon> h) ` M)", "using chain'"], ["proof (prove)\nusing this:\n  Complete_Partial_Order.chain (\\<le>) M\n\ngoal (1 subgoal):\n 1. Complete_Partial_Order.chain (\\<le>)\n     ((\\<lambda>(\\<epsilon>, h). plus_current \\<epsilon> h) ` M)", "by(rule chain_imageI)(auto simp add: le_fun_def add_mono)"], ["proof (state)\nthis:\n  Complete_Partial_Order.chain (\\<le>)\n   ((\\<lambda>(\\<epsilon>, h). plus_current \\<epsilon> h) ` M)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>(\\<epsilon>, h)\\<in>M.\n               d_OUT f a\n               < d_OUT (plus_current \\<epsilon> h) a +\n                 \\<delta>) \\<Longrightarrow>\n    False", "have \"d_OUT f a + 0 < d_OUT f a + \\<delta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT f a + 0 < d_OUT f a + \\<delta>", "using currentD_finite_OUT[OF f_curr, of a]"], ["proof (prove)\nusing this:\n  d_OUT f a \\<noteq> \\<top>\n\ngoal (1 subgoal):\n 1. d_OUT f a + 0 < d_OUT f a + \\<delta>", "by (simp add: \\<delta>_pos)"], ["proof (state)\nthis:\n  d_OUT f a + 0 < d_OUT f a + \\<delta>\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>(\\<epsilon>, h)\\<in>M.\n               d_OUT f a\n               < d_OUT (plus_current \\<epsilon> h) a +\n                 \\<delta>) \\<Longrightarrow>\n    False", "also"], ["proof (state)\nthis:\n  d_OUT f a + 0 < d_OUT f a + \\<delta>\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>(\\<epsilon>, h)\\<in>M.\n               d_OUT f a\n               < d_OUT (plus_current \\<epsilon> h) a +\n                 \\<delta>) \\<Longrightarrow>\n    False", "have \"d_OUT f a + \\<delta> = (SUP (\\<epsilon>, h)\\<in>M. d_OUT (plus_current \\<epsilon> h) a) + \\<delta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT f a + \\<delta> =\n    (\\<Squnion>(\\<epsilon>, h)\\<in>M. d_OUT (plus_current \\<epsilon> h) a) +\n    \\<delta>", "using chain'' nempty supp_flow"], ["proof (prove)\nusing this:\n  Complete_Partial_Order.chain (\\<le>)\n   ((\\<lambda>(\\<epsilon>, h). plus_current \\<epsilon> h) ` M)\n  M \\<noteq> {}\n  countable (support_flow f)\n\ngoal (1 subgoal):\n 1. d_OUT f a + \\<delta> =\n    (\\<Squnion>(\\<epsilon>, h)\\<in>M. d_OUT (plus_current \\<epsilon> h) a) +\n    \\<delta>", "unfolding f_alt"], ["proof (prove)\nusing this:\n  Complete_Partial_Order.chain (\\<le>)\n   ((\\<lambda>(\\<epsilon>, h). plus_current \\<epsilon> h) ` M)\n  M \\<noteq> {}\n  countable (support_flow (\\<Squnion>(x, y)\\<in>M. plus_current x y))\n\ngoal (1 subgoal):\n 1. d_OUT (\\<Squnion>(x, y)\\<in>M. plus_current x y) a + \\<delta> =\n    (\\<Squnion>(\\<epsilon>, h)\\<in>M. d_OUT (plus_current \\<epsilon> h) a) +\n    \\<delta>", "by (subst d_OUT_Sup)\n            (simp_all add: plus_current_def [abs_def] split_def image_comp)"], ["proof (state)\nthis:\n  d_OUT f a + \\<delta> =\n  (\\<Squnion>(\\<epsilon>, h)\\<in>M. d_OUT (plus_current \\<epsilon> h) a) +\n  \\<delta>\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>(\\<epsilon>, h)\\<in>M.\n               d_OUT f a\n               < d_OUT (plus_current \\<epsilon> h) a +\n                 \\<delta>) \\<Longrightarrow>\n    False", "also"], ["proof (state)\nthis:\n  d_OUT f a + \\<delta> =\n  (\\<Squnion>(\\<epsilon>, h)\\<in>M. d_OUT (plus_current \\<epsilon> h) a) +\n  \\<delta>\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>(\\<epsilon>, h)\\<in>M.\n               d_OUT f a\n               < d_OUT (plus_current \\<epsilon> h) a +\n                 \\<delta>) \\<Longrightarrow>\n    False", "have \"\\<dots> \\<le> d_OUT f a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Squnion>(\\<epsilon>, h)\\<in>M. d_OUT (plus_current \\<epsilon> h) a) +\n    \\<delta>\n    \\<le> d_OUT f a", "unfolding ennreal_SUP_add_left[symmetric, OF nempty]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Squnion>i\\<in>M.\n        (case i of\n         (\\<epsilon>, h) \\<Rightarrow>\n           d_OUT (plus_current \\<epsilon> h) a) +\n        \\<delta>)\n    \\<le> d_OUT f a", "proof(rule SUP_least, clarify)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa b.\n       (aa, b) \\<in> M \\<Longrightarrow>\n       d_OUT (plus_current aa b) a + \\<delta> \\<le> d_OUT f a", "show \"d_OUT (plus_current \\<epsilon> h) a + \\<delta> \\<le> d_OUT f a\" if \"(\\<epsilon>, h) \\<in> M\" for \\<epsilon> h"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT (plus_current \\<epsilon> h) a + \\<delta> \\<le> d_OUT f a", "using greater[OF that] currentD_finite_OUT[OF Chains_FieldD[OF M that, THEN f], of a]"], ["proof (prove)\nusing this:\n  d_OUT (plus_current \\<epsilon> h) a + \\<delta> \\<le> d_OUT f a\n  d_OUT (F (\\<epsilon>, h)) a \\<noteq> \\<top>\n\ngoal (1 subgoal):\n 1. d_OUT (plus_current \\<epsilon> h) a + \\<delta> \\<le> d_OUT f a", "by(auto simp add: ennreal_le_minus_iff add.commute F_def)"], ["proof (state)\nthis:\n  (?\\<epsilon>, ?h) \\<in> M \\<Longrightarrow>\n  d_OUT (plus_current ?\\<epsilon> ?h) a + \\<delta> \\<le> d_OUT f a\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Squnion>(\\<epsilon>, h)\\<in>M. d_OUT (plus_current \\<epsilon> h) a) +\n  \\<delta>\n  \\<le> d_OUT f a\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>(\\<epsilon>, h)\\<in>M.\n               d_OUT f a\n               < d_OUT (plus_current \\<epsilon> h) a +\n                 \\<delta>) \\<Longrightarrow>\n    False", "finally"], ["proof (chain)\npicking this:\n  d_OUT f a + 0 < d_OUT f a", "show False"], ["proof (prove)\nusing this:\n  d_OUT f a + 0 < d_OUT f a\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>(\\<epsilon>, h)\\<in>M.\n     d_OUT f a < d_OUT (plus_current \\<epsilon> h) a + \\<delta>\n\ngoal (1 subgoal):\n 1. hindered (\\<Gamma> \\<ominus> f) \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<exists>(\\<epsilon>, h)\\<in>M.\n     d_OUT f a < d_OUT (plus_current \\<epsilon> h) a + \\<delta>", "obtain \\<epsilon> h where hM: \"(\\<epsilon>, h) \\<in> M\" and close: \"d_OUT f a < d_OUT (plus_current \\<epsilon> h) a + \\<delta>\""], ["proof (prove)\nusing this:\n  \\<exists>(\\<epsilon>, h)\\<in>M.\n     d_OUT f a < d_OUT (plus_current \\<epsilon> h) a + \\<delta>\n\ngoal (1 subgoal):\n 1. (\\<And>\\<epsilon> h.\n        \\<lbrakk>(\\<epsilon>, h) \\<in> M;\n         d_OUT f a < d_OUT (plus_current \\<epsilon> h) a + \\<delta>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  (\\<epsilon>, h) \\<in> M\n  d_OUT f a < d_OUT (plus_current \\<epsilon> h) a + \\<delta>\n\ngoal (1 subgoal):\n 1. hindered (\\<Gamma> \\<ominus> f) \\<Longrightarrow> False", "have Field: \"(\\<epsilon>, h) \\<in> Field leq\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<epsilon>, h) \\<in> Field leq", "using hM"], ["proof (prove)\nusing this:\n  (\\<epsilon>, h) \\<in> M\n\ngoal (1 subgoal):\n 1. (\\<epsilon>, h) \\<in> Field leq", "by(rule Chains_FieldD[OF M])"], ["proof (state)\nthis:\n  (\\<epsilon>, h) \\<in> Field leq\n\ngoal (1 subgoal):\n 1. hindered (\\<Gamma> \\<ominus> f) \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  (\\<epsilon>, h) \\<in> Field leq", "have \\<epsilon>: \"current \\<Gamma> \\<epsilon>\"\n        and unhindered_h: \"\\<not> hindered (\\<Gamma> \\<ominus> F (\\<epsilon>, h))\"\n        and h_curr: \"current (\\<Gamma> \\<ominus> \\<epsilon>) h\"\n        and h_w: \"wave (\\<Gamma> \\<ominus> \\<epsilon>) h\"\n        and OUT_\\<epsilon>: \"x \\<noteq> a \\<Longrightarrow> d_OUT \\<epsilon> x = 0\" for x"], ["proof (prove)\nusing this:\n  (\\<epsilon>, h) \\<in> Field leq\n\ngoal (1 subgoal):\n 1. (current \\<Gamma> \\<epsilon> &&&\n     \\<not> hindered (\\<Gamma> \\<ominus> F (\\<epsilon>, h))) &&&\n    current (\\<Gamma> \\<ominus> \\<epsilon>) h &&&\n    wave (\\<Gamma> \\<ominus> \\<epsilon>) h &&&\n    (x \\<noteq> a \\<Longrightarrow> d_OUT \\<epsilon> x = 0)", "by(rule \\<epsilon>_curr OUT_\\<epsilon> h h_w unhindered')+"], ["proof (state)\nthis:\n  current \\<Gamma> \\<epsilon>\n  \\<not> hindered (\\<Gamma> \\<ominus> F (\\<epsilon>, h))\n  current (\\<Gamma> \\<ominus> \\<epsilon>) h\n  wave (\\<Gamma> \\<ominus> \\<epsilon>) h\n  ?x \\<noteq> a \\<Longrightarrow> d_OUT \\<epsilon> ?x = 0\n\ngoal (1 subgoal):\n 1. hindered (\\<Gamma> \\<ominus> f) \\<Longrightarrow> False", "let ?\\<epsilon>h = \"plus_current \\<epsilon> h\""], ["proof (state)\ngoal (1 subgoal):\n 1. hindered (\\<Gamma> \\<ominus> f) \\<Longrightarrow> False", "have \\<epsilon>h_curr: \"current \\<Gamma> ?\\<epsilon>h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. current \\<Gamma> (plus_current \\<epsilon> h)", "using Field"], ["proof (prove)\nusing this:\n  (\\<epsilon>, h) \\<in> Field leq\n\ngoal (1 subgoal):\n 1. current \\<Gamma> (plus_current \\<epsilon> h)", "unfolding F_simps[symmetric]"], ["proof (prove)\nusing this:\n  (\\<epsilon>, h) \\<in> Field leq\n\ngoal (1 subgoal):\n 1. current \\<Gamma> (F (\\<epsilon>, h))", "by(rule f)"], ["proof (state)\nthis:\n  current \\<Gamma> (plus_current \\<epsilon> h)\n\ngoal (1 subgoal):\n 1. hindered (\\<Gamma> \\<ominus> f) \\<Longrightarrow> False", "interpret h: countable_bipartite_web \"\\<Gamma> \\<ominus> \\<epsilon>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. countable_bipartite_web (\\<Gamma> \\<ominus> \\<epsilon>)", "using \\<epsilon>"], ["proof (prove)\nusing this:\n  current \\<Gamma> \\<epsilon>\n\ngoal (1 subgoal):\n 1. countable_bipartite_web (\\<Gamma> \\<ominus> \\<epsilon>)", "by(rule countable_bipartite_web_minus_web)"], ["proof (state)\ngoal (1 subgoal):\n 1. hindered (\\<Gamma> \\<ominus> f) \\<Longrightarrow> False", "interpret \\<epsilon>h: countable_bipartite_web \"\\<Gamma> \\<ominus> ?\\<epsilon>h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. countable_bipartite_web (\\<Gamma> \\<ominus> plus_current \\<epsilon> h)", "using \\<epsilon>h_curr"], ["proof (prove)\nusing this:\n  current \\<Gamma> (plus_current \\<epsilon> h)\n\ngoal (1 subgoal):\n 1. countable_bipartite_web (\\<Gamma> \\<ominus> plus_current \\<epsilon> h)", "by(rule countable_bipartite_web_minus_web)"], ["proof (state)\ngoal (1 subgoal):\n 1. hindered (\\<Gamma> \\<ominus> f) \\<Longrightarrow> False", "note [simp del] = minus_web_sel(2)\n        and [simp] = weight_minus_web[OF \\<epsilon>h_curr] weight_minus_web[OF SM1, simplified]"], ["proof (state)\nthis:\n  weight (?\\<Gamma> \\<ominus> ?f) ?x =\n  (if ?x \\<in> A ?\\<Gamma> then weight ?\\<Gamma> ?x - d_OUT ?f ?x\n   else weight ?\\<Gamma> ?x + d_OUT ?f ?x - d_IN ?f ?x)\n  weight (\\<Gamma> \\<ominus> plus_current \\<epsilon> h) ?x =\n  (if ?x \\<in> A \\<Gamma>\n   then weight \\<Gamma> ?x - d_OUT (plus_current \\<epsilon> h) ?x\n   else weight \\<Gamma> ?x - d_IN (plus_current \\<epsilon> h) ?x)\n  weight (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)) ?x =\n  (if ?x \\<in> A \\<Gamma>\n   then weight \\<Gamma> ?x - d_OUT (\\<Squnion> (fst ` M)) ?x\n   else weight \\<Gamma> ?x - d_IN (\\<Squnion> (fst ` M)) ?x)\n\ngoal (1 subgoal):\n 1. hindered (\\<Gamma> \\<ominus> f) \\<Longrightarrow> False", "define k where \"k e = Sup (fst ` M) e - \\<epsilon> e\" for e"], ["proof (state)\nthis:\n  k ?e = (\\<Squnion> (fst ` M)) ?e - \\<epsilon> ?e\n\ngoal (1 subgoal):\n 1. hindered (\\<Gamma> \\<ominus> f) \\<Longrightarrow> False", "have k_simps: \"k (x, y) = Sup (fst ` M) (x, y) - \\<epsilon> (x, y)\" for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. k (x, y) = (\\<Squnion> (fst ` M)) (x, y) - \\<epsilon> (x, y)", "by(simp add: k_def)"], ["proof (state)\nthis:\n  k (?x, ?y) = (\\<Squnion> (fst ` M)) (?x, ?y) - \\<epsilon> (?x, ?y)\n\ngoal (1 subgoal):\n 1. hindered (\\<Gamma> \\<ominus> f) \\<Longrightarrow> False", "have k_alt: \"k (x, y) = (if x = a \\<and> edge \\<Gamma> x y then Sup (fst ` M) (a, y) - \\<epsilon> (a, y) else 0)\" for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. k (x, y) =\n    (if x = a \\<and> edge \\<Gamma> x y\n     then (\\<Squnion> (fst ` M)) (a, y) - \\<epsilon> (a, y) else 0)", "by (cases \"x = a\")\n          (auto simp add: k_simps out_\\<epsilon> [OF Field] currentD_outside [OF \\<epsilon>] image_comp\n           intro!: SUP_eq_const [OF nempty] dest!: Chains_FieldD [OF M]\n           intro: currentD_outside [OF \\<epsilon>_curr] out_\\<epsilon>)"], ["proof (state)\nthis:\n  k (?x, ?y) =\n  (if ?x = a \\<and> edge \\<Gamma> ?x ?y\n   then (\\<Squnion> (fst ` M)) (a, ?y) - \\<epsilon> (a, ?y) else 0)\n\ngoal (1 subgoal):\n 1. hindered (\\<Gamma> \\<ominus> f) \\<Longrightarrow> False", "have OUT_k: \"d_OUT k x = (if x = a then d_OUT (Sup (fst ` M)) a - d_OUT \\<epsilon> a else 0)\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT k x =\n    (if x = a then d_OUT (\\<Squnion> (fst ` M)) a - d_OUT \\<epsilon> a\n     else 0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. d_OUT k x =\n    (if x = a then d_OUT (\\<Squnion> (fst ` M)) a - d_OUT \\<epsilon> a\n     else 0)", "have \"d_OUT k x = (if x = a then (\\<Sum>\\<^sup>+ y. Sup (fst ` M) (a, y) - \\<epsilon> (a, y)) else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT k x =\n    (if x = a\n     then \\<Sum>\\<^sup>+ y.\n            (\\<Squnion> (fst ` M)) (a, y) - \\<epsilon> (a, y)\n     else 0)", "using currentD_outside[OF SM1] currentD_outside[OF \\<epsilon>]"], ["proof (prove)\nusing this:\n  \\<not> edge \\<Gamma> ?x ?y \\<Longrightarrow>\n  (\\<Squnion> (fst ` M)) (?x, ?y) = 0\n  \\<not> edge \\<Gamma> ?x ?y \\<Longrightarrow> \\<epsilon> (?x, ?y) = 0\n\ngoal (1 subgoal):\n 1. d_OUT k x =\n    (if x = a\n     then \\<Sum>\\<^sup>+ y.\n            (\\<Squnion> (fst ` M)) (a, y) - \\<epsilon> (a, y)\n     else 0)", "by(auto simp add: k_alt d_OUT_def intro!: nn_integral_cong)"], ["proof (state)\nthis:\n  d_OUT k x =\n  (if x = a\n   then \\<Sum>\\<^sup>+ y. (\\<Squnion> (fst ` M)) (a, y) - \\<epsilon> (a, y)\n   else 0)\n\ngoal (1 subgoal):\n 1. d_OUT k x =\n    (if x = a then d_OUT (\\<Squnion> (fst ` M)) a - d_OUT \\<epsilon> a\n     else 0)", "also"], ["proof (state)\nthis:\n  d_OUT k x =\n  (if x = a\n   then \\<Sum>\\<^sup>+ y. (\\<Squnion> (fst ` M)) (a, y) - \\<epsilon> (a, y)\n   else 0)\n\ngoal (1 subgoal):\n 1. d_OUT k x =\n    (if x = a then d_OUT (\\<Squnion> (fst ` M)) a - d_OUT \\<epsilon> a\n     else 0)", "have \"(\\<Sum>\\<^sup>+ y. Sup (fst ` M) (a, y) - \\<epsilon> (a, y)) = d_OUT (Sup (fst `M)) a - d_OUT \\<epsilon> a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y. (\\<Squnion> (fst ` M)) (a, y) - \\<epsilon> (a, y)) =\n    d_OUT (\\<Squnion> (fst ` M)) a - d_OUT \\<epsilon> a", "using currentD_finite_OUT[OF \\<epsilon>, of a] hM"], ["proof (prove)\nusing this:\n  d_OUT \\<epsilon> a \\<noteq> \\<top>\n  (\\<epsilon>, h) \\<in> M\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y. (\\<Squnion> (fst ` M)) (a, y) - \\<epsilon> (a, y)) =\n    d_OUT (\\<Squnion> (fst ` M)) a - d_OUT \\<epsilon> a", "unfolding d_OUT_def"], ["proof (prove)\nusing this:\n  (\\<Sum>\\<^sup>+ y. \\<epsilon> (a, y)) \\<noteq> \\<top>\n  (\\<epsilon>, h) \\<in> M\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y. (\\<Squnion> (fst ` M)) (a, y) - \\<epsilon> (a, y)) =\n    (\\<Sum>\\<^sup>+ y. (\\<Squnion> (fst ` M)) (a, y)) -\n    (\\<Sum>\\<^sup>+ y. \\<epsilon> (a, y))", "by(subst nn_integral_diff[symmetric])(auto simp add: AE_count_space intro!: SUP_upper2)"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y. (\\<Squnion> (fst ` M)) (a, y) - \\<epsilon> (a, y)) =\n  d_OUT (\\<Squnion> (fst ` M)) a - d_OUT \\<epsilon> a\n\ngoal (1 subgoal):\n 1. d_OUT k x =\n    (if x = a then d_OUT (\\<Squnion> (fst ` M)) a - d_OUT \\<epsilon> a\n     else 0)", "finally"], ["proof (chain)\npicking this:\n  d_OUT k x =\n  (if x = a then d_OUT (\\<Squnion> (fst ` M)) a - d_OUT \\<epsilon> a else 0)", "show ?thesis"], ["proof (prove)\nusing this:\n  d_OUT k x =\n  (if x = a then d_OUT (\\<Squnion> (fst ` M)) a - d_OUT \\<epsilon> a else 0)\n\ngoal (1 subgoal):\n 1. d_OUT k x =\n    (if x = a then d_OUT (\\<Squnion> (fst ` M)) a - d_OUT \\<epsilon> a\n     else 0)", "."], ["proof (state)\nthis:\n  d_OUT k x =\n  (if x = a then d_OUT (\\<Squnion> (fst ` M)) a - d_OUT \\<epsilon> a else 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  d_OUT k ?x =\n  (if ?x = a then d_OUT (\\<Squnion> (fst ` M)) a - d_OUT \\<epsilon> a\n   else 0)\n\ngoal (1 subgoal):\n 1. hindered (\\<Gamma> \\<ominus> f) \\<Longrightarrow> False", "have IN_k: \"d_IN k y = (if edge \\<Gamma> a y then Sup (fst ` M) (a, y) - \\<epsilon> (a, y) else 0)\" for y"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN k y =\n    (if edge \\<Gamma> a y\n     then (\\<Squnion> (fst ` M)) (a, y) - \\<epsilon> (a, y) else 0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. d_IN k y =\n    (if edge \\<Gamma> a y\n     then (\\<Squnion> (fst ` M)) (a, y) - \\<epsilon> (a, y) else 0)", "have \"d_IN k y = (\\<Sum>\\<^sup>+ x. (if edge \\<Gamma> x y then Sup (fst ` M) (a, y) - \\<epsilon> (a, y) else 0) * indicator {a} x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN k y =\n    \\<integral>\\<^sup>+x\\<in>{a}.\n                       (if edge \\<Gamma> x y\n                        then (\\<Squnion> (fst ` M)) (a, y) -\n                             \\<epsilon> (a, y)\n                        else 0)\n    \\<partial>count_space UNIV", "unfolding d_IN_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ x. k (x, y)) =\n    \\<integral>\\<^sup>+x\\<in>{a}.\n                       (if edge \\<Gamma> x y\n                        then (\\<Squnion> (fst ` M)) (a, y) -\n                             \\<epsilon> (a, y)\n                        else 0)\n    \\<partial>count_space UNIV", "by(rule nn_integral_cong)(auto simp add: k_alt outgoing_def split: split_indicator)"], ["proof (state)\nthis:\n  d_IN k y =\n  \\<integral>\\<^sup>+x\\<in>{a}.\n                     (if edge \\<Gamma> x y\n                      then (\\<Squnion> (fst ` M)) (a, y) - \\<epsilon> (a, y)\n                      else 0)\n  \\<partial>count_space UNIV\n\ngoal (1 subgoal):\n 1. d_IN k y =\n    (if edge \\<Gamma> a y\n     then (\\<Squnion> (fst ` M)) (a, y) - \\<epsilon> (a, y) else 0)", "also"], ["proof (state)\nthis:\n  d_IN k y =\n  \\<integral>\\<^sup>+x\\<in>{a}.\n                     (if edge \\<Gamma> x y\n                      then (\\<Squnion> (fst ` M)) (a, y) - \\<epsilon> (a, y)\n                      else 0)\n  \\<partial>count_space UNIV\n\ngoal (1 subgoal):\n 1. d_IN k y =\n    (if edge \\<Gamma> a y\n     then (\\<Squnion> (fst ` M)) (a, y) - \\<epsilon> (a, y) else 0)", "have \"\\<dots> = (if edge \\<Gamma> a y then Sup (fst ` M) (a, y) - \\<epsilon> (a, y) else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+x\\<in>{a}.\n                       (if edge \\<Gamma> x y\n                        then (\\<Squnion> (fst ` M)) (a, y) -\n                             \\<epsilon> (a, y)\n                        else 0)\n    \\<partial>count_space UNIV =\n    (if edge \\<Gamma> a y\n     then (\\<Squnion> (fst ` M)) (a, y) - \\<epsilon> (a, y) else 0)", "using hM"], ["proof (prove)\nusing this:\n  (\\<epsilon>, h) \\<in> M\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+x\\<in>{a}.\n                       (if edge \\<Gamma> x y\n                        then (\\<Squnion> (fst ` M)) (a, y) -\n                             \\<epsilon> (a, y)\n                        else 0)\n    \\<partial>count_space UNIV =\n    (if edge \\<Gamma> a y\n     then (\\<Squnion> (fst ` M)) (a, y) - \\<epsilon> (a, y) else 0)", "by(auto simp add: max_def intro!: SUP_upper2)"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+x\\<in>{a}.\n                     (if edge \\<Gamma> x y\n                      then (\\<Squnion> (fst ` M)) (a, y) - \\<epsilon> (a, y)\n                      else 0)\n  \\<partial>count_space UNIV =\n  (if edge \\<Gamma> a y\n   then (\\<Squnion> (fst ` M)) (a, y) - \\<epsilon> (a, y) else 0)\n\ngoal (1 subgoal):\n 1. d_IN k y =\n    (if edge \\<Gamma> a y\n     then (\\<Squnion> (fst ` M)) (a, y) - \\<epsilon> (a, y) else 0)", "finally"], ["proof (chain)\npicking this:\n  d_IN k y =\n  (if edge \\<Gamma> a y\n   then (\\<Squnion> (fst ` M)) (a, y) - \\<epsilon> (a, y) else 0)", "show ?thesis"], ["proof (prove)\nusing this:\n  d_IN k y =\n  (if edge \\<Gamma> a y\n   then (\\<Squnion> (fst ` M)) (a, y) - \\<epsilon> (a, y) else 0)\n\ngoal (1 subgoal):\n 1. d_IN k y =\n    (if edge \\<Gamma> a y\n     then (\\<Squnion> (fst ` M)) (a, y) - \\<epsilon> (a, y) else 0)", "."], ["proof (state)\nthis:\n  d_IN k y =\n  (if edge \\<Gamma> a y\n   then (\\<Squnion> (fst ` M)) (a, y) - \\<epsilon> (a, y) else 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  d_IN k ?y =\n  (if edge \\<Gamma> a ?y\n   then (\\<Squnion> (fst ` M)) (a, ?y) - \\<epsilon> (a, ?y) else 0)\n\ngoal (1 subgoal):\n 1. hindered (\\<Gamma> \\<ominus> f) \\<Longrightarrow> False", "have OUT_\\<epsilon>h: \"d_OUT ?\\<epsilon>h x = d_OUT \\<epsilon> x + d_OUT h x\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT (plus_current \\<epsilon> h) x = d_OUT \\<epsilon> x + d_OUT h x", "unfolding plus_current_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT (\\<lambda>e. \\<epsilon> e + h e) x =\n    d_OUT \\<epsilon> x + d_OUT h x", "by(rule d_OUT_add)+"], ["proof (state)\nthis:\n  d_OUT (plus_current \\<epsilon> h) ?x = d_OUT \\<epsilon> ?x + d_OUT h ?x\n\ngoal (1 subgoal):\n 1. hindered (\\<Gamma> \\<ominus> f) \\<Longrightarrow> False", "have IN_\\<epsilon>h: \"d_IN ?\\<epsilon>h x = d_IN \\<epsilon> x + d_IN h x\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN (plus_current \\<epsilon> h) x = d_IN \\<epsilon> x + d_IN h x", "unfolding plus_current_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN (\\<lambda>e. \\<epsilon> e + h e) x = d_IN \\<epsilon> x + d_IN h x", "by(rule d_IN_add)+"], ["proof (state)\nthis:\n  d_IN (plus_current \\<epsilon> h) ?x = d_IN \\<epsilon> ?x + d_IN h ?x\n\ngoal (1 subgoal):\n 1. hindered (\\<Gamma> \\<ominus> f) \\<Longrightarrow> False", "have OUT1_le': \"d_OUT (Sup (fst`M)) x \\<le> weight \\<Gamma> x\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT (\\<Squnion> (fst ` M)) x \\<le> weight \\<Gamma> x", "using OUT1_le[of x]"], ["proof (prove)\nusing this:\n  (\\<Squnion>\\<epsilon>h\\<in>M. d_OUT (fst \\<epsilon>h) x)\n  \\<le> weight \\<Gamma> x\n\ngoal (1 subgoal):\n 1. d_OUT (\\<Squnion> (fst ` M)) x \\<le> weight \\<Gamma> x", "unfolding OUT1"], ["proof (prove)\nusing this:\n  (\\<Squnion>\\<epsilon>h\\<in>M. d_OUT (fst \\<epsilon>h) x)\n  \\<le> weight \\<Gamma> x\n\ngoal (1 subgoal):\n 1. (\\<Squnion>(\\<epsilon>, h)\\<in>M. d_OUT \\<epsilon> x)\n    \\<le> weight \\<Gamma> x", "by (simp add: split_beta')"], ["proof (state)\nthis:\n  d_OUT (\\<Squnion> (fst ` M)) ?x \\<le> weight \\<Gamma> ?x\n\ngoal (1 subgoal):\n 1. hindered (\\<Gamma> \\<ominus> f) \\<Longrightarrow> False", "have k: \"current (\\<Gamma> \\<ominus> ?\\<epsilon>h) k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. current (\\<Gamma> \\<ominus> plus_current \\<epsilon> h) k", "proof"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x.\n       d_OUT k x\n       \\<le> weight (\\<Gamma> \\<ominus> plus_current \\<epsilon> h) x\n 2. \\<And>x.\n       d_IN k x\n       \\<le> weight (\\<Gamma> \\<ominus> plus_current \\<epsilon> h) x\n 3. \\<And>e.\n       e \\<notin> \\<^bold>E\\<^bsub>\\<Gamma> \\<ominus> plus_current \\<epsilon> h\\<^esub> \\<Longrightarrow>\n       k e = 0", "fix x"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x.\n       d_OUT k x\n       \\<le> weight (\\<Gamma> \\<ominus> plus_current \\<epsilon> h) x\n 2. \\<And>x.\n       d_IN k x\n       \\<le> weight (\\<Gamma> \\<ominus> plus_current \\<epsilon> h) x\n 3. \\<And>e.\n       e \\<notin> \\<^bold>E\\<^bsub>\\<Gamma> \\<ominus> plus_current \\<epsilon> h\\<^esub> \\<Longrightarrow>\n       k e = 0", "show \"d_OUT k x \\<le> weight (\\<Gamma> \\<ominus> ?\\<epsilon>h) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT k x \\<le> weight (\\<Gamma> \\<ominus> plus_current \\<epsilon> h) x", "using a OUT1_na[of x] currentD_weight_OUT[OF hM2[OF hM], of x] currentD_weight_IN[OF \\<epsilon>h_curr, of x]\n            currentD_weight_IN[OF \\<epsilon>, of x] OUT1_le'[of x]"], ["proof (prove)\nusing this:\n  a \\<in> A \\<Gamma>\n  x \\<noteq> a \\<Longrightarrow> d_OUT (\\<Squnion> (fst ` M)) x = 0\n  d_OUT h x \\<le> weight (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)) x\n  d_IN (plus_current \\<epsilon> h) x \\<le> weight \\<Gamma> x\n  d_IN \\<epsilon> x \\<le> weight \\<Gamma> x\n  d_OUT (\\<Squnion> (fst ` M)) x \\<le> weight \\<Gamma> x\n\ngoal (1 subgoal):\n 1. d_OUT k x \\<le> weight (\\<Gamma> \\<ominus> plus_current \\<epsilon> h) x", "apply(auto simp add: diff_add_eq_diff_diff_swap_ennreal diff_add_assoc2_ennreal[symmetric]\n                               OUT_k OUT_\\<epsilon> OUT_\\<epsilon>h IN_\\<epsilon>h currentD_OUT'[OF \\<epsilon>] IN_\\<epsilon>[OF Field] h.currentD_OUT'[OF h_curr])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<in> A \\<Gamma>;\n     d_OUT h a \\<le> weight \\<Gamma> a - d_OUT (\\<Squnion> (fst ` M)) a;\n     \\<epsilon> (a, a) + d_IN h a \\<le> weight \\<Gamma> a;\n     \\<epsilon> (a, a) \\<le> weight \\<Gamma> a;\n     d_OUT (\\<Squnion> (fst ` M)) a \\<le> weight \\<Gamma> a; x = a\\<rbrakk>\n    \\<Longrightarrow> d_OUT (\\<Squnion> (fst ` M)) a - d_OUT \\<epsilon> a\n                      \\<le> weight \\<Gamma> a - d_OUT \\<epsilon> a -\n                            d_OUT h a", "apply(subst diff_diff_commute_ennreal)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<in> A \\<Gamma>;\n     d_OUT h a \\<le> weight \\<Gamma> a - d_OUT (\\<Squnion> (fst ` M)) a;\n     \\<epsilon> (a, a) + d_IN h a \\<le> weight \\<Gamma> a;\n     \\<epsilon> (a, a) \\<le> weight \\<Gamma> a;\n     d_OUT (\\<Squnion> (fst ` M)) a \\<le> weight \\<Gamma> a; x = a\\<rbrakk>\n    \\<Longrightarrow> d_OUT (\\<Squnion> (fst ` M)) a - d_OUT \\<epsilon> a\n                      \\<le> weight \\<Gamma> a - d_OUT h a -\n                            d_OUT \\<epsilon> a", "apply(intro ennreal_minus_mono)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>a \\<in> A \\<Gamma>;\n     d_OUT h a \\<le> weight \\<Gamma> a - d_OUT (\\<Squnion> (fst ` M)) a;\n     \\<epsilon> (a, a) + d_IN h a \\<le> weight \\<Gamma> a;\n     \\<epsilon> (a, a) \\<le> weight \\<Gamma> a;\n     d_OUT (\\<Squnion> (fst ` M)) a \\<le> weight \\<Gamma> a; x = a\\<rbrakk>\n    \\<Longrightarrow> d_OUT (\\<Squnion> (fst ` M)) a\n                      \\<le> weight \\<Gamma> a - d_OUT h a\n 2. \\<lbrakk>a \\<in> A \\<Gamma>;\n     d_OUT h a \\<le> weight \\<Gamma> a - d_OUT (\\<Squnion> (fst ` M)) a;\n     \\<epsilon> (a, a) + d_IN h a \\<le> weight \\<Gamma> a;\n     \\<epsilon> (a, a) \\<le> weight \\<Gamma> a;\n     d_OUT (\\<Squnion> (fst ` M)) a \\<le> weight \\<Gamma> a; x = a\\<rbrakk>\n    \\<Longrightarrow> d_OUT \\<epsilon> a \\<le> d_OUT \\<epsilon> a", "apply(auto simp add: ennreal_le_minus_iff ac_simps less_imp_le OUT1)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  d_OUT k x \\<le> weight (\\<Gamma> \\<ominus> plus_current \\<epsilon> h) x\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       d_IN k x\n       \\<le> weight (\\<Gamma> \\<ominus> plus_current \\<epsilon> h) x\n 2. \\<And>e.\n       e \\<notin> \\<^bold>E\\<^bsub>\\<Gamma> \\<ominus> plus_current \\<epsilon> h\\<^esub> \\<Longrightarrow>\n       k e = 0", "have *: \"(\\<Squnion>xa\\<in>M. fst xa (a, x)) \\<le> d_IN (Sup (fst`M)) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Squnion>xa\\<in>M. fst xa (a, x)) \\<le> d_IN (\\<Squnion> (fst ` M)) x", "unfolding IN1"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Squnion>xa\\<in>M. fst xa (a, x))\n    \\<le> (\\<Squnion>(\\<epsilon>, h)\\<in>M. d_IN \\<epsilon> x)", "by (intro SUP_subset_mono) (auto simp: split_beta' d_IN_ge_point)"], ["proof (state)\nthis:\n  (\\<Squnion>xa\\<in>M. fst xa (a, x)) \\<le> d_IN (\\<Squnion> (fst ` M)) x\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       d_IN k x\n       \\<le> weight (\\<Gamma> \\<ominus> plus_current \\<epsilon> h) x\n 2. \\<And>e.\n       e \\<notin> \\<^bold>E\\<^bsub>\\<Gamma> \\<ominus> plus_current \\<epsilon> h\\<^esub> \\<Longrightarrow>\n       k e = 0", "also"], ["proof (state)\nthis:\n  (\\<Squnion>xa\\<in>M. fst xa (a, x)) \\<le> d_IN (\\<Squnion> (fst ` M)) x\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       d_IN k x\n       \\<le> weight (\\<Gamma> \\<ominus> plus_current \\<epsilon> h) x\n 2. \\<And>e.\n       e \\<notin> \\<^bold>E\\<^bsub>\\<Gamma> \\<ominus> plus_current \\<epsilon> h\\<^esub> \\<Longrightarrow>\n       k e = 0", "have \"\\<dots> \\<le> weight \\<Gamma> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN (\\<Squnion> (fst ` M)) x \\<le> weight \\<Gamma> x", "using IN1_le[of x] IN1"], ["proof (prove)\nusing this:\n  (\\<Squnion>\\<epsilon>h\\<in>M. d_IN (fst \\<epsilon>h) x)\n  \\<le> weight \\<Gamma> x\n  d_IN (\\<Squnion> (fst ` M)) ?x =\n  (\\<Squnion>(\\<epsilon>, h)\\<in>M. d_IN \\<epsilon> ?x)\n\ngoal (1 subgoal):\n 1. d_IN (\\<Squnion> (fst ` M)) x \\<le> weight \\<Gamma> x", "by (simp add: split_beta')"], ["proof (state)\nthis:\n  d_IN (\\<Squnion> (fst ` M)) x \\<le> weight \\<Gamma> x\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       d_IN k x\n       \\<le> weight (\\<Gamma> \\<ominus> plus_current \\<epsilon> h) x\n 2. \\<And>e.\n       e \\<notin> \\<^bold>E\\<^bsub>\\<Gamma> \\<ominus> plus_current \\<epsilon> h\\<^esub> \\<Longrightarrow>\n       k e = 0", "finally"], ["proof (chain)\npicking this:\n  (\\<Squnion>xa\\<in>M. fst xa (a, x)) \\<le> weight \\<Gamma> x", "show \"d_IN k x \\<le> weight (\\<Gamma> \\<ominus> ?\\<epsilon>h) x\""], ["proof (prove)\nusing this:\n  (\\<Squnion>xa\\<in>M. fst xa (a, x)) \\<le> weight \\<Gamma> x\n\ngoal (1 subgoal):\n 1. d_IN k x \\<le> weight (\\<Gamma> \\<ominus> plus_current \\<epsilon> h) x", "using currentD_weight_IN[OF \\<epsilon>h_curr, of x] currentD_weight_OUT[OF \\<epsilon>h_curr, of x]\n            currentD_weight_IN[OF hM2[OF hM], of x] IN_\\<epsilon>[OF Field, of x] *"], ["proof (prove)\nusing this:\n  (\\<Squnion>xa\\<in>M. fst xa (a, x)) \\<le> weight \\<Gamma> x\n  d_IN (plus_current \\<epsilon> h) x \\<le> weight \\<Gamma> x\n  d_OUT (plus_current \\<epsilon> h) x \\<le> weight \\<Gamma> x\n  d_IN h x \\<le> weight (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)) x\n  d_IN \\<epsilon> x = \\<epsilon> (a, x)\n  (\\<Squnion>xa\\<in>M. fst xa (a, x)) \\<le> d_IN (\\<Squnion> (fst ` M)) x\n\ngoal (1 subgoal):\n 1. d_IN k x \\<le> weight (\\<Gamma> \\<ominus> plus_current \\<epsilon> h) x", "apply (auto simp add: IN_k outgoing_def IN_\\<epsilon>h IN_\\<epsilon> A_in diff_add_eq_diff_diff_swap_ennreal)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<Squnion>xa\\<in>M. fst xa (a, x)) \\<le> weight \\<Gamma> x;\n     \\<epsilon> (a, x) + d_IN h x \\<le> weight \\<Gamma> x;\n     d_OUT (plus_current \\<epsilon> h) x \\<le> weight \\<Gamma> x;\n     d_IN h x \\<le> weight \\<Gamma> x - d_IN (\\<Squnion> (fst ` M)) x;\n     d_IN \\<epsilon> x = \\<epsilon> (a, x);\n     (\\<Squnion>xa\\<in>M. fst xa (a, x))\n     \\<le> d_IN (\\<Squnion> (fst ` M)) x;\n     edge \\<Gamma> a x; x \\<notin> A \\<Gamma>\\<rbrakk>\n    \\<Longrightarrow> (\\<Squnion>xa\\<in>fst ` M. xa (a, x)) -\n                      \\<epsilon> (a, x)\n                      \\<le> weight \\<Gamma> x - \\<epsilon> (a, x) - d_IN h x", "apply (subst diff_diff_commute_ennreal)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<Squnion>xa\\<in>M. fst xa (a, x)) \\<le> weight \\<Gamma> x;\n     \\<epsilon> (a, x) + d_IN h x \\<le> weight \\<Gamma> x;\n     d_OUT (plus_current \\<epsilon> h) x \\<le> weight \\<Gamma> x;\n     d_IN h x \\<le> weight \\<Gamma> x - d_IN (\\<Squnion> (fst ` M)) x;\n     d_IN \\<epsilon> x = \\<epsilon> (a, x);\n     (\\<Squnion>xa\\<in>M. fst xa (a, x))\n     \\<le> d_IN (\\<Squnion> (fst ` M)) x;\n     edge \\<Gamma> a x; x \\<notin> A \\<Gamma>\\<rbrakk>\n    \\<Longrightarrow> (\\<Squnion>xa\\<in>fst ` M. xa (a, x)) -\n                      \\<epsilon> (a, x)\n                      \\<le> weight \\<Gamma> x - d_IN h x - \\<epsilon> (a, x)", "apply (intro ennreal_minus_mono[OF _ order_refl])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<Squnion>xa\\<in>M. fst xa (a, x)) \\<le> weight \\<Gamma> x;\n     \\<epsilon> (a, x) + d_IN h x \\<le> weight \\<Gamma> x;\n     d_OUT (plus_current \\<epsilon> h) x \\<le> weight \\<Gamma> x;\n     d_IN h x \\<le> weight \\<Gamma> x - d_IN (\\<Squnion> (fst ` M)) x;\n     d_IN \\<epsilon> x = \\<epsilon> (a, x);\n     (\\<Squnion>xa\\<in>M. fst xa (a, x))\n     \\<le> d_IN (\\<Squnion> (fst ` M)) x;\n     edge \\<Gamma> a x; x \\<notin> A \\<Gamma>\\<rbrakk>\n    \\<Longrightarrow> (\\<Squnion>xa\\<in>fst ` M. xa (a, x))\n                      \\<le> weight \\<Gamma> x - d_IN h x", "apply (auto simp add: ennreal_le_minus_iff ac_simps image_comp intro: order_trans add_mono)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  d_IN k x \\<le> weight (\\<Gamma> \\<ominus> plus_current \\<epsilon> h) x\n\ngoal (1 subgoal):\n 1. \\<And>e.\n       e \\<notin> \\<^bold>E\\<^bsub>\\<Gamma> \\<ominus> plus_current \\<epsilon> h\\<^esub> \\<Longrightarrow>\n       k e = 0", "show \"k e = 0\" if \"e \\<notin> \\<^bold>E\\<^bsub>\\<Gamma> \\<ominus> ?\\<epsilon>h\\<^esub>\" for e"], ["proof (prove)\ngoal (1 subgoal):\n 1. k e = 0", "using that"], ["proof (prove)\nusing this:\n  e \\<notin> \\<^bold>E\\<^bsub>\\<Gamma> \\<ominus> plus_current \\<epsilon> h\\<^esub>\n\ngoal (1 subgoal):\n 1. k e = 0", "by (cases e) (simp add: k_alt)"], ["proof (state)\nthis:\n  ?e \\<notin> \\<^bold>E\\<^bsub>\\<Gamma> \\<ominus> plus_current \\<epsilon> h\\<^esub> \\<Longrightarrow>\n  k ?e = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  current (\\<Gamma> \\<ominus> plus_current \\<epsilon> h) k\n\ngoal (1 subgoal):\n 1. hindered (\\<Gamma> \\<ominus> f) \\<Longrightarrow> False", "define q where \"q = (\\<Sum>\\<^sup>+ y\\<in>B (\\<Gamma> \\<ominus> ?\\<epsilon>h). d_IN k y - d_OUT k y)\""], ["proof (state)\nthis:\n  q =\n  (\\<Sum>\\<^sup>+ y\\<in>B (\\<Gamma> \\<ominus> plus_current \\<epsilon> h).\n     d_IN k y - d_OUT k y)\n\ngoal (1 subgoal):\n 1. hindered (\\<Gamma> \\<ominus> f) \\<Longrightarrow> False", "have q_alt: \"q = (\\<Sum>\\<^sup>+ y\\<in>- A (\\<Gamma> \\<ominus> ?\\<epsilon>h). d_IN k y - d_OUT k y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q =\n    (\\<Sum>\\<^sup>+ y\\<in>- A (\\<Gamma> \\<ominus>\n                               plus_current \\<epsilon> h).\n       d_IN k y - d_OUT k y)", "using disjoint"], ["proof (prove)\nusing this:\n  A \\<Gamma> \\<inter> B \\<Gamma> = {}\n\ngoal (1 subgoal):\n 1. q =\n    (\\<Sum>\\<^sup>+ y\\<in>- A (\\<Gamma> \\<ominus>\n                               plus_current \\<epsilon> h).\n       d_IN k y - d_OUT k y)", "by(auto simp add: q_def nn_integral_count_space_indicator currentD_outside_OUT[OF k] currentD_outside_IN[OF k] not_vertex split: split_indicator intro!: nn_integral_cong)"], ["proof (state)\nthis:\n  q =\n  (\\<Sum>\\<^sup>+ y\\<in>- A (\\<Gamma> \\<ominus> plus_current \\<epsilon> h).\n     d_IN k y - d_OUT k y)\n\ngoal (1 subgoal):\n 1. hindered (\\<Gamma> \\<ominus> f) \\<Longrightarrow> False", "have q_simps: \"q = d_OUT (Sup (fst ` M)) a - d_OUT \\<epsilon> a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q = d_OUT (\\<Squnion> (fst ` M)) a - d_OUT \\<epsilon> a", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. q = d_OUT (\\<Squnion> (fst ` M)) a - d_OUT \\<epsilon> a", "have \"q = (\\<Sum>\\<^sup>+ y. d_IN k y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q = integral\\<^sup>N (count_space UNIV) (d_IN k)", "using a IN1 OUT1 OUT1_na"], ["proof (prove)\nusing this:\n  a \\<in> A \\<Gamma>\n  d_IN (\\<Squnion> (fst ` M)) ?x =\n  (\\<Squnion>(\\<epsilon>, h)\\<in>M. d_IN \\<epsilon> ?x)\n  d_OUT (\\<Squnion> (fst ` M)) ?x =\n  (\\<Squnion>(\\<epsilon>, h)\\<in>M. d_OUT \\<epsilon> ?x)\n  ?x \\<noteq> a \\<Longrightarrow> d_OUT (\\<Squnion> (fst ` M)) ?x = 0\n\ngoal (1 subgoal):\n 1. q = integral\\<^sup>N (count_space UNIV) (d_IN k)", "unfolding q_alt"], ["proof (prove)\nusing this:\n  a \\<in> A \\<Gamma>\n  d_IN (\\<Squnion> (fst ` M)) ?x =\n  (\\<Squnion>(\\<epsilon>, h)\\<in>M. d_IN \\<epsilon> ?x)\n  d_OUT (\\<Squnion> (fst ` M)) ?x =\n  (\\<Squnion>(\\<epsilon>, h)\\<in>M. d_OUT \\<epsilon> ?x)\n  ?x \\<noteq> a \\<Longrightarrow> d_OUT (\\<Squnion> (fst ` M)) ?x = 0\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y\\<in>- A (\\<Gamma> \\<ominus>\n                               plus_current \\<epsilon> h).\n       d_IN k y - d_OUT k y) =\n    integral\\<^sup>N (count_space UNIV) (d_IN k)", "by(auto simp add: nn_integral_count_space_indicator OUT_k IN_\\<epsilon>[OF Field] OUT_\\<epsilon> currentD_outside[OF \\<epsilon>] outgoing_def no_loop A_in IN_k intro!: nn_integral_cong split: split_indicator)"], ["proof (state)\nthis:\n  q = integral\\<^sup>N (count_space UNIV) (d_IN k)\n\ngoal (1 subgoal):\n 1. q = d_OUT (\\<Squnion> (fst ` M)) a - d_OUT \\<epsilon> a", "also"], ["proof (state)\nthis:\n  q = integral\\<^sup>N (count_space UNIV) (d_IN k)\n\ngoal (1 subgoal):\n 1. q = d_OUT (\\<Squnion> (fst ` M)) a - d_OUT \\<epsilon> a", "have \"\\<dots> = d_OUT (Sup (fst ` M)) a - d_OUT \\<epsilon> a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. integral\\<^sup>N (count_space UNIV) (d_IN k) =\n    d_OUT (\\<Squnion> (fst ` M)) a - d_OUT \\<epsilon> a", "using currentD_finite_OUT[OF \\<epsilon>, of a] hM currentD_outside[OF SM1] currentD_outside[OF \\<epsilon>]"], ["proof (prove)\nusing this:\n  d_OUT \\<epsilon> a \\<noteq> \\<top>\n  (\\<epsilon>, h) \\<in> M\n  \\<not> edge \\<Gamma> ?x ?y \\<Longrightarrow>\n  (\\<Squnion> (fst ` M)) (?x, ?y) = 0\n  \\<not> edge \\<Gamma> ?x ?y \\<Longrightarrow> \\<epsilon> (?x, ?y) = 0\n\ngoal (1 subgoal):\n 1. integral\\<^sup>N (count_space UNIV) (d_IN k) =\n    d_OUT (\\<Squnion> (fst ` M)) a - d_OUT \\<epsilon> a", "by(subst d_OUT_diff[symmetric])(auto simp add: d_OUT_def IN_k intro!: SUP_upper2 nn_integral_cong)"], ["proof (state)\nthis:\n  integral\\<^sup>N (count_space UNIV) (d_IN k) =\n  d_OUT (\\<Squnion> (fst ` M)) a - d_OUT \\<epsilon> a\n\ngoal (1 subgoal):\n 1. q = d_OUT (\\<Squnion> (fst ` M)) a - d_OUT \\<epsilon> a", "finally"], ["proof (chain)\npicking this:\n  q = d_OUT (\\<Squnion> (fst ` M)) a - d_OUT \\<epsilon> a", "show ?thesis"], ["proof (prove)\nusing this:\n  q = d_OUT (\\<Squnion> (fst ` M)) a - d_OUT \\<epsilon> a\n\ngoal (1 subgoal):\n 1. q = d_OUT (\\<Squnion> (fst ` M)) a - d_OUT \\<epsilon> a", "."], ["proof (state)\nthis:\n  q = d_OUT (\\<Squnion> (fst ` M)) a - d_OUT \\<epsilon> a\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  q = d_OUT (\\<Squnion> (fst ` M)) a - d_OUT \\<epsilon> a\n\ngoal (1 subgoal):\n 1. hindered (\\<Gamma> \\<ominus> f) \\<Longrightarrow> False", "have q_finite: \"q \\<noteq> \\<top>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q \\<noteq> \\<top>", "using currentD_finite_OUT[OF SM1, of a]"], ["proof (prove)\nusing this:\n  d_OUT (\\<Squnion> (fst ` M)) a \\<noteq> \\<top>\n\ngoal (1 subgoal):\n 1. q \\<noteq> \\<top>", "by(simp add: q_simps)"], ["proof (state)\nthis:\n  q \\<noteq> \\<top>\n\ngoal (1 subgoal):\n 1. hindered (\\<Gamma> \\<ominus> f) \\<Longrightarrow> False", "have q_nonneg: \"0 \\<le> q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> q", "using hM"], ["proof (prove)\nusing this:\n  (\\<epsilon>, h) \\<in> M\n\ngoal (1 subgoal):\n 1. 0 \\<le> q", "by(auto simp add: q_simps intro!: d_OUT_mono SUP_upper2)"], ["proof (state)\nthis:\n  0 \\<le> q\n\ngoal (1 subgoal):\n 1. hindered (\\<Gamma> \\<ominus> f) \\<Longrightarrow> False", "have q_less_\\<delta>: \"q < \\<delta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q < \\<delta>", "using close"], ["proof (prove)\nusing this:\n  d_OUT f a < d_OUT (plus_current \\<epsilon> h) a + \\<delta>\n\ngoal (1 subgoal):\n 1. q < \\<delta>", "unfolding q_simps \\<delta>_def OUT_\\<epsilon>h OUT_f"], ["proof (prove)\nusing this:\n  d_OUT (\\<Squnion> (fst ` M)) a + d_OUT (\\<Squnion> (snd ` M)) a\n  < d_OUT \\<epsilon> a + d_OUT h a +\n    (weight (\\<Gamma> \\<ominus> f) z - d_OUT g z)\n\ngoal (1 subgoal):\n 1. d_OUT (\\<Squnion> (fst ` M)) a - d_OUT \\<epsilon> a\n    < weight (\\<Gamma> \\<ominus> f) z - d_OUT g z", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. d_OUT (\\<Squnion> (fst ` M)) a + d_OUT (\\<Squnion> (snd ` M)) a\n    < d_OUT \\<epsilon> a + d_OUT h a +\n      (weight (\\<Gamma> \\<ominus> f) z - d_OUT g z) \\<Longrightarrow>\n    d_OUT (\\<Squnion> (fst ` M)) a - d_OUT \\<epsilon> a\n    < weight (\\<Gamma> \\<ominus> f) z - d_OUT g z", "let ?F = \"d_OUT (Sup (fst`M)) a\" and ?S = \"d_OUT (Sup (snd`M)) a\"\n          and ?\\<epsilon> = \"d_OUT \\<epsilon> a\" and ?h = \"d_OUT h a\" and ?w = \"weight (\\<Gamma> \\<ominus> f) z - d_OUT g z\""], ["proof (state)\ngoal (1 subgoal):\n 1. d_OUT (\\<Squnion> (fst ` M)) a + d_OUT (\\<Squnion> (snd ` M)) a\n    < d_OUT \\<epsilon> a + d_OUT h a +\n      (weight (\\<Gamma> \\<ominus> f) z - d_OUT g z) \\<Longrightarrow>\n    d_OUT (\\<Squnion> (fst ` M)) a - d_OUT \\<epsilon> a\n    < weight (\\<Gamma> \\<ominus> f) z - d_OUT g z", "have \"?F + ?h \\<le> ?F + ?S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT (\\<Squnion> (fst ` M)) a + d_OUT h a\n    \\<le> d_OUT (\\<Squnion> (fst ` M)) a + d_OUT (\\<Squnion> (snd ` M)) a", "using hM"], ["proof (prove)\nusing this:\n  (\\<epsilon>, h) \\<in> M\n\ngoal (1 subgoal):\n 1. d_OUT (\\<Squnion> (fst ` M)) a + d_OUT h a\n    \\<le> d_OUT (\\<Squnion> (fst ` M)) a + d_OUT (\\<Squnion> (snd ` M)) a", "by (auto intro!: add_mono d_OUT_mono SUP_upper2)"], ["proof (state)\nthis:\n  d_OUT (\\<Squnion> (fst ` M)) a + d_OUT h a\n  \\<le> d_OUT (\\<Squnion> (fst ` M)) a + d_OUT (\\<Squnion> (snd ` M)) a\n\ngoal (1 subgoal):\n 1. d_OUT (\\<Squnion> (fst ` M)) a + d_OUT (\\<Squnion> (snd ` M)) a\n    < d_OUT \\<epsilon> a + d_OUT h a +\n      (weight (\\<Gamma> \\<ominus> f) z - d_OUT g z) \\<Longrightarrow>\n    d_OUT (\\<Squnion> (fst ` M)) a - d_OUT \\<epsilon> a\n    < weight (\\<Gamma> \\<ominus> f) z - d_OUT g z", "also"], ["proof (state)\nthis:\n  d_OUT (\\<Squnion> (fst ` M)) a + d_OUT h a\n  \\<le> d_OUT (\\<Squnion> (fst ` M)) a + d_OUT (\\<Squnion> (snd ` M)) a\n\ngoal (1 subgoal):\n 1. d_OUT (\\<Squnion> (fst ` M)) a + d_OUT (\\<Squnion> (snd ` M)) a\n    < d_OUT \\<epsilon> a + d_OUT h a +\n      (weight (\\<Gamma> \\<ominus> f) z - d_OUT g z) \\<Longrightarrow>\n    d_OUT (\\<Squnion> (fst ` M)) a - d_OUT \\<epsilon> a\n    < weight (\\<Gamma> \\<ominus> f) z - d_OUT g z", "assume \"?F + ?S < ?\\<epsilon> + ?h + ?w\""], ["proof (state)\nthis:\n  d_OUT (\\<Squnion> (fst ` M)) a + d_OUT (\\<Squnion> (snd ` M)) a\n  < d_OUT \\<epsilon> a + d_OUT h a +\n    (weight (\\<Gamma> \\<ominus> f) z - d_OUT g z)\n\ngoal (1 subgoal):\n 1. d_OUT (\\<Squnion> (fst ` M)) a + d_OUT (\\<Squnion> (snd ` M)) a\n    < d_OUT \\<epsilon> a + d_OUT h a +\n      (weight (\\<Gamma> \\<ominus> f) z - d_OUT g z) \\<Longrightarrow>\n    d_OUT (\\<Squnion> (fst ` M)) a - d_OUT \\<epsilon> a\n    < weight (\\<Gamma> \\<ominus> f) z - d_OUT g z", "finally"], ["proof (chain)\npicking this:\n  d_OUT (\\<Squnion> (fst ` M)) a + d_OUT h a\n  < d_OUT \\<epsilon> a + d_OUT h a +\n    (weight (\\<Gamma> \\<ominus> f) z - d_OUT g z)", "have \"?h + ?F < ?h + (?w + ?\\<epsilon>)\""], ["proof (prove)\nusing this:\n  d_OUT (\\<Squnion> (fst ` M)) a + d_OUT h a\n  < d_OUT \\<epsilon> a + d_OUT h a +\n    (weight (\\<Gamma> \\<ominus> f) z - d_OUT g z)\n\ngoal (1 subgoal):\n 1. d_OUT h a + d_OUT (\\<Squnion> (fst ` M)) a\n    < d_OUT h a +\n      (weight (\\<Gamma> \\<ominus> f) z - d_OUT g z + d_OUT \\<epsilon> a)", "by (simp add: ac_simps)"], ["proof (state)\nthis:\n  d_OUT h a + d_OUT (\\<Squnion> (fst ` M)) a\n  < d_OUT h a +\n    (weight (\\<Gamma> \\<ominus> f) z - d_OUT g z + d_OUT \\<epsilon> a)\n\ngoal (1 subgoal):\n 1. d_OUT (\\<Squnion> (fst ` M)) a + d_OUT (\\<Squnion> (snd ` M)) a\n    < d_OUT \\<epsilon> a + d_OUT h a +\n      (weight (\\<Gamma> \\<ominus> f) z - d_OUT g z) \\<Longrightarrow>\n    d_OUT (\\<Squnion> (fst ` M)) a - d_OUT \\<epsilon> a\n    < weight (\\<Gamma> \\<ominus> f) z - d_OUT g z", "then"], ["proof (chain)\npicking this:\n  d_OUT h a + d_OUT (\\<Squnion> (fst ` M)) a\n  < d_OUT h a +\n    (weight (\\<Gamma> \\<ominus> f) z - d_OUT g z + d_OUT \\<epsilon> a)", "show \"?F - ?\\<epsilon> < ?w\""], ["proof (prove)\nusing this:\n  d_OUT h a + d_OUT (\\<Squnion> (fst ` M)) a\n  < d_OUT h a +\n    (weight (\\<Gamma> \\<ominus> f) z - d_OUT g z + d_OUT \\<epsilon> a)\n\ngoal (1 subgoal):\n 1. d_OUT (\\<Squnion> (fst ` M)) a - d_OUT \\<epsilon> a\n    < weight (\\<Gamma> \\<ominus> f) z - d_OUT g z", "using currentD_finite_OUT[OF \\<epsilon>, of a] hM"], ["proof (prove)\nusing this:\n  d_OUT h a + d_OUT (\\<Squnion> (fst ` M)) a\n  < d_OUT h a +\n    (weight (\\<Gamma> \\<ominus> f) z - d_OUT g z + d_OUT \\<epsilon> a)\n  d_OUT \\<epsilon> a \\<noteq> \\<top>\n  (\\<epsilon>, h) \\<in> M\n\ngoal (1 subgoal):\n 1. d_OUT (\\<Squnion> (fst ` M)) a - d_OUT \\<epsilon> a\n    < weight (\\<Gamma> \\<ominus> f) z - d_OUT g z", "unfolding ennreal_add_left_cancel_less"], ["proof (prove)\nusing this:\n  d_OUT h a \\<noteq> \\<infinity> \\<and>\n  d_OUT (\\<Squnion> (fst ` M)) a\n  < weight (\\<Gamma> \\<ominus> f) z - d_OUT g z + d_OUT \\<epsilon> a\n  d_OUT \\<epsilon> a \\<noteq> \\<top>\n  (\\<epsilon>, h) \\<in> M\n\ngoal (1 subgoal):\n 1. d_OUT (\\<Squnion> (fst ` M)) a - d_OUT \\<epsilon> a\n    < weight (\\<Gamma> \\<ominus> f) z - d_OUT g z", "by (subst minus_less_iff_ennreal) (auto intro!: d_OUT_mono SUP_upper2 simp: less_top)"], ["proof (state)\nthis:\n  d_OUT (\\<Squnion> (fst ` M)) a - d_OUT \\<epsilon> a\n  < weight (\\<Gamma> \\<ominus> f) z - d_OUT g z\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  q < \\<delta>\n\ngoal (1 subgoal):\n 1. hindered (\\<Gamma> \\<ominus> f) \\<Longrightarrow> False", "define g' where \"g' = plus_current g (Sup (snd ` M) - h)\""], ["proof (state)\nthis:\n  g' = plus_current g (\\<Squnion> (snd ` M) - h)\n\ngoal (1 subgoal):\n 1. hindered (\\<Gamma> \\<ominus> f) \\<Longrightarrow> False", "have g'_simps: \"g' e = g e + Sup (snd ` M) e - h e\" for e"], ["proof (prove)\ngoal (1 subgoal):\n 1. g' e = g e + (\\<Squnion> (snd ` M)) e - h e", "using hM"], ["proof (prove)\nusing this:\n  (\\<epsilon>, h) \\<in> M\n\ngoal (1 subgoal):\n 1. g' e = g e + (\\<Squnion> (snd ` M)) e - h e", "by(auto simp add: g'_def intro!: add_diff_eq_ennreal intro: SUP_upper2)"], ["proof (state)\nthis:\n  g' ?e = g ?e + (\\<Squnion> (snd ` M)) ?e - h ?e\n\ngoal (1 subgoal):\n 1. hindered (\\<Gamma> \\<ominus> f) \\<Longrightarrow> False", "have OUT_g': \"d_OUT g' x = d_OUT g x + (d_OUT (Sup (snd ` M)) x - d_OUT h x)\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT g' x = d_OUT g x + (d_OUT (\\<Squnion> (snd ` M)) x - d_OUT h x)", "unfolding g'_simps[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT (\\<lambda>e. g e + (\\<Squnion> (snd ` M)) e - h e) x =\n    d_OUT g x + (d_OUT (\\<Squnion> (snd ` M)) x - d_OUT h x)", "using \\<epsilon>h.currentD_finite_OUT[OF k] hM h.currentD_finite_OUT[OF h_curr] hM"], ["proof (prove)\nusing this:\n  d_OUT k ?x \\<noteq> \\<top>\n  (\\<epsilon>, h) \\<in> M\n  d_OUT h ?x \\<noteq> \\<top>\n  (\\<epsilon>, h) \\<in> M\n\ngoal (1 subgoal):\n 1. d_OUT (\\<lambda>e. g e + (\\<Squnion> (snd ` M)) e - h e) x =\n    d_OUT g x + (d_OUT (\\<Squnion> (snd ` M)) x - d_OUT h x)", "apply(subst d_OUT_diff)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>y.\n       \\<lbrakk>\\<And>x. d_OUT k x \\<noteq> \\<top>; (\\<epsilon>, h) \\<in> M;\n        \\<And>x. d_OUT h x \\<noteq> \\<top>; (\\<epsilon>, h) \\<in> M\\<rbrakk>\n       \\<Longrightarrow> h (x, y)\n                         \\<le> g (x, y) + (\\<Squnion> (snd ` M)) (x, y)\n 2. \\<lbrakk>\\<And>x. d_OUT k x \\<noteq> \\<top>; (\\<epsilon>, h) \\<in> M;\n     \\<And>x. d_OUT h x \\<noteq> \\<top>; (\\<epsilon>, h) \\<in> M\\<rbrakk>\n    \\<Longrightarrow> d_OUT h x \\<noteq> \\<top>\n 3. \\<lbrakk>\\<And>x. d_OUT k x \\<noteq> \\<top>; (\\<epsilon>, h) \\<in> M;\n     \\<And>x. d_OUT h x \\<noteq> \\<top>; (\\<epsilon>, h) \\<in> M\\<rbrakk>\n    \\<Longrightarrow> d_OUT (\\<lambda>e. g e + (\\<Squnion> (snd ` M)) e) x -\n                      d_OUT h x =\n                      d_OUT g x +\n                      (d_OUT (\\<Squnion> (snd ` M)) x - d_OUT h x)", "apply(auto simp add: add_diff_eq_ennreal[symmetric] k_simps intro: add_increasing intro!: SUP_upper2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x. d_OUT k x \\<noteq> \\<top>;\n     \\<And>x. d_OUT h x \\<noteq> \\<top>; (\\<epsilon>, h) \\<in> M\\<rbrakk>\n    \\<Longrightarrow> d_OUT\n                       (\\<lambda>e. g e + (\\<Squnion>x\\<in>snd ` M. x e))\n                       x -\n                      d_OUT h x =\n                      d_OUT g x +\n                      (d_OUT (\\<Squnion> (snd ` M)) x - d_OUT h x)", "apply(subst d_OUT_add)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x. d_OUT k x \\<noteq> \\<top>;\n     \\<And>x. d_OUT h x \\<noteq> \\<top>; (\\<epsilon>, h) \\<in> M\\<rbrakk>\n    \\<Longrightarrow> d_OUT g x +\n                      d_OUT (\\<lambda>e. \\<Squnion>x\\<in>snd ` M. x e) x -\n                      d_OUT h x =\n                      d_OUT g x +\n                      (d_OUT (\\<Squnion> (snd ` M)) x - d_OUT h x)", "apply(auto simp add: add_diff_eq_ennreal[symmetric] k_simps intro: add_increasing intro!:)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x. d_OUT k x \\<noteq> \\<top>;\n     \\<And>x. d_OUT h x \\<noteq> \\<top>; (\\<epsilon>, h) \\<in> M\\<rbrakk>\n    \\<Longrightarrow> d_OUT g x +\n                      d_OUT (\\<lambda>e. \\<Squnion>x\\<in>snd ` M. x e) x -\n                      d_OUT h x =\n                      d_OUT g x +\n                      (d_OUT (\\<Squnion> (snd ` M)) x - d_OUT h x)", "apply(simp add: add_diff_eq_ennreal SUP_apply[abs_def])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x. d_OUT k x \\<noteq> \\<top>;\n     \\<And>x. d_OUT h x \\<noteq> \\<top>; (\\<epsilon>, h) \\<in> M\\<rbrakk>\n    \\<Longrightarrow> d_OUT g x +\n                      d_OUT (\\<lambda>e. \\<Squnion>x\\<in>snd ` M. x e) x -\n                      d_OUT h x =\n                      d_OUT g x +\n                      (d_OUT (\\<lambda>x. \\<Squnion>y\\<in>M. snd y x) x -\n                       d_OUT h x)", "apply(auto simp add: g'_def image_comp intro!: add_diff_eq_ennreal[symmetric] d_OUT_mono intro: SUP_upper2)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  d_OUT g' ?x = d_OUT g ?x + (d_OUT (\\<Squnion> (snd ` M)) ?x - d_OUT h ?x)\n\ngoal (1 subgoal):\n 1. hindered (\\<Gamma> \\<ominus> f) \\<Longrightarrow> False", "have IN_g': \"d_IN g' x = d_IN g x + (d_IN (Sup (snd ` M)) x - d_IN h x)\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN g' x = d_IN g x + (d_IN (\\<Squnion> (snd ` M)) x - d_IN h x)", "unfolding g'_simps[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN (\\<lambda>e. g e + (\\<Squnion> (snd ` M)) e - h e) x =\n    d_IN g x + (d_IN (\\<Squnion> (snd ` M)) x - d_IN h x)", "using \\<epsilon>h.currentD_finite_IN[OF k] hM h.currentD_finite_IN[OF h_curr] hM"], ["proof (prove)\nusing this:\n  d_IN k ?x \\<noteq> \\<top>\n  (\\<epsilon>, h) \\<in> M\n  d_IN h ?x \\<noteq> \\<top>\n  (\\<epsilon>, h) \\<in> M\n\ngoal (1 subgoal):\n 1. d_IN (\\<lambda>e. g e + (\\<Squnion> (snd ` M)) e - h e) x =\n    d_IN g x + (d_IN (\\<Squnion> (snd ` M)) x - d_IN h x)", "apply(subst d_IN_diff)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>\\<And>x. d_IN k x \\<noteq> \\<top>; (\\<epsilon>, h) \\<in> M;\n        \\<And>x. d_IN h x \\<noteq> \\<top>; (\\<epsilon>, h) \\<in> M\\<rbrakk>\n       \\<Longrightarrow> h (xa, x)\n                         \\<le> g (xa, x) + (\\<Squnion> (snd ` M)) (xa, x)\n 2. \\<lbrakk>\\<And>x. d_IN k x \\<noteq> \\<top>; (\\<epsilon>, h) \\<in> M;\n     \\<And>x. d_IN h x \\<noteq> \\<top>; (\\<epsilon>, h) \\<in> M\\<rbrakk>\n    \\<Longrightarrow> d_IN h x \\<noteq> \\<top>\n 3. \\<lbrakk>\\<And>x. d_IN k x \\<noteq> \\<top>; (\\<epsilon>, h) \\<in> M;\n     \\<And>x. d_IN h x \\<noteq> \\<top>; (\\<epsilon>, h) \\<in> M\\<rbrakk>\n    \\<Longrightarrow> d_IN (\\<lambda>e. g e + (\\<Squnion> (snd ` M)) e) x -\n                      d_IN h x =\n                      d_IN g x + (d_IN (\\<Squnion> (snd ` M)) x - d_IN h x)", "apply(auto simp add: add_diff_eq_ennreal[symmetric] k_simps intro: add_increasing intro!: SUP_upper2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x. d_IN k x \\<noteq> \\<top>;\n     \\<And>x. d_IN h x \\<noteq> \\<top>; (\\<epsilon>, h) \\<in> M\\<rbrakk>\n    \\<Longrightarrow> d_IN\n                       (\\<lambda>e. g e + (\\<Squnion>x\\<in>snd ` M. x e))\n                       x -\n                      d_IN h x =\n                      d_IN g x + (d_IN (\\<Squnion> (snd ` M)) x - d_IN h x)", "apply(subst d_IN_add)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x. d_IN k x \\<noteq> \\<top>;\n     \\<And>x. d_IN h x \\<noteq> \\<top>; (\\<epsilon>, h) \\<in> M\\<rbrakk>\n    \\<Longrightarrow> d_IN g x +\n                      d_IN (\\<lambda>e. \\<Squnion>x\\<in>snd ` M. x e) x -\n                      d_IN h x =\n                      d_IN g x + (d_IN (\\<Squnion> (snd ` M)) x - d_IN h x)", "apply(auto simp add: add_diff_eq_ennreal[symmetric] k_simps intro: add_increasing intro!: SUP_upper)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x. d_IN k x \\<noteq> \\<top>;\n     \\<And>x. d_IN h x \\<noteq> \\<top>; (\\<epsilon>, h) \\<in> M\\<rbrakk>\n    \\<Longrightarrow> d_IN g x +\n                      d_IN (\\<lambda>e. \\<Squnion>x\\<in>snd ` M. x e) x -\n                      d_IN h x =\n                      d_IN g x + (d_IN (\\<Squnion> (snd ` M)) x - d_IN h x)", "apply(auto simp add: g'_def SUP_apply[abs_def] image_comp intro!: add_diff_eq_ennreal[symmetric] d_IN_mono intro: SUP_upper2)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  d_IN g' ?x = d_IN g ?x + (d_IN (\\<Squnion> (snd ` M)) ?x - d_IN h ?x)\n\ngoal (1 subgoal):\n 1. hindered (\\<Gamma> \\<ominus> f) \\<Longrightarrow> False", "have h': \"current (\\<Gamma> \\<ominus> Sup (fst ` M)) h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. current (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)) h", "using hM"], ["proof (prove)\nusing this:\n  (\\<epsilon>, h) \\<in> M\n\ngoal (1 subgoal):\n 1. current (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)) h", "by(rule hM2)"], ["proof (state)\nthis:\n  current (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)) h\n\ngoal (1 subgoal):\n 1. hindered (\\<Gamma> \\<ominus> f) \\<Longrightarrow> False", "let ?\\<Gamma> = \"\\<Gamma> \\<ominus> ?\\<epsilon>h \\<ominus> k\""], ["proof (state)\ngoal (1 subgoal):\n 1. hindered (\\<Gamma> \\<ominus> f) \\<Longrightarrow> False", "interpret \\<Gamma>: web ?\\<Gamma>"], ["proof (prove)\ngoal (1 subgoal):\n 1. web (\\<Gamma> \\<ominus> plus_current \\<epsilon> h \\<ominus> k)", "using k"], ["proof (prove)\nusing this:\n  current (\\<Gamma> \\<ominus> plus_current \\<epsilon> h) k\n\ngoal (1 subgoal):\n 1. web (\\<Gamma> \\<ominus> plus_current \\<epsilon> h \\<ominus> k)", "by(rule \\<epsilon>h.web_minus_web)"], ["proof (state)\ngoal (1 subgoal):\n 1. hindered (\\<Gamma> \\<ominus> f) \\<Longrightarrow> False", "note [simp] = \\<epsilon>h.weight_minus_web[OF k] h.weight_minus_web[OF h_curr]\n        weight_minus_web[OF f_curr] SM1.weight_minus_web[OF h', simplified]"], ["proof (state)\nthis:\n  weight (\\<Gamma> \\<ominus> plus_current \\<epsilon> h \\<ominus> k) ?x =\n  (if ?x \\<in> A (\\<Gamma> \\<ominus> plus_current \\<epsilon> h)\n   then weight (\\<Gamma> \\<ominus> plus_current \\<epsilon> h) ?x -\n        d_OUT k ?x\n   else weight (\\<Gamma> \\<ominus> plus_current \\<epsilon> h) ?x -\n        d_IN k ?x)\n  weight (\\<Gamma> \\<ominus> \\<epsilon> \\<ominus> h) ?x =\n  (if ?x \\<in> A (\\<Gamma> \\<ominus> \\<epsilon>)\n   then weight (\\<Gamma> \\<ominus> \\<epsilon>) ?x - d_OUT h ?x\n   else weight (\\<Gamma> \\<ominus> \\<epsilon>) ?x - d_IN h ?x)\n  weight (\\<Gamma> \\<ominus> f) ?x =\n  (if ?x \\<in> A \\<Gamma> then weight \\<Gamma> ?x - d_OUT f ?x\n   else weight \\<Gamma> ?x - d_IN f ?x)\n  weight (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M) \\<ominus> h) ?x =\n  (if ?x \\<in> A \\<Gamma>\n   then weight (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)) ?x - d_OUT h ?x\n   else weight (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)) ?x - d_IN h ?x)\n\ngoal (1 subgoal):\n 1. hindered (\\<Gamma> \\<ominus> f) \\<Longrightarrow> False", "interpret \\<Omega>: countable_bipartite_web \"\\<Gamma> \\<ominus> f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. countable_bipartite_web (\\<Gamma> \\<ominus> f)", "using f_curr"], ["proof (prove)\nusing this:\n  current \\<Gamma> f\n\ngoal (1 subgoal):\n 1. countable_bipartite_web (\\<Gamma> \\<ominus> f)", "by(rule countable_bipartite_web_minus_web)"], ["proof (state)\ngoal (1 subgoal):\n 1. hindered (\\<Gamma> \\<ominus> f) \\<Longrightarrow> False", "have *: \"\\<Gamma> \\<ominus> f = \\<Gamma> \\<ominus> Sup (fst ` M) \\<ominus> Sup (snd ` M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma> \\<ominus> f =\n    \\<Gamma> \\<ominus> \\<Squnion> (fst ` M) \\<ominus> \\<Squnion> (snd ` M)", "unfolding f_def F_simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma> \\<ominus>\n    plus_current (\\<Squnion> (fst ` M)) (\\<Squnion> (snd ` M)) =\n    \\<Gamma> \\<ominus> \\<Squnion> (fst ` M) \\<ominus> \\<Squnion> (snd ` M)", "using SM1 current"], ["proof (prove)\nusing this:\n  current \\<Gamma> (\\<Squnion> (fst ` M))\n  current (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)) (\\<Squnion> (snd ` M))\n\ngoal (1 subgoal):\n 1. \\<Gamma> \\<ominus>\n    plus_current (\\<Squnion> (fst ` M)) (\\<Squnion> (snd ` M)) =\n    \\<Gamma> \\<ominus> \\<Squnion> (fst ` M) \\<ominus> \\<Squnion> (snd ` M)", "by(rule minus_plus_current)"], ["proof (state)\nthis:\n  \\<Gamma> \\<ominus> f =\n  \\<Gamma> \\<ominus> \\<Squnion> (fst ` M) \\<ominus> \\<Squnion> (snd ` M)\n\ngoal (1 subgoal):\n 1. hindered (\\<Gamma> \\<ominus> f) \\<Longrightarrow> False", "have OUT_\\<epsilon>k: \"d_OUT (Sup (fst ` M)) x = d_OUT \\<epsilon> x + d_OUT k x\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT (\\<Squnion> (fst ` M)) x = d_OUT \\<epsilon> x + d_OUT k x", "using OUT1'[of x] currentD_finite_OUT[OF \\<epsilon>] hM"], ["proof (prove)\nusing this:\n  d_OUT (\\<Squnion> (fst ` M)) x =\n  (if x = a then \\<Squnion>(\\<epsilon>, h)\\<in>M. d_OUT \\<epsilon> a else 0)\n  d_OUT \\<epsilon> ?x \\<noteq> \\<top>\n  (\\<epsilon>, h) \\<in> M\n\ngoal (1 subgoal):\n 1. d_OUT (\\<Squnion> (fst ` M)) x = d_OUT \\<epsilon> x + d_OUT k x", "by(auto simp add: OUT_k OUT_\\<epsilon> add_diff_self_ennreal SUP_upper2)"], ["proof (state)\nthis:\n  d_OUT (\\<Squnion> (fst ` M)) ?x = d_OUT \\<epsilon> ?x + d_OUT k ?x\n\ngoal (1 subgoal):\n 1. hindered (\\<Gamma> \\<ominus> f) \\<Longrightarrow> False", "have IN_\\<epsilon>k: \"d_IN (Sup (fst ` M)) x = d_IN \\<epsilon> x + d_IN k x\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN (\\<Squnion> (fst ` M)) x = d_IN \\<epsilon> x + d_IN k x", "using IN1'[of x] currentD_finite_IN[OF \\<epsilon>] currentD_outside[OF \\<epsilon>] currentD_outside[OF \\<epsilon>_curr]"], ["proof (prove)\nusing this:\n  d_IN (\\<Squnion> (fst ` M)) x =\n  (\\<Squnion>(\\<epsilon>, h)\\<in>M. \\<epsilon> (a, x))\n  d_IN \\<epsilon> ?x \\<noteq> \\<top>\n  \\<not> edge \\<Gamma> ?x ?y \\<Longrightarrow> \\<epsilon> (?x, ?y) = 0\n  \\<lbrakk>(?f, ?h1) \\<in> Field leq; \\<not> edge \\<Gamma> ?x ?y\\<rbrakk>\n  \\<Longrightarrow> ?f (?x, ?y) = 0\n\ngoal (1 subgoal):\n 1. d_IN (\\<Squnion> (fst ` M)) x = d_IN \\<epsilon> x + d_IN k x", "by(auto simp add: IN_k IN_\\<epsilon>[OF Field] add_diff_self_ennreal split_beta nempty image_comp\n                dest!: Chains_FieldD[OF M] intro!: SUP_eq_const intro: SUP_upper2[OF hM])"], ["proof (state)\nthis:\n  d_IN (\\<Squnion> (fst ` M)) ?x = d_IN \\<epsilon> ?x + d_IN k ?x\n\ngoal (1 subgoal):\n 1. hindered (\\<Gamma> \\<ominus> f) \\<Longrightarrow> False", "have **: \"?\\<Gamma> = \\<Gamma> \\<ominus> Sup (fst ` M) \\<ominus> h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma> \\<ominus> plus_current \\<epsilon> h \\<ominus> k =\n    \\<Gamma> \\<ominus> \\<Squnion> (fst ` M) \\<ominus> h", "proof(rule web.equality)"], ["proof (state)\ngoal (5 subgoals):\n 1. edge (\\<Gamma> \\<ominus> plus_current \\<epsilon> h \\<ominus> k) =\n    edge (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M) \\<ominus> h)\n 2. weight (\\<Gamma> \\<ominus> plus_current \\<epsilon> h \\<ominus> k) =\n    weight (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M) \\<ominus> h)\n 3. A (\\<Gamma> \\<ominus> plus_current \\<epsilon> h \\<ominus> k) =\n    A (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M) \\<ominus> h)\n 4. B (\\<Gamma> \\<ominus> plus_current \\<epsilon> h \\<ominus> k) =\n    B (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M) \\<ominus> h)\n 5. web.more (\\<Gamma> \\<ominus> plus_current \\<epsilon> h \\<ominus> k) =\n    web.more (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M) \\<ominus> h)", "show \"weight ?\\<Gamma> = weight (\\<Gamma> \\<ominus> Sup (fst ` M) \\<ominus> h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. weight (\\<Gamma> \\<ominus> plus_current \\<epsilon> h \\<ominus> k) =\n    weight (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M) \\<ominus> h)", "using OUT_\\<epsilon>k OUT_\\<epsilon>h currentD_finite_OUT[OF \\<epsilon>] IN_\\<epsilon>k IN_\\<epsilon>h currentD_finite_IN[OF \\<epsilon>]"], ["proof (prove)\nusing this:\n  d_OUT (\\<Squnion> (fst ` M)) ?x = d_OUT \\<epsilon> ?x + d_OUT k ?x\n  d_OUT (plus_current \\<epsilon> h) ?x = d_OUT \\<epsilon> ?x + d_OUT h ?x\n  d_OUT \\<epsilon> ?x \\<noteq> \\<top>\n  d_IN (\\<Squnion> (fst ` M)) ?x = d_IN \\<epsilon> ?x + d_IN k ?x\n  d_IN (plus_current \\<epsilon> h) ?x = d_IN \\<epsilon> ?x + d_IN h ?x\n  d_IN \\<epsilon> ?x \\<noteq> \\<top>\n\ngoal (1 subgoal):\n 1. weight (\\<Gamma> \\<ominus> plus_current \\<epsilon> h \\<ominus> k) =\n    weight (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M) \\<ominus> h)", "by(auto simp add: diff_add_eq_diff_diff_swap_ennreal diff_diff_commute_ennreal)"], ["proof (state)\nthis:\n  weight (\\<Gamma> \\<ominus> plus_current \\<epsilon> h \\<ominus> k) =\n  weight (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M) \\<ominus> h)\n\ngoal (4 subgoals):\n 1. edge (\\<Gamma> \\<ominus> plus_current \\<epsilon> h \\<ominus> k) =\n    edge (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M) \\<ominus> h)\n 2. A (\\<Gamma> \\<ominus> plus_current \\<epsilon> h \\<ominus> k) =\n    A (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M) \\<ominus> h)\n 3. B (\\<Gamma> \\<ominus> plus_current \\<epsilon> h \\<ominus> k) =\n    B (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M) \\<ominus> h)\n 4. web.more (\\<Gamma> \\<ominus> plus_current \\<epsilon> h \\<ominus> k) =\n    web.more (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M) \\<ominus> h)", "qed simp_all"], ["proof (state)\nthis:\n  \\<Gamma> \\<ominus> plus_current \\<epsilon> h \\<ominus> k =\n  \\<Gamma> \\<ominus> \\<Squnion> (fst ` M) \\<ominus> h\n\ngoal (1 subgoal):\n 1. hindered (\\<Gamma> \\<ominus> f) \\<Longrightarrow> False", "have g'_alt: \"g' = plus_current (Sup (snd ` M)) g - h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g' = plus_current (\\<Squnion> (snd ` M)) g - h", "by(simp add: fun_eq_iff g'_simps add_diff_eq_ennreal add.commute)"], ["proof (state)\nthis:\n  g' = plus_current (\\<Squnion> (snd ` M)) g - h\n\ngoal (1 subgoal):\n 1. hindered (\\<Gamma> \\<ominus> f) \\<Longrightarrow> False", "have \"current (\\<Gamma> \\<ominus> Sup (fst ` M)) (plus_current (Sup (snd ` M)) g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. current (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M))\n     (plus_current (\\<Squnion> (snd ` M)) g)", "using current g"], ["proof (prove)\nusing this:\n  current (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)) (\\<Squnion> (snd ` M))\n  current (\\<Gamma> \\<ominus> f) g\n\ngoal (1 subgoal):\n 1. current (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M))\n     (plus_current (\\<Squnion> (snd ` M)) g)", "unfolding *"], ["proof (prove)\nusing this:\n  current (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)) (\\<Squnion> (snd ` M))\n  current\n   (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M) \\<ominus> \\<Squnion> (snd ` M))\n   g\n\ngoal (1 subgoal):\n 1. current (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M))\n     (plus_current (\\<Squnion> (snd ` M)) g)", "by(rule SM1.current_plus_current_minus)"], ["proof (state)\nthis:\n  current (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M))\n   (plus_current (\\<Squnion> (snd ` M)) g)\n\ngoal (1 subgoal):\n 1. hindered (\\<Gamma> \\<ominus> f) \\<Longrightarrow> False", "hence g': \"current ?\\<Gamma> g'\""], ["proof (prove)\nusing this:\n  current (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M))\n   (plus_current (\\<Squnion> (snd ` M)) g)\n\ngoal (1 subgoal):\n 1. current (\\<Gamma> \\<ominus> plus_current \\<epsilon> h \\<ominus> k) g'", "unfolding * ** g'_alt"], ["proof (prove)\nusing this:\n  current (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M))\n   (plus_current (\\<Squnion> (snd ` M)) g)\n\ngoal (1 subgoal):\n 1. current (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M) \\<ominus> h)\n     (plus_current (\\<Squnion> (snd ` M)) g - h)", "using hM2[OF hM]"], ["proof (prove)\nusing this:\n  current (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M))\n   (plus_current (\\<Squnion> (snd ` M)) g)\n  current (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)) h\n\ngoal (1 subgoal):\n 1. current (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M) \\<ominus> h)\n     (plus_current (\\<Squnion> (snd ` M)) g - h)", "by(rule SM1.current_minus)(auto intro!: add_increasing2 SUP_upper2 hM)"], ["proof (state)\nthis:\n  current (\\<Gamma> \\<ominus> plus_current \\<epsilon> h \\<ominus> k) g'\n\ngoal (1 subgoal):\n 1. hindered (\\<Gamma> \\<ominus> f) \\<Longrightarrow> False", "have \"wave (\\<Gamma> \\<ominus> Sup (fst ` M)) (plus_current (Sup (snd ` M)) g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wave (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M))\n     (plus_current (\\<Squnion> (snd ` M)) g)", "using current wave g g_w"], ["proof (prove)\nusing this:\n  current (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)) (\\<Squnion> (snd ` M))\n  wave (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)) (\\<Squnion> (snd ` M))\n  current (\\<Gamma> \\<ominus> f) g\n  wave (\\<Gamma> \\<ominus> f) g\n\ngoal (1 subgoal):\n 1. wave (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M))\n     (plus_current (\\<Squnion> (snd ` M)) g)", "unfolding *"], ["proof (prove)\nusing this:\n  current (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)) (\\<Squnion> (snd ` M))\n  wave (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)) (\\<Squnion> (snd ` M))\n  current\n   (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M) \\<ominus> \\<Squnion> (snd ` M))\n   g\n  wave\n   (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M) \\<ominus> \\<Squnion> (snd ` M))\n   g\n\ngoal (1 subgoal):\n 1. wave (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M))\n     (plus_current (\\<Squnion> (snd ` M)) g)", "by(rule SM1.wave_plus_current_minus)"], ["proof (state)\nthis:\n  wave (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M))\n   (plus_current (\\<Squnion> (snd ` M)) g)\n\ngoal (1 subgoal):\n 1. hindered (\\<Gamma> \\<ominus> f) \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  wave (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M))\n   (plus_current (\\<Squnion> (snd ` M)) g)", "have g'_w: \"wave ?\\<Gamma> g'\""], ["proof (prove)\nusing this:\n  wave (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M))\n   (plus_current (\\<Squnion> (snd ` M)) g)\n\ngoal (1 subgoal):\n 1. wave (\\<Gamma> \\<ominus> plus_current \\<epsilon> h \\<ominus> k) g'", "unfolding * ** g'_alt"], ["proof (prove)\nusing this:\n  wave (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M))\n   (plus_current (\\<Squnion> (snd ` M)) g)\n\ngoal (1 subgoal):\n 1. wave (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M) \\<ominus> h)\n     (plus_current (\\<Squnion> (snd ` M)) g - h)", "using hM2[OF hM]"], ["proof (prove)\nusing this:\n  wave (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M))\n   (plus_current (\\<Squnion> (snd ` M)) g)\n  current (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M)) h\n\ngoal (1 subgoal):\n 1. wave (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M) \\<ominus> h)\n     (plus_current (\\<Squnion> (snd ` M)) g - h)", "by(rule SM1.wave_minus)(auto intro!: add_increasing2 SUP_upper2 hM)"], ["proof (state)\nthis:\n  wave (\\<Gamma> \\<ominus> plus_current \\<epsilon> h \\<ominus> k) g'\n\ngoal (1 subgoal):\n 1. hindered (\\<Gamma> \\<ominus> f) \\<Longrightarrow> False", "have \"hindrance_by ?\\<Gamma> g' q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hindrance_by (\\<Gamma> \\<ominus> plus_current \\<epsilon> h \\<ominus> k)\n     g' q", "proof"], ["proof (state)\ngoal (4 subgoals):\n 1. ?a \\<in> A (\\<Gamma> \\<ominus> plus_current \\<epsilon> h \\<ominus> k)\n 2. ?a \\<notin> \\<E>\\<^bsub>\\<Gamma> \\<ominus> plus_current \\<epsilon> h \\<ominus> k\\<^esub>\n                 (TER\\<^bsub>\\<Gamma> \\<ominus> plus_current \\<epsilon> h \\<ominus> k\\<^esub>\n                   g')\n 3. d_OUT g' ?a\n    < weight (\\<Gamma> \\<ominus> plus_current \\<epsilon> h \\<ominus> k) ?a\n 4. q < weight (\\<Gamma> \\<ominus> plus_current \\<epsilon> h \\<ominus> k)\n         ?a -\n        d_OUT g' ?a", "show \"z \\<in> A ?\\<Gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z \\<in> A (\\<Gamma> \\<ominus> plus_current \\<epsilon> h \\<ominus> k)", "using z"], ["proof (prove)\nusing this:\n  z \\<in> A \\<Gamma>\n\ngoal (1 subgoal):\n 1. z \\<in> A (\\<Gamma> \\<ominus> plus_current \\<epsilon> h \\<ominus> k)", "by simp"], ["proof (state)\nthis:\n  z \\<in> A (\\<Gamma> \\<ominus> plus_current \\<epsilon> h \\<ominus> k)\n\ngoal (3 subgoals):\n 1. z \\<notin> \\<E>\\<^bsub>\\<Gamma> \\<ominus> plus_current \\<epsilon> h \\<ominus> k\\<^esub>\n                (TER\\<^bsub>\\<Gamma> \\<ominus> plus_current \\<epsilon> h \\<ominus> k\\<^esub>\n                  g')\n 2. d_OUT g' z\n    < weight (\\<Gamma> \\<ominus> plus_current \\<epsilon> h \\<ominus> k) z\n 3. q < weight (\\<Gamma> \\<ominus> plus_current \\<epsilon> h \\<ominus> k)\n         z -\n        d_OUT g' z", "show \"z \\<notin> \\<E>\\<^bsub>?\\<Gamma>\\<^esub> (TER\\<^bsub>?\\<Gamma>\\<^esub> g')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z \\<notin> \\<E>\\<^bsub>\\<Gamma> \\<ominus> plus_current \\<epsilon> h \\<ominus> k\\<^esub>\n                (TER\\<^bsub>\\<Gamma> \\<ominus> plus_current \\<epsilon> h \\<ominus> k\\<^esub>\n                  g')", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. z \\<in> \\<E>\\<^bsub>\\<Gamma> \\<ominus> plus_current \\<epsilon> h \\<ominus> k\\<^esub>\n             (TER\\<^bsub>\\<Gamma> \\<ominus> plus_current \\<epsilon> h \\<ominus> k\\<^esub>\n               g') \\<Longrightarrow>\n    False", "assume \"z \\<in> \\<E>\\<^bsub>?\\<Gamma>\\<^esub> (TER\\<^bsub>?\\<Gamma>\\<^esub> g')\""], ["proof (state)\nthis:\n  z \\<in> \\<E>\\<^bsub>\\<Gamma> \\<ominus> plus_current \\<epsilon> h \\<ominus> k\\<^esub>\n           (TER\\<^bsub>\\<Gamma> \\<ominus> plus_current \\<epsilon> h \\<ominus> k\\<^esub>\n             g')\n\ngoal (1 subgoal):\n 1. z \\<in> \\<E>\\<^bsub>\\<Gamma> \\<ominus> plus_current \\<epsilon> h \\<ominus> k\\<^esub>\n             (TER\\<^bsub>\\<Gamma> \\<ominus> plus_current \\<epsilon> h \\<ominus> k\\<^esub>\n               g') \\<Longrightarrow>\n    False", "hence OUT_z: \"d_OUT g' z = 0\"\n            and ess: \"essential ?\\<Gamma> (B \\<Gamma>) (TER\\<^bsub>?\\<Gamma>\\<^esub> g') z\""], ["proof (prove)\nusing this:\n  z \\<in> \\<E>\\<^bsub>\\<Gamma> \\<ominus> plus_current \\<epsilon> h \\<ominus> k\\<^esub>\n           (TER\\<^bsub>\\<Gamma> \\<ominus> plus_current \\<epsilon> h \\<ominus> k\\<^esub>\n             g')\n\ngoal (1 subgoal):\n 1. d_OUT g' z = 0 &&&\n    essential (\\<Gamma> \\<ominus> plus_current \\<epsilon> h \\<ominus> k)\n     (B \\<Gamma>)\n     (TER\\<^bsub>\\<Gamma> \\<ominus> plus_current \\<epsilon> h \\<ominus> k\\<^esub>\n       g')\n     z", "by(simp_all add: SINK.simps)"], ["proof (state)\nthis:\n  d_OUT g' z = 0\n  essential (\\<Gamma> \\<ominus> plus_current \\<epsilon> h \\<ominus> k)\n   (B \\<Gamma>)\n   (TER\\<^bsub>\\<Gamma> \\<ominus> plus_current \\<epsilon> h \\<ominus> k\\<^esub>\n     g')\n   z\n\ngoal (1 subgoal):\n 1. z \\<in> \\<E>\\<^bsub>\\<Gamma> \\<ominus> plus_current \\<epsilon> h \\<ominus> k\\<^esub>\n             (TER\\<^bsub>\\<Gamma> \\<ominus> plus_current \\<epsilon> h \\<ominus> k\\<^esub>\n               g') \\<Longrightarrow>\n    False", "from ess"], ["proof (chain)\npicking this:\n  essential (\\<Gamma> \\<ominus> plus_current \\<epsilon> h \\<ominus> k)\n   (B \\<Gamma>)\n   (TER\\<^bsub>\\<Gamma> \\<ominus> plus_current \\<epsilon> h \\<ominus> k\\<^esub>\n     g')\n   z", "obtain p y where p: \"path \\<Gamma> z p y\" and y: \"y \\<in> B \\<Gamma>\"\n            and bypass: \"\\<And>z. z \\<in> set p \\<Longrightarrow> z \\<notin> RF (TER\\<^bsub>?\\<Gamma>\\<^esub> g')\""], ["proof (prove)\nusing this:\n  essential (\\<Gamma> \\<ominus> plus_current \\<epsilon> h \\<ominus> k)\n   (B \\<Gamma>)\n   (TER\\<^bsub>\\<Gamma> \\<ominus> plus_current \\<epsilon> h \\<ominus> k\\<^esub>\n     g')\n   z\n\ngoal (1 subgoal):\n 1. (\\<And>p y.\n        \\<lbrakk>path \\<Gamma> z p y; y \\<in> B \\<Gamma>;\n         \\<And>z.\n            z \\<in> set p \\<Longrightarrow>\n            z \\<notin> RF (TER\\<^bsub>\\<Gamma> \\<ominus> plus_current \\<epsilon> h \\<ominus> k\\<^esub>\n                            g')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(rule essentialE_RF) auto"], ["proof (state)\nthis:\n  path \\<Gamma> z p y\n  y \\<in> B \\<Gamma>\n  ?z \\<in> set p \\<Longrightarrow>\n  ?z \\<notin> RF (TER\\<^bsub>\\<Gamma> \\<ominus> plus_current \\<epsilon> h \\<ominus> k\\<^esub>\n                   g')\n\ngoal (1 subgoal):\n 1. z \\<in> \\<E>\\<^bsub>\\<Gamma> \\<ominus> plus_current \\<epsilon> h \\<ominus> k\\<^esub>\n             (TER\\<^bsub>\\<Gamma> \\<ominus> plus_current \\<epsilon> h \\<ominus> k\\<^esub>\n               g') \\<Longrightarrow>\n    False", "from y"], ["proof (chain)\npicking this:\n  y \\<in> B \\<Gamma>", "have y': \"y \\<notin> A \\<Gamma>\""], ["proof (prove)\nusing this:\n  y \\<in> B \\<Gamma>\n\ngoal (1 subgoal):\n 1. y \\<notin> A \\<Gamma>", "using disjoint"], ["proof (prove)\nusing this:\n  y \\<in> B \\<Gamma>\n  A \\<Gamma> \\<inter> B \\<Gamma> = {}\n\ngoal (1 subgoal):\n 1. y \\<notin> A \\<Gamma>", "by blast"], ["proof (state)\nthis:\n  y \\<notin> A \\<Gamma>\n\ngoal (1 subgoal):\n 1. z \\<in> \\<E>\\<^bsub>\\<Gamma> \\<ominus> plus_current \\<epsilon> h \\<ominus> k\\<^esub>\n             (TER\\<^bsub>\\<Gamma> \\<ominus> plus_current \\<epsilon> h \\<ominus> k\\<^esub>\n               g') \\<Longrightarrow>\n    False", "from p z y"], ["proof (chain)\npicking this:\n  path \\<Gamma> z p y\n  z \\<in> A \\<Gamma>\n  y \\<in> B \\<Gamma>", "obtain py: \"p = [y]\" and edge: \"edge \\<Gamma> z y\""], ["proof (prove)\nusing this:\n  path \\<Gamma> z p y\n  z \\<in> A \\<Gamma>\n  y \\<in> B \\<Gamma>\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>p = [y]; edge \\<Gamma> z y\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using disjoint"], ["proof (prove)\nusing this:\n  path \\<Gamma> z p y\n  z \\<in> A \\<Gamma>\n  y \\<in> B \\<Gamma>\n  A \\<Gamma> \\<inter> B \\<Gamma> = {}\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>p = [y]; edge \\<Gamma> z y\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases)(auto 4 3 elim: rtrancl_path.cases dest: bipartite_E)"], ["proof (state)\nthis:\n  p = [y]\n  edge \\<Gamma> z y\n\ngoal (1 subgoal):\n 1. z \\<in> \\<E>\\<^bsub>\\<Gamma> \\<ominus> plus_current \\<epsilon> h \\<ominus> k\\<^esub>\n             (TER\\<^bsub>\\<Gamma> \\<ominus> plus_current \\<epsilon> h \\<ominus> k\\<^esub>\n               g') \\<Longrightarrow>\n    False", "hence yRF: \"y \\<notin> RF (TER\\<^bsub>?\\<Gamma>\\<^esub> g')\""], ["proof (prove)\nusing this:\n  p = [y]\n  edge \\<Gamma> z y\n\ngoal (1 subgoal):\n 1. y \\<notin> RF (TER\\<^bsub>\\<Gamma> \\<ominus> plus_current \\<epsilon> h \\<ominus> k\\<^esub>\n                    g')", "using bypass[of y]"], ["proof (prove)\nusing this:\n  p = [y]\n  edge \\<Gamma> z y\n  y \\<in> set p \\<Longrightarrow>\n  y \\<notin> RF (TER\\<^bsub>\\<Gamma> \\<ominus> plus_current \\<epsilon> h \\<ominus> k\\<^esub>\n                  g')\n\ngoal (1 subgoal):\n 1. y \\<notin> RF (TER\\<^bsub>\\<Gamma> \\<ominus> plus_current \\<epsilon> h \\<ominus> k\\<^esub>\n                    g')", "by(auto)"], ["proof (state)\nthis:\n  y \\<notin> RF (TER\\<^bsub>\\<Gamma> \\<ominus> plus_current \\<epsilon> h \\<ominus> k\\<^esub>\n                  g')\n\ngoal (1 subgoal):\n 1. z \\<in> \\<E>\\<^bsub>\\<Gamma> \\<ominus> plus_current \\<epsilon> h \\<ominus> k\\<^esub>\n             (TER\\<^bsub>\\<Gamma> \\<ominus> plus_current \\<epsilon> h \\<ominus> k\\<^esub>\n               g') \\<Longrightarrow>\n    False", "with wave_not_RF_IN_zero[OF g' g'_w, of y]"], ["proof (chain)\npicking this:\n  y \\<notin> RF\\<^bsub>\\<Gamma> \\<ominus> plus_current \\<epsilon> h \\<ominus> k\\<^esub>\n              (TER\\<^bsub>\\<Gamma> \\<ominus> plus_current \\<epsilon> h \\<ominus> k\\<^esub>\n                g') \\<Longrightarrow>\n  d_IN g' y = 0\n  y \\<notin> RF (TER\\<^bsub>\\<Gamma> \\<ominus> plus_current \\<epsilon> h \\<ominus> k\\<^esub>\n                  g')", "have IN_g'_y: \"d_IN g' y = 0\""], ["proof (prove)\nusing this:\n  y \\<notin> RF\\<^bsub>\\<Gamma> \\<ominus> plus_current \\<epsilon> h \\<ominus> k\\<^esub>\n              (TER\\<^bsub>\\<Gamma> \\<ominus> plus_current \\<epsilon> h \\<ominus> k\\<^esub>\n                g') \\<Longrightarrow>\n  d_IN g' y = 0\n  y \\<notin> RF (TER\\<^bsub>\\<Gamma> \\<ominus> plus_current \\<epsilon> h \\<ominus> k\\<^esub>\n                  g')\n\ngoal (1 subgoal):\n 1. d_IN g' y = 0", "by(auto intro: roofed_greaterI)"], ["proof (state)\nthis:\n  d_IN g' y = 0\n\ngoal (1 subgoal):\n 1. z \\<in> \\<E>\\<^bsub>\\<Gamma> \\<ominus> plus_current \\<epsilon> h \\<ominus> k\\<^esub>\n             (TER\\<^bsub>\\<Gamma> \\<ominus> plus_current \\<epsilon> h \\<ominus> k\\<^esub>\n               g') \\<Longrightarrow>\n    False", "with yRF y y'"], ["proof (chain)\npicking this:\n  y \\<notin> RF (TER\\<^bsub>\\<Gamma> \\<ominus> plus_current \\<epsilon> h \\<ominus> k\\<^esub>\n                  g')\n  y \\<in> B \\<Gamma>\n  y \\<notin> A \\<Gamma>\n  d_IN g' y = 0", "have w_y: \"weight ?\\<Gamma> y > 0\""], ["proof (prove)\nusing this:\n  y \\<notin> RF (TER\\<^bsub>\\<Gamma> \\<ominus> plus_current \\<epsilon> h \\<ominus> k\\<^esub>\n                  g')\n  y \\<in> B \\<Gamma>\n  y \\<notin> A \\<Gamma>\n  d_IN g' y = 0\n\ngoal (1 subgoal):\n 1. 0 < weight (\\<Gamma> \\<ominus> plus_current \\<epsilon> h \\<ominus> k) y", "using currentD_OUT[OF g', of y]"], ["proof (prove)\nusing this:\n  y \\<notin> RF (TER\\<^bsub>\\<Gamma> \\<ominus> plus_current \\<epsilon> h \\<ominus> k\\<^esub>\n                  g')\n  y \\<in> B \\<Gamma>\n  y \\<notin> A \\<Gamma>\n  d_IN g' y = 0\n  y \\<in> B (\\<Gamma> \\<ominus> plus_current \\<epsilon> h \\<ominus>\n             k) \\<Longrightarrow>\n  d_OUT g' y = 0\n\ngoal (1 subgoal):\n 1. 0 < weight (\\<Gamma> \\<ominus> plus_current \\<epsilon> h \\<ominus> k) y", "by(auto simp add: RF_in_B currentD_SAT[OF g'] SINK.simps zero_less_iff_neq_zero)"], ["proof (state)\nthis:\n  0 < weight (\\<Gamma> \\<ominus> plus_current \\<epsilon> h \\<ominus> k) y\n\ngoal (1 subgoal):\n 1. z \\<in> \\<E>\\<^bsub>\\<Gamma> \\<ominus> plus_current \\<epsilon> h \\<ominus> k\\<^esub>\n             (TER\\<^bsub>\\<Gamma> \\<ominus> plus_current \\<epsilon> h \\<ominus> k\\<^esub>\n               g') \\<Longrightarrow>\n    False", "have \"y \\<notin> SAT (\\<Gamma> \\<ominus> f) g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<notin> SAT (\\<Gamma> \\<ominus> f) g", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. y \\<in> SAT (\\<Gamma> \\<ominus> f) g \\<Longrightarrow> False", "assume \"y \\<in> SAT (\\<Gamma> \\<ominus> f) g\""], ["proof (state)\nthis:\n  y \\<in> SAT (\\<Gamma> \\<ominus> f) g\n\ngoal (1 subgoal):\n 1. y \\<in> SAT (\\<Gamma> \\<ominus> f) g \\<Longrightarrow> False", "with y disjoint"], ["proof (chain)\npicking this:\n  y \\<in> B \\<Gamma>\n  A \\<Gamma> \\<inter> B \\<Gamma> = {}\n  y \\<in> SAT (\\<Gamma> \\<ominus> f) g", "have IN_g_y: \"d_IN g y = weight (\\<Gamma> \\<ominus> f) y\""], ["proof (prove)\nusing this:\n  y \\<in> B \\<Gamma>\n  A \\<Gamma> \\<inter> B \\<Gamma> = {}\n  y \\<in> SAT (\\<Gamma> \\<ominus> f) g\n\ngoal (1 subgoal):\n 1. d_IN g y = weight (\\<Gamma> \\<ominus> f) y", "by(auto simp add: currentD_SAT[OF g])"], ["proof (state)\nthis:\n  d_IN g y = weight (\\<Gamma> \\<ominus> f) y\n\ngoal (1 subgoal):\n 1. y \\<in> SAT (\\<Gamma> \\<ominus> f) g \\<Longrightarrow> False", "have \"0 < weight \\<Gamma> y - d_IN (\\<Squnion>x\\<in>M. fst x) y - d_IN h y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < weight \\<Gamma> y - d_IN (\\<Squnion> (fst ` M)) y - d_IN h y", "using y' w_y"], ["proof (prove)\nusing this:\n  y \\<notin> A \\<Gamma>\n  0 < weight (\\<Gamma> \\<ominus> plus_current \\<epsilon> h \\<ominus> k) y\n\ngoal (1 subgoal):\n 1. 0 < weight \\<Gamma> y - d_IN (\\<Squnion> (fst ` M)) y - d_IN h y", "unfolding **"], ["proof (prove)\nusing this:\n  y \\<notin> A \\<Gamma>\n  0 < weight (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M) \\<ominus> h) y\n\ngoal (1 subgoal):\n 1. 0 < weight \\<Gamma> y - d_IN (\\<Squnion> (fst ` M)) y - d_IN h y", "by auto"], ["proof (state)\nthis:\n  0 < weight \\<Gamma> y - d_IN (\\<Squnion> (fst ` M)) y - d_IN h y\n\ngoal (1 subgoal):\n 1. y \\<in> SAT (\\<Gamma> \\<ominus> f) g \\<Longrightarrow> False", "have \"d_IN g' y > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < d_IN g' y", "using y' w_y hM"], ["proof (prove)\nusing this:\n  y \\<notin> A \\<Gamma>\n  0 < weight (\\<Gamma> \\<ominus> plus_current \\<epsilon> h \\<ominus> k) y\n  (\\<epsilon>, h) \\<in> M\n\ngoal (1 subgoal):\n 1. 0 < d_IN g' y", "unfolding **"], ["proof (prove)\nusing this:\n  y \\<notin> A \\<Gamma>\n  0 < weight (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M) \\<ominus> h) y\n  (\\<epsilon>, h) \\<in> M\n\ngoal (1 subgoal):\n 1. 0 < d_IN g' y", "apply(simp add: IN_g' IN_f IN_g_y diff_add_eq_diff_diff_swap_ennreal)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y \\<notin> A \\<Gamma>;\n     0 < weight \\<Gamma> y - d_IN (\\<Squnion> (fst ` M)) y - d_IN h y;\n     (\\<epsilon>, h) \\<in> M\\<rbrakk>\n    \\<Longrightarrow> 0 < weight \\<Gamma> y -\n                          d_IN (\\<Squnion> (fst ` M)) y -\n                          d_IN (\\<Squnion> (snd ` M)) y +\n                          (d_IN (\\<Squnion> (snd ` M)) y - d_IN h y)", "apply(subst add_diff_eq_ennreal)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>y \\<notin> A \\<Gamma>;\n     0 < weight \\<Gamma> y - d_IN (\\<Squnion> (fst ` M)) y - d_IN h y;\n     (\\<epsilon>, h) \\<in> M\\<rbrakk>\n    \\<Longrightarrow> d_IN h y \\<le> d_IN (\\<Squnion> (snd ` M)) y\n 2. \\<lbrakk>y \\<notin> A \\<Gamma>;\n     0 < weight \\<Gamma> y - d_IN (\\<Squnion> (fst ` M)) y - d_IN h y;\n     (\\<epsilon>, h) \\<in> M\\<rbrakk>\n    \\<Longrightarrow> 0 < weight \\<Gamma> y -\n                          d_IN (\\<Squnion> (fst ` M)) y -\n                          d_IN (\\<Squnion> (snd ` M)) y +\n                          d_IN (\\<Squnion> (snd ` M)) y -\n                          d_IN h y", "apply(auto intro!: SUP_upper2 d_IN_mono simp: diff_add_self_ennreal diff_gt_0_iff_gt_ennreal)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  0 < d_IN g' y\n\ngoal (1 subgoal):\n 1. y \\<in> SAT (\\<Gamma> \\<ominus> f) g \\<Longrightarrow> False", "with IN_g'_y"], ["proof (chain)\npicking this:\n  d_IN g' y = 0\n  0 < d_IN g' y", "show False"], ["proof (prove)\nusing this:\n  d_IN g' y = 0\n  0 < d_IN g' y\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  y \\<notin> SAT (\\<Gamma> \\<ominus> f) g\n\ngoal (1 subgoal):\n 1. z \\<in> \\<E>\\<^bsub>\\<Gamma> \\<ominus> plus_current \\<epsilon> h \\<ominus> k\\<^esub>\n             (TER\\<^bsub>\\<Gamma> \\<ominus> plus_current \\<epsilon> h \\<ominus> k\\<^esub>\n               g') \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  y \\<notin> SAT (\\<Gamma> \\<ominus> f) g", "have \"y \\<notin> TER\\<^bsub>\\<Gamma> \\<ominus> f\\<^esub> g\""], ["proof (prove)\nusing this:\n  y \\<notin> SAT (\\<Gamma> \\<ominus> f) g\n\ngoal (1 subgoal):\n 1. y \\<notin> TER\\<^bsub>\\<Gamma> \\<ominus> f\\<^esub> g", "by simp"], ["proof (state)\nthis:\n  y \\<notin> TER\\<^bsub>\\<Gamma> \\<ominus> f\\<^esub> g\n\ngoal (1 subgoal):\n 1. z \\<in> \\<E>\\<^bsub>\\<Gamma> \\<ominus> plus_current \\<epsilon> h \\<ominus> k\\<^esub>\n             (TER\\<^bsub>\\<Gamma> \\<ominus> plus_current \\<epsilon> h \\<ominus> k\\<^esub>\n               g') \\<Longrightarrow>\n    False", "with p y py"], ["proof (chain)\npicking this:\n  path \\<Gamma> z p y\n  y \\<in> B \\<Gamma>\n  p = [y]\n  y \\<notin> TER\\<^bsub>\\<Gamma> \\<ominus> f\\<^esub> g", "have \"essential \\<Gamma> (B \\<Gamma>) (TER\\<^bsub>\\<Gamma> \\<ominus> f\\<^esub> g) z\""], ["proof (prove)\nusing this:\n  path \\<Gamma> z p y\n  y \\<in> B \\<Gamma>\n  p = [y]\n  y \\<notin> TER\\<^bsub>\\<Gamma> \\<ominus> f\\<^esub> g\n\ngoal (1 subgoal):\n 1. essential \\<Gamma> (B \\<Gamma>)\n     (TER\\<^bsub>\\<Gamma> \\<ominus> f\\<^esub> g) z", "by(auto intro: essentialI)"], ["proof (state)\nthis:\n  essential \\<Gamma> (B \\<Gamma>)\n   (TER\\<^bsub>\\<Gamma> \\<ominus> f\\<^esub> g) z\n\ngoal (1 subgoal):\n 1. z \\<in> \\<E>\\<^bsub>\\<Gamma> \\<ominus> plus_current \\<epsilon> h \\<ominus> k\\<^esub>\n             (TER\\<^bsub>\\<Gamma> \\<ominus> plus_current \\<epsilon> h \\<ominus> k\\<^esub>\n               g') \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  essential \\<Gamma> (B \\<Gamma>)\n   (TER\\<^bsub>\\<Gamma> \\<ominus> f\\<^esub> g) z\n\ngoal (1 subgoal):\n 1. z \\<in> \\<E>\\<^bsub>\\<Gamma> \\<ominus> plus_current \\<epsilon> h \\<ominus> k\\<^esub>\n             (TER\\<^bsub>\\<Gamma> \\<ominus> plus_current \\<epsilon> h \\<ominus> k\\<^esub>\n               g') \\<Longrightarrow>\n    False", "with z waveD_separating[OF g_w, THEN separating_RF_A]"], ["proof (chain)\npicking this:\n  z \\<in> A \\<Gamma>\n  A (\\<Gamma> \\<ominus> f)\n  \\<subseteq> RF\\<^bsub>\\<Gamma> \\<ominus> f\\<^esub>\n               (TER\\<^bsub>\\<Gamma> \\<ominus> f\\<^esub> g)\n  essential \\<Gamma> (B \\<Gamma>)\n   (TER\\<^bsub>\\<Gamma> \\<ominus> f\\<^esub> g) z", "have \"z \\<in> \\<E>\\<^bsub>?\\<Omega>\\<^esub> (TER\\<^bsub>?\\<Omega>\\<^esub> g)\""], ["proof (prove)\nusing this:\n  z \\<in> A \\<Gamma>\n  A (\\<Gamma> \\<ominus> f)\n  \\<subseteq> RF\\<^bsub>\\<Gamma> \\<ominus> f\\<^esub>\n               (TER\\<^bsub>\\<Gamma> \\<ominus> f\\<^esub> g)\n  essential \\<Gamma> (B \\<Gamma>)\n   (TER\\<^bsub>\\<Gamma> \\<ominus> f\\<^esub> g) z\n\ngoal (1 subgoal):\n 1. z \\<in> \\<E>\\<^bsub>\\<Gamma> \\<ominus> f\\<^esub>\n             (TER\\<^bsub>\\<Gamma> \\<ominus> f\\<^esub> g)", "by(auto simp add: RF_in_essential)"], ["proof (state)\nthis:\n  z \\<in> \\<E>\\<^bsub>\\<Gamma> \\<ominus> f\\<^esub>\n           (TER\\<^bsub>\\<Gamma> \\<ominus> f\\<^esub> g)\n\ngoal (1 subgoal):\n 1. z \\<in> \\<E>\\<^bsub>\\<Gamma> \\<ominus> plus_current \\<epsilon> h \\<ominus> k\\<^esub>\n             (TER\\<^bsub>\\<Gamma> \\<ominus> plus_current \\<epsilon> h \\<ominus> k\\<^esub>\n               g') \\<Longrightarrow>\n    False", "with z\\<E>"], ["proof (chain)\npicking this:\n  z \\<notin> \\<E>\\<^bsub>\\<Gamma> \\<ominus> f\\<^esub>\n              (TER\\<^bsub>\\<Gamma> \\<ominus> f\\<^esub> g)\n  z \\<in> \\<E>\\<^bsub>\\<Gamma> \\<ominus> f\\<^esub>\n           (TER\\<^bsub>\\<Gamma> \\<ominus> f\\<^esub> g)", "show False"], ["proof (prove)\nusing this:\n  z \\<notin> \\<E>\\<^bsub>\\<Gamma> \\<ominus> f\\<^esub>\n              (TER\\<^bsub>\\<Gamma> \\<ominus> f\\<^esub> g)\n  z \\<in> \\<E>\\<^bsub>\\<Gamma> \\<ominus> f\\<^esub>\n           (TER\\<^bsub>\\<Gamma> \\<ominus> f\\<^esub> g)\n\ngoal (1 subgoal):\n 1. False", "by contradiction"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  z \\<notin> \\<E>\\<^bsub>\\<Gamma> \\<ominus> plus_current \\<epsilon> h \\<ominus> k\\<^esub>\n              (TER\\<^bsub>\\<Gamma> \\<ominus> plus_current \\<epsilon> h \\<ominus> k\\<^esub>\n                g')\n\ngoal (2 subgoals):\n 1. d_OUT g' z\n    < weight (\\<Gamma> \\<ominus> plus_current \\<epsilon> h \\<ominus> k) z\n 2. q < weight (\\<Gamma> \\<ominus> plus_current \\<epsilon> h \\<ominus> k)\n         z -\n        d_OUT g' z", "have \"\\<delta> \\<le> weight ?\\<Gamma> z - d_OUT g' z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<delta>\n    \\<le> weight (\\<Gamma> \\<ominus> plus_current \\<epsilon> h \\<ominus> k)\n           z -\n          d_OUT g' z", "unfolding ** OUT_g'"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<delta>\n    \\<le> weight (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M) \\<ominus> h) z -\n          (d_OUT g z + (d_OUT (\\<Squnion> (snd ` M)) z - d_OUT h z))", "using z"], ["proof (prove)\nusing this:\n  z \\<in> A \\<Gamma>\n\ngoal (1 subgoal):\n 1. \\<delta>\n    \\<le> weight (\\<Gamma> \\<ominus> \\<Squnion> (fst ` M) \\<ominus> h) z -\n          (d_OUT g z + (d_OUT (\\<Squnion> (snd ` M)) z - d_OUT h z))", "apply (simp add: \\<delta>_def OUT_f diff_add_eq_diff_diff_swap_ennreal)"], ["proof (prove)\ngoal (1 subgoal):\n 1. z \\<in> A \\<Gamma> \\<Longrightarrow>\n    weight \\<Gamma> z - d_OUT (\\<Squnion> (fst ` M)) z -\n    d_OUT (\\<Squnion> (snd ` M)) z -\n    d_OUT g z\n    \\<le> weight \\<Gamma> z - d_OUT (\\<Squnion> (fst ` M)) z - d_OUT h z -\n          d_OUT g z -\n          (d_OUT (\\<Squnion> (snd ` M)) z - d_OUT h z)", "apply (subst (5) diff_diff_commute_ennreal)"], ["proof (prove)\ngoal (1 subgoal):\n 1. z \\<in> A \\<Gamma> \\<Longrightarrow>\n    weight \\<Gamma> z - d_OUT (\\<Squnion> (fst ` M)) z -\n    d_OUT (\\<Squnion> (snd ` M)) z -\n    d_OUT g z\n    \\<le> weight \\<Gamma> z - d_OUT (\\<Squnion> (fst ` M)) z - d_OUT h z -\n          (d_OUT (\\<Squnion> (snd ` M)) z - d_OUT h z) -\n          d_OUT g z", "apply (rule ennreal_minus_mono[OF _ order_refl])"], ["proof (prove)\ngoal (1 subgoal):\n 1. z \\<in> A \\<Gamma> \\<Longrightarrow>\n    weight \\<Gamma> z - d_OUT (\\<Squnion> (fst ` M)) z -\n    d_OUT (\\<Squnion> (snd ` M)) z\n    \\<le> weight \\<Gamma> z - d_OUT (\\<Squnion> (fst ` M)) z - d_OUT h z -\n          (d_OUT (\\<Squnion> (snd ` M)) z - d_OUT h z)", "apply (auto simp add: ac_simps diff_add_eq_diff_diff_swap_ennreal[symmetric] add_diff_self_ennreal image_comp\n                      intro!: ennreal_minus_mono[OF order_refl] SUP_upper2[OF hM] d_OUT_mono)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<delta>\n  \\<le> weight (\\<Gamma> \\<ominus> plus_current \\<epsilon> h \\<ominus> k)\n         z -\n        d_OUT g' z\n\ngoal (2 subgoals):\n 1. d_OUT g' z\n    < weight (\\<Gamma> \\<ominus> plus_current \\<epsilon> h \\<ominus> k) z\n 2. q < weight (\\<Gamma> \\<ominus> plus_current \\<epsilon> h \\<ominus> k)\n         z -\n        d_OUT g' z", "then"], ["proof (chain)\npicking this:\n  \\<delta>\n  \\<le> weight (\\<Gamma> \\<ominus> plus_current \\<epsilon> h \\<ominus> k)\n         z -\n        d_OUT g' z", "show q_z: \"q < weight ?\\<Gamma> z - d_OUT g' z\""], ["proof (prove)\nusing this:\n  \\<delta>\n  \\<le> weight (\\<Gamma> \\<ominus> plus_current \\<epsilon> h \\<ominus> k)\n         z -\n        d_OUT g' z\n\ngoal (1 subgoal):\n 1. q < weight (\\<Gamma> \\<ominus> plus_current \\<epsilon> h \\<ominus> k)\n         z -\n        d_OUT g' z", "using q_less_\\<delta>"], ["proof (prove)\nusing this:\n  \\<delta>\n  \\<le> weight (\\<Gamma> \\<ominus> plus_current \\<epsilon> h \\<ominus> k)\n         z -\n        d_OUT g' z\n  q < \\<delta>\n\ngoal (1 subgoal):\n 1. q < weight (\\<Gamma> \\<ominus> plus_current \\<epsilon> h \\<ominus> k)\n         z -\n        d_OUT g' z", "by simp"], ["proof (state)\nthis:\n  q < weight (\\<Gamma> \\<ominus> plus_current \\<epsilon> h \\<ominus> k) z -\n      d_OUT g' z\n\ngoal (1 subgoal):\n 1. d_OUT g' z\n    < weight (\\<Gamma> \\<ominus> plus_current \\<epsilon> h \\<ominus> k) z", "then"], ["proof (chain)\npicking this:\n  q < weight (\\<Gamma> \\<ominus> plus_current \\<epsilon> h \\<ominus> k) z -\n      d_OUT g' z", "show \"d_OUT g' z < weight ?\\<Gamma> z\""], ["proof (prove)\nusing this:\n  q < weight (\\<Gamma> \\<ominus> plus_current \\<epsilon> h \\<ominus> k) z -\n      d_OUT g' z\n\ngoal (1 subgoal):\n 1. d_OUT g' z\n    < weight (\\<Gamma> \\<ominus> plus_current \\<epsilon> h \\<ominus> k) z", "using q_nonneg z"], ["proof (prove)\nusing this:\n  q < weight (\\<Gamma> \\<ominus> plus_current \\<epsilon> h \\<ominus> k) z -\n      d_OUT g' z\n  0 \\<le> q\n  z \\<in> A \\<Gamma>\n\ngoal (1 subgoal):\n 1. d_OUT g' z\n    < weight (\\<Gamma> \\<ominus> plus_current \\<epsilon> h \\<ominus> k) z", "by(auto simp add: less_diff_eq_ennreal less_top[symmetric] ac_simps \\<Gamma>.currentD_finite_OUT[OF g']\n                  intro: le_less_trans[rotated] add_increasing)"], ["proof (state)\nthis:\n  d_OUT g' z\n  < weight (\\<Gamma> \\<ominus> plus_current \\<epsilon> h \\<ominus> k) z\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  hindrance_by (\\<Gamma> \\<ominus> plus_current \\<epsilon> h \\<ominus> k) g'\n   q\n\ngoal (1 subgoal):\n 1. hindered (\\<Gamma> \\<ominus> f) \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  hindrance_by (\\<Gamma> \\<ominus> plus_current \\<epsilon> h \\<ominus> k) g'\n   q", "have hindered_by: \"hindered_by (\\<Gamma> \\<ominus> ?\\<epsilon>h \\<ominus> k) q\""], ["proof (prove)\nusing this:\n  hindrance_by (\\<Gamma> \\<ominus> plus_current \\<epsilon> h \\<ominus> k) g'\n   q\n\ngoal (1 subgoal):\n 1. hindered_by (\\<Gamma> \\<ominus> plus_current \\<epsilon> h \\<ominus> k) q", "using g' g'_w"], ["proof (prove)\nusing this:\n  hindrance_by (\\<Gamma> \\<ominus> plus_current \\<epsilon> h \\<ominus> k) g'\n   q\n  current (\\<Gamma> \\<ominus> plus_current \\<epsilon> h \\<ominus> k) g'\n  wave (\\<Gamma> \\<ominus> plus_current \\<epsilon> h \\<ominus> k) g'\n\ngoal (1 subgoal):\n 1. hindered_by (\\<Gamma> \\<ominus> plus_current \\<epsilon> h \\<ominus> k) q", "by(rule hindered_by.intros)"], ["proof (state)\nthis:\n  hindered_by (\\<Gamma> \\<ominus> plus_current \\<epsilon> h \\<ominus> k) q\n\ngoal (1 subgoal):\n 1. hindered (\\<Gamma> \\<ominus> f) \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  hindered_by (\\<Gamma> \\<ominus> plus_current \\<epsilon> h \\<ominus> k) q", "have \"hindered (\\<Gamma> \\<ominus> ?\\<epsilon>h)\""], ["proof (prove)\nusing this:\n  hindered_by (\\<Gamma> \\<ominus> plus_current \\<epsilon> h \\<ominus> k) q\n\ngoal (1 subgoal):\n 1. hindered (\\<Gamma> \\<ominus> plus_current \\<epsilon> h)", "using q_finite"], ["proof (prove)\nusing this:\n  hindered_by (\\<Gamma> \\<ominus> plus_current \\<epsilon> h \\<ominus> k) q\n  q \\<noteq> \\<top>\n\ngoal (1 subgoal):\n 1. hindered (\\<Gamma> \\<ominus> plus_current \\<epsilon> h)", "unfolding q_def"], ["proof (prove)\nusing this:\n  hindered_by (\\<Gamma> \\<ominus> plus_current \\<epsilon> h \\<ominus> k)\n   (\\<Sum>\\<^sup>+ y\\<in>B (\\<Gamma> \\<ominus> plus_current \\<epsilon> h).\n      d_IN k y - d_OUT k y)\n  (\\<Sum>\\<^sup>+ y\\<in>B (\\<Gamma> \\<ominus> plus_current \\<epsilon> h).\n     d_IN k y - d_OUT k y) \\<noteq>\n  \\<top>\n\ngoal (1 subgoal):\n 1. hindered (\\<Gamma> \\<ominus> plus_current \\<epsilon> h)", "by -(rule \\<epsilon>h.hindered_reduce_current[OF k])"], ["proof (state)\nthis:\n  hindered (\\<Gamma> \\<ominus> plus_current \\<epsilon> h)\n\ngoal (1 subgoal):\n 1. hindered (\\<Gamma> \\<ominus> f) \\<Longrightarrow> False", "with unhindered_h"], ["proof (chain)\npicking this:\n  \\<not> hindered (\\<Gamma> \\<ominus> F (\\<epsilon>, h))\n  hindered (\\<Gamma> \\<ominus> plus_current \\<epsilon> h)", "show False"], ["proof (prove)\nusing this:\n  \\<not> hindered (\\<Gamma> \\<ominus> F (\\<epsilon>, h))\n  hindered (\\<Gamma> \\<ominus> plus_current \\<epsilon> h)\n\ngoal (1 subgoal):\n 1. False", "unfolding F_simps"], ["proof (prove)\nusing this:\n  \\<not> hindered (\\<Gamma> \\<ominus> plus_current \\<epsilon> h)\n  hindered (\\<Gamma> \\<ominus> plus_current \\<epsilon> h)\n\ngoal (1 subgoal):\n 1. False", "by contradiction"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> hindered (\\<Gamma> \\<ominus> f)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>?M \\<in> Chains leq; ?M \\<noteq> {}\\<rbrakk>\n  \\<Longrightarrow> \\<Squnion> ?M \\<in> Field leq\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       current \\<Gamma> f \\<and>\n       d_OUT f a = weight \\<Gamma> a \\<and>\n       \\<not> hindered (\\<Gamma> \\<ominus> f)", "define sat where \"sat =\n    (\\<lambda>(\\<epsilon>, h).\n      let\n        f = F (\\<epsilon>, h);\n        k = SOME k. current (\\<Gamma> \\<ominus> f) k \\<and> wave (\\<Gamma> \\<ominus> f) k \\<and> (\\<forall>k'. current (\\<Gamma> \\<ominus> f) k' \\<and> wave (\\<Gamma> \\<ominus> f) k' \\<and> k \\<le> k' \\<longrightarrow> k = k')\n      in\n        if d_OUT (plus_current f k) a < weight \\<Gamma> a then\n          let\n            \\<Omega> = \\<Gamma> \\<ominus> f \\<ominus> k;\n            y = SOME y. y \\<in> \\<^bold>O\\<^bold>U\\<^bold>T\\<^bsub>\\<Omega>\\<^esub> a \\<and> weight \\<Omega> y > 0;\n            \\<delta> = SOME \\<delta>. \\<delta> > 0 \\<and> \\<delta> < enn2real (min (weight \\<Omega> a) (weight \\<Omega> y)) \\<and> \\<not> hindered (reduce_weight \\<Omega> y \\<delta>)\n          in\n            (plus_current \\<epsilon> (zero_current((a, y) := \\<delta>)), plus_current h k)\n        else (\\<epsilon>, h))\""], ["proof (state)\nthis:\n  sat =\n  (\\<lambda>(\\<epsilon>, h).\n      let f = F (\\<epsilon>, h);\n          k = SOME k.\n                 current (\\<Gamma> \\<ominus> f) k \\<and>\n                 wave (\\<Gamma> \\<ominus> f) k \\<and>\n                 (\\<forall>k'.\n                     current (\\<Gamma> \\<ominus> f) k' \\<and>\n                     wave (\\<Gamma> \\<ominus> f) k' \\<and>\n                     k \\<le> k' \\<longrightarrow>\n                     k = k')\n      in if d_OUT (plus_current f k) a < weight \\<Gamma> a\n         then let \\<Omega> = \\<Gamma> \\<ominus> f \\<ominus> k;\n                  y = SOME y.\n                         y \\<in> \\<^bold>O\\<^bold>U\\<^bold>T\\<^bsub>\\<Omega>\\<^esub>\n                                  a \\<and>\n                         0 < weight \\<Omega> y;\n                  x = SOME \\<delta>.\n                         0 < \\<delta> \\<and>\n                         \\<delta>\n                         < enn2real\n                            (min (weight \\<Omega> a)\n                              (weight \\<Omega> y)) \\<and>\n                         \\<not> hindered (reduce_weight \\<Omega> y \\<delta>)\n              in (plus_current \\<epsilon>\n                   ((\\<lambda>_. 0)((a, y) := ennreal x)),\n                  plus_current h k)\n         else (\\<epsilon>, h))\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       current \\<Gamma> f \\<and>\n       d_OUT f a = weight \\<Gamma> a \\<and>\n       \\<not> hindered (\\<Gamma> \\<ominus> f)", "have zero: \"(zero_current, zero_current) \\<in> Field leq\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>_. 0, \\<lambda>_. 0) \\<in> Field leq", "by(rule F_I)(simp_all add: unhindered  F_def)"], ["proof (state)\nthis:\n  (\\<lambda>_. 0, \\<lambda>_. 0) \\<in> Field leq\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       current \\<Gamma> f \\<and>\n       d_OUT f a = weight \\<Gamma> a \\<and>\n       \\<not> hindered (\\<Gamma> \\<ominus> f)", "have a_TER: \"a \\<in> TER\\<^bsub>\\<Gamma> \\<ominus> F \\<epsilon>h\\<^esub> k\"\n    if that: \"\\<epsilon>h \\<in> Field leq\"\n    and k: \"current (\\<Gamma> \\<ominus> F \\<epsilon>h) k\" and k_w: \"wave (\\<Gamma> \\<ominus> F \\<epsilon>h) k\"\n    and less: \"d_OUT (plus_current (F \\<epsilon>h) k) a < weight \\<Gamma> a\" for \\<epsilon>h k"], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<in> TER\\<^bsub>\\<Gamma> \\<ominus> F \\<epsilon>h\\<^esub> k", "proof(rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. a \\<notin> TER\\<^bsub>\\<Gamma> \\<ominus> F \\<epsilon>h\\<^esub>\n                k \\<Longrightarrow>\n    False", "assume \"\\<not> ?thesis\""], ["proof (state)\nthis:\n  a \\<notin> TER\\<^bsub>\\<Gamma> \\<ominus> F \\<epsilon>h\\<^esub> k\n\ngoal (1 subgoal):\n 1. a \\<notin> TER\\<^bsub>\\<Gamma> \\<ominus> F \\<epsilon>h\\<^esub>\n                k \\<Longrightarrow>\n    False", "hence \\<E>: \"a \\<notin> \\<E>\\<^bsub>\\<Gamma> \\<ominus> F \\<epsilon>h\\<^esub> (TER\\<^bsub>\\<Gamma> \\<ominus> F \\<epsilon>h\\<^esub> k)\""], ["proof (prove)\nusing this:\n  a \\<notin> TER\\<^bsub>\\<Gamma> \\<ominus> F \\<epsilon>h\\<^esub> k\n\ngoal (1 subgoal):\n 1. a \\<notin> \\<E>\\<^bsub>\\<Gamma> \\<ominus> F \\<epsilon>h\\<^esub>\n                (TER\\<^bsub>\\<Gamma> \\<ominus> F \\<epsilon>h\\<^esub> k)", "by auto"], ["proof (state)\nthis:\n  a \\<notin> \\<E>\\<^bsub>\\<Gamma> \\<ominus> F \\<epsilon>h\\<^esub>\n              (TER\\<^bsub>\\<Gamma> \\<ominus> F \\<epsilon>h\\<^esub> k)\n\ngoal (1 subgoal):\n 1. a \\<notin> TER\\<^bsub>\\<Gamma> \\<ominus> F \\<epsilon>h\\<^esub>\n                k \\<Longrightarrow>\n    False", "from that"], ["proof (chain)\npicking this:\n  \\<epsilon>h \\<in> Field leq", "have f: \"current \\<Gamma> (F \\<epsilon>h)\" and unhindered: \"\\<not> hindered (\\<Gamma> \\<ominus> F \\<epsilon>h)\""], ["proof (prove)\nusing this:\n  \\<epsilon>h \\<in> Field leq\n\ngoal (1 subgoal):\n 1. current \\<Gamma> (F \\<epsilon>h) &&&\n    \\<not> hindered (\\<Gamma> \\<ominus> F \\<epsilon>h)", "by(cases \\<epsilon>h; simp add: f unhindered'; fail)+"], ["proof (state)\nthis:\n  current \\<Gamma> (F \\<epsilon>h)\n  \\<not> hindered (\\<Gamma> \\<ominus> F \\<epsilon>h)\n\ngoal (1 subgoal):\n 1. a \\<notin> TER\\<^bsub>\\<Gamma> \\<ominus> F \\<epsilon>h\\<^esub>\n                k \\<Longrightarrow>\n    False", "from less"], ["proof (chain)\npicking this:\n  d_OUT (plus_current (F \\<epsilon>h) k) a < weight \\<Gamma> a", "have \"d_OUT k a < weight (\\<Gamma> \\<ominus> F \\<epsilon>h) a\""], ["proof (prove)\nusing this:\n  d_OUT (plus_current (F \\<epsilon>h) k) a < weight \\<Gamma> a\n\ngoal (1 subgoal):\n 1. d_OUT k a < weight (\\<Gamma> \\<ominus> F \\<epsilon>h) a", "using a currentD_finite_OUT[OF f, of a]"], ["proof (prove)\nusing this:\n  d_OUT (plus_current (F \\<epsilon>h) k) a < weight \\<Gamma> a\n  a \\<in> A \\<Gamma>\n  d_OUT (F \\<epsilon>h) a \\<noteq> \\<top>\n\ngoal (1 subgoal):\n 1. d_OUT k a < weight (\\<Gamma> \\<ominus> F \\<epsilon>h) a", "by(simp add: d_OUT_def nn_integral_add less_diff_eq_ennreal add.commute less_top[symmetric])"], ["proof (state)\nthis:\n  d_OUT k a < weight (\\<Gamma> \\<ominus> F \\<epsilon>h) a\n\ngoal (1 subgoal):\n 1. a \\<notin> TER\\<^bsub>\\<Gamma> \\<ominus> F \\<epsilon>h\\<^esub>\n                k \\<Longrightarrow>\n    False", "with _ \\<E>"], ["proof (chain)\npicking this:\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  a \\<notin> \\<E>\\<^bsub>\\<Gamma> \\<ominus> F \\<epsilon>h\\<^esub>\n              (TER\\<^bsub>\\<Gamma> \\<ominus> F \\<epsilon>h\\<^esub> k)\n  d_OUT k a < weight (\\<Gamma> \\<ominus> F \\<epsilon>h) a", "have \"hindrance (\\<Gamma> \\<ominus> F \\<epsilon>h) k\""], ["proof (prove)\nusing this:\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  a \\<notin> \\<E>\\<^bsub>\\<Gamma> \\<ominus> F \\<epsilon>h\\<^esub>\n              (TER\\<^bsub>\\<Gamma> \\<ominus> F \\<epsilon>h\\<^esub> k)\n  d_OUT k a < weight (\\<Gamma> \\<ominus> F \\<epsilon>h) a\n\ngoal (1 subgoal):\n 1. hindrance (\\<Gamma> \\<ominus> F \\<epsilon>h) k", "by(rule hindrance)(simp add: a)"], ["proof (state)\nthis:\n  hindrance (\\<Gamma> \\<ominus> F \\<epsilon>h) k\n\ngoal (1 subgoal):\n 1. a \\<notin> TER\\<^bsub>\\<Gamma> \\<ominus> F \\<epsilon>h\\<^esub>\n                k \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  hindrance (\\<Gamma> \\<ominus> F \\<epsilon>h) k", "have \"hindered (\\<Gamma> \\<ominus> F \\<epsilon>h)\""], ["proof (prove)\nusing this:\n  hindrance (\\<Gamma> \\<ominus> F \\<epsilon>h) k\n\ngoal (1 subgoal):\n 1. hindered (\\<Gamma> \\<ominus> F \\<epsilon>h)", "using k k_w"], ["proof (prove)\nusing this:\n  hindrance (\\<Gamma> \\<ominus> F \\<epsilon>h) k\n  current (\\<Gamma> \\<ominus> F \\<epsilon>h) k\n  wave (\\<Gamma> \\<ominus> F \\<epsilon>h) k\n\ngoal (1 subgoal):\n 1. hindered (\\<Gamma> \\<ominus> F \\<epsilon>h)", ".."], ["proof (state)\nthis:\n  hindered (\\<Gamma> \\<ominus> F \\<epsilon>h)\n\ngoal (1 subgoal):\n 1. a \\<notin> TER\\<^bsub>\\<Gamma> \\<ominus> F \\<epsilon>h\\<^esub>\n                k \\<Longrightarrow>\n    False", "with unhindered"], ["proof (chain)\npicking this:\n  \\<not> hindered (\\<Gamma> \\<ominus> F \\<epsilon>h)\n  hindered (\\<Gamma> \\<ominus> F \\<epsilon>h)", "show False"], ["proof (prove)\nusing this:\n  \\<not> hindered (\\<Gamma> \\<ominus> F \\<epsilon>h)\n  hindered (\\<Gamma> \\<ominus> F \\<epsilon>h)\n\ngoal (1 subgoal):\n 1. False", "by contradiction"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>?\\<epsilon>h \\<in> Field leq;\n   current (\\<Gamma> \\<ominus> F ?\\<epsilon>h) ?k;\n   wave (\\<Gamma> \\<ominus> F ?\\<epsilon>h) ?k;\n   d_OUT (plus_current (F ?\\<epsilon>h) ?k) a < weight \\<Gamma> a\\<rbrakk>\n  \\<Longrightarrow> a \\<in> TER\\<^bsub>\\<Gamma> \\<ominus> F ?\\<epsilon>h\\<^esub>\n                             ?k\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       current \\<Gamma> f \\<and>\n       d_OUT f a = weight \\<Gamma> a \\<and>\n       \\<not> hindered (\\<Gamma> \\<ominus> f)", "note minus_web_sel(2)[simp del]"], ["proof (state)\nthis:\n  weight (?\\<Gamma> \\<ominus> ?f) ?x =\n  (if ?x \\<in> A ?\\<Gamma> then weight ?\\<Gamma> ?x - d_OUT ?f ?x\n   else weight ?\\<Gamma> ?x + d_OUT ?f ?x - d_IN ?f ?x)\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       current \\<Gamma> f \\<and>\n       d_OUT f a = weight \\<Gamma> a \\<and>\n       \\<not> hindered (\\<Gamma> \\<ominus> f)", "let ?P_y = \"\\<lambda>\\<epsilon>h k y. y \\<in> \\<^bold>O\\<^bold>U\\<^bold>T\\<^bsub>\\<Gamma> \\<ominus> F \\<epsilon>h \\<ominus> k\\<^esub> a \\<and> weight (\\<Gamma> \\<ominus> F \\<epsilon>h \\<ominus> k) y > 0\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>f.\n       current \\<Gamma> f \\<and>\n       d_OUT f a = weight \\<Gamma> a \\<and>\n       \\<not> hindered (\\<Gamma> \\<ominus> f)", "have Ex_y: \"Ex (?P_y \\<epsilon>h k)\"\n    if that: \"\\<epsilon>h \\<in> Field leq\"\n    and k: \"current (\\<Gamma> \\<ominus> F \\<epsilon>h) k\" and k_w: \"wave (\\<Gamma> \\<ominus> F \\<epsilon>h) k\"\n    and less: \"d_OUT (plus_current (F \\<epsilon>h) k) a < weight \\<Gamma> a\" for \\<epsilon>h k"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>y.\n       y \\<in> \\<^bold>O\\<^bold>U\\<^bold>T\\<^bsub>\\<Gamma> \\<ominus> F \\<epsilon>h \\<ominus> k\\<^esub>\n                a \\<and>\n       0 < weight (\\<Gamma> \\<ominus> F \\<epsilon>h \\<ominus> k) y", "proof(rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<nexists>y.\n       y \\<in> \\<^bold>O\\<^bold>U\\<^bold>T\\<^bsub>\\<Gamma> \\<ominus> F \\<epsilon>h \\<ominus> k\\<^esub>\n                a \\<and>\n       0 < weight (\\<Gamma> \\<ominus> F \\<epsilon>h \\<ominus> k)\n            y \\<Longrightarrow>\n    False", "let ?\\<Omega> = \"\\<Gamma> \\<ominus> F \\<epsilon>h \\<ominus> k\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<nexists>y.\n       y \\<in> \\<^bold>O\\<^bold>U\\<^bold>T\\<^bsub>\\<Gamma> \\<ominus> F \\<epsilon>h \\<ominus> k\\<^esub>\n                a \\<and>\n       0 < weight (\\<Gamma> \\<ominus> F \\<epsilon>h \\<ominus> k)\n            y \\<Longrightarrow>\n    False", "assume *: \"\\<not> ?thesis\""], ["proof (state)\nthis:\n  \\<nexists>y.\n     y \\<in> \\<^bold>O\\<^bold>U\\<^bold>T\\<^bsub>\\<Gamma> \\<ominus> F \\<epsilon>h \\<ominus> k\\<^esub>\n              a \\<and>\n     0 < weight (\\<Gamma> \\<ominus> F \\<epsilon>h \\<ominus> k) y\n\ngoal (1 subgoal):\n 1. \\<nexists>y.\n       y \\<in> \\<^bold>O\\<^bold>U\\<^bold>T\\<^bsub>\\<Gamma> \\<ominus> F \\<epsilon>h \\<ominus> k\\<^esub>\n                a \\<and>\n       0 < weight (\\<Gamma> \\<ominus> F \\<epsilon>h \\<ominus> k)\n            y \\<Longrightarrow>\n    False", "interpret \\<Gamma>: countable_bipartite_web \"\\<Gamma> \\<ominus> F \\<epsilon>h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. countable_bipartite_web (\\<Gamma> \\<ominus> F \\<epsilon>h)", "using f[OF that]"], ["proof (prove)\nusing this:\n  current \\<Gamma> (F \\<epsilon>h)\n\ngoal (1 subgoal):\n 1. countable_bipartite_web (\\<Gamma> \\<ominus> F \\<epsilon>h)", "by(rule countable_bipartite_web_minus_web)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<nexists>y.\n       y \\<in> \\<^bold>O\\<^bold>U\\<^bold>T\\<^bsub>\\<Gamma> \\<ominus> F \\<epsilon>h \\<ominus> k\\<^esub>\n                a \\<and>\n       0 < weight (\\<Gamma> \\<ominus> F \\<epsilon>h \\<ominus> k)\n            y \\<Longrightarrow>\n    False", "note [simp] = weight_minus_web[OF f[OF that]] \\<Gamma>.weight_minus_web[OF k]"], ["proof (state)\nthis:\n  weight (\\<Gamma> \\<ominus> F \\<epsilon>h) ?x =\n  (if ?x \\<in> A \\<Gamma> then weight \\<Gamma> ?x - d_OUT (F \\<epsilon>h) ?x\n   else weight \\<Gamma> ?x - d_IN (F \\<epsilon>h) ?x)\n  weight (\\<Gamma> \\<ominus> F \\<epsilon>h \\<ominus> k) ?x =\n  (if ?x \\<in> A (\\<Gamma> \\<ominus> F \\<epsilon>h)\n   then weight (\\<Gamma> \\<ominus> F \\<epsilon>h) ?x - d_OUT k ?x\n   else weight (\\<Gamma> \\<ominus> F \\<epsilon>h) ?x - d_IN k ?x)\n\ngoal (1 subgoal):\n 1. \\<nexists>y.\n       y \\<in> \\<^bold>O\\<^bold>U\\<^bold>T\\<^bsub>\\<Gamma> \\<ominus> F \\<epsilon>h \\<ominus> k\\<^esub>\n                a \\<and>\n       0 < weight (\\<Gamma> \\<ominus> F \\<epsilon>h \\<ominus> k)\n            y \\<Longrightarrow>\n    False", "have \"hindrance ?\\<Omega> zero_current\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hindrance (\\<Gamma> \\<ominus> F \\<epsilon>h \\<ominus> k) (\\<lambda>_. 0)", "proof"], ["proof (state)\ngoal (3 subgoals):\n 1. ?a \\<in> A (\\<Gamma> \\<ominus> F \\<epsilon>h \\<ominus> k)\n 2. ?a \\<notin> \\<E>\\<^bsub>\\<Gamma> \\<ominus> F \\<epsilon>h \\<ominus> k\\<^esub>\n                 (TER\\<^bsub>\\<Gamma> \\<ominus> F \\<epsilon>h \\<ominus> k\\<^esub>\n                   (\\<lambda>_. 0))\n 3. d_OUT (\\<lambda>_. 0) ?a\n    < weight (\\<Gamma> \\<ominus> F \\<epsilon>h \\<ominus> k) ?a", "show \"a \\<in> A ?\\<Omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<in> A (\\<Gamma> \\<ominus> F \\<epsilon>h \\<ominus> k)", "using a"], ["proof (prove)\nusing this:\n  a \\<in> A \\<Gamma>\n\ngoal (1 subgoal):\n 1. a \\<in> A (\\<Gamma> \\<ominus> F \\<epsilon>h \\<ominus> k)", "by simp"], ["proof (state)\nthis:\n  a \\<in> A (\\<Gamma> \\<ominus> F \\<epsilon>h \\<ominus> k)\n\ngoal (2 subgoals):\n 1. a \\<notin> \\<E>\\<^bsub>\\<Gamma> \\<ominus> F \\<epsilon>h \\<ominus> k\\<^esub>\n                (TER\\<^bsub>\\<Gamma> \\<ominus> F \\<epsilon>h \\<ominus> k\\<^esub>\n                  (\\<lambda>_. 0))\n 2. d_OUT (\\<lambda>_. 0) a\n    < weight (\\<Gamma> \\<ominus> F \\<epsilon>h \\<ominus> k) a", "show \"a \\<notin> \\<E>\\<^bsub>?\\<Omega>\\<^esub> (TER\\<^bsub>?\\<Omega>\\<^esub> zero_current)\" (is \"a \\<notin> \\<E>\\<^bsub>_\\<^esub> ?TER\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<notin> \\<E>\\<^bsub>\\<Gamma> \\<ominus> F \\<epsilon>h \\<ominus> k\\<^esub>\n                (TER\\<^bsub>\\<Gamma> \\<ominus> F \\<epsilon>h \\<ominus> k\\<^esub>\n                  (\\<lambda>_. 0))", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. a \\<in> \\<E>\\<^bsub>\\<Gamma> \\<ominus> F \\<epsilon>h \\<ominus> k\\<^esub>\n             (TER\\<^bsub>\\<Gamma> \\<ominus> F \\<epsilon>h \\<ominus> k\\<^esub>\n               (\\<lambda>_. 0)) \\<Longrightarrow>\n    False", "assume \"a \\<in> \\<E>\\<^bsub>?\\<Omega>\\<^esub> ?TER\""], ["proof (state)\nthis:\n  a \\<in> \\<E>\\<^bsub>\\<Gamma> \\<ominus> F \\<epsilon>h \\<ominus> k\\<^esub>\n           (TER\\<^bsub>\\<Gamma> \\<ominus> F \\<epsilon>h \\<ominus> k\\<^esub>\n             (\\<lambda>_. 0))\n\ngoal (1 subgoal):\n 1. a \\<in> \\<E>\\<^bsub>\\<Gamma> \\<ominus> F \\<epsilon>h \\<ominus> k\\<^esub>\n             (TER\\<^bsub>\\<Gamma> \\<ominus> F \\<epsilon>h \\<ominus> k\\<^esub>\n               (\\<lambda>_. 0)) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  a \\<in> \\<E>\\<^bsub>\\<Gamma> \\<ominus> F \\<epsilon>h \\<ominus> k\\<^esub>\n           (TER\\<^bsub>\\<Gamma> \\<ominus> F \\<epsilon>h \\<ominus> k\\<^esub>\n             (\\<lambda>_. 0))", "obtain p y where p: \"path ?\\<Omega> a p y\" and y: \"y \\<in> B ?\\<Omega>\"\n          and bypass: \"\\<And>z. z \\<in> set p \\<Longrightarrow> z \\<notin> RF\\<^bsub>?\\<Omega>\\<^esub> ?TER\""], ["proof (prove)\nusing this:\n  a \\<in> \\<E>\\<^bsub>\\<Gamma> \\<ominus> F \\<epsilon>h \\<ominus> k\\<^esub>\n           (TER\\<^bsub>\\<Gamma> \\<ominus> F \\<epsilon>h \\<ominus> k\\<^esub>\n             (\\<lambda>_. 0))\n\ngoal (1 subgoal):\n 1. (\\<And>p y.\n        \\<lbrakk>path (\\<Gamma> \\<ominus> F \\<epsilon>h \\<ominus> k) a p y;\n         y \\<in> B (\\<Gamma> \\<ominus> F \\<epsilon>h \\<ominus> k);\n         \\<And>z.\n            z \\<in> set p \\<Longrightarrow>\n            z \\<notin> RF\\<^bsub>\\<Gamma> \\<ominus> F \\<epsilon>h \\<ominus> k\\<^esub>\n                        (TER\\<^bsub>\\<Gamma> \\<ominus> F \\<epsilon>h \\<ominus> k\\<^esub>\n                          (\\<lambda>_. 0))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(rule \\<E>_E_RF)(auto)"], ["proof (state)\nthis:\n  path (\\<Gamma> \\<ominus> F \\<epsilon>h \\<ominus> k) a p y\n  y \\<in> B (\\<Gamma> \\<ominus> F \\<epsilon>h \\<ominus> k)\n  ?z \\<in> set p \\<Longrightarrow>\n  ?z \\<notin> RF\\<^bsub>\\<Gamma> \\<ominus> F \\<epsilon>h \\<ominus> k\\<^esub>\n               (TER\\<^bsub>\\<Gamma> \\<ominus> F \\<epsilon>h \\<ominus> k\\<^esub>\n                 (\\<lambda>_. 0))\n\ngoal (1 subgoal):\n 1. a \\<in> \\<E>\\<^bsub>\\<Gamma> \\<ominus> F \\<epsilon>h \\<ominus> k\\<^esub>\n             (TER\\<^bsub>\\<Gamma> \\<ominus> F \\<epsilon>h \\<ominus> k\\<^esub>\n               (\\<lambda>_. 0)) \\<Longrightarrow>\n    False", "from a p y disjoint"], ["proof (chain)\npicking this:\n  a \\<in> A \\<Gamma>\n  path (\\<Gamma> \\<ominus> F \\<epsilon>h \\<ominus> k) a p y\n  y \\<in> B (\\<Gamma> \\<ominus> F \\<epsilon>h \\<ominus> k)\n  A \\<Gamma> \\<inter> B \\<Gamma> = {}", "have Nil: \"p \\<noteq> []\""], ["proof (prove)\nusing this:\n  a \\<in> A \\<Gamma>\n  path (\\<Gamma> \\<ominus> F \\<epsilon>h \\<ominus> k) a p y\n  y \\<in> B (\\<Gamma> \\<ominus> F \\<epsilon>h \\<ominus> k)\n  A \\<Gamma> \\<inter> B \\<Gamma> = {}\n\ngoal (1 subgoal):\n 1. p \\<noteq> []", "by(auto simp add: rtrancl_path_simps)"], ["proof (state)\nthis:\n  p \\<noteq> []\n\ngoal (1 subgoal):\n 1. a \\<in> \\<E>\\<^bsub>\\<Gamma> \\<ominus> F \\<epsilon>h \\<ominus> k\\<^esub>\n             (TER\\<^bsub>\\<Gamma> \\<ominus> F \\<epsilon>h \\<ominus> k\\<^esub>\n               (\\<lambda>_. 0)) \\<Longrightarrow>\n    False", "hence \"edge ?\\<Omega> a (p ! 0)\" \"p ! 0 \\<notin> RF\\<^bsub>?\\<Omega>\\<^esub> ?TER\""], ["proof (prove)\nusing this:\n  p \\<noteq> []\n\ngoal (1 subgoal):\n 1. edge (\\<Gamma> \\<ominus> F \\<epsilon>h \\<ominus> k) a (p ! 0) &&&\n    p ! 0\n    \\<notin> RF\\<^bsub>\\<Gamma> \\<ominus> F \\<epsilon>h \\<ominus> k\\<^esub>\n              (TER\\<^bsub>\\<Gamma> \\<ominus> F \\<epsilon>h \\<ominus> k\\<^esub>\n                (\\<lambda>_. 0))", "using rtrancl_path_nth[OF p, of 0] bypass"], ["proof (prove)\nusing this:\n  p \\<noteq> []\n  0 < length p \\<Longrightarrow>\n  edge (\\<Gamma> \\<ominus> F \\<epsilon>h \\<ominus> k) ((a # p) ! 0) (p ! 0)\n  ?z \\<in> set p \\<Longrightarrow>\n  ?z \\<notin> RF\\<^bsub>\\<Gamma> \\<ominus> F \\<epsilon>h \\<ominus> k\\<^esub>\n               (TER\\<^bsub>\\<Gamma> \\<ominus> F \\<epsilon>h \\<ominus> k\\<^esub>\n                 (\\<lambda>_. 0))\n\ngoal (1 subgoal):\n 1. edge (\\<Gamma> \\<ominus> F \\<epsilon>h \\<ominus> k) a (p ! 0) &&&\n    p ! 0\n    \\<notin> RF\\<^bsub>\\<Gamma> \\<ominus> F \\<epsilon>h \\<ominus> k\\<^esub>\n              (TER\\<^bsub>\\<Gamma> \\<ominus> F \\<epsilon>h \\<ominus> k\\<^esub>\n                (\\<lambda>_. 0))", "by auto"], ["proof (state)\nthis:\n  edge (\\<Gamma> \\<ominus> F \\<epsilon>h \\<ominus> k) a (p ! 0)\n  p ! 0\n  \\<notin> RF\\<^bsub>\\<Gamma> \\<ominus> F \\<epsilon>h \\<ominus> k\\<^esub>\n            (TER\\<^bsub>\\<Gamma> \\<ominus> F \\<epsilon>h \\<ominus> k\\<^esub>\n              (\\<lambda>_. 0))\n\ngoal (1 subgoal):\n 1. a \\<in> \\<E>\\<^bsub>\\<Gamma> \\<ominus> F \\<epsilon>h \\<ominus> k\\<^esub>\n             (TER\\<^bsub>\\<Gamma> \\<ominus> F \\<epsilon>h \\<ominus> k\\<^esub>\n               (\\<lambda>_. 0)) \\<Longrightarrow>\n    False", "with *"], ["proof (chain)\npicking this:\n  \\<nexists>y.\n     y \\<in> \\<^bold>O\\<^bold>U\\<^bold>T\\<^bsub>\\<Gamma> \\<ominus> F \\<epsilon>h \\<ominus> k\\<^esub>\n              a \\<and>\n     0 < weight (\\<Gamma> \\<ominus> F \\<epsilon>h \\<ominus> k) y\n  edge (\\<Gamma> \\<ominus> F \\<epsilon>h \\<ominus> k) a (p ! 0)\n  p ! 0\n  \\<notin> RF\\<^bsub>\\<Gamma> \\<ominus> F \\<epsilon>h \\<ominus> k\\<^esub>\n            (TER\\<^bsub>\\<Gamma> \\<ominus> F \\<epsilon>h \\<ominus> k\\<^esub>\n              (\\<lambda>_. 0))", "show False"], ["proof (prove)\nusing this:\n  \\<nexists>y.\n     y \\<in> \\<^bold>O\\<^bold>U\\<^bold>T\\<^bsub>\\<Gamma> \\<ominus> F \\<epsilon>h \\<ominus> k\\<^esub>\n              a \\<and>\n     0 < weight (\\<Gamma> \\<ominus> F \\<epsilon>h \\<ominus> k) y\n  edge (\\<Gamma> \\<ominus> F \\<epsilon>h \\<ominus> k) a (p ! 0)\n  p ! 0\n  \\<notin> RF\\<^bsub>\\<Gamma> \\<ominus> F \\<epsilon>h \\<ominus> k\\<^esub>\n            (TER\\<^bsub>\\<Gamma> \\<ominus> F \\<epsilon>h \\<ominus> k\\<^esub>\n              (\\<lambda>_. 0))\n\ngoal (1 subgoal):\n 1. False", "by(auto simp add: not_less outgoing_def intro: roofed_greaterI)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  a \\<notin> \\<E>\\<^bsub>\\<Gamma> \\<ominus> F \\<epsilon>h \\<ominus> k\\<^esub>\n              (TER\\<^bsub>\\<Gamma> \\<ominus> F \\<epsilon>h \\<ominus> k\\<^esub>\n                (\\<lambda>_. 0))\n\ngoal (1 subgoal):\n 1. d_OUT (\\<lambda>_. 0) a\n    < weight (\\<Gamma> \\<ominus> F \\<epsilon>h \\<ominus> k) a", "have \"d_OUT (plus_current (F \\<epsilon>h) k) x = d_OUT (F \\<epsilon>h) x + d_OUT k x\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT (plus_current (F \\<epsilon>h) k) x =\n    d_OUT (F \\<epsilon>h) x + d_OUT k x", "by(simp add: d_OUT_def nn_integral_add)"], ["proof (state)\nthis:\n  d_OUT (plus_current (F \\<epsilon>h) k) ?x =\n  d_OUT (F \\<epsilon>h) ?x + d_OUT k ?x\n\ngoal (1 subgoal):\n 1. d_OUT (\\<lambda>_. 0) a\n    < weight (\\<Gamma> \\<ominus> F \\<epsilon>h \\<ominus> k) a", "then"], ["proof (chain)\npicking this:\n  d_OUT (plus_current (F \\<epsilon>h) k) ?x =\n  d_OUT (F \\<epsilon>h) ?x + d_OUT k ?x", "show \"d_OUT zero_current a < weight ?\\<Omega> a\""], ["proof (prove)\nusing this:\n  d_OUT (plus_current (F \\<epsilon>h) k) ?x =\n  d_OUT (F \\<epsilon>h) ?x + d_OUT k ?x\n\ngoal (1 subgoal):\n 1. d_OUT (\\<lambda>_. 0) a\n    < weight (\\<Gamma> \\<ominus> F \\<epsilon>h \\<ominus> k) a", "using less a_TER[OF that k k_w less] a"], ["proof (prove)\nusing this:\n  d_OUT (plus_current (F \\<epsilon>h) k) ?x =\n  d_OUT (F \\<epsilon>h) ?x + d_OUT k ?x\n  d_OUT (plus_current (F \\<epsilon>h) k) a < weight \\<Gamma> a\n  a \\<in> TER\\<^bsub>\\<Gamma> \\<ominus> F \\<epsilon>h\\<^esub> k\n  a \\<in> A \\<Gamma>\n\ngoal (1 subgoal):\n 1. d_OUT (\\<lambda>_. 0) a\n    < weight (\\<Gamma> \\<ominus> F \\<epsilon>h \\<ominus> k) a", "by(simp add: SINK.simps diff_gr0_ennreal)"], ["proof (state)\nthis:\n  d_OUT (\\<lambda>_. 0) a\n  < weight (\\<Gamma> \\<ominus> F \\<epsilon>h \\<ominus> k) a\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  hindrance (\\<Gamma> \\<ominus> F \\<epsilon>h \\<ominus> k) (\\<lambda>_. 0)\n\ngoal (1 subgoal):\n 1. \\<nexists>y.\n       y \\<in> \\<^bold>O\\<^bold>U\\<^bold>T\\<^bsub>\\<Gamma> \\<ominus> F \\<epsilon>h \\<ominus> k\\<^esub>\n                a \\<and>\n       0 < weight (\\<Gamma> \\<ominus> F \\<epsilon>h \\<ominus> k)\n            y \\<Longrightarrow>\n    False", "hence \"hindered ?\\<Omega>\""], ["proof (prove)\nusing this:\n  hindrance (\\<Gamma> \\<ominus> F \\<epsilon>h \\<ominus> k) (\\<lambda>_. 0)\n\ngoal (1 subgoal):\n 1. hindered (\\<Gamma> \\<ominus> F \\<epsilon>h \\<ominus> k)", "by(auto intro!: hindered.intros order_trans[OF currentD_weight_OUT[OF k]] order_trans[OF currentD_weight_IN[OF k]])"], ["proof (state)\nthis:\n  hindered (\\<Gamma> \\<ominus> F \\<epsilon>h \\<ominus> k)\n\ngoal (1 subgoal):\n 1. \\<nexists>y.\n       y \\<in> \\<^bold>O\\<^bold>U\\<^bold>T\\<^bsub>\\<Gamma> \\<ominus> F \\<epsilon>h \\<ominus> k\\<^esub>\n                a \\<and>\n       0 < weight (\\<Gamma> \\<ominus> F \\<epsilon>h \\<ominus> k)\n            y \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  hindered (\\<Gamma> \\<ominus> F \\<epsilon>h \\<ominus> k)\n\ngoal (1 subgoal):\n 1. \\<nexists>y.\n       y \\<in> \\<^bold>O\\<^bold>U\\<^bold>T\\<^bsub>\\<Gamma> \\<ominus> F \\<epsilon>h \\<ominus> k\\<^esub>\n                a \\<and>\n       0 < weight (\\<Gamma> \\<ominus> F \\<epsilon>h \\<ominus> k)\n            y \\<Longrightarrow>\n    False", "have \"\\<not> hindered ?\\<Omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> hindered (\\<Gamma> \\<ominus> F \\<epsilon>h \\<ominus> k)", "using unhindered'[OF that] k k_w"], ["proof (prove)\nusing this:\n  \\<not> hindered (\\<Gamma> \\<ominus> F \\<epsilon>h)\n  current (\\<Gamma> \\<ominus> F \\<epsilon>h) k\n  wave (\\<Gamma> \\<ominus> F \\<epsilon>h) k\n\ngoal (1 subgoal):\n 1. \\<not> hindered (\\<Gamma> \\<ominus> F \\<epsilon>h \\<ominus> k)", "by(rule \\<Gamma>.unhindered_minus_web)"], ["proof (state)\nthis:\n  \\<not> hindered (\\<Gamma> \\<ominus> F \\<epsilon>h \\<ominus> k)\n\ngoal (1 subgoal):\n 1. \\<nexists>y.\n       y \\<in> \\<^bold>O\\<^bold>U\\<^bold>T\\<^bsub>\\<Gamma> \\<ominus> F \\<epsilon>h \\<ominus> k\\<^esub>\n                a \\<and>\n       0 < weight (\\<Gamma> \\<ominus> F \\<epsilon>h \\<ominus> k)\n            y \\<Longrightarrow>\n    False", "ultimately"], ["proof (chain)\npicking this:\n  hindered (\\<Gamma> \\<ominus> F \\<epsilon>h \\<ominus> k)\n  \\<not> hindered (\\<Gamma> \\<ominus> F \\<epsilon>h \\<ominus> k)", "show False"], ["proof (prove)\nusing this:\n  hindered (\\<Gamma> \\<ominus> F \\<epsilon>h \\<ominus> k)\n  \\<not> hindered (\\<Gamma> \\<ominus> F \\<epsilon>h \\<ominus> k)\n\ngoal (1 subgoal):\n 1. False", "by contradiction"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>?\\<epsilon>h \\<in> Field leq;\n   current (\\<Gamma> \\<ominus> F ?\\<epsilon>h) ?k;\n   wave (\\<Gamma> \\<ominus> F ?\\<epsilon>h) ?k;\n   d_OUT (plus_current (F ?\\<epsilon>h) ?k) a < weight \\<Gamma> a\\<rbrakk>\n  \\<Longrightarrow> \\<exists>y.\n                       y \\<in> \\<^bold>O\\<^bold>U\\<^bold>T\\<^bsub>\\<Gamma> \\<ominus> F ?\\<epsilon>h \\<ominus> ?k\\<^esub>\n                                a \\<and>\n                       0 < weight\n                            (\\<Gamma> \\<ominus> F ?\\<epsilon>h \\<ominus> ?k)\n                            y\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       current \\<Gamma> f \\<and>\n       d_OUT f a = weight \\<Gamma> a \\<and>\n       \\<not> hindered (\\<Gamma> \\<ominus> f)", "have increasing: \"\\<epsilon>h \\<le> sat \\<epsilon>h \\<and> sat \\<epsilon>h \\<in> Field leq\" if \"\\<epsilon>h \\<in> Field leq\" for \\<epsilon>h"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<epsilon>h \\<le> sat \\<epsilon>h \\<and> sat \\<epsilon>h \\<in> Field leq", "proof(cases \\<epsilon>h)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<epsilon>h = (a, b) \\<Longrightarrow>\n       \\<epsilon>h \\<le> sat \\<epsilon>h \\<and>\n       sat \\<epsilon>h \\<in> Field leq", "case (Pair \\<epsilon> h)"], ["proof (state)\nthis:\n  \\<epsilon>h = (\\<epsilon>, h)\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<epsilon>h = (a, b) \\<Longrightarrow>\n       \\<epsilon>h \\<le> sat \\<epsilon>h \\<and>\n       sat \\<epsilon>h \\<in> Field leq", "with that"], ["proof (chain)\npicking this:\n  \\<epsilon>h \\<in> Field leq\n  \\<epsilon>h = (\\<epsilon>, h)", "have that: \"(\\<epsilon>, h) \\<in> Field leq\""], ["proof (prove)\nusing this:\n  \\<epsilon>h \\<in> Field leq\n  \\<epsilon>h = (\\<epsilon>, h)\n\ngoal (1 subgoal):\n 1. (\\<epsilon>, h) \\<in> Field leq", "by simp"], ["proof (state)\nthis:\n  (\\<epsilon>, h) \\<in> Field leq\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<epsilon>h = (a, b) \\<Longrightarrow>\n       \\<epsilon>h \\<le> sat \\<epsilon>h \\<and>\n       sat \\<epsilon>h \\<in> Field leq", "have f: \"current \\<Gamma> (F (\\<epsilon>, h))\" and unhindered: \"\\<not> hindered (\\<Gamma> \\<ominus> F (\\<epsilon>, h))\"\n      and \\<epsilon>: \"current \\<Gamma> \\<epsilon>\"\n      and h: \"current (\\<Gamma> \\<ominus> \\<epsilon>) h\" and h_w: \"wave (\\<Gamma> \\<ominus> \\<epsilon>) h\" and OUT_\\<epsilon>: \"x \\<noteq> a \\<Longrightarrow> d_OUT \\<epsilon> x = 0\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. (current \\<Gamma> (F (\\<epsilon>, h)) &&&\n     \\<not> hindered (\\<Gamma> \\<ominus> F (\\<epsilon>, h)) &&&\n     current \\<Gamma> \\<epsilon>) &&&\n    current (\\<Gamma> \\<ominus> \\<epsilon>) h &&&\n    wave (\\<Gamma> \\<ominus> \\<epsilon>) h &&&\n    (x \\<noteq> a \\<Longrightarrow> d_OUT \\<epsilon> x = 0)", "using that"], ["proof (prove)\nusing this:\n  (\\<epsilon>, h) \\<in> Field leq\n\ngoal (1 subgoal):\n 1. (current \\<Gamma> (F (\\<epsilon>, h)) &&&\n     \\<not> hindered (\\<Gamma> \\<ominus> F (\\<epsilon>, h)) &&&\n     current \\<Gamma> \\<epsilon>) &&&\n    current (\\<Gamma> \\<ominus> \\<epsilon>) h &&&\n    wave (\\<Gamma> \\<ominus> \\<epsilon>) h &&&\n    (x \\<noteq> a \\<Longrightarrow> d_OUT \\<epsilon> x = 0)", "by(rule f unhindered' \\<epsilon>_curr OUT_\\<epsilon> h h_w)+"], ["proof (state)\nthis:\n  current \\<Gamma> (F (\\<epsilon>, h))\n  \\<not> hindered (\\<Gamma> \\<ominus> F (\\<epsilon>, h))\n  current \\<Gamma> \\<epsilon>\n  current (\\<Gamma> \\<ominus> \\<epsilon>) h\n  wave (\\<Gamma> \\<ominus> \\<epsilon>) h\n  ?x \\<noteq> a \\<Longrightarrow> d_OUT \\<epsilon> ?x = 0\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<epsilon>h = (a, b) \\<Longrightarrow>\n       \\<epsilon>h \\<le> sat \\<epsilon>h \\<and>\n       sat \\<epsilon>h \\<in> Field leq", "interpret \\<Gamma>: countable_bipartite_web \"\\<Gamma> \\<ominus> F (\\<epsilon>, h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. countable_bipartite_web (\\<Gamma> \\<ominus> F (\\<epsilon>, h))", "using f"], ["proof (prove)\nusing this:\n  current \\<Gamma> (F (\\<epsilon>, h))\n\ngoal (1 subgoal):\n 1. countable_bipartite_web (\\<Gamma> \\<ominus> F (\\<epsilon>, h))", "by(rule countable_bipartite_web_minus_web)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<epsilon>h = (a, b) \\<Longrightarrow>\n       \\<epsilon>h \\<le> sat \\<epsilon>h \\<and>\n       sat \\<epsilon>h \\<in> Field leq", "note [simp] = weight_minus_web[OF f]"], ["proof (state)\nthis:\n  weight (\\<Gamma> \\<ominus> F (\\<epsilon>, h)) ?x =\n  (if ?x \\<in> A \\<Gamma>\n   then weight \\<Gamma> ?x - d_OUT (F (\\<epsilon>, h)) ?x\n   else weight \\<Gamma> ?x - d_IN (F (\\<epsilon>, h)) ?x)\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<epsilon>h = (a, b) \\<Longrightarrow>\n       \\<epsilon>h \\<le> sat \\<epsilon>h \\<and>\n       sat \\<epsilon>h \\<in> Field leq", "let ?P_k = \"\\<lambda>k. current (\\<Gamma> \\<ominus> F (\\<epsilon>, h)) k \\<and> wave (\\<Gamma> \\<ominus> F (\\<epsilon>, h)) k \\<and> (\\<forall>k'. current (\\<Gamma> \\<ominus> F (\\<epsilon>, h)) k' \\<and> wave (\\<Gamma> \\<ominus> F (\\<epsilon>, h)) k' \\<and> k \\<le> k' \\<longrightarrow> k = k')\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<epsilon>h = (a, b) \\<Longrightarrow>\n       \\<epsilon>h \\<le> sat \\<epsilon>h \\<and>\n       sat \\<epsilon>h \\<in> Field leq", "define k where \"k = Eps ?P_k\""], ["proof (state)\nthis:\n  k =\n  (SOME k.\n      current (\\<Gamma> \\<ominus> F (\\<epsilon>, h)) k \\<and>\n      wave (\\<Gamma> \\<ominus> F (\\<epsilon>, h)) k \\<and>\n      (\\<forall>k'.\n          current (\\<Gamma> \\<ominus> F (\\<epsilon>, h)) k' \\<and>\n          wave (\\<Gamma> \\<ominus> F (\\<epsilon>, h)) k' \\<and>\n          k \\<le> k' \\<longrightarrow>\n          k = k'))\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<epsilon>h = (a, b) \\<Longrightarrow>\n       \\<epsilon>h \\<le> sat \\<epsilon>h \\<and>\n       sat \\<epsilon>h \\<in> Field leq", "have \"Ex ?P_k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>k.\n       current (\\<Gamma> \\<ominus> F (\\<epsilon>, h)) k \\<and>\n       wave (\\<Gamma> \\<ominus> F (\\<epsilon>, h)) k \\<and>\n       (\\<forall>k'.\n           current (\\<Gamma> \\<ominus> F (\\<epsilon>, h)) k' \\<and>\n           wave (\\<Gamma> \\<ominus> F (\\<epsilon>, h)) k' \\<and>\n           k \\<le> k' \\<longrightarrow>\n           k = k')", "by(intro ex_maximal_wave)(simp_all)"], ["proof (state)\nthis:\n  \\<exists>k.\n     current (\\<Gamma> \\<ominus> F (\\<epsilon>, h)) k \\<and>\n     wave (\\<Gamma> \\<ominus> F (\\<epsilon>, h)) k \\<and>\n     (\\<forall>k'.\n         current (\\<Gamma> \\<ominus> F (\\<epsilon>, h)) k' \\<and>\n         wave (\\<Gamma> \\<ominus> F (\\<epsilon>, h)) k' \\<and>\n         k \\<le> k' \\<longrightarrow>\n         k = k')\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<epsilon>h = (a, b) \\<Longrightarrow>\n       \\<epsilon>h \\<le> sat \\<epsilon>h \\<and>\n       sat \\<epsilon>h \\<in> Field leq", "hence \"?P_k k\""], ["proof (prove)\nusing this:\n  \\<exists>k.\n     current (\\<Gamma> \\<ominus> F (\\<epsilon>, h)) k \\<and>\n     wave (\\<Gamma> \\<ominus> F (\\<epsilon>, h)) k \\<and>\n     (\\<forall>k'.\n         current (\\<Gamma> \\<ominus> F (\\<epsilon>, h)) k' \\<and>\n         wave (\\<Gamma> \\<ominus> F (\\<epsilon>, h)) k' \\<and>\n         k \\<le> k' \\<longrightarrow>\n         k = k')\n\ngoal (1 subgoal):\n 1. current (\\<Gamma> \\<ominus> F (\\<epsilon>, h)) k \\<and>\n    wave (\\<Gamma> \\<ominus> F (\\<epsilon>, h)) k \\<and>\n    (\\<forall>k'.\n        current (\\<Gamma> \\<ominus> F (\\<epsilon>, h)) k' \\<and>\n        wave (\\<Gamma> \\<ominus> F (\\<epsilon>, h)) k' \\<and>\n        k \\<le> k' \\<longrightarrow>\n        k = k')", "unfolding k_def"], ["proof (prove)\nusing this:\n  \\<exists>k.\n     current (\\<Gamma> \\<ominus> F (\\<epsilon>, h)) k \\<and>\n     wave (\\<Gamma> \\<ominus> F (\\<epsilon>, h)) k \\<and>\n     (\\<forall>k'.\n         current (\\<Gamma> \\<ominus> F (\\<epsilon>, h)) k' \\<and>\n         wave (\\<Gamma> \\<ominus> F (\\<epsilon>, h)) k' \\<and>\n         k \\<le> k' \\<longrightarrow>\n         k = k')\n\ngoal (1 subgoal):\n 1. current (\\<Gamma> \\<ominus> F (\\<epsilon>, h))\n     (SOME k.\n         current (\\<Gamma> \\<ominus> F (\\<epsilon>, h)) k \\<and>\n         wave (\\<Gamma> \\<ominus> F (\\<epsilon>, h)) k \\<and>\n         (\\<forall>k'.\n             current (\\<Gamma> \\<ominus> F (\\<epsilon>, h)) k' \\<and>\n             wave (\\<Gamma> \\<ominus> F (\\<epsilon>, h)) k' \\<and>\n             k \\<le> k' \\<longrightarrow>\n             k = k')) \\<and>\n    wave (\\<Gamma> \\<ominus> F (\\<epsilon>, h))\n     (SOME k.\n         current (\\<Gamma> \\<ominus> F (\\<epsilon>, h)) k \\<and>\n         wave (\\<Gamma> \\<ominus> F (\\<epsilon>, h)) k \\<and>\n         (\\<forall>k'.\n             current (\\<Gamma> \\<ominus> F (\\<epsilon>, h)) k' \\<and>\n             wave (\\<Gamma> \\<ominus> F (\\<epsilon>, h)) k' \\<and>\n             k \\<le> k' \\<longrightarrow>\n             k = k')) \\<and>\n    (\\<forall>k'.\n        current (\\<Gamma> \\<ominus> F (\\<epsilon>, h)) k' \\<and>\n        wave (\\<Gamma> \\<ominus> F (\\<epsilon>, h)) k' \\<and>\n        (SOME k.\n            current (\\<Gamma> \\<ominus> F (\\<epsilon>, h)) k \\<and>\n            wave (\\<Gamma> \\<ominus> F (\\<epsilon>, h)) k \\<and>\n            (\\<forall>k'.\n                current (\\<Gamma> \\<ominus> F (\\<epsilon>, h)) k' \\<and>\n                wave (\\<Gamma> \\<ominus> F (\\<epsilon>, h)) k' \\<and>\n                k \\<le> k' \\<longrightarrow>\n                k = k'))\n        \\<le> k' \\<longrightarrow>\n        (SOME k.\n            current (\\<Gamma> \\<ominus> F (\\<epsilon>, h)) k \\<and>\n            wave (\\<Gamma> \\<ominus> F (\\<epsilon>, h)) k \\<and>\n            (\\<forall>k'.\n                current (\\<Gamma> \\<ominus> F (\\<epsilon>, h)) k' \\<and>\n                wave (\\<Gamma> \\<ominus> F (\\<epsilon>, h)) k' \\<and>\n                k \\<le> k' \\<longrightarrow>\n                k = k')) =\n        k')", "by(rule someI_ex)"], ["proof (state)\nthis:\n  current (\\<Gamma> \\<ominus> F (\\<epsilon>, h)) k \\<and>\n  wave (\\<Gamma> \\<ominus> F (\\<epsilon>, h)) k \\<and>\n  (\\<forall>k'.\n      current (\\<Gamma> \\<ominus> F (\\<epsilon>, h)) k' \\<and>\n      wave (\\<Gamma> \\<ominus> F (\\<epsilon>, h)) k' \\<and>\n      k \\<le> k' \\<longrightarrow>\n      k = k')\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<epsilon>h = (a, b) \\<Longrightarrow>\n       \\<epsilon>h \\<le> sat \\<epsilon>h \\<and>\n       sat \\<epsilon>h \\<in> Field leq", "hence k: \"current (\\<Gamma> \\<ominus> F (\\<epsilon>, h)) k\" and k_w: \"wave (\\<Gamma> \\<ominus> F (\\<epsilon>, h)) k\"\n      and maximal: \"\\<And>k'. \\<lbrakk> current (\\<Gamma> \\<ominus> F (\\<epsilon>, h)) k'; wave (\\<Gamma> \\<ominus> F (\\<epsilon>, h)) k'; k \\<le> k' \\<rbrakk> \\<Longrightarrow> k = k'\""], ["proof (prove)\nusing this:\n  current (\\<Gamma> \\<ominus> F (\\<epsilon>, h)) k \\<and>\n  wave (\\<Gamma> \\<ominus> F (\\<epsilon>, h)) k \\<and>\n  (\\<forall>k'.\n      current (\\<Gamma> \\<ominus> F (\\<epsilon>, h)) k' \\<and>\n      wave (\\<Gamma> \\<ominus> F (\\<epsilon>, h)) k' \\<and>\n      k \\<le> k' \\<longrightarrow>\n      k = k')\n\ngoal (1 subgoal):\n 1. current (\\<Gamma> \\<ominus> F (\\<epsilon>, h)) k &&&\n    wave (\\<Gamma> \\<ominus> F (\\<epsilon>, h)) k &&&\n    (\\<And>k'.\n        \\<lbrakk>current (\\<Gamma> \\<ominus> F (\\<epsilon>, h)) k';\n         wave (\\<Gamma> \\<ominus> F (\\<epsilon>, h)) k'; k \\<le> k'\\<rbrakk>\n        \\<Longrightarrow> k = k')", "by blast+"], ["proof (state)\nthis:\n  current (\\<Gamma> \\<ominus> F (\\<epsilon>, h)) k\n  wave (\\<Gamma> \\<ominus> F (\\<epsilon>, h)) k\n  \\<lbrakk>current (\\<Gamma> \\<ominus> F (\\<epsilon>, h)) ?k';\n   wave (\\<Gamma> \\<ominus> F (\\<epsilon>, h)) ?k'; k \\<le> ?k'\\<rbrakk>\n  \\<Longrightarrow> k = ?k'\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<epsilon>h = (a, b) \\<Longrightarrow>\n       \\<epsilon>h \\<le> sat \\<epsilon>h \\<and>\n       sat \\<epsilon>h \\<in> Field leq", "note [simp] = \\<Gamma>.weight_minus_web[OF k]"], ["proof (state)\nthis:\n  weight (\\<Gamma> \\<ominus> F (\\<epsilon>, h) \\<ominus> k) ?x =\n  (if ?x \\<in> A (\\<Gamma> \\<ominus> F (\\<epsilon>, h))\n   then weight (\\<Gamma> \\<ominus> F (\\<epsilon>, h)) ?x - d_OUT k ?x\n   else weight (\\<Gamma> \\<ominus> F (\\<epsilon>, h)) ?x - d_IN k ?x)\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<epsilon>h = (a, b) \\<Longrightarrow>\n       \\<epsilon>h \\<le> sat \\<epsilon>h \\<and>\n       sat \\<epsilon>h \\<in> Field leq", "let ?fk = \"plus_current (F (\\<epsilon>, h)) k\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<epsilon>h = (a, b) \\<Longrightarrow>\n       \\<epsilon>h \\<le> sat \\<epsilon>h \\<and>\n       sat \\<epsilon>h \\<in> Field leq", "have IN_fk: \"d_IN ?fk x = d_IN (F (\\<epsilon>, h)) x + d_IN k x\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN (plus_current (F (\\<epsilon>, h)) k) x =\n    d_IN (F (\\<epsilon>, h)) x + d_IN k x", "by(simp add: d_IN_def nn_integral_add)"], ["proof (state)\nthis:\n  d_IN (plus_current (F (\\<epsilon>, h)) k) ?x =\n  d_IN (F (\\<epsilon>, h)) ?x + d_IN k ?x\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<epsilon>h = (a, b) \\<Longrightarrow>\n       \\<epsilon>h \\<le> sat \\<epsilon>h \\<and>\n       sat \\<epsilon>h \\<in> Field leq", "have OUT_fk: \"d_OUT ?fk x = d_OUT (F (\\<epsilon>, h)) x + d_OUT k x\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT (plus_current (F (\\<epsilon>, h)) k) x =\n    d_OUT (F (\\<epsilon>, h)) x + d_OUT k x", "by(simp add: d_OUT_def nn_integral_add)"], ["proof (state)\nthis:\n  d_OUT (plus_current (F (\\<epsilon>, h)) k) ?x =\n  d_OUT (F (\\<epsilon>, h)) ?x + d_OUT k ?x\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<epsilon>h = (a, b) \\<Longrightarrow>\n       \\<epsilon>h \\<le> sat \\<epsilon>h \\<and>\n       sat \\<epsilon>h \\<in> Field leq", "have fk: \"current \\<Gamma> ?fk\""], ["proof (prove)\ngoal (1 subgoal):\n 1. current \\<Gamma> (plus_current (F (\\<epsilon>, h)) k)", "using f k"], ["proof (prove)\nusing this:\n  current \\<Gamma> (F (\\<epsilon>, h))\n  current (\\<Gamma> \\<ominus> F (\\<epsilon>, h)) k\n\ngoal (1 subgoal):\n 1. current \\<Gamma> (plus_current (F (\\<epsilon>, h)) k)", "by(rule current_plus_current_minus)"], ["proof (state)\nthis:\n  current \\<Gamma> (plus_current (F (\\<epsilon>, h)) k)\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<epsilon>h = (a, b) \\<Longrightarrow>\n       \\<epsilon>h \\<le> sat \\<epsilon>h \\<and>\n       sat \\<epsilon>h \\<in> Field leq", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<epsilon>h \\<le> sat \\<epsilon>h \\<and> sat \\<epsilon>h \\<in> Field leq", "proof(cases \"d_OUT ?fk a < weight \\<Gamma> a\")"], ["proof (state)\ngoal (2 subgoals):\n 1. d_OUT (plus_current (F (\\<epsilon>, h)) k) a\n    < weight \\<Gamma> a \\<Longrightarrow>\n    \\<epsilon>h \\<le> sat \\<epsilon>h \\<and> sat \\<epsilon>h \\<in> Field leq\n 2. \\<not> d_OUT (plus_current (F (\\<epsilon>, h)) k) a\n           < weight \\<Gamma> a \\<Longrightarrow>\n    \\<epsilon>h \\<le> sat \\<epsilon>h \\<and> sat \\<epsilon>h \\<in> Field leq", "case less: True"], ["proof (state)\nthis:\n  d_OUT (plus_current (F (\\<epsilon>, h)) k) a < weight \\<Gamma> a\n\ngoal (2 subgoals):\n 1. d_OUT (plus_current (F (\\<epsilon>, h)) k) a\n    < weight \\<Gamma> a \\<Longrightarrow>\n    \\<epsilon>h \\<le> sat \\<epsilon>h \\<and> sat \\<epsilon>h \\<in> Field leq\n 2. \\<not> d_OUT (plus_current (F (\\<epsilon>, h)) k) a\n           < weight \\<Gamma> a \\<Longrightarrow>\n    \\<epsilon>h \\<le> sat \\<epsilon>h \\<and> sat \\<epsilon>h \\<in> Field leq", "define \\<Omega> where \"\\<Omega> = \\<Gamma> \\<ominus> F (\\<epsilon>, h) \\<ominus> k\""], ["proof (state)\nthis:\n  \\<Omega> = \\<Gamma> \\<ominus> F (\\<epsilon>, h) \\<ominus> k\n\ngoal (2 subgoals):\n 1. d_OUT (plus_current (F (\\<epsilon>, h)) k) a\n    < weight \\<Gamma> a \\<Longrightarrow>\n    \\<epsilon>h \\<le> sat \\<epsilon>h \\<and> sat \\<epsilon>h \\<in> Field leq\n 2. \\<not> d_OUT (plus_current (F (\\<epsilon>, h)) k) a\n           < weight \\<Gamma> a \\<Longrightarrow>\n    \\<epsilon>h \\<le> sat \\<epsilon>h \\<and> sat \\<epsilon>h \\<in> Field leq", "have B_\\<Omega> [simp]: \"B \\<Omega> = B \\<Gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B \\<Omega> = B \\<Gamma>", "by(simp add: \\<Omega>_def)"], ["proof (state)\nthis:\n  B \\<Omega> = B \\<Gamma>\n\ngoal (2 subgoals):\n 1. d_OUT (plus_current (F (\\<epsilon>, h)) k) a\n    < weight \\<Gamma> a \\<Longrightarrow>\n    \\<epsilon>h \\<le> sat \\<epsilon>h \\<and> sat \\<epsilon>h \\<in> Field leq\n 2. \\<not> d_OUT (plus_current (F (\\<epsilon>, h)) k) a\n           < weight \\<Gamma> a \\<Longrightarrow>\n    \\<epsilon>h \\<le> sat \\<epsilon>h \\<and> sat \\<epsilon>h \\<in> Field leq", "have loose: \"loose \\<Omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. loose \\<Omega>", "unfolding \\<Omega>_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. loose (\\<Gamma> \\<ominus> F (\\<epsilon>, h) \\<ominus> k)", "using unhindered k k_w maximal"], ["proof (prove)\nusing this:\n  \\<not> hindered (\\<Gamma> \\<ominus> F (\\<epsilon>, h))\n  current (\\<Gamma> \\<ominus> F (\\<epsilon>, h)) k\n  wave (\\<Gamma> \\<ominus> F (\\<epsilon>, h)) k\n  \\<lbrakk>current (\\<Gamma> \\<ominus> F (\\<epsilon>, h)) ?k';\n   wave (\\<Gamma> \\<ominus> F (\\<epsilon>, h)) ?k'; k \\<le> ?k'\\<rbrakk>\n  \\<Longrightarrow> k = ?k'\n\ngoal (1 subgoal):\n 1. loose (\\<Gamma> \\<ominus> F (\\<epsilon>, h) \\<ominus> k)", "by(rule \\<Gamma>.loose_minus_web)"], ["proof (state)\nthis:\n  loose \\<Omega>\n\ngoal (2 subgoals):\n 1. d_OUT (plus_current (F (\\<epsilon>, h)) k) a\n    < weight \\<Gamma> a \\<Longrightarrow>\n    \\<epsilon>h \\<le> sat \\<epsilon>h \\<and> sat \\<epsilon>h \\<in> Field leq\n 2. \\<not> d_OUT (plus_current (F (\\<epsilon>, h)) k) a\n           < weight \\<Gamma> a \\<Longrightarrow>\n    \\<epsilon>h \\<le> sat \\<epsilon>h \\<and> sat \\<epsilon>h \\<in> Field leq", "interpret \\<Omega>: countable_bipartite_web \\<Omega>"], ["proof (prove)\ngoal (1 subgoal):\n 1. countable_bipartite_web \\<Omega>", "using k"], ["proof (prove)\nusing this:\n  current (\\<Gamma> \\<ominus> F (\\<epsilon>, h)) k\n\ngoal (1 subgoal):\n 1. countable_bipartite_web \\<Omega>", "unfolding \\<Omega>_def"], ["proof (prove)\nusing this:\n  current (\\<Gamma> \\<ominus> F (\\<epsilon>, h)) k\n\ngoal (1 subgoal):\n 1. countable_bipartite_web\n     (\\<Gamma> \\<ominus> F (\\<epsilon>, h) \\<ominus> k)", "by(rule \\<Gamma>.countable_bipartite_web_minus_web)"], ["proof (state)\ngoal (2 subgoals):\n 1. d_OUT (plus_current (F (\\<epsilon>, h)) k) a\n    < weight \\<Gamma> a \\<Longrightarrow>\n    \\<epsilon>h \\<le> sat \\<epsilon>h \\<and> sat \\<epsilon>h \\<in> Field leq\n 2. \\<not> d_OUT (plus_current (F (\\<epsilon>, h)) k) a\n           < weight \\<Gamma> a \\<Longrightarrow>\n    \\<epsilon>h \\<le> sat \\<epsilon>h \\<and> sat \\<epsilon>h \\<in> Field leq", "have a_\\<E>: \"a \\<in> TER\\<^bsub>\\<Gamma> \\<ominus> F (\\<epsilon>, h)\\<^esub> k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<in> TER\\<^bsub>\\<Gamma> \\<ominus> F (\\<epsilon>, h)\\<^esub> k", "using that k k_w less"], ["proof (prove)\nusing this:\n  (\\<epsilon>, h) \\<in> Field leq\n  current (\\<Gamma> \\<ominus> F (\\<epsilon>, h)) k\n  wave (\\<Gamma> \\<ominus> F (\\<epsilon>, h)) k\n  d_OUT (plus_current (F (\\<epsilon>, h)) k) a < weight \\<Gamma> a\n\ngoal (1 subgoal):\n 1. a \\<in> TER\\<^bsub>\\<Gamma> \\<ominus> F (\\<epsilon>, h)\\<^esub> k", "by(rule a_TER)"], ["proof (state)\nthis:\n  a \\<in> TER\\<^bsub>\\<Gamma> \\<ominus> F (\\<epsilon>, h)\\<^esub> k\n\ngoal (2 subgoals):\n 1. d_OUT (plus_current (F (\\<epsilon>, h)) k) a\n    < weight \\<Gamma> a \\<Longrightarrow>\n    \\<epsilon>h \\<le> sat \\<epsilon>h \\<and> sat \\<epsilon>h \\<in> Field leq\n 2. \\<not> d_OUT (plus_current (F (\\<epsilon>, h)) k) a\n           < weight \\<Gamma> a \\<Longrightarrow>\n    \\<epsilon>h \\<le> sat \\<epsilon>h \\<and> sat \\<epsilon>h \\<in> Field leq", "then"], ["proof (chain)\npicking this:\n  a \\<in> TER\\<^bsub>\\<Gamma> \\<ominus> F (\\<epsilon>, h)\\<^esub> k", "have weight_\\<Omega>_a: \"weight \\<Omega> a = weight \\<Gamma> a - d_OUT (F (\\<epsilon>, h)) a\""], ["proof (prove)\nusing this:\n  a \\<in> TER\\<^bsub>\\<Gamma> \\<ominus> F (\\<epsilon>, h)\\<^esub> k\n\ngoal (1 subgoal):\n 1. weight \\<Omega> a = weight \\<Gamma> a - d_OUT (F (\\<epsilon>, h)) a", "using a disjoint"], ["proof (prove)\nusing this:\n  a \\<in> TER\\<^bsub>\\<Gamma> \\<ominus> F (\\<epsilon>, h)\\<^esub> k\n  a \\<in> A \\<Gamma>\n  A \\<Gamma> \\<inter> B \\<Gamma> = {}\n\ngoal (1 subgoal):\n 1. weight \\<Omega> a = weight \\<Gamma> a - d_OUT (F (\\<epsilon>, h)) a", "by(auto simp add: roofed_circ_def \\<Omega>_def SINK.simps)"], ["proof (state)\nthis:\n  weight \\<Omega> a = weight \\<Gamma> a - d_OUT (F (\\<epsilon>, h)) a\n\ngoal (2 subgoals):\n 1. d_OUT (plus_current (F (\\<epsilon>, h)) k) a\n    < weight \\<Gamma> a \\<Longrightarrow>\n    \\<epsilon>h \\<le> sat \\<epsilon>h \\<and> sat \\<epsilon>h \\<in> Field leq\n 2. \\<not> d_OUT (plus_current (F (\\<epsilon>, h)) k) a\n           < weight \\<Gamma> a \\<Longrightarrow>\n    \\<epsilon>h \\<le> sat \\<epsilon>h \\<and> sat \\<epsilon>h \\<in> Field leq", "then"], ["proof (chain)\npicking this:\n  weight \\<Omega> a = weight \\<Gamma> a - d_OUT (F (\\<epsilon>, h)) a", "have weight_a: \"0 < weight \\<Omega> a\""], ["proof (prove)\nusing this:\n  weight \\<Omega> a = weight \\<Gamma> a - d_OUT (F (\\<epsilon>, h)) a\n\ngoal (1 subgoal):\n 1. 0 < weight \\<Omega> a", "using less a_\\<E>"], ["proof (prove)\nusing this:\n  weight \\<Omega> a = weight \\<Gamma> a - d_OUT (F (\\<epsilon>, h)) a\n  d_OUT (plus_current (F (\\<epsilon>, h)) k) a < weight \\<Gamma> a\n  a \\<in> TER\\<^bsub>\\<Gamma> \\<ominus> F (\\<epsilon>, h)\\<^esub> k\n\ngoal (1 subgoal):\n 1. 0 < weight \\<Omega> a", "by(simp add: OUT_fk SINK.simps diff_gr0_ennreal)"], ["proof (state)\nthis:\n  0 < weight \\<Omega> a\n\ngoal (2 subgoals):\n 1. d_OUT (plus_current (F (\\<epsilon>, h)) k) a\n    < weight \\<Gamma> a \\<Longrightarrow>\n    \\<epsilon>h \\<le> sat \\<epsilon>h \\<and> sat \\<epsilon>h \\<in> Field leq\n 2. \\<not> d_OUT (plus_current (F (\\<epsilon>, h)) k) a\n           < weight \\<Gamma> a \\<Longrightarrow>\n    \\<epsilon>h \\<le> sat \\<epsilon>h \\<and> sat \\<epsilon>h \\<in> Field leq", "let ?P_y = \"\\<lambda>y. y \\<in> \\<^bold>O\\<^bold>U\\<^bold>T\\<^bsub>\\<Omega>\\<^esub> a \\<and> weight \\<Omega> y > 0\""], ["proof (state)\ngoal (2 subgoals):\n 1. d_OUT (plus_current (F (\\<epsilon>, h)) k) a\n    < weight \\<Gamma> a \\<Longrightarrow>\n    \\<epsilon>h \\<le> sat \\<epsilon>h \\<and> sat \\<epsilon>h \\<in> Field leq\n 2. \\<not> d_OUT (plus_current (F (\\<epsilon>, h)) k) a\n           < weight \\<Gamma> a \\<Longrightarrow>\n    \\<epsilon>h \\<le> sat \\<epsilon>h \\<and> sat \\<epsilon>h \\<in> Field leq", "define y where \"y = Eps ?P_y\""], ["proof (state)\nthis:\n  y =\n  (SOME y.\n      y \\<in> \\<^bold>O\\<^bold>U\\<^bold>T\\<^bsub>\\<Omega>\\<^esub> a \\<and>\n      0 < weight \\<Omega> y)\n\ngoal (2 subgoals):\n 1. d_OUT (plus_current (F (\\<epsilon>, h)) k) a\n    < weight \\<Gamma> a \\<Longrightarrow>\n    \\<epsilon>h \\<le> sat \\<epsilon>h \\<and> sat \\<epsilon>h \\<in> Field leq\n 2. \\<not> d_OUT (plus_current (F (\\<epsilon>, h)) k) a\n           < weight \\<Gamma> a \\<Longrightarrow>\n    \\<epsilon>h \\<le> sat \\<epsilon>h \\<and> sat \\<epsilon>h \\<in> Field leq", "have \"Ex ?P_y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>y.\n       y \\<in> \\<^bold>O\\<^bold>U\\<^bold>T\\<^bsub>\\<Omega>\\<^esub> a \\<and>\n       0 < weight \\<Omega> y", "using that k k_w less"], ["proof (prove)\nusing this:\n  (\\<epsilon>, h) \\<in> Field leq\n  current (\\<Gamma> \\<ominus> F (\\<epsilon>, h)) k\n  wave (\\<Gamma> \\<ominus> F (\\<epsilon>, h)) k\n  d_OUT (plus_current (F (\\<epsilon>, h)) k) a < weight \\<Gamma> a\n\ngoal (1 subgoal):\n 1. \\<exists>y.\n       y \\<in> \\<^bold>O\\<^bold>U\\<^bold>T\\<^bsub>\\<Omega>\\<^esub> a \\<and>\n       0 < weight \\<Omega> y", "unfolding \\<Omega>_def"], ["proof (prove)\nusing this:\n  (\\<epsilon>, h) \\<in> Field leq\n  current (\\<Gamma> \\<ominus> F (\\<epsilon>, h)) k\n  wave (\\<Gamma> \\<ominus> F (\\<epsilon>, h)) k\n  d_OUT (plus_current (F (\\<epsilon>, h)) k) a < weight \\<Gamma> a\n\ngoal (1 subgoal):\n 1. \\<exists>y.\n       y \\<in> \\<^bold>O\\<^bold>U\\<^bold>T\\<^bsub>\\<Gamma> \\<ominus> F (\\<epsilon>, h) \\<ominus> k\\<^esub>\n                a \\<and>\n       0 < weight (\\<Gamma> \\<ominus> F (\\<epsilon>, h) \\<ominus> k) y", "by(rule Ex_y)"], ["proof (state)\nthis:\n  \\<exists>y.\n     y \\<in> \\<^bold>O\\<^bold>U\\<^bold>T\\<^bsub>\\<Omega>\\<^esub> a \\<and>\n     0 < weight \\<Omega> y\n\ngoal (2 subgoals):\n 1. d_OUT (plus_current (F (\\<epsilon>, h)) k) a\n    < weight \\<Gamma> a \\<Longrightarrow>\n    \\<epsilon>h \\<le> sat \\<epsilon>h \\<and> sat \\<epsilon>h \\<in> Field leq\n 2. \\<not> d_OUT (plus_current (F (\\<epsilon>, h)) k) a\n           < weight \\<Gamma> a \\<Longrightarrow>\n    \\<epsilon>h \\<le> sat \\<epsilon>h \\<and> sat \\<epsilon>h \\<in> Field leq", "hence \"?P_y y\""], ["proof (prove)\nusing this:\n  \\<exists>y.\n     y \\<in> \\<^bold>O\\<^bold>U\\<^bold>T\\<^bsub>\\<Omega>\\<^esub> a \\<and>\n     0 < weight \\<Omega> y\n\ngoal (1 subgoal):\n 1. y \\<in> \\<^bold>O\\<^bold>U\\<^bold>T\\<^bsub>\\<Omega>\\<^esub> a \\<and>\n    0 < weight \\<Omega> y", "unfolding y_def"], ["proof (prove)\nusing this:\n  \\<exists>y.\n     y \\<in> \\<^bold>O\\<^bold>U\\<^bold>T\\<^bsub>\\<Omega>\\<^esub> a \\<and>\n     0 < weight \\<Omega> y\n\ngoal (1 subgoal):\n 1. (SOME y.\n        y \\<in> \\<^bold>O\\<^bold>U\\<^bold>T\\<^bsub>\\<Omega>\\<^esub> a \\<and>\n        0 < weight \\<Omega> y)\n    \\<in> \\<^bold>O\\<^bold>U\\<^bold>T\\<^bsub>\\<Omega>\\<^esub> a \\<and>\n    0 < weight \\<Omega>\n         (SOME y.\n             y \\<in> \\<^bold>O\\<^bold>U\\<^bold>T\\<^bsub>\\<Omega>\\<^esub>\n                      a \\<and>\n             0 < weight \\<Omega> y)", "by(rule someI_ex)"], ["proof (state)\nthis:\n  y \\<in> \\<^bold>O\\<^bold>U\\<^bold>T\\<^bsub>\\<Omega>\\<^esub> a \\<and>\n  0 < weight \\<Omega> y\n\ngoal (2 subgoals):\n 1. d_OUT (plus_current (F (\\<epsilon>, h)) k) a\n    < weight \\<Gamma> a \\<Longrightarrow>\n    \\<epsilon>h \\<le> sat \\<epsilon>h \\<and> sat \\<epsilon>h \\<in> Field leq\n 2. \\<not> d_OUT (plus_current (F (\\<epsilon>, h)) k) a\n           < weight \\<Gamma> a \\<Longrightarrow>\n    \\<epsilon>h \\<le> sat \\<epsilon>h \\<and> sat \\<epsilon>h \\<in> Field leq", "hence y_OUT: \"y \\<in> \\<^bold>O\\<^bold>U\\<^bold>T\\<^bsub>\\<Omega>\\<^esub> a\" and weight_y: \"weight \\<Omega> y > 0\""], ["proof (prove)\nusing this:\n  y \\<in> \\<^bold>O\\<^bold>U\\<^bold>T\\<^bsub>\\<Omega>\\<^esub> a \\<and>\n  0 < weight \\<Omega> y\n\ngoal (1 subgoal):\n 1. y \\<in> \\<^bold>O\\<^bold>U\\<^bold>T\\<^bsub>\\<Omega>\\<^esub> a &&&\n    0 < weight \\<Omega> y", "by blast+"], ["proof (state)\nthis:\n  y \\<in> \\<^bold>O\\<^bold>U\\<^bold>T\\<^bsub>\\<Omega>\\<^esub> a\n  0 < weight \\<Omega> y\n\ngoal (2 subgoals):\n 1. d_OUT (plus_current (F (\\<epsilon>, h)) k) a\n    < weight \\<Gamma> a \\<Longrightarrow>\n    \\<epsilon>h \\<le> sat \\<epsilon>h \\<and> sat \\<epsilon>h \\<in> Field leq\n 2. \\<not> d_OUT (plus_current (F (\\<epsilon>, h)) k) a\n           < weight \\<Gamma> a \\<Longrightarrow>\n    \\<epsilon>h \\<le> sat \\<epsilon>h \\<and> sat \\<epsilon>h \\<in> Field leq", "from y_OUT"], ["proof (chain)\npicking this:\n  y \\<in> \\<^bold>O\\<^bold>U\\<^bold>T\\<^bsub>\\<Omega>\\<^esub> a", "have y_B: \"y \\<in> B \\<Omega>\""], ["proof (prove)\nusing this:\n  y \\<in> \\<^bold>O\\<^bold>U\\<^bold>T\\<^bsub>\\<Omega>\\<^esub> a\n\ngoal (1 subgoal):\n 1. y \\<in> B \\<Omega>", "by(auto simp add: outgoing_def \\<Omega>_def dest: bipartite_E)"], ["proof (state)\nthis:\n  y \\<in> B \\<Omega>\n\ngoal (2 subgoals):\n 1. d_OUT (plus_current (F (\\<epsilon>, h)) k) a\n    < weight \\<Gamma> a \\<Longrightarrow>\n    \\<epsilon>h \\<le> sat \\<epsilon>h \\<and> sat \\<epsilon>h \\<in> Field leq\n 2. \\<not> d_OUT (plus_current (F (\\<epsilon>, h)) k) a\n           < weight \\<Gamma> a \\<Longrightarrow>\n    \\<epsilon>h \\<le> sat \\<epsilon>h \\<and> sat \\<epsilon>h \\<in> Field leq", "with weight_y"], ["proof (chain)\npicking this:\n  0 < weight \\<Omega> y\n  y \\<in> B \\<Omega>", "have yRF: \"y \\<notin> RF\\<^bsub>\\<Gamma> \\<ominus> F (\\<epsilon>, h)\\<^esub> (TER\\<^bsub>\\<Gamma> \\<ominus> F (\\<epsilon>, h)\\<^esub> k)\""], ["proof (prove)\nusing this:\n  0 < weight \\<Omega> y\n  y \\<in> B \\<Omega>\n\ngoal (1 subgoal):\n 1. y \\<notin> RF\\<^bsub>\\<Gamma> \\<ominus> F (\\<epsilon>, h)\\<^esub>\n                (TER\\<^bsub>\\<Gamma> \\<ominus> F (\\<epsilon>, h)\\<^esub> k)", "unfolding \\<Omega>_def"], ["proof (prove)\nusing this:\n  0 < weight (\\<Gamma> \\<ominus> F (\\<epsilon>, h) \\<ominus> k) y\n  y \\<in> B (\\<Gamma> \\<ominus> F (\\<epsilon>, h) \\<ominus> k)\n\ngoal (1 subgoal):\n 1. y \\<notin> RF\\<^bsub>\\<Gamma> \\<ominus> F (\\<epsilon>, h)\\<^esub>\n                (TER\\<^bsub>\\<Gamma> \\<ominus> F (\\<epsilon>, h)\\<^esub> k)", "using currentD_OUT[OF k, of y] disjoint"], ["proof (prove)\nusing this:\n  0 < weight (\\<Gamma> \\<ominus> F (\\<epsilon>, h) \\<ominus> k) y\n  y \\<in> B (\\<Gamma> \\<ominus> F (\\<epsilon>, h) \\<ominus> k)\n  y \\<in> B (\\<Gamma> \\<ominus> F (\\<epsilon>, h)) \\<Longrightarrow>\n  d_OUT k y = 0\n  A \\<Gamma> \\<inter> B \\<Gamma> = {}\n\ngoal (1 subgoal):\n 1. y \\<notin> RF\\<^bsub>\\<Gamma> \\<ominus> F (\\<epsilon>, h)\\<^esub>\n                (TER\\<^bsub>\\<Gamma> \\<ominus> F (\\<epsilon>, h)\\<^esub> k)", "by(auto split: if_split_asm simp add: SINK.simps currentD_SAT[OF k] roofed_circ_def RF_in_B \\<Gamma>.currentD_finite_IN[OF k])"], ["proof (state)\nthis:\n  y \\<notin> RF\\<^bsub>\\<Gamma> \\<ominus> F (\\<epsilon>, h)\\<^esub>\n              (TER\\<^bsub>\\<Gamma> \\<ominus> F (\\<epsilon>, h)\\<^esub> k)\n\ngoal (2 subgoals):\n 1. d_OUT (plus_current (F (\\<epsilon>, h)) k) a\n    < weight \\<Gamma> a \\<Longrightarrow>\n    \\<epsilon>h \\<le> sat \\<epsilon>h \\<and> sat \\<epsilon>h \\<in> Field leq\n 2. \\<not> d_OUT (plus_current (F (\\<epsilon>, h)) k) a\n           < weight \\<Gamma> a \\<Longrightarrow>\n    \\<epsilon>h \\<le> sat \\<epsilon>h \\<and> sat \\<epsilon>h \\<in> Field leq", "hence IN_k_y: \"d_IN k y = 0\""], ["proof (prove)\nusing this:\n  y \\<notin> RF\\<^bsub>\\<Gamma> \\<ominus> F (\\<epsilon>, h)\\<^esub>\n              (TER\\<^bsub>\\<Gamma> \\<ominus> F (\\<epsilon>, h)\\<^esub> k)\n\ngoal (1 subgoal):\n 1. d_IN k y = 0", "by(rule wave_not_RF_IN_zero[OF k k_w])"], ["proof (state)\nthis:\n  d_IN k y = 0\n\ngoal (2 subgoals):\n 1. d_OUT (plus_current (F (\\<epsilon>, h)) k) a\n    < weight \\<Gamma> a \\<Longrightarrow>\n    \\<epsilon>h \\<le> sat \\<epsilon>h \\<and> sat \\<epsilon>h \\<in> Field leq\n 2. \\<not> d_OUT (plus_current (F (\\<epsilon>, h)) k) a\n           < weight \\<Gamma> a \\<Longrightarrow>\n    \\<epsilon>h \\<le> sat \\<epsilon>h \\<and> sat \\<epsilon>h \\<in> Field leq", "define bound where \"bound = enn2real (min (weight \\<Omega> a) (weight \\<Omega> y))\""], ["proof (state)\nthis:\n  bound = enn2real (min (weight \\<Omega> a) (weight \\<Omega> y))\n\ngoal (2 subgoals):\n 1. d_OUT (plus_current (F (\\<epsilon>, h)) k) a\n    < weight \\<Gamma> a \\<Longrightarrow>\n    \\<epsilon>h \\<le> sat \\<epsilon>h \\<and> sat \\<epsilon>h \\<in> Field leq\n 2. \\<not> d_OUT (plus_current (F (\\<epsilon>, h)) k) a\n           < weight \\<Gamma> a \\<Longrightarrow>\n    \\<epsilon>h \\<le> sat \\<epsilon>h \\<and> sat \\<epsilon>h \\<in> Field leq", "have bound_pos: \"bound > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < bound", "using weight_y weight_a"], ["proof (prove)\nusing this:\n  0 < weight \\<Omega> y\n  0 < weight \\<Omega> a\n\ngoal (1 subgoal):\n 1. 0 < bound", "using \\<Omega>.weight_finite"], ["proof (prove)\nusing this:\n  0 < weight \\<Omega> y\n  0 < weight \\<Omega> a\n  weight \\<Omega> ?x \\<noteq> \\<top>\n\ngoal (1 subgoal):\n 1. 0 < bound", "by(cases \"weight \\<Omega> a\" \"weight \\<Omega> y\" rule: ennreal2_cases)\n          (simp_all add: bound_def min_def split: if_split_asm)"], ["proof (state)\nthis:\n  0 < bound\n\ngoal (2 subgoals):\n 1. d_OUT (plus_current (F (\\<epsilon>, h)) k) a\n    < weight \\<Gamma> a \\<Longrightarrow>\n    \\<epsilon>h \\<le> sat \\<epsilon>h \\<and> sat \\<epsilon>h \\<in> Field leq\n 2. \\<not> d_OUT (plus_current (F (\\<epsilon>, h)) k) a\n           < weight \\<Gamma> a \\<Longrightarrow>\n    \\<epsilon>h \\<le> sat \\<epsilon>h \\<and> sat \\<epsilon>h \\<in> Field leq", "let ?P_\\<delta> = \"\\<lambda>\\<delta>. \\<delta> > 0 \\<and> \\<delta> < bound \\<and> \\<not> hindered (reduce_weight \\<Omega> y \\<delta>)\""], ["proof (state)\ngoal (2 subgoals):\n 1. d_OUT (plus_current (F (\\<epsilon>, h)) k) a\n    < weight \\<Gamma> a \\<Longrightarrow>\n    \\<epsilon>h \\<le> sat \\<epsilon>h \\<and> sat \\<epsilon>h \\<in> Field leq\n 2. \\<not> d_OUT (plus_current (F (\\<epsilon>, h)) k) a\n           < weight \\<Gamma> a \\<Longrightarrow>\n    \\<epsilon>h \\<le> sat \\<epsilon>h \\<and> sat \\<epsilon>h \\<in> Field leq", "define \\<delta> where \"\\<delta> = Eps ?P_\\<delta>\""], ["proof (state)\nthis:\n  \\<delta> =\n  (SOME \\<delta>.\n      0 < \\<delta> \\<and>\n      \\<delta> < bound \\<and>\n      \\<not> hindered (reduce_weight \\<Omega> y \\<delta>))\n\ngoal (2 subgoals):\n 1. d_OUT (plus_current (F (\\<epsilon>, h)) k) a\n    < weight \\<Gamma> a \\<Longrightarrow>\n    \\<epsilon>h \\<le> sat \\<epsilon>h \\<and> sat \\<epsilon>h \\<in> Field leq\n 2. \\<not> d_OUT (plus_current (F (\\<epsilon>, h)) k) a\n           < weight \\<Gamma> a \\<Longrightarrow>\n    \\<epsilon>h \\<le> sat \\<epsilon>h \\<and> sat \\<epsilon>h \\<in> Field leq", "let ?\\<Omega> = \"reduce_weight \\<Omega> y \\<delta>\""], ["proof (state)\ngoal (2 subgoals):\n 1. d_OUT (plus_current (F (\\<epsilon>, h)) k) a\n    < weight \\<Gamma> a \\<Longrightarrow>\n    \\<epsilon>h \\<le> sat \\<epsilon>h \\<and> sat \\<epsilon>h \\<in> Field leq\n 2. \\<not> d_OUT (plus_current (F (\\<epsilon>, h)) k) a\n           < weight \\<Gamma> a \\<Longrightarrow>\n    \\<epsilon>h \\<le> sat \\<epsilon>h \\<and> sat \\<epsilon>h \\<in> Field leq", "from \\<Omega>.unhinder[OF loose _ weight_y bound_pos] y_B disjoint"], ["proof (chain)\npicking this:\n  y \\<in> B \\<Omega> \\<Longrightarrow>\n  \\<exists>\\<epsilon>>0.\n     \\<epsilon> < bound \\<and>\n     \\<not> hindered (reduce_weight \\<Omega> y \\<epsilon>)\n  y \\<in> B \\<Omega>\n  A \\<Gamma> \\<inter> B \\<Gamma> = {}", "have \"Ex ?P_\\<delta>\""], ["proof (prove)\nusing this:\n  y \\<in> B \\<Omega> \\<Longrightarrow>\n  \\<exists>\\<epsilon>>0.\n     \\<epsilon> < bound \\<and>\n     \\<not> hindered (reduce_weight \\<Omega> y \\<epsilon>)\n  y \\<in> B \\<Omega>\n  A \\<Gamma> \\<inter> B \\<Gamma> = {}\n\ngoal (1 subgoal):\n 1. \\<exists>\\<delta>>0.\n       \\<delta> < bound \\<and>\n       \\<not> hindered (reduce_weight \\<Omega> y \\<delta>)", "by(auto simp add: \\<Omega>_def)"], ["proof (state)\nthis:\n  \\<exists>\\<delta>>0.\n     \\<delta> < bound \\<and>\n     \\<not> hindered (reduce_weight \\<Omega> y \\<delta>)\n\ngoal (2 subgoals):\n 1. d_OUT (plus_current (F (\\<epsilon>, h)) k) a\n    < weight \\<Gamma> a \\<Longrightarrow>\n    \\<epsilon>h \\<le> sat \\<epsilon>h \\<and> sat \\<epsilon>h \\<in> Field leq\n 2. \\<not> d_OUT (plus_current (F (\\<epsilon>, h)) k) a\n           < weight \\<Gamma> a \\<Longrightarrow>\n    \\<epsilon>h \\<le> sat \\<epsilon>h \\<and> sat \\<epsilon>h \\<in> Field leq", "hence \"?P_\\<delta> \\<delta>\""], ["proof (prove)\nusing this:\n  \\<exists>\\<delta>>0.\n     \\<delta> < bound \\<and>\n     \\<not> hindered (reduce_weight \\<Omega> y \\<delta>)\n\ngoal (1 subgoal):\n 1. 0 < \\<delta> \\<and>\n    \\<delta> < bound \\<and>\n    \\<not> hindered (reduce_weight \\<Omega> y \\<delta>)", "unfolding \\<delta>_def"], ["proof (prove)\nusing this:\n  \\<exists>\\<delta>>0.\n     \\<delta> < bound \\<and>\n     \\<not> hindered (reduce_weight \\<Omega> y \\<delta>)\n\ngoal (1 subgoal):\n 1. 0 < (SOME \\<delta>.\n            0 < \\<delta> \\<and>\n            \\<delta> < bound \\<and>\n            \\<not> hindered (reduce_weight \\<Omega> y \\<delta>)) \\<and>\n    (SOME \\<delta>.\n        0 < \\<delta> \\<and>\n        \\<delta> < bound \\<and>\n        \\<not> hindered (reduce_weight \\<Omega> y \\<delta>))\n    < bound \\<and>\n    \\<not> hindered\n            (reduce_weight \\<Omega> y\n              (SOME \\<delta>.\n                  0 < \\<delta> \\<and>\n                  \\<delta> < bound \\<and>\n                  \\<not> hindered (reduce_weight \\<Omega> y \\<delta>)))", "by(rule someI_ex)"], ["proof (state)\nthis:\n  0 < \\<delta> \\<and>\n  \\<delta> < bound \\<and>\n  \\<not> hindered (reduce_weight \\<Omega> y \\<delta>)\n\ngoal (2 subgoals):\n 1. d_OUT (plus_current (F (\\<epsilon>, h)) k) a\n    < weight \\<Gamma> a \\<Longrightarrow>\n    \\<epsilon>h \\<le> sat \\<epsilon>h \\<and> sat \\<epsilon>h \\<in> Field leq\n 2. \\<not> d_OUT (plus_current (F (\\<epsilon>, h)) k) a\n           < weight \\<Gamma> a \\<Longrightarrow>\n    \\<epsilon>h \\<le> sat \\<epsilon>h \\<and> sat \\<epsilon>h \\<in> Field leq", "hence \\<delta>_pos: \"0 < \\<delta>\" and \\<delta>_le_bound: \"\\<delta> < bound\" and unhindered': \"\\<not> hindered ?\\<Omega>\""], ["proof (prove)\nusing this:\n  0 < \\<delta> \\<and>\n  \\<delta> < bound \\<and>\n  \\<not> hindered (reduce_weight \\<Omega> y \\<delta>)\n\ngoal (1 subgoal):\n 1. 0 < \\<delta> &&&\n    \\<delta> < bound &&& \\<not> hindered (reduce_weight \\<Omega> y \\<delta>)", "by blast+"], ["proof (state)\nthis:\n  0 < \\<delta>\n  \\<delta> < bound\n  \\<not> hindered (reduce_weight \\<Omega> y \\<delta>)\n\ngoal (2 subgoals):\n 1. d_OUT (plus_current (F (\\<epsilon>, h)) k) a\n    < weight \\<Gamma> a \\<Longrightarrow>\n    \\<epsilon>h \\<le> sat \\<epsilon>h \\<and> sat \\<epsilon>h \\<in> Field leq\n 2. \\<not> d_OUT (plus_current (F (\\<epsilon>, h)) k) a\n           < weight \\<Gamma> a \\<Longrightarrow>\n    \\<epsilon>h \\<le> sat \\<epsilon>h \\<and> sat \\<epsilon>h \\<in> Field leq", "from \\<delta>_pos"], ["proof (chain)\npicking this:\n  0 < \\<delta>", "have \\<delta>_nonneg: \"0 \\<le> \\<delta>\""], ["proof (prove)\nusing this:\n  0 < \\<delta>\n\ngoal (1 subgoal):\n 1. 0 \\<le> \\<delta>", "by simp"], ["proof (state)\nthis:\n  0 \\<le> \\<delta>\n\ngoal (2 subgoals):\n 1. d_OUT (plus_current (F (\\<epsilon>, h)) k) a\n    < weight \\<Gamma> a \\<Longrightarrow>\n    \\<epsilon>h \\<le> sat \\<epsilon>h \\<and> sat \\<epsilon>h \\<in> Field leq\n 2. \\<not> d_OUT (plus_current (F (\\<epsilon>, h)) k) a\n           < weight \\<Gamma> a \\<Longrightarrow>\n    \\<epsilon>h \\<le> sat \\<epsilon>h \\<and> sat \\<epsilon>h \\<in> Field leq", "from \\<delta>_le_bound \\<delta>_pos"], ["proof (chain)\npicking this:\n  \\<delta> < bound\n  0 < \\<delta>", "have \\<delta>_le_a: \"\\<delta> < weight \\<Omega> a\" and \\<delta>_le_y: \"\\<delta> < weight \\<Omega> y\""], ["proof (prove)\nusing this:\n  \\<delta> < bound\n  0 < \\<delta>\n\ngoal (1 subgoal):\n 1. ennreal \\<delta> < weight \\<Omega> a &&&\n    ennreal \\<delta> < weight \\<Omega> y", "by(cases \"weight \\<Omega> a\" \"weight \\<Omega> y\" rule: ennreal2_cases;\n           simp add: bound_def min_def ennreal_less_iff split: if_split_asm)+"], ["proof (state)\nthis:\n  ennreal \\<delta> < weight \\<Omega> a\n  ennreal \\<delta> < weight \\<Omega> y\n\ngoal (2 subgoals):\n 1. d_OUT (plus_current (F (\\<epsilon>, h)) k) a\n    < weight \\<Gamma> a \\<Longrightarrow>\n    \\<epsilon>h \\<le> sat \\<epsilon>h \\<and> sat \\<epsilon>h \\<in> Field leq\n 2. \\<not> d_OUT (plus_current (F (\\<epsilon>, h)) k) a\n           < weight \\<Gamma> a \\<Longrightarrow>\n    \\<epsilon>h \\<le> sat \\<epsilon>h \\<and> sat \\<epsilon>h \\<in> Field leq", "let ?\\<Gamma> = \"\\<Gamma> \\<ominus> ?fk\""], ["proof (state)\ngoal (2 subgoals):\n 1. d_OUT (plus_current (F (\\<epsilon>, h)) k) a\n    < weight \\<Gamma> a \\<Longrightarrow>\n    \\<epsilon>h \\<le> sat \\<epsilon>h \\<and> sat \\<epsilon>h \\<in> Field leq\n 2. \\<not> d_OUT (plus_current (F (\\<epsilon>, h)) k) a\n           < weight \\<Gamma> a \\<Longrightarrow>\n    \\<epsilon>h \\<le> sat \\<epsilon>h \\<and> sat \\<epsilon>h \\<in> Field leq", "interpret \\<Gamma>': countable_bipartite_web ?\\<Gamma>"], ["proof (prove)\ngoal (1 subgoal):\n 1. countable_bipartite_web\n     (\\<Gamma> \\<ominus> plus_current (F (\\<epsilon>, h)) k)", "by(rule countable_bipartite_web_minus_web fk)+"], ["proof (state)\ngoal (2 subgoals):\n 1. d_OUT (plus_current (F (\\<epsilon>, h)) k) a\n    < weight \\<Gamma> a \\<Longrightarrow>\n    \\<epsilon>h \\<le> sat \\<epsilon>h \\<and> sat \\<epsilon>h \\<in> Field leq\n 2. \\<not> d_OUT (plus_current (F (\\<epsilon>, h)) k) a\n           < weight \\<Gamma> a \\<Longrightarrow>\n    \\<epsilon>h \\<le> sat \\<epsilon>h \\<and> sat \\<epsilon>h \\<in> Field leq", "note [simp] = weight_minus_web[OF fk]"], ["proof (state)\nthis:\n  weight (\\<Gamma> \\<ominus> plus_current (F (\\<epsilon>, h)) k) ?x =\n  (if ?x \\<in> A \\<Gamma>\n   then weight \\<Gamma> ?x - d_OUT (plus_current (F (\\<epsilon>, h)) k) ?x\n   else weight \\<Gamma> ?x - d_IN (plus_current (F (\\<epsilon>, h)) k) ?x)\n\ngoal (2 subgoals):\n 1. d_OUT (plus_current (F (\\<epsilon>, h)) k) a\n    < weight \\<Gamma> a \\<Longrightarrow>\n    \\<epsilon>h \\<le> sat \\<epsilon>h \\<and> sat \\<epsilon>h \\<in> Field leq\n 2. \\<not> d_OUT (plus_current (F (\\<epsilon>, h)) k) a\n           < weight \\<Gamma> a \\<Longrightarrow>\n    \\<epsilon>h \\<le> sat \\<epsilon>h \\<and> sat \\<epsilon>h \\<in> Field leq", "let ?g = \"zero_current((a, y) := \\<delta>)\""], ["proof (state)\ngoal (2 subgoals):\n 1. d_OUT (plus_current (F (\\<epsilon>, h)) k) a\n    < weight \\<Gamma> a \\<Longrightarrow>\n    \\<epsilon>h \\<le> sat \\<epsilon>h \\<and> sat \\<epsilon>h \\<in> Field leq\n 2. \\<not> d_OUT (plus_current (F (\\<epsilon>, h)) k) a\n           < weight \\<Gamma> a \\<Longrightarrow>\n    \\<epsilon>h \\<le> sat \\<epsilon>h \\<and> sat \\<epsilon>h \\<in> Field leq", "have OUT_g: \"d_OUT ?g x = (if x = a then \\<delta> else 0)\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>)) x =\n    ennreal (if x = a then \\<delta> else 0)", "proof(rule trans)"], ["proof (state)\ngoal (2 subgoals):\n 1. d_OUT ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>)) x = ?s\n 2. ?s = ennreal (if x = a then \\<delta> else 0)", "show \"d_OUT ?g x = (\\<Sum>\\<^sup>+ z. (if x = a then \\<delta> else 0) * indicator {y} z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>)) x =\n    (\\<Sum>\\<^sup>+ xa.\n       ennreal ((if x = a then \\<delta> else 0) * indicat_real {y} xa))", "unfolding d_OUT_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ ya.\n       ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>)) (x, ya)) =\n    (\\<Sum>\\<^sup>+ xa.\n       ennreal ((if x = a then \\<delta> else 0) * indicat_real {y} xa))", "by(rule nn_integral_cong) simp"], ["proof (state)\nthis:\n  d_OUT ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>)) x =\n  (\\<Sum>\\<^sup>+ xa.\n     ennreal ((if x = a then \\<delta> else 0) * indicat_real {y} xa))\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ xa.\n       ennreal ((if x = a then \\<delta> else 0) * indicat_real {y} xa)) =\n    ennreal (if x = a then \\<delta> else 0)", "show \"\\<dots> = (if x = a then \\<delta> else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ xa.\n       ennreal ((if x = a then \\<delta> else 0) * indicat_real {y} xa)) =\n    ennreal (if x = a then \\<delta> else 0)", "using \\<delta>_pos"], ["proof (prove)\nusing this:\n  0 < \\<delta>\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ xa.\n       ennreal ((if x = a then \\<delta> else 0) * indicat_real {y} xa)) =\n    ennreal (if x = a then \\<delta> else 0)", "by(simp add: max_def)"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ xa.\n     ennreal ((if x = a then \\<delta> else 0) * indicat_real {y} xa)) =\n  ennreal (if x = a then \\<delta> else 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  d_OUT ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>)) ?x =\n  ennreal (if ?x = a then \\<delta> else 0)\n\ngoal (2 subgoals):\n 1. d_OUT (plus_current (F (\\<epsilon>, h)) k) a\n    < weight \\<Gamma> a \\<Longrightarrow>\n    \\<epsilon>h \\<le> sat \\<epsilon>h \\<and> sat \\<epsilon>h \\<in> Field leq\n 2. \\<not> d_OUT (plus_current (F (\\<epsilon>, h)) k) a\n           < weight \\<Gamma> a \\<Longrightarrow>\n    \\<epsilon>h \\<le> sat \\<epsilon>h \\<and> sat \\<epsilon>h \\<in> Field leq", "have IN_g: \"d_IN ?g x = (if x = y then \\<delta> else 0)\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>)) x =\n    ennreal (if x = y then \\<delta> else 0)", "proof(rule trans)"], ["proof (state)\ngoal (2 subgoals):\n 1. d_IN ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>)) x = ?s\n 2. ?s = ennreal (if x = y then \\<delta> else 0)", "show \"d_IN ?g x = (\\<Sum>\\<^sup>+ z. (if x = y then \\<delta> else 0) * indicator {a} z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>)) x =\n    (\\<Sum>\\<^sup>+ xa.\n       ennreal ((if x = y then \\<delta> else 0) * indicat_real {a} xa))", "unfolding d_IN_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ xa.\n       ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>)) (xa, x)) =\n    (\\<Sum>\\<^sup>+ xa.\n       ennreal ((if x = y then \\<delta> else 0) * indicat_real {a} xa))", "by(rule nn_integral_cong) simp"], ["proof (state)\nthis:\n  d_IN ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>)) x =\n  (\\<Sum>\\<^sup>+ xa.\n     ennreal ((if x = y then \\<delta> else 0) * indicat_real {a} xa))\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ xa.\n       ennreal ((if x = y then \\<delta> else 0) * indicat_real {a} xa)) =\n    ennreal (if x = y then \\<delta> else 0)", "show \"\\<dots> = (if x = y then \\<delta> else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ xa.\n       ennreal ((if x = y then \\<delta> else 0) * indicat_real {a} xa)) =\n    ennreal (if x = y then \\<delta> else 0)", "using \\<delta>_pos"], ["proof (prove)\nusing this:\n  0 < \\<delta>\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ xa.\n       ennreal ((if x = y then \\<delta> else 0) * indicat_real {a} xa)) =\n    ennreal (if x = y then \\<delta> else 0)", "by(simp add: max_def)"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ xa.\n     ennreal ((if x = y then \\<delta> else 0) * indicat_real {a} xa)) =\n  ennreal (if x = y then \\<delta> else 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  d_IN ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>)) ?x =\n  ennreal (if ?x = y then \\<delta> else 0)\n\ngoal (2 subgoals):\n 1. d_OUT (plus_current (F (\\<epsilon>, h)) k) a\n    < weight \\<Gamma> a \\<Longrightarrow>\n    \\<epsilon>h \\<le> sat \\<epsilon>h \\<and> sat \\<epsilon>h \\<in> Field leq\n 2. \\<not> d_OUT (plus_current (F (\\<epsilon>, h)) k) a\n           < weight \\<Gamma> a \\<Longrightarrow>\n    \\<epsilon>h \\<le> sat \\<epsilon>h \\<and> sat \\<epsilon>h \\<in> Field leq", "have g: \"current ?\\<Gamma> ?g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. current (\\<Gamma> \\<ominus> plus_current (F (\\<epsilon>, h)) k)\n     ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>))", "proof"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x.\n       d_OUT ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>)) x\n       \\<le> weight (\\<Gamma> \\<ominus> plus_current (F (\\<epsilon>, h)) k)\n              x\n 2. \\<And>x.\n       d_IN ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>)) x\n       \\<le> weight (\\<Gamma> \\<ominus> plus_current (F (\\<epsilon>, h)) k)\n              x\n 3. \\<And>e.\n       e \\<notin> \\<^bold>E\\<^bsub>\\<Gamma> \\<ominus> plus_current (F (\\<epsilon>, h)) k\\<^esub> \\<Longrightarrow>\n       ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>)) e = 0", "show \"d_OUT ?g x \\<le> weight ?\\<Gamma> x\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>)) x\n    \\<le> weight (\\<Gamma> \\<ominus> plus_current (F (\\<epsilon>, h)) k) x", "proof(cases \"x = a\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x = a \\<Longrightarrow>\n    d_OUT ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>)) x\n    \\<le> weight (\\<Gamma> \\<ominus> plus_current (F (\\<epsilon>, h)) k) x\n 2. x \\<noteq> a \\<Longrightarrow>\n    d_OUT ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>)) x\n    \\<le> weight (\\<Gamma> \\<ominus> plus_current (F (\\<epsilon>, h)) k) x", "case False"], ["proof (state)\nthis:\n  x \\<noteq> a\n\ngoal (2 subgoals):\n 1. x = a \\<Longrightarrow>\n    d_OUT ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>)) x\n    \\<le> weight (\\<Gamma> \\<ominus> plus_current (F (\\<epsilon>, h)) k) x\n 2. x \\<noteq> a \\<Longrightarrow>\n    d_OUT ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>)) x\n    \\<le> weight (\\<Gamma> \\<ominus> plus_current (F (\\<epsilon>, h)) k) x", "then"], ["proof (chain)\npicking this:\n  x \\<noteq> a", "show ?thesis"], ["proof (prove)\nusing this:\n  x \\<noteq> a\n\ngoal (1 subgoal):\n 1. d_OUT ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>)) x\n    \\<le> weight (\\<Gamma> \\<ominus> plus_current (F (\\<epsilon>, h)) k) x", "using currentD_weight_OUT[OF fk, of x] currentD_weight_IN[OF fk, of x]"], ["proof (prove)\nusing this:\n  x \\<noteq> a\n  d_OUT (plus_current (F (\\<epsilon>, h)) k) x \\<le> weight \\<Gamma> x\n  d_IN (plus_current (F (\\<epsilon>, h)) k) x \\<le> weight \\<Gamma> x\n\ngoal (1 subgoal):\n 1. d_OUT ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>)) x\n    \\<le> weight (\\<Gamma> \\<ominus> plus_current (F (\\<epsilon>, h)) k) x", "by(auto simp add: OUT_g zero_ennreal_def[symmetric])"], ["proof (state)\nthis:\n  d_OUT ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>)) x\n  \\<le> weight (\\<Gamma> \\<ominus> plus_current (F (\\<epsilon>, h)) k) x\n\ngoal (1 subgoal):\n 1. x = a \\<Longrightarrow>\n    d_OUT ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>)) x\n    \\<le> weight (\\<Gamma> \\<ominus> plus_current (F (\\<epsilon>, h)) k) x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x = a \\<Longrightarrow>\n    d_OUT ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>)) x\n    \\<le> weight (\\<Gamma> \\<ominus> plus_current (F (\\<epsilon>, h)) k) x", "case True"], ["proof (state)\nthis:\n  x = a\n\ngoal (1 subgoal):\n 1. x = a \\<Longrightarrow>\n    d_OUT ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>)) x\n    \\<le> weight (\\<Gamma> \\<ominus> plus_current (F (\\<epsilon>, h)) k) x", "then"], ["proof (chain)\npicking this:\n  x = a", "show ?thesis"], ["proof (prove)\nusing this:\n  x = a\n\ngoal (1 subgoal):\n 1. d_OUT ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>)) x\n    \\<le> weight (\\<Gamma> \\<ominus> plus_current (F (\\<epsilon>, h)) k) x", "using \\<delta>_le_a a a_\\<E> \\<delta>_pos"], ["proof (prove)\nusing this:\n  x = a\n  ennreal \\<delta> < weight \\<Omega> a\n  a \\<in> A \\<Gamma>\n  a \\<in> TER\\<^bsub>\\<Gamma> \\<ominus> F (\\<epsilon>, h)\\<^esub> k\n  0 < \\<delta>\n\ngoal (1 subgoal):\n 1. d_OUT ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>)) x\n    \\<le> weight (\\<Gamma> \\<ominus> plus_current (F (\\<epsilon>, h)) k) x", "unfolding OUT_g"], ["proof (prove)\nusing this:\n  x = a\n  ennreal \\<delta> < weight \\<Omega> a\n  a \\<in> A \\<Gamma>\n  a \\<in> TER\\<^bsub>\\<Gamma> \\<ominus> F (\\<epsilon>, h)\\<^esub> k\n  0 < \\<delta>\n\ngoal (1 subgoal):\n 1. ennreal (if x = a then \\<delta> else 0)\n    \\<le> weight (\\<Gamma> \\<ominus> plus_current (F (\\<epsilon>, h)) k) x", "by(simp add: OUT_g \\<Omega>_def SINK.simps OUT_fk split: if_split_asm)"], ["proof (state)\nthis:\n  d_OUT ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>)) x\n  \\<le> weight (\\<Gamma> \\<ominus> plus_current (F (\\<epsilon>, h)) k) x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  d_OUT ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>)) ?x\n  \\<le> weight (\\<Gamma> \\<ominus> plus_current (F (\\<epsilon>, h)) k) ?x\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       d_IN ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>)) x\n       \\<le> weight (\\<Gamma> \\<ominus> plus_current (F (\\<epsilon>, h)) k)\n              x\n 2. \\<And>e.\n       e \\<notin> \\<^bold>E\\<^bsub>\\<Gamma> \\<ominus> plus_current (F (\\<epsilon>, h)) k\\<^esub> \\<Longrightarrow>\n       ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>)) e = 0", "show \"d_IN ?g x \\<le> weight ?\\<Gamma> x\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>)) x\n    \\<le> weight (\\<Gamma> \\<ominus> plus_current (F (\\<epsilon>, h)) k) x", "proof(cases \"x = y\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x = y \\<Longrightarrow>\n    d_IN ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>)) x\n    \\<le> weight (\\<Gamma> \\<ominus> plus_current (F (\\<epsilon>, h)) k) x\n 2. x \\<noteq> y \\<Longrightarrow>\n    d_IN ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>)) x\n    \\<le> weight (\\<Gamma> \\<ominus> plus_current (F (\\<epsilon>, h)) k) x", "case False"], ["proof (state)\nthis:\n  x \\<noteq> y\n\ngoal (2 subgoals):\n 1. x = y \\<Longrightarrow>\n    d_IN ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>)) x\n    \\<le> weight (\\<Gamma> \\<ominus> plus_current (F (\\<epsilon>, h)) k) x\n 2. x \\<noteq> y \\<Longrightarrow>\n    d_IN ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>)) x\n    \\<le> weight (\\<Gamma> \\<ominus> plus_current (F (\\<epsilon>, h)) k) x", "then"], ["proof (chain)\npicking this:\n  x \\<noteq> y", "show ?thesis"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. d_IN ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>)) x\n    \\<le> weight (\\<Gamma> \\<ominus> plus_current (F (\\<epsilon>, h)) k) x", "using currentD_weight_OUT[OF fk, of x] currentD_weight_IN[OF fk, of x]"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  d_OUT (plus_current (F (\\<epsilon>, h)) k) x \\<le> weight \\<Gamma> x\n  d_IN (plus_current (F (\\<epsilon>, h)) k) x \\<le> weight \\<Gamma> x\n\ngoal (1 subgoal):\n 1. d_IN ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>)) x\n    \\<le> weight (\\<Gamma> \\<ominus> plus_current (F (\\<epsilon>, h)) k) x", "by(auto simp add: IN_g zero_ennreal_def[symmetric])"], ["proof (state)\nthis:\n  d_IN ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>)) x\n  \\<le> weight (\\<Gamma> \\<ominus> plus_current (F (\\<epsilon>, h)) k) x\n\ngoal (1 subgoal):\n 1. x = y \\<Longrightarrow>\n    d_IN ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>)) x\n    \\<le> weight (\\<Gamma> \\<ominus> plus_current (F (\\<epsilon>, h)) k) x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x = y \\<Longrightarrow>\n    d_IN ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>)) x\n    \\<le> weight (\\<Gamma> \\<ominus> plus_current (F (\\<epsilon>, h)) k) x", "case True"], ["proof (state)\nthis:\n  x = y\n\ngoal (1 subgoal):\n 1. x = y \\<Longrightarrow>\n    d_IN ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>)) x\n    \\<le> weight (\\<Gamma> \\<ominus> plus_current (F (\\<epsilon>, h)) k) x", "then"], ["proof (chain)\npicking this:\n  x = y", "show ?thesis"], ["proof (prove)\nusing this:\n  x = y\n\ngoal (1 subgoal):\n 1. d_IN ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>)) x\n    \\<le> weight (\\<Gamma> \\<ominus> plus_current (F (\\<epsilon>, h)) k) x", "using \\<delta>_le_y y_B a_\\<E> \\<delta>_pos currentD_OUT[OF k, of y] IN_k_y"], ["proof (prove)\nusing this:\n  x = y\n  ennreal \\<delta> < weight \\<Omega> y\n  y \\<in> B \\<Omega>\n  a \\<in> TER\\<^bsub>\\<Gamma> \\<ominus> F (\\<epsilon>, h)\\<^esub> k\n  0 < \\<delta>\n  y \\<in> B (\\<Gamma> \\<ominus> F (\\<epsilon>, h)) \\<Longrightarrow>\n  d_OUT k y = 0\n  d_IN k y = 0\n\ngoal (1 subgoal):\n 1. d_IN ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>)) x\n    \\<le> weight (\\<Gamma> \\<ominus> plus_current (F (\\<epsilon>, h)) k) x", "by(simp add: OUT_g \\<Omega>_def SINK.simps OUT_fk IN_fk IN_g split: if_split_asm)"], ["proof (state)\nthis:\n  d_IN ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>)) x\n  \\<le> weight (\\<Gamma> \\<ominus> plus_current (F (\\<epsilon>, h)) k) x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  d_IN ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>)) ?x\n  \\<le> weight (\\<Gamma> \\<ominus> plus_current (F (\\<epsilon>, h)) k) ?x\n\ngoal (1 subgoal):\n 1. \\<And>e.\n       e \\<notin> \\<^bold>E\\<^bsub>\\<Gamma> \\<ominus> plus_current (F (\\<epsilon>, h)) k\\<^esub> \\<Longrightarrow>\n       ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>)) e = 0", "show \"?g e = 0\" if \"e \\<notin> \\<^bold>E\\<^bsub>?\\<Gamma>\\<^esub>\" for e"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>)) e = 0", "using y_OUT that"], ["proof (prove)\nusing this:\n  y \\<in> \\<^bold>O\\<^bold>U\\<^bold>T\\<^bsub>\\<Omega>\\<^esub> a\n  e \\<notin> \\<^bold>E\\<^bsub>\\<Gamma> \\<ominus> plus_current (F (\\<epsilon>, h)) k\\<^esub>\n\ngoal (1 subgoal):\n 1. ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>)) e = 0", "by(auto simp add: \\<Omega>_def outgoing_def)"], ["proof (state)\nthis:\n  ?e \\<notin> \\<^bold>E\\<^bsub>\\<Gamma> \\<ominus> plus_current (F (\\<epsilon>, h)) k\\<^esub> \\<Longrightarrow>\n  ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>)) ?e = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  current (\\<Gamma> \\<ominus> plus_current (F (\\<epsilon>, h)) k)\n   ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>))\n\ngoal (2 subgoals):\n 1. d_OUT (plus_current (F (\\<epsilon>, h)) k) a\n    < weight \\<Gamma> a \\<Longrightarrow>\n    \\<epsilon>h \\<le> sat \\<epsilon>h \\<and> sat \\<epsilon>h \\<in> Field leq\n 2. \\<not> d_OUT (plus_current (F (\\<epsilon>, h)) k) a\n           < weight \\<Gamma> a \\<Longrightarrow>\n    \\<epsilon>h \\<le> sat \\<epsilon>h \\<and> sat \\<epsilon>h \\<in> Field leq", "interpret \\<Gamma>'': web \"\\<Gamma> \\<ominus> ?fk \\<ominus> ?g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. web (\\<Gamma> \\<ominus> plus_current (F (\\<epsilon>, h)) k \\<ominus>\n         (\\<lambda>_. 0)((a, y) := ennreal \\<delta>))", "using g"], ["proof (prove)\nusing this:\n  current (\\<Gamma> \\<ominus> plus_current (F (\\<epsilon>, h)) k)\n   ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>))\n\ngoal (1 subgoal):\n 1. web (\\<Gamma> \\<ominus> plus_current (F (\\<epsilon>, h)) k \\<ominus>\n         (\\<lambda>_. 0)((a, y) := ennreal \\<delta>))", "by(rule \\<Gamma>'.web_minus_web)"], ["proof (state)\ngoal (2 subgoals):\n 1. d_OUT (plus_current (F (\\<epsilon>, h)) k) a\n    < weight \\<Gamma> a \\<Longrightarrow>\n    \\<epsilon>h \\<le> sat \\<epsilon>h \\<and> sat \\<epsilon>h \\<in> Field leq\n 2. \\<not> d_OUT (plus_current (F (\\<epsilon>, h)) k) a\n           < weight \\<Gamma> a \\<Longrightarrow>\n    \\<epsilon>h \\<le> sat \\<epsilon>h \\<and> sat \\<epsilon>h \\<in> Field leq", "let ?\\<epsilon>' = \"plus_current \\<epsilon> (zero_current((a, y) := \\<delta>))\""], ["proof (state)\ngoal (2 subgoals):\n 1. d_OUT (plus_current (F (\\<epsilon>, h)) k) a\n    < weight \\<Gamma> a \\<Longrightarrow>\n    \\<epsilon>h \\<le> sat \\<epsilon>h \\<and> sat \\<epsilon>h \\<in> Field leq\n 2. \\<not> d_OUT (plus_current (F (\\<epsilon>, h)) k) a\n           < weight \\<Gamma> a \\<Longrightarrow>\n    \\<epsilon>h \\<le> sat \\<epsilon>h \\<and> sat \\<epsilon>h \\<in> Field leq", "let ?h' = \"plus_current h k\""], ["proof (state)\ngoal (2 subgoals):\n 1. d_OUT (plus_current (F (\\<epsilon>, h)) k) a\n    < weight \\<Gamma> a \\<Longrightarrow>\n    \\<epsilon>h \\<le> sat \\<epsilon>h \\<and> sat \\<epsilon>h \\<in> Field leq\n 2. \\<not> d_OUT (plus_current (F (\\<epsilon>, h)) k) a\n           < weight \\<Gamma> a \\<Longrightarrow>\n    \\<epsilon>h \\<le> sat \\<epsilon>h \\<and> sat \\<epsilon>h \\<in> Field leq", "have F': \"F (?\\<epsilon>', ?h') = plus_current (plus_current (F (\\<epsilon>, h)) k) (zero_current((a, y) := \\<delta>))\" (is \"_ = ?f'\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. F (plus_current \\<epsilon>\n        ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>)),\n       plus_current h k) =\n    plus_current (plus_current (F (\\<epsilon>, h)) k)\n     ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>))", "by(auto simp add: F_simps fun_eq_iff add_ac)"], ["proof (state)\nthis:\n  F (plus_current \\<epsilon> ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>)),\n     plus_current h k) =\n  plus_current (plus_current (F (\\<epsilon>, h)) k)\n   ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>))\n\ngoal (2 subgoals):\n 1. d_OUT (plus_current (F (\\<epsilon>, h)) k) a\n    < weight \\<Gamma> a \\<Longrightarrow>\n    \\<epsilon>h \\<le> sat \\<epsilon>h \\<and> sat \\<epsilon>h \\<in> Field leq\n 2. \\<not> d_OUT (plus_current (F (\\<epsilon>, h)) k) a\n           < weight \\<Gamma> a \\<Longrightarrow>\n    \\<epsilon>h \\<le> sat \\<epsilon>h \\<and> sat \\<epsilon>h \\<in> Field leq", "have sat: \"sat (\\<epsilon>, h) = (?\\<epsilon>', ?h')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sat (\\<epsilon>, h) =\n    (plus_current \\<epsilon> ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>)),\n     plus_current h k)", "using less"], ["proof (prove)\nusing this:\n  d_OUT (plus_current (F (\\<epsilon>, h)) k) a < weight \\<Gamma> a\n\ngoal (1 subgoal):\n 1. sat (\\<epsilon>, h) =\n    (plus_current \\<epsilon> ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>)),\n     plus_current h k)", "by(simp add: sat_def k_def \\<Omega>_def Let_def y_def bound_def \\<delta>_def)"], ["proof (state)\nthis:\n  sat (\\<epsilon>, h) =\n  (plus_current \\<epsilon> ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>)),\n   plus_current h k)\n\ngoal (2 subgoals):\n 1. d_OUT (plus_current (F (\\<epsilon>, h)) k) a\n    < weight \\<Gamma> a \\<Longrightarrow>\n    \\<epsilon>h \\<le> sat \\<epsilon>h \\<and> sat \\<epsilon>h \\<in> Field leq\n 2. \\<not> d_OUT (plus_current (F (\\<epsilon>, h)) k) a\n           < weight \\<Gamma> a \\<Longrightarrow>\n    \\<epsilon>h \\<le> sat \\<epsilon>h \\<and> sat \\<epsilon>h \\<in> Field leq", "have le: \"(\\<epsilon>, h) \\<le> (?\\<epsilon>', ?h')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<epsilon>, h)\n    \\<le> (plus_current \\<epsilon>\n            ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>)),\n           plus_current h k)", "using \\<delta>_pos"], ["proof (prove)\nusing this:\n  0 < \\<delta>\n\ngoal (1 subgoal):\n 1. (\\<epsilon>, h)\n    \\<le> (plus_current \\<epsilon>\n            ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>)),\n           plus_current h k)", "by(auto simp add: le_fun_def add_increasing2 add_increasing)"], ["proof (state)\nthis:\n  (\\<epsilon>, h)\n  \\<le> (plus_current \\<epsilon>\n          ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>)),\n         plus_current h k)\n\ngoal (2 subgoals):\n 1. d_OUT (plus_current (F (\\<epsilon>, h)) k) a\n    < weight \\<Gamma> a \\<Longrightarrow>\n    \\<epsilon>h \\<le> sat \\<epsilon>h \\<and> sat \\<epsilon>h \\<in> Field leq\n 2. \\<not> d_OUT (plus_current (F (\\<epsilon>, h)) k) a\n           < weight \\<Gamma> a \\<Longrightarrow>\n    \\<epsilon>h \\<le> sat \\<epsilon>h \\<and> sat \\<epsilon>h \\<in> Field leq", "have \"current (\\<Gamma> \\<ominus> \\<epsilon>) ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. current (\\<Gamma> \\<ominus> \\<epsilon>)\n     ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>))", "using g"], ["proof (prove)\nusing this:\n  current (\\<Gamma> \\<ominus> plus_current (F (\\<epsilon>, h)) k)\n   ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>))\n\ngoal (1 subgoal):\n 1. current (\\<Gamma> \\<ominus> \\<epsilon>)\n     ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>))", "by(rule current_weight_mono)(auto simp add: weight_minus_web[OF \\<epsilon>] intro!: ennreal_minus_mono d_OUT_mono d_IN_mono, simp_all add: F_def add_increasing2)"], ["proof (state)\nthis:\n  current (\\<Gamma> \\<ominus> \\<epsilon>)\n   ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>))\n\ngoal (2 subgoals):\n 1. d_OUT (plus_current (F (\\<epsilon>, h)) k) a\n    < weight \\<Gamma> a \\<Longrightarrow>\n    \\<epsilon>h \\<le> sat \\<epsilon>h \\<and> sat \\<epsilon>h \\<in> Field leq\n 2. \\<not> d_OUT (plus_current (F (\\<epsilon>, h)) k) a\n           < weight \\<Gamma> a \\<Longrightarrow>\n    \\<epsilon>h \\<le> sat \\<epsilon>h \\<and> sat \\<epsilon>h \\<in> Field leq", "with \\<epsilon>"], ["proof (chain)\npicking this:\n  current \\<Gamma> \\<epsilon>\n  current (\\<Gamma> \\<ominus> \\<epsilon>)\n   ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>))", "have \\<epsilon>': \"current \\<Gamma> ?\\<epsilon>'\""], ["proof (prove)\nusing this:\n  current \\<Gamma> \\<epsilon>\n  current (\\<Gamma> \\<ominus> \\<epsilon>)\n   ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>))\n\ngoal (1 subgoal):\n 1. current \\<Gamma>\n     (plus_current \\<epsilon> ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>)))", "by(rule current_plus_current_minus)"], ["proof (state)\nthis:\n  current \\<Gamma>\n   (plus_current \\<epsilon> ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>)))\n\ngoal (2 subgoals):\n 1. d_OUT (plus_current (F (\\<epsilon>, h)) k) a\n    < weight \\<Gamma> a \\<Longrightarrow>\n    \\<epsilon>h \\<le> sat \\<epsilon>h \\<and> sat \\<epsilon>h \\<in> Field leq\n 2. \\<not> d_OUT (plus_current (F (\\<epsilon>, h)) k) a\n           < weight \\<Gamma> a \\<Longrightarrow>\n    \\<epsilon>h \\<le> sat \\<epsilon>h \\<and> sat \\<epsilon>h \\<in> Field leq", "moreover"], ["proof (state)\nthis:\n  current \\<Gamma>\n   (plus_current \\<epsilon> ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>)))\n\ngoal (2 subgoals):\n 1. d_OUT (plus_current (F (\\<epsilon>, h)) k) a\n    < weight \\<Gamma> a \\<Longrightarrow>\n    \\<epsilon>h \\<le> sat \\<epsilon>h \\<and> sat \\<epsilon>h \\<in> Field leq\n 2. \\<not> d_OUT (plus_current (F (\\<epsilon>, h)) k) a\n           < weight \\<Gamma> a \\<Longrightarrow>\n    \\<epsilon>h \\<le> sat \\<epsilon>h \\<and> sat \\<epsilon>h \\<in> Field leq", "have eq_0: \"d_OUT ?\\<epsilon>' x = 0\" if \"x \\<noteq> a\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT\n     (plus_current \\<epsilon> ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>)))\n     x =\n    0", "unfolding plus_current_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT\n     (\\<lambda>e.\n         \\<epsilon> e + ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>)) e)\n     x =\n    0", "using that"], ["proof (prove)\nusing this:\n  x \\<noteq> a\n\ngoal (1 subgoal):\n 1. d_OUT\n     (\\<lambda>e.\n         \\<epsilon> e + ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>)) e)\n     x =\n    0", "by(subst d_OUT_add)(simp_all add: \\<delta>_nonneg d_OUT_fun_upd OUT_\\<epsilon>)"], ["proof (state)\nthis:\n  ?x \\<noteq> a \\<Longrightarrow>\n  d_OUT\n   (plus_current \\<epsilon> ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>)))\n   ?x =\n  0\n\ngoal (2 subgoals):\n 1. d_OUT (plus_current (F (\\<epsilon>, h)) k) a\n    < weight \\<Gamma> a \\<Longrightarrow>\n    \\<epsilon>h \\<le> sat \\<epsilon>h \\<and> sat \\<epsilon>h \\<in> Field leq\n 2. \\<not> d_OUT (plus_current (F (\\<epsilon>, h)) k) a\n           < weight \\<Gamma> a \\<Longrightarrow>\n    \\<epsilon>h \\<le> sat \\<epsilon>h \\<and> sat \\<epsilon>h \\<in> Field leq", "moreover"], ["proof (state)\nthis:\n  ?x \\<noteq> a \\<Longrightarrow>\n  d_OUT\n   (plus_current \\<epsilon> ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>)))\n   ?x =\n  0\n\ngoal (2 subgoals):\n 1. d_OUT (plus_current (F (\\<epsilon>, h)) k) a\n    < weight \\<Gamma> a \\<Longrightarrow>\n    \\<epsilon>h \\<le> sat \\<epsilon>h \\<and> sat \\<epsilon>h \\<in> Field leq\n 2. \\<not> d_OUT (plus_current (F (\\<epsilon>, h)) k) a\n           < weight \\<Gamma> a \\<Longrightarrow>\n    \\<epsilon>h \\<le> sat \\<epsilon>h \\<and> sat \\<epsilon>h \\<in> Field leq", "from \\<epsilon>'"], ["proof (chain)\npicking this:\n  current \\<Gamma>\n   (plus_current \\<epsilon> ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>)))", "interpret \\<epsilon>': countable_bipartite_web \"\\<Gamma> \\<ominus> ?\\<epsilon>'\""], ["proof (prove)\nusing this:\n  current \\<Gamma>\n   (plus_current \\<epsilon> ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>)))\n\ngoal (1 subgoal):\n 1. countable_bipartite_web\n     (\\<Gamma> \\<ominus>\n      plus_current \\<epsilon> ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>)))", "by(rule countable_bipartite_web_minus_web)"], ["proof (state)\ngoal (2 subgoals):\n 1. d_OUT (plus_current (F (\\<epsilon>, h)) k) a\n    < weight \\<Gamma> a \\<Longrightarrow>\n    \\<epsilon>h \\<le> sat \\<epsilon>h \\<and> sat \\<epsilon>h \\<in> Field leq\n 2. \\<not> d_OUT (plus_current (F (\\<epsilon>, h)) k) a\n           < weight \\<Gamma> a \\<Longrightarrow>\n    \\<epsilon>h \\<le> sat \\<epsilon>h \\<and> sat \\<epsilon>h \\<in> Field leq", "from \\<epsilon>"], ["proof (chain)\npicking this:\n  current \\<Gamma> \\<epsilon>", "interpret \\<epsilon>: countable_bipartite_web \"\\<Gamma> \\<ominus> \\<epsilon>\""], ["proof (prove)\nusing this:\n  current \\<Gamma> \\<epsilon>\n\ngoal (1 subgoal):\n 1. countable_bipartite_web (\\<Gamma> \\<ominus> \\<epsilon>)", "by(rule countable_bipartite_web_minus_web)"], ["proof (state)\ngoal (2 subgoals):\n 1. d_OUT (plus_current (F (\\<epsilon>, h)) k) a\n    < weight \\<Gamma> a \\<Longrightarrow>\n    \\<epsilon>h \\<le> sat \\<epsilon>h \\<and> sat \\<epsilon>h \\<in> Field leq\n 2. \\<not> d_OUT (plus_current (F (\\<epsilon>, h)) k) a\n           < weight \\<Gamma> a \\<Longrightarrow>\n    \\<epsilon>h \\<le> sat \\<epsilon>h \\<and> sat \\<epsilon>h \\<in> Field leq", "have g': \"current (\\<Gamma> \\<ominus> \\<epsilon>) ?g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. current (\\<Gamma> \\<ominus> \\<epsilon>)\n     ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>))", "using g"], ["proof (prove)\nusing this:\n  current (\\<Gamma> \\<ominus> plus_current (F (\\<epsilon>, h)) k)\n   ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>))\n\ngoal (1 subgoal):\n 1. current (\\<Gamma> \\<ominus> \\<epsilon>)\n     ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>))", "apply(rule current_weight_mono)"], ["proof (prove)\ngoal (4 subgoals):\n 1. edge (\\<Gamma> \\<ominus> plus_current (F (\\<epsilon>, h)) k) =\n    edge (\\<Gamma> \\<ominus> \\<epsilon>)\n 2. A (\\<Gamma> \\<ominus> plus_current (F (\\<epsilon>, h)) k) =\n    A (\\<Gamma> \\<ominus> \\<epsilon>)\n 3. B (\\<Gamma> \\<ominus> plus_current (F (\\<epsilon>, h)) k) =\n    B (\\<Gamma> \\<ominus> \\<epsilon>)\n 4. \\<And>x.\n       weight (\\<Gamma> \\<ominus> plus_current (F (\\<epsilon>, h)) k) x\n       \\<le> weight (\\<Gamma> \\<ominus> \\<epsilon>) x", "apply(auto simp add: weight_minus_web[OF \\<epsilon>] intro!: ennreal_minus_mono d_OUT_mono d_IN_mono)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       x \\<in> A \\<Gamma> \\<Longrightarrow>\n       \\<epsilon> (x, y) \\<le> F (\\<epsilon>, h) (x, y) + k (x, y)\n 2. \\<And>x xa.\n       x \\<notin> A \\<Gamma> \\<Longrightarrow>\n       \\<epsilon> (xa, x) \\<le> F (\\<epsilon>, h) (xa, x) + k (xa, x)", "apply(simp_all add: F_def add_increasing2)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  current (\\<Gamma> \\<ominus> \\<epsilon>)\n   ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>))\n\ngoal (2 subgoals):\n 1. d_OUT (plus_current (F (\\<epsilon>, h)) k) a\n    < weight \\<Gamma> a \\<Longrightarrow>\n    \\<epsilon>h \\<le> sat \\<epsilon>h \\<and> sat \\<epsilon>h \\<in> Field leq\n 2. \\<not> d_OUT (plus_current (F (\\<epsilon>, h)) k) a\n           < weight \\<Gamma> a \\<Longrightarrow>\n    \\<epsilon>h \\<le> sat \\<epsilon>h \\<and> sat \\<epsilon>h \\<in> Field leq", "have k': \"current (\\<Gamma> \\<ominus> \\<epsilon> \\<ominus> h) k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. current (\\<Gamma> \\<ominus> \\<epsilon> \\<ominus> h) k", "using k"], ["proof (prove)\nusing this:\n  current (\\<Gamma> \\<ominus> F (\\<epsilon>, h)) k\n\ngoal (1 subgoal):\n 1. current (\\<Gamma> \\<ominus> \\<epsilon> \\<ominus> h) k", "unfolding F_simps minus_plus_current[OF \\<epsilon> h]"], ["proof (prove)\nusing this:\n  current (\\<Gamma> \\<ominus> \\<epsilon> \\<ominus> h) k\n\ngoal (1 subgoal):\n 1. current (\\<Gamma> \\<ominus> \\<epsilon> \\<ominus> h) k", "."], ["proof (state)\nthis:\n  current (\\<Gamma> \\<ominus> \\<epsilon> \\<ominus> h) k\n\ngoal (2 subgoals):\n 1. d_OUT (plus_current (F (\\<epsilon>, h)) k) a\n    < weight \\<Gamma> a \\<Longrightarrow>\n    \\<epsilon>h \\<le> sat \\<epsilon>h \\<and> sat \\<epsilon>h \\<in> Field leq\n 2. \\<not> d_OUT (plus_current (F (\\<epsilon>, h)) k) a\n           < weight \\<Gamma> a \\<Longrightarrow>\n    \\<epsilon>h \\<le> sat \\<epsilon>h \\<and> sat \\<epsilon>h \\<in> Field leq", "with h"], ["proof (chain)\npicking this:\n  current (\\<Gamma> \\<ominus> \\<epsilon>) h\n  current (\\<Gamma> \\<ominus> \\<epsilon> \\<ominus> h) k", "have \"current (\\<Gamma> \\<ominus> \\<epsilon>) (plus_current h k)\""], ["proof (prove)\nusing this:\n  current (\\<Gamma> \\<ominus> \\<epsilon>) h\n  current (\\<Gamma> \\<ominus> \\<epsilon> \\<ominus> h) k\n\ngoal (1 subgoal):\n 1. current (\\<Gamma> \\<ominus> \\<epsilon>) (plus_current h k)", "by(rule \\<epsilon>.current_plus_current_minus)"], ["proof (state)\nthis:\n  current (\\<Gamma> \\<ominus> \\<epsilon>) (plus_current h k)\n\ngoal (2 subgoals):\n 1. d_OUT (plus_current (F (\\<epsilon>, h)) k) a\n    < weight \\<Gamma> a \\<Longrightarrow>\n    \\<epsilon>h \\<le> sat \\<epsilon>h \\<and> sat \\<epsilon>h \\<in> Field leq\n 2. \\<not> d_OUT (plus_current (F (\\<epsilon>, h)) k) a\n           < weight \\<Gamma> a \\<Longrightarrow>\n    \\<epsilon>h \\<le> sat \\<epsilon>h \\<and> sat \\<epsilon>h \\<in> Field leq", "hence \"current (\\<Gamma> \\<ominus> \\<epsilon>) (plus_current (plus_current h k) ?g)\""], ["proof (prove)\nusing this:\n  current (\\<Gamma> \\<ominus> \\<epsilon>) (plus_current h k)\n\ngoal (1 subgoal):\n 1. current (\\<Gamma> \\<ominus> \\<epsilon>)\n     (plus_current (plus_current h k)\n       ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>)))", "using g"], ["proof (prove)\nusing this:\n  current (\\<Gamma> \\<ominus> \\<epsilon>) (plus_current h k)\n  current (\\<Gamma> \\<ominus> plus_current (F (\\<epsilon>, h)) k)\n   ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>))\n\ngoal (1 subgoal):\n 1. current (\\<Gamma> \\<ominus> \\<epsilon>)\n     (plus_current (plus_current h k)\n       ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>)))", "unfolding minus_plus_current[OF f k]"], ["proof (prove)\nusing this:\n  current (\\<Gamma> \\<ominus> \\<epsilon>) (plus_current h k)\n  current (\\<Gamma> \\<ominus> F (\\<epsilon>, h) \\<ominus> k)\n   ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>))\n\ngoal (1 subgoal):\n 1. current (\\<Gamma> \\<ominus> \\<epsilon>)\n     (plus_current (plus_current h k)\n       ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>)))", "unfolding F_simps minus_plus_current[OF \\<epsilon> h] \\<epsilon>.minus_plus_current[OF h k', symmetric]"], ["proof (prove)\nusing this:\n  current (\\<Gamma> \\<ominus> \\<epsilon>) (plus_current h k)\n  current (\\<Gamma> \\<ominus> \\<epsilon> \\<ominus> plus_current h k)\n   ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>))\n\ngoal (1 subgoal):\n 1. current (\\<Gamma> \\<ominus> \\<epsilon>)\n     (plus_current (plus_current h k)\n       ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>)))", "by(rule \\<epsilon>.current_plus_current_minus)"], ["proof (state)\nthis:\n  current (\\<Gamma> \\<ominus> \\<epsilon>)\n   (plus_current (plus_current h k)\n     ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>)))\n\ngoal (2 subgoals):\n 1. d_OUT (plus_current (F (\\<epsilon>, h)) k) a\n    < weight \\<Gamma> a \\<Longrightarrow>\n    \\<epsilon>h \\<le> sat \\<epsilon>h \\<and> sat \\<epsilon>h \\<in> Field leq\n 2. \\<not> d_OUT (plus_current (F (\\<epsilon>, h)) k) a\n           < weight \\<Gamma> a \\<Longrightarrow>\n    \\<epsilon>h \\<le> sat \\<epsilon>h \\<and> sat \\<epsilon>h \\<in> Field leq", "then"], ["proof (chain)\npicking this:\n  current (\\<Gamma> \\<ominus> \\<epsilon>)\n   (plus_current (plus_current h k)\n     ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>)))", "have \"current (\\<Gamma> \\<ominus> \\<epsilon> \\<ominus> ?g) (plus_current (plus_current h k) ?g - ?g)\""], ["proof (prove)\nusing this:\n  current (\\<Gamma> \\<ominus> \\<epsilon>)\n   (plus_current (plus_current h k)\n     ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>)))\n\ngoal (1 subgoal):\n 1. current\n     (\\<Gamma> \\<ominus> \\<epsilon> \\<ominus> (\\<lambda>_. 0)\n      ((a, y) := ennreal \\<delta>))\n     (plus_current (plus_current h k)\n       ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>)) -\n      (\\<lambda>_. 0)((a, y) := ennreal \\<delta>))", "using g'"], ["proof (prove)\nusing this:\n  current (\\<Gamma> \\<ominus> \\<epsilon>)\n   (plus_current (plus_current h k)\n     ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>)))\n  current (\\<Gamma> \\<ominus> \\<epsilon>)\n   ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>))\n\ngoal (1 subgoal):\n 1. current\n     (\\<Gamma> \\<ominus> \\<epsilon> \\<ominus> (\\<lambda>_. 0)\n      ((a, y) := ennreal \\<delta>))\n     (plus_current (plus_current h k)\n       ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>)) -\n      (\\<lambda>_. 0)((a, y) := ennreal \\<delta>))", "by(rule \\<epsilon>.current_minus)(auto simp add: add_increasing)"], ["proof (state)\nthis:\n  current\n   (\\<Gamma> \\<ominus> \\<epsilon> \\<ominus> (\\<lambda>_. 0)\n    ((a, y) := ennreal \\<delta>))\n   (plus_current (plus_current h k)\n     ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>)) -\n    (\\<lambda>_. 0)((a, y) := ennreal \\<delta>))\n\ngoal (2 subgoals):\n 1. d_OUT (plus_current (F (\\<epsilon>, h)) k) a\n    < weight \\<Gamma> a \\<Longrightarrow>\n    \\<epsilon>h \\<le> sat \\<epsilon>h \\<and> sat \\<epsilon>h \\<in> Field leq\n 2. \\<not> d_OUT (plus_current (F (\\<epsilon>, h)) k) a\n           < weight \\<Gamma> a \\<Longrightarrow>\n    \\<epsilon>h \\<le> sat \\<epsilon>h \\<and> sat \\<epsilon>h \\<in> Field leq", "then"], ["proof (chain)\npicking this:\n  current\n   (\\<Gamma> \\<ominus> \\<epsilon> \\<ominus> (\\<lambda>_. 0)\n    ((a, y) := ennreal \\<delta>))\n   (plus_current (plus_current h k)\n     ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>)) -\n    (\\<lambda>_. 0)((a, y) := ennreal \\<delta>))", "have h'': \"current (\\<Gamma> \\<ominus> ?\\<epsilon>') ?h'\""], ["proof (prove)\nusing this:\n  current\n   (\\<Gamma> \\<ominus> \\<epsilon> \\<ominus> (\\<lambda>_. 0)\n    ((a, y) := ennreal \\<delta>))\n   (plus_current (plus_current h k)\n     ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>)) -\n    (\\<lambda>_. 0)((a, y) := ennreal \\<delta>))\n\ngoal (1 subgoal):\n 1. current\n     (\\<Gamma> \\<ominus>\n      plus_current \\<epsilon> ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>)))\n     (plus_current h k)", "by(rule arg_cong2[where f=current, THEN iffD1, rotated -1])\n          (simp_all add: minus_plus_current[OF \\<epsilon> g'] fun_eq_iff add_diff_eq_ennreal[symmetric])"], ["proof (state)\nthis:\n  current\n   (\\<Gamma> \\<ominus>\n    plus_current \\<epsilon> ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>)))\n   (plus_current h k)\n\ngoal (2 subgoals):\n 1. d_OUT (plus_current (F (\\<epsilon>, h)) k) a\n    < weight \\<Gamma> a \\<Longrightarrow>\n    \\<epsilon>h \\<le> sat \\<epsilon>h \\<and> sat \\<epsilon>h \\<in> Field leq\n 2. \\<not> d_OUT (plus_current (F (\\<epsilon>, h)) k) a\n           < weight \\<Gamma> a \\<Longrightarrow>\n    \\<epsilon>h \\<le> sat \\<epsilon>h \\<and> sat \\<epsilon>h \\<in> Field leq", "moreover"], ["proof (state)\nthis:\n  current\n   (\\<Gamma> \\<ominus>\n    plus_current \\<epsilon> ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>)))\n   (plus_current h k)\n\ngoal (2 subgoals):\n 1. d_OUT (plus_current (F (\\<epsilon>, h)) k) a\n    < weight \\<Gamma> a \\<Longrightarrow>\n    \\<epsilon>h \\<le> sat \\<epsilon>h \\<and> sat \\<epsilon>h \\<in> Field leq\n 2. \\<not> d_OUT (plus_current (F (\\<epsilon>, h)) k) a\n           < weight \\<Gamma> a \\<Longrightarrow>\n    \\<epsilon>h \\<le> sat \\<epsilon>h \\<and> sat \\<epsilon>h \\<in> Field leq", "have \"wave (\\<Gamma> \\<ominus> ?\\<epsilon>') ?h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wave\n     (\\<Gamma> \\<ominus>\n      plus_current \\<epsilon> ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>)))\n     (plus_current h k)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. separating\n     (\\<Gamma> \\<ominus>\n      plus_current \\<epsilon> ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>)))\n     (TER\\<^bsub>\\<Gamma> \\<ominus> plus_current \\<epsilon> ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>))\\<^esub>\n       (plus_current h k))\n 2. current\n     (\\<Gamma> \\<ominus>\n      plus_current \\<epsilon> ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>)))\n     (plus_current h k)", "have \"separating (\\<Gamma> \\<ominus> \\<epsilon>) (TER\\<^bsub>\\<Gamma> \\<ominus> \\<epsilon>\\<^esub> (plus_current h k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. separating (\\<Gamma> \\<ominus> \\<epsilon>)\n     (TER\\<^bsub>\\<Gamma> \\<ominus> \\<epsilon>\\<^esub> (plus_current h k))", "using k k_w"], ["proof (prove)\nusing this:\n  current (\\<Gamma> \\<ominus> F (\\<epsilon>, h)) k\n  wave (\\<Gamma> \\<ominus> F (\\<epsilon>, h)) k\n\ngoal (1 subgoal):\n 1. separating (\\<Gamma> \\<ominus> \\<epsilon>)\n     (TER\\<^bsub>\\<Gamma> \\<ominus> \\<epsilon>\\<^esub> (plus_current h k))", "unfolding F_simps minus_plus_current[OF \\<epsilon> h]"], ["proof (prove)\nusing this:\n  current (\\<Gamma> \\<ominus> \\<epsilon> \\<ominus> h) k\n  wave (\\<Gamma> \\<ominus> \\<epsilon> \\<ominus> h) k\n\ngoal (1 subgoal):\n 1. separating (\\<Gamma> \\<ominus> \\<epsilon>)\n     (TER\\<^bsub>\\<Gamma> \\<ominus> \\<epsilon>\\<^esub> (plus_current h k))", "by(intro waveD_separating \\<epsilon>.wave_plus_current_minus[OF h h_w])"], ["proof (state)\nthis:\n  separating (\\<Gamma> \\<ominus> \\<epsilon>)\n   (TER\\<^bsub>\\<Gamma> \\<ominus> \\<epsilon>\\<^esub> (plus_current h k))\n\ngoal (2 subgoals):\n 1. separating\n     (\\<Gamma> \\<ominus>\n      plus_current \\<epsilon> ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>)))\n     (TER\\<^bsub>\\<Gamma> \\<ominus> plus_current \\<epsilon> ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>))\\<^esub>\n       (plus_current h k))\n 2. current\n     (\\<Gamma> \\<ominus>\n      plus_current \\<epsilon> ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>)))\n     (plus_current h k)", "moreover"], ["proof (state)\nthis:\n  separating (\\<Gamma> \\<ominus> \\<epsilon>)\n   (TER\\<^bsub>\\<Gamma> \\<ominus> \\<epsilon>\\<^esub> (plus_current h k))\n\ngoal (2 subgoals):\n 1. separating\n     (\\<Gamma> \\<ominus>\n      plus_current \\<epsilon> ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>)))\n     (TER\\<^bsub>\\<Gamma> \\<ominus> plus_current \\<epsilon> ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>))\\<^esub>\n       (plus_current h k))\n 2. current\n     (\\<Gamma> \\<ominus>\n      plus_current \\<epsilon> ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>)))\n     (plus_current h k)", "have \"TER\\<^bsub>\\<Gamma> \\<ominus> \\<epsilon>\\<^esub> (plus_current h k) \\<subseteq> TER\\<^bsub>\\<Gamma> \\<ominus> ?\\<epsilon>'\\<^esub> (plus_current h k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. TER\\<^bsub>\\<Gamma> \\<ominus> \\<epsilon>\\<^esub> (plus_current h k)\n    \\<subseteq> TER\\<^bsub>\\<Gamma> \\<ominus> plus_current \\<epsilon> ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>))\\<^esub>\n                 (plus_current h k)", "by(auto 4 4 simp add: SAT.simps weight_minus_web[OF \\<epsilon>] weight_minus_web[OF \\<epsilon>'] split: if_split_asm elim: order_trans[rotated] intro!: ennreal_minus_mono d_IN_mono add_increasing2 \\<delta>_nonneg)"], ["proof (state)\nthis:\n  TER\\<^bsub>\\<Gamma> \\<ominus> \\<epsilon>\\<^esub> (plus_current h k)\n  \\<subseteq> TER\\<^bsub>\\<Gamma> \\<ominus> plus_current \\<epsilon> ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>))\\<^esub>\n               (plus_current h k)\n\ngoal (2 subgoals):\n 1. separating\n     (\\<Gamma> \\<ominus>\n      plus_current \\<epsilon> ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>)))\n     (TER\\<^bsub>\\<Gamma> \\<ominus> plus_current \\<epsilon> ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>))\\<^esub>\n       (plus_current h k))\n 2. current\n     (\\<Gamma> \\<ominus>\n      plus_current \\<epsilon> ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>)))\n     (plus_current h k)", "ultimately"], ["proof (chain)\npicking this:\n  separating (\\<Gamma> \\<ominus> \\<epsilon>)\n   (TER\\<^bsub>\\<Gamma> \\<ominus> \\<epsilon>\\<^esub> (plus_current h k))\n  TER\\<^bsub>\\<Gamma> \\<ominus> \\<epsilon>\\<^esub> (plus_current h k)\n  \\<subseteq> TER\\<^bsub>\\<Gamma> \\<ominus> plus_current \\<epsilon> ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>))\\<^esub>\n               (plus_current h k)", "show sep: \"separating (\\<Gamma> \\<ominus> ?\\<epsilon>') (TER\\<^bsub>\\<Gamma> \\<ominus> ?\\<epsilon>'\\<^esub> ?h')\""], ["proof (prove)\nusing this:\n  separating (\\<Gamma> \\<ominus> \\<epsilon>)\n   (TER\\<^bsub>\\<Gamma> \\<ominus> \\<epsilon>\\<^esub> (plus_current h k))\n  TER\\<^bsub>\\<Gamma> \\<ominus> \\<epsilon>\\<^esub> (plus_current h k)\n  \\<subseteq> TER\\<^bsub>\\<Gamma> \\<ominus> plus_current \\<epsilon> ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>))\\<^esub>\n               (plus_current h k)\n\ngoal (1 subgoal):\n 1. separating\n     (\\<Gamma> \\<ominus>\n      plus_current \\<epsilon> ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>)))\n     (TER\\<^bsub>\\<Gamma> \\<ominus> plus_current \\<epsilon> ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>))\\<^esub>\n       (plus_current h k))", "by(simp add: minus_plus_current[OF \\<epsilon> g'] separating_weakening)"], ["proof (state)\nthis:\n  separating\n   (\\<Gamma> \\<ominus>\n    plus_current \\<epsilon> ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>)))\n   (TER\\<^bsub>\\<Gamma> \\<ominus> plus_current \\<epsilon> ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>))\\<^esub>\n     (plus_current h k))\n\ngoal (1 subgoal):\n 1. current\n     (\\<Gamma> \\<ominus>\n      plus_current \\<epsilon> ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>)))\n     (plus_current h k)", "qed(rule h'')"], ["proof (state)\nthis:\n  wave\n   (\\<Gamma> \\<ominus>\n    plus_current \\<epsilon> ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>)))\n   (plus_current h k)\n\ngoal (2 subgoals):\n 1. d_OUT (plus_current (F (\\<epsilon>, h)) k) a\n    < weight \\<Gamma> a \\<Longrightarrow>\n    \\<epsilon>h \\<le> sat \\<epsilon>h \\<and> sat \\<epsilon>h \\<in> Field leq\n 2. \\<not> d_OUT (plus_current (F (\\<epsilon>, h)) k) a\n           < weight \\<Gamma> a \\<Longrightarrow>\n    \\<epsilon>h \\<le> sat \\<epsilon>h \\<and> sat \\<epsilon>h \\<in> Field leq", "moreover"], ["proof (state)\nthis:\n  wave\n   (\\<Gamma> \\<ominus>\n    plus_current \\<epsilon> ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>)))\n   (plus_current h k)\n\ngoal (2 subgoals):\n 1. d_OUT (plus_current (F (\\<epsilon>, h)) k) a\n    < weight \\<Gamma> a \\<Longrightarrow>\n    \\<epsilon>h \\<le> sat \\<epsilon>h \\<and> sat \\<epsilon>h \\<in> Field leq\n 2. \\<not> d_OUT (plus_current (F (\\<epsilon>, h)) k) a\n           < weight \\<Gamma> a \\<Longrightarrow>\n    \\<epsilon>h \\<le> sat \\<epsilon>h \\<and> sat \\<epsilon>h \\<in> Field leq", "have \"\\<not> hindered (\\<Gamma> \\<ominus> F (?\\<epsilon>', ?h'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> hindered\n            (\\<Gamma> \\<ominus>\n             F (plus_current \\<epsilon>\n                 ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>)),\n                plus_current h k))", "using unhindered'"], ["proof (prove)\nusing this:\n  \\<not> hindered (reduce_weight \\<Omega> y \\<delta>)\n\ngoal (1 subgoal):\n 1. \\<not> hindered\n            (\\<Gamma> \\<ominus>\n             F (plus_current \\<epsilon>\n                 ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>)),\n                plus_current h k))", "proof(rule contrapos_nn)"], ["proof (state)\ngoal (1 subgoal):\n 1. hindered\n     (\\<Gamma> \\<ominus>\n      F (plus_current \\<epsilon>\n          ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>)),\n         plus_current h k)) \\<Longrightarrow>\n    hindered (reduce_weight \\<Omega> y \\<delta>)", "assume \"hindered (\\<Gamma> \\<ominus> F (?\\<epsilon>', ?h'))\""], ["proof (state)\nthis:\n  hindered\n   (\\<Gamma> \\<ominus>\n    F (plus_current \\<epsilon>\n        ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>)),\n       plus_current h k))\n\ngoal (1 subgoal):\n 1. hindered\n     (\\<Gamma> \\<ominus>\n      F (plus_current \\<epsilon>\n          ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>)),\n         plus_current h k)) \\<Longrightarrow>\n    hindered (reduce_weight \\<Omega> y \\<delta>)", "thus \"hindered ?\\<Omega>\""], ["proof (prove)\nusing this:\n  hindered\n   (\\<Gamma> \\<ominus>\n    F (plus_current \\<epsilon>\n        ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>)),\n       plus_current h k))\n\ngoal (1 subgoal):\n 1. hindered (reduce_weight \\<Omega> y \\<delta>)", "proof(rule hindered_mono_web[rotated -1])"], ["proof (state)\ngoal (5 subgoals):\n 1. edge (reduce_weight \\<Omega> y \\<delta>) =\n    edge\n     (\\<Gamma> \\<ominus>\n      F (plus_current \\<epsilon>\n          ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>)),\n         plus_current h k))\n 2. A (reduce_weight \\<Omega> y \\<delta>) =\n    A (\\<Gamma> \\<ominus>\n       F (plus_current \\<epsilon>\n           ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>)),\n          plus_current h k))\n 3. B (reduce_weight \\<Omega> y \\<delta>) =\n    B (\\<Gamma> \\<ominus>\n       F (plus_current \\<epsilon>\n           ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>)),\n          plus_current h k))\n 4. \\<And>x.\n       x \\<notin> A (\\<Gamma> \\<ominus>\n                     F (plus_current \\<epsilon>\n                         ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>)),\n                        plus_current h k)) \\<Longrightarrow>\n       weight (reduce_weight \\<Omega> y \\<delta>) x =\n       weight\n        (\\<Gamma> \\<ominus>\n         F (plus_current \\<epsilon>\n             ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>)),\n            plus_current h k))\n        x\n 5. \\<And>aa.\n       aa \\<in> A (\\<Gamma> \\<ominus>\n                   F (plus_current \\<epsilon>\n                       ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>)),\n                      plus_current h k)) \\<Longrightarrow>\n       weight\n        (\\<Gamma> \\<ominus>\n         F (plus_current \\<epsilon>\n             ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>)),\n            plus_current h k))\n        aa\n       \\<le> weight (reduce_weight \\<Omega> y \\<delta>) aa", "show \"weight ?\\<Omega> z = weight (\\<Gamma> \\<ominus> F (?\\<epsilon>', ?h')) z\" if \"z \\<notin> A (\\<Gamma> \\<ominus> F (?\\<epsilon>', ?h'))\" for z"], ["proof (prove)\ngoal (1 subgoal):\n 1. weight (reduce_weight \\<Omega> y \\<delta>) z =\n    weight\n     (\\<Gamma> \\<ominus>\n      F (plus_current \\<epsilon>\n          ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>)),\n         plus_current h k))\n     z", "using that"], ["proof (prove)\nusing this:\n  z \\<notin> A (\\<Gamma> \\<ominus>\n                F (plus_current \\<epsilon>\n                    ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>)),\n                   plus_current h k))\n\ngoal (1 subgoal):\n 1. weight (reduce_weight \\<Omega> y \\<delta>) z =\n    weight\n     (\\<Gamma> \\<ominus>\n      F (plus_current \\<epsilon>\n          ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>)),\n         plus_current h k))\n     z", "unfolding F'"], ["proof (prove)\nusing this:\n  z \\<notin> A (\\<Gamma> \\<ominus>\n                plus_current (plus_current (F (\\<epsilon>, h)) k)\n                 ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>)))\n\ngoal (1 subgoal):\n 1. weight (reduce_weight \\<Omega> y \\<delta>) z =\n    weight\n     (\\<Gamma> \\<ominus>\n      plus_current (plus_current (F (\\<epsilon>, h)) k)\n       ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>)))\n     z", "apply(cases \"z = y\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>z \\<notin> A (\\<Gamma> \\<ominus>\n                           plus_current (plus_current (F (\\<epsilon>, h)) k)\n                            ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>)));\n     z = y\\<rbrakk>\n    \\<Longrightarrow> weight (reduce_weight \\<Omega> y \\<delta>) z =\n                      weight\n                       (\\<Gamma> \\<ominus>\n                        plus_current (plus_current (F (\\<epsilon>, h)) k)\n                         ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>)))\n                       z\n 2. \\<lbrakk>z \\<notin> A (\\<Gamma> \\<ominus>\n                           plus_current (plus_current (F (\\<epsilon>, h)) k)\n                            ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>)));\n     z \\<noteq> y\\<rbrakk>\n    \\<Longrightarrow> weight (reduce_weight \\<Omega> y \\<delta>) z =\n                      weight\n                       (\\<Gamma> \\<ominus>\n                        plus_current (plus_current (F (\\<epsilon>, h)) k)\n                         ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>)))\n                       z", "apply(simp_all add: \\<Omega>_def minus_plus_current[OF fk g] \\<Gamma>'.weight_minus_web[OF g] IN_g)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>y \\<notin> A \\<Gamma>; z = y\\<rbrakk>\n    \\<Longrightarrow> weight \\<Gamma> y - d_IN (F (\\<epsilon>, h)) y -\n                      d_IN k y -\n                      ennreal \\<delta> =\n                      weight \\<Gamma> y -\n                      d_IN (plus_current (F (\\<epsilon>, h)) k) y -\n                      ennreal \\<delta>\n 2. \\<lbrakk>z \\<notin> A \\<Gamma>; z \\<noteq> y\\<rbrakk>\n    \\<Longrightarrow> weight \\<Gamma> z - d_IN (F (\\<epsilon>, h)) z -\n                      d_IN k z =\n                      weight \\<Gamma> z -\n                      d_IN (plus_current (F (\\<epsilon>, h)) k) z", "apply(simp_all add: plus_current_def d_IN_add diff_add_eq_diff_diff_swap_ennreal currentD_finite_IN[OF f])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  ?z \\<notin> A (\\<Gamma> \\<ominus>\n                 F (plus_current \\<epsilon>\n                     ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>)),\n                    plus_current h k)) \\<Longrightarrow>\n  weight (reduce_weight \\<Omega> y \\<delta>) ?z =\n  weight\n   (\\<Gamma> \\<ominus>\n    F (plus_current \\<epsilon>\n        ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>)),\n       plus_current h k))\n   ?z\n\ngoal (4 subgoals):\n 1. edge (reduce_weight \\<Omega> y \\<delta>) =\n    edge\n     (\\<Gamma> \\<ominus>\n      F (plus_current \\<epsilon>\n          ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>)),\n         plus_current h k))\n 2. A (reduce_weight \\<Omega> y \\<delta>) =\n    A (\\<Gamma> \\<ominus>\n       F (plus_current \\<epsilon>\n           ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>)),\n          plus_current h k))\n 3. B (reduce_weight \\<Omega> y \\<delta>) =\n    B (\\<Gamma> \\<ominus>\n       F (plus_current \\<epsilon>\n           ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>)),\n          plus_current h k))\n 4. \\<And>aa.\n       aa \\<in> A (\\<Gamma> \\<ominus>\n                   F (plus_current \\<epsilon>\n                       ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>)),\n                      plus_current h k)) \\<Longrightarrow>\n       weight\n        (\\<Gamma> \\<ominus>\n         F (plus_current \\<epsilon>\n             ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>)),\n            plus_current h k))\n        aa\n       \\<le> weight (reduce_weight \\<Omega> y \\<delta>) aa", "have \"y \\<noteq> a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<noteq> a", "using y_B a disjoint"], ["proof (prove)\nusing this:\n  y \\<in> B \\<Omega>\n  a \\<in> A \\<Gamma>\n  A \\<Gamma> \\<inter> B \\<Gamma> = {}\n\ngoal (1 subgoal):\n 1. y \\<noteq> a", "by auto"], ["proof (state)\nthis:\n  y \\<noteq> a\n\ngoal (4 subgoals):\n 1. edge (reduce_weight \\<Omega> y \\<delta>) =\n    edge\n     (\\<Gamma> \\<ominus>\n      F (plus_current \\<epsilon>\n          ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>)),\n         plus_current h k))\n 2. A (reduce_weight \\<Omega> y \\<delta>) =\n    A (\\<Gamma> \\<ominus>\n       F (plus_current \\<epsilon>\n           ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>)),\n          plus_current h k))\n 3. B (reduce_weight \\<Omega> y \\<delta>) =\n    B (\\<Gamma> \\<ominus>\n       F (plus_current \\<epsilon>\n           ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>)),\n          plus_current h k))\n 4. \\<And>aa.\n       aa \\<in> A (\\<Gamma> \\<ominus>\n                   F (plus_current \\<epsilon>\n                       ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>)),\n                      plus_current h k)) \\<Longrightarrow>\n       weight\n        (\\<Gamma> \\<ominus>\n         F (plus_current \\<epsilon>\n             ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>)),\n            plus_current h k))\n        aa\n       \\<le> weight (reduce_weight \\<Omega> y \\<delta>) aa", "then"], ["proof (chain)\npicking this:\n  y \\<noteq> a", "show \"weight (\\<Gamma> \\<ominus> F (?\\<epsilon>', ?h')) z \\<le> weight ?\\<Omega> z\" if \"z \\<in> A (\\<Gamma> \\<ominus> F (?\\<epsilon>', ?h'))\" for z"], ["proof (prove)\nusing this:\n  y \\<noteq> a\n\ngoal (1 subgoal):\n 1. weight\n     (\\<Gamma> \\<ominus>\n      F (plus_current \\<epsilon>\n          ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>)),\n         plus_current h k))\n     z\n    \\<le> weight (reduce_weight \\<Omega> y \\<delta>) z", "using that y_B disjoint \\<delta>_nonneg"], ["proof (prove)\nusing this:\n  y \\<noteq> a\n  z \\<in> A (\\<Gamma> \\<ominus>\n             F (plus_current \\<epsilon>\n                 ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>)),\n                plus_current h k))\n  y \\<in> B \\<Omega>\n  A \\<Gamma> \\<inter> B \\<Gamma> = {}\n  0 \\<le> \\<delta>\n\ngoal (1 subgoal):\n 1. weight\n     (\\<Gamma> \\<ominus>\n      F (plus_current \\<epsilon>\n          ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>)),\n         plus_current h k))\n     z\n    \\<le> weight (reduce_weight \\<Omega> y \\<delta>) z", "unfolding F'"], ["proof (prove)\nusing this:\n  y \\<noteq> a\n  z \\<in> A (\\<Gamma> \\<ominus>\n             plus_current (plus_current (F (\\<epsilon>, h)) k)\n              ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>)))\n  y \\<in> B \\<Omega>\n  A \\<Gamma> \\<inter> B \\<Gamma> = {}\n  0 \\<le> \\<delta>\n\ngoal (1 subgoal):\n 1. weight\n     (\\<Gamma> \\<ominus>\n      plus_current (plus_current (F (\\<epsilon>, h)) k)\n       ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>)))\n     z\n    \\<le> weight (reduce_weight \\<Omega> y \\<delta>) z", "apply(cases \"z = a\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>y \\<noteq> a;\n     z \\<in> A (\\<Gamma> \\<ominus>\n                plus_current (plus_current (F (\\<epsilon>, h)) k)\n                 ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>)));\n     y \\<in> B \\<Omega>; A \\<Gamma> \\<inter> B \\<Gamma> = {};\n     0 \\<le> \\<delta>; z = a\\<rbrakk>\n    \\<Longrightarrow> weight\n                       (\\<Gamma> \\<ominus>\n                        plus_current (plus_current (F (\\<epsilon>, h)) k)\n                         ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>)))\n                       z\n                      \\<le> weight (reduce_weight \\<Omega> y \\<delta>) z\n 2. \\<lbrakk>y \\<noteq> a;\n     z \\<in> A (\\<Gamma> \\<ominus>\n                plus_current (plus_current (F (\\<epsilon>, h)) k)\n                 ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>)));\n     y \\<in> B \\<Omega>; A \\<Gamma> \\<inter> B \\<Gamma> = {};\n     0 \\<le> \\<delta>; z \\<noteq> a\\<rbrakk>\n    \\<Longrightarrow> weight\n                       (\\<Gamma> \\<ominus>\n                        plus_current (plus_current (F (\\<epsilon>, h)) k)\n                         ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>)))\n                       z\n                      \\<le> weight (reduce_weight \\<Omega> y \\<delta>) z", "apply(simp_all add: \\<Omega>_def minus_plus_current[OF fk g] \\<Gamma>'.weight_minus_web[OF g] OUT_g)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>y \\<noteq> a; a \\<in> A \\<Gamma>; y \\<in> B \\<Gamma>;\n     A \\<Gamma> \\<inter> B \\<Gamma> = {}; 0 \\<le> \\<delta>; z = a\\<rbrakk>\n    \\<Longrightarrow> weight \\<Gamma> a -\n                      d_OUT (plus_current (F (\\<epsilon>, h)) k) a -\n                      ennreal \\<delta>\n                      \\<le> weight \\<Gamma> a -\n                            d_OUT (F (\\<epsilon>, h)) a -\n                            d_OUT k a\n 2. \\<lbrakk>y \\<noteq> a; z \\<in> A \\<Gamma>; y \\<in> B \\<Gamma>;\n     A \\<Gamma> \\<inter> B \\<Gamma> = {}; 0 \\<le> \\<delta>;\n     z \\<noteq> a\\<rbrakk>\n    \\<Longrightarrow> (y = z \\<longrightarrow>\n                       weight \\<Gamma> z -\n                       d_OUT (plus_current (F (\\<epsilon>, h)) k) z\n                       \\<le> weight \\<Gamma> z -\n                             d_OUT (F (\\<epsilon>, h)) z -\n                             d_OUT k z -\n                             ennreal \\<delta>) \\<and>\n                      (y \\<noteq> z \\<longrightarrow>\n                       weight \\<Gamma> z -\n                       d_OUT (plus_current (F (\\<epsilon>, h)) k) z\n                       \\<le> weight \\<Gamma> z -\n                             d_OUT (F (\\<epsilon>, h)) z -\n                             d_OUT k z)", "apply(auto simp add: plus_current_def d_OUT_add diff_add_eq_diff_diff_swap_ennreal currentD_finite_OUT[OF f])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  ?z \\<in> A (\\<Gamma> \\<ominus>\n              F (plus_current \\<epsilon>\n                  ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>)),\n                 plus_current h k)) \\<Longrightarrow>\n  weight\n   (\\<Gamma> \\<ominus>\n    F (plus_current \\<epsilon>\n        ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>)),\n       plus_current h k))\n   ?z\n  \\<le> weight (reduce_weight \\<Omega> y \\<delta>) ?z\n\ngoal (3 subgoals):\n 1. edge (reduce_weight \\<Omega> y \\<delta>) =\n    edge\n     (\\<Gamma> \\<ominus>\n      F (plus_current \\<epsilon>\n          ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>)),\n         plus_current h k))\n 2. A (reduce_weight \\<Omega> y \\<delta>) =\n    A (\\<Gamma> \\<ominus>\n       F (plus_current \\<epsilon>\n           ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>)),\n          plus_current h k))\n 3. B (reduce_weight \\<Omega> y \\<delta>) =\n    B (\\<Gamma> \\<ominus>\n       F (plus_current \\<epsilon>\n           ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>)),\n          plus_current h k))", "qed(simp_all add: \\<Omega>_def)"], ["proof (state)\nthis:\n  hindered (reduce_weight \\<Omega> y \\<delta>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> hindered\n          (\\<Gamma> \\<ominus>\n           F (plus_current \\<epsilon>\n               ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>)),\n              plus_current h k))\n\ngoal (2 subgoals):\n 1. d_OUT (plus_current (F (\\<epsilon>, h)) k) a\n    < weight \\<Gamma> a \\<Longrightarrow>\n    \\<epsilon>h \\<le> sat \\<epsilon>h \\<and> sat \\<epsilon>h \\<in> Field leq\n 2. \\<not> d_OUT (plus_current (F (\\<epsilon>, h)) k) a\n           < weight \\<Gamma> a \\<Longrightarrow>\n    \\<epsilon>h \\<le> sat \\<epsilon>h \\<and> sat \\<epsilon>h \\<in> Field leq", "ultimately"], ["proof (chain)\npicking this:\n  current \\<Gamma>\n   (plus_current \\<epsilon> ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>)))\n  ?x \\<noteq> a \\<Longrightarrow>\n  d_OUT\n   (plus_current \\<epsilon> ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>)))\n   ?x =\n  0\n  current\n   (\\<Gamma> \\<ominus>\n    plus_current \\<epsilon> ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>)))\n   (plus_current h k)\n  wave\n   (\\<Gamma> \\<ominus>\n    plus_current \\<epsilon> ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>)))\n   (plus_current h k)\n  \\<not> hindered\n          (\\<Gamma> \\<ominus>\n           F (plus_current \\<epsilon>\n               ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>)),\n              plus_current h k))", "have \"(?\\<epsilon>', ?h') \\<in> Field leq\""], ["proof (prove)\nusing this:\n  current \\<Gamma>\n   (plus_current \\<epsilon> ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>)))\n  ?x \\<noteq> a \\<Longrightarrow>\n  d_OUT\n   (plus_current \\<epsilon> ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>)))\n   ?x =\n  0\n  current\n   (\\<Gamma> \\<ominus>\n    plus_current \\<epsilon> ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>)))\n   (plus_current h k)\n  wave\n   (\\<Gamma> \\<ominus>\n    plus_current \\<epsilon> ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>)))\n   (plus_current h k)\n  \\<not> hindered\n          (\\<Gamma> \\<ominus>\n           F (plus_current \\<epsilon>\n               ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>)),\n              plus_current h k))\n\ngoal (1 subgoal):\n 1. (plus_current \\<epsilon> ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>)),\n     plus_current h k)\n    \\<in> Field leq", "by-(rule F_I)"], ["proof (state)\nthis:\n  (plus_current \\<epsilon> ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>)),\n   plus_current h k)\n  \\<in> Field leq\n\ngoal (2 subgoals):\n 1. d_OUT (plus_current (F (\\<epsilon>, h)) k) a\n    < weight \\<Gamma> a \\<Longrightarrow>\n    \\<epsilon>h \\<le> sat \\<epsilon>h \\<and> sat \\<epsilon>h \\<in> Field leq\n 2. \\<not> d_OUT (plus_current (F (\\<epsilon>, h)) k) a\n           < weight \\<Gamma> a \\<Longrightarrow>\n    \\<epsilon>h \\<le> sat \\<epsilon>h \\<and> sat \\<epsilon>h \\<in> Field leq", "with Pair le sat that"], ["proof (chain)\npicking this:\n  \\<epsilon>h = (\\<epsilon>, h)\n  (\\<epsilon>, h)\n  \\<le> (plus_current \\<epsilon>\n          ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>)),\n         plus_current h k)\n  sat (\\<epsilon>, h) =\n  (plus_current \\<epsilon> ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>)),\n   plus_current h k)\n  (\\<epsilon>, h) \\<in> Field leq\n  (plus_current \\<epsilon> ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>)),\n   plus_current h k)\n  \\<in> Field leq", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<epsilon>h = (\\<epsilon>, h)\n  (\\<epsilon>, h)\n  \\<le> (plus_current \\<epsilon>\n          ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>)),\n         plus_current h k)\n  sat (\\<epsilon>, h) =\n  (plus_current \\<epsilon> ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>)),\n   plus_current h k)\n  (\\<epsilon>, h) \\<in> Field leq\n  (plus_current \\<epsilon> ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>)),\n   plus_current h k)\n  \\<in> Field leq\n\ngoal (1 subgoal):\n 1. \\<epsilon>h \\<le> sat \\<epsilon>h \\<and> sat \\<epsilon>h \\<in> Field leq", "by(auto)"], ["proof (state)\nthis:\n  \\<epsilon>h \\<le> sat \\<epsilon>h \\<and> sat \\<epsilon>h \\<in> Field leq\n\ngoal (1 subgoal):\n 1. \\<not> d_OUT (plus_current (F (\\<epsilon>, h)) k) a\n           < weight \\<Gamma> a \\<Longrightarrow>\n    \\<epsilon>h \\<le> sat \\<epsilon>h \\<and> sat \\<epsilon>h \\<in> Field leq", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> d_OUT (plus_current (F (\\<epsilon>, h)) k) a\n           < weight \\<Gamma> a \\<Longrightarrow>\n    \\<epsilon>h \\<le> sat \\<epsilon>h \\<and> sat \\<epsilon>h \\<in> Field leq", "case False"], ["proof (state)\nthis:\n  \\<not> d_OUT (plus_current (F (\\<epsilon>, h)) k) a < weight \\<Gamma> a\n\ngoal (1 subgoal):\n 1. \\<not> d_OUT (plus_current (F (\\<epsilon>, h)) k) a\n           < weight \\<Gamma> a \\<Longrightarrow>\n    \\<epsilon>h \\<le> sat \\<epsilon>h \\<and> sat \\<epsilon>h \\<in> Field leq", "with currentD_weight_OUT[OF fk, of a]"], ["proof (chain)\npicking this:\n  d_OUT (plus_current (F (\\<epsilon>, h)) k) a \\<le> weight \\<Gamma> a\n  \\<not> d_OUT (plus_current (F (\\<epsilon>, h)) k) a < weight \\<Gamma> a", "have \"d_OUT ?fk a = weight \\<Gamma> a\""], ["proof (prove)\nusing this:\n  d_OUT (plus_current (F (\\<epsilon>, h)) k) a \\<le> weight \\<Gamma> a\n  \\<not> d_OUT (plus_current (F (\\<epsilon>, h)) k) a < weight \\<Gamma> a\n\ngoal (1 subgoal):\n 1. d_OUT (plus_current (F (\\<epsilon>, h)) k) a = weight \\<Gamma> a", "by simp"], ["proof (state)\nthis:\n  d_OUT (plus_current (F (\\<epsilon>, h)) k) a = weight \\<Gamma> a\n\ngoal (1 subgoal):\n 1. \\<not> d_OUT (plus_current (F (\\<epsilon>, h)) k) a\n           < weight \\<Gamma> a \\<Longrightarrow>\n    \\<epsilon>h \\<le> sat \\<epsilon>h \\<and> sat \\<epsilon>h \\<in> Field leq", "have \"sat \\<epsilon>h = \\<epsilon>h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sat \\<epsilon>h = \\<epsilon>h", "using False Pair"], ["proof (prove)\nusing this:\n  \\<not> d_OUT (plus_current (F (\\<epsilon>, h)) k) a < weight \\<Gamma> a\n  \\<epsilon>h = (\\<epsilon>, h)\n\ngoal (1 subgoal):\n 1. sat \\<epsilon>h = \\<epsilon>h", "by(simp add: sat_def k_def)"], ["proof (state)\nthis:\n  sat \\<epsilon>h = \\<epsilon>h\n\ngoal (1 subgoal):\n 1. \\<not> d_OUT (plus_current (F (\\<epsilon>, h)) k) a\n           < weight \\<Gamma> a \\<Longrightarrow>\n    \\<epsilon>h \\<le> sat \\<epsilon>h \\<and> sat \\<epsilon>h \\<in> Field leq", "thus ?thesis"], ["proof (prove)\nusing this:\n  sat \\<epsilon>h = \\<epsilon>h\n\ngoal (1 subgoal):\n 1. \\<epsilon>h \\<le> sat \\<epsilon>h \\<and> sat \\<epsilon>h \\<in> Field leq", "using that Pair"], ["proof (prove)\nusing this:\n  sat \\<epsilon>h = \\<epsilon>h\n  (\\<epsilon>, h) \\<in> Field leq\n  \\<epsilon>h = (\\<epsilon>, h)\n\ngoal (1 subgoal):\n 1. \\<epsilon>h \\<le> sat \\<epsilon>h \\<and> sat \\<epsilon>h \\<in> Field leq", "by(auto)"], ["proof (state)\nthis:\n  \\<epsilon>h \\<le> sat \\<epsilon>h \\<and> sat \\<epsilon>h \\<in> Field leq\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<epsilon>h \\<le> sat \\<epsilon>h \\<and> sat \\<epsilon>h \\<in> Field leq\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?\\<epsilon>h \\<in> Field leq \\<Longrightarrow>\n  ?\\<epsilon>h \\<le> sat ?\\<epsilon>h \\<and>\n  sat ?\\<epsilon>h \\<in> Field leq\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       current \\<Gamma> f \\<and>\n       d_OUT f a = weight \\<Gamma> a \\<and>\n       \\<not> hindered (\\<Gamma> \\<ominus> f)", "have \"bourbaki_witt_fixpoint Sup leq sat\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bourbaki_witt_fixpoint Sup leq sat", "using increasing chain_Field"], ["proof (prove)\nusing this:\n  ?\\<epsilon>h \\<in> Field leq \\<Longrightarrow>\n  ?\\<epsilon>h \\<le> sat ?\\<epsilon>h \\<and>\n  sat ?\\<epsilon>h \\<in> Field leq\n  \\<lbrakk>?M \\<in> Chains leq; ?M \\<noteq> {}\\<rbrakk>\n  \\<Longrightarrow> \\<Squnion> ?M \\<in> Field leq\n\ngoal (1 subgoal):\n 1. bourbaki_witt_fixpoint Sup leq sat", "unfolding leq_def"], ["proof (prove)\nusing this:\n  ?\\<epsilon>h\n  \\<in> Field (restrict_rel Fld {(x, y). x \\<le> y}) \\<Longrightarrow>\n  ?\\<epsilon>h \\<le> sat ?\\<epsilon>h \\<and>\n  sat ?\\<epsilon>h \\<in> Field (restrict_rel Fld {(x, y). x \\<le> y})\n  \\<lbrakk>?M \\<in> Chains (restrict_rel Fld {(x, y). x \\<le> y});\n   ?M \\<noteq> {}\\<rbrakk>\n  \\<Longrightarrow> \\<Squnion> ?M\n                    \\<in> Field (restrict_rel Fld {(x, y). x \\<le> y})\n\ngoal (1 subgoal):\n 1. bourbaki_witt_fixpoint Sup (restrict_rel Fld {(x, y). x \\<le> y}) sat", "by(intro bourbaki_witt_fixpoint_restrict_rel)(auto intro: Sup_upper Sup_least)"], ["proof (state)\nthis:\n  bourbaki_witt_fixpoint Sup leq sat\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       current \\<Gamma> f \\<and>\n       d_OUT f a = weight \\<Gamma> a \\<and>\n       \\<not> hindered (\\<Gamma> \\<ominus> f)", "then"], ["proof (chain)\npicking this:\n  bourbaki_witt_fixpoint Sup leq sat", "interpret bourbaki_witt_fixpoint Sup leq sat"], ["proof (prove)\nusing this:\n  bourbaki_witt_fixpoint Sup leq sat\n\ngoal (1 subgoal):\n 1. bourbaki_witt_fixpoint Sup leq sat", "."], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>f.\n       current \\<Gamma> f \\<and>\n       d_OUT f a = weight \\<Gamma> a \\<and>\n       \\<not> hindered (\\<Gamma> \\<ominus> f)", "define f where \"f = fixp_above (zero_current, zero_current)\""], ["proof (state)\nthis:\n  f = fixp_above (\\<lambda>_. 0, \\<lambda>_. 0)\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       current \\<Gamma> f \\<and>\n       d_OUT f a = weight \\<Gamma> a \\<and>\n       \\<not> hindered (\\<Gamma> \\<ominus> f)", "have Field: \"f \\<in> Field leq\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<in> Field leq", "using fixp_above_Field[OF zero]"], ["proof (prove)\nusing this:\n  fixp_above (\\<lambda>_. 0, \\<lambda>_. 0) \\<in> Field leq\n\ngoal (1 subgoal):\n 1. f \\<in> Field leq", "unfolding f_def"], ["proof (prove)\nusing this:\n  fixp_above (\\<lambda>_. 0, \\<lambda>_. 0) \\<in> Field leq\n\ngoal (1 subgoal):\n 1. fixp_above (\\<lambda>_. 0, \\<lambda>_. 0) \\<in> Field leq", "."], ["proof (state)\nthis:\n  f \\<in> Field leq\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       current \\<Gamma> f \\<and>\n       d_OUT f a = weight \\<Gamma> a \\<and>\n       \\<not> hindered (\\<Gamma> \\<ominus> f)", "then"], ["proof (chain)\npicking this:\n  f \\<in> Field leq", "have f: \"current \\<Gamma> (F f)\" and unhindered: \"\\<not> hindered (\\<Gamma> \\<ominus> F f)\""], ["proof (prove)\nusing this:\n  f \\<in> Field leq\n\ngoal (1 subgoal):\n 1. current \\<Gamma> (F f) &&& \\<not> hindered (\\<Gamma> \\<ominus> F f)", "by(cases f; simp add: f unhindered'; fail)+"], ["proof (state)\nthis:\n  current \\<Gamma> (F f)\n  \\<not> hindered (\\<Gamma> \\<ominus> F f)\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       current \\<Gamma> f \\<and>\n       d_OUT f a = weight \\<Gamma> a \\<and>\n       \\<not> hindered (\\<Gamma> \\<ominus> f)", "interpret \\<Gamma>: countable_bipartite_web \"\\<Gamma> \\<ominus> F f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. countable_bipartite_web (\\<Gamma> \\<ominus> F f)", "using f"], ["proof (prove)\nusing this:\n  current \\<Gamma> (F f)\n\ngoal (1 subgoal):\n 1. countable_bipartite_web (\\<Gamma> \\<ominus> F f)", "by(rule countable_bipartite_web_minus_web)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>f.\n       current \\<Gamma> f \\<and>\n       d_OUT f a = weight \\<Gamma> a \\<and>\n       \\<not> hindered (\\<Gamma> \\<ominus> f)", "note [simp] = weight_minus_web[OF f]"], ["proof (state)\nthis:\n  weight (\\<Gamma> \\<ominus> F f) ?x =\n  (if ?x \\<in> A \\<Gamma> then weight \\<Gamma> ?x - d_OUT (F f) ?x\n   else weight \\<Gamma> ?x - d_IN (F f) ?x)\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       current \\<Gamma> f \\<and>\n       d_OUT f a = weight \\<Gamma> a \\<and>\n       \\<not> hindered (\\<Gamma> \\<ominus> f)", "have Field': \"(fst f, snd f) \\<in> Field leq\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (fst f, snd f) \\<in> Field leq", "using Field"], ["proof (prove)\nusing this:\n  f \\<in> Field leq\n\ngoal (1 subgoal):\n 1. (fst f, snd f) \\<in> Field leq", "by simp"], ["proof (state)\nthis:\n  (fst f, snd f) \\<in> Field leq\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       current \\<Gamma> f \\<and>\n       d_OUT f a = weight \\<Gamma> a \\<and>\n       \\<not> hindered (\\<Gamma> \\<ominus> f)", "let ?P_k = \"\\<lambda>k. current (\\<Gamma> \\<ominus> F f) k \\<and> wave (\\<Gamma> \\<ominus> F f) k \\<and> (\\<forall>k'. current (\\<Gamma> \\<ominus> F f) k' \\<and> wave (\\<Gamma> \\<ominus> F f) k' \\<and> k \\<le> k' \\<longrightarrow> k = k')\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>f.\n       current \\<Gamma> f \\<and>\n       d_OUT f a = weight \\<Gamma> a \\<and>\n       \\<not> hindered (\\<Gamma> \\<ominus> f)", "define k where \"k = Eps ?P_k\""], ["proof (state)\nthis:\n  k =\n  (SOME k.\n      current (\\<Gamma> \\<ominus> F f) k \\<and>\n      wave (\\<Gamma> \\<ominus> F f) k \\<and>\n      (\\<forall>k'.\n          current (\\<Gamma> \\<ominus> F f) k' \\<and>\n          wave (\\<Gamma> \\<ominus> F f) k' \\<and>\n          k \\<le> k' \\<longrightarrow>\n          k = k'))\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       current \\<Gamma> f \\<and>\n       d_OUT f a = weight \\<Gamma> a \\<and>\n       \\<not> hindered (\\<Gamma> \\<ominus> f)", "have \"Ex ?P_k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>k.\n       current (\\<Gamma> \\<ominus> F f) k \\<and>\n       wave (\\<Gamma> \\<ominus> F f) k \\<and>\n       (\\<forall>k'.\n           current (\\<Gamma> \\<ominus> F f) k' \\<and>\n           wave (\\<Gamma> \\<ominus> F f) k' \\<and>\n           k \\<le> k' \\<longrightarrow>\n           k = k')", "by(intro ex_maximal_wave)(simp_all)"], ["proof (state)\nthis:\n  \\<exists>k.\n     current (\\<Gamma> \\<ominus> F f) k \\<and>\n     wave (\\<Gamma> \\<ominus> F f) k \\<and>\n     (\\<forall>k'.\n         current (\\<Gamma> \\<ominus> F f) k' \\<and>\n         wave (\\<Gamma> \\<ominus> F f) k' \\<and>\n         k \\<le> k' \\<longrightarrow>\n         k = k')\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       current \\<Gamma> f \\<and>\n       d_OUT f a = weight \\<Gamma> a \\<and>\n       \\<not> hindered (\\<Gamma> \\<ominus> f)", "hence \"?P_k k\""], ["proof (prove)\nusing this:\n  \\<exists>k.\n     current (\\<Gamma> \\<ominus> F f) k \\<and>\n     wave (\\<Gamma> \\<ominus> F f) k \\<and>\n     (\\<forall>k'.\n         current (\\<Gamma> \\<ominus> F f) k' \\<and>\n         wave (\\<Gamma> \\<ominus> F f) k' \\<and>\n         k \\<le> k' \\<longrightarrow>\n         k = k')\n\ngoal (1 subgoal):\n 1. current (\\<Gamma> \\<ominus> F f) k \\<and>\n    wave (\\<Gamma> \\<ominus> F f) k \\<and>\n    (\\<forall>k'.\n        current (\\<Gamma> \\<ominus> F f) k' \\<and>\n        wave (\\<Gamma> \\<ominus> F f) k' \\<and> k \\<le> k' \\<longrightarrow>\n        k = k')", "unfolding k_def"], ["proof (prove)\nusing this:\n  \\<exists>k.\n     current (\\<Gamma> \\<ominus> F f) k \\<and>\n     wave (\\<Gamma> \\<ominus> F f) k \\<and>\n     (\\<forall>k'.\n         current (\\<Gamma> \\<ominus> F f) k' \\<and>\n         wave (\\<Gamma> \\<ominus> F f) k' \\<and>\n         k \\<le> k' \\<longrightarrow>\n         k = k')\n\ngoal (1 subgoal):\n 1. current (\\<Gamma> \\<ominus> F f)\n     (SOME k.\n         current (\\<Gamma> \\<ominus> F f) k \\<and>\n         wave (\\<Gamma> \\<ominus> F f) k \\<and>\n         (\\<forall>k'.\n             current (\\<Gamma> \\<ominus> F f) k' \\<and>\n             wave (\\<Gamma> \\<ominus> F f) k' \\<and>\n             k \\<le> k' \\<longrightarrow>\n             k = k')) \\<and>\n    wave (\\<Gamma> \\<ominus> F f)\n     (SOME k.\n         current (\\<Gamma> \\<ominus> F f) k \\<and>\n         wave (\\<Gamma> \\<ominus> F f) k \\<and>\n         (\\<forall>k'.\n             current (\\<Gamma> \\<ominus> F f) k' \\<and>\n             wave (\\<Gamma> \\<ominus> F f) k' \\<and>\n             k \\<le> k' \\<longrightarrow>\n             k = k')) \\<and>\n    (\\<forall>k'.\n        current (\\<Gamma> \\<ominus> F f) k' \\<and>\n        wave (\\<Gamma> \\<ominus> F f) k' \\<and>\n        (SOME k.\n            current (\\<Gamma> \\<ominus> F f) k \\<and>\n            wave (\\<Gamma> \\<ominus> F f) k \\<and>\n            (\\<forall>k'.\n                current (\\<Gamma> \\<ominus> F f) k' \\<and>\n                wave (\\<Gamma> \\<ominus> F f) k' \\<and>\n                k \\<le> k' \\<longrightarrow>\n                k = k'))\n        \\<le> k' \\<longrightarrow>\n        (SOME k.\n            current (\\<Gamma> \\<ominus> F f) k \\<and>\n            wave (\\<Gamma> \\<ominus> F f) k \\<and>\n            (\\<forall>k'.\n                current (\\<Gamma> \\<ominus> F f) k' \\<and>\n                wave (\\<Gamma> \\<ominus> F f) k' \\<and>\n                k \\<le> k' \\<longrightarrow>\n                k = k')) =\n        k')", "by(rule someI_ex)"], ["proof (state)\nthis:\n  current (\\<Gamma> \\<ominus> F f) k \\<and>\n  wave (\\<Gamma> \\<ominus> F f) k \\<and>\n  (\\<forall>k'.\n      current (\\<Gamma> \\<ominus> F f) k' \\<and>\n      wave (\\<Gamma> \\<ominus> F f) k' \\<and> k \\<le> k' \\<longrightarrow>\n      k = k')\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       current \\<Gamma> f \\<and>\n       d_OUT f a = weight \\<Gamma> a \\<and>\n       \\<not> hindered (\\<Gamma> \\<ominus> f)", "hence k: \"current (\\<Gamma> \\<ominus> F f) k\" and k_w: \"wave (\\<Gamma> \\<ominus> F f) k\"\n    and maximal: \"\\<And>k'. \\<lbrakk> current (\\<Gamma> \\<ominus> F f) k'; wave (\\<Gamma> \\<ominus> F f) k'; k \\<le> k' \\<rbrakk> \\<Longrightarrow> k = k'\""], ["proof (prove)\nusing this:\n  current (\\<Gamma> \\<ominus> F f) k \\<and>\n  wave (\\<Gamma> \\<ominus> F f) k \\<and>\n  (\\<forall>k'.\n      current (\\<Gamma> \\<ominus> F f) k' \\<and>\n      wave (\\<Gamma> \\<ominus> F f) k' \\<and> k \\<le> k' \\<longrightarrow>\n      k = k')\n\ngoal (1 subgoal):\n 1. current (\\<Gamma> \\<ominus> F f) k &&&\n    wave (\\<Gamma> \\<ominus> F f) k &&&\n    (\\<And>k'.\n        \\<lbrakk>current (\\<Gamma> \\<ominus> F f) k';\n         wave (\\<Gamma> \\<ominus> F f) k'; k \\<le> k'\\<rbrakk>\n        \\<Longrightarrow> k = k')", "by blast+"], ["proof (state)\nthis:\n  current (\\<Gamma> \\<ominus> F f) k\n  wave (\\<Gamma> \\<ominus> F f) k\n  \\<lbrakk>current (\\<Gamma> \\<ominus> F f) ?k';\n   wave (\\<Gamma> \\<ominus> F f) ?k'; k \\<le> ?k'\\<rbrakk>\n  \\<Longrightarrow> k = ?k'\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       current \\<Gamma> f \\<and>\n       d_OUT f a = weight \\<Gamma> a \\<and>\n       \\<not> hindered (\\<Gamma> \\<ominus> f)", "note [simp] = \\<Gamma>.weight_minus_web[OF k]"], ["proof (state)\nthis:\n  weight (\\<Gamma> \\<ominus> F f \\<ominus> k) ?x =\n  (if ?x \\<in> A (\\<Gamma> \\<ominus> F f)\n   then weight (\\<Gamma> \\<ominus> F f) ?x - d_OUT k ?x\n   else weight (\\<Gamma> \\<ominus> F f) ?x - d_IN k ?x)\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       current \\<Gamma> f \\<and>\n       d_OUT f a = weight \\<Gamma> a \\<and>\n       \\<not> hindered (\\<Gamma> \\<ominus> f)", "let ?fk = \"plus_current (F f) k\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>f.\n       current \\<Gamma> f \\<and>\n       d_OUT f a = weight \\<Gamma> a \\<and>\n       \\<not> hindered (\\<Gamma> \\<ominus> f)", "have IN_fk: \"d_IN ?fk x = d_IN (F f) x + d_IN k x\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_IN (plus_current (F f) k) x = d_IN (F f) x + d_IN k x", "by(simp add: d_IN_def nn_integral_add)"], ["proof (state)\nthis:\n  d_IN (plus_current (F f) k) ?x = d_IN (F f) ?x + d_IN k ?x\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       current \\<Gamma> f \\<and>\n       d_OUT f a = weight \\<Gamma> a \\<and>\n       \\<not> hindered (\\<Gamma> \\<ominus> f)", "have OUT_fk: \"d_OUT ?fk x = d_OUT (F f) x + d_OUT k x\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT (plus_current (F f) k) x = d_OUT (F f) x + d_OUT k x", "by(simp add: d_OUT_def nn_integral_add)"], ["proof (state)\nthis:\n  d_OUT (plus_current (F f) k) ?x = d_OUT (F f) ?x + d_OUT k ?x\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       current \\<Gamma> f \\<and>\n       d_OUT f a = weight \\<Gamma> a \\<and>\n       \\<not> hindered (\\<Gamma> \\<ominus> f)", "have fk: \"current \\<Gamma> ?fk\""], ["proof (prove)\ngoal (1 subgoal):\n 1. current \\<Gamma> (plus_current (F f) k)", "using f k"], ["proof (prove)\nusing this:\n  current \\<Gamma> (F f)\n  current (\\<Gamma> \\<ominus> F f) k\n\ngoal (1 subgoal):\n 1. current \\<Gamma> (plus_current (F f) k)", "by(rule current_plus_current_minus)"], ["proof (state)\nthis:\n  current \\<Gamma> (plus_current (F f) k)\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       current \\<Gamma> f \\<and>\n       d_OUT f a = weight \\<Gamma> a \\<and>\n       \\<not> hindered (\\<Gamma> \\<ominus> f)", "have \"d_OUT ?fk a \\<ge> weight \\<Gamma> a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. weight \\<Gamma> a \\<le> d_OUT (plus_current (F f) k) a", "proof(rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> weight \\<Gamma> a\n           \\<le> d_OUT (plus_current (F f) k) a \\<Longrightarrow>\n    False", "assume \"\\<not> ?thesis\""], ["proof (state)\nthis:\n  \\<not> weight \\<Gamma> a \\<le> d_OUT (plus_current (F f) k) a\n\ngoal (1 subgoal):\n 1. \\<not> weight \\<Gamma> a\n           \\<le> d_OUT (plus_current (F f) k) a \\<Longrightarrow>\n    False", "hence less: \"d_OUT ?fk a < weight \\<Gamma> a\""], ["proof (prove)\nusing this:\n  \\<not> weight \\<Gamma> a \\<le> d_OUT (plus_current (F f) k) a\n\ngoal (1 subgoal):\n 1. d_OUT (plus_current (F f) k) a < weight \\<Gamma> a", "by simp"], ["proof (state)\nthis:\n  d_OUT (plus_current (F f) k) a < weight \\<Gamma> a\n\ngoal (1 subgoal):\n 1. \\<not> weight \\<Gamma> a\n           \\<le> d_OUT (plus_current (F f) k) a \\<Longrightarrow>\n    False", "define \\<Omega> where \"\\<Omega> = \\<Gamma> \\<ominus> F f \\<ominus> k\""], ["proof (state)\nthis:\n  \\<Omega> = \\<Gamma> \\<ominus> F f \\<ominus> k\n\ngoal (1 subgoal):\n 1. \\<not> weight \\<Gamma> a\n           \\<le> d_OUT (plus_current (F f) k) a \\<Longrightarrow>\n    False", "have B_\\<Omega> [simp]: \"B \\<Omega> = B \\<Gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B \\<Omega> = B \\<Gamma>", "by(simp add: \\<Omega>_def)"], ["proof (state)\nthis:\n  B \\<Omega> = B \\<Gamma>\n\ngoal (1 subgoal):\n 1. \\<not> weight \\<Gamma> a\n           \\<le> d_OUT (plus_current (F f) k) a \\<Longrightarrow>\n    False", "have loose: \"loose \\<Omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. loose \\<Omega>", "unfolding \\<Omega>_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. loose (\\<Gamma> \\<ominus> F f \\<ominus> k)", "using unhindered k k_w maximal"], ["proof (prove)\nusing this:\n  \\<not> hindered (\\<Gamma> \\<ominus> F f)\n  current (\\<Gamma> \\<ominus> F f) k\n  wave (\\<Gamma> \\<ominus> F f) k\n  \\<lbrakk>current (\\<Gamma> \\<ominus> F f) ?k';\n   wave (\\<Gamma> \\<ominus> F f) ?k'; k \\<le> ?k'\\<rbrakk>\n  \\<Longrightarrow> k = ?k'\n\ngoal (1 subgoal):\n 1. loose (\\<Gamma> \\<ominus> F f \\<ominus> k)", "by(rule \\<Gamma>.loose_minus_web)"], ["proof (state)\nthis:\n  loose \\<Omega>\n\ngoal (1 subgoal):\n 1. \\<not> weight \\<Gamma> a\n           \\<le> d_OUT (plus_current (F f) k) a \\<Longrightarrow>\n    False", "interpret \\<Omega>: countable_bipartite_web \\<Omega>"], ["proof (prove)\ngoal (1 subgoal):\n 1. countable_bipartite_web \\<Omega>", "using k"], ["proof (prove)\nusing this:\n  current (\\<Gamma> \\<ominus> F f) k\n\ngoal (1 subgoal):\n 1. countable_bipartite_web \\<Omega>", "unfolding \\<Omega>_def"], ["proof (prove)\nusing this:\n  current (\\<Gamma> \\<ominus> F f) k\n\ngoal (1 subgoal):\n 1. countable_bipartite_web (\\<Gamma> \\<ominus> F f \\<ominus> k)", "by(rule \\<Gamma>.countable_bipartite_web_minus_web)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> weight \\<Gamma> a\n           \\<le> d_OUT (plus_current (F f) k) a \\<Longrightarrow>\n    False", "have a_\\<E>: \"a \\<in> TER\\<^bsub>\\<Gamma> \\<ominus> F f\\<^esub> k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<in> TER\\<^bsub>\\<Gamma> \\<ominus> F f\\<^esub> k", "using Field k k_w less"], ["proof (prove)\nusing this:\n  f \\<in> Field leq\n  current (\\<Gamma> \\<ominus> F f) k\n  wave (\\<Gamma> \\<ominus> F f) k\n  d_OUT (plus_current (F f) k) a < weight \\<Gamma> a\n\ngoal (1 subgoal):\n 1. a \\<in> TER\\<^bsub>\\<Gamma> \\<ominus> F f\\<^esub> k", "by(rule a_TER)"], ["proof (state)\nthis:\n  a \\<in> TER\\<^bsub>\\<Gamma> \\<ominus> F f\\<^esub> k\n\ngoal (1 subgoal):\n 1. \\<not> weight \\<Gamma> a\n           \\<le> d_OUT (plus_current (F f) k) a \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  a \\<in> TER\\<^bsub>\\<Gamma> \\<ominus> F f\\<^esub> k", "have \"weight \\<Omega> a = weight \\<Gamma> a - d_OUT (F f) a\""], ["proof (prove)\nusing this:\n  a \\<in> TER\\<^bsub>\\<Gamma> \\<ominus> F f\\<^esub> k\n\ngoal (1 subgoal):\n 1. weight \\<Omega> a = weight \\<Gamma> a - d_OUT (F f) a", "using a disjoint"], ["proof (prove)\nusing this:\n  a \\<in> TER\\<^bsub>\\<Gamma> \\<ominus> F f\\<^esub> k\n  a \\<in> A \\<Gamma>\n  A \\<Gamma> \\<inter> B \\<Gamma> = {}\n\ngoal (1 subgoal):\n 1. weight \\<Omega> a = weight \\<Gamma> a - d_OUT (F f) a", "by(auto simp add: roofed_circ_def \\<Omega>_def SINK.simps)"], ["proof (state)\nthis:\n  weight \\<Omega> a = weight \\<Gamma> a - d_OUT (F f) a\n\ngoal (1 subgoal):\n 1. \\<not> weight \\<Gamma> a\n           \\<le> d_OUT (plus_current (F f) k) a \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  weight \\<Omega> a = weight \\<Gamma> a - d_OUT (F f) a", "have weight_a: \"0 < weight \\<Omega> a\""], ["proof (prove)\nusing this:\n  weight \\<Omega> a = weight \\<Gamma> a - d_OUT (F f) a\n\ngoal (1 subgoal):\n 1. 0 < weight \\<Omega> a", "using less a_\\<E>"], ["proof (prove)\nusing this:\n  weight \\<Omega> a = weight \\<Gamma> a - d_OUT (F f) a\n  d_OUT (plus_current (F f) k) a < weight \\<Gamma> a\n  a \\<in> TER\\<^bsub>\\<Gamma> \\<ominus> F f\\<^esub> k\n\ngoal (1 subgoal):\n 1. 0 < weight \\<Omega> a", "by(simp add: OUT_fk SINK.simps diff_gr0_ennreal)"], ["proof (state)\nthis:\n  0 < weight \\<Omega> a\n\ngoal (1 subgoal):\n 1. \\<not> weight \\<Gamma> a\n           \\<le> d_OUT (plus_current (F f) k) a \\<Longrightarrow>\n    False", "let ?P_y = \"\\<lambda>y. y \\<in> \\<^bold>O\\<^bold>U\\<^bold>T\\<^bsub>\\<Omega>\\<^esub> a \\<and> weight \\<Omega> y > 0\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> weight \\<Gamma> a\n           \\<le> d_OUT (plus_current (F f) k) a \\<Longrightarrow>\n    False", "define y where \"y = Eps ?P_y\""], ["proof (state)\nthis:\n  y =\n  (SOME y.\n      y \\<in> \\<^bold>O\\<^bold>U\\<^bold>T\\<^bsub>\\<Omega>\\<^esub> a \\<and>\n      0 < weight \\<Omega> y)\n\ngoal (1 subgoal):\n 1. \\<not> weight \\<Gamma> a\n           \\<le> d_OUT (plus_current (F f) k) a \\<Longrightarrow>\n    False", "have \"Ex ?P_y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>y.\n       y \\<in> \\<^bold>O\\<^bold>U\\<^bold>T\\<^bsub>\\<Omega>\\<^esub> a \\<and>\n       0 < weight \\<Omega> y", "using Field k k_w less"], ["proof (prove)\nusing this:\n  f \\<in> Field leq\n  current (\\<Gamma> \\<ominus> F f) k\n  wave (\\<Gamma> \\<ominus> F f) k\n  d_OUT (plus_current (F f) k) a < weight \\<Gamma> a\n\ngoal (1 subgoal):\n 1. \\<exists>y.\n       y \\<in> \\<^bold>O\\<^bold>U\\<^bold>T\\<^bsub>\\<Omega>\\<^esub> a \\<and>\n       0 < weight \\<Omega> y", "unfolding \\<Omega>_def"], ["proof (prove)\nusing this:\n  f \\<in> Field leq\n  current (\\<Gamma> \\<ominus> F f) k\n  wave (\\<Gamma> \\<ominus> F f) k\n  d_OUT (plus_current (F f) k) a < weight \\<Gamma> a\n\ngoal (1 subgoal):\n 1. \\<exists>y.\n       y \\<in> \\<^bold>O\\<^bold>U\\<^bold>T\\<^bsub>\\<Gamma> \\<ominus> F f \\<ominus> k\\<^esub>\n                a \\<and>\n       0 < weight (\\<Gamma> \\<ominus> F f \\<ominus> k) y", "by(rule Ex_y)"], ["proof (state)\nthis:\n  \\<exists>y.\n     y \\<in> \\<^bold>O\\<^bold>U\\<^bold>T\\<^bsub>\\<Omega>\\<^esub> a \\<and>\n     0 < weight \\<Omega> y\n\ngoal (1 subgoal):\n 1. \\<not> weight \\<Gamma> a\n           \\<le> d_OUT (plus_current (F f) k) a \\<Longrightarrow>\n    False", "hence \"?P_y y\""], ["proof (prove)\nusing this:\n  \\<exists>y.\n     y \\<in> \\<^bold>O\\<^bold>U\\<^bold>T\\<^bsub>\\<Omega>\\<^esub> a \\<and>\n     0 < weight \\<Omega> y\n\ngoal (1 subgoal):\n 1. y \\<in> \\<^bold>O\\<^bold>U\\<^bold>T\\<^bsub>\\<Omega>\\<^esub> a \\<and>\n    0 < weight \\<Omega> y", "unfolding y_def"], ["proof (prove)\nusing this:\n  \\<exists>y.\n     y \\<in> \\<^bold>O\\<^bold>U\\<^bold>T\\<^bsub>\\<Omega>\\<^esub> a \\<and>\n     0 < weight \\<Omega> y\n\ngoal (1 subgoal):\n 1. (SOME y.\n        y \\<in> \\<^bold>O\\<^bold>U\\<^bold>T\\<^bsub>\\<Omega>\\<^esub> a \\<and>\n        0 < weight \\<Omega> y)\n    \\<in> \\<^bold>O\\<^bold>U\\<^bold>T\\<^bsub>\\<Omega>\\<^esub> a \\<and>\n    0 < weight \\<Omega>\n         (SOME y.\n             y \\<in> \\<^bold>O\\<^bold>U\\<^bold>T\\<^bsub>\\<Omega>\\<^esub>\n                      a \\<and>\n             0 < weight \\<Omega> y)", "by(rule someI_ex)"], ["proof (state)\nthis:\n  y \\<in> \\<^bold>O\\<^bold>U\\<^bold>T\\<^bsub>\\<Omega>\\<^esub> a \\<and>\n  0 < weight \\<Omega> y\n\ngoal (1 subgoal):\n 1. \\<not> weight \\<Gamma> a\n           \\<le> d_OUT (plus_current (F f) k) a \\<Longrightarrow>\n    False", "hence \"y \\<in> \\<^bold>O\\<^bold>U\\<^bold>T\\<^bsub>\\<Omega>\\<^esub> a\" and weight_y: \"weight \\<Omega> y > 0\""], ["proof (prove)\nusing this:\n  y \\<in> \\<^bold>O\\<^bold>U\\<^bold>T\\<^bsub>\\<Omega>\\<^esub> a \\<and>\n  0 < weight \\<Omega> y\n\ngoal (1 subgoal):\n 1. y \\<in> \\<^bold>O\\<^bold>U\\<^bold>T\\<^bsub>\\<Omega>\\<^esub> a &&&\n    0 < weight \\<Omega> y", "by blast+"], ["proof (state)\nthis:\n  y \\<in> \\<^bold>O\\<^bold>U\\<^bold>T\\<^bsub>\\<Omega>\\<^esub> a\n  0 < weight \\<Omega> y\n\ngoal (1 subgoal):\n 1. \\<not> weight \\<Gamma> a\n           \\<le> d_OUT (plus_current (F f) k) a \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  y \\<in> \\<^bold>O\\<^bold>U\\<^bold>T\\<^bsub>\\<Omega>\\<^esub> a\n  0 < weight \\<Omega> y", "have y_B: \"y \\<in> B \\<Omega>\""], ["proof (prove)\nusing this:\n  y \\<in> \\<^bold>O\\<^bold>U\\<^bold>T\\<^bsub>\\<Omega>\\<^esub> a\n  0 < weight \\<Omega> y\n\ngoal (1 subgoal):\n 1. y \\<in> B \\<Omega>", "by(auto simp add: outgoing_def \\<Omega>_def dest: bipartite_E)"], ["proof (state)\nthis:\n  y \\<in> B \\<Omega>\n\ngoal (1 subgoal):\n 1. \\<not> weight \\<Gamma> a\n           \\<le> d_OUT (plus_current (F f) k) a \\<Longrightarrow>\n    False", "define bound where \"bound = enn2real (min (weight \\<Omega> a) (weight \\<Omega> y))\""], ["proof (state)\nthis:\n  bound = enn2real (min (weight \\<Omega> a) (weight \\<Omega> y))\n\ngoal (1 subgoal):\n 1. \\<not> weight \\<Gamma> a\n           \\<le> d_OUT (plus_current (F f) k) a \\<Longrightarrow>\n    False", "have bound_pos: \"bound > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < bound", "using weight_y weight_a \\<Omega>.weight_finite"], ["proof (prove)\nusing this:\n  0 < weight \\<Omega> y\n  0 < weight \\<Omega> a\n  weight \\<Omega> ?x \\<noteq> \\<top>\n\ngoal (1 subgoal):\n 1. 0 < bound", "by(cases \"weight \\<Omega> a\" \"weight \\<Omega> y\" rule: ennreal2_cases)\n        (simp_all add: bound_def min_def split: if_split_asm)"], ["proof (state)\nthis:\n  0 < bound\n\ngoal (1 subgoal):\n 1. \\<not> weight \\<Gamma> a\n           \\<le> d_OUT (plus_current (F f) k) a \\<Longrightarrow>\n    False", "let ?P_\\<delta> = \"\\<lambda>\\<delta>. \\<delta> > 0 \\<and> \\<delta> < bound \\<and> \\<not> hindered (reduce_weight \\<Omega> y \\<delta>)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> weight \\<Gamma> a\n           \\<le> d_OUT (plus_current (F f) k) a \\<Longrightarrow>\n    False", "define \\<delta> where \"\\<delta> = Eps ?P_\\<delta>\""], ["proof (state)\nthis:\n  \\<delta> =\n  (SOME \\<delta>.\n      0 < \\<delta> \\<and>\n      \\<delta> < bound \\<and>\n      \\<not> hindered (reduce_weight \\<Omega> y \\<delta>))\n\ngoal (1 subgoal):\n 1. \\<not> weight \\<Gamma> a\n           \\<le> d_OUT (plus_current (F f) k) a \\<Longrightarrow>\n    False", "from \\<Omega>.unhinder[OF loose _ weight_y bound_pos] y_B disjoint"], ["proof (chain)\npicking this:\n  y \\<in> B \\<Omega> \\<Longrightarrow>\n  \\<exists>\\<epsilon>>0.\n     \\<epsilon> < bound \\<and>\n     \\<not> hindered (reduce_weight \\<Omega> y \\<epsilon>)\n  y \\<in> B \\<Omega>\n  A \\<Gamma> \\<inter> B \\<Gamma> = {}", "have \"Ex ?P_\\<delta>\""], ["proof (prove)\nusing this:\n  y \\<in> B \\<Omega> \\<Longrightarrow>\n  \\<exists>\\<epsilon>>0.\n     \\<epsilon> < bound \\<and>\n     \\<not> hindered (reduce_weight \\<Omega> y \\<epsilon>)\n  y \\<in> B \\<Omega>\n  A \\<Gamma> \\<inter> B \\<Gamma> = {}\n\ngoal (1 subgoal):\n 1. \\<exists>\\<delta>>0.\n       \\<delta> < bound \\<and>\n       \\<not> hindered (reduce_weight \\<Omega> y \\<delta>)", "by(auto simp add: \\<Omega>_def)"], ["proof (state)\nthis:\n  \\<exists>\\<delta>>0.\n     \\<delta> < bound \\<and>\n     \\<not> hindered (reduce_weight \\<Omega> y \\<delta>)\n\ngoal (1 subgoal):\n 1. \\<not> weight \\<Gamma> a\n           \\<le> d_OUT (plus_current (F f) k) a \\<Longrightarrow>\n    False", "hence \"?P_\\<delta> \\<delta>\""], ["proof (prove)\nusing this:\n  \\<exists>\\<delta>>0.\n     \\<delta> < bound \\<and>\n     \\<not> hindered (reduce_weight \\<Omega> y \\<delta>)\n\ngoal (1 subgoal):\n 1. 0 < \\<delta> \\<and>\n    \\<delta> < bound \\<and>\n    \\<not> hindered (reduce_weight \\<Omega> y \\<delta>)", "unfolding \\<delta>_def"], ["proof (prove)\nusing this:\n  \\<exists>\\<delta>>0.\n     \\<delta> < bound \\<and>\n     \\<not> hindered (reduce_weight \\<Omega> y \\<delta>)\n\ngoal (1 subgoal):\n 1. 0 < (SOME \\<delta>.\n            0 < \\<delta> \\<and>\n            \\<delta> < bound \\<and>\n            \\<not> hindered (reduce_weight \\<Omega> y \\<delta>)) \\<and>\n    (SOME \\<delta>.\n        0 < \\<delta> \\<and>\n        \\<delta> < bound \\<and>\n        \\<not> hindered (reduce_weight \\<Omega> y \\<delta>))\n    < bound \\<and>\n    \\<not> hindered\n            (reduce_weight \\<Omega> y\n              (SOME \\<delta>.\n                  0 < \\<delta> \\<and>\n                  \\<delta> < bound \\<and>\n                  \\<not> hindered (reduce_weight \\<Omega> y \\<delta>)))", "by(rule someI_ex)"], ["proof (state)\nthis:\n  0 < \\<delta> \\<and>\n  \\<delta> < bound \\<and>\n  \\<not> hindered (reduce_weight \\<Omega> y \\<delta>)\n\ngoal (1 subgoal):\n 1. \\<not> weight \\<Gamma> a\n           \\<le> d_OUT (plus_current (F f) k) a \\<Longrightarrow>\n    False", "hence \\<delta>_pos: \"0 < \\<delta>\""], ["proof (prove)\nusing this:\n  0 < \\<delta> \\<and>\n  \\<delta> < bound \\<and>\n  \\<not> hindered (reduce_weight \\<Omega> y \\<delta>)\n\ngoal (1 subgoal):\n 1. 0 < \\<delta>", "by blast+"], ["proof (state)\nthis:\n  0 < \\<delta>\n\ngoal (1 subgoal):\n 1. \\<not> weight \\<Gamma> a\n           \\<le> d_OUT (plus_current (F f) k) a \\<Longrightarrow>\n    False", "let ?f' = \"(plus_current (fst f) (zero_current((a, y) := \\<delta>)), plus_current (snd f) k)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> weight \\<Gamma> a\n           \\<le> d_OUT (plus_current (F f) k) a \\<Longrightarrow>\n    False", "have sat: \"?f' = sat f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (plus_current (fst f) ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>)),\n     plus_current (snd f) k) =\n    sat f", "using less"], ["proof (prove)\nusing this:\n  d_OUT (plus_current (F f) k) a < weight \\<Gamma> a\n\ngoal (1 subgoal):\n 1. (plus_current (fst f) ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>)),\n     plus_current (snd f) k) =\n    sat f", "by(simp add: sat_def k_def \\<Omega>_def Let_def y_def bound_def \\<delta>_def split_def)"], ["proof (state)\nthis:\n  (plus_current (fst f) ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>)),\n   plus_current (snd f) k) =\n  sat f\n\ngoal (1 subgoal):\n 1. \\<not> weight \\<Gamma> a\n           \\<le> d_OUT (plus_current (F f) k) a \\<Longrightarrow>\n    False", "also"], ["proof (state)\nthis:\n  (plus_current (fst f) ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>)),\n   plus_current (snd f) k) =\n  sat f\n\ngoal (1 subgoal):\n 1. \\<not> weight \\<Gamma> a\n           \\<le> d_OUT (plus_current (F f) k) a \\<Longrightarrow>\n    False", "have \"\\<dots> = f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sat f = f", "unfolding f_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. sat (fixp_above (\\<lambda>_. 0, \\<lambda>_. 0)) =\n    fixp_above (\\<lambda>_. 0, \\<lambda>_. 0)", "using fixp_above_unfold[OF zero]"], ["proof (prove)\nusing this:\n  fixp_above (\\<lambda>_. 0, \\<lambda>_. 0) =\n  sat (fixp_above (\\<lambda>_. 0, \\<lambda>_. 0))\n\ngoal (1 subgoal):\n 1. sat (fixp_above (\\<lambda>_. 0, \\<lambda>_. 0)) =\n    fixp_above (\\<lambda>_. 0, \\<lambda>_. 0)", "by simp"], ["proof (state)\nthis:\n  sat f = f\n\ngoal (1 subgoal):\n 1. \\<not> weight \\<Gamma> a\n           \\<le> d_OUT (plus_current (F f) k) a \\<Longrightarrow>\n    False", "finally"], ["proof (chain)\npicking this:\n  (plus_current (fst f) ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>)),\n   plus_current (snd f) k) =\n  f", "have \"fst ?f' (a, y) = fst f (a, y)\""], ["proof (prove)\nusing this:\n  (plus_current (fst f) ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>)),\n   plus_current (snd f) k) =\n  f\n\ngoal (1 subgoal):\n 1. fst (plus_current (fst f) ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>)),\n         plus_current (snd f) k)\n     (a, y) =\n    fst f (a, y)", "by simp"], ["proof (state)\nthis:\n  fst (plus_current (fst f) ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>)),\n       plus_current (snd f) k)\n   (a, y) =\n  fst f (a, y)\n\ngoal (1 subgoal):\n 1. \\<not> weight \\<Gamma> a\n           \\<le> d_OUT (plus_current (F f) k) a \\<Longrightarrow>\n    False", "hence \"\\<delta> = 0\""], ["proof (prove)\nusing this:\n  fst (plus_current (fst f) ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>)),\n       plus_current (snd f) k)\n   (a, y) =\n  fst f (a, y)\n\ngoal (1 subgoal):\n 1. \\<delta> = 0", "using currentD_finite[OF \\<epsilon>_curr[OF Field']] \\<delta>_pos"], ["proof (prove)\nusing this:\n  fst (plus_current (fst f) ((\\<lambda>_. 0)((a, y) := ennreal \\<delta>)),\n       plus_current (snd f) k)\n   (a, y) =\n  fst f (a, y)\n  fst f ?e \\<noteq> \\<top>\n  0 < \\<delta>\n\ngoal (1 subgoal):\n 1. \\<delta> = 0", "by(cases \"fst f (a, y)\") simp_all"], ["proof (state)\nthis:\n  \\<delta> = 0\n\ngoal (1 subgoal):\n 1. \\<not> weight \\<Gamma> a\n           \\<le> d_OUT (plus_current (F f) k) a \\<Longrightarrow>\n    False", "with \\<delta>_pos"], ["proof (chain)\npicking this:\n  0 < \\<delta>\n  \\<delta> = 0", "show False"], ["proof (prove)\nusing this:\n  0 < \\<delta>\n  \\<delta> = 0\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  weight \\<Gamma> a \\<le> d_OUT (plus_current (F f) k) a\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       current \\<Gamma> f \\<and>\n       d_OUT f a = weight \\<Gamma> a \\<and>\n       \\<not> hindered (\\<Gamma> \\<ominus> f)", "with currentD_weight_OUT[OF fk, of a]"], ["proof (chain)\npicking this:\n  d_OUT (plus_current (F f) k) a \\<le> weight \\<Gamma> a\n  weight \\<Gamma> a \\<le> d_OUT (plus_current (F f) k) a", "have \"d_OUT ?fk a = weight \\<Gamma> a\""], ["proof (prove)\nusing this:\n  d_OUT (plus_current (F f) k) a \\<le> weight \\<Gamma> a\n  weight \\<Gamma> a \\<le> d_OUT (plus_current (F f) k) a\n\ngoal (1 subgoal):\n 1. d_OUT (plus_current (F f) k) a = weight \\<Gamma> a", "by simp"], ["proof (state)\nthis:\n  d_OUT (plus_current (F f) k) a = weight \\<Gamma> a\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       current \\<Gamma> f \\<and>\n       d_OUT f a = weight \\<Gamma> a \\<and>\n       \\<not> hindered (\\<Gamma> \\<ominus> f)", "moreover"], ["proof (state)\nthis:\n  d_OUT (plus_current (F f) k) a = weight \\<Gamma> a\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       current \\<Gamma> f \\<and>\n       d_OUT f a = weight \\<Gamma> a \\<and>\n       \\<not> hindered (\\<Gamma> \\<ominus> f)", "have \"current \\<Gamma> ?fk\""], ["proof (prove)\ngoal (1 subgoal):\n 1. current \\<Gamma> (plus_current (F f) k)", "using f k"], ["proof (prove)\nusing this:\n  current \\<Gamma> (F f)\n  current (\\<Gamma> \\<ominus> F f) k\n\ngoal (1 subgoal):\n 1. current \\<Gamma> (plus_current (F f) k)", "by(rule current_plus_current_minus)"], ["proof (state)\nthis:\n  current \\<Gamma> (plus_current (F f) k)\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       current \\<Gamma> f \\<and>\n       d_OUT f a = weight \\<Gamma> a \\<and>\n       \\<not> hindered (\\<Gamma> \\<ominus> f)", "moreover"], ["proof (state)\nthis:\n  current \\<Gamma> (plus_current (F f) k)\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       current \\<Gamma> f \\<and>\n       d_OUT f a = weight \\<Gamma> a \\<and>\n       \\<not> hindered (\\<Gamma> \\<ominus> f)", "have \"\\<not> hindered (\\<Gamma> \\<ominus> ?fk)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> hindered (\\<Gamma> \\<ominus> plus_current (F f) k)", "unfolding minus_plus_current[OF f k]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> hindered (\\<Gamma> \\<ominus> F f \\<ominus> k)", "using unhindered k k_w"], ["proof (prove)\nusing this:\n  \\<not> hindered (\\<Gamma> \\<ominus> F f)\n  current (\\<Gamma> \\<ominus> F f) k\n  wave (\\<Gamma> \\<ominus> F f) k\n\ngoal (1 subgoal):\n 1. \\<not> hindered (\\<Gamma> \\<ominus> F f \\<ominus> k)", "by(rule \\<Gamma>.unhindered_minus_web)"], ["proof (state)\nthis:\n  \\<not> hindered (\\<Gamma> \\<ominus> plus_current (F f) k)\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       current \\<Gamma> f \\<and>\n       d_OUT f a = weight \\<Gamma> a \\<and>\n       \\<not> hindered (\\<Gamma> \\<ominus> f)", "ultimately"], ["proof (chain)\npicking this:\n  d_OUT (plus_current (F f) k) a = weight \\<Gamma> a\n  current \\<Gamma> (plus_current (F f) k)\n  \\<not> hindered (\\<Gamma> \\<ominus> plus_current (F f) k)", "show ?thesis"], ["proof (prove)\nusing this:\n  d_OUT (plus_current (F f) k) a = weight \\<Gamma> a\n  current \\<Gamma> (plus_current (F f) k)\n  \\<not> hindered (\\<Gamma> \\<ominus> plus_current (F f) k)\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       current \\<Gamma> f \\<and>\n       d_OUT f a = weight \\<Gamma> a \\<and>\n       \\<not> hindered (\\<Gamma> \\<ominus> f)", "by blast"], ["proof (state)\nthis:\n  \\<exists>f.\n     current \\<Gamma> f \\<and>\n     d_OUT f a = weight \\<Gamma> a \\<and>\n     \\<not> hindered (\\<Gamma> \\<ominus> f)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "subsection \\<open>Linkability of unhindered bipartite webs\\<close>"], ["", "context countable_bipartite_web begin"], ["", "theorem unhindered_linkable:\n  assumes unhindered: \"\\<not> hindered \\<Gamma>\"\n  shows \"linkable \\<Gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. linkable \\<Gamma>", "proof(cases \"A \\<Gamma> = {}\")"], ["proof (state)\ngoal (2 subgoals):\n 1. A \\<Gamma> = {} \\<Longrightarrow> linkable \\<Gamma>\n 2. A \\<Gamma> \\<noteq> {} \\<Longrightarrow> linkable \\<Gamma>", "case True"], ["proof (state)\nthis:\n  A \\<Gamma> = {}\n\ngoal (2 subgoals):\n 1. A \\<Gamma> = {} \\<Longrightarrow> linkable \\<Gamma>\n 2. A \\<Gamma> \\<noteq> {} \\<Longrightarrow> linkable \\<Gamma>", "thus ?thesis"], ["proof (prove)\nusing this:\n  A \\<Gamma> = {}\n\ngoal (1 subgoal):\n 1. linkable \\<Gamma>", "by(auto intro!: exI[where x=\"zero_current\"] linkage.intros simp add: web_flow_iff )"], ["proof (state)\nthis:\n  linkable \\<Gamma>\n\ngoal (1 subgoal):\n 1. A \\<Gamma> \\<noteq> {} \\<Longrightarrow> linkable \\<Gamma>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. A \\<Gamma> \\<noteq> {} \\<Longrightarrow> linkable \\<Gamma>", "case nempty: False"], ["proof (state)\nthis:\n  A \\<Gamma> \\<noteq> {}\n\ngoal (1 subgoal):\n 1. A \\<Gamma> \\<noteq> {} \\<Longrightarrow> linkable \\<Gamma>", "let ?P = \"\\<lambda>f a f'. current (\\<Gamma> \\<ominus> f) f' \\<and> d_OUT f' a = weight (\\<Gamma> \\<ominus> f) a \\<and> \\<not> hindered (\\<Gamma> \\<ominus> f \\<ominus> f')\""], ["proof (state)\ngoal (1 subgoal):\n 1. A \\<Gamma> \\<noteq> {} \\<Longrightarrow> linkable \\<Gamma>", "define enum where \"enum = from_nat_into (A \\<Gamma>)\""], ["proof (state)\nthis:\n  enum = from_nat_into (A \\<Gamma>)\n\ngoal (1 subgoal):\n 1. A \\<Gamma> \\<noteq> {} \\<Longrightarrow> linkable \\<Gamma>", "have enum_A: \"enum n \\<in> A \\<Gamma>\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. enum n \\<in> A \\<Gamma>", "using from_nat_into[OF nempty, of n]"], ["proof (prove)\nusing this:\n  from_nat_into (A \\<Gamma>) n \\<in> A \\<Gamma>\n\ngoal (1 subgoal):\n 1. enum n \\<in> A \\<Gamma>", "by(simp add: enum_def)"], ["proof (state)\nthis:\n  enum ?n \\<in> A \\<Gamma>\n\ngoal (1 subgoal):\n 1. A \\<Gamma> \\<noteq> {} \\<Longrightarrow> linkable \\<Gamma>", "have vertex_enum [simp]: \"vertex \\<Gamma> (enum n)\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. vertex \\<Gamma> (enum n)", "using enum_A[of n] A_vertex"], ["proof (prove)\nusing this:\n  enum n \\<in> A \\<Gamma>\n  A \\<Gamma> \\<subseteq> \\<^bold>V\n\ngoal (1 subgoal):\n 1. vertex \\<Gamma> (enum n)", "by blast"], ["proof (state)\nthis:\n  vertex \\<Gamma> (enum ?n)\n\ngoal (1 subgoal):\n 1. A \\<Gamma> \\<noteq> {} \\<Longrightarrow> linkable \\<Gamma>", "define f where \"f = rec_nat zero_current (\\<lambda>n f. let f' = SOME f'. ?P f (enum n) f' in plus_current f f')\""], ["proof (state)\nthis:\n  f =\n  rec_nat (\\<lambda>_. 0)\n   (\\<lambda>n f.\n       Let (SOME f'.\n               current (\\<Gamma> \\<ominus> f) f' \\<and>\n               d_OUT f' (enum n) =\n               weight (\\<Gamma> \\<ominus> f) (enum n) \\<and>\n               \\<not> hindered (\\<Gamma> \\<ominus> f \\<ominus> f'))\n        (plus_current f))\n\ngoal (1 subgoal):\n 1. A \\<Gamma> \\<noteq> {} \\<Longrightarrow> linkable \\<Gamma>", "have f_0 [simp]: \"f 0 = zero_current\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f 0 = (\\<lambda>_. 0)", "by(simp add: f_def)"], ["proof (state)\nthis:\n  f 0 = (\\<lambda>_. 0)\n\ngoal (1 subgoal):\n 1. A \\<Gamma> \\<noteq> {} \\<Longrightarrow> linkable \\<Gamma>", "have f_Suc: \"f (Suc n) = plus_current (f n) (Eps (?P (f n) (enum n)))\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. f (Suc n) =\n    plus_current (f n)\n     (SOME f'.\n         current (\\<Gamma> \\<ominus> f n) f' \\<and>\n         d_OUT f' (enum n) = weight (\\<Gamma> \\<ominus> f n) (enum n) \\<and>\n         \\<not> hindered (\\<Gamma> \\<ominus> f n \\<ominus> f'))", "by(simp add: f_def)"], ["proof (state)\nthis:\n  f (Suc ?n) =\n  plus_current (f ?n)\n   (SOME f'.\n       current (\\<Gamma> \\<ominus> f ?n) f' \\<and>\n       d_OUT f' (enum ?n) =\n       weight (\\<Gamma> \\<ominus> f ?n) (enum ?n) \\<and>\n       \\<not> hindered (\\<Gamma> \\<ominus> f ?n \\<ominus> f'))\n\ngoal (1 subgoal):\n 1. A \\<Gamma> \\<noteq> {} \\<Longrightarrow> linkable \\<Gamma>", "have f: \"current \\<Gamma> (f n)\"\n    and sat: \"\\<And>m. m < n \\<Longrightarrow> d_OUT (f n) (enum m) = weight \\<Gamma> (enum m)\"\n    and unhindered: \"\\<not> hindered (\\<Gamma> \\<ominus> f n)\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. current \\<Gamma> (f n) &&&\n    (\\<And>m.\n        m < n \\<Longrightarrow>\n        d_OUT (f n) (enum m) = weight \\<Gamma> (enum m)) &&&\n    \\<not> hindered (\\<Gamma> \\<ominus> f n)", "proof(induction n)"], ["proof (state)\ngoal (6 subgoals):\n 1. current \\<Gamma> (f 0)\n 2. \\<And>m.\n       m < 0 \\<Longrightarrow>\n       d_OUT (f 0) (enum m) = weight \\<Gamma> (enum m)\n 3. \\<not> hindered (\\<Gamma> \\<ominus> f 0)\n 4. \\<And>n.\n       \\<lbrakk>current \\<Gamma> (f n);\n        \\<And>m.\n           m < n \\<Longrightarrow>\n           d_OUT (f n) (enum m) = weight \\<Gamma> (enum m);\n        \\<not> hindered (\\<Gamma> \\<ominus> f n)\\<rbrakk>\n       \\<Longrightarrow> current \\<Gamma> (f (Suc n))\n 5. \\<And>n m.\n       \\<lbrakk>current \\<Gamma> (f n);\n        \\<And>m.\n           m < n \\<Longrightarrow>\n           d_OUT (f n) (enum m) = weight \\<Gamma> (enum m);\n        \\<not> hindered (\\<Gamma> \\<ominus> f n); m < Suc n\\<rbrakk>\n       \\<Longrightarrow> d_OUT (f (Suc n)) (enum m) =\n                         weight \\<Gamma> (enum m)\n 6. \\<And>n.\n       \\<lbrakk>current \\<Gamma> (f n);\n        \\<And>m.\n           m < n \\<Longrightarrow>\n           d_OUT (f n) (enum m) = weight \\<Gamma> (enum m);\n        \\<not> hindered (\\<Gamma> \\<ominus> f n)\\<rbrakk>\n       \\<Longrightarrow> \\<not> hindered (\\<Gamma> \\<ominus> f (Suc n))", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (6 subgoals):\n 1. current \\<Gamma> (f 0)\n 2. \\<And>m.\n       m < 0 \\<Longrightarrow>\n       d_OUT (f 0) (enum m) = weight \\<Gamma> (enum m)\n 3. \\<not> hindered (\\<Gamma> \\<ominus> f 0)\n 4. \\<And>n.\n       \\<lbrakk>current \\<Gamma> (f n);\n        \\<And>m.\n           m < n \\<Longrightarrow>\n           d_OUT (f n) (enum m) = weight \\<Gamma> (enum m);\n        \\<not> hindered (\\<Gamma> \\<ominus> f n)\\<rbrakk>\n       \\<Longrightarrow> current \\<Gamma> (f (Suc n))\n 5. \\<And>n m.\n       \\<lbrakk>current \\<Gamma> (f n);\n        \\<And>m.\n           m < n \\<Longrightarrow>\n           d_OUT (f n) (enum m) = weight \\<Gamma> (enum m);\n        \\<not> hindered (\\<Gamma> \\<ominus> f n); m < Suc n\\<rbrakk>\n       \\<Longrightarrow> d_OUT (f (Suc n)) (enum m) =\n                         weight \\<Gamma> (enum m)\n 6. \\<And>n.\n       \\<lbrakk>current \\<Gamma> (f n);\n        \\<And>m.\n           m < n \\<Longrightarrow>\n           d_OUT (f n) (enum m) = weight \\<Gamma> (enum m);\n        \\<not> hindered (\\<Gamma> \\<ominus> f n)\\<rbrakk>\n       \\<Longrightarrow> \\<not> hindered (\\<Gamma> \\<ominus> f (Suc n))", "{"], ["proof (state)\nthis:\n  \n\ngoal (6 subgoals):\n 1. current \\<Gamma> (f 0)\n 2. \\<And>m.\n       m < 0 \\<Longrightarrow>\n       d_OUT (f 0) (enum m) = weight \\<Gamma> (enum m)\n 3. \\<not> hindered (\\<Gamma> \\<ominus> f 0)\n 4. \\<And>n.\n       \\<lbrakk>current \\<Gamma> (f n);\n        \\<And>m.\n           m < n \\<Longrightarrow>\n           d_OUT (f n) (enum m) = weight \\<Gamma> (enum m);\n        \\<not> hindered (\\<Gamma> \\<ominus> f n)\\<rbrakk>\n       \\<Longrightarrow> current \\<Gamma> (f (Suc n))\n 5. \\<And>n m.\n       \\<lbrakk>current \\<Gamma> (f n);\n        \\<And>m.\n           m < n \\<Longrightarrow>\n           d_OUT (f n) (enum m) = weight \\<Gamma> (enum m);\n        \\<not> hindered (\\<Gamma> \\<ominus> f n); m < Suc n\\<rbrakk>\n       \\<Longrightarrow> d_OUT (f (Suc n)) (enum m) =\n                         weight \\<Gamma> (enum m)\n 6. \\<And>n.\n       \\<lbrakk>current \\<Gamma> (f n);\n        \\<And>m.\n           m < n \\<Longrightarrow>\n           d_OUT (f n) (enum m) = weight \\<Gamma> (enum m);\n        \\<not> hindered (\\<Gamma> \\<ominus> f n)\\<rbrakk>\n       \\<Longrightarrow> \\<not> hindered (\\<Gamma> \\<ominus> f (Suc n))", "case 1"], ["proof (state)\nthis:\n  \n\ngoal (6 subgoals):\n 1. current \\<Gamma> (f 0)\n 2. \\<And>m.\n       m < 0 \\<Longrightarrow>\n       d_OUT (f 0) (enum m) = weight \\<Gamma> (enum m)\n 3. \\<not> hindered (\\<Gamma> \\<ominus> f 0)\n 4. \\<And>n.\n       \\<lbrakk>current \\<Gamma> (f n);\n        \\<And>m.\n           m < n \\<Longrightarrow>\n           d_OUT (f n) (enum m) = weight \\<Gamma> (enum m);\n        \\<not> hindered (\\<Gamma> \\<ominus> f n)\\<rbrakk>\n       \\<Longrightarrow> current \\<Gamma> (f (Suc n))\n 5. \\<And>n m.\n       \\<lbrakk>current \\<Gamma> (f n);\n        \\<And>m.\n           m < n \\<Longrightarrow>\n           d_OUT (f n) (enum m) = weight \\<Gamma> (enum m);\n        \\<not> hindered (\\<Gamma> \\<ominus> f n); m < Suc n\\<rbrakk>\n       \\<Longrightarrow> d_OUT (f (Suc n)) (enum m) =\n                         weight \\<Gamma> (enum m)\n 6. \\<And>n.\n       \\<lbrakk>current \\<Gamma> (f n);\n        \\<And>m.\n           m < n \\<Longrightarrow>\n           d_OUT (f n) (enum m) = weight \\<Gamma> (enum m);\n        \\<not> hindered (\\<Gamma> \\<ominus> f n)\\<rbrakk>\n       \\<Longrightarrow> \\<not> hindered (\\<Gamma> \\<ominus> f (Suc n))", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. current \\<Gamma> (f 0)", "by(simp add: )"], ["proof (state)\nthis:\n  current \\<Gamma> (f 0)\n\ngoal (5 subgoals):\n 1. \\<And>m.\n       m < 0 \\<Longrightarrow>\n       d_OUT (f 0) (enum m) = weight \\<Gamma> (enum m)\n 2. \\<not> hindered (\\<Gamma> \\<ominus> f 0)\n 3. \\<And>n.\n       \\<lbrakk>current \\<Gamma> (f n);\n        \\<And>m.\n           m < n \\<Longrightarrow>\n           d_OUT (f n) (enum m) = weight \\<Gamma> (enum m);\n        \\<not> hindered (\\<Gamma> \\<ominus> f n)\\<rbrakk>\n       \\<Longrightarrow> current \\<Gamma> (f (Suc n))\n 4. \\<And>n m.\n       \\<lbrakk>current \\<Gamma> (f n);\n        \\<And>m.\n           m < n \\<Longrightarrow>\n           d_OUT (f n) (enum m) = weight \\<Gamma> (enum m);\n        \\<not> hindered (\\<Gamma> \\<ominus> f n); m < Suc n\\<rbrakk>\n       \\<Longrightarrow> d_OUT (f (Suc n)) (enum m) =\n                         weight \\<Gamma> (enum m)\n 5. \\<And>n.\n       \\<lbrakk>current \\<Gamma> (f n);\n        \\<And>m.\n           m < n \\<Longrightarrow>\n           d_OUT (f n) (enum m) = weight \\<Gamma> (enum m);\n        \\<not> hindered (\\<Gamma> \\<ominus> f n)\\<rbrakk>\n       \\<Longrightarrow> \\<not> hindered (\\<Gamma> \\<ominus> f (Suc n))", "}"], ["proof (state)\nthis:\n  current \\<Gamma> (f 0)\n\ngoal (5 subgoals):\n 1. \\<And>m.\n       m < 0 \\<Longrightarrow>\n       d_OUT (f 0) (enum m) = weight \\<Gamma> (enum m)\n 2. \\<not> hindered (\\<Gamma> \\<ominus> f 0)\n 3. \\<And>n.\n       \\<lbrakk>current \\<Gamma> (f n);\n        \\<And>m.\n           m < n \\<Longrightarrow>\n           d_OUT (f n) (enum m) = weight \\<Gamma> (enum m);\n        \\<not> hindered (\\<Gamma> \\<ominus> f n)\\<rbrakk>\n       \\<Longrightarrow> current \\<Gamma> (f (Suc n))\n 4. \\<And>n m.\n       \\<lbrakk>current \\<Gamma> (f n);\n        \\<And>m.\n           m < n \\<Longrightarrow>\n           d_OUT (f n) (enum m) = weight \\<Gamma> (enum m);\n        \\<not> hindered (\\<Gamma> \\<ominus> f n); m < Suc n\\<rbrakk>\n       \\<Longrightarrow> d_OUT (f (Suc n)) (enum m) =\n                         weight \\<Gamma> (enum m)\n 5. \\<And>n.\n       \\<lbrakk>current \\<Gamma> (f n);\n        \\<And>m.\n           m < n \\<Longrightarrow>\n           d_OUT (f n) (enum m) = weight \\<Gamma> (enum m);\n        \\<not> hindered (\\<Gamma> \\<ominus> f n)\\<rbrakk>\n       \\<Longrightarrow> \\<not> hindered (\\<Gamma> \\<ominus> f (Suc n))", "{"], ["proof (state)\nthis:\n  current \\<Gamma> (f 0)\n\ngoal (5 subgoals):\n 1. \\<And>m.\n       m < 0 \\<Longrightarrow>\n       d_OUT (f 0) (enum m) = weight \\<Gamma> (enum m)\n 2. \\<not> hindered (\\<Gamma> \\<ominus> f 0)\n 3. \\<And>n.\n       \\<lbrakk>current \\<Gamma> (f n);\n        \\<And>m.\n           m < n \\<Longrightarrow>\n           d_OUT (f n) (enum m) = weight \\<Gamma> (enum m);\n        \\<not> hindered (\\<Gamma> \\<ominus> f n)\\<rbrakk>\n       \\<Longrightarrow> current \\<Gamma> (f (Suc n))\n 4. \\<And>n m.\n       \\<lbrakk>current \\<Gamma> (f n);\n        \\<And>m.\n           m < n \\<Longrightarrow>\n           d_OUT (f n) (enum m) = weight \\<Gamma> (enum m);\n        \\<not> hindered (\\<Gamma> \\<ominus> f n); m < Suc n\\<rbrakk>\n       \\<Longrightarrow> d_OUT (f (Suc n)) (enum m) =\n                         weight \\<Gamma> (enum m)\n 5. \\<And>n.\n       \\<lbrakk>current \\<Gamma> (f n);\n        \\<And>m.\n           m < n \\<Longrightarrow>\n           d_OUT (f n) (enum m) = weight \\<Gamma> (enum m);\n        \\<not> hindered (\\<Gamma> \\<ominus> f n)\\<rbrakk>\n       \\<Longrightarrow> \\<not> hindered (\\<Gamma> \\<ominus> f (Suc n))", "case 2"], ["proof (state)\nthis:\n  m < 0\n\ngoal (5 subgoals):\n 1. \\<And>m.\n       m < 0 \\<Longrightarrow>\n       d_OUT (f 0) (enum m) = weight \\<Gamma> (enum m)\n 2. \\<not> hindered (\\<Gamma> \\<ominus> f 0)\n 3. \\<And>n.\n       \\<lbrakk>current \\<Gamma> (f n);\n        \\<And>m.\n           m < n \\<Longrightarrow>\n           d_OUT (f n) (enum m) = weight \\<Gamma> (enum m);\n        \\<not> hindered (\\<Gamma> \\<ominus> f n)\\<rbrakk>\n       \\<Longrightarrow> current \\<Gamma> (f (Suc n))\n 4. \\<And>n m.\n       \\<lbrakk>current \\<Gamma> (f n);\n        \\<And>m.\n           m < n \\<Longrightarrow>\n           d_OUT (f n) (enum m) = weight \\<Gamma> (enum m);\n        \\<not> hindered (\\<Gamma> \\<ominus> f n); m < Suc n\\<rbrakk>\n       \\<Longrightarrow> d_OUT (f (Suc n)) (enum m) =\n                         weight \\<Gamma> (enum m)\n 5. \\<And>n.\n       \\<lbrakk>current \\<Gamma> (f n);\n        \\<And>m.\n           m < n \\<Longrightarrow>\n           d_OUT (f n) (enum m) = weight \\<Gamma> (enum m);\n        \\<not> hindered (\\<Gamma> \\<ominus> f n)\\<rbrakk>\n       \\<Longrightarrow> \\<not> hindered (\\<Gamma> \\<ominus> f (Suc n))", "thus ?case"], ["proof (prove)\nusing this:\n  m < 0\n\ngoal (1 subgoal):\n 1. d_OUT (f 0) (enum m) = weight \\<Gamma> (enum m)", "by simp"], ["proof (state)\nthis:\n  d_OUT (f 0) (enum m) = weight \\<Gamma> (enum m)\n\ngoal (4 subgoals):\n 1. \\<not> hindered (\\<Gamma> \\<ominus> f 0)\n 2. \\<And>n.\n       \\<lbrakk>current \\<Gamma> (f n);\n        \\<And>m.\n           m < n \\<Longrightarrow>\n           d_OUT (f n) (enum m) = weight \\<Gamma> (enum m);\n        \\<not> hindered (\\<Gamma> \\<ominus> f n)\\<rbrakk>\n       \\<Longrightarrow> current \\<Gamma> (f (Suc n))\n 3. \\<And>n m.\n       \\<lbrakk>current \\<Gamma> (f n);\n        \\<And>m.\n           m < n \\<Longrightarrow>\n           d_OUT (f n) (enum m) = weight \\<Gamma> (enum m);\n        \\<not> hindered (\\<Gamma> \\<ominus> f n); m < Suc n\\<rbrakk>\n       \\<Longrightarrow> d_OUT (f (Suc n)) (enum m) =\n                         weight \\<Gamma> (enum m)\n 4. \\<And>n.\n       \\<lbrakk>current \\<Gamma> (f n);\n        \\<And>m.\n           m < n \\<Longrightarrow>\n           d_OUT (f n) (enum m) = weight \\<Gamma> (enum m);\n        \\<not> hindered (\\<Gamma> \\<ominus> f n)\\<rbrakk>\n       \\<Longrightarrow> \\<not> hindered (\\<Gamma> \\<ominus> f (Suc n))", "}"], ["proof (state)\nthis:\n  ?m2 < 0 \\<Longrightarrow>\n  d_OUT (f 0) (enum ?m2) = weight \\<Gamma> (enum ?m2)\n\ngoal (4 subgoals):\n 1. \\<not> hindered (\\<Gamma> \\<ominus> f 0)\n 2. \\<And>n.\n       \\<lbrakk>current \\<Gamma> (f n);\n        \\<And>m.\n           m < n \\<Longrightarrow>\n           d_OUT (f n) (enum m) = weight \\<Gamma> (enum m);\n        \\<not> hindered (\\<Gamma> \\<ominus> f n)\\<rbrakk>\n       \\<Longrightarrow> current \\<Gamma> (f (Suc n))\n 3. \\<And>n m.\n       \\<lbrakk>current \\<Gamma> (f n);\n        \\<And>m.\n           m < n \\<Longrightarrow>\n           d_OUT (f n) (enum m) = weight \\<Gamma> (enum m);\n        \\<not> hindered (\\<Gamma> \\<ominus> f n); m < Suc n\\<rbrakk>\n       \\<Longrightarrow> d_OUT (f (Suc n)) (enum m) =\n                         weight \\<Gamma> (enum m)\n 4. \\<And>n.\n       \\<lbrakk>current \\<Gamma> (f n);\n        \\<And>m.\n           m < n \\<Longrightarrow>\n           d_OUT (f n) (enum m) = weight \\<Gamma> (enum m);\n        \\<not> hindered (\\<Gamma> \\<ominus> f n)\\<rbrakk>\n       \\<Longrightarrow> \\<not> hindered (\\<Gamma> \\<ominus> f (Suc n))", "{"], ["proof (state)\nthis:\n  ?m2 < 0 \\<Longrightarrow>\n  d_OUT (f 0) (enum ?m2) = weight \\<Gamma> (enum ?m2)\n\ngoal (4 subgoals):\n 1. \\<not> hindered (\\<Gamma> \\<ominus> f 0)\n 2. \\<And>n.\n       \\<lbrakk>current \\<Gamma> (f n);\n        \\<And>m.\n           m < n \\<Longrightarrow>\n           d_OUT (f n) (enum m) = weight \\<Gamma> (enum m);\n        \\<not> hindered (\\<Gamma> \\<ominus> f n)\\<rbrakk>\n       \\<Longrightarrow> current \\<Gamma> (f (Suc n))\n 3. \\<And>n m.\n       \\<lbrakk>current \\<Gamma> (f n);\n        \\<And>m.\n           m < n \\<Longrightarrow>\n           d_OUT (f n) (enum m) = weight \\<Gamma> (enum m);\n        \\<not> hindered (\\<Gamma> \\<ominus> f n); m < Suc n\\<rbrakk>\n       \\<Longrightarrow> d_OUT (f (Suc n)) (enum m) =\n                         weight \\<Gamma> (enum m)\n 4. \\<And>n.\n       \\<lbrakk>current \\<Gamma> (f n);\n        \\<And>m.\n           m < n \\<Longrightarrow>\n           d_OUT (f n) (enum m) = weight \\<Gamma> (enum m);\n        \\<not> hindered (\\<Gamma> \\<ominus> f n)\\<rbrakk>\n       \\<Longrightarrow> \\<not> hindered (\\<Gamma> \\<ominus> f (Suc n))", "case 3"], ["proof (state)\nthis:\n  \n\ngoal (4 subgoals):\n 1. \\<not> hindered (\\<Gamma> \\<ominus> f 0)\n 2. \\<And>n.\n       \\<lbrakk>current \\<Gamma> (f n);\n        \\<And>m.\n           m < n \\<Longrightarrow>\n           d_OUT (f n) (enum m) = weight \\<Gamma> (enum m);\n        \\<not> hindered (\\<Gamma> \\<ominus> f n)\\<rbrakk>\n       \\<Longrightarrow> current \\<Gamma> (f (Suc n))\n 3. \\<And>n m.\n       \\<lbrakk>current \\<Gamma> (f n);\n        \\<And>m.\n           m < n \\<Longrightarrow>\n           d_OUT (f n) (enum m) = weight \\<Gamma> (enum m);\n        \\<not> hindered (\\<Gamma> \\<ominus> f n); m < Suc n\\<rbrakk>\n       \\<Longrightarrow> d_OUT (f (Suc n)) (enum m) =\n                         weight \\<Gamma> (enum m)\n 4. \\<And>n.\n       \\<lbrakk>current \\<Gamma> (f n);\n        \\<And>m.\n           m < n \\<Longrightarrow>\n           d_OUT (f n) (enum m) = weight \\<Gamma> (enum m);\n        \\<not> hindered (\\<Gamma> \\<ominus> f n)\\<rbrakk>\n       \\<Longrightarrow> \\<not> hindered (\\<Gamma> \\<ominus> f (Suc n))", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> hindered (\\<Gamma> \\<ominus> f 0)", "using unhindered"], ["proof (prove)\nusing this:\n  \\<not> hindered \\<Gamma>\n\ngoal (1 subgoal):\n 1. \\<not> hindered (\\<Gamma> \\<ominus> f 0)", "by simp"], ["proof (state)\nthis:\n  \\<not> hindered (\\<Gamma> \\<ominus> f 0)\n\ngoal (3 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>current \\<Gamma> (f n);\n        \\<And>m.\n           m < n \\<Longrightarrow>\n           d_OUT (f n) (enum m) = weight \\<Gamma> (enum m);\n        \\<not> hindered (\\<Gamma> \\<ominus> f n)\\<rbrakk>\n       \\<Longrightarrow> current \\<Gamma> (f (Suc n))\n 2. \\<And>n m.\n       \\<lbrakk>current \\<Gamma> (f n);\n        \\<And>m.\n           m < n \\<Longrightarrow>\n           d_OUT (f n) (enum m) = weight \\<Gamma> (enum m);\n        \\<not> hindered (\\<Gamma> \\<ominus> f n); m < Suc n\\<rbrakk>\n       \\<Longrightarrow> d_OUT (f (Suc n)) (enum m) =\n                         weight \\<Gamma> (enum m)\n 3. \\<And>n.\n       \\<lbrakk>current \\<Gamma> (f n);\n        \\<And>m.\n           m < n \\<Longrightarrow>\n           d_OUT (f n) (enum m) = weight \\<Gamma> (enum m);\n        \\<not> hindered (\\<Gamma> \\<ominus> f n)\\<rbrakk>\n       \\<Longrightarrow> \\<not> hindered (\\<Gamma> \\<ominus> f (Suc n))", "}"], ["proof (state)\nthis:\n  \\<not> hindered (\\<Gamma> \\<ominus> f 0)\n\ngoal (3 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>current \\<Gamma> (f n);\n        \\<And>m.\n           m < n \\<Longrightarrow>\n           d_OUT (f n) (enum m) = weight \\<Gamma> (enum m);\n        \\<not> hindered (\\<Gamma> \\<ominus> f n)\\<rbrakk>\n       \\<Longrightarrow> current \\<Gamma> (f (Suc n))\n 2. \\<And>n m.\n       \\<lbrakk>current \\<Gamma> (f n);\n        \\<And>m.\n           m < n \\<Longrightarrow>\n           d_OUT (f n) (enum m) = weight \\<Gamma> (enum m);\n        \\<not> hindered (\\<Gamma> \\<ominus> f n); m < Suc n\\<rbrakk>\n       \\<Longrightarrow> d_OUT (f (Suc n)) (enum m) =\n                         weight \\<Gamma> (enum m)\n 3. \\<And>n.\n       \\<lbrakk>current \\<Gamma> (f n);\n        \\<And>m.\n           m < n \\<Longrightarrow>\n           d_OUT (f n) (enum m) = weight \\<Gamma> (enum m);\n        \\<not> hindered (\\<Gamma> \\<ominus> f n)\\<rbrakk>\n       \\<Longrightarrow> \\<not> hindered (\\<Gamma> \\<ominus> f (Suc n))", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>current \\<Gamma> (f n);\n        \\<And>m.\n           m < n \\<Longrightarrow>\n           d_OUT (f n) (enum m) = weight \\<Gamma> (enum m);\n        \\<not> hindered (\\<Gamma> \\<ominus> f n)\\<rbrakk>\n       \\<Longrightarrow> current \\<Gamma> (f (Suc n))\n 2. \\<And>n m.\n       \\<lbrakk>current \\<Gamma> (f n);\n        \\<And>m.\n           m < n \\<Longrightarrow>\n           d_OUT (f n) (enum m) = weight \\<Gamma> (enum m);\n        \\<not> hindered (\\<Gamma> \\<ominus> f n); m < Suc n\\<rbrakk>\n       \\<Longrightarrow> d_OUT (f (Suc n)) (enum m) =\n                         weight \\<Gamma> (enum m)\n 3. \\<And>n.\n       \\<lbrakk>current \\<Gamma> (f n);\n        \\<And>m.\n           m < n \\<Longrightarrow>\n           d_OUT (f n) (enum m) = weight \\<Gamma> (enum m);\n        \\<not> hindered (\\<Gamma> \\<ominus> f n)\\<rbrakk>\n       \\<Longrightarrow> \\<not> hindered (\\<Gamma> \\<ominus> f (Suc n))", "case (Suc n)"], ["proof (state)\nthis:\n  current \\<Gamma> (f n)\n  ?m < n \\<Longrightarrow> d_OUT (f n) (enum ?m) = weight \\<Gamma> (enum ?m)\n  \\<not> hindered (\\<Gamma> \\<ominus> f n)\n\ngoal (3 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>current \\<Gamma> (f n);\n        \\<And>m.\n           m < n \\<Longrightarrow>\n           d_OUT (f n) (enum m) = weight \\<Gamma> (enum m);\n        \\<not> hindered (\\<Gamma> \\<ominus> f n)\\<rbrakk>\n       \\<Longrightarrow> current \\<Gamma> (f (Suc n))\n 2. \\<And>n m.\n       \\<lbrakk>current \\<Gamma> (f n);\n        \\<And>m.\n           m < n \\<Longrightarrow>\n           d_OUT (f n) (enum m) = weight \\<Gamma> (enum m);\n        \\<not> hindered (\\<Gamma> \\<ominus> f n); m < Suc n\\<rbrakk>\n       \\<Longrightarrow> d_OUT (f (Suc n)) (enum m) =\n                         weight \\<Gamma> (enum m)\n 3. \\<And>n.\n       \\<lbrakk>current \\<Gamma> (f n);\n        \\<And>m.\n           m < n \\<Longrightarrow>\n           d_OUT (f n) (enum m) = weight \\<Gamma> (enum m);\n        \\<not> hindered (\\<Gamma> \\<ominus> f n)\\<rbrakk>\n       \\<Longrightarrow> \\<not> hindered (\\<Gamma> \\<ominus> f (Suc n))", "interpret \\<Gamma>: countable_bipartite_web \"\\<Gamma> \\<ominus> f n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. countable_bipartite_web (\\<Gamma> \\<ominus> f n)", "using Suc.IH(1)"], ["proof (prove)\nusing this:\n  current \\<Gamma> (f n)\n\ngoal (1 subgoal):\n 1. countable_bipartite_web (\\<Gamma> \\<ominus> f n)", "by(rule countable_bipartite_web_minus_web)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>current \\<Gamma> (f n);\n        \\<And>m.\n           m < n \\<Longrightarrow>\n           d_OUT (f n) (enum m) = weight \\<Gamma> (enum m);\n        \\<not> hindered (\\<Gamma> \\<ominus> f n)\\<rbrakk>\n       \\<Longrightarrow> current \\<Gamma> (f (Suc n))\n 2. \\<And>n m.\n       \\<lbrakk>current \\<Gamma> (f n);\n        \\<And>m.\n           m < n \\<Longrightarrow>\n           d_OUT (f n) (enum m) = weight \\<Gamma> (enum m);\n        \\<not> hindered (\\<Gamma> \\<ominus> f n); m < Suc n\\<rbrakk>\n       \\<Longrightarrow> d_OUT (f (Suc n)) (enum m) =\n                         weight \\<Gamma> (enum m)\n 3. \\<And>n.\n       \\<lbrakk>current \\<Gamma> (f n);\n        \\<And>m.\n           m < n \\<Longrightarrow>\n           d_OUT (f n) (enum m) = weight \\<Gamma> (enum m);\n        \\<not> hindered (\\<Gamma> \\<ominus> f n)\\<rbrakk>\n       \\<Longrightarrow> \\<not> hindered (\\<Gamma> \\<ominus> f (Suc n))", "define f' where \"f' = Eps (?P (f n) (enum n))\""], ["proof (state)\nthis:\n  f' =\n  (SOME f'.\n      current (\\<Gamma> \\<ominus> f n) f' \\<and>\n      d_OUT f' (enum n) = weight (\\<Gamma> \\<ominus> f n) (enum n) \\<and>\n      \\<not> hindered (\\<Gamma> \\<ominus> f n \\<ominus> f'))\n\ngoal (3 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>current \\<Gamma> (f n);\n        \\<And>m.\n           m < n \\<Longrightarrow>\n           d_OUT (f n) (enum m) = weight \\<Gamma> (enum m);\n        \\<not> hindered (\\<Gamma> \\<ominus> f n)\\<rbrakk>\n       \\<Longrightarrow> current \\<Gamma> (f (Suc n))\n 2. \\<And>n m.\n       \\<lbrakk>current \\<Gamma> (f n);\n        \\<And>m.\n           m < n \\<Longrightarrow>\n           d_OUT (f n) (enum m) = weight \\<Gamma> (enum m);\n        \\<not> hindered (\\<Gamma> \\<ominus> f n); m < Suc n\\<rbrakk>\n       \\<Longrightarrow> d_OUT (f (Suc n)) (enum m) =\n                         weight \\<Gamma> (enum m)\n 3. \\<And>n.\n       \\<lbrakk>current \\<Gamma> (f n);\n        \\<And>m.\n           m < n \\<Longrightarrow>\n           d_OUT (f n) (enum m) = weight \\<Gamma> (enum m);\n        \\<not> hindered (\\<Gamma> \\<ominus> f n)\\<rbrakk>\n       \\<Longrightarrow> \\<not> hindered (\\<Gamma> \\<ominus> f (Suc n))", "have \"Ex (?P (f n) (enum n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>f'.\n       current (\\<Gamma> \\<ominus> f n) f' \\<and>\n       d_OUT f' (enum n) = weight (\\<Gamma> \\<ominus> f n) (enum n) \\<and>\n       \\<not> hindered (\\<Gamma> \\<ominus> f n \\<ominus> f')", "using Suc.IH(3)"], ["proof (prove)\nusing this:\n  \\<not> hindered (\\<Gamma> \\<ominus> f n)\n\ngoal (1 subgoal):\n 1. \\<exists>f'.\n       current (\\<Gamma> \\<ominus> f n) f' \\<and>\n       d_OUT f' (enum n) = weight (\\<Gamma> \\<ominus> f n) (enum n) \\<and>\n       \\<not> hindered (\\<Gamma> \\<ominus> f n \\<ominus> f')", "by(rule \\<Gamma>.unhindered_saturate1)(simp add: enum_A)"], ["proof (state)\nthis:\n  \\<exists>f'.\n     current (\\<Gamma> \\<ominus> f n) f' \\<and>\n     d_OUT f' (enum n) = weight (\\<Gamma> \\<ominus> f n) (enum n) \\<and>\n     \\<not> hindered (\\<Gamma> \\<ominus> f n \\<ominus> f')\n\ngoal (3 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>current \\<Gamma> (f n);\n        \\<And>m.\n           m < n \\<Longrightarrow>\n           d_OUT (f n) (enum m) = weight \\<Gamma> (enum m);\n        \\<not> hindered (\\<Gamma> \\<ominus> f n)\\<rbrakk>\n       \\<Longrightarrow> current \\<Gamma> (f (Suc n))\n 2. \\<And>n m.\n       \\<lbrakk>current \\<Gamma> (f n);\n        \\<And>m.\n           m < n \\<Longrightarrow>\n           d_OUT (f n) (enum m) = weight \\<Gamma> (enum m);\n        \\<not> hindered (\\<Gamma> \\<ominus> f n); m < Suc n\\<rbrakk>\n       \\<Longrightarrow> d_OUT (f (Suc n)) (enum m) =\n                         weight \\<Gamma> (enum m)\n 3. \\<And>n.\n       \\<lbrakk>current \\<Gamma> (f n);\n        \\<And>m.\n           m < n \\<Longrightarrow>\n           d_OUT (f n) (enum m) = weight \\<Gamma> (enum m);\n        \\<not> hindered (\\<Gamma> \\<ominus> f n)\\<rbrakk>\n       \\<Longrightarrow> \\<not> hindered (\\<Gamma> \\<ominus> f (Suc n))", "hence \"?P (f n) (enum n) f'\""], ["proof (prove)\nusing this:\n  \\<exists>f'.\n     current (\\<Gamma> \\<ominus> f n) f' \\<and>\n     d_OUT f' (enum n) = weight (\\<Gamma> \\<ominus> f n) (enum n) \\<and>\n     \\<not> hindered (\\<Gamma> \\<ominus> f n \\<ominus> f')\n\ngoal (1 subgoal):\n 1. current (\\<Gamma> \\<ominus> f n) f' \\<and>\n    d_OUT f' (enum n) = weight (\\<Gamma> \\<ominus> f n) (enum n) \\<and>\n    \\<not> hindered (\\<Gamma> \\<ominus> f n \\<ominus> f')", "unfolding f'_def"], ["proof (prove)\nusing this:\n  \\<exists>f'.\n     current (\\<Gamma> \\<ominus> f n) f' \\<and>\n     d_OUT f' (enum n) = weight (\\<Gamma> \\<ominus> f n) (enum n) \\<and>\n     \\<not> hindered (\\<Gamma> \\<ominus> f n \\<ominus> f')\n\ngoal (1 subgoal):\n 1. current (\\<Gamma> \\<ominus> f n)\n     (SOME f'.\n         current (\\<Gamma> \\<ominus> f n) f' \\<and>\n         d_OUT f' (enum n) = weight (\\<Gamma> \\<ominus> f n) (enum n) \\<and>\n         \\<not> hindered (\\<Gamma> \\<ominus> f n \\<ominus> f')) \\<and>\n    d_OUT\n     (SOME f'.\n         current (\\<Gamma> \\<ominus> f n) f' \\<and>\n         d_OUT f' (enum n) = weight (\\<Gamma> \\<ominus> f n) (enum n) \\<and>\n         \\<not> hindered (\\<Gamma> \\<ominus> f n \\<ominus> f'))\n     (enum n) =\n    weight (\\<Gamma> \\<ominus> f n) (enum n) \\<and>\n    \\<not> hindered\n            (\\<Gamma> \\<ominus> f n \\<ominus>\n             (SOME f'.\n                 current (\\<Gamma> \\<ominus> f n) f' \\<and>\n                 d_OUT f' (enum n) =\n                 weight (\\<Gamma> \\<ominus> f n) (enum n) \\<and>\n                 \\<not> hindered (\\<Gamma> \\<ominus> f n \\<ominus> f')))", "by(rule someI_ex)"], ["proof (state)\nthis:\n  current (\\<Gamma> \\<ominus> f n) f' \\<and>\n  d_OUT f' (enum n) = weight (\\<Gamma> \\<ominus> f n) (enum n) \\<and>\n  \\<not> hindered (\\<Gamma> \\<ominus> f n \\<ominus> f')\n\ngoal (3 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>current \\<Gamma> (f n);\n        \\<And>m.\n           m < n \\<Longrightarrow>\n           d_OUT (f n) (enum m) = weight \\<Gamma> (enum m);\n        \\<not> hindered (\\<Gamma> \\<ominus> f n)\\<rbrakk>\n       \\<Longrightarrow> current \\<Gamma> (f (Suc n))\n 2. \\<And>n m.\n       \\<lbrakk>current \\<Gamma> (f n);\n        \\<And>m.\n           m < n \\<Longrightarrow>\n           d_OUT (f n) (enum m) = weight \\<Gamma> (enum m);\n        \\<not> hindered (\\<Gamma> \\<ominus> f n); m < Suc n\\<rbrakk>\n       \\<Longrightarrow> d_OUT (f (Suc n)) (enum m) =\n                         weight \\<Gamma> (enum m)\n 3. \\<And>n.\n       \\<lbrakk>current \\<Gamma> (f n);\n        \\<And>m.\n           m < n \\<Longrightarrow>\n           d_OUT (f n) (enum m) = weight \\<Gamma> (enum m);\n        \\<not> hindered (\\<Gamma> \\<ominus> f n)\\<rbrakk>\n       \\<Longrightarrow> \\<not> hindered (\\<Gamma> \\<ominus> f (Suc n))", "hence f': \"current (\\<Gamma> \\<ominus> f n) f'\"\n      and OUT: \"d_OUT f' (enum n) = weight (\\<Gamma> \\<ominus> f n) (enum n)\"\n      and unhindered': \"\\<not> hindered (\\<Gamma> \\<ominus> f n \\<ominus> f')\""], ["proof (prove)\nusing this:\n  current (\\<Gamma> \\<ominus> f n) f' \\<and>\n  d_OUT f' (enum n) = weight (\\<Gamma> \\<ominus> f n) (enum n) \\<and>\n  \\<not> hindered (\\<Gamma> \\<ominus> f n \\<ominus> f')\n\ngoal (1 subgoal):\n 1. current (\\<Gamma> \\<ominus> f n) f' &&&\n    d_OUT f' (enum n) = weight (\\<Gamma> \\<ominus> f n) (enum n) &&&\n    \\<not> hindered (\\<Gamma> \\<ominus> f n \\<ominus> f')", "by blast+"], ["proof (state)\nthis:\n  current (\\<Gamma> \\<ominus> f n) f'\n  d_OUT f' (enum n) = weight (\\<Gamma> \\<ominus> f n) (enum n)\n  \\<not> hindered (\\<Gamma> \\<ominus> f n \\<ominus> f')\n\ngoal (3 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>current \\<Gamma> (f n);\n        \\<And>m.\n           m < n \\<Longrightarrow>\n           d_OUT (f n) (enum m) = weight \\<Gamma> (enum m);\n        \\<not> hindered (\\<Gamma> \\<ominus> f n)\\<rbrakk>\n       \\<Longrightarrow> current \\<Gamma> (f (Suc n))\n 2. \\<And>n m.\n       \\<lbrakk>current \\<Gamma> (f n);\n        \\<And>m.\n           m < n \\<Longrightarrow>\n           d_OUT (f n) (enum m) = weight \\<Gamma> (enum m);\n        \\<not> hindered (\\<Gamma> \\<ominus> f n); m < Suc n\\<rbrakk>\n       \\<Longrightarrow> d_OUT (f (Suc n)) (enum m) =\n                         weight \\<Gamma> (enum m)\n 3. \\<And>n.\n       \\<lbrakk>current \\<Gamma> (f n);\n        \\<And>m.\n           m < n \\<Longrightarrow>\n           d_OUT (f n) (enum m) = weight \\<Gamma> (enum m);\n        \\<not> hindered (\\<Gamma> \\<ominus> f n)\\<rbrakk>\n       \\<Longrightarrow> \\<not> hindered (\\<Gamma> \\<ominus> f (Suc n))", "have f_Suc: \"f (Suc n) = plus_current (f n) f'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f (Suc n) = plus_current (f n) f'", "by(simp add: f'_def f_Suc)"], ["proof (state)\nthis:\n  f (Suc n) = plus_current (f n) f'\n\ngoal (3 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>current \\<Gamma> (f n);\n        \\<And>m.\n           m < n \\<Longrightarrow>\n           d_OUT (f n) (enum m) = weight \\<Gamma> (enum m);\n        \\<not> hindered (\\<Gamma> \\<ominus> f n)\\<rbrakk>\n       \\<Longrightarrow> current \\<Gamma> (f (Suc n))\n 2. \\<And>n m.\n       \\<lbrakk>current \\<Gamma> (f n);\n        \\<And>m.\n           m < n \\<Longrightarrow>\n           d_OUT (f n) (enum m) = weight \\<Gamma> (enum m);\n        \\<not> hindered (\\<Gamma> \\<ominus> f n); m < Suc n\\<rbrakk>\n       \\<Longrightarrow> d_OUT (f (Suc n)) (enum m) =\n                         weight \\<Gamma> (enum m)\n 3. \\<And>n.\n       \\<lbrakk>current \\<Gamma> (f n);\n        \\<And>m.\n           m < n \\<Longrightarrow>\n           d_OUT (f n) (enum m) = weight \\<Gamma> (enum m);\n        \\<not> hindered (\\<Gamma> \\<ominus> f n)\\<rbrakk>\n       \\<Longrightarrow> \\<not> hindered (\\<Gamma> \\<ominus> f (Suc n))", "{"], ["proof (state)\nthis:\n  f (Suc n) = plus_current (f n) f'\n\ngoal (3 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>current \\<Gamma> (f n);\n        \\<And>m.\n           m < n \\<Longrightarrow>\n           d_OUT (f n) (enum m) = weight \\<Gamma> (enum m);\n        \\<not> hindered (\\<Gamma> \\<ominus> f n)\\<rbrakk>\n       \\<Longrightarrow> current \\<Gamma> (f (Suc n))\n 2. \\<And>n m.\n       \\<lbrakk>current \\<Gamma> (f n);\n        \\<And>m.\n           m < n \\<Longrightarrow>\n           d_OUT (f n) (enum m) = weight \\<Gamma> (enum m);\n        \\<not> hindered (\\<Gamma> \\<ominus> f n); m < Suc n\\<rbrakk>\n       \\<Longrightarrow> d_OUT (f (Suc n)) (enum m) =\n                         weight \\<Gamma> (enum m)\n 3. \\<And>n.\n       \\<lbrakk>current \\<Gamma> (f n);\n        \\<And>m.\n           m < n \\<Longrightarrow>\n           d_OUT (f n) (enum m) = weight \\<Gamma> (enum m);\n        \\<not> hindered (\\<Gamma> \\<ominus> f n)\\<rbrakk>\n       \\<Longrightarrow> \\<not> hindered (\\<Gamma> \\<ominus> f (Suc n))", "case 1"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>current \\<Gamma> (f n);\n        \\<And>m.\n           m < n \\<Longrightarrow>\n           d_OUT (f n) (enum m) = weight \\<Gamma> (enum m);\n        \\<not> hindered (\\<Gamma> \\<ominus> f n)\\<rbrakk>\n       \\<Longrightarrow> current \\<Gamma> (f (Suc n))\n 2. \\<And>n m.\n       \\<lbrakk>current \\<Gamma> (f n);\n        \\<And>m.\n           m < n \\<Longrightarrow>\n           d_OUT (f n) (enum m) = weight \\<Gamma> (enum m);\n        \\<not> hindered (\\<Gamma> \\<ominus> f n); m < Suc n\\<rbrakk>\n       \\<Longrightarrow> d_OUT (f (Suc n)) (enum m) =\n                         weight \\<Gamma> (enum m)\n 3. \\<And>n.\n       \\<lbrakk>current \\<Gamma> (f n);\n        \\<And>m.\n           m < n \\<Longrightarrow>\n           d_OUT (f n) (enum m) = weight \\<Gamma> (enum m);\n        \\<not> hindered (\\<Gamma> \\<ominus> f n)\\<rbrakk>\n       \\<Longrightarrow> \\<not> hindered (\\<Gamma> \\<ominus> f (Suc n))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. current \\<Gamma> (f (Suc n))", "unfolding f_Suc"], ["proof (prove)\ngoal (1 subgoal):\n 1. current \\<Gamma> (plus_current (f n) f')", "using Suc.IH(1) f'"], ["proof (prove)\nusing this:\n  current \\<Gamma> (f n)\n  current (\\<Gamma> \\<ominus> f n) f'\n\ngoal (1 subgoal):\n 1. current \\<Gamma> (plus_current (f n) f')", "by(rule current_plus_current_minus)"], ["proof (state)\nthis:\n  current \\<Gamma> (f (Suc n))\n\ngoal (2 subgoals):\n 1. \\<And>n m.\n       \\<lbrakk>current \\<Gamma> (f n);\n        \\<And>m.\n           m < n \\<Longrightarrow>\n           d_OUT (f n) (enum m) = weight \\<Gamma> (enum m);\n        \\<not> hindered (\\<Gamma> \\<ominus> f n); m < Suc n\\<rbrakk>\n       \\<Longrightarrow> d_OUT (f (Suc n)) (enum m) =\n                         weight \\<Gamma> (enum m)\n 2. \\<And>n.\n       \\<lbrakk>current \\<Gamma> (f n);\n        \\<And>m.\n           m < n \\<Longrightarrow>\n           d_OUT (f n) (enum m) = weight \\<Gamma> (enum m);\n        \\<not> hindered (\\<Gamma> \\<ominus> f n)\\<rbrakk>\n       \\<Longrightarrow> \\<not> hindered (\\<Gamma> \\<ominus> f (Suc n))", "}"], ["proof (state)\nthis:\n  current \\<Gamma> (f (Suc n))\n\ngoal (2 subgoals):\n 1. \\<And>n m.\n       \\<lbrakk>current \\<Gamma> (f n);\n        \\<And>m.\n           m < n \\<Longrightarrow>\n           d_OUT (f n) (enum m) = weight \\<Gamma> (enum m);\n        \\<not> hindered (\\<Gamma> \\<ominus> f n); m < Suc n\\<rbrakk>\n       \\<Longrightarrow> d_OUT (f (Suc n)) (enum m) =\n                         weight \\<Gamma> (enum m)\n 2. \\<And>n.\n       \\<lbrakk>current \\<Gamma> (f n);\n        \\<And>m.\n           m < n \\<Longrightarrow>\n           d_OUT (f n) (enum m) = weight \\<Gamma> (enum m);\n        \\<not> hindered (\\<Gamma> \\<ominus> f n)\\<rbrakk>\n       \\<Longrightarrow> \\<not> hindered (\\<Gamma> \\<ominus> f (Suc n))", "note f'' = this"], ["proof (state)\nthis:\n  current \\<Gamma> (f (Suc n))\n\ngoal (2 subgoals):\n 1. \\<And>n m.\n       \\<lbrakk>current \\<Gamma> (f n);\n        \\<And>m.\n           m < n \\<Longrightarrow>\n           d_OUT (f n) (enum m) = weight \\<Gamma> (enum m);\n        \\<not> hindered (\\<Gamma> \\<ominus> f n); m < Suc n\\<rbrakk>\n       \\<Longrightarrow> d_OUT (f (Suc n)) (enum m) =\n                         weight \\<Gamma> (enum m)\n 2. \\<And>n.\n       \\<lbrakk>current \\<Gamma> (f n);\n        \\<And>m.\n           m < n \\<Longrightarrow>\n           d_OUT (f n) (enum m) = weight \\<Gamma> (enum m);\n        \\<not> hindered (\\<Gamma> \\<ominus> f n)\\<rbrakk>\n       \\<Longrightarrow> \\<not> hindered (\\<Gamma> \\<ominus> f (Suc n))", "{"], ["proof (state)\nthis:\n  current \\<Gamma> (f (Suc n))\n\ngoal (2 subgoals):\n 1. \\<And>n m.\n       \\<lbrakk>current \\<Gamma> (f n);\n        \\<And>m.\n           m < n \\<Longrightarrow>\n           d_OUT (f n) (enum m) = weight \\<Gamma> (enum m);\n        \\<not> hindered (\\<Gamma> \\<ominus> f n); m < Suc n\\<rbrakk>\n       \\<Longrightarrow> d_OUT (f (Suc n)) (enum m) =\n                         weight \\<Gamma> (enum m)\n 2. \\<And>n.\n       \\<lbrakk>current \\<Gamma> (f n);\n        \\<And>m.\n           m < n \\<Longrightarrow>\n           d_OUT (f n) (enum m) = weight \\<Gamma> (enum m);\n        \\<not> hindered (\\<Gamma> \\<ominus> f n)\\<rbrakk>\n       \\<Longrightarrow> \\<not> hindered (\\<Gamma> \\<ominus> f (Suc n))", "case (2 m)"], ["proof (state)\nthis:\n  m < Suc n\n\ngoal (2 subgoals):\n 1. \\<And>n m.\n       \\<lbrakk>current \\<Gamma> (f n);\n        \\<And>m.\n           m < n \\<Longrightarrow>\n           d_OUT (f n) (enum m) = weight \\<Gamma> (enum m);\n        \\<not> hindered (\\<Gamma> \\<ominus> f n); m < Suc n\\<rbrakk>\n       \\<Longrightarrow> d_OUT (f (Suc n)) (enum m) =\n                         weight \\<Gamma> (enum m)\n 2. \\<And>n.\n       \\<lbrakk>current \\<Gamma> (f n);\n        \\<And>m.\n           m < n \\<Longrightarrow>\n           d_OUT (f n) (enum m) = weight \\<Gamma> (enum m);\n        \\<not> hindered (\\<Gamma> \\<ominus> f n)\\<rbrakk>\n       \\<Longrightarrow> \\<not> hindered (\\<Gamma> \\<ominus> f (Suc n))", "have \"d_OUT (f (Suc n)) (enum m) \\<le> weight \\<Gamma> (enum m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT (f (Suc n)) (enum m) \\<le> weight \\<Gamma> (enum m)", "using f''"], ["proof (prove)\nusing this:\n  current \\<Gamma> (f (Suc n))\n\ngoal (1 subgoal):\n 1. d_OUT (f (Suc n)) (enum m) \\<le> weight \\<Gamma> (enum m)", "by(rule currentD_weight_OUT)"], ["proof (state)\nthis:\n  d_OUT (f (Suc n)) (enum m) \\<le> weight \\<Gamma> (enum m)\n\ngoal (2 subgoals):\n 1. \\<And>n m.\n       \\<lbrakk>current \\<Gamma> (f n);\n        \\<And>m.\n           m < n \\<Longrightarrow>\n           d_OUT (f n) (enum m) = weight \\<Gamma> (enum m);\n        \\<not> hindered (\\<Gamma> \\<ominus> f n); m < Suc n\\<rbrakk>\n       \\<Longrightarrow> d_OUT (f (Suc n)) (enum m) =\n                         weight \\<Gamma> (enum m)\n 2. \\<And>n.\n       \\<lbrakk>current \\<Gamma> (f n);\n        \\<And>m.\n           m < n \\<Longrightarrow>\n           d_OUT (f n) (enum m) = weight \\<Gamma> (enum m);\n        \\<not> hindered (\\<Gamma> \\<ominus> f n)\\<rbrakk>\n       \\<Longrightarrow> \\<not> hindered (\\<Gamma> \\<ominus> f (Suc n))", "moreover"], ["proof (state)\nthis:\n  d_OUT (f (Suc n)) (enum m) \\<le> weight \\<Gamma> (enum m)\n\ngoal (2 subgoals):\n 1. \\<And>n m.\n       \\<lbrakk>current \\<Gamma> (f n);\n        \\<And>m.\n           m < n \\<Longrightarrow>\n           d_OUT (f n) (enum m) = weight \\<Gamma> (enum m);\n        \\<not> hindered (\\<Gamma> \\<ominus> f n); m < Suc n\\<rbrakk>\n       \\<Longrightarrow> d_OUT (f (Suc n)) (enum m) =\n                         weight \\<Gamma> (enum m)\n 2. \\<And>n.\n       \\<lbrakk>current \\<Gamma> (f n);\n        \\<And>m.\n           m < n \\<Longrightarrow>\n           d_OUT (f n) (enum m) = weight \\<Gamma> (enum m);\n        \\<not> hindered (\\<Gamma> \\<ominus> f n)\\<rbrakk>\n       \\<Longrightarrow> \\<not> hindered (\\<Gamma> \\<ominus> f (Suc n))", "have \"weight \\<Gamma> (enum m) \\<le> d_OUT (f (Suc n)) (enum m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. weight \\<Gamma> (enum m) \\<le> d_OUT (f (Suc n)) (enum m)", "proof(cases \"m = n\")"], ["proof (state)\ngoal (2 subgoals):\n 1. m = n \\<Longrightarrow>\n    weight \\<Gamma> (enum m) \\<le> d_OUT (f (Suc n)) (enum m)\n 2. m \\<noteq> n \\<Longrightarrow>\n    weight \\<Gamma> (enum m) \\<le> d_OUT (f (Suc n)) (enum m)", "case True"], ["proof (state)\nthis:\n  m = n\n\ngoal (2 subgoals):\n 1. m = n \\<Longrightarrow>\n    weight \\<Gamma> (enum m) \\<le> d_OUT (f (Suc n)) (enum m)\n 2. m \\<noteq> n \\<Longrightarrow>\n    weight \\<Gamma> (enum m) \\<le> d_OUT (f (Suc n)) (enum m)", "then"], ["proof (chain)\npicking this:\n  m = n", "show ?thesis"], ["proof (prove)\nusing this:\n  m = n\n\ngoal (1 subgoal):\n 1. weight \\<Gamma> (enum m) \\<le> d_OUT (f (Suc n)) (enum m)", "unfolding f_Suc"], ["proof (prove)\nusing this:\n  m = n\n\ngoal (1 subgoal):\n 1. weight \\<Gamma> (enum m) \\<le> d_OUT (plus_current (f n) f') (enum m)", "using OUT True"], ["proof (prove)\nusing this:\n  m = n\n  d_OUT f' (enum n) = weight (\\<Gamma> \\<ominus> f n) (enum n)\n  m = n\n\ngoal (1 subgoal):\n 1. weight \\<Gamma> (enum m) \\<le> d_OUT (plus_current (f n) f') (enum m)", "by(simp add: d_OUT_def nn_integral_add enum_A add_diff_self_ennreal less_imp_le)"], ["proof (state)\nthis:\n  weight \\<Gamma> (enum m) \\<le> d_OUT (f (Suc n)) (enum m)\n\ngoal (1 subgoal):\n 1. m \\<noteq> n \\<Longrightarrow>\n    weight \\<Gamma> (enum m) \\<le> d_OUT (f (Suc n)) (enum m)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. m \\<noteq> n \\<Longrightarrow>\n    weight \\<Gamma> (enum m) \\<le> d_OUT (f (Suc n)) (enum m)", "case False"], ["proof (state)\nthis:\n  m \\<noteq> n\n\ngoal (1 subgoal):\n 1. m \\<noteq> n \\<Longrightarrow>\n    weight \\<Gamma> (enum m) \\<le> d_OUT (f (Suc n)) (enum m)", "hence \"m < n\""], ["proof (prove)\nusing this:\n  m \\<noteq> n\n\ngoal (1 subgoal):\n 1. m < n", "using 2"], ["proof (prove)\nusing this:\n  m \\<noteq> n\n  m < Suc n\n\ngoal (1 subgoal):\n 1. m < n", "by simp"], ["proof (state)\nthis:\n  m < n\n\ngoal (1 subgoal):\n 1. m \\<noteq> n \\<Longrightarrow>\n    weight \\<Gamma> (enum m) \\<le> d_OUT (f (Suc n)) (enum m)", "thus ?thesis"], ["proof (prove)\nusing this:\n  m < n\n\ngoal (1 subgoal):\n 1. weight \\<Gamma> (enum m) \\<le> d_OUT (f (Suc n)) (enum m)", "using Suc.IH(2)[OF \\<open>m < n\\<close>]"], ["proof (prove)\nusing this:\n  m < n\n  d_OUT (f n) (enum m) = weight \\<Gamma> (enum m)\n\ngoal (1 subgoal):\n 1. weight \\<Gamma> (enum m) \\<le> d_OUT (f (Suc n)) (enum m)", "unfolding f_Suc"], ["proof (prove)\nusing this:\n  m < n\n  d_OUT (f n) (enum m) = weight \\<Gamma> (enum m)\n\ngoal (1 subgoal):\n 1. weight \\<Gamma> (enum m) \\<le> d_OUT (plus_current (f n) f') (enum m)", "by(simp add: d_OUT_def nn_integral_add add_increasing2 )"], ["proof (state)\nthis:\n  weight \\<Gamma> (enum m) \\<le> d_OUT (f (Suc n)) (enum m)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  weight \\<Gamma> (enum m) \\<le> d_OUT (f (Suc n)) (enum m)\n\ngoal (2 subgoals):\n 1. \\<And>n m.\n       \\<lbrakk>current \\<Gamma> (f n);\n        \\<And>m.\n           m < n \\<Longrightarrow>\n           d_OUT (f n) (enum m) = weight \\<Gamma> (enum m);\n        \\<not> hindered (\\<Gamma> \\<ominus> f n); m < Suc n\\<rbrakk>\n       \\<Longrightarrow> d_OUT (f (Suc n)) (enum m) =\n                         weight \\<Gamma> (enum m)\n 2. \\<And>n.\n       \\<lbrakk>current \\<Gamma> (f n);\n        \\<And>m.\n           m < n \\<Longrightarrow>\n           d_OUT (f n) (enum m) = weight \\<Gamma> (enum m);\n        \\<not> hindered (\\<Gamma> \\<ominus> f n)\\<rbrakk>\n       \\<Longrightarrow> \\<not> hindered (\\<Gamma> \\<ominus> f (Suc n))", "ultimately"], ["proof (chain)\npicking this:\n  d_OUT (f (Suc n)) (enum m) \\<le> weight \\<Gamma> (enum m)\n  weight \\<Gamma> (enum m) \\<le> d_OUT (f (Suc n)) (enum m)", "show ?case"], ["proof (prove)\nusing this:\n  d_OUT (f (Suc n)) (enum m) \\<le> weight \\<Gamma> (enum m)\n  weight \\<Gamma> (enum m) \\<le> d_OUT (f (Suc n)) (enum m)\n\ngoal (1 subgoal):\n 1. d_OUT (f (Suc n)) (enum m) = weight \\<Gamma> (enum m)", "by(rule antisym)"], ["proof (state)\nthis:\n  d_OUT (f (Suc n)) (enum m) = weight \\<Gamma> (enum m)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>current \\<Gamma> (f n);\n        \\<And>m.\n           m < n \\<Longrightarrow>\n           d_OUT (f n) (enum m) = weight \\<Gamma> (enum m);\n        \\<not> hindered (\\<Gamma> \\<ominus> f n)\\<rbrakk>\n       \\<Longrightarrow> \\<not> hindered (\\<Gamma> \\<ominus> f (Suc n))", "}"], ["proof (state)\nthis:\n  ?m2 < Suc n \\<Longrightarrow>\n  d_OUT (f (Suc n)) (enum ?m2) = weight \\<Gamma> (enum ?m2)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>current \\<Gamma> (f n);\n        \\<And>m.\n           m < n \\<Longrightarrow>\n           d_OUT (f n) (enum m) = weight \\<Gamma> (enum m);\n        \\<not> hindered (\\<Gamma> \\<ominus> f n)\\<rbrakk>\n       \\<Longrightarrow> \\<not> hindered (\\<Gamma> \\<ominus> f (Suc n))", "{"], ["proof (state)\nthis:\n  ?m2 < Suc n \\<Longrightarrow>\n  d_OUT (f (Suc n)) (enum ?m2) = weight \\<Gamma> (enum ?m2)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>current \\<Gamma> (f n);\n        \\<And>m.\n           m < n \\<Longrightarrow>\n           d_OUT (f n) (enum m) = weight \\<Gamma> (enum m);\n        \\<not> hindered (\\<Gamma> \\<ominus> f n)\\<rbrakk>\n       \\<Longrightarrow> \\<not> hindered (\\<Gamma> \\<ominus> f (Suc n))", "case 3"], ["proof (state)\nthis:\n  \n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>current \\<Gamma> (f n);\n        \\<And>m.\n           m < n \\<Longrightarrow>\n           d_OUT (f n) (enum m) = weight \\<Gamma> (enum m);\n        \\<not> hindered (\\<Gamma> \\<ominus> f n)\\<rbrakk>\n       \\<Longrightarrow> \\<not> hindered (\\<Gamma> \\<ominus> f (Suc n))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> hindered (\\<Gamma> \\<ominus> f (Suc n))", "unfolding f_Suc minus_plus_current[OF Suc.IH(1) f']"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> hindered (\\<Gamma> \\<ominus> f n \\<ominus> f')", "by(rule unhindered')"], ["proof (state)\nthis:\n  \\<not> hindered (\\<Gamma> \\<ominus> f (Suc n))\n\ngoal:\nNo subgoals!", "}"], ["proof (state)\nthis:\n  \\<not> hindered (\\<Gamma> \\<ominus> f (Suc n))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  current \\<Gamma> (f ?n)\n  ?m < ?n1 \\<Longrightarrow>\n  d_OUT (f ?n1) (enum ?m) = weight \\<Gamma> (enum ?m)\n  \\<not> hindered (\\<Gamma> \\<ominus> f ?n)\n\ngoal (1 subgoal):\n 1. A \\<Gamma> \\<noteq> {} \\<Longrightarrow> linkable \\<Gamma>", "interpret \\<Gamma>: countable_bipartite_web \"\\<Gamma> \\<ominus> f n\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. countable_bipartite_web (\\<Gamma> \\<ominus> f n)", "using f"], ["proof (prove)\nusing this:\n  current \\<Gamma> (f ?n)\n\ngoal (1 subgoal):\n 1. countable_bipartite_web (\\<Gamma> \\<ominus> f n)", "by(rule countable_bipartite_web_minus_web)"], ["proof (state)\ngoal (1 subgoal):\n 1. A \\<Gamma> \\<noteq> {} \\<Longrightarrow> linkable \\<Gamma>", "have Ex_P: \"Ex (?P (f n) (enum n))\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>f'.\n       current (\\<Gamma> \\<ominus> f n) f' \\<and>\n       d_OUT f' (enum n) = weight (\\<Gamma> \\<ominus> f n) (enum n) \\<and>\n       \\<not> hindered (\\<Gamma> \\<ominus> f n \\<ominus> f')", "using unhindered"], ["proof (prove)\nusing this:\n  \\<not> hindered (\\<Gamma> \\<ominus> f ?n)\n\ngoal (1 subgoal):\n 1. \\<exists>f'.\n       current (\\<Gamma> \\<ominus> f n) f' \\<and>\n       d_OUT f' (enum n) = weight (\\<Gamma> \\<ominus> f n) (enum n) \\<and>\n       \\<not> hindered (\\<Gamma> \\<ominus> f n \\<ominus> f')", "by(rule \\<Gamma>.unhindered_saturate1)(simp add: enum_A)"], ["proof (state)\nthis:\n  \\<exists>f'.\n     current (\\<Gamma> \\<ominus> f ?n) f' \\<and>\n     d_OUT f' (enum ?n) = weight (\\<Gamma> \\<ominus> f ?n) (enum ?n) \\<and>\n     \\<not> hindered (\\<Gamma> \\<ominus> f ?n \\<ominus> f')\n\ngoal (1 subgoal):\n 1. A \\<Gamma> \\<noteq> {} \\<Longrightarrow> linkable \\<Gamma>", "have f_mono: \"f n \\<le> f (Suc n)\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. f n \\<le> f (Suc n)", "using someI_ex[OF Ex_P, of n]"], ["proof (prove)\nusing this:\n  current (\\<Gamma> \\<ominus> f n)\n   (SOME x.\n       current (\\<Gamma> \\<ominus> f n) x \\<and>\n       d_OUT x (enum n) = weight (\\<Gamma> \\<ominus> f n) (enum n) \\<and>\n       \\<not> hindered (\\<Gamma> \\<ominus> f n \\<ominus> x)) \\<and>\n  d_OUT\n   (SOME x.\n       current (\\<Gamma> \\<ominus> f n) x \\<and>\n       d_OUT x (enum n) = weight (\\<Gamma> \\<ominus> f n) (enum n) \\<and>\n       \\<not> hindered (\\<Gamma> \\<ominus> f n \\<ominus> x))\n   (enum n) =\n  weight (\\<Gamma> \\<ominus> f n) (enum n) \\<and>\n  \\<not> hindered\n          (\\<Gamma> \\<ominus> f n \\<ominus>\n           (SOME x.\n               current (\\<Gamma> \\<ominus> f n) x \\<and>\n               d_OUT x (enum n) =\n               weight (\\<Gamma> \\<ominus> f n) (enum n) \\<and>\n               \\<not> hindered (\\<Gamma> \\<ominus> f n \\<ominus> x)))\n\ngoal (1 subgoal):\n 1. f n \\<le> f (Suc n)", "by(auto simp add: le_fun_def f_Suc enum_A intro: add_increasing2 dest: )"], ["proof (state)\nthis:\n  f ?n \\<le> f (Suc ?n)\n\ngoal (1 subgoal):\n 1. A \\<Gamma> \\<noteq> {} \\<Longrightarrow> linkable \\<Gamma>", "hence incseq: \"incseq f\""], ["proof (prove)\nusing this:\n  f ?n \\<le> f (Suc ?n)\n\ngoal (1 subgoal):\n 1. incseq f", "by(rule incseq_SucI)"], ["proof (state)\nthis:\n  incseq f\n\ngoal (1 subgoal):\n 1. A \\<Gamma> \\<noteq> {} \\<Longrightarrow> linkable \\<Gamma>", "hence chain: \"Complete_Partial_Order.chain (\\<le>) (range f)\""], ["proof (prove)\nusing this:\n  incseq f\n\ngoal (1 subgoal):\n 1. Complete_Partial_Order.chain (\\<le>) (range f)", "by(rule incseq_chain_range)"], ["proof (state)\nthis:\n  Complete_Partial_Order.chain (\\<le>) (range f)\n\ngoal (1 subgoal):\n 1. A \\<Gamma> \\<noteq> {} \\<Longrightarrow> linkable \\<Gamma>", "define g where \"g = Sup (range f)\""], ["proof (state)\nthis:\n  g = \\<Squnion> range f\n\ngoal (1 subgoal):\n 1. A \\<Gamma> \\<noteq> {} \\<Longrightarrow> linkable \\<Gamma>", "have \"support_flow g \\<subseteq> \\<^bold>E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. support_flow g \\<subseteq> \\<^bold>E", "by (auto simp add: g_def support_flow.simps currentD_outside [OF f] image_comp elim: contrapos_pp)"], ["proof (state)\nthis:\n  support_flow g \\<subseteq> \\<^bold>E\n\ngoal (1 subgoal):\n 1. A \\<Gamma> \\<noteq> {} \\<Longrightarrow> linkable \\<Gamma>", "then"], ["proof (chain)\npicking this:\n  support_flow g \\<subseteq> \\<^bold>E", "have countable_g: \"countable (support_flow g)\""], ["proof (prove)\nusing this:\n  support_flow g \\<subseteq> \\<^bold>E\n\ngoal (1 subgoal):\n 1. countable (support_flow g)", "by(rule countable_subset) simp"], ["proof (state)\nthis:\n  countable (support_flow g)\n\ngoal (1 subgoal):\n 1. A \\<Gamma> \\<noteq> {} \\<Longrightarrow> linkable \\<Gamma>", "with chain _ _"], ["proof (chain)\npicking this:\n  Complete_Partial_Order.chain (\\<le>) (range f)\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  countable (support_flow g)", "have g: \"current \\<Gamma> g\""], ["proof (prove)\nusing this:\n  Complete_Partial_Order.chain (\\<le>) (range f)\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  countable (support_flow g)\n\ngoal (1 subgoal):\n 1. current \\<Gamma> g", "unfolding g_def"], ["proof (prove)\nusing this:\n  Complete_Partial_Order.chain (\\<le>) (range f)\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  countable (support_flow (\\<Squnion> range f))\n\ngoal (1 subgoal):\n 1. current \\<Gamma> (\\<Squnion> range f)", "by(rule current_Sup)(auto simp add: f)"], ["proof (state)\nthis:\n  current \\<Gamma> g\n\ngoal (1 subgoal):\n 1. A \\<Gamma> \\<noteq> {} \\<Longrightarrow> linkable \\<Gamma>", "moreover"], ["proof (state)\nthis:\n  current \\<Gamma> g\n\ngoal (1 subgoal):\n 1. A \\<Gamma> \\<noteq> {} \\<Longrightarrow> linkable \\<Gamma>", "have \"d_OUT g x = weight \\<Gamma> x\" if \"x \\<in> A \\<Gamma>\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT g x = weight \\<Gamma> x", "proof(rule antisym)"], ["proof (state)\ngoal (2 subgoals):\n 1. d_OUT g x \\<le> weight \\<Gamma> x\n 2. weight \\<Gamma> x \\<le> d_OUT g x", "show \"d_OUT g x \\<le> weight \\<Gamma> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_OUT g x \\<le> weight \\<Gamma> x", "using g"], ["proof (prove)\nusing this:\n  current \\<Gamma> g\n\ngoal (1 subgoal):\n 1. d_OUT g x \\<le> weight \\<Gamma> x", "by(rule currentD_weight_OUT)"], ["proof (state)\nthis:\n  d_OUT g x \\<le> weight \\<Gamma> x\n\ngoal (1 subgoal):\n 1. weight \\<Gamma> x \\<le> d_OUT g x", "have \"countable (A \\<Gamma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. countable (A \\<Gamma>)", "using A_vertex"], ["proof (prove)\nusing this:\n  A \\<Gamma> \\<subseteq> \\<^bold>V\n\ngoal (1 subgoal):\n 1. countable (A \\<Gamma>)", "by(rule countable_subset) simp"], ["proof (state)\nthis:\n  countable (A \\<Gamma>)\n\ngoal (1 subgoal):\n 1. weight \\<Gamma> x \\<le> d_OUT g x", "from that subset_range_from_nat_into[OF this]"], ["proof (chain)\npicking this:\n  x \\<in> A \\<Gamma>\n  A \\<Gamma> \\<subseteq> range (from_nat_into (A \\<Gamma>))", "obtain n where \"x = enum n\""], ["proof (prove)\nusing this:\n  x \\<in> A \\<Gamma>\n  A \\<Gamma> \\<subseteq> range (from_nat_into (A \\<Gamma>))\n\ngoal (1 subgoal):\n 1. (\\<And>n. x = enum n \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "unfolding enum_def"], ["proof (prove)\nusing this:\n  x \\<in> A \\<Gamma>\n  A \\<Gamma> \\<subseteq> range (from_nat_into (A \\<Gamma>))\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        x = from_nat_into (A \\<Gamma>) n \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  x = enum n\n\ngoal (1 subgoal):\n 1. weight \\<Gamma> x \\<le> d_OUT g x", "with sat[of n \"Suc n\"]"], ["proof (chain)\npicking this:\n  n < Suc n \\<Longrightarrow>\n  d_OUT (f (Suc n)) (enum n) = weight \\<Gamma> (enum n)\n  x = enum n", "have \"d_OUT (f (Suc n)) x \\<ge> weight \\<Gamma> x\""], ["proof (prove)\nusing this:\n  n < Suc n \\<Longrightarrow>\n  d_OUT (f (Suc n)) (enum n) = weight \\<Gamma> (enum n)\n  x = enum n\n\ngoal (1 subgoal):\n 1. weight \\<Gamma> x \\<le> d_OUT (f (Suc n)) x", "by simp"], ["proof (state)\nthis:\n  weight \\<Gamma> x \\<le> d_OUT (f (Suc n)) x\n\ngoal (1 subgoal):\n 1. weight \\<Gamma> x \\<le> d_OUT g x", "then"], ["proof (chain)\npicking this:\n  weight \\<Gamma> x \\<le> d_OUT (f (Suc n)) x", "show \"weight \\<Gamma> x \\<le> d_OUT g x\""], ["proof (prove)\nusing this:\n  weight \\<Gamma> x \\<le> d_OUT (f (Suc n)) x\n\ngoal (1 subgoal):\n 1. weight \\<Gamma> x \\<le> d_OUT g x", "using countable_g"], ["proof (prove)\nusing this:\n  weight \\<Gamma> x \\<le> d_OUT (f (Suc n)) x\n  countable (support_flow g)\n\ngoal (1 subgoal):\n 1. weight \\<Gamma> x \\<le> d_OUT g x", "unfolding g_def"], ["proof (prove)\nusing this:\n  weight \\<Gamma> x \\<le> d_OUT (f (Suc n)) x\n  countable (support_flow (\\<Squnion> range f))\n\ngoal (1 subgoal):\n 1. weight \\<Gamma> x \\<le> d_OUT (\\<Squnion> range f) x", "by(subst d_OUT_Sup[OF chain])(auto intro: SUP_upper2)"], ["proof (state)\nthis:\n  weight \\<Gamma> x \\<le> d_OUT g x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?x \\<in> A \\<Gamma> \\<Longrightarrow> d_OUT g ?x = weight \\<Gamma> ?x\n\ngoal (1 subgoal):\n 1. A \\<Gamma> \\<noteq> {} \\<Longrightarrow> linkable \\<Gamma>", "ultimately"], ["proof (chain)\npicking this:\n  current \\<Gamma> g\n  ?x \\<in> A \\<Gamma> \\<Longrightarrow> d_OUT g ?x = weight \\<Gamma> ?x", "show ?thesis"], ["proof (prove)\nusing this:\n  current \\<Gamma> g\n  ?x \\<in> A \\<Gamma> \\<Longrightarrow> d_OUT g ?x = weight \\<Gamma> ?x\n\ngoal (1 subgoal):\n 1. linkable \\<Gamma>", "by(auto simp add: web_flow_iff linkage.simps)"], ["proof (state)\nthis:\n  linkable \\<Gamma>\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "context countable_web begin"], ["", "theorem loose_linkable: \\<comment> \\<open>Theorem 6.2\\<close>\n  assumes \"loose \\<Gamma>\"\n  shows \"linkable \\<Gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. linkable \\<Gamma>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. linkable \\<Gamma>", "interpret bi: countable_bipartite_web \"bipartite_web_of \\<Gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. countable_bipartite_web (bipartite_web_of \\<Gamma>)", "by(rule countable_bipartite_web_of)"], ["proof (state)\ngoal (1 subgoal):\n 1. linkable \\<Gamma>", "have \"\\<not> hindered (bipartite_web_of \\<Gamma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> hindered (bipartite_web_of \\<Gamma>)", "using assms"], ["proof (prove)\nusing this:\n  loose \\<Gamma>\n\ngoal (1 subgoal):\n 1. \\<not> hindered (bipartite_web_of \\<Gamma>)", "by(rule unhindered_bipartite_web_of)"], ["proof (state)\nthis:\n  \\<not> hindered (bipartite_web_of \\<Gamma>)\n\ngoal (1 subgoal):\n 1. linkable \\<Gamma>", "then"], ["proof (chain)\npicking this:\n  \\<not> hindered (bipartite_web_of \\<Gamma>)", "have \"linkable (bipartite_web_of \\<Gamma>)\""], ["proof (prove)\nusing this:\n  \\<not> hindered (bipartite_web_of \\<Gamma>)\n\ngoal (1 subgoal):\n 1. linkable (bipartite_web_of \\<Gamma>)", "by(rule bi.unhindered_linkable)"], ["proof (state)\nthis:\n  linkable (bipartite_web_of \\<Gamma>)\n\ngoal (1 subgoal):\n 1. linkable \\<Gamma>", "then"], ["proof (chain)\npicking this:\n  linkable (bipartite_web_of \\<Gamma>)", "show ?thesis"], ["proof (prove)\nusing this:\n  linkable (bipartite_web_of \\<Gamma>)\n\ngoal (1 subgoal):\n 1. linkable \\<Gamma>", "by(rule linkable_bipartite_web_ofD) simp"], ["proof (state)\nthis:\n  linkable \\<Gamma>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ex_orthogonal_current: \\<comment> \\<open>Lemma 4.15\\<close>\n  \"\\<exists>f S. web_flow \\<Gamma> f \\<and> separating \\<Gamma> S \\<and> orthogonal_current \\<Gamma> f S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>f S.\n       web_flow \\<Gamma> f \\<and>\n       separating \\<Gamma> S \\<and> orthogonal_current \\<Gamma> f S", "by(rule ex_orthogonal_current')(rule countable_web.loose_linkable[OF countable_web_quotient_web])"], ["", "end"], ["", "subsection \\<open>Glueing the reductions together\\<close>"], ["", "context countable_network begin"], ["", "context begin"], ["", "qualified"], ["", "lemma max_flow_min_cut':\n  assumes source_in: \"\\<And>x. \\<not> edge \\<Delta> x (source \\<Delta>)\"\n  and sink_out: \"\\<And>y. \\<not> edge \\<Delta> (sink \\<Delta>) y\"\n  and undead: \"\\<And>x y. edge \\<Delta> x y \\<Longrightarrow> (\\<exists>z. edge \\<Delta> y z) \\<or> (\\<exists>z. edge \\<Delta> z x)\"\n  and source_sink: \"\\<not> edge \\<Delta> (source \\<Delta>) (sink \\<Delta>)\"\n  and no_loop: \"\\<And>x. \\<not> edge \\<Delta> x x\"\n  and capacity_pos: \"\\<And>e. e \\<in> \\<^bold>E \\<Longrightarrow> capacity \\<Delta> e > 0\"\n  shows \"\\<exists>f S. flow \\<Delta> f \\<and> cut \\<Delta> S \\<and> orthogonal \\<Delta> f S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>f S.\n       flow \\<Delta> f \\<and> cut \\<Delta> S \\<and> orthogonal \\<Delta> f S", "by(rule max_flow_min_cut')(rule countable_web.ex_orthogonal_current[OF countable_web_web_of_network], fact+)"], ["", "qualified"], ["", "lemma max_flow_min_cut'':\n  assumes sink_out: \"\\<And>y. \\<not> edge \\<Delta> (sink \\<Delta>) y\"\n  and source_in: \"\\<And>x. \\<not> edge \\<Delta> x (source \\<Delta>)\"\n  and no_loop: \"\\<And>x. \\<not> edge \\<Delta> x x\"\n  and capacity_pos: \"\\<And>e. e \\<in> \\<^bold>E \\<Longrightarrow> capacity \\<Delta> e > 0\"\n  shows \"\\<exists>f S. flow \\<Delta> f \\<and> cut \\<Delta> S \\<and> orthogonal \\<Delta> f S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>f S.\n       flow \\<Delta> f \\<and> cut \\<Delta> S \\<and> orthogonal \\<Delta> f S", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>f S.\n       flow \\<Delta> f \\<and> cut \\<Delta> S \\<and> orthogonal \\<Delta> f S", "interpret antiparallel_edges \\<Delta>"], ["proof (prove)\ngoal (1 subgoal):\n 1. antiparallel_edges \\<Delta>", ".."], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>f S.\n       flow \\<Delta> f \\<and> cut \\<Delta> S \\<and> orthogonal \\<Delta> f S", "interpret \\<Delta>'': countable_network \\<Delta>''"], ["proof (prove)\ngoal (1 subgoal):\n 1. countable_network \\<Delta>''", "by(rule \\<Delta>''_countable_network)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>f S.\n       flow \\<Delta> f \\<and> cut \\<Delta> S \\<and> orthogonal \\<Delta> f S", "have \"\\<exists>f S. flow \\<Delta>'' f \\<and> cut \\<Delta>'' S \\<and> orthogonal \\<Delta>'' f S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>f S.\n       flow \\<Delta>'' f \\<and>\n       cut \\<Delta>'' S \\<and> orthogonal \\<Delta>'' f S", "by(rule \\<Delta>''.max_flow_min_cut')(auto simp add: sink_out source_in no_loop capacity_pos elim: edg.cases)"], ["proof (state)\nthis:\n  \\<exists>f S.\n     flow \\<Delta>'' f \\<and>\n     cut \\<Delta>'' S \\<and> orthogonal \\<Delta>'' f S\n\ngoal (1 subgoal):\n 1. \\<exists>f S.\n       flow \\<Delta> f \\<and> cut \\<Delta> S \\<and> orthogonal \\<Delta> f S", "then"], ["proof (chain)\npicking this:\n  \\<exists>f S.\n     flow \\<Delta>'' f \\<and>\n     cut \\<Delta>'' S \\<and> orthogonal \\<Delta>'' f S", "obtain f S where f: \"flow \\<Delta>'' f\" and cut: \"cut \\<Delta>'' S\" and ortho: \"orthogonal \\<Delta>'' f S\""], ["proof (prove)\nusing this:\n  \\<exists>f S.\n     flow \\<Delta>'' f \\<and>\n     cut \\<Delta>'' S \\<and> orthogonal \\<Delta>'' f S\n\ngoal (1 subgoal):\n 1. (\\<And>f S.\n        \\<lbrakk>flow \\<Delta>'' f; cut \\<Delta>'' S;\n         orthogonal \\<Delta>'' f S\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  flow \\<Delta>'' f\n  cut \\<Delta>'' S\n  orthogonal \\<Delta>'' f S\n\ngoal (1 subgoal):\n 1. \\<exists>f S.\n       flow \\<Delta> f \\<and> cut \\<Delta> S \\<and> orthogonal \\<Delta> f S", "have \"flow \\<Delta> (collect f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. flow \\<Delta> (\\<lambda>(x, y). f (Edge x y, Vertex y))", "using f"], ["proof (prove)\nusing this:\n  flow \\<Delta>'' f\n\ngoal (1 subgoal):\n 1. flow \\<Delta> (\\<lambda>(x, y). f (Edge x y, Vertex y))", "by(rule flow_collect)"], ["proof (state)\nthis:\n  flow \\<Delta> (\\<lambda>(x, y). f (Edge x y, Vertex y))\n\ngoal (1 subgoal):\n 1. \\<exists>f S.\n       flow \\<Delta> f \\<and> cut \\<Delta> S \\<and> orthogonal \\<Delta> f S", "moreover"], ["proof (state)\nthis:\n  flow \\<Delta> (\\<lambda>(x, y). f (Edge x y, Vertex y))\n\ngoal (1 subgoal):\n 1. \\<exists>f S.\n       flow \\<Delta> f \\<and> cut \\<Delta> S \\<and> orthogonal \\<Delta> f S", "have \"cut \\<Delta> (cut' S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cut \\<Delta> (Vertex -` S)", "using cut"], ["proof (prove)\nusing this:\n  cut \\<Delta>'' S\n\ngoal (1 subgoal):\n 1. cut \\<Delta> (Vertex -` S)", "by(rule cut_cut')"], ["proof (state)\nthis:\n  cut \\<Delta> (Vertex -` S)\n\ngoal (1 subgoal):\n 1. \\<exists>f S.\n       flow \\<Delta> f \\<and> cut \\<Delta> S \\<and> orthogonal \\<Delta> f S", "moreover"], ["proof (state)\nthis:\n  cut \\<Delta> (Vertex -` S)\n\ngoal (1 subgoal):\n 1. \\<exists>f S.\n       flow \\<Delta> f \\<and> cut \\<Delta> S \\<and> orthogonal \\<Delta> f S", "have \"orthogonal \\<Delta> (collect f) (cut' S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. orthogonal \\<Delta> (\\<lambda>(x, y). f (Edge x y, Vertex y))\n     (Vertex -` S)", "using ortho f"], ["proof (prove)\nusing this:\n  orthogonal \\<Delta>'' f S\n  flow \\<Delta>'' f\n\ngoal (1 subgoal):\n 1. orthogonal \\<Delta> (\\<lambda>(x, y). f (Edge x y, Vertex y))\n     (Vertex -` S)", "by(rule orthogonal_cut')"], ["proof (state)\nthis:\n  orthogonal \\<Delta> (\\<lambda>(x, y). f (Edge x y, Vertex y))\n   (Vertex -` S)\n\ngoal (1 subgoal):\n 1. \\<exists>f S.\n       flow \\<Delta> f \\<and> cut \\<Delta> S \\<and> orthogonal \\<Delta> f S", "ultimately"], ["proof (chain)\npicking this:\n  flow \\<Delta> (\\<lambda>(x, y). f (Edge x y, Vertex y))\n  cut \\<Delta> (Vertex -` S)\n  orthogonal \\<Delta> (\\<lambda>(x, y). f (Edge x y, Vertex y))\n   (Vertex -` S)", "show ?thesis"], ["proof (prove)\nusing this:\n  flow \\<Delta> (\\<lambda>(x, y). f (Edge x y, Vertex y))\n  cut \\<Delta> (Vertex -` S)\n  orthogonal \\<Delta> (\\<lambda>(x, y). f (Edge x y, Vertex y))\n   (Vertex -` S)\n\ngoal (1 subgoal):\n 1. \\<exists>f S.\n       flow \\<Delta> f \\<and> cut \\<Delta> S \\<and> orthogonal \\<Delta> f S", "by blast"], ["proof (state)\nthis:\n  \\<exists>f S.\n     flow \\<Delta> f \\<and> cut \\<Delta> S \\<and> orthogonal \\<Delta> f S\n\ngoal:\nNo subgoals!", "qed"], ["", "qualified"], ["", "lemma max_flow_min_cut''':\n  assumes sink_out: \"\\<And>y. \\<not> edge \\<Delta> (sink \\<Delta>) y\"\n  and source_in: \"\\<And>x. \\<not> edge \\<Delta> x (source \\<Delta>)\"\n  and capacity_pos: \"\\<And>e. e \\<in> \\<^bold>E \\<Longrightarrow> capacity \\<Delta> e > 0\"\n  shows \"\\<exists>f S. flow \\<Delta> f \\<and> cut \\<Delta> S \\<and> orthogonal \\<Delta> f S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>f S.\n       flow \\<Delta> f \\<and> cut \\<Delta> S \\<and> orthogonal \\<Delta> f S", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>f S.\n       flow \\<Delta> f \\<and> cut \\<Delta> S \\<and> orthogonal \\<Delta> f S", "interpret antiparallel_edges \\<Delta>"], ["proof (prove)\ngoal (1 subgoal):\n 1. antiparallel_edges \\<Delta>", ".."], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>f S.\n       flow \\<Delta> f \\<and> cut \\<Delta> S \\<and> orthogonal \\<Delta> f S", "interpret \\<Delta>'': countable_network \\<Delta>''"], ["proof (prove)\ngoal (1 subgoal):\n 1. countable_network \\<Delta>''", "by(rule \\<Delta>''_countable_network)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>f S.\n       flow \\<Delta> f \\<and> cut \\<Delta> S \\<and> orthogonal \\<Delta> f S", "have \"\\<exists>f S. flow \\<Delta>'' f \\<and> cut \\<Delta>'' S \\<and> orthogonal \\<Delta>'' f S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>f S.\n       flow \\<Delta>'' f \\<and>\n       cut \\<Delta>'' S \\<and> orthogonal \\<Delta>'' f S", "by(rule \\<Delta>''.max_flow_min_cut'')(auto simp add: sink_out source_in capacity_pos elim: edg.cases)"], ["proof (state)\nthis:\n  \\<exists>f S.\n     flow \\<Delta>'' f \\<and>\n     cut \\<Delta>'' S \\<and> orthogonal \\<Delta>'' f S\n\ngoal (1 subgoal):\n 1. \\<exists>f S.\n       flow \\<Delta> f \\<and> cut \\<Delta> S \\<and> orthogonal \\<Delta> f S", "then"], ["proof (chain)\npicking this:\n  \\<exists>f S.\n     flow \\<Delta>'' f \\<and>\n     cut \\<Delta>'' S \\<and> orthogonal \\<Delta>'' f S", "obtain f S where f: \"flow \\<Delta>'' f\" and cut: \"cut \\<Delta>'' S\" and ortho: \"orthogonal \\<Delta>'' f S\""], ["proof (prove)\nusing this:\n  \\<exists>f S.\n     flow \\<Delta>'' f \\<and>\n     cut \\<Delta>'' S \\<and> orthogonal \\<Delta>'' f S\n\ngoal (1 subgoal):\n 1. (\\<And>f S.\n        \\<lbrakk>flow \\<Delta>'' f; cut \\<Delta>'' S;\n         orthogonal \\<Delta>'' f S\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  flow \\<Delta>'' f\n  cut \\<Delta>'' S\n  orthogonal \\<Delta>'' f S\n\ngoal (1 subgoal):\n 1. \\<exists>f S.\n       flow \\<Delta> f \\<and> cut \\<Delta> S \\<and> orthogonal \\<Delta> f S", "have \"flow \\<Delta> (collect f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. flow \\<Delta> (\\<lambda>(x, y). f (Edge x y, Vertex y))", "using f"], ["proof (prove)\nusing this:\n  flow \\<Delta>'' f\n\ngoal (1 subgoal):\n 1. flow \\<Delta> (\\<lambda>(x, y). f (Edge x y, Vertex y))", "by(rule flow_collect)"], ["proof (state)\nthis:\n  flow \\<Delta> (\\<lambda>(x, y). f (Edge x y, Vertex y))\n\ngoal (1 subgoal):\n 1. \\<exists>f S.\n       flow \\<Delta> f \\<and> cut \\<Delta> S \\<and> orthogonal \\<Delta> f S", "moreover"], ["proof (state)\nthis:\n  flow \\<Delta> (\\<lambda>(x, y). f (Edge x y, Vertex y))\n\ngoal (1 subgoal):\n 1. \\<exists>f S.\n       flow \\<Delta> f \\<and> cut \\<Delta> S \\<and> orthogonal \\<Delta> f S", "have \"cut \\<Delta> (cut' S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cut \\<Delta> (Vertex -` S)", "using cut"], ["proof (prove)\nusing this:\n  cut \\<Delta>'' S\n\ngoal (1 subgoal):\n 1. cut \\<Delta> (Vertex -` S)", "by(rule cut_cut')"], ["proof (state)\nthis:\n  cut \\<Delta> (Vertex -` S)\n\ngoal (1 subgoal):\n 1. \\<exists>f S.\n       flow \\<Delta> f \\<and> cut \\<Delta> S \\<and> orthogonal \\<Delta> f S", "moreover"], ["proof (state)\nthis:\n  cut \\<Delta> (Vertex -` S)\n\ngoal (1 subgoal):\n 1. \\<exists>f S.\n       flow \\<Delta> f \\<and> cut \\<Delta> S \\<and> orthogonal \\<Delta> f S", "have \"orthogonal \\<Delta> (collect f) (cut' S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. orthogonal \\<Delta> (\\<lambda>(x, y). f (Edge x y, Vertex y))\n     (Vertex -` S)", "using ortho f"], ["proof (prove)\nusing this:\n  orthogonal \\<Delta>'' f S\n  flow \\<Delta>'' f\n\ngoal (1 subgoal):\n 1. orthogonal \\<Delta> (\\<lambda>(x, y). f (Edge x y, Vertex y))\n     (Vertex -` S)", "by(rule orthogonal_cut')"], ["proof (state)\nthis:\n  orthogonal \\<Delta> (\\<lambda>(x, y). f (Edge x y, Vertex y))\n   (Vertex -` S)\n\ngoal (1 subgoal):\n 1. \\<exists>f S.\n       flow \\<Delta> f \\<and> cut \\<Delta> S \\<and> orthogonal \\<Delta> f S", "ultimately"], ["proof (chain)\npicking this:\n  flow \\<Delta> (\\<lambda>(x, y). f (Edge x y, Vertex y))\n  cut \\<Delta> (Vertex -` S)\n  orthogonal \\<Delta> (\\<lambda>(x, y). f (Edge x y, Vertex y))\n   (Vertex -` S)", "show ?thesis"], ["proof (prove)\nusing this:\n  flow \\<Delta> (\\<lambda>(x, y). f (Edge x y, Vertex y))\n  cut \\<Delta> (Vertex -` S)\n  orthogonal \\<Delta> (\\<lambda>(x, y). f (Edge x y, Vertex y))\n   (Vertex -` S)\n\ngoal (1 subgoal):\n 1. \\<exists>f S.\n       flow \\<Delta> f \\<and> cut \\<Delta> S \\<and> orthogonal \\<Delta> f S", "by blast"], ["proof (state)\nthis:\n  \\<exists>f S.\n     flow \\<Delta> f \\<and> cut \\<Delta> S \\<and> orthogonal \\<Delta> f S\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem max_flow_min_cut:\n  \"\\<exists>f S. flow \\<Delta> f \\<and> cut \\<Delta> S \\<and> orthogonal \\<Delta> f S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>f S.\n       flow \\<Delta> f \\<and> cut \\<Delta> S \\<and> orthogonal \\<Delta> f S", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>f S.\n       flow \\<Delta> f \\<and> cut \\<Delta> S \\<and> orthogonal \\<Delta> f S", "interpret \\<Delta>''': countable_network \\<Delta>'''"], ["proof (prove)\ngoal (1 subgoal):\n 1. countable_network \\<Delta>'''", "by(rule \\<Delta>'''_countable_network)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>f S.\n       flow \\<Delta> f \\<and> cut \\<Delta> S \\<and> orthogonal \\<Delta> f S", "have \"\\<exists>f S. flow \\<Delta>''' f \\<and> cut \\<Delta>''' S \\<and> orthogonal \\<Delta>''' f S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>f S.\n       flow \\<Delta>''' f \\<and>\n       cut \\<Delta>''' S \\<and> orthogonal \\<Delta>''' f S", "by(rule \\<Delta>'''.max_flow_min_cut''') auto"], ["proof (state)\nthis:\n  \\<exists>f S.\n     flow \\<Delta>''' f \\<and>\n     cut \\<Delta>''' S \\<and> orthogonal \\<Delta>''' f S\n\ngoal (1 subgoal):\n 1. \\<exists>f S.\n       flow \\<Delta> f \\<and> cut \\<Delta> S \\<and> orthogonal \\<Delta> f S", "then"], ["proof (chain)\npicking this:\n  \\<exists>f S.\n     flow \\<Delta>''' f \\<and>\n     cut \\<Delta>''' S \\<and> orthogonal \\<Delta>''' f S", "obtain f S where f: \"flow \\<Delta>''' f\" and cut: \"cut \\<Delta>''' S\" and ortho: \"orthogonal \\<Delta>''' f S\""], ["proof (prove)\nusing this:\n  \\<exists>f S.\n     flow \\<Delta>''' f \\<and>\n     cut \\<Delta>''' S \\<and> orthogonal \\<Delta>''' f S\n\ngoal (1 subgoal):\n 1. (\\<And>f S.\n        \\<lbrakk>flow \\<Delta>''' f; cut \\<Delta>''' S;\n         orthogonal \\<Delta>''' f S\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  flow \\<Delta>''' f\n  cut \\<Delta>''' S\n  orthogonal \\<Delta>''' f S\n\ngoal (1 subgoal):\n 1. \\<exists>f S.\n       flow \\<Delta> f \\<and> cut \\<Delta> S \\<and> orthogonal \\<Delta> f S", "from flow_\\<Delta>'''[OF this]"], ["proof (chain)\npicking this:\n  flow \\<Delta> f\n  cut \\<Delta> S\n  orthogonal \\<Delta> f S", "show ?thesis"], ["proof (prove)\nusing this:\n  flow \\<Delta> f\n  cut \\<Delta> S\n  orthogonal \\<Delta> f S\n\ngoal (1 subgoal):\n 1. \\<exists>f S.\n       flow \\<Delta> f \\<and> cut \\<Delta> S \\<and> orthogonal \\<Delta> f S", "by blast"], ["proof (state)\nthis:\n  \\<exists>f S.\n     flow \\<Delta> f \\<and> cut \\<Delta> S \\<and> orthogonal \\<Delta> f S\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "end"], ["", "end"]]}