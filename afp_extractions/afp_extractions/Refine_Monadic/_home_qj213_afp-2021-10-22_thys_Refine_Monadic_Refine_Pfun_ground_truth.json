{"file_name": "/home/qj213/afp-2021-10-22/thys/Refine_Monadic/Refine_Pfun.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Refine_Monadic", "problem_names": ["lemma nrec_admissible: \"nrec.admissible (\\<lambda>(f::'a \\<Rightarrow> 'b nres).\n  (\\<forall>x0. f x0 \\<le> SPEC (P x0)))\"", "lemma bind_mono_pfun[partial_function_mono]:\n  fixes C :: \"'a \\<Rightarrow> ('b \\<Rightarrow> 'c nres) \\<Rightarrow> ('d nres)\"\n  shows\n  \"\\<lbrakk> monotone (fun_ord (\\<le>)) (\\<le>) B; \n    \\<And>y. monotone (fun_ord (\\<le>)) (\\<le>) (\\<lambda>f. C y f) \\<rbrakk> \\<Longrightarrow> \n     monotone (fun_ord (\\<le>)) (\\<le>) (\\<lambda>f. bind (B f) (\\<lambda>y. C y f))\"", "lemma drec_admissible: \"drec.admissible (\\<lambda>(f::'a \\<Rightarrow> 'b dres).\n  (\\<forall>x. P x \\<longrightarrow> \n    (f x \\<noteq> dFAIL \\<and> \n    (\\<forall>r. f x = dRETURN r \\<longrightarrow> Q x r))))\"", "lemma drec_bind_mono_pfun[partial_function_mono]:\n  fixes C :: \"'a \\<Rightarrow> ('b \\<Rightarrow> 'c dres) \\<Rightarrow> ('d dres)\"\n  shows\n  \"\\<lbrakk> monotone (fun_ord (\\<le>)) (\\<le>) B; \n    \\<And>y. monotone (fun_ord (\\<le>)) (\\<le>) (\\<lambda>f. C y f) \\<rbrakk> \\<Longrightarrow> \n     monotone (fun_ord (\\<le>)) (\\<le>) (\\<lambda>f. dbind (B f) (\\<lambda>y. C y f))\""], "translations": [["", "lemma nrec_admissible: \"nrec.admissible (\\<lambda>(f::'a \\<Rightarrow> 'b nres).\n  (\\<forall>x0. f x0 \\<le> SPEC (P x0)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nrec.admissible (\\<lambda>f. \\<forall>x0. f x0 \\<le> SPEC (P x0))", "apply (rule ccpo.admissibleI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>A.\n       \\<lbrakk>Complete_Partial_Order.chain nrec.le_fun A; A \\<noteq> {};\n        \\<forall>x\\<in>A. \\<forall>x0. x x0 \\<le> SPEC (P x0)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x0. nrec.lub_fun A x0 \\<le> SPEC (P x0)", "apply (unfold fun_lub_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>A.\n       \\<lbrakk>Complete_Partial_Order.chain nrec.le_fun A; A \\<noteq> {};\n        \\<forall>x\\<in>A. \\<forall>x0. x x0 \\<le> SPEC (P x0)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x0.\n                            Sup {y. \\<exists>f\\<in>A. y = f x0}\n                            \\<le> SPEC (P x0)", "apply (intro allI impI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>A x0.\n       \\<lbrakk>Complete_Partial_Order.chain nrec.le_fun A; A \\<noteq> {};\n        \\<forall>x\\<in>A. \\<forall>x0. x x0 \\<le> SPEC (P x0)\\<rbrakk>\n       \\<Longrightarrow> Sup {y. \\<exists>f\\<in>A. y = f x0}\n                         \\<le> SPEC (P x0)", "apply (rule Sup_least)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>A x0 x.\n       \\<lbrakk>Complete_Partial_Order.chain nrec.le_fun A; A \\<noteq> {};\n        \\<forall>x\\<in>A. \\<forall>x0. x x0 \\<le> SPEC (P x0);\n        x \\<in> {y. \\<exists>f\\<in>A. y = f x0}\\<rbrakk>\n       \\<Longrightarrow> x \\<le> SPEC (P x0)", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*thm fixp_induct_option\n\nlemma fixp_induct_nrec:\n  fixes F :: \"'c \\<Rightarrow> 'c\" and\n    U :: \"'c \\<Rightarrow> 'b \\<Rightarrow> 'a nres\" and\n    C :: \"('b \\<Rightarrow> 'a nres) \\<Rightarrow> 'c\" and\n    P :: \"'b \\<Rightarrow> 'a \\<Rightarrow> bool\"\n  assumes mono: \"\\<And>x. nrec.mono_body (\\<lambda>f. U (F (C f)) x)\"                       \n  assumes eq: \"f \\<equiv> C (nrec.fixp_fun (\\<lambda>f. U (F (C f))))\"\n  assumes inverse2: \"\\<And>f. U (C f) = f\"\n  assumes step: \"\\<And>f x z. (\\<And>x. U f x = U f x; Q x z) \\<Longrightarrow> Q (U (F (C f))) z\"\n (* assumes defined: \"RETURN y \\<le> U (C f) x\"*)\n  assumes Q: \"\\<And>x z. Q x z \\<longleftrightarrow> z = U f x \\<and> U f x \\<le> SPEC (P x)\"\n  shows \"Q x z\" oops\n  (*using step defined\n    nrec.fixp_induct_uc[of U F C, OF mono eq inverse2 nrec_admissible]\n  unfolding Q oops (*\n  by blast*)*)\n\nlemma fixp_induct_nrec':\n  fixes F :: \"'c \\<Rightarrow> 'c\" and\n    U :: \"'c \\<Rightarrow> 'b \\<Rightarrow> 'a nres\" and\n    C :: \"('b \\<Rightarrow> 'a nres) \\<Rightarrow> 'c\" and\n    P :: \"'b \\<Rightarrow> 'a \\<Rightarrow> bool\"\n  assumes mono: \"\\<And>x. nrec_mono (\\<lambda>f. U (F (C f)) x)\"\n  assumes eq: \"f \\<equiv> C (nrec_ffix (\\<lambda>f. U (F (C f))))\"\n  assumes inverse2: \"\\<And>f. U (C f) = f\"\n  assumes step: \"\\<And>f x0. (\\<And>x0. U f x0 \\<le> SPEC (P x0)) \n    \\<Longrightarrow> U (F f) x0 \\<le> SPEC (P x0)\"\n  assumes defined: \"RETURN y \\<le> U f x\"\n  shows \"P x y\"\nproof -\n  note defined\n  also have \"\\<forall>x0. U f x0 \\<le> SPEC (P x0)\"\n    apply (rule nrec.fixp_induct_uc[of U F C, OF mono eq inverse2 \n      nrec_admissible])\n    using step by blast\n  hence \"U f x \\<le> SPEC (P x)\" by simp\n  finally show \"P x y\" by auto\nqed\n*)    \n(* TODO/FIXME: Induction rule seems not to work here ! \n    Function package expects induction rule where conclusion is a binary \n    predicate as free variable.\n*)"], ["", "declaration \\<open>Partial_Function.init \"nrec\" @{term nrec.fixp_fun}\n  @{term nrec.mono_body} @{thm nrec.fixp_rule_uc} @{thm nrec.fixp_induct_uc}\n  (*SOME @{thm fixp_induct_nrec}*) (NONE)\\<close>"], ["", "lemma bind_mono_pfun[partial_function_mono]:\n  fixes C :: \"'a \\<Rightarrow> ('b \\<Rightarrow> 'c nres) \\<Rightarrow> ('d nres)\"\n  shows\n  \"\\<lbrakk> monotone (fun_ord (\\<le>)) (\\<le>) B; \n    \\<And>y. monotone (fun_ord (\\<le>)) (\\<le>) (\\<lambda>f. C y f) \\<rbrakk> \\<Longrightarrow> \n     monotone (fun_ord (\\<le>)) (\\<le>) (\\<lambda>f. bind (B f) (\\<lambda>y. C y f))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>monotone nrec.le_fun (\\<le>) B;\n     \\<And>y. monotone nrec.le_fun (\\<le>) (C y)\\<rbrakk>\n    \\<Longrightarrow> monotone nrec.le_fun (\\<le>)\n                       (\\<lambda>f. B f \\<bind> (\\<lambda>y. C y f))", "apply rule"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>monotone nrec.le_fun (\\<le>) B;\n        \\<And>y. monotone nrec.le_fun (\\<le>) (C y);\n        nrec.le_fun x y\\<rbrakk>\n       \\<Longrightarrow> B x \\<bind> (\\<lambda>y. C y x)\n                         \\<le> B y \\<bind> (\\<lambda>ya. C ya y)", "apply (rule Refine_Basic.bind_mono)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>monotone nrec.le_fun (\\<le>) B;\n        \\<And>y. monotone nrec.le_fun (\\<le>) (C y);\n        nrec.le_fun x y\\<rbrakk>\n       \\<Longrightarrow> B x \\<le> B y\n 2. \\<And>x y xa.\n       \\<lbrakk>monotone nrec.le_fun (\\<le>) B;\n        \\<And>y. monotone nrec.le_fun (\\<le>) (C y); nrec.le_fun x y;\n        RETURN xa \\<le> B x\\<rbrakk>\n       \\<Longrightarrow> C xa x \\<le> C xa y", "apply (blast dest: monotoneD)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection \\<open>Deterministic Result Monad\\<close>"], ["", "interpretation drec:\n  partial_function_definitions \"(\\<le>)\" \"Sup::'a dres set \\<Rightarrow> 'a dres\""], ["proof (prove)\ngoal (1 subgoal):\n 1. partial_function_definitions (\\<le>) Sup", "by unfold_locales (auto simp add: Sup_upper Sup_least)"], ["", "lemma drec_admissible: \"drec.admissible (\\<lambda>(f::'a \\<Rightarrow> 'b dres).\n  (\\<forall>x. P x \\<longrightarrow> \n    (f x \\<noteq> dFAIL \\<and> \n    (\\<forall>r. f x = dRETURN r \\<longrightarrow> Q x r))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. drec.admissible\n     (\\<lambda>f.\n         \\<forall>x.\n            P x \\<longrightarrow>\n            f x \\<noteq> dFAIL \\<and>\n            (\\<forall>r. f x = dRETURN r \\<longrightarrow> Q x r))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. drec.admissible\n     (\\<lambda>f.\n         \\<forall>x.\n            P x \\<longrightarrow>\n            f x \\<noteq> dFAIL \\<and>\n            (\\<forall>r. f x = dRETURN r \\<longrightarrow> Q x r))", "have [simp]: \"fun_ord ((\\<le>) ::'b dres \\<Rightarrow> _ \\<Rightarrow> _) = (\\<le>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. drec.le_fun = (\\<le>)", "apply (intro ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa. drec.le_fun x xa = (x \\<le> xa)", "unfolding fun_ord_def le_fun_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       (\\<forall>xb. x xb \\<le> xa xb) = (\\<forall>xb. x xb \\<le> xa xb)", "by (rule refl)"], ["proof (state)\nthis:\n  drec.le_fun = (\\<le>)\n\ngoal (1 subgoal):\n 1. drec.admissible\n     (\\<lambda>f.\n         \\<forall>x.\n            P x \\<longrightarrow>\n            f x \\<noteq> dFAIL \\<and>\n            (\\<forall>r. f x = dRETURN r \\<longrightarrow> Q x r))", "have [simp]: \"\\<And>A x. {y. \\<exists>f\\<in>A. y = f x} = (\\<lambda>f. f x)`A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>A x. {y. \\<exists>f\\<in>A. y = f x} = (\\<lambda>f. f x) ` A", "by auto"], ["proof (state)\nthis:\n  {y. \\<exists>f\\<in>?A1. y = f ?x1} = (\\<lambda>f. f ?x1) ` ?A1\n\ngoal (1 subgoal):\n 1. drec.admissible\n     (\\<lambda>f.\n         \\<forall>x.\n            P x \\<longrightarrow>\n            f x \\<noteq> dFAIL \\<and>\n            (\\<forall>r. f x = dRETURN r \\<longrightarrow> Q x r))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. drec.admissible\n     (\\<lambda>f.\n         \\<forall>x.\n            P x \\<longrightarrow>\n            f x \\<noteq> dFAIL \\<and>\n            (\\<forall>r. f x = dRETURN r \\<longrightarrow> Q x r))", "apply (rule ccpo.admissibleI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>A.\n       \\<lbrakk>Complete_Partial_Order.chain drec.le_fun A; A \\<noteq> {};\n        \\<forall>x\\<in>A.\n           \\<forall>xa.\n              P xa \\<longrightarrow>\n              x xa \\<noteq> dFAIL \\<and>\n              (\\<forall>r.\n                  x xa = dRETURN r \\<longrightarrow> Q xa r)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x.\n                            P x \\<longrightarrow>\n                            drec.lub_fun A x \\<noteq> dFAIL \\<and>\n                            (\\<forall>r.\n                                drec.lub_fun A x =\n                                dRETURN r \\<longrightarrow>\n                                Q x r)", "apply (unfold fun_lub_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>A.\n       \\<lbrakk>Complete_Partial_Order.chain drec.le_fun A; A \\<noteq> {};\n        \\<forall>x\\<in>A.\n           \\<forall>xa.\n              P xa \\<longrightarrow>\n              x xa \\<noteq> dFAIL \\<and>\n              (\\<forall>r.\n                  x xa = dRETURN r \\<longrightarrow> Q xa r)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x.\n                            P x \\<longrightarrow>\n                            Sup {y. \\<exists>f\\<in>A. y = f x} \\<noteq>\n                            dFAIL \\<and>\n                            (\\<forall>r.\n                                Sup {y. \\<exists>f\\<in>A. y = f x} =\n                                dRETURN r \\<longrightarrow>\n                                Q x r)", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>A x.\n       \\<lbrakk>is_chain A; A \\<noteq> {};\n        \\<forall>x\\<in>A.\n           \\<forall>xa.\n              P xa \\<longrightarrow>\n              x xa \\<noteq> dFAIL \\<and>\n              (\\<forall>r. x xa = dRETURN r \\<longrightarrow> Q xa r);\n        P x\\<rbrakk>\n       \\<Longrightarrow> (SUP f\\<in>A. f x) \\<noteq> dFAIL \\<and>\n                         (\\<forall>r.\n                             (SUP f\\<in>A. f x) =\n                             dRETURN r \\<longrightarrow>\n                             Q x r)", "apply (drule_tac x=x in point_chainI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>A x.\n       \\<lbrakk>A \\<noteq> {};\n        \\<forall>x\\<in>A.\n           \\<forall>xa.\n              P xa \\<longrightarrow>\n              x xa \\<noteq> dFAIL \\<and>\n              (\\<forall>r. x xa = dRETURN r \\<longrightarrow> Q xa r);\n        P x; is_chain ((\\<lambda>f. f x) ` A)\\<rbrakk>\n       \\<Longrightarrow> (SUP f\\<in>A. f x) \\<noteq> dFAIL \\<and>\n                         (\\<forall>r.\n                             (SUP f\\<in>A. f x) =\n                             dRETURN r \\<longrightarrow>\n                             Q x r)", "apply (erule dres_Sup_chain_cases)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>A x.\n       \\<lbrakk>A \\<noteq> {};\n        \\<forall>x\\<in>A.\n           \\<forall>xa.\n              P xa \\<longrightarrow>\n              x xa \\<noteq> dFAIL \\<and>\n              (\\<forall>r. x xa = dRETURN r \\<longrightarrow> Q xa r);\n        P x; (\\<lambda>f. f x) ` A \\<subseteq> {dSUCCEED};\n        (SUP f\\<in>A. f x) = dSUCCEED\\<rbrakk>\n       \\<Longrightarrow> (SUP f\\<in>A. f x) \\<noteq> dFAIL \\<and>\n                         (\\<forall>r.\n                             (SUP f\\<in>A. f x) =\n                             dRETURN r \\<longrightarrow>\n                             Q x r)\n 2. \\<And>A x r.\n       \\<lbrakk>A \\<noteq> {};\n        \\<forall>x\\<in>A.\n           \\<forall>xa.\n              P xa \\<longrightarrow>\n              x xa \\<noteq> dFAIL \\<and>\n              (\\<forall>r. x xa = dRETURN r \\<longrightarrow> Q xa r);\n        P x; (\\<lambda>f. f x) ` A \\<subseteq> {dSUCCEED, dRETURN r};\n        dRETURN r \\<in> (\\<lambda>f. f x) ` A;\n        (SUP f\\<in>A. f x) = dRETURN r\\<rbrakk>\n       \\<Longrightarrow> (SUP f\\<in>A. f x) \\<noteq> dFAIL \\<and>\n                         (\\<forall>r.\n                             (SUP f\\<in>A. f x) =\n                             dRETURN r \\<longrightarrow>\n                             Q x r)\n 3. \\<And>A x.\n       \\<lbrakk>A \\<noteq> {};\n        \\<forall>x\\<in>A.\n           \\<forall>xa.\n              P xa \\<longrightarrow>\n              x xa \\<noteq> dFAIL \\<and>\n              (\\<forall>r. x xa = dRETURN r \\<longrightarrow> Q xa r);\n        P x; dFAIL \\<in> (\\<lambda>f. f x) ` A;\n        (SUP f\\<in>A. f x) = dFAIL\\<rbrakk>\n       \\<Longrightarrow> (SUP f\\<in>A. f x) \\<noteq> dFAIL \\<and>\n                         (\\<forall>r.\n                             (SUP f\\<in>A. f x) =\n                             dRETURN r \\<longrightarrow>\n                             Q x r)", "apply auto"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>A x xa.\n       \\<lbrakk>\\<forall>x\\<in>A.\n                   \\<forall>xa.\n                      P xa \\<longrightarrow>\n                      x xa \\<noteq> dFAIL \\<and>\n                      (\\<forall>r.\n                          x xa = dRETURN r \\<longrightarrow> Q xa r);\n        P x; (\\<lambda>f. f x) ` A \\<subseteq> {dSUCCEED};\n        \\<forall>xa\\<in>A. xa x = dSUCCEED; xa \\<in> A;\n        (SUP f\\<in>A. f x) = dFAIL\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>A x xa r.\n       \\<lbrakk>\\<forall>x\\<in>A.\n                   \\<forall>xa.\n                      P xa \\<longrightarrow>\n                      x xa \\<noteq> dFAIL \\<and>\n                      (\\<forall>r.\n                          x xa = dRETURN r \\<longrightarrow> Q xa r);\n        P x; (\\<lambda>f. f x) ` A \\<subseteq> {dSUCCEED};\n        \\<forall>xa\\<in>A. xa x = dSUCCEED; xa \\<in> A;\n        (SUP f\\<in>A. f x) = dRETURN r\\<rbrakk>\n       \\<Longrightarrow> Q x r\n 3. \\<And>A x f xa.\n       \\<lbrakk>\\<forall>x\\<in>A.\n                   \\<forall>xa.\n                      P xa \\<longrightarrow>\n                      x xa \\<noteq> dFAIL \\<and>\n                      (\\<forall>r.\n                          x xa = dRETURN r \\<longrightarrow> Q xa r);\n        P x; (SUP f\\<in>A. f x) = dFAIL; dFAIL = f x; f \\<in> A;\n        xa \\<in> A\\<rbrakk>\n       \\<Longrightarrow> False", "apply (metis (poly_guards_query) SUP_bot_conv(1))"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>A x xa r.\n       \\<lbrakk>\\<forall>x\\<in>A.\n                   \\<forall>xa.\n                      P xa \\<longrightarrow>\n                      x xa \\<noteq> dFAIL \\<and>\n                      (\\<forall>r.\n                          x xa = dRETURN r \\<longrightarrow> Q xa r);\n        P x; (\\<lambda>f. f x) ` A \\<subseteq> {dSUCCEED};\n        \\<forall>xa\\<in>A. xa x = dSUCCEED; xa \\<in> A;\n        (SUP f\\<in>A. f x) = dRETURN r\\<rbrakk>\n       \\<Longrightarrow> Q x r\n 2. \\<And>A x f xa.\n       \\<lbrakk>\\<forall>x\\<in>A.\n                   \\<forall>xa.\n                      P xa \\<longrightarrow>\n                      x xa \\<noteq> dFAIL \\<and>\n                      (\\<forall>r.\n                          x xa = dRETURN r \\<longrightarrow> Q xa r);\n        P x; (SUP f\\<in>A. f x) = dFAIL; dFAIL = f x; f \\<in> A;\n        xa \\<in> A\\<rbrakk>\n       \\<Longrightarrow> False", "apply (metis (poly_guards_query) SUP_bot_conv(1))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>A x f xa.\n       \\<lbrakk>\\<forall>x\\<in>A.\n                   \\<forall>xa.\n                      P xa \\<longrightarrow>\n                      x xa \\<noteq> dFAIL \\<and>\n                      (\\<forall>r.\n                          x xa = dRETURN r \\<longrightarrow> Q xa r);\n        P x; (SUP f\\<in>A. f x) = dFAIL; dFAIL = f x; f \\<in> A;\n        xa \\<in> A\\<rbrakk>\n       \\<Longrightarrow> False", "apply metis"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  drec.admissible\n   (\\<lambda>f.\n       \\<forall>x.\n          P x \\<longrightarrow>\n          f x \\<noteq> dFAIL \\<and>\n          (\\<forall>r. f x = dRETURN r \\<longrightarrow> Q x r))\n\ngoal:\nNo subgoals!", "qed"], ["", "declaration \\<open>Partial_Function.init \"drec\" @{term drec.fixp_fun}\n  @{term drec.mono_body} @{thm drec.fixp_rule_uc} @{thm drec.fixp_induct_uc} \n  NONE\\<close>"], ["", "lemma drec_bind_mono_pfun[partial_function_mono]:\n  fixes C :: \"'a \\<Rightarrow> ('b \\<Rightarrow> 'c dres) \\<Rightarrow> ('d dres)\"\n  shows\n  \"\\<lbrakk> monotone (fun_ord (\\<le>)) (\\<le>) B; \n    \\<And>y. monotone (fun_ord (\\<le>)) (\\<le>) (\\<lambda>f. C y f) \\<rbrakk> \\<Longrightarrow> \n     monotone (fun_ord (\\<le>)) (\\<le>) (\\<lambda>f. dbind (B f) (\\<lambda>y. C y f))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>monotone drec.le_fun (\\<le>) B;\n     \\<And>y. monotone drec.le_fun (\\<le>) (C y)\\<rbrakk>\n    \\<Longrightarrow> monotone drec.le_fun (\\<le>)\n                       (\\<lambda>f. B f \\<bind> (\\<lambda>y. C y f))", "apply rule"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>monotone drec.le_fun (\\<le>) B;\n        \\<And>y. monotone drec.le_fun (\\<le>) (C y);\n        drec.le_fun x y\\<rbrakk>\n       \\<Longrightarrow> B x \\<bind> (\\<lambda>y. C y x)\n                         \\<le> B y \\<bind> (\\<lambda>ya. C ya y)", "apply (rule dbind_mono)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>monotone drec.le_fun (\\<le>) B;\n        \\<And>y. monotone drec.le_fun (\\<le>) (C y);\n        drec.le_fun x y\\<rbrakk>\n       \\<Longrightarrow> B x \\<le> B y\n 2. \\<And>x y xa.\n       \\<lbrakk>monotone drec.le_fun (\\<le>) B;\n        \\<And>y. monotone drec.le_fun (\\<le>) (C y); drec.le_fun x y;\n        dRETURN xa \\<le> B x\\<rbrakk>\n       \\<Longrightarrow> C xa x \\<le> C xa y", "apply (blast dest: monotoneD)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"]]}