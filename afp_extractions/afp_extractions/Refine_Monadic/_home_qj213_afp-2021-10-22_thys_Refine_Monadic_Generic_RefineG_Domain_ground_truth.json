{"file_name": "/home/qj213/afp-2021-10-22/thys/Refine_Monadic/Generic/RefineG_Domain.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Refine_Monadic", "problem_names": ["lemma chain_f_apply: \"Complete_Partial_Order.chain (fun_ord le) F\n    \\<Longrightarrow> Complete_Partial_Order.chain le {y . \\<exists>f\\<in>F. y = f x}\"", "lemma ccpo_lift:\n    assumes \"class.ccpo lub le lt\"\n    shows \"class.ccpo (fun_lub lub) (fun_ord le) (mk_less (fun_ord le))\"", "lemma fun_lub_simps[simp]: \n    \"fun_lub lub {} = (\\<lambda>x. lub {})\"\n    \"fun_lub lub {f} = (\\<lambda>x. lub {f x})\"", "lemma flat_ord_chain_cases: \n    assumes A: \"Complete_Partial_Order.chain (flat_ord b) C\"\n    obtains \"C={}\" \n    | \"C={b}\" \n    | x where \"x\\<noteq>b\" and \"C={x}\" \n    | x where \"x\\<noteq>b\" and \"C={b,x}\"", "lemma flat_lub_simps[simp]:\n    \"flat_lub b {} = b\"\n    \"flat_lub b {x} = x\"\n    \"flat_lub b (insert b X) = flat_lub b X\"", "lemma flat_ord_simps[simp]:\n    \"flat_ord b b x\"", "lemma flatf_fp_mono[refine_mono]:\n    \\<comment> \\<open>The fixed point combinator is monotonic\\<close>\n    assumes \"flatf_mono b f\"\n      and \"flatf_mono b g\"\n      and \"\\<And>Z x. flat_ord b (f Z x) (g Z x)\"\n    shows \"flat_ord b (flatf_fp b f x) (flatf_fp b g x)\"", "lemma flatf_admissible_pointwise:\n    \"(\\<And>x. P x b) \\<Longrightarrow> \n      ccpo.admissible (flatf_lub b) (flatf_ord b) (\\<lambda>g. \\<forall>x. P x (g x))\"", "lemma flatf_fp_induct_pointwise:\n    \\<comment> \\<open>Fixed-point induction for pointwise properties\\<close>\n    fixes a :: 'a\n    assumes cond_bot: \"\\<And>a x. pre a x \\<Longrightarrow> post a x b\"\n    assumes MONO: \"flatf_mono b B\"\n    assumes PRE0: \"pre a x\"\n    assumes STEP: \"\\<And>f a x. \n      \\<lbrakk>\\<And>a' x'. pre a' x' \\<Longrightarrow> post a' x' (f x'); pre a x; \n        flatf_ord b f (flatf_fp b B) \\<rbrakk> \n      \\<Longrightarrow> post a x (B f x)\"\n    shows \"post a x (flatf_fp b B x)\"", "lemma flatf_fixp_transfer:\n    \\<comment> \\<open>Transfer rule for fixed points\\<close>\n    assumes TR_BOT[simp]: \"\\<And>x'. tr b x'\"\n    assumes MONO: \"flatf_mono b B\"\n    assumes FP': \"fp' = B' fp'\"\n    assumes R0: \"P x x'\"\n    assumes RS: \"\\<And>f f' x x'.\n       \\<lbrakk>\\<And>x x'. P x x' \\<Longrightarrow> tr (f x) (f' x'); P x x'; fp' = f'\\<rbrakk>\n       \\<Longrightarrow> tr (B f x) (B' f' x')\"\n    shows \"tr (flatf_fp b B x) (fp' x')\"", "lemma flat_ord_compat: \n    fixes x y :: \"'a :: complete_lattice\"\n    shows \n    \"flat_le x y \\<Longrightarrow> x \\<le> y\"\n    \"flat_ge x y \\<Longrightarrow> x \\<ge> y\"", "lemma flatf_ord_compat: \n    fixes x y :: \"'a \\<Rightarrow> ('b :: complete_lattice)\"\n    shows \n    \"flatf_le x y \\<Longrightarrow> x \\<le> y\"\n    \"flatf_ge x y \\<Longrightarrow> x \\<ge> y\"", "lemma lfp_eq_flatf_lfp:\n    assumes FM: \"flatf_mono_le B\" and M: \"mono B\"\n    shows \"lfp B = flatf_lfp B\"", "lemma gfp_eq_flatf_gfp:\n    assumes FM: \"flatf_mono_ge B\" and M: \"mono B\"\n    shows \"gfp B = flatf_gfp B\"", "lemma wf_fixp_induct:\n    \\<comment> \\<open>Well-Founded induction for arbitrary fixed points\\<close>\n    fixes a :: 'a\n    assumes fixp_unfold: \"fp B = B (fp B)\"\n    assumes WF: \"wf V\"\n    assumes P0: \"pre a x\"\n    assumes STEP: \"\\<And>f a x. \\<lbrakk> \n      \\<And>a' x'. \\<lbrakk> pre a' x'; (x',x)\\<in>V \\<rbrakk> \\<Longrightarrow> post a' x' (f x'); fp B = f; pre a x \n    \\<rbrakk> \\<Longrightarrow> post a x (B f x)\"\n    shows \"post a x (fp B x)\"", "lemma flatf_lfp_transfer:\n    \\<comment> \\<open>Transfer rule for least fixed points\\<close>\n    fixes B::\"(_ \\<Rightarrow> 'a::order_bot) \\<Rightarrow> _\"\n    assumes TR_BOT[simp]: \"\\<And>x. tr bot x\"\n    assumes MONO: \"flatf_mono_le B\"\n    assumes MONO': \"flatf_mono_le B'\"\n    assumes R0: \"P x x'\"\n    assumes RS: \"\\<And>f f' x x'.\n       \\<lbrakk>\\<And>x x'. P x x' \\<Longrightarrow> tr (f x) (f' x'); P x x'; flatf_lfp B' = f'\\<rbrakk>\n       \\<Longrightarrow> tr (B f x) (B' f' x')\"\n    shows \"tr (flatf_lfp B x) (flatf_lfp B' x')\"", "lemma flatf_gfp_transfer:\n    \\<comment> \\<open>Transfer rule for greatest fixed points\\<close>\n    fixes B::\"(_ \\<Rightarrow> 'a::order_top) \\<Rightarrow> _\"\n    assumes TR_TOP[simp]: \"\\<And>x. tr x top\"\n    assumes MONO: \"flatf_mono_ge B\"\n    assumes MONO': \"flatf_mono_ge B'\"\n    assumes R0: \"P x x'\"\n    assumes RS: \"\\<And>f f' x x'.\n       \\<lbrakk>\\<And>x x'. P x x' \\<Longrightarrow> tr (f x) (f' x'); P x x'; flatf_gfp B = f\\<rbrakk>\n       \\<Longrightarrow> tr (B f x) (B' f' x')\"\n    shows \"tr (flatf_gfp B x) (flatf_gfp B' x')\"", "lemma meta_le_everything_if_top: \"(m=top) \\<Longrightarrow> (\\<And>x. x \\<le> (m::'a::order_top))\"", "lemmas flatf_lfp_refine = flatf_lfp_transfer[\n    where tr = \"\\<lambda>a b. a \\<le> cf b\" for cf, OF bot_least]", "lemmas flatf_gfp_refine = flatf_gfp_transfer[\n    where tr = \"\\<lambda>a b. a \\<le> cf b\" for cf, OF meta_le_everything_if_top]", "lemma flat_ge_sup_mono[refine_mono]: \"\\<And>a a'::'a::complete_lattice. \n    flat_ge a a' \\<Longrightarrow> flat_ge b b' \\<Longrightarrow> flat_ge (sup a b) (sup a' b')\""], "translations": [["", "lemma chain_f_apply: \"Complete_Partial_Order.chain (fun_ord le) F\n    \\<Longrightarrow> Complete_Partial_Order.chain le {y . \\<exists>f\\<in>F. y = f x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Complete_Partial_Order.chain (fun_ord le) F \\<Longrightarrow>\n    Complete_Partial_Order.chain le {y. \\<exists>f\\<in>F. y = f x}", "unfolding Complete_Partial_Order.chain_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>F.\n       \\<forall>y\\<in>F.\n          fun_ord le x y \\<or> fun_ord le y x \\<Longrightarrow>\n    \\<forall>xa\\<in>{y. \\<exists>f\\<in>F. y = f x}.\n       \\<forall>y\\<in>{y. \\<exists>f\\<in>F. y = f x}. le xa y \\<or> le y xa", "by (auto simp: fun_ord_def)"], ["", "lemma ccpo_lift:\n    assumes \"class.ccpo lub le lt\"\n    shows \"class.ccpo (fun_lub lub) (fun_ord le) (mk_less (fun_ord le))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. class.ccpo (fun_lub lub) (fun_ord le) (mk_less (fun_ord le))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. class.ccpo (fun_lub lub) (fun_ord le) (mk_less (fun_ord le))", "interpret ccpo: ccpo lub le lt"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.ccpo lub le lt", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. class.ccpo (fun_lub lub) (fun_ord le) (mk_less (fun_ord le))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.ccpo (fun_lub lub) (fun_ord le) (mk_less (fun_ord le))", "apply unfold_locales"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>x y.\n       mk_less (fun_ord le) x y =\n       (fun_ord le x y \\<and> \\<not> fun_ord le y x)\n 2. \\<And>x. fun_ord le x x\n 3. \\<And>x y z.\n       \\<lbrakk>fun_ord le x y; fun_ord le y z\\<rbrakk>\n       \\<Longrightarrow> fun_ord le x z\n 4. \\<And>x y.\n       \\<lbrakk>fun_ord le x y; fun_ord le y x\\<rbrakk>\n       \\<Longrightarrow> x = y\n 5. \\<And>A x.\n       \\<lbrakk>Complete_Partial_Order.chain (fun_ord le) A;\n        x \\<in> A\\<rbrakk>\n       \\<Longrightarrow> fun_ord le x (fun_lub lub A)\n 6. \\<And>A z.\n       \\<lbrakk>Complete_Partial_Order.chain (fun_ord le) A;\n        \\<And>x. x \\<in> A \\<Longrightarrow> fun_ord le x z\\<rbrakk>\n       \\<Longrightarrow> fun_ord le (fun_lub lub A) z", "apply (simp_all only: mk_less_def fun_ord_def fun_lub_def)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x. \\<forall>xa. le (x xa) (x xa)\n 2. \\<And>x y z.\n       \\<lbrakk>\\<forall>xa. le (x xa) (y xa);\n        \\<forall>x. le (y x) (z x)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>xa. le (x xa) (z xa)\n 3. \\<And>x y.\n       \\<lbrakk>\\<forall>xa. le (x xa) (y xa);\n        \\<forall>xa. le (y xa) (x xa)\\<rbrakk>\n       \\<Longrightarrow> x = y\n 4. \\<And>A x.\n       \\<lbrakk>Complete_Partial_Order.chain (fun_ord le) A;\n        x \\<in> A\\<rbrakk>\n       \\<Longrightarrow> \\<forall>xa.\n                            le (x xa) (lub {y. \\<exists>f\\<in>A. y = f xa})\n 5. \\<And>A z.\n       \\<lbrakk>Complete_Partial_Order.chain (fun_ord le) A;\n        \\<And>x.\n           x \\<in> A \\<Longrightarrow>\n           \\<forall>xa. le (x xa) (z xa)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x.\n                            le (lub {y. \\<exists>f\\<in>A. y = f x}) (z x)", "apply simp"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>\\<forall>xa. le (x xa) (y xa);\n        \\<forall>x. le (y x) (z x)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>xa. le (x xa) (z xa)\n 2. \\<And>x y.\n       \\<lbrakk>\\<forall>xa. le (x xa) (y xa);\n        \\<forall>xa. le (y xa) (x xa)\\<rbrakk>\n       \\<Longrightarrow> x = y\n 3. \\<And>A x.\n       \\<lbrakk>Complete_Partial_Order.chain (fun_ord le) A;\n        x \\<in> A\\<rbrakk>\n       \\<Longrightarrow> \\<forall>xa.\n                            le (x xa) (lub {y. \\<exists>f\\<in>A. y = f xa})\n 4. \\<And>A z.\n       \\<lbrakk>Complete_Partial_Order.chain (fun_ord le) A;\n        \\<And>x.\n           x \\<in> A \\<Longrightarrow>\n           \\<forall>xa. le (x xa) (z xa)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x.\n                            le (lub {y. \\<exists>f\\<in>A. y = f x}) (z x)", "using ccpo.order_trans"], ["proof (prove)\nusing this:\n  \\<lbrakk>le ?x ?y; le ?y ?z\\<rbrakk> \\<Longrightarrow> le ?x ?z\n\ngoal (4 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>\\<forall>xa. le (x xa) (y xa);\n        \\<forall>x. le (y x) (z x)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>xa. le (x xa) (z xa)\n 2. \\<And>x y.\n       \\<lbrakk>\\<forall>xa. le (x xa) (y xa);\n        \\<forall>xa. le (y xa) (x xa)\\<rbrakk>\n       \\<Longrightarrow> x = y\n 3. \\<And>A x.\n       \\<lbrakk>Complete_Partial_Order.chain (fun_ord le) A;\n        x \\<in> A\\<rbrakk>\n       \\<Longrightarrow> \\<forall>xa.\n                            le (x xa) (lub {y. \\<exists>f\\<in>A. y = f xa})\n 4. \\<And>A z.\n       \\<lbrakk>Complete_Partial_Order.chain (fun_ord le) A;\n        \\<And>x.\n           x \\<in> A \\<Longrightarrow>\n           \\<forall>xa. le (x xa) (z xa)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x.\n                            le (lub {y. \\<exists>f\\<in>A. y = f x}) (z x)", "apply blast"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>\\<forall>xa. le (x xa) (y xa);\n        \\<forall>xa. le (y xa) (x xa)\\<rbrakk>\n       \\<Longrightarrow> x = y\n 2. \\<And>A x.\n       \\<lbrakk>Complete_Partial_Order.chain (fun_ord le) A;\n        x \\<in> A\\<rbrakk>\n       \\<Longrightarrow> \\<forall>xa.\n                            le (x xa) (lub {y. \\<exists>f\\<in>A. y = f xa})\n 3. \\<And>A z.\n       \\<lbrakk>Complete_Partial_Order.chain (fun_ord le) A;\n        \\<And>x.\n           x \\<in> A \\<Longrightarrow>\n           \\<forall>xa. le (x xa) (z xa)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x.\n                            le (lub {y. \\<exists>f\\<in>A. y = f x}) (z x)", "using ccpo.antisym"], ["proof (prove)\nusing this:\n  \\<lbrakk>le ?x ?y; le ?y ?x\\<rbrakk> \\<Longrightarrow> ?x = ?y\n\ngoal (3 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>\\<forall>xa. le (x xa) (y xa);\n        \\<forall>xa. le (y xa) (x xa)\\<rbrakk>\n       \\<Longrightarrow> x = y\n 2. \\<And>A x.\n       \\<lbrakk>Complete_Partial_Order.chain (fun_ord le) A;\n        x \\<in> A\\<rbrakk>\n       \\<Longrightarrow> \\<forall>xa.\n                            le (x xa) (lub {y. \\<exists>f\\<in>A. y = f xa})\n 3. \\<And>A z.\n       \\<lbrakk>Complete_Partial_Order.chain (fun_ord le) A;\n        \\<And>x.\n           x \\<in> A \\<Longrightarrow>\n           \\<forall>xa. le (x xa) (z xa)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x.\n                            le (lub {y. \\<exists>f\\<in>A. y = f x}) (z x)", "apply blast"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>A x.\n       \\<lbrakk>Complete_Partial_Order.chain (fun_ord le) A;\n        x \\<in> A\\<rbrakk>\n       \\<Longrightarrow> \\<forall>xa.\n                            le (x xa) (lub {y. \\<exists>f\\<in>A. y = f xa})\n 2. \\<And>A z.\n       \\<lbrakk>Complete_Partial_Order.chain (fun_ord le) A;\n        \\<And>x.\n           x \\<in> A \\<Longrightarrow>\n           \\<forall>xa. le (x xa) (z xa)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x.\n                            le (lub {y. \\<exists>f\\<in>A. y = f x}) (z x)", "using ccpo.ccpo_Sup_upper"], ["proof (prove)\nusing this:\n  \\<lbrakk>Complete_Partial_Order.chain le ?A; ?x \\<in> ?A\\<rbrakk>\n  \\<Longrightarrow> le ?x (lub ?A)\n\ngoal (2 subgoals):\n 1. \\<And>A x.\n       \\<lbrakk>Complete_Partial_Order.chain (fun_ord le) A;\n        x \\<in> A\\<rbrakk>\n       \\<Longrightarrow> \\<forall>xa.\n                            le (x xa) (lub {y. \\<exists>f\\<in>A. y = f xa})\n 2. \\<And>A z.\n       \\<lbrakk>Complete_Partial_Order.chain (fun_ord le) A;\n        \\<And>x.\n           x \\<in> A \\<Longrightarrow>\n           \\<forall>xa. le (x xa) (z xa)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x.\n                            le (lub {y. \\<exists>f\\<in>A. y = f x}) (z x)", "apply (blast intro: chain_f_apply)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>A z.\n       \\<lbrakk>Complete_Partial_Order.chain (fun_ord le) A;\n        \\<And>x.\n           x \\<in> A \\<Longrightarrow>\n           \\<forall>xa. le (x xa) (z xa)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x.\n                            le (lub {y. \\<exists>f\\<in>A. y = f x}) (z x)", "using ccpo.ccpo_Sup_least"], ["proof (prove)\nusing this:\n  \\<lbrakk>Complete_Partial_Order.chain le ?A;\n   \\<And>x. x \\<in> ?A \\<Longrightarrow> le x ?z\\<rbrakk>\n  \\<Longrightarrow> le (lub ?A) ?z\n\ngoal (1 subgoal):\n 1. \\<And>A z.\n       \\<lbrakk>Complete_Partial_Order.chain (fun_ord le) A;\n        \\<And>x.\n           x \\<in> A \\<Longrightarrow>\n           \\<forall>xa. le (x xa) (z xa)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x.\n                            le (lub {y. \\<exists>f\\<in>A. y = f x}) (z x)", "apply (blast intro: chain_f_apply)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  class.ccpo (fun_lub lub) (fun_ord le) (mk_less (fun_ord le))\n\ngoal:\nNo subgoals!", "qed"], ["", "(* TODO: Move *)"], ["", "lemma fun_lub_simps[simp]: \n    \"fun_lub lub {} = (\\<lambda>x. lub {})\"\n    \"fun_lub lub {f} = (\\<lambda>x. lub {f x})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fun_lub lub {} = (\\<lambda>x. lub {}) &&&\n    fun_lub lub {f} = (\\<lambda>x. lub {f x})", "unfolding fun_lub_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. lub {y. \\<exists>f\\<in>{}. y = f x}) =\n    (\\<lambda>x. lub {}) &&&\n    (\\<lambda>x. lub {y. \\<exists>f\\<in>{f}. y = f x}) =\n    (\\<lambda>x. lub {f x})", "by auto"], ["", "subsection \\<open>Flat Ordering\\<close>"], ["", "lemma flat_ord_chain_cases: \n    assumes A: \"Complete_Partial_Order.chain (flat_ord b) C\"\n    obtains \"C={}\" \n    | \"C={b}\" \n    | x where \"x\\<noteq>b\" and \"C={x}\" \n    | x where \"x\\<noteq>b\" and \"C={b,x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>C = {} \\<Longrightarrow> thesis;\n     C = {b} \\<Longrightarrow> thesis;\n     \\<And>x.\n        \\<lbrakk>x \\<noteq> b; C = {x}\\<rbrakk> \\<Longrightarrow> thesis;\n     \\<And>x.\n        \\<lbrakk>x \\<noteq> b; C = {b, x}\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>C = {} \\<Longrightarrow> thesis;\n     C = {b} \\<Longrightarrow> thesis;\n     \\<And>x.\n        \\<lbrakk>x \\<noteq> b; C = {x}\\<rbrakk> \\<Longrightarrow> thesis;\n     \\<And>x.\n        \\<lbrakk>x \\<noteq> b; C = {b, x}\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "have \"\\<exists>m1 m2. C \\<subseteq> {m1,m2} \\<and> (m1 = b \\<or> m2 = b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>m1 m2. C \\<subseteq> {m1, m2} \\<and> (m1 = b \\<or> m2 = b)", "apply (rule ccontr)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nexists>m1 m2.\n       C \\<subseteq> {m1, m2} \\<and> (m1 = b \\<or> m2 = b) \\<Longrightarrow>\n    False", "proof clarsimp"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>m1 m2.\n       C \\<subseteq> {m1, m2} \\<longrightarrow>\n       m1 \\<noteq> b \\<and> m2 \\<noteq> b \\<Longrightarrow>\n    False", "assume \"\\<forall>m1 m2. C \\<subseteq> {m1, m2} \\<longrightarrow> m1\\<noteq>b \\<and> m2\\<noteq>b\""], ["proof (state)\nthis:\n  \\<forall>m1 m2.\n     C \\<subseteq> {m1, m2} \\<longrightarrow>\n     m1 \\<noteq> b \\<and> m2 \\<noteq> b\n\ngoal (1 subgoal):\n 1. \\<forall>m1 m2.\n       C \\<subseteq> {m1, m2} \\<longrightarrow>\n       m1 \\<noteq> b \\<and> m2 \\<noteq> b \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<forall>m1 m2.\n     C \\<subseteq> {m1, m2} \\<longrightarrow>\n     m1 \\<noteq> b \\<and> m2 \\<noteq> b", "obtain m1 m2 where \"m1\\<in>C\" \"m2\\<in>C\" \n        \"m1\\<noteq>m2\" \"m1\\<noteq>b\" \"m2\\<noteq>b\""], ["proof (prove)\nusing this:\n  \\<forall>m1 m2.\n     C \\<subseteq> {m1, m2} \\<longrightarrow>\n     m1 \\<noteq> b \\<and> m2 \\<noteq> b\n\ngoal (1 subgoal):\n 1. (\\<And>m1 m2.\n        \\<lbrakk>m1 \\<in> C; m2 \\<in> C; m1 \\<noteq> m2; m1 \\<noteq> b;\n         m2 \\<noteq> b\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  m1 \\<in> C\n  m2 \\<in> C\n  m1 \\<noteq> m2\n  m1 \\<noteq> b\n  m2 \\<noteq> b\n\ngoal (1 subgoal):\n 1. \\<forall>m1 m2.\n       C \\<subseteq> {m1, m2} \\<longrightarrow>\n       m1 \\<noteq> b \\<and> m2 \\<noteq> b \\<Longrightarrow>\n    False", "with A"], ["proof (chain)\npicking this:\n  Complete_Partial_Order.chain (flat_ord b) C\n  m1 \\<in> C\n  m2 \\<in> C\n  m1 \\<noteq> m2\n  m1 \\<noteq> b\n  m2 \\<noteq> b", "show False"], ["proof (prove)\nusing this:\n  Complete_Partial_Order.chain (flat_ord b) C\n  m1 \\<in> C\n  m2 \\<in> C\n  m1 \\<noteq> m2\n  m1 \\<noteq> b\n  m2 \\<noteq> b\n\ngoal (1 subgoal):\n 1. False", "unfolding Complete_Partial_Order.chain_def flat_ord_def"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>C.\n     \\<forall>y\\<in>C. (x = b \\<or> x = y) \\<or> y = b \\<or> y = x\n  m1 \\<in> C\n  m2 \\<in> C\n  m1 \\<noteq> m2\n  m1 \\<noteq> b\n  m2 \\<noteq> b\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>m1 m2. C \\<subseteq> {m1, m2} \\<and> (m1 = b \\<or> m2 = b)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>C = {} \\<Longrightarrow> thesis;\n     C = {b} \\<Longrightarrow> thesis;\n     \\<And>x.\n        \\<lbrakk>x \\<noteq> b; C = {x}\\<rbrakk> \\<Longrightarrow> thesis;\n     \\<And>x.\n        \\<lbrakk>x \\<noteq> b; C = {b, x}\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  \\<exists>m1 m2. C \\<subseteq> {m1, m2} \\<and> (m1 = b \\<or> m2 = b)", "obtain m where \"C \\<subseteq> {m,b}\""], ["proof (prove)\nusing this:\n  \\<exists>m1 m2. C \\<subseteq> {m1, m2} \\<and> (m1 = b \\<or> m2 = b)\n\ngoal (1 subgoal):\n 1. (\\<And>m.\n        C \\<subseteq> {m, b} \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  C \\<subseteq> {m, b}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>C = {} \\<Longrightarrow> thesis;\n     C = {b} \\<Longrightarrow> thesis;\n     \\<And>x.\n        \\<lbrakk>x \\<noteq> b; C = {x}\\<rbrakk> \\<Longrightarrow> thesis;\n     \\<And>x.\n        \\<lbrakk>x \\<noteq> b; C = {b, x}\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "thus ?thesis"], ["proof (prove)\nusing this:\n  C \\<subseteq> {m, b}\n\ngoal (1 subgoal):\n 1. thesis", "apply (cases \"m=b\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>C \\<subseteq> {m, b}; m = b\\<rbrakk> \\<Longrightarrow> thesis\n 2. \\<lbrakk>C \\<subseteq> {m, b}; m \\<noteq> b\\<rbrakk>\n    \\<Longrightarrow> thesis", "using that"], ["proof (prove)\nusing this:\n  C = {} \\<Longrightarrow> thesis\n  C = {b} \\<Longrightarrow> thesis\n  \\<lbrakk>?x \\<noteq> b; C = {?x}\\<rbrakk> \\<Longrightarrow> thesis\n  \\<lbrakk>?x \\<noteq> b; C = {b, ?x}\\<rbrakk> \\<Longrightarrow> thesis\n\ngoal (2 subgoals):\n 1. \\<lbrakk>C \\<subseteq> {m, b}; m = b\\<rbrakk> \\<Longrightarrow> thesis\n 2. \\<lbrakk>C \\<subseteq> {m, b}; m \\<noteq> b\\<rbrakk>\n    \\<Longrightarrow> thesis", "apply blast+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma flat_lub_simps[simp]:\n    \"flat_lub b {} = b\"\n    \"flat_lub b {x} = x\"\n    \"flat_lub b (insert b X) = flat_lub b X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. flat_lub b {} = b &&&\n    flat_lub b {x} = x &&& flat_lub b (insert b X) = flat_lub b X", "unfolding flat_lub_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if {} \\<subseteq> {b} then b else THE x. x \\<in> {} - {b}) = b &&&\n    (if {x} \\<subseteq> {b} then b else THE xa. xa \\<in> {x} - {b}) = x &&&\n    (if insert b X \\<subseteq> {b} then b\n     else THE x. x \\<in> insert b X - {b}) =\n    (if X \\<subseteq> {b} then b else THE x. x \\<in> X - {b})", "by auto"], ["", "lemma flat_ord_simps[simp]:\n    \"flat_ord b b x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. flat_ord b b x", "by (simp add: flat_ord_def)"], ["", "interpretation flat_ord: ccpo \"flat_lub b\" \"flat_ord b\" \"mk_less (flat_ord b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. class.ccpo (flat_lub b) (flat_ord b) (mk_less (flat_ord b))", "apply unfold_locales"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>x y.\n       mk_less (flat_ord b) x y =\n       (flat_ord b x y \\<and> \\<not> flat_ord b y x)\n 2. \\<And>x. flat_ord b x x\n 3. \\<And>x y z.\n       \\<lbrakk>flat_ord b x y; flat_ord b y z\\<rbrakk>\n       \\<Longrightarrow> flat_ord b x z\n 4. \\<And>x y.\n       \\<lbrakk>flat_ord b x y; flat_ord b y x\\<rbrakk>\n       \\<Longrightarrow> x = y\n 5. \\<And>A x.\n       \\<lbrakk>Complete_Partial_Order.chain (flat_ord b) A;\n        x \\<in> A\\<rbrakk>\n       \\<Longrightarrow> flat_ord b x (flat_lub b A)\n 6. \\<And>A z.\n       \\<lbrakk>Complete_Partial_Order.chain (flat_ord b) A;\n        \\<And>x. x \\<in> A \\<Longrightarrow> flat_ord b x z\\<rbrakk>\n       \\<Longrightarrow> flat_ord b (flat_lub b A) z", "apply (simp_all only: mk_less_def flat_ord_def)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x. x = b \\<or> x = x\n 2. \\<And>x y z.\n       \\<lbrakk>x = b \\<or> x = y; y = b \\<or> y = z\\<rbrakk>\n       \\<Longrightarrow> x = b \\<or> x = z\n 3. \\<And>x y.\n       \\<lbrakk>x = b \\<or> x = y; y = b \\<or> y = x\\<rbrakk>\n       \\<Longrightarrow> x = y\n 4. \\<And>A x.\n       \\<lbrakk>Complete_Partial_Order.chain (flat_ord b) A;\n        x \\<in> A\\<rbrakk>\n       \\<Longrightarrow> x = b \\<or> x = flat_lub b A\n 5. \\<And>A z.\n       \\<lbrakk>Complete_Partial_Order.chain (flat_ord b) A;\n        \\<And>x. x \\<in> A \\<Longrightarrow> x = b \\<or> x = z\\<rbrakk>\n       \\<Longrightarrow> flat_lub b A = b \\<or> flat_lub b A = z", "apply auto [4]"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>A x.\n       \\<lbrakk>Complete_Partial_Order.chain (flat_ord b) A; x \\<in> A;\n        x \\<noteq> flat_lub b A\\<rbrakk>\n       \\<Longrightarrow> x = b\n 2. \\<And>A z.\n       \\<lbrakk>Complete_Partial_Order.chain (flat_ord b) A;\n        \\<And>x. x \\<in> A \\<Longrightarrow> x = b \\<or> x = z\\<rbrakk>\n       \\<Longrightarrow> flat_lub b A = b \\<or> flat_lub b A = z", "apply (erule flat_ord_chain_cases, auto) []"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>A z.\n       \\<lbrakk>Complete_Partial_Order.chain (flat_ord b) A;\n        \\<And>x. x \\<in> A \\<Longrightarrow> x = b \\<or> x = z\\<rbrakk>\n       \\<Longrightarrow> flat_lub b A = b \\<or> flat_lub b A = z", "apply (erule flat_ord_chain_cases, auto) []"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "interpretation flat_le_mono_setup: mono_setup_loc \"flat_ord b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono_setup_loc (flat_ord b)", "by standard auto"], ["", "subsubsection \\<open>Flat function Ordering\\<close>"], ["", "abbreviation \"flatf_ord b == fun_ord (flat_ord b)\""], ["", "abbreviation \"flatf_lub b == fun_lub (flat_lub b)\""], ["", "interpretation flatf_ord: ccpo \"flatf_lub b\" \"flatf_ord b\" \"mk_less (flatf_ord b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. class.ccpo (flatf_lub b) (flatf_ord b) (mk_less (flatf_ord b))", "apply (rule ccpo_lift)"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.ccpo (flat_lub b) (flat_ord b) ?lt1", "apply unfold_locales"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsubsection \\<open>Fixed Points in Flat Ordering\\<close>"], ["", "text \\<open>\n    Fixed points in a flat ordering are used to express recursion.\n    The bottom element is interpreted as non-termination.\n\\<close>"], ["", "abbreviation \"flat_mono b == monotone (flat_ord b) (flat_ord b)\""], ["", "abbreviation \"flatf_mono b == monotone (flatf_ord b) (flatf_ord b)\""], ["", "abbreviation \"flatf_fp b \\<equiv> flatf_ord.fixp b\""], ["", "lemma flatf_fp_mono[refine_mono]:\n    \\<comment> \\<open>The fixed point combinator is monotonic\\<close>\n    assumes \"flatf_mono b f\"\n      and \"flatf_mono b g\"\n      and \"\\<And>Z x. flat_ord b (f Z x) (g Z x)\"\n    shows \"flat_ord b (flatf_fp b f x) (flatf_fp b g x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. flat_ord b (flatf_fp b f x) (flatf_fp b g x)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. flat_ord b (flatf_fp b f x) (flatf_fp b g x)", "have \"flatf_ord b (flatf_fp b f) (flatf_fp b g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. flatf_ord b (flatf_fp b f) (flatf_fp b g)", "apply (rule flatf_ord.fixp_mono[OF assms(1,2)])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Z. flatf_ord b (f Z) (g Z)", "using assms(3)"], ["proof (prove)\nusing this:\n  flat_ord b (f ?Z ?x) (g ?Z ?x)\n\ngoal (1 subgoal):\n 1. \\<And>Z. flatf_ord b (f Z) (g Z)", "by (simp add: fun_ord_def)"], ["proof (state)\nthis:\n  flatf_ord b (flatf_fp b f) (flatf_fp b g)\n\ngoal (1 subgoal):\n 1. flat_ord b (flatf_fp b f x) (flatf_fp b g x)", "thus ?thesis"], ["proof (prove)\nusing this:\n  flatf_ord b (flatf_fp b f) (flatf_fp b g)\n\ngoal (1 subgoal):\n 1. flat_ord b (flatf_fp b f x) (flatf_fp b g x)", "unfolding fun_ord_def"], ["proof (prove)\nusing this:\n  \\<forall>x.\n     flat_ord b\n      (ccpo.fixp (flatf_lub b)\n        (\\<lambda>f g. \\<forall>x. flat_ord b (f x) (g x)) f x)\n      (ccpo.fixp (flatf_lub b)\n        (\\<lambda>f g. \\<forall>x. flat_ord b (f x) (g x)) g x)\n\ngoal (1 subgoal):\n 1. flat_ord b\n     (ccpo.fixp (flatf_lub b)\n       (\\<lambda>f g. \\<forall>x. flat_ord b (f x) (g x)) f x)\n     (ccpo.fixp (flatf_lub b)\n       (\\<lambda>f g. \\<forall>x. flat_ord b (f x) (g x)) g x)", "by blast"], ["proof (state)\nthis:\n  flat_ord b (flatf_fp b f x) (flatf_fp b g x)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma flatf_admissible_pointwise:\n    \"(\\<And>x. P x b) \\<Longrightarrow> \n      ccpo.admissible (flatf_lub b) (flatf_ord b) (\\<lambda>g. \\<forall>x. P x (g x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x. P x b) \\<Longrightarrow>\n    ccpo.admissible (flatf_lub b) (flatf_ord b)\n     (\\<lambda>g. \\<forall>x. P x (g x))", "apply (intro ccpo.admissibleI allI impI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>A x.\n       \\<lbrakk>\\<And>x. P x b;\n        Complete_Partial_Order.chain (flatf_ord b) A; A \\<noteq> {};\n        \\<forall>x\\<in>A. \\<forall>xa. P xa (x xa)\\<rbrakk>\n       \\<Longrightarrow> P x (flatf_lub b A x)", "apply (drule_tac x=x in chain_f_apply)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>A x.\n       \\<lbrakk>\\<And>x. P x b; A \\<noteq> {};\n        \\<forall>x\\<in>A. \\<forall>xa. P xa (x xa);\n        Complete_Partial_Order.chain (flat_ord b)\n         {y. \\<exists>f\\<in>A. y = f x}\\<rbrakk>\n       \\<Longrightarrow> P x (flatf_lub b A x)", "apply (erule flat_ord_chain_cases)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>A x.\n       \\<lbrakk>\\<And>x. P x b; A \\<noteq> {};\n        \\<forall>x\\<in>A. \\<forall>xa. P xa (x xa);\n        {y. \\<exists>f\\<in>A. y = f x} = {}\\<rbrakk>\n       \\<Longrightarrow> P x (flatf_lub b A x)\n 2. \\<And>A x.\n       \\<lbrakk>\\<And>x. P x b; A \\<noteq> {};\n        \\<forall>x\\<in>A. \\<forall>xa. P xa (x xa);\n        {y. \\<exists>f\\<in>A. y = f x} = {b}\\<rbrakk>\n       \\<Longrightarrow> P x (flatf_lub b A x)\n 3. \\<And>A x xa.\n       \\<lbrakk>\\<And>x. P x b; A \\<noteq> {};\n        \\<forall>x\\<in>A. \\<forall>xa. P xa (x xa); xa \\<noteq> b;\n        {y. \\<exists>f\\<in>A. y = f x} = {xa}\\<rbrakk>\n       \\<Longrightarrow> P x (flatf_lub b A x)\n 4. \\<And>A x xa.\n       \\<lbrakk>\\<And>x. P x b; A \\<noteq> {};\n        \\<forall>x\\<in>A. \\<forall>xa. P xa (x xa); xa \\<noteq> b;\n        {y. \\<exists>f\\<in>A. y = f x} = {b, xa}\\<rbrakk>\n       \\<Longrightarrow> P x (flatf_lub b A x)", "apply (auto simp add: fun_lub_def) [2]"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>A x xa.\n       \\<lbrakk>\\<And>x. P x b; A \\<noteq> {};\n        \\<forall>x\\<in>A. \\<forall>xa. P xa (x xa); xa \\<noteq> b;\n        {y. \\<exists>f\\<in>A. y = f x} = {xa}\\<rbrakk>\n       \\<Longrightarrow> P x (flatf_lub b A x)\n 2. \\<And>A x xa.\n       \\<lbrakk>\\<And>x. P x b; A \\<noteq> {};\n        \\<forall>x\\<in>A. \\<forall>xa. P xa (x xa); xa \\<noteq> b;\n        {y. \\<exists>f\\<in>A. y = f x} = {b, xa}\\<rbrakk>\n       \\<Longrightarrow> P x (flatf_lub b A x)", "apply (force simp add: fun_lub_def) []"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>A x xa.\n       \\<lbrakk>\\<And>x. P x b; A \\<noteq> {};\n        \\<forall>x\\<in>A. \\<forall>xa. P xa (x xa); xa \\<noteq> b;\n        {y. \\<exists>f\\<in>A. y = f x} = {b, xa}\\<rbrakk>\n       \\<Longrightarrow> P x (flatf_lub b A x)", "apply (auto simp add: fun_lub_def) []"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>\n    If a property is defined pointwise, and holds for the bottom element,\n    we can use fixed-point induction for it. \n\n    In the induction step, we can assume that the function is less or equal\n    to the fixed-point.\n\n    This rule covers refinement and transfer properties, \n    such as: Refinement of fixed-point combinators and transfer of \n    fixed-point combinators to different domains.\n\\<close>"], ["", "lemma flatf_fp_induct_pointwise:\n    \\<comment> \\<open>Fixed-point induction for pointwise properties\\<close>\n    fixes a :: 'a\n    assumes cond_bot: \"\\<And>a x. pre a x \\<Longrightarrow> post a x b\"\n    assumes MONO: \"flatf_mono b B\"\n    assumes PRE0: \"pre a x\"\n    assumes STEP: \"\\<And>f a x. \n      \\<lbrakk>\\<And>a' x'. pre a' x' \\<Longrightarrow> post a' x' (f x'); pre a x; \n        flatf_ord b f (flatf_fp b B) \\<rbrakk> \n      \\<Longrightarrow> post a x (B f x)\"\n    shows \"post a x (flatf_fp b B x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. post a x (flatf_fp b B x)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. post a x (flatf_fp b B x)", "define ub where \"ub = flatf_fp b B\""], ["proof (state)\nthis:\n  ub = flatf_fp b B\n\ngoal (1 subgoal):\n 1. post a x (flatf_fp b B x)", "have \"(\\<forall>x a. pre a x \\<longrightarrow> post a x (flatf_fp b B x)) \n      \\<and> flatf_ord b (flatf_fp b B) ub\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x a.\n        pre a x \\<longrightarrow> post a x (flatf_fp b B x)) \\<and>\n    flatf_ord b (flatf_fp b B) ub", "apply (rule flatf_ord.fixp_induct[OF _ MONO])"], ["proof (prove)\ngoal (3 subgoals):\n 1. ccpo.admissible (flatf_lub b) (flatf_ord b)\n     (\\<lambda>a.\n         (\\<forall>x aa. pre aa x \\<longrightarrow> post aa x (a x)) \\<and>\n         flatf_ord b a ub)\n 2. (\\<forall>x a.\n        pre a x \\<longrightarrow> post a x (flatf_lub b {} x)) \\<and>\n    flatf_ord b (flatf_lub b {}) ub\n 3. \\<And>x.\n       (\\<forall>xa a. pre a xa \\<longrightarrow> post a xa (x xa)) \\<and>\n       flatf_ord b x ub \\<Longrightarrow>\n       (\\<forall>xa a. pre a xa \\<longrightarrow> post a xa (B x xa)) \\<and>\n       flatf_ord b (B x) ub", "apply (rule admissible_conj)"], ["proof (prove)\ngoal (4 subgoals):\n 1. ccpo.admissible (flatf_lub b) (flatf_ord b)\n     (\\<lambda>x.\n         \\<forall>xa a. pre a xa \\<longrightarrow> post a xa (x xa))\n 2. ccpo.admissible (flatf_lub b) (flatf_ord b)\n     (\\<lambda>x. flatf_ord b x ub)\n 3. (\\<forall>x a.\n        pre a x \\<longrightarrow> post a x (flatf_lub b {} x)) \\<and>\n    flatf_ord b (flatf_lub b {}) ub\n 4. \\<And>x.\n       (\\<forall>xa a. pre a xa \\<longrightarrow> post a xa (x xa)) \\<and>\n       flatf_ord b x ub \\<Longrightarrow>\n       (\\<forall>xa a. pre a xa \\<longrightarrow> post a xa (B x xa)) \\<and>\n       flatf_ord b (B x) ub", "apply (rule flatf_admissible_pointwise)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x. \\<forall>a. pre a x \\<longrightarrow> post a x b\n 2. ccpo.admissible (flatf_lub b) (flatf_ord b)\n     (\\<lambda>x. flatf_ord b x ub)\n 3. (\\<forall>x a.\n        pre a x \\<longrightarrow> post a x (flatf_lub b {} x)) \\<and>\n    flatf_ord b (flatf_lub b {}) ub\n 4. \\<And>x.\n       (\\<forall>xa a. pre a xa \\<longrightarrow> post a xa (x xa)) \\<and>\n       flatf_ord b x ub \\<Longrightarrow>\n       (\\<forall>xa a. pre a xa \\<longrightarrow> post a xa (B x xa)) \\<and>\n       flatf_ord b (B x) ub", "apply (blast intro: cond_bot)"], ["proof (prove)\ngoal (3 subgoals):\n 1. ccpo.admissible (flatf_lub b) (flatf_ord b)\n     (\\<lambda>x. flatf_ord b x ub)\n 2. (\\<forall>x a.\n        pre a x \\<longrightarrow> post a x (flatf_lub b {} x)) \\<and>\n    flatf_ord b (flatf_lub b {}) ub\n 3. \\<And>x.\n       (\\<forall>xa a. pre a xa \\<longrightarrow> post a xa (x xa)) \\<and>\n       flatf_ord b x ub \\<Longrightarrow>\n       (\\<forall>xa a. pre a xa \\<longrightarrow> post a xa (B x xa)) \\<and>\n       flatf_ord b (B x) ub", "apply (rule ccpo.admissibleI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>A.\n       \\<lbrakk>Complete_Partial_Order.chain (flatf_ord b) A; A \\<noteq> {};\n        \\<forall>x\\<in>A. flatf_ord b x ub\\<rbrakk>\n       \\<Longrightarrow> flatf_ord b (flatf_lub b A) ub\n 2. (\\<forall>x a.\n        pre a x \\<longrightarrow> post a x (flatf_lub b {} x)) \\<and>\n    flatf_ord b (flatf_lub b {}) ub\n 3. \\<And>x.\n       (\\<forall>xa a. pre a xa \\<longrightarrow> post a xa (x xa)) \\<and>\n       flatf_ord b x ub \\<Longrightarrow>\n       (\\<forall>xa a. pre a xa \\<longrightarrow> post a xa (B x xa)) \\<and>\n       flatf_ord b (B x) ub", "apply (blast intro: flatf_ord.ccpo_Sup_least)"], ["proof (prove)\ngoal (2 subgoals):\n 1. (\\<forall>x a.\n        pre a x \\<longrightarrow> post a x (flatf_lub b {} x)) \\<and>\n    flatf_ord b (flatf_lub b {}) ub\n 2. \\<And>x.\n       (\\<forall>xa a. pre a xa \\<longrightarrow> post a xa (x xa)) \\<and>\n       flatf_ord b x ub \\<Longrightarrow>\n       (\\<forall>xa a. pre a xa \\<longrightarrow> post a xa (B x xa)) \\<and>\n       flatf_ord b (B x) ub", "apply (auto intro: cond_bot simp: fun_ord_def flat_ord_def) []"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<forall>xa a. pre a xa \\<longrightarrow> post a xa (x xa)) \\<and>\n       flatf_ord b x ub \\<Longrightarrow>\n       (\\<forall>xa a. pre a xa \\<longrightarrow> post a xa (B x xa)) \\<and>\n       flatf_ord b (B x) ub", "apply (rule conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       (\\<forall>xa a. pre a xa \\<longrightarrow> post a xa (x xa)) \\<and>\n       flatf_ord b x ub \\<Longrightarrow>\n       \\<forall>xa a. pre a xa \\<longrightarrow> post a xa (B x xa)\n 2. \\<And>x.\n       (\\<forall>xa a. pre a xa \\<longrightarrow> post a xa (x xa)) \\<and>\n       flatf_ord b x ub \\<Longrightarrow>\n       flatf_ord b (B x) ub", "unfolding ub_def"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       (\\<forall>xa a. pre a xa \\<longrightarrow> post a xa (x xa)) \\<and>\n       flatf_ord b x (flatf_fp b B) \\<Longrightarrow>\n       \\<forall>xa a. pre a xa \\<longrightarrow> post a xa (B x xa)\n 2. \\<And>x.\n       (\\<forall>xa a. pre a xa \\<longrightarrow> post a xa (x xa)) \\<and>\n       flatf_ord b x (flatf_fp b B) \\<Longrightarrow>\n       flatf_ord b (B x) (flatf_fp b B)", "apply (blast intro: STEP)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<forall>xa a. pre a xa \\<longrightarrow> post a xa (x xa)) \\<and>\n       flatf_ord b x (flatf_fp b B) \\<Longrightarrow>\n       flatf_ord b (B x) (flatf_fp b B)", "apply (subst flatf_ord.fixp_unfold[OF MONO])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<forall>xa a. pre a xa \\<longrightarrow> post a xa (x xa)) \\<and>\n       flatf_ord b x (flatf_fp b B) \\<Longrightarrow>\n       flatf_ord b (B x) (B (flatf_fp b B))", "apply (blast intro: monotoneD[OF MONO])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (\\<forall>x a. pre a x \\<longrightarrow> post a x (flatf_fp b B x)) \\<and>\n  flatf_ord b (flatf_fp b B) ub\n\ngoal (1 subgoal):\n 1. post a x (flatf_fp b B x)", "with PRE0"], ["proof (chain)\npicking this:\n  pre a x\n  (\\<forall>x a. pre a x \\<longrightarrow> post a x (flatf_fp b B x)) \\<and>\n  flatf_ord b (flatf_fp b B) ub", "show ?thesis"], ["proof (prove)\nusing this:\n  pre a x\n  (\\<forall>x a. pre a x \\<longrightarrow> post a x (flatf_fp b B x)) \\<and>\n  flatf_ord b (flatf_fp b B) ub\n\ngoal (1 subgoal):\n 1. post a x (flatf_fp b B x)", "by blast"], ["proof (state)\nthis:\n  post a x (flatf_fp b B x)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n    The next rule covers transfer between fixed points.\n    It allows to lift a pointwise transfer condition \n    \\<open>P x y \\<longrightarrow> tr (f x) (f y)\\<close> to fixed points.\n    Note that one of the fixed points may be an arbitrary fixed point.\n\\<close>"], ["", "lemma flatf_fixp_transfer:\n    \\<comment> \\<open>Transfer rule for fixed points\\<close>\n    assumes TR_BOT[simp]: \"\\<And>x'. tr b x'\"\n    assumes MONO: \"flatf_mono b B\"\n    assumes FP': \"fp' = B' fp'\"\n    assumes R0: \"P x x'\"\n    assumes RS: \"\\<And>f f' x x'.\n       \\<lbrakk>\\<And>x x'. P x x' \\<Longrightarrow> tr (f x) (f' x'); P x x'; fp' = f'\\<rbrakk>\n       \\<Longrightarrow> tr (B f x) (B' f' x')\"\n    shows \"tr (flatf_fp b B x) (fp' x')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tr (flatf_fp b B x) (fp' x')", "apply (rule flatf_fp_induct_pointwise[where pre=\"\\<lambda>x y. P y x\", OF _ MONO])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a x. P x a \\<Longrightarrow> tr b (fp' a)\n 2. P x x'\n 3. \\<And>f a x.\n       \\<lbrakk>\\<And>a' x'. P x' a' \\<Longrightarrow> tr (f x') (fp' a');\n        P x a; flatf_ord b f (flatf_fp b B)\\<rbrakk>\n       \\<Longrightarrow> tr (B f x) (fp' a)", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. P x x'\n 2. \\<And>f a x.\n       \\<lbrakk>\\<And>a' x'. P x' a' \\<Longrightarrow> tr (f x') (fp' a');\n        P x a; flatf_ord b f (flatf_fp b B)\\<rbrakk>\n       \\<Longrightarrow> tr (B f x) (fp' a)", "apply (rule R0)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f a x.\n       \\<lbrakk>\\<And>a' x'. P x' a' \\<Longrightarrow> tr (f x') (fp' a');\n        P x a; flatf_ord b f (flatf_fp b B)\\<rbrakk>\n       \\<Longrightarrow> tr (B f x) (fp' a)", "apply (subst FP')"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f a x.\n       \\<lbrakk>\\<And>a' x'. P x' a' \\<Longrightarrow> tr (f x') (fp' a');\n        P x a; flatf_ord b f (flatf_fp b B)\\<rbrakk>\n       \\<Longrightarrow> tr (B f x) (B' fp' a)", "apply (blast intro: RS)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsubsection \\<open>Relation of Flat Ordering to Complete Lattices\\<close>"], ["", "text \\<open>\n    In this section, we establish the relation between flat orderings \n    and complete lattices. This relation is exploited to show properties\n    of fixed points wrt. a refinement ordering.\n\\<close>"], ["", "abbreviation \"flat_le \\<equiv> flat_ord bot\""], ["", "abbreviation \"flat_ge \\<equiv> flat_ord top\""], ["", "abbreviation \"flatf_le \\<equiv> flatf_ord bot\""], ["", "abbreviation \"flatf_ge \\<equiv> flatf_ord top\""], ["", "text \\<open>The flat ordering implies the lattice ordering\\<close>"], ["", "lemma flat_ord_compat: \n    fixes x y :: \"'a :: complete_lattice\"\n    shows \n    \"flat_le x y \\<Longrightarrow> x \\<le> y\"\n    \"flat_ge x y \\<Longrightarrow> x \\<ge> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (flat_le x y \\<Longrightarrow> x \\<le> y) &&&\n    (flat_ge x y \\<Longrightarrow> y \\<le> x)", "unfolding flat_ord_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (x = bot \\<or> x = y \\<Longrightarrow> x \\<le> y) &&&\n    (x = top \\<or> x = y \\<Longrightarrow> y \\<le> x)", "by auto"], ["", "lemma flatf_ord_compat: \n    fixes x y :: \"'a \\<Rightarrow> ('b :: complete_lattice)\"\n    shows \n    \"flatf_le x y \\<Longrightarrow> x \\<le> y\"\n    \"flatf_ge x y \\<Longrightarrow> x \\<ge> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (flatf_le x y \\<Longrightarrow> x \\<le> y) &&&\n    (flatf_ge x y \\<Longrightarrow> y \\<le> x)", "by (auto simp: flat_ord_compat le_fun_def fun_ord_def)"], ["", "abbreviation \"flat_mono_le \\<equiv> flat_mono bot\""], ["", "abbreviation \"flat_mono_ge \\<equiv> flat_mono top\""], ["", "abbreviation \"flatf_mono_le \\<equiv> flatf_mono bot\""], ["", "abbreviation \"flatf_mono_ge \\<equiv> flatf_mono top\""], ["", "abbreviation \"flatf_gfp \\<equiv> flatf_ord.fixp top\""], ["", "abbreviation \"flatf_lfp \\<equiv> flatf_ord.fixp bot\""], ["", "text \\<open>If a functor is monotonic wrt. both the flat and the \n    lattice ordering, the fixed points wrt. these orderings coincide. \n\\<close>"], ["", "lemma lfp_eq_flatf_lfp:\n    assumes FM: \"flatf_mono_le B\" and M: \"mono B\"\n    shows \"lfp B = flatf_lfp B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lfp B = flatf_lfp B", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. lfp B = flatf_lfp B", "from lfp_unfold[OF M, symmetric]"], ["proof (chain)\npicking this:\n  B (lfp B) = lfp B", "have \"B (lfp B) = lfp B\""], ["proof (prove)\nusing this:\n  B (lfp B) = lfp B\n\ngoal (1 subgoal):\n 1. B (lfp B) = lfp B", "."], ["proof (state)\nthis:\n  B (lfp B) = lfp B\n\ngoal (1 subgoal):\n 1. lfp B = flatf_lfp B", "hence \"flatf_le (B (lfp B)) (lfp B)\""], ["proof (prove)\nusing this:\n  B (lfp B) = lfp B\n\ngoal (1 subgoal):\n 1. flatf_le (B (lfp B)) (lfp B)", "by simp"], ["proof (state)\nthis:\n  flatf_le (B (lfp B)) (lfp B)\n\ngoal (1 subgoal):\n 1. lfp B = flatf_lfp B", "with flatf_ord.fixp_lowerbound[OF FM]"], ["proof (chain)\npicking this:\n  flatf_le (B ?z) ?z \\<Longrightarrow> flatf_le (flatf_lfp B) ?z\n  flatf_le (B (lfp B)) (lfp B)", "have \"flatf_le (flatf_lfp B) (lfp B)\""], ["proof (prove)\nusing this:\n  flatf_le (B ?z) ?z \\<Longrightarrow> flatf_le (flatf_lfp B) ?z\n  flatf_le (B (lfp B)) (lfp B)\n\ngoal (1 subgoal):\n 1. flatf_le (flatf_lfp B) (lfp B)", "."], ["proof (state)\nthis:\n  flatf_le (flatf_lfp B) (lfp B)\n\ngoal (1 subgoal):\n 1. lfp B = flatf_lfp B", "with flatf_ord_compat"], ["proof (chain)\npicking this:\n  flatf_le ?x ?y \\<Longrightarrow> ?x \\<le> ?y\n  flatf_ge ?x ?y \\<Longrightarrow> ?y \\<le> ?x\n  flatf_le (flatf_lfp B) (lfp B)", "have \"flatf_lfp B \\<le> lfp B\""], ["proof (prove)\nusing this:\n  flatf_le ?x ?y \\<Longrightarrow> ?x \\<le> ?y\n  flatf_ge ?x ?y \\<Longrightarrow> ?y \\<le> ?x\n  flatf_le (flatf_lfp B) (lfp B)\n\ngoal (1 subgoal):\n 1. flatf_lfp B \\<le> lfp B", "by blast"], ["proof (state)\nthis:\n  flatf_lfp B \\<le> lfp B\n\ngoal (1 subgoal):\n 1. lfp B = flatf_lfp B", "also"], ["proof (state)\nthis:\n  flatf_lfp B \\<le> lfp B\n\ngoal (1 subgoal):\n 1. lfp B = flatf_lfp B", "from flatf_ord.fixp_unfold[OF FM, symmetric]"], ["proof (chain)\npicking this:\n  B (flatf_lfp B) = flatf_lfp B", "have \"B (flatf_lfp B) = flatf_lfp B\""], ["proof (prove)\nusing this:\n  B (flatf_lfp B) = flatf_lfp B\n\ngoal (1 subgoal):\n 1. B (flatf_lfp B) = flatf_lfp B", "."], ["proof (state)\nthis:\n  B (flatf_lfp B) = flatf_lfp B\n\ngoal (1 subgoal):\n 1. lfp B = flatf_lfp B", "hence \"B (flatf_lfp B) \\<le> flatf_lfp B\""], ["proof (prove)\nusing this:\n  B (flatf_lfp B) = flatf_lfp B\n\ngoal (1 subgoal):\n 1. B (flatf_lfp B) \\<le> flatf_lfp B", "by simp"], ["proof (state)\nthis:\n  B (flatf_lfp B) \\<le> flatf_lfp B\n\ngoal (1 subgoal):\n 1. lfp B = flatf_lfp B", "with lfp_lowerbound[where A=\"flatf_lfp B\"]"], ["proof (chain)\npicking this:\n  ?f (flatf_lfp B) \\<le> flatf_lfp B \\<Longrightarrow>\n  lfp ?f \\<le> flatf_lfp B\n  B (flatf_lfp B) \\<le> flatf_lfp B", "have \"lfp B \\<le> flatf_lfp B\""], ["proof (prove)\nusing this:\n  ?f (flatf_lfp B) \\<le> flatf_lfp B \\<Longrightarrow>\n  lfp ?f \\<le> flatf_lfp B\n  B (flatf_lfp B) \\<le> flatf_lfp B\n\ngoal (1 subgoal):\n 1. lfp B \\<le> flatf_lfp B", "."], ["proof (state)\nthis:\n  lfp B \\<le> flatf_lfp B\n\ngoal (1 subgoal):\n 1. lfp B = flatf_lfp B", "finally"], ["proof (chain)\npicking this:\n  flatf_lfp B = lfp B", "show \"lfp B = flatf_lfp B\""], ["proof (prove)\nusing this:\n  flatf_lfp B = lfp B\n\ngoal (1 subgoal):\n 1. lfp B = flatf_lfp B", ".."], ["proof (state)\nthis:\n  lfp B = flatf_lfp B\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma gfp_eq_flatf_gfp:\n    assumes FM: \"flatf_mono_ge B\" and M: \"mono B\"\n    shows \"gfp B = flatf_gfp B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gfp B = flatf_gfp B", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. gfp B = flatf_gfp B", "from gfp_unfold[OF M, symmetric]"], ["proof (chain)\npicking this:\n  B (gfp B) = gfp B", "have \"B (gfp B) = gfp B\""], ["proof (prove)\nusing this:\n  B (gfp B) = gfp B\n\ngoal (1 subgoal):\n 1. B (gfp B) = gfp B", "."], ["proof (state)\nthis:\n  B (gfp B) = gfp B\n\ngoal (1 subgoal):\n 1. gfp B = flatf_gfp B", "hence \"flatf_ge (B (gfp B)) (gfp B)\""], ["proof (prove)\nusing this:\n  B (gfp B) = gfp B\n\ngoal (1 subgoal):\n 1. flatf_ge (B (gfp B)) (gfp B)", "by simp"], ["proof (state)\nthis:\n  flatf_ge (B (gfp B)) (gfp B)\n\ngoal (1 subgoal):\n 1. gfp B = flatf_gfp B", "with flatf_ord.fixp_lowerbound[OF FM]"], ["proof (chain)\npicking this:\n  flatf_ge (B ?z) ?z \\<Longrightarrow> flatf_ge (flatf_gfp B) ?z\n  flatf_ge (B (gfp B)) (gfp B)", "have \"flatf_ge (flatf_gfp B) (gfp B)\""], ["proof (prove)\nusing this:\n  flatf_ge (B ?z) ?z \\<Longrightarrow> flatf_ge (flatf_gfp B) ?z\n  flatf_ge (B (gfp B)) (gfp B)\n\ngoal (1 subgoal):\n 1. flatf_ge (flatf_gfp B) (gfp B)", "."], ["proof (state)\nthis:\n  flatf_ge (flatf_gfp B) (gfp B)\n\ngoal (1 subgoal):\n 1. gfp B = flatf_gfp B", "with flatf_ord_compat"], ["proof (chain)\npicking this:\n  flatf_le ?x ?y \\<Longrightarrow> ?x \\<le> ?y\n  flatf_ge ?x ?y \\<Longrightarrow> ?y \\<le> ?x\n  flatf_ge (flatf_gfp B) (gfp B)", "have \"gfp B \\<le> flatf_gfp B\""], ["proof (prove)\nusing this:\n  flatf_le ?x ?y \\<Longrightarrow> ?x \\<le> ?y\n  flatf_ge ?x ?y \\<Longrightarrow> ?y \\<le> ?x\n  flatf_ge (flatf_gfp B) (gfp B)\n\ngoal (1 subgoal):\n 1. gfp B \\<le> flatf_gfp B", "by blast"], ["proof (state)\nthis:\n  gfp B \\<le> flatf_gfp B\n\ngoal (1 subgoal):\n 1. gfp B = flatf_gfp B", "also"], ["proof (state)\nthis:\n  gfp B \\<le> flatf_gfp B\n\ngoal (1 subgoal):\n 1. gfp B = flatf_gfp B", "from flatf_ord.fixp_unfold[OF FM, symmetric]"], ["proof (chain)\npicking this:\n  B (flatf_gfp B) = flatf_gfp B", "have \"B (flatf_gfp B) = flatf_gfp B\""], ["proof (prove)\nusing this:\n  B (flatf_gfp B) = flatf_gfp B\n\ngoal (1 subgoal):\n 1. B (flatf_gfp B) = flatf_gfp B", "."], ["proof (state)\nthis:\n  B (flatf_gfp B) = flatf_gfp B\n\ngoal (1 subgoal):\n 1. gfp B = flatf_gfp B", "hence \"flatf_gfp B \\<le> B (flatf_gfp B)\""], ["proof (prove)\nusing this:\n  B (flatf_gfp B) = flatf_gfp B\n\ngoal (1 subgoal):\n 1. flatf_gfp B \\<le> B (flatf_gfp B)", "by simp"], ["proof (state)\nthis:\n  flatf_gfp B \\<le> B (flatf_gfp B)\n\ngoal (1 subgoal):\n 1. gfp B = flatf_gfp B", "with gfp_upperbound[where X=\"flatf_gfp B\"]"], ["proof (chain)\npicking this:\n  flatf_gfp B \\<le> ?f (flatf_gfp B) \\<Longrightarrow>\n  flatf_gfp B \\<le> gfp ?f\n  flatf_gfp B \\<le> B (flatf_gfp B)", "have \"flatf_gfp B \\<le> gfp B\""], ["proof (prove)\nusing this:\n  flatf_gfp B \\<le> ?f (flatf_gfp B) \\<Longrightarrow>\n  flatf_gfp B \\<le> gfp ?f\n  flatf_gfp B \\<le> B (flatf_gfp B)\n\ngoal (1 subgoal):\n 1. flatf_gfp B \\<le> gfp B", "."], ["proof (state)\nthis:\n  flatf_gfp B \\<le> gfp B\n\ngoal (1 subgoal):\n 1. gfp B = flatf_gfp B", "finally"], ["proof (chain)\npicking this:\n  gfp B = flatf_gfp B", "show \"gfp B = flatf_gfp B\""], ["proof (prove)\nusing this:\n  gfp B = flatf_gfp B\n\ngoal (1 subgoal):\n 1. gfp B = flatf_gfp B", "."], ["proof (state)\nthis:\n  gfp B = flatf_gfp B\n\ngoal:\nNo subgoals!", "qed"], ["", "(* TODO: This belongs to \"General Recursion\"*)"], ["", "text \\<open>\n    The following lemma provides a well-founded induction scheme for arbitrary \n    fixed point combinators.\n\\<close>"], ["", "lemma wf_fixp_induct:\n    \\<comment> \\<open>Well-Founded induction for arbitrary fixed points\\<close>\n    fixes a :: 'a\n    assumes fixp_unfold: \"fp B = B (fp B)\"\n    assumes WF: \"wf V\"\n    assumes P0: \"pre a x\"\n    assumes STEP: \"\\<And>f a x. \\<lbrakk> \n      \\<And>a' x'. \\<lbrakk> pre a' x'; (x',x)\\<in>V \\<rbrakk> \\<Longrightarrow> post a' x' (f x'); fp B = f; pre a x \n    \\<rbrakk> \\<Longrightarrow> post a x (B f x)\"\n    shows \"post a x (fp B x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. post a x (fp B x)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. post a x (fp B x)", "have \"\\<forall>a. pre a x \\<longrightarrow> post a x (fp B x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a. pre a x \\<longrightarrow> post a x (fp B x)", "using WF"], ["proof (prove)\nusing this:\n  wf V\n\ngoal (1 subgoal):\n 1. \\<forall>a. pre a x \\<longrightarrow> post a x (fp B x)", "apply (induct x rule: wf_induct_rule)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<And>y.\n           (y, x) \\<in> V \\<Longrightarrow>\n           \\<forall>a.\n              pre a y \\<longrightarrow> post a y (fp B y)) \\<Longrightarrow>\n       \\<forall>a. pre a x \\<longrightarrow> post a x (fp B x)", "apply (intro allI impI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x a.\n       \\<lbrakk>\\<And>y.\n                   (y, x) \\<in> V \\<Longrightarrow>\n                   \\<forall>a. pre a y \\<longrightarrow> post a y (fp B y);\n        pre a x\\<rbrakk>\n       \\<Longrightarrow> post a x (fp B x)", "apply (subst fixp_unfold)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x a.\n       \\<lbrakk>\\<And>y.\n                   (y, x) \\<in> V \\<Longrightarrow>\n                   \\<forall>a. pre a y \\<longrightarrow> post a y (fp B y);\n        pre a x\\<rbrakk>\n       \\<Longrightarrow> post a x (B (fp B) x)", "apply (rule STEP)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x a a' x'.\n       \\<lbrakk>\\<And>y.\n                   (y, x) \\<in> V \\<Longrightarrow>\n                   \\<forall>a. pre a y \\<longrightarrow> post a y (fp B y);\n        pre a x; pre a' x'; (x', x) \\<in> V\\<rbrakk>\n       \\<Longrightarrow> post a' x' (fp B x')\n 2. \\<And>x a.\n       \\<lbrakk>\\<And>y.\n                   (y, x) \\<in> V \\<Longrightarrow>\n                   \\<forall>a. pre a y \\<longrightarrow> post a y (fp B y);\n        pre a x\\<rbrakk>\n       \\<Longrightarrow> fp B = fp B\n 3. \\<And>x a.\n       \\<lbrakk>\\<And>y.\n                   (y, x) \\<in> V \\<Longrightarrow>\n                   \\<forall>a. pre a y \\<longrightarrow> post a y (fp B y);\n        pre a x\\<rbrakk>\n       \\<Longrightarrow> pre a x", "apply (simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x a.\n       \\<lbrakk>\\<And>y.\n                   (y, x) \\<in> V \\<Longrightarrow>\n                   \\<forall>a. pre a y \\<longrightarrow> post a y (fp B y);\n        pre a x\\<rbrakk>\n       \\<Longrightarrow> fp B = fp B\n 2. \\<And>x a.\n       \\<lbrakk>\\<And>y.\n                   (y, x) \\<in> V \\<Longrightarrow>\n                   \\<forall>a. pre a y \\<longrightarrow> post a y (fp B y);\n        pre a x\\<rbrakk>\n       \\<Longrightarrow> pre a x", "apply (simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x a.\n       \\<lbrakk>\\<And>y.\n                   (y, x) \\<in> V \\<Longrightarrow>\n                   \\<forall>a. pre a y \\<longrightarrow> post a y (fp B y);\n        pre a x\\<rbrakk>\n       \\<Longrightarrow> pre a x", "apply (simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<forall>a. pre a x \\<longrightarrow> post a x (fp B x)\n\ngoal (1 subgoal):\n 1. post a x (fp B x)", "with P0"], ["proof (chain)\npicking this:\n  pre a x\n  \\<forall>a. pre a x \\<longrightarrow> post a x (fp B x)", "show ?thesis"], ["proof (prove)\nusing this:\n  pre a x\n  \\<forall>a. pre a x \\<longrightarrow> post a x (fp B x)\n\ngoal (1 subgoal):\n 1. post a x (fp B x)", "by blast"], ["proof (state)\nthis:\n  post a x (fp B x)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma flatf_lfp_transfer:\n    \\<comment> \\<open>Transfer rule for least fixed points\\<close>\n    fixes B::\"(_ \\<Rightarrow> 'a::order_bot) \\<Rightarrow> _\"\n    assumes TR_BOT[simp]: \"\\<And>x. tr bot x\"\n    assumes MONO: \"flatf_mono_le B\"\n    assumes MONO': \"flatf_mono_le B'\"\n    assumes R0: \"P x x'\"\n    assumes RS: \"\\<And>f f' x x'.\n       \\<lbrakk>\\<And>x x'. P x x' \\<Longrightarrow> tr (f x) (f' x'); P x x'; flatf_lfp B' = f'\\<rbrakk>\n       \\<Longrightarrow> tr (B f x) (B' f' x')\"\n    shows \"tr (flatf_lfp B x) (flatf_lfp B' x')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tr (flatf_lfp B x) (flatf_lfp B' x')", "apply (rule flatf_fixp_transfer[where tr=tr and fp'=\"flatf_lfp B'\" and P=P])"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x'. tr bot x'\n 2. monotone flatf_le flatf_le B\n 3. flatf_lfp B' = ?B' (flatf_lfp B')\n 4. P x x'\n 5. \\<And>f f' x x'.\n       \\<lbrakk>\\<And>x x'. P x x' \\<Longrightarrow> tr (f x) (f' x');\n        P x x'; flatf_lfp B' = f'\\<rbrakk>\n       \\<Longrightarrow> tr (B f x) (?B' f' x')", "apply (fact|rule flatf_ord.fixp_unfold[OF MONO'])+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma flatf_gfp_transfer:\n    \\<comment> \\<open>Transfer rule for greatest fixed points\\<close>\n    fixes B::\"(_ \\<Rightarrow> 'a::order_top) \\<Rightarrow> _\"\n    assumes TR_TOP[simp]: \"\\<And>x. tr x top\"\n    assumes MONO: \"flatf_mono_ge B\"\n    assumes MONO': \"flatf_mono_ge B'\"\n    assumes R0: \"P x x'\"\n    assumes RS: \"\\<And>f f' x x'.\n       \\<lbrakk>\\<And>x x'. P x x' \\<Longrightarrow> tr (f x) (f' x'); P x x'; flatf_gfp B = f\\<rbrakk>\n       \\<Longrightarrow> tr (B f x) (B' f' x')\"\n    shows \"tr (flatf_gfp B x) (flatf_gfp B' x')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tr (flatf_gfp B x) (flatf_gfp B' x')", "apply (rule flatf_fixp_transfer[where \n        tr=\"\\<lambda>x y. tr y x\" and fp'=\"flatf_gfp B\" and P=\"\\<lambda>x y. P y x\"])"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x'. tr x' top\n 2. monotone flatf_ge flatf_ge B'\n 3. flatf_gfp B = ?B' (flatf_gfp B)\n 4. P x x'\n 5. \\<And>f f' x x'.\n       \\<lbrakk>\\<And>x x'. P x' x \\<Longrightarrow> tr (f' x') (f x);\n        P x' x; flatf_gfp B = f'\\<rbrakk>\n       \\<Longrightarrow> tr (?B' f' x') (B' f x)", "apply (fact|assumption|rule flatf_ord.fixp_unfold[OF MONO] RS)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma meta_le_everything_if_top: \"(m=top) \\<Longrightarrow> (\\<And>x. x \\<le> (m::'a::order_top))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m = top \\<Longrightarrow> (\\<And>x. x \\<le> m)", "by auto"], ["", "lemmas flatf_lfp_refine = flatf_lfp_transfer[\n    where tr = \"\\<lambda>a b. a \\<le> cf b\" for cf, OF bot_least]"], ["", "lemmas flatf_gfp_refine = flatf_gfp_transfer[\n    where tr = \"\\<lambda>a b. a \\<le> cf b\" for cf, OF meta_le_everything_if_top]"], ["", "lemma flat_ge_sup_mono[refine_mono]: \"\\<And>a a'::'a::complete_lattice. \n    flat_ge a a' \\<Longrightarrow> flat_ge b b' \\<Longrightarrow> flat_ge (sup a b) (sup a' b')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       \\<lbrakk>flat_ge a a'; flat_ge b b'\\<rbrakk>\n       \\<Longrightarrow> flat_ge (sup a b) (sup a' b')", "by (auto simp: flat_ord_def)"], ["", "declare sup_mono[refine_mono]"], ["", "end"]]}