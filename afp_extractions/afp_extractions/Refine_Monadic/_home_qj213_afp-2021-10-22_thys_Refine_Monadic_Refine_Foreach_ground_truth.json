{"file_name": "/home/qj213/afp-2021-10-22/thys/Refine_Monadic/Refine_Foreach.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Refine_Monadic", "problem_names": ["lemma it_step_insert_iff: \n  \"it \\<subseteq> S \\<Longrightarrow> x\\<in>it \\<Longrightarrow> S-(it-{x}) = insert x (S-it)\"", "lemmas FOREACH_to_oci_unfold\n  = FOREACHci_def FOREACHc_def FOREACHi_def FOREACHoi_def FOREACH_def", "lemma FOREACHoci_rule[refine_vcg]:\n  assumes FIN: \"finite S\"\n  assumes I0: \"I S \\<sigma>0\"\n  assumes IP: \n    \"\\<And>x it \\<sigma>. \\<lbrakk> c \\<sigma>; x\\<in>it; it\\<subseteq>S; I it \\<sigma>; \\<forall>y\\<in>it - {x}. R x y;\n                \\<forall>y\\<in>S - it. R y x \\<rbrakk> \\<Longrightarrow> f x \\<sigma> \\<le> SPEC (I (it-{x}))\"\n  assumes II1: \"\\<And>\\<sigma>. \\<lbrakk>I {} \\<sigma>\\<rbrakk> \\<Longrightarrow> P \\<sigma>\"\n  assumes II2: \"\\<And>it \\<sigma>. \\<lbrakk> it\\<noteq>{}; it\\<subseteq>S; I it \\<sigma>; \\<not>c \\<sigma>;\n                         \\<forall>x\\<in>it. \\<forall>y\\<in>S - it. R y x \\<rbrakk> \\<Longrightarrow> P \\<sigma>\"\n  shows \"FOREACHoci R I S c f \\<sigma>0 \\<le> SPEC P\"", "lemma FOREACHoi_rule[refine_vcg]:\n  assumes FIN: \"finite S\"\n  assumes I0: \"I S \\<sigma>0\"\n  assumes IP: \n    \"\\<And>x it \\<sigma>. \\<lbrakk> x\\<in>it; it\\<subseteq>S; I it \\<sigma>; \\<forall>y\\<in>it - {x}. R x y;\n                \\<forall>y\\<in>S - it. R y x \\<rbrakk> \\<Longrightarrow> f x \\<sigma> \\<le> SPEC (I (it-{x}))\"\n  assumes II1: \"\\<And>\\<sigma>. \\<lbrakk>I {} \\<sigma>\\<rbrakk> \\<Longrightarrow> P \\<sigma>\"\n  shows \"FOREACHoi R I S f \\<sigma>0 \\<le> SPEC P\"", "lemma FOREACHci_rule[refine_vcg]:\n  assumes FIN: \"finite S\"\n  assumes I0: \"I S \\<sigma>0\"\n  assumes IP: \n    \"\\<And>x it \\<sigma>. \\<lbrakk> x\\<in>it; it\\<subseteq>S; I it \\<sigma>; c \\<sigma> \\<rbrakk> \\<Longrightarrow> f x \\<sigma> \\<le> SPEC (I (it-{x}))\"\n  assumes II1: \"\\<And>\\<sigma>. \\<lbrakk>I {} \\<sigma>\\<rbrakk> \\<Longrightarrow> P \\<sigma>\"\n  assumes II2: \"\\<And>it \\<sigma>. \\<lbrakk> it\\<noteq>{}; it\\<subseteq>S; I it \\<sigma>; \\<not>c \\<sigma> \\<rbrakk> \\<Longrightarrow> P \\<sigma>\"\n  shows \"FOREACHci I S c f \\<sigma>0 \\<le> SPEC P\"", "lemma FOREACHoci_refine_genR:\n  fixes \\<alpha> :: \"'S \\<Rightarrow> 'Sa\" \\<comment> \\<open>Abstraction mapping of elements\\<close>\n  fixes S :: \"'S set\" \\<comment> \\<open>Concrete set\\<close>\n  fixes S' :: \"'Sa set\" \\<comment> \\<open>Abstract set\\<close>\n  fixes \\<sigma>0 :: \"'\\<sigma>\"\n  fixes \\<sigma>0' :: \"'\\<sigma>a\"\n  fixes R :: \"(('S set \\<times> '\\<sigma>) \\<times> ('Sa set \\<times> '\\<sigma>a)) set\"\n  assumes INJ: \"inj_on \\<alpha> S\" \n  assumes REFS[simp]: \"S' = \\<alpha>`S\"\n  assumes RR_OK: \"\\<And>x y. \\<lbrakk>x \\<in> S; y \\<in> S; RR x y\\<rbrakk> \\<Longrightarrow> RR' (\\<alpha> x) (\\<alpha> y)\"\n  assumes REF0: \"((S,\\<sigma>0),(\\<alpha>`S,\\<sigma>0')) \\<in> R\"\n  assumes REFC: \"\\<And>it \\<sigma> it' \\<sigma>'. \\<lbrakk> \n    it\\<subseteq>S; it'\\<subseteq>S'; \\<Phi>' it' \\<sigma>'; \\<Phi> it \\<sigma>; \n    \\<forall>x\\<in>S-it. \\<forall>y\\<in>it. RR x y; \\<forall>x\\<in>S'-it'. \\<forall>y\\<in>it'. RR' x y;\n    it'=\\<alpha>`it; ((it,\\<sigma>),(it',\\<sigma>'))\\<in>R\n  \\<rbrakk> \\<Longrightarrow> c \\<sigma> \\<longleftrightarrow> c' \\<sigma>'\"\n  assumes REFPHI: \"\\<And>it \\<sigma> it' \\<sigma>'. \\<lbrakk> \n    it\\<subseteq>S; it'\\<subseteq>S'; \\<Phi>' it' \\<sigma>';\n    \\<forall>x\\<in>S-it. \\<forall>y\\<in>it. RR x y; \\<forall>x\\<in>S'-it'. \\<forall>y\\<in>it'. RR' x y;\n    it'=\\<alpha>`it; ((it,\\<sigma>),(it',\\<sigma>'))\\<in>R\n  \\<rbrakk> \\<Longrightarrow> \\<Phi> it \\<sigma>\"\n  assumes REFSTEP: \"\\<And>x it \\<sigma> x' it' \\<sigma>'. \\<lbrakk>\n    it\\<subseteq>S; it'\\<subseteq>S'; \\<Phi> it \\<sigma>; \\<Phi>' it' \\<sigma>';\n    \\<forall>x\\<in>S-it. \\<forall>y\\<in>it. RR x y; \\<forall>x\\<in>S'-it'. \\<forall>y\\<in>it'. RR' x y;\n    x'=\\<alpha> x; it'=\\<alpha>`it; ((it,\\<sigma>),(it',\\<sigma>'))\\<in>R;\n    x\\<in>it; \\<forall>y\\<in>it-{x}. RR x y;\n    x'\\<in>it'; \\<forall>y'\\<in>it'-{x'}. RR' x' y';\n    c \\<sigma>; c' \\<sigma>'\n  \\<rbrakk> \\<Longrightarrow> f x \\<sigma> \n    \\<le> \\<Down>({(\\<sigma>, \\<sigma>'). ((it-{x},\\<sigma>),(it'-{x'},\\<sigma>'))\\<in>R}) (f' x' \\<sigma>')\"\n  assumes REF_R_DONE: \"\\<And>\\<sigma> \\<sigma>'. \\<lbrakk> \\<Phi> {} \\<sigma>; \\<Phi>' {} \\<sigma>'; (({},\\<sigma>),({},\\<sigma>'))\\<in>R \\<rbrakk> \n    \\<Longrightarrow> (\\<sigma>,\\<sigma>')\\<in>R'\"\n  assumes REF_R_BRK: \"\\<And>it \\<sigma> it' \\<sigma>'. \\<lbrakk> \n    it\\<subseteq>S; it'\\<subseteq>S'; \\<Phi> it \\<sigma>; \\<Phi>' it' \\<sigma>';\n    \\<forall>x\\<in>S-it. \\<forall>y\\<in>it. RR x y; \\<forall>x\\<in>S'-it'. \\<forall>y\\<in>it'. RR' x y;\n    it'=\\<alpha>`it; ((it,\\<sigma>),(it',\\<sigma>'))\\<in>R;\n    it\\<noteq>{}; it'\\<noteq>{};\n    \\<not>c \\<sigma>; \\<not>c' \\<sigma>'\n  \\<rbrakk> \\<Longrightarrow> (\\<sigma>,\\<sigma>')\\<in>R'\"\n  shows \"FOREACHoci RR \\<Phi> S c f \\<sigma>0 \\<le> \\<Down>R' (FOREACHoci RR' \\<Phi>' S' c' f' \\<sigma>0')\"", "lemma FOREACHoci_refine:\n  fixes \\<alpha> :: \"'S \\<Rightarrow> 'Sa\"\n  fixes S :: \"'S set\"\n  fixes S' :: \"'Sa set\"\n  assumes INJ: \"inj_on \\<alpha> S\"\n  assumes REFS: \"S' = \\<alpha>`S\"\n  assumes REF0: \"(\\<sigma>0,\\<sigma>0')\\<in>R\"\n  assumes RR_OK: \"\\<And>x y. \\<lbrakk>x \\<in> S; y \\<in> S; RR x y\\<rbrakk> \\<Longrightarrow> RR' (\\<alpha> x) (\\<alpha> y)\"\n  assumes REFPHI0: \"\\<Phi>'' S \\<sigma>0 (\\<alpha>`S) \\<sigma>0'\"\n  assumes REFC: \"\\<And>it \\<sigma> it' \\<sigma>'. \\<lbrakk> \n    it'=\\<alpha>`it; it\\<subseteq>S; it'\\<subseteq>S'; \\<Phi>' it' \\<sigma>';  \\<Phi>'' it \\<sigma> it' \\<sigma>'; \\<Phi> it \\<sigma>; (\\<sigma>,\\<sigma>')\\<in>R\n  \\<rbrakk> \\<Longrightarrow> c \\<sigma> \\<longleftrightarrow> c' \\<sigma>'\"\n  assumes REFPHI: \"\\<And>it \\<sigma> it' \\<sigma>'. \\<lbrakk> \n    it'=\\<alpha>`it; it\\<subseteq>S; it'\\<subseteq>S'; \\<Phi>' it' \\<sigma>'; \\<Phi>'' it \\<sigma> it' \\<sigma>'; (\\<sigma>,\\<sigma>')\\<in>R\n  \\<rbrakk> \\<Longrightarrow> \\<Phi> it \\<sigma>\"\n  assumes REFSTEP: \"\\<And>x it \\<sigma> x' it' \\<sigma>'. \\<lbrakk>\\<forall>y\\<in>it-{x}. RR x y; \n    x'=\\<alpha> x; x\\<in>it; x'\\<in>it'; it'=\\<alpha>`it; it\\<subseteq>S; it'\\<subseteq>S';\n    \\<Phi> it \\<sigma>; \\<Phi>' it' \\<sigma>';  \\<Phi>'' it \\<sigma> it' \\<sigma>'; c \\<sigma>; c' \\<sigma>';\n    (\\<sigma>,\\<sigma>')\\<in>R\n  \\<rbrakk> \\<Longrightarrow> f x \\<sigma> \n    \\<le> \\<Down>({(\\<sigma>, \\<sigma>'). (\\<sigma>, \\<sigma>') \\<in> R \\<and> \\<Phi>'' (it - {x}) \\<sigma> (it' - {x'}) \\<sigma>'}) (f' x' \\<sigma>')\"\n  shows \"FOREACHoci RR \\<Phi> S c f \\<sigma>0 \\<le> \\<Down>R (FOREACHoci RR' \\<Phi>' S' c' f' \\<sigma>0')\"", "lemma FOREACHoci_refine_rcg[refine]:\n  fixes \\<alpha> :: \"'S \\<Rightarrow> 'Sa\"\n  fixes S :: \"'S set\"\n  fixes S' :: \"'Sa set\"\n  assumes INJ: \"inj_on \\<alpha> S\"\n  assumes REFS: \"S' = \\<alpha>`S\"\n  assumes REF0: \"(\\<sigma>0,\\<sigma>0')\\<in>R\"\n  assumes RR_OK: \"\\<And>x y. \\<lbrakk>x \\<in> S; y \\<in> S; RR x y\\<rbrakk> \\<Longrightarrow> RR' (\\<alpha> x) (\\<alpha> y)\"\n  assumes REFC: \"\\<And>it \\<sigma> it' \\<sigma>'. \\<lbrakk> \n    it'=\\<alpha>`it; it\\<subseteq>S; it'\\<subseteq>S'; \\<Phi>' it' \\<sigma>'; \\<Phi> it \\<sigma>; (\\<sigma>,\\<sigma>')\\<in>R\n  \\<rbrakk> \\<Longrightarrow> c \\<sigma> \\<longleftrightarrow> c' \\<sigma>'\"\n  assumes REFPHI: \"\\<And>it \\<sigma> it' \\<sigma>'. \\<lbrakk> \n    it'=\\<alpha>`it; it\\<subseteq>S; it'\\<subseteq>S'; \\<Phi>' it' \\<sigma>'; (\\<sigma>,\\<sigma>')\\<in>R\n  \\<rbrakk> \\<Longrightarrow> \\<Phi> it \\<sigma>\"\n  assumes REFSTEP: \"\\<And>x it \\<sigma> x' it' \\<sigma>'. \\<lbrakk> \\<forall>y\\<in>it-{x}. RR x y;\n    x'=\\<alpha> x; x\\<in>it; x'\\<in>it'; it'=\\<alpha>`it; it\\<subseteq>S; it'\\<subseteq>S';\n    \\<Phi> it \\<sigma>; \\<Phi>' it' \\<sigma>'; c \\<sigma>; c' \\<sigma>';\n    (\\<sigma>,\\<sigma>')\\<in>R\n  \\<rbrakk> \\<Longrightarrow> f x \\<sigma> \\<le> \\<Down>R (f' x' \\<sigma>')\"\n  shows \"FOREACHoci RR \\<Phi> S c f \\<sigma>0 \\<le> \\<Down>R (FOREACHoci RR' \\<Phi>' S' c' f' \\<sigma>0')\"", "lemma FOREACHoci_weaken:\n  assumes IREF: \"\\<And>it \\<sigma>. it\\<subseteq>S \\<Longrightarrow> I it \\<sigma> \\<Longrightarrow> I' it \\<sigma>\"\n  shows \"FOREACHoci RR I' S c f \\<sigma>0 \\<le> FOREACHoci RR I S c f \\<sigma>0\"", "lemma FOREACHoci_weaken_order:\n  assumes RRREF: \"\\<And>x y. x \\<in> S \\<Longrightarrow> y \\<in> S \\<Longrightarrow> RR x y \\<Longrightarrow> RR' x y\"\n  shows \"FOREACHoci RR I S c f \\<sigma>0 \\<le> FOREACHoci RR' I S c f \\<sigma>0\"", "lemma FOREACHoi_refine_genR:\n  fixes \\<alpha> :: \"'S \\<Rightarrow> 'Sa\" \\<comment> \\<open>Abstraction mapping of elements\\<close>\n  fixes S :: \"'S set\" \\<comment> \\<open>Concrete set\\<close>\n  fixes S' :: \"'Sa set\" \\<comment> \\<open>Abstract set\\<close>\n  fixes \\<sigma>0 :: \"'\\<sigma>\"\n  fixes \\<sigma>0' :: \"'\\<sigma>a\"\n  fixes R :: \"(('S set \\<times> '\\<sigma>) \\<times> ('Sa set \\<times> '\\<sigma>a)) set\"\n  assumes INJ: \"inj_on \\<alpha> S\" \n  assumes REFS[simp]: \"S' = \\<alpha>`S\"\n  assumes RR_OK: \"\\<And>x y. \\<lbrakk>x \\<in> S; y \\<in> S; RR x y\\<rbrakk> \\<Longrightarrow> RR' (\\<alpha> x) (\\<alpha> y)\"\n  assumes REF0: \"((S,\\<sigma>0),(\\<alpha>`S,\\<sigma>0')) \\<in> R\"\n  assumes REFPHI: \"\\<And>it \\<sigma> it' \\<sigma>'. \\<lbrakk> \n    it\\<subseteq>S; it'\\<subseteq>S'; \\<Phi>' it' \\<sigma>';\n    \\<forall>x\\<in>S-it. \\<forall>y\\<in>it. RR x y; \\<forall>x\\<in>S'-it'. \\<forall>y\\<in>it'. RR' x y;\n    it'=\\<alpha>`it; ((it,\\<sigma>),(it',\\<sigma>'))\\<in>R\n  \\<rbrakk> \\<Longrightarrow> \\<Phi> it \\<sigma>\"\n  assumes REFSTEP: \"\\<And>x it \\<sigma> x' it' \\<sigma>'. \\<lbrakk>\n    it\\<subseteq>S; it'\\<subseteq>S'; \\<Phi> it \\<sigma>; \\<Phi>' it' \\<sigma>';\n    \\<forall>x\\<in>S-it. \\<forall>y\\<in>it. RR x y; \\<forall>x\\<in>S'-it'. \\<forall>y\\<in>it'. RR' x y;\n    x'=\\<alpha> x; it'=\\<alpha>`it; ((it,\\<sigma>),(it',\\<sigma>'))\\<in>R;\n    x\\<in>it; \\<forall>y\\<in>it-{x}. RR x y;\n    x'\\<in>it'; \\<forall>y'\\<in>it'-{x'}. RR' x' y'\n  \\<rbrakk> \\<Longrightarrow> f x \\<sigma> \n    \\<le> \\<Down>({(\\<sigma>, \\<sigma>'). ((it-{x},\\<sigma>),(it'-{x'},\\<sigma>'))\\<in>R}) (f' x' \\<sigma>')\"\n  assumes REF_R_DONE: \"\\<And>\\<sigma> \\<sigma>'. \\<lbrakk> \\<Phi> {} \\<sigma>; \\<Phi>' {} \\<sigma>'; (({},\\<sigma>),({},\\<sigma>'))\\<in>R \\<rbrakk> \n    \\<Longrightarrow> (\\<sigma>,\\<sigma>')\\<in>R'\"\n  shows \"FOREACHoi RR \\<Phi> S f \\<sigma>0 \\<le> \\<Down>R' (FOREACHoi RR' \\<Phi>' S' f' \\<sigma>0')\"", "lemma FOREACHoi_refine:\n  fixes \\<alpha> :: \"'S \\<Rightarrow> 'Sa\"\n  fixes S :: \"'S set\"\n  fixes S' :: \"'Sa set\"\n  assumes INJ: \"inj_on \\<alpha> S\"\n  assumes REFS: \"S' = \\<alpha>`S\"\n  assumes REF0: \"(\\<sigma>0,\\<sigma>0')\\<in>R\"\n  assumes RR_OK: \"\\<And>x y. \\<lbrakk>x \\<in> S; y \\<in> S; RR x y\\<rbrakk> \\<Longrightarrow> RR' (\\<alpha> x) (\\<alpha> y)\"\n  assumes REFPHI0: \"\\<Phi>'' S \\<sigma>0 (\\<alpha>`S) \\<sigma>0'\"\n  assumes REFPHI: \"\\<And>it \\<sigma> it' \\<sigma>'. \\<lbrakk> \n    it'=\\<alpha>`it; it\\<subseteq>S; it'\\<subseteq>S'; \\<Phi>' it' \\<sigma>'; \\<Phi>'' it \\<sigma> it' \\<sigma>'; (\\<sigma>,\\<sigma>')\\<in>R\n  \\<rbrakk> \\<Longrightarrow> \\<Phi> it \\<sigma>\"\n  assumes REFSTEP: \"\\<And>x it \\<sigma> x' it' \\<sigma>'. \\<lbrakk>\\<forall>y\\<in>it-{x}. RR x y; \n    x'=\\<alpha> x; x\\<in>it; x'\\<in>it'; it'=\\<alpha>`it; it\\<subseteq>S; it'\\<subseteq>S';\n    \\<Phi> it \\<sigma>; \\<Phi>' it' \\<sigma>';  \\<Phi>'' it \\<sigma> it' \\<sigma>'; (\\<sigma>,\\<sigma>')\\<in>R\n  \\<rbrakk> \\<Longrightarrow> f x \\<sigma> \n    \\<le> \\<Down>({(\\<sigma>, \\<sigma>'). (\\<sigma>, \\<sigma>') \\<in> R \\<and> \\<Phi>'' (it - {x}) \\<sigma> (it' - {x'}) \\<sigma>'}) (f' x' \\<sigma>')\"\n  shows \"FOREACHoi RR \\<Phi> S f \\<sigma>0 \\<le> \\<Down>R (FOREACHoi RR' \\<Phi>' S' f' \\<sigma>0')\"", "lemma FOREACHoi_refine_rcg[refine]:\n  fixes \\<alpha> :: \"'S \\<Rightarrow> 'Sa\"\n  fixes S :: \"'S set\"\n  fixes S' :: \"'Sa set\"\n  assumes INJ: \"inj_on \\<alpha> S\"\n  assumes REFS: \"S' = \\<alpha>`S\"\n  assumes REF0: \"(\\<sigma>0,\\<sigma>0')\\<in>R\"\n  assumes RR_OK: \"\\<And>x y. \\<lbrakk>x \\<in> S; y \\<in> S; RR x y\\<rbrakk> \\<Longrightarrow> RR' (\\<alpha> x) (\\<alpha> y)\"\n  assumes REFPHI: \"\\<And>it \\<sigma> it' \\<sigma>'. \\<lbrakk> \n    it'=\\<alpha>`it; it\\<subseteq>S; it'\\<subseteq>S'; \\<Phi>' it' \\<sigma>'; (\\<sigma>,\\<sigma>')\\<in>R\n  \\<rbrakk> \\<Longrightarrow> \\<Phi> it \\<sigma>\"\n  assumes REFSTEP: \"\\<And>x it \\<sigma> x' it' \\<sigma>'. \\<lbrakk> \\<forall>y\\<in>it-{x}. RR x y;\n    x'=\\<alpha> x; x\\<in>it; x'\\<in>it'; it'=\\<alpha>`it; it\\<subseteq>S; it'\\<subseteq>S';\n    \\<Phi> it \\<sigma>; \\<Phi>' it' \\<sigma>'; (\\<sigma>,\\<sigma>')\\<in>R\n  \\<rbrakk> \\<Longrightarrow> f x \\<sigma> \\<le> \\<Down>R (f' x' \\<sigma>')\"\n  shows \"FOREACHoi RR \\<Phi> S f \\<sigma>0 \\<le> \\<Down>R (FOREACHoi RR' \\<Phi>' S' f' \\<sigma>0')\"", "lemma FOREACHci_refine_genR:\n  fixes \\<alpha> :: \"'S \\<Rightarrow> 'Sa\" \\<comment> \\<open>Abstraction mapping of elements\\<close>\n  fixes S :: \"'S set\" \\<comment> \\<open>Concrete set\\<close>\n  fixes S' :: \"'Sa set\" \\<comment> \\<open>Abstract set\\<close>\n  fixes \\<sigma>0 :: \"'\\<sigma>\"\n  fixes \\<sigma>0' :: \"'\\<sigma>a\"\n  fixes R :: \"(('S set \\<times> '\\<sigma>) \\<times> ('Sa set \\<times> '\\<sigma>a)) set\"\n  assumes INJ: \"inj_on \\<alpha> S\" \n  assumes REFS[simp]: \"S' = \\<alpha>`S\"\n  assumes REF0: \"((S,\\<sigma>0),(\\<alpha>`S,\\<sigma>0')) \\<in> R\"\n  assumes REFC: \"\\<And>it \\<sigma> it' \\<sigma>'. \\<lbrakk> \n    it\\<subseteq>S; it'\\<subseteq>S'; \\<Phi>' it' \\<sigma>'; \\<Phi> it \\<sigma>; \n    it'=\\<alpha>`it; ((it,\\<sigma>),(it',\\<sigma>'))\\<in>R\n  \\<rbrakk> \\<Longrightarrow> c \\<sigma> \\<longleftrightarrow> c' \\<sigma>'\"\n  assumes REFPHI: \"\\<And>it \\<sigma> it' \\<sigma>'. \\<lbrakk> \n    it\\<subseteq>S; it'\\<subseteq>S'; \\<Phi>' it' \\<sigma>';\n    it'=\\<alpha>`it; ((it,\\<sigma>),(it',\\<sigma>'))\\<in>R\n  \\<rbrakk> \\<Longrightarrow> \\<Phi> it \\<sigma>\"\n  assumes REFSTEP: \"\\<And>x it \\<sigma> x' it' \\<sigma>'. \\<lbrakk>\n    it\\<subseteq>S; it'\\<subseteq>S'; \\<Phi> it \\<sigma>; \\<Phi>' it' \\<sigma>';\n    x'=\\<alpha> x; it'=\\<alpha>`it; ((it,\\<sigma>),(it',\\<sigma>'))\\<in>R;\n    x\\<in>it; x'\\<in>it';\n    c \\<sigma>; c' \\<sigma>'\n  \\<rbrakk> \\<Longrightarrow> f x \\<sigma> \n    \\<le> \\<Down>({(\\<sigma>, \\<sigma>'). ((it-{x},\\<sigma>),(it'-{x'},\\<sigma>'))\\<in>R}) (f' x' \\<sigma>')\"\n  assumes REF_R_DONE: \"\\<And>\\<sigma> \\<sigma>'. \\<lbrakk> \\<Phi> {} \\<sigma>; \\<Phi>' {} \\<sigma>'; (({},\\<sigma>),({},\\<sigma>'))\\<in>R \\<rbrakk> \n    \\<Longrightarrow> (\\<sigma>,\\<sigma>')\\<in>R'\"\n  assumes REF_R_BRK: \"\\<And>it \\<sigma> it' \\<sigma>'. \\<lbrakk> \n    it\\<subseteq>S; it'\\<subseteq>S'; \\<Phi> it \\<sigma>; \\<Phi>' it' \\<sigma>';\n    it'=\\<alpha>`it; ((it,\\<sigma>),(it',\\<sigma>'))\\<in>R;\n    it\\<noteq>{}; it'\\<noteq>{};\n    \\<not>c \\<sigma>; \\<not>c' \\<sigma>'\n  \\<rbrakk> \\<Longrightarrow> (\\<sigma>,\\<sigma>')\\<in>R'\"\n  shows \"FOREACHci \\<Phi> S c f \\<sigma>0 \\<le> \\<Down>R' (FOREACHci \\<Phi>' S' c' f' \\<sigma>0')\"", "lemma FOREACHci_refine:\n  fixes \\<alpha> :: \"'S \\<Rightarrow> 'Sa\"\n  fixes S :: \"'S set\"\n  fixes S' :: \"'Sa set\"\n  assumes INJ: \"inj_on \\<alpha> S\"\n  assumes REFS: \"S' = \\<alpha>`S\"\n  assumes REF0: \"(\\<sigma>0,\\<sigma>0')\\<in>R\"\n  assumes REFPHI0: \"\\<Phi>'' S \\<sigma>0 (\\<alpha>`S) \\<sigma>0'\"\n  assumes REFC: \"\\<And>it \\<sigma> it' \\<sigma>'. \\<lbrakk> \n    it'=\\<alpha>`it; it\\<subseteq>S; it'\\<subseteq>S'; \\<Phi>' it' \\<sigma>';  \\<Phi>'' it \\<sigma> it' \\<sigma>'; \\<Phi> it \\<sigma>; (\\<sigma>,\\<sigma>')\\<in>R\n  \\<rbrakk> \\<Longrightarrow> c \\<sigma> \\<longleftrightarrow> c' \\<sigma>'\"\n  assumes REFPHI: \"\\<And>it \\<sigma> it' \\<sigma>'. \\<lbrakk> \n    it'=\\<alpha>`it; it\\<subseteq>S; it'\\<subseteq>S'; \\<Phi>' it' \\<sigma>'; \\<Phi>'' it \\<sigma> it' \\<sigma>'; (\\<sigma>,\\<sigma>')\\<in>R\n  \\<rbrakk> \\<Longrightarrow> \\<Phi> it \\<sigma>\"\n  assumes REFSTEP: \"\\<And>x it \\<sigma> x' it' \\<sigma>'. \\<lbrakk> \n    x'=\\<alpha> x; x\\<in>it; x'\\<in>it'; it'=\\<alpha>`it; it\\<subseteq>S; it'\\<subseteq>S';\n    \\<Phi> it \\<sigma>; \\<Phi>' it' \\<sigma>';  \\<Phi>'' it \\<sigma> it' \\<sigma>'; c \\<sigma>; c' \\<sigma>';\n    (\\<sigma>,\\<sigma>')\\<in>R\n  \\<rbrakk> \\<Longrightarrow> f x \\<sigma> \n    \\<le> \\<Down>({(\\<sigma>, \\<sigma>'). (\\<sigma>, \\<sigma>') \\<in> R \\<and> \\<Phi>'' (it - {x}) \\<sigma> (it' - {x'}) \\<sigma>'}) (f' x' \\<sigma>')\"\n  shows \"FOREACHci \\<Phi> S c f \\<sigma>0 \\<le> \\<Down>R (FOREACHci \\<Phi>' S' c' f' \\<sigma>0')\"", "lemma FOREACHci_refine_rcg[refine]:\n  fixes \\<alpha> :: \"'S \\<Rightarrow> 'Sa\"\n  fixes S :: \"'S set\"\n  fixes S' :: \"'Sa set\"\n  assumes INJ: \"inj_on \\<alpha> S\"\n  assumes REFS: \"S' = \\<alpha>`S\"\n  assumes REF0: \"(\\<sigma>0,\\<sigma>0')\\<in>R\"\n  assumes REFC: \"\\<And>it \\<sigma> it' \\<sigma>'. \\<lbrakk> \n    it'=\\<alpha>`it; it\\<subseteq>S; it'\\<subseteq>S'; \\<Phi>' it' \\<sigma>'; \\<Phi> it \\<sigma>; (\\<sigma>,\\<sigma>')\\<in>R\n  \\<rbrakk> \\<Longrightarrow> c \\<sigma> \\<longleftrightarrow> c' \\<sigma>'\"\n  assumes REFPHI: \"\\<And>it \\<sigma> it' \\<sigma>'. \\<lbrakk> \n    it'=\\<alpha>`it; it\\<subseteq>S; it'\\<subseteq>S'; \\<Phi>' it' \\<sigma>'; (\\<sigma>,\\<sigma>')\\<in>R\n  \\<rbrakk> \\<Longrightarrow> \\<Phi> it \\<sigma>\"\n  assumes REFSTEP: \"\\<And>x it \\<sigma> x' it' \\<sigma>'. \\<lbrakk> \n    x'=\\<alpha> x; x\\<in>it; x'\\<in>it'; it'=\\<alpha>`it; it\\<subseteq>S; it'\\<subseteq>S';\n    \\<Phi> it \\<sigma>; \\<Phi>' it' \\<sigma>'; c \\<sigma>; c' \\<sigma>';\n    (\\<sigma>,\\<sigma>')\\<in>R\n  \\<rbrakk> \\<Longrightarrow> f x \\<sigma> \\<le> \\<Down>R (f' x' \\<sigma>')\"\n  shows \"FOREACHci \\<Phi> S c f \\<sigma>0 \\<le> \\<Down>R (FOREACHci \\<Phi>' S' c' f' \\<sigma>0')\"", "lemma FOREACHci_weaken:\n  assumes IREF: \"\\<And>it \\<sigma>. it\\<subseteq>S \\<Longrightarrow> I it \\<sigma> \\<Longrightarrow> I' it \\<sigma>\"\n  shows \"FOREACHci I' S c f \\<sigma>0 \\<le> FOREACHci I S c f \\<sigma>0\"", "lemma FOREACHi_rule[refine_vcg]:\n  assumes FIN: \"finite S\"\n  assumes I0: \"I S \\<sigma>0\"\n  assumes IP: \n    \"\\<And>x it \\<sigma>. \\<lbrakk> x\\<in>it; it\\<subseteq>S; I it \\<sigma> \\<rbrakk> \\<Longrightarrow> f x \\<sigma> \\<le> SPEC (I (it-{x}))\"\n  assumes II: \"\\<And>\\<sigma>. \\<lbrakk>I {} \\<sigma>\\<rbrakk> \\<Longrightarrow> P \\<sigma>\"\n  shows \"FOREACHi I S f \\<sigma>0 \\<le> SPEC P\"", "lemma FOREACHc_rule:\n  assumes FIN: \"finite S\"\n  assumes I0: \"I S \\<sigma>0\"\n  assumes IP: \n    \"\\<And>x it \\<sigma>. \\<lbrakk> x\\<in>it; it\\<subseteq>S; I it \\<sigma>; c \\<sigma> \\<rbrakk> \\<Longrightarrow> f x \\<sigma> \\<le> SPEC (I (it-{x}))\"\n  assumes II1: \"\\<And>\\<sigma>. \\<lbrakk>I {} \\<sigma>\\<rbrakk> \\<Longrightarrow> P \\<sigma>\"\n  assumes II2: \"\\<And>it \\<sigma>. \\<lbrakk> it\\<noteq>{}; it\\<subseteq>S; I it \\<sigma>; \\<not>c \\<sigma> \\<rbrakk> \\<Longrightarrow> P \\<sigma>\"\n  shows \"FOREACHc S c f \\<sigma>0 \\<le> SPEC P\"", "lemma FOREACH_rule:\n  assumes FIN: \"finite S\"\n  assumes I0: \"I S \\<sigma>0\"\n  assumes IP: \n    \"\\<And>x it \\<sigma>. \\<lbrakk> x\\<in>it; it\\<subseteq>S; I it \\<sigma> \\<rbrakk> \\<Longrightarrow> f x \\<sigma> \\<le> SPEC (I (it-{x}))\"\n  assumes II: \"\\<And>\\<sigma>. \\<lbrakk>I {} \\<sigma>\\<rbrakk> \\<Longrightarrow> P \\<sigma>\"\n  shows \"FOREACH S f \\<sigma>0 \\<le> SPEC P\"", "lemma FOREACHc_refine_genR:\n  fixes \\<alpha> :: \"'S \\<Rightarrow> 'Sa\" \\<comment> \\<open>Abstraction mapping of elements\\<close>\n  fixes S :: \"'S set\" \\<comment> \\<open>Concrete set\\<close>\n  fixes S' :: \"'Sa set\" \\<comment> \\<open>Abstract set\\<close>\n  fixes \\<sigma>0 :: \"'\\<sigma>\"\n  fixes \\<sigma>0' :: \"'\\<sigma>a\"\n  fixes R :: \"(('S set \\<times> '\\<sigma>) \\<times> ('Sa set \\<times> '\\<sigma>a)) set\"\n  assumes INJ: \"inj_on \\<alpha> S\" \n  assumes REFS[simp]: \"S' = \\<alpha>`S\"\n  assumes REF0: \"((S,\\<sigma>0),(\\<alpha>`S,\\<sigma>0')) \\<in> R\"\n  assumes REFC: \"\\<And>it \\<sigma> it' \\<sigma>'. \\<lbrakk> \n    it\\<subseteq>S; it'\\<subseteq>S'; \n    it'=\\<alpha>`it; ((it,\\<sigma>),(it',\\<sigma>'))\\<in>R\n  \\<rbrakk> \\<Longrightarrow> c \\<sigma> \\<longleftrightarrow> c' \\<sigma>'\"\n  assumes REFSTEP: \"\\<And>x it \\<sigma> x' it' \\<sigma>'. \\<lbrakk>\n    it\\<subseteq>S; it'\\<subseteq>S'; \n    x'=\\<alpha> x; it'=\\<alpha>`it; ((it,\\<sigma>),(it',\\<sigma>'))\\<in>R;\n    x\\<in>it; x'\\<in>it';\n    c \\<sigma>; c' \\<sigma>'\n  \\<rbrakk> \\<Longrightarrow> f x \\<sigma> \n    \\<le> \\<Down>({(\\<sigma>, \\<sigma>'). ((it-{x},\\<sigma>),(it'-{x'},\\<sigma>'))\\<in>R}) (f' x' \\<sigma>')\"\n  assumes REF_R_DONE: \"\\<And>\\<sigma> \\<sigma>'. \\<lbrakk> (({},\\<sigma>),({},\\<sigma>'))\\<in>R \\<rbrakk> \n    \\<Longrightarrow> (\\<sigma>,\\<sigma>')\\<in>R'\"\n  assumes REF_R_BRK: \"\\<And>it \\<sigma> it' \\<sigma>'. \\<lbrakk> \n    it\\<subseteq>S; it'\\<subseteq>S'; \n    it'=\\<alpha>`it; ((it,\\<sigma>),(it',\\<sigma>'))\\<in>R;\n    it\\<noteq>{}; it'\\<noteq>{};\n    \\<not>c \\<sigma>; \\<not>c' \\<sigma>'\n  \\<rbrakk> \\<Longrightarrow> (\\<sigma>,\\<sigma>')\\<in>R'\"\n  shows \"FOREACHc S c f \\<sigma>0 \\<le> \\<Down>R' (FOREACHc S' c' f' \\<sigma>0')\"", "lemma FOREACHc_refine:\n  fixes \\<alpha> :: \"'S \\<Rightarrow> 'Sa\"\n  fixes S :: \"'S set\"\n  fixes S' :: \"'Sa set\"\n  assumes INJ: \"inj_on \\<alpha> S\"\n  assumes REFS: \"S' = \\<alpha>`S\"\n  assumes REF0: \"(\\<sigma>0,\\<sigma>0')\\<in>R\"\n  assumes REFPHI0: \"\\<Phi>'' S \\<sigma>0 (\\<alpha>`S) \\<sigma>0'\"\n  assumes REFC: \"\\<And>it \\<sigma> it' \\<sigma>'. \\<lbrakk> \n    it'=\\<alpha>`it; it\\<subseteq>S; it'\\<subseteq>S'; \\<Phi>'' it \\<sigma> it' \\<sigma>'; (\\<sigma>,\\<sigma>')\\<in>R\n  \\<rbrakk> \\<Longrightarrow> c \\<sigma> \\<longleftrightarrow> c' \\<sigma>'\"\n  assumes REFSTEP: \"\\<And>x it \\<sigma> x' it' \\<sigma>'. \\<lbrakk> \n    x'=\\<alpha> x; x\\<in>it; x'\\<in>it'; it'=\\<alpha>`it; it\\<subseteq>S; it'\\<subseteq>S';\n    \\<Phi>'' it \\<sigma> it' \\<sigma>'; c \\<sigma>; c' \\<sigma>'; (\\<sigma>,\\<sigma>')\\<in>R\n  \\<rbrakk> \\<Longrightarrow> f x \\<sigma> \n    \\<le> \\<Down>({(\\<sigma>, \\<sigma>'). (\\<sigma>, \\<sigma>') \\<in> R \\<and> \\<Phi>'' (it - {x}) \\<sigma> (it' - {x'}) \\<sigma>'}) (f' x' \\<sigma>')\"\n  shows \"FOREACHc S c f \\<sigma>0 \\<le> \\<Down>R (FOREACHc S' c' f' \\<sigma>0')\"", "lemma FOREACHc_refine_rcg[refine]:\n  fixes \\<alpha> :: \"'S \\<Rightarrow> 'Sa\"\n  fixes S :: \"'S set\"\n  fixes S' :: \"'Sa set\"\n  assumes INJ: \"inj_on \\<alpha> S\"\n  assumes REFS: \"S' = \\<alpha>`S\"\n  assumes REF0: \"(\\<sigma>0,\\<sigma>0')\\<in>R\"\n  assumes REFC: \"\\<And>it \\<sigma> it' \\<sigma>'. \\<lbrakk> \n    it'=\\<alpha>`it; it\\<subseteq>S; it'\\<subseteq>S'; (\\<sigma>,\\<sigma>')\\<in>R\n  \\<rbrakk> \\<Longrightarrow> c \\<sigma> \\<longleftrightarrow> c' \\<sigma>'\"\n  assumes REFSTEP: \"\\<And>x it \\<sigma> x' it' \\<sigma>'. \\<lbrakk> \n    x'=\\<alpha> x; x\\<in>it; x'\\<in>it'; it'=\\<alpha>`it; it\\<subseteq>S; it'\\<subseteq>S'; c \\<sigma>; c' \\<sigma>';\n    (\\<sigma>,\\<sigma>')\\<in>R\n  \\<rbrakk> \\<Longrightarrow> f x \\<sigma> \\<le> \\<Down>R (f' x' \\<sigma>')\"\n  shows \"FOREACHc S c f \\<sigma>0 \\<le> \\<Down>R (FOREACHc S' c' f' \\<sigma>0')\"", "lemma FOREACHi_refine_genR:\n  fixes \\<alpha> :: \"'S \\<Rightarrow> 'Sa\" \\<comment> \\<open>Abstraction mapping of elements\\<close>\n  fixes S :: \"'S set\" \\<comment> \\<open>Concrete set\\<close>\n  fixes S' :: \"'Sa set\" \\<comment> \\<open>Abstract set\\<close>\n  fixes \\<sigma>0 :: \"'\\<sigma>\"\n  fixes \\<sigma>0' :: \"'\\<sigma>a\"\n  fixes R :: \"(('S set \\<times> '\\<sigma>) \\<times> ('Sa set \\<times> '\\<sigma>a)) set\"\n  assumes INJ: \"inj_on \\<alpha> S\" \n  assumes REFS[simp]: \"S' = \\<alpha>`S\"\n  assumes REF0: \"((S,\\<sigma>0),(\\<alpha>`S,\\<sigma>0')) \\<in> R\"\n  assumes REFPHI: \"\\<And>it \\<sigma> it' \\<sigma>'. \\<lbrakk> \n    it\\<subseteq>S; it'\\<subseteq>S'; \\<Phi>' it' \\<sigma>';\n    it'=\\<alpha>`it; ((it,\\<sigma>),(it',\\<sigma>'))\\<in>R\n  \\<rbrakk> \\<Longrightarrow> \\<Phi> it \\<sigma>\"\n  assumes REFSTEP: \"\\<And>x it \\<sigma> x' it' \\<sigma>'. \\<lbrakk>\n    it\\<subseteq>S; it'\\<subseteq>S'; \\<Phi> it \\<sigma>; \\<Phi>' it' \\<sigma>';\n    x'=\\<alpha> x; it'=\\<alpha>`it; ((it,\\<sigma>),(it',\\<sigma>'))\\<in>R;\n    x\\<in>it; x'\\<in>it'\n  \\<rbrakk> \\<Longrightarrow> f x \\<sigma> \n    \\<le> \\<Down>({(\\<sigma>, \\<sigma>'). ((it-{x},\\<sigma>),(it'-{x'},\\<sigma>'))\\<in>R}) (f' x' \\<sigma>')\"\n  assumes REF_R_DONE: \"\\<And>\\<sigma> \\<sigma>'. \\<lbrakk> \\<Phi> {} \\<sigma>; \\<Phi>' {} \\<sigma>'; (({},\\<sigma>),({},\\<sigma>'))\\<in>R \\<rbrakk> \n    \\<Longrightarrow> (\\<sigma>,\\<sigma>')\\<in>R'\"\n  shows \"FOREACHi \\<Phi> S f \\<sigma>0 \\<le> \\<Down>R' (FOREACHi \\<Phi>' S' f' \\<sigma>0')\"", "lemma FOREACHi_refine:\n  fixes \\<alpha> :: \"'S \\<Rightarrow> 'Sa\"\n  fixes S :: \"'S set\"\n  fixes S' :: \"'Sa set\"\n  assumes INJ: \"inj_on \\<alpha> S\"\n  assumes REFS: \"S' = \\<alpha>`S\"\n  assumes REF0: \"(\\<sigma>0,\\<sigma>0')\\<in>R\"\n  assumes REFPHI0: \"\\<Phi>'' S \\<sigma>0 (\\<alpha>`S) \\<sigma>0'\"\n  assumes REFPHI: \"\\<And>it \\<sigma> it' \\<sigma>'. \\<lbrakk> \n    it'=\\<alpha>`it; it\\<subseteq>S; it'\\<subseteq>S'; \\<Phi>' it' \\<sigma>'; \\<Phi>'' it \\<sigma> it' \\<sigma>'; (\\<sigma>,\\<sigma>')\\<in>R\n  \\<rbrakk> \\<Longrightarrow> \\<Phi> it \\<sigma>\"\n  assumes REFSTEP: \"\\<And>x it \\<sigma> x' it' \\<sigma>'. \\<lbrakk> \n    x'=\\<alpha> x; x\\<in>it; x'\\<in>it'; it'=\\<alpha>`it; it\\<subseteq>S; it'\\<subseteq>S';\n    \\<Phi> it \\<sigma>; \\<Phi>' it' \\<sigma>';  \\<Phi>'' it \\<sigma> it' \\<sigma>';\n    (\\<sigma>,\\<sigma>')\\<in>R\n  \\<rbrakk> \\<Longrightarrow> f x \\<sigma> \n    \\<le> \\<Down>({(\\<sigma>, \\<sigma>'). (\\<sigma>, \\<sigma>') \\<in> R \\<and> \\<Phi>'' (it - {x}) \\<sigma> (it' - {x'}) \\<sigma>'}) (f' x' \\<sigma>')\"\n  shows \"FOREACHi \\<Phi> S f \\<sigma>0 \\<le> \\<Down>R (FOREACHi \\<Phi>' S' f' \\<sigma>0')\"", "lemma FOREACHi_refine_rcg[refine]:\n  fixes \\<alpha> :: \"'S \\<Rightarrow> 'Sa\"\n  fixes S :: \"'S set\"\n  fixes S' :: \"'Sa set\"\n  assumes INJ: \"inj_on \\<alpha> S\"\n  assumes REFS: \"S' = \\<alpha>`S\"\n  assumes REF0: \"(\\<sigma>0,\\<sigma>0')\\<in>R\"\n  assumes REFPHI: \"\\<And>it \\<sigma> it' \\<sigma>'. \\<lbrakk> \n    it'=\\<alpha>`it; it\\<subseteq>S; it'\\<subseteq>S'; \\<Phi>' it' \\<sigma>'; (\\<sigma>,\\<sigma>')\\<in>R\n  \\<rbrakk> \\<Longrightarrow> \\<Phi> it \\<sigma>\"\n  assumes REFSTEP: \"\\<And>x it \\<sigma> x' it' \\<sigma>'. \\<lbrakk> \n    x'=\\<alpha> x; x\\<in>it; x'\\<in>it'; it'=\\<alpha>`it; it\\<subseteq>S; it'\\<subseteq>S';\n    \\<Phi> it \\<sigma>; \\<Phi>' it' \\<sigma>';\n    (\\<sigma>,\\<sigma>')\\<in>R\n  \\<rbrakk> \\<Longrightarrow> f x \\<sigma> \\<le> \\<Down>R (f' x' \\<sigma>')\"\n  shows \"FOREACHi \\<Phi> S f \\<sigma>0 \\<le> \\<Down>R (FOREACHi \\<Phi>' S' f' \\<sigma>0')\"", "lemma FOREACH_refine_genR:\n  fixes \\<alpha> :: \"'S \\<Rightarrow> 'Sa\" \\<comment> \\<open>Abstraction mapping of elements\\<close>\n  fixes S :: \"'S set\" \\<comment> \\<open>Concrete set\\<close>\n  fixes S' :: \"'Sa set\" \\<comment> \\<open>Abstract set\\<close>\n  fixes \\<sigma>0 :: \"'\\<sigma>\"\n  fixes \\<sigma>0' :: \"'\\<sigma>a\"\n  fixes R :: \"(('S set \\<times> '\\<sigma>) \\<times> ('Sa set \\<times> '\\<sigma>a)) set\"\n  assumes INJ: \"inj_on \\<alpha> S\" \n  assumes REFS[simp]: \"S' = \\<alpha>`S\"\n  assumes REF0: \"((S,\\<sigma>0),(\\<alpha>`S,\\<sigma>0')) \\<in> R\"\n  assumes REFSTEP: \"\\<And>x it \\<sigma> x' it' \\<sigma>'. \\<lbrakk>\n    it\\<subseteq>S; it'\\<subseteq>S';\n    x'=\\<alpha> x; it'=\\<alpha>`it; ((it,\\<sigma>),(it',\\<sigma>'))\\<in>R;\n    x\\<in>it; x'\\<in>it'\n  \\<rbrakk> \\<Longrightarrow> f x \\<sigma> \n    \\<le> \\<Down>({(\\<sigma>, \\<sigma>'). ((it-{x},\\<sigma>),(it'-{x'},\\<sigma>'))\\<in>R}) (f' x' \\<sigma>')\"\n  assumes REF_R_DONE: \"\\<And>\\<sigma> \\<sigma>'. \\<lbrakk> (({},\\<sigma>),({},\\<sigma>'))\\<in>R \\<rbrakk> \n    \\<Longrightarrow> (\\<sigma>,\\<sigma>')\\<in>R'\"\n  shows \"FOREACH S f \\<sigma>0 \\<le> \\<Down>R' (FOREACH S' f' \\<sigma>0')\"", "lemma FOREACH_refine:\n  fixes \\<alpha> :: \"'S \\<Rightarrow> 'Sa\"\n  fixes S :: \"'S set\"\n  fixes S' :: \"'Sa set\"\n  assumes INJ: \"inj_on \\<alpha> S\"\n  assumes REFS: \"S' = \\<alpha>`S\"\n  assumes REF0: \"(\\<sigma>0,\\<sigma>0')\\<in>R\"\n  assumes REFPHI0: \"\\<Phi>'' S \\<sigma>0 (\\<alpha>`S) \\<sigma>0'\"\n  assumes REFSTEP: \"\\<And>x it \\<sigma> x' it' \\<sigma>'. \\<lbrakk> \n    x'=\\<alpha> x; x\\<in>it; x'\\<in>it'; it'=\\<alpha>`it; it\\<subseteq>S; it'\\<subseteq>S';\n    \\<Phi>'' it \\<sigma> it' \\<sigma>'; (\\<sigma>,\\<sigma>')\\<in>R\n  \\<rbrakk> \\<Longrightarrow> f x \\<sigma> \n    \\<le> \\<Down>({(\\<sigma>, \\<sigma>'). (\\<sigma>, \\<sigma>') \\<in> R \\<and> \\<Phi>'' (it - {x}) \\<sigma> (it' - {x'}) \\<sigma>'}) (f' x' \\<sigma>')\"\n  shows \"FOREACH S f \\<sigma>0 \\<le> \\<Down>R (FOREACH S' f' \\<sigma>0')\"", "lemma FOREACH_refine_rcg[refine]:\n  fixes \\<alpha> :: \"'S \\<Rightarrow> 'Sa\"\n  fixes S :: \"'S set\"\n  fixes S' :: \"'Sa set\"\n  assumes INJ: \"inj_on \\<alpha> S\"\n  assumes REFS: \"S' = \\<alpha>`S\"\n  assumes REF0: \"(\\<sigma>0,\\<sigma>0')\\<in>R\"\n  assumes REFSTEP: \"\\<And>x it \\<sigma> x' it' \\<sigma>'. \\<lbrakk> \n    x'=\\<alpha> x; x\\<in>it; x'\\<in>it'; it'=\\<alpha>`it; it\\<subseteq>S; it'\\<subseteq>S';\n    (\\<sigma>,\\<sigma>')\\<in>R\n  \\<rbrakk> \\<Longrightarrow> f x \\<sigma> \\<le> \\<Down>R (f' x' \\<sigma>')\"\n  shows \"FOREACH S f \\<sigma>0 \\<le> \\<Down>R (FOREACH S' f' \\<sigma>0')\"", "lemma FOREACHci_refine_rcg'[refine]:\n  fixes \\<alpha> :: \"'S \\<Rightarrow> 'Sa\"\n  fixes S :: \"'S set\"\n  fixes S' :: \"'Sa set\"\n  assumes INJ: \"inj_on \\<alpha> S\"\n  assumes REFS: \"S' = \\<alpha>`S\"\n  assumes REF0: \"(\\<sigma>0,\\<sigma>0')\\<in>R\"\n  assumes REFC: \"\\<And>it \\<sigma> it' \\<sigma>'. \\<lbrakk> \n    it'=\\<alpha>`it; it\\<subseteq>S; it'\\<subseteq>S'; \\<Phi>' it' \\<sigma>'; (\\<sigma>,\\<sigma>')\\<in>R\n  \\<rbrakk> \\<Longrightarrow> c \\<sigma> \\<longleftrightarrow> c' \\<sigma>'\"\n  assumes REFSTEP: \"\\<And>x it \\<sigma> x' it' \\<sigma>'. \\<lbrakk> \n    x'=\\<alpha> x; x\\<in>it; x'\\<in>it'; it'=\\<alpha>`it; it\\<subseteq>S; it'\\<subseteq>S';\n    \\<Phi>' it' \\<sigma>'; c \\<sigma>; c' \\<sigma>';\n    (\\<sigma>,\\<sigma>')\\<in>R\n  \\<rbrakk> \\<Longrightarrow> f x \\<sigma> \\<le> \\<Down>R (f' x' \\<sigma>')\"\n  shows \"FOREACHc S c f \\<sigma>0 \\<le> \\<Down>R (FOREACHci \\<Phi>' S' c' f' \\<sigma>0')\"", "lemma FOREACHi_refine_rcg'[refine]:\n  fixes \\<alpha> :: \"'S \\<Rightarrow> 'Sa\"\n  fixes S :: \"'S set\"\n  fixes S' :: \"'Sa set\"\n  assumes INJ: \"inj_on \\<alpha> S\"\n  assumes REFS: \"S' = \\<alpha>`S\"\n  assumes REF0: \"(\\<sigma>0,\\<sigma>0')\\<in>R\"\n  assumes REFSTEP: \"\\<And>x it \\<sigma> x' it' \\<sigma>'. \\<lbrakk> \n    x'=\\<alpha> x; x\\<in>it; x'\\<in>it'; it'=\\<alpha>`it; it\\<subseteq>S; it'\\<subseteq>S';\n    \\<Phi>' it' \\<sigma>';\n    (\\<sigma>,\\<sigma>')\\<in>R\n  \\<rbrakk> \\<Longrightarrow> f x \\<sigma> \\<le> \\<Down>R (f' x' \\<sigma>')\"\n  shows \"FOREACH S f \\<sigma>0 \\<le> \\<Down>R (FOREACHi \\<Phi>' S' f' \\<sigma>0')\"", "lemma FOREACHoci_rule':\n  assumes FIN: \"finite S\"\n  assumes I0: \"I S \\<sigma>0\"\n  assumes IP: \n    \"\\<And>x it \\<sigma>. \\<lbrakk> c \\<sigma>; x\\<in>it; it\\<subseteq>S; I it \\<sigma>; \\<forall>y\\<in>it - {x}. R x y;\n                \\<forall>y\\<in>S - it. R y x \\<rbrakk> \\<Longrightarrow> f x \\<sigma> \\<le> SPEC (I (it-{x}))\"\n  assumes II1: \"\\<And>\\<sigma>. \\<lbrakk>I {} \\<sigma>; c \\<sigma>\\<rbrakk> \\<Longrightarrow> P \\<sigma>\"\n  assumes II2: \"\\<And>it \\<sigma>. \\<lbrakk> it\\<subseteq>S; I it \\<sigma>; \\<not>c \\<sigma>;\n                         \\<forall>x\\<in>it. \\<forall>y\\<in>S - it. R y x \\<rbrakk> \\<Longrightarrow> P \\<sigma>\"\n  shows \"FOREACHoci R I S c f \\<sigma>0 \\<le> SPEC P\"", "lemma FOREACHci_rule'[refine_vcg]:\n  assumes FIN: \"finite S\"\n  assumes I0: \"I S \\<sigma>0\"\n  assumes IP: \n    \"\\<And>x it \\<sigma>. \\<lbrakk> x\\<in>it; it\\<subseteq>S; I it \\<sigma>; c \\<sigma> \\<rbrakk> \\<Longrightarrow> f x \\<sigma> \\<le> SPEC (I (it-{x}))\"\n  assumes II1: \"\\<And>\\<sigma>. \\<lbrakk>I {} \\<sigma>; c \\<sigma>\\<rbrakk> \\<Longrightarrow> P \\<sigma>\"\n  assumes II2: \"\\<And>it \\<sigma>. \\<lbrakk> it\\<subseteq>S; I it \\<sigma>; \\<not>c \\<sigma> \\<rbrakk> \\<Longrightarrow> P \\<sigma>\"\n  shows \"FOREACHci I S c f \\<sigma>0 \\<le> SPEC P\"", "lemma FOREACHc_rule':\n  assumes FIN: \"finite S\"\n  assumes I0: \"I S \\<sigma>0\"\n  assumes IP: \n    \"\\<And>x it \\<sigma>. \\<lbrakk> x\\<in>it; it\\<subseteq>S; I it \\<sigma>; c \\<sigma> \\<rbrakk> \\<Longrightarrow> f x \\<sigma> \\<le> SPEC (I (it-{x}))\"\n  assumes II1: \"\\<And>\\<sigma>. \\<lbrakk>I {} \\<sigma>; c \\<sigma>\\<rbrakk> \\<Longrightarrow> P \\<sigma>\"\n  assumes II2: \"\\<And>it \\<sigma>. \\<lbrakk> it\\<subseteq>S; I it \\<sigma>; \\<not>c \\<sigma> \\<rbrakk> \\<Longrightarrow> P \\<sigma>\"\n  shows \"FOREACHc S c f \\<sigma>0 \\<le> SPEC P\"", "lemma FOREACHoci_emp [simp] :\n  \"FOREACHoci R \\<Phi> {} c f \\<sigma> = do {ASSERT (\\<Phi> {} \\<sigma>); RETURN \\<sigma>}\"", "lemma FOREACHoi_emp [simp] :\n  \"FOREACHoi R \\<Phi> {} f \\<sigma> = do {ASSERT (\\<Phi> {} \\<sigma>); RETURN \\<sigma>}\"", "lemma FOREACHci_emp [simp] :\n  \"FOREACHci \\<Phi> {} c f \\<sigma> = do {ASSERT (\\<Phi> {} \\<sigma>); RETURN \\<sigma>}\"", "lemma FOREACHc_emp [simp] :\n  \"FOREACHc {} c f \\<sigma> = RETURN \\<sigma>\"", "lemma FOREACH_emp [simp] :\n  \"FOREACH {} f \\<sigma> = RETURN \\<sigma>\"", "lemma FOREACHi_emp [simp] :\n  \"FOREACHi \\<Phi> {} f \\<sigma> = do {ASSERT (\\<Phi> {} \\<sigma>); RETURN \\<sigma>}\"", "lemmas trimono_atomize = atomize_imp atomize_conj atomize_all", "lemmas trimono_deatomize = trimono_atomize[symmetric]", "lemmas trimono_spec_defs = trimono_spec_def lift_refl_def[abs_def] comp_def id_def\n    lift_mono_def[abs_def] lift_mono1_def[abs_def] lift_mono2_def[abs_def]\n    trimono_deatomize", "lemma FOREACHoci_mono[unfolded trimono_spec_defs,refine_mono]: \n  \"trimono_spec (R o R o R o R o M2 o R) FOREACHoci\"\n  \"trimono_spec (R o R o R o M2 o R) FOREACHoi\"\n  \"trimono_spec (R o R o R o M2 o R) FOREACHci\"\n  \"trimono_spec (R o R o M2 o R) FOREACHc\"\n  \"trimono_spec (R o R o M2 o R) FOREACHi\"\n  \"trimono_spec (R o M2 o R) FOREACH\"", "lemma nfoldli_simps[simp]:\n  \"nfoldli [] c f s = RETURN s\"\n  \"nfoldli (x#ls) c f s = \n    (if c s then do { s\\<leftarrow>f x s; nfoldli ls c f s} else RETURN s)\"", "lemma param_nfoldli[param]:\n  shows \"(nfoldli,nfoldli) \\<in> \n    \\<langle>Ra\\<rangle>list_rel \\<rightarrow> (Rb\\<rightarrow>Id) \\<rightarrow> (Ra\\<rightarrow>Rb\\<rightarrow>\\<langle>Rb\\<rangle>nres_rel) \\<rightarrow> Rb \\<rightarrow> \\<langle>Rb\\<rangle>nres_rel\"", "lemma nfoldli_no_ctd[simp]: \"\\<not>ctd s \\<Longrightarrow> nfoldli l ctd f s = RETURN s\"", "lemma nfoldli_append[simp]: \"nfoldli (l1@l2) ctd f s = nfoldli l1 ctd f s \\<bind> nfoldli l2 ctd f\"", "lemma nfoldli_map: \"nfoldli (map f l) ctd g s = nfoldli l ctd (g o f) s\"", "lemma nfoldli_nfoldli_prod_conv: \n  \"nfoldli l2 ctd (\\<lambda>i. nfoldli l1 ctd (f i)) s = nfoldli (List.product l2 l1) ctd (\\<lambda>(i,j). f i j) s\"", "lemma nfoldli_transfer_plain[refine_transfer]:\n  assumes \"\\<And>x s. RETURN (f x s) \\<le> f' x s\"\n  shows \"RETURN (foldli l c f s) \\<le> (nfoldli l c f' s)\"", "lemma nfoldli_transfer_dres[refine_transfer]:\n  fixes l :: \"'a list\" and c:: \"'b \\<Rightarrow> bool\"\n  assumes FR: \"\\<And>x s. nres_of (f x s) \\<le> f' x s\"\n  shows \"nres_of \n    (foldli l (case_dres False False c) (\\<lambda>x s. s\\<bind>f x) (dRETURN s)) \n    \\<le> (nfoldli l c f' s)\"", "lemma nfoldli_mono[refine_mono]: \n  \"\\<lbrakk> \\<And>x s. f x s \\<le> f' x s \\<rbrakk> \\<Longrightarrow> nfoldli l c f \\<sigma> \\<le> nfoldli l c f' \\<sigma>\"\n  \"\\<lbrakk> \\<And>x s. flat_ge (f x s) (f' x s) \\<rbrakk> \\<Longrightarrow> flat_ge (nfoldli l c f \\<sigma>) (nfoldli l c f' \\<sigma>)\"", "lemma nfoldli_while: \"nfoldli l c f \\<sigma>\n          \\<le>\n         (WHILE\\<^sub>T\\<^bsup>I\\<^esup>\n           (FOREACH_cond c) (FOREACH_body f) (l, \\<sigma>) \\<bind>\n          (\\<lambda>(_, \\<sigma>). RETURN \\<sigma>))\"", "lemma while_nfoldli:\n  \"do {\n    (_,\\<sigma>) \\<leftarrow> WHILE\\<^sub>T (FOREACH_cond c) (FOREACH_body f) (l,\\<sigma>);\n    RETURN \\<sigma>\n  } \\<le> nfoldli l c f \\<sigma>\"", "lemma while_eq_nfoldli: \"do {\n    (_,\\<sigma>) \\<leftarrow> WHILE\\<^sub>T (FOREACH_cond c) (FOREACH_body f) (l,\\<sigma>);\n    RETURN \\<sigma>\n  } = nfoldli l c f \\<sigma>\"", "lemma nfoldli_rule:\n  assumes I0: \"I [] l0 \\<sigma>0\"\n  assumes IS: \"\\<And>x l1 l2 \\<sigma>. \\<lbrakk> l0=l1@x#l2; I l1 (x#l2) \\<sigma>; c \\<sigma> \\<rbrakk> \\<Longrightarrow> f x \\<sigma> \\<le> SPEC (I (l1@[x]) l2)\"\n  assumes FNC: \"\\<And>l1 l2 \\<sigma>. \\<lbrakk> l0=l1@l2; I l1 l2 \\<sigma>; \\<not>c \\<sigma> \\<rbrakk> \\<Longrightarrow> P \\<sigma>\"\n  assumes FC: \"\\<And>\\<sigma>. \\<lbrakk> I l0 [] \\<sigma>; c \\<sigma> \\<rbrakk> \\<Longrightarrow> P \\<sigma>\"\n  shows \"nfoldli l0 c f \\<sigma>0 \\<le> SPEC P\"", "lemma nfoldli_leof_rule:\n  assumes I0: \"I [] l0 \\<sigma>0\"\n  assumes IS: \"\\<And>x l1 l2 \\<sigma>. \\<lbrakk> l0=l1@x#l2; I l1 (x#l2) \\<sigma>; c \\<sigma> \\<rbrakk> \\<Longrightarrow> f x \\<sigma> \\<le>\\<^sub>n SPEC (I (l1@[x]) l2)\"\n  assumes FNC: \"\\<And>l1 l2 \\<sigma>. \\<lbrakk> l0=l1@l2; I l1 l2 \\<sigma>; \\<not>c \\<sigma> \\<rbrakk> \\<Longrightarrow> P \\<sigma>\"\n  assumes FC: \"\\<And>\\<sigma>. \\<lbrakk> I l0 [] \\<sigma>; c \\<sigma> \\<rbrakk> \\<Longrightarrow> P \\<sigma>\"\n  shows \"nfoldli l0 c f \\<sigma>0 \\<le>\\<^sub>n SPEC P\"", "lemma nfoldli_refine[refine]:\n  assumes \"(li, l) \\<in> \\<langle>S\\<rangle>list_rel\"\n    and \"(si, s) \\<in> R\"\n    and CR: \"(ci, c) \\<in> R \\<rightarrow> bool_rel\"\n    and [refine]: \"\\<And>xi x si s. \\<lbrakk> (xi,x)\\<in>S; (si,s)\\<in>R; c s \\<rbrakk> \\<Longrightarrow> fi xi si \\<le> \\<Down>R (f x s)\"\n  shows \"nfoldli li ci fi si \\<le> \\<Down> R (nfoldli l c f s)\"", "lemma nfoldli_invar_refine:\n  assumes \"(li,l)\\<in>\\<langle>S\\<rangle>list_rel\"\n  assumes \"(si,s)\\<in>R\"\n  assumes \"I [] li si\"\n  assumes COND: \"\\<And>l1i l2i l1 l2 si s. \\<lbrakk>\n    li=l1i@l2i; l=l1@l2; (l1i,l1)\\<in>\\<langle>S\\<rangle>list_rel; (l2i,l2)\\<in>\\<langle>S\\<rangle>list_rel; \n    I l1i l2i si; (si,s)\\<in>R\\<rbrakk> \\<Longrightarrow> (ci si, c s)\\<in>bool_rel\"\n  assumes INV: \"\\<And>l1i xi l2i si. \\<lbrakk>li=l1i@xi#l2i; I l1i (xi#l2i) si\\<rbrakk> \\<Longrightarrow> fi xi si \\<le>\\<^sub>n SPEC (I (l1i@[xi]) l2i)\"\n  assumes STEP: \"\\<And>l1i xi l2i l1 x l2 si s. \\<lbrakk>\n    li=l1i@xi#l2i; l=l1@x#l2; (l1i,l1)\\<in>\\<langle>S\\<rangle>list_rel; (xi,x)\\<in>S; (l2i,l2)\\<in>\\<langle>S\\<rangle>list_rel; \n    I l1i (xi#l2i) si; (si,s)\\<in>R\\<rbrakk> \\<Longrightarrow> fi xi si \\<le> \\<Down>R (f x s)\"\n  shows \"nfoldli li ci fi si \\<le> \\<Down>R (nfoldli l c f s)\"", "lemma foldli_mono_dres_aux1:\n  fixes \\<sigma> :: \"'a :: {order_bot, order_top}\"\n  assumes COND: \"\\<And>\\<sigma> \\<sigma>'. \\<sigma>\\<le>\\<sigma>' \\<Longrightarrow> c \\<sigma> \\<noteq> c \\<sigma>' \\<Longrightarrow> \\<sigma>=bot \\<or> \\<sigma>'=top \"\n  assumes STRICT: \"\\<And>x. f x bot = bot\" \"\\<And>x. f' x top = top\"\n  assumes B: \"\\<sigma>\\<le>\\<sigma>'\"\n  assumes A: \"\\<And>a x x'. x\\<le>x' \\<Longrightarrow> f a x \\<le> f' a x'\"\n  shows \"foldli l c f \\<sigma> \\<le> foldli l c f' \\<sigma>'\"", "lemma foldli_mono_dres_aux2:\n  assumes STRICT: \"\\<And>x. f x bot = bot\" \"\\<And>x. f' x top = top\"\n  assumes A: \"\\<And>a x x'. x\\<le>x' \\<Longrightarrow> f a x \\<le> f' a x'\"\n  shows \"foldli l (case_dres False False c) f \\<sigma> \n    \\<le> foldli l (case_dres False False c) f' \\<sigma>\"", "lemma foldli_mono_dres[refine_mono]:\n  assumes A: \"\\<And>a x. f a x \\<le> f' a x\"\n  shows \"foldli l (case_dres False False c) (\\<lambda>x s. dbind s (f x)) \\<sigma> \n    \\<le> foldli l (case_dres False False c) (\\<lambda>x s. dbind s (f' x)) \\<sigma>\"", "lemma dfoldli_simps[simp]:\n  \"dfoldli [] c f s = dRETURN s\"\n  \"dfoldli (x#ls) c f s = \n    (if c s then do { s\\<leftarrow>f x s; dfoldli ls c f s} else dRETURN s)\"", "lemma dfoldli_mono[refine_mono]: \n  \"\\<lbrakk> \\<And>x s. f x s \\<le> f' x s \\<rbrakk> \\<Longrightarrow> dfoldli l c f \\<sigma> \\<le> dfoldli l c f' \\<sigma>\"\n  \"\\<lbrakk> \\<And>x s. flat_ge (f x s) (f' x s) \\<rbrakk> \\<Longrightarrow> flat_ge (dfoldli l c f \\<sigma>) (dfoldli l c f' \\<sigma>)\"", "lemma foldli_dres_pres_FAIL[simp]: \n  \"foldli l (case_dres False False c) (\\<lambda>x s. dbind s (f x)) dFAIL = dFAIL\"", "lemma foldli_dres_pres_SUCCEED[simp]:\n  \"foldli l (case_dres False False c) (\\<lambda>x s. dbind s (f x)) dSUCCEED = dSUCCEED\"", "lemma dfoldli_by_foldli: \"dfoldli l c f \\<sigma>\n  = foldli l (case_dres False False c) (\\<lambda>x s. dbind s (f x)) (dRETURN \\<sigma>)\"", "lemma foldli_mono_dres_flat[refine_mono]:\n  assumes A: \"\\<And>a x. flat_ge (f a x) (f' a x)\"\n  shows \"flat_ge (foldli l (case_dres False False c) (\\<lambda>x s. dbind s (f x)) \\<sigma>) \n          (foldli l (case_dres False False c) (\\<lambda>x s. dbind s (f' x)) \\<sigma>)\"", "lemma dres_foldli_ne_bot[refine_transfer]:\n  assumes 1: \"\\<sigma> \\<noteq> dSUCCEED\"\n  assumes 2: \"\\<And>x \\<sigma>. f x \\<sigma> \\<noteq> dSUCCEED\"\n  shows \"foldli l c (\\<lambda>x s. s \\<bind> f x) \\<sigma> \\<noteq> dSUCCEED\"", "lemma autoref_nfoldli[autoref_rules]:\n  shows \"(nfoldli, nfoldli)\n  \\<in> \\<langle>Ra\\<rangle>list_rel \\<rightarrow> (Rb \\<rightarrow> bool_rel) \\<rightarrow> (Ra \\<rightarrow> Rb \\<rightarrow> \\<langle>Rb\\<rangle>nres_rel) \\<rightarrow> Rb \\<rightarrow> \\<langle>Rb\\<rangle>nres_rel\"", "lemma FOREACHoci_by_LIST_FOREACH:\n  \"FOREACHoci R \\<Phi> S c f \\<sigma>0 = do {\n    ASSERT (finite S);\n    LIST_FOREACH \\<Phi> (it_to_sorted_list R S) c f \\<sigma>0\n  }\"", "lemma FOREACH_patterns[autoref_op_pat_def]:\n  \"FOREACH\\<^bsup>I\\<^esup> s f \\<equiv> FOREACH\\<^sub>O\\<^sub>C\\<^bsup>\\<lambda>_ _. True,I\\<^esup> s (\\<lambda>_. True) f\"\n  \"FOREACHci I s c f \\<equiv> FOREACHoci (\\<lambda>_ _. True) I s c f\"\n  \"FOREACH\\<^sub>O\\<^sub>C\\<^bsup>R,\\<Phi>\\<^esup> s c f \\<equiv> \\<lambda>\\<sigma>. do {\n    ASSERT (finite s);\n    Autoref_Tagging.OP (LIST_FOREACH \\<Phi>) (it_to_sorted_list R s) c f \\<sigma>\n  }\"\n  \"FOREACH s f \\<equiv> FOREACHoci (\\<lambda>_ _. True) (\\<lambda>_ _. True) s (\\<lambda>_. True) f\"\n  \"FOREACHoi R I s f \\<equiv> FOREACHoci R I s (\\<lambda>_. True) f\"\n  \"FOREACHc s c f \\<equiv> FOREACHoci (\\<lambda>_ _. True) (\\<lambda>_ _. True) s c f\"", "lemma LIST_FOREACH'_param[param]: \n  shows \"(LIST_FOREACH',LIST_FOREACH') \n  \\<in> (\\<langle>\\<langle>Rv\\<rangle>list_rel\\<rangle>nres_rel \\<rightarrow> (R\\<sigma>\\<rightarrow>bool_rel) \n    \\<rightarrow> (Rv \\<rightarrow> R\\<sigma> \\<rightarrow> \\<langle>R\\<sigma>\\<rangle>nres_rel) \\<rightarrow> R\\<sigma> \\<rightarrow> \\<langle>R\\<sigma>\\<rangle>nres_rel)\"", "lemma LIST_FOREACH_autoref[autoref_rules]:\n  shows \"(LIST_FOREACH', LIST_FOREACH \\<Phi>) \\<in> \n    (\\<langle>\\<langle>Rv\\<rangle>list_rel\\<rangle>nres_rel \\<rightarrow> (R\\<sigma>\\<rightarrow>bool_rel) \n      \\<rightarrow> (Rv \\<rightarrow> R\\<sigma> \\<rightarrow> \\<langle>R\\<sigma>\\<rangle>nres_rel) \\<rightarrow> R\\<sigma> \\<rightarrow> \\<langle>R\\<sigma>\\<rangle>nres_rel)\"", "lemma LIST_FOREACH'_mono[unfolded trimono_spec_defs,refine_mono]: \n  \"trimono_spec (R o R o M2 o R) LIST_FOREACH'\"", "lemma LIST_FOREACH'_transfer_plain[refine_transfer]:\n  assumes \"RETURN tsl \\<le> tsl'\"\n  assumes \"\\<And>x \\<sigma>. RETURN (f x \\<sigma>) \\<le> f' x \\<sigma>\"\n  shows \"RETURN (foldli tsl c f \\<sigma>) \\<le> LIST_FOREACH' tsl' c f' \\<sigma>\"", "lemma LIST_FOREACH'_transfer_nres[refine_transfer]:\n  assumes \"nres_of tsl \\<le> tsl'\"\n  assumes \"\\<And>x \\<sigma>. nres_of (f x \\<sigma>) \\<le> f' x \\<sigma>\"\n  shows \"nres_of (\n    do {\n      xs\\<leftarrow>tsl; \n      foldli xs (case_dres False False c) (\\<lambda>x s. s\\<bind>f x) (dRETURN \\<sigma>)\n    }) \\<le> LIST_FOREACH' tsl' c f' \\<sigma>\"", "lemma [refine_transfer_post_simp]: \n  \"do {\n    xs \\<leftarrow> dRETURN tsl;\n    foldli xs c f \\<sigma>\n  } = foldli tsl c f \\<sigma>\"", "lemma [refine_transfer_post_simp]: \n  \"(let xs = tsl in foldli xs c f \\<sigma>) = foldli tsl c f \\<sigma>\"", "lemma LFO_pre_refine: (* TODO: Generalize! *)\n  assumes \"(li,l)\\<in>\\<langle>A\\<rangle>list_set_rel\"\n  assumes \"(ci,c)\\<in>R \\<rightarrow> bool_rel\"\n  assumes \"(fi,f)\\<in>A\\<rightarrow>R\\<rightarrow>\\<langle>R\\<rangle>nres_rel\"\n  assumes \"(s0i,s0)\\<in>R\"\n  shows \"LIST_FOREACH' (RETURN li) ci fi s0i \\<le> \\<Down>R (FOREACHci I l c f s0)\"", "lemma LFOci_refine: (* TODO: Generalize! *)\n  assumes \"(li,l)\\<in>\\<langle>A\\<rangle>list_set_rel\"\n  assumes \"\\<And>s si. (si,s)\\<in>R \\<Longrightarrow> ci si \\<longleftrightarrow> c s\"\n  assumes \"\\<And>x xi s si. \\<lbrakk>(xi,x)\\<in>A; (si,s)\\<in>R\\<rbrakk> \\<Longrightarrow> fi xi si \\<le> \\<Down>R (f x s)\"\n  assumes \"(s0i,s0)\\<in>R\"\n  shows \"nfoldli li ci fi s0i \\<le> \\<Down>R (FOREACHci I l c f s0)\"", "lemma LFOc_refine: (* TODO: Generalize! *)\n  assumes \"(li,l)\\<in>\\<langle>A\\<rangle>list_set_rel\"\n  assumes \"\\<And>s si. (si,s)\\<in>R \\<Longrightarrow> ci si \\<longleftrightarrow> c s\"\n  assumes \"\\<And>x xi s si. \\<lbrakk>(xi,x)\\<in>A; (si,s)\\<in>R\\<rbrakk> \\<Longrightarrow> fi xi si \\<le> \\<Down>R (f x s)\"\n  assumes \"(s0i,s0)\\<in>R\"\n  shows \"nfoldli li ci fi s0i \\<le> \\<Down>R (FOREACHc l c f s0)\"", "lemma LFO_refine: (* TODO: Generalize! *)\n  assumes \"(li,l)\\<in>\\<langle>A\\<rangle>list_set_rel\"\n  assumes \"\\<And>x xi s si. \\<lbrakk>(xi,x)\\<in>A; (si,s)\\<in>R\\<rbrakk> \\<Longrightarrow> fi xi si \\<le> \\<Down>R (f x s)\"\n  assumes \"(s0i,s0)\\<in>R\"\n  shows \"nfoldli li (\\<lambda>_. True) fi s0i \\<le> \\<Down>R (FOREACH l f s0)\"", "lemma LFOi_refine: (* TODO: Generalize! *)\n  assumes \"(li,l)\\<in>\\<langle>A\\<rangle>list_set_rel\"\n  assumes \"\\<And>x xi s si. \\<lbrakk>(xi,x)\\<in>A; (si,s)\\<in>R\\<rbrakk> \\<Longrightarrow> fi xi si \\<le> \\<Down>R (f x s)\"\n  assumes \"(s0i,s0)\\<in>R\"\n  shows \"nfoldli li (\\<lambda>_. True) fi s0i \\<le> \\<Down>R (FOREACHi I l f s0)\"", "lemma LIST_FOREACH'_refine: \"LIST_FOREACH' tsl' c' f' \\<sigma>' \\<le> LIST_FOREACH \\<Phi> tsl' c' f' \\<sigma>'\"", "lemma LIST_FOREACH'_eq: \"LIST_FOREACH (\\<lambda>_ _. True) tsl' c' f' \\<sigma>' = (LIST_FOREACH' tsl' c' f' \\<sigma>')\"", "lemma FOREACHcd_rule:\n  assumes \"finite S\\<^sub>0\"\n  assumes I0: \"I {} S\\<^sub>0 \\<sigma>\\<^sub>0\"\n  assumes STEP: \"\\<And>S1 S2 x \\<sigma>. \\<lbrakk> S\\<^sub>0 = insert x (S1\\<union>S2); I S1 (insert x S2) \\<sigma>; c \\<sigma> \\<rbrakk> \\<Longrightarrow> f x \\<sigma> \\<le> SPEC (I (insert x S1) S2)\"\n  assumes INTR: \"\\<And>S1 S2 \\<sigma>. \\<lbrakk> S\\<^sub>0 = S1\\<union>S2; I S1 S2 \\<sigma>; \\<not>c \\<sigma> \\<rbrakk> \\<Longrightarrow> \\<Phi> \\<sigma>\"\n  assumes COMPL: \"\\<And>\\<sigma>. \\<lbrakk> I S\\<^sub>0 {} \\<sigma>; c \\<sigma> \\<rbrakk> \\<Longrightarrow> \\<Phi> \\<sigma>\"\n  shows \"FOREACHcd S\\<^sub>0 c f \\<sigma>\\<^sub>0 \\<le> SPEC \\<Phi>\"", "lemma FOREACHcdi_rule[refine_vcg]:\n  assumes \"finite S\\<^sub>0\"\n  assumes I0: \"I {} S\\<^sub>0 \\<sigma>\\<^sub>0\"\n  assumes STEP: \"\\<And>S1 S2 x \\<sigma>. \\<lbrakk> S\\<^sub>0 = insert x (S1\\<union>S2); I S1 (insert x S2) \\<sigma>; c \\<sigma> \\<rbrakk> \\<Longrightarrow> f x \\<sigma> \\<le> SPEC (I (insert x S1) S2)\"\n  assumes INTR: \"\\<And>S1 S2 \\<sigma>. \\<lbrakk> S\\<^sub>0 = S1\\<union>S2; I S1 S2 \\<sigma>; \\<not>c \\<sigma> \\<rbrakk> \\<Longrightarrow> \\<Phi> \\<sigma>\"\n  assumes COMPL: \"\\<And>\\<sigma>. \\<lbrakk> I S\\<^sub>0 {} \\<sigma>; c \\<sigma> \\<rbrakk> \\<Longrightarrow> \\<Phi> \\<sigma>\"\n  shows \"FOREACHcdi I S\\<^sub>0 c f \\<sigma>\\<^sub>0 \\<le> SPEC \\<Phi>\"", "lemma FOREACHcd_refine[refine]:\n  assumes [simp]: \"finite s'\"\n  assumes S: \"(s',s)\\<in>\\<langle>S\\<rangle>set_rel\"\n  assumes SV: \"single_valued S\"\n  assumes R0: \"(\\<sigma>',\\<sigma>)\\<in>R\"\n  assumes C: \"\\<And>\\<sigma>' \\<sigma>. (\\<sigma>',\\<sigma>)\\<in>R \\<Longrightarrow> (c' \\<sigma>', c \\<sigma>)\\<in>bool_rel\"\n  assumes F: \"\\<And>x' x \\<sigma>' \\<sigma>. \\<lbrakk>(x', x) \\<in> S; (\\<sigma>', \\<sigma>) \\<in> R\\<rbrakk>\n     \\<Longrightarrow> f' x' \\<sigma>' \\<le> \\<Down> R (f x \\<sigma>)\"\n  shows \"FOREACHcd s' c' f' \\<sigma>' \\<le> \\<Down>R (FOREACHcdi I s c f \\<sigma>)\"", "lemma FOREACHc_refines_FOREACHcd_aux:\n  shows \"FOREACHc s c f \\<sigma> \\<le> FOREACHcd s c f \\<sigma>\"", "lemmas FOREACHc_refines_FOREACHcd[refine]\n  = order_trans[OF FOREACHc_refines_FOREACHcd_aux FOREACHcd_refine]", "lemma map_foreach:\n  assumes \"finite S\"\n  shows \"FOREACH S (\\<lambda>x \\<sigma>. RETURN (insert (f x) \\<sigma>)) R0 \\<le> SPEC ((=) (R0 \\<union> f`S))\"", "lemma map_sigma_foreach:\n  fixes f :: \"'a \\<times> 'b \\<Rightarrow> 'c\"\n  assumes \"finite A\"\n  assumes \"\\<And>x. x\\<in>A \\<Longrightarrow> finite (B x)\"\n  shows \"FOREACH A (\\<lambda>a \\<sigma>. \n    FOREACH (B a) (\\<lambda>b \\<sigma>. RETURN (insert (f (a,b)) \\<sigma>)) \\<sigma>\n  ) R0 \\<le> SPEC ((=) (R0 \\<union> f`Sigma A B))\"", "lemma map_sigma_sigma_foreach:\n  fixes f :: \"'a \\<times> ('b \\<times> 'c) \\<Rightarrow> 'd\"\n  assumes \"finite A\"\n  assumes \"\\<And>a. a\\<in>A \\<Longrightarrow> finite (B a)\"\n  assumes \"\\<And>a b. \\<lbrakk>a\\<in>A; b\\<in>B a\\<rbrakk> \\<Longrightarrow> finite (C a b)\"\n  shows \"FOREACH A (\\<lambda>a \\<sigma>. \n    FOREACH (B a) (\\<lambda>b \\<sigma>. \n      FOREACH (C a b) (\\<lambda>c \\<sigma>.\n        RETURN (insert (f (a,(b,c))) \\<sigma>)) \\<sigma>) \\<sigma>\n  ) R0 \\<le> SPEC ((=) (R0 \\<union> f`Sigma A (\\<lambda>a. Sigma (B a) (C a))))\"", "lemma bij_set_rel_for_inj: \n  fixes R\n  defines \"\\<alpha> \\<equiv> fun_of_rel R\" \n  assumes \"bijective R\" \"(s,s')\\<in>\\<langle>R\\<rangle>set_rel\"  \n  shows \"inj_on \\<alpha> s\" \"s' = \\<alpha>`s\"\n  \\<comment> \\<open>To be used when generating refinement conditions for foreach-loops\\<close>", "lemma nfoldli_by_idx_gen:\n  shows \"nfoldli (drop k l) c f s = nfoldli [k..<length l] c (\\<lambda>i s. do {\n      ASSERT (i<length l);\n      let x = l!i;\n      f x s\n    }) s\"", "lemma nfoldli_by_idx: \n  \"nfoldli l c f s = nfoldli [0..<length l] c (\\<lambda>i s. do {\n    ASSERT (i<length l);\n    let x = l!i;\n    f x s\n  }) s\"", "lemma nfoldli_map_inv:\n  assumes \"inj g\"\n  shows \"nfoldli l c f = nfoldli (map g l) c (\\<lambda>x s. f (the_inv g x) s)\"", "lemma nfoldli_shift:\n  fixes ofs :: nat \n  shows \"nfoldli l c f = nfoldli (map (\\<lambda>i. i+ofs) l) c (\\<lambda>x s. do {ASSERT (x\\<ge>ofs); f (x - ofs) s})\"", "lemma nfoldli_foreach_shift: \n  shows \"nfoldli [a..<b] c f = nfoldli [a+ofs..<b+ofs] c (\\<lambda>x s. do{ASSERT(x\\<ge>ofs); f (x - ofs) s})\"", "lemma member_by_nfoldli: \"nfoldli l (\\<lambda>f. \\<not>f) (\\<lambda>y _. RETURN (y=x)) False \\<le> SPEC (\\<lambda>r. r \\<longleftrightarrow> x\\<in>set l)\"", "lemma sum_impl_correct: \n  assumes [simp]: \"finite S\"\n  assumes [refine_vcg]: \"\\<And>x. x\\<in>S \\<Longrightarrow> gi x \\<le> SPEC (\\<lambda>r. r=g x)\"\n  shows \"sum_impl gi S \\<le> SPEC (\\<lambda>r. r=sum g S)\""], "translations": [["", "lemma it_step_insert_iff: \n  \"it \\<subseteq> S \\<Longrightarrow> x\\<in>it \\<Longrightarrow> S-(it-{x}) = insert x (S-it)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>it \\<subseteq> S; x \\<in> it\\<rbrakk>\n    \\<Longrightarrow> S - (it - {x}) = insert x (S - it)", "by auto"], ["", "subsection \\<open>Definition\\<close>"], ["", "text \\<open>\n  Foreach-loops come in different versions, depending on whether they have an \n  annotated invariant (I), a termination condition (C), and an order (O).\n\n  Note that asserting that the set is finite is not necessary to guarantee\n  termination. However, we currently provide only iteration over finite sets,\n  as this also matches the ICF concept of iterators.\n\\<close>"], ["", "definition \"FOREACH_body f \\<equiv> \\<lambda>(xs, \\<sigma>). do {\n  let x = hd xs; \\<sigma>'\\<leftarrow>f x \\<sigma>; RETURN (tl xs,\\<sigma>')\n  }\""], ["", "definition FOREACH_cond where \"FOREACH_cond c \\<equiv> (\\<lambda>(xs,\\<sigma>). xs\\<noteq>[] \\<and> c \\<sigma>)\""], ["", "text \\<open>Foreach with continuation condition, order and annotated invariant:\\<close>"], ["", "definition FOREACHoci (\"FOREACH\\<^sub>O\\<^sub>C\\<^bsup>_,_\\<^esup>\") where \"FOREACHoci R \\<Phi> S c f \\<sigma>0 \\<equiv> do {\n  ASSERT (finite S);\n  xs \\<leftarrow> SPEC (\\<lambda>xs. distinct xs \\<and> S = set xs \\<and> sorted_wrt R xs);\n  (_,\\<sigma>) \\<leftarrow> WHILEIT \n    (\\<lambda>(it,\\<sigma>). \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>) (FOREACH_cond c) (FOREACH_body f) (xs,\\<sigma>0); \n  RETURN \\<sigma> }\""], ["", "text \\<open>Foreach with continuation condition and annotated invariant:\\<close>"], ["", "definition FOREACHci (\"FOREACH\\<^sub>C\\<^bsup>_\\<^esup>\") where \"FOREACHci \\<equiv> FOREACHoci (\\<lambda>_ _. True)\""], ["", "text \\<open>Foreach with continuation condition:\\<close>"], ["", "definition FOREACHc (\"FOREACH\\<^sub>C\") where \"FOREACHc \\<equiv> FOREACHci (\\<lambda>_ _. True)\""], ["", "text \\<open>Foreach with annotated invariant:\\<close>"], ["", "definition FOREACHi (\"FOREACH\\<^bsup>_\\<^esup>\") where \n  \"FOREACHi \\<Phi> S \\<equiv> FOREACHci \\<Phi> S (\\<lambda>_. True)\""], ["", "text \\<open>Foreach with annotated invariant and order:\\<close>"], ["", "definition FOREACHoi (\"FOREACH\\<^sub>O\\<^bsup>_,_\\<^esup>\") where \n  \"FOREACHoi R \\<Phi> S \\<equiv> FOREACHoci R \\<Phi> S (\\<lambda>_. True)\""], ["", "text \\<open>Basic foreach\\<close>"], ["", "definition \"FOREACH S \\<equiv> FOREACHc S (\\<lambda>_. True)\""], ["", "lemmas FOREACH_to_oci_unfold\n  = FOREACHci_def FOREACHc_def FOREACHi_def FOREACHoi_def FOREACH_def"], ["", "subsection \\<open>Proof Rules\\<close>"], ["", "lemma FOREACHoci_rule[refine_vcg]:\n  assumes FIN: \"finite S\"\n  assumes I0: \"I S \\<sigma>0\"\n  assumes IP: \n    \"\\<And>x it \\<sigma>. \\<lbrakk> c \\<sigma>; x\\<in>it; it\\<subseteq>S; I it \\<sigma>; \\<forall>y\\<in>it - {x}. R x y;\n                \\<forall>y\\<in>S - it. R y x \\<rbrakk> \\<Longrightarrow> f x \\<sigma> \\<le> SPEC (I (it-{x}))\"\n  assumes II1: \"\\<And>\\<sigma>. \\<lbrakk>I {} \\<sigma>\\<rbrakk> \\<Longrightarrow> P \\<sigma>\"\n  assumes II2: \"\\<And>it \\<sigma>. \\<lbrakk> it\\<noteq>{}; it\\<subseteq>S; I it \\<sigma>; \\<not>c \\<sigma>;\n                         \\<forall>x\\<in>it. \\<forall>y\\<in>S - it. R y x \\<rbrakk> \\<Longrightarrow> P \\<sigma>\"\n  shows \"FOREACHoci R I S c f \\<sigma>0 \\<le> SPEC P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. FOREACH\\<^sub>O\\<^sub>C\\<^bsup>R,I\\<^esup> S c f \\<sigma>0 \\<le> SPEC P", "unfolding FOREACHoci_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ASSERT (finite S) \\<bind>\n    (\\<lambda>_.\n        SPEC\n         (\\<lambda>xs.\n             distinct xs \\<and> S = set xs \\<and> sorted_wrt R xs) \\<bind>\n        (\\<lambda>xs.\n            WHILE\\<^sub>T\\<^bsup>\\<lambda>(it, \\<sigma>).\n                                    \\<exists>xs'.\n xs = xs' @ it \\<and> I (set it) \\<sigma>\\<^esup>\n             (FOREACH_cond c) (FOREACH_body f) (xs, \\<sigma>0) \\<bind>\n            (\\<lambda>(uu_, \\<sigma>). RETURN \\<sigma>)))\n    \\<le> SPEC P", "apply (intro refine_vcg)"], ["proof (prove)\ngoal (5 subgoals):\n 1. finite S\n 2. \\<And>x.\n       \\<lbrakk>finite S;\n        distinct x \\<and> S = set x \\<and> sorted_wrt R x\\<rbrakk>\n       \\<Longrightarrow> wf (?R5 x)\n 3. \\<And>x.\n       \\<lbrakk>finite S;\n        distinct x \\<and> S = set x \\<and> sorted_wrt R x\\<rbrakk>\n       \\<Longrightarrow> case (x, \\<sigma>0) of\n                         (it, \\<sigma>) \\<Rightarrow>\n                           \\<exists>xs'.\n                              x = xs' @ it \\<and> I (set it) \\<sigma>\n 4. \\<And>x s.\n       \\<lbrakk>finite S; distinct x \\<and> S = set x \\<and> sorted_wrt R x;\n        case s of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. x = xs' @ it \\<and> I (set it) \\<sigma>;\n        FOREACH_cond c s\\<rbrakk>\n       \\<Longrightarrow> FOREACH_body f s\n                         \\<le> SPEC\n                                (\\<lambda>s'.\n                                    (case s' of\n                                     (it, \\<sigma>) \\<Rightarrow>\n \\<exists>xs'. x = xs' @ it \\<and> I (set it) \\<sigma>) \\<and>\n                                    (s', s) \\<in> ?R5 x)\n 5. \\<And>x s a b.\n       \\<lbrakk>finite S; distinct x \\<and> S = set x \\<and> sorted_wrt R x;\n        case s of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. x = xs' @ it \\<and> I (set it) \\<sigma>;\n        \\<not> FOREACH_cond c s; s = (a, b)\\<rbrakk>\n       \\<Longrightarrow> P b", "apply (rule FIN)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>finite S;\n        distinct x \\<and> S = set x \\<and> sorted_wrt R x\\<rbrakk>\n       \\<Longrightarrow> wf (?R5 x)\n 2. \\<And>x.\n       \\<lbrakk>finite S;\n        distinct x \\<and> S = set x \\<and> sorted_wrt R x\\<rbrakk>\n       \\<Longrightarrow> case (x, \\<sigma>0) of\n                         (it, \\<sigma>) \\<Rightarrow>\n                           \\<exists>xs'.\n                              x = xs' @ it \\<and> I (set it) \\<sigma>\n 3. \\<And>x s.\n       \\<lbrakk>finite S; distinct x \\<and> S = set x \\<and> sorted_wrt R x;\n        case s of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. x = xs' @ it \\<and> I (set it) \\<sigma>;\n        FOREACH_cond c s\\<rbrakk>\n       \\<Longrightarrow> FOREACH_body f s\n                         \\<le> SPEC\n                                (\\<lambda>s'.\n                                    (case s' of\n                                     (it, \\<sigma>) \\<Rightarrow>\n \\<exists>xs'. x = xs' @ it \\<and> I (set it) \\<sigma>) \\<and>\n                                    (s', s) \\<in> ?R5 x)\n 4. \\<And>x s a b.\n       \\<lbrakk>finite S; distinct x \\<and> S = set x \\<and> sorted_wrt R x;\n        case s of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. x = xs' @ it \\<and> I (set it) \\<sigma>;\n        \\<not> FOREACH_cond c s; s = (a, b)\\<rbrakk>\n       \\<Longrightarrow> P b", "apply (subgoal_tac \"wf (measure (\\<lambda>(xs, _). length xs))\")"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>finite S; distinct x \\<and> S = set x \\<and> sorted_wrt R x;\n        wf (measure (\\<lambda>(xs, uu_). length xs))\\<rbrakk>\n       \\<Longrightarrow> wf (?R5 x)\n 2. \\<And>x.\n       \\<lbrakk>finite S;\n        distinct x \\<and> S = set x \\<and> sorted_wrt R x\\<rbrakk>\n       \\<Longrightarrow> wf (measure (\\<lambda>(xs, uu_). length xs))\n 3. \\<And>x.\n       \\<lbrakk>finite S;\n        distinct x \\<and> S = set x \\<and> sorted_wrt R x\\<rbrakk>\n       \\<Longrightarrow> case (x, \\<sigma>0) of\n                         (it, \\<sigma>) \\<Rightarrow>\n                           \\<exists>xs'.\n                              x = xs' @ it \\<and> I (set it) \\<sigma>\n 4. \\<And>x s.\n       \\<lbrakk>finite S; distinct x \\<and> S = set x \\<and> sorted_wrt R x;\n        case s of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. x = xs' @ it \\<and> I (set it) \\<sigma>;\n        FOREACH_cond c s\\<rbrakk>\n       \\<Longrightarrow> FOREACH_body f s\n                         \\<le> SPEC\n                                (\\<lambda>s'.\n                                    (case s' of\n                                     (it, \\<sigma>) \\<Rightarrow>\n \\<exists>xs'. x = xs' @ it \\<and> I (set it) \\<sigma>) \\<and>\n                                    (s', s) \\<in> ?R5 x)\n 5. \\<And>x s a b.\n       \\<lbrakk>finite S; distinct x \\<and> S = set x \\<and> sorted_wrt R x;\n        case s of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. x = xs' @ it \\<and> I (set it) \\<sigma>;\n        \\<not> FOREACH_cond c s; s = (a, b)\\<rbrakk>\n       \\<Longrightarrow> P b", "apply assumption"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>finite S;\n        distinct x \\<and> S = set x \\<and> sorted_wrt R x\\<rbrakk>\n       \\<Longrightarrow> wf (measure (\\<lambda>(xs, uu_). length xs))\n 2. \\<And>x.\n       \\<lbrakk>finite S;\n        distinct x \\<and> S = set x \\<and> sorted_wrt R x\\<rbrakk>\n       \\<Longrightarrow> case (x, \\<sigma>0) of\n                         (it, \\<sigma>) \\<Rightarrow>\n                           \\<exists>xs'.\n                              x = xs' @ it \\<and> I (set it) \\<sigma>\n 3. \\<And>x s.\n       \\<lbrakk>finite S; distinct x \\<and> S = set x \\<and> sorted_wrt R x;\n        case s of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. x = xs' @ it \\<and> I (set it) \\<sigma>;\n        FOREACH_cond c s\\<rbrakk>\n       \\<Longrightarrow> FOREACH_body f s\n                         \\<le> SPEC\n                                (\\<lambda>s'.\n                                    (case s' of\n                                     (it, \\<sigma>) \\<Rightarrow>\n \\<exists>xs'. x = xs' @ it \\<and> I (set it) \\<sigma>) \\<and>\n                                    (s', s)\n                                    \\<in> measure\n     (\\<lambda>(xs, uu_). length xs))\n 4. \\<And>x s a b.\n       \\<lbrakk>finite S; distinct x \\<and> S = set x \\<and> sorted_wrt R x;\n        case s of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. x = xs' @ it \\<and> I (set it) \\<sigma>;\n        \\<not> FOREACH_cond c s; s = (a, b)\\<rbrakk>\n       \\<Longrightarrow> P b", "apply simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>finite S;\n        distinct x \\<and> S = set x \\<and> sorted_wrt R x\\<rbrakk>\n       \\<Longrightarrow> case (x, \\<sigma>0) of\n                         (it, \\<sigma>) \\<Rightarrow>\n                           \\<exists>xs'.\n                              x = xs' @ it \\<and> I (set it) \\<sigma>\n 2. \\<And>x s.\n       \\<lbrakk>finite S; distinct x \\<and> S = set x \\<and> sorted_wrt R x;\n        case s of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. x = xs' @ it \\<and> I (set it) \\<sigma>;\n        FOREACH_cond c s\\<rbrakk>\n       \\<Longrightarrow> FOREACH_body f s\n                         \\<le> SPEC\n                                (\\<lambda>s'.\n                                    (case s' of\n                                     (it, \\<sigma>) \\<Rightarrow>\n \\<exists>xs'. x = xs' @ it \\<and> I (set it) \\<sigma>) \\<and>\n                                    (s', s)\n                                    \\<in> measure\n     (\\<lambda>(xs, uu_). length xs))\n 3. \\<And>x s a b.\n       \\<lbrakk>finite S; distinct x \\<and> S = set x \\<and> sorted_wrt R x;\n        case s of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. x = xs' @ it \\<and> I (set it) \\<sigma>;\n        \\<not> FOREACH_cond c s; s = (a, b)\\<rbrakk>\n       \\<Longrightarrow> P b", "apply (insert I0, simp add: I0) []"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x s.\n       \\<lbrakk>finite S; distinct x \\<and> S = set x \\<and> sorted_wrt R x;\n        case s of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. x = xs' @ it \\<and> I (set it) \\<sigma>;\n        FOREACH_cond c s\\<rbrakk>\n       \\<Longrightarrow> FOREACH_body f s\n                         \\<le> SPEC\n                                (\\<lambda>s'.\n                                    (case s' of\n                                     (it, \\<sigma>) \\<Rightarrow>\n \\<exists>xs'. x = xs' @ it \\<and> I (set it) \\<sigma>) \\<and>\n                                    (s', s)\n                                    \\<in> measure\n     (\\<lambda>(xs, uu_). length xs))\n 2. \\<And>x s a b.\n       \\<lbrakk>finite S; distinct x \\<and> S = set x \\<and> sorted_wrt R x;\n        case s of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. x = xs' @ it \\<and> I (set it) \\<sigma>;\n        \\<not> FOREACH_cond c s; s = (a, b)\\<rbrakk>\n       \\<Longrightarrow> P b", "unfolding FOREACH_body_def FOREACH_cond_def"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x s.\n       \\<lbrakk>finite S; distinct x \\<and> S = set x \\<and> sorted_wrt R x;\n        case s of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. x = xs' @ it \\<and> I (set it) \\<sigma>;\n        case s of\n        (xs, \\<sigma>) \\<Rightarrow>\n          xs \\<noteq> [] \\<and> c \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> (case s of\n                          (xs, \\<sigma>) \\<Rightarrow>\n                            let x = hd xs\n                            in f x \\<sigma> \\<bind>\n                               (\\<lambda>\\<sigma>'.\n                                   RETURN (tl xs, \\<sigma>')))\n                         \\<le> SPEC\n                                (\\<lambda>s'.\n                                    (case s' of\n                                     (it, \\<sigma>) \\<Rightarrow>\n \\<exists>xs'. x = xs' @ it \\<and> I (set it) \\<sigma>) \\<and>\n                                    (s', s)\n                                    \\<in> measure\n     (\\<lambda>(xs, uu_). length xs))\n 2. \\<And>x s a b.\n       \\<lbrakk>finite S; distinct x \\<and> S = set x \\<and> sorted_wrt R x;\n        case s of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. x = xs' @ it \\<and> I (set it) \\<sigma>;\n        \\<not> (case s of\n                (xs, \\<sigma>) \\<Rightarrow>\n                  xs \\<noteq> [] \\<and> c \\<sigma>);\n        s = (a, b)\\<rbrakk>\n       \\<Longrightarrow> P b", "apply (rule refine_vcg)+"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x s a b.\n       \\<lbrakk>finite S; distinct x \\<and> S = set x \\<and> sorted_wrt R x;\n        case s of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. x = xs' @ it \\<and> I (set it) \\<sigma>;\n        case s of\n        (xs, \\<sigma>) \\<Rightarrow> xs \\<noteq> [] \\<and> c \\<sigma>;\n        s = (a, b)\\<rbrakk>\n       \\<Longrightarrow> f (hd a) b\n                         \\<le> SPEC\n                                (\\<lambda>\\<sigma>'.\n                                    RETURN (tl a, \\<sigma>')\n                                    \\<le> SPEC\n     (\\<lambda>s'.\n         (case s' of\n          (it, \\<sigma>) \\<Rightarrow>\n            \\<exists>xs'. x = xs' @ it \\<and> I (set it) \\<sigma>) \\<and>\n         (s', s) \\<in> measure (\\<lambda>(xs, uu_). length xs)))\n 2. \\<And>x s a b.\n       \\<lbrakk>finite S; distinct x \\<and> S = set x \\<and> sorted_wrt R x;\n        case s of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. x = xs' @ it \\<and> I (set it) \\<sigma>;\n        \\<not> (case s of\n                (xs, \\<sigma>) \\<Rightarrow>\n                  xs \\<noteq> [] \\<and> c \\<sigma>);\n        s = (a, b)\\<rbrakk>\n       \\<Longrightarrow> P b", "apply ((simp, elim conjE exE)+) []"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x s a b xs'.\n       \\<lbrakk>s = (a, b); I (set a) b; a \\<noteq> []; c b;\n        S = set xs' \\<union> set a; sorted_wrt R (xs' @ a); x = xs' @ a;\n        distinct xs'; distinct a; set xs' \\<inter> set a = {}\\<rbrakk>\n       \\<Longrightarrow> f (hd a) b\n                         \\<le> SPEC\n                                (\\<lambda>\\<sigma>'.\n                                    (\\<exists>xs'a.\n  xs' @ a = xs'a @ tl a) \\<and>\n                                    I (set (tl a)) \\<sigma>')\n 2. \\<And>x s a b.\n       \\<lbrakk>finite S; distinct x \\<and> S = set x \\<and> sorted_wrt R x;\n        case s of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. x = xs' @ it \\<and> I (set it) \\<sigma>;\n        \\<not> (case s of\n                (xs, \\<sigma>) \\<Rightarrow>\n                  xs \\<noteq> [] \\<and> c \\<sigma>);\n        s = (a, b)\\<rbrakk>\n       \\<Longrightarrow> P b", "apply (rename_tac xs'' s xs' \\<sigma> xs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xs'' s xs' \\<sigma> xs.\n       \\<lbrakk>s = (xs', \\<sigma>); I (set xs') \\<sigma>; xs' \\<noteq> [];\n        c \\<sigma>; S = set xs \\<union> set xs'; sorted_wrt R (xs @ xs');\n        xs'' = xs @ xs'; distinct xs; distinct xs';\n        set xs \\<inter> set xs' = {}\\<rbrakk>\n       \\<Longrightarrow> f (hd xs') \\<sigma>\n                         \\<le> SPEC\n                                (\\<lambda>\\<sigma>'.\n                                    (\\<exists>xs'a.\n  xs @ xs' = xs'a @ tl xs') \\<and>\n                                    I (set (tl xs')) \\<sigma>')\n 2. \\<And>x s a b.\n       \\<lbrakk>finite S; distinct x \\<and> S = set x \\<and> sorted_wrt R x;\n        case s of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. x = xs' @ it \\<and> I (set it) \\<sigma>;\n        \\<not> (case s of\n                (xs, \\<sigma>) \\<Rightarrow>\n                  xs \\<noteq> [] \\<and> c \\<sigma>);\n        s = (a, b)\\<rbrakk>\n       \\<Longrightarrow> P b", "defer"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x s a b.\n       \\<lbrakk>finite S; distinct x \\<and> S = set x \\<and> sorted_wrt R x;\n        case s of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. x = xs' @ it \\<and> I (set it) \\<sigma>;\n        \\<not> (case s of\n                (xs, \\<sigma>) \\<Rightarrow>\n                  xs \\<noteq> [] \\<and> c \\<sigma>);\n        s = (a, b)\\<rbrakk>\n       \\<Longrightarrow> P b\n 2. \\<And>xs'' s xs' \\<sigma> xs.\n       \\<lbrakk>s = (xs', \\<sigma>); I (set xs') \\<sigma>; xs' \\<noteq> [];\n        c \\<sigma>; S = set xs \\<union> set xs'; sorted_wrt R (xs @ xs');\n        xs'' = xs @ xs'; distinct xs; distinct xs';\n        set xs \\<inter> set xs' = {}\\<rbrakk>\n       \\<Longrightarrow> f (hd xs') \\<sigma>\n                         \\<le> SPEC\n                                (\\<lambda>\\<sigma>'.\n                                    (\\<exists>xs'a.\n  xs @ xs' = xs'a @ tl xs') \\<and>\n                                    I (set (tl xs')) \\<sigma>')", "apply (simp, elim conjE exE)+"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x s a b xs'.\n       \\<lbrakk>a = [] \\<or> \\<not> c b; s = (a, b); I (set a) b;\n        S = set xs' \\<union> set a; sorted_wrt R (xs' @ a); x = xs' @ a;\n        distinct xs'; distinct a; set xs' \\<inter> set a = {}\\<rbrakk>\n       \\<Longrightarrow> P b\n 2. \\<And>xs'' s xs' \\<sigma> xs.\n       \\<lbrakk>s = (xs', \\<sigma>); I (set xs') \\<sigma>; xs' \\<noteq> [];\n        c \\<sigma>; S = set xs \\<union> set xs'; sorted_wrt R (xs @ xs');\n        xs'' = xs @ xs'; distinct xs; distinct xs';\n        set xs \\<inter> set xs' = {}\\<rbrakk>\n       \\<Longrightarrow> f (hd xs') \\<sigma>\n                         \\<le> SPEC\n                                (\\<lambda>\\<sigma>'.\n                                    (\\<exists>xs'a.\n  xs @ xs' = xs'a @ tl xs') \\<and>\n                                    I (set (tl xs')) \\<sigma>')", "apply (rename_tac x s xs' \\<sigma> xs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x s xs' \\<sigma> xs.\n       \\<lbrakk>xs' = [] \\<or> \\<not> c \\<sigma>; s = (xs', \\<sigma>);\n        I (set xs') \\<sigma>; S = set xs \\<union> set xs';\n        sorted_wrt R (xs @ xs'); x = xs @ xs'; distinct xs; distinct xs';\n        set xs \\<inter> set xs' = {}\\<rbrakk>\n       \\<Longrightarrow> P \\<sigma>\n 2. \\<And>xs'' s xs' \\<sigma> xs.\n       \\<lbrakk>s = (xs', \\<sigma>); I (set xs') \\<sigma>; xs' \\<noteq> [];\n        c \\<sigma>; S = set xs \\<union> set xs'; sorted_wrt R (xs @ xs');\n        xs'' = xs @ xs'; distinct xs; distinct xs';\n        set xs \\<inter> set xs' = {}\\<rbrakk>\n       \\<Longrightarrow> f (hd xs') \\<sigma>\n                         \\<le> SPEC\n                                (\\<lambda>\\<sigma>'.\n                                    (\\<exists>xs'a.\n  xs @ xs' = xs'a @ tl xs') \\<and>\n                                    I (set (tl xs')) \\<sigma>')", "defer"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xs'' s xs' \\<sigma> xs.\n       \\<lbrakk>s = (xs', \\<sigma>); I (set xs') \\<sigma>; xs' \\<noteq> [];\n        c \\<sigma>; S = set xs \\<union> set xs'; sorted_wrt R (xs @ xs');\n        xs'' = xs @ xs'; distinct xs; distinct xs';\n        set xs \\<inter> set xs' = {}\\<rbrakk>\n       \\<Longrightarrow> f (hd xs') \\<sigma>\n                         \\<le> SPEC\n                                (\\<lambda>\\<sigma>'.\n                                    (\\<exists>xs'a.\n  xs @ xs' = xs'a @ tl xs') \\<and>\n                                    I (set (tl xs')) \\<sigma>')\n 2. \\<And>x s xs' \\<sigma> xs.\n       \\<lbrakk>xs' = [] \\<or> \\<not> c \\<sigma>; s = (xs', \\<sigma>);\n        I (set xs') \\<sigma>; S = set xs \\<union> set xs';\n        sorted_wrt R (xs @ xs'); x = xs @ xs'; distinct xs; distinct xs';\n        set xs \\<inter> set xs' = {}\\<rbrakk>\n       \\<Longrightarrow> P \\<sigma>", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xs'' s xs' \\<sigma> xs.\n       \\<lbrakk>s = (xs', \\<sigma>); I (set xs') \\<sigma>; xs' \\<noteq> [];\n        c \\<sigma>; S = set xs \\<union> set xs'; sorted_wrt R (xs @ xs');\n        xs'' = xs @ xs'; distinct xs; distinct xs';\n        set xs \\<inter> set xs' = {}\\<rbrakk>\n       \\<Longrightarrow> f (hd xs') \\<sigma>\n                         \\<le> SPEC\n                                (\\<lambda>\\<sigma>'.\n                                    (\\<exists>xs'a.\n  xs @ xs' = xs'a @ tl xs') \\<and>\n                                    I (set (tl xs')) \\<sigma>')\n 2. \\<And>x s xs' \\<sigma> xs.\n       \\<lbrakk>xs' = [] \\<or> \\<not> c \\<sigma>; s = (xs', \\<sigma>);\n        I (set xs') \\<sigma>; S = set xs \\<union> set xs';\n        sorted_wrt R (xs @ xs'); x = xs @ xs'; distinct xs; distinct xs';\n        set xs \\<inter> set xs' = {}\\<rbrakk>\n       \\<Longrightarrow> P \\<sigma>", "fix xs' \\<sigma> xs"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xs'' s xs' \\<sigma> xs.\n       \\<lbrakk>s = (xs', \\<sigma>); I (set xs') \\<sigma>; xs' \\<noteq> [];\n        c \\<sigma>; S = set xs \\<union> set xs'; sorted_wrt R (xs @ xs');\n        xs'' = xs @ xs'; distinct xs; distinct xs';\n        set xs \\<inter> set xs' = {}\\<rbrakk>\n       \\<Longrightarrow> f (hd xs') \\<sigma>\n                         \\<le> SPEC\n                                (\\<lambda>\\<sigma>'.\n                                    (\\<exists>xs'a.\n  xs @ xs' = xs'a @ tl xs') \\<and>\n                                    I (set (tl xs')) \\<sigma>')\n 2. \\<And>x s xs' \\<sigma> xs.\n       \\<lbrakk>xs' = [] \\<or> \\<not> c \\<sigma>; s = (xs', \\<sigma>);\n        I (set xs') \\<sigma>; S = set xs \\<union> set xs';\n        sorted_wrt R (xs @ xs'); x = xs @ xs'; distinct xs; distinct xs';\n        set xs \\<inter> set xs' = {}\\<rbrakk>\n       \\<Longrightarrow> P \\<sigma>", "assume I_xs': \"I (set xs') \\<sigma>\"\n     and sorted_xs_xs': \"sorted_wrt R (xs @ xs')\"\n     and dist: \"distinct xs\" \"distinct xs'\" \"set xs \\<inter> set xs' = {}\"\n     and S_eq: \"S = set xs \\<union> set xs'\""], ["proof (state)\nthis:\n  I (set xs') \\<sigma>\n  sorted_wrt R (xs @ xs')\n  distinct xs\n  distinct xs'\n  set xs \\<inter> set xs' = {}\n  S = set xs \\<union> set xs'\n\ngoal (2 subgoals):\n 1. \\<And>xs'' s xs' \\<sigma> xs.\n       \\<lbrakk>s = (xs', \\<sigma>); I (set xs') \\<sigma>; xs' \\<noteq> [];\n        c \\<sigma>; S = set xs \\<union> set xs'; sorted_wrt R (xs @ xs');\n        xs'' = xs @ xs'; distinct xs; distinct xs';\n        set xs \\<inter> set xs' = {}\\<rbrakk>\n       \\<Longrightarrow> f (hd xs') \\<sigma>\n                         \\<le> SPEC\n                                (\\<lambda>\\<sigma>'.\n                                    (\\<exists>xs'a.\n  xs @ xs' = xs'a @ tl xs') \\<and>\n                                    I (set (tl xs')) \\<sigma>')\n 2. \\<And>x s xs' \\<sigma> xs.\n       \\<lbrakk>xs' = [] \\<or> \\<not> c \\<sigma>; s = (xs', \\<sigma>);\n        I (set xs') \\<sigma>; S = set xs \\<union> set xs';\n        sorted_wrt R (xs @ xs'); x = xs @ xs'; distinct xs; distinct xs';\n        set xs \\<inter> set xs' = {}\\<rbrakk>\n       \\<Longrightarrow> P \\<sigma>", "from S_eq"], ["proof (chain)\npicking this:\n  S = set xs \\<union> set xs'", "have \"set xs' \\<subseteq> S\""], ["proof (prove)\nusing this:\n  S = set xs \\<union> set xs'\n\ngoal (1 subgoal):\n 1. set xs' \\<subseteq> S", "by simp"], ["proof (state)\nthis:\n  set xs' \\<subseteq> S\n\ngoal (2 subgoals):\n 1. \\<And>xs'' s xs' \\<sigma> xs.\n       \\<lbrakk>s = (xs', \\<sigma>); I (set xs') \\<sigma>; xs' \\<noteq> [];\n        c \\<sigma>; S = set xs \\<union> set xs'; sorted_wrt R (xs @ xs');\n        xs'' = xs @ xs'; distinct xs; distinct xs';\n        set xs \\<inter> set xs' = {}\\<rbrakk>\n       \\<Longrightarrow> f (hd xs') \\<sigma>\n                         \\<le> SPEC\n                                (\\<lambda>\\<sigma>'.\n                                    (\\<exists>xs'a.\n  xs @ xs' = xs'a @ tl xs') \\<and>\n                                    I (set (tl xs')) \\<sigma>')\n 2. \\<And>x s xs' \\<sigma> xs.\n       \\<lbrakk>xs' = [] \\<or> \\<not> c \\<sigma>; s = (xs', \\<sigma>);\n        I (set xs') \\<sigma>; S = set xs \\<union> set xs';\n        sorted_wrt R (xs @ xs'); x = xs @ xs'; distinct xs; distinct xs';\n        set xs \\<inter> set xs' = {}\\<rbrakk>\n       \\<Longrightarrow> P \\<sigma>", "from dist S_eq"], ["proof (chain)\npicking this:\n  distinct xs\n  distinct xs'\n  set xs \\<inter> set xs' = {}\n  S = set xs \\<union> set xs'", "have S_diff: \"S - set xs' = set xs\""], ["proof (prove)\nusing this:\n  distinct xs\n  distinct xs'\n  set xs \\<inter> set xs' = {}\n  S = set xs \\<union> set xs'\n\ngoal (1 subgoal):\n 1. S - set xs' = set xs", "by blast"], ["proof (state)\nthis:\n  S - set xs' = set xs\n\ngoal (2 subgoals):\n 1. \\<And>xs'' s xs' \\<sigma> xs.\n       \\<lbrakk>s = (xs', \\<sigma>); I (set xs') \\<sigma>; xs' \\<noteq> [];\n        c \\<sigma>; S = set xs \\<union> set xs'; sorted_wrt R (xs @ xs');\n        xs'' = xs @ xs'; distinct xs; distinct xs';\n        set xs \\<inter> set xs' = {}\\<rbrakk>\n       \\<Longrightarrow> f (hd xs') \\<sigma>\n                         \\<le> SPEC\n                                (\\<lambda>\\<sigma>'.\n                                    (\\<exists>xs'a.\n  xs @ xs' = xs'a @ tl xs') \\<and>\n                                    I (set (tl xs')) \\<sigma>')\n 2. \\<And>x s xs' \\<sigma> xs.\n       \\<lbrakk>xs' = [] \\<or> \\<not> c \\<sigma>; s = (xs', \\<sigma>);\n        I (set xs') \\<sigma>; S = set xs \\<union> set xs';\n        sorted_wrt R (xs @ xs'); x = xs @ xs'; distinct xs; distinct xs';\n        set xs \\<inter> set xs' = {}\\<rbrakk>\n       \\<Longrightarrow> P \\<sigma>", "{"], ["proof (state)\nthis:\n  S - set xs' = set xs\n\ngoal (2 subgoals):\n 1. \\<And>xs'' s xs' \\<sigma> xs.\n       \\<lbrakk>s = (xs', \\<sigma>); I (set xs') \\<sigma>; xs' \\<noteq> [];\n        c \\<sigma>; S = set xs \\<union> set xs'; sorted_wrt R (xs @ xs');\n        xs'' = xs @ xs'; distinct xs; distinct xs';\n        set xs \\<inter> set xs' = {}\\<rbrakk>\n       \\<Longrightarrow> f (hd xs') \\<sigma>\n                         \\<le> SPEC\n                                (\\<lambda>\\<sigma>'.\n                                    (\\<exists>xs'a.\n  xs @ xs' = xs'a @ tl xs') \\<and>\n                                    I (set (tl xs')) \\<sigma>')\n 2. \\<And>x s xs' \\<sigma> xs.\n       \\<lbrakk>xs' = [] \\<or> \\<not> c \\<sigma>; s = (xs', \\<sigma>);\n        I (set xs') \\<sigma>; S = set xs \\<union> set xs';\n        sorted_wrt R (xs @ xs'); x = xs @ xs'; distinct xs; distinct xs';\n        set xs \\<inter> set xs' = {}\\<rbrakk>\n       \\<Longrightarrow> P \\<sigma>", "assume \"xs' \\<noteq> []\" \"c \\<sigma>\""], ["proof (state)\nthis:\n  xs' \\<noteq> []\n  c \\<sigma>\n\ngoal (2 subgoals):\n 1. \\<And>xs'' s xs' \\<sigma> xs.\n       \\<lbrakk>s = (xs', \\<sigma>); I (set xs') \\<sigma>; xs' \\<noteq> [];\n        c \\<sigma>; S = set xs \\<union> set xs'; sorted_wrt R (xs @ xs');\n        xs'' = xs @ xs'; distinct xs; distinct xs';\n        set xs \\<inter> set xs' = {}\\<rbrakk>\n       \\<Longrightarrow> f (hd xs') \\<sigma>\n                         \\<le> SPEC\n                                (\\<lambda>\\<sigma>'.\n                                    (\\<exists>xs'a.\n  xs @ xs' = xs'a @ tl xs') \\<and>\n                                    I (set (tl xs')) \\<sigma>')\n 2. \\<And>x s xs' \\<sigma> xs.\n       \\<lbrakk>xs' = [] \\<or> \\<not> c \\<sigma>; s = (xs', \\<sigma>);\n        I (set xs') \\<sigma>; S = set xs \\<union> set xs';\n        sorted_wrt R (xs @ xs'); x = xs @ xs'; distinct xs; distinct xs';\n        set xs \\<inter> set xs' = {}\\<rbrakk>\n       \\<Longrightarrow> P \\<sigma>", "from \\<open>xs' \\<noteq> []\\<close>"], ["proof (chain)\npicking this:\n  xs' \\<noteq> []", "obtain x xs'' where xs'_eq: \"xs' = x # xs''\""], ["proof (prove)\nusing this:\n  xs' \\<noteq> []\n\ngoal (1 subgoal):\n 1. (\\<And>x xs''.\n        xs' = x # xs'' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases xs', auto)"], ["proof (state)\nthis:\n  xs' = x # xs''\n\ngoal (2 subgoals):\n 1. \\<And>xs'' s xs' \\<sigma> xs.\n       \\<lbrakk>s = (xs', \\<sigma>); I (set xs') \\<sigma>; xs' \\<noteq> [];\n        c \\<sigma>; S = set xs \\<union> set xs'; sorted_wrt R (xs @ xs');\n        xs'' = xs @ xs'; distinct xs; distinct xs';\n        set xs \\<inter> set xs' = {}\\<rbrakk>\n       \\<Longrightarrow> f (hd xs') \\<sigma>\n                         \\<le> SPEC\n                                (\\<lambda>\\<sigma>'.\n                                    (\\<exists>xs'a.\n  xs @ xs' = xs'a @ tl xs') \\<and>\n                                    I (set (tl xs')) \\<sigma>')\n 2. \\<And>x s xs' \\<sigma> xs.\n       \\<lbrakk>xs' = [] \\<or> \\<not> c \\<sigma>; s = (xs', \\<sigma>);\n        I (set xs') \\<sigma>; S = set xs \\<union> set xs';\n        sorted_wrt R (xs @ xs'); x = xs @ xs'; distinct xs; distinct xs';\n        set xs \\<inter> set xs' = {}\\<rbrakk>\n       \\<Longrightarrow> P \\<sigma>", "have x_in_xs': \"x \\<in> set xs'\" and x_nin_xs'': \"x \\<notin> set xs''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> set xs' &&& x \\<notin> set xs''", "using \\<open>distinct xs'\\<close>"], ["proof (prove)\nusing this:\n  distinct xs'\n\ngoal (1 subgoal):\n 1. x \\<in> set xs' &&& x \\<notin> set xs''", "unfolding xs'_eq"], ["proof (prove)\nusing this:\n  distinct (x # xs'')\n\ngoal (1 subgoal):\n 1. x \\<in> set (x # xs'') &&& x \\<notin> set xs''", "by simp_all"], ["proof (state)\nthis:\n  x \\<in> set xs'\n  x \\<notin> set xs''\n\ngoal (2 subgoals):\n 1. \\<And>xs'' s xs' \\<sigma> xs.\n       \\<lbrakk>s = (xs', \\<sigma>); I (set xs') \\<sigma>; xs' \\<noteq> [];\n        c \\<sigma>; S = set xs \\<union> set xs'; sorted_wrt R (xs @ xs');\n        xs'' = xs @ xs'; distinct xs; distinct xs';\n        set xs \\<inter> set xs' = {}\\<rbrakk>\n       \\<Longrightarrow> f (hd xs') \\<sigma>\n                         \\<le> SPEC\n                                (\\<lambda>\\<sigma>'.\n                                    (\\<exists>xs'a.\n  xs @ xs' = xs'a @ tl xs') \\<and>\n                                    I (set (tl xs')) \\<sigma>')\n 2. \\<And>x s xs' \\<sigma> xs.\n       \\<lbrakk>xs' = [] \\<or> \\<not> c \\<sigma>; s = (xs', \\<sigma>);\n        I (set xs') \\<sigma>; S = set xs \\<union> set xs';\n        sorted_wrt R (xs @ xs'); x = xs @ xs'; distinct xs; distinct xs';\n        set xs \\<inter> set xs' = {}\\<rbrakk>\n       \\<Longrightarrow> P \\<sigma>", "from IP[of \\<sigma> x \"set xs'\", OF \\<open>c \\<sigma>\\<close> x_in_xs' \\<open>set xs' \\<subseteq> S\\<close> \\<open>I (set xs') \\<sigma>\\<close>] x_nin_xs''\n         sorted_xs_xs' S_diff"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<forall>y\\<in>set xs' - {x}. R x y;\n   \\<forall>y\\<in>S - set xs'. R y x\\<rbrakk>\n  \\<Longrightarrow> f x \\<sigma> \\<le> SPEC (I (set xs' - {x}))\n  x \\<notin> set xs''\n  sorted_wrt R (xs @ xs')\n  S - set xs' = set xs", "show \"f (hd xs') \\<sigma> \\<le> SPEC\n            (\\<lambda>x. (\\<exists>xs'a. xs @ xs' = xs'a @ tl xs') \\<and>\n                 I (set (tl xs')) x)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<forall>y\\<in>set xs' - {x}. R x y;\n   \\<forall>y\\<in>S - set xs'. R y x\\<rbrakk>\n  \\<Longrightarrow> f x \\<sigma> \\<le> SPEC (I (set xs' - {x}))\n  x \\<notin> set xs''\n  sorted_wrt R (xs @ xs')\n  S - set xs' = set xs\n\ngoal (1 subgoal):\n 1. f (hd xs') \\<sigma>\n    \\<le> SPEC\n           (\\<lambda>x.\n               (\\<exists>xs'a. xs @ xs' = xs'a @ tl xs') \\<and>\n               I (set (tl xs')) x)", "apply (simp add: xs'_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>\\<forall>y\\<in>set xs''. R x y;\n              \\<forall>y\\<in>set xs. R y x\\<rbrakk>\n             \\<Longrightarrow> f x \\<sigma> \\<le> SPEC (I (set xs''));\n     x \\<notin> set xs''; sorted_wrt R (xs @ x # xs'');\n     S - insert x (set xs'') = set xs\\<rbrakk>\n    \\<Longrightarrow> f x \\<sigma> \\<le> SPEC (I (set xs''))", "apply (simp add: sorted_wrt_append)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  f (hd xs') \\<sigma>\n  \\<le> SPEC\n         (\\<lambda>x.\n             (\\<exists>xs'a. xs @ xs' = xs'a @ tl xs') \\<and>\n             I (set (tl xs')) x)\n\ngoal (1 subgoal):\n 1. \\<And>x s xs' \\<sigma> xs.\n       \\<lbrakk>xs' = [] \\<or> \\<not> c \\<sigma>; s = (xs', \\<sigma>);\n        I (set xs') \\<sigma>; S = set xs \\<union> set xs';\n        sorted_wrt R (xs @ xs'); x = xs @ xs'; distinct xs; distinct xs';\n        set xs \\<inter> set xs' = {}\\<rbrakk>\n       \\<Longrightarrow> P \\<sigma>", "}"], ["proof (state)\nthis:\n  \\<lbrakk>xs' \\<noteq> []; c \\<sigma>\\<rbrakk>\n  \\<Longrightarrow> f (hd xs') \\<sigma>\n                    \\<le> SPEC\n                           (\\<lambda>x.\n                               (\\<exists>xs'a.\n                                   xs @ xs' = xs'a @ tl xs') \\<and>\n                               I (set (tl xs')) x)\n\ngoal (1 subgoal):\n 1. \\<And>x s xs' \\<sigma> xs.\n       \\<lbrakk>xs' = [] \\<or> \\<not> c \\<sigma>; s = (xs', \\<sigma>);\n        I (set xs') \\<sigma>; S = set xs \\<union> set xs';\n        sorted_wrt R (xs @ xs'); x = xs @ xs'; distinct xs; distinct xs';\n        set xs \\<inter> set xs' = {}\\<rbrakk>\n       \\<Longrightarrow> P \\<sigma>", "{"], ["proof (state)\nthis:\n  \\<lbrakk>xs' \\<noteq> []; c \\<sigma>\\<rbrakk>\n  \\<Longrightarrow> f (hd xs') \\<sigma>\n                    \\<le> SPEC\n                           (\\<lambda>x.\n                               (\\<exists>xs'a.\n                                   xs @ xs' = xs'a @ tl xs') \\<and>\n                               I (set (tl xs')) x)\n\ngoal (1 subgoal):\n 1. \\<And>x s xs' \\<sigma> xs.\n       \\<lbrakk>xs' = [] \\<or> \\<not> c \\<sigma>; s = (xs', \\<sigma>);\n        I (set xs') \\<sigma>; S = set xs \\<union> set xs';\n        sorted_wrt R (xs @ xs'); x = xs @ xs'; distinct xs; distinct xs';\n        set xs \\<inter> set xs' = {}\\<rbrakk>\n       \\<Longrightarrow> P \\<sigma>", "assume \"xs' = [] \\<or> \\<not>(c \\<sigma>)\""], ["proof (state)\nthis:\n  xs' = [] \\<or> \\<not> c \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<And>x s xs' \\<sigma> xs.\n       \\<lbrakk>xs' = [] \\<or> \\<not> c \\<sigma>; s = (xs', \\<sigma>);\n        I (set xs') \\<sigma>; S = set xs \\<union> set xs';\n        sorted_wrt R (xs @ xs'); x = xs @ xs'; distinct xs; distinct xs';\n        set xs \\<inter> set xs' = {}\\<rbrakk>\n       \\<Longrightarrow> P \\<sigma>", "show \"P \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<sigma>", "proof (cases \"xs' = []\")"], ["proof (state)\ngoal (2 subgoals):\n 1. xs' = [] \\<Longrightarrow> P \\<sigma>\n 2. xs' \\<noteq> [] \\<Longrightarrow> P \\<sigma>", "case True"], ["proof (state)\nthis:\n  xs' = []\n\ngoal (2 subgoals):\n 1. xs' = [] \\<Longrightarrow> P \\<sigma>\n 2. xs' \\<noteq> [] \\<Longrightarrow> P \\<sigma>", "thus \"P \\<sigma>\""], ["proof (prove)\nusing this:\n  xs' = []\n\ngoal (1 subgoal):\n 1. P \\<sigma>", "using \\<open>I (set xs') \\<sigma>\\<close>"], ["proof (prove)\nusing this:\n  xs' = []\n  I (set xs') \\<sigma>\n\ngoal (1 subgoal):\n 1. P \\<sigma>", "by (simp add: II1)"], ["proof (state)\nthis:\n  P \\<sigma>\n\ngoal (1 subgoal):\n 1. xs' \\<noteq> [] \\<Longrightarrow> P \\<sigma>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. xs' \\<noteq> [] \\<Longrightarrow> P \\<sigma>", "case False"], ["proof (state)\nthis:\n  xs' \\<noteq> []\n\ngoal (1 subgoal):\n 1. xs' \\<noteq> [] \\<Longrightarrow> P \\<sigma>", "note xs'_neq_nil = this"], ["proof (state)\nthis:\n  xs' \\<noteq> []\n\ngoal (1 subgoal):\n 1. xs' \\<noteq> [] \\<Longrightarrow> P \\<sigma>", "with \\<open>xs' = [] \\<or> \\<not> c \\<sigma>\\<close>"], ["proof (chain)\npicking this:\n  xs' = [] \\<or> \\<not> c \\<sigma>\n  xs' \\<noteq> []", "have \"\\<not> c \\<sigma>\""], ["proof (prove)\nusing this:\n  xs' = [] \\<or> \\<not> c \\<sigma>\n  xs' \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<not> c \\<sigma>", "by simp"], ["proof (state)\nthis:\n  \\<not> c \\<sigma>\n\ngoal (1 subgoal):\n 1. xs' \\<noteq> [] \\<Longrightarrow> P \\<sigma>", "from II2 [of \"set xs'\" \\<sigma>] S_diff sorted_xs_xs'"], ["proof (chain)\npicking this:\n  \\<lbrakk>set xs' \\<noteq> {}; set xs' \\<subseteq> S; I (set xs') \\<sigma>;\n   \\<not> c \\<sigma>;\n   \\<forall>x\\<in>set xs'. \\<forall>y\\<in>S - set xs'. R y x\\<rbrakk>\n  \\<Longrightarrow> P \\<sigma>\n  S - set xs' = set xs\n  sorted_wrt R (xs @ xs')", "show \"P \\<sigma>\""], ["proof (prove)\nusing this:\n  \\<lbrakk>set xs' \\<noteq> {}; set xs' \\<subseteq> S; I (set xs') \\<sigma>;\n   \\<not> c \\<sigma>;\n   \\<forall>x\\<in>set xs'. \\<forall>y\\<in>S - set xs'. R y x\\<rbrakk>\n  \\<Longrightarrow> P \\<sigma>\n  S - set xs' = set xs\n  sorted_wrt R (xs @ xs')\n\ngoal (1 subgoal):\n 1. P \\<sigma>", "apply (simp add: xs'_neq_nil S_eq \\<open>\\<not> c \\<sigma>\\<close> I_xs')"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>x\\<in>set xs'.\n                \\<forall>y\\<in>set xs. R y x \\<Longrightarrow>\n             P \\<sigma>;\n     set xs \\<union> set xs' - set xs' = set xs;\n     sorted_wrt R (xs @ xs')\\<rbrakk>\n    \\<Longrightarrow> P \\<sigma>", "apply (simp add: sorted_wrt_append)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  P \\<sigma>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  P \\<sigma>\n\ngoal:\nNo subgoals!", "}"], ["proof (state)\nthis:\n  xs' = [] \\<or> \\<not> c \\<sigma> \\<Longrightarrow> P \\<sigma>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma FOREACHoi_rule[refine_vcg]:\n  assumes FIN: \"finite S\"\n  assumes I0: \"I S \\<sigma>0\"\n  assumes IP: \n    \"\\<And>x it \\<sigma>. \\<lbrakk> x\\<in>it; it\\<subseteq>S; I it \\<sigma>; \\<forall>y\\<in>it - {x}. R x y;\n                \\<forall>y\\<in>S - it. R y x \\<rbrakk> \\<Longrightarrow> f x \\<sigma> \\<le> SPEC (I (it-{x}))\"\n  assumes II1: \"\\<And>\\<sigma>. \\<lbrakk>I {} \\<sigma>\\<rbrakk> \\<Longrightarrow> P \\<sigma>\"\n  shows \"FOREACHoi R I S f \\<sigma>0 \\<le> SPEC P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. FOREACH\\<^sub>O\\<^bsup>R,I\\<^esup> S f \\<sigma>0 \\<le> SPEC P", "unfolding FOREACHoi_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. FOREACH\\<^sub>O\\<^sub>C\\<^bsup>R,I\\<^esup> S (\\<lambda>_. True) f\n     \\<sigma>0\n    \\<le> SPEC P", "by (rule FOREACHoci_rule) (simp_all add: assms)"], ["", "lemma FOREACHci_rule[refine_vcg]:\n  assumes FIN: \"finite S\"\n  assumes I0: \"I S \\<sigma>0\"\n  assumes IP: \n    \"\\<And>x it \\<sigma>. \\<lbrakk> x\\<in>it; it\\<subseteq>S; I it \\<sigma>; c \\<sigma> \\<rbrakk> \\<Longrightarrow> f x \\<sigma> \\<le> SPEC (I (it-{x}))\"\n  assumes II1: \"\\<And>\\<sigma>. \\<lbrakk>I {} \\<sigma>\\<rbrakk> \\<Longrightarrow> P \\<sigma>\"\n  assumes II2: \"\\<And>it \\<sigma>. \\<lbrakk> it\\<noteq>{}; it\\<subseteq>S; I it \\<sigma>; \\<not>c \\<sigma> \\<rbrakk> \\<Longrightarrow> P \\<sigma>\"\n  shows \"FOREACHci I S c f \\<sigma>0 \\<le> SPEC P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. FOREACH\\<^sub>C\\<^bsup>I\\<^esup> S c f \\<sigma>0 \\<le> SPEC P", "unfolding FOREACHci_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. FOREACH\\<^sub>O\\<^sub>C\\<^bsup>\\<lambda>_ _. True,I\\<^esup> S c f\n     \\<sigma>0\n    \\<le> SPEC P", "by (rule FOREACHoci_rule) (simp_all add: assms)"], ["", "subsubsection \\<open>Refinement:\\<close>"], ["", "text \\<open>\n  Refinement rule using a coupling invariant over sets of remaining\n  items and the state.\n\\<close>"], ["", "lemma FOREACHoci_refine_genR:\n  fixes \\<alpha> :: \"'S \\<Rightarrow> 'Sa\" \\<comment> \\<open>Abstraction mapping of elements\\<close>\n  fixes S :: \"'S set\" \\<comment> \\<open>Concrete set\\<close>\n  fixes S' :: \"'Sa set\" \\<comment> \\<open>Abstract set\\<close>\n  fixes \\<sigma>0 :: \"'\\<sigma>\"\n  fixes \\<sigma>0' :: \"'\\<sigma>a\"\n  fixes R :: \"(('S set \\<times> '\\<sigma>) \\<times> ('Sa set \\<times> '\\<sigma>a)) set\"\n  assumes INJ: \"inj_on \\<alpha> S\" \n  assumes REFS[simp]: \"S' = \\<alpha>`S\"\n  assumes RR_OK: \"\\<And>x y. \\<lbrakk>x \\<in> S; y \\<in> S; RR x y\\<rbrakk> \\<Longrightarrow> RR' (\\<alpha> x) (\\<alpha> y)\"\n  assumes REF0: \"((S,\\<sigma>0),(\\<alpha>`S,\\<sigma>0')) \\<in> R\"\n  assumes REFC: \"\\<And>it \\<sigma> it' \\<sigma>'. \\<lbrakk> \n    it\\<subseteq>S; it'\\<subseteq>S'; \\<Phi>' it' \\<sigma>'; \\<Phi> it \\<sigma>; \n    \\<forall>x\\<in>S-it. \\<forall>y\\<in>it. RR x y; \\<forall>x\\<in>S'-it'. \\<forall>y\\<in>it'. RR' x y;\n    it'=\\<alpha>`it; ((it,\\<sigma>),(it',\\<sigma>'))\\<in>R\n  \\<rbrakk> \\<Longrightarrow> c \\<sigma> \\<longleftrightarrow> c' \\<sigma>'\"\n  assumes REFPHI: \"\\<And>it \\<sigma> it' \\<sigma>'. \\<lbrakk> \n    it\\<subseteq>S; it'\\<subseteq>S'; \\<Phi>' it' \\<sigma>';\n    \\<forall>x\\<in>S-it. \\<forall>y\\<in>it. RR x y; \\<forall>x\\<in>S'-it'. \\<forall>y\\<in>it'. RR' x y;\n    it'=\\<alpha>`it; ((it,\\<sigma>),(it',\\<sigma>'))\\<in>R\n  \\<rbrakk> \\<Longrightarrow> \\<Phi> it \\<sigma>\"\n  assumes REFSTEP: \"\\<And>x it \\<sigma> x' it' \\<sigma>'. \\<lbrakk>\n    it\\<subseteq>S; it'\\<subseteq>S'; \\<Phi> it \\<sigma>; \\<Phi>' it' \\<sigma>';\n    \\<forall>x\\<in>S-it. \\<forall>y\\<in>it. RR x y; \\<forall>x\\<in>S'-it'. \\<forall>y\\<in>it'. RR' x y;\n    x'=\\<alpha> x; it'=\\<alpha>`it; ((it,\\<sigma>),(it',\\<sigma>'))\\<in>R;\n    x\\<in>it; \\<forall>y\\<in>it-{x}. RR x y;\n    x'\\<in>it'; \\<forall>y'\\<in>it'-{x'}. RR' x' y';\n    c \\<sigma>; c' \\<sigma>'\n  \\<rbrakk> \\<Longrightarrow> f x \\<sigma> \n    \\<le> \\<Down>({(\\<sigma>, \\<sigma>'). ((it-{x},\\<sigma>),(it'-{x'},\\<sigma>'))\\<in>R}) (f' x' \\<sigma>')\"\n  assumes REF_R_DONE: \"\\<And>\\<sigma> \\<sigma>'. \\<lbrakk> \\<Phi> {} \\<sigma>; \\<Phi>' {} \\<sigma>'; (({},\\<sigma>),({},\\<sigma>'))\\<in>R \\<rbrakk> \n    \\<Longrightarrow> (\\<sigma>,\\<sigma>')\\<in>R'\"\n  assumes REF_R_BRK: \"\\<And>it \\<sigma> it' \\<sigma>'. \\<lbrakk> \n    it\\<subseteq>S; it'\\<subseteq>S'; \\<Phi> it \\<sigma>; \\<Phi>' it' \\<sigma>';\n    \\<forall>x\\<in>S-it. \\<forall>y\\<in>it. RR x y; \\<forall>x\\<in>S'-it'. \\<forall>y\\<in>it'. RR' x y;\n    it'=\\<alpha>`it; ((it,\\<sigma>),(it',\\<sigma>'))\\<in>R;\n    it\\<noteq>{}; it'\\<noteq>{};\n    \\<not>c \\<sigma>; \\<not>c' \\<sigma>'\n  \\<rbrakk> \\<Longrightarrow> (\\<sigma>,\\<sigma>')\\<in>R'\"\n  shows \"FOREACHoci RR \\<Phi> S c f \\<sigma>0 \\<le> \\<Down>R' (FOREACHoci RR' \\<Phi>' S' c' f' \\<sigma>0')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. FOREACH\\<^sub>O\\<^sub>C\\<^bsup>RR,\\<Phi>\\<^esup> S c f \\<sigma>0\n    \\<le> \\<Down> R'\n           (FOREACH\\<^sub>O\\<^sub>C\\<^bsup>RR',\\<Phi>'\\<^esup> S' c' f'\n             \\<sigma>0')", "(* TODO: Clean up this mess !!! *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. FOREACH\\<^sub>O\\<^sub>C\\<^bsup>RR,\\<Phi>\\<^esup> S c f \\<sigma>0\n    \\<le> \\<Down> R'\n           (FOREACH\\<^sub>O\\<^sub>C\\<^bsup>RR',\\<Phi>'\\<^esup> S' c' f'\n             \\<sigma>0')", "supply [[simproc del: defined_all]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. FOREACH\\<^sub>O\\<^sub>C\\<^bsup>RR,\\<Phi>\\<^esup> S c f \\<sigma>0\n    \\<le> \\<Down> R'\n           (FOREACH\\<^sub>O\\<^sub>C\\<^bsup>RR',\\<Phi>'\\<^esup> S' c' f'\n             \\<sigma>0')", "unfolding FOREACHoci_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ASSERT (finite S) \\<bind>\n    (\\<lambda>_.\n        SPEC\n         (\\<lambda>xs.\n             distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs) \\<bind>\n        (\\<lambda>xs.\n            WHILE\\<^sub>T\\<^bsup>\\<lambda>(it, \\<sigma>).\n                                    \\<exists>xs'.\n xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>\\<^esup>\n             (FOREACH_cond c) (FOREACH_body f) (xs, \\<sigma>0) \\<bind>\n            (\\<lambda>(uu_, \\<sigma>). RETURN \\<sigma>)))\n    \\<le> \\<Down> R'\n           (ASSERT (finite S') \\<bind>\n            (\\<lambda>_.\n                SPEC\n                 (\\<lambda>xs.\n                     distinct xs \\<and>\n                     S' = set xs \\<and> sorted_wrt RR' xs) \\<bind>\n                (\\<lambda>xs.\n                    WHILE\\<^sub>T\\<^bsup>\\<lambda>(it, \\<sigma>).\n      \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>\\<^esup>\n                     (FOREACH_cond c') (FOREACH_body f')\n                     (xs, \\<sigma>0') \\<bind>\n                    (\\<lambda>(uu_, \\<sigma>). RETURN \\<sigma>))))", "apply (refine_rcg WHILEIT_refine_genR[where \n    R'=\"{((xs,\\<sigma>),(xs',\\<sigma>')) . \n      xs'=map \\<alpha> xs \\<and> \n      set xs \\<subseteq> S \\<and> set xs' \\<subseteq> S' \\<and>\n      (\\<forall>x\\<in>S - set xs. \\<forall>y\\<in>set xs. RR x y) \\<and>\n      (\\<forall>x\\<in>S' - set xs'. \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n      ((set xs,\\<sigma>),(set xs',\\<sigma>')) \\<in> R }\"\n    ])"], ["proof (prove)\ngoal (8 subgoals):\n 1. finite S' \\<Longrightarrow> finite S\n 2. \\<lbrakk>finite S'; finite S\\<rbrakk>\n    \\<Longrightarrow> SPEC\n                       (\\<lambda>xs.\n                           distinct xs \\<and>\n                           S = set xs \\<and> sorted_wrt RR xs)\n                      \\<le> \\<Down> ?R'2\n                             (SPEC\n                               (\\<lambda>xs.\n                                   distinct xs \\<and>\n                                   S' = set xs \\<and> sorted_wrt RR' xs))\n 3. \\<And>xs xsa.\n       \\<lbrakk>finite S'; finite S; (xs, xsa) \\<in> ?R'2;\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        case (xsa, \\<sigma>0') of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'.\n             xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> ((xs, \\<sigma>0), xsa, \\<sigma>0')\n                         \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n                                xs' = map \\<alpha> xs \\<and>\n                                set xs \\<subseteq> S \\<and>\n                                set xs' \\<subseteq> S' \\<and>\n                                (\\<forall>x\\<in>S - set xs.\n                                    \\<forall>y\\<in>set xs. RR x y) \\<and>\n                                (\\<forall>x\\<in>S' - set xs'.\n                                    \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n                                ((set xs, \\<sigma>), set xs', \\<sigma>')\n                                \\<in> R}\n 4. \\<And>xs xsa x x' x1 x2.\n       \\<lbrakk>finite S'; finite S; (xs, xsa) \\<in> ?R'2;\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>;\n        x = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs'.\n                            xs = xs' @ x1 \\<and> \\<Phi> (set x1) x2\n 5. \\<And>xs xsa x x'.\n       \\<lbrakk>finite S'; finite S; (xs, xsa) \\<in> ?R'2;\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n        case x of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'.\n             xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> FOREACH_cond c x = FOREACH_cond c' x'\n 6. \\<And>xs xsa x x'.\n       \\<lbrakk>finite S'; finite S; (xs, xsa) \\<in> ?R'2;\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n        FOREACH_cond c x; FOREACH_cond c' x';\n        case x of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'.\n             xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> FOREACH_body f x\n                         \\<le> \\<Down>\n                                {((xs, \\<sigma>), xs', \\<sigma>').\n                                 xs' = map \\<alpha> xs \\<and>\n                                 set xs \\<subseteq> S \\<and>\n                                 set xs' \\<subseteq> S' \\<and>\n                                 (\\<forall>x\\<in>S - set xs.\n                                     \\<forall>y\\<in>set xs. RR x y) \\<and>\n                                 (\\<forall>x\\<in>S' - set xs'.\n                                     \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n                                 ((set xs, \\<sigma>), set xs', \\<sigma>')\n                                 \\<in> R}\n                                (FOREACH_body f' x')\n 7. \\<And>xs xsa x x'.\n       \\<lbrakk>finite S'; finite S; (xs, xsa) \\<in> ?R'2;\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n        \\<not> FOREACH_cond c x; \\<not> FOREACH_cond c' x';\n        case x of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'.\n             xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> (x, x') \\<in> ?R'3 xs xsa\n 8. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>finite S'; finite S; (xs, xsa) \\<in> ?R'2;\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x') \\<in> ?R'3 xs xsa; x' = (x1, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> (x2a, x2) \\<in> R'", "using REFS INJ"], ["proof (prove)\nusing this:\n  S' = \\<alpha> ` S\n  inj_on \\<alpha> S\n\ngoal (8 subgoals):\n 1. finite S' \\<Longrightarrow> finite S\n 2. \\<lbrakk>finite S'; finite S\\<rbrakk>\n    \\<Longrightarrow> SPEC\n                       (\\<lambda>xs.\n                           distinct xs \\<and>\n                           S = set xs \\<and> sorted_wrt RR xs)\n                      \\<le> \\<Down> ?R'2\n                             (SPEC\n                               (\\<lambda>xs.\n                                   distinct xs \\<and>\n                                   S' = set xs \\<and> sorted_wrt RR' xs))\n 3. \\<And>xs xsa.\n       \\<lbrakk>finite S'; finite S; (xs, xsa) \\<in> ?R'2;\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        case (xsa, \\<sigma>0') of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'.\n             xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> ((xs, \\<sigma>0), xsa, \\<sigma>0')\n                         \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n                                xs' = map \\<alpha> xs \\<and>\n                                set xs \\<subseteq> S \\<and>\n                                set xs' \\<subseteq> S' \\<and>\n                                (\\<forall>x\\<in>S - set xs.\n                                    \\<forall>y\\<in>set xs. RR x y) \\<and>\n                                (\\<forall>x\\<in>S' - set xs'.\n                                    \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n                                ((set xs, \\<sigma>), set xs', \\<sigma>')\n                                \\<in> R}\n 4. \\<And>xs xsa x x' x1 x2.\n       \\<lbrakk>finite S'; finite S; (xs, xsa) \\<in> ?R'2;\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>;\n        x = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs'.\n                            xs = xs' @ x1 \\<and> \\<Phi> (set x1) x2\n 5. \\<And>xs xsa x x'.\n       \\<lbrakk>finite S'; finite S; (xs, xsa) \\<in> ?R'2;\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n        case x of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'.\n             xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> FOREACH_cond c x = FOREACH_cond c' x'\n 6. \\<And>xs xsa x x'.\n       \\<lbrakk>finite S'; finite S; (xs, xsa) \\<in> ?R'2;\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n        FOREACH_cond c x; FOREACH_cond c' x';\n        case x of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'.\n             xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> FOREACH_body f x\n                         \\<le> \\<Down>\n                                {((xs, \\<sigma>), xs', \\<sigma>').\n                                 xs' = map \\<alpha> xs \\<and>\n                                 set xs \\<subseteq> S \\<and>\n                                 set xs' \\<subseteq> S' \\<and>\n                                 (\\<forall>x\\<in>S - set xs.\n                                     \\<forall>y\\<in>set xs. RR x y) \\<and>\n                                 (\\<forall>x\\<in>S' - set xs'.\n                                     \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n                                 ((set xs, \\<sigma>), set xs', \\<sigma>')\n                                 \\<in> R}\n                                (FOREACH_body f' x')\n 7. \\<And>xs xsa x x'.\n       \\<lbrakk>finite S'; finite S; (xs, xsa) \\<in> ?R'2;\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n        \\<not> FOREACH_cond c x; \\<not> FOREACH_cond c' x';\n        case x of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'.\n             xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> (x, x') \\<in> ?R'3 xs xsa\n 8. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>finite S'; finite S; (xs, xsa) \\<in> ?R'2;\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x') \\<in> ?R'3 xs xsa; x' = (x1, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> (x2a, x2) \\<in> R'", "apply (auto dest: finite_imageD) []"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<lbrakk>finite S'; finite S\\<rbrakk>\n    \\<Longrightarrow> SPEC\n                       (\\<lambda>xs.\n                           distinct xs \\<and>\n                           S = set xs \\<and> sorted_wrt RR xs)\n                      \\<le> \\<Down> ?R'2\n                             (SPEC\n                               (\\<lambda>xs.\n                                   distinct xs \\<and>\n                                   S' = set xs \\<and> sorted_wrt RR' xs))\n 2. \\<And>xs xsa.\n       \\<lbrakk>finite S'; finite S; (xs, xsa) \\<in> ?R'2;\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        case (xsa, \\<sigma>0') of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'.\n             xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> ((xs, \\<sigma>0), xsa, \\<sigma>0')\n                         \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n                                xs' = map \\<alpha> xs \\<and>\n                                set xs \\<subseteq> S \\<and>\n                                set xs' \\<subseteq> S' \\<and>\n                                (\\<forall>x\\<in>S - set xs.\n                                    \\<forall>y\\<in>set xs. RR x y) \\<and>\n                                (\\<forall>x\\<in>S' - set xs'.\n                                    \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n                                ((set xs, \\<sigma>), set xs', \\<sigma>')\n                                \\<in> R}\n 3. \\<And>xs xsa x x' x1 x2.\n       \\<lbrakk>finite S'; finite S; (xs, xsa) \\<in> ?R'2;\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>;\n        x = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs'.\n                            xs = xs' @ x1 \\<and> \\<Phi> (set x1) x2\n 4. \\<And>xs xsa x x'.\n       \\<lbrakk>finite S'; finite S; (xs, xsa) \\<in> ?R'2;\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n        case x of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'.\n             xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> FOREACH_cond c x = FOREACH_cond c' x'\n 5. \\<And>xs xsa x x'.\n       \\<lbrakk>finite S'; finite S; (xs, xsa) \\<in> ?R'2;\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n        FOREACH_cond c x; FOREACH_cond c' x';\n        case x of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'.\n             xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> FOREACH_body f x\n                         \\<le> \\<Down>\n                                {((xs, \\<sigma>), xs', \\<sigma>').\n                                 xs' = map \\<alpha> xs \\<and>\n                                 set xs \\<subseteq> S \\<and>\n                                 set xs' \\<subseteq> S' \\<and>\n                                 (\\<forall>x\\<in>S - set xs.\n                                     \\<forall>y\\<in>set xs. RR x y) \\<and>\n                                 (\\<forall>x\\<in>S' - set xs'.\n                                     \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n                                 ((set xs, \\<sigma>), set xs', \\<sigma>')\n                                 \\<in> R}\n                                (FOREACH_body f' x')\n 6. \\<And>xs xsa x x'.\n       \\<lbrakk>finite S'; finite S; (xs, xsa) \\<in> ?R'2;\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n        \\<not> FOREACH_cond c x; \\<not> FOREACH_cond c' x';\n        case x of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'.\n             xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> (x, x') \\<in> ?R'3 xs xsa\n 7. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>finite S'; finite S; (xs, xsa) \\<in> ?R'2;\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x') \\<in> ?R'3 xs xsa; x' = (x1, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> (x2a, x2) \\<in> R'", "apply (rule intro_prgR[where R=\"{(xs,xs') . xs'=map \\<alpha> xs }\"])"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<lbrakk>finite S'; finite S\\<rbrakk>\n    \\<Longrightarrow> SPEC\n                       (\\<lambda>xs.\n                           distinct xs \\<and>\n                           S = set xs \\<and> sorted_wrt RR xs)\n                      \\<le> \\<Down> {(xs, xs'). xs' = map \\<alpha> xs}\n                             (SPEC\n                               (\\<lambda>xs.\n                                   distinct xs \\<and>\n                                   S' = set xs \\<and> sorted_wrt RR' xs))\n 2. \\<And>xs xsa.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        case (xsa, \\<sigma>0') of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'.\n             xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> ((xs, \\<sigma>0), xsa, \\<sigma>0')\n                         \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n                                xs' = map \\<alpha> xs \\<and>\n                                set xs \\<subseteq> S \\<and>\n                                set xs' \\<subseteq> S' \\<and>\n                                (\\<forall>x\\<in>S - set xs.\n                                    \\<forall>y\\<in>set xs. RR x y) \\<and>\n                                (\\<forall>x\\<in>S' - set xs'.\n                                    \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n                                ((set xs, \\<sigma>), set xs', \\<sigma>')\n                                \\<in> R}\n 3. \\<And>xs xsa x x' x1 x2.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>;\n        x = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs'.\n                            xs = xs' @ x1 \\<and> \\<Phi> (set x1) x2\n 4. \\<And>xs xsa x x'.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n        case x of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'.\n             xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> FOREACH_cond c x = FOREACH_cond c' x'\n 5. \\<And>xs xsa x x'.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n        FOREACH_cond c x; FOREACH_cond c' x';\n        case x of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'.\n             xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> FOREACH_body f x\n                         \\<le> \\<Down>\n                                {((xs, \\<sigma>), xs', \\<sigma>').\n                                 xs' = map \\<alpha> xs \\<and>\n                                 set xs \\<subseteq> S \\<and>\n                                 set xs' \\<subseteq> S' \\<and>\n                                 (\\<forall>x\\<in>S - set xs.\n                                     \\<forall>y\\<in>set xs. RR x y) \\<and>\n                                 (\\<forall>x\\<in>S' - set xs'.\n                                     \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n                                 ((set xs, \\<sigma>), set xs', \\<sigma>')\n                                 \\<in> R}\n                                (FOREACH_body f' x')\n 6. \\<And>xs xsa x x'.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n        \\<not> FOREACH_cond c x; \\<not> FOREACH_cond c' x';\n        case x of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'.\n             xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> (x, x') \\<in> ?R'3 xs xsa\n 7. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x') \\<in> ?R'3 xs xsa; x' = (x1, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> (x2a, x2) \\<in> R'", "apply (rule SPEC_refine)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<lbrakk>finite S'; finite S\\<rbrakk>\n    \\<Longrightarrow> SPEC\n                       (\\<lambda>xs.\n                           distinct xs \\<and>\n                           S = set xs \\<and> sorted_wrt RR xs)\n                      \\<le> SPEC\n                             (\\<lambda>x.\n                                 \\<exists>x'.\n                                    (x, x')\n                                    \\<in> {(xs, xs').\n     xs' = map \\<alpha> xs} \\<and>\n                                    distinct x' \\<and>\n                                    S' = set x' \\<and> sorted_wrt RR' x')\n 2. \\<And>xs xsa.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        case (xsa, \\<sigma>0') of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'.\n             xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> ((xs, \\<sigma>0), xsa, \\<sigma>0')\n                         \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n                                xs' = map \\<alpha> xs \\<and>\n                                set xs \\<subseteq> S \\<and>\n                                set xs' \\<subseteq> S' \\<and>\n                                (\\<forall>x\\<in>S - set xs.\n                                    \\<forall>y\\<in>set xs. RR x y) \\<and>\n                                (\\<forall>x\\<in>S' - set xs'.\n                                    \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n                                ((set xs, \\<sigma>), set xs', \\<sigma>')\n                                \\<in> R}\n 3. \\<And>xs xsa x x' x1 x2.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>;\n        x = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs'.\n                            xs = xs' @ x1 \\<and> \\<Phi> (set x1) x2\n 4. \\<And>xs xsa x x'.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n        case x of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'.\n             xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> FOREACH_cond c x = FOREACH_cond c' x'\n 5. \\<And>xs xsa x x'.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n        FOREACH_cond c x; FOREACH_cond c' x';\n        case x of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'.\n             xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> FOREACH_body f x\n                         \\<le> \\<Down>\n                                {((xs, \\<sigma>), xs', \\<sigma>').\n                                 xs' = map \\<alpha> xs \\<and>\n                                 set xs \\<subseteq> S \\<and>\n                                 set xs' \\<subseteq> S' \\<and>\n                                 (\\<forall>x\\<in>S - set xs.\n                                     \\<forall>y\\<in>set xs. RR x y) \\<and>\n                                 (\\<forall>x\\<in>S' - set xs'.\n                                     \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n                                 ((set xs, \\<sigma>), set xs', \\<sigma>')\n                                 \\<in> R}\n                                (FOREACH_body f' x')\n 6. \\<And>xs xsa x x'.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n        \\<not> FOREACH_cond c x; \\<not> FOREACH_cond c' x';\n        case x of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'.\n             xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> (x, x') \\<in> ?R'3 xs xsa\n 7. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x') \\<in> ?R'3 xs xsa; x' = (x1, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> (x2a, x2) \\<in> R'", "using INJ RR_OK"], ["proof (prove)\nusing this:\n  inj_on \\<alpha> S\n  \\<lbrakk>?x \\<in> S; ?y \\<in> S; RR ?x ?y\\<rbrakk>\n  \\<Longrightarrow> RR' (\\<alpha> ?x) (\\<alpha> ?y)\n\ngoal (7 subgoals):\n 1. \\<lbrakk>finite S'; finite S\\<rbrakk>\n    \\<Longrightarrow> SPEC\n                       (\\<lambda>xs.\n                           distinct xs \\<and>\n                           S = set xs \\<and> sorted_wrt RR xs)\n                      \\<le> SPEC\n                             (\\<lambda>x.\n                                 \\<exists>x'.\n                                    (x, x')\n                                    \\<in> {(xs, xs').\n     xs' = map \\<alpha> xs} \\<and>\n                                    distinct x' \\<and>\n                                    S' = set x' \\<and> sorted_wrt RR' x')\n 2. \\<And>xs xsa.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        case (xsa, \\<sigma>0') of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'.\n             xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> ((xs, \\<sigma>0), xsa, \\<sigma>0')\n                         \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n                                xs' = map \\<alpha> xs \\<and>\n                                set xs \\<subseteq> S \\<and>\n                                set xs' \\<subseteq> S' \\<and>\n                                (\\<forall>x\\<in>S - set xs.\n                                    \\<forall>y\\<in>set xs. RR x y) \\<and>\n                                (\\<forall>x\\<in>S' - set xs'.\n                                    \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n                                ((set xs, \\<sigma>), set xs', \\<sigma>')\n                                \\<in> R}\n 3. \\<And>xs xsa x x' x1 x2.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>;\n        x = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs'.\n                            xs = xs' @ x1 \\<and> \\<Phi> (set x1) x2\n 4. \\<And>xs xsa x x'.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n        case x of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'.\n             xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> FOREACH_cond c x = FOREACH_cond c' x'\n 5. \\<And>xs xsa x x'.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n        FOREACH_cond c x; FOREACH_cond c' x';\n        case x of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'.\n             xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> FOREACH_body f x\n                         \\<le> \\<Down>\n                                {((xs, \\<sigma>), xs', \\<sigma>').\n                                 xs' = map \\<alpha> xs \\<and>\n                                 set xs \\<subseteq> S \\<and>\n                                 set xs' \\<subseteq> S' \\<and>\n                                 (\\<forall>x\\<in>S - set xs.\n                                     \\<forall>y\\<in>set xs. RR x y) \\<and>\n                                 (\\<forall>x\\<in>S' - set xs'.\n                                     \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n                                 ((set xs, \\<sigma>), set xs', \\<sigma>')\n                                 \\<in> R}\n                                (FOREACH_body f' x')\n 6. \\<And>xs xsa x x'.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n        \\<not> FOREACH_cond c x; \\<not> FOREACH_cond c' x';\n        case x of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'.\n             xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> (x, x') \\<in> ?R'3 xs xsa\n 7. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x') \\<in> ?R'3 xs xsa; x' = (x1, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> (x2a, x2) \\<in> R'", "apply (auto \n    simp add: distinct_map sorted_wrt_map \n    intro: sorted_wrt_mono_rel[of _ RR]) []"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>xs xsa.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        case (xsa, \\<sigma>0') of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'.\n             xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> ((xs, \\<sigma>0), xsa, \\<sigma>0')\n                         \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n                                xs' = map \\<alpha> xs \\<and>\n                                set xs \\<subseteq> S \\<and>\n                                set xs' \\<subseteq> S' \\<and>\n                                (\\<forall>x\\<in>S - set xs.\n                                    \\<forall>y\\<in>set xs. RR x y) \\<and>\n                                (\\<forall>x\\<in>S' - set xs'.\n                                    \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n                                ((set xs, \\<sigma>), set xs', \\<sigma>')\n                                \\<in> R}\n 2. \\<And>xs xsa x x' x1 x2.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>;\n        x = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs'.\n                            xs = xs' @ x1 \\<and> \\<Phi> (set x1) x2\n 3. \\<And>xs xsa x x'.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n        case x of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'.\n             xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> FOREACH_cond c x = FOREACH_cond c' x'\n 4. \\<And>xs xsa x x'.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n        FOREACH_cond c x; FOREACH_cond c' x';\n        case x of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'.\n             xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> FOREACH_body f x\n                         \\<le> \\<Down>\n                                {((xs, \\<sigma>), xs', \\<sigma>').\n                                 xs' = map \\<alpha> xs \\<and>\n                                 set xs \\<subseteq> S \\<and>\n                                 set xs' \\<subseteq> S' \\<and>\n                                 (\\<forall>x\\<in>S - set xs.\n                                     \\<forall>y\\<in>set xs. RR x y) \\<and>\n                                 (\\<forall>x\\<in>S' - set xs'.\n                                     \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n                                 ((set xs, \\<sigma>), set xs', \\<sigma>')\n                                 \\<in> R}\n                                (FOREACH_body f' x')\n 5. \\<And>xs xsa x x'.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n        \\<not> FOREACH_cond c x; \\<not> FOREACH_cond c' x';\n        case x of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'.\n             xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> (x, x') \\<in> ?R'3 xs xsa\n 6. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x') \\<in> ?R'3 xs xsa; x' = (x1, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> (x2a, x2) \\<in> R'", "using REF0"], ["proof (prove)\nusing this:\n  ((S, \\<sigma>0), \\<alpha> ` S, \\<sigma>0') \\<in> R\n\ngoal (6 subgoals):\n 1. \\<And>xs xsa.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        case (xsa, \\<sigma>0') of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'.\n             xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> ((xs, \\<sigma>0), xsa, \\<sigma>0')\n                         \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n                                xs' = map \\<alpha> xs \\<and>\n                                set xs \\<subseteq> S \\<and>\n                                set xs' \\<subseteq> S' \\<and>\n                                (\\<forall>x\\<in>S - set xs.\n                                    \\<forall>y\\<in>set xs. RR x y) \\<and>\n                                (\\<forall>x\\<in>S' - set xs'.\n                                    \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n                                ((set xs, \\<sigma>), set xs', \\<sigma>')\n                                \\<in> R}\n 2. \\<And>xs xsa x x' x1 x2.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>;\n        x = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs'.\n                            xs = xs' @ x1 \\<and> \\<Phi> (set x1) x2\n 3. \\<And>xs xsa x x'.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n        case x of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'.\n             xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> FOREACH_cond c x = FOREACH_cond c' x'\n 4. \\<And>xs xsa x x'.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n        FOREACH_cond c x; FOREACH_cond c' x';\n        case x of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'.\n             xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> FOREACH_body f x\n                         \\<le> \\<Down>\n                                {((xs, \\<sigma>), xs', \\<sigma>').\n                                 xs' = map \\<alpha> xs \\<and>\n                                 set xs \\<subseteq> S \\<and>\n                                 set xs' \\<subseteq> S' \\<and>\n                                 (\\<forall>x\\<in>S - set xs.\n                                     \\<forall>y\\<in>set xs. RR x y) \\<and>\n                                 (\\<forall>x\\<in>S' - set xs'.\n                                     \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n                                 ((set xs, \\<sigma>), set xs', \\<sigma>')\n                                 \\<in> R}\n                                (FOREACH_body f' x')\n 5. \\<And>xs xsa x x'.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n        \\<not> FOREACH_cond c x; \\<not> FOREACH_cond c' x';\n        case x of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'.\n             xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> (x, x') \\<in> ?R'3 xs xsa\n 6. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x') \\<in> ?R'3 xs xsa; x' = (x1, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> (x2a, x2) \\<in> R'", "apply auto []"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>xs xsa x x' x1 x2.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>;\n        x = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs'.\n                            xs = xs' @ x1 \\<and> \\<Phi> (set x1) x2\n 2. \\<And>xs xsa x x'.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n        case x of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'.\n             xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> FOREACH_cond c x = FOREACH_cond c' x'\n 3. \\<And>xs xsa x x'.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n        FOREACH_cond c x; FOREACH_cond c' x';\n        case x of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'.\n             xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> FOREACH_body f x\n                         \\<le> \\<Down>\n                                {((xs, \\<sigma>), xs', \\<sigma>').\n                                 xs' = map \\<alpha> xs \\<and>\n                                 set xs \\<subseteq> S \\<and>\n                                 set xs' \\<subseteq> S' \\<and>\n                                 (\\<forall>x\\<in>S - set xs.\n                                     \\<forall>y\\<in>set xs. RR x y) \\<and>\n                                 (\\<forall>x\\<in>S' - set xs'.\n                                     \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n                                 ((set xs, \\<sigma>), set xs', \\<sigma>')\n                                 \\<in> R}\n                                (FOREACH_body f' x')\n 4. \\<And>xs xsa x x'.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n        \\<not> FOREACH_cond c x; \\<not> FOREACH_cond c' x';\n        case x of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'.\n             xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> (x, x') \\<in> ?R'3 xs xsa\n 5. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x') \\<in> ?R'3 xs xsa; x' = (x1, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> (x2a, x2) \\<in> R'", "apply simp"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>xs xsa x x' x1 x2.\n       \\<lbrakk>xsa = map \\<alpha> xs;\n        distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs;\n        distinct (map \\<alpha> xs) \\<and> sorted_wrt RR' (map \\<alpha> xs);\n        case x' of\n        (xs', \\<sigma>') \\<Rightarrow>\n          xs' = map \\<alpha> x1 \\<and>\n          set x1 \\<subseteq> set xs \\<and>\n          set xs' \\<subseteq> \\<alpha> ` set xs \\<and>\n          (\\<forall>x\\<in>set xs - set x1.\n              \\<forall>xa\\<in>set x1. RR x xa) \\<and>\n          (\\<forall>x\\<in>\\<alpha> ` set xs - set xs'.\n              \\<forall>xa\\<in>set xs'. RR' x xa) \\<and>\n          ((set x1, x2), set xs', \\<sigma>') \\<in> R;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          (\\<exists>xs'. map \\<alpha> xs = xs' @ it) \\<and>\n          \\<Phi>' (set it) \\<sigma>;\n        x = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>xs'. xs = xs' @ x1) \\<and>\n                         \\<Phi> (set x1) x2\n 2. \\<And>xs xsa x x'.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n        case x of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'.\n             xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> FOREACH_cond c x = FOREACH_cond c' x'\n 3. \\<And>xs xsa x x'.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n        FOREACH_cond c x; FOREACH_cond c' x';\n        case x of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'.\n             xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> FOREACH_body f x\n                         \\<le> \\<Down>\n                                {((xs, \\<sigma>), xs', \\<sigma>').\n                                 xs' = map \\<alpha> xs \\<and>\n                                 set xs \\<subseteq> S \\<and>\n                                 set xs' \\<subseteq> S' \\<and>\n                                 (\\<forall>x\\<in>S - set xs.\n                                     \\<forall>y\\<in>set xs. RR x y) \\<and>\n                                 (\\<forall>x\\<in>S' - set xs'.\n                                     \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n                                 ((set xs, \\<sigma>), set xs', \\<sigma>')\n                                 \\<in> R}\n                                (FOREACH_body f' x')\n 4. \\<And>xs xsa x x'.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n        \\<not> FOREACH_cond c x; \\<not> FOREACH_cond c' x';\n        case x of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'.\n             xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> (x, x') \\<in> ?R'3 xs xsa\n 5. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x') \\<in> ?R'3 xs xsa; x' = (x1, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> (x2a, x2) \\<in> R'", "apply (rule conjI)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>xs xsa x x' x1 x2.\n       \\<lbrakk>xsa = map \\<alpha> xs;\n        distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs;\n        distinct (map \\<alpha> xs) \\<and> sorted_wrt RR' (map \\<alpha> xs);\n        case x' of\n        (xs', \\<sigma>') \\<Rightarrow>\n          xs' = map \\<alpha> x1 \\<and>\n          set x1 \\<subseteq> set xs \\<and>\n          set xs' \\<subseteq> \\<alpha> ` set xs \\<and>\n          (\\<forall>x\\<in>set xs - set x1.\n              \\<forall>xa\\<in>set x1. RR x xa) \\<and>\n          (\\<forall>x\\<in>\\<alpha> ` set xs - set xs'.\n              \\<forall>xa\\<in>set xs'. RR' x xa) \\<and>\n          ((set x1, x2), set xs', \\<sigma>') \\<in> R;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          (\\<exists>xs'. map \\<alpha> xs = xs' @ it) \\<and>\n          \\<Phi>' (set it) \\<sigma>;\n        x = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs'. xs = xs' @ x1\n 2. \\<And>xs xsa x x' x1 x2.\n       \\<lbrakk>xsa = map \\<alpha> xs;\n        distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs;\n        distinct (map \\<alpha> xs) \\<and> sorted_wrt RR' (map \\<alpha> xs);\n        case x' of\n        (xs', \\<sigma>') \\<Rightarrow>\n          xs' = map \\<alpha> x1 \\<and>\n          set x1 \\<subseteq> set xs \\<and>\n          set xs' \\<subseteq> \\<alpha> ` set xs \\<and>\n          (\\<forall>x\\<in>set xs - set x1.\n              \\<forall>xa\\<in>set x1. RR x xa) \\<and>\n          (\\<forall>x\\<in>\\<alpha> ` set xs - set xs'.\n              \\<forall>xa\\<in>set xs'. RR' x xa) \\<and>\n          ((set x1, x2), set xs', \\<sigma>') \\<in> R;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          (\\<exists>xs'. map \\<alpha> xs = xs' @ it) \\<and>\n          \\<Phi>' (set it) \\<sigma>;\n        x = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> (set x1) x2\n 3. \\<And>xs xsa x x'.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n        case x of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'.\n             xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> FOREACH_cond c x = FOREACH_cond c' x'\n 4. \\<And>xs xsa x x'.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n        FOREACH_cond c x; FOREACH_cond c' x';\n        case x of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'.\n             xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> FOREACH_body f x\n                         \\<le> \\<Down>\n                                {((xs, \\<sigma>), xs', \\<sigma>').\n                                 xs' = map \\<alpha> xs \\<and>\n                                 set xs \\<subseteq> S \\<and>\n                                 set xs' \\<subseteq> S' \\<and>\n                                 (\\<forall>x\\<in>S - set xs.\n                                     \\<forall>y\\<in>set xs. RR x y) \\<and>\n                                 (\\<forall>x\\<in>S' - set xs'.\n                                     \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n                                 ((set xs, \\<sigma>), set xs', \\<sigma>')\n                                 \\<in> R}\n                                (FOREACH_body f' x')\n 5. \\<And>xs xsa x x'.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n        \\<not> FOREACH_cond c x; \\<not> FOREACH_cond c' x';\n        case x of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'.\n             xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> (x, x') \\<in> ?R'3 xs xsa\n 6. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x') \\<in> ?R'3 xs xsa; x' = (x1, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> (x2a, x2) \\<in> R'", "using INJ"], ["proof (prove)\nusing this:\n  inj_on \\<alpha> S\n\ngoal (6 subgoals):\n 1. \\<And>xs xsa x x' x1 x2.\n       \\<lbrakk>xsa = map \\<alpha> xs;\n        distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs;\n        distinct (map \\<alpha> xs) \\<and> sorted_wrt RR' (map \\<alpha> xs);\n        case x' of\n        (xs', \\<sigma>') \\<Rightarrow>\n          xs' = map \\<alpha> x1 \\<and>\n          set x1 \\<subseteq> set xs \\<and>\n          set xs' \\<subseteq> \\<alpha> ` set xs \\<and>\n          (\\<forall>x\\<in>set xs - set x1.\n              \\<forall>xa\\<in>set x1. RR x xa) \\<and>\n          (\\<forall>x\\<in>\\<alpha> ` set xs - set xs'.\n              \\<forall>xa\\<in>set xs'. RR' x xa) \\<and>\n          ((set x1, x2), set xs', \\<sigma>') \\<in> R;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          (\\<exists>xs'. map \\<alpha> xs = xs' @ it) \\<and>\n          \\<Phi>' (set it) \\<sigma>;\n        x = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs'. xs = xs' @ x1\n 2. \\<And>xs xsa x x' x1 x2.\n       \\<lbrakk>xsa = map \\<alpha> xs;\n        distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs;\n        distinct (map \\<alpha> xs) \\<and> sorted_wrt RR' (map \\<alpha> xs);\n        case x' of\n        (xs', \\<sigma>') \\<Rightarrow>\n          xs' = map \\<alpha> x1 \\<and>\n          set x1 \\<subseteq> set xs \\<and>\n          set xs' \\<subseteq> \\<alpha> ` set xs \\<and>\n          (\\<forall>x\\<in>set xs - set x1.\n              \\<forall>xa\\<in>set x1. RR x xa) \\<and>\n          (\\<forall>x\\<in>\\<alpha> ` set xs - set xs'.\n              \\<forall>xa\\<in>set xs'. RR' x xa) \\<and>\n          ((set x1, x2), set xs', \\<sigma>') \\<in> R;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          (\\<exists>xs'. map \\<alpha> xs = xs' @ it) \\<and>\n          \\<Phi>' (set it) \\<sigma>;\n        x = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> (set x1) x2\n 3. \\<And>xs xsa x x'.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n        case x of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'.\n             xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> FOREACH_cond c x = FOREACH_cond c' x'\n 4. \\<And>xs xsa x x'.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n        FOREACH_cond c x; FOREACH_cond c' x';\n        case x of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'.\n             xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> FOREACH_body f x\n                         \\<le> \\<Down>\n                                {((xs, \\<sigma>), xs', \\<sigma>').\n                                 xs' = map \\<alpha> xs \\<and>\n                                 set xs \\<subseteq> S \\<and>\n                                 set xs' \\<subseteq> S' \\<and>\n                                 (\\<forall>x\\<in>S - set xs.\n                                     \\<forall>y\\<in>set xs. RR x y) \\<and>\n                                 (\\<forall>x\\<in>S' - set xs'.\n                                     \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n                                 ((set xs, \\<sigma>), set xs', \\<sigma>')\n                                 \\<in> R}\n                                (FOREACH_body f' x')\n 5. \\<And>xs xsa x x'.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n        \\<not> FOREACH_cond c x; \\<not> FOREACH_cond c' x';\n        case x of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'.\n             xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> (x, x') \\<in> ?R'3 xs xsa\n 6. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x') \\<in> ?R'3 xs xsa; x' = (x1, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> (x2a, x2) \\<in> R'", "apply clarsimp"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>xs ba x1 x2 xs'.\n       \\<lbrakk>inj_on \\<alpha> (set xs); distinct xs;\n        sorted_wrt RR' (xs' @ map \\<alpha> x1);\n        \\<Phi>' (\\<alpha> ` set x1) ba;\n        map \\<alpha> xs = xs' @ map \\<alpha> x1; S = set xs;\n        sorted_wrt RR xs; set x1 \\<subseteq> set xs;\n        \\<alpha> ` set x1 \\<subseteq> \\<alpha> ` set xs;\n        \\<forall>x\\<in>set xs - set x1. \\<forall>xa\\<in>set x1. RR x xa;\n        \\<forall>x\\<in>\\<alpha> ` set xs - \\<alpha> ` set x1.\n           \\<forall>xa\\<in>set x1. RR' x (\\<alpha> xa);\n        ((set x1, x2), \\<alpha> ` set x1, ba) \\<in> R; distinct xs';\n        distinct (map \\<alpha> x1);\n        set xs' \\<inter> \\<alpha> ` set x1 = {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs'. xs = xs' @ x1\n 2. \\<And>xs xsa x x' x1 x2.\n       \\<lbrakk>xsa = map \\<alpha> xs;\n        distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs;\n        distinct (map \\<alpha> xs) \\<and> sorted_wrt RR' (map \\<alpha> xs);\n        case x' of\n        (xs', \\<sigma>') \\<Rightarrow>\n          xs' = map \\<alpha> x1 \\<and>\n          set x1 \\<subseteq> set xs \\<and>\n          set xs' \\<subseteq> \\<alpha> ` set xs \\<and>\n          (\\<forall>x\\<in>set xs - set x1.\n              \\<forall>xa\\<in>set x1. RR x xa) \\<and>\n          (\\<forall>x\\<in>\\<alpha> ` set xs - set xs'.\n              \\<forall>xa\\<in>set xs'. RR' x xa) \\<and>\n          ((set x1, x2), set xs', \\<sigma>') \\<in> R;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          (\\<exists>xs'. map \\<alpha> xs = xs' @ it) \\<and>\n          \\<Phi>' (set it) \\<sigma>;\n        x = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> (set x1) x2\n 3. \\<And>xs xsa x x'.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n        case x of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'.\n             xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> FOREACH_cond c x = FOREACH_cond c' x'\n 4. \\<And>xs xsa x x'.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n        FOREACH_cond c x; FOREACH_cond c' x';\n        case x of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'.\n             xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> FOREACH_body f x\n                         \\<le> \\<Down>\n                                {((xs, \\<sigma>), xs', \\<sigma>').\n                                 xs' = map \\<alpha> xs \\<and>\n                                 set xs \\<subseteq> S \\<and>\n                                 set xs' \\<subseteq> S' \\<and>\n                                 (\\<forall>x\\<in>S - set xs.\n                                     \\<forall>y\\<in>set xs. RR x y) \\<and>\n                                 (\\<forall>x\\<in>S' - set xs'.\n                                     \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n                                 ((set xs, \\<sigma>), set xs', \\<sigma>')\n                                 \\<in> R}\n                                (FOREACH_body f' x')\n 5. \\<And>xs xsa x x'.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n        \\<not> FOREACH_cond c x; \\<not> FOREACH_cond c' x';\n        case x of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'.\n             xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> (x, x') \\<in> ?R'3 xs xsa\n 6. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x') \\<in> ?R'3 xs xsa; x' = (x1, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> (x2a, x2) \\<in> R'", "apply (erule map_eq_appendE)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>xs ba x1 x2 xs' l l'.\n       \\<lbrakk>inj_on \\<alpha> (set xs); distinct xs;\n        sorted_wrt RR' (xs' @ map \\<alpha> x1);\n        \\<Phi>' (\\<alpha> ` set x1) ba; S = set xs; sorted_wrt RR xs;\n        set x1 \\<subseteq> set xs;\n        \\<alpha> ` set x1 \\<subseteq> \\<alpha> ` set xs;\n        \\<forall>x\\<in>set xs - set x1. \\<forall>xa\\<in>set x1. RR x xa;\n        \\<forall>x\\<in>\\<alpha> ` set xs - \\<alpha> ` set x1.\n           \\<forall>xa\\<in>set x1. RR' x (\\<alpha> xa);\n        ((set x1, x2), \\<alpha> ` set x1, ba) \\<in> R; distinct xs';\n        distinct (map \\<alpha> x1); set xs' \\<inter> \\<alpha> ` set x1 = {};\n        xs = l @ l'; map \\<alpha> l = xs';\n        map \\<alpha> l' = map \\<alpha> x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs'. xs = xs' @ x1\n 2. \\<And>xs xsa x x' x1 x2.\n       \\<lbrakk>xsa = map \\<alpha> xs;\n        distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs;\n        distinct (map \\<alpha> xs) \\<and> sorted_wrt RR' (map \\<alpha> xs);\n        case x' of\n        (xs', \\<sigma>') \\<Rightarrow>\n          xs' = map \\<alpha> x1 \\<and>\n          set x1 \\<subseteq> set xs \\<and>\n          set xs' \\<subseteq> \\<alpha> ` set xs \\<and>\n          (\\<forall>x\\<in>set xs - set x1.\n              \\<forall>xa\\<in>set x1. RR x xa) \\<and>\n          (\\<forall>x\\<in>\\<alpha> ` set xs - set xs'.\n              \\<forall>xa\\<in>set xs'. RR' x xa) \\<and>\n          ((set x1, x2), set xs', \\<sigma>') \\<in> R;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          (\\<exists>xs'. map \\<alpha> xs = xs' @ it) \\<and>\n          \\<Phi>' (set it) \\<sigma>;\n        x = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> (set x1) x2\n 3. \\<And>xs xsa x x'.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n        case x of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'.\n             xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> FOREACH_cond c x = FOREACH_cond c' x'\n 4. \\<And>xs xsa x x'.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n        FOREACH_cond c x; FOREACH_cond c' x';\n        case x of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'.\n             xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> FOREACH_body f x\n                         \\<le> \\<Down>\n                                {((xs, \\<sigma>), xs', \\<sigma>').\n                                 xs' = map \\<alpha> xs \\<and>\n                                 set xs \\<subseteq> S \\<and>\n                                 set xs' \\<subseteq> S' \\<and>\n                                 (\\<forall>x\\<in>S - set xs.\n                                     \\<forall>y\\<in>set xs. RR x y) \\<and>\n                                 (\\<forall>x\\<in>S' - set xs'.\n                                     \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n                                 ((set xs, \\<sigma>), set xs', \\<sigma>')\n                                 \\<in> R}\n                                (FOREACH_body f' x')\n 5. \\<And>xs xsa x x'.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n        \\<not> FOREACH_cond c x; \\<not> FOREACH_cond c' x';\n        case x of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'.\n             xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> (x, x') \\<in> ?R'3 xs xsa\n 6. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x') \\<in> ?R'3 xs xsa; x' = (x1, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> (x2a, x2) \\<in> R'", "apply clarsimp"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>ba x1 x2 l l'.\n       \\<lbrakk>inj_on \\<alpha> (set l \\<union> set l');\n        sorted_wrt RR' (map \\<alpha> l @ map \\<alpha> x1);\n        \\<Phi>' (\\<alpha> ` set x1) ba; S = set l \\<union> set l';\n        sorted_wrt RR (l @ l'); set x1 \\<subseteq> set l \\<union> set l';\n        \\<alpha> ` set x1 \\<subseteq> \\<alpha> ` (set l \\<union> set l');\n        \\<forall>x\\<in>set l \\<union> set l' - set x1.\n           \\<forall>xa\\<in>set x1. RR x xa;\n        \\<forall>x\\<in>\\<alpha> ` (set l \\<union> set l') -\n                       \\<alpha> ` set x1.\n           \\<forall>xa\\<in>set x1. RR' x (\\<alpha> xa);\n        ((set x1, x2), \\<alpha> ` set x1, ba) \\<in> R;\n        distinct (map \\<alpha> l); distinct (map \\<alpha> x1);\n        \\<alpha> ` set l \\<inter> \\<alpha> ` set x1 = {};\n        map \\<alpha> l' = map \\<alpha> x1; distinct l; distinct l';\n        set l \\<inter> set l' = {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs'. l @ l' = xs' @ x1\n 2. \\<And>xs xsa x x' x1 x2.\n       \\<lbrakk>xsa = map \\<alpha> xs;\n        distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs;\n        distinct (map \\<alpha> xs) \\<and> sorted_wrt RR' (map \\<alpha> xs);\n        case x' of\n        (xs', \\<sigma>') \\<Rightarrow>\n          xs' = map \\<alpha> x1 \\<and>\n          set x1 \\<subseteq> set xs \\<and>\n          set xs' \\<subseteq> \\<alpha> ` set xs \\<and>\n          (\\<forall>x\\<in>set xs - set x1.\n              \\<forall>xa\\<in>set x1. RR x xa) \\<and>\n          (\\<forall>x\\<in>\\<alpha> ` set xs - set xs'.\n              \\<forall>xa\\<in>set xs'. RR' x xa) \\<and>\n          ((set x1, x2), set xs', \\<sigma>') \\<in> R;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          (\\<exists>xs'. map \\<alpha> xs = xs' @ it) \\<and>\n          \\<Phi>' (set it) \\<sigma>;\n        x = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> (set x1) x2\n 3. \\<And>xs xsa x x'.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n        case x of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'.\n             xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> FOREACH_cond c x = FOREACH_cond c' x'\n 4. \\<And>xs xsa x x'.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n        FOREACH_cond c x; FOREACH_cond c' x';\n        case x of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'.\n             xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> FOREACH_body f x\n                         \\<le> \\<Down>\n                                {((xs, \\<sigma>), xs', \\<sigma>').\n                                 xs' = map \\<alpha> xs \\<and>\n                                 set xs \\<subseteq> S \\<and>\n                                 set xs' \\<subseteq> S' \\<and>\n                                 (\\<forall>x\\<in>S - set xs.\n                                     \\<forall>y\\<in>set xs. RR x y) \\<and>\n                                 (\\<forall>x\\<in>S' - set xs'.\n                                     \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n                                 ((set xs, \\<sigma>), set xs', \\<sigma>')\n                                 \\<in> R}\n                                (FOREACH_body f' x')\n 5. \\<And>xs xsa x x'.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n        \\<not> FOREACH_cond c x; \\<not> FOREACH_cond c' x';\n        case x of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'.\n             xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> (x, x') \\<in> ?R'3 xs xsa\n 6. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x') \\<in> ?R'3 xs xsa; x' = (x1, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> (x2a, x2) \\<in> R'", "apply (rule_tac x=l in exI)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>ba x1 x2 l l'.\n       \\<lbrakk>inj_on \\<alpha> (set l \\<union> set l');\n        sorted_wrt RR' (map \\<alpha> l @ map \\<alpha> x1);\n        \\<Phi>' (\\<alpha> ` set x1) ba; S = set l \\<union> set l';\n        sorted_wrt RR (l @ l'); set x1 \\<subseteq> set l \\<union> set l';\n        \\<alpha> ` set x1 \\<subseteq> \\<alpha> ` (set l \\<union> set l');\n        \\<forall>x\\<in>set l \\<union> set l' - set x1.\n           \\<forall>xa\\<in>set x1. RR x xa;\n        \\<forall>x\\<in>\\<alpha> ` (set l \\<union> set l') -\n                       \\<alpha> ` set x1.\n           \\<forall>xa\\<in>set x1. RR' x (\\<alpha> xa);\n        ((set x1, x2), \\<alpha> ` set x1, ba) \\<in> R;\n        distinct (map \\<alpha> l); distinct (map \\<alpha> x1);\n        \\<alpha> ` set l \\<inter> \\<alpha> ` set x1 = {};\n        map \\<alpha> l' = map \\<alpha> x1; distinct l; distinct l';\n        set l \\<inter> set l' = {}\\<rbrakk>\n       \\<Longrightarrow> l @ l' = l @ x1\n 2. \\<And>xs xsa x x' x1 x2.\n       \\<lbrakk>xsa = map \\<alpha> xs;\n        distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs;\n        distinct (map \\<alpha> xs) \\<and> sorted_wrt RR' (map \\<alpha> xs);\n        case x' of\n        (xs', \\<sigma>') \\<Rightarrow>\n          xs' = map \\<alpha> x1 \\<and>\n          set x1 \\<subseteq> set xs \\<and>\n          set xs' \\<subseteq> \\<alpha> ` set xs \\<and>\n          (\\<forall>x\\<in>set xs - set x1.\n              \\<forall>xa\\<in>set x1. RR x xa) \\<and>\n          (\\<forall>x\\<in>\\<alpha> ` set xs - set xs'.\n              \\<forall>xa\\<in>set xs'. RR' x xa) \\<and>\n          ((set x1, x2), set xs', \\<sigma>') \\<in> R;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          (\\<exists>xs'. map \\<alpha> xs = xs' @ it) \\<and>\n          \\<Phi>' (set it) \\<sigma>;\n        x = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> (set x1) x2\n 3. \\<And>xs xsa x x'.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n        case x of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'.\n             xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> FOREACH_cond c x = FOREACH_cond c' x'\n 4. \\<And>xs xsa x x'.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n        FOREACH_cond c x; FOREACH_cond c' x';\n        case x of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'.\n             xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> FOREACH_body f x\n                         \\<le> \\<Down>\n                                {((xs, \\<sigma>), xs', \\<sigma>').\n                                 xs' = map \\<alpha> xs \\<and>\n                                 set xs \\<subseteq> S \\<and>\n                                 set xs' \\<subseteq> S' \\<and>\n                                 (\\<forall>x\\<in>S - set xs.\n                                     \\<forall>y\\<in>set xs. RR x y) \\<and>\n                                 (\\<forall>x\\<in>S' - set xs'.\n                                     \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n                                 ((set xs, \\<sigma>), set xs', \\<sigma>')\n                                 \\<in> R}\n                                (FOREACH_body f' x')\n 5. \\<And>xs xsa x x'.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n        \\<not> FOREACH_cond c x; \\<not> FOREACH_cond c' x';\n        case x of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'.\n             xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> (x, x') \\<in> ?R'3 xs xsa\n 6. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x') \\<in> ?R'3 xs xsa; x' = (x1, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> (x2a, x2) \\<in> R'", "apply simp"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>ba x1 x2 l l'.\n       \\<lbrakk>inj_on \\<alpha> (set l \\<union> set l');\n        sorted_wrt RR' (map \\<alpha> l @ map \\<alpha> x1);\n        \\<Phi>' (\\<alpha> ` set x1) ba; S = set l \\<union> set l';\n        sorted_wrt RR (l @ l'); set x1 \\<subseteq> set l \\<union> set l';\n        \\<alpha> ` set x1 \\<subseteq> \\<alpha> ` (set l \\<union> set l');\n        \\<forall>x\\<in>set l \\<union> set l' - set x1.\n           \\<forall>xa\\<in>set x1. RR x xa;\n        \\<forall>x\\<in>\\<alpha> ` (set l \\<union> set l') -\n                       \\<alpha> ` set x1.\n           \\<forall>xa\\<in>set x1. RR' x (\\<alpha> xa);\n        ((set x1, x2), \\<alpha> ` set x1, ba) \\<in> R;\n        distinct (map \\<alpha> l); distinct (map \\<alpha> x1);\n        \\<alpha> ` set l \\<inter> \\<alpha> ` set x1 = {};\n        map \\<alpha> l' = map \\<alpha> x1; distinct l; distinct l';\n        set l \\<inter> set l' = {}\\<rbrakk>\n       \\<Longrightarrow> l' = x1\n 2. \\<And>xs xsa x x' x1 x2.\n       \\<lbrakk>xsa = map \\<alpha> xs;\n        distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs;\n        distinct (map \\<alpha> xs) \\<and> sorted_wrt RR' (map \\<alpha> xs);\n        case x' of\n        (xs', \\<sigma>') \\<Rightarrow>\n          xs' = map \\<alpha> x1 \\<and>\n          set x1 \\<subseteq> set xs \\<and>\n          set xs' \\<subseteq> \\<alpha> ` set xs \\<and>\n          (\\<forall>x\\<in>set xs - set x1.\n              \\<forall>xa\\<in>set x1. RR x xa) \\<and>\n          (\\<forall>x\\<in>\\<alpha> ` set xs - set xs'.\n              \\<forall>xa\\<in>set xs'. RR' x xa) \\<and>\n          ((set x1, x2), set xs', \\<sigma>') \\<in> R;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          (\\<exists>xs'. map \\<alpha> xs = xs' @ it) \\<and>\n          \\<Phi>' (set it) \\<sigma>;\n        x = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> (set x1) x2\n 3. \\<And>xs xsa x x'.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n        case x of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'.\n             xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> FOREACH_cond c x = FOREACH_cond c' x'\n 4. \\<And>xs xsa x x'.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n        FOREACH_cond c x; FOREACH_cond c' x';\n        case x of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'.\n             xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> FOREACH_body f x\n                         \\<le> \\<Down>\n                                {((xs, \\<sigma>), xs', \\<sigma>').\n                                 xs' = map \\<alpha> xs \\<and>\n                                 set xs \\<subseteq> S \\<and>\n                                 set xs' \\<subseteq> S' \\<and>\n                                 (\\<forall>x\\<in>S - set xs.\n                                     \\<forall>y\\<in>set xs. RR x y) \\<and>\n                                 (\\<forall>x\\<in>S' - set xs'.\n                                     \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n                                 ((set xs, \\<sigma>), set xs', \\<sigma>')\n                                 \\<in> R}\n                                (FOREACH_body f' x')\n 5. \\<And>xs xsa x x'.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n        \\<not> FOREACH_cond c x; \\<not> FOREACH_cond c' x';\n        case x of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'.\n             xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> (x, x') \\<in> ?R'3 xs xsa\n 6. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x') \\<in> ?R'3 xs xsa; x' = (x1, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> (x2a, x2) \\<in> R'", "apply (subst inj_on_map_eq_map[where f=\\<alpha>,symmetric])"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>ba x1 x2 l l'.\n       \\<lbrakk>inj_on \\<alpha> (set l \\<union> set l');\n        sorted_wrt RR' (map \\<alpha> l @ map \\<alpha> x1);\n        \\<Phi>' (\\<alpha> ` set x1) ba; S = set l \\<union> set l';\n        sorted_wrt RR (l @ l'); set x1 \\<subseteq> set l \\<union> set l';\n        \\<alpha> ` set x1 \\<subseteq> \\<alpha> ` (set l \\<union> set l');\n        \\<forall>x\\<in>set l \\<union> set l' - set x1.\n           \\<forall>xa\\<in>set x1. RR x xa;\n        \\<forall>x\\<in>\\<alpha> ` (set l \\<union> set l') -\n                       \\<alpha> ` set x1.\n           \\<forall>xa\\<in>set x1. RR' x (\\<alpha> xa);\n        ((set x1, x2), \\<alpha> ` set x1, ba) \\<in> R;\n        distinct (map \\<alpha> l); distinct (map \\<alpha> x1);\n        \\<alpha> ` set l \\<inter> \\<alpha> ` set x1 = {};\n        map \\<alpha> l' = map \\<alpha> x1; distinct l; distinct l';\n        set l \\<inter> set l' = {}\\<rbrakk>\n       \\<Longrightarrow> inj_on \\<alpha> (set l' \\<union> set x1)\n 2. \\<And>ba x1 x2 l l'.\n       \\<lbrakk>inj_on \\<alpha> (set l \\<union> set l');\n        sorted_wrt RR' (map \\<alpha> l @ map \\<alpha> x1);\n        \\<Phi>' (\\<alpha> ` set x1) ba; S = set l \\<union> set l';\n        sorted_wrt RR (l @ l'); set x1 \\<subseteq> set l \\<union> set l';\n        \\<alpha> ` set x1 \\<subseteq> \\<alpha> ` (set l \\<union> set l');\n        \\<forall>x\\<in>set l \\<union> set l' - set x1.\n           \\<forall>xa\\<in>set x1. RR x xa;\n        \\<forall>x\\<in>\\<alpha> ` (set l \\<union> set l') -\n                       \\<alpha> ` set x1.\n           \\<forall>xa\\<in>set x1. RR' x (\\<alpha> xa);\n        ((set x1, x2), \\<alpha> ` set x1, ba) \\<in> R;\n        distinct (map \\<alpha> l); distinct (map \\<alpha> x1);\n        \\<alpha> ` set l \\<inter> \\<alpha> ` set x1 = {};\n        map \\<alpha> l' = map \\<alpha> x1; distinct l; distinct l';\n        set l \\<inter> set l' = {}\\<rbrakk>\n       \\<Longrightarrow> map \\<alpha> l' = map \\<alpha> x1\n 3. \\<And>xs xsa x x' x1 x2.\n       \\<lbrakk>xsa = map \\<alpha> xs;\n        distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs;\n        distinct (map \\<alpha> xs) \\<and> sorted_wrt RR' (map \\<alpha> xs);\n        case x' of\n        (xs', \\<sigma>') \\<Rightarrow>\n          xs' = map \\<alpha> x1 \\<and>\n          set x1 \\<subseteq> set xs \\<and>\n          set xs' \\<subseteq> \\<alpha> ` set xs \\<and>\n          (\\<forall>x\\<in>set xs - set x1.\n              \\<forall>xa\\<in>set x1. RR x xa) \\<and>\n          (\\<forall>x\\<in>\\<alpha> ` set xs - set xs'.\n              \\<forall>xa\\<in>set xs'. RR' x xa) \\<and>\n          ((set x1, x2), set xs', \\<sigma>') \\<in> R;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          (\\<exists>xs'. map \\<alpha> xs = xs' @ it) \\<and>\n          \\<Phi>' (set it) \\<sigma>;\n        x = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> (set x1) x2\n 4. \\<And>xs xsa x x'.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n        case x of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'.\n             xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> FOREACH_cond c x = FOREACH_cond c' x'\n 5. \\<And>xs xsa x x'.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n        FOREACH_cond c x; FOREACH_cond c' x';\n        case x of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'.\n             xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> FOREACH_body f x\n                         \\<le> \\<Down>\n                                {((xs, \\<sigma>), xs', \\<sigma>').\n                                 xs' = map \\<alpha> xs \\<and>\n                                 set xs \\<subseteq> S \\<and>\n                                 set xs' \\<subseteq> S' \\<and>\n                                 (\\<forall>x\\<in>S - set xs.\n                                     \\<forall>y\\<in>set xs. RR x y) \\<and>\n                                 (\\<forall>x\\<in>S' - set xs'.\n                                     \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n                                 ((set xs, \\<sigma>), set xs', \\<sigma>')\n                                 \\<in> R}\n                                (FOREACH_body f' x')\n 6. \\<And>xs xsa x x'.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n        \\<not> FOREACH_cond c x; \\<not> FOREACH_cond c' x';\n        case x of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'.\n             xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> (x, x') \\<in> ?R'3 xs xsa\n 7. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x') \\<in> ?R'3 xs xsa; x' = (x1, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> (x2a, x2) \\<in> R'", "apply (rule subset_inj_on, assumption, blast)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>ba x1 x2 l l'.\n       \\<lbrakk>inj_on \\<alpha> (set l \\<union> set l');\n        sorted_wrt RR' (map \\<alpha> l @ map \\<alpha> x1);\n        \\<Phi>' (\\<alpha> ` set x1) ba; S = set l \\<union> set l';\n        sorted_wrt RR (l @ l'); set x1 \\<subseteq> set l \\<union> set l';\n        \\<alpha> ` set x1 \\<subseteq> \\<alpha> ` (set l \\<union> set l');\n        \\<forall>x\\<in>set l \\<union> set l' - set x1.\n           \\<forall>xa\\<in>set x1. RR x xa;\n        \\<forall>x\\<in>\\<alpha> ` (set l \\<union> set l') -\n                       \\<alpha> ` set x1.\n           \\<forall>xa\\<in>set x1. RR' x (\\<alpha> xa);\n        ((set x1, x2), \\<alpha> ` set x1, ba) \\<in> R;\n        distinct (map \\<alpha> l); distinct (map \\<alpha> x1);\n        \\<alpha> ` set l \\<inter> \\<alpha> ` set x1 = {};\n        map \\<alpha> l' = map \\<alpha> x1; distinct l; distinct l';\n        set l \\<inter> set l' = {}\\<rbrakk>\n       \\<Longrightarrow> map \\<alpha> l' = map \\<alpha> x1\n 2. \\<And>xs xsa x x' x1 x2.\n       \\<lbrakk>xsa = map \\<alpha> xs;\n        distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs;\n        distinct (map \\<alpha> xs) \\<and> sorted_wrt RR' (map \\<alpha> xs);\n        case x' of\n        (xs', \\<sigma>') \\<Rightarrow>\n          xs' = map \\<alpha> x1 \\<and>\n          set x1 \\<subseteq> set xs \\<and>\n          set xs' \\<subseteq> \\<alpha> ` set xs \\<and>\n          (\\<forall>x\\<in>set xs - set x1.\n              \\<forall>xa\\<in>set x1. RR x xa) \\<and>\n          (\\<forall>x\\<in>\\<alpha> ` set xs - set xs'.\n              \\<forall>xa\\<in>set xs'. RR' x xa) \\<and>\n          ((set x1, x2), set xs', \\<sigma>') \\<in> R;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          (\\<exists>xs'. map \\<alpha> xs = xs' @ it) \\<and>\n          \\<Phi>' (set it) \\<sigma>;\n        x = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> (set x1) x2\n 3. \\<And>xs xsa x x'.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n        case x of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'.\n             xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> FOREACH_cond c x = FOREACH_cond c' x'\n 4. \\<And>xs xsa x x'.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n        FOREACH_cond c x; FOREACH_cond c' x';\n        case x of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'.\n             xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> FOREACH_body f x\n                         \\<le> \\<Down>\n                                {((xs, \\<sigma>), xs', \\<sigma>').\n                                 xs' = map \\<alpha> xs \\<and>\n                                 set xs \\<subseteq> S \\<and>\n                                 set xs' \\<subseteq> S' \\<and>\n                                 (\\<forall>x\\<in>S - set xs.\n                                     \\<forall>y\\<in>set xs. RR x y) \\<and>\n                                 (\\<forall>x\\<in>S' - set xs'.\n                                     \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n                                 ((set xs, \\<sigma>), set xs', \\<sigma>')\n                                 \\<in> R}\n                                (FOREACH_body f' x')\n 5. \\<And>xs xsa x x'.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n        \\<not> FOREACH_cond c x; \\<not> FOREACH_cond c' x';\n        case x of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'.\n             xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> (x, x') \\<in> ?R'3 xs xsa\n 6. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x') \\<in> ?R'3 xs xsa; x' = (x1, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> (x2a, x2) \\<in> R'", "apply assumption"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>xs xsa x x' x1 x2.\n       \\<lbrakk>xsa = map \\<alpha> xs;\n        distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs;\n        distinct (map \\<alpha> xs) \\<and> sorted_wrt RR' (map \\<alpha> xs);\n        case x' of\n        (xs', \\<sigma>') \\<Rightarrow>\n          xs' = map \\<alpha> x1 \\<and>\n          set x1 \\<subseteq> set xs \\<and>\n          set xs' \\<subseteq> \\<alpha> ` set xs \\<and>\n          (\\<forall>x\\<in>set xs - set x1.\n              \\<forall>xa\\<in>set x1. RR x xa) \\<and>\n          (\\<forall>x\\<in>\\<alpha> ` set xs - set xs'.\n              \\<forall>xa\\<in>set xs'. RR' x xa) \\<and>\n          ((set x1, x2), set xs', \\<sigma>') \\<in> R;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          (\\<exists>xs'. map \\<alpha> xs = xs' @ it) \\<and>\n          \\<Phi>' (set it) \\<sigma>;\n        x = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> (set x1) x2\n 2. \\<And>xs xsa x x'.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n        case x of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'.\n             xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> FOREACH_cond c x = FOREACH_cond c' x'\n 3. \\<And>xs xsa x x'.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n        FOREACH_cond c x; FOREACH_cond c' x';\n        case x of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'.\n             xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> FOREACH_body f x\n                         \\<le> \\<Down>\n                                {((xs, \\<sigma>), xs', \\<sigma>').\n                                 xs' = map \\<alpha> xs \\<and>\n                                 set xs \\<subseteq> S \\<and>\n                                 set xs' \\<subseteq> S' \\<and>\n                                 (\\<forall>x\\<in>S - set xs.\n                                     \\<forall>y\\<in>set xs. RR x y) \\<and>\n                                 (\\<forall>x\\<in>S' - set xs'.\n                                     \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n                                 ((set xs, \\<sigma>), set xs', \\<sigma>')\n                                 \\<in> R}\n                                (FOREACH_body f' x')\n 4. \\<And>xs xsa x x'.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n        \\<not> FOREACH_cond c x; \\<not> FOREACH_cond c' x';\n        case x of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'.\n             xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> (x, x') \\<in> ?R'3 xs xsa\n 5. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x') \\<in> ?R'3 xs xsa; x' = (x1, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> (x2a, x2) \\<in> R'", "apply (simp split: prod.split_asm, elim conjE)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>x = (x1, x2); xsa = map \\<alpha> xs; distinct xs;\n        distinct (map \\<alpha> xs); sorted_wrt RR' (map \\<alpha> xs);\n        S = set xs; sorted_wrt RR xs; x' = (map \\<alpha> x1, x2a);\n        \\<exists>xs'. map \\<alpha> xs = xs' @ map \\<alpha> x1;\n        \\<Phi>' (\\<alpha> ` set x1) x2a; x1a = map \\<alpha> x1;\n        set x1 \\<subseteq> set xs; set x1a \\<subseteq> \\<alpha> ` set xs;\n        \\<forall>x\\<in>set xs - set x1. \\<forall>xa\\<in>set x1. RR x xa;\n        \\<forall>x\\<in>\\<alpha> ` set xs - set x1a.\n           \\<forall>xa\\<in>set x1a. RR' x xa;\n        ((set x1, x2), set x1a, x2a) \\<in> R\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> (set x1) x2\n 2. \\<And>xs xsa x x'.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n        case x of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'.\n             xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> FOREACH_cond c x = FOREACH_cond c' x'\n 3. \\<And>xs xsa x x'.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n        FOREACH_cond c x; FOREACH_cond c' x';\n        case x of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'.\n             xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> FOREACH_body f x\n                         \\<le> \\<Down>\n                                {((xs, \\<sigma>), xs', \\<sigma>').\n                                 xs' = map \\<alpha> xs \\<and>\n                                 set xs \\<subseteq> S \\<and>\n                                 set xs' \\<subseteq> S' \\<and>\n                                 (\\<forall>x\\<in>S - set xs.\n                                     \\<forall>y\\<in>set xs. RR x y) \\<and>\n                                 (\\<forall>x\\<in>S' - set xs'.\n                                     \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n                                 ((set xs, \\<sigma>), set xs', \\<sigma>')\n                                 \\<in> R}\n                                (FOREACH_body f' x')\n 4. \\<And>xs xsa x x'.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n        \\<not> FOREACH_cond c x; \\<not> FOREACH_cond c' x';\n        case x of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'.\n             xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> (x, x') \\<in> ?R'3 xs xsa\n 5. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x') \\<in> ?R'3 xs xsa; x' = (x1, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> (x2a, x2) \\<in> R'", "apply (rule REFPHI, auto) []"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>xs xsa x x'.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n        case x of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'.\n             xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> FOREACH_cond c x = FOREACH_cond c' x'\n 2. \\<And>xs xsa x x'.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n        FOREACH_cond c x; FOREACH_cond c' x';\n        case x of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'.\n             xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> FOREACH_body f x\n                         \\<le> \\<Down>\n                                {((xs, \\<sigma>), xs', \\<sigma>').\n                                 xs' = map \\<alpha> xs \\<and>\n                                 set xs \\<subseteq> S \\<and>\n                                 set xs' \\<subseteq> S' \\<and>\n                                 (\\<forall>x\\<in>S - set xs.\n                                     \\<forall>y\\<in>set xs. RR x y) \\<and>\n                                 (\\<forall>x\\<in>S' - set xs'.\n                                     \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n                                 ((set xs, \\<sigma>), set xs', \\<sigma>')\n                                 \\<in> R}\n                                (FOREACH_body f' x')\n 3. \\<And>xs xsa x x'.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n        \\<not> FOREACH_cond c x; \\<not> FOREACH_cond c' x';\n        case x of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'.\n             xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> (x, x') \\<in> ?R'3 xs xsa\n 4. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x') \\<in> ?R'3 xs xsa; x' = (x1, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> (x2a, x2) \\<in> R'", "apply (simp add: FOREACH_cond_def split: prod.split prod.split_asm, \n    intro allI impI conj_cong) []"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>xs xsa x x' x1 x2 x1a xs' x2a.\n       \\<lbrakk>xsa = map \\<alpha> xs' @ map \\<alpha> x1;\n        distinct xs' \\<and> distinct x1 \\<and> set xs' \\<inter> set x1 = {};\n        distinct (map \\<alpha> xs') \\<and>\n        distinct (map \\<alpha> x1) \\<and>\n        \\<alpha> ` set xs' \\<inter> \\<alpha> ` set x1 = {};\n        sorted_wrt RR' (map \\<alpha> xs' @ map \\<alpha> x1);\n        S = set xs' \\<union> set x1; sorted_wrt RR (xs' @ x1); x = (x1, x2);\n        x1a = map \\<alpha> x1 \\<and>\n        set x1a \\<subseteq> \\<alpha> ` (set xs' \\<union> set x1) \\<and>\n        (\\<forall>x\\<in>set xs' \\<union> set x1 - set x1.\n            \\<forall>xa\\<in>set x1. RR x xa) \\<and>\n        (\\<forall>x\\<in>\\<alpha> ` (set xs' \\<union> set x1) - set x1a.\n            \\<forall>xa\\<in>set x1a. RR' x xa) \\<and>\n        ((set x1, x2), set x1a, x2a) \\<in> R;\n        \\<Phi> (set x1) x2; xs = xs' @ x1; x' = (map \\<alpha> x1, x2a);\n        \\<Phi>' (\\<alpha> ` set x1) x2a\\<rbrakk>\n       \\<Longrightarrow> (x1 \\<noteq> []) = (x1 \\<noteq> [])\n 2. \\<And>xs xsa x x' x1 x2 x1a xs' x2a.\n       \\<lbrakk>xsa = map \\<alpha> xs' @ map \\<alpha> x1;\n        distinct xs' \\<and> distinct x1 \\<and> set xs' \\<inter> set x1 = {};\n        distinct (map \\<alpha> xs') \\<and>\n        distinct (map \\<alpha> x1) \\<and>\n        \\<alpha> ` set xs' \\<inter> \\<alpha> ` set x1 = {};\n        sorted_wrt RR' (map \\<alpha> xs' @ map \\<alpha> x1);\n        S = set xs' \\<union> set x1; sorted_wrt RR (xs' @ x1); x = (x1, x2);\n        x1a = map \\<alpha> x1 \\<and>\n        set x1a \\<subseteq> \\<alpha> ` (set xs' \\<union> set x1) \\<and>\n        (\\<forall>x\\<in>set xs' \\<union> set x1 - set x1.\n            \\<forall>xa\\<in>set x1. RR x xa) \\<and>\n        (\\<forall>x\\<in>\\<alpha> ` (set xs' \\<union> set x1) - set x1a.\n            \\<forall>xa\\<in>set x1a. RR' x xa) \\<and>\n        ((set x1, x2), set x1a, x2a) \\<in> R;\n        \\<Phi> (set x1) x2; xs = xs' @ x1; x' = (map \\<alpha> x1, x2a);\n        \\<Phi>' (\\<alpha> ` set x1) x2a; x1 \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> c x2 = c' x2a\n 3. \\<And>xs xsa x x'.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n        FOREACH_cond c x; FOREACH_cond c' x';\n        case x of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'.\n             xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> FOREACH_body f x\n                         \\<le> \\<Down>\n                                {((xs, \\<sigma>), xs', \\<sigma>').\n                                 xs' = map \\<alpha> xs \\<and>\n                                 set xs \\<subseteq> S \\<and>\n                                 set xs' \\<subseteq> S' \\<and>\n                                 (\\<forall>x\\<in>S - set xs.\n                                     \\<forall>y\\<in>set xs. RR x y) \\<and>\n                                 (\\<forall>x\\<in>S' - set xs'.\n                                     \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n                                 ((set xs, \\<sigma>), set xs', \\<sigma>')\n                                 \\<in> R}\n                                (FOREACH_body f' x')\n 4. \\<And>xs xsa x x'.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n        \\<not> FOREACH_cond c x; \\<not> FOREACH_cond c' x';\n        case x of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'.\n             xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> (x, x') \\<in> ?R'3 xs xsa\n 5. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x') \\<in> ?R'3 xs xsa; x' = (x1, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> (x2a, x2) \\<in> R'", "apply auto []"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>xs xsa x x' x1 x2 x1a xs' x2a.\n       \\<lbrakk>xsa = map \\<alpha> xs' @ map \\<alpha> x1;\n        distinct xs' \\<and> distinct x1 \\<and> set xs' \\<inter> set x1 = {};\n        distinct (map \\<alpha> xs') \\<and>\n        distinct (map \\<alpha> x1) \\<and>\n        \\<alpha> ` set xs' \\<inter> \\<alpha> ` set x1 = {};\n        sorted_wrt RR' (map \\<alpha> xs' @ map \\<alpha> x1);\n        S = set xs' \\<union> set x1; sorted_wrt RR (xs' @ x1); x = (x1, x2);\n        x1a = map \\<alpha> x1 \\<and>\n        set x1a \\<subseteq> \\<alpha> ` (set xs' \\<union> set x1) \\<and>\n        (\\<forall>x\\<in>set xs' \\<union> set x1 - set x1.\n            \\<forall>xa\\<in>set x1. RR x xa) \\<and>\n        (\\<forall>x\\<in>\\<alpha> ` (set xs' \\<union> set x1) - set x1a.\n            \\<forall>xa\\<in>set x1a. RR' x xa) \\<and>\n        ((set x1, x2), set x1a, x2a) \\<in> R;\n        \\<Phi> (set x1) x2; xs = xs' @ x1; x' = (map \\<alpha> x1, x2a);\n        \\<Phi>' (\\<alpha> ` set x1) x2a; x1 \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> c x2 = c' x2a\n 2. \\<And>xs xsa x x'.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n        FOREACH_cond c x; FOREACH_cond c' x';\n        case x of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'.\n             xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> FOREACH_body f x\n                         \\<le> \\<Down>\n                                {((xs, \\<sigma>), xs', \\<sigma>').\n                                 xs' = map \\<alpha> xs \\<and>\n                                 set xs \\<subseteq> S \\<and>\n                                 set xs' \\<subseteq> S' \\<and>\n                                 (\\<forall>x\\<in>S - set xs.\n                                     \\<forall>y\\<in>set xs. RR x y) \\<and>\n                                 (\\<forall>x\\<in>S' - set xs'.\n                                     \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n                                 ((set xs, \\<sigma>), set xs', \\<sigma>')\n                                 \\<in> R}\n                                (FOREACH_body f' x')\n 3. \\<And>xs xsa x x'.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n        \\<not> FOREACH_cond c x; \\<not> FOREACH_cond c' x';\n        case x of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'.\n             xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> (x, x') \\<in> ?R'3 xs xsa\n 4. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x') \\<in> ?R'3 xs xsa; x' = (x1, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> (x2a, x2) \\<in> R'", "apply (rule REFC, auto) []"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>xs xsa x x'.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n        FOREACH_cond c x; FOREACH_cond c' x';\n        case x of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'.\n             xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> FOREACH_body f x\n                         \\<le> \\<Down>\n                                {((xs, \\<sigma>), xs', \\<sigma>').\n                                 xs' = map \\<alpha> xs \\<and>\n                                 set xs \\<subseteq> S \\<and>\n                                 set xs' \\<subseteq> S' \\<and>\n                                 (\\<forall>x\\<in>S - set xs.\n                                     \\<forall>y\\<in>set xs. RR x y) \\<and>\n                                 (\\<forall>x\\<in>S' - set xs'.\n                                     \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n                                 ((set xs, \\<sigma>), set xs', \\<sigma>')\n                                 \\<in> R}\n                                (FOREACH_body f' x')\n 2. \\<And>xs xsa x x'.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n        \\<not> FOREACH_cond c x; \\<not> FOREACH_cond c' x';\n        case x of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'.\n             xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> (x, x') \\<in> ?R'3 xs xsa\n 3. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x') \\<in> ?R'3 xs xsa; x' = (x1, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> (x2a, x2) \\<in> R'", "unfolding FOREACH_body_def"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>xs xsa x x'.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n        FOREACH_cond c x; FOREACH_cond c' x';\n        case x of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'.\n             xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> (case x of\n                          (xs, \\<sigma>) \\<Rightarrow>\n                            let x = hd xs\n                            in f x \\<sigma> \\<bind>\n                               (\\<lambda>\\<sigma>'.\n                                   RETURN (tl xs, \\<sigma>')))\n                         \\<le> \\<Down>\n                                {((xs, \\<sigma>), xs', \\<sigma>').\n                                 xs' = map \\<alpha> xs \\<and>\n                                 set xs \\<subseteq> S \\<and>\n                                 set xs' \\<subseteq> S' \\<and>\n                                 (\\<forall>x\\<in>S - set xs.\n                                     \\<forall>y\\<in>set xs. RR x y) \\<and>\n                                 (\\<forall>x\\<in>S' - set xs'.\n                                     \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n                                 ((set xs, \\<sigma>), set xs', \\<sigma>')\n                                 \\<in> R}\n                                (case x' of\n                                 (xs, \\<sigma>) \\<Rightarrow>\n                                   let x = hd xs\n                                   in f' x \\<sigma> \\<bind>\n(\\<lambda>\\<sigma>'. RETURN (tl xs, \\<sigma>')))\n 2. \\<And>xs xsa x x'.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n        \\<not> FOREACH_cond c x; \\<not> FOREACH_cond c' x';\n        case x of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'.\n             xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> (x, x') \\<in> ?R'3 xs xsa\n 3. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x') \\<in> ?R'3 xs xsa; x' = (x1, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> (x2a, x2) \\<in> R'", "apply refine_rcg"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n        FOREACH_cond c x; FOREACH_cond c' x';\n        case x of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>;\n        x' = (x1, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> f (hd x1a) x2a\n                         \\<le> \\<Down> (?R'460 xs xsa x x' x1 x2 x1a x2a)\n                                (f' (hd x1) x2)\n 2. \\<And>xs xsa x x' x1 x2 x1a x2a \\<sigma>' \\<sigma>''.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n        FOREACH_cond c x; FOREACH_cond c' x';\n        case x of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>;\n        x' = (x1, x2); x = (x1a, x2a);\n        (\\<sigma>', \\<sigma>'')\n        \\<in> ?R'460 xs xsa x x' x1 x2 x1a x2a\\<rbrakk>\n       \\<Longrightarrow> ((tl x1a, \\<sigma>'), tl x1, \\<sigma>'')\n                         \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n                                xs' = map \\<alpha> xs \\<and>\n                                set xs \\<subseteq> S \\<and>\n                                set xs' \\<subseteq> S' \\<and>\n                                (\\<forall>x\\<in>S - set xs.\n                                    \\<forall>y\\<in>set xs. RR x y) \\<and>\n                                (\\<forall>x\\<in>S' - set xs'.\n                                    \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n                                ((set xs, \\<sigma>), set xs', \\<sigma>')\n                                \\<in> R}\n 3. \\<And>xs xsa x x'.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n        \\<not> FOREACH_cond c x; \\<not> FOREACH_cond c' x';\n        case x of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'.\n             xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> (x, x') \\<in> ?R'3 xs xsa\n 4. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x') \\<in> ?R'3 xs xsa; x' = (x1, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> (x2a, x2) \\<in> R'", "apply (rule REFSTEP) []"], ["proof (prove)\ngoal (18 subgoals):\n 1. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n        FOREACH_cond c x; FOREACH_cond c' x';\n        case x of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>;\n        x' = (x1, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> ?it463 xs xsa x x' x1 x2 x1a x2a \\<subseteq> S\n 2. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n        FOREACH_cond c x; FOREACH_cond c' x';\n        case x of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>;\n        x' = (x1, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> ?it'463 xs xsa x x' x1 x2 x1a x2a \\<subseteq> S'\n 3. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n        FOREACH_cond c x; FOREACH_cond c' x';\n        case x of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>;\n        x' = (x1, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> (?it463 xs xsa x x' x1 x2 x1a x2a) x2a\n 4. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n        FOREACH_cond c x; FOREACH_cond c' x';\n        case x of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>;\n        x' = (x1, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> \\<Phi>' (?it'463 xs xsa x x' x1 x2 x1a x2a) x2\n 5. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n        FOREACH_cond c x; FOREACH_cond c' x';\n        case x of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>;\n        x' = (x1, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>xa\\<in>S -\n   ?it463 xs xsa x x' x1 x2 x1a x2a.\n                            \\<forall>y\\<in>?it463 xs xsa x x' x1 x2 x1a x2a.\n                               RR xa y\n 6. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n        FOREACH_cond c x; FOREACH_cond c' x';\n        case x of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>;\n        x' = (x1, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>xa\\<in>S' -\n   ?it'463 xs xsa x x' x1 x2 x1a x2a.\n                            \\<forall>y\\<in>?it'463 xs xsa x x' x1 x2 x1a\n      x2a.\n                               RR' xa y\n 7. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n        FOREACH_cond c x; FOREACH_cond c' x';\n        case x of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>;\n        x' = (x1, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> hd x1 = \\<alpha> (hd x1a)\n 8. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n        FOREACH_cond c x; FOREACH_cond c' x';\n        case x of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>;\n        x' = (x1, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> ?it'463 xs xsa x x' x1 x2 x1a x2a =\n                         \\<alpha> ` ?it463 xs xsa x x' x1 x2 x1a x2a\n 9. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n        FOREACH_cond c x; FOREACH_cond c' x';\n        case x of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>;\n        x' = (x1, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> ((?it463 xs xsa x x' x1 x2 x1a x2a, x2a),\n                          ?it'463 xs xsa x x' x1 x2 x1a x2a, x2)\n                         \\<in> R\n 10. \\<And>xs xsa x x' x1 x2 x1a x2a.\n        \\<lbrakk>finite S'; finite S;\n         (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n         xs \\<in> {xs.\n                   distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n         xsa\n         \\<in> {xs.\n                distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n         (x, x')\n         \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n                xs' = map \\<alpha> xs \\<and>\n                set xs \\<subseteq> S \\<and>\n                set xs' \\<subseteq> S' \\<and>\n                (\\<forall>x\\<in>S - set xs.\n                    \\<forall>y\\<in>set xs. RR x y) \\<and>\n                (\\<forall>x\\<in>S' - set xs'.\n                    \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n                ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n         FOREACH_cond c x; FOREACH_cond c' x';\n         case x of\n         (it, \\<sigma>) \\<Rightarrow>\n           \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>;\n         case x' of\n         (it, \\<sigma>) \\<Rightarrow>\n           \\<exists>xs'. xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>;\n         x' = (x1, x2); x = (x1a, x2a)\\<rbrakk>\n        \\<Longrightarrow> hd x1a \\<in> ?it463 xs xsa x x' x1 x2 x1a x2a\nA total of 18 subgoals...", "prefer 3"], ["proof (prove)\ngoal (18 subgoals):\n 1. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n        FOREACH_cond c x; FOREACH_cond c' x';\n        case x of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>;\n        x' = (x1, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> (?it463 xs xsa x x' x1 x2 x1a x2a) x2a\n 2. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n        FOREACH_cond c x; FOREACH_cond c' x';\n        case x of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>;\n        x' = (x1, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> ?it463 xs xsa x x' x1 x2 x1a x2a \\<subseteq> S\n 3. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n        FOREACH_cond c x; FOREACH_cond c' x';\n        case x of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>;\n        x' = (x1, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> ?it'463 xs xsa x x' x1 x2 x1a x2a \\<subseteq> S'\n 4. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n        FOREACH_cond c x; FOREACH_cond c' x';\n        case x of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>;\n        x' = (x1, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> \\<Phi>' (?it'463 xs xsa x x' x1 x2 x1a x2a) x2\n 5. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n        FOREACH_cond c x; FOREACH_cond c' x';\n        case x of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>;\n        x' = (x1, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>xa\\<in>S -\n   ?it463 xs xsa x x' x1 x2 x1a x2a.\n                            \\<forall>y\\<in>?it463 xs xsa x x' x1 x2 x1a x2a.\n                               RR xa y\n 6. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n        FOREACH_cond c x; FOREACH_cond c' x';\n        case x of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>;\n        x' = (x1, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>xa\\<in>S' -\n   ?it'463 xs xsa x x' x1 x2 x1a x2a.\n                            \\<forall>y\\<in>?it'463 xs xsa x x' x1 x2 x1a\n      x2a.\n                               RR' xa y\n 7. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n        FOREACH_cond c x; FOREACH_cond c' x';\n        case x of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>;\n        x' = (x1, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> hd x1 = \\<alpha> (hd x1a)\n 8. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n        FOREACH_cond c x; FOREACH_cond c' x';\n        case x of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>;\n        x' = (x1, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> ?it'463 xs xsa x x' x1 x2 x1a x2a =\n                         \\<alpha> ` ?it463 xs xsa x x' x1 x2 x1a x2a\n 9. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n        FOREACH_cond c x; FOREACH_cond c' x';\n        case x of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>;\n        x' = (x1, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> ((?it463 xs xsa x x' x1 x2 x1a x2a, x2a),\n                          ?it'463 xs xsa x x' x1 x2 x1a x2a, x2)\n                         \\<in> R\n 10. \\<And>xs xsa x x' x1 x2 x1a x2a.\n        \\<lbrakk>finite S'; finite S;\n         (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n         xs \\<in> {xs.\n                   distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n         xsa\n         \\<in> {xs.\n                distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n         (x, x')\n         \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n                xs' = map \\<alpha> xs \\<and>\n                set xs \\<subseteq> S \\<and>\n                set xs' \\<subseteq> S' \\<and>\n                (\\<forall>x\\<in>S - set xs.\n                    \\<forall>y\\<in>set xs. RR x y) \\<and>\n                (\\<forall>x\\<in>S' - set xs'.\n                    \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n                ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n         FOREACH_cond c x; FOREACH_cond c' x';\n         case x of\n         (it, \\<sigma>) \\<Rightarrow>\n           \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>;\n         case x' of\n         (it, \\<sigma>) \\<Rightarrow>\n           \\<exists>xs'. xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>;\n         x' = (x1, x2); x = (x1a, x2a)\\<rbrakk>\n        \\<Longrightarrow> hd x1a \\<in> ?it463 xs xsa x x' x1 x2 x1a x2a\nA total of 18 subgoals...", "apply auto []"], ["proof (prove)\ngoal (17 subgoals):\n 1. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n        FOREACH_cond c x; FOREACH_cond c' x';\n        case x of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>;\n        x' = (x1, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> set x1a \\<subseteq> S\n 2. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n        FOREACH_cond c x; FOREACH_cond c' x';\n        case x of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>;\n        x' = (x1, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> ?it'463 xs xsa x x' x1 x2 x1a x2a \\<subseteq> S'\n 3. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n        FOREACH_cond c x; FOREACH_cond c' x';\n        case x of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>;\n        x' = (x1, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> \\<Phi>' (?it'463 xs xsa x x' x1 x2 x1a x2a) x2\n 4. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n        FOREACH_cond c x; FOREACH_cond c' x';\n        case x of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>;\n        x' = (x1, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x\\<in>S - set x1a.\n                            \\<forall>y\\<in>set x1a. RR x y\n 5. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n        FOREACH_cond c x; FOREACH_cond c' x';\n        case x of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>;\n        x' = (x1, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>xa\\<in>S' -\n   ?it'463 xs xsa x x' x1 x2 x1a x2a.\n                            \\<forall>y\\<in>?it'463 xs xsa x x' x1 x2 x1a\n      x2a.\n                               RR' xa y\n 6. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n        FOREACH_cond c x; FOREACH_cond c' x';\n        case x of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>;\n        x' = (x1, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> hd x1 = \\<alpha> (hd x1a)\n 7. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n        FOREACH_cond c x; FOREACH_cond c' x';\n        case x of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>;\n        x' = (x1, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> ?it'463 xs xsa x x' x1 x2 x1a x2a =\n                         \\<alpha> ` set x1a\n 8. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n        FOREACH_cond c x; FOREACH_cond c' x';\n        case x of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>;\n        x' = (x1, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> ((set x1a, x2a), ?it'463 xs xsa x x' x1 x2 x1a x2a,\n                          x2)\n                         \\<in> R\n 9. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n        FOREACH_cond c x; FOREACH_cond c' x';\n        case x of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>;\n        x' = (x1, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> hd x1a \\<in> set x1a\n 10. \\<And>xs xsa x x' x1 x2 x1a x2a.\n        \\<lbrakk>finite S'; finite S;\n         (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n         xs \\<in> {xs.\n                   distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n         xsa\n         \\<in> {xs.\n                distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n         (x, x')\n         \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n                xs' = map \\<alpha> xs \\<and>\n                set xs \\<subseteq> S \\<and>\n                set xs' \\<subseteq> S' \\<and>\n                (\\<forall>x\\<in>S - set xs.\n                    \\<forall>y\\<in>set xs. RR x y) \\<and>\n                (\\<forall>x\\<in>S' - set xs'.\n                    \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n                ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n         FOREACH_cond c x; FOREACH_cond c' x';\n         case x of\n         (it, \\<sigma>) \\<Rightarrow>\n           \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>;\n         case x' of\n         (it, \\<sigma>) \\<Rightarrow>\n           \\<exists>xs'. xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>;\n         x' = (x1, x2); x = (x1a, x2a)\\<rbrakk>\n        \\<Longrightarrow> \\<forall>y\\<in>set x1a - {hd x1a}. RR (hd x1a) y\nA total of 17 subgoals...", "prefer 3"], ["proof (prove)\ngoal (17 subgoals):\n 1. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n        FOREACH_cond c x; FOREACH_cond c' x';\n        case x of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>;\n        x' = (x1, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> \\<Phi>' (?it'463 xs xsa x x' x1 x2 x1a x2a) x2\n 2. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n        FOREACH_cond c x; FOREACH_cond c' x';\n        case x of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>;\n        x' = (x1, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> set x1a \\<subseteq> S\n 3. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n        FOREACH_cond c x; FOREACH_cond c' x';\n        case x of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>;\n        x' = (x1, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> ?it'463 xs xsa x x' x1 x2 x1a x2a \\<subseteq> S'\n 4. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n        FOREACH_cond c x; FOREACH_cond c' x';\n        case x of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>;\n        x' = (x1, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x\\<in>S - set x1a.\n                            \\<forall>y\\<in>set x1a. RR x y\n 5. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n        FOREACH_cond c x; FOREACH_cond c' x';\n        case x of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>;\n        x' = (x1, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>xa\\<in>S' -\n   ?it'463 xs xsa x x' x1 x2 x1a x2a.\n                            \\<forall>y\\<in>?it'463 xs xsa x x' x1 x2 x1a\n      x2a.\n                               RR' xa y\n 6. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n        FOREACH_cond c x; FOREACH_cond c' x';\n        case x of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>;\n        x' = (x1, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> hd x1 = \\<alpha> (hd x1a)\n 7. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n        FOREACH_cond c x; FOREACH_cond c' x';\n        case x of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>;\n        x' = (x1, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> ?it'463 xs xsa x x' x1 x2 x1a x2a =\n                         \\<alpha> ` set x1a\n 8. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n        FOREACH_cond c x; FOREACH_cond c' x';\n        case x of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>;\n        x' = (x1, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> ((set x1a, x2a), ?it'463 xs xsa x x' x1 x2 x1a x2a,\n                          x2)\n                         \\<in> R\n 9. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n        FOREACH_cond c x; FOREACH_cond c' x';\n        case x of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>;\n        x' = (x1, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> hd x1a \\<in> set x1a\n 10. \\<And>xs xsa x x' x1 x2 x1a x2a.\n        \\<lbrakk>finite S'; finite S;\n         (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n         xs \\<in> {xs.\n                   distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n         xsa\n         \\<in> {xs.\n                distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n         (x, x')\n         \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n                xs' = map \\<alpha> xs \\<and>\n                set xs \\<subseteq> S \\<and>\n                set xs' \\<subseteq> S' \\<and>\n                (\\<forall>x\\<in>S - set xs.\n                    \\<forall>y\\<in>set xs. RR x y) \\<and>\n                (\\<forall>x\\<in>S' - set xs'.\n                    \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n                ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n         FOREACH_cond c x; FOREACH_cond c' x';\n         case x of\n         (it, \\<sigma>) \\<Rightarrow>\n           \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>;\n         case x' of\n         (it, \\<sigma>) \\<Rightarrow>\n           \\<exists>xs'. xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>;\n         x' = (x1, x2); x = (x1a, x2a)\\<rbrakk>\n        \\<Longrightarrow> \\<forall>y\\<in>set x1a - {hd x1a}. RR (hd x1a) y\nA total of 17 subgoals...", "apply auto []"], ["proof (prove)\ngoal (16 subgoals):\n 1. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n        FOREACH_cond c x; FOREACH_cond c' x';\n        case x of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>;\n        x' = (x1, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> set x1a \\<subseteq> S\n 2. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n        FOREACH_cond c x; FOREACH_cond c' x';\n        case x of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>;\n        x' = (x1, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> \\<alpha> ` set x1a \\<subseteq> S'\n 3. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n        FOREACH_cond c x; FOREACH_cond c' x';\n        case x of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>;\n        x' = (x1, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x\\<in>S - set x1a.\n                            \\<forall>y\\<in>set x1a. RR x y\n 4. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n        FOREACH_cond c x; FOREACH_cond c' x';\n        case x of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>;\n        x' = (x1, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x\\<in>S' - \\<alpha> ` set x1a.\n                            \\<forall>y\\<in>\\<alpha> ` set x1a. RR' x y\n 5. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n        FOREACH_cond c x; FOREACH_cond c' x';\n        case x of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>;\n        x' = (x1, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> hd x1 = \\<alpha> (hd x1a)\n 6. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n        FOREACH_cond c x; FOREACH_cond c' x';\n        case x of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>;\n        x' = (x1, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> \\<alpha> ` set x1a = \\<alpha> ` set x1a\n 7. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n        FOREACH_cond c x; FOREACH_cond c' x';\n        case x of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>;\n        x' = (x1, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> ((set x1a, x2a), \\<alpha> ` set x1a, x2) \\<in> R\n 8. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n        FOREACH_cond c x; FOREACH_cond c' x';\n        case x of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>;\n        x' = (x1, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> hd x1a \\<in> set x1a\n 9. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n        FOREACH_cond c x; FOREACH_cond c' x';\n        case x of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>;\n        x' = (x1, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>y\\<in>set x1a - {hd x1a}. RR (hd x1a) y\n 10. \\<And>xs xsa x x' x1 x2 x1a x2a.\n        \\<lbrakk>finite S'; finite S;\n         (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n         xs \\<in> {xs.\n                   distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n         xsa\n         \\<in> {xs.\n                distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n         (x, x')\n         \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n                xs' = map \\<alpha> xs \\<and>\n                set xs \\<subseteq> S \\<and>\n                set xs' \\<subseteq> S' \\<and>\n                (\\<forall>x\\<in>S - set xs.\n                    \\<forall>y\\<in>set xs. RR x y) \\<and>\n                (\\<forall>x\\<in>S' - set xs'.\n                    \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n                ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n         FOREACH_cond c x; FOREACH_cond c' x';\n         case x of\n         (it, \\<sigma>) \\<Rightarrow>\n           \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>;\n         case x' of\n         (it, \\<sigma>) \\<Rightarrow>\n           \\<exists>xs'. xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>;\n         x' = (x1, x2); x = (x1a, x2a)\\<rbrakk>\n        \\<Longrightarrow> hd x1 \\<in> \\<alpha> ` set x1a\nA total of 16 subgoals...", "apply simp_all[13]"], ["proof (prove)\ngoal (12 subgoals):\n 1. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>xsa = map \\<alpha> xs;\n        distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs;\n        distinct (map \\<alpha> xs) \\<and> sorted_wrt RR' (map \\<alpha> xs);\n        x1 = map \\<alpha> x1a \\<and>\n        set x1a \\<subseteq> set xs \\<and>\n        set x1 \\<subseteq> \\<alpha> ` set xs \\<and>\n        (\\<forall>x\\<in>set xs - set x1a.\n            \\<forall>xa\\<in>set x1a. RR x xa) \\<and>\n        (\\<forall>x\\<in>\\<alpha> ` set xs - set x1.\n            \\<forall>xa\\<in>set x1. RR' x xa) \\<and>\n        ((set x1a, x2a), set x1, x2) \\<in> R;\n        FOREACH_cond c (x1a, x2a); FOREACH_cond c' (map \\<alpha> x1a, x2);\n        (\\<exists>xs'. xs = xs' @ x1a) \\<and> \\<Phi> (set x1a) x2a;\n        (\\<exists>xs'. map \\<alpha> xs = xs' @ map \\<alpha> x1a) \\<and>\n        \\<Phi>' (\\<alpha> ` set x1a) x2;\n        x' = (map \\<alpha> x1a, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> \\<alpha> ` set x1a \\<subseteq> \\<alpha> ` set xs\n 2. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>xsa = map \\<alpha> xs;\n        distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs;\n        distinct (map \\<alpha> xs) \\<and> sorted_wrt RR' (map \\<alpha> xs);\n        x1 = map \\<alpha> x1a \\<and>\n        set x1a \\<subseteq> set xs \\<and>\n        set x1 \\<subseteq> \\<alpha> ` set xs \\<and>\n        (\\<forall>x\\<in>set xs - set x1a.\n            \\<forall>xa\\<in>set x1a. RR x xa) \\<and>\n        (\\<forall>x\\<in>\\<alpha> ` set xs - set x1.\n            \\<forall>xa\\<in>set x1. RR' x xa) \\<and>\n        ((set x1a, x2a), set x1, x2) \\<in> R;\n        FOREACH_cond c (x1a, x2a); FOREACH_cond c' (map \\<alpha> x1a, x2);\n        (\\<exists>xs'. xs = xs' @ x1a) \\<and> \\<Phi> (set x1a) x2a;\n        (\\<exists>xs'. map \\<alpha> xs = xs' @ map \\<alpha> x1a) \\<and>\n        \\<Phi>' (\\<alpha> ` set x1a) x2;\n        x' = (map \\<alpha> x1a, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> hd (map \\<alpha> x1a) = \\<alpha> (hd x1a)\n 3. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>xsa = map \\<alpha> xs;\n        distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs;\n        distinct (map \\<alpha> xs) \\<and> sorted_wrt RR' (map \\<alpha> xs);\n        x1 = map \\<alpha> x1a \\<and>\n        set x1a \\<subseteq> set xs \\<and>\n        set x1 \\<subseteq> \\<alpha> ` set xs \\<and>\n        (\\<forall>x\\<in>set xs - set x1a.\n            \\<forall>xa\\<in>set x1a. RR x xa) \\<and>\n        (\\<forall>x\\<in>\\<alpha> ` set xs - set x1.\n            \\<forall>xa\\<in>set x1. RR' x xa) \\<and>\n        ((set x1a, x2a), set x1, x2) \\<in> R;\n        FOREACH_cond c (x1a, x2a); FOREACH_cond c' (map \\<alpha> x1a, x2);\n        (\\<exists>xs'. xs = xs' @ x1a) \\<and> \\<Phi> (set x1a) x2a;\n        (\\<exists>xs'. map \\<alpha> xs = xs' @ map \\<alpha> x1a) \\<and>\n        \\<Phi>' (\\<alpha> ` set x1a) x2;\n        x' = (map \\<alpha> x1a, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> ((set x1a, x2a), \\<alpha> ` set x1a, x2) \\<in> R\n 4. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>xsa = map \\<alpha> xs;\n        distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs;\n        distinct (map \\<alpha> xs) \\<and> sorted_wrt RR' (map \\<alpha> xs);\n        x1 = map \\<alpha> x1a \\<and>\n        set x1a \\<subseteq> set xs \\<and>\n        set x1 \\<subseteq> \\<alpha> ` set xs \\<and>\n        (\\<forall>x\\<in>set xs - set x1a.\n            \\<forall>xa\\<in>set x1a. RR x xa) \\<and>\n        (\\<forall>x\\<in>\\<alpha> ` set xs - set x1.\n            \\<forall>xa\\<in>set x1. RR' x xa) \\<and>\n        ((set x1a, x2a), set x1, x2) \\<in> R;\n        FOREACH_cond c (x1a, x2a); FOREACH_cond c' (map \\<alpha> x1a, x2);\n        (\\<exists>xs'. xs = xs' @ x1a) \\<and> \\<Phi> (set x1a) x2a;\n        (\\<exists>xs'. map \\<alpha> xs = xs' @ map \\<alpha> x1a) \\<and>\n        \\<Phi>' (\\<alpha> ` set x1a) x2;\n        x' = (map \\<alpha> x1a, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> hd x1a \\<in> set x1a\n 5. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>xsa = map \\<alpha> xs;\n        distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs;\n        distinct (map \\<alpha> xs) \\<and> sorted_wrt RR' (map \\<alpha> xs);\n        x1 = map \\<alpha> x1a \\<and>\n        set x1a \\<subseteq> set xs \\<and>\n        set x1 \\<subseteq> \\<alpha> ` set xs \\<and>\n        (\\<forall>x\\<in>set xs - set x1a.\n            \\<forall>xa\\<in>set x1a. RR x xa) \\<and>\n        (\\<forall>x\\<in>\\<alpha> ` set xs - set x1.\n            \\<forall>xa\\<in>set x1. RR' x xa) \\<and>\n        ((set x1a, x2a), set x1, x2) \\<in> R;\n        FOREACH_cond c (x1a, x2a); FOREACH_cond c' (map \\<alpha> x1a, x2);\n        (\\<exists>xs'. xs = xs' @ x1a) \\<and> \\<Phi> (set x1a) x2a;\n        (\\<exists>xs'. map \\<alpha> xs = xs' @ map \\<alpha> x1a) \\<and>\n        \\<Phi>' (\\<alpha> ` set x1a) x2;\n        x' = (map \\<alpha> x1a, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x\\<in>set x1a - {hd x1a}. RR (hd x1a) x\n 6. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>xsa = map \\<alpha> xs;\n        distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs;\n        distinct (map \\<alpha> xs) \\<and> sorted_wrt RR' (map \\<alpha> xs);\n        x1 = map \\<alpha> x1a \\<and>\n        set x1a \\<subseteq> set xs \\<and>\n        set x1 \\<subseteq> \\<alpha> ` set xs \\<and>\n        (\\<forall>x\\<in>set xs - set x1a.\n            \\<forall>xa\\<in>set x1a. RR x xa) \\<and>\n        (\\<forall>x\\<in>\\<alpha> ` set xs - set x1.\n            \\<forall>xa\\<in>set x1. RR' x xa) \\<and>\n        ((set x1a, x2a), set x1, x2) \\<in> R;\n        FOREACH_cond c (x1a, x2a); FOREACH_cond c' (map \\<alpha> x1a, x2);\n        (\\<exists>xs'. xs = xs' @ x1a) \\<and> \\<Phi> (set x1a) x2a;\n        (\\<exists>xs'. map \\<alpha> xs = xs' @ map \\<alpha> x1a) \\<and>\n        \\<Phi>' (\\<alpha> ` set x1a) x2;\n        x' = (map \\<alpha> x1a, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> hd (map \\<alpha> x1a) \\<in> \\<alpha> ` set x1a\n 7. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>xsa = map \\<alpha> xs;\n        distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs;\n        distinct (map \\<alpha> xs) \\<and> sorted_wrt RR' (map \\<alpha> xs);\n        x1 = map \\<alpha> x1a \\<and>\n        set x1a \\<subseteq> set xs \\<and>\n        set x1 \\<subseteq> \\<alpha> ` set xs \\<and>\n        (\\<forall>x\\<in>set xs - set x1a.\n            \\<forall>xa\\<in>set x1a. RR x xa) \\<and>\n        (\\<forall>x\\<in>\\<alpha> ` set xs - set x1.\n            \\<forall>xa\\<in>set x1. RR' x xa) \\<and>\n        ((set x1a, x2a), set x1, x2) \\<in> R;\n        FOREACH_cond c (x1a, x2a); FOREACH_cond c' (map \\<alpha> x1a, x2);\n        (\\<exists>xs'. xs = xs' @ x1a) \\<and> \\<Phi> (set x1a) x2a;\n        (\\<exists>xs'. map \\<alpha> xs = xs' @ map \\<alpha> x1a) \\<and>\n        \\<Phi>' (\\<alpha> ` set x1a) x2;\n        x' = (map \\<alpha> x1a, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x\\<in>\\<alpha> ` set x1a -\n  {hd (map \\<alpha> x1a)}.\n                            RR' (hd (map \\<alpha> x1a)) x\n 8. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>xsa = map \\<alpha> xs;\n        distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs;\n        distinct (map \\<alpha> xs) \\<and> sorted_wrt RR' (map \\<alpha> xs);\n        x1 = map \\<alpha> x1a \\<and>\n        set x1a \\<subseteq> set xs \\<and>\n        set x1 \\<subseteq> \\<alpha> ` set xs \\<and>\n        (\\<forall>x\\<in>set xs - set x1a.\n            \\<forall>xa\\<in>set x1a. RR x xa) \\<and>\n        (\\<forall>x\\<in>\\<alpha> ` set xs - set x1.\n            \\<forall>xa\\<in>set x1. RR' x xa) \\<and>\n        ((set x1a, x2a), set x1, x2) \\<in> R;\n        FOREACH_cond c (x1a, x2a); FOREACH_cond c' (map \\<alpha> x1a, x2);\n        (\\<exists>xs'. xs = xs' @ x1a) \\<and> \\<Phi> (set x1a) x2a;\n        (\\<exists>xs'. map \\<alpha> xs = xs' @ map \\<alpha> x1a) \\<and>\n        \\<Phi>' (\\<alpha> ` set x1a) x2;\n        x' = (map \\<alpha> x1a, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> c x2a\n 9. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>xsa = map \\<alpha> xs;\n        distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs;\n        distinct (map \\<alpha> xs) \\<and> sorted_wrt RR' (map \\<alpha> xs);\n        x1 = map \\<alpha> x1a \\<and>\n        set x1a \\<subseteq> set xs \\<and>\n        set x1 \\<subseteq> \\<alpha> ` set xs \\<and>\n        (\\<forall>x\\<in>set xs - set x1a.\n            \\<forall>xa\\<in>set x1a. RR x xa) \\<and>\n        (\\<forall>x\\<in>\\<alpha> ` set xs - set x1.\n            \\<forall>xa\\<in>set x1. RR' x xa) \\<and>\n        ((set x1a, x2a), set x1, x2) \\<in> R;\n        FOREACH_cond c (x1a, x2a); FOREACH_cond c' (map \\<alpha> x1a, x2);\n        (\\<exists>xs'. xs = xs' @ x1a) \\<and> \\<Phi> (set x1a) x2a;\n        (\\<exists>xs'. map \\<alpha> xs = xs' @ map \\<alpha> x1a) \\<and>\n        \\<Phi>' (\\<alpha> ` set x1a) x2;\n        x' = (map \\<alpha> x1a, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> c' x2\n 10. \\<And>xs xsa x x' x1 x2 x1a x2a \\<sigma>' \\<sigma>''.\n        \\<lbrakk>finite S'; finite S;\n         (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n         xs \\<in> {xs.\n                   distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n         xsa\n         \\<in> {xs.\n                distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n         (x, x')\n         \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n                xs' = map \\<alpha> xs \\<and>\n                set xs \\<subseteq> S \\<and>\n                set xs' \\<subseteq> S' \\<and>\n                (\\<forall>x\\<in>S - set xs.\n                    \\<forall>y\\<in>set xs. RR x y) \\<and>\n                (\\<forall>x\\<in>S' - set xs'.\n                    \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n                ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n         FOREACH_cond c x; FOREACH_cond c' x';\n         case x of\n         (it, \\<sigma>) \\<Rightarrow>\n           \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>;\n         case x' of\n         (it, \\<sigma>) \\<Rightarrow>\n           \\<exists>xs'. xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>;\n         x' = (x1, x2); x = (x1a, x2a);\n         (\\<sigma>', \\<sigma>'')\n         \\<in> {(\\<sigma>, \\<sigma>').\n                ((set x1a - {hd x1a}, \\<sigma>),\n                 \\<alpha> ` set x1a - {hd x1}, \\<sigma>')\n                \\<in> R}\\<rbrakk>\n        \\<Longrightarrow> ((tl x1a, \\<sigma>'), tl x1, \\<sigma>'')\n                          \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n                                 xs' = map \\<alpha> xs \\<and>\n                                 set xs \\<subseteq> S \\<and>\n                                 set xs' \\<subseteq> S' \\<and>\n                                 (\\<forall>x\\<in>S - set xs.\n                                     \\<forall>y\\<in>set xs. RR x y) \\<and>\n                                 (\\<forall>x\\<in>S' - set xs'.\n                                     \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n                                 ((set xs, \\<sigma>), set xs', \\<sigma>')\n                                 \\<in> R}\nA total of 12 subgoals...", "apply auto []"], ["proof (prove)\ngoal (11 subgoals):\n 1. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>xsa = map \\<alpha> xs;\n        distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs;\n        distinct (map \\<alpha> xs) \\<and> sorted_wrt RR' (map \\<alpha> xs);\n        x1 = map \\<alpha> x1a \\<and>\n        set x1a \\<subseteq> set xs \\<and>\n        set x1 \\<subseteq> \\<alpha> ` set xs \\<and>\n        (\\<forall>x\\<in>set xs - set x1a.\n            \\<forall>xa\\<in>set x1a. RR x xa) \\<and>\n        (\\<forall>x\\<in>\\<alpha> ` set xs - set x1.\n            \\<forall>xa\\<in>set x1. RR' x xa) \\<and>\n        ((set x1a, x2a), set x1, x2) \\<in> R;\n        FOREACH_cond c (x1a, x2a); FOREACH_cond c' (map \\<alpha> x1a, x2);\n        (\\<exists>xs'. xs = xs' @ x1a) \\<and> \\<Phi> (set x1a) x2a;\n        (\\<exists>xs'. map \\<alpha> xs = xs' @ map \\<alpha> x1a) \\<and>\n        \\<Phi>' (\\<alpha> ` set x1a) x2;\n        x' = (map \\<alpha> x1a, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> hd (map \\<alpha> x1a) = \\<alpha> (hd x1a)\n 2. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>xsa = map \\<alpha> xs;\n        distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs;\n        distinct (map \\<alpha> xs) \\<and> sorted_wrt RR' (map \\<alpha> xs);\n        x1 = map \\<alpha> x1a \\<and>\n        set x1a \\<subseteq> set xs \\<and>\n        set x1 \\<subseteq> \\<alpha> ` set xs \\<and>\n        (\\<forall>x\\<in>set xs - set x1a.\n            \\<forall>xa\\<in>set x1a. RR x xa) \\<and>\n        (\\<forall>x\\<in>\\<alpha> ` set xs - set x1.\n            \\<forall>xa\\<in>set x1. RR' x xa) \\<and>\n        ((set x1a, x2a), set x1, x2) \\<in> R;\n        FOREACH_cond c (x1a, x2a); FOREACH_cond c' (map \\<alpha> x1a, x2);\n        (\\<exists>xs'. xs = xs' @ x1a) \\<and> \\<Phi> (set x1a) x2a;\n        (\\<exists>xs'. map \\<alpha> xs = xs' @ map \\<alpha> x1a) \\<and>\n        \\<Phi>' (\\<alpha> ` set x1a) x2;\n        x' = (map \\<alpha> x1a, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> ((set x1a, x2a), \\<alpha> ` set x1a, x2) \\<in> R\n 3. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>xsa = map \\<alpha> xs;\n        distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs;\n        distinct (map \\<alpha> xs) \\<and> sorted_wrt RR' (map \\<alpha> xs);\n        x1 = map \\<alpha> x1a \\<and>\n        set x1a \\<subseteq> set xs \\<and>\n        set x1 \\<subseteq> \\<alpha> ` set xs \\<and>\n        (\\<forall>x\\<in>set xs - set x1a.\n            \\<forall>xa\\<in>set x1a. RR x xa) \\<and>\n        (\\<forall>x\\<in>\\<alpha> ` set xs - set x1.\n            \\<forall>xa\\<in>set x1. RR' x xa) \\<and>\n        ((set x1a, x2a), set x1, x2) \\<in> R;\n        FOREACH_cond c (x1a, x2a); FOREACH_cond c' (map \\<alpha> x1a, x2);\n        (\\<exists>xs'. xs = xs' @ x1a) \\<and> \\<Phi> (set x1a) x2a;\n        (\\<exists>xs'. map \\<alpha> xs = xs' @ map \\<alpha> x1a) \\<and>\n        \\<Phi>' (\\<alpha> ` set x1a) x2;\n        x' = (map \\<alpha> x1a, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> hd x1a \\<in> set x1a\n 4. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>xsa = map \\<alpha> xs;\n        distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs;\n        distinct (map \\<alpha> xs) \\<and> sorted_wrt RR' (map \\<alpha> xs);\n        x1 = map \\<alpha> x1a \\<and>\n        set x1a \\<subseteq> set xs \\<and>\n        set x1 \\<subseteq> \\<alpha> ` set xs \\<and>\n        (\\<forall>x\\<in>set xs - set x1a.\n            \\<forall>xa\\<in>set x1a. RR x xa) \\<and>\n        (\\<forall>x\\<in>\\<alpha> ` set xs - set x1.\n            \\<forall>xa\\<in>set x1. RR' x xa) \\<and>\n        ((set x1a, x2a), set x1, x2) \\<in> R;\n        FOREACH_cond c (x1a, x2a); FOREACH_cond c' (map \\<alpha> x1a, x2);\n        (\\<exists>xs'. xs = xs' @ x1a) \\<and> \\<Phi> (set x1a) x2a;\n        (\\<exists>xs'. map \\<alpha> xs = xs' @ map \\<alpha> x1a) \\<and>\n        \\<Phi>' (\\<alpha> ` set x1a) x2;\n        x' = (map \\<alpha> x1a, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x\\<in>set x1a - {hd x1a}. RR (hd x1a) x\n 5. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>xsa = map \\<alpha> xs;\n        distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs;\n        distinct (map \\<alpha> xs) \\<and> sorted_wrt RR' (map \\<alpha> xs);\n        x1 = map \\<alpha> x1a \\<and>\n        set x1a \\<subseteq> set xs \\<and>\n        set x1 \\<subseteq> \\<alpha> ` set xs \\<and>\n        (\\<forall>x\\<in>set xs - set x1a.\n            \\<forall>xa\\<in>set x1a. RR x xa) \\<and>\n        (\\<forall>x\\<in>\\<alpha> ` set xs - set x1.\n            \\<forall>xa\\<in>set x1. RR' x xa) \\<and>\n        ((set x1a, x2a), set x1, x2) \\<in> R;\n        FOREACH_cond c (x1a, x2a); FOREACH_cond c' (map \\<alpha> x1a, x2);\n        (\\<exists>xs'. xs = xs' @ x1a) \\<and> \\<Phi> (set x1a) x2a;\n        (\\<exists>xs'. map \\<alpha> xs = xs' @ map \\<alpha> x1a) \\<and>\n        \\<Phi>' (\\<alpha> ` set x1a) x2;\n        x' = (map \\<alpha> x1a, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> hd (map \\<alpha> x1a) \\<in> \\<alpha> ` set x1a\n 6. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>xsa = map \\<alpha> xs;\n        distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs;\n        distinct (map \\<alpha> xs) \\<and> sorted_wrt RR' (map \\<alpha> xs);\n        x1 = map \\<alpha> x1a \\<and>\n        set x1a \\<subseteq> set xs \\<and>\n        set x1 \\<subseteq> \\<alpha> ` set xs \\<and>\n        (\\<forall>x\\<in>set xs - set x1a.\n            \\<forall>xa\\<in>set x1a. RR x xa) \\<and>\n        (\\<forall>x\\<in>\\<alpha> ` set xs - set x1.\n            \\<forall>xa\\<in>set x1. RR' x xa) \\<and>\n        ((set x1a, x2a), set x1, x2) \\<in> R;\n        FOREACH_cond c (x1a, x2a); FOREACH_cond c' (map \\<alpha> x1a, x2);\n        (\\<exists>xs'. xs = xs' @ x1a) \\<and> \\<Phi> (set x1a) x2a;\n        (\\<exists>xs'. map \\<alpha> xs = xs' @ map \\<alpha> x1a) \\<and>\n        \\<Phi>' (\\<alpha> ` set x1a) x2;\n        x' = (map \\<alpha> x1a, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x\\<in>\\<alpha> ` set x1a -\n  {hd (map \\<alpha> x1a)}.\n                            RR' (hd (map \\<alpha> x1a)) x\n 7. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>xsa = map \\<alpha> xs;\n        distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs;\n        distinct (map \\<alpha> xs) \\<and> sorted_wrt RR' (map \\<alpha> xs);\n        x1 = map \\<alpha> x1a \\<and>\n        set x1a \\<subseteq> set xs \\<and>\n        set x1 \\<subseteq> \\<alpha> ` set xs \\<and>\n        (\\<forall>x\\<in>set xs - set x1a.\n            \\<forall>xa\\<in>set x1a. RR x xa) \\<and>\n        (\\<forall>x\\<in>\\<alpha> ` set xs - set x1.\n            \\<forall>xa\\<in>set x1. RR' x xa) \\<and>\n        ((set x1a, x2a), set x1, x2) \\<in> R;\n        FOREACH_cond c (x1a, x2a); FOREACH_cond c' (map \\<alpha> x1a, x2);\n        (\\<exists>xs'. xs = xs' @ x1a) \\<and> \\<Phi> (set x1a) x2a;\n        (\\<exists>xs'. map \\<alpha> xs = xs' @ map \\<alpha> x1a) \\<and>\n        \\<Phi>' (\\<alpha> ` set x1a) x2;\n        x' = (map \\<alpha> x1a, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> c x2a\n 8. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>xsa = map \\<alpha> xs;\n        distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs;\n        distinct (map \\<alpha> xs) \\<and> sorted_wrt RR' (map \\<alpha> xs);\n        x1 = map \\<alpha> x1a \\<and>\n        set x1a \\<subseteq> set xs \\<and>\n        set x1 \\<subseteq> \\<alpha> ` set xs \\<and>\n        (\\<forall>x\\<in>set xs - set x1a.\n            \\<forall>xa\\<in>set x1a. RR x xa) \\<and>\n        (\\<forall>x\\<in>\\<alpha> ` set xs - set x1.\n            \\<forall>xa\\<in>set x1. RR' x xa) \\<and>\n        ((set x1a, x2a), set x1, x2) \\<in> R;\n        FOREACH_cond c (x1a, x2a); FOREACH_cond c' (map \\<alpha> x1a, x2);\n        (\\<exists>xs'. xs = xs' @ x1a) \\<and> \\<Phi> (set x1a) x2a;\n        (\\<exists>xs'. map \\<alpha> xs = xs' @ map \\<alpha> x1a) \\<and>\n        \\<Phi>' (\\<alpha> ` set x1a) x2;\n        x' = (map \\<alpha> x1a, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> c' x2\n 9. \\<And>xs xsa x x' x1 x2 x1a x2a \\<sigma>' \\<sigma>''.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n        FOREACH_cond c x; FOREACH_cond c' x';\n        case x of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>;\n        x' = (x1, x2); x = (x1a, x2a);\n        (\\<sigma>', \\<sigma>'')\n        \\<in> {(\\<sigma>, \\<sigma>').\n               ((set x1a - {hd x1a}, \\<sigma>),\n                \\<alpha> ` set x1a - {hd x1}, \\<sigma>')\n               \\<in> R}\\<rbrakk>\n       \\<Longrightarrow> ((tl x1a, \\<sigma>'), tl x1, \\<sigma>'')\n                         \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n                                xs' = map \\<alpha> xs \\<and>\n                                set xs \\<subseteq> S \\<and>\n                                set xs' \\<subseteq> S' \\<and>\n                                (\\<forall>x\\<in>S - set xs.\n                                    \\<forall>y\\<in>set xs. RR x y) \\<and>\n                                (\\<forall>x\\<in>S' - set xs'.\n                                    \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n                                ((set xs, \\<sigma>), set xs', \\<sigma>')\n                                \\<in> R}\n 10. \\<And>xs xsa x x'.\n        \\<lbrakk>finite S'; finite S;\n         (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n         xs \\<in> {xs.\n                   distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n         xsa\n         \\<in> {xs.\n                distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n         (x, x')\n         \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n                xs' = map \\<alpha> xs \\<and>\n                set xs \\<subseteq> S \\<and>\n                set xs' \\<subseteq> S' \\<and>\n                (\\<forall>x\\<in>S - set xs.\n                    \\<forall>y\\<in>set xs. RR x y) \\<and>\n                (\\<forall>x\\<in>S' - set xs'.\n                    \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n                ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n         \\<not> FOREACH_cond c x; \\<not> FOREACH_cond c' x';\n         case x of\n         (it, \\<sigma>) \\<Rightarrow>\n           \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>;\n         case x' of\n         (it, \\<sigma>) \\<Rightarrow>\n           \\<exists>xs'.\n              xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>\\<rbrakk>\n        \\<Longrightarrow> (x, x') \\<in> ?R'3 xs xsa\nA total of 11 subgoals...", "apply (rename_tac a b d e f g h i)"], ["proof (prove)\ngoal (11 subgoals):\n 1. \\<And>a b d e f g h i.\n       \\<lbrakk>b = map \\<alpha> a;\n        distinct a \\<and> S = set a \\<and> sorted_wrt RR a;\n        distinct (map \\<alpha> a) \\<and> sorted_wrt RR' (map \\<alpha> a);\n        f = map \\<alpha> h \\<and>\n        set h \\<subseteq> set a \\<and>\n        set f \\<subseteq> \\<alpha> ` set a \\<and>\n        (\\<forall>x\\<in>set a - set h.\n            \\<forall>xa\\<in>set h. RR x xa) \\<and>\n        (\\<forall>x\\<in>\\<alpha> ` set a - set f.\n            \\<forall>xa\\<in>set f. RR' x xa) \\<and>\n        ((set h, i), set f, g) \\<in> R;\n        FOREACH_cond c (h, i); FOREACH_cond c' (map \\<alpha> h, g);\n        (\\<exists>xs'. a = xs' @ h) \\<and> \\<Phi> (set h) i;\n        (\\<exists>xs'. map \\<alpha> a = xs' @ map \\<alpha> h) \\<and>\n        \\<Phi>' (\\<alpha> ` set h) g;\n        e = (map \\<alpha> h, g); d = (h, i)\\<rbrakk>\n       \\<Longrightarrow> hd (map \\<alpha> h) = \\<alpha> (hd h)\n 2. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>xsa = map \\<alpha> xs;\n        distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs;\n        distinct (map \\<alpha> xs) \\<and> sorted_wrt RR' (map \\<alpha> xs);\n        x1 = map \\<alpha> x1a \\<and>\n        set x1a \\<subseteq> set xs \\<and>\n        set x1 \\<subseteq> \\<alpha> ` set xs \\<and>\n        (\\<forall>x\\<in>set xs - set x1a.\n            \\<forall>xa\\<in>set x1a. RR x xa) \\<and>\n        (\\<forall>x\\<in>\\<alpha> ` set xs - set x1.\n            \\<forall>xa\\<in>set x1. RR' x xa) \\<and>\n        ((set x1a, x2a), set x1, x2) \\<in> R;\n        FOREACH_cond c (x1a, x2a); FOREACH_cond c' (map \\<alpha> x1a, x2);\n        (\\<exists>xs'. xs = xs' @ x1a) \\<and> \\<Phi> (set x1a) x2a;\n        (\\<exists>xs'. map \\<alpha> xs = xs' @ map \\<alpha> x1a) \\<and>\n        \\<Phi>' (\\<alpha> ` set x1a) x2;\n        x' = (map \\<alpha> x1a, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> ((set x1a, x2a), \\<alpha> ` set x1a, x2) \\<in> R\n 3. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>xsa = map \\<alpha> xs;\n        distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs;\n        distinct (map \\<alpha> xs) \\<and> sorted_wrt RR' (map \\<alpha> xs);\n        x1 = map \\<alpha> x1a \\<and>\n        set x1a \\<subseteq> set xs \\<and>\n        set x1 \\<subseteq> \\<alpha> ` set xs \\<and>\n        (\\<forall>x\\<in>set xs - set x1a.\n            \\<forall>xa\\<in>set x1a. RR x xa) \\<and>\n        (\\<forall>x\\<in>\\<alpha> ` set xs - set x1.\n            \\<forall>xa\\<in>set x1. RR' x xa) \\<and>\n        ((set x1a, x2a), set x1, x2) \\<in> R;\n        FOREACH_cond c (x1a, x2a); FOREACH_cond c' (map \\<alpha> x1a, x2);\n        (\\<exists>xs'. xs = xs' @ x1a) \\<and> \\<Phi> (set x1a) x2a;\n        (\\<exists>xs'. map \\<alpha> xs = xs' @ map \\<alpha> x1a) \\<and>\n        \\<Phi>' (\\<alpha> ` set x1a) x2;\n        x' = (map \\<alpha> x1a, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> hd x1a \\<in> set x1a\n 4. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>xsa = map \\<alpha> xs;\n        distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs;\n        distinct (map \\<alpha> xs) \\<and> sorted_wrt RR' (map \\<alpha> xs);\n        x1 = map \\<alpha> x1a \\<and>\n        set x1a \\<subseteq> set xs \\<and>\n        set x1 \\<subseteq> \\<alpha> ` set xs \\<and>\n        (\\<forall>x\\<in>set xs - set x1a.\n            \\<forall>xa\\<in>set x1a. RR x xa) \\<and>\n        (\\<forall>x\\<in>\\<alpha> ` set xs - set x1.\n            \\<forall>xa\\<in>set x1. RR' x xa) \\<and>\n        ((set x1a, x2a), set x1, x2) \\<in> R;\n        FOREACH_cond c (x1a, x2a); FOREACH_cond c' (map \\<alpha> x1a, x2);\n        (\\<exists>xs'. xs = xs' @ x1a) \\<and> \\<Phi> (set x1a) x2a;\n        (\\<exists>xs'. map \\<alpha> xs = xs' @ map \\<alpha> x1a) \\<and>\n        \\<Phi>' (\\<alpha> ` set x1a) x2;\n        x' = (map \\<alpha> x1a, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x\\<in>set x1a - {hd x1a}. RR (hd x1a) x\n 5. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>xsa = map \\<alpha> xs;\n        distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs;\n        distinct (map \\<alpha> xs) \\<and> sorted_wrt RR' (map \\<alpha> xs);\n        x1 = map \\<alpha> x1a \\<and>\n        set x1a \\<subseteq> set xs \\<and>\n        set x1 \\<subseteq> \\<alpha> ` set xs \\<and>\n        (\\<forall>x\\<in>set xs - set x1a.\n            \\<forall>xa\\<in>set x1a. RR x xa) \\<and>\n        (\\<forall>x\\<in>\\<alpha> ` set xs - set x1.\n            \\<forall>xa\\<in>set x1. RR' x xa) \\<and>\n        ((set x1a, x2a), set x1, x2) \\<in> R;\n        FOREACH_cond c (x1a, x2a); FOREACH_cond c' (map \\<alpha> x1a, x2);\n        (\\<exists>xs'. xs = xs' @ x1a) \\<and> \\<Phi> (set x1a) x2a;\n        (\\<exists>xs'. map \\<alpha> xs = xs' @ map \\<alpha> x1a) \\<and>\n        \\<Phi>' (\\<alpha> ` set x1a) x2;\n        x' = (map \\<alpha> x1a, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> hd (map \\<alpha> x1a) \\<in> \\<alpha> ` set x1a\n 6. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>xsa = map \\<alpha> xs;\n        distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs;\n        distinct (map \\<alpha> xs) \\<and> sorted_wrt RR' (map \\<alpha> xs);\n        x1 = map \\<alpha> x1a \\<and>\n        set x1a \\<subseteq> set xs \\<and>\n        set x1 \\<subseteq> \\<alpha> ` set xs \\<and>\n        (\\<forall>x\\<in>set xs - set x1a.\n            \\<forall>xa\\<in>set x1a. RR x xa) \\<and>\n        (\\<forall>x\\<in>\\<alpha> ` set xs - set x1.\n            \\<forall>xa\\<in>set x1. RR' x xa) \\<and>\n        ((set x1a, x2a), set x1, x2) \\<in> R;\n        FOREACH_cond c (x1a, x2a); FOREACH_cond c' (map \\<alpha> x1a, x2);\n        (\\<exists>xs'. xs = xs' @ x1a) \\<and> \\<Phi> (set x1a) x2a;\n        (\\<exists>xs'. map \\<alpha> xs = xs' @ map \\<alpha> x1a) \\<and>\n        \\<Phi>' (\\<alpha> ` set x1a) x2;\n        x' = (map \\<alpha> x1a, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x\\<in>\\<alpha> ` set x1a -\n  {hd (map \\<alpha> x1a)}.\n                            RR' (hd (map \\<alpha> x1a)) x\n 7. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>xsa = map \\<alpha> xs;\n        distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs;\n        distinct (map \\<alpha> xs) \\<and> sorted_wrt RR' (map \\<alpha> xs);\n        x1 = map \\<alpha> x1a \\<and>\n        set x1a \\<subseteq> set xs \\<and>\n        set x1 \\<subseteq> \\<alpha> ` set xs \\<and>\n        (\\<forall>x\\<in>set xs - set x1a.\n            \\<forall>xa\\<in>set x1a. RR x xa) \\<and>\n        (\\<forall>x\\<in>\\<alpha> ` set xs - set x1.\n            \\<forall>xa\\<in>set x1. RR' x xa) \\<and>\n        ((set x1a, x2a), set x1, x2) \\<in> R;\n        FOREACH_cond c (x1a, x2a); FOREACH_cond c' (map \\<alpha> x1a, x2);\n        (\\<exists>xs'. xs = xs' @ x1a) \\<and> \\<Phi> (set x1a) x2a;\n        (\\<exists>xs'. map \\<alpha> xs = xs' @ map \\<alpha> x1a) \\<and>\n        \\<Phi>' (\\<alpha> ` set x1a) x2;\n        x' = (map \\<alpha> x1a, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> c x2a\n 8. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>xsa = map \\<alpha> xs;\n        distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs;\n        distinct (map \\<alpha> xs) \\<and> sorted_wrt RR' (map \\<alpha> xs);\n        x1 = map \\<alpha> x1a \\<and>\n        set x1a \\<subseteq> set xs \\<and>\n        set x1 \\<subseteq> \\<alpha> ` set xs \\<and>\n        (\\<forall>x\\<in>set xs - set x1a.\n            \\<forall>xa\\<in>set x1a. RR x xa) \\<and>\n        (\\<forall>x\\<in>\\<alpha> ` set xs - set x1.\n            \\<forall>xa\\<in>set x1. RR' x xa) \\<and>\n        ((set x1a, x2a), set x1, x2) \\<in> R;\n        FOREACH_cond c (x1a, x2a); FOREACH_cond c' (map \\<alpha> x1a, x2);\n        (\\<exists>xs'. xs = xs' @ x1a) \\<and> \\<Phi> (set x1a) x2a;\n        (\\<exists>xs'. map \\<alpha> xs = xs' @ map \\<alpha> x1a) \\<and>\n        \\<Phi>' (\\<alpha> ` set x1a) x2;\n        x' = (map \\<alpha> x1a, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> c' x2\n 9. \\<And>xs xsa x x' x1 x2 x1a x2a \\<sigma>' \\<sigma>''.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n        FOREACH_cond c x; FOREACH_cond c' x';\n        case x of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>;\n        x' = (x1, x2); x = (x1a, x2a);\n        (\\<sigma>', \\<sigma>'')\n        \\<in> {(\\<sigma>, \\<sigma>').\n               ((set x1a - {hd x1a}, \\<sigma>),\n                \\<alpha> ` set x1a - {hd x1}, \\<sigma>')\n               \\<in> R}\\<rbrakk>\n       \\<Longrightarrow> ((tl x1a, \\<sigma>'), tl x1, \\<sigma>'')\n                         \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n                                xs' = map \\<alpha> xs \\<and>\n                                set xs \\<subseteq> S \\<and>\n                                set xs' \\<subseteq> S' \\<and>\n                                (\\<forall>x\\<in>S - set xs.\n                                    \\<forall>y\\<in>set xs. RR x y) \\<and>\n                                (\\<forall>x\\<in>S' - set xs'.\n                                    \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n                                ((set xs, \\<sigma>), set xs', \\<sigma>')\n                                \\<in> R}\n 10. \\<And>xs xsa x x'.\n        \\<lbrakk>finite S'; finite S;\n         (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n         xs \\<in> {xs.\n                   distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n         xsa\n         \\<in> {xs.\n                distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n         (x, x')\n         \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n                xs' = map \\<alpha> xs \\<and>\n                set xs \\<subseteq> S \\<and>\n                set xs' \\<subseteq> S' \\<and>\n                (\\<forall>x\\<in>S - set xs.\n                    \\<forall>y\\<in>set xs. RR x y) \\<and>\n                (\\<forall>x\\<in>S' - set xs'.\n                    \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n                ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n         \\<not> FOREACH_cond c x; \\<not> FOREACH_cond c' x';\n         case x of\n         (it, \\<sigma>) \\<Rightarrow>\n           \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>;\n         case x' of\n         (it, \\<sigma>) \\<Rightarrow>\n           \\<exists>xs'.\n              xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>\\<rbrakk>\n        \\<Longrightarrow> (x, x') \\<in> ?R'3 xs xsa\nA total of 11 subgoals...", "apply (case_tac h, auto simp: FOREACH_cond_def) []"], ["proof (prove)\ngoal (10 subgoals):\n 1. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>xsa = map \\<alpha> xs;\n        distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs;\n        distinct (map \\<alpha> xs) \\<and> sorted_wrt RR' (map \\<alpha> xs);\n        x1 = map \\<alpha> x1a \\<and>\n        set x1a \\<subseteq> set xs \\<and>\n        set x1 \\<subseteq> \\<alpha> ` set xs \\<and>\n        (\\<forall>x\\<in>set xs - set x1a.\n            \\<forall>xa\\<in>set x1a. RR x xa) \\<and>\n        (\\<forall>x\\<in>\\<alpha> ` set xs - set x1.\n            \\<forall>xa\\<in>set x1. RR' x xa) \\<and>\n        ((set x1a, x2a), set x1, x2) \\<in> R;\n        FOREACH_cond c (x1a, x2a); FOREACH_cond c' (map \\<alpha> x1a, x2);\n        (\\<exists>xs'. xs = xs' @ x1a) \\<and> \\<Phi> (set x1a) x2a;\n        (\\<exists>xs'. map \\<alpha> xs = xs' @ map \\<alpha> x1a) \\<and>\n        \\<Phi>' (\\<alpha> ` set x1a) x2;\n        x' = (map \\<alpha> x1a, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> ((set x1a, x2a), \\<alpha> ` set x1a, x2) \\<in> R\n 2. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>xsa = map \\<alpha> xs;\n        distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs;\n        distinct (map \\<alpha> xs) \\<and> sorted_wrt RR' (map \\<alpha> xs);\n        x1 = map \\<alpha> x1a \\<and>\n        set x1a \\<subseteq> set xs \\<and>\n        set x1 \\<subseteq> \\<alpha> ` set xs \\<and>\n        (\\<forall>x\\<in>set xs - set x1a.\n            \\<forall>xa\\<in>set x1a. RR x xa) \\<and>\n        (\\<forall>x\\<in>\\<alpha> ` set xs - set x1.\n            \\<forall>xa\\<in>set x1. RR' x xa) \\<and>\n        ((set x1a, x2a), set x1, x2) \\<in> R;\n        FOREACH_cond c (x1a, x2a); FOREACH_cond c' (map \\<alpha> x1a, x2);\n        (\\<exists>xs'. xs = xs' @ x1a) \\<and> \\<Phi> (set x1a) x2a;\n        (\\<exists>xs'. map \\<alpha> xs = xs' @ map \\<alpha> x1a) \\<and>\n        \\<Phi>' (\\<alpha> ` set x1a) x2;\n        x' = (map \\<alpha> x1a, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> hd x1a \\<in> set x1a\n 3. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>xsa = map \\<alpha> xs;\n        distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs;\n        distinct (map \\<alpha> xs) \\<and> sorted_wrt RR' (map \\<alpha> xs);\n        x1 = map \\<alpha> x1a \\<and>\n        set x1a \\<subseteq> set xs \\<and>\n        set x1 \\<subseteq> \\<alpha> ` set xs \\<and>\n        (\\<forall>x\\<in>set xs - set x1a.\n            \\<forall>xa\\<in>set x1a. RR x xa) \\<and>\n        (\\<forall>x\\<in>\\<alpha> ` set xs - set x1.\n            \\<forall>xa\\<in>set x1. RR' x xa) \\<and>\n        ((set x1a, x2a), set x1, x2) \\<in> R;\n        FOREACH_cond c (x1a, x2a); FOREACH_cond c' (map \\<alpha> x1a, x2);\n        (\\<exists>xs'. xs = xs' @ x1a) \\<and> \\<Phi> (set x1a) x2a;\n        (\\<exists>xs'. map \\<alpha> xs = xs' @ map \\<alpha> x1a) \\<and>\n        \\<Phi>' (\\<alpha> ` set x1a) x2;\n        x' = (map \\<alpha> x1a, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x\\<in>set x1a - {hd x1a}. RR (hd x1a) x\n 4. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>xsa = map \\<alpha> xs;\n        distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs;\n        distinct (map \\<alpha> xs) \\<and> sorted_wrt RR' (map \\<alpha> xs);\n        x1 = map \\<alpha> x1a \\<and>\n        set x1a \\<subseteq> set xs \\<and>\n        set x1 \\<subseteq> \\<alpha> ` set xs \\<and>\n        (\\<forall>x\\<in>set xs - set x1a.\n            \\<forall>xa\\<in>set x1a. RR x xa) \\<and>\n        (\\<forall>x\\<in>\\<alpha> ` set xs - set x1.\n            \\<forall>xa\\<in>set x1. RR' x xa) \\<and>\n        ((set x1a, x2a), set x1, x2) \\<in> R;\n        FOREACH_cond c (x1a, x2a); FOREACH_cond c' (map \\<alpha> x1a, x2);\n        (\\<exists>xs'. xs = xs' @ x1a) \\<and> \\<Phi> (set x1a) x2a;\n        (\\<exists>xs'. map \\<alpha> xs = xs' @ map \\<alpha> x1a) \\<and>\n        \\<Phi>' (\\<alpha> ` set x1a) x2;\n        x' = (map \\<alpha> x1a, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> hd (map \\<alpha> x1a) \\<in> \\<alpha> ` set x1a\n 5. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>xsa = map \\<alpha> xs;\n        distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs;\n        distinct (map \\<alpha> xs) \\<and> sorted_wrt RR' (map \\<alpha> xs);\n        x1 = map \\<alpha> x1a \\<and>\n        set x1a \\<subseteq> set xs \\<and>\n        set x1 \\<subseteq> \\<alpha> ` set xs \\<and>\n        (\\<forall>x\\<in>set xs - set x1a.\n            \\<forall>xa\\<in>set x1a. RR x xa) \\<and>\n        (\\<forall>x\\<in>\\<alpha> ` set xs - set x1.\n            \\<forall>xa\\<in>set x1. RR' x xa) \\<and>\n        ((set x1a, x2a), set x1, x2) \\<in> R;\n        FOREACH_cond c (x1a, x2a); FOREACH_cond c' (map \\<alpha> x1a, x2);\n        (\\<exists>xs'. xs = xs' @ x1a) \\<and> \\<Phi> (set x1a) x2a;\n        (\\<exists>xs'. map \\<alpha> xs = xs' @ map \\<alpha> x1a) \\<and>\n        \\<Phi>' (\\<alpha> ` set x1a) x2;\n        x' = (map \\<alpha> x1a, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x\\<in>\\<alpha> ` set x1a -\n  {hd (map \\<alpha> x1a)}.\n                            RR' (hd (map \\<alpha> x1a)) x\n 6. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>xsa = map \\<alpha> xs;\n        distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs;\n        distinct (map \\<alpha> xs) \\<and> sorted_wrt RR' (map \\<alpha> xs);\n        x1 = map \\<alpha> x1a \\<and>\n        set x1a \\<subseteq> set xs \\<and>\n        set x1 \\<subseteq> \\<alpha> ` set xs \\<and>\n        (\\<forall>x\\<in>set xs - set x1a.\n            \\<forall>xa\\<in>set x1a. RR x xa) \\<and>\n        (\\<forall>x\\<in>\\<alpha> ` set xs - set x1.\n            \\<forall>xa\\<in>set x1. RR' x xa) \\<and>\n        ((set x1a, x2a), set x1, x2) \\<in> R;\n        FOREACH_cond c (x1a, x2a); FOREACH_cond c' (map \\<alpha> x1a, x2);\n        (\\<exists>xs'. xs = xs' @ x1a) \\<and> \\<Phi> (set x1a) x2a;\n        (\\<exists>xs'. map \\<alpha> xs = xs' @ map \\<alpha> x1a) \\<and>\n        \\<Phi>' (\\<alpha> ` set x1a) x2;\n        x' = (map \\<alpha> x1a, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> c x2a\n 7. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>xsa = map \\<alpha> xs;\n        distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs;\n        distinct (map \\<alpha> xs) \\<and> sorted_wrt RR' (map \\<alpha> xs);\n        x1 = map \\<alpha> x1a \\<and>\n        set x1a \\<subseteq> set xs \\<and>\n        set x1 \\<subseteq> \\<alpha> ` set xs \\<and>\n        (\\<forall>x\\<in>set xs - set x1a.\n            \\<forall>xa\\<in>set x1a. RR x xa) \\<and>\n        (\\<forall>x\\<in>\\<alpha> ` set xs - set x1.\n            \\<forall>xa\\<in>set x1. RR' x xa) \\<and>\n        ((set x1a, x2a), set x1, x2) \\<in> R;\n        FOREACH_cond c (x1a, x2a); FOREACH_cond c' (map \\<alpha> x1a, x2);\n        (\\<exists>xs'. xs = xs' @ x1a) \\<and> \\<Phi> (set x1a) x2a;\n        (\\<exists>xs'. map \\<alpha> xs = xs' @ map \\<alpha> x1a) \\<and>\n        \\<Phi>' (\\<alpha> ` set x1a) x2;\n        x' = (map \\<alpha> x1a, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> c' x2\n 8. \\<And>xs xsa x x' x1 x2 x1a x2a \\<sigma>' \\<sigma>''.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n        FOREACH_cond c x; FOREACH_cond c' x';\n        case x of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>;\n        x' = (x1, x2); x = (x1a, x2a);\n        (\\<sigma>', \\<sigma>'')\n        \\<in> {(\\<sigma>, \\<sigma>').\n               ((set x1a - {hd x1a}, \\<sigma>),\n                \\<alpha> ` set x1a - {hd x1}, \\<sigma>')\n               \\<in> R}\\<rbrakk>\n       \\<Longrightarrow> ((tl x1a, \\<sigma>'), tl x1, \\<sigma>'')\n                         \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n                                xs' = map \\<alpha> xs \\<and>\n                                set xs \\<subseteq> S \\<and>\n                                set xs' \\<subseteq> S' \\<and>\n                                (\\<forall>x\\<in>S - set xs.\n                                    \\<forall>y\\<in>set xs. RR x y) \\<and>\n                                (\\<forall>x\\<in>S' - set xs'.\n                                    \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n                                ((set xs, \\<sigma>), set xs', \\<sigma>')\n                                \\<in> R}\n 9. \\<And>xs xsa x x'.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n        \\<not> FOREACH_cond c x; \\<not> FOREACH_cond c' x';\n        case x of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'.\n             xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> (x, x') \\<in> ?R'3 xs xsa\n 10. \\<And>xs xsa x x' x1 x2 x1a x2a.\n        \\<lbrakk>finite S'; finite S;\n         (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n         xs \\<in> {xs.\n                   distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n         xsa\n         \\<in> {xs.\n                distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n         (x, x') \\<in> ?R'3 xs xsa; x' = (x1, x2); x = (x1a, x2a)\\<rbrakk>\n        \\<Longrightarrow> (x2a, x2) \\<in> R'", "apply auto []"], ["proof (prove)\ngoal (9 subgoals):\n 1. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>xsa = map \\<alpha> xs;\n        distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs;\n        distinct (map \\<alpha> xs) \\<and> sorted_wrt RR' (map \\<alpha> xs);\n        x1 = map \\<alpha> x1a \\<and>\n        set x1a \\<subseteq> set xs \\<and>\n        set x1 \\<subseteq> \\<alpha> ` set xs \\<and>\n        (\\<forall>x\\<in>set xs - set x1a.\n            \\<forall>xa\\<in>set x1a. RR x xa) \\<and>\n        (\\<forall>x\\<in>\\<alpha> ` set xs - set x1.\n            \\<forall>xa\\<in>set x1. RR' x xa) \\<and>\n        ((set x1a, x2a), set x1, x2) \\<in> R;\n        FOREACH_cond c (x1a, x2a); FOREACH_cond c' (map \\<alpha> x1a, x2);\n        (\\<exists>xs'. xs = xs' @ x1a) \\<and> \\<Phi> (set x1a) x2a;\n        (\\<exists>xs'. map \\<alpha> xs = xs' @ map \\<alpha> x1a) \\<and>\n        \\<Phi>' (\\<alpha> ` set x1a) x2;\n        x' = (map \\<alpha> x1a, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> hd x1a \\<in> set x1a\n 2. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>xsa = map \\<alpha> xs;\n        distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs;\n        distinct (map \\<alpha> xs) \\<and> sorted_wrt RR' (map \\<alpha> xs);\n        x1 = map \\<alpha> x1a \\<and>\n        set x1a \\<subseteq> set xs \\<and>\n        set x1 \\<subseteq> \\<alpha> ` set xs \\<and>\n        (\\<forall>x\\<in>set xs - set x1a.\n            \\<forall>xa\\<in>set x1a. RR x xa) \\<and>\n        (\\<forall>x\\<in>\\<alpha> ` set xs - set x1.\n            \\<forall>xa\\<in>set x1. RR' x xa) \\<and>\n        ((set x1a, x2a), set x1, x2) \\<in> R;\n        FOREACH_cond c (x1a, x2a); FOREACH_cond c' (map \\<alpha> x1a, x2);\n        (\\<exists>xs'. xs = xs' @ x1a) \\<and> \\<Phi> (set x1a) x2a;\n        (\\<exists>xs'. map \\<alpha> xs = xs' @ map \\<alpha> x1a) \\<and>\n        \\<Phi>' (\\<alpha> ` set x1a) x2;\n        x' = (map \\<alpha> x1a, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x\\<in>set x1a - {hd x1a}. RR (hd x1a) x\n 3. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>xsa = map \\<alpha> xs;\n        distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs;\n        distinct (map \\<alpha> xs) \\<and> sorted_wrt RR' (map \\<alpha> xs);\n        x1 = map \\<alpha> x1a \\<and>\n        set x1a \\<subseteq> set xs \\<and>\n        set x1 \\<subseteq> \\<alpha> ` set xs \\<and>\n        (\\<forall>x\\<in>set xs - set x1a.\n            \\<forall>xa\\<in>set x1a. RR x xa) \\<and>\n        (\\<forall>x\\<in>\\<alpha> ` set xs - set x1.\n            \\<forall>xa\\<in>set x1. RR' x xa) \\<and>\n        ((set x1a, x2a), set x1, x2) \\<in> R;\n        FOREACH_cond c (x1a, x2a); FOREACH_cond c' (map \\<alpha> x1a, x2);\n        (\\<exists>xs'. xs = xs' @ x1a) \\<and> \\<Phi> (set x1a) x2a;\n        (\\<exists>xs'. map \\<alpha> xs = xs' @ map \\<alpha> x1a) \\<and>\n        \\<Phi>' (\\<alpha> ` set x1a) x2;\n        x' = (map \\<alpha> x1a, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> hd (map \\<alpha> x1a) \\<in> \\<alpha> ` set x1a\n 4. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>xsa = map \\<alpha> xs;\n        distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs;\n        distinct (map \\<alpha> xs) \\<and> sorted_wrt RR' (map \\<alpha> xs);\n        x1 = map \\<alpha> x1a \\<and>\n        set x1a \\<subseteq> set xs \\<and>\n        set x1 \\<subseteq> \\<alpha> ` set xs \\<and>\n        (\\<forall>x\\<in>set xs - set x1a.\n            \\<forall>xa\\<in>set x1a. RR x xa) \\<and>\n        (\\<forall>x\\<in>\\<alpha> ` set xs - set x1.\n            \\<forall>xa\\<in>set x1. RR' x xa) \\<and>\n        ((set x1a, x2a), set x1, x2) \\<in> R;\n        FOREACH_cond c (x1a, x2a); FOREACH_cond c' (map \\<alpha> x1a, x2);\n        (\\<exists>xs'. xs = xs' @ x1a) \\<and> \\<Phi> (set x1a) x2a;\n        (\\<exists>xs'. map \\<alpha> xs = xs' @ map \\<alpha> x1a) \\<and>\n        \\<Phi>' (\\<alpha> ` set x1a) x2;\n        x' = (map \\<alpha> x1a, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x\\<in>\\<alpha> ` set x1a -\n  {hd (map \\<alpha> x1a)}.\n                            RR' (hd (map \\<alpha> x1a)) x\n 5. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>xsa = map \\<alpha> xs;\n        distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs;\n        distinct (map \\<alpha> xs) \\<and> sorted_wrt RR' (map \\<alpha> xs);\n        x1 = map \\<alpha> x1a \\<and>\n        set x1a \\<subseteq> set xs \\<and>\n        set x1 \\<subseteq> \\<alpha> ` set xs \\<and>\n        (\\<forall>x\\<in>set xs - set x1a.\n            \\<forall>xa\\<in>set x1a. RR x xa) \\<and>\n        (\\<forall>x\\<in>\\<alpha> ` set xs - set x1.\n            \\<forall>xa\\<in>set x1. RR' x xa) \\<and>\n        ((set x1a, x2a), set x1, x2) \\<in> R;\n        FOREACH_cond c (x1a, x2a); FOREACH_cond c' (map \\<alpha> x1a, x2);\n        (\\<exists>xs'. xs = xs' @ x1a) \\<and> \\<Phi> (set x1a) x2a;\n        (\\<exists>xs'. map \\<alpha> xs = xs' @ map \\<alpha> x1a) \\<and>\n        \\<Phi>' (\\<alpha> ` set x1a) x2;\n        x' = (map \\<alpha> x1a, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> c x2a\n 6. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>xsa = map \\<alpha> xs;\n        distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs;\n        distinct (map \\<alpha> xs) \\<and> sorted_wrt RR' (map \\<alpha> xs);\n        x1 = map \\<alpha> x1a \\<and>\n        set x1a \\<subseteq> set xs \\<and>\n        set x1 \\<subseteq> \\<alpha> ` set xs \\<and>\n        (\\<forall>x\\<in>set xs - set x1a.\n            \\<forall>xa\\<in>set x1a. RR x xa) \\<and>\n        (\\<forall>x\\<in>\\<alpha> ` set xs - set x1.\n            \\<forall>xa\\<in>set x1. RR' x xa) \\<and>\n        ((set x1a, x2a), set x1, x2) \\<in> R;\n        FOREACH_cond c (x1a, x2a); FOREACH_cond c' (map \\<alpha> x1a, x2);\n        (\\<exists>xs'. xs = xs' @ x1a) \\<and> \\<Phi> (set x1a) x2a;\n        (\\<exists>xs'. map \\<alpha> xs = xs' @ map \\<alpha> x1a) \\<and>\n        \\<Phi>' (\\<alpha> ` set x1a) x2;\n        x' = (map \\<alpha> x1a, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> c' x2\n 7. \\<And>xs xsa x x' x1 x2 x1a x2a \\<sigma>' \\<sigma>''.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n        FOREACH_cond c x; FOREACH_cond c' x';\n        case x of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>;\n        x' = (x1, x2); x = (x1a, x2a);\n        (\\<sigma>', \\<sigma>'')\n        \\<in> {(\\<sigma>, \\<sigma>').\n               ((set x1a - {hd x1a}, \\<sigma>),\n                \\<alpha> ` set x1a - {hd x1}, \\<sigma>')\n               \\<in> R}\\<rbrakk>\n       \\<Longrightarrow> ((tl x1a, \\<sigma>'), tl x1, \\<sigma>'')\n                         \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n                                xs' = map \\<alpha> xs \\<and>\n                                set xs \\<subseteq> S \\<and>\n                                set xs' \\<subseteq> S' \\<and>\n                                (\\<forall>x\\<in>S - set xs.\n                                    \\<forall>y\\<in>set xs. RR x y) \\<and>\n                                (\\<forall>x\\<in>S' - set xs'.\n                                    \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n                                ((set xs, \\<sigma>), set xs', \\<sigma>')\n                                \\<in> R}\n 8. \\<And>xs xsa x x'.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n        \\<not> FOREACH_cond c x; \\<not> FOREACH_cond c' x';\n        case x of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'.\n             xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> (x, x') \\<in> ?R'3 xs xsa\n 9. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x') \\<in> ?R'3 xs xsa; x' = (x1, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> (x2a, x2) \\<in> R'", "apply (auto simp: FOREACH_cond_def) []"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>xsa = map \\<alpha> xs;\n        distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs;\n        distinct (map \\<alpha> xs) \\<and> sorted_wrt RR' (map \\<alpha> xs);\n        x1 = map \\<alpha> x1a \\<and>\n        set x1a \\<subseteq> set xs \\<and>\n        set x1 \\<subseteq> \\<alpha> ` set xs \\<and>\n        (\\<forall>x\\<in>set xs - set x1a.\n            \\<forall>xa\\<in>set x1a. RR x xa) \\<and>\n        (\\<forall>x\\<in>\\<alpha> ` set xs - set x1.\n            \\<forall>xa\\<in>set x1. RR' x xa) \\<and>\n        ((set x1a, x2a), set x1, x2) \\<in> R;\n        FOREACH_cond c (x1a, x2a); FOREACH_cond c' (map \\<alpha> x1a, x2);\n        (\\<exists>xs'. xs = xs' @ x1a) \\<and> \\<Phi> (set x1a) x2a;\n        (\\<exists>xs'. map \\<alpha> xs = xs' @ map \\<alpha> x1a) \\<and>\n        \\<Phi>' (\\<alpha> ` set x1a) x2;\n        x' = (map \\<alpha> x1a, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x\\<in>set x1a - {hd x1a}. RR (hd x1a) x\n 2. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>xsa = map \\<alpha> xs;\n        distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs;\n        distinct (map \\<alpha> xs) \\<and> sorted_wrt RR' (map \\<alpha> xs);\n        x1 = map \\<alpha> x1a \\<and>\n        set x1a \\<subseteq> set xs \\<and>\n        set x1 \\<subseteq> \\<alpha> ` set xs \\<and>\n        (\\<forall>x\\<in>set xs - set x1a.\n            \\<forall>xa\\<in>set x1a. RR x xa) \\<and>\n        (\\<forall>x\\<in>\\<alpha> ` set xs - set x1.\n            \\<forall>xa\\<in>set x1. RR' x xa) \\<and>\n        ((set x1a, x2a), set x1, x2) \\<in> R;\n        FOREACH_cond c (x1a, x2a); FOREACH_cond c' (map \\<alpha> x1a, x2);\n        (\\<exists>xs'. xs = xs' @ x1a) \\<and> \\<Phi> (set x1a) x2a;\n        (\\<exists>xs'. map \\<alpha> xs = xs' @ map \\<alpha> x1a) \\<and>\n        \\<Phi>' (\\<alpha> ` set x1a) x2;\n        x' = (map \\<alpha> x1a, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> hd (map \\<alpha> x1a) \\<in> \\<alpha> ` set x1a\n 3. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>xsa = map \\<alpha> xs;\n        distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs;\n        distinct (map \\<alpha> xs) \\<and> sorted_wrt RR' (map \\<alpha> xs);\n        x1 = map \\<alpha> x1a \\<and>\n        set x1a \\<subseteq> set xs \\<and>\n        set x1 \\<subseteq> \\<alpha> ` set xs \\<and>\n        (\\<forall>x\\<in>set xs - set x1a.\n            \\<forall>xa\\<in>set x1a. RR x xa) \\<and>\n        (\\<forall>x\\<in>\\<alpha> ` set xs - set x1.\n            \\<forall>xa\\<in>set x1. RR' x xa) \\<and>\n        ((set x1a, x2a), set x1, x2) \\<in> R;\n        FOREACH_cond c (x1a, x2a); FOREACH_cond c' (map \\<alpha> x1a, x2);\n        (\\<exists>xs'. xs = xs' @ x1a) \\<and> \\<Phi> (set x1a) x2a;\n        (\\<exists>xs'. map \\<alpha> xs = xs' @ map \\<alpha> x1a) \\<and>\n        \\<Phi>' (\\<alpha> ` set x1a) x2;\n        x' = (map \\<alpha> x1a, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x\\<in>\\<alpha> ` set x1a -\n  {hd (map \\<alpha> x1a)}.\n                            RR' (hd (map \\<alpha> x1a)) x\n 4. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>xsa = map \\<alpha> xs;\n        distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs;\n        distinct (map \\<alpha> xs) \\<and> sorted_wrt RR' (map \\<alpha> xs);\n        x1 = map \\<alpha> x1a \\<and>\n        set x1a \\<subseteq> set xs \\<and>\n        set x1 \\<subseteq> \\<alpha> ` set xs \\<and>\n        (\\<forall>x\\<in>set xs - set x1a.\n            \\<forall>xa\\<in>set x1a. RR x xa) \\<and>\n        (\\<forall>x\\<in>\\<alpha> ` set xs - set x1.\n            \\<forall>xa\\<in>set x1. RR' x xa) \\<and>\n        ((set x1a, x2a), set x1, x2) \\<in> R;\n        FOREACH_cond c (x1a, x2a); FOREACH_cond c' (map \\<alpha> x1a, x2);\n        (\\<exists>xs'. xs = xs' @ x1a) \\<and> \\<Phi> (set x1a) x2a;\n        (\\<exists>xs'. map \\<alpha> xs = xs' @ map \\<alpha> x1a) \\<and>\n        \\<Phi>' (\\<alpha> ` set x1a) x2;\n        x' = (map \\<alpha> x1a, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> c x2a\n 5. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>xsa = map \\<alpha> xs;\n        distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs;\n        distinct (map \\<alpha> xs) \\<and> sorted_wrt RR' (map \\<alpha> xs);\n        x1 = map \\<alpha> x1a \\<and>\n        set x1a \\<subseteq> set xs \\<and>\n        set x1 \\<subseteq> \\<alpha> ` set xs \\<and>\n        (\\<forall>x\\<in>set xs - set x1a.\n            \\<forall>xa\\<in>set x1a. RR x xa) \\<and>\n        (\\<forall>x\\<in>\\<alpha> ` set xs - set x1.\n            \\<forall>xa\\<in>set x1. RR' x xa) \\<and>\n        ((set x1a, x2a), set x1, x2) \\<in> R;\n        FOREACH_cond c (x1a, x2a); FOREACH_cond c' (map \\<alpha> x1a, x2);\n        (\\<exists>xs'. xs = xs' @ x1a) \\<and> \\<Phi> (set x1a) x2a;\n        (\\<exists>xs'. map \\<alpha> xs = xs' @ map \\<alpha> x1a) \\<and>\n        \\<Phi>' (\\<alpha> ` set x1a) x2;\n        x' = (map \\<alpha> x1a, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> c' x2\n 6. \\<And>xs xsa x x' x1 x2 x1a x2a \\<sigma>' \\<sigma>''.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n        FOREACH_cond c x; FOREACH_cond c' x';\n        case x of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>;\n        x' = (x1, x2); x = (x1a, x2a);\n        (\\<sigma>', \\<sigma>'')\n        \\<in> {(\\<sigma>, \\<sigma>').\n               ((set x1a - {hd x1a}, \\<sigma>),\n                \\<alpha> ` set x1a - {hd x1}, \\<sigma>')\n               \\<in> R}\\<rbrakk>\n       \\<Longrightarrow> ((tl x1a, \\<sigma>'), tl x1, \\<sigma>'')\n                         \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n                                xs' = map \\<alpha> xs \\<and>\n                                set xs \\<subseteq> S \\<and>\n                                set xs' \\<subseteq> S' \\<and>\n                                (\\<forall>x\\<in>S - set xs.\n                                    \\<forall>y\\<in>set xs. RR x y) \\<and>\n                                (\\<forall>x\\<in>S' - set xs'.\n                                    \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n                                ((set xs, \\<sigma>), set xs', \\<sigma>')\n                                \\<in> R}\n 7. \\<And>xs xsa x x'.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n        \\<not> FOREACH_cond c x; \\<not> FOREACH_cond c' x';\n        case x of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'.\n             xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> (x, x') \\<in> ?R'3 xs xsa\n 8. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x') \\<in> ?R'3 xs xsa; x' = (x1, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> (x2a, x2) \\<in> R'", "apply (clarsimp simp: FOREACH_cond_def)"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>x2 x1a x2a x xs'.\n       \\<lbrakk>c' x2; x \\<in> set x1a; \\<not> RR (hd x1a) x;\n        sorted_wrt RR' (map \\<alpha> xs' @ map \\<alpha> x1a);\n        x1a \\<noteq> []; c x2a; \\<Phi> (set x1a) x2a;\n        \\<Phi>' (\\<alpha> ` set x1a) x2; S = set xs' \\<union> set x1a;\n        sorted_wrt RR (xs' @ x1a);\n        \\<alpha> ` set x1a\n        \\<subseteq> \\<alpha> ` (set xs' \\<union> set x1a);\n        \\<forall>x\\<in>set xs' \\<union> set x1a - set x1a.\n           \\<forall>xa\\<in>set x1a. RR x xa;\n        \\<forall>x\\<in>\\<alpha> ` (set xs' \\<union> set x1a) -\n                       \\<alpha> ` set x1a.\n           \\<forall>xa\\<in>set x1a. RR' x (\\<alpha> xa);\n        ((set x1a, x2a), \\<alpha> ` set x1a, x2) \\<in> R; distinct xs';\n        distinct (map \\<alpha> xs'); distinct x1a;\n        set xs' \\<inter> set x1a = {}; distinct (map \\<alpha> x1a);\n        \\<alpha> ` set xs' \\<inter> \\<alpha> ` set x1a = {}\\<rbrakk>\n       \\<Longrightarrow> x = hd x1a\n 2. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>xsa = map \\<alpha> xs;\n        distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs;\n        distinct (map \\<alpha> xs) \\<and> sorted_wrt RR' (map \\<alpha> xs);\n        x1 = map \\<alpha> x1a \\<and>\n        set x1a \\<subseteq> set xs \\<and>\n        set x1 \\<subseteq> \\<alpha> ` set xs \\<and>\n        (\\<forall>x\\<in>set xs - set x1a.\n            \\<forall>xa\\<in>set x1a. RR x xa) \\<and>\n        (\\<forall>x\\<in>\\<alpha> ` set xs - set x1.\n            \\<forall>xa\\<in>set x1. RR' x xa) \\<and>\n        ((set x1a, x2a), set x1, x2) \\<in> R;\n        FOREACH_cond c (x1a, x2a); FOREACH_cond c' (map \\<alpha> x1a, x2);\n        (\\<exists>xs'. xs = xs' @ x1a) \\<and> \\<Phi> (set x1a) x2a;\n        (\\<exists>xs'. map \\<alpha> xs = xs' @ map \\<alpha> x1a) \\<and>\n        \\<Phi>' (\\<alpha> ` set x1a) x2;\n        x' = (map \\<alpha> x1a, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> hd (map \\<alpha> x1a) \\<in> \\<alpha> ` set x1a\n 3. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>xsa = map \\<alpha> xs;\n        distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs;\n        distinct (map \\<alpha> xs) \\<and> sorted_wrt RR' (map \\<alpha> xs);\n        x1 = map \\<alpha> x1a \\<and>\n        set x1a \\<subseteq> set xs \\<and>\n        set x1 \\<subseteq> \\<alpha> ` set xs \\<and>\n        (\\<forall>x\\<in>set xs - set x1a.\n            \\<forall>xa\\<in>set x1a. RR x xa) \\<and>\n        (\\<forall>x\\<in>\\<alpha> ` set xs - set x1.\n            \\<forall>xa\\<in>set x1. RR' x xa) \\<and>\n        ((set x1a, x2a), set x1, x2) \\<in> R;\n        FOREACH_cond c (x1a, x2a); FOREACH_cond c' (map \\<alpha> x1a, x2);\n        (\\<exists>xs'. xs = xs' @ x1a) \\<and> \\<Phi> (set x1a) x2a;\n        (\\<exists>xs'. map \\<alpha> xs = xs' @ map \\<alpha> x1a) \\<and>\n        \\<Phi>' (\\<alpha> ` set x1a) x2;\n        x' = (map \\<alpha> x1a, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x\\<in>\\<alpha> ` set x1a -\n  {hd (map \\<alpha> x1a)}.\n                            RR' (hd (map \\<alpha> x1a)) x\n 4. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>xsa = map \\<alpha> xs;\n        distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs;\n        distinct (map \\<alpha> xs) \\<and> sorted_wrt RR' (map \\<alpha> xs);\n        x1 = map \\<alpha> x1a \\<and>\n        set x1a \\<subseteq> set xs \\<and>\n        set x1 \\<subseteq> \\<alpha> ` set xs \\<and>\n        (\\<forall>x\\<in>set xs - set x1a.\n            \\<forall>xa\\<in>set x1a. RR x xa) \\<and>\n        (\\<forall>x\\<in>\\<alpha> ` set xs - set x1.\n            \\<forall>xa\\<in>set x1. RR' x xa) \\<and>\n        ((set x1a, x2a), set x1, x2) \\<in> R;\n        FOREACH_cond c (x1a, x2a); FOREACH_cond c' (map \\<alpha> x1a, x2);\n        (\\<exists>xs'. xs = xs' @ x1a) \\<and> \\<Phi> (set x1a) x2a;\n        (\\<exists>xs'. map \\<alpha> xs = xs' @ map \\<alpha> x1a) \\<and>\n        \\<Phi>' (\\<alpha> ` set x1a) x2;\n        x' = (map \\<alpha> x1a, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> c x2a\n 5. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>xsa = map \\<alpha> xs;\n        distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs;\n        distinct (map \\<alpha> xs) \\<and> sorted_wrt RR' (map \\<alpha> xs);\n        x1 = map \\<alpha> x1a \\<and>\n        set x1a \\<subseteq> set xs \\<and>\n        set x1 \\<subseteq> \\<alpha> ` set xs \\<and>\n        (\\<forall>x\\<in>set xs - set x1a.\n            \\<forall>xa\\<in>set x1a. RR x xa) \\<and>\n        (\\<forall>x\\<in>\\<alpha> ` set xs - set x1.\n            \\<forall>xa\\<in>set x1. RR' x xa) \\<and>\n        ((set x1a, x2a), set x1, x2) \\<in> R;\n        FOREACH_cond c (x1a, x2a); FOREACH_cond c' (map \\<alpha> x1a, x2);\n        (\\<exists>xs'. xs = xs' @ x1a) \\<and> \\<Phi> (set x1a) x2a;\n        (\\<exists>xs'. map \\<alpha> xs = xs' @ map \\<alpha> x1a) \\<and>\n        \\<Phi>' (\\<alpha> ` set x1a) x2;\n        x' = (map \\<alpha> x1a, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> c' x2\n 6. \\<And>xs xsa x x' x1 x2 x1a x2a \\<sigma>' \\<sigma>''.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n        FOREACH_cond c x; FOREACH_cond c' x';\n        case x of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>;\n        x' = (x1, x2); x = (x1a, x2a);\n        (\\<sigma>', \\<sigma>'')\n        \\<in> {(\\<sigma>, \\<sigma>').\n               ((set x1a - {hd x1a}, \\<sigma>),\n                \\<alpha> ` set x1a - {hd x1}, \\<sigma>')\n               \\<in> R}\\<rbrakk>\n       \\<Longrightarrow> ((tl x1a, \\<sigma>'), tl x1, \\<sigma>'')\n                         \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n                                xs' = map \\<alpha> xs \\<and>\n                                set xs \\<subseteq> S \\<and>\n                                set xs' \\<subseteq> S' \\<and>\n                                (\\<forall>x\\<in>S - set xs.\n                                    \\<forall>y\\<in>set xs. RR x y) \\<and>\n                                (\\<forall>x\\<in>S' - set xs'.\n                                    \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n                                ((set xs, \\<sigma>), set xs', \\<sigma>')\n                                \\<in> R}\n 7. \\<And>xs xsa x x'.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n        \\<not> FOREACH_cond c x; \\<not> FOREACH_cond c' x';\n        case x of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'.\n             xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> (x, x') \\<in> ?R'3 xs xsa\n 8. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x') \\<in> ?R'3 xs xsa; x' = (x1, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> (x2a, x2) \\<in> R'", "apply (rule ccontr)"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>x2 x1a x2a x xs'.\n       \\<lbrakk>c' x2; x \\<in> set x1a; \\<not> RR (hd x1a) x;\n        sorted_wrt RR' (map \\<alpha> xs' @ map \\<alpha> x1a);\n        x1a \\<noteq> []; c x2a; \\<Phi> (set x1a) x2a;\n        \\<Phi>' (\\<alpha> ` set x1a) x2; S = set xs' \\<union> set x1a;\n        sorted_wrt RR (xs' @ x1a);\n        \\<alpha> ` set x1a\n        \\<subseteq> \\<alpha> ` (set xs' \\<union> set x1a);\n        \\<forall>x\\<in>set xs' \\<union> set x1a - set x1a.\n           \\<forall>xa\\<in>set x1a. RR x xa;\n        \\<forall>x\\<in>\\<alpha> ` (set xs' \\<union> set x1a) -\n                       \\<alpha> ` set x1a.\n           \\<forall>xa\\<in>set x1a. RR' x (\\<alpha> xa);\n        ((set x1a, x2a), \\<alpha> ` set x1a, x2) \\<in> R; distinct xs';\n        distinct (map \\<alpha> xs'); distinct x1a;\n        set xs' \\<inter> set x1a = {}; distinct (map \\<alpha> x1a);\n        \\<alpha> ` set xs' \\<inter> \\<alpha> ` set x1a = {};\n        x \\<noteq> hd x1a\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>xsa = map \\<alpha> xs;\n        distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs;\n        distinct (map \\<alpha> xs) \\<and> sorted_wrt RR' (map \\<alpha> xs);\n        x1 = map \\<alpha> x1a \\<and>\n        set x1a \\<subseteq> set xs \\<and>\n        set x1 \\<subseteq> \\<alpha> ` set xs \\<and>\n        (\\<forall>x\\<in>set xs - set x1a.\n            \\<forall>xa\\<in>set x1a. RR x xa) \\<and>\n        (\\<forall>x\\<in>\\<alpha> ` set xs - set x1.\n            \\<forall>xa\\<in>set x1. RR' x xa) \\<and>\n        ((set x1a, x2a), set x1, x2) \\<in> R;\n        FOREACH_cond c (x1a, x2a); FOREACH_cond c' (map \\<alpha> x1a, x2);\n        (\\<exists>xs'. xs = xs' @ x1a) \\<and> \\<Phi> (set x1a) x2a;\n        (\\<exists>xs'. map \\<alpha> xs = xs' @ map \\<alpha> x1a) \\<and>\n        \\<Phi>' (\\<alpha> ` set x1a) x2;\n        x' = (map \\<alpha> x1a, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> hd (map \\<alpha> x1a) \\<in> \\<alpha> ` set x1a\n 3. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>xsa = map \\<alpha> xs;\n        distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs;\n        distinct (map \\<alpha> xs) \\<and> sorted_wrt RR' (map \\<alpha> xs);\n        x1 = map \\<alpha> x1a \\<and>\n        set x1a \\<subseteq> set xs \\<and>\n        set x1 \\<subseteq> \\<alpha> ` set xs \\<and>\n        (\\<forall>x\\<in>set xs - set x1a.\n            \\<forall>xa\\<in>set x1a. RR x xa) \\<and>\n        (\\<forall>x\\<in>\\<alpha> ` set xs - set x1.\n            \\<forall>xa\\<in>set x1. RR' x xa) \\<and>\n        ((set x1a, x2a), set x1, x2) \\<in> R;\n        FOREACH_cond c (x1a, x2a); FOREACH_cond c' (map \\<alpha> x1a, x2);\n        (\\<exists>xs'. xs = xs' @ x1a) \\<and> \\<Phi> (set x1a) x2a;\n        (\\<exists>xs'. map \\<alpha> xs = xs' @ map \\<alpha> x1a) \\<and>\n        \\<Phi>' (\\<alpha> ` set x1a) x2;\n        x' = (map \\<alpha> x1a, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x\\<in>\\<alpha> ` set x1a -\n  {hd (map \\<alpha> x1a)}.\n                            RR' (hd (map \\<alpha> x1a)) x\n 4. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>xsa = map \\<alpha> xs;\n        distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs;\n        distinct (map \\<alpha> xs) \\<and> sorted_wrt RR' (map \\<alpha> xs);\n        x1 = map \\<alpha> x1a \\<and>\n        set x1a \\<subseteq> set xs \\<and>\n        set x1 \\<subseteq> \\<alpha> ` set xs \\<and>\n        (\\<forall>x\\<in>set xs - set x1a.\n            \\<forall>xa\\<in>set x1a. RR x xa) \\<and>\n        (\\<forall>x\\<in>\\<alpha> ` set xs - set x1.\n            \\<forall>xa\\<in>set x1. RR' x xa) \\<and>\n        ((set x1a, x2a), set x1, x2) \\<in> R;\n        FOREACH_cond c (x1a, x2a); FOREACH_cond c' (map \\<alpha> x1a, x2);\n        (\\<exists>xs'. xs = xs' @ x1a) \\<and> \\<Phi> (set x1a) x2a;\n        (\\<exists>xs'. map \\<alpha> xs = xs' @ map \\<alpha> x1a) \\<and>\n        \\<Phi>' (\\<alpha> ` set x1a) x2;\n        x' = (map \\<alpha> x1a, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> c x2a\n 5. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>xsa = map \\<alpha> xs;\n        distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs;\n        distinct (map \\<alpha> xs) \\<and> sorted_wrt RR' (map \\<alpha> xs);\n        x1 = map \\<alpha> x1a \\<and>\n        set x1a \\<subseteq> set xs \\<and>\n        set x1 \\<subseteq> \\<alpha> ` set xs \\<and>\n        (\\<forall>x\\<in>set xs - set x1a.\n            \\<forall>xa\\<in>set x1a. RR x xa) \\<and>\n        (\\<forall>x\\<in>\\<alpha> ` set xs - set x1.\n            \\<forall>xa\\<in>set x1. RR' x xa) \\<and>\n        ((set x1a, x2a), set x1, x2) \\<in> R;\n        FOREACH_cond c (x1a, x2a); FOREACH_cond c' (map \\<alpha> x1a, x2);\n        (\\<exists>xs'. xs = xs' @ x1a) \\<and> \\<Phi> (set x1a) x2a;\n        (\\<exists>xs'. map \\<alpha> xs = xs' @ map \\<alpha> x1a) \\<and>\n        \\<Phi>' (\\<alpha> ` set x1a) x2;\n        x' = (map \\<alpha> x1a, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> c' x2\n 6. \\<And>xs xsa x x' x1 x2 x1a x2a \\<sigma>' \\<sigma>''.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n        FOREACH_cond c x; FOREACH_cond c' x';\n        case x of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>;\n        x' = (x1, x2); x = (x1a, x2a);\n        (\\<sigma>', \\<sigma>'')\n        \\<in> {(\\<sigma>, \\<sigma>').\n               ((set x1a - {hd x1a}, \\<sigma>),\n                \\<alpha> ` set x1a - {hd x1}, \\<sigma>')\n               \\<in> R}\\<rbrakk>\n       \\<Longrightarrow> ((tl x1a, \\<sigma>'), tl x1, \\<sigma>'')\n                         \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n                                xs' = map \\<alpha> xs \\<and>\n                                set xs \\<subseteq> S \\<and>\n                                set xs' \\<subseteq> S' \\<and>\n                                (\\<forall>x\\<in>S - set xs.\n                                    \\<forall>y\\<in>set xs. RR x y) \\<and>\n                                (\\<forall>x\\<in>S' - set xs'.\n                                    \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n                                ((set xs, \\<sigma>), set xs', \\<sigma>')\n                                \\<in> R}\n 7. \\<And>xs xsa x x'.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n        \\<not> FOREACH_cond c x; \\<not> FOREACH_cond c' x';\n        case x of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'.\n             xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> (x, x') \\<in> ?R'3 xs xsa\n 8. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x') \\<in> ?R'3 xs xsa; x' = (x1, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> (x2a, x2) \\<in> R'", "apply (rename_tac a b d e f)"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>a b d e f.\n       \\<lbrakk>c' a; e \\<in> set b; \\<not> RR (hd b) e;\n        sorted_wrt RR' (map \\<alpha> f @ map \\<alpha> b); b \\<noteq> [];\n        c d; \\<Phi> (set b) d; \\<Phi>' (\\<alpha> ` set b) a;\n        S = set f \\<union> set b; sorted_wrt RR (f @ b);\n        \\<alpha> ` set b \\<subseteq> \\<alpha> ` (set f \\<union> set b);\n        \\<forall>x\\<in>set f \\<union> set b - set b.\n           \\<forall>xa\\<in>set b. RR x xa;\n        \\<forall>x\\<in>\\<alpha> ` (set f \\<union> set b) - \\<alpha> ` set b.\n           \\<forall>xa\\<in>set b. RR' x (\\<alpha> xa);\n        ((set b, d), \\<alpha> ` set b, a) \\<in> R; distinct f;\n        distinct (map \\<alpha> f); distinct b; set f \\<inter> set b = {};\n        distinct (map \\<alpha> b);\n        \\<alpha> ` set f \\<inter> \\<alpha> ` set b = {};\n        e \\<noteq> hd b\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>xsa = map \\<alpha> xs;\n        distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs;\n        distinct (map \\<alpha> xs) \\<and> sorted_wrt RR' (map \\<alpha> xs);\n        x1 = map \\<alpha> x1a \\<and>\n        set x1a \\<subseteq> set xs \\<and>\n        set x1 \\<subseteq> \\<alpha> ` set xs \\<and>\n        (\\<forall>x\\<in>set xs - set x1a.\n            \\<forall>xa\\<in>set x1a. RR x xa) \\<and>\n        (\\<forall>x\\<in>\\<alpha> ` set xs - set x1.\n            \\<forall>xa\\<in>set x1. RR' x xa) \\<and>\n        ((set x1a, x2a), set x1, x2) \\<in> R;\n        FOREACH_cond c (x1a, x2a); FOREACH_cond c' (map \\<alpha> x1a, x2);\n        (\\<exists>xs'. xs = xs' @ x1a) \\<and> \\<Phi> (set x1a) x2a;\n        (\\<exists>xs'. map \\<alpha> xs = xs' @ map \\<alpha> x1a) \\<and>\n        \\<Phi>' (\\<alpha> ` set x1a) x2;\n        x' = (map \\<alpha> x1a, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> hd (map \\<alpha> x1a) \\<in> \\<alpha> ` set x1a\n 3. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>xsa = map \\<alpha> xs;\n        distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs;\n        distinct (map \\<alpha> xs) \\<and> sorted_wrt RR' (map \\<alpha> xs);\n        x1 = map \\<alpha> x1a \\<and>\n        set x1a \\<subseteq> set xs \\<and>\n        set x1 \\<subseteq> \\<alpha> ` set xs \\<and>\n        (\\<forall>x\\<in>set xs - set x1a.\n            \\<forall>xa\\<in>set x1a. RR x xa) \\<and>\n        (\\<forall>x\\<in>\\<alpha> ` set xs - set x1.\n            \\<forall>xa\\<in>set x1. RR' x xa) \\<and>\n        ((set x1a, x2a), set x1, x2) \\<in> R;\n        FOREACH_cond c (x1a, x2a); FOREACH_cond c' (map \\<alpha> x1a, x2);\n        (\\<exists>xs'. xs = xs' @ x1a) \\<and> \\<Phi> (set x1a) x2a;\n        (\\<exists>xs'. map \\<alpha> xs = xs' @ map \\<alpha> x1a) \\<and>\n        \\<Phi>' (\\<alpha> ` set x1a) x2;\n        x' = (map \\<alpha> x1a, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x\\<in>\\<alpha> ` set x1a -\n  {hd (map \\<alpha> x1a)}.\n                            RR' (hd (map \\<alpha> x1a)) x\n 4. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>xsa = map \\<alpha> xs;\n        distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs;\n        distinct (map \\<alpha> xs) \\<and> sorted_wrt RR' (map \\<alpha> xs);\n        x1 = map \\<alpha> x1a \\<and>\n        set x1a \\<subseteq> set xs \\<and>\n        set x1 \\<subseteq> \\<alpha> ` set xs \\<and>\n        (\\<forall>x\\<in>set xs - set x1a.\n            \\<forall>xa\\<in>set x1a. RR x xa) \\<and>\n        (\\<forall>x\\<in>\\<alpha> ` set xs - set x1.\n            \\<forall>xa\\<in>set x1. RR' x xa) \\<and>\n        ((set x1a, x2a), set x1, x2) \\<in> R;\n        FOREACH_cond c (x1a, x2a); FOREACH_cond c' (map \\<alpha> x1a, x2);\n        (\\<exists>xs'. xs = xs' @ x1a) \\<and> \\<Phi> (set x1a) x2a;\n        (\\<exists>xs'. map \\<alpha> xs = xs' @ map \\<alpha> x1a) \\<and>\n        \\<Phi>' (\\<alpha> ` set x1a) x2;\n        x' = (map \\<alpha> x1a, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> c x2a\n 5. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>xsa = map \\<alpha> xs;\n        distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs;\n        distinct (map \\<alpha> xs) \\<and> sorted_wrt RR' (map \\<alpha> xs);\n        x1 = map \\<alpha> x1a \\<and>\n        set x1a \\<subseteq> set xs \\<and>\n        set x1 \\<subseteq> \\<alpha> ` set xs \\<and>\n        (\\<forall>x\\<in>set xs - set x1a.\n            \\<forall>xa\\<in>set x1a. RR x xa) \\<and>\n        (\\<forall>x\\<in>\\<alpha> ` set xs - set x1.\n            \\<forall>xa\\<in>set x1. RR' x xa) \\<and>\n        ((set x1a, x2a), set x1, x2) \\<in> R;\n        FOREACH_cond c (x1a, x2a); FOREACH_cond c' (map \\<alpha> x1a, x2);\n        (\\<exists>xs'. xs = xs' @ x1a) \\<and> \\<Phi> (set x1a) x2a;\n        (\\<exists>xs'. map \\<alpha> xs = xs' @ map \\<alpha> x1a) \\<and>\n        \\<Phi>' (\\<alpha> ` set x1a) x2;\n        x' = (map \\<alpha> x1a, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> c' x2\n 6. \\<And>xs xsa x x' x1 x2 x1a x2a \\<sigma>' \\<sigma>''.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n        FOREACH_cond c x; FOREACH_cond c' x';\n        case x of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>;\n        x' = (x1, x2); x = (x1a, x2a);\n        (\\<sigma>', \\<sigma>'')\n        \\<in> {(\\<sigma>, \\<sigma>').\n               ((set x1a - {hd x1a}, \\<sigma>),\n                \\<alpha> ` set x1a - {hd x1}, \\<sigma>')\n               \\<in> R}\\<rbrakk>\n       \\<Longrightarrow> ((tl x1a, \\<sigma>'), tl x1, \\<sigma>'')\n                         \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n                                xs' = map \\<alpha> xs \\<and>\n                                set xs \\<subseteq> S \\<and>\n                                set xs' \\<subseteq> S' \\<and>\n                                (\\<forall>x\\<in>S - set xs.\n                                    \\<forall>y\\<in>set xs. RR x y) \\<and>\n                                (\\<forall>x\\<in>S' - set xs'.\n                                    \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n                                ((set xs, \\<sigma>), set xs', \\<sigma>')\n                                \\<in> R}\n 7. \\<And>xs xsa x x'.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n        \\<not> FOREACH_cond c x; \\<not> FOREACH_cond c' x';\n        case x of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'.\n             xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> (x, x') \\<in> ?R'3 xs xsa\n 8. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x') \\<in> ?R'3 xs xsa; x' = (x1, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> (x2a, x2) \\<in> R'", "apply (case_tac b)"], ["proof (prove)\ngoal (9 subgoals):\n 1. \\<And>a b d e f.\n       \\<lbrakk>c' a; e \\<in> set b; \\<not> RR (hd b) e;\n        sorted_wrt RR' (map \\<alpha> f @ map \\<alpha> b); b \\<noteq> [];\n        c d; \\<Phi> (set b) d; \\<Phi>' (\\<alpha> ` set b) a;\n        S = set f \\<union> set b; sorted_wrt RR (f @ b);\n        \\<alpha> ` set b \\<subseteq> \\<alpha> ` (set f \\<union> set b);\n        \\<forall>x\\<in>set f \\<union> set b - set b.\n           \\<forall>xa\\<in>set b. RR x xa;\n        \\<forall>x\\<in>\\<alpha> ` (set f \\<union> set b) - \\<alpha> ` set b.\n           \\<forall>xa\\<in>set b. RR' x (\\<alpha> xa);\n        ((set b, d), \\<alpha> ` set b, a) \\<in> R; distinct f;\n        distinct (map \\<alpha> f); distinct b; set f \\<inter> set b = {};\n        distinct (map \\<alpha> b);\n        \\<alpha> ` set f \\<inter> \\<alpha> ` set b = {}; e \\<noteq> hd b;\n        b = []\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>a b d e f aa list.\n       \\<lbrakk>c' a; e \\<in> set b; \\<not> RR (hd b) e;\n        sorted_wrt RR' (map \\<alpha> f @ map \\<alpha> b); b \\<noteq> [];\n        c d; \\<Phi> (set b) d; \\<Phi>' (\\<alpha> ` set b) a;\n        S = set f \\<union> set b; sorted_wrt RR (f @ b);\n        \\<alpha> ` set b \\<subseteq> \\<alpha> ` (set f \\<union> set b);\n        \\<forall>x\\<in>set f \\<union> set b - set b.\n           \\<forall>xa\\<in>set b. RR x xa;\n        \\<forall>x\\<in>\\<alpha> ` (set f \\<union> set b) - \\<alpha> ` set b.\n           \\<forall>xa\\<in>set b. RR' x (\\<alpha> xa);\n        ((set b, d), \\<alpha> ` set b, a) \\<in> R; distinct f;\n        distinct (map \\<alpha> f); distinct b; set f \\<inter> set b = {};\n        distinct (map \\<alpha> b);\n        \\<alpha> ` set f \\<inter> \\<alpha> ` set b = {}; e \\<noteq> hd b;\n        b = aa # list\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>xsa = map \\<alpha> xs;\n        distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs;\n        distinct (map \\<alpha> xs) \\<and> sorted_wrt RR' (map \\<alpha> xs);\n        x1 = map \\<alpha> x1a \\<and>\n        set x1a \\<subseteq> set xs \\<and>\n        set x1 \\<subseteq> \\<alpha> ` set xs \\<and>\n        (\\<forall>x\\<in>set xs - set x1a.\n            \\<forall>xa\\<in>set x1a. RR x xa) \\<and>\n        (\\<forall>x\\<in>\\<alpha> ` set xs - set x1.\n            \\<forall>xa\\<in>set x1. RR' x xa) \\<and>\n        ((set x1a, x2a), set x1, x2) \\<in> R;\n        FOREACH_cond c (x1a, x2a); FOREACH_cond c' (map \\<alpha> x1a, x2);\n        (\\<exists>xs'. xs = xs' @ x1a) \\<and> \\<Phi> (set x1a) x2a;\n        (\\<exists>xs'. map \\<alpha> xs = xs' @ map \\<alpha> x1a) \\<and>\n        \\<Phi>' (\\<alpha> ` set x1a) x2;\n        x' = (map \\<alpha> x1a, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> hd (map \\<alpha> x1a) \\<in> \\<alpha> ` set x1a\n 4. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>xsa = map \\<alpha> xs;\n        distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs;\n        distinct (map \\<alpha> xs) \\<and> sorted_wrt RR' (map \\<alpha> xs);\n        x1 = map \\<alpha> x1a \\<and>\n        set x1a \\<subseteq> set xs \\<and>\n        set x1 \\<subseteq> \\<alpha> ` set xs \\<and>\n        (\\<forall>x\\<in>set xs - set x1a.\n            \\<forall>xa\\<in>set x1a. RR x xa) \\<and>\n        (\\<forall>x\\<in>\\<alpha> ` set xs - set x1.\n            \\<forall>xa\\<in>set x1. RR' x xa) \\<and>\n        ((set x1a, x2a), set x1, x2) \\<in> R;\n        FOREACH_cond c (x1a, x2a); FOREACH_cond c' (map \\<alpha> x1a, x2);\n        (\\<exists>xs'. xs = xs' @ x1a) \\<and> \\<Phi> (set x1a) x2a;\n        (\\<exists>xs'. map \\<alpha> xs = xs' @ map \\<alpha> x1a) \\<and>\n        \\<Phi>' (\\<alpha> ` set x1a) x2;\n        x' = (map \\<alpha> x1a, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x\\<in>\\<alpha> ` set x1a -\n  {hd (map \\<alpha> x1a)}.\n                            RR' (hd (map \\<alpha> x1a)) x\n 5. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>xsa = map \\<alpha> xs;\n        distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs;\n        distinct (map \\<alpha> xs) \\<and> sorted_wrt RR' (map \\<alpha> xs);\n        x1 = map \\<alpha> x1a \\<and>\n        set x1a \\<subseteq> set xs \\<and>\n        set x1 \\<subseteq> \\<alpha> ` set xs \\<and>\n        (\\<forall>x\\<in>set xs - set x1a.\n            \\<forall>xa\\<in>set x1a. RR x xa) \\<and>\n        (\\<forall>x\\<in>\\<alpha> ` set xs - set x1.\n            \\<forall>xa\\<in>set x1. RR' x xa) \\<and>\n        ((set x1a, x2a), set x1, x2) \\<in> R;\n        FOREACH_cond c (x1a, x2a); FOREACH_cond c' (map \\<alpha> x1a, x2);\n        (\\<exists>xs'. xs = xs' @ x1a) \\<and> \\<Phi> (set x1a) x2a;\n        (\\<exists>xs'. map \\<alpha> xs = xs' @ map \\<alpha> x1a) \\<and>\n        \\<Phi>' (\\<alpha> ` set x1a) x2;\n        x' = (map \\<alpha> x1a, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> c x2a\n 6. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>xsa = map \\<alpha> xs;\n        distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs;\n        distinct (map \\<alpha> xs) \\<and> sorted_wrt RR' (map \\<alpha> xs);\n        x1 = map \\<alpha> x1a \\<and>\n        set x1a \\<subseteq> set xs \\<and>\n        set x1 \\<subseteq> \\<alpha> ` set xs \\<and>\n        (\\<forall>x\\<in>set xs - set x1a.\n            \\<forall>xa\\<in>set x1a. RR x xa) \\<and>\n        (\\<forall>x\\<in>\\<alpha> ` set xs - set x1.\n            \\<forall>xa\\<in>set x1. RR' x xa) \\<and>\n        ((set x1a, x2a), set x1, x2) \\<in> R;\n        FOREACH_cond c (x1a, x2a); FOREACH_cond c' (map \\<alpha> x1a, x2);\n        (\\<exists>xs'. xs = xs' @ x1a) \\<and> \\<Phi> (set x1a) x2a;\n        (\\<exists>xs'. map \\<alpha> xs = xs' @ map \\<alpha> x1a) \\<and>\n        \\<Phi>' (\\<alpha> ` set x1a) x2;\n        x' = (map \\<alpha> x1a, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> c' x2\n 7. \\<And>xs xsa x x' x1 x2 x1a x2a \\<sigma>' \\<sigma>''.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n        FOREACH_cond c x; FOREACH_cond c' x';\n        case x of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>;\n        x' = (x1, x2); x = (x1a, x2a);\n        (\\<sigma>', \\<sigma>'')\n        \\<in> {(\\<sigma>, \\<sigma>').\n               ((set x1a - {hd x1a}, \\<sigma>),\n                \\<alpha> ` set x1a - {hd x1}, \\<sigma>')\n               \\<in> R}\\<rbrakk>\n       \\<Longrightarrow> ((tl x1a, \\<sigma>'), tl x1, \\<sigma>'')\n                         \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n                                xs' = map \\<alpha> xs \\<and>\n                                set xs \\<subseteq> S \\<and>\n                                set xs' \\<subseteq> S' \\<and>\n                                (\\<forall>x\\<in>S - set xs.\n                                    \\<forall>y\\<in>set xs. RR x y) \\<and>\n                                (\\<forall>x\\<in>S' - set xs'.\n                                    \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n                                ((set xs, \\<sigma>), set xs', \\<sigma>')\n                                \\<in> R}\n 8. \\<And>xs xsa x x'.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n        \\<not> FOREACH_cond c x; \\<not> FOREACH_cond c' x';\n        case x of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'.\n             xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> (x, x') \\<in> ?R'3 xs xsa\n 9. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x') \\<in> ?R'3 xs xsa; x' = (x1, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> (x2a, x2) \\<in> R'", "apply (auto simp: sorted_wrt_append) [2]"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>xsa = map \\<alpha> xs;\n        distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs;\n        distinct (map \\<alpha> xs) \\<and> sorted_wrt RR' (map \\<alpha> xs);\n        x1 = map \\<alpha> x1a \\<and>\n        set x1a \\<subseteq> set xs \\<and>\n        set x1 \\<subseteq> \\<alpha> ` set xs \\<and>\n        (\\<forall>x\\<in>set xs - set x1a.\n            \\<forall>xa\\<in>set x1a. RR x xa) \\<and>\n        (\\<forall>x\\<in>\\<alpha> ` set xs - set x1.\n            \\<forall>xa\\<in>set x1. RR' x xa) \\<and>\n        ((set x1a, x2a), set x1, x2) \\<in> R;\n        FOREACH_cond c (x1a, x2a); FOREACH_cond c' (map \\<alpha> x1a, x2);\n        (\\<exists>xs'. xs = xs' @ x1a) \\<and> \\<Phi> (set x1a) x2a;\n        (\\<exists>xs'. map \\<alpha> xs = xs' @ map \\<alpha> x1a) \\<and>\n        \\<Phi>' (\\<alpha> ` set x1a) x2;\n        x' = (map \\<alpha> x1a, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> hd (map \\<alpha> x1a) \\<in> \\<alpha> ` set x1a\n 2. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>xsa = map \\<alpha> xs;\n        distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs;\n        distinct (map \\<alpha> xs) \\<and> sorted_wrt RR' (map \\<alpha> xs);\n        x1 = map \\<alpha> x1a \\<and>\n        set x1a \\<subseteq> set xs \\<and>\n        set x1 \\<subseteq> \\<alpha> ` set xs \\<and>\n        (\\<forall>x\\<in>set xs - set x1a.\n            \\<forall>xa\\<in>set x1a. RR x xa) \\<and>\n        (\\<forall>x\\<in>\\<alpha> ` set xs - set x1.\n            \\<forall>xa\\<in>set x1. RR' x xa) \\<and>\n        ((set x1a, x2a), set x1, x2) \\<in> R;\n        FOREACH_cond c (x1a, x2a); FOREACH_cond c' (map \\<alpha> x1a, x2);\n        (\\<exists>xs'. xs = xs' @ x1a) \\<and> \\<Phi> (set x1a) x2a;\n        (\\<exists>xs'. map \\<alpha> xs = xs' @ map \\<alpha> x1a) \\<and>\n        \\<Phi>' (\\<alpha> ` set x1a) x2;\n        x' = (map \\<alpha> x1a, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x\\<in>\\<alpha> ` set x1a -\n  {hd (map \\<alpha> x1a)}.\n                            RR' (hd (map \\<alpha> x1a)) x\n 3. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>xsa = map \\<alpha> xs;\n        distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs;\n        distinct (map \\<alpha> xs) \\<and> sorted_wrt RR' (map \\<alpha> xs);\n        x1 = map \\<alpha> x1a \\<and>\n        set x1a \\<subseteq> set xs \\<and>\n        set x1 \\<subseteq> \\<alpha> ` set xs \\<and>\n        (\\<forall>x\\<in>set xs - set x1a.\n            \\<forall>xa\\<in>set x1a. RR x xa) \\<and>\n        (\\<forall>x\\<in>\\<alpha> ` set xs - set x1.\n            \\<forall>xa\\<in>set x1. RR' x xa) \\<and>\n        ((set x1a, x2a), set x1, x2) \\<in> R;\n        FOREACH_cond c (x1a, x2a); FOREACH_cond c' (map \\<alpha> x1a, x2);\n        (\\<exists>xs'. xs = xs' @ x1a) \\<and> \\<Phi> (set x1a) x2a;\n        (\\<exists>xs'. map \\<alpha> xs = xs' @ map \\<alpha> x1a) \\<and>\n        \\<Phi>' (\\<alpha> ` set x1a) x2;\n        x' = (map \\<alpha> x1a, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> c x2a\n 4. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>xsa = map \\<alpha> xs;\n        distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs;\n        distinct (map \\<alpha> xs) \\<and> sorted_wrt RR' (map \\<alpha> xs);\n        x1 = map \\<alpha> x1a \\<and>\n        set x1a \\<subseteq> set xs \\<and>\n        set x1 \\<subseteq> \\<alpha> ` set xs \\<and>\n        (\\<forall>x\\<in>set xs - set x1a.\n            \\<forall>xa\\<in>set x1a. RR x xa) \\<and>\n        (\\<forall>x\\<in>\\<alpha> ` set xs - set x1.\n            \\<forall>xa\\<in>set x1. RR' x xa) \\<and>\n        ((set x1a, x2a), set x1, x2) \\<in> R;\n        FOREACH_cond c (x1a, x2a); FOREACH_cond c' (map \\<alpha> x1a, x2);\n        (\\<exists>xs'. xs = xs' @ x1a) \\<and> \\<Phi> (set x1a) x2a;\n        (\\<exists>xs'. map \\<alpha> xs = xs' @ map \\<alpha> x1a) \\<and>\n        \\<Phi>' (\\<alpha> ` set x1a) x2;\n        x' = (map \\<alpha> x1a, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> c' x2\n 5. \\<And>xs xsa x x' x1 x2 x1a x2a \\<sigma>' \\<sigma>''.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n        FOREACH_cond c x; FOREACH_cond c' x';\n        case x of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>;\n        x' = (x1, x2); x = (x1a, x2a);\n        (\\<sigma>', \\<sigma>'')\n        \\<in> {(\\<sigma>, \\<sigma>').\n               ((set x1a - {hd x1a}, \\<sigma>),\n                \\<alpha> ` set x1a - {hd x1}, \\<sigma>')\n               \\<in> R}\\<rbrakk>\n       \\<Longrightarrow> ((tl x1a, \\<sigma>'), tl x1, \\<sigma>'')\n                         \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n                                xs' = map \\<alpha> xs \\<and>\n                                set xs \\<subseteq> S \\<and>\n                                set xs' \\<subseteq> S' \\<and>\n                                (\\<forall>x\\<in>S - set xs.\n                                    \\<forall>y\\<in>set xs. RR x y) \\<and>\n                                (\\<forall>x\\<in>S' - set xs'.\n                                    \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n                                ((set xs, \\<sigma>), set xs', \\<sigma>')\n                                \\<in> R}\n 6. \\<And>xs xsa x x'.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n        \\<not> FOREACH_cond c x; \\<not> FOREACH_cond c' x';\n        case x of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'.\n             xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> (x, x') \\<in> ?R'3 xs xsa\n 7. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x') \\<in> ?R'3 xs xsa; x' = (x1, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> (x2a, x2) \\<in> R'", "apply (auto simp: FOREACH_cond_def) []"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>x2 x1a x2a xs'.\n       \\<lbrakk>c' x2; sorted_wrt RR' (map \\<alpha> xs' @ map \\<alpha> x1a);\n        x1a \\<noteq> []; c x2a; \\<Phi> (set x1a) x2a;\n        \\<Phi>' (\\<alpha> ` set x1a) x2; S = set xs' \\<union> set x1a;\n        sorted_wrt RR (xs' @ x1a);\n        \\<alpha> ` set x1a\n        \\<subseteq> \\<alpha> ` (set xs' \\<union> set x1a);\n        \\<forall>x\\<in>set xs' \\<union> set x1a - set x1a.\n           \\<forall>xa\\<in>set x1a. RR x xa;\n        \\<forall>x\\<in>\\<alpha> ` (set xs' \\<union> set x1a) -\n                       \\<alpha> ` set x1a.\n           \\<forall>xa\\<in>set x1a. RR' x (\\<alpha> xa);\n        ((set x1a, x2a), \\<alpha> ` set x1a, x2) \\<in> R; distinct xs';\n        distinct (map \\<alpha> xs'); distinct x1a;\n        set xs' \\<inter> set x1a = {}; distinct (map \\<alpha> x1a);\n        \\<alpha> ` set xs' \\<inter> \\<alpha> ` set x1a = {}\\<rbrakk>\n       \\<Longrightarrow> hd (map \\<alpha> x1a) \\<in> \\<alpha> ` set x1a\n 2. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>xsa = map \\<alpha> xs;\n        distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs;\n        distinct (map \\<alpha> xs) \\<and> sorted_wrt RR' (map \\<alpha> xs);\n        x1 = map \\<alpha> x1a \\<and>\n        set x1a \\<subseteq> set xs \\<and>\n        set x1 \\<subseteq> \\<alpha> ` set xs \\<and>\n        (\\<forall>x\\<in>set xs - set x1a.\n            \\<forall>xa\\<in>set x1a. RR x xa) \\<and>\n        (\\<forall>x\\<in>\\<alpha> ` set xs - set x1.\n            \\<forall>xa\\<in>set x1. RR' x xa) \\<and>\n        ((set x1a, x2a), set x1, x2) \\<in> R;\n        FOREACH_cond c (x1a, x2a); FOREACH_cond c' (map \\<alpha> x1a, x2);\n        (\\<exists>xs'. xs = xs' @ x1a) \\<and> \\<Phi> (set x1a) x2a;\n        (\\<exists>xs'. map \\<alpha> xs = xs' @ map \\<alpha> x1a) \\<and>\n        \\<Phi>' (\\<alpha> ` set x1a) x2;\n        x' = (map \\<alpha> x1a, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x\\<in>\\<alpha> ` set x1a -\n  {hd (map \\<alpha> x1a)}.\n                            RR' (hd (map \\<alpha> x1a)) x\n 3. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>xsa = map \\<alpha> xs;\n        distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs;\n        distinct (map \\<alpha> xs) \\<and> sorted_wrt RR' (map \\<alpha> xs);\n        x1 = map \\<alpha> x1a \\<and>\n        set x1a \\<subseteq> set xs \\<and>\n        set x1 \\<subseteq> \\<alpha> ` set xs \\<and>\n        (\\<forall>x\\<in>set xs - set x1a.\n            \\<forall>xa\\<in>set x1a. RR x xa) \\<and>\n        (\\<forall>x\\<in>\\<alpha> ` set xs - set x1.\n            \\<forall>xa\\<in>set x1. RR' x xa) \\<and>\n        ((set x1a, x2a), set x1, x2) \\<in> R;\n        FOREACH_cond c (x1a, x2a); FOREACH_cond c' (map \\<alpha> x1a, x2);\n        (\\<exists>xs'. xs = xs' @ x1a) \\<and> \\<Phi> (set x1a) x2a;\n        (\\<exists>xs'. map \\<alpha> xs = xs' @ map \\<alpha> x1a) \\<and>\n        \\<Phi>' (\\<alpha> ` set x1a) x2;\n        x' = (map \\<alpha> x1a, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> c x2a\n 4. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>xsa = map \\<alpha> xs;\n        distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs;\n        distinct (map \\<alpha> xs) \\<and> sorted_wrt RR' (map \\<alpha> xs);\n        x1 = map \\<alpha> x1a \\<and>\n        set x1a \\<subseteq> set xs \\<and>\n        set x1 \\<subseteq> \\<alpha> ` set xs \\<and>\n        (\\<forall>x\\<in>set xs - set x1a.\n            \\<forall>xa\\<in>set x1a. RR x xa) \\<and>\n        (\\<forall>x\\<in>\\<alpha> ` set xs - set x1.\n            \\<forall>xa\\<in>set x1. RR' x xa) \\<and>\n        ((set x1a, x2a), set x1, x2) \\<in> R;\n        FOREACH_cond c (x1a, x2a); FOREACH_cond c' (map \\<alpha> x1a, x2);\n        (\\<exists>xs'. xs = xs' @ x1a) \\<and> \\<Phi> (set x1a) x2a;\n        (\\<exists>xs'. map \\<alpha> xs = xs' @ map \\<alpha> x1a) \\<and>\n        \\<Phi>' (\\<alpha> ` set x1a) x2;\n        x' = (map \\<alpha> x1a, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> c' x2\n 5. \\<And>xs xsa x x' x1 x2 x1a x2a \\<sigma>' \\<sigma>''.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n        FOREACH_cond c x; FOREACH_cond c' x';\n        case x of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>;\n        x' = (x1, x2); x = (x1a, x2a);\n        (\\<sigma>', \\<sigma>'')\n        \\<in> {(\\<sigma>, \\<sigma>').\n               ((set x1a - {hd x1a}, \\<sigma>),\n                \\<alpha> ` set x1a - {hd x1}, \\<sigma>')\n               \\<in> R}\\<rbrakk>\n       \\<Longrightarrow> ((tl x1a, \\<sigma>'), tl x1, \\<sigma>'')\n                         \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n                                xs' = map \\<alpha> xs \\<and>\n                                set xs \\<subseteq> S \\<and>\n                                set xs' \\<subseteq> S' \\<and>\n                                (\\<forall>x\\<in>S - set xs.\n                                    \\<forall>y\\<in>set xs. RR x y) \\<and>\n                                (\\<forall>x\\<in>S' - set xs'.\n                                    \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n                                ((set xs, \\<sigma>), set xs', \\<sigma>')\n                                \\<in> R}\n 6. \\<And>xs xsa x x'.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n        \\<not> FOREACH_cond c x; \\<not> FOREACH_cond c' x';\n        case x of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'.\n             xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> (x, x') \\<in> ?R'3 xs xsa\n 7. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x') \\<in> ?R'3 xs xsa; x' = (x1, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> (x2a, x2) \\<in> R'", "apply (rename_tac a b d e)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>a b d e.\n       \\<lbrakk>c' a; sorted_wrt RR' (map \\<alpha> e @ map \\<alpha> b);\n        b \\<noteq> []; c d; \\<Phi> (set b) d; \\<Phi>' (\\<alpha> ` set b) a;\n        S = set e \\<union> set b; sorted_wrt RR (e @ b);\n        \\<alpha> ` set b \\<subseteq> \\<alpha> ` (set e \\<union> set b);\n        \\<forall>x\\<in>set e \\<union> set b - set b.\n           \\<forall>xa\\<in>set b. RR x xa;\n        \\<forall>x\\<in>\\<alpha> ` (set e \\<union> set b) - \\<alpha> ` set b.\n           \\<forall>xa\\<in>set b. RR' x (\\<alpha> xa);\n        ((set b, d), \\<alpha> ` set b, a) \\<in> R; distinct e;\n        distinct (map \\<alpha> e); distinct b; set e \\<inter> set b = {};\n        distinct (map \\<alpha> b);\n        \\<alpha> ` set e \\<inter> \\<alpha> ` set b = {}\\<rbrakk>\n       \\<Longrightarrow> hd (map \\<alpha> b) \\<in> \\<alpha> ` set b\n 2. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>xsa = map \\<alpha> xs;\n        distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs;\n        distinct (map \\<alpha> xs) \\<and> sorted_wrt RR' (map \\<alpha> xs);\n        x1 = map \\<alpha> x1a \\<and>\n        set x1a \\<subseteq> set xs \\<and>\n        set x1 \\<subseteq> \\<alpha> ` set xs \\<and>\n        (\\<forall>x\\<in>set xs - set x1a.\n            \\<forall>xa\\<in>set x1a. RR x xa) \\<and>\n        (\\<forall>x\\<in>\\<alpha> ` set xs - set x1.\n            \\<forall>xa\\<in>set x1. RR' x xa) \\<and>\n        ((set x1a, x2a), set x1, x2) \\<in> R;\n        FOREACH_cond c (x1a, x2a); FOREACH_cond c' (map \\<alpha> x1a, x2);\n        (\\<exists>xs'. xs = xs' @ x1a) \\<and> \\<Phi> (set x1a) x2a;\n        (\\<exists>xs'. map \\<alpha> xs = xs' @ map \\<alpha> x1a) \\<and>\n        \\<Phi>' (\\<alpha> ` set x1a) x2;\n        x' = (map \\<alpha> x1a, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x\\<in>\\<alpha> ` set x1a -\n  {hd (map \\<alpha> x1a)}.\n                            RR' (hd (map \\<alpha> x1a)) x\n 3. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>xsa = map \\<alpha> xs;\n        distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs;\n        distinct (map \\<alpha> xs) \\<and> sorted_wrt RR' (map \\<alpha> xs);\n        x1 = map \\<alpha> x1a \\<and>\n        set x1a \\<subseteq> set xs \\<and>\n        set x1 \\<subseteq> \\<alpha> ` set xs \\<and>\n        (\\<forall>x\\<in>set xs - set x1a.\n            \\<forall>xa\\<in>set x1a. RR x xa) \\<and>\n        (\\<forall>x\\<in>\\<alpha> ` set xs - set x1.\n            \\<forall>xa\\<in>set x1. RR' x xa) \\<and>\n        ((set x1a, x2a), set x1, x2) \\<in> R;\n        FOREACH_cond c (x1a, x2a); FOREACH_cond c' (map \\<alpha> x1a, x2);\n        (\\<exists>xs'. xs = xs' @ x1a) \\<and> \\<Phi> (set x1a) x2a;\n        (\\<exists>xs'. map \\<alpha> xs = xs' @ map \\<alpha> x1a) \\<and>\n        \\<Phi>' (\\<alpha> ` set x1a) x2;\n        x' = (map \\<alpha> x1a, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> c x2a\n 4. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>xsa = map \\<alpha> xs;\n        distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs;\n        distinct (map \\<alpha> xs) \\<and> sorted_wrt RR' (map \\<alpha> xs);\n        x1 = map \\<alpha> x1a \\<and>\n        set x1a \\<subseteq> set xs \\<and>\n        set x1 \\<subseteq> \\<alpha> ` set xs \\<and>\n        (\\<forall>x\\<in>set xs - set x1a.\n            \\<forall>xa\\<in>set x1a. RR x xa) \\<and>\n        (\\<forall>x\\<in>\\<alpha> ` set xs - set x1.\n            \\<forall>xa\\<in>set x1. RR' x xa) \\<and>\n        ((set x1a, x2a), set x1, x2) \\<in> R;\n        FOREACH_cond c (x1a, x2a); FOREACH_cond c' (map \\<alpha> x1a, x2);\n        (\\<exists>xs'. xs = xs' @ x1a) \\<and> \\<Phi> (set x1a) x2a;\n        (\\<exists>xs'. map \\<alpha> xs = xs' @ map \\<alpha> x1a) \\<and>\n        \\<Phi>' (\\<alpha> ` set x1a) x2;\n        x' = (map \\<alpha> x1a, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> c' x2\n 5. \\<And>xs xsa x x' x1 x2 x1a x2a \\<sigma>' \\<sigma>''.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n        FOREACH_cond c x; FOREACH_cond c' x';\n        case x of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>;\n        x' = (x1, x2); x = (x1a, x2a);\n        (\\<sigma>', \\<sigma>'')\n        \\<in> {(\\<sigma>, \\<sigma>').\n               ((set x1a - {hd x1a}, \\<sigma>),\n                \\<alpha> ` set x1a - {hd x1}, \\<sigma>')\n               \\<in> R}\\<rbrakk>\n       \\<Longrightarrow> ((tl x1a, \\<sigma>'), tl x1, \\<sigma>'')\n                         \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n                                xs' = map \\<alpha> xs \\<and>\n                                set xs \\<subseteq> S \\<and>\n                                set xs' \\<subseteq> S' \\<and>\n                                (\\<forall>x\\<in>S - set xs.\n                                    \\<forall>y\\<in>set xs. RR x y) \\<and>\n                                (\\<forall>x\\<in>S' - set xs'.\n                                    \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n                                ((set xs, \\<sigma>), set xs', \\<sigma>')\n                                \\<in> R}\n 6. \\<And>xs xsa x x'.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n        \\<not> FOREACH_cond c x; \\<not> FOREACH_cond c' x';\n        case x of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'.\n             xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> (x, x') \\<in> ?R'3 xs xsa\n 7. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x') \\<in> ?R'3 xs xsa; x' = (x1, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> (x2a, x2) \\<in> R'", "apply (case_tac b)"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>a b d e.\n       \\<lbrakk>c' a; sorted_wrt RR' (map \\<alpha> e @ map \\<alpha> b);\n        b \\<noteq> []; c d; \\<Phi> (set b) d; \\<Phi>' (\\<alpha> ` set b) a;\n        S = set e \\<union> set b; sorted_wrt RR (e @ b);\n        \\<alpha> ` set b \\<subseteq> \\<alpha> ` (set e \\<union> set b);\n        \\<forall>x\\<in>set e \\<union> set b - set b.\n           \\<forall>xa\\<in>set b. RR x xa;\n        \\<forall>x\\<in>\\<alpha> ` (set e \\<union> set b) - \\<alpha> ` set b.\n           \\<forall>xa\\<in>set b. RR' x (\\<alpha> xa);\n        ((set b, d), \\<alpha> ` set b, a) \\<in> R; distinct e;\n        distinct (map \\<alpha> e); distinct b; set e \\<inter> set b = {};\n        distinct (map \\<alpha> b);\n        \\<alpha> ` set e \\<inter> \\<alpha> ` set b = {}; b = []\\<rbrakk>\n       \\<Longrightarrow> hd (map \\<alpha> b) \\<in> \\<alpha> ` set b\n 2. \\<And>a b d e aa list.\n       \\<lbrakk>c' a; sorted_wrt RR' (map \\<alpha> e @ map \\<alpha> b);\n        b \\<noteq> []; c d; \\<Phi> (set b) d; \\<Phi>' (\\<alpha> ` set b) a;\n        S = set e \\<union> set b; sorted_wrt RR (e @ b);\n        \\<alpha> ` set b \\<subseteq> \\<alpha> ` (set e \\<union> set b);\n        \\<forall>x\\<in>set e \\<union> set b - set b.\n           \\<forall>xa\\<in>set b. RR x xa;\n        \\<forall>x\\<in>\\<alpha> ` (set e \\<union> set b) - \\<alpha> ` set b.\n           \\<forall>xa\\<in>set b. RR' x (\\<alpha> xa);\n        ((set b, d), \\<alpha> ` set b, a) \\<in> R; distinct e;\n        distinct (map \\<alpha> e); distinct b; set e \\<inter> set b = {};\n        distinct (map \\<alpha> b);\n        \\<alpha> ` set e \\<inter> \\<alpha> ` set b = {};\n        b = aa # list\\<rbrakk>\n       \\<Longrightarrow> hd (map \\<alpha> b) \\<in> \\<alpha> ` set b\n 3. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>xsa = map \\<alpha> xs;\n        distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs;\n        distinct (map \\<alpha> xs) \\<and> sorted_wrt RR' (map \\<alpha> xs);\n        x1 = map \\<alpha> x1a \\<and>\n        set x1a \\<subseteq> set xs \\<and>\n        set x1 \\<subseteq> \\<alpha> ` set xs \\<and>\n        (\\<forall>x\\<in>set xs - set x1a.\n            \\<forall>xa\\<in>set x1a. RR x xa) \\<and>\n        (\\<forall>x\\<in>\\<alpha> ` set xs - set x1.\n            \\<forall>xa\\<in>set x1. RR' x xa) \\<and>\n        ((set x1a, x2a), set x1, x2) \\<in> R;\n        FOREACH_cond c (x1a, x2a); FOREACH_cond c' (map \\<alpha> x1a, x2);\n        (\\<exists>xs'. xs = xs' @ x1a) \\<and> \\<Phi> (set x1a) x2a;\n        (\\<exists>xs'. map \\<alpha> xs = xs' @ map \\<alpha> x1a) \\<and>\n        \\<Phi>' (\\<alpha> ` set x1a) x2;\n        x' = (map \\<alpha> x1a, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x\\<in>\\<alpha> ` set x1a -\n  {hd (map \\<alpha> x1a)}.\n                            RR' (hd (map \\<alpha> x1a)) x\n 4. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>xsa = map \\<alpha> xs;\n        distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs;\n        distinct (map \\<alpha> xs) \\<and> sorted_wrt RR' (map \\<alpha> xs);\n        x1 = map \\<alpha> x1a \\<and>\n        set x1a \\<subseteq> set xs \\<and>\n        set x1 \\<subseteq> \\<alpha> ` set xs \\<and>\n        (\\<forall>x\\<in>set xs - set x1a.\n            \\<forall>xa\\<in>set x1a. RR x xa) \\<and>\n        (\\<forall>x\\<in>\\<alpha> ` set xs - set x1.\n            \\<forall>xa\\<in>set x1. RR' x xa) \\<and>\n        ((set x1a, x2a), set x1, x2) \\<in> R;\n        FOREACH_cond c (x1a, x2a); FOREACH_cond c' (map \\<alpha> x1a, x2);\n        (\\<exists>xs'. xs = xs' @ x1a) \\<and> \\<Phi> (set x1a) x2a;\n        (\\<exists>xs'. map \\<alpha> xs = xs' @ map \\<alpha> x1a) \\<and>\n        \\<Phi>' (\\<alpha> ` set x1a) x2;\n        x' = (map \\<alpha> x1a, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> c x2a\n 5. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>xsa = map \\<alpha> xs;\n        distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs;\n        distinct (map \\<alpha> xs) \\<and> sorted_wrt RR' (map \\<alpha> xs);\n        x1 = map \\<alpha> x1a \\<and>\n        set x1a \\<subseteq> set xs \\<and>\n        set x1 \\<subseteq> \\<alpha> ` set xs \\<and>\n        (\\<forall>x\\<in>set xs - set x1a.\n            \\<forall>xa\\<in>set x1a. RR x xa) \\<and>\n        (\\<forall>x\\<in>\\<alpha> ` set xs - set x1.\n            \\<forall>xa\\<in>set x1. RR' x xa) \\<and>\n        ((set x1a, x2a), set x1, x2) \\<in> R;\n        FOREACH_cond c (x1a, x2a); FOREACH_cond c' (map \\<alpha> x1a, x2);\n        (\\<exists>xs'. xs = xs' @ x1a) \\<and> \\<Phi> (set x1a) x2a;\n        (\\<exists>xs'. map \\<alpha> xs = xs' @ map \\<alpha> x1a) \\<and>\n        \\<Phi>' (\\<alpha> ` set x1a) x2;\n        x' = (map \\<alpha> x1a, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> c' x2\n 6. \\<And>xs xsa x x' x1 x2 x1a x2a \\<sigma>' \\<sigma>''.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n        FOREACH_cond c x; FOREACH_cond c' x';\n        case x of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>;\n        x' = (x1, x2); x = (x1a, x2a);\n        (\\<sigma>', \\<sigma>'')\n        \\<in> {(\\<sigma>, \\<sigma>').\n               ((set x1a - {hd x1a}, \\<sigma>),\n                \\<alpha> ` set x1a - {hd x1}, \\<sigma>')\n               \\<in> R}\\<rbrakk>\n       \\<Longrightarrow> ((tl x1a, \\<sigma>'), tl x1, \\<sigma>'')\n                         \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n                                xs' = map \\<alpha> xs \\<and>\n                                set xs \\<subseteq> S \\<and>\n                                set xs' \\<subseteq> S' \\<and>\n                                (\\<forall>x\\<in>S - set xs.\n                                    \\<forall>y\\<in>set xs. RR x y) \\<and>\n                                (\\<forall>x\\<in>S' - set xs'.\n                                    \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n                                ((set xs, \\<sigma>), set xs', \\<sigma>')\n                                \\<in> R}\n 7. \\<And>xs xsa x x'.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n        \\<not> FOREACH_cond c x; \\<not> FOREACH_cond c' x';\n        case x of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'.\n             xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> (x, x') \\<in> ?R'3 xs xsa\n 8. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x') \\<in> ?R'3 xs xsa; x' = (x1, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> (x2a, x2) \\<in> R'", "apply (auto) [2]"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>xsa = map \\<alpha> xs;\n        distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs;\n        distinct (map \\<alpha> xs) \\<and> sorted_wrt RR' (map \\<alpha> xs);\n        x1 = map \\<alpha> x1a \\<and>\n        set x1a \\<subseteq> set xs \\<and>\n        set x1 \\<subseteq> \\<alpha> ` set xs \\<and>\n        (\\<forall>x\\<in>set xs - set x1a.\n            \\<forall>xa\\<in>set x1a. RR x xa) \\<and>\n        (\\<forall>x\\<in>\\<alpha> ` set xs - set x1.\n            \\<forall>xa\\<in>set x1. RR' x xa) \\<and>\n        ((set x1a, x2a), set x1, x2) \\<in> R;\n        FOREACH_cond c (x1a, x2a); FOREACH_cond c' (map \\<alpha> x1a, x2);\n        (\\<exists>xs'. xs = xs' @ x1a) \\<and> \\<Phi> (set x1a) x2a;\n        (\\<exists>xs'. map \\<alpha> xs = xs' @ map \\<alpha> x1a) \\<and>\n        \\<Phi>' (\\<alpha> ` set x1a) x2;\n        x' = (map \\<alpha> x1a, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x\\<in>\\<alpha> ` set x1a -\n  {hd (map \\<alpha> x1a)}.\n                            RR' (hd (map \\<alpha> x1a)) x\n 2. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>xsa = map \\<alpha> xs;\n        distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs;\n        distinct (map \\<alpha> xs) \\<and> sorted_wrt RR' (map \\<alpha> xs);\n        x1 = map \\<alpha> x1a \\<and>\n        set x1a \\<subseteq> set xs \\<and>\n        set x1 \\<subseteq> \\<alpha> ` set xs \\<and>\n        (\\<forall>x\\<in>set xs - set x1a.\n            \\<forall>xa\\<in>set x1a. RR x xa) \\<and>\n        (\\<forall>x\\<in>\\<alpha> ` set xs - set x1.\n            \\<forall>xa\\<in>set x1. RR' x xa) \\<and>\n        ((set x1a, x2a), set x1, x2) \\<in> R;\n        FOREACH_cond c (x1a, x2a); FOREACH_cond c' (map \\<alpha> x1a, x2);\n        (\\<exists>xs'. xs = xs' @ x1a) \\<and> \\<Phi> (set x1a) x2a;\n        (\\<exists>xs'. map \\<alpha> xs = xs' @ map \\<alpha> x1a) \\<and>\n        \\<Phi>' (\\<alpha> ` set x1a) x2;\n        x' = (map \\<alpha> x1a, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> c x2a\n 3. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>xsa = map \\<alpha> xs;\n        distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs;\n        distinct (map \\<alpha> xs) \\<and> sorted_wrt RR' (map \\<alpha> xs);\n        x1 = map \\<alpha> x1a \\<and>\n        set x1a \\<subseteq> set xs \\<and>\n        set x1 \\<subseteq> \\<alpha> ` set xs \\<and>\n        (\\<forall>x\\<in>set xs - set x1a.\n            \\<forall>xa\\<in>set x1a. RR x xa) \\<and>\n        (\\<forall>x\\<in>\\<alpha> ` set xs - set x1.\n            \\<forall>xa\\<in>set x1. RR' x xa) \\<and>\n        ((set x1a, x2a), set x1, x2) \\<in> R;\n        FOREACH_cond c (x1a, x2a); FOREACH_cond c' (map \\<alpha> x1a, x2);\n        (\\<exists>xs'. xs = xs' @ x1a) \\<and> \\<Phi> (set x1a) x2a;\n        (\\<exists>xs'. map \\<alpha> xs = xs' @ map \\<alpha> x1a) \\<and>\n        \\<Phi>' (\\<alpha> ` set x1a) x2;\n        x' = (map \\<alpha> x1a, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> c' x2\n 4. \\<And>xs xsa x x' x1 x2 x1a x2a \\<sigma>' \\<sigma>''.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n        FOREACH_cond c x; FOREACH_cond c' x';\n        case x of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>;\n        x' = (x1, x2); x = (x1a, x2a);\n        (\\<sigma>', \\<sigma>'')\n        \\<in> {(\\<sigma>, \\<sigma>').\n               ((set x1a - {hd x1a}, \\<sigma>),\n                \\<alpha> ` set x1a - {hd x1}, \\<sigma>')\n               \\<in> R}\\<rbrakk>\n       \\<Longrightarrow> ((tl x1a, \\<sigma>'), tl x1, \\<sigma>'')\n                         \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n                                xs' = map \\<alpha> xs \\<and>\n                                set xs \\<subseteq> S \\<and>\n                                set xs' \\<subseteq> S' \\<and>\n                                (\\<forall>x\\<in>S - set xs.\n                                    \\<forall>y\\<in>set xs. RR x y) \\<and>\n                                (\\<forall>x\\<in>S' - set xs'.\n                                    \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n                                ((set xs, \\<sigma>), set xs', \\<sigma>')\n                                \\<in> R}\n 5. \\<And>xs xsa x x'.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n        \\<not> FOREACH_cond c x; \\<not> FOREACH_cond c' x';\n        case x of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'.\n             xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> (x, x') \\<in> ?R'3 xs xsa\n 6. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x') \\<in> ?R'3 xs xsa; x' = (x1, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> (x2a, x2) \\<in> R'", "apply (clarsimp simp: FOREACH_cond_def)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>x2 x1a x2a xa xs'.\n       \\<lbrakk>c' x2; xa \\<in> set x1a;\n        \\<not> RR' (hd (map \\<alpha> x1a)) (\\<alpha> xa);\n        sorted_wrt RR' (map \\<alpha> xs' @ map \\<alpha> x1a);\n        x1a \\<noteq> []; c x2a; \\<Phi> (set x1a) x2a;\n        \\<Phi>' (\\<alpha> ` set x1a) x2; S = set xs' \\<union> set x1a;\n        sorted_wrt RR (xs' @ x1a);\n        \\<alpha> ` set x1a\n        \\<subseteq> \\<alpha> ` (set xs' \\<union> set x1a);\n        \\<forall>x\\<in>set xs' \\<union> set x1a - set x1a.\n           \\<forall>xa\\<in>set x1a. RR x xa;\n        \\<forall>x\\<in>\\<alpha> ` (set xs' \\<union> set x1a) -\n                       \\<alpha> ` set x1a.\n           \\<forall>xa\\<in>set x1a. RR' x (\\<alpha> xa);\n        ((set x1a, x2a), \\<alpha> ` set x1a, x2) \\<in> R; distinct xs';\n        distinct (map \\<alpha> xs'); distinct x1a;\n        set xs' \\<inter> set x1a = {}; distinct (map \\<alpha> x1a);\n        \\<alpha> ` set xs' \\<inter> \\<alpha> ` set x1a = {}\\<rbrakk>\n       \\<Longrightarrow> \\<alpha> xa = hd (map \\<alpha> x1a)\n 2. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>xsa = map \\<alpha> xs;\n        distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs;\n        distinct (map \\<alpha> xs) \\<and> sorted_wrt RR' (map \\<alpha> xs);\n        x1 = map \\<alpha> x1a \\<and>\n        set x1a \\<subseteq> set xs \\<and>\n        set x1 \\<subseteq> \\<alpha> ` set xs \\<and>\n        (\\<forall>x\\<in>set xs - set x1a.\n            \\<forall>xa\\<in>set x1a. RR x xa) \\<and>\n        (\\<forall>x\\<in>\\<alpha> ` set xs - set x1.\n            \\<forall>xa\\<in>set x1. RR' x xa) \\<and>\n        ((set x1a, x2a), set x1, x2) \\<in> R;\n        FOREACH_cond c (x1a, x2a); FOREACH_cond c' (map \\<alpha> x1a, x2);\n        (\\<exists>xs'. xs = xs' @ x1a) \\<and> \\<Phi> (set x1a) x2a;\n        (\\<exists>xs'. map \\<alpha> xs = xs' @ map \\<alpha> x1a) \\<and>\n        \\<Phi>' (\\<alpha> ` set x1a) x2;\n        x' = (map \\<alpha> x1a, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> c x2a\n 3. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>xsa = map \\<alpha> xs;\n        distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs;\n        distinct (map \\<alpha> xs) \\<and> sorted_wrt RR' (map \\<alpha> xs);\n        x1 = map \\<alpha> x1a \\<and>\n        set x1a \\<subseteq> set xs \\<and>\n        set x1 \\<subseteq> \\<alpha> ` set xs \\<and>\n        (\\<forall>x\\<in>set xs - set x1a.\n            \\<forall>xa\\<in>set x1a. RR x xa) \\<and>\n        (\\<forall>x\\<in>\\<alpha> ` set xs - set x1.\n            \\<forall>xa\\<in>set x1. RR' x xa) \\<and>\n        ((set x1a, x2a), set x1, x2) \\<in> R;\n        FOREACH_cond c (x1a, x2a); FOREACH_cond c' (map \\<alpha> x1a, x2);\n        (\\<exists>xs'. xs = xs' @ x1a) \\<and> \\<Phi> (set x1a) x2a;\n        (\\<exists>xs'. map \\<alpha> xs = xs' @ map \\<alpha> x1a) \\<and>\n        \\<Phi>' (\\<alpha> ` set x1a) x2;\n        x' = (map \\<alpha> x1a, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> c' x2\n 4. \\<And>xs xsa x x' x1 x2 x1a x2a \\<sigma>' \\<sigma>''.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n        FOREACH_cond c x; FOREACH_cond c' x';\n        case x of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>;\n        x' = (x1, x2); x = (x1a, x2a);\n        (\\<sigma>', \\<sigma>'')\n        \\<in> {(\\<sigma>, \\<sigma>').\n               ((set x1a - {hd x1a}, \\<sigma>),\n                \\<alpha> ` set x1a - {hd x1}, \\<sigma>')\n               \\<in> R}\\<rbrakk>\n       \\<Longrightarrow> ((tl x1a, \\<sigma>'), tl x1, \\<sigma>'')\n                         \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n                                xs' = map \\<alpha> xs \\<and>\n                                set xs \\<subseteq> S \\<and>\n                                set xs' \\<subseteq> S' \\<and>\n                                (\\<forall>x\\<in>S - set xs.\n                                    \\<forall>y\\<in>set xs. RR x y) \\<and>\n                                (\\<forall>x\\<in>S' - set xs'.\n                                    \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n                                ((set xs, \\<sigma>), set xs', \\<sigma>')\n                                \\<in> R}\n 5. \\<And>xs xsa x x'.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n        \\<not> FOREACH_cond c x; \\<not> FOREACH_cond c' x';\n        case x of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'.\n             xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> (x, x') \\<in> ?R'3 xs xsa\n 6. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x') \\<in> ?R'3 xs xsa; x' = (x1, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> (x2a, x2) \\<in> R'", "apply (rule ccontr)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>x2 x1a x2a xa xs'.\n       \\<lbrakk>c' x2; xa \\<in> set x1a;\n        \\<not> RR' (hd (map \\<alpha> x1a)) (\\<alpha> xa);\n        sorted_wrt RR' (map \\<alpha> xs' @ map \\<alpha> x1a);\n        x1a \\<noteq> []; c x2a; \\<Phi> (set x1a) x2a;\n        \\<Phi>' (\\<alpha> ` set x1a) x2; S = set xs' \\<union> set x1a;\n        sorted_wrt RR (xs' @ x1a);\n        \\<alpha> ` set x1a\n        \\<subseteq> \\<alpha> ` (set xs' \\<union> set x1a);\n        \\<forall>x\\<in>set xs' \\<union> set x1a - set x1a.\n           \\<forall>xa\\<in>set x1a. RR x xa;\n        \\<forall>x\\<in>\\<alpha> ` (set xs' \\<union> set x1a) -\n                       \\<alpha> ` set x1a.\n           \\<forall>xa\\<in>set x1a. RR' x (\\<alpha> xa);\n        ((set x1a, x2a), \\<alpha> ` set x1a, x2) \\<in> R; distinct xs';\n        distinct (map \\<alpha> xs'); distinct x1a;\n        set xs' \\<inter> set x1a = {}; distinct (map \\<alpha> x1a);\n        \\<alpha> ` set xs' \\<inter> \\<alpha> ` set x1a = {};\n        \\<alpha> xa \\<noteq> hd (map \\<alpha> x1a)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>xsa = map \\<alpha> xs;\n        distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs;\n        distinct (map \\<alpha> xs) \\<and> sorted_wrt RR' (map \\<alpha> xs);\n        x1 = map \\<alpha> x1a \\<and>\n        set x1a \\<subseteq> set xs \\<and>\n        set x1 \\<subseteq> \\<alpha> ` set xs \\<and>\n        (\\<forall>x\\<in>set xs - set x1a.\n            \\<forall>xa\\<in>set x1a. RR x xa) \\<and>\n        (\\<forall>x\\<in>\\<alpha> ` set xs - set x1.\n            \\<forall>xa\\<in>set x1. RR' x xa) \\<and>\n        ((set x1a, x2a), set x1, x2) \\<in> R;\n        FOREACH_cond c (x1a, x2a); FOREACH_cond c' (map \\<alpha> x1a, x2);\n        (\\<exists>xs'. xs = xs' @ x1a) \\<and> \\<Phi> (set x1a) x2a;\n        (\\<exists>xs'. map \\<alpha> xs = xs' @ map \\<alpha> x1a) \\<and>\n        \\<Phi>' (\\<alpha> ` set x1a) x2;\n        x' = (map \\<alpha> x1a, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> c x2a\n 3. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>xsa = map \\<alpha> xs;\n        distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs;\n        distinct (map \\<alpha> xs) \\<and> sorted_wrt RR' (map \\<alpha> xs);\n        x1 = map \\<alpha> x1a \\<and>\n        set x1a \\<subseteq> set xs \\<and>\n        set x1 \\<subseteq> \\<alpha> ` set xs \\<and>\n        (\\<forall>x\\<in>set xs - set x1a.\n            \\<forall>xa\\<in>set x1a. RR x xa) \\<and>\n        (\\<forall>x\\<in>\\<alpha> ` set xs - set x1.\n            \\<forall>xa\\<in>set x1. RR' x xa) \\<and>\n        ((set x1a, x2a), set x1, x2) \\<in> R;\n        FOREACH_cond c (x1a, x2a); FOREACH_cond c' (map \\<alpha> x1a, x2);\n        (\\<exists>xs'. xs = xs' @ x1a) \\<and> \\<Phi> (set x1a) x2a;\n        (\\<exists>xs'. map \\<alpha> xs = xs' @ map \\<alpha> x1a) \\<and>\n        \\<Phi>' (\\<alpha> ` set x1a) x2;\n        x' = (map \\<alpha> x1a, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> c' x2\n 4. \\<And>xs xsa x x' x1 x2 x1a x2a \\<sigma>' \\<sigma>''.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n        FOREACH_cond c x; FOREACH_cond c' x';\n        case x of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>;\n        x' = (x1, x2); x = (x1a, x2a);\n        (\\<sigma>', \\<sigma>'')\n        \\<in> {(\\<sigma>, \\<sigma>').\n               ((set x1a - {hd x1a}, \\<sigma>),\n                \\<alpha> ` set x1a - {hd x1}, \\<sigma>')\n               \\<in> R}\\<rbrakk>\n       \\<Longrightarrow> ((tl x1a, \\<sigma>'), tl x1, \\<sigma>'')\n                         \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n                                xs' = map \\<alpha> xs \\<and>\n                                set xs \\<subseteq> S \\<and>\n                                set xs' \\<subseteq> S' \\<and>\n                                (\\<forall>x\\<in>S - set xs.\n                                    \\<forall>y\\<in>set xs. RR x y) \\<and>\n                                (\\<forall>x\\<in>S' - set xs'.\n                                    \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n                                ((set xs, \\<sigma>), set xs', \\<sigma>')\n                                \\<in> R}\n 5. \\<And>xs xsa x x'.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n        \\<not> FOREACH_cond c x; \\<not> FOREACH_cond c' x';\n        case x of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'.\n             xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> (x, x') \\<in> ?R'3 xs xsa\n 6. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x') \\<in> ?R'3 xs xsa; x' = (x1, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> (x2a, x2) \\<in> R'", "apply (rename_tac a b d e f)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>a b d e f.\n       \\<lbrakk>c' a; e \\<in> set b;\n        \\<not> RR' (hd (map \\<alpha> b)) (\\<alpha> e);\n        sorted_wrt RR' (map \\<alpha> f @ map \\<alpha> b); b \\<noteq> [];\n        c d; \\<Phi> (set b) d; \\<Phi>' (\\<alpha> ` set b) a;\n        S = set f \\<union> set b; sorted_wrt RR (f @ b);\n        \\<alpha> ` set b \\<subseteq> \\<alpha> ` (set f \\<union> set b);\n        \\<forall>x\\<in>set f \\<union> set b - set b.\n           \\<forall>xa\\<in>set b. RR x xa;\n        \\<forall>x\\<in>\\<alpha> ` (set f \\<union> set b) - \\<alpha> ` set b.\n           \\<forall>xa\\<in>set b. RR' x (\\<alpha> xa);\n        ((set b, d), \\<alpha> ` set b, a) \\<in> R; distinct f;\n        distinct (map \\<alpha> f); distinct b; set f \\<inter> set b = {};\n        distinct (map \\<alpha> b);\n        \\<alpha> ` set f \\<inter> \\<alpha> ` set b = {};\n        \\<alpha> e \\<noteq> hd (map \\<alpha> b)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>xsa = map \\<alpha> xs;\n        distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs;\n        distinct (map \\<alpha> xs) \\<and> sorted_wrt RR' (map \\<alpha> xs);\n        x1 = map \\<alpha> x1a \\<and>\n        set x1a \\<subseteq> set xs \\<and>\n        set x1 \\<subseteq> \\<alpha> ` set xs \\<and>\n        (\\<forall>x\\<in>set xs - set x1a.\n            \\<forall>xa\\<in>set x1a. RR x xa) \\<and>\n        (\\<forall>x\\<in>\\<alpha> ` set xs - set x1.\n            \\<forall>xa\\<in>set x1. RR' x xa) \\<and>\n        ((set x1a, x2a), set x1, x2) \\<in> R;\n        FOREACH_cond c (x1a, x2a); FOREACH_cond c' (map \\<alpha> x1a, x2);\n        (\\<exists>xs'. xs = xs' @ x1a) \\<and> \\<Phi> (set x1a) x2a;\n        (\\<exists>xs'. map \\<alpha> xs = xs' @ map \\<alpha> x1a) \\<and>\n        \\<Phi>' (\\<alpha> ` set x1a) x2;\n        x' = (map \\<alpha> x1a, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> c x2a\n 3. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>xsa = map \\<alpha> xs;\n        distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs;\n        distinct (map \\<alpha> xs) \\<and> sorted_wrt RR' (map \\<alpha> xs);\n        x1 = map \\<alpha> x1a \\<and>\n        set x1a \\<subseteq> set xs \\<and>\n        set x1 \\<subseteq> \\<alpha> ` set xs \\<and>\n        (\\<forall>x\\<in>set xs - set x1a.\n            \\<forall>xa\\<in>set x1a. RR x xa) \\<and>\n        (\\<forall>x\\<in>\\<alpha> ` set xs - set x1.\n            \\<forall>xa\\<in>set x1. RR' x xa) \\<and>\n        ((set x1a, x2a), set x1, x2) \\<in> R;\n        FOREACH_cond c (x1a, x2a); FOREACH_cond c' (map \\<alpha> x1a, x2);\n        (\\<exists>xs'. xs = xs' @ x1a) \\<and> \\<Phi> (set x1a) x2a;\n        (\\<exists>xs'. map \\<alpha> xs = xs' @ map \\<alpha> x1a) \\<and>\n        \\<Phi>' (\\<alpha> ` set x1a) x2;\n        x' = (map \\<alpha> x1a, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> c' x2\n 4. \\<And>xs xsa x x' x1 x2 x1a x2a \\<sigma>' \\<sigma>''.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n        FOREACH_cond c x; FOREACH_cond c' x';\n        case x of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>;\n        x' = (x1, x2); x = (x1a, x2a);\n        (\\<sigma>', \\<sigma>'')\n        \\<in> {(\\<sigma>, \\<sigma>').\n               ((set x1a - {hd x1a}, \\<sigma>),\n                \\<alpha> ` set x1a - {hd x1}, \\<sigma>')\n               \\<in> R}\\<rbrakk>\n       \\<Longrightarrow> ((tl x1a, \\<sigma>'), tl x1, \\<sigma>'')\n                         \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n                                xs' = map \\<alpha> xs \\<and>\n                                set xs \\<subseteq> S \\<and>\n                                set xs' \\<subseteq> S' \\<and>\n                                (\\<forall>x\\<in>S - set xs.\n                                    \\<forall>y\\<in>set xs. RR x y) \\<and>\n                                (\\<forall>x\\<in>S' - set xs'.\n                                    \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n                                ((set xs, \\<sigma>), set xs', \\<sigma>')\n                                \\<in> R}\n 5. \\<And>xs xsa x x'.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n        \\<not> FOREACH_cond c x; \\<not> FOREACH_cond c' x';\n        case x of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'.\n             xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> (x, x') \\<in> ?R'3 xs xsa\n 6. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x') \\<in> ?R'3 xs xsa; x' = (x1, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> (x2a, x2) \\<in> R'", "apply (case_tac b)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>a b d e f.\n       \\<lbrakk>c' a; e \\<in> set b;\n        \\<not> RR' (hd (map \\<alpha> b)) (\\<alpha> e);\n        sorted_wrt RR' (map \\<alpha> f @ map \\<alpha> b); b \\<noteq> [];\n        c d; \\<Phi> (set b) d; \\<Phi>' (\\<alpha> ` set b) a;\n        S = set f \\<union> set b; sorted_wrt RR (f @ b);\n        \\<alpha> ` set b \\<subseteq> \\<alpha> ` (set f \\<union> set b);\n        \\<forall>x\\<in>set f \\<union> set b - set b.\n           \\<forall>xa\\<in>set b. RR x xa;\n        \\<forall>x\\<in>\\<alpha> ` (set f \\<union> set b) - \\<alpha> ` set b.\n           \\<forall>xa\\<in>set b. RR' x (\\<alpha> xa);\n        ((set b, d), \\<alpha> ` set b, a) \\<in> R; distinct f;\n        distinct (map \\<alpha> f); distinct b; set f \\<inter> set b = {};\n        distinct (map \\<alpha> b);\n        \\<alpha> ` set f \\<inter> \\<alpha> ` set b = {};\n        \\<alpha> e \\<noteq> hd (map \\<alpha> b); b = []\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>a b d e f aa list.\n       \\<lbrakk>c' a; e \\<in> set b;\n        \\<not> RR' (hd (map \\<alpha> b)) (\\<alpha> e);\n        sorted_wrt RR' (map \\<alpha> f @ map \\<alpha> b); b \\<noteq> [];\n        c d; \\<Phi> (set b) d; \\<Phi>' (\\<alpha> ` set b) a;\n        S = set f \\<union> set b; sorted_wrt RR (f @ b);\n        \\<alpha> ` set b \\<subseteq> \\<alpha> ` (set f \\<union> set b);\n        \\<forall>x\\<in>set f \\<union> set b - set b.\n           \\<forall>xa\\<in>set b. RR x xa;\n        \\<forall>x\\<in>\\<alpha> ` (set f \\<union> set b) - \\<alpha> ` set b.\n           \\<forall>xa\\<in>set b. RR' x (\\<alpha> xa);\n        ((set b, d), \\<alpha> ` set b, a) \\<in> R; distinct f;\n        distinct (map \\<alpha> f); distinct b; set f \\<inter> set b = {};\n        distinct (map \\<alpha> b);\n        \\<alpha> ` set f \\<inter> \\<alpha> ` set b = {};\n        \\<alpha> e \\<noteq> hd (map \\<alpha> b); b = aa # list\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>xsa = map \\<alpha> xs;\n        distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs;\n        distinct (map \\<alpha> xs) \\<and> sorted_wrt RR' (map \\<alpha> xs);\n        x1 = map \\<alpha> x1a \\<and>\n        set x1a \\<subseteq> set xs \\<and>\n        set x1 \\<subseteq> \\<alpha> ` set xs \\<and>\n        (\\<forall>x\\<in>set xs - set x1a.\n            \\<forall>xa\\<in>set x1a. RR x xa) \\<and>\n        (\\<forall>x\\<in>\\<alpha> ` set xs - set x1.\n            \\<forall>xa\\<in>set x1. RR' x xa) \\<and>\n        ((set x1a, x2a), set x1, x2) \\<in> R;\n        FOREACH_cond c (x1a, x2a); FOREACH_cond c' (map \\<alpha> x1a, x2);\n        (\\<exists>xs'. xs = xs' @ x1a) \\<and> \\<Phi> (set x1a) x2a;\n        (\\<exists>xs'. map \\<alpha> xs = xs' @ map \\<alpha> x1a) \\<and>\n        \\<Phi>' (\\<alpha> ` set x1a) x2;\n        x' = (map \\<alpha> x1a, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> c x2a\n 4. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>xsa = map \\<alpha> xs;\n        distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs;\n        distinct (map \\<alpha> xs) \\<and> sorted_wrt RR' (map \\<alpha> xs);\n        x1 = map \\<alpha> x1a \\<and>\n        set x1a \\<subseteq> set xs \\<and>\n        set x1 \\<subseteq> \\<alpha> ` set xs \\<and>\n        (\\<forall>x\\<in>set xs - set x1a.\n            \\<forall>xa\\<in>set x1a. RR x xa) \\<and>\n        (\\<forall>x\\<in>\\<alpha> ` set xs - set x1.\n            \\<forall>xa\\<in>set x1. RR' x xa) \\<and>\n        ((set x1a, x2a), set x1, x2) \\<in> R;\n        FOREACH_cond c (x1a, x2a); FOREACH_cond c' (map \\<alpha> x1a, x2);\n        (\\<exists>xs'. xs = xs' @ x1a) \\<and> \\<Phi> (set x1a) x2a;\n        (\\<exists>xs'. map \\<alpha> xs = xs' @ map \\<alpha> x1a) \\<and>\n        \\<Phi>' (\\<alpha> ` set x1a) x2;\n        x' = (map \\<alpha> x1a, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> c' x2\n 5. \\<And>xs xsa x x' x1 x2 x1a x2a \\<sigma>' \\<sigma>''.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n        FOREACH_cond c x; FOREACH_cond c' x';\n        case x of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>;\n        x' = (x1, x2); x = (x1a, x2a);\n        (\\<sigma>', \\<sigma>'')\n        \\<in> {(\\<sigma>, \\<sigma>').\n               ((set x1a - {hd x1a}, \\<sigma>),\n                \\<alpha> ` set x1a - {hd x1}, \\<sigma>')\n               \\<in> R}\\<rbrakk>\n       \\<Longrightarrow> ((tl x1a, \\<sigma>'), tl x1, \\<sigma>'')\n                         \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n                                xs' = map \\<alpha> xs \\<and>\n                                set xs \\<subseteq> S \\<and>\n                                set xs' \\<subseteq> S' \\<and>\n                                (\\<forall>x\\<in>S - set xs.\n                                    \\<forall>y\\<in>set xs. RR x y) \\<and>\n                                (\\<forall>x\\<in>S' - set xs'.\n                                    \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n                                ((set xs, \\<sigma>), set xs', \\<sigma>')\n                                \\<in> R}\n 6. \\<And>xs xsa x x'.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n        \\<not> FOREACH_cond c x; \\<not> FOREACH_cond c' x';\n        case x of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'.\n             xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> (x, x') \\<in> ?R'3 xs xsa\n 7. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x') \\<in> ?R'3 xs xsa; x' = (x1, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> (x2a, x2) \\<in> R'", "apply (auto simp: sorted_wrt_append) [2]"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>xsa = map \\<alpha> xs;\n        distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs;\n        distinct (map \\<alpha> xs) \\<and> sorted_wrt RR' (map \\<alpha> xs);\n        x1 = map \\<alpha> x1a \\<and>\n        set x1a \\<subseteq> set xs \\<and>\n        set x1 \\<subseteq> \\<alpha> ` set xs \\<and>\n        (\\<forall>x\\<in>set xs - set x1a.\n            \\<forall>xa\\<in>set x1a. RR x xa) \\<and>\n        (\\<forall>x\\<in>\\<alpha> ` set xs - set x1.\n            \\<forall>xa\\<in>set x1. RR' x xa) \\<and>\n        ((set x1a, x2a), set x1, x2) \\<in> R;\n        FOREACH_cond c (x1a, x2a); FOREACH_cond c' (map \\<alpha> x1a, x2);\n        (\\<exists>xs'. xs = xs' @ x1a) \\<and> \\<Phi> (set x1a) x2a;\n        (\\<exists>xs'. map \\<alpha> xs = xs' @ map \\<alpha> x1a) \\<and>\n        \\<Phi>' (\\<alpha> ` set x1a) x2;\n        x' = (map \\<alpha> x1a, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> c x2a\n 2. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>xsa = map \\<alpha> xs;\n        distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs;\n        distinct (map \\<alpha> xs) \\<and> sorted_wrt RR' (map \\<alpha> xs);\n        x1 = map \\<alpha> x1a \\<and>\n        set x1a \\<subseteq> set xs \\<and>\n        set x1 \\<subseteq> \\<alpha> ` set xs \\<and>\n        (\\<forall>x\\<in>set xs - set x1a.\n            \\<forall>xa\\<in>set x1a. RR x xa) \\<and>\n        (\\<forall>x\\<in>\\<alpha> ` set xs - set x1.\n            \\<forall>xa\\<in>set x1. RR' x xa) \\<and>\n        ((set x1a, x2a), set x1, x2) \\<in> R;\n        FOREACH_cond c (x1a, x2a); FOREACH_cond c' (map \\<alpha> x1a, x2);\n        (\\<exists>xs'. xs = xs' @ x1a) \\<and> \\<Phi> (set x1a) x2a;\n        (\\<exists>xs'. map \\<alpha> xs = xs' @ map \\<alpha> x1a) \\<and>\n        \\<Phi>' (\\<alpha> ` set x1a) x2;\n        x' = (map \\<alpha> x1a, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> c' x2\n 3. \\<And>xs xsa x x' x1 x2 x1a x2a \\<sigma>' \\<sigma>''.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n        FOREACH_cond c x; FOREACH_cond c' x';\n        case x of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>;\n        x' = (x1, x2); x = (x1a, x2a);\n        (\\<sigma>', \\<sigma>'')\n        \\<in> {(\\<sigma>, \\<sigma>').\n               ((set x1a - {hd x1a}, \\<sigma>),\n                \\<alpha> ` set x1a - {hd x1}, \\<sigma>')\n               \\<in> R}\\<rbrakk>\n       \\<Longrightarrow> ((tl x1a, \\<sigma>'), tl x1, \\<sigma>'')\n                         \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n                                xs' = map \\<alpha> xs \\<and>\n                                set xs \\<subseteq> S \\<and>\n                                set xs' \\<subseteq> S' \\<and>\n                                (\\<forall>x\\<in>S - set xs.\n                                    \\<forall>y\\<in>set xs. RR x y) \\<and>\n                                (\\<forall>x\\<in>S' - set xs'.\n                                    \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n                                ((set xs, \\<sigma>), set xs', \\<sigma>')\n                                \\<in> R}\n 4. \\<And>xs xsa x x'.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n        \\<not> FOREACH_cond c x; \\<not> FOREACH_cond c' x';\n        case x of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'.\n             xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> (x, x') \\<in> ?R'3 xs xsa\n 5. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x') \\<in> ?R'3 xs xsa; x' = (x1, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> (x2a, x2) \\<in> R'", "apply (clarsimp simp: FOREACH_cond_def)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>xsa = map \\<alpha> xs;\n        distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs;\n        distinct (map \\<alpha> xs) \\<and> sorted_wrt RR' (map \\<alpha> xs);\n        x1 = map \\<alpha> x1a \\<and>\n        set x1a \\<subseteq> set xs \\<and>\n        set x1 \\<subseteq> \\<alpha> ` set xs \\<and>\n        (\\<forall>x\\<in>set xs - set x1a.\n            \\<forall>xa\\<in>set x1a. RR x xa) \\<and>\n        (\\<forall>x\\<in>\\<alpha> ` set xs - set x1.\n            \\<forall>xa\\<in>set x1. RR' x xa) \\<and>\n        ((set x1a, x2a), set x1, x2) \\<in> R;\n        FOREACH_cond c (x1a, x2a); FOREACH_cond c' (map \\<alpha> x1a, x2);\n        (\\<exists>xs'. xs = xs' @ x1a) \\<and> \\<Phi> (set x1a) x2a;\n        (\\<exists>xs'. map \\<alpha> xs = xs' @ map \\<alpha> x1a) \\<and>\n        \\<Phi>' (\\<alpha> ` set x1a) x2;\n        x' = (map \\<alpha> x1a, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> c' x2\n 2. \\<And>xs xsa x x' x1 x2 x1a x2a \\<sigma>' \\<sigma>''.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n        FOREACH_cond c x; FOREACH_cond c' x';\n        case x of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>;\n        x' = (x1, x2); x = (x1a, x2a);\n        (\\<sigma>', \\<sigma>'')\n        \\<in> {(\\<sigma>, \\<sigma>').\n               ((set x1a - {hd x1a}, \\<sigma>),\n                \\<alpha> ` set x1a - {hd x1}, \\<sigma>')\n               \\<in> R}\\<rbrakk>\n       \\<Longrightarrow> ((tl x1a, \\<sigma>'), tl x1, \\<sigma>'')\n                         \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n                                xs' = map \\<alpha> xs \\<and>\n                                set xs \\<subseteq> S \\<and>\n                                set xs' \\<subseteq> S' \\<and>\n                                (\\<forall>x\\<in>S - set xs.\n                                    \\<forall>y\\<in>set xs. RR x y) \\<and>\n                                (\\<forall>x\\<in>S' - set xs'.\n                                    \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n                                ((set xs, \\<sigma>), set xs', \\<sigma>')\n                                \\<in> R}\n 3. \\<And>xs xsa x x'.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n        \\<not> FOREACH_cond c x; \\<not> FOREACH_cond c' x';\n        case x of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'.\n             xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> (x, x') \\<in> ?R'3 xs xsa\n 4. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x') \\<in> ?R'3 xs xsa; x' = (x1, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> (x2a, x2) \\<in> R'", "apply (clarsimp simp: FOREACH_cond_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>xs xsa x x' x1 x2 x1a x2a \\<sigma>' \\<sigma>''.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n        FOREACH_cond c x; FOREACH_cond c' x';\n        case x of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>;\n        x' = (x1, x2); x = (x1a, x2a);\n        (\\<sigma>', \\<sigma>'')\n        \\<in> {(\\<sigma>, \\<sigma>').\n               ((set x1a - {hd x1a}, \\<sigma>),\n                \\<alpha> ` set x1a - {hd x1}, \\<sigma>')\n               \\<in> R}\\<rbrakk>\n       \\<Longrightarrow> ((tl x1a, \\<sigma>'), tl x1, \\<sigma>'')\n                         \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n                                xs' = map \\<alpha> xs \\<and>\n                                set xs \\<subseteq> S \\<and>\n                                set xs' \\<subseteq> S' \\<and>\n                                (\\<forall>x\\<in>S - set xs.\n                                    \\<forall>y\\<in>set xs. RR x y) \\<and>\n                                (\\<forall>x\\<in>S' - set xs'.\n                                    \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n                                ((set xs, \\<sigma>), set xs', \\<sigma>')\n                                \\<in> R}\n 2. \\<And>xs xsa x x'.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n        \\<not> FOREACH_cond c x; \\<not> FOREACH_cond c' x';\n        case x of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'.\n             xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> (x, x') \\<in> ?R'3 xs xsa\n 3. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x') \\<in> ?R'3 xs xsa; x' = (x1, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> (x2a, x2) \\<in> R'", "apply (clarsimp simp: map_tl)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x2 x1a x2a \\<sigma>' \\<sigma>'' xs'.\n       \\<lbrakk>FOREACH_cond c (x1a, x2a);\n        FOREACH_cond c' (map \\<alpha> x1a, x2);\n        ((set x1a - {hd x1a}, \\<sigma>'),\n         \\<alpha> ` set x1a - {hd (map \\<alpha> x1a)}, \\<sigma>'')\n        \\<in> R;\n        sorted_wrt RR' (map \\<alpha> xs' @ map \\<alpha> x1a);\n        \\<Phi> (set x1a) x2a; \\<Phi>' (\\<alpha> ` set x1a) x2;\n        S = set xs' \\<union> set x1a; sorted_wrt RR (xs' @ x1a);\n        \\<alpha> ` set x1a\n        \\<subseteq> \\<alpha> ` (set xs' \\<union> set x1a);\n        \\<forall>x\\<in>set xs' \\<union> set x1a - set x1a.\n           \\<forall>xa\\<in>set x1a. RR x xa;\n        \\<forall>x\\<in>\\<alpha> ` (set xs' \\<union> set x1a) -\n                       \\<alpha> ` set x1a.\n           \\<forall>xa\\<in>set x1a. RR' x (\\<alpha> xa);\n        ((set x1a, x2a), \\<alpha> ` set x1a, x2) \\<in> R; distinct xs';\n        distinct (map \\<alpha> xs'); distinct x1a;\n        set xs' \\<inter> set x1a = {}; distinct (map \\<alpha> x1a);\n        \\<alpha> ` set xs' \\<inter> \\<alpha> ` set x1a = {}\\<rbrakk>\n       \\<Longrightarrow> set (tl x1a)\n                         \\<subseteq> set xs' \\<union> set x1a \\<and>\n                         set (tl (map \\<alpha> x1a))\n                         \\<subseteq> \\<alpha> `\n                                     (set xs' \\<union> set x1a) \\<and>\n                         (\\<forall>x\\<in>set xs' \\<union> set x1a -\n   set (tl x1a).\n                             \\<forall>xa\\<in>set (tl x1a). RR x xa) \\<and>\n                         (\\<forall>x\\<in>\\<alpha> `\n   (set xs' \\<union> set x1a) -\n   set (tl (map \\<alpha> x1a)).\n                             \\<forall>xa\\<in>set (tl (map \\<alpha> x1a)).\n                                RR' x xa) \\<and>\n                         ((set (tl x1a), \\<sigma>'),\n                          set (tl (map \\<alpha> x1a)), \\<sigma>'')\n                         \\<in> R\n 2. \\<And>xs xsa x x'.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n        \\<not> FOREACH_cond c x; \\<not> FOREACH_cond c' x';\n        case x of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'.\n             xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> (x, x') \\<in> ?R'3 xs xsa\n 3. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x') \\<in> ?R'3 xs xsa; x' = (x1, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> (x2a, x2) \\<in> R'", "apply (intro conjI)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>x2 x1a x2a \\<sigma>' \\<sigma>'' xs'.\n       \\<lbrakk>FOREACH_cond c (x1a, x2a);\n        FOREACH_cond c' (map \\<alpha> x1a, x2);\n        ((set x1a - {hd x1a}, \\<sigma>'),\n         \\<alpha> ` set x1a - {hd (map \\<alpha> x1a)}, \\<sigma>'')\n        \\<in> R;\n        sorted_wrt RR' (map \\<alpha> xs' @ map \\<alpha> x1a);\n        \\<Phi> (set x1a) x2a; \\<Phi>' (\\<alpha> ` set x1a) x2;\n        S = set xs' \\<union> set x1a; sorted_wrt RR (xs' @ x1a);\n        \\<alpha> ` set x1a\n        \\<subseteq> \\<alpha> ` (set xs' \\<union> set x1a);\n        \\<forall>x\\<in>set xs' \\<union> set x1a - set x1a.\n           \\<forall>xa\\<in>set x1a. RR x xa;\n        \\<forall>x\\<in>\\<alpha> ` (set xs' \\<union> set x1a) -\n                       \\<alpha> ` set x1a.\n           \\<forall>xa\\<in>set x1a. RR' x (\\<alpha> xa);\n        ((set x1a, x2a), \\<alpha> ` set x1a, x2) \\<in> R; distinct xs';\n        distinct (map \\<alpha> xs'); distinct x1a;\n        set xs' \\<inter> set x1a = {}; distinct (map \\<alpha> x1a);\n        \\<alpha> ` set xs' \\<inter> \\<alpha> ` set x1a = {}\\<rbrakk>\n       \\<Longrightarrow> set (tl x1a) \\<subseteq> set xs' \\<union> set x1a\n 2. \\<And>x2 x1a x2a \\<sigma>' \\<sigma>'' xs'.\n       \\<lbrakk>FOREACH_cond c (x1a, x2a);\n        FOREACH_cond c' (map \\<alpha> x1a, x2);\n        ((set x1a - {hd x1a}, \\<sigma>'),\n         \\<alpha> ` set x1a - {hd (map \\<alpha> x1a)}, \\<sigma>'')\n        \\<in> R;\n        sorted_wrt RR' (map \\<alpha> xs' @ map \\<alpha> x1a);\n        \\<Phi> (set x1a) x2a; \\<Phi>' (\\<alpha> ` set x1a) x2;\n        S = set xs' \\<union> set x1a; sorted_wrt RR (xs' @ x1a);\n        \\<alpha> ` set x1a\n        \\<subseteq> \\<alpha> ` (set xs' \\<union> set x1a);\n        \\<forall>x\\<in>set xs' \\<union> set x1a - set x1a.\n           \\<forall>xa\\<in>set x1a. RR x xa;\n        \\<forall>x\\<in>\\<alpha> ` (set xs' \\<union> set x1a) -\n                       \\<alpha> ` set x1a.\n           \\<forall>xa\\<in>set x1a. RR' x (\\<alpha> xa);\n        ((set x1a, x2a), \\<alpha> ` set x1a, x2) \\<in> R; distinct xs';\n        distinct (map \\<alpha> xs'); distinct x1a;\n        set xs' \\<inter> set x1a = {}; distinct (map \\<alpha> x1a);\n        \\<alpha> ` set xs' \\<inter> \\<alpha> ` set x1a = {}\\<rbrakk>\n       \\<Longrightarrow> set (tl (map \\<alpha> x1a))\n                         \\<subseteq> \\<alpha> ` (set xs' \\<union> set x1a)\n 3. \\<And>x2 x1a x2a \\<sigma>' \\<sigma>'' xs'.\n       \\<lbrakk>FOREACH_cond c (x1a, x2a);\n        FOREACH_cond c' (map \\<alpha> x1a, x2);\n        ((set x1a - {hd x1a}, \\<sigma>'),\n         \\<alpha> ` set x1a - {hd (map \\<alpha> x1a)}, \\<sigma>'')\n        \\<in> R;\n        sorted_wrt RR' (map \\<alpha> xs' @ map \\<alpha> x1a);\n        \\<Phi> (set x1a) x2a; \\<Phi>' (\\<alpha> ` set x1a) x2;\n        S = set xs' \\<union> set x1a; sorted_wrt RR (xs' @ x1a);\n        \\<alpha> ` set x1a\n        \\<subseteq> \\<alpha> ` (set xs' \\<union> set x1a);\n        \\<forall>x\\<in>set xs' \\<union> set x1a - set x1a.\n           \\<forall>xa\\<in>set x1a. RR x xa;\n        \\<forall>x\\<in>\\<alpha> ` (set xs' \\<union> set x1a) -\n                       \\<alpha> ` set x1a.\n           \\<forall>xa\\<in>set x1a. RR' x (\\<alpha> xa);\n        ((set x1a, x2a), \\<alpha> ` set x1a, x2) \\<in> R; distinct xs';\n        distinct (map \\<alpha> xs'); distinct x1a;\n        set xs' \\<inter> set x1a = {}; distinct (map \\<alpha> x1a);\n        \\<alpha> ` set xs' \\<inter> \\<alpha> ` set x1a = {}\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x\\<in>set xs' \\<union> set x1a -\n  set (tl x1a).\n                            \\<forall>xa\\<in>set (tl x1a). RR x xa\n 4. \\<And>x2 x1a x2a \\<sigma>' \\<sigma>'' xs'.\n       \\<lbrakk>FOREACH_cond c (x1a, x2a);\n        FOREACH_cond c' (map \\<alpha> x1a, x2);\n        ((set x1a - {hd x1a}, \\<sigma>'),\n         \\<alpha> ` set x1a - {hd (map \\<alpha> x1a)}, \\<sigma>'')\n        \\<in> R;\n        sorted_wrt RR' (map \\<alpha> xs' @ map \\<alpha> x1a);\n        \\<Phi> (set x1a) x2a; \\<Phi>' (\\<alpha> ` set x1a) x2;\n        S = set xs' \\<union> set x1a; sorted_wrt RR (xs' @ x1a);\n        \\<alpha> ` set x1a\n        \\<subseteq> \\<alpha> ` (set xs' \\<union> set x1a);\n        \\<forall>x\\<in>set xs' \\<union> set x1a - set x1a.\n           \\<forall>xa\\<in>set x1a. RR x xa;\n        \\<forall>x\\<in>\\<alpha> ` (set xs' \\<union> set x1a) -\n                       \\<alpha> ` set x1a.\n           \\<forall>xa\\<in>set x1a. RR' x (\\<alpha> xa);\n        ((set x1a, x2a), \\<alpha> ` set x1a, x2) \\<in> R; distinct xs';\n        distinct (map \\<alpha> xs'); distinct x1a;\n        set xs' \\<inter> set x1a = {}; distinct (map \\<alpha> x1a);\n        \\<alpha> ` set xs' \\<inter> \\<alpha> ` set x1a = {}\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x\\<in>\\<alpha> `\n  (set xs' \\<union> set x1a) -\n  set (tl (map \\<alpha> x1a)).\n                            \\<forall>xa\\<in>set (tl (map \\<alpha> x1a)).\n                               RR' x xa\n 5. \\<And>x2 x1a x2a \\<sigma>' \\<sigma>'' xs'.\n       \\<lbrakk>FOREACH_cond c (x1a, x2a);\n        FOREACH_cond c' (map \\<alpha> x1a, x2);\n        ((set x1a - {hd x1a}, \\<sigma>'),\n         \\<alpha> ` set x1a - {hd (map \\<alpha> x1a)}, \\<sigma>'')\n        \\<in> R;\n        sorted_wrt RR' (map \\<alpha> xs' @ map \\<alpha> x1a);\n        \\<Phi> (set x1a) x2a; \\<Phi>' (\\<alpha> ` set x1a) x2;\n        S = set xs' \\<union> set x1a; sorted_wrt RR (xs' @ x1a);\n        \\<alpha> ` set x1a\n        \\<subseteq> \\<alpha> ` (set xs' \\<union> set x1a);\n        \\<forall>x\\<in>set xs' \\<union> set x1a - set x1a.\n           \\<forall>xa\\<in>set x1a. RR x xa;\n        \\<forall>x\\<in>\\<alpha> ` (set xs' \\<union> set x1a) -\n                       \\<alpha> ` set x1a.\n           \\<forall>xa\\<in>set x1a. RR' x (\\<alpha> xa);\n        ((set x1a, x2a), \\<alpha> ` set x1a, x2) \\<in> R; distinct xs';\n        distinct (map \\<alpha> xs'); distinct x1a;\n        set xs' \\<inter> set x1a = {}; distinct (map \\<alpha> x1a);\n        \\<alpha> ` set xs' \\<inter> \\<alpha> ` set x1a = {}\\<rbrakk>\n       \\<Longrightarrow> ((set (tl x1a), \\<sigma>'),\n                          set (tl (map \\<alpha> x1a)), \\<sigma>'')\n                         \\<in> R\n 6. \\<And>xs xsa x x'.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n        \\<not> FOREACH_cond c x; \\<not> FOREACH_cond c' x';\n        case x of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'.\n             xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> (x, x') \\<in> ?R'3 xs xsa\n 7. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x') \\<in> ?R'3 xs xsa; x' = (x1, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> (x2a, x2) \\<in> R'", "apply (rename_tac a b d e f g)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>a b d e f g.\n       \\<lbrakk>FOREACH_cond c (b, d); FOREACH_cond c' (map \\<alpha> b, a);\n        ((set b - {hd b}, e), \\<alpha> ` set b - {hd (map \\<alpha> b)}, f)\n        \\<in> R;\n        sorted_wrt RR' (map \\<alpha> g @ map \\<alpha> b); \\<Phi> (set b) d;\n        \\<Phi>' (\\<alpha> ` set b) a; S = set g \\<union> set b;\n        sorted_wrt RR (g @ b);\n        \\<alpha> ` set b \\<subseteq> \\<alpha> ` (set g \\<union> set b);\n        \\<forall>x\\<in>set g \\<union> set b - set b.\n           \\<forall>xa\\<in>set b. RR x xa;\n        \\<forall>x\\<in>\\<alpha> ` (set g \\<union> set b) - \\<alpha> ` set b.\n           \\<forall>xa\\<in>set b. RR' x (\\<alpha> xa);\n        ((set b, d), \\<alpha> ` set b, a) \\<in> R; distinct g;\n        distinct (map \\<alpha> g); distinct b; set g \\<inter> set b = {};\n        distinct (map \\<alpha> b);\n        \\<alpha> ` set g \\<inter> \\<alpha> ` set b = {}\\<rbrakk>\n       \\<Longrightarrow> set (tl b) \\<subseteq> set g \\<union> set b\n 2. \\<And>x2 x1a x2a \\<sigma>' \\<sigma>'' xs'.\n       \\<lbrakk>FOREACH_cond c (x1a, x2a);\n        FOREACH_cond c' (map \\<alpha> x1a, x2);\n        ((set x1a - {hd x1a}, \\<sigma>'),\n         \\<alpha> ` set x1a - {hd (map \\<alpha> x1a)}, \\<sigma>'')\n        \\<in> R;\n        sorted_wrt RR' (map \\<alpha> xs' @ map \\<alpha> x1a);\n        \\<Phi> (set x1a) x2a; \\<Phi>' (\\<alpha> ` set x1a) x2;\n        S = set xs' \\<union> set x1a; sorted_wrt RR (xs' @ x1a);\n        \\<alpha> ` set x1a\n        \\<subseteq> \\<alpha> ` (set xs' \\<union> set x1a);\n        \\<forall>x\\<in>set xs' \\<union> set x1a - set x1a.\n           \\<forall>xa\\<in>set x1a. RR x xa;\n        \\<forall>x\\<in>\\<alpha> ` (set xs' \\<union> set x1a) -\n                       \\<alpha> ` set x1a.\n           \\<forall>xa\\<in>set x1a. RR' x (\\<alpha> xa);\n        ((set x1a, x2a), \\<alpha> ` set x1a, x2) \\<in> R; distinct xs';\n        distinct (map \\<alpha> xs'); distinct x1a;\n        set xs' \\<inter> set x1a = {}; distinct (map \\<alpha> x1a);\n        \\<alpha> ` set xs' \\<inter> \\<alpha> ` set x1a = {}\\<rbrakk>\n       \\<Longrightarrow> set (tl (map \\<alpha> x1a))\n                         \\<subseteq> \\<alpha> ` (set xs' \\<union> set x1a)\n 3. \\<And>x2 x1a x2a \\<sigma>' \\<sigma>'' xs'.\n       \\<lbrakk>FOREACH_cond c (x1a, x2a);\n        FOREACH_cond c' (map \\<alpha> x1a, x2);\n        ((set x1a - {hd x1a}, \\<sigma>'),\n         \\<alpha> ` set x1a - {hd (map \\<alpha> x1a)}, \\<sigma>'')\n        \\<in> R;\n        sorted_wrt RR' (map \\<alpha> xs' @ map \\<alpha> x1a);\n        \\<Phi> (set x1a) x2a; \\<Phi>' (\\<alpha> ` set x1a) x2;\n        S = set xs' \\<union> set x1a; sorted_wrt RR (xs' @ x1a);\n        \\<alpha> ` set x1a\n        \\<subseteq> \\<alpha> ` (set xs' \\<union> set x1a);\n        \\<forall>x\\<in>set xs' \\<union> set x1a - set x1a.\n           \\<forall>xa\\<in>set x1a. RR x xa;\n        \\<forall>x\\<in>\\<alpha> ` (set xs' \\<union> set x1a) -\n                       \\<alpha> ` set x1a.\n           \\<forall>xa\\<in>set x1a. RR' x (\\<alpha> xa);\n        ((set x1a, x2a), \\<alpha> ` set x1a, x2) \\<in> R; distinct xs';\n        distinct (map \\<alpha> xs'); distinct x1a;\n        set xs' \\<inter> set x1a = {}; distinct (map \\<alpha> x1a);\n        \\<alpha> ` set xs' \\<inter> \\<alpha> ` set x1a = {}\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x\\<in>set xs' \\<union> set x1a -\n  set (tl x1a).\n                            \\<forall>xa\\<in>set (tl x1a). RR x xa\n 4. \\<And>x2 x1a x2a \\<sigma>' \\<sigma>'' xs'.\n       \\<lbrakk>FOREACH_cond c (x1a, x2a);\n        FOREACH_cond c' (map \\<alpha> x1a, x2);\n        ((set x1a - {hd x1a}, \\<sigma>'),\n         \\<alpha> ` set x1a - {hd (map \\<alpha> x1a)}, \\<sigma>'')\n        \\<in> R;\n        sorted_wrt RR' (map \\<alpha> xs' @ map \\<alpha> x1a);\n        \\<Phi> (set x1a) x2a; \\<Phi>' (\\<alpha> ` set x1a) x2;\n        S = set xs' \\<union> set x1a; sorted_wrt RR (xs' @ x1a);\n        \\<alpha> ` set x1a\n        \\<subseteq> \\<alpha> ` (set xs' \\<union> set x1a);\n        \\<forall>x\\<in>set xs' \\<union> set x1a - set x1a.\n           \\<forall>xa\\<in>set x1a. RR x xa;\n        \\<forall>x\\<in>\\<alpha> ` (set xs' \\<union> set x1a) -\n                       \\<alpha> ` set x1a.\n           \\<forall>xa\\<in>set x1a. RR' x (\\<alpha> xa);\n        ((set x1a, x2a), \\<alpha> ` set x1a, x2) \\<in> R; distinct xs';\n        distinct (map \\<alpha> xs'); distinct x1a;\n        set xs' \\<inter> set x1a = {}; distinct (map \\<alpha> x1a);\n        \\<alpha> ` set xs' \\<inter> \\<alpha> ` set x1a = {}\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x\\<in>\\<alpha> `\n  (set xs' \\<union> set x1a) -\n  set (tl (map \\<alpha> x1a)).\n                            \\<forall>xa\\<in>set (tl (map \\<alpha> x1a)).\n                               RR' x xa\n 5. \\<And>x2 x1a x2a \\<sigma>' \\<sigma>'' xs'.\n       \\<lbrakk>FOREACH_cond c (x1a, x2a);\n        FOREACH_cond c' (map \\<alpha> x1a, x2);\n        ((set x1a - {hd x1a}, \\<sigma>'),\n         \\<alpha> ` set x1a - {hd (map \\<alpha> x1a)}, \\<sigma>'')\n        \\<in> R;\n        sorted_wrt RR' (map \\<alpha> xs' @ map \\<alpha> x1a);\n        \\<Phi> (set x1a) x2a; \\<Phi>' (\\<alpha> ` set x1a) x2;\n        S = set xs' \\<union> set x1a; sorted_wrt RR (xs' @ x1a);\n        \\<alpha> ` set x1a\n        \\<subseteq> \\<alpha> ` (set xs' \\<union> set x1a);\n        \\<forall>x\\<in>set xs' \\<union> set x1a - set x1a.\n           \\<forall>xa\\<in>set x1a. RR x xa;\n        \\<forall>x\\<in>\\<alpha> ` (set xs' \\<union> set x1a) -\n                       \\<alpha> ` set x1a.\n           \\<forall>xa\\<in>set x1a. RR' x (\\<alpha> xa);\n        ((set x1a, x2a), \\<alpha> ` set x1a, x2) \\<in> R; distinct xs';\n        distinct (map \\<alpha> xs'); distinct x1a;\n        set xs' \\<inter> set x1a = {}; distinct (map \\<alpha> x1a);\n        \\<alpha> ` set xs' \\<inter> \\<alpha> ` set x1a = {}\\<rbrakk>\n       \\<Longrightarrow> ((set (tl x1a), \\<sigma>'),\n                          set (tl (map \\<alpha> x1a)), \\<sigma>'')\n                         \\<in> R\n 6. \\<And>xs xsa x x'.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n        \\<not> FOREACH_cond c x; \\<not> FOREACH_cond c' x';\n        case x of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'.\n             xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> (x, x') \\<in> ?R'3 xs xsa\n 7. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x') \\<in> ?R'3 xs xsa; x' = (x1, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> (x2a, x2) \\<in> R'", "apply (case_tac b, auto) []"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>x2 x1a x2a \\<sigma>' \\<sigma>'' xs'.\n       \\<lbrakk>FOREACH_cond c (x1a, x2a);\n        FOREACH_cond c' (map \\<alpha> x1a, x2);\n        ((set x1a - {hd x1a}, \\<sigma>'),\n         \\<alpha> ` set x1a - {hd (map \\<alpha> x1a)}, \\<sigma>'')\n        \\<in> R;\n        sorted_wrt RR' (map \\<alpha> xs' @ map \\<alpha> x1a);\n        \\<Phi> (set x1a) x2a; \\<Phi>' (\\<alpha> ` set x1a) x2;\n        S = set xs' \\<union> set x1a; sorted_wrt RR (xs' @ x1a);\n        \\<alpha> ` set x1a\n        \\<subseteq> \\<alpha> ` (set xs' \\<union> set x1a);\n        \\<forall>x\\<in>set xs' \\<union> set x1a - set x1a.\n           \\<forall>xa\\<in>set x1a. RR x xa;\n        \\<forall>x\\<in>\\<alpha> ` (set xs' \\<union> set x1a) -\n                       \\<alpha> ` set x1a.\n           \\<forall>xa\\<in>set x1a. RR' x (\\<alpha> xa);\n        ((set x1a, x2a), \\<alpha> ` set x1a, x2) \\<in> R; distinct xs';\n        distinct (map \\<alpha> xs'); distinct x1a;\n        set xs' \\<inter> set x1a = {}; distinct (map \\<alpha> x1a);\n        \\<alpha> ` set xs' \\<inter> \\<alpha> ` set x1a = {}\\<rbrakk>\n       \\<Longrightarrow> set (tl (map \\<alpha> x1a))\n                         \\<subseteq> \\<alpha> ` (set xs' \\<union> set x1a)\n 2. \\<And>x2 x1a x2a \\<sigma>' \\<sigma>'' xs'.\n       \\<lbrakk>FOREACH_cond c (x1a, x2a);\n        FOREACH_cond c' (map \\<alpha> x1a, x2);\n        ((set x1a - {hd x1a}, \\<sigma>'),\n         \\<alpha> ` set x1a - {hd (map \\<alpha> x1a)}, \\<sigma>'')\n        \\<in> R;\n        sorted_wrt RR' (map \\<alpha> xs' @ map \\<alpha> x1a);\n        \\<Phi> (set x1a) x2a; \\<Phi>' (\\<alpha> ` set x1a) x2;\n        S = set xs' \\<union> set x1a; sorted_wrt RR (xs' @ x1a);\n        \\<alpha> ` set x1a\n        \\<subseteq> \\<alpha> ` (set xs' \\<union> set x1a);\n        \\<forall>x\\<in>set xs' \\<union> set x1a - set x1a.\n           \\<forall>xa\\<in>set x1a. RR x xa;\n        \\<forall>x\\<in>\\<alpha> ` (set xs' \\<union> set x1a) -\n                       \\<alpha> ` set x1a.\n           \\<forall>xa\\<in>set x1a. RR' x (\\<alpha> xa);\n        ((set x1a, x2a), \\<alpha> ` set x1a, x2) \\<in> R; distinct xs';\n        distinct (map \\<alpha> xs'); distinct x1a;\n        set xs' \\<inter> set x1a = {}; distinct (map \\<alpha> x1a);\n        \\<alpha> ` set xs' \\<inter> \\<alpha> ` set x1a = {}\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x\\<in>set xs' \\<union> set x1a -\n  set (tl x1a).\n                            \\<forall>xa\\<in>set (tl x1a). RR x xa\n 3. \\<And>x2 x1a x2a \\<sigma>' \\<sigma>'' xs'.\n       \\<lbrakk>FOREACH_cond c (x1a, x2a);\n        FOREACH_cond c' (map \\<alpha> x1a, x2);\n        ((set x1a - {hd x1a}, \\<sigma>'),\n         \\<alpha> ` set x1a - {hd (map \\<alpha> x1a)}, \\<sigma>'')\n        \\<in> R;\n        sorted_wrt RR' (map \\<alpha> xs' @ map \\<alpha> x1a);\n        \\<Phi> (set x1a) x2a; \\<Phi>' (\\<alpha> ` set x1a) x2;\n        S = set xs' \\<union> set x1a; sorted_wrt RR (xs' @ x1a);\n        \\<alpha> ` set x1a\n        \\<subseteq> \\<alpha> ` (set xs' \\<union> set x1a);\n        \\<forall>x\\<in>set xs' \\<union> set x1a - set x1a.\n           \\<forall>xa\\<in>set x1a. RR x xa;\n        \\<forall>x\\<in>\\<alpha> ` (set xs' \\<union> set x1a) -\n                       \\<alpha> ` set x1a.\n           \\<forall>xa\\<in>set x1a. RR' x (\\<alpha> xa);\n        ((set x1a, x2a), \\<alpha> ` set x1a, x2) \\<in> R; distinct xs';\n        distinct (map \\<alpha> xs'); distinct x1a;\n        set xs' \\<inter> set x1a = {}; distinct (map \\<alpha> x1a);\n        \\<alpha> ` set xs' \\<inter> \\<alpha> ` set x1a = {}\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x\\<in>\\<alpha> `\n  (set xs' \\<union> set x1a) -\n  set (tl (map \\<alpha> x1a)).\n                            \\<forall>xa\\<in>set (tl (map \\<alpha> x1a)).\n                               RR' x xa\n 4. \\<And>x2 x1a x2a \\<sigma>' \\<sigma>'' xs'.\n       \\<lbrakk>FOREACH_cond c (x1a, x2a);\n        FOREACH_cond c' (map \\<alpha> x1a, x2);\n        ((set x1a - {hd x1a}, \\<sigma>'),\n         \\<alpha> ` set x1a - {hd (map \\<alpha> x1a)}, \\<sigma>'')\n        \\<in> R;\n        sorted_wrt RR' (map \\<alpha> xs' @ map \\<alpha> x1a);\n        \\<Phi> (set x1a) x2a; \\<Phi>' (\\<alpha> ` set x1a) x2;\n        S = set xs' \\<union> set x1a; sorted_wrt RR (xs' @ x1a);\n        \\<alpha> ` set x1a\n        \\<subseteq> \\<alpha> ` (set xs' \\<union> set x1a);\n        \\<forall>x\\<in>set xs' \\<union> set x1a - set x1a.\n           \\<forall>xa\\<in>set x1a. RR x xa;\n        \\<forall>x\\<in>\\<alpha> ` (set xs' \\<union> set x1a) -\n                       \\<alpha> ` set x1a.\n           \\<forall>xa\\<in>set x1a. RR' x (\\<alpha> xa);\n        ((set x1a, x2a), \\<alpha> ` set x1a, x2) \\<in> R; distinct xs';\n        distinct (map \\<alpha> xs'); distinct x1a;\n        set xs' \\<inter> set x1a = {}; distinct (map \\<alpha> x1a);\n        \\<alpha> ` set xs' \\<inter> \\<alpha> ` set x1a = {}\\<rbrakk>\n       \\<Longrightarrow> ((set (tl x1a), \\<sigma>'),\n                          set (tl (map \\<alpha> x1a)), \\<sigma>'')\n                         \\<in> R\n 5. \\<And>xs xsa x x'.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n        \\<not> FOREACH_cond c x; \\<not> FOREACH_cond c' x';\n        case x of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'.\n             xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> (x, x') \\<in> ?R'3 xs xsa\n 6. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x') \\<in> ?R'3 xs xsa; x' = (x1, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> (x2a, x2) \\<in> R'", "apply (rename_tac a b d e f g)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>a b d e f g.\n       \\<lbrakk>FOREACH_cond c (b, d); FOREACH_cond c' (map \\<alpha> b, a);\n        ((set b - {hd b}, e), \\<alpha> ` set b - {hd (map \\<alpha> b)}, f)\n        \\<in> R;\n        sorted_wrt RR' (map \\<alpha> g @ map \\<alpha> b); \\<Phi> (set b) d;\n        \\<Phi>' (\\<alpha> ` set b) a; S = set g \\<union> set b;\n        sorted_wrt RR (g @ b);\n        \\<alpha> ` set b \\<subseteq> \\<alpha> ` (set g \\<union> set b);\n        \\<forall>x\\<in>set g \\<union> set b - set b.\n           \\<forall>xa\\<in>set b. RR x xa;\n        \\<forall>x\\<in>\\<alpha> ` (set g \\<union> set b) - \\<alpha> ` set b.\n           \\<forall>xa\\<in>set b. RR' x (\\<alpha> xa);\n        ((set b, d), \\<alpha> ` set b, a) \\<in> R; distinct g;\n        distinct (map \\<alpha> g); distinct b; set g \\<inter> set b = {};\n        distinct (map \\<alpha> b);\n        \\<alpha> ` set g \\<inter> \\<alpha> ` set b = {}\\<rbrakk>\n       \\<Longrightarrow> set (tl (map \\<alpha> b))\n                         \\<subseteq> \\<alpha> ` (set g \\<union> set b)\n 2. \\<And>x2 x1a x2a \\<sigma>' \\<sigma>'' xs'.\n       \\<lbrakk>FOREACH_cond c (x1a, x2a);\n        FOREACH_cond c' (map \\<alpha> x1a, x2);\n        ((set x1a - {hd x1a}, \\<sigma>'),\n         \\<alpha> ` set x1a - {hd (map \\<alpha> x1a)}, \\<sigma>'')\n        \\<in> R;\n        sorted_wrt RR' (map \\<alpha> xs' @ map \\<alpha> x1a);\n        \\<Phi> (set x1a) x2a; \\<Phi>' (\\<alpha> ` set x1a) x2;\n        S = set xs' \\<union> set x1a; sorted_wrt RR (xs' @ x1a);\n        \\<alpha> ` set x1a\n        \\<subseteq> \\<alpha> ` (set xs' \\<union> set x1a);\n        \\<forall>x\\<in>set xs' \\<union> set x1a - set x1a.\n           \\<forall>xa\\<in>set x1a. RR x xa;\n        \\<forall>x\\<in>\\<alpha> ` (set xs' \\<union> set x1a) -\n                       \\<alpha> ` set x1a.\n           \\<forall>xa\\<in>set x1a. RR' x (\\<alpha> xa);\n        ((set x1a, x2a), \\<alpha> ` set x1a, x2) \\<in> R; distinct xs';\n        distinct (map \\<alpha> xs'); distinct x1a;\n        set xs' \\<inter> set x1a = {}; distinct (map \\<alpha> x1a);\n        \\<alpha> ` set xs' \\<inter> \\<alpha> ` set x1a = {}\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x\\<in>set xs' \\<union> set x1a -\n  set (tl x1a).\n                            \\<forall>xa\\<in>set (tl x1a). RR x xa\n 3. \\<And>x2 x1a x2a \\<sigma>' \\<sigma>'' xs'.\n       \\<lbrakk>FOREACH_cond c (x1a, x2a);\n        FOREACH_cond c' (map \\<alpha> x1a, x2);\n        ((set x1a - {hd x1a}, \\<sigma>'),\n         \\<alpha> ` set x1a - {hd (map \\<alpha> x1a)}, \\<sigma>'')\n        \\<in> R;\n        sorted_wrt RR' (map \\<alpha> xs' @ map \\<alpha> x1a);\n        \\<Phi> (set x1a) x2a; \\<Phi>' (\\<alpha> ` set x1a) x2;\n        S = set xs' \\<union> set x1a; sorted_wrt RR (xs' @ x1a);\n        \\<alpha> ` set x1a\n        \\<subseteq> \\<alpha> ` (set xs' \\<union> set x1a);\n        \\<forall>x\\<in>set xs' \\<union> set x1a - set x1a.\n           \\<forall>xa\\<in>set x1a. RR x xa;\n        \\<forall>x\\<in>\\<alpha> ` (set xs' \\<union> set x1a) -\n                       \\<alpha> ` set x1a.\n           \\<forall>xa\\<in>set x1a. RR' x (\\<alpha> xa);\n        ((set x1a, x2a), \\<alpha> ` set x1a, x2) \\<in> R; distinct xs';\n        distinct (map \\<alpha> xs'); distinct x1a;\n        set xs' \\<inter> set x1a = {}; distinct (map \\<alpha> x1a);\n        \\<alpha> ` set xs' \\<inter> \\<alpha> ` set x1a = {}\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x\\<in>\\<alpha> `\n  (set xs' \\<union> set x1a) -\n  set (tl (map \\<alpha> x1a)).\n                            \\<forall>xa\\<in>set (tl (map \\<alpha> x1a)).\n                               RR' x xa\n 4. \\<And>x2 x1a x2a \\<sigma>' \\<sigma>'' xs'.\n       \\<lbrakk>FOREACH_cond c (x1a, x2a);\n        FOREACH_cond c' (map \\<alpha> x1a, x2);\n        ((set x1a - {hd x1a}, \\<sigma>'),\n         \\<alpha> ` set x1a - {hd (map \\<alpha> x1a)}, \\<sigma>'')\n        \\<in> R;\n        sorted_wrt RR' (map \\<alpha> xs' @ map \\<alpha> x1a);\n        \\<Phi> (set x1a) x2a; \\<Phi>' (\\<alpha> ` set x1a) x2;\n        S = set xs' \\<union> set x1a; sorted_wrt RR (xs' @ x1a);\n        \\<alpha> ` set x1a\n        \\<subseteq> \\<alpha> ` (set xs' \\<union> set x1a);\n        \\<forall>x\\<in>set xs' \\<union> set x1a - set x1a.\n           \\<forall>xa\\<in>set x1a. RR x xa;\n        \\<forall>x\\<in>\\<alpha> ` (set xs' \\<union> set x1a) -\n                       \\<alpha> ` set x1a.\n           \\<forall>xa\\<in>set x1a. RR' x (\\<alpha> xa);\n        ((set x1a, x2a), \\<alpha> ` set x1a, x2) \\<in> R; distinct xs';\n        distinct (map \\<alpha> xs'); distinct x1a;\n        set xs' \\<inter> set x1a = {}; distinct (map \\<alpha> x1a);\n        \\<alpha> ` set xs' \\<inter> \\<alpha> ` set x1a = {}\\<rbrakk>\n       \\<Longrightarrow> ((set (tl x1a), \\<sigma>'),\n                          set (tl (map \\<alpha> x1a)), \\<sigma>'')\n                         \\<in> R\n 5. \\<And>xs xsa x x'.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n        \\<not> FOREACH_cond c x; \\<not> FOREACH_cond c' x';\n        case x of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'.\n             xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> (x, x') \\<in> ?R'3 xs xsa\n 6. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x') \\<in> ?R'3 xs xsa; x' = (x1, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> (x2a, x2) \\<in> R'", "apply (case_tac b, auto) []"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x2 x1a x2a \\<sigma>' \\<sigma>'' xs'.\n       \\<lbrakk>FOREACH_cond c (x1a, x2a);\n        FOREACH_cond c' (map \\<alpha> x1a, x2);\n        ((set x1a - {hd x1a}, \\<sigma>'),\n         \\<alpha> ` set x1a - {hd (map \\<alpha> x1a)}, \\<sigma>'')\n        \\<in> R;\n        sorted_wrt RR' (map \\<alpha> xs' @ map \\<alpha> x1a);\n        \\<Phi> (set x1a) x2a; \\<Phi>' (\\<alpha> ` set x1a) x2;\n        S = set xs' \\<union> set x1a; sorted_wrt RR (xs' @ x1a);\n        \\<alpha> ` set x1a\n        \\<subseteq> \\<alpha> ` (set xs' \\<union> set x1a);\n        \\<forall>x\\<in>set xs' \\<union> set x1a - set x1a.\n           \\<forall>xa\\<in>set x1a. RR x xa;\n        \\<forall>x\\<in>\\<alpha> ` (set xs' \\<union> set x1a) -\n                       \\<alpha> ` set x1a.\n           \\<forall>xa\\<in>set x1a. RR' x (\\<alpha> xa);\n        ((set x1a, x2a), \\<alpha> ` set x1a, x2) \\<in> R; distinct xs';\n        distinct (map \\<alpha> xs'); distinct x1a;\n        set xs' \\<inter> set x1a = {}; distinct (map \\<alpha> x1a);\n        \\<alpha> ` set xs' \\<inter> \\<alpha> ` set x1a = {}\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x\\<in>set xs' \\<union> set x1a -\n  set (tl x1a).\n                            \\<forall>xa\\<in>set (tl x1a). RR x xa\n 2. \\<And>x2 x1a x2a \\<sigma>' \\<sigma>'' xs'.\n       \\<lbrakk>FOREACH_cond c (x1a, x2a);\n        FOREACH_cond c' (map \\<alpha> x1a, x2);\n        ((set x1a - {hd x1a}, \\<sigma>'),\n         \\<alpha> ` set x1a - {hd (map \\<alpha> x1a)}, \\<sigma>'')\n        \\<in> R;\n        sorted_wrt RR' (map \\<alpha> xs' @ map \\<alpha> x1a);\n        \\<Phi> (set x1a) x2a; \\<Phi>' (\\<alpha> ` set x1a) x2;\n        S = set xs' \\<union> set x1a; sorted_wrt RR (xs' @ x1a);\n        \\<alpha> ` set x1a\n        \\<subseteq> \\<alpha> ` (set xs' \\<union> set x1a);\n        \\<forall>x\\<in>set xs' \\<union> set x1a - set x1a.\n           \\<forall>xa\\<in>set x1a. RR x xa;\n        \\<forall>x\\<in>\\<alpha> ` (set xs' \\<union> set x1a) -\n                       \\<alpha> ` set x1a.\n           \\<forall>xa\\<in>set x1a. RR' x (\\<alpha> xa);\n        ((set x1a, x2a), \\<alpha> ` set x1a, x2) \\<in> R; distinct xs';\n        distinct (map \\<alpha> xs'); distinct x1a;\n        set xs' \\<inter> set x1a = {}; distinct (map \\<alpha> x1a);\n        \\<alpha> ` set xs' \\<inter> \\<alpha> ` set x1a = {}\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x\\<in>\\<alpha> `\n  (set xs' \\<union> set x1a) -\n  set (tl (map \\<alpha> x1a)).\n                            \\<forall>xa\\<in>set (tl (map \\<alpha> x1a)).\n                               RR' x xa\n 3. \\<And>x2 x1a x2a \\<sigma>' \\<sigma>'' xs'.\n       \\<lbrakk>FOREACH_cond c (x1a, x2a);\n        FOREACH_cond c' (map \\<alpha> x1a, x2);\n        ((set x1a - {hd x1a}, \\<sigma>'),\n         \\<alpha> ` set x1a - {hd (map \\<alpha> x1a)}, \\<sigma>'')\n        \\<in> R;\n        sorted_wrt RR' (map \\<alpha> xs' @ map \\<alpha> x1a);\n        \\<Phi> (set x1a) x2a; \\<Phi>' (\\<alpha> ` set x1a) x2;\n        S = set xs' \\<union> set x1a; sorted_wrt RR (xs' @ x1a);\n        \\<alpha> ` set x1a\n        \\<subseteq> \\<alpha> ` (set xs' \\<union> set x1a);\n        \\<forall>x\\<in>set xs' \\<union> set x1a - set x1a.\n           \\<forall>xa\\<in>set x1a. RR x xa;\n        \\<forall>x\\<in>\\<alpha> ` (set xs' \\<union> set x1a) -\n                       \\<alpha> ` set x1a.\n           \\<forall>xa\\<in>set x1a. RR' x (\\<alpha> xa);\n        ((set x1a, x2a), \\<alpha> ` set x1a, x2) \\<in> R; distinct xs';\n        distinct (map \\<alpha> xs'); distinct x1a;\n        set xs' \\<inter> set x1a = {}; distinct (map \\<alpha> x1a);\n        \\<alpha> ` set xs' \\<inter> \\<alpha> ` set x1a = {}\\<rbrakk>\n       \\<Longrightarrow> ((set (tl x1a), \\<sigma>'),\n                          set (tl (map \\<alpha> x1a)), \\<sigma>'')\n                         \\<in> R\n 4. \\<And>xs xsa x x'.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n        \\<not> FOREACH_cond c x; \\<not> FOREACH_cond c' x';\n        case x of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'.\n             xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> (x, x') \\<in> ?R'3 xs xsa\n 5. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x') \\<in> ?R'3 xs xsa; x' = (x1, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> (x2a, x2) \\<in> R'", "apply (rename_tac a b d e f g)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>a b d e f g.\n       \\<lbrakk>FOREACH_cond c (b, d); FOREACH_cond c' (map \\<alpha> b, a);\n        ((set b - {hd b}, e), \\<alpha> ` set b - {hd (map \\<alpha> b)}, f)\n        \\<in> R;\n        sorted_wrt RR' (map \\<alpha> g @ map \\<alpha> b); \\<Phi> (set b) d;\n        \\<Phi>' (\\<alpha> ` set b) a; S = set g \\<union> set b;\n        sorted_wrt RR (g @ b);\n        \\<alpha> ` set b \\<subseteq> \\<alpha> ` (set g \\<union> set b);\n        \\<forall>x\\<in>set g \\<union> set b - set b.\n           \\<forall>xa\\<in>set b. RR x xa;\n        \\<forall>x\\<in>\\<alpha> ` (set g \\<union> set b) - \\<alpha> ` set b.\n           \\<forall>xa\\<in>set b. RR' x (\\<alpha> xa);\n        ((set b, d), \\<alpha> ` set b, a) \\<in> R; distinct g;\n        distinct (map \\<alpha> g); distinct b; set g \\<inter> set b = {};\n        distinct (map \\<alpha> b);\n        \\<alpha> ` set g \\<inter> \\<alpha> ` set b = {}\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x\\<in>set g \\<union> set b - set (tl b).\n                            \\<forall>xa\\<in>set (tl b). RR x xa\n 2. \\<And>x2 x1a x2a \\<sigma>' \\<sigma>'' xs'.\n       \\<lbrakk>FOREACH_cond c (x1a, x2a);\n        FOREACH_cond c' (map \\<alpha> x1a, x2);\n        ((set x1a - {hd x1a}, \\<sigma>'),\n         \\<alpha> ` set x1a - {hd (map \\<alpha> x1a)}, \\<sigma>'')\n        \\<in> R;\n        sorted_wrt RR' (map \\<alpha> xs' @ map \\<alpha> x1a);\n        \\<Phi> (set x1a) x2a; \\<Phi>' (\\<alpha> ` set x1a) x2;\n        S = set xs' \\<union> set x1a; sorted_wrt RR (xs' @ x1a);\n        \\<alpha> ` set x1a\n        \\<subseteq> \\<alpha> ` (set xs' \\<union> set x1a);\n        \\<forall>x\\<in>set xs' \\<union> set x1a - set x1a.\n           \\<forall>xa\\<in>set x1a. RR x xa;\n        \\<forall>x\\<in>\\<alpha> ` (set xs' \\<union> set x1a) -\n                       \\<alpha> ` set x1a.\n           \\<forall>xa\\<in>set x1a. RR' x (\\<alpha> xa);\n        ((set x1a, x2a), \\<alpha> ` set x1a, x2) \\<in> R; distinct xs';\n        distinct (map \\<alpha> xs'); distinct x1a;\n        set xs' \\<inter> set x1a = {}; distinct (map \\<alpha> x1a);\n        \\<alpha> ` set xs' \\<inter> \\<alpha> ` set x1a = {}\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x\\<in>\\<alpha> `\n  (set xs' \\<union> set x1a) -\n  set (tl (map \\<alpha> x1a)).\n                            \\<forall>xa\\<in>set (tl (map \\<alpha> x1a)).\n                               RR' x xa\n 3. \\<And>x2 x1a x2a \\<sigma>' \\<sigma>'' xs'.\n       \\<lbrakk>FOREACH_cond c (x1a, x2a);\n        FOREACH_cond c' (map \\<alpha> x1a, x2);\n        ((set x1a - {hd x1a}, \\<sigma>'),\n         \\<alpha> ` set x1a - {hd (map \\<alpha> x1a)}, \\<sigma>'')\n        \\<in> R;\n        sorted_wrt RR' (map \\<alpha> xs' @ map \\<alpha> x1a);\n        \\<Phi> (set x1a) x2a; \\<Phi>' (\\<alpha> ` set x1a) x2;\n        S = set xs' \\<union> set x1a; sorted_wrt RR (xs' @ x1a);\n        \\<alpha> ` set x1a\n        \\<subseteq> \\<alpha> ` (set xs' \\<union> set x1a);\n        \\<forall>x\\<in>set xs' \\<union> set x1a - set x1a.\n           \\<forall>xa\\<in>set x1a. RR x xa;\n        \\<forall>x\\<in>\\<alpha> ` (set xs' \\<union> set x1a) -\n                       \\<alpha> ` set x1a.\n           \\<forall>xa\\<in>set x1a. RR' x (\\<alpha> xa);\n        ((set x1a, x2a), \\<alpha> ` set x1a, x2) \\<in> R; distinct xs';\n        distinct (map \\<alpha> xs'); distinct x1a;\n        set xs' \\<inter> set x1a = {}; distinct (map \\<alpha> x1a);\n        \\<alpha> ` set xs' \\<inter> \\<alpha> ` set x1a = {}\\<rbrakk>\n       \\<Longrightarrow> ((set (tl x1a), \\<sigma>'),\n                          set (tl (map \\<alpha> x1a)), \\<sigma>'')\n                         \\<in> R\n 4. \\<And>xs xsa x x'.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n        \\<not> FOREACH_cond c x; \\<not> FOREACH_cond c' x';\n        case x of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'.\n             xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> (x, x') \\<in> ?R'3 xs xsa\n 5. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x') \\<in> ?R'3 xs xsa; x' = (x1, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> (x2a, x2) \\<in> R'", "apply (case_tac b, auto simp: sorted_wrt_append) []"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x2 x1a x2a \\<sigma>' \\<sigma>'' xs'.\n       \\<lbrakk>FOREACH_cond c (x1a, x2a);\n        FOREACH_cond c' (map \\<alpha> x1a, x2);\n        ((set x1a - {hd x1a}, \\<sigma>'),\n         \\<alpha> ` set x1a - {hd (map \\<alpha> x1a)}, \\<sigma>'')\n        \\<in> R;\n        sorted_wrt RR' (map \\<alpha> xs' @ map \\<alpha> x1a);\n        \\<Phi> (set x1a) x2a; \\<Phi>' (\\<alpha> ` set x1a) x2;\n        S = set xs' \\<union> set x1a; sorted_wrt RR (xs' @ x1a);\n        \\<alpha> ` set x1a\n        \\<subseteq> \\<alpha> ` (set xs' \\<union> set x1a);\n        \\<forall>x\\<in>set xs' \\<union> set x1a - set x1a.\n           \\<forall>xa\\<in>set x1a. RR x xa;\n        \\<forall>x\\<in>\\<alpha> ` (set xs' \\<union> set x1a) -\n                       \\<alpha> ` set x1a.\n           \\<forall>xa\\<in>set x1a. RR' x (\\<alpha> xa);\n        ((set x1a, x2a), \\<alpha> ` set x1a, x2) \\<in> R; distinct xs';\n        distinct (map \\<alpha> xs'); distinct x1a;\n        set xs' \\<inter> set x1a = {}; distinct (map \\<alpha> x1a);\n        \\<alpha> ` set xs' \\<inter> \\<alpha> ` set x1a = {}\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x\\<in>\\<alpha> `\n  (set xs' \\<union> set x1a) -\n  set (tl (map \\<alpha> x1a)).\n                            \\<forall>xa\\<in>set (tl (map \\<alpha> x1a)).\n                               RR' x xa\n 2. \\<And>x2 x1a x2a \\<sigma>' \\<sigma>'' xs'.\n       \\<lbrakk>FOREACH_cond c (x1a, x2a);\n        FOREACH_cond c' (map \\<alpha> x1a, x2);\n        ((set x1a - {hd x1a}, \\<sigma>'),\n         \\<alpha> ` set x1a - {hd (map \\<alpha> x1a)}, \\<sigma>'')\n        \\<in> R;\n        sorted_wrt RR' (map \\<alpha> xs' @ map \\<alpha> x1a);\n        \\<Phi> (set x1a) x2a; \\<Phi>' (\\<alpha> ` set x1a) x2;\n        S = set xs' \\<union> set x1a; sorted_wrt RR (xs' @ x1a);\n        \\<alpha> ` set x1a\n        \\<subseteq> \\<alpha> ` (set xs' \\<union> set x1a);\n        \\<forall>x\\<in>set xs' \\<union> set x1a - set x1a.\n           \\<forall>xa\\<in>set x1a. RR x xa;\n        \\<forall>x\\<in>\\<alpha> ` (set xs' \\<union> set x1a) -\n                       \\<alpha> ` set x1a.\n           \\<forall>xa\\<in>set x1a. RR' x (\\<alpha> xa);\n        ((set x1a, x2a), \\<alpha> ` set x1a, x2) \\<in> R; distinct xs';\n        distinct (map \\<alpha> xs'); distinct x1a;\n        set xs' \\<inter> set x1a = {}; distinct (map \\<alpha> x1a);\n        \\<alpha> ` set xs' \\<inter> \\<alpha> ` set x1a = {}\\<rbrakk>\n       \\<Longrightarrow> ((set (tl x1a), \\<sigma>'),\n                          set (tl (map \\<alpha> x1a)), \\<sigma>'')\n                         \\<in> R\n 3. \\<And>xs xsa x x'.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n        \\<not> FOREACH_cond c x; \\<not> FOREACH_cond c' x';\n        case x of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'.\n             xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> (x, x') \\<in> ?R'3 xs xsa\n 4. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x') \\<in> ?R'3 xs xsa; x' = (x1, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> (x2a, x2) \\<in> R'", "apply (rename_tac a b d e f g)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a b d e f g.\n       \\<lbrakk>FOREACH_cond c (b, d); FOREACH_cond c' (map \\<alpha> b, a);\n        ((set b - {hd b}, e), \\<alpha> ` set b - {hd (map \\<alpha> b)}, f)\n        \\<in> R;\n        sorted_wrt RR' (map \\<alpha> g @ map \\<alpha> b); \\<Phi> (set b) d;\n        \\<Phi>' (\\<alpha> ` set b) a; S = set g \\<union> set b;\n        sorted_wrt RR (g @ b);\n        \\<alpha> ` set b \\<subseteq> \\<alpha> ` (set g \\<union> set b);\n        \\<forall>x\\<in>set g \\<union> set b - set b.\n           \\<forall>xa\\<in>set b. RR x xa;\n        \\<forall>x\\<in>\\<alpha> ` (set g \\<union> set b) - \\<alpha> ` set b.\n           \\<forall>xa\\<in>set b. RR' x (\\<alpha> xa);\n        ((set b, d), \\<alpha> ` set b, a) \\<in> R; distinct g;\n        distinct (map \\<alpha> g); distinct b; set g \\<inter> set b = {};\n        distinct (map \\<alpha> b);\n        \\<alpha> ` set g \\<inter> \\<alpha> ` set b = {}\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x\\<in>\\<alpha> ` (set g \\<union> set b) -\n  set (tl (map \\<alpha> b)).\n                            \\<forall>xa\\<in>set (tl (map \\<alpha> b)).\n                               RR' x xa\n 2. \\<And>x2 x1a x2a \\<sigma>' \\<sigma>'' xs'.\n       \\<lbrakk>FOREACH_cond c (x1a, x2a);\n        FOREACH_cond c' (map \\<alpha> x1a, x2);\n        ((set x1a - {hd x1a}, \\<sigma>'),\n         \\<alpha> ` set x1a - {hd (map \\<alpha> x1a)}, \\<sigma>'')\n        \\<in> R;\n        sorted_wrt RR' (map \\<alpha> xs' @ map \\<alpha> x1a);\n        \\<Phi> (set x1a) x2a; \\<Phi>' (\\<alpha> ` set x1a) x2;\n        S = set xs' \\<union> set x1a; sorted_wrt RR (xs' @ x1a);\n        \\<alpha> ` set x1a\n        \\<subseteq> \\<alpha> ` (set xs' \\<union> set x1a);\n        \\<forall>x\\<in>set xs' \\<union> set x1a - set x1a.\n           \\<forall>xa\\<in>set x1a. RR x xa;\n        \\<forall>x\\<in>\\<alpha> ` (set xs' \\<union> set x1a) -\n                       \\<alpha> ` set x1a.\n           \\<forall>xa\\<in>set x1a. RR' x (\\<alpha> xa);\n        ((set x1a, x2a), \\<alpha> ` set x1a, x2) \\<in> R; distinct xs';\n        distinct (map \\<alpha> xs'); distinct x1a;\n        set xs' \\<inter> set x1a = {}; distinct (map \\<alpha> x1a);\n        \\<alpha> ` set xs' \\<inter> \\<alpha> ` set x1a = {}\\<rbrakk>\n       \\<Longrightarrow> ((set (tl x1a), \\<sigma>'),\n                          set (tl (map \\<alpha> x1a)), \\<sigma>'')\n                         \\<in> R\n 3. \\<And>xs xsa x x'.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n        \\<not> FOREACH_cond c x; \\<not> FOREACH_cond c' x';\n        case x of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'.\n             xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> (x, x') \\<in> ?R'3 xs xsa\n 4. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x') \\<in> ?R'3 xs xsa; x' = (x1, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> (x2a, x2) \\<in> R'", "apply (case_tac b, auto simp: sorted_wrt_append) []"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x2 x1a x2a \\<sigma>' \\<sigma>'' xs'.\n       \\<lbrakk>FOREACH_cond c (x1a, x2a);\n        FOREACH_cond c' (map \\<alpha> x1a, x2);\n        ((set x1a - {hd x1a}, \\<sigma>'),\n         \\<alpha> ` set x1a - {hd (map \\<alpha> x1a)}, \\<sigma>'')\n        \\<in> R;\n        sorted_wrt RR' (map \\<alpha> xs' @ map \\<alpha> x1a);\n        \\<Phi> (set x1a) x2a; \\<Phi>' (\\<alpha> ` set x1a) x2;\n        S = set xs' \\<union> set x1a; sorted_wrt RR (xs' @ x1a);\n        \\<alpha> ` set x1a\n        \\<subseteq> \\<alpha> ` (set xs' \\<union> set x1a);\n        \\<forall>x\\<in>set xs' \\<union> set x1a - set x1a.\n           \\<forall>xa\\<in>set x1a. RR x xa;\n        \\<forall>x\\<in>\\<alpha> ` (set xs' \\<union> set x1a) -\n                       \\<alpha> ` set x1a.\n           \\<forall>xa\\<in>set x1a. RR' x (\\<alpha> xa);\n        ((set x1a, x2a), \\<alpha> ` set x1a, x2) \\<in> R; distinct xs';\n        distinct (map \\<alpha> xs'); distinct x1a;\n        set xs' \\<inter> set x1a = {}; distinct (map \\<alpha> x1a);\n        \\<alpha> ` set xs' \\<inter> \\<alpha> ` set x1a = {}\\<rbrakk>\n       \\<Longrightarrow> ((set (tl x1a), \\<sigma>'),\n                          set (tl (map \\<alpha> x1a)), \\<sigma>'')\n                         \\<in> R\n 2. \\<And>xs xsa x x'.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n        \\<not> FOREACH_cond c x; \\<not> FOREACH_cond c' x';\n        case x of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'.\n             xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> (x, x') \\<in> ?R'3 xs xsa\n 3. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x') \\<in> ?R'3 xs xsa; x' = (x1, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> (x2a, x2) \\<in> R'", "apply (rename_tac a b d e f g)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b d e f g.\n       \\<lbrakk>FOREACH_cond c (b, d); FOREACH_cond c' (map \\<alpha> b, a);\n        ((set b - {hd b}, e), \\<alpha> ` set b - {hd (map \\<alpha> b)}, f)\n        \\<in> R;\n        sorted_wrt RR' (map \\<alpha> g @ map \\<alpha> b); \\<Phi> (set b) d;\n        \\<Phi>' (\\<alpha> ` set b) a; S = set g \\<union> set b;\n        sorted_wrt RR (g @ b);\n        \\<alpha> ` set b \\<subseteq> \\<alpha> ` (set g \\<union> set b);\n        \\<forall>x\\<in>set g \\<union> set b - set b.\n           \\<forall>xa\\<in>set b. RR x xa;\n        \\<forall>x\\<in>\\<alpha> ` (set g \\<union> set b) - \\<alpha> ` set b.\n           \\<forall>xa\\<in>set b. RR' x (\\<alpha> xa);\n        ((set b, d), \\<alpha> ` set b, a) \\<in> R; distinct g;\n        distinct (map \\<alpha> g); distinct b; set g \\<inter> set b = {};\n        distinct (map \\<alpha> b);\n        \\<alpha> ` set g \\<inter> \\<alpha> ` set b = {}\\<rbrakk>\n       \\<Longrightarrow> ((set (tl b), e), set (tl (map \\<alpha> b)), f)\n                         \\<in> R\n 2. \\<And>xs xsa x x'.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n        \\<not> FOREACH_cond c x; \\<not> FOREACH_cond c' x';\n        case x of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'.\n             xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> (x, x') \\<in> ?R'3 xs xsa\n 3. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x') \\<in> ?R'3 xs xsa; x' = (x1, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> (x2a, x2) \\<in> R'", "apply (case_tac b, auto) []"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xs xsa x x'.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n        \\<not> FOREACH_cond c x; \\<not> FOREACH_cond c' x';\n        case x of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'.\n             xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> (x, x') \\<in> ?R'3 xs xsa\n 2. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x') \\<in> ?R'3 xs xsa; x' = (x1, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> (x2a, x2) \\<in> R'", "apply (rule introR[where R=\"{((xs,\\<sigma>),(xs',\\<sigma>')). \n      xs'=map \\<alpha> xs \\<and> \\<Phi> (set xs) \\<sigma> \\<and> \\<Phi>' (set xs') \\<sigma>' \\<and>\n      set xs \\<subseteq> S \\<and> set xs' \\<subseteq> S' \\<and>\n      (\\<forall>x\\<in>S - set xs. \\<forall>y\\<in>set xs. RR x y) \\<and>\n      (\\<forall>x\\<in>S' - set xs'. \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n      ((set xs,\\<sigma>),(set xs',\\<sigma>')) \\<in> R \\<and>\n      \\<not> FOREACH_cond c (xs,\\<sigma>) \\<and> \\<not> FOREACH_cond c' (xs',\\<sigma>')\n    }\n    \"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xs xsa x x'.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R};\n        \\<not> FOREACH_cond c x; \\<not> FOREACH_cond c' x';\n        case x of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>;\n        case x' of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'.\n             xsa = xs' @ it \\<and> \\<Phi>' (set it) \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> (x, x')\n                         \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n                                xs' = map \\<alpha> xs \\<and>\n                                \\<Phi> (set xs) \\<sigma> \\<and>\n                                \\<Phi>' (set xs') \\<sigma>' \\<and>\n                                set xs \\<subseteq> S \\<and>\n                                set xs' \\<subseteq> S' \\<and>\n                                (\\<forall>x\\<in>S - set xs.\n                                    \\<forall>y\\<in>set xs. RR x y) \\<and>\n                                (\\<forall>x\\<in>S' - set xs'.\n                                    \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n                                ((set xs, \\<sigma>), set xs', \\<sigma>')\n                                \\<in> R \\<and>\n                                \\<not> FOREACH_cond c (xs, \\<sigma>) \\<and>\n                                \\<not> FOREACH_cond c' (xs', \\<sigma>')}\n 2. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               \\<Phi> (set xs) \\<sigma> \\<and>\n               \\<Phi>' (set xs') \\<sigma>' \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R \\<and>\n               \\<not> FOREACH_cond c (xs, \\<sigma>) \\<and>\n               \\<not> FOREACH_cond c' (xs', \\<sigma>')};\n        x' = (x1, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> (x2a, x2) \\<in> R'", "apply auto []"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>finite S'; finite S;\n        (xs, xsa) \\<in> {(xs, xs'). xs' = map \\<alpha> xs};\n        xs \\<in> {xs.\n                  distinct xs \\<and> S = set xs \\<and> sorted_wrt RR xs};\n        xsa\n        \\<in> {xs. distinct xs \\<and> S' = set xs \\<and> sorted_wrt RR' xs};\n        (x, x')\n        \\<in> {((xs, \\<sigma>), xs', \\<sigma>').\n               xs' = map \\<alpha> xs \\<and>\n               \\<Phi> (set xs) \\<sigma> \\<and>\n               \\<Phi>' (set xs') \\<sigma>' \\<and>\n               set xs \\<subseteq> S \\<and>\n               set xs' \\<subseteq> S' \\<and>\n               (\\<forall>x\\<in>S - set xs.\n                   \\<forall>y\\<in>set xs. RR x y) \\<and>\n               (\\<forall>x\\<in>S' - set xs'.\n                   \\<forall>y\\<in>set xs'. RR' x y) \\<and>\n               ((set xs, \\<sigma>), set xs', \\<sigma>') \\<in> R \\<and>\n               \\<not> FOREACH_cond c (xs, \\<sigma>) \\<and>\n               \\<not> FOREACH_cond c' (xs', \\<sigma>')};\n        x' = (x1, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> (x2a, x2) \\<in> R'", "apply (simp add: FOREACH_cond_def, elim conjE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>xsa = map \\<alpha> xs; x' = (map \\<alpha> x1a, x2);\n        x = (x1a, x2a); distinct xs; distinct (map \\<alpha> xs);\n        sorted_wrt RR' (map \\<alpha> xs); x1 = map \\<alpha> x1a; S = set xs;\n        sorted_wrt RR xs; \\<Phi> (set x1a) x2a; \\<Phi>' (set x1) x2;\n        set x1a \\<subseteq> set xs; set x1 \\<subseteq> \\<alpha> ` set xs;\n        \\<forall>x\\<in>set xs - set x1a. \\<forall>xa\\<in>set x1a. RR x xa;\n        \\<forall>x\\<in>\\<alpha> ` set xs - set x1.\n           \\<forall>xa\\<in>set x1. RR' x xa;\n        ((set x1a, x2a), set x1, x2) \\<in> R; x1a = [] \\<or> \\<not> c x2a;\n        x1 = [] \\<or> \\<not> c' x2\\<rbrakk>\n       \\<Longrightarrow> (x2a, x2) \\<in> R'", "apply (elim disjE1, simp_all) []"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>xsa = map \\<alpha> xs; x' = ([], x2); x = ([], x2a);\n        distinct xs; distinct (map \\<alpha> xs);\n        sorted_wrt RR' (map \\<alpha> xs); S = set xs; sorted_wrt RR xs;\n        \\<Phi> {} x2a; \\<Phi>' {} x2; (({}, x2a), {}, x2) \\<in> R; x1a = [];\n        x1 = []\\<rbrakk>\n       \\<Longrightarrow> (x2a, x2) \\<in> R'\n 2. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>xsa = map \\<alpha> xs; x' = (map \\<alpha> x1a, x2);\n        x = (x1a, x2a); distinct xs; distinct (map \\<alpha> xs);\n        sorted_wrt RR' (map \\<alpha> xs); x1 = map \\<alpha> x1a; S = set xs;\n        sorted_wrt RR xs; \\<Phi> (set x1a) x2a;\n        \\<Phi>' (\\<alpha> ` set x1a) x2; set x1a \\<subseteq> set xs;\n        \\<alpha> ` set x1a \\<subseteq> \\<alpha> ` set xs;\n        \\<forall>x\\<in>set xs - set x1a. \\<forall>xa\\<in>set x1a. RR x xa;\n        \\<forall>x\\<in>\\<alpha> ` set xs - \\<alpha> ` set x1a.\n           \\<forall>xa\\<in>set x1a. RR' x (\\<alpha> xa);\n        ((set x1a, x2a), \\<alpha> ` set x1a, x2) \\<in> R; x1a \\<noteq> [];\n        \\<not> c x2a; \\<not> c' x2\\<rbrakk>\n       \\<Longrightarrow> (x2a, x2) \\<in> R'", "using REF_R_DONE"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<Phi> {} ?\\<sigma>; \\<Phi>' {} ?\\<sigma>';\n   (({}, ?\\<sigma>), {}, ?\\<sigma>') \\<in> R\\<rbrakk>\n  \\<Longrightarrow> (?\\<sigma>, ?\\<sigma>') \\<in> R'\n\ngoal (2 subgoals):\n 1. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>xsa = map \\<alpha> xs; x' = ([], x2); x = ([], x2a);\n        distinct xs; distinct (map \\<alpha> xs);\n        sorted_wrt RR' (map \\<alpha> xs); S = set xs; sorted_wrt RR xs;\n        \\<Phi> {} x2a; \\<Phi>' {} x2; (({}, x2a), {}, x2) \\<in> R; x1a = [];\n        x1 = []\\<rbrakk>\n       \\<Longrightarrow> (x2a, x2) \\<in> R'\n 2. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>xsa = map \\<alpha> xs; x' = (map \\<alpha> x1a, x2);\n        x = (x1a, x2a); distinct xs; distinct (map \\<alpha> xs);\n        sorted_wrt RR' (map \\<alpha> xs); x1 = map \\<alpha> x1a; S = set xs;\n        sorted_wrt RR xs; \\<Phi> (set x1a) x2a;\n        \\<Phi>' (\\<alpha> ` set x1a) x2; set x1a \\<subseteq> set xs;\n        \\<alpha> ` set x1a \\<subseteq> \\<alpha> ` set xs;\n        \\<forall>x\\<in>set xs - set x1a. \\<forall>xa\\<in>set x1a. RR x xa;\n        \\<forall>x\\<in>\\<alpha> ` set xs - \\<alpha> ` set x1a.\n           \\<forall>xa\\<in>set x1a. RR' x (\\<alpha> xa);\n        ((set x1a, x2a), \\<alpha> ` set x1a, x2) \\<in> R; x1a \\<noteq> [];\n        \\<not> c x2a; \\<not> c' x2\\<rbrakk>\n       \\<Longrightarrow> (x2a, x2) \\<in> R'", "apply auto []"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>xsa = map \\<alpha> xs; x' = (map \\<alpha> x1a, x2);\n        x = (x1a, x2a); distinct xs; distinct (map \\<alpha> xs);\n        sorted_wrt RR' (map \\<alpha> xs); x1 = map \\<alpha> x1a; S = set xs;\n        sorted_wrt RR xs; \\<Phi> (set x1a) x2a;\n        \\<Phi>' (\\<alpha> ` set x1a) x2; set x1a \\<subseteq> set xs;\n        \\<alpha> ` set x1a \\<subseteq> \\<alpha> ` set xs;\n        \\<forall>x\\<in>set xs - set x1a. \\<forall>xa\\<in>set x1a. RR x xa;\n        \\<forall>x\\<in>\\<alpha> ` set xs - \\<alpha> ` set x1a.\n           \\<forall>xa\\<in>set x1a. RR' x (\\<alpha> xa);\n        ((set x1a, x2a), \\<alpha> ` set x1a, x2) \\<in> R; x1a \\<noteq> [];\n        \\<not> c x2a; \\<not> c' x2\\<rbrakk>\n       \\<Longrightarrow> (x2a, x2) \\<in> R'", "using REF_R_BRK"], ["proof (prove)\nusing this:\n  \\<lbrakk>?it \\<subseteq> S; ?it' \\<subseteq> S'; \\<Phi> ?it ?\\<sigma>;\n   \\<Phi>' ?it' ?\\<sigma>';\n   \\<forall>x\\<in>S - ?it. \\<forall>y\\<in>?it. RR x y;\n   \\<forall>x\\<in>S' - ?it'. \\<forall>y\\<in>?it'. RR' x y;\n   ?it' = \\<alpha> ` ?it; ((?it, ?\\<sigma>), ?it', ?\\<sigma>') \\<in> R;\n   ?it \\<noteq> {}; ?it' \\<noteq> {}; \\<not> c ?\\<sigma>;\n   \\<not> c' ?\\<sigma>'\\<rbrakk>\n  \\<Longrightarrow> (?\\<sigma>, ?\\<sigma>') \\<in> R'\n\ngoal (1 subgoal):\n 1. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>xsa = map \\<alpha> xs; x' = (map \\<alpha> x1a, x2);\n        x = (x1a, x2a); distinct xs; distinct (map \\<alpha> xs);\n        sorted_wrt RR' (map \\<alpha> xs); x1 = map \\<alpha> x1a; S = set xs;\n        sorted_wrt RR xs; \\<Phi> (set x1a) x2a;\n        \\<Phi>' (\\<alpha> ` set x1a) x2; set x1a \\<subseteq> set xs;\n        \\<alpha> ` set x1a \\<subseteq> \\<alpha> ` set xs;\n        \\<forall>x\\<in>set xs - set x1a. \\<forall>xa\\<in>set x1a. RR x xa;\n        \\<forall>x\\<in>\\<alpha> ` set xs - \\<alpha> ` set x1a.\n           \\<forall>xa\\<in>set x1a. RR' x (\\<alpha> xa);\n        ((set x1a, x2a), \\<alpha> ` set x1a, x2) \\<in> R; x1a \\<noteq> [];\n        \\<not> c x2a; \\<not> c' x2\\<rbrakk>\n       \\<Longrightarrow> (x2a, x2) \\<in> R'", "apply auto []"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma FOREACHoci_refine:\n  fixes \\<alpha> :: \"'S \\<Rightarrow> 'Sa\"\n  fixes S :: \"'S set\"\n  fixes S' :: \"'Sa set\"\n  assumes INJ: \"inj_on \\<alpha> S\"\n  assumes REFS: \"S' = \\<alpha>`S\"\n  assumes REF0: \"(\\<sigma>0,\\<sigma>0')\\<in>R\"\n  assumes RR_OK: \"\\<And>x y. \\<lbrakk>x \\<in> S; y \\<in> S; RR x y\\<rbrakk> \\<Longrightarrow> RR' (\\<alpha> x) (\\<alpha> y)\"\n  assumes REFPHI0: \"\\<Phi>'' S \\<sigma>0 (\\<alpha>`S) \\<sigma>0'\"\n  assumes REFC: \"\\<And>it \\<sigma> it' \\<sigma>'. \\<lbrakk> \n    it'=\\<alpha>`it; it\\<subseteq>S; it'\\<subseteq>S'; \\<Phi>' it' \\<sigma>';  \\<Phi>'' it \\<sigma> it' \\<sigma>'; \\<Phi> it \\<sigma>; (\\<sigma>,\\<sigma>')\\<in>R\n  \\<rbrakk> \\<Longrightarrow> c \\<sigma> \\<longleftrightarrow> c' \\<sigma>'\"\n  assumes REFPHI: \"\\<And>it \\<sigma> it' \\<sigma>'. \\<lbrakk> \n    it'=\\<alpha>`it; it\\<subseteq>S; it'\\<subseteq>S'; \\<Phi>' it' \\<sigma>'; \\<Phi>'' it \\<sigma> it' \\<sigma>'; (\\<sigma>,\\<sigma>')\\<in>R\n  \\<rbrakk> \\<Longrightarrow> \\<Phi> it \\<sigma>\"\n  assumes REFSTEP: \"\\<And>x it \\<sigma> x' it' \\<sigma>'. \\<lbrakk>\\<forall>y\\<in>it-{x}. RR x y; \n    x'=\\<alpha> x; x\\<in>it; x'\\<in>it'; it'=\\<alpha>`it; it\\<subseteq>S; it'\\<subseteq>S';\n    \\<Phi> it \\<sigma>; \\<Phi>' it' \\<sigma>';  \\<Phi>'' it \\<sigma> it' \\<sigma>'; c \\<sigma>; c' \\<sigma>';\n    (\\<sigma>,\\<sigma>')\\<in>R\n  \\<rbrakk> \\<Longrightarrow> f x \\<sigma> \n    \\<le> \\<Down>({(\\<sigma>, \\<sigma>'). (\\<sigma>, \\<sigma>') \\<in> R \\<and> \\<Phi>'' (it - {x}) \\<sigma> (it' - {x'}) \\<sigma>'}) (f' x' \\<sigma>')\"\n  shows \"FOREACHoci RR \\<Phi> S c f \\<sigma>0 \\<le> \\<Down>R (FOREACHoci RR' \\<Phi>' S' c' f' \\<sigma>0')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. FOREACH\\<^sub>O\\<^sub>C\\<^bsup>RR,\\<Phi>\\<^esup> S c f \\<sigma>0\n    \\<le> \\<Down> R\n           (FOREACH\\<^sub>O\\<^sub>C\\<^bsup>RR',\\<Phi>'\\<^esup> S' c' f'\n             \\<sigma>0')", "apply (rule FOREACHoci_refine_genR[\n    where R = \"{((it,\\<sigma>),(it',\\<sigma>')). (\\<sigma>,\\<sigma>')\\<in>R \\<and> \\<Phi>'' it \\<sigma> it' \\<sigma>'}\"\n    ])"], ["proof (prove)\ngoal (9 subgoals):\n 1. inj_on ?\\<alpha> S\n 2. S' = ?\\<alpha> ` S\n 3. \\<And>x y.\n       \\<lbrakk>x \\<in> S; y \\<in> S; RR x y\\<rbrakk>\n       \\<Longrightarrow> RR' (?\\<alpha> x) (?\\<alpha> y)\n 4. ((S, \\<sigma>0), ?\\<alpha> ` S, \\<sigma>0')\n    \\<in> {((it, \\<sigma>), it', \\<sigma>').\n           (\\<sigma>, \\<sigma>') \\<in> R \\<and>\n           \\<Phi>'' it \\<sigma> it' \\<sigma>'}\n 5. \\<And>it \\<sigma> it' \\<sigma>'.\n       \\<lbrakk>it \\<subseteq> S; it' \\<subseteq> S'; \\<Phi>' it' \\<sigma>';\n        \\<Phi> it \\<sigma>;\n        \\<forall>x\\<in>S - it. \\<forall>y\\<in>it. RR x y;\n        \\<forall>x\\<in>S' - it'. \\<forall>y\\<in>it'. RR' x y;\n        it' = ?\\<alpha> ` it;\n        ((it, \\<sigma>), it', \\<sigma>')\n        \\<in> {((it, \\<sigma>), it', \\<sigma>').\n               (\\<sigma>, \\<sigma>') \\<in> R \\<and>\n               \\<Phi>'' it \\<sigma> it' \\<sigma>'}\\<rbrakk>\n       \\<Longrightarrow> c \\<sigma> = c' \\<sigma>'\n 6. \\<And>it \\<sigma> it' \\<sigma>'.\n       \\<lbrakk>it \\<subseteq> S; it' \\<subseteq> S'; \\<Phi>' it' \\<sigma>';\n        \\<forall>x\\<in>S - it. \\<forall>y\\<in>it. RR x y;\n        \\<forall>x\\<in>S' - it'. \\<forall>y\\<in>it'. RR' x y;\n        it' = ?\\<alpha> ` it;\n        ((it, \\<sigma>), it', \\<sigma>')\n        \\<in> {((it, \\<sigma>), it', \\<sigma>').\n               (\\<sigma>, \\<sigma>') \\<in> R \\<and>\n               \\<Phi>'' it \\<sigma> it' \\<sigma>'}\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> it \\<sigma>\n 7. \\<And>x it \\<sigma> x' it' \\<sigma>'.\n       \\<lbrakk>it \\<subseteq> S; it' \\<subseteq> S'; \\<Phi> it \\<sigma>;\n        \\<Phi>' it' \\<sigma>';\n        \\<forall>x\\<in>S - it. \\<forall>y\\<in>it. RR x y;\n        \\<forall>x\\<in>S' - it'. \\<forall>y\\<in>it'. RR' x y;\n        x' = ?\\<alpha> x; it' = ?\\<alpha> ` it;\n        ((it, \\<sigma>), it', \\<sigma>')\n        \\<in> {((it, \\<sigma>), it', \\<sigma>').\n               (\\<sigma>, \\<sigma>') \\<in> R \\<and>\n               \\<Phi>'' it \\<sigma> it' \\<sigma>'};\n        x \\<in> it; \\<forall>y\\<in>it - {x}. RR x y; x' \\<in> it';\n        \\<forall>y'\\<in>it' - {x'}. RR' x' y'; c \\<sigma>;\n        c' \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> f x \\<sigma>\n                         \\<le> \\<Down>\n                                {(\\<sigma>, \\<sigma>').\n                                 ((it - {x}, \\<sigma>), it' - {x'},\n                                  \\<sigma>')\n                                 \\<in> {((it, \\<sigma>), it', \\<sigma>').\n  (\\<sigma>, \\<sigma>') \\<in> R \\<and> \\<Phi>'' it \\<sigma> it' \\<sigma>'}}\n                                (f' x' \\<sigma>')\n 8. \\<And>\\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<Phi> {} \\<sigma>; \\<Phi>' {} \\<sigma>';\n        (({}, \\<sigma>), {}, \\<sigma>')\n        \\<in> {((it, \\<sigma>), it', \\<sigma>').\n               (\\<sigma>, \\<sigma>') \\<in> R \\<and>\n               \\<Phi>'' it \\<sigma> it' \\<sigma>'}\\<rbrakk>\n       \\<Longrightarrow> (\\<sigma>, \\<sigma>') \\<in> R\n 9. \\<And>it \\<sigma> it' \\<sigma>'.\n       \\<lbrakk>it \\<subseteq> S; it' \\<subseteq> S'; \\<Phi> it \\<sigma>;\n        \\<Phi>' it' \\<sigma>';\n        \\<forall>x\\<in>S - it. \\<forall>y\\<in>it. RR x y;\n        \\<forall>x\\<in>S' - it'. \\<forall>y\\<in>it'. RR' x y;\n        it' = ?\\<alpha> ` it;\n        ((it, \\<sigma>), it', \\<sigma>')\n        \\<in> {((it, \\<sigma>), it', \\<sigma>').\n               (\\<sigma>, \\<sigma>') \\<in> R \\<and>\n               \\<Phi>'' it \\<sigma> it' \\<sigma>'};\n        it \\<noteq> {}; it' \\<noteq> {}; \\<not> c \\<sigma>;\n        \\<not> c' \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> (\\<sigma>, \\<sigma>') \\<in> R", "apply fact"], ["proof (prove)\ngoal (8 subgoals):\n 1. S' = \\<alpha> ` S\n 2. \\<And>x y.\n       \\<lbrakk>x \\<in> S; y \\<in> S; RR x y\\<rbrakk>\n       \\<Longrightarrow> RR' (\\<alpha> x) (\\<alpha> y)\n 3. ((S, \\<sigma>0), \\<alpha> ` S, \\<sigma>0')\n    \\<in> {((it, \\<sigma>), it', \\<sigma>').\n           (\\<sigma>, \\<sigma>') \\<in> R \\<and>\n           \\<Phi>'' it \\<sigma> it' \\<sigma>'}\n 4. \\<And>it \\<sigma> it' \\<sigma>'.\n       \\<lbrakk>it \\<subseteq> S; it' \\<subseteq> S'; \\<Phi>' it' \\<sigma>';\n        \\<Phi> it \\<sigma>;\n        \\<forall>x\\<in>S - it. \\<forall>y\\<in>it. RR x y;\n        \\<forall>x\\<in>S' - it'. \\<forall>y\\<in>it'. RR' x y;\n        it' = \\<alpha> ` it;\n        ((it, \\<sigma>), it', \\<sigma>')\n        \\<in> {((it, \\<sigma>), it', \\<sigma>').\n               (\\<sigma>, \\<sigma>') \\<in> R \\<and>\n               \\<Phi>'' it \\<sigma> it' \\<sigma>'}\\<rbrakk>\n       \\<Longrightarrow> c \\<sigma> = c' \\<sigma>'\n 5. \\<And>it \\<sigma> it' \\<sigma>'.\n       \\<lbrakk>it \\<subseteq> S; it' \\<subseteq> S'; \\<Phi>' it' \\<sigma>';\n        \\<forall>x\\<in>S - it. \\<forall>y\\<in>it. RR x y;\n        \\<forall>x\\<in>S' - it'. \\<forall>y\\<in>it'. RR' x y;\n        it' = \\<alpha> ` it;\n        ((it, \\<sigma>), it', \\<sigma>')\n        \\<in> {((it, \\<sigma>), it', \\<sigma>').\n               (\\<sigma>, \\<sigma>') \\<in> R \\<and>\n               \\<Phi>'' it \\<sigma> it' \\<sigma>'}\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> it \\<sigma>\n 6. \\<And>x it \\<sigma> x' it' \\<sigma>'.\n       \\<lbrakk>it \\<subseteq> S; it' \\<subseteq> S'; \\<Phi> it \\<sigma>;\n        \\<Phi>' it' \\<sigma>';\n        \\<forall>x\\<in>S - it. \\<forall>y\\<in>it. RR x y;\n        \\<forall>x\\<in>S' - it'. \\<forall>y\\<in>it'. RR' x y;\n        x' = \\<alpha> x; it' = \\<alpha> ` it;\n        ((it, \\<sigma>), it', \\<sigma>')\n        \\<in> {((it, \\<sigma>), it', \\<sigma>').\n               (\\<sigma>, \\<sigma>') \\<in> R \\<and>\n               \\<Phi>'' it \\<sigma> it' \\<sigma>'};\n        x \\<in> it; \\<forall>y\\<in>it - {x}. RR x y; x' \\<in> it';\n        \\<forall>y'\\<in>it' - {x'}. RR' x' y'; c \\<sigma>;\n        c' \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> f x \\<sigma>\n                         \\<le> \\<Down>\n                                {(\\<sigma>, \\<sigma>').\n                                 ((it - {x}, \\<sigma>), it' - {x'},\n                                  \\<sigma>')\n                                 \\<in> {((it, \\<sigma>), it', \\<sigma>').\n  (\\<sigma>, \\<sigma>') \\<in> R \\<and> \\<Phi>'' it \\<sigma> it' \\<sigma>'}}\n                                (f' x' \\<sigma>')\n 7. \\<And>\\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<Phi> {} \\<sigma>; \\<Phi>' {} \\<sigma>';\n        (({}, \\<sigma>), {}, \\<sigma>')\n        \\<in> {((it, \\<sigma>), it', \\<sigma>').\n               (\\<sigma>, \\<sigma>') \\<in> R \\<and>\n               \\<Phi>'' it \\<sigma> it' \\<sigma>'}\\<rbrakk>\n       \\<Longrightarrow> (\\<sigma>, \\<sigma>') \\<in> R\n 8. \\<And>it \\<sigma> it' \\<sigma>'.\n       \\<lbrakk>it \\<subseteq> S; it' \\<subseteq> S'; \\<Phi> it \\<sigma>;\n        \\<Phi>' it' \\<sigma>';\n        \\<forall>x\\<in>S - it. \\<forall>y\\<in>it. RR x y;\n        \\<forall>x\\<in>S' - it'. \\<forall>y\\<in>it'. RR' x y;\n        it' = \\<alpha> ` it;\n        ((it, \\<sigma>), it', \\<sigma>')\n        \\<in> {((it, \\<sigma>), it', \\<sigma>').\n               (\\<sigma>, \\<sigma>') \\<in> R \\<and>\n               \\<Phi>'' it \\<sigma> it' \\<sigma>'};\n        it \\<noteq> {}; it' \\<noteq> {}; \\<not> c \\<sigma>;\n        \\<not> c' \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> (\\<sigma>, \\<sigma>') \\<in> R", "apply fact"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> S; y \\<in> S; RR x y\\<rbrakk>\n       \\<Longrightarrow> RR' (\\<alpha> x) (\\<alpha> y)\n 2. ((S, \\<sigma>0), \\<alpha> ` S, \\<sigma>0')\n    \\<in> {((it, \\<sigma>), it', \\<sigma>').\n           (\\<sigma>, \\<sigma>') \\<in> R \\<and>\n           \\<Phi>'' it \\<sigma> it' \\<sigma>'}\n 3. \\<And>it \\<sigma> it' \\<sigma>'.\n       \\<lbrakk>it \\<subseteq> S; it' \\<subseteq> S'; \\<Phi>' it' \\<sigma>';\n        \\<Phi> it \\<sigma>;\n        \\<forall>x\\<in>S - it. \\<forall>y\\<in>it. RR x y;\n        \\<forall>x\\<in>S' - it'. \\<forall>y\\<in>it'. RR' x y;\n        it' = \\<alpha> ` it;\n        ((it, \\<sigma>), it', \\<sigma>')\n        \\<in> {((it, \\<sigma>), it', \\<sigma>').\n               (\\<sigma>, \\<sigma>') \\<in> R \\<and>\n               \\<Phi>'' it \\<sigma> it' \\<sigma>'}\\<rbrakk>\n       \\<Longrightarrow> c \\<sigma> = c' \\<sigma>'\n 4. \\<And>it \\<sigma> it' \\<sigma>'.\n       \\<lbrakk>it \\<subseteq> S; it' \\<subseteq> S'; \\<Phi>' it' \\<sigma>';\n        \\<forall>x\\<in>S - it. \\<forall>y\\<in>it. RR x y;\n        \\<forall>x\\<in>S' - it'. \\<forall>y\\<in>it'. RR' x y;\n        it' = \\<alpha> ` it;\n        ((it, \\<sigma>), it', \\<sigma>')\n        \\<in> {((it, \\<sigma>), it', \\<sigma>').\n               (\\<sigma>, \\<sigma>') \\<in> R \\<and>\n               \\<Phi>'' it \\<sigma> it' \\<sigma>'}\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> it \\<sigma>\n 5. \\<And>x it \\<sigma> x' it' \\<sigma>'.\n       \\<lbrakk>it \\<subseteq> S; it' \\<subseteq> S'; \\<Phi> it \\<sigma>;\n        \\<Phi>' it' \\<sigma>';\n        \\<forall>x\\<in>S - it. \\<forall>y\\<in>it. RR x y;\n        \\<forall>x\\<in>S' - it'. \\<forall>y\\<in>it'. RR' x y;\n        x' = \\<alpha> x; it' = \\<alpha> ` it;\n        ((it, \\<sigma>), it', \\<sigma>')\n        \\<in> {((it, \\<sigma>), it', \\<sigma>').\n               (\\<sigma>, \\<sigma>') \\<in> R \\<and>\n               \\<Phi>'' it \\<sigma> it' \\<sigma>'};\n        x \\<in> it; \\<forall>y\\<in>it - {x}. RR x y; x' \\<in> it';\n        \\<forall>y'\\<in>it' - {x'}. RR' x' y'; c \\<sigma>;\n        c' \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> f x \\<sigma>\n                         \\<le> \\<Down>\n                                {(\\<sigma>, \\<sigma>').\n                                 ((it - {x}, \\<sigma>), it' - {x'},\n                                  \\<sigma>')\n                                 \\<in> {((it, \\<sigma>), it', \\<sigma>').\n  (\\<sigma>, \\<sigma>') \\<in> R \\<and> \\<Phi>'' it \\<sigma> it' \\<sigma>'}}\n                                (f' x' \\<sigma>')\n 6. \\<And>\\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<Phi> {} \\<sigma>; \\<Phi>' {} \\<sigma>';\n        (({}, \\<sigma>), {}, \\<sigma>')\n        \\<in> {((it, \\<sigma>), it', \\<sigma>').\n               (\\<sigma>, \\<sigma>') \\<in> R \\<and>\n               \\<Phi>'' it \\<sigma> it' \\<sigma>'}\\<rbrakk>\n       \\<Longrightarrow> (\\<sigma>, \\<sigma>') \\<in> R\n 7. \\<And>it \\<sigma> it' \\<sigma>'.\n       \\<lbrakk>it \\<subseteq> S; it' \\<subseteq> S'; \\<Phi> it \\<sigma>;\n        \\<Phi>' it' \\<sigma>';\n        \\<forall>x\\<in>S - it. \\<forall>y\\<in>it. RR x y;\n        \\<forall>x\\<in>S' - it'. \\<forall>y\\<in>it'. RR' x y;\n        it' = \\<alpha> ` it;\n        ((it, \\<sigma>), it', \\<sigma>')\n        \\<in> {((it, \\<sigma>), it', \\<sigma>').\n               (\\<sigma>, \\<sigma>') \\<in> R \\<and>\n               \\<Phi>'' it \\<sigma> it' \\<sigma>'};\n        it \\<noteq> {}; it' \\<noteq> {}; \\<not> c \\<sigma>;\n        \\<not> c' \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> (\\<sigma>, \\<sigma>') \\<in> R", "apply fact"], ["proof (prove)\ngoal (6 subgoals):\n 1. ((S, \\<sigma>0), \\<alpha> ` S, \\<sigma>0')\n    \\<in> {((it, \\<sigma>), it', \\<sigma>').\n           (\\<sigma>, \\<sigma>') \\<in> R \\<and>\n           \\<Phi>'' it \\<sigma> it' \\<sigma>'}\n 2. \\<And>it \\<sigma> it' \\<sigma>'.\n       \\<lbrakk>it \\<subseteq> S; it' \\<subseteq> S'; \\<Phi>' it' \\<sigma>';\n        \\<Phi> it \\<sigma>;\n        \\<forall>x\\<in>S - it. \\<forall>y\\<in>it. RR x y;\n        \\<forall>x\\<in>S' - it'. \\<forall>y\\<in>it'. RR' x y;\n        it' = \\<alpha> ` it;\n        ((it, \\<sigma>), it', \\<sigma>')\n        \\<in> {((it, \\<sigma>), it', \\<sigma>').\n               (\\<sigma>, \\<sigma>') \\<in> R \\<and>\n               \\<Phi>'' it \\<sigma> it' \\<sigma>'}\\<rbrakk>\n       \\<Longrightarrow> c \\<sigma> = c' \\<sigma>'\n 3. \\<And>it \\<sigma> it' \\<sigma>'.\n       \\<lbrakk>it \\<subseteq> S; it' \\<subseteq> S'; \\<Phi>' it' \\<sigma>';\n        \\<forall>x\\<in>S - it. \\<forall>y\\<in>it. RR x y;\n        \\<forall>x\\<in>S' - it'. \\<forall>y\\<in>it'. RR' x y;\n        it' = \\<alpha> ` it;\n        ((it, \\<sigma>), it', \\<sigma>')\n        \\<in> {((it, \\<sigma>), it', \\<sigma>').\n               (\\<sigma>, \\<sigma>') \\<in> R \\<and>\n               \\<Phi>'' it \\<sigma> it' \\<sigma>'}\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> it \\<sigma>\n 4. \\<And>x it \\<sigma> x' it' \\<sigma>'.\n       \\<lbrakk>it \\<subseteq> S; it' \\<subseteq> S'; \\<Phi> it \\<sigma>;\n        \\<Phi>' it' \\<sigma>';\n        \\<forall>x\\<in>S - it. \\<forall>y\\<in>it. RR x y;\n        \\<forall>x\\<in>S' - it'. \\<forall>y\\<in>it'. RR' x y;\n        x' = \\<alpha> x; it' = \\<alpha> ` it;\n        ((it, \\<sigma>), it', \\<sigma>')\n        \\<in> {((it, \\<sigma>), it', \\<sigma>').\n               (\\<sigma>, \\<sigma>') \\<in> R \\<and>\n               \\<Phi>'' it \\<sigma> it' \\<sigma>'};\n        x \\<in> it; \\<forall>y\\<in>it - {x}. RR x y; x' \\<in> it';\n        \\<forall>y'\\<in>it' - {x'}. RR' x' y'; c \\<sigma>;\n        c' \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> f x \\<sigma>\n                         \\<le> \\<Down>\n                                {(\\<sigma>, \\<sigma>').\n                                 ((it - {x}, \\<sigma>), it' - {x'},\n                                  \\<sigma>')\n                                 \\<in> {((it, \\<sigma>), it', \\<sigma>').\n  (\\<sigma>, \\<sigma>') \\<in> R \\<and> \\<Phi>'' it \\<sigma> it' \\<sigma>'}}\n                                (f' x' \\<sigma>')\n 5. \\<And>\\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<Phi> {} \\<sigma>; \\<Phi>' {} \\<sigma>';\n        (({}, \\<sigma>), {}, \\<sigma>')\n        \\<in> {((it, \\<sigma>), it', \\<sigma>').\n               (\\<sigma>, \\<sigma>') \\<in> R \\<and>\n               \\<Phi>'' it \\<sigma> it' \\<sigma>'}\\<rbrakk>\n       \\<Longrightarrow> (\\<sigma>, \\<sigma>') \\<in> R\n 6. \\<And>it \\<sigma> it' \\<sigma>'.\n       \\<lbrakk>it \\<subseteq> S; it' \\<subseteq> S'; \\<Phi> it \\<sigma>;\n        \\<Phi>' it' \\<sigma>';\n        \\<forall>x\\<in>S - it. \\<forall>y\\<in>it. RR x y;\n        \\<forall>x\\<in>S' - it'. \\<forall>y\\<in>it'. RR' x y;\n        it' = \\<alpha> ` it;\n        ((it, \\<sigma>), it', \\<sigma>')\n        \\<in> {((it, \\<sigma>), it', \\<sigma>').\n               (\\<sigma>, \\<sigma>') \\<in> R \\<and>\n               \\<Phi>'' it \\<sigma> it' \\<sigma>'};\n        it \\<noteq> {}; it' \\<noteq> {}; \\<not> c \\<sigma>;\n        \\<not> c' \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> (\\<sigma>, \\<sigma>') \\<in> R", "using REF0 REFPHI0"], ["proof (prove)\nusing this:\n  (\\<sigma>0, \\<sigma>0') \\<in> R\n  \\<Phi>'' S \\<sigma>0 (\\<alpha> ` S) \\<sigma>0'\n\ngoal (6 subgoals):\n 1. ((S, \\<sigma>0), \\<alpha> ` S, \\<sigma>0')\n    \\<in> {((it, \\<sigma>), it', \\<sigma>').\n           (\\<sigma>, \\<sigma>') \\<in> R \\<and>\n           \\<Phi>'' it \\<sigma> it' \\<sigma>'}\n 2. \\<And>it \\<sigma> it' \\<sigma>'.\n       \\<lbrakk>it \\<subseteq> S; it' \\<subseteq> S'; \\<Phi>' it' \\<sigma>';\n        \\<Phi> it \\<sigma>;\n        \\<forall>x\\<in>S - it. \\<forall>y\\<in>it. RR x y;\n        \\<forall>x\\<in>S' - it'. \\<forall>y\\<in>it'. RR' x y;\n        it' = \\<alpha> ` it;\n        ((it, \\<sigma>), it', \\<sigma>')\n        \\<in> {((it, \\<sigma>), it', \\<sigma>').\n               (\\<sigma>, \\<sigma>') \\<in> R \\<and>\n               \\<Phi>'' it \\<sigma> it' \\<sigma>'}\\<rbrakk>\n       \\<Longrightarrow> c \\<sigma> = c' \\<sigma>'\n 3. \\<And>it \\<sigma> it' \\<sigma>'.\n       \\<lbrakk>it \\<subseteq> S; it' \\<subseteq> S'; \\<Phi>' it' \\<sigma>';\n        \\<forall>x\\<in>S - it. \\<forall>y\\<in>it. RR x y;\n        \\<forall>x\\<in>S' - it'. \\<forall>y\\<in>it'. RR' x y;\n        it' = \\<alpha> ` it;\n        ((it, \\<sigma>), it', \\<sigma>')\n        \\<in> {((it, \\<sigma>), it', \\<sigma>').\n               (\\<sigma>, \\<sigma>') \\<in> R \\<and>\n               \\<Phi>'' it \\<sigma> it' \\<sigma>'}\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> it \\<sigma>\n 4. \\<And>x it \\<sigma> x' it' \\<sigma>'.\n       \\<lbrakk>it \\<subseteq> S; it' \\<subseteq> S'; \\<Phi> it \\<sigma>;\n        \\<Phi>' it' \\<sigma>';\n        \\<forall>x\\<in>S - it. \\<forall>y\\<in>it. RR x y;\n        \\<forall>x\\<in>S' - it'. \\<forall>y\\<in>it'. RR' x y;\n        x' = \\<alpha> x; it' = \\<alpha> ` it;\n        ((it, \\<sigma>), it', \\<sigma>')\n        \\<in> {((it, \\<sigma>), it', \\<sigma>').\n               (\\<sigma>, \\<sigma>') \\<in> R \\<and>\n               \\<Phi>'' it \\<sigma> it' \\<sigma>'};\n        x \\<in> it; \\<forall>y\\<in>it - {x}. RR x y; x' \\<in> it';\n        \\<forall>y'\\<in>it' - {x'}. RR' x' y'; c \\<sigma>;\n        c' \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> f x \\<sigma>\n                         \\<le> \\<Down>\n                                {(\\<sigma>, \\<sigma>').\n                                 ((it - {x}, \\<sigma>), it' - {x'},\n                                  \\<sigma>')\n                                 \\<in> {((it, \\<sigma>), it', \\<sigma>').\n  (\\<sigma>, \\<sigma>') \\<in> R \\<and> \\<Phi>'' it \\<sigma> it' \\<sigma>'}}\n                                (f' x' \\<sigma>')\n 5. \\<And>\\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<Phi> {} \\<sigma>; \\<Phi>' {} \\<sigma>';\n        (({}, \\<sigma>), {}, \\<sigma>')\n        \\<in> {((it, \\<sigma>), it', \\<sigma>').\n               (\\<sigma>, \\<sigma>') \\<in> R \\<and>\n               \\<Phi>'' it \\<sigma> it' \\<sigma>'}\\<rbrakk>\n       \\<Longrightarrow> (\\<sigma>, \\<sigma>') \\<in> R\n 6. \\<And>it \\<sigma> it' \\<sigma>'.\n       \\<lbrakk>it \\<subseteq> S; it' \\<subseteq> S'; \\<Phi> it \\<sigma>;\n        \\<Phi>' it' \\<sigma>';\n        \\<forall>x\\<in>S - it. \\<forall>y\\<in>it. RR x y;\n        \\<forall>x\\<in>S' - it'. \\<forall>y\\<in>it'. RR' x y;\n        it' = \\<alpha> ` it;\n        ((it, \\<sigma>), it', \\<sigma>')\n        \\<in> {((it, \\<sigma>), it', \\<sigma>').\n               (\\<sigma>, \\<sigma>') \\<in> R \\<and>\n               \\<Phi>'' it \\<sigma> it' \\<sigma>'};\n        it \\<noteq> {}; it' \\<noteq> {}; \\<not> c \\<sigma>;\n        \\<not> c' \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> (\\<sigma>, \\<sigma>') \\<in> R", "apply blast"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>it \\<sigma> it' \\<sigma>'.\n       \\<lbrakk>it \\<subseteq> S; it' \\<subseteq> S'; \\<Phi>' it' \\<sigma>';\n        \\<Phi> it \\<sigma>;\n        \\<forall>x\\<in>S - it. \\<forall>y\\<in>it. RR x y;\n        \\<forall>x\\<in>S' - it'. \\<forall>y\\<in>it'. RR' x y;\n        it' = \\<alpha> ` it;\n        ((it, \\<sigma>), it', \\<sigma>')\n        \\<in> {((it, \\<sigma>), it', \\<sigma>').\n               (\\<sigma>, \\<sigma>') \\<in> R \\<and>\n               \\<Phi>'' it \\<sigma> it' \\<sigma>'}\\<rbrakk>\n       \\<Longrightarrow> c \\<sigma> = c' \\<sigma>'\n 2. \\<And>it \\<sigma> it' \\<sigma>'.\n       \\<lbrakk>it \\<subseteq> S; it' \\<subseteq> S'; \\<Phi>' it' \\<sigma>';\n        \\<forall>x\\<in>S - it. \\<forall>y\\<in>it. RR x y;\n        \\<forall>x\\<in>S' - it'. \\<forall>y\\<in>it'. RR' x y;\n        it' = \\<alpha> ` it;\n        ((it, \\<sigma>), it', \\<sigma>')\n        \\<in> {((it, \\<sigma>), it', \\<sigma>').\n               (\\<sigma>, \\<sigma>') \\<in> R \\<and>\n               \\<Phi>'' it \\<sigma> it' \\<sigma>'}\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> it \\<sigma>\n 3. \\<And>x it \\<sigma> x' it' \\<sigma>'.\n       \\<lbrakk>it \\<subseteq> S; it' \\<subseteq> S'; \\<Phi> it \\<sigma>;\n        \\<Phi>' it' \\<sigma>';\n        \\<forall>x\\<in>S - it. \\<forall>y\\<in>it. RR x y;\n        \\<forall>x\\<in>S' - it'. \\<forall>y\\<in>it'. RR' x y;\n        x' = \\<alpha> x; it' = \\<alpha> ` it;\n        ((it, \\<sigma>), it', \\<sigma>')\n        \\<in> {((it, \\<sigma>), it', \\<sigma>').\n               (\\<sigma>, \\<sigma>') \\<in> R \\<and>\n               \\<Phi>'' it \\<sigma> it' \\<sigma>'};\n        x \\<in> it; \\<forall>y\\<in>it - {x}. RR x y; x' \\<in> it';\n        \\<forall>y'\\<in>it' - {x'}. RR' x' y'; c \\<sigma>;\n        c' \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> f x \\<sigma>\n                         \\<le> \\<Down>\n                                {(\\<sigma>, \\<sigma>').\n                                 ((it - {x}, \\<sigma>), it' - {x'},\n                                  \\<sigma>')\n                                 \\<in> {((it, \\<sigma>), it', \\<sigma>').\n  (\\<sigma>, \\<sigma>') \\<in> R \\<and> \\<Phi>'' it \\<sigma> it' \\<sigma>'}}\n                                (f' x' \\<sigma>')\n 4. \\<And>\\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<Phi> {} \\<sigma>; \\<Phi>' {} \\<sigma>';\n        (({}, \\<sigma>), {}, \\<sigma>')\n        \\<in> {((it, \\<sigma>), it', \\<sigma>').\n               (\\<sigma>, \\<sigma>') \\<in> R \\<and>\n               \\<Phi>'' it \\<sigma> it' \\<sigma>'}\\<rbrakk>\n       \\<Longrightarrow> (\\<sigma>, \\<sigma>') \\<in> R\n 5. \\<And>it \\<sigma> it' \\<sigma>'.\n       \\<lbrakk>it \\<subseteq> S; it' \\<subseteq> S'; \\<Phi> it \\<sigma>;\n        \\<Phi>' it' \\<sigma>';\n        \\<forall>x\\<in>S - it. \\<forall>y\\<in>it. RR x y;\n        \\<forall>x\\<in>S' - it'. \\<forall>y\\<in>it'. RR' x y;\n        it' = \\<alpha> ` it;\n        ((it, \\<sigma>), it', \\<sigma>')\n        \\<in> {((it, \\<sigma>), it', \\<sigma>').\n               (\\<sigma>, \\<sigma>') \\<in> R \\<and>\n               \\<Phi>'' it \\<sigma> it' \\<sigma>'};\n        it \\<noteq> {}; it' \\<noteq> {}; \\<not> c \\<sigma>;\n        \\<not> c' \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> (\\<sigma>, \\<sigma>') \\<in> R", "using REFC"], ["proof (prove)\nusing this:\n  \\<lbrakk>?it' = \\<alpha> ` ?it; ?it \\<subseteq> S; ?it' \\<subseteq> S';\n   \\<Phi>' ?it' ?\\<sigma>'; \\<Phi>'' ?it ?\\<sigma> ?it' ?\\<sigma>';\n   \\<Phi> ?it ?\\<sigma>; (?\\<sigma>, ?\\<sigma>') \\<in> R\\<rbrakk>\n  \\<Longrightarrow> c ?\\<sigma> = c' ?\\<sigma>'\n\ngoal (5 subgoals):\n 1. \\<And>it \\<sigma> it' \\<sigma>'.\n       \\<lbrakk>it \\<subseteq> S; it' \\<subseteq> S'; \\<Phi>' it' \\<sigma>';\n        \\<Phi> it \\<sigma>;\n        \\<forall>x\\<in>S - it. \\<forall>y\\<in>it. RR x y;\n        \\<forall>x\\<in>S' - it'. \\<forall>y\\<in>it'. RR' x y;\n        it' = \\<alpha> ` it;\n        ((it, \\<sigma>), it', \\<sigma>')\n        \\<in> {((it, \\<sigma>), it', \\<sigma>').\n               (\\<sigma>, \\<sigma>') \\<in> R \\<and>\n               \\<Phi>'' it \\<sigma> it' \\<sigma>'}\\<rbrakk>\n       \\<Longrightarrow> c \\<sigma> = c' \\<sigma>'\n 2. \\<And>it \\<sigma> it' \\<sigma>'.\n       \\<lbrakk>it \\<subseteq> S; it' \\<subseteq> S'; \\<Phi>' it' \\<sigma>';\n        \\<forall>x\\<in>S - it. \\<forall>y\\<in>it. RR x y;\n        \\<forall>x\\<in>S' - it'. \\<forall>y\\<in>it'. RR' x y;\n        it' = \\<alpha> ` it;\n        ((it, \\<sigma>), it', \\<sigma>')\n        \\<in> {((it, \\<sigma>), it', \\<sigma>').\n               (\\<sigma>, \\<sigma>') \\<in> R \\<and>\n               \\<Phi>'' it \\<sigma> it' \\<sigma>'}\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> it \\<sigma>\n 3. \\<And>x it \\<sigma> x' it' \\<sigma>'.\n       \\<lbrakk>it \\<subseteq> S; it' \\<subseteq> S'; \\<Phi> it \\<sigma>;\n        \\<Phi>' it' \\<sigma>';\n        \\<forall>x\\<in>S - it. \\<forall>y\\<in>it. RR x y;\n        \\<forall>x\\<in>S' - it'. \\<forall>y\\<in>it'. RR' x y;\n        x' = \\<alpha> x; it' = \\<alpha> ` it;\n        ((it, \\<sigma>), it', \\<sigma>')\n        \\<in> {((it, \\<sigma>), it', \\<sigma>').\n               (\\<sigma>, \\<sigma>') \\<in> R \\<and>\n               \\<Phi>'' it \\<sigma> it' \\<sigma>'};\n        x \\<in> it; \\<forall>y\\<in>it - {x}. RR x y; x' \\<in> it';\n        \\<forall>y'\\<in>it' - {x'}. RR' x' y'; c \\<sigma>;\n        c' \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> f x \\<sigma>\n                         \\<le> \\<Down>\n                                {(\\<sigma>, \\<sigma>').\n                                 ((it - {x}, \\<sigma>), it' - {x'},\n                                  \\<sigma>')\n                                 \\<in> {((it, \\<sigma>), it', \\<sigma>').\n  (\\<sigma>, \\<sigma>') \\<in> R \\<and> \\<Phi>'' it \\<sigma> it' \\<sigma>'}}\n                                (f' x' \\<sigma>')\n 4. \\<And>\\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<Phi> {} \\<sigma>; \\<Phi>' {} \\<sigma>';\n        (({}, \\<sigma>), {}, \\<sigma>')\n        \\<in> {((it, \\<sigma>), it', \\<sigma>').\n               (\\<sigma>, \\<sigma>') \\<in> R \\<and>\n               \\<Phi>'' it \\<sigma> it' \\<sigma>'}\\<rbrakk>\n       \\<Longrightarrow> (\\<sigma>, \\<sigma>') \\<in> R\n 5. \\<And>it \\<sigma> it' \\<sigma>'.\n       \\<lbrakk>it \\<subseteq> S; it' \\<subseteq> S'; \\<Phi> it \\<sigma>;\n        \\<Phi>' it' \\<sigma>';\n        \\<forall>x\\<in>S - it. \\<forall>y\\<in>it. RR x y;\n        \\<forall>x\\<in>S' - it'. \\<forall>y\\<in>it'. RR' x y;\n        it' = \\<alpha> ` it;\n        ((it, \\<sigma>), it', \\<sigma>')\n        \\<in> {((it, \\<sigma>), it', \\<sigma>').\n               (\\<sigma>, \\<sigma>') \\<in> R \\<and>\n               \\<Phi>'' it \\<sigma> it' \\<sigma>'};\n        it \\<noteq> {}; it' \\<noteq> {}; \\<not> c \\<sigma>;\n        \\<not> c' \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> (\\<sigma>, \\<sigma>') \\<in> R", "apply auto []"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>it \\<sigma> it' \\<sigma>'.\n       \\<lbrakk>it \\<subseteq> S; it' \\<subseteq> S'; \\<Phi>' it' \\<sigma>';\n        \\<forall>x\\<in>S - it. \\<forall>y\\<in>it. RR x y;\n        \\<forall>x\\<in>S' - it'. \\<forall>y\\<in>it'. RR' x y;\n        it' = \\<alpha> ` it;\n        ((it, \\<sigma>), it', \\<sigma>')\n        \\<in> {((it, \\<sigma>), it', \\<sigma>').\n               (\\<sigma>, \\<sigma>') \\<in> R \\<and>\n               \\<Phi>'' it \\<sigma> it' \\<sigma>'}\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> it \\<sigma>\n 2. \\<And>x it \\<sigma> x' it' \\<sigma>'.\n       \\<lbrakk>it \\<subseteq> S; it' \\<subseteq> S'; \\<Phi> it \\<sigma>;\n        \\<Phi>' it' \\<sigma>';\n        \\<forall>x\\<in>S - it. \\<forall>y\\<in>it. RR x y;\n        \\<forall>x\\<in>S' - it'. \\<forall>y\\<in>it'. RR' x y;\n        x' = \\<alpha> x; it' = \\<alpha> ` it;\n        ((it, \\<sigma>), it', \\<sigma>')\n        \\<in> {((it, \\<sigma>), it', \\<sigma>').\n               (\\<sigma>, \\<sigma>') \\<in> R \\<and>\n               \\<Phi>'' it \\<sigma> it' \\<sigma>'};\n        x \\<in> it; \\<forall>y\\<in>it - {x}. RR x y; x' \\<in> it';\n        \\<forall>y'\\<in>it' - {x'}. RR' x' y'; c \\<sigma>;\n        c' \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> f x \\<sigma>\n                         \\<le> \\<Down>\n                                {(\\<sigma>, \\<sigma>').\n                                 ((it - {x}, \\<sigma>), it' - {x'},\n                                  \\<sigma>')\n                                 \\<in> {((it, \\<sigma>), it', \\<sigma>').\n  (\\<sigma>, \\<sigma>') \\<in> R \\<and> \\<Phi>'' it \\<sigma> it' \\<sigma>'}}\n                                (f' x' \\<sigma>')\n 3. \\<And>\\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<Phi> {} \\<sigma>; \\<Phi>' {} \\<sigma>';\n        (({}, \\<sigma>), {}, \\<sigma>')\n        \\<in> {((it, \\<sigma>), it', \\<sigma>').\n               (\\<sigma>, \\<sigma>') \\<in> R \\<and>\n               \\<Phi>'' it \\<sigma> it' \\<sigma>'}\\<rbrakk>\n       \\<Longrightarrow> (\\<sigma>, \\<sigma>') \\<in> R\n 4. \\<And>it \\<sigma> it' \\<sigma>'.\n       \\<lbrakk>it \\<subseteq> S; it' \\<subseteq> S'; \\<Phi> it \\<sigma>;\n        \\<Phi>' it' \\<sigma>';\n        \\<forall>x\\<in>S - it. \\<forall>y\\<in>it. RR x y;\n        \\<forall>x\\<in>S' - it'. \\<forall>y\\<in>it'. RR' x y;\n        it' = \\<alpha> ` it;\n        ((it, \\<sigma>), it', \\<sigma>')\n        \\<in> {((it, \\<sigma>), it', \\<sigma>').\n               (\\<sigma>, \\<sigma>') \\<in> R \\<and>\n               \\<Phi>'' it \\<sigma> it' \\<sigma>'};\n        it \\<noteq> {}; it' \\<noteq> {}; \\<not> c \\<sigma>;\n        \\<not> c' \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> (\\<sigma>, \\<sigma>') \\<in> R", "using REFPHI"], ["proof (prove)\nusing this:\n  \\<lbrakk>?it' = \\<alpha> ` ?it; ?it \\<subseteq> S; ?it' \\<subseteq> S';\n   \\<Phi>' ?it' ?\\<sigma>'; \\<Phi>'' ?it ?\\<sigma> ?it' ?\\<sigma>';\n   (?\\<sigma>, ?\\<sigma>') \\<in> R\\<rbrakk>\n  \\<Longrightarrow> \\<Phi> ?it ?\\<sigma>\n\ngoal (4 subgoals):\n 1. \\<And>it \\<sigma> it' \\<sigma>'.\n       \\<lbrakk>it \\<subseteq> S; it' \\<subseteq> S'; \\<Phi>' it' \\<sigma>';\n        \\<forall>x\\<in>S - it. \\<forall>y\\<in>it. RR x y;\n        \\<forall>x\\<in>S' - it'. \\<forall>y\\<in>it'. RR' x y;\n        it' = \\<alpha> ` it;\n        ((it, \\<sigma>), it', \\<sigma>')\n        \\<in> {((it, \\<sigma>), it', \\<sigma>').\n               (\\<sigma>, \\<sigma>') \\<in> R \\<and>\n               \\<Phi>'' it \\<sigma> it' \\<sigma>'}\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> it \\<sigma>\n 2. \\<And>x it \\<sigma> x' it' \\<sigma>'.\n       \\<lbrakk>it \\<subseteq> S; it' \\<subseteq> S'; \\<Phi> it \\<sigma>;\n        \\<Phi>' it' \\<sigma>';\n        \\<forall>x\\<in>S - it. \\<forall>y\\<in>it. RR x y;\n        \\<forall>x\\<in>S' - it'. \\<forall>y\\<in>it'. RR' x y;\n        x' = \\<alpha> x; it' = \\<alpha> ` it;\n        ((it, \\<sigma>), it', \\<sigma>')\n        \\<in> {((it, \\<sigma>), it', \\<sigma>').\n               (\\<sigma>, \\<sigma>') \\<in> R \\<and>\n               \\<Phi>'' it \\<sigma> it' \\<sigma>'};\n        x \\<in> it; \\<forall>y\\<in>it - {x}. RR x y; x' \\<in> it';\n        \\<forall>y'\\<in>it' - {x'}. RR' x' y'; c \\<sigma>;\n        c' \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> f x \\<sigma>\n                         \\<le> \\<Down>\n                                {(\\<sigma>, \\<sigma>').\n                                 ((it - {x}, \\<sigma>), it' - {x'},\n                                  \\<sigma>')\n                                 \\<in> {((it, \\<sigma>), it', \\<sigma>').\n  (\\<sigma>, \\<sigma>') \\<in> R \\<and> \\<Phi>'' it \\<sigma> it' \\<sigma>'}}\n                                (f' x' \\<sigma>')\n 3. \\<And>\\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<Phi> {} \\<sigma>; \\<Phi>' {} \\<sigma>';\n        (({}, \\<sigma>), {}, \\<sigma>')\n        \\<in> {((it, \\<sigma>), it', \\<sigma>').\n               (\\<sigma>, \\<sigma>') \\<in> R \\<and>\n               \\<Phi>'' it \\<sigma> it' \\<sigma>'}\\<rbrakk>\n       \\<Longrightarrow> (\\<sigma>, \\<sigma>') \\<in> R\n 4. \\<And>it \\<sigma> it' \\<sigma>'.\n       \\<lbrakk>it \\<subseteq> S; it' \\<subseteq> S'; \\<Phi> it \\<sigma>;\n        \\<Phi>' it' \\<sigma>';\n        \\<forall>x\\<in>S - it. \\<forall>y\\<in>it. RR x y;\n        \\<forall>x\\<in>S' - it'. \\<forall>y\\<in>it'. RR' x y;\n        it' = \\<alpha> ` it;\n        ((it, \\<sigma>), it', \\<sigma>')\n        \\<in> {((it, \\<sigma>), it', \\<sigma>').\n               (\\<sigma>, \\<sigma>') \\<in> R \\<and>\n               \\<Phi>'' it \\<sigma> it' \\<sigma>'};\n        it \\<noteq> {}; it' \\<noteq> {}; \\<not> c \\<sigma>;\n        \\<not> c' \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> (\\<sigma>, \\<sigma>') \\<in> R", "apply auto []"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x it \\<sigma> x' it' \\<sigma>'.\n       \\<lbrakk>it \\<subseteq> S; it' \\<subseteq> S'; \\<Phi> it \\<sigma>;\n        \\<Phi>' it' \\<sigma>';\n        \\<forall>x\\<in>S - it. \\<forall>y\\<in>it. RR x y;\n        \\<forall>x\\<in>S' - it'. \\<forall>y\\<in>it'. RR' x y;\n        x' = \\<alpha> x; it' = \\<alpha> ` it;\n        ((it, \\<sigma>), it', \\<sigma>')\n        \\<in> {((it, \\<sigma>), it', \\<sigma>').\n               (\\<sigma>, \\<sigma>') \\<in> R \\<and>\n               \\<Phi>'' it \\<sigma> it' \\<sigma>'};\n        x \\<in> it; \\<forall>y\\<in>it - {x}. RR x y; x' \\<in> it';\n        \\<forall>y'\\<in>it' - {x'}. RR' x' y'; c \\<sigma>;\n        c' \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> f x \\<sigma>\n                         \\<le> \\<Down>\n                                {(\\<sigma>, \\<sigma>').\n                                 ((it - {x}, \\<sigma>), it' - {x'},\n                                  \\<sigma>')\n                                 \\<in> {((it, \\<sigma>), it', \\<sigma>').\n  (\\<sigma>, \\<sigma>') \\<in> R \\<and> \\<Phi>'' it \\<sigma> it' \\<sigma>'}}\n                                (f' x' \\<sigma>')\n 2. \\<And>\\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<Phi> {} \\<sigma>; \\<Phi>' {} \\<sigma>';\n        (({}, \\<sigma>), {}, \\<sigma>')\n        \\<in> {((it, \\<sigma>), it', \\<sigma>').\n               (\\<sigma>, \\<sigma>') \\<in> R \\<and>\n               \\<Phi>'' it \\<sigma> it' \\<sigma>'}\\<rbrakk>\n       \\<Longrightarrow> (\\<sigma>, \\<sigma>') \\<in> R\n 3. \\<And>it \\<sigma> it' \\<sigma>'.\n       \\<lbrakk>it \\<subseteq> S; it' \\<subseteq> S'; \\<Phi> it \\<sigma>;\n        \\<Phi>' it' \\<sigma>';\n        \\<forall>x\\<in>S - it. \\<forall>y\\<in>it. RR x y;\n        \\<forall>x\\<in>S' - it'. \\<forall>y\\<in>it'. RR' x y;\n        it' = \\<alpha> ` it;\n        ((it, \\<sigma>), it', \\<sigma>')\n        \\<in> {((it, \\<sigma>), it', \\<sigma>').\n               (\\<sigma>, \\<sigma>') \\<in> R \\<and>\n               \\<Phi>'' it \\<sigma> it' \\<sigma>'};\n        it \\<noteq> {}; it' \\<noteq> {}; \\<not> c \\<sigma>;\n        \\<not> c' \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> (\\<sigma>, \\<sigma>') \\<in> R", "using REFSTEP"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<forall>y\\<in>?it - {?x}. RR ?x y; ?x' = \\<alpha> ?x;\n   ?x \\<in> ?it; ?x' \\<in> ?it'; ?it' = \\<alpha> ` ?it; ?it \\<subseteq> S;\n   ?it' \\<subseteq> S'; \\<Phi> ?it ?\\<sigma>; \\<Phi>' ?it' ?\\<sigma>';\n   \\<Phi>'' ?it ?\\<sigma> ?it' ?\\<sigma>'; c ?\\<sigma>; c' ?\\<sigma>';\n   (?\\<sigma>, ?\\<sigma>') \\<in> R\\<rbrakk>\n  \\<Longrightarrow> f ?x ?\\<sigma>\n                    \\<le> \\<Down>\n                           {(\\<sigma>, \\<sigma>').\n                            (\\<sigma>, \\<sigma>') \\<in> R \\<and>\n                            \\<Phi>'' (?it - {?x}) \\<sigma> (?it' - {?x'})\n                             \\<sigma>'}\n                           (f' ?x' ?\\<sigma>')\n\ngoal (3 subgoals):\n 1. \\<And>x it \\<sigma> x' it' \\<sigma>'.\n       \\<lbrakk>it \\<subseteq> S; it' \\<subseteq> S'; \\<Phi> it \\<sigma>;\n        \\<Phi>' it' \\<sigma>';\n        \\<forall>x\\<in>S - it. \\<forall>y\\<in>it. RR x y;\n        \\<forall>x\\<in>S' - it'. \\<forall>y\\<in>it'. RR' x y;\n        x' = \\<alpha> x; it' = \\<alpha> ` it;\n        ((it, \\<sigma>), it', \\<sigma>')\n        \\<in> {((it, \\<sigma>), it', \\<sigma>').\n               (\\<sigma>, \\<sigma>') \\<in> R \\<and>\n               \\<Phi>'' it \\<sigma> it' \\<sigma>'};\n        x \\<in> it; \\<forall>y\\<in>it - {x}. RR x y; x' \\<in> it';\n        \\<forall>y'\\<in>it' - {x'}. RR' x' y'; c \\<sigma>;\n        c' \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> f x \\<sigma>\n                         \\<le> \\<Down>\n                                {(\\<sigma>, \\<sigma>').\n                                 ((it - {x}, \\<sigma>), it' - {x'},\n                                  \\<sigma>')\n                                 \\<in> {((it, \\<sigma>), it', \\<sigma>').\n  (\\<sigma>, \\<sigma>') \\<in> R \\<and> \\<Phi>'' it \\<sigma> it' \\<sigma>'}}\n                                (f' x' \\<sigma>')\n 2. \\<And>\\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<Phi> {} \\<sigma>; \\<Phi>' {} \\<sigma>';\n        (({}, \\<sigma>), {}, \\<sigma>')\n        \\<in> {((it, \\<sigma>), it', \\<sigma>').\n               (\\<sigma>, \\<sigma>') \\<in> R \\<and>\n               \\<Phi>'' it \\<sigma> it' \\<sigma>'}\\<rbrakk>\n       \\<Longrightarrow> (\\<sigma>, \\<sigma>') \\<in> R\n 3. \\<And>it \\<sigma> it' \\<sigma>'.\n       \\<lbrakk>it \\<subseteq> S; it' \\<subseteq> S'; \\<Phi> it \\<sigma>;\n        \\<Phi>' it' \\<sigma>';\n        \\<forall>x\\<in>S - it. \\<forall>y\\<in>it. RR x y;\n        \\<forall>x\\<in>S' - it'. \\<forall>y\\<in>it'. RR' x y;\n        it' = \\<alpha> ` it;\n        ((it, \\<sigma>), it', \\<sigma>')\n        \\<in> {((it, \\<sigma>), it', \\<sigma>').\n               (\\<sigma>, \\<sigma>') \\<in> R \\<and>\n               \\<Phi>'' it \\<sigma> it' \\<sigma>'};\n        it \\<noteq> {}; it' \\<noteq> {}; \\<not> c \\<sigma>;\n        \\<not> c' \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> (\\<sigma>, \\<sigma>') \\<in> R", "apply auto []"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>\\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<Phi> {} \\<sigma>; \\<Phi>' {} \\<sigma>';\n        (({}, \\<sigma>), {}, \\<sigma>')\n        \\<in> {((it, \\<sigma>), it', \\<sigma>').\n               (\\<sigma>, \\<sigma>') \\<in> R \\<and>\n               \\<Phi>'' it \\<sigma> it' \\<sigma>'}\\<rbrakk>\n       \\<Longrightarrow> (\\<sigma>, \\<sigma>') \\<in> R\n 2. \\<And>it \\<sigma> it' \\<sigma>'.\n       \\<lbrakk>it \\<subseteq> S; it' \\<subseteq> S'; \\<Phi> it \\<sigma>;\n        \\<Phi>' it' \\<sigma>';\n        \\<forall>x\\<in>S - it. \\<forall>y\\<in>it. RR x y;\n        \\<forall>x\\<in>S' - it'. \\<forall>y\\<in>it'. RR' x y;\n        it' = \\<alpha> ` it;\n        ((it, \\<sigma>), it', \\<sigma>')\n        \\<in> {((it, \\<sigma>), it', \\<sigma>').\n               (\\<sigma>, \\<sigma>') \\<in> R \\<and>\n               \\<Phi>'' it \\<sigma> it' \\<sigma>'};\n        it \\<noteq> {}; it' \\<noteq> {}; \\<not> c \\<sigma>;\n        \\<not> c' \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> (\\<sigma>, \\<sigma>') \\<in> R", "apply auto []"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>it \\<sigma> it' \\<sigma>'.\n       \\<lbrakk>it \\<subseteq> S; it' \\<subseteq> S'; \\<Phi> it \\<sigma>;\n        \\<Phi>' it' \\<sigma>';\n        \\<forall>x\\<in>S - it. \\<forall>y\\<in>it. RR x y;\n        \\<forall>x\\<in>S' - it'. \\<forall>y\\<in>it'. RR' x y;\n        it' = \\<alpha> ` it;\n        ((it, \\<sigma>), it', \\<sigma>')\n        \\<in> {((it, \\<sigma>), it', \\<sigma>').\n               (\\<sigma>, \\<sigma>') \\<in> R \\<and>\n               \\<Phi>'' it \\<sigma> it' \\<sigma>'};\n        it \\<noteq> {}; it' \\<noteq> {}; \\<not> c \\<sigma>;\n        \\<not> c' \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> (\\<sigma>, \\<sigma>') \\<in> R", "apply auto []"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma FOREACHoci_refine_rcg[refine]:\n  fixes \\<alpha> :: \"'S \\<Rightarrow> 'Sa\"\n  fixes S :: \"'S set\"\n  fixes S' :: \"'Sa set\"\n  assumes INJ: \"inj_on \\<alpha> S\"\n  assumes REFS: \"S' = \\<alpha>`S\"\n  assumes REF0: \"(\\<sigma>0,\\<sigma>0')\\<in>R\"\n  assumes RR_OK: \"\\<And>x y. \\<lbrakk>x \\<in> S; y \\<in> S; RR x y\\<rbrakk> \\<Longrightarrow> RR' (\\<alpha> x) (\\<alpha> y)\"\n  assumes REFC: \"\\<And>it \\<sigma> it' \\<sigma>'. \\<lbrakk> \n    it'=\\<alpha>`it; it\\<subseteq>S; it'\\<subseteq>S'; \\<Phi>' it' \\<sigma>'; \\<Phi> it \\<sigma>; (\\<sigma>,\\<sigma>')\\<in>R\n  \\<rbrakk> \\<Longrightarrow> c \\<sigma> \\<longleftrightarrow> c' \\<sigma>'\"\n  assumes REFPHI: \"\\<And>it \\<sigma> it' \\<sigma>'. \\<lbrakk> \n    it'=\\<alpha>`it; it\\<subseteq>S; it'\\<subseteq>S'; \\<Phi>' it' \\<sigma>'; (\\<sigma>,\\<sigma>')\\<in>R\n  \\<rbrakk> \\<Longrightarrow> \\<Phi> it \\<sigma>\"\n  assumes REFSTEP: \"\\<And>x it \\<sigma> x' it' \\<sigma>'. \\<lbrakk> \\<forall>y\\<in>it-{x}. RR x y;\n    x'=\\<alpha> x; x\\<in>it; x'\\<in>it'; it'=\\<alpha>`it; it\\<subseteq>S; it'\\<subseteq>S';\n    \\<Phi> it \\<sigma>; \\<Phi>' it' \\<sigma>'; c \\<sigma>; c' \\<sigma>';\n    (\\<sigma>,\\<sigma>')\\<in>R\n  \\<rbrakk> \\<Longrightarrow> f x \\<sigma> \\<le> \\<Down>R (f' x' \\<sigma>')\"\n  shows \"FOREACHoci RR \\<Phi> S c f \\<sigma>0 \\<le> \\<Down>R (FOREACHoci RR' \\<Phi>' S' c' f' \\<sigma>0')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. FOREACH\\<^sub>O\\<^sub>C\\<^bsup>RR,\\<Phi>\\<^esup> S c f \\<sigma>0\n    \\<le> \\<Down> R\n           (FOREACH\\<^sub>O\\<^sub>C\\<^bsup>RR',\\<Phi>'\\<^esup> S' c' f'\n             \\<sigma>0')", "apply (rule FOREACHoci_refine[where \\<Phi>''=\"\\<lambda>_ _ _ _. True\"])"], ["proof (prove)\ngoal (8 subgoals):\n 1. inj_on ?\\<alpha> S\n 2. S' = ?\\<alpha> ` S\n 3. (\\<sigma>0, \\<sigma>0') \\<in> R\n 4. \\<And>x y.\n       \\<lbrakk>x \\<in> S; y \\<in> S; RR x y\\<rbrakk>\n       \\<Longrightarrow> RR' (?\\<alpha> x) (?\\<alpha> y)\n 5. True\n 6. \\<And>it \\<sigma> it' \\<sigma>'.\n       \\<lbrakk>it' = ?\\<alpha> ` it; it \\<subseteq> S; it' \\<subseteq> S';\n        \\<Phi>' it' \\<sigma>'; True; \\<Phi> it \\<sigma>;\n        (\\<sigma>, \\<sigma>') \\<in> R\\<rbrakk>\n       \\<Longrightarrow> c \\<sigma> = c' \\<sigma>'\n 7. \\<And>it \\<sigma> it' \\<sigma>'.\n       \\<lbrakk>it' = ?\\<alpha> ` it; it \\<subseteq> S; it' \\<subseteq> S';\n        \\<Phi>' it' \\<sigma>'; True; (\\<sigma>, \\<sigma>') \\<in> R\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> it \\<sigma>\n 8. \\<And>x it \\<sigma> x' it' \\<sigma>'.\n       \\<lbrakk>\\<forall>y\\<in>it - {x}. RR x y; x' = ?\\<alpha> x;\n        x \\<in> it; x' \\<in> it'; it' = ?\\<alpha> ` it; it \\<subseteq> S;\n        it' \\<subseteq> S'; \\<Phi> it \\<sigma>; \\<Phi>' it' \\<sigma>'; True;\n        c \\<sigma>; c' \\<sigma>'; (\\<sigma>, \\<sigma>') \\<in> R\\<rbrakk>\n       \\<Longrightarrow> f x \\<sigma>\n                         \\<le> \\<Down>\n                                {(\\<sigma>, \\<sigma>').\n                                 (\\<sigma>, \\<sigma>') \\<in> R \\<and> True}\n                                (f' x' \\<sigma>')", "apply (rule assms)+"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> S; y \\<in> S; RR x y\\<rbrakk>\n       \\<Longrightarrow> x \\<in> S\n 2. \\<And>x y.\n       \\<lbrakk>x \\<in> S; y \\<in> S; RR x y\\<rbrakk>\n       \\<Longrightarrow> y \\<in> S\n 3. \\<And>x y.\n       \\<lbrakk>x \\<in> S; y \\<in> S; RR x y\\<rbrakk>\n       \\<Longrightarrow> RR x y\n 4. True\n 5. \\<And>it \\<sigma> it' \\<sigma>'.\n       \\<lbrakk>it' = \\<alpha> ` it; it \\<subseteq> S; it' \\<subseteq> S';\n        \\<Phi>' it' \\<sigma>'; True; \\<Phi> it \\<sigma>;\n        (\\<sigma>, \\<sigma>') \\<in> R\\<rbrakk>\n       \\<Longrightarrow> c \\<sigma> = c' \\<sigma>'\n 6. \\<And>it \\<sigma> it' \\<sigma>'.\n       \\<lbrakk>it' = \\<alpha> ` it; it \\<subseteq> S; it' \\<subseteq> S';\n        \\<Phi>' it' \\<sigma>'; True; (\\<sigma>, \\<sigma>') \\<in> R\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> it \\<sigma>\n 7. \\<And>x it \\<sigma> x' it' \\<sigma>'.\n       \\<lbrakk>\\<forall>y\\<in>it - {x}. RR x y; x' = \\<alpha> x;\n        x \\<in> it; x' \\<in> it'; it' = \\<alpha> ` it; it \\<subseteq> S;\n        it' \\<subseteq> S'; \\<Phi> it \\<sigma>; \\<Phi>' it' \\<sigma>'; True;\n        c \\<sigma>; c' \\<sigma>'; (\\<sigma>, \\<sigma>') \\<in> R\\<rbrakk>\n       \\<Longrightarrow> f x \\<sigma>\n                         \\<le> \\<Down>\n                                {(\\<sigma>, \\<sigma>').\n                                 (\\<sigma>, \\<sigma>') \\<in> R \\<and> True}\n                                (f' x' \\<sigma>')", "using assms"], ["proof (prove)\nusing this:\n  inj_on \\<alpha> S\n  S' = \\<alpha> ` S\n  (\\<sigma>0, \\<sigma>0') \\<in> R\n  \\<lbrakk>?x \\<in> S; ?y \\<in> S; RR ?x ?y\\<rbrakk>\n  \\<Longrightarrow> RR' (\\<alpha> ?x) (\\<alpha> ?y)\n  \\<lbrakk>?it' = \\<alpha> ` ?it; ?it \\<subseteq> S; ?it' \\<subseteq> S';\n   \\<Phi>' ?it' ?\\<sigma>'; \\<Phi> ?it ?\\<sigma>;\n   (?\\<sigma>, ?\\<sigma>') \\<in> R\\<rbrakk>\n  \\<Longrightarrow> c ?\\<sigma> = c' ?\\<sigma>'\n  \\<lbrakk>?it' = \\<alpha> ` ?it; ?it \\<subseteq> S; ?it' \\<subseteq> S';\n   \\<Phi>' ?it' ?\\<sigma>'; (?\\<sigma>, ?\\<sigma>') \\<in> R\\<rbrakk>\n  \\<Longrightarrow> \\<Phi> ?it ?\\<sigma>\n  \\<lbrakk>\\<forall>y\\<in>?it - {?x}. RR ?x y; ?x' = \\<alpha> ?x;\n   ?x \\<in> ?it; ?x' \\<in> ?it'; ?it' = \\<alpha> ` ?it; ?it \\<subseteq> S;\n   ?it' \\<subseteq> S'; \\<Phi> ?it ?\\<sigma>; \\<Phi>' ?it' ?\\<sigma>';\n   c ?\\<sigma>; c' ?\\<sigma>'; (?\\<sigma>, ?\\<sigma>') \\<in> R\\<rbrakk>\n  \\<Longrightarrow> f ?x ?\\<sigma> \\<le> \\<Down> R (f' ?x' ?\\<sigma>')\n\ngoal (7 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> S; y \\<in> S; RR x y\\<rbrakk>\n       \\<Longrightarrow> x \\<in> S\n 2. \\<And>x y.\n       \\<lbrakk>x \\<in> S; y \\<in> S; RR x y\\<rbrakk>\n       \\<Longrightarrow> y \\<in> S\n 3. \\<And>x y.\n       \\<lbrakk>x \\<in> S; y \\<in> S; RR x y\\<rbrakk>\n       \\<Longrightarrow> RR x y\n 4. True\n 5. \\<And>it \\<sigma> it' \\<sigma>'.\n       \\<lbrakk>it' = \\<alpha> ` it; it \\<subseteq> S; it' \\<subseteq> S';\n        \\<Phi>' it' \\<sigma>'; True; \\<Phi> it \\<sigma>;\n        (\\<sigma>, \\<sigma>') \\<in> R\\<rbrakk>\n       \\<Longrightarrow> c \\<sigma> = c' \\<sigma>'\n 6. \\<And>it \\<sigma> it' \\<sigma>'.\n       \\<lbrakk>it' = \\<alpha> ` it; it \\<subseteq> S; it' \\<subseteq> S';\n        \\<Phi>' it' \\<sigma>'; True; (\\<sigma>, \\<sigma>') \\<in> R\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> it \\<sigma>\n 7. \\<And>x it \\<sigma> x' it' \\<sigma>'.\n       \\<lbrakk>\\<forall>y\\<in>it - {x}. RR x y; x' = \\<alpha> x;\n        x \\<in> it; x' \\<in> it'; it' = \\<alpha> ` it; it \\<subseteq> S;\n        it' \\<subseteq> S'; \\<Phi> it \\<sigma>; \\<Phi>' it' \\<sigma>'; True;\n        c \\<sigma>; c' \\<sigma>'; (\\<sigma>, \\<sigma>') \\<in> R\\<rbrakk>\n       \\<Longrightarrow> f x \\<sigma>\n                         \\<le> \\<Down>\n                                {(\\<sigma>, \\<sigma>').\n                                 (\\<sigma>, \\<sigma>') \\<in> R \\<and> True}\n                                (f' x' \\<sigma>')", "by simp_all"], ["", "lemma FOREACHoci_weaken:\n  assumes IREF: \"\\<And>it \\<sigma>. it\\<subseteq>S \\<Longrightarrow> I it \\<sigma> \\<Longrightarrow> I' it \\<sigma>\"\n  shows \"FOREACHoci RR I' S c f \\<sigma>0 \\<le> FOREACHoci RR I S c f \\<sigma>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. FOREACH\\<^sub>O\\<^sub>C\\<^bsup>RR,I'\\<^esup> S c f \\<sigma>0\n    \\<le> FOREACH\\<^sub>O\\<^sub>C\\<^bsup>RR,I\\<^esup> S c f \\<sigma>0", "apply (rule FOREACHoci_refine_rcg[where \\<alpha>=id and R=Id, simplified])"], ["proof (prove)\ngoal (6 subgoals):\n 1. S = S\n 2. \\<sigma>0 = \\<sigma>0\n 3. \\<And>x y.\n       \\<lbrakk>x \\<in> S; y \\<in> S; RR x y\\<rbrakk>\n       \\<Longrightarrow> RR x y\n 4. \\<And>it \\<sigma> it' \\<sigma>'.\n       \\<lbrakk>it' = it; it \\<subseteq> S; it' \\<subseteq> S;\n        I it' \\<sigma>'; I' it \\<sigma>; \\<sigma> = \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> c \\<sigma> = c \\<sigma>'\n 5. \\<And>it \\<sigma> it' \\<sigma>'.\n       \\<lbrakk>it' = it; it \\<subseteq> S; it' \\<subseteq> S;\n        I it' \\<sigma>'; \\<sigma> = \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> I' it \\<sigma>\n 6. \\<And>x it \\<sigma> x' it' \\<sigma>'.\n       \\<lbrakk>\\<forall>xa\\<in>it - {x}. RR x xa; x' = x; x \\<in> it;\n        x' \\<in> it'; it' = it; it \\<subseteq> S; it' \\<subseteq> S;\n        I' it \\<sigma>; I it' \\<sigma>'; c \\<sigma>; c \\<sigma>';\n        \\<sigma> = \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> f x \\<sigma> \\<le> f x' \\<sigma>'", "apply (auto intro: IREF)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma FOREACHoci_weaken_order:\n  assumes RRREF: \"\\<And>x y. x \\<in> S \\<Longrightarrow> y \\<in> S \\<Longrightarrow> RR x y \\<Longrightarrow> RR' x y\"\n  shows \"FOREACHoci RR I S c f \\<sigma>0 \\<le> FOREACHoci RR' I S c f \\<sigma>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. FOREACH\\<^sub>O\\<^sub>C\\<^bsup>RR,I\\<^esup> S c f \\<sigma>0\n    \\<le> FOREACH\\<^sub>O\\<^sub>C\\<^bsup>RR',I\\<^esup> S c f \\<sigma>0", "apply (rule FOREACHoci_refine_rcg[where \\<alpha>=id and R=Id, simplified])"], ["proof (prove)\ngoal (6 subgoals):\n 1. S = S\n 2. \\<sigma>0 = \\<sigma>0\n 3. \\<And>x y.\n       \\<lbrakk>x \\<in> S; y \\<in> S; RR x y\\<rbrakk>\n       \\<Longrightarrow> RR' x y\n 4. \\<And>it \\<sigma> it' \\<sigma>'.\n       \\<lbrakk>it' = it; it \\<subseteq> S; it' \\<subseteq> S;\n        I it' \\<sigma>'; I it \\<sigma>; \\<sigma> = \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> c \\<sigma> = c \\<sigma>'\n 5. \\<And>it \\<sigma> it' \\<sigma>'.\n       \\<lbrakk>it' = it; it \\<subseteq> S; it' \\<subseteq> S;\n        I it' \\<sigma>'; \\<sigma> = \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> I it \\<sigma>\n 6. \\<And>x it \\<sigma> x' it' \\<sigma>'.\n       \\<lbrakk>\\<forall>xa\\<in>it - {x}. RR x xa; x' = x; x \\<in> it;\n        x' \\<in> it'; it' = it; it \\<subseteq> S; it' \\<subseteq> S;\n        I it \\<sigma>; I it' \\<sigma>'; c \\<sigma>; c \\<sigma>';\n        \\<sigma> = \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> f x \\<sigma> \\<le> f x' \\<sigma>'", "apply (auto intro: RRREF)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsubsection \\<open>Rules for Derived Constructs\\<close>"], ["", "lemma FOREACHoi_refine_genR:\n  fixes \\<alpha> :: \"'S \\<Rightarrow> 'Sa\" \\<comment> \\<open>Abstraction mapping of elements\\<close>\n  fixes S :: \"'S set\" \\<comment> \\<open>Concrete set\\<close>\n  fixes S' :: \"'Sa set\" \\<comment> \\<open>Abstract set\\<close>\n  fixes \\<sigma>0 :: \"'\\<sigma>\"\n  fixes \\<sigma>0' :: \"'\\<sigma>a\"\n  fixes R :: \"(('S set \\<times> '\\<sigma>) \\<times> ('Sa set \\<times> '\\<sigma>a)) set\"\n  assumes INJ: \"inj_on \\<alpha> S\" \n  assumes REFS[simp]: \"S' = \\<alpha>`S\"\n  assumes RR_OK: \"\\<And>x y. \\<lbrakk>x \\<in> S; y \\<in> S; RR x y\\<rbrakk> \\<Longrightarrow> RR' (\\<alpha> x) (\\<alpha> y)\"\n  assumes REF0: \"((S,\\<sigma>0),(\\<alpha>`S,\\<sigma>0')) \\<in> R\"\n  assumes REFPHI: \"\\<And>it \\<sigma> it' \\<sigma>'. \\<lbrakk> \n    it\\<subseteq>S; it'\\<subseteq>S'; \\<Phi>' it' \\<sigma>';\n    \\<forall>x\\<in>S-it. \\<forall>y\\<in>it. RR x y; \\<forall>x\\<in>S'-it'. \\<forall>y\\<in>it'. RR' x y;\n    it'=\\<alpha>`it; ((it,\\<sigma>),(it',\\<sigma>'))\\<in>R\n  \\<rbrakk> \\<Longrightarrow> \\<Phi> it \\<sigma>\"\n  assumes REFSTEP: \"\\<And>x it \\<sigma> x' it' \\<sigma>'. \\<lbrakk>\n    it\\<subseteq>S; it'\\<subseteq>S'; \\<Phi> it \\<sigma>; \\<Phi>' it' \\<sigma>';\n    \\<forall>x\\<in>S-it. \\<forall>y\\<in>it. RR x y; \\<forall>x\\<in>S'-it'. \\<forall>y\\<in>it'. RR' x y;\n    x'=\\<alpha> x; it'=\\<alpha>`it; ((it,\\<sigma>),(it',\\<sigma>'))\\<in>R;\n    x\\<in>it; \\<forall>y\\<in>it-{x}. RR x y;\n    x'\\<in>it'; \\<forall>y'\\<in>it'-{x'}. RR' x' y'\n  \\<rbrakk> \\<Longrightarrow> f x \\<sigma> \n    \\<le> \\<Down>({(\\<sigma>, \\<sigma>'). ((it-{x},\\<sigma>),(it'-{x'},\\<sigma>'))\\<in>R}) (f' x' \\<sigma>')\"\n  assumes REF_R_DONE: \"\\<And>\\<sigma> \\<sigma>'. \\<lbrakk> \\<Phi> {} \\<sigma>; \\<Phi>' {} \\<sigma>'; (({},\\<sigma>),({},\\<sigma>'))\\<in>R \\<rbrakk> \n    \\<Longrightarrow> (\\<sigma>,\\<sigma>')\\<in>R'\"\n  shows \"FOREACHoi RR \\<Phi> S f \\<sigma>0 \\<le> \\<Down>R' (FOREACHoi RR' \\<Phi>' S' f' \\<sigma>0')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. FOREACH\\<^sub>O\\<^bsup>RR,\\<Phi>\\<^esup> S f \\<sigma>0\n    \\<le> \\<Down> R'\n           (FOREACH\\<^sub>O\\<^bsup>RR',\\<Phi>'\\<^esup> S' f' \\<sigma>0')", "unfolding FOREACHoi_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. FOREACH\\<^sub>O\\<^sub>C\\<^bsup>RR,\\<Phi>\\<^esup> S (\\<lambda>_. True) f\n     \\<sigma>0\n    \\<le> \\<Down> R'\n           (FOREACH\\<^sub>O\\<^sub>C\\<^bsup>RR',\\<Phi>'\\<^esup> S'\n             (\\<lambda>_. True) f' \\<sigma>0')", "apply (rule FOREACHoci_refine_genR)"], ["proof (prove)\ngoal (9 subgoals):\n 1. inj_on ?\\<alpha> S\n 2. S' = ?\\<alpha> ` S\n 3. \\<And>x y.\n       \\<lbrakk>x \\<in> S; y \\<in> S; RR x y\\<rbrakk>\n       \\<Longrightarrow> RR' (?\\<alpha> x) (?\\<alpha> y)\n 4. ((S, \\<sigma>0), ?\\<alpha> ` S, \\<sigma>0') \\<in> ?R\n 5. \\<And>it \\<sigma> it' \\<sigma>'.\n       \\<lbrakk>it \\<subseteq> S; it' \\<subseteq> S'; \\<Phi>' it' \\<sigma>';\n        \\<Phi> it \\<sigma>;\n        \\<forall>x\\<in>S - it. \\<forall>y\\<in>it. RR x y;\n        \\<forall>x\\<in>S' - it'. \\<forall>y\\<in>it'. RR' x y;\n        it' = ?\\<alpha> ` it;\n        ((it, \\<sigma>), it', \\<sigma>') \\<in> ?R\\<rbrakk>\n       \\<Longrightarrow> True = True\n 6. \\<And>it \\<sigma> it' \\<sigma>'.\n       \\<lbrakk>it \\<subseteq> S; it' \\<subseteq> S'; \\<Phi>' it' \\<sigma>';\n        \\<forall>x\\<in>S - it. \\<forall>y\\<in>it. RR x y;\n        \\<forall>x\\<in>S' - it'. \\<forall>y\\<in>it'. RR' x y;\n        it' = ?\\<alpha> ` it;\n        ((it, \\<sigma>), it', \\<sigma>') \\<in> ?R\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> it \\<sigma>\n 7. \\<And>x it \\<sigma> x' it' \\<sigma>'.\n       \\<lbrakk>it \\<subseteq> S; it' \\<subseteq> S'; \\<Phi> it \\<sigma>;\n        \\<Phi>' it' \\<sigma>';\n        \\<forall>x\\<in>S - it. \\<forall>y\\<in>it. RR x y;\n        \\<forall>x\\<in>S' - it'. \\<forall>y\\<in>it'. RR' x y;\n        x' = ?\\<alpha> x; it' = ?\\<alpha> ` it;\n        ((it, \\<sigma>), it', \\<sigma>') \\<in> ?R; x \\<in> it;\n        \\<forall>y\\<in>it - {x}. RR x y; x' \\<in> it';\n        \\<forall>y'\\<in>it' - {x'}. RR' x' y'; True; True\\<rbrakk>\n       \\<Longrightarrow> f x \\<sigma>\n                         \\<le> \\<Down>\n                                {(\\<sigma>, \\<sigma>').\n                                 ((it - {x}, \\<sigma>), it' - {x'},\n                                  \\<sigma>')\n                                 \\<in> ?R}\n                                (f' x' \\<sigma>')\n 8. \\<And>\\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<Phi> {} \\<sigma>; \\<Phi>' {} \\<sigma>';\n        (({}, \\<sigma>), {}, \\<sigma>') \\<in> ?R\\<rbrakk>\n       \\<Longrightarrow> (\\<sigma>, \\<sigma>') \\<in> R'\n 9. \\<And>it \\<sigma> it' \\<sigma>'.\n       \\<lbrakk>it \\<subseteq> S; it' \\<subseteq> S'; \\<Phi> it \\<sigma>;\n        \\<Phi>' it' \\<sigma>';\n        \\<forall>x\\<in>S - it. \\<forall>y\\<in>it. RR x y;\n        \\<forall>x\\<in>S' - it'. \\<forall>y\\<in>it'. RR' x y;\n        it' = ?\\<alpha> ` it; ((it, \\<sigma>), it', \\<sigma>') \\<in> ?R;\n        it \\<noteq> {}; it' \\<noteq> {}; \\<not> True; \\<not> True\\<rbrakk>\n       \\<Longrightarrow> (\\<sigma>, \\<sigma>') \\<in> R'", "apply (fact | simp)+"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x it \\<sigma> x' it' \\<sigma>'.\n       \\<lbrakk>it \\<subseteq> S; \\<alpha> ` it \\<subseteq> \\<alpha> ` S;\n        \\<Phi> it \\<sigma>; \\<Phi>' (\\<alpha> ` it) \\<sigma>';\n        \\<forall>x\\<in>S - it. \\<forall>y\\<in>it. RR x y;\n        \\<forall>x\\<in>\\<alpha> ` S - \\<alpha> ` it.\n           \\<forall>xa\\<in>it. RR' x (\\<alpha> xa);\n        x' = \\<alpha> x; it' = \\<alpha> ` it;\n        ((it, \\<sigma>), \\<alpha> ` it, \\<sigma>') \\<in> R; x \\<in> it;\n        \\<forall>y\\<in>it - {x}. RR x y;\n        \\<forall>xa\\<in>\\<alpha> ` it - {\\<alpha> x}.\n           RR' (\\<alpha> x) xa\\<rbrakk>\n       \\<Longrightarrow> f x \\<sigma>\n                         \\<le> \\<Down>\n                                {(\\<sigma>, \\<sigma>').\n                                 ((it - {x}, \\<sigma>),\n                                  \\<alpha> ` it - {\\<alpha> x}, \\<sigma>')\n                                 \\<in> R}\n                                (f' (\\<alpha> x) \\<sigma>')\n 2. \\<And>\\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<Phi> {} \\<sigma>; \\<Phi>' {} \\<sigma>';\n        (({}, \\<sigma>), {}, \\<sigma>') \\<in> R\\<rbrakk>\n       \\<Longrightarrow> (\\<sigma>, \\<sigma>') \\<in> R'\n 3. \\<And>it \\<sigma> it' \\<sigma>'.\n       \\<lbrakk>it \\<subseteq> S; it' \\<subseteq> S'; \\<Phi> it \\<sigma>;\n        \\<Phi>' it' \\<sigma>';\n        \\<forall>x\\<in>S - it. \\<forall>y\\<in>it. RR x y;\n        \\<forall>x\\<in>S' - it'. \\<forall>y\\<in>it'. RR' x y;\n        it' = \\<alpha> ` it; ((it, \\<sigma>), it', \\<sigma>') \\<in> R;\n        it \\<noteq> {}; it' \\<noteq> {}; \\<not> True; \\<not> True\\<rbrakk>\n       \\<Longrightarrow> (\\<sigma>, \\<sigma>') \\<in> R'", "using REFSTEP"], ["proof (prove)\nusing this:\n  \\<lbrakk>?it \\<subseteq> S; ?it' \\<subseteq> S'; \\<Phi> ?it ?\\<sigma>;\n   \\<Phi>' ?it' ?\\<sigma>';\n   \\<forall>x\\<in>S - ?it. \\<forall>y\\<in>?it. RR x y;\n   \\<forall>x\\<in>S' - ?it'. \\<forall>y\\<in>?it'. RR' x y;\n   ?x' = \\<alpha> ?x; ?it' = \\<alpha> ` ?it;\n   ((?it, ?\\<sigma>), ?it', ?\\<sigma>') \\<in> R; ?x \\<in> ?it;\n   \\<forall>y\\<in>?it - {?x}. RR ?x y; ?x' \\<in> ?it';\n   \\<forall>y'\\<in>?it' - {?x'}. RR' ?x' y'\\<rbrakk>\n  \\<Longrightarrow> f ?x ?\\<sigma>\n                    \\<le> \\<Down>\n                           {(\\<sigma>, \\<sigma>').\n                            ((?it - {?x}, \\<sigma>), ?it' - {?x'},\n                             \\<sigma>')\n                            \\<in> R}\n                           (f' ?x' ?\\<sigma>')\n\ngoal (3 subgoals):\n 1. \\<And>x it \\<sigma> x' it' \\<sigma>'.\n       \\<lbrakk>it \\<subseteq> S; \\<alpha> ` it \\<subseteq> \\<alpha> ` S;\n        \\<Phi> it \\<sigma>; \\<Phi>' (\\<alpha> ` it) \\<sigma>';\n        \\<forall>x\\<in>S - it. \\<forall>y\\<in>it. RR x y;\n        \\<forall>x\\<in>\\<alpha> ` S - \\<alpha> ` it.\n           \\<forall>xa\\<in>it. RR' x (\\<alpha> xa);\n        x' = \\<alpha> x; it' = \\<alpha> ` it;\n        ((it, \\<sigma>), \\<alpha> ` it, \\<sigma>') \\<in> R; x \\<in> it;\n        \\<forall>y\\<in>it - {x}. RR x y;\n        \\<forall>xa\\<in>\\<alpha> ` it - {\\<alpha> x}.\n           RR' (\\<alpha> x) xa\\<rbrakk>\n       \\<Longrightarrow> f x \\<sigma>\n                         \\<le> \\<Down>\n                                {(\\<sigma>, \\<sigma>').\n                                 ((it - {x}, \\<sigma>),\n                                  \\<alpha> ` it - {\\<alpha> x}, \\<sigma>')\n                                 \\<in> R}\n                                (f' (\\<alpha> x) \\<sigma>')\n 2. \\<And>\\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<Phi> {} \\<sigma>; \\<Phi>' {} \\<sigma>';\n        (({}, \\<sigma>), {}, \\<sigma>') \\<in> R\\<rbrakk>\n       \\<Longrightarrow> (\\<sigma>, \\<sigma>') \\<in> R'\n 3. \\<And>it \\<sigma> it' \\<sigma>'.\n       \\<lbrakk>it \\<subseteq> S; it' \\<subseteq> S'; \\<Phi> it \\<sigma>;\n        \\<Phi>' it' \\<sigma>';\n        \\<forall>x\\<in>S - it. \\<forall>y\\<in>it. RR x y;\n        \\<forall>x\\<in>S' - it'. \\<forall>y\\<in>it'. RR' x y;\n        it' = \\<alpha> ` it; ((it, \\<sigma>), it', \\<sigma>') \\<in> R;\n        it \\<noteq> {}; it' \\<noteq> {}; \\<not> True; \\<not> True\\<rbrakk>\n       \\<Longrightarrow> (\\<sigma>, \\<sigma>') \\<in> R'", "apply auto []"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>\\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<Phi> {} \\<sigma>; \\<Phi>' {} \\<sigma>';\n        (({}, \\<sigma>), {}, \\<sigma>') \\<in> R\\<rbrakk>\n       \\<Longrightarrow> (\\<sigma>, \\<sigma>') \\<in> R'\n 2. \\<And>it \\<sigma> it' \\<sigma>'.\n       \\<lbrakk>it \\<subseteq> S; it' \\<subseteq> S'; \\<Phi> it \\<sigma>;\n        \\<Phi>' it' \\<sigma>';\n        \\<forall>x\\<in>S - it. \\<forall>y\\<in>it. RR x y;\n        \\<forall>x\\<in>S' - it'. \\<forall>y\\<in>it'. RR' x y;\n        it' = \\<alpha> ` it; ((it, \\<sigma>), it', \\<sigma>') \\<in> R;\n        it \\<noteq> {}; it' \\<noteq> {}; \\<not> True; \\<not> True\\<rbrakk>\n       \\<Longrightarrow> (\\<sigma>, \\<sigma>') \\<in> R'", "apply (fact | simp)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma FOREACHoi_refine:\n  fixes \\<alpha> :: \"'S \\<Rightarrow> 'Sa\"\n  fixes S :: \"'S set\"\n  fixes S' :: \"'Sa set\"\n  assumes INJ: \"inj_on \\<alpha> S\"\n  assumes REFS: \"S' = \\<alpha>`S\"\n  assumes REF0: \"(\\<sigma>0,\\<sigma>0')\\<in>R\"\n  assumes RR_OK: \"\\<And>x y. \\<lbrakk>x \\<in> S; y \\<in> S; RR x y\\<rbrakk> \\<Longrightarrow> RR' (\\<alpha> x) (\\<alpha> y)\"\n  assumes REFPHI0: \"\\<Phi>'' S \\<sigma>0 (\\<alpha>`S) \\<sigma>0'\"\n  assumes REFPHI: \"\\<And>it \\<sigma> it' \\<sigma>'. \\<lbrakk> \n    it'=\\<alpha>`it; it\\<subseteq>S; it'\\<subseteq>S'; \\<Phi>' it' \\<sigma>'; \\<Phi>'' it \\<sigma> it' \\<sigma>'; (\\<sigma>,\\<sigma>')\\<in>R\n  \\<rbrakk> \\<Longrightarrow> \\<Phi> it \\<sigma>\"\n  assumes REFSTEP: \"\\<And>x it \\<sigma> x' it' \\<sigma>'. \\<lbrakk>\\<forall>y\\<in>it-{x}. RR x y; \n    x'=\\<alpha> x; x\\<in>it; x'\\<in>it'; it'=\\<alpha>`it; it\\<subseteq>S; it'\\<subseteq>S';\n    \\<Phi> it \\<sigma>; \\<Phi>' it' \\<sigma>';  \\<Phi>'' it \\<sigma> it' \\<sigma>'; (\\<sigma>,\\<sigma>')\\<in>R\n  \\<rbrakk> \\<Longrightarrow> f x \\<sigma> \n    \\<le> \\<Down>({(\\<sigma>, \\<sigma>'). (\\<sigma>, \\<sigma>') \\<in> R \\<and> \\<Phi>'' (it - {x}) \\<sigma> (it' - {x'}) \\<sigma>'}) (f' x' \\<sigma>')\"\n  shows \"FOREACHoi RR \\<Phi> S f \\<sigma>0 \\<le> \\<Down>R (FOREACHoi RR' \\<Phi>' S' f' \\<sigma>0')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. FOREACH\\<^sub>O\\<^bsup>RR,\\<Phi>\\<^esup> S f \\<sigma>0\n    \\<le> \\<Down> R\n           (FOREACH\\<^sub>O\\<^bsup>RR',\\<Phi>'\\<^esup> S' f' \\<sigma>0')", "unfolding FOREACHoi_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. FOREACH\\<^sub>O\\<^sub>C\\<^bsup>RR,\\<Phi>\\<^esup> S (\\<lambda>_. True) f\n     \\<sigma>0\n    \\<le> \\<Down> R\n           (FOREACH\\<^sub>O\\<^sub>C\\<^bsup>RR',\\<Phi>'\\<^esup> S'\n             (\\<lambda>_. True) f' \\<sigma>0')", "apply (rule FOREACHoci_refine [of \\<alpha> _ _ _ _ _ _ _ \\<Phi>''])"], ["proof (prove)\ngoal (8 subgoals):\n 1. inj_on \\<alpha> S\n 2. S' = \\<alpha> ` S\n 3. (\\<sigma>0, \\<sigma>0') \\<in> R\n 4. \\<And>x y.\n       \\<lbrakk>x \\<in> S; y \\<in> S; RR x y\\<rbrakk>\n       \\<Longrightarrow> RR' (\\<alpha> x) (\\<alpha> y)\n 5. \\<Phi>'' S \\<sigma>0 (\\<alpha> ` S) \\<sigma>0'\n 6. \\<And>it \\<sigma> it' \\<sigma>'.\n       \\<lbrakk>it' = \\<alpha> ` it; it \\<subseteq> S; it' \\<subseteq> S';\n        \\<Phi>' it' \\<sigma>'; \\<Phi>'' it \\<sigma> it' \\<sigma>';\n        \\<Phi> it \\<sigma>; (\\<sigma>, \\<sigma>') \\<in> R\\<rbrakk>\n       \\<Longrightarrow> True = True\n 7. \\<And>it \\<sigma> it' \\<sigma>'.\n       \\<lbrakk>it' = \\<alpha> ` it; it \\<subseteq> S; it' \\<subseteq> S';\n        \\<Phi>' it' \\<sigma>'; \\<Phi>'' it \\<sigma> it' \\<sigma>';\n        (\\<sigma>, \\<sigma>') \\<in> R\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> it \\<sigma>\n 8. \\<And>x it \\<sigma> x' it' \\<sigma>'.\n       \\<lbrakk>\\<forall>y\\<in>it - {x}. RR x y; x' = \\<alpha> x;\n        x \\<in> it; x' \\<in> it'; it' = \\<alpha> ` it; it \\<subseteq> S;\n        it' \\<subseteq> S'; \\<Phi> it \\<sigma>; \\<Phi>' it' \\<sigma>';\n        \\<Phi>'' it \\<sigma> it' \\<sigma>'; True; True;\n        (\\<sigma>, \\<sigma>') \\<in> R\\<rbrakk>\n       \\<Longrightarrow> f x \\<sigma>\n                         \\<le> \\<Down>\n                                {(\\<sigma>, \\<sigma>').\n                                 (\\<sigma>, \\<sigma>') \\<in> R \\<and>\n                                 \\<Phi>'' (it - {x}) \\<sigma> (it' - {x'})\n                                  \\<sigma>'}\n                                (f' x' \\<sigma>')", "apply (simp_all add: assms)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma FOREACHoi_refine_rcg[refine]:\n  fixes \\<alpha> :: \"'S \\<Rightarrow> 'Sa\"\n  fixes S :: \"'S set\"\n  fixes S' :: \"'Sa set\"\n  assumes INJ: \"inj_on \\<alpha> S\"\n  assumes REFS: \"S' = \\<alpha>`S\"\n  assumes REF0: \"(\\<sigma>0,\\<sigma>0')\\<in>R\"\n  assumes RR_OK: \"\\<And>x y. \\<lbrakk>x \\<in> S; y \\<in> S; RR x y\\<rbrakk> \\<Longrightarrow> RR' (\\<alpha> x) (\\<alpha> y)\"\n  assumes REFPHI: \"\\<And>it \\<sigma> it' \\<sigma>'. \\<lbrakk> \n    it'=\\<alpha>`it; it\\<subseteq>S; it'\\<subseteq>S'; \\<Phi>' it' \\<sigma>'; (\\<sigma>,\\<sigma>')\\<in>R\n  \\<rbrakk> \\<Longrightarrow> \\<Phi> it \\<sigma>\"\n  assumes REFSTEP: \"\\<And>x it \\<sigma> x' it' \\<sigma>'. \\<lbrakk> \\<forall>y\\<in>it-{x}. RR x y;\n    x'=\\<alpha> x; x\\<in>it; x'\\<in>it'; it'=\\<alpha>`it; it\\<subseteq>S; it'\\<subseteq>S';\n    \\<Phi> it \\<sigma>; \\<Phi>' it' \\<sigma>'; (\\<sigma>,\\<sigma>')\\<in>R\n  \\<rbrakk> \\<Longrightarrow> f x \\<sigma> \\<le> \\<Down>R (f' x' \\<sigma>')\"\n  shows \"FOREACHoi RR \\<Phi> S f \\<sigma>0 \\<le> \\<Down>R (FOREACHoi RR' \\<Phi>' S' f' \\<sigma>0')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. FOREACH\\<^sub>O\\<^bsup>RR,\\<Phi>\\<^esup> S f \\<sigma>0\n    \\<le> \\<Down> R\n           (FOREACH\\<^sub>O\\<^bsup>RR',\\<Phi>'\\<^esup> S' f' \\<sigma>0')", "apply (rule FOREACHoi_refine[where \\<Phi>''=\"\\<lambda>_ _ _ _. True\"])"], ["proof (prove)\ngoal (7 subgoals):\n 1. inj_on ?\\<alpha> S\n 2. S' = ?\\<alpha> ` S\n 3. (\\<sigma>0, \\<sigma>0') \\<in> R\n 4. \\<And>x y.\n       \\<lbrakk>x \\<in> S; y \\<in> S; RR x y\\<rbrakk>\n       \\<Longrightarrow> RR' (?\\<alpha> x) (?\\<alpha> y)\n 5. True\n 6. \\<And>it \\<sigma> it' \\<sigma>'.\n       \\<lbrakk>it' = ?\\<alpha> ` it; it \\<subseteq> S; it' \\<subseteq> S';\n        \\<Phi>' it' \\<sigma>'; True; (\\<sigma>, \\<sigma>') \\<in> R\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> it \\<sigma>\n 7. \\<And>x it \\<sigma> x' it' \\<sigma>'.\n       \\<lbrakk>\\<forall>y\\<in>it - {x}. RR x y; x' = ?\\<alpha> x;\n        x \\<in> it; x' \\<in> it'; it' = ?\\<alpha> ` it; it \\<subseteq> S;\n        it' \\<subseteq> S'; \\<Phi> it \\<sigma>; \\<Phi>' it' \\<sigma>'; True;\n        (\\<sigma>, \\<sigma>') \\<in> R\\<rbrakk>\n       \\<Longrightarrow> f x \\<sigma>\n                         \\<le> \\<Down>\n                                {(\\<sigma>, \\<sigma>').\n                                 (\\<sigma>, \\<sigma>') \\<in> R \\<and> True}\n                                (f' x' \\<sigma>')", "apply (rule assms)+"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> S; y \\<in> S; RR x y\\<rbrakk>\n       \\<Longrightarrow> x \\<in> S\n 2. \\<And>x y.\n       \\<lbrakk>x \\<in> S; y \\<in> S; RR x y\\<rbrakk>\n       \\<Longrightarrow> y \\<in> S\n 3. \\<And>x y.\n       \\<lbrakk>x \\<in> S; y \\<in> S; RR x y\\<rbrakk>\n       \\<Longrightarrow> RR x y\n 4. True\n 5. \\<And>it \\<sigma> it' \\<sigma>'.\n       \\<lbrakk>it' = \\<alpha> ` it; it \\<subseteq> S; it' \\<subseteq> S';\n        \\<Phi>' it' \\<sigma>'; True; (\\<sigma>, \\<sigma>') \\<in> R\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> it \\<sigma>\n 6. \\<And>x it \\<sigma> x' it' \\<sigma>'.\n       \\<lbrakk>\\<forall>y\\<in>it - {x}. RR x y; x' = \\<alpha> x;\n        x \\<in> it; x' \\<in> it'; it' = \\<alpha> ` it; it \\<subseteq> S;\n        it' \\<subseteq> S'; \\<Phi> it \\<sigma>; \\<Phi>' it' \\<sigma>'; True;\n        (\\<sigma>, \\<sigma>') \\<in> R\\<rbrakk>\n       \\<Longrightarrow> f x \\<sigma>\n                         \\<le> \\<Down>\n                                {(\\<sigma>, \\<sigma>').\n                                 (\\<sigma>, \\<sigma>') \\<in> R \\<and> True}\n                                (f' x' \\<sigma>')", "using assms"], ["proof (prove)\nusing this:\n  inj_on \\<alpha> S\n  S' = \\<alpha> ` S\n  (\\<sigma>0, \\<sigma>0') \\<in> R\n  \\<lbrakk>?x \\<in> S; ?y \\<in> S; RR ?x ?y\\<rbrakk>\n  \\<Longrightarrow> RR' (\\<alpha> ?x) (\\<alpha> ?y)\n  \\<lbrakk>?it' = \\<alpha> ` ?it; ?it \\<subseteq> S; ?it' \\<subseteq> S';\n   \\<Phi>' ?it' ?\\<sigma>'; (?\\<sigma>, ?\\<sigma>') \\<in> R\\<rbrakk>\n  \\<Longrightarrow> \\<Phi> ?it ?\\<sigma>\n  \\<lbrakk>\\<forall>y\\<in>?it - {?x}. RR ?x y; ?x' = \\<alpha> ?x;\n   ?x \\<in> ?it; ?x' \\<in> ?it'; ?it' = \\<alpha> ` ?it; ?it \\<subseteq> S;\n   ?it' \\<subseteq> S'; \\<Phi> ?it ?\\<sigma>; \\<Phi>' ?it' ?\\<sigma>';\n   (?\\<sigma>, ?\\<sigma>') \\<in> R\\<rbrakk>\n  \\<Longrightarrow> f ?x ?\\<sigma> \\<le> \\<Down> R (f' ?x' ?\\<sigma>')\n\ngoal (6 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> S; y \\<in> S; RR x y\\<rbrakk>\n       \\<Longrightarrow> x \\<in> S\n 2. \\<And>x y.\n       \\<lbrakk>x \\<in> S; y \\<in> S; RR x y\\<rbrakk>\n       \\<Longrightarrow> y \\<in> S\n 3. \\<And>x y.\n       \\<lbrakk>x \\<in> S; y \\<in> S; RR x y\\<rbrakk>\n       \\<Longrightarrow> RR x y\n 4. True\n 5. \\<And>it \\<sigma> it' \\<sigma>'.\n       \\<lbrakk>it' = \\<alpha> ` it; it \\<subseteq> S; it' \\<subseteq> S';\n        \\<Phi>' it' \\<sigma>'; True; (\\<sigma>, \\<sigma>') \\<in> R\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> it \\<sigma>\n 6. \\<And>x it \\<sigma> x' it' \\<sigma>'.\n       \\<lbrakk>\\<forall>y\\<in>it - {x}. RR x y; x' = \\<alpha> x;\n        x \\<in> it; x' \\<in> it'; it' = \\<alpha> ` it; it \\<subseteq> S;\n        it' \\<subseteq> S'; \\<Phi> it \\<sigma>; \\<Phi>' it' \\<sigma>'; True;\n        (\\<sigma>, \\<sigma>') \\<in> R\\<rbrakk>\n       \\<Longrightarrow> f x \\<sigma>\n                         \\<le> \\<Down>\n                                {(\\<sigma>, \\<sigma>').\n                                 (\\<sigma>, \\<sigma>') \\<in> R \\<and> True}\n                                (f' x' \\<sigma>')", "by simp_all"], ["", "lemma FOREACHci_refine_genR:\n  fixes \\<alpha> :: \"'S \\<Rightarrow> 'Sa\" \\<comment> \\<open>Abstraction mapping of elements\\<close>\n  fixes S :: \"'S set\" \\<comment> \\<open>Concrete set\\<close>\n  fixes S' :: \"'Sa set\" \\<comment> \\<open>Abstract set\\<close>\n  fixes \\<sigma>0 :: \"'\\<sigma>\"\n  fixes \\<sigma>0' :: \"'\\<sigma>a\"\n  fixes R :: \"(('S set \\<times> '\\<sigma>) \\<times> ('Sa set \\<times> '\\<sigma>a)) set\"\n  assumes INJ: \"inj_on \\<alpha> S\" \n  assumes REFS[simp]: \"S' = \\<alpha>`S\"\n  assumes REF0: \"((S,\\<sigma>0),(\\<alpha>`S,\\<sigma>0')) \\<in> R\"\n  assumes REFC: \"\\<And>it \\<sigma> it' \\<sigma>'. \\<lbrakk> \n    it\\<subseteq>S; it'\\<subseteq>S'; \\<Phi>' it' \\<sigma>'; \\<Phi> it \\<sigma>; \n    it'=\\<alpha>`it; ((it,\\<sigma>),(it',\\<sigma>'))\\<in>R\n  \\<rbrakk> \\<Longrightarrow> c \\<sigma> \\<longleftrightarrow> c' \\<sigma>'\"\n  assumes REFPHI: \"\\<And>it \\<sigma> it' \\<sigma>'. \\<lbrakk> \n    it\\<subseteq>S; it'\\<subseteq>S'; \\<Phi>' it' \\<sigma>';\n    it'=\\<alpha>`it; ((it,\\<sigma>),(it',\\<sigma>'))\\<in>R\n  \\<rbrakk> \\<Longrightarrow> \\<Phi> it \\<sigma>\"\n  assumes REFSTEP: \"\\<And>x it \\<sigma> x' it' \\<sigma>'. \\<lbrakk>\n    it\\<subseteq>S; it'\\<subseteq>S'; \\<Phi> it \\<sigma>; \\<Phi>' it' \\<sigma>';\n    x'=\\<alpha> x; it'=\\<alpha>`it; ((it,\\<sigma>),(it',\\<sigma>'))\\<in>R;\n    x\\<in>it; x'\\<in>it';\n    c \\<sigma>; c' \\<sigma>'\n  \\<rbrakk> \\<Longrightarrow> f x \\<sigma> \n    \\<le> \\<Down>({(\\<sigma>, \\<sigma>'). ((it-{x},\\<sigma>),(it'-{x'},\\<sigma>'))\\<in>R}) (f' x' \\<sigma>')\"\n  assumes REF_R_DONE: \"\\<And>\\<sigma> \\<sigma>'. \\<lbrakk> \\<Phi> {} \\<sigma>; \\<Phi>' {} \\<sigma>'; (({},\\<sigma>),({},\\<sigma>'))\\<in>R \\<rbrakk> \n    \\<Longrightarrow> (\\<sigma>,\\<sigma>')\\<in>R'\"\n  assumes REF_R_BRK: \"\\<And>it \\<sigma> it' \\<sigma>'. \\<lbrakk> \n    it\\<subseteq>S; it'\\<subseteq>S'; \\<Phi> it \\<sigma>; \\<Phi>' it' \\<sigma>';\n    it'=\\<alpha>`it; ((it,\\<sigma>),(it',\\<sigma>'))\\<in>R;\n    it\\<noteq>{}; it'\\<noteq>{};\n    \\<not>c \\<sigma>; \\<not>c' \\<sigma>'\n  \\<rbrakk> \\<Longrightarrow> (\\<sigma>,\\<sigma>')\\<in>R'\"\n  shows \"FOREACHci \\<Phi> S c f \\<sigma>0 \\<le> \\<Down>R' (FOREACHci \\<Phi>' S' c' f' \\<sigma>0')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. FOREACH\\<^sub>C\\<^bsup>\\<Phi>\\<^esup> S c f \\<sigma>0\n    \\<le> \\<Down> R'\n           (FOREACH\\<^sub>C\\<^bsup>\\<Phi>'\\<^esup> S' c' f' \\<sigma>0')", "unfolding FOREACHci_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. FOREACH\\<^sub>O\\<^sub>C\\<^bsup>\\<lambda>_ _. True,\\<Phi>\\<^esup> S c f\n     \\<sigma>0\n    \\<le> \\<Down> R'\n           (FOREACH\\<^sub>O\\<^sub>C\\<^bsup>\\<lambda>_ _.\n        True,\\<Phi>'\\<^esup>\n             S' c' f' \\<sigma>0')", "apply (rule FOREACHoci_refine_genR)"], ["proof (prove)\ngoal (9 subgoals):\n 1. inj_on ?\\<alpha> S\n 2. S' = ?\\<alpha> ` S\n 3. \\<And>x y.\n       \\<lbrakk>x \\<in> S; y \\<in> S; True\\<rbrakk> \\<Longrightarrow> True\n 4. ((S, \\<sigma>0), ?\\<alpha> ` S, \\<sigma>0') \\<in> ?R\n 5. \\<And>it \\<sigma> it' \\<sigma>'.\n       \\<lbrakk>it \\<subseteq> S; it' \\<subseteq> S'; \\<Phi>' it' \\<sigma>';\n        \\<Phi> it \\<sigma>; \\<forall>x\\<in>S - it. \\<forall>y\\<in>it. True;\n        \\<forall>x\\<in>S' - it'. \\<forall>y\\<in>it'. True;\n        it' = ?\\<alpha> ` it;\n        ((it, \\<sigma>), it', \\<sigma>') \\<in> ?R\\<rbrakk>\n       \\<Longrightarrow> c \\<sigma> = c' \\<sigma>'\n 6. \\<And>it \\<sigma> it' \\<sigma>'.\n       \\<lbrakk>it \\<subseteq> S; it' \\<subseteq> S'; \\<Phi>' it' \\<sigma>';\n        \\<forall>x\\<in>S - it. \\<forall>y\\<in>it. True;\n        \\<forall>x\\<in>S' - it'. \\<forall>y\\<in>it'. True;\n        it' = ?\\<alpha> ` it;\n        ((it, \\<sigma>), it', \\<sigma>') \\<in> ?R\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> it \\<sigma>\n 7. \\<And>x it \\<sigma> x' it' \\<sigma>'.\n       \\<lbrakk>it \\<subseteq> S; it' \\<subseteq> S'; \\<Phi> it \\<sigma>;\n        \\<Phi>' it' \\<sigma>';\n        \\<forall>x\\<in>S - it. \\<forall>y\\<in>it. True;\n        \\<forall>x\\<in>S' - it'. \\<forall>y\\<in>it'. True; x' = ?\\<alpha> x;\n        it' = ?\\<alpha> ` it; ((it, \\<sigma>), it', \\<sigma>') \\<in> ?R;\n        x \\<in> it; \\<forall>y\\<in>it - {x}. True; x' \\<in> it';\n        \\<forall>y'\\<in>it' - {x'}. True; c \\<sigma>; c' \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> f x \\<sigma>\n                         \\<le> \\<Down>\n                                {(\\<sigma>, \\<sigma>').\n                                 ((it - {x}, \\<sigma>), it' - {x'},\n                                  \\<sigma>')\n                                 \\<in> ?R}\n                                (f' x' \\<sigma>')\n 8. \\<And>\\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<Phi> {} \\<sigma>; \\<Phi>' {} \\<sigma>';\n        (({}, \\<sigma>), {}, \\<sigma>') \\<in> ?R\\<rbrakk>\n       \\<Longrightarrow> (\\<sigma>, \\<sigma>') \\<in> R'\n 9. \\<And>it \\<sigma> it' \\<sigma>'.\n       \\<lbrakk>it \\<subseteq> S; it' \\<subseteq> S'; \\<Phi> it \\<sigma>;\n        \\<Phi>' it' \\<sigma>';\n        \\<forall>x\\<in>S - it. \\<forall>y\\<in>it. True;\n        \\<forall>x\\<in>S' - it'. \\<forall>y\\<in>it'. True;\n        it' = ?\\<alpha> ` it; ((it, \\<sigma>), it', \\<sigma>') \\<in> ?R;\n        it \\<noteq> {}; it' \\<noteq> {}; \\<not> c \\<sigma>;\n        \\<not> c' \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> (\\<sigma>, \\<sigma>') \\<in> R'", "apply (fact|simp)+"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>it \\<sigma> it' \\<sigma>'.\n       \\<lbrakk>it \\<subseteq> S; \\<alpha> ` it \\<subseteq> \\<alpha> ` S;\n        \\<Phi>' (\\<alpha> ` it) \\<sigma>'; \\<Phi> it \\<sigma>;\n        it' = \\<alpha> ` it;\n        ((it, \\<sigma>), \\<alpha> ` it, \\<sigma>') \\<in> R\\<rbrakk>\n       \\<Longrightarrow> c \\<sigma> = c' \\<sigma>'\n 2. \\<And>it \\<sigma> it' \\<sigma>'.\n       \\<lbrakk>it \\<subseteq> S; it' \\<subseteq> S'; \\<Phi>' it' \\<sigma>';\n        \\<forall>x\\<in>S - it. \\<forall>y\\<in>it. True;\n        \\<forall>x\\<in>S' - it'. \\<forall>y\\<in>it'. True;\n        it' = \\<alpha> ` it;\n        ((it, \\<sigma>), it', \\<sigma>') \\<in> R\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> it \\<sigma>\n 3. \\<And>x it \\<sigma> x' it' \\<sigma>'.\n       \\<lbrakk>it \\<subseteq> S; it' \\<subseteq> S'; \\<Phi> it \\<sigma>;\n        \\<Phi>' it' \\<sigma>';\n        \\<forall>x\\<in>S - it. \\<forall>y\\<in>it. True;\n        \\<forall>x\\<in>S' - it'. \\<forall>y\\<in>it'. True; x' = \\<alpha> x;\n        it' = \\<alpha> ` it; ((it, \\<sigma>), it', \\<sigma>') \\<in> R;\n        x \\<in> it; \\<forall>y\\<in>it - {x}. True; x' \\<in> it';\n        \\<forall>y'\\<in>it' - {x'}. True; c \\<sigma>; c' \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> f x \\<sigma>\n                         \\<le> \\<Down>\n                                {(\\<sigma>, \\<sigma>').\n                                 ((it - {x}, \\<sigma>), it' - {x'},\n                                  \\<sigma>')\n                                 \\<in> R}\n                                (f' x' \\<sigma>')\n 4. \\<And>\\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<Phi> {} \\<sigma>; \\<Phi>' {} \\<sigma>';\n        (({}, \\<sigma>), {}, \\<sigma>') \\<in> R\\<rbrakk>\n       \\<Longrightarrow> (\\<sigma>, \\<sigma>') \\<in> R'\n 5. \\<And>it \\<sigma> it' \\<sigma>'.\n       \\<lbrakk>it \\<subseteq> S; it' \\<subseteq> S'; \\<Phi> it \\<sigma>;\n        \\<Phi>' it' \\<sigma>';\n        \\<forall>x\\<in>S - it. \\<forall>y\\<in>it. True;\n        \\<forall>x\\<in>S' - it'. \\<forall>y\\<in>it'. True;\n        it' = \\<alpha> ` it; ((it, \\<sigma>), it', \\<sigma>') \\<in> R;\n        it \\<noteq> {}; it' \\<noteq> {}; \\<not> c \\<sigma>;\n        \\<not> c' \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> (\\<sigma>, \\<sigma>') \\<in> R'", "using REFC"], ["proof (prove)\nusing this:\n  \\<lbrakk>?it \\<subseteq> S; ?it' \\<subseteq> S'; \\<Phi>' ?it' ?\\<sigma>';\n   \\<Phi> ?it ?\\<sigma>; ?it' = \\<alpha> ` ?it;\n   ((?it, ?\\<sigma>), ?it', ?\\<sigma>') \\<in> R\\<rbrakk>\n  \\<Longrightarrow> c ?\\<sigma> = c' ?\\<sigma>'\n\ngoal (5 subgoals):\n 1. \\<And>it \\<sigma> it' \\<sigma>'.\n       \\<lbrakk>it \\<subseteq> S; \\<alpha> ` it \\<subseteq> \\<alpha> ` S;\n        \\<Phi>' (\\<alpha> ` it) \\<sigma>'; \\<Phi> it \\<sigma>;\n        it' = \\<alpha> ` it;\n        ((it, \\<sigma>), \\<alpha> ` it, \\<sigma>') \\<in> R\\<rbrakk>\n       \\<Longrightarrow> c \\<sigma> = c' \\<sigma>'\n 2. \\<And>it \\<sigma> it' \\<sigma>'.\n       \\<lbrakk>it \\<subseteq> S; it' \\<subseteq> S'; \\<Phi>' it' \\<sigma>';\n        \\<forall>x\\<in>S - it. \\<forall>y\\<in>it. True;\n        \\<forall>x\\<in>S' - it'. \\<forall>y\\<in>it'. True;\n        it' = \\<alpha> ` it;\n        ((it, \\<sigma>), it', \\<sigma>') \\<in> R\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> it \\<sigma>\n 3. \\<And>x it \\<sigma> x' it' \\<sigma>'.\n       \\<lbrakk>it \\<subseteq> S; it' \\<subseteq> S'; \\<Phi> it \\<sigma>;\n        \\<Phi>' it' \\<sigma>';\n        \\<forall>x\\<in>S - it. \\<forall>y\\<in>it. True;\n        \\<forall>x\\<in>S' - it'. \\<forall>y\\<in>it'. True; x' = \\<alpha> x;\n        it' = \\<alpha> ` it; ((it, \\<sigma>), it', \\<sigma>') \\<in> R;\n        x \\<in> it; \\<forall>y\\<in>it - {x}. True; x' \\<in> it';\n        \\<forall>y'\\<in>it' - {x'}. True; c \\<sigma>; c' \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> f x \\<sigma>\n                         \\<le> \\<Down>\n                                {(\\<sigma>, \\<sigma>').\n                                 ((it - {x}, \\<sigma>), it' - {x'},\n                                  \\<sigma>')\n                                 \\<in> R}\n                                (f' x' \\<sigma>')\n 4. \\<And>\\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<Phi> {} \\<sigma>; \\<Phi>' {} \\<sigma>';\n        (({}, \\<sigma>), {}, \\<sigma>') \\<in> R\\<rbrakk>\n       \\<Longrightarrow> (\\<sigma>, \\<sigma>') \\<in> R'\n 5. \\<And>it \\<sigma> it' \\<sigma>'.\n       \\<lbrakk>it \\<subseteq> S; it' \\<subseteq> S'; \\<Phi> it \\<sigma>;\n        \\<Phi>' it' \\<sigma>';\n        \\<forall>x\\<in>S - it. \\<forall>y\\<in>it. True;\n        \\<forall>x\\<in>S' - it'. \\<forall>y\\<in>it'. True;\n        it' = \\<alpha> ` it; ((it, \\<sigma>), it', \\<sigma>') \\<in> R;\n        it \\<noteq> {}; it' \\<noteq> {}; \\<not> c \\<sigma>;\n        \\<not> c' \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> (\\<sigma>, \\<sigma>') \\<in> R'", "apply auto []"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>it \\<sigma> it' \\<sigma>'.\n       \\<lbrakk>it \\<subseteq> S; it' \\<subseteq> S'; \\<Phi>' it' \\<sigma>';\n        \\<forall>x\\<in>S - it. \\<forall>y\\<in>it. True;\n        \\<forall>x\\<in>S' - it'. \\<forall>y\\<in>it'. True;\n        it' = \\<alpha> ` it;\n        ((it, \\<sigma>), it', \\<sigma>') \\<in> R\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> it \\<sigma>\n 2. \\<And>x it \\<sigma> x' it' \\<sigma>'.\n       \\<lbrakk>it \\<subseteq> S; it' \\<subseteq> S'; \\<Phi> it \\<sigma>;\n        \\<Phi>' it' \\<sigma>';\n        \\<forall>x\\<in>S - it. \\<forall>y\\<in>it. True;\n        \\<forall>x\\<in>S' - it'. \\<forall>y\\<in>it'. True; x' = \\<alpha> x;\n        it' = \\<alpha> ` it; ((it, \\<sigma>), it', \\<sigma>') \\<in> R;\n        x \\<in> it; \\<forall>y\\<in>it - {x}. True; x' \\<in> it';\n        \\<forall>y'\\<in>it' - {x'}. True; c \\<sigma>; c' \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> f x \\<sigma>\n                         \\<le> \\<Down>\n                                {(\\<sigma>, \\<sigma>').\n                                 ((it - {x}, \\<sigma>), it' - {x'},\n                                  \\<sigma>')\n                                 \\<in> R}\n                                (f' x' \\<sigma>')\n 3. \\<And>\\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<Phi> {} \\<sigma>; \\<Phi>' {} \\<sigma>';\n        (({}, \\<sigma>), {}, \\<sigma>') \\<in> R\\<rbrakk>\n       \\<Longrightarrow> (\\<sigma>, \\<sigma>') \\<in> R'\n 4. \\<And>it \\<sigma> it' \\<sigma>'.\n       \\<lbrakk>it \\<subseteq> S; it' \\<subseteq> S'; \\<Phi> it \\<sigma>;\n        \\<Phi>' it' \\<sigma>';\n        \\<forall>x\\<in>S - it. \\<forall>y\\<in>it. True;\n        \\<forall>x\\<in>S' - it'. \\<forall>y\\<in>it'. True;\n        it' = \\<alpha> ` it; ((it, \\<sigma>), it', \\<sigma>') \\<in> R;\n        it \\<noteq> {}; it' \\<noteq> {}; \\<not> c \\<sigma>;\n        \\<not> c' \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> (\\<sigma>, \\<sigma>') \\<in> R'", "using REFPHI"], ["proof (prove)\nusing this:\n  \\<lbrakk>?it \\<subseteq> S; ?it' \\<subseteq> S'; \\<Phi>' ?it' ?\\<sigma>';\n   ?it' = \\<alpha> ` ?it;\n   ((?it, ?\\<sigma>), ?it', ?\\<sigma>') \\<in> R\\<rbrakk>\n  \\<Longrightarrow> \\<Phi> ?it ?\\<sigma>\n\ngoal (4 subgoals):\n 1. \\<And>it \\<sigma> it' \\<sigma>'.\n       \\<lbrakk>it \\<subseteq> S; it' \\<subseteq> S'; \\<Phi>' it' \\<sigma>';\n        \\<forall>x\\<in>S - it. \\<forall>y\\<in>it. True;\n        \\<forall>x\\<in>S' - it'. \\<forall>y\\<in>it'. True;\n        it' = \\<alpha> ` it;\n        ((it, \\<sigma>), it', \\<sigma>') \\<in> R\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> it \\<sigma>\n 2. \\<And>x it \\<sigma> x' it' \\<sigma>'.\n       \\<lbrakk>it \\<subseteq> S; it' \\<subseteq> S'; \\<Phi> it \\<sigma>;\n        \\<Phi>' it' \\<sigma>';\n        \\<forall>x\\<in>S - it. \\<forall>y\\<in>it. True;\n        \\<forall>x\\<in>S' - it'. \\<forall>y\\<in>it'. True; x' = \\<alpha> x;\n        it' = \\<alpha> ` it; ((it, \\<sigma>), it', \\<sigma>') \\<in> R;\n        x \\<in> it; \\<forall>y\\<in>it - {x}. True; x' \\<in> it';\n        \\<forall>y'\\<in>it' - {x'}. True; c \\<sigma>; c' \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> f x \\<sigma>\n                         \\<le> \\<Down>\n                                {(\\<sigma>, \\<sigma>').\n                                 ((it - {x}, \\<sigma>), it' - {x'},\n                                  \\<sigma>')\n                                 \\<in> R}\n                                (f' x' \\<sigma>')\n 3. \\<And>\\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<Phi> {} \\<sigma>; \\<Phi>' {} \\<sigma>';\n        (({}, \\<sigma>), {}, \\<sigma>') \\<in> R\\<rbrakk>\n       \\<Longrightarrow> (\\<sigma>, \\<sigma>') \\<in> R'\n 4. \\<And>it \\<sigma> it' \\<sigma>'.\n       \\<lbrakk>it \\<subseteq> S; it' \\<subseteq> S'; \\<Phi> it \\<sigma>;\n        \\<Phi>' it' \\<sigma>';\n        \\<forall>x\\<in>S - it. \\<forall>y\\<in>it. True;\n        \\<forall>x\\<in>S' - it'. \\<forall>y\\<in>it'. True;\n        it' = \\<alpha> ` it; ((it, \\<sigma>), it', \\<sigma>') \\<in> R;\n        it \\<noteq> {}; it' \\<noteq> {}; \\<not> c \\<sigma>;\n        \\<not> c' \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> (\\<sigma>, \\<sigma>') \\<in> R'", "apply auto []"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x it \\<sigma> x' it' \\<sigma>'.\n       \\<lbrakk>it \\<subseteq> S; it' \\<subseteq> S'; \\<Phi> it \\<sigma>;\n        \\<Phi>' it' \\<sigma>';\n        \\<forall>x\\<in>S - it. \\<forall>y\\<in>it. True;\n        \\<forall>x\\<in>S' - it'. \\<forall>y\\<in>it'. True; x' = \\<alpha> x;\n        it' = \\<alpha> ` it; ((it, \\<sigma>), it', \\<sigma>') \\<in> R;\n        x \\<in> it; \\<forall>y\\<in>it - {x}. True; x' \\<in> it';\n        \\<forall>y'\\<in>it' - {x'}. True; c \\<sigma>; c' \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> f x \\<sigma>\n                         \\<le> \\<Down>\n                                {(\\<sigma>, \\<sigma>').\n                                 ((it - {x}, \\<sigma>), it' - {x'},\n                                  \\<sigma>')\n                                 \\<in> R}\n                                (f' x' \\<sigma>')\n 2. \\<And>\\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<Phi> {} \\<sigma>; \\<Phi>' {} \\<sigma>';\n        (({}, \\<sigma>), {}, \\<sigma>') \\<in> R\\<rbrakk>\n       \\<Longrightarrow> (\\<sigma>, \\<sigma>') \\<in> R'\n 3. \\<And>it \\<sigma> it' \\<sigma>'.\n       \\<lbrakk>it \\<subseteq> S; it' \\<subseteq> S'; \\<Phi> it \\<sigma>;\n        \\<Phi>' it' \\<sigma>';\n        \\<forall>x\\<in>S - it. \\<forall>y\\<in>it. True;\n        \\<forall>x\\<in>S' - it'. \\<forall>y\\<in>it'. True;\n        it' = \\<alpha> ` it; ((it, \\<sigma>), it', \\<sigma>') \\<in> R;\n        it \\<noteq> {}; it' \\<noteq> {}; \\<not> c \\<sigma>;\n        \\<not> c' \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> (\\<sigma>, \\<sigma>') \\<in> R'", "using REFSTEP"], ["proof (prove)\nusing this:\n  \\<lbrakk>?it \\<subseteq> S; ?it' \\<subseteq> S'; \\<Phi> ?it ?\\<sigma>;\n   \\<Phi>' ?it' ?\\<sigma>'; ?x' = \\<alpha> ?x; ?it' = \\<alpha> ` ?it;\n   ((?it, ?\\<sigma>), ?it', ?\\<sigma>') \\<in> R; ?x \\<in> ?it;\n   ?x' \\<in> ?it'; c ?\\<sigma>; c' ?\\<sigma>'\\<rbrakk>\n  \\<Longrightarrow> f ?x ?\\<sigma>\n                    \\<le> \\<Down>\n                           {(\\<sigma>, \\<sigma>').\n                            ((?it - {?x}, \\<sigma>), ?it' - {?x'},\n                             \\<sigma>')\n                            \\<in> R}\n                           (f' ?x' ?\\<sigma>')\n\ngoal (3 subgoals):\n 1. \\<And>x it \\<sigma> x' it' \\<sigma>'.\n       \\<lbrakk>it \\<subseteq> S; it' \\<subseteq> S'; \\<Phi> it \\<sigma>;\n        \\<Phi>' it' \\<sigma>';\n        \\<forall>x\\<in>S - it. \\<forall>y\\<in>it. True;\n        \\<forall>x\\<in>S' - it'. \\<forall>y\\<in>it'. True; x' = \\<alpha> x;\n        it' = \\<alpha> ` it; ((it, \\<sigma>), it', \\<sigma>') \\<in> R;\n        x \\<in> it; \\<forall>y\\<in>it - {x}. True; x' \\<in> it';\n        \\<forall>y'\\<in>it' - {x'}. True; c \\<sigma>; c' \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> f x \\<sigma>\n                         \\<le> \\<Down>\n                                {(\\<sigma>, \\<sigma>').\n                                 ((it - {x}, \\<sigma>), it' - {x'},\n                                  \\<sigma>')\n                                 \\<in> R}\n                                (f' x' \\<sigma>')\n 2. \\<And>\\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<Phi> {} \\<sigma>; \\<Phi>' {} \\<sigma>';\n        (({}, \\<sigma>), {}, \\<sigma>') \\<in> R\\<rbrakk>\n       \\<Longrightarrow> (\\<sigma>, \\<sigma>') \\<in> R'\n 3. \\<And>it \\<sigma> it' \\<sigma>'.\n       \\<lbrakk>it \\<subseteq> S; it' \\<subseteq> S'; \\<Phi> it \\<sigma>;\n        \\<Phi>' it' \\<sigma>';\n        \\<forall>x\\<in>S - it. \\<forall>y\\<in>it. True;\n        \\<forall>x\\<in>S' - it'. \\<forall>y\\<in>it'. True;\n        it' = \\<alpha> ` it; ((it, \\<sigma>), it', \\<sigma>') \\<in> R;\n        it \\<noteq> {}; it' \\<noteq> {}; \\<not> c \\<sigma>;\n        \\<not> c' \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> (\\<sigma>, \\<sigma>') \\<in> R'", "apply auto []"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>\\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<Phi> {} \\<sigma>; \\<Phi>' {} \\<sigma>';\n        (({}, \\<sigma>), {}, \\<sigma>') \\<in> R\\<rbrakk>\n       \\<Longrightarrow> (\\<sigma>, \\<sigma>') \\<in> R'\n 2. \\<And>it \\<sigma> it' \\<sigma>'.\n       \\<lbrakk>it \\<subseteq> S; it' \\<subseteq> S'; \\<Phi> it \\<sigma>;\n        \\<Phi>' it' \\<sigma>';\n        \\<forall>x\\<in>S - it. \\<forall>y\\<in>it. True;\n        \\<forall>x\\<in>S' - it'. \\<forall>y\\<in>it'. True;\n        it' = \\<alpha> ` it; ((it, \\<sigma>), it', \\<sigma>') \\<in> R;\n        it \\<noteq> {}; it' \\<noteq> {}; \\<not> c \\<sigma>;\n        \\<not> c' \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> (\\<sigma>, \\<sigma>') \\<in> R'", "apply (fact|simp)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>it \\<sigma> it' \\<sigma>'.\n       \\<lbrakk>it \\<subseteq> S; \\<alpha> ` it \\<subseteq> \\<alpha> ` S;\n        \\<Phi> it \\<sigma>; \\<Phi>' (\\<alpha> ` it) \\<sigma>';\n        it' = \\<alpha> ` it;\n        ((it, \\<sigma>), \\<alpha> ` it, \\<sigma>') \\<in> R; it \\<noteq> {};\n        \\<not> c \\<sigma>; \\<not> c' \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> (\\<sigma>, \\<sigma>') \\<in> R'", "using REF_R_BRK"], ["proof (prove)\nusing this:\n  \\<lbrakk>?it \\<subseteq> S; ?it' \\<subseteq> S'; \\<Phi> ?it ?\\<sigma>;\n   \\<Phi>' ?it' ?\\<sigma>'; ?it' = \\<alpha> ` ?it;\n   ((?it, ?\\<sigma>), ?it', ?\\<sigma>') \\<in> R; ?it \\<noteq> {};\n   ?it' \\<noteq> {}; \\<not> c ?\\<sigma>; \\<not> c' ?\\<sigma>'\\<rbrakk>\n  \\<Longrightarrow> (?\\<sigma>, ?\\<sigma>') \\<in> R'\n\ngoal (1 subgoal):\n 1. \\<And>it \\<sigma> it' \\<sigma>'.\n       \\<lbrakk>it \\<subseteq> S; \\<alpha> ` it \\<subseteq> \\<alpha> ` S;\n        \\<Phi> it \\<sigma>; \\<Phi>' (\\<alpha> ` it) \\<sigma>';\n        it' = \\<alpha> ` it;\n        ((it, \\<sigma>), \\<alpha> ` it, \\<sigma>') \\<in> R; it \\<noteq> {};\n        \\<not> c \\<sigma>; \\<not> c' \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> (\\<sigma>, \\<sigma>') \\<in> R'", "apply auto []"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma FOREACHci_refine:\n  fixes \\<alpha> :: \"'S \\<Rightarrow> 'Sa\"\n  fixes S :: \"'S set\"\n  fixes S' :: \"'Sa set\"\n  assumes INJ: \"inj_on \\<alpha> S\"\n  assumes REFS: \"S' = \\<alpha>`S\"\n  assumes REF0: \"(\\<sigma>0,\\<sigma>0')\\<in>R\"\n  assumes REFPHI0: \"\\<Phi>'' S \\<sigma>0 (\\<alpha>`S) \\<sigma>0'\"\n  assumes REFC: \"\\<And>it \\<sigma> it' \\<sigma>'. \\<lbrakk> \n    it'=\\<alpha>`it; it\\<subseteq>S; it'\\<subseteq>S'; \\<Phi>' it' \\<sigma>';  \\<Phi>'' it \\<sigma> it' \\<sigma>'; \\<Phi> it \\<sigma>; (\\<sigma>,\\<sigma>')\\<in>R\n  \\<rbrakk> \\<Longrightarrow> c \\<sigma> \\<longleftrightarrow> c' \\<sigma>'\"\n  assumes REFPHI: \"\\<And>it \\<sigma> it' \\<sigma>'. \\<lbrakk> \n    it'=\\<alpha>`it; it\\<subseteq>S; it'\\<subseteq>S'; \\<Phi>' it' \\<sigma>'; \\<Phi>'' it \\<sigma> it' \\<sigma>'; (\\<sigma>,\\<sigma>')\\<in>R\n  \\<rbrakk> \\<Longrightarrow> \\<Phi> it \\<sigma>\"\n  assumes REFSTEP: \"\\<And>x it \\<sigma> x' it' \\<sigma>'. \\<lbrakk> \n    x'=\\<alpha> x; x\\<in>it; x'\\<in>it'; it'=\\<alpha>`it; it\\<subseteq>S; it'\\<subseteq>S';\n    \\<Phi> it \\<sigma>; \\<Phi>' it' \\<sigma>';  \\<Phi>'' it \\<sigma> it' \\<sigma>'; c \\<sigma>; c' \\<sigma>';\n    (\\<sigma>,\\<sigma>')\\<in>R\n  \\<rbrakk> \\<Longrightarrow> f x \\<sigma> \n    \\<le> \\<Down>({(\\<sigma>, \\<sigma>'). (\\<sigma>, \\<sigma>') \\<in> R \\<and> \\<Phi>'' (it - {x}) \\<sigma> (it' - {x'}) \\<sigma>'}) (f' x' \\<sigma>')\"\n  shows \"FOREACHci \\<Phi> S c f \\<sigma>0 \\<le> \\<Down>R (FOREACHci \\<Phi>' S' c' f' \\<sigma>0')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. FOREACH\\<^sub>C\\<^bsup>\\<Phi>\\<^esup> S c f \\<sigma>0\n    \\<le> \\<Down> R\n           (FOREACH\\<^sub>C\\<^bsup>\\<Phi>'\\<^esup> S' c' f' \\<sigma>0')", "unfolding FOREACHci_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. FOREACH\\<^sub>O\\<^sub>C\\<^bsup>\\<lambda>_ _. True,\\<Phi>\\<^esup> S c f\n     \\<sigma>0\n    \\<le> \\<Down> R\n           (FOREACH\\<^sub>O\\<^sub>C\\<^bsup>\\<lambda>_ _.\n        True,\\<Phi>'\\<^esup>\n             S' c' f' \\<sigma>0')", "apply (rule FOREACHoci_refine [of \\<alpha> _ _ _ _ _ _ _ \\<Phi>''])"], ["proof (prove)\ngoal (8 subgoals):\n 1. inj_on \\<alpha> S\n 2. S' = \\<alpha> ` S\n 3. (\\<sigma>0, \\<sigma>0') \\<in> R\n 4. \\<And>x y.\n       \\<lbrakk>x \\<in> S; y \\<in> S; True\\<rbrakk> \\<Longrightarrow> True\n 5. \\<Phi>'' S \\<sigma>0 (\\<alpha> ` S) \\<sigma>0'\n 6. \\<And>it \\<sigma> it' \\<sigma>'.\n       \\<lbrakk>it' = \\<alpha> ` it; it \\<subseteq> S; it' \\<subseteq> S';\n        \\<Phi>' it' \\<sigma>'; \\<Phi>'' it \\<sigma> it' \\<sigma>';\n        \\<Phi> it \\<sigma>; (\\<sigma>, \\<sigma>') \\<in> R\\<rbrakk>\n       \\<Longrightarrow> c \\<sigma> = c' \\<sigma>'\n 7. \\<And>it \\<sigma> it' \\<sigma>'.\n       \\<lbrakk>it' = \\<alpha> ` it; it \\<subseteq> S; it' \\<subseteq> S';\n        \\<Phi>' it' \\<sigma>'; \\<Phi>'' it \\<sigma> it' \\<sigma>';\n        (\\<sigma>, \\<sigma>') \\<in> R\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> it \\<sigma>\n 8. \\<And>x it \\<sigma> x' it' \\<sigma>'.\n       \\<lbrakk>\\<forall>y\\<in>it - {x}. True; x' = \\<alpha> x; x \\<in> it;\n        x' \\<in> it'; it' = \\<alpha> ` it; it \\<subseteq> S;\n        it' \\<subseteq> S'; \\<Phi> it \\<sigma>; \\<Phi>' it' \\<sigma>';\n        \\<Phi>'' it \\<sigma> it' \\<sigma>'; c \\<sigma>; c' \\<sigma>';\n        (\\<sigma>, \\<sigma>') \\<in> R\\<rbrakk>\n       \\<Longrightarrow> f x \\<sigma>\n                         \\<le> \\<Down>\n                                {(\\<sigma>, \\<sigma>').\n                                 (\\<sigma>, \\<sigma>') \\<in> R \\<and>\n                                 \\<Phi>'' (it - {x}) \\<sigma> (it' - {x'})\n                                  \\<sigma>'}\n                                (f' x' \\<sigma>')", "apply (simp_all add: assms)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma FOREACHci_refine_rcg[refine]:\n  fixes \\<alpha> :: \"'S \\<Rightarrow> 'Sa\"\n  fixes S :: \"'S set\"\n  fixes S' :: \"'Sa set\"\n  assumes INJ: \"inj_on \\<alpha> S\"\n  assumes REFS: \"S' = \\<alpha>`S\"\n  assumes REF0: \"(\\<sigma>0,\\<sigma>0')\\<in>R\"\n  assumes REFC: \"\\<And>it \\<sigma> it' \\<sigma>'. \\<lbrakk> \n    it'=\\<alpha>`it; it\\<subseteq>S; it'\\<subseteq>S'; \\<Phi>' it' \\<sigma>'; \\<Phi> it \\<sigma>; (\\<sigma>,\\<sigma>')\\<in>R\n  \\<rbrakk> \\<Longrightarrow> c \\<sigma> \\<longleftrightarrow> c' \\<sigma>'\"\n  assumes REFPHI: \"\\<And>it \\<sigma> it' \\<sigma>'. \\<lbrakk> \n    it'=\\<alpha>`it; it\\<subseteq>S; it'\\<subseteq>S'; \\<Phi>' it' \\<sigma>'; (\\<sigma>,\\<sigma>')\\<in>R\n  \\<rbrakk> \\<Longrightarrow> \\<Phi> it \\<sigma>\"\n  assumes REFSTEP: \"\\<And>x it \\<sigma> x' it' \\<sigma>'. \\<lbrakk> \n    x'=\\<alpha> x; x\\<in>it; x'\\<in>it'; it'=\\<alpha>`it; it\\<subseteq>S; it'\\<subseteq>S';\n    \\<Phi> it \\<sigma>; \\<Phi>' it' \\<sigma>'; c \\<sigma>; c' \\<sigma>';\n    (\\<sigma>,\\<sigma>')\\<in>R\n  \\<rbrakk> \\<Longrightarrow> f x \\<sigma> \\<le> \\<Down>R (f' x' \\<sigma>')\"\n  shows \"FOREACHci \\<Phi> S c f \\<sigma>0 \\<le> \\<Down>R (FOREACHci \\<Phi>' S' c' f' \\<sigma>0')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. FOREACH\\<^sub>C\\<^bsup>\\<Phi>\\<^esup> S c f \\<sigma>0\n    \\<le> \\<Down> R\n           (FOREACH\\<^sub>C\\<^bsup>\\<Phi>'\\<^esup> S' c' f' \\<sigma>0')", "apply (rule FOREACHci_refine[where \\<Phi>''=\"\\<lambda>_ _ _ _. True\"])"], ["proof (prove)\ngoal (7 subgoals):\n 1. inj_on ?\\<alpha> S\n 2. S' = ?\\<alpha> ` S\n 3. (\\<sigma>0, \\<sigma>0') \\<in> R\n 4. True\n 5. \\<And>it \\<sigma> it' \\<sigma>'.\n       \\<lbrakk>it' = ?\\<alpha> ` it; it \\<subseteq> S; it' \\<subseteq> S';\n        \\<Phi>' it' \\<sigma>'; True; \\<Phi> it \\<sigma>;\n        (\\<sigma>, \\<sigma>') \\<in> R\\<rbrakk>\n       \\<Longrightarrow> c \\<sigma> = c' \\<sigma>'\n 6. \\<And>it \\<sigma> it' \\<sigma>'.\n       \\<lbrakk>it' = ?\\<alpha> ` it; it \\<subseteq> S; it' \\<subseteq> S';\n        \\<Phi>' it' \\<sigma>'; True; (\\<sigma>, \\<sigma>') \\<in> R\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> it \\<sigma>\n 7. \\<And>x it \\<sigma> x' it' \\<sigma>'.\n       \\<lbrakk>x' = ?\\<alpha> x; x \\<in> it; x' \\<in> it';\n        it' = ?\\<alpha> ` it; it \\<subseteq> S; it' \\<subseteq> S';\n        \\<Phi> it \\<sigma>; \\<Phi>' it' \\<sigma>'; True; c \\<sigma>;\n        c' \\<sigma>'; (\\<sigma>, \\<sigma>') \\<in> R\\<rbrakk>\n       \\<Longrightarrow> f x \\<sigma>\n                         \\<le> \\<Down>\n                                {(\\<sigma>, \\<sigma>').\n                                 (\\<sigma>, \\<sigma>') \\<in> R \\<and> True}\n                                (f' x' \\<sigma>')", "apply (rule assms)+"], ["proof (prove)\ngoal (4 subgoals):\n 1. True\n 2. \\<And>it \\<sigma> it' \\<sigma>'.\n       \\<lbrakk>it' = \\<alpha> ` it; it \\<subseteq> S; it' \\<subseteq> S';\n        \\<Phi>' it' \\<sigma>'; True; \\<Phi> it \\<sigma>;\n        (\\<sigma>, \\<sigma>') \\<in> R\\<rbrakk>\n       \\<Longrightarrow> c \\<sigma> = c' \\<sigma>'\n 3. \\<And>it \\<sigma> it' \\<sigma>'.\n       \\<lbrakk>it' = \\<alpha> ` it; it \\<subseteq> S; it' \\<subseteq> S';\n        \\<Phi>' it' \\<sigma>'; True; (\\<sigma>, \\<sigma>') \\<in> R\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> it \\<sigma>\n 4. \\<And>x it \\<sigma> x' it' \\<sigma>'.\n       \\<lbrakk>x' = \\<alpha> x; x \\<in> it; x' \\<in> it';\n        it' = \\<alpha> ` it; it \\<subseteq> S; it' \\<subseteq> S';\n        \\<Phi> it \\<sigma>; \\<Phi>' it' \\<sigma>'; True; c \\<sigma>;\n        c' \\<sigma>'; (\\<sigma>, \\<sigma>') \\<in> R\\<rbrakk>\n       \\<Longrightarrow> f x \\<sigma>\n                         \\<le> \\<Down>\n                                {(\\<sigma>, \\<sigma>').\n                                 (\\<sigma>, \\<sigma>') \\<in> R \\<and> True}\n                                (f' x' \\<sigma>')", "using assms"], ["proof (prove)\nusing this:\n  inj_on \\<alpha> S\n  S' = \\<alpha> ` S\n  (\\<sigma>0, \\<sigma>0') \\<in> R\n  \\<lbrakk>?it' = \\<alpha> ` ?it; ?it \\<subseteq> S; ?it' \\<subseteq> S';\n   \\<Phi>' ?it' ?\\<sigma>'; \\<Phi> ?it ?\\<sigma>;\n   (?\\<sigma>, ?\\<sigma>') \\<in> R\\<rbrakk>\n  \\<Longrightarrow> c ?\\<sigma> = c' ?\\<sigma>'\n  \\<lbrakk>?it' = \\<alpha> ` ?it; ?it \\<subseteq> S; ?it' \\<subseteq> S';\n   \\<Phi>' ?it' ?\\<sigma>'; (?\\<sigma>, ?\\<sigma>') \\<in> R\\<rbrakk>\n  \\<Longrightarrow> \\<Phi> ?it ?\\<sigma>\n  \\<lbrakk>?x' = \\<alpha> ?x; ?x \\<in> ?it; ?x' \\<in> ?it';\n   ?it' = \\<alpha> ` ?it; ?it \\<subseteq> S; ?it' \\<subseteq> S';\n   \\<Phi> ?it ?\\<sigma>; \\<Phi>' ?it' ?\\<sigma>'; c ?\\<sigma>;\n   c' ?\\<sigma>'; (?\\<sigma>, ?\\<sigma>') \\<in> R\\<rbrakk>\n  \\<Longrightarrow> f ?x ?\\<sigma> \\<le> \\<Down> R (f' ?x' ?\\<sigma>')\n\ngoal (4 subgoals):\n 1. True\n 2. \\<And>it \\<sigma> it' \\<sigma>'.\n       \\<lbrakk>it' = \\<alpha> ` it; it \\<subseteq> S; it' \\<subseteq> S';\n        \\<Phi>' it' \\<sigma>'; True; \\<Phi> it \\<sigma>;\n        (\\<sigma>, \\<sigma>') \\<in> R\\<rbrakk>\n       \\<Longrightarrow> c \\<sigma> = c' \\<sigma>'\n 3. \\<And>it \\<sigma> it' \\<sigma>'.\n       \\<lbrakk>it' = \\<alpha> ` it; it \\<subseteq> S; it' \\<subseteq> S';\n        \\<Phi>' it' \\<sigma>'; True; (\\<sigma>, \\<sigma>') \\<in> R\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> it \\<sigma>\n 4. \\<And>x it \\<sigma> x' it' \\<sigma>'.\n       \\<lbrakk>x' = \\<alpha> x; x \\<in> it; x' \\<in> it';\n        it' = \\<alpha> ` it; it \\<subseteq> S; it' \\<subseteq> S';\n        \\<Phi> it \\<sigma>; \\<Phi>' it' \\<sigma>'; True; c \\<sigma>;\n        c' \\<sigma>'; (\\<sigma>, \\<sigma>') \\<in> R\\<rbrakk>\n       \\<Longrightarrow> f x \\<sigma>\n                         \\<le> \\<Down>\n                                {(\\<sigma>, \\<sigma>').\n                                 (\\<sigma>, \\<sigma>') \\<in> R \\<and> True}\n                                (f' x' \\<sigma>')", "by auto"], ["", "lemma FOREACHci_weaken:\n  assumes IREF: \"\\<And>it \\<sigma>. it\\<subseteq>S \\<Longrightarrow> I it \\<sigma> \\<Longrightarrow> I' it \\<sigma>\"\n  shows \"FOREACHci I' S c f \\<sigma>0 \\<le> FOREACHci I S c f \\<sigma>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. FOREACH\\<^sub>C\\<^bsup>I'\\<^esup> S c f \\<sigma>0\n    \\<le> FOREACH\\<^sub>C\\<^bsup>I\\<^esup> S c f \\<sigma>0", "apply (rule FOREACHci_refine_rcg[where \\<alpha>=id and R=Id, simplified])"], ["proof (prove)\ngoal (5 subgoals):\n 1. S = S\n 2. \\<sigma>0 = \\<sigma>0\n 3. \\<And>it \\<sigma> it' \\<sigma>'.\n       \\<lbrakk>it' = it; it \\<subseteq> S; it' \\<subseteq> S;\n        I it' \\<sigma>'; I' it \\<sigma>; \\<sigma> = \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> c \\<sigma> = c \\<sigma>'\n 4. \\<And>it \\<sigma> it' \\<sigma>'.\n       \\<lbrakk>it' = it; it \\<subseteq> S; it' \\<subseteq> S;\n        I it' \\<sigma>'; \\<sigma> = \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> I' it \\<sigma>\n 5. \\<And>x it \\<sigma> x' it' \\<sigma>'.\n       \\<lbrakk>x' = x; x \\<in> it; x' \\<in> it'; it' = it;\n        it \\<subseteq> S; it' \\<subseteq> S; I' it \\<sigma>;\n        I it' \\<sigma>'; c \\<sigma>; c \\<sigma>';\n        \\<sigma> = \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> f x \\<sigma> \\<le> f x' \\<sigma>'", "apply (auto intro: IREF)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma FOREACHi_rule[refine_vcg]:\n  assumes FIN: \"finite S\"\n  assumes I0: \"I S \\<sigma>0\"\n  assumes IP: \n    \"\\<And>x it \\<sigma>. \\<lbrakk> x\\<in>it; it\\<subseteq>S; I it \\<sigma> \\<rbrakk> \\<Longrightarrow> f x \\<sigma> \\<le> SPEC (I (it-{x}))\"\n  assumes II: \"\\<And>\\<sigma>. \\<lbrakk>I {} \\<sigma>\\<rbrakk> \\<Longrightarrow> P \\<sigma>\"\n  shows \"FOREACHi I S f \\<sigma>0 \\<le> SPEC P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. FOREACH\\<^bsup>I\\<^esup> S f \\<sigma>0 \\<le> SPEC P", "unfolding FOREACHi_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. FOREACH\\<^sub>C\\<^bsup>I\\<^esup> S (\\<lambda>_. True) f \\<sigma>0\n    \\<le> SPEC P", "apply (rule FOREACHci_rule[of S I])"], ["proof (prove)\ngoal (5 subgoals):\n 1. finite S\n 2. I S \\<sigma>0\n 3. \\<And>x it \\<sigma>.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> S; I it \\<sigma>; True\\<rbrakk>\n       \\<Longrightarrow> f x \\<sigma> \\<le> SPEC (I (it - {x}))\n 4. \\<And>\\<sigma>. I {} \\<sigma> \\<Longrightarrow> P \\<sigma>\n 5. \\<And>it \\<sigma>.\n       \\<lbrakk>it \\<noteq> {}; it \\<subseteq> S; I it \\<sigma>;\n        \\<not> True\\<rbrakk>\n       \\<Longrightarrow> P \\<sigma>", "using assms"], ["proof (prove)\nusing this:\n  finite S\n  I S \\<sigma>0\n  \\<lbrakk>?x \\<in> ?it; ?it \\<subseteq> S; I ?it ?\\<sigma>\\<rbrakk>\n  \\<Longrightarrow> f ?x ?\\<sigma> \\<le> SPEC (I (?it - {?x}))\n  I {} ?\\<sigma> \\<Longrightarrow> P ?\\<sigma>\n\ngoal (5 subgoals):\n 1. finite S\n 2. I S \\<sigma>0\n 3. \\<And>x it \\<sigma>.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> S; I it \\<sigma>; True\\<rbrakk>\n       \\<Longrightarrow> f x \\<sigma> \\<le> SPEC (I (it - {x}))\n 4. \\<And>\\<sigma>. I {} \\<sigma> \\<Longrightarrow> P \\<sigma>\n 5. \\<And>it \\<sigma>.\n       \\<lbrakk>it \\<noteq> {}; it \\<subseteq> S; I it \\<sigma>;\n        \\<not> True\\<rbrakk>\n       \\<Longrightarrow> P \\<sigma>", "by auto"], ["", "lemma FOREACHc_rule:\n  assumes FIN: \"finite S\"\n  assumes I0: \"I S \\<sigma>0\"\n  assumes IP: \n    \"\\<And>x it \\<sigma>. \\<lbrakk> x\\<in>it; it\\<subseteq>S; I it \\<sigma>; c \\<sigma> \\<rbrakk> \\<Longrightarrow> f x \\<sigma> \\<le> SPEC (I (it-{x}))\"\n  assumes II1: \"\\<And>\\<sigma>. \\<lbrakk>I {} \\<sigma>\\<rbrakk> \\<Longrightarrow> P \\<sigma>\"\n  assumes II2: \"\\<And>it \\<sigma>. \\<lbrakk> it\\<noteq>{}; it\\<subseteq>S; I it \\<sigma>; \\<not>c \\<sigma> \\<rbrakk> \\<Longrightarrow> P \\<sigma>\"\n  shows \"FOREACHc S c f \\<sigma>0 \\<le> SPEC P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. FOREACH\\<^sub>C S c f \\<sigma>0 \\<le> SPEC P", "unfolding FOREACHc_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. FOREACH\\<^sub>C\\<^bsup>\\<lambda>_ _. True\\<^esup> S c f \\<sigma>0\n    \\<le> SPEC P", "apply (rule order_trans[OF FOREACHci_weaken], rule TrueI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. FOREACH\\<^sub>C\\<^bsup>?I1\\<^esup> S c f \\<sigma>0 \\<le> SPEC P", "apply (rule FOREACHci_rule[where I=I])"], ["proof (prove)\ngoal (5 subgoals):\n 1. finite S\n 2. I S \\<sigma>0\n 3. \\<And>x it \\<sigma>.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> S; I it \\<sigma>;\n        c \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> f x \\<sigma> \\<le> SPEC (I (it - {x}))\n 4. \\<And>\\<sigma>. I {} \\<sigma> \\<Longrightarrow> P \\<sigma>\n 5. \\<And>it \\<sigma>.\n       \\<lbrakk>it \\<noteq> {}; it \\<subseteq> S; I it \\<sigma>;\n        \\<not> c \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> P \\<sigma>", "using assms"], ["proof (prove)\nusing this:\n  finite S\n  I S \\<sigma>0\n  \\<lbrakk>?x \\<in> ?it; ?it \\<subseteq> S; I ?it ?\\<sigma>;\n   c ?\\<sigma>\\<rbrakk>\n  \\<Longrightarrow> f ?x ?\\<sigma> \\<le> SPEC (I (?it - {?x}))\n  I {} ?\\<sigma> \\<Longrightarrow> P ?\\<sigma>\n  \\<lbrakk>?it \\<noteq> {}; ?it \\<subseteq> S; I ?it ?\\<sigma>;\n   \\<not> c ?\\<sigma>\\<rbrakk>\n  \\<Longrightarrow> P ?\\<sigma>\n\ngoal (5 subgoals):\n 1. finite S\n 2. I S \\<sigma>0\n 3. \\<And>x it \\<sigma>.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> S; I it \\<sigma>;\n        c \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> f x \\<sigma> \\<le> SPEC (I (it - {x}))\n 4. \\<And>\\<sigma>. I {} \\<sigma> \\<Longrightarrow> P \\<sigma>\n 5. \\<And>it \\<sigma>.\n       \\<lbrakk>it \\<noteq> {}; it \\<subseteq> S; I it \\<sigma>;\n        \\<not> c \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> P \\<sigma>", "by auto"], ["", "lemma FOREACH_rule:\n  assumes FIN: \"finite S\"\n  assumes I0: \"I S \\<sigma>0\"\n  assumes IP: \n    \"\\<And>x it \\<sigma>. \\<lbrakk> x\\<in>it; it\\<subseteq>S; I it \\<sigma> \\<rbrakk> \\<Longrightarrow> f x \\<sigma> \\<le> SPEC (I (it-{x}))\"\n  assumes II: \"\\<And>\\<sigma>. \\<lbrakk>I {} \\<sigma>\\<rbrakk> \\<Longrightarrow> P \\<sigma>\"\n  shows \"FOREACH S f \\<sigma>0 \\<le> SPEC P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. FOREACH S f \\<sigma>0 \\<le> SPEC P", "unfolding FOREACH_def FOREACHc_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. FOREACH\\<^sub>C\\<^bsup>\\<lambda>_ _. True\\<^esup> S (\\<lambda>_. True) f\n     \\<sigma>0\n    \\<le> SPEC P", "apply (rule order_trans[OF FOREACHci_weaken], rule TrueI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. FOREACH\\<^sub>C\\<^bsup>?I1\\<^esup> S (\\<lambda>_. True) f \\<sigma>0\n    \\<le> SPEC P", "apply (rule FOREACHci_rule[where I=I])"], ["proof (prove)\ngoal (5 subgoals):\n 1. finite S\n 2. I S \\<sigma>0\n 3. \\<And>x it \\<sigma>.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> S; I it \\<sigma>; True\\<rbrakk>\n       \\<Longrightarrow> f x \\<sigma> \\<le> SPEC (I (it - {x}))\n 4. \\<And>\\<sigma>. I {} \\<sigma> \\<Longrightarrow> P \\<sigma>\n 5. \\<And>it \\<sigma>.\n       \\<lbrakk>it \\<noteq> {}; it \\<subseteq> S; I it \\<sigma>;\n        \\<not> True\\<rbrakk>\n       \\<Longrightarrow> P \\<sigma>", "using assms"], ["proof (prove)\nusing this:\n  finite S\n  I S \\<sigma>0\n  \\<lbrakk>?x \\<in> ?it; ?it \\<subseteq> S; I ?it ?\\<sigma>\\<rbrakk>\n  \\<Longrightarrow> f ?x ?\\<sigma> \\<le> SPEC (I (?it - {?x}))\n  I {} ?\\<sigma> \\<Longrightarrow> P ?\\<sigma>\n\ngoal (5 subgoals):\n 1. finite S\n 2. I S \\<sigma>0\n 3. \\<And>x it \\<sigma>.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> S; I it \\<sigma>; True\\<rbrakk>\n       \\<Longrightarrow> f x \\<sigma> \\<le> SPEC (I (it - {x}))\n 4. \\<And>\\<sigma>. I {} \\<sigma> \\<Longrightarrow> P \\<sigma>\n 5. \\<And>it \\<sigma>.\n       \\<lbrakk>it \\<noteq> {}; it \\<subseteq> S; I it \\<sigma>;\n        \\<not> True\\<rbrakk>\n       \\<Longrightarrow> P \\<sigma>", "by auto"], ["", "lemma FOREACHc_refine_genR:\n  fixes \\<alpha> :: \"'S \\<Rightarrow> 'Sa\" \\<comment> \\<open>Abstraction mapping of elements\\<close>\n  fixes S :: \"'S set\" \\<comment> \\<open>Concrete set\\<close>\n  fixes S' :: \"'Sa set\" \\<comment> \\<open>Abstract set\\<close>\n  fixes \\<sigma>0 :: \"'\\<sigma>\"\n  fixes \\<sigma>0' :: \"'\\<sigma>a\"\n  fixes R :: \"(('S set \\<times> '\\<sigma>) \\<times> ('Sa set \\<times> '\\<sigma>a)) set\"\n  assumes INJ: \"inj_on \\<alpha> S\" \n  assumes REFS[simp]: \"S' = \\<alpha>`S\"\n  assumes REF0: \"((S,\\<sigma>0),(\\<alpha>`S,\\<sigma>0')) \\<in> R\"\n  assumes REFC: \"\\<And>it \\<sigma> it' \\<sigma>'. \\<lbrakk> \n    it\\<subseteq>S; it'\\<subseteq>S'; \n    it'=\\<alpha>`it; ((it,\\<sigma>),(it',\\<sigma>'))\\<in>R\n  \\<rbrakk> \\<Longrightarrow> c \\<sigma> \\<longleftrightarrow> c' \\<sigma>'\"\n  assumes REFSTEP: \"\\<And>x it \\<sigma> x' it' \\<sigma>'. \\<lbrakk>\n    it\\<subseteq>S; it'\\<subseteq>S'; \n    x'=\\<alpha> x; it'=\\<alpha>`it; ((it,\\<sigma>),(it',\\<sigma>'))\\<in>R;\n    x\\<in>it; x'\\<in>it';\n    c \\<sigma>; c' \\<sigma>'\n  \\<rbrakk> \\<Longrightarrow> f x \\<sigma> \n    \\<le> \\<Down>({(\\<sigma>, \\<sigma>'). ((it-{x},\\<sigma>),(it'-{x'},\\<sigma>'))\\<in>R}) (f' x' \\<sigma>')\"\n  assumes REF_R_DONE: \"\\<And>\\<sigma> \\<sigma>'. \\<lbrakk> (({},\\<sigma>),({},\\<sigma>'))\\<in>R \\<rbrakk> \n    \\<Longrightarrow> (\\<sigma>,\\<sigma>')\\<in>R'\"\n  assumes REF_R_BRK: \"\\<And>it \\<sigma> it' \\<sigma>'. \\<lbrakk> \n    it\\<subseteq>S; it'\\<subseteq>S'; \n    it'=\\<alpha>`it; ((it,\\<sigma>),(it',\\<sigma>'))\\<in>R;\n    it\\<noteq>{}; it'\\<noteq>{};\n    \\<not>c \\<sigma>; \\<not>c' \\<sigma>'\n  \\<rbrakk> \\<Longrightarrow> (\\<sigma>,\\<sigma>')\\<in>R'\"\n  shows \"FOREACHc S c f \\<sigma>0 \\<le> \\<Down>R' (FOREACHc S' c' f' \\<sigma>0')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. FOREACH\\<^sub>C S c f \\<sigma>0\n    \\<le> \\<Down> R' (FOREACH\\<^sub>C S' c' f' \\<sigma>0')", "unfolding FOREACHc_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. FOREACH\\<^sub>C\\<^bsup>\\<lambda>_ _. True\\<^esup> S c f \\<sigma>0\n    \\<le> \\<Down> R'\n           (FOREACH\\<^sub>C\\<^bsup>\\<lambda>_ _. True\\<^esup> S' c' f'\n             \\<sigma>0')", "apply (rule FOREACHci_refine_genR)"], ["proof (prove)\ngoal (8 subgoals):\n 1. inj_on ?\\<alpha> S\n 2. S' = ?\\<alpha> ` S\n 3. ((S, \\<sigma>0), ?\\<alpha> ` S, \\<sigma>0') \\<in> ?R\n 4. \\<And>it \\<sigma> it' \\<sigma>'.\n       \\<lbrakk>it \\<subseteq> S; it' \\<subseteq> S'; True; True;\n        it' = ?\\<alpha> ` it;\n        ((it, \\<sigma>), it', \\<sigma>') \\<in> ?R\\<rbrakk>\n       \\<Longrightarrow> c \\<sigma> = c' \\<sigma>'\n 5. \\<And>it \\<sigma> it' \\<sigma>'.\n       \\<lbrakk>it \\<subseteq> S; it' \\<subseteq> S'; True;\n        it' = ?\\<alpha> ` it;\n        ((it, \\<sigma>), it', \\<sigma>') \\<in> ?R\\<rbrakk>\n       \\<Longrightarrow> True\n 6. \\<And>x it \\<sigma> x' it' \\<sigma>'.\n       \\<lbrakk>it \\<subseteq> S; it' \\<subseteq> S'; True; True;\n        x' = ?\\<alpha> x; it' = ?\\<alpha> ` it;\n        ((it, \\<sigma>), it', \\<sigma>') \\<in> ?R; x \\<in> it; x' \\<in> it';\n        c \\<sigma>; c' \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> f x \\<sigma>\n                         \\<le> \\<Down>\n                                {(\\<sigma>, \\<sigma>').\n                                 ((it - {x}, \\<sigma>), it' - {x'},\n                                  \\<sigma>')\n                                 \\<in> ?R}\n                                (f' x' \\<sigma>')\n 7. \\<And>\\<sigma> \\<sigma>'.\n       \\<lbrakk>True; True;\n        (({}, \\<sigma>), {}, \\<sigma>') \\<in> ?R\\<rbrakk>\n       \\<Longrightarrow> (\\<sigma>, \\<sigma>') \\<in> R'\n 8. \\<And>it \\<sigma> it' \\<sigma>'.\n       \\<lbrakk>it \\<subseteq> S; it' \\<subseteq> S'; True; True;\n        it' = ?\\<alpha> ` it; ((it, \\<sigma>), it', \\<sigma>') \\<in> ?R;\n        it \\<noteq> {}; it' \\<noteq> {}; \\<not> c \\<sigma>;\n        \\<not> c' \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> (\\<sigma>, \\<sigma>') \\<in> R'", "apply simp_all"], ["proof (prove)\ngoal (6 subgoals):\n 1. inj_on \\<alpha> S\n 2. ((S, \\<sigma>0), \\<alpha> ` S, \\<sigma>0') \\<in> ?R\n 3. \\<And>it \\<sigma> it' \\<sigma>'.\n       \\<lbrakk>it \\<subseteq> S; it' \\<subseteq> \\<alpha> ` S;\n        it' = \\<alpha> ` it;\n        ((it, \\<sigma>), it', \\<sigma>') \\<in> ?R\\<rbrakk>\n       \\<Longrightarrow> c \\<sigma> = c' \\<sigma>'\n 4. \\<And>x it \\<sigma> x' it' \\<sigma>'.\n       \\<lbrakk>it \\<subseteq> S; it' \\<subseteq> \\<alpha> ` S;\n        x' = \\<alpha> x; it' = \\<alpha> ` it;\n        ((it, \\<sigma>), it', \\<sigma>') \\<in> ?R; x \\<in> it; x' \\<in> it';\n        c \\<sigma>; c' \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> f x \\<sigma>\n                         \\<le> \\<Down>\n                                {(\\<sigma>, \\<sigma>').\n                                 ((it - {x}, \\<sigma>), it' - {x'},\n                                  \\<sigma>')\n                                 \\<in> ?R}\n                                (f' x' \\<sigma>')\n 5. \\<And>\\<sigma> \\<sigma>'.\n       (({}, \\<sigma>), {}, \\<sigma>') \\<in> ?R \\<Longrightarrow>\n       (\\<sigma>, \\<sigma>') \\<in> R'\n 6. \\<And>it \\<sigma> it' \\<sigma>'.\n       \\<lbrakk>it \\<subseteq> S; it' \\<subseteq> \\<alpha> ` S;\n        it' = \\<alpha> ` it; ((it, \\<sigma>), it', \\<sigma>') \\<in> ?R;\n        it \\<noteq> {}; it' \\<noteq> {}; \\<not> c \\<sigma>;\n        \\<not> c' \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> (\\<sigma>, \\<sigma>') \\<in> R'", "apply (fact|simp)+"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>it \\<sigma> it' \\<sigma>'.\n       \\<lbrakk>it \\<subseteq> S; \\<alpha> ` it \\<subseteq> \\<alpha> ` S;\n        it' = \\<alpha> ` it;\n        ((it, \\<sigma>), \\<alpha> ` it, \\<sigma>') \\<in> R\\<rbrakk>\n       \\<Longrightarrow> c \\<sigma> = c' \\<sigma>'\n 2. \\<And>x it \\<sigma> x' it' \\<sigma>'.\n       \\<lbrakk>it \\<subseteq> S; it' \\<subseteq> \\<alpha> ` S;\n        x' = \\<alpha> x; it' = \\<alpha> ` it;\n        ((it, \\<sigma>), it', \\<sigma>') \\<in> R; x \\<in> it; x' \\<in> it';\n        c \\<sigma>; c' \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> f x \\<sigma>\n                         \\<le> \\<Down>\n                                {(\\<sigma>, \\<sigma>').\n                                 ((it - {x}, \\<sigma>), it' - {x'},\n                                  \\<sigma>')\n                                 \\<in> R}\n                                (f' x' \\<sigma>')\n 3. \\<And>\\<sigma> \\<sigma>'.\n       (({}, \\<sigma>), {}, \\<sigma>') \\<in> R \\<Longrightarrow>\n       (\\<sigma>, \\<sigma>') \\<in> R'\n 4. \\<And>it \\<sigma> it' \\<sigma>'.\n       \\<lbrakk>it \\<subseteq> S; it' \\<subseteq> \\<alpha> ` S;\n        it' = \\<alpha> ` it; ((it, \\<sigma>), it', \\<sigma>') \\<in> R;\n        it \\<noteq> {}; it' \\<noteq> {}; \\<not> c \\<sigma>;\n        \\<not> c' \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> (\\<sigma>, \\<sigma>') \\<in> R'", "using REFC"], ["proof (prove)\nusing this:\n  \\<lbrakk>?it \\<subseteq> S; ?it' \\<subseteq> S'; ?it' = \\<alpha> ` ?it;\n   ((?it, ?\\<sigma>), ?it', ?\\<sigma>') \\<in> R\\<rbrakk>\n  \\<Longrightarrow> c ?\\<sigma> = c' ?\\<sigma>'\n\ngoal (4 subgoals):\n 1. \\<And>it \\<sigma> it' \\<sigma>'.\n       \\<lbrakk>it \\<subseteq> S; \\<alpha> ` it \\<subseteq> \\<alpha> ` S;\n        it' = \\<alpha> ` it;\n        ((it, \\<sigma>), \\<alpha> ` it, \\<sigma>') \\<in> R\\<rbrakk>\n       \\<Longrightarrow> c \\<sigma> = c' \\<sigma>'\n 2. \\<And>x it \\<sigma> x' it' \\<sigma>'.\n       \\<lbrakk>it \\<subseteq> S; it' \\<subseteq> \\<alpha> ` S;\n        x' = \\<alpha> x; it' = \\<alpha> ` it;\n        ((it, \\<sigma>), it', \\<sigma>') \\<in> R; x \\<in> it; x' \\<in> it';\n        c \\<sigma>; c' \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> f x \\<sigma>\n                         \\<le> \\<Down>\n                                {(\\<sigma>, \\<sigma>').\n                                 ((it - {x}, \\<sigma>), it' - {x'},\n                                  \\<sigma>')\n                                 \\<in> R}\n                                (f' x' \\<sigma>')\n 3. \\<And>\\<sigma> \\<sigma>'.\n       (({}, \\<sigma>), {}, \\<sigma>') \\<in> R \\<Longrightarrow>\n       (\\<sigma>, \\<sigma>') \\<in> R'\n 4. \\<And>it \\<sigma> it' \\<sigma>'.\n       \\<lbrakk>it \\<subseteq> S; it' \\<subseteq> \\<alpha> ` S;\n        it' = \\<alpha> ` it; ((it, \\<sigma>), it', \\<sigma>') \\<in> R;\n        it \\<noteq> {}; it' \\<noteq> {}; \\<not> c \\<sigma>;\n        \\<not> c' \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> (\\<sigma>, \\<sigma>') \\<in> R'", "apply auto []"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x it \\<sigma> x' it' \\<sigma>'.\n       \\<lbrakk>it \\<subseteq> S; it' \\<subseteq> \\<alpha> ` S;\n        x' = \\<alpha> x; it' = \\<alpha> ` it;\n        ((it, \\<sigma>), it', \\<sigma>') \\<in> R; x \\<in> it; x' \\<in> it';\n        c \\<sigma>; c' \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> f x \\<sigma>\n                         \\<le> \\<Down>\n                                {(\\<sigma>, \\<sigma>').\n                                 ((it - {x}, \\<sigma>), it' - {x'},\n                                  \\<sigma>')\n                                 \\<in> R}\n                                (f' x' \\<sigma>')\n 2. \\<And>\\<sigma> \\<sigma>'.\n       (({}, \\<sigma>), {}, \\<sigma>') \\<in> R \\<Longrightarrow>\n       (\\<sigma>, \\<sigma>') \\<in> R'\n 3. \\<And>it \\<sigma> it' \\<sigma>'.\n       \\<lbrakk>it \\<subseteq> S; it' \\<subseteq> \\<alpha> ` S;\n        it' = \\<alpha> ` it; ((it, \\<sigma>), it', \\<sigma>') \\<in> R;\n        it \\<noteq> {}; it' \\<noteq> {}; \\<not> c \\<sigma>;\n        \\<not> c' \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> (\\<sigma>, \\<sigma>') \\<in> R'", "using REFSTEP"], ["proof (prove)\nusing this:\n  \\<lbrakk>?it \\<subseteq> S; ?it' \\<subseteq> S'; ?x' = \\<alpha> ?x;\n   ?it' = \\<alpha> ` ?it; ((?it, ?\\<sigma>), ?it', ?\\<sigma>') \\<in> R;\n   ?x \\<in> ?it; ?x' \\<in> ?it'; c ?\\<sigma>; c' ?\\<sigma>'\\<rbrakk>\n  \\<Longrightarrow> f ?x ?\\<sigma>\n                    \\<le> \\<Down>\n                           {(\\<sigma>, \\<sigma>').\n                            ((?it - {?x}, \\<sigma>), ?it' - {?x'},\n                             \\<sigma>')\n                            \\<in> R}\n                           (f' ?x' ?\\<sigma>')\n\ngoal (3 subgoals):\n 1. \\<And>x it \\<sigma> x' it' \\<sigma>'.\n       \\<lbrakk>it \\<subseteq> S; it' \\<subseteq> \\<alpha> ` S;\n        x' = \\<alpha> x; it' = \\<alpha> ` it;\n        ((it, \\<sigma>), it', \\<sigma>') \\<in> R; x \\<in> it; x' \\<in> it';\n        c \\<sigma>; c' \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> f x \\<sigma>\n                         \\<le> \\<Down>\n                                {(\\<sigma>, \\<sigma>').\n                                 ((it - {x}, \\<sigma>), it' - {x'},\n                                  \\<sigma>')\n                                 \\<in> R}\n                                (f' x' \\<sigma>')\n 2. \\<And>\\<sigma> \\<sigma>'.\n       (({}, \\<sigma>), {}, \\<sigma>') \\<in> R \\<Longrightarrow>\n       (\\<sigma>, \\<sigma>') \\<in> R'\n 3. \\<And>it \\<sigma> it' \\<sigma>'.\n       \\<lbrakk>it \\<subseteq> S; it' \\<subseteq> \\<alpha> ` S;\n        it' = \\<alpha> ` it; ((it, \\<sigma>), it', \\<sigma>') \\<in> R;\n        it \\<noteq> {}; it' \\<noteq> {}; \\<not> c \\<sigma>;\n        \\<not> c' \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> (\\<sigma>, \\<sigma>') \\<in> R'", "apply auto []"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>\\<sigma> \\<sigma>'.\n       (({}, \\<sigma>), {}, \\<sigma>') \\<in> R \\<Longrightarrow>\n       (\\<sigma>, \\<sigma>') \\<in> R'\n 2. \\<And>it \\<sigma> it' \\<sigma>'.\n       \\<lbrakk>it \\<subseteq> S; it' \\<subseteq> \\<alpha> ` S;\n        it' = \\<alpha> ` it; ((it, \\<sigma>), it', \\<sigma>') \\<in> R;\n        it \\<noteq> {}; it' \\<noteq> {}; \\<not> c \\<sigma>;\n        \\<not> c' \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> (\\<sigma>, \\<sigma>') \\<in> R'", "using REF_R_DONE"], ["proof (prove)\nusing this:\n  (({}, ?\\<sigma>), {}, ?\\<sigma>') \\<in> R \\<Longrightarrow>\n  (?\\<sigma>, ?\\<sigma>') \\<in> R'\n\ngoal (2 subgoals):\n 1. \\<And>\\<sigma> \\<sigma>'.\n       (({}, \\<sigma>), {}, \\<sigma>') \\<in> R \\<Longrightarrow>\n       (\\<sigma>, \\<sigma>') \\<in> R'\n 2. \\<And>it \\<sigma> it' \\<sigma>'.\n       \\<lbrakk>it \\<subseteq> S; it' \\<subseteq> \\<alpha> ` S;\n        it' = \\<alpha> ` it; ((it, \\<sigma>), it', \\<sigma>') \\<in> R;\n        it \\<noteq> {}; it' \\<noteq> {}; \\<not> c \\<sigma>;\n        \\<not> c' \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> (\\<sigma>, \\<sigma>') \\<in> R'", "apply auto []"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>it \\<sigma> it' \\<sigma>'.\n       \\<lbrakk>it \\<subseteq> S; it' \\<subseteq> \\<alpha> ` S;\n        it' = \\<alpha> ` it; ((it, \\<sigma>), it', \\<sigma>') \\<in> R;\n        it \\<noteq> {}; it' \\<noteq> {}; \\<not> c \\<sigma>;\n        \\<not> c' \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> (\\<sigma>, \\<sigma>') \\<in> R'", "using REF_R_BRK"], ["proof (prove)\nusing this:\n  \\<lbrakk>?it \\<subseteq> S; ?it' \\<subseteq> S'; ?it' = \\<alpha> ` ?it;\n   ((?it, ?\\<sigma>), ?it', ?\\<sigma>') \\<in> R; ?it \\<noteq> {};\n   ?it' \\<noteq> {}; \\<not> c ?\\<sigma>; \\<not> c' ?\\<sigma>'\\<rbrakk>\n  \\<Longrightarrow> (?\\<sigma>, ?\\<sigma>') \\<in> R'\n\ngoal (1 subgoal):\n 1. \\<And>it \\<sigma> it' \\<sigma>'.\n       \\<lbrakk>it \\<subseteq> S; it' \\<subseteq> \\<alpha> ` S;\n        it' = \\<alpha> ` it; ((it, \\<sigma>), it', \\<sigma>') \\<in> R;\n        it \\<noteq> {}; it' \\<noteq> {}; \\<not> c \\<sigma>;\n        \\<not> c' \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> (\\<sigma>, \\<sigma>') \\<in> R'", "apply auto []"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma FOREACHc_refine:\n  fixes \\<alpha> :: \"'S \\<Rightarrow> 'Sa\"\n  fixes S :: \"'S set\"\n  fixes S' :: \"'Sa set\"\n  assumes INJ: \"inj_on \\<alpha> S\"\n  assumes REFS: \"S' = \\<alpha>`S\"\n  assumes REF0: \"(\\<sigma>0,\\<sigma>0')\\<in>R\"\n  assumes REFPHI0: \"\\<Phi>'' S \\<sigma>0 (\\<alpha>`S) \\<sigma>0'\"\n  assumes REFC: \"\\<And>it \\<sigma> it' \\<sigma>'. \\<lbrakk> \n    it'=\\<alpha>`it; it\\<subseteq>S; it'\\<subseteq>S'; \\<Phi>'' it \\<sigma> it' \\<sigma>'; (\\<sigma>,\\<sigma>')\\<in>R\n  \\<rbrakk> \\<Longrightarrow> c \\<sigma> \\<longleftrightarrow> c' \\<sigma>'\"\n  assumes REFSTEP: \"\\<And>x it \\<sigma> x' it' \\<sigma>'. \\<lbrakk> \n    x'=\\<alpha> x; x\\<in>it; x'\\<in>it'; it'=\\<alpha>`it; it\\<subseteq>S; it'\\<subseteq>S';\n    \\<Phi>'' it \\<sigma> it' \\<sigma>'; c \\<sigma>; c' \\<sigma>'; (\\<sigma>,\\<sigma>')\\<in>R\n  \\<rbrakk> \\<Longrightarrow> f x \\<sigma> \n    \\<le> \\<Down>({(\\<sigma>, \\<sigma>'). (\\<sigma>, \\<sigma>') \\<in> R \\<and> \\<Phi>'' (it - {x}) \\<sigma> (it' - {x'}) \\<sigma>'}) (f' x' \\<sigma>')\"\n  shows \"FOREACHc S c f \\<sigma>0 \\<le> \\<Down>R (FOREACHc S' c' f' \\<sigma>0')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. FOREACH\\<^sub>C S c f \\<sigma>0\n    \\<le> \\<Down> R (FOREACH\\<^sub>C S' c' f' \\<sigma>0')", "unfolding FOREACHc_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. FOREACH\\<^sub>C\\<^bsup>\\<lambda>_ _. True\\<^esup> S c f \\<sigma>0\n    \\<le> \\<Down> R\n           (FOREACH\\<^sub>C\\<^bsup>\\<lambda>_ _. True\\<^esup> S' c' f'\n             \\<sigma>0')", "apply (rule FOREACHci_refine[where \\<Phi>''=\\<Phi>'', OF INJ REFS REF0 REFPHI0])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>it \\<sigma> it' \\<sigma>'.\n       \\<lbrakk>it' = \\<alpha> ` it; it \\<subseteq> S; it' \\<subseteq> S';\n        True; \\<Phi>'' it \\<sigma> it' \\<sigma>'; True;\n        (\\<sigma>, \\<sigma>') \\<in> R\\<rbrakk>\n       \\<Longrightarrow> c \\<sigma> = c' \\<sigma>'\n 2. \\<And>it \\<sigma> it' \\<sigma>'.\n       \\<lbrakk>it' = \\<alpha> ` it; it \\<subseteq> S; it' \\<subseteq> S';\n        True; \\<Phi>'' it \\<sigma> it' \\<sigma>';\n        (\\<sigma>, \\<sigma>') \\<in> R\\<rbrakk>\n       \\<Longrightarrow> True\n 3. \\<And>x it \\<sigma> x' it' \\<sigma>'.\n       \\<lbrakk>x' = \\<alpha> x; x \\<in> it; x' \\<in> it';\n        it' = \\<alpha> ` it; it \\<subseteq> S; it' \\<subseteq> S'; True;\n        True; \\<Phi>'' it \\<sigma> it' \\<sigma>'; c \\<sigma>; c' \\<sigma>';\n        (\\<sigma>, \\<sigma>') \\<in> R\\<rbrakk>\n       \\<Longrightarrow> f x \\<sigma>\n                         \\<le> \\<Down>\n                                {(\\<sigma>, \\<sigma>').\n                                 (\\<sigma>, \\<sigma>') \\<in> R \\<and>\n                                 \\<Phi>'' (it - {x}) \\<sigma> (it' - {x'})\n                                  \\<sigma>'}\n                                (f' x' \\<sigma>')", "apply (erule (4) REFC)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>it \\<sigma> it' \\<sigma>'.\n       \\<lbrakk>it' = \\<alpha> ` it; it \\<subseteq> S; it' \\<subseteq> S';\n        True; \\<Phi>'' it \\<sigma> it' \\<sigma>';\n        (\\<sigma>, \\<sigma>') \\<in> R\\<rbrakk>\n       \\<Longrightarrow> True\n 2. \\<And>x it \\<sigma> x' it' \\<sigma>'.\n       \\<lbrakk>x' = \\<alpha> x; x \\<in> it; x' \\<in> it';\n        it' = \\<alpha> ` it; it \\<subseteq> S; it' \\<subseteq> S'; True;\n        True; \\<Phi>'' it \\<sigma> it' \\<sigma>'; c \\<sigma>; c' \\<sigma>';\n        (\\<sigma>, \\<sigma>') \\<in> R\\<rbrakk>\n       \\<Longrightarrow> f x \\<sigma>\n                         \\<le> \\<Down>\n                                {(\\<sigma>, \\<sigma>').\n                                 (\\<sigma>, \\<sigma>') \\<in> R \\<and>\n                                 \\<Phi>'' (it - {x}) \\<sigma> (it' - {x'})\n                                  \\<sigma>'}\n                                (f' x' \\<sigma>')", "apply (rule TrueI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x it \\<sigma> x' it' \\<sigma>'.\n       \\<lbrakk>x' = \\<alpha> x; x \\<in> it; x' \\<in> it';\n        it' = \\<alpha> ` it; it \\<subseteq> S; it' \\<subseteq> S'; True;\n        True; \\<Phi>'' it \\<sigma> it' \\<sigma>'; c \\<sigma>; c' \\<sigma>';\n        (\\<sigma>, \\<sigma>') \\<in> R\\<rbrakk>\n       \\<Longrightarrow> f x \\<sigma>\n                         \\<le> \\<Down>\n                                {(\\<sigma>, \\<sigma>').\n                                 (\\<sigma>, \\<sigma>') \\<in> R \\<and>\n                                 \\<Phi>'' (it - {x}) \\<sigma> (it' - {x'})\n                                  \\<sigma>'}\n                                (f' x' \\<sigma>')", "apply (erule (9) REFSTEP)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma FOREACHc_refine_rcg[refine]:\n  fixes \\<alpha> :: \"'S \\<Rightarrow> 'Sa\"\n  fixes S :: \"'S set\"\n  fixes S' :: \"'Sa set\"\n  assumes INJ: \"inj_on \\<alpha> S\"\n  assumes REFS: \"S' = \\<alpha>`S\"\n  assumes REF0: \"(\\<sigma>0,\\<sigma>0')\\<in>R\"\n  assumes REFC: \"\\<And>it \\<sigma> it' \\<sigma>'. \\<lbrakk> \n    it'=\\<alpha>`it; it\\<subseteq>S; it'\\<subseteq>S'; (\\<sigma>,\\<sigma>')\\<in>R\n  \\<rbrakk> \\<Longrightarrow> c \\<sigma> \\<longleftrightarrow> c' \\<sigma>'\"\n  assumes REFSTEP: \"\\<And>x it \\<sigma> x' it' \\<sigma>'. \\<lbrakk> \n    x'=\\<alpha> x; x\\<in>it; x'\\<in>it'; it'=\\<alpha>`it; it\\<subseteq>S; it'\\<subseteq>S'; c \\<sigma>; c' \\<sigma>';\n    (\\<sigma>,\\<sigma>')\\<in>R\n  \\<rbrakk> \\<Longrightarrow> f x \\<sigma> \\<le> \\<Down>R (f' x' \\<sigma>')\"\n  shows \"FOREACHc S c f \\<sigma>0 \\<le> \\<Down>R (FOREACHc S' c' f' \\<sigma>0')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. FOREACH\\<^sub>C S c f \\<sigma>0\n    \\<le> \\<Down> R (FOREACH\\<^sub>C S' c' f' \\<sigma>0')", "unfolding FOREACHc_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. FOREACH\\<^sub>C\\<^bsup>\\<lambda>_ _. True\\<^esup> S c f \\<sigma>0\n    \\<le> \\<Down> R\n           (FOREACH\\<^sub>C\\<^bsup>\\<lambda>_ _. True\\<^esup> S' c' f'\n             \\<sigma>0')", "apply (rule FOREACHci_refine_rcg)"], ["proof (prove)\ngoal (6 subgoals):\n 1. inj_on ?\\<alpha> S\n 2. S' = ?\\<alpha> ` S\n 3. (\\<sigma>0, \\<sigma>0') \\<in> R\n 4. \\<And>it \\<sigma> it' \\<sigma>'.\n       \\<lbrakk>it' = ?\\<alpha> ` it; it \\<subseteq> S; it' \\<subseteq> S';\n        True; True; (\\<sigma>, \\<sigma>') \\<in> R\\<rbrakk>\n       \\<Longrightarrow> c \\<sigma> = c' \\<sigma>'\n 5. \\<And>it \\<sigma> it' \\<sigma>'.\n       \\<lbrakk>it' = ?\\<alpha> ` it; it \\<subseteq> S; it' \\<subseteq> S';\n        True; (\\<sigma>, \\<sigma>') \\<in> R\\<rbrakk>\n       \\<Longrightarrow> True\n 6. \\<And>x it \\<sigma> x' it' \\<sigma>'.\n       \\<lbrakk>x' = ?\\<alpha> x; x \\<in> it; x' \\<in> it';\n        it' = ?\\<alpha> ` it; it \\<subseteq> S; it' \\<subseteq> S'; True;\n        True; c \\<sigma>; c' \\<sigma>';\n        (\\<sigma>, \\<sigma>') \\<in> R\\<rbrakk>\n       \\<Longrightarrow> f x \\<sigma> \\<le> \\<Down> R (f' x' \\<sigma>')", "apply (rule assms)+"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>it \\<sigma> it' \\<sigma>'.\n       \\<lbrakk>it' = \\<alpha> ` it; it \\<subseteq> S; it' \\<subseteq> S';\n        True; True; (\\<sigma>, \\<sigma>') \\<in> R\\<rbrakk>\n       \\<Longrightarrow> S \\<subseteq> S\n 2. \\<And>it \\<sigma> it' \\<sigma>'.\n       \\<lbrakk>it' = \\<alpha> ` it; it \\<subseteq> S; it' \\<subseteq> S';\n        True; True; (\\<sigma>, \\<sigma>') \\<in> R\\<rbrakk>\n       \\<Longrightarrow> S' \\<subseteq> S'\n 3. \\<And>it \\<sigma> it' \\<sigma>'.\n       \\<lbrakk>it' = \\<alpha> ` it; it \\<subseteq> S; it' \\<subseteq> S';\n        True; True; (\\<sigma>, \\<sigma>') \\<in> R\\<rbrakk>\n       \\<Longrightarrow> (\\<sigma>, \\<sigma>') \\<in> R\n 4. \\<And>it \\<sigma> it' \\<sigma>'.\n       \\<lbrakk>it' = \\<alpha> ` it; it \\<subseteq> S; it' \\<subseteq> S';\n        True; (\\<sigma>, \\<sigma>') \\<in> R\\<rbrakk>\n       \\<Longrightarrow> True\n 5. \\<And>x it \\<sigma> x' it' \\<sigma>'.\n       \\<lbrakk>x' = \\<alpha> x; x \\<in> it; x' \\<in> it';\n        it' = \\<alpha> ` it; it \\<subseteq> S; it' \\<subseteq> S'; True;\n        True; c \\<sigma>; c' \\<sigma>';\n        (\\<sigma>, \\<sigma>') \\<in> R\\<rbrakk>\n       \\<Longrightarrow> f x \\<sigma> \\<le> \\<Down> R (f' x' \\<sigma>')", "using assms"], ["proof (prove)\nusing this:\n  inj_on \\<alpha> S\n  S' = \\<alpha> ` S\n  (\\<sigma>0, \\<sigma>0') \\<in> R\n  \\<lbrakk>?it' = \\<alpha> ` ?it; ?it \\<subseteq> S; ?it' \\<subseteq> S';\n   (?\\<sigma>, ?\\<sigma>') \\<in> R\\<rbrakk>\n  \\<Longrightarrow> c ?\\<sigma> = c' ?\\<sigma>'\n  \\<lbrakk>?x' = \\<alpha> ?x; ?x \\<in> ?it; ?x' \\<in> ?it';\n   ?it' = \\<alpha> ` ?it; ?it \\<subseteq> S; ?it' \\<subseteq> S';\n   c ?\\<sigma>; c' ?\\<sigma>'; (?\\<sigma>, ?\\<sigma>') \\<in> R\\<rbrakk>\n  \\<Longrightarrow> f ?x ?\\<sigma> \\<le> \\<Down> R (f' ?x' ?\\<sigma>')\n\ngoal (5 subgoals):\n 1. \\<And>it \\<sigma> it' \\<sigma>'.\n       \\<lbrakk>it' = \\<alpha> ` it; it \\<subseteq> S; it' \\<subseteq> S';\n        True; True; (\\<sigma>, \\<sigma>') \\<in> R\\<rbrakk>\n       \\<Longrightarrow> S \\<subseteq> S\n 2. \\<And>it \\<sigma> it' \\<sigma>'.\n       \\<lbrakk>it' = \\<alpha> ` it; it \\<subseteq> S; it' \\<subseteq> S';\n        True; True; (\\<sigma>, \\<sigma>') \\<in> R\\<rbrakk>\n       \\<Longrightarrow> S' \\<subseteq> S'\n 3. \\<And>it \\<sigma> it' \\<sigma>'.\n       \\<lbrakk>it' = \\<alpha> ` it; it \\<subseteq> S; it' \\<subseteq> S';\n        True; True; (\\<sigma>, \\<sigma>') \\<in> R\\<rbrakk>\n       \\<Longrightarrow> (\\<sigma>, \\<sigma>') \\<in> R\n 4. \\<And>it \\<sigma> it' \\<sigma>'.\n       \\<lbrakk>it' = \\<alpha> ` it; it \\<subseteq> S; it' \\<subseteq> S';\n        True; (\\<sigma>, \\<sigma>') \\<in> R\\<rbrakk>\n       \\<Longrightarrow> True\n 5. \\<And>x it \\<sigma> x' it' \\<sigma>'.\n       \\<lbrakk>x' = \\<alpha> x; x \\<in> it; x' \\<in> it';\n        it' = \\<alpha> ` it; it \\<subseteq> S; it' \\<subseteq> S'; True;\n        True; c \\<sigma>; c' \\<sigma>';\n        (\\<sigma>, \\<sigma>') \\<in> R\\<rbrakk>\n       \\<Longrightarrow> f x \\<sigma> \\<le> \\<Down> R (f' x' \\<sigma>')", "by auto"], ["", "lemma FOREACHi_refine_genR:\n  fixes \\<alpha> :: \"'S \\<Rightarrow> 'Sa\" \\<comment> \\<open>Abstraction mapping of elements\\<close>\n  fixes S :: \"'S set\" \\<comment> \\<open>Concrete set\\<close>\n  fixes S' :: \"'Sa set\" \\<comment> \\<open>Abstract set\\<close>\n  fixes \\<sigma>0 :: \"'\\<sigma>\"\n  fixes \\<sigma>0' :: \"'\\<sigma>a\"\n  fixes R :: \"(('S set \\<times> '\\<sigma>) \\<times> ('Sa set \\<times> '\\<sigma>a)) set\"\n  assumes INJ: \"inj_on \\<alpha> S\" \n  assumes REFS[simp]: \"S' = \\<alpha>`S\"\n  assumes REF0: \"((S,\\<sigma>0),(\\<alpha>`S,\\<sigma>0')) \\<in> R\"\n  assumes REFPHI: \"\\<And>it \\<sigma> it' \\<sigma>'. \\<lbrakk> \n    it\\<subseteq>S; it'\\<subseteq>S'; \\<Phi>' it' \\<sigma>';\n    it'=\\<alpha>`it; ((it,\\<sigma>),(it',\\<sigma>'))\\<in>R\n  \\<rbrakk> \\<Longrightarrow> \\<Phi> it \\<sigma>\"\n  assumes REFSTEP: \"\\<And>x it \\<sigma> x' it' \\<sigma>'. \\<lbrakk>\n    it\\<subseteq>S; it'\\<subseteq>S'; \\<Phi> it \\<sigma>; \\<Phi>' it' \\<sigma>';\n    x'=\\<alpha> x; it'=\\<alpha>`it; ((it,\\<sigma>),(it',\\<sigma>'))\\<in>R;\n    x\\<in>it; x'\\<in>it'\n  \\<rbrakk> \\<Longrightarrow> f x \\<sigma> \n    \\<le> \\<Down>({(\\<sigma>, \\<sigma>'). ((it-{x},\\<sigma>),(it'-{x'},\\<sigma>'))\\<in>R}) (f' x' \\<sigma>')\"\n  assumes REF_R_DONE: \"\\<And>\\<sigma> \\<sigma>'. \\<lbrakk> \\<Phi> {} \\<sigma>; \\<Phi>' {} \\<sigma>'; (({},\\<sigma>),({},\\<sigma>'))\\<in>R \\<rbrakk> \n    \\<Longrightarrow> (\\<sigma>,\\<sigma>')\\<in>R'\"\n  shows \"FOREACHi \\<Phi> S f \\<sigma>0 \\<le> \\<Down>R' (FOREACHi \\<Phi>' S' f' \\<sigma>0')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. FOREACH\\<^bsup>\\<Phi>\\<^esup> S f \\<sigma>0\n    \\<le> \\<Down> R' (FOREACH\\<^bsup>\\<Phi>'\\<^esup> S' f' \\<sigma>0')", "unfolding FOREACHi_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. FOREACH\\<^sub>C\\<^bsup>\\<Phi>\\<^esup> S (\\<lambda>_. True) f \\<sigma>0\n    \\<le> \\<Down> R'\n           (FOREACH\\<^sub>C\\<^bsup>\\<Phi>'\\<^esup> S' (\\<lambda>_. True) f'\n             \\<sigma>0')", "apply (rule FOREACHci_refine_genR)"], ["proof (prove)\ngoal (8 subgoals):\n 1. inj_on ?\\<alpha> S\n 2. S' = ?\\<alpha> ` S\n 3. ((S, \\<sigma>0), ?\\<alpha> ` S, \\<sigma>0') \\<in> ?R\n 4. \\<And>it \\<sigma> it' \\<sigma>'.\n       \\<lbrakk>it \\<subseteq> S; it' \\<subseteq> S'; \\<Phi>' it' \\<sigma>';\n        \\<Phi> it \\<sigma>; it' = ?\\<alpha> ` it;\n        ((it, \\<sigma>), it', \\<sigma>') \\<in> ?R\\<rbrakk>\n       \\<Longrightarrow> True = True\n 5. \\<And>it \\<sigma> it' \\<sigma>'.\n       \\<lbrakk>it \\<subseteq> S; it' \\<subseteq> S'; \\<Phi>' it' \\<sigma>';\n        it' = ?\\<alpha> ` it;\n        ((it, \\<sigma>), it', \\<sigma>') \\<in> ?R\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> it \\<sigma>\n 6. \\<And>x it \\<sigma> x' it' \\<sigma>'.\n       \\<lbrakk>it \\<subseteq> S; it' \\<subseteq> S'; \\<Phi> it \\<sigma>;\n        \\<Phi>' it' \\<sigma>'; x' = ?\\<alpha> x; it' = ?\\<alpha> ` it;\n        ((it, \\<sigma>), it', \\<sigma>') \\<in> ?R; x \\<in> it; x' \\<in> it';\n        True; True\\<rbrakk>\n       \\<Longrightarrow> f x \\<sigma>\n                         \\<le> \\<Down>\n                                {(\\<sigma>, \\<sigma>').\n                                 ((it - {x}, \\<sigma>), it' - {x'},\n                                  \\<sigma>')\n                                 \\<in> ?R}\n                                (f' x' \\<sigma>')\n 7. \\<And>\\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<Phi> {} \\<sigma>; \\<Phi>' {} \\<sigma>';\n        (({}, \\<sigma>), {}, \\<sigma>') \\<in> ?R\\<rbrakk>\n       \\<Longrightarrow> (\\<sigma>, \\<sigma>') \\<in> R'\n 8. \\<And>it \\<sigma> it' \\<sigma>'.\n       \\<lbrakk>it \\<subseteq> S; it' \\<subseteq> S'; \\<Phi> it \\<sigma>;\n        \\<Phi>' it' \\<sigma>'; it' = ?\\<alpha> ` it;\n        ((it, \\<sigma>), it', \\<sigma>') \\<in> ?R; it \\<noteq> {};\n        it' \\<noteq> {}; \\<not> True; \\<not> True\\<rbrakk>\n       \\<Longrightarrow> (\\<sigma>, \\<sigma>') \\<in> R'", "apply (fact|simp)+"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x it \\<sigma> x' it' \\<sigma>'.\n       \\<lbrakk>it \\<subseteq> S; \\<alpha> ` it \\<subseteq> \\<alpha> ` S;\n        \\<Phi> it \\<sigma>; \\<Phi>' (\\<alpha> ` it) \\<sigma>';\n        x' = \\<alpha> x; it' = \\<alpha> ` it;\n        ((it, \\<sigma>), \\<alpha> ` it, \\<sigma>') \\<in> R;\n        x \\<in> it\\<rbrakk>\n       \\<Longrightarrow> f x \\<sigma>\n                         \\<le> \\<Down>\n                                {(\\<sigma>, \\<sigma>').\n                                 ((it - {x}, \\<sigma>),\n                                  \\<alpha> ` it - {\\<alpha> x}, \\<sigma>')\n                                 \\<in> R}\n                                (f' (\\<alpha> x) \\<sigma>')\n 2. \\<And>\\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<Phi> {} \\<sigma>; \\<Phi>' {} \\<sigma>';\n        (({}, \\<sigma>), {}, \\<sigma>') \\<in> R\\<rbrakk>\n       \\<Longrightarrow> (\\<sigma>, \\<sigma>') \\<in> R'\n 3. \\<And>it \\<sigma> it' \\<sigma>'.\n       \\<lbrakk>it \\<subseteq> S; it' \\<subseteq> S'; \\<Phi> it \\<sigma>;\n        \\<Phi>' it' \\<sigma>'; it' = \\<alpha> ` it;\n        ((it, \\<sigma>), it', \\<sigma>') \\<in> R; it \\<noteq> {};\n        it' \\<noteq> {}; \\<not> True; \\<not> True\\<rbrakk>\n       \\<Longrightarrow> (\\<sigma>, \\<sigma>') \\<in> R'", "using REFSTEP"], ["proof (prove)\nusing this:\n  \\<lbrakk>?it \\<subseteq> S; ?it' \\<subseteq> S'; \\<Phi> ?it ?\\<sigma>;\n   \\<Phi>' ?it' ?\\<sigma>'; ?x' = \\<alpha> ?x; ?it' = \\<alpha> ` ?it;\n   ((?it, ?\\<sigma>), ?it', ?\\<sigma>') \\<in> R; ?x \\<in> ?it;\n   ?x' \\<in> ?it'\\<rbrakk>\n  \\<Longrightarrow> f ?x ?\\<sigma>\n                    \\<le> \\<Down>\n                           {(\\<sigma>, \\<sigma>').\n                            ((?it - {?x}, \\<sigma>), ?it' - {?x'},\n                             \\<sigma>')\n                            \\<in> R}\n                           (f' ?x' ?\\<sigma>')\n\ngoal (3 subgoals):\n 1. \\<And>x it \\<sigma> x' it' \\<sigma>'.\n       \\<lbrakk>it \\<subseteq> S; \\<alpha> ` it \\<subseteq> \\<alpha> ` S;\n        \\<Phi> it \\<sigma>; \\<Phi>' (\\<alpha> ` it) \\<sigma>';\n        x' = \\<alpha> x; it' = \\<alpha> ` it;\n        ((it, \\<sigma>), \\<alpha> ` it, \\<sigma>') \\<in> R;\n        x \\<in> it\\<rbrakk>\n       \\<Longrightarrow> f x \\<sigma>\n                         \\<le> \\<Down>\n                                {(\\<sigma>, \\<sigma>').\n                                 ((it - {x}, \\<sigma>),\n                                  \\<alpha> ` it - {\\<alpha> x}, \\<sigma>')\n                                 \\<in> R}\n                                (f' (\\<alpha> x) \\<sigma>')\n 2. \\<And>\\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<Phi> {} \\<sigma>; \\<Phi>' {} \\<sigma>';\n        (({}, \\<sigma>), {}, \\<sigma>') \\<in> R\\<rbrakk>\n       \\<Longrightarrow> (\\<sigma>, \\<sigma>') \\<in> R'\n 3. \\<And>it \\<sigma> it' \\<sigma>'.\n       \\<lbrakk>it \\<subseteq> S; it' \\<subseteq> S'; \\<Phi> it \\<sigma>;\n        \\<Phi>' it' \\<sigma>'; it' = \\<alpha> ` it;\n        ((it, \\<sigma>), it', \\<sigma>') \\<in> R; it \\<noteq> {};\n        it' \\<noteq> {}; \\<not> True; \\<not> True\\<rbrakk>\n       \\<Longrightarrow> (\\<sigma>, \\<sigma>') \\<in> R'", "apply auto []"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>\\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<Phi> {} \\<sigma>; \\<Phi>' {} \\<sigma>';\n        (({}, \\<sigma>), {}, \\<sigma>') \\<in> R\\<rbrakk>\n       \\<Longrightarrow> (\\<sigma>, \\<sigma>') \\<in> R'\n 2. \\<And>it \\<sigma> it' \\<sigma>'.\n       \\<lbrakk>it \\<subseteq> S; it' \\<subseteq> S'; \\<Phi> it \\<sigma>;\n        \\<Phi>' it' \\<sigma>'; it' = \\<alpha> ` it;\n        ((it, \\<sigma>), it', \\<sigma>') \\<in> R; it \\<noteq> {};\n        it' \\<noteq> {}; \\<not> True; \\<not> True\\<rbrakk>\n       \\<Longrightarrow> (\\<sigma>, \\<sigma>') \\<in> R'", "apply (fact|simp)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma FOREACHi_refine:\n  fixes \\<alpha> :: \"'S \\<Rightarrow> 'Sa\"\n  fixes S :: \"'S set\"\n  fixes S' :: \"'Sa set\"\n  assumes INJ: \"inj_on \\<alpha> S\"\n  assumes REFS: \"S' = \\<alpha>`S\"\n  assumes REF0: \"(\\<sigma>0,\\<sigma>0')\\<in>R\"\n  assumes REFPHI0: \"\\<Phi>'' S \\<sigma>0 (\\<alpha>`S) \\<sigma>0'\"\n  assumes REFPHI: \"\\<And>it \\<sigma> it' \\<sigma>'. \\<lbrakk> \n    it'=\\<alpha>`it; it\\<subseteq>S; it'\\<subseteq>S'; \\<Phi>' it' \\<sigma>'; \\<Phi>'' it \\<sigma> it' \\<sigma>'; (\\<sigma>,\\<sigma>')\\<in>R\n  \\<rbrakk> \\<Longrightarrow> \\<Phi> it \\<sigma>\"\n  assumes REFSTEP: \"\\<And>x it \\<sigma> x' it' \\<sigma>'. \\<lbrakk> \n    x'=\\<alpha> x; x\\<in>it; x'\\<in>it'; it'=\\<alpha>`it; it\\<subseteq>S; it'\\<subseteq>S';\n    \\<Phi> it \\<sigma>; \\<Phi>' it' \\<sigma>';  \\<Phi>'' it \\<sigma> it' \\<sigma>';\n    (\\<sigma>,\\<sigma>')\\<in>R\n  \\<rbrakk> \\<Longrightarrow> f x \\<sigma> \n    \\<le> \\<Down>({(\\<sigma>, \\<sigma>'). (\\<sigma>, \\<sigma>') \\<in> R \\<and> \\<Phi>'' (it - {x}) \\<sigma> (it' - {x'}) \\<sigma>'}) (f' x' \\<sigma>')\"\n  shows \"FOREACHi \\<Phi> S f \\<sigma>0 \\<le> \\<Down>R (FOREACHi \\<Phi>' S' f' \\<sigma>0')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. FOREACH\\<^bsup>\\<Phi>\\<^esup> S f \\<sigma>0\n    \\<le> \\<Down> R (FOREACH\\<^bsup>\\<Phi>'\\<^esup> S' f' \\<sigma>0')", "unfolding FOREACHi_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. FOREACH\\<^sub>C\\<^bsup>\\<Phi>\\<^esup> S (\\<lambda>_. True) f \\<sigma>0\n    \\<le> \\<Down> R\n           (FOREACH\\<^sub>C\\<^bsup>\\<Phi>'\\<^esup> S' (\\<lambda>_. True) f'\n             \\<sigma>0')", "apply (rule FOREACHci_refine[where \\<Phi>''=\\<Phi>'', OF INJ REFS REF0 REFPHI0])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>it \\<sigma> it' \\<sigma>'.\n       \\<lbrakk>it' = \\<alpha> ` it; it \\<subseteq> S; it' \\<subseteq> S';\n        \\<Phi>' it' \\<sigma>'; \\<Phi>'' it \\<sigma> it' \\<sigma>';\n        \\<Phi> it \\<sigma>; (\\<sigma>, \\<sigma>') \\<in> R\\<rbrakk>\n       \\<Longrightarrow> True = True\n 2. \\<And>it \\<sigma> it' \\<sigma>'.\n       \\<lbrakk>it' = \\<alpha> ` it; it \\<subseteq> S; it' \\<subseteq> S';\n        \\<Phi>' it' \\<sigma>'; \\<Phi>'' it \\<sigma> it' \\<sigma>';\n        (\\<sigma>, \\<sigma>') \\<in> R\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> it \\<sigma>\n 3. \\<And>x it \\<sigma> x' it' \\<sigma>'.\n       \\<lbrakk>x' = \\<alpha> x; x \\<in> it; x' \\<in> it';\n        it' = \\<alpha> ` it; it \\<subseteq> S; it' \\<subseteq> S';\n        \\<Phi> it \\<sigma>; \\<Phi>' it' \\<sigma>';\n        \\<Phi>'' it \\<sigma> it' \\<sigma>'; True; True;\n        (\\<sigma>, \\<sigma>') \\<in> R\\<rbrakk>\n       \\<Longrightarrow> f x \\<sigma>\n                         \\<le> \\<Down>\n                                {(\\<sigma>, \\<sigma>').\n                                 (\\<sigma>, \\<sigma>') \\<in> R \\<and>\n                                 \\<Phi>'' (it - {x}) \\<sigma> (it' - {x'})\n                                  \\<sigma>'}\n                                (f' x' \\<sigma>')", "apply (rule refl)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>it \\<sigma> it' \\<sigma>'.\n       \\<lbrakk>it' = \\<alpha> ` it; it \\<subseteq> S; it' \\<subseteq> S';\n        \\<Phi>' it' \\<sigma>'; \\<Phi>'' it \\<sigma> it' \\<sigma>';\n        (\\<sigma>, \\<sigma>') \\<in> R\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> it \\<sigma>\n 2. \\<And>x it \\<sigma> x' it' \\<sigma>'.\n       \\<lbrakk>x' = \\<alpha> x; x \\<in> it; x' \\<in> it';\n        it' = \\<alpha> ` it; it \\<subseteq> S; it' \\<subseteq> S';\n        \\<Phi> it \\<sigma>; \\<Phi>' it' \\<sigma>';\n        \\<Phi>'' it \\<sigma> it' \\<sigma>'; True; True;\n        (\\<sigma>, \\<sigma>') \\<in> R\\<rbrakk>\n       \\<Longrightarrow> f x \\<sigma>\n                         \\<le> \\<Down>\n                                {(\\<sigma>, \\<sigma>').\n                                 (\\<sigma>, \\<sigma>') \\<in> R \\<and>\n                                 \\<Phi>'' (it - {x}) \\<sigma> (it' - {x'})\n                                  \\<sigma>'}\n                                (f' x' \\<sigma>')", "apply (erule (5) REFPHI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x it \\<sigma> x' it' \\<sigma>'.\n       \\<lbrakk>x' = \\<alpha> x; x \\<in> it; x' \\<in> it';\n        it' = \\<alpha> ` it; it \\<subseteq> S; it' \\<subseteq> S';\n        \\<Phi> it \\<sigma>; \\<Phi>' it' \\<sigma>';\n        \\<Phi>'' it \\<sigma> it' \\<sigma>'; True; True;\n        (\\<sigma>, \\<sigma>') \\<in> R\\<rbrakk>\n       \\<Longrightarrow> f x \\<sigma>\n                         \\<le> \\<Down>\n                                {(\\<sigma>, \\<sigma>').\n                                 (\\<sigma>, \\<sigma>') \\<in> R \\<and>\n                                 \\<Phi>'' (it - {x}) \\<sigma> (it' - {x'})\n                                  \\<sigma>'}\n                                (f' x' \\<sigma>')", "apply (erule (9) REFSTEP)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma FOREACHi_refine_rcg[refine]:\n  fixes \\<alpha> :: \"'S \\<Rightarrow> 'Sa\"\n  fixes S :: \"'S set\"\n  fixes S' :: \"'Sa set\"\n  assumes INJ: \"inj_on \\<alpha> S\"\n  assumes REFS: \"S' = \\<alpha>`S\"\n  assumes REF0: \"(\\<sigma>0,\\<sigma>0')\\<in>R\"\n  assumes REFPHI: \"\\<And>it \\<sigma> it' \\<sigma>'. \\<lbrakk> \n    it'=\\<alpha>`it; it\\<subseteq>S; it'\\<subseteq>S'; \\<Phi>' it' \\<sigma>'; (\\<sigma>,\\<sigma>')\\<in>R\n  \\<rbrakk> \\<Longrightarrow> \\<Phi> it \\<sigma>\"\n  assumes REFSTEP: \"\\<And>x it \\<sigma> x' it' \\<sigma>'. \\<lbrakk> \n    x'=\\<alpha> x; x\\<in>it; x'\\<in>it'; it'=\\<alpha>`it; it\\<subseteq>S; it'\\<subseteq>S';\n    \\<Phi> it \\<sigma>; \\<Phi>' it' \\<sigma>';\n    (\\<sigma>,\\<sigma>')\\<in>R\n  \\<rbrakk> \\<Longrightarrow> f x \\<sigma> \\<le> \\<Down>R (f' x' \\<sigma>')\"\n  shows \"FOREACHi \\<Phi> S f \\<sigma>0 \\<le> \\<Down>R (FOREACHi \\<Phi>' S' f' \\<sigma>0')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. FOREACH\\<^bsup>\\<Phi>\\<^esup> S f \\<sigma>0\n    \\<le> \\<Down> R (FOREACH\\<^bsup>\\<Phi>'\\<^esup> S' f' \\<sigma>0')", "unfolding FOREACHi_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. FOREACH\\<^sub>C\\<^bsup>\\<Phi>\\<^esup> S (\\<lambda>_. True) f \\<sigma>0\n    \\<le> \\<Down> R\n           (FOREACH\\<^sub>C\\<^bsup>\\<Phi>'\\<^esup> S' (\\<lambda>_. True) f'\n             \\<sigma>0')", "apply (rule FOREACHci_refine_rcg)"], ["proof (prove)\ngoal (6 subgoals):\n 1. inj_on ?\\<alpha> S\n 2. S' = ?\\<alpha> ` S\n 3. (\\<sigma>0, \\<sigma>0') \\<in> R\n 4. \\<And>it \\<sigma> it' \\<sigma>'.\n       \\<lbrakk>it' = ?\\<alpha> ` it; it \\<subseteq> S; it' \\<subseteq> S';\n        \\<Phi>' it' \\<sigma>'; \\<Phi> it \\<sigma>;\n        (\\<sigma>, \\<sigma>') \\<in> R\\<rbrakk>\n       \\<Longrightarrow> True = True\n 5. \\<And>it \\<sigma> it' \\<sigma>'.\n       \\<lbrakk>it' = ?\\<alpha> ` it; it \\<subseteq> S; it' \\<subseteq> S';\n        \\<Phi>' it' \\<sigma>'; (\\<sigma>, \\<sigma>') \\<in> R\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> it \\<sigma>\n 6. \\<And>x it \\<sigma> x' it' \\<sigma>'.\n       \\<lbrakk>x' = ?\\<alpha> x; x \\<in> it; x' \\<in> it';\n        it' = ?\\<alpha> ` it; it \\<subseteq> S; it' \\<subseteq> S';\n        \\<Phi> it \\<sigma>; \\<Phi>' it' \\<sigma>'; True; True;\n        (\\<sigma>, \\<sigma>') \\<in> R\\<rbrakk>\n       \\<Longrightarrow> f x \\<sigma> \\<le> \\<Down> R (f' x' \\<sigma>')", "apply (rule assms)+"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>it \\<sigma> it' \\<sigma>'.\n       \\<lbrakk>it' = \\<alpha> ` it; it \\<subseteq> S; it' \\<subseteq> S';\n        \\<Phi>' it' \\<sigma>'; \\<Phi> it \\<sigma>;\n        (\\<sigma>, \\<sigma>') \\<in> R\\<rbrakk>\n       \\<Longrightarrow> True = True\n 2. \\<And>it \\<sigma> it' \\<sigma>'.\n       \\<lbrakk>it' = \\<alpha> ` it; it \\<subseteq> S; it' \\<subseteq> S';\n        \\<Phi>' it' \\<sigma>'; (\\<sigma>, \\<sigma>') \\<in> R\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> it \\<sigma>\n 3. \\<And>x it \\<sigma> x' it' \\<sigma>'.\n       \\<lbrakk>x' = \\<alpha> x; x \\<in> it; x' \\<in> it';\n        it' = \\<alpha> ` it; it \\<subseteq> S; it' \\<subseteq> S';\n        \\<Phi> it \\<sigma>; \\<Phi>' it' \\<sigma>'; True; True;\n        (\\<sigma>, \\<sigma>') \\<in> R\\<rbrakk>\n       \\<Longrightarrow> f x \\<sigma> \\<le> \\<Down> R (f' x' \\<sigma>')", "using assms"], ["proof (prove)\nusing this:\n  inj_on \\<alpha> S\n  S' = \\<alpha> ` S\n  (\\<sigma>0, \\<sigma>0') \\<in> R\n  \\<lbrakk>?it' = \\<alpha> ` ?it; ?it \\<subseteq> S; ?it' \\<subseteq> S';\n   \\<Phi>' ?it' ?\\<sigma>'; (?\\<sigma>, ?\\<sigma>') \\<in> R\\<rbrakk>\n  \\<Longrightarrow> \\<Phi> ?it ?\\<sigma>\n  \\<lbrakk>?x' = \\<alpha> ?x; ?x \\<in> ?it; ?x' \\<in> ?it';\n   ?it' = \\<alpha> ` ?it; ?it \\<subseteq> S; ?it' \\<subseteq> S';\n   \\<Phi> ?it ?\\<sigma>; \\<Phi>' ?it' ?\\<sigma>';\n   (?\\<sigma>, ?\\<sigma>') \\<in> R\\<rbrakk>\n  \\<Longrightarrow> f ?x ?\\<sigma> \\<le> \\<Down> R (f' ?x' ?\\<sigma>')\n\ngoal (3 subgoals):\n 1. \\<And>it \\<sigma> it' \\<sigma>'.\n       \\<lbrakk>it' = \\<alpha> ` it; it \\<subseteq> S; it' \\<subseteq> S';\n        \\<Phi>' it' \\<sigma>'; \\<Phi> it \\<sigma>;\n        (\\<sigma>, \\<sigma>') \\<in> R\\<rbrakk>\n       \\<Longrightarrow> True = True\n 2. \\<And>it \\<sigma> it' \\<sigma>'.\n       \\<lbrakk>it' = \\<alpha> ` it; it \\<subseteq> S; it' \\<subseteq> S';\n        \\<Phi>' it' \\<sigma>'; (\\<sigma>, \\<sigma>') \\<in> R\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> it \\<sigma>\n 3. \\<And>x it \\<sigma> x' it' \\<sigma>'.\n       \\<lbrakk>x' = \\<alpha> x; x \\<in> it; x' \\<in> it';\n        it' = \\<alpha> ` it; it \\<subseteq> S; it' \\<subseteq> S';\n        \\<Phi> it \\<sigma>; \\<Phi>' it' \\<sigma>'; True; True;\n        (\\<sigma>, \\<sigma>') \\<in> R\\<rbrakk>\n       \\<Longrightarrow> f x \\<sigma> \\<le> \\<Down> R (f' x' \\<sigma>')", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma FOREACH_refine_genR:\n  fixes \\<alpha> :: \"'S \\<Rightarrow> 'Sa\" \\<comment> \\<open>Abstraction mapping of elements\\<close>\n  fixes S :: \"'S set\" \\<comment> \\<open>Concrete set\\<close>\n  fixes S' :: \"'Sa set\" \\<comment> \\<open>Abstract set\\<close>\n  fixes \\<sigma>0 :: \"'\\<sigma>\"\n  fixes \\<sigma>0' :: \"'\\<sigma>a\"\n  fixes R :: \"(('S set \\<times> '\\<sigma>) \\<times> ('Sa set \\<times> '\\<sigma>a)) set\"\n  assumes INJ: \"inj_on \\<alpha> S\" \n  assumes REFS[simp]: \"S' = \\<alpha>`S\"\n  assumes REF0: \"((S,\\<sigma>0),(\\<alpha>`S,\\<sigma>0')) \\<in> R\"\n  assumes REFSTEP: \"\\<And>x it \\<sigma> x' it' \\<sigma>'. \\<lbrakk>\n    it\\<subseteq>S; it'\\<subseteq>S';\n    x'=\\<alpha> x; it'=\\<alpha>`it; ((it,\\<sigma>),(it',\\<sigma>'))\\<in>R;\n    x\\<in>it; x'\\<in>it'\n  \\<rbrakk> \\<Longrightarrow> f x \\<sigma> \n    \\<le> \\<Down>({(\\<sigma>, \\<sigma>'). ((it-{x},\\<sigma>),(it'-{x'},\\<sigma>'))\\<in>R}) (f' x' \\<sigma>')\"\n  assumes REF_R_DONE: \"\\<And>\\<sigma> \\<sigma>'. \\<lbrakk> (({},\\<sigma>),({},\\<sigma>'))\\<in>R \\<rbrakk> \n    \\<Longrightarrow> (\\<sigma>,\\<sigma>')\\<in>R'\"\n  shows \"FOREACH S f \\<sigma>0 \\<le> \\<Down>R' (FOREACH S' f' \\<sigma>0')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. FOREACH S f \\<sigma>0 \\<le> \\<Down> R' (FOREACH S' f' \\<sigma>0')", "unfolding FOREACH_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. FOREACH\\<^sub>C S (\\<lambda>_. True) f \\<sigma>0\n    \\<le> \\<Down> R' (FOREACH\\<^sub>C S' (\\<lambda>_. True) f' \\<sigma>0')", "apply (rule FOREACHc_refine_genR)"], ["proof (prove)\ngoal (7 subgoals):\n 1. inj_on ?\\<alpha> S\n 2. S' = ?\\<alpha> ` S\n 3. ((S, \\<sigma>0), ?\\<alpha> ` S, \\<sigma>0') \\<in> ?R\n 4. \\<And>it \\<sigma> it' \\<sigma>'.\n       \\<lbrakk>it \\<subseteq> S; it' \\<subseteq> S'; it' = ?\\<alpha> ` it;\n        ((it, \\<sigma>), it', \\<sigma>') \\<in> ?R\\<rbrakk>\n       \\<Longrightarrow> True = True\n 5. \\<And>x it \\<sigma> x' it' \\<sigma>'.\n       \\<lbrakk>it \\<subseteq> S; it' \\<subseteq> S'; x' = ?\\<alpha> x;\n        it' = ?\\<alpha> ` it; ((it, \\<sigma>), it', \\<sigma>') \\<in> ?R;\n        x \\<in> it; x' \\<in> it'; True; True\\<rbrakk>\n       \\<Longrightarrow> f x \\<sigma>\n                         \\<le> \\<Down>\n                                {(\\<sigma>, \\<sigma>').\n                                 ((it - {x}, \\<sigma>), it' - {x'},\n                                  \\<sigma>')\n                                 \\<in> ?R}\n                                (f' x' \\<sigma>')\n 6. \\<And>\\<sigma> \\<sigma>'.\n       (({}, \\<sigma>), {}, \\<sigma>') \\<in> ?R \\<Longrightarrow>\n       (\\<sigma>, \\<sigma>') \\<in> R'\n 7. \\<And>it \\<sigma> it' \\<sigma>'.\n       \\<lbrakk>it \\<subseteq> S; it' \\<subseteq> S'; it' = ?\\<alpha> ` it;\n        ((it, \\<sigma>), it', \\<sigma>') \\<in> ?R; it \\<noteq> {};\n        it' \\<noteq> {}; \\<not> True; \\<not> True\\<rbrakk>\n       \\<Longrightarrow> (\\<sigma>, \\<sigma>') \\<in> R'", "apply (fact|simp)+"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x it \\<sigma> x' it' \\<sigma>'.\n       \\<lbrakk>it \\<subseteq> S; \\<alpha> ` it \\<subseteq> \\<alpha> ` S;\n        x' = \\<alpha> x; it' = \\<alpha> ` it;\n        ((it, \\<sigma>), \\<alpha> ` it, \\<sigma>') \\<in> R;\n        x \\<in> it\\<rbrakk>\n       \\<Longrightarrow> f x \\<sigma>\n                         \\<le> \\<Down>\n                                {(\\<sigma>, \\<sigma>').\n                                 ((it - {x}, \\<sigma>),\n                                  \\<alpha> ` it - {\\<alpha> x}, \\<sigma>')\n                                 \\<in> R}\n                                (f' (\\<alpha> x) \\<sigma>')\n 2. \\<And>\\<sigma> \\<sigma>'.\n       (({}, \\<sigma>), {}, \\<sigma>') \\<in> R \\<Longrightarrow>\n       (\\<sigma>, \\<sigma>') \\<in> R'\n 3. \\<And>it \\<sigma> it' \\<sigma>'.\n       \\<lbrakk>it \\<subseteq> S; it' \\<subseteq> S'; it' = \\<alpha> ` it;\n        ((it, \\<sigma>), it', \\<sigma>') \\<in> R; it \\<noteq> {};\n        it' \\<noteq> {}; \\<not> True; \\<not> True\\<rbrakk>\n       \\<Longrightarrow> (\\<sigma>, \\<sigma>') \\<in> R'", "using REFSTEP"], ["proof (prove)\nusing this:\n  \\<lbrakk>?it \\<subseteq> S; ?it' \\<subseteq> S'; ?x' = \\<alpha> ?x;\n   ?it' = \\<alpha> ` ?it; ((?it, ?\\<sigma>), ?it', ?\\<sigma>') \\<in> R;\n   ?x \\<in> ?it; ?x' \\<in> ?it'\\<rbrakk>\n  \\<Longrightarrow> f ?x ?\\<sigma>\n                    \\<le> \\<Down>\n                           {(\\<sigma>, \\<sigma>').\n                            ((?it - {?x}, \\<sigma>), ?it' - {?x'},\n                             \\<sigma>')\n                            \\<in> R}\n                           (f' ?x' ?\\<sigma>')\n\ngoal (3 subgoals):\n 1. \\<And>x it \\<sigma> x' it' \\<sigma>'.\n       \\<lbrakk>it \\<subseteq> S; \\<alpha> ` it \\<subseteq> \\<alpha> ` S;\n        x' = \\<alpha> x; it' = \\<alpha> ` it;\n        ((it, \\<sigma>), \\<alpha> ` it, \\<sigma>') \\<in> R;\n        x \\<in> it\\<rbrakk>\n       \\<Longrightarrow> f x \\<sigma>\n                         \\<le> \\<Down>\n                                {(\\<sigma>, \\<sigma>').\n                                 ((it - {x}, \\<sigma>),\n                                  \\<alpha> ` it - {\\<alpha> x}, \\<sigma>')\n                                 \\<in> R}\n                                (f' (\\<alpha> x) \\<sigma>')\n 2. \\<And>\\<sigma> \\<sigma>'.\n       (({}, \\<sigma>), {}, \\<sigma>') \\<in> R \\<Longrightarrow>\n       (\\<sigma>, \\<sigma>') \\<in> R'\n 3. \\<And>it \\<sigma> it' \\<sigma>'.\n       \\<lbrakk>it \\<subseteq> S; it' \\<subseteq> S'; it' = \\<alpha> ` it;\n        ((it, \\<sigma>), it', \\<sigma>') \\<in> R; it \\<noteq> {};\n        it' \\<noteq> {}; \\<not> True; \\<not> True\\<rbrakk>\n       \\<Longrightarrow> (\\<sigma>, \\<sigma>') \\<in> R'", "apply auto []"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>\\<sigma> \\<sigma>'.\n       (({}, \\<sigma>), {}, \\<sigma>') \\<in> R \\<Longrightarrow>\n       (\\<sigma>, \\<sigma>') \\<in> R'\n 2. \\<And>it \\<sigma> it' \\<sigma>'.\n       \\<lbrakk>it \\<subseteq> S; it' \\<subseteq> S'; it' = \\<alpha> ` it;\n        ((it, \\<sigma>), it', \\<sigma>') \\<in> R; it \\<noteq> {};\n        it' \\<noteq> {}; \\<not> True; \\<not> True\\<rbrakk>\n       \\<Longrightarrow> (\\<sigma>, \\<sigma>') \\<in> R'", "apply (fact|simp)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma FOREACH_refine:\n  fixes \\<alpha> :: \"'S \\<Rightarrow> 'Sa\"\n  fixes S :: \"'S set\"\n  fixes S' :: \"'Sa set\"\n  assumes INJ: \"inj_on \\<alpha> S\"\n  assumes REFS: \"S' = \\<alpha>`S\"\n  assumes REF0: \"(\\<sigma>0,\\<sigma>0')\\<in>R\"\n  assumes REFPHI0: \"\\<Phi>'' S \\<sigma>0 (\\<alpha>`S) \\<sigma>0'\"\n  assumes REFSTEP: \"\\<And>x it \\<sigma> x' it' \\<sigma>'. \\<lbrakk> \n    x'=\\<alpha> x; x\\<in>it; x'\\<in>it'; it'=\\<alpha>`it; it\\<subseteq>S; it'\\<subseteq>S';\n    \\<Phi>'' it \\<sigma> it' \\<sigma>'; (\\<sigma>,\\<sigma>')\\<in>R\n  \\<rbrakk> \\<Longrightarrow> f x \\<sigma> \n    \\<le> \\<Down>({(\\<sigma>, \\<sigma>'). (\\<sigma>, \\<sigma>') \\<in> R \\<and> \\<Phi>'' (it - {x}) \\<sigma> (it' - {x'}) \\<sigma>'}) (f' x' \\<sigma>')\"\n  shows \"FOREACH S f \\<sigma>0 \\<le> \\<Down>R (FOREACH S' f' \\<sigma>0')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. FOREACH S f \\<sigma>0 \\<le> \\<Down> R (FOREACH S' f' \\<sigma>0')", "unfolding FOREACH_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. FOREACH\\<^sub>C S (\\<lambda>_. True) f \\<sigma>0\n    \\<le> \\<Down> R (FOREACH\\<^sub>C S' (\\<lambda>_. True) f' \\<sigma>0')", "apply (rule FOREACHc_refine[where \\<Phi>''=\\<Phi>'', OF INJ REFS REF0 REFPHI0])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>it \\<sigma> it' \\<sigma>'.\n       \\<lbrakk>it' = \\<alpha> ` it; it \\<subseteq> S; it' \\<subseteq> S';\n        \\<Phi>'' it \\<sigma> it' \\<sigma>';\n        (\\<sigma>, \\<sigma>') \\<in> R\\<rbrakk>\n       \\<Longrightarrow> True = True\n 2. \\<And>x it \\<sigma> x' it' \\<sigma>'.\n       \\<lbrakk>x' = \\<alpha> x; x \\<in> it; x' \\<in> it';\n        it' = \\<alpha> ` it; it \\<subseteq> S; it' \\<subseteq> S';\n        \\<Phi>'' it \\<sigma> it' \\<sigma>'; True; True;\n        (\\<sigma>, \\<sigma>') \\<in> R\\<rbrakk>\n       \\<Longrightarrow> f x \\<sigma>\n                         \\<le> \\<Down>\n                                {(\\<sigma>, \\<sigma>').\n                                 (\\<sigma>, \\<sigma>') \\<in> R \\<and>\n                                 \\<Phi>'' (it - {x}) \\<sigma> (it' - {x'})\n                                  \\<sigma>'}\n                                (f' x' \\<sigma>')", "apply (rule refl)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x it \\<sigma> x' it' \\<sigma>'.\n       \\<lbrakk>x' = \\<alpha> x; x \\<in> it; x' \\<in> it';\n        it' = \\<alpha> ` it; it \\<subseteq> S; it' \\<subseteq> S';\n        \\<Phi>'' it \\<sigma> it' \\<sigma>'; True; True;\n        (\\<sigma>, \\<sigma>') \\<in> R\\<rbrakk>\n       \\<Longrightarrow> f x \\<sigma>\n                         \\<le> \\<Down>\n                                {(\\<sigma>, \\<sigma>').\n                                 (\\<sigma>, \\<sigma>') \\<in> R \\<and>\n                                 \\<Phi>'' (it - {x}) \\<sigma> (it' - {x'})\n                                  \\<sigma>'}\n                                (f' x' \\<sigma>')", "apply (erule (7) REFSTEP)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma FOREACH_refine_rcg[refine]:\n  fixes \\<alpha> :: \"'S \\<Rightarrow> 'Sa\"\n  fixes S :: \"'S set\"\n  fixes S' :: \"'Sa set\"\n  assumes INJ: \"inj_on \\<alpha> S\"\n  assumes REFS: \"S' = \\<alpha>`S\"\n  assumes REF0: \"(\\<sigma>0,\\<sigma>0')\\<in>R\"\n  assumes REFSTEP: \"\\<And>x it \\<sigma> x' it' \\<sigma>'. \\<lbrakk> \n    x'=\\<alpha> x; x\\<in>it; x'\\<in>it'; it'=\\<alpha>`it; it\\<subseteq>S; it'\\<subseteq>S';\n    (\\<sigma>,\\<sigma>')\\<in>R\n  \\<rbrakk> \\<Longrightarrow> f x \\<sigma> \\<le> \\<Down>R (f' x' \\<sigma>')\"\n  shows \"FOREACH S f \\<sigma>0 \\<le> \\<Down>R (FOREACH S' f' \\<sigma>0')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. FOREACH S f \\<sigma>0 \\<le> \\<Down> R (FOREACH S' f' \\<sigma>0')", "unfolding FOREACH_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. FOREACH\\<^sub>C S (\\<lambda>_. True) f \\<sigma>0\n    \\<le> \\<Down> R (FOREACH\\<^sub>C S' (\\<lambda>_. True) f' \\<sigma>0')", "apply (rule FOREACHc_refine_rcg)"], ["proof (prove)\ngoal (5 subgoals):\n 1. inj_on ?\\<alpha> S\n 2. S' = ?\\<alpha> ` S\n 3. (\\<sigma>0, \\<sigma>0') \\<in> R\n 4. \\<And>it \\<sigma> it' \\<sigma>'.\n       \\<lbrakk>it' = ?\\<alpha> ` it; it \\<subseteq> S; it' \\<subseteq> S';\n        (\\<sigma>, \\<sigma>') \\<in> R\\<rbrakk>\n       \\<Longrightarrow> True = True\n 5. \\<And>x it \\<sigma> x' it' \\<sigma>'.\n       \\<lbrakk>x' = ?\\<alpha> x; x \\<in> it; x' \\<in> it';\n        it' = ?\\<alpha> ` it; it \\<subseteq> S; it' \\<subseteq> S'; True;\n        True; (\\<sigma>, \\<sigma>') \\<in> R\\<rbrakk>\n       \\<Longrightarrow> f x \\<sigma> \\<le> \\<Down> R (f' x' \\<sigma>')", "apply (rule assms)+"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>it \\<sigma> it' \\<sigma>'.\n       \\<lbrakk>it' = \\<alpha> ` it; it \\<subseteq> S; it' \\<subseteq> S';\n        (\\<sigma>, \\<sigma>') \\<in> R\\<rbrakk>\n       \\<Longrightarrow> True = True\n 2. \\<And>x it \\<sigma> x' it' \\<sigma>'.\n       \\<lbrakk>x' = \\<alpha> x; x \\<in> it; x' \\<in> it';\n        it' = \\<alpha> ` it; it \\<subseteq> S; it' \\<subseteq> S'; True;\n        True; (\\<sigma>, \\<sigma>') \\<in> R\\<rbrakk>\n       \\<Longrightarrow> f x \\<sigma> \\<le> \\<Down> R (f' x' \\<sigma>')", "using assms"], ["proof (prove)\nusing this:\n  inj_on \\<alpha> S\n  S' = \\<alpha> ` S\n  (\\<sigma>0, \\<sigma>0') \\<in> R\n  \\<lbrakk>?x' = \\<alpha> ?x; ?x \\<in> ?it; ?x' \\<in> ?it';\n   ?it' = \\<alpha> ` ?it; ?it \\<subseteq> S; ?it' \\<subseteq> S';\n   (?\\<sigma>, ?\\<sigma>') \\<in> R\\<rbrakk>\n  \\<Longrightarrow> f ?x ?\\<sigma> \\<le> \\<Down> R (f' ?x' ?\\<sigma>')\n\ngoal (2 subgoals):\n 1. \\<And>it \\<sigma> it' \\<sigma>'.\n       \\<lbrakk>it' = \\<alpha> ` it; it \\<subseteq> S; it' \\<subseteq> S';\n        (\\<sigma>, \\<sigma>') \\<in> R\\<rbrakk>\n       \\<Longrightarrow> True = True\n 2. \\<And>x it \\<sigma> x' it' \\<sigma>'.\n       \\<lbrakk>x' = \\<alpha> x; x \\<in> it; x' \\<in> it';\n        it' = \\<alpha> ` it; it \\<subseteq> S; it' \\<subseteq> S'; True;\n        True; (\\<sigma>, \\<sigma>') \\<in> R\\<rbrakk>\n       \\<Longrightarrow> f x \\<sigma> \\<le> \\<Down> R (f' x' \\<sigma>')", "by auto"], ["", "lemma FOREACHci_refine_rcg'[refine]:\n  fixes \\<alpha> :: \"'S \\<Rightarrow> 'Sa\"\n  fixes S :: \"'S set\"\n  fixes S' :: \"'Sa set\"\n  assumes INJ: \"inj_on \\<alpha> S\"\n  assumes REFS: \"S' = \\<alpha>`S\"\n  assumes REF0: \"(\\<sigma>0,\\<sigma>0')\\<in>R\"\n  assumes REFC: \"\\<And>it \\<sigma> it' \\<sigma>'. \\<lbrakk> \n    it'=\\<alpha>`it; it\\<subseteq>S; it'\\<subseteq>S'; \\<Phi>' it' \\<sigma>'; (\\<sigma>,\\<sigma>')\\<in>R\n  \\<rbrakk> \\<Longrightarrow> c \\<sigma> \\<longleftrightarrow> c' \\<sigma>'\"\n  assumes REFSTEP: \"\\<And>x it \\<sigma> x' it' \\<sigma>'. \\<lbrakk> \n    x'=\\<alpha> x; x\\<in>it; x'\\<in>it'; it'=\\<alpha>`it; it\\<subseteq>S; it'\\<subseteq>S';\n    \\<Phi>' it' \\<sigma>'; c \\<sigma>; c' \\<sigma>';\n    (\\<sigma>,\\<sigma>')\\<in>R\n  \\<rbrakk> \\<Longrightarrow> f x \\<sigma> \\<le> \\<Down>R (f' x' \\<sigma>')\"\n  shows \"FOREACHc S c f \\<sigma>0 \\<le> \\<Down>R (FOREACHci \\<Phi>' S' c' f' \\<sigma>0')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. FOREACH\\<^sub>C S c f \\<sigma>0\n    \\<le> \\<Down> R\n           (FOREACH\\<^sub>C\\<^bsup>\\<Phi>'\\<^esup> S' c' f' \\<sigma>0')", "unfolding FOREACHc_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. FOREACH\\<^sub>C\\<^bsup>\\<lambda>_ _. True\\<^esup> S c f \\<sigma>0\n    \\<le> \\<Down> R\n           (FOREACH\\<^sub>C\\<^bsup>\\<Phi>'\\<^esup> S' c' f' \\<sigma>0')", "apply (rule FOREACHci_refine_rcg)"], ["proof (prove)\ngoal (6 subgoals):\n 1. inj_on ?\\<alpha> S\n 2. S' = ?\\<alpha> ` S\n 3. (\\<sigma>0, \\<sigma>0') \\<in> R\n 4. \\<And>it \\<sigma> it' \\<sigma>'.\n       \\<lbrakk>it' = ?\\<alpha> ` it; it \\<subseteq> S; it' \\<subseteq> S';\n        \\<Phi>' it' \\<sigma>'; True; (\\<sigma>, \\<sigma>') \\<in> R\\<rbrakk>\n       \\<Longrightarrow> c \\<sigma> = c' \\<sigma>'\n 5. \\<And>it \\<sigma> it' \\<sigma>'.\n       \\<lbrakk>it' = ?\\<alpha> ` it; it \\<subseteq> S; it' \\<subseteq> S';\n        \\<Phi>' it' \\<sigma>'; (\\<sigma>, \\<sigma>') \\<in> R\\<rbrakk>\n       \\<Longrightarrow> True\n 6. \\<And>x it \\<sigma> x' it' \\<sigma>'.\n       \\<lbrakk>x' = ?\\<alpha> x; x \\<in> it; x' \\<in> it';\n        it' = ?\\<alpha> ` it; it \\<subseteq> S; it' \\<subseteq> S'; True;\n        \\<Phi>' it' \\<sigma>'; c \\<sigma>; c' \\<sigma>';\n        (\\<sigma>, \\<sigma>') \\<in> R\\<rbrakk>\n       \\<Longrightarrow> f x \\<sigma> \\<le> \\<Down> R (f' x' \\<sigma>')", "apply (rule assms)"], ["proof (prove)\ngoal (5 subgoals):\n 1. S' = \\<alpha> ` S\n 2. (\\<sigma>0, \\<sigma>0') \\<in> R\n 3. \\<And>it \\<sigma> it' \\<sigma>'.\n       \\<lbrakk>it' = \\<alpha> ` it; it \\<subseteq> S; it' \\<subseteq> S';\n        \\<Phi>' it' \\<sigma>'; True; (\\<sigma>, \\<sigma>') \\<in> R\\<rbrakk>\n       \\<Longrightarrow> c \\<sigma> = c' \\<sigma>'\n 4. \\<And>it \\<sigma> it' \\<sigma>'.\n       \\<lbrakk>it' = \\<alpha> ` it; it \\<subseteq> S; it' \\<subseteq> S';\n        \\<Phi>' it' \\<sigma>'; (\\<sigma>, \\<sigma>') \\<in> R\\<rbrakk>\n       \\<Longrightarrow> True\n 5. \\<And>x it \\<sigma> x' it' \\<sigma>'.\n       \\<lbrakk>x' = \\<alpha> x; x \\<in> it; x' \\<in> it';\n        it' = \\<alpha> ` it; it \\<subseteq> S; it' \\<subseteq> S'; True;\n        \\<Phi>' it' \\<sigma>'; c \\<sigma>; c' \\<sigma>';\n        (\\<sigma>, \\<sigma>') \\<in> R\\<rbrakk>\n       \\<Longrightarrow> f x \\<sigma> \\<le> \\<Down> R (f' x' \\<sigma>')", "apply (rule assms)"], ["proof (prove)\ngoal (4 subgoals):\n 1. (\\<sigma>0, \\<sigma>0') \\<in> R\n 2. \\<And>it \\<sigma> it' \\<sigma>'.\n       \\<lbrakk>it' = \\<alpha> ` it; it \\<subseteq> S; it' \\<subseteq> S';\n        \\<Phi>' it' \\<sigma>'; True; (\\<sigma>, \\<sigma>') \\<in> R\\<rbrakk>\n       \\<Longrightarrow> c \\<sigma> = c' \\<sigma>'\n 3. \\<And>it \\<sigma> it' \\<sigma>'.\n       \\<lbrakk>it' = \\<alpha> ` it; it \\<subseteq> S; it' \\<subseteq> S';\n        \\<Phi>' it' \\<sigma>'; (\\<sigma>, \\<sigma>') \\<in> R\\<rbrakk>\n       \\<Longrightarrow> True\n 4. \\<And>x it \\<sigma> x' it' \\<sigma>'.\n       \\<lbrakk>x' = \\<alpha> x; x \\<in> it; x' \\<in> it';\n        it' = \\<alpha> ` it; it \\<subseteq> S; it' \\<subseteq> S'; True;\n        \\<Phi>' it' \\<sigma>'; c \\<sigma>; c' \\<sigma>';\n        (\\<sigma>, \\<sigma>') \\<in> R\\<rbrakk>\n       \\<Longrightarrow> f x \\<sigma> \\<le> \\<Down> R (f' x' \\<sigma>')", "apply (rule assms)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>it \\<sigma> it' \\<sigma>'.\n       \\<lbrakk>it' = \\<alpha> ` it; it \\<subseteq> S; it' \\<subseteq> S';\n        \\<Phi>' it' \\<sigma>'; True; (\\<sigma>, \\<sigma>') \\<in> R\\<rbrakk>\n       \\<Longrightarrow> c \\<sigma> = c' \\<sigma>'\n 2. \\<And>it \\<sigma> it' \\<sigma>'.\n       \\<lbrakk>it' = \\<alpha> ` it; it \\<subseteq> S; it' \\<subseteq> S';\n        \\<Phi>' it' \\<sigma>'; (\\<sigma>, \\<sigma>') \\<in> R\\<rbrakk>\n       \\<Longrightarrow> True\n 3. \\<And>x it \\<sigma> x' it' \\<sigma>'.\n       \\<lbrakk>x' = \\<alpha> x; x \\<in> it; x' \\<in> it';\n        it' = \\<alpha> ` it; it \\<subseteq> S; it' \\<subseteq> S'; True;\n        \\<Phi>' it' \\<sigma>'; c \\<sigma>; c' \\<sigma>';\n        (\\<sigma>, \\<sigma>') \\<in> R\\<rbrakk>\n       \\<Longrightarrow> f x \\<sigma> \\<le> \\<Down> R (f' x' \\<sigma>')", "apply (erule (4) REFC)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>it \\<sigma> it' \\<sigma>'.\n       \\<lbrakk>it' = \\<alpha> ` it; it \\<subseteq> S; it' \\<subseteq> S';\n        \\<Phi>' it' \\<sigma>'; (\\<sigma>, \\<sigma>') \\<in> R\\<rbrakk>\n       \\<Longrightarrow> True\n 2. \\<And>x it \\<sigma> x' it' \\<sigma>'.\n       \\<lbrakk>x' = \\<alpha> x; x \\<in> it; x' \\<in> it';\n        it' = \\<alpha> ` it; it \\<subseteq> S; it' \\<subseteq> S'; True;\n        \\<Phi>' it' \\<sigma>'; c \\<sigma>; c' \\<sigma>';\n        (\\<sigma>, \\<sigma>') \\<in> R\\<rbrakk>\n       \\<Longrightarrow> f x \\<sigma> \\<le> \\<Down> R (f' x' \\<sigma>')", "apply (rule TrueI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x it \\<sigma> x' it' \\<sigma>'.\n       \\<lbrakk>x' = \\<alpha> x; x \\<in> it; x' \\<in> it';\n        it' = \\<alpha> ` it; it \\<subseteq> S; it' \\<subseteq> S'; True;\n        \\<Phi>' it' \\<sigma>'; c \\<sigma>; c' \\<sigma>';\n        (\\<sigma>, \\<sigma>') \\<in> R\\<rbrakk>\n       \\<Longrightarrow> f x \\<sigma> \\<le> \\<Down> R (f' x' \\<sigma>')", "apply (rule REFSTEP, assumption+)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma FOREACHi_refine_rcg'[refine]:\n  fixes \\<alpha> :: \"'S \\<Rightarrow> 'Sa\"\n  fixes S :: \"'S set\"\n  fixes S' :: \"'Sa set\"\n  assumes INJ: \"inj_on \\<alpha> S\"\n  assumes REFS: \"S' = \\<alpha>`S\"\n  assumes REF0: \"(\\<sigma>0,\\<sigma>0')\\<in>R\"\n  assumes REFSTEP: \"\\<And>x it \\<sigma> x' it' \\<sigma>'. \\<lbrakk> \n    x'=\\<alpha> x; x\\<in>it; x'\\<in>it'; it'=\\<alpha>`it; it\\<subseteq>S; it'\\<subseteq>S';\n    \\<Phi>' it' \\<sigma>';\n    (\\<sigma>,\\<sigma>')\\<in>R\n  \\<rbrakk> \\<Longrightarrow> f x \\<sigma> \\<le> \\<Down>R (f' x' \\<sigma>')\"\n  shows \"FOREACH S f \\<sigma>0 \\<le> \\<Down>R (FOREACHi \\<Phi>' S' f' \\<sigma>0')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. FOREACH S f \\<sigma>0\n    \\<le> \\<Down> R (FOREACH\\<^bsup>\\<Phi>'\\<^esup> S' f' \\<sigma>0')", "unfolding FOREACH_def FOREACHi_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. FOREACH\\<^sub>C S (\\<lambda>_. True) f \\<sigma>0\n    \\<le> \\<Down> R\n           (FOREACH\\<^sub>C\\<^bsup>\\<Phi>'\\<^esup> S' (\\<lambda>_. True) f'\n             \\<sigma>0')", "apply (rule FOREACHci_refine_rcg')"], ["proof (prove)\ngoal (5 subgoals):\n 1. inj_on ?\\<alpha> S\n 2. S' = ?\\<alpha> ` S\n 3. (\\<sigma>0, \\<sigma>0') \\<in> R\n 4. \\<And>it \\<sigma> it' \\<sigma>'.\n       \\<lbrakk>it' = ?\\<alpha> ` it; it \\<subseteq> S; it' \\<subseteq> S';\n        \\<Phi>' it' \\<sigma>'; (\\<sigma>, \\<sigma>') \\<in> R\\<rbrakk>\n       \\<Longrightarrow> True = True\n 5. \\<And>x it \\<sigma> x' it' \\<sigma>'.\n       \\<lbrakk>x' = ?\\<alpha> x; x \\<in> it; x' \\<in> it';\n        it' = ?\\<alpha> ` it; it \\<subseteq> S; it' \\<subseteq> S';\n        \\<Phi>' it' \\<sigma>'; True; True;\n        (\\<sigma>, \\<sigma>') \\<in> R\\<rbrakk>\n       \\<Longrightarrow> f x \\<sigma> \\<le> \\<Down> R (f' x' \\<sigma>')", "apply (rule assms)+"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>it \\<sigma> it' \\<sigma>'.\n       \\<lbrakk>it' = \\<alpha> ` it; it \\<subseteq> S; it' \\<subseteq> S';\n        \\<Phi>' it' \\<sigma>'; (\\<sigma>, \\<sigma>') \\<in> R\\<rbrakk>\n       \\<Longrightarrow> True = True\n 2. \\<And>x it \\<sigma> x' it' \\<sigma>'.\n       \\<lbrakk>x' = \\<alpha> x; x \\<in> it; x' \\<in> it';\n        it' = \\<alpha> ` it; it \\<subseteq> S; it' \\<subseteq> S';\n        \\<Phi>' it' \\<sigma>'; True; True;\n        (\\<sigma>, \\<sigma>') \\<in> R\\<rbrakk>\n       \\<Longrightarrow> f x \\<sigma> \\<le> \\<Down> R (f' x' \\<sigma>')", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x it \\<sigma> x' it' \\<sigma>'.\n       \\<lbrakk>x' = \\<alpha> x; x \\<in> it; x' \\<in> it';\n        it' = \\<alpha> ` it; it \\<subseteq> S; it' \\<subseteq> S';\n        \\<Phi>' it' \\<sigma>'; True; True;\n        (\\<sigma>, \\<sigma>') \\<in> R\\<rbrakk>\n       \\<Longrightarrow> f x \\<sigma> \\<le> \\<Down> R (f' x' \\<sigma>')", "apply (rule REFSTEP, assumption+)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsubsection \\<open>Alternative set of FOREACHc-rules\\<close>"], ["", "text \\<open>Here, we provide an alternative set of FOREACH rules with \n  interruption. In some cases, they are easier to use, as they avoid \n  redundancy between the final cases for interruption and non-interruption\\<close>"], ["", "lemma FOREACHoci_rule':\n  assumes FIN: \"finite S\"\n  assumes I0: \"I S \\<sigma>0\"\n  assumes IP: \n    \"\\<And>x it \\<sigma>. \\<lbrakk> c \\<sigma>; x\\<in>it; it\\<subseteq>S; I it \\<sigma>; \\<forall>y\\<in>it - {x}. R x y;\n                \\<forall>y\\<in>S - it. R y x \\<rbrakk> \\<Longrightarrow> f x \\<sigma> \\<le> SPEC (I (it-{x}))\"\n  assumes II1: \"\\<And>\\<sigma>. \\<lbrakk>I {} \\<sigma>; c \\<sigma>\\<rbrakk> \\<Longrightarrow> P \\<sigma>\"\n  assumes II2: \"\\<And>it \\<sigma>. \\<lbrakk> it\\<subseteq>S; I it \\<sigma>; \\<not>c \\<sigma>;\n                         \\<forall>x\\<in>it. \\<forall>y\\<in>S - it. R y x \\<rbrakk> \\<Longrightarrow> P \\<sigma>\"\n  shows \"FOREACHoci R I S c f \\<sigma>0 \\<le> SPEC P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. FOREACH\\<^sub>O\\<^sub>C\\<^bsup>R,I\\<^esup> S c f \\<sigma>0 \\<le> SPEC P", "apply (rule FOREACHoci_rule[OF FIN, where I=I, OF I0])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x it \\<sigma>.\n       \\<lbrakk>c \\<sigma>; x \\<in> it; it \\<subseteq> S; I it \\<sigma>;\n        \\<forall>y\\<in>it - {x}. R x y;\n        \\<forall>y\\<in>S - it. R y x\\<rbrakk>\n       \\<Longrightarrow> f x \\<sigma> \\<le> SPEC (I (it - {x}))\n 2. \\<And>\\<sigma>. I {} \\<sigma> \\<Longrightarrow> P \\<sigma>\n 3. \\<And>it \\<sigma>.\n       \\<lbrakk>it \\<noteq> {}; it \\<subseteq> S; I it \\<sigma>;\n        \\<not> c \\<sigma>;\n        \\<forall>x\\<in>it. \\<forall>y\\<in>S - it. R y x\\<rbrakk>\n       \\<Longrightarrow> P \\<sigma>", "apply (rule IP, assumption+)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>\\<sigma>. I {} \\<sigma> \\<Longrightarrow> P \\<sigma>\n 2. \\<And>it \\<sigma>.\n       \\<lbrakk>it \\<noteq> {}; it \\<subseteq> S; I it \\<sigma>;\n        \\<not> c \\<sigma>;\n        \\<forall>x\\<in>it. \\<forall>y\\<in>S - it. R y x\\<rbrakk>\n       \\<Longrightarrow> P \\<sigma>", "apply (case_tac \"c \\<sigma>\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>\\<sigma>.\n       \\<lbrakk>I {} \\<sigma>; c \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> P \\<sigma>\n 2. \\<And>\\<sigma>.\n       \\<lbrakk>I {} \\<sigma>; \\<not> c \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> P \\<sigma>\n 3. \\<And>it \\<sigma>.\n       \\<lbrakk>it \\<noteq> {}; it \\<subseteq> S; I it \\<sigma>;\n        \\<not> c \\<sigma>;\n        \\<forall>x\\<in>it. \\<forall>y\\<in>S - it. R y x\\<rbrakk>\n       \\<Longrightarrow> P \\<sigma>", "apply (blast intro: II1)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>\\<sigma>.\n       \\<lbrakk>I {} \\<sigma>; \\<not> c \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> P \\<sigma>\n 2. \\<And>it \\<sigma>.\n       \\<lbrakk>it \\<noteq> {}; it \\<subseteq> S; I it \\<sigma>;\n        \\<not> c \\<sigma>;\n        \\<forall>x\\<in>it. \\<forall>y\\<in>S - it. R y x\\<rbrakk>\n       \\<Longrightarrow> P \\<sigma>", "apply (blast intro: II2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>it \\<sigma>.\n       \\<lbrakk>it \\<noteq> {}; it \\<subseteq> S; I it \\<sigma>;\n        \\<not> c \\<sigma>;\n        \\<forall>x\\<in>it. \\<forall>y\\<in>S - it. R y x\\<rbrakk>\n       \\<Longrightarrow> P \\<sigma>", "apply (blast intro: II2)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma FOREACHci_rule'[refine_vcg]:\n  assumes FIN: \"finite S\"\n  assumes I0: \"I S \\<sigma>0\"\n  assumes IP: \n    \"\\<And>x it \\<sigma>. \\<lbrakk> x\\<in>it; it\\<subseteq>S; I it \\<sigma>; c \\<sigma> \\<rbrakk> \\<Longrightarrow> f x \\<sigma> \\<le> SPEC (I (it-{x}))\"\n  assumes II1: \"\\<And>\\<sigma>. \\<lbrakk>I {} \\<sigma>; c \\<sigma>\\<rbrakk> \\<Longrightarrow> P \\<sigma>\"\n  assumes II2: \"\\<And>it \\<sigma>. \\<lbrakk> it\\<subseteq>S; I it \\<sigma>; \\<not>c \\<sigma> \\<rbrakk> \\<Longrightarrow> P \\<sigma>\"\n  shows \"FOREACHci I S c f \\<sigma>0 \\<le> SPEC P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. FOREACH\\<^sub>C\\<^bsup>I\\<^esup> S c f \\<sigma>0 \\<le> SPEC P", "unfolding FOREACHci_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. FOREACH\\<^sub>O\\<^sub>C\\<^bsup>\\<lambda>_ _. True,I\\<^esup> S c f\n     \\<sigma>0\n    \\<le> SPEC P", "by (rule FOREACHoci_rule') (simp_all add: assms)"], ["", "lemma FOREACHc_rule':\n  assumes FIN: \"finite S\"\n  assumes I0: \"I S \\<sigma>0\"\n  assumes IP: \n    \"\\<And>x it \\<sigma>. \\<lbrakk> x\\<in>it; it\\<subseteq>S; I it \\<sigma>; c \\<sigma> \\<rbrakk> \\<Longrightarrow> f x \\<sigma> \\<le> SPEC (I (it-{x}))\"\n  assumes II1: \"\\<And>\\<sigma>. \\<lbrakk>I {} \\<sigma>; c \\<sigma>\\<rbrakk> \\<Longrightarrow> P \\<sigma>\"\n  assumes II2: \"\\<And>it \\<sigma>. \\<lbrakk> it\\<subseteq>S; I it \\<sigma>; \\<not>c \\<sigma> \\<rbrakk> \\<Longrightarrow> P \\<sigma>\"\n  shows \"FOREACHc S c f \\<sigma>0 \\<le> SPEC P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. FOREACH\\<^sub>C S c f \\<sigma>0 \\<le> SPEC P", "unfolding FOREACHc_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. FOREACH\\<^sub>C\\<^bsup>\\<lambda>_ _. True\\<^esup> S c f \\<sigma>0\n    \\<le> SPEC P", "apply (rule order_trans[OF FOREACHci_weaken], rule TrueI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. FOREACH\\<^sub>C\\<^bsup>?I1\\<^esup> S c f \\<sigma>0 \\<le> SPEC P", "apply (rule FOREACHci_rule'[where I=I])"], ["proof (prove)\ngoal (5 subgoals):\n 1. finite S\n 2. I S \\<sigma>0\n 3. \\<And>x it \\<sigma>.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> S; I it \\<sigma>;\n        c \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> f x \\<sigma> \\<le> SPEC (I (it - {x}))\n 4. \\<And>\\<sigma>.\n       \\<lbrakk>I {} \\<sigma>; c \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> P \\<sigma>\n 5. \\<And>it \\<sigma>.\n       \\<lbrakk>it \\<subseteq> S; I it \\<sigma>; \\<not> c \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> P \\<sigma>", "using assms"], ["proof (prove)\nusing this:\n  finite S\n  I S \\<sigma>0\n  \\<lbrakk>?x \\<in> ?it; ?it \\<subseteq> S; I ?it ?\\<sigma>;\n   c ?\\<sigma>\\<rbrakk>\n  \\<Longrightarrow> f ?x ?\\<sigma> \\<le> SPEC (I (?it - {?x}))\n  \\<lbrakk>I {} ?\\<sigma>; c ?\\<sigma>\\<rbrakk>\n  \\<Longrightarrow> P ?\\<sigma>\n  \\<lbrakk>?it \\<subseteq> S; I ?it ?\\<sigma>; \\<not> c ?\\<sigma>\\<rbrakk>\n  \\<Longrightarrow> P ?\\<sigma>\n\ngoal (5 subgoals):\n 1. finite S\n 2. I S \\<sigma>0\n 3. \\<And>x it \\<sigma>.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> S; I it \\<sigma>;\n        c \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> f x \\<sigma> \\<le> SPEC (I (it - {x}))\n 4. \\<And>\\<sigma>.\n       \\<lbrakk>I {} \\<sigma>; c \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> P \\<sigma>\n 5. \\<And>it \\<sigma>.\n       \\<lbrakk>it \\<subseteq> S; I it \\<sigma>; \\<not> c \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> P \\<sigma>", "by auto"], ["", "subsection \\<open>FOREACH with empty sets\\<close>"], ["", "lemma FOREACHoci_emp [simp] :\n  \"FOREACHoci R \\<Phi> {} c f \\<sigma> = do {ASSERT (\\<Phi> {} \\<sigma>); RETURN \\<sigma>}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. FOREACH\\<^sub>O\\<^sub>C\\<^bsup>R,\\<Phi>\\<^esup> {} c f \\<sigma> =\n    ASSERT (\\<Phi> {} \\<sigma>) \\<bind> (\\<lambda>_. RETURN \\<sigma>)", "by (simp add: FOREACHoci_def FOREACH_cond_def bind_RES)\n    (simp add: WHILEIT_unfold)"], ["", "lemma FOREACHoi_emp [simp] :\n  \"FOREACHoi R \\<Phi> {} f \\<sigma> = do {ASSERT (\\<Phi> {} \\<sigma>); RETURN \\<sigma>}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. FOREACH\\<^sub>O\\<^bsup>R,\\<Phi>\\<^esup> {} f \\<sigma> =\n    ASSERT (\\<Phi> {} \\<sigma>) \\<bind> (\\<lambda>_. RETURN \\<sigma>)", "by (simp add: FOREACHoi_def)"], ["", "lemma FOREACHci_emp [simp] :\n  \"FOREACHci \\<Phi> {} c f \\<sigma> = do {ASSERT (\\<Phi> {} \\<sigma>); RETURN \\<sigma>}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. FOREACH\\<^sub>C\\<^bsup>\\<Phi>\\<^esup> {} c f \\<sigma> =\n    ASSERT (\\<Phi> {} \\<sigma>) \\<bind> (\\<lambda>_. RETURN \\<sigma>)", "by (simp add: FOREACHci_def)"], ["", "lemma FOREACHc_emp [simp] :\n  \"FOREACHc {} c f \\<sigma> = RETURN \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. FOREACH\\<^sub>C {} c f \\<sigma> = RETURN \\<sigma>", "by (simp add: FOREACHc_def)"], ["", "lemma FOREACH_emp [simp] :\n  \"FOREACH {} f \\<sigma> = RETURN \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. FOREACH {} f \\<sigma> = RETURN \\<sigma>", "by (simp add: FOREACH_def)"], ["", "lemma FOREACHi_emp [simp] :\n  \"FOREACHi \\<Phi> {} f \\<sigma> = do {ASSERT (\\<Phi> {} \\<sigma>); RETURN \\<sigma>}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. FOREACH\\<^bsup>\\<Phi>\\<^esup> {} f \\<sigma> =\n    ASSERT (\\<Phi> {} \\<sigma>) \\<bind> (\\<lambda>_. RETURN \\<sigma>)", "by (simp add: FOREACHi_def)"], ["", "subsection \"Monotonicity\""], ["", "(* TODO: Move to RefineG_Domain *)"], ["", "definition \"lift_refl P c f g == \\<forall>x. P c (f x) (g x)\""], ["", "definition \"lift_mono P c f g == \\<forall>x y. c x y \\<longrightarrow> P c (f x) (g y)\""], ["", "definition \"lift_mono1 P c f g == \\<forall>x y. (\\<forall>a. c (x a) (y a)) \\<longrightarrow> P c (f x) (g y)\""], ["", "definition \"lift_mono2 P c f g == \\<forall>x y. (\\<forall>a b. c (x a b) (y a b)) \\<longrightarrow> P c (f x) (g y)\""], ["", "definition \"trimono_spec L f == ((L id (\\<le>) f f) \\<and> (L id flat_ge f f))\""], ["", "lemmas trimono_atomize = atomize_imp atomize_conj atomize_all"], ["", "lemmas trimono_deatomize = trimono_atomize[symmetric]"], ["", "lemmas trimono_spec_defs = trimono_spec_def lift_refl_def[abs_def] comp_def id_def\n    lift_mono_def[abs_def] lift_mono1_def[abs_def] lift_mono2_def[abs_def]\n    trimono_deatomize"], ["", "locale trimono_spec begin"], ["", "abbreviation \"R \\<equiv> lift_refl\""], ["", "abbreviation \"M \\<equiv> lift_mono\""], ["", "abbreviation \"M1 \\<equiv> lift_mono1\""], ["", "abbreviation \"M2 \\<equiv> lift_mono2\""], ["", "end"], ["", "context begin"], ["", "interpretation trimono_spec"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma FOREACHoci_mono[unfolded trimono_spec_defs,refine_mono]: \n  \"trimono_spec (R o R o R o R o M2 o R) FOREACHoci\"\n  \"trimono_spec (R o R o R o M2 o R) FOREACHoi\"\n  \"trimono_spec (R o R o R o M2 o R) FOREACHci\"\n  \"trimono_spec (R o R o M2 o R) FOREACHc\"\n  \"trimono_spec (R o R o M2 o R) FOREACHi\"\n  \"trimono_spec (R o M2 o R) FOREACH\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (trimono_spec\n      (lift_refl \\<circ> lift_refl \\<circ> lift_refl \\<circ>\n       lift_refl \\<circ>\n       lift_mono2 \\<circ>\n       lift_refl)\n      FOREACHoci &&&\n     trimono_spec\n      (lift_refl \\<circ> lift_refl \\<circ> lift_refl \\<circ>\n       lift_mono2 \\<circ>\n       lift_refl)\n      FOREACHoi &&&\n     trimono_spec\n      (lift_refl \\<circ> lift_refl \\<circ> lift_refl \\<circ>\n       lift_mono2 \\<circ>\n       lift_refl)\n      FOREACHci) &&&\n    trimono_spec\n     (lift_refl \\<circ> lift_refl \\<circ> lift_mono2 \\<circ> lift_refl)\n     FOREACH\\<^sub>C &&&\n    trimono_spec\n     (lift_refl \\<circ> lift_refl \\<circ> lift_mono2 \\<circ> lift_refl)\n     FOREACHi &&&\n    trimono_spec (lift_refl \\<circ> lift_mono2 \\<circ> lift_refl) FOREACH", "apply (unfold trimono_spec_defs)"], ["proof (prove)\ngoal (6 subgoals):\n 1. (\\<And>x xa xb xc xd y.\n        (\\<And>a b. xd a b \\<le> y a b) \\<Longrightarrow>\n        (\\<And>xe.\n            FOREACH\\<^sub>O\\<^sub>C\\<^bsup>x,xa\\<^esup> xb xc xd xe\n            \\<le> FOREACH\\<^sub>O\\<^sub>C\\<^bsup>x,xa\\<^esup> xb xc y\n                   xe)) &&&\n    (\\<And>x xa xb xc xd y.\n        (\\<And>a b. flat_ge (xd a b) (y a b)) \\<Longrightarrow>\n        (\\<And>xe.\n            flat_ge\n             (FOREACH\\<^sub>O\\<^sub>C\\<^bsup>x,xa\\<^esup> xb xc xd xe)\n             (FOREACH\\<^sub>O\\<^sub>C\\<^bsup>x,xa\\<^esup> xb xc y xe)))\n 2. (\\<And>x xa xb xc y.\n        (\\<And>a b. xc a b \\<le> y a b) \\<Longrightarrow>\n        (\\<And>xd.\n            FOREACH\\<^sub>O\\<^bsup>x,xa\\<^esup> xb xc xd\n            \\<le> FOREACH\\<^sub>O\\<^bsup>x,xa\\<^esup> xb y xd)) &&&\n    (\\<And>x xa xb xc y.\n        (\\<And>a b. flat_ge (xc a b) (y a b)) \\<Longrightarrow>\n        (\\<And>xd.\n            flat_ge (FOREACH\\<^sub>O\\<^bsup>x,xa\\<^esup> xb xc xd)\n             (FOREACH\\<^sub>O\\<^bsup>x,xa\\<^esup> xb y xd)))\n 3. (\\<And>x xa xb xc y.\n        (\\<And>a b. xc a b \\<le> y a b) \\<Longrightarrow>\n        (\\<And>xd.\n            FOREACH\\<^sub>C\\<^bsup>x\\<^esup> xa xb xc xd\n            \\<le> FOREACH\\<^sub>C\\<^bsup>x\\<^esup> xa xb y xd)) &&&\n    (\\<And>x xa xb xc y.\n        (\\<And>a b. flat_ge (xc a b) (y a b)) \\<Longrightarrow>\n        (\\<And>xd.\n            flat_ge (FOREACH\\<^sub>C\\<^bsup>x\\<^esup> xa xb xc xd)\n             (FOREACH\\<^sub>C\\<^bsup>x\\<^esup> xa xb y xd)))\n 4. (\\<And>x xa xb y.\n        (\\<And>a b. xb a b \\<le> y a b) \\<Longrightarrow>\n        (\\<And>xc.\n            FOREACH\\<^sub>C x xa xb xc \\<le> FOREACH\\<^sub>C x xa y xc)) &&&\n    (\\<And>x xa xb y.\n        (\\<And>a b. flat_ge (xb a b) (y a b)) \\<Longrightarrow>\n        (\\<And>xc.\n            flat_ge (FOREACH\\<^sub>C x xa xb xc)\n             (FOREACH\\<^sub>C x xa y xc)))\n 5. (\\<And>x xa xb y.\n        (\\<And>a b. xb a b \\<le> y a b) \\<Longrightarrow>\n        (\\<And>xc.\n            FOREACH\\<^bsup>x\\<^esup> xa xb xc\n            \\<le> FOREACH\\<^bsup>x\\<^esup> xa y xc)) &&&\n    (\\<And>x xa xb y.\n        (\\<And>a b. flat_ge (xb a b) (y a b)) \\<Longrightarrow>\n        (\\<And>xc.\n            flat_ge (FOREACH\\<^bsup>x\\<^esup> xa xb xc)\n             (FOREACH\\<^bsup>x\\<^esup> xa y xc)))\n 6. (\\<And>x xa y.\n        (\\<And>a b. xa a b \\<le> y a b) \\<Longrightarrow>\n        (\\<And>xb. FOREACH x xa xb \\<le> FOREACH x y xb)) &&&\n    (\\<And>x xa y.\n        (\\<And>a b. flat_ge (xa a b) (y a b)) \\<Longrightarrow>\n        (\\<And>xb. flat_ge (FOREACH x xa xb) (FOREACH x y xb)))", "apply -"], ["proof (prove)\ngoal (12 subgoals):\n 1. \\<And>x xa xb xc xd y.\n       (\\<And>a b. xd a b \\<le> y a b) \\<Longrightarrow>\n       (\\<And>xe.\n           FOREACH\\<^sub>O\\<^sub>C\\<^bsup>x,xa\\<^esup> xb xc xd xe\n           \\<le> FOREACH\\<^sub>O\\<^sub>C\\<^bsup>x,xa\\<^esup> xb xc y xe)\n 2. \\<And>x xa xb xc xd y.\n       (\\<And>a b. flat_ge (xd a b) (y a b)) \\<Longrightarrow>\n       (\\<And>xe.\n           flat_ge (FOREACH\\<^sub>O\\<^sub>C\\<^bsup>x,xa\\<^esup> xb xc xd xe)\n            (FOREACH\\<^sub>O\\<^sub>C\\<^bsup>x,xa\\<^esup> xb xc y xe))\n 3. \\<And>x xa xb xc y.\n       (\\<And>a b. xc a b \\<le> y a b) \\<Longrightarrow>\n       (\\<And>xd.\n           FOREACH\\<^sub>O\\<^bsup>x,xa\\<^esup> xb xc xd\n           \\<le> FOREACH\\<^sub>O\\<^bsup>x,xa\\<^esup> xb y xd)\n 4. \\<And>x xa xb xc y.\n       (\\<And>a b. flat_ge (xc a b) (y a b)) \\<Longrightarrow>\n       (\\<And>xd.\n           flat_ge (FOREACH\\<^sub>O\\<^bsup>x,xa\\<^esup> xb xc xd)\n            (FOREACH\\<^sub>O\\<^bsup>x,xa\\<^esup> xb y xd))\n 5. \\<And>x xa xb xc y.\n       (\\<And>a b. xc a b \\<le> y a b) \\<Longrightarrow>\n       (\\<And>xd.\n           FOREACH\\<^sub>C\\<^bsup>x\\<^esup> xa xb xc xd\n           \\<le> FOREACH\\<^sub>C\\<^bsup>x\\<^esup> xa xb y xd)\n 6. \\<And>x xa xb xc y.\n       (\\<And>a b. flat_ge (xc a b) (y a b)) \\<Longrightarrow>\n       (\\<And>xd.\n           flat_ge (FOREACH\\<^sub>C\\<^bsup>x\\<^esup> xa xb xc xd)\n            (FOREACH\\<^sub>C\\<^bsup>x\\<^esup> xa xb y xd))\n 7. \\<And>x xa xb y.\n       (\\<And>a b. xb a b \\<le> y a b) \\<Longrightarrow>\n       (\\<And>xc.\n           FOREACH\\<^sub>C x xa xb xc \\<le> FOREACH\\<^sub>C x xa y xc)\n 8. \\<And>x xa xb y.\n       (\\<And>a b. flat_ge (xb a b) (y a b)) \\<Longrightarrow>\n       (\\<And>xc.\n           flat_ge (FOREACH\\<^sub>C x xa xb xc) (FOREACH\\<^sub>C x xa y xc))\n 9. \\<And>x xa xb y.\n       (\\<And>a b. xb a b \\<le> y a b) \\<Longrightarrow>\n       (\\<And>xc.\n           FOREACH\\<^bsup>x\\<^esup> xa xb xc\n           \\<le> FOREACH\\<^bsup>x\\<^esup> xa y xc)\n 10. \\<And>x xa xb y.\n        (\\<And>a b. flat_ge (xb a b) (y a b)) \\<Longrightarrow>\n        (\\<And>xc.\n            flat_ge (FOREACH\\<^bsup>x\\<^esup> xa xb xc)\n             (FOREACH\\<^bsup>x\\<^esup> xa y xc))\nA total of 12 subgoals...", "unfolding FOREACHoci_def FOREACH_to_oci_unfold FOREACH_body_def"], ["proof (prove)\ngoal (12 subgoals):\n 1. \\<And>x xa xb xc xd y.\n       (\\<And>a b. xd a b \\<le> y a b) \\<Longrightarrow>\n       (\\<And>xe.\n           ASSERT (finite xb) \\<bind>\n           (\\<lambda>_.\n               SPEC\n                (\\<lambda>xs.\n                    distinct xs \\<and>\n                    xb = set xs \\<and> sorted_wrt x xs) \\<bind>\n               (\\<lambda>xs.\n                   WHILE\\<^sub>T\\<^bsup>\\<lambda>(it, \\<sigma>).\n     \\<exists>xs'. xs = xs' @ it \\<and> xa (set it) \\<sigma>\\<^esup>\n                    (FOREACH_cond xc)\n                    (\\<lambda>(xs, \\<sigma>).\n                        let x = hd xs\n                        in xd x \\<sigma> \\<bind>\n                           (\\<lambda>\\<sigma>'. RETURN (tl xs, \\<sigma>')))\n                    (xs, xe) \\<bind>\n                   (\\<lambda>(uu_, \\<sigma>). RETURN \\<sigma>)))\n           \\<le> ASSERT (finite xb) \\<bind>\n                 (\\<lambda>_.\n                     SPEC\n                      (\\<lambda>xs.\n                          distinct xs \\<and>\n                          xb = set xs \\<and> sorted_wrt x xs) \\<bind>\n                     (\\<lambda>xs.\n                         WHILE\\<^sub>T\\<^bsup>\\<lambda>(it, \\<sigma>).\n           \\<exists>xs'. xs = xs' @ it \\<and> xa (set it) \\<sigma>\\<^esup>\n                          (FOREACH_cond xc)\n                          (\\<lambda>(xs, \\<sigma>).\n                              let x = hd xs\n                              in y x \\<sigma> \\<bind>\n                                 (\\<lambda>\\<sigma>'.\n                                     RETURN (tl xs, \\<sigma>')))\n                          (xs, xe) \\<bind>\n                         (\\<lambda>(uu_, \\<sigma>). RETURN \\<sigma>))))\n 2. \\<And>x xa xb xc xd y.\n       (\\<And>a b. flat_ge (xd a b) (y a b)) \\<Longrightarrow>\n       (\\<And>xe.\n           flat_ge\n            (ASSERT (finite xb) \\<bind>\n             (\\<lambda>_.\n                 SPEC\n                  (\\<lambda>xs.\n                      distinct xs \\<and>\n                      xb = set xs \\<and> sorted_wrt x xs) \\<bind>\n                 (\\<lambda>xs.\n                     WHILE\\<^sub>T\\<^bsup>\\<lambda>(it, \\<sigma>).\n       \\<exists>xs'. xs = xs' @ it \\<and> xa (set it) \\<sigma>\\<^esup>\n                      (FOREACH_cond xc)\n                      (\\<lambda>(xs, \\<sigma>).\n                          let x = hd xs\n                          in xd x \\<sigma> \\<bind>\n                             (\\<lambda>\\<sigma>'.\n                                 RETURN (tl xs, \\<sigma>')))\n                      (xs, xe) \\<bind>\n                     (\\<lambda>(uu_, \\<sigma>). RETURN \\<sigma>))))\n            (ASSERT (finite xb) \\<bind>\n             (\\<lambda>_.\n                 SPEC\n                  (\\<lambda>xs.\n                      distinct xs \\<and>\n                      xb = set xs \\<and> sorted_wrt x xs) \\<bind>\n                 (\\<lambda>xs.\n                     WHILE\\<^sub>T\\<^bsup>\\<lambda>(it, \\<sigma>).\n       \\<exists>xs'. xs = xs' @ it \\<and> xa (set it) \\<sigma>\\<^esup>\n                      (FOREACH_cond xc)\n                      (\\<lambda>(xs, \\<sigma>).\n                          let x = hd xs\n                          in y x \\<sigma> \\<bind>\n                             (\\<lambda>\\<sigma>'.\n                                 RETURN (tl xs, \\<sigma>')))\n                      (xs, xe) \\<bind>\n                     (\\<lambda>(uu_, \\<sigma>). RETURN \\<sigma>)))))\n 3. \\<And>x xa xb xc y.\n       (\\<And>a b. xc a b \\<le> y a b) \\<Longrightarrow>\n       (\\<And>xd.\n           ASSERT (finite xb) \\<bind>\n           (\\<lambda>_.\n               SPEC\n                (\\<lambda>xs.\n                    distinct xs \\<and>\n                    xb = set xs \\<and> sorted_wrt x xs) \\<bind>\n               (\\<lambda>xs.\n                   WHILE\\<^sub>T\\<^bsup>\\<lambda>(it, \\<sigma>).\n     \\<exists>xs'. xs = xs' @ it \\<and> xa (set it) \\<sigma>\\<^esup>\n                    (FOREACH_cond (\\<lambda>_. True))\n                    (\\<lambda>(xs, \\<sigma>).\n                        let x = hd xs\n                        in xc x \\<sigma> \\<bind>\n                           (\\<lambda>\\<sigma>'. RETURN (tl xs, \\<sigma>')))\n                    (xs, xd) \\<bind>\n                   (\\<lambda>(uu_, \\<sigma>). RETURN \\<sigma>)))\n           \\<le> ASSERT (finite xb) \\<bind>\n                 (\\<lambda>_.\n                     SPEC\n                      (\\<lambda>xs.\n                          distinct xs \\<and>\n                          xb = set xs \\<and> sorted_wrt x xs) \\<bind>\n                     (\\<lambda>xs.\n                         WHILE\\<^sub>T\\<^bsup>\\<lambda>(it, \\<sigma>).\n           \\<exists>xs'. xs = xs' @ it \\<and> xa (set it) \\<sigma>\\<^esup>\n                          (FOREACH_cond (\\<lambda>_. True))\n                          (\\<lambda>(xs, \\<sigma>).\n                              let x = hd xs\n                              in y x \\<sigma> \\<bind>\n                                 (\\<lambda>\\<sigma>'.\n                                     RETURN (tl xs, \\<sigma>')))\n                          (xs, xd) \\<bind>\n                         (\\<lambda>(uu_, \\<sigma>). RETURN \\<sigma>))))\n 4. \\<And>x xa xb xc y.\n       (\\<And>a b. flat_ge (xc a b) (y a b)) \\<Longrightarrow>\n       (\\<And>xd.\n           flat_ge\n            (ASSERT (finite xb) \\<bind>\n             (\\<lambda>_.\n                 SPEC\n                  (\\<lambda>xs.\n                      distinct xs \\<and>\n                      xb = set xs \\<and> sorted_wrt x xs) \\<bind>\n                 (\\<lambda>xs.\n                     WHILE\\<^sub>T\\<^bsup>\\<lambda>(it, \\<sigma>).\n       \\<exists>xs'. xs = xs' @ it \\<and> xa (set it) \\<sigma>\\<^esup>\n                      (FOREACH_cond (\\<lambda>_. True))\n                      (\\<lambda>(xs, \\<sigma>).\n                          let x = hd xs\n                          in xc x \\<sigma> \\<bind>\n                             (\\<lambda>\\<sigma>'.\n                                 RETURN (tl xs, \\<sigma>')))\n                      (xs, xd) \\<bind>\n                     (\\<lambda>(uu_, \\<sigma>). RETURN \\<sigma>))))\n            (ASSERT (finite xb) \\<bind>\n             (\\<lambda>_.\n                 SPEC\n                  (\\<lambda>xs.\n                      distinct xs \\<and>\n                      xb = set xs \\<and> sorted_wrt x xs) \\<bind>\n                 (\\<lambda>xs.\n                     WHILE\\<^sub>T\\<^bsup>\\<lambda>(it, \\<sigma>).\n       \\<exists>xs'. xs = xs' @ it \\<and> xa (set it) \\<sigma>\\<^esup>\n                      (FOREACH_cond (\\<lambda>_. True))\n                      (\\<lambda>(xs, \\<sigma>).\n                          let x = hd xs\n                          in y x \\<sigma> \\<bind>\n                             (\\<lambda>\\<sigma>'.\n                                 RETURN (tl xs, \\<sigma>')))\n                      (xs, xd) \\<bind>\n                     (\\<lambda>(uu_, \\<sigma>). RETURN \\<sigma>)))))\n 5. \\<And>x xa xb xc y.\n       (\\<And>a b. xc a b \\<le> y a b) \\<Longrightarrow>\n       (\\<And>xd.\n           ASSERT (finite xa) \\<bind>\n           (\\<lambda>_.\n               SPEC\n                (\\<lambda>xs.\n                    distinct xs \\<and>\n                    xa = set xs \\<and>\n                    sorted_wrt (\\<lambda>_ _. True) xs) \\<bind>\n               (\\<lambda>xs.\n                   WHILE\\<^sub>T\\<^bsup>\\<lambda>(it, \\<sigma>).\n     \\<exists>xs'. xs = xs' @ it \\<and> x (set it) \\<sigma>\\<^esup>\n                    (FOREACH_cond xb)\n                    (\\<lambda>(xs, \\<sigma>).\n                        let x = hd xs\n                        in xc x \\<sigma> \\<bind>\n                           (\\<lambda>\\<sigma>'. RETURN (tl xs, \\<sigma>')))\n                    (xs, xd) \\<bind>\n                   (\\<lambda>(uu_, \\<sigma>). RETURN \\<sigma>)))\n           \\<le> ASSERT (finite xa) \\<bind>\n                 (\\<lambda>_.\n                     SPEC\n                      (\\<lambda>xs.\n                          distinct xs \\<and>\n                          xa = set xs \\<and>\n                          sorted_wrt (\\<lambda>_ _. True) xs) \\<bind>\n                     (\\<lambda>xs.\n                         WHILE\\<^sub>T\\<^bsup>\\<lambda>(it, \\<sigma>).\n           \\<exists>xs'. xs = xs' @ it \\<and> x (set it) \\<sigma>\\<^esup>\n                          (FOREACH_cond xb)\n                          (\\<lambda>(xs, \\<sigma>).\n                              let x = hd xs\n                              in y x \\<sigma> \\<bind>\n                                 (\\<lambda>\\<sigma>'.\n                                     RETURN (tl xs, \\<sigma>')))\n                          (xs, xd) \\<bind>\n                         (\\<lambda>(uu_, \\<sigma>). RETURN \\<sigma>))))\n 6. \\<And>x xa xb xc y.\n       (\\<And>a b. flat_ge (xc a b) (y a b)) \\<Longrightarrow>\n       (\\<And>xd.\n           flat_ge\n            (ASSERT (finite xa) \\<bind>\n             (\\<lambda>_.\n                 SPEC\n                  (\\<lambda>xs.\n                      distinct xs \\<and>\n                      xa = set xs \\<and>\n                      sorted_wrt (\\<lambda>_ _. True) xs) \\<bind>\n                 (\\<lambda>xs.\n                     WHILE\\<^sub>T\\<^bsup>\\<lambda>(it, \\<sigma>).\n       \\<exists>xs'. xs = xs' @ it \\<and> x (set it) \\<sigma>\\<^esup>\n                      (FOREACH_cond xb)\n                      (\\<lambda>(xs, \\<sigma>).\n                          let x = hd xs\n                          in xc x \\<sigma> \\<bind>\n                             (\\<lambda>\\<sigma>'.\n                                 RETURN (tl xs, \\<sigma>')))\n                      (xs, xd) \\<bind>\n                     (\\<lambda>(uu_, \\<sigma>). RETURN \\<sigma>))))\n            (ASSERT (finite xa) \\<bind>\n             (\\<lambda>_.\n                 SPEC\n                  (\\<lambda>xs.\n                      distinct xs \\<and>\n                      xa = set xs \\<and>\n                      sorted_wrt (\\<lambda>_ _. True) xs) \\<bind>\n                 (\\<lambda>xs.\n                     WHILE\\<^sub>T\\<^bsup>\\<lambda>(it, \\<sigma>).\n       \\<exists>xs'. xs = xs' @ it \\<and> x (set it) \\<sigma>\\<^esup>\n                      (FOREACH_cond xb)\n                      (\\<lambda>(xs, \\<sigma>).\n                          let x = hd xs\n                          in y x \\<sigma> \\<bind>\n                             (\\<lambda>\\<sigma>'.\n                                 RETURN (tl xs, \\<sigma>')))\n                      (xs, xd) \\<bind>\n                     (\\<lambda>(uu_, \\<sigma>). RETURN \\<sigma>)))))\n 7. \\<And>x xa xb y.\n       (\\<And>a b. xb a b \\<le> y a b) \\<Longrightarrow>\n       (\\<And>xc.\n           ASSERT (finite x) \\<bind>\n           (\\<lambda>_.\n               SPEC\n                (\\<lambda>xs.\n                    distinct xs \\<and>\n                    x = set xs \\<and>\n                    sorted_wrt (\\<lambda>_ _. True) xs) \\<bind>\n               (\\<lambda>xs.\n                   WHILE\\<^sub>T\\<^bsup>\\<lambda>(it, \\<sigma>).\n     \\<exists>xs'. xs = xs' @ it \\<and> True\\<^esup>\n                    (FOREACH_cond xa)\n                    (\\<lambda>(xs, \\<sigma>).\n                        let x = hd xs\n                        in xb x \\<sigma> \\<bind>\n                           (\\<lambda>\\<sigma>'. RETURN (tl xs, \\<sigma>')))\n                    (xs, xc) \\<bind>\n                   (\\<lambda>(uu_, \\<sigma>). RETURN \\<sigma>)))\n           \\<le> ASSERT (finite x) \\<bind>\n                 (\\<lambda>_.\n                     SPEC\n                      (\\<lambda>xs.\n                          distinct xs \\<and>\n                          x = set xs \\<and>\n                          sorted_wrt (\\<lambda>_ _. True) xs) \\<bind>\n                     (\\<lambda>xs.\n                         WHILE\\<^sub>T\\<^bsup>\\<lambda>(it, \\<sigma>).\n           \\<exists>xs'. xs = xs' @ it \\<and> True\\<^esup>\n                          (FOREACH_cond xa)\n                          (\\<lambda>(xs, \\<sigma>).\n                              let x = hd xs\n                              in y x \\<sigma> \\<bind>\n                                 (\\<lambda>\\<sigma>'.\n                                     RETURN (tl xs, \\<sigma>')))\n                          (xs, xc) \\<bind>\n                         (\\<lambda>(uu_, \\<sigma>). RETURN \\<sigma>))))\n 8. \\<And>x xa xb y.\n       (\\<And>a b. flat_ge (xb a b) (y a b)) \\<Longrightarrow>\n       (\\<And>xc.\n           flat_ge\n            (ASSERT (finite x) \\<bind>\n             (\\<lambda>_.\n                 SPEC\n                  (\\<lambda>xs.\n                      distinct xs \\<and>\n                      x = set xs \\<and>\n                      sorted_wrt (\\<lambda>_ _. True) xs) \\<bind>\n                 (\\<lambda>xs.\n                     WHILE\\<^sub>T\\<^bsup>\\<lambda>(it, \\<sigma>).\n       \\<exists>xs'. xs = xs' @ it \\<and> True\\<^esup>\n                      (FOREACH_cond xa)\n                      (\\<lambda>(xs, \\<sigma>).\n                          let x = hd xs\n                          in xb x \\<sigma> \\<bind>\n                             (\\<lambda>\\<sigma>'.\n                                 RETURN (tl xs, \\<sigma>')))\n                      (xs, xc) \\<bind>\n                     (\\<lambda>(uu_, \\<sigma>). RETURN \\<sigma>))))\n            (ASSERT (finite x) \\<bind>\n             (\\<lambda>_.\n                 SPEC\n                  (\\<lambda>xs.\n                      distinct xs \\<and>\n                      x = set xs \\<and>\n                      sorted_wrt (\\<lambda>_ _. True) xs) \\<bind>\n                 (\\<lambda>xs.\n                     WHILE\\<^sub>T\\<^bsup>\\<lambda>(it, \\<sigma>).\n       \\<exists>xs'. xs = xs' @ it \\<and> True\\<^esup>\n                      (FOREACH_cond xa)\n                      (\\<lambda>(xs, \\<sigma>).\n                          let x = hd xs\n                          in y x \\<sigma> \\<bind>\n                             (\\<lambda>\\<sigma>'.\n                                 RETURN (tl xs, \\<sigma>')))\n                      (xs, xc) \\<bind>\n                     (\\<lambda>(uu_, \\<sigma>). RETURN \\<sigma>)))))\n 9. \\<And>x xa xb y.\n       (\\<And>a b. xb a b \\<le> y a b) \\<Longrightarrow>\n       (\\<And>xc.\n           ASSERT (finite xa) \\<bind>\n           (\\<lambda>_.\n               SPEC\n                (\\<lambda>xs.\n                    distinct xs \\<and>\n                    xa = set xs \\<and>\n                    sorted_wrt (\\<lambda>_ _. True) xs) \\<bind>\n               (\\<lambda>xs.\n                   WHILE\\<^sub>T\\<^bsup>\\<lambda>(it, \\<sigma>).\n     \\<exists>xs'. xs = xs' @ it \\<and> x (set it) \\<sigma>\\<^esup>\n                    (FOREACH_cond (\\<lambda>_. True))\n                    (\\<lambda>(xs, \\<sigma>).\n                        let x = hd xs\n                        in xb x \\<sigma> \\<bind>\n                           (\\<lambda>\\<sigma>'. RETURN (tl xs, \\<sigma>')))\n                    (xs, xc) \\<bind>\n                   (\\<lambda>(uu_, \\<sigma>). RETURN \\<sigma>)))\n           \\<le> ASSERT (finite xa) \\<bind>\n                 (\\<lambda>_.\n                     SPEC\n                      (\\<lambda>xs.\n                          distinct xs \\<and>\n                          xa = set xs \\<and>\n                          sorted_wrt (\\<lambda>_ _. True) xs) \\<bind>\n                     (\\<lambda>xs.\n                         WHILE\\<^sub>T\\<^bsup>\\<lambda>(it, \\<sigma>).\n           \\<exists>xs'. xs = xs' @ it \\<and> x (set it) \\<sigma>\\<^esup>\n                          (FOREACH_cond (\\<lambda>_. True))\n                          (\\<lambda>(xs, \\<sigma>).\n                              let x = hd xs\n                              in y x \\<sigma> \\<bind>\n                                 (\\<lambda>\\<sigma>'.\n                                     RETURN (tl xs, \\<sigma>')))\n                          (xs, xc) \\<bind>\n                         (\\<lambda>(uu_, \\<sigma>). RETURN \\<sigma>))))\n 10. \\<And>x xa xb y.\n        (\\<And>a b. flat_ge (xb a b) (y a b)) \\<Longrightarrow>\n        (\\<And>xc.\n            flat_ge\n             (ASSERT (finite xa) \\<bind>\n              (\\<lambda>_.\n                  SPEC\n                   (\\<lambda>xs.\n                       distinct xs \\<and>\n                       xa = set xs \\<and>\n                       sorted_wrt (\\<lambda>_ _. True) xs) \\<bind>\n                  (\\<lambda>xs.\n                      WHILE\\<^sub>T\\<^bsup>\\<lambda>(it, \\<sigma>).\n        \\<exists>xs'. xs = xs' @ it \\<and> x (set it) \\<sigma>\\<^esup>\n                       (FOREACH_cond (\\<lambda>_. True))\n                       (\\<lambda>(xs, \\<sigma>).\n                           let x = hd xs\n                           in xb x \\<sigma> \\<bind>\n                              (\\<lambda>\\<sigma>'.\n                                  RETURN (tl xs, \\<sigma>')))\n                       (xs, xc) \\<bind>\n                      (\\<lambda>(uu_, \\<sigma>). RETURN \\<sigma>))))\n             (ASSERT (finite xa) \\<bind>\n              (\\<lambda>_.\n                  SPEC\n                   (\\<lambda>xs.\n                       distinct xs \\<and>\n                       xa = set xs \\<and>\n                       sorted_wrt (\\<lambda>_ _. True) xs) \\<bind>\n                  (\\<lambda>xs.\n                      WHILE\\<^sub>T\\<^bsup>\\<lambda>(it, \\<sigma>).\n        \\<exists>xs'. xs = xs' @ it \\<and> x (set it) \\<sigma>\\<^esup>\n                       (FOREACH_cond (\\<lambda>_. True))\n                       (\\<lambda>(xs, \\<sigma>).\n                           let x = hd xs\n                           in y x \\<sigma> \\<bind>\n                              (\\<lambda>\\<sigma>'.\n                                  RETURN (tl xs, \\<sigma>')))\n                       (xs, xc) \\<bind>\n                      (\\<lambda>(uu_, \\<sigma>). RETURN \\<sigma>)))))\nA total of 12 subgoals...", "apply (refine_mono)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "subsection \\<open>Nres-Fold with Interruption (nfoldli)\\<close>"], ["", "text \\<open>\n  A foreach-loop can be conveniently expressed as an operation that converts\n  the set to a list, followed by folding over the list.\n  \n  This representation is handy for automatic refinement, as the complex \n  foreach-operation is expressed by two relatively simple operations.\n\\<close>"], ["", "text \\<open>We first define a fold-function in the nres-monad\\<close>"], ["", "partial_function (nrec) nfoldli where\n  \"nfoldli l c f s = (case l of \n    [] \\<Rightarrow> RETURN s \n    | x#ls \\<Rightarrow> if c s then do { s\\<leftarrow>f x s; nfoldli ls c f s} else RETURN s\n  )\""], ["", "lemma nfoldli_simps[simp]:\n  \"nfoldli [] c f s = RETURN s\"\n  \"nfoldli (x#ls) c f s = \n    (if c s then do { s\\<leftarrow>f x s; nfoldli ls c f s} else RETURN s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nfoldli [] c f s = RETURN s &&&\n    nfoldli (x # ls) c f s =\n    (if c s then f x s \\<bind> nfoldli ls c f else RETURN s)", "apply (subst nfoldli.simps, simp)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma param_nfoldli[param]:\n  shows \"(nfoldli,nfoldli) \\<in> \n    \\<langle>Ra\\<rangle>list_rel \\<rightarrow> (Rb\\<rightarrow>Id) \\<rightarrow> (Ra\\<rightarrow>Rb\\<rightarrow>\\<langle>Rb\\<rangle>nres_rel) \\<rightarrow> Rb \\<rightarrow> \\<langle>Rb\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (nfoldli, nfoldli)\n    \\<in> \\<langle>Ra\\<rangle>list_rel \\<rightarrow>\n          (Rb \\<rightarrow> bool_rel) \\<rightarrow>\n          (Ra \\<rightarrow>\n           Rb \\<rightarrow> \\<langle>Rb\\<rangle>nres_rel) \\<rightarrow>\n          Rb \\<rightarrow> \\<langle>Rb\\<rangle>nres_rel", "apply (intro fun_relI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a ab a'b ac a'c.\n       \\<lbrakk>(a, a') \\<in> \\<langle>Ra\\<rangle>list_rel;\n        (aa, a'a) \\<in> Rb \\<rightarrow> bool_rel;\n        (ab, a'b)\n        \\<in> Ra \\<rightarrow>\n              Rb \\<rightarrow> \\<langle>Rb\\<rangle>nres_rel;\n        (ac, a'c) \\<in> Rb\\<rbrakk>\n       \\<Longrightarrow> (nfoldli a aa ab ac, nfoldli a' a'a a'b a'c)\n                         \\<in> \\<langle>Rb\\<rangle>nres_rel", "proof goal_cases"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a ab a'b ac a'c.\n       \\<lbrakk>(a, a') \\<in> \\<langle>Ra\\<rangle>list_rel;\n        (aa, a'a) \\<in> Rb \\<rightarrow> bool_rel;\n        (ab, a'b)\n        \\<in> Ra \\<rightarrow>\n              Rb \\<rightarrow> \\<langle>Rb\\<rangle>nres_rel;\n        (ac, a'c) \\<in> Rb\\<rbrakk>\n       \\<Longrightarrow> (nfoldli a aa ab ac, nfoldli a' a'a a'b a'c)\n                         \\<in> \\<langle>Rb\\<rangle>nres_rel", "case (1 l l' c c' f f' s s')"], ["proof (state)\nthis:\n  (l, l') \\<in> \\<langle>Ra\\<rangle>list_rel\n  (c, c') \\<in> Rb \\<rightarrow> bool_rel\n  (f, f')\n  \\<in> Ra \\<rightarrow> Rb \\<rightarrow> \\<langle>Rb\\<rangle>nres_rel\n  (s, s') \\<in> Rb\n\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a ab a'b ac a'c.\n       \\<lbrakk>(a, a') \\<in> \\<langle>Ra\\<rangle>list_rel;\n        (aa, a'a) \\<in> Rb \\<rightarrow> bool_rel;\n        (ab, a'b)\n        \\<in> Ra \\<rightarrow>\n              Rb \\<rightarrow> \\<langle>Rb\\<rangle>nres_rel;\n        (ac, a'c) \\<in> Rb\\<rbrakk>\n       \\<Longrightarrow> (nfoldli a aa ab ac, nfoldli a' a'a a'b a'c)\n                         \\<in> \\<langle>Rb\\<rangle>nres_rel", "thus ?case"], ["proof (prove)\nusing this:\n  (l, l') \\<in> \\<langle>Ra\\<rangle>list_rel\n  (c, c') \\<in> Rb \\<rightarrow> bool_rel\n  (f, f')\n  \\<in> Ra \\<rightarrow> Rb \\<rightarrow> \\<langle>Rb\\<rangle>nres_rel\n  (s, s') \\<in> Rb\n\ngoal (1 subgoal):\n 1. (nfoldli l c f s, nfoldli l' c' f' s')\n    \\<in> \\<langle>Rb\\<rangle>nres_rel", "apply (induct arbitrary: s s')"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s s'.\n       \\<lbrakk>(c, c') \\<in> Rb \\<rightarrow> bool_rel;\n        (f, f')\n        \\<in> Ra \\<rightarrow>\n              Rb \\<rightarrow> \\<langle>Rb\\<rangle>nres_rel;\n        (s, s') \\<in> Rb\\<rbrakk>\n       \\<Longrightarrow> (nfoldli [] c f s, nfoldli [] c' f' s')\n                         \\<in> \\<langle>Rb\\<rangle>nres_rel\n 2. \\<And>x x' l l' s s'.\n       \\<lbrakk>(x, x') \\<in> Ra;\n        (l, l') \\<in> \\<langle>Ra\\<rangle>list_rel;\n        \\<And>s s'.\n           \\<lbrakk>(c, c') \\<in> Rb \\<rightarrow> bool_rel;\n            (f, f')\n            \\<in> Ra \\<rightarrow>\n                  Rb \\<rightarrow> \\<langle>Rb\\<rangle>nres_rel;\n            (s, s') \\<in> Rb\\<rbrakk>\n           \\<Longrightarrow> (nfoldli l c f s, nfoldli l' c' f' s')\n                             \\<in> \\<langle>Rb\\<rangle>nres_rel;\n        (c, c') \\<in> Rb \\<rightarrow> bool_rel;\n        (f, f')\n        \\<in> Ra \\<rightarrow>\n              Rb \\<rightarrow> \\<langle>Rb\\<rangle>nres_rel;\n        (s, s') \\<in> Rb\\<rbrakk>\n       \\<Longrightarrow> (nfoldli (x # l) c f s, nfoldli (x' # l') c' f' s')\n                         \\<in> \\<langle>Rb\\<rangle>nres_rel", "apply (simp only: nfoldli_simps True_implies_equals)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s s'.\n       \\<lbrakk>(c, c') \\<in> Rb \\<rightarrow> bool_rel;\n        (f, f')\n        \\<in> Ra \\<rightarrow>\n              Rb \\<rightarrow> \\<langle>Rb\\<rangle>nres_rel;\n        (s, s') \\<in> Rb\\<rbrakk>\n       \\<Longrightarrow> (RETURN s, RETURN s')\n                         \\<in> \\<langle>Rb\\<rangle>nres_rel\n 2. \\<And>x x' l l' s s'.\n       \\<lbrakk>(x, x') \\<in> Ra;\n        (l, l') \\<in> \\<langle>Ra\\<rangle>list_rel;\n        \\<And>s s'.\n           \\<lbrakk>(c, c') \\<in> Rb \\<rightarrow> bool_rel;\n            (f, f')\n            \\<in> Ra \\<rightarrow>\n                  Rb \\<rightarrow> \\<langle>Rb\\<rangle>nres_rel;\n            (s, s') \\<in> Rb\\<rbrakk>\n           \\<Longrightarrow> (nfoldli l c f s, nfoldli l' c' f' s')\n                             \\<in> \\<langle>Rb\\<rangle>nres_rel;\n        (c, c') \\<in> Rb \\<rightarrow> bool_rel;\n        (f, f')\n        \\<in> Ra \\<rightarrow>\n              Rb \\<rightarrow> \\<langle>Rb\\<rangle>nres_rel;\n        (s, s') \\<in> Rb\\<rbrakk>\n       \\<Longrightarrow> (nfoldli (x # l) c f s, nfoldli (x' # l') c' f' s')\n                         \\<in> \\<langle>Rb\\<rangle>nres_rel", "apply parametricity"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x x' l l' s s'.\n       \\<lbrakk>(x, x') \\<in> Ra;\n        (l, l') \\<in> \\<langle>Ra\\<rangle>list_rel;\n        \\<And>s s'.\n           \\<lbrakk>(c, c') \\<in> Rb \\<rightarrow> bool_rel;\n            (f, f')\n            \\<in> Ra \\<rightarrow>\n                  Rb \\<rightarrow> \\<langle>Rb\\<rangle>nres_rel;\n            (s, s') \\<in> Rb\\<rbrakk>\n           \\<Longrightarrow> (nfoldli l c f s, nfoldli l' c' f' s')\n                             \\<in> \\<langle>Rb\\<rangle>nres_rel;\n        (c, c') \\<in> Rb \\<rightarrow> bool_rel;\n        (f, f')\n        \\<in> Ra \\<rightarrow>\n              Rb \\<rightarrow> \\<langle>Rb\\<rangle>nres_rel;\n        (s, s') \\<in> Rb\\<rbrakk>\n       \\<Longrightarrow> (nfoldli (x # l) c f s, nfoldli (x' # l') c' f' s')\n                         \\<in> \\<langle>Rb\\<rangle>nres_rel", "apply (simp only: nfoldli_simps True_implies_equals)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x x' l l' s s'.\n       \\<lbrakk>(x, x') \\<in> Ra;\n        (l, l') \\<in> \\<langle>Ra\\<rangle>list_rel;\n        \\<And>s s'.\n           (s, s') \\<in> Rb \\<Longrightarrow>\n           (nfoldli l c f s, nfoldli l' c' f' s')\n           \\<in> \\<langle>Rb\\<rangle>nres_rel;\n        (c, c') \\<in> Rb \\<rightarrow> bool_rel;\n        (f, f')\n        \\<in> Ra \\<rightarrow>\n              Rb \\<rightarrow> \\<langle>Rb\\<rangle>nres_rel;\n        (s, s') \\<in> Rb\\<rbrakk>\n       \\<Longrightarrow> (if c s then f x s \\<bind> nfoldli l c f\n                          else RETURN s,\n                          if c' s' then f' x' s' \\<bind> nfoldli l' c' f'\n                          else RETURN s')\n                         \\<in> \\<langle>Rb\\<rangle>nres_rel", "apply (parametricity)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (nfoldli l c f s, nfoldli l' c' f' s') \\<in> \\<langle>Rb\\<rangle>nres_rel\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma nfoldli_no_ctd[simp]: \"\\<not>ctd s \\<Longrightarrow> nfoldli l ctd f s = RETURN s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> ctd s \\<Longrightarrow> nfoldli l ctd f s = RETURN s", "by (cases l) auto"], ["", "lemma nfoldli_append[simp]: \"nfoldli (l1@l2) ctd f s = nfoldli l1 ctd f s \\<bind> nfoldli l2 ctd f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nfoldli (l1 @ l2) ctd f s = nfoldli l1 ctd f s \\<bind> nfoldli l2 ctd f", "by (induction l1 arbitrary: s) (auto simp: pw_eq_iff refine_pw_simps)"], ["", "lemma nfoldli_map: \"nfoldli (map f l) ctd g s = nfoldli l ctd (g o f) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nfoldli (map f l) ctd g s = nfoldli l ctd (g \\<circ> f) s", "apply (induction l arbitrary: s)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s. nfoldli (map f []) ctd g s = nfoldli [] ctd (g \\<circ> f) s\n 2. \\<And>a l s.\n       (\\<And>s.\n           nfoldli (map f l) ctd g s =\n           nfoldli l ctd (g \\<circ> f) s) \\<Longrightarrow>\n       nfoldli (map f (a # l)) ctd g s = nfoldli (a # l) ctd (g \\<circ> f) s", "by (auto simp: pw_eq_iff refine_pw_simps)"], ["", "lemma nfoldli_nfoldli_prod_conv: \n  \"nfoldli l2 ctd (\\<lambda>i. nfoldli l1 ctd (f i)) s = nfoldli (List.product l2 l1) ctd (\\<lambda>(i,j). f i j) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nfoldli l2 ctd (\\<lambda>i. nfoldli l1 ctd (f i)) s =\n    nfoldli (List.product l2 l1) ctd (\\<lambda>(i, j). f i j) s", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. nfoldli l2 ctd (\\<lambda>i. nfoldli l1 ctd (f i)) s =\n    nfoldli (List.product l2 l1) ctd (\\<lambda>(i, j). f i j) s", "have [simp]: \"nfoldli (map (Pair a) l) ctd (\\<lambda>(x, y). f x y) s = nfoldli l ctd (f a) s\"\n    for a l s"], ["proof (prove)\ngoal (1 subgoal):\n 1. nfoldli (map (Pair a) l) ctd (\\<lambda>(x, y). f x y) s =\n    nfoldli l ctd (f a) s", "apply (induction l arbitrary: s)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s.\n       nfoldli (map (Pair a) []) ctd (\\<lambda>(x, y). f x y) s =\n       nfoldli [] ctd (f a) s\n 2. \\<And>aa l s.\n       (\\<And>s.\n           nfoldli (map (Pair a) l) ctd (\\<lambda>(x, y). f x y) s =\n           nfoldli l ctd (f a) s) \\<Longrightarrow>\n       nfoldli (map (Pair a) (aa # l)) ctd (\\<lambda>(x, y). f x y) s =\n       nfoldli (aa # l) ctd (f a) s", "by (auto simp: pw_eq_iff refine_pw_simps)"], ["proof (state)\nthis:\n  nfoldli (map (Pair ?a) ?l) ctd (\\<lambda>(x, y). f x y) ?s =\n  nfoldli ?l ctd (f ?a) ?s\n\ngoal (1 subgoal):\n 1. nfoldli l2 ctd (\\<lambda>i. nfoldli l1 ctd (f i)) s =\n    nfoldli (List.product l2 l1) ctd (\\<lambda>(i, j). f i j) s", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. nfoldli l2 ctd (\\<lambda>i. nfoldli l1 ctd (f i)) s =\n    nfoldli (List.product l2 l1) ctd (\\<lambda>(i, j). f i j) s", "by (induction l2 arbitrary: l1 s) auto"], ["proof (state)\nthis:\n  nfoldli l2 ctd (\\<lambda>i. nfoldli l1 ctd (f i)) s =\n  nfoldli (List.product l2 l1) ctd (\\<lambda>(i, j). f i j) s\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>The fold-function over the nres-monad is transfered to a plain \n  foldli function\\<close>"], ["", "lemma nfoldli_transfer_plain[refine_transfer]:\n  assumes \"\\<And>x s. RETURN (f x s) \\<le> f' x s\"\n  shows \"RETURN (foldli l c f s) \\<le> (nfoldli l c f' s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RETURN (foldli l c f s) \\<le> nfoldli l c f' s", "using assms"], ["proof (prove)\nusing this:\n  RETURN (f ?x ?s) \\<le> f' ?x ?s\n\ngoal (1 subgoal):\n 1. RETURN (foldli l c f s) \\<le> nfoldli l c f' s", "apply (induct l arbitrary: s)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s.\n       (\\<And>x s. RETURN (f x s) \\<le> f' x s) \\<Longrightarrow>\n       RETURN (foldli [] c f s) \\<le> nfoldli [] c f' s\n 2. \\<And>a l s.\n       \\<lbrakk>\\<And>s.\n                   (\\<And>x s.\n                       RETURN (f x s) \\<le> f' x s) \\<Longrightarrow>\n                   RETURN (foldli l c f s) \\<le> nfoldli l c f' s;\n        \\<And>x s. RETURN (f x s) \\<le> f' x s\\<rbrakk>\n       \\<Longrightarrow> RETURN (foldli (a # l) c f s)\n                         \\<le> nfoldli (a # l) c f' s", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a l s.\n       \\<lbrakk>\\<And>s. RETURN (foldli l c f s) \\<le> nfoldli l c f' s;\n        \\<And>x s. RETURN (f x s) \\<le> f' x s; c s\\<rbrakk>\n       \\<Longrightarrow> RETURN (foldli l c f (f a s))\n                         \\<le> f' a s \\<bind> nfoldli l c f'", "by (metis (lifting) plain_bind)"], ["", "lemma nfoldli_transfer_dres[refine_transfer]:\n  fixes l :: \"'a list\" and c:: \"'b \\<Rightarrow> bool\"\n  assumes FR: \"\\<And>x s. nres_of (f x s) \\<le> f' x s\"\n  shows \"nres_of \n    (foldli l (case_dres False False c) (\\<lambda>x s. s\\<bind>f x) (dRETURN s)) \n    \\<le> (nfoldli l c f' s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nres_of\n     (foldli l (case_dres False False c) (\\<lambda>x s. s \\<bind> f x)\n       (dRETURN s))\n    \\<le> nfoldli l c f' s", "proof (induct l arbitrary: s)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s.\n       nres_of\n        (foldli [] (case_dres False False c) (\\<lambda>x s. s \\<bind> f x)\n          (dRETURN s))\n       \\<le> nfoldli [] c f' s\n 2. \\<And>a l s.\n       (\\<And>s.\n           nres_of\n            (foldli l (case_dres False False c)\n              (\\<lambda>x s. s \\<bind> f x) (dRETURN s))\n           \\<le> nfoldli l c f' s) \\<Longrightarrow>\n       nres_of\n        (foldli (a # l) (case_dres False False c)\n          (\\<lambda>x s. s \\<bind> f x) (dRETURN s))\n       \\<le> nfoldli (a # l) c f' s", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>s.\n       nres_of\n        (foldli [] (case_dres False False c) (\\<lambda>x s. s \\<bind> f x)\n          (dRETURN s))\n       \\<le> nfoldli [] c f' s\n 2. \\<And>a l s.\n       (\\<And>s.\n           nres_of\n            (foldli l (case_dres False False c)\n              (\\<lambda>x s. s \\<bind> f x) (dRETURN s))\n           \\<le> nfoldli l c f' s) \\<Longrightarrow>\n       nres_of\n        (foldli (a # l) (case_dres False False c)\n          (\\<lambda>x s. s \\<bind> f x) (dRETURN s))\n       \\<le> nfoldli (a # l) c f' s", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. nres_of\n     (foldli []\n       (\\<lambda>a.\n           case a of dRETURN a \\<Rightarrow> c a | _ \\<Rightarrow> False)\n       (\\<lambda>x s. s \\<bind> f x) (dRETURN s))\n    \\<le> nfoldli [] c f' s", "by auto"], ["proof (state)\nthis:\n  nres_of\n   (foldli []\n     (\\<lambda>a.\n         case a of dRETURN a \\<Rightarrow> c a | _ \\<Rightarrow> False)\n     (\\<lambda>x s. s \\<bind> f x) (dRETURN s))\n  \\<le> nfoldli [] c f' s\n\ngoal (1 subgoal):\n 1. \\<And>a l s.\n       (\\<And>s.\n           nres_of\n            (foldli l (case_dres False False c)\n              (\\<lambda>x s. s \\<bind> f x) (dRETURN s))\n           \\<le> nfoldli l c f' s) \\<Longrightarrow>\n       nres_of\n        (foldli (a # l) (case_dres False False c)\n          (\\<lambda>x s. s \\<bind> f x) (dRETURN s))\n       \\<le> nfoldli (a # l) c f' s", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a l s.\n       (\\<And>s.\n           nres_of\n            (foldli l (case_dres False False c)\n              (\\<lambda>x s. s \\<bind> f x) (dRETURN s))\n           \\<le> nfoldli l c f' s) \\<Longrightarrow>\n       nres_of\n        (foldli (a # l) (case_dres False False c)\n          (\\<lambda>x s. s \\<bind> f x) (dRETURN s))\n       \\<le> nfoldli (a # l) c f' s", "case (Cons a l)"], ["proof (state)\nthis:\n  nres_of\n   (foldli l\n     (\\<lambda>a.\n         case a of dRETURN a \\<Rightarrow> c a | _ \\<Rightarrow> False)\n     (\\<lambda>x s. s \\<bind> f x) (dRETURN ?s))\n  \\<le> nfoldli l c f' ?s\n\ngoal (1 subgoal):\n 1. \\<And>a l s.\n       (\\<And>s.\n           nres_of\n            (foldli l (case_dres False False c)\n              (\\<lambda>x s. s \\<bind> f x) (dRETURN s))\n           \\<le> nfoldli l c f' s) \\<Longrightarrow>\n       nres_of\n        (foldli (a # l) (case_dres False False c)\n          (\\<lambda>x s. s \\<bind> f x) (dRETURN s))\n       \\<le> nfoldli (a # l) c f' s", "thus ?case"], ["proof (prove)\nusing this:\n  nres_of\n   (foldli l\n     (\\<lambda>a.\n         case a of dRETURN a \\<Rightarrow> c a | _ \\<Rightarrow> False)\n     (\\<lambda>x s. s \\<bind> f x) (dRETURN ?s))\n  \\<le> nfoldli l c f' ?s\n\ngoal (1 subgoal):\n 1. nres_of\n     (foldli (a # l)\n       (\\<lambda>a.\n           case a of dRETURN a \\<Rightarrow> c a | _ \\<Rightarrow> False)\n       (\\<lambda>x s. s \\<bind> f x) (dRETURN s))\n    \\<le> nfoldli (a # l) c f' s", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>s.\n                nres_of\n                 (foldli l\n                   (\\<lambda>a.\n                       case a of dRETURN a \\<Rightarrow> c a\n                       | _ \\<Rightarrow> False)\n                   (\\<lambda>x s. s \\<bind> f x) (dRETURN s))\n                \\<le> nfoldli l c f' s;\n     c s\\<rbrakk>\n    \\<Longrightarrow> nres_of\n                       (foldli l (case_dres False False c)\n                         (\\<lambda>x s. s \\<bind> f x) (f a s))\n                      \\<le> f' a s \\<bind> nfoldli l c f'", "apply (cases \"f a s\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<And>s.\n                nres_of\n                 (foldli l\n                   (\\<lambda>a.\n                       case a of dRETURN a \\<Rightarrow> c a\n                       | _ \\<Rightarrow> False)\n                   (\\<lambda>x s. s \\<bind> f x) (dRETURN s))\n                \\<le> nfoldli l c f' s;\n     c s; f a s = dSUCCEED\\<rbrakk>\n    \\<Longrightarrow> nres_of\n                       (foldli l (case_dres False False c)\n                         (\\<lambda>x s. s \\<bind> f x) (f a s))\n                      \\<le> f' a s \\<bind> nfoldli l c f'\n 2. \\<And>r.\n       \\<lbrakk>\\<And>s.\n                   nres_of\n                    (foldli l\n                      (\\<lambda>a.\n                          case a of dRETURN a \\<Rightarrow> c a\n                          | _ \\<Rightarrow> False)\n                      (\\<lambda>x s. s \\<bind> f x) (dRETURN s))\n                   \\<le> nfoldli l c f' s;\n        c s; f a s = dRETURN r\\<rbrakk>\n       \\<Longrightarrow> nres_of\n                          (foldli l (case_dres False False c)\n                            (\\<lambda>x s. s \\<bind> f x) (f a s))\n                         \\<le> f' a s \\<bind> nfoldli l c f'\n 3. \\<lbrakk>\\<And>s.\n                nres_of\n                 (foldli l\n                   (\\<lambda>a.\n                       case a of dRETURN a \\<Rightarrow> c a\n                       | _ \\<Rightarrow> False)\n                   (\\<lambda>x s. s \\<bind> f x) (dRETURN s))\n                \\<le> nfoldli l c f' s;\n     c s; f a s = dFAIL\\<rbrakk>\n    \\<Longrightarrow> nres_of\n                       (foldli l (case_dres False False c)\n                         (\\<lambda>x s. s \\<bind> f x) (f a s))\n                      \\<le> f' a s \\<bind> nfoldli l c f'", "apply (cases l, simp_all) []"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>r.\n       \\<lbrakk>\\<And>s.\n                   nres_of\n                    (foldli l\n                      (\\<lambda>a.\n                          case a of dRETURN a \\<Rightarrow> c a\n                          | _ \\<Rightarrow> False)\n                      (\\<lambda>x s. s \\<bind> f x) (dRETURN s))\n                   \\<le> nfoldli l c f' s;\n        c s; f a s = dRETURN r\\<rbrakk>\n       \\<Longrightarrow> nres_of\n                          (foldli l (case_dres False False c)\n                            (\\<lambda>x s. s \\<bind> f x) (f a s))\n                         \\<le> f' a s \\<bind> nfoldli l c f'\n 2. \\<lbrakk>\\<And>s.\n                nres_of\n                 (foldli l\n                   (\\<lambda>a.\n                       case a of dRETURN a \\<Rightarrow> c a\n                       | _ \\<Rightarrow> False)\n                   (\\<lambda>x s. s \\<bind> f x) (dRETURN s))\n                \\<le> nfoldli l c f' s;\n     c s; f a s = dFAIL\\<rbrakk>\n    \\<Longrightarrow> nres_of\n                       (foldli l (case_dres False False c)\n                         (\\<lambda>x s. s \\<bind> f x) (f a s))\n                      \\<le> f' a s \\<bind> nfoldli l c f'", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>r.\n       \\<lbrakk>\\<And>s.\n                   nres_of\n                    (foldli l\n                      (\\<lambda>a.\n                          case a of dRETURN a \\<Rightarrow> c a\n                          | _ \\<Rightarrow> False)\n                      (\\<lambda>x s. s \\<bind> f x) (dRETURN s))\n                   \\<le> nfoldli l c f' s;\n        c s; f a s = dRETURN r\\<rbrakk>\n       \\<Longrightarrow> nres_of\n                          (foldli l (case_dres False False c)\n                            (\\<lambda>x s. s \\<bind> f x) (dRETURN r))\n                         \\<le> f' a s \\<bind> nfoldli l c f'\n 2. \\<lbrakk>\\<And>s.\n                nres_of\n                 (foldli l\n                   (\\<lambda>a.\n                       case a of dRETURN a \\<Rightarrow> c a\n                       | _ \\<Rightarrow> False)\n                   (\\<lambda>x s. s \\<bind> f x) (dRETURN s))\n                \\<le> nfoldli l c f' s;\n     c s; f a s = dFAIL\\<rbrakk>\n    \\<Longrightarrow> nres_of\n                       (foldli l (case_dres False False c)\n                         (\\<lambda>x s. s \\<bind> f x) (f a s))\n                      \\<le> f' a s \\<bind> nfoldli l c f'", "apply (rule order_trans[rotated])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>r.\n       \\<lbrakk>\\<And>s.\n                   nres_of\n                    (foldli l\n                      (\\<lambda>a.\n                          case a of dRETURN a \\<Rightarrow> c a\n                          | _ \\<Rightarrow> False)\n                      (\\<lambda>x s. s \\<bind> f x) (dRETURN s))\n                   \\<le> nfoldli l c f' s;\n        c s; f a s = dRETURN r\\<rbrakk>\n       \\<Longrightarrow> ?y11 r \\<le> f' a s \\<bind> nfoldli l c f'\n 2. \\<And>r.\n       \\<lbrakk>\\<And>s.\n                   nres_of\n                    (foldli l\n                      (\\<lambda>a.\n                          case a of dRETURN a \\<Rightarrow> c a\n                          | _ \\<Rightarrow> False)\n                      (\\<lambda>x s. s \\<bind> f x) (dRETURN s))\n                   \\<le> nfoldli l c f' s;\n        c s; f a s = dRETURN r\\<rbrakk>\n       \\<Longrightarrow> nres_of\n                          (foldli l (case_dres False False c)\n                            (\\<lambda>x s. s \\<bind> f x) (dRETURN r))\n                         \\<le> ?y11 r\n 3. \\<lbrakk>\\<And>s.\n                nres_of\n                 (foldli l\n                   (\\<lambda>a.\n                       case a of dRETURN a \\<Rightarrow> c a\n                       | _ \\<Rightarrow> False)\n                   (\\<lambda>x s. s \\<bind> f x) (dRETURN s))\n                \\<le> nfoldli l c f' s;\n     c s; f a s = dFAIL\\<rbrakk>\n    \\<Longrightarrow> nres_of\n                       (foldli l (case_dres False False c)\n                         (\\<lambda>x s. s \\<bind> f x) (f a s))\n                      \\<le> f' a s \\<bind> nfoldli l c f'", "apply (rule bind_mono)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>r.\n       \\<lbrakk>\\<And>s.\n                   nres_of\n                    (foldli l\n                      (\\<lambda>a.\n                          case a of dRETURN a \\<Rightarrow> c a\n                          | _ \\<Rightarrow> False)\n                      (\\<lambda>x s. s \\<bind> f x) (dRETURN s))\n                   \\<le> nfoldli l c f' s;\n        c s; f a s = dRETURN r\\<rbrakk>\n       \\<Longrightarrow> ?M14 r \\<le> f' a s\n 2. \\<And>r x.\n       \\<lbrakk>\\<And>s.\n                   nres_of\n                    (foldli l\n                      (\\<lambda>a.\n                          case a of dRETURN a \\<Rightarrow> c a\n                          | _ \\<Rightarrow> False)\n                      (\\<lambda>x s. s \\<bind> f x) (dRETURN s))\n                   \\<le> nfoldli l c f' s;\n        c s; f a s = dRETURN r; RETURN x \\<le> ?M14 r\\<rbrakk>\n       \\<Longrightarrow> ?f14 r x \\<le> nfoldli l c f' x\n 3. \\<And>r.\n       \\<lbrakk>\\<And>s.\n                   nres_of\n                    (foldli l\n                      (\\<lambda>a.\n                          case a of dRETURN a \\<Rightarrow> c a\n                          | _ \\<Rightarrow> False)\n                      (\\<lambda>x s. s \\<bind> f x) (dRETURN s))\n                   \\<le> nfoldli l c f' s;\n        c s; f a s = dRETURN r\\<rbrakk>\n       \\<Longrightarrow> nres_of\n                          (foldli l (case_dres False False c)\n                            (\\<lambda>x s. s \\<bind> f x) (dRETURN r))\n                         \\<le> ?M14 r \\<bind> ?f14 r\n 4. \\<lbrakk>\\<And>s.\n                nres_of\n                 (foldli l\n                   (\\<lambda>a.\n                       case a of dRETURN a \\<Rightarrow> c a\n                       | _ \\<Rightarrow> False)\n                   (\\<lambda>x s. s \\<bind> f x) (dRETURN s))\n                \\<le> nfoldli l c f' s;\n     c s; f a s = dFAIL\\<rbrakk>\n    \\<Longrightarrow> nres_of\n                       (foldli l (case_dres False False c)\n                         (\\<lambda>x s. s \\<bind> f x) (f a s))\n                      \\<le> f' a s \\<bind> nfoldli l c f'", "apply (rule FR)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>r x.\n       \\<lbrakk>\\<And>s.\n                   nres_of\n                    (foldli l\n                      (\\<lambda>a.\n                          case a of dRETURN a \\<Rightarrow> c a\n                          | _ \\<Rightarrow> False)\n                      (\\<lambda>x s. s \\<bind> f x) (dRETURN s))\n                   \\<le> nfoldli l c f' s;\n        c s; f a s = dRETURN r; RETURN x \\<le> nres_of (f a s)\\<rbrakk>\n       \\<Longrightarrow> ?f14 r x \\<le> nfoldli l c f' x\n 2. \\<And>r.\n       \\<lbrakk>\\<And>s.\n                   nres_of\n                    (foldli l\n                      (\\<lambda>a.\n                          case a of dRETURN a \\<Rightarrow> c a\n                          | _ \\<Rightarrow> False)\n                      (\\<lambda>x s. s \\<bind> f x) (dRETURN s))\n                   \\<le> nfoldli l c f' s;\n        c s; f a s = dRETURN r\\<rbrakk>\n       \\<Longrightarrow> nres_of\n                          (foldli l (case_dres False False c)\n                            (\\<lambda>x s. s \\<bind> f x) (dRETURN r))\n                         \\<le> nres_of (f a s) \\<bind> ?f14 r\n 3. \\<lbrakk>\\<And>s.\n                nres_of\n                 (foldli l\n                   (\\<lambda>a.\n                       case a of dRETURN a \\<Rightarrow> c a\n                       | _ \\<Rightarrow> False)\n                   (\\<lambda>x s. s \\<bind> f x) (dRETURN s))\n                \\<le> nfoldli l c f' s;\n     c s; f a s = dFAIL\\<rbrakk>\n    \\<Longrightarrow> nres_of\n                       (foldli l (case_dres False False c)\n                         (\\<lambda>x s. s \\<bind> f x) (f a s))\n                      \\<le> f' a s \\<bind> nfoldli l c f'", "apply assumption"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>r.\n       \\<lbrakk>\\<And>s.\n                   nres_of\n                    (foldli l\n                      (\\<lambda>a.\n                          case a of dRETURN a \\<Rightarrow> c a\n                          | _ \\<Rightarrow> False)\n                      (\\<lambda>x s. s \\<bind> f x) (dRETURN s))\n                   \\<le> nfoldli l c f' s;\n        c s; f a s = dRETURN r\\<rbrakk>\n       \\<Longrightarrow> nres_of\n                          (foldli l (case_dres False False c)\n                            (\\<lambda>x s. s \\<bind> f x) (dRETURN r))\n                         \\<le> nres_of (f a s) \\<bind>\n                               (\\<lambda>x.\n                                   nres_of\n                                    (foldli l (case_dres False False c)\n(\\<lambda>x s. s \\<bind> f x) (dRETURN x)))\n 2. \\<lbrakk>\\<And>s.\n                nres_of\n                 (foldli l\n                   (\\<lambda>a.\n                       case a of dRETURN a \\<Rightarrow> c a\n                       | _ \\<Rightarrow> False)\n                   (\\<lambda>x s. s \\<bind> f x) (dRETURN s))\n                \\<le> nfoldli l c f' s;\n     c s; f a s = dFAIL\\<rbrakk>\n    \\<Longrightarrow> nres_of\n                       (foldli l (case_dres False False c)\n                         (\\<lambda>x s. s \\<bind> f x) (f a s))\n                      \\<le> f' a s \\<bind> nfoldli l c f'", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>s.\n                nres_of\n                 (foldli l\n                   (\\<lambda>a.\n                       case a of dRETURN a \\<Rightarrow> c a\n                       | _ \\<Rightarrow> False)\n                   (\\<lambda>x s. s \\<bind> f x) (dRETURN s))\n                \\<le> nfoldli l c f' s;\n     c s; f a s = dFAIL\\<rbrakk>\n    \\<Longrightarrow> nres_of\n                       (foldli l (case_dres False False c)\n                         (\\<lambda>x s. s \\<bind> f x) (f a s))\n                      \\<le> f' a s \\<bind> nfoldli l c f'", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>s.\n                nres_of\n                 (foldli l\n                   (\\<lambda>a.\n                       case a of dRETURN a \\<Rightarrow> c a\n                       | _ \\<Rightarrow> False)\n                   (\\<lambda>x s. s \\<bind> f x) (dRETURN s))\n                \\<le> nfoldli l c f' s;\n     c s; f a s = dFAIL\\<rbrakk>\n    \\<Longrightarrow> f' a s \\<bind> nfoldli l c f' = FAIL", "using FR[of a s]"], ["proof (prove)\nusing this:\n  nres_of (f a s) \\<le> f' a s\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>s.\n                nres_of\n                 (foldli l\n                   (\\<lambda>a.\n                       case a of dRETURN a \\<Rightarrow> c a\n                       | _ \\<Rightarrow> False)\n                   (\\<lambda>x s. s \\<bind> f x) (dRETURN s))\n                \\<le> nfoldli l c f' s;\n     c s; f a s = dFAIL\\<rbrakk>\n    \\<Longrightarrow> f' a s \\<bind> nfoldli l c f' = FAIL", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  nres_of\n   (foldli (a # l)\n     (\\<lambda>a.\n         case a of dRETURN a \\<Rightarrow> c a | _ \\<Rightarrow> False)\n     (\\<lambda>x s. s \\<bind> f x) (dRETURN s))\n  \\<le> nfoldli (a # l) c f' s\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma nfoldli_mono[refine_mono]: \n  \"\\<lbrakk> \\<And>x s. f x s \\<le> f' x s \\<rbrakk> \\<Longrightarrow> nfoldli l c f \\<sigma> \\<le> nfoldli l c f' \\<sigma>\"\n  \"\\<lbrakk> \\<And>x s. flat_ge (f x s) (f' x s) \\<rbrakk> \\<Longrightarrow> flat_ge (nfoldli l c f \\<sigma>) (nfoldli l c f' \\<sigma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<And>x s. f x s \\<le> f' x s) \\<Longrightarrow>\n     nfoldli l c f \\<sigma> \\<le> nfoldli l c f' \\<sigma>) &&&\n    ((\\<And>x s. flat_ge (f x s) (f' x s)) \\<Longrightarrow>\n     flat_ge (nfoldli l c f \\<sigma>) (nfoldli l c f' \\<sigma>))", "apply (induct l arbitrary: \\<sigma>)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>\\<sigma>.\n       (\\<And>x s. f x s \\<le> f' x s) \\<Longrightarrow>\n       nfoldli [] c f \\<sigma> \\<le> nfoldli [] c f' \\<sigma>\n 2. \\<And>\\<sigma>.\n       (\\<And>x s. flat_ge (f x s) (f' x s)) \\<Longrightarrow>\n       flat_ge (nfoldli [] c f \\<sigma>) (nfoldli [] c f' \\<sigma>)\n 3. \\<And>a l \\<sigma>.\n       \\<lbrakk>\\<And>\\<sigma>.\n                   (\\<And>x s. f x s \\<le> f' x s) \\<Longrightarrow>\n                   nfoldli l c f \\<sigma> \\<le> nfoldli l c f' \\<sigma>;\n        \\<And>\\<sigma>.\n           (\\<And>x s. flat_ge (f x s) (f' x s)) \\<Longrightarrow>\n           flat_ge (nfoldli l c f \\<sigma>) (nfoldli l c f' \\<sigma>);\n        \\<And>x s. f x s \\<le> f' x s\\<rbrakk>\n       \\<Longrightarrow> nfoldli (a # l) c f \\<sigma>\n                         \\<le> nfoldli (a # l) c f' \\<sigma>\n 4. \\<And>a l \\<sigma>.\n       \\<lbrakk>\\<And>\\<sigma>.\n                   (\\<And>x s. f x s \\<le> f' x s) \\<Longrightarrow>\n                   nfoldli l c f \\<sigma> \\<le> nfoldli l c f' \\<sigma>;\n        \\<And>\\<sigma>.\n           (\\<And>x s. flat_ge (f x s) (f' x s)) \\<Longrightarrow>\n           flat_ge (nfoldli l c f \\<sigma>) (nfoldli l c f' \\<sigma>);\n        \\<And>x s. flat_ge (f x s) (f' x s)\\<rbrakk>\n       \\<Longrightarrow> flat_ge (nfoldli (a # l) c f \\<sigma>)\n                          (nfoldli (a # l) c f' \\<sigma>)", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a l \\<sigma>.\n       \\<lbrakk>\\<And>\\<sigma>.\n                   nfoldli l c f \\<sigma> \\<le> nfoldli l c f' \\<sigma>;\n        \\<And>\\<sigma>.\n           (\\<And>x s. flat_ge (f x s) (f' x s)) \\<Longrightarrow>\n           flat_ge (nfoldli l c f \\<sigma>) (nfoldli l c f' \\<sigma>);\n        \\<And>x s. f x s \\<le> f' x s; c \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> f a \\<sigma> \\<bind> nfoldli l c f\n                         \\<le> f' a \\<sigma> \\<bind> nfoldli l c f'\n 2. \\<And>a l \\<sigma>.\n       \\<lbrakk>\\<And>\\<sigma>.\n                   (\\<And>x s. f x s \\<le> f' x s) \\<Longrightarrow>\n                   nfoldli l c f \\<sigma> \\<le> nfoldli l c f' \\<sigma>;\n        \\<And>\\<sigma>.\n           flat_ge (nfoldli l c f \\<sigma>) (nfoldli l c f' \\<sigma>);\n        \\<And>x s. flat_ge (f x s) (f' x s); c \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> flat_ge (f a \\<sigma> \\<bind> nfoldli l c f)\n                          (f' a \\<sigma> \\<bind> nfoldli l c f')", "apply refine_mono"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a l \\<sigma>.\n       \\<lbrakk>\\<And>\\<sigma>.\n                   (\\<And>x s. f x s \\<le> f' x s) \\<Longrightarrow>\n                   nfoldli l c f \\<sigma> \\<le> nfoldli l c f' \\<sigma>;\n        \\<And>\\<sigma>.\n           flat_ge (nfoldli l c f \\<sigma>) (nfoldli l c f' \\<sigma>);\n        \\<And>x s. flat_ge (f x s) (f' x s); c \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> flat_ge (f a \\<sigma> \\<bind> nfoldli l c f)\n                          (f' a \\<sigma> \\<bind> nfoldli l c f')", "apply (induct l arbitrary: \\<sigma>)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a l \\<sigma>.\n       \\<lbrakk>\\<And>\\<sigma>.\n                   (\\<And>x s. f x s \\<le> f' x s) \\<Longrightarrow>\n                   nfoldli l c f \\<sigma> \\<le> nfoldli l c f' \\<sigma>;\n        \\<And>\\<sigma>.\n           flat_ge (nfoldli l c f \\<sigma>) (nfoldli l c f' \\<sigma>);\n        \\<And>x s. flat_ge (f x s) (f' x s); c \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> flat_ge (f a \\<sigma> \\<bind> nfoldli l c f)\n                          (f' a \\<sigma> \\<bind> nfoldli l c f')\n 2. \\<And>a l aa la \\<sigma>.\n       \\<lbrakk>\\<And>a l \\<sigma>.\n                   \\<lbrakk>\\<And>\\<sigma>.\n                               (\\<And>x s.\n                                   f x s \\<le> f' x s) \\<Longrightarrow>\n                               nfoldli l c f \\<sigma>\n                               \\<le> nfoldli l c f' \\<sigma>;\n                    \\<And>\\<sigma>.\n                       flat_ge (nfoldli l c f \\<sigma>)\n                        (nfoldli l c f' \\<sigma>);\n                    \\<And>x s. flat_ge (f x s) (f' x s); c \\<sigma>\\<rbrakk>\n                   \\<Longrightarrow> flat_ge\n(f a \\<sigma> \\<bind> nfoldli l c f) (f' a \\<sigma> \\<bind> nfoldli l c f');\n        \\<And>\\<sigma>.\n           (\\<And>x s. f x s \\<le> f' x s) \\<Longrightarrow>\n           nfoldli la c f \\<sigma> \\<le> nfoldli la c f' \\<sigma>;\n        \\<And>\\<sigma>.\n           flat_ge (nfoldli la c f \\<sigma>) (nfoldli la c f' \\<sigma>);\n        \\<And>x s. flat_ge (f x s) (f' x s); c \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> flat_ge (f aa \\<sigma> \\<bind> nfoldli la c f)\n                          (f' aa \\<sigma> \\<bind> nfoldli la c f')", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a l \\<sigma>.\n       \\<lbrakk>\\<And>\\<sigma>.\n                   (\\<And>x s. f x s \\<le> f' x s) \\<Longrightarrow>\n                   nfoldli l c f \\<sigma> \\<le> nfoldli l c f' \\<sigma>;\n        \\<And>\\<sigma>.\n           flat_ge (nfoldli l c f \\<sigma>) (nfoldli l c f' \\<sigma>);\n        \\<And>x s. flat_ge (f x s) (f' x s); c \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> flat_ge (f a \\<sigma> \\<bind> nfoldli l c f)\n                          (f' a \\<sigma> \\<bind> nfoldli l c f')", "apply refine_mono"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>We relate our fold-function to the while-loop that we used in\n  the original definition of the foreach-loop\\<close>"], ["", "lemma nfoldli_while: \"nfoldli l c f \\<sigma>\n          \\<le>\n         (WHILE\\<^sub>T\\<^bsup>I\\<^esup>\n           (FOREACH_cond c) (FOREACH_body f) (l, \\<sigma>) \\<bind>\n          (\\<lambda>(_, \\<sigma>). RETURN \\<sigma>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nfoldli l c f \\<sigma>\n    \\<le> WHILE\\<^sub>T\\<^bsup>I\\<^esup> (FOREACH_cond c) (FOREACH_body f)\n           (l, \\<sigma>) \\<bind>\n          (\\<lambda>(uu_, \\<sigma>). RETURN \\<sigma>)", "proof (induct l arbitrary: \\<sigma>)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>\\<sigma>.\n       nfoldli [] c f \\<sigma>\n       \\<le> WHILE\\<^sub>T\\<^bsup>I\\<^esup> (FOREACH_cond c)\n              (FOREACH_body f) ([], \\<sigma>) \\<bind>\n             (\\<lambda>(uu_, y). RETURN y)\n 2. \\<And>a l \\<sigma>.\n       (\\<And>\\<sigma>.\n           nfoldli l c f \\<sigma>\n           \\<le> WHILE\\<^sub>T\\<^bsup>I\\<^esup> (FOREACH_cond c)\n                  (FOREACH_body f) (l, \\<sigma>) \\<bind>\n                 (\\<lambda>(uu_, y). RETURN y)) \\<Longrightarrow>\n       nfoldli (a # l) c f \\<sigma>\n       \\<le> WHILE\\<^sub>T\\<^bsup>I\\<^esup> (FOREACH_cond c)\n              (FOREACH_body f) (a # l, \\<sigma>) \\<bind>\n             (\\<lambda>(uu_, y). RETURN y)", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>\\<sigma>.\n       nfoldli [] c f \\<sigma>\n       \\<le> WHILE\\<^sub>T\\<^bsup>I\\<^esup> (FOREACH_cond c)\n              (FOREACH_body f) ([], \\<sigma>) \\<bind>\n             (\\<lambda>(uu_, y). RETURN y)\n 2. \\<And>a l \\<sigma>.\n       (\\<And>\\<sigma>.\n           nfoldli l c f \\<sigma>\n           \\<le> WHILE\\<^sub>T\\<^bsup>I\\<^esup> (FOREACH_cond c)\n                  (FOREACH_body f) (l, \\<sigma>) \\<bind>\n                 (\\<lambda>(uu_, y). RETURN y)) \\<Longrightarrow>\n       nfoldli (a # l) c f \\<sigma>\n       \\<le> WHILE\\<^sub>T\\<^bsup>I\\<^esup> (FOREACH_cond c)\n              (FOREACH_body f) (a # l, \\<sigma>) \\<bind>\n             (\\<lambda>(uu_, y). RETURN y)", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. nfoldli [] c f \\<sigma>\n    \\<le> WHILE\\<^sub>T\\<^bsup>I\\<^esup> (FOREACH_cond c) (FOREACH_body f)\n           ([], \\<sigma>) \\<bind>\n          (\\<lambda>a. case a of (uu_, a) \\<Rightarrow> RETURN a)", "by (subst WHILEIT_unfold) (auto simp: FOREACH_cond_def)"], ["proof (state)\nthis:\n  nfoldli [] c f \\<sigma>\n  \\<le> WHILE\\<^sub>T\\<^bsup>I\\<^esup> (FOREACH_cond c) (FOREACH_body f)\n         ([], \\<sigma>) \\<bind>\n        (\\<lambda>a. case a of (uu_, a) \\<Rightarrow> RETURN a)\n\ngoal (1 subgoal):\n 1. \\<And>a l \\<sigma>.\n       (\\<And>\\<sigma>.\n           nfoldli l c f \\<sigma>\n           \\<le> WHILE\\<^sub>T\\<^bsup>I\\<^esup> (FOREACH_cond c)\n                  (FOREACH_body f) (l, \\<sigma>) \\<bind>\n                 (\\<lambda>(uu_, y). RETURN y)) \\<Longrightarrow>\n       nfoldli (a # l) c f \\<sigma>\n       \\<le> WHILE\\<^sub>T\\<^bsup>I\\<^esup> (FOREACH_cond c)\n              (FOREACH_body f) (a # l, \\<sigma>) \\<bind>\n             (\\<lambda>(uu_, y). RETURN y)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a l \\<sigma>.\n       (\\<And>\\<sigma>.\n           nfoldli l c f \\<sigma>\n           \\<le> WHILE\\<^sub>T\\<^bsup>I\\<^esup> (FOREACH_cond c)\n                  (FOREACH_body f) (l, \\<sigma>) \\<bind>\n                 (\\<lambda>(uu_, y). RETURN y)) \\<Longrightarrow>\n       nfoldli (a # l) c f \\<sigma>\n       \\<le> WHILE\\<^sub>T\\<^bsup>I\\<^esup> (FOREACH_cond c)\n              (FOREACH_body f) (a # l, \\<sigma>) \\<bind>\n             (\\<lambda>(uu_, y). RETURN y)", "case (Cons x ls)"], ["proof (state)\nthis:\n  nfoldli ls c f ?\\<sigma>\n  \\<le> WHILE\\<^sub>T\\<^bsup>I\\<^esup> (FOREACH_cond c) (FOREACH_body f)\n         (ls, ?\\<sigma>) \\<bind>\n        (\\<lambda>a. case a of (uu_, a) \\<Rightarrow> RETURN a)\n\ngoal (1 subgoal):\n 1. \\<And>a l \\<sigma>.\n       (\\<And>\\<sigma>.\n           nfoldli l c f \\<sigma>\n           \\<le> WHILE\\<^sub>T\\<^bsup>I\\<^esup> (FOREACH_cond c)\n                  (FOREACH_body f) (l, \\<sigma>) \\<bind>\n                 (\\<lambda>(uu_, y). RETURN y)) \\<Longrightarrow>\n       nfoldli (a # l) c f \\<sigma>\n       \\<le> WHILE\\<^sub>T\\<^bsup>I\\<^esup> (FOREACH_cond c)\n              (FOREACH_body f) (a # l, \\<sigma>) \\<bind>\n             (\\<lambda>(uu_, y). RETURN y)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. nfoldli (x # ls) c f \\<sigma>\n    \\<le> WHILE\\<^sub>T\\<^bsup>I\\<^esup> (FOREACH_cond c) (FOREACH_body f)\n           (x # ls, \\<sigma>) \\<bind>\n          (\\<lambda>a. case a of (uu_, a) \\<Rightarrow> RETURN a)", "proof (cases \"c \\<sigma>\")"], ["proof (state)\ngoal (2 subgoals):\n 1. c \\<sigma> \\<Longrightarrow>\n    nfoldli (x # ls) c f \\<sigma>\n    \\<le> WHILE\\<^sub>T\\<^bsup>I\\<^esup> (FOREACH_cond c) (FOREACH_body f)\n           (x # ls, \\<sigma>) \\<bind>\n          (\\<lambda>a. case a of (uu_, a) \\<Rightarrow> RETURN a)\n 2. \\<not> c \\<sigma> \\<Longrightarrow>\n    nfoldli (x # ls) c f \\<sigma>\n    \\<le> WHILE\\<^sub>T\\<^bsup>I\\<^esup> (FOREACH_cond c) (FOREACH_body f)\n           (x # ls, \\<sigma>) \\<bind>\n          (\\<lambda>a. case a of (uu_, a) \\<Rightarrow> RETURN a)", "case False"], ["proof (state)\nthis:\n  \\<not> c \\<sigma>\n\ngoal (2 subgoals):\n 1. c \\<sigma> \\<Longrightarrow>\n    nfoldli (x # ls) c f \\<sigma>\n    \\<le> WHILE\\<^sub>T\\<^bsup>I\\<^esup> (FOREACH_cond c) (FOREACH_body f)\n           (x # ls, \\<sigma>) \\<bind>\n          (\\<lambda>a. case a of (uu_, a) \\<Rightarrow> RETURN a)\n 2. \\<not> c \\<sigma> \\<Longrightarrow>\n    nfoldli (x # ls) c f \\<sigma>\n    \\<le> WHILE\\<^sub>T\\<^bsup>I\\<^esup> (FOREACH_cond c) (FOREACH_body f)\n           (x # ls, \\<sigma>) \\<bind>\n          (\\<lambda>a. case a of (uu_, a) \\<Rightarrow> RETURN a)", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> c \\<sigma>\n\ngoal (1 subgoal):\n 1. nfoldli (x # ls) c f \\<sigma>\n    \\<le> WHILE\\<^sub>T\\<^bsup>I\\<^esup> (FOREACH_cond c) (FOREACH_body f)\n           (x # ls, \\<sigma>) \\<bind>\n          (\\<lambda>a. case a of (uu_, a) \\<Rightarrow> RETURN a)", "apply (subst WHILEIT_unfold)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> c \\<sigma> \\<Longrightarrow>\n    nfoldli (x # ls) c f \\<sigma>\n    \\<le> (if I (x # ls, \\<sigma>)\n           then if FOREACH_cond c (x # ls, \\<sigma>)\n                then FOREACH_body f (x # ls, \\<sigma>) \\<bind>\n                     WHILE\\<^sub>T\\<^bsup>I\\<^esup> (FOREACH_cond c)\n                      (FOREACH_body f)\n                else RETURN (x # ls, \\<sigma>)\n           else FAIL) \\<bind>\n          (\\<lambda>(uu_, y). RETURN y)", "unfolding FOREACH_cond_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> c \\<sigma> \\<Longrightarrow>\n    nfoldli (x # ls) c f \\<sigma>\n    \\<le> (if I (x # ls, \\<sigma>)\n           then if case (x # ls, \\<sigma>) of\n                   (xs, \\<sigma>) \\<Rightarrow>\n                     xs \\<noteq> [] \\<and> c \\<sigma>\n                then FOREACH_body f (x # ls, \\<sigma>) \\<bind>\n                     WHILE\\<^sub>T\\<^bsup>I\\<^esup>\n                      (\\<lambda>(xs, \\<sigma>).\n                          xs \\<noteq> [] \\<and> c \\<sigma>)\n                      (FOREACH_body f)\n                else RETURN (x # ls, \\<sigma>)\n           else FAIL) \\<bind>\n          (\\<lambda>(uu_, y). RETURN y)", "by simp"], ["proof (state)\nthis:\n  nfoldli (x # ls) c f \\<sigma>\n  \\<le> WHILE\\<^sub>T\\<^bsup>I\\<^esup> (FOREACH_cond c) (FOREACH_body f)\n         (x # ls, \\<sigma>) \\<bind>\n        (\\<lambda>a. case a of (uu_, a) \\<Rightarrow> RETURN a)\n\ngoal (1 subgoal):\n 1. c \\<sigma> \\<Longrightarrow>\n    nfoldli (x # ls) c f \\<sigma>\n    \\<le> WHILE\\<^sub>T\\<^bsup>I\\<^esup> (FOREACH_cond c) (FOREACH_body f)\n           (x # ls, \\<sigma>) \\<bind>\n          (\\<lambda>a. case a of (uu_, a) \\<Rightarrow> RETURN a)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. c \\<sigma> \\<Longrightarrow>\n    nfoldli (x # ls) c f \\<sigma>\n    \\<le> WHILE\\<^sub>T\\<^bsup>I\\<^esup> (FOREACH_cond c) (FOREACH_body f)\n           (x # ls, \\<sigma>) \\<bind>\n          (\\<lambda>a. case a of (uu_, a) \\<Rightarrow> RETURN a)", "case [simp]: True"], ["proof (state)\nthis:\n  c \\<sigma>\n\ngoal (1 subgoal):\n 1. c \\<sigma> \\<Longrightarrow>\n    nfoldli (x # ls) c f \\<sigma>\n    \\<le> WHILE\\<^sub>T\\<^bsup>I\\<^esup> (FOREACH_cond c) (FOREACH_body f)\n           (x # ls, \\<sigma>) \\<bind>\n          (\\<lambda>a. case a of (uu_, a) \\<Rightarrow> RETURN a)", "from Cons"], ["proof (chain)\npicking this:\n  nfoldli ls c f ?\\<sigma>\n  \\<le> WHILE\\<^sub>T\\<^bsup>I\\<^esup> (FOREACH_cond c) (FOREACH_body f)\n         (ls, ?\\<sigma>) \\<bind>\n        (\\<lambda>a. case a of (uu_, a) \\<Rightarrow> RETURN a)", "show ?thesis"], ["proof (prove)\nusing this:\n  nfoldli ls c f ?\\<sigma>\n  \\<le> WHILE\\<^sub>T\\<^bsup>I\\<^esup> (FOREACH_cond c) (FOREACH_body f)\n         (ls, ?\\<sigma>) \\<bind>\n        (\\<lambda>a. case a of (uu_, a) \\<Rightarrow> RETURN a)\n\ngoal (1 subgoal):\n 1. nfoldli (x # ls) c f \\<sigma>\n    \\<le> WHILE\\<^sub>T\\<^bsup>I\\<^esup> (FOREACH_cond c) (FOREACH_body f)\n           (x # ls, \\<sigma>) \\<bind>\n          (\\<lambda>a. case a of (uu_, a) \\<Rightarrow> RETURN a)", "apply (subst WHILEIT_unfold)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>\\<sigma>.\n        nfoldli ls c f \\<sigma>\n        \\<le> WHILE\\<^sub>T\\<^bsup>I\\<^esup> (FOREACH_cond c)\n               (FOREACH_body f) (ls, \\<sigma>) \\<bind>\n              (\\<lambda>a.\n                  case a of\n                  (uu_, a) \\<Rightarrow> RETURN a)) \\<Longrightarrow>\n    nfoldli (x # ls) c f \\<sigma>\n    \\<le> (if I (x # ls, \\<sigma>)\n           then if FOREACH_cond c (x # ls, \\<sigma>)\n                then FOREACH_body f (x # ls, \\<sigma>) \\<bind>\n                     WHILE\\<^sub>T\\<^bsup>I\\<^esup> (FOREACH_cond c)\n                      (FOREACH_body f)\n                else RETURN (x # ls, \\<sigma>)\n           else FAIL) \\<bind>\n          (\\<lambda>(uu_, y). RETURN y)", "unfolding FOREACH_cond_def FOREACH_body_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>\\<sigma>.\n        nfoldli ls c f \\<sigma>\n        \\<le> WHILE\\<^sub>T\\<^bsup>I\\<^esup>\n               (\\<lambda>a.\n                   case a of\n                   (xs, \\<sigma>) \\<Rightarrow>\n                     xs \\<noteq> [] \\<and> c \\<sigma>)\n               (\\<lambda>a.\n                   case a of\n                   (xs, \\<sigma>) \\<Rightarrow>\n                     let x = hd xs\n                     in f x \\<sigma> \\<bind>\n                        (\\<lambda>\\<sigma>'. RETURN (tl xs, \\<sigma>')))\n               (ls, \\<sigma>) \\<bind>\n              (\\<lambda>a.\n                  case a of\n                  (uu_, a) \\<Rightarrow> RETURN a)) \\<Longrightarrow>\n    nfoldli (x # ls) c f \\<sigma>\n    \\<le> (if I (x # ls, \\<sigma>)\n           then if case (x # ls, \\<sigma>) of\n                   (xs, \\<sigma>) \\<Rightarrow>\n                     xs \\<noteq> [] \\<and> c \\<sigma>\n                then (case (x # ls, \\<sigma>) of\n                      (xs, \\<sigma>) \\<Rightarrow>\n                        let x = hd xs\n                        in f x \\<sigma> \\<bind>\n                           (\\<lambda>\\<sigma>'.\n                               RETURN (tl xs, \\<sigma>'))) \\<bind>\n                     WHILE\\<^sub>T\\<^bsup>I\\<^esup>\n                      (\\<lambda>(xs, \\<sigma>).\n                          xs \\<noteq> [] \\<and> c \\<sigma>)\n                      (\\<lambda>(xs, \\<sigma>).\n                          let x = hd xs\n                          in f x \\<sigma> \\<bind>\n                             (\\<lambda>\\<sigma>'.\n                                 RETURN (tl xs, \\<sigma>')))\n                else RETURN (x # ls, \\<sigma>)\n           else FAIL) \\<bind>\n          (\\<lambda>(uu_, y). RETURN y)", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>\\<sigma>.\n                nfoldli ls c f \\<sigma>\n                \\<le> WHILE\\<^sub>T\\<^bsup>I\\<^esup>\n                       (\\<lambda>a.\n                           case a of\n                           (xs, \\<sigma>) \\<Rightarrow>\n                             xs \\<noteq> [] \\<and> c \\<sigma>)\n                       (\\<lambda>a.\n                           case a of\n                           (xs, \\<sigma>) \\<Rightarrow>\n                             f (hd xs) \\<sigma> \\<bind>\n                             (\\<lambda>\\<sigma>'.\n                                 RETURN (tl xs, \\<sigma>')))\n                       (ls, \\<sigma>) \\<bind>\n                      (\\<lambda>a.\n                          case a of (uu_, a) \\<Rightarrow> RETURN a);\n     I (x # ls, \\<sigma>)\\<rbrakk>\n    \\<Longrightarrow> f x \\<sigma> \\<bind> nfoldli ls c f\n                      \\<le> f x \\<sigma> \\<bind>\n                            (\\<lambda>x.\n                                WHILE\\<^sub>T\\<^bsup>I\\<^esup>\n                                 (\\<lambda>(xs, \\<sigma>).\n                                     xs \\<noteq> [] \\<and> c \\<sigma>)\n                                 (\\<lambda>(xs, \\<sigma>).\n                                     f (hd xs) \\<sigma> \\<bind>\n                                     (\\<lambda>\\<sigma>'.\n   RETURN (tl xs, \\<sigma>')))\n                                 (ls, x) \\<bind>\n                                (\\<lambda>(uu_, y). RETURN y))", "apply (rule Refine_Basic.bind_mono)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>\\<sigma>.\n                nfoldli ls c f \\<sigma>\n                \\<le> WHILE\\<^sub>T\\<^bsup>I\\<^esup>\n                       (\\<lambda>a.\n                           case a of\n                           (xs, \\<sigma>) \\<Rightarrow>\n                             xs \\<noteq> [] \\<and> c \\<sigma>)\n                       (\\<lambda>a.\n                           case a of\n                           (xs, \\<sigma>) \\<Rightarrow>\n                             f (hd xs) \\<sigma> \\<bind>\n                             (\\<lambda>\\<sigma>'.\n                                 RETURN (tl xs, \\<sigma>')))\n                       (ls, \\<sigma>) \\<bind>\n                      (\\<lambda>a.\n                          case a of (uu_, a) \\<Rightarrow> RETURN a);\n     I (x # ls, \\<sigma>)\\<rbrakk>\n    \\<Longrightarrow> f x \\<sigma> \\<le> f x \\<sigma>\n 2. \\<And>xa.\n       \\<lbrakk>\\<And>\\<sigma>.\n                   nfoldli ls c f \\<sigma>\n                   \\<le> WHILE\\<^sub>T\\<^bsup>I\\<^esup>\n                          (\\<lambda>a.\n                              case a of\n                              (xs, \\<sigma>) \\<Rightarrow>\n                                xs \\<noteq> [] \\<and> c \\<sigma>)\n                          (\\<lambda>a.\n                              case a of\n                              (xs, \\<sigma>) \\<Rightarrow>\n                                f (hd xs) \\<sigma> \\<bind>\n                                (\\<lambda>\\<sigma>'.\n                                    RETURN (tl xs, \\<sigma>')))\n                          (ls, \\<sigma>) \\<bind>\n                         (\\<lambda>a.\n                             case a of (uu_, a) \\<Rightarrow> RETURN a);\n        I (x # ls, \\<sigma>); RETURN xa \\<le> f x \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> nfoldli ls c f xa\n                         \\<le> WHILE\\<^sub>T\\<^bsup>I\\<^esup>\n                                (\\<lambda>(xs, \\<sigma>).\n                                    xs \\<noteq> [] \\<and> c \\<sigma>)\n                                (\\<lambda>(xs, \\<sigma>).\n                                    f (hd xs) \\<sigma> \\<bind>\n                                    (\\<lambda>\\<sigma>'.\n  RETURN (tl xs, \\<sigma>')))\n                                (ls, xa) \\<bind>\n                               (\\<lambda>(uu_, y). RETURN y)", "apply simp_all"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  nfoldli (x # ls) c f \\<sigma>\n  \\<le> WHILE\\<^sub>T\\<^bsup>I\\<^esup> (FOREACH_cond c) (FOREACH_body f)\n         (x # ls, \\<sigma>) \\<bind>\n        (\\<lambda>a. case a of (uu_, a) \\<Rightarrow> RETURN a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  nfoldli (x # ls) c f \\<sigma>\n  \\<le> WHILE\\<^sub>T\\<^bsup>I\\<^esup> (FOREACH_cond c) (FOREACH_body f)\n         (x # ls, \\<sigma>) \\<bind>\n        (\\<lambda>a. case a of (uu_, a) \\<Rightarrow> RETURN a)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma while_nfoldli:\n  \"do {\n    (_,\\<sigma>) \\<leftarrow> WHILE\\<^sub>T (FOREACH_cond c) (FOREACH_body f) (l,\\<sigma>);\n    RETURN \\<sigma>\n  } \\<le> nfoldli l c f \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. WHILE\\<^sub>T (FOREACH_cond c) (FOREACH_body f) (l, \\<sigma>) \\<bind>\n    (\\<lambda>(uu_, \\<sigma>). RETURN \\<sigma>)\n    \\<le> nfoldli l c f \\<sigma>", "apply (induct l arbitrary: \\<sigma>)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>\\<sigma>.\n       WHILE\\<^sub>T (FOREACH_cond c) (FOREACH_body f)\n        ([], \\<sigma>) \\<bind>\n       (\\<lambda>(uu_, y). RETURN y)\n       \\<le> nfoldli [] c f \\<sigma>\n 2. \\<And>a l \\<sigma>.\n       (\\<And>\\<sigma>.\n           WHILE\\<^sub>T (FOREACH_cond c) (FOREACH_body f)\n            (l, \\<sigma>) \\<bind>\n           (\\<lambda>(uu_, y). RETURN y)\n           \\<le> nfoldli l c f \\<sigma>) \\<Longrightarrow>\n       WHILE\\<^sub>T (FOREACH_cond c) (FOREACH_body f)\n        (a # l, \\<sigma>) \\<bind>\n       (\\<lambda>(uu_, y). RETURN y)\n       \\<le> nfoldli (a # l) c f \\<sigma>", "apply (subst WHILET_unfold)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>\\<sigma>.\n       (if FOREACH_cond c ([], \\<sigma>)\n        then FOREACH_body f ([], \\<sigma>) \\<bind>\n             WHILE\\<^sub>T (FOREACH_cond c) (FOREACH_body f)\n        else RETURN ([], \\<sigma>)) \\<bind>\n       (\\<lambda>(uu_, y). RETURN y)\n       \\<le> nfoldli [] c f \\<sigma>\n 2. \\<And>a l \\<sigma>.\n       (\\<And>\\<sigma>.\n           WHILE\\<^sub>T (FOREACH_cond c) (FOREACH_body f)\n            (l, \\<sigma>) \\<bind>\n           (\\<lambda>(uu_, y). RETURN y)\n           \\<le> nfoldli l c f \\<sigma>) \\<Longrightarrow>\n       WHILE\\<^sub>T (FOREACH_cond c) (FOREACH_body f)\n        (a # l, \\<sigma>) \\<bind>\n       (\\<lambda>(uu_, y). RETURN y)\n       \\<le> nfoldli (a # l) c f \\<sigma>", "apply (simp add: FOREACH_cond_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a l \\<sigma>.\n       (\\<And>\\<sigma>.\n           WHILE\\<^sub>T (FOREACH_cond c) (FOREACH_body f)\n            (l, \\<sigma>) \\<bind>\n           (\\<lambda>(uu_, y). RETURN y)\n           \\<le> nfoldli l c f \\<sigma>) \\<Longrightarrow>\n       WHILE\\<^sub>T (FOREACH_cond c) (FOREACH_body f)\n        (a # l, \\<sigma>) \\<bind>\n       (\\<lambda>(uu_, y). RETURN y)\n       \\<le> nfoldli (a # l) c f \\<sigma>", "apply (subst WHILET_unfold)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a l \\<sigma>.\n       (\\<And>\\<sigma>.\n           WHILE\\<^sub>T (FOREACH_cond c) (FOREACH_body f)\n            (l, \\<sigma>) \\<bind>\n           (\\<lambda>(uu_, y). RETURN y)\n           \\<le> nfoldli l c f \\<sigma>) \\<Longrightarrow>\n       (if FOREACH_cond c (a # l, \\<sigma>)\n        then FOREACH_body f (a # l, \\<sigma>) \\<bind>\n             WHILE\\<^sub>T (FOREACH_cond c) (FOREACH_body f)\n        else RETURN (a # l, \\<sigma>)) \\<bind>\n       (\\<lambda>(uu_, y). RETURN y)\n       \\<le> nfoldli (a # l) c f \\<sigma>", "apply (auto\n    simp: FOREACH_cond_def FOREACH_body_def\n    intro: bind_mono)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma while_eq_nfoldli: \"do {\n    (_,\\<sigma>) \\<leftarrow> WHILE\\<^sub>T (FOREACH_cond c) (FOREACH_body f) (l,\\<sigma>);\n    RETURN \\<sigma>\n  } = nfoldli l c f \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. WHILE\\<^sub>T (FOREACH_cond c) (FOREACH_body f) (l, \\<sigma>) \\<bind>\n    (\\<lambda>(uu_, \\<sigma>). RETURN \\<sigma>) =\n    nfoldli l c f \\<sigma>", "apply (rule antisym)"], ["proof (prove)\ngoal (2 subgoals):\n 1. WHILE\\<^sub>T (FOREACH_cond c) (FOREACH_body f) (l, \\<sigma>) \\<bind>\n    (\\<lambda>(uu_, \\<sigma>). RETURN \\<sigma>)\n    \\<le> nfoldli l c f \\<sigma>\n 2. nfoldli l c f \\<sigma>\n    \\<le> WHILE\\<^sub>T (FOREACH_cond c) (FOREACH_body f)\n           (l, \\<sigma>) \\<bind>\n          (\\<lambda>(uu_, \\<sigma>). RETURN \\<sigma>)", "apply (rule while_nfoldli)"], ["proof (prove)\ngoal (1 subgoal):\n 1. nfoldli l c f \\<sigma>\n    \\<le> WHILE\\<^sub>T (FOREACH_cond c) (FOREACH_body f)\n           (l, \\<sigma>) \\<bind>\n          (\\<lambda>(uu_, \\<sigma>). RETURN \\<sigma>)", "apply (rule order_trans[OF nfoldli_while[where I=\"\\<lambda>_. True\"]])"], ["proof (prove)\ngoal (1 subgoal):\n 1. WHILE\\<^sub>T\\<^bsup>\\<lambda>_. True\\<^esup> (FOREACH_cond c)\n     (FOREACH_body f) (l, \\<sigma>) \\<bind>\n    (\\<lambda>(uu_, \\<sigma>). RETURN \\<sigma>)\n    \\<le> WHILE\\<^sub>T (FOREACH_cond c) (FOREACH_body f)\n           (l, \\<sigma>) \\<bind>\n          (\\<lambda>(uu_, \\<sigma>). RETURN \\<sigma>)", "apply (simp add: WHILET_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma nfoldli_rule:\n  assumes I0: \"I [] l0 \\<sigma>0\"\n  assumes IS: \"\\<And>x l1 l2 \\<sigma>. \\<lbrakk> l0=l1@x#l2; I l1 (x#l2) \\<sigma>; c \\<sigma> \\<rbrakk> \\<Longrightarrow> f x \\<sigma> \\<le> SPEC (I (l1@[x]) l2)\"\n  assumes FNC: \"\\<And>l1 l2 \\<sigma>. \\<lbrakk> l0=l1@l2; I l1 l2 \\<sigma>; \\<not>c \\<sigma> \\<rbrakk> \\<Longrightarrow> P \\<sigma>\"\n  assumes FC: \"\\<And>\\<sigma>. \\<lbrakk> I l0 [] \\<sigma>; c \\<sigma> \\<rbrakk> \\<Longrightarrow> P \\<sigma>\"\n  shows \"nfoldli l0 c f \\<sigma>0 \\<le> SPEC P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nfoldli l0 c f \\<sigma>0 \\<le> SPEC P", "apply (rule order_trans[OF nfoldli_while[\n    where I=\"\\<lambda>(l2,\\<sigma>). \\<exists>l1. l0=l1@l2 \\<and> I l1 l2 \\<sigma>\"]])"], ["proof (prove)\ngoal (1 subgoal):\n 1. WHILE\\<^sub>T\\<^bsup>\\<lambda>(l2, \\<sigma>).\n                            \\<exists>l1.\n                               l0 = l1 @ l2 \\<and> I l1 l2 \\<sigma>\\<^esup>\n     (FOREACH_cond c) (FOREACH_body f) (l0, \\<sigma>0) \\<bind>\n    (\\<lambda>(uu_, \\<sigma>). RETURN \\<sigma>)\n    \\<le> SPEC P", "unfolding FOREACH_cond_def FOREACH_body_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. WHILE\\<^sub>T\\<^bsup>\\<lambda>(l2, \\<sigma>).\n                            \\<exists>l1.\n                               l0 = l1 @ l2 \\<and> I l1 l2 \\<sigma>\\<^esup>\n     (\\<lambda>(xs, \\<sigma>). xs \\<noteq> [] \\<and> c \\<sigma>)\n     (\\<lambda>(xs, \\<sigma>).\n         let x = hd xs\n         in f x \\<sigma> \\<bind>\n            (\\<lambda>\\<sigma>'. RETURN (tl xs, \\<sigma>')))\n     (l0, \\<sigma>0) \\<bind>\n    (\\<lambda>(uu_, \\<sigma>). RETURN \\<sigma>)\n    \\<le> SPEC P", "apply (refine_rcg WHILEIT_rule[where R=\"measure (length o fst)\"] refine_vcg)"], ["proof (prove)\ngoal (4 subgoals):\n 1. wf (measure (length \\<circ> fst))\n 2. \\<And>x1 x2.\n       (l0, \\<sigma>0) = (x1, x2) \\<Longrightarrow>\n       \\<exists>l1. l0 = l1 @ x1 \\<and> I l1 x1 x2\n 3. \\<And>s a b.\n       \\<lbrakk>case s of\n                (l2, \\<sigma>) \\<Rightarrow>\n                  \\<exists>l1. l0 = l1 @ l2 \\<and> I l1 l2 \\<sigma>;\n        case s of\n        (xs, \\<sigma>) \\<Rightarrow> xs \\<noteq> [] \\<and> c \\<sigma>;\n        s = (a, b)\\<rbrakk>\n       \\<Longrightarrow> f (hd a) b\n                         \\<le> SPEC\n                                (\\<lambda>\\<sigma>'.\n                                    RETURN (tl a, \\<sigma>')\n                                    \\<le> SPEC\n     (\\<lambda>s'.\n         (case s' of\n          (l2, \\<sigma>) \\<Rightarrow>\n            \\<exists>l1. l0 = l1 @ l2 \\<and> I l1 l2 \\<sigma>) \\<and>\n         (s', s) \\<in> measure (length \\<circ> fst)))\n 4. \\<And>s a b.\n       \\<lbrakk>case s of\n                (l2, \\<sigma>) \\<Rightarrow>\n                  \\<exists>l1. l0 = l1 @ l2 \\<and> I l1 l2 \\<sigma>;\n        \\<not> (case s of\n                (xs, \\<sigma>) \\<Rightarrow>\n                  xs \\<noteq> [] \\<and> c \\<sigma>);\n        s = (a, b)\\<rbrakk>\n       \\<Longrightarrow> P b", "apply simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x1 x2.\n       (l0, \\<sigma>0) = (x1, x2) \\<Longrightarrow>\n       \\<exists>l1. l0 = l1 @ x1 \\<and> I l1 x1 x2\n 2. \\<And>s a b.\n       \\<lbrakk>case s of\n                (l2, \\<sigma>) \\<Rightarrow>\n                  \\<exists>l1. l0 = l1 @ l2 \\<and> I l1 l2 \\<sigma>;\n        case s of\n        (xs, \\<sigma>) \\<Rightarrow> xs \\<noteq> [] \\<and> c \\<sigma>;\n        s = (a, b)\\<rbrakk>\n       \\<Longrightarrow> f (hd a) b\n                         \\<le> SPEC\n                                (\\<lambda>\\<sigma>'.\n                                    RETURN (tl a, \\<sigma>')\n                                    \\<le> SPEC\n     (\\<lambda>s'.\n         (case s' of\n          (l2, \\<sigma>) \\<Rightarrow>\n            \\<exists>l1. l0 = l1 @ l2 \\<and> I l1 l2 \\<sigma>) \\<and>\n         (s', s) \\<in> measure (length \\<circ> fst)))\n 3. \\<And>s a b.\n       \\<lbrakk>case s of\n                (l2, \\<sigma>) \\<Rightarrow>\n                  \\<exists>l1. l0 = l1 @ l2 \\<and> I l1 l2 \\<sigma>;\n        \\<not> (case s of\n                (xs, \\<sigma>) \\<Rightarrow>\n                  xs \\<noteq> [] \\<and> c \\<sigma>);\n        s = (a, b)\\<rbrakk>\n       \\<Longrightarrow> P b", "using I0"], ["proof (prove)\nusing this:\n  I [] l0 \\<sigma>0\n\ngoal (3 subgoals):\n 1. \\<And>x1 x2.\n       (l0, \\<sigma>0) = (x1, x2) \\<Longrightarrow>\n       \\<exists>l1. l0 = l1 @ x1 \\<and> I l1 x1 x2\n 2. \\<And>s a b.\n       \\<lbrakk>case s of\n                (l2, \\<sigma>) \\<Rightarrow>\n                  \\<exists>l1. l0 = l1 @ l2 \\<and> I l1 l2 \\<sigma>;\n        case s of\n        (xs, \\<sigma>) \\<Rightarrow> xs \\<noteq> [] \\<and> c \\<sigma>;\n        s = (a, b)\\<rbrakk>\n       \\<Longrightarrow> f (hd a) b\n                         \\<le> SPEC\n                                (\\<lambda>\\<sigma>'.\n                                    RETURN (tl a, \\<sigma>')\n                                    \\<le> SPEC\n     (\\<lambda>s'.\n         (case s' of\n          (l2, \\<sigma>) \\<Rightarrow>\n            \\<exists>l1. l0 = l1 @ l2 \\<and> I l1 l2 \\<sigma>) \\<and>\n         (s', s) \\<in> measure (length \\<circ> fst)))\n 3. \\<And>s a b.\n       \\<lbrakk>case s of\n                (l2, \\<sigma>) \\<Rightarrow>\n                  \\<exists>l1. l0 = l1 @ l2 \\<and> I l1 l2 \\<sigma>;\n        \\<not> (case s of\n                (xs, \\<sigma>) \\<Rightarrow>\n                  xs \\<noteq> [] \\<and> c \\<sigma>);\n        s = (a, b)\\<rbrakk>\n       \\<Longrightarrow> P b", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s a b.\n       \\<lbrakk>case s of\n                (l2, \\<sigma>) \\<Rightarrow>\n                  \\<exists>l1. l0 = l1 @ l2 \\<and> I l1 l2 \\<sigma>;\n        case s of\n        (xs, \\<sigma>) \\<Rightarrow> xs \\<noteq> [] \\<and> c \\<sigma>;\n        s = (a, b)\\<rbrakk>\n       \\<Longrightarrow> f (hd a) b\n                         \\<le> SPEC\n                                (\\<lambda>\\<sigma>'.\n                                    RETURN (tl a, \\<sigma>')\n                                    \\<le> SPEC\n     (\\<lambda>s'.\n         (case s' of\n          (l2, \\<sigma>) \\<Rightarrow>\n            \\<exists>l1. l0 = l1 @ l2 \\<and> I l1 l2 \\<sigma>) \\<and>\n         (s', s) \\<in> measure (length \\<circ> fst)))\n 2. \\<And>s a b.\n       \\<lbrakk>case s of\n                (l2, \\<sigma>) \\<Rightarrow>\n                  \\<exists>l1. l0 = l1 @ l2 \\<and> I l1 l2 \\<sigma>;\n        \\<not> (case s of\n                (xs, \\<sigma>) \\<Rightarrow>\n                  xs \\<noteq> [] \\<and> c \\<sigma>);\n        s = (a, b)\\<rbrakk>\n       \\<Longrightarrow> P b", "apply (case_tac a, simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s a b aa list.\n       \\<lbrakk>case s of\n                (l2, \\<sigma>) \\<Rightarrow>\n                  \\<exists>l1. l0 = l1 @ l2 \\<and> I l1 l2 \\<sigma>;\n        case s of\n        (xs, \\<sigma>) \\<Rightarrow> xs \\<noteq> [] \\<and> c \\<sigma>;\n        s = (a, b); a = aa # list\\<rbrakk>\n       \\<Longrightarrow> f (hd a) b\n                         \\<le> SPEC\n                                (\\<lambda>\\<sigma>'.\n                                    RETURN (tl a, \\<sigma>')\n                                    \\<le> SPEC\n     (\\<lambda>s'.\n         (case s' of\n          (l2, \\<sigma>) \\<Rightarrow>\n            \\<exists>l1. l0 = l1 @ l2 \\<and> I l1 l2 \\<sigma>) \\<and>\n         (s', s) \\<in> measure (length \\<circ> fst)))\n 2. \\<And>s a b.\n       \\<lbrakk>case s of\n                (l2, \\<sigma>) \\<Rightarrow>\n                  \\<exists>l1. l0 = l1 @ l2 \\<and> I l1 l2 \\<sigma>;\n        \\<not> (case s of\n                (xs, \\<sigma>) \\<Rightarrow>\n                  xs \\<noteq> [] \\<and> c \\<sigma>);\n        s = (a, b)\\<rbrakk>\n       \\<Longrightarrow> P b", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s a b aa list.\n       \\<lbrakk>\\<exists>l1. l0 = l1 @ aa # list \\<and> I l1 (aa # list) b;\n        c b; s = (aa # list, b); a = aa # list\\<rbrakk>\n       \\<Longrightarrow> f aa b\n                         \\<le> SPEC\n                                (\\<lambda>\\<sigma>'.\n                                    \\<exists>l1.\n l0 = l1 @ list \\<and> I l1 list \\<sigma>')\n 2. \\<And>s a b.\n       \\<lbrakk>case s of\n                (l2, \\<sigma>) \\<Rightarrow>\n                  \\<exists>l1. l0 = l1 @ l2 \\<and> I l1 l2 \\<sigma>;\n        \\<not> (case s of\n                (xs, \\<sigma>) \\<Rightarrow>\n                  xs \\<noteq> [] \\<and> c \\<sigma>);\n        s = (a, b)\\<rbrakk>\n       \\<Longrightarrow> P b", "apply (elim exE conjE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s a b aa list l1.\n       \\<lbrakk>c b; s = (aa # list, b); a = aa # list; l0 = l1 @ aa # list;\n        I l1 (aa # list) b\\<rbrakk>\n       \\<Longrightarrow> f aa b\n                         \\<le> SPEC\n                                (\\<lambda>\\<sigma>'.\n                                    \\<exists>l1.\n l0 = l1 @ list \\<and> I l1 list \\<sigma>')\n 2. \\<And>s a b.\n       \\<lbrakk>case s of\n                (l2, \\<sigma>) \\<Rightarrow>\n                  \\<exists>l1. l0 = l1 @ l2 \\<and> I l1 l2 \\<sigma>;\n        \\<not> (case s of\n                (xs, \\<sigma>) \\<Rightarrow>\n                  xs \\<noteq> [] \\<and> c \\<sigma>);\n        s = (a, b)\\<rbrakk>\n       \\<Longrightarrow> P b", "apply (rule order_trans[OF IS], assumption+)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s a b aa list l1.\n       \\<lbrakk>c b; s = (aa # list, b); a = aa # list; l0 = l1 @ aa # list;\n        I l1 (aa # list) b\\<rbrakk>\n       \\<Longrightarrow> SPEC (I (l1 @ [aa]) list)\n                         \\<le> SPEC\n                                (\\<lambda>\\<sigma>'.\n                                    \\<exists>l1.\n l0 = l1 @ list \\<and> I l1 list \\<sigma>')\n 2. \\<And>s a b.\n       \\<lbrakk>case s of\n                (l2, \\<sigma>) \\<Rightarrow>\n                  \\<exists>l1. l0 = l1 @ l2 \\<and> I l1 l2 \\<sigma>;\n        \\<not> (case s of\n                (xs, \\<sigma>) \\<Rightarrow>\n                  xs \\<noteq> [] \\<and> c \\<sigma>);\n        s = (a, b)\\<rbrakk>\n       \\<Longrightarrow> P b", "apply auto []"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s a b.\n       \\<lbrakk>case s of\n                (l2, \\<sigma>) \\<Rightarrow>\n                  \\<exists>l1. l0 = l1 @ l2 \\<and> I l1 l2 \\<sigma>;\n        \\<not> (case s of\n                (xs, \\<sigma>) \\<Rightarrow>\n                  xs \\<noteq> [] \\<and> c \\<sigma>);\n        s = (a, b)\\<rbrakk>\n       \\<Longrightarrow> P b", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s a b.\n       \\<lbrakk>\\<exists>l1. l0 = l1 @ a \\<and> I l1 a b;\n        a = [] \\<or> \\<not> c b; s = (a, b)\\<rbrakk>\n       \\<Longrightarrow> P b", "apply (elim exE disjE2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s a b l1.\n       \\<lbrakk>s = (a, b); l0 = l1 @ a \\<and> I l1 a b; a = [];\n        \\<not> \\<not> c b\\<rbrakk>\n       \\<Longrightarrow> P b\n 2. \\<And>s a b l1.\n       \\<lbrakk>s = (a, b); l0 = l1 @ a \\<and> I l1 a b; \\<not> c b\\<rbrakk>\n       \\<Longrightarrow> P b", "using FC"], ["proof (prove)\nusing this:\n  \\<lbrakk>I l0 [] ?\\<sigma>; c ?\\<sigma>\\<rbrakk>\n  \\<Longrightarrow> P ?\\<sigma>\n\ngoal (2 subgoals):\n 1. \\<And>s a b l1.\n       \\<lbrakk>s = (a, b); l0 = l1 @ a \\<and> I l1 a b; a = [];\n        \\<not> \\<not> c b\\<rbrakk>\n       \\<Longrightarrow> P b\n 2. \\<And>s a b l1.\n       \\<lbrakk>s = (a, b); l0 = l1 @ a \\<and> I l1 a b; \\<not> c b\\<rbrakk>\n       \\<Longrightarrow> P b", "apply auto []"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s a b l1.\n       \\<lbrakk>s = (a, b); l0 = l1 @ a \\<and> I l1 a b; \\<not> c b\\<rbrakk>\n       \\<Longrightarrow> P b", "using FNC"], ["proof (prove)\nusing this:\n  \\<lbrakk>l0 = ?l1.0 @ ?l2.0; I ?l1.0 ?l2.0 ?\\<sigma>;\n   \\<not> c ?\\<sigma>\\<rbrakk>\n  \\<Longrightarrow> P ?\\<sigma>\n\ngoal (1 subgoal):\n 1. \\<And>s a b l1.\n       \\<lbrakk>s = (a, b); l0 = l1 @ a \\<and> I l1 a b; \\<not> c b\\<rbrakk>\n       \\<Longrightarrow> P b", "apply auto []"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma nfoldli_leof_rule:\n  assumes I0: \"I [] l0 \\<sigma>0\"\n  assumes IS: \"\\<And>x l1 l2 \\<sigma>. \\<lbrakk> l0=l1@x#l2; I l1 (x#l2) \\<sigma>; c \\<sigma> \\<rbrakk> \\<Longrightarrow> f x \\<sigma> \\<le>\\<^sub>n SPEC (I (l1@[x]) l2)\"\n  assumes FNC: \"\\<And>l1 l2 \\<sigma>. \\<lbrakk> l0=l1@l2; I l1 l2 \\<sigma>; \\<not>c \\<sigma> \\<rbrakk> \\<Longrightarrow> P \\<sigma>\"\n  assumes FC: \"\\<And>\\<sigma>. \\<lbrakk> I l0 [] \\<sigma>; c \\<sigma> \\<rbrakk> \\<Longrightarrow> P \\<sigma>\"\n  shows \"nfoldli l0 c f \\<sigma>0 \\<le>\\<^sub>n SPEC P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nfoldli l0 c f \\<sigma>0 \\<le>\\<^sub>n SPEC P", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. nfoldli l0 c f \\<sigma>0 \\<le>\\<^sub>n SPEC P", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. nfoldli l0 c f \\<sigma>0 \\<le>\\<^sub>n SPEC P", "fix l1 l2 \\<sigma>"], ["proof (state)\ngoal (1 subgoal):\n 1. nfoldli l0 c f \\<sigma>0 \\<le>\\<^sub>n SPEC P", "assume \"l0=l1@l2\" \"I l1 l2 \\<sigma>\""], ["proof (state)\nthis:\n  l0 = l1 @ l2\n  I l1 l2 \\<sigma>\n\ngoal (1 subgoal):\n 1. nfoldli l0 c f \\<sigma>0 \\<le>\\<^sub>n SPEC P", "hence \"nfoldli l2 c f \\<sigma> \\<le>\\<^sub>n SPEC P\""], ["proof (prove)\nusing this:\n  l0 = l1 @ l2\n  I l1 l2 \\<sigma>\n\ngoal (1 subgoal):\n 1. nfoldli l2 c f \\<sigma> \\<le>\\<^sub>n SPEC P", "proof (induction l2 arbitrary: l1 \\<sigma>)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>l1 \\<sigma>.\n       \\<lbrakk>l0 = l1 @ []; I l1 [] \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> nfoldli [] c f \\<sigma> \\<le>\\<^sub>n SPEC P\n 2. \\<And>a l2 l1 \\<sigma>.\n       \\<lbrakk>\\<And>l1 \\<sigma>.\n                   \\<lbrakk>l0 = l1 @ l2; I l1 l2 \\<sigma>\\<rbrakk>\n                   \\<Longrightarrow> nfoldli l2 c f \\<sigma> \\<le>\\<^sub>n\n                                     SPEC P;\n        l0 = l1 @ a # l2; I l1 (a # l2) \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> nfoldli (a # l2) c f \\<sigma> \\<le>\\<^sub>n SPEC P", "case Nil"], ["proof (state)\nthis:\n  l0 = l1 @ []\n  I l1 [] \\<sigma>\n\ngoal (2 subgoals):\n 1. \\<And>l1 \\<sigma>.\n       \\<lbrakk>l0 = l1 @ []; I l1 [] \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> nfoldli [] c f \\<sigma> \\<le>\\<^sub>n SPEC P\n 2. \\<And>a l2 l1 \\<sigma>.\n       \\<lbrakk>\\<And>l1 \\<sigma>.\n                   \\<lbrakk>l0 = l1 @ l2; I l1 l2 \\<sigma>\\<rbrakk>\n                   \\<Longrightarrow> nfoldli l2 c f \\<sigma> \\<le>\\<^sub>n\n                                     SPEC P;\n        l0 = l1 @ a # l2; I l1 (a # l2) \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> nfoldli (a # l2) c f \\<sigma> \\<le>\\<^sub>n SPEC P", "thus ?case"], ["proof (prove)\nusing this:\n  l0 = l1 @ []\n  I l1 [] \\<sigma>\n\ngoal (1 subgoal):\n 1. nfoldli [] c f \\<sigma> \\<le>\\<^sub>n SPEC P", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>l0 = l1; I l1 [] \\<sigma>\\<rbrakk> \\<Longrightarrow> P \\<sigma>", "apply (cases \"c \\<sigma>\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>l0 = l1; I l1 [] \\<sigma>; c \\<sigma>\\<rbrakk>\n    \\<Longrightarrow> P \\<sigma>\n 2. \\<lbrakk>l0 = l1; I l1 [] \\<sigma>; \\<not> c \\<sigma>\\<rbrakk>\n    \\<Longrightarrow> P \\<sigma>", "apply (rule FC; auto; fail)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>l0 = l1; I l1 [] \\<sigma>; \\<not> c \\<sigma>\\<rbrakk>\n    \\<Longrightarrow> P \\<sigma>", "apply (rule FNC[of l1 \"[]\"]; auto; fail)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  nfoldli [] c f \\<sigma> \\<le>\\<^sub>n SPEC P\n\ngoal (1 subgoal):\n 1. \\<And>a l2 l1 \\<sigma>.\n       \\<lbrakk>\\<And>l1 \\<sigma>.\n                   \\<lbrakk>l0 = l1 @ l2; I l1 l2 \\<sigma>\\<rbrakk>\n                   \\<Longrightarrow> nfoldli l2 c f \\<sigma> \\<le>\\<^sub>n\n                                     SPEC P;\n        l0 = l1 @ a # l2; I l1 (a # l2) \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> nfoldli (a # l2) c f \\<sigma> \\<le>\\<^sub>n SPEC P", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a l2 l1 \\<sigma>.\n       \\<lbrakk>\\<And>l1 \\<sigma>.\n                   \\<lbrakk>l0 = l1 @ l2; I l1 l2 \\<sigma>\\<rbrakk>\n                   \\<Longrightarrow> nfoldli l2 c f \\<sigma> \\<le>\\<^sub>n\n                                     SPEC P;\n        l0 = l1 @ a # l2; I l1 (a # l2) \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> nfoldli (a # l2) c f \\<sigma> \\<le>\\<^sub>n SPEC P", "case (Cons x l2)"], ["proof (state)\nthis:\n  \\<lbrakk>l0 = ?l1.0 @ l2; I ?l1.0 l2 ?\\<sigma>\\<rbrakk>\n  \\<Longrightarrow> nfoldli l2 c f ?\\<sigma> \\<le>\\<^sub>n SPEC P\n  l0 = l1 @ x # l2\n  I l1 (x # l2) \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<And>a l2 l1 \\<sigma>.\n       \\<lbrakk>\\<And>l1 \\<sigma>.\n                   \\<lbrakk>l0 = l1 @ l2; I l1 l2 \\<sigma>\\<rbrakk>\n                   \\<Longrightarrow> nfoldli l2 c f \\<sigma> \\<le>\\<^sub>n\n                                     SPEC P;\n        l0 = l1 @ a # l2; I l1 (a # l2) \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> nfoldli (a # l2) c f \\<sigma> \\<le>\\<^sub>n SPEC P", "note [refine_vcg] = Cons.IH[of \"l1@[x]\",THEN leof_trans] IS[of l1 x l2 \\<sigma>,THEN leof_trans]"], ["proof (state)\nthis:\n  \\<lbrakk>l0 = (l1 @ [x]) @ l2; I (l1 @ [x]) l2 ?\\<sigma>1;\n   SPEC P \\<le>\\<^sub>n ?c\\<rbrakk>\n  \\<Longrightarrow> nfoldli l2 c f ?\\<sigma>1 \\<le>\\<^sub>n ?c\n  \\<lbrakk>l0 = l1 @ x # l2; I l1 (x # l2) \\<sigma>; c \\<sigma>;\n   SPEC (I (l1 @ [x]) l2) \\<le>\\<^sub>n ?c\\<rbrakk>\n  \\<Longrightarrow> f x \\<sigma> \\<le>\\<^sub>n ?c\n\ngoal (1 subgoal):\n 1. \\<And>a l2 l1 \\<sigma>.\n       \\<lbrakk>\\<And>l1 \\<sigma>.\n                   \\<lbrakk>l0 = l1 @ l2; I l1 l2 \\<sigma>\\<rbrakk>\n                   \\<Longrightarrow> nfoldli l2 c f \\<sigma> \\<le>\\<^sub>n\n                                     SPEC P;\n        l0 = l1 @ a # l2; I l1 (a # l2) \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> nfoldli (a # l2) c f \\<sigma> \\<le>\\<^sub>n SPEC P", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. nfoldli (x # l2) c f \\<sigma> \\<le>\\<^sub>n SPEC P", "apply (simp split del: if_split)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if c \\<sigma> then f x \\<sigma> \\<bind> nfoldli l2 c f\n     else RETURN \\<sigma>) \\<le>\\<^sub>n\n    SPEC P", "apply refine_vcg"], ["proof (prove)\ngoal (6 subgoals):\n 1. c \\<sigma> \\<Longrightarrow> l0 = l1 @ x # l2\n 2. c \\<sigma> \\<Longrightarrow> I l1 (x # l2) \\<sigma>\n 3. \\<And>xa.\n       \\<lbrakk>c \\<sigma>; xa \\<in> Collect (I (l1 @ [x]) l2)\\<rbrakk>\n       \\<Longrightarrow> l0 = (l1 @ [x]) @ l2\n 4. \\<And>xa.\n       \\<lbrakk>c \\<sigma>; xa \\<in> Collect (I (l1 @ [x]) l2)\\<rbrakk>\n       \\<Longrightarrow> I (l1 @ [x]) l2 xa\n 5. \\<And>xa xaa.\n       \\<lbrakk>c \\<sigma>; xa \\<in> Collect (I (l1 @ [x]) l2);\n        xaa \\<in> {a. P a}\\<rbrakk>\n       \\<Longrightarrow> P xaa\n 6. \\<not> c \\<sigma> \\<Longrightarrow> P \\<sigma>", "using Cons.prems FNC"], ["proof (prove)\nusing this:\n  l0 = l1 @ x # l2\n  I l1 (x # l2) \\<sigma>\n  \\<lbrakk>l0 = ?l1.0 @ ?l2.0; I ?l1.0 ?l2.0 ?\\<sigma>;\n   \\<not> c ?\\<sigma>\\<rbrakk>\n  \\<Longrightarrow> P ?\\<sigma>\n\ngoal (6 subgoals):\n 1. c \\<sigma> \\<Longrightarrow> l0 = l1 @ x # l2\n 2. c \\<sigma> \\<Longrightarrow> I l1 (x # l2) \\<sigma>\n 3. \\<And>xa.\n       \\<lbrakk>c \\<sigma>; xa \\<in> Collect (I (l1 @ [x]) l2)\\<rbrakk>\n       \\<Longrightarrow> l0 = (l1 @ [x]) @ l2\n 4. \\<And>xa.\n       \\<lbrakk>c \\<sigma>; xa \\<in> Collect (I (l1 @ [x]) l2)\\<rbrakk>\n       \\<Longrightarrow> I (l1 @ [x]) l2 xa\n 5. \\<And>xa xaa.\n       \\<lbrakk>c \\<sigma>; xa \\<in> Collect (I (l1 @ [x]) l2);\n        xaa \\<in> {a. P a}\\<rbrakk>\n       \\<Longrightarrow> P xaa\n 6. \\<not> c \\<sigma> \\<Longrightarrow> P \\<sigma>", "by auto"], ["proof (state)\nthis:\n  nfoldli (x # l2) c f \\<sigma> \\<le>\\<^sub>n SPEC P\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  nfoldli l2 c f \\<sigma> \\<le>\\<^sub>n SPEC P\n\ngoal (1 subgoal):\n 1. nfoldli l0 c f \\<sigma>0 \\<le>\\<^sub>n SPEC P", "}"], ["proof (state)\nthis:\n  \\<lbrakk>l0 = ?l1.2 @ ?l2.2; I ?l1.2 ?l2.2 ?\\<sigma>2\\<rbrakk>\n  \\<Longrightarrow> nfoldli ?l2.2 c f ?\\<sigma>2 \\<le>\\<^sub>n SPEC P\n\ngoal (1 subgoal):\n 1. nfoldli l0 c f \\<sigma>0 \\<le>\\<^sub>n SPEC P", "from this[of \"[]\" l0 \\<sigma>0] I0"], ["proof (chain)\npicking this:\n  \\<lbrakk>l0 = [] @ l0; I [] l0 \\<sigma>0\\<rbrakk>\n  \\<Longrightarrow> nfoldli l0 c f \\<sigma>0 \\<le>\\<^sub>n SPEC P\n  I [] l0 \\<sigma>0", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>l0 = [] @ l0; I [] l0 \\<sigma>0\\<rbrakk>\n  \\<Longrightarrow> nfoldli l0 c f \\<sigma>0 \\<le>\\<^sub>n SPEC P\n  I [] l0 \\<sigma>0\n\ngoal (1 subgoal):\n 1. nfoldli l0 c f \\<sigma>0 \\<le>\\<^sub>n SPEC P", "by auto"], ["proof (state)\nthis:\n  nfoldli l0 c f \\<sigma>0 \\<le>\\<^sub>n SPEC P\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma nfoldli_refine[refine]:\n  assumes \"(li, l) \\<in> \\<langle>S\\<rangle>list_rel\"\n    and \"(si, s) \\<in> R\"\n    and CR: \"(ci, c) \\<in> R \\<rightarrow> bool_rel\"\n    and [refine]: \"\\<And>xi x si s. \\<lbrakk> (xi,x)\\<in>S; (si,s)\\<in>R; c s \\<rbrakk> \\<Longrightarrow> fi xi si \\<le> \\<Down>R (f x s)\"\n  shows \"nfoldli li ci fi si \\<le> \\<Down> R (nfoldli l c f s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nfoldli li ci fi si \\<le> \\<Down> R (nfoldli l c f s)", "using assms(1,2)"], ["proof (prove)\nusing this:\n  (li, l) \\<in> \\<langle>S\\<rangle>list_rel\n  (si, s) \\<in> R\n\ngoal (1 subgoal):\n 1. nfoldli li ci fi si \\<le> \\<Down> R (nfoldli l c f s)", "proof (induction arbitrary: si s rule: list_rel_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>si s.\n       (si, s) \\<in> R \\<Longrightarrow>\n       nfoldli [] ci fi si \\<le> \\<Down> R (nfoldli [] c f s)\n 2. \\<And>x x' l l' si s.\n       \\<lbrakk>(x, x') \\<in> S; (l, l') \\<in> \\<langle>S\\<rangle>list_rel;\n        \\<And>si s.\n           (si, s) \\<in> R \\<Longrightarrow>\n           nfoldli l ci fi si \\<le> \\<Down> R (nfoldli l' c f s);\n        (si, s) \\<in> R\\<rbrakk>\n       \\<Longrightarrow> nfoldli (x # l) ci fi si\n                         \\<le> \\<Down> R (nfoldli (x' # l') c f s)", "case Nil"], ["proof (state)\nthis:\n  (si, s) \\<in> R\n\ngoal (2 subgoals):\n 1. \\<And>si s.\n       (si, s) \\<in> R \\<Longrightarrow>\n       nfoldli [] ci fi si \\<le> \\<Down> R (nfoldli [] c f s)\n 2. \\<And>x x' l l' si s.\n       \\<lbrakk>(x, x') \\<in> S; (l, l') \\<in> \\<langle>S\\<rangle>list_rel;\n        \\<And>si s.\n           (si, s) \\<in> R \\<Longrightarrow>\n           nfoldli l ci fi si \\<le> \\<Down> R (nfoldli l' c f s);\n        (si, s) \\<in> R\\<rbrakk>\n       \\<Longrightarrow> nfoldli (x # l) ci fi si\n                         \\<le> \\<Down> R (nfoldli (x' # l') c f s)", "thus ?case"], ["proof (prove)\nusing this:\n  (si, s) \\<in> R\n\ngoal (1 subgoal):\n 1. nfoldli [] ci fi si \\<le> \\<Down> R (nfoldli [] c f s)", "by simp"], ["proof (state)\nthis:\n  nfoldli [] ci fi si \\<le> \\<Down> R (nfoldli [] c f s)\n\ngoal (1 subgoal):\n 1. \\<And>x x' l l' si s.\n       \\<lbrakk>(x, x') \\<in> S; (l, l') \\<in> \\<langle>S\\<rangle>list_rel;\n        \\<And>si s.\n           (si, s) \\<in> R \\<Longrightarrow>\n           nfoldli l ci fi si \\<le> \\<Down> R (nfoldli l' c f s);\n        (si, s) \\<in> R\\<rbrakk>\n       \\<Longrightarrow> nfoldli (x # l) ci fi si\n                         \\<le> \\<Down> R (nfoldli (x' # l') c f s)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x x' l l' si s.\n       \\<lbrakk>(x, x') \\<in> S; (l, l') \\<in> \\<langle>S\\<rangle>list_rel;\n        \\<And>si s.\n           (si, s) \\<in> R \\<Longrightarrow>\n           nfoldli l ci fi si \\<le> \\<Down> R (nfoldli l' c f s);\n        (si, s) \\<in> R\\<rbrakk>\n       \\<Longrightarrow> nfoldli (x # l) ci fi si\n                         \\<le> \\<Down> R (nfoldli (x' # l') c f s)", "case (Cons xi x li l)"], ["proof (state)\nthis:\n  (xi, x) \\<in> S\n  (li, l) \\<in> \\<langle>S\\<rangle>list_rel\n  (?si, ?s) \\<in> R \\<Longrightarrow>\n  nfoldli li ci fi ?si \\<le> \\<Down> R (nfoldli l c f ?s)\n  (si, s) \\<in> R\n\ngoal (1 subgoal):\n 1. \\<And>x x' l l' si s.\n       \\<lbrakk>(x, x') \\<in> S; (l, l') \\<in> \\<langle>S\\<rangle>list_rel;\n        \\<And>si s.\n           (si, s) \\<in> R \\<Longrightarrow>\n           nfoldli l ci fi si \\<le> \\<Down> R (nfoldli l' c f s);\n        (si, s) \\<in> R\\<rbrakk>\n       \\<Longrightarrow> nfoldli (x # l) ci fi si\n                         \\<le> \\<Down> R (nfoldli (x' # l') c f s)", "note [refine] = Cons"], ["proof (state)\nthis:\n  (xi, x) \\<in> S\n  (li, l) \\<in> \\<langle>S\\<rangle>list_rel\n  (?si, ?s) \\<in> R \\<Longrightarrow>\n  nfoldli li ci fi ?si \\<le> \\<Down> R (nfoldli l c f ?s)\n  (si, s) \\<in> R\n\ngoal (1 subgoal):\n 1. \\<And>x x' l l' si s.\n       \\<lbrakk>(x, x') \\<in> S; (l, l') \\<in> \\<langle>S\\<rangle>list_rel;\n        \\<And>si s.\n           (si, s) \\<in> R \\<Longrightarrow>\n           nfoldli l ci fi si \\<le> \\<Down> R (nfoldli l' c f s);\n        (si, s) \\<in> R\\<rbrakk>\n       \\<Longrightarrow> nfoldli (x # l) ci fi si\n                         \\<le> \\<Down> R (nfoldli (x' # l') c f s)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. nfoldli (xi # li) ci fi si \\<le> \\<Down> R (nfoldli (x # l) c f s)", "apply (simp split del: if_split)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if ci si then fi xi si \\<bind> nfoldli li ci fi else RETURN si)\n    \\<le> \\<Down> R (if c s then f x s \\<bind> nfoldli l c f else RETURN s)", "apply refine_rcg"], ["proof (prove)\ngoal (1 subgoal):\n 1. ci si = c s", "using CR Cons.prems"], ["proof (prove)\nusing this:\n  (ci, c) \\<in> R \\<rightarrow> bool_rel\n  (si, s) \\<in> R\n\ngoal (1 subgoal):\n 1. ci si = c s", "by (auto dest: fun_relD)"], ["proof (state)\nthis:\n  nfoldli (xi # li) ci fi si \\<le> \\<Down> R (nfoldli (x # l) c f s)\n\ngoal:\nNo subgoals!", "qed"], ["", "(* Refine, establishing additional invariant *)"], ["", "lemma nfoldli_invar_refine:\n  assumes \"(li,l)\\<in>\\<langle>S\\<rangle>list_rel\"\n  assumes \"(si,s)\\<in>R\"\n  assumes \"I [] li si\"\n  assumes COND: \"\\<And>l1i l2i l1 l2 si s. \\<lbrakk>\n    li=l1i@l2i; l=l1@l2; (l1i,l1)\\<in>\\<langle>S\\<rangle>list_rel; (l2i,l2)\\<in>\\<langle>S\\<rangle>list_rel; \n    I l1i l2i si; (si,s)\\<in>R\\<rbrakk> \\<Longrightarrow> (ci si, c s)\\<in>bool_rel\"\n  assumes INV: \"\\<And>l1i xi l2i si. \\<lbrakk>li=l1i@xi#l2i; I l1i (xi#l2i) si\\<rbrakk> \\<Longrightarrow> fi xi si \\<le>\\<^sub>n SPEC (I (l1i@[xi]) l2i)\"\n  assumes STEP: \"\\<And>l1i xi l2i l1 x l2 si s. \\<lbrakk>\n    li=l1i@xi#l2i; l=l1@x#l2; (l1i,l1)\\<in>\\<langle>S\\<rangle>list_rel; (xi,x)\\<in>S; (l2i,l2)\\<in>\\<langle>S\\<rangle>list_rel; \n    I l1i (xi#l2i) si; (si,s)\\<in>R\\<rbrakk> \\<Longrightarrow> fi xi si \\<le> \\<Down>R (f x s)\"\n  shows \"nfoldli li ci fi si \\<le> \\<Down>R (nfoldli l c f s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nfoldli li ci fi si \\<le> \\<Down> R (nfoldli l c f s)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. nfoldli li ci fi si \\<le> \\<Down> R (nfoldli l c f s)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. nfoldli li ci fi si \\<le> \\<Down> R (nfoldli l c f s)", "have [refine_dref_RELATES]: \"RELATES R\" \"RELATES S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RELATES R &&& RELATES S", "by (auto simp: RELATES_def)"], ["proof (state)\nthis:\n  RELATES R\n  RELATES S\n\ngoal (1 subgoal):\n 1. nfoldli li ci fi si \\<le> \\<Down> R (nfoldli l c f s)", "note [refine del] = nfoldli_refine"], ["proof (state)\nthis:\n  \\<lbrakk>(?li, ?l) \\<in> \\<langle>?S\\<rangle>list_rel; (?si, ?s) \\<in> ?R;\n   (?ci, ?c) \\<in> ?R \\<rightarrow> bool_rel;\n   \\<And>xi x si s.\n      \\<lbrakk>(xi, x) \\<in> ?S; (si, s) \\<in> ?R; ?c s\\<rbrakk>\n      \\<Longrightarrow> ?fi xi si \\<le> \\<Down> ?R (?f x s)\\<rbrakk>\n  \\<Longrightarrow> nfoldli ?li ?ci ?fi ?si\n                    \\<le> \\<Down> ?R (nfoldli ?l ?c ?f ?s)\n\ngoal (1 subgoal):\n 1. nfoldli li ci fi si \\<le> \\<Down> R (nfoldli l c f s)", "fix l1i l2i l1 l2 si s"], ["proof (state)\ngoal (1 subgoal):\n 1. nfoldli li ci fi si \\<le> \\<Down> R (nfoldli l c f s)", "assume \"(l2i,l2) \\<in> \\<langle>S\\<rangle>list_rel\" \"(l1i,l1) \\<in> \\<langle>S\\<rangle>list_rel\"\n    and \"li=l1i@l2i\" \"l=l1@l2\"\n    and \"(si,s)\\<in>R\" \"I l1i l2i si\""], ["proof (state)\nthis:\n  (l2i, l2) \\<in> \\<langle>S\\<rangle>list_rel\n  (l1i, l1) \\<in> \\<langle>S\\<rangle>list_rel\n  li = l1i @ l2i\n  l = l1 @ l2\n  (si, s) \\<in> R\n  I l1i l2i si\n\ngoal (1 subgoal):\n 1. nfoldli li ci fi si \\<le> \\<Down> R (nfoldli l c f s)", "hence \"nfoldli l2i ci fi si \\<le> \\<Down>R (nfoldli l2 c f s)\""], ["proof (prove)\nusing this:\n  (l2i, l2) \\<in> \\<langle>S\\<rangle>list_rel\n  (l1i, l1) \\<in> \\<langle>S\\<rangle>list_rel\n  li = l1i @ l2i\n  l = l1 @ l2\n  (si, s) \\<in> R\n  I l1i l2i si\n\ngoal (1 subgoal):\n 1. nfoldli l2i ci fi si \\<le> \\<Down> R (nfoldli l2 c f s)", "proof (induction arbitrary: si s l1i l1 rule: list_rel_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>si s l1i l1.\n       \\<lbrakk>(l1i, l1) \\<in> \\<langle>S\\<rangle>list_rel; li = l1i @ [];\n        l = l1 @ []; (si, s) \\<in> R; I l1i [] si\\<rbrakk>\n       \\<Longrightarrow> nfoldli [] ci fi si\n                         \\<le> \\<Down> R (nfoldli [] c f s)\n 2. \\<And>x x' la l' si s l1i l1.\n       \\<lbrakk>(x, x') \\<in> S; (la, l') \\<in> \\<langle>S\\<rangle>list_rel;\n        \\<And>si s l1i l1.\n           \\<lbrakk>(l1i, l1) \\<in> \\<langle>S\\<rangle>list_rel;\n            li = l1i @ la; l = l1 @ l'; (si, s) \\<in> R;\n            I l1i la si\\<rbrakk>\n           \\<Longrightarrow> nfoldli la ci fi si\n                             \\<le> \\<Down> R (nfoldli l' c f s);\n        (l1i, l1) \\<in> \\<langle>S\\<rangle>list_rel; li = l1i @ x # la;\n        l = l1 @ x' # l'; (si, s) \\<in> R; I l1i (x # la) si\\<rbrakk>\n       \\<Longrightarrow> nfoldli (x # la) ci fi si\n                         \\<le> \\<Down> R (nfoldli (x' # l') c f s)", "case Nil"], ["proof (state)\nthis:\n  (l1i, l1) \\<in> \\<langle>S\\<rangle>list_rel\n  li = l1i @ []\n  l = l1 @ []\n  (si, s) \\<in> R\n  I l1i [] si\n\ngoal (2 subgoals):\n 1. \\<And>si s l1i l1.\n       \\<lbrakk>(l1i, l1) \\<in> \\<langle>S\\<rangle>list_rel; li = l1i @ [];\n        l = l1 @ []; (si, s) \\<in> R; I l1i [] si\\<rbrakk>\n       \\<Longrightarrow> nfoldli [] ci fi si\n                         \\<le> \\<Down> R (nfoldli [] c f s)\n 2. \\<And>x x' la l' si s l1i l1.\n       \\<lbrakk>(x, x') \\<in> S; (la, l') \\<in> \\<langle>S\\<rangle>list_rel;\n        \\<And>si s l1i l1.\n           \\<lbrakk>(l1i, l1) \\<in> \\<langle>S\\<rangle>list_rel;\n            li = l1i @ la; l = l1 @ l'; (si, s) \\<in> R;\n            I l1i la si\\<rbrakk>\n           \\<Longrightarrow> nfoldli la ci fi si\n                             \\<le> \\<Down> R (nfoldli l' c f s);\n        (l1i, l1) \\<in> \\<langle>S\\<rangle>list_rel; li = l1i @ x # la;\n        l = l1 @ x' # l'; (si, s) \\<in> R; I l1i (x # la) si\\<rbrakk>\n       \\<Longrightarrow> nfoldli (x # la) ci fi si\n                         \\<le> \\<Down> R (nfoldli (x' # l') c f s)", "thus ?case"], ["proof (prove)\nusing this:\n  (l1i, l1) \\<in> \\<langle>S\\<rangle>list_rel\n  li = l1i @ []\n  l = l1 @ []\n  (si, s) \\<in> R\n  I l1i [] si\n\ngoal (1 subgoal):\n 1. nfoldli [] ci fi si \\<le> \\<Down> R (nfoldli [] c f s)", "by auto"], ["proof (state)\nthis:\n  nfoldli [] ci fi si \\<le> \\<Down> R (nfoldli [] c f s)\n\ngoal (1 subgoal):\n 1. \\<And>x x' la l' si s l1i l1.\n       \\<lbrakk>(x, x') \\<in> S; (la, l') \\<in> \\<langle>S\\<rangle>list_rel;\n        \\<And>si s l1i l1.\n           \\<lbrakk>(l1i, l1) \\<in> \\<langle>S\\<rangle>list_rel;\n            li = l1i @ la; l = l1 @ l'; (si, s) \\<in> R;\n            I l1i la si\\<rbrakk>\n           \\<Longrightarrow> nfoldli la ci fi si\n                             \\<le> \\<Down> R (nfoldli l' c f s);\n        (l1i, l1) \\<in> \\<langle>S\\<rangle>list_rel; li = l1i @ x # la;\n        l = l1 @ x' # l'; (si, s) \\<in> R; I l1i (x # la) si\\<rbrakk>\n       \\<Longrightarrow> nfoldli (x # la) ci fi si\n                         \\<le> \\<Down> R (nfoldli (x' # l') c f s)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x x' la l' si s l1i l1.\n       \\<lbrakk>(x, x') \\<in> S; (la, l') \\<in> \\<langle>S\\<rangle>list_rel;\n        \\<And>si s l1i l1.\n           \\<lbrakk>(l1i, l1) \\<in> \\<langle>S\\<rangle>list_rel;\n            li = l1i @ la; l = l1 @ l'; (si, s) \\<in> R;\n            I l1i la si\\<rbrakk>\n           \\<Longrightarrow> nfoldli la ci fi si\n                             \\<le> \\<Down> R (nfoldli l' c f s);\n        (l1i, l1) \\<in> \\<langle>S\\<rangle>list_rel; li = l1i @ x # la;\n        l = l1 @ x' # l'; (si, s) \\<in> R; I l1i (x # la) si\\<rbrakk>\n       \\<Longrightarrow> nfoldli (x # la) ci fi si\n                         \\<le> \\<Down> R (nfoldli (x' # l') c f s)", "case (Cons xi x l2i l2)"], ["proof (state)\nthis:\n  (xi, x) \\<in> S\n  (l2i, l2) \\<in> \\<langle>S\\<rangle>list_rel\n  \\<lbrakk>(?l1i, ?l1.0) \\<in> \\<langle>S\\<rangle>list_rel; li = ?l1i @ l2i;\n   l = ?l1.0 @ l2; (?si, ?s) \\<in> R; I ?l1i l2i ?si\\<rbrakk>\n  \\<Longrightarrow> nfoldli l2i ci fi ?si\n                    \\<le> \\<Down> R (nfoldli l2 c f ?s)\n  (l1i, l1) \\<in> \\<langle>S\\<rangle>list_rel\n  li = l1i @ xi # l2i\n  l = l1 @ x # l2\n  (si, s) \\<in> R\n  I l1i (xi # l2i) si\n\ngoal (1 subgoal):\n 1. \\<And>x x' la l' si s l1i l1.\n       \\<lbrakk>(x, x') \\<in> S; (la, l') \\<in> \\<langle>S\\<rangle>list_rel;\n        \\<And>si s l1i l1.\n           \\<lbrakk>(l1i, l1) \\<in> \\<langle>S\\<rangle>list_rel;\n            li = l1i @ la; l = l1 @ l'; (si, s) \\<in> R;\n            I l1i la si\\<rbrakk>\n           \\<Longrightarrow> nfoldli la ci fi si\n                             \\<le> \\<Down> R (nfoldli l' c f s);\n        (l1i, l1) \\<in> \\<langle>S\\<rangle>list_rel; li = l1i @ x # la;\n        l = l1 @ x' # l'; (si, s) \\<in> R; I l1i (x # la) si\\<rbrakk>\n       \\<Longrightarrow> nfoldli (x # la) ci fi si\n                         \\<le> \\<Down> R (nfoldli (x' # l') c f s)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. nfoldli (xi # l2i) ci fi si \\<le> \\<Down> R (nfoldli (x # l2) c f s)", "apply (simp split del: if_split)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if ci si then fi xi si \\<bind> nfoldli l2i ci fi else RETURN si)\n    \\<le> \\<Down> R (if c s then f x s \\<bind> nfoldli l2 c f else RETURN s)", "apply (refine_rcg bind_refine')"], ["proof (prove)\ngoal (4 subgoals):\n 1. ci si = c s\n 2. \\<lbrakk>ci si; c s\\<rbrakk>\n    \\<Longrightarrow> fi xi si \\<le> \\<Down> ?R'1 (f x s)\n 3. \\<And>s sa.\n       \\<lbrakk>ci si; c s; (s, sa) \\<in> ?R'1; inres (fi xi si) s;\n        inres (f x s) sa; nofail (fi xi si); nofail (f x s)\\<rbrakk>\n       \\<Longrightarrow> nfoldli l2i ci fi s\n                         \\<le> \\<Down> R (nfoldli l2 c f sa)\n 4. \\<lbrakk>\\<not> ci si; \\<not> c s\\<rbrakk>\n    \\<Longrightarrow> (si, s) \\<in> R", "apply (refine_dref_type)"], ["proof (prove)\ngoal (4 subgoals):\n 1. ci si = c s\n 2. \\<lbrakk>ci si; c s\\<rbrakk>\n    \\<Longrightarrow> fi xi si \\<le> \\<Down> R (f x s)\n 3. \\<And>s sa.\n       \\<lbrakk>ci si; c s; (s, sa) \\<in> R; inres (fi xi si) s;\n        inres (f x s) sa; nofail (fi xi si); nofail (f x s)\\<rbrakk>\n       \\<Longrightarrow> nfoldli l2i ci fi s\n                         \\<le> \\<Down> R (nfoldli l2 c f sa)\n 4. \\<lbrakk>\\<not> ci si; \\<not> c s\\<rbrakk>\n    \\<Longrightarrow> (si, s) \\<in> R", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. ci si = c s", "using COND[of l1i \"xi#l2i\" l1 \"x#l2\" si s] Cons.prems Cons.hyps"], ["proof (prove)\nusing this:\n  \\<lbrakk>li = l1i @ xi # l2i; l = l1 @ x # l2;\n   (l1i, l1) \\<in> \\<langle>S\\<rangle>list_rel;\n   (xi # l2i, x # l2) \\<in> \\<langle>S\\<rangle>list_rel;\n   I l1i (xi # l2i) si; (si, s) \\<in> R\\<rbrakk>\n  \\<Longrightarrow> (ci si, c s) \\<in> bool_rel\n  (l1i, l1) \\<in> \\<langle>S\\<rangle>list_rel\n  li = l1i @ xi # l2i\n  l = l1 @ x # l2\n  (si, s) \\<in> R\n  I l1i (xi # l2i) si\n  (xi, x) \\<in> S\n  (l2i, l2) \\<in> \\<langle>S\\<rangle>list_rel\n\ngoal (1 subgoal):\n 1. ci si = c s", "by auto"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>ci si; c s\\<rbrakk>\n    \\<Longrightarrow> fi xi si \\<le> \\<Down> R (f x s)\n 2. \\<And>s sa.\n       \\<lbrakk>ci si; c s; (s, sa) \\<in> R; inres (fi xi si) s;\n        inres (f x s) sa; nofail (fi xi si); nofail (f x s)\\<rbrakk>\n       \\<Longrightarrow> nfoldli l2i ci fi s\n                         \\<le> \\<Down> R (nfoldli l2 c f sa)\n 3. \\<lbrakk>\\<not> ci si; \\<not> c s\\<rbrakk>\n    \\<Longrightarrow> (si, s) \\<in> R", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ci si; c s\\<rbrakk>\n    \\<Longrightarrow> fi xi si \\<le> \\<Down> R (f x s)", "apply (rule STEP)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<lbrakk>ci si; c s\\<rbrakk> \\<Longrightarrow> li = ?l1i @ xi # ?l2i\n 2. \\<lbrakk>ci si; c s\\<rbrakk> \\<Longrightarrow> l = ?l1.0 @ x # ?l2.0\n 3. \\<lbrakk>ci si; c s\\<rbrakk>\n    \\<Longrightarrow> (?l1i, ?l1.0) \\<in> \\<langle>S\\<rangle>list_rel\n 4. \\<lbrakk>ci si; c s\\<rbrakk> \\<Longrightarrow> (xi, x) \\<in> S\n 5. \\<lbrakk>ci si; c s\\<rbrakk>\n    \\<Longrightarrow> (?l2i, ?l2.0) \\<in> \\<langle>S\\<rangle>list_rel\n 6. \\<lbrakk>ci si; c s\\<rbrakk> \\<Longrightarrow> I ?l1i (xi # ?l2i) si\n 7. \\<lbrakk>ci si; c s\\<rbrakk> \\<Longrightarrow> (si, s) \\<in> R", "using Cons.prems Cons.hyps"], ["proof (prove)\nusing this:\n  (l1i, l1) \\<in> \\<langle>S\\<rangle>list_rel\n  li = l1i @ xi # l2i\n  l = l1 @ x # l2\n  (si, s) \\<in> R\n  I l1i (xi # l2i) si\n  (xi, x) \\<in> S\n  (l2i, l2) \\<in> \\<langle>S\\<rangle>list_rel\n\ngoal (7 subgoals):\n 1. \\<lbrakk>ci si; c s\\<rbrakk> \\<Longrightarrow> li = ?l1i @ xi # ?l2i\n 2. \\<lbrakk>ci si; c s\\<rbrakk> \\<Longrightarrow> l = ?l1.0 @ x # ?l2.0\n 3. \\<lbrakk>ci si; c s\\<rbrakk>\n    \\<Longrightarrow> (?l1i, ?l1.0) \\<in> \\<langle>S\\<rangle>list_rel\n 4. \\<lbrakk>ci si; c s\\<rbrakk> \\<Longrightarrow> (xi, x) \\<in> S\n 5. \\<lbrakk>ci si; c s\\<rbrakk>\n    \\<Longrightarrow> (?l2i, ?l2.0) \\<in> \\<langle>S\\<rangle>list_rel\n 6. \\<lbrakk>ci si; c s\\<rbrakk> \\<Longrightarrow> I ?l1i (xi # ?l2i) si\n 7. \\<lbrakk>ci si; c s\\<rbrakk> \\<Longrightarrow> (si, s) \\<in> R", "by auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s sa.\n       \\<lbrakk>ci si; c s; (s, sa) \\<in> R; inres (fi xi si) s;\n        inres (f x s) sa; nofail (fi xi si); nofail (f x s)\\<rbrakk>\n       \\<Longrightarrow> nfoldli l2i ci fi s\n                         \\<le> \\<Down> R (nfoldli l2 c f sa)\n 2. \\<lbrakk>\\<not> ci si; \\<not> c s\\<rbrakk>\n    \\<Longrightarrow> (si, s) \\<in> R", "subgoal for si' s'"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ci si; c s; (si', s') \\<in> R; inres (fi xi si) si';\n     inres (f x s) s'; nofail (fi xi si); nofail (f x s)\\<rbrakk>\n    \\<Longrightarrow> nfoldli l2i ci fi si'\n                      \\<le> \\<Down> R (nfoldli l2 c f s')", "apply (rule Cons.IH[of \"l1i@[xi]\" \"l1@[x]\"])"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>ci si; c s; (si', s') \\<in> R; inres (fi xi si) si';\n     inres (f x s) s'; nofail (fi xi si); nofail (f x s)\\<rbrakk>\n    \\<Longrightarrow> (l1i @ [xi], l1 @ [x])\n                      \\<in> \\<langle>S\\<rangle>list_rel\n 2. \\<lbrakk>ci si; c s; (si', s') \\<in> R; inres (fi xi si) si';\n     inres (f x s) s'; nofail (fi xi si); nofail (f x s)\\<rbrakk>\n    \\<Longrightarrow> li = (l1i @ [xi]) @ l2i\n 3. \\<lbrakk>ci si; c s; (si', s') \\<in> R; inres (fi xi si) si';\n     inres (f x s) s'; nofail (fi xi si); nofail (f x s)\\<rbrakk>\n    \\<Longrightarrow> l = (l1 @ [x]) @ l2\n 4. \\<lbrakk>ci si; c s; (si', s') \\<in> R; inres (fi xi si) si';\n     inres (f x s) s'; nofail (fi xi si); nofail (f x s)\\<rbrakk>\n    \\<Longrightarrow> (si', s') \\<in> R\n 5. \\<lbrakk>ci si; c s; (si', s') \\<in> R; inres (fi xi si) si';\n     inres (f x s) s'; nofail (fi xi si); nofail (f x s)\\<rbrakk>\n    \\<Longrightarrow> I (l1i @ [xi]) l2i si'", "using Cons.prems Cons.hyps"], ["proof (prove)\nusing this:\n  (l1i, l1) \\<in> \\<langle>S\\<rangle>list_rel\n  li = l1i @ xi # l2i\n  l = l1 @ x # l2\n  (si, s) \\<in> R\n  I l1i (xi # l2i) si\n  (xi, x) \\<in> S\n  (l2i, l2) \\<in> \\<langle>S\\<rangle>list_rel\n\ngoal (5 subgoals):\n 1. \\<lbrakk>ci si; c s; (si', s') \\<in> R; inres (fi xi si) si';\n     inres (f x s) s'; nofail (fi xi si); nofail (f x s)\\<rbrakk>\n    \\<Longrightarrow> (l1i @ [xi], l1 @ [x])\n                      \\<in> \\<langle>S\\<rangle>list_rel\n 2. \\<lbrakk>ci si; c s; (si', s') \\<in> R; inres (fi xi si) si';\n     inres (f x s) s'; nofail (fi xi si); nofail (f x s)\\<rbrakk>\n    \\<Longrightarrow> li = (l1i @ [xi]) @ l2i\n 3. \\<lbrakk>ci si; c s; (si', s') \\<in> R; inres (fi xi si) si';\n     inres (f x s) s'; nofail (fi xi si); nofail (f x s)\\<rbrakk>\n    \\<Longrightarrow> l = (l1 @ [x]) @ l2\n 4. \\<lbrakk>ci si; c s; (si', s') \\<in> R; inres (fi xi si) si';\n     inres (f x s) s'; nofail (fi xi si); nofail (f x s)\\<rbrakk>\n    \\<Longrightarrow> (si', s') \\<in> R\n 5. \\<lbrakk>ci si; c s; (si', s') \\<in> R; inres (fi xi si) si';\n     inres (f x s) s'; nofail (fi xi si); nofail (f x s)\\<rbrakk>\n    \\<Longrightarrow> I (l1i @ [xi]) l2i si'", "apply (auto simp: list_rel_append1)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>ci si; c s; (si', s') \\<in> R; inres (fi xi si) si';\n     inres (f x s) s'; nofail (fi xi si); nofail (f x s);\n     (l1i, l1) \\<in> \\<langle>S\\<rangle>list_rel; li = l1i @ xi # l2i;\n     l = l1 @ x # l2; (si, s) \\<in> R; I l1i (xi # l2i) si; (xi, x) \\<in> S;\n     (l2i, l2) \\<in> \\<langle>S\\<rangle>list_rel\\<rbrakk>\n    \\<Longrightarrow> \\<exists>cs ds.\n                         l1 @ [x] = cs @ ds \\<and>\n                         (l1i, cs) \\<in> \\<langle>S\\<rangle>list_rel \\<and>\n                         ([xi], ds) \\<in> \\<langle>S\\<rangle>list_rel\n 2. \\<lbrakk>ci si; c s; (si', s') \\<in> R; inres (fi xi si) si';\n     inres (f x s) s'; nofail (fi xi si); nofail (f x s);\n     (l1i, l1) \\<in> \\<langle>S\\<rangle>list_rel; li = l1i @ xi # l2i;\n     l = l1 @ x # l2; (si, s) \\<in> R; I l1i (xi # l2i) si; (xi, x) \\<in> S;\n     (l2i, l2) \\<in> \\<langle>S\\<rangle>list_rel\\<rbrakk>\n    \\<Longrightarrow> I (l1i @ [xi]) l2i si'", "apply force"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ci si; c s; (si', s') \\<in> R; inres (fi xi si) si';\n     inres (f x s) s'; nofail (fi xi si); nofail (f x s);\n     (l1i, l1) \\<in> \\<langle>S\\<rangle>list_rel; li = l1i @ xi # l2i;\n     l = l1 @ x # l2; (si, s) \\<in> R; I l1i (xi # l2i) si; (xi, x) \\<in> S;\n     (l2i, l2) \\<in> \\<langle>S\\<rangle>list_rel\\<rbrakk>\n    \\<Longrightarrow> I (l1i @ [xi]) l2i si'", "using INV[of l1i xi l2i si]"], ["proof (prove)\nusing this:\n  \\<lbrakk>li = l1i @ xi # l2i; I l1i (xi # l2i) si\\<rbrakk>\n  \\<Longrightarrow> fi xi si \\<le>\\<^sub>n SPEC (I (l1i @ [xi]) l2i)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>ci si; c s; (si', s') \\<in> R; inres (fi xi si) si';\n     inres (f x s) s'; nofail (fi xi si); nofail (f x s);\n     (l1i, l1) \\<in> \\<langle>S\\<rangle>list_rel; li = l1i @ xi # l2i;\n     l = l1 @ x # l2; (si, s) \\<in> R; I l1i (xi # l2i) si; (xi, x) \\<in> S;\n     (l2i, l2) \\<in> \\<langle>S\\<rangle>list_rel\\<rbrakk>\n    \\<Longrightarrow> I (l1i @ [xi]) l2i si'", "by (auto simp: pw_leof_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> ci si; \\<not> c s\\<rbrakk>\n    \\<Longrightarrow> (si, s) \\<in> R", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> ci si; \\<not> c s\\<rbrakk>\n    \\<Longrightarrow> (si, s) \\<in> R", "using Cons.prems"], ["proof (prove)\nusing this:\n  (l1i, l1) \\<in> \\<langle>S\\<rangle>list_rel\n  li = l1i @ xi # l2i\n  l = l1 @ x # l2\n  (si, s) \\<in> R\n  I l1i (xi # l2i) si\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> ci si; \\<not> c s\\<rbrakk>\n    \\<Longrightarrow> (si, s) \\<in> R", "by simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  nfoldli (xi # l2i) ci fi si \\<le> \\<Down> R (nfoldli (x # l2) c f s)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  nfoldli l2i ci fi si \\<le> \\<Down> R (nfoldli l2 c f s)\n\ngoal (1 subgoal):\n 1. nfoldli li ci fi si \\<le> \\<Down> R (nfoldli l c f s)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>(?l2i2, ?l2.2) \\<in> \\<langle>S\\<rangle>list_rel;\n   (?l1i2, ?l1.2) \\<in> \\<langle>S\\<rangle>list_rel; li = ?l1i2 @ ?l2i2;\n   l = ?l1.2 @ ?l2.2; (?sia2, ?sa2) \\<in> R; I ?l1i2 ?l2i2 ?sia2\\<rbrakk>\n  \\<Longrightarrow> nfoldli ?l2i2 ci fi ?sia2\n                    \\<le> \\<Down> R (nfoldli ?l2.2 c f ?sa2)\n\ngoal (1 subgoal):\n 1. nfoldli li ci fi si \\<le> \\<Down> R (nfoldli l c f s)", "from this[of li l \"[]\" \"[]\" si s] assms(1,2,3)"], ["proof (chain)\npicking this:\n  \\<lbrakk>(li, l) \\<in> \\<langle>S\\<rangle>list_rel;\n   ([], []) \\<in> \\<langle>S\\<rangle>list_rel; li = [] @ li; l = [] @ l;\n   (si, s) \\<in> R; I [] li si\\<rbrakk>\n  \\<Longrightarrow> nfoldli li ci fi si \\<le> \\<Down> R (nfoldli l c f s)\n  (li, l) \\<in> \\<langle>S\\<rangle>list_rel\n  (si, s) \\<in> R\n  I [] li si", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>(li, l) \\<in> \\<langle>S\\<rangle>list_rel;\n   ([], []) \\<in> \\<langle>S\\<rangle>list_rel; li = [] @ li; l = [] @ l;\n   (si, s) \\<in> R; I [] li si\\<rbrakk>\n  \\<Longrightarrow> nfoldli li ci fi si \\<le> \\<Down> R (nfoldli l c f s)\n  (li, l) \\<in> \\<langle>S\\<rangle>list_rel\n  (si, s) \\<in> R\n  I [] li si\n\ngoal (1 subgoal):\n 1. nfoldli li ci fi si \\<le> \\<Down> R (nfoldli l c f s)", "by auto"], ["proof (state)\nthis:\n  nfoldli li ci fi si \\<le> \\<Down> R (nfoldli l c f s)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma foldli_mono_dres_aux1:\n  fixes \\<sigma> :: \"'a :: {order_bot, order_top}\"\n  assumes COND: \"\\<And>\\<sigma> \\<sigma>'. \\<sigma>\\<le>\\<sigma>' \\<Longrightarrow> c \\<sigma> \\<noteq> c \\<sigma>' \\<Longrightarrow> \\<sigma>=bot \\<or> \\<sigma>'=top \"\n  assumes STRICT: \"\\<And>x. f x bot = bot\" \"\\<And>x. f' x top = top\"\n  assumes B: \"\\<sigma>\\<le>\\<sigma>'\"\n  assumes A: \"\\<And>a x x'. x\\<le>x' \\<Longrightarrow> f a x \\<le> f' a x'\"\n  shows \"foldli l c f \\<sigma> \\<le> foldli l c f' \\<sigma>'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldli l c f \\<sigma> \\<le> foldli l c f' \\<sigma>'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. foldli l c f \\<sigma> \\<le> foldli l c f' \\<sigma>'", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. foldli l c f \\<sigma> \\<le> foldli l c f' \\<sigma>'", "fix l"], ["proof (state)\ngoal (1 subgoal):\n 1. foldli l c f \\<sigma> \\<le> foldli l c f' \\<sigma>'", "have \"foldli l c f bot = bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldli l c f bot = bot", "by (induct l) (auto simp: STRICT)"], ["proof (state)\nthis:\n  foldli l c f bot = bot\n\ngoal (1 subgoal):\n 1. foldli l c f \\<sigma> \\<le> foldli l c f' \\<sigma>'", "}"], ["proof (state)\nthis:\n  foldli ?la2 c f bot = bot\n\ngoal (1 subgoal):\n 1. foldli l c f \\<sigma> \\<le> foldli l c f' \\<sigma>'", "note [simp] = this"], ["proof (state)\nthis:\n  foldli ?la2 c f bot = bot\n\ngoal (1 subgoal):\n 1. foldli l c f \\<sigma> \\<le> foldli l c f' \\<sigma>'", "{"], ["proof (state)\nthis:\n  foldli ?la2 c f bot = bot\n\ngoal (1 subgoal):\n 1. foldli l c f \\<sigma> \\<le> foldli l c f' \\<sigma>'", "fix l"], ["proof (state)\ngoal (1 subgoal):\n 1. foldli l c f \\<sigma> \\<le> foldli l c f' \\<sigma>'", "have \"foldli l c f' top = top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldli l c f' top = top", "by (induct l) (auto simp: STRICT)"], ["proof (state)\nthis:\n  foldli l c f' top = top\n\ngoal (1 subgoal):\n 1. foldli l c f \\<sigma> \\<le> foldli l c f' \\<sigma>'", "}"], ["proof (state)\nthis:\n  foldli ?la2 c f' top = top\n\ngoal (1 subgoal):\n 1. foldli l c f \\<sigma> \\<le> foldli l c f' \\<sigma>'", "note [simp] = this"], ["proof (state)\nthis:\n  foldli ?la2 c f' top = top\n\ngoal (1 subgoal):\n 1. foldli l c f \\<sigma> \\<le> foldli l c f' \\<sigma>'", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. foldli l c f \\<sigma> \\<le> foldli l c f' \\<sigma>'", "using B"], ["proof (prove)\nusing this:\n  \\<sigma> \\<le> \\<sigma>'\n\ngoal (1 subgoal):\n 1. foldli l c f \\<sigma> \\<le> foldli l c f' \\<sigma>'", "apply (induct l arbitrary: \\<sigma> \\<sigma>')"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>\\<sigma> \\<sigma>'.\n       \\<sigma> \\<le> \\<sigma>' \\<Longrightarrow>\n       foldli [] c f \\<sigma> \\<le> foldli [] c f' \\<sigma>'\n 2. \\<And>a l \\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<And>\\<sigma> \\<sigma>'.\n                   \\<sigma> \\<le> \\<sigma>' \\<Longrightarrow>\n                   foldli l c f \\<sigma> \\<le> foldli l c f' \\<sigma>';\n        \\<sigma> \\<le> \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> foldli (a # l) c f \\<sigma>\n                         \\<le> foldli (a # l) c f' \\<sigma>'", "apply (auto simp: A STRICT dest!: COND)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  foldli l c f \\<sigma> \\<le> foldli l c f' \\<sigma>'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma foldli_mono_dres_aux2:\n  assumes STRICT: \"\\<And>x. f x bot = bot\" \"\\<And>x. f' x top = top\"\n  assumes A: \"\\<And>a x x'. x\\<le>x' \\<Longrightarrow> f a x \\<le> f' a x'\"\n  shows \"foldli l (case_dres False False c) f \\<sigma> \n    \\<le> foldli l (case_dres False False c) f' \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldli l (case_dres False False c) f \\<sigma>\n    \\<le> foldli l (case_dres False False c) f' \\<sigma>", "apply (rule foldli_mono_dres_aux1)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>\\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<sigma> \\<le> \\<sigma>';\n        (case \\<sigma> of dRETURN x \\<Rightarrow> c x\n         | _ \\<Rightarrow> False) \\<noteq>\n        (case \\<sigma>' of dRETURN x \\<Rightarrow> c x\n         | _ \\<Rightarrow> False)\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> = dSUCCEED \\<or> \\<sigma>' = dFAIL\n 2. \\<And>x. f x dSUCCEED = dSUCCEED\n 3. \\<And>x. f' x dFAIL = dFAIL\n 4. \\<sigma> \\<le> \\<sigma>\n 5. \\<And>a x x'. x \\<le> x' \\<Longrightarrow> f a x \\<le> f' a x'", "apply (simp_all split: dres.split_asm add: STRICT A)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma foldli_mono_dres[refine_mono]:\n  assumes A: \"\\<And>a x. f a x \\<le> f' a x\"\n  shows \"foldli l (case_dres False False c) (\\<lambda>x s. dbind s (f x)) \\<sigma> \n    \\<le> foldli l (case_dres False False c) (\\<lambda>x s. dbind s (f' x)) \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldli l (case_dres False False c) (\\<lambda>x s. s \\<bind> f x)\n     \\<sigma>\n    \\<le> foldli l (case_dres False False c) (\\<lambda>x s. s \\<bind> f' x)\n           \\<sigma>", "apply (rule foldli_mono_dres_aux2)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x. dSUCCEED \\<bind> f x = dSUCCEED\n 2. \\<And>x. dFAIL \\<bind> f' x = dFAIL\n 3. \\<And>a x x'.\n       x \\<le> x' \\<Longrightarrow> x \\<bind> f a \\<le> x' \\<bind> f' a", "apply (simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a x x'.\n       x \\<le> x' \\<Longrightarrow> x \\<bind> f a \\<le> x' \\<bind> f' a", "apply (rule dbind_mono)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a x x'. x \\<le> x' \\<Longrightarrow> x \\<le> x'\n 2. \\<And>a x x' xa.\n       \\<lbrakk>x \\<le> x'; dRETURN xa \\<le> x\\<rbrakk>\n       \\<Longrightarrow> f a xa \\<le> f' a xa", "apply (simp_all add: A)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "partial_function (drec) dfoldli where\n  \"dfoldli l c f s = (case l of \n    [] \\<Rightarrow> dRETURN s \n    | x#ls \\<Rightarrow> if c s then do { s\\<leftarrow>f x s; dfoldli ls c f s} else dRETURN s\n  )\""], ["", "lemma dfoldli_simps[simp]:\n  \"dfoldli [] c f s = dRETURN s\"\n  \"dfoldli (x#ls) c f s = \n    (if c s then do { s\\<leftarrow>f x s; dfoldli ls c f s} else dRETURN s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dfoldli [] c f s = dRETURN s &&&\n    dfoldli (x # ls) c f s =\n    (if c s then f x s \\<bind> dfoldli ls c f else dRETURN s)", "apply (subst dfoldli.simps, simp)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma dfoldli_mono[refine_mono]: \n  \"\\<lbrakk> \\<And>x s. f x s \\<le> f' x s \\<rbrakk> \\<Longrightarrow> dfoldli l c f \\<sigma> \\<le> dfoldli l c f' \\<sigma>\"\n  \"\\<lbrakk> \\<And>x s. flat_ge (f x s) (f' x s) \\<rbrakk> \\<Longrightarrow> flat_ge (dfoldli l c f \\<sigma>) (dfoldli l c f' \\<sigma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<And>x s. f x s \\<le> f' x s) \\<Longrightarrow>\n     dfoldli l c f \\<sigma> \\<le> dfoldli l c f' \\<sigma>) &&&\n    ((\\<And>x s. flat_ge (f x s) (f' x s)) \\<Longrightarrow>\n     flat_ge (dfoldli l c f \\<sigma>) (dfoldli l c f' \\<sigma>))", "apply (induct l arbitrary: \\<sigma>)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>\\<sigma>.\n       (\\<And>x s. f x s \\<le> f' x s) \\<Longrightarrow>\n       dfoldli [] c f \\<sigma> \\<le> dfoldli [] c f' \\<sigma>\n 2. \\<And>\\<sigma>.\n       (\\<And>x s. flat_ge (f x s) (f' x s)) \\<Longrightarrow>\n       flat_ge (dfoldli [] c f \\<sigma>) (dfoldli [] c f' \\<sigma>)\n 3. \\<And>a l \\<sigma>.\n       \\<lbrakk>\\<And>\\<sigma>.\n                   (\\<And>x s. f x s \\<le> f' x s) \\<Longrightarrow>\n                   dfoldli l c f \\<sigma> \\<le> dfoldli l c f' \\<sigma>;\n        \\<And>\\<sigma>.\n           (\\<And>x s. flat_ge (f x s) (f' x s)) \\<Longrightarrow>\n           flat_ge (dfoldli l c f \\<sigma>) (dfoldli l c f' \\<sigma>);\n        \\<And>x s. f x s \\<le> f' x s\\<rbrakk>\n       \\<Longrightarrow> dfoldli (a # l) c f \\<sigma>\n                         \\<le> dfoldli (a # l) c f' \\<sigma>\n 4. \\<And>a l \\<sigma>.\n       \\<lbrakk>\\<And>\\<sigma>.\n                   (\\<And>x s. f x s \\<le> f' x s) \\<Longrightarrow>\n                   dfoldli l c f \\<sigma> \\<le> dfoldli l c f' \\<sigma>;\n        \\<And>\\<sigma>.\n           (\\<And>x s. flat_ge (f x s) (f' x s)) \\<Longrightarrow>\n           flat_ge (dfoldli l c f \\<sigma>) (dfoldli l c f' \\<sigma>);\n        \\<And>x s. flat_ge (f x s) (f' x s)\\<rbrakk>\n       \\<Longrightarrow> flat_ge (dfoldli (a # l) c f \\<sigma>)\n                          (dfoldli (a # l) c f' \\<sigma>)", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a l \\<sigma>.\n       \\<lbrakk>\\<And>\\<sigma>.\n                   dfoldli l c f \\<sigma> \\<le> dfoldli l c f' \\<sigma>;\n        \\<And>\\<sigma>.\n           (\\<And>x s. flat_ge (f x s) (f' x s)) \\<Longrightarrow>\n           flat_ge (dfoldli l c f \\<sigma>) (dfoldli l c f' \\<sigma>);\n        \\<And>x s. f x s \\<le> f' x s; c \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> f a \\<sigma> \\<bind> dfoldli l c f\n                         \\<le> f' a \\<sigma> \\<bind> dfoldli l c f'\n 2. \\<And>a l \\<sigma>.\n       \\<lbrakk>\\<And>\\<sigma>.\n                   (\\<And>x s. f x s \\<le> f' x s) \\<Longrightarrow>\n                   dfoldli l c f \\<sigma> \\<le> dfoldli l c f' \\<sigma>;\n        \\<And>\\<sigma>.\n           flat_ge (dfoldli l c f \\<sigma>) (dfoldli l c f' \\<sigma>);\n        \\<And>x s. flat_ge (f x s) (f' x s); c \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> flat_ge (f a \\<sigma> \\<bind> dfoldli l c f)\n                          (f' a \\<sigma> \\<bind> dfoldli l c f')", "apply refine_mono"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a l \\<sigma>.\n       \\<lbrakk>\\<And>\\<sigma>.\n                   (\\<And>x s. f x s \\<le> f' x s) \\<Longrightarrow>\n                   dfoldli l c f \\<sigma> \\<le> dfoldli l c f' \\<sigma>;\n        \\<And>\\<sigma>.\n           flat_ge (dfoldli l c f \\<sigma>) (dfoldli l c f' \\<sigma>);\n        \\<And>x s. flat_ge (f x s) (f' x s); c \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> flat_ge (f a \\<sigma> \\<bind> dfoldli l c f)\n                          (f' a \\<sigma> \\<bind> dfoldli l c f')", "apply (induct l arbitrary: \\<sigma>)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a l \\<sigma>.\n       \\<lbrakk>\\<And>\\<sigma>.\n                   (\\<And>x s. f x s \\<le> f' x s) \\<Longrightarrow>\n                   dfoldli l c f \\<sigma> \\<le> dfoldli l c f' \\<sigma>;\n        \\<And>\\<sigma>.\n           flat_ge (dfoldli l c f \\<sigma>) (dfoldli l c f' \\<sigma>);\n        \\<And>x s. flat_ge (f x s) (f' x s); c \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> flat_ge (f a \\<sigma> \\<bind> dfoldli l c f)\n                          (f' a \\<sigma> \\<bind> dfoldli l c f')\n 2. \\<And>a l aa la \\<sigma>.\n       \\<lbrakk>\\<And>a l \\<sigma>.\n                   \\<lbrakk>\\<And>\\<sigma>.\n                               (\\<And>x s.\n                                   f x s \\<le> f' x s) \\<Longrightarrow>\n                               dfoldli l c f \\<sigma>\n                               \\<le> dfoldli l c f' \\<sigma>;\n                    \\<And>\\<sigma>.\n                       flat_ge (dfoldli l c f \\<sigma>)\n                        (dfoldli l c f' \\<sigma>);\n                    \\<And>x s. flat_ge (f x s) (f' x s); c \\<sigma>\\<rbrakk>\n                   \\<Longrightarrow> flat_ge\n(f a \\<sigma> \\<bind> dfoldli l c f) (f' a \\<sigma> \\<bind> dfoldli l c f');\n        \\<And>\\<sigma>.\n           (\\<And>x s. f x s \\<le> f' x s) \\<Longrightarrow>\n           dfoldli la c f \\<sigma> \\<le> dfoldli la c f' \\<sigma>;\n        \\<And>\\<sigma>.\n           flat_ge (dfoldli la c f \\<sigma>) (dfoldli la c f' \\<sigma>);\n        \\<And>x s. flat_ge (f x s) (f' x s); c \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> flat_ge (f aa \\<sigma> \\<bind> dfoldli la c f)\n                          (f' aa \\<sigma> \\<bind> dfoldli la c f')", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a l \\<sigma>.\n       \\<lbrakk>\\<And>\\<sigma>.\n                   (\\<And>x s. f x s \\<le> f' x s) \\<Longrightarrow>\n                   dfoldli l c f \\<sigma> \\<le> dfoldli l c f' \\<sigma>;\n        \\<And>\\<sigma>.\n           flat_ge (dfoldli l c f \\<sigma>) (dfoldli l c f' \\<sigma>);\n        \\<And>x s. flat_ge (f x s) (f' x s); c \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> flat_ge (f a \\<sigma> \\<bind> dfoldli l c f)\n                          (f' a \\<sigma> \\<bind> dfoldli l c f')", "apply refine_mono"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma foldli_dres_pres_FAIL[simp]: \n  \"foldli l (case_dres False False c) (\\<lambda>x s. dbind s (f x)) dFAIL = dFAIL\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldli l (case_dres False False c) (\\<lambda>x s. s \\<bind> f x) dFAIL =\n    dFAIL", "by (cases l) auto"], ["", "lemma foldli_dres_pres_SUCCEED[simp]:\n  \"foldli l (case_dres False False c) (\\<lambda>x s. dbind s (f x)) dSUCCEED = dSUCCEED\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldli l (case_dres False False c) (\\<lambda>x s. s \\<bind> f x)\n     dSUCCEED =\n    dSUCCEED", "by (cases l) auto"], ["", "lemma dfoldli_by_foldli: \"dfoldli l c f \\<sigma>\n  = foldli l (case_dres False False c) (\\<lambda>x s. dbind s (f x)) (dRETURN \\<sigma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dfoldli l c f \\<sigma> =\n    foldli l (case_dres False False c) (\\<lambda>x s. s \\<bind> f x)\n     (dRETURN \\<sigma>)", "apply (induction l arbitrary: \\<sigma>)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>\\<sigma>.\n       dfoldli [] c f \\<sigma> =\n       foldli [] (case_dres False False c) (\\<lambda>x s. s \\<bind> f x)\n        (dRETURN \\<sigma>)\n 2. \\<And>a l \\<sigma>.\n       (\\<And>\\<sigma>.\n           dfoldli l c f \\<sigma> =\n           foldli l (case_dres False False c) (\\<lambda>x s. s \\<bind> f x)\n            (dRETURN \\<sigma>)) \\<Longrightarrow>\n       dfoldli (a # l) c f \\<sigma> =\n       foldli (a # l) (case_dres False False c)\n        (\\<lambda>x s. s \\<bind> f x) (dRETURN \\<sigma>)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a l \\<sigma>.\n       (\\<And>\\<sigma>.\n           dfoldli l c f \\<sigma> =\n           foldli l (case_dres False False c) (\\<lambda>x s. s \\<bind> f x)\n            (dRETURN \\<sigma>)) \\<Longrightarrow>\n       dfoldli (a # l) c f \\<sigma> =\n       foldli (a # l) (case_dres False False c)\n        (\\<lambda>x s. s \\<bind> f x) (dRETURN \\<sigma>)", "apply (clarsimp intro!: ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a l \\<sigma>.\n       \\<lbrakk>\\<And>\\<sigma>.\n                   dfoldli l c f \\<sigma> =\n                   foldli l (case_dres False False c)\n                    (\\<lambda>x s. s \\<bind> f x) (dRETURN \\<sigma>);\n        c \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> f a \\<sigma> \\<bind> dfoldli l c f =\n                         foldli l (case_dres False False c)\n                          (\\<lambda>x s. s \\<bind> f x) (f a \\<sigma>)", "apply (rename_tac a l x)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a l x.\n       \\<lbrakk>\\<And>\\<sigma>.\n                   dfoldli l c f \\<sigma> =\n                   foldli l (case_dres False False c)\n                    (\\<lambda>x s. s \\<bind> f x) (dRETURN \\<sigma>);\n        c x\\<rbrakk>\n       \\<Longrightarrow> f a x \\<bind> dfoldli l c f =\n                         foldli l (case_dres False False c)\n                          (\\<lambda>x s. s \\<bind> f x) (f a x)", "apply (case_tac \"f a x\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a l x.\n       \\<lbrakk>\\<And>\\<sigma>.\n                   dfoldli l c f \\<sigma> =\n                   foldli l (case_dres False False c)\n                    (\\<lambda>x s. s \\<bind> f x) (dRETURN \\<sigma>);\n        c x; f a x = dSUCCEED\\<rbrakk>\n       \\<Longrightarrow> f a x \\<bind> dfoldli l c f =\n                         foldli l (case_dres False False c)\n                          (\\<lambda>x s. s \\<bind> f x) (f a x)\n 2. \\<And>a l x r.\n       \\<lbrakk>\\<And>\\<sigma>.\n                   dfoldli l c f \\<sigma> =\n                   foldli l (case_dres False False c)\n                    (\\<lambda>x s. s \\<bind> f x) (dRETURN \\<sigma>);\n        c x; f a x = dRETURN r\\<rbrakk>\n       \\<Longrightarrow> f a x \\<bind> dfoldli l c f =\n                         foldli l (case_dres False False c)\n                          (\\<lambda>x s. s \\<bind> f x) (f a x)\n 3. \\<And>a l x.\n       \\<lbrakk>\\<And>\\<sigma>.\n                   dfoldli l c f \\<sigma> =\n                   foldli l (case_dres False False c)\n                    (\\<lambda>x s. s \\<bind> f x) (dRETURN \\<sigma>);\n        c x; f a x = dFAIL\\<rbrakk>\n       \\<Longrightarrow> f a x \\<bind> dfoldli l c f =\n                         foldli l (case_dres False False c)\n                          (\\<lambda>x s. s \\<bind> f x) (f a x)", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma foldli_mono_dres_flat[refine_mono]:\n  assumes A: \"\\<And>a x. flat_ge (f a x) (f' a x)\"\n  shows \"flat_ge (foldli l (case_dres False False c) (\\<lambda>x s. dbind s (f x)) \\<sigma>) \n          (foldli l (case_dres False False c) (\\<lambda>x s. dbind s (f' x)) \\<sigma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. flat_ge\n     (foldli l (case_dres False False c) (\\<lambda>x s. s \\<bind> f x)\n       \\<sigma>)\n     (foldli l (case_dres False False c) (\\<lambda>x s. s \\<bind> f' x)\n       \\<sigma>)", "apply (cases \\<sigma>)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<sigma> = dSUCCEED \\<Longrightarrow>\n    flat_ge\n     (foldli l (case_dres False False c) (\\<lambda>x s. s \\<bind> f x)\n       \\<sigma>)\n     (foldli l (case_dres False False c) (\\<lambda>x s. s \\<bind> f' x)\n       \\<sigma>)\n 2. \\<And>r.\n       \\<sigma> = dRETURN r \\<Longrightarrow>\n       flat_ge\n        (foldli l (case_dres False False c) (\\<lambda>x s. s \\<bind> f x)\n          \\<sigma>)\n        (foldli l (case_dres False False c) (\\<lambda>x s. s \\<bind> f' x)\n          \\<sigma>)\n 3. \\<sigma> = dFAIL \\<Longrightarrow>\n    flat_ge\n     (foldli l (case_dres False False c) (\\<lambda>x s. s \\<bind> f x)\n       \\<sigma>)\n     (foldli l (case_dres False False c) (\\<lambda>x s. s \\<bind> f' x)\n       \\<sigma>)", "apply (simp_all add: dfoldli_by_foldli[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>r.\n       \\<sigma> = dRETURN r \\<Longrightarrow>\n       flat_ge (dfoldli l c f r) (dfoldli l c f' r)", "using A"], ["proof (prove)\nusing this:\n  flat_ge (f ?a ?x) (f' ?a ?x)\n\ngoal (1 subgoal):\n 1. \\<And>r.\n       \\<sigma> = dRETURN r \\<Longrightarrow>\n       flat_ge (dfoldli l c f r) (dfoldli l c f' r)", "apply refine_mono"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma dres_foldli_ne_bot[refine_transfer]:\n  assumes 1: \"\\<sigma> \\<noteq> dSUCCEED\"\n  assumes 2: \"\\<And>x \\<sigma>. f x \\<sigma> \\<noteq> dSUCCEED\"\n  shows \"foldli l c (\\<lambda>x s. s \\<bind> f x) \\<sigma> \\<noteq> dSUCCEED\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldli l c (\\<lambda>x s. s \\<bind> f x) \\<sigma> \\<noteq> dSUCCEED", "using 1"], ["proof (prove)\nusing this:\n  \\<sigma> \\<noteq> dSUCCEED\n\ngoal (1 subgoal):\n 1. foldli l c (\\<lambda>x s. s \\<bind> f x) \\<sigma> \\<noteq> dSUCCEED", "apply (induct l arbitrary: \\<sigma>)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>\\<sigma>.\n       \\<sigma> \\<noteq> dSUCCEED \\<Longrightarrow>\n       foldli [] c (\\<lambda>x s. s \\<bind> f x) \\<sigma> \\<noteq> dSUCCEED\n 2. \\<And>a l \\<sigma>.\n       \\<lbrakk>\\<And>\\<sigma>.\n                   \\<sigma> \\<noteq> dSUCCEED \\<Longrightarrow>\n                   foldli l c (\\<lambda>x s. s \\<bind> f x)\n                    \\<sigma> \\<noteq>\n                   dSUCCEED;\n        \\<sigma> \\<noteq> dSUCCEED\\<rbrakk>\n       \\<Longrightarrow> foldli (a # l) c (\\<lambda>x s. s \\<bind> f x)\n                          \\<sigma> \\<noteq>\n                         dSUCCEED", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a l \\<sigma>.\n       \\<lbrakk>\\<And>\\<sigma>.\n                   \\<sigma> \\<noteq> dSUCCEED \\<Longrightarrow>\n                   foldli l c (\\<lambda>x s. s \\<bind> f x)\n                    \\<sigma> \\<noteq>\n                   dSUCCEED;\n        \\<sigma> \\<noteq> dSUCCEED\\<rbrakk>\n       \\<Longrightarrow> foldli (a # l) c (\\<lambda>x s. s \\<bind> f x)\n                          \\<sigma> \\<noteq>\n                         dSUCCEED", "apply (simp split: dres.split, intro allI impI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a l \\<sigma>.\n       \\<lbrakk>\\<And>\\<sigma>.\n                   \\<sigma> \\<noteq> dSUCCEED \\<Longrightarrow>\n                   foldli l c (\\<lambda>x s. s \\<bind> f x)\n                    \\<sigma> \\<noteq>\n                   dSUCCEED;\n        \\<sigma> \\<noteq> dSUCCEED; c \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> foldli l c (\\<lambda>x s. s \\<bind> f x)\n                          (\\<sigma> \\<bind> f a) \\<noteq>\n                         dSUCCEED", "apply rprems"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a l \\<sigma>.\n       \\<lbrakk>\\<sigma> \\<noteq> dSUCCEED; c \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> \\<bind> f a \\<noteq> dSUCCEED", "using 2"], ["proof (prove)\nusing this:\n  f ?x ?\\<sigma> \\<noteq> dSUCCEED\n\ngoal (1 subgoal):\n 1. \\<And>a l \\<sigma>.\n       \\<lbrakk>\\<sigma> \\<noteq> dSUCCEED; c \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> \\<bind> f a \\<noteq> dSUCCEED", "apply (simp add: dres_ne_bot_basic)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection \\<open>LIST FOREACH combinator\\<close>"], ["", "text \\<open>\n  Foreach-loops are mapped to the combinator \\<open>LIST_FOREACH\\<close>, that\n  takes as first argument an explicit \\<open>to_list\\<close> operation. \n  This mapping is done during operation identification. \n  It is then the responsibility of the various implementations to further map\n  the \\<open>to_list\\<close> operations to custom \\<open>to_list\\<close> operations, like\n  \\<open>set_to_list\\<close>, \\<open>map_to_list\\<close>, \\<open>nodes_to_list\\<close>, etc.\n\\<close>"], ["", "text \\<open>We define a relation between distinct lists and sets.\\<close>"], ["", "definition [to_relAPP]: \"list_set_rel R \\<equiv> \\<langle>R\\<rangle>list_rel O br set distinct\""], ["", "lemma autoref_nfoldli[autoref_rules]:\n  shows \"(nfoldli, nfoldli)\n  \\<in> \\<langle>Ra\\<rangle>list_rel \\<rightarrow> (Rb \\<rightarrow> bool_rel) \\<rightarrow> (Ra \\<rightarrow> Rb \\<rightarrow> \\<langle>Rb\\<rangle>nres_rel) \\<rightarrow> Rb \\<rightarrow> \\<langle>Rb\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (nfoldli, nfoldli)\n    \\<in> \\<langle>Ra\\<rangle>list_rel \\<rightarrow>\n          (Rb \\<rightarrow> bool_rel) \\<rightarrow>\n          (Ra \\<rightarrow>\n           Rb \\<rightarrow> \\<langle>Rb\\<rangle>nres_rel) \\<rightarrow>\n          Rb \\<rightarrow> \\<langle>Rb\\<rangle>nres_rel", "by (rule param_nfoldli)"], ["", "text \\<open>This constant is a placeholder to be converted to\n  custom operations by pattern rules\\<close>"], ["", "definition \"it_to_sorted_list R s \n  \\<equiv> SPEC (\\<lambda>l. distinct l \\<and> s = set l \\<and> sorted_wrt R l)\""], ["", "definition \"LIST_FOREACH \\<Phi> tsl c f \\<sigma>0 \\<equiv> do {\n  xs \\<leftarrow> tsl;\n  (_,\\<sigma>) \\<leftarrow> WHILE\\<^sub>T\\<^bsup>\\<lambda>(it, \\<sigma>). \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>\\<^esup>\n    (FOREACH_cond c) (FOREACH_body f) (xs, \\<sigma>0);\n    RETURN \\<sigma>}\""], ["", "lemma FOREACHoci_by_LIST_FOREACH:\n  \"FOREACHoci R \\<Phi> S c f \\<sigma>0 = do {\n    ASSERT (finite S);\n    LIST_FOREACH \\<Phi> (it_to_sorted_list R S) c f \\<sigma>0\n  }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. FOREACH\\<^sub>O\\<^sub>C\\<^bsup>R,\\<Phi>\\<^esup> S c f \\<sigma>0 =\n    ASSERT (finite S) \\<bind>\n    (\\<lambda>_. LIST_FOREACH \\<Phi> (it_to_sorted_list R S) c f \\<sigma>0)", "unfolding OP_def FOREACHoci_def LIST_FOREACH_def it_to_sorted_list_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ASSERT (finite S) \\<bind>\n    (\\<lambda>_.\n        SPEC\n         (\\<lambda>xs.\n             distinct xs \\<and> S = set xs \\<and> sorted_wrt R xs) \\<bind>\n        (\\<lambda>xs.\n            WHILE\\<^sub>T\\<^bsup>\\<lambda>(it, \\<sigma>).\n                                    \\<exists>xs'.\n xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>\\<^esup>\n             (FOREACH_cond c) (FOREACH_body f) (xs, \\<sigma>0) \\<bind>\n            (\\<lambda>(uu_, \\<sigma>). RETURN \\<sigma>))) =\n    ASSERT (finite S) \\<bind>\n    (\\<lambda>_.\n        SPEC\n         (\\<lambda>l.\n             distinct l \\<and> S = set l \\<and> sorted_wrt R l) \\<bind>\n        (\\<lambda>xs.\n            WHILE\\<^sub>T\\<^bsup>\\<lambda>(it, \\<sigma>).\n                                    \\<exists>xs'.\n xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>\\<^esup>\n             (FOREACH_cond c) (FOREACH_body f) (xs, \\<sigma>0) \\<bind>\n            (\\<lambda>(uu_, \\<sigma>). RETURN \\<sigma>)))", "by simp"], ["", "text \\<open>Patterns that convert FOREACH-constructs \n  to \\<open>LIST_FOREACH\\<close>\n\\<close>"], ["", "context begin"], ["", "interpretation autoref_syn"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma FOREACH_patterns[autoref_op_pat_def]:\n  \"FOREACH\\<^bsup>I\\<^esup> s f \\<equiv> FOREACH\\<^sub>O\\<^sub>C\\<^bsup>\\<lambda>_ _. True,I\\<^esup> s (\\<lambda>_. True) f\"\n  \"FOREACHci I s c f \\<equiv> FOREACHoci (\\<lambda>_ _. True) I s c f\"\n  \"FOREACH\\<^sub>O\\<^sub>C\\<^bsup>R,\\<Phi>\\<^esup> s c f \\<equiv> \\<lambda>\\<sigma>. do {\n    ASSERT (finite s);\n    Autoref_Tagging.OP (LIST_FOREACH \\<Phi>) (it_to_sorted_list R s) c f \\<sigma>\n  }\"\n  \"FOREACH s f \\<equiv> FOREACHoci (\\<lambda>_ _. True) (\\<lambda>_ _. True) s (\\<lambda>_. True) f\"\n  \"FOREACHoi R I s f \\<equiv> FOREACHoci R I s (\\<lambda>_. True) f\"\n  \"FOREACHc s c f \\<equiv> FOREACHoci (\\<lambda>_ _. True) (\\<lambda>_ _. True) s c f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((FOREACH\\<^bsup>I\\<^esup> s f \\<equiv>\n      FOREACH\\<^sub>O\\<^sub>C\\<^bsup>\\<lambda>_ _. True,I\\<^esup> s\n       (\\<lambda>_. True) f) &&&\n     (FOREACH\\<^sub>C\\<^bsup>I\\<^esup> s c f \\<equiv>\n      FOREACH\\<^sub>O\\<^sub>C\\<^bsup>\\<lambda>_ _. True,I\\<^esup> s c f) &&&\n     FOREACH\\<^sub>O\\<^sub>C\\<^bsup>R,\\<Phi>\\<^esup> s c f \\<equiv>\n     \\<lambda>\\<sigma>.\n        ASSERT (finite s) \\<bind>\n        (\\<lambda>_.\n            OP (LIST_FOREACH \\<Phi>) (it_to_sorted_list R s) c f\n             \\<sigma>)) &&&\n    (FOREACH s f \\<equiv>\n     FOREACH\\<^sub>O\\<^sub>C\\<^bsup>\\<lambda>_ _.\n True,\\<lambda>_ _. True\\<^esup>\n      s (\\<lambda>_. True) f) &&&\n    (FOREACH\\<^sub>O\\<^bsup>R,I\\<^esup> s f \\<equiv>\n     FOREACH\\<^sub>O\\<^sub>C\\<^bsup>R,I\\<^esup> s (\\<lambda>_. True) f) &&&\n    FOREACH\\<^sub>C s c f \\<equiv>\n    FOREACH\\<^sub>O\\<^sub>C\\<^bsup>\\<lambda>_ _.\nTrue,\\<lambda>_ _. True\\<^esup>\n     s c f", "unfolding \n    FOREACHoci_by_LIST_FOREACH[abs_def]\n    FOREACHc_def[abs_def] \n    FOREACH_def[abs_def] \n    FOREACHci_def[abs_def] \n    FOREACHi_def[abs_def] \n    FOREACHoi_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>\\<sigma>0.\n         ASSERT (finite s) \\<bind>\n         (\\<lambda>_.\n             LIST_FOREACH I (it_to_sorted_list (\\<lambda>_ _. True) s)\n              (\\<lambda>_. True) f \\<sigma>0) \\<equiv>\n      \\<lambda>\\<sigma>0.\n         ASSERT (finite s) \\<bind>\n         (\\<lambda>_.\n             LIST_FOREACH I (it_to_sorted_list (\\<lambda>_ _. True) s)\n              (\\<lambda>_. True) f \\<sigma>0)) &&&\n     (\\<lambda>\\<sigma>0.\n         ASSERT (finite s) \\<bind>\n         (\\<lambda>_.\n             LIST_FOREACH I (it_to_sorted_list (\\<lambda>_ _. True) s) c f\n              \\<sigma>0) \\<equiv>\n      \\<lambda>\\<sigma>0.\n         ASSERT (finite s) \\<bind>\n         (\\<lambda>_.\n             LIST_FOREACH I (it_to_sorted_list (\\<lambda>_ _. True) s) c f\n              \\<sigma>0)) &&&\n     \\<lambda>\\<sigma>0.\n        ASSERT (finite s) \\<bind>\n        (\\<lambda>_.\n            LIST_FOREACH \\<Phi> (it_to_sorted_list R s) c f\n             \\<sigma>0) \\<equiv>\n     \\<lambda>\\<sigma>.\n        ASSERT (finite s) \\<bind>\n        (\\<lambda>_.\n            OP (LIST_FOREACH \\<Phi>) (it_to_sorted_list R s) c f\n             \\<sigma>)) &&&\n    (\\<lambda>\\<sigma>0.\n        ASSERT (finite s) \\<bind>\n        (\\<lambda>_.\n            LIST_FOREACH (\\<lambda>_ _. True)\n             (it_to_sorted_list (\\<lambda>_ _. True) s) (\\<lambda>_. True) f\n             \\<sigma>0) \\<equiv>\n     \\<lambda>\\<sigma>0.\n        ASSERT (finite s) \\<bind>\n        (\\<lambda>_.\n            LIST_FOREACH (\\<lambda>_ _. True)\n             (it_to_sorted_list (\\<lambda>_ _. True) s) (\\<lambda>_. True) f\n             \\<sigma>0)) &&&\n    (\\<lambda>\\<sigma>0.\n        ASSERT (finite s) \\<bind>\n        (\\<lambda>_.\n            LIST_FOREACH I (it_to_sorted_list R s) (\\<lambda>_. True) f\n             \\<sigma>0) \\<equiv>\n     \\<lambda>\\<sigma>0.\n        ASSERT (finite s) \\<bind>\n        (\\<lambda>_.\n            LIST_FOREACH I (it_to_sorted_list R s) (\\<lambda>_. True) f\n             \\<sigma>0)) &&&\n    \\<lambda>\\<sigma>0.\n       ASSERT (finite s) \\<bind>\n       (\\<lambda>_.\n           LIST_FOREACH (\\<lambda>_ _. True)\n            (it_to_sorted_list (\\<lambda>_ _. True) s) c f\n            \\<sigma>0) \\<equiv>\n    \\<lambda>\\<sigma>0.\n       ASSERT (finite s) \\<bind>\n       (\\<lambda>_.\n           LIST_FOREACH (\\<lambda>_ _. True)\n            (it_to_sorted_list (\\<lambda>_ _. True) s) c f \\<sigma>0)", "by simp_all"], ["", "(*lemma FOREACH_patterns[autoref_op_pat]: \n  \"FOREACHoci R \\<Phi> s c f \\<sigma> \\<equiv> do {\n    ASSERT (finite s);\n    OP (LIST_FOREACH \\<Phi>) (it_to_sorted_list R s) c f \\<sigma>\n  }\"\n  \"FOREACHc s c f \\<sigma> \\<equiv> FOREACHoci (\\<lambda>_ _. True) (\\<lambda>_ _. True) s c f \\<sigma>\"\n  \"FOREACH s f \\<sigma> \\<equiv> FOREACHoci (\\<lambda>_ _. True) (\\<lambda>_ _. True) s (\\<lambda>_. True) f \\<sigma>\"\n  \"FOREACHci I s c f \\<sigma> \\<equiv> FOREACHoci (\\<lambda>_ _. True) I s c f \\<sigma>\"\n  \"FOREACHi I s f \\<sigma> \\<equiv> FOREACHoci (\\<lambda>_ _. True) I s (\\<lambda>_. True) f \\<sigma>\"\n  \"FOREACHoi R I s f \\<sigma> \\<equiv> FOREACHoci R I s (\\<lambda>_. True) f \\<sigma>\"\n  unfolding \n    FOREACHoci_by_LIST_FOREACH[abs_def]\n    FOREACHc_def[abs_def] \n    FOREACH_def[abs_def] \n    FOREACHci_def[abs_def] \n    FOREACHi_def[abs_def] \n    FOREACHoi_def[abs_def] \n  by simp_all*)"], ["", "end"], ["", "definition \"LIST_FOREACH' tsl c f \\<sigma> \\<equiv> do {xs \\<leftarrow> tsl; nfoldli xs c f \\<sigma>}\""], ["", "lemma LIST_FOREACH'_param[param]: \n  shows \"(LIST_FOREACH',LIST_FOREACH') \n  \\<in> (\\<langle>\\<langle>Rv\\<rangle>list_rel\\<rangle>nres_rel \\<rightarrow> (R\\<sigma>\\<rightarrow>bool_rel) \n    \\<rightarrow> (Rv \\<rightarrow> R\\<sigma> \\<rightarrow> \\<langle>R\\<sigma>\\<rangle>nres_rel) \\<rightarrow> R\\<sigma> \\<rightarrow> \\<langle>R\\<sigma>\\<rangle>nres_rel)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (LIST_FOREACH', LIST_FOREACH')\n    \\<in> \\<langle>\\<langle>Rv\\<rangle>list_rel\\<rangle>nres_rel \\<rightarrow>\n          (R\\<sigma> \\<rightarrow> bool_rel) \\<rightarrow>\n          (Rv \\<rightarrow>\n           R\\<sigma> \\<rightarrow>\n           \\<langle>R\\<sigma>\\<rangle>nres_rel) \\<rightarrow>\n          R\\<sigma> \\<rightarrow> \\<langle>R\\<sigma>\\<rangle>nres_rel", "unfolding LIST_FOREACH'_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>tsl c f \\<sigma>.\n        tsl \\<bind> (\\<lambda>xs. nfoldli xs c f \\<sigma>),\n     \\<lambda>tsl c f \\<sigma>.\n        tsl \\<bind> (\\<lambda>xs. nfoldli xs c f \\<sigma>))\n    \\<in> \\<langle>\\<langle>Rv\\<rangle>list_rel\\<rangle>nres_rel \\<rightarrow>\n          (R\\<sigma> \\<rightarrow> bool_rel) \\<rightarrow>\n          (Rv \\<rightarrow>\n           R\\<sigma> \\<rightarrow>\n           \\<langle>R\\<sigma>\\<rangle>nres_rel) \\<rightarrow>\n          R\\<sigma> \\<rightarrow> \\<langle>R\\<sigma>\\<rangle>nres_rel", "by parametricity"], ["", "lemma LIST_FOREACH_autoref[autoref_rules]:\n  shows \"(LIST_FOREACH', LIST_FOREACH \\<Phi>) \\<in> \n    (\\<langle>\\<langle>Rv\\<rangle>list_rel\\<rangle>nres_rel \\<rightarrow> (R\\<sigma>\\<rightarrow>bool_rel) \n      \\<rightarrow> (Rv \\<rightarrow> R\\<sigma> \\<rightarrow> \\<langle>R\\<sigma>\\<rangle>nres_rel) \\<rightarrow> R\\<sigma> \\<rightarrow> \\<langle>R\\<sigma>\\<rangle>nres_rel)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (LIST_FOREACH', LIST_FOREACH \\<Phi>)\n    \\<in> \\<langle>\\<langle>Rv\\<rangle>list_rel\\<rangle>nres_rel \\<rightarrow>\n          (R\\<sigma> \\<rightarrow> bool_rel) \\<rightarrow>\n          (Rv \\<rightarrow>\n           R\\<sigma> \\<rightarrow>\n           \\<langle>R\\<sigma>\\<rangle>nres_rel) \\<rightarrow>\n          R\\<sigma> \\<rightarrow> \\<langle>R\\<sigma>\\<rangle>nres_rel", "proof (intro fun_relI nres_relI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a ab a'b ac a'c.\n       \\<lbrakk>(a, a')\n                \\<in> \\<langle>\\<langle>Rv\\<rangle>list_rel\\<rangle>nres_rel;\n        (aa, a'a) \\<in> R\\<sigma> \\<rightarrow> bool_rel;\n        (ab, a'b)\n        \\<in> Rv \\<rightarrow>\n              R\\<sigma> \\<rightarrow> \\<langle>R\\<sigma>\\<rangle>nres_rel;\n        (ac, a'c) \\<in> R\\<sigma>\\<rbrakk>\n       \\<Longrightarrow> LIST_FOREACH' a aa ab ac\n                         \\<le> \\<Down> R\\<sigma>\n                                (LIST_FOREACH \\<Phi> a' a'a a'b a'c)", "fix tsl tsl' c c' f f' \\<sigma> \\<sigma>'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a ab a'b ac a'c.\n       \\<lbrakk>(a, a')\n                \\<in> \\<langle>\\<langle>Rv\\<rangle>list_rel\\<rangle>nres_rel;\n        (aa, a'a) \\<in> R\\<sigma> \\<rightarrow> bool_rel;\n        (ab, a'b)\n        \\<in> Rv \\<rightarrow>\n              R\\<sigma> \\<rightarrow> \\<langle>R\\<sigma>\\<rangle>nres_rel;\n        (ac, a'c) \\<in> R\\<sigma>\\<rbrakk>\n       \\<Longrightarrow> LIST_FOREACH' a aa ab ac\n                         \\<le> \\<Down> R\\<sigma>\n                                (LIST_FOREACH \\<Phi> a' a'a a'b a'c)", "assume [param]:\n    \"(tsl,tsl')\\<in>\\<langle>\\<langle>Rv\\<rangle>list_rel\\<rangle>nres_rel\"\n    \"(c,c')\\<in>R\\<sigma>\\<rightarrow>bool_rel\" \n    \"(f,f')\\<in>Rv\\<rightarrow>R\\<sigma>\\<rightarrow>\\<langle>R\\<sigma>\\<rangle>nres_rel\"\n    \"(\\<sigma>,\\<sigma>')\\<in>R\\<sigma>\""], ["proof (state)\nthis:\n  (tsl, tsl') \\<in> \\<langle>\\<langle>Rv\\<rangle>list_rel\\<rangle>nres_rel\n  (c, c') \\<in> R\\<sigma> \\<rightarrow> bool_rel\n  (f, f')\n  \\<in> Rv \\<rightarrow>\n        R\\<sigma> \\<rightarrow> \\<langle>R\\<sigma>\\<rangle>nres_rel\n  (\\<sigma>, \\<sigma>') \\<in> R\\<sigma>\n\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a ab a'b ac a'c.\n       \\<lbrakk>(a, a')\n                \\<in> \\<langle>\\<langle>Rv\\<rangle>list_rel\\<rangle>nres_rel;\n        (aa, a'a) \\<in> R\\<sigma> \\<rightarrow> bool_rel;\n        (ab, a'b)\n        \\<in> Rv \\<rightarrow>\n              R\\<sigma> \\<rightarrow> \\<langle>R\\<sigma>\\<rangle>nres_rel;\n        (ac, a'c) \\<in> R\\<sigma>\\<rbrakk>\n       \\<Longrightarrow> LIST_FOREACH' a aa ab ac\n                         \\<le> \\<Down> R\\<sigma>\n                                (LIST_FOREACH \\<Phi> a' a'a a'b a'c)", "have \"LIST_FOREACH' tsl c f \\<sigma> \\<le> \\<Down>R\\<sigma> (LIST_FOREACH' tsl' c' f' \\<sigma>')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LIST_FOREACH' tsl c f \\<sigma>\n    \\<le> \\<Down> R\\<sigma> (LIST_FOREACH' tsl' c' f' \\<sigma>')", "apply (rule nres_relD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (LIST_FOREACH' tsl c f \\<sigma>, LIST_FOREACH' tsl' c' f' \\<sigma>')\n    \\<in> \\<langle>R\\<sigma>\\<rangle>nres_rel", "by parametricity"], ["proof (state)\nthis:\n  LIST_FOREACH' tsl c f \\<sigma>\n  \\<le> \\<Down> R\\<sigma> (LIST_FOREACH' tsl' c' f' \\<sigma>')\n\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a ab a'b ac a'c.\n       \\<lbrakk>(a, a')\n                \\<in> \\<langle>\\<langle>Rv\\<rangle>list_rel\\<rangle>nres_rel;\n        (aa, a'a) \\<in> R\\<sigma> \\<rightarrow> bool_rel;\n        (ab, a'b)\n        \\<in> Rv \\<rightarrow>\n              R\\<sigma> \\<rightarrow> \\<langle>R\\<sigma>\\<rangle>nres_rel;\n        (ac, a'c) \\<in> R\\<sigma>\\<rbrakk>\n       \\<Longrightarrow> LIST_FOREACH' a aa ab ac\n                         \\<le> \\<Down> R\\<sigma>\n                                (LIST_FOREACH \\<Phi> a' a'a a'b a'c)", "also"], ["proof (state)\nthis:\n  LIST_FOREACH' tsl c f \\<sigma>\n  \\<le> \\<Down> R\\<sigma> (LIST_FOREACH' tsl' c' f' \\<sigma>')\n\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a ab a'b ac a'c.\n       \\<lbrakk>(a, a')\n                \\<in> \\<langle>\\<langle>Rv\\<rangle>list_rel\\<rangle>nres_rel;\n        (aa, a'a) \\<in> R\\<sigma> \\<rightarrow> bool_rel;\n        (ab, a'b)\n        \\<in> Rv \\<rightarrow>\n              R\\<sigma> \\<rightarrow> \\<langle>R\\<sigma>\\<rangle>nres_rel;\n        (ac, a'c) \\<in> R\\<sigma>\\<rbrakk>\n       \\<Longrightarrow> LIST_FOREACH' a aa ab ac\n                         \\<le> \\<Down> R\\<sigma>\n                                (LIST_FOREACH \\<Phi> a' a'a a'b a'c)", "have \"LIST_FOREACH' tsl' c' f' \\<sigma>'\n    \\<le> LIST_FOREACH \\<Phi> tsl' c' f' \\<sigma>'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LIST_FOREACH' tsl' c' f' \\<sigma>'\n    \\<le> LIST_FOREACH \\<Phi> tsl' c' f' \\<sigma>'", "apply (rule refine_IdD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. LIST_FOREACH' tsl' c' f' \\<sigma>'\n    \\<le> \\<Down> Id (LIST_FOREACH \\<Phi> tsl' c' f' \\<sigma>')", "unfolding LIST_FOREACH_def LIST_FOREACH'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. tsl' \\<bind> (\\<lambda>xs. nfoldli xs c' f' \\<sigma>')\n    \\<le> \\<Down> Id\n           (tsl' \\<bind>\n            (\\<lambda>xs.\n                WHILE\\<^sub>T\\<^bsup>\\<lambda>(it, \\<sigma>).\n  \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>\\<^esup>\n                 (FOREACH_cond c') (FOREACH_body f') (xs, \\<sigma>') \\<bind>\n                (\\<lambda>(uu_, \\<sigma>). RETURN \\<sigma>)))", "apply refine_rcg"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs xsa.\n       (xs, xsa) \\<in> Id \\<Longrightarrow>\n       nfoldli xs c' f' \\<sigma>'\n       \\<le> \\<Down> Id\n              (WHILE\\<^sub>T\\<^bsup>\\<lambda>(it, \\<sigma>).\n \\<exists>xs'. xsa = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>\\<^esup>\n                (FOREACH_cond c') (FOREACH_body f') (xsa, \\<sigma>') \\<bind>\n               (\\<lambda>(uu_, \\<sigma>). RETURN \\<sigma>))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       nfoldli xs c' f' \\<sigma>'\n       \\<le> WHILE\\<^sub>T\\<^bsup>\\<lambda>(it, \\<sigma>).\n                                     (\\<exists>xs'. xs = xs' @ it) \\<and>\n                                     \\<Phi> (set it) \\<sigma>\\<^esup>\n              (FOREACH_cond c') (FOREACH_body f') (xs, \\<sigma>') \\<bind>\n             (\\<lambda>(uu_, y). RETURN y)", "apply (rule nfoldli_while)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  LIST_FOREACH' tsl' c' f' \\<sigma>'\n  \\<le> LIST_FOREACH \\<Phi> tsl' c' f' \\<sigma>'\n\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a ab a'b ac a'c.\n       \\<lbrakk>(a, a')\n                \\<in> \\<langle>\\<langle>Rv\\<rangle>list_rel\\<rangle>nres_rel;\n        (aa, a'a) \\<in> R\\<sigma> \\<rightarrow> bool_rel;\n        (ab, a'b)\n        \\<in> Rv \\<rightarrow>\n              R\\<sigma> \\<rightarrow> \\<langle>R\\<sigma>\\<rangle>nres_rel;\n        (ac, a'c) \\<in> R\\<sigma>\\<rbrakk>\n       \\<Longrightarrow> LIST_FOREACH' a aa ab ac\n                         \\<le> \\<Down> R\\<sigma>\n                                (LIST_FOREACH \\<Phi> a' a'a a'b a'c)", "finally"], ["proof (chain)\npicking this:\n  LIST_FOREACH' tsl c f \\<sigma>\n  \\<le> \\<Down> R\\<sigma> (LIST_FOREACH \\<Phi> tsl' c' f' \\<sigma>')", "show \n    \"LIST_FOREACH' tsl c f \\<sigma> \\<le> \\<Down> R\\<sigma> (LIST_FOREACH \\<Phi> tsl' c' f' \\<sigma>')\""], ["proof (prove)\nusing this:\n  LIST_FOREACH' tsl c f \\<sigma>\n  \\<le> \\<Down> R\\<sigma> (LIST_FOREACH \\<Phi> tsl' c' f' \\<sigma>')\n\ngoal (1 subgoal):\n 1. LIST_FOREACH' tsl c f \\<sigma>\n    \\<le> \\<Down> R\\<sigma> (LIST_FOREACH \\<Phi> tsl' c' f' \\<sigma>')", "."], ["proof (state)\nthis:\n  LIST_FOREACH' tsl c f \\<sigma>\n  \\<le> \\<Down> R\\<sigma> (LIST_FOREACH \\<Phi> tsl' c' f' \\<sigma>')\n\ngoal:\nNo subgoals!", "qed"], ["", "context begin"], ["", "interpretation trimono_spec"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma LIST_FOREACH'_mono[unfolded trimono_spec_defs,refine_mono]: \n  \"trimono_spec (R o R o M2 o R) LIST_FOREACH'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trimono_spec\n     (lift_refl \\<circ> lift_refl \\<circ> lift_mono2 \\<circ> lift_refl)\n     LIST_FOREACH'", "apply (unfold trimono_spec_defs)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x xa xb y.\n        (\\<And>a b. xb a b \\<le> y a b) \\<Longrightarrow>\n        (\\<And>xc.\n            LIST_FOREACH' x xa xb xc \\<le> LIST_FOREACH' x xa y xc)) &&&\n    (\\<And>x xa xb y.\n        (\\<And>a b. flat_ge (xb a b) (y a b)) \\<Longrightarrow>\n        (\\<And>xc.\n            flat_ge (LIST_FOREACH' x xa xb xc) (LIST_FOREACH' x xa y xc)))", "apply -"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xa xb y.\n       (\\<And>a b. xb a b \\<le> y a b) \\<Longrightarrow>\n       (\\<And>xc. LIST_FOREACH' x xa xb xc \\<le> LIST_FOREACH' x xa y xc)\n 2. \\<And>x xa xb y.\n       (\\<And>a b. flat_ge (xb a b) (y a b)) \\<Longrightarrow>\n       (\\<And>xc.\n           flat_ge (LIST_FOREACH' x xa xb xc) (LIST_FOREACH' x xa y xc))", "unfolding LIST_FOREACH'_def"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xa xb y.\n       (\\<And>a b. xb a b \\<le> y a b) \\<Longrightarrow>\n       (\\<And>xc.\n           x \\<bind> (\\<lambda>xs. nfoldli xs xa xb xc)\n           \\<le> x \\<bind> (\\<lambda>xs. nfoldli xs xa y xc))\n 2. \\<And>x xa xb y.\n       (\\<And>a b. flat_ge (xb a b) (y a b)) \\<Longrightarrow>\n       (\\<And>xc.\n           flat_ge (x \\<bind> (\\<lambda>xs. nfoldli xs xa xb xc))\n            (x \\<bind> (\\<lambda>xs. nfoldli xs xa y xc)))", "by refine_mono+"], ["", "end"], ["", "lemma LIST_FOREACH'_transfer_plain[refine_transfer]:\n  assumes \"RETURN tsl \\<le> tsl'\"\n  assumes \"\\<And>x \\<sigma>. RETURN (f x \\<sigma>) \\<le> f' x \\<sigma>\"\n  shows \"RETURN (foldli tsl c f \\<sigma>) \\<le> LIST_FOREACH' tsl' c f' \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RETURN (foldli tsl c f \\<sigma>) \\<le> LIST_FOREACH' tsl' c f' \\<sigma>", "apply (rule order_trans[rotated])"], ["proof (prove)\ngoal (2 subgoals):\n 1. ?y \\<le> LIST_FOREACH' tsl' c f' \\<sigma>\n 2. RETURN (foldli tsl c f \\<sigma>) \\<le> ?y", "unfolding LIST_FOREACH'_def"], ["proof (prove)\ngoal (2 subgoals):\n 1. ?y \\<le> tsl' \\<bind> (\\<lambda>xs. nfoldli xs c f' \\<sigma>)\n 2. RETURN (foldli tsl c f \\<sigma>) \\<le> ?y", "using assms"], ["proof (prove)\nusing this:\n  RETURN tsl \\<le> tsl'\n  RETURN (f ?x ?\\<sigma>) \\<le> f' ?x ?\\<sigma>\n\ngoal (2 subgoals):\n 1. ?y \\<le> tsl' \\<bind> (\\<lambda>xs. nfoldli xs c f' \\<sigma>)\n 2. RETURN (foldli tsl c f \\<sigma>) \\<le> ?y", "apply refine_transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. RETURN (foldli tsl c f \\<sigma>)\n    \\<le> RETURN (let x = tsl in foldli x c f \\<sigma>)", "by simp"], ["", "thm refine_transfer"], ["", "lemma LIST_FOREACH'_transfer_nres[refine_transfer]:\n  assumes \"nres_of tsl \\<le> tsl'\"\n  assumes \"\\<And>x \\<sigma>. nres_of (f x \\<sigma>) \\<le> f' x \\<sigma>\"\n  shows \"nres_of (\n    do {\n      xs\\<leftarrow>tsl; \n      foldli xs (case_dres False False c) (\\<lambda>x s. s\\<bind>f x) (dRETURN \\<sigma>)\n    }) \\<le> LIST_FOREACH' tsl' c f' \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nres_of\n     (tsl \\<bind>\n      (\\<lambda>xs.\n          foldli xs (case_dres False False c) (\\<lambda>x s. s \\<bind> f x)\n           (dRETURN \\<sigma>)))\n    \\<le> LIST_FOREACH' tsl' c f' \\<sigma>", "unfolding LIST_FOREACH'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. nres_of\n     (tsl \\<bind>\n      (\\<lambda>xs.\n          foldli xs (case_dres False False c) (\\<lambda>x s. s \\<bind> f x)\n           (dRETURN \\<sigma>)))\n    \\<le> tsl' \\<bind> (\\<lambda>xs. nfoldli xs c f' \\<sigma>)", "using assms"], ["proof (prove)\nusing this:\n  nres_of tsl \\<le> tsl'\n  nres_of (f ?x ?\\<sigma>) \\<le> f' ?x ?\\<sigma>\n\ngoal (1 subgoal):\n 1. nres_of\n     (tsl \\<bind>\n      (\\<lambda>xs.\n          foldli xs (case_dres False False c) (\\<lambda>x s. s \\<bind> f x)\n           (dRETURN \\<sigma>)))\n    \\<le> tsl' \\<bind> (\\<lambda>xs. nfoldli xs c f' \\<sigma>)", "by refine_transfer"], ["", "text \\<open>Simplification rules to summarize iterators\\<close>"], ["", "lemma [refine_transfer_post_simp]: \n  \"do {\n    xs \\<leftarrow> dRETURN tsl;\n    foldli xs c f \\<sigma>\n  } = foldli tsl c f \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dRETURN tsl \\<bind> (\\<lambda>xs. foldli xs c f \\<sigma>) =\n    foldli tsl c f \\<sigma>", "by simp"], ["", "lemma [refine_transfer_post_simp]: \n  \"(let xs = tsl in foldli xs c f \\<sigma>) = foldli tsl c f \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (let xs = tsl in foldli xs c f \\<sigma>) = foldli tsl c f \\<sigma>", "by simp"], ["", "lemma LFO_pre_refine: (* TODO: Generalize! *)\n  assumes \"(li,l)\\<in>\\<langle>A\\<rangle>list_set_rel\"\n  assumes \"(ci,c)\\<in>R \\<rightarrow> bool_rel\"\n  assumes \"(fi,f)\\<in>A\\<rightarrow>R\\<rightarrow>\\<langle>R\\<rangle>nres_rel\"\n  assumes \"(s0i,s0)\\<in>R\"\n  shows \"LIST_FOREACH' (RETURN li) ci fi s0i \\<le> \\<Down>R (FOREACHci I l c f s0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LIST_FOREACH' (RETURN li) ci fi s0i\n    \\<le> \\<Down> R (FOREACH\\<^sub>C\\<^bsup>I\\<^esup> l c f s0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. LIST_FOREACH' (RETURN li) ci fi s0i\n    \\<le> \\<Down> R (FOREACH\\<^sub>C\\<^bsup>I\\<^esup> l c f s0)", "from assms(1)"], ["proof (chain)\npicking this:\n  (li, l) \\<in> \\<langle>A\\<rangle>list_set_rel", "have [simp]: \"finite l\""], ["proof (prove)\nusing this:\n  (li, l) \\<in> \\<langle>A\\<rangle>list_set_rel\n\ngoal (1 subgoal):\n 1. finite l", "by (auto simp: list_set_rel_def br_def)"], ["proof (state)\nthis:\n  finite l\n\ngoal (1 subgoal):\n 1. LIST_FOREACH' (RETURN li) ci fi s0i\n    \\<le> \\<Down> R (FOREACH\\<^sub>C\\<^bsup>I\\<^esup> l c f s0)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. LIST_FOREACH' (RETURN li) ci fi s0i\n    \\<le> \\<Down> R (FOREACH\\<^sub>C\\<^bsup>I\\<^esup> l c f s0)", "unfolding FOREACHc_def FOREACHci_def FOREACHoci_by_LIST_FOREACH"], ["proof (prove)\ngoal (1 subgoal):\n 1. LIST_FOREACH' (RETURN li) ci fi s0i\n    \\<le> \\<Down> R\n           (ASSERT (finite l) \\<bind>\n            (\\<lambda>_.\n                LIST_FOREACH I (it_to_sorted_list (\\<lambda>_ _. True) l) c\n                 f s0))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. LIST_FOREACH' (RETURN li) ci fi s0i\n    \\<le> \\<Down> R\n           (LIST_FOREACH I (it_to_sorted_list (\\<lambda>_ _. True) l) c f\n             s0)", "apply (rule LIST_FOREACH_autoref[param_fo, THEN nres_relD])"], ["proof (prove)\ngoal (4 subgoals):\n 1. (RETURN li, it_to_sorted_list (\\<lambda>_ _. True) l)\n    \\<in> \\<langle>\\<langle>?Rv6\\<rangle>list_rel\\<rangle>nres_rel\n 2. (ci, c) \\<in> R \\<rightarrow> bool_rel\n 3. (fi, f)\n    \\<in> ?Rv6 \\<rightarrow> R \\<rightarrow> \\<langle>R\\<rangle>nres_rel\n 4. (s0i, s0) \\<in> R", "using assms"], ["proof (prove)\nusing this:\n  (li, l) \\<in> \\<langle>A\\<rangle>list_set_rel\n  (ci, c) \\<in> R \\<rightarrow> bool_rel\n  (fi, f) \\<in> A \\<rightarrow> R \\<rightarrow> \\<langle>R\\<rangle>nres_rel\n  (s0i, s0) \\<in> R\n\ngoal (4 subgoals):\n 1. (RETURN li, it_to_sorted_list (\\<lambda>_ _. True) l)\n    \\<in> \\<langle>\\<langle>?Rv6\\<rangle>list_rel\\<rangle>nres_rel\n 2. (ci, c) \\<in> R \\<rightarrow> bool_rel\n 3. (fi, f)\n    \\<in> ?Rv6 \\<rightarrow> R \\<rightarrow> \\<langle>R\\<rangle>nres_rel\n 4. (s0i, s0) \\<in> R", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(li, l) \\<in> \\<langle>A\\<rangle>list_set_rel;\n     (ci, c) \\<in> R \\<rightarrow> bool_rel;\n     (fi, f)\n     \\<in> A \\<rightarrow> R \\<rightarrow> \\<langle>R\\<rangle>nres_rel;\n     (s0i, s0) \\<in> R\\<rbrakk>\n    \\<Longrightarrow> (RETURN li, it_to_sorted_list (\\<lambda>_ _. True) l)\n                      \\<in> \\<langle>\\<langle>A\\<rangle>list_rel\\<rangle>nres_rel", "apply (auto simp: it_to_sorted_list_def nres_rel_def pw_le_iff refine_pw_simps\n      list_set_rel_def br_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  LIST_FOREACH' (RETURN li) ci fi s0i\n  \\<le> \\<Down> R (FOREACH\\<^sub>C\\<^bsup>I\\<^esup> l c f s0)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma LFOci_refine: (* TODO: Generalize! *)\n  assumes \"(li,l)\\<in>\\<langle>A\\<rangle>list_set_rel\"\n  assumes \"\\<And>s si. (si,s)\\<in>R \\<Longrightarrow> ci si \\<longleftrightarrow> c s\"\n  assumes \"\\<And>x xi s si. \\<lbrakk>(xi,x)\\<in>A; (si,s)\\<in>R\\<rbrakk> \\<Longrightarrow> fi xi si \\<le> \\<Down>R (f x s)\"\n  assumes \"(s0i,s0)\\<in>R\"\n  shows \"nfoldli li ci fi s0i \\<le> \\<Down>R (FOREACHci I l c f s0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nfoldli li ci fi s0i\n    \\<le> \\<Down> R (FOREACH\\<^sub>C\\<^bsup>I\\<^esup> l c f s0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. nfoldli li ci fi s0i\n    \\<le> \\<Down> R (FOREACH\\<^sub>C\\<^bsup>I\\<^esup> l c f s0)", "from assms LFO_pre_refine[of li l A ci c R fi f s0i s0]"], ["proof (chain)\npicking this:\n  (li, l) \\<in> \\<langle>A\\<rangle>list_set_rel\n  (?si, ?s) \\<in> R \\<Longrightarrow> ci ?si = c ?s\n  \\<lbrakk>(?xi, ?x) \\<in> A; (?si, ?s) \\<in> R\\<rbrakk>\n  \\<Longrightarrow> fi ?xi ?si \\<le> \\<Down> R (f ?x ?s)\n  (s0i, s0) \\<in> R\n  \\<lbrakk>(li, l) \\<in> \\<langle>A\\<rangle>list_set_rel;\n   (ci, c) \\<in> R \\<rightarrow> bool_rel;\n   (fi, f)\n   \\<in> A \\<rightarrow> R \\<rightarrow> \\<langle>R\\<rangle>nres_rel;\n   (s0i, s0) \\<in> R\\<rbrakk>\n  \\<Longrightarrow> LIST_FOREACH' (RETURN li) ci fi s0i\n                    \\<le> \\<Down> R\n                           (FOREACH\\<^sub>C\\<^bsup>?I\\<^esup> l c f s0)", "show ?thesis"], ["proof (prove)\nusing this:\n  (li, l) \\<in> \\<langle>A\\<rangle>list_set_rel\n  (?si, ?s) \\<in> R \\<Longrightarrow> ci ?si = c ?s\n  \\<lbrakk>(?xi, ?x) \\<in> A; (?si, ?s) \\<in> R\\<rbrakk>\n  \\<Longrightarrow> fi ?xi ?si \\<le> \\<Down> R (f ?x ?s)\n  (s0i, s0) \\<in> R\n  \\<lbrakk>(li, l) \\<in> \\<langle>A\\<rangle>list_set_rel;\n   (ci, c) \\<in> R \\<rightarrow> bool_rel;\n   (fi, f)\n   \\<in> A \\<rightarrow> R \\<rightarrow> \\<langle>R\\<rangle>nres_rel;\n   (s0i, s0) \\<in> R\\<rbrakk>\n  \\<Longrightarrow> LIST_FOREACH' (RETURN li) ci fi s0i\n                    \\<le> \\<Down> R\n                           (FOREACH\\<^sub>C\\<^bsup>?I\\<^esup> l c f s0)\n\ngoal (1 subgoal):\n 1. nfoldli li ci fi s0i\n    \\<le> \\<Down> R (FOREACH\\<^sub>C\\<^bsup>I\\<^esup> l c f s0)", "unfolding fun_rel_def nres_rel_def LIST_FOREACH'_def"], ["proof (prove)\nusing this:\n  (li, l) \\<in> \\<langle>A\\<rangle>list_set_rel\n  (?si, ?s) \\<in> R \\<Longrightarrow> ci ?si = c ?s\n  \\<lbrakk>(?xi, ?x) \\<in> A; (?si, ?s) \\<in> R\\<rbrakk>\n  \\<Longrightarrow> fi ?xi ?si \\<le> \\<Down> R (f ?x ?s)\n  (s0i, s0) \\<in> R\n  \\<lbrakk>(li, l) \\<in> \\<langle>A\\<rangle>list_set_rel;\n   (ci, c)\n   \\<in> {(f, f'). \\<forall>(a, a')\\<in>R. (f a, f' a') \\<in> bool_rel};\n   (fi, f)\n   \\<in> {(f, f').\n          \\<forall>(a, a')\\<in>A.\n             (f a, f' a')\n             \\<in> {(f, f').\n                    \\<forall>(a, a')\\<in>R.\n                       (f a, f' a') \\<in> {(c, a). c \\<le> \\<Down> R a}}};\n   (s0i, s0) \\<in> R\\<rbrakk>\n  \\<Longrightarrow> RETURN li \\<bind> (\\<lambda>xs. nfoldli xs ci fi s0i)\n                    \\<le> \\<Down> R\n                           (FOREACH\\<^sub>C\\<^bsup>?I\\<^esup> l c f s0)\n\ngoal (1 subgoal):\n 1. nfoldli li ci fi s0i\n    \\<le> \\<Down> R (FOREACH\\<^sub>C\\<^bsup>I\\<^esup> l c f s0)", "apply (simp add: pw_le_iff refine_pw_simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(li, l) \\<in> \\<langle>A\\<rangle>list_set_rel;\n     \\<And>si s. (si, s) \\<in> R \\<Longrightarrow> ci si = c s;\n     \\<And>xi x si s.\n        \\<lbrakk>(xi, x) \\<in> A; (si, s) \\<in> R\\<rbrakk>\n        \\<Longrightarrow> nofail (f x s) \\<longrightarrow>\n                          nofail (fi xi si) \\<and>\n                          (\\<forall>xa.\n                              inres (fi xi si) xa \\<longrightarrow>\n                              (\\<exists>s'.\n                                  (xa, s') \\<in> R \\<and>\n                                  inres (f x s) s'));\n     (s0i, s0) \\<in> R;\n     \\<And>I.\n        \\<lbrakk>\\<forall>x\\<in>R.\n                    case x of (a, a') \\<Rightarrow> ci a = c a';\n         \\<forall>x\\<in>A.\n            case x of\n            (a, a') \\<Rightarrow>\n              \\<forall>x\\<in>R.\n                 case x of\n                 (aa, a'a) \\<Rightarrow>\n                   nofail (f a' a'a) \\<longrightarrow>\n                   nofail (fi a aa) \\<and>\n                   (\\<forall>x.\n                       inres (fi a aa) x \\<longrightarrow>\n                       (\\<exists>s'.\n                           (x, s') \\<in> R \\<and>\n                           inres (f a' a'a) s'))\\<rbrakk>\n        \\<Longrightarrow> nofail\n                           (FOREACH\\<^sub>C\\<^bsup>I\\<^esup> l c f\n                             s0) \\<longrightarrow>\n                          nofail (nfoldli li ci fi s0i) \\<and>\n                          (\\<forall>x.\n                              inres (nfoldli li ci fi s0i)\n                               x \\<longrightarrow>\n                              (\\<exists>s'.\n                                  (x, s') \\<in> R \\<and>\n                                  inres\n                                   (FOREACH\\<^sub>C\\<^bsup>I\\<^esup> l c f\n                                     s0)\n                                   s'))\\<rbrakk>\n    \\<Longrightarrow> nofail\n                       (FOREACH\\<^sub>C\\<^bsup>I\\<^esup> l c f\n                         s0) \\<longrightarrow>\n                      nofail (nfoldli li ci fi s0i) \\<and>\n                      (\\<forall>x.\n                          inres (nfoldli li ci fi s0i) x \\<longrightarrow>\n                          (\\<exists>s'.\n                              (x, s') \\<in> R \\<and>\n                              inres\n                               (FOREACH\\<^sub>C\\<^bsup>I\\<^esup> l c f s0)\n                               s'))", "apply blast+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  nfoldli li ci fi s0i\n  \\<le> \\<Down> R (FOREACH\\<^sub>C\\<^bsup>I\\<^esup> l c f s0)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma LFOc_refine: (* TODO: Generalize! *)\n  assumes \"(li,l)\\<in>\\<langle>A\\<rangle>list_set_rel\"\n  assumes \"\\<And>s si. (si,s)\\<in>R \\<Longrightarrow> ci si \\<longleftrightarrow> c s\"\n  assumes \"\\<And>x xi s si. \\<lbrakk>(xi,x)\\<in>A; (si,s)\\<in>R\\<rbrakk> \\<Longrightarrow> fi xi si \\<le> \\<Down>R (f x s)\"\n  assumes \"(s0i,s0)\\<in>R\"\n  shows \"nfoldli li ci fi s0i \\<le> \\<Down>R (FOREACHc l c f s0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nfoldli li ci fi s0i \\<le> \\<Down> R (FOREACH\\<^sub>C l c f s0)", "unfolding FOREACHc_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. nfoldli li ci fi s0i\n    \\<le> \\<Down> R\n           (FOREACH\\<^sub>C\\<^bsup>\\<lambda>_ _. True\\<^esup> l c f s0)", "by (rule LFOci_refine[OF assms])"], ["", "lemma LFO_refine: (* TODO: Generalize! *)\n  assumes \"(li,l)\\<in>\\<langle>A\\<rangle>list_set_rel\"\n  assumes \"\\<And>x xi s si. \\<lbrakk>(xi,x)\\<in>A; (si,s)\\<in>R\\<rbrakk> \\<Longrightarrow> fi xi si \\<le> \\<Down>R (f x s)\"\n  assumes \"(s0i,s0)\\<in>R\"\n  shows \"nfoldli li (\\<lambda>_. True) fi s0i \\<le> \\<Down>R (FOREACH l f s0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nfoldli li (\\<lambda>_. True) fi s0i \\<le> \\<Down> R (FOREACH l f s0)", "unfolding FOREACH_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. nfoldli li (\\<lambda>_. True) fi s0i\n    \\<le> \\<Down> R (FOREACH\\<^sub>C l (\\<lambda>_. True) f s0)", "apply (rule LFOc_refine)"], ["proof (prove)\ngoal (4 subgoals):\n 1. (li, l) \\<in> \\<langle>?A\\<rangle>list_set_rel\n 2. \\<And>s si. (si, s) \\<in> R \\<Longrightarrow> True = True\n 3. \\<And>x xi s si.\n       \\<lbrakk>(xi, x) \\<in> ?A; (si, s) \\<in> R\\<rbrakk>\n       \\<Longrightarrow> fi xi si \\<le> \\<Down> R (f x s)\n 4. (s0i, s0) \\<in> R", "apply (rule assms | simp)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma LFOi_refine: (* TODO: Generalize! *)\n  assumes \"(li,l)\\<in>\\<langle>A\\<rangle>list_set_rel\"\n  assumes \"\\<And>x xi s si. \\<lbrakk>(xi,x)\\<in>A; (si,s)\\<in>R\\<rbrakk> \\<Longrightarrow> fi xi si \\<le> \\<Down>R (f x s)\"\n  assumes \"(s0i,s0)\\<in>R\"\n  shows \"nfoldli li (\\<lambda>_. True) fi s0i \\<le> \\<Down>R (FOREACHi I l f s0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nfoldli li (\\<lambda>_. True) fi s0i\n    \\<le> \\<Down> R (FOREACH\\<^bsup>I\\<^esup> l f s0)", "unfolding FOREACHi_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. nfoldli li (\\<lambda>_. True) fi s0i\n    \\<le> \\<Down> R\n           (FOREACH\\<^sub>C\\<^bsup>I\\<^esup> l (\\<lambda>_. True) f s0)", "apply (rule LFOci_refine)"], ["proof (prove)\ngoal (4 subgoals):\n 1. (li, l) \\<in> \\<langle>?A\\<rangle>list_set_rel\n 2. \\<And>s si. (si, s) \\<in> R \\<Longrightarrow> True = True\n 3. \\<And>x xi s si.\n       \\<lbrakk>(xi, x) \\<in> ?A; (si, s) \\<in> R\\<rbrakk>\n       \\<Longrightarrow> fi xi si \\<le> \\<Down> R (f x s)\n 4. (s0i, s0) \\<in> R", "apply (rule assms | simp)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma LIST_FOREACH'_refine: \"LIST_FOREACH' tsl' c' f' \\<sigma>' \\<le> LIST_FOREACH \\<Phi> tsl' c' f' \\<sigma>'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LIST_FOREACH' tsl' c' f' \\<sigma>'\n    \\<le> LIST_FOREACH \\<Phi> tsl' c' f' \\<sigma>'", "apply (rule refine_IdD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. LIST_FOREACH' tsl' c' f' \\<sigma>'\n    \\<le> \\<Down> Id (LIST_FOREACH \\<Phi> tsl' c' f' \\<sigma>')", "unfolding LIST_FOREACH_def LIST_FOREACH'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. tsl' \\<bind> (\\<lambda>xs. nfoldli xs c' f' \\<sigma>')\n    \\<le> \\<Down> Id\n           (tsl' \\<bind>\n            (\\<lambda>xs.\n                WHILE\\<^sub>T\\<^bsup>\\<lambda>(it, \\<sigma>).\n  \\<exists>xs'. xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>\\<^esup>\n                 (FOREACH_cond c') (FOREACH_body f') (xs, \\<sigma>') \\<bind>\n                (\\<lambda>(uu_, \\<sigma>). RETURN \\<sigma>)))", "apply refine_rcg"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs xsa.\n       (xs, xsa) \\<in> Id \\<Longrightarrow>\n       nfoldli xs c' f' \\<sigma>'\n       \\<le> \\<Down> Id\n              (WHILE\\<^sub>T\\<^bsup>\\<lambda>(it, \\<sigma>).\n \\<exists>xs'. xsa = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>\\<^esup>\n                (FOREACH_cond c') (FOREACH_body f') (xsa, \\<sigma>') \\<bind>\n               (\\<lambda>(uu_, \\<sigma>). RETURN \\<sigma>))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       nfoldli xs c' f' \\<sigma>'\n       \\<le> WHILE\\<^sub>T\\<^bsup>\\<lambda>(it, \\<sigma>).\n                                     (\\<exists>xs'. xs = xs' @ it) \\<and>\n                                     \\<Phi> (set it) \\<sigma>\\<^esup>\n              (FOREACH_cond c') (FOREACH_body f') (xs, \\<sigma>') \\<bind>\n             (\\<lambda>(uu_, y). RETURN y)", "apply (rule nfoldli_while)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma LIST_FOREACH'_eq: \"LIST_FOREACH (\\<lambda>_ _. True) tsl' c' f' \\<sigma>' = (LIST_FOREACH' tsl' c' f' \\<sigma>')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LIST_FOREACH (\\<lambda>_ _. True) tsl' c' f' \\<sigma>' =\n    LIST_FOREACH' tsl' c' f' \\<sigma>'", "apply (rule antisym)"], ["proof (prove)\ngoal (2 subgoals):\n 1. LIST_FOREACH (\\<lambda>_ _. True) tsl' c' f' \\<sigma>'\n    \\<le> LIST_FOREACH' tsl' c' f' \\<sigma>'\n 2. LIST_FOREACH' tsl' c' f' \\<sigma>'\n    \\<le> LIST_FOREACH (\\<lambda>_ _. True) tsl' c' f' \\<sigma>'", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. LIST_FOREACH (\\<lambda>_ _. True) tsl' c' f' \\<sigma>'\n    \\<le> LIST_FOREACH' tsl' c' f' \\<sigma>'", "apply (rule refine_IdD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. LIST_FOREACH (\\<lambda>_ _. True) tsl' c' f' \\<sigma>'\n    \\<le> \\<Down> Id (LIST_FOREACH' tsl' c' f' \\<sigma>')", "unfolding LIST_FOREACH_def LIST_FOREACH'_def while_eq_nfoldli[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. tsl' \\<bind>\n    (\\<lambda>xs.\n        WHILE\\<^sub>T\\<^bsup>\\<lambda>(it, \\<sigma>).\n                                \\<exists>xs'.\n                                   xs = xs' @ it \\<and> True\\<^esup>\n         (FOREACH_cond c') (FOREACH_body f') (xs, \\<sigma>') \\<bind>\n        (\\<lambda>(uu_, \\<sigma>). RETURN \\<sigma>))\n    \\<le> \\<Down> Id\n           (tsl' \\<bind>\n            (\\<lambda>xs.\n                WHILE\\<^sub>T (FOREACH_cond c') (FOREACH_body f')\n                 (xs, \\<sigma>') \\<bind>\n                (\\<lambda>(uu_, y). RETURN y)))", "apply (refine_rcg WHILEIT_refine_new_invar)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xs xsa.\n       (xs, xsa) \\<in> Id \\<Longrightarrow>\n       WHILE\\<^sub>T\\<^bsup>\\<lambda>(it, \\<sigma>).\n                               \\<exists>xs'.\n                                  xs = xs' @ it \\<and> True\\<^esup>\n        (FOREACH_cond c') (FOREACH_body f') (xs, \\<sigma>')\n       \\<le> \\<Down> (?R'4 xs xsa)\n              (WHILE\\<^sub>T (FOREACH_cond c') (FOREACH_body f')\n                (xsa, \\<sigma>'))\n 2. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>(xs, xsa) \\<in> Id; (x, x') \\<in> ?R'4 xs xsa;\n        x' = (x1, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> (x2a, x2) \\<in> Id", "unfolding WHILET_def"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xs xsa.\n       (xs, xsa) \\<in> Id \\<Longrightarrow>\n       WHILE\\<^sub>T\\<^bsup>\\<lambda>(it, \\<sigma>).\n                               \\<exists>xs'.\n                                  xs = xs' @ it \\<and> True\\<^esup>\n        (FOREACH_cond c') (FOREACH_body f') (xs, \\<sigma>')\n       \\<le> \\<Down> (?R'4 xs xsa)\n              (WHILE\\<^sub>T\\<^bsup>\\<lambda>_. True\\<^esup>\n                (FOREACH_cond c') (FOREACH_body f') (xsa, \\<sigma>'))\n 2. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>(xs, xsa) \\<in> Id; (x, x') \\<in> ?R'4 xs xsa;\n        x' = (x1, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> (x2a, x2) \\<in> Id", "apply (rule WHILEIT_refine_new_invar)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>xs xsa.\n       \\<lbrakk>(xs, xsa) \\<in> Id; True\\<rbrakk>\n       \\<Longrightarrow> ((xs, \\<sigma>'), xsa, \\<sigma>') \\<in> ?R'4 xs xsa\n 2. \\<And>xs xsa.\n       \\<lbrakk>(xs, xsa) \\<in> Id; True;\n        ((xs, \\<sigma>'), xsa, \\<sigma>') \\<in> ?R'4 xs xsa\\<rbrakk>\n       \\<Longrightarrow> case (xs, \\<sigma>') of\n                         (it, \\<sigma>) \\<Rightarrow>\n                           \\<exists>xs'. xs = xs' @ it \\<and> True\n 3. \\<And>xs xsa x x'.\n       \\<lbrakk>(xs, xsa) \\<in> Id; (x, x') \\<in> ?R'4 xs xsa;\n        case x of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xs = xs' @ it \\<and> True;\n        True\\<rbrakk>\n       \\<Longrightarrow> FOREACH_cond c' x = FOREACH_cond c' x'\n 4. \\<And>xs xsa x x'.\n       \\<lbrakk>(xs, xsa) \\<in> Id; (x, x') \\<in> ?R'4 xs xsa;\n        FOREACH_cond c' x; FOREACH_cond c' x';\n        case x of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xs = xs' @ it \\<and> True;\n        True\\<rbrakk>\n       \\<Longrightarrow> FOREACH_body f' x\n                         \\<le> \\<Down> (?R'4 xs xsa) (FOREACH_body f' x')\n 5. \\<And>xs xsa x x'.\n       \\<lbrakk>(xs, xsa) \\<in> Id; nofail (FOREACH_body f' x);\n        (x, x') \\<in> ?R'4 xs xsa; FOREACH_cond c' x; FOREACH_cond c' x';\n        case x of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xs = xs' @ it \\<and> True;\n        True\\<rbrakk>\n       \\<Longrightarrow> FOREACH_body f' x\n                         \\<le> SPEC\n                                (\\<lambda>(it, \\<sigma>).\n                                    \\<exists>xs'. xs = xs' @ it \\<and> True)\n 6. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>(xs, xsa) \\<in> Id; (x, x') \\<in> ?R'4 xs xsa;\n        x' = (x1, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> (x2a, x2) \\<in> Id", "apply refine_dref_type"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>xs xsa.\n       \\<lbrakk>(xs, xsa) \\<in> Id; True\\<rbrakk>\n       \\<Longrightarrow> ((xs, \\<sigma>'), xsa, \\<sigma>')\n                         \\<in> \\<langle>Id\\<rangle>list_rel \\<times>\\<^sub>r\n                               Id\n 2. \\<And>xs xsa.\n       \\<lbrakk>(xs, xsa) \\<in> Id; True;\n        ((xs, \\<sigma>'), xsa, \\<sigma>')\n        \\<in> \\<langle>Id\\<rangle>list_rel \\<times>\\<^sub>r Id\\<rbrakk>\n       \\<Longrightarrow> case (xs, \\<sigma>') of\n                         (it, \\<sigma>) \\<Rightarrow>\n                           \\<exists>xs'. xs = xs' @ it \\<and> True\n 3. \\<And>xs xsa x x'.\n       \\<lbrakk>(xs, xsa) \\<in> Id;\n        (x, x') \\<in> \\<langle>Id\\<rangle>list_rel \\<times>\\<^sub>r Id;\n        case x of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xs = xs' @ it \\<and> True;\n        True\\<rbrakk>\n       \\<Longrightarrow> FOREACH_cond c' x = FOREACH_cond c' x'\n 4. \\<And>xs xsa x x'.\n       \\<lbrakk>(xs, xsa) \\<in> Id;\n        (x, x') \\<in> \\<langle>Id\\<rangle>list_rel \\<times>\\<^sub>r Id;\n        FOREACH_cond c' x; FOREACH_cond c' x';\n        case x of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xs = xs' @ it \\<and> True;\n        True\\<rbrakk>\n       \\<Longrightarrow> FOREACH_body f' x\n                         \\<le> \\<Down>\n                                (\\<langle>Id\\<rangle>list_rel \\<times>\\<^sub>r\n                                 Id)\n                                (FOREACH_body f' x')\n 5. \\<And>xs xsa x x'.\n       \\<lbrakk>(xs, xsa) \\<in> Id; nofail (FOREACH_body f' x);\n        (x, x') \\<in> \\<langle>Id\\<rangle>list_rel \\<times>\\<^sub>r Id;\n        FOREACH_cond c' x; FOREACH_cond c' x';\n        case x of\n        (it, \\<sigma>) \\<Rightarrow>\n          \\<exists>xs'. xs = xs' @ it \\<and> True;\n        True\\<rbrakk>\n       \\<Longrightarrow> FOREACH_body f' x\n                         \\<le> SPEC\n                                (\\<lambda>(it, \\<sigma>).\n                                    \\<exists>xs'. xs = xs' @ it \\<and> True)\n 6. \\<And>xs xsa x x' x1 x2 x1a x2a.\n       \\<lbrakk>(xs, xsa) \\<in> Id;\n        (x, x') \\<in> \\<langle>Id\\<rangle>list_rel \\<times>\\<^sub>r Id;\n        x' = (x1, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> (x2a, x2) \\<in> Id", "apply clarsimp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa ba xs'.\n       \\<lbrakk>nofail (FOREACH_body f' (aa, ba));\n        FOREACH_cond c' (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> FOREACH_body f' (aa, ba)\n                         \\<le> SPEC\n                                (\\<lambda>(it, \\<sigma>).\n                                    \\<exists>xs'a. xs' @ aa = xs'a @ it)", "unfolding FOREACH_body_def FOREACH_cond_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa ba xs'.\n       \\<lbrakk>nofail\n                 (case (aa, ba) of\n                  (xs, \\<sigma>) \\<Rightarrow>\n                    let x = hd xs\n                    in f' x \\<sigma> \\<bind>\n                       (\\<lambda>\\<sigma>'. RETURN (tl xs, \\<sigma>')));\n        case (aa, ba) of\n        (xs, \\<sigma>) \\<Rightarrow>\n          xs \\<noteq> [] \\<and> c' \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> (case (aa, ba) of\n                          (xs, \\<sigma>) \\<Rightarrow>\n                            let x = hd xs\n                            in f' x \\<sigma> \\<bind>\n                               (\\<lambda>\\<sigma>'.\n                                   RETURN (tl xs, \\<sigma>')))\n                         \\<le> SPEC\n                                (\\<lambda>(it, \\<sigma>).\n                                    \\<exists>xs'a. xs' @ aa = xs'a @ it)", "apply refine_vcg"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa ba xs' a b.\n       \\<lbrakk>nofail\n                 (case (aa, ba) of\n                  (xs, \\<sigma>) \\<Rightarrow>\n                    let x = hd xs\n                    in f' x \\<sigma> \\<bind>\n                       (\\<lambda>\\<sigma>'. RETURN (tl xs, \\<sigma>')));\n        case (aa, ba) of\n        (xs, \\<sigma>) \\<Rightarrow> xs \\<noteq> [] \\<and> c' \\<sigma>;\n        (aa, ba) = (a, b)\\<rbrakk>\n       \\<Longrightarrow> f' (hd a) b\n                         \\<le> SPEC\n                                (\\<lambda>\\<sigma>'.\n                                    RETURN (tl a, \\<sigma>')\n                                    \\<le> SPEC\n     (\\<lambda>(it, \\<sigma>). \\<exists>xs'a. xs' @ aa = xs'a @ it))", "apply (auto simp: refine_pw_simps pw_le_iff neq_Nil_conv)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (1 subgoal):\n 1. LIST_FOREACH' tsl' c' f' \\<sigma>'\n    \\<le> LIST_FOREACH (\\<lambda>_ _. True) tsl' c' f' \\<sigma>'", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. LIST_FOREACH' tsl' c' f' \\<sigma>'\n    \\<le> LIST_FOREACH (\\<lambda>_ _. True) tsl' c' f' \\<sigma>'", "by (rule LIST_FOREACH'_refine)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection \\<open>FOREACH with duplicates\\<close>"], ["", "definition \"FOREACHcd S c f \\<sigma> \\<equiv> do {\n  ASSERT (finite S);\n  l \\<leftarrow> SPEC (\\<lambda>l. set l = S);\n  nfoldli l c f \\<sigma>\n}\""], ["", "lemma FOREACHcd_rule:\n  assumes \"finite S\\<^sub>0\"\n  assumes I0: \"I {} S\\<^sub>0 \\<sigma>\\<^sub>0\"\n  assumes STEP: \"\\<And>S1 S2 x \\<sigma>. \\<lbrakk> S\\<^sub>0 = insert x (S1\\<union>S2); I S1 (insert x S2) \\<sigma>; c \\<sigma> \\<rbrakk> \\<Longrightarrow> f x \\<sigma> \\<le> SPEC (I (insert x S1) S2)\"\n  assumes INTR: \"\\<And>S1 S2 \\<sigma>. \\<lbrakk> S\\<^sub>0 = S1\\<union>S2; I S1 S2 \\<sigma>; \\<not>c \\<sigma> \\<rbrakk> \\<Longrightarrow> \\<Phi> \\<sigma>\"\n  assumes COMPL: \"\\<And>\\<sigma>. \\<lbrakk> I S\\<^sub>0 {} \\<sigma>; c \\<sigma> \\<rbrakk> \\<Longrightarrow> \\<Phi> \\<sigma>\"\n  shows \"FOREACHcd S\\<^sub>0 c f \\<sigma>\\<^sub>0 \\<le> SPEC \\<Phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. FOREACHcd S\\<^sub>0 c f \\<sigma>\\<^sub>0 \\<le> SPEC \\<Phi>", "unfolding FOREACHcd_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ASSERT (finite S\\<^sub>0) \\<bind>\n    (\\<lambda>_.\n        SPEC (\\<lambda>l. set l = S\\<^sub>0) \\<bind>\n        (\\<lambda>l. nfoldli l c f \\<sigma>\\<^sub>0))\n    \\<le> SPEC \\<Phi>", "apply refine_vcg"], ["proof (prove)\ngoal (2 subgoals):\n 1. finite S\\<^sub>0\n 2. \\<And>x.\n       \\<lbrakk>finite S\\<^sub>0; set x = S\\<^sub>0\\<rbrakk>\n       \\<Longrightarrow> nfoldli x c f \\<sigma>\\<^sub>0 \\<le> SPEC \\<Phi>", "apply fact"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>finite S\\<^sub>0; set x = S\\<^sub>0\\<rbrakk>\n       \\<Longrightarrow> nfoldli x c f \\<sigma>\\<^sub>0 \\<le> SPEC \\<Phi>", "apply (rule nfoldli_rule[where I = \"\\<lambda>l1 l2 \\<sigma>. I (set l1) (set l2) \\<sigma>\"])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>finite S\\<^sub>0; set x = S\\<^sub>0\\<rbrakk>\n       \\<Longrightarrow> I (set []) (set x) \\<sigma>\\<^sub>0\n 2. \\<And>x xa l1 l2 \\<sigma>.\n       \\<lbrakk>finite S\\<^sub>0; set x = S\\<^sub>0; x = l1 @ xa # l2;\n        I (set l1) (set (xa # l2)) \\<sigma>; c \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> f xa \\<sigma>\n                         \\<le> SPEC (I (set (l1 @ [xa])) (set l2))\n 3. \\<And>x l1 l2 \\<sigma>.\n       \\<lbrakk>finite S\\<^sub>0; set x = S\\<^sub>0; x = l1 @ l2;\n        I (set l1) (set l2) \\<sigma>; \\<not> c \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<sigma>\n 4. \\<And>x \\<sigma>.\n       \\<lbrakk>finite S\\<^sub>0; set x = S\\<^sub>0;\n        I (set x) (set []) \\<sigma>; c \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<sigma>", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite S\\<^sub>0; set x_ = S\\<^sub>0\\<rbrakk>\n    \\<Longrightarrow> I (set []) (set x_) \\<sigma>\\<^sub>0", "using I0"], ["proof (prove)\nusing this:\n  I {} S\\<^sub>0 \\<sigma>\\<^sub>0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>finite S\\<^sub>0; set x_ = S\\<^sub>0\\<rbrakk>\n    \\<Longrightarrow> I (set []) (set x_) \\<sigma>\\<^sub>0", "by auto"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x xa l1 l2 \\<sigma>.\n       \\<lbrakk>finite S\\<^sub>0; set x = S\\<^sub>0; x = l1 @ xa # l2;\n        I (set l1) (set (xa # l2)) \\<sigma>; c \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> f xa \\<sigma>\n                         \\<le> SPEC (I (set (l1 @ [xa])) (set l2))\n 2. \\<And>x l1 l2 \\<sigma>.\n       \\<lbrakk>finite S\\<^sub>0; set x = S\\<^sub>0; x = l1 @ l2;\n        I (set l1) (set l2) \\<sigma>; \\<not> c \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<sigma>\n 3. \\<And>x \\<sigma>.\n       \\<lbrakk>finite S\\<^sub>0; set x = S\\<^sub>0;\n        I (set x) (set []) \\<sigma>; c \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<sigma>", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite S\\<^sub>0; set x_ = S\\<^sub>0; x_ = l1_ @ xa_ # l2_;\n     I (set l1_) (set (xa_ # l2_)) \\<sigma>_; c \\<sigma>_\\<rbrakk>\n    \\<Longrightarrow> f xa_ \\<sigma>_\n                      \\<le> SPEC (I (set (l1_ @ [xa_])) (set l2_))", "using STEP"], ["proof (prove)\nusing this:\n  \\<lbrakk>S\\<^sub>0 = insert ?x (?S1.0 \\<union> ?S2.0);\n   I ?S1.0 (insert ?x ?S2.0) ?\\<sigma>; c ?\\<sigma>\\<rbrakk>\n  \\<Longrightarrow> f ?x ?\\<sigma> \\<le> SPEC (I (insert ?x ?S1.0) ?S2.0)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>finite S\\<^sub>0; set x_ = S\\<^sub>0; x_ = l1_ @ xa_ # l2_;\n     I (set l1_) (set (xa_ # l2_)) \\<sigma>_; c \\<sigma>_\\<rbrakk>\n    \\<Longrightarrow> f xa_ \\<sigma>_\n                      \\<le> SPEC (I (set (l1_ @ [xa_])) (set l2_))", "by auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x l1 l2 \\<sigma>.\n       \\<lbrakk>finite S\\<^sub>0; set x = S\\<^sub>0; x = l1 @ l2;\n        I (set l1) (set l2) \\<sigma>; \\<not> c \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<sigma>\n 2. \\<And>x \\<sigma>.\n       \\<lbrakk>finite S\\<^sub>0; set x = S\\<^sub>0;\n        I (set x) (set []) \\<sigma>; c \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<sigma>", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite S\\<^sub>0; set x_ = S\\<^sub>0; x_ = l1_ @ l2_;\n     I (set l1_) (set l2_) \\<sigma>_; \\<not> c \\<sigma>_\\<rbrakk>\n    \\<Longrightarrow> \\<Phi> \\<sigma>_", "using INTR"], ["proof (prove)\nusing this:\n  \\<lbrakk>S\\<^sub>0 = ?S1.0 \\<union> ?S2.0; I ?S1.0 ?S2.0 ?\\<sigma>;\n   \\<not> c ?\\<sigma>\\<rbrakk>\n  \\<Longrightarrow> \\<Phi> ?\\<sigma>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>finite S\\<^sub>0; set x_ = S\\<^sub>0; x_ = l1_ @ l2_;\n     I (set l1_) (set l2_) \\<sigma>_; \\<not> c \\<sigma>_\\<rbrakk>\n    \\<Longrightarrow> \\<Phi> \\<sigma>_", "by auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x \\<sigma>.\n       \\<lbrakk>finite S\\<^sub>0; set x = S\\<^sub>0;\n        I (set x) (set []) \\<sigma>; c \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<sigma>", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite S\\<^sub>0; set x_ = S\\<^sub>0;\n     I (set x_) (set []) \\<sigma>_; c \\<sigma>_\\<rbrakk>\n    \\<Longrightarrow> \\<Phi> \\<sigma>_", "using COMPL"], ["proof (prove)\nusing this:\n  \\<lbrakk>I S\\<^sub>0 {} ?\\<sigma>; c ?\\<sigma>\\<rbrakk>\n  \\<Longrightarrow> \\<Phi> ?\\<sigma>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>finite S\\<^sub>0; set x_ = S\\<^sub>0;\n     I (set x_) (set []) \\<sigma>_; c \\<sigma>_\\<rbrakk>\n    \\<Longrightarrow> \\<Phi> \\<sigma>_", "by auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "definition FOREACHcdi \n  :: \"('a set \\<Rightarrow> 'a set \\<Rightarrow> 'b \\<Rightarrow> bool) \n    \\<Rightarrow> 'a set \\<Rightarrow> ('b \\<Rightarrow> bool) \\<Rightarrow> ('a \\<Rightarrow> 'b \\<Rightarrow> 'b nres) \\<Rightarrow> 'b \\<Rightarrow> 'b nres\"\n  where\n  \"FOREACHcdi I \\<equiv> FOREACHcd\""], ["", "lemma FOREACHcdi_rule[refine_vcg]:\n  assumes \"finite S\\<^sub>0\"\n  assumes I0: \"I {} S\\<^sub>0 \\<sigma>\\<^sub>0\"\n  assumes STEP: \"\\<And>S1 S2 x \\<sigma>. \\<lbrakk> S\\<^sub>0 = insert x (S1\\<union>S2); I S1 (insert x S2) \\<sigma>; c \\<sigma> \\<rbrakk> \\<Longrightarrow> f x \\<sigma> \\<le> SPEC (I (insert x S1) S2)\"\n  assumes INTR: \"\\<And>S1 S2 \\<sigma>. \\<lbrakk> S\\<^sub>0 = S1\\<union>S2; I S1 S2 \\<sigma>; \\<not>c \\<sigma> \\<rbrakk> \\<Longrightarrow> \\<Phi> \\<sigma>\"\n  assumes COMPL: \"\\<And>\\<sigma>. \\<lbrakk> I S\\<^sub>0 {} \\<sigma>; c \\<sigma> \\<rbrakk> \\<Longrightarrow> \\<Phi> \\<sigma>\"\n  shows \"FOREACHcdi I S\\<^sub>0 c f \\<sigma>\\<^sub>0 \\<le> SPEC \\<Phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. FOREACHcdi I S\\<^sub>0 c f \\<sigma>\\<^sub>0 \\<le> SPEC \\<Phi>", "unfolding FOREACHcdi_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. FOREACHcd S\\<^sub>0 c f \\<sigma>\\<^sub>0 \\<le> SPEC \\<Phi>", "using assms"], ["proof (prove)\nusing this:\n  finite S\\<^sub>0\n  I {} S\\<^sub>0 \\<sigma>\\<^sub>0\n  \\<lbrakk>S\\<^sub>0 = insert ?x (?S1.0 \\<union> ?S2.0);\n   I ?S1.0 (insert ?x ?S2.0) ?\\<sigma>; c ?\\<sigma>\\<rbrakk>\n  \\<Longrightarrow> f ?x ?\\<sigma> \\<le> SPEC (I (insert ?x ?S1.0) ?S2.0)\n  \\<lbrakk>S\\<^sub>0 = ?S1.0 \\<union> ?S2.0; I ?S1.0 ?S2.0 ?\\<sigma>;\n   \\<not> c ?\\<sigma>\\<rbrakk>\n  \\<Longrightarrow> \\<Phi> ?\\<sigma>\n  \\<lbrakk>I S\\<^sub>0 {} ?\\<sigma>; c ?\\<sigma>\\<rbrakk>\n  \\<Longrightarrow> \\<Phi> ?\\<sigma>\n\ngoal (1 subgoal):\n 1. FOREACHcd S\\<^sub>0 c f \\<sigma>\\<^sub>0 \\<le> SPEC \\<Phi>", "by (rule FOREACHcd_rule)"], ["", "lemma FOREACHcd_refine[refine]:\n  assumes [simp]: \"finite s'\"\n  assumes S: \"(s',s)\\<in>\\<langle>S\\<rangle>set_rel\"\n  assumes SV: \"single_valued S\"\n  assumes R0: \"(\\<sigma>',\\<sigma>)\\<in>R\"\n  assumes C: \"\\<And>\\<sigma>' \\<sigma>. (\\<sigma>',\\<sigma>)\\<in>R \\<Longrightarrow> (c' \\<sigma>', c \\<sigma>)\\<in>bool_rel\"\n  assumes F: \"\\<And>x' x \\<sigma>' \\<sigma>. \\<lbrakk>(x', x) \\<in> S; (\\<sigma>', \\<sigma>) \\<in> R\\<rbrakk>\n     \\<Longrightarrow> f' x' \\<sigma>' \\<le> \\<Down> R (f x \\<sigma>)\"\n  shows \"FOREACHcd s' c' f' \\<sigma>' \\<le> \\<Down>R (FOREACHcdi I s c f \\<sigma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. FOREACHcd s' c' f' \\<sigma>'\n    \\<le> \\<Down> R (FOREACHcdi I s c f \\<sigma>)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. FOREACHcd s' c' f' \\<sigma>'\n    \\<le> \\<Down> R (FOREACHcdi I s c f \\<sigma>)", "have [refine_dref_RELATES]: \"RELATES S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RELATES S", "by (simp add: RELATES_def)"], ["proof (state)\nthis:\n  RELATES S\n\ngoal (1 subgoal):\n 1. FOREACHcd s' c' f' \\<sigma>'\n    \\<le> \\<Down> R (FOREACHcdi I s c f \\<sigma>)", "from SV"], ["proof (chain)\npicking this:\n  single_valued S", "obtain \\<alpha> I where [simp]: \"S=br \\<alpha> I\""], ["proof (prove)\nusing this:\n  single_valued S\n\ngoal (1 subgoal):\n 1. (\\<And>\\<alpha> I.\n        S = br \\<alpha> I \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule single_valued_as_brE)"], ["proof (state)\nthis:\n  S = br \\<alpha> I\n\ngoal (1 subgoal):\n 1. FOREACHcd s' c' f' \\<sigma>'\n    \\<le> \\<Down> R (FOREACHcdi I s c f \\<sigma>)", "with S"], ["proof (chain)\npicking this:\n  (s', s) \\<in> \\<langle>S\\<rangle>set_rel\n  S = br \\<alpha> I", "have [simp]: \"s=\\<alpha>`s'\" and [simp]: \"\\<forall>x\\<in>s'. I x\""], ["proof (prove)\nusing this:\n  (s', s) \\<in> \\<langle>S\\<rangle>set_rel\n  S = br \\<alpha> I\n\ngoal (1 subgoal):\n 1. s = \\<alpha> ` s' &&& \\<forall>x\\<in>s'. I x", "by (auto simp: br_set_rel_alt)"], ["proof (state)\nthis:\n  s = \\<alpha> ` s'\n  \\<forall>x\\<in>s'. I x\n\ngoal (1 subgoal):\n 1. FOREACHcd s' c' f' \\<sigma>'\n    \\<le> \\<Down> R (FOREACHcdi I s c f \\<sigma>)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. FOREACHcd s' c' f' \\<sigma>'\n    \\<le> \\<Down> R (FOREACHcdi I s c f \\<sigma>)", "unfolding FOREACHcd_def FOREACHcdi_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ASSERT (finite s') \\<bind>\n    (\\<lambda>_.\n        SPEC (\\<lambda>l. set l = s') \\<bind>\n        (\\<lambda>l. nfoldli l c' f' \\<sigma>'))\n    \\<le> \\<Down> R\n           (ASSERT (finite s) \\<bind>\n            (\\<lambda>_.\n                SPEC (\\<lambda>l. set l = s) \\<bind>\n                (\\<lambda>l. nfoldli l c f \\<sigma>)))", "apply refine_rcg"], ["proof (prove)\ngoal (6 subgoals):\n 1. finite s \\<Longrightarrow> finite s'\n 2. \\<lbrakk>finite s; finite s'\\<rbrakk>\n    \\<Longrightarrow> SPEC (\\<lambda>l. set l = s')\n                      \\<le> \\<Down> ?R'2 (SPEC (\\<lambda>l. set l = s))\n 3. \\<And>l la.\n       \\<lbrakk>finite s; finite s'; (l, la) \\<in> ?R'2;\n        l \\<in> {l. set l = s'}; la \\<in> {l. set l = s}\\<rbrakk>\n       \\<Longrightarrow> (l, la) \\<in> \\<langle>?S3 l la\\<rangle>list_rel\n 4. \\<And>l la.\n       \\<lbrakk>finite s; finite s'; (l, la) \\<in> ?R'2;\n        l \\<in> {l. set l = s'}; la \\<in> {l. set l = s}\\<rbrakk>\n       \\<Longrightarrow> (\\<sigma>', \\<sigma>) \\<in> R\n 5. \\<And>l la a a'.\n       \\<lbrakk>finite s; finite s'; (l, la) \\<in> ?R'2;\n        l \\<in> {l. set l = s'}; la \\<in> {l. set l = s};\n        (a, a') \\<in> R\\<rbrakk>\n       \\<Longrightarrow> (c' a, c a') \\<in> bool_rel\n 6. \\<And>l la xi x si sa.\n       \\<lbrakk>finite s; finite s'; (l, la) \\<in> ?R'2;\n        l \\<in> {l. set l = s'}; la \\<in> {l. set l = s};\n        (xi, x) \\<in> ?S3 l la; (si, sa) \\<in> R; c sa\\<rbrakk>\n       \\<Longrightarrow> f' xi si \\<le> \\<Down> R (f x sa)", "apply refine_dref_type"], ["proof (prove)\ngoal (5 subgoals):\n 1. finite s \\<Longrightarrow> finite s'\n 2. \\<lbrakk>finite s; finite s'\\<rbrakk>\n    \\<Longrightarrow> SPEC (\\<lambda>l. set l = s')\n                      \\<le> \\<Down> (\\<langle>S\\<rangle>list_rel)\n                             (SPEC (\\<lambda>l. set l = s))\n 3. \\<And>l la.\n       \\<lbrakk>finite s; finite s';\n        (l, la) \\<in> \\<langle>S\\<rangle>list_rel; l \\<in> {l. set l = s'};\n        la \\<in> {l. set l = s}\\<rbrakk>\n       \\<Longrightarrow> (\\<sigma>', \\<sigma>) \\<in> R\n 4. \\<And>l la a a'.\n       \\<lbrakk>finite s; finite s';\n        (l, la) \\<in> \\<langle>S\\<rangle>list_rel; l \\<in> {l. set l = s'};\n        la \\<in> {l. set l = s}; (a, a') \\<in> R\\<rbrakk>\n       \\<Longrightarrow> (c' a, c a') \\<in> bool_rel\n 5. \\<And>l la xi x si sa.\n       \\<lbrakk>finite s; finite s';\n        (l, la) \\<in> \\<langle>S\\<rangle>list_rel; l \\<in> {l. set l = s'};\n        la \\<in> {l. set l = s}; (xi, x) \\<in> S; (si, sa) \\<in> R;\n        c sa\\<rbrakk>\n       \\<Longrightarrow> f' xi si \\<le> \\<Down> R (f x sa)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite s \\<Longrightarrow> finite s'", "by simp"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>finite s; finite s'\\<rbrakk>\n    \\<Longrightarrow> SPEC (\\<lambda>l. set l = s')\n                      \\<le> \\<Down> (\\<langle>S\\<rangle>list_rel)\n                             (SPEC (\\<lambda>l. set l = s))\n 2. \\<And>l la.\n       \\<lbrakk>finite s; finite s';\n        (l, la) \\<in> \\<langle>S\\<rangle>list_rel; l \\<in> {l. set l = s'};\n        la \\<in> {l. set l = s}\\<rbrakk>\n       \\<Longrightarrow> (\\<sigma>', \\<sigma>) \\<in> R\n 3. \\<And>l la a a'.\n       \\<lbrakk>finite s; finite s';\n        (l, la) \\<in> \\<langle>S\\<rangle>list_rel; l \\<in> {l. set l = s'};\n        la \\<in> {l. set l = s}; (a, a') \\<in> R\\<rbrakk>\n       \\<Longrightarrow> (c' a, c a') \\<in> bool_rel\n 4. \\<And>l la xi x si sa.\n       \\<lbrakk>finite s; finite s';\n        (l, la) \\<in> \\<langle>S\\<rangle>list_rel; l \\<in> {l. set l = s'};\n        la \\<in> {l. set l = s}; (xi, x) \\<in> S; (si, sa) \\<in> R;\n        c sa\\<rbrakk>\n       \\<Longrightarrow> f' xi si \\<le> \\<Down> R (f x sa)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite s; finite s'\\<rbrakk>\n    \\<Longrightarrow> SPEC (\\<lambda>l. set l = s')\n                      \\<le> \\<Down> (\\<langle>S\\<rangle>list_rel)\n                             (SPEC (\\<lambda>l. set l = s))", "apply (auto simp: pw_le_iff refine_pw_simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       s' = set x \\<Longrightarrow>\n       \\<exists>s'.\n          (x, s') \\<in> \\<langle>br \\<alpha> I\\<rangle>list_rel \\<and>\n          set s' = \\<alpha> ` set x", "using S"], ["proof (prove)\nusing this:\n  (s', s) \\<in> \\<langle>S\\<rangle>set_rel\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       s' = set x \\<Longrightarrow>\n       \\<exists>s'.\n          (x, s') \\<in> \\<langle>br \\<alpha> I\\<rangle>list_rel \\<and>\n          set s' = \\<alpha> ` set x", "apply (rule_tac x=\"map \\<alpha> x\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>s' = set x;\n        (s', s) \\<in> \\<langle>S\\<rangle>set_rel\\<rbrakk>\n       \\<Longrightarrow> (x, map \\<alpha> x)\n                         \\<in> \\<langle>br \\<alpha>\n   I\\<rangle>list_rel \\<and>\n                         set (map \\<alpha> x) = \\<alpha> ` set x", "apply (auto simp: map_in_list_rel_conv)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>l la.\n       \\<lbrakk>finite s; finite s';\n        (l, la) \\<in> \\<langle>S\\<rangle>list_rel; l \\<in> {l. set l = s'};\n        la \\<in> {l. set l = s}\\<rbrakk>\n       \\<Longrightarrow> (\\<sigma>', \\<sigma>) \\<in> R\n 2. \\<And>l la a a'.\n       \\<lbrakk>finite s; finite s';\n        (l, la) \\<in> \\<langle>S\\<rangle>list_rel; l \\<in> {l. set l = s'};\n        la \\<in> {l. set l = s}; (a, a') \\<in> R\\<rbrakk>\n       \\<Longrightarrow> (c' a, c a') \\<in> bool_rel\n 3. \\<And>l la xi x si sa.\n       \\<lbrakk>finite s; finite s';\n        (l, la) \\<in> \\<langle>S\\<rangle>list_rel; l \\<in> {l. set l = s'};\n        la \\<in> {l. set l = s}; (xi, x) \\<in> S; (si, sa) \\<in> R;\n        c sa\\<rbrakk>\n       \\<Longrightarrow> f' xi si \\<le> \\<Down> R (f x sa)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite s; finite s';\n     (l_, la_) \\<in> \\<langle>S\\<rangle>list_rel; l_ \\<in> {l. set l = s'};\n     la_ \\<in> {l. set l = s}\\<rbrakk>\n    \\<Longrightarrow> (\\<sigma>', \\<sigma>) \\<in> R", "using R0"], ["proof (prove)\nusing this:\n  (\\<sigma>', \\<sigma>) \\<in> R\n\ngoal (1 subgoal):\n 1. \\<lbrakk>finite s; finite s';\n     (l_, la_) \\<in> \\<langle>S\\<rangle>list_rel; l_ \\<in> {l. set l = s'};\n     la_ \\<in> {l. set l = s}\\<rbrakk>\n    \\<Longrightarrow> (\\<sigma>', \\<sigma>) \\<in> R", "by auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>l la a a'.\n       \\<lbrakk>finite s; finite s';\n        (l, la) \\<in> \\<langle>S\\<rangle>list_rel; l \\<in> {l. set l = s'};\n        la \\<in> {l. set l = s}; (a, a') \\<in> R\\<rbrakk>\n       \\<Longrightarrow> (c' a, c a') \\<in> bool_rel\n 2. \\<And>l la xi x si sa.\n       \\<lbrakk>finite s; finite s';\n        (l, la) \\<in> \\<langle>S\\<rangle>list_rel; l \\<in> {l. set l = s'};\n        la \\<in> {l. set l = s}; (xi, x) \\<in> S; (si, sa) \\<in> R;\n        c sa\\<rbrakk>\n       \\<Longrightarrow> f' xi si \\<le> \\<Down> R (f x sa)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite s; finite s';\n     (l_, la_) \\<in> \\<langle>S\\<rangle>list_rel; l_ \\<in> {l. set l = s'};\n     la_ \\<in> {l. set l = s}; (a_, a'_) \\<in> R\\<rbrakk>\n    \\<Longrightarrow> (c' a_, c a'_) \\<in> bool_rel", "using C"], ["proof (prove)\nusing this:\n  (?\\<sigma>', ?\\<sigma>) \\<in> R \\<Longrightarrow>\n  (c' ?\\<sigma>', c ?\\<sigma>) \\<in> bool_rel\n\ngoal (1 subgoal):\n 1. \\<lbrakk>finite s; finite s';\n     (l_, la_) \\<in> \\<langle>S\\<rangle>list_rel; l_ \\<in> {l. set l = s'};\n     la_ \\<in> {l. set l = s}; (a_, a'_) \\<in> R\\<rbrakk>\n    \\<Longrightarrow> (c' a_, c a'_) \\<in> bool_rel", "by auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l la xi x si sa.\n       \\<lbrakk>finite s; finite s';\n        (l, la) \\<in> \\<langle>S\\<rangle>list_rel; l \\<in> {l. set l = s'};\n        la \\<in> {l. set l = s}; (xi, x) \\<in> S; (si, sa) \\<in> R;\n        c sa\\<rbrakk>\n       \\<Longrightarrow> f' xi si \\<le> \\<Down> R (f x sa)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite s; finite s';\n     (l_, la_) \\<in> \\<langle>S\\<rangle>list_rel; l_ \\<in> {l. set l = s'};\n     la_ \\<in> {l. set l = s}; (xi_, x_) \\<in> S; (si_, sa_) \\<in> R;\n     c sa_\\<rbrakk>\n    \\<Longrightarrow> f' xi_ si_ \\<le> \\<Down> R (f x_ sa_)", "using F"], ["proof (prove)\nusing this:\n  \\<lbrakk>(?x', ?x) \\<in> S; (?\\<sigma>', ?\\<sigma>) \\<in> R\\<rbrakk>\n  \\<Longrightarrow> f' ?x' ?\\<sigma>' \\<le> \\<Down> R (f ?x ?\\<sigma>)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>finite s; finite s';\n     (l_, la_) \\<in> \\<langle>S\\<rangle>list_rel; l_ \\<in> {l. set l = s'};\n     la_ \\<in> {l. set l = s}; (xi_, x_) \\<in> S; (si_, sa_) \\<in> R;\n     c sa_\\<rbrakk>\n    \\<Longrightarrow> f' xi_ si_ \\<le> \\<Down> R (f x_ sa_)", "by auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  FOREACHcd s' c' f' \\<sigma>' \\<le> \\<Down> R (FOREACHcdi I s c f \\<sigma>)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma FOREACHc_refines_FOREACHcd_aux:\n  shows \"FOREACHc s c f \\<sigma> \\<le> FOREACHcd s c f \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. FOREACH\\<^sub>C s c f \\<sigma> \\<le> FOREACHcd s c f \\<sigma>", "unfolding FOREACHc_def FOREACHci_def FOREACHoci_by_LIST_FOREACH LIST_FOREACH'_eq\n    LIST_FOREACH'_def FOREACHcd_def it_to_sorted_list_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ASSERT (finite s) \\<bind>\n    (\\<lambda>_.\n        SPEC\n         (\\<lambda>l.\n             distinct l \\<and>\n             s = set l \\<and> sorted_wrt (\\<lambda>_ _. True) l) \\<bind>\n        (\\<lambda>xs. nfoldli xs c f \\<sigma>))\n    \\<le> ASSERT (finite s) \\<bind>\n          (\\<lambda>_.\n              SPEC (\\<lambda>l. set l = s) \\<bind>\n              (\\<lambda>l. nfoldli l c f \\<sigma>))", "apply (rule refine_IdD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ASSERT (finite s) \\<bind>\n    (\\<lambda>_.\n        SPEC\n         (\\<lambda>l.\n             distinct l \\<and>\n             s = set l \\<and> sorted_wrt (\\<lambda>_ _. True) l) \\<bind>\n        (\\<lambda>xs. nfoldli xs c f \\<sigma>))\n    \\<le> \\<Down> Id\n           (ASSERT (finite s) \\<bind>\n            (\\<lambda>_.\n                SPEC (\\<lambda>l. set l = s) \\<bind>\n                (\\<lambda>l. nfoldli l c f \\<sigma>)))", "apply (refine_rcg)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>finite s; finite s\\<rbrakk>\n    \\<Longrightarrow> SPEC\n                       (\\<lambda>l.\n                           distinct l \\<and>\n                           s = set l \\<and>\n                           sorted_wrt (\\<lambda>_ _. True) l)\n                      \\<le> SPEC (\\<lambda>l. set l = s)\n 2. \\<And>xs l.\n       \\<lbrakk>finite s; finite s; (xs, l) \\<in> Id;\n        xs \\<in> {l. distinct l \\<and>\n                     s = set l \\<and> sorted_wrt (\\<lambda>_ _. True) l};\n        l \\<in> {l. set l = s}\\<rbrakk>\n       \\<Longrightarrow> (xs, l) \\<in> \\<langle>?S6 xs l\\<rangle>list_rel\n 3. \\<And>xs l.\n       \\<lbrakk>finite s; finite s; (xs, l) \\<in> Id;\n        xs \\<in> {l. distinct l \\<and>\n                     s = set l \\<and> sorted_wrt (\\<lambda>_ _. True) l};\n        l \\<in> {l. set l = s}\\<rbrakk>\n       \\<Longrightarrow> (\\<sigma>, \\<sigma>) \\<in> Id\n 4. \\<And>xs l a a'.\n       \\<lbrakk>finite s; finite s; (xs, l) \\<in> Id;\n        xs \\<in> {l. distinct l \\<and>\n                     s = set l \\<and> sorted_wrt (\\<lambda>_ _. True) l};\n        l \\<in> {l. set l = s}; (a, a') \\<in> Id\\<rbrakk>\n       \\<Longrightarrow> (c a, c a') \\<in> bool_rel\n 5. \\<And>xs l xi x si sa.\n       \\<lbrakk>finite s; finite s; (xs, l) \\<in> Id;\n        xs \\<in> {l. distinct l \\<and>\n                     s = set l \\<and> sorted_wrt (\\<lambda>_ _. True) l};\n        l \\<in> {l. set l = s}; (xi, x) \\<in> ?S6 xs l; (si, sa) \\<in> Id;\n        c sa\\<rbrakk>\n       \\<Longrightarrow> f xi si \\<le> \\<Down> Id (f x sa)", "apply refine_dref_type"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>finite s; finite s\\<rbrakk>\n    \\<Longrightarrow> SPEC\n                       (\\<lambda>l.\n                           distinct l \\<and>\n                           s = set l \\<and>\n                           sorted_wrt (\\<lambda>_ _. True) l)\n                      \\<le> SPEC (\\<lambda>l. set l = s)\n 2. \\<And>xs l.\n       \\<lbrakk>finite s; finite s; (xs, l) \\<in> Id;\n        xs \\<in> {l. distinct l \\<and>\n                     s = set l \\<and> sorted_wrt (\\<lambda>_ _. True) l};\n        l \\<in> {l. set l = s}\\<rbrakk>\n       \\<Longrightarrow> (xs, l) \\<in> \\<langle>Id\\<rangle>list_rel\n 3. \\<And>xs l.\n       \\<lbrakk>finite s; finite s; (xs, l) \\<in> Id;\n        xs \\<in> {l. distinct l \\<and>\n                     s = set l \\<and> sorted_wrt (\\<lambda>_ _. True) l};\n        l \\<in> {l. set l = s}\\<rbrakk>\n       \\<Longrightarrow> (\\<sigma>, \\<sigma>) \\<in> Id\n 4. \\<And>xs l a a'.\n       \\<lbrakk>finite s; finite s; (xs, l) \\<in> Id;\n        xs \\<in> {l. distinct l \\<and>\n                     s = set l \\<and> sorted_wrt (\\<lambda>_ _. True) l};\n        l \\<in> {l. set l = s}; (a, a') \\<in> Id\\<rbrakk>\n       \\<Longrightarrow> (c a, c a') \\<in> bool_rel\n 5. \\<And>xs l xi x si sa.\n       \\<lbrakk>finite s; finite s; (xs, l) \\<in> Id;\n        xs \\<in> {l. distinct l \\<and>\n                     s = set l \\<and> sorted_wrt (\\<lambda>_ _. True) l};\n        l \\<in> {l. set l = s}; (xi, x) \\<in> Id; (si, sa) \\<in> Id;\n        c sa\\<rbrakk>\n       \\<Longrightarrow> f xi si \\<le> \\<Down> Id (f x sa)", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemmas FOREACHc_refines_FOREACHcd[refine]\n  = order_trans[OF FOREACHc_refines_FOREACHcd_aux FOREACHcd_refine]"], ["", "subsection \\<open>Miscellanneous Utility Lemmas\\<close>"], ["", "(* TODO: Can we make this somewhat more general ? *)"], ["", "lemma map_foreach:\n  assumes \"finite S\"\n  shows \"FOREACH S (\\<lambda>x \\<sigma>. RETURN (insert (f x) \\<sigma>)) R0 \\<le> SPEC ((=) (R0 \\<union> f`S))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. FOREACH S (\\<lambda>x \\<sigma>. RETURN (insert (f x) \\<sigma>)) R0\n    \\<le> SPEC ((=) (R0 \\<union> f ` S))", "apply (rule FOREACH_rule[where I=\"\\<lambda>it \\<sigma>. \\<sigma>=R0 \\<union> f`(S-it)\"])"], ["proof (prove)\ngoal (4 subgoals):\n 1. finite S\n 2. R0 = R0 \\<union> f ` (S - S)\n 3. \\<And>x it \\<sigma>.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> S;\n        \\<sigma> = R0 \\<union> f ` (S - it)\\<rbrakk>\n       \\<Longrightarrow> RETURN (insert (f x) \\<sigma>)\n                         \\<le> SPEC\n                                (\\<lambda>\\<sigma>.\n                                    \\<sigma> =\n                                    R0 \\<union> f ` (S - (it - {x})))\n 4. \\<And>\\<sigma>.\n       \\<sigma> = R0 \\<union> f ` (S - {}) \\<Longrightarrow>\n       R0 \\<union> f ` S = \\<sigma>", "apply (auto intro: assms)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma map_sigma_foreach:\n  fixes f :: \"'a \\<times> 'b \\<Rightarrow> 'c\"\n  assumes \"finite A\"\n  assumes \"\\<And>x. x\\<in>A \\<Longrightarrow> finite (B x)\"\n  shows \"FOREACH A (\\<lambda>a \\<sigma>. \n    FOREACH (B a) (\\<lambda>b \\<sigma>. RETURN (insert (f (a,b)) \\<sigma>)) \\<sigma>\n  ) R0 \\<le> SPEC ((=) (R0 \\<union> f`Sigma A B))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. FOREACH A\n     (\\<lambda>a.\n         FOREACH (B a)\n          (\\<lambda>b \\<sigma>. RETURN (insert (f (a, b)) \\<sigma>)))\n     R0\n    \\<le> SPEC ((=) (R0 \\<union> f ` Sigma A B))", "apply (rule FOREACH_rule[where I=\"\\<lambda>it \\<sigma>. \\<sigma>=R0 \\<union> f`(Sigma (A-it) B)\"])"], ["proof (prove)\ngoal (4 subgoals):\n 1. finite A\n 2. R0 = R0 \\<union> f ` Sigma (A - A) B\n 3. \\<And>x it \\<sigma>.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> A;\n        \\<sigma> = R0 \\<union> f ` Sigma (A - it) B\\<rbrakk>\n       \\<Longrightarrow> FOREACH (B x)\n                          (\\<lambda>b \\<sigma>.\n                              RETURN (insert (f (x, b)) \\<sigma>))\n                          \\<sigma>\n                         \\<le> SPEC\n                                (\\<lambda>\\<sigma>.\n                                    \\<sigma> =\n                                    R0 \\<union>\n                                    f ` Sigma (A - (it - {x})) B)\n 4. \\<And>\\<sigma>.\n       \\<sigma> = R0 \\<union> f ` Sigma (A - {}) B \\<Longrightarrow>\n       R0 \\<union> f ` Sigma A B = \\<sigma>", "apply (auto intro: assms) [2]"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x it \\<sigma>.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> A;\n        \\<sigma> = R0 \\<union> f ` Sigma (A - it) B\\<rbrakk>\n       \\<Longrightarrow> FOREACH (B x)\n                          (\\<lambda>b \\<sigma>.\n                              RETURN (insert (f (x, b)) \\<sigma>))\n                          \\<sigma>\n                         \\<le> SPEC\n                                (\\<lambda>\\<sigma>.\n                                    \\<sigma> =\n                                    R0 \\<union>\n                                    f ` Sigma (A - (it - {x})) B)\n 2. \\<And>\\<sigma>.\n       \\<sigma> = R0 \\<union> f ` Sigma (A - {}) B \\<Longrightarrow>\n       R0 \\<union> f ` Sigma A B = \\<sigma>", "apply (rule_tac I=\"\\<lambda>it' \\<sigma>. \\<sigma>=R0 \\<union> f`(Sigma (A - it) B) \n    \\<union> f`({x} \\<times> (B x - it'))\"\n    in FOREACH_rule)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x it \\<sigma>.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> A;\n        \\<sigma> = R0 \\<union> f ` Sigma (A - it) B\\<rbrakk>\n       \\<Longrightarrow> finite (B x)\n 2. \\<And>x it \\<sigma>.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> A;\n        \\<sigma> = R0 \\<union> f ` Sigma (A - it) B\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> =\n                         R0 \\<union> f ` Sigma (A - it) B \\<union>\n                         f ` ({x} \\<times> (B x - B x))\n 3. \\<And>x it \\<sigma> xa ita \\<sigma>'.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> A;\n        \\<sigma> = R0 \\<union> f ` Sigma (A - it) B; xa \\<in> ita;\n        ita \\<subseteq> B x;\n        \\<sigma>' =\n        R0 \\<union> f ` Sigma (A - it) B \\<union>\n        f ` ({x} \\<times> (B x - ita))\\<rbrakk>\n       \\<Longrightarrow> RETURN (insert (f (x, xa)) \\<sigma>')\n                         \\<le> SPEC\n                                (\\<lambda>\\<sigma>.\n                                    \\<sigma> =\n                                    R0 \\<union>\n                                    f ` Sigma (A - it) B \\<union>\n                                    f ` ({x} \\<times> (B x - (ita - {xa}))))\n 4. \\<And>x it \\<sigma> \\<sigma>'.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> A;\n        \\<sigma> = R0 \\<union> f ` Sigma (A - it) B;\n        \\<sigma>' =\n        R0 \\<union> f ` Sigma (A - it) B \\<union>\n        f ` ({x} \\<times> (B x - {}))\\<rbrakk>\n       \\<Longrightarrow> \\<sigma>' =\n                         R0 \\<union> f ` Sigma (A - (it - {x})) B\n 5. \\<And>\\<sigma>.\n       \\<sigma> = R0 \\<union> f ` Sigma (A - {}) B \\<Longrightarrow>\n       R0 \\<union> f ` Sigma A B = \\<sigma>", "apply (auto intro: assms) [2]"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x it \\<sigma> xa ita \\<sigma>'.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> A;\n        \\<sigma> = R0 \\<union> f ` Sigma (A - it) B; xa \\<in> ita;\n        ita \\<subseteq> B x;\n        \\<sigma>' =\n        R0 \\<union> f ` Sigma (A - it) B \\<union>\n        f ` ({x} \\<times> (B x - ita))\\<rbrakk>\n       \\<Longrightarrow> RETURN (insert (f (x, xa)) \\<sigma>')\n                         \\<le> SPEC\n                                (\\<lambda>\\<sigma>.\n                                    \\<sigma> =\n                                    R0 \\<union>\n                                    f ` Sigma (A - it) B \\<union>\n                                    f ` ({x} \\<times> (B x - (ita - {xa}))))\n 2. \\<And>x it \\<sigma> \\<sigma>'.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> A;\n        \\<sigma> = R0 \\<union> f ` Sigma (A - it) B;\n        \\<sigma>' =\n        R0 \\<union> f ` Sigma (A - it) B \\<union>\n        f ` ({x} \\<times> (B x - {}))\\<rbrakk>\n       \\<Longrightarrow> \\<sigma>' =\n                         R0 \\<union> f ` Sigma (A - (it - {x})) B\n 3. \\<And>\\<sigma>.\n       \\<sigma> = R0 \\<union> f ` Sigma (A - {}) B \\<Longrightarrow>\n       R0 \\<union> f ` Sigma A B = \\<sigma>", "apply (rule refine_vcg)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x it \\<sigma> xa ita \\<sigma>'.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> A;\n        \\<sigma> = R0 \\<union> f ` Sigma (A - it) B; xa \\<in> ita;\n        ita \\<subseteq> B x;\n        \\<sigma>' =\n        R0 \\<union> f ` Sigma (A - it) B \\<union>\n        f ` ({x} \\<times> (B x - ita))\\<rbrakk>\n       \\<Longrightarrow> insert (f (x, xa)) \\<sigma>' =\n                         R0 \\<union> f ` Sigma (A - it) B \\<union>\n                         f ` ({x} \\<times> (B x - (ita - {xa})))\n 2. \\<And>x it \\<sigma> \\<sigma>'.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> A;\n        \\<sigma> = R0 \\<union> f ` Sigma (A - it) B;\n        \\<sigma>' =\n        R0 \\<union> f ` Sigma (A - it) B \\<union>\n        f ` ({x} \\<times> (B x - {}))\\<rbrakk>\n       \\<Longrightarrow> \\<sigma>' =\n                         R0 \\<union> f ` Sigma (A - (it - {x})) B\n 3. \\<And>\\<sigma>.\n       \\<sigma> = R0 \\<union> f ` Sigma (A - {}) B \\<Longrightarrow>\n       R0 \\<union> f ` Sigma A B = \\<sigma>", "apply auto []"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x it \\<sigma> \\<sigma>'.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> A;\n        \\<sigma> = R0 \\<union> f ` Sigma (A - it) B;\n        \\<sigma>' =\n        R0 \\<union> f ` Sigma (A - it) B \\<union>\n        f ` ({x} \\<times> (B x - {}))\\<rbrakk>\n       \\<Longrightarrow> \\<sigma>' =\n                         R0 \\<union> f ` Sigma (A - (it - {x})) B\n 2. \\<And>\\<sigma>.\n       \\<sigma> = R0 \\<union> f ` Sigma (A - {}) B \\<Longrightarrow>\n       R0 \\<union> f ` Sigma A B = \\<sigma>", "apply auto []"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       \\<sigma> = R0 \\<union> f ` Sigma (A - {}) B \\<Longrightarrow>\n       R0 \\<union> f ` Sigma A B = \\<sigma>", "apply auto []"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma map_sigma_sigma_foreach:\n  fixes f :: \"'a \\<times> ('b \\<times> 'c) \\<Rightarrow> 'd\"\n  assumes \"finite A\"\n  assumes \"\\<And>a. a\\<in>A \\<Longrightarrow> finite (B a)\"\n  assumes \"\\<And>a b. \\<lbrakk>a\\<in>A; b\\<in>B a\\<rbrakk> \\<Longrightarrow> finite (C a b)\"\n  shows \"FOREACH A (\\<lambda>a \\<sigma>. \n    FOREACH (B a) (\\<lambda>b \\<sigma>. \n      FOREACH (C a b) (\\<lambda>c \\<sigma>.\n        RETURN (insert (f (a,(b,c))) \\<sigma>)) \\<sigma>) \\<sigma>\n  ) R0 \\<le> SPEC ((=) (R0 \\<union> f`Sigma A (\\<lambda>a. Sigma (B a) (C a))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. FOREACH A\n     (\\<lambda>a.\n         FOREACH (B a)\n          (\\<lambda>b.\n              FOREACH (C a b)\n               (\\<lambda>c \\<sigma>.\n                   RETURN (insert (f (a, b, c)) \\<sigma>))))\n     R0\n    \\<le> SPEC ((=) (R0 \\<union> f ` (SIGMA a:A. Sigma (B a) (C a))))", "apply (rule FOREACH_rule[where \n    I=\"\\<lambda>it \\<sigma>. \\<sigma>=R0 \\<union> f`(Sigma (A-it) (\\<lambda>a. Sigma (B a) (C a)))\"])"], ["proof (prove)\ngoal (4 subgoals):\n 1. finite A\n 2. R0 = R0 \\<union> f ` (SIGMA a:A - A. Sigma (B a) (C a))\n 3. \\<And>x it \\<sigma>.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> A;\n        \\<sigma> =\n        R0 \\<union> f ` (SIGMA a:A - it. Sigma (B a) (C a))\\<rbrakk>\n       \\<Longrightarrow> FOREACH (B x)\n                          (\\<lambda>b.\n                              FOREACH (C x b)\n                               (\\<lambda>c \\<sigma>.\n                                   RETURN (insert (f (x, b, c)) \\<sigma>)))\n                          \\<sigma>\n                         \\<le> SPEC\n                                (\\<lambda>\\<sigma>.\n                                    \\<sigma> =\n                                    R0 \\<union>\n                                    f `\n                                    (SIGMA a:A - (it - {x}).\n  Sigma (B a) (C a)))\n 4. \\<And>\\<sigma>.\n       \\<sigma> =\n       R0 \\<union> f ` (SIGMA a:A - {}. Sigma (B a) (C a)) \\<Longrightarrow>\n       R0 \\<union> f ` (SIGMA a:A. Sigma (B a) (C a)) = \\<sigma>", "apply (auto intro: assms) [2]"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x it \\<sigma>.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> A;\n        \\<sigma> =\n        R0 \\<union> f ` (SIGMA a:A - it. Sigma (B a) (C a))\\<rbrakk>\n       \\<Longrightarrow> FOREACH (B x)\n                          (\\<lambda>b.\n                              FOREACH (C x b)\n                               (\\<lambda>c \\<sigma>.\n                                   RETURN (insert (f (x, b, c)) \\<sigma>)))\n                          \\<sigma>\n                         \\<le> SPEC\n                                (\\<lambda>\\<sigma>.\n                                    \\<sigma> =\n                                    R0 \\<union>\n                                    f `\n                                    (SIGMA a:A - (it - {x}).\n  Sigma (B a) (C a)))\n 2. \\<And>\\<sigma>.\n       \\<sigma> =\n       R0 \\<union> f ` (SIGMA a:A - {}. Sigma (B a) (C a)) \\<Longrightarrow>\n       R0 \\<union> f ` (SIGMA a:A. Sigma (B a) (C a)) = \\<sigma>", "apply (rule_tac \n    I=\"\\<lambda>it' \\<sigma>. \\<sigma>=R0 \\<union> f`(Sigma (A - it) (\\<lambda>a. Sigma (B a) (C a))) \n      \\<union> f`({x} \\<times> ( Sigma (B x - it') (C x)))\"\n    in FOREACH_rule)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x it \\<sigma>.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> A;\n        \\<sigma> =\n        R0 \\<union> f ` (SIGMA a:A - it. Sigma (B a) (C a))\\<rbrakk>\n       \\<Longrightarrow> finite (B x)\n 2. \\<And>x it \\<sigma>.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> A;\n        \\<sigma> =\n        R0 \\<union> f ` (SIGMA a:A - it. Sigma (B a) (C a))\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> =\n                         R0 \\<union>\n                         f ` (SIGMA a:A - it. Sigma (B a) (C a)) \\<union>\n                         f ` ({x} \\<times> Sigma (B x - B x) (C x))\n 3. \\<And>x it \\<sigma> xa ita \\<sigma>'.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> A;\n        \\<sigma> = R0 \\<union> f ` (SIGMA a:A - it. Sigma (B a) (C a));\n        xa \\<in> ita; ita \\<subseteq> B x;\n        \\<sigma>' =\n        R0 \\<union> f ` (SIGMA a:A - it. Sigma (B a) (C a)) \\<union>\n        f ` ({x} \\<times> Sigma (B x - ita) (C x))\\<rbrakk>\n       \\<Longrightarrow> FOREACH (C x xa)\n                          (\\<lambda>c \\<sigma>.\n                              RETURN (insert (f (x, xa, c)) \\<sigma>))\n                          \\<sigma>'\n                         \\<le> SPEC\n                                (\\<lambda>\\<sigma>.\n                                    \\<sigma> =\n                                    R0 \\<union>\n                                    f `\n                                    (SIGMA a:A - it.\n  Sigma (B a) (C a)) \\<union>\n                                    f `\n                                    ({x} \\<times>\n                                     Sigma (B x - (ita - {xa})) (C x)))\n 4. \\<And>x it \\<sigma> \\<sigma>'.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> A;\n        \\<sigma> = R0 \\<union> f ` (SIGMA a:A - it. Sigma (B a) (C a));\n        \\<sigma>' =\n        R0 \\<union> f ` (SIGMA a:A - it. Sigma (B a) (C a)) \\<union>\n        f ` ({x} \\<times> Sigma (B x - {}) (C x))\\<rbrakk>\n       \\<Longrightarrow> \\<sigma>' =\n                         R0 \\<union>\n                         f ` (SIGMA a:A - (it - {x}). Sigma (B a) (C a))\n 5. \\<And>\\<sigma>.\n       \\<sigma> =\n       R0 \\<union> f ` (SIGMA a:A - {}. Sigma (B a) (C a)) \\<Longrightarrow>\n       R0 \\<union> f ` (SIGMA a:A. Sigma (B a) (C a)) = \\<sigma>", "apply (auto intro: assms) [2]"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x it \\<sigma> xa ita \\<sigma>'.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> A;\n        \\<sigma> = R0 \\<union> f ` (SIGMA a:A - it. Sigma (B a) (C a));\n        xa \\<in> ita; ita \\<subseteq> B x;\n        \\<sigma>' =\n        R0 \\<union> f ` (SIGMA a:A - it. Sigma (B a) (C a)) \\<union>\n        f ` ({x} \\<times> Sigma (B x - ita) (C x))\\<rbrakk>\n       \\<Longrightarrow> FOREACH (C x xa)\n                          (\\<lambda>c \\<sigma>.\n                              RETURN (insert (f (x, xa, c)) \\<sigma>))\n                          \\<sigma>'\n                         \\<le> SPEC\n                                (\\<lambda>\\<sigma>.\n                                    \\<sigma> =\n                                    R0 \\<union>\n                                    f `\n                                    (SIGMA a:A - it.\n  Sigma (B a) (C a)) \\<union>\n                                    f `\n                                    ({x} \\<times>\n                                     Sigma (B x - (ita - {xa})) (C x)))\n 2. \\<And>x it \\<sigma> \\<sigma>'.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> A;\n        \\<sigma> = R0 \\<union> f ` (SIGMA a:A - it. Sigma (B a) (C a));\n        \\<sigma>' =\n        R0 \\<union> f ` (SIGMA a:A - it. Sigma (B a) (C a)) \\<union>\n        f ` ({x} \\<times> Sigma (B x - {}) (C x))\\<rbrakk>\n       \\<Longrightarrow> \\<sigma>' =\n                         R0 \\<union>\n                         f ` (SIGMA a:A - (it - {x}). Sigma (B a) (C a))\n 3. \\<And>\\<sigma>.\n       \\<sigma> =\n       R0 \\<union> f ` (SIGMA a:A - {}. Sigma (B a) (C a)) \\<Longrightarrow>\n       R0 \\<union> f ` (SIGMA a:A. Sigma (B a) (C a)) = \\<sigma>", "apply (rule_tac \n    I=\"\\<lambda>it'' \\<sigma>. \\<sigma>=R0 \\<union> f`(Sigma (A - it) (\\<lambda>a. Sigma (B a) (C a))) \n      \\<union> f`({x} \\<times> ( Sigma (B x - ita) (C x)))\n      \\<union> f`({x} \\<times> ({xa} \\<times> (C x xa - it'')))\n    \"\n    in FOREACH_rule)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>x it \\<sigma> xa ita \\<sigma>'.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> A;\n        \\<sigma> = R0 \\<union> f ` (SIGMA a:A - it. Sigma (B a) (C a));\n        xa \\<in> ita; ita \\<subseteq> B x;\n        \\<sigma>' =\n        R0 \\<union> f ` (SIGMA a:A - it. Sigma (B a) (C a)) \\<union>\n        f ` ({x} \\<times> Sigma (B x - ita) (C x))\\<rbrakk>\n       \\<Longrightarrow> finite (C x xa)\n 2. \\<And>x it \\<sigma> xa ita \\<sigma>'.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> A;\n        \\<sigma> = R0 \\<union> f ` (SIGMA a:A - it. Sigma (B a) (C a));\n        xa \\<in> ita; ita \\<subseteq> B x;\n        \\<sigma>' =\n        R0 \\<union> f ` (SIGMA a:A - it. Sigma (B a) (C a)) \\<union>\n        f ` ({x} \\<times> Sigma (B x - ita) (C x))\\<rbrakk>\n       \\<Longrightarrow> \\<sigma>' =\n                         R0 \\<union>\n                         f ` (SIGMA a:A - it. Sigma (B a) (C a)) \\<union>\n                         f ` ({x} \\<times> Sigma (B x - ita) (C x)) \\<union>\n                         f ` ({x} \\<times> {xa} \\<times> (C x xa - C x xa))\n 3. \\<And>x it \\<sigma> xa ita \\<sigma>' xb itb \\<sigma>''.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> A;\n        \\<sigma> = R0 \\<union> f ` (SIGMA a:A - it. Sigma (B a) (C a));\n        xa \\<in> ita; ita \\<subseteq> B x;\n        \\<sigma>' =\n        R0 \\<union> f ` (SIGMA a:A - it. Sigma (B a) (C a)) \\<union>\n        f ` ({x} \\<times> Sigma (B x - ita) (C x));\n        xb \\<in> itb; itb \\<subseteq> C x xa;\n        \\<sigma>'' =\n        R0 \\<union> f ` (SIGMA a:A - it. Sigma (B a) (C a)) \\<union>\n        f ` ({x} \\<times> Sigma (B x - ita) (C x)) \\<union>\n        f ` ({x} \\<times> {xa} \\<times> (C x xa - itb))\\<rbrakk>\n       \\<Longrightarrow> RETURN (insert (f (x, xa, xb)) \\<sigma>'')\n                         \\<le> SPEC\n                                (\\<lambda>\\<sigma>.\n                                    \\<sigma> =\n                                    R0 \\<union>\n                                    f `\n                                    (SIGMA a:A - it.\n  Sigma (B a) (C a)) \\<union>\n                                    f `\n                                    ({x} \\<times>\n                                     Sigma (B x - ita) (C x)) \\<union>\n                                    f `\n                                    ({x} \\<times>\n                                     {xa} \\<times> (C x xa - (itb - {xb}))))\n 4. \\<And>x it \\<sigma> xa ita \\<sigma>' \\<sigma>''.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> A;\n        \\<sigma> = R0 \\<union> f ` (SIGMA a:A - it. Sigma (B a) (C a));\n        xa \\<in> ita; ita \\<subseteq> B x;\n        \\<sigma>' =\n        R0 \\<union> f ` (SIGMA a:A - it. Sigma (B a) (C a)) \\<union>\n        f ` ({x} \\<times> Sigma (B x - ita) (C x));\n        \\<sigma>'' =\n        R0 \\<union> f ` (SIGMA a:A - it. Sigma (B a) (C a)) \\<union>\n        f ` ({x} \\<times> Sigma (B x - ita) (C x)) \\<union>\n        f ` ({x} \\<times> {xa} \\<times> (C x xa - {}))\\<rbrakk>\n       \\<Longrightarrow> \\<sigma>'' =\n                         R0 \\<union>\n                         f ` (SIGMA a:A - it. Sigma (B a) (C a)) \\<union>\n                         f ` ({x} \\<times> Sigma (B x - (ita - {xa})) (C x))\n 5. \\<And>x it \\<sigma> \\<sigma>'.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> A;\n        \\<sigma> = R0 \\<union> f ` (SIGMA a:A - it. Sigma (B a) (C a));\n        \\<sigma>' =\n        R0 \\<union> f ` (SIGMA a:A - it. Sigma (B a) (C a)) \\<union>\n        f ` ({x} \\<times> Sigma (B x - {}) (C x))\\<rbrakk>\n       \\<Longrightarrow> \\<sigma>' =\n                         R0 \\<union>\n                         f ` (SIGMA a:A - (it - {x}). Sigma (B a) (C a))\n 6. \\<And>\\<sigma>.\n       \\<sigma> =\n       R0 \\<union> f ` (SIGMA a:A - {}. Sigma (B a) (C a)) \\<Longrightarrow>\n       R0 \\<union> f ` (SIGMA a:A. Sigma (B a) (C a)) = \\<sigma>", "apply (auto intro: assms) [2]"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x it \\<sigma> xa ita \\<sigma>' xb itb \\<sigma>''.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> A;\n        \\<sigma> = R0 \\<union> f ` (SIGMA a:A - it. Sigma (B a) (C a));\n        xa \\<in> ita; ita \\<subseteq> B x;\n        \\<sigma>' =\n        R0 \\<union> f ` (SIGMA a:A - it. Sigma (B a) (C a)) \\<union>\n        f ` ({x} \\<times> Sigma (B x - ita) (C x));\n        xb \\<in> itb; itb \\<subseteq> C x xa;\n        \\<sigma>'' =\n        R0 \\<union> f ` (SIGMA a:A - it. Sigma (B a) (C a)) \\<union>\n        f ` ({x} \\<times> Sigma (B x - ita) (C x)) \\<union>\n        f ` ({x} \\<times> {xa} \\<times> (C x xa - itb))\\<rbrakk>\n       \\<Longrightarrow> RETURN (insert (f (x, xa, xb)) \\<sigma>'')\n                         \\<le> SPEC\n                                (\\<lambda>\\<sigma>.\n                                    \\<sigma> =\n                                    R0 \\<union>\n                                    f `\n                                    (SIGMA a:A - it.\n  Sigma (B a) (C a)) \\<union>\n                                    f `\n                                    ({x} \\<times>\n                                     Sigma (B x - ita) (C x)) \\<union>\n                                    f `\n                                    ({x} \\<times>\n                                     {xa} \\<times> (C x xa - (itb - {xb}))))\n 2. \\<And>x it \\<sigma> xa ita \\<sigma>' \\<sigma>''.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> A;\n        \\<sigma> = R0 \\<union> f ` (SIGMA a:A - it. Sigma (B a) (C a));\n        xa \\<in> ita; ita \\<subseteq> B x;\n        \\<sigma>' =\n        R0 \\<union> f ` (SIGMA a:A - it. Sigma (B a) (C a)) \\<union>\n        f ` ({x} \\<times> Sigma (B x - ita) (C x));\n        \\<sigma>'' =\n        R0 \\<union> f ` (SIGMA a:A - it. Sigma (B a) (C a)) \\<union>\n        f ` ({x} \\<times> Sigma (B x - ita) (C x)) \\<union>\n        f ` ({x} \\<times> {xa} \\<times> (C x xa - {}))\\<rbrakk>\n       \\<Longrightarrow> \\<sigma>'' =\n                         R0 \\<union>\n                         f ` (SIGMA a:A - it. Sigma (B a) (C a)) \\<union>\n                         f ` ({x} \\<times> Sigma (B x - (ita - {xa})) (C x))\n 3. \\<And>x it \\<sigma> \\<sigma>'.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> A;\n        \\<sigma> = R0 \\<union> f ` (SIGMA a:A - it. Sigma (B a) (C a));\n        \\<sigma>' =\n        R0 \\<union> f ` (SIGMA a:A - it. Sigma (B a) (C a)) \\<union>\n        f ` ({x} \\<times> Sigma (B x - {}) (C x))\\<rbrakk>\n       \\<Longrightarrow> \\<sigma>' =\n                         R0 \\<union>\n                         f ` (SIGMA a:A - (it - {x}). Sigma (B a) (C a))\n 4. \\<And>\\<sigma>.\n       \\<sigma> =\n       R0 \\<union> f ` (SIGMA a:A - {}. Sigma (B a) (C a)) \\<Longrightarrow>\n       R0 \\<union> f ` (SIGMA a:A. Sigma (B a) (C a)) = \\<sigma>", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma bij_set_rel_for_inj: \n  fixes R\n  defines \"\\<alpha> \\<equiv> fun_of_rel R\" \n  assumes \"bijective R\" \"(s,s')\\<in>\\<langle>R\\<rangle>set_rel\"  \n  shows \"inj_on \\<alpha> s\" \"s' = \\<alpha>`s\"\n  \\<comment> \\<open>To be used when generating refinement conditions for foreach-loops\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on \\<alpha> s &&& s' = \\<alpha> ` s", "using assms"], ["proof (prove)\nusing this:\n  \\<alpha> \\<equiv> fun_of_rel R\n  bijective R\n  (s, s') \\<in> \\<langle>R\\<rangle>set_rel\n\ngoal (1 subgoal):\n 1. inj_on \\<alpha> s &&& s' = \\<alpha> ` s", "unfolding bijective_def set_rel_def \\<alpha>_def fun_of_rel_def[abs_def]"], ["proof (prove)\nusing this:\n  \\<lambda>x. SOME y. (x, y) \\<in> R \\<equiv>\n  \\<lambda>x. SOME y. (x, y) \\<in> R\n  (\\<forall>x y z.\n      (x, y) \\<in> R \\<and> (x, z) \\<in> R \\<longrightarrow> y = z) \\<and>\n  (\\<forall>x y z.\n      (x, z) \\<in> R \\<and> (y, z) \\<in> R \\<longrightarrow> x = y)\n  (s, s')\n  \\<in> {(A, B).\n         (\\<forall>x\\<in>A. \\<exists>y\\<in>B. (x, y) \\<in> R) \\<and>\n         (\\<forall>y\\<in>B. \\<exists>x\\<in>A. (x, y) \\<in> R)}\n\ngoal (1 subgoal):\n 1. inj_on (\\<lambda>x. SOME y. (x, y) \\<in> R) s &&&\n    s' = (\\<lambda>x. SOME y. (x, y) \\<in> R) ` s", "apply (auto intro!: inj_onI ImageI simp: image_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>\\<lambda>x. SOME y. (x, y) \\<in> R \\<equiv>\n                \\<lambda>x. SOME y. (x, y) \\<in> R;\n        x \\<in> s; y \\<in> s;\n        (SOME y. (x, y) \\<in> R) = (SOME ya. (y, ya) \\<in> R);\n        \\<forall>x y z.\n           (x, y) \\<in> R \\<and> (x, z) \\<in> R \\<longrightarrow> y = z;\n        \\<forall>x y.\n           (\\<exists>z.\n               (x, z) \\<in> R \\<and> (y, z) \\<in> R) \\<longrightarrow>\n           x = y;\n        \\<forall>x\\<in>s. \\<exists>y\\<in>s'. (x, y) \\<in> R;\n        \\<forall>y\\<in>s'. \\<exists>x\\<in>s. (x, y) \\<in> R\\<rbrakk>\n       \\<Longrightarrow> x = y\n 2. \\<And>x.\n       \\<lbrakk>\\<lambda>x. SOME y. (x, y) \\<in> R \\<equiv>\n                \\<lambda>x. SOME y. (x, y) \\<in> R;\n        \\<forall>x y z.\n           (x, y) \\<in> R \\<and> (x, z) \\<in> R \\<longrightarrow> y = z;\n        \\<forall>x y.\n           (\\<exists>z.\n               (x, z) \\<in> R \\<and> (y, z) \\<in> R) \\<longrightarrow>\n           x = y;\n        \\<forall>x\\<in>s. \\<exists>y\\<in>s'. (x, y) \\<in> R;\n        \\<forall>y\\<in>s'. \\<exists>x\\<in>s. (x, y) \\<in> R;\n        x \\<in> s'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa\\<in>s. x = (SOME y. (xa, y) \\<in> R)\n 3. \\<And>xa.\n       \\<lbrakk>\\<lambda>x. SOME y. (x, y) \\<in> R \\<equiv>\n                \\<lambda>x. SOME y. (x, y) \\<in> R;\n        \\<forall>x y z.\n           (x, y) \\<in> R \\<and> (x, z) \\<in> R \\<longrightarrow> y = z;\n        \\<forall>x y.\n           (\\<exists>z.\n               (x, z) \\<in> R \\<and> (y, z) \\<in> R) \\<longrightarrow>\n           x = y;\n        \\<forall>x\\<in>s. \\<exists>y\\<in>s'. (x, y) \\<in> R;\n        \\<forall>y\\<in>s'. \\<exists>x\\<in>s. (x, y) \\<in> R;\n        xa \\<in> s\\<rbrakk>\n       \\<Longrightarrow> (SOME y. (xa, y) \\<in> R) \\<in> s'", "apply (metis (mono_tags) Domain.simps contra_subsetD tfl_some)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<lambda>x. SOME y. (x, y) \\<in> R \\<equiv>\n                \\<lambda>x. SOME y. (x, y) \\<in> R;\n        \\<forall>x y z.\n           (x, y) \\<in> R \\<and> (x, z) \\<in> R \\<longrightarrow> y = z;\n        \\<forall>x y.\n           (\\<exists>z.\n               (x, z) \\<in> R \\<and> (y, z) \\<in> R) \\<longrightarrow>\n           x = y;\n        \\<forall>x\\<in>s. \\<exists>y\\<in>s'. (x, y) \\<in> R;\n        \\<forall>y\\<in>s'. \\<exists>x\\<in>s. (x, y) \\<in> R;\n        x \\<in> s'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa\\<in>s. x = (SOME y. (xa, y) \\<in> R)\n 2. \\<And>xa.\n       \\<lbrakk>\\<lambda>x. SOME y. (x, y) \\<in> R \\<equiv>\n                \\<lambda>x. SOME y. (x, y) \\<in> R;\n        \\<forall>x y z.\n           (x, y) \\<in> R \\<and> (x, z) \\<in> R \\<longrightarrow> y = z;\n        \\<forall>x y.\n           (\\<exists>z.\n               (x, z) \\<in> R \\<and> (y, z) \\<in> R) \\<longrightarrow>\n           x = y;\n        \\<forall>x\\<in>s. \\<exists>y\\<in>s'. (x, y) \\<in> R;\n        \\<forall>y\\<in>s'. \\<exists>x\\<in>s. (x, y) \\<in> R;\n        xa \\<in> s\\<rbrakk>\n       \\<Longrightarrow> (SOME y. (xa, y) \\<in> R) \\<in> s'", "apply (metis (mono_tags) someI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>\\<lambda>x. SOME y. (x, y) \\<in> R \\<equiv>\n                \\<lambda>x. SOME y. (x, y) \\<in> R;\n        \\<forall>x y z.\n           (x, y) \\<in> R \\<and> (x, z) \\<in> R \\<longrightarrow> y = z;\n        \\<forall>x y.\n           (\\<exists>z.\n               (x, z) \\<in> R \\<and> (y, z) \\<in> R) \\<longrightarrow>\n           x = y;\n        \\<forall>x\\<in>s. \\<exists>y\\<in>s'. (x, y) \\<in> R;\n        \\<forall>y\\<in>s'. \\<exists>x\\<in>s. (x, y) \\<in> R;\n        xa \\<in> s\\<rbrakk>\n       \\<Longrightarrow> (SOME y. (xa, y) \\<in> R) \\<in> s'", "apply (metis DomainE contra_subsetD tfl_some)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma nfoldli_by_idx_gen:\n  shows \"nfoldli (drop k l) c f s = nfoldli [k..<length l] c (\\<lambda>i s. do {\n      ASSERT (i<length l);\n      let x = l!i;\n      f x s\n    }) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nfoldli (drop k l) c f s =\n    nfoldli [k..<length l] c\n     (\\<lambda>i s.\n         ASSERT (i < length l) \\<bind> (\\<lambda>_. let x = l ! i in f x s))\n     s", "proof (cases \"k\\<le>length l\")"], ["proof (state)\ngoal (2 subgoals):\n 1. k \\<le> length l \\<Longrightarrow>\n    nfoldli (drop k l) c f s =\n    nfoldli [k..<length l] c\n     (\\<lambda>i s.\n         ASSERT (i < length l) \\<bind> (\\<lambda>_. let x = l ! i in f x s))\n     s\n 2. \\<not> k \\<le> length l \\<Longrightarrow>\n    nfoldli (drop k l) c f s =\n    nfoldli [k..<length l] c\n     (\\<lambda>i s.\n         ASSERT (i < length l) \\<bind> (\\<lambda>_. let x = l ! i in f x s))\n     s", "case False"], ["proof (state)\nthis:\n  \\<not> k \\<le> length l\n\ngoal (2 subgoals):\n 1. k \\<le> length l \\<Longrightarrow>\n    nfoldli (drop k l) c f s =\n    nfoldli [k..<length l] c\n     (\\<lambda>i s.\n         ASSERT (i < length l) \\<bind> (\\<lambda>_. let x = l ! i in f x s))\n     s\n 2. \\<not> k \\<le> length l \\<Longrightarrow>\n    nfoldli (drop k l) c f s =\n    nfoldli [k..<length l] c\n     (\\<lambda>i s.\n         ASSERT (i < length l) \\<bind> (\\<lambda>_. let x = l ! i in f x s))\n     s", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> k \\<le> length l\n\ngoal (1 subgoal):\n 1. nfoldli (drop k l) c f s =\n    nfoldli [k..<length l] c\n     (\\<lambda>i s.\n         ASSERT (i < length l) \\<bind> (\\<lambda>_. let x = l ! i in f x s))\n     s", "by auto"], ["proof (state)\nthis:\n  nfoldli (drop k l) c f s =\n  nfoldli [k..<length l] c\n   (\\<lambda>i s.\n       ASSERT (i < length l) \\<bind> (\\<lambda>_. let x = l ! i in f x s))\n   s\n\ngoal (1 subgoal):\n 1. k \\<le> length l \\<Longrightarrow>\n    nfoldli (drop k l) c f s =\n    nfoldli [k..<length l] c\n     (\\<lambda>i s.\n         ASSERT (i < length l) \\<bind> (\\<lambda>_. let x = l ! i in f x s))\n     s", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. k \\<le> length l \\<Longrightarrow>\n    nfoldli (drop k l) c f s =\n    nfoldli [k..<length l] c\n     (\\<lambda>i s.\n         ASSERT (i < length l) \\<bind> (\\<lambda>_. let x = l ! i in f x s))\n     s", "case True"], ["proof (state)\nthis:\n  k \\<le> length l\n\ngoal (1 subgoal):\n 1. k \\<le> length l \\<Longrightarrow>\n    nfoldli (drop k l) c f s =\n    nfoldli [k..<length l] c\n     (\\<lambda>i s.\n         ASSERT (i < length l) \\<bind> (\\<lambda>_. let x = l ! i in f x s))\n     s", "thus ?thesis"], ["proof (prove)\nusing this:\n  k \\<le> length l\n\ngoal (1 subgoal):\n 1. nfoldli (drop k l) c f s =\n    nfoldli [k..<length l] c\n     (\\<lambda>i s.\n         ASSERT (i < length l) \\<bind> (\\<lambda>_. let x = l ! i in f x s))\n     s", "proof (induction arbitrary: s rule: inc_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s.\n       nfoldli (drop (length l) l) c f s =\n       nfoldli [length l..<length l] c\n        (\\<lambda>i s.\n            ASSERT (i < length l) \\<bind>\n            (\\<lambda>_. let x = l ! i in f x s))\n        s\n 2. \\<And>n s.\n       \\<lbrakk>k \\<le> n; n < length l;\n        \\<And>s.\n           nfoldli (drop (Suc n) l) c f s =\n           nfoldli [Suc n..<length l] c\n            (\\<lambda>i s.\n                ASSERT (i < length l) \\<bind>\n                (\\<lambda>_. let x = l ! i in f x s))\n            s\\<rbrakk>\n       \\<Longrightarrow> nfoldli (drop n l) c f s =\n                         nfoldli [n..<length l] c\n                          (\\<lambda>i s.\n                              ASSERT (i < length l) \\<bind>\n                              (\\<lambda>_. let x = l ! i in f x s))\n                          s", "case base"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>s.\n       nfoldli (drop (length l) l) c f s =\n       nfoldli [length l..<length l] c\n        (\\<lambda>i s.\n            ASSERT (i < length l) \\<bind>\n            (\\<lambda>_. let x = l ! i in f x s))\n        s\n 2. \\<And>n s.\n       \\<lbrakk>k \\<le> n; n < length l;\n        \\<And>s.\n           nfoldli (drop (Suc n) l) c f s =\n           nfoldli [Suc n..<length l] c\n            (\\<lambda>i s.\n                ASSERT (i < length l) \\<bind>\n                (\\<lambda>_. let x = l ! i in f x s))\n            s\\<rbrakk>\n       \\<Longrightarrow> nfoldli (drop n l) c f s =\n                         nfoldli [n..<length l] c\n                          (\\<lambda>i s.\n                              ASSERT (i < length l) \\<bind>\n                              (\\<lambda>_. let x = l ! i in f x s))\n                          s", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. nfoldli (drop (length l) l) c f s =\n    nfoldli [length l..<length l] c\n     (\\<lambda>i s.\n         ASSERT (i < length l) \\<bind> (\\<lambda>_. let x = l ! i in f x s))\n     s", "by auto"], ["proof (state)\nthis:\n  nfoldli (drop (length l) l) c f s =\n  nfoldli [length l..<length l] c\n   (\\<lambda>i s.\n       ASSERT (i < length l) \\<bind> (\\<lambda>_. let x = l ! i in f x s))\n   s\n\ngoal (1 subgoal):\n 1. \\<And>n s.\n       \\<lbrakk>k \\<le> n; n < length l;\n        \\<And>s.\n           nfoldli (drop (Suc n) l) c f s =\n           nfoldli [Suc n..<length l] c\n            (\\<lambda>i s.\n                ASSERT (i < length l) \\<bind>\n                (\\<lambda>_. let x = l ! i in f x s))\n            s\\<rbrakk>\n       \\<Longrightarrow> nfoldli (drop n l) c f s =\n                         nfoldli [n..<length l] c\n                          (\\<lambda>i s.\n                              ASSERT (i < length l) \\<bind>\n                              (\\<lambda>_. let x = l ! i in f x s))\n                          s", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n s.\n       \\<lbrakk>k \\<le> n; n < length l;\n        \\<And>s.\n           nfoldli (drop (Suc n) l) c f s =\n           nfoldli [Suc n..<length l] c\n            (\\<lambda>i s.\n                ASSERT (i < length l) \\<bind>\n                (\\<lambda>_. let x = l ! i in f x s))\n            s\\<rbrakk>\n       \\<Longrightarrow> nfoldli (drop n l) c f s =\n                         nfoldli [n..<length l] c\n                          (\\<lambda>i s.\n                              ASSERT (i < length l) \\<bind>\n                              (\\<lambda>_. let x = l ! i in f x s))\n                          s", "case (step k)"], ["proof (state)\nthis:\n  k \\<le> k\n  k < length l\n  nfoldli (drop (Suc k) l) c f ?s =\n  nfoldli [Suc k..<length l] c\n   (\\<lambda>i s.\n       ASSERT (i < length l) \\<bind> (\\<lambda>_. let x = l ! i in f x s))\n   ?s\n\ngoal (1 subgoal):\n 1. \\<And>n s.\n       \\<lbrakk>k \\<le> n; n < length l;\n        \\<And>s.\n           nfoldli (drop (Suc n) l) c f s =\n           nfoldli [Suc n..<length l] c\n            (\\<lambda>i s.\n                ASSERT (i < length l) \\<bind>\n                (\\<lambda>_. let x = l ! i in f x s))\n            s\\<rbrakk>\n       \\<Longrightarrow> nfoldli (drop n l) c f s =\n                         nfoldli [n..<length l] c\n                          (\\<lambda>i s.\n                              ASSERT (i < length l) \\<bind>\n                              (\\<lambda>_. let x = l ! i in f x s))\n                          s", "from step.hyps"], ["proof (chain)\npicking this:\n  k \\<le> k\n  k < length l", "have 1: \"drop k l = l!k # drop (Suc k) l\""], ["proof (prove)\nusing this:\n  k \\<le> k\n  k < length l\n\ngoal (1 subgoal):\n 1. drop k l = l ! k # drop (Suc k) l", "by (auto simp: Cons_nth_drop_Suc)"], ["proof (state)\nthis:\n  drop k l = l ! k # drop (Suc k) l\n\ngoal (1 subgoal):\n 1. \\<And>n s.\n       \\<lbrakk>k \\<le> n; n < length l;\n        \\<And>s.\n           nfoldli (drop (Suc n) l) c f s =\n           nfoldli [Suc n..<length l] c\n            (\\<lambda>i s.\n                ASSERT (i < length l) \\<bind>\n                (\\<lambda>_. let x = l ! i in f x s))\n            s\\<rbrakk>\n       \\<Longrightarrow> nfoldli (drop n l) c f s =\n                         nfoldli [n..<length l] c\n                          (\\<lambda>i s.\n                              ASSERT (i < length l) \\<bind>\n                              (\\<lambda>_. let x = l ! i in f x s))\n                          s", "from step.hyps"], ["proof (chain)\npicking this:\n  k \\<le> k\n  k < length l", "have 2: \"[k..<length l] = k#[Suc k..<length l]\""], ["proof (prove)\nusing this:\n  k \\<le> k\n  k < length l\n\ngoal (1 subgoal):\n 1. [k..<length l] = k # [Suc k..<length l]", "by (auto simp: upt_conv_Cons)"], ["proof (state)\nthis:\n  [k..<length l] = k # [Suc k..<length l]\n\ngoal (1 subgoal):\n 1. \\<And>n s.\n       \\<lbrakk>k \\<le> n; n < length l;\n        \\<And>s.\n           nfoldli (drop (Suc n) l) c f s =\n           nfoldli [Suc n..<length l] c\n            (\\<lambda>i s.\n                ASSERT (i < length l) \\<bind>\n                (\\<lambda>_. let x = l ! i in f x s))\n            s\\<rbrakk>\n       \\<Longrightarrow> nfoldli (drop n l) c f s =\n                         nfoldli [n..<length l] c\n                          (\\<lambda>i s.\n                              ASSERT (i < length l) \\<bind>\n                              (\\<lambda>_. let x = l ! i in f x s))\n                          s", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. nfoldli (drop k l) c f s =\n    nfoldli [k..<length l] c\n     (\\<lambda>i s.\n         ASSERT (i < length l) \\<bind> (\\<lambda>_. let x = l ! i in f x s))\n     s", "unfolding 1 2"], ["proof (prove)\ngoal (1 subgoal):\n 1. nfoldli (l ! k # drop (Suc k) l) c f s =\n    nfoldli (k # [Suc k..<length l]) c\n     (\\<lambda>i s.\n         ASSERT (i < length l) \\<bind> (\\<lambda>_. let x = l ! i in f x s))\n     s", "by (auto simp: step.IH[abs_def] step.hyps)"], ["proof (state)\nthis:\n  nfoldli (drop k l) c f s =\n  nfoldli [k..<length l] c\n   (\\<lambda>i s.\n       ASSERT (i < length l) \\<bind> (\\<lambda>_. let x = l ! i in f x s))\n   s\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  nfoldli (drop k l) c f s =\n  nfoldli [k..<length l] c\n   (\\<lambda>i s.\n       ASSERT (i < length l) \\<bind> (\\<lambda>_. let x = l ! i in f x s))\n   s\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma nfoldli_by_idx: \n  \"nfoldli l c f s = nfoldli [0..<length l] c (\\<lambda>i s. do {\n    ASSERT (i<length l);\n    let x = l!i;\n    f x s\n  }) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nfoldli l c f s =\n    nfoldli [0..<length l] c\n     (\\<lambda>i s.\n         ASSERT (i < length l) \\<bind> (\\<lambda>_. let x = l ! i in f x s))\n     s", "using nfoldli_by_idx_gen[of 0]"], ["proof (prove)\nusing this:\n  nfoldli (drop 0 ?l) ?c ?f ?s =\n  nfoldli [0..<length ?l] ?c\n   (\\<lambda>i s.\n       ASSERT (i < length ?l) \\<bind>\n       (\\<lambda>_. let x = ?l ! i in ?f x s))\n   ?s\n\ngoal (1 subgoal):\n 1. nfoldli l c f s =\n    nfoldli [0..<length l] c\n     (\\<lambda>i s.\n         ASSERT (i < length l) \\<bind> (\\<lambda>_. let x = l ! i in f x s))\n     s", "by auto"], ["", "lemma nfoldli_map_inv:\n  assumes \"inj g\"\n  shows \"nfoldli l c f = nfoldli (map g l) c (\\<lambda>x s. f (the_inv g x) s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nfoldli l c f = nfoldli (map g l) c (\\<lambda>x. f (the_inv g x))", "using assms"], ["proof (prove)\nusing this:\n  inj g\n\ngoal (1 subgoal):\n 1. nfoldli l c f = nfoldli (map g l) c (\\<lambda>x. f (the_inv g x))", "apply (induction l)"], ["proof (prove)\ngoal (2 subgoals):\n 1. inj g \\<Longrightarrow>\n    nfoldli [] c f = nfoldli (map g []) c (\\<lambda>x. f (the_inv g x))\n 2. \\<And>a l.\n       \\<lbrakk>inj g \\<Longrightarrow>\n                nfoldli l c f =\n                nfoldli (map g l) c (\\<lambda>x. f (the_inv g x));\n        inj g\\<rbrakk>\n       \\<Longrightarrow> nfoldli (a # l) c f =\n                         nfoldli (map g (a # l)) c\n                          (\\<lambda>x. f (the_inv g x))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. inj g \\<Longrightarrow>\n    nfoldli [] c f = nfoldli (map g []) c (\\<lambda>x. f (the_inv g x))", "by auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a l.\n       \\<lbrakk>inj g \\<Longrightarrow>\n                nfoldli l c f =\n                nfoldli (map g l) c (\\<lambda>x. f (the_inv g x));\n        inj g\\<rbrakk>\n       \\<Longrightarrow> nfoldli (a # l) c f =\n                         nfoldli (map g (a # l)) c\n                          (\\<lambda>x. f (the_inv g x))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>inj g \\<Longrightarrow>\n             nfoldli l_ c f =\n             nfoldli (map g l_) c (\\<lambda>x. f (the_inv g x));\n     inj g\\<rbrakk>\n    \\<Longrightarrow> nfoldli (a_ # l_) c f =\n                      nfoldli (map g (a_ # l_)) c\n                       (\\<lambda>x. f (the_inv g x))", "by (auto simp: the_inv_f_f)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma nfoldli_shift:\n  fixes ofs :: nat \n  shows \"nfoldli l c f = nfoldli (map (\\<lambda>i. i+ofs) l) c (\\<lambda>x s. do {ASSERT (x\\<ge>ofs); f (x - ofs) s})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nfoldli l c f =\n    nfoldli (map (\\<lambda>i. i + ofs) l) c\n     (\\<lambda>x s.\n         ASSERT (ofs \\<le> x) \\<bind> (\\<lambda>_. f (x - ofs) s))", "by (induction l) auto"], ["", "lemma nfoldli_foreach_shift: \n  shows \"nfoldli [a..<b] c f = nfoldli [a+ofs..<b+ofs] c (\\<lambda>x s. do{ASSERT(x\\<ge>ofs); f (x - ofs) s})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nfoldli [a..<b] c f =\n    nfoldli [a + ofs..<b + ofs] c\n     (\\<lambda>x s.\n         ASSERT (ofs \\<le> x) \\<bind> (\\<lambda>_. f (x - ofs) s))", "using nfoldli_shift[of \"[a..<b]\" c f ofs]"], ["proof (prove)\nusing this:\n  nfoldli [a..<b] c f =\n  nfoldli (map (\\<lambda>i. i + ofs) [a..<b]) c\n   (\\<lambda>x s. ASSERT (ofs \\<le> x) \\<bind> (\\<lambda>_. f (x - ofs) s))\n\ngoal (1 subgoal):\n 1. nfoldli [a..<b] c f =\n    nfoldli [a + ofs..<b + ofs] c\n     (\\<lambda>x s.\n         ASSERT (ofs \\<le> x) \\<bind> (\\<lambda>_. f (x - ofs) s))", "by (auto simp: map_add_upt')"], ["", "(* TODO: Move. Probably we have this already with FOREACH, or iterator! *)"], ["", "lemma member_by_nfoldli: \"nfoldli l (\\<lambda>f. \\<not>f) (\\<lambda>y _. RETURN (y=x)) False \\<le> SPEC (\\<lambda>r. r \\<longleftrightarrow> x\\<in>set l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nfoldli l Not (\\<lambda>y _. RETURN (y = x)) False\n    \\<le> SPEC (\\<lambda>r. r = (x \\<in> set l))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. nfoldli l Not (\\<lambda>y _. RETURN (y = x)) False\n    \\<le> SPEC (\\<lambda>r. r = (x \\<in> set l))", "have \"nfoldli l (\\<lambda>f. \\<not>f) (\\<lambda>y _. RETURN (y=x)) s \\<le> SPEC (\\<lambda>r. r \\<longleftrightarrow> s \\<or> x\\<in>set l)\" for s"], ["proof (prove)\ngoal (1 subgoal):\n 1. nfoldli l Not (\\<lambda>y _. RETURN (y = x)) s\n    \\<le> SPEC (\\<lambda>r. r = (s \\<or> x \\<in> set l))", "apply (induction l arbitrary: s)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s.\n       nfoldli [] Not (\\<lambda>y _. RETURN (y = x)) s\n       \\<le> SPEC (\\<lambda>r. r = (s \\<or> x \\<in> set []))\n 2. \\<And>a l s.\n       (\\<And>s.\n           nfoldli l Not (\\<lambda>y _. RETURN (y = x)) s\n           \\<le> SPEC\n                  (\\<lambda>r.\n                      r = (s \\<or> x \\<in> set l))) \\<Longrightarrow>\n       nfoldli (a # l) Not (\\<lambda>y _. RETURN (y = x)) s\n       \\<le> SPEC (\\<lambda>r. r = (s \\<or> x \\<in> set (a # l)))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. nfoldli [] Not (\\<lambda>y _. RETURN (y = x)) s_\n    \\<le> SPEC (\\<lambda>r. r = (s_ \\<or> x \\<in> set []))", "by auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a l s.\n       (\\<And>s.\n           nfoldli l Not (\\<lambda>y _. RETURN (y = x)) s\n           \\<le> SPEC\n                  (\\<lambda>r.\n                      r = (s \\<or> x \\<in> set l))) \\<Longrightarrow>\n       nfoldli (a # l) Not (\\<lambda>y _. RETURN (y = x)) s\n       \\<le> SPEC (\\<lambda>r. r = (s \\<or> x \\<in> set (a # l)))", "subgoal for a l s"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>s.\n        nfoldli l Not (\\<lambda>y _. RETURN (y = x)) s\n        \\<le> SPEC\n               (\\<lambda>r. r = (s \\<or> x \\<in> set l))) \\<Longrightarrow>\n    nfoldli (a # l) Not (\\<lambda>y _. RETURN (y = x)) s\n    \\<le> SPEC (\\<lambda>r. r = (s \\<or> x \\<in> set (a # l)))", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>s.\n                nfoldli l Not (\\<lambda>y _. RETURN (y = x)) s\n                \\<le> RES {s \\<or> x \\<in> set l};\n     \\<not> s\\<rbrakk>\n    \\<Longrightarrow> nfoldli l Not (\\<lambda>y _. RETURN (y = x)) (a = x)\n                      \\<le> RES {x = a \\<or> x \\<in> set l}", "apply (rule order_trans)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>s.\n                nfoldli l Not (\\<lambda>y _. RETURN (y = x)) s\n                \\<le> RES {s \\<or> x \\<in> set l};\n     \\<not> s\\<rbrakk>\n    \\<Longrightarrow> nfoldli l Not (\\<lambda>y _. RETURN (y = x)) (a = x)\n                      \\<le> ?y7\n 2. \\<lbrakk>\\<And>s.\n                nfoldli l Not (\\<lambda>y _. RETURN (y = x)) s\n                \\<le> RES {s \\<or> x \\<in> set l};\n     \\<not> s\\<rbrakk>\n    \\<Longrightarrow> ?y7 \\<le> RES {x = a \\<or> x \\<in> set l}", "apply rprems"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>s.\n                nfoldli l Not (\\<lambda>y _. RETURN (y = x)) s\n                \\<le> RES {s \\<or> x \\<in> set l};\n     \\<not> s\\<rbrakk>\n    \\<Longrightarrow> RES {a = x \\<or> x \\<in> set l}\n                      \\<le> RES {x = a \\<or> x \\<in> set l}", "by auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  nfoldli l Not (\\<lambda>y _. RETURN (y = x)) ?s\n  \\<le> SPEC (\\<lambda>r. r = (?s \\<or> x \\<in> set l))\n\ngoal (1 subgoal):\n 1. nfoldli l Not (\\<lambda>y _. RETURN (y = x)) False\n    \\<le> SPEC (\\<lambda>r. r = (x \\<in> set l))", "from this[of False]"], ["proof (chain)\npicking this:\n  nfoldli l Not (\\<lambda>y _. RETURN (y = x)) False\n  \\<le> SPEC (\\<lambda>r. r = (False \\<or> x \\<in> set l))", "show ?thesis"], ["proof (prove)\nusing this:\n  nfoldli l Not (\\<lambda>y _. RETURN (y = x)) False\n  \\<le> SPEC (\\<lambda>r. r = (False \\<or> x \\<in> set l))\n\ngoal (1 subgoal):\n 1. nfoldli l Not (\\<lambda>y _. RETURN (y = x)) False\n    \\<le> SPEC (\\<lambda>r. r = (x \\<in> set l))", "by auto"], ["proof (state)\nthis:\n  nfoldli l Not (\\<lambda>y _. RETURN (y = x)) False\n  \\<le> SPEC (\\<lambda>r. r = (x \\<in> set l))\n\ngoal:\nNo subgoals!", "qed"], ["", "definition sum_impl :: \"('a \\<Rightarrow> 'b::comm_monoid_add nres) \\<Rightarrow> 'a set \\<Rightarrow> 'b nres\" where\n  \"sum_impl g S \\<equiv> FOREACH S (\\<lambda>x a. do { b \\<leftarrow> g x; RETURN (a+b)}) 0\""], ["", "lemma sum_impl_correct: \n  assumes [simp]: \"finite S\"\n  assumes [refine_vcg]: \"\\<And>x. x\\<in>S \\<Longrightarrow> gi x \\<le> SPEC (\\<lambda>r. r=g x)\"\n  shows \"sum_impl gi S \\<le> SPEC (\\<lambda>r. r=sum g S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_impl gi S \\<le> SPEC (\\<lambda>r. r = sum g S)", "unfolding sum_impl_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. FOREACH S (\\<lambda>x a. gi x \\<bind> (\\<lambda>b. RETURN (a + b)))\n     (0::'b)\n    \\<le> SPEC (\\<lambda>r. r = sum g S)", "apply (refine_vcg FOREACH_rule[where I=\"\\<lambda>it a. a = sum g (S - it)\"])"], ["proof (prove)\ngoal (5 subgoals):\n 1. finite S\n 2. (0::'b) = sum g (S - S)\n 3. \\<And>x it \\<sigma>.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> S;\n        \\<sigma> = sum g (S - it)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> S\n 4. \\<And>x it \\<sigma> xa.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> S; \\<sigma> = sum g (S - it);\n        xa = g x\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> + xa = sum g (S - (it - {x}))\n 5. \\<And>\\<sigma>.\n       \\<sigma> = sum g (S - {}) \\<Longrightarrow> \\<sigma> = sum g S", "apply (auto simp: it_step_insert_iff algebra_simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"]]}