{"file_name": "/home/qj213/afp-2021-10-22/thys/Refine_Monadic/Refine_Transfer.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Refine_Monadic", "problem_names": ["lemma nres_of_simps[simp]:\n  \"nres_of dSUCCEED = SUCCEED\"\n  \"nres_of dFAIL = FAIL\"\n  \"nres_of (dRETURN x) = RETURN x\"", "lemma nres_of_mono: \"mono nres_of\"", "lemma nres_transfer:\n  \"nres_of dSUCCEED = SUCCEED\"\n  \"nres_of dFAIL = FAIL\"\n  \"nres_of a \\<le> nres_of b \\<longleftrightarrow> a\\<le>b\"\n  \"nres_of a < nres_of b \\<longleftrightarrow> a<b\"\n  \"is_chain A \\<Longrightarrow> nres_of (Sup A) = Sup (nres_of`A)\"\n  \"is_chain A \\<Longrightarrow> nres_of (Inf A) = Inf (nres_of`A)\"", "lemma nres_correctD:\n  assumes \"nres_of S \\<le> SPEC \\<Phi>\"\n  shows \n  \"S=dRETURN x \\<Longrightarrow> \\<Phi> x\"\n  \"S\\<noteq>dFAIL\"", "lemma nres_of_transfer[refine_transfer]: \"nres_of x \\<le> nres_of x\"", "lemma det_FAIL[refine_transfer]: \"nres_of (dFAIL) \\<le> FAIL\"", "lemma det_SUCCEED[refine_transfer]: \"nres_of (dSUCCEED) \\<le> SUCCEED\"", "lemma det_SPEC: \"\\<Phi> x \\<Longrightarrow> nres_of (dRETURN x) \\<le> SPEC \\<Phi>\"", "lemma det_RETURN[refine_transfer]: \n  \"nres_of (dRETURN x) \\<le> RETURN x\"", "lemma det_bind[refine_transfer]:\n  assumes \"nres_of m \\<le> M\"\n  assumes \"\\<And>x. nres_of (f x) \\<le> F x\"\n  shows \"nres_of (dbind m f) \\<le> bind M F\"", "lemma plain_RETURN[refine_transfer]: \"RETURN a \\<le> RETURN a\"", "lemma plain_bind[refine_transfer]: \n  \"\\<lbrakk>RETURN x \\<le> M; \\<And>x. RETURN (f x) \\<le> F x\\<rbrakk> \\<Longrightarrow> RETURN (Let x f) \\<le> bind M F\"", "lemma the_resI:\n  assumes \"nres_of S \\<le> S'\"\n  assumes \"S \\<noteq> dSUCCEED\"\n  shows \"RETURN (the_res S) \\<le> S'\"", "lemma detTAGI: \"x = detTAG x\"", "lemma autoref_detI:\n  assumes \"(b,a)\\<in>\\<langle>R\\<rangle>nres_rel\"\n  assumes \"RETURN c \\<le> b\"\n  assumes \"c = detTAG d\"\n  shows \"(RETURN d, a)\\<in>\\<langle>R\\<rangle>nres_rel\"", "lemma dres_nres_rel_def: \"\\<langle>R\\<rangle>dres_nres_rel \\<equiv> {(c,a). nres_of c \\<le> \\<Down> R a}\"", "lemma dres_nres_relI[intro?]: \"nres_of c \\<le> \\<Down> R a \\<Longrightarrow> (c,a)\\<in>\\<langle>R\\<rangle>dres_nres_rel\"", "lemma dres_nres_relD: \"(c,a)\\<in>\\<langle>R\\<rangle>dres_nres_rel \\<Longrightarrow> nres_of c \\<le> \\<Down> R a\"", "lemma dres_nres_rel_as_br_conv: \n  \"\\<langle>R\\<rangle>dres_nres_rel = br nres_of (\\<lambda>_. True) O \\<langle>R\\<rangle>nres_rel\"", "lemma plain_nres_rel_def: \"\\<langle>R\\<rangle>plain_nres_rel \\<equiv> {(c,a). RETURN c \\<le> \\<Down> R a}\"", "lemma plain_nres_relI[intro?]: \"RETURN c \\<le> \\<Down> R a \\<Longrightarrow> (c,a)\\<in>\\<langle>R\\<rangle>plain_nres_rel\"", "lemma plain_nres_relD: \"(c,a)\\<in>\\<langle>R\\<rangle>plain_nres_rel \\<Longrightarrow> RETURN c \\<le> \\<Down> R a\"", "lemma plain_nres_rel_as_br_conv: \n  \"\\<langle>R\\<rangle>plain_nres_rel = br RETURN (\\<lambda>_. True) O \\<langle>R\\<rangle>nres_rel\"", "lemma dres_unit_simps[refine_transfer_post_simp]:\n  \"dbind (dRETURN (u::unit)) f = f ()\"", "lemma Let_dRETURN_simp[refine_transfer_post_simp]:\n  \"Let m dRETURN = dRETURN m\"", "lemmas [refine_transfer_post_simp] = dres_monad_laws"], "translations": [["", "lemma nres_of_simps[simp]:\n  \"nres_of dSUCCEED = SUCCEED\"\n  \"nres_of dFAIL = FAIL\"\n  \"nres_of (dRETURN x) = RETURN x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nres_of dSUCCEED = SUCCEED &&&\n    nres_of dFAIL = FAIL &&& nres_of (dRETURN x) = RETURN x", "apply -"], ["proof (prove)\ngoal (3 subgoals):\n 1. nres_of dSUCCEED = SUCCEED\n 2. nres_of dFAIL = FAIL\n 3. nres_of (dRETURN x) = RETURN x", "unfolding nres_of_def bot_dres_def top_dres_def"], ["proof (prove)\ngoal (3 subgoals):\n 1. (case dSUCCEEDi of dSUCCEEDi \\<Rightarrow> SUCCEED\n     | dFAILi \\<Rightarrow> FAIL | dRETURN x \\<Rightarrow> RETURN x) =\n    SUCCEED\n 2. (case dFAILi of dSUCCEEDi \\<Rightarrow> SUCCEED\n     | dFAILi \\<Rightarrow> FAIL | dRETURN x \\<Rightarrow> RETURN x) =\n    FAIL\n 3. (case dRETURN x of dSUCCEEDi \\<Rightarrow> SUCCEED\n     | dFAILi \\<Rightarrow> FAIL | dRETURN x \\<Rightarrow> RETURN x) =\n    RETURN x", "by (auto simp del: dres_internal_simps)"], ["", "lemma nres_of_mono: \"mono nres_of\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono nres_of", "apply (rule)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y. x \\<le> y \\<Longrightarrow> nres_of x \\<le> nres_of y", "apply (case_tac x, simp_all, case_tac y, simp_all)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma nres_transfer:\n  \"nres_of dSUCCEED = SUCCEED\"\n  \"nres_of dFAIL = FAIL\"\n  \"nres_of a \\<le> nres_of b \\<longleftrightarrow> a\\<le>b\"\n  \"nres_of a < nres_of b \\<longleftrightarrow> a<b\"\n  \"is_chain A \\<Longrightarrow> nres_of (Sup A) = Sup (nres_of`A)\"\n  \"is_chain A \\<Longrightarrow> nres_of (Inf A) = Inf (nres_of`A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (nres_of dSUCCEED = SUCCEED &&&\n     nres_of dFAIL = FAIL &&& (nres_of a \\<le> nres_of b) = (a \\<le> b)) &&&\n    (nres_of a < nres_of b) = (a < b) &&&\n    (is_chain A \\<Longrightarrow> nres_of (Sup A) = Sup (nres_of ` A)) &&&\n    (is_chain A \\<Longrightarrow> nres_of (Inf A) = Inf (nres_of ` A))", "apply simp_all"], ["proof (prove)\ngoal (4 subgoals):\n 1. (nres_of a \\<le> nres_of b) = (a \\<le> b)\n 2. (nres_of a < nres_of b) = (a < b)\n 3. is_chain A \\<Longrightarrow> nres_of (Sup A) = Sup (nres_of ` A)\n 4. is_chain A \\<Longrightarrow> nres_of (Inf A) = Inf (nres_of ` A)", "apply (case_tac a, simp_all, case_tac [!] b, simp_all) [1]"], ["proof (prove)\ngoal (3 subgoals):\n 1. (nres_of a < nres_of b) = (a < b)\n 2. is_chain A \\<Longrightarrow> nres_of (Sup A) = Sup (nres_of ` A)\n 3. is_chain A \\<Longrightarrow> nres_of (Inf A) = Inf (nres_of ` A)", "apply (simp add: less_le)"], ["proof (prove)\ngoal (3 subgoals):\n 1. (nres_of a \\<le> nres_of b \\<and> nres_of a \\<noteq> nres_of b) =\n    (a \\<le> b \\<and> a \\<noteq> b)\n 2. is_chain A \\<Longrightarrow> nres_of (Sup A) = Sup (nres_of ` A)\n 3. is_chain A \\<Longrightarrow> nres_of (Inf A) = Inf (nres_of ` A)", "apply (case_tac a, simp_all, case_tac [!] b, simp_all) [1]"], ["proof (prove)\ngoal (2 subgoals):\n 1. is_chain A \\<Longrightarrow> nres_of (Sup A) = Sup (nres_of ` A)\n 2. is_chain A \\<Longrightarrow> nres_of (Inf A) = Inf (nres_of ` A)", "apply (erule dres_Sup_chain_cases)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>A \\<subseteq> {dSUCCEED}; Sup A = dSUCCEED\\<rbrakk>\n    \\<Longrightarrow> nres_of (Sup A) = Sup (nres_of ` A)\n 2. \\<And>r.\n       \\<lbrakk>A \\<subseteq> {dSUCCEED, dRETURN r}; dRETURN r \\<in> A;\n        Sup A = dRETURN r\\<rbrakk>\n       \\<Longrightarrow> nres_of (Sup A) = Sup (nres_of ` A)\n 3. \\<lbrakk>dFAIL \\<in> A; Sup A = dFAIL\\<rbrakk>\n    \\<Longrightarrow> nres_of (Sup A) = Sup (nres_of ` A)\n 4. is_chain A \\<Longrightarrow> nres_of (Inf A) = Inf (nres_of ` A)", "apply (cases \"A={}\")"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>A \\<subseteq> {dSUCCEED}; Sup A = dSUCCEED; A = {}\\<rbrakk>\n    \\<Longrightarrow> nres_of (Sup A) = Sup (nres_of ` A)\n 2. \\<lbrakk>A \\<subseteq> {dSUCCEED}; Sup A = dSUCCEED;\n     A \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> nres_of (Sup A) = Sup (nres_of ` A)\n 3. \\<And>r.\n       \\<lbrakk>A \\<subseteq> {dSUCCEED, dRETURN r}; dRETURN r \\<in> A;\n        Sup A = dRETURN r\\<rbrakk>\n       \\<Longrightarrow> nres_of (Sup A) = Sup (nres_of ` A)\n 4. \\<lbrakk>dFAIL \\<in> A; Sup A = dFAIL\\<rbrakk>\n    \\<Longrightarrow> nres_of (Sup A) = Sup (nres_of ` A)\n 5. is_chain A \\<Longrightarrow> nres_of (Inf A) = Inf (nres_of ` A)", "apply auto []"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>A \\<subseteq> {dSUCCEED}; Sup A = dSUCCEED;\n     A \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> nres_of (Sup A) = Sup (nres_of ` A)\n 2. \\<And>r.\n       \\<lbrakk>A \\<subseteq> {dSUCCEED, dRETURN r}; dRETURN r \\<in> A;\n        Sup A = dRETURN r\\<rbrakk>\n       \\<Longrightarrow> nres_of (Sup A) = Sup (nres_of ` A)\n 3. \\<lbrakk>dFAIL \\<in> A; Sup A = dFAIL\\<rbrakk>\n    \\<Longrightarrow> nres_of (Sup A) = Sup (nres_of ` A)\n 4. is_chain A \\<Longrightarrow> nres_of (Inf A) = Inf (nres_of ` A)", "apply (subgoal_tac \"A={dSUCCEED}\", auto) []"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>r.\n       \\<lbrakk>A \\<subseteq> {dSUCCEED, dRETURN r}; dRETURN r \\<in> A;\n        Sup A = dRETURN r\\<rbrakk>\n       \\<Longrightarrow> nres_of (Sup A) = Sup (nres_of ` A)\n 2. \\<lbrakk>dFAIL \\<in> A; Sup A = dFAIL\\<rbrakk>\n    \\<Longrightarrow> nres_of (Sup A) = Sup (nres_of ` A)\n 3. is_chain A \\<Longrightarrow> nres_of (Inf A) = Inf (nres_of ` A)", "apply (case_tac \"A={dRETURN r}\")"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>r.\n       \\<lbrakk>A \\<subseteq> {dSUCCEED, dRETURN r}; dRETURN r \\<in> A;\n        Sup A = dRETURN r; A = {dRETURN r}\\<rbrakk>\n       \\<Longrightarrow> nres_of (Sup A) = Sup (nres_of ` A)\n 2. \\<And>r.\n       \\<lbrakk>A \\<subseteq> {dSUCCEED, dRETURN r}; dRETURN r \\<in> A;\n        Sup A = dRETURN r; A \\<noteq> {dRETURN r}\\<rbrakk>\n       \\<Longrightarrow> nres_of (Sup A) = Sup (nres_of ` A)\n 3. \\<lbrakk>dFAIL \\<in> A; Sup A = dFAIL\\<rbrakk>\n    \\<Longrightarrow> nres_of (Sup A) = Sup (nres_of ` A)\n 4. is_chain A \\<Longrightarrow> nres_of (Inf A) = Inf (nres_of ` A)", "apply auto []"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>r.\n       \\<lbrakk>A \\<subseteq> {dSUCCEED, dRETURN r}; dRETURN r \\<in> A;\n        Sup A = dRETURN r; A \\<noteq> {dRETURN r}\\<rbrakk>\n       \\<Longrightarrow> nres_of (Sup A) = Sup (nres_of ` A)\n 2. \\<lbrakk>dFAIL \\<in> A; Sup A = dFAIL\\<rbrakk>\n    \\<Longrightarrow> nres_of (Sup A) = Sup (nres_of ` A)\n 3. is_chain A \\<Longrightarrow> nres_of (Inf A) = Inf (nres_of ` A)", "apply (subgoal_tac \"A={dSUCCEED,dRETURN r}\", auto) []"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>dFAIL \\<in> A; Sup A = dFAIL\\<rbrakk>\n    \\<Longrightarrow> nres_of (Sup A) = Sup (nres_of ` A)\n 2. is_chain A \\<Longrightarrow> nres_of (Inf A) = Inf (nres_of ` A)", "apply (drule imageI[where f=nres_of])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>Sup A = dFAIL; nres_of dFAIL \\<in> nres_of ` A\\<rbrakk>\n    \\<Longrightarrow> nres_of (Sup A) = Sup (nres_of ` A)\n 2. is_chain A \\<Longrightarrow> nres_of (Inf A) = Inf (nres_of ` A)", "apply auto []"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_chain A \\<Longrightarrow> nres_of (Inf A) = Inf (nres_of ` A)", "apply (erule dres_Inf_chain_cases)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>A \\<subseteq> {dFAIL}; Inf A = dFAIL\\<rbrakk>\n    \\<Longrightarrow> nres_of (Inf A) = Inf (nres_of ` A)\n 2. \\<And>r.\n       \\<lbrakk>A \\<subseteq> {dFAIL, dRETURN r}; dRETURN r \\<in> A;\n        Inf A = dRETURN r\\<rbrakk>\n       \\<Longrightarrow> nres_of (Inf A) = Inf (nres_of ` A)\n 3. \\<lbrakk>dSUCCEED \\<in> A; Inf A = dSUCCEED\\<rbrakk>\n    \\<Longrightarrow> nres_of (Inf A) = Inf (nres_of ` A)", "apply (cases \"A={}\")"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>A \\<subseteq> {dFAIL}; Inf A = dFAIL; A = {}\\<rbrakk>\n    \\<Longrightarrow> nres_of (Inf A) = Inf (nres_of ` A)\n 2. \\<lbrakk>A \\<subseteq> {dFAIL}; Inf A = dFAIL; A \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> nres_of (Inf A) = Inf (nres_of ` A)\n 3. \\<And>r.\n       \\<lbrakk>A \\<subseteq> {dFAIL, dRETURN r}; dRETURN r \\<in> A;\n        Inf A = dRETURN r\\<rbrakk>\n       \\<Longrightarrow> nres_of (Inf A) = Inf (nres_of ` A)\n 4. \\<lbrakk>dSUCCEED \\<in> A; Inf A = dSUCCEED\\<rbrakk>\n    \\<Longrightarrow> nres_of (Inf A) = Inf (nres_of ` A)", "apply auto []"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>A \\<subseteq> {dFAIL}; Inf A = dFAIL; A \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> nres_of (Inf A) = Inf (nres_of ` A)\n 2. \\<And>r.\n       \\<lbrakk>A \\<subseteq> {dFAIL, dRETURN r}; dRETURN r \\<in> A;\n        Inf A = dRETURN r\\<rbrakk>\n       \\<Longrightarrow> nres_of (Inf A) = Inf (nres_of ` A)\n 3. \\<lbrakk>dSUCCEED \\<in> A; Inf A = dSUCCEED\\<rbrakk>\n    \\<Longrightarrow> nres_of (Inf A) = Inf (nres_of ` A)", "apply (subgoal_tac \"A={dFAIL}\", auto) []"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>r.\n       \\<lbrakk>A \\<subseteq> {dFAIL, dRETURN r}; dRETURN r \\<in> A;\n        Inf A = dRETURN r\\<rbrakk>\n       \\<Longrightarrow> nres_of (Inf A) = Inf (nres_of ` A)\n 2. \\<lbrakk>dSUCCEED \\<in> A; Inf A = dSUCCEED\\<rbrakk>\n    \\<Longrightarrow> nres_of (Inf A) = Inf (nres_of ` A)", "apply (case_tac \"A={dRETURN r}\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>r.\n       \\<lbrakk>A \\<subseteq> {dFAIL, dRETURN r}; dRETURN r \\<in> A;\n        Inf A = dRETURN r; A = {dRETURN r}\\<rbrakk>\n       \\<Longrightarrow> nres_of (Inf A) = Inf (nres_of ` A)\n 2. \\<And>r.\n       \\<lbrakk>A \\<subseteq> {dFAIL, dRETURN r}; dRETURN r \\<in> A;\n        Inf A = dRETURN r; A \\<noteq> {dRETURN r}\\<rbrakk>\n       \\<Longrightarrow> nres_of (Inf A) = Inf (nres_of ` A)\n 3. \\<lbrakk>dSUCCEED \\<in> A; Inf A = dSUCCEED\\<rbrakk>\n    \\<Longrightarrow> nres_of (Inf A) = Inf (nres_of ` A)", "apply auto []"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>r.\n       \\<lbrakk>A \\<subseteq> {dFAIL, dRETURN r}; dRETURN r \\<in> A;\n        Inf A = dRETURN r; A \\<noteq> {dRETURN r}\\<rbrakk>\n       \\<Longrightarrow> nres_of (Inf A) = Inf (nres_of ` A)\n 2. \\<lbrakk>dSUCCEED \\<in> A; Inf A = dSUCCEED\\<rbrakk>\n    \\<Longrightarrow> nres_of (Inf A) = Inf (nres_of ` A)", "apply (subgoal_tac \"A={dFAIL,dRETURN r}\", auto) []"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>dSUCCEED \\<in> A; Inf A = dSUCCEED\\<rbrakk>\n    \\<Longrightarrow> nres_of (Inf A) = Inf (nres_of ` A)", "apply (drule imageI[where f=nres_of])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Inf A = dSUCCEED; nres_of dSUCCEED \\<in> nres_of ` A\\<rbrakk>\n    \\<Longrightarrow> nres_of (Inf A) = Inf (nres_of ` A)", "apply (auto intro: bot_Inf [symmetric]) []"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma nres_correctD:\n  assumes \"nres_of S \\<le> SPEC \\<Phi>\"\n  shows \n  \"S=dRETURN x \\<Longrightarrow> \\<Phi> x\"\n  \"S\\<noteq>dFAIL\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (S = dRETURN x \\<Longrightarrow> \\<Phi> x) &&& S \\<noteq> dFAIL", "using assms"], ["proof (prove)\nusing this:\n  nres_of S \\<le> SPEC \\<Phi>\n\ngoal (1 subgoal):\n 1. (S = dRETURN x \\<Longrightarrow> \\<Phi> x) &&& S \\<noteq> dFAIL", "apply -"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>S = dRETURN x; nres_of S \\<le> SPEC \\<Phi>\\<rbrakk>\n    \\<Longrightarrow> \\<Phi> x\n 2. nres_of S \\<le> SPEC \\<Phi> \\<Longrightarrow> S \\<noteq> dFAIL", "apply (cases S, simp_all)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsubsection \\<open>Transfer Theorems Setup\\<close>"], ["", "interpretation dres: dist_transfer nres_of"], ["proof (prove)\ngoal (1 subgoal):\n 1. dist_transfer nres_of", "apply unfold_locales"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>A.\n       is_chain A \\<Longrightarrow> nres_of (Sup A) = Sup (nres_of ` A)", "apply (simp add: nres_transfer)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma nres_of_transfer[refine_transfer]: \"nres_of x \\<le> nres_of x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nres_of x \\<le> nres_of x", "by simp"], ["", "lemma det_FAIL[refine_transfer]: \"nres_of (dFAIL) \\<le> FAIL\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nres_of dFAIL \\<le> FAIL", "by auto"], ["", "lemma det_SUCCEED[refine_transfer]: \"nres_of (dSUCCEED) \\<le> SUCCEED\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nres_of dSUCCEED \\<le> SUCCEED", "by auto"], ["", "lemma det_SPEC: \"\\<Phi> x \\<Longrightarrow> nres_of (dRETURN x) \\<le> SPEC \\<Phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Phi> x \\<Longrightarrow> nres_of (dRETURN x) \\<le> SPEC \\<Phi>", "by simp"], ["", "lemma det_RETURN[refine_transfer]: \n  \"nres_of (dRETURN x) \\<le> RETURN x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nres_of (dRETURN x) \\<le> RETURN x", "by simp"], ["", "lemma det_bind[refine_transfer]:\n  assumes \"nres_of m \\<le> M\"\n  assumes \"\\<And>x. nres_of (f x) \\<le> F x\"\n  shows \"nres_of (dbind m f) \\<le> bind M F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nres_of (m \\<bind> f) \\<le> M \\<bind> F", "using assms"], ["proof (prove)\nusing this:\n  nres_of m \\<le> M\n  nres_of (f ?x) \\<le> F ?x\n\ngoal (1 subgoal):\n 1. nres_of (m \\<bind> f) \\<le> M \\<bind> F", "apply (cases m)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>nres_of m \\<le> M; \\<And>x. nres_of (f x) \\<le> F x;\n     m = dSUCCEED\\<rbrakk>\n    \\<Longrightarrow> nres_of (m \\<bind> f) \\<le> M \\<bind> F\n 2. \\<And>r.\n       \\<lbrakk>nres_of m \\<le> M; \\<And>x. nres_of (f x) \\<le> F x;\n        m = dRETURN r\\<rbrakk>\n       \\<Longrightarrow> nres_of (m \\<bind> f) \\<le> M \\<bind> F\n 3. \\<lbrakk>nres_of m \\<le> M; \\<And>x. nres_of (f x) \\<le> F x;\n     m = dFAIL\\<rbrakk>\n    \\<Longrightarrow> nres_of (m \\<bind> f) \\<le> M \\<bind> F", "apply (auto simp: pw_le_iff refine_pw_simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "interpretation det_assert: transfer_generic_Assert_remove \n  bind RETURN ASSERT ASSUME\n  nres_of"], ["proof (prove)\ngoal (1 subgoal):\n 1. transfer_generic_Assert_remove (\\<bind>) RETURN ASSERT ASSUME", "by unfold_locales"], ["", "interpretation det_while: transfer_WHILE\n  dbind dRETURN dWHILEIT dWHILEI dWHILET dWHILE \n  bind RETURN WHILEIT WHILEI WHILET WHILE nres_of"], ["proof (prove)\ngoal (1 subgoal):\n 1. transfer_WHILE (\\<bind>) dRETURN dWHILEIT dWHILEI dWHILET dWHILE\n     (\\<bind>) RETURN WHILEIT WHILEI WHILE\\<^sub>T WHILE nres_of", "apply unfold_locales"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>m M f F.\n       \\<lbrakk>nres_of m \\<le> M; \\<And>x. nres_of (f x) \\<le> F x\\<rbrakk>\n       \\<Longrightarrow> nres_of (m \\<bind> f) \\<le> M \\<bind> F\n 2. \\<And>x. nres_of (dRETURN x) \\<le> RETURN x", "apply (auto intro: det_bind)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*\ninterpretation det_foreach: \n  transfer_FOREACH nres_of dRETURN dbind \"case_dres True True\"\n  apply unfold_locales\n  apply (blast intro: det_bind)\n  apply simp\n  apply (case_tac m)\n  apply simp_all\n  done\n*)\n\n(* Done generally in RefineG_Transfer\nlemma det_rec_list[refine_transfer]:\n  assumes FN: \"\\<And>s. RETURN (fn s) \\<le> (fn' s)\"\n  assumes FC: \"\\<And>x l rec rec' s. \\<lbrakk> \\<And>s. RETURN (rec s) \\<le> (rec' s) \\<rbrakk> \n    \\<Longrightarrow> RETURN (fc x l rec s) \\<le> fc' x l rec' s\"\n  shows \"RETURN (rec_list fn fc l s) \\<le> rec_list fn' fc' l s\"\n  apply (induct l arbitrary: s)\n  apply (simp add: FN)\n  apply (simp add: FC)\n  done\n\nlemma det_rec_nat[refine_transfer]:\n  assumes FN: \"\\<And>s. RETURN (fn s) \\<le> (fn' s)\"\n  assumes FC: \"\\<And>n rec rec' s. \\<lbrakk> \\<And>s. RETURN (rec s) \\<le> (rec' s) \\<rbrakk> \n    \\<Longrightarrow> RETURN (fc x l rec s) \\<le> fc' x l rec' s\"\n  shows \"RETURN (rec_list fn fc l s) \\<le> rec_list fn' fc' l s\"\n  apply (induct l arbitrary: s)\n  apply (simp add: FN)\n  apply (simp add: FC)\n  done\n*)"], ["", "subsection \\<open>Transfer to Plain Function\\<close>"], ["", "interpretation plain: transfer RETURN"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma plain_RETURN[refine_transfer]: \"RETURN a \\<le> RETURN a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RETURN a \\<le> RETURN a", "by simp"], ["", "lemma plain_bind[refine_transfer]: \n  \"\\<lbrakk>RETURN x \\<le> M; \\<And>x. RETURN (f x) \\<le> F x\\<rbrakk> \\<Longrightarrow> RETURN (Let x f) \\<le> bind M F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>RETURN x \\<le> M; \\<And>x. RETURN (f x) \\<le> F x\\<rbrakk>\n    \\<Longrightarrow> RETURN (Let x f) \\<le> M \\<bind> F", "apply (erule order_trans[rotated,OF bind_mono(1)])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>\\<And>x. RETURN (f x) \\<le> F x;\n        RETURN xa \\<le> RETURN x\\<rbrakk>\n       \\<Longrightarrow> ?f1 xa \\<le> F xa\n 2. (\\<And>x. RETURN (f x) \\<le> F x) \\<Longrightarrow>\n    RETURN (Let x f) \\<le> RETURN x \\<bind> ?f1", "apply assumption"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x. RETURN (f x) \\<le> F x) \\<Longrightarrow>\n    RETURN (Let x f) \\<le> RETURN x \\<bind> (\\<lambda>x. RETURN (f x))", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "interpretation plain_assert: transfer_generic_Assert_remove \n  bind RETURN ASSERT ASSUME\n  RETURN"], ["proof (prove)\ngoal (1 subgoal):\n 1. transfer_generic_Assert_remove (\\<bind>) RETURN ASSERT ASSUME", "by unfold_locales"], ["", "(*\ninterpretation plain: transfer_FOREACH RETURN \"(\\<lambda>x. x)\" Let \"(\\<lambda>x. x)\"\n  apply (unfold_locales)\n  apply (erule plain_bind, assumption)\n  apply simp\n  apply simp\n  done\n*)"], ["", "subsection \\<open>Total correctness in deterministic monad\\<close>"], ["", "text \\<open>\n  Sometimes one cannot extract total correct programs to executable plain \n  Isabelle functions, for example, if the total correctness only holds for\n  certain preconditions. In those cases, one can still show\n  \\<open>RETURN (the_res S) \\<le> S'\\<close>. Here, \\<open>the_res\\<close> extracts\n  the result from a deterministic monad. As \\<open>the_res\\<close> is executable,\n  the above shows that \\<open>(the_res S)\\<close> is always a correct result.\n\\<close>"], ["", "fun the_res where \"the_res (dRETURN x) = x\""], ["", "text \\<open>The following lemma converts a proof-obligation\n  with result extraction to a transfer proof obligation,\n  and a proof obligation that the program yields not bottom.\n\n  Note that this rule has to be applied manually, as, otherwise,\n  it would interfere with the default setup, that tries to generate a\n  plain function.\n\\<close>"], ["", "lemma the_resI:\n  assumes \"nres_of S \\<le> S'\"\n  assumes \"S \\<noteq> dSUCCEED\"\n  shows \"RETURN (the_res S) \\<le> S'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RETURN (the_res S) \\<le> S'", "using assms"], ["proof (prove)\nusing this:\n  nres_of S \\<le> S'\n  S \\<noteq> dSUCCEED\n\ngoal (1 subgoal):\n 1. RETURN (the_res S) \\<le> S'", "by (cases S, simp_all)"], ["", "text \\<open>The following rule sets up a refinement goal, a transfer goal, and a \n  final optimization goal.\\<close>"], ["", "definition \"detTAG x \\<equiv> x\""], ["", "lemma detTAGI: \"x = detTAG x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = detTAG x", "unfolding detTAG_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. x = x", "by simp"], ["", "lemma autoref_detI:\n  assumes \"(b,a)\\<in>\\<langle>R\\<rangle>nres_rel\"\n  assumes \"RETURN c \\<le> b\"\n  assumes \"c = detTAG d\"\n  shows \"(RETURN d, a)\\<in>\\<langle>R\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (RETURN d, a) \\<in> \\<langle>R\\<rangle>nres_rel", "using assms"], ["proof (prove)\nusing this:\n  (b, a) \\<in> \\<langle>R\\<rangle>nres_rel\n  RETURN c \\<le> b\n  c = detTAG d\n\ngoal (1 subgoal):\n 1. (RETURN d, a) \\<in> \\<langle>R\\<rangle>nres_rel", "unfolding nres_rel_def detTAG_def"], ["proof (prove)\nusing this:\n  (b, a) \\<in> {(c, a). c \\<le> \\<Down> R a}\n  RETURN c \\<le> b\n  c = d\n\ngoal (1 subgoal):\n 1. (RETURN d, a) \\<in> {(c, a). c \\<le> \\<Down> R a}", "by simp"], ["", "subsection \\<open>Relator-Based Transfer\\<close>"], ["", "definition dres_nres_rel_internal_def: \n  \"dres_nres_rel R \\<equiv> {(c,a). nres_of c \\<le> \\<Down> R a}\""], ["", "lemma dres_nres_rel_def: \"\\<langle>R\\<rangle>dres_nres_rel \\<equiv> {(c,a). nres_of c \\<le> \\<Down> R a}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>R\\<rangle>dres_nres_rel \\<equiv>\n    {(c, a). nres_of c \\<le> \\<Down> R a}", "by (simp add: dres_nres_rel_internal_def relAPP_def)"], ["", "lemma dres_nres_relI[intro?]: \"nres_of c \\<le> \\<Down> R a \\<Longrightarrow> (c,a)\\<in>\\<langle>R\\<rangle>dres_nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nres_of c \\<le> \\<Down> R a \\<Longrightarrow>\n    (c, a) \\<in> \\<langle>R\\<rangle>dres_nres_rel", "by (simp add: dres_nres_rel_def)"], ["", "lemma dres_nres_relD: \"(c,a)\\<in>\\<langle>R\\<rangle>dres_nres_rel \\<Longrightarrow> nres_of c \\<le> \\<Down> R a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (c, a) \\<in> \\<langle>R\\<rangle>dres_nres_rel \\<Longrightarrow>\n    nres_of c \\<le> \\<Down> R a", "by (simp add: dres_nres_rel_def)"], ["", "lemma dres_nres_rel_as_br_conv: \n  \"\\<langle>R\\<rangle>dres_nres_rel = br nres_of (\\<lambda>_. True) O \\<langle>R\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>R\\<rangle>dres_nres_rel =\n    br nres_of (\\<lambda>_. True) O \\<langle>R\\<rangle>nres_rel", "unfolding dres_nres_rel_def br_def nres_rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {(c, a). nres_of c \\<le> \\<Down> R a} =\n    {(c, a). a = nres_of c \\<and> True} O {(c, a). c \\<le> \\<Down> R a}", "by auto"], ["", "definition plain_nres_rel_internal_def: \n  \"plain_nres_rel R \\<equiv> {(c,a). RETURN c \\<le> \\<Down> R a}\""], ["", "lemma plain_nres_rel_def: \"\\<langle>R\\<rangle>plain_nres_rel \\<equiv> {(c,a). RETURN c \\<le> \\<Down> R a}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>R\\<rangle>plain_nres_rel \\<equiv>\n    {(c, a). RETURN c \\<le> \\<Down> R a}", "by (simp add: plain_nres_rel_internal_def relAPP_def)"], ["", "lemma plain_nres_relI[intro?]: \"RETURN c \\<le> \\<Down> R a \\<Longrightarrow> (c,a)\\<in>\\<langle>R\\<rangle>plain_nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RETURN c \\<le> \\<Down> R a \\<Longrightarrow>\n    (c, a) \\<in> \\<langle>R\\<rangle>plain_nres_rel", "by (simp add: plain_nres_rel_def)"], ["", "lemma plain_nres_relD: \"(c,a)\\<in>\\<langle>R\\<rangle>plain_nres_rel \\<Longrightarrow> RETURN c \\<le> \\<Down> R a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (c, a) \\<in> \\<langle>R\\<rangle>plain_nres_rel \\<Longrightarrow>\n    RETURN c \\<le> \\<Down> R a", "by (simp add: plain_nres_rel_def)"], ["", "lemma plain_nres_rel_as_br_conv: \n  \"\\<langle>R\\<rangle>plain_nres_rel = br RETURN (\\<lambda>_. True) O \\<langle>R\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>R\\<rangle>plain_nres_rel =\n    br RETURN (\\<lambda>_. True) O \\<langle>R\\<rangle>nres_rel", "unfolding plain_nres_rel_def br_def nres_rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {(c, a). RETURN c \\<le> \\<Down> R a} =\n    {(c, a). a = RETURN c \\<and> True} O {(c, a). c \\<le> \\<Down> R a}", "by auto"], ["", "(* TODO: Refine_Transfer could be expressed also just as a \n    parametricity based transfer, and based on the same infrastructure\n    as autoref *)"], ["", "subsection \\<open>Post-Simplification Setup\\<close>"], ["", "lemma dres_unit_simps[refine_transfer_post_simp]:\n  \"dbind (dRETURN (u::unit)) f = f ()\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dRETURN u \\<bind> f = f ()", "by auto"], ["", "lemma Let_dRETURN_simp[refine_transfer_post_simp]:\n  \"Let m dRETURN = dRETURN m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Let m dRETURN = dRETURN m", "by auto"], ["", "lemmas [refine_transfer_post_simp] = dres_monad_laws"], ["", "end"]]}