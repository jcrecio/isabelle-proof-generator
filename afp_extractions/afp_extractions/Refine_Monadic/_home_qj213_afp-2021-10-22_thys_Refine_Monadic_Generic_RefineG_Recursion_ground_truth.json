{"file_name": "/home/qj213/afp-2021-10-22/thys/Refine_Monadic/Generic/RefineG_Recursion.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Refine_Monadic", "problem_names": ["lemma fp_compare:\n  \\<comment> \\<open>At any point, fixed points wrt.\\ different orderings are either equal, \n    or both bottom.\\<close>\n  assumes M1: \"flatf_mono b1 B\" and M2: \"flatf_mono b2 B\"\n  shows \"flatf_fp b1 B x = flatf_fp b2 B x \n    \\<or> (flatf_fp b1 B x = b1 \\<and> flatf_fp b2 B x = b2)\"", "lemma flat_ord_top[simp]: \"flat_ord b b x\"", "lemma lfp_gfp_compare:\n  \\<comment> \\<open>Least and greatest fixed point are either equal, or bot and top\\<close>\n  assumes MLE: \"flatf_mono_le B\" and MGE: \"flatf_mono_ge B\"\n  shows \"flatf_lfp B x = flatf_gfp B x \n    \\<or> (flatf_lfp B x = bot \\<and> flatf_gfp B x = top)\"", "lemma trimonoI[refine_mono]: \n  \"\\<lbrakk>flatf_mono_ge B; mono B\\<rbrakk> \\<Longrightarrow> trimono B\"", "lemma trimono_trigger: \"trimono B \\<Longrightarrow> trimono B\"", "lemma trimonoD_flatf_ge: \"trimono B \\<Longrightarrow> flatf_mono_ge B\"", "lemma trimonoD_mono: \"trimono B \\<Longrightarrow> mono B\"", "lemmas trimonoD = trimonoD_flatf_ge trimonoD_mono", "lemma trimono_alt: \n  \"trimono B \\<longleftrightarrow> (\\<forall>ord\\<in>fun_ord`triords. monotone ord ord B)\"", "lemma trimonoI': \n  assumes \"\\<And>ord. ord\\<in>triords \\<Longrightarrow> monotone (fun_ord ord) (fun_ord ord) B\"\n  shows \"trimono B\"", "lemma RECT_gfp_def: \"RECT B x = \n  (if (trimono B) then (gfp B x) else (top::'a::complete_lattice))\"", "lemma REC_unfold: \"trimono B \\<Longrightarrow> REC B = B (REC B)\"", "lemma RECT_unfold: \"\\<lbrakk>trimono B\\<rbrakk> \\<Longrightarrow> RECT B = B (RECT B)\"", "lemma REC_mono[refine_mono]:\n  assumes [simp]: \"trimono B\"\n  assumes LE: \"\\<And>F x. (B F x) \\<le> (B' F x)\"\n  shows \"(REC B x) \\<le> (REC B' x)\"", "lemma RECT_mono[refine_mono]:\n  assumes [simp]: \"trimono B'\"\n  assumes LE: \"\\<And>F x. flat_ge (B F x) (B' F x)\"\n  shows \"flat_ge (RECT B x) (RECT B' x)\"", "lemma REC_le_RECT: \"REC body x \\<le> RECT body x\"", "theorem lfp_induct_pointwise:\n  fixes a::'a\n  assumes ADM1: \"\\<And>a x. chain_admissible (\\<lambda>b. \\<forall>a x. pre a x \\<longrightarrow> post a x (b x))\"\n  assumes ADM2: \"\\<And>a x. pre a x \\<longrightarrow> post a x bot\"\n  assumes MONO: \"mono B\"\n  assumes P0: \"pre a x\"\n  assumes IS: \n    \"\\<And>f a x.\n        \\<lbrakk>\\<And>a' x'. pre a' x' \\<Longrightarrow> post a' x' (f x'); pre a x;\n         f \\<le> (lfp B)\\<rbrakk>\n        \\<Longrightarrow> post a x (B f x)\"\n  shows \"post a x (lfp B x)\"", "lemma REC_rule_arb:\n  fixes x::\"'x\" and arb::'arb\n  assumes M: \"trimono body\"\n  assumes I0: \"pre arb x\"\n  assumes IS: \"\\<And>f arb x. \\<lbrakk>\n    \\<And>arb' x. pre arb' x \\<Longrightarrow> f x \\<le> M arb' x; pre arb x; f \\<le> REC body\n  \\<rbrakk> \\<Longrightarrow> body f x \\<le> M arb x\"\n  shows \"REC body x \\<le> M arb x\"", "lemma RECT_rule_arb:\n  assumes M: \"trimono body\"\n  assumes WF: \"wf (V::('x\\<times>'x) set)\"\n  assumes I0: \"pre (arb::'arb) (x::'x)\"\n  assumes IS: \"\\<And>f arb x. \\<lbrakk> \n      \\<And>arb' x'. \\<lbrakk>pre arb' x'; (x',x)\\<in>V\\<rbrakk> \\<Longrightarrow> f x' \\<le> M arb' x'; \n      pre arb x;\n      RECT body = f\n    \\<rbrakk>  \\<Longrightarrow> body f x \\<le> M arb x\"\n  shows \"RECT body x \\<le> M arb x\"", "lemma REC_rule:\n  fixes x::\"'x\"\n  assumes M: \"trimono body\"\n  assumes I0: \"pre x\"\n  assumes IS: \"\\<And>f x. \\<lbrakk> \\<And>x. pre x \\<Longrightarrow> f x \\<le> M x; pre x; f \\<le> REC body \\<rbrakk> \n    \\<Longrightarrow> body f x \\<le> M x\"\n  shows \"REC body x \\<le> M x\"", "lemma RECT_rule:\n  assumes M: \"trimono body\"\n  assumes WF: \"wf (V::('x\\<times>'x) set)\"\n  assumes I0: \"pre (x::'x)\"\n  assumes IS: \"\\<And>f x. \\<lbrakk> \\<And>x'. \\<lbrakk>pre x'; (x',x)\\<in>V\\<rbrakk> \\<Longrightarrow> f x' \\<le> M x'; pre x; \n                        RECT body = f\n    \\<rbrakk> \\<Longrightarrow> body f x \\<le> M x\"\n  shows \"RECT body x \\<le> M x\"", "lemma REC_rule_arb2:\n  assumes M: \"trimono body\"\n  assumes I0: \"pre (arb::'arb) (arc::'arc) (x::'x)\"\n  assumes IS: \"\\<And>f arb arc x. \\<lbrakk> \n      \\<And>arb' arc' x'. \\<lbrakk>pre arb' arc' x' \\<rbrakk> \\<Longrightarrow> f x' \\<le> M arb' arc' x'; \n      pre arb arc x\n    \\<rbrakk>  \\<Longrightarrow> body f x \\<le> M arb arc x\"\n  shows \"REC body x \\<le> M arb arc x\"", "lemma REC_rule_arb3:\n  assumes M: \"trimono body\"\n  assumes I0: \"pre (arb::'arb) (arc::'arc) (ard::'ard) (x::'x)\"\n  assumes IS: \"\\<And>f arb arc ard x. \\<lbrakk> \n      \\<And>arb' arc' ard' x'. \\<lbrakk>pre arb' arc' ard' x'\\<rbrakk> \\<Longrightarrow> f x' \\<le> M arb' arc' ard' x';\n      pre arb arc ard x \n    \\<rbrakk>  \\<Longrightarrow> body f x \\<le> M arb arc ard x\"\n  shows \"REC body x \\<le> M arb arc ard x\"", "lemma RECT_rule_arb2:\n  assumes M: \"trimono body\"\n  assumes WF: \"wf (V::'x rel)\"\n  assumes I0: \"pre (arb::'arb) (arc::'arc) (x::'x)\"\n  assumes IS: \"\\<And>f arb arc x. \\<lbrakk> \n      \\<And>arb' arc' x'. \\<lbrakk>pre arb' arc' x'; (x',x)\\<in>V\\<rbrakk> \\<Longrightarrow> f x' \\<le> M arb' arc' x'; \n      pre arb arc x;\n      f \\<le> RECT body\n    \\<rbrakk>  \\<Longrightarrow> body f x \\<le> M arb arc x\"\n  shows \"RECT body x \\<le> M arb arc x\"", "lemma RECT_rule_arb3:\n  assumes M: \"trimono body\"\n  assumes WF: \"wf (V::'x rel)\"\n  assumes I0: \"pre (arb::'arb) (arc::'arc) (ard::'ard) (x::'x)\"\n  assumes IS: \"\\<And>f arb arc ard x. \\<lbrakk> \n      \\<And>arb' arc' ard' x'. \\<lbrakk>pre arb' arc' ard' x'; (x',x)\\<in>V\\<rbrakk> \\<Longrightarrow> f x' \\<le> M arb' arc' ard' x'; \n    pre arb arc ard x;\n    f \\<le> RECT body\n  \\<rbrakk>  \\<Longrightarrow> body f x \\<le> M arb arc ard x\"\n  shows \"RECT body x \\<le> M arb arc ard x\"", "lemma RECT_eq_REC: \n  \\<comment> \\<open>Partial and total correct recursion are equal if total \n    recursion does not fail.\\<close>\n  assumes NT: \"RECT body x \\<noteq> top\"\n  shows \"RECT body x = REC body x\"", "lemma RECT_eq_REC_tproof:\n  \\<comment> \\<open>Partial and total correct recursion are equal if we can provide a \n    termination proof.\\<close>\n  fixes a :: 'a\n  assumes M: \"trimono body\"\n  assumes WF: \"wf V\"\n  assumes I0: \"pre a x\"\n  assumes IS: \"\\<And>f arb x.\n          \\<lbrakk>\\<And>arb' x'. \\<lbrakk>pre arb' x'; (x', x) \\<in> V\\<rbrakk> \\<Longrightarrow> f x' \\<le> M arb' x'; \n            pre arb x; REC\\<^sub>T body = f\\<rbrakk>\n          \\<Longrightarrow> body f x \\<le> M arb x\"\n  assumes NT: \"M a x \\<noteq> top\"\n  shows \"RECT body x = REC body x \\<and> RECT body x \\<le> M a x\"", "lemma (in transfer) transfer_RECT'[refine_transfer]:\n  assumes REC_EQ: \"\\<And>x. fr x = b fr x\"\n  assumes REF: \"\\<And>F f x. \\<lbrakk>\\<And>x. \\<alpha> (f x) \\<le> F x \\<rbrakk> \\<Longrightarrow> \\<alpha> (b f x) \\<le> B F x\"\n  shows \"\\<alpha> (fr x) \\<le> RECT B x\"", "lemma (in ordered_transfer) transfer_RECT[refine_transfer]:\n  assumes REF: \"\\<And>F f x. \\<lbrakk>\\<And>x. \\<alpha> (f x) \\<le> F x \\<rbrakk> \\<Longrightarrow> \\<alpha> (b f x) \\<le> B F x\"\n  assumes M: \"trimono b\"\n  shows \"\\<alpha> (RECT b x) \\<le> RECT B x\"", "lemma (in dist_transfer) transfer_REC[refine_transfer]:\n  assumes REF: \"\\<And>F f x. \\<lbrakk>\\<And>x. \\<alpha> (f x) \\<le> F x \\<rbrakk> \\<Longrightarrow> \\<alpha> (b f x) \\<le> B F x\"\n  assumes M: \"trimono b\"\n  shows \"\\<alpha> (REC b x) \\<le> REC B x\"", "lemma RECT_transfer_rel:\n  assumes [simp]: \"trimono F\" \"trimono F'\"\n  assumes TR_top[simp]: \"\\<And>x. tr x top\"\n  assumes P_start[simp]: \"P x x'\"\n  assumes IS: \"\\<And>D D' x x'. \\<lbrakk> \\<And>x x'. P x x' \\<Longrightarrow> tr (D x) (D' x'); P x x'; RECT F = D \\<rbrakk> \\<Longrightarrow> tr (F D x) (F' D' x')\"\n  shows \"tr (RECT F x) (RECT F' x')\"", "lemma RECT_transfer_rel':\n  assumes [simp]: \"trimono F\" \"trimono F'\"\n  assumes TR_top[simp]: \"\\<And>x. tr x top\"\n  assumes P_start[simp]: \"P x x'\"\n  assumes IS: \"\\<And>D D' x x'. \\<lbrakk> \\<And>x x'. P x x' \\<Longrightarrow> tr (D x) (D' x'); P x x' \\<rbrakk> \\<Longrightarrow> tr (F D x) (F' D' x')\"\n  shows \"tr (RECT F x) (RECT F' x')\""], "translations": [["", "lemma fp_compare:\n  \\<comment> \\<open>At any point, fixed points wrt.\\ different orderings are either equal, \n    or both bottom.\\<close>\n  assumes M1: \"flatf_mono b1 B\" and M2: \"flatf_mono b2 B\"\n  shows \"flatf_fp b1 B x = flatf_fp b2 B x \n    \\<or> (flatf_fp b1 B x = b1 \\<and> flatf_fp b2 B x = b2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. flatf_fp b1 B x = flatf_fp b2 B x \\<or>\n    flatf_fp b1 B x = b1 \\<and> flatf_fp b2 B x = b2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. flatf_fp b1 B x = flatf_fp b2 B x \\<or>\n    flatf_fp b1 B x = b1 \\<and> flatf_fp b2 B x = b2", "note UNF1 = flatf_ord.fixp_unfold[OF M1, symmetric]"], ["proof (state)\nthis:\n  B (flatf_fp b1 B) = flatf_fp b1 B\n\ngoal (1 subgoal):\n 1. flatf_fp b1 B x = flatf_fp b2 B x \\<or>\n    flatf_fp b1 B x = b1 \\<and> flatf_fp b2 B x = b2", "note UNF2 = flatf_ord.fixp_unfold[OF M2, symmetric]"], ["proof (state)\nthis:\n  B (flatf_fp b2 B) = flatf_fp b2 B\n\ngoal (1 subgoal):\n 1. flatf_fp b1 B x = flatf_fp b2 B x \\<or>\n    flatf_fp b1 B x = b1 \\<and> flatf_fp b2 B x = b2", "from UNF1"], ["proof (chain)\npicking this:\n  B (flatf_fp b1 B) = flatf_fp b1 B", "have 1: \"flatf_ord b2 (B (flatf_fp b1 B)) (flatf_fp b1 B)\""], ["proof (prove)\nusing this:\n  B (flatf_fp b1 B) = flatf_fp b1 B\n\ngoal (1 subgoal):\n 1. flatf_ord b2 (B (flatf_fp b1 B)) (flatf_fp b1 B)", "by simp"], ["proof (state)\nthis:\n  flatf_ord b2 (B (flatf_fp b1 B)) (flatf_fp b1 B)\n\ngoal (1 subgoal):\n 1. flatf_fp b1 B x = flatf_fp b2 B x \\<or>\n    flatf_fp b1 B x = b1 \\<and> flatf_fp b2 B x = b2", "from UNF2"], ["proof (chain)\npicking this:\n  B (flatf_fp b2 B) = flatf_fp b2 B", "have 2: \"flatf_ord b1 (B (flatf_fp b2 B)) (flatf_fp b2 B)\""], ["proof (prove)\nusing this:\n  B (flatf_fp b2 B) = flatf_fp b2 B\n\ngoal (1 subgoal):\n 1. flatf_ord b1 (B (flatf_fp b2 B)) (flatf_fp b2 B)", "by simp"], ["proof (state)\nthis:\n  flatf_ord b1 (B (flatf_fp b2 B)) (flatf_fp b2 B)\n\ngoal (1 subgoal):\n 1. flatf_fp b1 B x = flatf_fp b2 B x \\<or>\n    flatf_fp b1 B x = b1 \\<and> flatf_fp b2 B x = b2", "from flatf_ord.fixp_lowerbound[OF M2 1] flatf_ord.fixp_lowerbound[OF M1 2]"], ["proof (chain)\npicking this:\n  flatf_ord b2 (flatf_fp b2 B) (flatf_fp b1 B)\n  flatf_ord b1 (flatf_fp b1 B) (flatf_fp b2 B)", "show ?thesis"], ["proof (prove)\nusing this:\n  flatf_ord b2 (flatf_fp b2 B) (flatf_fp b1 B)\n  flatf_ord b1 (flatf_fp b1 B) (flatf_fp b2 B)\n\ngoal (1 subgoal):\n 1. flatf_fp b1 B x = flatf_fp b2 B x \\<or>\n    flatf_fp b1 B x = b1 \\<and> flatf_fp b2 B x = b2", "unfolding fun_ord_def flat_ord_def"], ["proof (prove)\nusing this:\n  \\<forall>x.\n     ccpo.fixp (flatf_lub b2)\n      (\\<lambda>f g. \\<forall>x. f x = b2 \\<or> f x = g x) B x =\n     b2 \\<or>\n     ccpo.fixp (flatf_lub b2)\n      (\\<lambda>f g. \\<forall>x. f x = b2 \\<or> f x = g x) B x =\n     ccpo.fixp (flatf_lub b1)\n      (\\<lambda>f g. \\<forall>x. f x = b1 \\<or> f x = g x) B x\n  \\<forall>x.\n     ccpo.fixp (flatf_lub b1)\n      (\\<lambda>f g. \\<forall>x. f x = b1 \\<or> f x = g x) B x =\n     b1 \\<or>\n     ccpo.fixp (flatf_lub b1)\n      (\\<lambda>f g. \\<forall>x. f x = b1 \\<or> f x = g x) B x =\n     ccpo.fixp (flatf_lub b2)\n      (\\<lambda>f g. \\<forall>x. f x = b2 \\<or> f x = g x) B x\n\ngoal (1 subgoal):\n 1. ccpo.fixp (flatf_lub b1)\n     (\\<lambda>f g. \\<forall>x. f x = b1 \\<or> f x = g x) B x =\n    ccpo.fixp (flatf_lub b2)\n     (\\<lambda>f g. \\<forall>x. f x = b2 \\<or> f x = g x) B x \\<or>\n    ccpo.fixp (flatf_lub b1)\n     (\\<lambda>f g. \\<forall>x. f x = b1 \\<or> f x = g x) B x =\n    b1 \\<and>\n    ccpo.fixp (flatf_lub b2)\n     (\\<lambda>f g. \\<forall>x. f x = b2 \\<or> f x = g x) B x =\n    b2", "by auto"], ["proof (state)\nthis:\n  flatf_fp b1 B x = flatf_fp b2 B x \\<or>\n  flatf_fp b1 B x = b1 \\<and> flatf_fp b2 B x = b2\n\ngoal:\nNo subgoals!", "qed"], ["", "(* TODO: Move *)"], ["", "lemma flat_ord_top[simp]: \"flat_ord b b x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. flat_ord b b x", "by (simp add: flat_ord_def)"], ["", "(* TODO: Move to Domain.*)"], ["", "lemma lfp_gfp_compare:\n  \\<comment> \\<open>Least and greatest fixed point are either equal, or bot and top\\<close>\n  assumes MLE: \"flatf_mono_le B\" and MGE: \"flatf_mono_ge B\"\n  shows \"flatf_lfp B x = flatf_gfp B x \n    \\<or> (flatf_lfp B x = bot \\<and> flatf_gfp B x = top)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. flatf_lfp B x = flatf_gfp B x \\<or>\n    flatf_lfp B x = bot \\<and> flatf_gfp B x = top", "using fp_compare[OF MLE MGE]"], ["proof (prove)\nusing this:\n  flatf_lfp B ?x = flatf_gfp B ?x \\<or>\n  flatf_lfp B ?x = bot \\<and> flatf_gfp B ?x = top\n\ngoal (1 subgoal):\n 1. flatf_lfp B x = flatf_gfp B x \\<or>\n    flatf_lfp B x = bot \\<and> flatf_gfp B x = top", "."], ["", "(* TODO: Move to Domain *)"], ["", "definition trimono :: \"(('a \\<Rightarrow> 'b) \\<Rightarrow> 'a \\<Rightarrow> ('b::{bot,order,top})) \\<Rightarrow> bool\" \n  where \"trimono B \\<equiv> \\<^cancel>\\<open>flatf_mono_le B \\<and>\\<close> flatf_mono_ge B \\<and> mono B\""], ["", "lemma trimonoI[refine_mono]: \n  \"\\<lbrakk>flatf_mono_ge B; mono B\\<rbrakk> \\<Longrightarrow> trimono B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>monotone flatf_ge flatf_ge B; mono B\\<rbrakk>\n    \\<Longrightarrow> trimono B", "unfolding trimono_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>monotone flatf_ge flatf_ge B; mono B\\<rbrakk>\n    \\<Longrightarrow> monotone flatf_ge flatf_ge B \\<and> mono B", "by auto"], ["", "lemma trimono_trigger: \"trimono B \\<Longrightarrow> trimono B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trimono B \\<Longrightarrow> trimono B", "."], ["", "declaration \\<open>Refine_Mono_Prover.declare_mono_triggers @{thms trimono_trigger}\\<close>"], ["", "(*lemma trimonoD_flatf_le: \"trimono B \\<Longrightarrow> flatf_mono_le B\"\n  unfolding trimono_def by auto*)"], ["", "lemma trimonoD_flatf_ge: \"trimono B \\<Longrightarrow> flatf_mono_ge B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trimono B \\<Longrightarrow> monotone flatf_ge flatf_ge B", "unfolding trimono_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. monotone flatf_ge flatf_ge B \\<and> mono B \\<Longrightarrow>\n    monotone flatf_ge flatf_ge B", "by auto"], ["", "lemma trimonoD_mono: \"trimono B \\<Longrightarrow> mono B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trimono B \\<Longrightarrow> mono B", "unfolding trimono_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. monotone flatf_ge flatf_ge B \\<and> mono B \\<Longrightarrow> mono B", "by auto"], ["", "lemmas trimonoD = trimonoD_flatf_ge trimonoD_mono"], ["", "(* TODO: Optimize mono-prover to only do derivations once. \n  Will cause problem with higher-order unification on ord - variable! *)"], ["", "definition \"triords \\<equiv> {flat_ge,(\\<le>)}\""], ["", "lemma trimono_alt: \n  \"trimono B \\<longleftrightarrow> (\\<forall>ord\\<in>fun_ord`triords. monotone ord ord B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trimono B = (\\<forall>ord\\<in>fun_ord ` triords. monotone ord ord B)", "unfolding trimono_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (monotone flatf_ge flatf_ge B \\<and> mono B) =\n    (\\<forall>ord\\<in>fun_ord ` triords. monotone ord ord B)", "by (auto simp: ccpo_mono_simp[symmetric] triords_def \n    fun_ord_def[abs_def] le_fun_def[abs_def])"], ["", "lemma trimonoI': \n  assumes \"\\<And>ord. ord\\<in>triords \\<Longrightarrow> monotone (fun_ord ord) (fun_ord ord) B\"\n  shows \"trimono B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trimono B", "unfolding trimono_alt"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>ord\\<in>fun_ord ` triords. monotone ord ord B", "using assms"], ["proof (prove)\nusing this:\n  ?ord \\<in> triords \\<Longrightarrow>\n  monotone (fun_ord ?ord) (fun_ord ?ord) B\n\ngoal (1 subgoal):\n 1. \\<forall>ord\\<in>fun_ord ` triords. monotone ord ord B", "by blast"], ["", "(* TODO: Once complete_lattice and ccpo typeclass are unified,\n  we should also define a REC-combinator for ccpos! *)"], ["", "definition REC where \"REC B x \\<equiv> \n  if (trimono B) then (lfp B x) else (top::'a::complete_lattice)\""], ["", "definition RECT (\"REC\\<^sub>T\") where \"RECT B x \\<equiv> \n  if (trimono B) then (flatf_gfp B x) else (top::'a::complete_lattice)\""], ["", "lemma RECT_gfp_def: \"RECT B x = \n  (if (trimono B) then (gfp B x) else (top::'a::complete_lattice))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. REC\\<^sub>T B x = (if trimono B then gfp B x else top)", "unfolding RECT_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if trimono B then flatf_gfp B x else top) =\n    (if trimono B then gfp B x else top)", "by (auto simp: gfp_eq_flatf_gfp[OF trimonoD_flatf_ge trimonoD_mono])"], ["", "lemma REC_unfold: \"trimono B \\<Longrightarrow> REC B = B (REC B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trimono B \\<Longrightarrow> REC B = B (REC B)", "unfolding REC_def [abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. trimono B \\<Longrightarrow>\n    (\\<lambda>x. if trimono B then lfp B x else top) =\n    B (\\<lambda>x. if trimono B then lfp B x else top)", "by (simp add: lfp_unfold[OF trimonoD_mono, symmetric])"], ["", "lemma RECT_unfold: \"\\<lbrakk>trimono B\\<rbrakk> \\<Longrightarrow> RECT B = B (RECT B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trimono B \\<Longrightarrow> REC\\<^sub>T B = B (REC\\<^sub>T B)", "unfolding RECT_def [abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. trimono B \\<Longrightarrow>\n    (\\<lambda>x. if trimono B then flatf_gfp B x else top) =\n    B (\\<lambda>x. if trimono B then flatf_gfp B x else top)", "by (simp add: flatf_ord.fixp_unfold[OF trimonoD_flatf_ge, symmetric])"], ["", "lemma REC_mono[refine_mono]:\n  assumes [simp]: \"trimono B\"\n  assumes LE: \"\\<And>F x. (B F x) \\<le> (B' F x)\"\n  shows \"(REC B x) \\<le> (REC B' x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. REC B x \\<le> REC B' x", "unfolding REC_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if trimono B then lfp B x else top)\n    \\<le> (if trimono B' then lfp B' x else top)", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. trimono B' \\<Longrightarrow> lfp B x \\<le> lfp B' x", "apply (rule lfp_mono[THEN le_funD])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Z. trimono B' \\<Longrightarrow> B Z \\<le> B' Z", "apply (rule LE[THEN le_funI])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma RECT_mono[refine_mono]:\n  assumes [simp]: \"trimono B'\"\n  assumes LE: \"\\<And>F x. flat_ge (B F x) (B' F x)\"\n  shows \"flat_ge (RECT B x) (RECT B' x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. flat_ge (REC\\<^sub>T B x) (REC\\<^sub>T B' x)", "unfolding RECT_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. flat_ge (if trimono B then flatf_gfp B x else top)\n     (if trimono B' then flatf_gfp B' x else top)", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. trimono B \\<Longrightarrow> flat_ge (flatf_gfp B x) (flatf_gfp B' x)", "apply (rule flatf_fp_mono, (simp_all add: trimonoD) [2])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Z x. trimono B \\<Longrightarrow> flat_ge (B Z x) (B' Z x)", "apply (rule LE)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma REC_le_RECT: \"REC body x \\<le> RECT body x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. REC body x \\<le> REC\\<^sub>T body x", "unfolding REC_def RECT_gfp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if trimono body then lfp body x else top)\n    \\<le> (if trimono body then gfp body x else top)", "apply (cases \"trimono body\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. trimono body \\<Longrightarrow>\n    (if trimono body then lfp body x else top)\n    \\<le> (if trimono body then gfp body x else top)\n 2. \\<not> trimono body \\<Longrightarrow>\n    (if trimono body then lfp body x else top)\n    \\<le> (if trimono body then gfp body x else top)", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. trimono body \\<Longrightarrow> lfp body x \\<le> gfp body x\n 2. \\<not> trimono body \\<Longrightarrow>\n    (if trimono body then lfp body x else top)\n    \\<le> (if trimono body then gfp body x else top)", "apply (rule lfp_le_gfp[THEN le_funD])"], ["proof (prove)\ngoal (2 subgoals):\n 1. trimono body \\<Longrightarrow> mono body\n 2. \\<not> trimono body \\<Longrightarrow>\n    (if trimono body then lfp body x else top)\n    \\<le> (if trimono body then gfp body x else top)", "apply (simp add: trimonoD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> trimono body \\<Longrightarrow>\n    (if trimono body then lfp body x else top)\n    \\<le> (if trimono body then gfp body x else top)", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "print_statement flatf_fp_induct_pointwise"], ["", "theorem lfp_induct_pointwise:\n  fixes a::'a\n  assumes ADM1: \"\\<And>a x. chain_admissible (\\<lambda>b. \\<forall>a x. pre a x \\<longrightarrow> post a x (b x))\"\n  assumes ADM2: \"\\<And>a x. pre a x \\<longrightarrow> post a x bot\"\n  assumes MONO: \"mono B\"\n  assumes P0: \"pre a x\"\n  assumes IS: \n    \"\\<And>f a x.\n        \\<lbrakk>\\<And>a' x'. pre a' x' \\<Longrightarrow> post a' x' (f x'); pre a x;\n         f \\<le> (lfp B)\\<rbrakk>\n        \\<Longrightarrow> post a x (B f x)\"\n  shows \"post a x (lfp B x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. post a x (lfp B x)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. post a x (lfp B x)", "define u where \"u = lfp B\""], ["proof (state)\nthis:\n  u = lfp B\n\ngoal (1 subgoal):\n 1. post a x (lfp B x)", "have [simp]: \"\\<And>f. f\\<le>lfp B \\<Longrightarrow> B f \\<le> lfp B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f. f \\<le> lfp B \\<Longrightarrow> B f \\<le> lfp B", "by (metis (poly_guards_query) MONO lfp_unfold monoD)"], ["proof (state)\nthis:\n  ?f \\<le> lfp B \\<Longrightarrow> B ?f \\<le> lfp B\n\ngoal (1 subgoal):\n 1. post a x (lfp B x)", "have \"(\\<forall>a x. pre a x \\<longrightarrow> post a x (lfp B x)) \\<and> lfp B \\<le> u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>a x. pre a x \\<longrightarrow> post a x (lfp B x)) \\<and>\n    lfp B \\<le> u", "apply (rule lfp_cadm_induct[where f=B])"], ["proof (prove)\ngoal (4 subgoals):\n 1. chain_admissible\n     (\\<lambda>a.\n         (\\<forall>aa x. pre aa x \\<longrightarrow> post aa x (a x)) \\<and>\n         a \\<le> u)\n 2. (\\<forall>a x. pre a x \\<longrightarrow> post a x (Sup {} x)) \\<and>\n    Sup {} \\<le> u\n 3. mono B\n 4. \\<And>x.\n       (\\<forall>a xa. pre a xa \\<longrightarrow> post a xa (x xa)) \\<and>\n       x \\<le> u \\<Longrightarrow>\n       (\\<forall>a xa. pre a xa \\<longrightarrow> post a xa (B x xa)) \\<and>\n       B x \\<le> u", "apply (rule admissible_conj)"], ["proof (prove)\ngoal (5 subgoals):\n 1. chain_admissible\n     (\\<lambda>x.\n         \\<forall>a xa. pre a xa \\<longrightarrow> post a xa (x xa))\n 2. chain_admissible (\\<lambda>x. x \\<le> u)\n 3. (\\<forall>a x. pre a x \\<longrightarrow> post a x (Sup {} x)) \\<and>\n    Sup {} \\<le> u\n 4. mono B\n 5. \\<And>x.\n       (\\<forall>a xa. pre a xa \\<longrightarrow> post a xa (x xa)) \\<and>\n       x \\<le> u \\<Longrightarrow>\n       (\\<forall>a xa. pre a xa \\<longrightarrow> post a xa (B x xa)) \\<and>\n       B x \\<le> u", "apply (rule ADM1)"], ["proof (prove)\ngoal (4 subgoals):\n 1. chain_admissible (\\<lambda>x. x \\<le> u)\n 2. (\\<forall>a x. pre a x \\<longrightarrow> post a x (Sup {} x)) \\<and>\n    Sup {} \\<le> u\n 3. mono B\n 4. \\<And>x.\n       (\\<forall>a xa. pre a xa \\<longrightarrow> post a xa (x xa)) \\<and>\n       x \\<le> u \\<Longrightarrow>\n       (\\<forall>a xa. pre a xa \\<longrightarrow> post a xa (B x xa)) \\<and>\n       B x \\<le> u", "apply (rule)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>A.\n       \\<lbrakk>is_chain A; A \\<noteq> {};\n        \\<forall>x\\<in>A. x \\<le> u\\<rbrakk>\n       \\<Longrightarrow> Sup A \\<le> u\n 2. (\\<forall>a x. pre a x \\<longrightarrow> post a x (Sup {} x)) \\<and>\n    Sup {} \\<le> u\n 3. mono B\n 4. \\<And>x.\n       (\\<forall>a xa. pre a xa \\<longrightarrow> post a xa (x xa)) \\<and>\n       x \\<le> u \\<Longrightarrow>\n       (\\<forall>a xa. pre a xa \\<longrightarrow> post a xa (B x xa)) \\<and>\n       B x \\<le> u", "apply (blast intro: Sup_least)"], ["proof (prove)\ngoal (3 subgoals):\n 1. (\\<forall>a x. pre a x \\<longrightarrow> post a x (Sup {} x)) \\<and>\n    Sup {} \\<le> u\n 2. mono B\n 3. \\<And>x.\n       (\\<forall>a xa. pre a xa \\<longrightarrow> post a xa (x xa)) \\<and>\n       x \\<le> u \\<Longrightarrow>\n       (\\<forall>a xa. pre a xa \\<longrightarrow> post a xa (B x xa)) \\<and>\n       B x \\<le> u", "apply (simp add: le_fun_def ADM2) []"], ["proof (prove)\ngoal (2 subgoals):\n 1. mono B\n 2. \\<And>x.\n       (\\<forall>a xa. pre a xa \\<longrightarrow> post a xa (x xa)) \\<and>\n       x \\<le> u \\<Longrightarrow>\n       (\\<forall>a xa. pre a xa \\<longrightarrow> post a xa (B x xa)) \\<and>\n       B x \\<le> u", "apply fact"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<forall>a xa. pre a xa \\<longrightarrow> post a xa (x xa)) \\<and>\n       x \\<le> u \\<Longrightarrow>\n       (\\<forall>a xa. pre a xa \\<longrightarrow> post a xa (B x xa)) \\<and>\n       B x \\<le> u", "apply (intro conjI allI impI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x a xa.\n       \\<lbrakk>(\\<forall>a xa.\n                    pre a xa \\<longrightarrow> post a xa (x xa)) \\<and>\n                x \\<le> u;\n        pre a xa\\<rbrakk>\n       \\<Longrightarrow> post a xa (B x xa)\n 2. \\<And>x.\n       (\\<forall>a xa. pre a xa \\<longrightarrow> post a xa (x xa)) \\<and>\n       x \\<le> u \\<Longrightarrow>\n       B x \\<le> u", "unfolding u_def"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x a xa.\n       \\<lbrakk>(\\<forall>a xa.\n                    pre a xa \\<longrightarrow> post a xa (x xa)) \\<and>\n                x \\<le> lfp B;\n        pre a xa\\<rbrakk>\n       \\<Longrightarrow> post a xa (B x xa)\n 2. \\<And>x.\n       (\\<forall>a xa. pre a xa \\<longrightarrow> post a xa (x xa)) \\<and>\n       x \\<le> lfp B \\<Longrightarrow>\n       B x \\<le> lfp B", "apply (blast intro: IS)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<forall>a xa. pre a xa \\<longrightarrow> post a xa (x xa)) \\<and>\n       x \\<le> lfp B \\<Longrightarrow>\n       B x \\<le> lfp B", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (\\<forall>a x. pre a x \\<longrightarrow> post a x (lfp B x)) \\<and>\n  lfp B \\<le> u\n\ngoal (1 subgoal):\n 1. post a x (lfp B x)", "with P0"], ["proof (chain)\npicking this:\n  pre a x\n  (\\<forall>a x. pre a x \\<longrightarrow> post a x (lfp B x)) \\<and>\n  lfp B \\<le> u", "show ?thesis"], ["proof (prove)\nusing this:\n  pre a x\n  (\\<forall>a x. pre a x \\<longrightarrow> post a x (lfp B x)) \\<and>\n  lfp B \\<le> u\n\ngoal (1 subgoal):\n 1. post a x (lfp B x)", "by blast"], ["proof (state)\nthis:\n  post a x (lfp B x)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma REC_rule_arb:\n  fixes x::\"'x\" and arb::'arb\n  assumes M: \"trimono body\"\n  assumes I0: \"pre arb x\"\n  assumes IS: \"\\<And>f arb x. \\<lbrakk>\n    \\<And>arb' x. pre arb' x \\<Longrightarrow> f x \\<le> M arb' x; pre arb x; f \\<le> REC body\n  \\<rbrakk> \\<Longrightarrow> body f x \\<le> M arb x\"\n  shows \"REC body x \\<le> M arb x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. REC body x \\<le> M arb x", "unfolding REC_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if trimono body then lfp body x else top) \\<le> M arb x", "apply (clarsimp simp: M)"], ["proof (prove)\ngoal (1 subgoal):\n 1. lfp body x \\<le> M arb x", "apply (rule lfp_induct_pointwise[where pre=pre])"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>a x.\n       chain_admissible\n        (\\<lambda>b.\n            \\<forall>a x. pre a x \\<longrightarrow> b x \\<le> M a x)\n 2. \\<And>a x. pre a x \\<longrightarrow> bot \\<le> M a x\n 3. mono body\n 4. pre arb x\n 5. \\<And>f a x.\n       \\<lbrakk>\\<And>a' x'. pre a' x' \\<Longrightarrow> f x' \\<le> M a' x';\n        pre a x; f \\<le> lfp body\\<rbrakk>\n       \\<Longrightarrow> body f x \\<le> M a x", "apply (auto intro!: chain_admissibleI SUP_least) [2]"], ["proof (prove)\ngoal (3 subgoals):\n 1. mono body\n 2. pre arb x\n 3. \\<And>f a x.\n       \\<lbrakk>\\<And>a' x'. pre a' x' \\<Longrightarrow> f x' \\<le> M a' x';\n        pre a x; f \\<le> lfp body\\<rbrakk>\n       \\<Longrightarrow> body f x \\<le> M a x", "apply (simp add: trimonoD[OF M])"], ["proof (prove)\ngoal (2 subgoals):\n 1. pre arb x\n 2. \\<And>f a x.\n       \\<lbrakk>\\<And>a' x'. pre a' x' \\<Longrightarrow> f x' \\<le> M a' x';\n        pre a x; f \\<le> lfp body\\<rbrakk>\n       \\<Longrightarrow> body f x \\<le> M a x", "apply (rule I0)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f a x.\n       \\<lbrakk>\\<And>a' x'. pre a' x' \\<Longrightarrow> f x' \\<le> M a' x';\n        pre a x; f \\<le> lfp body\\<rbrakk>\n       \\<Longrightarrow> body f x \\<le> M a x", "apply (rule IS, assumption+)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f a x.\n       \\<lbrakk>\\<And>a' x'. pre a' x' \\<Longrightarrow> f x' \\<le> M a' x';\n        pre a x; f \\<le> lfp body\\<rbrakk>\n       \\<Longrightarrow> f \\<le> REC body", "apply (auto simp: REC_def[abs_def] intro!: le_funI dest: le_funD) []"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma RECT_rule_arb:\n  assumes M: \"trimono body\"\n  assumes WF: \"wf (V::('x\\<times>'x) set)\"\n  assumes I0: \"pre (arb::'arb) (x::'x)\"\n  assumes IS: \"\\<And>f arb x. \\<lbrakk> \n      \\<And>arb' x'. \\<lbrakk>pre arb' x'; (x',x)\\<in>V\\<rbrakk> \\<Longrightarrow> f x' \\<le> M arb' x'; \n      pre arb x;\n      RECT body = f\n    \\<rbrakk>  \\<Longrightarrow> body f x \\<le> M arb x\"\n  shows \"RECT body x \\<le> M arb x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. REC\\<^sub>T body x \\<le> M arb x", "apply (rule wf_fixp_induct[where fp=RECT and pre=pre and B=body])"], ["proof (prove)\ngoal (4 subgoals):\n 1. REC\\<^sub>T body = body (REC\\<^sub>T body)\n 2. wf ?V\n 3. pre arb x\n 4. \\<And>f a x.\n       \\<lbrakk>\\<And>a' x'.\n                   \\<lbrakk>pre a' x'; (x', x) \\<in> ?V\\<rbrakk>\n                   \\<Longrightarrow> f x' \\<le> M a' x';\n        REC\\<^sub>T body = f; pre a x\\<rbrakk>\n       \\<Longrightarrow> body f x \\<le> M a x", "apply (rule RECT_unfold)"], ["proof (prove)\ngoal (4 subgoals):\n 1. trimono body\n 2. wf ?V\n 3. pre arb x\n 4. \\<And>f a x.\n       \\<lbrakk>\\<And>a' x'.\n                   \\<lbrakk>pre a' x'; (x', x) \\<in> ?V\\<rbrakk>\n                   \\<Longrightarrow> f x' \\<le> M a' x';\n        REC\\<^sub>T body = f; pre a x\\<rbrakk>\n       \\<Longrightarrow> body f x \\<le> M a x", "apply (simp_all add: M) [2]"], ["proof (prove)\ngoal (3 subgoals):\n 1. wf ?V\n 2. pre arb x\n 3. \\<And>f a x.\n       \\<lbrakk>\\<And>a' x'.\n                   \\<lbrakk>pre a' x'; (x', x) \\<in> ?V\\<rbrakk>\n                   \\<Longrightarrow> f x' \\<le> M a' x';\n        REC\\<^sub>T body = f; pre a x\\<rbrakk>\n       \\<Longrightarrow> body f x \\<le> M a x", "apply (rule WF)"], ["proof (prove)\ngoal (2 subgoals):\n 1. pre arb x\n 2. \\<And>f a x.\n       \\<lbrakk>\\<And>a' x'.\n                   \\<lbrakk>pre a' x'; (x', x) \\<in> V\\<rbrakk>\n                   \\<Longrightarrow> f x' \\<le> M a' x';\n        REC\\<^sub>T body = f; pre a x\\<rbrakk>\n       \\<Longrightarrow> body f x \\<le> M a x", "apply fact"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f a x.\n       \\<lbrakk>\\<And>a' x'.\n                   \\<lbrakk>pre a' x'; (x', x) \\<in> V\\<rbrakk>\n                   \\<Longrightarrow> f x' \\<le> M a' x';\n        REC\\<^sub>T body = f; pre a x\\<rbrakk>\n       \\<Longrightarrow> body f x \\<le> M a x", "apply (rule IS)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>f a x arb' x'.\n       \\<lbrakk>\\<And>a' x'.\n                   \\<lbrakk>pre a' x'; (x', x) \\<in> V\\<rbrakk>\n                   \\<Longrightarrow> f x' \\<le> M a' x';\n        REC\\<^sub>T body = f; pre a x; pre arb' x'; (x', x) \\<in> V\\<rbrakk>\n       \\<Longrightarrow> f x' \\<le> M arb' x'\n 2. \\<And>f a x.\n       \\<lbrakk>\\<And>a' x'.\n                   \\<lbrakk>pre a' x'; (x', x) \\<in> V\\<rbrakk>\n                   \\<Longrightarrow> f x' \\<le> M a' x';\n        REC\\<^sub>T body = f; pre a x\\<rbrakk>\n       \\<Longrightarrow> pre a x\n 3. \\<And>f a x.\n       \\<lbrakk>\\<And>a' x'.\n                   \\<lbrakk>pre a' x'; (x', x) \\<in> V\\<rbrakk>\n                   \\<Longrightarrow> f x' \\<le> M a' x';\n        REC\\<^sub>T body = f; pre a x\\<rbrakk>\n       \\<Longrightarrow> REC\\<^sub>T body = f", "apply assumption"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>f a x.\n       \\<lbrakk>\\<And>a' x'.\n                   \\<lbrakk>pre a' x'; (x', x) \\<in> V\\<rbrakk>\n                   \\<Longrightarrow> f x' \\<le> M a' x';\n        REC\\<^sub>T body = f; pre a x\\<rbrakk>\n       \\<Longrightarrow> pre a x\n 2. \\<And>f a x.\n       \\<lbrakk>\\<And>a' x'.\n                   \\<lbrakk>pre a' x'; (x', x) \\<in> V\\<rbrakk>\n                   \\<Longrightarrow> f x' \\<le> M a' x';\n        REC\\<^sub>T body = f; pre a x\\<rbrakk>\n       \\<Longrightarrow> REC\\<^sub>T body = f", "apply assumption"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f a x.\n       \\<lbrakk>\\<And>a' x'.\n                   \\<lbrakk>pre a' x'; (x', x) \\<in> V\\<rbrakk>\n                   \\<Longrightarrow> f x' \\<le> M a' x';\n        REC\\<^sub>T body = f; pre a x\\<rbrakk>\n       \\<Longrightarrow> REC\\<^sub>T body = f", "apply assumption"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma REC_rule:\n  fixes x::\"'x\"\n  assumes M: \"trimono body\"\n  assumes I0: \"pre x\"\n  assumes IS: \"\\<And>f x. \\<lbrakk> \\<And>x. pre x \\<Longrightarrow> f x \\<le> M x; pre x; f \\<le> REC body \\<rbrakk> \n    \\<Longrightarrow> body f x \\<le> M x\"\n  shows \"REC body x \\<le> M x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. REC body x \\<le> M x", "by (rule REC_rule_arb[where pre=\"\\<lambda>_. pre\" and M=\"\\<lambda>_. M\", OF assms])"], ["", "lemma RECT_rule:\n  assumes M: \"trimono body\"\n  assumes WF: \"wf (V::('x\\<times>'x) set)\"\n  assumes I0: \"pre (x::'x)\"\n  assumes IS: \"\\<And>f x. \\<lbrakk> \\<And>x'. \\<lbrakk>pre x'; (x',x)\\<in>V\\<rbrakk> \\<Longrightarrow> f x' \\<le> M x'; pre x; \n                        RECT body = f\n    \\<rbrakk> \\<Longrightarrow> body f x \\<le> M x\"\n  shows \"RECT body x \\<le> M x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. REC\\<^sub>T body x \\<le> M x", "by (rule RECT_rule_arb[where pre=\"\\<lambda>_. pre\" and M=\"\\<lambda>_. M\", OF assms])"], ["", "(* TODO: Can we set-up induction method to work with such goals? *)"], ["", "lemma REC_rule_arb2:\n  assumes M: \"trimono body\"\n  assumes I0: \"pre (arb::'arb) (arc::'arc) (x::'x)\"\n  assumes IS: \"\\<And>f arb arc x. \\<lbrakk> \n      \\<And>arb' arc' x'. \\<lbrakk>pre arb' arc' x' \\<rbrakk> \\<Longrightarrow> f x' \\<le> M arb' arc' x'; \n      pre arb arc x\n    \\<rbrakk>  \\<Longrightarrow> body f x \\<le> M arb arc x\"\n  shows \"REC body x \\<le> M arb arc x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. REC body x \\<le> M arb arc x", "apply (rule order_trans)"], ["proof (prove)\ngoal (2 subgoals):\n 1. REC body x \\<le> ?y\n 2. ?y \\<le> M arb arc x", "apply (rule REC_rule_arb[\n    where pre=\"case_prod pre\" and M=\"case_prod M\" and arb=\"(arb, arc)\", \n    OF M])"], ["proof (prove)\ngoal (3 subgoals):\n 1. (case (arb, arc) of (x, xa) \\<Rightarrow> pre x xa) x\n 2. \\<And>f arb x.\n       \\<lbrakk>\\<And>arb' x.\n                   (case arb' of (x, xa) \\<Rightarrow> pre x xa)\n                    x \\<Longrightarrow>\n                   f x \\<le> (case arb' of (x, xa) \\<Rightarrow> M x xa) x;\n        (case arb of (x, xa) \\<Rightarrow> pre x xa) x;\n        f \\<le> REC body\\<rbrakk>\n       \\<Longrightarrow> body f x\n                         \\<le> (case arb of (x, xa) \\<Rightarrow> M x xa) x\n 3. (case (arb, arc) of (x, xa) \\<Rightarrow> M x xa) x \\<le> M arb arc x", "by (auto intro: assms)"], ["", "lemma REC_rule_arb3:\n  assumes M: \"trimono body\"\n  assumes I0: \"pre (arb::'arb) (arc::'arc) (ard::'ard) (x::'x)\"\n  assumes IS: \"\\<And>f arb arc ard x. \\<lbrakk> \n      \\<And>arb' arc' ard' x'. \\<lbrakk>pre arb' arc' ard' x'\\<rbrakk> \\<Longrightarrow> f x' \\<le> M arb' arc' ard' x';\n      pre arb arc ard x \n    \\<rbrakk>  \\<Longrightarrow> body f x \\<le> M arb arc ard x\"\n  shows \"REC body x \\<le> M arb arc ard x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. REC body x \\<le> M arb arc ard x", "apply (rule order_trans)"], ["proof (prove)\ngoal (2 subgoals):\n 1. REC body x \\<le> ?y\n 2. ?y \\<le> M arb arc ard x", "apply (rule REC_rule_arb2[\n    where pre=\"case_prod pre\" and M=\"case_prod M\" and arb=\"(arb, arc)\" and arc=\"ard\", \n    OF M])"], ["proof (prove)\ngoal (3 subgoals):\n 1. (case (arb, arc) of (x, xa) \\<Rightarrow> pre x xa) ard x\n 2. \\<And>f arb arc x.\n       \\<lbrakk>\\<And>arb' arc' x'.\n                   (case arb' of (x, xa) \\<Rightarrow> pre x xa) arc'\n                    x' \\<Longrightarrow>\n                   f x'\n                   \\<le> (case arb' of (x, xa) \\<Rightarrow> M x xa) arc'\n                          x';\n        (case arb of (x, xa) \\<Rightarrow> pre x xa) arc x\\<rbrakk>\n       \\<Longrightarrow> body f x\n                         \\<le> (case arb of (x, xa) \\<Rightarrow> M x xa)\n                                arc x\n 3. (case (arb, arc) of (x, xa) \\<Rightarrow> M x xa) ard x\n    \\<le> M arb arc ard x", "by (auto intro: assms)"], ["", "lemma RECT_rule_arb2:\n  assumes M: \"trimono body\"\n  assumes WF: \"wf (V::'x rel)\"\n  assumes I0: \"pre (arb::'arb) (arc::'arc) (x::'x)\"\n  assumes IS: \"\\<And>f arb arc x. \\<lbrakk> \n      \\<And>arb' arc' x'. \\<lbrakk>pre arb' arc' x'; (x',x)\\<in>V\\<rbrakk> \\<Longrightarrow> f x' \\<le> M arb' arc' x'; \n      pre arb arc x;\n      f \\<le> RECT body\n    \\<rbrakk>  \\<Longrightarrow> body f x \\<le> M arb arc x\"\n  shows \"RECT body x \\<le> M arb arc x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. REC\\<^sub>T body x \\<le> M arb arc x", "apply (rule order_trans)"], ["proof (prove)\ngoal (2 subgoals):\n 1. REC\\<^sub>T body x \\<le> ?y\n 2. ?y \\<le> M arb arc x", "apply (rule RECT_rule_arb[\n    where pre=\"case_prod pre\" and M=\"case_prod M\" and arb=\"(arb, arc)\", \n    OF M WF])"], ["proof (prove)\ngoal (3 subgoals):\n 1. (case (arb, arc) of (x, xa) \\<Rightarrow> pre x xa) x\n 2. \\<And>f arb x.\n       \\<lbrakk>\\<And>arb' x'.\n                   \\<lbrakk>(case arb' of (x, xa) \\<Rightarrow> pre x xa)\n                             x';\n                    (x', x) \\<in> V\\<rbrakk>\n                   \\<Longrightarrow> f x'\n                                     \\<le> (case arb' of\n      (x, xa) \\<Rightarrow> M x xa)\n      x';\n        (case arb of (x, xa) \\<Rightarrow> pre x xa) x;\n        REC\\<^sub>T body = f\\<rbrakk>\n       \\<Longrightarrow> body f x\n                         \\<le> (case arb of (x, xa) \\<Rightarrow> M x xa) x\n 3. (case (arb, arc) of (x, xa) \\<Rightarrow> M x xa) x \\<le> M arb arc x", "by (auto intro: assms)"], ["", "lemma RECT_rule_arb3:\n  assumes M: \"trimono body\"\n  assumes WF: \"wf (V::'x rel)\"\n  assumes I0: \"pre (arb::'arb) (arc::'arc) (ard::'ard) (x::'x)\"\n  assumes IS: \"\\<And>f arb arc ard x. \\<lbrakk> \n      \\<And>arb' arc' ard' x'. \\<lbrakk>pre arb' arc' ard' x'; (x',x)\\<in>V\\<rbrakk> \\<Longrightarrow> f x' \\<le> M arb' arc' ard' x'; \n    pre arb arc ard x;\n    f \\<le> RECT body\n  \\<rbrakk>  \\<Longrightarrow> body f x \\<le> M arb arc ard x\"\n  shows \"RECT body x \\<le> M arb arc ard x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. REC\\<^sub>T body x \\<le> M arb arc ard x", "apply (rule order_trans)"], ["proof (prove)\ngoal (2 subgoals):\n 1. REC\\<^sub>T body x \\<le> ?y\n 2. ?y \\<le> M arb arc ard x", "apply (rule RECT_rule_arb2[\n    where pre=\"case_prod pre\" and M=\"case_prod M\" and arb=\"(arb, arc)\" and arc=\"ard\", \n    OF M WF])"], ["proof (prove)\ngoal (3 subgoals):\n 1. (case (arb, arc) of (x, xa) \\<Rightarrow> pre x xa) ard x\n 2. \\<And>f arb arc x.\n       \\<lbrakk>\\<And>arb' arc' x'.\n                   \\<lbrakk>(case arb' of (x, xa) \\<Rightarrow> pre x xa)\n                             arc' x';\n                    (x', x) \\<in> V\\<rbrakk>\n                   \\<Longrightarrow> f x'\n                                     \\<le> (case arb' of\n      (x, xa) \\<Rightarrow> M x xa)\n      arc' x';\n        (case arb of (x, xa) \\<Rightarrow> pre x xa) arc x;\n        f \\<le> REC\\<^sub>T body\\<rbrakk>\n       \\<Longrightarrow> body f x\n                         \\<le> (case arb of (x, xa) \\<Rightarrow> M x xa)\n                                arc x\n 3. (case (arb, arc) of (x, xa) \\<Rightarrow> M x xa) ard x\n    \\<le> M arb arc ard x", "by (auto intro: assms)"], ["", "(* Obsolete, provide a variant to show nofail.\ntext {* The following lemma shows that greatest and least fixed point are equal,\n  if we can provide a variant. *}\nlemma RECT_eq_REC:\n  assumes MONO: \"flatf_mono_le body\"\n  assumes MONO_GE: \"flatf_mono_ge body\"\n  assumes WF: \"wf V\"\n  assumes I0: \"I x\"\n  assumes IS: \"\\<And>f x. I x \\<Longrightarrow> \n    body (\\<lambda>x'. if (I x' \\<and> (x',x)\\<in>V) then f x' else top) x \\<le> body f x\"\n  shows \"RECT body x = REC body x\"\n  unfolding RECT_def REC_def \nproof (simp add: MONO MONO_GE)\n  have \"I x \\<longrightarrow> flatf_gfp body x \\<le> flatf_lfp body x\"\n    using WF\n    apply (induct rule: wf_induct_rule)\n    apply (rule impI)\n    apply (subst flatf_ord.fixp_unfold[OF MONO])\n    apply (subst flatf_ord.fixp_unfold[OF MONO_GE])\n    apply (rule order_trans[OF _ IS])\n    apply (rule monoD[OF MONO,THEN le_funD])\n    apply (rule le_funI)\n    apply simp\n    apply simp\n    done\n  \n\n\n  from lfp_le_gfp' MONO have \"lfp body x \\<le> gfp body x\" .\n  moreover have \"I x \\<longrightarrow> gfp body x \\<le> lfp body x\"\n    using WF\n    apply (induct rule: wf_induct[consumes 1])\n    apply (rule impI)\n    apply (subst lfp_unfold[OF MONO])\n    apply (subst gfp_unfold[OF MONO])\n    apply (rule order_trans[OF _ IS])\n    apply (rule monoD[OF MONO,THEN le_funD])\n    apply (rule le_funI)\n    apply simp\n    apply simp\n    done\n  ultimately show ?thesis\n    unfolding REC_def RECT_def gfp_eq_flatf_gfp[OF MONO_GE MONO, symmetric]\n    apply (rule_tac antisym)\n    using I0 MONO MONO_GE by auto\nqed\n*)"], ["", "lemma RECT_eq_REC: \n  \\<comment> \\<open>Partial and total correct recursion are equal if total \n    recursion does not fail.\\<close>\n  assumes NT: \"RECT body x \\<noteq> top\"\n  shows \"RECT body x = REC body x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. REC\\<^sub>T body x = REC body x", "proof (cases \"trimono body\")"], ["proof (state)\ngoal (2 subgoals):\n 1. trimono body \\<Longrightarrow> REC\\<^sub>T body x = REC body x\n 2. \\<not> trimono body \\<Longrightarrow> REC\\<^sub>T body x = REC body x", "case M: True"], ["proof (state)\nthis:\n  trimono body\n\ngoal (2 subgoals):\n 1. trimono body \\<Longrightarrow> REC\\<^sub>T body x = REC body x\n 2. \\<not> trimono body \\<Longrightarrow> REC\\<^sub>T body x = REC body x", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. REC\\<^sub>T body x = REC body x", "using NT M"], ["proof (prove)\nusing this:\n  REC\\<^sub>T body x \\<noteq> top\n  trimono body\n\ngoal (1 subgoal):\n 1. REC\\<^sub>T body x = REC body x", "unfolding RECT_def REC_def"], ["proof (prove)\nusing this:\n  (if trimono body then flatf_gfp body x else top) \\<noteq> top\n  trimono body\n\ngoal (1 subgoal):\n 1. (if trimono body then flatf_gfp body x else top) =\n    (if trimono body then lfp body x else top)", "proof clarsimp"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>flatf_gfp body x \\<noteq> top; trimono body\\<rbrakk>\n    \\<Longrightarrow> flatf_gfp body x = lfp body x", "from lfp_unfold[OF trimonoD_mono[OF M], symmetric]"], ["proof (chain)\npicking this:\n  body (lfp body) = lfp body", "have \"flatf_ge (body (lfp body)) (lfp body)\""], ["proof (prove)\nusing this:\n  body (lfp body) = lfp body\n\ngoal (1 subgoal):\n 1. flatf_ge (body (lfp body)) (lfp body)", "by simp"], ["proof (state)\nthis:\n  flatf_ge (body (lfp body)) (lfp body)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>flatf_gfp body x \\<noteq> top; trimono body\\<rbrakk>\n    \\<Longrightarrow> flatf_gfp body x = lfp body x", "note flatf_ord.fixp_lowerbound[\n      OF trimonoD_flatf_ge[OF M], of \"lfp body\", OF this]"], ["proof (state)\nthis:\n  flatf_ge (flatf_gfp body) (lfp body)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>flatf_gfp body x \\<noteq> top; trimono body\\<rbrakk>\n    \\<Longrightarrow> flatf_gfp body x = lfp body x", "moreover"], ["proof (state)\nthis:\n  flatf_ge (flatf_gfp body) (lfp body)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>flatf_gfp body x \\<noteq> top; trimono body\\<rbrakk>\n    \\<Longrightarrow> flatf_gfp body x = lfp body x", "assume \"flatf_gfp body x \\<noteq> top\""], ["proof (state)\nthis:\n  flatf_gfp body x \\<noteq> top\n\ngoal (1 subgoal):\n 1. \\<lbrakk>flatf_gfp body x \\<noteq> top; trimono body\\<rbrakk>\n    \\<Longrightarrow> flatf_gfp body x = lfp body x", "ultimately"], ["proof (chain)\npicking this:\n  flatf_ge (flatf_gfp body) (lfp body)\n  flatf_gfp body x \\<noteq> top", "show \"flatf_gfp body x = lfp body x\""], ["proof (prove)\nusing this:\n  flatf_ge (flatf_gfp body) (lfp body)\n  flatf_gfp body x \\<noteq> top\n\ngoal (1 subgoal):\n 1. flatf_gfp body x = lfp body x", "by (auto simp add: fun_ord_def flat_ord_def)"], ["proof (state)\nthis:\n  flatf_gfp body x = lfp body x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  REC\\<^sub>T body x = REC body x\n\ngoal (1 subgoal):\n 1. \\<not> trimono body \\<Longrightarrow> REC\\<^sub>T body x = REC body x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> trimono body \\<Longrightarrow> REC\\<^sub>T body x = REC body x", "case False"], ["proof (state)\nthis:\n  \\<not> trimono body\n\ngoal (1 subgoal):\n 1. \\<not> trimono body \\<Longrightarrow> REC\\<^sub>T body x = REC body x", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> trimono body\n\ngoal (1 subgoal):\n 1. REC\\<^sub>T body x = REC body x", "unfolding RECT_def REC_def"], ["proof (prove)\nusing this:\n  \\<not> trimono body\n\ngoal (1 subgoal):\n 1. (if trimono body then flatf_gfp body x else top) =\n    (if trimono body then lfp body x else top)", "by auto"], ["proof (state)\nthis:\n  REC\\<^sub>T body x = REC body x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma RECT_eq_REC_tproof:\n  \\<comment> \\<open>Partial and total correct recursion are equal if we can provide a \n    termination proof.\\<close>\n  fixes a :: 'a\n  assumes M: \"trimono body\"\n  assumes WF: \"wf V\"\n  assumes I0: \"pre a x\"\n  assumes IS: \"\\<And>f arb x.\n          \\<lbrakk>\\<And>arb' x'. \\<lbrakk>pre arb' x'; (x', x) \\<in> V\\<rbrakk> \\<Longrightarrow> f x' \\<le> M arb' x'; \n            pre arb x; REC\\<^sub>T body = f\\<rbrakk>\n          \\<Longrightarrow> body f x \\<le> M arb x\"\n  assumes NT: \"M a x \\<noteq> top\"\n  shows \"RECT body x = REC body x \\<and> RECT body x \\<le> M a x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. REC\\<^sub>T body x = REC body x \\<and> REC\\<^sub>T body x \\<le> M a x", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. REC\\<^sub>T body x = REC body x\n 2. REC\\<^sub>T body x \\<le> M a x", "show \"RECT body x \\<le> M a x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. REC\\<^sub>T body x \\<le> M a x", "by (rule RECT_rule_arb[OF M WF, where pre=pre, OF I0 IS])"], ["proof (state)\nthis:\n  REC\\<^sub>T body x \\<le> M a x\n\ngoal (1 subgoal):\n 1. REC\\<^sub>T body x = REC body x", "with NT"], ["proof (chain)\npicking this:\n  M a x \\<noteq> top\n  REC\\<^sub>T body x \\<le> M a x", "have \"RECT body x \\<noteq> top\""], ["proof (prove)\nusing this:\n  M a x \\<noteq> top\n  REC\\<^sub>T body x \\<le> M a x\n\ngoal (1 subgoal):\n 1. REC\\<^sub>T body x \\<noteq> top", "by (metis top.extremum_unique)"], ["proof (state)\nthis:\n  REC\\<^sub>T body x \\<noteq> top\n\ngoal (1 subgoal):\n 1. REC\\<^sub>T body x = REC body x", "thus \"RECT body x = REC body x\""], ["proof (prove)\nusing this:\n  REC\\<^sub>T body x \\<noteq> top\n\ngoal (1 subgoal):\n 1. REC\\<^sub>T body x = REC body x", "by (rule RECT_eq_REC)"], ["proof (state)\nthis:\n  REC\\<^sub>T body x = REC body x\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Transfer\\<close>"], ["", "lemma (in transfer) transfer_RECT'[refine_transfer]:\n  assumes REC_EQ: \"\\<And>x. fr x = b fr x\"\n  assumes REF: \"\\<And>F f x. \\<lbrakk>\\<And>x. \\<alpha> (f x) \\<le> F x \\<rbrakk> \\<Longrightarrow> \\<alpha> (b f x) \\<le> B F x\"\n  shows \"\\<alpha> (fr x) \\<le> RECT B x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha> (fr x) \\<le> REC\\<^sub>T B x", "unfolding RECT_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha> (fr x) \\<le> (if trimono B then flatf_gfp B x else top)", "proof clarsimp"], ["proof (state)\ngoal (1 subgoal):\n 1. trimono B \\<Longrightarrow> \\<alpha> (fr x) \\<le> flatf_gfp B x", "assume MONO: \"trimono B\""], ["proof (state)\nthis:\n  trimono B\n\ngoal (1 subgoal):\n 1. trimono B \\<Longrightarrow> \\<alpha> (fr x) \\<le> flatf_gfp B x", "show \"\\<alpha> (fr x) \\<le> flatf_gfp B x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha> (fr x) \\<le> flatf_gfp B x", "apply (rule flatf_fixp_transfer[where B=B and fp'=fr and P=\"(=)\", \n        OF _ trimonoD_flatf_ge[OF MONO]])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x'. \\<alpha> x' \\<le> top\n 2. fr = ?B' fr\n 3. x = x\n 4. \\<And>f f' x x'.\n       \\<lbrakk>\\<And>x x'.\n                   x = x' \\<Longrightarrow> \\<alpha> (f' x') \\<le> f x;\n        x = x'; fr = f'\\<rbrakk>\n       \\<Longrightarrow> \\<alpha> (?B' f' x') \\<le> B f x", "apply simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. fr = ?B' fr\n 2. x = x\n 3. \\<And>f f' x x'.\n       \\<lbrakk>\\<And>x x'.\n                   x = x' \\<Longrightarrow> \\<alpha> (f' x') \\<le> f x;\n        x = x'; fr = f'\\<rbrakk>\n       \\<Longrightarrow> \\<alpha> (?B' f' x') \\<le> B f x", "apply (rule ext, fact)"], ["proof (prove)\ngoal (2 subgoals):\n 1. x = x\n 2. \\<And>f f' x x'.\n       \\<lbrakk>\\<And>x x'.\n                   x = x' \\<Longrightarrow> \\<alpha> (f' x') \\<le> f x;\n        x = x'; fr = f'\\<rbrakk>\n       \\<Longrightarrow> \\<alpha> (b f' x') \\<le> B f x", "apply (simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f f' x x'.\n       \\<lbrakk>\\<And>x x'.\n                   x = x' \\<Longrightarrow> \\<alpha> (f' x') \\<le> f x;\n        x = x'; fr = f'\\<rbrakk>\n       \\<Longrightarrow> \\<alpha> (b f' x') \\<le> B f x", "apply (simp,rule REF, blast)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<alpha> (fr x) \\<le> flatf_gfp B x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in ordered_transfer) transfer_RECT[refine_transfer]:\n  assumes REF: \"\\<And>F f x. \\<lbrakk>\\<And>x. \\<alpha> (f x) \\<le> F x \\<rbrakk> \\<Longrightarrow> \\<alpha> (b f x) \\<le> B F x\"\n  assumes M: \"trimono b\"\n  shows \"\\<alpha> (RECT b x) \\<le> RECT B x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha> (REC\\<^sub>T b x) \\<le> REC\\<^sub>T B x", "apply (rule transfer_RECT')"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x. REC\\<^sub>T b x = ?b (REC\\<^sub>T b) x\n 2. \\<And>F f x.\n       (\\<And>x. \\<alpha> (f x) \\<le> F x) \\<Longrightarrow>\n       \\<alpha> (?b f x) \\<le> B F x", "apply (rule RECT_unfold[OF M, THEN fun_cong])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>F f x.\n       (\\<And>x. \\<alpha> (f x) \\<le> F x) \\<Longrightarrow>\n       \\<alpha> (b f x) \\<le> B F x", "by fact"], ["", "lemma (in dist_transfer) transfer_REC[refine_transfer]:\n  assumes REF: \"\\<And>F f x. \\<lbrakk>\\<And>x. \\<alpha> (f x) \\<le> F x \\<rbrakk> \\<Longrightarrow> \\<alpha> (b f x) \\<le> B F x\"\n  assumes M: \"trimono b\"\n  shows \"\\<alpha> (REC b x) \\<le> REC B x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha> (REC b x) \\<le> REC B x", "unfolding REC_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha> (if trimono b then lfp b x else top)\n    \\<le> (if trimono B then lfp B x else top)", "(* TODO: Clean up *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha> (if trimono b then lfp b x else top)\n    \\<le> (if trimono B then lfp B x else top)", "apply (clarsimp simp: M)"], ["proof (prove)\ngoal (1 subgoal):\n 1. trimono B \\<Longrightarrow> \\<alpha> (lfp b x) \\<le> lfp B x", "apply (rule lfp_induct_pointwise[where B=b and pre=\"(=)\"])"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>a x.\n       trimono B \\<Longrightarrow>\n       chain_admissible\n        (\\<lambda>b.\n            \\<forall>a x.\n               a = x \\<longrightarrow> \\<alpha> (b x) \\<le> lfp B x)\n 2. \\<And>a x.\n       trimono B \\<Longrightarrow>\n       a = x \\<longrightarrow> \\<alpha> bot \\<le> lfp B x\n 3. trimono B \\<Longrightarrow> mono b\n 4. trimono B \\<Longrightarrow> ?a7 = x\n 5. \\<And>f a x.\n       \\<lbrakk>trimono B;\n        \\<And>a' x'.\n           a' = x' \\<Longrightarrow> \\<alpha> (f x') \\<le> lfp B x';\n        a = x; f \\<le> lfp b\\<rbrakk>\n       \\<Longrightarrow> \\<alpha> (b f x) \\<le> lfp B x", "apply (rule)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>a x A.\n       \\<lbrakk>trimono B; is_chain A; A \\<noteq> {};\n        \\<forall>x\\<in>A.\n           \\<forall>a xa.\n              a = xa \\<longrightarrow>\n              \\<alpha> (x xa) \\<le> lfp B xa\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a x.\n                            a = x \\<longrightarrow>\n                            \\<alpha> (Sup A x) \\<le> lfp B x\n 2. \\<And>a x.\n       trimono B \\<Longrightarrow>\n       a = x \\<longrightarrow> \\<alpha> bot \\<le> lfp B x\n 3. trimono B \\<Longrightarrow> mono b\n 4. trimono B \\<Longrightarrow> ?a7 = x\n 5. \\<And>f a x.\n       \\<lbrakk>trimono B;\n        \\<And>a' x'.\n           a' = x' \\<Longrightarrow> \\<alpha> (f x') \\<le> lfp B x';\n        a = x; f \\<le> lfp b\\<rbrakk>\n       \\<Longrightarrow> \\<alpha> (b f x) \\<le> lfp B x", "apply clarsimp"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>A a.\n       \\<lbrakk>trimono B; is_chain A; A \\<noteq> {};\n        \\<forall>x\\<in>A. \\<forall>a. \\<alpha> (x a) \\<le> lfp B a\\<rbrakk>\n       \\<Longrightarrow> \\<alpha> (SUP f\\<in>A. f a) \\<le> lfp B a\n 2. \\<And>a x.\n       trimono B \\<Longrightarrow>\n       a = x \\<longrightarrow> \\<alpha> bot \\<le> lfp B x\n 3. trimono B \\<Longrightarrow> mono b\n 4. trimono B \\<Longrightarrow> ?a7 = x\n 5. \\<And>f a x.\n       \\<lbrakk>trimono B;\n        \\<And>a' x'.\n           a' = x' \\<Longrightarrow> \\<alpha> (f x') \\<le> lfp B x';\n        a = x; f \\<le> lfp b\\<rbrakk>\n       \\<Longrightarrow> \\<alpha> (b f x) \\<le> lfp B x", "apply (subst \\<alpha>_dist)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>A a.\n       \\<lbrakk>trimono B; is_chain A; A \\<noteq> {};\n        \\<forall>x\\<in>A. \\<forall>a. \\<alpha> (x a) \\<le> lfp B a\\<rbrakk>\n       \\<Longrightarrow> is_chain ((\\<lambda>f. f a) ` A)\n 2. \\<And>A a.\n       \\<lbrakk>trimono B; is_chain A; A \\<noteq> {};\n        \\<forall>x\\<in>A. \\<forall>a. \\<alpha> (x a) \\<le> lfp B a\\<rbrakk>\n       \\<Longrightarrow> Sup (\\<alpha> ` (\\<lambda>f. f a) ` A)\n                         \\<le> lfp B a\n 3. \\<And>a x.\n       trimono B \\<Longrightarrow>\n       a = x \\<longrightarrow> \\<alpha> bot \\<le> lfp B x\n 4. trimono B \\<Longrightarrow> mono b\n 5. trimono B \\<Longrightarrow> ?a7 = x\n 6. \\<And>f a x.\n       \\<lbrakk>trimono B;\n        \\<And>a' x'.\n           a' = x' \\<Longrightarrow> \\<alpha> (f x') \\<le> lfp B x';\n        a = x; f \\<le> lfp b\\<rbrakk>\n       \\<Longrightarrow> \\<alpha> (b f x) \\<le> lfp B x", "apply (auto simp add: chain_def le_fun_def) []"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>A a.\n       \\<lbrakk>trimono B; is_chain A; A \\<noteq> {};\n        \\<forall>x\\<in>A. \\<forall>a. \\<alpha> (x a) \\<le> lfp B a\\<rbrakk>\n       \\<Longrightarrow> Sup (\\<alpha> ` (\\<lambda>f. f a) ` A)\n                         \\<le> lfp B a\n 2. \\<And>a x.\n       trimono B \\<Longrightarrow>\n       a = x \\<longrightarrow> \\<alpha> bot \\<le> lfp B x\n 3. trimono B \\<Longrightarrow> mono b\n 4. trimono B \\<Longrightarrow> ?a7 = x\n 5. \\<And>f a x.\n       \\<lbrakk>trimono B;\n        \\<And>a' x'.\n           a' = x' \\<Longrightarrow> \\<alpha> (f x') \\<le> lfp B x';\n        a = x; f \\<le> lfp b\\<rbrakk>\n       \\<Longrightarrow> \\<alpha> (b f x) \\<le> lfp B x", "apply (rule Sup_least)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>A a x.\n       \\<lbrakk>trimono B; is_chain A; A \\<noteq> {};\n        \\<forall>x\\<in>A. \\<forall>a. \\<alpha> (x a) \\<le> lfp B a;\n        x \\<in> \\<alpha> ` (\\<lambda>f. f a) ` A\\<rbrakk>\n       \\<Longrightarrow> x \\<le> lfp B a\n 2. \\<And>a x.\n       trimono B \\<Longrightarrow>\n       a = x \\<longrightarrow> \\<alpha> bot \\<le> lfp B x\n 3. trimono B \\<Longrightarrow> mono b\n 4. trimono B \\<Longrightarrow> ?a7 = x\n 5. \\<And>f a x.\n       \\<lbrakk>trimono B;\n        \\<And>a' x'.\n           a' = x' \\<Longrightarrow> \\<alpha> (f x') \\<le> lfp B x';\n        a = x; f \\<le> lfp b\\<rbrakk>\n       \\<Longrightarrow> \\<alpha> (b f x) \\<le> lfp B x", "apply auto []"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a x.\n       trimono B \\<Longrightarrow>\n       a = x \\<longrightarrow> \\<alpha> bot \\<le> lfp B x\n 2. trimono B \\<Longrightarrow> mono b\n 3. trimono B \\<Longrightarrow> ?a7 = x\n 4. \\<And>f a x.\n       \\<lbrakk>trimono B;\n        \\<And>a' x'.\n           a' = x' \\<Longrightarrow> \\<alpha> (f x') \\<le> lfp B x';\n        a = x; f \\<le> lfp b\\<rbrakk>\n       \\<Longrightarrow> \\<alpha> (b f x) \\<le> lfp B x", "apply simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. trimono B \\<Longrightarrow> mono b\n 2. trimono B \\<Longrightarrow> ?a7 = x\n 3. \\<And>f a x.\n       \\<lbrakk>trimono B;\n        \\<And>a' x'.\n           a' = x' \\<Longrightarrow> \\<alpha> (f x') \\<le> lfp B x';\n        a = x; f \\<le> lfp b\\<rbrakk>\n       \\<Longrightarrow> \\<alpha> (b f x) \\<le> lfp B x", "apply (simp add: trimonoD[OF M])"], ["proof (prove)\ngoal (2 subgoals):\n 1. trimono B \\<Longrightarrow> ?a7 = x\n 2. \\<And>f a x.\n       \\<lbrakk>trimono B;\n        \\<And>a' x'.\n           a' = x' \\<Longrightarrow> \\<alpha> (f x') \\<le> lfp B x';\n        a = x; f \\<le> lfp b\\<rbrakk>\n       \\<Longrightarrow> \\<alpha> (b f x) \\<le> lfp B x", "apply (rule refl)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f a x.\n       \\<lbrakk>trimono B;\n        \\<And>a' x'.\n           a' = x' \\<Longrightarrow> \\<alpha> (f x') \\<le> lfp B x';\n        a = x; f \\<le> lfp b\\<rbrakk>\n       \\<Longrightarrow> \\<alpha> (b f x) \\<le> lfp B x", "apply (subst lfp_unfold)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>f a x.\n       \\<lbrakk>trimono B;\n        \\<And>a' x'.\n           a' = x' \\<Longrightarrow> \\<alpha> (f x') \\<le> lfp B x';\n        a = x; f \\<le> lfp b\\<rbrakk>\n       \\<Longrightarrow> mono B\n 2. \\<And>f a x.\n       \\<lbrakk>trimono B;\n        \\<And>a' x'.\n           a' = x' \\<Longrightarrow> \\<alpha> (f x') \\<le> lfp B x';\n        a = x; f \\<le> lfp b\\<rbrakk>\n       \\<Longrightarrow> \\<alpha> (b f x) \\<le> B (lfp B) x", "apply (simp add: trimonoD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f a x.\n       \\<lbrakk>trimono B;\n        \\<And>a' x'.\n           a' = x' \\<Longrightarrow> \\<alpha> (f x') \\<le> lfp B x';\n        a = x; f \\<le> lfp b\\<rbrakk>\n       \\<Longrightarrow> \\<alpha> (b f x) \\<le> B (lfp B) x", "apply (rule REF)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f a x xa.\n       \\<lbrakk>trimono B;\n        \\<And>a' x'.\n           a' = x' \\<Longrightarrow> \\<alpha> (f x') \\<le> lfp B x';\n        a = x; f \\<le> lfp b\\<rbrakk>\n       \\<Longrightarrow> \\<alpha> (f xa) \\<le> lfp B xa", "apply blast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(* TODO: Could we base the whole refine_transfer-stuff on arbitrary relations *)\n(* TODO: For enres-breakdown, we had to do antisymmetry, in order to get TR_top.\n  What is the general shape of tr-relations for that, such that we could show equality directly?\n*)"], ["", "lemma RECT_transfer_rel:\n  assumes [simp]: \"trimono F\" \"trimono F'\"\n  assumes TR_top[simp]: \"\\<And>x. tr x top\"\n  assumes P_start[simp]: \"P x x'\"\n  assumes IS: \"\\<And>D D' x x'. \\<lbrakk> \\<And>x x'. P x x' \\<Longrightarrow> tr (D x) (D' x'); P x x'; RECT F = D \\<rbrakk> \\<Longrightarrow> tr (F D x) (F' D' x')\"\n  shows \"tr (RECT F x) (RECT F' x')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tr (REC\\<^sub>T F x) (REC\\<^sub>T F' x')", "unfolding RECT_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. tr (if trimono F then flatf_gfp F x else top)\n     (if trimono F' then flatf_gfp F' x' else top)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. tr (flatf_gfp F x) (flatf_gfp F' x')", "apply (rule flatf_gfp_transfer[where tr=tr and P=P])"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x. tr x top\n 2. monotone flatf_ge flatf_ge F\n 3. monotone flatf_ge flatf_ge F'\n 4. P x x'\n 5. \\<And>f f' x x'.\n       \\<lbrakk>\\<And>x x'. P x x' \\<Longrightarrow> tr (f x) (f' x');\n        P x x'; flatf_gfp F = f\\<rbrakk>\n       \\<Longrightarrow> tr (F f x) (F' f' x')", "apply (auto simp: trimonoD_flatf_ge)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f' x x'.\n       \\<lbrakk>\\<And>x x'.\n                   P x x' \\<Longrightarrow> tr (flatf_gfp F x) (f' x');\n        P x x'\\<rbrakk>\n       \\<Longrightarrow> tr (F (flatf_gfp F) x) (F' f' x')", "apply (rule IS)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>f' x x' xa x'a.\n       \\<lbrakk>\\<And>x x'.\n                   P x x' \\<Longrightarrow> tr (flatf_gfp F x) (f' x');\n        P x x'; P xa x'a\\<rbrakk>\n       \\<Longrightarrow> tr (flatf_gfp F xa) (f' x'a)\n 2. \\<And>f' x x'.\n       \\<lbrakk>\\<And>x x'.\n                   P x x' \\<Longrightarrow> tr (flatf_gfp F x) (f' x');\n        P x x'\\<rbrakk>\n       \\<Longrightarrow> P x x'\n 3. \\<And>f' x x'.\n       \\<lbrakk>\\<And>x x'.\n                   P x x' \\<Longrightarrow> tr (flatf_gfp F x) (f' x');\n        P x x'\\<rbrakk>\n       \\<Longrightarrow> REC\\<^sub>T F = flatf_gfp F", "apply (auto simp: RECT_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma RECT_transfer_rel':\n  assumes [simp]: \"trimono F\" \"trimono F'\"\n  assumes TR_top[simp]: \"\\<And>x. tr x top\"\n  assumes P_start[simp]: \"P x x'\"\n  assumes IS: \"\\<And>D D' x x'. \\<lbrakk> \\<And>x x'. P x x' \\<Longrightarrow> tr (D x) (D' x'); P x x' \\<rbrakk> \\<Longrightarrow> tr (F D x) (F' D' x')\"\n  shows \"tr (RECT F x) (RECT F' x')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tr (REC\\<^sub>T F x) (REC\\<^sub>T F' x')", "using RECT_transfer_rel[where tr=tr and P=P,OF assms(1,2,3,4)] IS"], ["proof (prove)\nusing this:\n  (\\<And>D D' x x'.\n      \\<lbrakk>\\<And>x x'. P x x' \\<Longrightarrow> tr (D x) (D' x');\n       P x x'; REC\\<^sub>T F = D\\<rbrakk>\n      \\<Longrightarrow> tr (F D x) (F' D' x')) \\<Longrightarrow>\n  tr (REC\\<^sub>T F x) (REC\\<^sub>T F' x')\n  \\<lbrakk>\\<And>x x'. P x x' \\<Longrightarrow> tr (?D x) (?D' x');\n   P ?x ?x'\\<rbrakk>\n  \\<Longrightarrow> tr (F ?D ?x) (F' ?D' ?x')\n\ngoal (1 subgoal):\n 1. tr (REC\\<^sub>T F x) (REC\\<^sub>T F' x')", "by blast"], ["", "end"]]}