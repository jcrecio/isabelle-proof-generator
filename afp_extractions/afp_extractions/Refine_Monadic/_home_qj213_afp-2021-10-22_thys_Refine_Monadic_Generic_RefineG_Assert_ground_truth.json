{"file_name": "/home/qj213/afp-2021-10-22/thys/Refine_Monadic/Generic/RefineG_Assert.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Refine_Monadic", "problem_names": ["lemma ASSERT_simps[simp,code]: \n      \"ASSERT True = return ()\"\n      \"ASSERT False = top\"", "lemma ASSUME_simps[simp,code]: \n      \"ASSUME True = return ()\"\n      \"ASSUME False = bot\"", "lemma le_ASSERTI: \"\\<lbrakk> \\<Phi> \\<Longrightarrow> M\\<le>M' \\<rbrakk> \\<Longrightarrow> M \\<le> bind (ASSERT \\<Phi>) (\\<lambda>_. M')\"", "lemma le_ASSERTI_pres: \"\\<lbrakk> \\<Phi> \\<Longrightarrow> M\\<le>bind (ASSERT \\<Phi>) (\\<lambda>_. M') \\<rbrakk> \n      \\<Longrightarrow> M \\<le> bind (ASSERT \\<Phi>) (\\<lambda>_. M')\"", "lemma ASSERT_leI: \"\\<lbrakk> \\<Phi>; \\<Phi> \\<Longrightarrow> M\\<le>M' \\<rbrakk> \\<Longrightarrow> bind (ASSERT \\<Phi>) (\\<lambda>_. M) \\<le> M'\"", "lemma ASSUME_leI: \"\\<lbrakk> \\<Phi> \\<Longrightarrow> M\\<le>M' \\<rbrakk> \\<Longrightarrow> bind (ASSUME \\<Phi>) (\\<lambda>_. M) \\<le> M'\"", "lemma ASSUME_leI_pres: \"\\<lbrakk> \\<Phi> \\<Longrightarrow> bind (ASSUME \\<Phi>) (\\<lambda>_. M)\\<le>M' \\<rbrakk> \n      \\<Longrightarrow> bind (ASSUME \\<Phi>) (\\<lambda>_. M) \\<le> M'\"", "lemma le_ASSUMEI: \"\\<lbrakk> \\<Phi>; \\<Phi> \\<Longrightarrow> M\\<le>M' \\<rbrakk> \\<Longrightarrow> M \\<le> bind (ASSUME \\<Phi>) (\\<lambda>_. M')\"", "lemmas [intro?] = ASSERT_leI le_ASSUMEI", "lemmas [intro?] = le_ASSERTI ASSUME_leI", "lemma ASSERT_le_iff: \n      \"bind (ASSERT \\<Phi>) (\\<lambda>_. S) \\<le> S' \\<longleftrightarrow> (S'\\<noteq>top \\<longrightarrow> \\<Phi>) \\<and> S\\<le>S'\"", "lemma ASSUME_le_iff:\n      \"bind (ASSUME \\<Phi>) (\\<lambda>_. S) \\<le> S' \\<longleftrightarrow> (\\<Phi> \\<longrightarrow> S\\<le>S')\"", "lemma le_ASSERT_iff:\n      \"S \\<le> bind (ASSERT \\<Phi>) (\\<lambda>_. S') \\<longleftrightarrow> (\\<Phi> \\<longrightarrow> S\\<le>S')\"", "lemma le_ASSUME_iff:\n      \"S \\<le> bind (ASSUME \\<Phi>) (\\<lambda>_. S') \\<longleftrightarrow> (S\\<noteq>bot \\<longrightarrow> \\<Phi>) \\<and> S\\<le>S'\"", "lemma transfer_ASSERT[refine_transfer]:\n      \"\\<lbrakk>\\<Phi> \\<Longrightarrow> \\<alpha> M \\<le> M'\\<rbrakk> \n      \\<Longrightarrow> \\<alpha> (cbind (cASSERT \\<Phi>) (\\<lambda>_. M)) \\<le> (abind (aASSERT \\<Phi>) (\\<lambda>_. M'))\"", "lemma transfer_ASSUME[refine_transfer]:\n      \"\\<lbrakk>\\<Phi>; \\<Phi> \\<Longrightarrow> \\<alpha> M \\<le> M'\\<rbrakk> \n      \\<Longrightarrow> \\<alpha> (cbind (cASSUME \\<Phi>) (\\<lambda>_. M)) \\<le> (abind (aASSUME \\<Phi>) (\\<lambda>_. M'))\"", "lemma transfer_ASSERT_remove[refine_transfer]: \n      \"\\<lbrakk> \\<Phi> \\<Longrightarrow> \\<alpha> M \\<le> M' \\<rbrakk> \\<Longrightarrow> \\<alpha> M \\<le> abind (aASSERT \\<Phi>) (\\<lambda>_. M')\"", "lemma transfer_ASSUME_remove[refine_transfer]: \n      \"\\<lbrakk> \\<Phi>; \\<Phi> \\<Longrightarrow> \\<alpha> M \\<le> M' \\<rbrakk> \\<Longrightarrow> \\<alpha> M \\<le> abind (aASSUME \\<Phi>) (\\<lambda>_. M')\""], "translations": [["", "lemma ASSERT_simps[simp,code]: \n      \"ASSERT True = return ()\"\n      \"ASSERT False = top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ASSERT True = return () &&& ASSERT False = top", "unfolding ASSERT_eq iASSERT_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if True then return () else top) = return () &&&\n    (if False then return () else top) = top", "by auto"], ["", "lemma ASSUME_simps[simp,code]: \n      \"ASSUME True = return ()\"\n      \"ASSUME False = bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ASSUME True = return () &&& ASSUME False = bot", "unfolding ASSUME_eq iASSUME_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if True then return () else bot) = return () &&&\n    (if False then return () else bot) = bot", "by auto"], ["", "lemma le_ASSERTI: \"\\<lbrakk> \\<Phi> \\<Longrightarrow> M\\<le>M' \\<rbrakk> \\<Longrightarrow> M \\<le> bind (ASSERT \\<Phi>) (\\<lambda>_. M')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Phi> \\<Longrightarrow> M \\<le> M') \\<Longrightarrow>\n    M \\<le> bind (ASSERT \\<Phi>) (\\<lambda>_. M')", "apply (cases \\<Phi>)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<Phi> \\<Longrightarrow> M \\<le> M'; \\<Phi>\\<rbrakk>\n    \\<Longrightarrow> M \\<le> bind (ASSERT \\<Phi>) (\\<lambda>_. M')\n 2. \\<lbrakk>\\<Phi> \\<Longrightarrow> M \\<le> M'; \\<not> \\<Phi>\\<rbrakk>\n    \\<Longrightarrow> M \\<le> bind (ASSERT \\<Phi>) (\\<lambda>_. M')", "by (auto simp: ibind_strict imonad1)"], ["", "lemma le_ASSERTI_pres: \"\\<lbrakk> \\<Phi> \\<Longrightarrow> M\\<le>bind (ASSERT \\<Phi>) (\\<lambda>_. M') \\<rbrakk> \n      \\<Longrightarrow> M \\<le> bind (ASSERT \\<Phi>) (\\<lambda>_. M')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Phi> \\<Longrightarrow>\n     M \\<le> bind (ASSERT \\<Phi>) (\\<lambda>_. M')) \\<Longrightarrow>\n    M \\<le> bind (ASSERT \\<Phi>) (\\<lambda>_. M')", "apply (cases \\<Phi>)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<Phi> \\<Longrightarrow>\n             M \\<le> bind (ASSERT \\<Phi>) (\\<lambda>_. M');\n     \\<Phi>\\<rbrakk>\n    \\<Longrightarrow> M \\<le> bind (ASSERT \\<Phi>) (\\<lambda>_. M')\n 2. \\<lbrakk>\\<Phi> \\<Longrightarrow>\n             M \\<le> bind (ASSERT \\<Phi>) (\\<lambda>_. M');\n     \\<not> \\<Phi>\\<rbrakk>\n    \\<Longrightarrow> M \\<le> bind (ASSERT \\<Phi>) (\\<lambda>_. M')", "by (auto simp: ibind_strict imonad1)"], ["", "lemma ASSERT_leI: \"\\<lbrakk> \\<Phi>; \\<Phi> \\<Longrightarrow> M\\<le>M' \\<rbrakk> \\<Longrightarrow> bind (ASSERT \\<Phi>) (\\<lambda>_. M) \\<le> M'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<Phi>; \\<Phi> \\<Longrightarrow> M \\<le> M'\\<rbrakk>\n    \\<Longrightarrow> bind (ASSERT \\<Phi>) (\\<lambda>_. M) \\<le> M'", "apply (cases \\<Phi>)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<Phi>; \\<Phi> \\<Longrightarrow> M \\<le> M'; \\<Phi>\\<rbrakk>\n    \\<Longrightarrow> bind (ASSERT \\<Phi>) (\\<lambda>_. M) \\<le> M'\n 2. \\<lbrakk>\\<Phi>; \\<Phi> \\<Longrightarrow> M \\<le> M';\n     \\<not> \\<Phi>\\<rbrakk>\n    \\<Longrightarrow> bind (ASSERT \\<Phi>) (\\<lambda>_. M) \\<le> M'", "by (auto simp: ibind_strict imonad1)"], ["", "lemma ASSUME_leI: \"\\<lbrakk> \\<Phi> \\<Longrightarrow> M\\<le>M' \\<rbrakk> \\<Longrightarrow> bind (ASSUME \\<Phi>) (\\<lambda>_. M) \\<le> M'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Phi> \\<Longrightarrow> M \\<le> M') \\<Longrightarrow>\n    bind (ASSUME \\<Phi>) (\\<lambda>_. M) \\<le> M'", "apply (cases \\<Phi>)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<Phi> \\<Longrightarrow> M \\<le> M'; \\<Phi>\\<rbrakk>\n    \\<Longrightarrow> bind (ASSUME \\<Phi>) (\\<lambda>_. M) \\<le> M'\n 2. \\<lbrakk>\\<Phi> \\<Longrightarrow> M \\<le> M'; \\<not> \\<Phi>\\<rbrakk>\n    \\<Longrightarrow> bind (ASSUME \\<Phi>) (\\<lambda>_. M) \\<le> M'", "by (auto simp: ibind_strict imonad1)"], ["", "lemma ASSUME_leI_pres: \"\\<lbrakk> \\<Phi> \\<Longrightarrow> bind (ASSUME \\<Phi>) (\\<lambda>_. M)\\<le>M' \\<rbrakk> \n      \\<Longrightarrow> bind (ASSUME \\<Phi>) (\\<lambda>_. M) \\<le> M'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Phi> \\<Longrightarrow>\n     bind (ASSUME \\<Phi>) (\\<lambda>_. M) \\<le> M') \\<Longrightarrow>\n    bind (ASSUME \\<Phi>) (\\<lambda>_. M) \\<le> M'", "apply (cases \\<Phi>)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<Phi> \\<Longrightarrow>\n             bind (ASSUME \\<Phi>) (\\<lambda>_. M) \\<le> M';\n     \\<Phi>\\<rbrakk>\n    \\<Longrightarrow> bind (ASSUME \\<Phi>) (\\<lambda>_. M) \\<le> M'\n 2. \\<lbrakk>\\<Phi> \\<Longrightarrow>\n             bind (ASSUME \\<Phi>) (\\<lambda>_. M) \\<le> M';\n     \\<not> \\<Phi>\\<rbrakk>\n    \\<Longrightarrow> bind (ASSUME \\<Phi>) (\\<lambda>_. M) \\<le> M'", "by (auto simp: ibind_strict imonad1)"], ["", "lemma le_ASSUMEI: \"\\<lbrakk> \\<Phi>; \\<Phi> \\<Longrightarrow> M\\<le>M' \\<rbrakk> \\<Longrightarrow> M \\<le> bind (ASSUME \\<Phi>) (\\<lambda>_. M')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<Phi>; \\<Phi> \\<Longrightarrow> M \\<le> M'\\<rbrakk>\n    \\<Longrightarrow> M \\<le> bind (ASSUME \\<Phi>) (\\<lambda>_. M')", "apply (cases \\<Phi>)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<Phi>; \\<Phi> \\<Longrightarrow> M \\<le> M'; \\<Phi>\\<rbrakk>\n    \\<Longrightarrow> M \\<le> bind (ASSUME \\<Phi>) (\\<lambda>_. M')\n 2. \\<lbrakk>\\<Phi>; \\<Phi> \\<Longrightarrow> M \\<le> M';\n     \\<not> \\<Phi>\\<rbrakk>\n    \\<Longrightarrow> M \\<le> bind (ASSUME \\<Phi>) (\\<lambda>_. M')", "by (auto simp: ibind_strict imonad1)"], ["", "text \\<open>The order of these declarations does matter!\\<close>"], ["", "lemmas [intro?] = ASSERT_leI le_ASSUMEI"], ["", "lemmas [intro?] = le_ASSERTI ASSUME_leI"], ["", "lemma ASSERT_le_iff: \n      \"bind (ASSERT \\<Phi>) (\\<lambda>_. S) \\<le> S' \\<longleftrightarrow> (S'\\<noteq>top \\<longrightarrow> \\<Phi>) \\<and> S\\<le>S'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (bind (ASSERT \\<Phi>) (\\<lambda>_. S) \\<le> S') =\n    ((S' \\<noteq> top \\<longrightarrow> \\<Phi>) \\<and> S \\<le> S')", "by (cases \\<Phi>) (auto simp: ibind_strict imonad1 simp: top_unique)"], ["", "lemma ASSUME_le_iff:\n      \"bind (ASSUME \\<Phi>) (\\<lambda>_. S) \\<le> S' \\<longleftrightarrow> (\\<Phi> \\<longrightarrow> S\\<le>S')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (bind (ASSUME \\<Phi>) (\\<lambda>_. S) \\<le> S') =\n    (\\<Phi> \\<longrightarrow> S \\<le> S')", "by (cases \\<Phi>) (auto simp: ibind_strict imonad1)"], ["", "lemma le_ASSERT_iff:\n      \"S \\<le> bind (ASSERT \\<Phi>) (\\<lambda>_. S') \\<longleftrightarrow> (\\<Phi> \\<longrightarrow> S\\<le>S')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (S \\<le> bind (ASSERT \\<Phi>) (\\<lambda>_. S')) =\n    (\\<Phi> \\<longrightarrow> S \\<le> S')", "by (cases \\<Phi>) (auto simp: ibind_strict imonad1)"], ["", "lemma le_ASSUME_iff:\n      \"S \\<le> bind (ASSUME \\<Phi>) (\\<lambda>_. S') \\<longleftrightarrow> (S\\<noteq>bot \\<longrightarrow> \\<Phi>) \\<and> S\\<le>S'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (S \\<le> bind (ASSUME \\<Phi>) (\\<lambda>_. S')) =\n    ((S \\<noteq> bot \\<longrightarrow> \\<Phi>) \\<and> S \\<le> S')", "by (cases \\<Phi>) (auto simp: ibind_strict imonad1 simp: bot_unique)"], ["", "end"], ["", "text \\<open>\n    This locale transfer's asserts and assumes. \n    To remove them, use the next locale.\n\\<close>"], ["", "locale transfer_generic_Assert = \n    c: generic_Assert cbind creturn cASSERT cASSUME +\n    a: generic_Assert abind areturn aASSERT aASSUME +\n    ordered_transfer \\<alpha>\n    for cbind :: \"('muc::complete_lattice) \n      \\<Rightarrow> (unit\\<Rightarrow>'mac) \\<Rightarrow> ('mac::complete_lattice)\" \n    and creturn :: \"unit \\<Rightarrow> 'muc\" and cASSERT and cASSUME\n    and abind :: \"('mua::complete_lattice) \n      \\<Rightarrow> (unit\\<Rightarrow>'maa) \\<Rightarrow> ('maa::complete_lattice)\"\n    and areturn :: \"unit \\<Rightarrow> 'mua\" and aASSERT and aASSUME\n    and \\<alpha> :: \"'mac \\<Rightarrow> 'maa\"\n  begin"], ["", "lemma transfer_ASSERT[refine_transfer]:\n      \"\\<lbrakk>\\<Phi> \\<Longrightarrow> \\<alpha> M \\<le> M'\\<rbrakk> \n      \\<Longrightarrow> \\<alpha> (cbind (cASSERT \\<Phi>) (\\<lambda>_. M)) \\<le> (abind (aASSERT \\<Phi>) (\\<lambda>_. M'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Phi> \\<Longrightarrow> \\<alpha> M \\<le> M') \\<Longrightarrow>\n    \\<alpha> (cbind (cASSERT \\<Phi>) (\\<lambda>_. M))\n    \\<le> abind (aASSERT \\<Phi>) (\\<lambda>_. M')", "apply (cases \\<Phi>)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<Phi> \\<Longrightarrow> \\<alpha> M \\<le> M'; \\<Phi>\\<rbrakk>\n    \\<Longrightarrow> \\<alpha> (cbind (cASSERT \\<Phi>) (\\<lambda>_. M))\n                      \\<le> abind (aASSERT \\<Phi>) (\\<lambda>_. M')\n 2. \\<lbrakk>\\<Phi> \\<Longrightarrow> \\<alpha> M \\<le> M';\n     \\<not> \\<Phi>\\<rbrakk>\n    \\<Longrightarrow> \\<alpha> (cbind (cASSERT \\<Phi>) (\\<lambda>_. M))\n                      \\<le> abind (aASSERT \\<Phi>) (\\<lambda>_. M')", "apply (auto simp: c.ibind_strict a.ibind_strict c.imonad1 a.imonad1)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma transfer_ASSUME[refine_transfer]:\n      \"\\<lbrakk>\\<Phi>; \\<Phi> \\<Longrightarrow> \\<alpha> M \\<le> M'\\<rbrakk> \n      \\<Longrightarrow> \\<alpha> (cbind (cASSUME \\<Phi>) (\\<lambda>_. M)) \\<le> (abind (aASSUME \\<Phi>) (\\<lambda>_. M'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<Phi>; \\<Phi> \\<Longrightarrow> \\<alpha> M \\<le> M'\\<rbrakk>\n    \\<Longrightarrow> \\<alpha> (cbind (cASSUME \\<Phi>) (\\<lambda>_. M))\n                      \\<le> abind (aASSUME \\<Phi>) (\\<lambda>_. M')", "apply (auto simp: c.ibind_strict a.ibind_strict c.imonad1 a.imonad1)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "locale transfer_generic_Assert_remove = \n    a: generic_Assert abind areturn aASSERT aASSUME +\n    transfer \\<alpha>\n    for abind :: \"('mua::complete_lattice) \n      \\<Rightarrow> (unit\\<Rightarrow>'maa) \\<Rightarrow> ('maa::complete_lattice)\"\n    and areturn :: \"unit \\<Rightarrow> 'mua\" and aASSERT and aASSUME\n    and \\<alpha> :: \"'mac \\<Rightarrow> 'maa\"\n  begin"], ["", "lemma transfer_ASSERT_remove[refine_transfer]: \n      \"\\<lbrakk> \\<Phi> \\<Longrightarrow> \\<alpha> M \\<le> M' \\<rbrakk> \\<Longrightarrow> \\<alpha> M \\<le> abind (aASSERT \\<Phi>) (\\<lambda>_. M')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Phi> \\<Longrightarrow> \\<alpha> M \\<le> M') \\<Longrightarrow>\n    \\<alpha> M \\<le> abind (aASSERT \\<Phi>) (\\<lambda>_. M')", "by (rule a.le_ASSERTI)"], ["", "lemma transfer_ASSUME_remove[refine_transfer]: \n      \"\\<lbrakk> \\<Phi>; \\<Phi> \\<Longrightarrow> \\<alpha> M \\<le> M' \\<rbrakk> \\<Longrightarrow> \\<alpha> M \\<le> abind (aASSUME \\<Phi>) (\\<lambda>_. M')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<Phi>; \\<Phi> \\<Longrightarrow> \\<alpha> M \\<le> M'\\<rbrakk>\n    \\<Longrightarrow> \\<alpha> M\n                      \\<le> abind (aASSUME \\<Phi>) (\\<lambda>_. M')", "by (rule a.le_ASSUMEI)"], ["", "end"], ["", "end"]]}