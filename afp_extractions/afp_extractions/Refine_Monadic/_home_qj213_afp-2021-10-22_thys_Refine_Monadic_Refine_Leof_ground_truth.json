{"file_name": "/home/qj213/afp-2021-10-22/thys/Refine_Monadic/Refine_Leof.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Refine_Monadic", "problem_names": ["lemma leofI[intro?]: \n    assumes \"nofail m \\<Longrightarrow> m \\<le> m'\" shows \"m \\<le>\\<^sub>n m'\"", "lemma leofD:  \n    assumes \"nofail m\"\n    assumes \"m \\<le>\\<^sub>n m'\"\n    shows \"m \\<le> m'\"", "lemma pw_leof_iff:\n    \"m \\<le>\\<^sub>n m' \\<longleftrightarrow> (nofail m \\<longrightarrow> (\\<forall>x. inres m x \\<longrightarrow> inres m' x))\"", "lemma le_by_leofI: \"\\<lbrakk> nofail m' \\<Longrightarrow> nofail m; m\\<le>\\<^sub>nm' \\<rbrakk> \\<Longrightarrow> m \\<le> m'\"", "lemma inres_leof_mono: \"m\\<le>\\<^sub>nm' \\<Longrightarrow> nofail m \\<Longrightarrow> inres m x \\<Longrightarrow> inres m' x\"", "lemma leof_trans[trans]: \"\\<lbrakk>a \\<le>\\<^sub>n RES X; RES X \\<le>\\<^sub>n c\\<rbrakk> \\<Longrightarrow> a \\<le>\\<^sub>n c\"", "lemma leof_trans_nofail: \"\\<lbrakk> a\\<le>\\<^sub>nb; nofail b; b\\<le>\\<^sub>nc \\<rbrakk> \\<Longrightarrow> a \\<le>\\<^sub>n c\"", "lemma leof_refl[simp]: \"a \\<le>\\<^sub>n a\"", "lemma leof_RES_UNIV[simp, intro!]: \"m \\<le>\\<^sub>n RES UNIV\"", "lemma leof_FAIL[simp, intro!]: \"m \\<le>\\<^sub>n FAIL\"", "lemma FAIL_leof[simp, intro!]: \"FAIL \\<le>\\<^sub>n m\"", "lemma leof_lift:\n    \"m \\<le> F \\<Longrightarrow> m \\<le>\\<^sub>n F\"", "lemma leof_RETURN_rule[refine_vcg]: \n    \"\\<Phi> m \\<Longrightarrow> RETURN m \\<le>\\<^sub>n SPEC \\<Phi>\"", "lemma leof_bind_rule[refine_vcg]: \n    \"\\<lbrakk> m \\<le>\\<^sub>n SPEC (\\<lambda>x. f x \\<le>\\<^sub>n SPEC \\<Phi>) \\<rbrakk> \\<Longrightarrow> m\\<bind>f \\<le>\\<^sub>n SPEC \\<Phi>\"", "lemma RETURN_leof_RES_iff[simp]: \"RETURN x \\<le>\\<^sub>n RES Y \\<longleftrightarrow> x\\<in>Y\"", "lemma RES_leof_RES_iff[simp]: \"RES X \\<le>\\<^sub>n RES Y \\<longleftrightarrow> X \\<subseteq> Y\"", "lemma leof_Let_rule[refine_vcg]: \"f x \\<le>\\<^sub>n SPEC \\<Phi> \\<Longrightarrow> Let x f \\<le>\\<^sub>n SPEC \\<Phi>\"", "lemma leof_If_rule[refine_vcg]: \n    \"\\<lbrakk>c \\<Longrightarrow> t \\<le>\\<^sub>n SPEC \\<Phi>; \\<not>c \\<Longrightarrow> e \\<le>\\<^sub>n SPEC \\<Phi>\\<rbrakk> \\<Longrightarrow> If c t e \\<le>\\<^sub>n SPEC \\<Phi>\"", "lemma leof_RES_rule[refine_vcg]:\n    \"\\<lbrakk>\\<And>x. \\<Psi> x \\<Longrightarrow> \\<Phi> x\\<rbrakk> \\<Longrightarrow> SPEC \\<Psi> \\<le>\\<^sub>n SPEC \\<Phi>\"\n    \"\\<lbrakk>\\<And>x. x\\<in>X \\<Longrightarrow> \\<Phi> x\\<rbrakk> \\<Longrightarrow> RES X \\<le>\\<^sub>n SPEC \\<Phi>\"", "lemma leof_True_rule: \"\\<lbrakk>\\<And>x. \\<Phi> x\\<rbrakk> \\<Longrightarrow> m \\<le>\\<^sub>n SPEC \\<Phi>\"", "lemma sup_leof_iff: \"(sup a b \\<le>\\<^sub>n m) \\<longleftrightarrow> (nofail a \\<and> nofail b \\<longrightarrow> a\\<le>\\<^sub>nm \\<and> b\\<le>\\<^sub>nm)\"", "lemma sup_leof_rule[refine_vcg]:\n    assumes \"\\<lbrakk>nofail a; nofail b\\<rbrakk> \\<Longrightarrow> a\\<le>\\<^sub>nm\"\n    assumes \"\\<lbrakk>nofail a; nofail b\\<rbrakk> \\<Longrightarrow> b\\<le>\\<^sub>nm\"\n    shows \"sup a b \\<le>\\<^sub>n m\"", "lemma leof_option_rule[refine_vcg]: \n  \"\\<lbrakk>v = None \\<Longrightarrow> S1 \\<le>\\<^sub>n SPEC \\<Phi>; \\<And>x. v = Some x \\<Longrightarrow> f2 x \\<le>\\<^sub>n SPEC \\<Phi>\\<rbrakk>\n    \\<Longrightarrow> (case v of None \\<Rightarrow> S1 | Some x \\<Rightarrow> f2 x) \\<le>\\<^sub>n SPEC \\<Phi>\"", "lemma ASSERT_leof_rule[refine_vcg]:\n    assumes \"\\<Phi> \\<Longrightarrow> m \\<le>\\<^sub>n m'\"\n    shows \"do {ASSERT \\<Phi>; m} \\<le>\\<^sub>n m'\"", "lemma leof_ASSERT_rule[refine_vcg]: \"\\<lbrakk>\\<Phi> \\<Longrightarrow> m \\<le>\\<^sub>n m'\\<rbrakk> \\<Longrightarrow> m \\<le>\\<^sub>n ASSERT \\<Phi> \\<then> m'\"", "lemma leof_ASSERT_refine_rule[refine]: \"\\<lbrakk>\\<Phi> \\<Longrightarrow> m \\<le>\\<^sub>n \\<Down>R m'\\<rbrakk> \\<Longrightarrow> m \\<le>\\<^sub>n \\<Down>R (ASSERT \\<Phi> \\<then> m')\"", "lemma ASSUME_leof_iff: \"(ASSUME \\<Phi> \\<le>\\<^sub>n SPEC \\<Psi>) \\<longleftrightarrow> (\\<Phi> \\<longrightarrow> \\<Psi> ())\"", "lemma ASSUME_leof_rule[refine_vcg]: \n    assumes \"\\<Phi> \\<Longrightarrow> \\<Psi> ()\" \n    shows \"ASSUME \\<Phi> \\<le>\\<^sub>n SPEC \\<Psi>\"", "lemma SPEC_rule_conj_leofI1:\n    assumes \"m \\<le> SPEC \\<Phi>\"\n    assumes \"m \\<le>\\<^sub>n SPEC \\<Psi>\"\n    shows \"m \\<le> SPEC (\\<lambda>s. \\<Phi> s \\<and> \\<Psi> s)\"", "lemma SPEC_rule_conj_leofI2:\n    assumes \"m \\<le>\\<^sub>n SPEC \\<Phi>\"\n    assumes \"m \\<le> SPEC \\<Psi>\"\n    shows \"m \\<le> SPEC (\\<lambda>s. \\<Phi> s \\<and> \\<Psi> s)\"", "lemma SPEC_rule_leof_conjI: \n    assumes \"m \\<le>\\<^sub>n SPEC \\<Phi>\" \"m \\<le>\\<^sub>n SPEC \\<Psi>\"\n    shows \"m \\<le>\\<^sub>n SPEC (\\<lambda>x. \\<Phi> x \\<and> \\<Psi> x)\"", "lemma leof_use_spec_rule:\n    assumes \"m \\<le>\\<^sub>n SPEC \\<Psi>\"\n    assumes \"m \\<le>\\<^sub>n SPEC (\\<lambda>s. \\<Psi> s \\<longrightarrow> \\<Phi> s)\"\n    shows \"m \\<le>\\<^sub>n SPEC \\<Phi>\"", "lemma use_spec_leof_rule:\n    assumes \"m \\<le>\\<^sub>n SPEC \\<Psi>\"\n    assumes \"m \\<le> SPEC (\\<lambda>s. \\<Psi> s \\<longrightarrow> \\<Phi> s)\"\n    shows \"m \\<le> SPEC \\<Phi>\"", "lemma leof_strengthen_SPEC: \n    \"m \\<le>\\<^sub>n SPEC \\<Phi> \\<Longrightarrow> m \\<le>\\<^sub>n SPEC (\\<lambda>x. inres m x \\<and> \\<Phi> x)\"", "lemma build_rel_SPEC_leof: \n    assumes \"m \\<le>\\<^sub>n SPEC (\\<lambda>x. I x \\<and> \\<Phi> (\\<alpha> x))\"  \n    shows \"m \\<le>\\<^sub>n \\<Down>(br \\<alpha> I) (SPEC \\<Phi>)\"", "lemma RETURN_as_SPEC_refine_leof[refine2]:\n    assumes \"M \\<le>\\<^sub>n SPEC (\\<lambda>c. (c,a)\\<in>R)\"\n    shows \"M \\<le>\\<^sub>n \\<Down>R (RETURN a)\"", "lemma ASSERT_leof_defI:\n    assumes \"c \\<equiv> do { ASSERT \\<Phi>; m'}\"\n    assumes \"\\<Phi> \\<Longrightarrow> m' \\<le>\\<^sub>n m\"\n    shows \"c \\<le>\\<^sub>n m\"", "lemma leof_fun_conv_le: \n    \"(f x \\<le>\\<^sub>n M x) \\<longleftrightarrow> (f x \\<le> (if nofail (f x) then M x else FAIL))\"", "lemma leof_add_nofailI: \"\\<lbrakk> nofail m \\<Longrightarrow> m\\<le>\\<^sub>nm' \\<rbrakk> \\<Longrightarrow> m\\<le>\\<^sub>nm'\"", "lemma leof_cons_rule[refine_vcg_cons]: \n    assumes \"m \\<le>\\<^sub>n SPEC Q\"\n    assumes \"\\<And>x. Q x \\<Longrightarrow> P x\"  \n    shows \"m \\<le>\\<^sub>n SPEC P\"", "lemma RECT_rule_leof:\n  assumes WF: \"wf (V::('x\\<times>'x) set)\"\n  assumes I0: \"pre (x::'x)\"\n  assumes IS: \"\\<And>f x. \\<lbrakk> \\<And>x'. \\<lbrakk>pre x'; (x',x)\\<in>V\\<rbrakk> \\<Longrightarrow> f x' \\<le>\\<^sub>n M x'; pre x; \n                        RECT body = f\n    \\<rbrakk> \\<Longrightarrow> body f x \\<le>\\<^sub>n M x\"\n  shows \"RECT body x \\<le>\\<^sub>n M x\""], "translations": [["", "lemma leofI[intro?]: \n    assumes \"nofail m \\<Longrightarrow> m \\<le> m'\" shows \"m \\<le>\\<^sub>n m'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<le>\\<^sub>n m'", "using assms"], ["proof (prove)\nusing this:\n  nofail m \\<Longrightarrow> m \\<le> m'\n\ngoal (1 subgoal):\n 1. m \\<le>\\<^sub>n m'", "unfolding le_or_fail_def"], ["proof (prove)\nusing this:\n  nofail m \\<Longrightarrow> m \\<le> m'\n\ngoal (1 subgoal):\n 1. nofail m \\<longrightarrow> m \\<le> m'", "by auto"], ["", "lemma leofD:  \n    assumes \"nofail m\"\n    assumes \"m \\<le>\\<^sub>n m'\"\n    shows \"m \\<le> m'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<le> m'", "using assms"], ["proof (prove)\nusing this:\n  nofail m\n  m \\<le>\\<^sub>n m'\n\ngoal (1 subgoal):\n 1. m \\<le> m'", "unfolding le_or_fail_def"], ["proof (prove)\nusing this:\n  nofail m\n  nofail m \\<longrightarrow> m \\<le> m'\n\ngoal (1 subgoal):\n 1. m \\<le> m'", "by blast"], ["", "lemma pw_leof_iff:\n    \"m \\<le>\\<^sub>n m' \\<longleftrightarrow> (nofail m \\<longrightarrow> (\\<forall>x. inres m x \\<longrightarrow> inres m' x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (m \\<le>\\<^sub>n m') =\n    (nofail m \\<longrightarrow>\n     (\\<forall>x. inres m x \\<longrightarrow> inres m' x))", "unfolding le_or_fail_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (nofail m \\<longrightarrow> m \\<le> m') =\n    (nofail m \\<longrightarrow>\n     (\\<forall>x. inres m x \\<longrightarrow> inres m' x))", "by (auto simp add: pw_le_iff refine_pw_simps)"], ["", "lemma le_by_leofI: \"\\<lbrakk> nofail m' \\<Longrightarrow> nofail m; m\\<le>\\<^sub>nm' \\<rbrakk> \\<Longrightarrow> m \\<le> m'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>nofail m' \\<Longrightarrow> nofail m;\n     m \\<le>\\<^sub>n m'\\<rbrakk>\n    \\<Longrightarrow> m \\<le> m'", "by (auto simp: pw_le_iff pw_leof_iff)"], ["", "lemma inres_leof_mono: \"m\\<le>\\<^sub>nm' \\<Longrightarrow> nofail m \\<Longrightarrow> inres m x \\<Longrightarrow> inres m' x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>m \\<le>\\<^sub>n m'; nofail m; inres m x\\<rbrakk>\n    \\<Longrightarrow> inres m' x", "by (auto simp: pw_leof_iff)"], ["", "lemma leof_trans[trans]: \"\\<lbrakk>a \\<le>\\<^sub>n RES X; RES X \\<le>\\<^sub>n c\\<rbrakk> \\<Longrightarrow> a \\<le>\\<^sub>n c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<le>\\<^sub>n RES X; RES X \\<le>\\<^sub>n c\\<rbrakk>\n    \\<Longrightarrow> a \\<le>\\<^sub>n c", "by (auto simp: pw_leof_iff)"], ["", "lemma leof_trans_nofail: \"\\<lbrakk> a\\<le>\\<^sub>nb; nofail b; b\\<le>\\<^sub>nc \\<rbrakk> \\<Longrightarrow> a \\<le>\\<^sub>n c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<le>\\<^sub>n b; nofail b; b \\<le>\\<^sub>n c\\<rbrakk>\n    \\<Longrightarrow> a \\<le>\\<^sub>n c", "by (auto simp: pw_leof_iff)"], ["", "lemma leof_refl[simp]: \"a \\<le>\\<^sub>n a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<le>\\<^sub>n a", "by (auto simp: pw_leof_iff)"], ["", "lemma leof_RES_UNIV[simp, intro!]: \"m \\<le>\\<^sub>n RES UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<le>\\<^sub>n RES UNIV", "by (auto simp: pw_leof_iff)"], ["", "lemma leof_FAIL[simp, intro!]: \"m \\<le>\\<^sub>n FAIL\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<le>\\<^sub>n FAIL", "by (auto simp: pw_leof_iff)"], ["", "lemma FAIL_leof[simp, intro!]: \"FAIL \\<le>\\<^sub>n m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. FAIL \\<le>\\<^sub>n m", "by (auto simp: le_or_fail_def)"], ["", "lemma leof_lift:\n    \"m \\<le> F \\<Longrightarrow> m \\<le>\\<^sub>n F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<le> F \\<Longrightarrow> m \\<le>\\<^sub>n F", "by (auto simp add: pw_leof_iff pw_le_iff)"], ["", "lemma leof_RETURN_rule[refine_vcg]: \n    \"\\<Phi> m \\<Longrightarrow> RETURN m \\<le>\\<^sub>n SPEC \\<Phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Phi> m \\<Longrightarrow> RETURN m \\<le>\\<^sub>n SPEC \\<Phi>", "by (simp add: pw_leof_iff)"], ["", "lemma leof_bind_rule[refine_vcg]: \n    \"\\<lbrakk> m \\<le>\\<^sub>n SPEC (\\<lambda>x. f x \\<le>\\<^sub>n SPEC \\<Phi>) \\<rbrakk> \\<Longrightarrow> m\\<bind>f \\<le>\\<^sub>n SPEC \\<Phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<le>\\<^sub>n\n    SPEC (\\<lambda>x. f x \\<le>\\<^sub>n SPEC \\<Phi>) \\<Longrightarrow>\n    m \\<bind> f \\<le>\\<^sub>n SPEC \\<Phi>", "by (auto simp add: pw_leof_iff refine_pw_simps)"], ["", "lemma RETURN_leof_RES_iff[simp]: \"RETURN x \\<le>\\<^sub>n RES Y \\<longleftrightarrow> x\\<in>Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (RETURN x \\<le>\\<^sub>n RES Y) = (x \\<in> Y)", "by (auto simp add: pw_leof_iff refine_pw_simps)"], ["", "lemma RES_leof_RES_iff[simp]: \"RES X \\<le>\\<^sub>n RES Y \\<longleftrightarrow> X \\<subseteq> Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (RES X \\<le>\\<^sub>n RES Y) = (X \\<subseteq> Y)", "by (auto simp add: pw_leof_iff refine_pw_simps)"], ["", "lemma leof_Let_rule[refine_vcg]: \"f x \\<le>\\<^sub>n SPEC \\<Phi> \\<Longrightarrow> Let x f \\<le>\\<^sub>n SPEC \\<Phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f x \\<le>\\<^sub>n SPEC \\<Phi> \\<Longrightarrow>\n    Let x f \\<le>\\<^sub>n SPEC \\<Phi>", "by simp"], ["", "lemma leof_If_rule[refine_vcg]: \n    \"\\<lbrakk>c \\<Longrightarrow> t \\<le>\\<^sub>n SPEC \\<Phi>; \\<not>c \\<Longrightarrow> e \\<le>\\<^sub>n SPEC \\<Phi>\\<rbrakk> \\<Longrightarrow> If c t e \\<le>\\<^sub>n SPEC \\<Phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>c \\<Longrightarrow> t \\<le>\\<^sub>n SPEC \\<Phi>;\n     \\<not> c \\<Longrightarrow> e \\<le>\\<^sub>n SPEC \\<Phi>\\<rbrakk>\n    \\<Longrightarrow> (if c then t else e) \\<le>\\<^sub>n SPEC \\<Phi>", "by simp"], ["", "lemma leof_RES_rule[refine_vcg]:\n    \"\\<lbrakk>\\<And>x. \\<Psi> x \\<Longrightarrow> \\<Phi> x\\<rbrakk> \\<Longrightarrow> SPEC \\<Psi> \\<le>\\<^sub>n SPEC \\<Phi>\"\n    \"\\<lbrakk>\\<And>x. x\\<in>X \\<Longrightarrow> \\<Phi> x\\<rbrakk> \\<Longrightarrow> RES X \\<le>\\<^sub>n SPEC \\<Phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<And>x. \\<Psi> x \\<Longrightarrow> \\<Phi> x) \\<Longrightarrow>\n     SPEC \\<Psi> \\<le>\\<^sub>n SPEC \\<Phi>) &&&\n    ((\\<And>x. x \\<in> X \\<Longrightarrow> \\<Phi> x) \\<Longrightarrow>\n     RES X \\<le>\\<^sub>n SPEC \\<Phi>)", "by auto"], ["", "lemma leof_True_rule: \"\\<lbrakk>\\<And>x. \\<Phi> x\\<rbrakk> \\<Longrightarrow> m \\<le>\\<^sub>n SPEC \\<Phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x. \\<Phi> x) \\<Longrightarrow> m \\<le>\\<^sub>n SPEC \\<Phi>", "by (auto simp add: pw_leof_iff refine_pw_simps)"], ["", "lemma sup_leof_iff: \"(sup a b \\<le>\\<^sub>n m) \\<longleftrightarrow> (nofail a \\<and> nofail b \\<longrightarrow> a\\<le>\\<^sub>nm \\<and> b\\<le>\\<^sub>nm)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (sup a b \\<le>\\<^sub>n m) =\n    (nofail a \\<and> nofail b \\<longrightarrow>\n     a \\<le>\\<^sub>n m \\<and> b \\<le>\\<^sub>n m)", "by (auto simp: pw_leof_iff refine_pw_simps)"], ["", "lemma sup_leof_rule[refine_vcg]:\n    assumes \"\\<lbrakk>nofail a; nofail b\\<rbrakk> \\<Longrightarrow> a\\<le>\\<^sub>nm\"\n    assumes \"\\<lbrakk>nofail a; nofail b\\<rbrakk> \\<Longrightarrow> b\\<le>\\<^sub>nm\"\n    shows \"sup a b \\<le>\\<^sub>n m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sup a b \\<le>\\<^sub>n m", "using assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>nofail a; nofail b\\<rbrakk> \\<Longrightarrow> a \\<le>\\<^sub>n m\n  \\<lbrakk>nofail a; nofail b\\<rbrakk> \\<Longrightarrow> b \\<le>\\<^sub>n m\n\ngoal (1 subgoal):\n 1. sup a b \\<le>\\<^sub>n m", "by (auto simp: pw_leof_iff refine_pw_simps)"], ["", "lemma leof_option_rule[refine_vcg]: \n  \"\\<lbrakk>v = None \\<Longrightarrow> S1 \\<le>\\<^sub>n SPEC \\<Phi>; \\<And>x. v = Some x \\<Longrightarrow> f2 x \\<le>\\<^sub>n SPEC \\<Phi>\\<rbrakk>\n    \\<Longrightarrow> (case v of None \\<Rightarrow> S1 | Some x \\<Rightarrow> f2 x) \\<le>\\<^sub>n SPEC \\<Phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>v = None \\<Longrightarrow> S1 \\<le>\\<^sub>n SPEC \\<Phi>;\n     \\<And>x.\n        v = Some x \\<Longrightarrow> f2 x \\<le>\\<^sub>n SPEC \\<Phi>\\<rbrakk>\n    \\<Longrightarrow> (case v of None \\<Rightarrow> S1\n                       | Some x \\<Rightarrow> f2 x) \\<le>\\<^sub>n\n                      SPEC \\<Phi>", "by (cases v) auto"], ["", "lemma ASSERT_leof_rule[refine_vcg]:\n    assumes \"\\<Phi> \\<Longrightarrow> m \\<le>\\<^sub>n m'\"\n    shows \"do {ASSERT \\<Phi>; m} \\<le>\\<^sub>n m'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ASSERT \\<Phi> \\<bind> (\\<lambda>_. m) \\<le>\\<^sub>n m'", "using assms"], ["proof (prove)\nusing this:\n  \\<Phi> \\<Longrightarrow> m \\<le>\\<^sub>n m'\n\ngoal (1 subgoal):\n 1. ASSERT \\<Phi> \\<bind> (\\<lambda>_. m) \\<le>\\<^sub>n m'", "by (cases \\<Phi>, auto simp: pw_leof_iff)"], ["", "lemma leof_ASSERT_rule[refine_vcg]: \"\\<lbrakk>\\<Phi> \\<Longrightarrow> m \\<le>\\<^sub>n m'\\<rbrakk> \\<Longrightarrow> m \\<le>\\<^sub>n ASSERT \\<Phi> \\<then> m'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Phi> \\<Longrightarrow> m \\<le>\\<^sub>n m') \\<Longrightarrow>\n    m \\<le>\\<^sub>n ASSERT \\<Phi> \\<bind> (\\<lambda>_. m')", "by (auto simp: pw_leof_iff refine_pw_simps)"], ["", "lemma leof_ASSERT_refine_rule[refine]: \"\\<lbrakk>\\<Phi> \\<Longrightarrow> m \\<le>\\<^sub>n \\<Down>R m'\\<rbrakk> \\<Longrightarrow> m \\<le>\\<^sub>n \\<Down>R (ASSERT \\<Phi> \\<then> m')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Phi> \\<Longrightarrow>\n     m \\<le>\\<^sub>n \\<Down> R m') \\<Longrightarrow>\n    m \\<le>\\<^sub>n \\<Down> R (ASSERT \\<Phi> \\<bind> (\\<lambda>_. m'))", "by (auto simp: pw_leof_iff refine_pw_simps)"], ["", "lemma ASSUME_leof_iff: \"(ASSUME \\<Phi> \\<le>\\<^sub>n SPEC \\<Psi>) \\<longleftrightarrow> (\\<Phi> \\<longrightarrow> \\<Psi> ())\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ASSUME \\<Phi> \\<le>\\<^sub>n SPEC \\<Psi>) =\n    (\\<Phi> \\<longrightarrow> \\<Psi> ())", "by (auto simp: pw_leof_iff)"], ["", "lemma ASSUME_leof_rule[refine_vcg]: \n    assumes \"\\<Phi> \\<Longrightarrow> \\<Psi> ()\" \n    shows \"ASSUME \\<Phi> \\<le>\\<^sub>n SPEC \\<Psi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ASSUME \\<Phi> \\<le>\\<^sub>n SPEC \\<Psi>", "using assms"], ["proof (prove)\nusing this:\n  \\<Phi> \\<Longrightarrow> \\<Psi> ()\n\ngoal (1 subgoal):\n 1. ASSUME \\<Phi> \\<le>\\<^sub>n SPEC \\<Psi>", "by (auto simp: ASSUME_leof_iff)"], ["", "lemma SPEC_rule_conj_leofI1:\n    assumes \"m \\<le> SPEC \\<Phi>\"\n    assumes \"m \\<le>\\<^sub>n SPEC \\<Psi>\"\n    shows \"m \\<le> SPEC (\\<lambda>s. \\<Phi> s \\<and> \\<Psi> s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<le> SPEC (\\<lambda>s. \\<Phi> s \\<and> \\<Psi> s)", "using assms"], ["proof (prove)\nusing this:\n  m \\<le> SPEC \\<Phi>\n  m \\<le>\\<^sub>n SPEC \\<Psi>\n\ngoal (1 subgoal):\n 1. m \\<le> SPEC (\\<lambda>s. \\<Phi> s \\<and> \\<Psi> s)", "by (auto simp: pw_le_iff pw_leof_iff)"], ["", "lemma SPEC_rule_conj_leofI2:\n    assumes \"m \\<le>\\<^sub>n SPEC \\<Phi>\"\n    assumes \"m \\<le> SPEC \\<Psi>\"\n    shows \"m \\<le> SPEC (\\<lambda>s. \\<Phi> s \\<and> \\<Psi> s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<le> SPEC (\\<lambda>s. \\<Phi> s \\<and> \\<Psi> s)", "using assms"], ["proof (prove)\nusing this:\n  m \\<le>\\<^sub>n SPEC \\<Phi>\n  m \\<le> SPEC \\<Psi>\n\ngoal (1 subgoal):\n 1. m \\<le> SPEC (\\<lambda>s. \\<Phi> s \\<and> \\<Psi> s)", "by (auto simp: pw_le_iff pw_leof_iff)"], ["", "lemma SPEC_rule_leof_conjI: \n    assumes \"m \\<le>\\<^sub>n SPEC \\<Phi>\" \"m \\<le>\\<^sub>n SPEC \\<Psi>\"\n    shows \"m \\<le>\\<^sub>n SPEC (\\<lambda>x. \\<Phi> x \\<and> \\<Psi> x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<le>\\<^sub>n SPEC (\\<lambda>x. \\<Phi> x \\<and> \\<Psi> x)", "using assms"], ["proof (prove)\nusing this:\n  m \\<le>\\<^sub>n SPEC \\<Phi>\n  m \\<le>\\<^sub>n SPEC \\<Psi>\n\ngoal (1 subgoal):\n 1. m \\<le>\\<^sub>n SPEC (\\<lambda>x. \\<Phi> x \\<and> \\<Psi> x)", "by (auto simp: pw_leof_iff)"], ["", "lemma leof_use_spec_rule:\n    assumes \"m \\<le>\\<^sub>n SPEC \\<Psi>\"\n    assumes \"m \\<le>\\<^sub>n SPEC (\\<lambda>s. \\<Psi> s \\<longrightarrow> \\<Phi> s)\"\n    shows \"m \\<le>\\<^sub>n SPEC \\<Phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<le>\\<^sub>n SPEC \\<Phi>", "using assms"], ["proof (prove)\nusing this:\n  m \\<le>\\<^sub>n SPEC \\<Psi>\n  m \\<le>\\<^sub>n SPEC (\\<lambda>s. \\<Psi> s \\<longrightarrow> \\<Phi> s)\n\ngoal (1 subgoal):\n 1. m \\<le>\\<^sub>n SPEC \\<Phi>", "by (auto simp: pw_leof_iff refine_pw_simps)"], ["", "lemma use_spec_leof_rule:\n    assumes \"m \\<le>\\<^sub>n SPEC \\<Psi>\"\n    assumes \"m \\<le> SPEC (\\<lambda>s. \\<Psi> s \\<longrightarrow> \\<Phi> s)\"\n    shows \"m \\<le> SPEC \\<Phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<le> SPEC \\<Phi>", "using assms"], ["proof (prove)\nusing this:\n  m \\<le>\\<^sub>n SPEC \\<Psi>\n  m \\<le> SPEC (\\<lambda>s. \\<Psi> s \\<longrightarrow> \\<Phi> s)\n\ngoal (1 subgoal):\n 1. m \\<le> SPEC \\<Phi>", "by (auto simp: pw_leof_iff pw_le_iff refine_pw_simps)"], ["", "lemma leof_strengthen_SPEC: \n    \"m \\<le>\\<^sub>n SPEC \\<Phi> \\<Longrightarrow> m \\<le>\\<^sub>n SPEC (\\<lambda>x. inres m x \\<and> \\<Phi> x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<le>\\<^sub>n SPEC \\<Phi> \\<Longrightarrow>\n    m \\<le>\\<^sub>n SPEC (\\<lambda>x. inres m x \\<and> \\<Phi> x)", "by (auto simp: pw_leof_iff)"], ["", "lemma build_rel_SPEC_leof: \n    assumes \"m \\<le>\\<^sub>n SPEC (\\<lambda>x. I x \\<and> \\<Phi> (\\<alpha> x))\"  \n    shows \"m \\<le>\\<^sub>n \\<Down>(br \\<alpha> I) (SPEC \\<Phi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<le>\\<^sub>n \\<Down> (br \\<alpha> I) (SPEC \\<Phi>)", "using assms"], ["proof (prove)\nusing this:\n  m \\<le>\\<^sub>n SPEC (\\<lambda>x. I x \\<and> \\<Phi> (\\<alpha> x))\n\ngoal (1 subgoal):\n 1. m \\<le>\\<^sub>n \\<Down> (br \\<alpha> I) (SPEC \\<Phi>)", "by (auto simp: build_rel_SPEC_conv)"], ["", "lemma RETURN_as_SPEC_refine_leof[refine2]:\n    assumes \"M \\<le>\\<^sub>n SPEC (\\<lambda>c. (c,a)\\<in>R)\"\n    shows \"M \\<le>\\<^sub>n \\<Down>R (RETURN a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M \\<le>\\<^sub>n \\<Down> R (RETURN a)", "using assms"], ["proof (prove)\nusing this:\n  M \\<le>\\<^sub>n SPEC (\\<lambda>c. (c, a) \\<in> R)\n\ngoal (1 subgoal):\n 1. M \\<le>\\<^sub>n \\<Down> R (RETURN a)", "by (simp add: pw_leof_iff refine_pw_simps)"], ["", "lemma ASSERT_leof_defI:\n    assumes \"c \\<equiv> do { ASSERT \\<Phi>; m'}\"\n    assumes \"\\<Phi> \\<Longrightarrow> m' \\<le>\\<^sub>n m\"\n    shows \"c \\<le>\\<^sub>n m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c \\<le>\\<^sub>n m", "using assms"], ["proof (prove)\nusing this:\n  c \\<equiv> ASSERT \\<Phi> \\<bind> (\\<lambda>_. m')\n  \\<Phi> \\<Longrightarrow> m' \\<le>\\<^sub>n m\n\ngoal (1 subgoal):\n 1. c \\<le>\\<^sub>n m", "by (auto simp: pw_leof_iff refine_pw_simps)"], ["", "lemma leof_fun_conv_le: \n    \"(f x \\<le>\\<^sub>n M x) \\<longleftrightarrow> (f x \\<le> (if nofail (f x) then M x else FAIL))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f x \\<le>\\<^sub>n M x) =\n    (f x \\<le> (if nofail (f x) then M x else FAIL))", "by (auto simp: pw_le_iff pw_leof_iff)"], ["", "lemma leof_add_nofailI: \"\\<lbrakk> nofail m \\<Longrightarrow> m\\<le>\\<^sub>nm' \\<rbrakk> \\<Longrightarrow> m\\<le>\\<^sub>nm'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (nofail m \\<Longrightarrow> m \\<le>\\<^sub>n m') \\<Longrightarrow>\n    m \\<le>\\<^sub>n m'", "by (auto simp: pw_le_iff pw_leof_iff)"], ["", "lemma leof_cons_rule[refine_vcg_cons]: \n    assumes \"m \\<le>\\<^sub>n SPEC Q\"\n    assumes \"\\<And>x. Q x \\<Longrightarrow> P x\"  \n    shows \"m \\<le>\\<^sub>n SPEC P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<le>\\<^sub>n SPEC P", "using assms"], ["proof (prove)\nusing this:\n  m \\<le>\\<^sub>n SPEC Q\n  Q ?x \\<Longrightarrow> P ?x\n\ngoal (1 subgoal):\n 1. m \\<le>\\<^sub>n SPEC P", "by (auto simp: pw_le_iff pw_leof_iff)"], ["", "lemma RECT_rule_leof:\n  assumes WF: \"wf (V::('x\\<times>'x) set)\"\n  assumes I0: \"pre (x::'x)\"\n  assumes IS: \"\\<And>f x. \\<lbrakk> \\<And>x'. \\<lbrakk>pre x'; (x',x)\\<in>V\\<rbrakk> \\<Longrightarrow> f x' \\<le>\\<^sub>n M x'; pre x; \n                        RECT body = f\n    \\<rbrakk> \\<Longrightarrow> body f x \\<le>\\<^sub>n M x\"\n  shows \"RECT body x \\<le>\\<^sub>n M x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. REC\\<^sub>T body x \\<le>\\<^sub>n M x", "apply (cases \"\\<not>trimono body\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<not> trimono body \\<Longrightarrow>\n    REC\\<^sub>T body x \\<le>\\<^sub>n M x\n 2. \\<not> \\<not> trimono body \\<Longrightarrow>\n    REC\\<^sub>T body x \\<le>\\<^sub>n M x", "apply (simp add: RECT_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> \\<not> trimono body \\<Longrightarrow>\n    REC\\<^sub>T body x \\<le>\\<^sub>n M x", "using assms"], ["proof (prove)\nusing this:\n  wf V\n  pre x\n  \\<lbrakk>\\<And>x'.\n              \\<lbrakk>pre x'; (x', ?x) \\<in> V\\<rbrakk>\n              \\<Longrightarrow> ?f x' \\<le>\\<^sub>n M x';\n   pre ?x; REC\\<^sub>T body = ?f\\<rbrakk>\n  \\<Longrightarrow> body ?f ?x \\<le>\\<^sub>n M ?x\n\ngoal (1 subgoal):\n 1. \\<not> \\<not> trimono body \\<Longrightarrow>\n    REC\\<^sub>T body x \\<le>\\<^sub>n M x", "unfolding leof_fun_conv_le"], ["proof (prove)\nusing this:\n  wf V\n  pre x\n  \\<lbrakk>\\<And>x'.\n              \\<lbrakk>pre x'; (x', ?x) \\<in> V\\<rbrakk>\n              \\<Longrightarrow> ?f x'\n                                \\<le> (if nofail (?f x') then M x'\n else FAIL);\n   pre ?x; REC\\<^sub>T body = ?f\\<rbrakk>\n  \\<Longrightarrow> body ?f ?x\n                    \\<le> (if nofail (body ?f ?x) then M ?x else FAIL)\n\ngoal (1 subgoal):\n 1. \\<not> \\<not> trimono body \\<Longrightarrow>\n    REC\\<^sub>T body x\n    \\<le> (if nofail (REC\\<^sub>T body x) then M x else FAIL)", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> \\<not> trimono body; wf V; pre x;\n     \\<And>x f.\n        \\<lbrakk>\\<And>x'.\n                    \\<lbrakk>pre x'; (x', x) \\<in> V\\<rbrakk>\n                    \\<Longrightarrow> f x'\n\\<le> (if nofail (f x') then M x' else FAIL);\n         pre x; REC\\<^sub>T body = f\\<rbrakk>\n        \\<Longrightarrow> body f x\n                          \\<le> (if nofail (body f x) then M x\n                                 else FAIL)\\<rbrakk>\n    \\<Longrightarrow> REC\\<^sub>T body x\n                      \\<le> (if nofail (REC\\<^sub>T body x) then M x\n                             else FAIL)", "apply (rule RECT_rule[where pre=pre and V=V])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>\\<not> \\<not> trimono body; wf V; pre x;\n     \\<And>x f.\n        \\<lbrakk>\\<And>x'.\n                    \\<lbrakk>pre x'; (x', x) \\<in> V\\<rbrakk>\n                    \\<Longrightarrow> f x'\n\\<le> (if nofail (f x') then M x' else FAIL);\n         pre x; REC\\<^sub>T body = f\\<rbrakk>\n        \\<Longrightarrow> body f x\n                          \\<le> (if nofail (body f x) then M x\n                                 else FAIL)\\<rbrakk>\n    \\<Longrightarrow> trimono body\n 2. \\<lbrakk>\\<not> \\<not> trimono body; wf V; pre x;\n     \\<And>x f.\n        \\<lbrakk>\\<And>x'.\n                    \\<lbrakk>pre x'; (x', x) \\<in> V\\<rbrakk>\n                    \\<Longrightarrow> f x'\n\\<le> (if nofail (f x') then M x' else FAIL);\n         pre x; REC\\<^sub>T body = f\\<rbrakk>\n        \\<Longrightarrow> body f x\n                          \\<le> (if nofail (body f x) then M x\n                                 else FAIL)\\<rbrakk>\n    \\<Longrightarrow> wf V\n 3. \\<lbrakk>\\<not> \\<not> trimono body; wf V; pre x;\n     \\<And>x f.\n        \\<lbrakk>\\<And>x'.\n                    \\<lbrakk>pre x'; (x', x) \\<in> V\\<rbrakk>\n                    \\<Longrightarrow> f x'\n\\<le> (if nofail (f x') then M x' else FAIL);\n         pre x; REC\\<^sub>T body = f\\<rbrakk>\n        \\<Longrightarrow> body f x\n                          \\<le> (if nofail (body f x) then M x\n                                 else FAIL)\\<rbrakk>\n    \\<Longrightarrow> pre x\n 4. \\<And>f xa.\n       \\<lbrakk>\\<not> \\<not> trimono body; wf V; pre x;\n        \\<And>x f.\n           \\<lbrakk>\\<And>x'.\n                       \\<lbrakk>pre x'; (x', x) \\<in> V\\<rbrakk>\n                       \\<Longrightarrow> f x'\n   \\<le> (if nofail (f x') then M x' else FAIL);\n            pre x; REC\\<^sub>T body = f\\<rbrakk>\n           \\<Longrightarrow> body f x\n                             \\<le> (if nofail (body f x) then M x\n                                    else FAIL);\n        \\<And>x'.\n           \\<lbrakk>pre x'; (x', xa) \\<in> V\\<rbrakk>\n           \\<Longrightarrow> f x'\n                             \\<le> (if nofail (REC\\<^sub>T body x')\n                                    then M x' else FAIL);\n        pre xa; REC\\<^sub>T body = f\\<rbrakk>\n       \\<Longrightarrow> body f xa\n                         \\<le> (if nofail (REC\\<^sub>T body xa) then M xa\n                                else FAIL)", "apply clarsimp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>trimono body; wf V; pre x;\n        \\<And>x f.\n           \\<lbrakk>\\<And>x'.\n                       \\<lbrakk>pre x'; (x', x) \\<in> V\\<rbrakk>\n                       \\<Longrightarrow> f x'\n   \\<le> (if nofail (f x') then M x' else FAIL);\n            pre x; REC\\<^sub>T body = f\\<rbrakk>\n           \\<Longrightarrow> body f x\n                             \\<le> (if nofail (body f x) then M x\n                                    else FAIL);\n        \\<And>x'.\n           \\<lbrakk>pre x'; (x', xa) \\<in> V\\<rbrakk>\n           \\<Longrightarrow> REC\\<^sub>T body x'\n                             \\<le> (if nofail (REC\\<^sub>T body x')\n                                    then M x' else FAIL);\n        pre xa; nofail (REC\\<^sub>T body xa)\\<rbrakk>\n       \\<Longrightarrow> body (REC\\<^sub>T body) xa \\<le> M xa", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>trimono body; wf V; pre x;\n        \\<And>x f.\n           \\<lbrakk>\\<And>x'.\n                       \\<lbrakk>pre x'; (x', x) \\<in> V\\<rbrakk>\n                       \\<Longrightarrow> f x'\n   \\<le> (if nofail (f x') then M x' else FAIL);\n            pre x; REC\\<^sub>T body = f\\<rbrakk>\n           \\<Longrightarrow> body f x\n                             \\<le> (if nofail (body f x) then M x\n                                    else FAIL);\n        \\<And>x'.\n           \\<lbrakk>pre x'; (x', xa) \\<in> V\\<rbrakk>\n           \\<Longrightarrow> REC\\<^sub>T body x'\n                             \\<le> (if nofail (REC\\<^sub>T body x')\n                                    then M x' else FAIL);\n        pre xa; nofail (REC\\<^sub>T body xa)\\<rbrakk>\n       \\<Longrightarrow> body (REC\\<^sub>T body) xa \\<le> M xa", "fix xa :: 'x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>trimono body; wf V; pre x;\n        \\<And>x f.\n           \\<lbrakk>\\<And>x'.\n                       \\<lbrakk>pre x'; (x', x) \\<in> V\\<rbrakk>\n                       \\<Longrightarrow> f x'\n   \\<le> (if nofail (f x') then M x' else FAIL);\n            pre x; REC\\<^sub>T body = f\\<rbrakk>\n           \\<Longrightarrow> body f x\n                             \\<le> (if nofail (body f x) then M x\n                                    else FAIL);\n        \\<And>x'.\n           \\<lbrakk>pre x'; (x', xa) \\<in> V\\<rbrakk>\n           \\<Longrightarrow> REC\\<^sub>T body x'\n                             \\<le> (if nofail (REC\\<^sub>T body x')\n                                    then M x' else FAIL);\n        pre xa; nofail (REC\\<^sub>T body xa)\\<rbrakk>\n       \\<Longrightarrow> body (REC\\<^sub>T body) xa \\<le> M xa", "assume a1: \"\\<And>x'. \\<lbrakk>pre x'; (x', xa) \\<in> V\\<rbrakk> \\<Longrightarrow> REC\\<^sub>T body x' \\<le> (if nofail (REC\\<^sub>T body x') then M x' else FAIL)\""], ["proof (state)\nthis:\n  \\<lbrakk>pre ?x'; (?x', xa) \\<in> V\\<rbrakk>\n  \\<Longrightarrow> REC\\<^sub>T body ?x'\n                    \\<le> (if nofail (REC\\<^sub>T body ?x') then M ?x'\n                           else FAIL)\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>trimono body; wf V; pre x;\n        \\<And>x f.\n           \\<lbrakk>\\<And>x'.\n                       \\<lbrakk>pre x'; (x', x) \\<in> V\\<rbrakk>\n                       \\<Longrightarrow> f x'\n   \\<le> (if nofail (f x') then M x' else FAIL);\n            pre x; REC\\<^sub>T body = f\\<rbrakk>\n           \\<Longrightarrow> body f x\n                             \\<le> (if nofail (body f x) then M x\n                                    else FAIL);\n        \\<And>x'.\n           \\<lbrakk>pre x'; (x', xa) \\<in> V\\<rbrakk>\n           \\<Longrightarrow> REC\\<^sub>T body x'\n                             \\<le> (if nofail (REC\\<^sub>T body x')\n                                    then M x' else FAIL);\n        pre xa; nofail (REC\\<^sub>T body xa)\\<rbrakk>\n       \\<Longrightarrow> body (REC\\<^sub>T body) xa \\<le> M xa", "assume a2: \"\\<And>x f. \\<lbrakk>\\<And>x'. \\<lbrakk>pre x'; (x', x) \\<in> V\\<rbrakk> \\<Longrightarrow> f x' \\<le> (if nofail (f x') then M x' else FAIL); pre x; REC\\<^sub>T body = f\\<rbrakk> \\<Longrightarrow> body f x \\<le> (if nofail (body f x) then M x else FAIL)\""], ["proof (state)\nthis:\n  \\<lbrakk>\\<And>x'.\n              \\<lbrakk>pre x'; (x', ?x) \\<in> V\\<rbrakk>\n              \\<Longrightarrow> ?f x'\n                                \\<le> (if nofail (?f x') then M x'\n else FAIL);\n   pre ?x; REC\\<^sub>T body = ?f\\<rbrakk>\n  \\<Longrightarrow> body ?f ?x\n                    \\<le> (if nofail (body ?f ?x) then M ?x else FAIL)\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>trimono body; wf V; pre x;\n        \\<And>x f.\n           \\<lbrakk>\\<And>x'.\n                       \\<lbrakk>pre x'; (x', x) \\<in> V\\<rbrakk>\n                       \\<Longrightarrow> f x'\n   \\<le> (if nofail (f x') then M x' else FAIL);\n            pre x; REC\\<^sub>T body = f\\<rbrakk>\n           \\<Longrightarrow> body f x\n                             \\<le> (if nofail (body f x) then M x\n                                    else FAIL);\n        \\<And>x'.\n           \\<lbrakk>pre x'; (x', xa) \\<in> V\\<rbrakk>\n           \\<Longrightarrow> REC\\<^sub>T body x'\n                             \\<le> (if nofail (REC\\<^sub>T body x')\n                                    then M x' else FAIL);\n        pre xa; nofail (REC\\<^sub>T body xa)\\<rbrakk>\n       \\<Longrightarrow> body (REC\\<^sub>T body) xa \\<le> M xa", "assume a3: \"pre xa\""], ["proof (state)\nthis:\n  pre xa\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>trimono body; wf V; pre x;\n        \\<And>x f.\n           \\<lbrakk>\\<And>x'.\n                       \\<lbrakk>pre x'; (x', x) \\<in> V\\<rbrakk>\n                       \\<Longrightarrow> f x'\n   \\<le> (if nofail (f x') then M x' else FAIL);\n            pre x; REC\\<^sub>T body = f\\<rbrakk>\n           \\<Longrightarrow> body f x\n                             \\<le> (if nofail (body f x) then M x\n                                    else FAIL);\n        \\<And>x'.\n           \\<lbrakk>pre x'; (x', xa) \\<in> V\\<rbrakk>\n           \\<Longrightarrow> REC\\<^sub>T body x'\n                             \\<le> (if nofail (REC\\<^sub>T body x')\n                                    then M x' else FAIL);\n        pre xa; nofail (REC\\<^sub>T body xa)\\<rbrakk>\n       \\<Longrightarrow> body (REC\\<^sub>T body) xa \\<le> M xa", "assume a4: \"nofail (REC\\<^sub>T body xa)\""], ["proof (state)\nthis:\n  nofail (REC\\<^sub>T body xa)\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>trimono body; wf V; pre x;\n        \\<And>x f.\n           \\<lbrakk>\\<And>x'.\n                       \\<lbrakk>pre x'; (x', x) \\<in> V\\<rbrakk>\n                       \\<Longrightarrow> f x'\n   \\<le> (if nofail (f x') then M x' else FAIL);\n            pre x; REC\\<^sub>T body = f\\<rbrakk>\n           \\<Longrightarrow> body f x\n                             \\<le> (if nofail (body f x) then M x\n                                    else FAIL);\n        \\<And>x'.\n           \\<lbrakk>pre x'; (x', xa) \\<in> V\\<rbrakk>\n           \\<Longrightarrow> REC\\<^sub>T body x'\n                             \\<le> (if nofail (REC\\<^sub>T body x')\n                                    then M x' else FAIL);\n        pre xa; nofail (REC\\<^sub>T body xa)\\<rbrakk>\n       \\<Longrightarrow> body (REC\\<^sub>T body) xa \\<le> M xa", "assume a5: \"trimono body\""], ["proof (state)\nthis:\n  trimono body\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>trimono body; wf V; pre x;\n        \\<And>x f.\n           \\<lbrakk>\\<And>x'.\n                       \\<lbrakk>pre x'; (x', x) \\<in> V\\<rbrakk>\n                       \\<Longrightarrow> f x'\n   \\<le> (if nofail (f x') then M x' else FAIL);\n            pre x; REC\\<^sub>T body = f\\<rbrakk>\n           \\<Longrightarrow> body f x\n                             \\<le> (if nofail (body f x) then M x\n                                    else FAIL);\n        \\<And>x'.\n           \\<lbrakk>pre x'; (x', xa) \\<in> V\\<rbrakk>\n           \\<Longrightarrow> REC\\<^sub>T body x'\n                             \\<le> (if nofail (REC\\<^sub>T body x')\n                                    then M x' else FAIL);\n        pre xa; nofail (REC\\<^sub>T body xa)\\<rbrakk>\n       \\<Longrightarrow> body (REC\\<^sub>T body) xa \\<le> M xa", "have f6: \"\\<forall>x. \\<not> pre x \\<or> (x, xa) \\<notin> V \\<or> (if nofail (REC\\<^sub>T body x) then REC\\<^sub>T body x \\<le> M x else REC\\<^sub>T body x \\<le> FAIL)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       \\<not> pre x \\<or>\n       (x, xa) \\<notin> V \\<or>\n       (if nofail (REC\\<^sub>T body x) then REC\\<^sub>T body x \\<le> M x\n        else REC\\<^sub>T body x \\<le> FAIL)", "using a1"], ["proof (prove)\nusing this:\n  \\<lbrakk>pre ?x'; (?x', xa) \\<in> V\\<rbrakk>\n  \\<Longrightarrow> REC\\<^sub>T body ?x'\n                    \\<le> (if nofail (REC\\<^sub>T body ?x') then M ?x'\n                           else FAIL)\n\ngoal (1 subgoal):\n 1. \\<forall>x.\n       \\<not> pre x \\<or>\n       (x, xa) \\<notin> V \\<or>\n       (if nofail (REC\\<^sub>T body x) then REC\\<^sub>T body x \\<le> M x\n        else REC\\<^sub>T body x \\<le> FAIL)", "by presburger"], ["proof (state)\nthis:\n  \\<forall>x.\n     \\<not> pre x \\<or>\n     (x, xa) \\<notin> V \\<or>\n     (if nofail (REC\\<^sub>T body x) then REC\\<^sub>T body x \\<le> M x\n      else REC\\<^sub>T body x \\<le> FAIL)\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>trimono body; wf V; pre x;\n        \\<And>x f.\n           \\<lbrakk>\\<And>x'.\n                       \\<lbrakk>pre x'; (x', x) \\<in> V\\<rbrakk>\n                       \\<Longrightarrow> f x'\n   \\<le> (if nofail (f x') then M x' else FAIL);\n            pre x; REC\\<^sub>T body = f\\<rbrakk>\n           \\<Longrightarrow> body f x\n                             \\<le> (if nofail (body f x) then M x\n                                    else FAIL);\n        \\<And>x'.\n           \\<lbrakk>pre x'; (x', xa) \\<in> V\\<rbrakk>\n           \\<Longrightarrow> REC\\<^sub>T body x'\n                             \\<le> (if nofail (REC\\<^sub>T body x')\n                                    then M x' else FAIL);\n        pre xa; nofail (REC\\<^sub>T body xa)\\<rbrakk>\n       \\<Longrightarrow> body (REC\\<^sub>T body) xa \\<le> M xa", "have f7: \"\\<forall>x f. ((\\<exists>xa. (pre xa \\<and> (xa, x) \\<in> V) \\<and> \\<not> f xa \\<le> (if nofail (f xa) then M xa else FAIL)) \\<or> \\<not> pre x \\<or> REC\\<^sub>T body \\<noteq> f) \\<or> body f x \\<le> (if nofail (body f x) then M x else FAIL)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x f.\n       ((\\<exists>xa.\n            (pre xa \\<and> (xa, x) \\<in> V) \\<and>\n            \\<not> f xa \\<le> (if nofail (f xa) then M xa else FAIL)) \\<or>\n        \\<not> pre x \\<or> REC\\<^sub>T body \\<noteq> f) \\<or>\n       body f x \\<le> (if nofail (body f x) then M x else FAIL)", "using a2"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>x'.\n              \\<lbrakk>pre x'; (x', ?x) \\<in> V\\<rbrakk>\n              \\<Longrightarrow> ?f x'\n                                \\<le> (if nofail (?f x') then M x'\n else FAIL);\n   pre ?x; REC\\<^sub>T body = ?f\\<rbrakk>\n  \\<Longrightarrow> body ?f ?x\n                    \\<le> (if nofail (body ?f ?x) then M ?x else FAIL)\n\ngoal (1 subgoal):\n 1. \\<forall>x f.\n       ((\\<exists>xa.\n            (pre xa \\<and> (xa, x) \\<in> V) \\<and>\n            \\<not> f xa \\<le> (if nofail (f xa) then M xa else FAIL)) \\<or>\n        \\<not> pre x \\<or> REC\\<^sub>T body \\<noteq> f) \\<or>\n       body f x \\<le> (if nofail (body f x) then M x else FAIL)", "by blast"], ["proof (state)\nthis:\n  \\<forall>x f.\n     ((\\<exists>xa.\n          (pre xa \\<and> (xa, x) \\<in> V) \\<and>\n          \\<not> f xa \\<le> (if nofail (f xa) then M xa else FAIL)) \\<or>\n      \\<not> pre x \\<or> REC\\<^sub>T body \\<noteq> f) \\<or>\n     body f x \\<le> (if nofail (body f x) then M x else FAIL)\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>trimono body; wf V; pre x;\n        \\<And>x f.\n           \\<lbrakk>\\<And>x'.\n                       \\<lbrakk>pre x'; (x', x) \\<in> V\\<rbrakk>\n                       \\<Longrightarrow> f x'\n   \\<le> (if nofail (f x') then M x' else FAIL);\n            pre x; REC\\<^sub>T body = f\\<rbrakk>\n           \\<Longrightarrow> body f x\n                             \\<le> (if nofail (body f x) then M x\n                                    else FAIL);\n        \\<And>x'.\n           \\<lbrakk>pre x'; (x', xa) \\<in> V\\<rbrakk>\n           \\<Longrightarrow> REC\\<^sub>T body x'\n                             \\<le> (if nofail (REC\\<^sub>T body x')\n                                    then M x' else FAIL);\n        pre xa; nofail (REC\\<^sub>T body xa)\\<rbrakk>\n       \\<Longrightarrow> body (REC\\<^sub>T body) xa \\<le> M xa", "obtain xx :: \"('x \\<Rightarrow> 'a nres) \\<Rightarrow> 'x \\<Rightarrow> 'x\" where\n    f8: \"\\<forall>x0 x1. (\\<exists>v2. (pre v2 \\<and> (v2, x1) \\<in> V) \\<and> \\<not> x0 v2 \\<le> (if nofail (x0 v2) then M v2 else FAIL)) = ((pre (xx x0 x1) \\<and> (xx x0 x1, x1) \\<in> V) \\<and> \\<not> x0 (xx x0 x1) \\<le> (if nofail (x0 (xx x0 x1)) then M (xx x0 x1) else FAIL))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>xx.\n        \\<forall>x0 x1.\n           (\\<exists>v2.\n               (pre v2 \\<and> (v2, x1) \\<in> V) \\<and>\n               \\<not> x0 v2 \\<le> (if nofail (x0 v2) then M v2 else FAIL)) =\n           ((pre (xx x0 x1) \\<and> (xx x0 x1, x1) \\<in> V) \\<and>\n            \\<not> x0 (xx x0 x1)\n                   \\<le> (if nofail (x0 (xx x0 x1)) then M (xx x0 x1)\n                          else FAIL)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by moura"], ["proof (state)\nthis:\n  \\<forall>x0 x1.\n     (\\<exists>v2.\n         (pre v2 \\<and> (v2, x1) \\<in> V) \\<and>\n         \\<not> x0 v2 \\<le> (if nofail (x0 v2) then M v2 else FAIL)) =\n     ((pre (xx x0 x1) \\<and> (xx x0 x1, x1) \\<in> V) \\<and>\n      \\<not> x0 (xx x0 x1)\n             \\<le> (if nofail (x0 (xx x0 x1)) then M (xx x0 x1) else FAIL))\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>trimono body; wf V; pre x;\n        \\<And>x f.\n           \\<lbrakk>\\<And>x'.\n                       \\<lbrakk>pre x'; (x', x) \\<in> V\\<rbrakk>\n                       \\<Longrightarrow> f x'\n   \\<le> (if nofail (f x') then M x' else FAIL);\n            pre x; REC\\<^sub>T body = f\\<rbrakk>\n           \\<Longrightarrow> body f x\n                             \\<le> (if nofail (body f x) then M x\n                                    else FAIL);\n        \\<And>x'.\n           \\<lbrakk>pre x'; (x', xa) \\<in> V\\<rbrakk>\n           \\<Longrightarrow> REC\\<^sub>T body x'\n                             \\<le> (if nofail (REC\\<^sub>T body x')\n                                    then M x' else FAIL);\n        pre xa; nofail (REC\\<^sub>T body xa)\\<rbrakk>\n       \\<Longrightarrow> body (REC\\<^sub>T body) xa \\<le> M xa", "have f9: \"\\<forall>x0 x1. (x0 (xx x0 x1) \\<le> (if nofail (x0 (xx x0 x1)) then M (xx x0 x1) else FAIL)) = (if nofail (x0 (xx x0 x1)) then x0 (xx x0 x1) \\<le> M (xx x0 x1) else x0 (xx x0 x1) \\<le> FAIL)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x0 x1.\n       (x0 (xx x0 x1)\n        \\<le> (if nofail (x0 (xx x0 x1)) then M (xx x0 x1) else FAIL)) =\n       (if nofail (x0 (xx x0 x1)) then x0 (xx x0 x1) \\<le> M (xx x0 x1)\n        else x0 (xx x0 x1) \\<le> FAIL)", "by presburger"], ["proof (state)\nthis:\n  \\<forall>x0 x1.\n     (x0 (xx x0 x1)\n      \\<le> (if nofail (x0 (xx x0 x1)) then M (xx x0 x1) else FAIL)) =\n     (if nofail (x0 (xx x0 x1)) then x0 (xx x0 x1) \\<le> M (xx x0 x1)\n      else x0 (xx x0 x1) \\<le> FAIL)\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>trimono body; wf V; pre x;\n        \\<And>x f.\n           \\<lbrakk>\\<And>x'.\n                       \\<lbrakk>pre x'; (x', x) \\<in> V\\<rbrakk>\n                       \\<Longrightarrow> f x'\n   \\<le> (if nofail (f x') then M x' else FAIL);\n            pre x; REC\\<^sub>T body = f\\<rbrakk>\n           \\<Longrightarrow> body f x\n                             \\<le> (if nofail (body f x) then M x\n                                    else FAIL);\n        \\<And>x'.\n           \\<lbrakk>pre x'; (x', xa) \\<in> V\\<rbrakk>\n           \\<Longrightarrow> REC\\<^sub>T body x'\n                             \\<le> (if nofail (REC\\<^sub>T body x')\n                                    then M x' else FAIL);\n        pre xa; nofail (REC\\<^sub>T body xa)\\<rbrakk>\n       \\<Longrightarrow> body (REC\\<^sub>T body) xa \\<le> M xa", "have \"nofail (body (REC\\<^sub>T body) xa)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nofail (body (REC\\<^sub>T body) xa)", "using a5 a4"], ["proof (prove)\nusing this:\n  trimono body\n  nofail (REC\\<^sub>T body xa)\n\ngoal (1 subgoal):\n 1. nofail (body (REC\\<^sub>T body) xa)", "by (metis (no_types) RECT_unfold)"], ["proof (state)\nthis:\n  nofail (body (REC\\<^sub>T body) xa)\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>trimono body; wf V; pre x;\n        \\<And>x f.\n           \\<lbrakk>\\<And>x'.\n                       \\<lbrakk>pre x'; (x', x) \\<in> V\\<rbrakk>\n                       \\<Longrightarrow> f x'\n   \\<le> (if nofail (f x') then M x' else FAIL);\n            pre x; REC\\<^sub>T body = f\\<rbrakk>\n           \\<Longrightarrow> body f x\n                             \\<le> (if nofail (body f x) then M x\n                                    else FAIL);\n        \\<And>x'.\n           \\<lbrakk>pre x'; (x', xa) \\<in> V\\<rbrakk>\n           \\<Longrightarrow> REC\\<^sub>T body x'\n                             \\<le> (if nofail (REC\\<^sub>T body x')\n                                    then M x' else FAIL);\n        pre xa; nofail (REC\\<^sub>T body xa)\\<rbrakk>\n       \\<Longrightarrow> body (REC\\<^sub>T body) xa \\<le> M xa", "then"], ["proof (chain)\npicking this:\n  nofail (body (REC\\<^sub>T body) xa)", "show \"body (REC\\<^sub>T body) xa \\<le> M xa\""], ["proof (prove)\nusing this:\n  nofail (body (REC\\<^sub>T body) xa)\n\ngoal (1 subgoal):\n 1. body (REC\\<^sub>T body) xa \\<le> M xa", "using f9 f8 f7 f6 a3"], ["proof (prove)\nusing this:\n  nofail (body (REC\\<^sub>T body) xa)\n  \\<forall>x0 x1.\n     (x0 (xx x0 x1)\n      \\<le> (if nofail (x0 (xx x0 x1)) then M (xx x0 x1) else FAIL)) =\n     (if nofail (x0 (xx x0 x1)) then x0 (xx x0 x1) \\<le> M (xx x0 x1)\n      else x0 (xx x0 x1) \\<le> FAIL)\n  \\<forall>x0 x1.\n     (\\<exists>v2.\n         (pre v2 \\<and> (v2, x1) \\<in> V) \\<and>\n         \\<not> x0 v2 \\<le> (if nofail (x0 v2) then M v2 else FAIL)) =\n     ((pre (xx x0 x1) \\<and> (xx x0 x1, x1) \\<in> V) \\<and>\n      \\<not> x0 (xx x0 x1)\n             \\<le> (if nofail (x0 (xx x0 x1)) then M (xx x0 x1) else FAIL))\n  \\<forall>x f.\n     ((\\<exists>xa.\n          (pre xa \\<and> (xa, x) \\<in> V) \\<and>\n          \\<not> f xa \\<le> (if nofail (f xa) then M xa else FAIL)) \\<or>\n      \\<not> pre x \\<or> REC\\<^sub>T body \\<noteq> f) \\<or>\n     body f x \\<le> (if nofail (body f x) then M x else FAIL)\n  \\<forall>x.\n     \\<not> pre x \\<or>\n     (x, xa) \\<notin> V \\<or>\n     (if nofail (REC\\<^sub>T body x) then REC\\<^sub>T body x \\<le> M x\n      else REC\\<^sub>T body x \\<le> FAIL)\n  pre xa\n\ngoal (1 subgoal):\n 1. body (REC\\<^sub>T body) xa \\<le> M xa", "by fastforce"], ["proof (state)\nthis:\n  body (REC\\<^sub>T body) xa \\<le> M xa\n\ngoal:\nNo subgoals!", "qed"], ["", "(* TODO: REC_rule_leof! (However, this may require some fix \n     to the domain theory model of Refine_Monadic!) *)"], ["", "end"]]}