{"file_name": "/home/qj213/afp-2021-10-22/thys/Refine_Monadic/Refine_Basic.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Refine_Monadic", "problem_names": ["lemma nres_cases[case_names FAIL RES, cases type]:\n  obtains \"M=FAIL\" | X where \"M=RES X\"", "lemma nres_simp_internals: \n  \"RES {} = SUCCEED\"\n  \"FAILi = FAIL\"", "lemma nres_inequalities[simp]: \n  \"FAIL \\<noteq> RES X\"\n  \"FAIL \\<noteq> SUCCEED\" \n  \"FAIL \\<noteq> RETURN x\"\n  \"SUCCEED \\<noteq> FAIL\"\n  \"SUCCEED \\<noteq> RETURN x\"\n  \"RES X \\<noteq> FAIL\"\n  \"RETURN x \\<noteq> FAIL\"\n  \"RETURN x \\<noteq> SUCCEED\"", "lemma nres_more_simps[simp]:\n  \"SUCCEED = RES X \\<longleftrightarrow> X={}\"\n  \"RES X = SUCCEED \\<longleftrightarrow> X={}\"\n  \"RES X = RETURN x \\<longleftrightarrow> X={x}\"\n  \"RES X = RES Y \\<longleftrightarrow> X=Y\"\n  \"RETURN x = RES X \\<longleftrightarrow> {x}=X\"\n  \"RETURN x = RETURN y \\<longleftrightarrow> x=y\"", "lemma nres_order_simps[simp]:\n  \"\\<And>M. SUCCEED \\<le> M\"\n  \"\\<And>M. M \\<le> SUCCEED \\<longleftrightarrow> M=SUCCEED\"\n  \"\\<And>M. M \\<le> FAIL\"\n  \"\\<And>M. FAIL \\<le> M \\<longleftrightarrow> M=FAIL\"\n  \"\\<And>X Y. RES X \\<le> RES Y \\<longleftrightarrow> X\\<le>Y\"\n  \"\\<And>X. Sup X = FAIL \\<longleftrightarrow> FAIL\\<in>X\"\n  \"\\<And>X f. Sup (f ` X) = FAIL \\<longleftrightarrow> FAIL \\<in> f ` X\"\n  \"\\<And>X. FAIL = Sup X \\<longleftrightarrow> FAIL\\<in>X\"\n  \"\\<And>X f. FAIL = Sup (f ` X) \\<longleftrightarrow> FAIL \\<in> f ` X\"\n  \"\\<And>X. FAIL\\<in>X \\<Longrightarrow> Sup X = FAIL\"\n  \"\\<And>X. FAIL\\<in>f ` X \\<Longrightarrow> Sup (f ` X) = FAIL\"\n  \"\\<And>A. Sup (RES ` A) = RES (Sup A)\"\n  \"\\<And>A. Sup (RES ` A) = RES (Sup A)\"\n  \"\\<And>A. A\\<noteq>{} \\<Longrightarrow> Inf (RES`A) = RES (Inf A)\"\n  \"\\<And>A. A\\<noteq>{} \\<Longrightarrow> Inf (RES ` A) = RES (Inf A)\"\n  \"Inf {} = FAIL\"\n  \"Inf UNIV = SUCCEED\"\n  \"Sup {} = SUCCEED\"\n  \"Sup UNIV = FAIL\"\n  \"\\<And>x y. RETURN x \\<le> RETURN y \\<longleftrightarrow> x=y\"\n  \"\\<And>x Y. RETURN x \\<le> RES Y \\<longleftrightarrow> x\\<in>Y\"\n  \"\\<And>X y. RES X \\<le> RETURN y \\<longleftrightarrow> X \\<subseteq> {y}\"", "lemma Sup_eq_RESE:\n  assumes \"Sup A = RES B\"\n  obtains C where \"A=RES`C\" and \"B=Sup C\"", "lemma nofail_simps[simp, refine_pw_simps]:\n  \"nofail FAIL \\<longleftrightarrow> False\"\n  \"nofail (RES X) \\<longleftrightarrow> True\"\n  \"nofail (RETURN x) \\<longleftrightarrow> True\"\n  \"nofail SUCCEED \\<longleftrightarrow> True\"", "lemma inres_simps[simp, refine_pw_simps]:\n  \"inres FAIL = (\\<lambda>_. True)\"\n  \"inres (RES X) = (\\<lambda>x. x\\<in>X)\"\n  \"inres (RETURN x) = (\\<lambda>y. x=y)\"\n  \"inres SUCCEED = (\\<lambda>_. False)\"", "lemma not_nofail_iff: \n  \"\\<not>nofail S \\<longleftrightarrow> S=FAIL\"", "lemma not_nofail_inres[simp, refine_pw_simps]: \n  \"\\<not>nofail S \\<Longrightarrow> inres S x\"", "lemma intro_nofail[refine_pw_simps]: \n  \"S\\<noteq>FAIL \\<longleftrightarrow> nofail S\"\n  \"FAIL\\<noteq>S \\<longleftrightarrow> nofail S\"", "lemma pw_le_iff: \n  \"S \\<le> S' \\<longleftrightarrow> (nofail S'\\<longrightarrow> (nofail S \\<and> (\\<forall>x. inres S x \\<longrightarrow> inres S' x)))\"", "lemma pw_eq_iff:\n  \"S=S' \\<longleftrightarrow> (nofail S = nofail S' \\<and> (\\<forall>x. inres S x \\<longleftrightarrow> inres S' x))\"", "lemma pw_flat_le_iff: \"flat_le S S' \\<longleftrightarrow> \n  (\\<exists>x. inres S x) \\<longrightarrow> (nofail S \\<longleftrightarrow> nofail S') \\<and> (\\<forall>x. inres S x \\<longleftrightarrow> inres S' x)\"", "lemma pw_flat_ge_iff: \"flat_ge S S' \\<longleftrightarrow> \n  (nofail S) \\<longrightarrow> nofail S' \\<and> (\\<forall>x. inres S x \\<longleftrightarrow> inres S' x)\"", "lemmas pw_ords_iff = pw_le_iff pw_flat_le_iff pw_flat_ge_iff", "lemma pw_leI: \n  \"(nofail S'\\<longrightarrow> (nofail S \\<and> (\\<forall>x. inres S x \\<longrightarrow> inres S' x))) \\<Longrightarrow> S \\<le> S'\"", "lemma pw_leI': \n  assumes \"nofail S' \\<Longrightarrow> nofail S\"\n  assumes \"\\<And>x. \\<lbrakk>nofail S'; inres S x\\<rbrakk> \\<Longrightarrow> inres S' x\"\n  shows \"S \\<le> S'\"", "lemma pw_eqI: \n  assumes \"nofail S = nofail S'\" \n  assumes \"\\<And>x. inres S x \\<longleftrightarrow> inres S' x\" \n  shows \"S=S'\"", "lemma pwD1:\n  assumes \"S\\<le>S'\" \"nofail S'\" \n  shows \"nofail S\"", "lemma pwD2:\n  assumes \"S\\<le>S'\" \"inres S x\"\n  shows \"inres S' x\"", "lemmas pwD = pwD1 pwD2", "lemma le_nofailI: \"\\<lbrakk> nofail M' \\<Longrightarrow> M \\<le> M' \\<rbrakk> \\<Longrightarrow> M \\<le> M'\"", "lemma pw_sup_nofail[refine_pw_simps]:\n  \"nofail (sup a b) \\<longleftrightarrow> nofail a \\<and> nofail b\"", "lemma pw_sup_inres[refine_pw_simps]:\n  \"inres (sup a b) x \\<longleftrightarrow> inres a x \\<or> inres b x\"", "lemma pw_Sup_inres[refine_pw_simps]: \"inres (Sup X) r \\<longleftrightarrow> (\\<exists>M\\<in>X. inres M r)\"", "lemma pw_SUP_inres [refine_pw_simps]: \"inres (Sup (f ` X)) r \\<longleftrightarrow> (\\<exists>M\\<in>X. inres (f M) r)\"", "lemma pw_Sup_nofail[refine_pw_simps]: \"nofail (Sup X) \\<longleftrightarrow> (\\<forall>x\\<in>X. nofail x)\"", "lemma pw_SUP_nofail [refine_pw_simps]: \"nofail (Sup (f ` X)) \\<longleftrightarrow> (\\<forall>x\\<in>X. nofail (f x))\"", "lemma pw_inf_nofail[refine_pw_simps]:\n  \"nofail (inf a b) \\<longleftrightarrow> nofail a \\<or> nofail b\"", "lemma pw_inf_inres[refine_pw_simps]:\n  \"inres (inf a b) x \\<longleftrightarrow> inres a x \\<and> inres b x\"", "lemma pw_Inf_nofail[refine_pw_simps]: \"nofail (Inf C) \\<longleftrightarrow> (\\<exists>x\\<in>C. nofail x)\"", "lemma pw_INF_nofail [refine_pw_simps]: \"nofail (Inf (f ` C)) \\<longleftrightarrow> (\\<exists>x\\<in>C. nofail (f x))\"", "lemma pw_Inf_inres[refine_pw_simps]: \"inres (Inf C) r \\<longleftrightarrow> (\\<forall>M\\<in>C. inres M r)\"", "lemma pw_INF_inres [refine_pw_simps]: \"inres (Inf (f ` C)) r \\<longleftrightarrow> (\\<forall>M\\<in>C. inres (f M) r)\"", "lemma nofail_RES_conv: \"nofail m \\<longleftrightarrow> (\\<exists>M. m=RES M)\"", "lemma the_RES_inv[simp]: \"nofail m \\<Longrightarrow> RES (the_RES m) = m\"", "lemma nf_inres_RES[simp]: \"nf_inres (RES X) x \\<longleftrightarrow> x\\<in>X\"", "lemma nf_inres_SPEC[simp]: \"nf_inres (SPEC \\<Phi>) x \\<longleftrightarrow> \\<Phi> x\"", "lemma nofail_antimono_fun: \"f \\<le> g \\<Longrightarrow> (nofail (g x) \\<longrightarrow> nofail (f x))\"", "lemma bind_FAIL[simp]: \"bind FAIL f = FAIL\"", "lemma bind_SUCCEED[simp]: \"bind SUCCEED f = SUCCEED\"", "lemma bind_RES: \"bind (RES X) f = Sup (f`X)\"", "lemma pw_bind_nofail[refine_pw_simps]:\n  \"nofail (bind M f) \\<longleftrightarrow> (nofail M \\<and> (\\<forall>x. inres M x \\<longrightarrow> nofail (f x)))\"", "lemma pw_bind_inres[refine_pw_simps]:\n  \"inres (bind M f) = (\\<lambda>x. nofail M \\<longrightarrow> (\\<exists>y. (inres M y \\<and> inres (f y) x)))\"", "lemma pw_bind_le_iff:\n  \"bind M f \\<le> S \\<longleftrightarrow> (nofail S \\<longrightarrow> nofail M) \\<and> \n    (\\<forall>x. nofail M \\<and> inres M x \\<longrightarrow> f x \\<le> S)\"", "lemma pw_bind_leI: \"\\<lbrakk> \n  nofail S \\<Longrightarrow> nofail M; \\<And>x. \\<lbrakk>nofail M; inres M x\\<rbrakk> \\<Longrightarrow> f x \\<le> S\\<rbrakk> \n  \\<Longrightarrow> bind M f \\<le> S\"", "lemma nres_monad1[simp]: \"bind (RETURN x) f = f x\"", "lemma nres_monad2[simp]: \"bind M RETURN = M\"", "lemma nres_monad3[simp]: \"bind (bind M f) g = bind M (\\<lambda>x. bind (f x) g)\"", "lemmas nres_monad_laws = nres_monad1 nres_monad2 nres_monad3", "lemma bind_cong:\n  assumes \"m=m'\"\n  assumes \"\\<And>x. RETURN x \\<le> m' \\<Longrightarrow> f x = f' x\"\n  shows \"bind m f = bind m' f'\"", "lemma bind_mono[refine_mono]:\n  \"\\<lbrakk> M \\<le> M'; \\<And>x. RETURN x \\<le> M \\<Longrightarrow> f x \\<le> f' x \\<rbrakk> \\<Longrightarrow> bind M f \\<le> bind M' f'\"\n  (*\"\\<lbrakk> flat_le M M'; \\<And>x. flat_le (f x) (f' x) \\<rbrakk> \\<Longrightarrow> flat_le (bind M f) (bind M' f')\"*)\n  \"\\<lbrakk> flat_ge M M'; \\<And>x. flat_ge (f x) (f' x) \\<rbrakk> \\<Longrightarrow> flat_ge (bind M f) (bind M' f')\"", "lemma bind_mono1[simp, intro!]: \"mono (\\<lambda>M. bind M f)\"", "lemma bind_mono1'[simp, intro!]: \"mono bind\"", "lemma bind_mono2'[simp, intro!]: \"mono (bind M)\"", "lemma bind_distrib_sup1: \"bind (sup M N) f = sup (bind M f) (bind N f)\"", "lemma  bind_distrib_sup2: \"bind m (\\<lambda>x. sup (f x) (g x)) = sup (bind m f) (bind m g)\"", "lemma bind_distrib_Sup1: \"bind (Sup M) f = (SUP m\\<in>M. bind m f)\"", "lemma bind_distrib_Sup2: \"F\\<noteq>{} \\<Longrightarrow> bind m (Sup F) = (SUP f\\<in>F. bind m f)\"", "lemma RES_Sup_RETURN: \"Sup (RETURN`X) = RES X\"", "lemma SPEC_cons_rule:\n  assumes \"m \\<le> SPEC \\<Phi>\"\n  assumes \"\\<And>x. \\<Phi> x \\<Longrightarrow> \\<Psi> x\"\n  shows \"m \\<le> SPEC \\<Psi>\"", "lemmas SPEC_trans = order_trans[where z=\"SPEC Postcond\" for Postcond, zero_var_indexes]", "lemma \n  conc_fun_FAIL[simp]: \"\\<Down>R FAIL = FAIL\" and\n  conc_fun_RES: \"\\<Down>R (RES X) = RES (R\\<inverse>``X)\"", "lemma abs_fun_simps[simp]: \n  \"\\<Up>R FAIL = FAIL\"\n  \"X\\<subseteq>Domain R \\<Longrightarrow> \\<Up>R (RES X) = RES (R``X)\"\n  \"\\<not>(X\\<subseteq>Domain R) \\<Longrightarrow> \\<Up>R (RES X) = FAIL\"", "lemma conc_abs_swap: \"m' \\<le> \\<Down>R m \\<longleftrightarrow> \\<Up>R m' \\<le> m\"", "lemma ac_galois: \"galois_connection (\\<Up>R) (\\<Down>R)\"", "lemma pw_abs_nofail[refine_pw_simps]: \n  \"nofail (\\<Up>R M) \\<longleftrightarrow> (nofail M \\<and> (\\<forall>x. inres M x \\<longrightarrow> x\\<in>Domain R))\"", "lemma pw_abs_inres[refine_pw_simps]: \n  \"inres (\\<Up>R M) a \\<longleftrightarrow> (nofail (\\<Up>R M) \\<longrightarrow> (\\<exists>c. inres M c \\<and> (c,a)\\<in>R))\"", "lemma pw_conc_nofail[refine_pw_simps]: \n  \"nofail (\\<Down>R S) = nofail S\"", "lemma pw_conc_inres[refine_pw_simps]:\n  \"inres (\\<Down>R S') = (\\<lambda>s. nofail S' \n  \\<longrightarrow> (\\<exists>s'. (s,s')\\<in>R \\<and> inres S' s'))\"", "lemma abs_fun_strict[simp]:\n  \"\\<Up> R SUCCEED = SUCCEED\"", "lemma conc_fun_strict[simp]:\n  \"\\<Down> R SUCCEED = SUCCEED\"", "lemma conc_fun_mono[simp, intro!]: \"mono (\\<Down>R)\"", "lemma abs_fun_mono[simp, intro!]: \"mono (\\<Up>R)\"", "lemma conc_fun_R_mono:\n  assumes \"R \\<subseteq> R'\"\n  shows \"\\<Down>R M \\<le> \\<Down>R' M\"", "lemma conc_fun_chain: \"\\<Down>R (\\<Down>S M) = \\<Down>(R O S) M\"", "lemma conc_Id[simp]: \"\\<Down>Id = id\"", "lemma abs_Id[simp]: \"\\<Up>Id = id\"", "lemma conc_fun_fail_iff[simp]: \n  \"\\<Down>R S = FAIL \\<longleftrightarrow> S=FAIL\"\n  \"FAIL = \\<Down>R S \\<longleftrightarrow> S=FAIL\"", "lemma conc_trans[trans]:\n  assumes A: \"C \\<le> \\<Down>R B\" and B: \"B \\<le> \\<Down>R' A\" \n  shows \"C \\<le> \\<Down>R (\\<Down>R' A)\"", "lemma abs_trans[trans]:\n  assumes A: \"\\<Up>R C \\<le> B\" and B: \"\\<Up>R' B \\<le> A\" \n  shows \"\\<Up>R' (\\<Up>R C) \\<le> A\"", "lemma conc_trans_additional[trans]:\n  \"\\<And>A B C. A\\<le>\\<Down>R  B \\<Longrightarrow> B\\<le>    C \\<Longrightarrow> A\\<le>\\<Down>R  C\"\n  \"\\<And>A B C. A\\<le>\\<Down>Id B \\<Longrightarrow> B\\<le>\\<Down>R  C \\<Longrightarrow> A\\<le>\\<Down>R  C\"\n  \"\\<And>A B C. A\\<le>\\<Down>R  B \\<Longrightarrow> B\\<le>\\<Down>Id C \\<Longrightarrow> A\\<le>\\<Down>R  C\"\n\n  \"\\<And>A B C. A\\<le>\\<Down>Id B \\<Longrightarrow> B\\<le>\\<Down>Id C \\<Longrightarrow> A\\<le>    C\"\n  \"\\<And>A B C. A\\<le>\\<Down>Id B \\<Longrightarrow> B\\<le>    C \\<Longrightarrow> A\\<le>    C\"\n  \"\\<And>A B C. A\\<le>    B \\<Longrightarrow> B\\<le>\\<Down>Id C \\<Longrightarrow> A\\<le>    C\"", "lemma abs_trans_additional[trans]:\n  \"\\<And>A B C. \\<lbrakk> A \\<le> B; \\<Up> R B \\<le> C\\<rbrakk> \\<Longrightarrow> \\<Up> R A \\<le> C\"\n  \"\\<And>A B C. \\<lbrakk>\\<Up> Id A \\<le> B; \\<Up> R B \\<le> C\\<rbrakk> \\<Longrightarrow> \\<Up> R A \\<le> C\"\n  \"\\<And>A B C. \\<lbrakk>\\<Up> R A \\<le> B; \\<Up> Id B \\<le> C\\<rbrakk> \\<Longrightarrow> \\<Up> R A \\<le> C\"\n\n  \"\\<And>A B C. \\<lbrakk>\\<Up> Id A \\<le> B; \\<Up> Id B \\<le> C\\<rbrakk> \\<Longrightarrow> A \\<le> C\"\n  \"\\<And>A B C. \\<lbrakk>\\<Up> Id A \\<le> B; B \\<le> C\\<rbrakk> \\<Longrightarrow> A \\<le> C\"\n  \"\\<And>A B C. \\<lbrakk>A \\<le> B; \\<Up> Id B \\<le> C\\<rbrakk> \\<Longrightarrow> A \\<le> C\"", "lemmas [refine_vcg] = ASSERT_leI", "lemmas [refine_vcg] = le_ASSUMEI", "lemmas [refine_vcg] = le_ASSERTI", "lemmas [refine_vcg] = ASSUME_leI", "lemma pw_ASSERT[refine_pw_simps]:\n  \"nofail (ASSERT \\<Phi>) \\<longleftrightarrow> \\<Phi>\"\n  \"inres (ASSERT \\<Phi>) x\"", "lemma pw_ASSUME[refine_pw_simps]:\n  \"nofail (ASSUME \\<Phi>)\"\n  \"inres (ASSUME \\<Phi>) x \\<longleftrightarrow> \\<Phi>\"", "lemma pw_REC_nofail: \n  shows \"nofail (REC B x) \\<longleftrightarrow> trimono B \\<and>\n  (\\<exists>F. (\\<forall>x. \n    nofail (F x) \\<longrightarrow> nofail (B F x) \n    \\<and> (\\<forall>x'. inres (B F x) x' \\<longrightarrow> inres (F x) x')\n  ) \\<and> nofail (F x))\"", "lemma pw_REC_inres: \n  \"inres (REC B x) x' = (trimono B \\<longrightarrow>\n  (\\<forall>F. (\\<forall>x''. \n    nofail (F x'') \\<longrightarrow> nofail (B F x'') \n    \\<and> (\\<forall>x. inres (B F x'') x \\<longrightarrow> inres (F x'') x)) \n    \\<longrightarrow> inres (F x) x'))\"", "lemmas pw_REC = pw_REC_inres pw_REC_nofail", "lemma pw_RECT_nofail: \n  shows \"nofail (RECT B x) \\<longleftrightarrow> trimono B \\<and>\n  (\\<forall>F. (\\<forall>y. nofail (B F y) \\<longrightarrow>\n             nofail (F y) \\<and> (\\<forall>x. inres (F y) x \\<longrightarrow> inres (B F y) x)) \\<longrightarrow>\n        nofail (F x))\"", "lemma pw_RECT_inres: \n  shows \"inres (RECT B x) x' = (trimono B \\<longrightarrow>\n   (\\<exists>M. (\\<forall>y. nofail (B M y) \\<longrightarrow>\n             nofail (M y) \\<and> (\\<forall>x. inres (M y) x \\<longrightarrow> inres (B M y) x)) \\<and>\n        inres (M x) x'))\"", "lemmas pw_RECT = pw_RECT_inres pw_RECT_nofail", "lemma le_SPEC_UNIV_rule [refine_vcg]: \n  \"m \\<le> SPEC (\\<lambda>_. True) \\<Longrightarrow> m \\<le> RES UNIV\"", "lemma RETURN_rule[refine_vcg]: \"\\<Phi> x \\<Longrightarrow> RETURN x \\<le> SPEC \\<Phi>\"", "lemma RES_rule[refine_vcg]: \"\\<lbrakk>\\<And>x. x\\<in>S \\<Longrightarrow> \\<Phi> x\\<rbrakk> \\<Longrightarrow> RES S \\<le> SPEC \\<Phi>\"", "lemma SUCCEED_rule[refine_vcg]: \"SUCCEED \\<le> SPEC \\<Phi>\"", "lemma FAIL_rule: \"False \\<Longrightarrow> FAIL \\<le> SPEC \\<Phi>\"", "lemma SPEC_rule[refine_vcg]: \"\\<lbrakk>\\<And>x. \\<Phi> x \\<Longrightarrow> \\<Phi>' x\\<rbrakk> \\<Longrightarrow> SPEC \\<Phi> \\<le> SPEC \\<Phi>'\"", "lemma RETURN_to_SPEC_rule[refine_vcg]: \"m\\<le>SPEC ((=) v) \\<Longrightarrow> m\\<le>RETURN v\"", "lemma Sup_img_rule_complete: \n  \"(\\<forall>x. x\\<in>S \\<longrightarrow> f x \\<le> SPEC \\<Phi>) \\<longleftrightarrow> Sup (f`S) \\<le> SPEC \\<Phi>\"", "lemma SUP_img_rule_complete: \n  \"(\\<forall>x. x\\<in>S \\<longrightarrow> f x \\<le> SPEC \\<Phi>) \\<longleftrightarrow> Sup (f ` S) \\<le> SPEC \\<Phi>\"", "lemma Sup_img_rule[refine_vcg]: \n  \"\\<lbrakk> \\<And>x. x\\<in>S \\<Longrightarrow> f x \\<le> SPEC \\<Phi> \\<rbrakk> \\<Longrightarrow> Sup(f`S) \\<le> SPEC \\<Phi>\"", "lemma bind_rule_complete: \"bind M f \\<le> SPEC \\<Phi> \\<longleftrightarrow> M \\<le> SPEC (\\<lambda>x. f x \\<le> SPEC \\<Phi>)\"", "lemma bind_rule[refine_vcg]: \n  \"\\<lbrakk> M \\<le> SPEC (\\<lambda>x. f x \\<le> SPEC \\<Phi>) \\<rbrakk> \\<Longrightarrow> bind M (\\<lambda>x. f x) \\<le> SPEC \\<Phi>\"\n  \\<comment> \\<open>Note: @{text \"\\<eta>\"}-expanded version helps Isabelle's unification to keep meaningful \n      variable names from the program\\<close>", "lemma ASSUME_rule[refine_vcg]: \"\\<lbrakk>\\<Phi> \\<Longrightarrow> \\<Psi> ()\\<rbrakk> \\<Longrightarrow> ASSUME \\<Phi> \\<le> SPEC \\<Psi>\"", "lemma ASSERT_rule[refine_vcg]: \"\\<lbrakk>\\<Phi>; \\<Phi> \\<Longrightarrow> \\<Psi> ()\\<rbrakk> \\<Longrightarrow> ASSERT \\<Phi> \\<le> SPEC \\<Psi>\"", "lemma prod_rule[refine_vcg]: \n  \"\\<lbrakk>\\<And>a b. p=(a,b) \\<Longrightarrow> S a b \\<le> SPEC \\<Phi>\\<rbrakk> \\<Longrightarrow> case_prod S p \\<le> SPEC \\<Phi>\"", "lemma prod2_rule[refine_vcg]:\n  assumes \"\\<And>a b c d. \\<lbrakk>ab=(a,b); cd=(c,d)\\<rbrakk> \\<Longrightarrow> f a b c d \\<le> SPEC \\<Phi>\"\n  shows \"(\\<lambda>(a,b) (c,d). f a b c d) ab cd \\<le> SPEC \\<Phi>\"", "lemma if_rule[refine_vcg]: \n  \"\\<lbrakk> b \\<Longrightarrow> S1 \\<le> SPEC \\<Phi>; \\<not>b \\<Longrightarrow> S2 \\<le> SPEC \\<Phi>\\<rbrakk> \n  \\<Longrightarrow> (if b then S1 else S2) \\<le> SPEC \\<Phi>\"", "lemma option_rule[refine_vcg]: \n  \"\\<lbrakk> v=None \\<Longrightarrow> S1 \\<le> SPEC \\<Phi>; \\<And>x. v=Some x \\<Longrightarrow> f2 x \\<le> SPEC \\<Phi>\\<rbrakk> \n  \\<Longrightarrow> case_option S1 f2 v \\<le> SPEC \\<Phi>\"", "lemma Let_rule[refine_vcg]:\n  \"f x \\<le> SPEC \\<Phi> \\<Longrightarrow> Let x f \\<le> SPEC \\<Phi>\"", "lemma Let_rule':\n  assumes \"\\<And>x. x=v \\<Longrightarrow> f x \\<le> SPEC \\<Phi>\"\n  shows \"Let v (\\<lambda>x. f x) \\<le> SPEC \\<Phi>\"", "lemma REC_le_rule:\n  assumes M: \"trimono body\"\n  assumes I0: \"(x,x')\\<in>R\"\n  assumes IS: \"\\<And>f x x'. \\<lbrakk> \\<And>x x'. (x,x')\\<in>R \\<Longrightarrow> f x \\<le> M x'; (x,x')\\<in>R \\<rbrakk> \n    \\<Longrightarrow> body f x \\<le> M x'\"\n  shows \"REC body x \\<le> M x'\"", "lemma nr_mono_bind:\n  assumes MA: \"mono A\" and MB: \"\\<And>s. mono (B s)\"\n  shows \"mono (\\<lambda>F s. bind (A F s) (\\<lambda>s'. B s F s'))\"", "lemma nr_mono_bind': \"mono (\\<lambda>F s. bind (f s) F)\"", "lemmas nr_mono = nr_mono_bind nr_mono_bind' mono_const mono_if mono_id", "lemma Id_refine[refine0]: \"S \\<le> \\<Down>Id S\"", "lemma RES_refine: \n  \"\\<lbrakk> \\<And>s. s\\<in>S \\<Longrightarrow> \\<exists>s'\\<in>S'. (s,s')\\<in>R\\<rbrakk> \\<Longrightarrow> RES S \\<le> \\<Down>R (RES S')\"", "lemma SPEC_refine: \n  assumes \"S \\<le> SPEC (\\<lambda>x. \\<exists>x'. (x,x')\\<in>R \\<and> \\<Phi> x')\"\n  shows \"S \\<le> \\<Down>R (SPEC \\<Phi>)\"", "lemma Id_SPEC_refine[refine]: \n  \"S \\<le> SPEC \\<Phi> \\<Longrightarrow> S \\<le> \\<Down>Id (SPEC \\<Phi>)\"", "lemma RETURN_refine[refine]:\n  assumes \"(x,x')\\<in>R\"\n  shows \"RETURN x \\<le> \\<Down>R (RETURN x')\"", "lemma RETURN_SPEC_refine:\n  assumes \"\\<exists>x'. (x,x')\\<in>R \\<and> \\<Phi> x'\"\n  shows \"RETURN x \\<le> \\<Down>R (SPEC \\<Phi>)\"", "lemma FAIL_refine[refine]: \"X \\<le> \\<Down>R FAIL\"", "lemma SUCCEED_refine[refine]: \"SUCCEED \\<le> \\<Down>R X'\"", "lemma sup_refine[refine]:\n  assumes \"ai \\<le>\\<Down>R a\"\n  assumes \"bi \\<le>\\<Down>R b\"\n  shows \"sup ai bi \\<le>\\<Down>R (sup a b)\"", "lemma bind_refine':\n  fixes R' :: \"('a\\<times>'b) set\" and R::\"('c\\<times>'d) set\"\n  assumes R1: \"M \\<le> \\<Down> R' M'\"\n  assumes R2: \"\\<And>x x'. \\<lbrakk> (x,x')\\<in>R'; inres M x; inres M' x';\n    nofail M; nofail M'\n  \\<rbrakk> \\<Longrightarrow> f x \\<le> \\<Down> R (f' x')\"\n  shows \"bind M (\\<lambda>x. f x) \\<le> \\<Down> R (bind M' (\\<lambda>x'. f' x'))\"", "lemma bind_refine[refine]:\n  fixes R' :: \"('a\\<times>'b) set\" and R::\"('c\\<times>'d) set\"\n  assumes R1: \"M \\<le> \\<Down> R' M'\"\n  assumes R2: \"\\<And>x x'. \\<lbrakk> (x,x')\\<in>R' \\<rbrakk> \n    \\<Longrightarrow> f x \\<le> \\<Down> R (f' x')\"\n  shows \"bind M (\\<lambda>x. f x) \\<le> \\<Down> R (bind M' (\\<lambda>x'. f' x'))\"", "lemma bind_refine_abs': (* Only keep nf_inres-information for abstract *)\n  fixes R' :: \"('a\\<times>'b) set\" and R::\"('c\\<times>'d) set\"\n  assumes R1: \"M \\<le> \\<Down> R' M'\"\n  assumes R2: \"\\<And>x x'. \\<lbrakk> (x,x')\\<in>R'; nf_inres M' x'\n  \\<rbrakk> \\<Longrightarrow> f x \\<le> \\<Down> R (f' x')\"\n  shows \"bind M (\\<lambda>x. f x) \\<le> \\<Down> R (bind M' (\\<lambda>x'. f' x'))\"", "lemma bind_refine_RES:\n  \"\\<lbrakk>RES X \\<le> \\<Down> R' M';\n  \\<And>x x'. \\<lbrakk>(x, x') \\<in> R'; x \\<in> X \\<rbrakk> \\<Longrightarrow> f x \\<le> \\<Down> R (f' x')\\<rbrakk>\n  \\<Longrightarrow> RES X \\<bind> (\\<lambda>x. f x) \\<le> \\<Down> R (M' \\<bind> (\\<lambda>x'. f' x'))\"\n\n  \"\\<lbrakk>M \\<le> \\<Down> R' (RES X');\n  \\<And>x x'. \\<lbrakk>(x, x') \\<in> R'; x' \\<in> X' \\<rbrakk> \\<Longrightarrow> f x \\<le> \\<Down> R (f' x')\\<rbrakk>\n  \\<Longrightarrow> M \\<bind> (\\<lambda>x. f x) \\<le> \\<Down> R (RES X' \\<bind> (\\<lambda>x'. f' x'))\"\n\n  \"\\<lbrakk>RES X \\<le> \\<Down> R' (RES X');\n  \\<And>x x'. \\<lbrakk>(x, x') \\<in> R'; x \\<in> X; x' \\<in> X'\\<rbrakk> \\<Longrightarrow> f x \\<le> \\<Down> R (f' x')\\<rbrakk>\n  \\<Longrightarrow> RES X \\<bind> (\\<lambda>x. f x) \\<le> \\<Down> R (RES X' \\<bind> (\\<lambda>x'. f' x'))\"", "lemma ASSERT_refine[refine]:\n  \"\\<lbrakk> \\<Phi>'\\<Longrightarrow>\\<Phi> \\<rbrakk> \\<Longrightarrow> ASSERT \\<Phi> \\<le> \\<Down>Id (ASSERT \\<Phi>')\"", "lemma ASSUME_refine[refine]: \n  \"\\<lbrakk> \\<Phi> \\<Longrightarrow> \\<Phi>' \\<rbrakk> \\<Longrightarrow> ASSUME \\<Phi> \\<le> \\<Down>Id (ASSUME \\<Phi>')\"", "lemma ASSERT_refine_right:\n  assumes \"\\<Phi> \\<Longrightarrow> S \\<le>\\<Down>R S'\"\n  shows \"S \\<le>\\<Down>R (do {ASSERT \\<Phi>; S'})\"", "lemma ASSERT_refine_right_pres:\n  assumes \"\\<Phi> \\<Longrightarrow> S \\<le>\\<Down>R (do {ASSERT \\<Phi>; S'})\"\n  shows \"S \\<le>\\<Down>R (do {ASSERT \\<Phi>; S'})\"", "lemma ASSERT_refine_left:\n  assumes \"\\<Phi>\"\n  assumes \"\\<Phi> \\<Longrightarrow> S \\<le> \\<Down>R S'\"\n  shows \"do{ASSERT \\<Phi>; S} \\<le> \\<Down>R S'\"", "lemma ASSUME_refine_right:\n  assumes \"\\<Phi>\"\n  assumes \"\\<Phi> \\<Longrightarrow> S \\<le>\\<Down>R S'\"\n  shows \"S \\<le>\\<Down>R (do {ASSUME \\<Phi>; S'})\"", "lemma ASSUME_refine_left:\n  assumes \"\\<Phi> \\<Longrightarrow> S \\<le> \\<Down>R S'\"\n  shows \"do {ASSUME \\<Phi>; S} \\<le> \\<Down>R S'\"", "lemma ASSUME_refine_left_pres:\n  assumes \"\\<Phi> \\<Longrightarrow> do {ASSUME \\<Phi>; S} \\<le> \\<Down>R S'\"\n  shows \"do {ASSUME \\<Phi>; S} \\<le> \\<Down>R S'\"", "lemmas [refine0] = ASSUME_refine_right", "lemmas [refine0] = ASSERT_refine_left", "lemmas [refine0] = ASSUME_refine_left", "lemmas [refine0] = ASSERT_refine_right", "lemmas [refine] = ASSUME_refine_right", "lemmas [refine] = ASSERT_refine_left", "lemmas [refine] = ASSUME_refine_left", "lemmas [refine] = ASSERT_refine_right", "lemma lift_assnI: \"\\<lbrakk>(s,s')\\<in>R; \\<Phi> s'\\<rbrakk> \\<Longrightarrow> lift_assn R \\<Phi> s\"", "lemma REC_refine[refine]:\n  assumes M: \"trimono body\"\n  assumes R0: \"(x,x')\\<in>R\"\n  assumes RS: \"\\<And>f f' x x'. \\<lbrakk> \\<And>x x'. (x,x')\\<in>R \\<Longrightarrow> f x \\<le>\\<Down>S (f' x'); (x,x')\\<in>R; \n        REC body' = f' \\<rbrakk> \n    \\<Longrightarrow> body f x \\<le>\\<Down>S (body' f' x')\"\n  shows \"REC (\\<lambda>f x. body f x) x \\<le>\\<Down>S (REC (\\<lambda>f' x'. body' f' x') x')\"", "lemma RECT_refine[refine]:\n  assumes M: \"trimono body\"\n  assumes R0: \"(x,x')\\<in>R\"\n  assumes RS: \"\\<And>f f' x x'. \\<lbrakk> \\<And>x x'. (x,x')\\<in>R \\<Longrightarrow> f x \\<le>\\<Down>S (f' x'); (x,x')\\<in>R \\<rbrakk> \n    \\<Longrightarrow> body f x \\<le>\\<Down>S (body' f' x')\"\n  shows \"RECT (\\<lambda>f x. body f x) x \\<le>\\<Down>S (RECT (\\<lambda>f' x'. body' f' x') x')\"", "lemma if_refine[refine]:\n  assumes \"b \\<longleftrightarrow> b'\"\n  assumes \"\\<lbrakk>b;b'\\<rbrakk> \\<Longrightarrow> S1 \\<le> \\<Down>R S1'\"\n  assumes \"\\<lbrakk>\\<not>b;\\<not>b'\\<rbrakk> \\<Longrightarrow> S2 \\<le> \\<Down>R S2'\"\n  shows \"(if b then S1 else S2) \\<le> \\<Down>R (if b' then S1' else S2')\"", "lemma Let_unfold_refine[refine]:\n  assumes \"f x \\<le> \\<Down>R (f' x')\"\n  shows \"Let x f \\<le> \\<Down>R (Let x' f')\"", "lemma Let_refine:\n  assumes \"(m,m')\\<in>R'\"\n  assumes \"\\<And>x x'. (x,x')\\<in>R' \\<Longrightarrow> f x \\<le> \\<Down>R (f' x')\"\n  shows \"Let m (\\<lambda>x. f x) \\<le>\\<Down>R (Let m' (\\<lambda>x'. f' x'))\"", "lemma Let_refine':\n  assumes \"(m,m')\\<in>R\"\n  assumes \"(m,m')\\<in>R \\<Longrightarrow> f m \\<le>\\<Down>S (f' m')\"\n  shows \"Let m f \\<le> \\<Down>S (Let m' f')\"", "lemma case_option_refine[refine]:\n  assumes \"(v,v')\\<in>\\<langle>Ra\\<rangle>option_rel\"\n  assumes \"\\<lbrakk>v=None; v'=None\\<rbrakk> \\<Longrightarrow> n \\<le> \\<Down> Rb n'\"\n  assumes \"\\<And>x x'. \\<lbrakk> v=Some x; v'=Some x'; (x, x') \\<in> Ra \\<rbrakk> \n    \\<Longrightarrow> f x \\<le> \\<Down> Rb (f' x')\"\n  shows \"case_option n f v \\<le>\\<Down>Rb (case_option n' f' v')\"", "lemma list_case_refine[refine]: \n  assumes \"(li,l)\\<in>\\<langle>S\\<rangle>list_rel\"\n  assumes \"fni \\<le>\\<Down>R fn\"  \n  assumes \"\\<And>xi x xsi xs. \\<lbrakk> (xi,x)\\<in>S; (xsi,xs)\\<in>\\<langle>S\\<rangle>list_rel; li=xi#xsi; l=x#xs \\<rbrakk> \\<Longrightarrow> fci xi xsi \\<le>\\<Down>R (fc x xs)\"  \n  shows \"(case li of [] \\<Rightarrow> fni | xi#xsi \\<Rightarrow> fci xi xsi) \\<le> \\<Down>R (case l of [] \\<Rightarrow> fn | x#xs \\<Rightarrow> fc x xs)\"", "lemma remove_Let_refine[refine2]:\n  assumes \"M \\<le> \\<Down>R (f x)\"\n  shows \"M \\<le> \\<Down>R (Let x f)\"", "lemma intro_Let_refine[refine2]:\n  assumes \"f x \\<le> \\<Down>R M'\"\n  shows \"Let x f \\<le> \\<Down>R M'\"", "lemma bind2let_refine[refine2]:\n  assumes \"RETURN x \\<le> \\<Down>R' M'\"\n  assumes \"\\<And>x'. (x,x')\\<in>R' \\<Longrightarrow> f x \\<le> \\<Down>R (f' x')\"\n  shows \"Let x f \\<le> \\<Down>R (bind M' (\\<lambda>x'. f' x'))\"", "lemma bind_Let_refine2[refine2]: \"\\<lbrakk> \n    m' \\<le>\\<Down>R' (RETURN x);\n    \\<And>x'. \\<lbrakk>inres m' x'; (x',x)\\<in>R'\\<rbrakk> \\<Longrightarrow> f' x' \\<le> \\<Down>R (f x) \n  \\<rbrakk> \\<Longrightarrow> m'\\<bind>(\\<lambda>x'. f' x') \\<le> \\<Down>R (Let x (\\<lambda>x. f x))\"", "lemma bind2letRETURN_refine[refine2]:\n  assumes \"RETURN x \\<le> \\<Down>R' M'\"\n  assumes \"\\<And>x'. (x,x')\\<in>R' \\<Longrightarrow> RETURN (f x) \\<le> \\<Down>R (f' x')\"\n  shows \"RETURN (Let x f) \\<le> \\<Down>R (bind M' (\\<lambda>x'. f' x'))\"", "lemma RETURN_as_SPEC_refine[refine2]:\n  assumes \"M \\<le> SPEC (\\<lambda>c. (c,a)\\<in>R)\"\n  shows \"M \\<le> \\<Down>R (RETURN a)\"", "lemma RETURN_as_SPEC_refine_old:\n  \"\\<And>M R. M \\<le> \\<Down>R (SPEC (\\<lambda>x. x=v)) \\<Longrightarrow> M \\<le>\\<Down>R (RETURN v)\"", "lemma if_RETURN_refine [refine2]:\n  assumes \"b \\<longleftrightarrow> b'\"\n  assumes \"\\<lbrakk>b;b'\\<rbrakk> \\<Longrightarrow> RETURN S1 \\<le> \\<Down>R S1'\"\n  assumes \"\\<lbrakk>\\<not>b;\\<not>b'\\<rbrakk> \\<Longrightarrow> RETURN S2 \\<le> \\<Down>R S2'\"\n  shows \"RETURN (if b then S1 else S2) \\<le> \\<Down>R (if b' then S1' else S2')\"", "lemma RES_sng_as_SPEC_refine[refine2]:\n  assumes \"M \\<le> SPEC (\\<lambda>c. (c,a)\\<in>R)\"\n  shows \"M \\<le> \\<Down>R (RES {a})\"", "lemma intro_spec_refine_iff:\n  \"(bind (RES X) f \\<le> \\<Down>R M) \\<longleftrightarrow> (\\<forall>x\\<in>X. f x \\<le> \\<Down>R M)\"", "lemma intro_spec_refine[refine2]:\n  assumes \"\\<And>x. x\\<in>X \\<Longrightarrow> f x \\<le> \\<Down>R M\"\n  shows \"bind (RES X) (\\<lambda>x. f x) \\<le> \\<Down>R M\"", "lemma let2bind_refine:\n  assumes \"m \\<le> \\<Down>R' (RETURN m')\"\n  assumes \"\\<And>x x'. (x,x')\\<in>R' \\<Longrightarrow> f x \\<le> \\<Down>R (f' x')\"\n  shows \"bind m (\\<lambda>x. f x) \\<le> \\<Down>R (Let m' (\\<lambda>x'. f' x'))\"", "lemma intro_bind_refine:\n  assumes \"m \\<le> \\<Down>R' (RETURN m')\"\n  assumes \"\\<And>x. (x,m')\\<in>R' \\<Longrightarrow> f x \\<le> \\<Down>R m''\"\n  shows \"bind m (\\<lambda>x. f x) \\<le> \\<Down>R m''\"", "lemma intro_bind_refine_id:\n  assumes \"m \\<le> (SPEC ((=) m'))\"\n  assumes \"f m' \\<le> \\<Down>R m''\"\n  shows \"bind m f \\<le> \\<Down>R m''\"", "lemma lhs_step_If:\n  \"\\<lbrakk> b \\<Longrightarrow> t \\<le> m; \\<not>b \\<Longrightarrow> e \\<le> m \\<rbrakk> \\<Longrightarrow> If b t e \\<le> m\"", "lemma lhs_step_RES:\n  \"\\<lbrakk> \\<And>x. x\\<in>X \\<Longrightarrow> RETURN x \\<le> m  \\<rbrakk> \\<Longrightarrow> RES X \\<le> m\"", "lemma lhs_step_SPEC:\n  \"\\<lbrakk> \\<And>x. \\<Phi> x \\<Longrightarrow> RETURN x \\<le> m \\<rbrakk> \\<Longrightarrow> SPEC (\\<lambda>x. \\<Phi> x) \\<le> m\"", "lemma lhs_step_bind:\n  fixes m :: \"'a nres\" and f :: \"'a \\<Rightarrow> 'b nres\"\n  assumes \"nofail m' \\<Longrightarrow> nofail m\"\n  assumes \"\\<And>x. nf_inres m x \\<Longrightarrow> f x \\<le> m'\"\n  shows \"do {x\\<leftarrow>m; f x} \\<le> m'\"", "lemma rhs_step_bind:\n  assumes \"m \\<le> \\<Down>R m'\" \"inres m x\" \"\\<And>x'. (x,x')\\<in>R \\<Longrightarrow> lhs \\<le>\\<Down>S (f' x')\"\n  shows \"lhs \\<le> \\<Down>S (m' \\<bind> f')\"", "lemma rhs_step_bind_RES:\n  assumes \"x'\\<in>X'\"\n  assumes \"m \\<le> \\<Down>R (f' x')\"\n  shows \"m \\<le> \\<Down>R (RES X' \\<bind> f')\"", "lemma rhs_step_bind_SPEC:\n  assumes \"\\<Phi> x'\"\n  assumes \"m \\<le> \\<Down>R (f' x')\"\n  shows \"m \\<le> \\<Down>R (SPEC \\<Phi> \\<bind> f')\"", "lemma RES_bind_choose:\n  assumes \"x\\<in>X\"\n  assumes \"m \\<le> f x\"\n  shows \"m \\<le> RES X \\<bind> f\"", "lemma pw_RES_bind_choose: \n  \"nofail (RES X \\<bind> f) \\<longleftrightarrow> (\\<forall>x\\<in>X. nofail (f x))\"\n  \"inres (RES X \\<bind> f) y \\<longleftrightarrow> (\\<exists>x\\<in>X. inres (f x) y)\"", "lemma prod_case_refine:  \n  assumes \"(p',p)\\<in>R1\\<times>\\<^sub>rR2\"\n  assumes \"\\<And>x1' x2' x1 x2. \\<lbrakk> p'=(x1',x2'); p=(x1,x2); (x1',x1)\\<in>R1; (x2',x2)\\<in>R2\\<rbrakk> \\<Longrightarrow> f' x1' x2' \\<le> \\<Down>R (f x1 x2)\"\n  shows \"(case p' of (x1',x2') \\<Rightarrow> f' x1' x2') \\<le>\\<Down>R (case p of (x1,x2) \\<Rightarrow> f x1 x2)\"", "lemma nres_rel_def: \"\\<langle>R\\<rangle>nres_rel \\<equiv> {(c,a). c \\<le> \\<Down>R a}\"", "lemma nres_relD: \"(c,a)\\<in>\\<langle>R\\<rangle>nres_rel \\<Longrightarrow> c \\<le>\\<Down>R a\"", "lemma nres_relI[refine]: \"c \\<le>\\<Down>R a \\<Longrightarrow> (c,a)\\<in>\\<langle>R\\<rangle>nres_rel\"", "lemma nres_rel_comp: \"\\<langle>A\\<rangle>nres_rel O \\<langle>B\\<rangle>nres_rel = \\<langle>A O B\\<rangle>nres_rel\"", "lemma pw_nres_rel_iff: \"(a,b)\\<in>\\<langle>A\\<rangle>nres_rel \\<longleftrightarrow> nofail (\\<Down> A b) \\<longrightarrow> nofail a \\<and> (\\<forall>x. inres a x \\<longrightarrow> inres (\\<Down> A b) x)\"", "lemma param_SUCCEED[param]: \"(SUCCEED,SUCCEED) \\<in> \\<langle>R\\<rangle>nres_rel\"", "lemma param_FAIL[param]: \"(FAIL,FAIL) \\<in> \\<langle>R\\<rangle>nres_rel\"", "lemma param_RES[param]:\n  \"(RES,RES) \\<in> \\<langle>R\\<rangle>set_rel \\<rightarrow> \\<langle>R\\<rangle>nres_rel\"", "lemma param_RETURN[param]: \n  \"(RETURN,RETURN) \\<in> R \\<rightarrow> \\<langle>R\\<rangle>nres_rel\"", "lemma param_bind[param]:\n  \"(bind,bind) \\<in> \\<langle>Ra\\<rangle>nres_rel \\<rightarrow> (Ra\\<rightarrow>\\<langle>Rb\\<rangle>nres_rel) \\<rightarrow> \\<langle>Rb\\<rangle>nres_rel\"", "lemma param_ASSERT_bind[param]: \"\\<lbrakk> \n    (\\<Phi>,\\<Psi>) \\<in> bool_rel; \n    \\<lbrakk> \\<Phi>; \\<Psi> \\<rbrakk> \\<Longrightarrow> (f,g)\\<in>\\<langle>R\\<rangle>nres_rel\n  \\<rbrakk> \\<Longrightarrow> (ASSERT \\<Phi> \\<then> f, ASSERT \\<Psi> \\<then> g) \\<in> \\<langle>R\\<rangle>nres_rel\"", "lemmas [autoref_rel_intf] = REL_INTFI[of nres_rel i_nres]", "lemma param_op_nres_ASSERT_bnd[param]:\n  assumes \"\\<Phi>' \\<Longrightarrow> \\<Phi>\"\n  assumes \"\\<lbrakk>\\<Phi>'; \\<Phi>\\<rbrakk> \\<Longrightarrow> (m,m')\\<in>\\<langle>R\\<rangle>nres_rel\"\n  shows \"(op_nres_ASSERT_bnd \\<Phi> m, op_nres_ASSERT_bnd \\<Phi>' m') \\<in> \\<langle>R\\<rangle>nres_rel\"", "lemma id_ASSERT[autoref_op_pat_def]:\n  \"do {ASSERT \\<Phi>; m} \\<equiv> OP (op_nres_ASSERT_bnd \\<Phi>)$m\"", "lemma id_ASSUME[autoref_op_pat_def]:\n  \"do {ASSUME \\<Phi>; m} \\<equiv> OP (op_nres_ASSUME_bnd \\<Phi>)$m\"", "lemma autoref_SUCCEED[autoref_rules]: \"(SUCCEED,SUCCEED) \\<in> \\<langle>R\\<rangle>nres_rel\"", "lemma autoref_FAIL[autoref_rules]: \"(FAIL,FAIL) \\<in> \\<langle>R\\<rangle>nres_rel\"", "lemma autoref_RETURN[autoref_rules]: \n  \"(RETURN,RETURN) \\<in> R \\<rightarrow> \\<langle>R\\<rangle>nres_rel\"", "lemma autoref_bind[autoref_rules]: \n  \"(bind,bind) \\<in> \\<langle>R1\\<rangle>nres_rel \\<rightarrow> (R1\\<rightarrow>\\<langle>R2\\<rangle>nres_rel) \\<rightarrow> \\<langle>R2\\<rangle>nres_rel\"", "lemma autoref_ASSERT[autoref_rules]:\n  assumes \"\\<Phi> \\<Longrightarrow> (m',m)\\<in>\\<langle>R\\<rangle>nres_rel\"\n  shows \"(\n    m',\n    (OP (op_nres_ASSERT_bnd \\<Phi>) ::: \\<langle>R\\<rangle>nres_rel \\<rightarrow> \\<langle>R\\<rangle>nres_rel) $ m)\\<in>\\<langle>R\\<rangle>nres_rel\"", "lemma autoref_ASSUME[autoref_rules]:\n  assumes \"SIDE_PRECOND \\<Phi>\"\n  assumes \"\\<Phi> \\<Longrightarrow> (m',m)\\<in>\\<langle>R\\<rangle>nres_rel\"\n  shows \"(\n    m',\n    (OP (op_nres_ASSUME_bnd \\<Phi>) ::: \\<langle>R\\<rangle>nres_rel \\<rightarrow> \\<langle>R\\<rangle>nres_rel) $ m)\\<in>\\<langle>R\\<rangle>nres_rel\"", "lemma autoref_REC[autoref_rules]:\n  assumes \"(B,B')\\<in>(Ra\\<rightarrow>\\<langle>Rr\\<rangle>nres_rel) \\<rightarrow> Ra \\<rightarrow> \\<langle>Rr\\<rangle>nres_rel\"\n  assumes \"DEFER trimono B\"\n  shows \"(REC B,\n    (OP REC \n      ::: ((Ra\\<rightarrow>\\<langle>Rr\\<rangle>nres_rel) \\<rightarrow> Ra \\<rightarrow> \\<langle>Rr\\<rangle>nres_rel) \\<rightarrow> Ra \\<rightarrow> \\<langle>Rr\\<rangle>nres_rel)$B'\n    ) \\<in> Ra \\<rightarrow> \\<langle>Rr\\<rangle>nres_rel\"", "theorem param_RECT[param]:\n  assumes \"(B, B') \\<in> (Ra \\<rightarrow> \\<langle>Rr\\<rangle>nres_rel) \\<rightarrow> Ra \\<rightarrow> \\<langle>Rr\\<rangle>nres_rel\"\n    and \"trimono B\"\n  shows \"(REC\\<^sub>T B, REC\\<^sub>T B')\\<in> Ra \\<rightarrow> \\<langle>Rr\\<rangle>nres_rel\"", "lemma autoref_RECT[autoref_rules]:\n  assumes \"(B,B') \\<in> (Ra\\<rightarrow>\\<langle>Rr\\<rangle>nres_rel) \\<rightarrow> Ra\\<rightarrow>\\<langle>Rr\\<rangle>nres_rel\"\n  assumes \"DEFER trimono B\"\n  shows \"(RECT B,\n    (OP RECT \n      ::: ((Ra\\<rightarrow>\\<langle>Rr\\<rangle>nres_rel) \\<rightarrow> Ra \\<rightarrow> \\<langle>Rr\\<rangle>nres_rel) \\<rightarrow> Ra \\<rightarrow> \\<langle>Rr\\<rangle>nres_rel)$B'\n    ) \\<in> Ra \\<rightarrow> \\<langle>Rr\\<rangle>nres_rel\"", "lemma ref_two_step: \"A\\<le>\\<Down>R  B \\<Longrightarrow> B\\<le>C \\<Longrightarrow> A\\<le>\\<Down>R  C\"", "lemma pw_ref_iff:\n  shows \"S \\<le> \\<Down>R S' \n  \\<longleftrightarrow> (nofail S' \n    \\<longrightarrow> nofail S \\<and> (\\<forall>x. inres S x \\<longrightarrow> (\\<exists>s'. (x, s') \\<in> R \\<and> inres S' s')))\"", "lemma pw_ref_I:\n  assumes \"nofail S' \n    \\<longrightarrow> nofail S \\<and> (\\<forall>x. inres S x \\<longrightarrow> (\\<exists>s'. (x, s') \\<in> R \\<and> inres S' s'))\"\n  shows \"S \\<le> \\<Down>R S'\"", "lemma introR: \"(a,a')\\<in>R \\<Longrightarrow> (a,a')\\<in>R\"", "lemma intro_prgR: \"c \\<le> \\<Down>R a \\<Longrightarrow> c \\<le> \\<Down>R a\"", "lemma refine_IdI: \"m \\<le> m' \\<Longrightarrow> m \\<le> \\<Down>Id m'\"", "lemma le_ASSERTI_pres:\n  assumes \"\\<Phi> \\<Longrightarrow> S \\<le> do {ASSERT \\<Phi>; S'}\"\n  shows \"S \\<le> do {ASSERT \\<Phi>; S'}\"", "lemma RETURN_ref_SPECD:\n  assumes \"RETURN c \\<le> \\<Down>R (SPEC \\<Phi>)\"\n  obtains a where \"(c,a)\\<in>R\" \"\\<Phi> a\"", "lemma RETURN_ref_RETURND:\n  assumes \"RETURN c \\<le> \\<Down>R (RETURN a)\"\n  shows \"(c,a)\\<in>R\"", "lemma return_refine_prop_return:\n  assumes \"nofail m\"\n  assumes \"RETURN x \\<le> \\<Down>R m\"\n  obtains x' where \"(x,x')\\<in>R\" \"RETURN x' \\<le> m\"", "lemma ignore_snd_refine_conv: \n  \"(m \\<le> \\<Down>(R\\<times>\\<^sub>rUNIV) m') \\<longleftrightarrow> m\\<bind>(RETURN o fst) \\<le>\\<Down>R (m'\\<bind>(RETURN o fst))\"", "lemma ret_le_down_conv: \n  \"nofail m \\<Longrightarrow> RETURN c \\<le> \\<Down>R m \\<longleftrightarrow> (\\<exists>a. (c,a)\\<in>R \\<and> RETURN a \\<le> m)\"", "lemma SPEC_eq_is_RETURN:\n  \"SPEC ((=) x) = RETURN x\"\n  \"SPEC (\\<lambda>x. x=y) = RETURN y\"", "lemma RETURN_SPEC_conv: \"RETURN r = SPEC (\\<lambda>x. x=r)\"", "lemma refine2spec_aux:\n  \"a \\<le> \\<Down>R b \\<longleftrightarrow> ( (nofail b \\<longrightarrow> a \\<le> SPEC ( \\<lambda>r. (\\<exists>x. inres b x \\<and> (r,x)\\<in>R) )) )\"", "lemma refine2specI:\n  assumes \"nofail b \\<Longrightarrow> a \\<le> SPEC (\\<lambda>r. (\\<exists>x. inres b x \\<and> (r,x)\\<in>R) )\"\n  shows \"a \\<le> \\<Down>R b\"", "lemma specify_left:\n  assumes \"m \\<le> SPEC \\<Phi>\"\n  assumes \"\\<And>x. \\<Phi> x \\<Longrightarrow> f x \\<le> M\"  \n  shows \"do { x \\<leftarrow> m; f x } \\<le> M\"", "lemma build_rel_SPEC: \n  \"M \\<le> SPEC ( \\<lambda>x. \\<Phi> (\\<alpha> x) \\<and> I x) \\<Longrightarrow> M \\<le> \\<Down>(build_rel \\<alpha> I) (SPEC \\<Phi>)\"", "lemma build_rel_SPEC_conv: \"\\<Down>(br \\<alpha> I) (SPEC \\<Phi>) = SPEC (\\<lambda>x. I x \\<and> \\<Phi> (\\<alpha> x))\"", "lemma refine_IdD: \"c \\<le> \\<Down>Id a \\<Longrightarrow> c \\<le> a\"", "lemma bind_sim_select_rule:\n  assumes \"m\\<bind>f' \\<le> SPEC \\<Psi>\"\n  assumes \"\\<And>x. \\<lbrakk>nofail m; inres m x; f' x\\<le>SPEC \\<Psi>\\<rbrakk> \\<Longrightarrow> f x\\<le>SPEC \\<Phi>\"\n  shows \"m\\<bind>f \\<le> SPEC \\<Phi>\"\n  \\<comment> \\<open>Simultaneously select a result from assumption and verification goal.\n    Useful to work with assumptions that restrict the current program to \n    be verified.\\<close>", "lemma assert_bind_spec_conv: \"ASSERT \\<Phi> \\<then> m \\<le> SPEC \\<Psi> \\<longleftrightarrow> (\\<Phi> \\<and> m \\<le> SPEC \\<Psi>)\"  \n  \\<comment> \\<open>Simplify a bind-assert verification condition. \n    Useful if this occurs in the assumptions, and considerably faster than \n    using pointwise reasoning, which may causes a blowup for many chained \n    assertions.\\<close>", "lemma summarize_ASSERT_conv: \"do {ASSERT \\<Phi>; ASSERT \\<Psi>; m} = do {ASSERT (\\<Phi> \\<and> \\<Psi>); m}\"", "lemma bind_ASSERT_eq_if: \"do { ASSERT \\<Phi>; m } = (if \\<Phi> then m else FAIL)\"", "lemma le_RES_nofailI:\n  assumes \"a\\<le>RES x\"\n  shows \"nofail a\"", "lemma add_invar_refineI:\n  assumes \"f x \\<le>\\<Down>R (f' x')\"\n    and \"nofail (f x) \\<Longrightarrow> f x \\<le> SPEC I\"\n  shows \"f x \\<le> \\<Down> {(c, a). (c, a) \\<in> R \\<and> I c} (f' x')\"", "lemma bind_RES_RETURN_eq: \"bind (RES X) (\\<lambda>x. RETURN (f x)) = \n  RES { f x | x. x\\<in>X }\"", "lemma bind_RES_RETURN2_eq: \"bind (RES X) (\\<lambda>(x,y). RETURN (f x y)) = \n  RES { f x y | x y. (x,y)\\<in>X }\"", "lemma le_SPEC_bindI: \n  assumes \"\\<Phi> x\"\n  assumes \"m \\<le> f x\"\n  shows \"m \\<le> SPEC \\<Phi> \\<bind> f\"", "lemma bind_assert_refine: \n  assumes \"m1 \\<le> SPEC \\<Phi>\"\n  assumes \"\\<And>x. \\<Phi> x \\<Longrightarrow> m2 x \\<le> m'\"\n  shows \"do {x\\<leftarrow>m1; ASSERT (\\<Phi> x); m2 x} \\<le> m'\"", "lemma RETURN_refine_iff[simp]: \"RETURN x \\<le>\\<Down>R (RETURN y) \\<longleftrightarrow> (x,y)\\<in>R\"", "lemma RETURN_RES_refine_iff: \n  \"RETURN x \\<le>\\<Down>R (RES Y) \\<longleftrightarrow> (\\<exists>y\\<in>Y. (x,y)\\<in>R)\"", "lemma RETURN_RES_refine:\n  assumes \"\\<exists>x'. (x,x')\\<in>R \\<and> x'\\<in>X\"\n  shows \"RETURN x \\<le> \\<Down>R (RES X)\"", "lemma in_nres_rel_iff: \"(a,b)\\<in>\\<langle>R\\<rangle>nres_rel \\<longleftrightarrow> a \\<le>\\<Down>R b\"", "lemma inf_RETURN_RES: \n  \"inf (RETURN x) (RES X) = (if x\\<in>X then RETURN x else SUCCEED)\"\n  \"inf (RES X) (RETURN x) = (if x\\<in>X then RETURN x else SUCCEED)\"", "lemma inf_RETURN_SPEC[simp]:\n  \"inf (RETURN x) (SPEC (\\<lambda>y. \\<Phi> y)) = SPEC (\\<lambda>y. y=x \\<and> \\<Phi> x)\"\n  \"inf (SPEC (\\<lambda>y. \\<Phi> y)) (RETURN x) = SPEC (\\<lambda>y. y=x \\<and> \\<Phi> x)\"", "lemma RES_sng_eq_RETURN: \"RES {x} = RETURN x\"", "lemma nofail_inf_serialize:\n  \"\\<lbrakk>nofail a; nofail b\\<rbrakk> \\<Longrightarrow> inf a b = do {x\\<leftarrow>a; ASSUME (inres b x); RETURN x}\"", "lemma conc_fun_SPEC: \n  \"\\<Down>R (SPEC (\\<lambda>x. \\<Phi> x)) = SPEC (\\<lambda>y. \\<exists>x. (y,x)\\<in>R \\<and> \\<Phi> x)\"", "lemma conc_fun_RETURN: \n  \"\\<Down>R (RETURN x) = SPEC (\\<lambda>y. (y,x)\\<in>R)\"", "lemma use_spec_rule:\n  assumes \"m \\<le> SPEC \\<Psi>\"\n  assumes \"m \\<le> SPEC (\\<lambda>s. \\<Psi> s \\<longrightarrow> \\<Phi> s)\"\n  shows \"m \\<le> SPEC \\<Phi>\"", "lemma strengthen_SPEC: \"m \\<le> SPEC \\<Phi> \\<Longrightarrow> m \\<le> SPEC(\\<lambda>s. inres m s \\<and> nofail m \\<and> \\<Phi> s)\"\n  \\<comment> \\<open>Strengthen SPEC by adding trivial upper bound for result\\<close>", "lemma weaken_SPEC:\n  \"m \\<le> SPEC \\<Phi> \\<Longrightarrow> (\\<And>x. \\<Phi> x \\<Longrightarrow> \\<Psi> x) \\<Longrightarrow> m \\<le> SPEC \\<Psi>\"", "lemma bind_le_nofailI:\n  assumes \"nofail m\"\n  assumes \"\\<And>x. RETURN x \\<le> m \\<Longrightarrow> f x \\<le> m'\"\n  shows \"m\\<bind>f \\<le> m'\"", "lemma bind_le_shift:\n  \"bind m f \\<le> m' \n  \\<longleftrightarrow> m \\<le> (if nofail m' then SPEC (\\<lambda>x. f x \\<le> m') else FAIL)\"", "lemma If_bind_distrib[simp]:\n  fixes t e :: \"'a nres\"\n  shows \"(If b t e \\<bind> (\\<lambda>x. f x)) = (If b (t\\<bind>(\\<lambda>x. f x)) (e\\<bind>(\\<lambda>x. f x)))\"", "lemma unused_bind_conv: \n  assumes \"NO_MATCH (ASSERT \\<Phi>) m\"\n  assumes \"NO_MATCH (ASSUME \\<Phi>) m\"\n  shows \"(m\\<bind>(\\<lambda>x. c))  = (ASSERT (nofail m) \\<bind> (\\<lambda>_. ASSUME (\\<exists>x. inres m x) \\<bind> (\\<lambda>x. c)))\"", "lemma let_to_bind_conv: \n  \"Let x f = RETURN x\\<bind>f\"", "lemmas bind_to_let_conv = let_to_bind_conv[symmetric]", "lemma pull_out_let_conv: \"RETURN (Let x f) = Let x (\\<lambda>x. RETURN (f x))\"", "lemma push_in_let_conv: \n  \"Let x (\\<lambda>x. RETURN (f x)) = RETURN (Let x f)\"\n  \"Let x (RETURN o f) = RETURN (Let x f)\"", "lemma pull_out_RETURN_case_option: \n  \"case_option (RETURN a) (\\<lambda>v. RETURN (f v)) x = RETURN (case_option a f x)\"", "lemma if_bind_cond_refine: \n  assumes \"ci \\<le> RETURN b\"\n  assumes \"b \\<Longrightarrow> ti\\<le>\\<Down>R t\"\n  assumes \"\\<not>b \\<Longrightarrow> ei\\<le>\\<Down>R e\"\n  shows \"do {b\\<leftarrow>ci; if b then ti else ei} \\<le> \\<Down>R (if b then t else e)\"", "lemma intro_RETURN_Let_refine:\n  assumes \"RETURN (f x) \\<le> \\<Down>R M'\"\n  shows \"RETURN (Let x f) \\<le> \\<Down>R M'\"", "lemma ife_FAIL_to_ASSERT_cnv: \n  \"(if \\<Phi> then m else FAIL) = op_nres_ASSERT_bnd \\<Phi> m\"", "lemma nres_bind_let_law: \"(do { x \\<leftarrow> do { let y=v; f y }; g x } :: _ nres)\n  = do { let y=v; x\\<leftarrow> f y; g x }\"", "lemma unused_bind_RES_ne[simp]: \"X\\<noteq>{} \\<Longrightarrow> do { _ \\<leftarrow> RES X; m} = m\"", "lemma le_ASSERT_defI1:\n  assumes \"c \\<equiv> do {ASSERT \\<Phi>; m}\"\n  assumes \"\\<Phi> \\<Longrightarrow> m' \\<le> c\"\n  shows \"m' \\<le> c\"", "lemma refine_ASSERT_defI1:\n  assumes \"c \\<equiv> do {ASSERT \\<Phi>; m}\"\n  assumes \"\\<Phi> \\<Longrightarrow> m' \\<le> \\<Down>R c\"\n  shows \"m' \\<le> \\<Down>R c\"", "lemma le_ASSERT_defI2:\n  assumes \"c \\<equiv> do {ASSERT \\<Phi>; ASSERT \\<Psi>; m}\"\n  assumes \"\\<lbrakk>\\<Phi>; \\<Psi>\\<rbrakk> \\<Longrightarrow> m' \\<le> c\"\n  shows \"m' \\<le> c\"", "lemma refine_ASSERT_defI2:\n  assumes \"c \\<equiv> do {ASSERT \\<Phi>; ASSERT \\<Psi>; m}\"\n  assumes \"\\<lbrakk>\\<Phi>; \\<Psi>\\<rbrakk> \\<Longrightarrow> m' \\<le> \\<Down>R c\"\n  shows \"m' \\<le> \\<Down>R c\"", "lemma ASSERT_le_defI:\n  assumes \"c \\<equiv> do { ASSERT \\<Phi>; m'}\"\n  assumes \"\\<Phi>\"\n  assumes \"\\<Phi> \\<Longrightarrow> m' \\<le> m\"\n  shows \"c \\<le> m\"", "lemma ASSERT_same_eq_conv: \"(ASSERT \\<Phi> \\<then> m) = (ASSERT \\<Phi> \\<then> n) \\<longleftrightarrow> (\\<Phi> \\<longrightarrow> m=n)\"", "lemma case_prod_bind_simp[simp]: \"\n  (\\<lambda>x. (case x of (a, b) \\<Rightarrow> f a b) \\<le> SPEC \\<Phi>) = (\\<lambda>(a,b). f a b \\<le> SPEC \\<Phi>)\"", "lemma RECT_eq_REC': \"nofail (RECT B x) \\<Longrightarrow> RECT B x = REC B x\"", "lemma rel2p_nres_RETURN[rel2p]: \"rel2p (\\<langle>A\\<rangle>nres_rel) (RETURN x) (RETURN y) = rel2p A x y\"", "lemma SPEC_iff:\n  assumes \"P \\<le> SPEC (\\<lambda>s. Q s \\<longrightarrow> R s)\"\n  and \"P \\<le> SPEC (\\<lambda>s. \\<not> Q s \\<longrightarrow> \\<not> R s)\"\n  shows \"P \\<le> SPEC (\\<lambda>s. Q s \\<longleftrightarrow> R s)\"", "lemma SPEC_rule_conjI:\n  assumes \"A \\<le> SPEC P\" and \"A \\<le> SPEC Q\"\n    shows \"A \\<le> SPEC (\\<lambda>v. P v \\<and> Q v)\"", "lemma SPEC_rule_conjunct1:\n  assumes \"A \\<le> SPEC (\\<lambda>v. P v \\<and> Q v)\"\n    shows \"A \\<le> SPEC P\"", "lemma SPEC_rule_conjunct2:\n  assumes \"A \\<le> SPEC (\\<lambda>v. P v \\<and> Q v)\"\n    shows \"A \\<le> SPEC Q\"", "lemma inres_if:\n  \"\\<lbrakk> inres (if P then Q else R) x; \\<lbrakk>P; inres Q x\\<rbrakk> \\<Longrightarrow> S; \\<lbrakk>\\<not> P; inres R x\\<rbrakk> \\<Longrightarrow> S \\<rbrakk> \\<Longrightarrow> S\"", "lemma inres_SPEC:\n  \"inres M x \\<Longrightarrow> M \\<le> SPEC \\<Phi> \\<Longrightarrow> \\<Phi> x\"", "lemma SPEC_nofail:\n  \"X \\<le> SPEC \\<Phi> \\<Longrightarrow> nofail X\"", "lemma nofail_SPEC: \"nofail m \\<Longrightarrow> m \\<le> SPEC (\\<lambda>_. True)\"", "lemma nofail_SPEC_iff: \"nofail m \\<longleftrightarrow> m \\<le> SPEC (\\<lambda>_. True)\"", "lemma nofail_SPEC_triv_refine: \"\\<lbrakk> nofail m; \\<And>x. \\<Phi> x \\<rbrakk> \\<Longrightarrow> m \\<le> SPEC \\<Phi>\""], "translations": [["", "lemma nres_cases[case_names FAIL RES, cases type]:\n  obtains \"M=FAIL\" | X where \"M=RES X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>M = FAIL \\<Longrightarrow> thesis;\n     \\<And>X. M = RES X \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "apply (cases M, fold top_nres_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>M = FAIL \\<Longrightarrow> thesis;\n     \\<And>X. M = RES X \\<Longrightarrow> thesis; M = FAIL\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<And>x2.\n       \\<lbrakk>M = FAIL \\<Longrightarrow> thesis;\n        \\<And>X. M = RES X \\<Longrightarrow> thesis; M = RES x2\\<rbrakk>\n       \\<Longrightarrow> thesis", "by auto"], ["", "lemma nres_simp_internals: \n  \"RES {} = SUCCEED\"\n  \"FAILi = FAIL\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RES {} = SUCCEED &&& FAILi = FAIL", "unfolding top_nres_def bot_nres_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. RES {} = RES {} &&& FAILi = FAILi", "by simp_all"], ["", "lemma nres_inequalities[simp]: \n  \"FAIL \\<noteq> RES X\"\n  \"FAIL \\<noteq> SUCCEED\" \n  \"FAIL \\<noteq> RETURN x\"\n  \"SUCCEED \\<noteq> FAIL\"\n  \"SUCCEED \\<noteq> RETURN x\"\n  \"RES X \\<noteq> FAIL\"\n  \"RETURN x \\<noteq> FAIL\"\n  \"RETURN x \\<noteq> SUCCEED\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((FAIL \\<noteq> RES X &&& FAIL \\<noteq> SUCCEED) &&&\n     FAIL \\<noteq> RETURN x &&& SUCCEED \\<noteq> FAIL) &&&\n    (SUCCEED \\<noteq> RETURN x &&& RES X \\<noteq> FAIL) &&&\n    RETURN x \\<noteq> FAIL &&& RETURN x \\<noteq> SUCCEED", "unfolding top_nres_def bot_nres_def RETURN_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((FAILi \\<noteq> RES X &&& FAILi \\<noteq> RES {}) &&&\n     FAILi \\<noteq> RES {x} &&& RES {} \\<noteq> FAILi) &&&\n    (RES {} \\<noteq> RES {x} &&& RES X \\<noteq> FAILi) &&&\n    RES {x} \\<noteq> FAILi &&& RES {x} \\<noteq> RES {}", "by auto"], ["", "lemma nres_more_simps[simp]:\n  \"SUCCEED = RES X \\<longleftrightarrow> X={}\"\n  \"RES X = SUCCEED \\<longleftrightarrow> X={}\"\n  \"RES X = RETURN x \\<longleftrightarrow> X={x}\"\n  \"RES X = RES Y \\<longleftrightarrow> X=Y\"\n  \"RETURN x = RES X \\<longleftrightarrow> {x}=X\"\n  \"RETURN x = RETURN y \\<longleftrightarrow> x=y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((SUCCEED = RES X) = (X = {}) &&&\n     (RES X = SUCCEED) = (X = {}) &&& (RES X = RETURN x) = (X = {x})) &&&\n    (RES X = RES Y) = (X = Y) &&&\n    (RETURN x = RES X) = ({x} = X) &&& (RETURN x = RETURN y) = (x = y)", "unfolding top_nres_def bot_nres_def RETURN_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((RES {} = RES X) = (X = {}) &&&\n     (RES X = RES {}) = (X = {}) &&& (RES X = RES {x}) = (X = {x})) &&&\n    (RES X = RES Y) = (X = Y) &&&\n    (RES {x} = RES X) = ({x} = X) &&& (RES {x} = RES {y}) = (x = y)", "by auto"], ["", "lemma nres_order_simps[simp]:\n  \"\\<And>M. SUCCEED \\<le> M\"\n  \"\\<And>M. M \\<le> SUCCEED \\<longleftrightarrow> M=SUCCEED\"\n  \"\\<And>M. M \\<le> FAIL\"\n  \"\\<And>M. FAIL \\<le> M \\<longleftrightarrow> M=FAIL\"\n  \"\\<And>X Y. RES X \\<le> RES Y \\<longleftrightarrow> X\\<le>Y\"\n  \"\\<And>X. Sup X = FAIL \\<longleftrightarrow> FAIL\\<in>X\"\n  \"\\<And>X f. Sup (f ` X) = FAIL \\<longleftrightarrow> FAIL \\<in> f ` X\"\n  \"\\<And>X. FAIL = Sup X \\<longleftrightarrow> FAIL\\<in>X\"\n  \"\\<And>X f. FAIL = Sup (f ` X) \\<longleftrightarrow> FAIL \\<in> f ` X\"\n  \"\\<And>X. FAIL\\<in>X \\<Longrightarrow> Sup X = FAIL\"\n  \"\\<And>X. FAIL\\<in>f ` X \\<Longrightarrow> Sup (f ` X) = FAIL\"\n  \"\\<And>A. Sup (RES ` A) = RES (Sup A)\"\n  \"\\<And>A. Sup (RES ` A) = RES (Sup A)\"\n  \"\\<And>A. A\\<noteq>{} \\<Longrightarrow> Inf (RES`A) = RES (Inf A)\"\n  \"\\<And>A. A\\<noteq>{} \\<Longrightarrow> Inf (RES ` A) = RES (Inf A)\"\n  \"Inf {} = FAIL\"\n  \"Inf UNIV = SUCCEED\"\n  \"Sup {} = SUCCEED\"\n  \"Sup UNIV = FAIL\"\n  \"\\<And>x y. RETURN x \\<le> RETURN y \\<longleftrightarrow> x=y\"\n  \"\\<And>x Y. RETURN x \\<le> RES Y \\<longleftrightarrow> x\\<in>Y\"\n  \"\\<And>X y. RES X \\<le> RETURN y \\<longleftrightarrow> X \\<subseteq> {y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((((\\<And>M. SUCCEED \\<le> M) &&&\n       (\\<And>M. (M \\<le> SUCCEED) = (M = SUCCEED))) &&&\n      (\\<And>M. M \\<le> FAIL) &&&\n      (\\<And>M. (FAIL \\<le> M) = (M = FAIL)) &&&\n      (\\<And>X Y. (RES X \\<le> RES Y) = (X \\<subseteq> Y))) &&&\n     ((\\<And>X. (Sup X = FAIL) = (FAIL \\<in> X)) &&&\n      (\\<And>X f. (Sup (f ` X) = FAIL) = (FAIL \\<in> f ` X)) &&&\n      (\\<And>X. (FAIL = Sup X) = (FAIL \\<in> X))) &&&\n     (\\<And>X f. (FAIL = Sup (f ` X)) = (FAIL \\<in> f ` X)) &&&\n     (\\<And>X. FAIL \\<in> X \\<Longrightarrow> Sup X = FAIL) &&&\n     (\\<And>X. FAIL \\<in> f ` X \\<Longrightarrow> Sup (f ` X) = FAIL)) &&&\n    (((\\<And>A. Sup (RES ` A) = RES (\\<Union> A)) &&&\n      (\\<And>A. Sup (RES ` A) = RES (\\<Union> A))) &&&\n     (\\<And>A.\n         A \\<noteq> {} \\<Longrightarrow>\n         Inf (RES ` A) = RES (\\<Inter> A)) &&&\n     (\\<And>A.\n         A \\<noteq> {} \\<Longrightarrow>\n         Inf (RES ` A) = RES (\\<Inter> A)) &&&\n     Inf {} = FAIL) &&&\n    (Inf UNIV = SUCCEED &&& Sup {} = SUCCEED &&& Sup UNIV = FAIL) &&&\n    (\\<And>x y. (RETURN x \\<le> RETURN y) = (x = y)) &&&\n    (\\<And>x Y. (RETURN x \\<le> RES Y) = (x \\<in> Y)) &&&\n    (\\<And>X y. (RES X \\<le> RETURN y) = (X \\<subseteq> {y}))", "unfolding Sup_nres_def Inf_nres_def RETURN_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((((\\<And>M. SUCCEED \\<le> M) &&&\n       (\\<And>M. (M \\<le> SUCCEED) = (M = SUCCEED))) &&&\n      (\\<And>M. M \\<le> FAIL) &&&\n      (\\<And>M. (FAIL \\<le> M) = (M = FAIL)) &&&\n      (\\<And>X Y. (RES X \\<le> RES Y) = (X \\<subseteq> Y))) &&&\n     ((\\<And>X.\n          ((if FAILi \\<in> X then FAILi\n            else RES (\\<Union> {x. RES x \\<in> X})) =\n           FAIL) =\n          (FAIL \\<in> X)) &&&\n      (\\<And>X f.\n          ((if FAILi \\<in> f ` X then FAILi\n            else RES (\\<Union> {x. RES x \\<in> f ` X})) =\n           FAIL) =\n          (FAIL \\<in> f ` X)) &&&\n      (\\<And>X.\n          (FAIL =\n           (if FAILi \\<in> X then FAILi\n            else RES (\\<Union> {x. RES x \\<in> X}))) =\n          (FAIL \\<in> X))) &&&\n     (\\<And>X f.\n         (FAIL =\n          (if FAILi \\<in> f ` X then FAILi\n           else RES (\\<Union> {x. RES x \\<in> f ` X}))) =\n         (FAIL \\<in> f ` X)) &&&\n     (\\<And>X.\n         FAIL \\<in> X \\<Longrightarrow>\n         (if FAILi \\<in> X then FAILi\n          else RES (\\<Union> {x. RES x \\<in> X})) =\n         FAIL) &&&\n     (\\<And>X.\n         FAIL \\<in> f ` X \\<Longrightarrow>\n         (if FAILi \\<in> f ` X then FAILi\n          else RES (\\<Union> {x. RES x \\<in> f ` X})) =\n         FAIL)) &&&\n    (((\\<And>A.\n          (if FAILi \\<in> RES ` A then FAILi\n           else RES (\\<Union> {x. RES x \\<in> RES ` A})) =\n          RES (\\<Union> A)) &&&\n      (\\<And>A.\n          (if FAILi \\<in> RES ` A then FAILi\n           else RES (\\<Union> {x. RES x \\<in> RES ` A})) =\n          RES (\\<Union> A))) &&&\n     (\\<And>A.\n         A \\<noteq> {} \\<Longrightarrow>\n         (if \\<exists>x. RES x \\<in> RES ` A\n          then RES (\\<Inter> {x. RES x \\<in> RES ` A}) else FAILi) =\n         RES (\\<Inter> A)) &&&\n     (\\<And>A.\n         A \\<noteq> {} \\<Longrightarrow>\n         (if \\<exists>x. RES x \\<in> RES ` A\n          then RES (\\<Inter> {x. RES x \\<in> RES ` A}) else FAILi) =\n         RES (\\<Inter> A)) &&&\n     (if \\<exists>x. RES x \\<in> {} then RES (\\<Inter> {x. RES x \\<in> {}})\n      else FAILi) =\n     FAIL) &&&\n    ((if \\<exists>x. RES x \\<in> UNIV\n      then RES (\\<Inter> {x. RES x \\<in> UNIV}) else FAILi) =\n     SUCCEED &&&\n     (if FAILi \\<in> {} then FAILi\n      else RES (\\<Union> {x. RES x \\<in> {}})) =\n     SUCCEED &&&\n     (if FAILi \\<in> UNIV then FAILi\n      else RES (\\<Union> {x. RES x \\<in> UNIV})) =\n     FAIL) &&&\n    (\\<And>x y. (RES {x} \\<le> RES {y}) = (x = y)) &&&\n    (\\<And>x Y. (RES {x} \\<le> RES Y) = (x \\<in> Y)) &&&\n    (\\<And>X y. (RES X \\<le> RES {y}) = (X \\<subseteq> {y}))", "by (auto simp add: bot_unique top_unique nres_simp_internals)"], ["", "lemma Sup_eq_RESE:\n  assumes \"Sup A = RES B\"\n  obtains C where \"A=RES`C\" and \"B=Sup C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>C.\n        \\<lbrakk>A = RES ` C; B = \\<Union> C\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>C.\n        \\<lbrakk>A = RES ` C; B = \\<Union> C\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "using assms"], ["proof (prove)\nusing this:\n  Sup A = RES B\n\ngoal (1 subgoal):\n 1. thesis", "unfolding Sup_nres_def"], ["proof (prove)\nusing this:\n  (if FAILi \\<in> A then FAILi else RES (\\<Union> {x. RES x \\<in> A})) =\n  RES B\n\ngoal (1 subgoal):\n 1. thesis", "apply (simp split: if_split_asm)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>FAILi \\<notin> A; \\<Union> {x. RES x \\<in> A} = B\\<rbrakk>\n    \\<Longrightarrow> thesis", "apply (rule_tac C=\"{X. RES X \\<in> A}\" in that)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>FAILi \\<notin> A; \\<Union> {x. RES x \\<in> A} = B\\<rbrakk>\n    \\<Longrightarrow> A = RES ` {X. RES X \\<in> A}\n 2. \\<lbrakk>FAILi \\<notin> A; \\<Union> {x. RES x \\<in> A} = B\\<rbrakk>\n    \\<Longrightarrow> B = \\<Union> {X. RES X \\<in> A}", "apply auto []"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>FAILi \\<notin> A; B = \\<Union> {x. RES x \\<in> A};\n        x \\<in> A\\<rbrakk>\n       \\<Longrightarrow> x \\<in> RES ` {X. RES X \\<in> A}\n 2. \\<lbrakk>FAILi \\<notin> A; \\<Union> {x. RES x \\<in> A} = B\\<rbrakk>\n    \\<Longrightarrow> B = \\<Union> {X. RES X \\<in> A}", "apply (case_tac x, auto simp: nres_simp_internals) []"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>FAILi \\<notin> A; \\<Union> {x. RES x \\<in> A} = B\\<rbrakk>\n    \\<Longrightarrow> B = \\<Union> {X. RES X \\<in> A}", "apply (auto simp: nres_simp_internals) []"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "declare nres_simp_internals[simp]"], ["", "subsubsection \\<open>Pointwise Reasoning\\<close>"], ["", "ML \\<open>\n  structure refine_pw_simps = Named_Thms\n    ( val name = @{binding refine_pw_simps}\n      val description = \"Refinement Framework: \" ^\n        \"Simplifier rules for pointwise reasoning\" )\n\\<close>"], ["", "setup \\<open>refine_pw_simps.setup\\<close>"], ["", "definition \"nofail S \\<equiv> S\\<noteq>FAIL\""], ["", "definition \"inres S x \\<equiv> RETURN x \\<le> S\""], ["", "lemma nofail_simps[simp, refine_pw_simps]:\n  \"nofail FAIL \\<longleftrightarrow> False\"\n  \"nofail (RES X) \\<longleftrightarrow> True\"\n  \"nofail (RETURN x) \\<longleftrightarrow> True\"\n  \"nofail SUCCEED \\<longleftrightarrow> True\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (nofail FAIL = False &&& nofail (RES X) = True) &&&\n    nofail (RETURN x) = True &&& nofail SUCCEED = True", "unfolding nofail_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((FAIL \\<noteq> FAIL) = False &&& (RES X \\<noteq> FAIL) = True) &&&\n    (RETURN x \\<noteq> FAIL) = True &&& (SUCCEED \\<noteq> FAIL) = True", "by (simp_all add: RETURN_def)"], ["", "lemma inres_simps[simp, refine_pw_simps]:\n  \"inres FAIL = (\\<lambda>_. True)\"\n  \"inres (RES X) = (\\<lambda>x. x\\<in>X)\"\n  \"inres (RETURN x) = (\\<lambda>y. x=y)\"\n  \"inres SUCCEED = (\\<lambda>_. False)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (inres FAIL = (\\<lambda>_. True) &&&\n     inres (RES X) = (\\<lambda>x. x \\<in> X)) &&&\n    inres (RETURN x) = (=) x &&& inres SUCCEED = (\\<lambda>_. False)", "unfolding inres_def [abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x. RETURN x \\<le> FAIL) = (\\<lambda>_. True) &&&\n     (\\<lambda>x. RETURN x \\<le> RES X) = (\\<lambda>x. x \\<in> X)) &&&\n    (\\<lambda>xa. RETURN xa \\<le> RETURN x) = (=) x &&&\n    (\\<lambda>x. RETURN x \\<le> SUCCEED) = (\\<lambda>_. False)", "by (auto simp add: RETURN_def)"], ["", "lemma not_nofail_iff: \n  \"\\<not>nofail S \\<longleftrightarrow> S=FAIL\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<not> nofail S) = (S = FAIL)", "by (cases S) auto"], ["", "lemma not_nofail_inres[simp, refine_pw_simps]: \n  \"\\<not>nofail S \\<Longrightarrow> inres S x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> nofail S \\<Longrightarrow> inres S x", "apply (cases S)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> nofail S; S = FAIL\\<rbrakk> \\<Longrightarrow> inres S x\n 2. \\<And>X.\n       \\<lbrakk>\\<not> nofail S; S = RES X\\<rbrakk>\n       \\<Longrightarrow> inres S x", "by auto"], ["", "lemma intro_nofail[refine_pw_simps]: \n  \"S\\<noteq>FAIL \\<longleftrightarrow> nofail S\"\n  \"FAIL\\<noteq>S \\<longleftrightarrow> nofail S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (S \\<noteq> FAIL) = nofail S &&& (FAIL \\<noteq> S) = nofail S", "by (cases S, simp_all)+"], ["", "text \\<open>The following two lemmas will introduce pointwise reasoning for\n  orderings and equalities.\\<close>"], ["", "lemma pw_le_iff: \n  \"S \\<le> S' \\<longleftrightarrow> (nofail S'\\<longrightarrow> (nofail S \\<and> (\\<forall>x. inres S x \\<longrightarrow> inres S' x)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (S \\<le> S') =\n    (nofail S' \\<longrightarrow>\n     nofail S \\<and> (\\<forall>x. inres S x \\<longrightarrow> inres S' x))", "apply (cases S, simp_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. S = FAIL \\<Longrightarrow> (S' = FAIL) = (\\<not> nofail S')\n 2. \\<And>X.\n       S = RES X \\<Longrightarrow>\n       (RES X \\<le> S') =\n       (nofail S' \\<longrightarrow>\n        (\\<forall>x. x \\<in> X \\<longrightarrow> inres S' x))", "apply (case_tac [!] S', auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma pw_eq_iff:\n  \"S=S' \\<longleftrightarrow> (nofail S = nofail S' \\<and> (\\<forall>x. inres S x \\<longleftrightarrow> inres S' x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (S = S') =\n    (nofail S = nofail S' \\<and> (\\<forall>x. inres S x = inres S' x))", "apply (rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. S = S' \\<Longrightarrow>\n    nofail S = nofail S' \\<and> (\\<forall>x. inres S x = inres S' x)\n 2. nofail S = nofail S' \\<and>\n    (\\<forall>x. inres S x = inres S' x) \\<Longrightarrow>\n    S = S'", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. nofail S = nofail S' \\<and>\n    (\\<forall>x. inres S x = inres S' x) \\<Longrightarrow>\n    S = S'", "apply (rule antisym)"], ["proof (prove)\ngoal (2 subgoals):\n 1. nofail S = nofail S' \\<and>\n    (\\<forall>x. inres S x = inres S' x) \\<Longrightarrow>\n    S \\<le> S'\n 2. nofail S = nofail S' \\<and>\n    (\\<forall>x. inres S x = inres S' x) \\<Longrightarrow>\n    S' \\<le> S", "apply (simp_all add: pw_le_iff)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma pw_flat_le_iff: \"flat_le S S' \\<longleftrightarrow> \n  (\\<exists>x. inres S x) \\<longrightarrow> (nofail S \\<longleftrightarrow> nofail S') \\<and> (\\<forall>x. inres S x \\<longleftrightarrow> inres S' x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. flat_le S S' =\n    ((\\<exists>x. inres S x) \\<longrightarrow>\n     nofail S = nofail S' \\<and> (\\<forall>x. inres S x = inres S' x))", "by (auto simp : flat_ord_def pw_eq_iff)"], ["", "lemma pw_flat_ge_iff: \"flat_ge S S' \\<longleftrightarrow> \n  (nofail S) \\<longrightarrow> nofail S' \\<and> (\\<forall>x. inres S x \\<longleftrightarrow> inres S' x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. flat_ge S S' =\n    (nofail S \\<longrightarrow>\n     nofail S' \\<and> (\\<forall>x. inres S x = inres S' x))", "apply (simp add: flat_ord_def pw_eq_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<not> nofail S \\<and> (\\<forall>x. inres S x) \\<or>\n     nofail S = nofail S' \\<and> (\\<forall>x. inres S x = inres S' x)) =\n    (nofail S \\<longrightarrow>\n     nofail S' \\<and> (\\<forall>x. inres S x = inres S' x))", "apply safe"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<not> nofail S; \\<not> inres S x; nofail S'\\<rbrakk>\n       \\<Longrightarrow> nofail S\n 2. \\<And>x xa.\n       \\<lbrakk>\\<not> nofail S; \\<not> inres S xa; inres S x\\<rbrakk>\n       \\<Longrightarrow> inres S' x\n 3. \\<And>x xa.\n       \\<lbrakk>\\<not> nofail S; \\<not> inres S xa; inres S' x\\<rbrakk>\n       \\<Longrightarrow> inres S x\n 4. \\<And>x.\n       \\<lbrakk>nofail S'; \\<forall>x. inres S x = inres S' x;\n        \\<not> inres S x; nofail S'\\<rbrakk>\n       \\<Longrightarrow> nofail S", "apply simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x xa.\n       \\<lbrakk>\\<not> nofail S; \\<not> inres S xa; inres S x\\<rbrakk>\n       \\<Longrightarrow> inres S' x\n 2. \\<And>x xa.\n       \\<lbrakk>\\<not> nofail S; \\<not> inres S xa; inres S' x\\<rbrakk>\n       \\<Longrightarrow> inres S x\n 3. \\<And>x.\n       \\<lbrakk>nofail S'; \\<forall>x. inres S x = inres S' x;\n        \\<not> inres S x; nofail S'\\<rbrakk>\n       \\<Longrightarrow> nofail S", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       \\<lbrakk>\\<not> nofail S; \\<not> inres S xa; inres S' x\\<rbrakk>\n       \\<Longrightarrow> inres S x\n 2. \\<And>x.\n       \\<lbrakk>nofail S'; \\<forall>x. inres S x = inres S' x;\n        \\<not> inres S x; nofail S'\\<rbrakk>\n       \\<Longrightarrow> nofail S", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>nofail S'; \\<forall>x. inres S x = inres S' x;\n        \\<not> inres S x; nofail S'\\<rbrakk>\n       \\<Longrightarrow> nofail S", "apply (rule ccontr)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>nofail S'; \\<forall>x. inres S x = inres S' x;\n        \\<not> inres S x; nofail S'; \\<not> nofail S\\<rbrakk>\n       \\<Longrightarrow> False", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemmas pw_ords_iff = pw_le_iff pw_flat_le_iff pw_flat_ge_iff"], ["", "lemma pw_leI: \n  \"(nofail S'\\<longrightarrow> (nofail S \\<and> (\\<forall>x. inres S x \\<longrightarrow> inres S' x))) \\<Longrightarrow> S \\<le> S'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nofail S' \\<longrightarrow>\n    nofail S \\<and>\n    (\\<forall>x. inres S x \\<longrightarrow> inres S' x) \\<Longrightarrow>\n    S \\<le> S'", "by (simp add: pw_le_iff)"], ["", "lemma pw_leI': \n  assumes \"nofail S' \\<Longrightarrow> nofail S\"\n  assumes \"\\<And>x. \\<lbrakk>nofail S'; inres S x\\<rbrakk> \\<Longrightarrow> inres S' x\"\n  shows \"S \\<le> S'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S \\<le> S'", "using assms"], ["proof (prove)\nusing this:\n  nofail S' \\<Longrightarrow> nofail S\n  \\<lbrakk>nofail S'; inres S ?x\\<rbrakk> \\<Longrightarrow> inres S' ?x\n\ngoal (1 subgoal):\n 1. S \\<le> S'", "by (simp add: pw_le_iff)"], ["", "lemma pw_eqI: \n  assumes \"nofail S = nofail S'\" \n  assumes \"\\<And>x. inres S x \\<longleftrightarrow> inres S' x\" \n  shows \"S=S'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S = S'", "using assms"], ["proof (prove)\nusing this:\n  nofail S = nofail S'\n  inres S ?x = inres S' ?x\n\ngoal (1 subgoal):\n 1. S = S'", "by (simp add: pw_eq_iff)"], ["", "lemma pwD1:\n  assumes \"S\\<le>S'\" \"nofail S'\" \n  shows \"nofail S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nofail S", "using assms"], ["proof (prove)\nusing this:\n  S \\<le> S'\n  nofail S'\n\ngoal (1 subgoal):\n 1. nofail S", "by (simp add: pw_le_iff)"], ["", "lemma pwD2:\n  assumes \"S\\<le>S'\" \"inres S x\"\n  shows \"inres S' x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inres S' x", "using assms"], ["proof (prove)\nusing this:\n  S \\<le> S'\n  inres S x\n\ngoal (1 subgoal):\n 1. inres S' x", "by (auto simp add: pw_le_iff)"], ["", "lemmas pwD = pwD1 pwD2"], ["", "text \\<open>\n  When proving refinement, we may assume that the refined program does not \n  fail.\\<close>"], ["", "lemma le_nofailI: \"\\<lbrakk> nofail M' \\<Longrightarrow> M \\<le> M' \\<rbrakk> \\<Longrightarrow> M \\<le> M'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (nofail M' \\<Longrightarrow> M \\<le> M') \\<Longrightarrow> M \\<le> M'", "by (cases M') auto"], ["", "text \\<open>The following lemmas push pointwise reasoning over operators,\n  thus converting an expression over lattice operators into a logical\n  formula.\\<close>"], ["", "lemma pw_sup_nofail[refine_pw_simps]:\n  \"nofail (sup a b) \\<longleftrightarrow> nofail a \\<and> nofail b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nofail (sup a b) = (nofail a \\<and> nofail b)", "apply (cases a, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>X.\n       a = RES X \\<Longrightarrow>\n       nofail (sup a b) = (nofail a \\<and> nofail b)", "apply (cases b, simp_all)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma pw_sup_inres[refine_pw_simps]:\n  \"inres (sup a b) x \\<longleftrightarrow> inres a x \\<or> inres b x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inres (sup a b) x = (inres a x \\<or> inres b x)", "apply (cases a, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>X.\n       a = RES X \\<Longrightarrow>\n       inres (sup a b) x = (inres a x \\<or> inres b x)", "apply (cases b, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>X Xa.\n       \\<lbrakk>a = RES X; b = RES Xa\\<rbrakk>\n       \\<Longrightarrow> inres (sup a b) x = (inres a x \\<or> inres b x)", "apply (simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma pw_Sup_inres[refine_pw_simps]: \"inres (Sup X) r \\<longleftrightarrow> (\\<exists>M\\<in>X. inres M r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inres (Sup X) r = (\\<exists>M\\<in>X. inres M r)", "apply (cases \"Sup X\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. Sup X = FAIL \\<Longrightarrow>\n    inres (Sup X) r = (\\<exists>M\\<in>X. inres M r)\n 2. \\<And>Xa.\n       Sup X = RES Xa \\<Longrightarrow>\n       inres (Sup X) r = (\\<exists>M\\<in>X. inres M r)", "apply (simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. FAIL \\<in> X \\<Longrightarrow> \\<exists>M\\<in>X. inres M r\n 2. \\<And>Xa.\n       Sup X = RES Xa \\<Longrightarrow>\n       inres (Sup X) r = (\\<exists>M\\<in>X. inres M r)", "apply (erule bexI[rotated])"], ["proof (prove)\ngoal (2 subgoals):\n 1. inres FAIL r\n 2. \\<And>Xa.\n       Sup X = RES Xa \\<Longrightarrow>\n       inres (Sup X) r = (\\<exists>M\\<in>X. inres M r)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Xa.\n       Sup X = RES Xa \\<Longrightarrow>\n       inres (Sup X) r = (\\<exists>M\\<in>X. inres M r)", "apply (erule Sup_eq_RESE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Xa C.\n       \\<lbrakk>X = RES ` C; Xa = \\<Union> C\\<rbrakk>\n       \\<Longrightarrow> inres (Sup X) r = (\\<exists>M\\<in>X. inres M r)", "apply (simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma pw_SUP_inres [refine_pw_simps]: \"inres (Sup (f ` X)) r \\<longleftrightarrow> (\\<exists>M\\<in>X. inres (f M) r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inres (Sup (f ` X)) r = (\\<exists>M\\<in>X. inres (f M) r)", "using pw_Sup_inres [of \"f ` X\"]"], ["proof (prove)\nusing this:\n  inres (Sup (f ` X)) ?r = (\\<exists>M\\<in>f ` X. inres M ?r)\n\ngoal (1 subgoal):\n 1. inres (Sup (f ` X)) r = (\\<exists>M\\<in>X. inres (f M) r)", "by simp"], ["", "lemma pw_Sup_nofail[refine_pw_simps]: \"nofail (Sup X) \\<longleftrightarrow> (\\<forall>x\\<in>X. nofail x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nofail (Sup X) = (\\<forall>x\\<in>X. nofail x)", "apply (cases \"Sup X\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. Sup X = FAIL \\<Longrightarrow>\n    nofail (Sup X) = (\\<forall>x\\<in>X. nofail x)\n 2. \\<And>Xa.\n       Sup X = RES Xa \\<Longrightarrow>\n       nofail (Sup X) = (\\<forall>x\\<in>X. nofail x)", "apply force"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Xa.\n       Sup X = RES Xa \\<Longrightarrow>\n       nofail (Sup X) = (\\<forall>x\\<in>X. nofail x)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Xa. Sup X = RES Xa \\<Longrightarrow> Ball X nofail", "apply (erule Sup_eq_RESE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Xa C.\n       \\<lbrakk>X = RES ` C; Xa = \\<Union> C\\<rbrakk>\n       \\<Longrightarrow> Ball X nofail", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma pw_SUP_nofail [refine_pw_simps]: \"nofail (Sup (f ` X)) \\<longleftrightarrow> (\\<forall>x\\<in>X. nofail (f x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nofail (Sup (f ` X)) = (\\<forall>x\\<in>X. nofail (f x))", "using pw_Sup_nofail [of \"f ` X\"]"], ["proof (prove)\nusing this:\n  nofail (Sup (f ` X)) = (\\<forall>x\\<in>f ` X. nofail x)\n\ngoal (1 subgoal):\n 1. nofail (Sup (f ` X)) = (\\<forall>x\\<in>X. nofail (f x))", "by simp"], ["", "lemma pw_inf_nofail[refine_pw_simps]:\n  \"nofail (inf a b) \\<longleftrightarrow> nofail a \\<or> nofail b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nofail (inf a b) = (nofail a \\<or> nofail b)", "apply (cases a, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>X.\n       a = RES X \\<Longrightarrow>\n       nofail (inf a b) = (nofail a \\<or> nofail b)", "apply (cases b, simp_all)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma pw_inf_inres[refine_pw_simps]:\n  \"inres (inf a b) x \\<longleftrightarrow> inres a x \\<and> inres b x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inres (inf a b) x = (inres a x \\<and> inres b x)", "apply (cases a, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>X.\n       a = RES X \\<Longrightarrow>\n       inres (inf a b) x = (inres a x \\<and> inres b x)", "apply (cases b, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>X Xa.\n       \\<lbrakk>a = RES X; b = RES Xa\\<rbrakk>\n       \\<Longrightarrow> inres (inf a b) x = (inres a x \\<and> inres b x)", "apply (simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma pw_Inf_nofail[refine_pw_simps]: \"nofail (Inf C) \\<longleftrightarrow> (\\<exists>x\\<in>C. nofail x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nofail (Inf C) = (\\<exists>x\\<in>C. nofail x)", "apply (cases \"C={}\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. C = {} \\<Longrightarrow> nofail (Inf C) = (\\<exists>x\\<in>C. nofail x)\n 2. C \\<noteq> {} \\<Longrightarrow>\n    nofail (Inf C) = (\\<exists>x\\<in>C. nofail x)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. C \\<noteq> {} \\<Longrightarrow>\n    nofail (Inf C) = (\\<exists>x\\<in>C. nofail x)", "apply (cases \"Inf C\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>C \\<noteq> {}; Inf C = FAIL\\<rbrakk>\n    \\<Longrightarrow> nofail (Inf C) = (\\<exists>x\\<in>C. nofail x)\n 2. \\<And>X.\n       \\<lbrakk>C \\<noteq> {}; Inf C = RES X\\<rbrakk>\n       \\<Longrightarrow> nofail (Inf C) = (\\<exists>x\\<in>C. nofail x)", "apply (subgoal_tac \"C={FAIL}\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>C \\<noteq> {}; Inf C = FAIL; C = {FAIL}\\<rbrakk>\n    \\<Longrightarrow> nofail (Inf C) = (\\<exists>x\\<in>C. nofail x)\n 2. \\<lbrakk>C \\<noteq> {}; Inf C = FAIL\\<rbrakk>\n    \\<Longrightarrow> C = {FAIL}\n 3. \\<And>X.\n       \\<lbrakk>C \\<noteq> {}; Inf C = RES X\\<rbrakk>\n       \\<Longrightarrow> nofail (Inf C) = (\\<exists>x\\<in>C. nofail x)", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>C \\<noteq> {}; Inf C = FAIL\\<rbrakk>\n    \\<Longrightarrow> C = {FAIL}\n 2. \\<And>X.\n       \\<lbrakk>C \\<noteq> {}; Inf C = RES X\\<rbrakk>\n       \\<Longrightarrow> nofail (Inf C) = (\\<exists>x\\<in>C. nofail x)", "apply auto []"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>X.\n       \\<lbrakk>C \\<noteq> {}; Inf C = RES X\\<rbrakk>\n       \\<Longrightarrow> nofail (Inf C) = (\\<exists>x\\<in>C. nofail x)", "apply (subgoal_tac \"C\\<noteq>{FAIL}\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>X.\n       \\<lbrakk>C \\<noteq> {}; Inf C = RES X; C \\<noteq> {FAIL}\\<rbrakk>\n       \\<Longrightarrow> nofail (Inf C) = (\\<exists>x\\<in>C. nofail x)\n 2. \\<And>X.\n       \\<lbrakk>C \\<noteq> {}; Inf C = RES X\\<rbrakk>\n       \\<Longrightarrow> C \\<noteq> {FAIL}", "apply (auto simp: not_nofail_iff) []"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>X.\n       \\<lbrakk>C \\<noteq> {}; Inf C = RES X\\<rbrakk>\n       \\<Longrightarrow> C \\<noteq> {FAIL}", "apply auto []"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma pw_INF_nofail [refine_pw_simps]: \"nofail (Inf (f ` C)) \\<longleftrightarrow> (\\<exists>x\\<in>C. nofail (f x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nofail (Inf (f ` C)) = (\\<exists>x\\<in>C. nofail (f x))", "using pw_Inf_nofail [of \"f ` C\"]"], ["proof (prove)\nusing this:\n  nofail (Inf (f ` C)) = (\\<exists>x\\<in>f ` C. nofail x)\n\ngoal (1 subgoal):\n 1. nofail (Inf (f ` C)) = (\\<exists>x\\<in>C. nofail (f x))", "by simp"], ["", "lemma pw_Inf_inres[refine_pw_simps]: \"inres (Inf C) r \\<longleftrightarrow> (\\<forall>M\\<in>C. inres M r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inres (Inf C) r = (\\<forall>M\\<in>C. inres M r)", "apply (unfold Inf_nres_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. inres\n     (if \\<exists>x. RES x \\<in> C then RES (\\<Inter> {x. RES x \\<in> C})\n      else FAILi)\n     r =\n    (\\<forall>M\\<in>C. inres M r)", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x M.\n       \\<lbrakk>RES x \\<in> C;\n        \\<forall>x. RES x \\<in> C \\<longrightarrow> r \\<in> x;\n        M \\<in> C\\<rbrakk>\n       \\<Longrightarrow> inres M r\n 2. \\<And>M.\n       \\<lbrakk>\\<forall>x. RES x \\<notin> C; M \\<in> C\\<rbrakk>\n       \\<Longrightarrow> inres M r", "apply (case_tac M)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x M.\n       \\<lbrakk>RES x \\<in> C;\n        \\<forall>x. RES x \\<in> C \\<longrightarrow> r \\<in> x; M \\<in> C;\n        M = FAIL\\<rbrakk>\n       \\<Longrightarrow> inres M r\n 2. \\<And>x M X.\n       \\<lbrakk>RES x \\<in> C;\n        \\<forall>x. RES x \\<in> C \\<longrightarrow> r \\<in> x; M \\<in> C;\n        M = RES X\\<rbrakk>\n       \\<Longrightarrow> inres M r\n 3. \\<And>M.\n       \\<lbrakk>\\<forall>x. RES x \\<notin> C; M \\<in> C\\<rbrakk>\n       \\<Longrightarrow> inres M r", "apply force"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x M X.\n       \\<lbrakk>RES x \\<in> C;\n        \\<forall>x. RES x \\<in> C \\<longrightarrow> r \\<in> x; M \\<in> C;\n        M = RES X\\<rbrakk>\n       \\<Longrightarrow> inres M r\n 2. \\<And>M.\n       \\<lbrakk>\\<forall>x. RES x \\<notin> C; M \\<in> C\\<rbrakk>\n       \\<Longrightarrow> inres M r", "apply force"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>M.\n       \\<lbrakk>\\<forall>x. RES x \\<notin> C; M \\<in> C\\<rbrakk>\n       \\<Longrightarrow> inres M r", "apply (case_tac M)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>M.\n       \\<lbrakk>\\<forall>x. RES x \\<notin> C; M \\<in> C; M = FAIL\\<rbrakk>\n       \\<Longrightarrow> inres M r\n 2. \\<And>M X.\n       \\<lbrakk>\\<forall>x. RES x \\<notin> C; M \\<in> C; M = RES X\\<rbrakk>\n       \\<Longrightarrow> inres M r", "apply force"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>M X.\n       \\<lbrakk>\\<forall>x. RES x \\<notin> C; M \\<in> C; M = RES X\\<rbrakk>\n       \\<Longrightarrow> inres M r", "apply force"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma pw_INF_inres [refine_pw_simps]: \"inres (Inf (f ` C)) r \\<longleftrightarrow> (\\<forall>M\\<in>C. inres (f M) r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inres (Inf (f ` C)) r = (\\<forall>M\\<in>C. inres (f M) r)", "using pw_Inf_inres [of \"f ` C\"]"], ["proof (prove)\nusing this:\n  inres (Inf (f ` C)) ?r = (\\<forall>M\\<in>f ` C. inres M ?r)\n\ngoal (1 subgoal):\n 1. inres (Inf (f ` C)) r = (\\<forall>M\\<in>C. inres (f M) r)", "by simp"], ["", "lemma nofail_RES_conv: \"nofail m \\<longleftrightarrow> (\\<exists>M. m=RES M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nofail m = (\\<exists>M. m = RES M)", "by (cases m) auto"], ["", "primrec the_RES where \"the_RES (RES X) = X\""], ["", "lemma the_RES_inv[simp]: \"nofail m \\<Longrightarrow> RES (the_RES m) = m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nofail m \\<Longrightarrow> RES (the_RES m) = m", "by (cases m) auto"], ["", "definition [refine_pw_simps]: \"nf_inres m x \\<equiv> nofail m \\<and> inres m x\""], ["", "lemma nf_inres_RES[simp]: \"nf_inres (RES X) x \\<longleftrightarrow> x\\<in>X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nf_inres (RES X) x = (x \\<in> X)", "by (simp add: refine_pw_simps)"], ["", "lemma nf_inres_SPEC[simp]: \"nf_inres (SPEC \\<Phi>) x \\<longleftrightarrow> \\<Phi> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nf_inres (SPEC \\<Phi>) x = \\<Phi> x", "by (simp add: refine_pw_simps)"], ["", "lemma nofail_antimono_fun: \"f \\<le> g \\<Longrightarrow> (nofail (g x) \\<longrightarrow> nofail (f x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<le> g \\<Longrightarrow> nofail (g x) \\<longrightarrow> nofail (f x)", "by (auto simp: pw_le_iff dest: le_funD)"], ["", "subsubsection \\<open>Monad Operators\\<close>"], ["", "definition bind where \"bind M f \\<equiv> case M of \n  FAILi \\<Rightarrow> FAIL |\n  RES X \\<Rightarrow> Sup (f`X)\""], ["", "lemma bind_FAIL[simp]: \"bind FAIL f = FAIL\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Refine_Basic.bind FAIL f = FAIL", "unfolding bind_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case FAIL of FAILi \\<Rightarrow> FAIL\n     | RES X \\<Rightarrow> Sup (f ` X)) =\n    FAIL", "by (auto split: nres.split)"], ["", "lemma bind_SUCCEED[simp]: \"bind SUCCEED f = SUCCEED\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Refine_Basic.bind SUCCEED f = SUCCEED", "unfolding bind_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case SUCCEED of FAILi \\<Rightarrow> FAIL\n     | RES X \\<Rightarrow> Sup (f ` X)) =\n    SUCCEED", "by (auto split: nres.split)"], ["", "lemma bind_RES: \"bind (RES X) f = Sup (f`X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Refine_Basic.bind (RES X) f = Sup (f ` X)", "unfolding bind_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case RES X of FAILi \\<Rightarrow> FAIL\n     | RES X \\<Rightarrow> Sup (f ` X)) =\n    Sup (f ` X)", "by (auto)"], ["", "adhoc_overloading\n  Monad_Syntax.bind Refine_Basic.bind"], ["", "lemma pw_bind_nofail[refine_pw_simps]:\n  \"nofail (bind M f) \\<longleftrightarrow> (nofail M \\<and> (\\<forall>x. inres M x \\<longrightarrow> nofail (f x)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nofail (M \\<bind> f) =\n    (nofail M \\<and> (\\<forall>x. inres M x \\<longrightarrow> nofail (f x)))", "apply (cases M)"], ["proof (prove)\ngoal (2 subgoals):\n 1. M = FAIL \\<Longrightarrow>\n    nofail (M \\<bind> f) =\n    (nofail M \\<and> (\\<forall>x. inres M x \\<longrightarrow> nofail (f x)))\n 2. \\<And>X.\n       M = RES X \\<Longrightarrow>\n       nofail (M \\<bind> f) =\n       (nofail M \\<and>\n        (\\<forall>x. inres M x \\<longrightarrow> nofail (f x)))", "by (auto simp: bind_RES refine_pw_simps)"], ["", "lemma pw_bind_inres[refine_pw_simps]:\n  \"inres (bind M f) = (\\<lambda>x. nofail M \\<longrightarrow> (\\<exists>y. (inres M y \\<and> inres (f y) x)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inres (M \\<bind> f) =\n    (\\<lambda>x.\n        nofail M \\<longrightarrow>\n        (\\<exists>y. inres M y \\<and> inres (f y) x))", "apply (rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       inres (M \\<bind> f) x =\n       (nofail M \\<longrightarrow>\n        (\\<exists>y. inres M y \\<and> inres (f y) x))", "apply (cases M)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       M = FAIL \\<Longrightarrow>\n       inres (M \\<bind> f) x =\n       (nofail M \\<longrightarrow>\n        (\\<exists>y. inres M y \\<and> inres (f y) x))\n 2. \\<And>x X.\n       M = RES X \\<Longrightarrow>\n       inres (M \\<bind> f) x =\n       (nofail M \\<longrightarrow>\n        (\\<exists>y. inres M y \\<and> inres (f y) x))", "apply (auto simp add: bind_RES refine_pw_simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma pw_bind_le_iff:\n  \"bind M f \\<le> S \\<longleftrightarrow> (nofail S \\<longrightarrow> nofail M) \\<and> \n    (\\<forall>x. nofail M \\<and> inres M x \\<longrightarrow> f x \\<le> S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (M \\<bind> f \\<le> S) =\n    ((nofail S \\<longrightarrow> nofail M) \\<and>\n     (\\<forall>x. nofail M \\<and> inres M x \\<longrightarrow> f x \\<le> S))", "by (auto simp: pw_le_iff refine_pw_simps)"], ["", "lemma pw_bind_leI: \"\\<lbrakk> \n  nofail S \\<Longrightarrow> nofail M; \\<And>x. \\<lbrakk>nofail M; inres M x\\<rbrakk> \\<Longrightarrow> f x \\<le> S\\<rbrakk> \n  \\<Longrightarrow> bind M f \\<le> S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>nofail S \\<Longrightarrow> nofail M;\n     \\<And>x.\n        \\<lbrakk>nofail M; inres M x\\<rbrakk>\n        \\<Longrightarrow> f x \\<le> S\\<rbrakk>\n    \\<Longrightarrow> M \\<bind> f \\<le> S", "by (simp add: pw_bind_le_iff)"], ["", "text \\<open>\\paragraph{Monad Laws}\\<close>"], ["", "lemma nres_monad1[simp]: \"bind (RETURN x) f = f x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RETURN x \\<bind> f = f x", "by (rule pw_eqI) (auto simp: refine_pw_simps)"], ["", "lemma nres_monad2[simp]: \"bind M RETURN = M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M \\<bind> RETURN = M", "by (rule pw_eqI) (auto simp: refine_pw_simps)"], ["", "lemma nres_monad3[simp]: \"bind (bind M f) g = bind M (\\<lambda>x. bind (f x) g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M \\<bind> f \\<bind> g = M \\<bind> (\\<lambda>x. f x \\<bind> g)", "by (rule pw_eqI) (auto simp: refine_pw_simps)"], ["", "lemmas nres_monad_laws = nres_monad1 nres_monad2 nres_monad3"], ["", "text \\<open>\\paragraph{Congruence rule for bind}\\<close>"], ["", "lemma bind_cong:\n  assumes \"m=m'\"\n  assumes \"\\<And>x. RETURN x \\<le> m' \\<Longrightarrow> f x = f' x\"\n  shows \"bind m f = bind m' f'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<bind> f = m' \\<bind> f'", "using assms"], ["proof (prove)\nusing this:\n  m = m'\n  RETURN ?x \\<le> m' \\<Longrightarrow> f ?x = f' ?x\n\ngoal (1 subgoal):\n 1. m \\<bind> f = m' \\<bind> f'", "by (auto simp: refine_pw_simps pw_eq_iff pw_le_iff)"], ["", "text \\<open>\\paragraph{Monotonicity and Related Properties}\\<close>"], ["", "lemma bind_mono[refine_mono]:\n  \"\\<lbrakk> M \\<le> M'; \\<And>x. RETURN x \\<le> M \\<Longrightarrow> f x \\<le> f' x \\<rbrakk> \\<Longrightarrow> bind M f \\<le> bind M' f'\"\n  (*\"\\<lbrakk> flat_le M M'; \\<And>x. flat_le (f x) (f' x) \\<rbrakk> \\<Longrightarrow> flat_le (bind M f) (bind M' f')\"*)\n  \"\\<lbrakk> flat_ge M M'; \\<And>x. flat_ge (f x) (f' x) \\<rbrakk> \\<Longrightarrow> flat_ge (bind M f) (bind M' f')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>M \\<le> M';\n      \\<And>x. RETURN x \\<le> M \\<Longrightarrow> f x \\<le> f' x\\<rbrakk>\n     \\<Longrightarrow> M \\<bind> f \\<le> M' \\<bind> f') &&&\n    (\\<lbrakk>flat_ge M M'; \\<And>x. flat_ge (f x) (f' x)\\<rbrakk>\n     \\<Longrightarrow> flat_ge (M \\<bind> f) (M' \\<bind> f'))", "apply (auto simp: refine_pw_simps pw_ords_iff) []"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>flat_ge M M'; \\<And>x. flat_ge (f x) (f' x)\\<rbrakk>\n    \\<Longrightarrow> flat_ge (M \\<bind> f) (M' \\<bind> f')", "apply (auto simp: refine_pw_simps pw_ords_iff) []"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma bind_mono1[simp, intro!]: \"mono (\\<lambda>M. bind M f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono (\\<lambda>M. M \\<bind> f)", "apply (rule monoI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y. x \\<le> y \\<Longrightarrow> x \\<bind> f \\<le> y \\<bind> f", "apply (rule bind_mono)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y. x \\<le> y \\<Longrightarrow> x \\<le> y\n 2. \\<And>x y xa.\n       \\<lbrakk>x \\<le> y; RETURN xa \\<le> x\\<rbrakk>\n       \\<Longrightarrow> f xa \\<le> f xa", "by auto"], ["", "lemma bind_mono1'[simp, intro!]: \"mono bind\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono (\\<bind>)", "apply (rule monoI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y. x \\<le> y \\<Longrightarrow> (\\<bind>) x \\<le> (\\<bind>) y", "apply (rule le_funI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y xa.\n       x \\<le> y \\<Longrightarrow> x \\<bind> xa \\<le> y \\<bind> xa", "apply (rule bind_mono)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y xa. x \\<le> y \\<Longrightarrow> x \\<le> y\n 2. \\<And>x y xa xb.\n       \\<lbrakk>x \\<le> y; RETURN xb \\<le> x\\<rbrakk>\n       \\<Longrightarrow> xa xb \\<le> xa xb", "by auto"], ["", "lemma bind_mono2'[simp, intro!]: \"mono (bind M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono ((\\<bind>) M)", "apply (rule monoI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y. x \\<le> y \\<Longrightarrow> M \\<bind> x \\<le> M \\<bind> y", "apply (rule bind_mono)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y. x \\<le> y \\<Longrightarrow> M \\<le> M\n 2. \\<And>x y xa.\n       \\<lbrakk>x \\<le> y; RETURN xa \\<le> M\\<rbrakk>\n       \\<Longrightarrow> x xa \\<le> y xa", "by (auto dest: le_funD)"], ["", "lemma bind_distrib_sup1: \"bind (sup M N) f = sup (bind M f) (bind N f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sup M N \\<bind> f = sup (M \\<bind> f) (N \\<bind> f)", "by (auto simp add: pw_eq_iff refine_pw_simps)"], ["", "lemma  bind_distrib_sup2: \"bind m (\\<lambda>x. sup (f x) (g x)) = sup (bind m f) (bind m g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<bind> (\\<lambda>x. sup (f x) (g x)) =\n    sup (m \\<bind> f) (m \\<bind> g)", "by (auto simp: pw_eq_iff refine_pw_simps)"], ["", "lemma bind_distrib_Sup1: \"bind (Sup M) f = (SUP m\\<in>M. bind m f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Sup M \\<bind> f = (SUP m\\<in>M. m \\<bind> f)", "by (auto simp: pw_eq_iff refine_pw_simps)"], ["", "lemma bind_distrib_Sup2: \"F\\<noteq>{} \\<Longrightarrow> bind m (Sup F) = (SUP f\\<in>F. bind m f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. F \\<noteq> {} \\<Longrightarrow> m \\<bind> Sup F = Sup ((\\<bind>) m ` F)", "by (auto simp: pw_eq_iff refine_pw_simps)"], ["", "lemma RES_Sup_RETURN: \"Sup (RETURN`X) = RES X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Sup (RETURN ` X) = RES X", "by (rule pw_eqI) (auto simp add: refine_pw_simps)"], ["", "subsection \\<open>VCG Setup\\<close>"], ["", "lemma SPEC_cons_rule:\n  assumes \"m \\<le> SPEC \\<Phi>\"\n  assumes \"\\<And>x. \\<Phi> x \\<Longrightarrow> \\<Psi> x\"\n  shows \"m \\<le> SPEC \\<Psi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<le> SPEC \\<Psi>", "using assms"], ["proof (prove)\nusing this:\n  m \\<le> SPEC \\<Phi>\n  \\<Phi> ?x \\<Longrightarrow> \\<Psi> ?x\n\ngoal (1 subgoal):\n 1. m \\<le> SPEC \\<Psi>", "by (auto simp: pw_le_iff)"], ["", "lemmas SPEC_trans = order_trans[where z=\"SPEC Postcond\" for Postcond, zero_var_indexes]"], ["", "ML \\<open>\nstructure Refine = struct\n\n  structure vcg = Named_Thms\n    ( val name = @{binding refine_vcg}\n      val description = \"Refinement Framework: \" ^ \n        \"Verification condition generation rules (intro)\" )\n\n  structure vcg_cons = Named_Thms\n    ( val name = @{binding refine_vcg_cons}\n      val description = \"Refinement Framework: \" ^\n        \"Consequence rules tried by VCG\" )\n\n  structure refine0 = Named_Thms\n    ( val name = @{binding refine0}\n      val description = \"Refinement Framework: \" ^\n        \"Refinement rules applied first (intro)\" )\n\n  structure refine = Named_Thms\n    ( val name = @{binding refine}\n      val description = \"Refinement Framework: Refinement rules (intro)\" )\n\n  structure refine2 = Named_Thms\n    ( val name = @{binding refine2}\n      val description = \"Refinement Framework: \" ^\n        \"Refinement rules 2nd stage (intro)\" )\n\n  (* If set to true, the product splitter of refine_rcg is disabled. *)\n  val no_prod_split = \n    Attrib.setup_config_bool @{binding refine_no_prod_split} (K false);\n\n  fun rcg_tac add_thms ctxt = \n    let \n      val cons_thms = vcg_cons.get ctxt\n      val ref_thms = (refine0.get ctxt \n        @ add_thms @ refine.get ctxt @ refine2.get ctxt);\n      val prod_ss = (Splitter.add_split @{thm prod.split} \n        (put_simpset HOL_basic_ss ctxt));\n      val prod_simp_tac = \n        if Config.get ctxt no_prod_split then \n          K no_tac\n        else\n          (simp_tac prod_ss THEN' \n            REPEAT_ALL_NEW (resolve_tac ctxt @{thms impI allI}));\n    in\n      REPEAT_ALL_NEW_FWD (DETERM o FIRST' [\n        resolve_tac ctxt ref_thms,\n        resolve_tac ctxt cons_thms THEN' resolve_tac ctxt ref_thms,\n        prod_simp_tac\n      ])\n    end;\n\n  fun post_tac ctxt = REPEAT_ALL_NEW_FWD (FIRST' [\n    eq_assume_tac,\n    (*match_tac ctxt thms,*)\n    SOLVED' (Tagged_Solver.solve_tac ctxt)]) \n         \n\nend;\n\\<close>"], ["", "setup \\<open>Refine.vcg.setup\\<close>"], ["", "setup \\<open>Refine.vcg_cons.setup\\<close>"], ["", "setup \\<open>Refine.refine0.setup\\<close>"], ["", "setup \\<open>Refine.refine.setup\\<close>"], ["", "setup \\<open>Refine.refine2.setup\\<close>"], ["", "(*setup {* Refine.refine_post.setup *}*)"], ["", "method_setup refine_rcg = \n  \\<open>Attrib.thms >> (fn add_thms => fn ctxt => SIMPLE_METHOD' (\n    Refine.rcg_tac add_thms ctxt THEN_ALL_NEW_FWD (TRY o Refine.post_tac ctxt)\n  ))\\<close> \n  \"Refinement framework: Generate refinement conditions\""], ["", "method_setup refine_vcg = \n  \\<open>Attrib.thms >> (fn add_thms => fn ctxt => SIMPLE_METHOD' (\n    Refine.rcg_tac (add_thms @ Refine.vcg.get ctxt) ctxt THEN_ALL_NEW_FWD (TRY o Refine.post_tac ctxt)\n  ))\\<close> \n  \"Refinement framework: Generate refinement and verification conditions\""], ["", "(* Use tagged-solver instead!\n  method_setup refine_post = \n    {* Scan.succeed (fn ctxt => SIMPLE_METHOD' (\n      Refine.post_tac ctxt\n    )) *} \n    \"Refinement framework: Postprocessing of refinement goals\"\n    *)"], ["", "declare SPEC_cons_rule[refine_vcg_cons]"], ["", "subsection \\<open>Data Refinement\\<close>"], ["", "text \\<open>\n  In this section we establish a notion of pointwise data refinement, by\n  lifting a relation \\<open>R\\<close> between concrete and abstract values to \n  our result lattice.\n\n  Given a relation \\<open>R\\<close>, we define a {\\em concretization function}\n  \\<open>\\<Down>R\\<close> that takes an abstract result, and returns a concrete result.\n  The concrete result contains all values that are mapped by \\<open>R\\<close> to\n  a value in the abstract result.\n\n  Note that our concretization function forms no Galois connection, i.e.,\n  in general there is no \\<open>\\<alpha>\\<close> such that \n  \\<open>m \\<le>\\<Down> R m'\\<close> is equivalent to \\<open>\\<alpha> m \\<le> m'\\<close>.\n  However, we get a Galois connection for the special case of \n  single-valued relations.\n \n  Regarding data refinement as Galois connections is inspired by \\cite{mmo97},\n  that also uses the adjuncts of\n  a Galois connection to express data refinement by program refinement.\n\\<close>"], ["", "definition conc_fun (\"\\<Down>\") where\n  \"conc_fun R m \\<equiv> case m of FAILi \\<Rightarrow> FAIL | RES X \\<Rightarrow> RES (R\\<inverse>``X)\""], ["", "definition abs_fun (\"\\<Up>\") where\n  \"abs_fun R m \\<equiv> case m of FAILi \\<Rightarrow> FAIL \n    | RES X \\<Rightarrow> if X\\<subseteq>Domain R then RES (R``X) else FAIL\""], ["", "lemma \n  conc_fun_FAIL[simp]: \"\\<Down>R FAIL = FAIL\" and\n  conc_fun_RES: \"\\<Down>R (RES X) = RES (R\\<inverse>``X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Down> R FAIL = FAIL &&& \\<Down> R (RES X) = RES (R\\<inverse> `` X)", "unfolding conc_fun_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case FAIL of FAILi \\<Rightarrow> FAIL\n     | RES X \\<Rightarrow> RES (R\\<inverse> `` X)) =\n    FAIL &&&\n    (case RES X of FAILi \\<Rightarrow> FAIL\n     | RES X \\<Rightarrow> RES (R\\<inverse> `` X)) =\n    RES (R\\<inverse> `` X)", "by (auto split: nres.split)"], ["", "lemma abs_fun_simps[simp]: \n  \"\\<Up>R FAIL = FAIL\"\n  \"X\\<subseteq>Domain R \\<Longrightarrow> \\<Up>R (RES X) = RES (R``X)\"\n  \"\\<not>(X\\<subseteq>Domain R) \\<Longrightarrow> \\<Up>R (RES X) = FAIL\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Up> R FAIL = FAIL &&&\n    (X \\<subseteq> Domain R \\<Longrightarrow>\n     \\<Up> R (RES X) = RES (R `` X)) &&&\n    (\\<not> X \\<subseteq> Domain R \\<Longrightarrow> \\<Up> R (RES X) = FAIL)", "unfolding abs_fun_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case FAIL of FAILi \\<Rightarrow> FAIL\n     | RES X \\<Rightarrow>\n         if X \\<subseteq> Domain R then RES (R `` X) else FAIL) =\n    FAIL &&&\n    (X \\<subseteq> Domain R \\<Longrightarrow>\n     (case RES X of FAILi \\<Rightarrow> FAIL\n      | RES X \\<Rightarrow>\n          if X \\<subseteq> Domain R then RES (R `` X) else FAIL) =\n     RES (R `` X)) &&&\n    (\\<not> X \\<subseteq> Domain R \\<Longrightarrow>\n     (case RES X of FAILi \\<Rightarrow> FAIL\n      | RES X \\<Rightarrow>\n          if X \\<subseteq> Domain R then RES (R `` X) else FAIL) =\n     FAIL)", "by (auto split: nres.split)"], ["", "context fixes R assumes SV: \"single_valued R\" begin"], ["", "lemma conc_abs_swap: \"m' \\<le> \\<Down>R m \\<longleftrightarrow> \\<Up>R m' \\<le> m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (m' \\<le> \\<Down> R m) = (\\<Up> R m' \\<le> m)", "unfolding conc_fun_def abs_fun_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (m' \\<le> (case m of FAILi \\<Rightarrow> FAIL\n               | RES X \\<Rightarrow> RES (R\\<inverse> `` X))) =\n    ((case m' of FAILi \\<Rightarrow> FAIL\n      | RES X \\<Rightarrow>\n          if X \\<subseteq> Domain R then RES (R `` X) else FAIL)\n     \\<le> m)", "using SV"], ["proof (prove)\nusing this:\n  single_valued R\n\ngoal (1 subgoal):\n 1. (m' \\<le> (case m of FAILi \\<Rightarrow> FAIL\n               | RES X \\<Rightarrow> RES (R\\<inverse> `` X))) =\n    ((case m' of FAILi \\<Rightarrow> FAIL\n      | RES X \\<Rightarrow>\n          if X \\<subseteq> Domain R then RES (R `` X) else FAIL)\n     \\<le> m)", "by (auto split: nres.split)\n    (metis ImageE converseD single_valuedD subsetD)"], ["", "lemma ac_galois: \"galois_connection (\\<Up>R) (\\<Down>R)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. galois_connection (\\<Up> R) (\\<Down> R)", "apply (unfold_locales)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c a. (c \\<le> \\<Down> R a) = (\\<Up> R c \\<le> a)", "by (rule conc_abs_swap)"], ["", "end"], ["", "lemma pw_abs_nofail[refine_pw_simps]: \n  \"nofail (\\<Up>R M) \\<longleftrightarrow> (nofail M \\<and> (\\<forall>x. inres M x \\<longrightarrow> x\\<in>Domain R))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nofail (\\<Up> R M) =\n    (nofail M \\<and>\n     (\\<forall>x. inres M x \\<longrightarrow> x \\<in> Domain R))", "apply (cases M)"], ["proof (prove)\ngoal (2 subgoals):\n 1. M = FAIL \\<Longrightarrow>\n    nofail (\\<Up> R M) =\n    (nofail M \\<and>\n     (\\<forall>x. inres M x \\<longrightarrow> x \\<in> Domain R))\n 2. \\<And>X.\n       M = RES X \\<Longrightarrow>\n       nofail (\\<Up> R M) =\n       (nofail M \\<and>\n        (\\<forall>x. inres M x \\<longrightarrow> x \\<in> Domain R))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>X.\n       M = RES X \\<Longrightarrow>\n       nofail (\\<Up> R M) =\n       (nofail M \\<and>\n        (\\<forall>x. inres M x \\<longrightarrow> x \\<in> Domain R))", "apply (auto simp: abs_fun_simps abs_fun_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma pw_abs_inres[refine_pw_simps]: \n  \"inres (\\<Up>R M) a \\<longleftrightarrow> (nofail (\\<Up>R M) \\<longrightarrow> (\\<exists>c. inres M c \\<and> (c,a)\\<in>R))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inres (\\<Up> R M) a =\n    (nofail (\\<Up> R M) \\<longrightarrow>\n     (\\<exists>c. inres M c \\<and> (c, a) \\<in> R))", "apply (cases M)"], ["proof (prove)\ngoal (2 subgoals):\n 1. M = FAIL \\<Longrightarrow>\n    inres (\\<Up> R M) a =\n    (nofail (\\<Up> R M) \\<longrightarrow>\n     (\\<exists>c. inres M c \\<and> (c, a) \\<in> R))\n 2. \\<And>X.\n       M = RES X \\<Longrightarrow>\n       inres (\\<Up> R M) a =\n       (nofail (\\<Up> R M) \\<longrightarrow>\n        (\\<exists>c. inres M c \\<and> (c, a) \\<in> R))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>X.\n       M = RES X \\<Longrightarrow>\n       inres (\\<Up> R M) a =\n       (nofail (\\<Up> R M) \\<longrightarrow>\n        (\\<exists>c. inres M c \\<and> (c, a) \\<in> R))", "apply (auto simp: abs_fun_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma pw_conc_nofail[refine_pw_simps]: \n  \"nofail (\\<Down>R S) = nofail S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nofail (\\<Down> R S) = nofail S", "by (cases S) (auto simp: conc_fun_RES)"], ["", "lemma pw_conc_inres[refine_pw_simps]:\n  \"inres (\\<Down>R S') = (\\<lambda>s. nofail S' \n  \\<longrightarrow> (\\<exists>s'. (s,s')\\<in>R \\<and> inres S' s'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inres (\\<Down> R S') =\n    (\\<lambda>s.\n        nofail S' \\<longrightarrow>\n        (\\<exists>s'. (s, s') \\<in> R \\<and> inres S' s'))", "apply (rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s.\n       inres (\\<Down> R S') s =\n       (nofail S' \\<longrightarrow>\n        (\\<exists>s'. (s, s') \\<in> R \\<and> inres S' s'))", "apply (cases S')"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s.\n       S' = FAIL \\<Longrightarrow>\n       inres (\\<Down> R S') s =\n       (nofail S' \\<longrightarrow>\n        (\\<exists>s'. (s, s') \\<in> R \\<and> inres S' s'))\n 2. \\<And>s X.\n       S' = RES X \\<Longrightarrow>\n       inres (\\<Down> R S') s =\n       (nofail S' \\<longrightarrow>\n        (\\<exists>s'. (s, s') \\<in> R \\<and> inres S' s'))", "apply (auto simp: conc_fun_RES)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma abs_fun_strict[simp]:\n  \"\\<Up> R SUCCEED = SUCCEED\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Up> R SUCCEED = SUCCEED", "unfolding abs_fun_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case SUCCEED of FAILi \\<Rightarrow> FAIL\n     | RES X \\<Rightarrow>\n         if X \\<subseteq> Domain R then RES (R `` X) else FAIL) =\n    SUCCEED", "by (auto split: nres.split)"], ["", "lemma conc_fun_strict[simp]:\n  \"\\<Down> R SUCCEED = SUCCEED\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Down> R SUCCEED = SUCCEED", "unfolding conc_fun_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case SUCCEED of FAILi \\<Rightarrow> FAIL\n     | RES X \\<Rightarrow> RES (R\\<inverse> `` X)) =\n    SUCCEED", "by (auto split: nres.split)"], ["", "lemma conc_fun_mono[simp, intro!]: \"mono (\\<Down>R)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono (\\<Down> R)", "by rule (auto simp: pw_le_iff refine_pw_simps)"], ["", "lemma abs_fun_mono[simp, intro!]: \"mono (\\<Up>R)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono (\\<Up> R)", "by rule (auto simp: pw_le_iff refine_pw_simps)"], ["", "lemma conc_fun_R_mono:\n  assumes \"R \\<subseteq> R'\"\n  shows \"\\<Down>R M \\<le> \\<Down>R' M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Down> R M \\<le> \\<Down> R' M", "using assms"], ["proof (prove)\nusing this:\n  R \\<subseteq> R'\n\ngoal (1 subgoal):\n 1. \\<Down> R M \\<le> \\<Down> R' M", "by (auto simp: pw_le_iff refine_pw_simps)"], ["", "lemma conc_fun_chain: \"\\<Down>R (\\<Down>S M) = \\<Down>(R O S) M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Down> R (\\<Down> S M) = \\<Down> (R O S) M", "unfolding conc_fun_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case case M of FAILi \\<Rightarrow> FAIL\n          | RES X \\<Rightarrow> RES (S\\<inverse> `` X) of\n     FAILi \\<Rightarrow> FAIL\n     | RES X \\<Rightarrow> RES (R\\<inverse> `` X)) =\n    (case M of FAILi \\<Rightarrow> FAIL\n     | RES X \\<Rightarrow> RES ((R O S)\\<inverse> `` X))", "by (auto split: nres.split)"], ["", "lemma conc_Id[simp]: \"\\<Down>Id = id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Down> Id = id", "unfolding conc_fun_def [abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. case_nres FAIL (\\<lambda>X. RES (Id\\<inverse> `` X)) = id", "by (auto split: nres.split)"], ["", "lemma abs_Id[simp]: \"\\<Up>Id = id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Up> Id = id", "unfolding abs_fun_def [abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. case_nres FAIL\n     (\\<lambda>X. if X \\<subseteq> Domain Id then RES (Id `` X) else FAIL) =\n    id", "by (auto split: nres.split)"], ["", "lemma conc_fun_fail_iff[simp]: \n  \"\\<Down>R S = FAIL \\<longleftrightarrow> S=FAIL\"\n  \"FAIL = \\<Down>R S \\<longleftrightarrow> S=FAIL\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Down> R S = FAIL) = (S = FAIL) &&& (FAIL = \\<Down> R S) = (S = FAIL)", "by (auto simp add: pw_eq_iff refine_pw_simps)"], ["", "lemma conc_trans[trans]:\n  assumes A: \"C \\<le> \\<Down>R B\" and B: \"B \\<le> \\<Down>R' A\" \n  shows \"C \\<le> \\<Down>R (\\<Down>R' A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. C \\<le> \\<Down> R (\\<Down> R' A)", "using assms"], ["proof (prove)\nusing this:\n  C \\<le> \\<Down> R B\n  B \\<le> \\<Down> R' A\n\ngoal (1 subgoal):\n 1. C \\<le> \\<Down> R (\\<Down> R' A)", "by (fastforce simp: pw_le_iff refine_pw_simps)"], ["", "lemma abs_trans[trans]:\n  assumes A: \"\\<Up>R C \\<le> B\" and B: \"\\<Up>R' B \\<le> A\" \n  shows \"\\<Up>R' (\\<Up>R C) \\<le> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Up> R' (\\<Up> R C) \\<le> A", "using assms"], ["proof (prove)\nusing this:\n  \\<Up> R C \\<le> B\n  \\<Up> R' B \\<le> A\n\ngoal (1 subgoal):\n 1. \\<Up> R' (\\<Up> R C) \\<le> A", "by (fastforce simp: pw_le_iff refine_pw_simps)"], ["", "subsubsection \\<open>Transitivity Reasoner Setup\\<close>"], ["", "text \\<open>WARNING: The order of the single statements is important here!\\<close>"], ["", "lemma conc_trans_additional[trans]:\n  \"\\<And>A B C. A\\<le>\\<Down>R  B \\<Longrightarrow> B\\<le>    C \\<Longrightarrow> A\\<le>\\<Down>R  C\"\n  \"\\<And>A B C. A\\<le>\\<Down>Id B \\<Longrightarrow> B\\<le>\\<Down>R  C \\<Longrightarrow> A\\<le>\\<Down>R  C\"\n  \"\\<And>A B C. A\\<le>\\<Down>R  B \\<Longrightarrow> B\\<le>\\<Down>Id C \\<Longrightarrow> A\\<le>\\<Down>R  C\"\n\n  \"\\<And>A B C. A\\<le>\\<Down>Id B \\<Longrightarrow> B\\<le>\\<Down>Id C \\<Longrightarrow> A\\<le>    C\"\n  \"\\<And>A B C. A\\<le>\\<Down>Id B \\<Longrightarrow> B\\<le>    C \\<Longrightarrow> A\\<le>    C\"\n  \"\\<And>A B C. A\\<le>    B \\<Longrightarrow> B\\<le>\\<Down>Id C \\<Longrightarrow> A\\<le>    C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<And>A B C.\n         \\<lbrakk>A \\<le> \\<Down> R B; B \\<le> C\\<rbrakk>\n         \\<Longrightarrow> A \\<le> \\<Down> R C) &&&\n     (\\<And>A B C.\n         \\<lbrakk>A \\<le> \\<Down> Id B; B \\<le> \\<Down> R C\\<rbrakk>\n         \\<Longrightarrow> A \\<le> \\<Down> R C) &&&\n     (\\<And>A B C.\n         \\<lbrakk>A \\<le> \\<Down> R B; B \\<le> \\<Down> Id C\\<rbrakk>\n         \\<Longrightarrow> A \\<le> \\<Down> R C)) &&&\n    (\\<And>A B C.\n        \\<lbrakk>A \\<le> \\<Down> Id B; B \\<le> \\<Down> Id C\\<rbrakk>\n        \\<Longrightarrow> A \\<le> C) &&&\n    (\\<And>A B C.\n        \\<lbrakk>A \\<le> \\<Down> Id B; B \\<le> C\\<rbrakk>\n        \\<Longrightarrow> A \\<le> C) &&&\n    (\\<And>A B C.\n        \\<lbrakk>A \\<le> B; B \\<le> \\<Down> Id C\\<rbrakk>\n        \\<Longrightarrow> A \\<le> C)", "using conc_trans[where R=R and R'=Id]"], ["proof (prove)\nusing this:\n  \\<lbrakk>?C \\<le> \\<Down> R ?B; ?B \\<le> \\<Down> Id ?A\\<rbrakk>\n  \\<Longrightarrow> ?C \\<le> \\<Down> R (\\<Down> Id ?A)\n\ngoal (1 subgoal):\n 1. ((\\<And>A B C.\n         \\<lbrakk>A \\<le> \\<Down> R B; B \\<le> C\\<rbrakk>\n         \\<Longrightarrow> A \\<le> \\<Down> R C) &&&\n     (\\<And>A B C.\n         \\<lbrakk>A \\<le> \\<Down> Id B; B \\<le> \\<Down> R C\\<rbrakk>\n         \\<Longrightarrow> A \\<le> \\<Down> R C) &&&\n     (\\<And>A B C.\n         \\<lbrakk>A \\<le> \\<Down> R B; B \\<le> \\<Down> Id C\\<rbrakk>\n         \\<Longrightarrow> A \\<le> \\<Down> R C)) &&&\n    (\\<And>A B C.\n        \\<lbrakk>A \\<le> \\<Down> Id B; B \\<le> \\<Down> Id C\\<rbrakk>\n        \\<Longrightarrow> A \\<le> C) &&&\n    (\\<And>A B C.\n        \\<lbrakk>A \\<le> \\<Down> Id B; B \\<le> C\\<rbrakk>\n        \\<Longrightarrow> A \\<le> C) &&&\n    (\\<And>A B C.\n        \\<lbrakk>A \\<le> B; B \\<le> \\<Down> Id C\\<rbrakk>\n        \\<Longrightarrow> A \\<le> C)", "by (auto intro: order_trans)"], ["", "text \\<open>WARNING: The order of the single statements is important here!\\<close>"], ["", "lemma abs_trans_additional[trans]:\n  \"\\<And>A B C. \\<lbrakk> A \\<le> B; \\<Up> R B \\<le> C\\<rbrakk> \\<Longrightarrow> \\<Up> R A \\<le> C\"\n  \"\\<And>A B C. \\<lbrakk>\\<Up> Id A \\<le> B; \\<Up> R B \\<le> C\\<rbrakk> \\<Longrightarrow> \\<Up> R A \\<le> C\"\n  \"\\<And>A B C. \\<lbrakk>\\<Up> R A \\<le> B; \\<Up> Id B \\<le> C\\<rbrakk> \\<Longrightarrow> \\<Up> R A \\<le> C\"\n\n  \"\\<And>A B C. \\<lbrakk>\\<Up> Id A \\<le> B; \\<Up> Id B \\<le> C\\<rbrakk> \\<Longrightarrow> A \\<le> C\"\n  \"\\<And>A B C. \\<lbrakk>\\<Up> Id A \\<le> B; B \\<le> C\\<rbrakk> \\<Longrightarrow> A \\<le> C\"\n  \"\\<And>A B C. \\<lbrakk>A \\<le> B; \\<Up> Id B \\<le> C\\<rbrakk> \\<Longrightarrow> A \\<le> C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<And>A B C.\n         \\<lbrakk>A \\<le> B; \\<Up> R B \\<le> C\\<rbrakk>\n         \\<Longrightarrow> \\<Up> R A \\<le> C) &&&\n     (\\<And>A B C.\n         \\<lbrakk>\\<Up> Id A \\<le> B; \\<Up> R B \\<le> C\\<rbrakk>\n         \\<Longrightarrow> \\<Up> R A \\<le> C) &&&\n     (\\<And>A B C.\n         \\<lbrakk>\\<Up> R A \\<le> B; \\<Up> Id B \\<le> C\\<rbrakk>\n         \\<Longrightarrow> \\<Up> R A \\<le> C)) &&&\n    (\\<And>A B C.\n        \\<lbrakk>\\<Up> Id A \\<le> B; \\<Up> Id B \\<le> C\\<rbrakk>\n        \\<Longrightarrow> A \\<le> C) &&&\n    (\\<And>A B C.\n        \\<lbrakk>\\<Up> Id A \\<le> B; B \\<le> C\\<rbrakk>\n        \\<Longrightarrow> A \\<le> C) &&&\n    (\\<And>A B C.\n        \\<lbrakk>A \\<le> B; \\<Up> Id B \\<le> C\\<rbrakk>\n        \\<Longrightarrow> A \\<le> C)", "apply (auto simp: refine_pw_simps pw_le_iff)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>A B C x c.\n       \\<lbrakk>nofail C; nofail B;\n        \\<forall>x. inres B x \\<longrightarrow> x \\<in> Domain R;\n        \\<forall>x.\n           (\\<exists>c. inres B c \\<and> (c, x) \\<in> R) \\<longrightarrow>\n           inres C x;\n        nofail A; \\<forall>x. inres A x \\<longrightarrow> inres B x;\n        inres A c; (c, x) \\<in> R\\<rbrakk>\n       \\<Longrightarrow> inres C x\n 2. \\<And>A B C x c.\n       \\<lbrakk>nofail C; nofail B;\n        \\<forall>x. inres B x \\<longrightarrow> x \\<in> Domain R;\n        \\<forall>x.\n           (\\<exists>c. inres B c \\<and> (c, x) \\<in> R) \\<longrightarrow>\n           inres C x;\n        nofail A; \\<forall>x. inres A x \\<longrightarrow> inres B x;\n        inres A c; (c, x) \\<in> R\\<rbrakk>\n       \\<Longrightarrow> inres C x", "apply fastforce+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection \\<open>Derived Program Constructs\\<close>"], ["", "text \\<open>\n  In this section, we introduce some programming constructs that are derived \n  from the basic monad and ordering operations of our nondeterminism monad.\n\\<close>"], ["", "subsubsection \\<open>ASSUME and ASSERT\\<close>"], ["", "definition ASSERT where \"ASSERT \\<equiv> iASSERT RETURN\""], ["", "definition ASSUME where \"ASSUME \\<equiv> iASSUME RETURN\""], ["", "interpretation assert?: generic_Assert bind RETURN ASSERT ASSUME"], ["proof (prove)\ngoal (1 subgoal):\n 1. generic_Assert (\\<bind>) RETURN ASSERT ASSUME", "apply unfold_locales"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>f. SUCCEED \\<bind> f = SUCCEED\n 2. \\<And>f. FAIL \\<bind> f = FAIL\n 3. \\<And>u f. RETURN u \\<bind> f = f u\n 4. ASSERT \\<equiv> iASSERT RETURN\n 5. ASSUME \\<equiv> iASSUME RETURN", "by (simp_all add: ASSERT_def ASSUME_def)"], ["", "text \\<open>Order matters! \\<close>"], ["", "lemmas [refine_vcg] = ASSERT_leI"], ["", "lemmas [refine_vcg] = le_ASSUMEI"], ["", "lemmas [refine_vcg] = le_ASSERTI"], ["", "lemmas [refine_vcg] = ASSUME_leI"], ["", "lemma pw_ASSERT[refine_pw_simps]:\n  \"nofail (ASSERT \\<Phi>) \\<longleftrightarrow> \\<Phi>\"\n  \"inres (ASSERT \\<Phi>) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nofail (ASSERT \\<Phi>) = \\<Phi> &&& inres (ASSERT \\<Phi>) x", "by (cases \\<Phi>, simp_all)+"], ["", "lemma pw_ASSUME[refine_pw_simps]:\n  \"nofail (ASSUME \\<Phi>)\"\n  \"inres (ASSUME \\<Phi>) x \\<longleftrightarrow> \\<Phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nofail (ASSUME \\<Phi>) &&& inres (ASSUME \\<Phi>) x = \\<Phi>", "by (cases \\<Phi>, simp_all)+"], ["", "subsubsection \\<open>Recursion\\<close>"], ["", "lemma pw_REC_nofail: \n  shows \"nofail (REC B x) \\<longleftrightarrow> trimono B \\<and>\n  (\\<exists>F. (\\<forall>x. \n    nofail (F x) \\<longrightarrow> nofail (B F x) \n    \\<and> (\\<forall>x'. inres (B F x) x' \\<longrightarrow> inres (F x) x')\n  ) \\<and> nofail (F x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nofail (REC B x) =\n    (trimono B \\<and>\n     (\\<exists>F.\n         (\\<forall>x.\n             nofail (F x) \\<longrightarrow>\n             nofail (B F x) \\<and>\n             (\\<forall>x'.\n                 inres (B F x) x' \\<longrightarrow> inres (F x) x')) \\<and>\n         nofail (F x)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. nofail (REC B x) =\n    (trimono B \\<and>\n     (\\<exists>F.\n         (\\<forall>x.\n             nofail (F x) \\<longrightarrow>\n             nofail (B F x) \\<and>\n             (\\<forall>x'.\n                 inres (B F x) x' \\<longrightarrow> inres (F x) x')) \\<and>\n         nofail (F x)))", "have \"nofail (REC B x) \\<longleftrightarrow> trimono B \\<and>\n  (\\<exists>F. (\\<forall>x. B F x \\<le> F x) \\<and> nofail (F x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nofail (REC B x) =\n    (trimono B \\<and>\n     (\\<exists>F. (\\<forall>x. B F x \\<le> F x) \\<and> nofail (F x)))", "unfolding REC_def lfp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. nofail (if trimono B then Inf {u. B u \\<le> u} x else FAIL) =\n    (trimono B \\<and>\n     (\\<exists>F. (\\<forall>x. B F x \\<le> F x) \\<and> nofail (F x)))", "apply (auto simp: refine_pw_simps intro: le_funI dest: le_funD)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  nofail (REC B x) =\n  (trimono B \\<and>\n   (\\<exists>F. (\\<forall>x. B F x \\<le> F x) \\<and> nofail (F x)))\n\ngoal (1 subgoal):\n 1. nofail (REC B x) =\n    (trimono B \\<and>\n     (\\<exists>F.\n         (\\<forall>x.\n             nofail (F x) \\<longrightarrow>\n             nofail (B F x) \\<and>\n             (\\<forall>x'.\n                 inres (B F x) x' \\<longrightarrow> inres (F x) x')) \\<and>\n         nofail (F x)))", "thus ?thesis"], ["proof (prove)\nusing this:\n  nofail (REC B x) =\n  (trimono B \\<and>\n   (\\<exists>F. (\\<forall>x. B F x \\<le> F x) \\<and> nofail (F x)))\n\ngoal (1 subgoal):\n 1. nofail (REC B x) =\n    (trimono B \\<and>\n     (\\<exists>F.\n         (\\<forall>x.\n             nofail (F x) \\<longrightarrow>\n             nofail (B F x) \\<and>\n             (\\<forall>x'.\n                 inres (B F x) x' \\<longrightarrow> inres (F x) x')) \\<and>\n         nofail (F x)))", "unfolding pw_le_iff"], ["proof (prove)\nusing this:\n  nofail (REC B x) =\n  (trimono B \\<and>\n   (\\<exists>F.\n       (\\<forall>x.\n           nofail (F x) \\<longrightarrow>\n           nofail (B F x) \\<and>\n           (\\<forall>xa.\n               inres (B F x) xa \\<longrightarrow> inres (F x) xa)) \\<and>\n       nofail (F x)))\n\ngoal (1 subgoal):\n 1. nofail (REC B x) =\n    (trimono B \\<and>\n     (\\<exists>F.\n         (\\<forall>x.\n             nofail (F x) \\<longrightarrow>\n             nofail (B F x) \\<and>\n             (\\<forall>x'.\n                 inres (B F x) x' \\<longrightarrow> inres (F x) x')) \\<and>\n         nofail (F x)))", "."], ["proof (state)\nthis:\n  nofail (REC B x) =\n  (trimono B \\<and>\n   (\\<exists>F.\n       (\\<forall>x.\n           nofail (F x) \\<longrightarrow>\n           nofail (B F x) \\<and>\n           (\\<forall>x'.\n               inres (B F x) x' \\<longrightarrow> inres (F x) x')) \\<and>\n       nofail (F x)))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma pw_REC_inres: \n  \"inres (REC B x) x' = (trimono B \\<longrightarrow>\n  (\\<forall>F. (\\<forall>x''. \n    nofail (F x'') \\<longrightarrow> nofail (B F x'') \n    \\<and> (\\<forall>x. inres (B F x'') x \\<longrightarrow> inres (F x'') x)) \n    \\<longrightarrow> inres (F x) x'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inres (REC B x) x' =\n    (trimono B \\<longrightarrow>\n     (\\<forall>F.\n         (\\<forall>x''.\n             nofail (F x'') \\<longrightarrow>\n             nofail (B F x'') \\<and>\n             (\\<forall>x.\n                 inres (B F x'') x \\<longrightarrow>\n                 inres (F x'') x)) \\<longrightarrow>\n         inres (F x) x'))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. inres (REC B x) x' =\n    (trimono B \\<longrightarrow>\n     (\\<forall>F.\n         (\\<forall>x''.\n             nofail (F x'') \\<longrightarrow>\n             nofail (B F x'') \\<and>\n             (\\<forall>x.\n                 inres (B F x'') x \\<longrightarrow>\n                 inres (F x'') x)) \\<longrightarrow>\n         inres (F x) x'))", "have \"inres (REC B x) x' \n    \\<longleftrightarrow> (trimono B \\<longrightarrow> (\\<forall>F. (\\<forall>x''. B F x'' \\<le> F x'') \\<longrightarrow> inres (F x) x'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inres (REC B x) x' =\n    (trimono B \\<longrightarrow>\n     (\\<forall>F.\n         (\\<forall>x''. B F x'' \\<le> F x'') \\<longrightarrow>\n         inres (F x) x'))", "unfolding REC_def lfp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. inres (if trimono B then Inf {u. B u \\<le> u} x else FAIL) x' =\n    (trimono B \\<longrightarrow>\n     (\\<forall>F.\n         (\\<forall>x''. B F x'' \\<le> F x'') \\<longrightarrow>\n         inres (F x) x'))", "by (auto simp: refine_pw_simps intro: le_funI dest: le_funD)"], ["proof (state)\nthis:\n  inres (REC B x) x' =\n  (trimono B \\<longrightarrow>\n   (\\<forall>F.\n       (\\<forall>x''. B F x'' \\<le> F x'') \\<longrightarrow>\n       inres (F x) x'))\n\ngoal (1 subgoal):\n 1. inres (REC B x) x' =\n    (trimono B \\<longrightarrow>\n     (\\<forall>F.\n         (\\<forall>x''.\n             nofail (F x'') \\<longrightarrow>\n             nofail (B F x'') \\<and>\n             (\\<forall>x.\n                 inres (B F x'') x \\<longrightarrow>\n                 inres (F x'') x)) \\<longrightarrow>\n         inres (F x) x'))", "thus ?thesis"], ["proof (prove)\nusing this:\n  inres (REC B x) x' =\n  (trimono B \\<longrightarrow>\n   (\\<forall>F.\n       (\\<forall>x''. B F x'' \\<le> F x'') \\<longrightarrow>\n       inres (F x) x'))\n\ngoal (1 subgoal):\n 1. inres (REC B x) x' =\n    (trimono B \\<longrightarrow>\n     (\\<forall>F.\n         (\\<forall>x''.\n             nofail (F x'') \\<longrightarrow>\n             nofail (B F x'') \\<and>\n             (\\<forall>x.\n                 inres (B F x'') x \\<longrightarrow>\n                 inres (F x'') x)) \\<longrightarrow>\n         inres (F x) x'))", "unfolding pw_le_iff"], ["proof (prove)\nusing this:\n  inres (REC B x) x' =\n  (trimono B \\<longrightarrow>\n   (\\<forall>F.\n       (\\<forall>x''.\n           nofail (F x'') \\<longrightarrow>\n           nofail (B F x'') \\<and>\n           (\\<forall>x.\n               inres (B F x'') x \\<longrightarrow>\n               inres (F x'') x)) \\<longrightarrow>\n       inres (F x) x'))\n\ngoal (1 subgoal):\n 1. inres (REC B x) x' =\n    (trimono B \\<longrightarrow>\n     (\\<forall>F.\n         (\\<forall>x''.\n             nofail (F x'') \\<longrightarrow>\n             nofail (B F x'') \\<and>\n             (\\<forall>x.\n                 inres (B F x'') x \\<longrightarrow>\n                 inres (F x'') x)) \\<longrightarrow>\n         inres (F x) x'))", "."], ["proof (state)\nthis:\n  inres (REC B x) x' =\n  (trimono B \\<longrightarrow>\n   (\\<forall>F.\n       (\\<forall>x''.\n           nofail (F x'') \\<longrightarrow>\n           nofail (B F x'') \\<and>\n           (\\<forall>x.\n               inres (B F x'') x \\<longrightarrow>\n               inres (F x'') x)) \\<longrightarrow>\n       inres (F x) x'))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemmas pw_REC = pw_REC_inres pw_REC_nofail"], ["", "lemma pw_RECT_nofail: \n  shows \"nofail (RECT B x) \\<longleftrightarrow> trimono B \\<and>\n  (\\<forall>F. (\\<forall>y. nofail (B F y) \\<longrightarrow>\n             nofail (F y) \\<and> (\\<forall>x. inres (F y) x \\<longrightarrow> inres (B F y) x)) \\<longrightarrow>\n        nofail (F x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nofail (REC\\<^sub>T B x) =\n    (trimono B \\<and>\n     (\\<forall>F.\n         (\\<forall>y.\n             nofail (B F y) \\<longrightarrow>\n             nofail (F y) \\<and>\n             (\\<forall>x.\n                 inres (F y) x \\<longrightarrow>\n                 inres (B F y) x)) \\<longrightarrow>\n         nofail (F x)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. nofail (REC\\<^sub>T B x) =\n    (trimono B \\<and>\n     (\\<forall>F.\n         (\\<forall>y.\n             nofail (B F y) \\<longrightarrow>\n             nofail (F y) \\<and>\n             (\\<forall>x.\n                 inres (F y) x \\<longrightarrow>\n                 inres (B F y) x)) \\<longrightarrow>\n         nofail (F x)))", "have \"nofail (RECT B x) \\<longleftrightarrow> (trimono B \\<and> (\\<forall>F. (\\<forall>y. F y \\<le> B F y) \\<longrightarrow> nofail (F x)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nofail (REC\\<^sub>T B x) =\n    (trimono B \\<and>\n     (\\<forall>F.\n         (\\<forall>y. F y \\<le> B F y) \\<longrightarrow> nofail (F x)))", "unfolding RECT_gfp_def gfp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. nofail (if trimono B then Sup {u. u \\<le> B u} x else FAIL) =\n    (trimono B \\<and>\n     (\\<forall>F.\n         (\\<forall>y. F y \\<le> B F y) \\<longrightarrow> nofail (F x)))", "by (auto simp: refine_pw_simps intro: le_funI dest: le_funD)"], ["proof (state)\nthis:\n  nofail (REC\\<^sub>T B x) =\n  (trimono B \\<and>\n   (\\<forall>F.\n       (\\<forall>y. F y \\<le> B F y) \\<longrightarrow> nofail (F x)))\n\ngoal (1 subgoal):\n 1. nofail (REC\\<^sub>T B x) =\n    (trimono B \\<and>\n     (\\<forall>F.\n         (\\<forall>y.\n             nofail (B F y) \\<longrightarrow>\n             nofail (F y) \\<and>\n             (\\<forall>x.\n                 inres (F y) x \\<longrightarrow>\n                 inres (B F y) x)) \\<longrightarrow>\n         nofail (F x)))", "thus ?thesis"], ["proof (prove)\nusing this:\n  nofail (REC\\<^sub>T B x) =\n  (trimono B \\<and>\n   (\\<forall>F.\n       (\\<forall>y. F y \\<le> B F y) \\<longrightarrow> nofail (F x)))\n\ngoal (1 subgoal):\n 1. nofail (REC\\<^sub>T B x) =\n    (trimono B \\<and>\n     (\\<forall>F.\n         (\\<forall>y.\n             nofail (B F y) \\<longrightarrow>\n             nofail (F y) \\<and>\n             (\\<forall>x.\n                 inres (F y) x \\<longrightarrow>\n                 inres (B F y) x)) \\<longrightarrow>\n         nofail (F x)))", "unfolding pw_le_iff"], ["proof (prove)\nusing this:\n  nofail (REC\\<^sub>T B x) =\n  (trimono B \\<and>\n   (\\<forall>F.\n       (\\<forall>y.\n           nofail (B F y) \\<longrightarrow>\n           nofail (F y) \\<and>\n           (\\<forall>x.\n               inres (F y) x \\<longrightarrow>\n               inres (B F y) x)) \\<longrightarrow>\n       nofail (F x)))\n\ngoal (1 subgoal):\n 1. nofail (REC\\<^sub>T B x) =\n    (trimono B \\<and>\n     (\\<forall>F.\n         (\\<forall>y.\n             nofail (B F y) \\<longrightarrow>\n             nofail (F y) \\<and>\n             (\\<forall>x.\n                 inres (F y) x \\<longrightarrow>\n                 inres (B F y) x)) \\<longrightarrow>\n         nofail (F x)))", "."], ["proof (state)\nthis:\n  nofail (REC\\<^sub>T B x) =\n  (trimono B \\<and>\n   (\\<forall>F.\n       (\\<forall>y.\n           nofail (B F y) \\<longrightarrow>\n           nofail (F y) \\<and>\n           (\\<forall>x.\n               inres (F y) x \\<longrightarrow>\n               inres (B F y) x)) \\<longrightarrow>\n       nofail (F x)))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma pw_RECT_inres: \n  shows \"inres (RECT B x) x' = (trimono B \\<longrightarrow>\n   (\\<exists>M. (\\<forall>y. nofail (B M y) \\<longrightarrow>\n             nofail (M y) \\<and> (\\<forall>x. inres (M y) x \\<longrightarrow> inres (B M y) x)) \\<and>\n        inres (M x) x'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inres (REC\\<^sub>T B x) x' =\n    (trimono B \\<longrightarrow>\n     (\\<exists>M.\n         (\\<forall>y.\n             nofail (B M y) \\<longrightarrow>\n             nofail (M y) \\<and>\n             (\\<forall>x.\n                 inres (M y) x \\<longrightarrow> inres (B M y) x)) \\<and>\n         inres (M x) x'))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. inres (REC\\<^sub>T B x) x' =\n    (trimono B \\<longrightarrow>\n     (\\<exists>M.\n         (\\<forall>y.\n             nofail (B M y) \\<longrightarrow>\n             nofail (M y) \\<and>\n             (\\<forall>x.\n                 inres (M y) x \\<longrightarrow> inres (B M y) x)) \\<and>\n         inres (M x) x'))", "have \"inres (RECT B x) x' \\<longleftrightarrow> trimono B \\<longrightarrow> (\\<exists>M. (\\<forall>y. M y \\<le> B M y) \\<and> inres (M x) x')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inres (REC\\<^sub>T B x) x' =\n    (trimono B \\<longrightarrow>\n     (\\<exists>M. (\\<forall>y. M y \\<le> B M y) \\<and> inres (M x) x'))", "unfolding RECT_gfp_def gfp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. inres (if trimono B then Sup {u. u \\<le> B u} x else FAIL) x' =\n    (trimono B \\<longrightarrow>\n     (\\<exists>M. (\\<forall>y. M y \\<le> B M y) \\<and> inres (M x) x'))", "by (auto simp: refine_pw_simps intro: le_funI dest: le_funD)"], ["proof (state)\nthis:\n  inres (REC\\<^sub>T B x) x' =\n  (trimono B \\<longrightarrow>\n   (\\<exists>M. (\\<forall>y. M y \\<le> B M y) \\<and> inres (M x) x'))\n\ngoal (1 subgoal):\n 1. inres (REC\\<^sub>T B x) x' =\n    (trimono B \\<longrightarrow>\n     (\\<exists>M.\n         (\\<forall>y.\n             nofail (B M y) \\<longrightarrow>\n             nofail (M y) \\<and>\n             (\\<forall>x.\n                 inres (M y) x \\<longrightarrow> inres (B M y) x)) \\<and>\n         inres (M x) x'))", "thus ?thesis"], ["proof (prove)\nusing this:\n  inres (REC\\<^sub>T B x) x' =\n  (trimono B \\<longrightarrow>\n   (\\<exists>M. (\\<forall>y. M y \\<le> B M y) \\<and> inres (M x) x'))\n\ngoal (1 subgoal):\n 1. inres (REC\\<^sub>T B x) x' =\n    (trimono B \\<longrightarrow>\n     (\\<exists>M.\n         (\\<forall>y.\n             nofail (B M y) \\<longrightarrow>\n             nofail (M y) \\<and>\n             (\\<forall>x.\n                 inres (M y) x \\<longrightarrow> inres (B M y) x)) \\<and>\n         inres (M x) x'))", "unfolding pw_le_iff"], ["proof (prove)\nusing this:\n  inres (REC\\<^sub>T B x) x' =\n  (trimono B \\<longrightarrow>\n   (\\<exists>M.\n       (\\<forall>y.\n           nofail (B M y) \\<longrightarrow>\n           nofail (M y) \\<and>\n           (\\<forall>x.\n               inres (M y) x \\<longrightarrow> inres (B M y) x)) \\<and>\n       inres (M x) x'))\n\ngoal (1 subgoal):\n 1. inres (REC\\<^sub>T B x) x' =\n    (trimono B \\<longrightarrow>\n     (\\<exists>M.\n         (\\<forall>y.\n             nofail (B M y) \\<longrightarrow>\n             nofail (M y) \\<and>\n             (\\<forall>x.\n                 inres (M y) x \\<longrightarrow> inres (B M y) x)) \\<and>\n         inres (M x) x'))", "."], ["proof (state)\nthis:\n  inres (REC\\<^sub>T B x) x' =\n  (trimono B \\<longrightarrow>\n   (\\<exists>M.\n       (\\<forall>y.\n           nofail (B M y) \\<longrightarrow>\n           nofail (M y) \\<and>\n           (\\<forall>x.\n               inres (M y) x \\<longrightarrow> inres (B M y) x)) \\<and>\n       inres (M x) x'))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemmas pw_RECT = pw_RECT_inres pw_RECT_nofail"], ["", "subsection \\<open>Proof Rules\\<close>"], ["", "subsubsection \\<open>Proving Correctness\\<close>"], ["", "text \\<open>\n  In this section, we establish Hoare-like rules to prove that a program\n  meets its specification.\n\\<close>"], ["", "lemma le_SPEC_UNIV_rule [refine_vcg]: \n  \"m \\<le> SPEC (\\<lambda>_. True) \\<Longrightarrow> m \\<le> RES UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<le> SPEC (\\<lambda>_. True) \\<Longrightarrow> m \\<le> RES UNIV", "by auto"], ["", "lemma RETURN_rule[refine_vcg]: \"\\<Phi> x \\<Longrightarrow> RETURN x \\<le> SPEC \\<Phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Phi> x \\<Longrightarrow> RETURN x \\<le> SPEC \\<Phi>", "by (auto simp: RETURN_def)"], ["", "lemma RES_rule[refine_vcg]: \"\\<lbrakk>\\<And>x. x\\<in>S \\<Longrightarrow> \\<Phi> x\\<rbrakk> \\<Longrightarrow> RES S \\<le> SPEC \\<Phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x. x \\<in> S \\<Longrightarrow> \\<Phi> x) \\<Longrightarrow>\n    RES S \\<le> SPEC \\<Phi>", "by auto"], ["", "lemma SUCCEED_rule[refine_vcg]: \"SUCCEED \\<le> SPEC \\<Phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SUCCEED \\<le> SPEC \\<Phi>", "by auto"], ["", "lemma FAIL_rule: \"False \\<Longrightarrow> FAIL \\<le> SPEC \\<Phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. False \\<Longrightarrow> FAIL \\<le> SPEC \\<Phi>", "by auto"], ["", "lemma SPEC_rule[refine_vcg]: \"\\<lbrakk>\\<And>x. \\<Phi> x \\<Longrightarrow> \\<Phi>' x\\<rbrakk> \\<Longrightarrow> SPEC \\<Phi> \\<le> SPEC \\<Phi>'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x. \\<Phi> x \\<Longrightarrow> \\<Phi>' x) \\<Longrightarrow>\n    SPEC \\<Phi> \\<le> SPEC \\<Phi>'", "by auto"], ["", "lemma RETURN_to_SPEC_rule[refine_vcg]: \"m\\<le>SPEC ((=) v) \\<Longrightarrow> m\\<le>RETURN v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<le> SPEC ((=) v) \\<Longrightarrow> m \\<le> RETURN v", "by (simp add: pw_le_iff refine_pw_simps)"], ["", "lemma Sup_img_rule_complete: \n  \"(\\<forall>x. x\\<in>S \\<longrightarrow> f x \\<le> SPEC \\<Phi>) \\<longleftrightarrow> Sup (f`S) \\<le> SPEC \\<Phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x. x \\<in> S \\<longrightarrow> f x \\<le> SPEC \\<Phi>) =\n    (Sup (f ` S) \\<le> SPEC \\<Phi>)", "apply rule"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>x.\n       x \\<in> S \\<longrightarrow> f x \\<le> SPEC \\<Phi> \\<Longrightarrow>\n    Sup (f ` S) \\<le> SPEC \\<Phi>\n 2. Sup (f ` S) \\<le> SPEC \\<Phi> \\<Longrightarrow>\n    \\<forall>x. x \\<in> S \\<longrightarrow> f x \\<le> SPEC \\<Phi>", "apply (rule pw_leI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>x.\n       x \\<in> S \\<longrightarrow> f x \\<le> SPEC \\<Phi> \\<Longrightarrow>\n    nofail (SPEC \\<Phi>) \\<longrightarrow>\n    nofail (Sup (f ` S)) \\<and>\n    (\\<forall>x.\n        inres (Sup (f ` S)) x \\<longrightarrow> inres (SPEC \\<Phi>) x)\n 2. Sup (f ` S) \\<le> SPEC \\<Phi> \\<Longrightarrow>\n    \\<forall>x. x \\<in> S \\<longrightarrow> f x \\<le> SPEC \\<Phi>", "apply (auto simp: pw_le_iff refine_pw_simps) []"], ["proof (prove)\ngoal (1 subgoal):\n 1. Sup (f ` S) \\<le> SPEC \\<Phi> \\<Longrightarrow>\n    \\<forall>x. x \\<in> S \\<longrightarrow> f x \\<le> SPEC \\<Phi>", "apply (intro allI impI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>Sup (f ` S) \\<le> SPEC \\<Phi>; x \\<in> S\\<rbrakk>\n       \\<Longrightarrow> f x \\<le> SPEC \\<Phi>", "apply (rule pw_leI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>Sup (f ` S) \\<le> SPEC \\<Phi>; x \\<in> S\\<rbrakk>\n       \\<Longrightarrow> nofail (SPEC \\<Phi>) \\<longrightarrow>\n                         nofail (f x) \\<and>\n                         (\\<forall>xa.\n                             inres (f x) xa \\<longrightarrow>\n                             inres (SPEC \\<Phi>) xa)", "apply (auto simp: pw_le_iff refine_pw_simps) []"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma SUP_img_rule_complete: \n  \"(\\<forall>x. x\\<in>S \\<longrightarrow> f x \\<le> SPEC \\<Phi>) \\<longleftrightarrow> Sup (f ` S) \\<le> SPEC \\<Phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x. x \\<in> S \\<longrightarrow> f x \\<le> SPEC \\<Phi>) =\n    (Sup (f ` S) \\<le> SPEC \\<Phi>)", "using Sup_img_rule_complete [of S f]"], ["proof (prove)\nusing this:\n  (\\<forall>x. x \\<in> S \\<longrightarrow> f x \\<le> SPEC ?\\<Phi>) =\n  (Sup (f ` S) \\<le> SPEC ?\\<Phi>)\n\ngoal (1 subgoal):\n 1. (\\<forall>x. x \\<in> S \\<longrightarrow> f x \\<le> SPEC \\<Phi>) =\n    (Sup (f ` S) \\<le> SPEC \\<Phi>)", "by simp"], ["", "lemma Sup_img_rule[refine_vcg]: \n  \"\\<lbrakk> \\<And>x. x\\<in>S \\<Longrightarrow> f x \\<le> SPEC \\<Phi> \\<rbrakk> \\<Longrightarrow> Sup(f`S) \\<le> SPEC \\<Phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x.\n        x \\<in> S \\<Longrightarrow> f x \\<le> SPEC \\<Phi>) \\<Longrightarrow>\n    Sup (f ` S) \\<le> SPEC \\<Phi>", "by (auto simp: SUP_img_rule_complete[symmetric])"], ["", "text \\<open>This lemma is just to demonstrate that our rule is complete.\\<close>"], ["", "lemma bind_rule_complete: \"bind M f \\<le> SPEC \\<Phi> \\<longleftrightarrow> M \\<le> SPEC (\\<lambda>x. f x \\<le> SPEC \\<Phi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (M \\<bind> f \\<le> SPEC \\<Phi>) =\n    (M \\<le> SPEC (\\<lambda>x. f x \\<le> SPEC \\<Phi>))", "by (auto simp: pw_le_iff refine_pw_simps)"], ["", "lemma bind_rule[refine_vcg]: \n  \"\\<lbrakk> M \\<le> SPEC (\\<lambda>x. f x \\<le> SPEC \\<Phi>) \\<rbrakk> \\<Longrightarrow> bind M (\\<lambda>x. f x) \\<le> SPEC \\<Phi>\"\n  \\<comment> \\<open>Note: @{text \"\\<eta>\"}-expanded version helps Isabelle's unification to keep meaningful \n      variable names from the program\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. M \\<le> SPEC (\\<lambda>x. f x \\<le> SPEC \\<Phi>) \\<Longrightarrow>\n    M \\<bind> f \\<le> SPEC \\<Phi>", "by (auto simp: bind_rule_complete)"], ["", "lemma ASSUME_rule[refine_vcg]: \"\\<lbrakk>\\<Phi> \\<Longrightarrow> \\<Psi> ()\\<rbrakk> \\<Longrightarrow> ASSUME \\<Phi> \\<le> SPEC \\<Psi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Phi> \\<Longrightarrow> \\<Psi> ()) \\<Longrightarrow>\n    ASSUME \\<Phi> \\<le> SPEC \\<Psi>", "by (cases \\<Phi>) auto"], ["", "lemma ASSERT_rule[refine_vcg]: \"\\<lbrakk>\\<Phi>; \\<Phi> \\<Longrightarrow> \\<Psi> ()\\<rbrakk> \\<Longrightarrow> ASSERT \\<Phi> \\<le> SPEC \\<Psi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<Phi>; \\<Phi> \\<Longrightarrow> \\<Psi> ()\\<rbrakk>\n    \\<Longrightarrow> ASSERT \\<Phi> \\<le> SPEC \\<Psi>", "by auto"], ["", "lemma prod_rule[refine_vcg]: \n  \"\\<lbrakk>\\<And>a b. p=(a,b) \\<Longrightarrow> S a b \\<le> SPEC \\<Phi>\\<rbrakk> \\<Longrightarrow> case_prod S p \\<le> SPEC \\<Phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a b.\n        p = (a, b) \\<Longrightarrow>\n        S a b \\<le> SPEC \\<Phi>) \\<Longrightarrow>\n    (case p of (x, xa) \\<Rightarrow> S x xa) \\<le> SPEC \\<Phi>", "by (auto split: prod.split)"], ["", "(* TODO: Add a simplifier setup that normalizes nested case-expressions to\n  the vcg! *)"], ["", "lemma prod2_rule[refine_vcg]:\n  assumes \"\\<And>a b c d. \\<lbrakk>ab=(a,b); cd=(c,d)\\<rbrakk> \\<Longrightarrow> f a b c d \\<le> SPEC \\<Phi>\"\n  shows \"(\\<lambda>(a,b) (c,d). f a b c d) ab cd \\<le> SPEC \\<Phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (case ab of (a, b) \\<Rightarrow> \\<lambda>(c, d). f a b c d) cd\n    \\<le> SPEC \\<Phi>", "using assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>ab = (?a, ?b); cd = (?c, ?d)\\<rbrakk>\n  \\<Longrightarrow> f ?a ?b ?c ?d \\<le> SPEC \\<Phi>\n\ngoal (1 subgoal):\n 1. (case ab of (a, b) \\<Rightarrow> \\<lambda>(c, d). f a b c d) cd\n    \\<le> SPEC \\<Phi>", "by (auto split: prod.split)"], ["", "lemma if_rule[refine_vcg]: \n  \"\\<lbrakk> b \\<Longrightarrow> S1 \\<le> SPEC \\<Phi>; \\<not>b \\<Longrightarrow> S2 \\<le> SPEC \\<Phi>\\<rbrakk> \n  \\<Longrightarrow> (if b then S1 else S2) \\<le> SPEC \\<Phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>b \\<Longrightarrow> S1 \\<le> SPEC \\<Phi>;\n     \\<not> b \\<Longrightarrow> S2 \\<le> SPEC \\<Phi>\\<rbrakk>\n    \\<Longrightarrow> (if b then S1 else S2) \\<le> SPEC \\<Phi>", "by (auto)"], ["", "lemma option_rule[refine_vcg]: \n  \"\\<lbrakk> v=None \\<Longrightarrow> S1 \\<le> SPEC \\<Phi>; \\<And>x. v=Some x \\<Longrightarrow> f2 x \\<le> SPEC \\<Phi>\\<rbrakk> \n  \\<Longrightarrow> case_option S1 f2 v \\<le> SPEC \\<Phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>v = None \\<Longrightarrow> S1 \\<le> SPEC \\<Phi>;\n     \\<And>x. v = Some x \\<Longrightarrow> f2 x \\<le> SPEC \\<Phi>\\<rbrakk>\n    \\<Longrightarrow> (case v of None \\<Rightarrow> S1\n                       | Some x \\<Rightarrow> f2 x)\n                      \\<le> SPEC \\<Phi>", "by (auto split: option.split)"], ["", "lemma Let_rule[refine_vcg]:\n  \"f x \\<le> SPEC \\<Phi> \\<Longrightarrow> Let x f \\<le> SPEC \\<Phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f x \\<le> SPEC \\<Phi> \\<Longrightarrow> Let x f \\<le> SPEC \\<Phi>", "by auto"], ["", "lemma Let_rule':\n  assumes \"\\<And>x. x=v \\<Longrightarrow> f x \\<le> SPEC \\<Phi>\"\n  shows \"Let v (\\<lambda>x. f x) \\<le> SPEC \\<Phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Let v f \\<le> SPEC \\<Phi>", "using assms"], ["proof (prove)\nusing this:\n  ?x = v \\<Longrightarrow> f ?x \\<le> SPEC \\<Phi>\n\ngoal (1 subgoal):\n 1. Let v f \\<le> SPEC \\<Phi>", "by simp"], ["", "(* Obsolete, use RECT_eq_REC_tproof instead\ntext {* The following lemma shows that greatest and least fixed point are equal,\n  if we can provide a variant. *}\nthm RECT_eq_REC\nlemma RECT_eq_REC_old:\n  assumes WF: \"wf V\"\n  assumes I0: \"I x\"\n  assumes IS: \"\\<And>f x. I x \\<Longrightarrow> \n    body (\\<lambda>x'. do { ASSERT (I x' \\<and> (x',x)\\<in>V); f x'}) x \\<le> body f x\"\n  shows \"REC\\<^sub>T body x = REC body x\"\n  apply (rule RECT_eq_REC)\n  apply (rule WF)\n  apply (rule I0)\n  apply (rule order_trans[OF _ IS])\n  apply (subgoal_tac \"(\\<lambda>x'. if I x' \\<and> (x', x) \\<in> V then f x' else FAIL) = \n    (\\<lambda>x'. ASSERT (I x' \\<and> (x', x) \\<in> V) \\<bind> (\\<lambda>_. f x'))\")\n  apply simp\n  apply (rule ext)\n  apply (rule pw_eqI)\n  apply (auto simp add: refine_pw_simps)\n  done\n*)\n\n(* TODO: Also require RECT_le_rule. Derive RECT_invisible_refine from that. *)"], ["", "lemma REC_le_rule:\n  assumes M: \"trimono body\"\n  assumes I0: \"(x,x')\\<in>R\"\n  assumes IS: \"\\<And>f x x'. \\<lbrakk> \\<And>x x'. (x,x')\\<in>R \\<Longrightarrow> f x \\<le> M x'; (x,x')\\<in>R \\<rbrakk> \n    \\<Longrightarrow> body f x \\<le> M x'\"\n  shows \"REC body x \\<le> M x'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. REC body x \\<le> M x'", "by (rule REC_rule_arb[OF M, where pre=\"\\<lambda>x' x. (x,x')\\<in>R\", OF I0 IS])"], ["", "(* TODO: Invariant annotations and vcg-rule\n  Possibility 1: Semantically alter the program, such that it fails if the \n    invariant does not hold\n  Possibility 2: Only syntactically annotate the invariant, as hint for the VCG.\n*)"], ["", "subsubsection \\<open>Proving Monotonicity\\<close>"], ["", "lemma nr_mono_bind:\n  assumes MA: \"mono A\" and MB: \"\\<And>s. mono (B s)\"\n  shows \"mono (\\<lambda>F s. bind (A F s) (\\<lambda>s'. B s F s'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono (\\<lambda>F s. A F s \\<bind> B s F)", "apply (rule monoI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       x \\<le> y \\<Longrightarrow>\n       (\\<lambda>s. A x s \\<bind> B s x)\n       \\<le> (\\<lambda>s. A y s \\<bind> B s y)", "apply (rule le_funI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y xa.\n       x \\<le> y \\<Longrightarrow>\n       A x xa \\<bind> B xa x \\<le> A y xa \\<bind> B xa y", "apply (rule bind_mono)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y xa. x \\<le> y \\<Longrightarrow> A x xa \\<le> A y xa\n 2. \\<And>x y xa xb.\n       \\<lbrakk>x \\<le> y; RETURN xb \\<le> A x xa\\<rbrakk>\n       \\<Longrightarrow> B xa x xb \\<le> B xa y xb", "apply (auto dest: monoD[OF MA, THEN le_funD]) []"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y xa xb.\n       \\<lbrakk>x \\<le> y; RETURN xb \\<le> A x xa\\<rbrakk>\n       \\<Longrightarrow> B xa x xb \\<le> B xa y xb", "apply (auto dest: monoD[OF MB, THEN le_funD]) []"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma nr_mono_bind': \"mono (\\<lambda>F s. bind (f s) F)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono (\\<lambda>F s. f s \\<bind> F)", "apply rule"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       x \\<le> y \\<Longrightarrow>\n       (\\<lambda>s. f s \\<bind> x) \\<le> (\\<lambda>s. f s \\<bind> y)", "apply (rule le_funI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y xa.\n       x \\<le> y \\<Longrightarrow> f xa \\<bind> x \\<le> f xa \\<bind> y", "apply (rule bind_mono)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y xa. x \\<le> y \\<Longrightarrow> f xa \\<le> f xa\n 2. \\<And>x y xa xb.\n       \\<lbrakk>x \\<le> y; RETURN xb \\<le> f xa\\<rbrakk>\n       \\<Longrightarrow> x xb \\<le> y xb", "apply (auto dest: le_funD)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemmas nr_mono = nr_mono_bind nr_mono_bind' mono_const mono_if mono_id"], ["", "subsubsection \\<open>Proving Refinement\\<close>"], ["", "text \\<open>In this subsection, we establish rules to prove refinement between \n  structurally similar programs. All rules are formulated including a possible\n  data refinement via a refinement relation. If this is not required, the \n  refinement relation can be chosen to be the identity relation.\n\\<close>"], ["", "text \\<open>If we have two identical programs, this rule solves the refinement goal\n  immediately, using the identity refinement relation.\\<close>"], ["", "lemma Id_refine[refine0]: \"S \\<le> \\<Down>Id S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S \\<le> \\<Down> Id S", "by auto"], ["", "lemma RES_refine: \n  \"\\<lbrakk> \\<And>s. s\\<in>S \\<Longrightarrow> \\<exists>s'\\<in>S'. (s,s')\\<in>R\\<rbrakk> \\<Longrightarrow> RES S \\<le> \\<Down>R (RES S')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>s.\n        s \\<in> S \\<Longrightarrow>\n        \\<exists>s'\\<in>S'. (s, s') \\<in> R) \\<Longrightarrow>\n    RES S \\<le> \\<Down> R (RES S')", "by (auto simp: conc_fun_RES)"], ["", "lemma SPEC_refine: \n  assumes \"S \\<le> SPEC (\\<lambda>x. \\<exists>x'. (x,x')\\<in>R \\<and> \\<Phi> x')\"\n  shows \"S \\<le> \\<Down>R (SPEC \\<Phi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S \\<le> \\<Down> R (SPEC \\<Phi>)", "using assms"], ["proof (prove)\nusing this:\n  S \\<le> SPEC (\\<lambda>x. \\<exists>x'. (x, x') \\<in> R \\<and> \\<Phi> x')\n\ngoal (1 subgoal):\n 1. S \\<le> \\<Down> R (SPEC \\<Phi>)", "by (force simp: pw_le_iff refine_pw_simps)"], ["", "(* TODO/FIXME: This is already part of a type-based heuristics! *)"], ["", "lemma Id_SPEC_refine[refine]: \n  \"S \\<le> SPEC \\<Phi> \\<Longrightarrow> S \\<le> \\<Down>Id (SPEC \\<Phi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S \\<le> SPEC \\<Phi> \\<Longrightarrow> S \\<le> \\<Down> Id (SPEC \\<Phi>)", "by simp"], ["", "lemma RETURN_refine[refine]:\n  assumes \"(x,x')\\<in>R\"\n  shows \"RETURN x \\<le> \\<Down>R (RETURN x')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RETURN x \\<le> \\<Down> R (RETURN x')", "using assms"], ["proof (prove)\nusing this:\n  (x, x') \\<in> R\n\ngoal (1 subgoal):\n 1. RETURN x \\<le> \\<Down> R (RETURN x')", "by (auto simp: RETURN_def conc_fun_RES)"], ["", "lemma RETURN_SPEC_refine:\n  assumes \"\\<exists>x'. (x,x')\\<in>R \\<and> \\<Phi> x'\"\n  shows \"RETURN x \\<le> \\<Down>R (SPEC \\<Phi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RETURN x \\<le> \\<Down> R (SPEC \\<Phi>)", "using assms"], ["proof (prove)\nusing this:\n  \\<exists>x'. (x, x') \\<in> R \\<and> \\<Phi> x'\n\ngoal (1 subgoal):\n 1. RETURN x \\<le> \\<Down> R (SPEC \\<Phi>)", "by (auto simp: pw_le_iff refine_pw_simps)"], ["", "lemma FAIL_refine[refine]: \"X \\<le> \\<Down>R FAIL\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X \\<le> \\<Down> R FAIL", "by auto"], ["", "lemma SUCCEED_refine[refine]: \"SUCCEED \\<le> \\<Down>R X'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SUCCEED \\<le> \\<Down> R X'", "by auto"], ["", "lemma sup_refine[refine]:\n  assumes \"ai \\<le>\\<Down>R a\"\n  assumes \"bi \\<le>\\<Down>R b\"\n  shows \"sup ai bi \\<le>\\<Down>R (sup a b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sup ai bi \\<le> \\<Down> R (sup a b)", "using assms"], ["proof (prove)\nusing this:\n  ai \\<le> \\<Down> R a\n  bi \\<le> \\<Down> R b\n\ngoal (1 subgoal):\n 1. sup ai bi \\<le> \\<Down> R (sup a b)", "by (auto simp: pw_le_iff refine_pw_simps)"], ["", "text \\<open>The next two rules are incomplete, but a good approximation for refining\n  structurally similar programs.\\<close>"], ["", "lemma bind_refine':\n  fixes R' :: \"('a\\<times>'b) set\" and R::\"('c\\<times>'d) set\"\n  assumes R1: \"M \\<le> \\<Down> R' M'\"\n  assumes R2: \"\\<And>x x'. \\<lbrakk> (x,x')\\<in>R'; inres M x; inres M' x';\n    nofail M; nofail M'\n  \\<rbrakk> \\<Longrightarrow> f x \\<le> \\<Down> R (f' x')\"\n  shows \"bind M (\\<lambda>x. f x) \\<le> \\<Down> R (bind M' (\\<lambda>x'. f' x'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M \\<bind> f \\<le> \\<Down> R (M' \\<bind> f')", "using assms"], ["proof (prove)\nusing this:\n  M \\<le> \\<Down> R' M'\n  \\<lbrakk>(?x, ?x') \\<in> R'; inres M ?x; inres M' ?x'; nofail M;\n   nofail M'\\<rbrakk>\n  \\<Longrightarrow> f ?x \\<le> \\<Down> R (f' ?x')\n\ngoal (1 subgoal):\n 1. M \\<bind> f \\<le> \\<Down> R (M' \\<bind> f')", "apply (simp add: pw_le_iff refine_pw_simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>nofail M' \\<longrightarrow>\n             nofail M \\<and>\n             (\\<forall>x.\n                 inres M x \\<longrightarrow>\n                 (\\<exists>s'. (x, s') \\<in> R' \\<and> inres M' s'));\n     \\<And>x x'.\n        \\<lbrakk>(x, x') \\<in> R'; inres M x; inres M' x';\n         nofail M'\\<rbrakk>\n        \\<Longrightarrow> nofail (f' x') \\<longrightarrow>\n                          nofail (f x) \\<and>\n                          (\\<forall>xa.\n                              inres (f x) xa \\<longrightarrow>\n                              (\\<exists>s'.\n                                  (xa, s') \\<in> R \\<and>\n                                  inres (f' x') s'))\\<rbrakk>\n    \\<Longrightarrow> nofail M' \\<and>\n                      (\\<forall>x.\n                          inres M' x \\<longrightarrow>\n                          nofail (f' x)) \\<longrightarrow>\n                      (\\<forall>x.\n                          inres M x \\<longrightarrow> nofail (f x)) \\<and>\n                      (\\<forall>x.\n                          (\\<exists>y.\n                              inres M y \\<and>\n                              inres (f y) x) \\<longrightarrow>\n                          (\\<exists>s'.\n                              (x, s') \\<in> R \\<and>\n                              (\\<exists>y.\n                                  inres M' y \\<and> inres (f' y) s')))", "apply fast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma bind_refine[refine]:\n  fixes R' :: \"('a\\<times>'b) set\" and R::\"('c\\<times>'d) set\"\n  assumes R1: \"M \\<le> \\<Down> R' M'\"\n  assumes R2: \"\\<And>x x'. \\<lbrakk> (x,x')\\<in>R' \\<rbrakk> \n    \\<Longrightarrow> f x \\<le> \\<Down> R (f' x')\"\n  shows \"bind M (\\<lambda>x. f x) \\<le> \\<Down> R (bind M' (\\<lambda>x'. f' x'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M \\<bind> f \\<le> \\<Down> R (M' \\<bind> f')", "apply (rule bind_refine')"], ["proof (prove)\ngoal (2 subgoals):\n 1. M \\<le> \\<Down> ?R' M'\n 2. \\<And>x x'.\n       \\<lbrakk>(x, x') \\<in> ?R'; inres M x; inres M' x'; nofail M;\n        nofail M'\\<rbrakk>\n       \\<Longrightarrow> f x \\<le> \\<Down> R (f' x')", "using assms"], ["proof (prove)\nusing this:\n  M \\<le> \\<Down> R' M'\n  (?x, ?x') \\<in> R' \\<Longrightarrow> f ?x \\<le> \\<Down> R (f' ?x')\n\ngoal (2 subgoals):\n 1. M \\<le> \\<Down> ?R' M'\n 2. \\<And>x x'.\n       \\<lbrakk>(x, x') \\<in> ?R'; inres M x; inres M' x'; nofail M;\n        nofail M'\\<rbrakk>\n       \\<Longrightarrow> f x \\<le> \\<Down> R (f' x')", "by auto"], ["", "lemma bind_refine_abs': (* Only keep nf_inres-information for abstract *)\n  fixes R' :: \"('a\\<times>'b) set\" and R::\"('c\\<times>'d) set\"\n  assumes R1: \"M \\<le> \\<Down> R' M'\"\n  assumes R2: \"\\<And>x x'. \\<lbrakk> (x,x')\\<in>R'; nf_inres M' x'\n  \\<rbrakk> \\<Longrightarrow> f x \\<le> \\<Down> R (f' x')\"\n  shows \"bind M (\\<lambda>x. f x) \\<le> \\<Down> R (bind M' (\\<lambda>x'. f' x'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M \\<bind> f \\<le> \\<Down> R (M' \\<bind> f')", "using assms"], ["proof (prove)\nusing this:\n  M \\<le> \\<Down> R' M'\n  \\<lbrakk>(?x, ?x') \\<in> R'; nf_inres M' ?x'\\<rbrakk>\n  \\<Longrightarrow> f ?x \\<le> \\<Down> R (f' ?x')\n\ngoal (1 subgoal):\n 1. M \\<bind> f \\<le> \\<Down> R (M' \\<bind> f')", "apply (simp add: pw_le_iff refine_pw_simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>nofail M' \\<longrightarrow>\n             nofail M \\<and>\n             (\\<forall>x.\n                 inres M x \\<longrightarrow>\n                 (\\<exists>s'. (x, s') \\<in> R' \\<and> inres M' s'));\n     \\<And>x x'.\n        \\<lbrakk>(x, x') \\<in> R'; nofail M' \\<and> inres M' x'\\<rbrakk>\n        \\<Longrightarrow> nofail (f' x') \\<longrightarrow>\n                          nofail (f x) \\<and>\n                          (\\<forall>xa.\n                              inres (f x) xa \\<longrightarrow>\n                              (\\<exists>s'.\n                                  (xa, s') \\<in> R \\<and>\n                                  inres (f' x') s'))\\<rbrakk>\n    \\<Longrightarrow> nofail M' \\<and>\n                      (\\<forall>x.\n                          inres M' x \\<longrightarrow>\n                          nofail (f' x)) \\<longrightarrow>\n                      (\\<forall>x.\n                          inres M x \\<longrightarrow> nofail (f x)) \\<and>\n                      (\\<forall>x.\n                          (\\<exists>y.\n                              inres M y \\<and>\n                              inres (f y) x) \\<longrightarrow>\n                          (\\<exists>s'.\n                              (x, s') \\<in> R \\<and>\n                              (\\<exists>y.\n                                  inres M' y \\<and> inres (f' y) s')))", "apply blast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>Special cases for refinement of binding to \\<open>RES\\<close>\n  statements\\<close>"], ["", "lemma bind_refine_RES:\n  \"\\<lbrakk>RES X \\<le> \\<Down> R' M';\n  \\<And>x x'. \\<lbrakk>(x, x') \\<in> R'; x \\<in> X \\<rbrakk> \\<Longrightarrow> f x \\<le> \\<Down> R (f' x')\\<rbrakk>\n  \\<Longrightarrow> RES X \\<bind> (\\<lambda>x. f x) \\<le> \\<Down> R (M' \\<bind> (\\<lambda>x'. f' x'))\"\n\n  \"\\<lbrakk>M \\<le> \\<Down> R' (RES X');\n  \\<And>x x'. \\<lbrakk>(x, x') \\<in> R'; x' \\<in> X' \\<rbrakk> \\<Longrightarrow> f x \\<le> \\<Down> R (f' x')\\<rbrakk>\n  \\<Longrightarrow> M \\<bind> (\\<lambda>x. f x) \\<le> \\<Down> R (RES X' \\<bind> (\\<lambda>x'. f' x'))\"\n\n  \"\\<lbrakk>RES X \\<le> \\<Down> R' (RES X');\n  \\<And>x x'. \\<lbrakk>(x, x') \\<in> R'; x \\<in> X; x' \\<in> X'\\<rbrakk> \\<Longrightarrow> f x \\<le> \\<Down> R (f' x')\\<rbrakk>\n  \\<Longrightarrow> RES X \\<bind> (\\<lambda>x. f x) \\<le> \\<Down> R (RES X' \\<bind> (\\<lambda>x'. f' x'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>RES X \\<le> \\<Down> R' M';\n      \\<And>x x'.\n         \\<lbrakk>(x, x') \\<in> R'; x \\<in> X\\<rbrakk>\n         \\<Longrightarrow> f x \\<le> \\<Down> R (f' x')\\<rbrakk>\n     \\<Longrightarrow> RES X \\<bind> f \\<le> \\<Down> R (M' \\<bind> f')) &&&\n    (\\<lbrakk>M \\<le> \\<Down> R' (RES X');\n      \\<And>x x'.\n         \\<lbrakk>(x, x') \\<in> R'; x' \\<in> X'\\<rbrakk>\n         \\<Longrightarrow> f x \\<le> \\<Down> R (f' x')\\<rbrakk>\n     \\<Longrightarrow> M \\<bind> f \\<le> \\<Down> R (RES X' \\<bind> f')) &&&\n    (\\<lbrakk>RES X \\<le> \\<Down> R' (RES X');\n      \\<And>x x'.\n         \\<lbrakk>(x, x') \\<in> R'; x \\<in> X; x' \\<in> X'\\<rbrakk>\n         \\<Longrightarrow> f x \\<le> \\<Down> R (f' x')\\<rbrakk>\n     \\<Longrightarrow> RES X \\<bind> f \\<le> \\<Down> R (RES X' \\<bind> f'))", "by (auto intro!: bind_refine')"], ["", "declare bind_refine_RES(1,2)[refine]"], ["", "declare bind_refine_RES(3)[refine]"], ["", "lemma ASSERT_refine[refine]:\n  \"\\<lbrakk> \\<Phi>'\\<Longrightarrow>\\<Phi> \\<rbrakk> \\<Longrightarrow> ASSERT \\<Phi> \\<le> \\<Down>Id (ASSERT \\<Phi>')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Phi>' \\<Longrightarrow> \\<Phi>) \\<Longrightarrow>\n    ASSERT \\<Phi> \\<le> \\<Down> unit_rel (ASSERT \\<Phi>')", "by (cases \\<Phi>') auto"], ["", "lemma ASSUME_refine[refine]: \n  \"\\<lbrakk> \\<Phi> \\<Longrightarrow> \\<Phi>' \\<rbrakk> \\<Longrightarrow> ASSUME \\<Phi> \\<le> \\<Down>Id (ASSUME \\<Phi>')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Phi> \\<Longrightarrow> \\<Phi>') \\<Longrightarrow>\n    ASSUME \\<Phi> \\<le> \\<Down> unit_rel (ASSUME \\<Phi>')", "by (cases \\<Phi>) auto"], ["", "text \\<open>\n  Assertions and assumptions are treated specially in bindings\n\\<close>"], ["", "lemma ASSERT_refine_right:\n  assumes \"\\<Phi> \\<Longrightarrow> S \\<le>\\<Down>R S'\"\n  shows \"S \\<le>\\<Down>R (do {ASSERT \\<Phi>; S'})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S \\<le> \\<Down> R (ASSERT \\<Phi> \\<bind> (\\<lambda>_. S'))", "using assms"], ["proof (prove)\nusing this:\n  \\<Phi> \\<Longrightarrow> S \\<le> \\<Down> R S'\n\ngoal (1 subgoal):\n 1. S \\<le> \\<Down> R (ASSERT \\<Phi> \\<bind> (\\<lambda>_. S'))", "by (cases \\<Phi>) auto"], ["", "lemma ASSERT_refine_right_pres:\n  assumes \"\\<Phi> \\<Longrightarrow> S \\<le>\\<Down>R (do {ASSERT \\<Phi>; S'})\"\n  shows \"S \\<le>\\<Down>R (do {ASSERT \\<Phi>; S'})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S \\<le> \\<Down> R (ASSERT \\<Phi> \\<bind> (\\<lambda>_. S'))", "using assms"], ["proof (prove)\nusing this:\n  \\<Phi> \\<Longrightarrow>\n  S \\<le> \\<Down> R (ASSERT \\<Phi> \\<bind> (\\<lambda>_. S'))\n\ngoal (1 subgoal):\n 1. S \\<le> \\<Down> R (ASSERT \\<Phi> \\<bind> (\\<lambda>_. S'))", "by (cases \\<Phi>) auto"], ["", "lemma ASSERT_refine_left:\n  assumes \"\\<Phi>\"\n  assumes \"\\<Phi> \\<Longrightarrow> S \\<le> \\<Down>R S'\"\n  shows \"do{ASSERT \\<Phi>; S} \\<le> \\<Down>R S'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ASSERT \\<Phi> \\<bind> (\\<lambda>_. S) \\<le> \\<Down> R S'", "using assms"], ["proof (prove)\nusing this:\n  \\<Phi>\n  \\<Phi> \\<Longrightarrow> S \\<le> \\<Down> R S'\n\ngoal (1 subgoal):\n 1. ASSERT \\<Phi> \\<bind> (\\<lambda>_. S) \\<le> \\<Down> R S'", "by (cases \\<Phi>) auto"], ["", "lemma ASSUME_refine_right:\n  assumes \"\\<Phi>\"\n  assumes \"\\<Phi> \\<Longrightarrow> S \\<le>\\<Down>R S'\"\n  shows \"S \\<le>\\<Down>R (do {ASSUME \\<Phi>; S'})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S \\<le> \\<Down> R (ASSUME \\<Phi> \\<bind> (\\<lambda>_. S'))", "using assms"], ["proof (prove)\nusing this:\n  \\<Phi>\n  \\<Phi> \\<Longrightarrow> S \\<le> \\<Down> R S'\n\ngoal (1 subgoal):\n 1. S \\<le> \\<Down> R (ASSUME \\<Phi> \\<bind> (\\<lambda>_. S'))", "by (cases \\<Phi>) auto"], ["", "lemma ASSUME_refine_left:\n  assumes \"\\<Phi> \\<Longrightarrow> S \\<le> \\<Down>R S'\"\n  shows \"do {ASSUME \\<Phi>; S} \\<le> \\<Down>R S'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ASSUME \\<Phi> \\<bind> (\\<lambda>_. S) \\<le> \\<Down> R S'", "using assms"], ["proof (prove)\nusing this:\n  \\<Phi> \\<Longrightarrow> S \\<le> \\<Down> R S'\n\ngoal (1 subgoal):\n 1. ASSUME \\<Phi> \\<bind> (\\<lambda>_. S) \\<le> \\<Down> R S'", "by (cases \\<Phi>) auto"], ["", "lemma ASSUME_refine_left_pres:\n  assumes \"\\<Phi> \\<Longrightarrow> do {ASSUME \\<Phi>; S} \\<le> \\<Down>R S'\"\n  shows \"do {ASSUME \\<Phi>; S} \\<le> \\<Down>R S'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ASSUME \\<Phi> \\<bind> (\\<lambda>_. S) \\<le> \\<Down> R S'", "using assms"], ["proof (prove)\nusing this:\n  \\<Phi> \\<Longrightarrow>\n  ASSUME \\<Phi> \\<bind> (\\<lambda>_. S) \\<le> \\<Down> R S'\n\ngoal (1 subgoal):\n 1. ASSUME \\<Phi> \\<bind> (\\<lambda>_. S) \\<le> \\<Down> R S'", "by (cases \\<Phi>) auto"], ["", "text \\<open>Warning: The order of \\<open>[refine]\\<close>-declarations is \n  important here, as preconditions should be generated before \n  additional proof obligations.\\<close>"], ["", "lemmas [refine0] = ASSUME_refine_right"], ["", "lemmas [refine0] = ASSERT_refine_left"], ["", "lemmas [refine0] = ASSUME_refine_left"], ["", "lemmas [refine0] = ASSERT_refine_right"], ["", "text \\<open>For backward compatibility, as \\<open>intro refine\\<close> still\n  seems to be used instead of \\<open>refine_rcg\\<close>.\\<close>"], ["", "lemmas [refine] = ASSUME_refine_right"], ["", "lemmas [refine] = ASSERT_refine_left"], ["", "lemmas [refine] = ASSUME_refine_left"], ["", "lemmas [refine] = ASSERT_refine_right"], ["", "definition lift_assn :: \"('a \\<times> 'b) set \\<Rightarrow> ('b \\<Rightarrow> bool) \\<Rightarrow> ('a \\<Rightarrow> bool)\"\n  \\<comment> \\<open>Lift assertion over refinement relation\\<close>\n  where \"lift_assn R \\<Phi> s \\<equiv> \\<exists>s'. (s,s')\\<in>R \\<and> \\<Phi> s'\""], ["", "lemma lift_assnI: \"\\<lbrakk>(s,s')\\<in>R; \\<Phi> s'\\<rbrakk> \\<Longrightarrow> lift_assn R \\<Phi> s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(s, s') \\<in> R; \\<Phi> s'\\<rbrakk>\n    \\<Longrightarrow> lift_assn R \\<Phi> s", "unfolding lift_assn_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(s, s') \\<in> R; \\<Phi> s'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s'. (s, s') \\<in> R \\<and> \\<Phi> s'", "by auto"], ["", "lemma REC_refine[refine]:\n  assumes M: \"trimono body\"\n  assumes R0: \"(x,x')\\<in>R\"\n  assumes RS: \"\\<And>f f' x x'. \\<lbrakk> \\<And>x x'. (x,x')\\<in>R \\<Longrightarrow> f x \\<le>\\<Down>S (f' x'); (x,x')\\<in>R; \n        REC body' = f' \\<rbrakk> \n    \\<Longrightarrow> body f x \\<le>\\<Down>S (body' f' x')\"\n  shows \"REC (\\<lambda>f x. body f x) x \\<le>\\<Down>S (REC (\\<lambda>f' x'. body' f' x') x')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. REC body x \\<le> \\<Down> S (REC body' x')", "unfolding REC_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if trimono body then lfp body x else FAIL)\n    \\<le> \\<Down> S (if trimono body' then lfp body' x' else FAIL)", "apply (clarsimp simp add: M)"], ["proof (prove)\ngoal (1 subgoal):\n 1. trimono body' \\<Longrightarrow>\n    lfp body x \\<le> \\<Down> S (lfp body' x')", "apply (rule lfp_induct_pointwise[where pre=\"\\<lambda>x' x. (x,x')\\<in>R\" and B=body])"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>a x.\n       trimono body' \\<Longrightarrow>\n       chain_admissible\n        (\\<lambda>b.\n            \\<forall>a x.\n               (x, a) \\<in> R \\<longrightarrow>\n               b x \\<le> \\<Down> S (lfp body' a))\n 2. \\<And>a x.\n       trimono body' \\<Longrightarrow>\n       (x, a) \\<in> R \\<longrightarrow>\n       SUCCEED \\<le> \\<Down> S (lfp body' a)\n 3. trimono body' \\<Longrightarrow> mono body\n 4. trimono body' \\<Longrightarrow> (x, x') \\<in> R\n 5. \\<And>f a x.\n       \\<lbrakk>trimono body';\n        \\<And>a' x'.\n           (x', a') \\<in> R \\<Longrightarrow>\n           f x' \\<le> \\<Down> S (lfp body' a');\n        (x, a) \\<in> R; f \\<le> lfp body\\<rbrakk>\n       \\<Longrightarrow> body f x \\<le> \\<Down> S (lfp body' a)", "apply rule"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>a x A.\n       \\<lbrakk>trimono body'; is_chain A; A \\<noteq> {};\n        \\<forall>x\\<in>A.\n           \\<forall>a xa.\n              (xa, a) \\<in> R \\<longrightarrow>\n              x xa \\<le> \\<Down> S (lfp body' a)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a x.\n                            (x, a) \\<in> R \\<longrightarrow>\n                            Sup A x \\<le> \\<Down> S (lfp body' a)\n 2. \\<And>a x.\n       trimono body' \\<Longrightarrow>\n       (x, a) \\<in> R \\<longrightarrow>\n       SUCCEED \\<le> \\<Down> S (lfp body' a)\n 3. trimono body' \\<Longrightarrow> mono body\n 4. trimono body' \\<Longrightarrow> (x, x') \\<in> R\n 5. \\<And>f a x.\n       \\<lbrakk>trimono body';\n        \\<And>a' x'.\n           (x', a') \\<in> R \\<Longrightarrow>\n           f x' \\<le> \\<Down> S (lfp body' a');\n        (x, a) \\<in> R; f \\<le> lfp body\\<rbrakk>\n       \\<Longrightarrow> body f x \\<le> \\<Down> S (lfp body' a)", "apply clarsimp"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>A a x.\n       \\<lbrakk>trimono body'; is_chain A; A \\<noteq> {};\n        \\<forall>x\\<in>A.\n           \\<forall>a xa.\n              (xa, a) \\<in> R \\<longrightarrow>\n              x xa \\<le> \\<Down> S (lfp body' a);\n        (x, a) \\<in> R\\<rbrakk>\n       \\<Longrightarrow> (SUP f\\<in>A. f x) \\<le> \\<Down> S (lfp body' a)\n 2. \\<And>a x.\n       trimono body' \\<Longrightarrow>\n       (x, a) \\<in> R \\<longrightarrow>\n       SUCCEED \\<le> \\<Down> S (lfp body' a)\n 3. trimono body' \\<Longrightarrow> mono body\n 4. trimono body' \\<Longrightarrow> (x, x') \\<in> R\n 5. \\<And>f a x.\n       \\<lbrakk>trimono body';\n        \\<And>a' x'.\n           (x', a') \\<in> R \\<Longrightarrow>\n           f x' \\<le> \\<Down> S (lfp body' a');\n        (x, a) \\<in> R; f \\<le> lfp body\\<rbrakk>\n       \\<Longrightarrow> body f x \\<le> \\<Down> S (lfp body' a)", "apply (blast intro: SUP_least)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a x.\n       trimono body' \\<Longrightarrow>\n       (x, a) \\<in> R \\<longrightarrow>\n       SUCCEED \\<le> \\<Down> S (lfp body' a)\n 2. trimono body' \\<Longrightarrow> mono body\n 3. trimono body' \\<Longrightarrow> (x, x') \\<in> R\n 4. \\<And>f a x.\n       \\<lbrakk>trimono body';\n        \\<And>a' x'.\n           (x', a') \\<in> R \\<Longrightarrow>\n           f x' \\<le> \\<Down> S (lfp body' a');\n        (x, a) \\<in> R; f \\<le> lfp body\\<rbrakk>\n       \\<Longrightarrow> body f x \\<le> \\<Down> S (lfp body' a)", "apply simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. trimono body' \\<Longrightarrow> mono body\n 2. trimono body' \\<Longrightarrow> (x, x') \\<in> R\n 3. \\<And>f a x.\n       \\<lbrakk>trimono body';\n        \\<And>a' x'.\n           (x', a') \\<in> R \\<Longrightarrow>\n           f x' \\<le> \\<Down> S (lfp body' a');\n        (x, a) \\<in> R; f \\<le> lfp body\\<rbrakk>\n       \\<Longrightarrow> body f x \\<le> \\<Down> S (lfp body' a)", "apply (simp add: trimonoD[OF M])"], ["proof (prove)\ngoal (2 subgoals):\n 1. trimono body' \\<Longrightarrow> (x, x') \\<in> R\n 2. \\<And>f a x.\n       \\<lbrakk>trimono body';\n        \\<And>a' x'.\n           (x', a') \\<in> R \\<Longrightarrow>\n           f x' \\<le> \\<Down> S (lfp body' a');\n        (x, a) \\<in> R; f \\<le> lfp body\\<rbrakk>\n       \\<Longrightarrow> body f x \\<le> \\<Down> S (lfp body' a)", "apply (rule R0)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f a x.\n       \\<lbrakk>trimono body';\n        \\<And>a' x'.\n           (x', a') \\<in> R \\<Longrightarrow>\n           f x' \\<le> \\<Down> S (lfp body' a');\n        (x, a) \\<in> R; f \\<le> lfp body\\<rbrakk>\n       \\<Longrightarrow> body f x \\<le> \\<Down> S (lfp body' a)", "apply (subst lfp_unfold, simp add: trimonoD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f a x.\n       \\<lbrakk>trimono body';\n        \\<And>a' x'.\n           (x', a') \\<in> R \\<Longrightarrow>\n           f x' \\<le> \\<Down> S (lfp body' a');\n        (x, a) \\<in> R; f \\<le> lfp body\\<rbrakk>\n       \\<Longrightarrow> body f x \\<le> \\<Down> S (body' (lfp body') a)", "apply (rule RS)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>f a x xa x'.\n       \\<lbrakk>trimono body';\n        \\<And>a' x'.\n           (x', a') \\<in> R \\<Longrightarrow>\n           f x' \\<le> \\<Down> S (lfp body' a');\n        (x, a) \\<in> R; f \\<le> lfp body; (xa, x') \\<in> R\\<rbrakk>\n       \\<Longrightarrow> f xa \\<le> \\<Down> S (lfp body' x')\n 2. \\<And>f a x.\n       \\<lbrakk>trimono body';\n        \\<And>a' x'.\n           (x', a') \\<in> R \\<Longrightarrow>\n           f x' \\<le> \\<Down> S (lfp body' a');\n        (x, a) \\<in> R; f \\<le> lfp body\\<rbrakk>\n       \\<Longrightarrow> (x, a) \\<in> R\n 3. \\<And>f a x.\n       \\<lbrakk>trimono body';\n        \\<And>a' x'.\n           (x', a') \\<in> R \\<Longrightarrow>\n           f x' \\<le> \\<Down> S (lfp body' a');\n        (x, a) \\<in> R; f \\<le> lfp body\\<rbrakk>\n       \\<Longrightarrow> REC body' = lfp body'", "apply blast"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>f a x.\n       \\<lbrakk>trimono body';\n        \\<And>a' x'.\n           (x', a') \\<in> R \\<Longrightarrow>\n           f x' \\<le> \\<Down> S (lfp body' a');\n        (x, a) \\<in> R; f \\<le> lfp body\\<rbrakk>\n       \\<Longrightarrow> (x, a) \\<in> R\n 2. \\<And>f a x.\n       \\<lbrakk>trimono body';\n        \\<And>a' x'.\n           (x', a') \\<in> R \\<Longrightarrow>\n           f x' \\<le> \\<Down> S (lfp body' a');\n        (x, a) \\<in> R; f \\<le> lfp body\\<rbrakk>\n       \\<Longrightarrow> REC body' = lfp body'", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f a x.\n       \\<lbrakk>trimono body';\n        \\<And>a' x'.\n           (x', a') \\<in> R \\<Longrightarrow>\n           f x' \\<le> \\<Down> S (lfp body' a');\n        (x, a) \\<in> R; f \\<le> lfp body\\<rbrakk>\n       \\<Longrightarrow> REC body' = lfp body'", "apply (simp add: REC_def[abs_def])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma RECT_refine[refine]:\n  assumes M: \"trimono body\"\n  assumes R0: \"(x,x')\\<in>R\"\n  assumes RS: \"\\<And>f f' x x'. \\<lbrakk> \\<And>x x'. (x,x')\\<in>R \\<Longrightarrow> f x \\<le>\\<Down>S (f' x'); (x,x')\\<in>R \\<rbrakk> \n    \\<Longrightarrow> body f x \\<le>\\<Down>S (body' f' x')\"\n  shows \"RECT (\\<lambda>f x. body f x) x \\<le>\\<Down>S (RECT (\\<lambda>f' x'. body' f' x') x')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. REC\\<^sub>T body x \\<le> \\<Down> S (REC\\<^sub>T body' x')", "unfolding RECT_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if trimono body then flatf_gfp body x else FAIL)\n    \\<le> \\<Down> S (if trimono body' then flatf_gfp body' x' else FAIL)", "apply (clarsimp simp add: M)"], ["proof (prove)\ngoal (1 subgoal):\n 1. trimono body' \\<Longrightarrow>\n    flatf_gfp body x \\<le> \\<Down> S (flatf_gfp body' x')", "apply (rule flatf_fixp_transfer[where \n        fp'=\"flatf_gfp body\" \n    and B'=body \n    and P=\"\\<lambda>x x'. (x',x)\\<in>R\", \n    OF _ _ flatf_ord.fixp_unfold[OF M[THEN trimonoD_flatf_ge]] R0])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x'. trimono body' \\<Longrightarrow> x' \\<le> \\<Down> S FAIL\n 2. trimono body' \\<Longrightarrow> flatf_mono FAIL body'\n 3. \\<And>f f' x x'.\n       \\<lbrakk>trimono body';\n        \\<And>x x'.\n           (x', x) \\<in> R \\<Longrightarrow> f' x' \\<le> \\<Down> S (f x);\n        (x', x) \\<in> R; flatf_gfp body = f'\\<rbrakk>\n       \\<Longrightarrow> body f' x' \\<le> \\<Down> S (body' f x)", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. trimono body' \\<Longrightarrow> flatf_mono FAIL body'\n 2. \\<And>f f' x x'.\n       \\<lbrakk>trimono body';\n        \\<And>x x'.\n           (x', x) \\<in> R \\<Longrightarrow> f' x' \\<le> \\<Down> S (f x);\n        (x', x) \\<in> R; flatf_gfp body = f'\\<rbrakk>\n       \\<Longrightarrow> body f' x' \\<le> \\<Down> S (body' f x)", "apply (simp add: trimonoD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f f' x x'.\n       \\<lbrakk>trimono body';\n        \\<And>x x'.\n           (x', x) \\<in> R \\<Longrightarrow> f' x' \\<le> \\<Down> S (f x);\n        (x', x) \\<in> R; flatf_gfp body = f'\\<rbrakk>\n       \\<Longrightarrow> body f' x' \\<le> \\<Down> S (body' f x)", "by (rule RS)"], ["", "lemma if_refine[refine]:\n  assumes \"b \\<longleftrightarrow> b'\"\n  assumes \"\\<lbrakk>b;b'\\<rbrakk> \\<Longrightarrow> S1 \\<le> \\<Down>R S1'\"\n  assumes \"\\<lbrakk>\\<not>b;\\<not>b'\\<rbrakk> \\<Longrightarrow> S2 \\<le> \\<Down>R S2'\"\n  shows \"(if b then S1 else S2) \\<le> \\<Down>R (if b' then S1' else S2')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if b then S1 else S2) \\<le> \\<Down> R (if b' then S1' else S2')", "using assms"], ["proof (prove)\nusing this:\n  b = b'\n  \\<lbrakk>b; b'\\<rbrakk> \\<Longrightarrow> S1 \\<le> \\<Down> R S1'\n  \\<lbrakk>\\<not> b; \\<not> b'\\<rbrakk>\n  \\<Longrightarrow> S2 \\<le> \\<Down> R S2'\n\ngoal (1 subgoal):\n 1. (if b then S1 else S2) \\<le> \\<Down> R (if b' then S1' else S2')", "by auto"], ["", "lemma Let_unfold_refine[refine]:\n  assumes \"f x \\<le> \\<Down>R (f' x')\"\n  shows \"Let x f \\<le> \\<Down>R (Let x' f')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Let x f \\<le> \\<Down> R (Let x' f')", "using assms"], ["proof (prove)\nusing this:\n  f x \\<le> \\<Down> R (f' x')\n\ngoal (1 subgoal):\n 1. Let x f \\<le> \\<Down> R (Let x' f')", "by auto"], ["", "text \\<open>The next lemma is sometimes more convenient, as it prevents\n  large let-expressions from exploding by being completely unfolded.\\<close>"], ["", "lemma Let_refine:\n  assumes \"(m,m')\\<in>R'\"\n  assumes \"\\<And>x x'. (x,x')\\<in>R' \\<Longrightarrow> f x \\<le> \\<Down>R (f' x')\"\n  shows \"Let m (\\<lambda>x. f x) \\<le>\\<Down>R (Let m' (\\<lambda>x'. f' x'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Let m f \\<le> \\<Down> R (Let m' f')", "using assms"], ["proof (prove)\nusing this:\n  (m, m') \\<in> R'\n  (?x, ?x') \\<in> R' \\<Longrightarrow> f ?x \\<le> \\<Down> R (f' ?x')\n\ngoal (1 subgoal):\n 1. Let m f \\<le> \\<Down> R (Let m' f')", "by auto"], ["", "lemma Let_refine':\n  assumes \"(m,m')\\<in>R\"\n  assumes \"(m,m')\\<in>R \\<Longrightarrow> f m \\<le>\\<Down>S (f' m')\"\n  shows \"Let m f \\<le> \\<Down>S (Let m' f')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Let m f \\<le> \\<Down> S (Let m' f')", "using assms"], ["proof (prove)\nusing this:\n  (m, m') \\<in> R\n  (m, m') \\<in> R \\<Longrightarrow> f m \\<le> \\<Down> S (f' m')\n\ngoal (1 subgoal):\n 1. Let m f \\<le> \\<Down> S (Let m' f')", "by simp"], ["", "lemma case_option_refine[refine]:\n  assumes \"(v,v')\\<in>\\<langle>Ra\\<rangle>option_rel\"\n  assumes \"\\<lbrakk>v=None; v'=None\\<rbrakk> \\<Longrightarrow> n \\<le> \\<Down> Rb n'\"\n  assumes \"\\<And>x x'. \\<lbrakk> v=Some x; v'=Some x'; (x, x') \\<in> Ra \\<rbrakk> \n    \\<Longrightarrow> f x \\<le> \\<Down> Rb (f' x')\"\n  shows \"case_option n f v \\<le>\\<Down>Rb (case_option n' f' v')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (case v of None \\<Rightarrow> n | Some x \\<Rightarrow> f x)\n    \\<le> \\<Down> Rb\n           (case v' of None \\<Rightarrow> n' | Some x \\<Rightarrow> f' x)", "using assms"], ["proof (prove)\nusing this:\n  (v, v') \\<in> \\<langle>Ra\\<rangle>option_rel\n  \\<lbrakk>v = None; v' = None\\<rbrakk>\n  \\<Longrightarrow> n \\<le> \\<Down> Rb n'\n  \\<lbrakk>v = Some ?x; v' = Some ?x'; (?x, ?x') \\<in> Ra\\<rbrakk>\n  \\<Longrightarrow> f ?x \\<le> \\<Down> Rb (f' ?x')\n\ngoal (1 subgoal):\n 1. (case v of None \\<Rightarrow> n | Some x \\<Rightarrow> f x)\n    \\<le> \\<Down> Rb\n           (case v' of None \\<Rightarrow> n' | Some x \\<Rightarrow> f' x)", "by (auto split: option.split simp: option_rel_def)"], ["", "lemma list_case_refine[refine]: \n  assumes \"(li,l)\\<in>\\<langle>S\\<rangle>list_rel\"\n  assumes \"fni \\<le>\\<Down>R fn\"  \n  assumes \"\\<And>xi x xsi xs. \\<lbrakk> (xi,x)\\<in>S; (xsi,xs)\\<in>\\<langle>S\\<rangle>list_rel; li=xi#xsi; l=x#xs \\<rbrakk> \\<Longrightarrow> fci xi xsi \\<le>\\<Down>R (fc x xs)\"  \n  shows \"(case li of [] \\<Rightarrow> fni | xi#xsi \\<Rightarrow> fci xi xsi) \\<le> \\<Down>R (case l of [] \\<Rightarrow> fn | x#xs \\<Rightarrow> fc x xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (case li of [] \\<Rightarrow> fni | xi # xsi \\<Rightarrow> fci xi xsi)\n    \\<le> \\<Down> R\n           (case l of [] \\<Rightarrow> fn | x # xs \\<Rightarrow> fc x xs)", "using assms"], ["proof (prove)\nusing this:\n  (li, l) \\<in> \\<langle>S\\<rangle>list_rel\n  fni \\<le> \\<Down> R fn\n  \\<lbrakk>(?xi, ?x) \\<in> S; (?xsi, ?xs) \\<in> \\<langle>S\\<rangle>list_rel;\n   li = ?xi # ?xsi; l = ?x # ?xs\\<rbrakk>\n  \\<Longrightarrow> fci ?xi ?xsi \\<le> \\<Down> R (fc ?x ?xs)\n\ngoal (1 subgoal):\n 1. (case li of [] \\<Rightarrow> fni | xi # xsi \\<Rightarrow> fci xi xsi)\n    \\<le> \\<Down> R\n           (case l of [] \\<Rightarrow> fn | x # xs \\<Rightarrow> fc x xs)", "by (auto split: list.split)"], ["", "text \\<open>It is safe to split conjunctions in refinement goals.\\<close>"], ["", "declare conjI[refine]"], ["", "text \\<open>The following rules try to compensate for some structural changes,\n  like inlining lets or converting binds to lets.\\<close>"], ["", "lemma remove_Let_refine[refine2]:\n  assumes \"M \\<le> \\<Down>R (f x)\"\n  shows \"M \\<le> \\<Down>R (Let x f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M \\<le> \\<Down> R (Let x f)", "using assms"], ["proof (prove)\nusing this:\n  M \\<le> \\<Down> R (f x)\n\ngoal (1 subgoal):\n 1. M \\<le> \\<Down> R (Let x f)", "by auto"], ["", "lemma intro_Let_refine[refine2]:\n  assumes \"f x \\<le> \\<Down>R M'\"\n  shows \"Let x f \\<le> \\<Down>R M'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Let x f \\<le> \\<Down> R M'", "using assms"], ["proof (prove)\nusing this:\n  f x \\<le> \\<Down> R M'\n\ngoal (1 subgoal):\n 1. Let x f \\<le> \\<Down> R M'", "by auto"], ["", "lemma bind2let_refine[refine2]:\n  assumes \"RETURN x \\<le> \\<Down>R' M'\"\n  assumes \"\\<And>x'. (x,x')\\<in>R' \\<Longrightarrow> f x \\<le> \\<Down>R (f' x')\"\n  shows \"Let x f \\<le> \\<Down>R (bind M' (\\<lambda>x'. f' x'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Let x f \\<le> \\<Down> R (M' \\<bind> f')", "using assms"], ["proof (prove)\nusing this:\n  RETURN x \\<le> \\<Down> R' M'\n  (x, ?x') \\<in> R' \\<Longrightarrow> f x \\<le> \\<Down> R (f' ?x')\n\ngoal (1 subgoal):\n 1. Let x f \\<le> \\<Down> R (M' \\<bind> f')", "apply (simp add: pw_le_iff refine_pw_simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>nofail M' \\<longrightarrow>\n             (\\<exists>s'. (x, s') \\<in> R' \\<and> inres M' s');\n     \\<And>x'.\n        (x, x') \\<in> R' \\<Longrightarrow>\n        nofail (f' x') \\<longrightarrow>\n        nofail (f x) \\<and>\n        (\\<forall>xa.\n            inres (f x) xa \\<longrightarrow>\n            (\\<exists>s'.\n                (xa, s') \\<in> R \\<and> inres (f' x') s'))\\<rbrakk>\n    \\<Longrightarrow> nofail M' \\<and>\n                      (\\<forall>x.\n                          inres M' x \\<longrightarrow>\n                          nofail (f' x)) \\<longrightarrow>\n                      nofail (f x) \\<and>\n                      (\\<forall>xa.\n                          inres (f x) xa \\<longrightarrow>\n                          (\\<exists>s'.\n                              (xa, s') \\<in> R \\<and>\n                              (\\<exists>y.\n                                  inres M' y \\<and> inres (f' y) s')))", "apply fast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma bind_Let_refine2[refine2]: \"\\<lbrakk> \n    m' \\<le>\\<Down>R' (RETURN x);\n    \\<And>x'. \\<lbrakk>inres m' x'; (x',x)\\<in>R'\\<rbrakk> \\<Longrightarrow> f' x' \\<le> \\<Down>R (f x) \n  \\<rbrakk> \\<Longrightarrow> m'\\<bind>(\\<lambda>x'. f' x') \\<le> \\<Down>R (Let x (\\<lambda>x. f x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>m' \\<le> \\<Down> R' (RETURN x);\n     \\<And>x'.\n        \\<lbrakk>inres m' x'; (x', x) \\<in> R'\\<rbrakk>\n        \\<Longrightarrow> f' x' \\<le> \\<Down> R (f x)\\<rbrakk>\n    \\<Longrightarrow> m' \\<bind> f' \\<le> \\<Down> R (Let x f)", "apply (simp add: pw_le_iff refine_pw_simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>nofail m' \\<and>\n             (\\<forall>xa. inres m' xa \\<longrightarrow> (xa, x) \\<in> R');\n     \\<And>x'.\n        inres m' x' \\<Longrightarrow>\n        nofail (f x) \\<longrightarrow>\n        nofail (f' x') \\<and>\n        (\\<forall>xa.\n            inres (f' x') xa \\<longrightarrow>\n            (\\<exists>s'. (xa, s') \\<in> R \\<and> inres (f x) s'))\\<rbrakk>\n    \\<Longrightarrow> nofail (f x) \\<longrightarrow>\n                      (\\<forall>xa.\n                          (\\<exists>y.\n                              inres m' y \\<and>\n                              inres (f' y) xa) \\<longrightarrow>\n                          (\\<exists>s'.\n                              (xa, s') \\<in> R \\<and> inres (f x) s'))", "apply blast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma bind2letRETURN_refine[refine2]:\n  assumes \"RETURN x \\<le> \\<Down>R' M'\"\n  assumes \"\\<And>x'. (x,x')\\<in>R' \\<Longrightarrow> RETURN (f x) \\<le> \\<Down>R (f' x')\"\n  shows \"RETURN (Let x f) \\<le> \\<Down>R (bind M' (\\<lambda>x'. f' x'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RETURN (Let x f) \\<le> \\<Down> R (M' \\<bind> f')", "using assms"], ["proof (prove)\nusing this:\n  RETURN x \\<le> \\<Down> R' M'\n  (x, ?x') \\<in> R' \\<Longrightarrow> RETURN (f x) \\<le> \\<Down> R (f' ?x')\n\ngoal (1 subgoal):\n 1. RETURN (Let x f) \\<le> \\<Down> R (M' \\<bind> f')", "apply (simp add: pw_le_iff refine_pw_simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>nofail M' \\<longrightarrow>\n             (\\<exists>s'. (x, s') \\<in> R' \\<and> inres M' s');\n     \\<And>x'.\n        (x, x') \\<in> R' \\<Longrightarrow>\n        nofail (f' x') \\<longrightarrow>\n        (\\<exists>s'. (f x, s') \\<in> R \\<and> inres (f' x') s')\\<rbrakk>\n    \\<Longrightarrow> nofail M' \\<and>\n                      (\\<forall>x.\n                          inres M' x \\<longrightarrow>\n                          nofail (f' x)) \\<longrightarrow>\n                      (\\<exists>s'.\n                          (f x, s') \\<in> R \\<and>\n                          (\\<exists>y. inres M' y \\<and> inres (f' y) s'))", "apply fast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma RETURN_as_SPEC_refine[refine2]:\n  assumes \"M \\<le> SPEC (\\<lambda>c. (c,a)\\<in>R)\"\n  shows \"M \\<le> \\<Down>R (RETURN a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M \\<le> \\<Down> R (RETURN a)", "using assms"], ["proof (prove)\nusing this:\n  M \\<le> SPEC (\\<lambda>c. (c, a) \\<in> R)\n\ngoal (1 subgoal):\n 1. M \\<le> \\<Down> R (RETURN a)", "by (simp add: pw_le_iff refine_pw_simps)"], ["", "lemma RETURN_as_SPEC_refine_old:\n  \"\\<And>M R. M \\<le> \\<Down>R (SPEC (\\<lambda>x. x=v)) \\<Longrightarrow> M \\<le>\\<Down>R (RETURN v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>M R.\n       M \\<le> \\<Down> R (SPEC (\\<lambda>x. x = v)) \\<Longrightarrow>\n       M \\<le> \\<Down> R (RETURN v)", "by (simp add: RETURN_def)"], ["", "lemma if_RETURN_refine [refine2]:\n  assumes \"b \\<longleftrightarrow> b'\"\n  assumes \"\\<lbrakk>b;b'\\<rbrakk> \\<Longrightarrow> RETURN S1 \\<le> \\<Down>R S1'\"\n  assumes \"\\<lbrakk>\\<not>b;\\<not>b'\\<rbrakk> \\<Longrightarrow> RETURN S2 \\<le> \\<Down>R S2'\"\n  shows \"RETURN (if b then S1 else S2) \\<le> \\<Down>R (if b' then S1' else S2')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RETURN (if b then S1 else S2) \\<le> \\<Down> R (if b' then S1' else S2')", "(* this is nice to have for small functions, hence keep it in refine2 *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. RETURN (if b then S1 else S2) \\<le> \\<Down> R (if b' then S1' else S2')", "using assms"], ["proof (prove)\nusing this:\n  b = b'\n  \\<lbrakk>b; b'\\<rbrakk> \\<Longrightarrow> RETURN S1 \\<le> \\<Down> R S1'\n  \\<lbrakk>\\<not> b; \\<not> b'\\<rbrakk>\n  \\<Longrightarrow> RETURN S2 \\<le> \\<Down> R S2'\n\ngoal (1 subgoal):\n 1. RETURN (if b then S1 else S2) \\<le> \\<Down> R (if b' then S1' else S2')", "by (simp add: pw_le_iff refine_pw_simps)"], ["", "lemma RES_sng_as_SPEC_refine[refine2]:\n  assumes \"M \\<le> SPEC (\\<lambda>c. (c,a)\\<in>R)\"\n  shows \"M \\<le> \\<Down>R (RES {a})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M \\<le> \\<Down> R (RES {a})", "using assms"], ["proof (prove)\nusing this:\n  M \\<le> SPEC (\\<lambda>c. (c, a) \\<in> R)\n\ngoal (1 subgoal):\n 1. M \\<le> \\<Down> R (RES {a})", "by (simp add: pw_le_iff refine_pw_simps)"], ["", "lemma intro_spec_refine_iff:\n  \"(bind (RES X) f \\<le> \\<Down>R M) \\<longleftrightarrow> (\\<forall>x\\<in>X. f x \\<le> \\<Down>R M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (RES X \\<bind> f \\<le> \\<Down> R M) =\n    (\\<forall>x\\<in>X. f x \\<le> \\<Down> R M)", "apply (simp add: pw_le_iff refine_pw_simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (nofail M \\<longrightarrow>\n     (\\<forall>x. x \\<in> X \\<longrightarrow> nofail (f x)) \\<and>\n     (\\<forall>x.\n         (\\<exists>y. y \\<in> X \\<and> inres (f y) x) \\<longrightarrow>\n         (\\<exists>s'. (x, s') \\<in> R \\<and> inres M s'))) =\n    (nofail M \\<longrightarrow>\n     (\\<forall>x\\<in>X.\n         nofail (f x) \\<and>\n         (\\<forall>xa.\n             inres (f x) xa \\<longrightarrow>\n             (\\<exists>s'. (xa, s') \\<in> R \\<and> inres M s'))))", "apply blast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma intro_spec_refine[refine2]:\n  assumes \"\\<And>x. x\\<in>X \\<Longrightarrow> f x \\<le> \\<Down>R M\"\n  shows \"bind (RES X) (\\<lambda>x. f x) \\<le> \\<Down>R M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RES X \\<bind> f \\<le> \\<Down> R M", "using assms"], ["proof (prove)\nusing this:\n  ?x \\<in> X \\<Longrightarrow> f ?x \\<le> \\<Down> R M\n\ngoal (1 subgoal):\n 1. RES X \\<bind> f \\<le> \\<Down> R M", "by (simp add: intro_spec_refine_iff)"], ["", "text \\<open>The following rules are intended for manual application, to reflect \n  some common structural changes, that, however, are not suited to be applied\n  automatically.\\<close>"], ["", "text \\<open>Replacing a let by a deterministic computation\\<close>"], ["", "lemma let2bind_refine:\n  assumes \"m \\<le> \\<Down>R' (RETURN m')\"\n  assumes \"\\<And>x x'. (x,x')\\<in>R' \\<Longrightarrow> f x \\<le> \\<Down>R (f' x')\"\n  shows \"bind m (\\<lambda>x. f x) \\<le> \\<Down>R (Let m' (\\<lambda>x'. f' x'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<bind> f \\<le> \\<Down> R (Let m' f')", "using assms"], ["proof (prove)\nusing this:\n  m \\<le> \\<Down> R' (RETURN m')\n  (?x, ?x') \\<in> R' \\<Longrightarrow> f ?x \\<le> \\<Down> R (f' ?x')\n\ngoal (1 subgoal):\n 1. m \\<bind> f \\<le> \\<Down> R (Let m' f')", "apply (simp add: pw_le_iff refine_pw_simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>nofail m \\<and>\n             (\\<forall>x. inres m x \\<longrightarrow> (x, m') \\<in> R');\n     \\<And>x x'.\n        (x, x') \\<in> R' \\<Longrightarrow>\n        nofail (f' x') \\<longrightarrow>\n        nofail (f x) \\<and>\n        (\\<forall>xa.\n            inres (f x) xa \\<longrightarrow>\n            (\\<exists>s'.\n                (xa, s') \\<in> R \\<and> inres (f' x') s'))\\<rbrakk>\n    \\<Longrightarrow> nofail (f' m') \\<longrightarrow>\n                      (\\<forall>x.\n                          inres m x \\<longrightarrow> nofail (f x)) \\<and>\n                      (\\<forall>x.\n                          (\\<exists>y.\n                              inres m y \\<and>\n                              inres (f y) x) \\<longrightarrow>\n                          (\\<exists>s'.\n                              (x, s') \\<in> R \\<and> inres (f' m') s'))", "apply blast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>Introduce a new binding, without a structural match in the abstract \n  program\\<close>"], ["", "lemma intro_bind_refine:\n  assumes \"m \\<le> \\<Down>R' (RETURN m')\"\n  assumes \"\\<And>x. (x,m')\\<in>R' \\<Longrightarrow> f x \\<le> \\<Down>R m''\"\n  shows \"bind m (\\<lambda>x. f x) \\<le> \\<Down>R m''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<bind> f \\<le> \\<Down> R m''", "using assms"], ["proof (prove)\nusing this:\n  m \\<le> \\<Down> R' (RETURN m')\n  (?x, m') \\<in> R' \\<Longrightarrow> f ?x \\<le> \\<Down> R m''\n\ngoal (1 subgoal):\n 1. m \\<bind> f \\<le> \\<Down> R m''", "apply (simp add: pw_le_iff refine_pw_simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>nofail m \\<and>\n             (\\<forall>x. inres m x \\<longrightarrow> (x, m') \\<in> R');\n     \\<And>x.\n        (x, m') \\<in> R' \\<Longrightarrow>\n        nofail m'' \\<longrightarrow>\n        nofail (f x) \\<and>\n        (\\<forall>xa.\n            inres (f x) xa \\<longrightarrow>\n            (\\<exists>s'. (xa, s') \\<in> R \\<and> inres m'' s'))\\<rbrakk>\n    \\<Longrightarrow> nofail m'' \\<longrightarrow>\n                      (\\<forall>x.\n                          (\\<exists>y.\n                              inres m y \\<and>\n                              inres (f y) x) \\<longrightarrow>\n                          (\\<exists>s'.\n                              (x, s') \\<in> R \\<and> inres m'' s'))", "apply blast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma intro_bind_refine_id:\n  assumes \"m \\<le> (SPEC ((=) m'))\"\n  assumes \"f m' \\<le> \\<Down>R m''\"\n  shows \"bind m f \\<le> \\<Down>R m''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<bind> f \\<le> \\<Down> R m''", "using assms"], ["proof (prove)\nusing this:\n  m \\<le> SPEC ((=) m')\n  f m' \\<le> \\<Down> R m''\n\ngoal (1 subgoal):\n 1. m \\<bind> f \\<le> \\<Down> R m''", "apply (simp add: pw_le_iff refine_pw_simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>nofail m \\<and>\n             (\\<forall>x. inres m x \\<longrightarrow> x = m');\n     nofail m'' \\<longrightarrow>\n     nofail (f m') \\<and>\n     (\\<forall>x.\n         inres (f m') x \\<longrightarrow>\n         (\\<exists>s'. (x, s') \\<in> R \\<and> inres m'' s'))\\<rbrakk>\n    \\<Longrightarrow> nofail m'' \\<longrightarrow>\n                      (\\<forall>x.\n                          inres m x \\<longrightarrow> nofail (f x)) \\<and>\n                      (\\<forall>x.\n                          (\\<exists>y.\n                              inres m y \\<and>\n                              inres (f y) x) \\<longrightarrow>\n                          (\\<exists>s'.\n                              (x, s') \\<in> R \\<and> inres m'' s'))", "apply blast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>The following set of rules executes a step on the LHS or RHS of \n  a refinement proof obligation, without changing the other side.\n  These kind of rules is useful for performing refinements with \n  invisible steps.\\<close>"], ["", "lemma lhs_step_If:\n  \"\\<lbrakk> b \\<Longrightarrow> t \\<le> m; \\<not>b \\<Longrightarrow> e \\<le> m \\<rbrakk> \\<Longrightarrow> If b t e \\<le> m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>b \\<Longrightarrow> t \\<le> m;\n     \\<not> b \\<Longrightarrow> e \\<le> m\\<rbrakk>\n    \\<Longrightarrow> (if b then t else e) \\<le> m", "by simp"], ["", "lemma lhs_step_RES:\n  \"\\<lbrakk> \\<And>x. x\\<in>X \\<Longrightarrow> RETURN x \\<le> m  \\<rbrakk> \\<Longrightarrow> RES X \\<le> m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x.\n        x \\<in> X \\<Longrightarrow> RETURN x \\<le> m) \\<Longrightarrow>\n    RES X \\<le> m", "by (simp add: pw_le_iff)"], ["", "lemma lhs_step_SPEC:\n  \"\\<lbrakk> \\<And>x. \\<Phi> x \\<Longrightarrow> RETURN x \\<le> m \\<rbrakk> \\<Longrightarrow> SPEC (\\<lambda>x. \\<Phi> x) \\<le> m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x. \\<Phi> x \\<Longrightarrow> RETURN x \\<le> m) \\<Longrightarrow>\n    SPEC \\<Phi> \\<le> m", "by (simp add: pw_le_iff)"], ["", "lemma lhs_step_bind:\n  fixes m :: \"'a nres\" and f :: \"'a \\<Rightarrow> 'b nres\"\n  assumes \"nofail m' \\<Longrightarrow> nofail m\"\n  assumes \"\\<And>x. nf_inres m x \\<Longrightarrow> f x \\<le> m'\"\n  shows \"do {x\\<leftarrow>m; f x} \\<le> m'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<bind> f \\<le> m'", "using assms"], ["proof (prove)\nusing this:\n  nofail m' \\<Longrightarrow> nofail m\n  nf_inres m ?x \\<Longrightarrow> f ?x \\<le> m'\n\ngoal (1 subgoal):\n 1. m \\<bind> f \\<le> m'", "by (simp add: pw_le_iff refine_pw_simps) blast"], ["", "lemma rhs_step_bind:\n  assumes \"m \\<le> \\<Down>R m'\" \"inres m x\" \"\\<And>x'. (x,x')\\<in>R \\<Longrightarrow> lhs \\<le>\\<Down>S (f' x')\"\n  shows \"lhs \\<le> \\<Down>S (m' \\<bind> f')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lhs \\<le> \\<Down> S (m' \\<bind> f')", "using assms"], ["proof (prove)\nusing this:\n  m \\<le> \\<Down> R m'\n  inres m x\n  (x, ?x') \\<in> R \\<Longrightarrow> lhs \\<le> \\<Down> S (f' ?x')\n\ngoal (1 subgoal):\n 1. lhs \\<le> \\<Down> S (m' \\<bind> f')", "by (simp add: pw_le_iff refine_pw_simps) blast"], ["", "lemma rhs_step_bind_RES:\n  assumes \"x'\\<in>X'\"\n  assumes \"m \\<le> \\<Down>R (f' x')\"\n  shows \"m \\<le> \\<Down>R (RES X' \\<bind> f')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<le> \\<Down> R (RES X' \\<bind> f')", "using assms"], ["proof (prove)\nusing this:\n  x' \\<in> X'\n  m \\<le> \\<Down> R (f' x')\n\ngoal (1 subgoal):\n 1. m \\<le> \\<Down> R (RES X' \\<bind> f')", "by (simp add: pw_le_iff refine_pw_simps) blast"], ["", "lemma rhs_step_bind_SPEC:\n  assumes \"\\<Phi> x'\"\n  assumes \"m \\<le> \\<Down>R (f' x')\"\n  shows \"m \\<le> \\<Down>R (SPEC \\<Phi> \\<bind> f')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<le> \\<Down> R (SPEC \\<Phi> \\<bind> f')", "using assms"], ["proof (prove)\nusing this:\n  \\<Phi> x'\n  m \\<le> \\<Down> R (f' x')\n\ngoal (1 subgoal):\n 1. m \\<le> \\<Down> R (SPEC \\<Phi> \\<bind> f')", "by (simp add: pw_le_iff refine_pw_simps) blast"], ["", "lemma RES_bind_choose:\n  assumes \"x\\<in>X\"\n  assumes \"m \\<le> f x\"\n  shows \"m \\<le> RES X \\<bind> f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<le> RES X \\<bind> f", "using assms"], ["proof (prove)\nusing this:\n  x \\<in> X\n  m \\<le> f x\n\ngoal (1 subgoal):\n 1. m \\<le> RES X \\<bind> f", "by (auto simp: pw_le_iff refine_pw_simps)"], ["", "lemma pw_RES_bind_choose: \n  \"nofail (RES X \\<bind> f) \\<longleftrightarrow> (\\<forall>x\\<in>X. nofail (f x))\"\n  \"inres (RES X \\<bind> f) y \\<longleftrightarrow> (\\<exists>x\\<in>X. inres (f x) y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nofail (RES X \\<bind> f) = (\\<forall>x\\<in>X. nofail (f x)) &&&\n    inres (RES X \\<bind> f) y = (\\<exists>x\\<in>X. inres (f x) y)", "by (auto simp: refine_pw_simps)"], ["", "lemma prod_case_refine:  \n  assumes \"(p',p)\\<in>R1\\<times>\\<^sub>rR2\"\n  assumes \"\\<And>x1' x2' x1 x2. \\<lbrakk> p'=(x1',x2'); p=(x1,x2); (x1',x1)\\<in>R1; (x2',x2)\\<in>R2\\<rbrakk> \\<Longrightarrow> f' x1' x2' \\<le> \\<Down>R (f x1 x2)\"\n  shows \"(case p' of (x1',x2') \\<Rightarrow> f' x1' x2') \\<le>\\<Down>R (case p of (x1,x2) \\<Rightarrow> f x1 x2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (case p' of (x1', x2') \\<Rightarrow> f' x1' x2')\n    \\<le> \\<Down> R (case p of (x1, x2) \\<Rightarrow> f x1 x2)", "using assms"], ["proof (prove)\nusing this:\n  (p', p) \\<in> R1 \\<times>\\<^sub>r R2\n  \\<lbrakk>p' = (?x1', ?x2'); p = (?x1.0, ?x2.0); (?x1', ?x1.0) \\<in> R1;\n   (?x2', ?x2.0) \\<in> R2\\<rbrakk>\n  \\<Longrightarrow> f' ?x1' ?x2' \\<le> \\<Down> R (f ?x1.0 ?x2.0)\n\ngoal (1 subgoal):\n 1. (case p' of (x1', x2') \\<Rightarrow> f' x1' x2')\n    \\<le> \\<Down> R (case p of (x1, x2) \\<Rightarrow> f x1 x2)", "by (auto split: prod.split)"], ["", "subsection \\<open>Relators\\<close>"], ["", "declare fun_relI[refine]"], ["", "definition nres_rel where \n  nres_rel_def_internal: \"nres_rel R \\<equiv> {(c,a). c \\<le> \\<Down>R a}\""], ["", "lemma nres_rel_def: \"\\<langle>R\\<rangle>nres_rel \\<equiv> {(c,a). c \\<le> \\<Down>R a}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>R\\<rangle>nres_rel \\<equiv> {(c, a). c \\<le> \\<Down> R a}", "by (simp add: nres_rel_def_internal relAPP_def)"], ["", "lemma nres_relD: \"(c,a)\\<in>\\<langle>R\\<rangle>nres_rel \\<Longrightarrow> c \\<le>\\<Down>R a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (c, a) \\<in> \\<langle>R\\<rangle>nres_rel \\<Longrightarrow>\n    c \\<le> \\<Down> R a", "by (simp add: nres_rel_def)"], ["", "lemma nres_relI[refine]: \"c \\<le>\\<Down>R a \\<Longrightarrow> (c,a)\\<in>\\<langle>R\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c \\<le> \\<Down> R a \\<Longrightarrow>\n    (c, a) \\<in> \\<langle>R\\<rangle>nres_rel", "by (simp add: nres_rel_def)"], ["", "lemma nres_rel_comp: \"\\<langle>A\\<rangle>nres_rel O \\<langle>B\\<rangle>nres_rel = \\<langle>A O B\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>A\\<rangle>nres_rel O \\<langle>B\\<rangle>nres_rel =\n    \\<langle>A O B\\<rangle>nres_rel", "by (auto simp: nres_rel_def conc_fun_chain[symmetric] conc_trans)"], ["", "lemma pw_nres_rel_iff: \"(a,b)\\<in>\\<langle>A\\<rangle>nres_rel \\<longleftrightarrow> nofail (\\<Down> A b) \\<longrightarrow> nofail a \\<and> (\\<forall>x. inres a x \\<longrightarrow> inres (\\<Down> A b) x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((a, b) \\<in> \\<langle>A\\<rangle>nres_rel) =\n    (nofail (\\<Down> A b) \\<longrightarrow>\n     nofail a \\<and>\n     (\\<forall>x. inres a x \\<longrightarrow> inres (\\<Down> A b) x))", "by (simp add: pw_le_iff nres_rel_def)"], ["", "lemma param_SUCCEED[param]: \"(SUCCEED,SUCCEED) \\<in> \\<langle>R\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (SUCCEED, SUCCEED) \\<in> \\<langle>R\\<rangle>nres_rel", "by (auto simp: nres_rel_def)"], ["", "lemma param_FAIL[param]: \"(FAIL,FAIL) \\<in> \\<langle>R\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (FAIL, FAIL) \\<in> \\<langle>R\\<rangle>nres_rel", "by (auto simp: nres_rel_def)"], ["", "lemma param_RES[param]:\n  \"(RES,RES) \\<in> \\<langle>R\\<rangle>set_rel \\<rightarrow> \\<langle>R\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (RES, RES)\n    \\<in> \\<langle>R\\<rangle>set_rel \\<rightarrow>\n          \\<langle>R\\<rangle>nres_rel", "unfolding set_rel_def nres_rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (RES, RES)\n    \\<in> {(A, B).\n           (\\<forall>x\\<in>A. \\<exists>y\\<in>B. (x, y) \\<in> R) \\<and>\n           (\\<forall>y\\<in>B.\n               \\<exists>x\\<in>A. (x, y) \\<in> R)} \\<rightarrow>\n          {(c, a). c \\<le> \\<Down> R a}", "by (fastforce intro: RES_refine)"], ["", "lemma param_RETURN[param]: \n  \"(RETURN,RETURN) \\<in> R \\<rightarrow> \\<langle>R\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (RETURN, RETURN) \\<in> R \\<rightarrow> \\<langle>R\\<rangle>nres_rel", "by (auto simp: nres_rel_def RETURN_refine)"], ["", "lemma param_bind[param]:\n  \"(bind,bind) \\<in> \\<langle>Ra\\<rangle>nres_rel \\<rightarrow> (Ra\\<rightarrow>\\<langle>Rb\\<rangle>nres_rel) \\<rightarrow> \\<langle>Rb\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<bind>), (\\<bind>))\n    \\<in> \\<langle>Ra\\<rangle>nres_rel \\<rightarrow>\n          (Ra \\<rightarrow> \\<langle>Rb\\<rangle>nres_rel) \\<rightarrow>\n          \\<langle>Rb\\<rangle>nres_rel", "by (auto simp: nres_rel_def intro: bind_refine dest: fun_relD)"], ["", "lemma param_ASSERT_bind[param]: \"\\<lbrakk> \n    (\\<Phi>,\\<Psi>) \\<in> bool_rel; \n    \\<lbrakk> \\<Phi>; \\<Psi> \\<rbrakk> \\<Longrightarrow> (f,g)\\<in>\\<langle>R\\<rangle>nres_rel\n  \\<rbrakk> \\<Longrightarrow> (ASSERT \\<Phi> \\<then> f, ASSERT \\<Psi> \\<then> g) \\<in> \\<langle>R\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<Phi>, \\<Psi>) \\<in> bool_rel;\n     \\<lbrakk>\\<Phi>; \\<Psi>\\<rbrakk>\n     \\<Longrightarrow> (f, g) \\<in> \\<langle>R\\<rangle>nres_rel\\<rbrakk>\n    \\<Longrightarrow> (ASSERT \\<Phi> \\<bind> (\\<lambda>_. f),\n                       ASSERT \\<Psi> \\<bind> (\\<lambda>_. g))\n                      \\<in> \\<langle>R\\<rangle>nres_rel", "by (auto intro: nres_relI)"], ["", "subsection \\<open>Autoref Setup\\<close>"], ["", "consts i_nres :: \"interface \\<Rightarrow> interface\""], ["", "lemmas [autoref_rel_intf] = REL_INTFI[of nres_rel i_nres]"], ["", "(*lemma id_nres[autoref_id_self]: \"ID_LIST \n  (l SUCCEED FAIL bind (REC::_ \\<Rightarrow> _ \\<Rightarrow> _ nres,1) (RECT::_ \\<Rightarrow> _ \\<Rightarrow> _ nres,1))\"\n  by simp_all\n*)\n(*definition [simp]: \"op_RETURN x \\<equiv> RETURN x\"\nlemma [autoref_op_pat_def]: \"RETURN x \\<equiv> op_RETURN x\" by simp\n*)"], ["", "definition [simp]: \"op_nres_ASSERT_bnd \\<Phi> m \\<equiv> do {ASSERT \\<Phi>; m}\""], ["", "lemma param_op_nres_ASSERT_bnd[param]:\n  assumes \"\\<Phi>' \\<Longrightarrow> \\<Phi>\"\n  assumes \"\\<lbrakk>\\<Phi>'; \\<Phi>\\<rbrakk> \\<Longrightarrow> (m,m')\\<in>\\<langle>R\\<rangle>nres_rel\"\n  shows \"(op_nres_ASSERT_bnd \\<Phi> m, op_nres_ASSERT_bnd \\<Phi>' m') \\<in> \\<langle>R\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (op_nres_ASSERT_bnd \\<Phi> m, op_nres_ASSERT_bnd \\<Phi>' m')\n    \\<in> \\<langle>R\\<rangle>nres_rel", "using assms"], ["proof (prove)\nusing this:\n  \\<Phi>' \\<Longrightarrow> \\<Phi>\n  \\<lbrakk>\\<Phi>'; \\<Phi>\\<rbrakk>\n  \\<Longrightarrow> (m, m') \\<in> \\<langle>R\\<rangle>nres_rel\n\ngoal (1 subgoal):\n 1. (op_nres_ASSERT_bnd \\<Phi> m, op_nres_ASSERT_bnd \\<Phi>' m')\n    \\<in> \\<langle>R\\<rangle>nres_rel", "by (auto simp: pw_le_iff refine_pw_simps nres_rel_def)"], ["", "context begin"], ["", "interpretation autoref_syn"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma id_ASSERT[autoref_op_pat_def]:\n  \"do {ASSERT \\<Phi>; m} \\<equiv> OP (op_nres_ASSERT_bnd \\<Phi>)$m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ASSERT \\<Phi> \\<bind> (\\<lambda>_. m) \\<equiv>\n    OP (op_nres_ASSERT_bnd \\<Phi>) $ m", "by simp"], ["", "definition [simp]: \"op_nres_ASSUME_bnd \\<Phi> m \\<equiv> do {ASSUME \\<Phi>; m}\""], ["", "lemma id_ASSUME[autoref_op_pat_def]:\n  \"do {ASSUME \\<Phi>; m} \\<equiv> OP (op_nres_ASSUME_bnd \\<Phi>)$m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ASSUME \\<Phi> \\<bind> (\\<lambda>_. m) \\<equiv>\n    OP (op_nres_ASSUME_bnd \\<Phi>) $ m", "by simp"], ["", "end"], ["", "lemma autoref_SUCCEED[autoref_rules]: \"(SUCCEED,SUCCEED) \\<in> \\<langle>R\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (SUCCEED, SUCCEED) \\<in> \\<langle>R\\<rangle>nres_rel", "by (auto simp: nres_rel_def)"], ["", "lemma autoref_FAIL[autoref_rules]: \"(FAIL,FAIL) \\<in> \\<langle>R\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (FAIL, FAIL) \\<in> \\<langle>R\\<rangle>nres_rel", "by (auto simp: nres_rel_def)"], ["", "lemma autoref_RETURN[autoref_rules]: \n  \"(RETURN,RETURN) \\<in> R \\<rightarrow> \\<langle>R\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (RETURN, RETURN) \\<in> R \\<rightarrow> \\<langle>R\\<rangle>nres_rel", "by (auto simp: nres_rel_def RETURN_refine)"], ["", "lemma autoref_bind[autoref_rules]: \n  \"(bind,bind) \\<in> \\<langle>R1\\<rangle>nres_rel \\<rightarrow> (R1\\<rightarrow>\\<langle>R2\\<rangle>nres_rel) \\<rightarrow> \\<langle>R2\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<bind>), (\\<bind>))\n    \\<in> \\<langle>R1\\<rangle>nres_rel \\<rightarrow>\n          (R1 \\<rightarrow> \\<langle>R2\\<rangle>nres_rel) \\<rightarrow>\n          \\<langle>R2\\<rangle>nres_rel", "apply (intro fun_relI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> \\<langle>R1\\<rangle>nres_rel;\n        (aa, a'a)\n        \\<in> R1 \\<rightarrow> \\<langle>R2\\<rangle>nres_rel\\<rbrakk>\n       \\<Longrightarrow> (a \\<bind> aa, a' \\<bind> a'a)\n                         \\<in> \\<langle>R2\\<rangle>nres_rel", "apply (rule nres_relI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> \\<langle>R1\\<rangle>nres_rel;\n        (aa, a'a)\n        \\<in> R1 \\<rightarrow> \\<langle>R2\\<rangle>nres_rel\\<rbrakk>\n       \\<Longrightarrow> a \\<bind> aa \\<le> \\<Down> R2 (a' \\<bind> a'a)", "apply (rule bind_refine)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> \\<langle>R1\\<rangle>nres_rel;\n        (aa, a'a)\n        \\<in> R1 \\<rightarrow> \\<langle>R2\\<rangle>nres_rel\\<rbrakk>\n       \\<Longrightarrow> a \\<le> \\<Down> (?R'4 a a' aa a'a) a'\n 2. \\<And>a a' aa a'a x x'.\n       \\<lbrakk>(a, a') \\<in> \\<langle>R1\\<rangle>nres_rel;\n        (aa, a'a) \\<in> R1 \\<rightarrow> \\<langle>R2\\<rangle>nres_rel;\n        (x, x') \\<in> ?R'4 a a' aa a'a\\<rbrakk>\n       \\<Longrightarrow> aa x \\<le> \\<Down> R2 (a'a x')", "apply (erule nres_relD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a x x'.\n       \\<lbrakk>(a, a') \\<in> \\<langle>R1\\<rangle>nres_rel;\n        (aa, a'a) \\<in> R1 \\<rightarrow> \\<langle>R2\\<rangle>nres_rel;\n        (x, x') \\<in> R1\\<rbrakk>\n       \\<Longrightarrow> aa x \\<le> \\<Down> R2 (a'a x')", "apply (erule (1) fun_relD[THEN nres_relD])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "context begin"], ["", "interpretation autoref_syn"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma autoref_ASSERT[autoref_rules]:\n  assumes \"\\<Phi> \\<Longrightarrow> (m',m)\\<in>\\<langle>R\\<rangle>nres_rel\"\n  shows \"(\n    m',\n    (OP (op_nres_ASSERT_bnd \\<Phi>) ::: \\<langle>R\\<rangle>nres_rel \\<rightarrow> \\<langle>R\\<rangle>nres_rel) $ m)\\<in>\\<langle>R\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (m',\n     (OP (op_nres_ASSERT_bnd \\<Phi>) :::\n      \\<langle>R\\<rangle>nres_rel \\<rightarrow>\n      \\<langle>R\\<rangle>nres_rel) $\n     m)\n    \\<in> \\<langle>R\\<rangle>nres_rel", "using assms"], ["proof (prove)\nusing this:\n  \\<Phi> \\<Longrightarrow> (m', m) \\<in> \\<langle>R\\<rangle>nres_rel\n\ngoal (1 subgoal):\n 1. (m',\n     (OP (op_nres_ASSERT_bnd \\<Phi>) :::\n      \\<langle>R\\<rangle>nres_rel \\<rightarrow>\n      \\<langle>R\\<rangle>nres_rel) $\n     m)\n    \\<in> \\<langle>R\\<rangle>nres_rel", "unfolding nres_rel_def"], ["proof (prove)\nusing this:\n  \\<Phi> \\<Longrightarrow> (m', m) \\<in> {(c, a). c \\<le> \\<Down> R a}\n\ngoal (1 subgoal):\n 1. (m',\n     (OP (op_nres_ASSERT_bnd \\<Phi>) :::\n      {(c, a). c \\<le> \\<Down> R a} \\<rightarrow>\n      {(c, a). c \\<le> \\<Down> R a}) $\n     m)\n    \\<in> {(c, a). c \\<le> \\<Down> R a}", "by (simp add: ASSERT_refine_right)"], ["", "lemma autoref_ASSUME[autoref_rules]:\n  assumes \"SIDE_PRECOND \\<Phi>\"\n  assumes \"\\<Phi> \\<Longrightarrow> (m',m)\\<in>\\<langle>R\\<rangle>nres_rel\"\n  shows \"(\n    m',\n    (OP (op_nres_ASSUME_bnd \\<Phi>) ::: \\<langle>R\\<rangle>nres_rel \\<rightarrow> \\<langle>R\\<rangle>nres_rel) $ m)\\<in>\\<langle>R\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (m',\n     (OP (op_nres_ASSUME_bnd \\<Phi>) :::\n      \\<langle>R\\<rangle>nres_rel \\<rightarrow>\n      \\<langle>R\\<rangle>nres_rel) $\n     m)\n    \\<in> \\<langle>R\\<rangle>nres_rel", "using assms"], ["proof (prove)\nusing this:\n  SIDE_PRECOND \\<Phi>\n  \\<Phi> \\<Longrightarrow> (m', m) \\<in> \\<langle>R\\<rangle>nres_rel\n\ngoal (1 subgoal):\n 1. (m',\n     (OP (op_nres_ASSUME_bnd \\<Phi>) :::\n      \\<langle>R\\<rangle>nres_rel \\<rightarrow>\n      \\<langle>R\\<rangle>nres_rel) $\n     m)\n    \\<in> \\<langle>R\\<rangle>nres_rel", "unfolding nres_rel_def"], ["proof (prove)\nusing this:\n  SIDE_PRECOND \\<Phi>\n  \\<Phi> \\<Longrightarrow> (m', m) \\<in> {(c, a). c \\<le> \\<Down> R a}\n\ngoal (1 subgoal):\n 1. (m',\n     (OP (op_nres_ASSUME_bnd \\<Phi>) :::\n      {(c, a). c \\<le> \\<Down> R a} \\<rightarrow>\n      {(c, a). c \\<le> \\<Down> R a}) $\n     m)\n    \\<in> {(c, a). c \\<le> \\<Down> R a}", "by (simp add: ASSUME_refine_right)"], ["", "lemma autoref_REC[autoref_rules]:\n  assumes \"(B,B')\\<in>(Ra\\<rightarrow>\\<langle>Rr\\<rangle>nres_rel) \\<rightarrow> Ra \\<rightarrow> \\<langle>Rr\\<rangle>nres_rel\"\n  assumes \"DEFER trimono B\"\n  shows \"(REC B,\n    (OP REC \n      ::: ((Ra\\<rightarrow>\\<langle>Rr\\<rangle>nres_rel) \\<rightarrow> Ra \\<rightarrow> \\<langle>Rr\\<rangle>nres_rel) \\<rightarrow> Ra \\<rightarrow> \\<langle>Rr\\<rangle>nres_rel)$B'\n    ) \\<in> Ra \\<rightarrow> \\<langle>Rr\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (REC B,\n     (OP REC :::\n      ((Ra \\<rightarrow> \\<langle>Rr\\<rangle>nres_rel) \\<rightarrow>\n       Ra \\<rightarrow> \\<langle>Rr\\<rangle>nres_rel) \\<rightarrow>\n      Ra \\<rightarrow> \\<langle>Rr\\<rangle>nres_rel) $\n     B')\n    \\<in> Ra \\<rightarrow> \\<langle>Rr\\<rangle>nres_rel", "apply (intro fun_relI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       (a, a') \\<in> Ra \\<Longrightarrow>\n       (REC B a,\n        ((OP REC :::\n          ((Ra \\<rightarrow> \\<langle>Rr\\<rangle>nres_rel) \\<rightarrow>\n           Ra \\<rightarrow> \\<langle>Rr\\<rangle>nres_rel) \\<rightarrow>\n          Ra \\<rightarrow> \\<langle>Rr\\<rangle>nres_rel) $\n         B')\n         a')\n       \\<in> \\<langle>Rr\\<rangle>nres_rel", "using assms"], ["proof (prove)\nusing this:\n  (B, B')\n  \\<in> (Ra \\<rightarrow> \\<langle>Rr\\<rangle>nres_rel) \\<rightarrow>\n        Ra \\<rightarrow> \\<langle>Rr\\<rangle>nres_rel\n  DEFER trimono B\n\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       (a, a') \\<in> Ra \\<Longrightarrow>\n       (REC B a,\n        ((OP REC :::\n          ((Ra \\<rightarrow> \\<langle>Rr\\<rangle>nres_rel) \\<rightarrow>\n           Ra \\<rightarrow> \\<langle>Rr\\<rangle>nres_rel) \\<rightarrow>\n          Ra \\<rightarrow> \\<langle>Rr\\<rangle>nres_rel) $\n         B')\n         a')\n       \\<in> \\<langle>Rr\\<rangle>nres_rel", "apply (auto simp: nres_rel_def intro!: REC_refine)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' f x x'.\n       \\<lbrakk>(a, a') \\<in> Ra;\n        (B, B')\n        \\<in> (Ra \\<rightarrow>\n               {(c, a). c \\<le> \\<Down> Rr a}) \\<rightarrow>\n              Ra \\<rightarrow> {(c, a). c \\<le> \\<Down> Rr a};\n        trimono B;\n        \\<forall>x x'.\n           (x, x') \\<in> Ra \\<longrightarrow>\n           f x \\<le> \\<Down> Rr (REC B' x');\n        (x, x') \\<in> Ra\\<rbrakk>\n       \\<Longrightarrow> B f x \\<le> \\<Down> Rr (B' (REC B') x')", "apply (simp add: fun_rel_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' f x x'.\n       \\<lbrakk>(a, a') \\<in> Ra;\n        \\<forall>a b.\n           (\\<forall>x\\<in>Ra.\n               case x of\n               (aa, a') \\<Rightarrow>\n                 a aa \\<le> \\<Down> Rr (b a')) \\<longrightarrow>\n           (\\<forall>x\\<in>Ra.\n               case x of\n               (aa, a') \\<Rightarrow> B a aa \\<le> \\<Down> Rr (B' b a'));\n        trimono B;\n        \\<forall>x x'.\n           (x, x') \\<in> Ra \\<longrightarrow>\n           f x \\<le> \\<Down> Rr (REC B' x');\n        (x, x') \\<in> Ra\\<rbrakk>\n       \\<Longrightarrow> B f x \\<le> \\<Down> Rr (B' (REC B') x')", "apply blast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "theorem param_RECT[param]:\n  assumes \"(B, B') \\<in> (Ra \\<rightarrow> \\<langle>Rr\\<rangle>nres_rel) \\<rightarrow> Ra \\<rightarrow> \\<langle>Rr\\<rangle>nres_rel\"\n    and \"trimono B\"\n  shows \"(REC\\<^sub>T B, REC\\<^sub>T B')\\<in> Ra \\<rightarrow> \\<langle>Rr\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (REC\\<^sub>T B, REC\\<^sub>T B')\n    \\<in> Ra \\<rightarrow> \\<langle>Rr\\<rangle>nres_rel", "apply (intro fun_relI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       (a, a') \\<in> Ra \\<Longrightarrow>\n       (REC\\<^sub>T B a, REC\\<^sub>T B' a')\n       \\<in> \\<langle>Rr\\<rangle>nres_rel", "using assms"], ["proof (prove)\nusing this:\n  (B, B')\n  \\<in> (Ra \\<rightarrow> \\<langle>Rr\\<rangle>nres_rel) \\<rightarrow>\n        Ra \\<rightarrow> \\<langle>Rr\\<rangle>nres_rel\n  trimono B\n\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       (a, a') \\<in> Ra \\<Longrightarrow>\n       (REC\\<^sub>T B a, REC\\<^sub>T B' a')\n       \\<in> \\<langle>Rr\\<rangle>nres_rel", "apply (auto simp: nres_rel_def intro!: RECT_refine)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' f f' x x'.\n       \\<lbrakk>(a, a') \\<in> Ra;\n        (B, B')\n        \\<in> (Ra \\<rightarrow>\n               {(c, a). c \\<le> \\<Down> Rr a}) \\<rightarrow>\n              Ra \\<rightarrow> {(c, a). c \\<le> \\<Down> Rr a};\n        trimono B;\n        \\<forall>x x'.\n           (x, x') \\<in> Ra \\<longrightarrow> f x \\<le> \\<Down> Rr (f' x');\n        (x, x') \\<in> Ra\\<rbrakk>\n       \\<Longrightarrow> B f x \\<le> \\<Down> Rr (B' f' x')", "apply (simp add: fun_rel_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' f f' x x'.\n       \\<lbrakk>(a, a') \\<in> Ra;\n        \\<forall>a b.\n           (\\<forall>x\\<in>Ra.\n               case x of\n               (aa, a') \\<Rightarrow>\n                 a aa \\<le> \\<Down> Rr (b a')) \\<longrightarrow>\n           (\\<forall>x\\<in>Ra.\n               case x of\n               (aa, a') \\<Rightarrow> B a aa \\<le> \\<Down> Rr (B' b a'));\n        trimono B;\n        \\<forall>x x'.\n           (x, x') \\<in> Ra \\<longrightarrow> f x \\<le> \\<Down> Rr (f' x');\n        (x, x') \\<in> Ra\\<rbrakk>\n       \\<Longrightarrow> B f x \\<le> \\<Down> Rr (B' f' x')", "apply blast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma autoref_RECT[autoref_rules]:\n  assumes \"(B,B') \\<in> (Ra\\<rightarrow>\\<langle>Rr\\<rangle>nres_rel) \\<rightarrow> Ra\\<rightarrow>\\<langle>Rr\\<rangle>nres_rel\"\n  assumes \"DEFER trimono B\"\n  shows \"(RECT B,\n    (OP RECT \n      ::: ((Ra\\<rightarrow>\\<langle>Rr\\<rangle>nres_rel) \\<rightarrow> Ra \\<rightarrow> \\<langle>Rr\\<rangle>nres_rel) \\<rightarrow> Ra \\<rightarrow> \\<langle>Rr\\<rangle>nres_rel)$B'\n    ) \\<in> Ra \\<rightarrow> \\<langle>Rr\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (REC\\<^sub>T B,\n     (OP REC\\<^sub>T :::\n      ((Ra \\<rightarrow> \\<langle>Rr\\<rangle>nres_rel) \\<rightarrow>\n       Ra \\<rightarrow> \\<langle>Rr\\<rangle>nres_rel) \\<rightarrow>\n      Ra \\<rightarrow> \\<langle>Rr\\<rangle>nres_rel) $\n     B')\n    \\<in> Ra \\<rightarrow> \\<langle>Rr\\<rangle>nres_rel", "using assms"], ["proof (prove)\nusing this:\n  (B, B')\n  \\<in> (Ra \\<rightarrow> \\<langle>Rr\\<rangle>nres_rel) \\<rightarrow>\n        Ra \\<rightarrow> \\<langle>Rr\\<rangle>nres_rel\n  DEFER trimono B\n\ngoal (1 subgoal):\n 1. (REC\\<^sub>T B,\n     (OP REC\\<^sub>T :::\n      ((Ra \\<rightarrow> \\<langle>Rr\\<rangle>nres_rel) \\<rightarrow>\n       Ra \\<rightarrow> \\<langle>Rr\\<rangle>nres_rel) \\<rightarrow>\n      Ra \\<rightarrow> \\<langle>Rr\\<rangle>nres_rel) $\n     B')\n    \\<in> Ra \\<rightarrow> \\<langle>Rr\\<rangle>nres_rel", "unfolding autoref_tag_defs"], ["proof (prove)\nusing this:\n  (B, B')\n  \\<in> (Ra \\<rightarrow> \\<langle>Rr\\<rangle>nres_rel) \\<rightarrow>\n        Ra \\<rightarrow> \\<langle>Rr\\<rangle>nres_rel\n  trimono B\n\ngoal (1 subgoal):\n 1. (REC\\<^sub>T B, REC\\<^sub>T B')\n    \\<in> Ra \\<rightarrow> \\<langle>Rr\\<rangle>nres_rel", "by (rule param_RECT)"], ["", "end"], ["", "subsection \\<open>Convenience Rules\\<close>"], ["", "text \\<open>\n  In this section, we define some lemmas that simplify common prover tasks.\n\\<close>"], ["", "lemma ref_two_step: \"A\\<le>\\<Down>R  B \\<Longrightarrow> B\\<le>C \\<Longrightarrow> A\\<le>\\<Down>R  C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<le> \\<Down> R B; B \\<le> C\\<rbrakk>\n    \\<Longrightarrow> A \\<le> \\<Down> R C", "by (rule conc_trans_additional)"], ["", "lemma pw_ref_iff:\n  shows \"S \\<le> \\<Down>R S' \n  \\<longleftrightarrow> (nofail S' \n    \\<longrightarrow> nofail S \\<and> (\\<forall>x. inres S x \\<longrightarrow> (\\<exists>s'. (x, s') \\<in> R \\<and> inres S' s')))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (S \\<le> \\<Down> R S') =\n    (nofail S' \\<longrightarrow>\n     nofail S \\<and>\n     (\\<forall>x.\n         inres S x \\<longrightarrow>\n         (\\<exists>s'. (x, s') \\<in> R \\<and> inres S' s')))", "by (simp add: pw_le_iff refine_pw_simps)"], ["", "lemma pw_ref_I:\n  assumes \"nofail S' \n    \\<longrightarrow> nofail S \\<and> (\\<forall>x. inres S x \\<longrightarrow> (\\<exists>s'. (x, s') \\<in> R \\<and> inres S' s'))\"\n  shows \"S \\<le> \\<Down>R S'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S \\<le> \\<Down> R S'", "using assms"], ["proof (prove)\nusing this:\n  nofail S' \\<longrightarrow>\n  nofail S \\<and>\n  (\\<forall>x.\n      inres S x \\<longrightarrow>\n      (\\<exists>s'. (x, s') \\<in> R \\<and> inres S' s'))\n\ngoal (1 subgoal):\n 1. S \\<le> \\<Down> R S'", "by (simp add: pw_ref_iff)"], ["", "text \\<open>Introduce an abstraction relation. Usage: \n  \\<open>rule introR[where R=absRel]\\<close>\n\\<close>"], ["", "lemma introR: \"(a,a')\\<in>R \\<Longrightarrow> (a,a')\\<in>R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a, a') \\<in> R \\<Longrightarrow> (a, a') \\<in> R", "."], ["", "lemma intro_prgR: \"c \\<le> \\<Down>R a \\<Longrightarrow> c \\<le> \\<Down>R a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c \\<le> \\<Down> R a \\<Longrightarrow> c \\<le> \\<Down> R a", "by auto"], ["", "lemma refine_IdI: \"m \\<le> m' \\<Longrightarrow> m \\<le> \\<Down>Id m'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<le> m' \\<Longrightarrow> m \\<le> \\<Down> Id m'", "by simp"], ["", "lemma le_ASSERTI_pres:\n  assumes \"\\<Phi> \\<Longrightarrow> S \\<le> do {ASSERT \\<Phi>; S'}\"\n  shows \"S \\<le> do {ASSERT \\<Phi>; S'}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S \\<le> ASSERT \\<Phi> \\<bind> (\\<lambda>_. S')", "using assms"], ["proof (prove)\nusing this:\n  \\<Phi> \\<Longrightarrow> S \\<le> ASSERT \\<Phi> \\<bind> (\\<lambda>_. S')\n\ngoal (1 subgoal):\n 1. S \\<le> ASSERT \\<Phi> \\<bind> (\\<lambda>_. S')", "by (auto intro: le_ASSERTI)"], ["", "lemma RETURN_ref_SPECD:\n  assumes \"RETURN c \\<le> \\<Down>R (SPEC \\<Phi>)\"\n  obtains a where \"(c,a)\\<in>R\" \"\\<Phi> a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>(c, a) \\<in> R; \\<Phi> a\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  RETURN c \\<le> \\<Down> R (SPEC \\<Phi>)\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>(c, a) \\<in> R; \\<Phi> a\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: pw_le_iff refine_pw_simps)"], ["", "lemma RETURN_ref_RETURND:\n  assumes \"RETURN c \\<le> \\<Down>R (RETURN a)\"\n  shows \"(c,a)\\<in>R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (c, a) \\<in> R", "using assms"], ["proof (prove)\nusing this:\n  RETURN c \\<le> \\<Down> R (RETURN a)\n\ngoal (1 subgoal):\n 1. (c, a) \\<in> R", "apply (auto simp: pw_le_iff refine_pw_simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma return_refine_prop_return:\n  assumes \"nofail m\"\n  assumes \"RETURN x \\<le> \\<Down>R m\"\n  obtains x' where \"(x,x')\\<in>R\" \"RETURN x' \\<le> m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x'.\n        \\<lbrakk>(x, x') \\<in> R; RETURN x' \\<le> m\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  nofail m\n  RETURN x \\<le> \\<Down> R m\n\ngoal (1 subgoal):\n 1. (\\<And>x'.\n        \\<lbrakk>(x, x') \\<in> R; RETURN x' \\<le> m\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: refine_pw_simps pw_le_iff)"], ["", "lemma ignore_snd_refine_conv: \n  \"(m \\<le> \\<Down>(R\\<times>\\<^sub>rUNIV) m') \\<longleftrightarrow> m\\<bind>(RETURN o fst) \\<le>\\<Down>R (m'\\<bind>(RETURN o fst))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (m \\<le> \\<Down> (R \\<times>\\<^sub>r UNIV) m') =\n    (m \\<bind> RETURN \\<circ> fst\n     \\<le> \\<Down> R (m' \\<bind> RETURN \\<circ> fst))", "by (auto simp: pw_le_iff refine_pw_simps)"], ["", "lemma ret_le_down_conv: \n  \"nofail m \\<Longrightarrow> RETURN c \\<le> \\<Down>R m \\<longleftrightarrow> (\\<exists>a. (c,a)\\<in>R \\<and> RETURN a \\<le> m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nofail m \\<Longrightarrow>\n    (RETURN c \\<le> \\<Down> R m) =\n    (\\<exists>a. (c, a) \\<in> R \\<and> RETURN a \\<le> m)", "by (auto simp: pw_le_iff refine_pw_simps)"], ["", "lemma SPEC_eq_is_RETURN:\n  \"SPEC ((=) x) = RETURN x\"\n  \"SPEC (\\<lambda>x. x=y) = RETURN y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SPEC ((=) x) = RETURN x &&& SPEC (\\<lambda>x. x = y) = RETURN y", "by (auto simp: RETURN_def)"], ["", "lemma RETURN_SPEC_conv: \"RETURN r = SPEC (\\<lambda>x. x=r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RETURN r = SPEC (\\<lambda>x. x = r)", "by (simp add: RETURN_def)"], ["", "lemma refine2spec_aux:\n  \"a \\<le> \\<Down>R b \\<longleftrightarrow> ( (nofail b \\<longrightarrow> a \\<le> SPEC ( \\<lambda>r. (\\<exists>x. inres b x \\<and> (r,x)\\<in>R) )) )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a \\<le> \\<Down> R b) =\n    (nofail b \\<longrightarrow>\n     a \\<le> SPEC (\\<lambda>r. \\<exists>x. inres b x \\<and> (r, x) \\<in> R))", "by (auto simp: pw_le_iff refine_pw_simps)"], ["", "lemma refine2specI:\n  assumes \"nofail b \\<Longrightarrow> a \\<le> SPEC (\\<lambda>r. (\\<exists>x. inres b x \\<and> (r,x)\\<in>R) )\"\n  shows \"a \\<le> \\<Down>R b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<le> \\<Down> R b", "using assms"], ["proof (prove)\nusing this:\n  nofail b \\<Longrightarrow>\n  a \\<le> SPEC (\\<lambda>r. \\<exists>x. inres b x \\<and> (r, x) \\<in> R)\n\ngoal (1 subgoal):\n 1. a \\<le> \\<Down> R b", "by (simp add: refine2spec_aux)"], ["", "lemma specify_left:\n  assumes \"m \\<le> SPEC \\<Phi>\"\n  assumes \"\\<And>x. \\<Phi> x \\<Longrightarrow> f x \\<le> M\"  \n  shows \"do { x \\<leftarrow> m; f x } \\<le> M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<bind> f \\<le> M", "using assms"], ["proof (prove)\nusing this:\n  m \\<le> SPEC \\<Phi>\n  \\<Phi> ?x \\<Longrightarrow> f ?x \\<le> M\n\ngoal (1 subgoal):\n 1. m \\<bind> f \\<le> M", "by (auto simp: pw_le_iff refine_pw_simps)"], ["", "lemma build_rel_SPEC: \n  \"M \\<le> SPEC ( \\<lambda>x. \\<Phi> (\\<alpha> x) \\<and> I x) \\<Longrightarrow> M \\<le> \\<Down>(build_rel \\<alpha> I) (SPEC \\<Phi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M \\<le> SPEC\n             (\\<lambda>x. \\<Phi> (\\<alpha> x) \\<and> I x) \\<Longrightarrow>\n    M \\<le> \\<Down> (br \\<alpha> I) (SPEC \\<Phi>)", "by (auto simp: pw_le_iff refine_pw_simps build_rel_def)"], ["", "lemma build_rel_SPEC_conv: \"\\<Down>(br \\<alpha> I) (SPEC \\<Phi>) = SPEC (\\<lambda>x. I x \\<and> \\<Phi> (\\<alpha> x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Down> (br \\<alpha> I) (SPEC \\<Phi>) =\n    SPEC (\\<lambda>x. I x \\<and> \\<Phi> (\\<alpha> x))", "by (auto simp: br_def pw_eq_iff refine_pw_simps)"], ["", "lemma refine_IdD: \"c \\<le> \\<Down>Id a \\<Longrightarrow> c \\<le> a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c \\<le> \\<Down> Id a \\<Longrightarrow> c \\<le> a", "by simp"], ["", "lemma bind_sim_select_rule:\n  assumes \"m\\<bind>f' \\<le> SPEC \\<Psi>\"\n  assumes \"\\<And>x. \\<lbrakk>nofail m; inres m x; f' x\\<le>SPEC \\<Psi>\\<rbrakk> \\<Longrightarrow> f x\\<le>SPEC \\<Phi>\"\n  shows \"m\\<bind>f \\<le> SPEC \\<Phi>\"\n  \\<comment> \\<open>Simultaneously select a result from assumption and verification goal.\n    Useful to work with assumptions that restrict the current program to \n    be verified.\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<bind> f \\<le> SPEC \\<Phi>", "using assms"], ["proof (prove)\nusing this:\n  m \\<bind> f' \\<le> SPEC \\<Psi>\n  \\<lbrakk>nofail m; inres m ?x; f' ?x \\<le> SPEC \\<Psi>\\<rbrakk>\n  \\<Longrightarrow> f ?x \\<le> SPEC \\<Phi>\n\ngoal (1 subgoal):\n 1. m \\<bind> f \\<le> SPEC \\<Phi>", "by (auto simp: pw_le_iff refine_pw_simps)"], ["", "lemma assert_bind_spec_conv: \"ASSERT \\<Phi> \\<then> m \\<le> SPEC \\<Psi> \\<longleftrightarrow> (\\<Phi> \\<and> m \\<le> SPEC \\<Psi>)\"  \n  \\<comment> \\<open>Simplify a bind-assert verification condition. \n    Useful if this occurs in the assumptions, and considerably faster than \n    using pointwise reasoning, which may causes a blowup for many chained \n    assertions.\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (ASSERT \\<Phi> \\<bind> (\\<lambda>_. m) \\<le> SPEC \\<Psi>) =\n    (\\<Phi> \\<and> m \\<le> SPEC \\<Psi>)", "by (auto simp: pw_le_iff refine_pw_simps)"], ["", "lemma summarize_ASSERT_conv: \"do {ASSERT \\<Phi>; ASSERT \\<Psi>; m} = do {ASSERT (\\<Phi> \\<and> \\<Psi>); m}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ASSERT \\<Phi> \\<bind>\n    (\\<lambda>_. ASSERT \\<Psi> \\<bind> (\\<lambda>_. m)) =\n    ASSERT (\\<Phi> \\<and> \\<Psi>) \\<bind> (\\<lambda>_. m)", "by (auto simp: pw_eq_iff refine_pw_simps)"], ["", "lemma bind_ASSERT_eq_if: \"do { ASSERT \\<Phi>; m } = (if \\<Phi> then m else FAIL)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ASSERT \\<Phi> \\<bind> (\\<lambda>_. m) = (if \\<Phi> then m else FAIL)", "by auto"], ["", "lemma le_RES_nofailI:\n  assumes \"a\\<le>RES x\"\n  shows \"nofail a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nofail a", "using assms"], ["proof (prove)\nusing this:\n  a \\<le> RES x\n\ngoal (1 subgoal):\n 1. nofail a", "by (metis nofail_simps(2) pwD1)"], ["", "lemma add_invar_refineI:\n  assumes \"f x \\<le>\\<Down>R (f' x')\"\n    and \"nofail (f x) \\<Longrightarrow> f x \\<le> SPEC I\"\n  shows \"f x \\<le> \\<Down> {(c, a). (c, a) \\<in> R \\<and> I c} (f' x')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f x \\<le> \\<Down> {(c, a). (c, a) \\<in> R \\<and> I c} (f' x')", "using assms"], ["proof (prove)\nusing this:\n  f x \\<le> \\<Down> R (f' x')\n  nofail (f x) \\<Longrightarrow> f x \\<le> SPEC I\n\ngoal (1 subgoal):\n 1. f x \\<le> \\<Down> {(c, a). (c, a) \\<in> R \\<and> I c} (f' x')", "by (simp add: pw_le_iff refine_pw_simps sv_add_invar)"], ["", "lemma bind_RES_RETURN_eq: \"bind (RES X) (\\<lambda>x. RETURN (f x)) = \n  RES { f x | x. x\\<in>X }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RES X \\<bind> (\\<lambda>x. RETURN (f x)) =\n    SPEC (\\<lambda>uu_. \\<exists>x. uu_ = f x \\<and> x \\<in> X)", "by (simp add: pw_eq_iff refine_pw_simps)\n    blast"], ["", "lemma bind_RES_RETURN2_eq: \"bind (RES X) (\\<lambda>(x,y). RETURN (f x y)) = \n  RES { f x y | x y. (x,y)\\<in>X }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RES X \\<bind> (\\<lambda>(x, y). RETURN (f x y)) =\n    SPEC (\\<lambda>uu_. \\<exists>x y. uu_ = f x y \\<and> (x, y) \\<in> X)", "apply (simp add: pw_eq_iff refine_pw_simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       (\\<exists>a b. (a, b) \\<in> X \\<and> f a b = x) =\n       (\\<exists>xa y. x = f xa y \\<and> (xa, y) \\<in> X)", "apply blast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma le_SPEC_bindI: \n  assumes \"\\<Phi> x\"\n  assumes \"m \\<le> f x\"\n  shows \"m \\<le> SPEC \\<Phi> \\<bind> f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<le> SPEC \\<Phi> \\<bind> f", "using assms"], ["proof (prove)\nusing this:\n  \\<Phi> x\n  m \\<le> f x\n\ngoal (1 subgoal):\n 1. m \\<le> SPEC \\<Phi> \\<bind> f", "by (auto simp add: pw_le_iff refine_pw_simps)"], ["", "lemma bind_assert_refine: \n  assumes \"m1 \\<le> SPEC \\<Phi>\"\n  assumes \"\\<And>x. \\<Phi> x \\<Longrightarrow> m2 x \\<le> m'\"\n  shows \"do {x\\<leftarrow>m1; ASSERT (\\<Phi> x); m2 x} \\<le> m'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m1 \\<bind> (\\<lambda>x. ASSERT (\\<Phi> x) \\<bind> (\\<lambda>_. m2 x))\n    \\<le> m'", "using assms"], ["proof (prove)\nusing this:\n  m1 \\<le> SPEC \\<Phi>\n  \\<Phi> ?x \\<Longrightarrow> m2 ?x \\<le> m'\n\ngoal (1 subgoal):\n 1. m1 \\<bind> (\\<lambda>x. ASSERT (\\<Phi> x) \\<bind> (\\<lambda>_. m2 x))\n    \\<le> m'", "by (simp add: pw_le_iff refine_pw_simps) blast"], ["", "lemma RETURN_refine_iff[simp]: \"RETURN x \\<le>\\<Down>R (RETURN y) \\<longleftrightarrow> (x,y)\\<in>R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (RETURN x \\<le> \\<Down> R (RETURN y)) = ((x, y) \\<in> R)", "by (auto simp: pw_le_iff refine_pw_simps)"], ["", "lemma RETURN_RES_refine_iff: \n  \"RETURN x \\<le>\\<Down>R (RES Y) \\<longleftrightarrow> (\\<exists>y\\<in>Y. (x,y)\\<in>R)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (RETURN x \\<le> \\<Down> R (RES Y)) = (\\<exists>y\\<in>Y. (x, y) \\<in> R)", "by (auto simp: pw_le_iff refine_pw_simps)"], ["", "lemma RETURN_RES_refine:\n  assumes \"\\<exists>x'. (x,x')\\<in>R \\<and> x'\\<in>X\"\n  shows \"RETURN x \\<le> \\<Down>R (RES X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RETURN x \\<le> \\<Down> R (RES X)", "using assms"], ["proof (prove)\nusing this:\n  \\<exists>x'. (x, x') \\<in> R \\<and> x' \\<in> X\n\ngoal (1 subgoal):\n 1. RETURN x \\<le> \\<Down> R (RES X)", "by (auto simp: pw_le_iff refine_pw_simps)"], ["", "lemma in_nres_rel_iff: \"(a,b)\\<in>\\<langle>R\\<rangle>nres_rel \\<longleftrightarrow> a \\<le>\\<Down>R b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((a, b) \\<in> \\<langle>R\\<rangle>nres_rel) = (a \\<le> \\<Down> R b)", "by (auto simp: nres_rel_def)"], ["", "lemma inf_RETURN_RES: \n  \"inf (RETURN x) (RES X) = (if x\\<in>X then RETURN x else SUCCEED)\"\n  \"inf (RES X) (RETURN x) = (if x\\<in>X then RETURN x else SUCCEED)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inf (RETURN x) (RES X) = (if x \\<in> X then RETURN x else SUCCEED) &&&\n    inf (RES X) (RETURN x) = (if x \\<in> X then RETURN x else SUCCEED)", "by (auto simp: pw_eq_iff refine_pw_simps)"], ["", "lemma inf_RETURN_SPEC[simp]:\n  \"inf (RETURN x) (SPEC (\\<lambda>y. \\<Phi> y)) = SPEC (\\<lambda>y. y=x \\<and> \\<Phi> x)\"\n  \"inf (SPEC (\\<lambda>y. \\<Phi> y)) (RETURN x) = SPEC (\\<lambda>y. y=x \\<and> \\<Phi> x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inf (RETURN x) (SPEC \\<Phi>) =\n    SPEC (\\<lambda>y. y = x \\<and> \\<Phi> x) &&&\n    inf (SPEC \\<Phi>) (RETURN x) = SPEC (\\<lambda>y. y = x \\<and> \\<Phi> x)", "by (auto simp: pw_eq_iff refine_pw_simps)"], ["", "lemma RES_sng_eq_RETURN: \"RES {x} = RETURN x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RES {x} = RETURN x", "by simp"], ["", "lemma nofail_inf_serialize:\n  \"\\<lbrakk>nofail a; nofail b\\<rbrakk> \\<Longrightarrow> inf a b = do {x\\<leftarrow>a; ASSUME (inres b x); RETURN x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>nofail a; nofail b\\<rbrakk>\n    \\<Longrightarrow> inf a b =\n                      a \\<bind>\n                      (\\<lambda>x.\n                          ASSUME (inres b x) \\<bind> (\\<lambda>_. RETURN x))", "by (auto simp: pw_eq_iff refine_pw_simps)"], ["", "lemma conc_fun_SPEC: \n  \"\\<Down>R (SPEC (\\<lambda>x. \\<Phi> x)) = SPEC (\\<lambda>y. \\<exists>x. (y,x)\\<in>R \\<and> \\<Phi> x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Down> R (SPEC \\<Phi>) =\n    SPEC (\\<lambda>y. \\<exists>x. (y, x) \\<in> R \\<and> \\<Phi> x)", "by (auto simp: pw_eq_iff refine_pw_simps)"], ["", "lemma conc_fun_RETURN: \n  \"\\<Down>R (RETURN x) = SPEC (\\<lambda>y. (y,x)\\<in>R)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Down> R (RETURN x) = SPEC (\\<lambda>y. (y, x) \\<in> R)", "by (auto simp: pw_eq_iff refine_pw_simps)"], ["", "lemma use_spec_rule:\n  assumes \"m \\<le> SPEC \\<Psi>\"\n  assumes \"m \\<le> SPEC (\\<lambda>s. \\<Psi> s \\<longrightarrow> \\<Phi> s)\"\n  shows \"m \\<le> SPEC \\<Phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<le> SPEC \\<Phi>", "using assms"], ["proof (prove)\nusing this:\n  m \\<le> SPEC \\<Psi>\n  m \\<le> SPEC (\\<lambda>s. \\<Psi> s \\<longrightarrow> \\<Phi> s)\n\ngoal (1 subgoal):\n 1. m \\<le> SPEC \\<Phi>", "by (auto simp: pw_le_iff refine_pw_simps)"], ["", "lemma strengthen_SPEC: \"m \\<le> SPEC \\<Phi> \\<Longrightarrow> m \\<le> SPEC(\\<lambda>s. inres m s \\<and> nofail m \\<and> \\<Phi> s)\"\n  \\<comment> \\<open>Strengthen SPEC by adding trivial upper bound for result\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<le> SPEC \\<Phi> \\<Longrightarrow>\n    m \\<le> SPEC (\\<lambda>s. inres m s \\<and> nofail m \\<and> \\<Phi> s)", "by (auto simp: pw_le_iff refine_pw_simps)"], ["", "lemma weaken_SPEC:\n  \"m \\<le> SPEC \\<Phi> \\<Longrightarrow> (\\<And>x. \\<Phi> x \\<Longrightarrow> \\<Psi> x) \\<Longrightarrow> m \\<le> SPEC \\<Psi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>m \\<le> SPEC \\<Phi>;\n     \\<And>x. \\<Phi> x \\<Longrightarrow> \\<Psi> x\\<rbrakk>\n    \\<Longrightarrow> m \\<le> SPEC \\<Psi>", "by (force elim!: order_trans)"], ["", "lemma bind_le_nofailI:\n  assumes \"nofail m\"\n  assumes \"\\<And>x. RETURN x \\<le> m \\<Longrightarrow> f x \\<le> m'\"\n  shows \"m\\<bind>f \\<le> m'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<bind> f \\<le> m'", "using assms"], ["proof (prove)\nusing this:\n  nofail m\n  RETURN ?x \\<le> m \\<Longrightarrow> f ?x \\<le> m'\n\ngoal (1 subgoal):\n 1. m \\<bind> f \\<le> m'", "by (simp add: refine_pw_simps pw_le_iff) blast"], ["", "lemma bind_le_shift:\n  \"bind m f \\<le> m' \n  \\<longleftrightarrow> m \\<le> (if nofail m' then SPEC (\\<lambda>x. f x \\<le> m') else FAIL)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (m \\<bind> f \\<le> m') =\n    (m \\<le> (if nofail m' then SPEC (\\<lambda>x. f x \\<le> m') else FAIL))", "by (auto simp: pw_le_iff refine_pw_simps)"], ["", "lemma If_bind_distrib[simp]:\n  fixes t e :: \"'a nres\"\n  shows \"(If b t e \\<bind> (\\<lambda>x. f x)) = (If b (t\\<bind>(\\<lambda>x. f x)) (e\\<bind>(\\<lambda>x. f x)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if b then t else e) \\<bind> f =\n    (if b then t \\<bind> f else e \\<bind> f)", "by simp"], ["", "(* TODO: Can we make this a simproc, using NO_MATCH? *)"], ["", "lemma unused_bind_conv: \n  assumes \"NO_MATCH (ASSERT \\<Phi>) m\"\n  assumes \"NO_MATCH (ASSUME \\<Phi>) m\"\n  shows \"(m\\<bind>(\\<lambda>x. c))  = (ASSERT (nofail m) \\<bind> (\\<lambda>_. ASSUME (\\<exists>x. inres m x) \\<bind> (\\<lambda>x. c)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<bind> (\\<lambda>x. c) =\n    ASSERT (nofail m) \\<bind>\n    (\\<lambda>_. ASSUME (\\<exists>x. inres m x) \\<bind> (\\<lambda>x. c))", "by (auto simp: pw_eq_iff refine_pw_simps)"], ["", "text \\<open>The following rules are useful for massaging programs before the \n  refinement takes place\\<close>"], ["", "lemma let_to_bind_conv: \n  \"Let x f = RETURN x\\<bind>f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Let x f = RETURN x \\<bind> f", "by simp"], ["", "lemmas bind_to_let_conv = let_to_bind_conv[symmetric]"], ["", "lemma pull_out_let_conv: \"RETURN (Let x f) = Let x (\\<lambda>x. RETURN (f x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RETURN (Let x f) = (let x = x in RETURN (f x))", "by simp"], ["", "lemma push_in_let_conv: \n  \"Let x (\\<lambda>x. RETURN (f x)) = RETURN (Let x f)\"\n  \"Let x (RETURN o f) = RETURN (Let x f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (let x = x in RETURN (f x)) = RETURN (Let x f) &&&\n    Let x (RETURN \\<circ> f) = RETURN (Let x f)", "by simp_all"], ["", "lemma pull_out_RETURN_case_option: \n  \"case_option (RETURN a) (\\<lambda>v. RETURN (f v)) x = RETURN (case_option a f x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (case x of None \\<Rightarrow> RETURN a\n     | Some v \\<Rightarrow> RETURN (f v)) =\n    RETURN (case x of None \\<Rightarrow> a | Some x \\<Rightarrow> f x)", "by (auto split: option.splits)"], ["", "lemma if_bind_cond_refine: \n  assumes \"ci \\<le> RETURN b\"\n  assumes \"b \\<Longrightarrow> ti\\<le>\\<Down>R t\"\n  assumes \"\\<not>b \\<Longrightarrow> ei\\<le>\\<Down>R e\"\n  shows \"do {b\\<leftarrow>ci; if b then ti else ei} \\<le> \\<Down>R (if b then t else e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ci \\<bind> (\\<lambda>b. if b then ti else ei)\n    \\<le> \\<Down> R (if b then t else e)", "using assms"], ["proof (prove)\nusing this:\n  ci \\<le> RETURN b\n  b \\<Longrightarrow> ti \\<le> \\<Down> R t\n  \\<not> b \\<Longrightarrow> ei \\<le> \\<Down> R e\n\ngoal (1 subgoal):\n 1. ci \\<bind> (\\<lambda>b. if b then ti else ei)\n    \\<le> \\<Down> R (if b then t else e)", "by (auto simp add: refine_pw_simps pw_le_iff)"], ["", "lemma intro_RETURN_Let_refine:\n  assumes \"RETURN (f x) \\<le> \\<Down>R M'\"\n  shows \"RETURN (Let x f) \\<le> \\<Down>R M'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RETURN (Let x f) \\<le> \\<Down> R M'", "(* this should be needed very rarely - so don't add it *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. RETURN (Let x f) \\<le> \\<Down> R M'", "using assms"], ["proof (prove)\nusing this:\n  RETURN (f x) \\<le> \\<Down> R M'\n\ngoal (1 subgoal):\n 1. RETURN (Let x f) \\<le> \\<Down> R M'", "by auto"], ["", "lemma ife_FAIL_to_ASSERT_cnv: \n  \"(if \\<Phi> then m else FAIL) = op_nres_ASSERT_bnd \\<Phi> m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if \\<Phi> then m else FAIL) = op_nres_ASSERT_bnd \\<Phi> m", "by (cases \\<Phi>, auto)"], ["", "lemma nres_bind_let_law: \"(do { x \\<leftarrow> do { let y=v; f y }; g x } :: _ nres)\n  = do { let y=v; x\\<leftarrow> f y; g x }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Let v f \\<bind> g = (let y = v in f y \\<bind> g)", "by auto"], ["", "lemma unused_bind_RES_ne[simp]: \"X\\<noteq>{} \\<Longrightarrow> do { _ \\<leftarrow> RES X; m} = m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> RES X \\<bind> (\\<lambda>_. m) = m", "by (auto simp: pw_eq_iff refine_pw_simps)"], ["", "lemma le_ASSERT_defI1:\n  assumes \"c \\<equiv> do {ASSERT \\<Phi>; m}\"\n  assumes \"\\<Phi> \\<Longrightarrow> m' \\<le> c\"\n  shows \"m' \\<le> c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m' \\<le> c", "using assms"], ["proof (prove)\nusing this:\n  c \\<equiv> ASSERT \\<Phi> \\<bind> (\\<lambda>_. m)\n  \\<Phi> \\<Longrightarrow> m' \\<le> c\n\ngoal (1 subgoal):\n 1. m' \\<le> c", "by (simp add: le_ASSERTI)"], ["", "lemma refine_ASSERT_defI1:\n  assumes \"c \\<equiv> do {ASSERT \\<Phi>; m}\"\n  assumes \"\\<Phi> \\<Longrightarrow> m' \\<le> \\<Down>R c\"\n  shows \"m' \\<le> \\<Down>R c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m' \\<le> \\<Down> R c", "using assms"], ["proof (prove)\nusing this:\n  c \\<equiv> ASSERT \\<Phi> \\<bind> (\\<lambda>_. m)\n  \\<Phi> \\<Longrightarrow> m' \\<le> \\<Down> R c\n\ngoal (1 subgoal):\n 1. m' \\<le> \\<Down> R c", "by (simp, refine_vcg)"], ["", "lemma le_ASSERT_defI2:\n  assumes \"c \\<equiv> do {ASSERT \\<Phi>; ASSERT \\<Psi>; m}\"\n  assumes \"\\<lbrakk>\\<Phi>; \\<Psi>\\<rbrakk> \\<Longrightarrow> m' \\<le> c\"\n  shows \"m' \\<le> c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m' \\<le> c", "using assms"], ["proof (prove)\nusing this:\n  c \\<equiv>\n  ASSERT \\<Phi> \\<bind> (\\<lambda>_. ASSERT \\<Psi> \\<bind> (\\<lambda>_. m))\n  \\<lbrakk>\\<Phi>; \\<Psi>\\<rbrakk> \\<Longrightarrow> m' \\<le> c\n\ngoal (1 subgoal):\n 1. m' \\<le> c", "by (simp add: le_ASSERTI)"], ["", "lemma refine_ASSERT_defI2:\n  assumes \"c \\<equiv> do {ASSERT \\<Phi>; ASSERT \\<Psi>; m}\"\n  assumes \"\\<lbrakk>\\<Phi>; \\<Psi>\\<rbrakk> \\<Longrightarrow> m' \\<le> \\<Down>R c\"\n  shows \"m' \\<le> \\<Down>R c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m' \\<le> \\<Down> R c", "using assms"], ["proof (prove)\nusing this:\n  c \\<equiv>\n  ASSERT \\<Phi> \\<bind> (\\<lambda>_. ASSERT \\<Psi> \\<bind> (\\<lambda>_. m))\n  \\<lbrakk>\\<Phi>; \\<Psi>\\<rbrakk> \\<Longrightarrow> m' \\<le> \\<Down> R c\n\ngoal (1 subgoal):\n 1. m' \\<le> \\<Down> R c", "by (simp, refine_vcg)"], ["", "lemma ASSERT_le_defI:\n  assumes \"c \\<equiv> do { ASSERT \\<Phi>; m'}\"\n  assumes \"\\<Phi>\"\n  assumes \"\\<Phi> \\<Longrightarrow> m' \\<le> m\"\n  shows \"c \\<le> m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c \\<le> m", "using assms"], ["proof (prove)\nusing this:\n  c \\<equiv> ASSERT \\<Phi> \\<bind> (\\<lambda>_. m')\n  \\<Phi>\n  \\<Phi> \\<Longrightarrow> m' \\<le> m\n\ngoal (1 subgoal):\n 1. c \\<le> m", "by (auto)"], ["", "lemma ASSERT_same_eq_conv: \"(ASSERT \\<Phi> \\<then> m) = (ASSERT \\<Phi> \\<then> n) \\<longleftrightarrow> (\\<Phi> \\<longrightarrow> m=n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ASSERT \\<Phi> \\<bind> (\\<lambda>_. m) =\n     ASSERT \\<Phi> \\<bind> (\\<lambda>_. n)) =\n    (\\<Phi> \\<longrightarrow> m = n)", "by auto"], ["", "lemma case_prod_bind_simp[simp]: \"\n  (\\<lambda>x. (case x of (a, b) \\<Rightarrow> f a b) \\<le> SPEC \\<Phi>) = (\\<lambda>(a,b). f a b \\<le> SPEC \\<Phi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. (case x of (a, b) \\<Rightarrow> f a b) \\<le> SPEC \\<Phi>) =\n    (\\<lambda>(a, b). f a b \\<le> SPEC \\<Phi>)", "by auto"], ["", "lemma RECT_eq_REC': \"nofail (RECT B x) \\<Longrightarrow> RECT B x = REC B x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nofail (REC\\<^sub>T B x) \\<Longrightarrow> REC\\<^sub>T B x = REC B x", "by (subst RECT_eq_REC; simp_all add: nofail_def)"], ["", "lemma rel2p_nres_RETURN[rel2p]: \"rel2p (\\<langle>A\\<rangle>nres_rel) (RETURN x) (RETURN y) = rel2p A x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel2p (\\<langle>A\\<rangle>nres_rel) (RETURN x) (RETURN y) = rel2p A x y", "by (auto simp: rel2p_def dest: nres_relD intro: nres_relI)"], ["", "subsubsection \\<open>Boolean Operations on Specifications\\<close>"], ["", "lemma SPEC_iff:\n  assumes \"P \\<le> SPEC (\\<lambda>s. Q s \\<longrightarrow> R s)\"\n  and \"P \\<le> SPEC (\\<lambda>s. \\<not> Q s \\<longrightarrow> \\<not> R s)\"\n  shows \"P \\<le> SPEC (\\<lambda>s. Q s \\<longleftrightarrow> R s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<le> SPEC (\\<lambda>s. Q s = R s)", "using assms[THEN pw_le_iff[THEN iffD1]]"], ["proof (prove)\nusing this:\n  nofail (SPEC (\\<lambda>s. Q s \\<longrightarrow> R s)) \\<longrightarrow>\n  nofail P \\<and>\n  (\\<forall>x.\n      inres P x \\<longrightarrow>\n      inres (SPEC (\\<lambda>s. Q s \\<longrightarrow> R s)) x)\n  nofail\n   (SPEC\n     (\\<lambda>s.\n         \\<not> Q s \\<longrightarrow> \\<not> R s)) \\<longrightarrow>\n  nofail P \\<and>\n  (\\<forall>x.\n      inres P x \\<longrightarrow>\n      inres (SPEC (\\<lambda>s. \\<not> Q s \\<longrightarrow> \\<not> R s)) x)\n\ngoal (1 subgoal):\n 1. P \\<le> SPEC (\\<lambda>s. Q s = R s)", "by (auto intro!: pw_leI)"], ["", "lemma SPEC_rule_conjI:\n  assumes \"A \\<le> SPEC P\" and \"A \\<le> SPEC Q\"\n    shows \"A \\<le> SPEC (\\<lambda>v. P v \\<and> Q v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<le> SPEC (\\<lambda>v. P v \\<and> Q v)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. A \\<le> SPEC (\\<lambda>v. P v \\<and> Q v)", "have \"A \\<le> inf (SPEC P) (SPEC Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<le> inf (SPEC P) (SPEC Q)", "using assms"], ["proof (prove)\nusing this:\n  A \\<le> SPEC P\n  A \\<le> SPEC Q\n\ngoal (1 subgoal):\n 1. A \\<le> inf (SPEC P) (SPEC Q)", "by (rule_tac inf_greatest) assumption"], ["proof (state)\nthis:\n  A \\<le> inf (SPEC P) (SPEC Q)\n\ngoal (1 subgoal):\n 1. A \\<le> SPEC (\\<lambda>v. P v \\<and> Q v)", "thus ?thesis"], ["proof (prove)\nusing this:\n  A \\<le> inf (SPEC P) (SPEC Q)\n\ngoal (1 subgoal):\n 1. A \\<le> SPEC (\\<lambda>v. P v \\<and> Q v)", "by (auto simp add:Collect_conj_eq)"], ["proof (state)\nthis:\n  A \\<le> SPEC (\\<lambda>v. P v \\<and> Q v)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma SPEC_rule_conjunct1:\n  assumes \"A \\<le> SPEC (\\<lambda>v. P v \\<and> Q v)\"\n    shows \"A \\<le> SPEC P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<le> SPEC P", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. A \\<le> SPEC P", "note assms"], ["proof (state)\nthis:\n  A \\<le> SPEC (\\<lambda>v. P v \\<and> Q v)\n\ngoal (1 subgoal):\n 1. A \\<le> SPEC P", "also"], ["proof (state)\nthis:\n  A \\<le> SPEC (\\<lambda>v. P v \\<and> Q v)\n\ngoal (1 subgoal):\n 1. A \\<le> SPEC P", "have \"\\<dots> \\<le> SPEC P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SPEC (\\<lambda>v. P v \\<and> Q v) \\<le> SPEC P", "by (rule SPEC_rule) auto"], ["proof (state)\nthis:\n  SPEC (\\<lambda>v. P v \\<and> Q v) \\<le> SPEC P\n\ngoal (1 subgoal):\n 1. A \\<le> SPEC P", "finally"], ["proof (chain)\npicking this:\n  A \\<le> SPEC P", "show ?thesis"], ["proof (prove)\nusing this:\n  A \\<le> SPEC P\n\ngoal (1 subgoal):\n 1. A \\<le> SPEC P", "."], ["proof (state)\nthis:\n  A \\<le> SPEC P\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma SPEC_rule_conjunct2:\n  assumes \"A \\<le> SPEC (\\<lambda>v. P v \\<and> Q v)\"\n    shows \"A \\<le> SPEC Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<le> SPEC Q", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. A \\<le> SPEC Q", "note assms"], ["proof (state)\nthis:\n  A \\<le> SPEC (\\<lambda>v. P v \\<and> Q v)\n\ngoal (1 subgoal):\n 1. A \\<le> SPEC Q", "also"], ["proof (state)\nthis:\n  A \\<le> SPEC (\\<lambda>v. P v \\<and> Q v)\n\ngoal (1 subgoal):\n 1. A \\<le> SPEC Q", "have \"\\<dots> \\<le> SPEC Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SPEC (\\<lambda>v. P v \\<and> Q v) \\<le> SPEC Q", "by (rule SPEC_rule) auto"], ["proof (state)\nthis:\n  SPEC (\\<lambda>v. P v \\<and> Q v) \\<le> SPEC Q\n\ngoal (1 subgoal):\n 1. A \\<le> SPEC Q", "finally"], ["proof (chain)\npicking this:\n  A \\<le> SPEC Q", "show ?thesis"], ["proof (prove)\nusing this:\n  A \\<le> SPEC Q\n\ngoal (1 subgoal):\n 1. A \\<le> SPEC Q", "."], ["proof (state)\nthis:\n  A \\<le> SPEC Q\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>Pointwise Reasoning\\<close>"], ["", "lemma inres_if:\n  \"\\<lbrakk> inres (if P then Q else R) x; \\<lbrakk>P; inres Q x\\<rbrakk> \\<Longrightarrow> S; \\<lbrakk>\\<not> P; inres R x\\<rbrakk> \\<Longrightarrow> S \\<rbrakk> \\<Longrightarrow> S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>inres (if P then Q else R) x;\n     \\<lbrakk>P; inres Q x\\<rbrakk> \\<Longrightarrow> S;\n     \\<lbrakk>\\<not> P; inres R x\\<rbrakk> \\<Longrightarrow> S\\<rbrakk>\n    \\<Longrightarrow> S", "by (metis (full_types))"], ["", "lemma inres_SPEC:\n  \"inres M x \\<Longrightarrow> M \\<le> SPEC \\<Phi> \\<Longrightarrow> \\<Phi> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>inres M x; M \\<le> SPEC \\<Phi>\\<rbrakk>\n    \\<Longrightarrow> \\<Phi> x", "by (auto dest: pwD2)"], ["", "lemma SPEC_nofail:\n  \"X \\<le> SPEC \\<Phi> \\<Longrightarrow> nofail X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X \\<le> SPEC \\<Phi> \\<Longrightarrow> nofail X", "by (auto dest: pwD1)"], ["", "lemma nofail_SPEC: \"nofail m \\<Longrightarrow> m \\<le> SPEC (\\<lambda>_. True)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nofail m \\<Longrightarrow> m \\<le> SPEC (\\<lambda>_. True)", "by (simp add: pw_le_iff)"], ["", "lemma nofail_SPEC_iff: \"nofail m \\<longleftrightarrow> m \\<le> SPEC (\\<lambda>_. True)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nofail m = (m \\<le> SPEC (\\<lambda>_. True))", "by (simp add: pw_le_iff)"], ["", "lemma nofail_SPEC_triv_refine: \"\\<lbrakk> nofail m; \\<And>x. \\<Phi> x \\<rbrakk> \\<Longrightarrow> m \\<le> SPEC \\<Phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>nofail m; \\<And>x. \\<Phi> x\\<rbrakk>\n    \\<Longrightarrow> m \\<le> SPEC \\<Phi>", "by (simp add: pw_le_iff)"], ["", "end"]]}