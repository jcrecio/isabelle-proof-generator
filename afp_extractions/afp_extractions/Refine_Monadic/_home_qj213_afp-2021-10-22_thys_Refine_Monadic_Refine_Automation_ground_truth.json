{"file_name": "/home/qj213/afp-2021-10-22/thys/Refine_Monadic/Refine_Automation.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Refine_Monadic", "problem_names": ["lemma gen_code_thm_RECT:\n  fixes x\n  assumes D: \"f \\<equiv> RECT B\"\n  assumes M: \"trimono B\"\n  shows \"f x \\<equiv> B f x\"", "lemma gen_code_thm_REC:\n  fixes x\n  assumes D: \"f \\<equiv> REC B\"\n  assumes M: \"trimono B\"\n  shows \"f x \\<equiv> B f x\""], "translations": [["", "lemma gen_code_thm_RECT:\n  fixes x\n  assumes D: \"f \\<equiv> RECT B\"\n  assumes M: \"trimono B\"\n  shows \"f x \\<equiv> B f x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f x \\<equiv> B f x", "unfolding D"], ["proof (prove)\ngoal (1 subgoal):\n 1. REC\\<^sub>T B x \\<equiv> B (REC\\<^sub>T B) x", "apply (subst RECT_unfold)"], ["proof (prove)\ngoal (2 subgoals):\n 1. trimono B\n 2. B (REC\\<^sub>T B) x \\<equiv> B (REC\\<^sub>T B) x", "by (rule M)"], ["", "lemma gen_code_thm_REC:\n  fixes x\n  assumes D: \"f \\<equiv> REC B\"\n  assumes M: \"trimono B\"\n  shows \"f x \\<equiv> B f x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f x \\<equiv> B f x", "unfolding D"], ["proof (prove)\ngoal (1 subgoal):\n 1. REC B x \\<equiv> B (REC B) x", "apply (subst REC_unfold)"], ["proof (prove)\ngoal (2 subgoals):\n 1. trimono B\n 2. B (REC B) x \\<equiv> B (REC B) x", "by (rule M)"], ["", "setup \\<open>\n  Refine_Automation.add_extraction \"nres\" {\n    pattern = Logic.varify_global @{term \"REC x\"},\n    gen_thm = @{thm gen_code_thm_REC},\n    gen_tac = Refine_Mono_Prover.mono_tac\n  }\n  #> \n  Refine_Automation.add_extraction \"nres\" {\n    pattern = Logic.varify_global @{term \"RECT x\"},\n    gen_thm = @{thm gen_code_thm_RECT},\n    gen_tac = Refine_Mono_Prover.mono_tac\n  }\n\\<close>"], ["", "text \\<open>\n  Method \\<open>vc_solve (no_pre) clasimp_modifiers\n    rec (add/del): ... solve (add/del): ...\\<close>\n  Named theorems \\<open>vcs_rec\\<close> and \\<open>vcs_solve\\<close>.\n\n  This method is specialized to\n  solve verification conditions. It first clarsimps all goals, then\n  it tries to apply a set of safe introduction rules (\\<open>vcs_rec\\<close>, \\<open>rec add\\<close>).\n  Finally, it applies introduction rules (\\<open>vcs_solve\\<close>, \\<open>solve add\\<close>) and tries\n  to discharge all emerging subgoals by auto. If this does not succeed, it\n  backtracks over the application of the solve-rule.\n\\<close>"], ["", "method_setup vc_solve = \n  \\<open>Scan.lift (Args.mode \"nopre\") \n      --| Method.sections Refine_Automation.vc_solve_modifiers >>\n  (fn (nopre) => fn ctxt => SIMPLE_METHOD (\n    CHANGED (ALLGOALS (Refine_Automation.vc_solve_tac ctxt nopre))\n  ))\\<close> \"Try to solve verification conditions\""], ["", "end"]]}