{"file_name": "/home/qj213/afp-2021-10-22/thys/Refine_Monadic/Refine_More_Comb.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Refine_Monadic", "problem_names": ["lemma OBTAIN_nofail[refine_pw_simps]: \"nofail (OBTAIN P) \\<longleftrightarrow> (\\<exists>x. P x)\"", "lemma OBTAIN_inres[refine_pw_simps]: \"inres (OBTAIN P) x \\<longleftrightarrow> (\\<forall>x. \\<not>P x) \\<or> P x\"", "lemma OBTAIN_rule[refine_vcg]: \"\\<lbrakk> \\<exists>x. P x; \\<And>x. P x \\<Longrightarrow> Q x  \\<rbrakk> \\<Longrightarrow> OBTAIN P \\<le> SPEC Q\"", "lemma OBTAIN_refine_iff: \"OBTAIN P \\<le>\\<Down>R (OBTAIN Q) \\<longleftrightarrow> (Ex Q \\<longrightarrow> Ex P \\<and> Collect P \\<subseteq> R\\<inverse>``Collect Q)\"", "lemma OBTAIN_refine[refine]:\n  assumes \"RELATES R\"\n  assumes \"\\<And>x. Q x \\<Longrightarrow> Ex P\"\n  assumes \"\\<And>x y. \\<lbrakk>Q x; P y\\<rbrakk> \\<Longrightarrow> \\<exists>x'. (y,x')\\<in>R \\<and> Q x'\"\n  shows \"OBTAIN P \\<le>\\<Down>R (OBTAIN Q)\"", "lemma SELECT_rule[refine_vcg]:\n  assumes \"\\<And>x. P x \\<Longrightarrow> Q (Some x)\"\n  assumes \"\\<forall>x. \\<not>P x \\<Longrightarrow> Q None\"\n  shows \"SELECT P \\<le> SPEC Q\"", "lemma SELECT_refine_iff: \"(SELECT P \\<le>\\<Down>(\\<langle>R\\<rangle>option_rel) (SELECT P')) \n  \\<longleftrightarrow> (  \n    (Ex P' \\<longrightarrow> Ex P) \\<and>\n    (\\<forall>x. P x \\<longrightarrow> (\\<exists>x'. (x,x')\\<in>R \\<and> P' x'))\n  )\"", "lemma SELECT_refine[refine]:\n  assumes \"RELATES R\"\n  assumes \"\\<And>x'. P' x' \\<Longrightarrow> \\<exists>x. P x\"\n  assumes \"\\<And>x. P x \\<Longrightarrow> \\<exists>x'. (x,x')\\<in>R \\<and> P' x'\"\n  shows \"SELECT P \\<le>\\<Down>(\\<langle>R\\<rangle>option_rel) (SELECT P')\"", "lemma SELECT_as_SPEC: \"SELECT P = SPEC (\\<lambda>None \\<Rightarrow> \\<forall>x. \\<not>P x | Some x \\<Rightarrow> P x)\"", "lemma SELECT_pw[refine_pw_simps]:\n  \"nofail (SELECT P)\"  \n  \"inres (SELECT P) r \\<longleftrightarrow> (r=None \\<longrightarrow> (\\<forall>x. \\<not>P x)) \\<and> (\\<forall>x. r=Some x \\<longrightarrow> P x)\"", "lemma SELECT_pw_simps[simp]:\n  \"nofail (SELECT P)\"\n  \"inres (SELECT P) None \\<longleftrightarrow> (\\<forall>x. \\<not>P x)\"\n  \"inres (SELECT P) (Some x) \\<longleftrightarrow> P x\""], "translations": [["", "lemma OBTAIN_nofail[refine_pw_simps]: \"nofail (OBTAIN P) \\<longleftrightarrow> (\\<exists>x. P x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nofail (OBTAIN P) = (\\<exists>x. P x)", "unfolding OBTAIN_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. nofail (ASSERT (\\<exists>x. P x) \\<bind> (\\<lambda>_. SPEC P)) =\n    (\\<exists>x. P x)", "by (auto simp: refine_pw_simps)"], ["", "lemma OBTAIN_inres[refine_pw_simps]: \"inres (OBTAIN P) x \\<longleftrightarrow> (\\<forall>x. \\<not>P x) \\<or> P x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inres (OBTAIN P) x = ((\\<forall>x. \\<not> P x) \\<or> P x)", "unfolding OBTAIN_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. inres (ASSERT (\\<exists>x. P x) \\<bind> (\\<lambda>_. SPEC P)) x =\n    ((\\<forall>x. \\<not> P x) \\<or> P x)", "by (auto simp: refine_pw_simps)"], ["", "lemma OBTAIN_rule[refine_vcg]: \"\\<lbrakk> \\<exists>x. P x; \\<And>x. P x \\<Longrightarrow> Q x  \\<rbrakk> \\<Longrightarrow> OBTAIN P \\<le> SPEC Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<exists>x. P x; \\<And>x. P x \\<Longrightarrow> Q x\\<rbrakk>\n    \\<Longrightarrow> OBTAIN P \\<le> SPEC Q", "unfolding OBTAIN_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<exists>x. P x; \\<And>x. P x \\<Longrightarrow> Q x\\<rbrakk>\n    \\<Longrightarrow> ASSERT (\\<exists>x. P x) \\<bind> (\\<lambda>_. SPEC P)\n                      \\<le> SPEC Q", "by auto"], ["", "lemma OBTAIN_refine_iff: \"OBTAIN P \\<le>\\<Down>R (OBTAIN Q) \\<longleftrightarrow> (Ex Q \\<longrightarrow> Ex P \\<and> Collect P \\<subseteq> R\\<inverse>``Collect Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (OBTAIN P \\<le> \\<Down> R (OBTAIN Q)) =\n    (Ex Q \\<longrightarrow>\n     Ex P \\<and> Collect P \\<subseteq> R\\<inverse> `` Collect Q)", "unfolding OBTAIN_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (ASSERT (\\<exists>x. P x) \\<bind> (\\<lambda>_. SPEC P)\n     \\<le> \\<Down> R\n            (ASSERT (\\<exists>x. Q x) \\<bind> (\\<lambda>_. SPEC Q))) =\n    (Ex Q \\<longrightarrow>\n     Ex P \\<and> Collect P \\<subseteq> R\\<inverse> `` Collect Q)", "by (auto simp: pw_le_iff refine_pw_simps)"], ["", "lemma OBTAIN_refine[refine]:\n  assumes \"RELATES R\"\n  assumes \"\\<And>x. Q x \\<Longrightarrow> Ex P\"\n  assumes \"\\<And>x y. \\<lbrakk>Q x; P y\\<rbrakk> \\<Longrightarrow> \\<exists>x'. (y,x')\\<in>R \\<and> Q x'\"\n  shows \"OBTAIN P \\<le>\\<Down>R (OBTAIN Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. OBTAIN P \\<le> \\<Down> R (OBTAIN Q)", "using assms"], ["proof (prove)\nusing this:\n  RELATES R\n  Q ?x \\<Longrightarrow> Ex P\n  \\<lbrakk>Q ?x; P ?y\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x'. (?y, x') \\<in> R \\<and> Q x'\n\ngoal (1 subgoal):\n 1. OBTAIN P \\<le> \\<Down> R (OBTAIN Q)", "unfolding OBTAIN_refine_iff"], ["proof (prove)\nusing this:\n  RELATES R\n  Q ?x \\<Longrightarrow> Ex P\n  \\<lbrakk>Q ?x; P ?y\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x'. (?y, x') \\<in> R \\<and> Q x'\n\ngoal (1 subgoal):\n 1. Ex Q \\<longrightarrow>\n    Ex P \\<and> Collect P \\<subseteq> R\\<inverse> `` Collect Q", "by blast"], ["", "subsubsection \\<open>SELECT Combinator\\<close>"], ["", "text \\<open>Select some value with given property, or \\<open>None\\<close> if there is none.\\<close>"], ["", "definition SELECT :: \"('a \\<Rightarrow> bool) \\<Rightarrow> 'a option nres\"\n  where \"SELECT P \\<equiv> if \\<exists>x. P x then RES {Some x| x. P x} else RETURN None\""], ["", "lemma SELECT_rule[refine_vcg]:\n  assumes \"\\<And>x. P x \\<Longrightarrow> Q (Some x)\"\n  assumes \"\\<forall>x. \\<not>P x \\<Longrightarrow> Q None\"\n  shows \"SELECT P \\<le> SPEC Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SELECT P \\<le> SPEC Q", "unfolding SELECT_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if \\<exists>x. P x\n     then SPEC (\\<lambda>uu_. \\<exists>x. uu_ = Some x \\<and> P x)\n     else RETURN None)\n    \\<le> SPEC Q", "using assms"], ["proof (prove)\nusing this:\n  P ?x \\<Longrightarrow> Q (Some ?x)\n  \\<forall>x. \\<not> P x \\<Longrightarrow> Q None\n\ngoal (1 subgoal):\n 1. (if \\<exists>x. P x\n     then SPEC (\\<lambda>uu_. \\<exists>x. uu_ = Some x \\<and> P x)\n     else RETURN None)\n    \\<le> SPEC Q", "by auto"], ["", "lemma SELECT_refine_iff: \"(SELECT P \\<le>\\<Down>(\\<langle>R\\<rangle>option_rel) (SELECT P')) \n  \\<longleftrightarrow> (  \n    (Ex P' \\<longrightarrow> Ex P) \\<and>\n    (\\<forall>x. P x \\<longrightarrow> (\\<exists>x'. (x,x')\\<in>R \\<and> P' x'))\n  )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (SELECT P \\<le> \\<Down> (\\<langle>R\\<rangle>option_rel) (SELECT P')) =\n    ((Ex P' \\<longrightarrow> Ex P) \\<and>\n     (\\<forall>x.\n         P x \\<longrightarrow> (\\<exists>x'. (x, x') \\<in> R \\<and> P' x')))", "by (force simp: SELECT_def pw_le_iff refine_pw_simps)"], ["", "lemma SELECT_refine[refine]:\n  assumes \"RELATES R\"\n  assumes \"\\<And>x'. P' x' \\<Longrightarrow> \\<exists>x. P x\"\n  assumes \"\\<And>x. P x \\<Longrightarrow> \\<exists>x'. (x,x')\\<in>R \\<and> P' x'\"\n  shows \"SELECT P \\<le>\\<Down>(\\<langle>R\\<rangle>option_rel) (SELECT P')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SELECT P \\<le> \\<Down> (\\<langle>R\\<rangle>option_rel) (SELECT P')", "unfolding SELECT_refine_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. (Ex P' \\<longrightarrow> Ex P) \\<and>\n    (\\<forall>x.\n        P x \\<longrightarrow> (\\<exists>x'. (x, x') \\<in> R \\<and> P' x'))", "using assms"], ["proof (prove)\nusing this:\n  RELATES R\n  P' ?x' \\<Longrightarrow> \\<exists>x. P x\n  P ?x \\<Longrightarrow> \\<exists>x'. (?x, x') \\<in> R \\<and> P' x'\n\ngoal (1 subgoal):\n 1. (Ex P' \\<longrightarrow> Ex P) \\<and>\n    (\\<forall>x.\n        P x \\<longrightarrow> (\\<exists>x'. (x, x') \\<in> R \\<and> P' x'))", "by blast"], ["", "lemma SELECT_as_SPEC: \"SELECT P = SPEC (\\<lambda>None \\<Rightarrow> \\<forall>x. \\<not>P x | Some x \\<Rightarrow> P x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SELECT P =\n    SPEC\n     (\\<lambda>xa.\n         case xa of None \\<Rightarrow> \\<forall>x. \\<not> P x\n         | Some x \\<Rightarrow> P x)", "unfolding SELECT_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if \\<exists>x. P x\n     then SPEC (\\<lambda>uu_. \\<exists>x. uu_ = Some x \\<and> P x)\n     else RETURN None) =\n    SPEC\n     (\\<lambda>xa.\n         case xa of None \\<Rightarrow> \\<forall>x. \\<not> P x\n         | Some x \\<Rightarrow> P x)", "by (auto simp: pw_eq_iff split: option.split)"], ["", "lemma SELECT_pw[refine_pw_simps]:\n  \"nofail (SELECT P)\"  \n  \"inres (SELECT P) r \\<longleftrightarrow> (r=None \\<longrightarrow> (\\<forall>x. \\<not>P x)) \\<and> (\\<forall>x. r=Some x \\<longrightarrow> P x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nofail (SELECT P) &&&\n    inres (SELECT P) r =\n    ((r = None \\<longrightarrow> (\\<forall>x. \\<not> P x)) \\<and>\n     (\\<forall>x. r = Some x \\<longrightarrow> P x))", "unfolding SELECT_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. nofail\n     (if \\<exists>x. P x\n      then SPEC (\\<lambda>uu_. \\<exists>x. uu_ = Some x \\<and> P x)\n      else RETURN None) &&&\n    inres\n     (if \\<exists>x. P x\n      then SPEC (\\<lambda>uu_. \\<exists>x. uu_ = Some x \\<and> P x)\n      else RETURN None)\n     r =\n    ((r = None \\<longrightarrow> (\\<forall>x. \\<not> P x)) \\<and>\n     (\\<forall>x. r = Some x \\<longrightarrow> P x))", "by auto"], ["", "lemma SELECT_pw_simps[simp]:\n  \"nofail (SELECT P)\"\n  \"inres (SELECT P) None \\<longleftrightarrow> (\\<forall>x. \\<not>P x)\"\n  \"inres (SELECT P) (Some x) \\<longleftrightarrow> P x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nofail (SELECT P) &&&\n    inres (SELECT P) None = (\\<forall>x. \\<not> P x) &&&\n    inres (SELECT P) (Some x) = P x", "by (auto simp: refine_pw_simps)"], ["", "end"]]}