{"file_name": "/home/qj213/afp-2021-10-22/thys/Refine_Monadic/Generic/RefineG_While.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Refine_Monadic", "problem_names": ["lemma mono_prover_monoI[refine_mono]: \n  \"monotone (fun_ord (\\<le>)) (fun_ord (\\<le>)) B \\<Longrightarrow> mono B\"", "lemmas WHILEIT_def = WHILEIT_eq[unfolded iWHILEIT_def [abs_def]]", "lemmas WHILEI_def = WHILEI_eq[unfolded iWHILEI_def [abs_def]]", "lemmas WHILET_def = WHILET_eq[unfolded iWHILET_def, folded WHILEIT_eq]", "lemmas WHILE_def = WHILE_eq[unfolded iWHILE_def [abs_def], folded WHILEI_eq]", "lemmas imonad_laws = imonad1 imonad2 imonad3", "lemmas [refine_mono] = ibind_mono_ge ibind_mono", "lemma WHILEI_body_trimono: \"trimono (WHILEI_body bind return I b f)\"", "lemmas WHILEI_mono = trimonoD_mono[OF WHILEI_body_trimono]", "lemmas WHILEI_mono_ge = trimonoD_flatf_ge[OF WHILEI_body_trimono]", "lemma WHILEI_unfold: \"WHILEI I b f x = (\n  if (I x) then (if b x then bind (f x) (WHILEI I b f) else return x) else top) \"", "lemma REC_mono_ref[refine_mono]: \n  \"\\<lbrakk>trimono B; \\<And>D x. B D x \\<le> B' D x\\<rbrakk> \\<Longrightarrow> REC B x \\<le> REC B' x\"", "lemma RECT_mono_ref[refine_mono]: \n  \"\\<lbrakk>trimono B; \\<And>D x. B D x \\<le> B' D x\\<rbrakk> \\<Longrightarrow> RECT B x \\<le> RECT B' x\"", "lemma WHILEI_weaken:\n  assumes IW: \"\\<And>x. I x \\<Longrightarrow> I' x\"\n  shows \"WHILEI I' b f x \\<le> WHILEI I b f x\"", "lemma WHILEIT_unfold: \"WHILEIT I b f x = (\n  if (I x) then \n    (if b x then bind (f x) (WHILEIT I b f) else return x) \n  else top) \"", "lemma WHILEIT_weaken:\n  assumes IW: \"\\<And>x. I x \\<Longrightarrow> I' x\"\n  shows \"WHILEIT I' b f x \\<le> WHILEIT I b f x\"", "lemma WHILEI_le_WHILEIT: \"WHILEI I b f s \\<le> WHILEIT I b f s\"", "lemma WHILE_unfold: \n  \"WHILE b f s = (if b s then bind (f s) (WHILE b f) else return s)\"", "lemma WHILET_unfold: \n  \"WHILET b f s = (if b s then bind (f s) (WHILET b f) else return s)\"", "lemma transfer_WHILEIT_esc[refine_transfer]:\n  assumes REF: \"\\<And>x. return (f x) \\<le> F x\"\n  shows \"return (while b f x) \\<le> WHILEIT I b F x\"", "lemma transfer_WHILET_esc[refine_transfer]:\n  assumes REF: \"\\<And>x. return (f x) \\<le> F x\"\n  shows \"return (while b f x) \\<le> WHILET b F x\"", "lemma WHILE_mono_prover_rule[refine_mono]:\n  \"\\<lbrakk>\\<And>x. f x \\<le> f' x\\<rbrakk> \\<Longrightarrow> WHILE b f s0 \\<le> WHILE b f' s0\"\n  \"\\<lbrakk>\\<And>x. f x \\<le> f' x\\<rbrakk> \\<Longrightarrow> WHILEI I b f s0 \\<le> WHILEI I b f' s0\"\n  \"\\<lbrakk>\\<And>x. f x \\<le> f' x\\<rbrakk> \\<Longrightarrow> WHILET b f s0 \\<le> WHILET b f' s0\"\n  \"\\<lbrakk>\\<And>x. f x \\<le> f' x\\<rbrakk> \\<Longrightarrow> WHILEIT I b f s0 \\<le> WHILEIT I b f' s0\"\n\n  \"\\<lbrakk>\\<And>x. flat_ge (f x) (f' x)\\<rbrakk> \\<Longrightarrow> flat_ge (WHILET b f s0) (WHILET b f' s0)\"\n  \"\\<lbrakk>\\<And>x. flat_ge (f x) (f' x)\\<rbrakk> \\<Longrightarrow> flat_ge (WHILEIT I b f s0) (WHILEIT I b f' s0)\"", "lemma transfer_WHILEIT[refine_transfer]:\n  assumes REF: \"\\<And>x. \\<alpha> (f x) \\<le> F x\"\n  shows \"\\<alpha> (cWHILEIT I b f x) \\<le> aWHILEIT I b F x\"", "lemma transfer_WHILEI[refine_transfer]:\n  assumes REF: \"\\<And>x. \\<alpha> (f x) \\<le> F x\"\n  shows \"\\<alpha> (cWHILEI I b f x) \\<le> aWHILEI I b F x\"", "lemma transfer_WHILE[refine_transfer]:\n  assumes REF: \"\\<And>x. \\<alpha> (f x) \\<le> F x\"\n  shows \"\\<alpha> (cWHILE b f x) \\<le> aWHILE b F x\"", "lemma transfer_WHILET[refine_transfer]:\n  assumes REF: \"\\<And>x. \\<alpha> (f x) \\<le> F x\"\n  shows \"\\<alpha> (cWHILET b f x) \\<le> aWHILET b F x\"", "lemma ireturn_eq: \"return x = SPEC ((=) x)\"", "lemma iSPEC_rule: \"(\\<And>x. \\<Phi> x \\<Longrightarrow> \\<Psi> x) \\<Longrightarrow> SPEC \\<Phi> \\<le> SPEC \\<Psi>\"", "lemma ireturn_rule: \"\\<Phi> x \\<Longrightarrow> return x \\<le> SPEC \\<Phi>\"", "lemma WHILEI_rule:\n  assumes I0: \"I s\"\n  assumes ISTEP: \"\\<And>s. \\<lbrakk>I s; b s\\<rbrakk> \\<Longrightarrow> f s \\<le> SPEC I\"\n  assumes CONS: \"\\<And>s. \\<lbrakk> I s; \\<not> b s \\<rbrakk> \\<Longrightarrow> \\<Phi> s\"\n  shows \"WHILEI I b f s \\<le> SPEC \\<Phi>\"", "lemma WHILEIT_rule:\n  assumes WF: \"wf R\"\n  assumes I0: \"I s\"\n  assumes IS: \"\\<And>s. \\<lbrakk> I s; b s \\<rbrakk> \\<Longrightarrow> f s \\<le> SPEC (\\<lambda>s'. I s' \\<and> (s',s)\\<in>R)\"\n  assumes PHI: \"\\<And>s. \\<lbrakk> I s; \\<not> b s \\<rbrakk> \\<Longrightarrow> \\<Phi> s\"\n  shows \"WHILEIT I b f s \\<le> SPEC \\<Phi>\"", "lemma WHILE_rule:\n  assumes I0: \"I s\"\n  assumes ISTEP: \"\\<And>s. \\<lbrakk>I s; b s\\<rbrakk> \\<Longrightarrow> f s \\<le> SPEC I\"\n  assumes CONS: \"\\<And>s. \\<lbrakk> I s; \\<not> b s \\<rbrakk> \\<Longrightarrow> \\<Phi> s\"\n  shows \"WHILE b f s \\<le> SPEC \\<Phi>\"", "lemma WHILET_rule:\n  assumes WF: \"wf R\"\n  assumes I0: \"I s\"\n  assumes IS: \"\\<And>s. \\<lbrakk> I s; b s \\<rbrakk> \\<Longrightarrow> f s \\<le> SPEC (\\<lambda>s'. I s' \\<and> (s',s)\\<in>R)\"\n  assumes PHI: \"\\<And>s. \\<lbrakk> I s; \\<not> b s \\<rbrakk> \\<Longrightarrow> \\<Phi> s\"\n  shows \"WHILET b f s \\<le> SPEC \\<Phi>\""], "translations": [["", "lemma mono_prover_monoI[refine_mono]: \n  \"monotone (fun_ord (\\<le>)) (fun_ord (\\<le>)) B \\<Longrightarrow> mono B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monotone (fun_ord (\\<le>)) (fun_ord (\\<le>)) B \\<Longrightarrow> mono B", "apply (rule ccpo_monoD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. monotone (fun_ord (\\<le>)) (fun_ord (\\<le>)) B \\<Longrightarrow>\n    monotone (\\<le>) (\\<le>) B", "apply (simp add: le_fun_def[abs_def] fun_ord_def[abs_def])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "locale generic_WHILE =\n  fixes bind :: \"'m \\<Rightarrow> ('a\\<Rightarrow>'m) \\<Rightarrow> ('m::complete_lattice)\"\n  fixes return :: \"'a \\<Rightarrow> 'm\"\n  fixes WHILEIT WHILEI WHILET WHILE \n  assumes imonad1: \"bind (return x) f = f x\"\n  assumes imonad2: \"bind M return = M\"\n  assumes imonad3: \"bind (bind M f) g = bind M (\\<lambda>x. bind (f x) g)\"\n  assumes ibind_mono_ge: \"\\<lbrakk>flat_ge m m'; \\<And>x. flat_ge (f x) (f' x)\\<rbrakk> \n    \\<Longrightarrow> flat_ge (bind m f) (bind m' f')\"\n  assumes ibind_mono: \"\\<lbrakk>(\\<le>) m m'; \\<And>x. (\\<le>) (f x) (f' x)\\<rbrakk> \n    \\<Longrightarrow> (\\<le>) (bind m f) (bind m' f')\"\n  assumes WHILEIT_eq: \"WHILEIT \\<equiv> iWHILEIT bind return\"\n  assumes WHILEI_eq: \"WHILEI \\<equiv> iWHILEI bind return\"\n  assumes WHILET_eq: \"WHILET \\<equiv> iWHILET bind return\"\n  assumes WHILE_eq: \"WHILE \\<equiv> iWHILE bind return\"\nbegin"], ["", "lemmas WHILEIT_def = WHILEIT_eq[unfolded iWHILEIT_def [abs_def]]"], ["", "lemmas WHILEI_def = WHILEI_eq[unfolded iWHILEI_def [abs_def]]"], ["", "lemmas WHILET_def = WHILET_eq[unfolded iWHILET_def, folded WHILEIT_eq]"], ["", "lemmas WHILE_def = WHILE_eq[unfolded iWHILE_def [abs_def], folded WHILEI_eq]"], ["", "lemmas imonad_laws = imonad1 imonad2 imonad3"], ["", "lemmas [refine_mono] = ibind_mono_ge ibind_mono"], ["", "(*  lemma ibind_mono: \"m \\<le> m' \\<Longrightarrow> f \\<le> f' \\<Longrightarrow> bind m f \\<le> bind m' f'\"\n    by (metis (no_types) ibind_mono1 ibind_mono2 le_funD monoD order_trans)\n*)"], ["", "lemma WHILEI_body_trimono: \"trimono (WHILEI_body bind return I b f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trimono (WHILEI_body bind return I b f)", "unfolding WHILEI_body_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. trimono\n     (\\<lambda>W s.\n         if I s then if b s then bind (f s) W else return s else top)", "by refine_mono"], ["", "lemmas WHILEI_mono = trimonoD_mono[OF WHILEI_body_trimono]"], ["", "lemmas WHILEI_mono_ge = trimonoD_flatf_ge[OF WHILEI_body_trimono]"], ["", "lemma WHILEI_unfold: \"WHILEI I b f x = (\n  if (I x) then (if b x then bind (f x) (WHILEI I b f) else return x) else top) \""], ["proof (prove)\ngoal (1 subgoal):\n 1. WHILEI I b f x =\n    (if I x then if b x then bind (f x) (WHILEI I b f) else return x\n     else top)", "unfolding WHILEI_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. REC (WHILEI_body bind return I b f) x =\n    (if I x\n     then if b x then bind (f x) (REC (WHILEI_body bind return I b f))\n          else return x\n     else top)", "apply (subst REC_unfold[OF WHILEI_body_trimono])"], ["proof (prove)\ngoal (1 subgoal):\n 1. WHILEI_body bind return I b f (REC (WHILEI_body bind return I b f)) x =\n    (if I x\n     then if b x then bind (f x) (REC (WHILEI_body bind return I b f))\n          else return x\n     else top)", "unfolding WHILEI_body_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if I x\n     then if b x\n          then bind (f x)\n                (REC (\\<lambda>W s.\n                         if I s then if b s then bind (f s) W else return s\n                         else top))\n          else return x\n     else top) =\n    (if I x\n     then if b x\n          then bind (f x)\n                (REC (\\<lambda>W s.\n                         if I s then if b s then bind (f s) W else return s\n                         else top))\n          else return x\n     else top)", "apply (rule refl)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(* TODO: Move *)"], ["", "lemma REC_mono_ref[refine_mono]: \n  \"\\<lbrakk>trimono B; \\<And>D x. B D x \\<le> B' D x\\<rbrakk> \\<Longrightarrow> REC B x \\<le> REC B' x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>trimono B; \\<And>D x. B D x \\<le> B' D x\\<rbrakk>\n    \\<Longrightarrow> REC B x \\<le> REC B' x", "unfolding REC_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>trimono B; \\<And>D x. B D x \\<le> B' D x\\<rbrakk>\n    \\<Longrightarrow> (if trimono B then lfp B x else top)\n                      \\<le> (if trimono B' then lfp B' x else top)", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>trimono B; \\<And>D x. B D x \\<le> B' D x; trimono B'\\<rbrakk>\n    \\<Longrightarrow> lfp B x \\<le> lfp B' x", "apply (rule lfp_mono[THEN le_funD])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Z.\n       \\<lbrakk>trimono B; \\<And>D x. B D x \\<le> B' D x;\n        trimono B'\\<rbrakk>\n       \\<Longrightarrow> B Z \\<le> B' Z", "by (rule le_funI)"], ["", "lemma RECT_mono_ref[refine_mono]: \n  \"\\<lbrakk>trimono B; \\<And>D x. B D x \\<le> B' D x\\<rbrakk> \\<Longrightarrow> RECT B x \\<le> RECT B' x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>trimono B; \\<And>D x. B D x \\<le> B' D x\\<rbrakk>\n    \\<Longrightarrow> REC\\<^sub>T B x \\<le> REC\\<^sub>T B' x", "unfolding RECT_gfp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>trimono B; \\<And>D x. B D x \\<le> B' D x\\<rbrakk>\n    \\<Longrightarrow> (if trimono B then gfp B x else top)\n                      \\<le> (if trimono B' then gfp B' x else top)", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>trimono B; \\<And>D x. B D x \\<le> B' D x; trimono B'\\<rbrakk>\n    \\<Longrightarrow> gfp B x \\<le> gfp B' x", "apply (rule gfp_mono[THEN le_funD])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Z.\n       \\<lbrakk>trimono B; \\<And>D x. B D x \\<le> B' D x;\n        trimono B'\\<rbrakk>\n       \\<Longrightarrow> B Z \\<le> B' Z", "by (rule le_funI)"], ["", "lemma WHILEI_weaken:\n  assumes IW: \"\\<And>x. I x \\<Longrightarrow> I' x\"\n  shows \"WHILEI I' b f x \\<le> WHILEI I b f x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. WHILEI I' b f x \\<le> WHILEI I b f x", "unfolding WHILEI_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. REC (WHILEI_body bind return I' b f) x\n    \\<le> REC (WHILEI_body bind return I b f) x", "apply (rule REC_mono_ref[OF WHILEI_body_trimono])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>D x.\n       WHILEI_body bind return I' b f D x\n       \\<le> WHILEI_body bind return I b f D x", "apply (auto simp add: WHILEI_body_def dest: IW)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma WHILEIT_unfold: \"WHILEIT I b f x = (\n  if (I x) then \n    (if b x then bind (f x) (WHILEIT I b f) else return x) \n  else top) \""], ["proof (prove)\ngoal (1 subgoal):\n 1. WHILEIT I b f x =\n    (if I x then if b x then bind (f x) (WHILEIT I b f) else return x\n     else top)", "unfolding WHILEIT_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. REC\\<^sub>T (WHILEI_body bind return I b f) x =\n    (if I x\n     then if b x\n          then bind (f x) (REC\\<^sub>T (WHILEI_body bind return I b f))\n          else return x\n     else top)", "apply (subst RECT_unfold[OF WHILEI_body_trimono])"], ["proof (prove)\ngoal (1 subgoal):\n 1. WHILEI_body bind return I b f\n     (REC\\<^sub>T (WHILEI_body bind return I b f)) x =\n    (if I x\n     then if b x\n          then bind (f x) (REC\\<^sub>T (WHILEI_body bind return I b f))\n          else return x\n     else top)", "unfolding WHILEI_body_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if I x\n     then if b x\n          then bind (f x)\n                (REC\\<^sub>T\n                  (\\<lambda>W s.\n                      if I s then if b s then bind (f s) W else return s\n                      else top))\n          else return x\n     else top) =\n    (if I x\n     then if b x\n          then bind (f x)\n                (REC\\<^sub>T\n                  (\\<lambda>W s.\n                      if I s then if b s then bind (f s) W else return s\n                      else top))\n          else return x\n     else top)", "apply (rule refl)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma WHILEIT_weaken:\n  assumes IW: \"\\<And>x. I x \\<Longrightarrow> I' x\"\n  shows \"WHILEIT I' b f x \\<le> WHILEIT I b f x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. WHILEIT I' b f x \\<le> WHILEIT I b f x", "unfolding WHILEIT_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. REC\\<^sub>T (WHILEI_body bind return I' b f) x\n    \\<le> REC\\<^sub>T (WHILEI_body bind return I b f) x", "apply (rule RECT_mono_ref[OF WHILEI_body_trimono])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>D x.\n       WHILEI_body bind return I' b f D x\n       \\<le> WHILEI_body bind return I b f D x", "apply (auto simp add: WHILEI_body_def dest: IW)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma WHILEI_le_WHILEIT: \"WHILEI I b f s \\<le> WHILEIT I b f s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. WHILEI I b f s \\<le> WHILEIT I b f s", "unfolding WHILEI_def WHILEIT_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. REC (WHILEI_body bind return I b f) s\n    \\<le> REC\\<^sub>T (WHILEI_body bind return I b f) s", "by (rule REC_le_RECT)"], ["", "subsubsection \\<open>While without Annotated Invariant\\<close>"], ["", "lemma WHILE_unfold: \n  \"WHILE b f s = (if b s then bind (f s) (WHILE b f) else return s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. WHILE b f s = (if b s then bind (f s) (WHILE b f) else return s)", "unfolding WHILE_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. WHILEI (\\<lambda>_. True) b f s =\n    (if b s then bind (f s) (WHILEI (\\<lambda>_. True) b f) else return s)", "apply (subst WHILEI_unfold)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if True\n     then if b s then bind (f s) (WHILEI (\\<lambda>_. True) b f)\n          else return s\n     else top) =\n    (if b s then bind (f s) (WHILEI (\\<lambda>_. True) b f) else return s)", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma WHILET_unfold: \n  \"WHILET b f s = (if b s then bind (f s) (WHILET b f) else return s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. WHILET b f s = (if b s then bind (f s) (WHILET b f) else return s)", "unfolding WHILET_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. WHILEIT (\\<lambda>_. True) b f s =\n    (if b s then bind (f s) (WHILEIT (\\<lambda>_. True) b f) else return s)", "apply (subst WHILEIT_unfold)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if True\n     then if b s then bind (f s) (WHILEIT (\\<lambda>_. True) b f)\n          else return s\n     else top) =\n    (if b s then bind (f s) (WHILEIT (\\<lambda>_. True) b f) else return s)", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma transfer_WHILEIT_esc[refine_transfer]:\n  assumes REF: \"\\<And>x. return (f x) \\<le> F x\"\n  shows \"return (while b f x) \\<le> WHILEIT I b F x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. return (while b f x) \\<le> WHILEIT I b F x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. return (while b f x) \\<le> WHILEIT I b F x", "interpret transfer return"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["proof (state)\ngoal (1 subgoal):\n 1. return (while b f x) \\<le> WHILEIT I b F x", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. return (while b f x) \\<le> WHILEIT I b F x", "unfolding WHILEIT_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. return (while b f x) \\<le> REC\\<^sub>T (WHILEI_body bind return I b F) x", "apply (rule transfer_RECT'[where fr=\"while b f\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x. while b f x = ?b (while b f) x\n 2. \\<And>Fa f x.\n       (\\<And>x. return (f x) \\<le> Fa x) \\<Longrightarrow>\n       return (?b f x) \\<le> WHILEI_body bind return I b F Fa x", "apply (rule while_unfold)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Fa fa x.\n       (\\<And>x. return (fa x) \\<le> Fa x) \\<Longrightarrow>\n       return (if b x then fa (f x) else x)\n       \\<le> WHILEI_body bind return I b F Fa x", "unfolding WHILEI_body_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Fa fa x.\n       (\\<And>x. return (fa x) \\<le> Fa x) \\<Longrightarrow>\n       return (if b x then fa (f x) else x)\n       \\<le> (if I x then if b x then bind (F x) Fa else return x else top)", "apply (split if_split, intro allI impI conjI)+"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>Fa fa x.\n       \\<lbrakk>\\<And>x. return (fa x) \\<le> Fa x; I x; b x; b x\\<rbrakk>\n       \\<Longrightarrow> return (fa (f x)) \\<le> bind (F x) Fa\n 2. \\<And>Fa f x.\n       \\<lbrakk>\\<And>x. return (f x) \\<le> Fa x; I x; b x;\n        \\<not> b x\\<rbrakk>\n       \\<Longrightarrow> return x \\<le> bind (F x) Fa\n 3. \\<And>F fa x.\n       \\<lbrakk>\\<And>x. return (fa x) \\<le> F x; I x; \\<not> b x\\<rbrakk>\n       \\<Longrightarrow> return (if b x then fa (f x) else x) \\<le> return x\n 4. \\<And>F fa x.\n       \\<lbrakk>\\<And>x. return (fa x) \\<le> F x; \\<not> I x\\<rbrakk>\n       \\<Longrightarrow> return (if b x then fa (f x) else x) \\<le> top", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Fa fa x.\n       \\<lbrakk>\\<And>x. return (fa x) \\<le> Fa x; I x; b x\\<rbrakk>\n       \\<Longrightarrow> return (fa (f x)) \\<le> bind (F x) Fa", "apply (rule order_trans[OF _ ibind_mono[OF REF order_refl]])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>F fa x.\n       \\<lbrakk>\\<And>x. return (fa x) \\<le> F x; I x; b x\\<rbrakk>\n       \\<Longrightarrow> return (fa (f x)) \\<le> bind (return (f x)) F", "apply (simp add: imonad_laws)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  return (while b f x) \\<le> WHILEIT I b F x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma transfer_WHILET_esc[refine_transfer]:\n  assumes REF: \"\\<And>x. return (f x) \\<le> F x\"\n  shows \"return (while b f x) \\<le> WHILET b F x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. return (while b f x) \\<le> WHILET b F x", "unfolding WHILET_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. return (while b f x) \\<le> WHILEIT (\\<lambda>_. True) b F x", "using assms"], ["proof (prove)\nusing this:\n  return (f ?x) \\<le> F ?x\n\ngoal (1 subgoal):\n 1. return (while b f x) \\<le> WHILEIT (\\<lambda>_. True) b F x", "by (rule transfer_WHILEIT_esc)"], ["", "lemma WHILE_mono_prover_rule[refine_mono]:\n  \"\\<lbrakk>\\<And>x. f x \\<le> f' x\\<rbrakk> \\<Longrightarrow> WHILE b f s0 \\<le> WHILE b f' s0\"\n  \"\\<lbrakk>\\<And>x. f x \\<le> f' x\\<rbrakk> \\<Longrightarrow> WHILEI I b f s0 \\<le> WHILEI I b f' s0\"\n  \"\\<lbrakk>\\<And>x. f x \\<le> f' x\\<rbrakk> \\<Longrightarrow> WHILET b f s0 \\<le> WHILET b f' s0\"\n  \"\\<lbrakk>\\<And>x. f x \\<le> f' x\\<rbrakk> \\<Longrightarrow> WHILEIT I b f s0 \\<le> WHILEIT I b f' s0\"\n\n  \"\\<lbrakk>\\<And>x. flat_ge (f x) (f' x)\\<rbrakk> \\<Longrightarrow> flat_ge (WHILET b f s0) (WHILET b f' s0)\"\n  \"\\<lbrakk>\\<And>x. flat_ge (f x) (f' x)\\<rbrakk> \\<Longrightarrow> flat_ge (WHILEIT I b f s0) (WHILEIT I b f' s0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (((\\<And>x. f x \\<le> f' x) \\<Longrightarrow>\n      WHILE b f s0 \\<le> WHILE b f' s0) &&&\n     ((\\<And>x. f x \\<le> f' x) \\<Longrightarrow>\n      WHILEI I b f s0 \\<le> WHILEI I b f' s0) &&&\n     ((\\<And>x. f x \\<le> f' x) \\<Longrightarrow>\n      WHILET b f s0 \\<le> WHILET b f' s0)) &&&\n    ((\\<And>x. f x \\<le> f' x) \\<Longrightarrow>\n     WHILEIT I b f s0 \\<le> WHILEIT I b f' s0) &&&\n    ((\\<And>x. flat_ge (f x) (f' x)) \\<Longrightarrow>\n     flat_ge (WHILET b f s0) (WHILET b f' s0)) &&&\n    ((\\<And>x. flat_ge (f x) (f' x)) \\<Longrightarrow>\n     flat_ge (WHILEIT I b f s0) (WHILEIT I b f' s0))", "unfolding WHILE_def WHILEI_def WHILEI_body_def\n    WHILET_def WHILEIT_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (((\\<And>x. f x \\<le> f' x) \\<Longrightarrow>\n      REC (\\<lambda>W s.\n              if True then if b s then bind (f s) W else return s else top)\n       s0\n      \\<le> REC (\\<lambda>W s.\n                    if True then if b s then bind (f' s) W else return s\n                    else top)\n             s0) &&&\n     ((\\<And>x. f x \\<le> f' x) \\<Longrightarrow>\n      REC (\\<lambda>W s.\n              if I s then if b s then bind (f s) W else return s else top)\n       s0\n      \\<le> REC (\\<lambda>W s.\n                    if I s then if b s then bind (f' s) W else return s\n                    else top)\n             s0) &&&\n     ((\\<And>x. f x \\<le> f' x) \\<Longrightarrow>\n      REC\\<^sub>T\n       (\\<lambda>W s.\n           if True then if b s then bind (f s) W else return s else top)\n       s0\n      \\<le> REC\\<^sub>T\n             (\\<lambda>W s.\n                 if True then if b s then bind (f' s) W else return s\n                 else top)\n             s0)) &&&\n    ((\\<And>x. f x \\<le> f' x) \\<Longrightarrow>\n     REC\\<^sub>T\n      (\\<lambda>W s.\n          if I s then if b s then bind (f s) W else return s else top)\n      s0\n     \\<le> REC\\<^sub>T\n            (\\<lambda>W s.\n                if I s then if b s then bind (f' s) W else return s\n                else top)\n            s0) &&&\n    ((\\<And>x. flat_ge (f x) (f' x)) \\<Longrightarrow>\n     flat_ge\n      (REC\\<^sub>T\n        (\\<lambda>W s.\n            if True then if b s then bind (f s) W else return s else top)\n        s0)\n      (REC\\<^sub>T\n        (\\<lambda>W s.\n            if True then if b s then bind (f' s) W else return s else top)\n        s0)) &&&\n    ((\\<And>x. flat_ge (f x) (f' x)) \\<Longrightarrow>\n     flat_ge\n      (REC\\<^sub>T\n        (\\<lambda>W s.\n            if I s then if b s then bind (f s) W else return s else top)\n        s0)\n      (REC\\<^sub>T\n        (\\<lambda>W s.\n            if I s then if b s then bind (f' s) W else return s else top)\n        s0))", "by refine_mono+"], ["", "end"], ["", "locale transfer_WHILE = \n  c: generic_WHILE cbind creturn cWHILEIT cWHILEI cWHILET cWHILE + \n  a: generic_WHILE abind areturn aWHILEIT aWHILEI aWHILET aWHILE +\n  dist_transfer \\<alpha>\n  for cbind and creturn::\"'a \\<Rightarrow> 'mc::complete_lattice\" \n  and cWHILEIT cWHILEI cWHILET cWHILE\n  and abind and areturn::\"'a \\<Rightarrow> 'ma::complete_lattice\"\n  and aWHILEIT aWHILEI aWHILET aWHILE\n  and \\<alpha> :: \"'mc \\<Rightarrow> 'ma\" +\n  assumes transfer_bind: \"\\<lbrakk>\\<alpha> m \\<le> M; \\<And>x. \\<alpha> (f x) \\<le> F x \\<rbrakk> \n    \\<Longrightarrow> \\<alpha> (cbind m f) \\<le> abind M F\"\n  assumes transfer_return: \"\\<alpha> (creturn x) \\<le> areturn x\"\nbegin"], ["", "lemma transfer_WHILEIT[refine_transfer]:\n  assumes REF: \"\\<And>x. \\<alpha> (f x) \\<le> F x\"\n  shows \"\\<alpha> (cWHILEIT I b f x) \\<le> aWHILEIT I b F x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha> (cWHILEIT I b f x) \\<le> aWHILEIT I b F x", "unfolding c.WHILEIT_def a.WHILEIT_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha> (REC\\<^sub>T (WHILEI_body cbind creturn I b f) x)\n    \\<le> REC\\<^sub>T (WHILEI_body abind areturn I b F) x", "apply (rule transfer_RECT[OF _ c.WHILEI_body_trimono])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Fa fa x.\n       (\\<And>x. \\<alpha> (fa x) \\<le> Fa x) \\<Longrightarrow>\n       \\<alpha> (WHILEI_body cbind creturn I b f fa x)\n       \\<le> WHILEI_body abind areturn I b F Fa x", "unfolding WHILEI_body_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Fa fa x.\n       (\\<And>x. \\<alpha> (fa x) \\<le> Fa x) \\<Longrightarrow>\n       \\<alpha>\n        (if I x then if b x then cbind (f x) fa else creturn x else top)\n       \\<le> (if I x then if b x then abind (F x) Fa else areturn x\n              else top)", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>Fa fa x.\n       \\<lbrakk>\\<And>x. \\<alpha> (fa x) \\<le> Fa x; b x; I x\\<rbrakk>\n       \\<Longrightarrow> \\<alpha> (cbind (f x) fa) \\<le> abind (F x) Fa\n 2. \\<And>F f x.\n       \\<lbrakk>\\<And>x. \\<alpha> (f x) \\<le> F x; \\<not> b x; I x\\<rbrakk>\n       \\<Longrightarrow> \\<alpha> (creturn x) \\<le> areturn x", "apply (rule transfer_bind)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>Fa fa x.\n       \\<lbrakk>\\<And>x. \\<alpha> (fa x) \\<le> Fa x; b x; I x\\<rbrakk>\n       \\<Longrightarrow> \\<alpha> (f x) \\<le> F x\n 2. \\<And>F f x xa.\n       \\<lbrakk>\\<And>x. \\<alpha> (f x) \\<le> F x; b x; I x\\<rbrakk>\n       \\<Longrightarrow> \\<alpha> (f xa) \\<le> F xa\n 3. \\<And>F f x.\n       \\<lbrakk>\\<And>x. \\<alpha> (f x) \\<le> F x; \\<not> b x; I x\\<rbrakk>\n       \\<Longrightarrow> \\<alpha> (creturn x) \\<le> areturn x", "apply (rule REF)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>F f x xa.\n       \\<lbrakk>\\<And>x. \\<alpha> (f x) \\<le> F x; b x; I x\\<rbrakk>\n       \\<Longrightarrow> \\<alpha> (f xa) \\<le> F xa\n 2. \\<And>F f x.\n       \\<lbrakk>\\<And>x. \\<alpha> (f x) \\<le> F x; \\<not> b x; I x\\<rbrakk>\n       \\<Longrightarrow> \\<alpha> (creturn x) \\<le> areturn x", "apply assumption"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>F f x.\n       \\<lbrakk>\\<And>x. \\<alpha> (f x) \\<le> F x; \\<not> b x; I x\\<rbrakk>\n       \\<Longrightarrow> \\<alpha> (creturn x) \\<le> areturn x", "apply (rule transfer_return)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma transfer_WHILEI[refine_transfer]:\n  assumes REF: \"\\<And>x. \\<alpha> (f x) \\<le> F x\"\n  shows \"\\<alpha> (cWHILEI I b f x) \\<le> aWHILEI I b F x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha> (cWHILEI I b f x) \\<le> aWHILEI I b F x", "unfolding c.WHILEI_def a.WHILEI_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha> (REC (WHILEI_body cbind creturn I b f) x)\n    \\<le> REC (WHILEI_body abind areturn I b F) x", "apply (rule transfer_REC[OF _ c.WHILEI_body_trimono])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Fa fa x.\n       (\\<And>x. \\<alpha> (fa x) \\<le> Fa x) \\<Longrightarrow>\n       \\<alpha> (WHILEI_body cbind creturn I b f fa x)\n       \\<le> WHILEI_body abind areturn I b F Fa x", "unfolding WHILEI_body_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Fa fa x.\n       (\\<And>x. \\<alpha> (fa x) \\<le> Fa x) \\<Longrightarrow>\n       \\<alpha>\n        (if I x then if b x then cbind (f x) fa else creturn x else top)\n       \\<le> (if I x then if b x then abind (F x) Fa else areturn x\n              else top)", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>Fa fa x.\n       \\<lbrakk>\\<And>x. \\<alpha> (fa x) \\<le> Fa x; b x; I x\\<rbrakk>\n       \\<Longrightarrow> \\<alpha> (cbind (f x) fa) \\<le> abind (F x) Fa\n 2. \\<And>F f x.\n       \\<lbrakk>\\<And>x. \\<alpha> (f x) \\<le> F x; \\<not> b x; I x\\<rbrakk>\n       \\<Longrightarrow> \\<alpha> (creturn x) \\<le> areturn x", "apply (rule transfer_bind)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>Fa fa x.\n       \\<lbrakk>\\<And>x. \\<alpha> (fa x) \\<le> Fa x; b x; I x\\<rbrakk>\n       \\<Longrightarrow> \\<alpha> (f x) \\<le> F x\n 2. \\<And>F f x xa.\n       \\<lbrakk>\\<And>x. \\<alpha> (f x) \\<le> F x; b x; I x\\<rbrakk>\n       \\<Longrightarrow> \\<alpha> (f xa) \\<le> F xa\n 3. \\<And>F f x.\n       \\<lbrakk>\\<And>x. \\<alpha> (f x) \\<le> F x; \\<not> b x; I x\\<rbrakk>\n       \\<Longrightarrow> \\<alpha> (creturn x) \\<le> areturn x", "apply (rule REF)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>F f x xa.\n       \\<lbrakk>\\<And>x. \\<alpha> (f x) \\<le> F x; b x; I x\\<rbrakk>\n       \\<Longrightarrow> \\<alpha> (f xa) \\<le> F xa\n 2. \\<And>F f x.\n       \\<lbrakk>\\<And>x. \\<alpha> (f x) \\<le> F x; \\<not> b x; I x\\<rbrakk>\n       \\<Longrightarrow> \\<alpha> (creturn x) \\<le> areturn x", "apply assumption"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>F f x.\n       \\<lbrakk>\\<And>x. \\<alpha> (f x) \\<le> F x; \\<not> b x; I x\\<rbrakk>\n       \\<Longrightarrow> \\<alpha> (creturn x) \\<le> areturn x", "apply (rule transfer_return)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma transfer_WHILE[refine_transfer]:\n  assumes REF: \"\\<And>x. \\<alpha> (f x) \\<le> F x\"\n  shows \"\\<alpha> (cWHILE b f x) \\<le> aWHILE b F x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha> (cWHILE b f x) \\<le> aWHILE b F x", "unfolding c.WHILE_def a.WHILE_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha> (cWHILEI (\\<lambda>_. True) b f x)\n    \\<le> aWHILEI (\\<lambda>_. True) b F x", "using assms"], ["proof (prove)\nusing this:\n  \\<alpha> (f ?x) \\<le> F ?x\n\ngoal (1 subgoal):\n 1. \\<alpha> (cWHILEI (\\<lambda>_. True) b f x)\n    \\<le> aWHILEI (\\<lambda>_. True) b F x", "by (rule transfer_WHILEI)"], ["", "lemma transfer_WHILET[refine_transfer]:\n  assumes REF: \"\\<And>x. \\<alpha> (f x) \\<le> F x\"\n  shows \"\\<alpha> (cWHILET b f x) \\<le> aWHILET b F x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha> (cWHILET b f x) \\<le> aWHILET b F x", "unfolding c.WHILET_def a.WHILET_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha> (cWHILEIT (\\<lambda>_. True) b f x)\n    \\<le> aWHILEIT (\\<lambda>_. True) b F x", "using assms"], ["proof (prove)\nusing this:\n  \\<alpha> (f ?x) \\<le> F ?x\n\ngoal (1 subgoal):\n 1. \\<alpha> (cWHILEIT (\\<lambda>_. True) b f x)\n    \\<le> aWHILEIT (\\<lambda>_. True) b F x", "by (rule transfer_WHILEIT)"], ["", "end"], ["", "locale generic_WHILE_rules = \n  generic_WHILE bind return WHILEIT WHILEI WHILET WHILE\n  for bind return SPEC WHILEIT WHILEI WHILET WHILE +\n  assumes iSPEC_eq: \"SPEC \\<Phi> = Sup {return x  | x. \\<Phi> x}\"\n  assumes ibind_rule: \"\\<lbrakk> M \\<le> SPEC (\\<lambda>x. f x \\<le> SPEC \\<Phi>) \\<rbrakk> \\<Longrightarrow> bind M f \\<le> SPEC \\<Phi>\"\nbegin"], ["", "lemma ireturn_eq: \"return x = SPEC ((=) x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. return x = SPEC ((=) x)", "unfolding iSPEC_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. return x = Sup {return xa |xa. x = xa}", "by auto"], ["", "lemma iSPEC_rule: \"(\\<And>x. \\<Phi> x \\<Longrightarrow> \\<Psi> x) \\<Longrightarrow> SPEC \\<Phi> \\<le> SPEC \\<Psi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x. \\<Phi> x \\<Longrightarrow> \\<Psi> x) \\<Longrightarrow>\n    SPEC \\<Phi> \\<le> SPEC \\<Psi>", "unfolding iSPEC_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x. \\<Phi> x \\<Longrightarrow> \\<Psi> x) \\<Longrightarrow>\n    Sup {return x |x. \\<Phi> x} \\<le> Sup {return x |x. \\<Psi> x}", "by (auto intro: Sup_mono)"], ["", "lemma ireturn_rule: \"\\<Phi> x \\<Longrightarrow> return x \\<le> SPEC \\<Phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Phi> x \\<Longrightarrow> return x \\<le> SPEC \\<Phi>", "unfolding ireturn_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Phi> x \\<Longrightarrow> SPEC ((=) x) \\<le> SPEC \\<Phi>", "by (auto intro: iSPEC_rule)"], ["", "lemma WHILEI_rule:\n  assumes I0: \"I s\"\n  assumes ISTEP: \"\\<And>s. \\<lbrakk>I s; b s\\<rbrakk> \\<Longrightarrow> f s \\<le> SPEC I\"\n  assumes CONS: \"\\<And>s. \\<lbrakk> I s; \\<not> b s \\<rbrakk> \\<Longrightarrow> \\<Phi> s\"\n  shows \"WHILEI I b f s \\<le> SPEC \\<Phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. WHILEI I b f s \\<le> SPEC \\<Phi>", "apply (rule order_trans[where y=\"SPEC (\\<lambda>s. I s \\<and> \\<not> b s)\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. WHILEI I b f s \\<le> SPEC (\\<lambda>s. I s \\<and> \\<not> b s)\n 2. SPEC (\\<lambda>s. I s \\<and> \\<not> b s) \\<le> SPEC \\<Phi>", "apply (unfold WHILEI_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. REC (WHILEI_body bind return I b f) s\n    \\<le> SPEC (\\<lambda>s. I s \\<and> \\<not> b s)\n 2. SPEC (\\<lambda>s. I s \\<and> \\<not> b s) \\<le> SPEC \\<Phi>", "apply (rule REC_rule[OF WHILEI_body_trimono])"], ["proof (prove)\ngoal (3 subgoals):\n 1. ?pre3 s\n 2. \\<And>fa x.\n       \\<lbrakk>\\<And>x.\n                   ?pre3 x \\<Longrightarrow>\n                   fa x \\<le> SPEC (\\<lambda>s. I s \\<and> \\<not> b s);\n        ?pre3 x; fa \\<le> REC (WHILEI_body bind return I b f)\\<rbrakk>\n       \\<Longrightarrow> WHILEI_body bind return I b f fa x\n                         \\<le> SPEC (\\<lambda>s. I s \\<and> \\<not> b s)\n 3. SPEC (\\<lambda>s. I s \\<and> \\<not> b s) \\<le> SPEC \\<Phi>", "apply (rule I0)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>fa x.\n       \\<lbrakk>\\<And>x.\n                   I x \\<Longrightarrow>\n                   fa x \\<le> SPEC (\\<lambda>s. I s \\<and> \\<not> b s);\n        I x; fa \\<le> REC (WHILEI_body bind return I b f)\\<rbrakk>\n       \\<Longrightarrow> WHILEI_body bind return I b f fa x\n                         \\<le> SPEC (\\<lambda>s. I s \\<and> \\<not> b s)\n 2. SPEC (\\<lambda>s. I s \\<and> \\<not> b s) \\<le> SPEC \\<Phi>", "unfolding WHILEI_body_def"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>fa x.\n       \\<lbrakk>\\<And>x.\n                   I x \\<Longrightarrow>\n                   fa x \\<le> SPEC (\\<lambda>s. I s \\<and> \\<not> b s);\n        I x;\n        fa \\<le> REC (\\<lambda>W s.\n                         if I s then if b s then bind (f s) W else return s\n                         else top)\\<rbrakk>\n       \\<Longrightarrow> (if I x\n                          then if b x then bind (f x) fa else return x\n                          else top)\n                         \\<le> SPEC (\\<lambda>s. I s \\<and> \\<not> b s)\n 2. SPEC (\\<lambda>s. I s \\<and> \\<not> b s) \\<le> SPEC \\<Phi>", "apply (split if_split)+"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>fa x.\n       \\<lbrakk>\\<And>x.\n                   I x \\<Longrightarrow>\n                   fa x \\<le> SPEC (\\<lambda>s. I s \\<and> \\<not> b s);\n        I x;\n        fa \\<le> REC (\\<lambda>W s.\n                         if I s then if b s then bind (f s) W else return s\n                         else top)\\<rbrakk>\n       \\<Longrightarrow> (b x \\<longrightarrow>\n                          (I x \\<longrightarrow>\n                           bind (f x) fa\n                           \\<le> SPEC\n                                  (\\<lambda>s.\nI s \\<and> \\<not> b s)) \\<and>\n                          (\\<not> I x \\<longrightarrow>\n                           top\n                           \\<le> SPEC\n                                  (\\<lambda>s.\nI s \\<and> \\<not> b s))) \\<and>\n                         (\\<not> b x \\<longrightarrow>\n                          (I x \\<longrightarrow>\n                           return x\n                           \\<le> SPEC\n                                  (\\<lambda>s.\nI s \\<and> \\<not> b s)) \\<and>\n                          (\\<not> I x \\<longrightarrow>\n                           top\n                           \\<le> SPEC (\\<lambda>s. I s \\<and> \\<not> b s)))\n 2. SPEC (\\<lambda>s. I s \\<and> \\<not> b s) \\<le> SPEC \\<Phi>", "apply (intro impI conjI)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>fa x.\n       \\<lbrakk>\\<And>x.\n                   I x \\<Longrightarrow>\n                   fa x \\<le> SPEC (\\<lambda>s. I s \\<and> \\<not> b s);\n        I x;\n        fa \\<le> REC (\\<lambda>W s.\n                         if I s then if b s then bind (f s) W else return s\n                         else top);\n        b x; I x\\<rbrakk>\n       \\<Longrightarrow> bind (f x) fa\n                         \\<le> SPEC (\\<lambda>s. I s \\<and> \\<not> b s)\n 2. \\<And>fa x.\n       \\<lbrakk>\\<And>x.\n                   I x \\<Longrightarrow>\n                   fa x \\<le> SPEC (\\<lambda>s. I s \\<and> \\<not> b s);\n        I x;\n        fa \\<le> REC (\\<lambda>W s.\n                         if I s then if b s then bind (f s) W else return s\n                         else top);\n        b x; \\<not> I x\\<rbrakk>\n       \\<Longrightarrow> top \\<le> SPEC (\\<lambda>s. I s \\<and> \\<not> b s)\n 3. \\<And>fa x.\n       \\<lbrakk>\\<And>x.\n                   I x \\<Longrightarrow>\n                   fa x \\<le> SPEC (\\<lambda>s. I s \\<and> \\<not> b s);\n        I x;\n        fa \\<le> REC (\\<lambda>W s.\n                         if I s then if b s then bind (f s) W else return s\n                         else top);\n        \\<not> b x; I x\\<rbrakk>\n       \\<Longrightarrow> return x\n                         \\<le> SPEC (\\<lambda>s. I s \\<and> \\<not> b s)\n 4. \\<And>fa x.\n       \\<lbrakk>\\<And>x.\n                   I x \\<Longrightarrow>\n                   fa x \\<le> SPEC (\\<lambda>s. I s \\<and> \\<not> b s);\n        I x;\n        fa \\<le> REC (\\<lambda>W s.\n                         if I s then if b s then bind (f s) W else return s\n                         else top);\n        \\<not> b x; \\<not> I x\\<rbrakk>\n       \\<Longrightarrow> top \\<le> SPEC (\\<lambda>s. I s \\<and> \\<not> b s)\n 5. SPEC (\\<lambda>s. I s \\<and> \\<not> b s) \\<le> SPEC \\<Phi>", "apply simp_all"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>fa x.\n       \\<lbrakk>\\<And>x.\n                   I x \\<Longrightarrow>\n                   fa x \\<le> SPEC (\\<lambda>s. I s \\<and> \\<not> b s);\n        fa \\<le> REC (\\<lambda>W s.\n                         if I s then if b s then bind (f s) W else return s\n                         else top);\n        b x; I x\\<rbrakk>\n       \\<Longrightarrow> bind (f x) fa\n                         \\<le> SPEC (\\<lambda>s. I s \\<and> \\<not> b s)\n 2. \\<And>fa x.\n       \\<lbrakk>\\<And>x.\n                   I x \\<Longrightarrow>\n                   fa x \\<le> SPEC (\\<lambda>s. I s \\<and> \\<not> b s);\n        fa \\<le> REC (\\<lambda>W s.\n                         if I s then if b s then bind (f s) W else return s\n                         else top);\n        \\<not> b x; I x\\<rbrakk>\n       \\<Longrightarrow> return x\n                         \\<le> SPEC (\\<lambda>s. I s \\<and> \\<not> b s)\n 3. SPEC (\\<lambda>s. I s \\<and> \\<not> b s) \\<le> SPEC \\<Phi>", "apply (rule ibind_rule)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>fa x.\n       \\<lbrakk>\\<And>x.\n                   I x \\<Longrightarrow>\n                   fa x \\<le> SPEC (\\<lambda>s. I s \\<and> \\<not> b s);\n        fa \\<le> REC (\\<lambda>W s.\n                         if I s then if b s then bind (f s) W else return s\n                         else top);\n        b x; I x\\<rbrakk>\n       \\<Longrightarrow> f x\n                         \\<le> SPEC\n                                (\\<lambda>x.\n                                    fa x\n                                    \\<le> SPEC\n     (\\<lambda>s. I s \\<and> \\<not> b s))\n 2. \\<And>fa x.\n       \\<lbrakk>\\<And>x.\n                   I x \\<Longrightarrow>\n                   fa x \\<le> SPEC (\\<lambda>s. I s \\<and> \\<not> b s);\n        fa \\<le> REC (\\<lambda>W s.\n                         if I s then if b s then bind (f s) W else return s\n                         else top);\n        \\<not> b x; I x\\<rbrakk>\n       \\<Longrightarrow> return x\n                         \\<le> SPEC (\\<lambda>s. I s \\<and> \\<not> b s)\n 3. SPEC (\\<lambda>s. I s \\<and> \\<not> b s) \\<le> SPEC \\<Phi>", "apply (erule (1) order_trans[OF ISTEP])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>fa x.\n       \\<lbrakk>\\<And>x.\n                   I x \\<Longrightarrow>\n                   fa x \\<le> SPEC (\\<lambda>s. I s \\<and> \\<not> b s);\n        fa \\<le> REC (\\<lambda>W s.\n                         if I s then if b s then bind (f s) W else return s\n                         else top);\n        b x\\<rbrakk>\n       \\<Longrightarrow> SPEC I\n                         \\<le> SPEC\n                                (\\<lambda>x.\n                                    fa x\n                                    \\<le> SPEC\n     (\\<lambda>s. I s \\<and> \\<not> b s))\n 2. \\<And>fa x.\n       \\<lbrakk>\\<And>x.\n                   I x \\<Longrightarrow>\n                   fa x \\<le> SPEC (\\<lambda>s. I s \\<and> \\<not> b s);\n        fa \\<le> REC (\\<lambda>W s.\n                         if I s then if b s then bind (f s) W else return s\n                         else top);\n        \\<not> b x; I x\\<rbrakk>\n       \\<Longrightarrow> return x\n                         \\<le> SPEC (\\<lambda>s. I s \\<and> \\<not> b s)\n 3. SPEC (\\<lambda>s. I s \\<and> \\<not> b s) \\<le> SPEC \\<Phi>", "apply (rule iSPEC_rule, assumption)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>fa x.\n       \\<lbrakk>\\<And>x.\n                   I x \\<Longrightarrow>\n                   fa x \\<le> SPEC (\\<lambda>s. I s \\<and> \\<not> b s);\n        fa \\<le> REC (\\<lambda>W s.\n                         if I s then if b s then bind (f s) W else return s\n                         else top);\n        \\<not> b x; I x\\<rbrakk>\n       \\<Longrightarrow> return x\n                         \\<le> SPEC (\\<lambda>s. I s \\<and> \\<not> b s)\n 2. SPEC (\\<lambda>s. I s \\<and> \\<not> b s) \\<le> SPEC \\<Phi>", "apply (rule ireturn_rule)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>fa x.\n       \\<lbrakk>\\<And>x.\n                   I x \\<Longrightarrow>\n                   fa x \\<le> SPEC (\\<lambda>s. I s \\<and> \\<not> b s);\n        fa \\<le> REC (\\<lambda>W s.\n                         if I s then if b s then bind (f s) W else return s\n                         else top);\n        \\<not> b x; I x\\<rbrakk>\n       \\<Longrightarrow> I x \\<and> \\<not> b x\n 2. SPEC (\\<lambda>s. I s \\<and> \\<not> b s) \\<le> SPEC \\<Phi>", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. SPEC (\\<lambda>s. I s \\<and> \\<not> b s) \\<le> SPEC \\<Phi>", "apply (rule iSPEC_rule)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. I x \\<and> \\<not> b x \\<Longrightarrow> \\<Phi> x", "apply (simp add: CONS)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma WHILEIT_rule:\n  assumes WF: \"wf R\"\n  assumes I0: \"I s\"\n  assumes IS: \"\\<And>s. \\<lbrakk> I s; b s \\<rbrakk> \\<Longrightarrow> f s \\<le> SPEC (\\<lambda>s'. I s' \\<and> (s',s)\\<in>R)\"\n  assumes PHI: \"\\<And>s. \\<lbrakk> I s; \\<not> b s \\<rbrakk> \\<Longrightarrow> \\<Phi> s\"\n  shows \"WHILEIT I b f s \\<le> SPEC \\<Phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. WHILEIT I b f s \\<le> SPEC \\<Phi>", "unfolding WHILEIT_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. REC\\<^sub>T (WHILEI_body bind return I b f) s \\<le> SPEC \\<Phi>", "apply (rule RECT_rule[OF WHILEI_body_trimono WF, where pre=I,OF I0])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>fa x.\n       \\<lbrakk>\\<And>x'.\n                   \\<lbrakk>I x'; (x', x) \\<in> R\\<rbrakk>\n                   \\<Longrightarrow> fa x' \\<le> SPEC \\<Phi>;\n        I x; REC\\<^sub>T (WHILEI_body bind return I b f) = fa\\<rbrakk>\n       \\<Longrightarrow> WHILEI_body bind return I b f fa x\n                         \\<le> SPEC \\<Phi>", "unfolding WHILEI_body_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>fa x.\n       \\<lbrakk>\\<And>x'.\n                   \\<lbrakk>I x'; (x', x) \\<in> R\\<rbrakk>\n                   \\<Longrightarrow> fa x' \\<le> SPEC \\<Phi>;\n        I x;\n        REC\\<^sub>T\n         (\\<lambda>W s.\n             if I s then if b s then bind (f s) W else return s else top) =\n        fa\\<rbrakk>\n       \\<Longrightarrow> (if I x\n                          then if b x then bind (f x) fa else return x\n                          else top)\n                         \\<le> SPEC \\<Phi>", "apply (split if_split)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>fa x.\n       \\<lbrakk>\\<And>x'.\n                   \\<lbrakk>I x'; (x', x) \\<in> R\\<rbrakk>\n                   \\<Longrightarrow> fa x' \\<le> SPEC \\<Phi>;\n        I x;\n        REC\\<^sub>T\n         (\\<lambda>W s.\n             if I s then if b s then bind (f s) W else return s else top) =\n        fa\\<rbrakk>\n       \\<Longrightarrow> (b x \\<longrightarrow>\n                          (I x \\<longrightarrow>\n                           bind (f x) fa \\<le> SPEC \\<Phi>) \\<and>\n                          (\\<not> I x \\<longrightarrow>\n                           top \\<le> SPEC \\<Phi>)) \\<and>\n                         (\\<not> b x \\<longrightarrow>\n                          (I x \\<longrightarrow>\n                           return x \\<le> SPEC \\<Phi>) \\<and>\n                          (\\<not> I x \\<longrightarrow>\n                           top \\<le> SPEC \\<Phi>))", "apply (intro impI conjI)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>fa x.\n       \\<lbrakk>\\<And>x'.\n                   \\<lbrakk>I x'; (x', x) \\<in> R\\<rbrakk>\n                   \\<Longrightarrow> fa x' \\<le> SPEC \\<Phi>;\n        I x;\n        REC\\<^sub>T\n         (\\<lambda>W s.\n             if I s then if b s then bind (f s) W else return s else top) =\n        fa;\n        b x; I x\\<rbrakk>\n       \\<Longrightarrow> bind (f x) fa \\<le> SPEC \\<Phi>\n 2. \\<And>fa x.\n       \\<lbrakk>\\<And>x'.\n                   \\<lbrakk>I x'; (x', x) \\<in> R\\<rbrakk>\n                   \\<Longrightarrow> fa x' \\<le> SPEC \\<Phi>;\n        I x;\n        REC\\<^sub>T\n         (\\<lambda>W s.\n             if I s then if b s then bind (f s) W else return s else top) =\n        fa;\n        b x; \\<not> I x\\<rbrakk>\n       \\<Longrightarrow> top \\<le> SPEC \\<Phi>\n 3. \\<And>fa x.\n       \\<lbrakk>\\<And>x'.\n                   \\<lbrakk>I x'; (x', x) \\<in> R\\<rbrakk>\n                   \\<Longrightarrow> fa x' \\<le> SPEC \\<Phi>;\n        I x;\n        REC\\<^sub>T\n         (\\<lambda>W s.\n             if I s then if b s then bind (f s) W else return s else top) =\n        fa;\n        \\<not> b x; I x\\<rbrakk>\n       \\<Longrightarrow> return x \\<le> SPEC \\<Phi>\n 4. \\<And>fa x.\n       \\<lbrakk>\\<And>x'.\n                   \\<lbrakk>I x'; (x', x) \\<in> R\\<rbrakk>\n                   \\<Longrightarrow> fa x' \\<le> SPEC \\<Phi>;\n        I x;\n        REC\\<^sub>T\n         (\\<lambda>W s.\n             if I s then if b s then bind (f s) W else return s else top) =\n        fa;\n        \\<not> b x; \\<not> I x\\<rbrakk>\n       \\<Longrightarrow> top \\<le> SPEC \\<Phi>", "apply simp_all"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>fa x.\n       \\<lbrakk>\\<And>x'.\n                   \\<lbrakk>I x'; (x', x) \\<in> R\\<rbrakk>\n                   \\<Longrightarrow> fa x' \\<le> SPEC \\<Phi>;\n        REC\\<^sub>T\n         (\\<lambda>W s.\n             if I s then if b s then bind (f s) W else return s else top) =\n        fa;\n        b x; I x\\<rbrakk>\n       \\<Longrightarrow> bind (f x) fa \\<le> SPEC \\<Phi>\n 2. \\<And>fa x.\n       \\<lbrakk>\\<And>x'.\n                   \\<lbrakk>I x'; (x', x) \\<in> R\\<rbrakk>\n                   \\<Longrightarrow> fa x' \\<le> SPEC \\<Phi>;\n        REC\\<^sub>T\n         (\\<lambda>W s.\n             if I s then if b s then bind (f s) W else return s else top) =\n        fa;\n        \\<not> b x; I x\\<rbrakk>\n       \\<Longrightarrow> return x \\<le> SPEC \\<Phi>", "apply (rule ibind_rule)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>fa x.\n       \\<lbrakk>\\<And>x'.\n                   \\<lbrakk>I x'; (x', x) \\<in> R\\<rbrakk>\n                   \\<Longrightarrow> fa x' \\<le> SPEC \\<Phi>;\n        REC\\<^sub>T\n         (\\<lambda>W s.\n             if I s then if b s then bind (f s) W else return s else top) =\n        fa;\n        b x; I x\\<rbrakk>\n       \\<Longrightarrow> f x \\<le> SPEC (\\<lambda>x. fa x \\<le> SPEC \\<Phi>)\n 2. \\<And>fa x.\n       \\<lbrakk>\\<And>x'.\n                   \\<lbrakk>I x'; (x', x) \\<in> R\\<rbrakk>\n                   \\<Longrightarrow> fa x' \\<le> SPEC \\<Phi>;\n        REC\\<^sub>T\n         (\\<lambda>W s.\n             if I s then if b s then bind (f s) W else return s else top) =\n        fa;\n        \\<not> b x; I x\\<rbrakk>\n       \\<Longrightarrow> return x \\<le> SPEC \\<Phi>", "apply (rule order_trans[OF IS], assumption+)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>fa x.\n       \\<lbrakk>\\<And>x'.\n                   \\<lbrakk>I x'; (x', x) \\<in> R\\<rbrakk>\n                   \\<Longrightarrow> fa x' \\<le> SPEC \\<Phi>;\n        REC\\<^sub>T\n         (\\<lambda>W s.\n             if I s then if b s then bind (f s) W else return s else top) =\n        fa;\n        b x; I x\\<rbrakk>\n       \\<Longrightarrow> SPEC (\\<lambda>s'. I s' \\<and> (s', x) \\<in> R)\n                         \\<le> SPEC (\\<lambda>x. fa x \\<le> SPEC \\<Phi>)\n 2. \\<And>fa x.\n       \\<lbrakk>\\<And>x'.\n                   \\<lbrakk>I x'; (x', x) \\<in> R\\<rbrakk>\n                   \\<Longrightarrow> fa x' \\<le> SPEC \\<Phi>;\n        REC\\<^sub>T\n         (\\<lambda>W s.\n             if I s then if b s then bind (f s) W else return s else top) =\n        fa;\n        \\<not> b x; I x\\<rbrakk>\n       \\<Longrightarrow> return x \\<le> SPEC \\<Phi>", "apply (rule iSPEC_rule)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>fa x xa.\n       \\<lbrakk>\\<And>x'.\n                   \\<lbrakk>I x'; (x', x) \\<in> R\\<rbrakk>\n                   \\<Longrightarrow> fa x' \\<le> SPEC \\<Phi>;\n        REC\\<^sub>T\n         (\\<lambda>W s.\n             if I s then if b s then bind (f s) W else return s else top) =\n        fa;\n        b x; I x; I xa \\<and> (xa, x) \\<in> R\\<rbrakk>\n       \\<Longrightarrow> fa xa \\<le> SPEC \\<Phi>\n 2. \\<And>fa x.\n       \\<lbrakk>\\<And>x'.\n                   \\<lbrakk>I x'; (x', x) \\<in> R\\<rbrakk>\n                   \\<Longrightarrow> fa x' \\<le> SPEC \\<Phi>;\n        REC\\<^sub>T\n         (\\<lambda>W s.\n             if I s then if b s then bind (f s) W else return s else top) =\n        fa;\n        \\<not> b x; I x\\<rbrakk>\n       \\<Longrightarrow> return x \\<le> SPEC \\<Phi>", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>fa x.\n       \\<lbrakk>\\<And>x'.\n                   \\<lbrakk>I x'; (x', x) \\<in> R\\<rbrakk>\n                   \\<Longrightarrow> fa x' \\<le> SPEC \\<Phi>;\n        REC\\<^sub>T\n         (\\<lambda>W s.\n             if I s then if b s then bind (f s) W else return s else top) =\n        fa;\n        \\<not> b x; I x\\<rbrakk>\n       \\<Longrightarrow> return x \\<le> SPEC \\<Phi>", "apply (rule ireturn_rule)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>fa x.\n       \\<lbrakk>\\<And>x'.\n                   \\<lbrakk>I x'; (x', x) \\<in> R\\<rbrakk>\n                   \\<Longrightarrow> fa x' \\<le> SPEC \\<Phi>;\n        REC\\<^sub>T\n         (\\<lambda>W s.\n             if I s then if b s then bind (f s) W else return s else top) =\n        fa;\n        \\<not> b x; I x\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> x", "apply (simp add: PHI)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma WHILE_rule:\n  assumes I0: \"I s\"\n  assumes ISTEP: \"\\<And>s. \\<lbrakk>I s; b s\\<rbrakk> \\<Longrightarrow> f s \\<le> SPEC I\"\n  assumes CONS: \"\\<And>s. \\<lbrakk> I s; \\<not> b s \\<rbrakk> \\<Longrightarrow> \\<Phi> s\"\n  shows \"WHILE b f s \\<le> SPEC \\<Phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. WHILE b f s \\<le> SPEC \\<Phi>", "unfolding WHILE_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. WHILEI (\\<lambda>_. True) b f s \\<le> SPEC \\<Phi>", "apply (rule order_trans[OF WHILEI_weaken WHILEI_rule])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x. ?I2 x \\<Longrightarrow> True\n 2. ?I2 s\n 3. \\<And>s.\n       \\<lbrakk>?I2 s; b s\\<rbrakk> \\<Longrightarrow> f s \\<le> SPEC ?I2\n 4. \\<And>s. \\<lbrakk>?I2 s; \\<not> b s\\<rbrakk> \\<Longrightarrow> \\<Phi> s", "apply (rule TrueI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. ?I2 s\n 2. \\<And>s.\n       \\<lbrakk>?I2 s; b s\\<rbrakk> \\<Longrightarrow> f s \\<le> SPEC ?I2\n 3. \\<And>s. \\<lbrakk>?I2 s; \\<not> b s\\<rbrakk> \\<Longrightarrow> \\<Phi> s", "apply (rule I0)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s. \\<lbrakk>I s; b s\\<rbrakk> \\<Longrightarrow> f s \\<le> SPEC I\n 2. \\<And>s. \\<lbrakk>I s; \\<not> b s\\<rbrakk> \\<Longrightarrow> \\<Phi> s", "using assms"], ["proof (prove)\nusing this:\n  I s\n  \\<lbrakk>I ?s; b ?s\\<rbrakk> \\<Longrightarrow> f ?s \\<le> SPEC I\n  \\<lbrakk>I ?s; \\<not> b ?s\\<rbrakk> \\<Longrightarrow> \\<Phi> ?s\n\ngoal (2 subgoals):\n 1. \\<And>s. \\<lbrakk>I s; b s\\<rbrakk> \\<Longrightarrow> f s \\<le> SPEC I\n 2. \\<And>s. \\<lbrakk>I s; \\<not> b s\\<rbrakk> \\<Longrightarrow> \\<Phi> s", "by auto"], ["", "lemma WHILET_rule:\n  assumes WF: \"wf R\"\n  assumes I0: \"I s\"\n  assumes IS: \"\\<And>s. \\<lbrakk> I s; b s \\<rbrakk> \\<Longrightarrow> f s \\<le> SPEC (\\<lambda>s'. I s' \\<and> (s',s)\\<in>R)\"\n  assumes PHI: \"\\<And>s. \\<lbrakk> I s; \\<not> b s \\<rbrakk> \\<Longrightarrow> \\<Phi> s\"\n  shows \"WHILET b f s \\<le> SPEC \\<Phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. WHILET b f s \\<le> SPEC \\<Phi>", "unfolding WHILET_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. WHILEIT (\\<lambda>_. True) b f s \\<le> SPEC \\<Phi>", "apply (rule order_trans[OF WHILEIT_weaken WHILEIT_rule])"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x. ?I2 x \\<Longrightarrow> True\n 2. wf ?R2\n 3. ?I2 s\n 4. \\<And>s.\n       \\<lbrakk>?I2 s; b s\\<rbrakk>\n       \\<Longrightarrow> f s\n                         \\<le> SPEC\n                                (\\<lambda>s'.\n                                    ?I2 s' \\<and> (s', s) \\<in> ?R2)\n 5. \\<And>s. \\<lbrakk>?I2 s; \\<not> b s\\<rbrakk> \\<Longrightarrow> \\<Phi> s", "apply (rule TrueI)"], ["proof (prove)\ngoal (4 subgoals):\n 1. wf ?R2\n 2. ?I2 s\n 3. \\<And>s.\n       \\<lbrakk>?I2 s; b s\\<rbrakk>\n       \\<Longrightarrow> f s\n                         \\<le> SPEC\n                                (\\<lambda>s'.\n                                    ?I2 s' \\<and> (s', s) \\<in> ?R2)\n 4. \\<And>s. \\<lbrakk>?I2 s; \\<not> b s\\<rbrakk> \\<Longrightarrow> \\<Phi> s", "apply (rule WF)"], ["proof (prove)\ngoal (3 subgoals):\n 1. ?I2 s\n 2. \\<And>s.\n       \\<lbrakk>?I2 s; b s\\<rbrakk>\n       \\<Longrightarrow> f s\n                         \\<le> SPEC\n                                (\\<lambda>s'. ?I2 s' \\<and> (s', s) \\<in> R)\n 3. \\<And>s. \\<lbrakk>?I2 s; \\<not> b s\\<rbrakk> \\<Longrightarrow> \\<Phi> s", "apply (rule I0)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>I s; b s\\<rbrakk>\n       \\<Longrightarrow> f s\n                         \\<le> SPEC\n                                (\\<lambda>s'. I s' \\<and> (s', s) \\<in> R)\n 2. \\<And>s. \\<lbrakk>I s; \\<not> b s\\<rbrakk> \\<Longrightarrow> \\<Phi> s", "using assms"], ["proof (prove)\nusing this:\n  wf R\n  I s\n  \\<lbrakk>I ?s; b ?s\\<rbrakk>\n  \\<Longrightarrow> f ?s\n                    \\<le> SPEC (\\<lambda>s'. I s' \\<and> (s', ?s) \\<in> R)\n  \\<lbrakk>I ?s; \\<not> b ?s\\<rbrakk> \\<Longrightarrow> \\<Phi> ?s\n\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>I s; b s\\<rbrakk>\n       \\<Longrightarrow> f s\n                         \\<le> SPEC\n                                (\\<lambda>s'. I s' \\<and> (s', s) \\<in> R)\n 2. \\<And>s. \\<lbrakk>I s; \\<not> b s\\<rbrakk> \\<Longrightarrow> \\<Phi> s", "by auto"], ["", "end"], ["", "end"]]}