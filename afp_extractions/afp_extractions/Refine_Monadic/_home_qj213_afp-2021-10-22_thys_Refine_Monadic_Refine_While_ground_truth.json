{"file_name": "/home/qj213/afp-2021-10-22/thys/Refine_Monadic/Refine_While.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Refine_Monadic", "problem_names": ["lemmas [refine_vcg] = WHILEI_rule", "lemmas [refine_vcg] = WHILEIT_rule", "lemma ref_WHILEI_invarI:\n  assumes \"I s \\<Longrightarrow> M \\<le> \\<Down>R (WHILEI I b f s)\"\n  shows \"M \\<le> \\<Down>R (WHILEI I b f s)\"", "lemma ref_WHILEIT_invarI:\n  assumes \"I s \\<Longrightarrow> M \\<le> \\<Down>R (WHILEIT I b f s)\"\n  shows \"M \\<le> \\<Down>R (WHILEIT I b f s)\"", "lemma WHILEI_le_rule:\n  assumes R0: \"(s,s')\\<in>R\"\n  assumes RS: \"\\<And>W s s'. \\<lbrakk>\\<And>s s'. (s,s')\\<in>R \\<Longrightarrow> W s \\<le> M s'; (s,s')\\<in>R\\<rbrakk> \\<Longrightarrow> \n    do {ASSERT (I s); if b s then bind (f s) W else RETURN s} \\<le> M s'\"\n  shows \"WHILEI I b f s \\<le> M s'\"", "lemma WHILEI_invisible_refine_genR:\n  assumes R0: \"I' s' \\<Longrightarrow> (s,s')\\<in>R'\"\n  assumes RI: \"\\<And>s s'. \\<lbrakk> (s,s')\\<in>R'; I' s' \\<rbrakk> \\<Longrightarrow> I s\"\n  assumes RB: \"\\<And>s s'. \\<lbrakk> (s,s')\\<in>R'; I' s'; I s; b' s' \\<rbrakk> \\<Longrightarrow> b s\"\n  assumes RS: \"\\<And>s s'. \\<lbrakk> (s,s')\\<in>R'; I' s'; I s; b s \\<rbrakk> \n    \\<Longrightarrow> f s \\<le> sup (\\<Down>R' (do {ASSUME (b' s'); f' s'})) (\\<Down>R' (RETURN s'))\"\n  assumes R_REF: \n    \"\\<And>x x'. \\<lbrakk> (x,x')\\<in>R'; \\<not>b x; \\<not>b' x'; I x; I' x' \\<rbrakk> \\<Longrightarrow> (x,x')\\<in>R\"\n  shows \"WHILEI I b f s \\<le> \\<Down>R (WHILEI I' b' f' s')\"", "lemma WHILEI_refine_genR:\n  assumes R0: \"I' x' \\<Longrightarrow> (x,x')\\<in>R'\"\n  assumes IREF: \"\\<And>x x'. \\<lbrakk> (x,x')\\<in>R'; I' x' \\<rbrakk> \\<Longrightarrow> I x\"\n  assumes COND_REF: \"\\<And>x x'. \\<lbrakk> (x,x')\\<in>R'; I x; I' x' \\<rbrakk> \\<Longrightarrow> b x = b' x'\"\n  assumes STEP_REF: \n    \"\\<And>x x'. \\<lbrakk> (x,x')\\<in>R'; b x; b' x'; I x; I' x' \\<rbrakk> \\<Longrightarrow> f x \\<le> \\<Down>R' (f' x')\"\n  assumes R_REF: \n    \"\\<And>x x'. \\<lbrakk> (x,x')\\<in>R'; \\<not>b x; \\<not>b' x'; I x; I' x' \\<rbrakk> \\<Longrightarrow> (x,x')\\<in>R\"\n  shows \"WHILEI I b f x \\<le>\\<Down>R (WHILEI I' b' f' x')\"", "lemma WHILE_invisible_refine_genR:\n  assumes R0: \"(s,s')\\<in>R'\"\n  assumes RB: \"\\<And>s s'. \\<lbrakk> (s,s')\\<in>R'; b' s' \\<rbrakk> \\<Longrightarrow> b s\"\n  assumes RS: \"\\<And>s s'. \\<lbrakk> (s,s')\\<in>R'; b s \\<rbrakk> \n    \\<Longrightarrow> f s \\<le> sup (\\<Down>R' (do {ASSUME (b' s'); f' s'})) (\\<Down>R' (RETURN s'))\"\n  assumes R_REF: \n    \"\\<And>x x'. \\<lbrakk> (x,x')\\<in>R'; \\<not>b x; \\<not>b' x' \\<rbrakk> \\<Longrightarrow> (x,x')\\<in>R\"\n  shows \"WHILE b f s \\<le> \\<Down>R (WHILE b' f' s')\"", "lemma WHILE_refine_genR:\n  assumes R0: \"(x,x')\\<in>R'\"\n  assumes COND_REF: \"\\<And>x x'. \\<lbrakk> (x,x')\\<in>R' \\<rbrakk> \\<Longrightarrow> b x = b' x'\"\n  assumes STEP_REF: \n    \"\\<And>x x'. \\<lbrakk> (x,x')\\<in>R'; b x; b' x' \\<rbrakk> \\<Longrightarrow> f x \\<le> \\<Down>R' (f' x')\"\n  assumes R_REF: \n    \"\\<And>x x'. \\<lbrakk> (x,x')\\<in>R'; \\<not>b x; \\<not>b' x' \\<rbrakk> \\<Longrightarrow> (x,x')\\<in>R\"\n  shows \"WHILE b f x \\<le>\\<Down>R (WHILE b' f' x')\"", "lemma WHILE_refine_genR':\n  assumes R0: \"(x,x')\\<in>R'\"\n  assumes COND_REF: \"\\<And>x x'. \\<lbrakk> (x,x')\\<in>R'; I' x' \\<rbrakk> \\<Longrightarrow> b x = b' x'\"\n  assumes STEP_REF: \n    \"\\<And>x x'. \\<lbrakk> (x,x')\\<in>R'; b x; b' x'; I' x' \\<rbrakk> \\<Longrightarrow> f x \\<le> \\<Down>R' (f' x')\"\n  assumes R_REF: \n    \"\\<And>x x'. \\<lbrakk> (x,x')\\<in>R'; \\<not>b x; \\<not>b' x' \\<rbrakk> \\<Longrightarrow> (x,x')\\<in>R\"\n  shows \"WHILE b f x \\<le>\\<Down>R (WHILEI I' b' f' x')\"", "lemma WHILEI_invisible_refine:\n  assumes R0: \"I' s' \\<Longrightarrow> (s,s')\\<in>R\"\n  assumes RI: \"\\<And>s s'. \\<lbrakk> (s,s')\\<in>R; I' s' \\<rbrakk> \\<Longrightarrow> I s\"\n  assumes RB: \"\\<And>s s'. \\<lbrakk> (s,s')\\<in>R; I' s'; I s; b' s' \\<rbrakk> \\<Longrightarrow> b s\"\n  assumes RS: \"\\<And>s s'. \\<lbrakk> (s,s')\\<in>R; I' s'; I s; b s \\<rbrakk> \n    \\<Longrightarrow> f s \\<le> sup (\\<Down>R (do {ASSUME (b' s'); f' s'})) (\\<Down>R (RETURN s'))\"\n  shows \"WHILEI I b f s \\<le> \\<Down>R (WHILEI I' b' f' s')\"", "lemma WHILEI_refine[refine]:\n  assumes R0: \"I' x' \\<Longrightarrow> (x,x')\\<in>R\"\n  assumes IREF: \"\\<And>x x'. \\<lbrakk> (x,x')\\<in>R; I' x' \\<rbrakk> \\<Longrightarrow> I x\"\n  assumes COND_REF: \"\\<And>x x'. \\<lbrakk> (x,x')\\<in>R; I x; I' x' \\<rbrakk> \\<Longrightarrow> b x = b' x'\"\n  assumes STEP_REF: \n    \"\\<And>x x'. \\<lbrakk> (x,x')\\<in>R; b x; b' x'; I x; I' x' \\<rbrakk> \\<Longrightarrow> f x \\<le> \\<Down>R (f' x')\"\n  shows \"WHILEI I b f x \\<le>\\<Down>R (WHILEI I' b' f' x')\"", "lemma WHILE_invisible_refine:\n  assumes R0: \"(s,s')\\<in>R\"\n  assumes RB: \"\\<And>s s'. \\<lbrakk> (s,s')\\<in>R; b' s' \\<rbrakk> \\<Longrightarrow> b s\"\n  assumes RS: \"\\<And>s s'. \\<lbrakk> (s,s')\\<in>R; b s \\<rbrakk> \n    \\<Longrightarrow> f s \\<le> sup (\\<Down>R (do {ASSUME (b' s'); f' s'})) (\\<Down>R (RETURN s'))\"\n  shows \"WHILE b f s \\<le> \\<Down>R (WHILE b' f' s')\"", "lemma WHILE_le_rule:\n  assumes R0: \"(s,s')\\<in>R\"\n  assumes RS: \"\\<And>W s s'. \\<lbrakk>\\<And>s s'. (s,s')\\<in>R \\<Longrightarrow> W s \\<le> M s'; (s,s')\\<in>R\\<rbrakk> \\<Longrightarrow> \n    do {if b s then bind (f s) W else RETURN s} \\<le> M s'\"\n  shows \"WHILE b f s \\<le> M s'\"", "lemma WHILE_refine[refine]:\n  assumes R0: \"(x,x')\\<in>R\"\n  assumes COND_REF: \"\\<And>x x'. \\<lbrakk> (x,x')\\<in>R \\<rbrakk> \\<Longrightarrow> b x = b' x'\"\n  assumes STEP_REF: \n    \"\\<And>x x'. \\<lbrakk> (x,x')\\<in>R; b x; b' x' \\<rbrakk> \\<Longrightarrow> f x \\<le> \\<Down>R (f' x')\"\n  shows \"WHILE b f x \\<le>\\<Down>R (WHILE b' f' x')\"", "lemma WHILE_refine'[refine]:\n  assumes R0: \"I' x' \\<Longrightarrow> (x,x')\\<in>R\"\n  assumes COND_REF: \"\\<And>x x'. \\<lbrakk> (x,x')\\<in>R; I' x' \\<rbrakk> \\<Longrightarrow> b x = b' x'\"\n  assumes STEP_REF: \n    \"\\<And>x x'. \\<lbrakk> (x,x')\\<in>R; b x; b' x'; I' x' \\<rbrakk> \\<Longrightarrow> f x \\<le> \\<Down>R (f' x')\"\n  shows \"WHILE b f x \\<le>\\<Down>R (WHILEI I' b' f' x')\"", "lemma AIF_leI: \"\\<lbrakk>\\<Phi>; \\<Phi> \\<Longrightarrow> S\\<le>S'\\<rbrakk> \\<Longrightarrow> (if \\<Phi> then S else FAIL) \\<le> S'\"", "lemma ref_AIFI: \"\\<lbrakk>\\<Phi> \\<Longrightarrow> S\\<le>\\<Down>R S'\\<rbrakk> \\<Longrightarrow> S \\<le> \\<Down>R (if \\<Phi> then S' else FAIL)\"", "lemma WHILEIT_refine_genR:\n  assumes R0: \"I' x' \\<Longrightarrow> (x,x')\\<in>R'\"\n  assumes IREF: \"\\<And>x x'. \\<lbrakk> (x,x')\\<in>R'; I' x' \\<rbrakk> \\<Longrightarrow> I x\"\n  assumes COND_REF: \"\\<And>x x'. \\<lbrakk> (x,x')\\<in>R'; I x; I' x' \\<rbrakk> \\<Longrightarrow> b x = b' x'\"\n  assumes STEP_REF: \n    \"\\<And>x x'. \\<lbrakk> (x,x')\\<in>R'; b x; b' x'; I x; I' x' \\<rbrakk> \\<Longrightarrow> f x \\<le> \\<Down>R' (f' x')\"\n  assumes R_REF: \n    \"\\<And>x x'. \\<lbrakk> (x,x')\\<in>R'; \\<not>b x; \\<not>b' x'; I x; I' x' \\<rbrakk> \\<Longrightarrow> (x,x')\\<in>R\"\n  shows \"WHILEIT I b f x \\<le>\\<Down>R (WHILEIT I' b' f' x')\"", "lemma WHILET_refine_genR:\n  assumes R0: \"(x,x')\\<in>R'\"\n  assumes COND_REF: \"\\<And>x x'. (x,x')\\<in>R' \\<Longrightarrow> b x = b' x'\"\n  assumes STEP_REF: \n    \"\\<And>x x'. \\<lbrakk> (x,x')\\<in>R'; b x; b' x' \\<rbrakk> \\<Longrightarrow> f x \\<le> \\<Down>R' (f' x')\"\n  assumes R_REF: \n    \"\\<And>x x'. \\<lbrakk> (x,x')\\<in>R'; \\<not>b x; \\<not>b' x' \\<rbrakk> \\<Longrightarrow> (x,x')\\<in>R\"\n  shows \"WHILET b f x \\<le>\\<Down>R (WHILET b' f' x')\"", "lemma WHILET_refine_genR':\n  assumes R0: \"I' x' \\<Longrightarrow> (x,x')\\<in>R'\"\n  assumes COND_REF: \"\\<And>x x'. \\<lbrakk> (x,x')\\<in>R'; I' x' \\<rbrakk> \\<Longrightarrow> b x = b' x'\"\n  assumes STEP_REF: \n    \"\\<And>x x'. \\<lbrakk> (x,x')\\<in>R'; b x; b' x'; I' x' \\<rbrakk> \\<Longrightarrow> f x \\<le> \\<Down>R' (f' x')\"\n  assumes R_REF: \n    \"\\<And>x x'. \\<lbrakk> (x,x')\\<in>R'; \\<not>b x; \\<not>b' x'; I' x' \\<rbrakk> \\<Longrightarrow> (x,x')\\<in>R\"\n  shows \"WHILET b f x \\<le>\\<Down>R (WHILEIT I' b' f' x')\"", "lemma WHILEIT_refine[refine]:\n  assumes R0: \"I' x' \\<Longrightarrow> (x,x')\\<in>R\"\n  assumes IREF: \"\\<And>x x'. \\<lbrakk> (x,x')\\<in>R; I' x' \\<rbrakk> \\<Longrightarrow> I x\"\n  assumes COND_REF: \"\\<And>x x'. \\<lbrakk> (x,x')\\<in>R; I x; I' x' \\<rbrakk> \\<Longrightarrow> b x = b' x'\"\n  assumes STEP_REF: \n    \"\\<And>x x'. \\<lbrakk> (x,x')\\<in>R; b x; b' x'; I x; I' x' \\<rbrakk> \\<Longrightarrow> f x \\<le> \\<Down>R (f' x')\"\n  shows \"WHILEIT I b f x \\<le>\\<Down>R (WHILEIT I' b' f' x')\"", "lemma WHILET_refine[refine]:\n  assumes R0: \"(x,x')\\<in>R\"\n  assumes COND_REF: \"\\<And>x x'. \\<lbrakk> (x,x')\\<in>R \\<rbrakk> \\<Longrightarrow> b x = b' x'\"\n  assumes STEP_REF: \n    \"\\<And>x x'. \\<lbrakk> (x,x')\\<in>R; b x; b' x' \\<rbrakk> \\<Longrightarrow> f x \\<le> \\<Down>R (f' x')\"\n  shows \"WHILET b f x \\<le>\\<Down>R (WHILET b' f' x')\"", "lemma WHILET_refine'[refine]:\n  assumes R0: \"I' x' \\<Longrightarrow> (x,x')\\<in>R\"\n  assumes COND_REF: \"\\<And>x x'. \\<lbrakk> (x,x')\\<in>R; I' x' \\<rbrakk> \\<Longrightarrow> b x = b' x'\"\n  assumes STEP_REF: \n    \"\\<And>x x'. \\<lbrakk> (x,x')\\<in>R; b x; b' x'; I' x' \\<rbrakk> \\<Longrightarrow> f x \\<le> \\<Down>R (f' x')\"\n  shows \"WHILET b f x \\<le>\\<Down>R (WHILEIT I' b' f' x')\"", "lemma WHILEI_refine_new_invar:\n  assumes R0: \"I' x' \\<Longrightarrow> (x,x')\\<in>R\"\n  assumes INV0: \"\\<lbrakk> I' x'; (x,x')\\<in>R \\<rbrakk> \\<Longrightarrow> I x\"\n  assumes COND_REF: \"\\<And>x x'. \\<lbrakk> (x,x')\\<in>R; I x; I' x' \\<rbrakk> \\<Longrightarrow> b x = b' x'\"\n  assumes STEP_REF: \n    \"\\<And>x x'. \\<lbrakk> (x,x')\\<in>R; b x; b' x'; I x; I' x' \\<rbrakk> \\<Longrightarrow> f x \\<le> \\<Down>R (f' x')\"\n  assumes STEP_INV: \n    \"\\<And>x x'. \\<lbrakk> (x,x')\\<in>R; b x; b' x'; I x; I' x'; nofail (f x) \\<rbrakk> \\<Longrightarrow> f x \\<le> SPEC I\"\n  shows \"WHILEI I b f x \\<le>\\<Down>R (WHILEI I' b' f' x')\"", "lemma WHILEIT_refine_new_invar:\n  assumes R0: \"I' x' \\<Longrightarrow> (x,x')\\<in>R\"\n  assumes INV0: \"\\<lbrakk> I' x'; (x,x')\\<in>R \\<rbrakk> \\<Longrightarrow> I x\"\n  assumes COND_REF: \"\\<And>x x'. \\<lbrakk> (x,x')\\<in>R; I x; I' x' \\<rbrakk> \\<Longrightarrow> b x = b' x'\"\n  assumes STEP_REF: \n    \"\\<And>x x'. \\<lbrakk> (x,x')\\<in>R; b x; b' x'; I x; I' x' \\<rbrakk> \\<Longrightarrow> f x \\<le> \\<Down>R (f' x')\"\n  assumes STEP_INV: \n    \"\\<And>x x'. \\<lbrakk> nofail (f x); (x,x')\\<in>R; b x; b' x'; I x; I' x' \\<rbrakk> \\<Longrightarrow> f x \\<le> SPEC I\"\n  shows \"WHILEIT I b f x \\<le>\\<Down>R (WHILEIT I' b' f' x')\"", "lemma [autoref_op_pat_def]:\n  \"WHILEIT I \\<equiv> OP (WHILEIT I)\"\n  \"WHILEI I \\<equiv> OP (WHILEI I)\"", "lemma autoref_WHILET[autoref_rules]:\n  assumes \"\\<And>x x'. \\<lbrakk> (x,x')\\<in>R\\<rbrakk> \\<Longrightarrow> (c x,c'$x') \\<in> Id\"\n  assumes \"\\<And>x x'. \\<lbrakk> REMOVE_INTERNAL c' x'; (x,x')\\<in>R\\<rbrakk> \n    \\<Longrightarrow> (f x,f'$x') \\<in> \\<langle>R\\<rangle>nres_rel\"\n  assumes \"(s,s')\\<in>R\"\n  shows \"(WHILET c f s,\n    (OP WHILET:::(R\\<rightarrow>Id)\\<rightarrow>(R\\<rightarrow>\\<langle>R\\<rangle>nres_rel)\\<rightarrow>R\\<rightarrow>\\<langle>R\\<rangle>nres_rel)$c'$f'$s')\n   \\<in> \\<langle>R\\<rangle>nres_rel\"", "lemma autoref_WHILEIT[autoref_rules]:\n  assumes \"\\<And>x x'. \\<lbrakk>I x'; (x,x')\\<in>R\\<rbrakk> \\<Longrightarrow> (c x,c'$x') \\<in> Id\"\n  assumes \"\\<And>x x'. \\<lbrakk>REMOVE_INTERNAL c' x'; I x'; (x,x')\\<in>R\\<rbrakk> \\<Longrightarrow>(f x,f'$x') \\<in> \\<langle>R\\<rangle>nres_rel\"\n  assumes \"I s' \\<Longrightarrow> (s,s')\\<in>R\"\n  shows \"(WHILET c f s,\n      (OP (WHILEIT I) ::: (R\\<rightarrow>Id) \\<rightarrow> (R\\<rightarrow>\\<langle>R\\<rangle>nres_rel) \\<rightarrow> R \\<rightarrow> \\<langle>R\\<rangle>nres_rel)$c'$f'$s'\n    )\\<in>\\<langle>R\\<rangle>nres_rel\"", "lemma autoref_WHILEIT'[autoref_rules]:\n  assumes \"\\<And>x x'. \\<lbrakk> (x,x')\\<in>R; I x'\\<rbrakk> \\<Longrightarrow> (c x,c'$x') \\<in> Id\"\n  assumes \"\\<And>x x'. \\<lbrakk> REMOVE_INTERNAL c' x'; (x,x')\\<in>R; I x'\\<rbrakk> \n    \\<Longrightarrow> (f x,f'$x') \\<in> \\<langle>R\\<rangle>nres_rel\"\n  shows \"(WHILET c f,\n      (OP (WHILEIT I) ::: (R\\<rightarrow>Id) \\<rightarrow> (R\\<rightarrow>\\<langle>R\\<rangle>nres_rel) \\<rightarrow> R \\<rightarrow> \\<langle>R\\<rangle>nres_rel)$c'$f'\n    )\\<in>R \\<rightarrow> \\<langle>R\\<rangle>nres_rel\"", "lemma autoref_WHILE[autoref_rules]: (** TODO: obsolete ? **)\n  assumes \"\\<And>x x'. \\<lbrakk> (x,x')\\<in>R\\<rbrakk> \\<Longrightarrow> (c x,c'$x') \\<in> Id\"\n  assumes \"\\<And>x x'. \\<lbrakk> REMOVE_INTERNAL c' x'; (x,x')\\<in>R\\<rbrakk> \n    \\<Longrightarrow> (f x,f'$x') \\<in> \\<langle>R\\<rangle>nres_rel\"\n  assumes \"(s,s')\\<in>R\"\n  shows \"(WHILE c f s,\n      (OP WHILE ::: (R\\<rightarrow>Id) \\<rightarrow> (R\\<rightarrow>\\<langle>R\\<rangle>nres_rel) \\<rightarrow> R \\<rightarrow> \\<langle>R\\<rangle>nres_rel)$c'$f'$s'\n    )\\<in>\\<langle>R\\<rangle>nres_rel\"", "lemma autoref_WHILE'[autoref_rules]:\n  assumes \"\\<And>x x'. \\<lbrakk> (x,x')\\<in>R\\<rbrakk> \\<Longrightarrow> (c x,c'$x') \\<in> Id\"\n  assumes \"\\<And>x x'. \\<lbrakk> REMOVE_INTERNAL c' x'; (x,x')\\<in>R\\<rbrakk> \n    \\<Longrightarrow> (f x,f'$x') \\<in> \\<langle>R\\<rangle>nres_rel\"\n  shows \"(WHILE c f,\n      (OP WHILE ::: (R\\<rightarrow>Id) \\<rightarrow> (R\\<rightarrow>\\<langle>R\\<rangle>nres_rel) \\<rightarrow> R \\<rightarrow> \\<langle>R\\<rangle>nres_rel)$c'$f'\n    )\\<in>R \\<rightarrow> \\<langle>R\\<rangle>nres_rel\"", "lemma autoref_WHILEI[autoref_rules]:\n  assumes \"\\<And>x x'. \\<lbrakk>I x'; (x,x')\\<in>R\\<rbrakk> \\<Longrightarrow> (c x,c'$x') \\<in> Id\"\n  assumes \"\\<And>x x'. \\<lbrakk>REMOVE_INTERNAL c' x'; I x'; (x,x')\\<in>R\\<rbrakk> \\<Longrightarrow>(f x,f'$x') \\<in> \\<langle>R\\<rangle>nres_rel\"\n  assumes \"I s' \\<Longrightarrow> (s,s')\\<in>R\"\n  shows \"(WHILE c f s,\n      (OP (WHILEI I) ::: (R\\<rightarrow>Id) \\<rightarrow> (R\\<rightarrow>\\<langle>R\\<rangle>nres_rel) \\<rightarrow> R \\<rightarrow> \\<langle>R\\<rangle>nres_rel)$c'$f'$s'\n    )\\<in>\\<langle>R\\<rangle>nres_rel\"", "lemma autoref_WHILEI'[autoref_rules]:\n  assumes \"\\<And>x x'. \\<lbrakk> (x,x')\\<in>R; I x'\\<rbrakk> \\<Longrightarrow> (c x,c'$x') \\<in> Id\"\n  assumes \"\\<And>x x'. \\<lbrakk> REMOVE_INTERNAL c' x'; (x,x')\\<in>R; I x'\\<rbrakk> \n    \\<Longrightarrow> (f x,f'$x') \\<in> \\<langle>R\\<rangle>nres_rel\"\n  shows \"(WHILE c f,\n      (OP (WHILEI I) ::: (R\\<rightarrow>Id) \\<rightarrow> (R\\<rightarrow>\\<langle>R\\<rangle>nres_rel) \\<rightarrow> R \\<rightarrow> \\<langle>R\\<rangle>nres_rel)$c'$f'\n    )\\<in>R \\<rightarrow> \\<langle>R\\<rangle>nres_rel\"", "lemma tailrec_transform_aux1:\n    assumes \"RETURN s \\<le> m\"\n    shows \"REC (\\<lambda>D s. sup (a s \\<bind> D) (b s)) s \\<le> lfp (\\<lambda>x. sup m (x\\<bind>a)) \\<bind> b\"\n    (is \"REC ?F s \\<le> lfp ?f \\<bind> b\")", "lemma tailrec_transform_aux2:\n    fixes m :: \"'a nres\"\n    shows \"lfp (\\<lambda>x. sup m (x\\<bind>a)) \n      \\<le> m \\<bind> REC (\\<lambda>D s. sup (a s \\<bind> D) (RETURN s))\"\n    (is \"lfp ?f \\<le> m \\<bind> REC ?F\")", "lemma tailrec_transform_aux3: \"REC (\\<lambda>D s. sup (a s \\<bind> D) (RETURN s)) s \\<bind> b \n    \\<le> REC (\\<lambda>D s. sup (a s \\<bind> D) (b s)) s\"", "lemma tailrec_transform2:\n    \"lfp (\\<lambda>x. sup m (bind x a)) \\<bind> b \\<le> m \\<bind> REC (\\<lambda>D s. sup (a s \\<bind> D) (b s))\"", "theorem tailrec_transform: \n    \"m \\<bind> REC (\\<lambda>D s. sup (a s \\<bind> D) (b s)) = lfp (\\<lambda>x. sup m (bind x a)) \\<bind> b\"", "theorem tailrec_transform': \n    \"m \\<bind> REC (tailrec_body a b) = lfp (\\<lambda>x. sup m (bind x a)) \\<bind> b\"", "lemma \"WHILE c f = \n    REC (tailrec_body \n      (\\<lambda>s. do {ASSUME (c s); f s}) \n      (\\<lambda>s. do {ASSUME (\\<not>c s); RETURN s})\n    )\"", "lemma WHILEI_tailrec_conv: \"WHILEI I c f = \n    REC (tailrec_body \n      (\\<lambda>s. do {ASSERT (I s); ASSUME (c s); f s}) \n      (\\<lambda>s. do {ASSERT (I s); ASSUME (\\<not>c s); RETURN s})\n    )\"", "lemma WHILEIT_tailrec_conv: \"WHILEIT I c f = \n    RECT (tailrec_body \n      (\\<lambda>s. do {ASSERT (I s); ASSUME (c s); f s}) \n      (\\<lambda>s. do {ASSERT (I s); ASSUME (\\<not>c s); RETURN s})\n    )\"", "lemma WHILEI_lfp_conv: \"m \\<bind> WHILEI I c f = \n    do { \n      s \\<leftarrow> lfp (WHILEI_lfp_body I m c f); \n      ASSERT (I s); \n      ASSUME (\\<not>c s); \n      RETURN s \n    }\"", "lemma [simp, intro!]: \"mono (WHILEI_lfp_body I m c f)\"", "lemma [refine_pw_simps]: \"nofail (filter_ASSUME c m) \\<longleftrightarrow> nofail m\"", "lemma [refine_pw_simps]: \"inres (filter_ASSUME c m) x \n  \\<longleftrightarrow> (nofail m \\<longrightarrow> inres m x \\<and> c x)\"", "lemma msii_is_invar:\n  \"m \\<le> msii I m c f\"\n  \"m \\<le> msii I m c f \\<Longrightarrow> bind (filter_ASSUME c (filter_ASSERT I m)) f \\<le> msii I m c f\"", "lemma WHILE_msii_conv: \"m \\<bind> WHILEI I c f \n  = filter_ASSUME (Not o c) (filter_ASSERT I (msii I m c f))\"", "lemma msii_induct: \n  assumes I0: \"m0 \\<le> P\"\n  assumes IS: \"\\<And>m. \\<lbrakk>m \\<le> msii I m0 c f; m \\<le> P;\n    filter_ASSUME c (filter_ASSERT I m) \\<bind> f \\<le> msii I m0 c f\n      \\<rbrakk> \\<Longrightarrow> filter_ASSUME c (filter_ASSERT I m) \\<bind> f \\<le> P\"\n  shows \"msii I m0 c f \\<le> P\"", "lemma establish_rwof_invar:\n    assumes I: \"m0 \\<le>\\<^sub>n SPEC I\"\n    assumes S: \"\\<And>s. \\<lbrakk> rwof m0 cond step s; I s; cond s \\<rbrakk> \n      \\<Longrightarrow> step s \\<le>\\<^sub>n SPEC I\"\n    assumes \"rwof m0 cond step s\"\n    shows \"I s\"", "lemma is_rwof_invarI[intro?]:\n    assumes I: \"m0 \\<le>\\<^sub>n SPEC I\"\n    assumes S: \"\\<And>s. \\<lbrakk> rwof m0 cond step s; I s; cond s \\<rbrakk> \n      \\<Longrightarrow> step s \\<le>\\<^sub>n SPEC I\"\n    shows \"is_rwof_invar m0 cond step I\"", "lemma rwof_cons: \"\\<lbrakk>is_rwof_invar m0 cond step I; rwof m0 cond step s\\<rbrakk> \\<Longrightarrow> I s\"", "lemma rwof_WHILE_rule:\n    assumes I0: \"m0 \\<le> SPEC I\"\n    assumes S: \"\\<And>s. \\<lbrakk> rwof m0 cond step s; I s; cond s \\<rbrakk> \\<Longrightarrow> step s \\<le> SPEC I\"\n    shows \"m0 \\<bind> WHILE cond step \\<le> SPEC (\\<lambda>s. rwof m0 cond step s \\<and> \\<not>cond s \\<and> I s)\"", "lemma pw_filter_nb[refine_pw_simps]:\n    \"nofail (filter_nb b I) \\<longleftrightarrow> nofail I\"\n    \"inres (filter_nb b I) x \\<longleftrightarrow> (nofail I \\<longrightarrow> inres I x \\<and> \\<not>b x)\"", "lemma filter_nb_mono: \"m\\<le>m' \\<Longrightarrow> filter_nb cond m \\<le> filter_nb cond m'\"", "lemma filter_nb_cont: \n    \"filter_nb cond (Sup M) = Sup {filter_nb cond m | m. m \\<in> M}\"", "lemma filter_nb_FAIL[simp]: \"filter_nb cond FAIL = FAIL\"", "lemma filter_nb_RES[simp]: \"filter_nb cond (RES X) = RES {x\\<in>X. \\<not>cond x}\"", "lemma WHILE_rule_gen_le:\n    assumes I0: \"m0 \\<le> I\"\n    assumes ISTEP: \"\\<And>s. \\<lbrakk>RETURN s \\<le> I; b s\\<rbrakk> \\<Longrightarrow> f s \\<le> I\"\n    shows \"m0 \\<bind> WHILE b f \\<le> filter_nb b I\"", "lemma bounded_WHILE_shift: \"do {\n             x \\<leftarrow> m;\n             if cond x then bounded_WHILE n cond step (step x) else RETURN x\n           } = do {\n             x \\<leftarrow> bounded_WHILE n cond step m;\n             if cond x then step x else RETURN x\n           }\"", "lemma bounded_WHILE'_eq: \n    \"bounded_WHILE' n cond step m = bounded_WHILE n cond step m\"", "lemma mWHILE_unfold: \"m \\<bind> WHILE cond step = do {\n      x \\<leftarrow> m;\n      if cond x then step x \\<bind> WHILE cond step\n      else RETURN x\n    }\"", "lemma WHILE_bounded_aux1: \n    \"filter_nb cond (bounded_WHILE n cond step m) \\<le> m \\<bind> WHILE cond step\"", "lemma WHILE_bounded_aux2:\n    \"m \\<bind> WHILE cond step \n      \\<le> filter_nb cond (Sup {bounded_WHILE n cond step m | n. True})\"", "lemma WHILE_bounded: \n    \"m \\<bind> WHILE cond step \n    = filter_nb cond (Sup {bounded_WHILE n cond step m | n. True})\"", "lemma rwof_in_bounded_WHILE:\n    assumes \"rwof m0 cond step s\" \n    shows \"\\<exists>n. RETURN s \\<le> (bounded_WHILE n cond step m0)\"", "lemma bounded_WHILE_FAIL_rwof:\n    assumes \"bounded_WHILE n cond step m0 = FAIL\"\n    assumes M0: \"m0 \\<noteq> FAIL\"\n    shows \"\\<exists>n'<n. \\<exists>x X. \n        bounded_WHILE n' cond step m0 = RES X \n      \\<and> x\\<in>X \\<and> cond x \\<and> step x = FAIL\"", "lemma bounded_WHILE_RES_rwof:\n    assumes \"bounded_WHILE n cond step m0 = RES X\"\n    assumes \"x\\<in>X\"\n    shows \"rwof m0 cond step x\"", "lemma rwof_FAIL_imp_WHILE_FAIL:\n    assumes RW: \"rwof m0 cond step s\" \n    and C: \"cond s\" \n    and S: \"step s = FAIL\"\n    shows \"m0 \\<bind> WHILE cond step = FAIL\"", "lemma pw_bounded_WHILE_RES_rwof: \"\\<lbrakk> nofail (bounded_WHILE n cond step m0); \n    inres (bounded_WHILE n cond step m0) x \\<rbrakk> \\<Longrightarrow> rwof m0 cond step x\"", "lemma WHILE_le_WHILEI: \"WHILE b f s \\<le> WHILEI I b f s\"", "lemma pw_rwof_in_bounded_WHILE:\n    \"rwof m0 cond step x \\<Longrightarrow> \\<exists>n. inres (bounded_WHILE n cond step m0) x\"", "lemma nofail_WHILE_eq_rwof: \n    assumes NF: \"nofail (m0 \\<bind> WHILE cond step)\"\n    shows \"m0 \\<bind> WHILE cond step = SPEC (\\<lambda>s. rwof m0 cond step s \\<and> \\<not>cond s)\"", "lemma WHILE_refine_rwof:\n    assumes \"nofail (m \\<bind> WHILE c f) \\<Longrightarrow> mi \\<le> SPEC (\\<lambda>s. rwof m c f s \\<and> \\<not>c s)\"\n    shows \"mi \\<le> m \\<bind> WHILE c f\"", "lemma pw_rwof_init:\n    assumes NF: \"nofail (m0 \\<bind> WHILE cond step)\"\n    shows \"inres m0 s \\<Longrightarrow> rwof m0 cond step s\" and \"nofail m0\"", "lemma rwof_init:\n    assumes NF: \"nofail (m0 \\<bind> WHILE cond step)\" \n    shows \"m0 \\<le> SPEC (rwof m0 cond step)\"", "lemma pw_rwof_step':\n    assumes NF: \"nofail (step s)\"\n    assumes R: \"rwof m0 cond step s\"\n    assumes C: \"cond s\"\n    shows \"inres (step s) s' \\<Longrightarrow> rwof m0 cond step s'\"", "lemma rwof_step': \n    \"\\<lbrakk> nofail (step s); rwof m0 cond step s; cond s \\<rbrakk>\n    \\<Longrightarrow> step s \\<le> SPEC (rwof m0 cond step)\"", "lemma pw_rwof_step:\n    assumes NF: \"nofail (m0 \\<bind> WHILE cond step)\"\n    assumes R: \"rwof m0 cond step s\"\n    assumes C: \"cond s\"\n    shows \"inres (step s) s' \\<Longrightarrow> rwof m0 cond step s'\"\n      and \"nofail (step s)\"", "lemma rwof_step: \n    \"\\<lbrakk> nofail (m0 \\<bind> WHILE cond step); rwof m0 cond step s; cond s \\<rbrakk>\n    \\<Longrightarrow> step s \\<le> SPEC (rwof m0 cond step)\"", "lemma (in -) rwof_leof_init: \"m \\<le>\\<^sub>n SPEC (rwof m c f)\"", "lemma (in -) rwof_leof_step: \"\\<lbrakk>rwof m c f s; c s\\<rbrakk> \\<Longrightarrow> f s \\<le>\\<^sub>n SPEC (rwof m c f)\"", "lemma (in -) rwof_step_refine:\n    assumes NF: \"nofail (m0 \\<bind> WHILE cond step)\"  \n    assumes A: \"rwof m0 cond step' s\"\n    assumes FR: \"\\<And>s. \\<lbrakk> rwof m0 cond step s; cond s \\<rbrakk> \\<Longrightarrow> step' s \\<le>\\<^sub>n step s\"\n    shows \"rwof m0 cond step s\"", "lemma WHILE_eq_I_rwof: \"m \\<bind> WHILE c f = m \\<bind> WHILEI (rwof m c f) c f\"", "lemma WHILET_eq_I_rwof: \"m \\<bind> WHILET c f = m \\<bind> WHILEIT (rwof m c f) c f\"", "lemma rwof_refine:\n  assumes RW: \"rwof m c f s\"\n  assumes NF: \"nofail (m' \\<bind> WHILE c' f')\"\n  assumes M: \"m \\<le>\\<^sub>n \\<Down>R m'\"\n  assumes C: \"\\<And>s s'. \\<lbrakk>(s,s')\\<in>R; rwof m c f s; rwof m' c' f' s'\\<rbrakk> \\<Longrightarrow> c s = c' s'\"\n  assumes S: \"\\<And>s s'. \\<lbrakk>(s,s')\\<in>R; rwof m c f s; rwof m' c' f' s'; c s; c' s'\\<rbrakk> \\<Longrightarrow> f s \\<le>\\<^sub>n \\<Down>R (f' s')\"\n  shows \"\\<exists>s'. (s,s')\\<in>R \\<and> rwof m' c' f' s'\"", "lemma rwof_rel_spec: \"\\<lbrakk>rwof init cond step s; cond s\\<rbrakk> \n  \\<Longrightarrow> step s \\<le>\\<^sub>n SPEC (\\<lambda>s'. (s,s')\\<in>rwof_rel init cond step)\"", "lemma rwof_reachable:\n  assumes \"rwof init cond step s\"\n  shows \"\\<exists>s0. inres init s0 \\<and> (s0,s)\\<in>(rwof_rel init cond step)\\<^sup>*\"", "theorem nofail_WHILEIT_wf_rel: \n  assumes NF: \"nofail (init \\<bind> WHILEIT I cond step)\"\n  shows \"wf ((rwof_rel init cond step)\\<inverse>)\"", "lemma range_set_WHILE:\n  assumes CEQ: \"\\<And>i s. c (i,s) \\<longleftrightarrow> i<u\"\n  assumes F0: \"F {} s0 = s0\"\n  assumes Fs: \"\\<And>s i X. \\<lbrakk>l\\<le>i; i<u\\<rbrakk> \n    \\<Longrightarrow> f (i, (F X s)) \\<le> SPEC (\\<lambda>(i',r). i'=i+1 \\<and> r=F (insert (list!i) X) s)\"\n  shows \"WHILET c f (l,s0) \n    \\<le> SPEC (\\<lambda>(_,r). r=F {list!i | i. l\\<le>i \\<and> i<u} s0)\""], "translations": [["", "lemmas [refine_vcg] = WHILEI_rule"], ["", "lemmas [refine_vcg] = WHILEIT_rule"], ["", "subsection \\<open>Data Refinement Rules\\<close>"], ["", "lemma ref_WHILEI_invarI:\n  assumes \"I s \\<Longrightarrow> M \\<le> \\<Down>R (WHILEI I b f s)\"\n  shows \"M \\<le> \\<Down>R (WHILEI I b f s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M \\<le> \\<Down> R (WHILE\\<^bsup>I\\<^esup> b f s)", "apply (subst WHILEI_unfold)"], ["proof (prove)\ngoal (1 subgoal):\n 1. M \\<le> \\<Down> R\n             (if I s\n              then if b s then f s \\<bind> WHILE\\<^bsup>I\\<^esup> b f\n                   else RETURN s\n              else FAIL)", "apply (cases \"I s\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. I s \\<Longrightarrow>\n    M \\<le> \\<Down> R\n             (if I s\n              then if b s then f s \\<bind> WHILE\\<^bsup>I\\<^esup> b f\n                   else RETURN s\n              else FAIL)\n 2. \\<not> I s \\<Longrightarrow>\n    M \\<le> \\<Down> R\n             (if I s\n              then if b s then f s \\<bind> WHILE\\<^bsup>I\\<^esup> b f\n                   else RETURN s\n              else FAIL)", "apply (subst WHILEI_unfold[symmetric])"], ["proof (prove)\ngoal (2 subgoals):\n 1. I s \\<Longrightarrow> M \\<le> \\<Down> R (WHILE\\<^bsup>I\\<^esup> b f s)\n 2. \\<not> I s \\<Longrightarrow>\n    M \\<le> \\<Down> R\n             (if I s\n              then if b s then f s \\<bind> WHILE\\<^bsup>I\\<^esup> b f\n                   else RETURN s\n              else FAIL)", "apply (erule assms)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> I s \\<Longrightarrow>\n    M \\<le> \\<Down> R\n             (if I s\n              then if b s then f s \\<bind> WHILE\\<^bsup>I\\<^esup> b f\n                   else RETURN s\n              else FAIL)", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma ref_WHILEIT_invarI:\n  assumes \"I s \\<Longrightarrow> M \\<le> \\<Down>R (WHILEIT I b f s)\"\n  shows \"M \\<le> \\<Down>R (WHILEIT I b f s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M \\<le> \\<Down> R (WHILE\\<^sub>T\\<^bsup>I\\<^esup> b f s)", "apply (subst WHILEIT_unfold)"], ["proof (prove)\ngoal (1 subgoal):\n 1. M \\<le> \\<Down> R\n             (if I s\n              then if b s\n                   then f s \\<bind> WHILE\\<^sub>T\\<^bsup>I\\<^esup> b f\n                   else RETURN s\n              else FAIL)", "apply (cases \"I s\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. I s \\<Longrightarrow>\n    M \\<le> \\<Down> R\n             (if I s\n              then if b s\n                   then f s \\<bind> WHILE\\<^sub>T\\<^bsup>I\\<^esup> b f\n                   else RETURN s\n              else FAIL)\n 2. \\<not> I s \\<Longrightarrow>\n    M \\<le> \\<Down> R\n             (if I s\n              then if b s\n                   then f s \\<bind> WHILE\\<^sub>T\\<^bsup>I\\<^esup> b f\n                   else RETURN s\n              else FAIL)", "apply (subst WHILEIT_unfold[symmetric])"], ["proof (prove)\ngoal (2 subgoals):\n 1. I s \\<Longrightarrow>\n    M \\<le> \\<Down> R (WHILE\\<^sub>T\\<^bsup>I\\<^esup> b f s)\n 2. \\<not> I s \\<Longrightarrow>\n    M \\<le> \\<Down> R\n             (if I s\n              then if b s\n                   then f s \\<bind> WHILE\\<^sub>T\\<^bsup>I\\<^esup> b f\n                   else RETURN s\n              else FAIL)", "apply (erule assms)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> I s \\<Longrightarrow>\n    M \\<le> \\<Down> R\n             (if I s\n              then if b s\n                   then f s \\<bind> WHILE\\<^sub>T\\<^bsup>I\\<^esup> b f\n                   else RETURN s\n              else FAIL)", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma WHILEI_le_rule:\n  assumes R0: \"(s,s')\\<in>R\"\n  assumes RS: \"\\<And>W s s'. \\<lbrakk>\\<And>s s'. (s,s')\\<in>R \\<Longrightarrow> W s \\<le> M s'; (s,s')\\<in>R\\<rbrakk> \\<Longrightarrow> \n    do {ASSERT (I s); if b s then bind (f s) W else RETURN s} \\<le> M s'\"\n  shows \"WHILEI I b f s \\<le> M s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. WHILE\\<^bsup>I\\<^esup> b f s \\<le> M s'", "unfolding WHILEI_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. REC (WHILEI_body (\\<bind>) RETURN I b f) s \\<le> M s'", "apply (rule REC_le_rule[where M=M])"], ["proof (prove)\ngoal (3 subgoals):\n 1. trimono (WHILEI_body (\\<bind>) RETURN I b f)\n 2. (s, s') \\<in> ?R\n 3. \\<And>fa x x'.\n       \\<lbrakk>\\<And>x x'.\n                   (x, x') \\<in> ?R \\<Longrightarrow> fa x \\<le> M x';\n        (x, x') \\<in> ?R\\<rbrakk>\n       \\<Longrightarrow> WHILEI_body (\\<bind>) RETURN I b f fa x \\<le> M x'", "apply (simp add: WHILEI_body_def, refine_mono)"], ["proof (prove)\ngoal (2 subgoals):\n 1. (s, s') \\<in> ?R\n 2. \\<And>fa x x'.\n       \\<lbrakk>\\<And>x x'.\n                   (x, x') \\<in> ?R \\<Longrightarrow> fa x \\<le> M x';\n        (x, x') \\<in> ?R\\<rbrakk>\n       \\<Longrightarrow> WHILEI_body (\\<bind>) RETURN I b f fa x \\<le> M x'", "apply (rule R0)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>fa x x'.\n       \\<lbrakk>\\<And>x x'.\n                   (x, x') \\<in> R \\<Longrightarrow> fa x \\<le> M x';\n        (x, x') \\<in> R\\<rbrakk>\n       \\<Longrightarrow> WHILEI_body (\\<bind>) RETURN I b f fa x \\<le> M x'", "apply (erule (1) order_trans[rotated,OF RS])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>fa x x'.\n       (x, x') \\<in> R \\<Longrightarrow>\n       WHILEI_body (\\<bind>) RETURN I b f fa x\n       \\<le> ASSERT (I x) \\<bind>\n             (\\<lambda>_. if b x then f x \\<bind> fa else RETURN x)", "unfolding WHILEI_body_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>fa x x'.\n       (x, x') \\<in> R \\<Longrightarrow>\n       (if I x then if b x then f x \\<bind> fa else RETURN x else FAIL)\n       \\<le> ASSERT (I x) \\<bind>\n             (\\<lambda>_. if b x then f x \\<bind> fa else RETURN x)", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>WHILE-refinement rule with invisible concrete steps.\n  Intuitively, a concrete step may either refine an abstract step, or\n  must not change the corresponding abstract state.\\<close>"], ["", "lemma WHILEI_invisible_refine_genR:\n  assumes R0: \"I' s' \\<Longrightarrow> (s,s')\\<in>R'\"\n  assumes RI: \"\\<And>s s'. \\<lbrakk> (s,s')\\<in>R'; I' s' \\<rbrakk> \\<Longrightarrow> I s\"\n  assumes RB: \"\\<And>s s'. \\<lbrakk> (s,s')\\<in>R'; I' s'; I s; b' s' \\<rbrakk> \\<Longrightarrow> b s\"\n  assumes RS: \"\\<And>s s'. \\<lbrakk> (s,s')\\<in>R'; I' s'; I s; b s \\<rbrakk> \n    \\<Longrightarrow> f s \\<le> sup (\\<Down>R' (do {ASSUME (b' s'); f' s'})) (\\<Down>R' (RETURN s'))\"\n  assumes R_REF: \n    \"\\<And>x x'. \\<lbrakk> (x,x')\\<in>R'; \\<not>b x; \\<not>b' x'; I x; I' x' \\<rbrakk> \\<Longrightarrow> (x,x')\\<in>R\"\n  shows \"WHILEI I b f s \\<le> \\<Down>R (WHILEI I' b' f' s')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. WHILE\\<^bsup>I\\<^esup> b f s\n    \\<le> \\<Down> R (WHILE\\<^bsup>I'\\<^esup> b' f' s')", "apply (rule ref_WHILEI_invarI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. I' s' \\<Longrightarrow>\n    WHILE\\<^bsup>I\\<^esup> b f s\n    \\<le> \\<Down> R (WHILE\\<^bsup>I'\\<^esup> b' f' s')", "apply (rule WHILEI_le_rule[where R=R'])"], ["proof (prove)\ngoal (2 subgoals):\n 1. I' s' \\<Longrightarrow> (s, s') \\<in> R'\n 2. \\<And>W s s'a.\n       \\<lbrakk>I' s';\n        \\<And>s s'.\n           (s, s') \\<in> R' \\<Longrightarrow>\n           W s \\<le> \\<Down> R (WHILE\\<^bsup>I'\\<^esup> b' f' s');\n        (s, s'a) \\<in> R'\\<rbrakk>\n       \\<Longrightarrow> ASSERT (I s) \\<bind>\n                         (\\<lambda>_.\n                             if b s then f s \\<bind> W else RETURN s)\n                         \\<le> \\<Down> R (WHILE\\<^bsup>I'\\<^esup> b' f' s'a)", "apply (erule R0)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>W s s'a.\n       \\<lbrakk>I' s';\n        \\<And>s s'.\n           (s, s') \\<in> R' \\<Longrightarrow>\n           W s \\<le> \\<Down> R (WHILE\\<^bsup>I'\\<^esup> b' f' s');\n        (s, s'a) \\<in> R'\\<rbrakk>\n       \\<Longrightarrow> ASSERT (I s) \\<bind>\n                         (\\<lambda>_.\n                             if b s then f s \\<bind> W else RETURN s)\n                         \\<le> \\<Down> R (WHILE\\<^bsup>I'\\<^esup> b' f' s'a)", "apply (rule ref_WHILEI_invarI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>W s s'a.\n       \\<lbrakk>I' s';\n        \\<And>s s'.\n           (s, s') \\<in> R' \\<Longrightarrow>\n           W s \\<le> \\<Down> R (WHILE\\<^bsup>I'\\<^esup> b' f' s');\n        (s, s'a) \\<in> R'; I' s'a\\<rbrakk>\n       \\<Longrightarrow> ASSERT (I s) \\<bind>\n                         (\\<lambda>_.\n                             if b s then f s \\<bind> W else RETURN s)\n                         \\<le> \\<Down> R (WHILE\\<^bsup>I'\\<^esup> b' f' s'a)", "apply (frule (1) RI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>W s s'a.\n       \\<lbrakk>I' s';\n        \\<And>s s'.\n           (s, s') \\<in> R' \\<Longrightarrow>\n           W s \\<le> \\<Down> R (WHILE\\<^bsup>I'\\<^esup> b' f' s');\n        (s, s'a) \\<in> R'; I' s'a; I s\\<rbrakk>\n       \\<Longrightarrow> ASSERT (I s) \\<bind>\n                         (\\<lambda>_.\n                             if b s then f s \\<bind> W else RETURN s)\n                         \\<le> \\<Down> R (WHILE\\<^bsup>I'\\<^esup> b' f' s'a)", "apply (case_tac \"b s=False\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>W s s'a.\n       \\<lbrakk>I' s';\n        \\<And>s s'.\n           (s, s') \\<in> R' \\<Longrightarrow>\n           W s \\<le> \\<Down> R (WHILE\\<^bsup>I'\\<^esup> b' f' s');\n        (s, s'a) \\<in> R'; I' s'a; I s; b s = False\\<rbrakk>\n       \\<Longrightarrow> ASSERT (I s) \\<bind>\n                         (\\<lambda>_.\n                             if b s then f s \\<bind> W else RETURN s)\n                         \\<le> \\<Down> R (WHILE\\<^bsup>I'\\<^esup> b' f' s'a)\n 2. \\<And>W s s'a.\n       \\<lbrakk>I' s';\n        \\<And>s s'.\n           (s, s') \\<in> R' \\<Longrightarrow>\n           W s \\<le> \\<Down> R (WHILE\\<^bsup>I'\\<^esup> b' f' s');\n        (s, s'a) \\<in> R'; I' s'a; I s; b s \\<noteq> False\\<rbrakk>\n       \\<Longrightarrow> ASSERT (I s) \\<bind>\n                         (\\<lambda>_.\n                             if b s then f s \\<bind> W else RETURN s)\n                         \\<le> \\<Down> R (WHILE\\<^bsup>I'\\<^esup> b' f' s'a)", "apply (subst WHILEI_unfold)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>W s s'a.\n       \\<lbrakk>I' s';\n        \\<And>s s'.\n           (s, s') \\<in> R' \\<Longrightarrow>\n           W s \\<le> \\<Down> R (WHILE\\<^bsup>I'\\<^esup> b' f' s');\n        (s, s'a) \\<in> R'; I' s'a; I s; b s = False\\<rbrakk>\n       \\<Longrightarrow> ASSERT (I s) \\<bind>\n                         (\\<lambda>_.\n                             if b s then f s \\<bind> W else RETURN s)\n                         \\<le> \\<Down> R\n                                (if I' s'a\n                                 then if b' s'a\nthen f' s'a \\<bind> WHILE\\<^bsup>I'\\<^esup> b' f' else RETURN s'a\n                                 else FAIL)\n 2. \\<And>W s s'a.\n       \\<lbrakk>I' s';\n        \\<And>s s'.\n           (s, s') \\<in> R' \\<Longrightarrow>\n           W s \\<le> \\<Down> R (WHILE\\<^bsup>I'\\<^esup> b' f' s');\n        (s, s'a) \\<in> R'; I' s'a; I s; b s \\<noteq> False\\<rbrakk>\n       \\<Longrightarrow> ASSERT (I s) \\<bind>\n                         (\\<lambda>_.\n                             if b s then f s \\<bind> W else RETURN s)\n                         \\<le> \\<Down> R (WHILE\\<^bsup>I'\\<^esup> b' f' s'a)", "apply (auto dest: RB intro: RETURN_refine R_REF) []"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>W s s'a.\n       \\<lbrakk>I' s';\n        \\<And>s s'.\n           (s, s') \\<in> R' \\<Longrightarrow>\n           W s \\<le> \\<Down> R (WHILE\\<^bsup>I'\\<^esup> b' f' s');\n        (s, s'a) \\<in> R'; I' s'a; I s; b s \\<noteq> False\\<rbrakk>\n       \\<Longrightarrow> ASSERT (I s) \\<bind>\n                         (\\<lambda>_.\n                             if b s then f s \\<bind> W else RETURN s)\n                         \\<le> \\<Down> R (WHILE\\<^bsup>I'\\<^esup> b' f' s'a)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>W s s'a.\n       \\<lbrakk>I' s';\n        \\<And>s s'.\n           (s, s') \\<in> R' \\<Longrightarrow>\n           W s \\<le> \\<Down> R (WHILE\\<^bsup>I'\\<^esup> b' f' s');\n        (s, s'a) \\<in> R'; I' s'a; I s; b s\\<rbrakk>\n       \\<Longrightarrow> f s \\<bind> W\n                         \\<le> \\<Down> R (WHILE\\<^bsup>I'\\<^esup> b' f' s'a)", "apply (rule order_trans[OF monoD[OF bind_mono1 RS]], assumption+)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>W s s'a.\n       \\<lbrakk>I' s';\n        \\<And>s s'.\n           (s, s') \\<in> R' \\<Longrightarrow>\n           W s \\<le> \\<Down> R (WHILE\\<^bsup>I'\\<^esup> b' f' s');\n        (s, s'a) \\<in> R'; I' s'a; I s; b s\\<rbrakk>\n       \\<Longrightarrow> sup (\\<Down> R'\n                               (ASSUME (b' s'a) \\<bind>\n                                (\\<lambda>_. f' s'a)))\n                          (\\<Down> R' (RETURN s'a)) \\<bind>\n                         W\n                         \\<le> \\<Down> R (WHILE\\<^bsup>I'\\<^esup> b' f' s'a)", "apply (simp only: bind_distrib_sup1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>W s s'a.\n       \\<lbrakk>I' s';\n        \\<And>s s'.\n           (s, s') \\<in> R' \\<Longrightarrow>\n           W s \\<le> \\<Down> R (WHILE\\<^bsup>I'\\<^esup> b' f' s');\n        (s, s'a) \\<in> R'; I' s'a; I s; b s\\<rbrakk>\n       \\<Longrightarrow> sup (\\<Down> R'\n                               (ASSUME (b' s'a) \\<bind>\n                                (\\<lambda>_. f' s'a)) \\<bind>\n                              W)\n                          (\\<Down> R' (RETURN s'a) \\<bind> W)\n                         \\<le> \\<Down> R (WHILE\\<^bsup>I'\\<^esup> b' f' s'a)", "apply (rule sup_least)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>W s s'a.\n       \\<lbrakk>I' s';\n        \\<And>s s'.\n           (s, s') \\<in> R' \\<Longrightarrow>\n           W s \\<le> \\<Down> R (WHILE\\<^bsup>I'\\<^esup> b' f' s');\n        (s, s'a) \\<in> R'; I' s'a; I s; b s\\<rbrakk>\n       \\<Longrightarrow> \\<Down> R'\n                          (ASSUME (b' s'a) \\<bind>\n                           (\\<lambda>_. f' s'a)) \\<bind>\n                         W\n                         \\<le> \\<Down> R (WHILE\\<^bsup>I'\\<^esup> b' f' s'a)\n 2. \\<And>W s s'a.\n       \\<lbrakk>I' s';\n        \\<And>s s'.\n           (s, s') \\<in> R' \\<Longrightarrow>\n           W s \\<le> \\<Down> R (WHILE\\<^bsup>I'\\<^esup> b' f' s');\n        (s, s'a) \\<in> R'; I' s'a; I s; b s\\<rbrakk>\n       \\<Longrightarrow> \\<Down> R' (RETURN s'a) \\<bind> W\n                         \\<le> \\<Down> R (WHILE\\<^bsup>I'\\<^esup> b' f' s'a)", "apply (subst WHILEI_unfold)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>W s s'a.\n       \\<lbrakk>I' s';\n        \\<And>s s'.\n           (s, s') \\<in> R' \\<Longrightarrow>\n           W s \\<le> \\<Down> R (WHILE\\<^bsup>I'\\<^esup> b' f' s');\n        (s, s'a) \\<in> R'; I' s'a; I s; b s\\<rbrakk>\n       \\<Longrightarrow> \\<Down> R'\n                          (ASSUME (b' s'a) \\<bind>\n                           (\\<lambda>_. f' s'a)) \\<bind>\n                         W\n                         \\<le> \\<Down> R\n                                (if I' s'a\n                                 then if b' s'a\nthen f' s'a \\<bind> WHILE\\<^bsup>I'\\<^esup> b' f' else RETURN s'a\n                                 else FAIL)\n 2. \\<And>W s s'a.\n       \\<lbrakk>I' s';\n        \\<And>s s'.\n           (s, s') \\<in> R' \\<Longrightarrow>\n           W s \\<le> \\<Down> R (WHILE\\<^bsup>I'\\<^esup> b' f' s');\n        (s, s'a) \\<in> R'; I' s'a; I s; b s\\<rbrakk>\n       \\<Longrightarrow> \\<Down> R' (RETURN s'a) \\<bind> W\n                         \\<le> \\<Down> R (WHILE\\<^bsup>I'\\<^esup> b' f' s'a)", "apply (simp add: RB, intro impI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>W s s'a.\n       \\<lbrakk>I' s';\n        \\<And>s s'.\n           (s, s') \\<in> R' \\<Longrightarrow>\n           W s \\<le> \\<Down> R (WHILE\\<^bsup>I'\\<^esup> b' f' s');\n        (s, s'a) \\<in> R'; I' s'a; I s; b s; b' s'a\\<rbrakk>\n       \\<Longrightarrow> \\<Down> R' (f' s'a) \\<bind> W\n                         \\<le> \\<Down> R\n                                (f' s'a \\<bind>\n                                 WHILE\\<^bsup>I'\\<^esup> b' f')\n 2. \\<And>W s s'a.\n       \\<lbrakk>I' s';\n        \\<And>s s'.\n           (s, s') \\<in> R' \\<Longrightarrow>\n           W s \\<le> \\<Down> R (WHILE\\<^bsup>I'\\<^esup> b' f' s');\n        (s, s'a) \\<in> R'; I' s'a; I s; b s\\<rbrakk>\n       \\<Longrightarrow> \\<Down> R' (RETURN s'a) \\<bind> W\n                         \\<le> \\<Down> R (WHILE\\<^bsup>I'\\<^esup> b' f' s'a)", "apply (rule bind_refine)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>W s s'a.\n       \\<lbrakk>I' s';\n        \\<And>s s'.\n           (s, s') \\<in> R' \\<Longrightarrow>\n           W s \\<le> \\<Down> R (WHILE\\<^bsup>I'\\<^esup> b' f' s');\n        (s, s'a) \\<in> R'; I' s'a; I s; b s; b' s'a\\<rbrakk>\n       \\<Longrightarrow> \\<Down> R' (f' s'a)\n                         \\<le> \\<Down> (?R'58 W s s'a) (f' s'a)\n 2. \\<And>W s s'a x x'.\n       \\<lbrakk>I' s';\n        \\<And>s s'.\n           (s, s') \\<in> R' \\<Longrightarrow>\n           W s \\<le> \\<Down> R (WHILE\\<^bsup>I'\\<^esup> b' f' s');\n        (s, s'a) \\<in> R'; I' s'a; I s; b s; b' s'a;\n        (x, x') \\<in> ?R'58 W s s'a\\<rbrakk>\n       \\<Longrightarrow> W x\n                         \\<le> \\<Down> R (WHILE\\<^bsup>I'\\<^esup> b' f' x')\n 3. \\<And>W s s'a.\n       \\<lbrakk>I' s';\n        \\<And>s s'.\n           (s, s') \\<in> R' \\<Longrightarrow>\n           W s \\<le> \\<Down> R (WHILE\\<^bsup>I'\\<^esup> b' f' s');\n        (s, s'a) \\<in> R'; I' s'a; I s; b s\\<rbrakk>\n       \\<Longrightarrow> \\<Down> R' (RETURN s'a) \\<bind> W\n                         \\<le> \\<Down> R (WHILE\\<^bsup>I'\\<^esup> b' f' s'a)", "apply (rule order_refl)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>W s s'a x x'.\n       \\<lbrakk>I' s';\n        \\<And>s s'.\n           (s, s') \\<in> R' \\<Longrightarrow>\n           W s \\<le> \\<Down> R (WHILE\\<^bsup>I'\\<^esup> b' f' s');\n        (s, s'a) \\<in> R'; I' s'a; I s; b s; b' s'a;\n        (x, x') \\<in> R'\\<rbrakk>\n       \\<Longrightarrow> W x\n                         \\<le> \\<Down> R (WHILE\\<^bsup>I'\\<^esup> b' f' x')\n 2. \\<And>W s s'a.\n       \\<lbrakk>I' s';\n        \\<And>s s'.\n           (s, s') \\<in> R' \\<Longrightarrow>\n           W s \\<le> \\<Down> R (WHILE\\<^bsup>I'\\<^esup> b' f' s');\n        (s, s'a) \\<in> R'; I' s'a; I s; b s\\<rbrakk>\n       \\<Longrightarrow> \\<Down> R' (RETURN s'a) \\<bind> W\n                         \\<le> \\<Down> R (WHILE\\<^bsup>I'\\<^esup> b' f' s'a)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>W s s'a.\n       \\<lbrakk>I' s';\n        \\<And>s s'.\n           (s, s') \\<in> R' \\<Longrightarrow>\n           W s \\<le> \\<Down> R (WHILE\\<^bsup>I'\\<^esup> b' f' s');\n        (s, s'a) \\<in> R'; I' s'a; I s; b s\\<rbrakk>\n       \\<Longrightarrow> \\<Down> R' (RETURN s'a) \\<bind> W\n                         \\<le> \\<Down> R (WHILE\\<^bsup>I'\\<^esup> b' f' s'a)", "apply (simp add: pw_le_iff refine_pw_simps, blast)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma WHILEI_refine_genR:\n  assumes R0: \"I' x' \\<Longrightarrow> (x,x')\\<in>R'\"\n  assumes IREF: \"\\<And>x x'. \\<lbrakk> (x,x')\\<in>R'; I' x' \\<rbrakk> \\<Longrightarrow> I x\"\n  assumes COND_REF: \"\\<And>x x'. \\<lbrakk> (x,x')\\<in>R'; I x; I' x' \\<rbrakk> \\<Longrightarrow> b x = b' x'\"\n  assumes STEP_REF: \n    \"\\<And>x x'. \\<lbrakk> (x,x')\\<in>R'; b x; b' x'; I x; I' x' \\<rbrakk> \\<Longrightarrow> f x \\<le> \\<Down>R' (f' x')\"\n  assumes R_REF: \n    \"\\<And>x x'. \\<lbrakk> (x,x')\\<in>R'; \\<not>b x; \\<not>b' x'; I x; I' x' \\<rbrakk> \\<Longrightarrow> (x,x')\\<in>R\"\n  shows \"WHILEI I b f x \\<le>\\<Down>R (WHILEI I' b' f' x')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. WHILE\\<^bsup>I\\<^esup> b f x\n    \\<le> \\<Down> R (WHILE\\<^bsup>I'\\<^esup> b' f' x')", "apply (rule WHILEI_invisible_refine_genR[OF R0])"], ["proof (prove)\ngoal (5 subgoals):\n 1. I' x' \\<Longrightarrow> I' x'\n 2. \\<And>s s'.\n       \\<lbrakk>(s, s') \\<in> R'; I' s'\\<rbrakk> \\<Longrightarrow> I s\n 3. \\<And>s s'.\n       \\<lbrakk>(s, s') \\<in> R'; I' s'; I s; b' s'\\<rbrakk>\n       \\<Longrightarrow> b s\n 4. \\<And>s s'.\n       \\<lbrakk>(s, s') \\<in> R'; I' s'; I s; b s\\<rbrakk>\n       \\<Longrightarrow> f s\n                         \\<le> sup (\\<Down> R'\n                                     (ASSUME (b' s') \\<bind>\n(\\<lambda>_. f' s')))\n                                (\\<Down> R' (RETURN s'))\n 5. \\<And>x x'.\n       \\<lbrakk>(x, x') \\<in> R'; \\<not> b x; \\<not> b' x'; I x;\n        I' x'\\<rbrakk>\n       \\<Longrightarrow> (x, x') \\<in> R", "apply assumption"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>s s'.\n       \\<lbrakk>(s, s') \\<in> R'; I' s'\\<rbrakk> \\<Longrightarrow> I s\n 2. \\<And>s s'.\n       \\<lbrakk>(s, s') \\<in> R'; I' s'; I s; b' s'\\<rbrakk>\n       \\<Longrightarrow> b s\n 3. \\<And>s s'.\n       \\<lbrakk>(s, s') \\<in> R'; I' s'; I s; b s\\<rbrakk>\n       \\<Longrightarrow> f s\n                         \\<le> sup (\\<Down> R'\n                                     (ASSUME (b' s') \\<bind>\n(\\<lambda>_. f' s')))\n                                (\\<Down> R' (RETURN s'))\n 4. \\<And>x x'.\n       \\<lbrakk>(x, x') \\<in> R'; \\<not> b x; \\<not> b' x'; I x;\n        I' x'\\<rbrakk>\n       \\<Longrightarrow> (x, x') \\<in> R", "apply (erule (1) IREF)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>s s'.\n       \\<lbrakk>(s, s') \\<in> R'; I' s'; I s; b' s'\\<rbrakk>\n       \\<Longrightarrow> b s\n 2. \\<And>s s'.\n       \\<lbrakk>(s, s') \\<in> R'; I' s'; I s; b s\\<rbrakk>\n       \\<Longrightarrow> f s\n                         \\<le> sup (\\<Down> R'\n                                     (ASSUME (b' s') \\<bind>\n(\\<lambda>_. f' s')))\n                                (\\<Down> R' (RETURN s'))\n 3. \\<And>x x'.\n       \\<lbrakk>(x, x') \\<in> R'; \\<not> b x; \\<not> b' x'; I x;\n        I' x'\\<rbrakk>\n       \\<Longrightarrow> (x, x') \\<in> R", "apply (simp add: COND_REF)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s s'.\n       \\<lbrakk>(s, s') \\<in> R'; I' s'; I s; b s\\<rbrakk>\n       \\<Longrightarrow> f s\n                         \\<le> sup (\\<Down> R'\n                                     (ASSUME (b' s') \\<bind>\n(\\<lambda>_. f' s')))\n                                (\\<Down> R' (RETURN s'))\n 2. \\<And>x x'.\n       \\<lbrakk>(x, x') \\<in> R'; \\<not> b x; \\<not> b' x'; I x;\n        I' x'\\<rbrakk>\n       \\<Longrightarrow> (x, x') \\<in> R", "apply (rule le_supI1)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s s'.\n       \\<lbrakk>(s, s') \\<in> R'; I' s'; I s; b s\\<rbrakk>\n       \\<Longrightarrow> f s\n                         \\<le> \\<Down> R'\n                                (ASSUME (b' s') \\<bind> (\\<lambda>_. f' s'))\n 2. \\<And>x x'.\n       \\<lbrakk>(x, x') \\<in> R'; \\<not> b x; \\<not> b' x'; I x;\n        I' x'\\<rbrakk>\n       \\<Longrightarrow> (x, x') \\<in> R", "apply (simp add: COND_REF STEP_REF)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x x'.\n       \\<lbrakk>(x, x') \\<in> R'; \\<not> b x; \\<not> b' x'; I x;\n        I' x'\\<rbrakk>\n       \\<Longrightarrow> (x, x') \\<in> R", "apply (rule R_REF, assumption+)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma WHILE_invisible_refine_genR:\n  assumes R0: \"(s,s')\\<in>R'\"\n  assumes RB: \"\\<And>s s'. \\<lbrakk> (s,s')\\<in>R'; b' s' \\<rbrakk> \\<Longrightarrow> b s\"\n  assumes RS: \"\\<And>s s'. \\<lbrakk> (s,s')\\<in>R'; b s \\<rbrakk> \n    \\<Longrightarrow> f s \\<le> sup (\\<Down>R' (do {ASSUME (b' s'); f' s'})) (\\<Down>R' (RETURN s'))\"\n  assumes R_REF: \n    \"\\<And>x x'. \\<lbrakk> (x,x')\\<in>R'; \\<not>b x; \\<not>b' x' \\<rbrakk> \\<Longrightarrow> (x,x')\\<in>R\"\n  shows \"WHILE b f s \\<le> \\<Down>R (WHILE b' f' s')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. WHILE b f s \\<le> \\<Down> R (WHILE b' f' s')", "unfolding WHILE_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. WHILE\\<^bsup>\\<lambda>_. True\\<^esup> b f s\n    \\<le> \\<Down> R (WHILE\\<^bsup>\\<lambda>_. True\\<^esup> b' f' s')", "apply (rule WHILEI_invisible_refine_genR)"], ["proof (prove)\ngoal (5 subgoals):\n 1. True \\<Longrightarrow> (s, s') \\<in> ?R'\n 2. \\<And>s s'.\n       \\<lbrakk>(s, s') \\<in> ?R'; True\\<rbrakk> \\<Longrightarrow> True\n 3. \\<And>s s'.\n       \\<lbrakk>(s, s') \\<in> ?R'; True; True; b' s'\\<rbrakk>\n       \\<Longrightarrow> b s\n 4. \\<And>s s'.\n       \\<lbrakk>(s, s') \\<in> ?R'; True; True; b s\\<rbrakk>\n       \\<Longrightarrow> f s\n                         \\<le> sup (\\<Down> ?R'\n                                     (ASSUME (b' s') \\<bind>\n(\\<lambda>_. f' s')))\n                                (\\<Down> ?R' (RETURN s'))\n 5. \\<And>x x'.\n       \\<lbrakk>(x, x') \\<in> ?R'; \\<not> b x; \\<not> b' x'; True;\n        True\\<rbrakk>\n       \\<Longrightarrow> (x, x') \\<in> R", "apply (rule assms, (assumption+)?)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma WHILE_refine_genR:\n  assumes R0: \"(x,x')\\<in>R'\"\n  assumes COND_REF: \"\\<And>x x'. \\<lbrakk> (x,x')\\<in>R' \\<rbrakk> \\<Longrightarrow> b x = b' x'\"\n  assumes STEP_REF: \n    \"\\<And>x x'. \\<lbrakk> (x,x')\\<in>R'; b x; b' x' \\<rbrakk> \\<Longrightarrow> f x \\<le> \\<Down>R' (f' x')\"\n  assumes R_REF: \n    \"\\<And>x x'. \\<lbrakk> (x,x')\\<in>R'; \\<not>b x; \\<not>b' x' \\<rbrakk> \\<Longrightarrow> (x,x')\\<in>R\"\n  shows \"WHILE b f x \\<le>\\<Down>R (WHILE b' f' x')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. WHILE b f x \\<le> \\<Down> R (WHILE b' f' x')", "unfolding WHILE_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. WHILE\\<^bsup>\\<lambda>_. True\\<^esup> b f x\n    \\<le> \\<Down> R (WHILE\\<^bsup>\\<lambda>_. True\\<^esup> b' f' x')", "apply (rule WHILEI_refine_genR)"], ["proof (prove)\ngoal (5 subgoals):\n 1. True \\<Longrightarrow> (x, x') \\<in> ?R'\n 2. \\<And>x x'.\n       \\<lbrakk>(x, x') \\<in> ?R'; True\\<rbrakk> \\<Longrightarrow> True\n 3. \\<And>x x'.\n       \\<lbrakk>(x, x') \\<in> ?R'; True; True\\<rbrakk>\n       \\<Longrightarrow> b x = b' x'\n 4. \\<And>x x'.\n       \\<lbrakk>(x, x') \\<in> ?R'; b x; b' x'; True; True\\<rbrakk>\n       \\<Longrightarrow> f x \\<le> \\<Down> ?R' (f' x')\n 5. \\<And>x x'.\n       \\<lbrakk>(x, x') \\<in> ?R'; \\<not> b x; \\<not> b' x'; True;\n        True\\<rbrakk>\n       \\<Longrightarrow> (x, x') \\<in> R", "apply (rule assms, (assumption+)?)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma WHILE_refine_genR':\n  assumes R0: \"(x,x')\\<in>R'\"\n  assumes COND_REF: \"\\<And>x x'. \\<lbrakk> (x,x')\\<in>R'; I' x' \\<rbrakk> \\<Longrightarrow> b x = b' x'\"\n  assumes STEP_REF: \n    \"\\<And>x x'. \\<lbrakk> (x,x')\\<in>R'; b x; b' x'; I' x' \\<rbrakk> \\<Longrightarrow> f x \\<le> \\<Down>R' (f' x')\"\n  assumes R_REF: \n    \"\\<And>x x'. \\<lbrakk> (x,x')\\<in>R'; \\<not>b x; \\<not>b' x' \\<rbrakk> \\<Longrightarrow> (x,x')\\<in>R\"\n  shows \"WHILE b f x \\<le>\\<Down>R (WHILEI I' b' f' x')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. WHILE b f x \\<le> \\<Down> R (WHILE\\<^bsup>I'\\<^esup> b' f' x')", "unfolding WHILE_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. WHILE\\<^bsup>\\<lambda>_. True\\<^esup> b f x\n    \\<le> \\<Down> R (WHILE\\<^bsup>I'\\<^esup> b' f' x')", "apply (rule WHILEI_refine_genR)"], ["proof (prove)\ngoal (5 subgoals):\n 1. I' x' \\<Longrightarrow> (x, x') \\<in> ?R'\n 2. \\<And>x x'.\n       \\<lbrakk>(x, x') \\<in> ?R'; I' x'\\<rbrakk> \\<Longrightarrow> True\n 3. \\<And>x x'.\n       \\<lbrakk>(x, x') \\<in> ?R'; True; I' x'\\<rbrakk>\n       \\<Longrightarrow> b x = b' x'\n 4. \\<And>x x'.\n       \\<lbrakk>(x, x') \\<in> ?R'; b x; b' x'; True; I' x'\\<rbrakk>\n       \\<Longrightarrow> f x \\<le> \\<Down> ?R' (f' x')\n 5. \\<And>x x'.\n       \\<lbrakk>(x, x') \\<in> ?R'; \\<not> b x; \\<not> b' x'; True;\n        I' x'\\<rbrakk>\n       \\<Longrightarrow> (x, x') \\<in> R", "apply (rule assms TrueI, (assumption+)?)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>WHILE-refinement rule with invisible concrete steps.\n  Intuitively, a concrete step may either refine an abstract step, or\n  must not change the corresponding abstract state.\\<close>"], ["", "lemma WHILEI_invisible_refine:\n  assumes R0: \"I' s' \\<Longrightarrow> (s,s')\\<in>R\"\n  assumes RI: \"\\<And>s s'. \\<lbrakk> (s,s')\\<in>R; I' s' \\<rbrakk> \\<Longrightarrow> I s\"\n  assumes RB: \"\\<And>s s'. \\<lbrakk> (s,s')\\<in>R; I' s'; I s; b' s' \\<rbrakk> \\<Longrightarrow> b s\"\n  assumes RS: \"\\<And>s s'. \\<lbrakk> (s,s')\\<in>R; I' s'; I s; b s \\<rbrakk> \n    \\<Longrightarrow> f s \\<le> sup (\\<Down>R (do {ASSUME (b' s'); f' s'})) (\\<Down>R (RETURN s'))\"\n  shows \"WHILEI I b f s \\<le> \\<Down>R (WHILEI I' b' f' s')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. WHILE\\<^bsup>I\\<^esup> b f s\n    \\<le> \\<Down> R (WHILE\\<^bsup>I'\\<^esup> b' f' s')", "apply (rule WHILEI_invisible_refine_genR[where R'=R])"], ["proof (prove)\ngoal (5 subgoals):\n 1. I' s' \\<Longrightarrow> (s, s') \\<in> R\n 2. \\<And>s s'.\n       \\<lbrakk>(s, s') \\<in> R; I' s'\\<rbrakk> \\<Longrightarrow> I s\n 3. \\<And>s s'.\n       \\<lbrakk>(s, s') \\<in> R; I' s'; I s; b' s'\\<rbrakk>\n       \\<Longrightarrow> b s\n 4. \\<And>s s'.\n       \\<lbrakk>(s, s') \\<in> R; I' s'; I s; b s\\<rbrakk>\n       \\<Longrightarrow> f s\n                         \\<le> sup (\\<Down> R\n                                     (ASSUME (b' s') \\<bind>\n(\\<lambda>_. f' s')))\n                                (\\<Down> R (RETURN s'))\n 5. \\<And>x x'.\n       \\<lbrakk>(x, x') \\<in> R; \\<not> b x; \\<not> b' x'; I x;\n        I' x'\\<rbrakk>\n       \\<Longrightarrow> (x, x') \\<in> R", "apply (rule assms, (assumption+)?)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma WHILEI_refine[refine]:\n  assumes R0: \"I' x' \\<Longrightarrow> (x,x')\\<in>R\"\n  assumes IREF: \"\\<And>x x'. \\<lbrakk> (x,x')\\<in>R; I' x' \\<rbrakk> \\<Longrightarrow> I x\"\n  assumes COND_REF: \"\\<And>x x'. \\<lbrakk> (x,x')\\<in>R; I x; I' x' \\<rbrakk> \\<Longrightarrow> b x = b' x'\"\n  assumes STEP_REF: \n    \"\\<And>x x'. \\<lbrakk> (x,x')\\<in>R; b x; b' x'; I x; I' x' \\<rbrakk> \\<Longrightarrow> f x \\<le> \\<Down>R (f' x')\"\n  shows \"WHILEI I b f x \\<le>\\<Down>R (WHILEI I' b' f' x')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. WHILE\\<^bsup>I\\<^esup> b f x\n    \\<le> \\<Down> R (WHILE\\<^bsup>I'\\<^esup> b' f' x')", "apply (rule WHILEI_invisible_refine[OF R0])"], ["proof (prove)\ngoal (4 subgoals):\n 1. I' x' \\<Longrightarrow> I' x'\n 2. \\<And>s s'.\n       \\<lbrakk>(s, s') \\<in> R; I' s'\\<rbrakk> \\<Longrightarrow> I s\n 3. \\<And>s s'.\n       \\<lbrakk>(s, s') \\<in> R; I' s'; I s; b' s'\\<rbrakk>\n       \\<Longrightarrow> b s\n 4. \\<And>s s'.\n       \\<lbrakk>(s, s') \\<in> R; I' s'; I s; b s\\<rbrakk>\n       \\<Longrightarrow> f s\n                         \\<le> sup (\\<Down> R\n                                     (ASSUME (b' s') \\<bind>\n(\\<lambda>_. f' s')))\n                                (\\<Down> R (RETURN s'))", "apply assumption"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>s s'.\n       \\<lbrakk>(s, s') \\<in> R; I' s'\\<rbrakk> \\<Longrightarrow> I s\n 2. \\<And>s s'.\n       \\<lbrakk>(s, s') \\<in> R; I' s'; I s; b' s'\\<rbrakk>\n       \\<Longrightarrow> b s\n 3. \\<And>s s'.\n       \\<lbrakk>(s, s') \\<in> R; I' s'; I s; b s\\<rbrakk>\n       \\<Longrightarrow> f s\n                         \\<le> sup (\\<Down> R\n                                     (ASSUME (b' s') \\<bind>\n(\\<lambda>_. f' s')))\n                                (\\<Down> R (RETURN s'))", "apply (erule (1) IREF)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s s'.\n       \\<lbrakk>(s, s') \\<in> R; I' s'; I s; b' s'\\<rbrakk>\n       \\<Longrightarrow> b s\n 2. \\<And>s s'.\n       \\<lbrakk>(s, s') \\<in> R; I' s'; I s; b s\\<rbrakk>\n       \\<Longrightarrow> f s\n                         \\<le> sup (\\<Down> R\n                                     (ASSUME (b' s') \\<bind>\n(\\<lambda>_. f' s')))\n                                (\\<Down> R (RETURN s'))", "apply (simp add: COND_REF)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s s'.\n       \\<lbrakk>(s, s') \\<in> R; I' s'; I s; b s\\<rbrakk>\n       \\<Longrightarrow> f s\n                         \\<le> sup (\\<Down> R\n                                     (ASSUME (b' s') \\<bind>\n(\\<lambda>_. f' s')))\n                                (\\<Down> R (RETURN s'))", "apply (rule le_supI1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s s'.\n       \\<lbrakk>(s, s') \\<in> R; I' s'; I s; b s\\<rbrakk>\n       \\<Longrightarrow> f s\n                         \\<le> \\<Down> R\n                                (ASSUME (b' s') \\<bind> (\\<lambda>_. f' s'))", "apply (simp add: COND_REF STEP_REF)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma WHILE_invisible_refine:\n  assumes R0: \"(s,s')\\<in>R\"\n  assumes RB: \"\\<And>s s'. \\<lbrakk> (s,s')\\<in>R; b' s' \\<rbrakk> \\<Longrightarrow> b s\"\n  assumes RS: \"\\<And>s s'. \\<lbrakk> (s,s')\\<in>R; b s \\<rbrakk> \n    \\<Longrightarrow> f s \\<le> sup (\\<Down>R (do {ASSUME (b' s'); f' s'})) (\\<Down>R (RETURN s'))\"\n  shows \"WHILE b f s \\<le> \\<Down>R (WHILE b' f' s')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. WHILE b f s \\<le> \\<Down> R (WHILE b' f' s')", "unfolding WHILE_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. WHILE\\<^bsup>\\<lambda>_. True\\<^esup> b f s\n    \\<le> \\<Down> R (WHILE\\<^bsup>\\<lambda>_. True\\<^esup> b' f' s')", "apply (rule WHILEI_invisible_refine)"], ["proof (prove)\ngoal (4 subgoals):\n 1. True \\<Longrightarrow> (s, s') \\<in> R\n 2. \\<And>s s'.\n       \\<lbrakk>(s, s') \\<in> R; True\\<rbrakk> \\<Longrightarrow> True\n 3. \\<And>s s'.\n       \\<lbrakk>(s, s') \\<in> R; True; True; b' s'\\<rbrakk>\n       \\<Longrightarrow> b s\n 4. \\<And>s s'.\n       \\<lbrakk>(s, s') \\<in> R; True; True; b s\\<rbrakk>\n       \\<Longrightarrow> f s\n                         \\<le> sup (\\<Down> R\n                                     (ASSUME (b' s') \\<bind>\n(\\<lambda>_. f' s')))\n                                (\\<Down> R (RETURN s'))", "using assms"], ["proof (prove)\nusing this:\n  (s, s') \\<in> R\n  \\<lbrakk>(?s, ?s') \\<in> R; b' ?s'\\<rbrakk> \\<Longrightarrow> b ?s\n  \\<lbrakk>(?s, ?s') \\<in> R; b ?s\\<rbrakk>\n  \\<Longrightarrow> f ?s\n                    \\<le> sup (\\<Down> R\n                                (ASSUME (b' ?s') \\<bind>\n                                 (\\<lambda>_. f' ?s')))\n                           (\\<Down> R (RETURN ?s'))\n\ngoal (4 subgoals):\n 1. True \\<Longrightarrow> (s, s') \\<in> R\n 2. \\<And>s s'.\n       \\<lbrakk>(s, s') \\<in> R; True\\<rbrakk> \\<Longrightarrow> True\n 3. \\<And>s s'.\n       \\<lbrakk>(s, s') \\<in> R; True; True; b' s'\\<rbrakk>\n       \\<Longrightarrow> b s\n 4. \\<And>s s'.\n       \\<lbrakk>(s, s') \\<in> R; True; True; b s\\<rbrakk>\n       \\<Longrightarrow> f s\n                         \\<le> sup (\\<Down> R\n                                     (ASSUME (b' s') \\<bind>\n(\\<lambda>_. f' s')))\n                                (\\<Down> R (RETURN s'))", "by auto"], ["", "lemma WHILE_le_rule:\n  assumes R0: \"(s,s')\\<in>R\"\n  assumes RS: \"\\<And>W s s'. \\<lbrakk>\\<And>s s'. (s,s')\\<in>R \\<Longrightarrow> W s \\<le> M s'; (s,s')\\<in>R\\<rbrakk> \\<Longrightarrow> \n    do {if b s then bind (f s) W else RETURN s} \\<le> M s'\"\n  shows \"WHILE b f s \\<le> M s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. WHILE b f s \\<le> M s'", "unfolding WHILE_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. WHILE\\<^bsup>\\<lambda>_. True\\<^esup> b f s \\<le> M s'", "apply (rule WHILEI_le_rule[OF R0])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>W s s'.\n       \\<lbrakk>\\<And>s s'.\n                   (s, s') \\<in> R \\<Longrightarrow> W s \\<le> M s';\n        (s, s') \\<in> R\\<rbrakk>\n       \\<Longrightarrow> ASSERT True \\<bind>\n                         (\\<lambda>_.\n                             if b s then f s \\<bind> W else RETURN s)\n                         \\<le> M s'", "apply (simp add: RS)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma WHILE_refine[refine]:\n  assumes R0: \"(x,x')\\<in>R\"\n  assumes COND_REF: \"\\<And>x x'. \\<lbrakk> (x,x')\\<in>R \\<rbrakk> \\<Longrightarrow> b x = b' x'\"\n  assumes STEP_REF: \n    \"\\<And>x x'. \\<lbrakk> (x,x')\\<in>R; b x; b' x' \\<rbrakk> \\<Longrightarrow> f x \\<le> \\<Down>R (f' x')\"\n  shows \"WHILE b f x \\<le>\\<Down>R (WHILE b' f' x')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. WHILE b f x \\<le> \\<Down> R (WHILE b' f' x')", "unfolding WHILE_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. WHILE\\<^bsup>\\<lambda>_. True\\<^esup> b f x\n    \\<le> \\<Down> R (WHILE\\<^bsup>\\<lambda>_. True\\<^esup> b' f' x')", "apply (rule WHILEI_refine)"], ["proof (prove)\ngoal (4 subgoals):\n 1. True \\<Longrightarrow> (x, x') \\<in> R\n 2. \\<And>x x'.\n       \\<lbrakk>(x, x') \\<in> R; True\\<rbrakk> \\<Longrightarrow> True\n 3. \\<And>x x'.\n       \\<lbrakk>(x, x') \\<in> R; True; True\\<rbrakk>\n       \\<Longrightarrow> b x = b' x'\n 4. \\<And>x x'.\n       \\<lbrakk>(x, x') \\<in> R; b x; b' x'; True; True\\<rbrakk>\n       \\<Longrightarrow> f x \\<le> \\<Down> R (f' x')", "using assms"], ["proof (prove)\nusing this:\n  (x, x') \\<in> R\n  (?x, ?x') \\<in> R \\<Longrightarrow> b ?x = b' ?x'\n  \\<lbrakk>(?x, ?x') \\<in> R; b ?x; b' ?x'\\<rbrakk>\n  \\<Longrightarrow> f ?x \\<le> \\<Down> R (f' ?x')\n\ngoal (4 subgoals):\n 1. True \\<Longrightarrow> (x, x') \\<in> R\n 2. \\<And>x x'.\n       \\<lbrakk>(x, x') \\<in> R; True\\<rbrakk> \\<Longrightarrow> True\n 3. \\<And>x x'.\n       \\<lbrakk>(x, x') \\<in> R; True; True\\<rbrakk>\n       \\<Longrightarrow> b x = b' x'\n 4. \\<And>x x'.\n       \\<lbrakk>(x, x') \\<in> R; b x; b' x'; True; True\\<rbrakk>\n       \\<Longrightarrow> f x \\<le> \\<Down> R (f' x')", "by auto"], ["", "lemma WHILE_refine'[refine]:\n  assumes R0: \"I' x' \\<Longrightarrow> (x,x')\\<in>R\"\n  assumes COND_REF: \"\\<And>x x'. \\<lbrakk> (x,x')\\<in>R; I' x' \\<rbrakk> \\<Longrightarrow> b x = b' x'\"\n  assumes STEP_REF: \n    \"\\<And>x x'. \\<lbrakk> (x,x')\\<in>R; b x; b' x'; I' x' \\<rbrakk> \\<Longrightarrow> f x \\<le> \\<Down>R (f' x')\"\n  shows \"WHILE b f x \\<le>\\<Down>R (WHILEI I' b' f' x')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. WHILE b f x \\<le> \\<Down> R (WHILE\\<^bsup>I'\\<^esup> b' f' x')", "unfolding WHILE_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. WHILE\\<^bsup>\\<lambda>_. True\\<^esup> b f x\n    \\<le> \\<Down> R (WHILE\\<^bsup>I'\\<^esup> b' f' x')", "apply (rule WHILEI_refine)"], ["proof (prove)\ngoal (4 subgoals):\n 1. I' x' \\<Longrightarrow> (x, x') \\<in> R\n 2. \\<And>x x'.\n       \\<lbrakk>(x, x') \\<in> R; I' x'\\<rbrakk> \\<Longrightarrow> True\n 3. \\<And>x x'.\n       \\<lbrakk>(x, x') \\<in> R; True; I' x'\\<rbrakk>\n       \\<Longrightarrow> b x = b' x'\n 4. \\<And>x x'.\n       \\<lbrakk>(x, x') \\<in> R; b x; b' x'; True; I' x'\\<rbrakk>\n       \\<Longrightarrow> f x \\<le> \\<Down> R (f' x')", "using assms"], ["proof (prove)\nusing this:\n  I' x' \\<Longrightarrow> (x, x') \\<in> R\n  \\<lbrakk>(?x, ?x') \\<in> R; I' ?x'\\<rbrakk>\n  \\<Longrightarrow> b ?x = b' ?x'\n  \\<lbrakk>(?x, ?x') \\<in> R; b ?x; b' ?x'; I' ?x'\\<rbrakk>\n  \\<Longrightarrow> f ?x \\<le> \\<Down> R (f' ?x')\n\ngoal (4 subgoals):\n 1. I' x' \\<Longrightarrow> (x, x') \\<in> R\n 2. \\<And>x x'.\n       \\<lbrakk>(x, x') \\<in> R; I' x'\\<rbrakk> \\<Longrightarrow> True\n 3. \\<And>x x'.\n       \\<lbrakk>(x, x') \\<in> R; True; I' x'\\<rbrakk>\n       \\<Longrightarrow> b x = b' x'\n 4. \\<And>x x'.\n       \\<lbrakk>(x, x') \\<in> R; b x; b' x'; True; I' x'\\<rbrakk>\n       \\<Longrightarrow> f x \\<le> \\<Down> R (f' x')", "by auto"], ["", "lemma AIF_leI: \"\\<lbrakk>\\<Phi>; \\<Phi> \\<Longrightarrow> S\\<le>S'\\<rbrakk> \\<Longrightarrow> (if \\<Phi> then S else FAIL) \\<le> S'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<Phi>; \\<Phi> \\<Longrightarrow> S \\<le> S'\\<rbrakk>\n    \\<Longrightarrow> (if \\<Phi> then S else FAIL) \\<le> S'", "by auto"], ["", "lemma ref_AIFI: \"\\<lbrakk>\\<Phi> \\<Longrightarrow> S\\<le>\\<Down>R S'\\<rbrakk> \\<Longrightarrow> S \\<le> \\<Down>R (if \\<Phi> then S' else FAIL)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Phi> \\<Longrightarrow> S \\<le> \\<Down> R S') \\<Longrightarrow>\n    S \\<le> \\<Down> R (if \\<Phi> then S' else FAIL)", "by (cases \\<Phi>) auto"], ["", "text \\<open>Refinement with generalized refinement relation. Required to exploit\n  the fact that the condition does not hold at the end of the loop.\\<close>"], ["", "lemma WHILEIT_refine_genR:\n  assumes R0: \"I' x' \\<Longrightarrow> (x,x')\\<in>R'\"\n  assumes IREF: \"\\<And>x x'. \\<lbrakk> (x,x')\\<in>R'; I' x' \\<rbrakk> \\<Longrightarrow> I x\"\n  assumes COND_REF: \"\\<And>x x'. \\<lbrakk> (x,x')\\<in>R'; I x; I' x' \\<rbrakk> \\<Longrightarrow> b x = b' x'\"\n  assumes STEP_REF: \n    \"\\<And>x x'. \\<lbrakk> (x,x')\\<in>R'; b x; b' x'; I x; I' x' \\<rbrakk> \\<Longrightarrow> f x \\<le> \\<Down>R' (f' x')\"\n  assumes R_REF: \n    \"\\<And>x x'. \\<lbrakk> (x,x')\\<in>R'; \\<not>b x; \\<not>b' x'; I x; I' x' \\<rbrakk> \\<Longrightarrow> (x,x')\\<in>R\"\n  shows \"WHILEIT I b f x \\<le>\\<Down>R (WHILEIT I' b' f' x')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. WHILE\\<^sub>T\\<^bsup>I\\<^esup> b f x\n    \\<le> \\<Down> R (WHILE\\<^sub>T\\<^bsup>I'\\<^esup> b' f' x')", "apply (rule ref_WHILEIT_invarI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. I' x' \\<Longrightarrow>\n    WHILE\\<^sub>T\\<^bsup>I\\<^esup> b f x\n    \\<le> \\<Down> R (WHILE\\<^sub>T\\<^bsup>I'\\<^esup> b' f' x')", "unfolding WHILEIT_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. I' x' \\<Longrightarrow>\n    REC\\<^sub>T (WHILEI_body (\\<bind>) RETURN I b f) x\n    \\<le> \\<Down> R (REC\\<^sub>T (WHILEI_body (\\<bind>) RETURN I' b' f') x')", "apply (rule RECT_refine[OF WHILEI_body_trimono R0])"], ["proof (prove)\ngoal (2 subgoals):\n 1. I' x' \\<Longrightarrow> I' x'\n 2. \\<And>fa f'a x x'a.\n       \\<lbrakk>I' x';\n        \\<And>x x'.\n           (x, x') \\<in> R' \\<Longrightarrow> fa x \\<le> \\<Down> R (f'a x');\n        (x, x'a) \\<in> R'\\<rbrakk>\n       \\<Longrightarrow> WHILEI_body (\\<bind>) RETURN I b f fa x\n                         \\<le> \\<Down> R\n                                (WHILEI_body (\\<bind>) RETURN I' b' f' f'a\n                                  x'a)", "apply assumption"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>fa f'a x x'a.\n       \\<lbrakk>I' x';\n        \\<And>x x'.\n           (x, x') \\<in> R' \\<Longrightarrow> fa x \\<le> \\<Down> R (f'a x');\n        (x, x'a) \\<in> R'\\<rbrakk>\n       \\<Longrightarrow> WHILEI_body (\\<bind>) RETURN I b f fa x\n                         \\<le> \\<Down> R\n                                (WHILEI_body (\\<bind>) RETURN I' b' f' f'a\n                                  x'a)", "unfolding WHILEI_body_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>fa f'a x x'a.\n       \\<lbrakk>I' x';\n        \\<And>x x'.\n           (x, x') \\<in> R' \\<Longrightarrow> fa x \\<le> \\<Down> R (f'a x');\n        (x, x'a) \\<in> R'\\<rbrakk>\n       \\<Longrightarrow> (if I x\n                          then if b x then f x \\<bind> fa else RETURN x\n                          else FAIL)\n                         \\<le> \\<Down> R\n                                (if I' x'a\n                                 then if b' x'a then f' x'a \\<bind> f'a\nelse RETURN x'a\n                                 else FAIL)", "apply (rule ref_AIFI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>fa f'a x x'a.\n       \\<lbrakk>I' x';\n        \\<And>x x'.\n           (x, x') \\<in> R' \\<Longrightarrow> fa x \\<le> \\<Down> R (f'a x');\n        (x, x'a) \\<in> R'; I' x'a\\<rbrakk>\n       \\<Longrightarrow> (if I x\n                          then if b x then f x \\<bind> fa else RETURN x\n                          else FAIL)\n                         \\<le> \\<Down> R\n                                (if b' x'a then f' x'a \\<bind> f'a\n                                 else RETURN x'a)", "apply (rule AIF_leI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>f f' x x'a.\n       \\<lbrakk>I' x';\n        \\<And>x x'.\n           (x, x') \\<in> R' \\<Longrightarrow> f x \\<le> \\<Down> R (f' x');\n        (x, x'a) \\<in> R'; I' x'a\\<rbrakk>\n       \\<Longrightarrow> I x\n 2. \\<And>fa f'a x x'a.\n       \\<lbrakk>I' x';\n        \\<And>x x'.\n           (x, x') \\<in> R' \\<Longrightarrow> fa x \\<le> \\<Down> R (f'a x');\n        (x, x'a) \\<in> R'; I' x'a; I x\\<rbrakk>\n       \\<Longrightarrow> (if b x then f x \\<bind> fa else RETURN x)\n                         \\<le> \\<Down> R\n                                (if b' x'a then f' x'a \\<bind> f'a\n                                 else RETURN x'a)", "apply (blast intro: IREF)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>fa f'a x x'a.\n       \\<lbrakk>I' x';\n        \\<And>x x'.\n           (x, x') \\<in> R' \\<Longrightarrow> fa x \\<le> \\<Down> R (f'a x');\n        (x, x'a) \\<in> R'; I' x'a; I x\\<rbrakk>\n       \\<Longrightarrow> (if b x then f x \\<bind> fa else RETURN x)\n                         \\<le> \\<Down> R\n                                (if b' x'a then f' x'a \\<bind> f'a\n                                 else RETURN x'a)", "apply (rule if_refine)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>f f' x x'a.\n       \\<lbrakk>I' x';\n        \\<And>x x'.\n           (x, x') \\<in> R' \\<Longrightarrow> f x \\<le> \\<Down> R (f' x');\n        (x, x'a) \\<in> R'; I' x'a; I x\\<rbrakk>\n       \\<Longrightarrow> b x = b' x'a\n 2. \\<And>fa f'a x x'a.\n       \\<lbrakk>I' x';\n        \\<And>x x'.\n           (x, x') \\<in> R' \\<Longrightarrow> fa x \\<le> \\<Down> R (f'a x');\n        (x, x'a) \\<in> R'; I' x'a; I x; b x; b' x'a\\<rbrakk>\n       \\<Longrightarrow> f x \\<bind> fa \\<le> \\<Down> R (f' x'a \\<bind> f'a)\n 3. \\<And>f f' x x'a.\n       \\<lbrakk>I' x';\n        \\<And>x x'.\n           (x, x') \\<in> R' \\<Longrightarrow> f x \\<le> \\<Down> R (f' x');\n        (x, x'a) \\<in> R'; I' x'a; I x; \\<not> b x; \\<not> b' x'a\\<rbrakk>\n       \\<Longrightarrow> RETURN x \\<le> \\<Down> R (RETURN x'a)", "apply (simp add: COND_REF)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>fa f'a x x'a.\n       \\<lbrakk>I' x';\n        \\<And>x x'.\n           (x, x') \\<in> R' \\<Longrightarrow> fa x \\<le> \\<Down> R (f'a x');\n        (x, x'a) \\<in> R'; I' x'a; I x; b x; b' x'a\\<rbrakk>\n       \\<Longrightarrow> f x \\<bind> fa \\<le> \\<Down> R (f' x'a \\<bind> f'a)\n 2. \\<And>f f' x x'a.\n       \\<lbrakk>I' x';\n        \\<And>x x'.\n           (x, x') \\<in> R' \\<Longrightarrow> f x \\<le> \\<Down> R (f' x');\n        (x, x'a) \\<in> R'; I' x'a; I x; \\<not> b x; \\<not> b' x'a\\<rbrakk>\n       \\<Longrightarrow> RETURN x \\<le> \\<Down> R (RETURN x'a)", "apply (rule bind_refine)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>fa f'a x x'a.\n       \\<lbrakk>I' x';\n        \\<And>x x'.\n           (x, x') \\<in> R' \\<Longrightarrow> fa x \\<le> \\<Down> R (f'a x');\n        (x, x'a) \\<in> R'; I' x'a; I x; b x; b' x'a\\<rbrakk>\n       \\<Longrightarrow> f x \\<le> \\<Down> (?R'21 fa f'a x x'a) (f' x'a)\n 2. \\<And>f f' x x'a xa x'aa.\n       \\<lbrakk>I' x';\n        \\<And>x x'.\n           (x, x') \\<in> R' \\<Longrightarrow> f x \\<le> \\<Down> R (f' x');\n        (x, x'a) \\<in> R'; I' x'a; I x; b x; b' x'a;\n        (xa, x'aa) \\<in> ?R'21 f f' x x'a\\<rbrakk>\n       \\<Longrightarrow> f xa \\<le> \\<Down> R (f' x'aa)\n 3. \\<And>f f' x x'a.\n       \\<lbrakk>I' x';\n        \\<And>x x'.\n           (x, x') \\<in> R' \\<Longrightarrow> f x \\<le> \\<Down> R (f' x');\n        (x, x'a) \\<in> R'; I' x'a; I x; \\<not> b x; \\<not> b' x'a\\<rbrakk>\n       \\<Longrightarrow> RETURN x \\<le> \\<Down> R (RETURN x'a)", "apply (rule STEP_REF, assumption+) []"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>f f' x x'a xa x'aa.\n       \\<lbrakk>I' x';\n        \\<And>x x'.\n           (x, x') \\<in> R' \\<Longrightarrow> f x \\<le> \\<Down> R (f' x');\n        (x, x'a) \\<in> R'; I' x'a; I x; b x; b' x'a;\n        (xa, x'aa) \\<in> R'\\<rbrakk>\n       \\<Longrightarrow> f xa \\<le> \\<Down> R (f' x'aa)\n 2. \\<And>f f' x x'a.\n       \\<lbrakk>I' x';\n        \\<And>x x'.\n           (x, x') \\<in> R' \\<Longrightarrow> f x \\<le> \\<Down> R (f' x');\n        (x, x'a) \\<in> R'; I' x'a; I x; \\<not> b x; \\<not> b' x'a\\<rbrakk>\n       \\<Longrightarrow> RETURN x \\<le> \\<Down> R (RETURN x'a)", "apply assumption"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f f' x x'a.\n       \\<lbrakk>I' x';\n        \\<And>x x'.\n           (x, x') \\<in> R' \\<Longrightarrow> f x \\<le> \\<Down> R (f' x');\n        (x, x'a) \\<in> R'; I' x'a; I x; \\<not> b x; \\<not> b' x'a\\<rbrakk>\n       \\<Longrightarrow> RETURN x \\<le> \\<Down> R (RETURN x'a)", "apply (rule RETURN_refine)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f f' x x'a.\n       \\<lbrakk>I' x';\n        \\<And>x x'.\n           (x, x') \\<in> R' \\<Longrightarrow> f x \\<le> \\<Down> R (f' x');\n        (x, x'a) \\<in> R'; I' x'a; I x; \\<not> b x; \\<not> b' x'a\\<rbrakk>\n       \\<Longrightarrow> (x, x'a) \\<in> R", "apply (simp add: R_REF)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma WHILET_refine_genR:\n  assumes R0: \"(x,x')\\<in>R'\"\n  assumes COND_REF: \"\\<And>x x'. (x,x')\\<in>R' \\<Longrightarrow> b x = b' x'\"\n  assumes STEP_REF: \n    \"\\<And>x x'. \\<lbrakk> (x,x')\\<in>R'; b x; b' x' \\<rbrakk> \\<Longrightarrow> f x \\<le> \\<Down>R' (f' x')\"\n  assumes R_REF: \n    \"\\<And>x x'. \\<lbrakk> (x,x')\\<in>R'; \\<not>b x; \\<not>b' x' \\<rbrakk> \\<Longrightarrow> (x,x')\\<in>R\"\n  shows \"WHILET b f x \\<le>\\<Down>R (WHILET b' f' x')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. WHILE\\<^sub>T b f x \\<le> \\<Down> R (WHILE\\<^sub>T b' f' x')", "unfolding WHILET_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. WHILE\\<^sub>T\\<^bsup>\\<lambda>_. True\\<^esup> b f x\n    \\<le> \\<Down> R (WHILE\\<^sub>T\\<^bsup>\\<lambda>_. True\\<^esup> b' f' x')", "apply (rule WHILEIT_refine_genR[OF R0])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x x'.\n       \\<lbrakk>(x, x') \\<in> R'; True\\<rbrakk> \\<Longrightarrow> True\n 2. \\<And>x x'.\n       \\<lbrakk>(x, x') \\<in> R'; True; True\\<rbrakk>\n       \\<Longrightarrow> b x = b' x'\n 3. \\<And>x x'.\n       \\<lbrakk>(x, x') \\<in> R'; b x; b' x'; True; True\\<rbrakk>\n       \\<Longrightarrow> f x \\<le> \\<Down> R' (f' x')\n 4. \\<And>x x'.\n       \\<lbrakk>(x, x') \\<in> R'; \\<not> b x; \\<not> b' x'; True;\n        True\\<rbrakk>\n       \\<Longrightarrow> (x, x') \\<in> R", "apply (rule TrueI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x x'.\n       \\<lbrakk>(x, x') \\<in> R'; True; True\\<rbrakk>\n       \\<Longrightarrow> b x = b' x'\n 2. \\<And>x x'.\n       \\<lbrakk>(x, x') \\<in> R'; b x; b' x'; True; True\\<rbrakk>\n       \\<Longrightarrow> f x \\<le> \\<Down> R' (f' x')\n 3. \\<And>x x'.\n       \\<lbrakk>(x, x') \\<in> R'; \\<not> b x; \\<not> b' x'; True;\n        True\\<rbrakk>\n       \\<Longrightarrow> (x, x') \\<in> R", "apply (rule assms, assumption+)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma WHILET_refine_genR':\n  assumes R0: \"I' x' \\<Longrightarrow> (x,x')\\<in>R'\"\n  assumes COND_REF: \"\\<And>x x'. \\<lbrakk> (x,x')\\<in>R'; I' x' \\<rbrakk> \\<Longrightarrow> b x = b' x'\"\n  assumes STEP_REF: \n    \"\\<And>x x'. \\<lbrakk> (x,x')\\<in>R'; b x; b' x'; I' x' \\<rbrakk> \\<Longrightarrow> f x \\<le> \\<Down>R' (f' x')\"\n  assumes R_REF: \n    \"\\<And>x x'. \\<lbrakk> (x,x')\\<in>R'; \\<not>b x; \\<not>b' x'; I' x' \\<rbrakk> \\<Longrightarrow> (x,x')\\<in>R\"\n  shows \"WHILET b f x \\<le>\\<Down>R (WHILEIT I' b' f' x')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. WHILE\\<^sub>T b f x\n    \\<le> \\<Down> R (WHILE\\<^sub>T\\<^bsup>I'\\<^esup> b' f' x')", "unfolding WHILET_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. WHILE\\<^sub>T\\<^bsup>\\<lambda>_. True\\<^esup> b f x\n    \\<le> \\<Down> R (WHILE\\<^sub>T\\<^bsup>I'\\<^esup> b' f' x')", "apply (rule WHILEIT_refine_genR[OF R0])"], ["proof (prove)\ngoal (5 subgoals):\n 1. I' x' \\<Longrightarrow> I' x'\n 2. \\<And>x x'.\n       \\<lbrakk>(x, x') \\<in> R'; I' x'\\<rbrakk> \\<Longrightarrow> True\n 3. \\<And>x x'.\n       \\<lbrakk>(x, x') \\<in> R'; True; I' x'\\<rbrakk>\n       \\<Longrightarrow> b x = b' x'\n 4. \\<And>x x'.\n       \\<lbrakk>(x, x') \\<in> R'; b x; b' x'; True; I' x'\\<rbrakk>\n       \\<Longrightarrow> f x \\<le> \\<Down> R' (f' x')\n 5. \\<And>x x'.\n       \\<lbrakk>(x, x') \\<in> R'; \\<not> b x; \\<not> b' x'; True;\n        I' x'\\<rbrakk>\n       \\<Longrightarrow> (x, x') \\<in> R", "apply assumption"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x x'.\n       \\<lbrakk>(x, x') \\<in> R'; I' x'\\<rbrakk> \\<Longrightarrow> True\n 2. \\<And>x x'.\n       \\<lbrakk>(x, x') \\<in> R'; True; I' x'\\<rbrakk>\n       \\<Longrightarrow> b x = b' x'\n 3. \\<And>x x'.\n       \\<lbrakk>(x, x') \\<in> R'; b x; b' x'; True; I' x'\\<rbrakk>\n       \\<Longrightarrow> f x \\<le> \\<Down> R' (f' x')\n 4. \\<And>x x'.\n       \\<lbrakk>(x, x') \\<in> R'; \\<not> b x; \\<not> b' x'; True;\n        I' x'\\<rbrakk>\n       \\<Longrightarrow> (x, x') \\<in> R", "apply (rule TrueI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x x'.\n       \\<lbrakk>(x, x') \\<in> R'; True; I' x'\\<rbrakk>\n       \\<Longrightarrow> b x = b' x'\n 2. \\<And>x x'.\n       \\<lbrakk>(x, x') \\<in> R'; b x; b' x'; True; I' x'\\<rbrakk>\n       \\<Longrightarrow> f x \\<le> \\<Down> R' (f' x')\n 3. \\<And>x x'.\n       \\<lbrakk>(x, x') \\<in> R'; \\<not> b x; \\<not> b' x'; True;\n        I' x'\\<rbrakk>\n       \\<Longrightarrow> (x, x') \\<in> R", "apply (rule assms, assumption+)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma WHILEIT_refine[refine]:\n  assumes R0: \"I' x' \\<Longrightarrow> (x,x')\\<in>R\"\n  assumes IREF: \"\\<And>x x'. \\<lbrakk> (x,x')\\<in>R; I' x' \\<rbrakk> \\<Longrightarrow> I x\"\n  assumes COND_REF: \"\\<And>x x'. \\<lbrakk> (x,x')\\<in>R; I x; I' x' \\<rbrakk> \\<Longrightarrow> b x = b' x'\"\n  assumes STEP_REF: \n    \"\\<And>x x'. \\<lbrakk> (x,x')\\<in>R; b x; b' x'; I x; I' x' \\<rbrakk> \\<Longrightarrow> f x \\<le> \\<Down>R (f' x')\"\n  shows \"WHILEIT I b f x \\<le>\\<Down>R (WHILEIT I' b' f' x')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. WHILE\\<^sub>T\\<^bsup>I\\<^esup> b f x\n    \\<le> \\<Down> R (WHILE\\<^sub>T\\<^bsup>I'\\<^esup> b' f' x')", "using WHILEIT_refine_genR[where R=R and R'=R, OF assms]"], ["proof (prove)\nusing this:\n  \\<lbrakk>?I' x' \\<Longrightarrow> I' x';\n   \\<And>x x'.\n      \\<lbrakk>(x, x') \\<in> R; ?I' x'\\<rbrakk>\n      \\<Longrightarrow> (?x8 x, ?x'7 x x') \\<in> R;\n   \\<And>x x'.\n      \\<lbrakk>(x, x') \\<in> R; ?I' x'\\<rbrakk>\n      \\<Longrightarrow> I' (?x'7 x x');\n   \\<And>x x'.\n      \\<lbrakk>(x, x') \\<in> R; I (?x8 x); ?I' x'\\<rbrakk>\n      \\<Longrightarrow> (?x5 x, ?x'6 x') \\<in> R;\n   \\<And>x x'.\n      \\<lbrakk>(x, x') \\<in> R; I (?x8 x); ?I' x'\\<rbrakk>\n      \\<Longrightarrow> I (?x5 x);\n   \\<And>x x'.\n      \\<lbrakk>(x, x') \\<in> R; I (?x8 x); ?I' x'\\<rbrakk>\n      \\<Longrightarrow> I' (?x'6 x');\n   \\<And>x x'.\n      \\<lbrakk>(x, x') \\<in> R; b (?x5 x); b' (?x'6 x'); I (?x8 x);\n       ?I' x'\\<rbrakk>\n      \\<Longrightarrow> (?x2 x, ?x'3 x') \\<in> R;\n   \\<And>x x'.\n      \\<lbrakk>(x, x') \\<in> R; b (?x5 x); b' (?x'6 x'); I (?x8 x);\n       ?I' x'\\<rbrakk>\n      \\<Longrightarrow> b (?x2 x);\n   \\<And>x x'.\n      \\<lbrakk>(x, x') \\<in> R; b (?x5 x); b' (?x'6 x'); I (?x8 x);\n       ?I' x'\\<rbrakk>\n      \\<Longrightarrow> b' (?x'3 x');\n   \\<And>x x'.\n      \\<lbrakk>(x, x') \\<in> R; b (?x5 x); b' (?x'6 x'); I (?x8 x);\n       ?I' x'\\<rbrakk>\n      \\<Longrightarrow> I (?x2 x);\n   \\<And>x x'.\n      \\<lbrakk>(x, x') \\<in> R; b (?x5 x); b' (?x'6 x'); I (?x8 x);\n       ?I' x'\\<rbrakk>\n      \\<Longrightarrow> I' (?x'3 x');\n   \\<And>x x'.\n      \\<lbrakk>(x, x') \\<in> R; \\<not> b (?x5 x); \\<not> b' (?x'6 x');\n       I (?x8 x); ?I' x'\\<rbrakk>\n      \\<Longrightarrow> (x, x') \\<in> R\\<rbrakk>\n  \\<Longrightarrow> WHILE\\<^sub>T\\<^bsup>\\<lambda>x. I (?x8 x)\\<^esup>\n                     (\\<lambda>x. b (?x5 x)) (\\<lambda>x. f (?x2 x)) x\n                    \\<le> \\<Down> R\n                           (WHILE\\<^sub>T\\<^bsup>?I'\\<^esup>\n                             (\\<lambda>x'. b' (?x'6 x'))\n                             (\\<lambda>x'. f' (?x'3 x')) x')\n\ngoal (1 subgoal):\n 1. WHILE\\<^sub>T\\<^bsup>I\\<^esup> b f x\n    \\<le> \\<Down> R (WHILE\\<^sub>T\\<^bsup>I'\\<^esup> b' f' x')", "."], ["", "lemma WHILET_refine[refine]:\n  assumes R0: \"(x,x')\\<in>R\"\n  assumes COND_REF: \"\\<And>x x'. \\<lbrakk> (x,x')\\<in>R \\<rbrakk> \\<Longrightarrow> b x = b' x'\"\n  assumes STEP_REF: \n    \"\\<And>x x'. \\<lbrakk> (x,x')\\<in>R; b x; b' x' \\<rbrakk> \\<Longrightarrow> f x \\<le> \\<Down>R (f' x')\"\n  shows \"WHILET b f x \\<le>\\<Down>R (WHILET b' f' x')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. WHILE\\<^sub>T b f x \\<le> \\<Down> R (WHILE\\<^sub>T b' f' x')", "unfolding WHILET_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. WHILE\\<^sub>T\\<^bsup>\\<lambda>_. True\\<^esup> b f x\n    \\<le> \\<Down> R (WHILE\\<^sub>T\\<^bsup>\\<lambda>_. True\\<^esup> b' f' x')", "apply (rule WHILEIT_refine)"], ["proof (prove)\ngoal (4 subgoals):\n 1. True \\<Longrightarrow> (x, x') \\<in> R\n 2. \\<And>x x'.\n       \\<lbrakk>(x, x') \\<in> R; True\\<rbrakk> \\<Longrightarrow> True\n 3. \\<And>x x'.\n       \\<lbrakk>(x, x') \\<in> R; True; True\\<rbrakk>\n       \\<Longrightarrow> b x = b' x'\n 4. \\<And>x x'.\n       \\<lbrakk>(x, x') \\<in> R; b x; b' x'; True; True\\<rbrakk>\n       \\<Longrightarrow> f x \\<le> \\<Down> R (f' x')", "using assms"], ["proof (prove)\nusing this:\n  (x, x') \\<in> R\n  (?x, ?x') \\<in> R \\<Longrightarrow> b ?x = b' ?x'\n  \\<lbrakk>(?x, ?x') \\<in> R; b ?x; b' ?x'\\<rbrakk>\n  \\<Longrightarrow> f ?x \\<le> \\<Down> R (f' ?x')\n\ngoal (4 subgoals):\n 1. True \\<Longrightarrow> (x, x') \\<in> R\n 2. \\<And>x x'.\n       \\<lbrakk>(x, x') \\<in> R; True\\<rbrakk> \\<Longrightarrow> True\n 3. \\<And>x x'.\n       \\<lbrakk>(x, x') \\<in> R; True; True\\<rbrakk>\n       \\<Longrightarrow> b x = b' x'\n 4. \\<And>x x'.\n       \\<lbrakk>(x, x') \\<in> R; b x; b' x'; True; True\\<rbrakk>\n       \\<Longrightarrow> f x \\<le> \\<Down> R (f' x')", "by auto"], ["", "lemma WHILET_refine'[refine]:\n  assumes R0: \"I' x' \\<Longrightarrow> (x,x')\\<in>R\"\n  assumes COND_REF: \"\\<And>x x'. \\<lbrakk> (x,x')\\<in>R; I' x' \\<rbrakk> \\<Longrightarrow> b x = b' x'\"\n  assumes STEP_REF: \n    \"\\<And>x x'. \\<lbrakk> (x,x')\\<in>R; b x; b' x'; I' x' \\<rbrakk> \\<Longrightarrow> f x \\<le> \\<Down>R (f' x')\"\n  shows \"WHILET b f x \\<le>\\<Down>R (WHILEIT I' b' f' x')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. WHILE\\<^sub>T b f x\n    \\<le> \\<Down> R (WHILE\\<^sub>T\\<^bsup>I'\\<^esup> b' f' x')", "unfolding WHILET_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. WHILE\\<^sub>T\\<^bsup>\\<lambda>_. True\\<^esup> b f x\n    \\<le> \\<Down> R (WHILE\\<^sub>T\\<^bsup>I'\\<^esup> b' f' x')", "apply (rule WHILEIT_refine)"], ["proof (prove)\ngoal (4 subgoals):\n 1. I' x' \\<Longrightarrow> (x, x') \\<in> R\n 2. \\<And>x x'.\n       \\<lbrakk>(x, x') \\<in> R; I' x'\\<rbrakk> \\<Longrightarrow> True\n 3. \\<And>x x'.\n       \\<lbrakk>(x, x') \\<in> R; True; I' x'\\<rbrakk>\n       \\<Longrightarrow> b x = b' x'\n 4. \\<And>x x'.\n       \\<lbrakk>(x, x') \\<in> R; b x; b' x'; True; I' x'\\<rbrakk>\n       \\<Longrightarrow> f x \\<le> \\<Down> R (f' x')", "using assms"], ["proof (prove)\nusing this:\n  I' x' \\<Longrightarrow> (x, x') \\<in> R\n  \\<lbrakk>(?x, ?x') \\<in> R; I' ?x'\\<rbrakk>\n  \\<Longrightarrow> b ?x = b' ?x'\n  \\<lbrakk>(?x, ?x') \\<in> R; b ?x; b' ?x'; I' ?x'\\<rbrakk>\n  \\<Longrightarrow> f ?x \\<le> \\<Down> R (f' ?x')\n\ngoal (4 subgoals):\n 1. I' x' \\<Longrightarrow> (x, x') \\<in> R\n 2. \\<And>x x'.\n       \\<lbrakk>(x, x') \\<in> R; I' x'\\<rbrakk> \\<Longrightarrow> True\n 3. \\<And>x x'.\n       \\<lbrakk>(x, x') \\<in> R; True; I' x'\\<rbrakk>\n       \\<Longrightarrow> b x = b' x'\n 4. \\<And>x x'.\n       \\<lbrakk>(x, x') \\<in> R; b x; b' x'; True; I' x'\\<rbrakk>\n       \\<Longrightarrow> f x \\<le> \\<Down> R (f' x')", "by auto"], ["", "lemma WHILEI_refine_new_invar:\n  assumes R0: \"I' x' \\<Longrightarrow> (x,x')\\<in>R\"\n  assumes INV0: \"\\<lbrakk> I' x'; (x,x')\\<in>R \\<rbrakk> \\<Longrightarrow> I x\"\n  assumes COND_REF: \"\\<And>x x'. \\<lbrakk> (x,x')\\<in>R; I x; I' x' \\<rbrakk> \\<Longrightarrow> b x = b' x'\"\n  assumes STEP_REF: \n    \"\\<And>x x'. \\<lbrakk> (x,x')\\<in>R; b x; b' x'; I x; I' x' \\<rbrakk> \\<Longrightarrow> f x \\<le> \\<Down>R (f' x')\"\n  assumes STEP_INV: \n    \"\\<And>x x'. \\<lbrakk> (x,x')\\<in>R; b x; b' x'; I x; I' x'; nofail (f x) \\<rbrakk> \\<Longrightarrow> f x \\<le> SPEC I\"\n  shows \"WHILEI I b f x \\<le>\\<Down>R (WHILEI I' b' f' x')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. WHILE\\<^bsup>I\\<^esup> b f x\n    \\<le> \\<Down> R (WHILE\\<^bsup>I'\\<^esup> b' f' x')", "apply (rule WHILEI_refine_genR[where \n    I=I and I'=I' and x'=x' and x=x and R=R and b=b and b'=b' and f'=f' and f=f\n    and R'=\"{ (c,a). (c,a)\\<in>R \\<and> I c }\"\n    ])"], ["proof (prove)\ngoal (5 subgoals):\n 1. I' x' \\<Longrightarrow>\n    (x, x') \\<in> {(c, a). (c, a) \\<in> R \\<and> I c}\n 2. \\<And>x x'.\n       \\<lbrakk>(x, x') \\<in> {(c, a). (c, a) \\<in> R \\<and> I c};\n        I' x'\\<rbrakk>\n       \\<Longrightarrow> I x\n 3. \\<And>x x'.\n       \\<lbrakk>(x, x') \\<in> {(c, a). (c, a) \\<in> R \\<and> I c}; I x;\n        I' x'\\<rbrakk>\n       \\<Longrightarrow> b x = b' x'\n 4. \\<And>x x'.\n       \\<lbrakk>(x, x') \\<in> {(c, a). (c, a) \\<in> R \\<and> I c}; b x;\n        b' x'; I x; I' x'\\<rbrakk>\n       \\<Longrightarrow> f x\n                         \\<le> \\<Down> {(c, a). (c, a) \\<in> R \\<and> I c}\n                                (f' x')\n 5. \\<And>x x'.\n       \\<lbrakk>(x, x') \\<in> {(c, a). (c, a) \\<in> R \\<and> I c};\n        \\<not> b x; \\<not> b' x'; I x; I' x'\\<rbrakk>\n       \\<Longrightarrow> (x, x') \\<in> R", "using assms"], ["proof (prove)\nusing this:\n  I' x' \\<Longrightarrow> (x, x') \\<in> R\n  \\<lbrakk>I' x'; (x, x') \\<in> R\\<rbrakk> \\<Longrightarrow> I x\n  \\<lbrakk>(?x, ?x') \\<in> R; I ?x; I' ?x'\\<rbrakk>\n  \\<Longrightarrow> b ?x = b' ?x'\n  \\<lbrakk>(?x, ?x') \\<in> R; b ?x; b' ?x'; I ?x; I' ?x'\\<rbrakk>\n  \\<Longrightarrow> f ?x \\<le> \\<Down> R (f' ?x')\n  \\<lbrakk>(?x, ?x') \\<in> R; b ?x; b' ?x'; I ?x; I' ?x';\n   nofail (f ?x)\\<rbrakk>\n  \\<Longrightarrow> f ?x \\<le> SPEC I\n\ngoal (5 subgoals):\n 1. I' x' \\<Longrightarrow>\n    (x, x') \\<in> {(c, a). (c, a) \\<in> R \\<and> I c}\n 2. \\<And>x x'.\n       \\<lbrakk>(x, x') \\<in> {(c, a). (c, a) \\<in> R \\<and> I c};\n        I' x'\\<rbrakk>\n       \\<Longrightarrow> I x\n 3. \\<And>x x'.\n       \\<lbrakk>(x, x') \\<in> {(c, a). (c, a) \\<in> R \\<and> I c}; I x;\n        I' x'\\<rbrakk>\n       \\<Longrightarrow> b x = b' x'\n 4. \\<And>x x'.\n       \\<lbrakk>(x, x') \\<in> {(c, a). (c, a) \\<in> R \\<and> I c}; b x;\n        b' x'; I x; I' x'\\<rbrakk>\n       \\<Longrightarrow> f x\n                         \\<le> \\<Down> {(c, a). (c, a) \\<in> R \\<and> I c}\n                                (f' x')\n 5. \\<And>x x'.\n       \\<lbrakk>(x, x') \\<in> {(c, a). (c, a) \\<in> R \\<and> I c};\n        \\<not> b x; \\<not> b' x'; I x; I' x'\\<rbrakk>\n       \\<Longrightarrow> (x, x') \\<in> R", "by (auto intro: add_invar_refineI)"], ["", "lemma WHILEIT_refine_new_invar:\n  assumes R0: \"I' x' \\<Longrightarrow> (x,x')\\<in>R\"\n  assumes INV0: \"\\<lbrakk> I' x'; (x,x')\\<in>R \\<rbrakk> \\<Longrightarrow> I x\"\n  assumes COND_REF: \"\\<And>x x'. \\<lbrakk> (x,x')\\<in>R; I x; I' x' \\<rbrakk> \\<Longrightarrow> b x = b' x'\"\n  assumes STEP_REF: \n    \"\\<And>x x'. \\<lbrakk> (x,x')\\<in>R; b x; b' x'; I x; I' x' \\<rbrakk> \\<Longrightarrow> f x \\<le> \\<Down>R (f' x')\"\n  assumes STEP_INV: \n    \"\\<And>x x'. \\<lbrakk> nofail (f x); (x,x')\\<in>R; b x; b' x'; I x; I' x' \\<rbrakk> \\<Longrightarrow> f x \\<le> SPEC I\"\n  shows \"WHILEIT I b f x \\<le>\\<Down>R (WHILEIT I' b' f' x')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. WHILE\\<^sub>T\\<^bsup>I\\<^esup> b f x\n    \\<le> \\<Down> R (WHILE\\<^sub>T\\<^bsup>I'\\<^esup> b' f' x')", "apply (rule WHILEIT_refine_genR[where \n    I=I and I'=I' and x'=x' and x=x and R=R and b=b and b'=b' and f'=f' and f=f\n    and R'=\"{ (c,a). (c,a)\\<in>R \\<and> I c }\"\n    ])"], ["proof (prove)\ngoal (5 subgoals):\n 1. I' x' \\<Longrightarrow>\n    (x, x') \\<in> {(c, a). (c, a) \\<in> R \\<and> I c}\n 2. \\<And>x x'.\n       \\<lbrakk>(x, x') \\<in> {(c, a). (c, a) \\<in> R \\<and> I c};\n        I' x'\\<rbrakk>\n       \\<Longrightarrow> I x\n 3. \\<And>x x'.\n       \\<lbrakk>(x, x') \\<in> {(c, a). (c, a) \\<in> R \\<and> I c}; I x;\n        I' x'\\<rbrakk>\n       \\<Longrightarrow> b x = b' x'\n 4. \\<And>x x'.\n       \\<lbrakk>(x, x') \\<in> {(c, a). (c, a) \\<in> R \\<and> I c}; b x;\n        b' x'; I x; I' x'\\<rbrakk>\n       \\<Longrightarrow> f x\n                         \\<le> \\<Down> {(c, a). (c, a) \\<in> R \\<and> I c}\n                                (f' x')\n 5. \\<And>x x'.\n       \\<lbrakk>(x, x') \\<in> {(c, a). (c, a) \\<in> R \\<and> I c};\n        \\<not> b x; \\<not> b' x'; I x; I' x'\\<rbrakk>\n       \\<Longrightarrow> (x, x') \\<in> R", "using assms"], ["proof (prove)\nusing this:\n  I' x' \\<Longrightarrow> (x, x') \\<in> R\n  \\<lbrakk>I' x'; (x, x') \\<in> R\\<rbrakk> \\<Longrightarrow> I x\n  \\<lbrakk>(?x, ?x') \\<in> R; I ?x; I' ?x'\\<rbrakk>\n  \\<Longrightarrow> b ?x = b' ?x'\n  \\<lbrakk>(?x, ?x') \\<in> R; b ?x; b' ?x'; I ?x; I' ?x'\\<rbrakk>\n  \\<Longrightarrow> f ?x \\<le> \\<Down> R (f' ?x')\n  \\<lbrakk>nofail (f ?x); (?x, ?x') \\<in> R; b ?x; b' ?x'; I ?x;\n   I' ?x'\\<rbrakk>\n  \\<Longrightarrow> f ?x \\<le> SPEC I\n\ngoal (5 subgoals):\n 1. I' x' \\<Longrightarrow>\n    (x, x') \\<in> {(c, a). (c, a) \\<in> R \\<and> I c}\n 2. \\<And>x x'.\n       \\<lbrakk>(x, x') \\<in> {(c, a). (c, a) \\<in> R \\<and> I c};\n        I' x'\\<rbrakk>\n       \\<Longrightarrow> I x\n 3. \\<And>x x'.\n       \\<lbrakk>(x, x') \\<in> {(c, a). (c, a) \\<in> R \\<and> I c}; I x;\n        I' x'\\<rbrakk>\n       \\<Longrightarrow> b x = b' x'\n 4. \\<And>x x'.\n       \\<lbrakk>(x, x') \\<in> {(c, a). (c, a) \\<in> R \\<and> I c}; b x;\n        b' x'; I x; I' x'\\<rbrakk>\n       \\<Longrightarrow> f x\n                         \\<le> \\<Down> {(c, a). (c, a) \\<in> R \\<and> I c}\n                                (f' x')\n 5. \\<And>x x'.\n       \\<lbrakk>(x, x') \\<in> {(c, a). (c, a) \\<in> R \\<and> I c};\n        \\<not> b x; \\<not> b' x'; I x; I' x'\\<rbrakk>\n       \\<Longrightarrow> (x, x') \\<in> R", "by (auto intro: add_invar_refineI)"], ["", "subsection \\<open>Autoref Setup\\<close>"], ["", "(*lemma id_WHILE[autoref_id_self]: \"ID_LIST \n  (l (WHILET,3) (WHILEIT I,3) (WHILE,3) (WHILEI I,3))\"\n  by simp_all*)"], ["", "context begin"], ["", "interpretation autoref_syn"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma [autoref_op_pat_def]:\n  \"WHILEIT I \\<equiv> OP (WHILEIT I)\"\n  \"WHILEI I \\<equiv> OP (WHILEI I)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (WHILE\\<^sub>T\\<^bsup>I\\<^esup> \\<equiv>\n     OP WHILE\\<^sub>T\\<^bsup>I\\<^esup>) &&&\n    WHILE\\<^bsup>I\\<^esup> \\<equiv> OP WHILE\\<^bsup>I\\<^esup>", "by auto"], ["", "lemma autoref_WHILET[autoref_rules]:\n  assumes \"\\<And>x x'. \\<lbrakk> (x,x')\\<in>R\\<rbrakk> \\<Longrightarrow> (c x,c'$x') \\<in> Id\"\n  assumes \"\\<And>x x'. \\<lbrakk> REMOVE_INTERNAL c' x'; (x,x')\\<in>R\\<rbrakk> \n    \\<Longrightarrow> (f x,f'$x') \\<in> \\<langle>R\\<rangle>nres_rel\"\n  assumes \"(s,s')\\<in>R\"\n  shows \"(WHILET c f s,\n    (OP WHILET:::(R\\<rightarrow>Id)\\<rightarrow>(R\\<rightarrow>\\<langle>R\\<rangle>nres_rel)\\<rightarrow>R\\<rightarrow>\\<langle>R\\<rangle>nres_rel)$c'$f'$s')\n   \\<in> \\<langle>R\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (WHILE\\<^sub>T c f s,\n     (OP WHILE\\<^sub>T :::\n      (R \\<rightarrow> bool_rel) \\<rightarrow>\n      (R \\<rightarrow> \\<langle>R\\<rangle>nres_rel) \\<rightarrow>\n      R \\<rightarrow> \\<langle>R\\<rangle>nres_rel) $\n     c' $\n     f' $\n     s')\n    \\<in> \\<langle>R\\<rangle>nres_rel", "using assms"], ["proof (prove)\nusing this:\n  (?x, ?x') \\<in> R \\<Longrightarrow> (c ?x, c' $ ?x') \\<in> bool_rel\n  \\<lbrakk>REMOVE_INTERNAL c' ?x'; (?x, ?x') \\<in> R\\<rbrakk>\n  \\<Longrightarrow> (f ?x, f' $ ?x') \\<in> \\<langle>R\\<rangle>nres_rel\n  (s, s') \\<in> R\n\ngoal (1 subgoal):\n 1. (WHILE\\<^sub>T c f s,\n     (OP WHILE\\<^sub>T :::\n      (R \\<rightarrow> bool_rel) \\<rightarrow>\n      (R \\<rightarrow> \\<langle>R\\<rangle>nres_rel) \\<rightarrow>\n      R \\<rightarrow> \\<langle>R\\<rangle>nres_rel) $\n     c' $\n     f' $\n     s')\n    \\<in> \\<langle>R\\<rangle>nres_rel", "by (auto simp add: nres_rel_def fun_rel_def intro!: WHILET_refine)"], ["", "lemma autoref_WHILEIT[autoref_rules]:\n  assumes \"\\<And>x x'. \\<lbrakk>I x'; (x,x')\\<in>R\\<rbrakk> \\<Longrightarrow> (c x,c'$x') \\<in> Id\"\n  assumes \"\\<And>x x'. \\<lbrakk>REMOVE_INTERNAL c' x'; I x'; (x,x')\\<in>R\\<rbrakk> \\<Longrightarrow>(f x,f'$x') \\<in> \\<langle>R\\<rangle>nres_rel\"\n  assumes \"I s' \\<Longrightarrow> (s,s')\\<in>R\"\n  shows \"(WHILET c f s,\n      (OP (WHILEIT I) ::: (R\\<rightarrow>Id) \\<rightarrow> (R\\<rightarrow>\\<langle>R\\<rangle>nres_rel) \\<rightarrow> R \\<rightarrow> \\<langle>R\\<rangle>nres_rel)$c'$f'$s'\n    )\\<in>\\<langle>R\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (WHILE\\<^sub>T c f s,\n     (OP WHILE\\<^sub>T\\<^bsup>I\\<^esup> :::\n      (R \\<rightarrow> bool_rel) \\<rightarrow>\n      (R \\<rightarrow> \\<langle>R\\<rangle>nres_rel) \\<rightarrow>\n      R \\<rightarrow> \\<langle>R\\<rangle>nres_rel) $\n     c' $\n     f' $\n     s')\n    \\<in> \\<langle>R\\<rangle>nres_rel", "using assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>I ?x'; (?x, ?x') \\<in> R\\<rbrakk>\n  \\<Longrightarrow> (c ?x, c' $ ?x') \\<in> bool_rel\n  \\<lbrakk>REMOVE_INTERNAL c' ?x'; I ?x'; (?x, ?x') \\<in> R\\<rbrakk>\n  \\<Longrightarrow> (f ?x, f' $ ?x') \\<in> \\<langle>R\\<rangle>nres_rel\n  I s' \\<Longrightarrow> (s, s') \\<in> R\n\ngoal (1 subgoal):\n 1. (WHILE\\<^sub>T c f s,\n     (OP WHILE\\<^sub>T\\<^bsup>I\\<^esup> :::\n      (R \\<rightarrow> bool_rel) \\<rightarrow>\n      (R \\<rightarrow> \\<langle>R\\<rangle>nres_rel) \\<rightarrow>\n      R \\<rightarrow> \\<langle>R\\<rangle>nres_rel) $\n     c' $\n     f' $\n     s')\n    \\<in> \\<langle>R\\<rangle>nres_rel", "by (auto simp add: nres_rel_def fun_rel_def intro!: WHILET_refine')"], ["", "lemma autoref_WHILEIT'[autoref_rules]:\n  assumes \"\\<And>x x'. \\<lbrakk> (x,x')\\<in>R; I x'\\<rbrakk> \\<Longrightarrow> (c x,c'$x') \\<in> Id\"\n  assumes \"\\<And>x x'. \\<lbrakk> REMOVE_INTERNAL c' x'; (x,x')\\<in>R; I x'\\<rbrakk> \n    \\<Longrightarrow> (f x,f'$x') \\<in> \\<langle>R\\<rangle>nres_rel\"\n  shows \"(WHILET c f,\n      (OP (WHILEIT I) ::: (R\\<rightarrow>Id) \\<rightarrow> (R\\<rightarrow>\\<langle>R\\<rangle>nres_rel) \\<rightarrow> R \\<rightarrow> \\<langle>R\\<rangle>nres_rel)$c'$f'\n    )\\<in>R \\<rightarrow> \\<langle>R\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (WHILE\\<^sub>T c f,\n     (OP WHILE\\<^sub>T\\<^bsup>I\\<^esup> :::\n      (R \\<rightarrow> bool_rel) \\<rightarrow>\n      (R \\<rightarrow> \\<langle>R\\<rangle>nres_rel) \\<rightarrow>\n      R \\<rightarrow> \\<langle>R\\<rangle>nres_rel) $\n     c' $\n     f')\n    \\<in> R \\<rightarrow> \\<langle>R\\<rangle>nres_rel", "unfolding autoref_tag_defs"], ["proof (prove)\ngoal (1 subgoal):\n 1. (WHILE\\<^sub>T c f, WHILE\\<^sub>T\\<^bsup>I\\<^esup> c' f')\n    \\<in> R \\<rightarrow> \\<langle>R\\<rangle>nres_rel", "by (parametricity \n      add: autoref_WHILEIT[unfolded autoref_tag_defs]\n      assms[unfolded autoref_tag_defs])"], ["", "lemma autoref_WHILE[autoref_rules]: (** TODO: obsolete ? **)\n  assumes \"\\<And>x x'. \\<lbrakk> (x,x')\\<in>R\\<rbrakk> \\<Longrightarrow> (c x,c'$x') \\<in> Id\"\n  assumes \"\\<And>x x'. \\<lbrakk> REMOVE_INTERNAL c' x'; (x,x')\\<in>R\\<rbrakk> \n    \\<Longrightarrow> (f x,f'$x') \\<in> \\<langle>R\\<rangle>nres_rel\"\n  assumes \"(s,s')\\<in>R\"\n  shows \"(WHILE c f s,\n      (OP WHILE ::: (R\\<rightarrow>Id) \\<rightarrow> (R\\<rightarrow>\\<langle>R\\<rangle>nres_rel) \\<rightarrow> R \\<rightarrow> \\<langle>R\\<rangle>nres_rel)$c'$f'$s'\n    )\\<in>\\<langle>R\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (WHILE c f s,\n     (OP WHILE :::\n      (R \\<rightarrow> bool_rel) \\<rightarrow>\n      (R \\<rightarrow> \\<langle>R\\<rangle>nres_rel) \\<rightarrow>\n      R \\<rightarrow> \\<langle>R\\<rangle>nres_rel) $\n     c' $\n     f' $\n     s')\n    \\<in> \\<langle>R\\<rangle>nres_rel", "using assms"], ["proof (prove)\nusing this:\n  (?x, ?x') \\<in> R \\<Longrightarrow> (c ?x, c' $ ?x') \\<in> bool_rel\n  \\<lbrakk>REMOVE_INTERNAL c' ?x'; (?x, ?x') \\<in> R\\<rbrakk>\n  \\<Longrightarrow> (f ?x, f' $ ?x') \\<in> \\<langle>R\\<rangle>nres_rel\n  (s, s') \\<in> R\n\ngoal (1 subgoal):\n 1. (WHILE c f s,\n     (OP WHILE :::\n      (R \\<rightarrow> bool_rel) \\<rightarrow>\n      (R \\<rightarrow> \\<langle>R\\<rangle>nres_rel) \\<rightarrow>\n      R \\<rightarrow> \\<langle>R\\<rangle>nres_rel) $\n     c' $\n     f' $\n     s')\n    \\<in> \\<langle>R\\<rangle>nres_rel", "by (auto simp add: nres_rel_def fun_rel_def intro!: WHILE_refine)"], ["", "lemma autoref_WHILE'[autoref_rules]:\n  assumes \"\\<And>x x'. \\<lbrakk> (x,x')\\<in>R\\<rbrakk> \\<Longrightarrow> (c x,c'$x') \\<in> Id\"\n  assumes \"\\<And>x x'. \\<lbrakk> REMOVE_INTERNAL c' x'; (x,x')\\<in>R\\<rbrakk> \n    \\<Longrightarrow> (f x,f'$x') \\<in> \\<langle>R\\<rangle>nres_rel\"\n  shows \"(WHILE c f,\n      (OP WHILE ::: (R\\<rightarrow>Id) \\<rightarrow> (R\\<rightarrow>\\<langle>R\\<rangle>nres_rel) \\<rightarrow> R \\<rightarrow> \\<langle>R\\<rangle>nres_rel)$c'$f'\n    )\\<in>R \\<rightarrow> \\<langle>R\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (WHILE c f,\n     (OP WHILE :::\n      (R \\<rightarrow> bool_rel) \\<rightarrow>\n      (R \\<rightarrow> \\<langle>R\\<rangle>nres_rel) \\<rightarrow>\n      R \\<rightarrow> \\<langle>R\\<rangle>nres_rel) $\n     c' $\n     f')\n    \\<in> R \\<rightarrow> \\<langle>R\\<rangle>nres_rel", "using assms"], ["proof (prove)\nusing this:\n  (?x, ?x') \\<in> R \\<Longrightarrow> (c ?x, c' $ ?x') \\<in> bool_rel\n  \\<lbrakk>REMOVE_INTERNAL c' ?x'; (?x, ?x') \\<in> R\\<rbrakk>\n  \\<Longrightarrow> (f ?x, f' $ ?x') \\<in> \\<langle>R\\<rangle>nres_rel\n\ngoal (1 subgoal):\n 1. (WHILE c f,\n     (OP WHILE :::\n      (R \\<rightarrow> bool_rel) \\<rightarrow>\n      (R \\<rightarrow> \\<langle>R\\<rangle>nres_rel) \\<rightarrow>\n      R \\<rightarrow> \\<langle>R\\<rangle>nres_rel) $\n     c' $\n     f')\n    \\<in> R \\<rightarrow> \\<langle>R\\<rangle>nres_rel", "by (auto simp add: nres_rel_def fun_rel_def intro!: WHILE_refine)"], ["", "lemma autoref_WHILEI[autoref_rules]:\n  assumes \"\\<And>x x'. \\<lbrakk>I x'; (x,x')\\<in>R\\<rbrakk> \\<Longrightarrow> (c x,c'$x') \\<in> Id\"\n  assumes \"\\<And>x x'. \\<lbrakk>REMOVE_INTERNAL c' x'; I x'; (x,x')\\<in>R\\<rbrakk> \\<Longrightarrow>(f x,f'$x') \\<in> \\<langle>R\\<rangle>nres_rel\"\n  assumes \"I s' \\<Longrightarrow> (s,s')\\<in>R\"\n  shows \"(WHILE c f s,\n      (OP (WHILEI I) ::: (R\\<rightarrow>Id) \\<rightarrow> (R\\<rightarrow>\\<langle>R\\<rangle>nres_rel) \\<rightarrow> R \\<rightarrow> \\<langle>R\\<rangle>nres_rel)$c'$f'$s'\n    )\\<in>\\<langle>R\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (WHILE c f s,\n     (OP WHILE\\<^bsup>I\\<^esup> :::\n      (R \\<rightarrow> bool_rel) \\<rightarrow>\n      (R \\<rightarrow> \\<langle>R\\<rangle>nres_rel) \\<rightarrow>\n      R \\<rightarrow> \\<langle>R\\<rangle>nres_rel) $\n     c' $\n     f' $\n     s')\n    \\<in> \\<langle>R\\<rangle>nres_rel", "using assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>I ?x'; (?x, ?x') \\<in> R\\<rbrakk>\n  \\<Longrightarrow> (c ?x, c' $ ?x') \\<in> bool_rel\n  \\<lbrakk>REMOVE_INTERNAL c' ?x'; I ?x'; (?x, ?x') \\<in> R\\<rbrakk>\n  \\<Longrightarrow> (f ?x, f' $ ?x') \\<in> \\<langle>R\\<rangle>nres_rel\n  I s' \\<Longrightarrow> (s, s') \\<in> R\n\ngoal (1 subgoal):\n 1. (WHILE c f s,\n     (OP WHILE\\<^bsup>I\\<^esup> :::\n      (R \\<rightarrow> bool_rel) \\<rightarrow>\n      (R \\<rightarrow> \\<langle>R\\<rangle>nres_rel) \\<rightarrow>\n      R \\<rightarrow> \\<langle>R\\<rangle>nres_rel) $\n     c' $\n     f' $\n     s')\n    \\<in> \\<langle>R\\<rangle>nres_rel", "by (auto simp add: nres_rel_def fun_rel_def intro!: WHILE_refine')"], ["", "lemma autoref_WHILEI'[autoref_rules]:\n  assumes \"\\<And>x x'. \\<lbrakk> (x,x')\\<in>R; I x'\\<rbrakk> \\<Longrightarrow> (c x,c'$x') \\<in> Id\"\n  assumes \"\\<And>x x'. \\<lbrakk> REMOVE_INTERNAL c' x'; (x,x')\\<in>R; I x'\\<rbrakk> \n    \\<Longrightarrow> (f x,f'$x') \\<in> \\<langle>R\\<rangle>nres_rel\"\n  shows \"(WHILE c f,\n      (OP (WHILEI I) ::: (R\\<rightarrow>Id) \\<rightarrow> (R\\<rightarrow>\\<langle>R\\<rangle>nres_rel) \\<rightarrow> R \\<rightarrow> \\<langle>R\\<rangle>nres_rel)$c'$f'\n    )\\<in>R \\<rightarrow> \\<langle>R\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (WHILE c f,\n     (OP WHILE\\<^bsup>I\\<^esup> :::\n      (R \\<rightarrow> bool_rel) \\<rightarrow>\n      (R \\<rightarrow> \\<langle>R\\<rangle>nres_rel) \\<rightarrow>\n      R \\<rightarrow> \\<langle>R\\<rangle>nres_rel) $\n     c' $\n     f')\n    \\<in> R \\<rightarrow> \\<langle>R\\<rangle>nres_rel", "unfolding autoref_tag_defs"], ["proof (prove)\ngoal (1 subgoal):\n 1. (WHILE c f, WHILE\\<^bsup>I\\<^esup> c' f')\n    \\<in> R \\<rightarrow> \\<langle>R\\<rangle>nres_rel", "by (parametricity \n      add: autoref_WHILEI[unfolded autoref_tag_defs]\n      assms[unfolded autoref_tag_defs])"], ["", "end"], ["", "subsection \\<open>Invariants\\<close>"], ["", "subsubsection \\<open>Tail Recursion\\<close>"], ["", "context begin"], ["", "private"], ["", "lemma tailrec_transform_aux1:\n    assumes \"RETURN s \\<le> m\"\n    shows \"REC (\\<lambda>D s. sup (a s \\<bind> D) (b s)) s \\<le> lfp (\\<lambda>x. sup m (x\\<bind>a)) \\<bind> b\"\n    (is \"REC ?F s \\<le> lfp ?f \\<bind> b\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. REC (\\<lambda>D s. sup (a s \\<bind> D) (b s)) s\n    \\<le> lfp (\\<lambda>x. sup m (x \\<bind> a)) \\<bind> b", "proof (rule REC_rule[where pre = \"\\<lambda>s. RETURN s \\<le> lfp ?f\"], refine_mono)"], ["proof (state)\ngoal (2 subgoals):\n 1. RETURN s \\<le> lfp (\\<lambda>x. sup m (x \\<bind> a))\n 2. \\<And>f x.\n       \\<lbrakk>\\<And>x.\n                   RETURN x\n                   \\<le> lfp (\\<lambda>x.\n                                 sup m (x \\<bind> a)) \\<Longrightarrow>\n                   f x\n                   \\<le> lfp (\\<lambda>x. sup m (x \\<bind> a)) \\<bind> b;\n        RETURN x \\<le> lfp (\\<lambda>x. sup m (x \\<bind> a));\n        f \\<le> REC (\\<lambda>D s. sup (a s \\<bind> D) (b s))\\<rbrakk>\n       \\<Longrightarrow> sup (a x \\<bind> f) (b x)\n                         \\<le> lfp (\\<lambda>x. sup m (x \\<bind> a)) \\<bind>\n                               b", "show \"RETURN s \\<le> lfp (\\<lambda>x. sup m (x \\<bind> a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RETURN s \\<le> lfp (\\<lambda>x. sup m (x \\<bind> a))", "apply (subst lfp_unfold, tagged_solver)"], ["proof (prove)\ngoal (1 subgoal):\n 1. RETURN s \\<le> sup m (lfp (\\<lambda>x. sup m (x \\<bind> a)) \\<bind> a)", "using assms"], ["proof (prove)\nusing this:\n  RETURN s \\<le> m\n\ngoal (1 subgoal):\n 1. RETURN s \\<le> sup m (lfp (\\<lambda>x. sup m (x \\<bind> a)) \\<bind> a)", "apply (simp add: le_supI1)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  RETURN s \\<le> lfp (\\<lambda>x. sup m (x \\<bind> a))\n\ngoal (1 subgoal):\n 1. \\<And>f x.\n       \\<lbrakk>\\<And>x.\n                   RETURN x\n                   \\<le> lfp (\\<lambda>x.\n                                 sup m (x \\<bind> a)) \\<Longrightarrow>\n                   f x\n                   \\<le> lfp (\\<lambda>x. sup m (x \\<bind> a)) \\<bind> b;\n        RETURN x \\<le> lfp (\\<lambda>x. sup m (x \\<bind> a));\n        f \\<le> REC (\\<lambda>D s. sup (a s \\<bind> D) (b s))\\<rbrakk>\n       \\<Longrightarrow> sup (a x \\<bind> f) (b x)\n                         \\<le> lfp (\\<lambda>x. sup m (x \\<bind> a)) \\<bind>\n                               b", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f x.\n       \\<lbrakk>\\<And>x.\n                   RETURN x\n                   \\<le> lfp (\\<lambda>x.\n                                 sup m (x \\<bind> a)) \\<Longrightarrow>\n                   f x\n                   \\<le> lfp (\\<lambda>x. sup m (x \\<bind> a)) \\<bind> b;\n        RETURN x \\<le> lfp (\\<lambda>x. sup m (x \\<bind> a));\n        f \\<le> REC (\\<lambda>D s. sup (a s \\<bind> D) (b s))\\<rbrakk>\n       \\<Longrightarrow> sup (a x \\<bind> f) (b x)\n                         \\<le> lfp (\\<lambda>x. sup m (x \\<bind> a)) \\<bind>\n                               b", "fix f x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f x.\n       \\<lbrakk>\\<And>x.\n                   RETURN x\n                   \\<le> lfp (\\<lambda>x.\n                                 sup m (x \\<bind> a)) \\<Longrightarrow>\n                   f x\n                   \\<le> lfp (\\<lambda>x. sup m (x \\<bind> a)) \\<bind> b;\n        RETURN x \\<le> lfp (\\<lambda>x. sup m (x \\<bind> a));\n        f \\<le> REC (\\<lambda>D s. sup (a s \\<bind> D) (b s))\\<rbrakk>\n       \\<Longrightarrow> sup (a x \\<bind> f) (b x)\n                         \\<le> lfp (\\<lambda>x. sup m (x \\<bind> a)) \\<bind>\n                               b", "assume IH: \"\\<And>x. RETURN x \\<le> lfp ?f \\<Longrightarrow>\n                  f x \\<le> lfp ?f \\<bind> b\"\n    and PRE: \"RETURN x \\<le> lfp ?f\""], ["proof (state)\nthis:\n  RETURN ?x \\<le> lfp (\\<lambda>x. sup m (x \\<bind> a)) \\<Longrightarrow>\n  f ?x \\<le> lfp (\\<lambda>x. sup m (x \\<bind> a)) \\<bind> b\n  RETURN x \\<le> lfp (\\<lambda>x. sup m (x \\<bind> a))\n\ngoal (1 subgoal):\n 1. \\<And>f x.\n       \\<lbrakk>\\<And>x.\n                   RETURN x\n                   \\<le> lfp (\\<lambda>x.\n                                 sup m (x \\<bind> a)) \\<Longrightarrow>\n                   f x\n                   \\<le> lfp (\\<lambda>x. sup m (x \\<bind> a)) \\<bind> b;\n        RETURN x \\<le> lfp (\\<lambda>x. sup m (x \\<bind> a));\n        f \\<le> REC (\\<lambda>D s. sup (a s \\<bind> D) (b s))\\<rbrakk>\n       \\<Longrightarrow> sup (a x \\<bind> f) (b x)\n                         \\<le> lfp (\\<lambda>x. sup m (x \\<bind> a)) \\<bind>\n                               b", "show \" sup (a x \\<bind> f) (b x) \\<le> lfp ?f \\<bind> b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sup (a x \\<bind> f) (b x)\n    \\<le> lfp (\\<lambda>x. sup m (x \\<bind> a)) \\<bind> b", "proof (rule sup_least)"], ["proof (state)\ngoal (2 subgoals):\n 1. a x \\<bind> f \\<le> lfp (\\<lambda>x. sup m (x \\<bind> a)) \\<bind> b\n 2. b x \\<le> lfp (\\<lambda>x. sup m (x \\<bind> a)) \\<bind> b", "show \"b x \\<le> lfp ?f \\<bind> b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b x \\<le> lfp (\\<lambda>x. sup m (x \\<bind> a)) \\<bind> b", "using PRE"], ["proof (prove)\nusing this:\n  RETURN x \\<le> lfp (\\<lambda>x. sup m (x \\<bind> a))\n\ngoal (1 subgoal):\n 1. b x \\<le> lfp (\\<lambda>x. sup m (x \\<bind> a)) \\<bind> b", "by (simp add: pw_le_iff refine_pw_simps) blast"], ["proof (state)\nthis:\n  b x \\<le> lfp (\\<lambda>x. sup m (x \\<bind> a)) \\<bind> b\n\ngoal (1 subgoal):\n 1. a x \\<bind> f \\<le> lfp (\\<lambda>x. sup m (x \\<bind> a)) \\<bind> b", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. a x \\<bind> f \\<le> lfp (\\<lambda>x. sup m (x \\<bind> a)) \\<bind> b", "from PRE"], ["proof (chain)\npicking this:\n  RETURN x \\<le> lfp (\\<lambda>x. sup m (x \\<bind> a))", "have \"a x \\<le> lfp ?f \\<bind> a\""], ["proof (prove)\nusing this:\n  RETURN x \\<le> lfp (\\<lambda>x. sup m (x \\<bind> a))\n\ngoal (1 subgoal):\n 1. a x \\<le> lfp (\\<lambda>x. sup m (x \\<bind> a)) \\<bind> a", "by (simp add: pw_le_iff refine_pw_simps) blast"], ["proof (state)\nthis:\n  a x \\<le> lfp (\\<lambda>x. sup m (x \\<bind> a)) \\<bind> a\n\ngoal (1 subgoal):\n 1. a x \\<bind> f \\<le> lfp (\\<lambda>x. sup m (x \\<bind> a)) \\<bind> b", "also"], ["proof (state)\nthis:\n  a x \\<le> lfp (\\<lambda>x. sup m (x \\<bind> a)) \\<bind> a\n\ngoal (1 subgoal):\n 1. a x \\<bind> f \\<le> lfp (\\<lambda>x. sup m (x \\<bind> a)) \\<bind> b", "have \"\\<dots> \\<le> lfp ?f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lfp (\\<lambda>x. sup m (x \\<bind> a)) \\<bind> a\n    \\<le> lfp (\\<lambda>x. sup m (x \\<bind> a))", "apply (subst (2) lfp_unfold, tagged_solver)"], ["proof (prove)\ngoal (1 subgoal):\n 1. lfp (\\<lambda>x. sup m (x \\<bind> a)) \\<bind> a\n    \\<le> sup m (lfp (\\<lambda>x. sup m (x \\<bind> a)) \\<bind> a)", "apply (simp add: le_supI2)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  lfp (\\<lambda>x. sup m (x \\<bind> a)) \\<bind> a\n  \\<le> lfp (\\<lambda>x. sup m (x \\<bind> a))\n\ngoal (1 subgoal):\n 1. a x \\<bind> f \\<le> lfp (\\<lambda>x. sup m (x \\<bind> a)) \\<bind> b", "finally"], ["proof (chain)\npicking this:\n  a x \\<le> lfp (\\<lambda>x. sup m (x \\<bind> a))", "show \"a x \\<bind> f \\<le> lfp ?f \\<bind> b\""], ["proof (prove)\nusing this:\n  a x \\<le> lfp (\\<lambda>x. sup m (x \\<bind> a))\n\ngoal (1 subgoal):\n 1. a x \\<bind> f \\<le> lfp (\\<lambda>x. sup m (x \\<bind> a)) \\<bind> b", "using IH"], ["proof (prove)\nusing this:\n  a x \\<le> lfp (\\<lambda>x. sup m (x \\<bind> a))\n  RETURN ?x \\<le> lfp (\\<lambda>x. sup m (x \\<bind> a)) \\<Longrightarrow>\n  f ?x \\<le> lfp (\\<lambda>x. sup m (x \\<bind> a)) \\<bind> b\n\ngoal (1 subgoal):\n 1. a x \\<bind> f \\<le> lfp (\\<lambda>x. sup m (x \\<bind> a)) \\<bind> b", "by (simp add: pw_le_iff refine_pw_simps) blast"], ["proof (state)\nthis:\n  a x \\<bind> f \\<le> lfp (\\<lambda>x. sup m (x \\<bind> a)) \\<bind> b\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sup (a x \\<bind> f) (b x)\n  \\<le> lfp (\\<lambda>x. sup m (x \\<bind> a)) \\<bind> b\n\ngoal:\nNo subgoals!", "qed"], ["", "private"], ["", "corollary tailrec_transform1: \n    fixes m :: \"'a nres\"\n    shows \"m\\<bind>REC (\\<lambda>D s. sup (a s \\<bind> D) (b s)) \\<le> lfp (\\<lambda>x. sup m (x\\<bind>a)) \\<bind> b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<bind> REC (\\<lambda>D s. sup (a s \\<bind> D) (b s))\n    \\<le> lfp (\\<lambda>x. sup m (x \\<bind> a)) \\<bind> b", "apply (cases \"nofail m\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. nofail m \\<Longrightarrow>\n    m \\<bind> REC (\\<lambda>D s. sup (a s \\<bind> D) (b s))\n    \\<le> lfp (\\<lambda>x. sup m (x \\<bind> a)) \\<bind> b\n 2. \\<not> nofail m \\<Longrightarrow>\n    m \\<bind> REC (\\<lambda>D s. sup (a s \\<bind> D) (b s))\n    \\<le> lfp (\\<lambda>x. sup m (x \\<bind> a)) \\<bind> b", "apply (erule bind_le_nofailI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       RETURN x \\<le> m \\<Longrightarrow>\n       REC (\\<lambda>D s. sup (a s \\<bind> D) (b s)) x\n       \\<le> lfp (\\<lambda>x. sup m (x \\<bind> a)) \\<bind> b\n 2. \\<not> nofail m \\<Longrightarrow>\n    m \\<bind> REC (\\<lambda>D s. sup (a s \\<bind> D) (b s))\n    \\<le> lfp (\\<lambda>x. sup m (x \\<bind> a)) \\<bind> b", "apply (erule tailrec_transform_aux1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> nofail m \\<Longrightarrow>\n    m \\<bind> REC (\\<lambda>D s. sup (a s \\<bind> D) (b s))\n    \\<le> lfp (\\<lambda>x. sup m (x \\<bind> a)) \\<bind> b", "apply (simp add: not_nofail_iff lfp_const)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "private"], ["", "lemma tailrec_transform_aux2:\n    fixes m :: \"'a nres\"\n    shows \"lfp (\\<lambda>x. sup m (x\\<bind>a)) \n      \\<le> m \\<bind> REC (\\<lambda>D s. sup (a s \\<bind> D) (RETURN s))\"\n    (is \"lfp ?f \\<le> m \\<bind> REC ?F\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. lfp (\\<lambda>x. sup m (x \\<bind> a))\n    \\<le> m \\<bind> REC (\\<lambda>D s. sup (a s \\<bind> D) (RETURN s))", "apply (subst gen_kleene_lfp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. cont (\\<lambda>x. x \\<bind> a)\n 2. (SUP i. ((\\<lambda>x. x \\<bind> a) ^^ i) m)\n    \\<le> m \\<bind> REC (\\<lambda>D s. sup (a s \\<bind> D) (RETURN s))", "apply (simp add: cont_def pw_eq_iff refine_pw_simps, blast)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (SUP i. ((\\<lambda>x. x \\<bind> a) ^^ i) m)\n    \\<le> m \\<bind> REC (\\<lambda>D s. sup (a s \\<bind> D) (RETURN s))", "apply (rule SUP_least, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       ((\\<lambda>x. x \\<bind> a) ^^ i) m\n       \\<le> m \\<bind> REC (\\<lambda>D s. sup (a s \\<bind> D) (RETURN s))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       ((\\<lambda>x. x \\<bind> a) ^^ i) m\n       \\<le> m \\<bind> REC (\\<lambda>D s. sup (a s \\<bind> D) (RETURN s))", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       ((\\<lambda>x. x \\<bind> a) ^^ i) m\n       \\<le> m \\<bind> REC (\\<lambda>D s. sup (a s \\<bind> D) (RETURN s))", "show \"((\\<lambda>x. x \\<bind> a) ^^ i) m \\<le> m \\<bind> REC (\\<lambda>D s. sup (a s \\<bind> D) (RETURN s))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x. x \\<bind> a) ^^ i) m\n    \\<le> m \\<bind> REC (\\<lambda>D s. sup (a s \\<bind> D) (RETURN s))", "apply (induction i arbitrary: m)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>m.\n       ((\\<lambda>x. x \\<bind> a) ^^ 0) m\n       \\<le> m \\<bind> REC (\\<lambda>D s. sup (a s \\<bind> D) (RETURN s))\n 2. \\<And>i m.\n       (\\<And>m.\n           ((\\<lambda>x. x \\<bind> a) ^^ i) m\n           \\<le> m \\<bind>\n                 REC (\\<lambda>D s.\n                         sup (a s \\<bind> D) (RETURN s))) \\<Longrightarrow>\n       ((\\<lambda>x. x \\<bind> a) ^^ Suc i) m\n       \\<le> m \\<bind> REC (\\<lambda>D s. sup (a s \\<bind> D) (RETURN s))", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>m.\n       m \\<le> m \\<bind> REC (\\<lambda>D s. sup (a s \\<bind> D) (RETURN s))\n 2. \\<And>i m.\n       (\\<And>m.\n           ((\\<lambda>x. x \\<bind> a) ^^ i) m\n           \\<le> m \\<bind>\n                 REC (\\<lambda>D s.\n                         sup (a s \\<bind> D) (RETURN s))) \\<Longrightarrow>\n       ((\\<lambda>x. x \\<bind> a) ^^ Suc i) m\n       \\<le> m \\<bind> REC (\\<lambda>D s. sup (a s \\<bind> D) (RETURN s))", "apply (subst REC_unfold, refine_mono)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>m.\n       m \\<le> m \\<bind>\n               (\\<lambda>b.\n                   sup (a b \\<bind>\n                        REC (\\<lambda>D s. sup (a s \\<bind> D) (RETURN s)))\n                    (RETURN b))\n 2. \\<And>i m.\n       (\\<And>m.\n           ((\\<lambda>x. x \\<bind> a) ^^ i) m\n           \\<le> m \\<bind>\n                 REC (\\<lambda>D s.\n                         sup (a s \\<bind> D) (RETURN s))) \\<Longrightarrow>\n       ((\\<lambda>x. x \\<bind> a) ^^ Suc i) m\n       \\<le> m \\<bind> REC (\\<lambda>D s. sup (a s \\<bind> D) (RETURN s))", "apply (simp add: pw_le_iff refine_pw_simps, blast)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i m.\n       (\\<And>m.\n           ((\\<lambda>x. x \\<bind> a) ^^ i) m\n           \\<le> m \\<bind>\n                 REC (\\<lambda>D s.\n                         sup (a s \\<bind> D) (RETURN s))) \\<Longrightarrow>\n       ((\\<lambda>x. x \\<bind> a) ^^ Suc i) m\n       \\<le> m \\<bind> REC (\\<lambda>D s. sup (a s \\<bind> D) (RETURN s))", "apply (subst funpow_Suc_right)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i m.\n       (\\<And>m.\n           ((\\<lambda>x. x \\<bind> a) ^^ i) m\n           \\<le> m \\<bind>\n                 REC (\\<lambda>D s.\n                         sup (a s \\<bind> D) (RETURN s))) \\<Longrightarrow>\n       ((\\<lambda>x. x \\<bind> a) ^^ i \\<circ> (\\<lambda>x. x \\<bind> a)) m\n       \\<le> m \\<bind> REC (\\<lambda>D s. sup (a s \\<bind> D) (RETURN s))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i m.\n       (\\<And>m.\n           ((\\<lambda>x. x \\<bind> a) ^^ i) m\n           \\<le> m \\<bind>\n                 REC (\\<lambda>D s.\n                         sup (a s \\<bind> D) (RETURN s))) \\<Longrightarrow>\n       ((\\<lambda>x. x \\<bind> a) ^^ i) (m \\<bind> a)\n       \\<le> m \\<bind> REC (\\<lambda>D s. sup (a s \\<bind> D) (RETURN s))", "apply (rule order_trans)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i m.\n       (\\<And>m.\n           ((\\<lambda>x. x \\<bind> a) ^^ i) m\n           \\<le> m \\<bind>\n                 REC (\\<lambda>D s.\n                         sup (a s \\<bind> D) (RETURN s))) \\<Longrightarrow>\n       ((\\<lambda>x. x \\<bind> a) ^^ i) (m \\<bind> a) \\<le> ?y106 i m\n 2. \\<And>i m.\n       (\\<And>m.\n           ((\\<lambda>x. x \\<bind> a) ^^ i) m\n           \\<le> m \\<bind>\n                 REC (\\<lambda>D s.\n                         sup (a s \\<bind> D) (RETURN s))) \\<Longrightarrow>\n       ?y106 i m\n       \\<le> m \\<bind> REC (\\<lambda>D s. sup (a s \\<bind> D) (RETURN s))", "apply rprems"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i m.\n       (\\<And>m.\n           ((\\<lambda>x. x \\<bind> a) ^^ i) m\n           \\<le> m \\<bind>\n                 REC (\\<lambda>D s.\n                         sup (a s \\<bind> D) (RETURN s))) \\<Longrightarrow>\n       m \\<bind> a \\<bind>\n       REC (\\<lambda>D s. sup (a s \\<bind> D) (RETURN s))\n       \\<le> m \\<bind> REC (\\<lambda>D s. sup (a s \\<bind> D) (RETURN s))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i m.\n       (\\<And>m.\n           ((\\<lambda>x. x \\<bind> a) ^^ i) m\n           \\<le> m \\<bind>\n                 REC (\\<lambda>D s.\n                         sup (a s \\<bind> D) (RETURN s))) \\<Longrightarrow>\n       m \\<bind>\n       (\\<lambda>x.\n           a x \\<bind> REC (\\<lambda>D s. sup (a s \\<bind> D) (RETURN s)))\n       \\<le> m \\<bind> REC (\\<lambda>D s. sup (a s \\<bind> D) (RETURN s))", "apply (subst (2) REC_unfold, refine_mono)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i m.\n       (\\<And>m.\n           ((\\<lambda>x. x \\<bind> a) ^^ i) m\n           \\<le> m \\<bind>\n                 REC (\\<lambda>D s.\n                         sup (a s \\<bind> D) (RETURN s))) \\<Longrightarrow>\n       m \\<bind>\n       (\\<lambda>x.\n           a x \\<bind> REC (\\<lambda>D s. sup (a s \\<bind> D) (RETURN s)))\n       \\<le> m \\<bind>\n             (\\<lambda>b.\n                 sup (a b \\<bind>\n                      REC (\\<lambda>D s. sup (a s \\<bind> D) (RETURN s)))\n                  (RETURN b))", "apply (simp add: bind_distrib_sup2)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  ((\\<lambda>x. x \\<bind> a) ^^ i) m\n  \\<le> m \\<bind> REC (\\<lambda>D s. sup (a s \\<bind> D) (RETURN s))\n\ngoal:\nNo subgoals!", "qed"], ["", "private"], ["", "lemma tailrec_transform_aux3: \"REC (\\<lambda>D s. sup (a s \\<bind> D) (RETURN s)) s \\<bind> b \n    \\<le> REC (\\<lambda>D s. sup (a s \\<bind> D) (b s)) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. REC (\\<lambda>D s. sup (a s \\<bind> D) (RETURN s)) s \\<bind> b\n    \\<le> REC (\\<lambda>D s. sup (a s \\<bind> D) (b s)) s", "apply (subst bind_le_shift)"], ["proof (prove)\ngoal (1 subgoal):\n 1. REC (\\<lambda>D s. sup (a s \\<bind> D) (RETURN s)) s\n    \\<le> (if nofail (REC (\\<lambda>D s. sup (a s \\<bind> D) (b s)) s)\n           then SPEC\n                 (\\<lambda>x.\n                     b x\n                     \\<le> REC (\\<lambda>D s. sup (a s \\<bind> D) (b s)) s)\n           else FAIL)", "apply (rule REC_rule, refine_mono)"], ["proof (prove)\ngoal (2 subgoals):\n 1. ?pre s\n 2. \\<And>f x.\n       \\<lbrakk>\\<And>x.\n                   ?pre x \\<Longrightarrow>\n                   f x\n                   \\<le> (if nofail\n                              (REC (\\<lambda>D s. sup (a s \\<bind> D) (b s))\n                                x)\n                          then SPEC\n                                (\\<lambda>xa.\n                                    b xa\n                                    \\<le> REC\n     (\\<lambda>D s. sup (a s \\<bind> D) (b s)) x)\n                          else FAIL);\n        ?pre x;\n        f \\<le> REC (\\<lambda>D s. sup (a s \\<bind> D) (RETURN s))\\<rbrakk>\n       \\<Longrightarrow> sup (a x \\<bind> f) (RETURN x)\n                         \\<le> (if nofail\n                                    (REC\n(\\<lambda>D s. sup (a s \\<bind> D) (b s)) x)\n                                then SPEC\n(\\<lambda>xa. b xa \\<le> REC (\\<lambda>D s. sup (a s \\<bind> D) (b s)) x)\n                                else FAIL)", "apply (rule TrueI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f x.\n       \\<lbrakk>\\<And>x.\n                   True \\<Longrightarrow>\n                   f x\n                   \\<le> (if nofail\n                              (REC (\\<lambda>D s. sup (a s \\<bind> D) (b s))\n                                x)\n                          then SPEC\n                                (\\<lambda>xa.\n                                    b xa\n                                    \\<le> REC\n     (\\<lambda>D s. sup (a s \\<bind> D) (b s)) x)\n                          else FAIL);\n        True;\n        f \\<le> REC (\\<lambda>D s. sup (a s \\<bind> D) (RETURN s))\\<rbrakk>\n       \\<Longrightarrow> sup (a x \\<bind> f) (RETURN x)\n                         \\<le> (if nofail\n                                    (REC\n(\\<lambda>D s. sup (a s \\<bind> D) (b s)) x)\n                                then SPEC\n(\\<lambda>xa. b xa \\<le> REC (\\<lambda>D s. sup (a s \\<bind> D) (b s)) x)\n                                else FAIL)", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>f x.\n       \\<lbrakk>\\<And>x.\n                   f x\n                   \\<le> (if nofail\n                              (REC (\\<lambda>D s. sup (a s \\<bind> D) (b s))\n                                x)\n                          then SPEC\n                                (\\<lambda>xa.\n                                    b xa\n                                    \\<le> REC\n     (\\<lambda>D s. sup (a s \\<bind> D) (b s)) x)\n                          else FAIL);\n        f \\<le> REC (\\<lambda>D s. sup (a s \\<bind> D) (RETURN s));\n        nofail (REC (\\<lambda>D s. sup (a s \\<bind> D) (b s)) x)\\<rbrakk>\n       \\<Longrightarrow> a x \\<bind> f\n                         \\<le> SPEC\n                                (\\<lambda>xa.\n                                    b xa\n                                    \\<le> REC\n     (\\<lambda>D s. sup (a s \\<bind> D) (b s)) x)\n 2. \\<And>f x.\n       \\<lbrakk>\\<And>x.\n                   f x\n                   \\<le> (if nofail\n                              (REC (\\<lambda>D s. sup (a s \\<bind> D) (b s))\n                                x)\n                          then SPEC\n                                (\\<lambda>xa.\n                                    b xa\n                                    \\<le> REC\n     (\\<lambda>D s. sup (a s \\<bind> D) (b s)) x)\n                          else FAIL);\n        f \\<le> REC (\\<lambda>D s. sup (a s \\<bind> D) (RETURN s));\n        nofail (REC (\\<lambda>D s. sup (a s \\<bind> D) (b s)) x)\\<rbrakk>\n       \\<Longrightarrow> b x\n                         \\<le> REC (\\<lambda>D s. sup (a s \\<bind> D) (b s))\n                                x", "apply (subst (asm) (4) REC_unfold, refine_mono)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>f x.\n       \\<lbrakk>\\<And>x.\n                   f x\n                   \\<le> (if nofail\n                              (REC (\\<lambda>D s. sup (a s \\<bind> D) (b s))\n                                x)\n                          then SPEC\n                                (\\<lambda>xa.\n                                    b xa\n                                    \\<le> REC\n     (\\<lambda>D s. sup (a s \\<bind> D) (b s)) x)\n                          else FAIL);\n        f \\<le> REC (\\<lambda>D s. sup (a s \\<bind> D) (RETURN s));\n        nofail\n         (sup (a x \\<bind> REC (\\<lambda>D s. sup (a s \\<bind> D) (b s)))\n           (b x))\\<rbrakk>\n       \\<Longrightarrow> a x \\<bind> f\n                         \\<le> SPEC\n                                (\\<lambda>xa.\n                                    b xa\n                                    \\<le> REC\n     (\\<lambda>D s. sup (a s \\<bind> D) (b s)) x)\n 2. \\<And>f x.\n       \\<lbrakk>\\<And>x.\n                   f x\n                   \\<le> (if nofail\n                              (REC (\\<lambda>D s. sup (a s \\<bind> D) (b s))\n                                x)\n                          then SPEC\n                                (\\<lambda>xa.\n                                    b xa\n                                    \\<le> REC\n     (\\<lambda>D s. sup (a s \\<bind> D) (b s)) x)\n                          else FAIL);\n        f \\<le> REC (\\<lambda>D s. sup (a s \\<bind> D) (RETURN s));\n        nofail (REC (\\<lambda>D s. sup (a s \\<bind> D) (b s)) x)\\<rbrakk>\n       \\<Longrightarrow> b x\n                         \\<le> REC (\\<lambda>D s. sup (a s \\<bind> D) (b s))\n                                x", "apply (rule order_trans[OF bind_mono(1)[OF order_refl]])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>f x xa.\n       \\<lbrakk>\\<And>x.\n                   f x\n                   \\<le> (if nofail\n                              (REC (\\<lambda>D s. sup (a s \\<bind> D) (b s))\n                                x)\n                          then SPEC\n                                (\\<lambda>xa.\n                                    b xa\n                                    \\<le> REC\n     (\\<lambda>D s. sup (a s \\<bind> D) (b s)) x)\n                          else FAIL);\n        f \\<le> REC (\\<lambda>D s. sup (a s \\<bind> D) (RETURN s));\n        nofail\n         (sup (a x \\<bind> REC (\\<lambda>D s. sup (a s \\<bind> D) (b s)))\n           (b x));\n        RETURN xa \\<le> a x\\<rbrakk>\n       \\<Longrightarrow> f xa \\<le> ?f'398 f x xa\n 2. \\<And>f x.\n       \\<lbrakk>\\<And>x.\n                   f x\n                   \\<le> (if nofail\n                              (REC (\\<lambda>D s. sup (a s \\<bind> D) (b s))\n                                x)\n                          then SPEC\n                                (\\<lambda>xa.\n                                    b xa\n                                    \\<le> REC\n     (\\<lambda>D s. sup (a s \\<bind> D) (b s)) x)\n                          else FAIL);\n        f \\<le> REC (\\<lambda>D s. sup (a s \\<bind> D) (RETURN s));\n        nofail\n         (sup (a x \\<bind> REC (\\<lambda>D s. sup (a s \\<bind> D) (b s)))\n           (b x))\\<rbrakk>\n       \\<Longrightarrow> a x \\<bind> ?f'398 f x\n                         \\<le> SPEC\n                                (\\<lambda>xa.\n                                    b xa\n                                    \\<le> REC\n     (\\<lambda>D s. sup (a s \\<bind> D) (b s)) x)\n 3. \\<And>f x.\n       \\<lbrakk>\\<And>x.\n                   f x\n                   \\<le> (if nofail\n                              (REC (\\<lambda>D s. sup (a s \\<bind> D) (b s))\n                                x)\n                          then SPEC\n                                (\\<lambda>xa.\n                                    b xa\n                                    \\<le> REC\n     (\\<lambda>D s. sup (a s \\<bind> D) (b s)) x)\n                          else FAIL);\n        f \\<le> REC (\\<lambda>D s. sup (a s \\<bind> D) (RETURN s));\n        nofail (REC (\\<lambda>D s. sup (a s \\<bind> D) (b s)) x)\\<rbrakk>\n       \\<Longrightarrow> b x\n                         \\<le> REC (\\<lambda>D s. sup (a s \\<bind> D) (b s))\n                                x", "apply rprems"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>f x.\n       \\<lbrakk>\\<And>x.\n                   f x\n                   \\<le> (if nofail\n                              (REC (\\<lambda>D s. sup (a s \\<bind> D) (b s))\n                                x)\n                          then SPEC\n                                (\\<lambda>xa.\n                                    b xa\n                                    \\<le> REC\n     (\\<lambda>D s. sup (a s \\<bind> D) (b s)) x)\n                          else FAIL);\n        f \\<le> REC (\\<lambda>D s. sup (a s \\<bind> D) (RETURN s));\n        nofail\n         (sup (a x \\<bind> REC (\\<lambda>D s. sup (a s \\<bind> D) (b s)))\n           (b x))\\<rbrakk>\n       \\<Longrightarrow> a x \\<bind>\n                         (\\<lambda>xa.\n                             if nofail\n                                 (REC (\\<lambda>D s.\n    sup (a s \\<bind> D) (b s))\n                                   xa)\n                             then SPEC\n                                   (\\<lambda>x.\n b x \\<le> REC (\\<lambda>D s. sup (a s \\<bind> D) (b s)) xa)\n                             else FAIL)\n                         \\<le> SPEC\n                                (\\<lambda>xa.\n                                    b xa\n                                    \\<le> REC\n     (\\<lambda>D s. sup (a s \\<bind> D) (b s)) x)\n 2. \\<And>f x.\n       \\<lbrakk>\\<And>x.\n                   f x\n                   \\<le> (if nofail\n                              (REC (\\<lambda>D s. sup (a s \\<bind> D) (b s))\n                                x)\n                          then SPEC\n                                (\\<lambda>xa.\n                                    b xa\n                                    \\<le> REC\n     (\\<lambda>D s. sup (a s \\<bind> D) (b s)) x)\n                          else FAIL);\n        f \\<le> REC (\\<lambda>D s. sup (a s \\<bind> D) (RETURN s));\n        nofail (REC (\\<lambda>D s. sup (a s \\<bind> D) (b s)) x)\\<rbrakk>\n       \\<Longrightarrow> b x\n                         \\<le> REC (\\<lambda>D s. sup (a s \\<bind> D) (b s))\n                                x", "apply (subst (3) REC_unfold, refine_mono)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>f x.\n       \\<lbrakk>\\<And>x.\n                   f x\n                   \\<le> (if nofail\n                              (REC (\\<lambda>D s. sup (a s \\<bind> D) (b s))\n                                x)\n                          then SPEC\n                                (\\<lambda>xa.\n                                    b xa\n                                    \\<le> REC\n     (\\<lambda>D s. sup (a s \\<bind> D) (b s)) x)\n                          else FAIL);\n        f \\<le> REC (\\<lambda>D s. sup (a s \\<bind> D) (RETURN s));\n        nofail\n         (sup (a x \\<bind> REC (\\<lambda>D s. sup (a s \\<bind> D) (b s)))\n           (b x))\\<rbrakk>\n       \\<Longrightarrow> a x \\<bind>\n                         (\\<lambda>xa.\n                             if nofail\n                                 (REC (\\<lambda>D s.\n    sup (a s \\<bind> D) (b s))\n                                   xa)\n                             then SPEC\n                                   (\\<lambda>x.\n b x \\<le> REC (\\<lambda>D s. sup (a s \\<bind> D) (b s)) xa)\n                             else FAIL)\n                         \\<le> SPEC\n                                (\\<lambda>xa.\n                                    b xa\n                                    \\<le> sup\n     (a x \\<bind> REC (\\<lambda>D s. sup (a s \\<bind> D) (b s))) (b x))\n 2. \\<And>f x.\n       \\<lbrakk>\\<And>x.\n                   f x\n                   \\<le> (if nofail\n                              (REC (\\<lambda>D s. sup (a s \\<bind> D) (b s))\n                                x)\n                          then SPEC\n                                (\\<lambda>xa.\n                                    b xa\n                                    \\<le> REC\n     (\\<lambda>D s. sup (a s \\<bind> D) (b s)) x)\n                          else FAIL);\n        f \\<le> REC (\\<lambda>D s. sup (a s \\<bind> D) (RETURN s));\n        nofail (REC (\\<lambda>D s. sup (a s \\<bind> D) (b s)) x)\\<rbrakk>\n       \\<Longrightarrow> b x\n                         \\<le> REC (\\<lambda>D s. sup (a s \\<bind> D) (b s))\n                                x", "apply (simp add: refine_pw_simps pw_le_iff, blast)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f x.\n       \\<lbrakk>\\<And>x.\n                   f x\n                   \\<le> (if nofail\n                              (REC (\\<lambda>D s. sup (a s \\<bind> D) (b s))\n                                x)\n                          then SPEC\n                                (\\<lambda>xa.\n                                    b xa\n                                    \\<le> REC\n     (\\<lambda>D s. sup (a s \\<bind> D) (b s)) x)\n                          else FAIL);\n        f \\<le> REC (\\<lambda>D s. sup (a s \\<bind> D) (RETURN s));\n        nofail (REC (\\<lambda>D s. sup (a s \\<bind> D) (b s)) x)\\<rbrakk>\n       \\<Longrightarrow> b x\n                         \\<le> REC (\\<lambda>D s. sup (a s \\<bind> D) (b s))\n                                x", "apply (subst REC_unfold, refine_mono, simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "private"], ["", "lemma tailrec_transform2:\n    \"lfp (\\<lambda>x. sup m (bind x a)) \\<bind> b \\<le> m \\<bind> REC (\\<lambda>D s. sup (a s \\<bind> D) (b s))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lfp (\\<lambda>x. sup m (x \\<bind> a)) \\<bind> b\n    \\<le> m \\<bind> REC (\\<lambda>D s. sup (a s \\<bind> D) (b s))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. lfp (\\<lambda>x. sup m (x \\<bind> a)) \\<bind> b\n    \\<le> m \\<bind> REC (\\<lambda>D s. sup (a s \\<bind> D) (b s))", "from bind_mono(1)[OF tailrec_transform_aux2 order_refl]"], ["proof (chain)\npicking this:\n  lfp (\\<lambda>x. sup ?m2 (x \\<bind> ?a2)) \\<bind> ?f\n  \\<le> ?m2 \\<bind>\n        REC (\\<lambda>D s. sup (?a2 s \\<bind> D) (RETURN s)) \\<bind>\n        ?f", "have \"lfp (\\<lambda>x. sup m (bind x a)) \\<bind> b \n      \\<le> m \\<bind> (\\<lambda>x. REC (\\<lambda>D s. sup (a s \\<bind> D) (RETURN s)) x \\<bind> b)\""], ["proof (prove)\nusing this:\n  lfp (\\<lambda>x. sup ?m2 (x \\<bind> ?a2)) \\<bind> ?f\n  \\<le> ?m2 \\<bind>\n        REC (\\<lambda>D s. sup (?a2 s \\<bind> D) (RETURN s)) \\<bind>\n        ?f\n\ngoal (1 subgoal):\n 1. lfp (\\<lambda>x. sup m (x \\<bind> a)) \\<bind> b\n    \\<le> m \\<bind>\n          (\\<lambda>x.\n              REC (\\<lambda>D s. sup (a s \\<bind> D) (RETURN s)) x \\<bind>\n              b)", "by simp"], ["proof (state)\nthis:\n  lfp (\\<lambda>x. sup m (x \\<bind> a)) \\<bind> b\n  \\<le> m \\<bind>\n        (\\<lambda>x.\n            REC (\\<lambda>D s. sup (a s \\<bind> D) (RETURN s)) x \\<bind> b)\n\ngoal (1 subgoal):\n 1. lfp (\\<lambda>x. sup m (x \\<bind> a)) \\<bind> b\n    \\<le> m \\<bind> REC (\\<lambda>D s. sup (a s \\<bind> D) (b s))", "also"], ["proof (state)\nthis:\n  lfp (\\<lambda>x. sup m (x \\<bind> a)) \\<bind> b\n  \\<le> m \\<bind>\n        (\\<lambda>x.\n            REC (\\<lambda>D s. sup (a s \\<bind> D) (RETURN s)) x \\<bind> b)\n\ngoal (1 subgoal):\n 1. lfp (\\<lambda>x. sup m (x \\<bind> a)) \\<bind> b\n    \\<le> m \\<bind> REC (\\<lambda>D s. sup (a s \\<bind> D) (b s))", "from bind_mono(1)[OF order_refl tailrec_transform_aux3]"], ["proof (chain)\npicking this:\n  ?M \\<bind>\n  (\\<lambda>x.\n      REC (\\<lambda>D s. sup (?a1 x s \\<bind> D) (RETURN s)) (?s1 x) \\<bind>\n      ?b1 x)\n  \\<le> ?M \\<bind>\n        (\\<lambda>x.\n            REC (\\<lambda>D s. sup (?a1 x s \\<bind> D) (?b1 x s)) (?s1 x))", "have \"\\<dots> \\<le> m \\<bind> REC (\\<lambda>D s. sup (a s \\<bind> D) (b s))\""], ["proof (prove)\nusing this:\n  ?M \\<bind>\n  (\\<lambda>x.\n      REC (\\<lambda>D s. sup (?a1 x s \\<bind> D) (RETURN s)) (?s1 x) \\<bind>\n      ?b1 x)\n  \\<le> ?M \\<bind>\n        (\\<lambda>x.\n            REC (\\<lambda>D s. sup (?a1 x s \\<bind> D) (?b1 x s)) (?s1 x))\n\ngoal (1 subgoal):\n 1. m \\<bind>\n    (\\<lambda>x.\n        REC (\\<lambda>D s. sup (a s \\<bind> D) (RETURN s)) x \\<bind> b)\n    \\<le> m \\<bind> REC (\\<lambda>D s. sup (a s \\<bind> D) (b s))", "."], ["proof (state)\nthis:\n  m \\<bind>\n  (\\<lambda>x.\n      REC (\\<lambda>D s. sup (a s \\<bind> D) (RETURN s)) x \\<bind> b)\n  \\<le> m \\<bind> REC (\\<lambda>D s. sup (a s \\<bind> D) (b s))\n\ngoal (1 subgoal):\n 1. lfp (\\<lambda>x. sup m (x \\<bind> a)) \\<bind> b\n    \\<le> m \\<bind> REC (\\<lambda>D s. sup (a s \\<bind> D) (b s))", "finally"], ["proof (chain)\npicking this:\n  lfp (\\<lambda>x. sup m (x \\<bind> a)) \\<bind> b\n  \\<le> m \\<bind> REC (\\<lambda>D s. sup (a s \\<bind> D) (b s))", "show ?thesis"], ["proof (prove)\nusing this:\n  lfp (\\<lambda>x. sup m (x \\<bind> a)) \\<bind> b\n  \\<le> m \\<bind> REC (\\<lambda>D s. sup (a s \\<bind> D) (b s))\n\ngoal (1 subgoal):\n 1. lfp (\\<lambda>x. sup m (x \\<bind> a)) \\<bind> b\n    \\<le> m \\<bind> REC (\\<lambda>D s. sup (a s \\<bind> D) (b s))", "."], ["proof (state)\nthis:\n  lfp (\\<lambda>x. sup m (x \\<bind> a)) \\<bind> b\n  \\<le> m \\<bind> REC (\\<lambda>D s. sup (a s \\<bind> D) (b s))\n\ngoal:\nNo subgoals!", "qed"], ["", "definition \"tailrec_body a b \\<equiv> (\\<lambda>D s. sup (bind (a s) D) (b s))\""], ["", "theorem tailrec_transform: \n    \"m \\<bind> REC (\\<lambda>D s. sup (a s \\<bind> D) (b s)) = lfp (\\<lambda>x. sup m (bind x a)) \\<bind> b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<bind> REC (\\<lambda>D s. sup (a s \\<bind> D) (b s)) =\n    lfp (\\<lambda>x. sup m (x \\<bind> a)) \\<bind> b", "apply (rule antisym)"], ["proof (prove)\ngoal (2 subgoals):\n 1. m \\<bind> REC (\\<lambda>D s. sup (a s \\<bind> D) (b s))\n    \\<le> lfp (\\<lambda>x. sup m (x \\<bind> a)) \\<bind> b\n 2. lfp (\\<lambda>x. sup m (x \\<bind> a)) \\<bind> b\n    \\<le> m \\<bind> REC (\\<lambda>D s. sup (a s \\<bind> D) (b s))", "apply (rule tailrec_transform1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. lfp (\\<lambda>x. sup m (x \\<bind> a)) \\<bind> b\n    \\<le> m \\<bind> REC (\\<lambda>D s. sup (a s \\<bind> D) (b s))", "apply (rule tailrec_transform2)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "theorem tailrec_transform': \n    \"m \\<bind> REC (tailrec_body a b) = lfp (\\<lambda>x. sup m (bind x a)) \\<bind> b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<bind> REC (tailrec_body a b) =\n    lfp (\\<lambda>x. sup m (x \\<bind> a)) \\<bind> b", "unfolding tailrec_body_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<bind> REC (\\<lambda>D s. sup (a s \\<bind> D) (b s)) =\n    lfp (\\<lambda>x. sup m (x \\<bind> a)) \\<bind> b", "by (rule tailrec_transform)"], ["", "lemma \"WHILE c f = \n    REC (tailrec_body \n      (\\<lambda>s. do {ASSUME (c s); f s}) \n      (\\<lambda>s. do {ASSUME (\\<not>c s); RETURN s})\n    )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. WHILE c f =\n    REC (tailrec_body (\\<lambda>s. ASSUME (c s) \\<bind> (\\<lambda>_. f s))\n          (\\<lambda>s. ASSUME (\\<not> c s) \\<bind> (\\<lambda>_. RETURN s)))", "unfolding WHILE_def WHILEI_def WHILEI_body_def tailrec_body_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. REC (\\<lambda>W s.\n            if True then if c s then f s \\<bind> W else RETURN s\n            else FAIL) =\n    REC (\\<lambda>D s.\n            sup (ASSUME (c s) \\<bind> (\\<lambda>_. f s) \\<bind> D)\n             (ASSUME (\\<not> c s) \\<bind> (\\<lambda>_. RETURN s)))", "apply (fo_rule fun_cong arg_cong)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>W s.\n        if True then if c s then f s \\<bind> W else RETURN s else FAIL) =\n    (\\<lambda>D s.\n        sup (ASSUME (c s) \\<bind> (\\<lambda>_. f s) \\<bind> D)\n         (ASSUME (\\<not> c s) \\<bind> (\\<lambda>_. RETURN s)))", "apply (intro ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>W s.\n       (if True then if c s then f s \\<bind> W else RETURN s else FAIL) =\n       sup (ASSUME (c s) \\<bind> (\\<lambda>_. f s) \\<bind> W)\n        (ASSUME (\\<not> c s) \\<bind> (\\<lambda>_. RETURN s))", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma WHILEI_tailrec_conv: \"WHILEI I c f = \n    REC (tailrec_body \n      (\\<lambda>s. do {ASSERT (I s); ASSUME (c s); f s}) \n      (\\<lambda>s. do {ASSERT (I s); ASSUME (\\<not>c s); RETURN s})\n    )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. WHILE\\<^bsup>I\\<^esup> c f =\n    REC (tailrec_body\n          (\\<lambda>s.\n              ASSERT (I s) \\<bind>\n              (\\<lambda>_. ASSUME (c s) \\<bind> (\\<lambda>_. f s)))\n          (\\<lambda>s.\n              ASSERT (I s) \\<bind>\n              (\\<lambda>_.\n                  ASSUME (\\<not> c s) \\<bind> (\\<lambda>_. RETURN s))))", "unfolding WHILEI_def WHILEI_body_def tailrec_body_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. REC (\\<lambda>W s.\n            if I s then if c s then f s \\<bind> W else RETURN s else FAIL) =\n    REC (\\<lambda>D s.\n            sup (ASSERT (I s) \\<bind>\n                 (\\<lambda>_.\n                     ASSUME (c s) \\<bind> (\\<lambda>_. f s)) \\<bind>\n                 D)\n             (ASSERT (I s) \\<bind>\n              (\\<lambda>_.\n                  ASSUME (\\<not> c s) \\<bind> (\\<lambda>_. RETURN s))))", "apply (fo_rule fun_cong arg_cong)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>W s.\n        if I s then if c s then f s \\<bind> W else RETURN s else FAIL) =\n    (\\<lambda>D s.\n        sup (ASSERT (I s) \\<bind>\n             (\\<lambda>_. ASSUME (c s) \\<bind> (\\<lambda>_. f s)) \\<bind>\n             D)\n         (ASSERT (I s) \\<bind>\n          (\\<lambda>_. ASSUME (\\<not> c s) \\<bind> (\\<lambda>_. RETURN s))))", "apply (intro ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>W s.\n       (if I s then if c s then f s \\<bind> W else RETURN s else FAIL) =\n       sup (ASSERT (I s) \\<bind>\n            (\\<lambda>_. ASSUME (c s) \\<bind> (\\<lambda>_. f s)) \\<bind>\n            W)\n        (ASSERT (I s) \\<bind>\n         (\\<lambda>_. ASSUME (\\<not> c s) \\<bind> (\\<lambda>_. RETURN s)))", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma WHILEIT_tailrec_conv: \"WHILEIT I c f = \n    RECT (tailrec_body \n      (\\<lambda>s. do {ASSERT (I s); ASSUME (c s); f s}) \n      (\\<lambda>s. do {ASSERT (I s); ASSUME (\\<not>c s); RETURN s})\n    )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. WHILE\\<^sub>T\\<^bsup>I\\<^esup> c f =\n    REC\\<^sub>T\n     (tailrec_body\n       (\\<lambda>s.\n           ASSERT (I s) \\<bind>\n           (\\<lambda>_. ASSUME (c s) \\<bind> (\\<lambda>_. f s)))\n       (\\<lambda>s.\n           ASSERT (I s) \\<bind>\n           (\\<lambda>_.\n               ASSUME (\\<not> c s) \\<bind> (\\<lambda>_. RETURN s))))", "unfolding WHILEIT_def WHILEI_body_def tailrec_body_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. REC\\<^sub>T\n     (\\<lambda>W s.\n         if I s then if c s then f s \\<bind> W else RETURN s else FAIL) =\n    REC\\<^sub>T\n     (\\<lambda>D s.\n         sup (ASSERT (I s) \\<bind>\n              (\\<lambda>_. ASSUME (c s) \\<bind> (\\<lambda>_. f s)) \\<bind>\n              D)\n          (ASSERT (I s) \\<bind>\n           (\\<lambda>_.\n               ASSUME (\\<not> c s) \\<bind> (\\<lambda>_. RETURN s))))", "apply (fo_rule fun_cong arg_cong)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>W s.\n        if I s then if c s then f s \\<bind> W else RETURN s else FAIL) =\n    (\\<lambda>D s.\n        sup (ASSERT (I s) \\<bind>\n             (\\<lambda>_. ASSUME (c s) \\<bind> (\\<lambda>_. f s)) \\<bind>\n             D)\n         (ASSERT (I s) \\<bind>\n          (\\<lambda>_. ASSUME (\\<not> c s) \\<bind> (\\<lambda>_. RETURN s))))", "apply (intro ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>W s.\n       (if I s then if c s then f s \\<bind> W else RETURN s else FAIL) =\n       sup (ASSERT (I s) \\<bind>\n            (\\<lambda>_. ASSUME (c s) \\<bind> (\\<lambda>_. f s)) \\<bind>\n            W)\n        (ASSERT (I s) \\<bind>\n         (\\<lambda>_. ASSUME (\\<not> c s) \\<bind> (\\<lambda>_. RETURN s)))", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "definition \"WHILEI_lfp_body I m c f \\<equiv> \n    (\\<lambda>x. sup m (do {\n       s \\<leftarrow> x;\n       _ \\<leftarrow> ASSERT (I s);\n       _ \\<leftarrow> ASSUME (c s);\n       f s\n     }))\""], ["", "lemma WHILEI_lfp_conv: \"m \\<bind> WHILEI I c f = \n    do { \n      s \\<leftarrow> lfp (WHILEI_lfp_body I m c f); \n      ASSERT (I s); \n      ASSUME (\\<not>c s); \n      RETURN s \n    }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<bind> WHILE\\<^bsup>I\\<^esup> c f =\n    lfp (WHILEI_lfp_body I m c f) \\<bind>\n    (\\<lambda>s.\n        ASSERT (I s) \\<bind>\n        (\\<lambda>_. ASSUME (\\<not> c s) \\<bind> (\\<lambda>_. RETURN s)))", "unfolding WHILEI_lfp_body_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<bind> WHILE\\<^bsup>I\\<^esup> c f =\n    lfp (\\<lambda>x.\n            sup m\n             (x \\<bind>\n              (\\<lambda>s.\n                  ASSERT (I s) \\<bind>\n                  (\\<lambda>_.\n                      ASSUME (c s) \\<bind> (\\<lambda>_. f s))))) \\<bind>\n    (\\<lambda>s.\n        ASSERT (I s) \\<bind>\n        (\\<lambda>_. ASSUME (\\<not> c s) \\<bind> (\\<lambda>_. RETURN s)))", "apply (subst WHILEI_tailrec_conv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<bind>\n    REC (tailrec_body\n          (\\<lambda>s.\n              ASSERT (I s) \\<bind>\n              (\\<lambda>_. ASSUME (c s) \\<bind> (\\<lambda>_. f s)))\n          (\\<lambda>s.\n              ASSERT (I s) \\<bind>\n              (\\<lambda>_.\n                  ASSUME (\\<not> c s) \\<bind> (\\<lambda>_. RETURN s)))) =\n    lfp (\\<lambda>x.\n            sup m\n             (x \\<bind>\n              (\\<lambda>s.\n                  ASSERT (I s) \\<bind>\n                  (\\<lambda>_.\n                      ASSUME (c s) \\<bind> (\\<lambda>_. f s))))) \\<bind>\n    (\\<lambda>s.\n        ASSERT (I s) \\<bind>\n        (\\<lambda>_. ASSUME (\\<not> c s) \\<bind> (\\<lambda>_. RETURN s)))", "apply (subst tailrec_transform')"], ["proof (prove)\ngoal (1 subgoal):\n 1. lfp (\\<lambda>x.\n            sup m\n             (x \\<bind>\n              (\\<lambda>s.\n                  ASSERT (I s) \\<bind>\n                  (\\<lambda>_.\n                      ASSUME (c s) \\<bind> (\\<lambda>_. f s))))) \\<bind>\n    (\\<lambda>s.\n        ASSERT (I s) \\<bind>\n        (\\<lambda>_. ASSUME (\\<not> c s) \\<bind> (\\<lambda>_. RETURN s))) =\n    lfp (\\<lambda>x.\n            sup m\n             (x \\<bind>\n              (\\<lambda>s.\n                  ASSERT (I s) \\<bind>\n                  (\\<lambda>_.\n                      ASSUME (c s) \\<bind> (\\<lambda>_. f s))))) \\<bind>\n    (\\<lambda>s.\n        ASSERT (I s) \\<bind>\n        (\\<lambda>_. ASSUME (\\<not> c s) \\<bind> (\\<lambda>_. RETURN s)))", ".."], ["", "end"], ["", "subsubsection \\<open>Most Specific Invariant\\<close>"], ["", "definition msii \\<comment> \\<open>Most specific invariant for WHILE-loop\\<close>\n  where \"msii I m c f \\<equiv> lfp (WHILEI_lfp_body I m c f)\""], ["", "lemma [simp, intro!]: \"mono (WHILEI_lfp_body I m c f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono (WHILEI_lfp_body I m c f)", "unfolding WHILEI_lfp_body_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. mono\n     (\\<lambda>x.\n         sup m\n          (x \\<bind>\n           (\\<lambda>s.\n               ASSERT (I s) \\<bind>\n               (\\<lambda>_. ASSUME (c s) \\<bind> (\\<lambda>_. f s)))))", "by tagged_solver"], ["", "definition \"filter_ASSUME c m \\<equiv> do {x\\<leftarrow>m; ASSUME (c x); RETURN x}\""], ["", "definition \"filter_ASSERT c m \\<equiv> do {x\\<leftarrow>m; ASSERT (c x); RETURN x}\""], ["", "lemma [refine_pw_simps]: \"nofail (filter_ASSUME c m) \\<longleftrightarrow> nofail m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nofail (filter_ASSUME c m) = nofail m", "unfolding filter_ASSUME_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. nofail\n     (m \\<bind> (\\<lambda>x. ASSUME (c x) \\<bind> (\\<lambda>_. RETURN x))) =\n    nofail m", "by (simp add: refine_pw_simps)"], ["", "lemma [refine_pw_simps]: \"inres (filter_ASSUME c m) x \n  \\<longleftrightarrow> (nofail m \\<longrightarrow> inres m x \\<and> c x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inres (filter_ASSUME c m) x =\n    (nofail m \\<longrightarrow> inres m x \\<and> c x)", "unfolding filter_ASSUME_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. inres\n     (m \\<bind> (\\<lambda>x. ASSUME (c x) \\<bind> (\\<lambda>_. RETURN x)))\n     x =\n    (nofail m \\<longrightarrow> inres m x \\<and> c x)", "by (simp add: refine_pw_simps)"], ["", "lemma msii_is_invar:\n  \"m \\<le> msii I m c f\"\n  \"m \\<le> msii I m c f \\<Longrightarrow> bind (filter_ASSUME c (filter_ASSERT I m)) f \\<le> msii I m c f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<le> msii I m c f &&&\n    (m \\<le> msii I m c f \\<Longrightarrow>\n     filter_ASSUME c (filter_ASSERT I m) \\<bind> f \\<le> msii I m c f)", "unfolding  msii_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<le> lfp (WHILEI_lfp_body I m c f) &&&\n    (m \\<le> lfp (WHILEI_lfp_body I m c f) \\<Longrightarrow>\n     filter_ASSUME c (filter_ASSERT I m) \\<bind> f\n     \\<le> lfp (WHILEI_lfp_body I m c f))", "apply -"], ["proof (prove)\ngoal (2 subgoals):\n 1. m \\<le> lfp (WHILEI_lfp_body I m c f)\n 2. m \\<le> lfp (WHILEI_lfp_body I m c f) \\<Longrightarrow>\n    filter_ASSUME c (filter_ASSERT I m) \\<bind> f\n    \\<le> lfp (WHILEI_lfp_body I m c f)", "apply (subst lfp_unfold, simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. m \\<le> WHILEI_lfp_body I m c f (lfp (WHILEI_lfp_body I m c f))\n 2. m \\<le> lfp (WHILEI_lfp_body I m c f) \\<Longrightarrow>\n    filter_ASSUME c (filter_ASSERT I m) \\<bind> f\n    \\<le> lfp (WHILEI_lfp_body I m c f)", "apply (simp add: WHILEI_lfp_body_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<le> lfp (WHILEI_lfp_body I m c f) \\<Longrightarrow>\n    filter_ASSUME c (filter_ASSERT I m) \\<bind> f\n    \\<le> lfp (WHILEI_lfp_body I m c f)", "unfolding filter_ASSUME_def filter_ASSERT_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<le> lfp (WHILEI_lfp_body I m c f) \\<Longrightarrow>\n    m \\<bind>\n    (\\<lambda>x. ASSERT (I x) \\<bind> (\\<lambda>_. RETURN x)) \\<bind>\n    (\\<lambda>x. ASSUME (c x) \\<bind> (\\<lambda>_. RETURN x)) \\<bind>\n    f\n    \\<le> lfp (WHILEI_lfp_body I m c f)", "apply (subst lfp_unfold, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<le> lfp (WHILEI_lfp_body I m c f) \\<Longrightarrow>\n    m \\<bind>\n    (\\<lambda>x. ASSERT (I x) \\<bind> (\\<lambda>_. RETURN x)) \\<bind>\n    (\\<lambda>x. ASSUME (c x) \\<bind> (\\<lambda>_. RETURN x)) \\<bind>\n    f\n    \\<le> WHILEI_lfp_body I m c f (lfp (WHILEI_lfp_body I m c f))", "apply (simp add: WHILEI_lfp_body_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<le> lfp (\\<lambda>x.\n                    sup m\n                     (x \\<bind>\n                      (\\<lambda>s.\n                          ASSERT (I s) \\<bind>\n                          (\\<lambda>_.\n                              ASSUME (c s) \\<bind>\n                              (\\<lambda>_. f s))))) \\<Longrightarrow>\n    m \\<bind>\n    (\\<lambda>x.\n        ASSERT (I x) \\<bind>\n        (\\<lambda>xa. ASSUME (c x) \\<bind> (\\<lambda>xa. f x)))\n    \\<le> sup m\n           (lfp (\\<lambda>x.\n                    sup m\n                     (x \\<bind>\n                      (\\<lambda>s.\n                          ASSERT (I s) \\<bind>\n                          (\\<lambda>_.\n                              ASSUME (c s) \\<bind>\n                              (\\<lambda>_. f s))))) \\<bind>\n            (\\<lambda>s.\n                ASSERT (I s) \\<bind>\n                (\\<lambda>_. ASSUME (c s) \\<bind> (\\<lambda>_. f s))))", "apply (simp only: refine_pw_simps pw_le_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. nofail\n     (lfp (\\<lambda>x.\n              sup m\n               (x \\<bind>\n                (\\<lambda>s.\n                    ASSERT (I s) \\<bind>\n                    (\\<lambda>_.\n                        ASSUME (c s) \\<bind>\n                        (\\<lambda>_. f s)))))) \\<longrightarrow>\n    nofail m \\<and>\n    (\\<forall>x.\n        inres m x \\<longrightarrow>\n        inres\n         (lfp (\\<lambda>x.\n                  sup m\n                   (x \\<bind>\n                    (\\<lambda>s.\n                        ASSERT (I s) \\<bind>\n                        (\\<lambda>_.\n                            ASSUME (c s) \\<bind> (\\<lambda>_. f s))))))\n         x) \\<Longrightarrow>\n    nofail m \\<and>\n    nofail\n     (lfp (\\<lambda>x.\n              sup m\n               (x \\<bind>\n                (\\<lambda>s.\n                    ASSERT (I s) \\<bind>\n                    (\\<lambda>_.\n                        ASSUME (c s) \\<bind> (\\<lambda>_. f s)))))) \\<and>\n    (\\<forall>x.\n        inres\n         (lfp (\\<lambda>x.\n                  sup m\n                   (x \\<bind>\n                    (\\<lambda>s.\n                        ASSERT (I s) \\<bind>\n                        (\\<lambda>_.\n                            ASSUME (c s) \\<bind> (\\<lambda>_. f s))))))\n         x \\<longrightarrow>\n        I x \\<and>\n        (\\<forall>xa.\n            True \\<longrightarrow>\n            True \\<and>\n            (\\<forall>xa.\n                c x \\<longrightarrow> nofail (f x)))) \\<longrightarrow>\n    (nofail m \\<and>\n     (\\<forall>x.\n         inres m x \\<longrightarrow>\n         I x \\<and>\n         (\\<forall>xa.\n             True \\<longrightarrow>\n             True \\<and>\n             (\\<forall>xa. c x \\<longrightarrow> nofail (f x))))) \\<and>\n    (\\<forall>x.\n        (nofail m \\<longrightarrow>\n         (\\<exists>y.\n             inres m y \\<and>\n             (I y \\<longrightarrow>\n              (\\<exists>ya.\n                  True \\<and>\n                  (True \\<longrightarrow>\n                   (\\<exists>ya.\n                       c y \\<and> inres (f y) x)))))) \\<longrightarrow>\n        inres m x \\<or>\n        (nofail\n          (lfp (\\<lambda>x.\n                   sup m\n                    (x \\<bind>\n                     (\\<lambda>s.\n                         ASSERT (I s) \\<bind>\n                         (\\<lambda>_.\n                             ASSUME (c s) \\<bind>\n                             (\\<lambda>_. f s)))))) \\<longrightarrow>\n         (\\<exists>y.\n             inres\n              (lfp (\\<lambda>x.\n                       sup m\n                        (x \\<bind>\n                         (\\<lambda>s.\n                             ASSERT (I s) \\<bind>\n                             (\\<lambda>_.\n                                 ASSUME (c s) \\<bind> (\\<lambda>_. f s))))))\n              y \\<and>\n             (I y \\<longrightarrow>\n              (\\<exists>ya.\n                  True \\<and>\n                  (True \\<longrightarrow>\n                   (\\<exists>ya. c y \\<and> inres (f y) x)))))))", "apply blast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma WHILE_msii_conv: \"m \\<bind> WHILEI I c f \n  = filter_ASSUME (Not o c) (filter_ASSERT I (msii I m c f))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<bind> WHILE\\<^bsup>I\\<^esup> c f =\n    filter_ASSUME (Not \\<circ> c) (filter_ASSERT I (msii I m c f))", "unfolding WHILEI_lfp_conv filter_ASSERT_def filter_ASSUME_def msii_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. lfp (WHILEI_lfp_body I m c f) \\<bind>\n    (\\<lambda>s.\n        ASSERT (I s) \\<bind>\n        (\\<lambda>_. ASSUME (\\<not> c s) \\<bind> (\\<lambda>_. RETURN s))) =\n    lfp (WHILEI_lfp_body I m c f) \\<bind>\n    (\\<lambda>x. ASSERT (I x) \\<bind> (\\<lambda>_. RETURN x)) \\<bind>\n    (\\<lambda>x. ASSUME ((Not \\<circ> c) x) \\<bind> (\\<lambda>_. RETURN x))", "by simp"], ["", "lemma msii_induct: \n  assumes I0: \"m0 \\<le> P\"\n  assumes IS: \"\\<And>m. \\<lbrakk>m \\<le> msii I m0 c f; m \\<le> P;\n    filter_ASSUME c (filter_ASSERT I m) \\<bind> f \\<le> msii I m0 c f\n      \\<rbrakk> \\<Longrightarrow> filter_ASSUME c (filter_ASSERT I m) \\<bind> f \\<le> P\"\n  shows \"msii I m0 c f \\<le> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. msii I m0 c f \\<le> P", "unfolding msii_def WHILEI_lfp_body_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. lfp (\\<lambda>x.\n            sup m0\n             (x \\<bind>\n              (\\<lambda>s.\n                  ASSERT (I s) \\<bind>\n                  (\\<lambda>_. ASSUME (c s) \\<bind> (\\<lambda>_. f s)))))\n    \\<le> P", "apply (rule lfp_gen_induct, tagged_solver)"], ["proof (prove)\ngoal (2 subgoals):\n 1. m0 \\<le> P\n 2. \\<And>m.\n       \\<lbrakk>m \\<le> lfp (\\<lambda>x.\n                                sup m0\n                                 (x \\<bind>\n                                  (\\<lambda>s.\nASSERT (I s) \\<bind>\n(\\<lambda>_. ASSUME (c s) \\<bind> (\\<lambda>_. f s)))));\n        m \\<le> P;\n        m \\<bind>\n        (\\<lambda>s.\n            ASSERT (I s) \\<bind>\n            (\\<lambda>_. ASSUME (c s) \\<bind> (\\<lambda>_. f s)))\n        \\<le> lfp (\\<lambda>x.\n                      sup m0\n                       (x \\<bind>\n                        (\\<lambda>s.\n                            ASSERT (I s) \\<bind>\n                            (\\<lambda>_.\n                                ASSUME (c s) \\<bind>\n                                (\\<lambda>_. f s)))))\\<rbrakk>\n       \\<Longrightarrow> m \\<bind>\n                         (\\<lambda>s.\n                             ASSERT (I s) \\<bind>\n                             (\\<lambda>_.\n                                 ASSUME (c s) \\<bind> (\\<lambda>_. f s)))\n                         \\<le> P", "unfolding msii_def[symmetric] WHILEI_lfp_body_def[symmetric]"], ["proof (prove)\ngoal (2 subgoals):\n 1. m0 \\<le> P\n 2. \\<And>m.\n       \\<lbrakk>m \\<le> msii I m0 c f; m \\<le> P;\n        m \\<bind>\n        (\\<lambda>s.\n            ASSERT (I s) \\<bind>\n            (\\<lambda>_. ASSUME (c s) \\<bind> (\\<lambda>_. f s)))\n        \\<le> msii I m0 c f\\<rbrakk>\n       \\<Longrightarrow> m \\<bind>\n                         (\\<lambda>s.\n                             ASSERT (I s) \\<bind>\n                             (\\<lambda>_.\n                                 ASSUME (c s) \\<bind> (\\<lambda>_. f s)))\n                         \\<le> P", "apply (rule I0)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m.\n       \\<lbrakk>m \\<le> msii I m0 c f; m \\<le> P;\n        m \\<bind>\n        (\\<lambda>s.\n            ASSERT (I s) \\<bind>\n            (\\<lambda>_. ASSUME (c s) \\<bind> (\\<lambda>_. f s)))\n        \\<le> msii I m0 c f\\<rbrakk>\n       \\<Longrightarrow> m \\<bind>\n                         (\\<lambda>s.\n                             ASSERT (I s) \\<bind>\n                             (\\<lambda>_.\n                                 ASSUME (c s) \\<bind> (\\<lambda>_. f s)))\n                         \\<le> P", "apply (drule IS, assumption)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>m.\n       \\<lbrakk>m \\<le> P;\n        m \\<bind>\n        (\\<lambda>s.\n            ASSERT (I s) \\<bind>\n            (\\<lambda>_. ASSUME (c s) \\<bind> (\\<lambda>_. f s)))\n        \\<le> msii I m0 c f\\<rbrakk>\n       \\<Longrightarrow> filter_ASSUME c (filter_ASSERT I m) \\<bind> f\n                         \\<le> msii I m0 c f\n 2. \\<And>m.\n       \\<lbrakk>m \\<le> P;\n        m \\<bind>\n        (\\<lambda>s.\n            ASSERT (I s) \\<bind>\n            (\\<lambda>_. ASSUME (c s) \\<bind> (\\<lambda>_. f s)))\n        \\<le> msii I m0 c f;\n        filter_ASSUME c (filter_ASSERT I m) \\<bind> f \\<le> P\\<rbrakk>\n       \\<Longrightarrow> m \\<bind>\n                         (\\<lambda>s.\n                             ASSERT (I s) \\<bind>\n                             (\\<lambda>_.\n                                 ASSUME (c s) \\<bind> (\\<lambda>_. f s)))\n                         \\<le> P", "unfolding filter_ASSERT_def filter_ASSUME_def"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>m.\n       \\<lbrakk>m \\<le> P;\n        m \\<bind>\n        (\\<lambda>s.\n            ASSERT (I s) \\<bind>\n            (\\<lambda>_. ASSUME (c s) \\<bind> (\\<lambda>_. f s)))\n        \\<le> msii I m0 c f\\<rbrakk>\n       \\<Longrightarrow> m \\<bind>\n                         (\\<lambda>x.\n                             ASSERT (I x) \\<bind>\n                             (\\<lambda>_. RETURN x)) \\<bind>\n                         (\\<lambda>x.\n                             ASSUME (c x) \\<bind>\n                             (\\<lambda>_. RETURN x)) \\<bind>\n                         f\n                         \\<le> msii I m0 c f\n 2. \\<And>m.\n       \\<lbrakk>m \\<le> P;\n        m \\<bind>\n        (\\<lambda>s.\n            ASSERT (I s) \\<bind>\n            (\\<lambda>_. ASSUME (c s) \\<bind> (\\<lambda>_. f s)))\n        \\<le> msii I m0 c f;\n        m \\<bind>\n        (\\<lambda>x. ASSERT (I x) \\<bind> (\\<lambda>_. RETURN x)) \\<bind>\n        (\\<lambda>x. ASSUME (c x) \\<bind> (\\<lambda>_. RETURN x)) \\<bind>\n        f\n        \\<le> P\\<rbrakk>\n       \\<Longrightarrow> m \\<bind>\n                         (\\<lambda>s.\n                             ASSERT (I s) \\<bind>\n                             (\\<lambda>_.\n                                 ASSUME (c s) \\<bind> (\\<lambda>_. f s)))\n                         \\<le> P", "apply simp_all"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsubsection \\<open>Reachable without fail\\<close>"], ["", "text \\<open>Reachable states in a while loop, ignoring failing states\\<close>"], ["", "(* (R)eachable states (w)ith(o)ut (f)ail. All non-fail states reachable\n    in a while-loop. *)"], ["", "inductive rwof :: \"'a nres \\<Rightarrow> ('a \\<Rightarrow> bool) \\<Rightarrow> ('a \\<Rightarrow> 'a nres) \\<Rightarrow> 'a \\<Rightarrow> bool\"\n    for m0 cond step \n    where\n      init: \"\\<lbrakk> m0=RES X; x\\<in>X \\<rbrakk> \\<Longrightarrow> rwof m0 cond step x\"\n    | step: \"\\<lbrakk> rwof m0 cond step x; cond x; step x = RES Y; y\\<in>Y \\<rbrakk> \n      \\<Longrightarrow> rwof m0 cond step y\""], ["", "(* This lemma establishes consequences of rwof as invariants. *)"], ["", "lemma establish_rwof_invar:\n    assumes I: \"m0 \\<le>\\<^sub>n SPEC I\"\n    assumes S: \"\\<And>s. \\<lbrakk> rwof m0 cond step s; I s; cond s \\<rbrakk> \n      \\<Longrightarrow> step s \\<le>\\<^sub>n SPEC I\"\n    assumes \"rwof m0 cond step s\"\n    shows \"I s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. I s", "using assms(3)"], ["proof (prove)\nusing this:\n  rwof m0 cond step s\n\ngoal (1 subgoal):\n 1. I s", "apply induct"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>X x. \\<lbrakk>m0 = RES X; x \\<in> X\\<rbrakk> \\<Longrightarrow> I x\n 2. \\<And>x Y y.\n       \\<lbrakk>rwof m0 cond step x; I x; cond x; step x = RES Y;\n        y \\<in> Y\\<rbrakk>\n       \\<Longrightarrow> I y", "using I"], ["proof (prove)\nusing this:\n  m0 \\<le>\\<^sub>n SPEC I\n\ngoal (2 subgoals):\n 1. \\<And>X x. \\<lbrakk>m0 = RES X; x \\<in> X\\<rbrakk> \\<Longrightarrow> I x\n 2. \\<And>x Y y.\n       \\<lbrakk>rwof m0 cond step x; I x; cond x; step x = RES Y;\n        y \\<in> Y\\<rbrakk>\n       \\<Longrightarrow> I y", "apply auto []"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x Y y.\n       \\<lbrakk>rwof m0 cond step x; I x; cond x; step x = RES Y;\n        y \\<in> Y\\<rbrakk>\n       \\<Longrightarrow> I y", "using S"], ["proof (prove)\nusing this:\n  \\<lbrakk>rwof m0 cond step ?s; I ?s; cond ?s\\<rbrakk>\n  \\<Longrightarrow> step ?s \\<le>\\<^sub>n SPEC I\n\ngoal (1 subgoal):\n 1. \\<And>x Y y.\n       \\<lbrakk>rwof m0 cond step x; I x; cond x; step x = RES Y;\n        y \\<in> Y\\<rbrakk>\n       \\<Longrightarrow> I y", "apply fastforce []"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(* Predicate to express an rwof-invariant *)"], ["", "definition \"is_rwof_invar m0 cond step I \\<equiv> \n      (m0 \\<le>\\<^sub>n SPEC I)\n    \\<and> (\\<forall>s. rwof m0 cond step s \\<and> I s \\<and> cond s \n        \\<longrightarrow> step s \\<le>\\<^sub>n SPEC I )\""], ["", "lemma is_rwof_invarI[intro?]:\n    assumes I: \"m0 \\<le>\\<^sub>n SPEC I\"\n    assumes S: \"\\<And>s. \\<lbrakk> rwof m0 cond step s; I s; cond s \\<rbrakk> \n      \\<Longrightarrow> step s \\<le>\\<^sub>n SPEC I\"\n    shows \"is_rwof_invar m0 cond step I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_rwof_invar m0 cond step I", "using assms"], ["proof (prove)\nusing this:\n  m0 \\<le>\\<^sub>n SPEC I\n  \\<lbrakk>rwof m0 cond step ?s; I ?s; cond ?s\\<rbrakk>\n  \\<Longrightarrow> step ?s \\<le>\\<^sub>n SPEC I\n\ngoal (1 subgoal):\n 1. is_rwof_invar m0 cond step I", "unfolding is_rwof_invar_def"], ["proof (prove)\nusing this:\n  m0 \\<le>\\<^sub>n SPEC I\n  \\<lbrakk>rwof m0 cond step ?s; I ?s; cond ?s\\<rbrakk>\n  \\<Longrightarrow> step ?s \\<le>\\<^sub>n SPEC I\n\ngoal (1 subgoal):\n 1. m0 \\<le>\\<^sub>n SPEC I \\<and>\n    (\\<forall>s.\n        rwof m0 cond step s \\<and> I s \\<and> cond s \\<longrightarrow>\n        step s \\<le>\\<^sub>n SPEC I)", "by blast"], ["", "lemma rwof_cons: \"\\<lbrakk>is_rwof_invar m0 cond step I; rwof m0 cond step s\\<rbrakk> \\<Longrightarrow> I s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_rwof_invar m0 cond step I; rwof m0 cond step s\\<rbrakk>\n    \\<Longrightarrow> I s", "unfolding is_rwof_invar_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>m0 \\<le>\\<^sub>n SPEC I \\<and>\n             (\\<forall>s.\n                 rwof m0 cond step s \\<and>\n                 I s \\<and> cond s \\<longrightarrow>\n                 step s \\<le>\\<^sub>n SPEC I);\n     rwof m0 cond step s\\<rbrakk>\n    \\<Longrightarrow> I s", "using establish_rwof_invar[of m0 I cond step s]"], ["proof (prove)\nusing this:\n  \\<lbrakk>m0 \\<le>\\<^sub>n SPEC I;\n   \\<And>s.\n      \\<lbrakk>rwof m0 cond step s; I s; cond s\\<rbrakk>\n      \\<Longrightarrow> step s \\<le>\\<^sub>n SPEC I;\n   rwof m0 cond step s\\<rbrakk>\n  \\<Longrightarrow> I s\n\ngoal (1 subgoal):\n 1. \\<lbrakk>m0 \\<le>\\<^sub>n SPEC I \\<and>\n             (\\<forall>s.\n                 rwof m0 cond step s \\<and>\n                 I s \\<and> cond s \\<longrightarrow>\n                 step s \\<le>\\<^sub>n SPEC I);\n     rwof m0 cond step s\\<rbrakk>\n    \\<Longrightarrow> I s", "by blast"], ["", "(* This lemma proves a specification for the while loop, based on rwof\n    and a nofail-proof. *)"], ["", "lemma rwof_WHILE_rule:\n    assumes I0: \"m0 \\<le> SPEC I\"\n    assumes S: \"\\<And>s. \\<lbrakk> rwof m0 cond step s; I s; cond s \\<rbrakk> \\<Longrightarrow> step s \\<le> SPEC I\"\n    shows \"m0 \\<bind> WHILE cond step \\<le> SPEC (\\<lambda>s. rwof m0 cond step s \\<and> \\<not>cond s \\<and> I s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m0 \\<bind> WHILE cond step\n    \\<le> SPEC\n           (\\<lambda>s. rwof m0 cond step s \\<and> \\<not> cond s \\<and> I s)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. m0 \\<bind> WHILE cond step\n    \\<le> SPEC\n           (\\<lambda>s. rwof m0 cond step s \\<and> \\<not> cond s \\<and> I s)", "from I0"], ["proof (chain)\npicking this:\n  m0 \\<le> SPEC I", "obtain M0 where [simp]: \"m0 = RES M0\" and \"M0 \\<subseteq> Collect I\""], ["proof (prove)\nusing this:\n  m0 \\<le> SPEC I\n\ngoal (1 subgoal):\n 1. (\\<And>M0.\n        \\<lbrakk>m0 = RES M0; M0 \\<subseteq> Collect I\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases m0) auto"], ["proof (state)\nthis:\n  m0 = RES M0\n  M0 \\<subseteq> Collect I\n\ngoal (1 subgoal):\n 1. m0 \\<bind> WHILE cond step\n    \\<le> SPEC\n           (\\<lambda>s. rwof m0 cond step s \\<and> \\<not> cond s \\<and> I s)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. m0 \\<bind> WHILE cond step\n    \\<le> SPEC\n           (\\<lambda>s. rwof m0 cond step s \\<and> \\<not> cond s \\<and> I s)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. RES M0 \\<bind> WHILE cond step\n    \\<le> SPEC\n           (\\<lambda>s.\n               rwof (RES M0) cond step s \\<and> \\<not> cond s \\<and> I s)", "apply refine_vcg"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> M0 \\<Longrightarrow>\n       WHILE cond step x\n       \\<le> SPEC\n              (\\<lambda>s.\n                  rwof (RES M0) cond step s \\<and> \\<not> cond s \\<and> I s)", "apply (rule WHILE_rule[where I=\"\\<lambda>s. I s \\<and> rwof m0 cond step s\"])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x. x \\<in> M0 \\<Longrightarrow> I x \\<and> rwof m0 cond step x\n 2. \\<And>x s.\n       \\<lbrakk>x \\<in> M0; I s \\<and> rwof m0 cond step s; cond s\\<rbrakk>\n       \\<Longrightarrow> step s\n                         \\<le> SPEC\n                                (\\<lambda>s. I s \\<and> rwof m0 cond step s)\n 3. \\<And>x s.\n       \\<lbrakk>x \\<in> M0; I s \\<and> rwof m0 cond step s;\n        \\<not> cond s\\<rbrakk>\n       \\<Longrightarrow> rwof (RES M0) cond step s \\<and>\n                         \\<not> cond s \\<and> I s", "proof -"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x. x \\<in> M0 \\<Longrightarrow> I x \\<and> rwof m0 cond step x\n 2. \\<And>x s.\n       \\<lbrakk>x \\<in> M0; I s \\<and> rwof m0 cond step s; cond s\\<rbrakk>\n       \\<Longrightarrow> step s\n                         \\<le> SPEC\n                                (\\<lambda>s. I s \\<and> rwof m0 cond step s)\n 3. \\<And>x s.\n       \\<lbrakk>x \\<in> M0; I s \\<and> rwof m0 cond step s;\n        \\<not> cond s\\<rbrakk>\n       \\<Longrightarrow> rwof (RES M0) cond step s \\<and>\n                         \\<not> cond s \\<and> I s", "fix s"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x. x \\<in> M0 \\<Longrightarrow> I x \\<and> rwof m0 cond step x\n 2. \\<And>x s.\n       \\<lbrakk>x \\<in> M0; I s \\<and> rwof m0 cond step s; cond s\\<rbrakk>\n       \\<Longrightarrow> step s\n                         \\<le> SPEC\n                                (\\<lambda>s. I s \\<and> rwof m0 cond step s)\n 3. \\<And>x s.\n       \\<lbrakk>x \\<in> M0; I s \\<and> rwof m0 cond step s;\n        \\<not> cond s\\<rbrakk>\n       \\<Longrightarrow> rwof (RES M0) cond step s \\<and>\n                         \\<not> cond s \\<and> I s", "assume \"s\\<in>M0\""], ["proof (state)\nthis:\n  s \\<in> M0\n\ngoal (3 subgoals):\n 1. \\<And>x. x \\<in> M0 \\<Longrightarrow> I x \\<and> rwof m0 cond step x\n 2. \\<And>x s.\n       \\<lbrakk>x \\<in> M0; I s \\<and> rwof m0 cond step s; cond s\\<rbrakk>\n       \\<Longrightarrow> step s\n                         \\<le> SPEC\n                                (\\<lambda>s. I s \\<and> rwof m0 cond step s)\n 3. \\<And>x s.\n       \\<lbrakk>x \\<in> M0; I s \\<and> rwof m0 cond step s;\n        \\<not> cond s\\<rbrakk>\n       \\<Longrightarrow> rwof (RES M0) cond step s \\<and>\n                         \\<not> cond s \\<and> I s", "thus \"I s \\<and> rwof m0 cond step s\""], ["proof (prove)\nusing this:\n  s \\<in> M0\n\ngoal (1 subgoal):\n 1. I s \\<and> rwof m0 cond step s", "using I0"], ["proof (prove)\nusing this:\n  s \\<in> M0\n  m0 \\<le> SPEC I\n\ngoal (1 subgoal):\n 1. I s \\<and> rwof m0 cond step s", "by (auto intro: rwof.init) []"], ["proof (state)\nthis:\n  I s \\<and> rwof m0 cond step s\n\ngoal (2 subgoals):\n 1. \\<And>x s.\n       \\<lbrakk>x \\<in> M0; I s \\<and> rwof m0 cond step s; cond s\\<rbrakk>\n       \\<Longrightarrow> step s\n                         \\<le> SPEC\n                                (\\<lambda>s. I s \\<and> rwof m0 cond step s)\n 2. \\<And>x s.\n       \\<lbrakk>x \\<in> M0; I s \\<and> rwof m0 cond step s;\n        \\<not> cond s\\<rbrakk>\n       \\<Longrightarrow> rwof (RES M0) cond step s \\<and>\n                         \\<not> cond s \\<and> I s", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x s.\n       \\<lbrakk>x \\<in> M0; I s \\<and> rwof m0 cond step s; cond s\\<rbrakk>\n       \\<Longrightarrow> step s\n                         \\<le> SPEC\n                                (\\<lambda>s. I s \\<and> rwof m0 cond step s)\n 2. \\<And>x s.\n       \\<lbrakk>x \\<in> M0; I s \\<and> rwof m0 cond step s;\n        \\<not> cond s\\<rbrakk>\n       \\<Longrightarrow> rwof (RES M0) cond step s \\<and>\n                         \\<not> cond s \\<and> I s", "fix s"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x s.\n       \\<lbrakk>x \\<in> M0; I s \\<and> rwof m0 cond step s; cond s\\<rbrakk>\n       \\<Longrightarrow> step s\n                         \\<le> SPEC\n                                (\\<lambda>s. I s \\<and> rwof m0 cond step s)\n 2. \\<And>x s.\n       \\<lbrakk>x \\<in> M0; I s \\<and> rwof m0 cond step s;\n        \\<not> cond s\\<rbrakk>\n       \\<Longrightarrow> rwof (RES M0) cond step s \\<and>\n                         \\<not> cond s \\<and> I s", "assume A: \"I s \\<and> rwof m0 cond step s\" and C: \"cond s\""], ["proof (state)\nthis:\n  I s \\<and> rwof m0 cond step s\n  cond s\n\ngoal (2 subgoals):\n 1. \\<And>x s.\n       \\<lbrakk>x \\<in> M0; I s \\<and> rwof m0 cond step s; cond s\\<rbrakk>\n       \\<Longrightarrow> step s\n                         \\<le> SPEC\n                                (\\<lambda>s. I s \\<and> rwof m0 cond step s)\n 2. \\<And>x s.\n       \\<lbrakk>x \\<in> M0; I s \\<and> rwof m0 cond step s;\n        \\<not> cond s\\<rbrakk>\n       \\<Longrightarrow> rwof (RES M0) cond step s \\<and>\n                         \\<not> cond s \\<and> I s", "hence \"step s \\<le> SPEC I\""], ["proof (prove)\nusing this:\n  I s \\<and> rwof m0 cond step s\n  cond s\n\ngoal (1 subgoal):\n 1. step s \\<le> SPEC I", "by - (rule S, simp_all)"], ["proof (state)\nthis:\n  step s \\<le> SPEC I\n\ngoal (2 subgoals):\n 1. \\<And>x s.\n       \\<lbrakk>x \\<in> M0; I s \\<and> rwof m0 cond step s; cond s\\<rbrakk>\n       \\<Longrightarrow> step s\n                         \\<le> SPEC\n                                (\\<lambda>s. I s \\<and> rwof m0 cond step s)\n 2. \\<And>x s.\n       \\<lbrakk>x \\<in> M0; I s \\<and> rwof m0 cond step s;\n        \\<not> cond s\\<rbrakk>\n       \\<Longrightarrow> rwof (RES M0) cond step s \\<and>\n                         \\<not> cond s \\<and> I s", "also"], ["proof (state)\nthis:\n  step s \\<le> SPEC I\n\ngoal (2 subgoals):\n 1. \\<And>x s.\n       \\<lbrakk>x \\<in> M0; I s \\<and> rwof m0 cond step s; cond s\\<rbrakk>\n       \\<Longrightarrow> step s\n                         \\<le> SPEC\n                                (\\<lambda>s. I s \\<and> rwof m0 cond step s)\n 2. \\<And>x s.\n       \\<lbrakk>x \\<in> M0; I s \\<and> rwof m0 cond step s;\n        \\<not> cond s\\<rbrakk>\n       \\<Longrightarrow> rwof (RES M0) cond step s \\<and>\n                         \\<not> cond s \\<and> I s", "then"], ["proof (chain)\npicking this:\n  step s \\<le> SPEC I", "obtain S' where \"step s = RES S'\""], ["proof (prove)\nusing this:\n  step s \\<le> SPEC I\n\ngoal (1 subgoal):\n 1. (\\<And>S'. step s = RES S' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases \"step s\") auto"], ["proof (state)\nthis:\n  step s = RES S'\n\ngoal (2 subgoals):\n 1. \\<And>x s.\n       \\<lbrakk>x \\<in> M0; I s \\<and> rwof m0 cond step s; cond s\\<rbrakk>\n       \\<Longrightarrow> step s\n                         \\<le> SPEC\n                                (\\<lambda>s. I s \\<and> rwof m0 cond step s)\n 2. \\<And>x s.\n       \\<lbrakk>x \\<in> M0; I s \\<and> rwof m0 cond step s;\n        \\<not> cond s\\<rbrakk>\n       \\<Longrightarrow> rwof (RES M0) cond step s \\<and>\n                         \\<not> cond s \\<and> I s", "from rwof.step[OF conjunct2[OF A] C this] this"], ["proof (chain)\npicking this:\n  ?y \\<in> S' \\<Longrightarrow> rwof m0 cond step ?y\n  step s = RES S'", "have \"step s \\<le> SPEC (rwof m0 cond step)\""], ["proof (prove)\nusing this:\n  ?y \\<in> S' \\<Longrightarrow> rwof m0 cond step ?y\n  step s = RES S'\n\ngoal (1 subgoal):\n 1. step s \\<le> SPEC (rwof m0 cond step)", "by auto"], ["proof (state)\nthis:\n  step s \\<le> SPEC (rwof m0 cond step)\n\ngoal (2 subgoals):\n 1. \\<And>x s.\n       \\<lbrakk>x \\<in> M0; I s \\<and> rwof m0 cond step s; cond s\\<rbrakk>\n       \\<Longrightarrow> step s\n                         \\<le> SPEC\n                                (\\<lambda>s. I s \\<and> rwof m0 cond step s)\n 2. \\<And>x s.\n       \\<lbrakk>x \\<in> M0; I s \\<and> rwof m0 cond step s;\n        \\<not> cond s\\<rbrakk>\n       \\<Longrightarrow> rwof (RES M0) cond step s \\<and>\n                         \\<not> cond s \\<and> I s", "finally (SPEC_rule_conjI)"], ["proof (chain)\npicking this:\n  step s \\<le> SPEC (\\<lambda>v. I v \\<and> rwof m0 cond step v)", "show \"step s \\<le> SPEC (\\<lambda>s. I s \\<and> rwof m0 cond step s)\""], ["proof (prove)\nusing this:\n  step s \\<le> SPEC (\\<lambda>v. I v \\<and> rwof m0 cond step v)\n\ngoal (1 subgoal):\n 1. step s \\<le> SPEC (\\<lambda>s. I s \\<and> rwof m0 cond step s)", "."], ["proof (state)\nthis:\n  step s \\<le> SPEC (\\<lambda>s. I s \\<and> rwof m0 cond step s)\n\ngoal (1 subgoal):\n 1. \\<And>x s.\n       \\<lbrakk>x \\<in> M0; I s \\<and> rwof m0 cond step s;\n        \\<not> cond s\\<rbrakk>\n       \\<Longrightarrow> rwof (RES M0) cond step s \\<and>\n                         \\<not> cond s \\<and> I s", "qed auto"], ["proof (state)\nthis:\n  m0 \\<bind> WHILE cond step\n  \\<le> SPEC\n         (\\<lambda>s. rwof m0 cond step s \\<and> \\<not> cond s \\<and> I s)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>Filtering out states that satisfy the loop condition\\<close>"], ["", "(* A shortcut definition for filtering out all results that satisfy\n    the loop condition. Intuitively, filtering out these results from the \n    best invariant gives the results of the while loop. *)"], ["", "definition filter_nb :: \"('a \\<Rightarrow> bool) \\<Rightarrow> 'a nres \\<Rightarrow> 'a nres\" where \n    \"filter_nb b I \\<equiv> do {s\\<leftarrow>I; ASSUME (\\<not>b s); RETURN s}\""], ["", "lemma pw_filter_nb[refine_pw_simps]:\n    \"nofail (filter_nb b I) \\<longleftrightarrow> nofail I\"\n    \"inres (filter_nb b I) x \\<longleftrightarrow> (nofail I \\<longrightarrow> inres I x \\<and> \\<not>b x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nofail (filter_nb b I) = nofail I &&&\n    inres (filter_nb b I) x =\n    (nofail I \\<longrightarrow> inres I x \\<and> \\<not> b x)", "unfolding filter_nb_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. nofail\n     (I \\<bind>\n      (\\<lambda>s. ASSUME (\\<not> b s) \\<bind> (\\<lambda>_. RETURN s))) =\n    nofail I &&&\n    inres\n     (I \\<bind>\n      (\\<lambda>s. ASSUME (\\<not> b s) \\<bind> (\\<lambda>_. RETURN s)))\n     x =\n    (nofail I \\<longrightarrow> inres I x \\<and> \\<not> b x)", "by (simp_all add: refine_pw_simps)"], ["", "lemma filter_nb_mono: \"m\\<le>m' \\<Longrightarrow> filter_nb cond m \\<le> filter_nb cond m'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<le> m' \\<Longrightarrow> filter_nb cond m \\<le> filter_nb cond m'", "unfolding filter_nb_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<le> m' \\<Longrightarrow>\n    m \\<bind>\n    (\\<lambda>s. ASSUME (\\<not> cond s) \\<bind> (\\<lambda>_. RETURN s))\n    \\<le> m' \\<bind>\n          (\\<lambda>s.\n              ASSUME (\\<not> cond s) \\<bind> (\\<lambda>_. RETURN s))", "by refine_mono"], ["", "lemma filter_nb_cont: \n    \"filter_nb cond (Sup M) = Sup {filter_nb cond m | m. m \\<in> M}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filter_nb cond (Sup M) = Sup {filter_nb cond m |m. m \\<in> M}", "apply (rule antisym)"], ["proof (prove)\ngoal (2 subgoals):\n 1. filter_nb cond (Sup M) \\<le> Sup {filter_nb cond m |m. m \\<in> M}\n 2. Sup {filter_nb cond m |m. m \\<in> M} \\<le> filter_nb cond (Sup M)", "apply (simp add: pw_le_iff refine_pw_simps)"], ["proof (prove)\ngoal (2 subgoals):\n 1. (\\<forall>x.\n        (\\<exists>m.\n            x = filter_nb cond m \\<and> m \\<in> M) \\<longrightarrow>\n        nofail x) \\<longrightarrow>\n    (\\<forall>x\\<in>M. nofail x) \\<and>\n    (\\<forall>x.\n        ((\\<forall>x\\<in>M. nofail x) \\<longrightarrow>\n         (\\<exists>M\\<in>M. inres M x) \\<and>\n         \\<not> cond x) \\<longrightarrow>\n        (\\<exists>Ma.\n            (\\<exists>m. Ma = filter_nb cond m \\<and> m \\<in> M) \\<and>\n            inres Ma x))\n 2. Sup {filter_nb cond m |m. m \\<in> M} \\<le> filter_nb cond (Sup M)", "apply (auto intro: not_nofail_inres simp: refine_pw_simps) []"], ["proof (prove)\ngoal (1 subgoal):\n 1. Sup {filter_nb cond m |m. m \\<in> M} \\<le> filter_nb cond (Sup M)", "apply (simp add: pw_le_iff refine_pw_simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x\\<in>M. nofail x) \\<longrightarrow>\n    (\\<forall>x.\n        (\\<exists>m.\n            x = filter_nb cond m \\<and> m \\<in> M) \\<longrightarrow>\n        nofail x) \\<and>\n    (\\<forall>x.\n        (\\<exists>Ma.\n            (\\<exists>m. Ma = filter_nb cond m \\<and> m \\<in> M) \\<and>\n            inres Ma x) \\<longrightarrow>\n        (\\<exists>M\\<in>M. inres M x) \\<and> \\<not> cond x)", "apply (auto intro: not_nofail_inres simp: refine_pw_simps) []"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma filter_nb_FAIL[simp]: \"filter_nb cond FAIL = FAIL\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filter_nb cond FAIL = FAIL", "by (simp add: filter_nb_def)"], ["", "lemma filter_nb_RES[simp]: \"filter_nb cond (RES X) = RES {x\\<in>X. \\<not>cond x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filter_nb cond (RES X) =\n    SPEC (\\<lambda>x. x \\<in> X \\<and> \\<not> cond x)", "by (simp add: pw_eq_iff refine_pw_simps)"], ["", "subsubsection \\<open>Bounded while-loop\\<close>"], ["", "(* A while rule that establishes an inductive invariant,\n    and then filters out the results satisfying the condition. *)"], ["", "lemma WHILE_rule_gen_le:\n    assumes I0: \"m0 \\<le> I\"\n    assumes ISTEP: \"\\<And>s. \\<lbrakk>RETURN s \\<le> I; b s\\<rbrakk> \\<Longrightarrow> f s \\<le> I\"\n    shows \"m0 \\<bind> WHILE b f \\<le> filter_nb b I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m0 \\<bind> WHILE b f \\<le> filter_nb b I", "apply (unfold WHILE_def WHILEI_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. m0 \\<bind> REC (WHILEI_body (\\<bind>) RETURN (\\<lambda>_. True) b f)\n    \\<le> filter_nb b I", "apply (refine_rcg order_trans[OF I0] refine_vcg pw_bind_leI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. nofail (filter_nb b I) \\<Longrightarrow> nofail m0\n 2. \\<And>x.\n       \\<lbrakk>nofail m0; inres m0 x\\<rbrakk>\n       \\<Longrightarrow> REC (WHILEI_body (\\<bind>) RETURN\n                               (\\<lambda>_. True) b f)\n                          x\n                         \\<le> filter_nb b I", "using I0"], ["proof (prove)\nusing this:\n  m0 \\<le> I\n\ngoal (2 subgoals):\n 1. nofail (filter_nb b I) \\<Longrightarrow> nofail m0\n 2. \\<And>x.\n       \\<lbrakk>nofail m0; inres m0 x\\<rbrakk>\n       \\<Longrightarrow> REC (WHILEI_body (\\<bind>) RETURN\n                               (\\<lambda>_. True) b f)\n                          x\n                         \\<le> filter_nb b I", "apply (simp add: pw_le_iff refine_pw_simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>nofail m0; inres m0 x\\<rbrakk>\n       \\<Longrightarrow> REC (WHILEI_body (\\<bind>) RETURN\n                               (\\<lambda>_. True) b f)\n                          x\n                         \\<le> filter_nb b I", "apply (rule REC_rule[OF WHILEI_body_trimono, where pre=\"\\<lambda>s. RETURN s \\<le> I\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>nofail m0; inres m0 x\\<rbrakk>\n       \\<Longrightarrow> RETURN x \\<le> I\n 2. \\<And>x fa xa.\n       \\<lbrakk>nofail m0; inres m0 x;\n        \\<And>x.\n           RETURN x \\<le> I \\<Longrightarrow> fa x \\<le> filter_nb b I;\n        RETURN xa \\<le> I;\n        fa \\<le> REC (WHILEI_body (\\<bind>) RETURN (\\<lambda>a. True) b\n                       f)\\<rbrakk>\n       \\<Longrightarrow> WHILEI_body (\\<bind>) RETURN (\\<lambda>a. True) b f\n                          fa xa\n                         \\<le> filter_nb b I", "using I0"], ["proof (prove)\nusing this:\n  m0 \\<le> I\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>nofail m0; inres m0 x\\<rbrakk>\n       \\<Longrightarrow> RETURN x \\<le> I\n 2. \\<And>x fa xa.\n       \\<lbrakk>nofail m0; inres m0 x;\n        \\<And>x.\n           RETURN x \\<le> I \\<Longrightarrow> fa x \\<le> filter_nb b I;\n        RETURN xa \\<le> I;\n        fa \\<le> REC (WHILEI_body (\\<bind>) RETURN (\\<lambda>a. True) b\n                       f)\\<rbrakk>\n       \\<Longrightarrow> WHILEI_body (\\<bind>) RETURN (\\<lambda>a. True) b f\n                          fa xa\n                         \\<le> filter_nb b I", "apply (simp add: pw_le_iff refine_pw_simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x fa xa.\n       \\<lbrakk>nofail m0; inres m0 x;\n        \\<And>x.\n           RETURN x \\<le> I \\<Longrightarrow> fa x \\<le> filter_nb b I;\n        RETURN xa \\<le> I;\n        fa \\<le> REC (WHILEI_body (\\<bind>) RETURN (\\<lambda>a. True) b\n                       f)\\<rbrakk>\n       \\<Longrightarrow> WHILEI_body (\\<bind>) RETURN (\\<lambda>a. True) b f\n                          fa xa\n                         \\<le> filter_nb b I", "unfolding WHILEI_body_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x fa xa.\n       \\<lbrakk>nofail m0; inres m0 x;\n        \\<And>x.\n           RETURN x \\<le> I \\<Longrightarrow> fa x \\<le> filter_nb b I;\n        RETURN xa \\<le> I;\n        fa \\<le> REC (\\<lambda>W s.\n                         if True\n                         then if b s then f s \\<bind> W else RETURN s\n                         else FAIL)\\<rbrakk>\n       \\<Longrightarrow> (if True\n                          then if b xa then f xa \\<bind> fa else RETURN xa\n                          else FAIL)\n                         \\<le> filter_nb b I", "apply (split if_split)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x fa xa.\n       \\<lbrakk>nofail m0; inres m0 x;\n        \\<And>x.\n           RETURN x \\<le> I \\<Longrightarrow> fa x \\<le> filter_nb b I;\n        RETURN xa \\<le> I;\n        fa \\<le> REC (\\<lambda>W s.\n                         if True\n                         then if b s then f s \\<bind> W else RETURN s\n                         else FAIL)\\<rbrakk>\n       \\<Longrightarrow> (b xa \\<longrightarrow>\n                          (True \\<longrightarrow>\n                           f xa \\<bind> fa \\<le> filter_nb b I) \\<and>\n                          (\\<not> True \\<longrightarrow>\n                           FAIL \\<le> filter_nb b I)) \\<and>\n                         (\\<not> b xa \\<longrightarrow>\n                          (True \\<longrightarrow>\n                           RETURN xa \\<le> filter_nb b I) \\<and>\n                          (\\<not> True \\<longrightarrow>\n                           FAIL \\<le> filter_nb b I))", "apply (intro impI conjI)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x fa xa.\n       \\<lbrakk>nofail m0; inres m0 x;\n        \\<And>x.\n           RETURN x \\<le> I \\<Longrightarrow> fa x \\<le> filter_nb b I;\n        RETURN xa \\<le> I;\n        fa \\<le> REC (\\<lambda>W s.\n                         if True\n                         then if b s then f s \\<bind> W else RETURN s\n                         else FAIL);\n        b xa; True\\<rbrakk>\n       \\<Longrightarrow> f xa \\<bind> fa \\<le> filter_nb b I\n 2. \\<And>x fa xa.\n       \\<lbrakk>nofail m0; inres m0 x;\n        \\<And>x.\n           RETURN x \\<le> I \\<Longrightarrow> fa x \\<le> filter_nb b I;\n        RETURN xa \\<le> I;\n        fa \\<le> REC (\\<lambda>W s.\n                         if True\n                         then if b s then f s \\<bind> W else RETURN s\n                         else FAIL);\n        b xa; \\<not> True\\<rbrakk>\n       \\<Longrightarrow> FAIL \\<le> filter_nb b I\n 3. \\<And>x fa xa.\n       \\<lbrakk>nofail m0; inres m0 x;\n        \\<And>x.\n           RETURN x \\<le> I \\<Longrightarrow> fa x \\<le> filter_nb b I;\n        RETURN xa \\<le> I;\n        fa \\<le> REC (\\<lambda>W s.\n                         if True\n                         then if b s then f s \\<bind> W else RETURN s\n                         else FAIL);\n        \\<not> b xa; True\\<rbrakk>\n       \\<Longrightarrow> RETURN xa \\<le> filter_nb b I\n 4. \\<And>x fa xa.\n       \\<lbrakk>nofail m0; inres m0 x;\n        \\<And>x.\n           RETURN x \\<le> I \\<Longrightarrow> fa x \\<le> filter_nb b I;\n        RETURN xa \\<le> I;\n        fa \\<le> REC (\\<lambda>W s.\n                         if True\n                         then if b s then f s \\<bind> W else RETURN s\n                         else FAIL);\n        \\<not> b xa; \\<not> True\\<rbrakk>\n       \\<Longrightarrow> FAIL \\<le> filter_nb b I", "apply (simp_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x fa xa.\n       \\<lbrakk>nofail m0; inres m0 x;\n        \\<And>x.\n           RETURN x \\<le> I \\<Longrightarrow> fa x \\<le> filter_nb b I;\n        RETURN xa \\<le> I;\n        fa \\<le> REC (\\<lambda>W s.\n                         if b s then f s \\<bind> W else RETURN s);\n        b xa\\<rbrakk>\n       \\<Longrightarrow> f xa \\<bind> fa \\<le> filter_nb b I\n 2. \\<And>x fa xa.\n       \\<lbrakk>nofail m0; inres m0 x;\n        \\<And>x.\n           RETURN x \\<le> I \\<Longrightarrow> fa x \\<le> filter_nb b I;\n        RETURN xa \\<le> I;\n        fa \\<le> REC (\\<lambda>W s.\n                         if b s then f s \\<bind> W else RETURN s);\n        \\<not> b xa\\<rbrakk>\n       \\<Longrightarrow> RETURN xa \\<le> filter_nb b I", "using ISTEP"], ["proof (prove)\nusing this:\n  \\<lbrakk>RETURN ?s \\<le> I; b ?s\\<rbrakk> \\<Longrightarrow> f ?s \\<le> I\n\ngoal (2 subgoals):\n 1. \\<And>x fa xa.\n       \\<lbrakk>nofail m0; inres m0 x;\n        \\<And>x.\n           RETURN x \\<le> I \\<Longrightarrow> fa x \\<le> filter_nb b I;\n        RETURN xa \\<le> I;\n        fa \\<le> REC (\\<lambda>W s.\n                         if b s then f s \\<bind> W else RETURN s);\n        b xa\\<rbrakk>\n       \\<Longrightarrow> f xa \\<bind> fa \\<le> filter_nb b I\n 2. \\<And>x fa xa.\n       \\<lbrakk>nofail m0; inres m0 x;\n        \\<And>x.\n           RETURN x \\<le> I \\<Longrightarrow> fa x \\<le> filter_nb b I;\n        RETURN xa \\<le> I;\n        fa \\<le> REC (\\<lambda>W s.\n                         if b s then f s \\<bind> W else RETURN s);\n        \\<not> b xa\\<rbrakk>\n       \\<Longrightarrow> RETURN xa \\<le> filter_nb b I", "apply (simp (no_asm_use) only: pw_le_iff refine_pw_simps)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x fa xa.\n       \\<lbrakk>nofail m0; inres m0 x;\n        \\<And>x.\n           nofail I \\<longrightarrow>\n           True \\<and>\n           (\\<forall>xa.\n               x = xa \\<longrightarrow> inres I xa) \\<Longrightarrow>\n           nofail I \\<longrightarrow>\n           nofail (fa x) \\<and>\n           (\\<forall>xa.\n               inres (fa x) xa \\<longrightarrow>\n               nofail I \\<longrightarrow> inres I xa \\<and> \\<not> b xa);\n        nofail I \\<longrightarrow>\n        True \\<and> (\\<forall>x. xa = x \\<longrightarrow> inres I x);\n        fa \\<le> REC (\\<lambda>W s.\n                         if b s then f s \\<bind> W else RETURN s);\n        b xa;\n        \\<And>s.\n           \\<lbrakk>nofail I \\<longrightarrow>\n                    True \\<and>\n                    (\\<forall>x. s = x \\<longrightarrow> inres I x);\n            b s\\<rbrakk>\n           \\<Longrightarrow> nofail I \\<longrightarrow>\n                             nofail (f s) \\<and>\n                             (\\<forall>x.\n                                 inres (f s) x \\<longrightarrow>\n                                 inres I x)\\<rbrakk>\n       \\<Longrightarrow> nofail I \\<longrightarrow>\n                         (nofail (f xa) \\<and>\n                          (\\<forall>x.\n                              inres (f xa) x \\<longrightarrow>\n                              nofail (fa x))) \\<and>\n                         (\\<forall>x.\n                             (nofail (f xa) \\<longrightarrow>\n                              (\\<exists>y.\n                                  inres (f xa) y \\<and>\n                                  inres (fa y) x)) \\<longrightarrow>\n                             nofail I \\<longrightarrow>\n                             inres I x \\<and> \\<not> b x)\n 2. \\<And>x fa xa.\n       \\<lbrakk>nofail m0; inres m0 x;\n        \\<And>x.\n           RETURN x \\<le> I \\<Longrightarrow> fa x \\<le> filter_nb b I;\n        RETURN xa \\<le> I;\n        fa \\<le> REC (\\<lambda>W s.\n                         if b s then f s \\<bind> W else RETURN s);\n        \\<not> b xa\\<rbrakk>\n       \\<Longrightarrow> RETURN xa \\<le> filter_nb b I", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x fa xa.\n       \\<lbrakk>nofail m0; inres m0 x;\n        \\<And>x.\n           RETURN x \\<le> I \\<Longrightarrow> fa x \\<le> filter_nb b I;\n        RETURN xa \\<le> I;\n        fa \\<le> REC (\\<lambda>W s.\n                         if b s then f s \\<bind> W else RETURN s);\n        \\<not> b xa\\<rbrakk>\n       \\<Longrightarrow> RETURN xa \\<le> filter_nb b I", "apply (simp only: pw_le_iff refine_pw_simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x fa xa.\n       \\<lbrakk>nofail m0; inres m0 x;\n        \\<And>x.\n           nofail I \\<longrightarrow>\n           True \\<and>\n           (\\<forall>xa.\n               x = xa \\<longrightarrow> inres I xa) \\<Longrightarrow>\n           nofail I \\<longrightarrow>\n           nofail (fa x) \\<and>\n           (\\<forall>xa.\n               inres (fa x) xa \\<longrightarrow>\n               nofail I \\<longrightarrow> inres I xa \\<and> \\<not> b xa);\n        nofail I \\<longrightarrow>\n        True \\<and> (\\<forall>x. xa = x \\<longrightarrow> inres I x);\n        fa \\<le> REC (\\<lambda>W s.\n                         if b s then f s \\<bind> W else RETURN s);\n        \\<not> b xa\\<rbrakk>\n       \\<Longrightarrow> nofail I \\<longrightarrow>\n                         True \\<and>\n                         (\\<forall>x.\n                             xa = x \\<longrightarrow>\n                             nofail I \\<longrightarrow>\n                             inres I x \\<and> \\<not> b x)", "apply metis"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "primrec bounded_WHILE' \n    :: \"nat \\<Rightarrow> ('a \\<Rightarrow> bool) \\<Rightarrow> ('a \\<Rightarrow> 'a nres) \\<Rightarrow> 'a nres \\<Rightarrow> 'a nres\" \n  where\n    \"bounded_WHILE' 0 cond step m = m\"\n  | \"bounded_WHILE' (Suc n) cond step m = do {\n      x \\<leftarrow> m;\n      if cond x then bounded_WHILE' n cond step (step x)\n      else RETURN x\n    }\""], ["", "primrec bounded_WHILE\n    :: \"nat \\<Rightarrow> ('a \\<Rightarrow> bool) \\<Rightarrow> ('a \\<Rightarrow> 'a nres) \\<Rightarrow> 'a nres \\<Rightarrow> 'a nres\" \n  where\n    \"bounded_WHILE 0 cond step m = m\"\n  | \"bounded_WHILE (Suc n) cond step m = do {\n      x \\<leftarrow> bounded_WHILE n cond step m;\n      if cond x then step x\n      else RETURN x\n    }\""], ["", "lemma bounded_WHILE_shift: \"do {\n             x \\<leftarrow> m;\n             if cond x then bounded_WHILE n cond step (step x) else RETURN x\n           } = do {\n             x \\<leftarrow> bounded_WHILE n cond step m;\n             if cond x then step x else RETURN x\n           }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<bind>\n    (\\<lambda>x.\n        if cond x then bounded_WHILE n cond step (step x) else RETURN x) =\n    bounded_WHILE n cond step m \\<bind>\n    (\\<lambda>x. if cond x then step x else RETURN x)", "proof (induction n arbitrary: m)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>m.\n       m \\<bind>\n       (\\<lambda>x.\n           if cond x then bounded_WHILE 0 cond step (step x)\n           else RETURN x) =\n       bounded_WHILE 0 cond step m \\<bind>\n       (\\<lambda>x. if cond x then step x else RETURN x)\n 2. \\<And>n m.\n       (\\<And>m.\n           m \\<bind>\n           (\\<lambda>x.\n               if cond x then bounded_WHILE n cond step (step x)\n               else RETURN x) =\n           bounded_WHILE n cond step m \\<bind>\n           (\\<lambda>x.\n               if cond x then step x else RETURN x)) \\<Longrightarrow>\n       m \\<bind>\n       (\\<lambda>x.\n           if cond x then bounded_WHILE (Suc n) cond step (step x)\n           else RETURN x) =\n       bounded_WHILE (Suc n) cond step m \\<bind>\n       (\\<lambda>x. if cond x then step x else RETURN x)", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>m.\n       m \\<bind>\n       (\\<lambda>x.\n           if cond x then bounded_WHILE 0 cond step (step x)\n           else RETURN x) =\n       bounded_WHILE 0 cond step m \\<bind>\n       (\\<lambda>x. if cond x then step x else RETURN x)\n 2. \\<And>n m.\n       (\\<And>m.\n           m \\<bind>\n           (\\<lambda>x.\n               if cond x then bounded_WHILE n cond step (step x)\n               else RETURN x) =\n           bounded_WHILE n cond step m \\<bind>\n           (\\<lambda>x.\n               if cond x then step x else RETURN x)) \\<Longrightarrow>\n       m \\<bind>\n       (\\<lambda>x.\n           if cond x then bounded_WHILE (Suc n) cond step (step x)\n           else RETURN x) =\n       bounded_WHILE (Suc n) cond step m \\<bind>\n       (\\<lambda>x. if cond x then step x else RETURN x)", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<bind>\n    (\\<lambda>x.\n        if cond x then bounded_WHILE 0 cond step (step x) else RETURN x) =\n    bounded_WHILE 0 cond step m \\<bind>\n    (\\<lambda>x. if cond x then step x else RETURN x)", "by (simp cong: if_cong)"], ["proof (state)\nthis:\n  m \\<bind>\n  (\\<lambda>x.\n      if cond x then bounded_WHILE 0 cond step (step x) else RETURN x) =\n  bounded_WHILE 0 cond step m \\<bind>\n  (\\<lambda>x. if cond x then step x else RETURN x)\n\ngoal (1 subgoal):\n 1. \\<And>n m.\n       (\\<And>m.\n           m \\<bind>\n           (\\<lambda>x.\n               if cond x then bounded_WHILE n cond step (step x)\n               else RETURN x) =\n           bounded_WHILE n cond step m \\<bind>\n           (\\<lambda>x.\n               if cond x then step x else RETURN x)) \\<Longrightarrow>\n       m \\<bind>\n       (\\<lambda>x.\n           if cond x then bounded_WHILE (Suc n) cond step (step x)\n           else RETURN x) =\n       bounded_WHILE (Suc n) cond step m \\<bind>\n       (\\<lambda>x. if cond x then step x else RETURN x)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n m.\n       (\\<And>m.\n           m \\<bind>\n           (\\<lambda>x.\n               if cond x then bounded_WHILE n cond step (step x)\n               else RETURN x) =\n           bounded_WHILE n cond step m \\<bind>\n           (\\<lambda>x.\n               if cond x then step x else RETURN x)) \\<Longrightarrow>\n       m \\<bind>\n       (\\<lambda>x.\n           if cond x then bounded_WHILE (Suc n) cond step (step x)\n           else RETURN x) =\n       bounded_WHILE (Suc n) cond step m \\<bind>\n       (\\<lambda>x. if cond x then step x else RETURN x)", "case (Suc n)"], ["proof (state)\nthis:\n  ?m \\<bind>\n  (\\<lambda>x.\n      if cond x then bounded_WHILE n cond step (step x) else RETURN x) =\n  bounded_WHILE n cond step ?m \\<bind>\n  (\\<lambda>x. if cond x then step x else RETURN x)\n\ngoal (1 subgoal):\n 1. \\<And>n m.\n       (\\<And>m.\n           m \\<bind>\n           (\\<lambda>x.\n               if cond x then bounded_WHILE n cond step (step x)\n               else RETURN x) =\n           bounded_WHILE n cond step m \\<bind>\n           (\\<lambda>x.\n               if cond x then step x else RETURN x)) \\<Longrightarrow>\n       m \\<bind>\n       (\\<lambda>x.\n           if cond x then bounded_WHILE (Suc n) cond step (step x)\n           else RETURN x) =\n       bounded_WHILE (Suc n) cond step m \\<bind>\n       (\\<lambda>x. if cond x then step x else RETURN x)", "have aux1: \"do {\n      x \\<leftarrow> m;\n      if cond x then do {\n                       x \\<leftarrow> bounded_WHILE n cond step (step x);\n                       if cond x then step x else RETURN x\n                     }\n      else RETURN x\n    } = do {\n      x \\<leftarrow> do {\n        x \\<leftarrow> m; \n        if cond x then bounded_WHILE n cond step (step x) else RETURN x\n      };\n      if cond x then step x else RETURN x\n    }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<bind>\n    (\\<lambda>x.\n        if cond x\n        then bounded_WHILE n cond step (step x) \\<bind>\n             (\\<lambda>x. if cond x then step x else RETURN x)\n        else RETURN x) =\n    m \\<bind>\n    (\\<lambda>x.\n        if cond x then bounded_WHILE n cond step (step x)\n        else RETURN x) \\<bind>\n    (\\<lambda>x. if cond x then step x else RETURN x)", "by (simp add: pw_eq_iff refine_pw_simps)"], ["proof (state)\nthis:\n  m \\<bind>\n  (\\<lambda>x.\n      if cond x\n      then bounded_WHILE n cond step (step x) \\<bind>\n           (\\<lambda>x. if cond x then step x else RETURN x)\n      else RETURN x) =\n  m \\<bind>\n  (\\<lambda>x.\n      if cond x then bounded_WHILE n cond step (step x)\n      else RETURN x) \\<bind>\n  (\\<lambda>x. if cond x then step x else RETURN x)\n\ngoal (1 subgoal):\n 1. \\<And>n m.\n       (\\<And>m.\n           m \\<bind>\n           (\\<lambda>x.\n               if cond x then bounded_WHILE n cond step (step x)\n               else RETURN x) =\n           bounded_WHILE n cond step m \\<bind>\n           (\\<lambda>x.\n               if cond x then step x else RETURN x)) \\<Longrightarrow>\n       m \\<bind>\n       (\\<lambda>x.\n           if cond x then bounded_WHILE (Suc n) cond step (step x)\n           else RETURN x) =\n       bounded_WHILE (Suc n) cond step m \\<bind>\n       (\\<lambda>x. if cond x then step x else RETURN x)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<bind>\n    (\\<lambda>x.\n        if cond x then bounded_WHILE (Suc n) cond step (step x)\n        else RETURN x) =\n    bounded_WHILE (Suc n) cond step m \\<bind>\n    (\\<lambda>x. if cond x then step x else RETURN x)", "apply (simp cong: if_cong)"], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<bind>\n    (\\<lambda>x.\n        if cond x\n        then bounded_WHILE n cond step (step x) \\<bind>\n             (\\<lambda>x. if cond x then step x else RETURN x)\n        else RETURN x) =\n    bounded_WHILE n cond step m \\<bind>\n    (\\<lambda>x.\n        if cond x\n        then step x \\<bind>\n             (\\<lambda>x. if cond x then step x else RETURN x)\n        else RETURN x)", "apply (subst aux1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<bind>\n    (\\<lambda>x.\n        if cond x then bounded_WHILE n cond step (step x)\n        else RETURN x) \\<bind>\n    (\\<lambda>x. if cond x then step x else RETURN x) =\n    bounded_WHILE n cond step m \\<bind>\n    (\\<lambda>x.\n        if cond x\n        then step x \\<bind>\n             (\\<lambda>x. if cond x then step x else RETURN x)\n        else RETURN x)", "apply (subst Suc.IH)"], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded_WHILE n cond step m \\<bind>\n    (\\<lambda>x. if cond x then step x else RETURN x) \\<bind>\n    (\\<lambda>x. if cond x then step x else RETURN x) =\n    bounded_WHILE n cond step m \\<bind>\n    (\\<lambda>x.\n        if cond x\n        then step x \\<bind>\n             (\\<lambda>x. if cond x then step x else RETURN x)\n        else RETURN x)", "apply (simp add: pw_eq_iff refine_pw_simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  m \\<bind>\n  (\\<lambda>x.\n      if cond x then bounded_WHILE (Suc n) cond step (step x)\n      else RETURN x) =\n  bounded_WHILE (Suc n) cond step m \\<bind>\n  (\\<lambda>x. if cond x then step x else RETURN x)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bounded_WHILE'_eq: \n    \"bounded_WHILE' n cond step m = bounded_WHILE n cond step m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded_WHILE' n cond step m = bounded_WHILE n cond step m", "apply (induct n arbitrary: m)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>m. bounded_WHILE' 0 cond step m = bounded_WHILE 0 cond step m\n 2. \\<And>n m.\n       (\\<And>m.\n           bounded_WHILE' n cond step m =\n           bounded_WHILE n cond step m) \\<Longrightarrow>\n       bounded_WHILE' (Suc n) cond step m =\n       bounded_WHILE (Suc n) cond step m", "apply (auto cong: if_cong simp: bounded_WHILE_shift)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma mWHILE_unfold: \"m \\<bind> WHILE cond step = do {\n      x \\<leftarrow> m;\n      if cond x then step x \\<bind> WHILE cond step\n      else RETURN x\n    }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<bind> WHILE cond step =\n    m \\<bind>\n    (\\<lambda>x.\n        if cond x then step x \\<bind> WHILE cond step else RETURN x)", "by (subst WHILE_unfold[abs_def]) (rule refl)"], ["", "lemma WHILE_bounded_aux1: \n    \"filter_nb cond (bounded_WHILE n cond step m) \\<le> m \\<bind> WHILE cond step\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filter_nb cond (bounded_WHILE n cond step m)\n    \\<le> m \\<bind> WHILE cond step", "unfolding bounded_WHILE'_eq[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. filter_nb cond (bounded_WHILE' n cond step m)\n    \\<le> m \\<bind> WHILE cond step", "apply (induct n arbitrary: m)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>m.\n       filter_nb cond (bounded_WHILE' 0 cond step m)\n       \\<le> m \\<bind> WHILE cond step\n 2. \\<And>n m.\n       (\\<And>m.\n           filter_nb cond (bounded_WHILE' n cond step m)\n           \\<le> m \\<bind> WHILE cond step) \\<Longrightarrow>\n       filter_nb cond (bounded_WHILE' (Suc n) cond step m)\n       \\<le> m \\<bind> WHILE cond step", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>m. filter_nb cond m \\<le> m \\<bind> WHILE cond step\n 2. \\<And>n m.\n       (\\<And>m.\n           filter_nb cond (bounded_WHILE' n cond step m)\n           \\<le> m \\<bind> WHILE cond step) \\<Longrightarrow>\n       filter_nb cond (bounded_WHILE' (Suc n) cond step m)\n       \\<le> m \\<bind> WHILE cond step", "apply (subst mWHILE_unfold)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>m.\n       filter_nb cond m\n       \\<le> m \\<bind>\n             (\\<lambda>x.\n                 if cond x then step x \\<bind> WHILE cond step\n                 else RETURN x)\n 2. \\<And>n m.\n       (\\<And>m.\n           filter_nb cond (bounded_WHILE' n cond step m)\n           \\<le> m \\<bind> WHILE cond step) \\<Longrightarrow>\n       filter_nb cond (bounded_WHILE' (Suc n) cond step m)\n       \\<le> m \\<bind> WHILE cond step", "apply (simp add: pw_le_iff refine_pw_simps, blast)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n m.\n       (\\<And>m.\n           filter_nb cond (bounded_WHILE' n cond step m)\n           \\<le> m \\<bind> WHILE cond step) \\<Longrightarrow>\n       filter_nb cond (bounded_WHILE' (Suc n) cond step m)\n       \\<le> m \\<bind> WHILE cond step", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n m.\n       (\\<And>m.\n           filter_nb cond (bounded_WHILE' n cond step m)\n           \\<le> m \\<bind> WHILE cond step) \\<Longrightarrow>\n       filter_nb cond\n        (m \\<bind>\n         (\\<lambda>x.\n             if cond x then bounded_WHILE' n cond step (step x)\n             else RETURN x))\n       \\<le> m \\<bind> WHILE cond step", "apply (subst mWHILE_unfold)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n m.\n       (\\<And>m.\n           filter_nb cond (bounded_WHILE' n cond step m)\n           \\<le> m \\<bind> WHILE cond step) \\<Longrightarrow>\n       filter_nb cond\n        (m \\<bind>\n         (\\<lambda>x.\n             if cond x then bounded_WHILE' n cond step (step x)\n             else RETURN x))\n       \\<le> m \\<bind>\n             (\\<lambda>x.\n                 if cond x then step x \\<bind> WHILE cond step\n                 else RETURN x)", "apply (auto simp add: pw_le_iff refine_pw_simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma WHILE_bounded_aux2:\n    \"m \\<bind> WHILE cond step \n      \\<le> filter_nb cond (Sup {bounded_WHILE n cond step m | n. True})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<bind> WHILE cond step\n    \\<le> filter_nb cond (Sup {bounded_WHILE n cond step m |n. True})", "apply (rule WHILE_rule_gen_le)"], ["proof (prove)\ngoal (2 subgoals):\n 1. m \\<le> Sup {bounded_WHILE n cond step m |n. True}\n 2. \\<And>s.\n       \\<lbrakk>RETURN s \\<le> Sup {bounded_WHILE n cond step m |n. True};\n        cond s\\<rbrakk>\n       \\<Longrightarrow> step s\n                         \\<le> Sup {bounded_WHILE n cond step m |n. True}", "apply (metis (mono_tags, lifting) Sup_upper bounded_WHILE.simps(1) \n      mem_Collect_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>RETURN s \\<le> Sup {bounded_WHILE n cond step m |n. True};\n        cond s\\<rbrakk>\n       \\<Longrightarrow> step s\n                         \\<le> Sup {bounded_WHILE n cond step m |n. True}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>RETURN s \\<le> Sup {bounded_WHILE n cond step m |n. True};\n        cond s\\<rbrakk>\n       \\<Longrightarrow> step s\n                         \\<le> Sup {bounded_WHILE n cond step m |n. True}", "fix s"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>RETURN s \\<le> Sup {bounded_WHILE n cond step m |n. True};\n        cond s\\<rbrakk>\n       \\<Longrightarrow> step s\n                         \\<le> Sup {bounded_WHILE n cond step m |n. True}", "assume \"RETURN s \\<le> Sup {bounded_WHILE n cond step m |n. True}\""], ["proof (state)\nthis:\n  RETURN s \\<le> Sup {bounded_WHILE n cond step m |n. True}\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>RETURN s \\<le> Sup {bounded_WHILE n cond step m |n. True};\n        cond s\\<rbrakk>\n       \\<Longrightarrow> step s\n                         \\<le> Sup {bounded_WHILE n cond step m |n. True}", "then"], ["proof (chain)\npicking this:\n  RETURN s \\<le> Sup {bounded_WHILE n cond step m |n. True}", "obtain n where \"RETURN s \\<le> bounded_WHILE n cond step m\""], ["proof (prove)\nusing this:\n  RETURN s \\<le> Sup {bounded_WHILE n cond step m |n. True}\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        RETURN s \\<le> bounded_WHILE n cond step m \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (fold inres_def) (auto simp: refine_pw_simps)"], ["proof (state)\nthis:\n  RETURN s \\<le> bounded_WHILE n cond step m\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>RETURN s \\<le> Sup {bounded_WHILE n cond step m |n. True};\n        cond s\\<rbrakk>\n       \\<Longrightarrow> step s\n                         \\<le> Sup {bounded_WHILE n cond step m |n. True}", "moreover"], ["proof (state)\nthis:\n  RETURN s \\<le> bounded_WHILE n cond step m\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>RETURN s \\<le> Sup {bounded_WHILE n cond step m |n. True};\n        cond s\\<rbrakk>\n       \\<Longrightarrow> step s\n                         \\<le> Sup {bounded_WHILE n cond step m |n. True}", "assume \"cond s\""], ["proof (state)\nthis:\n  cond s\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>RETURN s \\<le> Sup {bounded_WHILE n cond step m |n. True};\n        cond s\\<rbrakk>\n       \\<Longrightarrow> step s\n                         \\<le> Sup {bounded_WHILE n cond step m |n. True}", "ultimately"], ["proof (chain)\npicking this:\n  RETURN s \\<le> bounded_WHILE n cond step m\n  cond s", "have \"step s \\<le> bounded_WHILE (Suc n) cond step m\""], ["proof (prove)\nusing this:\n  RETURN s \\<le> bounded_WHILE n cond step m\n  cond s\n\ngoal (1 subgoal):\n 1. step s \\<le> bounded_WHILE (Suc n) cond step m", "by (simp add: pw_le_iff refine_pw_simps, blast)"], ["proof (state)\nthis:\n  step s \\<le> bounded_WHILE (Suc n) cond step m\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>RETURN s \\<le> Sup {bounded_WHILE n cond step m |n. True};\n        cond s\\<rbrakk>\n       \\<Longrightarrow> step s\n                         \\<le> Sup {bounded_WHILE n cond step m |n. True}", "thus \"step s \\<le> Sup {bounded_WHILE n cond step m |n. True}\""], ["proof (prove)\nusing this:\n  step s \\<le> bounded_WHILE (Suc n) cond step m\n\ngoal (1 subgoal):\n 1. step s \\<le> Sup {bounded_WHILE n cond step m |n. True}", "by (metis (mono_tags, lifting) Sup_upper2 mem_Collect_eq)"], ["proof (state)\nthis:\n  step s \\<le> Sup {bounded_WHILE n cond step m |n. True}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma WHILE_bounded: \n    \"m \\<bind> WHILE cond step \n    = filter_nb cond (Sup {bounded_WHILE n cond step m | n. True})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<bind> WHILE cond step =\n    filter_nb cond (Sup {bounded_WHILE n cond step m |n. True})", "apply (rule antisym)"], ["proof (prove)\ngoal (2 subgoals):\n 1. m \\<bind> WHILE cond step\n    \\<le> filter_nb cond (Sup {bounded_WHILE n cond step m |n. True})\n 2. filter_nb cond (Sup {bounded_WHILE n cond step m |n. True})\n    \\<le> m \\<bind> WHILE cond step", "apply (rule WHILE_bounded_aux2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. filter_nb cond (Sup {bounded_WHILE n cond step m |n. True})\n    \\<le> m \\<bind> WHILE cond step", "apply (simp add: filter_nb_cont)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Sup {filter_nb cond ma |ma.\n         \\<exists>n. ma = bounded_WHILE n cond step m}\n    \\<le> m \\<bind> WHILE cond step", "apply (rule Sup_least)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {filter_nb cond ma |ma.\n                \\<exists>n.\n                   ma = bounded_WHILE n cond step m} \\<Longrightarrow>\n       x \\<le> m \\<bind> WHILE cond step", "apply (auto simp: WHILE_bounded_aux1)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsubsection \\<open>Relation to rwof\\<close>"], ["", "lemma rwof_in_bounded_WHILE:\n    assumes \"rwof m0 cond step s\" \n    shows \"\\<exists>n. RETURN s \\<le> (bounded_WHILE n cond step m0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>n. RETURN s \\<le> bounded_WHILE n cond step m0", "using assms"], ["proof (prove)\nusing this:\n  rwof m0 cond step s\n\ngoal (1 subgoal):\n 1. \\<exists>n. RETURN s \\<le> bounded_WHILE n cond step m0", "apply induction"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>X x.\n       \\<lbrakk>m0 = RES X; x \\<in> X\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n.\n                            RETURN x \\<le> bounded_WHILE n cond step m0\n 2. \\<And>x Y y.\n       \\<lbrakk>rwof m0 cond step x;\n        \\<exists>n. RETURN x \\<le> bounded_WHILE n cond step m0; cond x;\n        step x = RES Y; y \\<in> Y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n.\n                            RETURN y \\<le> bounded_WHILE n cond step m0", "apply (rule_tac x=0 in exI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>X x.\n       \\<lbrakk>m0 = RES X; x \\<in> X\\<rbrakk>\n       \\<Longrightarrow> RETURN x \\<le> bounded_WHILE 0 cond step m0\n 2. \\<And>x Y y.\n       \\<lbrakk>rwof m0 cond step x;\n        \\<exists>n. RETURN x \\<le> bounded_WHILE n cond step m0; cond x;\n        step x = RES Y; y \\<in> Y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n.\n                            RETURN y \\<le> bounded_WHILE n cond step m0", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x Y y.\n       \\<lbrakk>rwof m0 cond step x;\n        \\<exists>n. RETURN x \\<le> bounded_WHILE n cond step m0; cond x;\n        step x = RES Y; y \\<in> Y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n.\n                            RETURN y \\<le> bounded_WHILE n cond step m0", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x Y y n.\n       \\<lbrakk>rwof m0 cond step x; cond x; step x = RES Y; y \\<in> Y;\n        RETURN x \\<le> bounded_WHILE n cond step m0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n.\n                            RETURN y \\<le> bounded_WHILE n cond step m0", "apply (rule_tac x=\"Suc n\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x Y y n.\n       \\<lbrakk>rwof m0 cond step x; cond x; step x = RES Y; y \\<in> Y;\n        RETURN x \\<le> bounded_WHILE n cond step m0\\<rbrakk>\n       \\<Longrightarrow> RETURN y \\<le> bounded_WHILE (Suc n) cond step m0", "apply (auto simp add: pw_le_iff refine_pw_simps) []"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma bounded_WHILE_FAIL_rwof:\n    assumes \"bounded_WHILE n cond step m0 = FAIL\"\n    assumes M0: \"m0 \\<noteq> FAIL\"\n    shows \"\\<exists>n'<n. \\<exists>x X. \n        bounded_WHILE n' cond step m0 = RES X \n      \\<and> x\\<in>X \\<and> cond x \\<and> step x = FAIL\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>n'<n.\n       \\<exists>x X.\n          bounded_WHILE n' cond step m0 = RES X \\<and>\n          x \\<in> X \\<and> cond x \\<and> step x = FAIL", "using assms"], ["proof (prove)\nusing this:\n  bounded_WHILE n cond step m0 = FAIL\n  m0 \\<noteq> FAIL\n\ngoal (1 subgoal):\n 1. \\<exists>n'<n.\n       \\<exists>x X.\n          bounded_WHILE n' cond step m0 = RES X \\<and>\n          x \\<in> X \\<and> cond x \\<and> step x = FAIL", "proof (induction n)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>bounded_WHILE 0 cond step m0 = FAIL; m0 \\<noteq> FAIL\\<rbrakk>\n    \\<Longrightarrow> \\<exists>n'<0.\n                         \\<exists>x X.\n                            bounded_WHILE n' cond step m0 = RES X \\<and>\n                            x \\<in> X \\<and> cond x \\<and> step x = FAIL\n 2. \\<And>n.\n       \\<lbrakk>\\<lbrakk>bounded_WHILE n cond step m0 = FAIL;\n                 m0 \\<noteq> FAIL\\<rbrakk>\n                \\<Longrightarrow> \\<exists>n'<n.\n                                     \\<exists>x X.\n  bounded_WHILE n' cond step m0 = RES X \\<and>\n  x \\<in> X \\<and> cond x \\<and> step x = FAIL;\n        bounded_WHILE (Suc n) cond step m0 = FAIL; m0 \\<noteq> FAIL\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n'<Suc n.\n                            \\<exists>x X.\n                               bounded_WHILE n' cond step m0 = RES X \\<and>\n                               x \\<in> X \\<and> cond x \\<and> step x = FAIL", "case 0"], ["proof (state)\nthis:\n  bounded_WHILE 0 cond step m0 = FAIL\n  m0 \\<noteq> FAIL\n\ngoal (2 subgoals):\n 1. \\<lbrakk>bounded_WHILE 0 cond step m0 = FAIL; m0 \\<noteq> FAIL\\<rbrakk>\n    \\<Longrightarrow> \\<exists>n'<0.\n                         \\<exists>x X.\n                            bounded_WHILE n' cond step m0 = RES X \\<and>\n                            x \\<in> X \\<and> cond x \\<and> step x = FAIL\n 2. \\<And>n.\n       \\<lbrakk>\\<lbrakk>bounded_WHILE n cond step m0 = FAIL;\n                 m0 \\<noteq> FAIL\\<rbrakk>\n                \\<Longrightarrow> \\<exists>n'<n.\n                                     \\<exists>x X.\n  bounded_WHILE n' cond step m0 = RES X \\<and>\n  x \\<in> X \\<and> cond x \\<and> step x = FAIL;\n        bounded_WHILE (Suc n) cond step m0 = FAIL; m0 \\<noteq> FAIL\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n'<Suc n.\n                            \\<exists>x X.\n                               bounded_WHILE n' cond step m0 = RES X \\<and>\n                               x \\<in> X \\<and> cond x \\<and> step x = FAIL", "thus ?case"], ["proof (prove)\nusing this:\n  bounded_WHILE 0 cond step m0 = FAIL\n  m0 \\<noteq> FAIL\n\ngoal (1 subgoal):\n 1. \\<exists>n'<0.\n       \\<exists>x X.\n          bounded_WHILE n' cond step m0 = RES X \\<and>\n          x \\<in> X \\<and> cond x \\<and> step x = FAIL", "by simp"], ["proof (state)\nthis:\n  \\<exists>n'<0.\n     \\<exists>x X.\n        bounded_WHILE n' cond step m0 = RES X \\<and>\n        x \\<in> X \\<and> cond x \\<and> step x = FAIL\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>\\<lbrakk>bounded_WHILE n cond step m0 = FAIL;\n                 m0 \\<noteq> FAIL\\<rbrakk>\n                \\<Longrightarrow> \\<exists>n'<n.\n                                     \\<exists>x X.\n  bounded_WHILE n' cond step m0 = RES X \\<and>\n  x \\<in> X \\<and> cond x \\<and> step x = FAIL;\n        bounded_WHILE (Suc n) cond step m0 = FAIL; m0 \\<noteq> FAIL\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n'<Suc n.\n                            \\<exists>x X.\n                               bounded_WHILE n' cond step m0 = RES X \\<and>\n                               x \\<in> X \\<and> cond x \\<and> step x = FAIL", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>\\<lbrakk>bounded_WHILE n cond step m0 = FAIL;\n                 m0 \\<noteq> FAIL\\<rbrakk>\n                \\<Longrightarrow> \\<exists>n'<n.\n                                     \\<exists>x X.\n  bounded_WHILE n' cond step m0 = RES X \\<and>\n  x \\<in> X \\<and> cond x \\<and> step x = FAIL;\n        bounded_WHILE (Suc n) cond step m0 = FAIL; m0 \\<noteq> FAIL\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n'<Suc n.\n                            \\<exists>x X.\n                               bounded_WHILE n' cond step m0 = RES X \\<and>\n                               x \\<in> X \\<and> cond x \\<and> step x = FAIL", "case (Suc n)"], ["proof (state)\nthis:\n  \\<lbrakk>bounded_WHILE n cond step m0 = FAIL; m0 \\<noteq> FAIL\\<rbrakk>\n  \\<Longrightarrow> \\<exists>n'<n.\n                       \\<exists>x X.\n                          bounded_WHILE n' cond step m0 = RES X \\<and>\n                          x \\<in> X \\<and> cond x \\<and> step x = FAIL\n  bounded_WHILE (Suc n) cond step m0 = FAIL\n  m0 \\<noteq> FAIL\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>\\<lbrakk>bounded_WHILE n cond step m0 = FAIL;\n                 m0 \\<noteq> FAIL\\<rbrakk>\n                \\<Longrightarrow> \\<exists>n'<n.\n                                     \\<exists>x X.\n  bounded_WHILE n' cond step m0 = RES X \\<and>\n  x \\<in> X \\<and> cond x \\<and> step x = FAIL;\n        bounded_WHILE (Suc n) cond step m0 = FAIL; m0 \\<noteq> FAIL\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n'<Suc n.\n                            \\<exists>x X.\n                               bounded_WHILE n' cond step m0 = RES X \\<and>\n                               x \\<in> X \\<and> cond x \\<and> step x = FAIL", "assume \"bounded_WHILE (Suc n) cond step m0 = FAIL\""], ["proof (state)\nthis:\n  bounded_WHILE (Suc n) cond step m0 = FAIL\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>\\<lbrakk>bounded_WHILE n cond step m0 = FAIL;\n                 m0 \\<noteq> FAIL\\<rbrakk>\n                \\<Longrightarrow> \\<exists>n'<n.\n                                     \\<exists>x X.\n  bounded_WHILE n' cond step m0 = RES X \\<and>\n  x \\<in> X \\<and> cond x \\<and> step x = FAIL;\n        bounded_WHILE (Suc n) cond step m0 = FAIL; m0 \\<noteq> FAIL\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n'<Suc n.\n                            \\<exists>x X.\n                               bounded_WHILE n' cond step m0 = RES X \\<and>\n                               x \\<in> X \\<and> cond x \\<and> step x = FAIL", "hence \"bounded_WHILE n cond step m0 = FAIL \n      \\<or> (\\<exists>X x. bounded_WHILE n cond step m0 = RES X \n          \\<and> x\\<in>X \\<and> cond x \\<and> step x = FAIL)\"\n      (is \"?C1 \\<or> ?C2\")"], ["proof (prove)\nusing this:\n  bounded_WHILE (Suc n) cond step m0 = FAIL\n\ngoal (1 subgoal):\n 1. bounded_WHILE n cond step m0 = FAIL \\<or>\n    (\\<exists>X x.\n        bounded_WHILE n cond step m0 = RES X \\<and>\n        x \\<in> X \\<and> cond x \\<and> step x = FAIL)", "apply (cases \"bounded_WHILE n cond step m0\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>bounded_WHILE (Suc n) cond step m0 = FAIL;\n     bounded_WHILE n cond step m0 = FAIL\\<rbrakk>\n    \\<Longrightarrow> bounded_WHILE n cond step m0 = FAIL \\<or>\n                      (\\<exists>X x.\n                          bounded_WHILE n cond step m0 = RES X \\<and>\n                          x \\<in> X \\<and> cond x \\<and> step x = FAIL)\n 2. \\<And>X.\n       \\<lbrakk>bounded_WHILE (Suc n) cond step m0 = FAIL;\n        bounded_WHILE n cond step m0 = RES X\\<rbrakk>\n       \\<Longrightarrow> bounded_WHILE n cond step m0 = FAIL \\<or>\n                         (\\<exists>X x.\n                             bounded_WHILE n cond step m0 = RES X \\<and>\n                             x \\<in> X \\<and> cond x \\<and> step x = FAIL)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>X.\n       \\<lbrakk>bounded_WHILE (Suc n) cond step m0 = FAIL;\n        bounded_WHILE n cond step m0 = RES X\\<rbrakk>\n       \\<Longrightarrow> bounded_WHILE n cond step m0 = FAIL \\<or>\n                         (\\<exists>X x.\n                             bounded_WHILE n cond step m0 = RES X \\<and>\n                             x \\<in> X \\<and> cond x \\<and> step x = FAIL)", "apply (simp add: pw_eq_iff refine_pw_simps split: if_split_asm)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>X x.\n       \\<lbrakk>\\<forall>x.\n                   \\<exists>y.\n                      (cond y \\<longrightarrow>\n                       y \\<in> X \\<and> inres (step y) x) \\<and>\n                      (cond y \\<or> y \\<in> X \\<and> y = x);\n        nofail (bounded_WHILE n cond step m0);\n        \\<forall>x. inres (bounded_WHILE n cond step m0) x = (x \\<in> X);\n        cond x; x \\<in> X; \\<not> nofail (step x)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Xa.\n                            (\\<forall>x. (x \\<in> X) = (x \\<in> Xa)) \\<and>\n                            (\\<exists>x.\n                                x \\<in> Xa \\<and>\n                                cond x \\<and>\n                                \\<not> nofail (step x) \\<and>\n                                All (inres (step x)))", "apply (auto intro: not_nofail_inres simp: refine_pw_simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  bounded_WHILE n cond step m0 = FAIL \\<or>\n  (\\<exists>X x.\n      bounded_WHILE n cond step m0 = RES X \\<and>\n      x \\<in> X \\<and> cond x \\<and> step x = FAIL)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>\\<lbrakk>bounded_WHILE n cond step m0 = FAIL;\n                 m0 \\<noteq> FAIL\\<rbrakk>\n                \\<Longrightarrow> \\<exists>n'<n.\n                                     \\<exists>x X.\n  bounded_WHILE n' cond step m0 = RES X \\<and>\n  x \\<in> X \\<and> cond x \\<and> step x = FAIL;\n        bounded_WHILE (Suc n) cond step m0 = FAIL; m0 \\<noteq> FAIL\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n'<Suc n.\n                            \\<exists>x X.\n                               bounded_WHILE n' cond step m0 = RES X \\<and>\n                               x \\<in> X \\<and> cond x \\<and> step x = FAIL", "moreover"], ["proof (state)\nthis:\n  bounded_WHILE n cond step m0 = FAIL \\<or>\n  (\\<exists>X x.\n      bounded_WHILE n cond step m0 = RES X \\<and>\n      x \\<in> X \\<and> cond x \\<and> step x = FAIL)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>\\<lbrakk>bounded_WHILE n cond step m0 = FAIL;\n                 m0 \\<noteq> FAIL\\<rbrakk>\n                \\<Longrightarrow> \\<exists>n'<n.\n                                     \\<exists>x X.\n  bounded_WHILE n' cond step m0 = RES X \\<and>\n  x \\<in> X \\<and> cond x \\<and> step x = FAIL;\n        bounded_WHILE (Suc n) cond step m0 = FAIL; m0 \\<noteq> FAIL\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n'<Suc n.\n                            \\<exists>x X.\n                               bounded_WHILE n' cond step m0 = RES X \\<and>\n                               x \\<in> X \\<and> cond x \\<and> step x = FAIL", "{"], ["proof (state)\nthis:\n  bounded_WHILE n cond step m0 = FAIL \\<or>\n  (\\<exists>X x.\n      bounded_WHILE n cond step m0 = RES X \\<and>\n      x \\<in> X \\<and> cond x \\<and> step x = FAIL)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>\\<lbrakk>bounded_WHILE n cond step m0 = FAIL;\n                 m0 \\<noteq> FAIL\\<rbrakk>\n                \\<Longrightarrow> \\<exists>n'<n.\n                                     \\<exists>x X.\n  bounded_WHILE n' cond step m0 = RES X \\<and>\n  x \\<in> X \\<and> cond x \\<and> step x = FAIL;\n        bounded_WHILE (Suc n) cond step m0 = FAIL; m0 \\<noteq> FAIL\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n'<Suc n.\n                            \\<exists>x X.\n                               bounded_WHILE n' cond step m0 = RES X \\<and>\n                               x \\<in> X \\<and> cond x \\<and> step x = FAIL", "assume ?C1"], ["proof (state)\nthis:\n  bounded_WHILE n cond step m0 = FAIL\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>\\<lbrakk>bounded_WHILE n cond step m0 = FAIL;\n                 m0 \\<noteq> FAIL\\<rbrakk>\n                \\<Longrightarrow> \\<exists>n'<n.\n                                     \\<exists>x X.\n  bounded_WHILE n' cond step m0 = RES X \\<and>\n  x \\<in> X \\<and> cond x \\<and> step x = FAIL;\n        bounded_WHILE (Suc n) cond step m0 = FAIL; m0 \\<noteq> FAIL\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n'<Suc n.\n                            \\<exists>x X.\n                               bounded_WHILE n' cond step m0 = RES X \\<and>\n                               x \\<in> X \\<and> cond x \\<and> step x = FAIL", "from Suc.IH[OF this M0]"], ["proof (chain)\npicking this:\n  \\<exists>n'<n.\n     \\<exists>x X.\n        bounded_WHILE n' cond step m0 = RES X \\<and>\n        x \\<in> X \\<and> cond x \\<and> step x = FAIL", "obtain n' x X where \"n' < n\" and\n        1: \"bounded_WHILE n' cond step m0 = RES X \\<and> x\\<in>X \\<and> cond x \\<and> step x = FAIL\""], ["proof (prove)\nusing this:\n  \\<exists>n'<n.\n     \\<exists>x X.\n        bounded_WHILE n' cond step m0 = RES X \\<and>\n        x \\<in> X \\<and> cond x \\<and> step x = FAIL\n\ngoal (1 subgoal):\n 1. (\\<And>n' X x.\n        \\<lbrakk>n' < n;\n         bounded_WHILE n' cond step m0 = RES X \\<and>\n         x \\<in> X \\<and> cond x \\<and> step x = FAIL\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  n' < n\n  bounded_WHILE n' cond step m0 = RES X \\<and>\n  x \\<in> X \\<and> cond x \\<and> step x = FAIL\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>\\<lbrakk>bounded_WHILE n cond step m0 = FAIL;\n                 m0 \\<noteq> FAIL\\<rbrakk>\n                \\<Longrightarrow> \\<exists>n'<n.\n                                     \\<exists>x X.\n  bounded_WHILE n' cond step m0 = RES X \\<and>\n  x \\<in> X \\<and> cond x \\<and> step x = FAIL;\n        bounded_WHILE (Suc n) cond step m0 = FAIL; m0 \\<noteq> FAIL\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n'<Suc n.\n                            \\<exists>x X.\n                               bounded_WHILE n' cond step m0 = RES X \\<and>\n                               x \\<in> X \\<and> cond x \\<and> step x = FAIL", "hence 2: \"n' < Suc n\""], ["proof (prove)\nusing this:\n  n' < n\n  bounded_WHILE n' cond step m0 = RES X \\<and>\n  x \\<in> X \\<and> cond x \\<and> step x = FAIL\n\ngoal (1 subgoal):\n 1. n' < Suc n", "by simp"], ["proof (state)\nthis:\n  n' < Suc n\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>\\<lbrakk>bounded_WHILE n cond step m0 = FAIL;\n                 m0 \\<noteq> FAIL\\<rbrakk>\n                \\<Longrightarrow> \\<exists>n'<n.\n                                     \\<exists>x X.\n  bounded_WHILE n' cond step m0 = RES X \\<and>\n  x \\<in> X \\<and> cond x \\<and> step x = FAIL;\n        bounded_WHILE (Suc n) cond step m0 = FAIL; m0 \\<noteq> FAIL\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n'<Suc n.\n                            \\<exists>x X.\n                               bounded_WHILE n' cond step m0 = RES X \\<and>\n                               x \\<in> X \\<and> cond x \\<and> step x = FAIL", "from 1 2"], ["proof (chain)\npicking this:\n  bounded_WHILE n' cond step m0 = RES X \\<and>\n  x \\<in> X \\<and> cond x \\<and> step x = FAIL\n  n' < Suc n", "have ?case"], ["proof (prove)\nusing this:\n  bounded_WHILE n' cond step m0 = RES X \\<and>\n  x \\<in> X \\<and> cond x \\<and> step x = FAIL\n  n' < Suc n\n\ngoal (1 subgoal):\n 1. \\<exists>n'<Suc n.\n       \\<exists>x X.\n          bounded_WHILE n' cond step m0 = RES X \\<and>\n          x \\<in> X \\<and> cond x \\<and> step x = FAIL", "by blast"], ["proof (state)\nthis:\n  \\<exists>n'<Suc n.\n     \\<exists>x X.\n        bounded_WHILE n' cond step m0 = RES X \\<and>\n        x \\<in> X \\<and> cond x \\<and> step x = FAIL\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>\\<lbrakk>bounded_WHILE n cond step m0 = FAIL;\n                 m0 \\<noteq> FAIL\\<rbrakk>\n                \\<Longrightarrow> \\<exists>n'<n.\n                                     \\<exists>x X.\n  bounded_WHILE n' cond step m0 = RES X \\<and>\n  x \\<in> X \\<and> cond x \\<and> step x = FAIL;\n        bounded_WHILE (Suc n) cond step m0 = FAIL; m0 \\<noteq> FAIL\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n'<Suc n.\n                            \\<exists>x X.\n                               bounded_WHILE n' cond step m0 = RES X \\<and>\n                               x \\<in> X \\<and> cond x \\<and> step x = FAIL", "}"], ["proof (state)\nthis:\n  bounded_WHILE n cond step m0 = FAIL \\<Longrightarrow>\n  \\<exists>n'<Suc n.\n     \\<exists>x X.\n        bounded_WHILE n' cond step m0 = RES X \\<and>\n        x \\<in> X \\<and> cond x \\<and> step x = FAIL\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>\\<lbrakk>bounded_WHILE n cond step m0 = FAIL;\n                 m0 \\<noteq> FAIL\\<rbrakk>\n                \\<Longrightarrow> \\<exists>n'<n.\n                                     \\<exists>x X.\n  bounded_WHILE n' cond step m0 = RES X \\<and>\n  x \\<in> X \\<and> cond x \\<and> step x = FAIL;\n        bounded_WHILE (Suc n) cond step m0 = FAIL; m0 \\<noteq> FAIL\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n'<Suc n.\n                            \\<exists>x X.\n                               bounded_WHILE n' cond step m0 = RES X \\<and>\n                               x \\<in> X \\<and> cond x \\<and> step x = FAIL", "moreover"], ["proof (state)\nthis:\n  bounded_WHILE n cond step m0 = FAIL \\<Longrightarrow>\n  \\<exists>n'<Suc n.\n     \\<exists>x X.\n        bounded_WHILE n' cond step m0 = RES X \\<and>\n        x \\<in> X \\<and> cond x \\<and> step x = FAIL\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>\\<lbrakk>bounded_WHILE n cond step m0 = FAIL;\n                 m0 \\<noteq> FAIL\\<rbrakk>\n                \\<Longrightarrow> \\<exists>n'<n.\n                                     \\<exists>x X.\n  bounded_WHILE n' cond step m0 = RES X \\<and>\n  x \\<in> X \\<and> cond x \\<and> step x = FAIL;\n        bounded_WHILE (Suc n) cond step m0 = FAIL; m0 \\<noteq> FAIL\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n'<Suc n.\n                            \\<exists>x X.\n                               bounded_WHILE n' cond step m0 = RES X \\<and>\n                               x \\<in> X \\<and> cond x \\<and> step x = FAIL", "{"], ["proof (state)\nthis:\n  bounded_WHILE n cond step m0 = FAIL \\<Longrightarrow>\n  \\<exists>n'<Suc n.\n     \\<exists>x X.\n        bounded_WHILE n' cond step m0 = RES X \\<and>\n        x \\<in> X \\<and> cond x \\<and> step x = FAIL\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>\\<lbrakk>bounded_WHILE n cond step m0 = FAIL;\n                 m0 \\<noteq> FAIL\\<rbrakk>\n                \\<Longrightarrow> \\<exists>n'<n.\n                                     \\<exists>x X.\n  bounded_WHILE n' cond step m0 = RES X \\<and>\n  x \\<in> X \\<and> cond x \\<and> step x = FAIL;\n        bounded_WHILE (Suc n) cond step m0 = FAIL; m0 \\<noteq> FAIL\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n'<Suc n.\n                            \\<exists>x X.\n                               bounded_WHILE n' cond step m0 = RES X \\<and>\n                               x \\<in> X \\<and> cond x \\<and> step x = FAIL", "assume ?C2"], ["proof (state)\nthis:\n  \\<exists>X x.\n     bounded_WHILE n cond step m0 = RES X \\<and>\n     x \\<in> X \\<and> cond x \\<and> step x = FAIL\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>\\<lbrakk>bounded_WHILE n cond step m0 = FAIL;\n                 m0 \\<noteq> FAIL\\<rbrakk>\n                \\<Longrightarrow> \\<exists>n'<n.\n                                     \\<exists>x X.\n  bounded_WHILE n' cond step m0 = RES X \\<and>\n  x \\<in> X \\<and> cond x \\<and> step x = FAIL;\n        bounded_WHILE (Suc n) cond step m0 = FAIL; m0 \\<noteq> FAIL\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n'<Suc n.\n                            \\<exists>x X.\n                               bounded_WHILE n' cond step m0 = RES X \\<and>\n                               x \\<in> X \\<and> cond x \\<and> step x = FAIL", "hence ?case"], ["proof (prove)\nusing this:\n  \\<exists>X x.\n     bounded_WHILE n cond step m0 = RES X \\<and>\n     x \\<in> X \\<and> cond x \\<and> step x = FAIL\n\ngoal (1 subgoal):\n 1. \\<exists>n'<Suc n.\n       \\<exists>x X.\n          bounded_WHILE n' cond step m0 = RES X \\<and>\n          x \\<in> X \\<and> cond x \\<and> step x = FAIL", "by blast"], ["proof (state)\nthis:\n  \\<exists>n'<Suc n.\n     \\<exists>x X.\n        bounded_WHILE n' cond step m0 = RES X \\<and>\n        x \\<in> X \\<and> cond x \\<and> step x = FAIL\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>\\<lbrakk>bounded_WHILE n cond step m0 = FAIL;\n                 m0 \\<noteq> FAIL\\<rbrakk>\n                \\<Longrightarrow> \\<exists>n'<n.\n                                     \\<exists>x X.\n  bounded_WHILE n' cond step m0 = RES X \\<and>\n  x \\<in> X \\<and> cond x \\<and> step x = FAIL;\n        bounded_WHILE (Suc n) cond step m0 = FAIL; m0 \\<noteq> FAIL\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n'<Suc n.\n                            \\<exists>x X.\n                               bounded_WHILE n' cond step m0 = RES X \\<and>\n                               x \\<in> X \\<and> cond x \\<and> step x = FAIL", "}"], ["proof (state)\nthis:\n  \\<exists>X x.\n     bounded_WHILE n cond step m0 = RES X \\<and>\n     x \\<in> X \\<and> cond x \\<and> step x = FAIL \\<Longrightarrow>\n  \\<exists>n'<Suc n.\n     \\<exists>x X.\n        bounded_WHILE n' cond step m0 = RES X \\<and>\n        x \\<in> X \\<and> cond x \\<and> step x = FAIL\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>\\<lbrakk>bounded_WHILE n cond step m0 = FAIL;\n                 m0 \\<noteq> FAIL\\<rbrakk>\n                \\<Longrightarrow> \\<exists>n'<n.\n                                     \\<exists>x X.\n  bounded_WHILE n' cond step m0 = RES X \\<and>\n  x \\<in> X \\<and> cond x \\<and> step x = FAIL;\n        bounded_WHILE (Suc n) cond step m0 = FAIL; m0 \\<noteq> FAIL\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n'<Suc n.\n                            \\<exists>x X.\n                               bounded_WHILE n' cond step m0 = RES X \\<and>\n                               x \\<in> X \\<and> cond x \\<and> step x = FAIL", "ultimately"], ["proof (chain)\npicking this:\n  bounded_WHILE n cond step m0 = FAIL \\<or>\n  (\\<exists>X x.\n      bounded_WHILE n cond step m0 = RES X \\<and>\n      x \\<in> X \\<and> cond x \\<and> step x = FAIL)\n  bounded_WHILE n cond step m0 = FAIL \\<Longrightarrow>\n  \\<exists>n'<Suc n.\n     \\<exists>x X.\n        bounded_WHILE n' cond step m0 = RES X \\<and>\n        x \\<in> X \\<and> cond x \\<and> step x = FAIL\n  \\<exists>X x.\n     bounded_WHILE n cond step m0 = RES X \\<and>\n     x \\<in> X \\<and> cond x \\<and> step x = FAIL \\<Longrightarrow>\n  \\<exists>n'<Suc n.\n     \\<exists>x X.\n        bounded_WHILE n' cond step m0 = RES X \\<and>\n        x \\<in> X \\<and> cond x \\<and> step x = FAIL", "show ?case"], ["proof (prove)\nusing this:\n  bounded_WHILE n cond step m0 = FAIL \\<or>\n  (\\<exists>X x.\n      bounded_WHILE n cond step m0 = RES X \\<and>\n      x \\<in> X \\<and> cond x \\<and> step x = FAIL)\n  bounded_WHILE n cond step m0 = FAIL \\<Longrightarrow>\n  \\<exists>n'<Suc n.\n     \\<exists>x X.\n        bounded_WHILE n' cond step m0 = RES X \\<and>\n        x \\<in> X \\<and> cond x \\<and> step x = FAIL\n  \\<exists>X x.\n     bounded_WHILE n cond step m0 = RES X \\<and>\n     x \\<in> X \\<and> cond x \\<and> step x = FAIL \\<Longrightarrow>\n  \\<exists>n'<Suc n.\n     \\<exists>x X.\n        bounded_WHILE n' cond step m0 = RES X \\<and>\n        x \\<in> X \\<and> cond x \\<and> step x = FAIL\n\ngoal (1 subgoal):\n 1. \\<exists>n'<Suc n.\n       \\<exists>x X.\n          bounded_WHILE n' cond step m0 = RES X \\<and>\n          x \\<in> X \\<and> cond x \\<and> step x = FAIL", "by blast"], ["proof (state)\nthis:\n  \\<exists>n'<Suc n.\n     \\<exists>x X.\n        bounded_WHILE n' cond step m0 = RES X \\<and>\n        x \\<in> X \\<and> cond x \\<and> step x = FAIL\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bounded_WHILE_RES_rwof:\n    assumes \"bounded_WHILE n cond step m0 = RES X\"\n    assumes \"x\\<in>X\"\n    shows \"rwof m0 cond step x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rwof m0 cond step x", "using assms"], ["proof (prove)\nusing this:\n  bounded_WHILE n cond step m0 = RES X\n  x \\<in> X\n\ngoal (1 subgoal):\n 1. rwof m0 cond step x", "proof (induction n arbitrary: x X)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x X.\n       \\<lbrakk>bounded_WHILE 0 cond step m0 = RES X; x \\<in> X\\<rbrakk>\n       \\<Longrightarrow> rwof m0 cond step x\n 2. \\<And>n x X.\n       \\<lbrakk>\\<And>x X.\n                   \\<lbrakk>bounded_WHILE n cond step m0 = RES X;\n                    x \\<in> X\\<rbrakk>\n                   \\<Longrightarrow> rwof m0 cond step x;\n        bounded_WHILE (Suc n) cond step m0 = RES X; x \\<in> X\\<rbrakk>\n       \\<Longrightarrow> rwof m0 cond step x", "case 0"], ["proof (state)\nthis:\n  bounded_WHILE 0 cond step m0 = RES X\n  x \\<in> X\n\ngoal (2 subgoals):\n 1. \\<And>x X.\n       \\<lbrakk>bounded_WHILE 0 cond step m0 = RES X; x \\<in> X\\<rbrakk>\n       \\<Longrightarrow> rwof m0 cond step x\n 2. \\<And>n x X.\n       \\<lbrakk>\\<And>x X.\n                   \\<lbrakk>bounded_WHILE n cond step m0 = RES X;\n                    x \\<in> X\\<rbrakk>\n                   \\<Longrightarrow> rwof m0 cond step x;\n        bounded_WHILE (Suc n) cond step m0 = RES X; x \\<in> X\\<rbrakk>\n       \\<Longrightarrow> rwof m0 cond step x", "thus ?case"], ["proof (prove)\nusing this:\n  bounded_WHILE 0 cond step m0 = RES X\n  x \\<in> X\n\ngoal (1 subgoal):\n 1. rwof m0 cond step x", "by (simp add: rwof.init)"], ["proof (state)\nthis:\n  rwof m0 cond step x\n\ngoal (1 subgoal):\n 1. \\<And>n x X.\n       \\<lbrakk>\\<And>x X.\n                   \\<lbrakk>bounded_WHILE n cond step m0 = RES X;\n                    x \\<in> X\\<rbrakk>\n                   \\<Longrightarrow> rwof m0 cond step x;\n        bounded_WHILE (Suc n) cond step m0 = RES X; x \\<in> X\\<rbrakk>\n       \\<Longrightarrow> rwof m0 cond step x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n x X.\n       \\<lbrakk>\\<And>x X.\n                   \\<lbrakk>bounded_WHILE n cond step m0 = RES X;\n                    x \\<in> X\\<rbrakk>\n                   \\<Longrightarrow> rwof m0 cond step x;\n        bounded_WHILE (Suc n) cond step m0 = RES X; x \\<in> X\\<rbrakk>\n       \\<Longrightarrow> rwof m0 cond step x", "case (Suc n)"], ["proof (state)\nthis:\n  \\<lbrakk>bounded_WHILE n cond step m0 = RES ?X; ?x \\<in> ?X\\<rbrakk>\n  \\<Longrightarrow> rwof m0 cond step ?x\n  bounded_WHILE (Suc n) cond step m0 = RES X\n  x \\<in> X\n\ngoal (1 subgoal):\n 1. \\<And>n x X.\n       \\<lbrakk>\\<And>x X.\n                   \\<lbrakk>bounded_WHILE n cond step m0 = RES X;\n                    x \\<in> X\\<rbrakk>\n                   \\<Longrightarrow> rwof m0 cond step x;\n        bounded_WHILE (Suc n) cond step m0 = RES X; x \\<in> X\\<rbrakk>\n       \\<Longrightarrow> rwof m0 cond step x", "from Suc.prems(1)"], ["proof (chain)\npicking this:\n  bounded_WHILE (Suc n) cond step m0 = RES X", "obtain Xh where\n      BWN: \"bounded_WHILE n cond step m0 = RES Xh\"\n      and \"\\<forall>x\\<in>Xh. cond x \\<longrightarrow> nofail (step x)\"\n      and \"X = {x'. \\<exists>x\\<in>Xh. cond x \\<and> inres (step x) x'} \\<union> {x. x\\<in>Xh \\<and> \\<not>cond x} \""], ["proof (prove)\nusing this:\n  bounded_WHILE (Suc n) cond step m0 = RES X\n\ngoal (1 subgoal):\n 1. (\\<And>Xh.\n        \\<lbrakk>bounded_WHILE n cond step m0 = RES Xh;\n         \\<forall>x\\<in>Xh. cond x \\<longrightarrow> nofail (step x);\n         X =\n         {x'. \\<exists>x\\<in>Xh. cond x \\<and> inres (step x) x'} \\<union>\n         {x \\<in> Xh. \\<not> cond x}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "apply (cases \"bounded_WHILE n cond step m0\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>Xh.\n                \\<lbrakk>bounded_WHILE n cond step m0 = RES Xh;\n                 \\<forall>x\\<in>Xh.\n                    cond x \\<longrightarrow> nofail (step x);\n                 X =\n                 {x'.\n                  \\<exists>x\\<in>Xh.\n                     cond x \\<and> inres (step x) x'} \\<union>\n                 {x \\<in> Xh. \\<not> cond x}\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     bounded_WHILE (Suc n) cond step m0 = RES X;\n     bounded_WHILE n cond step m0 = FAIL\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<And>X.\n       \\<lbrakk>\\<And>Xh.\n                   \\<lbrakk>bounded_WHILE n cond step m0 = RES Xh;\n                    \\<forall>x\\<in>Xh.\n                       cond x \\<longrightarrow> nofail (step x);\n                    X =\n                    {x'.\n                     \\<exists>x\\<in>Xh.\n                        cond x \\<and> inres (step x) x'} \\<union>\n                    {x \\<in> Xh. \\<not> cond x}\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        bounded_WHILE (Suc n) cond step m0 = RES X;\n        bounded_WHILE n cond step m0 = RES X\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>X.\n       \\<lbrakk>\\<And>Xh.\n                   \\<lbrakk>bounded_WHILE n cond step m0 = RES Xh;\n                    \\<forall>x\\<in>Xh.\n                       cond x \\<longrightarrow> nofail (step x);\n                    X =\n                    {x'.\n                     \\<exists>x\\<in>Xh.\n                        cond x \\<and> inres (step x) x'} \\<union>\n                    {x \\<in> Xh. \\<not> cond x}\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        bounded_WHILE (Suc n) cond step m0 = RES X;\n        bounded_WHILE n cond step m0 = RES X\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply (rule that, assumption)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>X.\n       \\<lbrakk>\\<And>Xh.\n                   \\<lbrakk>bounded_WHILE n cond step m0 = RES Xh;\n                    \\<forall>x\\<in>Xh.\n                       cond x \\<longrightarrow> nofail (step x);\n                    X =\n                    {x'.\n                     \\<exists>x\\<in>Xh.\n                        cond x \\<and> inres (step x) x'} \\<union>\n                    {x \\<in> Xh. \\<not> cond x}\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        bounded_WHILE (Suc n) cond step m0 = RES X;\n        bounded_WHILE n cond step m0 = RES X\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x\\<in>X.\n                            cond x \\<longrightarrow> nofail (step x)\n 2. \\<And>X.\n       \\<lbrakk>\\<And>Xh.\n                   \\<lbrakk>bounded_WHILE n cond step m0 = RES Xh;\n                    \\<forall>x\\<in>Xh.\n                       cond x \\<longrightarrow> nofail (step x);\n                    X =\n                    {x'.\n                     \\<exists>x\\<in>Xh.\n                        cond x \\<and> inres (step x) x'} \\<union>\n                    {x \\<in> Xh. \\<not> cond x}\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        bounded_WHILE (Suc n) cond step m0 = RES X;\n        bounded_WHILE n cond step m0 = RES X\\<rbrakk>\n       \\<Longrightarrow> X =\n                         {x'.\n                          \\<exists>x\\<in>X.\n                             cond x \\<and> inres (step x) x'} \\<union>\n                         {x \\<in> X. \\<not> cond x}", "apply (force simp: refine_pw_simps pw_eq_iff) []"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>X.\n       \\<lbrakk>\\<And>Xh.\n                   \\<lbrakk>bounded_WHILE n cond step m0 = RES Xh;\n                    \\<forall>x\\<in>Xh.\n                       cond x \\<longrightarrow> nofail (step x);\n                    X =\n                    {x'.\n                     \\<exists>x\\<in>Xh.\n                        cond x \\<and> inres (step x) x'} \\<union>\n                    {x \\<in> Xh. \\<not> cond x}\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        bounded_WHILE (Suc n) cond step m0 = RES X;\n        bounded_WHILE n cond step m0 = RES X\\<rbrakk>\n       \\<Longrightarrow> X =\n                         {x'.\n                          \\<exists>x\\<in>X.\n                             cond x \\<and> inres (step x) x'} \\<union>\n                         {x \\<in> X. \\<not> cond x}", "apply (auto simp add: refine_pw_simps pw_eq_iff split: if_split_asm)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  bounded_WHILE n cond step m0 = RES Xh\n  \\<forall>x\\<in>Xh. cond x \\<longrightarrow> nofail (step x)\n  X =\n  {x'. \\<exists>x\\<in>Xh. cond x \\<and> inres (step x) x'} \\<union>\n  {x \\<in> Xh. \\<not> cond x}\n\ngoal (1 subgoal):\n 1. \\<And>n x X.\n       \\<lbrakk>\\<And>x X.\n                   \\<lbrakk>bounded_WHILE n cond step m0 = RES X;\n                    x \\<in> X\\<rbrakk>\n                   \\<Longrightarrow> rwof m0 cond step x;\n        bounded_WHILE (Suc n) cond step m0 = RES X; x \\<in> X\\<rbrakk>\n       \\<Longrightarrow> rwof m0 cond step x", "with Suc.prems(2)"], ["proof (chain)\npicking this:\n  x \\<in> X\n  bounded_WHILE n cond step m0 = RES Xh\n  \\<forall>x\\<in>Xh. cond x \\<longrightarrow> nofail (step x)\n  X =\n  {x'. \\<exists>x\\<in>Xh. cond x \\<and> inres (step x) x'} \\<union>\n  {x \\<in> Xh. \\<not> cond x}", "obtain xh X' where \n        \"xh\\<in>Xh\" and\n      C: \"cond xh \\<longrightarrow> step xh = RES X' \\<and> x\\<in>X'\" and NC:  \"\\<not>cond xh \\<longrightarrow> x=xh\""], ["proof (prove)\nusing this:\n  x \\<in> X\n  bounded_WHILE n cond step m0 = RES Xh\n  \\<forall>x\\<in>Xh. cond x \\<longrightarrow> nofail (step x)\n  X =\n  {x'. \\<exists>x\\<in>Xh. cond x \\<and> inres (step x) x'} \\<union>\n  {x \\<in> Xh. \\<not> cond x}\n\ngoal (1 subgoal):\n 1. (\\<And>xh X'.\n        \\<lbrakk>xh \\<in> Xh;\n         cond xh \\<longrightarrow> step xh = RES X' \\<and> x \\<in> X';\n         \\<not> cond xh \\<longrightarrow> x = xh\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: nofail_RES_conv)"], ["proof (state)\nthis:\n  xh \\<in> Xh\n  cond xh \\<longrightarrow> step xh = RES X' \\<and> x \\<in> X'\n  \\<not> cond xh \\<longrightarrow> x = xh\n\ngoal (1 subgoal):\n 1. \\<And>n x X.\n       \\<lbrakk>\\<And>x X.\n                   \\<lbrakk>bounded_WHILE n cond step m0 = RES X;\n                    x \\<in> X\\<rbrakk>\n                   \\<Longrightarrow> rwof m0 cond step x;\n        bounded_WHILE (Suc n) cond step m0 = RES X; x \\<in> X\\<rbrakk>\n       \\<Longrightarrow> rwof m0 cond step x", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. rwof m0 cond step x", "apply (cases \"cond xh\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. cond xh \\<Longrightarrow> rwof m0 cond step x\n 2. \\<not> cond xh \\<Longrightarrow> rwof m0 cond step x", "apply (rule rwof.step[where Y=X'])"], ["proof (prove)\ngoal (5 subgoals):\n 1. cond xh \\<Longrightarrow> rwof m0 cond step ?x1\n 2. cond xh \\<Longrightarrow> cond ?x1\n 3. cond xh \\<Longrightarrow> step ?x1 = RES X'\n 4. cond xh \\<Longrightarrow> x \\<in> X'\n 5. \\<not> cond xh \\<Longrightarrow> rwof m0 cond step x", "apply (rule Suc.IH[OF BWN \\<open>xh\\<in>Xh\\<close>])"], ["proof (prove)\ngoal (4 subgoals):\n 1. cond xh \\<Longrightarrow> cond xh\n 2. cond xh \\<Longrightarrow> step xh = RES X'\n 3. cond xh \\<Longrightarrow> x \\<in> X'\n 4. \\<not> cond xh \\<Longrightarrow> rwof m0 cond step x", "apply assumption"], ["proof (prove)\ngoal (3 subgoals):\n 1. cond xh \\<Longrightarrow> step xh = RES X'\n 2. cond xh \\<Longrightarrow> x \\<in> X'\n 3. \\<not> cond xh \\<Longrightarrow> rwof m0 cond step x", "apply (simp_all add: C) [2]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> cond xh \\<Longrightarrow> rwof m0 cond step x", "apply (rule Suc.IH[OF BWN])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> cond xh \\<Longrightarrow> x \\<in> Xh", "apply (simp add: NC \\<open>xh\\<in>Xh\\<close>)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  rwof m0 cond step x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rwof_FAIL_imp_WHILE_FAIL:\n    assumes RW: \"rwof m0 cond step s\" \n    and C: \"cond s\" \n    and S: \"step s = FAIL\"\n    shows \"m0 \\<bind> WHILE cond step = FAIL\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m0 \\<bind> WHILE cond step = FAIL", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. m0 \\<bind> WHILE cond step = FAIL", "from rwof_in_bounded_WHILE[OF RW]"], ["proof (chain)\npicking this:\n  \\<exists>n. RETURN s \\<le> bounded_WHILE n cond step m0", "obtain n where \n      \"RETURN s \\<le> bounded_WHILE n cond step m0\""], ["proof (prove)\nusing this:\n  \\<exists>n. RETURN s \\<le> bounded_WHILE n cond step m0\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        RETURN s \\<le> bounded_WHILE n cond step m0 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  RETURN s \\<le> bounded_WHILE n cond step m0\n\ngoal (1 subgoal):\n 1. m0 \\<bind> WHILE cond step = FAIL", "with C"], ["proof (chain)\npicking this:\n  cond s\n  RETURN s \\<le> bounded_WHILE n cond step m0", "have \"step s \\<le> bounded_WHILE (Suc n) cond step m0\""], ["proof (prove)\nusing this:\n  cond s\n  RETURN s \\<le> bounded_WHILE n cond step m0\n\ngoal (1 subgoal):\n 1. step s \\<le> bounded_WHILE (Suc n) cond step m0", "by (auto simp add: pw_le_iff refine_pw_simps)"], ["proof (state)\nthis:\n  step s \\<le> bounded_WHILE (Suc n) cond step m0\n\ngoal (1 subgoal):\n 1. m0 \\<bind> WHILE cond step = FAIL", "with S"], ["proof (chain)\npicking this:\n  step s = FAIL\n  step s \\<le> bounded_WHILE (Suc n) cond step m0", "have \"bounded_WHILE (Suc n) cond step m0 = FAIL\""], ["proof (prove)\nusing this:\n  step s = FAIL\n  step s \\<le> bounded_WHILE (Suc n) cond step m0\n\ngoal (1 subgoal):\n 1. bounded_WHILE (Suc n) cond step m0 = FAIL", "by simp"], ["proof (state)\nthis:\n  bounded_WHILE (Suc n) cond step m0 = FAIL\n\ngoal (1 subgoal):\n 1. m0 \\<bind> WHILE cond step = FAIL", "with WHILE_bounded_aux1[of cond \"Suc n\" step m0]"], ["proof (chain)\npicking this:\n  filter_nb cond (bounded_WHILE (Suc n) cond step m0)\n  \\<le> m0 \\<bind> WHILE cond step\n  bounded_WHILE (Suc n) cond step m0 = FAIL", "show ?thesis"], ["proof (prove)\nusing this:\n  filter_nb cond (bounded_WHILE (Suc n) cond step m0)\n  \\<le> m0 \\<bind> WHILE cond step\n  bounded_WHILE (Suc n) cond step m0 = FAIL\n\ngoal (1 subgoal):\n 1. m0 \\<bind> WHILE cond step = FAIL", "by (simp del: bounded_WHILE.simps)"], ["proof (state)\nthis:\n  m0 \\<bind> WHILE cond step = FAIL\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma pw_bounded_WHILE_RES_rwof: \"\\<lbrakk> nofail (bounded_WHILE n cond step m0); \n    inres (bounded_WHILE n cond step m0) x \\<rbrakk> \\<Longrightarrow> rwof m0 cond step x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>nofail (bounded_WHILE n cond step m0);\n     inres (bounded_WHILE n cond step m0) x\\<rbrakk>\n    \\<Longrightarrow> rwof m0 cond step x", "using bounded_WHILE_RES_rwof[of n cond step m0 _ x]"], ["proof (prove)\nusing this:\n  \\<lbrakk>bounded_WHILE n cond step m0 = RES ?X; x \\<in> ?X\\<rbrakk>\n  \\<Longrightarrow> rwof m0 cond step x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>nofail (bounded_WHILE n cond step m0);\n     inres (bounded_WHILE n cond step m0) x\\<rbrakk>\n    \\<Longrightarrow> rwof m0 cond step x", "by (auto simp add: pw_eq_iff)"], ["", "corollary WHILE_nofail_imp_rwof_nofail:\n    assumes \"nofail (m0 \\<bind> WHILE cond step)\"\n    assumes RW: \"rwof m0 cond step s\" \n    assumes C: \"cond s\"\n    shows \"nofail (step s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nofail (step s)", "apply (rule ccontr)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> nofail (step s) \\<Longrightarrow> False", "apply (simp add: nofail_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. step s = FAIL \\<Longrightarrow> False", "using assms rwof_FAIL_imp_WHILE_FAIL[OF RW C]"], ["proof (prove)\nusing this:\n  nofail (m0 \\<bind> WHILE cond step)\n  rwof m0 cond step s\n  cond s\n  step s = FAIL \\<Longrightarrow> m0 \\<bind> WHILE cond step = FAIL\n\ngoal (1 subgoal):\n 1. step s = FAIL \\<Longrightarrow> False", "by auto"], ["", "(* TODO: Move *)"], ["", "lemma WHILE_le_WHILEI: \"WHILE b f s \\<le> WHILEI I b f s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. WHILE b f s \\<le> WHILE\\<^bsup>I\\<^esup> b f s", "unfolding WHILE_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. WHILE\\<^bsup>\\<lambda>_. True\\<^esup> b f s\n    \\<le> WHILE\\<^bsup>I\\<^esup> b f s", "by (rule WHILEI_weaken) simp"], ["", "corollary WHILEI_nofail_imp_rwof_nofail:\n    assumes NF: \"nofail (m0 \\<bind> WHILEI I cond step)\"\n    assumes RW: \"rwof m0 cond step s\" \n    assumes C: \"cond s\"\n    shows \"nofail (step s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nofail (step s)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. nofail (step s)", "from NF"], ["proof (chain)\npicking this:\n  nofail (m0 \\<bind> WHILE\\<^bsup>I\\<^esup> cond step)", "have \"nofail (m0 \\<bind> WHILE cond step)\""], ["proof (prove)\nusing this:\n  nofail (m0 \\<bind> WHILE\\<^bsup>I\\<^esup> cond step)\n\ngoal (1 subgoal):\n 1. nofail (m0 \\<bind> WHILE cond step)", "using WHILE_le_WHILEI"], ["proof (prove)\nusing this:\n  nofail (m0 \\<bind> WHILE\\<^bsup>I\\<^esup> cond step)\n  WHILE ?b ?f ?s \\<le> WHILE\\<^bsup>?I\\<^esup> ?b ?f ?s\n\ngoal (1 subgoal):\n 1. nofail (m0 \\<bind> WHILE cond step)", "by (fastforce simp: pw_le_iff refine_pw_simps)"], ["proof (state)\nthis:\n  nofail (m0 \\<bind> WHILE cond step)\n\ngoal (1 subgoal):\n 1. nofail (step s)", "from WHILE_nofail_imp_rwof_nofail[OF this RW C]"], ["proof (chain)\npicking this:\n  nofail (step s)", "show ?thesis"], ["proof (prove)\nusing this:\n  nofail (step s)\n\ngoal (1 subgoal):\n 1. nofail (step s)", "."], ["proof (state)\nthis:\n  nofail (step s)\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary WHILET_nofail_imp_rwof_nofail:\n    assumes NF: \"nofail (m0 \\<bind> WHILET cond step)\"\n    assumes RW: \"rwof m0 cond step s\" \n    assumes C: \"cond s\"\n    shows \"nofail (step s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nofail (step s)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. nofail (step s)", "from NF"], ["proof (chain)\npicking this:\n  nofail (m0 \\<bind> WHILE\\<^sub>T cond step)", "have \"nofail (m0 \\<bind> WHILE cond step)\""], ["proof (prove)\nusing this:\n  nofail (m0 \\<bind> WHILE\\<^sub>T cond step)\n\ngoal (1 subgoal):\n 1. nofail (m0 \\<bind> WHILE cond step)", "using WHILEI_le_WHILEIT"], ["proof (prove)\nusing this:\n  nofail (m0 \\<bind> WHILE\\<^sub>T cond step)\n  WHILE\\<^bsup>?I\\<^esup> ?b ?f ?s\n  \\<le> WHILE\\<^sub>T\\<^bsup>?I\\<^esup> ?b ?f ?s\n\ngoal (1 subgoal):\n 1. nofail (m0 \\<bind> WHILE cond step)", "unfolding WHILE_def WHILET_def"], ["proof (prove)\nusing this:\n  nofail\n   (m0 \\<bind> WHILE\\<^sub>T\\<^bsup>\\<lambda>_. True\\<^esup> cond step)\n  WHILE\\<^bsup>?I\\<^esup> ?b ?f ?s\n  \\<le> WHILE\\<^sub>T\\<^bsup>?I\\<^esup> ?b ?f ?s\n\ngoal (1 subgoal):\n 1. nofail (m0 \\<bind> WHILE\\<^bsup>\\<lambda>_. True\\<^esup> cond step)", "by (fastforce simp: pw_le_iff refine_pw_simps)"], ["proof (state)\nthis:\n  nofail (m0 \\<bind> WHILE cond step)\n\ngoal (1 subgoal):\n 1. nofail (step s)", "from WHILE_nofail_imp_rwof_nofail[OF this RW C]"], ["proof (chain)\npicking this:\n  nofail (step s)", "show ?thesis"], ["proof (prove)\nusing this:\n  nofail (step s)\n\ngoal (1 subgoal):\n 1. nofail (step s)", "."], ["proof (state)\nthis:\n  nofail (step s)\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary WHILEIT_nofail_imp_rwof_nofail:\n    assumes NF: \"nofail (m0 \\<bind> WHILEIT I cond step)\"\n    assumes RW: \"rwof m0 cond step s\" \n    assumes C: \"cond s\"\n    shows \"nofail (step s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nofail (step s)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. nofail (step s)", "from NF"], ["proof (chain)\npicking this:\n  nofail (m0 \\<bind> WHILE\\<^sub>T\\<^bsup>I\\<^esup> cond step)", "have \"nofail (m0 \\<bind> WHILE cond step)\""], ["proof (prove)\nusing this:\n  nofail (m0 \\<bind> WHILE\\<^sub>T\\<^bsup>I\\<^esup> cond step)\n\ngoal (1 subgoal):\n 1. nofail (m0 \\<bind> WHILE cond step)", "using WHILE_le_WHILEI WHILEI_le_WHILEIT"], ["proof (prove)\nusing this:\n  nofail (m0 \\<bind> WHILE\\<^sub>T\\<^bsup>I\\<^esup> cond step)\n  WHILE ?b ?f ?s \\<le> WHILE\\<^bsup>?I\\<^esup> ?b ?f ?s\n  WHILE\\<^bsup>?I\\<^esup> ?b ?f ?s\n  \\<le> WHILE\\<^sub>T\\<^bsup>?I\\<^esup> ?b ?f ?s\n\ngoal (1 subgoal):\n 1. nofail (m0 \\<bind> WHILE cond step)", "unfolding WHILE_def"], ["proof (prove)\nusing this:\n  nofail (m0 \\<bind> WHILE\\<^sub>T\\<^bsup>I\\<^esup> cond step)\n  WHILE\\<^bsup>\\<lambda>_. True\\<^esup> ?b ?f ?s\n  \\<le> WHILE\\<^bsup>?I\\<^esup> ?b ?f ?s\n  WHILE\\<^bsup>?I\\<^esup> ?b ?f ?s\n  \\<le> WHILE\\<^sub>T\\<^bsup>?I\\<^esup> ?b ?f ?s\n\ngoal (1 subgoal):\n 1. nofail (m0 \\<bind> WHILE\\<^bsup>\\<lambda>_. True\\<^esup> cond step)", "by (fastforce simp: pw_le_iff refine_pw_simps)"], ["proof (state)\nthis:\n  nofail (m0 \\<bind> WHILE cond step)\n\ngoal (1 subgoal):\n 1. nofail (step s)", "from WHILE_nofail_imp_rwof_nofail[OF this RW C]"], ["proof (chain)\npicking this:\n  nofail (step s)", "show ?thesis"], ["proof (prove)\nusing this:\n  nofail (step s)\n\ngoal (1 subgoal):\n 1. nofail (step s)", "."], ["proof (state)\nthis:\n  nofail (step s)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma pw_rwof_in_bounded_WHILE:\n    \"rwof m0 cond step x \\<Longrightarrow> \\<exists>n. inres (bounded_WHILE n cond step m0) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rwof m0 cond step x \\<Longrightarrow>\n    \\<exists>n. inres (bounded_WHILE n cond step m0) x", "using rwof_in_bounded_WHILE[of m0 cond step x]"], ["proof (prove)\nusing this:\n  rwof m0 cond step x \\<Longrightarrow>\n  \\<exists>n. RETURN x \\<le> bounded_WHILE n cond step m0\n\ngoal (1 subgoal):\n 1. rwof m0 cond step x \\<Longrightarrow>\n    \\<exists>n. inres (bounded_WHILE n cond step m0) x", "by (auto simp add: pw_le_iff intro: not_nofail_inres)"], ["", "subsubsection \\<open>WHILE-loops in the nofail-case\\<close>"], ["", "lemma nofail_WHILE_eq_rwof: \n    assumes NF: \"nofail (m0 \\<bind> WHILE cond step)\"\n    shows \"m0 \\<bind> WHILE cond step = SPEC (\\<lambda>s. rwof m0 cond step s \\<and> \\<not>cond s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m0 \\<bind> WHILE cond step =\n    SPEC (\\<lambda>s. rwof m0 cond step s \\<and> \\<not> cond s)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. m0 \\<bind> WHILE cond step =\n    SPEC (\\<lambda>s. rwof m0 cond step s \\<and> \\<not> cond s)", "from NF WHILE_bounded[of m0 cond step]"], ["proof (chain)\npicking this:\n  nofail (m0 \\<bind> WHILE cond step)\n  m0 \\<bind> WHILE cond step =\n  filter_nb cond (Sup {bounded_WHILE n cond step m0 |n. True})", "have NF': \n      \"nofail (Sup {filter_nb cond m |m. \\<exists>n. m = bounded_WHILE n cond step m0})\""], ["proof (prove)\nusing this:\n  nofail (m0 \\<bind> WHILE cond step)\n  m0 \\<bind> WHILE cond step =\n  filter_nb cond (Sup {bounded_WHILE n cond step m0 |n. True})\n\ngoal (1 subgoal):\n 1. nofail\n     (Sup {filter_nb cond m |m.\n           \\<exists>n. m = bounded_WHILE n cond step m0})", "by (auto simp: filter_nb_cont)"], ["proof (state)\nthis:\n  nofail\n   (Sup {filter_nb cond m |m. \\<exists>n. m = bounded_WHILE n cond step m0})\n\ngoal (1 subgoal):\n 1. m0 \\<bind> WHILE cond step =\n    SPEC (\\<lambda>s. rwof m0 cond step s \\<and> \\<not> cond s)", "(*from NF WHILE_bounded[of m0 cond step] obtain X \n      where FR:\n        \"Sup {filter_nb cond m |m. \\<exists>n. m = bounded_WHILE n cond step m0} = RES X\"\n      by (auto simp: nofail_RES_conv filter_nb_cont)*)"], ["proof (state)\nthis:\n  nofail\n   (Sup {filter_nb cond m |m. \\<exists>n. m = bounded_WHILE n cond step m0})\n\ngoal (1 subgoal):\n 1. m0 \\<bind> WHILE cond step =\n    SPEC (\\<lambda>s. rwof m0 cond step s \\<and> \\<not> cond s)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. m0 \\<bind> WHILE cond step =\n    SPEC (\\<lambda>s. rwof m0 cond step s \\<and> \\<not> cond s)", "unfolding WHILE_bounded[of m0 cond step] filter_nb_cont"], ["proof (prove)\ngoal (1 subgoal):\n 1. Sup {filter_nb cond m |m.\n         m \\<in> {bounded_WHILE n cond step m0 |n. True}} =\n    SPEC (\\<lambda>s. rwof m0 cond step s \\<and> \\<not> cond s)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. Sup {filter_nb cond m |m.\n         \\<exists>n. m = bounded_WHILE n cond step m0} =\n    SPEC (\\<lambda>s. rwof m0 cond step s \\<and> \\<not> cond s)", "proof (rule antisym)"], ["proof (state)\ngoal (2 subgoals):\n 1. Sup {filter_nb cond m |m. \\<exists>n. m = bounded_WHILE n cond step m0}\n    \\<le> SPEC (\\<lambda>s. rwof m0 cond step s \\<and> \\<not> cond s)\n 2. SPEC (\\<lambda>s. rwof m0 cond step s \\<and> \\<not> cond s)\n    \\<le> Sup {filter_nb cond m |m.\n               \\<exists>n. m = bounded_WHILE n cond step m0}", "show \"Sup {filter_nb cond m |m. \\<exists>n. m = bounded_WHILE n cond step m0}\n        \\<le> SPEC (\\<lambda>s. rwof m0 cond step s \\<and> \\<not> cond s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Sup {filter_nb cond m |m. \\<exists>n. m = bounded_WHILE n cond step m0}\n    \\<le> SPEC (\\<lambda>s. rwof m0 cond step s \\<and> \\<not> cond s)", "using NF' pw_bounded_WHILE_RES_rwof[of _ cond step m0]"], ["proof (prove)\nusing this:\n  nofail\n   (Sup {filter_nb cond m |m. \\<exists>n. m = bounded_WHILE n cond step m0})\n  \\<lbrakk>nofail (bounded_WHILE ?n cond step m0);\n   inres (bounded_WHILE ?n cond step m0) ?x\\<rbrakk>\n  \\<Longrightarrow> rwof m0 cond step ?x\n\ngoal (1 subgoal):\n 1. Sup {filter_nb cond m |m. \\<exists>n. m = bounded_WHILE n cond step m0}\n    \\<le> SPEC (\\<lambda>s. rwof m0 cond step s \\<and> \\<not> cond s)", "by (fastforce simp: pw_le_iff refine_pw_simps)"], ["proof (state)\nthis:\n  Sup {filter_nb cond m |m. \\<exists>n. m = bounded_WHILE n cond step m0}\n  \\<le> SPEC (\\<lambda>s. rwof m0 cond step s \\<and> \\<not> cond s)\n\ngoal (1 subgoal):\n 1. SPEC (\\<lambda>s. rwof m0 cond step s \\<and> \\<not> cond s)\n    \\<le> Sup {filter_nb cond m |m.\n               \\<exists>n. m = bounded_WHILE n cond step m0}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. SPEC (\\<lambda>s. rwof m0 cond step s \\<and> \\<not> cond s)\n    \\<le> Sup {filter_nb cond m |m.\n               \\<exists>n. m = bounded_WHILE n cond step m0}", "show \"SPEC (\\<lambda>s. rwof m0 cond step s \\<and> \\<not> cond s)\n        \\<le> Sup {filter_nb cond m |m. \\<exists>n. m = bounded_WHILE n cond step m0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SPEC (\\<lambda>s. rwof m0 cond step s \\<and> \\<not> cond s)\n    \\<le> Sup {filter_nb cond m |m.\n               \\<exists>n. m = bounded_WHILE n cond step m0}", "using NF' pw_rwof_in_bounded_WHILE[of m0 cond step]"], ["proof (prove)\nusing this:\n  nofail\n   (Sup {filter_nb cond m |m. \\<exists>n. m = bounded_WHILE n cond step m0})\n  rwof m0 cond step ?x \\<Longrightarrow>\n  \\<exists>n. inres (bounded_WHILE n cond step m0) ?x\n\ngoal (1 subgoal):\n 1. SPEC (\\<lambda>s. rwof m0 cond step s \\<and> \\<not> cond s)\n    \\<le> Sup {filter_nb cond m |m.\n               \\<exists>n. m = bounded_WHILE n cond step m0}", "by (fastforce simp: pw_le_iff refine_pw_simps)"], ["proof (state)\nthis:\n  SPEC (\\<lambda>s. rwof m0 cond step s \\<and> \\<not> cond s)\n  \\<le> Sup {filter_nb cond m |m.\n             \\<exists>n. m = bounded_WHILE n cond step m0}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  m0 \\<bind> WHILE cond step =\n  SPEC (\\<lambda>s. rwof m0 cond step s \\<and> \\<not> cond s)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma WHILE_refine_rwof:\n    assumes \"nofail (m \\<bind> WHILE c f) \\<Longrightarrow> mi \\<le> SPEC (\\<lambda>s. rwof m c f s \\<and> \\<not>c s)\"\n    shows \"mi \\<le> m \\<bind> WHILE c f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mi \\<le> m \\<bind> WHILE c f", "apply (cases \"nofail (m \\<bind> WHILE c f)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. nofail (m \\<bind> WHILE c f) \\<Longrightarrow>\n    mi \\<le> m \\<bind> WHILE c f\n 2. \\<not> nofail (m \\<bind> WHILE c f) \\<Longrightarrow>\n    mi \\<le> m \\<bind> WHILE c f", "apply (subst nofail_WHILE_eq_rwof, simp, fact)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> nofail (m \\<bind> WHILE c f) \\<Longrightarrow>\n    mi \\<le> m \\<bind> WHILE c f", "apply (simp add: pw_le_iff)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma pw_rwof_init:\n    assumes NF: \"nofail (m0 \\<bind> WHILE cond step)\"\n    shows \"inres m0 s \\<Longrightarrow> rwof m0 cond step s\" and \"nofail m0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (inres m0 s \\<Longrightarrow> rwof m0 cond step s) &&& nofail m0", "apply -"], ["proof (prove)\ngoal (2 subgoals):\n 1. inres m0 s \\<Longrightarrow> rwof m0 cond step s\n 2. nofail m0", "using NF"], ["proof (prove)\nusing this:\n  nofail (m0 \\<bind> WHILE cond step)\n\ngoal (2 subgoals):\n 1. inres m0 s \\<Longrightarrow> rwof m0 cond step s\n 2. nofail m0", "apply (cases m0, simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>X.\n       \\<lbrakk>inres m0 s; nofail (m0 \\<bind> WHILE cond step);\n        m0 = RES X\\<rbrakk>\n       \\<Longrightarrow> rwof m0 cond step s\n 2. nofail m0", "apply (rule rwof.init, assumption)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>X.\n       \\<lbrakk>inres m0 s; nofail (m0 \\<bind> WHILE cond step);\n        m0 = RES X\\<rbrakk>\n       \\<Longrightarrow> s \\<in> X\n 2. nofail m0", "apply auto []"], ["proof (prove)\ngoal (1 subgoal):\n 1. nofail m0", "using NF"], ["proof (prove)\nusing this:\n  nofail (m0 \\<bind> WHILE cond step)\n\ngoal (1 subgoal):\n 1. nofail m0", "apply (simp add: refine_pw_simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma rwof_init:\n    assumes NF: \"nofail (m0 \\<bind> WHILE cond step)\" \n    shows \"m0 \\<le> SPEC (rwof m0 cond step)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m0 \\<le> SPEC (rwof m0 cond step)", "using pw_rwof_init[OF NF]"], ["proof (prove)\nusing this:\n  inres m0 ?s \\<Longrightarrow> rwof m0 cond step ?s\n  nofail m0\n\ngoal (1 subgoal):\n 1. m0 \\<le> SPEC (rwof m0 cond step)", "by (simp add: pw_le_iff refine_pw_simps)"], ["", "lemma pw_rwof_step':\n    assumes NF: \"nofail (step s)\"\n    assumes R: \"rwof m0 cond step s\"\n    assumes C: \"cond s\"\n    shows \"inres (step s) s' \\<Longrightarrow> rwof m0 cond step s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inres (step s) s' \\<Longrightarrow> rwof m0 cond step s'", "using NF"], ["proof (prove)\nusing this:\n  nofail (step s)\n\ngoal (1 subgoal):\n 1. inres (step s) s' \\<Longrightarrow> rwof m0 cond step s'", "apply (clarsimp simp: nofail_RES_conv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>M.\n       \\<lbrakk>s' \\<in> M; step s = RES M\\<rbrakk>\n       \\<Longrightarrow> rwof m0 cond step s'", "apply (rule rwof.step[OF R C])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>M.\n       \\<lbrakk>s' \\<in> M; step s = RES M\\<rbrakk>\n       \\<Longrightarrow> step s = RES (?Y2 M)\n 2. \\<And>M.\n       \\<lbrakk>s' \\<in> M; step s = RES M\\<rbrakk>\n       \\<Longrightarrow> s' \\<in> ?Y2 M", "apply (assumption)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>M.\n       \\<lbrakk>s' \\<in> M; step s = RES M\\<rbrakk>\n       \\<Longrightarrow> s' \\<in> M", "by simp"], ["", "lemma rwof_step': \n    \"\\<lbrakk> nofail (step s); rwof m0 cond step s; cond s \\<rbrakk>\n    \\<Longrightarrow> step s \\<le> SPEC (rwof m0 cond step)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>nofail (step s); rwof m0 cond step s; cond s\\<rbrakk>\n    \\<Longrightarrow> step s \\<le> SPEC (rwof m0 cond step)", "using pw_rwof_step'[of step s m0 cond]"], ["proof (prove)\nusing this:\n  \\<lbrakk>nofail (step s); rwof m0 cond step s; cond s;\n   inres (step s) ?s'\\<rbrakk>\n  \\<Longrightarrow> rwof m0 cond step ?s'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>nofail (step s); rwof m0 cond step s; cond s\\<rbrakk>\n    \\<Longrightarrow> step s \\<le> SPEC (rwof m0 cond step)", "by (simp add: pw_le_iff refine_pw_simps)"], ["", "lemma pw_rwof_step:\n    assumes NF: \"nofail (m0 \\<bind> WHILE cond step)\"\n    assumes R: \"rwof m0 cond step s\"\n    assumes C: \"cond s\"\n    shows \"inres (step s) s' \\<Longrightarrow> rwof m0 cond step s'\"\n      and \"nofail (step s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (inres (step s) s' \\<Longrightarrow> rwof m0 cond step s') &&&\n    nofail (step s)", "using WHILE_nofail_imp_rwof_nofail[OF NF R C] pw_rwof_step'[OF _ assms(2-)]"], ["proof (prove)\nusing this:\n  nofail (step s)\n  \\<lbrakk>nofail (step s); inres (step s) ?s'\\<rbrakk>\n  \\<Longrightarrow> rwof m0 cond step ?s'\n\ngoal (1 subgoal):\n 1. (inres (step s) s' \\<Longrightarrow> rwof m0 cond step s') &&&\n    nofail (step s)", "by simp_all"], ["", "lemma rwof_step: \n    \"\\<lbrakk> nofail (m0 \\<bind> WHILE cond step); rwof m0 cond step s; cond s \\<rbrakk>\n    \\<Longrightarrow> step s \\<le> SPEC (rwof m0 cond step)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>nofail (m0 \\<bind> WHILE cond step); rwof m0 cond step s;\n     cond s\\<rbrakk>\n    \\<Longrightarrow> step s \\<le> SPEC (rwof m0 cond step)", "using pw_rwof_step[of m0 cond step s]"], ["proof (prove)\nusing this:\n  \\<lbrakk>nofail (m0 \\<bind> WHILE cond step); rwof m0 cond step s; cond s;\n   inres (step s) ?s'\\<rbrakk>\n  \\<Longrightarrow> rwof m0 cond step ?s'\n  \\<lbrakk>nofail (m0 \\<bind> WHILE cond step); rwof m0 cond step s;\n   cond s\\<rbrakk>\n  \\<Longrightarrow> nofail (step s)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>nofail (m0 \\<bind> WHILE cond step); rwof m0 cond step s;\n     cond s\\<rbrakk>\n    \\<Longrightarrow> step s \\<le> SPEC (rwof m0 cond step)", "by (simp add: pw_le_iff refine_pw_simps)"], ["", "lemma (in -) rwof_leof_init: \"m \\<le>\\<^sub>n SPEC (rwof m c f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<le>\\<^sub>n SPEC (rwof m c f)", "apply rule"], ["proof (prove)\ngoal (1 subgoal):\n 1. nofail m \\<Longrightarrow> m \\<le> SPEC (rwof m c f)", "using rwof.init"], ["proof (prove)\nusing this:\n  \\<lbrakk>?m0.0 = RES ?X; ?x \\<in> ?X\\<rbrakk>\n  \\<Longrightarrow> rwof ?m0.0 ?cond ?step ?x\n\ngoal (1 subgoal):\n 1. nofail m \\<Longrightarrow> m \\<le> SPEC (rwof m c f)", "apply (fastforce simp: nofail_RES_conv)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma (in -) rwof_leof_step: \"\\<lbrakk>rwof m c f s; c s\\<rbrakk> \\<Longrightarrow> f s \\<le>\\<^sub>n SPEC (rwof m c f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>rwof m c f s; c s\\<rbrakk>\n    \\<Longrightarrow> f s \\<le>\\<^sub>n SPEC (rwof m c f)", "apply rule"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>rwof m c f s; c s; nofail (f s)\\<rbrakk>\n    \\<Longrightarrow> f s \\<le> SPEC (rwof m c f)", "using rwof.step"], ["proof (prove)\nusing this:\n  \\<lbrakk>rwof ?m0.0 ?cond ?step ?x; ?cond ?x; ?step ?x = RES ?Y;\n   ?y \\<in> ?Y\\<rbrakk>\n  \\<Longrightarrow> rwof ?m0.0 ?cond ?step ?y\n\ngoal (1 subgoal):\n 1. \\<lbrakk>rwof m c f s; c s; nofail (f s)\\<rbrakk>\n    \\<Longrightarrow> f s \\<le> SPEC (rwof m c f)", "apply (fastforce simp: nofail_RES_conv)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma (in -) rwof_step_refine:\n    assumes NF: \"nofail (m0 \\<bind> WHILE cond step)\"  \n    assumes A: \"rwof m0 cond step' s\"\n    assumes FR: \"\\<And>s. \\<lbrakk> rwof m0 cond step s; cond s \\<rbrakk> \\<Longrightarrow> step' s \\<le>\\<^sub>n step s\"\n    shows \"rwof m0 cond step s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rwof m0 cond step s", "apply (rule establish_rwof_invar[OF _ _ A])"], ["proof (prove)\ngoal (2 subgoals):\n 1. m0 \\<le>\\<^sub>n SPEC (rwof m0 cond step)\n 2. \\<And>s.\n       \\<lbrakk>rwof m0 cond step' s; rwof m0 cond step s; cond s\\<rbrakk>\n       \\<Longrightarrow> step' s \\<le>\\<^sub>n SPEC (rwof m0 cond step)", "apply (rule rwof_leof_init)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>rwof m0 cond step' s; rwof m0 cond step s; cond s\\<rbrakk>\n       \\<Longrightarrow> step' s \\<le>\\<^sub>n SPEC (rwof m0 cond step)", "apply (rule leof_trans_nofail[OF FR], assumption+)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>rwof m0 cond step' s; rwof m0 cond step s; cond s\\<rbrakk>\n       \\<Longrightarrow> nofail (step s)\n 2. \\<And>s.\n       \\<lbrakk>rwof m0 cond step' s; rwof m0 cond step s; cond s\\<rbrakk>\n       \\<Longrightarrow> step s \\<le>\\<^sub>n SPEC (rwof m0 cond step)", "apply (rule WHILE_nofail_imp_rwof_nofail[OF NF], assumption+)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>rwof m0 cond step' s; rwof m0 cond step s; cond s\\<rbrakk>\n       \\<Longrightarrow> step s \\<le>\\<^sub>n SPEC (rwof m0 cond step)", "apply (simp add: rwof_leof_step)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsubsection \\<open>Adding Invariants\\<close>"], ["", "lemma WHILE_eq_I_rwof: \"m \\<bind> WHILE c f = m \\<bind> WHILEI (rwof m c f) c f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<bind> WHILE c f = m \\<bind> WHILE\\<^bsup>rwof m c f\\<^esup> c f", "proof (rule antisym)"], ["proof (state)\ngoal (2 subgoals):\n 1. m \\<bind> WHILE c f \\<le> m \\<bind> WHILE\\<^bsup>rwof m c f\\<^esup> c f\n 2. m \\<bind> WHILE\\<^bsup>rwof m c f\\<^esup> c f \\<le> m \\<bind> WHILE c f", "have \"m \\<bind> WHILEI (rwof m c f) c f\n      \\<le> \\<Down>{(s,s) | s. rwof m c f s} \n        (m \\<bind> WHILE c f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<bind> WHILE\\<^bsup>rwof m c f\\<^esup> c f\n    \\<le> \\<Down> {(s, s) |s. rwof m c f s} (m \\<bind> WHILE c f)", "unfolding WHILE_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<bind> WHILE\\<^bsup>rwof m c f\\<^esup> c f\n    \\<le> \\<Down> {(s, s) |s. rwof m c f s}\n           (m \\<bind> WHILE\\<^bsup>\\<lambda>_. True\\<^esup> c f)", "apply (rule bind_refine)"], ["proof (prove)\ngoal (2 subgoals):\n 1. m \\<le> \\<Down> ?R' m\n 2. \\<And>x x'.\n       (x, x') \\<in> ?R' \\<Longrightarrow>\n       WHILE\\<^bsup>rwof m c f\\<^esup> c f x\n       \\<le> \\<Down> {(s, s) |s. rwof m c f s}\n              (WHILE\\<^bsup>\\<lambda>_. True\\<^esup> c f x')", "apply (rule intro_prgR[where R=\"{(s,s) | s. rwof m c f s}\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. m \\<le> \\<Down> {(s, s) |s. rwof m c f s} m\n 2. \\<And>x x'.\n       (x, x') \\<in> {(s, s) |s. rwof m c f s} \\<Longrightarrow>\n       WHILE\\<^bsup>rwof m c f\\<^esup> c f x\n       \\<le> \\<Down> {(s, s) |s. rwof m c f s}\n              (WHILE\\<^bsup>\\<lambda>_. True\\<^esup> c f x')", "apply (auto simp: pw_le_iff refine_pw_simps) []"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>nofail m; inres m x\\<rbrakk> \\<Longrightarrow> rwof m c f x\n 2. \\<And>x x'.\n       (x, x') \\<in> {(s, s) |s. rwof m c f s} \\<Longrightarrow>\n       WHILE\\<^bsup>rwof m c f\\<^esup> c f x\n       \\<le> \\<Down> {(s, s) |s. rwof m c f s}\n              (WHILE\\<^bsup>\\<lambda>_. True\\<^esup> c f x')", "apply (cases m, simp, rule rwof.init, simp_all) []"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x x'.\n       (x, x') \\<in> {(s, s) |s. rwof m c f s} \\<Longrightarrow>\n       WHILE\\<^bsup>rwof m c f\\<^esup> c f x\n       \\<le> \\<Down> {(s, s) |s. rwof m c f s}\n              (WHILE\\<^bsup>\\<lambda>_. True\\<^esup> c f x')", "apply (rule WHILEI_refine)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x x'.\n       \\<lbrakk>(x, x') \\<in> {(s, s) |s. rwof m c f s}; True\\<rbrakk>\n       \\<Longrightarrow> (x, x') \\<in> {(s, s) |s. rwof m c f s}\n 2. \\<And>x x' xa x'a.\n       \\<lbrakk>(x, x') \\<in> {(s, s) |s. rwof m c f s};\n        (xa, x'a) \\<in> {(s, s) |s. rwof m c f s}; True\\<rbrakk>\n       \\<Longrightarrow> rwof m c f xa\n 3. \\<And>x x' xa x'a.\n       \\<lbrakk>(x, x') \\<in> {(s, s) |s. rwof m c f s};\n        (xa, x'a) \\<in> {(s, s) |s. rwof m c f s}; rwof m c f xa;\n        True\\<rbrakk>\n       \\<Longrightarrow> c xa = c x'a\n 4. \\<And>x x' xa x'a.\n       \\<lbrakk>(x, x') \\<in> {(s, s) |s. rwof m c f s};\n        (xa, x'a) \\<in> {(s, s) |s. rwof m c f s}; c xa; c x'a;\n        rwof m c f xa; True\\<rbrakk>\n       \\<Longrightarrow> f xa\n                         \\<le> \\<Down> {(s, s) |s. rwof m c f s} (f x'a)", "apply (auto simp: pw_le_iff refine_pw_simps pw_rwof_step')"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  m \\<bind> WHILE\\<^bsup>rwof m c f\\<^esup> c f\n  \\<le> \\<Down> {(s, s) |s. rwof m c f s} (m \\<bind> WHILE c f)\n\ngoal (2 subgoals):\n 1. m \\<bind> WHILE c f \\<le> m \\<bind> WHILE\\<^bsup>rwof m c f\\<^esup> c f\n 2. m \\<bind> WHILE\\<^bsup>rwof m c f\\<^esup> c f \\<le> m \\<bind> WHILE c f", "thus \"m \\<bind> WHILEI (rwof m c f) c f \\<le> m \\<bind> WHILE c f\""], ["proof (prove)\nusing this:\n  m \\<bind> WHILE\\<^bsup>rwof m c f\\<^esup> c f\n  \\<le> \\<Down> {(s, s) |s. rwof m c f s} (m \\<bind> WHILE c f)\n\ngoal (1 subgoal):\n 1. m \\<bind> WHILE\\<^bsup>rwof m c f\\<^esup> c f \\<le> m \\<bind> WHILE c f", "by (simp add: pw_le_iff refine_pw_simps)"], ["proof (state)\nthis:\n  m \\<bind> WHILE\\<^bsup>rwof m c f\\<^esup> c f \\<le> m \\<bind> WHILE c f\n\ngoal (1 subgoal):\n 1. m \\<bind> WHILE c f \\<le> m \\<bind> WHILE\\<^bsup>rwof m c f\\<^esup> c f", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. m \\<bind> WHILE c f \\<le> m \\<bind> WHILE\\<^bsup>rwof m c f\\<^esup> c f", "show \"m \\<bind> WHILE c f \\<le> m \\<bind> WHILEI (rwof m c f) c f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<bind> WHILE c f \\<le> m \\<bind> WHILE\\<^bsup>rwof m c f\\<^esup> c f", "unfolding WHILE_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<bind> WHILE\\<^bsup>\\<lambda>_. True\\<^esup> c f\n    \\<le> m \\<bind> WHILE\\<^bsup>rwof m c f\\<^esup> c f", "apply (rule bind_mono)"], ["proof (prove)\ngoal (2 subgoals):\n 1. m \\<le> m\n 2. \\<And>x.\n       RETURN x \\<le> m \\<Longrightarrow>\n       WHILE\\<^bsup>\\<lambda>_. True\\<^esup> c f x\n       \\<le> WHILE\\<^bsup>rwof m c f\\<^esup> c f x", "apply (rule order_refl)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       RETURN x \\<le> m \\<Longrightarrow>\n       WHILE\\<^bsup>\\<lambda>_. True\\<^esup> c f x\n       \\<le> WHILE\\<^bsup>rwof m c f\\<^esup> c f x", "apply (rule WHILEI_weaken)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>RETURN x \\<le> m; rwof m c f xa\\<rbrakk>\n       \\<Longrightarrow> True", ".."], ["proof (state)\nthis:\n  m \\<bind> WHILE c f \\<le> m \\<bind> WHILE\\<^bsup>rwof m c f\\<^esup> c f\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma WHILET_eq_I_rwof: \"m \\<bind> WHILET c f = m \\<bind> WHILEIT (rwof m c f) c f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<bind> WHILE\\<^sub>T c f =\n    m \\<bind> WHILE\\<^sub>T\\<^bsup>rwof m c f\\<^esup> c f", "proof (rule antisym)"], ["proof (state)\ngoal (2 subgoals):\n 1. m \\<bind> WHILE\\<^sub>T c f\n    \\<le> m \\<bind> WHILE\\<^sub>T\\<^bsup>rwof m c f\\<^esup> c f\n 2. m \\<bind> WHILE\\<^sub>T\\<^bsup>rwof m c f\\<^esup> c f\n    \\<le> m \\<bind> WHILE\\<^sub>T c f", "have \"m \\<bind> WHILEIT (rwof m c f) c f\n      \\<le> \\<Down>{(s,s) | s. rwof m c f s} \n        (m \\<bind> WHILET c f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<bind> WHILE\\<^sub>T\\<^bsup>rwof m c f\\<^esup> c f\n    \\<le> \\<Down> {(s, s) |s. rwof m c f s} (m \\<bind> WHILE\\<^sub>T c f)", "unfolding WHILET_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<bind> WHILE\\<^sub>T\\<^bsup>rwof m c f\\<^esup> c f\n    \\<le> \\<Down> {(s, s) |s. rwof m c f s}\n           (m \\<bind> WHILE\\<^sub>T\\<^bsup>\\<lambda>_. True\\<^esup> c f)", "apply (rule bind_refine)"], ["proof (prove)\ngoal (2 subgoals):\n 1. m \\<le> \\<Down> ?R' m\n 2. \\<And>x x'.\n       (x, x') \\<in> ?R' \\<Longrightarrow>\n       WHILE\\<^sub>T\\<^bsup>rwof m c f\\<^esup> c f x\n       \\<le> \\<Down> {(s, s) |s. rwof m c f s}\n              (WHILE\\<^sub>T\\<^bsup>\\<lambda>_. True\\<^esup> c f x')", "apply (rule intro_prgR[where R=\"{(s,s) | s. rwof m c f s}\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. m \\<le> \\<Down> {(s, s) |s. rwof m c f s} m\n 2. \\<And>x x'.\n       (x, x') \\<in> {(s, s) |s. rwof m c f s} \\<Longrightarrow>\n       WHILE\\<^sub>T\\<^bsup>rwof m c f\\<^esup> c f x\n       \\<le> \\<Down> {(s, s) |s. rwof m c f s}\n              (WHILE\\<^sub>T\\<^bsup>\\<lambda>_. True\\<^esup> c f x')", "apply (auto simp: pw_le_iff refine_pw_simps) []"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>nofail m; inres m x\\<rbrakk> \\<Longrightarrow> rwof m c f x\n 2. \\<And>x x'.\n       (x, x') \\<in> {(s, s) |s. rwof m c f s} \\<Longrightarrow>\n       WHILE\\<^sub>T\\<^bsup>rwof m c f\\<^esup> c f x\n       \\<le> \\<Down> {(s, s) |s. rwof m c f s}\n              (WHILE\\<^sub>T\\<^bsup>\\<lambda>_. True\\<^esup> c f x')", "apply (cases m, simp, rule rwof.init, simp_all) []"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x x'.\n       (x, x') \\<in> {(s, s) |s. rwof m c f s} \\<Longrightarrow>\n       WHILE\\<^sub>T\\<^bsup>rwof m c f\\<^esup> c f x\n       \\<le> \\<Down> {(s, s) |s. rwof m c f s}\n              (WHILE\\<^sub>T\\<^bsup>\\<lambda>_. True\\<^esup> c f x')", "apply (rule WHILEIT_refine)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x x'.\n       \\<lbrakk>(x, x') \\<in> {(s, s) |s. rwof m c f s}; True\\<rbrakk>\n       \\<Longrightarrow> (x, x') \\<in> {(s, s) |s. rwof m c f s}\n 2. \\<And>x x' xa x'a.\n       \\<lbrakk>(x, x') \\<in> {(s, s) |s. rwof m c f s};\n        (xa, x'a) \\<in> {(s, s) |s. rwof m c f s}; True\\<rbrakk>\n       \\<Longrightarrow> rwof m c f xa\n 3. \\<And>x x' xa x'a.\n       \\<lbrakk>(x, x') \\<in> {(s, s) |s. rwof m c f s};\n        (xa, x'a) \\<in> {(s, s) |s. rwof m c f s}; rwof m c f xa;\n        True\\<rbrakk>\n       \\<Longrightarrow> c xa = c x'a\n 4. \\<And>x x' xa x'a.\n       \\<lbrakk>(x, x') \\<in> {(s, s) |s. rwof m c f s};\n        (xa, x'a) \\<in> {(s, s) |s. rwof m c f s}; c xa; c x'a;\n        rwof m c f xa; True\\<rbrakk>\n       \\<Longrightarrow> f xa\n                         \\<le> \\<Down> {(s, s) |s. rwof m c f s} (f x'a)", "apply (auto simp: pw_le_iff refine_pw_simps pw_rwof_step')"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  m \\<bind> WHILE\\<^sub>T\\<^bsup>rwof m c f\\<^esup> c f\n  \\<le> \\<Down> {(s, s) |s. rwof m c f s} (m \\<bind> WHILE\\<^sub>T c f)\n\ngoal (2 subgoals):\n 1. m \\<bind> WHILE\\<^sub>T c f\n    \\<le> m \\<bind> WHILE\\<^sub>T\\<^bsup>rwof m c f\\<^esup> c f\n 2. m \\<bind> WHILE\\<^sub>T\\<^bsup>rwof m c f\\<^esup> c f\n    \\<le> m \\<bind> WHILE\\<^sub>T c f", "thus \"m \\<bind> WHILEIT (rwof m c f) c f \\<le> m \\<bind> WHILET c f\""], ["proof (prove)\nusing this:\n  m \\<bind> WHILE\\<^sub>T\\<^bsup>rwof m c f\\<^esup> c f\n  \\<le> \\<Down> {(s, s) |s. rwof m c f s} (m \\<bind> WHILE\\<^sub>T c f)\n\ngoal (1 subgoal):\n 1. m \\<bind> WHILE\\<^sub>T\\<^bsup>rwof m c f\\<^esup> c f\n    \\<le> m \\<bind> WHILE\\<^sub>T c f", "by (simp add: pw_le_iff refine_pw_simps)"], ["proof (state)\nthis:\n  m \\<bind> WHILE\\<^sub>T\\<^bsup>rwof m c f\\<^esup> c f\n  \\<le> m \\<bind> WHILE\\<^sub>T c f\n\ngoal (1 subgoal):\n 1. m \\<bind> WHILE\\<^sub>T c f\n    \\<le> m \\<bind> WHILE\\<^sub>T\\<^bsup>rwof m c f\\<^esup> c f", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. m \\<bind> WHILE\\<^sub>T c f\n    \\<le> m \\<bind> WHILE\\<^sub>T\\<^bsup>rwof m c f\\<^esup> c f", "show \"m \\<bind> WHILET c f \\<le> m \\<bind> WHILEIT (rwof m c f) c f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<bind> WHILE\\<^sub>T c f\n    \\<le> m \\<bind> WHILE\\<^sub>T\\<^bsup>rwof m c f\\<^esup> c f", "unfolding WHILET_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<bind> WHILE\\<^sub>T\\<^bsup>\\<lambda>_. True\\<^esup> c f\n    \\<le> m \\<bind> WHILE\\<^sub>T\\<^bsup>rwof m c f\\<^esup> c f", "apply (rule bind_mono)"], ["proof (prove)\ngoal (2 subgoals):\n 1. m \\<le> m\n 2. \\<And>x.\n       RETURN x \\<le> m \\<Longrightarrow>\n       WHILE\\<^sub>T\\<^bsup>\\<lambda>_. True\\<^esup> c f x\n       \\<le> WHILE\\<^sub>T\\<^bsup>rwof m c f\\<^esup> c f x", "apply (rule order_refl)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       RETURN x \\<le> m \\<Longrightarrow>\n       WHILE\\<^sub>T\\<^bsup>\\<lambda>_. True\\<^esup> c f x\n       \\<le> WHILE\\<^sub>T\\<^bsup>rwof m c f\\<^esup> c f x", "apply (rule WHILEIT_weaken)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>RETURN x \\<le> m; rwof m c f xa\\<rbrakk>\n       \\<Longrightarrow> True", ".."], ["proof (state)\nthis:\n  m \\<bind> WHILE\\<^sub>T c f\n  \\<le> m \\<bind> WHILE\\<^sub>T\\<^bsup>rwof m c f\\<^esup> c f\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>Refinement\\<close>"], ["", "lemma rwof_refine:\n  assumes RW: \"rwof m c f s\"\n  assumes NF: \"nofail (m' \\<bind> WHILE c' f')\"\n  assumes M: \"m \\<le>\\<^sub>n \\<Down>R m'\"\n  assumes C: \"\\<And>s s'. \\<lbrakk>(s,s')\\<in>R; rwof m c f s; rwof m' c' f' s'\\<rbrakk> \\<Longrightarrow> c s = c' s'\"\n  assumes S: \"\\<And>s s'. \\<lbrakk>(s,s')\\<in>R; rwof m c f s; rwof m' c' f' s'; c s; c' s'\\<rbrakk> \\<Longrightarrow> f s \\<le>\\<^sub>n \\<Down>R (f' s')\"\n  shows \"\\<exists>s'. (s,s')\\<in>R \\<and> rwof m' c' f' s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>s'. (s, s') \\<in> R \\<and> rwof m' c' f' s'", "using RW"], ["proof (prove)\nusing this:\n  rwof m c f s\n\ngoal (1 subgoal):\n 1. \\<exists>s'. (s, s') \\<in> R \\<and> rwof m' c' f' s'", "apply (induction rule: establish_rwof_invar[rotated -1,consumes 1])"], ["proof (prove)\ngoal (2 subgoals):\n 1. m \\<le>\\<^sub>n\n    SPEC (\\<lambda>a. \\<exists>s'. (a, s') \\<in> R \\<and> rwof m' c' f' s')\n 2. \\<And>s.\n       \\<lbrakk>rwof m c f s;\n        \\<exists>s'. (s, s') \\<in> R \\<and> rwof m' c' f' s'; c s\\<rbrakk>\n       \\<Longrightarrow> f s \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>a.\n                              \\<exists>s'.\n                                 (a, s') \\<in> R \\<and> rwof m' c' f' s')", "using M rwof_init[OF NF]"], ["proof (prove)\nusing this:\n  m \\<le>\\<^sub>n \\<Down> R m'\n  m' \\<le> SPEC (rwof m' c' f')\n\ngoal (2 subgoals):\n 1. m \\<le>\\<^sub>n\n    SPEC (\\<lambda>a. \\<exists>s'. (a, s') \\<in> R \\<and> rwof m' c' f' s')\n 2. \\<And>s.\n       \\<lbrakk>rwof m c f s;\n        \\<exists>s'. (s, s') \\<in> R \\<and> rwof m' c' f' s'; c s\\<rbrakk>\n       \\<Longrightarrow> f s \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>a.\n                              \\<exists>s'.\n                                 (a, s') \\<in> R \\<and> rwof m' c' f' s')", "apply (simp only: pw_leof_iff pw_le_iff refine_pw_simps, blast) []"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>rwof m c f s;\n        \\<exists>s'. (s, s') \\<in> R \\<and> rwof m' c' f' s'; c s\\<rbrakk>\n       \\<Longrightarrow> f s \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>a.\n                              \\<exists>s'.\n                                 (a, s') \\<in> R \\<and> rwof m' c' f' s')", "using C S rwof_step[OF NF]"], ["proof (prove)\nusing this:\n  \\<lbrakk>(?s, ?s') \\<in> R; rwof m c f ?s; rwof m' c' f' ?s'\\<rbrakk>\n  \\<Longrightarrow> c ?s = c' ?s'\n  \\<lbrakk>(?s, ?s') \\<in> R; rwof m c f ?s; rwof m' c' f' ?s'; c ?s;\n   c' ?s'\\<rbrakk>\n  \\<Longrightarrow> f ?s \\<le>\\<^sub>n \\<Down> R (f' ?s')\n  \\<lbrakk>rwof m' c' f' ?s; c' ?s\\<rbrakk>\n  \\<Longrightarrow> f' ?s \\<le> SPEC (rwof m' c' f')\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>rwof m c f s;\n        \\<exists>s'. (s, s') \\<in> R \\<and> rwof m' c' f' s'; c s\\<rbrakk>\n       \\<Longrightarrow> f s \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>a.\n                              \\<exists>s'.\n                                 (a, s') \\<in> R \\<and> rwof m' c' f' s')", "apply (simp only: pw_leof_iff pw_le_iff refine_pw_simps, blast) []"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsubsection \\<open>Total Correct Loops\\<close>"], ["", "text \\<open>In this theory, we show that every non-failing total-correct \n  while loop gives rise to a compatible well-founded relation\\<close>"], ["", "definition rwof_rel \n  \\<comment> \\<open>Transitions in a while-loop as relation\\<close>\n  where \"rwof_rel init cond step \n    \\<equiv> {(s,s'). rwof init cond step s \\<and> cond s \\<and> inres (step s) s'}\""], ["", "lemma rwof_rel_spec: \"\\<lbrakk>rwof init cond step s; cond s\\<rbrakk> \n  \\<Longrightarrow> step s \\<le>\\<^sub>n SPEC (\\<lambda>s'. (s,s')\\<in>rwof_rel init cond step)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>rwof init cond step s; cond s\\<rbrakk>\n    \\<Longrightarrow> step s \\<le>\\<^sub>n\n                      SPEC\n                       (\\<lambda>s'. (s, s') \\<in> rwof_rel init cond step)", "unfolding rwof_rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>rwof init cond step s; cond s\\<rbrakk>\n    \\<Longrightarrow> step s \\<le>\\<^sub>n\n                      SPEC\n                       (\\<lambda>s'.\n                           (s, s')\n                           \\<in> {(s, s').\n                                  rwof init cond step s \\<and>\n                                  cond s \\<and> inres (step s) s'})", "by (auto simp: pw_leof_iff refine_pw_simps)"], ["", "lemma rwof_reachable:\n  assumes \"rwof init cond step s\"\n  shows \"\\<exists>s0. inres init s0 \\<and> (s0,s)\\<in>(rwof_rel init cond step)\\<^sup>*\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>s0.\n       inres init s0 \\<and> (s0, s) \\<in> (rwof_rel init cond step)\\<^sup>*", "using assms"], ["proof (prove)\nusing this:\n  rwof init cond step s\n\ngoal (1 subgoal):\n 1. \\<exists>s0.\n       inres init s0 \\<and> (s0, s) \\<in> (rwof_rel init cond step)\\<^sup>*", "apply (induction)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>X x.\n       \\<lbrakk>init = RES X; x \\<in> X\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s0.\n                            inres init s0 \\<and>\n                            (s0, x) \\<in> (rwof_rel init cond step)\\<^sup>*\n 2. \\<And>x Y y.\n       \\<lbrakk>rwof init cond step x;\n        \\<exists>s0.\n           inres init s0 \\<and>\n           (s0, x) \\<in> (rwof_rel init cond step)\\<^sup>*;\n        cond x; step x = RES Y; y \\<in> Y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s0.\n                            inres init s0 \\<and>\n                            (s0, y) \\<in> (rwof_rel init cond step)\\<^sup>*", "unfolding rwof_rel_def"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>X x.\n       \\<lbrakk>init = RES X; x \\<in> X\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s0.\n                            inres init s0 \\<and>\n                            (s0, x)\n                            \\<in> {(s, s').\n                                   rwof init cond step s \\<and>\n                                   cond s \\<and> inres (step s) s'}\\<^sup>*\n 2. \\<And>x Y y.\n       \\<lbrakk>rwof init cond step x;\n        \\<exists>s0.\n           inres init s0 \\<and>\n           (s0, x)\n           \\<in> {(s, s').\n                  rwof init cond step s \\<and>\n                  cond s \\<and> inres (step s) s'}\\<^sup>*;\n        cond x; step x = RES Y; y \\<in> Y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s0.\n                            inres init s0 \\<and>\n                            (s0, y)\n                            \\<in> {(s, s').\n                                   rwof init cond step s \\<and>\n                                   cond s \\<and> inres (step s) s'}\\<^sup>*", "apply (auto intro: rwof.intros) []"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x Y y.\n       \\<lbrakk>rwof init cond step x;\n        \\<exists>s0.\n           inres init s0 \\<and>\n           (s0, x)\n           \\<in> {(s, s').\n                  rwof init cond step s \\<and>\n                  cond s \\<and> inres (step s) s'}\\<^sup>*;\n        cond x; step x = RES Y; y \\<in> Y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s0.\n                            inres init s0 \\<and>\n                            (s0, y)\n                            \\<in> {(s, s').\n                                   rwof init cond step s \\<and>\n                                   cond s \\<and> inres (step s) s'}\\<^sup>*", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x Y y s0.\n       \\<lbrakk>rwof init cond step x; cond x; step x = RES Y; y \\<in> Y;\n        inres init s0;\n        (s0, x)\n        \\<in> {(s, s').\n               rwof init cond step s \\<and>\n               cond s \\<and> inres (step s) s'}\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s0.\n                            inres init s0 \\<and>\n                            (s0, y)\n                            \\<in> {(s, s').\n                                   rwof init cond step s \\<and>\n                                   cond s \\<and> inres (step s) s'}\\<^sup>*", "apply (intro exI conjI, assumption)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x Y y s0.\n       \\<lbrakk>rwof init cond step x; cond x; step x = RES Y; y \\<in> Y;\n        inres init s0;\n        (s0, x)\n        \\<in> {(s, s').\n               rwof init cond step s \\<and>\n               cond s \\<and> inres (step s) s'}\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> (s0, y)\n                         \\<in> {(s, s').\n                                rwof init cond step s \\<and>\n                                cond s \\<and> inres (step s) s'}\\<^sup>*", "apply (rule rtrancl_into_rtrancl, assumption)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x Y y s0.\n       \\<lbrakk>rwof init cond step x; cond x; step x = RES Y; y \\<in> Y;\n        inres init s0;\n        (s0, x)\n        \\<in> {(s, s').\n               rwof init cond step s \\<and>\n               cond s \\<and> inres (step s) s'}\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> (x, y)\n                         \\<in> {(s, s').\n                                rwof init cond step s \\<and>\n                                cond s \\<and> inres (step s) s'}", "apply (auto intro: rwof.intros) []"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "theorem nofail_WHILEIT_wf_rel: \n  assumes NF: \"nofail (init \\<bind> WHILEIT I cond step)\"\n  shows \"wf ((rwof_rel init cond step)\\<inverse>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf ((rwof_rel init cond step)\\<inverse>)", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> wf ((rwof_rel init cond step)\\<inverse>) \\<Longrightarrow> False", "assume \"\\<not>wf ((rwof_rel init cond step)\\<inverse>)\""], ["proof (state)\nthis:\n  \\<not> wf ((rwof_rel init cond step)\\<inverse>)\n\ngoal (1 subgoal):\n 1. \\<not> wf ((rwof_rel init cond step)\\<inverse>) \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<not> wf ((rwof_rel init cond step)\\<inverse>)", "obtain f where IP: \"\\<And> i. (f i, f (Suc i)) \\<in> rwof_rel init cond step\""], ["proof (prove)\nusing this:\n  \\<not> wf ((rwof_rel init cond step)\\<inverse>)\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        (\\<And>i.\n            (f i, f (Suc i))\n            \\<in> rwof_rel init cond step) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding wf_iff_no_infinite_down_chain"], ["proof (prove)\nusing this:\n  \\<not> (\\<nexists>f.\n             \\<forall>i.\n                (f (Suc i), f i) \\<in> (rwof_rel init cond step)\\<inverse>)\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        (\\<And>i.\n            (f i, f (Suc i))\n            \\<in> rwof_rel init cond step) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  (f ?i, f (Suc ?i)) \\<in> rwof_rel init cond step\n\ngoal (1 subgoal):\n 1. \\<not> wf ((rwof_rel init cond step)\\<inverse>) \\<Longrightarrow> False", "hence \"rwof init cond step (f 0)\""], ["proof (prove)\nusing this:\n  (f ?i, f (Suc ?i)) \\<in> rwof_rel init cond step\n\ngoal (1 subgoal):\n 1. rwof init cond step (f 0)", "by (auto simp: rwof_rel_def)"], ["proof (state)\nthis:\n  rwof init cond step (f 0)\n\ngoal (1 subgoal):\n 1. \\<not> wf ((rwof_rel init cond step)\\<inverse>) \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  rwof init cond step (f 0)", "obtain s0 sn where \"(s0, sn) \\<in> (rwof_rel init cond step)\\<^sup>*\" \"inres init s0\" \"sn = f 0\""], ["proof (prove)\nusing this:\n  rwof init cond step (f 0)\n\ngoal (1 subgoal):\n 1. (\\<And>s0 sn.\n        \\<lbrakk>(s0, sn) \\<in> (rwof_rel init cond step)\\<^sup>*;\n         inres init s0; sn = f 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using rwof_reachable"], ["proof (prove)\nusing this:\n  rwof init cond step (f 0)\n  rwof ?init ?cond ?step ?s \\<Longrightarrow>\n  \\<exists>s0.\n     inres ?init s0 \\<and>\n     (s0, ?s) \\<in> (rwof_rel ?init ?cond ?step)\\<^sup>*\n\ngoal (1 subgoal):\n 1. (\\<And>s0 sn.\n        \\<lbrakk>(s0, sn) \\<in> (rwof_rel init cond step)\\<^sup>*;\n         inres init s0; sn = f 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  (s0, sn) \\<in> (rwof_rel init cond step)\\<^sup>*\n  inres init s0\n  sn = f 0\n\ngoal (1 subgoal):\n 1. \\<not> wf ((rwof_rel init cond step)\\<inverse>) \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  (s0, sn) \\<in> (rwof_rel init cond step)\\<^sup>*\n  inres init s0\n  sn = f 0", "obtain f where P: \"\\<And> i. (f i, f (Suc i)) \\<in> rwof_rel init cond step\" and I: \"inres init (f 0)\""], ["proof (prove)\nusing this:\n  (s0, sn) \\<in> (rwof_rel init cond step)\\<^sup>*\n  inres init s0\n  sn = f 0\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        \\<lbrakk>\\<And>i. (f i, f (Suc i)) \\<in> rwof_rel init cond step;\n         inres init (f 0)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using IP"], ["proof (prove)\nusing this:\n  (s0, sn) \\<in> (rwof_rel init cond step)\\<^sup>*\n  inres init s0\n  sn = f 0\n  (f ?i, f (Suc ?i)) \\<in> rwof_rel init cond step\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        \\<lbrakk>\\<And>i. (f i, f (Suc i)) \\<in> rwof_rel init cond step;\n         inres init (f 0)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof (induct arbitrary: f)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>f.\n       \\<lbrakk>\\<And>f.\n                   \\<lbrakk>\\<And>i.\n                               (f i, f (Suc i))\n                               \\<in> rwof_rel init cond step;\n                    inres init (f 0)\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        inres init s0; s0 = f 0;\n        \\<And>i. (f i, f (Suc i)) \\<in> rwof_rel init cond step\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>y z f.\n       \\<lbrakk>(s0, y) \\<in> (rwof_rel init cond step)\\<^sup>*;\n        (y, z) \\<in> rwof_rel init cond step;\n        \\<And>f.\n           \\<lbrakk>\\<And>f.\n                       \\<lbrakk>\\<And>i.\n                                   (f i, f (Suc i))\n                                   \\<in> rwof_rel init cond step;\n                        inres init (f 0)\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            inres init s0; y = f 0;\n            \\<And>i. (f i, f (Suc i)) \\<in> rwof_rel init cond step\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>f.\n           \\<lbrakk>\\<And>i. (f i, f (Suc i)) \\<in> rwof_rel init cond step;\n            inres init (f 0)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        inres init s0; z = f 0;\n        \\<And>i. (f i, f (Suc i)) \\<in> rwof_rel init cond step\\<rbrakk>\n       \\<Longrightarrow> thesis", "case (step sk sn)"], ["proof (state)\nthis:\n  (s0, sk) \\<in> (rwof_rel init cond step)\\<^sup>*\n  (sk, sn) \\<in> rwof_rel init cond step\n  \\<lbrakk>\\<And>f.\n              \\<lbrakk>\\<And>i.\n                          (f i, f (Suc i)) \\<in> rwof_rel init cond step;\n               inres init (f 0)\\<rbrakk>\n              \\<Longrightarrow> thesis;\n   inres init s0; sk = ?f 0;\n   \\<And>i. (?f i, ?f (Suc i)) \\<in> rwof_rel init cond step\\<rbrakk>\n  \\<Longrightarrow> thesis\n  \\<lbrakk>\\<And>i. (?f i, ?f (Suc i)) \\<in> rwof_rel init cond step;\n   inres init (?f 0)\\<rbrakk>\n  \\<Longrightarrow> thesis\n  inres init s0\n  sn = f 0\n  (f ?i, f (Suc ?i)) \\<in> rwof_rel init cond step\n\ngoal (2 subgoals):\n 1. \\<And>f.\n       \\<lbrakk>\\<And>f.\n                   \\<lbrakk>\\<And>i.\n                               (f i, f (Suc i))\n                               \\<in> rwof_rel init cond step;\n                    inres init (f 0)\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        inres init s0; s0 = f 0;\n        \\<And>i. (f i, f (Suc i)) \\<in> rwof_rel init cond step\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>y z f.\n       \\<lbrakk>(s0, y) \\<in> (rwof_rel init cond step)\\<^sup>*;\n        (y, z) \\<in> rwof_rel init cond step;\n        \\<And>f.\n           \\<lbrakk>\\<And>f.\n                       \\<lbrakk>\\<And>i.\n                                   (f i, f (Suc i))\n                                   \\<in> rwof_rel init cond step;\n                        inres init (f 0)\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            inres init s0; y = f 0;\n            \\<And>i. (f i, f (Suc i)) \\<in> rwof_rel init cond step\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>f.\n           \\<lbrakk>\\<And>i. (f i, f (Suc i)) \\<in> rwof_rel init cond step;\n            inres init (f 0)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        inres init s0; z = f 0;\n        \\<And>i. (f i, f (Suc i)) \\<in> rwof_rel init cond step\\<rbrakk>\n       \\<Longrightarrow> thesis", "let ?f = \"case_nat sk f\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>f.\n       \\<lbrakk>\\<And>f.\n                   \\<lbrakk>\\<And>i.\n                               (f i, f (Suc i))\n                               \\<in> rwof_rel init cond step;\n                    inres init (f 0)\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        inres init s0; s0 = f 0;\n        \\<And>i. (f i, f (Suc i)) \\<in> rwof_rel init cond step\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>y z f.\n       \\<lbrakk>(s0, y) \\<in> (rwof_rel init cond step)\\<^sup>*;\n        (y, z) \\<in> rwof_rel init cond step;\n        \\<And>f.\n           \\<lbrakk>\\<And>f.\n                       \\<lbrakk>\\<And>i.\n                                   (f i, f (Suc i))\n                                   \\<in> rwof_rel init cond step;\n                        inres init (f 0)\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            inres init s0; y = f 0;\n            \\<And>i. (f i, f (Suc i)) \\<in> rwof_rel init cond step\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>f.\n           \\<lbrakk>\\<And>i. (f i, f (Suc i)) \\<in> rwof_rel init cond step;\n            inres init (f 0)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        inres init s0; z = f 0;\n        \\<And>i. (f i, f (Suc i)) \\<in> rwof_rel init cond step\\<rbrakk>\n       \\<Longrightarrow> thesis", "have \"sk = ?f 0\" \"\\<And> i. (?f i, ?f (Suc i)) \\<in> rwof_rel init cond step\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sk = (case 0 of 0 \\<Rightarrow> sk | Suc x \\<Rightarrow> f x) &&&\n    (\\<And>i.\n        (case i of 0 \\<Rightarrow> sk | Suc x \\<Rightarrow> f x,\n         case Suc i of 0 \\<Rightarrow> sk | Suc x \\<Rightarrow> f x)\n        \\<in> rwof_rel init cond step)", "using step"], ["proof (prove)\nusing this:\n  (s0, sk) \\<in> (rwof_rel init cond step)\\<^sup>*\n  (sk, sn) \\<in> rwof_rel init cond step\n  \\<lbrakk>\\<And>f.\n              \\<lbrakk>\\<And>i.\n                          (f i, f (Suc i)) \\<in> rwof_rel init cond step;\n               inres init (f 0)\\<rbrakk>\n              \\<Longrightarrow> thesis;\n   inres init s0; sk = ?f 0;\n   \\<And>i. (?f i, ?f (Suc i)) \\<in> rwof_rel init cond step\\<rbrakk>\n  \\<Longrightarrow> thesis\n  \\<lbrakk>\\<And>i. (?f i, ?f (Suc i)) \\<in> rwof_rel init cond step;\n   inres init (?f 0)\\<rbrakk>\n  \\<Longrightarrow> thesis\n  inres init s0\n  sn = f 0\n  (f ?i, f (Suc ?i)) \\<in> rwof_rel init cond step\n\ngoal (1 subgoal):\n 1. sk = (case 0 of 0 \\<Rightarrow> sk | Suc x \\<Rightarrow> f x) &&&\n    (\\<And>i.\n        (case i of 0 \\<Rightarrow> sk | Suc x \\<Rightarrow> f x,\n         case Suc i of 0 \\<Rightarrow> sk | Suc x \\<Rightarrow> f x)\n        \\<in> rwof_rel init cond step)", "by (auto split: nat.splits)"], ["proof (state)\nthis:\n  sk = (case 0 of 0 \\<Rightarrow> sk | Suc x \\<Rightarrow> f x)\n  (case ?i of 0 \\<Rightarrow> sk | Suc x \\<Rightarrow> f x,\n   case Suc ?i of 0 \\<Rightarrow> sk | Suc x \\<Rightarrow> f x)\n  \\<in> rwof_rel init cond step\n\ngoal (2 subgoals):\n 1. \\<And>f.\n       \\<lbrakk>\\<And>f.\n                   \\<lbrakk>\\<And>i.\n                               (f i, f (Suc i))\n                               \\<in> rwof_rel init cond step;\n                    inres init (f 0)\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        inres init s0; s0 = f 0;\n        \\<And>i. (f i, f (Suc i)) \\<in> rwof_rel init cond step\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>y z f.\n       \\<lbrakk>(s0, y) \\<in> (rwof_rel init cond step)\\<^sup>*;\n        (y, z) \\<in> rwof_rel init cond step;\n        \\<And>f.\n           \\<lbrakk>\\<And>f.\n                       \\<lbrakk>\\<And>i.\n                                   (f i, f (Suc i))\n                                   \\<in> rwof_rel init cond step;\n                        inres init (f 0)\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            inres init s0; y = f 0;\n            \\<And>i. (f i, f (Suc i)) \\<in> rwof_rel init cond step\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>f.\n           \\<lbrakk>\\<And>i. (f i, f (Suc i)) \\<in> rwof_rel init cond step;\n            inres init (f 0)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        inres init s0; z = f 0;\n        \\<And>i. (f i, f (Suc i)) \\<in> rwof_rel init cond step\\<rbrakk>\n       \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  sk = (case 0 of 0 \\<Rightarrow> sk | Suc x \\<Rightarrow> f x)\n  (case ?i of 0 \\<Rightarrow> sk | Suc x \\<Rightarrow> f x,\n   case Suc ?i of 0 \\<Rightarrow> sk | Suc x \\<Rightarrow> f x)\n  \\<in> rwof_rel init cond step", "show ?case"], ["proof (prove)\nusing this:\n  sk = (case 0 of 0 \\<Rightarrow> sk | Suc x \\<Rightarrow> f x)\n  (case ?i of 0 \\<Rightarrow> sk | Suc x \\<Rightarrow> f x,\n   case Suc ?i of 0 \\<Rightarrow> sk | Suc x \\<Rightarrow> f x)\n  \\<in> rwof_rel init cond step\n\ngoal (1 subgoal):\n 1. thesis", "using step"], ["proof (prove)\nusing this:\n  sk = (case 0 of 0 \\<Rightarrow> sk | Suc x \\<Rightarrow> f x)\n  (case ?i of 0 \\<Rightarrow> sk | Suc x \\<Rightarrow> f x,\n   case Suc ?i of 0 \\<Rightarrow> sk | Suc x \\<Rightarrow> f x)\n  \\<in> rwof_rel init cond step\n  (s0, sk) \\<in> (rwof_rel init cond step)\\<^sup>*\n  (sk, sn) \\<in> rwof_rel init cond step\n  \\<lbrakk>\\<And>f.\n              \\<lbrakk>\\<And>i.\n                          (f i, f (Suc i)) \\<in> rwof_rel init cond step;\n               inres init (f 0)\\<rbrakk>\n              \\<Longrightarrow> thesis;\n   inres init s0; sk = ?f 0;\n   \\<And>i. (?f i, ?f (Suc i)) \\<in> rwof_rel init cond step\\<rbrakk>\n  \\<Longrightarrow> thesis\n  \\<lbrakk>\\<And>i. (?f i, ?f (Suc i)) \\<in> rwof_rel init cond step;\n   inres init (?f 0)\\<rbrakk>\n  \\<Longrightarrow> thesis\n  inres init s0\n  sn = f 0\n  (f ?i, f (Suc ?i)) \\<in> rwof_rel init cond step\n\ngoal (1 subgoal):\n 1. thesis", "by blast"], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<lbrakk>\\<And>f.\n                   \\<lbrakk>\\<And>i.\n                               (f i, f (Suc i))\n                               \\<in> rwof_rel init cond step;\n                    inres init (f 0)\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        inres init s0; s0 = f 0;\n        \\<And>i. (f i, f (Suc i)) \\<in> rwof_rel init cond step\\<rbrakk>\n       \\<Longrightarrow> thesis", "qed auto"], ["proof (state)\nthis:\n  (f ?i, f (Suc ?i)) \\<in> rwof_rel init cond step\n  inres init (f 0)\n\ngoal (1 subgoal):\n 1. \\<not> wf ((rwof_rel init cond step)\\<inverse>) \\<Longrightarrow> False", "from P"], ["proof (chain)\npicking this:\n  (f ?i, f (Suc ?i)) \\<in> rwof_rel init cond step", "have [simp]: \"\\<And>i. cond (f i)\""], ["proof (prove)\nusing this:\n  (f ?i, f (Suc ?i)) \\<in> rwof_rel init cond step\n\ngoal (1 subgoal):\n 1. \\<And>i. cond (f i)", "unfolding rwof_rel_def"], ["proof (prove)\nusing this:\n  (f ?i, f (Suc ?i))\n  \\<in> {(s, s').\n         rwof init cond step s \\<and> cond s \\<and> inres (step s) s'}\n\ngoal (1 subgoal):\n 1. \\<And>i. cond (f i)", "by auto"], ["proof (state)\nthis:\n  cond (f ?i)\n\ngoal (1 subgoal):\n 1. \\<not> wf ((rwof_rel init cond step)\\<inverse>) \\<Longrightarrow> False", "from P"], ["proof (chain)\npicking this:\n  (f ?i, f (Suc ?i)) \\<in> rwof_rel init cond step", "have SIR: \"\\<And>i. inres (step (f i)) (f (Suc i))\""], ["proof (prove)\nusing this:\n  (f ?i, f (Suc ?i)) \\<in> rwof_rel init cond step\n\ngoal (1 subgoal):\n 1. \\<And>i. inres (step (f i)) (f (Suc i))", "unfolding rwof_rel_def"], ["proof (prove)\nusing this:\n  (f ?i, f (Suc ?i))\n  \\<in> {(s, s').\n         rwof init cond step s \\<and> cond s \\<and> inres (step s) s'}\n\ngoal (1 subgoal):\n 1. \\<And>i. inres (step (f i)) (f (Suc i))", "by auto"], ["proof (state)\nthis:\n  inres (step (f ?i)) (f (Suc ?i))\n\ngoal (1 subgoal):\n 1. \\<not> wf ((rwof_rel init cond step)\\<inverse>) \\<Longrightarrow> False", "define F where \"F = (WHILEI_body (\\<bind>) RETURN I cond step)\""], ["proof (state)\nthis:\n  F = WHILEI_body (\\<bind>) RETURN I cond step\n\ngoal (1 subgoal):\n 1. \\<not> wf ((rwof_rel init cond step)\\<inverse>) \\<Longrightarrow> False", "{"], ["proof (state)\nthis:\n  F = WHILEI_body (\\<bind>) RETURN I cond step\n\ngoal (1 subgoal):\n 1. \\<not> wf ((rwof_rel init cond step)\\<inverse>) \\<Longrightarrow> False", "assume M: \"trimono F\""], ["proof (state)\nthis:\n  trimono F\n\ngoal (1 subgoal):\n 1. \\<not> wf ((rwof_rel init cond step)\\<inverse>) \\<Longrightarrow> False", "define f' where \"f' x = (if x\\<in>range f then FAIL else gfp F x)\" for x"], ["proof (state)\nthis:\n  f' ?x = (if ?x \\<in> range f then FAIL else gfp F ?x)\n\ngoal (1 subgoal):\n 1. \\<not> wf ((rwof_rel init cond step)\\<inverse>) \\<Longrightarrow> False", "have \"f' \\<le> F f'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f' \\<le> F f'", "unfolding f'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. if x \\<in> range f then FAIL else gfp F x)\n    \\<le> F (\\<lambda>x. if x \\<in> range f then FAIL else gfp F x)", "apply (rule le_funI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (if x \\<in> range f then FAIL else gfp F x)\n       \\<le> F (\\<lambda>x. if x \\<in> range f then FAIL else gfp F x) x", "apply (case_tac \"x\\<in>range f\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> range f \\<Longrightarrow>\n       (if x \\<in> range f then FAIL else gfp F x)\n       \\<le> F (\\<lambda>x. if x \\<in> range f then FAIL else gfp F x) x\n 2. \\<And>x.\n       x \\<notin> range f \\<Longrightarrow>\n       (if x \\<in> range f then FAIL else gfp F x)\n       \\<le> F (\\<lambda>x. if x \\<in> range f then FAIL else gfp F x) x", "apply simp_all"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> range f \\<Longrightarrow>\n       F (\\<lambda>x. if x \\<in> range f then FAIL else gfp F x) x = FAIL\n 2. \\<And>x.\n       x \\<notin> range f \\<Longrightarrow>\n       gfp F x\n       \\<le> F (\\<lambda>x. if x \\<in> range f then FAIL else gfp F x) x", "defer"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<notin> range f \\<Longrightarrow>\n       gfp F x\n       \\<le> F (\\<lambda>x. if x \\<in> range f then FAIL else gfp F x) x\n 2. \\<And>x.\n       x \\<in> range f \\<Longrightarrow>\n       F (\\<lambda>x. if x \\<in> range f then FAIL else gfp F x) x = FAIL", "apply (subst gfp_unfold)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x. x \\<notin> range f \\<Longrightarrow> mono F\n 2. \\<And>x.\n       x \\<notin> range f \\<Longrightarrow>\n       F (gfp F) x\n       \\<le> F (\\<lambda>x. if x \\<in> range f then FAIL else gfp F x) x\n 3. \\<And>x.\n       x \\<in> range f \\<Longrightarrow>\n       F (\\<lambda>x. if x \\<in> range f then FAIL else gfp F x) x = FAIL", "using M"], ["proof (prove)\nusing this:\n  trimono F\n\ngoal (3 subgoals):\n 1. \\<And>x. x \\<notin> range f \\<Longrightarrow> mono F\n 2. \\<And>x.\n       x \\<notin> range f \\<Longrightarrow>\n       F (gfp F) x\n       \\<le> F (\\<lambda>x. if x \\<in> range f then FAIL else gfp F x) x\n 3. \\<And>x.\n       x \\<in> range f \\<Longrightarrow>\n       F (\\<lambda>x. if x \\<in> range f then FAIL else gfp F x) x = FAIL", "apply (simp add: trimono_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<notin> range f \\<Longrightarrow>\n       F (gfp F) x\n       \\<le> F (\\<lambda>x. if x \\<in> range f then FAIL else gfp F x) x\n 2. \\<And>x.\n       x \\<in> range f \\<Longrightarrow>\n       F (\\<lambda>x. if x \\<in> range f then FAIL else gfp F x) x = FAIL", "apply (unfold F_def WHILEI_body_def) []"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<notin> range f \\<Longrightarrow>\n       (if I x\n        then if cond x\n             then step x \\<bind>\n                  gfp (\\<lambda>W s.\n                          if I s\n                          then if cond s then step s \\<bind> W else RETURN s\n                          else FAIL)\n             else RETURN x\n        else FAIL)\n       \\<le> (if I x\n              then if cond x\n                   then step x \\<bind>\n                        (\\<lambda>x.\n                            if x \\<in> range f then FAIL\n                            else gfp (\\<lambda>W s.\n   if I s then if cond s then step s \\<bind> W else RETURN s else FAIL)\n                                  x)\n                   else RETURN x\n              else FAIL)\n 2. \\<And>x.\n       x \\<in> range f \\<Longrightarrow>\n       F (\\<lambda>x. if x \\<in> range f then FAIL else gfp F x) x = FAIL", "apply (auto simp: pw_le_iff refine_pw_simps) []"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> range f \\<Longrightarrow>\n       F (\\<lambda>x. if x \\<in> range f then FAIL else gfp F x) x = FAIL", "apply (unfold F_def WHILEI_body_def not_nofail_iff[symmetric]) []"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> range f \\<Longrightarrow>\n       \\<not> nofail\n               (if I x\n                then if cond x\n                     then step x \\<bind>\n                          (\\<lambda>x.\n                              if x \\<in> range f then FAIL\n                              else gfp (\\<lambda>W s.\n     if I s then if cond s then step s \\<bind> W else RETURN s else FAIL)\n                                    x)\n                     else RETURN x\n                else FAIL)", "using SIR"], ["proof (prove)\nusing this:\n  inres (step (f ?i)) (f (Suc ?i))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> range f \\<Longrightarrow>\n       \\<not> nofail\n               (if I x\n                then if cond x\n                     then step x \\<bind>\n                          (\\<lambda>x.\n                              if x \\<in> range f then FAIL\n                              else gfp (\\<lambda>W s.\n     if I s then if cond s then step s \\<bind> W else RETURN s else FAIL)\n                                    x)\n                     else RETURN x\n                else FAIL)", "apply (auto simp: pw_le_iff refine_pw_simps) []"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  f' \\<le> F f'\n\ngoal (1 subgoal):\n 1. \\<not> wf ((rwof_rel init cond step)\\<inverse>) \\<Longrightarrow> False", "from gfp_upperbound[of f' F,OF this]"], ["proof (chain)\npicking this:\n  f' \\<le> gfp F", "have \"\\<And>x. f' x \\<le> gfp F x\""], ["proof (prove)\nusing this:\n  f' \\<le> gfp F\n\ngoal (1 subgoal):\n 1. \\<And>x. f' x \\<le> gfp F x", "by (auto dest: le_funD)"], ["proof (state)\nthis:\n  f' ?x \\<le> gfp F ?x\n\ngoal (1 subgoal):\n 1. \\<not> wf ((rwof_rel init cond step)\\<inverse>) \\<Longrightarrow> False", "from this[of \"f 0\"]"], ["proof (chain)\npicking this:\n  f' (f 0) \\<le> gfp F (f 0)", "have \"gfp F (f 0) = FAIL\""], ["proof (prove)\nusing this:\n  f' (f 0) \\<le> gfp F (f 0)\n\ngoal (1 subgoal):\n 1. gfp F (f 0) = FAIL", "unfolding f'_def"], ["proof (prove)\nusing this:\n  (if f 0 \\<in> range f then FAIL else gfp F (f 0)) \\<le> gfp F (f 0)\n\ngoal (1 subgoal):\n 1. gfp F (f 0) = FAIL", "by auto"], ["proof (state)\nthis:\n  gfp F (f 0) = FAIL\n\ngoal (1 subgoal):\n 1. \\<not> wf ((rwof_rel init cond step)\\<inverse>) \\<Longrightarrow> False", "}"], ["proof (state)\nthis:\n  trimono F \\<Longrightarrow> gfp F (f 0) = FAIL\n\ngoal (1 subgoal):\n 1. \\<not> wf ((rwof_rel init cond step)\\<inverse>) \\<Longrightarrow> False", "note aux=this"], ["proof (state)\nthis:\n  trimono F \\<Longrightarrow> gfp F (f 0) = FAIL\n\ngoal (1 subgoal):\n 1. \\<not> wf ((rwof_rel init cond step)\\<inverse>) \\<Longrightarrow> False", "have \"FAIL \\<le> WHILEIT I cond step (f 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. FAIL \\<le> WHILE\\<^sub>T\\<^bsup>I\\<^esup> cond step (f 0)", "unfolding WHILET_def WHILEIT_def RECT_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. FAIL\n    \\<le> (if trimono (WHILEI_body (\\<bind>) RETURN I cond step)\n           then flatf_gfp (WHILEI_body (\\<bind>) RETURN I cond step) (f 0)\n           else FAIL)", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. trimono (WHILEI_body (\\<bind>) RETURN I cond step) \\<Longrightarrow>\n    flatf_gfp (WHILEI_body (\\<bind>) RETURN I cond step) (f 0) = FAIL", "apply (subst gfp_eq_flatf_gfp[symmetric])"], ["proof (prove)\ngoal (3 subgoals):\n 1. trimono (WHILEI_body (\\<bind>) RETURN I cond step) \\<Longrightarrow>\n    flatf_mono FAIL (WHILEI_body (\\<bind>) RETURN I cond step)\n 2. trimono (WHILEI_body (\\<bind>) RETURN I cond step) \\<Longrightarrow>\n    mono (WHILEI_body (\\<bind>) RETURN I cond step)\n 3. trimono (WHILEI_body (\\<bind>) RETURN I cond step) \\<Longrightarrow>\n    gfp (WHILEI_body (\\<bind>) RETURN I cond step) (f 0) = FAIL", "apply (simp_all add: trimono_def) [2]"], ["proof (prove)\ngoal (1 subgoal):\n 1. trimono (WHILEI_body (\\<bind>) RETURN I cond step) \\<Longrightarrow>\n    gfp (WHILEI_body (\\<bind>) RETURN I cond step) (f 0) = FAIL", "apply (unfold F_def[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. trimono F \\<Longrightarrow> gfp F (f 0) = FAIL", "by (rule aux)"], ["proof (state)\nthis:\n  FAIL \\<le> WHILE\\<^sub>T\\<^bsup>I\\<^esup> cond step (f 0)\n\ngoal (1 subgoal):\n 1. \\<not> wf ((rwof_rel init cond step)\\<inverse>) \\<Longrightarrow> False", "with NF I"], ["proof (chain)\npicking this:\n  nofail (init \\<bind> WHILE\\<^sub>T\\<^bsup>I\\<^esup> cond step)\n  inres init (f 0)\n  FAIL \\<le> WHILE\\<^sub>T\\<^bsup>I\\<^esup> cond step (f 0)", "show False"], ["proof (prove)\nusing this:\n  nofail (init \\<bind> WHILE\\<^sub>T\\<^bsup>I\\<^esup> cond step)\n  inres init (f 0)\n  FAIL \\<le> WHILE\\<^sub>T\\<^bsup>I\\<^esup> cond step (f 0)\n\ngoal (1 subgoal):\n 1. False", "by (auto simp: refine_pw_simps)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Convenience\\<close>"], ["", "subsubsection \\<open>Iterate over range of list\\<close>"], ["", "lemma range_set_WHILE:\n  assumes CEQ: \"\\<And>i s. c (i,s) \\<longleftrightarrow> i<u\"\n  assumes F0: \"F {} s0 = s0\"\n  assumes Fs: \"\\<And>s i X. \\<lbrakk>l\\<le>i; i<u\\<rbrakk> \n    \\<Longrightarrow> f (i, (F X s)) \\<le> SPEC (\\<lambda>(i',r). i'=i+1 \\<and> r=F (insert (list!i) X) s)\"\n  shows \"WHILET c f (l,s0) \n    \\<le> SPEC (\\<lambda>(_,r). r=F {list!i | i. l\\<le>i \\<and> i<u} s0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. WHILE\\<^sub>T c f (l, s0)\n    \\<le> SPEC\n           (\\<lambda>(uu_, r).\n               r = F {list ! i |i. l \\<le> i \\<and> i < u} s0)", "apply (cases \"\\<not>(l<u)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<not> l < u \\<Longrightarrow>\n    WHILE\\<^sub>T c f (l, s0)\n    \\<le> SPEC\n           (\\<lambda>(uu_, r).\n               r = F {list ! i |i. l \\<le> i \\<and> i < u} s0)\n 2. \\<not> \\<not> l < u \\<Longrightarrow>\n    WHILE\\<^sub>T c f (l, s0)\n    \\<le> SPEC\n           (\\<lambda>(uu_, r).\n               r = F {list ! i |i. l \\<le> i \\<and> i < u} s0)", "apply (subst WHILET_unfold)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<not> l < u \\<Longrightarrow>\n    (if c (l, s0) then f (l, s0) \\<bind> WHILE\\<^sub>T c f\n     else RETURN (l, s0))\n    \\<le> SPEC\n           (\\<lambda>(uu_, r).\n               r = F {list ! i |i. l \\<le> i \\<and> i < u} s0)\n 2. \\<not> \\<not> l < u \\<Longrightarrow>\n    WHILE\\<^sub>T c f (l, s0)\n    \\<le> SPEC\n           (\\<lambda>(uu_, r).\n               r = F {list ! i |i. l \\<le> i \\<and> i < u} s0)", "using F0"], ["proof (prove)\nusing this:\n  F {} s0 = s0\n\ngoal (2 subgoals):\n 1. \\<not> l < u \\<Longrightarrow>\n    (if c (l, s0) then f (l, s0) \\<bind> WHILE\\<^sub>T c f\n     else RETURN (l, s0))\n    \\<le> SPEC\n           (\\<lambda>(uu_, r).\n               r = F {list ! i |i. l \\<le> i \\<and> i < u} s0)\n 2. \\<not> \\<not> l < u \\<Longrightarrow>\n    WHILE\\<^sub>T c f (l, s0)\n    \\<le> SPEC\n           (\\<lambda>(uu_, r).\n               r = F {list ! i |i. l \\<le> i \\<and> i < u} s0)", "apply (simp add: CEQ)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> l < u; F {} s0 = s0\\<rbrakk>\n    \\<Longrightarrow> s0 = F {list ! i |i. l \\<le> i \\<and> i < u} s0\n 2. \\<not> \\<not> l < u \\<Longrightarrow>\n    WHILE\\<^sub>T c f (l, s0)\n    \\<le> SPEC\n           (\\<lambda>(uu_, r).\n               r = F {list ! i |i. l \\<le> i \\<and> i < u} s0)", "apply (rule subst, assumption)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> l < u; F {} s0 = s0\\<rbrakk>\n    \\<Longrightarrow> F {} s0 =\n                      F {list ! i |i. l \\<le> i \\<and> i < u} (F {} s0)\n 2. \\<not> \\<not> l < u \\<Longrightarrow>\n    WHILE\\<^sub>T c f (l, s0)\n    \\<le> SPEC\n           (\\<lambda>(uu_, r).\n               r = F {list ! i |i. l \\<le> i \\<and> i < u} s0)", "apply ((fo_rule cong refl)+, auto) []"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> \\<not> l < u \\<Longrightarrow>\n    WHILE\\<^sub>T c f (l, s0)\n    \\<le> SPEC\n           (\\<lambda>(uu_, r).\n               r = F {list ! i |i. l \\<le> i \\<and> i < u} s0)", "apply (simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. l < u \\<Longrightarrow>\n    WHILE\\<^sub>T c f (l, s0)\n    \\<le> SPEC\n           (\\<lambda>(uu_, r).\n               r = F {list ! i |i. l \\<le> i \\<and> i < u} s0)", "apply (rule WHILET_rule[\n    where R = \"measure (\\<lambda>(i,_). u-i)\"\n    and I = \"\\<lambda>(i,s). l\\<le>i \\<and> i\\<le>u \\<and> s = F {list!j | j. l\\<le>j \\<and> j<i} s0\"\n    ])"], ["proof (prove)\ngoal (4 subgoals):\n 1. l < u \\<Longrightarrow> wf (measure (\\<lambda>(i, uu_). u - i))\n 2. l < u \\<Longrightarrow>\n    case (l, s0) of\n    (i, s) \\<Rightarrow>\n      l \\<le> i \\<and>\n      i \\<le> u \\<and> s = F {list ! j |j. l \\<le> j \\<and> j < i} s0\n 3. \\<And>s.\n       \\<lbrakk>l < u;\n        case s of\n        (i, s) \\<Rightarrow>\n          l \\<le> i \\<and>\n          i \\<le> u \\<and> s = F {list ! j |j. l \\<le> j \\<and> j < i} s0;\n        c s\\<rbrakk>\n       \\<Longrightarrow> f s\n                         \\<le> SPEC\n                                (\\<lambda>s'.\n                                    (case s' of\n                                     (i, s) \\<Rightarrow>\n l \\<le> i \\<and>\n i \\<le> u \\<and> s = F {list ! j |j. l \\<le> j \\<and> j < i} s0) \\<and>\n                                    (s', s)\n                                    \\<in> measure\n     (\\<lambda>(i, uu_). u - i))\n 4. \\<And>s.\n       \\<lbrakk>l < u;\n        case s of\n        (i, s) \\<Rightarrow>\n          l \\<le> i \\<and>\n          i \\<le> u \\<and> s = F {list ! j |j. l \\<le> j \\<and> j < i} s0;\n        \\<not> c s\\<rbrakk>\n       \\<Longrightarrow> case s of\n                         (uu_, r) \\<Rightarrow>\n                           r = F {list ! i |i. l \\<le> i \\<and> i < u} s0", "apply rule"], ["proof (prove)\ngoal (3 subgoals):\n 1. l < u \\<Longrightarrow>\n    case (l, s0) of\n    (i, s) \\<Rightarrow>\n      l \\<le> i \\<and>\n      i \\<le> u \\<and> s = F {list ! j |j. l \\<le> j \\<and> j < i} s0\n 2. \\<And>s.\n       \\<lbrakk>l < u;\n        case s of\n        (i, s) \\<Rightarrow>\n          l \\<le> i \\<and>\n          i \\<le> u \\<and> s = F {list ! j |j. l \\<le> j \\<and> j < i} s0;\n        c s\\<rbrakk>\n       \\<Longrightarrow> f s\n                         \\<le> SPEC\n                                (\\<lambda>s'.\n                                    (case s' of\n                                     (i, s) \\<Rightarrow>\n l \\<le> i \\<and>\n i \\<le> u \\<and> s = F {list ! j |j. l \\<le> j \\<and> j < i} s0) \\<and>\n                                    (s', s)\n                                    \\<in> measure\n     (\\<lambda>(i, uu_). u - i))\n 3. \\<And>s.\n       \\<lbrakk>l < u;\n        case s of\n        (i, s) \\<Rightarrow>\n          l \\<le> i \\<and>\n          i \\<le> u \\<and> s = F {list ! j |j. l \\<le> j \\<and> j < i} s0;\n        \\<not> c s\\<rbrakk>\n       \\<Longrightarrow> case s of\n                         (uu_, r) \\<Rightarrow>\n                           r = F {list ! i |i. l \\<le> i \\<and> i < u} s0", "apply simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. l < u \\<Longrightarrow> s0 = F {list ! j |j. l \\<le> j \\<and> j < l} s0\n 2. \\<And>s.\n       \\<lbrakk>l < u;\n        case s of\n        (i, s) \\<Rightarrow>\n          l \\<le> i \\<and>\n          i \\<le> u \\<and> s = F {list ! j |j. l \\<le> j \\<and> j < i} s0;\n        c s\\<rbrakk>\n       \\<Longrightarrow> f s\n                         \\<le> SPEC\n                                (\\<lambda>s'.\n                                    (case s' of\n                                     (i, s) \\<Rightarrow>\n l \\<le> i \\<and>\n i \\<le> u \\<and> s = F {list ! j |j. l \\<le> j \\<and> j < i} s0) \\<and>\n                                    (s', s)\n                                    \\<in> measure\n     (\\<lambda>(i, uu_). u - i))\n 3. \\<And>s.\n       \\<lbrakk>l < u;\n        case s of\n        (i, s) \\<Rightarrow>\n          l \\<le> i \\<and>\n          i \\<le> u \\<and> s = F {list ! j |j. l \\<le> j \\<and> j < i} s0;\n        \\<not> c s\\<rbrakk>\n       \\<Longrightarrow> case s of\n                         (uu_, r) \\<Rightarrow>\n                           r = F {list ! i |i. l \\<le> i \\<and> i < u} s0", "apply (subst F0[symmetric])"], ["proof (prove)\ngoal (3 subgoals):\n 1. l < u \\<Longrightarrow>\n    F {} s0 = F {list ! j |j. l \\<le> j \\<and> j < l} s0\n 2. \\<And>s.\n       \\<lbrakk>l < u;\n        case s of\n        (i, s) \\<Rightarrow>\n          l \\<le> i \\<and>\n          i \\<le> u \\<and> s = F {list ! j |j. l \\<le> j \\<and> j < i} s0;\n        c s\\<rbrakk>\n       \\<Longrightarrow> f s\n                         \\<le> SPEC\n                                (\\<lambda>s'.\n                                    (case s' of\n                                     (i, s) \\<Rightarrow>\n l \\<le> i \\<and>\n i \\<le> u \\<and> s = F {list ! j |j. l \\<le> j \\<and> j < i} s0) \\<and>\n                                    (s', s)\n                                    \\<in> measure\n     (\\<lambda>(i, uu_). u - i))\n 3. \\<And>s.\n       \\<lbrakk>l < u;\n        case s of\n        (i, s) \\<Rightarrow>\n          l \\<le> i \\<and>\n          i \\<le> u \\<and> s = F {list ! j |j. l \\<le> j \\<and> j < i} s0;\n        \\<not> c s\\<rbrakk>\n       \\<Longrightarrow> case s of\n                         (uu_, r) \\<Rightarrow>\n                           r = F {list ! i |i. l \\<le> i \\<and> i < u} s0", "apply ((fo_rule cong refl)+, auto) []"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>l < u;\n        case s of\n        (i, s) \\<Rightarrow>\n          l \\<le> i \\<and>\n          i \\<le> u \\<and> s = F {list ! j |j. l \\<le> j \\<and> j < i} s0;\n        c s\\<rbrakk>\n       \\<Longrightarrow> f s\n                         \\<le> SPEC\n                                (\\<lambda>s'.\n                                    (case s' of\n                                     (i, s) \\<Rightarrow>\n l \\<le> i \\<and>\n i \\<le> u \\<and> s = F {list ! j |j. l \\<le> j \\<and> j < i} s0) \\<and>\n                                    (s', s)\n                                    \\<in> measure\n     (\\<lambda>(i, uu_). u - i))\n 2. \\<And>s.\n       \\<lbrakk>l < u;\n        case s of\n        (i, s) \\<Rightarrow>\n          l \\<le> i \\<and>\n          i \\<le> u \\<and> s = F {list ! j |j. l \\<le> j \\<and> j < i} s0;\n        \\<not> c s\\<rbrakk>\n       \\<Longrightarrow> case s of\n                         (uu_, r) \\<Rightarrow>\n                           r = F {list ! i |i. l \\<le> i \\<and> i < u} s0", "apply (clarsimp simp: CEQ)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>a < u; l \\<le> a\\<rbrakk>\n       \\<Longrightarrow> f (a, F {list ! j |j. l \\<le> j \\<and> j < a} s0)\n                         \\<le> SPEC\n                                (\\<lambda>s'.\n                                    (case s' of\n                                     (i, s) \\<Rightarrow>\n l \\<le> i \\<and>\n i \\<le> u \\<and> s = F {list ! j |j. l \\<le> j \\<and> j < i} s0) \\<and>\n                                    (case s' of\n                                     (i, uu_) \\<Rightarrow> u - i)\n                                    < u - a)\n 2. \\<And>s.\n       \\<lbrakk>l < u;\n        case s of\n        (i, s) \\<Rightarrow>\n          l \\<le> i \\<and>\n          i \\<le> u \\<and> s = F {list ! j |j. l \\<le> j \\<and> j < i} s0;\n        \\<not> c s\\<rbrakk>\n       \\<Longrightarrow> case s of\n                         (uu_, r) \\<Rightarrow>\n                           r = F {list ! i |i. l \\<le> i \\<and> i < u} s0", "apply (rule order_trans[OF Fs], simp_all) []"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>a < u; l \\<le> a\\<rbrakk>\n       \\<Longrightarrow> F (insert (list ! a)\n                             {list ! j |j. l \\<le> j \\<and> j < a})\n                          s0 =\n                         F {list ! j |j. l \\<le> j \\<and> j < Suc a}\n                          s0 \\<and>\n                         u - Suc a < u - a\n 2. \\<And>s.\n       \\<lbrakk>l < u;\n        case s of\n        (i, s) \\<Rightarrow>\n          l \\<le> i \\<and>\n          i \\<le> u \\<and> s = F {list ! j |j. l \\<le> j \\<and> j < i} s0;\n        \\<not> c s\\<rbrakk>\n       \\<Longrightarrow> case s of\n                         (uu_, r) \\<Rightarrow>\n                           r = F {list ! i |i. l \\<le> i \\<and> i < u} s0", "apply (auto\n    intro!: fun_cong[OF arg_cong[of _ _ F]]\n    elim: less_SucE) []"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>l < u;\n        case s of\n        (i, s) \\<Rightarrow>\n          l \\<le> i \\<and>\n          i \\<le> u \\<and> s = F {list ! j |j. l \\<le> j \\<and> j < i} s0;\n        \\<not> c s\\<rbrakk>\n       \\<Longrightarrow> case s of\n                         (uu_, r) \\<Rightarrow>\n                           r = F {list ! i |i. l \\<le> i \\<and> i < u} s0", "apply (auto simp: CEQ) []"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"]]}