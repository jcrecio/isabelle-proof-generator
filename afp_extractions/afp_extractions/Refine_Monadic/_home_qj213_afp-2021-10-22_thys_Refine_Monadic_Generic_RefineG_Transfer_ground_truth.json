{"file_name": "/home/qj213/afp-2021-10-22/thys/Refine_Monadic/Generic/RefineG_Transfer.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Refine_Monadic", "problem_names": ["lemma REFINEG_TRANSFER_ALIGNI: \"REFINEG_TRANSFER_ALIGN x y\"", "lemma START_REFINEG_TRANSFER: \n  assumes \"REFINEG_TRANSFER_ALIGN d c\"\n  assumes \"c\\<le>a\"\n  assumes \"REFINEG_TRANSFER_POST_SIMP c d\"\n  shows \"d\\<le>a\"", "lemma STOP_REFINEG_TRANSFER: \"REFINEG_TRANSFER_POST_SIMP c c\"", "lemma transfer_if[refine_transfer]:\n  assumes \"b \\<Longrightarrow> \\<alpha> s1 \\<le> S1\"\n  assumes \"\\<not>b \\<Longrightarrow> \\<alpha> s2 \\<le> S2\"\n  shows \"\\<alpha> (if b then s1 else s2) \\<le> (if b then S1 else S2)\"", "lemma transfer_prod[refine_transfer]:\n  assumes \"\\<And>a b. \\<alpha> (f a b) \\<le> F a b\"\n  shows \"\\<alpha> (case_prod f x) \\<le> (case_prod F x)\"", "lemma transfer_Let[refine_transfer]:\n  assumes \"\\<And>x. \\<alpha> (f x) \\<le> F x\"\n  shows \"\\<alpha> (Let x f) \\<le> Let x F\"", "lemma transfer_option[refine_transfer]:\n  assumes \"\\<alpha> fa \\<le> Fa\"\n  assumes \"\\<And>x. \\<alpha> (fb x) \\<le> Fb x\"\n  shows \"\\<alpha> (case_option fa fb x) \\<le> case_option Fa Fb x\"", "lemma transfer_sum[refine_transfer]:\n  assumes \"\\<And>l. \\<alpha> (fl l) \\<le> Fl l\"\n  assumes \"\\<And>r. \\<alpha> (fr r) \\<le> Fr r\"\n  shows \"\\<alpha> (case_sum fl fr x) \\<le> (case_sum Fl Fr x)\"", "lemma transfer_list[refine_transfer]:\n  assumes \"\\<alpha> fn \\<le> Fn\"\n  assumes \"\\<And>x xs. \\<alpha> (fc x xs) \\<le> Fc x xs\"\n  shows \"\\<alpha> (case_list fn fc l) \\<le> case_list Fn Fc l\"", "lemma transfer_rec_list[refine_transfer]:\n  assumes FN: \"\\<And>s. \\<alpha> (fn s) \\<le> fn' s\"\n  assumes FC: \"\\<And>x l rec rec' s. \\<lbrakk> \\<And>s. \\<alpha> (rec s) \\<le> (rec' s) \\<rbrakk> \n    \\<Longrightarrow> \\<alpha> (fc x l rec s) \\<le> fc' x l rec' s\"\n  shows \"\\<alpha> (rec_list fn fc l s) \\<le> rec_list fn' fc' l s\"", "lemma transfer_rec_nat[refine_transfer]:\n  assumes FN: \"\\<And>s. \\<alpha> (fn s) \\<le> fn' s\"\n  assumes FC: \"\\<And>n rec rec' s. \\<lbrakk> \\<And>s. \\<alpha> (rec s) \\<le> rec' s \\<rbrakk> \n    \\<Longrightarrow> \\<alpha> (fs n rec s) \\<le> fs' n rec' s\"\n  shows \"\\<alpha> (rec_nat fn fs n s) \\<le> rec_nat fn' fs' n s\"", "lemma \\<alpha>_mono[simp, intro!]: \"mono \\<alpha>\"", "lemma \\<alpha>_strict[simp]: \"\\<alpha> bot = bot\"", "lemma \\<alpha>_mono[simp, intro!]: \"mono \\<alpha>\"", "lemma \\<alpha>_strict[simp]: \"\\<alpha> (Sup {}) = bot\""], "translations": [["", "lemma REFINEG_TRANSFER_ALIGNI: \"REFINEG_TRANSFER_ALIGN x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. REFINEG_TRANSFER_ALIGN x y", "by simp"], ["", "lemma START_REFINEG_TRANSFER: \n  assumes \"REFINEG_TRANSFER_ALIGN d c\"\n  assumes \"c\\<le>a\"\n  assumes \"REFINEG_TRANSFER_POST_SIMP c d\"\n  shows \"d\\<le>a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d \\<le> a", "using assms"], ["proof (prove)\nusing this:\n  REFINEG_TRANSFER_ALIGN d c\n  c \\<le> a\n  REFINEG_TRANSFER_POST_SIMP c d\n\ngoal (1 subgoal):\n 1. d \\<le> a", "by (simp add: REFINEG_TRANSFER_POST_SIMP_def)"], ["", "lemma STOP_REFINEG_TRANSFER: \"REFINEG_TRANSFER_POST_SIMP c c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. REFINEG_TRANSFER_POST_SIMP c c", "unfolding REFINEG_TRANSFER_POST_SIMP_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. c = c", ".."], ["", "ML \\<open>\nstructure RefineG_Transfer = struct\n\n  structure Post_Processors = Theory_Data (\n    type T = (Proof.context -> tactic') Symtab.table\n    val empty = Symtab.empty\n    val extend = I\n    val merge = Symtab.join (K snd)\n  )\n\n  fun add_post_processor name tac =\n    Post_Processors.map (Symtab.update_new (name,tac))\n  fun delete_post_processor name =\n    Post_Processors.map (Symtab.delete name)\n  val get_post_processors = Post_Processors.get #> Symtab.dest\n\n  fun post_process_tac ctxt = let\n    val tacs = get_post_processors (Proof_Context.theory_of ctxt)\n      |> map (fn (_,tac) => tac ctxt)\n\n    val tac = REPEAT_DETERM' (CHANGED o EVERY' (map (fn t => TRY o t) tacs))\n  in\n    tac\n  end\n\n  structure Post_Simp = Generic_Data (\n      type T = simpset\n      val empty = HOL_basic_ss\n      val extend = I\n      val merge = Raw_Simplifier.merge_ss\n  )\n\n  fun post_simps_op f a context = let\n    val ctxt = Context.proof_of context\n    fun do_it ss = simpset_of (f (put_simpset ss ctxt, a))\n  in\n    Post_Simp.map do_it context\n  end\n    \n  val add_post_simps = post_simps_op (op addsimps)\n  val del_post_simps = post_simps_op (op delsimps)\n\n  fun get_post_ss ctxt = let\n    val ss = Post_Simp.get (Context.Proof ctxt)\n    val ctxt = put_simpset ss ctxt\n  in\n    ctxt\n  end\n\n  structure post_subst = Named_Thms\n    ( val name = @{binding refine_transfer_post_subst}\n      val description = \"Refinement Framework: \" ^ \n        \"Transfer postprocessing substitutions\" );\n\n  fun post_subst_tac ctxt = let\n    val s_thms = post_subst.get ctxt\n    val dis_tac = (ALLGOALS (Tagged_Solver.solve_tac ctxt))\n    val cnv = Cond_Rewr_Conv.cond_rewrs_conv dis_tac s_thms\n    val ts_conv = Conv.top_sweep_conv cnv ctxt\n    val ss = get_post_ss ctxt\n  in\n    REPEAT o CHANGED o \n    (Simplifier.simp_tac ss THEN' CONVERSION ts_conv)\n  end\n\n\n  structure transfer = Named_Thms\n    ( val name = @{binding refine_transfer}\n      val description = \"Refinement Framework: \" ^ \n        \"Transfer rules\" );\n\n  fun transfer_tac thms ctxt i st = let \n    val thms = thms @ transfer.get ctxt;\n    val ss = put_simpset HOL_basic_ss ctxt addsimps @{thms nested_case_prod_simp}\n  in\n    REPEAT_DETERM1 (\n      COND (has_fewer_prems (Thm.nprems_of st)) no_tac (\n        FIRST [\n          Method.assm_tac ctxt i,\n          resolve_tac ctxt thms i,\n          Tagged_Solver.solve_tac ctxt i,\n          CHANGED_PROP (simp_tac ss i)]\n      )) st\n  end\n\n  (* Adjust right term to have same structure as left one *)\n  fun align_tac ctxt = IF_EXGOAL (fn i => fn st =>\n    case Logic.concl_of_goal (Thm.prop_of st) i of\n      @{mpat \"Trueprop (REFINEG_TRANSFER_ALIGN ?c _)\"} => let\n        val c = Thm.cterm_of ctxt c\n        val cT = Thm.ctyp_of_cterm c\n        \n        val rl = @{thm REFINEG_TRANSFER_ALIGNI}\n          |> Thm.incr_indexes (Thm.maxidx_of st + 1)\n          |> Thm.instantiate' [NONE,SOME cT] [NONE,SOME c]\n        (*val _ = tracing (@{make_string} rl)*)\n      in\n        resolve_tac ctxt [rl] i st\n      end\n    | _ => Seq.empty\n  )\n\n  fun post_transfer_tac thms ctxt = let open Autoref_Tacticals in\n    resolve_tac ctxt @{thms START_REFINEG_TRANSFER} \n    THEN' align_tac ctxt \n    THEN' IF_SOLVED (transfer_tac thms ctxt)\n      (post_process_tac ctxt THEN' resolve_tac ctxt @{thms STOP_REFINEG_TRANSFER})\n      (K all_tac)\n\n  end\n\n  fun get_post_simp_rules context = Context.proof_of context\n      |> get_post_ss\n      |> simpset_of \n      |> Raw_Simplifier.dest_ss\n      |> #simps |> map snd\n\n\n  local\n    val add_ps = Thm.declaration_attribute (add_post_simps o single)\n    val del_ps = Thm.declaration_attribute (del_post_simps o single)\n  in\n    val setup = I\n      #> add_post_processor \"RefineG_Transfer.post_subst\" post_subst_tac\n      #> post_subst.setup\n      #> transfer.setup\n      #> Attrib.setup @{binding refine_transfer_post_simp} \n          (Attrib.add_del add_ps del_ps) \n          (\"declaration of transfer post simplification rules\")\n      #> Global_Theory.add_thms_dynamic (\n           @{binding refine_transfer_post_simps}, get_post_simp_rules)\n\n  end\nend\n\\<close>"], ["", "setup \\<open>RefineG_Transfer.setup\\<close>"], ["", "method_setup refine_transfer = \n  \\<open>Scan.lift (Args.mode \"post\") -- Attrib.thms \n  >> (fn (post,thms) => fn ctxt => SIMPLE_METHOD'\n    ( if post then RefineG_Transfer.post_transfer_tac thms ctxt\n      else RefineG_Transfer.transfer_tac thms ctxt))\n\\<close> \"Invoke transfer rules\""], ["", "locale transfer = fixes \\<alpha> :: \"'c \\<Rightarrow> 'a::complete_lattice\"\nbegin"], ["", "text \\<open>\n  In the following, we define some transfer lemmas for general\n  HOL - constructs.\n\\<close>"], ["", "lemma transfer_if[refine_transfer]:\n  assumes \"b \\<Longrightarrow> \\<alpha> s1 \\<le> S1\"\n  assumes \"\\<not>b \\<Longrightarrow> \\<alpha> s2 \\<le> S2\"\n  shows \"\\<alpha> (if b then s1 else s2) \\<le> (if b then S1 else S2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha> (if b then s1 else s2) \\<le> (if b then S1 else S2)", "using assms"], ["proof (prove)\nusing this:\n  b \\<Longrightarrow> \\<alpha> s1 \\<le> S1\n  \\<not> b \\<Longrightarrow> \\<alpha> s2 \\<le> S2\n\ngoal (1 subgoal):\n 1. \\<alpha> (if b then s1 else s2) \\<le> (if b then S1 else S2)", "by auto"], ["", "lemma transfer_prod[refine_transfer]:\n  assumes \"\\<And>a b. \\<alpha> (f a b) \\<le> F a b\"\n  shows \"\\<alpha> (case_prod f x) \\<le> (case_prod F x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha> (case x of (x, xa) \\<Rightarrow> f x xa)\n    \\<le> (case x of (x, xa) \\<Rightarrow> F x xa)", "using assms"], ["proof (prove)\nusing this:\n  \\<alpha> (f ?a ?b) \\<le> F ?a ?b\n\ngoal (1 subgoal):\n 1. \\<alpha> (case x of (x, xa) \\<Rightarrow> f x xa)\n    \\<le> (case x of (x, xa) \\<Rightarrow> F x xa)", "by (auto split: prod.split)"], ["", "lemma transfer_Let[refine_transfer]:\n  assumes \"\\<And>x. \\<alpha> (f x) \\<le> F x\"\n  shows \"\\<alpha> (Let x f) \\<le> Let x F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha> (Let x f) \\<le> Let x F", "using assms"], ["proof (prove)\nusing this:\n  \\<alpha> (f ?x) \\<le> F ?x\n\ngoal (1 subgoal):\n 1. \\<alpha> (Let x f) \\<le> Let x F", "by auto"], ["", "lemma transfer_option[refine_transfer]:\n  assumes \"\\<alpha> fa \\<le> Fa\"\n  assumes \"\\<And>x. \\<alpha> (fb x) \\<le> Fb x\"\n  shows \"\\<alpha> (case_option fa fb x) \\<le> case_option Fa Fb x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha> (case x of None \\<Rightarrow> fa | Some x \\<Rightarrow> fb x)\n    \\<le> (case x of None \\<Rightarrow> Fa | Some x \\<Rightarrow> Fb x)", "using assms"], ["proof (prove)\nusing this:\n  \\<alpha> fa \\<le> Fa\n  \\<alpha> (fb ?x) \\<le> Fb ?x\n\ngoal (1 subgoal):\n 1. \\<alpha> (case x of None \\<Rightarrow> fa | Some x \\<Rightarrow> fb x)\n    \\<le> (case x of None \\<Rightarrow> Fa | Some x \\<Rightarrow> Fb x)", "by (auto split: option.split)"], ["", "lemma transfer_sum[refine_transfer]:\n  assumes \"\\<And>l. \\<alpha> (fl l) \\<le> Fl l\"\n  assumes \"\\<And>r. \\<alpha> (fr r) \\<le> Fr r\"\n  shows \"\\<alpha> (case_sum fl fr x) \\<le> (case_sum Fl Fr x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha> (case x of Inl x \\<Rightarrow> fl x | Inr x \\<Rightarrow> fr x)\n    \\<le> (case x of Inl x \\<Rightarrow> Fl x | Inr x \\<Rightarrow> Fr x)", "using assms"], ["proof (prove)\nusing this:\n  \\<alpha> (fl ?l) \\<le> Fl ?l\n  \\<alpha> (fr ?r) \\<le> Fr ?r\n\ngoal (1 subgoal):\n 1. \\<alpha> (case x of Inl x \\<Rightarrow> fl x | Inr x \\<Rightarrow> fr x)\n    \\<le> (case x of Inl x \\<Rightarrow> Fl x | Inr x \\<Rightarrow> Fr x)", "by (auto split: sum.split)"], ["", "lemma transfer_list[refine_transfer]:\n  assumes \"\\<alpha> fn \\<le> Fn\"\n  assumes \"\\<And>x xs. \\<alpha> (fc x xs) \\<le> Fc x xs\"\n  shows \"\\<alpha> (case_list fn fc l) \\<le> case_list Fn Fc l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha> (case l of [] \\<Rightarrow> fn | x # xa \\<Rightarrow> fc x xa)\n    \\<le> (case l of [] \\<Rightarrow> Fn | x # xa \\<Rightarrow> Fc x xa)", "using assms"], ["proof (prove)\nusing this:\n  \\<alpha> fn \\<le> Fn\n  \\<alpha> (fc ?x ?xs) \\<le> Fc ?x ?xs\n\ngoal (1 subgoal):\n 1. \\<alpha> (case l of [] \\<Rightarrow> fn | x # xa \\<Rightarrow> fc x xa)\n    \\<le> (case l of [] \\<Rightarrow> Fn | x # xa \\<Rightarrow> Fc x xa)", "by (auto split: list.split)"], ["", "lemma transfer_rec_list[refine_transfer]:\n  assumes FN: \"\\<And>s. \\<alpha> (fn s) \\<le> fn' s\"\n  assumes FC: \"\\<And>x l rec rec' s. \\<lbrakk> \\<And>s. \\<alpha> (rec s) \\<le> (rec' s) \\<rbrakk> \n    \\<Longrightarrow> \\<alpha> (fc x l rec s) \\<le> fc' x l rec' s\"\n  shows \"\\<alpha> (rec_list fn fc l s) \\<le> rec_list fn' fc' l s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha> (rec_list fn fc l s) \\<le> rec_list fn' fc' l s", "apply (induct l arbitrary: s)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s. \\<alpha> (rec_list fn fc [] s) \\<le> rec_list fn' fc' [] s\n 2. \\<And>a l s.\n       (\\<And>s.\n           \\<alpha> (rec_list fn fc l s)\n           \\<le> rec_list fn' fc' l s) \\<Longrightarrow>\n       \\<alpha> (rec_list fn fc (a # l) s) \\<le> rec_list fn' fc' (a # l) s", "apply (simp add: FN)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a l s.\n       (\\<And>s.\n           \\<alpha> (rec_list fn fc l s)\n           \\<le> rec_list fn' fc' l s) \\<Longrightarrow>\n       \\<alpha> (rec_list fn fc (a # l) s) \\<le> rec_list fn' fc' (a # l) s", "apply (simp add: FC)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma transfer_rec_nat[refine_transfer]:\n  assumes FN: \"\\<And>s. \\<alpha> (fn s) \\<le> fn' s\"\n  assumes FC: \"\\<And>n rec rec' s. \\<lbrakk> \\<And>s. \\<alpha> (rec s) \\<le> rec' s \\<rbrakk> \n    \\<Longrightarrow> \\<alpha> (fs n rec s) \\<le> fs' n rec' s\"\n  shows \"\\<alpha> (rec_nat fn fs n s) \\<le> rec_nat fn' fs' n s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha> (rec_nat fn fs n s) \\<le> rec_nat fn' fs' n s", "apply (induct n arbitrary: s)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s. \\<alpha> (rec_nat fn fs 0 s) \\<le> rec_nat fn' fs' 0 s\n 2. \\<And>n s.\n       (\\<And>s.\n           \\<alpha> (rec_nat fn fs n s)\n           \\<le> rec_nat fn' fs' n s) \\<Longrightarrow>\n       \\<alpha> (rec_nat fn fs (Suc n) s) \\<le> rec_nat fn' fs' (Suc n) s", "apply (simp add: FN)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n s.\n       (\\<And>s.\n           \\<alpha> (rec_nat fn fs n s)\n           \\<le> rec_nat fn' fs' n s) \\<Longrightarrow>\n       \\<alpha> (rec_nat fn fs (Suc n) s) \\<le> rec_nat fn' fs' (Suc n) s", "apply (simp add: FC)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "text \\<open>Transfer into complete lattice structure\\<close>"], ["", "locale ordered_transfer = transfer + \n  constrains \\<alpha> :: \"'c::complete_lattice \\<Rightarrow> 'a::complete_lattice\""], ["", "text \\<open>Transfer into complete lattice structure with distributive\n  transfer function.\\<close>"], ["", "locale dist_transfer = ordered_transfer + \n  constrains \\<alpha> :: \"'c::complete_lattice \\<Rightarrow> 'a::complete_lattice\"\n  assumes \\<alpha>_dist: \"\\<And>A. is_chain A \\<Longrightarrow> \\<alpha> (Sup A) = Sup (\\<alpha>`A)\"\nbegin"], ["", "lemma \\<alpha>_mono[simp, intro!]: \"mono \\<alpha>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono \\<alpha>", "apply rule"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y. x \\<le> y \\<Longrightarrow> \\<alpha> x \\<le> \\<alpha> y", "apply (subgoal_tac \"is_chain {x,y}\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<le> y; is_chain {x, y}\\<rbrakk>\n       \\<Longrightarrow> \\<alpha> x \\<le> \\<alpha> y\n 2. \\<And>x y. x \\<le> y \\<Longrightarrow> is_chain {x, y}", "apply (drule \\<alpha>_dist)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<le> y;\n        \\<alpha> (Sup {x, y}) = Sup (\\<alpha> ` {x, y})\\<rbrakk>\n       \\<Longrightarrow> \\<alpha> x \\<le> \\<alpha> y\n 2. \\<And>x y. x \\<le> y \\<Longrightarrow> is_chain {x, y}", "apply (auto simp: le_iff_sup) []"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y. x \\<le> y \\<Longrightarrow> is_chain {x, y}", "apply (rule chainI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>x \\<le> y; xa \\<in> {x, y}; ya \\<in> {x, y}\\<rbrakk>\n       \\<Longrightarrow> xa \\<le> ya \\<or> ya \\<le> xa", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma \\<alpha>_strict[simp]: \"\\<alpha> bot = bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha> bot = bot", "using \\<alpha>_dist[of \"{}\"]"], ["proof (prove)\nusing this:\n  is_chain {} \\<Longrightarrow> \\<alpha> (Sup {}) = Sup (\\<alpha> ` {})\n\ngoal (1 subgoal):\n 1. \\<alpha> bot = bot", "by simp"], ["", "end"], ["", "text \\<open>Transfer into ccpo\\<close>"], ["", "locale ccpo_transfer = transfer \\<alpha> for\n  \\<alpha> :: \"'c::ccpo \\<Rightarrow> 'a::complete_lattice\""], ["", "text \\<open>Transfer into ccpo with distributive\n  transfer function.\\<close>"], ["", "locale dist_ccpo_transfer = ccpo_transfer \\<alpha>\n  for \\<alpha> :: \"'c::ccpo \\<Rightarrow> 'a::complete_lattice\" + \n  assumes \\<alpha>_dist: \"\\<And>A. is_chain A \\<Longrightarrow> \\<alpha> (Sup A) = Sup (\\<alpha>`A)\"\nbegin"], ["", "lemma \\<alpha>_mono[simp, intro!]: \"mono \\<alpha>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono \\<alpha>", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y. x \\<le> y \\<Longrightarrow> \\<alpha> x \\<le> \\<alpha> y", "fix x y :: 'c"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y. x \\<le> y \\<Longrightarrow> \\<alpha> x \\<le> \\<alpha> y", "assume LE: \"x\\<le>y\""], ["proof (state)\nthis:\n  x \\<le> y\n\ngoal (1 subgoal):\n 1. \\<And>x y. x \\<le> y \\<Longrightarrow> \\<alpha> x \\<le> \\<alpha> y", "hence C[simp, intro!]: \"is_chain {x,y}\""], ["proof (prove)\nusing this:\n  x \\<le> y\n\ngoal (1 subgoal):\n 1. is_chain {x, y}", "by (auto intro: chainI)"], ["proof (state)\nthis:\n  is_chain {x, y}\n\ngoal (1 subgoal):\n 1. \\<And>x y. x \\<le> y \\<Longrightarrow> \\<alpha> x \\<le> \\<alpha> y", "from LE"], ["proof (chain)\npicking this:\n  x \\<le> y", "have \"\\<alpha> x \\<le> sup (\\<alpha> x) (\\<alpha> y)\""], ["proof (prove)\nusing this:\n  x \\<le> y\n\ngoal (1 subgoal):\n 1. \\<alpha> x \\<le> sup (\\<alpha> x) (\\<alpha> y)", "by simp"], ["proof (state)\nthis:\n  \\<alpha> x \\<le> sup (\\<alpha> x) (\\<alpha> y)\n\ngoal (1 subgoal):\n 1. \\<And>x y. x \\<le> y \\<Longrightarrow> \\<alpha> x \\<le> \\<alpha> y", "also"], ["proof (state)\nthis:\n  \\<alpha> x \\<le> sup (\\<alpha> x) (\\<alpha> y)\n\ngoal (1 subgoal):\n 1. \\<And>x y. x \\<le> y \\<Longrightarrow> \\<alpha> x \\<le> \\<alpha> y", "have \"\\<dots> = Sup (\\<alpha>`{x,y})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sup (\\<alpha> x) (\\<alpha> y) = Sup (\\<alpha> ` {x, y})", "by simp"], ["proof (state)\nthis:\n  sup (\\<alpha> x) (\\<alpha> y) = Sup (\\<alpha> ` {x, y})\n\ngoal (1 subgoal):\n 1. \\<And>x y. x \\<le> y \\<Longrightarrow> \\<alpha> x \\<le> \\<alpha> y", "also"], ["proof (state)\nthis:\n  sup (\\<alpha> x) (\\<alpha> y) = Sup (\\<alpha> ` {x, y})\n\ngoal (1 subgoal):\n 1. \\<And>x y. x \\<le> y \\<Longrightarrow> \\<alpha> x \\<le> \\<alpha> y", "have \"\\<dots> = \\<alpha> (Sup {x,y})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Sup (\\<alpha> ` {x, y}) = \\<alpha> (Sup {x, y})", "by (rule \\<alpha>_dist[symmetric]) simp"], ["proof (state)\nthis:\n  Sup (\\<alpha> ` {x, y}) = \\<alpha> (Sup {x, y})\n\ngoal (1 subgoal):\n 1. \\<And>x y. x \\<le> y \\<Longrightarrow> \\<alpha> x \\<le> \\<alpha> y", "also"], ["proof (state)\nthis:\n  Sup (\\<alpha> ` {x, y}) = \\<alpha> (Sup {x, y})\n\ngoal (1 subgoal):\n 1. \\<And>x y. x \\<le> y \\<Longrightarrow> \\<alpha> x \\<le> \\<alpha> y", "have \"Sup {x,y} = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Sup {x, y} = y", "apply (rule antisym)"], ["proof (prove)\ngoal (2 subgoals):\n 1. Sup {x, y} \\<le> y\n 2. y \\<le> Sup {x, y}", "apply (rule ccpo_Sup_least[OF C])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa. xa \\<in> {x, y} \\<Longrightarrow> xa \\<le> y\n 2. y \\<le> Sup {x, y}", "using LE"], ["proof (prove)\nusing this:\n  x \\<le> y\n\ngoal (2 subgoals):\n 1. \\<And>xa. xa \\<in> {x, y} \\<Longrightarrow> xa \\<le> y\n 2. y \\<le> Sup {x, y}", "apply auto []"], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<le> Sup {x, y}", "apply (rule ccpo_Sup_upper[OF C])"], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<in> {x, y}", "by auto"], ["proof (state)\nthis:\n  Sup {x, y} = y\n\ngoal (1 subgoal):\n 1. \\<And>x y. x \\<le> y \\<Longrightarrow> \\<alpha> x \\<le> \\<alpha> y", "finally"], ["proof (chain)\npicking this:\n  \\<alpha> x \\<le> \\<alpha> y", "show \"\\<alpha> x \\<le> \\<alpha> y\""], ["proof (prove)\nusing this:\n  \\<alpha> x \\<le> \\<alpha> y\n\ngoal (1 subgoal):\n 1. \\<alpha> x \\<le> \\<alpha> y", "."], ["proof (state)\nthis:\n  \\<alpha> x \\<le> \\<alpha> y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma \\<alpha>_strict[simp]: \"\\<alpha> (Sup {}) = bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha> (Sup {}) = bot", "using \\<alpha>_dist[of \"{}\"]"], ["proof (prove)\nusing this:\n  is_chain {} \\<Longrightarrow> \\<alpha> (Sup {}) = Sup (\\<alpha> ` {})\n\ngoal (1 subgoal):\n 1. \\<alpha> (Sup {}) = bot", "by simp"], ["", "end"], ["", "end"]]}