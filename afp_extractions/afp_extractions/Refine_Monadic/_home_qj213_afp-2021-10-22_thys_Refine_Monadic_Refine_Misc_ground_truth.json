{"file_name": "/home/qj213/afp-2021-10-22/thys/Refine_Monadic/Refine_Misc.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Refine_Monadic", "problem_names": ["lemmas [refine_mono] = monoI monotoneI[of \"(\\<le>)\" \"(\\<le>)\"]", "lemmas [refine_mono] = TrueI le_funI order_refl", "lemma case_prod_mono[refine_mono]: \n  \"\\<lbrakk>\\<And>a b. p=(a,b) \\<Longrightarrow> f a b \\<le> f' a b\\<rbrakk> \\<Longrightarrow> case_prod f p \\<le> case_prod f' p\"", "lemma case_option_mono[refine_mono]:\n  assumes \"fn \\<le> fn'\"\n  assumes \"\\<And>v. x=Some v \\<Longrightarrow> fs v \\<le> fs' v\"\n  shows \"case_option fn fs x \\<le> case_option fn' fs' x\"", "lemma case_list_mono[refine_mono]:\n  assumes \"fn \\<le> fn'\"\n  assumes \"\\<And>x xs. l=x#xs \\<Longrightarrow> fc x xs \\<le> fc' x xs\"\n  shows \"case_list fn fc l \\<le> case_list fn' fc' l\"", "lemma if_mono[refine_mono]:\n  assumes \"b \\<Longrightarrow> m1 \\<le> m1'\"\n  assumes \"\\<not>b \\<Longrightarrow> m2 \\<le> m2'\"\n  shows \"(if b then m1 else m2) \\<le> (if b then m1' else m2')\"", "lemma let_mono[refine_mono]:\n  \"f x \\<le> f' x' \\<Longrightarrow> Let x f \\<le> Let x' f'\"", "lemma all_nat_split_at: \"\\<forall>i::'a::linorder<k. P i \\<Longrightarrow> P k \\<Longrightarrow> \\<forall>i>k. P i \n  \\<Longrightarrow> \\<forall>i. P i\"", "lemma wf_no_infinite_down_chainI:\n  assumes \"\\<And>f. \\<lbrakk>\\<And>i. (f (Suc i), f i)\\<in>r\\<rbrakk> \\<Longrightarrow> False\"\n  shows \"wf r\"", "lemma sim_wf:\n  assumes WF: \"wf (S'\\<inverse>)\"\n  assumes STARTR: \"(x0,x0')\\<in>R\"\n  assumes SIM: \"\\<And>s s' t. \\<lbrakk> (s,s')\\<in>R; (s,t)\\<in>S; (x0',s')\\<in>S'\\<^sup>* \\<rbrakk> \n    \\<Longrightarrow> \\<exists>t'. (s',t')\\<in>S' \\<and> (t,t')\\<in>R\"\n  assumes CLOSED: \"Domain S  \\<subseteq> S\\<^sup>*``{x0}\"\n  shows \"wf (S\\<inverse>)\"", "lemma finite_psupset_wf[simp, intro]: \"finite S \\<Longrightarrow> wf (finite_psupset S)\"", "lemma wf_less_than_bool[simp, intro!]: \"wf (less_than_bool)\"", "lemma less_than_bool_iff[simp]:\n  \"(x,y)\\<in>less_than_bool \\<longleftrightarrow> x=False \\<and> y=True\"", "lemma wf_greater_bounded[simp, intro!]: \"wf (greater_bounded N)\"", "lemma greater_bounded_Suc_iff[simp]: \"(Suc x,x)\\<in>greater_bounded N \\<longleftrightarrow> Suc x \\<le> N\"", "lemma mono_const[simp, intro!]: \"mono (\\<lambda>_. c)\"", "lemma mono_if: \"\\<lbrakk>mono S1; mono S2\\<rbrakk> \\<Longrightarrow>\n  mono (\\<lambda>F s. if b s then S1 F s else S2 F s)\"", "lemma mono_infI: \"mono f \\<Longrightarrow> mono g \\<Longrightarrow> mono (inf f g)\"", "lemma mono_infI': \n  \"mono f \\<Longrightarrow> mono g \\<Longrightarrow> mono (\\<lambda>x. inf (f x) (g x) :: 'b::lattice)\"", "lemma mono_infArg: \n  fixes f :: \"'a::lattice \\<Rightarrow> 'b::order\"\n  shows \"mono f \\<Longrightarrow> mono (\\<lambda>x. f (inf x X))\"", "lemma mono_Sup:\n  fixes f :: \"'a::complete_lattice \\<Rightarrow> 'b::complete_lattice\"\n  shows \"mono f \\<Longrightarrow> Sup (f`S) \\<le> f (Sup S)\"", "lemma mono_SupI:\n  fixes f :: \"'a::complete_lattice \\<Rightarrow> 'b::complete_lattice\"\n  assumes \"mono f\"\n  assumes \"S'\\<subseteq>f`S\"\n  shows \"Sup S' \\<le> f (Sup S)\"", "lemma mono_Inf:\n  fixes f :: \"'a::complete_lattice \\<Rightarrow> 'b::complete_lattice\"\n  shows \"mono f \\<Longrightarrow> f (Inf S) \\<le> Inf (f`S)\"", "lemma mono_funpow: \"mono (f::'a::order \\<Rightarrow> 'a) \\<Longrightarrow> mono (f^^i)\"", "lemma mono_id[simp, intro!]:\n  \"mono id\"\n  \"mono (\\<lambda>x. x)\"", "lemma (in semilattice_inf) le_infD1:\n  \"a \\<le> inf b c \\<Longrightarrow> a \\<le> b\"", "lemma (in semilattice_inf) le_infD2:\n  \"a \\<le> inf b c \\<Longrightarrow> a \\<le> c\"", "lemma (in semilattice_inf) inf_leI:\n  \"\\<lbrakk> \\<And>x. \\<lbrakk> x\\<le>a; x\\<le>b \\<rbrakk> \\<Longrightarrow> x\\<le>c \\<rbrakk> \\<Longrightarrow> inf a b \\<le> c\"", "lemma top_Sup: \"(top::'a::complete_lattice)\\<in>A \\<Longrightarrow> Sup A = top\"", "lemma bot_Inf: \"(bot::'a::complete_lattice)\\<in>A \\<Longrightarrow> Inf A = bot\"", "lemma mono_compD: \"mono f \\<Longrightarrow> x\\<le>y \\<Longrightarrow> f o x \\<le> f o y\"", "lemma \\<alpha>\\<gamma>_defl: \"\\<alpha>(\\<gamma>(x)) \\<le> x\"", "lemma \\<gamma>\\<alpha>_infl: \"x \\<le> \\<gamma>(\\<alpha>(x))\"", "lemma \\<alpha>_mono: \"mono \\<alpha>\"", "lemma \\<gamma>_mono: \"mono \\<gamma>\"", "lemma dist_\\<gamma>[simp]: \n    \"\\<gamma> (inf a b) = inf (\\<gamma> a) (\\<gamma> b)\"", "lemma dist_\\<alpha>[simp]: \n    \"\\<alpha> (sup a b) = sup (\\<alpha> a) (\\<alpha> b)\"", "lemma mono_lfp_eqI:\n  assumes MONO: \"mono f\"\n  assumes FIXP: \"f a \\<le> a\"\n  assumes LEAST: \"\\<And>x. f x = x \\<Longrightarrow> a\\<le>x\"\n  shows \"lfp f = a\"", "lemma mono_gfp_eqI:\n  assumes MONO: \"mono f\"\n  assumes FIXP: \"a \\<le> f a\"\n  assumes GREATEST: \"\\<And>x. f x = x \\<Longrightarrow> x\\<le>a\"\n  shows \"gfp f = a\"", "lemma lfp_le_gfp': \"mono f \\<Longrightarrow> lfp f x \\<le> gfp f x\"", "lemma lfp_induct':\n  assumes M: \"mono f\"\n  assumes IS: \"\\<And>m. \\<lbrakk> m \\<le> lfp f; m \\<le> P \\<rbrakk> \\<Longrightarrow> f m \\<le> P\"\n  shows \"lfp f \\<le> P\"", "lemma lfp_gen_induct:\n  \\<comment> \\<open>Induction lemma for generalized lfps\\<close>\n  assumes M: \"mono f\"\n  notes MONO'[refine_mono] = monoD[OF M]\n  assumes I0: \"m0 \\<le> P\"\n  assumes IS: \"\\<And>m. \\<lbrakk>\n      m \\<le> lfp (\\<lambda>s. sup m0 (f s));  \\<comment> \\<open>Assume already established invariants\\<close>\n      m \\<le> P;                       \\<comment> \\<open>Assume invariant\\<close>\n      f m \\<le> lfp (\\<lambda>s. sup m0 (f s)) \\<comment> \\<open>Assume that step preserved est. invars\\<close>\n    \\<rbrakk> \\<Longrightarrow> f m \\<le> P\"                 \\<comment> \\<open>Show that step preserves invariant\\<close>\n  shows \"lfp (\\<lambda>s. sup m0 (f s)) \\<le> P\"", "lemma (in complete_lattice) is_ccpo: \"class.ccpo Sup (\\<le>) (<)\"", "lemma (in complete_lattice) is_dual_ccpo: \"class.ccpo Inf (\\<ge>) (>)\"", "lemma ccpo_mono_simp: \"monotone (\\<le>) (\\<le>) f \\<longleftrightarrow> mono f\"", "lemma ccpo_monoI: \"mono f \\<Longrightarrow> monotone (\\<le>) (\\<le>) f\"", "lemma ccpo_monoD: \"monotone (\\<le>) (\\<le>) f \\<Longrightarrow> mono f\"", "lemma dual_ccpo_mono_simp: \"monotone (\\<ge>) (\\<ge>) f \\<longleftrightarrow> mono f\"", "lemma dual_ccpo_monoI: \"mono f \\<Longrightarrow> monotone (\\<ge>) (\\<ge>) f\"", "lemma dual_ccpo_monoD: \"monotone (\\<ge>) (\\<ge>) f \\<Longrightarrow> mono f\"", "lemma ccpo_lfp_simp: \"\\<And>f. mono f \\<Longrightarrow> ccpo.fixp Sup (\\<le>) f = lfp f\"", "lemma ccpo_gfp_simp: \"\\<And>f. mono f \\<Longrightarrow> ccpo.fixp Inf (\\<ge>) f = gfp f\"", "lemmas chain_admissibleI[intro?] = ccpo.admissibleI[where lub=Sup and ord=\"(\\<le>)\"]", "lemmas dual_chain_admissibleI[intro?] = \n  ccpo.admissibleI[where lub=Inf and ord=\"(\\<lambda>x y. y\\<le>x)\"]", "lemma dual_chain_iff[simp]: \"is_dual_chain C = is_chain C\"", "lemmas chain_dualI = iffD1[OF dual_chain_iff]", "lemmas dual_chainI = iffD2[OF dual_chain_iff]", "lemma is_chain_empty[simp, intro!]: \"is_chain {}\"", "lemma is_dual_chain_empty[simp, intro!]: \"is_dual_chain {}\"", "lemma point_chainI: \"is_chain M \\<Longrightarrow> is_chain ((\\<lambda>f. f x)`M)\"", "lemma lfp_cadm_induct:\n  \"\\<lbrakk>chain_admissible P; P (Sup {}); mono f; \\<And>x. P x \\<Longrightarrow> P (f x)\\<rbrakk> \\<Longrightarrow> P (lfp f)\"", "lemma gfp_cadm_induct:\n  \"\\<lbrakk>dual_chain_admissible P; P (Inf {}); mono f; \\<And>x. P x \\<Longrightarrow> P (f x)\\<rbrakk> \\<Longrightarrow> P (gfp f)\"", "lemma contI[intro?]: \"\\<lbrakk>\\<And>C. C\\<noteq>{} \\<Longrightarrow> f (Sup C) = Sup (f`C)\\<rbrakk> \\<Longrightarrow> cont f\"", "lemma contD: \"cont f \\<Longrightarrow> C\\<noteq>{} \\<Longrightarrow> f (Sup C) = Sup (f ` C)\"", "lemma contD': \"cont f \\<Longrightarrow> C\\<noteq>{} \\<Longrightarrow> f (Sup C) = Sup (f ` C)\"", "lemma strictD[dest]: \"strict f \\<Longrightarrow> f bot = bot\"", "lemma strictD_simp[simp]: \"strict f \\<Longrightarrow> f (bot::'a::bot) = (bot::'a)\"", "lemma strictI[intro?]: \"f bot = bot \\<Longrightarrow> strict f\"", "lemma inf_distribD[simp]: \n  \"inf_distrib f \\<Longrightarrow> strict f\"\n  \"inf_distrib f \\<Longrightarrow> cont f\"", "lemma inf_distribI[intro?]: \"\\<lbrakk>strict f; cont f\\<rbrakk> \\<Longrightarrow> inf_distrib f\"", "lemma inf_distribD'[simp]:\n  fixes f :: \"'a::complete_lattice \\<Rightarrow> 'b::complete_lattice\"\n  shows \"inf_distrib f \\<Longrightarrow> f (Sup C) = Sup (f`C)\"", "lemma inf_distribI':\n  fixes f :: \"'a::complete_lattice \\<Rightarrow> 'b::complete_lattice\"\n  assumes B: \"\\<And>C. f (Sup C) = Sup (f`C)\"\n  shows \"inf_distrib f\"", "lemma cont_is_mono[simp]: \n  fixes f :: \"'a::complete_lattice \\<Rightarrow> 'b::complete_lattice\"\n  shows \"cont f \\<Longrightarrow> mono f\"", "lemma inf_distrib_is_mono[simp]: \n  fixes f :: \"'a::complete_lattice \\<Rightarrow> 'b::complete_lattice\"\n  shows \"inf_distrib f \\<Longrightarrow> mono f\"", "theorem gen_kleene_lfp:\n  fixes f:: \"'a::complete_lattice \\<Rightarrow> 'a\"\n  assumes CONT: \"cont f\"\n  shows \"lfp (\\<lambda>x. sup m (f x)) = (SUP i. (f^^i) m)\"", "theorem kleene_lfp:\n  fixes f:: \"'a::complete_lattice \\<Rightarrow> 'a\"\n  assumes CONT: \"cont f\"\n  shows \"lfp f = (SUP i. (f^^i) bot)\"", "theorem (* Detailed proof *)\n  fixes f:: \"'a::complete_lattice \\<Rightarrow> 'a\"\n  assumes CONT: \"cont f\"\n  shows \"lfp f = (SUP i. (f^^i) bot)\"", "lemma SUP_funpow_contracting:\n  fixes f :: \"'a \\<Rightarrow> ('a::complete_lattice)\"\n  assumes C: \"cont f\" \n  shows \"f (SUP i. (f^^i) m) \\<le> (SUP i. (f^^i) m)\"", "lemma gen_kleene_chain_conv:\n  fixes f :: \"'a::complete_lattice \\<Rightarrow> 'a\"\n  assumes C: \"cont f\"\n  shows \"(SUP i. (f^^i) m) = (SUP i. ((\\<lambda>x. sup m (f x))^^i) bot)\"", "theorem \n  assumes C: \"cont f\"\n  shows \"lfp (\\<lambda>x. sup m (f x)) = (SUP i. (f^^i) m)\"", "lemma (in galois_connection) dual_inf_dist_\\<gamma>: \"\\<gamma> (Inf C) = Inf (\\<gamma>`C)\"", "lemma (in galois_connection) inf_dist_\\<alpha>: \"inf_distrib \\<alpha>\"", "lemma map_to_set_simps[simp]: \n    \"map_to_set Map.empty = {}\"\n    \"map_to_set [a\\<mapsto>b] = {(a,b)}\"\n    \"map_to_set (m|`K) = map_to_set m \\<inter> K\\<times>UNIV\"\n    \"map_to_set (m(x:=None)) = map_to_set m - {x}\\<times>UNIV\"\n    \"map_to_set (m(x\\<mapsto>v)) = map_to_set m - {x}\\<times>UNIV \\<union> {(x,v)}\"\n    \"map_to_set m \\<inter> dom m\\<times>UNIV = map_to_set m\"\n    \"m k = Some v \\<Longrightarrow> (k,v)\\<in>map_to_set m\"\n    \"single_valued (map_to_set m)\"", "lemma map_to_set_inj:     \n    \"(k,v)\\<in>map_to_set m \\<Longrightarrow> (k,v')\\<in>map_to_set m \\<Longrightarrow> v = v'\""], "translations": [["", "lemmas [refine_mono] = monoI monotoneI[of \"(\\<le>)\" \"(\\<le>)\"]"], ["", "lemmas [refine_mono] = TrueI le_funI order_refl"], ["", "lemma case_prod_mono[refine_mono]: \n  \"\\<lbrakk>\\<And>a b. p=(a,b) \\<Longrightarrow> f a b \\<le> f' a b\\<rbrakk> \\<Longrightarrow> case_prod f p \\<le> case_prod f' p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a b.\n        p = (a, b) \\<Longrightarrow> f a b \\<le> f' a b) \\<Longrightarrow>\n    (case p of (x, xa) \\<Rightarrow> f x xa)\n    \\<le> (case p of (x, xa) \\<Rightarrow> f' x xa)", "by (auto split: prod.split)"], ["", "lemma case_option_mono[refine_mono]:\n  assumes \"fn \\<le> fn'\"\n  assumes \"\\<And>v. x=Some v \\<Longrightarrow> fs v \\<le> fs' v\"\n  shows \"case_option fn fs x \\<le> case_option fn' fs' x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (case x of None \\<Rightarrow> fn | Some x \\<Rightarrow> fs x)\n    \\<le> (case x of None \\<Rightarrow> fn' | Some x \\<Rightarrow> fs' x)", "using assms"], ["proof (prove)\nusing this:\n  fn \\<le> fn'\n  x = Some ?v \\<Longrightarrow> fs ?v \\<le> fs' ?v\n\ngoal (1 subgoal):\n 1. (case x of None \\<Rightarrow> fn | Some x \\<Rightarrow> fs x)\n    \\<le> (case x of None \\<Rightarrow> fn' | Some x \\<Rightarrow> fs' x)", "by (auto split: option.split)"], ["", "lemma case_list_mono[refine_mono]:\n  assumes \"fn \\<le> fn'\"\n  assumes \"\\<And>x xs. l=x#xs \\<Longrightarrow> fc x xs \\<le> fc' x xs\"\n  shows \"case_list fn fc l \\<le> case_list fn' fc' l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (case l of [] \\<Rightarrow> fn | x # xa \\<Rightarrow> fc x xa)\n    \\<le> (case l of [] \\<Rightarrow> fn' | x # xa \\<Rightarrow> fc' x xa)", "using assms"], ["proof (prove)\nusing this:\n  fn \\<le> fn'\n  l = ?x # ?xs \\<Longrightarrow> fc ?x ?xs \\<le> fc' ?x ?xs\n\ngoal (1 subgoal):\n 1. (case l of [] \\<Rightarrow> fn | x # xa \\<Rightarrow> fc x xa)\n    \\<le> (case l of [] \\<Rightarrow> fn' | x # xa \\<Rightarrow> fc' x xa)", "by (auto split: list.split)"], ["", "lemma if_mono[refine_mono]:\n  assumes \"b \\<Longrightarrow> m1 \\<le> m1'\"\n  assumes \"\\<not>b \\<Longrightarrow> m2 \\<le> m2'\"\n  shows \"(if b then m1 else m2) \\<le> (if b then m1' else m2')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if b then m1 else m2) \\<le> (if b then m1' else m2')", "using assms"], ["proof (prove)\nusing this:\n  b \\<Longrightarrow> m1 \\<le> m1'\n  \\<not> b \\<Longrightarrow> m2 \\<le> m2'\n\ngoal (1 subgoal):\n 1. (if b then m1 else m2) \\<le> (if b then m1' else m2')", "by auto"], ["", "lemma let_mono[refine_mono]:\n  \"f x \\<le> f' x' \\<Longrightarrow> Let x f \\<le> Let x' f'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f x \\<le> f' x' \\<Longrightarrow> Let x f \\<le> Let x' f'", "by auto"], ["", "subsection \\<open>Uncategorized Lemmas\\<close>"], ["", "lemma all_nat_split_at: \"\\<forall>i::'a::linorder<k. P i \\<Longrightarrow> P k \\<Longrightarrow> \\<forall>i>k. P i \n  \\<Longrightarrow> \\<forall>i. P i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>i<k. P i; P k; \\<forall>i>k. P i\\<rbrakk>\n    \\<Longrightarrow> \\<forall>i. P i", "by (metis linorder_neq_iff)"], ["", "subsection \\<open>Well-Foundedness\\<close>"], ["", "lemma wf_no_infinite_down_chainI:\n  assumes \"\\<And>f. \\<lbrakk>\\<And>i. (f (Suc i), f i)\\<in>r\\<rbrakk> \\<Longrightarrow> False\"\n  shows \"wf r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf r", "by (metis assms wf_iff_no_infinite_down_chain)"], ["", "text \\<open>This lemma transfers well-foundedness over a simulation relation.\\<close>"], ["", "lemma sim_wf:\n  assumes WF: \"wf (S'\\<inverse>)\"\n  assumes STARTR: \"(x0,x0')\\<in>R\"\n  assumes SIM: \"\\<And>s s' t. \\<lbrakk> (s,s')\\<in>R; (s,t)\\<in>S; (x0',s')\\<in>S'\\<^sup>* \\<rbrakk> \n    \\<Longrightarrow> \\<exists>t'. (s',t')\\<in>S' \\<and> (t,t')\\<in>R\"\n  assumes CLOSED: \"Domain S  \\<subseteq> S\\<^sup>*``{x0}\"\n  shows \"wf (S\\<inverse>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf (S\\<inverse>)", "proof (rule wf_no_infinite_down_chainI, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f. (\\<And>i. (f i, f (Suc i)) \\<in> S) \\<Longrightarrow> False", "txt \\<open>\n    Informal proof:\n    Assume there is an infinite chain in \\<open>S\\<close>.\n    Due to the closedness property of \\<open>S\\<close>, it can be extended to \n    start at \\<open>x0\\<close>.\n    Now, we inductively construct an infinite chain in \\<open>S'\\<close>, such that\n    each element of the new chain is in relation with the corresponding \n    element of the original chain:\n      The first element is \\<open>x0'\\<close>. \n      For any element \\<open>i+1\\<close>, the simulation property yields the next\n      element.\n    This chain contradicts well-foundedness of \\<open>S'\\<close>.\n\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f. (\\<And>i. (f i, f (Suc i)) \\<in> S) \\<Longrightarrow> False", "fix f"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f. (\\<And>i. (f i, f (Suc i)) \\<in> S) \\<Longrightarrow> False", "assume CHAIN: \"\\<And>i. (f i, f (Suc i))\\<in>S\""], ["proof (state)\nthis:\n  (f ?i, f (Suc ?i)) \\<in> S\n\ngoal (1 subgoal):\n 1. \\<And>f. (\\<And>i. (f i, f (Suc i)) \\<in> S) \\<Longrightarrow> False", "txt \\<open>Extend to start with \\<open>x0\\<close>\\<close>"], ["proof (state)\nthis:\n  (f ?i, f (Suc ?i)) \\<in> S\n\ngoal (1 subgoal):\n 1. \\<And>f. (\\<And>i. (f i, f (Suc i)) \\<in> S) \\<Longrightarrow> False", "obtain f' where CHAIN': \"\\<And>i. (f' i, f' (Suc i))\\<in>S\" and [simp]: \"f' 0 = x0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>f'.\n        \\<lbrakk>\\<And>i. (f' i, f' (Suc i)) \\<in> S; f' 0 = x0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>f'.\n        \\<lbrakk>\\<And>i. (f' i, f' (Suc i)) \\<in> S; f' 0 = x0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>f'.\n        \\<lbrakk>\\<And>i. (f' i, f' (Suc i)) \\<in> S; f' 0 = x0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>f'.\n        \\<lbrakk>\\<And>i. (f' i, f' (Suc i)) \\<in> S; f' 0 = x0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "assume S: \"x = f 0\""], ["proof (state)\nthis:\n  x = f 0\n\ngoal (1 subgoal):\n 1. (\\<And>f'.\n        \\<lbrakk>\\<And>i. (f' i, f' (Suc i)) \\<in> S; f' 0 = x0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from CHAIN"], ["proof (chain)\npicking this:\n  (f ?i, f (Suc ?i)) \\<in> S", "have \"f 0 \\<in> Domain S\""], ["proof (prove)\nusing this:\n  (f ?i, f (Suc ?i)) \\<in> S\n\ngoal (1 subgoal):\n 1. f 0 \\<in> Domain S", "by auto"], ["proof (state)\nthis:\n  f 0 \\<in> Domain S\n\ngoal (1 subgoal):\n 1. (\\<And>f'.\n        \\<lbrakk>\\<And>i. (f' i, f' (Suc i)) \\<in> S; f' 0 = x0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "with CLOSED"], ["proof (chain)\npicking this:\n  Domain S \\<subseteq> S\\<^sup>* `` {x0}\n  f 0 \\<in> Domain S", "have \"(x0,x)\\<in>S\\<^sup>*\""], ["proof (prove)\nusing this:\n  Domain S \\<subseteq> S\\<^sup>* `` {x0}\n  f 0 \\<in> Domain S\n\ngoal (1 subgoal):\n 1. (x0, x) \\<in> S\\<^sup>*", "by (auto simp: S)"], ["proof (state)\nthis:\n  (x0, x) \\<in> S\\<^sup>*\n\ngoal (1 subgoal):\n 1. (\\<And>f'.\n        \\<lbrakk>\\<And>i. (f' i, f' (Suc i)) \\<in> S; f' 0 = x0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  (x0, x) \\<in> S\\<^sup>*", "obtain g k where G0: \"g 0 = x0\" and X: \"x = g k\" \n        and CH: \"(\\<forall>i<k. (g i, g (Suc i))\\<in>S)\""], ["proof (prove)\nusing this:\n  (x0, x) \\<in> S\\<^sup>*\n\ngoal (1 subgoal):\n 1. (\\<And>g k.\n        \\<lbrakk>g 0 = x0; x = g k;\n         \\<forall>i<k. (g i, g (Suc i)) \\<in> S\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof induct"], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<And>g k.\n        \\<lbrakk>g 0 = x0; x0 = g k;\n         \\<forall>i<k. (g i, g (Suc i)) \\<in> S\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis\n 2. \\<And>y z.\n       \\<lbrakk>(x0, y) \\<in> S\\<^sup>*; (y, z) \\<in> S;\n        (\\<And>g k.\n            \\<lbrakk>g 0 = x0; y = g k;\n             \\<forall>i<k. (g i, g (Suc i)) \\<in> S\\<rbrakk>\n            \\<Longrightarrow> thesis) \\<Longrightarrow>\n        thesis;\n        \\<And>g k.\n           \\<lbrakk>g 0 = x0; z = g k;\n            \\<forall>i<k. (g i, g (Suc i)) \\<in> S\\<rbrakk>\n           \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis", "case base"], ["proof (state)\nthis:\n  \\<lbrakk>?g 0 = x0; x0 = ?g ?k;\n   \\<forall>i<?k. (?g i, ?g (Suc i)) \\<in> S\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (2 subgoals):\n 1. (\\<And>g k.\n        \\<lbrakk>g 0 = x0; x0 = g k;\n         \\<forall>i<k. (g i, g (Suc i)) \\<in> S\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis\n 2. \\<And>y z.\n       \\<lbrakk>(x0, y) \\<in> S\\<^sup>*; (y, z) \\<in> S;\n        (\\<And>g k.\n            \\<lbrakk>g 0 = x0; y = g k;\n             \\<forall>i<k. (g i, g (Suc i)) \\<in> S\\<rbrakk>\n            \\<Longrightarrow> thesis) \\<Longrightarrow>\n        thesis;\n        \\<And>g k.\n           \\<lbrakk>g 0 = x0; z = g k;\n            \\<forall>i<k. (g i, g (Suc i)) \\<in> S\\<rbrakk>\n           \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis", "thus ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>?g 0 = x0; x0 = ?g ?k;\n   \\<forall>i<?k. (?g i, ?g (Suc i)) \\<in> S\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "by force"], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>(x0, y) \\<in> S\\<^sup>*; (y, z) \\<in> S;\n        (\\<And>g k.\n            \\<lbrakk>g 0 = x0; y = g k;\n             \\<forall>i<k. (g i, g (Suc i)) \\<in> S\\<rbrakk>\n            \\<Longrightarrow> thesis) \\<Longrightarrow>\n        thesis;\n        \\<And>g k.\n           \\<lbrakk>g 0 = x0; z = g k;\n            \\<forall>i<k. (g i, g (Suc i)) \\<in> S\\<rbrakk>\n           \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>(x0, y) \\<in> S\\<^sup>*; (y, z) \\<in> S;\n        (\\<And>g k.\n            \\<lbrakk>g 0 = x0; y = g k;\n             \\<forall>i<k. (g i, g (Suc i)) \\<in> S\\<rbrakk>\n            \\<Longrightarrow> thesis) \\<Longrightarrow>\n        thesis;\n        \\<And>g k.\n           \\<lbrakk>g 0 = x0; z = g k;\n            \\<forall>i<k. (g i, g (Suc i)) \\<in> S\\<rbrakk>\n           \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis", "case (step y z)"], ["proof (state)\nthis:\n  (x0, y) \\<in> S\\<^sup>*\n  (y, z) \\<in> S\n  (\\<And>g k.\n      \\<lbrakk>g 0 = x0; y = g k;\n       \\<forall>i<k. (g i, g (Suc i)) \\<in> S\\<rbrakk>\n      \\<Longrightarrow> thesis) \\<Longrightarrow>\n  thesis\n  \\<lbrakk>?g 0 = x0; z = ?g ?k;\n   \\<forall>i<?k. (?g i, ?g (Suc i)) \\<in> S\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>(x0, y) \\<in> S\\<^sup>*; (y, z) \\<in> S;\n        (\\<And>g k.\n            \\<lbrakk>g 0 = x0; y = g k;\n             \\<forall>i<k. (g i, g (Suc i)) \\<in> S\\<rbrakk>\n            \\<Longrightarrow> thesis) \\<Longrightarrow>\n        thesis;\n        \\<And>g k.\n           \\<lbrakk>g 0 = x0; z = g k;\n            \\<forall>i<k. (g i, g (Suc i)) \\<in> S\\<rbrakk>\n           \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "proof (rule step.hyps(3))"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>g k.\n       \\<lbrakk>g 0 = x0; y = g k;\n        \\<forall>i<k. (g i, g (Suc i)) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> thesis", "fix g k"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>g k.\n       \\<lbrakk>g 0 = x0; y = g k;\n        \\<forall>i<k. (g i, g (Suc i)) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> thesis", "assume \"g 0 = x0\" and \"y = g k\" \n            and \"\\<forall>i<k. (g i, g (Suc i))\\<in>S\""], ["proof (state)\nthis:\n  g 0 = x0\n  y = g k\n  \\<forall>i<k. (g i, g (Suc i)) \\<in> S\n\ngoal (1 subgoal):\n 1. \\<And>g k.\n       \\<lbrakk>g 0 = x0; y = g k;\n        \\<forall>i<k. (g i, g (Suc i)) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> thesis", "thus ?case"], ["proof (prove)\nusing this:\n  g 0 = x0\n  y = g k\n  \\<forall>i<k. (g i, g (Suc i)) \\<in> S\n\ngoal (1 subgoal):\n 1. thesis", "using \\<open>(y,z)\\<in>S\\<close>"], ["proof (prove)\nusing this:\n  g 0 = x0\n  y = g k\n  \\<forall>i<k. (g i, g (Suc i)) \\<in> S\n  (y, z) \\<in> S\n\ngoal (1 subgoal):\n 1. thesis", "by (rule_tac step.prems[where g=\"g(Suc k := z)\" and k=\"Suc k\"])\n              auto"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  g 0 = x0\n  x = g k\n  \\<forall>i<k. (g i, g (Suc i)) \\<in> S\n\ngoal (1 subgoal):\n 1. (\\<And>f'.\n        \\<lbrakk>\\<And>i. (f' i, f' (Suc i)) \\<in> S; f' 0 = x0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "define f' where \"f' i = (if i<k then g i else f (i-k))\" for i"], ["proof (state)\nthis:\n  f' ?i = (if ?i < k then g ?i else f (?i - k))\n\ngoal (1 subgoal):\n 1. (\\<And>f'.\n        \\<lbrakk>\\<And>i. (f' i, f' (Suc i)) \\<in> S; f' 0 = x0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"\\<exists>f'. f' 0 = x0 \\<and> (\\<forall>i. (f' i, f' (Suc i))\\<in>S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>f'. f' 0 = x0 \\<and> (\\<forall>i. (f' i, f' (Suc i)) \\<in> S)", "apply (rule_tac x=f' in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. f' 0 = x0 \\<and> (\\<forall>i. (f' i, f' (Suc i)) \\<in> S)", "apply (unfold f'_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if 0 < k then g 0 else f (0 - k)) = x0 \\<and>\n    (\\<forall>i.\n        (if i < k then g i else f (i - k),\n         if Suc i < k then g (Suc i) else f (Suc i - k))\n        \\<in> S)", "apply (rule conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. (if 0 < k then g 0 else f (0 - k)) = x0\n 2. \\<forall>i.\n       (if i < k then g i else f (i - k),\n        if Suc i < k then g (Suc i) else f (Suc i - k))\n       \\<in> S", "using S X G0"], ["proof (prove)\nusing this:\n  x = f 0\n  x = g k\n  g 0 = x0\n\ngoal (2 subgoals):\n 1. (if 0 < k then g 0 else f (0 - k)) = x0\n 2. \\<forall>i.\n       (if i < k then g i else f (i - k),\n        if Suc i < k then g (Suc i) else f (Suc i - k))\n       \\<in> S", "apply (auto) []"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i.\n       (if i < k then g i else f (i - k),\n        if Suc i < k then g (Suc i) else f (Suc i - k))\n       \\<in> S", "apply (rule_tac k=k in all_nat_split_at)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<forall>i<k.\n       (if i < k then g i else f (i - k),\n        if Suc i < k then g (Suc i) else f (Suc i - k))\n       \\<in> S\n 2. (if k < k then g k else f (k - k),\n     if Suc k < k then g (Suc k) else f (Suc k - k))\n    \\<in> S\n 3. \\<forall>i>k.\n       (if i < k then g i else f (i - k),\n        if Suc i < k then g (Suc i) else f (Suc i - k))\n       \\<in> S", "apply (auto)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>i. Suc i < k \\<Longrightarrow> (g i, g (Suc i)) \\<in> S\n 2. \\<And>i.\n       \\<lbrakk>\\<not> Suc i < k; i < k\\<rbrakk>\n       \\<Longrightarrow> (g i, f 0) \\<in> S\n 3. (f 0, f (Suc 0)) \\<in> S\n 4. \\<And>i. k < i \\<Longrightarrow> (f (i - k), f (Suc i - k)) \\<in> S", "apply (simp add: CH)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>\\<not> Suc i < k; i < k\\<rbrakk>\n       \\<Longrightarrow> (g i, f 0) \\<in> S\n 2. (f 0, f (Suc 0)) \\<in> S\n 3. \\<And>i. k < i \\<Longrightarrow> (f (i - k), f (Suc i - k)) \\<in> S", "apply (subgoal_tac \"k = Suc i\")"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>\\<not> Suc i < k; i < k; k = Suc i\\<rbrakk>\n       \\<Longrightarrow> (g i, f 0) \\<in> S\n 2. \\<And>i.\n       \\<lbrakk>\\<not> Suc i < k; i < k\\<rbrakk> \\<Longrightarrow> k = Suc i\n 3. (f 0, f (Suc 0)) \\<in> S\n 4. \\<And>i. k < i \\<Longrightarrow> (f (i - k), f (Suc i - k)) \\<in> S", "apply (simp add: S[symmetric] CH X)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>\\<not> Suc i < k; i < k\\<rbrakk> \\<Longrightarrow> k = Suc i\n 2. (f 0, f (Suc 0)) \\<in> S\n 3. \\<And>i. k < i \\<Longrightarrow> (f (i - k), f (Suc i - k)) \\<in> S", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. (f 0, f (Suc 0)) \\<in> S\n 2. \\<And>i. k < i \\<Longrightarrow> (f (i - k), f (Suc i - k)) \\<in> S", "apply (simp add: CHAIN)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i. k < i \\<Longrightarrow> (f (i - k), f (Suc i - k)) \\<in> S", "apply (subgoal_tac \"Suc i - k = Suc (i-k)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>k < i; Suc i - k = Suc (i - k)\\<rbrakk>\n       \\<Longrightarrow> (f (i - k), f (Suc i - k)) \\<in> S\n 2. \\<And>i. k < i \\<Longrightarrow> Suc i - k = Suc (i - k)", "using CHAIN"], ["proof (prove)\nusing this:\n  (f ?i, f (Suc ?i)) \\<in> S\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>k < i; Suc i - k = Suc (i - k)\\<rbrakk>\n       \\<Longrightarrow> (f (i - k), f (Suc i - k)) \\<in> S\n 2. \\<And>i. k < i \\<Longrightarrow> Suc i - k = Suc (i - k)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i. k < i \\<Longrightarrow> Suc i - k = Suc (i - k)", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>f'. f' 0 = x0 \\<and> (\\<forall>i. (f' i, f' (Suc i)) \\<in> S)\n\ngoal (1 subgoal):\n 1. (\\<And>f'.\n        \\<lbrakk>\\<And>i. (f' i, f' (Suc i)) \\<in> S; f' 0 = x0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "}"], ["proof (state)\nthis:\n  ?x2 = f 0 \\<Longrightarrow>\n  \\<exists>f'. f' 0 = x0 \\<and> (\\<forall>i. (f' i, f' (Suc i)) \\<in> S)\n\ngoal (1 subgoal):\n 1. (\\<And>f'.\n        \\<lbrakk>\\<And>i. (f' i, f' (Suc i)) \\<in> S; f' 0 = x0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  ?x2 = f 0 \\<Longrightarrow>\n  \\<exists>f'. f' 0 = x0 \\<and> (\\<forall>i. (f' i, f' (Suc i)) \\<in> S)", "obtain f' where \"\\<forall>i. (f' i,f' (Suc i))\\<in>S\" and \"f' 0 = x0\""], ["proof (prove)\nusing this:\n  ?x2 = f 0 \\<Longrightarrow>\n  \\<exists>f'. f' 0 = x0 \\<and> (\\<forall>i. (f' i, f' (Suc i)) \\<in> S)\n\ngoal (1 subgoal):\n 1. (\\<And>f'.\n        \\<lbrakk>\\<forall>i. (f' i, f' (Suc i)) \\<in> S; f' 0 = x0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  \\<forall>i. (f' i, f' (Suc i)) \\<in> S\n  f' 0 = x0\n\ngoal (1 subgoal):\n 1. (\\<And>f'.\n        \\<lbrakk>\\<And>i. (f' i, f' (Suc i)) \\<in> S; f' 0 = x0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>i. (f' i, f' (Suc i)) \\<in> S\n  f' 0 = x0\n\ngoal (1 subgoal):\n 1. thesis", "by (blast intro!: that)"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (f' ?i, f' (Suc ?i)) \\<in> S\n  f' 0 = x0\n\ngoal (1 subgoal):\n 1. \\<And>f. (\\<And>i. (f i, f (Suc i)) \\<in> S) \\<Longrightarrow> False", "txt \\<open>Construct chain in \\<open>S'\\<close>\\<close>"], ["proof (state)\nthis:\n  (f' ?i, f' (Suc ?i)) \\<in> S\n  f' 0 = x0\n\ngoal (1 subgoal):\n 1. \\<And>f. (\\<And>i. (f i, f (Suc i)) \\<in> S) \\<Longrightarrow> False", "define g' where \"g' = rec_nat x0' (\\<lambda>i x. SOME x'. \n          (x,x')\\<in>S' \\<and> (f' (Suc i),x')\\<in>R \\<and> (x0', x')\\<in>S'\\<^sup>* )\""], ["proof (state)\nthis:\n  g' =\n  rec_nat x0'\n   (\\<lambda>i x.\n       SOME x'.\n          (x, x') \\<in> S' \\<and>\n          (f' (Suc i), x') \\<in> R \\<and> (x0', x') \\<in> S'\\<^sup>*)\n\ngoal (1 subgoal):\n 1. \\<And>f. (\\<And>i. (f i, f (Suc i)) \\<in> S) \\<Longrightarrow> False", "{"], ["proof (state)\nthis:\n  g' =\n  rec_nat x0'\n   (\\<lambda>i x.\n       SOME x'.\n          (x, x') \\<in> S' \\<and>\n          (f' (Suc i), x') \\<in> R \\<and> (x0', x') \\<in> S'\\<^sup>*)\n\ngoal (1 subgoal):\n 1. \\<And>f. (\\<And>i. (f i, f (Suc i)) \\<in> S) \\<Longrightarrow> False", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f. (\\<And>i. (f i, f (Suc i)) \\<in> S) \\<Longrightarrow> False", "note [simp] = g'_def"], ["proof (state)\nthis:\n  g' =\n  rec_nat x0'\n   (\\<lambda>i x.\n       SOME x'.\n          (x, x') \\<in> S' \\<and>\n          (f' (Suc i), x') \\<in> R \\<and> (x0', x') \\<in> S'\\<^sup>*)\n\ngoal (1 subgoal):\n 1. \\<And>f. (\\<And>i. (f i, f (Suc i)) \\<in> S) \\<Longrightarrow> False", "have \"(g' i, g' (Suc i))\\<in>S' \\<and> (f' (Suc i),g' (Suc i))\\<in>R \n      \\<and> (x0',g' (Suc i))\\<in>S'\\<^sup>*\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (g' i, g' (Suc i)) \\<in> S' \\<and>\n    (f' (Suc i), g' (Suc i)) \\<in> R \\<and>\n    (x0', g' (Suc i)) \\<in> S'\\<^sup>*", "proof (induct i)"], ["proof (state)\ngoal (2 subgoals):\n 1. (g' 0, g' (Suc 0)) \\<in> S' \\<and>\n    (f' (Suc 0), g' (Suc 0)) \\<in> R \\<and>\n    (x0', g' (Suc 0)) \\<in> S'\\<^sup>*\n 2. \\<And>i.\n       (g' i, g' (Suc i)) \\<in> S' \\<and>\n       (f' (Suc i), g' (Suc i)) \\<in> R \\<and>\n       (x0', g' (Suc i)) \\<in> S'\\<^sup>* \\<Longrightarrow>\n       (g' (Suc i), g' (Suc (Suc i))) \\<in> S' \\<and>\n       (f' (Suc (Suc i)), g' (Suc (Suc i))) \\<in> R \\<and>\n       (x0', g' (Suc (Suc i))) \\<in> S'\\<^sup>*", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. (g' 0, g' (Suc 0)) \\<in> S' \\<and>\n    (f' (Suc 0), g' (Suc 0)) \\<in> R \\<and>\n    (x0', g' (Suc 0)) \\<in> S'\\<^sup>*\n 2. \\<And>i.\n       (g' i, g' (Suc i)) \\<in> S' \\<and>\n       (f' (Suc i), g' (Suc i)) \\<in> R \\<and>\n       (x0', g' (Suc i)) \\<in> S'\\<^sup>* \\<Longrightarrow>\n       (g' (Suc i), g' (Suc (Suc i))) \\<in> S' \\<and>\n       (f' (Suc (Suc i)), g' (Suc (Suc i))) \\<in> R \\<and>\n       (x0', g' (Suc (Suc i))) \\<in> S'\\<^sup>*", "from SIM[OF STARTR] CHAIN'[of 0]"], ["proof (chain)\npicking this:\n  \\<lbrakk>(x0, ?t) \\<in> S; (x0', x0') \\<in> S'\\<^sup>*\\<rbrakk>\n  \\<Longrightarrow> \\<exists>t'. (x0', t') \\<in> S' \\<and> (?t, t') \\<in> R\n  (f' 0, f' (Suc 0)) \\<in> S", "obtain t' where \n        \"(x0',t')\\<in>S'\" and \"(f' (Suc 0),t')\\<in>R\""], ["proof (prove)\nusing this:\n  \\<lbrakk>(x0, ?t) \\<in> S; (x0', x0') \\<in> S'\\<^sup>*\\<rbrakk>\n  \\<Longrightarrow> \\<exists>t'. (x0', t') \\<in> S' \\<and> (?t, t') \\<in> R\n  (f' 0, f' (Suc 0)) \\<in> S\n\ngoal (1 subgoal):\n 1. (\\<And>t'.\n        \\<lbrakk>(x0', t') \\<in> S'; (f' (Suc 0), t') \\<in> R\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  (x0', t') \\<in> S'\n  (f' (Suc 0), t') \\<in> R\n\ngoal (2 subgoals):\n 1. (g' 0, g' (Suc 0)) \\<in> S' \\<and>\n    (f' (Suc 0), g' (Suc 0)) \\<in> R \\<and>\n    (x0', g' (Suc 0)) \\<in> S'\\<^sup>*\n 2. \\<And>i.\n       (g' i, g' (Suc i)) \\<in> S' \\<and>\n       (f' (Suc i), g' (Suc i)) \\<in> R \\<and>\n       (x0', g' (Suc i)) \\<in> S'\\<^sup>* \\<Longrightarrow>\n       (g' (Suc i), g' (Suc (Suc i))) \\<in> S' \\<and>\n       (f' (Suc (Suc i)), g' (Suc (Suc i))) \\<in> R \\<and>\n       (x0', g' (Suc (Suc i))) \\<in> S'\\<^sup>*", "moreover"], ["proof (state)\nthis:\n  (x0', t') \\<in> S'\n  (f' (Suc 0), t') \\<in> R\n\ngoal (2 subgoals):\n 1. (g' 0, g' (Suc 0)) \\<in> S' \\<and>\n    (f' (Suc 0), g' (Suc 0)) \\<in> R \\<and>\n    (x0', g' (Suc 0)) \\<in> S'\\<^sup>*\n 2. \\<And>i.\n       (g' i, g' (Suc i)) \\<in> S' \\<and>\n       (f' (Suc i), g' (Suc i)) \\<in> R \\<and>\n       (x0', g' (Suc i)) \\<in> S'\\<^sup>* \\<Longrightarrow>\n       (g' (Suc i), g' (Suc (Suc i))) \\<in> S' \\<and>\n       (f' (Suc (Suc i)), g' (Suc (Suc i))) \\<in> R \\<and>\n       (x0', g' (Suc (Suc i))) \\<in> S'\\<^sup>*", "hence \"(x0',t')\\<in>S'\\<^sup>*\""], ["proof (prove)\nusing this:\n  (x0', t') \\<in> S'\n  (f' (Suc 0), t') \\<in> R\n\ngoal (1 subgoal):\n 1. (x0', t') \\<in> S'\\<^sup>*", "by auto"], ["proof (state)\nthis:\n  (x0', t') \\<in> S'\\<^sup>*\n\ngoal (2 subgoals):\n 1. (g' 0, g' (Suc 0)) \\<in> S' \\<and>\n    (f' (Suc 0), g' (Suc 0)) \\<in> R \\<and>\n    (x0', g' (Suc 0)) \\<in> S'\\<^sup>*\n 2. \\<And>i.\n       (g' i, g' (Suc i)) \\<in> S' \\<and>\n       (f' (Suc i), g' (Suc i)) \\<in> R \\<and>\n       (x0', g' (Suc i)) \\<in> S'\\<^sup>* \\<Longrightarrow>\n       (g' (Suc i), g' (Suc (Suc i))) \\<in> S' \\<and>\n       (f' (Suc (Suc i)), g' (Suc (Suc i))) \\<in> R \\<and>\n       (x0', g' (Suc (Suc i))) \\<in> S'\\<^sup>*", "ultimately"], ["proof (chain)\npicking this:\n  (x0', t') \\<in> S'\n  (f' (Suc 0), t') \\<in> R\n  (x0', t') \\<in> S'\\<^sup>*", "show ?case"], ["proof (prove)\nusing this:\n  (x0', t') \\<in> S'\n  (f' (Suc 0), t') \\<in> R\n  (x0', t') \\<in> S'\\<^sup>*\n\ngoal (1 subgoal):\n 1. (g' 0, g' (Suc 0)) \\<in> S' \\<and>\n    (f' (Suc 0), g' (Suc 0)) \\<in> R \\<and>\n    (x0', g' (Suc 0)) \\<in> S'\\<^sup>*", "by (auto intro: someI2 simp: STARTR)"], ["proof (state)\nthis:\n  (g' 0, g' (Suc 0)) \\<in> S' \\<and>\n  (f' (Suc 0), g' (Suc 0)) \\<in> R \\<and> (x0', g' (Suc 0)) \\<in> S'\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       (g' i, g' (Suc i)) \\<in> S' \\<and>\n       (f' (Suc i), g' (Suc i)) \\<in> R \\<and>\n       (x0', g' (Suc i)) \\<in> S'\\<^sup>* \\<Longrightarrow>\n       (g' (Suc i), g' (Suc (Suc i))) \\<in> S' \\<and>\n       (f' (Suc (Suc i)), g' (Suc (Suc i))) \\<in> R \\<and>\n       (x0', g' (Suc (Suc i))) \\<in> S'\\<^sup>*", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       (g' i, g' (Suc i)) \\<in> S' \\<and>\n       (f' (Suc i), g' (Suc i)) \\<in> R \\<and>\n       (x0', g' (Suc i)) \\<in> S'\\<^sup>* \\<Longrightarrow>\n       (g' (Suc i), g' (Suc (Suc i))) \\<in> S' \\<and>\n       (f' (Suc (Suc i)), g' (Suc (Suc i))) \\<in> R \\<and>\n       (x0', g' (Suc (Suc i))) \\<in> S'\\<^sup>*", "case (Suc i)"], ["proof (state)\nthis:\n  (g' i, g' (Suc i)) \\<in> S' \\<and>\n  (f' (Suc i), g' (Suc i)) \\<in> R \\<and> (x0', g' (Suc i)) \\<in> S'\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       (g' i, g' (Suc i)) \\<in> S' \\<and>\n       (f' (Suc i), g' (Suc i)) \\<in> R \\<and>\n       (x0', g' (Suc i)) \\<in> S'\\<^sup>* \\<Longrightarrow>\n       (g' (Suc i), g' (Suc (Suc i))) \\<in> S' \\<and>\n       (f' (Suc (Suc i)), g' (Suc (Suc i))) \\<in> R \\<and>\n       (x0', g' (Suc (Suc i))) \\<in> S'\\<^sup>*", "with SIM[OF _ CHAIN'[of \"Suc i\"]]"], ["proof (chain)\npicking this:\n  \\<lbrakk>(f' (Suc i), ?s') \\<in> R; (x0', ?s') \\<in> S'\\<^sup>*\\<rbrakk>\n  \\<Longrightarrow> \\<exists>t'.\n                       (?s', t') \\<in> S' \\<and>\n                       (f' (Suc (Suc i)), t') \\<in> R\n  (g' i, g' (Suc i)) \\<in> S' \\<and>\n  (f' (Suc i), g' (Suc i)) \\<in> R \\<and> (x0', g' (Suc i)) \\<in> S'\\<^sup>*", "obtain t' where LS: \"(g' (Suc i),t')\\<in>S'\" and \"(f' (Suc (Suc i)),t')\\<in>R\""], ["proof (prove)\nusing this:\n  \\<lbrakk>(f' (Suc i), ?s') \\<in> R; (x0', ?s') \\<in> S'\\<^sup>*\\<rbrakk>\n  \\<Longrightarrow> \\<exists>t'.\n                       (?s', t') \\<in> S' \\<and>\n                       (f' (Suc (Suc i)), t') \\<in> R\n  (g' i, g' (Suc i)) \\<in> S' \\<and>\n  (f' (Suc i), g' (Suc i)) \\<in> R \\<and> (x0', g' (Suc i)) \\<in> S'\\<^sup>*\n\ngoal (1 subgoal):\n 1. (\\<And>t'.\n        \\<lbrakk>(g' (Suc i), t') \\<in> S';\n         (f' (Suc (Suc i)), t') \\<in> R\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  (g' (Suc i), t') \\<in> S'\n  (f' (Suc (Suc i)), t') \\<in> R\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       (g' i, g' (Suc i)) \\<in> S' \\<and>\n       (f' (Suc i), g' (Suc i)) \\<in> R \\<and>\n       (x0', g' (Suc i)) \\<in> S'\\<^sup>* \\<Longrightarrow>\n       (g' (Suc i), g' (Suc (Suc i))) \\<in> S' \\<and>\n       (f' (Suc (Suc i)), g' (Suc (Suc i))) \\<in> R \\<and>\n       (x0', g' (Suc (Suc i))) \\<in> S'\\<^sup>*", "moreover"], ["proof (state)\nthis:\n  (g' (Suc i), t') \\<in> S'\n  (f' (Suc (Suc i)), t') \\<in> R\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       (g' i, g' (Suc i)) \\<in> S' \\<and>\n       (f' (Suc i), g' (Suc i)) \\<in> R \\<and>\n       (x0', g' (Suc i)) \\<in> S'\\<^sup>* \\<Longrightarrow>\n       (g' (Suc i), g' (Suc (Suc i))) \\<in> S' \\<and>\n       (f' (Suc (Suc i)), g' (Suc (Suc i))) \\<in> R \\<and>\n       (x0', g' (Suc (Suc i))) \\<in> S'\\<^sup>*", "from LS Suc"], ["proof (chain)\npicking this:\n  (g' (Suc i), t') \\<in> S'\n  (g' i, g' (Suc i)) \\<in> S' \\<and>\n  (f' (Suc i), g' (Suc i)) \\<in> R \\<and> (x0', g' (Suc i)) \\<in> S'\\<^sup>*", "have \"(x0', t')\\<in>S'\\<^sup>*\""], ["proof (prove)\nusing this:\n  (g' (Suc i), t') \\<in> S'\n  (g' i, g' (Suc i)) \\<in> S' \\<and>\n  (f' (Suc i), g' (Suc i)) \\<in> R \\<and> (x0', g' (Suc i)) \\<in> S'\\<^sup>*\n\ngoal (1 subgoal):\n 1. (x0', t') \\<in> S'\\<^sup>*", "by auto"], ["proof (state)\nthis:\n  (x0', t') \\<in> S'\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       (g' i, g' (Suc i)) \\<in> S' \\<and>\n       (f' (Suc i), g' (Suc i)) \\<in> R \\<and>\n       (x0', g' (Suc i)) \\<in> S'\\<^sup>* \\<Longrightarrow>\n       (g' (Suc i), g' (Suc (Suc i))) \\<in> S' \\<and>\n       (f' (Suc (Suc i)), g' (Suc (Suc i))) \\<in> R \\<and>\n       (x0', g' (Suc (Suc i))) \\<in> S'\\<^sup>*", "ultimately"], ["proof (chain)\npicking this:\n  (g' (Suc i), t') \\<in> S'\n  (f' (Suc (Suc i)), t') \\<in> R\n  (x0', t') \\<in> S'\\<^sup>*", "show ?case"], ["proof (prove)\nusing this:\n  (g' (Suc i), t') \\<in> S'\n  (f' (Suc (Suc i)), t') \\<in> R\n  (x0', t') \\<in> S'\\<^sup>*\n\ngoal (1 subgoal):\n 1. (g' (Suc i), g' (Suc (Suc i))) \\<in> S' \\<and>\n    (f' (Suc (Suc i)), g' (Suc (Suc i))) \\<in> R \\<and>\n    (x0', g' (Suc (Suc i))) \\<in> S'\\<^sup>*", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(SOME x'.\n                 (rec_nat x0'\n                   (\\<lambda>i x.\n                       SOME x'.\n                          (x, x') \\<in> S' \\<and>\n                          (f' (Suc i), x') \\<in> R \\<and>\n                          (x0', x') \\<in> S'\\<^sup>*)\n                   i,\n                  x')\n                 \\<in> S' \\<and>\n                 (f' (Suc i), x') \\<in> R \\<and> (x0', x') \\<in> S'\\<^sup>*,\n              t')\n             \\<in> S';\n     (f' (Suc (Suc i)), t') \\<in> R; (x0', t') \\<in> S'\\<^sup>*\\<rbrakk>\n    \\<Longrightarrow> (SOME x'.\n                          (rec_nat x0'\n                            (\\<lambda>i x.\n                                SOME x'.\n                                   (x, x') \\<in> S' \\<and>\n                                   (f' (Suc i), x') \\<in> R \\<and>\n                                   (x0', x') \\<in> S'\\<^sup>*)\n                            i,\n                           x')\n                          \\<in> S' \\<and>\n                          (f' (Suc i), x') \\<in> R \\<and>\n                          (x0', x') \\<in> S'\\<^sup>*,\n                       SOME x'.\n                          (SOME x'.\n                              (rec_nat x0'\n                                (\\<lambda>i x.\n                                    SOME x'.\n (x, x') \\<in> S' \\<and>\n (f' (Suc i), x') \\<in> R \\<and> (x0', x') \\<in> S'\\<^sup>*)\n                                i,\n                               x')\n                              \\<in> S' \\<and>\n                              (f' (Suc i), x') \\<in> R \\<and>\n                              (x0', x') \\<in> S'\\<^sup>*,\n                           x')\n                          \\<in> S' \\<and>\n                          (f' (Suc (Suc i)), x') \\<in> R \\<and>\n                          (x0', x') \\<in> S'\\<^sup>*)\n                      \\<in> S' \\<and>\n                      (f' (Suc (Suc i)),\n                       SOME x'.\n                          (SOME x'.\n                              (rec_nat x0'\n                                (\\<lambda>i x.\n                                    SOME x'.\n (x, x') \\<in> S' \\<and>\n (f' (Suc i), x') \\<in> R \\<and> (x0', x') \\<in> S'\\<^sup>*)\n                                i,\n                               x')\n                              \\<in> S' \\<and>\n                              (f' (Suc i), x') \\<in> R \\<and>\n                              (x0', x') \\<in> S'\\<^sup>*,\n                           x')\n                          \\<in> S' \\<and>\n                          (f' (Suc (Suc i)), x') \\<in> R \\<and>\n                          (x0', x') \\<in> S'\\<^sup>*)\n                      \\<in> R \\<and>\n                      (x0',\n                       SOME x'.\n                          (SOME x'.\n                              (rec_nat x0'\n                                (\\<lambda>i x.\n                                    SOME x'.\n (x, x') \\<in> S' \\<and>\n (f' (Suc i), x') \\<in> R \\<and> (x0', x') \\<in> S'\\<^sup>*)\n                                i,\n                               x')\n                              \\<in> S' \\<and>\n                              (f' (Suc i), x') \\<in> R \\<and>\n                              (x0', x') \\<in> S'\\<^sup>*,\n                           x')\n                          \\<in> S' \\<and>\n                          (f' (Suc (Suc i)), x') \\<in> R \\<and>\n                          (x0', x') \\<in> S'\\<^sup>*)\n                      \\<in> S'\\<^sup>*", "apply (rule_tac a=\"t'\" in someI2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>(SOME x'.\n                 (rec_nat x0'\n                   (\\<lambda>i x.\n                       SOME x'.\n                          (x, x') \\<in> S' \\<and>\n                          (f' (Suc i), x') \\<in> R \\<and>\n                          (x0', x') \\<in> S'\\<^sup>*)\n                   i,\n                  x')\n                 \\<in> S' \\<and>\n                 (f' (Suc i), x') \\<in> R \\<and> (x0', x') \\<in> S'\\<^sup>*,\n              t')\n             \\<in> S';\n     (f' (Suc (Suc i)), t') \\<in> R; (x0', t') \\<in> S'\\<^sup>*\\<rbrakk>\n    \\<Longrightarrow> (SOME x'.\n                          (rec_nat x0'\n                            (\\<lambda>i x.\n                                SOME x'.\n                                   (x, x') \\<in> S' \\<and>\n                                   (f' (Suc i), x') \\<in> R \\<and>\n                                   (x0', x') \\<in> S'\\<^sup>*)\n                            i,\n                           x')\n                          \\<in> S' \\<and>\n                          (f' (Suc i), x') \\<in> R \\<and>\n                          (x0', x') \\<in> S'\\<^sup>*,\n                       t')\n                      \\<in> S' \\<and>\n                      (f' (Suc (Suc i)), t') \\<in> R \\<and>\n                      (x0', t') \\<in> S'\\<^sup>*\n 2. \\<And>x.\n       \\<lbrakk>(SOME x'.\n                    (rec_nat x0'\n                      (\\<lambda>i x.\n                          SOME x'.\n                             (x, x') \\<in> S' \\<and>\n                             (f' (Suc i), x') \\<in> R \\<and>\n                             (x0', x') \\<in> S'\\<^sup>*)\n                      i,\n                     x')\n                    \\<in> S' \\<and>\n                    (f' (Suc i), x') \\<in> R \\<and>\n                    (x0', x') \\<in> S'\\<^sup>*,\n                 t')\n                \\<in> S';\n        (f' (Suc (Suc i)), t') \\<in> R; (x0', t') \\<in> S'\\<^sup>*;\n        (SOME x'.\n            (rec_nat x0'\n              (\\<lambda>i x.\n                  SOME x'.\n                     (x, x') \\<in> S' \\<and>\n                     (f' (Suc i), x') \\<in> R \\<and>\n                     (x0', x') \\<in> S'\\<^sup>*)\n              i,\n             x')\n            \\<in> S' \\<and>\n            (f' (Suc i), x') \\<in> R \\<and> (x0', x') \\<in> S'\\<^sup>*,\n         x)\n        \\<in> S' \\<and>\n        (f' (Suc (Suc i)), x) \\<in> R \\<and>\n        (x0', x) \\<in> S'\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> (SOME x'.\n                             (rec_nat x0'\n                               (\\<lambda>i x.\n                                   SOME x'.\n(x, x') \\<in> S' \\<and>\n(f' (Suc i), x') \\<in> R \\<and> (x0', x') \\<in> S'\\<^sup>*)\n                               i,\n                              x')\n                             \\<in> S' \\<and>\n                             (f' (Suc i), x') \\<in> R \\<and>\n                             (x0', x') \\<in> S'\\<^sup>*,\n                          x)\n                         \\<in> S' \\<and>\n                         (f' (Suc (Suc i)), x) \\<in> R \\<and>\n                         (x0', x) \\<in> S'\\<^sup>*", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (g' (Suc i), g' (Suc (Suc i))) \\<in> S' \\<and>\n  (f' (Suc (Suc i)), g' (Suc (Suc i))) \\<in> R \\<and>\n  (x0', g' (Suc (Suc i))) \\<in> S'\\<^sup>*\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (g' i, g' (Suc i)) \\<in> S' \\<and>\n  (f' (Suc i), g' (Suc i)) \\<in> R \\<and> (x0', g' (Suc i)) \\<in> S'\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<And>f. (\\<And>i. (f i, f (Suc i)) \\<in> S) \\<Longrightarrow> False", "}"], ["proof (state)\nthis:\n  (g' ?i2, g' (Suc ?i2)) \\<in> S' \\<and>\n  (f' (Suc ?i2), g' (Suc ?i2)) \\<in> R \\<and>\n  (x0', g' (Suc ?i2)) \\<in> S'\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<And>f. (\\<And>i. (f i, f (Suc i)) \\<in> S) \\<Longrightarrow> False", "hence S'CHAIN: \"\\<forall>i. (g' i, g'(Suc i))\\<in>S'\""], ["proof (prove)\nusing this:\n  (g' ?i2, g' (Suc ?i2)) \\<in> S' \\<and>\n  (f' (Suc ?i2), g' (Suc ?i2)) \\<in> R \\<and>\n  (x0', g' (Suc ?i2)) \\<in> S'\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<forall>i. (g' i, g' (Suc i)) \\<in> S'", "by simp"], ["proof (state)\nthis:\n  \\<forall>i. (g' i, g' (Suc i)) \\<in> S'\n\ngoal (1 subgoal):\n 1. \\<And>f. (\\<And>i. (f i, f (Suc i)) \\<in> S) \\<Longrightarrow> False", "txt \\<open>This contradicts well-foundedness\\<close>"], ["proof (state)\nthis:\n  \\<forall>i. (g' i, g' (Suc i)) \\<in> S'\n\ngoal (1 subgoal):\n 1. \\<And>f. (\\<And>i. (f i, f (Suc i)) \\<in> S) \\<Longrightarrow> False", "with WF"], ["proof (chain)\npicking this:\n  wf (S'\\<inverse>)\n  \\<forall>i. (g' i, g' (Suc i)) \\<in> S'", "show False"], ["proof (prove)\nusing this:\n  wf (S'\\<inverse>)\n  \\<forall>i. (g' i, g' (Suc i)) \\<in> S'\n\ngoal (1 subgoal):\n 1. False", "by (erule_tac wf_no_infinite_down_chainE[where f=g']) simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Well-founded relation that approximates a finite set from below.\\<close>"], ["", "definition \"finite_psupset S \\<equiv> { (Q',Q). Q\\<subset>Q' \\<and> Q' \\<subseteq> S }\""], ["", "lemma finite_psupset_wf[simp, intro]: \"finite S \\<Longrightarrow> wf (finite_psupset S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite S \\<Longrightarrow> wf (finite_psupset S)", "unfolding finite_psupset_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite S \\<Longrightarrow>\n    wf {(Q', Q). Q \\<subset> Q' \\<and> Q' \\<subseteq> S}", "by (blast intro: wf_bounded_supset)"], ["", "definition \"less_than_bool \\<equiv> {(a,b). a<(b::bool)}\""], ["", "lemma wf_less_than_bool[simp, intro!]: \"wf (less_than_bool)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf less_than_bool", "unfolding less_than_bool_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. wf {(a, b). a < b}", "by (auto simp: wf_def)"], ["", "lemma less_than_bool_iff[simp]:\n  \"(x,y)\\<in>less_than_bool \\<longleftrightarrow> x=False \\<and> y=True\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((x, y) \\<in> less_than_bool) = (x = False \\<and> y = True)", "by (auto simp: less_than_bool_def)"], ["", "definition \"greater_bounded N \\<equiv> inv_image less_than (\\<lambda>x. N-x)\""], ["", "lemma wf_greater_bounded[simp, intro!]: \"wf (greater_bounded N)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf (greater_bounded N)", "by (auto simp: greater_bounded_def)"], ["", "lemma greater_bounded_Suc_iff[simp]: \"(Suc x,x)\\<in>greater_bounded N \\<longleftrightarrow> Suc x \\<le> N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((Suc x, x) \\<in> greater_bounded N) = (Suc x \\<le> N)", "by (auto simp: greater_bounded_def)"], ["", "subsection \\<open>Monotonicity and Orderings\\<close>"], ["", "lemma mono_const[simp, intro!]: \"mono (\\<lambda>_. c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono (\\<lambda>_. c)", "by (auto intro: monoI)"], ["", "lemma mono_if: \"\\<lbrakk>mono S1; mono S2\\<rbrakk> \\<Longrightarrow>\n  mono (\\<lambda>F s. if b s then S1 F s else S2 F s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>mono S1; mono S2\\<rbrakk>\n    \\<Longrightarrow> mono (\\<lambda>F s. if b s then S1 F s else S2 F s)", "apply rule"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>mono S1; mono S2; x \\<le> y\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>s. if b s then S1 x s else S2 x s)\n                         \\<le> (\\<lambda>s. if b s then S1 y s else S2 y s)", "apply (rule le_funI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y xa.\n       \\<lbrakk>mono S1; mono S2; x \\<le> y\\<rbrakk>\n       \\<Longrightarrow> (if b xa then S1 x xa else S2 x xa)\n                         \\<le> (if b xa then S1 y xa else S2 y xa)", "apply (auto dest: monoD[THEN le_funD])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma mono_infI: \"mono f \\<Longrightarrow> mono g \\<Longrightarrow> mono (inf f g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>mono f; mono g\\<rbrakk> \\<Longrightarrow> mono (inf f g)", "unfolding inf_fun_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>mono f; mono g\\<rbrakk>\n    \\<Longrightarrow> mono (\\<lambda>x. inf (f x) (g x))", "apply (rule monoI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>mono f; mono g; x \\<le> y\\<rbrakk>\n       \\<Longrightarrow> inf (f x) (g x) \\<le> inf (f y) (g y)", "apply (metis inf_mono monoD)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma mono_infI': \n  \"mono f \\<Longrightarrow> mono g \\<Longrightarrow> mono (\\<lambda>x. inf (f x) (g x) :: 'b::lattice)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>mono f; mono g\\<rbrakk>\n    \\<Longrightarrow> mono (\\<lambda>x. inf (f x) (g x))", "by (rule mono_infI[unfolded inf_fun_def])"], ["", "lemma mono_infArg: \n  fixes f :: \"'a::lattice \\<Rightarrow> 'b::order\"\n  shows \"mono f \\<Longrightarrow> mono (\\<lambda>x. f (inf x X))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono f \\<Longrightarrow> mono (\\<lambda>x. f (inf x X))", "apply (rule monoI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>mono f; x \\<le> y\\<rbrakk>\n       \\<Longrightarrow> f (inf x X) \\<le> f (inf y X)", "apply (erule monoD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y. x \\<le> y \\<Longrightarrow> inf x X \\<le> inf y X", "apply (metis inf_mono order_refl)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma mono_Sup:\n  fixes f :: \"'a::complete_lattice \\<Rightarrow> 'b::complete_lattice\"\n  shows \"mono f \\<Longrightarrow> Sup (f`S) \\<le> f (Sup S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono f \\<Longrightarrow> Sup (f ` S) \\<le> f (Sup S)", "apply (rule Sup_least)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>mono f; x \\<in> f ` S\\<rbrakk>\n       \\<Longrightarrow> x \\<le> f (Sup S)", "apply (erule imageE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>mono f; x = f xa; xa \\<in> S\\<rbrakk>\n       \\<Longrightarrow> x \\<le> f (Sup S)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>mono f; x = f xa; xa \\<in> S\\<rbrakk>\n       \\<Longrightarrow> f xa \\<le> f (Sup S)", "apply (erule monoD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>x = f xa; xa \\<in> S\\<rbrakk>\n       \\<Longrightarrow> xa \\<le> Sup S", "apply (erule Sup_upper)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma mono_SupI:\n  fixes f :: \"'a::complete_lattice \\<Rightarrow> 'b::complete_lattice\"\n  assumes \"mono f\"\n  assumes \"S'\\<subseteq>f`S\"\n  shows \"Sup S' \\<le> f (Sup S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Sup S' \\<le> f (Sup S)", "by (metis Sup_subset_mono assms mono_Sup order_trans)"], ["", "lemma mono_Inf:\n  fixes f :: \"'a::complete_lattice \\<Rightarrow> 'b::complete_lattice\"\n  shows \"mono f \\<Longrightarrow> f (Inf S) \\<le> Inf (f`S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono f \\<Longrightarrow> f (Inf S) \\<le> Inf (f ` S)", "apply (rule Inf_greatest)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>mono f; x \\<in> f ` S\\<rbrakk>\n       \\<Longrightarrow> f (Inf S) \\<le> x", "apply (erule imageE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>mono f; x = f xa; xa \\<in> S\\<rbrakk>\n       \\<Longrightarrow> f (Inf S) \\<le> x", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>mono f; x = f xa; xa \\<in> S\\<rbrakk>\n       \\<Longrightarrow> f (Inf S) \\<le> f xa", "apply (erule monoD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>x = f xa; xa \\<in> S\\<rbrakk>\n       \\<Longrightarrow> Inf S \\<le> xa", "apply (erule Inf_lower)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma mono_funpow: \"mono (f::'a::order \\<Rightarrow> 'a) \\<Longrightarrow> mono (f^^i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono f \\<Longrightarrow> mono (f ^^ i)", "apply (induct i)"], ["proof (prove)\ngoal (2 subgoals):\n 1. mono f \\<Longrightarrow> mono (f ^^ 0)\n 2. \\<And>i.\n       \\<lbrakk>mono f \\<Longrightarrow> mono (f ^^ i); mono f\\<rbrakk>\n       \\<Longrightarrow> mono (f ^^ Suc i)", "apply (auto intro!: monoI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i x y.\n       \\<lbrakk>mono (f ^^ i); mono f; x \\<le> y\\<rbrakk>\n       \\<Longrightarrow> f ((f ^^ i) x) \\<le> f ((f ^^ i) y)", "apply (auto dest: monoD)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma mono_id[simp, intro!]:\n  \"mono id\"\n  \"mono (\\<lambda>x. x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono id &&& mono (\\<lambda>x. x)", "by (auto intro: monoI)"], ["", "declare SUP_insert[simp]"], ["", "lemma (in semilattice_inf) le_infD1:\n  \"a \\<le> inf b c \\<Longrightarrow> a \\<le> b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<le> inf b c \\<Longrightarrow> a \\<le> b", "by (rule le_infE)"], ["", "lemma (in semilattice_inf) le_infD2:\n  \"a \\<le> inf b c \\<Longrightarrow> a \\<le> c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<le> inf b c \\<Longrightarrow> a \\<le> c", "by (rule le_infE)"], ["", "lemma (in semilattice_inf) inf_leI:\n  \"\\<lbrakk> \\<And>x. \\<lbrakk> x\\<le>a; x\\<le>b \\<rbrakk> \\<Longrightarrow> x\\<le>c \\<rbrakk> \\<Longrightarrow> inf a b \\<le> c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>x \\<le> a; x \\<le> b\\<rbrakk>\n        \\<Longrightarrow> x \\<le> c) \\<Longrightarrow>\n    inf a b \\<le> c", "by (metis inf_le1 inf_le2)"], ["", "lemma top_Sup: \"(top::'a::complete_lattice)\\<in>A \\<Longrightarrow> Sup A = top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. top \\<in> A \\<Longrightarrow> Sup A = top", "by (metis Sup_upper top_le)"], ["", "lemma bot_Inf: \"(bot::'a::complete_lattice)\\<in>A \\<Longrightarrow> Inf A = bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bot \\<in> A \\<Longrightarrow> Inf A = bot", "by (metis Inf_lower le_bot)"], ["", "lemma mono_compD: \"mono f \\<Longrightarrow> x\\<le>y \\<Longrightarrow> f o x \\<le> f o y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>mono f; x \\<le> y\\<rbrakk>\n    \\<Longrightarrow> f \\<circ> x \\<le> f \\<circ> y", "apply (rule le_funI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>mono f; x \\<le> y\\<rbrakk>\n       \\<Longrightarrow> (f \\<circ> x) xa \\<le> (f \\<circ> y) xa", "apply (auto dest: monoD le_funD)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsubsection \\<open>Galois Connections\\<close>"], ["", "locale galois_connection =\n  fixes \\<alpha>::\"'a::complete_lattice \\<Rightarrow> 'b::complete_lattice\" and \\<gamma>\n  assumes galois: \"c \\<le> \\<gamma>(a) \\<longleftrightarrow> \\<alpha>(c) \\<le> a\"\nbegin"], ["", "lemma \\<alpha>\\<gamma>_defl: \"\\<alpha>(\\<gamma>(x)) \\<le> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha> (\\<gamma> x) \\<le> x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<alpha> (\\<gamma> x) \\<le> x", "have \"\\<gamma> x \\<le> \\<gamma> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<gamma> x \\<le> \\<gamma> x", "by simp"], ["proof (state)\nthis:\n  \\<gamma> x \\<le> \\<gamma> x\n\ngoal (1 subgoal):\n 1. \\<alpha> (\\<gamma> x) \\<le> x", "with galois"], ["proof (chain)\npicking this:\n  (?c \\<le> \\<gamma> ?a) = (\\<alpha> ?c \\<le> ?a)\n  \\<gamma> x \\<le> \\<gamma> x", "show \"\\<alpha>(\\<gamma>(x)) \\<le> x\""], ["proof (prove)\nusing this:\n  (?c \\<le> \\<gamma> ?a) = (\\<alpha> ?c \\<le> ?a)\n  \\<gamma> x \\<le> \\<gamma> x\n\ngoal (1 subgoal):\n 1. \\<alpha> (\\<gamma> x) \\<le> x", "by blast"], ["proof (state)\nthis:\n  \\<alpha> (\\<gamma> x) \\<le> x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma \\<gamma>\\<alpha>_infl: \"x \\<le> \\<gamma>(\\<alpha>(x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> \\<gamma> (\\<alpha> x)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<le> \\<gamma> (\\<alpha> x)", "have \"\\<alpha> x \\<le> \\<alpha> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha> x \\<le> \\<alpha> x", "by simp"], ["proof (state)\nthis:\n  \\<alpha> x \\<le> \\<alpha> x\n\ngoal (1 subgoal):\n 1. x \\<le> \\<gamma> (\\<alpha> x)", "with galois"], ["proof (chain)\npicking this:\n  (?c \\<le> \\<gamma> ?a) = (\\<alpha> ?c \\<le> ?a)\n  \\<alpha> x \\<le> \\<alpha> x", "show \"x \\<le> \\<gamma>(\\<alpha>(x))\""], ["proof (prove)\nusing this:\n  (?c \\<le> \\<gamma> ?a) = (\\<alpha> ?c \\<le> ?a)\n  \\<alpha> x \\<le> \\<alpha> x\n\ngoal (1 subgoal):\n 1. x \\<le> \\<gamma> (\\<alpha> x)", "by blast"], ["proof (state)\nthis:\n  x \\<le> \\<gamma> (\\<alpha> x)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma \\<alpha>_mono: \"mono \\<alpha>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono \\<alpha>", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y. x \\<le> y \\<Longrightarrow> \\<alpha> x \\<le> \\<alpha> y", "fix x::'a and y::'a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y. x \\<le> y \\<Longrightarrow> \\<alpha> x \\<le> \\<alpha> y", "assume \"x\\<le>y\""], ["proof (state)\nthis:\n  x \\<le> y\n\ngoal (1 subgoal):\n 1. \\<And>x y. x \\<le> y \\<Longrightarrow> \\<alpha> x \\<le> \\<alpha> y", "also"], ["proof (state)\nthis:\n  x \\<le> y\n\ngoal (1 subgoal):\n 1. \\<And>x y. x \\<le> y \\<Longrightarrow> \\<alpha> x \\<le> \\<alpha> y", "note \\<gamma>\\<alpha>_infl[of y]"], ["proof (state)\nthis:\n  y \\<le> \\<gamma> (\\<alpha> y)\n\ngoal (1 subgoal):\n 1. \\<And>x y. x \\<le> y \\<Longrightarrow> \\<alpha> x \\<le> \\<alpha> y", "finally"], ["proof (chain)\npicking this:\n  x \\<le> \\<gamma> (\\<alpha> y)", "show \"\\<alpha> x \\<le> \\<alpha> y\""], ["proof (prove)\nusing this:\n  x \\<le> \\<gamma> (\\<alpha> y)\n\ngoal (1 subgoal):\n 1. \\<alpha> x \\<le> \\<alpha> y", "by (simp add: galois)"], ["proof (state)\nthis:\n  \\<alpha> x \\<le> \\<alpha> y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma \\<gamma>_mono: \"mono \\<gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono \\<gamma>", "by rule (metis \\<alpha>\\<gamma>_defl galois inf_absorb1 le_infE)"], ["", "lemma dist_\\<gamma>[simp]: \n    \"\\<gamma> (inf a b) = inf (\\<gamma> a) (\\<gamma> b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<gamma> (inf a b) = inf (\\<gamma> a) (\\<gamma> b)", "apply (rule order_antisym)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<gamma> (inf a b) \\<le> inf (\\<gamma> a) (\\<gamma> b)\n 2. inf (\\<gamma> a) (\\<gamma> b) \\<le> \\<gamma> (inf a b)", "apply (rule mono_inf[OF \\<gamma>_mono])"], ["proof (prove)\ngoal (1 subgoal):\n 1. inf (\\<gamma> a) (\\<gamma> b) \\<le> \\<gamma> (inf a b)", "apply (simp add: galois)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha> (inf (\\<gamma> a) (\\<gamma> b)) \\<le> a \\<and>\n    \\<alpha> (inf (\\<gamma> a) (\\<gamma> b)) \\<le> b", "apply (simp add: galois[symmetric])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma dist_\\<alpha>[simp]: \n    \"\\<alpha> (sup a b) = sup (\\<alpha> a) (\\<alpha> b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha> (sup a b) = sup (\\<alpha> a) (\\<alpha> b)", "by (metis (no_types) \\<alpha>_mono galois mono_sup order_antisym \n      sup_ge1 sup_ge2 sup_least)"], ["", "end"], ["", "subsubsection \\<open>Fixed Points\\<close>"], ["", "lemma mono_lfp_eqI:\n  assumes MONO: \"mono f\"\n  assumes FIXP: \"f a \\<le> a\"\n  assumes LEAST: \"\\<And>x. f x = x \\<Longrightarrow> a\\<le>x\"\n  shows \"lfp f = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lfp f = a", "apply (rule antisym)"], ["proof (prove)\ngoal (2 subgoals):\n 1. lfp f \\<le> a\n 2. a \\<le> lfp f", "apply (rule lfp_lowerbound)"], ["proof (prove)\ngoal (2 subgoals):\n 1. f a \\<le> a\n 2. a \\<le> lfp f", "apply (rule FIXP)"], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<le> lfp f", "by (metis LEAST MONO lfp_unfold)"], ["", "lemma mono_gfp_eqI:\n  assumes MONO: \"mono f\"\n  assumes FIXP: \"a \\<le> f a\"\n  assumes GREATEST: \"\\<And>x. f x = x \\<Longrightarrow> x\\<le>a\"\n  shows \"gfp f = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gfp f = a", "apply (rule antisym)"], ["proof (prove)\ngoal (2 subgoals):\n 1. gfp f \\<le> a\n 2. a \\<le> gfp f", "apply (metis GREATEST MONO gfp_unfold)"], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<le> gfp f", "apply (rule gfp_upperbound)"], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<le> f a", "apply (rule FIXP)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma lfp_le_gfp': \"mono f \\<Longrightarrow> lfp f x \\<le> gfp f x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono f \\<Longrightarrow> lfp f x \\<le> gfp f x", "by (rule le_funD[OF lfp_le_gfp])"], ["", "(* Just a reformulation of lfp_induct *)"], ["", "lemma lfp_induct':\n  assumes M: \"mono f\"\n  assumes IS: \"\\<And>m. \\<lbrakk> m \\<le> lfp f; m \\<le> P \\<rbrakk> \\<Longrightarrow> f m \\<le> P\"\n  shows \"lfp f \\<le> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lfp f \\<le> P", "apply (rule lfp_induct[OF M])"], ["proof (prove)\ngoal (1 subgoal):\n 1. f (inf (lfp f) P) \\<le> P", "apply (rule IS)"], ["proof (prove)\ngoal (2 subgoals):\n 1. inf (lfp f) P \\<le> lfp f\n 2. inf (lfp f) P \\<le> P", "by simp_all"], ["", "lemma lfp_gen_induct:\n  \\<comment> \\<open>Induction lemma for generalized lfps\\<close>\n  assumes M: \"mono f\"\n  notes MONO'[refine_mono] = monoD[OF M]\n  assumes I0: \"m0 \\<le> P\"\n  assumes IS: \"\\<And>m. \\<lbrakk>\n      m \\<le> lfp (\\<lambda>s. sup m0 (f s));  \\<comment> \\<open>Assume already established invariants\\<close>\n      m \\<le> P;                       \\<comment> \\<open>Assume invariant\\<close>\n      f m \\<le> lfp (\\<lambda>s. sup m0 (f s)) \\<comment> \\<open>Assume that step preserved est. invars\\<close>\n    \\<rbrakk> \\<Longrightarrow> f m \\<le> P\"                 \\<comment> \\<open>Show that step preserves invariant\\<close>\n  shows \"lfp (\\<lambda>s. sup m0 (f s)) \\<le> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lfp (\\<lambda>s. sup m0 (f s)) \\<le> P", "apply (rule lfp_induct')"], ["proof (prove)\ngoal (2 subgoals):\n 1. mono (\\<lambda>s. sup m0 (f s))\n 2. \\<And>m.\n       \\<lbrakk>m \\<le> lfp (\\<lambda>s. sup m0 (f s)); m \\<le> P\\<rbrakk>\n       \\<Longrightarrow> sup m0 (f m) \\<le> P", "apply (meson MONO' monoI order_mono_setup.refl sup_mono)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m.\n       \\<lbrakk>m \\<le> lfp (\\<lambda>s. sup m0 (f s)); m \\<le> P\\<rbrakk>\n       \\<Longrightarrow> sup m0 (f m) \\<le> P", "apply (rule sup_least)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>m.\n       \\<lbrakk>m \\<le> lfp (\\<lambda>s. sup m0 (f s)); m \\<le> P\\<rbrakk>\n       \\<Longrightarrow> m0 \\<le> P\n 2. \\<And>m.\n       \\<lbrakk>m \\<le> lfp (\\<lambda>s. sup m0 (f s)); m \\<le> P\\<rbrakk>\n       \\<Longrightarrow> f m \\<le> P", "apply (rule I0)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m.\n       \\<lbrakk>m \\<le> lfp (\\<lambda>s. sup m0 (f s)); m \\<le> P\\<rbrakk>\n       \\<Longrightarrow> f m \\<le> P", "apply (rule IS, assumption+)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m.\n       \\<lbrakk>m \\<le> lfp (\\<lambda>s. sup m0 (f s)); m \\<le> P\\<rbrakk>\n       \\<Longrightarrow> f m \\<le> lfp (\\<lambda>s. sup m0 (f s))", "apply (subst lfp_unfold)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>m.\n       \\<lbrakk>m \\<le> lfp (\\<lambda>s. sup m0 (f s)); m \\<le> P\\<rbrakk>\n       \\<Longrightarrow> mono (\\<lambda>s. sup m0 (f s))\n 2. \\<And>m.\n       \\<lbrakk>m \\<le> lfp (\\<lambda>s. sup m0 (f s)); m \\<le> P\\<rbrakk>\n       \\<Longrightarrow> f m\n                         \\<le> sup m0 (f (lfp (\\<lambda>s. sup m0 (f s))))", "apply (meson MONO' monoI order_mono_setup.refl sup_mono)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m.\n       \\<lbrakk>m \\<le> lfp (\\<lambda>s. sup m0 (f s)); m \\<le> P\\<rbrakk>\n       \\<Longrightarrow> f m\n                         \\<le> sup m0 (f (lfp (\\<lambda>s. sup m0 (f s))))", "apply (rule le_supI2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m.\n       \\<lbrakk>m \\<le> lfp (\\<lambda>s. sup m0 (f s)); m \\<le> P\\<rbrakk>\n       \\<Longrightarrow> f m \\<le> f (lfp (\\<lambda>s. sup m0 (f s)))", "apply (rule monoD[OF M])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m.\n       \\<lbrakk>m \\<le> lfp (\\<lambda>s. sup m0 (f s)); m \\<le> P\\<rbrakk>\n       \\<Longrightarrow> m \\<le> lfp (\\<lambda>s. sup m0 (f s))", "."], ["", "subsubsection \\<open>Connecting Complete Lattices and \n  Chain-Complete Partial Orders\\<close>"], ["", "(* Note: Also connected by subclass now. However, we need both directions\n  of embedding*)"], ["", "lemma (in complete_lattice) is_ccpo: \"class.ccpo Sup (\\<le>) (<)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. class.ccpo Sup (\\<le>) (<)", "apply unfold_locales"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>A x.\n       \\<lbrakk>Complete_Partial_Order.chain (\\<le>) A; x \\<in> A\\<rbrakk>\n       \\<Longrightarrow> x \\<le> Sup A\n 2. \\<And>A z.\n       \\<lbrakk>Complete_Partial_Order.chain (\\<le>) A;\n        \\<And>x. x \\<in> A \\<Longrightarrow> x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> Sup A \\<le> z", "apply (erule Sup_upper)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>A z.\n       \\<lbrakk>Complete_Partial_Order.chain (\\<le>) A;\n        \\<And>x. x \\<in> A \\<Longrightarrow> x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> Sup A \\<le> z", "apply (erule Sup_least)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma (in complete_lattice) is_dual_ccpo: \"class.ccpo Inf (\\<ge>) (>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. class.ccpo Inf (\\<lambda>x y. y \\<le> x) (\\<lambda>x y. y < x)", "apply unfold_locales"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>x y. (y < x) = (y \\<le> x \\<and> \\<not> x \\<le> y)\n 2. \\<And>x. x \\<le> x\n 3. \\<And>x y z.\n       \\<lbrakk>y \\<le> x; z \\<le> y\\<rbrakk> \\<Longrightarrow> z \\<le> x\n 4. \\<And>x y.\n       \\<lbrakk>y \\<le> x; x \\<le> y\\<rbrakk> \\<Longrightarrow> x = y\n 5. \\<And>A x.\n       \\<lbrakk>Complete_Partial_Order.chain (\\<lambda>x y. y \\<le> x) A;\n        x \\<in> A\\<rbrakk>\n       \\<Longrightarrow> Inf A \\<le> x\n 6. \\<And>A z.\n       \\<lbrakk>Complete_Partial_Order.chain (\\<lambda>x y. y \\<le> x) A;\n        \\<And>x. x \\<in> A \\<Longrightarrow> z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> z \\<le> Inf A", "apply (rule less_le_not_le)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x. x \\<le> x\n 2. \\<And>x y z.\n       \\<lbrakk>y \\<le> x; z \\<le> y\\<rbrakk> \\<Longrightarrow> z \\<le> x\n 3. \\<And>x y.\n       \\<lbrakk>y \\<le> x; x \\<le> y\\<rbrakk> \\<Longrightarrow> x = y\n 4. \\<And>A x.\n       \\<lbrakk>Complete_Partial_Order.chain (\\<lambda>x y. y \\<le> x) A;\n        x \\<in> A\\<rbrakk>\n       \\<Longrightarrow> Inf A \\<le> x\n 5. \\<And>A z.\n       \\<lbrakk>Complete_Partial_Order.chain (\\<lambda>x y. y \\<le> x) A;\n        \\<And>x. x \\<in> A \\<Longrightarrow> z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> z \\<le> Inf A", "apply (rule order_refl)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>y \\<le> x; z \\<le> y\\<rbrakk> \\<Longrightarrow> z \\<le> x\n 2. \\<And>x y.\n       \\<lbrakk>y \\<le> x; x \\<le> y\\<rbrakk> \\<Longrightarrow> x = y\n 3. \\<And>A x.\n       \\<lbrakk>Complete_Partial_Order.chain (\\<lambda>x y. y \\<le> x) A;\n        x \\<in> A\\<rbrakk>\n       \\<Longrightarrow> Inf A \\<le> x\n 4. \\<And>A z.\n       \\<lbrakk>Complete_Partial_Order.chain (\\<lambda>x y. y \\<le> x) A;\n        \\<And>x. x \\<in> A \\<Longrightarrow> z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> z \\<le> Inf A", "apply (erule (1) order_trans)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>y \\<le> x; x \\<le> y\\<rbrakk> \\<Longrightarrow> x = y\n 2. \\<And>A x.\n       \\<lbrakk>Complete_Partial_Order.chain (\\<lambda>x y. y \\<le> x) A;\n        x \\<in> A\\<rbrakk>\n       \\<Longrightarrow> Inf A \\<le> x\n 3. \\<And>A z.\n       \\<lbrakk>Complete_Partial_Order.chain (\\<lambda>x y. y \\<le> x) A;\n        \\<And>x. x \\<in> A \\<Longrightarrow> z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> z \\<le> Inf A", "apply (erule (1) antisym)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>A x.\n       \\<lbrakk>Complete_Partial_Order.chain (\\<lambda>x y. y \\<le> x) A;\n        x \\<in> A\\<rbrakk>\n       \\<Longrightarrow> Inf A \\<le> x\n 2. \\<And>A z.\n       \\<lbrakk>Complete_Partial_Order.chain (\\<lambda>x y. y \\<le> x) A;\n        \\<And>x. x \\<in> A \\<Longrightarrow> z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> z \\<le> Inf A", "apply (erule Inf_lower)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>A z.\n       \\<lbrakk>Complete_Partial_Order.chain (\\<lambda>x y. y \\<le> x) A;\n        \\<And>x. x \\<in> A \\<Longrightarrow> z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> z \\<le> Inf A", "apply (erule Inf_greatest)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma ccpo_mono_simp: \"monotone (\\<le>) (\\<le>) f \\<longleftrightarrow> mono f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monotone (\\<le>) (\\<le>) f = mono f", "unfolding monotone_def mono_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x y. x \\<le> y \\<longrightarrow> f x \\<le> f y) =\n    (\\<forall>x y. x \\<le> y \\<longrightarrow> f x \\<le> f y)", "by simp"], ["", "lemma ccpo_monoI: \"mono f \\<Longrightarrow> monotone (\\<le>) (\\<le>) f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono f \\<Longrightarrow> monotone (\\<le>) (\\<le>) f", "by (simp add: ccpo_mono_simp)"], ["", "lemma ccpo_monoD: \"monotone (\\<le>) (\\<le>) f \\<Longrightarrow> mono f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monotone (\\<le>) (\\<le>) f \\<Longrightarrow> mono f", "by (simp add: ccpo_mono_simp)"], ["", "lemma dual_ccpo_mono_simp: \"monotone (\\<ge>) (\\<ge>) f \\<longleftrightarrow> mono f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monotone (\\<lambda>x y. y \\<le> x) (\\<lambda>x y. y \\<le> x) f = mono f", "unfolding monotone_def mono_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x y. y \\<le> x \\<longrightarrow> f y \\<le> f x) =\n    (\\<forall>x y. x \\<le> y \\<longrightarrow> f x \\<le> f y)", "by auto"], ["", "lemma dual_ccpo_monoI: \"mono f \\<Longrightarrow> monotone (\\<ge>) (\\<ge>) f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono f \\<Longrightarrow>\n    monotone (\\<lambda>x y. y \\<le> x) (\\<lambda>x y. y \\<le> x) f", "by (simp add: dual_ccpo_mono_simp)"], ["", "lemma dual_ccpo_monoD: \"monotone (\\<ge>) (\\<ge>) f \\<Longrightarrow> mono f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monotone (\\<lambda>x y. y \\<le> x) (\\<lambda>x y. y \\<le> x)\n     f \\<Longrightarrow>\n    mono f", "by (simp add: dual_ccpo_mono_simp)"], ["", "lemma ccpo_lfp_simp: \"\\<And>f. mono f \\<Longrightarrow> ccpo.fixp Sup (\\<le>) f = lfp f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f. mono f \\<Longrightarrow> ccpo.fixp Sup (\\<le>) f = lfp f", "apply (rule antisym)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>f. mono f \\<Longrightarrow> ccpo.fixp Sup (\\<le>) f \\<le> lfp f\n 2. \\<And>f. mono f \\<Longrightarrow> lfp f \\<le> ccpo.fixp Sup (\\<le>) f", "defer"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>f. mono f \\<Longrightarrow> lfp f \\<le> ccpo.fixp Sup (\\<le>) f\n 2. \\<And>f. mono f \\<Longrightarrow> ccpo.fixp Sup (\\<le>) f \\<le> lfp f", "apply (rule lfp_lowerbound)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>f.\n       mono f \\<Longrightarrow>\n       f (ccpo.fixp Sup (\\<le>) f) \\<le> ccpo.fixp Sup (\\<le>) f\n 2. \\<And>f. mono f \\<Longrightarrow> ccpo.fixp Sup (\\<le>) f \\<le> lfp f", "apply (drule ccpo.fixp_unfold[OF is_ccpo ccpo_monoI, symmetric])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>f.\n       f (ccpo.fixp Sup (\\<le>) f) =\n       ccpo.fixp Sup (\\<le>) f \\<Longrightarrow>\n       f (ccpo.fixp Sup (\\<le>) f) \\<le> ccpo.fixp Sup (\\<le>) f\n 2. \\<And>f. mono f \\<Longrightarrow> ccpo.fixp Sup (\\<le>) f \\<le> lfp f", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f. mono f \\<Longrightarrow> ccpo.fixp Sup (\\<le>) f \\<le> lfp f", "apply (rule ccpo.fixp_lowerbound[OF is_ccpo ccpo_monoI], assumption)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f. mono f \\<Longrightarrow> f (lfp f) \\<le> lfp f", "apply (simp add: lfp_unfold[symmetric])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma ccpo_gfp_simp: \"\\<And>f. mono f \\<Longrightarrow> ccpo.fixp Inf (\\<ge>) f = gfp f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f.\n       mono f \\<Longrightarrow>\n       ccpo.fixp Inf (\\<lambda>x y. y \\<le> x) f = gfp f", "apply (rule antisym)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>f.\n       mono f \\<Longrightarrow>\n       ccpo.fixp Inf (\\<lambda>x y. y \\<le> x) f \\<le> gfp f\n 2. \\<And>f.\n       mono f \\<Longrightarrow>\n       gfp f \\<le> ccpo.fixp Inf (\\<lambda>x y. y \\<le> x) f", "apply (rule gfp_upperbound)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>f.\n       mono f \\<Longrightarrow>\n       ccpo.fixp Inf (\\<lambda>x y. y \\<le> x) f\n       \\<le> f (ccpo.fixp Inf (\\<lambda>x y. y \\<le> x) f)\n 2. \\<And>f.\n       mono f \\<Longrightarrow>\n       gfp f \\<le> ccpo.fixp Inf (\\<lambda>x y. y \\<le> x) f", "apply (drule ccpo.fixp_unfold[OF is_dual_ccpo dual_ccpo_monoI, symmetric])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>f.\n       f (ccpo.fixp Inf (\\<lambda>x y. y \\<le> x) f) =\n       ccpo.fixp Inf (\\<lambda>x y. y \\<le> x) f \\<Longrightarrow>\n       ccpo.fixp Inf (\\<lambda>x y. y \\<le> x) f\n       \\<le> f (ccpo.fixp Inf (\\<lambda>x y. y \\<le> x) f)\n 2. \\<And>f.\n       mono f \\<Longrightarrow>\n       gfp f \\<le> ccpo.fixp Inf (\\<lambda>x y. y \\<le> x) f", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f.\n       mono f \\<Longrightarrow>\n       gfp f \\<le> ccpo.fixp Inf (\\<lambda>x y. y \\<le> x) f", "apply (rule ccpo.fixp_lowerbound[OF is_dual_ccpo dual_ccpo_monoI], assumption)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f. mono f \\<Longrightarrow> gfp f \\<le> f (gfp f)", "apply (simp add: gfp_unfold[symmetric])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "abbreviation \"chain_admissible P \\<equiv> ccpo.admissible Sup (\\<le>) P\""], ["", "abbreviation \"is_chain \\<equiv> Complete_Partial_Order.chain (\\<le>)\""], ["", "lemmas chain_admissibleI[intro?] = ccpo.admissibleI[where lub=Sup and ord=\"(\\<le>)\"]"], ["", "abbreviation \"dual_chain_admissible P \\<equiv> ccpo.admissible Inf (\\<lambda>x y. y\\<le>x) P\""], ["", "abbreviation \"is_dual_chain \\<equiv> Complete_Partial_Order.chain (\\<lambda>x y. y\\<le>x)\""], ["", "lemmas dual_chain_admissibleI[intro?] = \n  ccpo.admissibleI[where lub=Inf and ord=\"(\\<lambda>x y. y\\<le>x)\"]"], ["", "lemma dual_chain_iff[simp]: \"is_dual_chain C = is_chain C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_dual_chain C = is_chain C", "unfolding chain_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x\\<in>C. \\<forall>y\\<in>C. y \\<le> x \\<or> x \\<le> y) =\n    (\\<forall>x\\<in>C. \\<forall>y\\<in>C. x \\<le> y \\<or> y \\<le> x)", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemmas chain_dualI = iffD1[OF dual_chain_iff]"], ["", "lemmas dual_chainI = iffD2[OF dual_chain_iff]"], ["", "lemma is_chain_empty[simp, intro!]: \"is_chain {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_chain {}", "by (rule chainI) auto"], ["", "lemma is_dual_chain_empty[simp, intro!]: \"is_dual_chain {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_dual_chain {}", "by (rule dual_chainI) auto"], ["", "lemma point_chainI: \"is_chain M \\<Longrightarrow> is_chain ((\\<lambda>f. f x)`M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_chain M \\<Longrightarrow> is_chain ((\\<lambda>f. f x) ` M)", "by (auto intro: chainI le_funI dest: chainD le_funD)"], ["", "text \\<open>We transfer the admissible induction lemmas to complete\n  lattices.\\<close>"], ["", "lemma lfp_cadm_induct:\n  \"\\<lbrakk>chain_admissible P; P (Sup {}); mono f; \\<And>x. P x \\<Longrightarrow> P (f x)\\<rbrakk> \\<Longrightarrow> P (lfp f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>chain_admissible P; P (Sup {}); mono f;\n     \\<And>x. P x \\<Longrightarrow> P (f x)\\<rbrakk>\n    \\<Longrightarrow> P (lfp f)", "by (simp only: ccpo_mono_simp[symmetric] ccpo_lfp_simp[symmetric])\n     (rule ccpo.fixp_induct[OF is_ccpo])"], ["", "lemma gfp_cadm_induct:\n  \"\\<lbrakk>dual_chain_admissible P; P (Inf {}); mono f; \\<And>x. P x \\<Longrightarrow> P (f x)\\<rbrakk> \\<Longrightarrow> P (gfp f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>dual_chain_admissible P; P (Inf {}); mono f;\n     \\<And>x. P x \\<Longrightarrow> P (f x)\\<rbrakk>\n    \\<Longrightarrow> P (gfp f)", "by (simp only: dual_ccpo_mono_simp[symmetric] ccpo_gfp_simp[symmetric])\n     (rule ccpo.fixp_induct[OF is_dual_ccpo])"], ["", "subsubsection \\<open>Continuity and Kleene Fixed Point Theorem\\<close>"], ["", "definition \"cont f \\<equiv> \\<forall>C. C\\<noteq>{} \\<longrightarrow> f (Sup C) = Sup (f`C)\""], ["", "definition \"strict f \\<equiv> f bot = bot\""], ["", "definition \"inf_distrib f \\<equiv> strict f \\<and> cont f\""], ["", "lemma contI[intro?]: \"\\<lbrakk>\\<And>C. C\\<noteq>{} \\<Longrightarrow> f (Sup C) = Sup (f`C)\\<rbrakk> \\<Longrightarrow> cont f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>C.\n        C \\<noteq> {} \\<Longrightarrow>\n        f (Sup C) = Sup (f ` C)) \\<Longrightarrow>\n    cont f", "unfolding cont_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>C.\n        C \\<noteq> {} \\<Longrightarrow>\n        f (Sup C) = Sup (f ` C)) \\<Longrightarrow>\n    \\<forall>C. C \\<noteq> {} \\<longrightarrow> f (Sup C) = Sup (f ` C)", "by auto"], ["", "lemma contD: \"cont f \\<Longrightarrow> C\\<noteq>{} \\<Longrightarrow> f (Sup C) = Sup (f ` C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>cont f; C \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> f (Sup C) = Sup (f ` C)", "unfolding cont_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>C.\n                C \\<noteq> {} \\<longrightarrow> f (Sup C) = Sup (f ` C);\n     C \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> f (Sup C) = Sup (f ` C)", "by auto"], ["", "lemma contD': \"cont f \\<Longrightarrow> C\\<noteq>{} \\<Longrightarrow> f (Sup C) = Sup (f ` C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>cont f; C \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> f (Sup C) = Sup (f ` C)", "by (fact contD)"], ["", "lemma strictD[dest]: \"strict f \\<Longrightarrow> f bot = bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strict f \\<Longrightarrow> f bot = bot", "unfolding strict_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. f bot = bot \\<Longrightarrow> f bot = bot", "by auto\n\\<comment> \\<open>We only add this lemma to the simpset for functions on the same type. \n    Otherwise, the simplifier tries it much too often.\\<close>"], ["", "lemma strictD_simp[simp]: \"strict f \\<Longrightarrow> f (bot::'a::bot) = (bot::'a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strict f \\<Longrightarrow> f bot = bot", "unfolding strict_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. f bot = bot \\<Longrightarrow> f bot = bot", "by auto"], ["", "lemma strictI[intro?]: \"f bot = bot \\<Longrightarrow> strict f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f bot = bot \\<Longrightarrow> strict f", "unfolding strict_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. f bot = bot \\<Longrightarrow> f bot = bot", "by auto"], ["", "lemma inf_distribD[simp]: \n  \"inf_distrib f \\<Longrightarrow> strict f\"\n  \"inf_distrib f \\<Longrightarrow> cont f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (inf_distrib f \\<Longrightarrow> strict f) &&&\n    (inf_distrib f \\<Longrightarrow> cont f)", "unfolding inf_distrib_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (strict f \\<and> cont f \\<Longrightarrow> strict f) &&&\n    (strict f \\<and> cont f \\<Longrightarrow> cont f)", "by auto"], ["", "lemma inf_distribI[intro?]: \"\\<lbrakk>strict f; cont f\\<rbrakk> \\<Longrightarrow> inf_distrib f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>strict f; cont f\\<rbrakk> \\<Longrightarrow> inf_distrib f", "unfolding inf_distrib_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>strict f; cont f\\<rbrakk>\n    \\<Longrightarrow> strict f \\<and> cont f", "by auto"], ["", "lemma inf_distribD'[simp]:\n  fixes f :: \"'a::complete_lattice \\<Rightarrow> 'b::complete_lattice\"\n  shows \"inf_distrib f \\<Longrightarrow> f (Sup C) = Sup (f`C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inf_distrib f \\<Longrightarrow> f (Sup C) = Sup (f ` C)", "apply (cases \"C={}\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>inf_distrib f; C = {}\\<rbrakk>\n    \\<Longrightarrow> f (Sup C) = Sup (f ` C)\n 2. \\<lbrakk>inf_distrib f; C \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> f (Sup C) = Sup (f ` C)", "apply (auto dest: inf_distribD contD')"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma inf_distribI':\n  fixes f :: \"'a::complete_lattice \\<Rightarrow> 'b::complete_lattice\"\n  assumes B: \"\\<And>C. f (Sup C) = Sup (f`C)\"\n  shows \"inf_distrib f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inf_distrib f", "apply (rule)"], ["proof (prove)\ngoal (2 subgoals):\n 1. strict f\n 2. cont f", "apply (rule)"], ["proof (prove)\ngoal (2 subgoals):\n 1. f bot = bot\n 2. cont f", "apply (rule B[of \"{}\", simplified])"], ["proof (prove)\ngoal (1 subgoal):\n 1. cont f", "apply (rule)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>C. C \\<noteq> {} \\<Longrightarrow> f (Sup C) = Sup (f ` C)", "apply (rule B)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma cont_is_mono[simp]: \n  fixes f :: \"'a::complete_lattice \\<Rightarrow> 'b::complete_lattice\"\n  shows \"cont f \\<Longrightarrow> mono f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cont f \\<Longrightarrow> mono f", "apply (rule monoI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>cont f; x \\<le> y\\<rbrakk> \\<Longrightarrow> f x \\<le> f y", "apply (drule_tac C=\"{x,y}\" in contD)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y. x \\<le> y \\<Longrightarrow> {x, y} \\<noteq> {}\n 2. \\<And>x y.\n       \\<lbrakk>x \\<le> y; f (Sup {x, y}) = Sup (f ` {x, y})\\<rbrakk>\n       \\<Longrightarrow> f x \\<le> f y", "apply (auto simp: le_iff_sup)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma inf_distrib_is_mono[simp]: \n  fixes f :: \"'a::complete_lattice \\<Rightarrow> 'b::complete_lattice\"\n  shows \"inf_distrib f \\<Longrightarrow> mono f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inf_distrib f \\<Longrightarrow> mono f", "by simp"], ["", "text \\<open>Only proven for complete lattices here. Also holds for CCPOs.\\<close>"], ["", "theorem gen_kleene_lfp:\n  fixes f:: \"'a::complete_lattice \\<Rightarrow> 'a\"\n  assumes CONT: \"cont f\"\n  shows \"lfp (\\<lambda>x. sup m (f x)) = (SUP i. (f^^i) m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lfp (\\<lambda>x. sup m (f x)) = (SUP i. (f ^^ i) m)", "proof (rule antisym)"], ["proof (state)\ngoal (2 subgoals):\n 1. lfp (\\<lambda>x. sup m (f x)) \\<le> (SUP i. (f ^^ i) m)\n 2. (SUP i. (f ^^ i) m) \\<le> lfp (\\<lambda>x. sup m (f x))", "let ?f = \"(\\<lambda>x. sup m (f x))\""], ["proof (state)\ngoal (2 subgoals):\n 1. lfp (\\<lambda>x. sup m (f x)) \\<le> (SUP i. (f ^^ i) m)\n 2. (SUP i. (f ^^ i) m) \\<le> lfp (\\<lambda>x. sup m (f x))", "let ?K=\"{ (f^^i) m | i . True}\""], ["proof (state)\ngoal (2 subgoals):\n 1. lfp (\\<lambda>x. sup m (f x)) \\<le> (SUP i. (f ^^ i) m)\n 2. (SUP i. (f ^^ i) m) \\<le> lfp (\\<lambda>x. sup m (f x))", "note MONO=cont_is_mono[OF CONT]"], ["proof (state)\nthis:\n  mono f\n\ngoal (2 subgoals):\n 1. lfp (\\<lambda>x. sup m (f x)) \\<le> (SUP i. (f ^^ i) m)\n 2. (SUP i. (f ^^ i) m) \\<le> lfp (\\<lambda>x. sup m (f x))", "note MONO'[refine_mono] = monoD[OF MONO]"], ["proof (state)\nthis:\n  ?x \\<le> ?y \\<Longrightarrow> f ?x \\<le> f ?y\n\ngoal (2 subgoals):\n 1. lfp (\\<lambda>x. sup m (f x)) \\<le> (SUP i. (f ^^ i) m)\n 2. (SUP i. (f ^^ i) m) \\<le> lfp (\\<lambda>x. sup m (f x))", "{"], ["proof (state)\nthis:\n  ?x \\<le> ?y \\<Longrightarrow> f ?x \\<le> f ?y\n\ngoal (2 subgoals):\n 1. lfp (\\<lambda>x. sup m (f x)) \\<le> (SUP i. (f ^^ i) m)\n 2. (SUP i. (f ^^ i) m) \\<le> lfp (\\<lambda>x. sup m (f x))", "fix i"], ["proof (state)\ngoal (2 subgoals):\n 1. lfp (\\<lambda>x. sup m (f x)) \\<le> (SUP i. (f ^^ i) m)\n 2. (SUP i. (f ^^ i) m) \\<le> lfp (\\<lambda>x. sup m (f x))", "have \"(f^^i) m \\<le> lfp ?f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f ^^ i) m \\<le> lfp (\\<lambda>x. sup m (f x))", "apply (induct i)"], ["proof (prove)\ngoal (2 subgoals):\n 1. (f ^^ 0) m \\<le> lfp (\\<lambda>x. sup m (f x))\n 2. \\<And>i.\n       (f ^^ i) m \\<le> lfp (\\<lambda>x. sup m (f x)) \\<Longrightarrow>\n       (f ^^ Suc i) m \\<le> lfp (\\<lambda>x. sup m (f x))", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. m \\<le> lfp (\\<lambda>x. sup m (f x))\n 2. \\<And>i.\n       (f ^^ i) m \\<le> lfp (\\<lambda>x. sup m (f x)) \\<Longrightarrow>\n       (f ^^ Suc i) m \\<le> lfp (\\<lambda>x. sup m (f x))", "apply (subst lfp_unfold)"], ["proof (prove)\ngoal (3 subgoals):\n 1. mono (\\<lambda>x. sup m (f x))\n 2. m \\<le> sup m (f (lfp (\\<lambda>x. sup m (f x))))\n 3. \\<And>i.\n       (f ^^ i) m \\<le> lfp (\\<lambda>x. sup m (f x)) \\<Longrightarrow>\n       (f ^^ Suc i) m \\<le> lfp (\\<lambda>x. sup m (f x))", "apply (meson MONO' monoI order_mono_setup.refl sup_mono)"], ["proof (prove)\ngoal (2 subgoals):\n 1. m \\<le> sup m (f (lfp (\\<lambda>x. sup m (f x))))\n 2. \\<And>i.\n       (f ^^ i) m \\<le> lfp (\\<lambda>x. sup m (f x)) \\<Longrightarrow>\n       (f ^^ Suc i) m \\<le> lfp (\\<lambda>x. sup m (f x))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       (f ^^ i) m \\<le> lfp (\\<lambda>x. sup m (f x)) \\<Longrightarrow>\n       (f ^^ Suc i) m \\<le> lfp (\\<lambda>x. sup m (f x))", "apply (subst lfp_unfold)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i.\n       (f ^^ i) m \\<le> lfp (\\<lambda>x. sup m (f x)) \\<Longrightarrow>\n       mono (\\<lambda>x. sup m (f x))\n 2. \\<And>i.\n       (f ^^ i) m \\<le> lfp (\\<lambda>x. sup m (f x)) \\<Longrightarrow>\n       (f ^^ Suc i) m \\<le> sup m (f (lfp (\\<lambda>x. sup m (f x))))", "apply (meson MONO' monoI order_mono_setup.refl sup_mono)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       (f ^^ i) m \\<le> lfp (\\<lambda>x. sup m (f x)) \\<Longrightarrow>\n       (f ^^ Suc i) m \\<le> sup m (f (lfp (\\<lambda>x. sup m (f x))))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       (f ^^ i) m \\<le> lfp (\\<lambda>x. sup m (f x)) \\<Longrightarrow>\n       f ((f ^^ i) m) \\<le> sup m (f (lfp (\\<lambda>x. sup m (f x))))", "by (metis MONO' le_supI2)"], ["proof (state)\nthis:\n  (f ^^ i) m \\<le> lfp (\\<lambda>x. sup m (f x))\n\ngoal (2 subgoals):\n 1. lfp (\\<lambda>x. sup m (f x)) \\<le> (SUP i. (f ^^ i) m)\n 2. (SUP i. (f ^^ i) m) \\<le> lfp (\\<lambda>x. sup m (f x))", "}"], ["proof (state)\nthis:\n  (f ^^ ?i2) m \\<le> lfp (\\<lambda>x. sup m (f x))\n\ngoal (2 subgoals):\n 1. lfp (\\<lambda>x. sup m (f x)) \\<le> (SUP i. (f ^^ i) m)\n 2. (SUP i. (f ^^ i) m) \\<le> lfp (\\<lambda>x. sup m (f x))", "thus \"(SUP i. (f^^i) m) \\<le> lfp ?f\""], ["proof (prove)\nusing this:\n  (f ^^ ?i2) m \\<le> lfp (\\<lambda>x. sup m (f x))\n\ngoal (1 subgoal):\n 1. (SUP i. (f ^^ i) m) \\<le> lfp (\\<lambda>x. sup m (f x))", "by (blast intro: SUP_least)"], ["proof (state)\nthis:\n  (SUP i. (f ^^ i) m) \\<le> lfp (\\<lambda>x. sup m (f x))\n\ngoal (1 subgoal):\n 1. lfp (\\<lambda>x. sup m (f x)) \\<le> (SUP i. (f ^^ i) m)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. lfp (\\<lambda>x. sup m (f x)) \\<le> (SUP i. (f ^^ i) m)", "let ?f = \"(\\<lambda>x. sup m (f x))\""], ["proof (state)\ngoal (1 subgoal):\n 1. lfp (\\<lambda>x. sup m (f x)) \\<le> (SUP i. (f ^^ i) m)", "show \"lfp ?f \\<le> (SUP i. (f^^i) m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lfp (\\<lambda>x. sup m (f x)) \\<le> (SUP i. (f ^^ i) m)", "apply (rule lfp_lowerbound)"], ["proof (prove)\ngoal (1 subgoal):\n 1. sup m (f (SUP i. (f ^^ i) m)) \\<le> (SUP i. (f ^^ i) m)", "apply (rule sup_least)"], ["proof (prove)\ngoal (2 subgoals):\n 1. m \\<le> (SUP i. (f ^^ i) m)\n 2. f (SUP i. (f ^^ i) m) \\<le> (SUP i. (f ^^ i) m)", "apply (rule order_trans[OF _ SUP_upper[where i=0]], simp_all) []"], ["proof (prove)\ngoal (1 subgoal):\n 1. f (SUP i. (f ^^ i) m) \\<le> (SUP i. (f ^^ i) m)", "apply (simp add: contD [OF CONT])"], ["proof (prove)\ngoal (1 subgoal):\n 1. Sup (f ` range (\\<lambda>i. (f ^^ i) m)) \\<le> (SUP i. (f ^^ i) m)", "apply (rule Sup_subset_mono)"], ["proof (prove)\ngoal (1 subgoal):\n 1. f ` range (\\<lambda>i. (f ^^ i) m)\n    \\<subseteq> range (\\<lambda>i. (f ^^ i) m)", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i. f ((f ^^ i) m) \\<in> range (\\<lambda>i. (f ^^ i) m)", "apply (rule_tac x=\"Suc i\" in range_eqI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i. f ((f ^^ i) m) = (f ^^ Suc i) m", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  lfp (\\<lambda>x. sup m (f x)) \\<le> (SUP i. (f ^^ i) m)\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem kleene_lfp:\n  fixes f:: \"'a::complete_lattice \\<Rightarrow> 'a\"\n  assumes CONT: \"cont f\"\n  shows \"lfp f = (SUP i. (f^^i) bot)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lfp f = (SUP i. (f ^^ i) bot)", "using gen_kleene_lfp[OF CONT,where m=bot]"], ["proof (prove)\nusing this:\n  lfp (\\<lambda>x. sup bot (f x)) = (SUP i. (f ^^ i) bot)\n\ngoal (1 subgoal):\n 1. lfp f = (SUP i. (f ^^ i) bot)", "by simp"], ["", "theorem (* Detailed proof *)\n  fixes f:: \"'a::complete_lattice \\<Rightarrow> 'a\"\n  assumes CONT: \"cont f\"\n  shows \"lfp f = (SUP i. (f^^i) bot)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lfp f = (SUP i. (f ^^ i) bot)", "proof (rule antisym)"], ["proof (state)\ngoal (2 subgoals):\n 1. lfp f \\<le> (SUP i. (f ^^ i) bot)\n 2. (SUP i. (f ^^ i) bot) \\<le> lfp f", "let ?K=\"{ (f^^i) bot | i . True}\""], ["proof (state)\ngoal (2 subgoals):\n 1. lfp f \\<le> (SUP i. (f ^^ i) bot)\n 2. (SUP i. (f ^^ i) bot) \\<le> lfp f", "note MONO=cont_is_mono[OF CONT]"], ["proof (state)\nthis:\n  mono f\n\ngoal (2 subgoals):\n 1. lfp f \\<le> (SUP i. (f ^^ i) bot)\n 2. (SUP i. (f ^^ i) bot) \\<le> lfp f", "{"], ["proof (state)\nthis:\n  mono f\n\ngoal (2 subgoals):\n 1. lfp f \\<le> (SUP i. (f ^^ i) bot)\n 2. (SUP i. (f ^^ i) bot) \\<le> lfp f", "fix i"], ["proof (state)\ngoal (2 subgoals):\n 1. lfp f \\<le> (SUP i. (f ^^ i) bot)\n 2. (SUP i. (f ^^ i) bot) \\<le> lfp f", "have \"(f^^i) bot \\<le> lfp f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f ^^ i) bot \\<le> lfp f", "apply (induct i)"], ["proof (prove)\ngoal (2 subgoals):\n 1. (f ^^ 0) bot \\<le> lfp f\n 2. \\<And>i.\n       (f ^^ i) bot \\<le> lfp f \\<Longrightarrow>\n       (f ^^ Suc i) bot \\<le> lfp f", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       (f ^^ i) bot \\<le> lfp f \\<Longrightarrow>\n       (f ^^ Suc i) bot \\<le> lfp f", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       (f ^^ i) bot \\<le> lfp f \\<Longrightarrow>\n       f ((f ^^ i) bot) \\<le> lfp f", "by (metis MONO lfp_unfold monoD)"], ["proof (state)\nthis:\n  (f ^^ i) bot \\<le> lfp f\n\ngoal (2 subgoals):\n 1. lfp f \\<le> (SUP i. (f ^^ i) bot)\n 2. (SUP i. (f ^^ i) bot) \\<le> lfp f", "}"], ["proof (state)\nthis:\n  (f ^^ ?i2) bot \\<le> lfp f\n\ngoal (2 subgoals):\n 1. lfp f \\<le> (SUP i. (f ^^ i) bot)\n 2. (SUP i. (f ^^ i) bot) \\<le> lfp f", "thus \"(SUP i. (f^^i) bot) \\<le> lfp f\""], ["proof (prove)\nusing this:\n  (f ^^ ?i2) bot \\<le> lfp f\n\ngoal (1 subgoal):\n 1. (SUP i. (f ^^ i) bot) \\<le> lfp f", "by (blast intro: SUP_least)"], ["proof (state)\nthis:\n  (SUP i. (f ^^ i) bot) \\<le> lfp f\n\ngoal (1 subgoal):\n 1. lfp f \\<le> (SUP i. (f ^^ i) bot)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. lfp f \\<le> (SUP i. (f ^^ i) bot)", "show \"lfp f \\<le> (SUP i. (f^^i) bot)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lfp f \\<le> (SUP i. (f ^^ i) bot)", "apply (rule lfp_lowerbound)"], ["proof (prove)\ngoal (1 subgoal):\n 1. f (SUP i. (f ^^ i) bot) \\<le> (SUP i. (f ^^ i) bot)", "apply (simp add: contD [OF CONT])"], ["proof (prove)\ngoal (1 subgoal):\n 1. Sup (f ` range (\\<lambda>i. (f ^^ i) bot)) \\<le> (SUP i. (f ^^ i) bot)", "apply (rule Sup_subset_mono)"], ["proof (prove)\ngoal (1 subgoal):\n 1. f ` range (\\<lambda>i. (f ^^ i) bot)\n    \\<subseteq> range (\\<lambda>i. (f ^^ i) bot)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i. f ((f ^^ i) bot) \\<in> range (\\<lambda>i. (f ^^ i) bot)", "apply (rule_tac x=\"Suc i\" in range_eqI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i. f ((f ^^ i) bot) = (f ^^ Suc i) bot", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  lfp f \\<le> (SUP i. (f ^^ i) bot)\n\ngoal:\nNo subgoals!", "qed"], ["", "(* Alternative proof of gen_kleene_lfp that re-uses standard Kleene, but is more tedious *)"], ["", "lemma SUP_funpow_contracting:\n  fixes f :: \"'a \\<Rightarrow> ('a::complete_lattice)\"\n  assumes C: \"cont f\" \n  shows \"f (SUP i. (f^^i) m) \\<le> (SUP i. (f^^i) m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f (SUP i. (f ^^ i) m) \\<le> (SUP i. (f ^^ i) m)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. f (SUP i. (f ^^ i) m) \\<le> (SUP i. (f ^^ i) m)", "have 1: \"\\<And>i x. f ((f^^i) x) = (f^^(Suc i)) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i x. f ((f ^^ i) x) = (f ^^ Suc i) x", "by simp"], ["proof (state)\nthis:\n  f ((f ^^ ?i) ?x) = (f ^^ Suc ?i) ?x\n\ngoal (1 subgoal):\n 1. f (SUP i. (f ^^ i) m) \\<le> (SUP i. (f ^^ i) m)", "have \"f (SUP i. (f^^i) m) = (SUP i. f ((f ^^ i) m))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f (SUP i. (f ^^ i) m) = (SUP i. f ((f ^^ i) m))", "by (subst contD[OF C]) (simp_all add: image_comp)"], ["proof (state)\nthis:\n  f (SUP i. (f ^^ i) m) = (SUP i. f ((f ^^ i) m))\n\ngoal (1 subgoal):\n 1. f (SUP i. (f ^^ i) m) \\<le> (SUP i. (f ^^ i) m)", "also"], ["proof (state)\nthis:\n  f (SUP i. (f ^^ i) m) = (SUP i. f ((f ^^ i) m))\n\ngoal (1 subgoal):\n 1. f (SUP i. (f ^^ i) m) \\<le> (SUP i. (f ^^ i) m)", "have \"\\<dots> \\<le> (SUP i. (f^^i) m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (SUP i. f ((f ^^ i) m)) \\<le> (SUP i. (f ^^ i) m)", "apply (rule SUP_least)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<in> UNIV \\<Longrightarrow>\n       f ((f ^^ i) m) \\<le> (SUP i. (f ^^ i) m)", "apply (simp, subst 1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i. (f ^^ Suc i) m \\<le> (SUP i. (f ^^ i) m)", "apply (rule SUP_upper)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i. Suc i \\<in> UNIV", ".."], ["proof (state)\nthis:\n  (SUP i. f ((f ^^ i) m)) \\<le> (SUP i. (f ^^ i) m)\n\ngoal (1 subgoal):\n 1. f (SUP i. (f ^^ i) m) \\<le> (SUP i. (f ^^ i) m)", "finally"], ["proof (chain)\npicking this:\n  f (SUP i. (f ^^ i) m) \\<le> (SUP i. (f ^^ i) m)", "show ?thesis"], ["proof (prove)\nusing this:\n  f (SUP i. (f ^^ i) m) \\<le> (SUP i. (f ^^ i) m)\n\ngoal (1 subgoal):\n 1. f (SUP i. (f ^^ i) m) \\<le> (SUP i. (f ^^ i) m)", "."], ["proof (state)\nthis:\n  f (SUP i. (f ^^ i) m) \\<le> (SUP i. (f ^^ i) m)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma gen_kleene_chain_conv:\n  fixes f :: \"'a::complete_lattice \\<Rightarrow> 'a\"\n  assumes C: \"cont f\"\n  shows \"(SUP i. (f^^i) m) = (SUP i. ((\\<lambda>x. sup m (f x))^^i) bot)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (SUP i. (f ^^ i) m) = (SUP i. ((\\<lambda>x. sup m (f x)) ^^ i) bot)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (SUP i. (f ^^ i) m) = (SUP i. ((\\<lambda>x. sup m (f x)) ^^ i) bot)", "let ?f' = \"\\<lambda>x. sup m (f x)\""], ["proof (state)\ngoal (1 subgoal):\n 1. (SUP i. (f ^^ i) m) = (SUP i. ((\\<lambda>x. sup m (f x)) ^^ i) bot)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (SUP i. (f ^^ i) m) = (SUP i. ((\\<lambda>x. sup m (f x)) ^^ i) bot)", "proof (intro antisym SUP_least)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i.\n       i \\<in> UNIV \\<Longrightarrow>\n       (f ^^ i) m \\<le> (SUP i. ((\\<lambda>x. sup m (f x)) ^^ i) bot)\n 2. \\<And>i.\n       i \\<in> UNIV \\<Longrightarrow>\n       ((\\<lambda>x. sup m (f x)) ^^ i) bot \\<le> (SUP i. (f ^^ i) m)", "from C"], ["proof (chain)\npicking this:\n  cont f", "have C': \"cont ?f'\""], ["proof (prove)\nusing this:\n  cont f\n\ngoal (1 subgoal):\n 1. cont (\\<lambda>x. sup m (f x))", "unfolding cont_def"], ["proof (prove)\nusing this:\n  \\<forall>C. C \\<noteq> {} \\<longrightarrow> f (Sup C) = Sup (f ` C)\n\ngoal (1 subgoal):\n 1. \\<forall>C.\n       C \\<noteq> {} \\<longrightarrow>\n       sup m (f (Sup C)) = (SUP x\\<in>C. sup m (f x))", "by (simp add: SUP_sup_distrib[symmetric])"], ["proof (state)\nthis:\n  cont (\\<lambda>x. sup m (f x))\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i \\<in> UNIV \\<Longrightarrow>\n       (f ^^ i) m \\<le> (SUP i. ((\\<lambda>x. sup m (f x)) ^^ i) bot)\n 2. \\<And>i.\n       i \\<in> UNIV \\<Longrightarrow>\n       ((\\<lambda>x. sup m (f x)) ^^ i) bot \\<le> (SUP i. (f ^^ i) m)", "fix i"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i.\n       i \\<in> UNIV \\<Longrightarrow>\n       (f ^^ i) m \\<le> (SUP i. ((\\<lambda>x. sup m (f x)) ^^ i) bot)\n 2. \\<And>i.\n       i \\<in> UNIV \\<Longrightarrow>\n       ((\\<lambda>x. sup m (f x)) ^^ i) bot \\<le> (SUP i. (f ^^ i) m)", "show \"(f ^^ i) m \\<le> (SUP i. (?f' ^^ i) bot)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f ^^ i) m \\<le> (SUP i. ((\\<lambda>x. sup m (f x)) ^^ i) bot)", "proof (induction i)"], ["proof (state)\ngoal (2 subgoals):\n 1. (f ^^ 0) m \\<le> (SUP i. ((\\<lambda>x. sup m (f x)) ^^ i) bot)\n 2. \\<And>i.\n       (f ^^ i) m\n       \\<le> (SUP i. ((\\<lambda>x. sup m (f x)) ^^ i) bot) \\<Longrightarrow>\n       (f ^^ Suc i) m \\<le> (SUP i. ((\\<lambda>x. sup m (f x)) ^^ i) bot)", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. (f ^^ 0) m \\<le> (SUP i. ((\\<lambda>x. sup m (f x)) ^^ i) bot)\n 2. \\<And>i.\n       (f ^^ i) m\n       \\<le> (SUP i. ((\\<lambda>x. sup m (f x)) ^^ i) bot) \\<Longrightarrow>\n       (f ^^ Suc i) m \\<le> (SUP i. ((\\<lambda>x. sup m (f x)) ^^ i) bot)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (f ^^ 0) m \\<le> (SUP i. ((\\<lambda>x. sup m (f x)) ^^ i) bot)", "by (rule order_trans[OF _ SUP_upper[where i=1]]) auto"], ["proof (state)\nthis:\n  (f ^^ 0) m \\<le> (SUP i. ((\\<lambda>x. sup m (f x)) ^^ i) bot)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       (f ^^ i) m\n       \\<le> (SUP i. ((\\<lambda>x. sup m (f x)) ^^ i) bot) \\<Longrightarrow>\n       (f ^^ Suc i) m \\<le> (SUP i. ((\\<lambda>x. sup m (f x)) ^^ i) bot)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       (f ^^ i) m\n       \\<le> (SUP i. ((\\<lambda>x. sup m (f x)) ^^ i) bot) \\<Longrightarrow>\n       (f ^^ Suc i) m \\<le> (SUP i. ((\\<lambda>x. sup m (f x)) ^^ i) bot)", "case (Suc i)"], ["proof (state)\nthis:\n  (f ^^ i) m \\<le> (SUP i. ((\\<lambda>x. sup m (f x)) ^^ i) bot)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       (f ^^ i) m\n       \\<le> (SUP i. ((\\<lambda>x. sup m (f x)) ^^ i) bot) \\<Longrightarrow>\n       (f ^^ Suc i) m \\<le> (SUP i. ((\\<lambda>x. sup m (f x)) ^^ i) bot)", "from cont_is_mono[OF C, THEN monoD, OF Suc]"], ["proof (chain)\npicking this:\n  f ((f ^^ i) m) \\<le> f (SUP i. ((\\<lambda>x. sup m (f x)) ^^ i) bot)", "have \"(f ^^ (Suc i)) m \\<le> f (SUP i. ((\\<lambda>x. sup m (f x)) ^^ i) bot)\""], ["proof (prove)\nusing this:\n  f ((f ^^ i) m) \\<le> f (SUP i. ((\\<lambda>x. sup m (f x)) ^^ i) bot)\n\ngoal (1 subgoal):\n 1. (f ^^ Suc i) m \\<le> f (SUP i. ((\\<lambda>x. sup m (f x)) ^^ i) bot)", "by simp"], ["proof (state)\nthis:\n  (f ^^ Suc i) m \\<le> f (SUP i. ((\\<lambda>x. sup m (f x)) ^^ i) bot)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       (f ^^ i) m\n       \\<le> (SUP i. ((\\<lambda>x. sup m (f x)) ^^ i) bot) \\<Longrightarrow>\n       (f ^^ Suc i) m \\<le> (SUP i. ((\\<lambda>x. sup m (f x)) ^^ i) bot)", "also"], ["proof (state)\nthis:\n  (f ^^ Suc i) m \\<le> f (SUP i. ((\\<lambda>x. sup m (f x)) ^^ i) bot)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       (f ^^ i) m\n       \\<le> (SUP i. ((\\<lambda>x. sup m (f x)) ^^ i) bot) \\<Longrightarrow>\n       (f ^^ Suc i) m \\<le> (SUP i. ((\\<lambda>x. sup m (f x)) ^^ i) bot)", "have \"\\<dots> \\<le> sup m \\<dots>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f (SUP i. ((\\<lambda>x. sup m (f x)) ^^ i) bot)\n    \\<le> sup m (f (SUP i. ((\\<lambda>x. sup m (f x)) ^^ i) bot))", "by simp"], ["proof (state)\nthis:\n  f (SUP i. ((\\<lambda>x. sup m (f x)) ^^ i) bot)\n  \\<le> sup m (f (SUP i. ((\\<lambda>x. sup m (f x)) ^^ i) bot))\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       (f ^^ i) m\n       \\<le> (SUP i. ((\\<lambda>x. sup m (f x)) ^^ i) bot) \\<Longrightarrow>\n       (f ^^ Suc i) m \\<le> (SUP i. ((\\<lambda>x. sup m (f x)) ^^ i) bot)", "also"], ["proof (state)\nthis:\n  f (SUP i. ((\\<lambda>x. sup m (f x)) ^^ i) bot)\n  \\<le> sup m (f (SUP i. ((\\<lambda>x. sup m (f x)) ^^ i) bot))\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       (f ^^ i) m\n       \\<le> (SUP i. ((\\<lambda>x. sup m (f x)) ^^ i) bot) \\<Longrightarrow>\n       (f ^^ Suc i) m \\<le> (SUP i. ((\\<lambda>x. sup m (f x)) ^^ i) bot)", "note SUP_funpow_contracting[OF C']"], ["proof (state)\nthis:\n  sup m (f (SUP i. ((\\<lambda>x. sup m (f x)) ^^ i) ?m))\n  \\<le> (SUP i. ((\\<lambda>x. sup m (f x)) ^^ i) ?m)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       (f ^^ i) m\n       \\<le> (SUP i. ((\\<lambda>x. sup m (f x)) ^^ i) bot) \\<Longrightarrow>\n       (f ^^ Suc i) m \\<le> (SUP i. ((\\<lambda>x. sup m (f x)) ^^ i) bot)", "finally"], ["proof (chain)\npicking this:\n  (f ^^ Suc i) m \\<le> (SUP i. ((\\<lambda>x. sup m (f x)) ^^ i) bot)", "show ?case"], ["proof (prove)\nusing this:\n  (f ^^ Suc i) m \\<le> (SUP i. ((\\<lambda>x. sup m (f x)) ^^ i) bot)\n\ngoal (1 subgoal):\n 1. (f ^^ Suc i) m \\<le> (SUP i. ((\\<lambda>x. sup m (f x)) ^^ i) bot)", "."], ["proof (state)\nthis:\n  (f ^^ Suc i) m \\<le> (SUP i. ((\\<lambda>x. sup m (f x)) ^^ i) bot)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (f ^^ i) m \\<le> (SUP i. ((\\<lambda>x. sup m (f x)) ^^ i) bot)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<in> UNIV \\<Longrightarrow>\n       ((\\<lambda>x. sup m (f x)) ^^ i) bot \\<le> (SUP i. (f ^^ i) m)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<in> UNIV \\<Longrightarrow>\n       ((\\<lambda>x. sup m (f x)) ^^ i) bot \\<le> (SUP i. (f ^^ i) m)", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<in> UNIV \\<Longrightarrow>\n       ((\\<lambda>x. sup m (f x)) ^^ i) bot \\<le> (SUP i. (f ^^ i) m)", "show \"(?f'^^i) bot \\<le> (SUP i. (f^^i) m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x. sup m (f x)) ^^ i) bot \\<le> (SUP i. (f ^^ i) m)", "proof (induction i)"], ["proof (state)\ngoal (2 subgoals):\n 1. ((\\<lambda>x. sup m (f x)) ^^ 0) bot \\<le> (SUP i. (f ^^ i) m)\n 2. \\<And>i.\n       ((\\<lambda>x. sup m (f x)) ^^ i) bot\n       \\<le> (SUP i. (f ^^ i) m) \\<Longrightarrow>\n       ((\\<lambda>x. sup m (f x)) ^^ Suc i) bot \\<le> (SUP i. (f ^^ i) m)", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. ((\\<lambda>x. sup m (f x)) ^^ 0) bot \\<le> (SUP i. (f ^^ i) m)\n 2. \\<And>i.\n       ((\\<lambda>x. sup m (f x)) ^^ i) bot\n       \\<le> (SUP i. (f ^^ i) m) \\<Longrightarrow>\n       ((\\<lambda>x. sup m (f x)) ^^ Suc i) bot \\<le> (SUP i. (f ^^ i) m)", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x. sup m (f x)) ^^ 0) bot \\<le> (SUP i. (f ^^ i) m)", "by simp"], ["proof (state)\nthis:\n  ((\\<lambda>x. sup m (f x)) ^^ 0) bot \\<le> (SUP i. (f ^^ i) m)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       ((\\<lambda>x. sup m (f x)) ^^ i) bot\n       \\<le> (SUP i. (f ^^ i) m) \\<Longrightarrow>\n       ((\\<lambda>x. sup m (f x)) ^^ Suc i) bot \\<le> (SUP i. (f ^^ i) m)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       ((\\<lambda>x. sup m (f x)) ^^ i) bot\n       \\<le> (SUP i. (f ^^ i) m) \\<Longrightarrow>\n       ((\\<lambda>x. sup m (f x)) ^^ Suc i) bot \\<le> (SUP i. (f ^^ i) m)", "case (Suc i)"], ["proof (state)\nthis:\n  ((\\<lambda>x. sup m (f x)) ^^ i) bot \\<le> (SUP i. (f ^^ i) m)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       ((\\<lambda>x. sup m (f x)) ^^ i) bot\n       \\<le> (SUP i. (f ^^ i) m) \\<Longrightarrow>\n       ((\\<lambda>x. sup m (f x)) ^^ Suc i) bot \\<le> (SUP i. (f ^^ i) m)", "from monoD[OF cont_is_mono[OF C] Suc]"], ["proof (chain)\npicking this:\n  f (((\\<lambda>x. sup m (f x)) ^^ i) bot) \\<le> f (SUP i. (f ^^ i) m)", "have \"(?f'^^Suc i) bot \\<le> sup m (f (SUP i. (f ^^ i) m))\""], ["proof (prove)\nusing this:\n  f (((\\<lambda>x. sup m (f x)) ^^ i) bot) \\<le> f (SUP i. (f ^^ i) m)\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. sup m (f x)) ^^ Suc i) bot\n    \\<le> sup m (f (SUP i. (f ^^ i) m))", "by (simp add: le_supI2)"], ["proof (state)\nthis:\n  ((\\<lambda>x. sup m (f x)) ^^ Suc i) bot\n  \\<le> sup m (f (SUP i. (f ^^ i) m))\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       ((\\<lambda>x. sup m (f x)) ^^ i) bot\n       \\<le> (SUP i. (f ^^ i) m) \\<Longrightarrow>\n       ((\\<lambda>x. sup m (f x)) ^^ Suc i) bot \\<le> (SUP i. (f ^^ i) m)", "also"], ["proof (state)\nthis:\n  ((\\<lambda>x. sup m (f x)) ^^ Suc i) bot\n  \\<le> sup m (f (SUP i. (f ^^ i) m))\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       ((\\<lambda>x. sup m (f x)) ^^ i) bot\n       \\<le> (SUP i. (f ^^ i) m) \\<Longrightarrow>\n       ((\\<lambda>x. sup m (f x)) ^^ Suc i) bot \\<le> (SUP i. (f ^^ i) m)", "have \"\\<dots> \\<le> (SUP i. (f ^^ i) m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sup m (f (SUP i. (f ^^ i) m)) \\<le> (SUP i. (f ^^ i) m)", "apply (rule sup_least)"], ["proof (prove)\ngoal (2 subgoals):\n 1. m \\<le> (SUP i. (f ^^ i) m)\n 2. f (SUP i. (f ^^ i) m) \\<le> (SUP i. (f ^^ i) m)", "apply (rule order_trans[OF _ SUP_upper[where i=0]], simp_all) []"], ["proof (prove)\ngoal (1 subgoal):\n 1. f (SUP i. (f ^^ i) m) \\<le> (SUP i. (f ^^ i) m)", "apply (rule SUP_funpow_contracting[OF C])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  sup m (f (SUP i. (f ^^ i) m)) \\<le> (SUP i. (f ^^ i) m)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       ((\\<lambda>x. sup m (f x)) ^^ i) bot\n       \\<le> (SUP i. (f ^^ i) m) \\<Longrightarrow>\n       ((\\<lambda>x. sup m (f x)) ^^ Suc i) bot \\<le> (SUP i. (f ^^ i) m)", "finally"], ["proof (chain)\npicking this:\n  ((\\<lambda>x. sup m (f x)) ^^ Suc i) bot \\<le> (SUP i. (f ^^ i) m)", "show ?case"], ["proof (prove)\nusing this:\n  ((\\<lambda>x. sup m (f x)) ^^ Suc i) bot \\<le> (SUP i. (f ^^ i) m)\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. sup m (f x)) ^^ Suc i) bot \\<le> (SUP i. (f ^^ i) m)", "."], ["proof (state)\nthis:\n  ((\\<lambda>x. sup m (f x)) ^^ Suc i) bot \\<le> (SUP i. (f ^^ i) m)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ((\\<lambda>x. sup m (f x)) ^^ i) bot \\<le> (SUP i. (f ^^ i) m)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (SUP i. (f ^^ i) m) = (SUP i. ((\\<lambda>x. sup m (f x)) ^^ i) bot)\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem \n  assumes C: \"cont f\"\n  shows \"lfp (\\<lambda>x. sup m (f x)) = (SUP i. (f^^i) m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lfp (\\<lambda>x. sup m (f x)) = (SUP i. (f ^^ i) m)", "apply (subst gen_kleene_chain_conv[OF C])"], ["proof (prove)\ngoal (1 subgoal):\n 1. lfp (\\<lambda>x. sup m (f x)) =\n    (SUP i. ((\\<lambda>x. sup m (f x)) ^^ i) bot)", "apply (rule kleene_lfp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. cont (\\<lambda>x. sup m (f x))", "using C"], ["proof (prove)\nusing this:\n  cont f\n\ngoal (1 subgoal):\n 1. cont (\\<lambda>x. sup m (f x))", "unfolding cont_def"], ["proof (prove)\nusing this:\n  \\<forall>C. C \\<noteq> {} \\<longrightarrow> f (Sup C) = Sup (f ` C)\n\ngoal (1 subgoal):\n 1. \\<forall>C.\n       C \\<noteq> {} \\<longrightarrow>\n       sup m (f (Sup C)) = (SUP x\\<in>C. sup m (f x))", "apply (simp add: SUP_sup_distrib[symmetric])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma (in galois_connection) dual_inf_dist_\\<gamma>: \"\\<gamma> (Inf C) = Inf (\\<gamma>`C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<gamma> (Inf C) = Inf (\\<gamma> ` C)", "apply (rule antisym)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<gamma> (Inf C) \\<le> Inf (\\<gamma> ` C)\n 2. Inf (\\<gamma> ` C) \\<le> \\<gamma> (Inf C)", "apply (rule Inf_greatest)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> \\<gamma> ` C \\<Longrightarrow> \\<gamma> (Inf C) \\<le> x\n 2. Inf (\\<gamma> ` C) \\<le> \\<gamma> (Inf C)", "apply clarify"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       xa \\<in> C \\<Longrightarrow> \\<gamma> (Inf C) \\<le> \\<gamma> xa\n 2. Inf (\\<gamma> ` C) \\<le> \\<gamma> (Inf C)", "apply (rule monoD[OF \\<gamma>_mono])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xa. xa \\<in> C \\<Longrightarrow> Inf C \\<le> xa\n 2. Inf (\\<gamma> ` C) \\<le> \\<gamma> (Inf C)", "apply (rule Inf_lower)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xa. xa \\<in> C \\<Longrightarrow> xa \\<in> C\n 2. Inf (\\<gamma> ` C) \\<le> \\<gamma> (Inf C)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. Inf (\\<gamma> ` C) \\<le> \\<gamma> (Inf C)", "apply (subst galois)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha> (Inf (\\<gamma> ` C)) \\<le> Inf C", "apply (rule Inf_greatest)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> C \\<Longrightarrow> \\<alpha> (Inf (\\<gamma> ` C)) \\<le> x", "apply (subst galois[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> C \\<Longrightarrow> Inf (\\<gamma> ` C) \\<le> \\<gamma> x", "apply (rule Inf_lower)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> C \\<Longrightarrow> \\<gamma> x \\<in> \\<gamma> ` C", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma (in galois_connection) inf_dist_\\<alpha>: \"inf_distrib \\<alpha>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inf_distrib \\<alpha>", "apply (rule inf_distribI')"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>C. \\<alpha> (Sup C) = Sup (\\<alpha> ` C)", "apply (rule antisym)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>C. \\<alpha> (Sup C) \\<le> Sup (\\<alpha> ` C)\n 2. \\<And>C. Sup (\\<alpha> ` C) \\<le> \\<alpha> (Sup C)", "apply (subst galois[symmetric])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>C. Sup C \\<le> \\<gamma> (Sup (\\<alpha> ` C))\n 2. \\<And>C. Sup (\\<alpha> ` C) \\<le> \\<alpha> (Sup C)", "apply (rule Sup_least)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>C x.\n       x \\<in> C \\<Longrightarrow> x \\<le> \\<gamma> (Sup (\\<alpha> ` C))\n 2. \\<And>C. Sup (\\<alpha> ` C) \\<le> \\<alpha> (Sup C)", "apply (subst galois)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>C x.\n       x \\<in> C \\<Longrightarrow> \\<alpha> x \\<le> Sup (\\<alpha> ` C)\n 2. \\<And>C. Sup (\\<alpha> ` C) \\<le> \\<alpha> (Sup C)", "apply (rule Sup_upper)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>C x. x \\<in> C \\<Longrightarrow> \\<alpha> x \\<in> \\<alpha> ` C\n 2. \\<And>C. Sup (\\<alpha> ` C) \\<le> \\<alpha> (Sup C)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>C. Sup (\\<alpha> ` C) \\<le> \\<alpha> (Sup C)", "apply (rule Sup_least)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>C x.\n       x \\<in> \\<alpha> ` C \\<Longrightarrow> x \\<le> \\<alpha> (Sup C)", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>C x xa.\n       xa \\<in> C \\<Longrightarrow> \\<alpha> xa \\<le> \\<alpha> (Sup C)", "apply (rule monoD[OF \\<alpha>_mono])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>C x xa. xa \\<in> C \\<Longrightarrow> xa \\<le> Sup C", "apply (rule Sup_upper)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>C x xa. xa \\<in> C \\<Longrightarrow> xa \\<in> C", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection \\<open>Maps\\<close>"], ["", "subsubsection \\<open>Key-Value Set\\<close>"], ["", "lemma map_to_set_simps[simp]: \n    \"map_to_set Map.empty = {}\"\n    \"map_to_set [a\\<mapsto>b] = {(a,b)}\"\n    \"map_to_set (m|`K) = map_to_set m \\<inter> K\\<times>UNIV\"\n    \"map_to_set (m(x:=None)) = map_to_set m - {x}\\<times>UNIV\"\n    \"map_to_set (m(x\\<mapsto>v)) = map_to_set m - {x}\\<times>UNIV \\<union> {(x,v)}\"\n    \"map_to_set m \\<inter> dom m\\<times>UNIV = map_to_set m\"\n    \"m k = Some v \\<Longrightarrow> (k,v)\\<in>map_to_set m\"\n    \"single_valued (map_to_set m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((map_to_set Map.empty = {} &&&\n      map_to_set [a \\<mapsto> b] = {(a, b)}) &&&\n     map_to_set (m |` K) = map_to_set m \\<inter> K \\<times> UNIV &&&\n     map_to_set (m(x := None)) = map_to_set m - {x} \\<times> UNIV) &&&\n    (map_to_set (m(x \\<mapsto> v)) =\n     map_to_set m - {x} \\<times> UNIV \\<union> {(x, v)} &&&\n     map_to_set m \\<inter> dom m \\<times> UNIV = map_to_set m) &&&\n    (m k = Some v \\<Longrightarrow> (k, v) \\<in> map_to_set m) &&&\n    single_valued (map_to_set m)", "apply (simp_all)"], ["proof (prove)\ngoal (6 subgoals):\n 1. map_to_set (m |` K) = map_to_set m \\<inter> K \\<times> UNIV\n 2. map_to_set (m(x := None)) = map_to_set m - {x} \\<times> UNIV\n 3. insert (x, v) (map_to_set m - {uu_. \\<exists>v'. uu_ = (x, v')}) =\n    insert (x, v) (map_to_set m - {x} \\<times> UNIV)\n 4. map_to_set m \\<inter> dom m \\<times> UNIV = map_to_set m\n 5. m k = Some v \\<Longrightarrow> (k, v) \\<in> map_to_set m\n 6. single_valued (map_to_set m)", "by (auto simp: map_to_set_def restrict_map_def split: if_split_asm\n      intro: single_valuedI)"], ["", "lemma map_to_set_inj:     \n    \"(k,v)\\<in>map_to_set m \\<Longrightarrow> (k,v')\\<in>map_to_set m \\<Longrightarrow> v = v'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(k, v) \\<in> map_to_set m; (k, v') \\<in> map_to_set m\\<rbrakk>\n    \\<Longrightarrow> v = v'", "by (auto simp: map_to_set_def)"], ["", "end"]]}