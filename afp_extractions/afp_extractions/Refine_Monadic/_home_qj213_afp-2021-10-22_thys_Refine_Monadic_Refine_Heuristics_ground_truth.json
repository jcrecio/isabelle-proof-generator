{"file_name": "/home/qj213/afp-2021-10-22/thys/Refine_Monadic/Refine_Heuristics.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Refine_Monadic", "problem_names": ["lemma RELATESI: \"RELATES R\"", "lemma RELATESI_memb[refine_dref_pattern]: \n  \"RELATES R \\<Longrightarrow> (a,b)\\<in>R \\<Longrightarrow> (a,b)\\<in>R\"", "lemma RELATESI_refspec[refine_dref_pattern]: \n  \"RELATES R \\<Longrightarrow> S \\<le>\\<Down>R S' \\<Longrightarrow> S \\<le>\\<Down>R S'\"", "lemma RELATES_pattern[refine_dref_pattern]: \"RELATES R \\<Longrightarrow> RELATES R\"", "lemmas [refine_hsimp] = RELATES_def", "lemma Id_RELATES [refine_dref_RELATES]: \"RELATES Id\"", "lemma prod_rel_RELATES[refine_dref_RELATES]: \n  \"RELATES Ra \\<Longrightarrow> RELATES Rb \\<Longrightarrow> RELATES (\\<langle>Ra,Rb\\<rangle>prod_rel)\"", "lemma prod_rel_iff[refine_hsimp]: \n  \"((a,b),(a',b'))\\<in>\\<langle>A,B\\<rangle>prod_rel \\<longleftrightarrow> (a,a')\\<in>A \\<and> (b,b')\\<in>B\"", "lemmas [refine_hsimp] = prod_rel_id_simp", "lemma option_rel_RELATES[refine_dref_RELATES]: \n  \"RELATES Ra \\<Longrightarrow> RELATES (\\<langle>Ra\\<rangle>option_rel)\"", "lemmas [refine_hsimp] = option_rel_id_simp", "lemmas [refine_hsimp] = set_rel_sv set_rel_csv", "lemma set_rel_RELATES[refine_dref_RELATES]: \n  \"RELATES R \\<Longrightarrow> RELATES (\\<langle>R\\<rangle>set_rel)\"", "lemma set_rel_empty_eq: \"(S,S')\\<in>\\<langle>X\\<rangle>set_rel \\<Longrightarrow> S={} \\<longleftrightarrow> S'={}\"", "lemma set_rel_sngD: \"({a},{b})\\<in>\\<langle>R\\<rangle>set_rel \\<Longrightarrow> (a,b)\\<in>R\"", "lemma Image_insert[refine_hsimp]: \n  \"(a,b)\\<in>R \\<Longrightarrow> single_valued R \\<Longrightarrow> R``insert a A = insert b (R``A)\"", "lemmas [refine_hsimp] = Image_Un", "lemma Image_Diff[refine_hsimp]:\n  \"single_valued (converse R) \\<Longrightarrow> R``(A-B) = R``A - R``B\"", "lemma Image_Inter[refine_hsimp]:\n  \"single_valued (converse R) \\<Longrightarrow> R``(A\\<inter>B) = R``A \\<inter> R``B\"", "lemma list_rel_RELATES[refine_dref_RELATES]: \n  \"RELATES R \\<Longrightarrow> RELATES (\\<langle>R\\<rangle>list_rel)\"", "lemmas [refine_hsimp] = list_rel_sv_iff list_rel_simp", "lemma RELATES_nres_rel[refine_dref_RELATES]: \"RELATES R \\<Longrightarrow> RELATES (\\<langle>R\\<rangle>nres_rel)\""], "translations": [["", "lemma RELATESI: \"RELATES R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RELATES R", "by (simp add: RELATES_def)"], ["", "ML \\<open>\nstructure Refine_dref_type = struct\n  structure pattern_rules = Named_Thms\n    ( val name = @{binding refine_dref_pattern}\n      val description = \"Refinement Framework: \" ^\n        \"Pattern rules to recognize refinement goal\" );\n\n  structure RELATES_rules = Named_Thms ( \n    val name = @{binding refine_dref_RELATES}\n    val description = \"Refinement Framework: \" ^\n        \"Type based heuristics introduction rules\" \n  );\n\n\n  val tracing = \n    Attrib.setup_config_bool @{binding refine_dref_tracing} (K false);\n\n  (* Check whether term contains schematic variable *)\n  fun \n    has_schematic (Var _) = true |\n    has_schematic (Abs (_,_,t)) = has_schematic t |\n    has_schematic (t1$t2) = has_schematic t1 orelse has_schematic t2 |\n    has_schematic _ = false;\n\n  (* Match proof states where the conclusion of some goal has the specified\n     shape *)\n  fun match_goal_shape_tac (shape:term->bool) (ctxt:Proof.context) i thm =\n    if Thm.nprems_of thm >= i then\n      let\n        val t = HOLogic.dest_Trueprop (Logic.concl_of_goal (Thm.prop_of thm) i);\n      in\n        (if shape t then all_tac thm else no_tac thm)\n      end\n    else\n      no_tac thm;\n\n  fun output_failed_msg ctxt failed_t = let\n    val failed_t_str = Pretty.string_of \n      (Syntax.pretty_term (Config.put show_types true ctxt) failed_t);\n    val msg = \"Failed to resolve refinement goal \\n  \" ^ failed_t_str;\n    val _ = if Config.get ctxt tracing then Output.tracing msg else ();\n    in () end;\n    \n  (* Try to apply patternI-rules, ensure that produced first subgoal\n     contains a schematic variable, and then solve it using \n     refine_dref_RELATES-rules. *)\n  fun type_tac ctxt =\n    ALL_GOALS_FWD (TRY o (\n      resolve_tac ctxt (pattern_rules.get ctxt) THEN'\n      match_goal_shape_tac has_schematic ctxt THEN'\n      (SOLVED' (REPEAT_ALL_NEW (resolve_tac ctxt (RELATES_rules.get ctxt)))\n        ORELSE' (fn i => fn st => let \n          val failed_t = \n            HOLogic.dest_Trueprop (Logic.concl_of_goal (Thm.prop_of st) i);\n          val _ = output_failed_msg ctxt failed_t;\n          in no_tac st end)\n      )\n    ));\n\n\nend;\n\\<close>"], ["", "setup \\<open>Refine_dref_type.RELATES_rules.setup\\<close>"], ["", "setup \\<open>Refine_dref_type.pattern_rules.setup\\<close>"], ["", "method_setup refine_dref_type = \n  \\<open>Scan.lift (Args.mode \"trace\" -- Args.mode \"nopost\") \n  >> (fn (tracing,nopost) => \n    fn ctxt => (let\n      val ctxt = \n        if tracing then Config.put Refine_dref_type.tracing true ctxt else ctxt; \n    in\n      SIMPLE_METHOD (CHANGED (\n        Refine_dref_type.type_tac ctxt \n        THEN (if nopost then all_tac else ALLGOALS (TRY o Refine.post_tac ctxt))))\n    end))\n\\<close> \n  \"Use type-based heuristics to instantiate data refinement relations\""], ["", "(*method_setup refine_dref_type_only = \n  {* Scan.succeed (fn ctxt => SIMPLE_METHOD (CHANGED (\n    Refine_dref_type.type_tac ctxt))) *} \n  \"Use type-based heuristics to instantiate data refinement relations. \n    No postprocessing.\"*)"], ["", "subsection \\<open>Patterns\\<close>"], ["", "text \\<open>\n  This section defines the patterns that are recognized as data refinement \n  goals.\n\\<close>"], ["", "lemma RELATESI_memb[refine_dref_pattern]: \n  \"RELATES R \\<Longrightarrow> (a,b)\\<in>R \\<Longrightarrow> (a,b)\\<in>R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>RELATES R; (a, b) \\<in> R\\<rbrakk>\n    \\<Longrightarrow> (a, b) \\<in> R", "."], ["", "lemma RELATESI_refspec[refine_dref_pattern]: \n  \"RELATES R \\<Longrightarrow> S \\<le>\\<Down>R S' \\<Longrightarrow> S \\<le>\\<Down>R S'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>RELATES R; S \\<le> \\<Down> R S'\\<rbrakk>\n    \\<Longrightarrow> S \\<le> \\<Down> R S'", "."], ["", "text \\<open>Allows refine-rules to add \\<open>RELATES\\<close> goals if they introduce hidden relations\\<close>"], ["", "lemma RELATES_pattern[refine_dref_pattern]: \"RELATES R \\<Longrightarrow> RELATES R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RELATES R \\<Longrightarrow> RELATES R", "."], ["", "lemmas [refine_hsimp] = RELATES_def"], ["", "subsection \\<open>Refinement Relations\\<close>"], ["", "text \\<open>\n  In this section, we define some general purpose refinement relations, e.g.,\n  for product types and sets.\n\\<close>"], ["", "lemma Id_RELATES [refine_dref_RELATES]: \"RELATES Id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RELATES Id", "by (simp add: RELATES_def)"], ["", "lemma prod_rel_RELATES[refine_dref_RELATES]: \n  \"RELATES Ra \\<Longrightarrow> RELATES Rb \\<Longrightarrow> RELATES (\\<langle>Ra,Rb\\<rangle>prod_rel)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>RELATES Ra; RELATES Rb\\<rbrakk>\n    \\<Longrightarrow> RELATES (Ra \\<times>\\<^sub>r Rb)", "by (simp add: RELATES_def prod_rel_def)"], ["", "declare prod_rel_sv[refine_hsimp]"], ["", "lemma prod_rel_iff[refine_hsimp]: \n  \"((a,b),(a',b'))\\<in>\\<langle>A,B\\<rangle>prod_rel \\<longleftrightarrow> (a,a')\\<in>A \\<and> (b,b')\\<in>B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (((a, b), a', b') \\<in> A \\<times>\\<^sub>r B) =\n    ((a, a') \\<in> A \\<and> (b, b') \\<in> B)", "by (auto simp: prod_rel_def)"], ["", "lemmas [refine_hsimp] = prod_rel_id_simp"], ["", "lemma option_rel_RELATES[refine_dref_RELATES]: \n  \"RELATES Ra \\<Longrightarrow> RELATES (\\<langle>Ra\\<rangle>option_rel)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RELATES Ra \\<Longrightarrow> RELATES (\\<langle>Ra\\<rangle>option_rel)", "by (simp add: RELATES_def option_rel_def)"], ["", "declare option_rel_sv[refine_hsimp]"], ["", "lemmas [refine_hsimp] = option_rel_id_simp"], ["", "lemmas [refine_hsimp] = set_rel_sv set_rel_csv"], ["", "lemma set_rel_RELATES[refine_dref_RELATES]: \n  \"RELATES R \\<Longrightarrow> RELATES (\\<langle>R\\<rangle>set_rel)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RELATES R \\<Longrightarrow> RELATES (\\<langle>R\\<rangle>set_rel)", "by (simp add: RELATES_def)"], ["", "lemma set_rel_empty_eq: \"(S,S')\\<in>\\<langle>X\\<rangle>set_rel \\<Longrightarrow> S={} \\<longleftrightarrow> S'={}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (S, S') \\<in> \\<langle>X\\<rangle>set_rel \\<Longrightarrow>\n    (S = {}) = (S' = {})", "by (auto simp: set_rel_def)"], ["", "lemma set_rel_sngD: \"({a},{b})\\<in>\\<langle>R\\<rangle>set_rel \\<Longrightarrow> (a,b)\\<in>R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ({a}, {b}) \\<in> \\<langle>R\\<rangle>set_rel \\<Longrightarrow>\n    (a, b) \\<in> R", "by (auto simp: set_rel_def)"], ["", "(*lemmas [refine_hsimp] = set_rel_empty set_rel_union set_rel_insert\n  set_rel_diff*)\n\n(*lemmas [refine_hsimp] = prod_set_eq_is_Id*)"], ["", "lemma Image_insert[refine_hsimp]: \n  \"(a,b)\\<in>R \\<Longrightarrow> single_valued R \\<Longrightarrow> R``insert a A = insert b (R``A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(a, b) \\<in> R; single_valued R\\<rbrakk>\n    \\<Longrightarrow> R `` insert a A = insert b (R `` A)", "by (auto dest: single_valuedD)"], ["", "lemmas [refine_hsimp] = Image_Un"], ["", "lemma Image_Diff[refine_hsimp]:\n  \"single_valued (converse R) \\<Longrightarrow> R``(A-B) = R``A - R``B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. single_valued (R\\<inverse>) \\<Longrightarrow>\n    R `` (A - B) = R `` A - R `` B", "by (auto dest: single_valuedD)"], ["", "lemma Image_Inter[refine_hsimp]:\n  \"single_valued (converse R) \\<Longrightarrow> R``(A\\<inter>B) = R``A \\<inter> R``B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. single_valued (R\\<inverse>) \\<Longrightarrow>\n    R `` (A \\<inter> B) = R `` A \\<inter> R `` B", "by (auto dest: single_valuedD)"], ["", "lemma list_rel_RELATES[refine_dref_RELATES]: \n  \"RELATES R \\<Longrightarrow> RELATES (\\<langle>R\\<rangle>list_rel)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RELATES R \\<Longrightarrow> RELATES (\\<langle>R\\<rangle>list_rel)", "by (simp add: RELATES_def)"], ["", "lemmas [refine_hsimp] = list_rel_sv_iff list_rel_simp"], ["", "lemma RELATES_nres_rel[refine_dref_RELATES]: \"RELATES R \\<Longrightarrow> RELATES (\\<langle>R\\<rangle>nres_rel)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RELATES R \\<Longrightarrow> RELATES (\\<langle>R\\<rangle>nres_rel)", "by (simp add: RELATES_def)"], ["", "end"]]}