{"file_name": "/home/qj213/afp-2021-10-22/thys/Prime_Number_Theorem/Prime_Number_Theorem_Library.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Prime_Number_Theorem", "problem_names": ["lemma asymp_equivD_strong:\n  assumes \"f \\<sim>[F] g\" \"eventually (\\<lambda>x. f x \\<noteq> 0 \\<or> g x \\<noteq> 0) F\"\n  shows   \"((\\<lambda>x. f x / g x) \\<longlongrightarrow> 1) F\"", "lemma frontier_real_Ici [simp]:\n  fixes a :: real\n  shows \"frontier {a..} = {a}\"", "lemma sum_upto_ln_conv_sum_upto_mangoldt:\n  \"sum_upto (\\<lambda>n. ln (real n)) x = sum_upto (\\<lambda>n. mangoldt n * nat \\<lfloor>x / real n\\<rfloor>) x\"", "lemma ln_fact_conv_sum_upto_mangoldt:\n  \"ln (fact n) = sum_upto (\\<lambda>k. mangoldt k * (n div k)) n\"", "lemma powr_sum: \"x \\<noteq> 0 \\<Longrightarrow> finite A \\<Longrightarrow> x powr sum f A = (\\<Prod>y\\<in>A. x powr f y)\"", "lemma fds_abs_converges_comparison_test:\n  fixes s :: \"'a :: dirichlet_series\"\n  assumes \"eventually (\\<lambda>n. norm (fds_nth f n) \\<le> fds_nth g n) at_top\" and \"fds_converges g (s \\<bullet> 1)\"\n  shows   \"fds_abs_converges f s\"", "lemma fds_converges_scaleR [intro]:\n  assumes \"fds_converges f s\"\n  shows   \"fds_converges (c *\\<^sub>R f) s\"", "lemma fds_abs_converges_scaleR [intro]:\n  assumes \"fds_abs_converges f s\"\n  shows   \"fds_abs_converges (c *\\<^sub>R f) s\"", "lemma conv_abscissa_scaleR: \"conv_abscissa (scaleR c f) \\<le> conv_abscissa f\"", "lemma abs_conv_abscissa_scaleR: \"abs_conv_abscissa (scaleR c f) \\<le> abs_conv_abscissa f\"", "lemma fds_converges_mult_const_left [intro]:\n  \"fds_converges f s \\<Longrightarrow> fds_converges (fds_const c * f) s\"", "lemma fds_abs_converges_mult_const_left [intro]:\n  \"fds_abs_converges f s \\<Longrightarrow> fds_abs_converges (fds_const c * f) s\"", "lemma conv_abscissa_mult_const_left:\n  \"conv_abscissa (fds_const c * f) \\<le> conv_abscissa f\"", "lemma abs_conv_abscissa_mult_const_left:\n  \"abs_conv_abscissa (fds_const c * f) \\<le> abs_conv_abscissa f\"", "lemma fds_converges_mult_const_right [intro]:\n  \"fds_converges f s \\<Longrightarrow> fds_converges (f * fds_const c) s\"", "lemma fds_abs_converges_mult_const_right [intro]:\n  \"fds_abs_converges f s \\<Longrightarrow> fds_abs_converges (f * fds_const c) s\"", "lemma conv_abscissa_mult_const_right:\n  \"conv_abscissa (f * fds_const c) \\<le> conv_abscissa f\"", "lemma abs_conv_abscissa_mult_const_right:\n  \"abs_conv_abscissa (f * fds_const c) \\<le> abs_conv_abscissa f\"", "lemma bounded_coeffs_imp_fds_abs_converges:\n  fixes s :: \"'a :: dirichlet_series\" and f :: \"'a fds\"\n  assumes \"Bseq (fds_nth f)\" \"s \\<bullet> 1 > 1\"\n  shows   \"fds_abs_converges f s\"", "lemma bounded_coeffs_imp_fds_abs_converges':\n  fixes s :: \"'a :: dirichlet_series\" and f :: \"'a fds\"\n  assumes \"Bseq (\\<lambda>n. fds_nth f n * nat_power n s0)\" \"s \\<bullet> 1 > 1 - s0 \\<bullet> 1\"\n  shows   \"fds_abs_converges f s\"", "lemma bounded_coeffs_imp_abs_conv_abscissa_le:\n  fixes s :: \"'a :: dirichlet_series\" and f :: \"'a fds\" and c :: ereal\n  assumes \"Bseq (\\<lambda>n. fds_nth f n * nat_power n s)\" \"1 - s \\<bullet> 1 \\<le> c\"\n  shows   \"abs_conv_abscissa f \\<le> c\"", "lemma bounded_coeffs_imp_abs_conv_abscissa_le_1:\n  fixes s :: \"'a :: dirichlet_series\" and f :: \"'a fds\"\n  assumes \"Bseq (\\<lambda>n. fds_nth f n)\"\n  shows   \"abs_conv_abscissa f \\<le> 1\"", "lemma\n  fixes a b c :: real\n  assumes ab: \"a + b > 0\" and c: \"c < -1\"\n  shows set_integrable_powr_at_top: \"(\\<lambda>x. (b + x) powr c) absolutely_integrable_on {a<..}\"\n  and   set_lebesgue_integral_powr_at_top:\n          \"(\\<integral>x\\<in>{a<..}. ((b + x) powr c) \\<partial>lborel) = -((b + a) powr (c + 1) / (c + 1))\"\n  and   powr_has_integral_at_top:\n          \"((\\<lambda>x. (b + x) powr c) has_integral -((b + a) powr (c + 1) / (c + 1))) {a<..}\"", "lemma fds_converges_altdef2:\n  \"fds_converges f s \\<longleftrightarrow> convergent (\\<lambda>N. eval_fds (fds_truncate N f) s)\"", "lemma tendsto_eval_fds_truncate:\n  assumes \"fds_converges f s\"\n  shows   \"(\\<lambda>N. eval_fds (fds_truncate N f) s) \\<longlonglongrightarrow> eval_fds f s\"", "lemma linepath_translate_left: \"linepath (c + a) (c + a) = (\\<lambda>x. c + a) \\<circ> linepath a b\"", "lemma linepath_translate_right: \"linepath (a + c) (b + c) = (\\<lambda>x. x + c) \\<circ> linepath a b\"", "lemma integrable_on_affinity:\n  assumes \"m \\<noteq> 0\" \"f integrable_on (cbox a b)\"\n  shows   \"(\\<lambda>x. f (m *\\<^sub>R x + c)) integrable_on ((\\<lambda>x. (1 / m) *\\<^sub>R x - ((1 / m) *\\<^sub>R c)) ` cbox a b)\"", "lemma has_integral_cmul_iff:\n  assumes \"c \\<noteq> 0\"\n  shows   \"((\\<lambda>x. c *\\<^sub>R f x) has_integral (c *\\<^sub>R I)) A \\<longleftrightarrow> (f has_integral I) A\"", "lemma has_integral_affinity':\n  fixes a :: \"'a::euclidean_space\"\n  assumes \"(f has_integral i) (cbox a b)\" and \"m > 0\"\n  shows \"((\\<lambda>x. f(m *\\<^sub>R x + c)) has_integral (i /\\<^sub>R m ^ DIM('a)))\n           (cbox ((a - c) /\\<^sub>R m) ((b - c) /\\<^sub>R m))\"", "lemma has_integral_affinity_iff:\n  fixes f :: \"'a :: euclidean_space \\<Rightarrow> 'b :: real_normed_vector\"\n  assumes \"m > 0\"\n  shows   \"((\\<lambda>x. f (m *\\<^sub>R x + c)) has_integral (I /\\<^sub>R m ^ DIM('a)))\n               (cbox ((a - c) /\\<^sub>R m) ((b - c) /\\<^sub>R m)) \\<longleftrightarrow>\n           (f has_integral I) (cbox a b)\" (is \"?lhs = ?rhs\")", "lemma has_contour_integral_linepath_Reals_iff:\n  fixes a b :: complex and f :: \"complex \\<Rightarrow> complex\"\n  assumes \"a \\<in> Reals\" \"b \\<in> Reals\" \"Re a < Re b\"\n  shows   \"(f has_contour_integral I) (linepath a b) \\<longleftrightarrow>\n             ((\\<lambda>x. f (of_real x)) has_integral I) {Re a..Re b}\"", "lemma contour_integrable_linepath_Reals_iff:\n  fixes a b :: complex and f :: \"complex \\<Rightarrow> complex\"\n  assumes \"a \\<in> Reals\" \"b \\<in> Reals\" \"Re a < Re b\"\n  shows   \"(f contour_integrable_on linepath a b) \\<longleftrightarrow>\n             (\\<lambda>x. f (of_real x)) integrable_on {Re a..Re b}\"", "lemma contour_integral_linepath_Reals_eq:\n  fixes a b :: complex and f :: \"complex \\<Rightarrow> complex\"\n  assumes \"a \\<in> Reals\" \"b \\<in> Reals\" \"Re a < Re b\"\n  shows   \"contour_integral (linepath a b) f = integral {Re a..Re b} (\\<lambda>x. f (of_real x))\"", "lemma has_contour_integral_linepath_same_Im_iff:\n  fixes a b :: complex and f :: \"complex \\<Rightarrow> complex\"\n  assumes \"Im a = Im b\" \"Re a < Re b\"\n  shows   \"(f has_contour_integral I) (linepath a b) \\<longleftrightarrow>\n             ((\\<lambda>x. f (of_real x + Im a * \\<i>)) has_integral I) {Re a..Re b}\"", "lemma contour_integrable_linepath_same_Im_iff:\n  fixes a b :: complex and f :: \"complex \\<Rightarrow> complex\"\n  assumes \"Im a = Im b\" \"Re a < Re b\"\n  shows   \"(f contour_integrable_on linepath a b) \\<longleftrightarrow>\n             (\\<lambda>x. f (of_real x + Im a * \\<i>)) integrable_on {Re a..Re b}\"", "lemma contour_integral_linepath_same_Im:\n  fixes a b :: complex and f :: \"complex \\<Rightarrow> complex\"\n  assumes \"Im a = Im b\" \"Re a < Re b\"\n  shows   \"contour_integral (linepath a b) f = integral {Re a..Re b} (\\<lambda>x. f (x + Im a * \\<i>))\"", "lemmas [simp del] = div_mult_self3 div_mult_self4 div_mult_self2 div_mult_self1", "lemma continuous_on_compact_bound:\n  assumes \"compact A\" \"continuous_on A f\"\n  obtains B where \"B \\<ge> 0\" \"\\<And>x. x \\<in> A \\<Longrightarrow> norm (f x) \\<le> B\"", "lemma open_contains_cbox:\n  fixes x :: \"'a :: euclidean_space\"\n  assumes \"open A\" \"x \\<in> A\"\n  obtains a b where \"cbox a b \\<subseteq> A\" \"x \\<in> box a b\" \"\\<forall>i\\<in>Basis. a \\<bullet> i < b \\<bullet> i\"", "lemma open_contains_box:\n  fixes x :: \"'a :: euclidean_space\"\n  assumes \"open A\" \"x \\<in> A\"\n  obtains a b where \"box a b \\<subseteq> A\" \"x \\<in> box a b\" \"\\<forall>i\\<in>Basis. a \\<bullet> i < b \\<bullet> i\"", "lemma analytic_onE_box:\n  assumes \"f analytic_on A\" \"s \\<in> A\"\n  obtains a b where \"Re a < Re b\" \"Im a < Im b\" \"s \\<in> box a b\" \"f analytic_on box a b\"", "lemma inner_image_box:\n  assumes \"(i :: 'a :: euclidean_space) \\<in> Basis\"\n  assumes \"\\<forall>i\\<in>Basis. a \\<bullet> i < b \\<bullet> i\"\n  shows   \"(\\<lambda>x. x \\<bullet> i) ` box a b = {a \\<bullet> i<..<b \\<bullet> i}\"", "lemma Re_image_box:\n  assumes \"Re a < Re b\" \"Im a < Im b\"\n  shows   \"Re ` box a b = {Re a<..<Re b}\"", "lemma Im_image_box:\n  assumes \"Re a < Re b\" \"Im a < Im b\"\n  shows   \"Im ` box a b = {Im a<..<Im b}\"", "lemma inner_image_cbox:\n  assumes \"(i :: 'a :: euclidean_space) \\<in> Basis\"\n  assumes \"\\<forall>i\\<in>Basis. a \\<bullet> i \\<le> b \\<bullet> i\"\n  shows   \"(\\<lambda>x. x \\<bullet> i) ` cbox a b = {a \\<bullet> i..b \\<bullet> i}\"", "lemma Re_image_cbox:\n  assumes \"Re a \\<le> Re b\" \"Im a \\<le> Im b\"\n  shows   \"Re ` cbox a b = {Re a..Re b}\"", "lemma Im_image_cbox:\n  assumes \"Re a \\<le> Re b\" \"Im a \\<le> Im b\"\n  shows   \"Im ` cbox a b = {Im a..Im b}\"", "lemma analytic_onE_cball:\n  assumes \"f analytic_on A\" \"s \\<in> A\" \"ub > (0::real)\"\n  obtains R where \"R > 0\" \"R < ub\" \"f analytic_on cball s R\"", "lemma logderiv_zeta_analytic: \"(\\<lambda>s. deriv zeta s / zeta s) analytic_on {s. Re s \\<ge> 1} - {1}\"", "lemma cis_pi_half [simp]: \"cis (pi / 2) = \\<i>\"", "lemma mult_real_sqrt: \"x \\<ge> 0 \\<Longrightarrow> x * sqrt y = sqrt (x ^ 2 * y)\"", "lemma arcsin_pos: \"x \\<in> {0<..1} \\<Longrightarrow> arcsin x > 0\"", "lemmas analytic_imp_holomorphic' = holomorphic_on_subset[OF analytic_imp_holomorphic]", "lemma residue_simple':\n  assumes \"open s\" \"0 \\<in> s\" \"f holomorphic_on s\"\n  shows   \"residue (\\<lambda>w. f w / w) 0 = f 0\"", "lemma fds_converges_cong:\n  assumes \"eventually (\\<lambda>n. fds_nth f n = fds_nth g n) at_top\" \"s = s'\"\n  shows   \"fds_converges f s \\<longleftrightarrow> fds_converges g s'\"", "lemma fds_abs_converges_cong:\n  assumes \"eventually (\\<lambda>n. fds_nth f n = fds_nth g n) at_top\" \"s = s'\"\n  shows   \"fds_abs_converges f s \\<longleftrightarrow> fds_abs_converges g s'\"", "lemma conv_abscissa_cong:\n  assumes \"eventually (\\<lambda>n. fds_nth f n = fds_nth g n) at_top\"\n  shows   \"conv_abscissa f = conv_abscissa g\"", "lemma abs_conv_abscissa_cong:\n  assumes \"eventually (\\<lambda>n. fds_nth f n = fds_nth g n) at_top\"\n  shows   \"abs_conv_abscissa f = abs_conv_abscissa g\"", "lemma fds_nth_remainder: \"fds_nth (fds_remainder m f) = (\\<lambda>n. if n > m then fds_nth f n else 0)\"", "lemma fds_converges_remainder_iff [simp]:\n  \"fds_converges (fds_remainder m f) s \\<longleftrightarrow> fds_converges f s\"", "lemma fds_abs_converges_remainder_iff [simp]:\n  \"fds_abs_converges (fds_remainder m f) s \\<longleftrightarrow> fds_abs_converges f s\"", "lemma fds_converges_remainder [intro]:\n        \"fds_converges f s \\<Longrightarrow> fds_converges (fds_remainder m f) s\"\n  and fds_abs_converges_remainder [intro]:\n        \"fds_abs_converges f s \\<Longrightarrow> fds_abs_converges (fds_remainder m f) s\"", "lemma conv_abscissa_remainder [simp]:\n  \"conv_abscissa (fds_remainder m f) = conv_abscissa f\"", "lemma abs_conv_abscissa_remainder [simp]:\n  \"abs_conv_abscissa (fds_remainder m f) = abs_conv_abscissa f\"", "lemma eval_fds_remainder:\n   \"eval_fds (fds_remainder m f) s = (\\<Sum>n. fds_nth f (n + Suc m) / nat_power (n + Suc m) s)\"\n    (is \"_ = suminf (\\<lambda>n. ?f (n + Suc m))\")", "lemma fds_truncate_plus_remainder: \"fds_truncate m f + fds_remainder m f = f\"", "lemma holomorphic_fds_eval' [holomorphic_intros]:\n  assumes \"g holomorphic_on A\" \"\\<And>x. x \\<in> A \\<Longrightarrow> Re (g x) > conv_abscissa f\"\n  shows   \"(\\<lambda>x. eval_fds f (g x)) holomorphic_on A\"", "lemma analytic_fds_eval' [analytic_intros]:\n  assumes \"g analytic_on A\" \"\\<And>x. x \\<in> A \\<Longrightarrow> Re (g x) > conv_abscissa f\"\n  shows   \"(\\<lambda>x. eval_fds f (g x)) analytic_on A\"", "lemma homotopic_loopsI:\n  fixes h :: \"real \\<times> real \\<Rightarrow> _\"\n  assumes \"continuous_on ({0..1} \\<times> {0..1}) h\"\n          \"h ` ({0..1} \\<times> {0..1}) \\<subseteq> s\"\n          \"\\<And>x. x \\<in> {0..1} \\<Longrightarrow> h (0, x) = p x\"\n          \"\\<And>x. x \\<in> {0..1} \\<Longrightarrow> h (1, x) = q x\"\n          \"\\<And>x. x \\<in> {0..1} \\<Longrightarrow> pathfinish (h \\<circ> Pair x) = pathstart (h \\<circ> Pair x)\"\n  shows   \"homotopic_loops s p q\"", "lemma continuous_on_linepath [continuous_intros]:\n  assumes \"continuous_on A a\" \"continuous_on A b\" \"continuous_on A f\"\n  shows   \"continuous_on A (\\<lambda>x. linepath (a x) (b x) (f x))\"", "lemma continuous_on_part_circlepath [continuous_intros]:\n  assumes \"continuous_on A c\" \"continuous_on A r\" \"continuous_on A a\" \"continuous_on A b\"\n          \"continuous_on A f\"\n  shows   \"continuous_on A (\\<lambda>x. part_circlepath (c x) (r x) (a x) (b x) (f x))\"", "lemma homotopic_loops_part_circlepath:\n  assumes \"sphere c r \\<subseteq> A\" and \"r \\<ge> 0\" and\n          \"b1 = a1 + 2 * of_int k * pi\" and \"b2 = a2 + 2 * of_int k * pi\"\n  shows   \"homotopic_loops A (part_circlepath c r a1 b1) (part_circlepath c r a2 b2)\"", "lemma homotopic_pathsI:\n  fixes h :: \"real \\<times> real \\<Rightarrow> _\"\n  assumes \"continuous_on ({0..1} \\<times> {0..1}) h\"\n  assumes \"h ` ({0..1} \\<times> {0..1}) \\<subseteq> s\"\n  assumes \"\\<And>x. x \\<in> {0..1} \\<Longrightarrow> h (0, x) = p x\"\n  assumes \"\\<And>x. x \\<in> {0..1} \\<Longrightarrow> h (1, x) = q x\"\n  assumes \"\\<And>x. x \\<in> {0..1} \\<Longrightarrow> pathstart (h \\<circ> Pair x) = pathstart p\"\n  assumes \"\\<And>x. x \\<in> {0..1} \\<Longrightarrow> pathfinish (h \\<circ> Pair x) = pathfinish p\"\n  shows   \"homotopic_paths s p q\"", "lemma part_circlepath_conv_subpath:\n  \"part_circlepath c r a b = subpath (a / (2*pi)) (b / (2*pi)) (circlepath c r)\"", "lemma homotopic_paths_part_circlepath:\n  assumes \"a \\<le> b\" \"b \\<le> c\"\n  assumes \"path_image (part_circlepath C r a c) \\<subseteq> A\" \"r \\<ge> 0\"\n  shows   \"homotopic_paths A (part_circlepath C r a c)\n             (part_circlepath C r a b +++ part_circlepath C r b c)\"\n  (is \"homotopic_paths _ ?g (?h1 +++ ?h2)\")", "lemma has_contour_integral_mirror_iff:\n  assumes \"valid_path g\"\n  shows   \"(f has_contour_integral I) (-g) \\<longleftrightarrow> ((\\<lambda>x. -f (- x)) has_contour_integral I) g\"", "lemma contour_integral_on_mirror_iff:\n  assumes \"valid_path g\"\n  shows   \"f contour_integrable_on (-g) \\<longleftrightarrow> (\\<lambda>x. -f (- x)) contour_integrable_on g\"", "lemma contour_integral_mirror:\n  assumes \"valid_path g\"\n  shows   \"contour_integral (-g) f = contour_integral g (\\<lambda>x. -f (- x))\"", "lemma contour_integrable_neg_iff:\n  \"(\\<lambda>x. -f x) contour_integrable_on g \\<longleftrightarrow> f contour_integrable_on g\"", "lemma contour_integral_neg:\n  shows \"contour_integral g (\\<lambda>x. -f x) = -contour_integral g f\"", "lemma minus_cis: \"-cis x = cis (x + pi)\"", "lemma path_image_part_circlepath_subset:\n  assumes \"a \\<le> a'\" \"a' \\<le> b'\" \"b' \\<le> b\"\n  shows   \"path_image (part_circlepath c r a' b') \\<subseteq> path_image (part_circlepath c r a b)\"", "lemma part_circlepath_mirror:\n  assumes \"a' = a + pi + 2 * pi * of_int k\" \"b' = b + pi + 2 * pi * of_int k\" \"c' = -c\"\n  shows   \"-part_circlepath c r a b = part_circlepath c' r a' b'\"", "lemma path_mirror [intro]: \"path (g :: _ \\<Rightarrow> 'b::topological_group_add) \\<Longrightarrow> path (-g)\"", "lemma path_mirror_iff [simp]: \"path (-g :: _ \\<Rightarrow> 'b::topological_group_add) \\<longleftrightarrow> path g\"", "lemma valid_path_mirror [intro]: \"valid_path g \\<Longrightarrow> valid_path (-g)\"", "lemma valid_path_mirror_iff [simp]: \"valid_path (-g) \\<longleftrightarrow> valid_path g\"", "lemma pathstart_mirror [simp]: \"pathstart (-g) = -pathstart g\"\n  and pathfinish_mirror [simp]: \"pathfinish (-g) = -pathfinish g\"", "lemma path_image_mirror: \"path_image (-g) = uminus ` path_image g\"", "lemma contour_integral_bound_part_circlepath:\n  assumes \"f contour_integrable_on part_circlepath c r a b\"\n  assumes \"B \\<ge> 0\" \"r \\<ge> 0\" \"\\<And>x. x \\<in> path_image (part_circlepath c r a b) \\<Longrightarrow> norm (f x) \\<le> B\"\n  shows   \"norm (contour_integral (part_circlepath c r a b) f) \\<le> B * r * \\<bar>b - a\\<bar>\"", "lemma contour_integral_spike_finite_simple_path:\n  assumes \"finite A\" \"simple_path g\" \"g = g'\" \"\\<And>x. x \\<in> path_image g - A \\<Longrightarrow> f x = f' x\"\n  shows   \"contour_integral g f = contour_integral g' f'\"", "lemma cos_le_zero:\n  assumes \"x \\<in> {pi/2..3*pi/2}\"\n  shows   \"cos x \\<le> 0\"", "lemma cos_le_zero': \"x \\<in> {-3*pi/2..-pi/2} \\<Longrightarrow> cos x \\<le> 0\"", "lemma cis_minus_pi_half [simp]: \"cis (- (pi / 2)) = -\\<i>\"", "lemma winding_number_join_pos_combined':\n     \"\\<lbrakk>valid_path \\<gamma>1 \\<and> z \\<notin> path_image \\<gamma>1 \\<and> 0 < Re (winding_number \\<gamma>1 z);\n       valid_path \\<gamma>2 \\<and> z \\<notin> path_image \\<gamma>2 \\<and> 0 < Re (winding_number \\<gamma>2 z);\n       pathfinish \\<gamma>1 = pathstart \\<gamma>2\\<rbrakk>\n      \\<Longrightarrow> valid_path(\\<gamma>1 +++ \\<gamma>2) \\<and> z \\<notin> path_image(\\<gamma>1 +++ \\<gamma>2) \\<and> 0 < Re(winding_number(\\<gamma>1 +++ \\<gamma>2) z)\"", "lemma Union_atLeastAtMost_real_of_nat:\n  assumes \"a < b\"\n  shows   \"(\\<Union>n\\<in>{a..<b}. {real n..real (n + 1)}) = {real a..real b}\"", "lemma nat_sum_has_integral_floor:\n  fixes f :: \"nat \\<Rightarrow> 'a :: banach\"\n  assumes mn: \"m < n\"\n  shows \"((\\<lambda>x. f (nat \\<lfloor>x\\<rfloor>)) has_integral sum f {m..<n}) {real m..real n}\"", "lemma nat_sum_has_integral_ceiling:\n  fixes f :: \"nat \\<Rightarrow> 'a :: banach\"\n  assumes mn: \"m < n\"\n  shows \"((\\<lambda>x. f (nat \\<lceil>x\\<rceil>)) has_integral sum f {m<..n}) {real m..real n}\"", "lemma zeta_partial_sum_le:\n  fixes x :: real and m :: nat\n  assumes x: \"x \\<in> {0<..1}\"\n  shows \"(\\<Sum>k=1..m. real k powr (x - 1)) \\<le> real m powr x / x\"", "lemma zeta_partial_sum_le':\n  fixes x :: real and m :: nat\n  assumes x: \"x > 0\" and m: \"m > 0\"\n  shows   \"(\\<Sum>n=1..m. real n powr (x - 1)) \\<le> m powr x * (1 / x + 1 / m)\"", "lemma natfun_bigo_1E:\n  assumes \"(f :: nat \\<Rightarrow> _) \\<in> O(\\<lambda>_. 1)\"\n  obtains C where \"C \\<ge> lb\" \"\\<And>n. norm (f n) \\<le> C\"", "lemma natfun_bigo_iff_Bseq: \"f \\<in> O(\\<lambda>_. 1) \\<longleftrightarrow> Bseq f\"", "lemma enn_decreasing_sum_le_set_nn_integral:\n  fixes f :: \"real \\<Rightarrow> ennreal\"\n  assumes decreasing: \"\\<And>x y. 0 \\<le> x \\<Longrightarrow> x \\<le> y \\<Longrightarrow> f y \\<le> f x\"\n  shows \"(\\<Sum>n. f (real (Suc n))) \\<le> set_nn_integral lborel {0..} f\"", "lemma nn_integral_has_integral_lebesgue:\n  fixes f :: \"'a::euclidean_space \\<Rightarrow> real\"\n  assumes nonneg: \"\\<And>x. x \\<in> \\<Omega> \\<Longrightarrow> 0 \\<le> f x\" and I: \"(f has_integral I) \\<Omega>\"\n  shows \"integral\\<^sup>N lborel (\\<lambda>x. indicator \\<Omega> x * f x) = I\"", "lemma decreasing_sum_le_integral:\n  fixes f :: \"real \\<Rightarrow> real\"\n  assumes nonneg: \"\\<And>x. x \\<ge> 0 \\<Longrightarrow> f x \\<ge> 0\"\n  assumes decreasing: \"\\<And>x y. 0 \\<le> x \\<Longrightarrow> x \\<le> y \\<Longrightarrow> f y \\<le> f x\"\n  assumes integral: \"(f has_integral I) {0..}\"\n  shows   \"summable (\\<lambda>i. f (real (Suc i)))\" and \"suminf (\\<lambda>i. f (real (Suc i))) \\<le> I\"", "lemma decreasing_sum_le_integral':\n  fixes f :: \"real \\<Rightarrow> real\"\n  assumes \"\\<And>x. x \\<ge> 0 \\<Longrightarrow> f x \\<ge> 0\"\n  assumes \"\\<And>x y. 0 \\<le> x \\<Longrightarrow> x \\<le> y \\<Longrightarrow> f y \\<le> f x\"\n  assumes \"(f has_integral I) {0..}\"\n  shows   \"summable (\\<lambda>i. f (real i))\" and \"suminf (\\<lambda>i. f (real i)) \\<le> f 0 + I\"", "lemma norm_suminf_le:\n  assumes \"\\<And>n. norm (f n :: 'a :: banach) \\<le> g n\" \"summable g\"\n  shows   \"norm (suminf f) \\<le> suminf g\"", "lemma of_nat_powr_neq_1_complex [simp]:\n  assumes \"n > 1\" \"Re s \\<noteq> 0\"\n  shows   \"of_nat n powr s \\<noteq> (1::complex)\"", "lemma abs_summable_on_uminus_iff:\n  \"(\\<lambda>x. -f x) abs_summable_on A \\<longleftrightarrow> f abs_summable_on A\"", "lemma abs_summable_on_cmult_right_iff:\n  fixes f :: \"'a \\<Rightarrow> 'b :: {banach, real_normed_field, second_countable_topology}\"\n  assumes \"c \\<noteq> 0\"\n  shows   \"(\\<lambda>x. c * f x) abs_summable_on A \\<longleftrightarrow> f abs_summable_on A\"", "lemma abs_summable_on_cmult_left_iff:\n  fixes f :: \"'a \\<Rightarrow> 'b :: {banach, real_normed_field, second_countable_topology}\"\n  assumes \"c \\<noteq> 0\"\n  shows   \"(\\<lambda>x. f x * c) abs_summable_on A \\<longleftrightarrow> f abs_summable_on A\"", "lemma fds_logderiv_completely_multiplicative:\n  fixes f :: \"'a :: {real_normed_field} fds\"\n  assumes \"completely_multiplicative_function (fds_nth f)\" \"fds_nth f 1 \\<noteq> 0\"\n  shows   \"fds_deriv f / f = - fds (\\<lambda>n. fds_nth f n * mangoldt n)\"", "lemma fds_nth_logderiv_completely_multiplicative:\n  fixes f :: \"'a :: {real_normed_field} fds\"\n  assumes \"completely_multiplicative_function (fds_nth f)\" \"fds_nth f 1 \\<noteq> 0\"\n  shows   \"fds_nth (fds_deriv f / f) n = -fds_nth f n * mangoldt n\"", "lemma eval_fds_logderiv_completely_multiplicative:\n  fixes s :: \"'a :: dirichlet_series\" and l :: 'a and f :: \"'a fds\"\n  defines \"h \\<equiv> fds_deriv f / f\"\n  assumes \"completely_multiplicative_function (fds_nth f)\" and [simp]: \"fds_nth f 1 \\<noteq> 0\"\n  assumes \"s \\<bullet> 1 > abs_conv_abscissa f\"\n  shows  \"(\\<lambda>p. of_real (ln (real p)) * (1 / (1 - fds_nth f p / nat_power p s) - 1))\n            abs_summable_on {p. prime p}\" (is ?th1)\n    and  \"eval_fds h s = -(\\<Sum>\\<^sub>ap | prime p. of_real (ln (real p)) *\n                            (1 / (1 - fds_nth f p / nat_power p s) - 1))\" (is ?th2)", "lemma eval_fds_logderiv_zeta:\n  assumes \"Re s > 1\"\n  shows  \"(\\<lambda>p. of_real (ln (real p)) / (p powr s - 1))\n            abs_summable_on {p. prime p}\" (is ?th1)\n    and  \"deriv zeta s / zeta s =\n            -(\\<Sum>\\<^sub>ap | prime p. of_real (ln (real p)) / (p powr s - 1))\" (is ?th2)", "lemma sums_logderiv_zeta:\n  assumes \"Re s > 1\"\n  shows   \"(\\<lambda>p. if prime p then of_real (ln (real p)) / (of_nat p powr s - 1) else 0) sums\n             -(deriv zeta s / zeta s)\" (is \"?f sums _\")", "lemma abs_conv_abscissa_diff_le:\n  \"abs_conv_abscissa (f - g :: 'a :: dirichlet_series fds) \\<le>\n     max (abs_conv_abscissa f) (abs_conv_abscissa g)\"", "lemma abs_conv_abscissa_diff_leI:\n  \"abs_conv_abscissa (f :: 'a :: dirichlet_series fds) \\<le> d \\<Longrightarrow> abs_conv_abscissa g \\<le> d \\<Longrightarrow>\n     abs_conv_abscissa (f - g) \\<le> d\"", "lemma range_add_nat: \"range (\\<lambda>n. n + c) = {(c::nat)..}\"", "lemma abs_summable_hurwitz_zeta:\n  assumes \"Re s > 1\" \"a + real b > 0\"\n  shows   \"(\\<lambda>n. 1 / (of_nat n + a) powr s) abs_summable_on {b..}\"", "lemma hurwitz_zeta_nat_conv_infsetsum:\n  assumes \"a > 0\" and \"Re s > 1\"\n  shows   \"hurwitz_zeta (real a) s = (\\<Sum>\\<^sub>an. of_nat (n + a) powr -s)\"\n          \"hurwitz_zeta (real a) s = (\\<Sum>\\<^sub>an\\<in>{a..}. of_nat n powr -s)\"", "lemma continuous_on_pre_zeta [continuous_intros]:\n  assumes \"continuous_on A f\" \"a > 0\"\n  shows   \"continuous_on A (\\<lambda>x. pre_zeta a (f x))\"", "lemma continuous_pre_zeta [continuous_intros]:\n  assumes \"continuous (at x within A) f\" \"a > 0\"\n  shows   \"continuous (at x within A) (\\<lambda>x. pre_zeta a (f x))\"", "lemma pre_zeta_bound:\n  assumes \"0 < Re s\" and a: \"a > 0\"\n  shows   \"norm (pre_zeta a s) \\<le> (1 + norm s / Re s) / 2 * a powr -Re s\"", "lemma pre_zeta_bound':\n  assumes \"0 < Re s\" and a: \"a > 0\"\n  shows   \"norm (pre_zeta a s) \\<le> norm s / (Re s * a powr Re s)\"", "lemma summable_comparison_test_bigo:\n  fixes f :: \"nat \\<Rightarrow> real\"\n  assumes \"summable (\\<lambda>n. norm (g n))\" \"f \\<in> O(g)\"\n  shows   \"summable f\"", "lemma deriv_zeta_eq:\n  assumes s: \"s \\<noteq> 1\"\n  shows   \"deriv zeta s = deriv (pre_zeta 1) s - 1 / (s - 1)\\<^sup>2\"", "lemma zeta_remove_zero:\n  assumes \"Re s \\<ge> 1\"\n  shows   \"(s - 1) * pre_zeta 1 s + 1 \\<noteq> 0\"", "lemma eval_fds_deriv_zeta:\n  assumes \"Re s > 1\"\n  shows   \"eval_fds (fds_deriv fds_zeta) s = deriv zeta s\"", "lemma length_sorted_list_of_set [simp]:\n  \"finite A \\<Longrightarrow> length (sorted_list_of_set A) = card A\"", "lemma le_nat_iff': \"x \\<le> nat y \\<longleftrightarrow> x = 0 \\<and> y \\<le> 0 \\<or> int x \\<le> y\"", "lemma sum_upto_plus1:\n  assumes \"x \\<ge> 0\"\n  shows   \"sum_upto f (x + 1) = sum_upto f x + f (Suc (nat \\<lfloor>x\\<rfloor>))\"", "lemma sum_upto_minus1:\n  assumes \"x \\<ge> 1\"\n  shows   \"sum_upto f (x - 1) = (sum_upto f x - f (nat \\<lfloor>x\\<rfloor>) :: 'a :: ab_group_add)\"", "lemma integral_smallo:\n  fixes f g g' :: \"real \\<Rightarrow> real\"\n  assumes \"f \\<in> o(g')\" and \"filterlim g at_top at_top\"\n  assumes \"\\<And>a' x. a \\<le> a' \\<Longrightarrow> a' \\<le> x \\<Longrightarrow> f integrable_on {a'..x}\"\n  assumes deriv: \"\\<And>x. x \\<ge> a \\<Longrightarrow> (g has_field_derivative g' x) (at x)\"\n  assumes cont: \"continuous_on {a..} g'\"\n  assumes nonneg: \"\\<And>x. x \\<ge> a \\<Longrightarrow> g' x \\<ge> 0\"\n  shows   \"(\\<lambda>x. integral {a..x} f) \\<in> o(g)\"", "lemma integral_bigo:\n  fixes f g g' :: \"real \\<Rightarrow> real\"\n  assumes \"f \\<in> O(g')\" and \"filterlim g at_top at_top\"\n  assumes \"\\<And>a' x. a \\<le> a' \\<Longrightarrow> a' \\<le> x \\<Longrightarrow> f integrable_on {a'..x}\"\n  assumes deriv: \"\\<And>x. x \\<ge> a \\<Longrightarrow> (g has_field_derivative g' x) (at x within {a..})\"\n  assumes cont: \"continuous_on {a..} g'\"\n  assumes nonneg: \"\\<And>x. x \\<ge> a \\<Longrightarrow> g' x \\<ge> 0\"\n  shows   \"(\\<lambda>x. integral {a..x} f) \\<in> O(g)\"", "lemma primepows_le_subset:\n  assumes x: \"x > 0\" and l: \"l > 0\"\n  shows   \"{(p, i). prime p \\<and> l \\<le> i \\<and> real (p ^ i) \\<le> x} \\<subseteq> {..nat \\<lfloor>root l x\\<rfloor>} \\<times> {..nat \\<lfloor>log 2 x\\<rfloor>}\"", "lemma mangoldt_non_primepow: \"\\<not>primepow n \\<Longrightarrow> mangoldt n = 0\"", "lemma le_imp_bigo_real:\n  assumes \"c \\<ge> 0\" \"eventually (\\<lambda>x. f x \\<le> c * (g x :: real)) F\" \"eventually (\\<lambda>x. 0 \\<le> f x) F\"\n  shows   \"f \\<in> O[F](g)\"", "lemma ln_minus_ln_floor_bigo: \"(\\<lambda>x. ln x - ln (real (nat \\<lfloor>x\\<rfloor>))) \\<in> O(\\<lambda>_. 1)\"", "lemma cos_geD:\n  assumes \"cos x \\<ge> cos a\" \"0 \\<le> a\" \"a \\<le> pi\" \"-pi \\<le> x\" \"x \\<le> pi\"\n  shows   \"x \\<in> {-a..a}\"", "lemma path_image_part_circlepath_same_Re:\n  assumes \"0 \\<le> b\" \"b \\<le> pi\" \"a = -b\" \"r \\<ge> 0\"\n  shows   \"path_image (part_circlepath c r a b) = sphere c r \\<inter> {s. Re s \\<ge> Re c + r * cos a}\"", "lemma part_circlepath_rotate_left:\n  \"part_circlepath c r (x + a) (x + b) = (\\<lambda>z. c + cis x * (z - c)) \\<circ> part_circlepath c r a b\"", "lemma part_circlepath_rotate_right:\n  \"part_circlepath c r (a + x) (b + x) = (\\<lambda>z. c + cis x * (z - c)) \\<circ> part_circlepath c r a b\"", "lemma path_image_semicircle_Re_ge:\n  assumes \"r \\<ge> 0\"\n  shows   \"path_image (part_circlepath c r (-pi/2) (pi/2)) =\n             sphere c r \\<inter> {s. Re s \\<ge> Re c}\"", "lemma sphere_rotate: \"(\\<lambda>z. c + cis x * (z - c)) ` sphere c r = sphere c r\"", "lemma path_image_semicircle_Re_le:\n  assumes \"r \\<ge> 0\"\n  shows   \"path_image (part_circlepath c r (pi/2) (3/2*pi)) =\n             sphere c r \\<inter> {s. Re s \\<le> Re c}\"", "lemma path_image_semicircle_Im_ge:\n  assumes \"r \\<ge> 0\"\n  shows   \"path_image (part_circlepath c r 0 pi) =\n             sphere c r \\<inter> {s. Im s \\<ge> Im c}\"", "lemma path_image_semicircle_Im_le:\n  assumes \"r \\<ge> 0\"\n  shows   \"path_image (part_circlepath c r pi (2 * pi)) =\n             sphere c r \\<inter> {s. Im s \\<le> Im c}\"", "lemma powr_numeral [simp]: \"x \\<ge> 0 \\<Longrightarrow> (x::real) powr numeral y = x ^ numeral y\"", "lemma eval_fds_logderiv_zeta_real:\n  assumes \"x > (1 :: real)\"\n  shows  \"(\\<lambda>p. ln (real p) / (p powr x - 1)) abs_summable_on {p. prime p}\" (is ?th1)\n    and  \"deriv zeta (of_real x) / zeta (of_real x) =\n            -of_real (\\<Sum>\\<^sub>ap | prime p. ln (real p) / (p powr x - 1))\" (is ?th2)", "lemma\n  fixes a b c d :: real\n  assumes ab: \"d * a + b \\<ge> 1\" and c: \"c < -1\" and d: \"d > 0\"\n  defines \"C \\<equiv> - ((ln (d * a + b) - 1 / (c + 1)) * (d * a + b) powr (c + 1) / (d * (c + 1)))\"\n  shows set_integrable_ln_powr_at_top:\n          \"(\\<lambda>x. (ln (d * x + b) * ((d * x + b) powr c))) absolutely_integrable_on {a<..}\" (is ?th1)\n  and   set_lebesgue_integral_ln_powr_at_top:\n          \"(\\<integral>x\\<in>{a<..}. (ln (d * x + b) * ((d * x + b) powr c)) \\<partial>lborel) = C\" (is ?th2)\n  and   ln_powr_has_integral_at_top:\n          \"((\\<lambda>x. ln (d * x + b) * (d * x + b) powr c) has_integral C) {a<..}\" (is ?th3)", "lemma ln_fact_conv_sum_upto: \"ln (fact n) = sum_upto ln n\"", "lemma sum_upto_ln_conv_ln_fact: \"sum_upto ln x = ln (fact (nat \\<lfloor>x\\<rfloor>))\"", "lemma real_of_nat_div: \"real (a div b) = real_of_int \\<lfloor>real a / real b\\<rfloor>\"", "lemma integral_subset_negligible:\n  fixes f :: \"'a :: euclidean_space \\<Rightarrow> 'b :: banach\"\n  assumes \"S \\<subseteq> T\" \"negligible (T - S)\"\n  shows   \"integral S f = integral T f\"", "lemma integrable_on_cong [cong]:\n  assumes \"\\<And>x. x \\<in> A \\<Longrightarrow> f x = g x\" \"A = B\"\n  shows   \"f integrable_on A \\<longleftrightarrow> g integrable_on B\"", "lemma measurable_sum_upto [measurable]:\n  fixes f :: \"'a \\<Rightarrow> nat \\<Rightarrow> real\"\n  assumes [measurable]: \"\\<And>y. (\\<lambda>t. f t y) \\<in> M \\<rightarrow>\\<^sub>M borel\"\n  assumes [measurable]: \"x \\<in> M \\<rightarrow>\\<^sub>M borel\"\n  shows \"(\\<lambda>t. sum_upto (f t) (x t)) \\<in> M \\<rightarrow>\\<^sub>M borel\""], "translations": [["", "lemma asymp_equivD_strong:\n  assumes \"f \\<sim>[F] g\" \"eventually (\\<lambda>x. f x \\<noteq> 0 \\<or> g x \\<noteq> 0) F\"\n  shows   \"((\\<lambda>x. f x / g x) \\<longlongrightarrow> 1) F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x. f x / g x) \\<longlongrightarrow> (1::'b)) F", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ((\\<lambda>x. f x / g x) \\<longlongrightarrow> (1::'b)) F", "from assms(1)"], ["proof (chain)\npicking this:\n  f \\<sim>[F] g", "have \"((\\<lambda>x. if f x = 0 \\<and> g x = 0 then 1 else f x / g x) \\<longlongrightarrow> 1) F\""], ["proof (prove)\nusing this:\n  f \\<sim>[F] g\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x.\n         if f x = (0::'b) \\<and> g x = (0::'b) then 1::'b\n         else f x / g x) \\<longlongrightarrow>\n     (1::'b))\n     F", "by (rule asymp_equivD)"], ["proof (state)\nthis:\n  ((\\<lambda>x.\n       if f x = (0::'b) \\<and> g x = (0::'b) then 1::'b\n       else f x / g x) \\<longlongrightarrow>\n   (1::'b))\n   F\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. f x / g x) \\<longlongrightarrow> (1::'b)) F", "also"], ["proof (state)\nthis:\n  ((\\<lambda>x.\n       if f x = (0::'b) \\<and> g x = (0::'b) then 1::'b\n       else f x / g x) \\<longlongrightarrow>\n   (1::'b))\n   F\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. f x / g x) \\<longlongrightarrow> (1::'b)) F", "have \"?this \\<longleftrightarrow> ?thesis\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x.\n         if f x = (0::'b) \\<and> g x = (0::'b) then 1::'b\n         else f x / g x) \\<longlongrightarrow>\n     (1::'b))\n     F =\n    ((\\<lambda>x. f x / g x) \\<longlongrightarrow> (1::'b)) F", "by (intro filterlim_cong eventually_mono[OF assms(2)]) auto"], ["proof (state)\nthis:\n  ((\\<lambda>x.\n       if f x = (0::'b) \\<and> g x = (0::'b) then 1::'b\n       else f x / g x) \\<longlongrightarrow>\n   (1::'b))\n   F =\n  ((\\<lambda>x. f x / g x) \\<longlongrightarrow> (1::'b)) F\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. f x / g x) \\<longlongrightarrow> (1::'b)) F", "finally"], ["proof (chain)\npicking this:\n  ((\\<lambda>x. f x / g x) \\<longlongrightarrow> (1::'b)) F", "show ?thesis"], ["proof (prove)\nusing this:\n  ((\\<lambda>x. f x / g x) \\<longlongrightarrow> (1::'b)) F\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. f x / g x) \\<longlongrightarrow> (1::'b)) F", "."], ["proof (state)\nthis:\n  ((\\<lambda>x. f x / g x) \\<longlongrightarrow> (1::'b)) F\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma frontier_real_Ici [simp]:\n  fixes a :: real\n  shows \"frontier {a..} = {a}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. frontier {a..} = {a}", "unfolding frontier_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. closure {a..} - interior {a..} = {a}", "by (auto simp: interior_real_atLeast)"], ["", "lemma sum_upto_ln_conv_sum_upto_mangoldt:\n  \"sum_upto (\\<lambda>n. ln (real n)) x = sum_upto (\\<lambda>n. mangoldt n * nat \\<lfloor>x / real n\\<rfloor>) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_upto (\\<lambda>n. ln (real n)) x =\n    sum_upto\n     (\\<lambda>n. mangoldt n * real (nat \\<lfloor>x / real n\\<rfloor>)) x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. sum_upto (\\<lambda>n. ln (real n)) x =\n    sum_upto\n     (\\<lambda>n. mangoldt n * real (nat \\<lfloor>x / real n\\<rfloor>)) x", "have \"sum_upto (\\<lambda>n. ln (real n)) x =\n          sum_upto (\\<lambda>n. \\<Sum>d | d dvd n. mangoldt d) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_upto (\\<lambda>n. ln (real n)) x =\n    sum_upto (\\<lambda>n. \\<Sum>d | d dvd n. mangoldt d) x", "by (intro sum_upto_cong) (simp_all add: mangoldt_sum)"], ["proof (state)\nthis:\n  sum_upto (\\<lambda>n. ln (real n)) x =\n  sum_upto (\\<lambda>n. \\<Sum>d | d dvd n. mangoldt d) x\n\ngoal (1 subgoal):\n 1. sum_upto (\\<lambda>n. ln (real n)) x =\n    sum_upto\n     (\\<lambda>n. mangoldt n * real (nat \\<lfloor>x / real n\\<rfloor>)) x", "also"], ["proof (state)\nthis:\n  sum_upto (\\<lambda>n. ln (real n)) x =\n  sum_upto (\\<lambda>n. \\<Sum>d | d dvd n. mangoldt d) x\n\ngoal (1 subgoal):\n 1. sum_upto (\\<lambda>n. ln (real n)) x =\n    sum_upto\n     (\\<lambda>n. mangoldt n * real (nat \\<lfloor>x / real n\\<rfloor>)) x", "have \"\\<dots> = sum_upto (\\<lambda>k. sum_upto (\\<lambda>d. mangoldt k) (x / real k)) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_upto (\\<lambda>n. \\<Sum>d | d dvd n. mangoldt d) x =\n    sum_upto (\\<lambda>k. sum_upto (\\<lambda>d. mangoldt k) (x / real k)) x", "by (rule sum_upto_sum_divisors)"], ["proof (state)\nthis:\n  sum_upto (\\<lambda>n. \\<Sum>d | d dvd n. mangoldt d) x =\n  sum_upto (\\<lambda>k. sum_upto (\\<lambda>d. mangoldt k) (x / real k)) x\n\ngoal (1 subgoal):\n 1. sum_upto (\\<lambda>n. ln (real n)) x =\n    sum_upto\n     (\\<lambda>n. mangoldt n * real (nat \\<lfloor>x / real n\\<rfloor>)) x", "also"], ["proof (state)\nthis:\n  sum_upto (\\<lambda>n. \\<Sum>d | d dvd n. mangoldt d) x =\n  sum_upto (\\<lambda>k. sum_upto (\\<lambda>d. mangoldt k) (x / real k)) x\n\ngoal (1 subgoal):\n 1. sum_upto (\\<lambda>n. ln (real n)) x =\n    sum_upto\n     (\\<lambda>n. mangoldt n * real (nat \\<lfloor>x / real n\\<rfloor>)) x", "have \"\\<dots> = sum_upto (\\<lambda>n. mangoldt n * nat \\<lfloor>x / real n\\<rfloor>) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_upto (\\<lambda>k. sum_upto (\\<lambda>d. mangoldt k) (x / real k))\n     x =\n    sum_upto\n     (\\<lambda>n. mangoldt n * real (nat \\<lfloor>x / real n\\<rfloor>)) x", "unfolding sum_upto_altdef"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k\\<in>{0<..nat \\<lfloor>x\\<rfloor>}.\n       \\<Sum>d\\<in>{0<..nat \\<lfloor>x / real k\\<rfloor>}. mangoldt k) =\n    (\\<Sum>n\\<in>{0<..nat \\<lfloor>x\\<rfloor>}.\n       mangoldt n * real (nat \\<lfloor>x / real n\\<rfloor>))", "by (simp add: mult_ac)"], ["proof (state)\nthis:\n  sum_upto (\\<lambda>k. sum_upto (\\<lambda>d. mangoldt k) (x / real k)) x =\n  sum_upto\n   (\\<lambda>n. mangoldt n * real (nat \\<lfloor>x / real n\\<rfloor>)) x\n\ngoal (1 subgoal):\n 1. sum_upto (\\<lambda>n. ln (real n)) x =\n    sum_upto\n     (\\<lambda>n. mangoldt n * real (nat \\<lfloor>x / real n\\<rfloor>)) x", "finally"], ["proof (chain)\npicking this:\n  sum_upto (\\<lambda>n. ln (real n)) x =\n  sum_upto\n   (\\<lambda>n. mangoldt n * real (nat \\<lfloor>x / real n\\<rfloor>)) x", "show ?thesis"], ["proof (prove)\nusing this:\n  sum_upto (\\<lambda>n. ln (real n)) x =\n  sum_upto\n   (\\<lambda>n. mangoldt n * real (nat \\<lfloor>x / real n\\<rfloor>)) x\n\ngoal (1 subgoal):\n 1. sum_upto (\\<lambda>n. ln (real n)) x =\n    sum_upto\n     (\\<lambda>n. mangoldt n * real (nat \\<lfloor>x / real n\\<rfloor>)) x", "."], ["proof (state)\nthis:\n  sum_upto (\\<lambda>n. ln (real n)) x =\n  sum_upto\n   (\\<lambda>n. mangoldt n * real (nat \\<lfloor>x / real n\\<rfloor>)) x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ln_fact_conv_sum_upto_mangoldt:\n  \"ln (fact n) = sum_upto (\\<lambda>k. mangoldt k * (n div k)) n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ln (fact n) =\n    sum_upto (\\<lambda>k. mangoldt k * real (n div k)) (real n)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ln (fact n) =\n    sum_upto (\\<lambda>k. mangoldt k * real (n div k)) (real n)", "have [simp]: \"{0<..Suc n} = insert (Suc n) {0<..n}\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. {0<..Suc n} = insert (Suc n) {0<..n}", "by auto"], ["proof (state)\nthis:\n  {0<..Suc ?n} = insert (Suc ?n) {0<..?n}\n\ngoal (1 subgoal):\n 1. ln (fact n) =\n    sum_upto (\\<lambda>k. mangoldt k * real (n div k)) (real n)", "have \"ln (fact n) = sum_upto (\\<lambda>n. ln (real n)) n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ln (fact n) = sum_upto (\\<lambda>n. ln (real n)) (real n)", "by (induction n) (auto simp: sum_upto_altdef nat_add_distrib ln_mult)"], ["proof (state)\nthis:\n  ln (fact n) = sum_upto (\\<lambda>n. ln (real n)) (real n)\n\ngoal (1 subgoal):\n 1. ln (fact n) =\n    sum_upto (\\<lambda>k. mangoldt k * real (n div k)) (real n)", "also"], ["proof (state)\nthis:\n  ln (fact n) = sum_upto (\\<lambda>n. ln (real n)) (real n)\n\ngoal (1 subgoal):\n 1. ln (fact n) =\n    sum_upto (\\<lambda>k. mangoldt k * real (n div k)) (real n)", "have \"\\<dots> = sum_upto (\\<lambda>k. mangoldt k * (n div k)) n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_upto (\\<lambda>n. ln (real n)) (real n) =\n    sum_upto (\\<lambda>k. mangoldt k * real (n div k)) (real n)", "unfolding sum_upto_ln_conv_sum_upto_mangoldt"], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_upto\n     (\\<lambda>na.\n         mangoldt na * real (nat \\<lfloor>real n / real na\\<rfloor>))\n     (real n) =\n    sum_upto (\\<lambda>k. mangoldt k * real (n div k)) (real n)", "by (intro sum_upto_cong) (auto simp: floor_divide_of_nat_eq)"], ["proof (state)\nthis:\n  sum_upto (\\<lambda>n. ln (real n)) (real n) =\n  sum_upto (\\<lambda>k. mangoldt k * real (n div k)) (real n)\n\ngoal (1 subgoal):\n 1. ln (fact n) =\n    sum_upto (\\<lambda>k. mangoldt k * real (n div k)) (real n)", "finally"], ["proof (chain)\npicking this:\n  ln (fact n) = sum_upto (\\<lambda>k. mangoldt k * real (n div k)) (real n)", "show ?thesis"], ["proof (prove)\nusing this:\n  ln (fact n) = sum_upto (\\<lambda>k. mangoldt k * real (n div k)) (real n)\n\ngoal (1 subgoal):\n 1. ln (fact n) =\n    sum_upto (\\<lambda>k. mangoldt k * real (n div k)) (real n)", "."], ["proof (state)\nthis:\n  ln (fact n) = sum_upto (\\<lambda>k. mangoldt k * real (n div k)) (real n)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma powr_sum: \"x \\<noteq> 0 \\<Longrightarrow> finite A \\<Longrightarrow> x powr sum f A = (\\<Prod>y\\<in>A. x powr f y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> (0::'a); finite A\\<rbrakk>\n    \\<Longrightarrow> x powr sum f A = (\\<Prod>y\\<in>A. x powr f y)", "by (simp add: powr_def exp_sum sum_distrib_right)"], ["", "lemma fds_abs_converges_comparison_test:\n  fixes s :: \"'a :: dirichlet_series\"\n  assumes \"eventually (\\<lambda>n. norm (fds_nth f n) \\<le> fds_nth g n) at_top\" and \"fds_converges g (s \\<bullet> 1)\"\n  shows   \"fds_abs_converges f s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fds_abs_converges f s", "unfolding fds_abs_converges_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. summable (\\<lambda>n. norm (fds_nth f n / nat_power n s))", "proof (rule summable_comparison_test_ev)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>\\<^sub>F n in sequentially.\n       norm (norm (fds_nth f n / nat_power n s)) \\<le> ?g n\n 2. summable ?g", "from assms(2)"], ["proof (chain)\npicking this:\n  fds_converges g (s \\<bullet> (1::'a))", "show \"summable (\\<lambda>n. fds_nth g n / n powr (s \\<bullet> 1))\""], ["proof (prove)\nusing this:\n  fds_converges g (s \\<bullet> (1::'a))\n\ngoal (1 subgoal):\n 1. summable (\\<lambda>n. fds_nth g n / real n powr (s \\<bullet> (1::'a)))", "by (auto simp: fds_converges_def)"], ["proof (state)\nthis:\n  summable (\\<lambda>n. fds_nth g n / real n powr (s \\<bullet> (1::'a)))\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F n in sequentially.\n       norm (norm (fds_nth f n / nat_power n s))\n       \\<le> fds_nth g n / real n powr (s \\<bullet> (1::'a))", "from assms(1) eventually_gt_at_top[of 0]"], ["proof (chain)\npicking this:\n  \\<forall>\\<^sub>F n in sequentially. norm (fds_nth f n) \\<le> fds_nth g n\n  eventually ((<) (0::?'b1)) at_top", "show \"eventually (\\<lambda>n. norm (norm (fds_nth f n / nat_power n s)) \\<le>\n                            fds_nth g n / real n powr (s \\<bullet> 1)) at_top\""], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F n in sequentially. norm (fds_nth f n) \\<le> fds_nth g n\n  eventually ((<) (0::?'b1)) at_top\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F n in sequentially.\n       norm (norm (fds_nth f n / nat_power n s))\n       \\<le> fds_nth g n / real n powr (s \\<bullet> (1::'a))", "by eventually_elim (auto simp: norm_divide norm_nat_power intro!: divide_right_mono)"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F n in sequentially.\n     norm (norm (fds_nth f n / nat_power n s))\n     \\<le> fds_nth g n / real n powr (s \\<bullet> (1::'a))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma fds_converges_scaleR [intro]:\n  assumes \"fds_converges f s\"\n  shows   \"fds_converges (c *\\<^sub>R f) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fds_converges (c *\\<^sub>R f) s", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. fds_converges (c *\\<^sub>R f) s", "from assms"], ["proof (chain)\npicking this:\n  fds_converges f s", "have \"summable (\\<lambda>n. c *\\<^sub>R (fds_nth f n / nat_power n s))\""], ["proof (prove)\nusing this:\n  fds_converges f s\n\ngoal (1 subgoal):\n 1. summable (\\<lambda>n. c *\\<^sub>R (fds_nth f n / nat_power n s))", "by (intro summable_scaleR_right) (auto simp: fds_converges_def)"], ["proof (state)\nthis:\n  summable (\\<lambda>n. c *\\<^sub>R (fds_nth f n / nat_power n s))\n\ngoal (1 subgoal):\n 1. fds_converges (c *\\<^sub>R f) s", "also"], ["proof (state)\nthis:\n  summable (\\<lambda>n. c *\\<^sub>R (fds_nth f n / nat_power n s))\n\ngoal (1 subgoal):\n 1. fds_converges (c *\\<^sub>R f) s", "have \"(\\<lambda>n. c *\\<^sub>R (fds_nth f n / nat_power n s)) = (\\<lambda>n. (c *\\<^sub>R fds_nth f n / nat_power n s))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n. c *\\<^sub>R (fds_nth f n / nat_power n s)) =\n    (\\<lambda>n. c *\\<^sub>R fds_nth f n / nat_power n s)", "by (simp add: scaleR_conv_of_real)"], ["proof (state)\nthis:\n  (\\<lambda>n. c *\\<^sub>R (fds_nth f n / nat_power n s)) =\n  (\\<lambda>n. c *\\<^sub>R fds_nth f n / nat_power n s)\n\ngoal (1 subgoal):\n 1. fds_converges (c *\\<^sub>R f) s", "finally"], ["proof (chain)\npicking this:\n  summable (\\<lambda>n. c *\\<^sub>R fds_nth f n / nat_power n s)", "show ?thesis"], ["proof (prove)\nusing this:\n  summable (\\<lambda>n. c *\\<^sub>R fds_nth f n / nat_power n s)\n\ngoal (1 subgoal):\n 1. fds_converges (c *\\<^sub>R f) s", "by (simp add: fds_converges_def)"], ["proof (state)\nthis:\n  fds_converges (c *\\<^sub>R f) s\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma fds_abs_converges_scaleR [intro]:\n  assumes \"fds_abs_converges f s\"\n  shows   \"fds_abs_converges (c *\\<^sub>R f) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fds_abs_converges (c *\\<^sub>R f) s", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. fds_abs_converges (c *\\<^sub>R f) s", "from assms"], ["proof (chain)\npicking this:\n  fds_abs_converges f s", "have \"summable (\\<lambda>n. abs c * norm (fds_nth f n / nat_power n s))\""], ["proof (prove)\nusing this:\n  fds_abs_converges f s\n\ngoal (1 subgoal):\n 1. summable\n     (\\<lambda>n. \\<bar>c\\<bar> * norm (fds_nth f n / nat_power n s))", "by (intro summable_mult) (auto simp: fds_abs_converges_def)"], ["proof (state)\nthis:\n  summable (\\<lambda>n. \\<bar>c\\<bar> * norm (fds_nth f n / nat_power n s))\n\ngoal (1 subgoal):\n 1. fds_abs_converges (c *\\<^sub>R f) s", "also"], ["proof (state)\nthis:\n  summable (\\<lambda>n. \\<bar>c\\<bar> * norm (fds_nth f n / nat_power n s))\n\ngoal (1 subgoal):\n 1. fds_abs_converges (c *\\<^sub>R f) s", "have \"(\\<lambda>n. abs c * norm (fds_nth f n / nat_power n s)) =\n               (\\<lambda>n. norm ((c *\\<^sub>R fds_nth f n) / nat_power n s))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n. \\<bar>c\\<bar> * norm (fds_nth f n / nat_power n s)) =\n    (\\<lambda>n. norm (c *\\<^sub>R fds_nth f n / nat_power n s))", "by (simp add: norm_divide)"], ["proof (state)\nthis:\n  (\\<lambda>n. \\<bar>c\\<bar> * norm (fds_nth f n / nat_power n s)) =\n  (\\<lambda>n. norm (c *\\<^sub>R fds_nth f n / nat_power n s))\n\ngoal (1 subgoal):\n 1. fds_abs_converges (c *\\<^sub>R f) s", "finally"], ["proof (chain)\npicking this:\n  summable (\\<lambda>n. norm (c *\\<^sub>R fds_nth f n / nat_power n s))", "show ?thesis"], ["proof (prove)\nusing this:\n  summable (\\<lambda>n. norm (c *\\<^sub>R fds_nth f n / nat_power n s))\n\ngoal (1 subgoal):\n 1. fds_abs_converges (c *\\<^sub>R f) s", "by (simp add: fds_abs_converges_def)"], ["proof (state)\nthis:\n  fds_abs_converges (c *\\<^sub>R f) s\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma conv_abscissa_scaleR: \"conv_abscissa (scaleR c f) \\<le> conv_abscissa f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. conv_abscissa (c *\\<^sub>R f) \\<le> conv_abscissa f", "by (rule conv_abscissa_mono) auto"], ["", "lemma abs_conv_abscissa_scaleR: \"abs_conv_abscissa (scaleR c f) \\<le> abs_conv_abscissa f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. abs_conv_abscissa (c *\\<^sub>R f) \\<le> abs_conv_abscissa f", "by (rule abs_conv_abscissa_mono) auto"], ["", "lemma fds_converges_mult_const_left [intro]:\n  \"fds_converges f s \\<Longrightarrow> fds_converges (fds_const c * f) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fds_converges f s \\<Longrightarrow> fds_converges (fds_const c * f) s", "by (auto simp: fds_converges_def dest: summable_mult[of _ c])"], ["", "lemma fds_abs_converges_mult_const_left [intro]:\n  \"fds_abs_converges f s \\<Longrightarrow> fds_abs_converges (fds_const c * f) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fds_abs_converges f s \\<Longrightarrow>\n    fds_abs_converges (fds_const c * f) s", "by (auto simp: fds_abs_converges_def norm_mult norm_divide dest: summable_mult[of _ \"norm c\"])"], ["", "lemma conv_abscissa_mult_const_left:\n  \"conv_abscissa (fds_const c * f) \\<le> conv_abscissa f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. conv_abscissa (fds_const c * f) \\<le> conv_abscissa f", "by (intro conv_abscissa_mono) auto"], ["", "lemma abs_conv_abscissa_mult_const_left:\n  \"abs_conv_abscissa (fds_const c * f) \\<le> abs_conv_abscissa f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. abs_conv_abscissa (fds_const c * f) \\<le> abs_conv_abscissa f", "by (intro abs_conv_abscissa_mono) auto"], ["", "lemma fds_converges_mult_const_right [intro]:\n  \"fds_converges f s \\<Longrightarrow> fds_converges (f * fds_const c) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fds_converges f s \\<Longrightarrow> fds_converges (f * fds_const c) s", "by (auto simp: fds_converges_def dest: summable_mult2[of _ c])"], ["", "lemma fds_abs_converges_mult_const_right [intro]:\n  \"fds_abs_converges f s \\<Longrightarrow> fds_abs_converges (f * fds_const c) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fds_abs_converges f s \\<Longrightarrow>\n    fds_abs_converges (f * fds_const c) s", "by (auto simp: fds_abs_converges_def norm_mult norm_divide dest: summable_mult2[of _ \"norm c\"])"], ["", "lemma conv_abscissa_mult_const_right:\n  \"conv_abscissa (f * fds_const c) \\<le> conv_abscissa f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. conv_abscissa (f * fds_const c) \\<le> conv_abscissa f", "by (intro conv_abscissa_mono) auto"], ["", "lemma abs_conv_abscissa_mult_const_right:\n  \"abs_conv_abscissa (f * fds_const c) \\<le> abs_conv_abscissa f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. abs_conv_abscissa (f * fds_const c) \\<le> abs_conv_abscissa f", "by (intro abs_conv_abscissa_mono) auto"], ["", "lemma bounded_coeffs_imp_fds_abs_converges:\n  fixes s :: \"'a :: dirichlet_series\" and f :: \"'a fds\"\n  assumes \"Bseq (fds_nth f)\" \"s \\<bullet> 1 > 1\"\n  shows   \"fds_abs_converges f s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fds_abs_converges f s", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. fds_abs_converges f s", "from assms"], ["proof (chain)\npicking this:\n  Bseq (fds_nth f)\n  1 < s \\<bullet> (1::'a)", "obtain C where C: \"\\<And>n. norm (fds_nth f n) \\<le> C\""], ["proof (prove)\nusing this:\n  Bseq (fds_nth f)\n  1 < s \\<bullet> (1::'a)\n\ngoal (1 subgoal):\n 1. (\\<And>C.\n        (\\<And>n. norm (fds_nth f n) \\<le> C) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: Bseq_def)"], ["proof (state)\nthis:\n  norm (fds_nth f ?n) \\<le> C\n\ngoal (1 subgoal):\n 1. fds_abs_converges f s", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. fds_abs_converges f s", "proof (rule fds_abs_converges_comparison_test)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>\\<^sub>F n in sequentially.\n       norm (fds_nth f n) \\<le> fds_nth ?g n\n 2. fds_converges ?g (s \\<bullet> (1::'a))", "from \\<open>s \\<bullet> 1 > 1\\<close>"], ["proof (chain)\npicking this:\n  1 < s \\<bullet> (1::'a)", "show \"fds_converges (C *\\<^sub>R fds_zeta) (s \\<bullet> 1)\""], ["proof (prove)\nusing this:\n  1 < s \\<bullet> (1::'a)\n\ngoal (1 subgoal):\n 1. fds_converges (C *\\<^sub>R fds_zeta) (s \\<bullet> (1::'a))", "by (intro fds_abs_converges_imp_converges) auto"], ["proof (state)\nthis:\n  fds_converges (C *\\<^sub>R fds_zeta) (s \\<bullet> (1::'a))\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F n in sequentially.\n       norm (fds_nth f n) \\<le> fds_nth (C *\\<^sub>R fds_zeta) n", "from C"], ["proof (chain)\npicking this:\n  norm (fds_nth f ?n) \\<le> C", "show \"eventually (\\<lambda>n. norm (fds_nth f n) \\<le> fds_nth (C *\\<^sub>R fds_zeta) n) at_top\""], ["proof (prove)\nusing this:\n  norm (fds_nth f ?n) \\<le> C\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F n in sequentially.\n       norm (fds_nth f n) \\<le> fds_nth (C *\\<^sub>R fds_zeta) n", "by (intro always_eventually) (auto simp: fds_nth_zeta)"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F n in sequentially.\n     norm (fds_nth f n) \\<le> fds_nth (C *\\<^sub>R fds_zeta) n\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  fds_abs_converges f s\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bounded_coeffs_imp_fds_abs_converges':\n  fixes s :: \"'a :: dirichlet_series\" and f :: \"'a fds\"\n  assumes \"Bseq (\\<lambda>n. fds_nth f n * nat_power n s0)\" \"s \\<bullet> 1 > 1 - s0 \\<bullet> 1\"\n  shows   \"fds_abs_converges f s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fds_abs_converges f s", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. fds_abs_converges f s", "have \"fds_nth (fds_shift s0 f) = (\\<lambda>n. fds_nth f n * nat_power n s0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fds_nth (fds_shift s0 f) = (\\<lambda>n. fds_nth f n * nat_power n s0)", "by (auto simp: fun_eq_iff)"], ["proof (state)\nthis:\n  fds_nth (fds_shift s0 f) = (\\<lambda>n. fds_nth f n * nat_power n s0)\n\ngoal (1 subgoal):\n 1. fds_abs_converges f s", "with assms"], ["proof (chain)\npicking this:\n  Bseq (\\<lambda>n. fds_nth f n * nat_power n s0)\n  1 - s0 \\<bullet> (1::'a) < s \\<bullet> (1::'a)\n  fds_nth (fds_shift s0 f) = (\\<lambda>n. fds_nth f n * nat_power n s0)", "have \"Bseq (fds_nth (fds_shift s0 f))\""], ["proof (prove)\nusing this:\n  Bseq (\\<lambda>n. fds_nth f n * nat_power n s0)\n  1 - s0 \\<bullet> (1::'a) < s \\<bullet> (1::'a)\n  fds_nth (fds_shift s0 f) = (\\<lambda>n. fds_nth f n * nat_power n s0)\n\ngoal (1 subgoal):\n 1. Bseq (fds_nth (fds_shift s0 f))", "by simp"], ["proof (state)\nthis:\n  Bseq (fds_nth (fds_shift s0 f))\n\ngoal (1 subgoal):\n 1. fds_abs_converges f s", "with assms(2)"], ["proof (chain)\npicking this:\n  1 - s0 \\<bullet> (1::'a) < s \\<bullet> (1::'a)\n  Bseq (fds_nth (fds_shift s0 f))", "have \"fds_abs_converges (fds_shift s0 f) (s + s0)\""], ["proof (prove)\nusing this:\n  1 - s0 \\<bullet> (1::'a) < s \\<bullet> (1::'a)\n  Bseq (fds_nth (fds_shift s0 f))\n\ngoal (1 subgoal):\n 1. fds_abs_converges (fds_shift s0 f) (s + s0)", "by (intro bounded_coeffs_imp_fds_abs_converges) (auto simp: algebra_simps)"], ["proof (state)\nthis:\n  fds_abs_converges (fds_shift s0 f) (s + s0)\n\ngoal (1 subgoal):\n 1. fds_abs_converges f s", "thus ?thesis"], ["proof (prove)\nusing this:\n  fds_abs_converges (fds_shift s0 f) (s + s0)\n\ngoal (1 subgoal):\n 1. fds_abs_converges f s", "by simp"], ["proof (state)\nthis:\n  fds_abs_converges f s\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bounded_coeffs_imp_abs_conv_abscissa_le:\n  fixes s :: \"'a :: dirichlet_series\" and f :: \"'a fds\" and c :: ereal\n  assumes \"Bseq (\\<lambda>n. fds_nth f n * nat_power n s)\" \"1 - s \\<bullet> 1 \\<le> c\"\n  shows   \"abs_conv_abscissa f \\<le> c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. abs_conv_abscissa f \\<le> c", "proof (rule abs_conv_abscissa_leI_weak)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. c < ereal x \\<Longrightarrow> fds_abs_converges f (of_real x)", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. c < ereal x \\<Longrightarrow> fds_abs_converges f (of_real x)", "assume \"c < ereal x\""], ["proof (state)\nthis:\n  c < ereal x\n\ngoal (1 subgoal):\n 1. \\<And>x. c < ereal x \\<Longrightarrow> fds_abs_converges f (of_real x)", "have \"ereal (1 - s \\<bullet> 1) \\<le> c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ereal (1 - s \\<bullet> (1::'a)) \\<le> c", "by fact"], ["proof (state)\nthis:\n  ereal (1 - s \\<bullet> (1::'a)) \\<le> c\n\ngoal (1 subgoal):\n 1. \\<And>x. c < ereal x \\<Longrightarrow> fds_abs_converges f (of_real x)", "also"], ["proof (state)\nthis:\n  ereal (1 - s \\<bullet> (1::'a)) \\<le> c\n\ngoal (1 subgoal):\n 1. \\<And>x. c < ereal x \\<Longrightarrow> fds_abs_converges f (of_real x)", "have \"\\<dots> < ereal x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c < ereal x", "by fact"], ["proof (state)\nthis:\n  c < ereal x\n\ngoal (1 subgoal):\n 1. \\<And>x. c < ereal x \\<Longrightarrow> fds_abs_converges f (of_real x)", "finally"], ["proof (chain)\npicking this:\n  ereal (1 - s \\<bullet> (1::'a)) < ereal x", "have \"1 - s \\<bullet> 1 < ereal x\""], ["proof (prove)\nusing this:\n  ereal (1 - s \\<bullet> (1::'a)) < ereal x\n\ngoal (1 subgoal):\n 1. ereal (1 - s \\<bullet> (1::'a)) < ereal x", "by simp"], ["proof (state)\nthis:\n  ereal (1 - s \\<bullet> (1::'a)) < ereal x\n\ngoal (1 subgoal):\n 1. \\<And>x. c < ereal x \\<Longrightarrow> fds_abs_converges f (of_real x)", "thus \"fds_abs_converges f (of_real x)\""], ["proof (prove)\nusing this:\n  ereal (1 - s \\<bullet> (1::'a)) < ereal x\n\ngoal (1 subgoal):\n 1. fds_abs_converges f (of_real x)", "by (intro bounded_coeffs_imp_fds_abs_converges'[OF assms(1)]) auto"], ["proof (state)\nthis:\n  fds_abs_converges f (of_real x)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bounded_coeffs_imp_abs_conv_abscissa_le_1:\n  fixes s :: \"'a :: dirichlet_series\" and f :: \"'a fds\"\n  assumes \"Bseq (\\<lambda>n. fds_nth f n)\"\n  shows   \"abs_conv_abscissa f \\<le> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. abs_conv_abscissa f \\<le> 1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. abs_conv_abscissa f \\<le> 1", "have [simp]: \"fds_nth f n * nat_power n 0 = fds_nth f n\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. fds_nth f n * nat_power n (0::'a) = fds_nth f n", "by (cases \"n = 0\") auto"], ["proof (state)\nthis:\n  fds_nth f ?n * nat_power ?n (0::'a) = fds_nth f ?n\n\ngoal (1 subgoal):\n 1. abs_conv_abscissa f \\<le> 1", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. abs_conv_abscissa f \\<le> 1", "by (rule bounded_coeffs_imp_abs_conv_abscissa_le[where s = 0]) (insert assms, auto simp:)"], ["proof (state)\nthis:\n  abs_conv_abscissa f \\<le> 1\n\ngoal:\nNo subgoals!", "qed"], ["", "(* TODO: replace library version *)\n(* EXAMPLE: This might make a good example to illustrate real_asymp *)"], ["", "lemma\n  fixes a b c :: real\n  assumes ab: \"a + b > 0\" and c: \"c < -1\"\n  shows set_integrable_powr_at_top: \"(\\<lambda>x. (b + x) powr c) absolutely_integrable_on {a<..}\"\n  and   set_lebesgue_integral_powr_at_top:\n          \"(\\<integral>x\\<in>{a<..}. ((b + x) powr c) \\<partial>lborel) = -((b + a) powr (c + 1) / (c + 1))\"\n  and   powr_has_integral_at_top:\n          \"((\\<lambda>x. (b + x) powr c) has_integral -((b + a) powr (c + 1) / (c + 1))) {a<..}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. (b + x) powr c) absolutely_integrable_on {a<..} &&&\n    LBINT x:{a<..}. (b + x) powr c = - ((b + a) powr (c + 1) / (c + 1)) &&&\n    ((\\<lambda>x. (b + x) powr c) has_integral\n     - ((b + a) powr (c + 1) / (c + 1)))\n     {a<..}", "proof -"], ["proof (state)\ngoal (3 subgoals):\n 1. (\\<lambda>x. (b + x) powr c) absolutely_integrable_on {a<..}\n 2. LBINT x:{a<..}. (b + x) powr c = - ((b + a) powr (c + 1) / (c + 1))\n 3. ((\\<lambda>x. (b + x) powr c) has_integral\n     - ((b + a) powr (c + 1) / (c + 1)))\n     {a<..}", "let ?f = \"\\<lambda>x. (b + x) powr c\" and ?F = \"\\<lambda>x. (b + x) powr (c + 1) / (c + 1)\""], ["proof (state)\ngoal (3 subgoals):\n 1. (\\<lambda>x. (b + x) powr c) absolutely_integrable_on {a<..}\n 2. LBINT x:{a<..}. (b + x) powr c = - ((b + a) powr (c + 1) / (c + 1))\n 3. ((\\<lambda>x. (b + x) powr c) has_integral\n     - ((b + a) powr (c + 1) / (c + 1)))\n     {a<..}", "have limits: \"((?F \\<circ> real_of_ereal) \\<longlongrightarrow> ?F a) (at_right (ereal a))\"\n               \"((?F \\<circ> real_of_ereal) \\<longlongrightarrow> 0) (at_left \\<infinity>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (((\\<lambda>x. (b + x) powr (c + 1) / (c + 1)) \\<circ>\n      real_of_ereal) \\<longlongrightarrow>\n     (b + a) powr (c + 1) / (c + 1))\n     (at_right (ereal a)) &&&\n    (((\\<lambda>x. (b + x) powr (c + 1) / (c + 1)) \\<circ>\n      real_of_ereal) \\<longlongrightarrow>\n     0)\n     (at_left \\<infinity>)", "using c ab"], ["proof (prove)\nusing this:\n  c < - 1\n  0 < a + b\n\ngoal (1 subgoal):\n 1. (((\\<lambda>x. (b + x) powr (c + 1) / (c + 1)) \\<circ>\n      real_of_ereal) \\<longlongrightarrow>\n     (b + a) powr (c + 1) / (c + 1))\n     (at_right (ereal a)) &&&\n    (((\\<lambda>x. (b + x) powr (c + 1) / (c + 1)) \\<circ>\n      real_of_ereal) \\<longlongrightarrow>\n     0)\n     (at_left \\<infinity>)", "unfolding ereal_tendsto_simps1"], ["proof (prove)\nusing this:\n  c < - 1\n  0 < a + b\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. (b + x) powr (c + 1) / (c + 1)) \\<longlongrightarrow>\n     (b + a) powr (c + 1) / (c + 1))\n     (at_right a) &&&\n    ((\\<lambda>x. (b + x) powr (c + 1) / (c + 1)) \\<longlongrightarrow> 0)\n     at_top", "by (real_asymp simp: field_simps)+"], ["proof (state)\nthis:\n  (((\\<lambda>x. (b + x) powr (c + 1) / (c + 1)) \\<circ>\n    real_of_ereal) \\<longlongrightarrow>\n   (b + a) powr (c + 1) / (c + 1))\n   (at_right (ereal a))\n  (((\\<lambda>x. (b + x) powr (c + 1) / (c + 1)) \\<circ>\n    real_of_ereal) \\<longlongrightarrow>\n   0)\n   (at_left \\<infinity>)\n\ngoal (3 subgoals):\n 1. (\\<lambda>x. (b + x) powr c) absolutely_integrable_on {a<..}\n 2. LBINT x:{a<..}. (b + x) powr c = - ((b + a) powr (c + 1) / (c + 1))\n 3. ((\\<lambda>x. (b + x) powr c) has_integral\n     - ((b + a) powr (c + 1) / (c + 1)))\n     {a<..}", "have 1: \"set_integrable lborel (einterval a \\<infinity>) ?f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_integrable lborel (einterval (ereal a) \\<infinity>)\n     (\\<lambda>x. (b + x) powr c)", "using ab c limits"], ["proof (prove)\nusing this:\n  0 < a + b\n  c < - 1\n  (((\\<lambda>x. (b + x) powr (c + 1) / (c + 1)) \\<circ>\n    real_of_ereal) \\<longlongrightarrow>\n   (b + a) powr (c + 1) / (c + 1))\n   (at_right (ereal a))\n  (((\\<lambda>x. (b + x) powr (c + 1) / (c + 1)) \\<circ>\n    real_of_ereal) \\<longlongrightarrow>\n   0)\n   (at_left \\<infinity>)\n\ngoal (1 subgoal):\n 1. set_integrable lborel (einterval (ereal a) \\<infinity>)\n     (\\<lambda>x. (b + x) powr c)", "by (intro interval_integral_FTC_nonneg) (auto intro!: derivative_eq_intros)"], ["proof (state)\nthis:\n  set_integrable lborel (einterval (ereal a) \\<infinity>)\n   (\\<lambda>x. (b + x) powr c)\n\ngoal (3 subgoals):\n 1. (\\<lambda>x. (b + x) powr c) absolutely_integrable_on {a<..}\n 2. LBINT x:{a<..}. (b + x) powr c = - ((b + a) powr (c + 1) / (c + 1))\n 3. ((\\<lambda>x. (b + x) powr c) has_integral\n     - ((b + a) powr (c + 1) / (c + 1)))\n     {a<..}", "thus 2: \"?f absolutely_integrable_on {a<..}\""], ["proof (prove)\nusing this:\n  set_integrable lborel (einterval (ereal a) \\<infinity>)\n   (\\<lambda>x. (b + x) powr c)\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. (b + x) powr c) absolutely_integrable_on {a<..}", "by (auto simp: set_integrable_def integrable_completion)"], ["proof (state)\nthis:\n  (\\<lambda>x. (b + x) powr c) absolutely_integrable_on {a<..}\n\ngoal (2 subgoals):\n 1. LBINT x:{a<..}. (b + x) powr c = - ((b + a) powr (c + 1) / (c + 1))\n 2. ((\\<lambda>x. (b + x) powr c) has_integral\n     - ((b + a) powr (c + 1) / (c + 1)))\n     {a<..}", "have \"LBINT x=ereal a..\\<infinity>. (b + x) powr c = 0 - ?F a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LBINT x=ereal a..\\<infinity>. (b + x) powr c =\n    0 - (b + a) powr (c + 1) / (c + 1)", "using ab c limits"], ["proof (prove)\nusing this:\n  0 < a + b\n  c < - 1\n  (((\\<lambda>x. (b + x) powr (c + 1) / (c + 1)) \\<circ>\n    real_of_ereal) \\<longlongrightarrow>\n   (b + a) powr (c + 1) / (c + 1))\n   (at_right (ereal a))\n  (((\\<lambda>x. (b + x) powr (c + 1) / (c + 1)) \\<circ>\n    real_of_ereal) \\<longlongrightarrow>\n   0)\n   (at_left \\<infinity>)\n\ngoal (1 subgoal):\n 1. LBINT x=ereal a..\\<infinity>. (b + x) powr c =\n    0 - (b + a) powr (c + 1) / (c + 1)", "by (intro interval_integral_FTC_nonneg) (auto intro!: derivative_eq_intros)"], ["proof (state)\nthis:\n  LBINT x=ereal a..\\<infinity>. (b + x) powr c =\n  0 - (b + a) powr (c + 1) / (c + 1)\n\ngoal (2 subgoals):\n 1. LBINT x:{a<..}. (b + x) powr c = - ((b + a) powr (c + 1) / (c + 1))\n 2. ((\\<lambda>x. (b + x) powr c) has_integral\n     - ((b + a) powr (c + 1) / (c + 1)))\n     {a<..}", "thus 3: \"(\\<integral>x\\<in>{a<..}. ((b + x) powr c) \\<partial>lborel) = -((b + a) powr (c + 1) / (c + 1))\""], ["proof (prove)\nusing this:\n  LBINT x=ereal a..\\<infinity>. (b + x) powr c =\n  0 - (b + a) powr (c + 1) / (c + 1)\n\ngoal (1 subgoal):\n 1. LBINT x:{a<..}. (b + x) powr c = - ((b + a) powr (c + 1) / (c + 1))", "by (simp add: interval_integral_to_infinity_eq)"], ["proof (state)\nthis:\n  LBINT x:{a<..}. (b + x) powr c = - ((b + a) powr (c + 1) / (c + 1))\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. (b + x) powr c) has_integral\n     - ((b + a) powr (c + 1) / (c + 1)))\n     {a<..}", "show \"(?f has_integral -((b + a) powr (c + 1) / (c + 1))) {a<..}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x. (b + x) powr c) has_integral\n     - ((b + a) powr (c + 1) / (c + 1)))\n     {a<..}", "using set_borel_integral_eq_integral[OF 1] 3"], ["proof (prove)\nusing this:\n  (\\<lambda>x. (b + x) powr c) integrable_on einterval (ereal a) \\<infinity>\n  LBINT x:einterval (ereal a) \\<infinity>. (b + x) powr c =\n  integral (einterval (ereal a) \\<infinity>) (\\<lambda>x. (b + x) powr c)\n  LBINT x:{a<..}. (b + x) powr c = - ((b + a) powr (c + 1) / (c + 1))\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. (b + x) powr c) has_integral\n     - ((b + a) powr (c + 1) / (c + 1)))\n     {a<..}", "by (simp add: has_integral_iff)"], ["proof (state)\nthis:\n  ((\\<lambda>x. (b + x) powr c) has_integral\n   - ((b + a) powr (c + 1) / (c + 1)))\n   {a<..}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma fds_converges_altdef2:\n  \"fds_converges f s \\<longleftrightarrow> convergent (\\<lambda>N. eval_fds (fds_truncate N f) s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fds_converges f s =\n    convergent (\\<lambda>N. eval_fds (fds_truncate N f) s)", "unfolding fds_converges_def summable_iff_convergent' eval_fds_truncate"], ["proof (prove)\ngoal (1 subgoal):\n 1. convergent (\\<lambda>n. \\<Sum>n\\<le>n. fds_nth f n / nat_power n s) =\n    convergent (\\<lambda>N. \\<Sum>k = 1..N. fds_nth f k / nat_power k s)", "by (auto simp: not_le intro!: convergent_cong always_eventually sum.mono_neutral_right)"], ["", "lemma tendsto_eval_fds_truncate:\n  assumes \"fds_converges f s\"\n  shows   \"(\\<lambda>N. eval_fds (fds_truncate N f) s) \\<longlonglongrightarrow> eval_fds f s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>N. eval_fds (fds_truncate N f) s)\n    \\<longlonglongrightarrow> eval_fds f s", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<lambda>N. eval_fds (fds_truncate N f) s)\n    \\<longlonglongrightarrow> eval_fds f s", "have \"(\\<lambda>N. eval_fds (fds_truncate N f) s) \\<longlonglongrightarrow> eval_fds f s \\<longleftrightarrow>\n          (\\<lambda>N. \\<Sum>i\\<le>N. fds_nth f i / nat_power i s) \\<longlonglongrightarrow> eval_fds f s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>N. eval_fds (fds_truncate N f) s)\n    \\<longlonglongrightarrow> eval_fds f s =\n    (\\<lambda>N. \\<Sum>i\\<le>N. fds_nth f i / nat_power i s)\n    \\<longlonglongrightarrow> eval_fds f s", "unfolding eval_fds_truncate"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>N. \\<Sum>k = 1..N. fds_nth f k / nat_power k s)\n    \\<longlonglongrightarrow> eval_fds f s =\n    (\\<lambda>N. \\<Sum>i\\<le>N. fds_nth f i / nat_power i s)\n    \\<longlonglongrightarrow> eval_fds f s", "by (intro filterlim_cong always_eventually allI sum.mono_neutral_left) (auto simp: not_le)"], ["proof (state)\nthis:\n  (\\<lambda>N. eval_fds (fds_truncate N f) s)\n  \\<longlonglongrightarrow> eval_fds f s =\n  (\\<lambda>N. \\<Sum>i\\<le>N. fds_nth f i / nat_power i s)\n  \\<longlonglongrightarrow> eval_fds f s\n\ngoal (1 subgoal):\n 1. (\\<lambda>N. eval_fds (fds_truncate N f) s)\n    \\<longlonglongrightarrow> eval_fds f s", "also"], ["proof (state)\nthis:\n  (\\<lambda>N. eval_fds (fds_truncate N f) s)\n  \\<longlonglongrightarrow> eval_fds f s =\n  (\\<lambda>N. \\<Sum>i\\<le>N. fds_nth f i / nat_power i s)\n  \\<longlonglongrightarrow> eval_fds f s\n\ngoal (1 subgoal):\n 1. (\\<lambda>N. eval_fds (fds_truncate N f) s)\n    \\<longlonglongrightarrow> eval_fds f s", "have \\<dots>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>N. \\<Sum>i\\<le>N. fds_nth f i / nat_power i s)\n    \\<longlonglongrightarrow> eval_fds f s", "using assms"], ["proof (prove)\nusing this:\n  fds_converges f s\n\ngoal (1 subgoal):\n 1. (\\<lambda>N. \\<Sum>i\\<le>N. fds_nth f i / nat_power i s)\n    \\<longlonglongrightarrow> eval_fds f s", "by (simp add: fds_converges_iff sums_def' atLeast0AtMost)"], ["proof (state)\nthis:\n  (\\<lambda>N. \\<Sum>i\\<le>N. fds_nth f i / nat_power i s)\n  \\<longlonglongrightarrow> eval_fds f s\n\ngoal (1 subgoal):\n 1. (\\<lambda>N. eval_fds (fds_truncate N f) s)\n    \\<longlonglongrightarrow> eval_fds f s", "finally"], ["proof (chain)\npicking this:\n  (\\<lambda>N. eval_fds (fds_truncate N f) s)\n  \\<longlonglongrightarrow> eval_fds f s", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<lambda>N. eval_fds (fds_truncate N f) s)\n  \\<longlonglongrightarrow> eval_fds f s\n\ngoal (1 subgoal):\n 1. (\\<lambda>N. eval_fds (fds_truncate N f) s)\n    \\<longlonglongrightarrow> eval_fds f s", "."], ["proof (state)\nthis:\n  (\\<lambda>N. eval_fds (fds_truncate N f) s)\n  \\<longlonglongrightarrow> eval_fds f s\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma linepath_translate_left: \"linepath (c + a) (c + a) = (\\<lambda>x. c + a) \\<circ> linepath a b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. linepath (c + a) (c + a) = (\\<lambda>x. c + a) \\<circ> linepath a b", "by (auto simp: fun_eq_iff linepath_def algebra_simps)"], ["", "lemma linepath_translate_right: \"linepath (a + c) (b + c) = (\\<lambda>x. x + c) \\<circ> linepath a b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. linepath (a + c) (b + c) = (\\<lambda>x. x + c) \\<circ> linepath a b", "by (auto simp: fun_eq_iff linepath_def algebra_simps)"], ["", "lemma integrable_on_affinity:\n  assumes \"m \\<noteq> 0\" \"f integrable_on (cbox a b)\"\n  shows   \"(\\<lambda>x. f (m *\\<^sub>R x + c)) integrable_on ((\\<lambda>x. (1 / m) *\\<^sub>R x - ((1 / m) *\\<^sub>R c)) ` cbox a b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. f (m *\\<^sub>R x + c)) integrable_on\n    (\\<lambda>x. (1 / m) *\\<^sub>R x - (1 / m) *\\<^sub>R c) ` cbox a b", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<lambda>x. f (m *\\<^sub>R x + c)) integrable_on\n    (\\<lambda>x. (1 / m) *\\<^sub>R x - (1 / m) *\\<^sub>R c) ` cbox a b", "from assms"], ["proof (chain)\npicking this:\n  m \\<noteq> 0\n  f integrable_on cbox a b", "obtain I where \"(f has_integral I) (cbox a b)\""], ["proof (prove)\nusing this:\n  m \\<noteq> 0\n  f integrable_on cbox a b\n\ngoal (1 subgoal):\n 1. (\\<And>I.\n        (f has_integral I) (cbox a b) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: integrable_on_def)"], ["proof (state)\nthis:\n  (f has_integral I) (cbox a b)\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. f (m *\\<^sub>R x + c)) integrable_on\n    (\\<lambda>x. (1 / m) *\\<^sub>R x - (1 / m) *\\<^sub>R c) ` cbox a b", "from has_integral_affinity[OF this assms(1), of c]"], ["proof (chain)\npicking this:\n  ((\\<lambda>x. f (m *\\<^sub>R x + c)) has_integral\n   (1 / \\<bar>m\\<bar> ^ DIM('a)) *\\<^sub>R I)\n   ((\\<lambda>x. (1 / m) *\\<^sub>R x + - ((1 / m) *\\<^sub>R c)) ` cbox a b)", "show ?thesis"], ["proof (prove)\nusing this:\n  ((\\<lambda>x. f (m *\\<^sub>R x + c)) has_integral\n   (1 / \\<bar>m\\<bar> ^ DIM('a)) *\\<^sub>R I)\n   ((\\<lambda>x. (1 / m) *\\<^sub>R x + - ((1 / m) *\\<^sub>R c)) ` cbox a b)\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. f (m *\\<^sub>R x + c)) integrable_on\n    (\\<lambda>x. (1 / m) *\\<^sub>R x - (1 / m) *\\<^sub>R c) ` cbox a b", "by (auto simp: integrable_on_def)"], ["proof (state)\nthis:\n  (\\<lambda>x. f (m *\\<^sub>R x + c)) integrable_on\n  (\\<lambda>x. (1 / m) *\\<^sub>R x - (1 / m) *\\<^sub>R c) ` cbox a b\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma has_integral_cmul_iff:\n  assumes \"c \\<noteq> 0\"\n  shows   \"((\\<lambda>x. c *\\<^sub>R f x) has_integral (c *\\<^sub>R I)) A \\<longleftrightarrow> (f has_integral I) A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x. c *\\<^sub>R f x) has_integral c *\\<^sub>R I) A =\n    (f has_integral I) A", "using assms has_integral_cmul[of f I A c]\n        has_integral_cmul[of \"\\<lambda>x. c *\\<^sub>R f x\" \"c *\\<^sub>R I\" A \"inverse c\"]"], ["proof (prove)\nusing this:\n  c \\<noteq> 0\n  (f has_integral I) A \\<Longrightarrow>\n  ((\\<lambda>x. c *\\<^sub>R f x) has_integral c *\\<^sub>R I) A\n  ((\\<lambda>x. c *\\<^sub>R f x) has_integral c *\\<^sub>R I)\n   A \\<Longrightarrow>\n  ((\\<lambda>x. c *\\<^sub>R f x /\\<^sub>R c) has_integral\n   c *\\<^sub>R I /\\<^sub>R c)\n   A\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. c *\\<^sub>R f x) has_integral c *\\<^sub>R I) A =\n    (f has_integral I) A", "by (auto simp: field_simps)"], ["", "lemma has_integral_affinity':\n  fixes a :: \"'a::euclidean_space\"\n  assumes \"(f has_integral i) (cbox a b)\" and \"m > 0\"\n  shows \"((\\<lambda>x. f(m *\\<^sub>R x + c)) has_integral (i /\\<^sub>R m ^ DIM('a)))\n           (cbox ((a - c) /\\<^sub>R m) ((b - c) /\\<^sub>R m))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x. f (m *\\<^sub>R x + c)) has_integral\n     i /\\<^sub>R m ^ DIM('a))\n     (cbox ((a - c) /\\<^sub>R m) ((b - c) /\\<^sub>R m))", "proof (cases \"cbox a b = {}\")"], ["proof (state)\ngoal (2 subgoals):\n 1. cbox a b = {} \\<Longrightarrow>\n    ((\\<lambda>x. f (m *\\<^sub>R x + c)) has_integral\n     i /\\<^sub>R m ^ DIM('a))\n     (cbox ((a - c) /\\<^sub>R m) ((b - c) /\\<^sub>R m))\n 2. cbox a b \\<noteq> {} \\<Longrightarrow>\n    ((\\<lambda>x. f (m *\\<^sub>R x + c)) has_integral\n     i /\\<^sub>R m ^ DIM('a))\n     (cbox ((a - c) /\\<^sub>R m) ((b - c) /\\<^sub>R m))", "case True"], ["proof (state)\nthis:\n  cbox a b = {}\n\ngoal (2 subgoals):\n 1. cbox a b = {} \\<Longrightarrow>\n    ((\\<lambda>x. f (m *\\<^sub>R x + c)) has_integral\n     i /\\<^sub>R m ^ DIM('a))\n     (cbox ((a - c) /\\<^sub>R m) ((b - c) /\\<^sub>R m))\n 2. cbox a b \\<noteq> {} \\<Longrightarrow>\n    ((\\<lambda>x. f (m *\\<^sub>R x + c)) has_integral\n     i /\\<^sub>R m ^ DIM('a))\n     (cbox ((a - c) /\\<^sub>R m) ((b - c) /\\<^sub>R m))", "hence \"(cbox ((a - c) /\\<^sub>R m) ((b - c) /\\<^sub>R m)) = {}\""], ["proof (prove)\nusing this:\n  cbox a b = {}\n\ngoal (1 subgoal):\n 1. cbox ((a - c) /\\<^sub>R m) ((b - c) /\\<^sub>R m) = {}", "using \\<open>m > 0\\<close>"], ["proof (prove)\nusing this:\n  cbox a b = {}\n  0 < m\n\ngoal (1 subgoal):\n 1. cbox ((a - c) /\\<^sub>R m) ((b - c) /\\<^sub>R m) = {}", "unfolding box_eq_empty"], ["proof (prove)\nusing this:\n  \\<exists>i\\<in>Basis. b \\<bullet> i < a \\<bullet> i\n  0 < m\n\ngoal (1 subgoal):\n 1. \\<exists>i\\<in>Basis.\n       ((b - c) /\\<^sub>R m) \\<bullet> i < ((a - c) /\\<^sub>R m) \\<bullet> i", "by (auto simp: algebra_simps)"], ["proof (state)\nthis:\n  cbox ((a - c) /\\<^sub>R m) ((b - c) /\\<^sub>R m) = {}\n\ngoal (2 subgoals):\n 1. cbox a b = {} \\<Longrightarrow>\n    ((\\<lambda>x. f (m *\\<^sub>R x + c)) has_integral\n     i /\\<^sub>R m ^ DIM('a))\n     (cbox ((a - c) /\\<^sub>R m) ((b - c) /\\<^sub>R m))\n 2. cbox a b \\<noteq> {} \\<Longrightarrow>\n    ((\\<lambda>x. f (m *\\<^sub>R x + c)) has_integral\n     i /\\<^sub>R m ^ DIM('a))\n     (cbox ((a - c) /\\<^sub>R m) ((b - c) /\\<^sub>R m))", "with True and assms"], ["proof (chain)\npicking this:\n  cbox a b = {}\n  (f has_integral i) (cbox a b)\n  0 < m\n  cbox ((a - c) /\\<^sub>R m) ((b - c) /\\<^sub>R m) = {}", "show ?thesis"], ["proof (prove)\nusing this:\n  cbox a b = {}\n  (f has_integral i) (cbox a b)\n  0 < m\n  cbox ((a - c) /\\<^sub>R m) ((b - c) /\\<^sub>R m) = {}\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. f (m *\\<^sub>R x + c)) has_integral\n     i /\\<^sub>R m ^ DIM('a))\n     (cbox ((a - c) /\\<^sub>R m) ((b - c) /\\<^sub>R m))", "by simp"], ["proof (state)\nthis:\n  ((\\<lambda>x. f (m *\\<^sub>R x + c)) has_integral i /\\<^sub>R m ^ DIM('a))\n   (cbox ((a - c) /\\<^sub>R m) ((b - c) /\\<^sub>R m))\n\ngoal (1 subgoal):\n 1. cbox a b \\<noteq> {} \\<Longrightarrow>\n    ((\\<lambda>x. f (m *\\<^sub>R x + c)) has_integral\n     i /\\<^sub>R m ^ DIM('a))\n     (cbox ((a - c) /\\<^sub>R m) ((b - c) /\\<^sub>R m))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. cbox a b \\<noteq> {} \\<Longrightarrow>\n    ((\\<lambda>x. f (m *\\<^sub>R x + c)) has_integral\n     i /\\<^sub>R m ^ DIM('a))\n     (cbox ((a - c) /\\<^sub>R m) ((b - c) /\\<^sub>R m))", "case False"], ["proof (state)\nthis:\n  cbox a b \\<noteq> {}\n\ngoal (1 subgoal):\n 1. cbox a b \\<noteq> {} \\<Longrightarrow>\n    ((\\<lambda>x. f (m *\\<^sub>R x + c)) has_integral\n     i /\\<^sub>R m ^ DIM('a))\n     (cbox ((a - c) /\\<^sub>R m) ((b - c) /\\<^sub>R m))", "have \"((\\<lambda>x. f (m *\\<^sub>R x + c)) has_integral (1 / \\<bar>m\\<bar> ^ DIM('a)) *\\<^sub>R i)\n          ((\\<lambda>x. (1 / m) *\\<^sub>R x + - ((1 / m) *\\<^sub>R c)) ` cbox a b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x. f (m *\\<^sub>R x + c)) has_integral\n     (1 / \\<bar>m\\<bar> ^ DIM('a)) *\\<^sub>R i)\n     ((\\<lambda>x. (1 / m) *\\<^sub>R x + - ((1 / m) *\\<^sub>R c)) `\n      cbox a b)", "using assms"], ["proof (prove)\nusing this:\n  (f has_integral i) (cbox a b)\n  0 < m\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. f (m *\\<^sub>R x + c)) has_integral\n     (1 / \\<bar>m\\<bar> ^ DIM('a)) *\\<^sub>R i)\n     ((\\<lambda>x. (1 / m) *\\<^sub>R x + - ((1 / m) *\\<^sub>R c)) `\n      cbox a b)", "by (intro has_integral_affinity) auto"], ["proof (state)\nthis:\n  ((\\<lambda>x. f (m *\\<^sub>R x + c)) has_integral\n   (1 / \\<bar>m\\<bar> ^ DIM('a)) *\\<^sub>R i)\n   ((\\<lambda>x. (1 / m) *\\<^sub>R x + - ((1 / m) *\\<^sub>R c)) ` cbox a b)\n\ngoal (1 subgoal):\n 1. cbox a b \\<noteq> {} \\<Longrightarrow>\n    ((\\<lambda>x. f (m *\\<^sub>R x + c)) has_integral\n     i /\\<^sub>R m ^ DIM('a))\n     (cbox ((a - c) /\\<^sub>R m) ((b - c) /\\<^sub>R m))", "also"], ["proof (state)\nthis:\n  ((\\<lambda>x. f (m *\\<^sub>R x + c)) has_integral\n   (1 / \\<bar>m\\<bar> ^ DIM('a)) *\\<^sub>R i)\n   ((\\<lambda>x. (1 / m) *\\<^sub>R x + - ((1 / m) *\\<^sub>R c)) ` cbox a b)\n\ngoal (1 subgoal):\n 1. cbox a b \\<noteq> {} \\<Longrightarrow>\n    ((\\<lambda>x. f (m *\\<^sub>R x + c)) has_integral\n     i /\\<^sub>R m ^ DIM('a))\n     (cbox ((a - c) /\\<^sub>R m) ((b - c) /\\<^sub>R m))", "have \"((\\<lambda>x. (1 / m) *\\<^sub>R x + - ((1 / m) *\\<^sub>R c)) ` cbox a b) =\n               ((\\<lambda>x.  - ((1 / m) *\\<^sub>R c) + x) ` (\\<lambda>x. (1 / m) *\\<^sub>R x) ` cbox a b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. (1 / m) *\\<^sub>R x + - ((1 / m) *\\<^sub>R c)) ` cbox a b =\n    (+) (- ((1 / m) *\\<^sub>R c)) ` (*\\<^sub>R) (1 / m) ` cbox a b", "by (simp add: image_image algebra_simps)"], ["proof (state)\nthis:\n  (\\<lambda>x. (1 / m) *\\<^sub>R x + - ((1 / m) *\\<^sub>R c)) ` cbox a b =\n  (+) (- ((1 / m) *\\<^sub>R c)) ` (*\\<^sub>R) (1 / m) ` cbox a b\n\ngoal (1 subgoal):\n 1. cbox a b \\<noteq> {} \\<Longrightarrow>\n    ((\\<lambda>x. f (m *\\<^sub>R x + c)) has_integral\n     i /\\<^sub>R m ^ DIM('a))\n     (cbox ((a - c) /\\<^sub>R m) ((b - c) /\\<^sub>R m))", "also"], ["proof (state)\nthis:\n  (\\<lambda>x. (1 / m) *\\<^sub>R x + - ((1 / m) *\\<^sub>R c)) ` cbox a b =\n  (+) (- ((1 / m) *\\<^sub>R c)) ` (*\\<^sub>R) (1 / m) ` cbox a b\n\ngoal (1 subgoal):\n 1. cbox a b \\<noteq> {} \\<Longrightarrow>\n    ((\\<lambda>x. f (m *\\<^sub>R x + c)) has_integral\n     i /\\<^sub>R m ^ DIM('a))\n     (cbox ((a - c) /\\<^sub>R m) ((b - c) /\\<^sub>R m))", "have \"(\\<lambda>x. (1 / m) *\\<^sub>R x) ` cbox a b = cbox ((1 / m) *\\<^sub>R a) ((1 / m) *\\<^sub>R b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (*\\<^sub>R) (1 / m) ` cbox a b =\n    cbox ((1 / m) *\\<^sub>R a) ((1 / m) *\\<^sub>R b)", "using \\<open>m > 0\\<close> False"], ["proof (prove)\nusing this:\n  0 < m\n  cbox a b \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (*\\<^sub>R) (1 / m) ` cbox a b =\n    cbox ((1 / m) *\\<^sub>R a) ((1 / m) *\\<^sub>R b)", "by (subst image_smult_cbox) simp_all"], ["proof (state)\nthis:\n  (*\\<^sub>R) (1 / m) ` cbox a b =\n  cbox ((1 / m) *\\<^sub>R a) ((1 / m) *\\<^sub>R b)\n\ngoal (1 subgoal):\n 1. cbox a b \\<noteq> {} \\<Longrightarrow>\n    ((\\<lambda>x. f (m *\\<^sub>R x + c)) has_integral\n     i /\\<^sub>R m ^ DIM('a))\n     (cbox ((a - c) /\\<^sub>R m) ((b - c) /\\<^sub>R m))", "also"], ["proof (state)\nthis:\n  (*\\<^sub>R) (1 / m) ` cbox a b =\n  cbox ((1 / m) *\\<^sub>R a) ((1 / m) *\\<^sub>R b)\n\ngoal (1 subgoal):\n 1. cbox a b \\<noteq> {} \\<Longrightarrow>\n    ((\\<lambda>x. f (m *\\<^sub>R x + c)) has_integral\n     i /\\<^sub>R m ^ DIM('a))\n     (cbox ((a - c) /\\<^sub>R m) ((b - c) /\\<^sub>R m))", "have \"(\\<lambda>x. - ((1 / m) *\\<^sub>R c) + x) ` \\<dots> = cbox ((a - c) /\\<^sub>R m) ((b - c) /\\<^sub>R m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (+) (- ((1 / m) *\\<^sub>R c)) `\n    cbox ((1 / m) *\\<^sub>R a) ((1 / m) *\\<^sub>R b) =\n    cbox ((a - c) /\\<^sub>R m) ((b - c) /\\<^sub>R m)", "by (subst cbox_translation [symmetric]) (simp add: field_simps vector_add_divide_simps)"], ["proof (state)\nthis:\n  (+) (- ((1 / m) *\\<^sub>R c)) `\n  cbox ((1 / m) *\\<^sub>R a) ((1 / m) *\\<^sub>R b) =\n  cbox ((a - c) /\\<^sub>R m) ((b - c) /\\<^sub>R m)\n\ngoal (1 subgoal):\n 1. cbox a b \\<noteq> {} \\<Longrightarrow>\n    ((\\<lambda>x. f (m *\\<^sub>R x + c)) has_integral\n     i /\\<^sub>R m ^ DIM('a))\n     (cbox ((a - c) /\\<^sub>R m) ((b - c) /\\<^sub>R m))", "finally"], ["proof (chain)\npicking this:\n  ((\\<lambda>x. f (m *\\<^sub>R x + c)) has_integral\n   (1 / \\<bar>m\\<bar> ^ DIM('a)) *\\<^sub>R i)\n   (cbox ((a - c) /\\<^sub>R m) ((b - c) /\\<^sub>R m))", "show ?thesis"], ["proof (prove)\nusing this:\n  ((\\<lambda>x. f (m *\\<^sub>R x + c)) has_integral\n   (1 / \\<bar>m\\<bar> ^ DIM('a)) *\\<^sub>R i)\n   (cbox ((a - c) /\\<^sub>R m) ((b - c) /\\<^sub>R m))\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. f (m *\\<^sub>R x + c)) has_integral\n     i /\\<^sub>R m ^ DIM('a))\n     (cbox ((a - c) /\\<^sub>R m) ((b - c) /\\<^sub>R m))", "using \\<open>m > 0\\<close>"], ["proof (prove)\nusing this:\n  ((\\<lambda>x. f (m *\\<^sub>R x + c)) has_integral\n   (1 / \\<bar>m\\<bar> ^ DIM('a)) *\\<^sub>R i)\n   (cbox ((a - c) /\\<^sub>R m) ((b - c) /\\<^sub>R m))\n  0 < m\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. f (m *\\<^sub>R x + c)) has_integral\n     i /\\<^sub>R m ^ DIM('a))\n     (cbox ((a - c) /\\<^sub>R m) ((b - c) /\\<^sub>R m))", "by (simp add: field_simps)"], ["proof (state)\nthis:\n  ((\\<lambda>x. f (m *\\<^sub>R x + c)) has_integral i /\\<^sub>R m ^ DIM('a))\n   (cbox ((a - c) /\\<^sub>R m) ((b - c) /\\<^sub>R m))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma has_integral_affinity_iff:\n  fixes f :: \"'a :: euclidean_space \\<Rightarrow> 'b :: real_normed_vector\"\n  assumes \"m > 0\"\n  shows   \"((\\<lambda>x. f (m *\\<^sub>R x + c)) has_integral (I /\\<^sub>R m ^ DIM('a)))\n               (cbox ((a - c) /\\<^sub>R m) ((b - c) /\\<^sub>R m)) \\<longleftrightarrow>\n           (f has_integral I) (cbox a b)\" (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x. f (m *\\<^sub>R x + c)) has_integral\n     I /\\<^sub>R m ^ DIM('a))\n     (cbox ((a - c) /\\<^sub>R m) ((b - c) /\\<^sub>R m)) =\n    (f has_integral I) (cbox a b)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. ((\\<lambda>x. f (m *\\<^sub>R x + c)) has_integral\n     I /\\<^sub>R m ^ DIM('a))\n     (cbox ((a - c) /\\<^sub>R m) ((b - c) /\\<^sub>R m)) \\<Longrightarrow>\n    (f has_integral I) (cbox a b)\n 2. (f has_integral I) (cbox a b) \\<Longrightarrow>\n    ((\\<lambda>x. f (m *\\<^sub>R x + c)) has_integral\n     I /\\<^sub>R m ^ DIM('a))\n     (cbox ((a - c) /\\<^sub>R m) ((b - c) /\\<^sub>R m))", "assume ?lhs"], ["proof (state)\nthis:\n  ((\\<lambda>x. f (m *\\<^sub>R x + c)) has_integral I /\\<^sub>R m ^ DIM('a))\n   (cbox ((a - c) /\\<^sub>R m) ((b - c) /\\<^sub>R m))\n\ngoal (2 subgoals):\n 1. ((\\<lambda>x. f (m *\\<^sub>R x + c)) has_integral\n     I /\\<^sub>R m ^ DIM('a))\n     (cbox ((a - c) /\\<^sub>R m) ((b - c) /\\<^sub>R m)) \\<Longrightarrow>\n    (f has_integral I) (cbox a b)\n 2. (f has_integral I) (cbox a b) \\<Longrightarrow>\n    ((\\<lambda>x. f (m *\\<^sub>R x + c)) has_integral\n     I /\\<^sub>R m ^ DIM('a))\n     (cbox ((a - c) /\\<^sub>R m) ((b - c) /\\<^sub>R m))", "from has_integral_affinity'[OF this, of \"1 / m\" \"-c /\\<^sub>R m\"] and \\<open>m > 0\\<close>"], ["proof (chain)\npicking this:\n  0 < 1 / m \\<Longrightarrow>\n  ((\\<lambda>x.\n       f (m *\\<^sub>R ((1 / m) *\\<^sub>R x + - c /\\<^sub>R m) +\n          c)) has_integral\n   I /\\<^sub>R m ^ DIM('a) /\\<^sub>R (1 / m) ^ DIM('a))\n   (cbox (((a - c) /\\<^sub>R m - - c /\\<^sub>R m) /\\<^sub>R (1 / m))\n     (((b - c) /\\<^sub>R m - - c /\\<^sub>R m) /\\<^sub>R (1 / m)))\n  0 < m", "show ?rhs"], ["proof (prove)\nusing this:\n  0 < 1 / m \\<Longrightarrow>\n  ((\\<lambda>x.\n       f (m *\\<^sub>R ((1 / m) *\\<^sub>R x + - c /\\<^sub>R m) +\n          c)) has_integral\n   I /\\<^sub>R m ^ DIM('a) /\\<^sub>R (1 / m) ^ DIM('a))\n   (cbox (((a - c) /\\<^sub>R m - - c /\\<^sub>R m) /\\<^sub>R (1 / m))\n     (((b - c) /\\<^sub>R m - - c /\\<^sub>R m) /\\<^sub>R (1 / m)))\n  0 < m\n\ngoal (1 subgoal):\n 1. (f has_integral I) (cbox a b)", "by (simp add: vector_add_divide_simps) (simp add: field_simps)"], ["proof (state)\nthis:\n  (f has_integral I) (cbox a b)\n\ngoal (1 subgoal):\n 1. (f has_integral I) (cbox a b) \\<Longrightarrow>\n    ((\\<lambda>x. f (m *\\<^sub>R x + c)) has_integral\n     I /\\<^sub>R m ^ DIM('a))\n     (cbox ((a - c) /\\<^sub>R m) ((b - c) /\\<^sub>R m))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (f has_integral I) (cbox a b) \\<Longrightarrow>\n    ((\\<lambda>x. f (m *\\<^sub>R x + c)) has_integral\n     I /\\<^sub>R m ^ DIM('a))\n     (cbox ((a - c) /\\<^sub>R m) ((b - c) /\\<^sub>R m))", "assume ?rhs"], ["proof (state)\nthis:\n  (f has_integral I) (cbox a b)\n\ngoal (1 subgoal):\n 1. (f has_integral I) (cbox a b) \\<Longrightarrow>\n    ((\\<lambda>x. f (m *\\<^sub>R x + c)) has_integral\n     I /\\<^sub>R m ^ DIM('a))\n     (cbox ((a - c) /\\<^sub>R m) ((b - c) /\\<^sub>R m))", "from has_integral_affinity'[OF this, of m c] and \\<open>m > 0\\<close>"], ["proof (chain)\npicking this:\n  0 < m \\<Longrightarrow>\n  ((\\<lambda>x. f (m *\\<^sub>R x + c)) has_integral I /\\<^sub>R m ^ DIM('a))\n   (cbox ((a - c) /\\<^sub>R m) ((b - c) /\\<^sub>R m))\n  0 < m", "show ?lhs"], ["proof (prove)\nusing this:\n  0 < m \\<Longrightarrow>\n  ((\\<lambda>x. f (m *\\<^sub>R x + c)) has_integral I /\\<^sub>R m ^ DIM('a))\n   (cbox ((a - c) /\\<^sub>R m) ((b - c) /\\<^sub>R m))\n  0 < m\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. f (m *\\<^sub>R x + c)) has_integral\n     I /\\<^sub>R m ^ DIM('a))\n     (cbox ((a - c) /\\<^sub>R m) ((b - c) /\\<^sub>R m))", "by simp"], ["proof (state)\nthis:\n  ((\\<lambda>x. f (m *\\<^sub>R x + c)) has_integral I /\\<^sub>R m ^ DIM('a))\n   (cbox ((a - c) /\\<^sub>R m) ((b - c) /\\<^sub>R m))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma has_contour_integral_linepath_Reals_iff:\n  fixes a b :: complex and f :: \"complex \\<Rightarrow> complex\"\n  assumes \"a \\<in> Reals\" \"b \\<in> Reals\" \"Re a < Re b\"\n  shows   \"(f has_contour_integral I) (linepath a b) \\<longleftrightarrow>\n             ((\\<lambda>x. f (of_real x)) has_integral I) {Re a..Re b}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f has_contour_integral I) (linepath a b) =\n    ((\\<lambda>x. f (complex_of_real x)) has_integral I) {Re a..Re b}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (f has_contour_integral I) (linepath a b) =\n    ((\\<lambda>x. f (complex_of_real x)) has_integral I) {Re a..Re b}", "from assms"], ["proof (chain)\npicking this:\n  a \\<in> \\<real>\n  b \\<in> \\<real>\n  Re a < Re b", "have [simp]: \"of_real (Re a) = a\" \"of_real (Re b) = b\""], ["proof (prove)\nusing this:\n  a \\<in> \\<real>\n  b \\<in> \\<real>\n  Re a < Re b\n\ngoal (1 subgoal):\n 1. complex_of_real (Re a) = a &&& complex_of_real (Re b) = b", "by (simp_all add: complex_eq_iff)"], ["proof (state)\nthis:\n  complex_of_real (Re a) = a\n  complex_of_real (Re b) = b\n\ngoal (1 subgoal):\n 1. (f has_contour_integral I) (linepath a b) =\n    ((\\<lambda>x. f (complex_of_real x)) has_integral I) {Re a..Re b}", "from assms"], ["proof (chain)\npicking this:\n  a \\<in> \\<real>\n  b \\<in> \\<real>\n  Re a < Re b", "have \"a \\<noteq> b\""], ["proof (prove)\nusing this:\n  a \\<in> \\<real>\n  b \\<in> \\<real>\n  Re a < Re b\n\ngoal (1 subgoal):\n 1. a \\<noteq> b", "by auto"], ["proof (state)\nthis:\n  a \\<noteq> b\n\ngoal (1 subgoal):\n 1. (f has_contour_integral I) (linepath a b) =\n    ((\\<lambda>x. f (complex_of_real x)) has_integral I) {Re a..Re b}", "have \"((\\<lambda>x. f (of_real x)) has_integral I) (cbox (Re a) (Re b)) \\<longleftrightarrow>\n          ((\\<lambda>x. f (a + b * of_real x - a * of_real x)) has_integral I /\\<^sub>R (Re b - Re a)) {0..1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x. f (complex_of_real x)) has_integral I)\n     (cbox (Re a) (Re b)) =\n    ((\\<lambda>x.\n         f (a + b * complex_of_real x - a * complex_of_real x)) has_integral\n     I /\\<^sub>R (Re b - Re a))\n     {0..1}", "by (subst has_integral_affinity_iff [of \"Re b - Re a\" _ \"Re a\", symmetric])\n       (insert assms, simp_all add: field_simps scaleR_conv_of_real)"], ["proof (state)\nthis:\n  ((\\<lambda>x. f (complex_of_real x)) has_integral I)\n   (cbox (Re a) (Re b)) =\n  ((\\<lambda>x.\n       f (a + b * complex_of_real x - a * complex_of_real x)) has_integral\n   I /\\<^sub>R (Re b - Re a))\n   {0..1}\n\ngoal (1 subgoal):\n 1. (f has_contour_integral I) (linepath a b) =\n    ((\\<lambda>x. f (complex_of_real x)) has_integral I) {Re a..Re b}", "also"], ["proof (state)\nthis:\n  ((\\<lambda>x. f (complex_of_real x)) has_integral I)\n   (cbox (Re a) (Re b)) =\n  ((\\<lambda>x.\n       f (a + b * complex_of_real x - a * complex_of_real x)) has_integral\n   I /\\<^sub>R (Re b - Re a))\n   {0..1}\n\ngoal (1 subgoal):\n 1. (f has_contour_integral I) (linepath a b) =\n    ((\\<lambda>x. f (complex_of_real x)) has_integral I) {Re a..Re b}", "have \"(\\<lambda>x. f (a + b * of_real x - a * of_real x)) =\n               (\\<lambda>x. (f (a + b * of_real x - a * of_real x) * (b - a)) /\\<^sub>R (Re b - Re a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. f (a + b * complex_of_real x - a * complex_of_real x)) =\n    (\\<lambda>x.\n        f (a + b * complex_of_real x - a * complex_of_real x) *\n        (b - a) /\\<^sub>R\n        (Re b - Re a))", "using \\<open>a \\<noteq> b\\<close>"], ["proof (prove)\nusing this:\n  a \\<noteq> b\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. f (a + b * complex_of_real x - a * complex_of_real x)) =\n    (\\<lambda>x.\n        f (a + b * complex_of_real x - a * complex_of_real x) *\n        (b - a) /\\<^sub>R\n        (Re b - Re a))", "by (auto simp: field_simps fun_eq_iff scaleR_conv_of_real)"], ["proof (state)\nthis:\n  (\\<lambda>x. f (a + b * complex_of_real x - a * complex_of_real x)) =\n  (\\<lambda>x.\n      f (a + b * complex_of_real x - a * complex_of_real x) *\n      (b - a) /\\<^sub>R\n      (Re b - Re a))\n\ngoal (1 subgoal):\n 1. (f has_contour_integral I) (linepath a b) =\n    ((\\<lambda>x. f (complex_of_real x)) has_integral I) {Re a..Re b}", "also"], ["proof (state)\nthis:\n  (\\<lambda>x. f (a + b * complex_of_real x - a * complex_of_real x)) =\n  (\\<lambda>x.\n      f (a + b * complex_of_real x - a * complex_of_real x) *\n      (b - a) /\\<^sub>R\n      (Re b - Re a))\n\ngoal (1 subgoal):\n 1. (f has_contour_integral I) (linepath a b) =\n    ((\\<lambda>x. f (complex_of_real x)) has_integral I) {Re a..Re b}", "have \"(\\<dots> has_integral I /\\<^sub>R (Re b - Re a)) {0..1} \\<longleftrightarrow>\n               ((\\<lambda>x. f (linepath a b x) * (b - a)) has_integral I) {0..1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x.\n         f (a + b * complex_of_real x - a * complex_of_real x) *\n         (b - a) /\\<^sub>R\n         (Re b - Re a)) has_integral\n     I /\\<^sub>R (Re b - Re a))\n     {0..1} =\n    ((\\<lambda>x. f (linepath a b x) * (b - a)) has_integral I) {0..1}", "using assms"], ["proof (prove)\nusing this:\n  a \\<in> \\<real>\n  b \\<in> \\<real>\n  Re a < Re b\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x.\n         f (a + b * complex_of_real x - a * complex_of_real x) *\n         (b - a) /\\<^sub>R\n         (Re b - Re a)) has_integral\n     I /\\<^sub>R (Re b - Re a))\n     {0..1} =\n    ((\\<lambda>x. f (linepath a b x) * (b - a)) has_integral I) {0..1}", "by (subst has_integral_cmul_iff) (auto simp: linepath_def scaleR_conv_of_real algebra_simps)"], ["proof (state)\nthis:\n  ((\\<lambda>x.\n       f (a + b * complex_of_real x - a * complex_of_real x) *\n       (b - a) /\\<^sub>R\n       (Re b - Re a)) has_integral\n   I /\\<^sub>R (Re b - Re a))\n   {0..1} =\n  ((\\<lambda>x. f (linepath a b x) * (b - a)) has_integral I) {0..1}\n\ngoal (1 subgoal):\n 1. (f has_contour_integral I) (linepath a b) =\n    ((\\<lambda>x. f (complex_of_real x)) has_integral I) {Re a..Re b}", "also"], ["proof (state)\nthis:\n  ((\\<lambda>x.\n       f (a + b * complex_of_real x - a * complex_of_real x) *\n       (b - a) /\\<^sub>R\n       (Re b - Re a)) has_integral\n   I /\\<^sub>R (Re b - Re a))\n   {0..1} =\n  ((\\<lambda>x. f (linepath a b x) * (b - a)) has_integral I) {0..1}\n\ngoal (1 subgoal):\n 1. (f has_contour_integral I) (linepath a b) =\n    ((\\<lambda>x. f (complex_of_real x)) has_integral I) {Re a..Re b}", "have \"\\<dots> \\<longleftrightarrow> (f has_contour_integral I) (linepath a b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x. f (linepath a b x) * (b - a)) has_integral I) {0..1} =\n    (f has_contour_integral I) (linepath a b)", "unfolding has_contour_integral_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x. f (linepath a b x) * (b - a)) has_integral I) {0..1} =\n    ((\\<lambda>x.\n         f (linepath a b x) *\n         vector_derivative (linepath a b) (at x within {0..1})) has_integral\n     I)\n     {0..1}", "by (intro has_integral_cong) (simp add: vector_derivative_linepath_within)"], ["proof (state)\nthis:\n  ((\\<lambda>x. f (linepath a b x) * (b - a)) has_integral I) {0..1} =\n  (f has_contour_integral I) (linepath a b)\n\ngoal (1 subgoal):\n 1. (f has_contour_integral I) (linepath a b) =\n    ((\\<lambda>x. f (complex_of_real x)) has_integral I) {Re a..Re b}", "finally"], ["proof (chain)\npicking this:\n  ((\\<lambda>x. f (complex_of_real x)) has_integral I)\n   (cbox (Re a) (Re b)) =\n  (f has_contour_integral I) (linepath a b)", "show ?thesis"], ["proof (prove)\nusing this:\n  ((\\<lambda>x. f (complex_of_real x)) has_integral I)\n   (cbox (Re a) (Re b)) =\n  (f has_contour_integral I) (linepath a b)\n\ngoal (1 subgoal):\n 1. (f has_contour_integral I) (linepath a b) =\n    ((\\<lambda>x. f (complex_of_real x)) has_integral I) {Re a..Re b}", "by simp"], ["proof (state)\nthis:\n  (f has_contour_integral I) (linepath a b) =\n  ((\\<lambda>x. f (complex_of_real x)) has_integral I) {Re a..Re b}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma contour_integrable_linepath_Reals_iff:\n  fixes a b :: complex and f :: \"complex \\<Rightarrow> complex\"\n  assumes \"a \\<in> Reals\" \"b \\<in> Reals\" \"Re a < Re b\"\n  shows   \"(f contour_integrable_on linepath a b) \\<longleftrightarrow>\n             (\\<lambda>x. f (of_real x)) integrable_on {Re a..Re b}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f contour_integrable_on linepath a b) =\n    ((\\<lambda>x. f (complex_of_real x)) integrable_on {Re a..Re b})", "using has_contour_integral_linepath_Reals_iff[OF assms, of f]"], ["proof (prove)\nusing this:\n  (f has_contour_integral ?I) (linepath a b) =\n  ((\\<lambda>x. f (complex_of_real x)) has_integral ?I) {Re a..Re b}\n\ngoal (1 subgoal):\n 1. (f contour_integrable_on linepath a b) =\n    ((\\<lambda>x. f (complex_of_real x)) integrable_on {Re a..Re b})", "by (auto simp: contour_integrable_on_def integrable_on_def)"], ["", "lemma contour_integral_linepath_Reals_eq:\n  fixes a b :: complex and f :: \"complex \\<Rightarrow> complex\"\n  assumes \"a \\<in> Reals\" \"b \\<in> Reals\" \"Re a < Re b\"\n  shows   \"contour_integral (linepath a b) f = integral {Re a..Re b} (\\<lambda>x. f (of_real x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. contour_integral (linepath a b) f =\n    integral {Re a..Re b} (\\<lambda>x. f (complex_of_real x))", "proof (cases \"f contour_integrable_on linepath a b\")"], ["proof (state)\ngoal (2 subgoals):\n 1. f contour_integrable_on linepath a b \\<Longrightarrow>\n    contour_integral (linepath a b) f =\n    integral {Re a..Re b} (\\<lambda>x. f (complex_of_real x))\n 2. \\<not> f contour_integrable_on linepath a b \\<Longrightarrow>\n    contour_integral (linepath a b) f =\n    integral {Re a..Re b} (\\<lambda>x. f (complex_of_real x))", "case True"], ["proof (state)\nthis:\n  f contour_integrable_on linepath a b\n\ngoal (2 subgoals):\n 1. f contour_integrable_on linepath a b \\<Longrightarrow>\n    contour_integral (linepath a b) f =\n    integral {Re a..Re b} (\\<lambda>x. f (complex_of_real x))\n 2. \\<not> f contour_integrable_on linepath a b \\<Longrightarrow>\n    contour_integral (linepath a b) f =\n    integral {Re a..Re b} (\\<lambda>x. f (complex_of_real x))", "thus ?thesis"], ["proof (prove)\nusing this:\n  f contour_integrable_on linepath a b\n\ngoal (1 subgoal):\n 1. contour_integral (linepath a b) f =\n    integral {Re a..Re b} (\\<lambda>x. f (complex_of_real x))", "using has_contour_integral_linepath_Reals_iff[OF assms, of f]"], ["proof (prove)\nusing this:\n  f contour_integrable_on linepath a b\n  (f has_contour_integral ?I) (linepath a b) =\n  ((\\<lambda>x. f (complex_of_real x)) has_integral ?I) {Re a..Re b}\n\ngoal (1 subgoal):\n 1. contour_integral (linepath a b) f =\n    integral {Re a..Re b} (\\<lambda>x. f (complex_of_real x))", "using has_contour_integral_integral has_contour_integral_unique"], ["proof (prove)\nusing this:\n  f contour_integrable_on linepath a b\n  (f has_contour_integral ?I) (linepath a b) =\n  ((\\<lambda>x. f (complex_of_real x)) has_integral ?I) {Re a..Re b}\n  ?f contour_integrable_on ?i \\<Longrightarrow>\n  (?f has_contour_integral contour_integral ?i ?f) ?i\n  \\<lbrakk>(?f has_contour_integral ?i) ?g;\n   (?f has_contour_integral ?j) ?g\\<rbrakk>\n  \\<Longrightarrow> ?i = ?j\n\ngoal (1 subgoal):\n 1. contour_integral (linepath a b) f =\n    integral {Re a..Re b} (\\<lambda>x. f (complex_of_real x))", "by blast"], ["proof (state)\nthis:\n  contour_integral (linepath a b) f =\n  integral {Re a..Re b} (\\<lambda>x. f (complex_of_real x))\n\ngoal (1 subgoal):\n 1. \\<not> f contour_integrable_on linepath a b \\<Longrightarrow>\n    contour_integral (linepath a b) f =\n    integral {Re a..Re b} (\\<lambda>x. f (complex_of_real x))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> f contour_integrable_on linepath a b \\<Longrightarrow>\n    contour_integral (linepath a b) f =\n    integral {Re a..Re b} (\\<lambda>x. f (complex_of_real x))", "case False"], ["proof (state)\nthis:\n  \\<not> f contour_integrable_on linepath a b\n\ngoal (1 subgoal):\n 1. \\<not> f contour_integrable_on linepath a b \\<Longrightarrow>\n    contour_integral (linepath a b) f =\n    integral {Re a..Re b} (\\<lambda>x. f (complex_of_real x))", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> f contour_integrable_on linepath a b\n\ngoal (1 subgoal):\n 1. contour_integral (linepath a b) f =\n    integral {Re a..Re b} (\\<lambda>x. f (complex_of_real x))", "using contour_integrable_linepath_Reals_iff[OF assms, of f]"], ["proof (prove)\nusing this:\n  \\<not> f contour_integrable_on linepath a b\n  (f contour_integrable_on linepath a b) =\n  ((\\<lambda>x. f (complex_of_real x)) integrable_on {Re a..Re b})\n\ngoal (1 subgoal):\n 1. contour_integral (linepath a b) f =\n    integral {Re a..Re b} (\\<lambda>x. f (complex_of_real x))", "by (simp add: not_integrable_contour_integral not_integrable_integral)"], ["proof (state)\nthis:\n  contour_integral (linepath a b) f =\n  integral {Re a..Re b} (\\<lambda>x. f (complex_of_real x))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma has_contour_integral_linepath_same_Im_iff:\n  fixes a b :: complex and f :: \"complex \\<Rightarrow> complex\"\n  assumes \"Im a = Im b\" \"Re a < Re b\"\n  shows   \"(f has_contour_integral I) (linepath a b) \\<longleftrightarrow>\n             ((\\<lambda>x. f (of_real x + Im a * \\<i>)) has_integral I) {Re a..Re b}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f has_contour_integral I) (linepath a b) =\n    ((\\<lambda>x.\n         f (complex_of_real x + complex_of_real (Im a) * \\<i>)) has_integral\n     I)\n     {Re a..Re b}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (f has_contour_integral I) (linepath a b) =\n    ((\\<lambda>x.\n         f (complex_of_real x + complex_of_real (Im a) * \\<i>)) has_integral\n     I)\n     {Re a..Re b}", "have deriv: \"vector_derivative ((\\<lambda>x. x - Im a * \\<i>) \\<circ> linepath a b) (at y) = b - a\" for y"], ["proof (prove)\ngoal (1 subgoal):\n 1. vector_derivative\n     ((\\<lambda>x. x - complex_of_real (Im a) * \\<i>) \\<circ> linepath a b)\n     (at y) =\n    b - a", "using linepath_translate_right[of a \"-Im a * \\<i>\" b, symmetric]"], ["proof (prove)\nusing this:\n  (\\<lambda>x. x + complex_of_real (- Im a) * \\<i>) \\<circ> linepath a b =\n  linepath (a + complex_of_real (- Im a) * \\<i>)\n   (b + complex_of_real (- Im a) * \\<i>)\n\ngoal (1 subgoal):\n 1. vector_derivative\n     ((\\<lambda>x. x - complex_of_real (Im a) * \\<i>) \\<circ> linepath a b)\n     (at y) =\n    b - a", "by simp"], ["proof (state)\nthis:\n  vector_derivative\n   ((\\<lambda>x. x - complex_of_real (Im a) * \\<i>) \\<circ> linepath a b)\n   (at ?y) =\n  b - a\n\ngoal (1 subgoal):\n 1. (f has_contour_integral I) (linepath a b) =\n    ((\\<lambda>x.\n         f (complex_of_real x + complex_of_real (Im a) * \\<i>)) has_integral\n     I)\n     {Re a..Re b}", "have \"(f has_contour_integral I) (linepath a b) \\<longleftrightarrow>\n          ((\\<lambda>x. f (x + Im a * \\<i>)) has_contour_integral I) (linepath (a - Im a * \\<i>) (b - Im a * \\<i>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f has_contour_integral I) (linepath a b) =\n    ((\\<lambda>x.\n         f (x + complex_of_real (Im a) * \\<i>)) has_contour_integral\n     I)\n     (linepath (a - complex_of_real (Im a) * \\<i>)\n       (b - complex_of_real (Im a) * \\<i>))", "using linepath_translate_right[of a \"-Im a * \\<i>\" b] deriv"], ["proof (prove)\nusing this:\n  linepath (a + complex_of_real (- Im a) * \\<i>)\n   (b + complex_of_real (- Im a) * \\<i>) =\n  (\\<lambda>x. x + complex_of_real (- Im a) * \\<i>) \\<circ> linepath a b\n  vector_derivative\n   ((\\<lambda>x. x - complex_of_real (Im a) * \\<i>) \\<circ> linepath a b)\n   (at ?y) =\n  b - a\n\ngoal (1 subgoal):\n 1. (f has_contour_integral I) (linepath a b) =\n    ((\\<lambda>x.\n         f (x + complex_of_real (Im a) * \\<i>)) has_contour_integral\n     I)\n     (linepath (a - complex_of_real (Im a) * \\<i>)\n       (b - complex_of_real (Im a) * \\<i>))", "by (simp add: has_contour_integral)"], ["proof (state)\nthis:\n  (f has_contour_integral I) (linepath a b) =\n  ((\\<lambda>x. f (x + complex_of_real (Im a) * \\<i>)) has_contour_integral\n   I)\n   (linepath (a - complex_of_real (Im a) * \\<i>)\n     (b - complex_of_real (Im a) * \\<i>))\n\ngoal (1 subgoal):\n 1. (f has_contour_integral I) (linepath a b) =\n    ((\\<lambda>x.\n         f (complex_of_real x + complex_of_real (Im a) * \\<i>)) has_integral\n     I)\n     {Re a..Re b}", "also"], ["proof (state)\nthis:\n  (f has_contour_integral I) (linepath a b) =\n  ((\\<lambda>x. f (x + complex_of_real (Im a) * \\<i>)) has_contour_integral\n   I)\n   (linepath (a - complex_of_real (Im a) * \\<i>)\n     (b - complex_of_real (Im a) * \\<i>))\n\ngoal (1 subgoal):\n 1. (f has_contour_integral I) (linepath a b) =\n    ((\\<lambda>x.\n         f (complex_of_real x + complex_of_real (Im a) * \\<i>)) has_integral\n     I)\n     {Re a..Re b}", "have \"\\<dots> \\<longleftrightarrow> ((\\<lambda>x. f (x + Im a * \\<i>)) has_integral I) {Re a..Re b}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x.\n         f (x + complex_of_real (Im a) * \\<i>)) has_contour_integral\n     I)\n     (linepath (a - complex_of_real (Im a) * \\<i>)\n       (b - complex_of_real (Im a) * \\<i>)) =\n    ((\\<lambda>x.\n         f (complex_of_real x + complex_of_real (Im a) * \\<i>)) has_integral\n     I)\n     {Re a..Re b}", "using assms"], ["proof (prove)\nusing this:\n  Im a = Im b\n  Re a < Re b\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x.\n         f (x + complex_of_real (Im a) * \\<i>)) has_contour_integral\n     I)\n     (linepath (a - complex_of_real (Im a) * \\<i>)\n       (b - complex_of_real (Im a) * \\<i>)) =\n    ((\\<lambda>x.\n         f (complex_of_real x + complex_of_real (Im a) * \\<i>)) has_integral\n     I)\n     {Re a..Re b}", "by (subst has_contour_integral_linepath_Reals_iff) (auto simp: complex_is_Real_iff)"], ["proof (state)\nthis:\n  ((\\<lambda>x. f (x + complex_of_real (Im a) * \\<i>)) has_contour_integral\n   I)\n   (linepath (a - complex_of_real (Im a) * \\<i>)\n     (b - complex_of_real (Im a) * \\<i>)) =\n  ((\\<lambda>x.\n       f (complex_of_real x + complex_of_real (Im a) * \\<i>)) has_integral\n   I)\n   {Re a..Re b}\n\ngoal (1 subgoal):\n 1. (f has_contour_integral I) (linepath a b) =\n    ((\\<lambda>x.\n         f (complex_of_real x + complex_of_real (Im a) * \\<i>)) has_integral\n     I)\n     {Re a..Re b}", "finally"], ["proof (chain)\npicking this:\n  (f has_contour_integral I) (linepath a b) =\n  ((\\<lambda>x.\n       f (complex_of_real x + complex_of_real (Im a) * \\<i>)) has_integral\n   I)\n   {Re a..Re b}", "show ?thesis"], ["proof (prove)\nusing this:\n  (f has_contour_integral I) (linepath a b) =\n  ((\\<lambda>x.\n       f (complex_of_real x + complex_of_real (Im a) * \\<i>)) has_integral\n   I)\n   {Re a..Re b}\n\ngoal (1 subgoal):\n 1. (f has_contour_integral I) (linepath a b) =\n    ((\\<lambda>x.\n         f (complex_of_real x + complex_of_real (Im a) * \\<i>)) has_integral\n     I)\n     {Re a..Re b}", "."], ["proof (state)\nthis:\n  (f has_contour_integral I) (linepath a b) =\n  ((\\<lambda>x.\n       f (complex_of_real x + complex_of_real (Im a) * \\<i>)) has_integral\n   I)\n   {Re a..Re b}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma contour_integrable_linepath_same_Im_iff:\n  fixes a b :: complex and f :: \"complex \\<Rightarrow> complex\"\n  assumes \"Im a = Im b\" \"Re a < Re b\"\n  shows   \"(f contour_integrable_on linepath a b) \\<longleftrightarrow>\n             (\\<lambda>x. f (of_real x + Im a * \\<i>)) integrable_on {Re a..Re b}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f contour_integrable_on linepath a b) =\n    ((\\<lambda>x.\n         f (complex_of_real x +\n            complex_of_real (Im a) * \\<i>)) integrable_on\n     {Re a..Re b})", "using has_contour_integral_linepath_same_Im_iff[OF assms, of f]"], ["proof (prove)\nusing this:\n  (f has_contour_integral ?I) (linepath a b) =\n  ((\\<lambda>x.\n       f (complex_of_real x + complex_of_real (Im a) * \\<i>)) has_integral\n   ?I)\n   {Re a..Re b}\n\ngoal (1 subgoal):\n 1. (f contour_integrable_on linepath a b) =\n    ((\\<lambda>x.\n         f (complex_of_real x +\n            complex_of_real (Im a) * \\<i>)) integrable_on\n     {Re a..Re b})", "by (auto simp: contour_integrable_on_def integrable_on_def)"], ["", "lemma contour_integral_linepath_same_Im:\n  fixes a b :: complex and f :: \"complex \\<Rightarrow> complex\"\n  assumes \"Im a = Im b\" \"Re a < Re b\"\n  shows   \"contour_integral (linepath a b) f = integral {Re a..Re b} (\\<lambda>x. f (x + Im a * \\<i>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. contour_integral (linepath a b) f =\n    integral {Re a..Re b}\n     (\\<lambda>x. f (complex_of_real x + complex_of_real (Im a) * \\<i>))", "proof (cases \"f contour_integrable_on linepath a b\")"], ["proof (state)\ngoal (2 subgoals):\n 1. f contour_integrable_on linepath a b \\<Longrightarrow>\n    contour_integral (linepath a b) f =\n    integral {Re a..Re b}\n     (\\<lambda>x. f (complex_of_real x + complex_of_real (Im a) * \\<i>))\n 2. \\<not> f contour_integrable_on linepath a b \\<Longrightarrow>\n    contour_integral (linepath a b) f =\n    integral {Re a..Re b}\n     (\\<lambda>x. f (complex_of_real x + complex_of_real (Im a) * \\<i>))", "case True"], ["proof (state)\nthis:\n  f contour_integrable_on linepath a b\n\ngoal (2 subgoals):\n 1. f contour_integrable_on linepath a b \\<Longrightarrow>\n    contour_integral (linepath a b) f =\n    integral {Re a..Re b}\n     (\\<lambda>x. f (complex_of_real x + complex_of_real (Im a) * \\<i>))\n 2. \\<not> f contour_integrable_on linepath a b \\<Longrightarrow>\n    contour_integral (linepath a b) f =\n    integral {Re a..Re b}\n     (\\<lambda>x. f (complex_of_real x + complex_of_real (Im a) * \\<i>))", "thus ?thesis"], ["proof (prove)\nusing this:\n  f contour_integrable_on linepath a b\n\ngoal (1 subgoal):\n 1. contour_integral (linepath a b) f =\n    integral {Re a..Re b}\n     (\\<lambda>x. f (complex_of_real x + complex_of_real (Im a) * \\<i>))", "using has_contour_integral_linepath_same_Im_iff[OF assms, of f]"], ["proof (prove)\nusing this:\n  f contour_integrable_on linepath a b\n  (f has_contour_integral ?I) (linepath a b) =\n  ((\\<lambda>x.\n       f (complex_of_real x + complex_of_real (Im a) * \\<i>)) has_integral\n   ?I)\n   {Re a..Re b}\n\ngoal (1 subgoal):\n 1. contour_integral (linepath a b) f =\n    integral {Re a..Re b}\n     (\\<lambda>x. f (complex_of_real x + complex_of_real (Im a) * \\<i>))", "using has_contour_integral_integral has_contour_integral_unique"], ["proof (prove)\nusing this:\n  f contour_integrable_on linepath a b\n  (f has_contour_integral ?I) (linepath a b) =\n  ((\\<lambda>x.\n       f (complex_of_real x + complex_of_real (Im a) * \\<i>)) has_integral\n   ?I)\n   {Re a..Re b}\n  ?f contour_integrable_on ?i \\<Longrightarrow>\n  (?f has_contour_integral contour_integral ?i ?f) ?i\n  \\<lbrakk>(?f has_contour_integral ?i) ?g;\n   (?f has_contour_integral ?j) ?g\\<rbrakk>\n  \\<Longrightarrow> ?i = ?j\n\ngoal (1 subgoal):\n 1. contour_integral (linepath a b) f =\n    integral {Re a..Re b}\n     (\\<lambda>x. f (complex_of_real x + complex_of_real (Im a) * \\<i>))", "by blast"], ["proof (state)\nthis:\n  contour_integral (linepath a b) f =\n  integral {Re a..Re b}\n   (\\<lambda>x. f (complex_of_real x + complex_of_real (Im a) * \\<i>))\n\ngoal (1 subgoal):\n 1. \\<not> f contour_integrable_on linepath a b \\<Longrightarrow>\n    contour_integral (linepath a b) f =\n    integral {Re a..Re b}\n     (\\<lambda>x. f (complex_of_real x + complex_of_real (Im a) * \\<i>))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> f contour_integrable_on linepath a b \\<Longrightarrow>\n    contour_integral (linepath a b) f =\n    integral {Re a..Re b}\n     (\\<lambda>x. f (complex_of_real x + complex_of_real (Im a) * \\<i>))", "case False"], ["proof (state)\nthis:\n  \\<not> f contour_integrable_on linepath a b\n\ngoal (1 subgoal):\n 1. \\<not> f contour_integrable_on linepath a b \\<Longrightarrow>\n    contour_integral (linepath a b) f =\n    integral {Re a..Re b}\n     (\\<lambda>x. f (complex_of_real x + complex_of_real (Im a) * \\<i>))", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> f contour_integrable_on linepath a b\n\ngoal (1 subgoal):\n 1. contour_integral (linepath a b) f =\n    integral {Re a..Re b}\n     (\\<lambda>x. f (complex_of_real x + complex_of_real (Im a) * \\<i>))", "using contour_integrable_linepath_same_Im_iff[OF assms, of f]"], ["proof (prove)\nusing this:\n  \\<not> f contour_integrable_on linepath a b\n  (f contour_integrable_on linepath a b) =\n  ((\\<lambda>x.\n       f (complex_of_real x + complex_of_real (Im a) * \\<i>)) integrable_on\n   {Re a..Re b})\n\ngoal (1 subgoal):\n 1. contour_integral (linepath a b) f =\n    integral {Re a..Re b}\n     (\\<lambda>x. f (complex_of_real x + complex_of_real (Im a) * \\<i>))", "by (simp add: not_integrable_contour_integral not_integrable_integral)"], ["proof (state)\nthis:\n  contour_integral (linepath a b) f =\n  integral {Re a..Re b}\n   (\\<lambda>x. f (complex_of_real x + complex_of_real (Im a) * \\<i>))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemmas [simp del] = div_mult_self3 div_mult_self4 div_mult_self2 div_mult_self1"], ["", "lemma continuous_on_compact_bound:\n  assumes \"compact A\" \"continuous_on A f\"\n  obtains B where \"B \\<ge> 0\" \"\\<And>x. x \\<in> A \\<Longrightarrow> norm (f x) \\<le> B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>B.\n        \\<lbrakk>0 \\<le> B;\n         \\<And>x. x \\<in> A \\<Longrightarrow> norm (f x) \\<le> B\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>B.\n        \\<lbrakk>0 \\<le> B;\n         \\<And>x. x \\<in> A \\<Longrightarrow> norm (f x) \\<le> B\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from assms(2,1)"], ["proof (chain)\npicking this:\n  continuous_on A f\n  compact A", "have \"compact (f ` A)\""], ["proof (prove)\nusing this:\n  continuous_on A f\n  compact A\n\ngoal (1 subgoal):\n 1. compact (f ` A)", "by (rule compact_continuous_image)"], ["proof (state)\nthis:\n  compact (f ` A)\n\ngoal (1 subgoal):\n 1. (\\<And>B.\n        \\<lbrakk>0 \\<le> B;\n         \\<And>x. x \\<in> A \\<Longrightarrow> norm (f x) \\<le> B\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  compact (f ` A)", "obtain B where \"\\<forall>x\\<in>A. norm (f x) \\<le> B\""], ["proof (prove)\nusing this:\n  compact (f ` A)\n\ngoal (1 subgoal):\n 1. (\\<And>B.\n        \\<forall>x\\<in>A. norm (f x) \\<le> B \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (auto dest!: compact_imp_bounded simp: bounded_iff)"], ["proof (state)\nthis:\n  \\<forall>x\\<in>A. norm (f x) \\<le> B\n\ngoal (1 subgoal):\n 1. (\\<And>B.\n        \\<lbrakk>0 \\<le> B;\n         \\<And>x. x \\<in> A \\<Longrightarrow> norm (f x) \\<le> B\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "hence \"max B 0 \\<ge> 0\" and \"\\<forall>x\\<in>A. norm (f x) \\<le> max B 0\""], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>A. norm (f x) \\<le> B\n\ngoal (1 subgoal):\n 1. 0 \\<le> max B 0 &&& \\<forall>x\\<in>A. norm (f x) \\<le> max B 0", "by auto"], ["proof (state)\nthis:\n  0 \\<le> max B 0\n  \\<forall>x\\<in>A. norm (f x) \\<le> max B 0\n\ngoal (1 subgoal):\n 1. (\\<And>B.\n        \\<lbrakk>0 \\<le> B;\n         \\<And>x. x \\<in> A \\<Longrightarrow> norm (f x) \\<le> B\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "thus ?thesis"], ["proof (prove)\nusing this:\n  0 \\<le> max B 0\n  \\<forall>x\\<in>A. norm (f x) \\<le> max B 0\n\ngoal (1 subgoal):\n 1. thesis", "using that"], ["proof (prove)\nusing this:\n  0 \\<le> max B 0\n  \\<forall>x\\<in>A. norm (f x) \\<le> max B 0\n  \\<lbrakk>0 \\<le> ?B;\n   \\<And>x. x \\<in> A \\<Longrightarrow> norm (f x) \\<le> ?B\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "by blast"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "interpretation cis: periodic_fun_simple cis \"2 * pi\""], ["proof (prove)\ngoal (1 subgoal):\n 1. periodic_fun_simple cis (2 * pi)", "by standard (simp_all add: complex_eq_iff)"], ["", "lemma open_contains_cbox:\n  fixes x :: \"'a :: euclidean_space\"\n  assumes \"open A\" \"x \\<in> A\"\n  obtains a b where \"cbox a b \\<subseteq> A\" \"x \\<in> box a b\" \"\\<forall>i\\<in>Basis. a \\<bullet> i < b \\<bullet> i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a b.\n        \\<lbrakk>cbox a b \\<subseteq> A; x \\<in> box a b;\n         \\<forall>i\\<in>Basis. a \\<bullet> i < b \\<bullet> i\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>a b.\n        \\<lbrakk>cbox a b \\<subseteq> A; x \\<in> box a b;\n         \\<forall>i\\<in>Basis. a \\<bullet> i < b \\<bullet> i\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from assms"], ["proof (chain)\npicking this:\n  open A\n  x \\<in> A", "obtain R where R: \"R > 0\" \"ball x R \\<subseteq> A\""], ["proof (prove)\nusing this:\n  open A\n  x \\<in> A\n\ngoal (1 subgoal):\n 1. (\\<And>R.\n        \\<lbrakk>0 < R; ball x R \\<subseteq> A\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: open_contains_ball)"], ["proof (state)\nthis:\n  0 < R\n  ball x R \\<subseteq> A\n\ngoal (1 subgoal):\n 1. (\\<And>a b.\n        \\<lbrakk>cbox a b \\<subseteq> A; x \\<in> box a b;\n         \\<forall>i\\<in>Basis. a \\<bullet> i < b \\<bullet> i\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "define r :: real where \"r = R / (2 * sqrt DIM('a))\""], ["proof (state)\nthis:\n  r = R / (2 * sqrt (real DIM('a)))\n\ngoal (1 subgoal):\n 1. (\\<And>a b.\n        \\<lbrakk>cbox a b \\<subseteq> A; x \\<in> box a b;\n         \\<forall>i\\<in>Basis. a \\<bullet> i < b \\<bullet> i\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from \\<open>R > 0\\<close>"], ["proof (chain)\npicking this:\n  0 < R", "have [simp]: \"r > 0\""], ["proof (prove)\nusing this:\n  0 < R\n\ngoal (1 subgoal):\n 1. 0 < r", "by (auto simp: r_def)"], ["proof (state)\nthis:\n  0 < r\n\ngoal (1 subgoal):\n 1. (\\<And>a b.\n        \\<lbrakk>cbox a b \\<subseteq> A; x \\<in> box a b;\n         \\<forall>i\\<in>Basis. a \\<bullet> i < b \\<bullet> i\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "define d :: 'a where \"d = r *\\<^sub>R Topology_Euclidean_Space.One\""], ["proof (state)\nthis:\n  d = r *\\<^sub>R One\n\ngoal (1 subgoal):\n 1. (\\<And>a b.\n        \\<lbrakk>cbox a b \\<subseteq> A; x \\<in> box a b;\n         \\<forall>i\\<in>Basis. a \\<bullet> i < b \\<bullet> i\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"cbox (x - d) (x + d) \\<subseteq> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cbox (x - d) (x + d) \\<subseteq> A", "proof safe"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa. xa \\<in> cbox (x - d) (x + d) \\<Longrightarrow> xa \\<in> A", "fix y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa. xa \\<in> cbox (x - d) (x + d) \\<Longrightarrow> xa \\<in> A", "assume y: \"y \\<in> cbox (x - d) (x + d)\""], ["proof (state)\nthis:\n  y \\<in> cbox (x - d) (x + d)\n\ngoal (1 subgoal):\n 1. \\<And>xa. xa \\<in> cbox (x - d) (x + d) \\<Longrightarrow> xa \\<in> A", "have \"dist x y = sqrt (\\<Sum>i\\<in>Basis. (dist (x \\<bullet> i) (y \\<bullet> i))\\<^sup>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist x y =\n    sqrt (\\<Sum>i\\<in>Basis. (dist (x \\<bullet> i) (y \\<bullet> i))\\<^sup>2)", "by (subst euclidean_dist_l2) (auto simp: L2_set_def)"], ["proof (state)\nthis:\n  dist x y =\n  sqrt (\\<Sum>i\\<in>Basis. (dist (x \\<bullet> i) (y \\<bullet> i))\\<^sup>2)\n\ngoal (1 subgoal):\n 1. \\<And>xa. xa \\<in> cbox (x - d) (x + d) \\<Longrightarrow> xa \\<in> A", "also"], ["proof (state)\nthis:\n  dist x y =\n  sqrt (\\<Sum>i\\<in>Basis. (dist (x \\<bullet> i) (y \\<bullet> i))\\<^sup>2)\n\ngoal (1 subgoal):\n 1. \\<And>xa. xa \\<in> cbox (x - d) (x + d) \\<Longrightarrow> xa \\<in> A", "from y"], ["proof (chain)\npicking this:\n  y \\<in> cbox (x - d) (x + d)", "have \"sqrt (\\<Sum>i\\<in>Basis. (dist (x \\<bullet> i) (y \\<bullet> i))\\<^sup>2) \\<le> sqrt (\\<Sum>i\\<in>(Basis::'a set). r\\<^sup>2)\""], ["proof (prove)\nusing this:\n  y \\<in> cbox (x - d) (x + d)\n\ngoal (1 subgoal):\n 1. sqrt (\\<Sum>i\\<in>Basis. (dist (x \\<bullet> i) (y \\<bullet> i))\\<^sup>2)\n    \\<le> sqrt (\\<Sum>i\\<in>Basis. r\\<^sup>2)", "by (intro real_sqrt_le_mono sum_mono power_mono)\n         (auto simp: dist_norm d_def cbox_def algebra_simps)"], ["proof (state)\nthis:\n  sqrt (\\<Sum>i\\<in>Basis. (dist (x \\<bullet> i) (y \\<bullet> i))\\<^sup>2)\n  \\<le> sqrt (\\<Sum>i\\<in>Basis. r\\<^sup>2)\n\ngoal (1 subgoal):\n 1. \\<And>xa. xa \\<in> cbox (x - d) (x + d) \\<Longrightarrow> xa \\<in> A", "also"], ["proof (state)\nthis:\n  sqrt (\\<Sum>i\\<in>Basis. (dist (x \\<bullet> i) (y \\<bullet> i))\\<^sup>2)\n  \\<le> sqrt (\\<Sum>i\\<in>Basis. r\\<^sup>2)\n\ngoal (1 subgoal):\n 1. \\<And>xa. xa \\<in> cbox (x - d) (x + d) \\<Longrightarrow> xa \\<in> A", "have \"\\<dots> = sqrt (DIM('a) * r\\<^sup>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sqrt (\\<Sum>i\\<in>Basis. r\\<^sup>2) = sqrt (real DIM('a) * r\\<^sup>2)", "by simp"], ["proof (state)\nthis:\n  sqrt (\\<Sum>i\\<in>Basis. r\\<^sup>2) = sqrt (real DIM('a) * r\\<^sup>2)\n\ngoal (1 subgoal):\n 1. \\<And>xa. xa \\<in> cbox (x - d) (x + d) \\<Longrightarrow> xa \\<in> A", "also"], ["proof (state)\nthis:\n  sqrt (\\<Sum>i\\<in>Basis. r\\<^sup>2) = sqrt (real DIM('a) * r\\<^sup>2)\n\ngoal (1 subgoal):\n 1. \\<And>xa. xa \\<in> cbox (x - d) (x + d) \\<Longrightarrow> xa \\<in> A", "have \"DIM('a) * r\\<^sup>2 = (R / 2) ^ 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real DIM('a) * r\\<^sup>2 = (R / 2)\\<^sup>2", "by (simp add: r_def power_divide)"], ["proof (state)\nthis:\n  real DIM('a) * r\\<^sup>2 = (R / 2)\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<And>xa. xa \\<in> cbox (x - d) (x + d) \\<Longrightarrow> xa \\<in> A", "also"], ["proof (state)\nthis:\n  real DIM('a) * r\\<^sup>2 = (R / 2)\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<And>xa. xa \\<in> cbox (x - d) (x + d) \\<Longrightarrow> xa \\<in> A", "have \"sqrt \\<dots> = R / 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sqrt ((R / 2)\\<^sup>2) = R / 2", "using \\<open>R > 0\\<close>"], ["proof (prove)\nusing this:\n  0 < R\n\ngoal (1 subgoal):\n 1. sqrt ((R / 2)\\<^sup>2) = R / 2", "by simp"], ["proof (state)\nthis:\n  sqrt ((R / 2)\\<^sup>2) = R / 2\n\ngoal (1 subgoal):\n 1. \\<And>xa. xa \\<in> cbox (x - d) (x + d) \\<Longrightarrow> xa \\<in> A", "also"], ["proof (state)\nthis:\n  sqrt ((R / 2)\\<^sup>2) = R / 2\n\ngoal (1 subgoal):\n 1. \\<And>xa. xa \\<in> cbox (x - d) (x + d) \\<Longrightarrow> xa \\<in> A", "from \\<open>R > 0\\<close>"], ["proof (chain)\npicking this:\n  0 < R", "have \"\\<dots> < R\""], ["proof (prove)\nusing this:\n  0 < R\n\ngoal (1 subgoal):\n 1. R / 2 < R", "by simp"], ["proof (state)\nthis:\n  R / 2 < R\n\ngoal (1 subgoal):\n 1. \\<And>xa. xa \\<in> cbox (x - d) (x + d) \\<Longrightarrow> xa \\<in> A", "finally"], ["proof (chain)\npicking this:\n  dist x y < R", "have \"y \\<in> ball x R\""], ["proof (prove)\nusing this:\n  dist x y < R\n\ngoal (1 subgoal):\n 1. y \\<in> ball x R", "by simp"], ["proof (state)\nthis:\n  y \\<in> ball x R\n\ngoal (1 subgoal):\n 1. \\<And>xa. xa \\<in> cbox (x - d) (x + d) \\<Longrightarrow> xa \\<in> A", "with R"], ["proof (chain)\npicking this:\n  0 < R\n  ball x R \\<subseteq> A\n  y \\<in> ball x R", "show \"y \\<in> A\""], ["proof (prove)\nusing this:\n  0 < R\n  ball x R \\<subseteq> A\n  y \\<in> ball x R\n\ngoal (1 subgoal):\n 1. y \\<in> A", "by blast"], ["proof (state)\nthis:\n  y \\<in> A\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  cbox (x - d) (x + d) \\<subseteq> A\n\ngoal (1 subgoal):\n 1. (\\<And>a b.\n        \\<lbrakk>cbox a b \\<subseteq> A; x \\<in> box a b;\n         \\<forall>i\\<in>Basis. a \\<bullet> i < b \\<bullet> i\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "thus ?thesis"], ["proof (prove)\nusing this:\n  cbox (x - d) (x + d) \\<subseteq> A\n\ngoal (1 subgoal):\n 1. thesis", "using that[of \"x - d\" \"x + d\"]"], ["proof (prove)\nusing this:\n  cbox (x - d) (x + d) \\<subseteq> A\n  \\<lbrakk>cbox (x - d) (x + d) \\<subseteq> A; x \\<in> box (x - d) (x + d);\n   \\<forall>i\\<in>Basis. (x - d) \\<bullet> i < (x + d) \\<bullet> i\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "by (auto simp: algebra_simps d_def box_def)"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma open_contains_box:\n  fixes x :: \"'a :: euclidean_space\"\n  assumes \"open A\" \"x \\<in> A\"\n  obtains a b where \"box a b \\<subseteq> A\" \"x \\<in> box a b\" \"\\<forall>i\\<in>Basis. a \\<bullet> i < b \\<bullet> i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a b.\n        \\<lbrakk>box a b \\<subseteq> A; x \\<in> box a b;\n         \\<forall>i\\<in>Basis. a \\<bullet> i < b \\<bullet> i\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>a b.\n        \\<lbrakk>box a b \\<subseteq> A; x \\<in> box a b;\n         \\<forall>i\\<in>Basis. a \\<bullet> i < b \\<bullet> i\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from open_contains_cbox[OF assms]"], ["proof (chain)\npicking this:\n  (\\<And>a b.\n      \\<lbrakk>cbox a b \\<subseteq> A; x \\<in> box a b;\n       \\<forall>i\\<in>Basis. a \\<bullet> i < b \\<bullet> i\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis", "guess a b"], ["proof (prove)\nusing this:\n  (\\<And>a b.\n      \\<lbrakk>cbox a b \\<subseteq> A; x \\<in> box a b;\n       \\<forall>i\\<in>Basis. a \\<bullet> i < b \\<bullet> i\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. thesis", "."], ["proof (state)\nthis:\n  cbox a b \\<subseteq> A\n  x \\<in> box a b\n  \\<forall>i\\<in>Basis. a \\<bullet> i < b \\<bullet> i\n\ngoal (1 subgoal):\n 1. (\\<And>a b.\n        \\<lbrakk>box a b \\<subseteq> A; x \\<in> box a b;\n         \\<forall>i\\<in>Basis. a \\<bullet> i < b \\<bullet> i\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "with that[of a b] box_subset_cbox[of a b]"], ["proof (chain)\npicking this:\n  \\<lbrakk>box a b \\<subseteq> A; x \\<in> box a b;\n   \\<forall>i\\<in>Basis. a \\<bullet> i < b \\<bullet> i\\<rbrakk>\n  \\<Longrightarrow> thesis\n  box a b \\<subseteq> cbox a b\n  cbox a b \\<subseteq> A\n  x \\<in> box a b\n  \\<forall>i\\<in>Basis. a \\<bullet> i < b \\<bullet> i", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>box a b \\<subseteq> A; x \\<in> box a b;\n   \\<forall>i\\<in>Basis. a \\<bullet> i < b \\<bullet> i\\<rbrakk>\n  \\<Longrightarrow> thesis\n  box a b \\<subseteq> cbox a b\n  cbox a b \\<subseteq> A\n  x \\<in> box a b\n  \\<forall>i\\<in>Basis. a \\<bullet> i < b \\<bullet> i\n\ngoal (1 subgoal):\n 1. thesis", "by auto"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma analytic_onE_box:\n  assumes \"f analytic_on A\" \"s \\<in> A\"\n  obtains a b where \"Re a < Re b\" \"Im a < Im b\" \"s \\<in> box a b\" \"f analytic_on box a b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a b.\n        \\<lbrakk>Re a < Re b; Im a < Im b; s \\<in> box a b;\n         f analytic_on box a b\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>a b.\n        \\<lbrakk>Re a < Re b; Im a < Im b; s \\<in> box a b;\n         f analytic_on box a b\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from assms"], ["proof (chain)\npicking this:\n  f analytic_on A\n  s \\<in> A", "obtain r where r: \"r > 0\" \"f holomorphic_on ball s r\""], ["proof (prove)\nusing this:\n  f analytic_on A\n  s \\<in> A\n\ngoal (1 subgoal):\n 1. (\\<And>r.\n        \\<lbrakk>0 < r; f holomorphic_on ball s r\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: analytic_on_def)"], ["proof (state)\nthis:\n  0 < r\n  f holomorphic_on ball s r\n\ngoal (1 subgoal):\n 1. (\\<And>a b.\n        \\<lbrakk>Re a < Re b; Im a < Im b; s \\<in> box a b;\n         f analytic_on box a b\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "with open_contains_box[of \"ball s r\" s]"], ["proof (chain)\npicking this:\n  \\<lbrakk>open (ball s r); s \\<in> ball s r;\n   \\<And>a b.\n      \\<lbrakk>box a b \\<subseteq> ball s r; s \\<in> box a b;\n       \\<forall>i\\<in>Basis. a \\<bullet> i < b \\<bullet> i\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  0 < r\n  f holomorphic_on ball s r", "obtain a b\n    where \"box a b \\<subseteq> ball s r\" \"s \\<in> box a b\" \"\\<forall>i\\<in>Basis. a \\<bullet> i < b \\<bullet> i\""], ["proof (prove)\nusing this:\n  \\<lbrakk>open (ball s r); s \\<in> ball s r;\n   \\<And>a b.\n      \\<lbrakk>box a b \\<subseteq> ball s r; s \\<in> box a b;\n       \\<forall>i\\<in>Basis. a \\<bullet> i < b \\<bullet> i\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  0 < r\n  f holomorphic_on ball s r\n\ngoal (1 subgoal):\n 1. (\\<And>a b.\n        \\<lbrakk>box a b \\<subseteq> ball s r; s \\<in> box a b;\n         \\<forall>i\\<in>Basis. a \\<bullet> i < b \\<bullet> i\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  box a b \\<subseteq> ball s r\n  s \\<in> box a b\n  \\<forall>i\\<in>Basis. a \\<bullet> i < b \\<bullet> i\n\ngoal (1 subgoal):\n 1. (\\<And>a b.\n        \\<lbrakk>Re a < Re b; Im a < Im b; s \\<in> box a b;\n         f analytic_on box a b\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  box a b \\<subseteq> ball s r\n  s \\<in> box a b\n  \\<forall>i\\<in>Basis. a \\<bullet> i < b \\<bullet> i\n\ngoal (1 subgoal):\n 1. (\\<And>a b.\n        \\<lbrakk>Re a < Re b; Im a < Im b; s \\<in> box a b;\n         f analytic_on box a b\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from r"], ["proof (chain)\npicking this:\n  0 < r\n  f holomorphic_on ball s r", "have \"f analytic_on ball s r\""], ["proof (prove)\nusing this:\n  0 < r\n  f holomorphic_on ball s r\n\ngoal (1 subgoal):\n 1. f analytic_on ball s r", "by (simp add: analytic_on_open)"], ["proof (state)\nthis:\n  f analytic_on ball s r\n\ngoal (1 subgoal):\n 1. (\\<And>a b.\n        \\<lbrakk>Re a < Re b; Im a < Im b; s \\<in> box a b;\n         f analytic_on box a b\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "ultimately"], ["proof (chain)\npicking this:\n  box a b \\<subseteq> ball s r\n  s \\<in> box a b\n  \\<forall>i\\<in>Basis. a \\<bullet> i < b \\<bullet> i\n  f analytic_on ball s r", "show ?thesis"], ["proof (prove)\nusing this:\n  box a b \\<subseteq> ball s r\n  s \\<in> box a b\n  \\<forall>i\\<in>Basis. a \\<bullet> i < b \\<bullet> i\n  f analytic_on ball s r\n\ngoal (1 subgoal):\n 1. thesis", "using that[of a b] analytic_on_subset[of _ \"ball s r\" \"box a b\"]"], ["proof (prove)\nusing this:\n  box a b \\<subseteq> ball s r\n  s \\<in> box a b\n  \\<forall>i\\<in>Basis. a \\<bullet> i < b \\<bullet> i\n  f analytic_on ball s r\n  \\<lbrakk>Re a < Re b; Im a < Im b; s \\<in> box a b;\n   f analytic_on box a b\\<rbrakk>\n  \\<Longrightarrow> thesis\n  \\<lbrakk>?f analytic_on ball s r; box a b \\<subseteq> ball s r\\<rbrakk>\n  \\<Longrightarrow> ?f analytic_on box a b\n\ngoal (1 subgoal):\n 1. thesis", "by (auto simp: Basis_complex_def)"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma inner_image_box:\n  assumes \"(i :: 'a :: euclidean_space) \\<in> Basis\"\n  assumes \"\\<forall>i\\<in>Basis. a \\<bullet> i < b \\<bullet> i\"\n  shows   \"(\\<lambda>x. x \\<bullet> i) ` box a b = {a \\<bullet> i<..<b \\<bullet> i}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. x \\<bullet> i) ` box a b = {a \\<bullet> i<..<b \\<bullet> i}", "proof safe"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       xa \\<in> box a b \\<Longrightarrow>\n       xa \\<bullet> i \\<in> {a \\<bullet> i<..<b \\<bullet> i}\n 2. \\<And>x.\n       x \\<in> {a \\<bullet> i<..<b \\<bullet> i} \\<Longrightarrow>\n       x \\<in> (\\<lambda>x. x \\<bullet> i) ` box a b", "fix x"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       xa \\<in> box a b \\<Longrightarrow>\n       xa \\<bullet> i \\<in> {a \\<bullet> i<..<b \\<bullet> i}\n 2. \\<And>x.\n       x \\<in> {a \\<bullet> i<..<b \\<bullet> i} \\<Longrightarrow>\n       x \\<in> (\\<lambda>x. x \\<bullet> i) ` box a b", "assume x: \"x \\<in> {a \\<bullet> i<..<b \\<bullet> i}\""], ["proof (state)\nthis:\n  x \\<in> {a \\<bullet> i<..<b \\<bullet> i}\n\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       xa \\<in> box a b \\<Longrightarrow>\n       xa \\<bullet> i \\<in> {a \\<bullet> i<..<b \\<bullet> i}\n 2. \\<And>x.\n       x \\<in> {a \\<bullet> i<..<b \\<bullet> i} \\<Longrightarrow>\n       x \\<in> (\\<lambda>x. x \\<bullet> i) ` box a b", "let ?y = \"(\\<Sum>j\\<in>Basis. (if i = j then x else (a + b) \\<bullet> j / 2) *\\<^sub>R j)\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       xa \\<in> box a b \\<Longrightarrow>\n       xa \\<bullet> i \\<in> {a \\<bullet> i<..<b \\<bullet> i}\n 2. \\<And>x.\n       x \\<in> {a \\<bullet> i<..<b \\<bullet> i} \\<Longrightarrow>\n       x \\<in> (\\<lambda>x. x \\<bullet> i) ` box a b", "from x assms"], ["proof (chain)\npicking this:\n  x \\<in> {a \\<bullet> i<..<b \\<bullet> i}\n  i \\<in> Basis\n  \\<forall>i\\<in>Basis. a \\<bullet> i < b \\<bullet> i", "have \"?y \\<bullet> i \\<in> (\\<lambda>x. x \\<bullet> i) ` box a b\""], ["proof (prove)\nusing this:\n  x \\<in> {a \\<bullet> i<..<b \\<bullet> i}\n  i \\<in> Basis\n  \\<forall>i\\<in>Basis. a \\<bullet> i < b \\<bullet> i\n\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<in>Basis.\n       (if i = j then x else (a + b) \\<bullet> j / 2) *\\<^sub>R j) \\<bullet>\n    i\n    \\<in> (\\<lambda>x. x \\<bullet> i) ` box a b", "by (intro imageI) (auto simp: box_def algebra_simps)"], ["proof (state)\nthis:\n  (\\<Sum>j\\<in>Basis.\n     (if i = j then x else (a + b) \\<bullet> j / 2) *\\<^sub>R j) \\<bullet>\n  i\n  \\<in> (\\<lambda>x. x \\<bullet> i) ` box a b\n\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       xa \\<in> box a b \\<Longrightarrow>\n       xa \\<bullet> i \\<in> {a \\<bullet> i<..<b \\<bullet> i}\n 2. \\<And>x.\n       x \\<in> {a \\<bullet> i<..<b \\<bullet> i} \\<Longrightarrow>\n       x \\<in> (\\<lambda>x. x \\<bullet> i) ` box a b", "also"], ["proof (state)\nthis:\n  (\\<Sum>j\\<in>Basis.\n     (if i = j then x else (a + b) \\<bullet> j / 2) *\\<^sub>R j) \\<bullet>\n  i\n  \\<in> (\\<lambda>x. x \\<bullet> i) ` box a b\n\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       xa \\<in> box a b \\<Longrightarrow>\n       xa \\<bullet> i \\<in> {a \\<bullet> i<..<b \\<bullet> i}\n 2. \\<And>x.\n       x \\<in> {a \\<bullet> i<..<b \\<bullet> i} \\<Longrightarrow>\n       x \\<in> (\\<lambda>x. x \\<bullet> i) ` box a b", "have \"?y \\<bullet> i = (\\<Sum>j\\<in>Basis. (if i = j then x else (a + b) \\<bullet> j / 2) * (j \\<bullet> i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<in>Basis.\n       (if i = j then x else (a + b) \\<bullet> j / 2) *\\<^sub>R j) \\<bullet>\n    i =\n    (\\<Sum>j\\<in>Basis.\n       (if i = j then x else (a + b) \\<bullet> j / 2) * (j \\<bullet> i))", "by (simp add: inner_sum_left)"], ["proof (state)\nthis:\n  (\\<Sum>j\\<in>Basis.\n     (if i = j then x else (a + b) \\<bullet> j / 2) *\\<^sub>R j) \\<bullet>\n  i =\n  (\\<Sum>j\\<in>Basis.\n     (if i = j then x else (a + b) \\<bullet> j / 2) * (j \\<bullet> i))\n\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       xa \\<in> box a b \\<Longrightarrow>\n       xa \\<bullet> i \\<in> {a \\<bullet> i<..<b \\<bullet> i}\n 2. \\<And>x.\n       x \\<in> {a \\<bullet> i<..<b \\<bullet> i} \\<Longrightarrow>\n       x \\<in> (\\<lambda>x. x \\<bullet> i) ` box a b", "also"], ["proof (state)\nthis:\n  (\\<Sum>j\\<in>Basis.\n     (if i = j then x else (a + b) \\<bullet> j / 2) *\\<^sub>R j) \\<bullet>\n  i =\n  (\\<Sum>j\\<in>Basis.\n     (if i = j then x else (a + b) \\<bullet> j / 2) * (j \\<bullet> i))\n\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       xa \\<in> box a b \\<Longrightarrow>\n       xa \\<bullet> i \\<in> {a \\<bullet> i<..<b \\<bullet> i}\n 2. \\<And>x.\n       x \\<in> {a \\<bullet> i<..<b \\<bullet> i} \\<Longrightarrow>\n       x \\<in> (\\<lambda>x. x \\<bullet> i) ` box a b", "have \"\\<dots> = (\\<Sum>j\\<in>Basis. if i = j then x else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<in>Basis.\n       (if i = j then x else (a + b) \\<bullet> j / 2) * (j \\<bullet> i)) =\n    (\\<Sum>j\\<in>Basis. if i = j then x else 0)", "by (intro sum.cong) (auto simp: inner_not_same_Basis assms)"], ["proof (state)\nthis:\n  (\\<Sum>j\\<in>Basis.\n     (if i = j then x else (a + b) \\<bullet> j / 2) * (j \\<bullet> i)) =\n  (\\<Sum>j\\<in>Basis. if i = j then x else 0)\n\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       xa \\<in> box a b \\<Longrightarrow>\n       xa \\<bullet> i \\<in> {a \\<bullet> i<..<b \\<bullet> i}\n 2. \\<And>x.\n       x \\<in> {a \\<bullet> i<..<b \\<bullet> i} \\<Longrightarrow>\n       x \\<in> (\\<lambda>x. x \\<bullet> i) ` box a b", "also"], ["proof (state)\nthis:\n  (\\<Sum>j\\<in>Basis.\n     (if i = j then x else (a + b) \\<bullet> j / 2) * (j \\<bullet> i)) =\n  (\\<Sum>j\\<in>Basis. if i = j then x else 0)\n\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       xa \\<in> box a b \\<Longrightarrow>\n       xa \\<bullet> i \\<in> {a \\<bullet> i<..<b \\<bullet> i}\n 2. \\<And>x.\n       x \\<in> {a \\<bullet> i<..<b \\<bullet> i} \\<Longrightarrow>\n       x \\<in> (\\<lambda>x. x \\<bullet> i) ` box a b", "have \"\\<dots> = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<in>Basis. if i = j then x else 0) = x", "using assms"], ["proof (prove)\nusing this:\n  i \\<in> Basis\n  \\<forall>i\\<in>Basis. a \\<bullet> i < b \\<bullet> i\n\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<in>Basis. if i = j then x else 0) = x", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>j\\<in>Basis. if i = j then x else 0) = x\n\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       xa \\<in> box a b \\<Longrightarrow>\n       xa \\<bullet> i \\<in> {a \\<bullet> i<..<b \\<bullet> i}\n 2. \\<And>x.\n       x \\<in> {a \\<bullet> i<..<b \\<bullet> i} \\<Longrightarrow>\n       x \\<in> (\\<lambda>x. x \\<bullet> i) ` box a b", "finally"], ["proof (chain)\npicking this:\n  x \\<in> (\\<lambda>x. x \\<bullet> i) ` box a b", "show \"x \\<in> (\\<lambda>x. x \\<bullet> i) ` box a b\""], ["proof (prove)\nusing this:\n  x \\<in> (\\<lambda>x. x \\<bullet> i) ` box a b\n\ngoal (1 subgoal):\n 1. x \\<in> (\\<lambda>x. x \\<bullet> i) ` box a b", "."], ["proof (state)\nthis:\n  x \\<in> (\\<lambda>x. x \\<bullet> i) ` box a b\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       xa \\<in> box a b \\<Longrightarrow>\n       xa \\<bullet> i \\<in> {a \\<bullet> i<..<b \\<bullet> i}", "qed (insert assms, auto simp: box_def)"], ["", "lemma Re_image_box:\n  assumes \"Re a < Re b\" \"Im a < Im b\"\n  shows   \"Re ` box a b = {Re a<..<Re b}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Re ` box a b = {Re a<..<Re b}", "using inner_image_box[of \"1::complex\" a b] assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>1 \\<in> Basis;\n   \\<forall>i\\<in>Basis. a \\<bullet> i < b \\<bullet> i\\<rbrakk>\n  \\<Longrightarrow> (\\<lambda>x. x \\<bullet> 1) ` box a b =\n                    {a \\<bullet> 1<..<b \\<bullet> 1}\n  Re a < Re b\n  Im a < Im b\n\ngoal (1 subgoal):\n 1. Re ` box a b = {Re a<..<Re b}", "by (auto simp: Basis_complex_def)"], ["", "lemma Im_image_box:\n  assumes \"Re a < Re b\" \"Im a < Im b\"\n  shows   \"Im ` box a b = {Im a<..<Im b}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Im ` box a b = {Im a<..<Im b}", "using inner_image_box[of \"\\<i>::complex\" a b] assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<i> \\<in> Basis;\n   \\<forall>i\\<in>Basis. a \\<bullet> i < b \\<bullet> i\\<rbrakk>\n  \\<Longrightarrow> (\\<lambda>x. x \\<bullet> \\<i>) ` box a b =\n                    {a \\<bullet> \\<i><..<b \\<bullet> \\<i>}\n  Re a < Re b\n  Im a < Im b\n\ngoal (1 subgoal):\n 1. Im ` box a b = {Im a<..<Im b}", "by (auto simp: Basis_complex_def)"], ["", "lemma inner_image_cbox:\n  assumes \"(i :: 'a :: euclidean_space) \\<in> Basis\"\n  assumes \"\\<forall>i\\<in>Basis. a \\<bullet> i \\<le> b \\<bullet> i\"\n  shows   \"(\\<lambda>x. x \\<bullet> i) ` cbox a b = {a \\<bullet> i..b \\<bullet> i}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. x \\<bullet> i) ` cbox a b = {a \\<bullet> i..b \\<bullet> i}", "proof safe"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       xa \\<in> cbox a b \\<Longrightarrow>\n       xa \\<bullet> i \\<in> {a \\<bullet> i..b \\<bullet> i}\n 2. \\<And>x.\n       x \\<in> {a \\<bullet> i..b \\<bullet> i} \\<Longrightarrow>\n       x \\<in> (\\<lambda>x. x \\<bullet> i) ` cbox a b", "fix x"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       xa \\<in> cbox a b \\<Longrightarrow>\n       xa \\<bullet> i \\<in> {a \\<bullet> i..b \\<bullet> i}\n 2. \\<And>x.\n       x \\<in> {a \\<bullet> i..b \\<bullet> i} \\<Longrightarrow>\n       x \\<in> (\\<lambda>x. x \\<bullet> i) ` cbox a b", "assume x: \"x \\<in> {a \\<bullet> i..b \\<bullet> i}\""], ["proof (state)\nthis:\n  x \\<in> {a \\<bullet> i..b \\<bullet> i}\n\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       xa \\<in> cbox a b \\<Longrightarrow>\n       xa \\<bullet> i \\<in> {a \\<bullet> i..b \\<bullet> i}\n 2. \\<And>x.\n       x \\<in> {a \\<bullet> i..b \\<bullet> i} \\<Longrightarrow>\n       x \\<in> (\\<lambda>x. x \\<bullet> i) ` cbox a b", "let ?y = \"(\\<Sum>j\\<in>Basis. (if i = j then x else a \\<bullet> j) *\\<^sub>R j)\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       xa \\<in> cbox a b \\<Longrightarrow>\n       xa \\<bullet> i \\<in> {a \\<bullet> i..b \\<bullet> i}\n 2. \\<And>x.\n       x \\<in> {a \\<bullet> i..b \\<bullet> i} \\<Longrightarrow>\n       x \\<in> (\\<lambda>x. x \\<bullet> i) ` cbox a b", "from x assms"], ["proof (chain)\npicking this:\n  x \\<in> {a \\<bullet> i..b \\<bullet> i}\n  i \\<in> Basis\n  \\<forall>i\\<in>Basis. a \\<bullet> i \\<le> b \\<bullet> i", "have \"?y \\<bullet> i \\<in> (\\<lambda>x. x \\<bullet> i) ` cbox a b\""], ["proof (prove)\nusing this:\n  x \\<in> {a \\<bullet> i..b \\<bullet> i}\n  i \\<in> Basis\n  \\<forall>i\\<in>Basis. a \\<bullet> i \\<le> b \\<bullet> i\n\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<in>Basis.\n       (if i = j then x else a \\<bullet> j) *\\<^sub>R j) \\<bullet>\n    i\n    \\<in> (\\<lambda>x. x \\<bullet> i) ` cbox a b", "by (intro imageI) (auto simp: cbox_def)"], ["proof (state)\nthis:\n  (\\<Sum>j\\<in>Basis.\n     (if i = j then x else a \\<bullet> j) *\\<^sub>R j) \\<bullet>\n  i\n  \\<in> (\\<lambda>x. x \\<bullet> i) ` cbox a b\n\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       xa \\<in> cbox a b \\<Longrightarrow>\n       xa \\<bullet> i \\<in> {a \\<bullet> i..b \\<bullet> i}\n 2. \\<And>x.\n       x \\<in> {a \\<bullet> i..b \\<bullet> i} \\<Longrightarrow>\n       x \\<in> (\\<lambda>x. x \\<bullet> i) ` cbox a b", "also"], ["proof (state)\nthis:\n  (\\<Sum>j\\<in>Basis.\n     (if i = j then x else a \\<bullet> j) *\\<^sub>R j) \\<bullet>\n  i\n  \\<in> (\\<lambda>x. x \\<bullet> i) ` cbox a b\n\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       xa \\<in> cbox a b \\<Longrightarrow>\n       xa \\<bullet> i \\<in> {a \\<bullet> i..b \\<bullet> i}\n 2. \\<And>x.\n       x \\<in> {a \\<bullet> i..b \\<bullet> i} \\<Longrightarrow>\n       x \\<in> (\\<lambda>x. x \\<bullet> i) ` cbox a b", "have \"?y \\<bullet> i = (\\<Sum>j\\<in>Basis. (if i = j then x else a \\<bullet> j) * (j \\<bullet> i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<in>Basis.\n       (if i = j then x else a \\<bullet> j) *\\<^sub>R j) \\<bullet>\n    i =\n    (\\<Sum>j\\<in>Basis.\n       (if i = j then x else a \\<bullet> j) * (j \\<bullet> i))", "by (simp add: inner_sum_left)"], ["proof (state)\nthis:\n  (\\<Sum>j\\<in>Basis.\n     (if i = j then x else a \\<bullet> j) *\\<^sub>R j) \\<bullet>\n  i =\n  (\\<Sum>j\\<in>Basis.\n     (if i = j then x else a \\<bullet> j) * (j \\<bullet> i))\n\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       xa \\<in> cbox a b \\<Longrightarrow>\n       xa \\<bullet> i \\<in> {a \\<bullet> i..b \\<bullet> i}\n 2. \\<And>x.\n       x \\<in> {a \\<bullet> i..b \\<bullet> i} \\<Longrightarrow>\n       x \\<in> (\\<lambda>x. x \\<bullet> i) ` cbox a b", "also"], ["proof (state)\nthis:\n  (\\<Sum>j\\<in>Basis.\n     (if i = j then x else a \\<bullet> j) *\\<^sub>R j) \\<bullet>\n  i =\n  (\\<Sum>j\\<in>Basis.\n     (if i = j then x else a \\<bullet> j) * (j \\<bullet> i))\n\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       xa \\<in> cbox a b \\<Longrightarrow>\n       xa \\<bullet> i \\<in> {a \\<bullet> i..b \\<bullet> i}\n 2. \\<And>x.\n       x \\<in> {a \\<bullet> i..b \\<bullet> i} \\<Longrightarrow>\n       x \\<in> (\\<lambda>x. x \\<bullet> i) ` cbox a b", "have \"\\<dots> = (\\<Sum>j\\<in>Basis. if i = j then x else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<in>Basis.\n       (if i = j then x else a \\<bullet> j) * (j \\<bullet> i)) =\n    (\\<Sum>j\\<in>Basis. if i = j then x else 0)", "by (intro sum.cong) (auto simp: inner_not_same_Basis assms)"], ["proof (state)\nthis:\n  (\\<Sum>j\\<in>Basis.\n     (if i = j then x else a \\<bullet> j) * (j \\<bullet> i)) =\n  (\\<Sum>j\\<in>Basis. if i = j then x else 0)\n\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       xa \\<in> cbox a b \\<Longrightarrow>\n       xa \\<bullet> i \\<in> {a \\<bullet> i..b \\<bullet> i}\n 2. \\<And>x.\n       x \\<in> {a \\<bullet> i..b \\<bullet> i} \\<Longrightarrow>\n       x \\<in> (\\<lambda>x. x \\<bullet> i) ` cbox a b", "also"], ["proof (state)\nthis:\n  (\\<Sum>j\\<in>Basis.\n     (if i = j then x else a \\<bullet> j) * (j \\<bullet> i)) =\n  (\\<Sum>j\\<in>Basis. if i = j then x else 0)\n\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       xa \\<in> cbox a b \\<Longrightarrow>\n       xa \\<bullet> i \\<in> {a \\<bullet> i..b \\<bullet> i}\n 2. \\<And>x.\n       x \\<in> {a \\<bullet> i..b \\<bullet> i} \\<Longrightarrow>\n       x \\<in> (\\<lambda>x. x \\<bullet> i) ` cbox a b", "have \"\\<dots> = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<in>Basis. if i = j then x else 0) = x", "using assms"], ["proof (prove)\nusing this:\n  i \\<in> Basis\n  \\<forall>i\\<in>Basis. a \\<bullet> i \\<le> b \\<bullet> i\n\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<in>Basis. if i = j then x else 0) = x", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>j\\<in>Basis. if i = j then x else 0) = x\n\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       xa \\<in> cbox a b \\<Longrightarrow>\n       xa \\<bullet> i \\<in> {a \\<bullet> i..b \\<bullet> i}\n 2. \\<And>x.\n       x \\<in> {a \\<bullet> i..b \\<bullet> i} \\<Longrightarrow>\n       x \\<in> (\\<lambda>x. x \\<bullet> i) ` cbox a b", "finally"], ["proof (chain)\npicking this:\n  x \\<in> (\\<lambda>x. x \\<bullet> i) ` cbox a b", "show \"x \\<in> (\\<lambda>x. x \\<bullet> i) ` cbox a b\""], ["proof (prove)\nusing this:\n  x \\<in> (\\<lambda>x. x \\<bullet> i) ` cbox a b\n\ngoal (1 subgoal):\n 1. x \\<in> (\\<lambda>x. x \\<bullet> i) ` cbox a b", "."], ["proof (state)\nthis:\n  x \\<in> (\\<lambda>x. x \\<bullet> i) ` cbox a b\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       xa \\<in> cbox a b \\<Longrightarrow>\n       xa \\<bullet> i \\<in> {a \\<bullet> i..b \\<bullet> i}", "qed (insert assms, auto simp: cbox_def)"], ["", "lemma Re_image_cbox:\n  assumes \"Re a \\<le> Re b\" \"Im a \\<le> Im b\"\n  shows   \"Re ` cbox a b = {Re a..Re b}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Re ` cbox a b = {Re a..Re b}", "using inner_image_cbox[of \"1::complex\" a b] assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>1 \\<in> Basis;\n   \\<forall>i\\<in>Basis. a \\<bullet> i \\<le> b \\<bullet> i\\<rbrakk>\n  \\<Longrightarrow> (\\<lambda>x. x \\<bullet> 1) ` cbox a b =\n                    {a \\<bullet> 1..b \\<bullet> 1}\n  Re a \\<le> Re b\n  Im a \\<le> Im b\n\ngoal (1 subgoal):\n 1. Re ` cbox a b = {Re a..Re b}", "by (auto simp: Basis_complex_def)"], ["", "lemma Im_image_cbox:\n  assumes \"Re a \\<le> Re b\" \"Im a \\<le> Im b\"\n  shows   \"Im ` cbox a b = {Im a..Im b}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Im ` cbox a b = {Im a..Im b}", "using inner_image_cbox[of \"\\<i>::complex\" a b] assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<i> \\<in> Basis;\n   \\<forall>i\\<in>Basis. a \\<bullet> i \\<le> b \\<bullet> i\\<rbrakk>\n  \\<Longrightarrow> (\\<lambda>x. x \\<bullet> \\<i>) ` cbox a b =\n                    {a \\<bullet> \\<i>..b \\<bullet> \\<i>}\n  Re a \\<le> Re b\n  Im a \\<le> Im b\n\ngoal (1 subgoal):\n 1. Im ` cbox a b = {Im a..Im b}", "by (auto simp: Basis_complex_def)"], ["", "lemma analytic_onE_cball:\n  assumes \"f analytic_on A\" \"s \\<in> A\" \"ub > (0::real)\"\n  obtains R where \"R > 0\" \"R < ub\" \"f analytic_on cball s R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>R.\n        \\<lbrakk>0 < R; R < ub; f analytic_on cball s R\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>R.\n        \\<lbrakk>0 < R; R < ub; f analytic_on cball s R\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from assms"], ["proof (chain)\npicking this:\n  f analytic_on A\n  s \\<in> A\n  0 < ub", "obtain r where \"r > 0\" \"f holomorphic_on ball s r\""], ["proof (prove)\nusing this:\n  f analytic_on A\n  s \\<in> A\n  0 < ub\n\ngoal (1 subgoal):\n 1. (\\<And>r.\n        \\<lbrakk>0 < r; f holomorphic_on ball s r\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: analytic_on_def)"], ["proof (state)\nthis:\n  0 < r\n  f holomorphic_on ball s r\n\ngoal (1 subgoal):\n 1. (\\<And>R.\n        \\<lbrakk>0 < R; R < ub; f analytic_on cball s R\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "hence \"f analytic_on ball s r\""], ["proof (prove)\nusing this:\n  0 < r\n  f holomorphic_on ball s r\n\ngoal (1 subgoal):\n 1. f analytic_on ball s r", "by (simp add: analytic_on_open)"], ["proof (state)\nthis:\n  f analytic_on ball s r\n\ngoal (1 subgoal):\n 1. (\\<And>R.\n        \\<lbrakk>0 < R; R < ub; f analytic_on cball s R\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "hence \"f analytic_on cball s (min (ub / 2) (r / 2))\""], ["proof (prove)\nusing this:\n  f analytic_on ball s r\n\ngoal (1 subgoal):\n 1. f analytic_on cball s (min (ub / 2) (r / 2))", "by (rule analytic_on_subset, subst cball_subset_ball_iff) (use \\<open>r > 0\\<close> in auto)"], ["proof (state)\nthis:\n  f analytic_on cball s (min (ub / 2) (r / 2))\n\ngoal (1 subgoal):\n 1. (\\<And>R.\n        \\<lbrakk>0 < R; R < ub; f analytic_on cball s R\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  f analytic_on cball s (min (ub / 2) (r / 2))\n\ngoal (1 subgoal):\n 1. (\\<And>R.\n        \\<lbrakk>0 < R; R < ub; f analytic_on cball s R\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"min (ub / 2) (r / 2) > 0\" and \"min (ub / 2) (r / 2) < ub\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < min (ub / 2) (r / 2) &&& min (ub / 2) (r / 2) < ub", "using \\<open>r > 0\\<close> and \\<open>ub > 0\\<close>"], ["proof (prove)\nusing this:\n  0 < r\n  0 < ub\n\ngoal (1 subgoal):\n 1. 0 < min (ub / 2) (r / 2) &&& min (ub / 2) (r / 2) < ub", "by (auto simp: min_def)"], ["proof (state)\nthis:\n  0 < min (ub / 2) (r / 2)\n  min (ub / 2) (r / 2) < ub\n\ngoal (1 subgoal):\n 1. (\\<And>R.\n        \\<lbrakk>0 < R; R < ub; f analytic_on cball s R\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "ultimately"], ["proof (chain)\npicking this:\n  f analytic_on cball s (min (ub / 2) (r / 2))\n  0 < min (ub / 2) (r / 2)\n  min (ub / 2) (r / 2) < ub", "show ?thesis"], ["proof (prove)\nusing this:\n  f analytic_on cball s (min (ub / 2) (r / 2))\n  0 < min (ub / 2) (r / 2)\n  min (ub / 2) (r / 2) < ub\n\ngoal (1 subgoal):\n 1. thesis", "using that[of \"min (ub / 2) (r / 2)\"]"], ["proof (prove)\nusing this:\n  f analytic_on cball s (min (ub / 2) (r / 2))\n  0 < min (ub / 2) (r / 2)\n  min (ub / 2) (r / 2) < ub\n  \\<lbrakk>0 < min (ub / 2) (r / 2); min (ub / 2) (r / 2) < ub;\n   f analytic_on cball s (min (ub / 2) (r / 2))\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "by blast"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary analytic_pre_zeta' [analytic_intros]:\n  assumes \"f analytic_on A\" \"a > 0\"\n  shows   \"(\\<lambda>x. pre_zeta a (f x)) analytic_on A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. pre_zeta a (f x)) analytic_on A", "using analytic_on_compose_gen[OF assms(1) analytic_pre_zeta[of a UNIV]] assms(2)"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 < a;\n   \\<And>z. z \\<in> A \\<Longrightarrow> f z \\<in> UNIV\\<rbrakk>\n  \\<Longrightarrow> pre_zeta a \\<circ> f analytic_on A\n  0 < a\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. pre_zeta a (f x)) analytic_on A", "by (auto simp: o_def)"], ["", "corollary analytic_hurwitz_zeta' [analytic_intros]:\n  assumes \"f analytic_on A\" \"(\\<And>x. x \\<in> A \\<Longrightarrow> f x \\<noteq> 1)\" \"a > 0\"\n  shows   \"(\\<lambda>x. hurwitz_zeta a (f x)) analytic_on A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. hurwitz_zeta a (f x)) analytic_on A", "using analytic_on_compose_gen[OF assms(1) analytic_hurwitz_zeta[of a \"-{1}\"]] assms(2,3)"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 < a; 1 \\<notin> - {1};\n   \\<And>z. z \\<in> A \\<Longrightarrow> f z \\<in> - {1}\\<rbrakk>\n  \\<Longrightarrow> hurwitz_zeta a \\<circ> f analytic_on A\n  ?x \\<in> A \\<Longrightarrow> f ?x \\<noteq> 1\n  0 < a\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. hurwitz_zeta a (f x)) analytic_on A", "by (auto simp: o_def)"], ["", "corollary analytic_zeta' [analytic_intros]:\n  assumes \"f analytic_on A\" \"(\\<And>x. x \\<in> A \\<Longrightarrow> f x \\<noteq> 1)\"\n  shows   \"(\\<lambda>x. zeta (f x)) analytic_on A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. zeta (f x)) analytic_on A", "using analytic_on_compose_gen[OF assms(1) analytic_zeta[of \"-{1}\"]] assms(2)"], ["proof (prove)\nusing this:\n  \\<lbrakk>1 \\<notin> - {1};\n   \\<And>z. z \\<in> A \\<Longrightarrow> f z \\<in> - {1}\\<rbrakk>\n  \\<Longrightarrow> zeta \\<circ> f analytic_on A\n  ?x \\<in> A \\<Longrightarrow> f ?x \\<noteq> 1\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. zeta (f x)) analytic_on A", "by (auto simp: o_def)"], ["", "lemma logderiv_zeta_analytic: \"(\\<lambda>s. deriv zeta s / zeta s) analytic_on {s. Re s \\<ge> 1} - {1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>s. deriv zeta s / zeta s) analytic_on {s. 1 \\<le> Re s} - {1}", "using zeta_Re_ge_1_nonzero"], ["proof (prove)\nusing this:\n  \\<lbrakk>1 \\<le> Re ?s; ?s \\<noteq> 1\\<rbrakk>\n  \\<Longrightarrow> zeta ?s \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<lambda>s. deriv zeta s / zeta s) analytic_on {s. 1 \\<le> Re s} - {1}", "by (auto intro!: analytic_intros)"], ["", "lemma cis_pi_half [simp]: \"cis (pi / 2) = \\<i>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cis (pi / 2) = \\<i>", "by (simp add: complex_eq_iff)"], ["", "lemma mult_real_sqrt: \"x \\<ge> 0 \\<Longrightarrow> x * sqrt y = sqrt (x ^ 2 * y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> x \\<Longrightarrow> x * sqrt y = sqrt (x\\<^sup>2 * y)", "by (simp add: real_sqrt_mult)"], ["", "lemma arcsin_pos: \"x \\<in> {0<..1} \\<Longrightarrow> arcsin x > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> {0<..1} \\<Longrightarrow> 0 < arcsin x", "using arcsin_less_arcsin[of 0 x]"], ["proof (prove)\nusing this:\n  \\<lbrakk>- 1 \\<le> 0; 0 < x; x \\<le> 1\\<rbrakk>\n  \\<Longrightarrow> arcsin 0 < arcsin x\n\ngoal (1 subgoal):\n 1. x \\<in> {0<..1} \\<Longrightarrow> 0 < arcsin x", "by simp"], ["", "lemmas analytic_imp_holomorphic' = holomorphic_on_subset[OF analytic_imp_holomorphic]"], ["", "lemma residue_simple':\n  assumes \"open s\" \"0 \\<in> s\" \"f holomorphic_on s\"\n  shows   \"residue (\\<lambda>w. f w / w) 0 = f 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. residue (\\<lambda>w. f w / w) 0 = f 0", "using residue_simple[of s 0 f] assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>open s; 0 \\<in> s; f holomorphic_on s\\<rbrakk>\n  \\<Longrightarrow> residue (\\<lambda>w. f w / (w - 0)) 0 = f 0\n  open s\n  0 \\<in> s\n  f holomorphic_on s\n\ngoal (1 subgoal):\n 1. residue (\\<lambda>w. f w / w) 0 = f 0", "by simp"], ["", "lemma fds_converges_cong:\n  assumes \"eventually (\\<lambda>n. fds_nth f n = fds_nth g n) at_top\" \"s = s'\"\n  shows   \"fds_converges f s \\<longleftrightarrow> fds_converges g s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fds_converges f s = fds_converges g s'", "unfolding fds_converges_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. summable (\\<lambda>n. fds_nth f n / nat_power n s) =\n    summable (\\<lambda>n. fds_nth g n / nat_power n s')", "by (intro summable_cong eventually_mono[OF assms(1)]) (simp_all add: assms)"], ["", "lemma fds_abs_converges_cong:\n  assumes \"eventually (\\<lambda>n. fds_nth f n = fds_nth g n) at_top\" \"s = s'\"\n  shows   \"fds_abs_converges f s \\<longleftrightarrow> fds_abs_converges g s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fds_abs_converges f s = fds_abs_converges g s'", "unfolding fds_abs_converges_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. summable (\\<lambda>n. norm (fds_nth f n / nat_power n s)) =\n    summable (\\<lambda>n. norm (fds_nth g n / nat_power n s'))", "by (intro summable_cong eventually_mono[OF assms(1)]) (simp_all add: assms)"], ["", "lemma conv_abscissa_cong:\n  assumes \"eventually (\\<lambda>n. fds_nth f n = fds_nth g n) at_top\"\n  shows   \"conv_abscissa f = conv_abscissa g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. conv_abscissa f = conv_abscissa g", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. conv_abscissa f = conv_abscissa g", "have \"fds_converges f = fds_converges g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fds_converges f = fds_converges g", "by (intro ext fds_converges_cong assms refl)"], ["proof (state)\nthis:\n  fds_converges f = fds_converges g\n\ngoal (1 subgoal):\n 1. conv_abscissa f = conv_abscissa g", "thus ?thesis"], ["proof (prove)\nusing this:\n  fds_converges f = fds_converges g\n\ngoal (1 subgoal):\n 1. conv_abscissa f = conv_abscissa g", "by (simp add: conv_abscissa_def)"], ["proof (state)\nthis:\n  conv_abscissa f = conv_abscissa g\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma abs_conv_abscissa_cong:\n  assumes \"eventually (\\<lambda>n. fds_nth f n = fds_nth g n) at_top\"\n  shows   \"abs_conv_abscissa f = abs_conv_abscissa g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. abs_conv_abscissa f = abs_conv_abscissa g", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. abs_conv_abscissa f = abs_conv_abscissa g", "have \"fds_abs_converges f = fds_abs_converges g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fds_abs_converges f = fds_abs_converges g", "by (intro ext fds_abs_converges_cong assms refl)"], ["proof (state)\nthis:\n  fds_abs_converges f = fds_abs_converges g\n\ngoal (1 subgoal):\n 1. abs_conv_abscissa f = abs_conv_abscissa g", "thus ?thesis"], ["proof (prove)\nusing this:\n  fds_abs_converges f = fds_abs_converges g\n\ngoal (1 subgoal):\n 1. abs_conv_abscissa f = abs_conv_abscissa g", "by (simp add: abs_conv_abscissa_def)"], ["proof (state)\nthis:\n  abs_conv_abscissa f = abs_conv_abscissa g\n\ngoal:\nNo subgoals!", "qed"], ["", "definition fds_remainder where\n  \"fds_remainder m = fds_subseries (\\<lambda>n. n > m)\""], ["", "lemma fds_nth_remainder: \"fds_nth (fds_remainder m f) = (\\<lambda>n. if n > m then fds_nth f n else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fds_nth (fds_remainder m f) =\n    (\\<lambda>n. if m < n then fds_nth f n else (0::'a))", "by (simp add: fds_remainder_def fds_subseries_def fds_nth_fds')"], ["", "lemma fds_converges_remainder_iff [simp]:\n  \"fds_converges (fds_remainder m f) s \\<longleftrightarrow> fds_converges f s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fds_converges (fds_remainder m f) s = fds_converges f s", "by (intro fds_converges_cong eventually_mono[OF eventually_gt_at_top[of m]])\n     (auto simp: fds_nth_remainder)"], ["", "lemma fds_abs_converges_remainder_iff [simp]:\n  \"fds_abs_converges (fds_remainder m f) s \\<longleftrightarrow> fds_abs_converges f s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fds_abs_converges (fds_remainder m f) s = fds_abs_converges f s", "by (intro fds_abs_converges_cong eventually_mono[OF eventually_gt_at_top[of m]])\n     (auto simp: fds_nth_remainder)"], ["", "lemma fds_converges_remainder [intro]:\n        \"fds_converges f s \\<Longrightarrow> fds_converges (fds_remainder m f) s\"\n  and fds_abs_converges_remainder [intro]:\n        \"fds_abs_converges f s \\<Longrightarrow> fds_abs_converges (fds_remainder m f) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (fds_converges f s \\<Longrightarrow>\n     fds_converges (fds_remainder m f) s) &&&\n    (fds_abs_converges f s \\<Longrightarrow>\n     fds_abs_converges (fds_remainder m f) s)", "by simp_all"], ["", "lemma conv_abscissa_remainder [simp]:\n  \"conv_abscissa (fds_remainder m f) = conv_abscissa f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. conv_abscissa (fds_remainder m f) = conv_abscissa f", "by (intro conv_abscissa_cong eventually_mono[OF eventually_gt_at_top[of m]])\n     (auto simp: fds_nth_remainder)"], ["", "lemma abs_conv_abscissa_remainder [simp]:\n  \"abs_conv_abscissa (fds_remainder m f) = abs_conv_abscissa f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. abs_conv_abscissa (fds_remainder m f) = abs_conv_abscissa f", "by (intro abs_conv_abscissa_cong eventually_mono[OF eventually_gt_at_top[of m]])\n     (auto simp: fds_nth_remainder)"], ["", "lemma eval_fds_remainder:\n   \"eval_fds (fds_remainder m f) s = (\\<Sum>n. fds_nth f (n + Suc m) / nat_power (n + Suc m) s)\"\n    (is \"_ = suminf (\\<lambda>n. ?f (n + Suc m))\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_fds (fds_remainder m f) s =\n    (\\<Sum>n. fds_nth f (n + Suc m) / nat_power (n + Suc m) s)", "proof (cases \"fds_converges f s\")"], ["proof (state)\ngoal (2 subgoals):\n 1. fds_converges f s \\<Longrightarrow>\n    eval_fds (fds_remainder m f) s =\n    (\\<Sum>n. fds_nth f (n + Suc m) / nat_power (n + Suc m) s)\n 2. \\<not> fds_converges f s \\<Longrightarrow>\n    eval_fds (fds_remainder m f) s =\n    (\\<Sum>n. fds_nth f (n + Suc m) / nat_power (n + Suc m) s)", "case False"], ["proof (state)\nthis:\n  \\<not> fds_converges f s\n\ngoal (2 subgoals):\n 1. fds_converges f s \\<Longrightarrow>\n    eval_fds (fds_remainder m f) s =\n    (\\<Sum>n. fds_nth f (n + Suc m) / nat_power (n + Suc m) s)\n 2. \\<not> fds_converges f s \\<Longrightarrow>\n    eval_fds (fds_remainder m f) s =\n    (\\<Sum>n. fds_nth f (n + Suc m) / nat_power (n + Suc m) s)", "hence \"\\<not>fds_converges (fds_remainder m f) s\""], ["proof (prove)\nusing this:\n  \\<not> fds_converges f s\n\ngoal (1 subgoal):\n 1. \\<not> fds_converges (fds_remainder m f) s", "by simp"], ["proof (state)\nthis:\n  \\<not> fds_converges (fds_remainder m f) s\n\ngoal (2 subgoals):\n 1. fds_converges f s \\<Longrightarrow>\n    eval_fds (fds_remainder m f) s =\n    (\\<Sum>n. fds_nth f (n + Suc m) / nat_power (n + Suc m) s)\n 2. \\<not> fds_converges f s \\<Longrightarrow>\n    eval_fds (fds_remainder m f) s =\n    (\\<Sum>n. fds_nth f (n + Suc m) / nat_power (n + Suc m) s)", "hence \"(\\<lambda>x. (\\<lambda>n. fds_nth (fds_remainder m f) n / nat_power n s) sums x) = (\\<lambda>_. False)\""], ["proof (prove)\nusing this:\n  \\<not> fds_converges (fds_remainder m f) s\n\ngoal (1 subgoal):\n 1. (sums) (\\<lambda>n. fds_nth (fds_remainder m f) n / nat_power n s) =\n    (\\<lambda>_. False)", "by (auto simp: fds_converges_def summable_def)"], ["proof (state)\nthis:\n  (sums) (\\<lambda>n. fds_nth (fds_remainder m f) n / nat_power n s) =\n  (\\<lambda>_. False)\n\ngoal (2 subgoals):\n 1. fds_converges f s \\<Longrightarrow>\n    eval_fds (fds_remainder m f) s =\n    (\\<Sum>n. fds_nth f (n + Suc m) / nat_power (n + Suc m) s)\n 2. \\<not> fds_converges f s \\<Longrightarrow>\n    eval_fds (fds_remainder m f) s =\n    (\\<Sum>n. fds_nth f (n + Suc m) / nat_power (n + Suc m) s)", "hence \"eval_fds (fds_remainder m f) s = (THE _. False)\""], ["proof (prove)\nusing this:\n  (sums) (\\<lambda>n. fds_nth (fds_remainder m f) n / nat_power n s) =\n  (\\<lambda>_. False)\n\ngoal (1 subgoal):\n 1. eval_fds (fds_remainder m f) s = (THE uu_. False)", "by (simp add: eval_fds_def suminf_def)"], ["proof (state)\nthis:\n  eval_fds (fds_remainder m f) s = (THE uu_. False)\n\ngoal (2 subgoals):\n 1. fds_converges f s \\<Longrightarrow>\n    eval_fds (fds_remainder m f) s =\n    (\\<Sum>n. fds_nth f (n + Suc m) / nat_power (n + Suc m) s)\n 2. \\<not> fds_converges f s \\<Longrightarrow>\n    eval_fds (fds_remainder m f) s =\n    (\\<Sum>n. fds_nth f (n + Suc m) / nat_power (n + Suc m) s)", "moreover"], ["proof (state)\nthis:\n  eval_fds (fds_remainder m f) s = (THE uu_. False)\n\ngoal (2 subgoals):\n 1. fds_converges f s \\<Longrightarrow>\n    eval_fds (fds_remainder m f) s =\n    (\\<Sum>n. fds_nth f (n + Suc m) / nat_power (n + Suc m) s)\n 2. \\<not> fds_converges f s \\<Longrightarrow>\n    eval_fds (fds_remainder m f) s =\n    (\\<Sum>n. fds_nth f (n + Suc m) / nat_power (n + Suc m) s)", "from False"], ["proof (chain)\npicking this:\n  \\<not> fds_converges f s", "have \"\\<not>summable (\\<lambda>n. ?f (n + Suc m))\""], ["proof (prove)\nusing this:\n  \\<not> fds_converges f s\n\ngoal (1 subgoal):\n 1. \\<not> summable\n            (\\<lambda>n. fds_nth f (n + Suc m) / nat_power (n + Suc m) s)", "unfolding fds_converges_def"], ["proof (prove)\nusing this:\n  \\<not> summable (\\<lambda>n. fds_nth f n / nat_power n s)\n\ngoal (1 subgoal):\n 1. \\<not> summable\n            (\\<lambda>n. fds_nth f (n + Suc m) / nat_power (n + Suc m) s)", "by (subst summable_iff_shift) auto"], ["proof (state)\nthis:\n  \\<not> summable\n          (\\<lambda>n. fds_nth f (n + Suc m) / nat_power (n + Suc m) s)\n\ngoal (2 subgoals):\n 1. fds_converges f s \\<Longrightarrow>\n    eval_fds (fds_remainder m f) s =\n    (\\<Sum>n. fds_nth f (n + Suc m) / nat_power (n + Suc m) s)\n 2. \\<not> fds_converges f s \\<Longrightarrow>\n    eval_fds (fds_remainder m f) s =\n    (\\<Sum>n. fds_nth f (n + Suc m) / nat_power (n + Suc m) s)", "hence \"(\\<lambda>x. (\\<lambda>n. ?f (n + Suc m)) sums x) = (\\<lambda>_. False)\""], ["proof (prove)\nusing this:\n  \\<not> summable\n          (\\<lambda>n. fds_nth f (n + Suc m) / nat_power (n + Suc m) s)\n\ngoal (1 subgoal):\n 1. (sums) (\\<lambda>n. fds_nth f (n + Suc m) / nat_power (n + Suc m) s) =\n    (\\<lambda>_. False)", "by (auto simp: summable_def)"], ["proof (state)\nthis:\n  (sums) (\\<lambda>n. fds_nth f (n + Suc m) / nat_power (n + Suc m) s) =\n  (\\<lambda>_. False)\n\ngoal (2 subgoals):\n 1. fds_converges f s \\<Longrightarrow>\n    eval_fds (fds_remainder m f) s =\n    (\\<Sum>n. fds_nth f (n + Suc m) / nat_power (n + Suc m) s)\n 2. \\<not> fds_converges f s \\<Longrightarrow>\n    eval_fds (fds_remainder m f) s =\n    (\\<Sum>n. fds_nth f (n + Suc m) / nat_power (n + Suc m) s)", "hence \"suminf (\\<lambda>n. ?f (n + Suc m)) = (THE _. False)\""], ["proof (prove)\nusing this:\n  (sums) (\\<lambda>n. fds_nth f (n + Suc m) / nat_power (n + Suc m) s) =\n  (\\<lambda>_. False)\n\ngoal (1 subgoal):\n 1. (\\<Sum>n. fds_nth f (n + Suc m) / nat_power (n + Suc m) s) =\n    (THE uu_. False)", "by (simp add: suminf_def)"], ["proof (state)\nthis:\n  (\\<Sum>n. fds_nth f (n + Suc m) / nat_power (n + Suc m) s) =\n  (THE uu_. False)\n\ngoal (2 subgoals):\n 1. fds_converges f s \\<Longrightarrow>\n    eval_fds (fds_remainder m f) s =\n    (\\<Sum>n. fds_nth f (n + Suc m) / nat_power (n + Suc m) s)\n 2. \\<not> fds_converges f s \\<Longrightarrow>\n    eval_fds (fds_remainder m f) s =\n    (\\<Sum>n. fds_nth f (n + Suc m) / nat_power (n + Suc m) s)", "ultimately"], ["proof (chain)\npicking this:\n  eval_fds (fds_remainder m f) s = (THE uu_. False)\n  (\\<Sum>n. fds_nth f (n + Suc m) / nat_power (n + Suc m) s) =\n  (THE uu_. False)", "show ?thesis"], ["proof (prove)\nusing this:\n  eval_fds (fds_remainder m f) s = (THE uu_. False)\n  (\\<Sum>n. fds_nth f (n + Suc m) / nat_power (n + Suc m) s) =\n  (THE uu_. False)\n\ngoal (1 subgoal):\n 1. eval_fds (fds_remainder m f) s =\n    (\\<Sum>n. fds_nth f (n + Suc m) / nat_power (n + Suc m) s)", "by simp"], ["proof (state)\nthis:\n  eval_fds (fds_remainder m f) s =\n  (\\<Sum>n. fds_nth f (n + Suc m) / nat_power (n + Suc m) s)\n\ngoal (1 subgoal):\n 1. fds_converges f s \\<Longrightarrow>\n    eval_fds (fds_remainder m f) s =\n    (\\<Sum>n. fds_nth f (n + Suc m) / nat_power (n + Suc m) s)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. fds_converges f s \\<Longrightarrow>\n    eval_fds (fds_remainder m f) s =\n    (\\<Sum>n. fds_nth f (n + Suc m) / nat_power (n + Suc m) s)", "case True"], ["proof (state)\nthis:\n  fds_converges f s\n\ngoal (1 subgoal):\n 1. fds_converges f s \\<Longrightarrow>\n    eval_fds (fds_remainder m f) s =\n    (\\<Sum>n. fds_nth f (n + Suc m) / nat_power (n + Suc m) s)", "hence *: \"fds_converges (fds_remainder m f) s\""], ["proof (prove)\nusing this:\n  fds_converges f s\n\ngoal (1 subgoal):\n 1. fds_converges (fds_remainder m f) s", "by simp"], ["proof (state)\nthis:\n  fds_converges (fds_remainder m f) s\n\ngoal (1 subgoal):\n 1. fds_converges f s \\<Longrightarrow>\n    eval_fds (fds_remainder m f) s =\n    (\\<Sum>n. fds_nth f (n + Suc m) / nat_power (n + Suc m) s)", "have \"eval_fds (fds_remainder m f) s = (\\<Sum>n. fds_nth (fds_remainder m f) n / nat_power n s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_fds (fds_remainder m f) s =\n    (\\<Sum>n. fds_nth (fds_remainder m f) n / nat_power n s)", "unfolding eval_fds_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>n. fds_nth (fds_remainder m f) n / nat_power n s) =\n    (\\<Sum>n. fds_nth (fds_remainder m f) n / nat_power n s)", ".."], ["proof (state)\nthis:\n  eval_fds (fds_remainder m f) s =\n  (\\<Sum>n. fds_nth (fds_remainder m f) n / nat_power n s)\n\ngoal (1 subgoal):\n 1. fds_converges f s \\<Longrightarrow>\n    eval_fds (fds_remainder m f) s =\n    (\\<Sum>n. fds_nth f (n + Suc m) / nat_power (n + Suc m) s)", "also"], ["proof (state)\nthis:\n  eval_fds (fds_remainder m f) s =\n  (\\<Sum>n. fds_nth (fds_remainder m f) n / nat_power n s)\n\ngoal (1 subgoal):\n 1. fds_converges f s \\<Longrightarrow>\n    eval_fds (fds_remainder m f) s =\n    (\\<Sum>n. fds_nth f (n + Suc m) / nat_power (n + Suc m) s)", "have \"\\<dots> = (\\<Sum>n. fds_nth (fds_remainder m f) (n + Suc m) / nat_power (n + Suc m) s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>n. fds_nth (fds_remainder m f) n / nat_power n s) =\n    (\\<Sum>n.\n        fds_nth (fds_remainder m f) (n + Suc m) / nat_power (n + Suc m) s)", "using *"], ["proof (prove)\nusing this:\n  fds_converges (fds_remainder m f) s\n\ngoal (1 subgoal):\n 1. (\\<Sum>n. fds_nth (fds_remainder m f) n / nat_power n s) =\n    (\\<Sum>n.\n        fds_nth (fds_remainder m f) (n + Suc m) / nat_power (n + Suc m) s)", "unfolding fds_converges_def"], ["proof (prove)\nusing this:\n  summable (\\<lambda>n. fds_nth (fds_remainder m f) n / nat_power n s)\n\ngoal (1 subgoal):\n 1. (\\<Sum>n. fds_nth (fds_remainder m f) n / nat_power n s) =\n    (\\<Sum>n.\n        fds_nth (fds_remainder m f) (n + Suc m) / nat_power (n + Suc m) s)", "by (subst suminf_minus_initial_segment) (auto simp: fds_nth_remainder)"], ["proof (state)\nthis:\n  (\\<Sum>n. fds_nth (fds_remainder m f) n / nat_power n s) =\n  (\\<Sum>n.\n      fds_nth (fds_remainder m f) (n + Suc m) / nat_power (n + Suc m) s)\n\ngoal (1 subgoal):\n 1. fds_converges f s \\<Longrightarrow>\n    eval_fds (fds_remainder m f) s =\n    (\\<Sum>n. fds_nth f (n + Suc m) / nat_power (n + Suc m) s)", "also"], ["proof (state)\nthis:\n  (\\<Sum>n. fds_nth (fds_remainder m f) n / nat_power n s) =\n  (\\<Sum>n.\n      fds_nth (fds_remainder m f) (n + Suc m) / nat_power (n + Suc m) s)\n\ngoal (1 subgoal):\n 1. fds_converges f s \\<Longrightarrow>\n    eval_fds (fds_remainder m f) s =\n    (\\<Sum>n. fds_nth f (n + Suc m) / nat_power (n + Suc m) s)", "have \"(\\<lambda>n. fds_nth (fds_remainder m f) (n + Suc m)) = (\\<lambda>n. fds_nth f (n + Suc m))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n. fds_nth (fds_remainder m f) (n + Suc m)) =\n    (\\<lambda>n. fds_nth f (n + Suc m))", "by (intro ext) (auto simp: fds_nth_remainder)"], ["proof (state)\nthis:\n  (\\<lambda>n. fds_nth (fds_remainder m f) (n + Suc m)) =\n  (\\<lambda>n. fds_nth f (n + Suc m))\n\ngoal (1 subgoal):\n 1. fds_converges f s \\<Longrightarrow>\n    eval_fds (fds_remainder m f) s =\n    (\\<Sum>n. fds_nth f (n + Suc m) / nat_power (n + Suc m) s)", "finally"], ["proof (chain)\npicking this:\n  eval_fds (fds_remainder m f) s =\n  (\\<Sum>n. fds_nth f (n + Suc m) / nat_power (n + Suc m) s)", "show ?thesis"], ["proof (prove)\nusing this:\n  eval_fds (fds_remainder m f) s =\n  (\\<Sum>n. fds_nth f (n + Suc m) / nat_power (n + Suc m) s)\n\ngoal (1 subgoal):\n 1. eval_fds (fds_remainder m f) s =\n    (\\<Sum>n. fds_nth f (n + Suc m) / nat_power (n + Suc m) s)", "."], ["proof (state)\nthis:\n  eval_fds (fds_remainder m f) s =\n  (\\<Sum>n. fds_nth f (n + Suc m) / nat_power (n + Suc m) s)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma fds_truncate_plus_remainder: \"fds_truncate m f + fds_remainder m f = f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fds_truncate m f + fds_remainder m f = f", "by (intro fds_eqI) (auto simp: fds_truncate_def fds_remainder_def fds_subseries_def)"], ["", "lemma holomorphic_fds_eval' [holomorphic_intros]:\n  assumes \"g holomorphic_on A\" \"\\<And>x. x \\<in> A \\<Longrightarrow> Re (g x) > conv_abscissa f\"\n  shows   \"(\\<lambda>x. eval_fds f (g x)) holomorphic_on A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. eval_fds f (g x)) holomorphic_on A", "using holomorphic_on_compose_gen[OF assms(1) holomorphic_fds_eval[OF order.refl, of f]] assms(2)"], ["proof (prove)\nusing this:\n  g ` A \\<subseteq> {z. conv_abscissa f < ereal (Re z)} \\<Longrightarrow>\n  eval_fds f \\<circ> g holomorphic_on A\n  ?x \\<in> A \\<Longrightarrow> conv_abscissa f < ereal (Re (g ?x))\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. eval_fds f (g x)) holomorphic_on A", "by (auto simp: o_def)"], ["", "lemma analytic_fds_eval' [analytic_intros]:\n  assumes \"g analytic_on A\" \"\\<And>x. x \\<in> A \\<Longrightarrow> Re (g x) > conv_abscissa f\"\n  shows   \"(\\<lambda>x. eval_fds f (g x)) analytic_on A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. eval_fds f (g x)) analytic_on A", "using analytic_on_compose_gen[OF assms(1) analytic_fds_eval[OF order.refl, of f]] assms(2)"], ["proof (prove)\nusing this:\n  (\\<And>z.\n      z \\<in> A \\<Longrightarrow>\n      g z \\<in> {z. conv_abscissa f < ereal (Re z)}) \\<Longrightarrow>\n  eval_fds f \\<circ> g analytic_on A\n  ?x \\<in> A \\<Longrightarrow> conv_abscissa f < ereal (Re (g ?x))\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. eval_fds f (g x)) analytic_on A", "by (auto simp: o_def)"], ["", "lemma homotopic_loopsI:\n  fixes h :: \"real \\<times> real \\<Rightarrow> _\"\n  assumes \"continuous_on ({0..1} \\<times> {0..1}) h\"\n          \"h ` ({0..1} \\<times> {0..1}) \\<subseteq> s\"\n          \"\\<And>x. x \\<in> {0..1} \\<Longrightarrow> h (0, x) = p x\"\n          \"\\<And>x. x \\<in> {0..1} \\<Longrightarrow> h (1, x) = q x\"\n          \"\\<And>x. x \\<in> {0..1} \\<Longrightarrow> pathfinish (h \\<circ> Pair x) = pathstart (h \\<circ> Pair x)\"\n  shows   \"homotopic_loops s p q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. homotopic_loops s p q", "using assms"], ["proof (prove)\nusing this:\n  continuous_on ({0..1} \\<times> {0..1}) h\n  h ` ({0..1} \\<times> {0..1}) \\<subseteq> s\n  ?x \\<in> {0..1} \\<Longrightarrow> h (0, ?x) = p ?x\n  ?x \\<in> {0..1} \\<Longrightarrow> h (1, ?x) = q ?x\n  ?x \\<in> {0..1} \\<Longrightarrow>\n  pathfinish (h \\<circ> Pair ?x) = pathstart (h \\<circ> Pair ?x)\n\ngoal (1 subgoal):\n 1. homotopic_loops s p q", "unfolding homotopic_loops"], ["proof (prove)\nusing this:\n  continuous_on ({0..1} \\<times> {0..1}) h\n  h ` ({0..1} \\<times> {0..1}) \\<subseteq> s\n  ?x \\<in> {0..1} \\<Longrightarrow> h (0, ?x) = p ?x\n  ?x \\<in> {0..1} \\<Longrightarrow> h (1, ?x) = q ?x\n  ?x \\<in> {0..1} \\<Longrightarrow>\n  pathfinish (h \\<circ> Pair ?x) = pathstart (h \\<circ> Pair ?x)\n\ngoal (1 subgoal):\n 1. \\<exists>h.\n       continuous_on ({0..1} \\<times> {0..1}) h \\<and>\n       h ` ({0..1} \\<times> {0..1}) \\<subseteq> s \\<and>\n       (\\<forall>x\\<in>{0..1}. h (0, x) = p x) \\<and>\n       (\\<forall>x\\<in>{0..1}. h (1, x) = q x) \\<and>\n       (\\<forall>t\\<in>{0..1}.\n           pathfinish (h \\<circ> Pair t) = pathstart (h \\<circ> Pair t))", "by (intro exI[of _ h]) auto"], ["", "lemma continuous_on_linepath [continuous_intros]:\n  assumes \"continuous_on A a\" \"continuous_on A b\" \"continuous_on A f\"\n  shows   \"continuous_on A (\\<lambda>x. linepath (a x) (b x) (f x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_on A (\\<lambda>x. linepath (a x) (b x) (f x))", "using assms"], ["proof (prove)\nusing this:\n  continuous_on A a\n  continuous_on A b\n  continuous_on A f\n\ngoal (1 subgoal):\n 1. continuous_on A (\\<lambda>x. linepath (a x) (b x) (f x))", "by (auto simp: linepath_def intro!: continuous_intros assms)"], ["", "lemma continuous_on_part_circlepath [continuous_intros]:\n  assumes \"continuous_on A c\" \"continuous_on A r\" \"continuous_on A a\" \"continuous_on A b\"\n          \"continuous_on A f\"\n  shows   \"continuous_on A (\\<lambda>x. part_circlepath (c x) (r x) (a x) (b x) (f x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_on A\n     (\\<lambda>x. part_circlepath (c x) (r x) (a x) (b x) (f x))", "using assms"], ["proof (prove)\nusing this:\n  continuous_on A c\n  continuous_on A r\n  continuous_on A a\n  continuous_on A b\n  continuous_on A f\n\ngoal (1 subgoal):\n 1. continuous_on A\n     (\\<lambda>x. part_circlepath (c x) (r x) (a x) (b x) (f x))", "by (auto simp: part_circlepath_def intro!: continuous_intros assms)"], ["", "lemma homotopic_loops_part_circlepath:\n  assumes \"sphere c r \\<subseteq> A\" and \"r \\<ge> 0\" and\n          \"b1 = a1 + 2 * of_int k * pi\" and \"b2 = a2 + 2 * of_int k * pi\"\n  shows   \"homotopic_loops A (part_circlepath c r a1 b1) (part_circlepath c r a2 b2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. homotopic_loops A (part_circlepath c r a1 b1)\n     (part_circlepath c r a2 b2)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. homotopic_loops A (part_circlepath c r a1 b1)\n     (part_circlepath c r a2 b2)", "define h where \"h = (\\<lambda>(x,y). part_circlepath c r (linepath a1 a2 x) (linepath b1 b2 x) y)\""], ["proof (state)\nthis:\n  h =\n  (\\<lambda>(x, y).\n      part_circlepath c r (linepath a1 a2 x) (linepath b1 b2 x) y)\n\ngoal (1 subgoal):\n 1. homotopic_loops A (part_circlepath c r a1 b1)\n     (part_circlepath c r a2 b2)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. homotopic_loops A (part_circlepath c r a1 b1)\n     (part_circlepath c r a2 b2)", "proof (rule homotopic_loopsI)"], ["proof (state)\ngoal (5 subgoals):\n 1. continuous_on ({0..1} \\<times> {0..1}) ?h\n 2. ?h ` ({0..1} \\<times> {0..1}) \\<subseteq> A\n 3. \\<And>x.\n       x \\<in> {0..1} \\<Longrightarrow>\n       ?h (0, x) = part_circlepath c r a1 b1 x\n 4. \\<And>x.\n       x \\<in> {0..1} \\<Longrightarrow>\n       ?h (1, x) = part_circlepath c r a2 b2 x\n 5. \\<And>x.\n       x \\<in> {0..1} \\<Longrightarrow>\n       pathfinish (?h \\<circ> Pair x) = pathstart (?h \\<circ> Pair x)", "show \"continuous_on ({0..1} \\<times> {0..1}) h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_on ({0..1} \\<times> {0..1}) h", "by (auto simp: h_def case_prod_unfold intro!: continuous_intros)"], ["proof (state)\nthis:\n  continuous_on ({0..1} \\<times> {0..1}) h\n\ngoal (4 subgoals):\n 1. h ` ({0..1} \\<times> {0..1}) \\<subseteq> A\n 2. \\<And>x.\n       x \\<in> {0..1} \\<Longrightarrow>\n       h (0, x) = part_circlepath c r a1 b1 x\n 3. \\<And>x.\n       x \\<in> {0..1} \\<Longrightarrow>\n       h (1, x) = part_circlepath c r a2 b2 x\n 4. \\<And>x.\n       x \\<in> {0..1} \\<Longrightarrow>\n       pathfinish (h \\<circ> Pair x) = pathstart (h \\<circ> Pair x)", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. h ` ({0..1} \\<times> {0..1}) \\<subseteq> A\n 2. \\<And>x.\n       x \\<in> {0..1} \\<Longrightarrow>\n       h (0, x) = part_circlepath c r a1 b1 x\n 3. \\<And>x.\n       x \\<in> {0..1} \\<Longrightarrow>\n       h (1, x) = part_circlepath c r a2 b2 x\n 4. \\<And>x.\n       x \\<in> {0..1} \\<Longrightarrow>\n       pathfinish (h \\<circ> Pair x) = pathstart (h \\<circ> Pair x)", "from assms"], ["proof (chain)\npicking this:\n  sphere c r \\<subseteq> A\n  0 \\<le> r\n  b1 = a1 + 2 * real_of_int k * pi\n  b2 = a2 + 2 * real_of_int k * pi", "have \"h ` ({0..1} \\<times> {0..1}) \\<subseteq> sphere c r\""], ["proof (prove)\nusing this:\n  sphere c r \\<subseteq> A\n  0 \\<le> r\n  b1 = a1 + 2 * real_of_int k * pi\n  b2 = a2 + 2 * real_of_int k * pi\n\ngoal (1 subgoal):\n 1. h ` ({0..1} \\<times> {0..1}) \\<subseteq> sphere c r", "by (auto simp: h_def part_circlepath_def dist_norm norm_mult)"], ["proof (state)\nthis:\n  h ` ({0..1} \\<times> {0..1}) \\<subseteq> sphere c r\n\ngoal (4 subgoals):\n 1. h ` ({0..1} \\<times> {0..1}) \\<subseteq> A\n 2. \\<And>x.\n       x \\<in> {0..1} \\<Longrightarrow>\n       h (0, x) = part_circlepath c r a1 b1 x\n 3. \\<And>x.\n       x \\<in> {0..1} \\<Longrightarrow>\n       h (1, x) = part_circlepath c r a2 b2 x\n 4. \\<And>x.\n       x \\<in> {0..1} \\<Longrightarrow>\n       pathfinish (h \\<circ> Pair x) = pathstart (h \\<circ> Pair x)", "also"], ["proof (state)\nthis:\n  h ` ({0..1} \\<times> {0..1}) \\<subseteq> sphere c r\n\ngoal (4 subgoals):\n 1. h ` ({0..1} \\<times> {0..1}) \\<subseteq> A\n 2. \\<And>x.\n       x \\<in> {0..1} \\<Longrightarrow>\n       h (0, x) = part_circlepath c r a1 b1 x\n 3. \\<And>x.\n       x \\<in> {0..1} \\<Longrightarrow>\n       h (1, x) = part_circlepath c r a2 b2 x\n 4. \\<And>x.\n       x \\<in> {0..1} \\<Longrightarrow>\n       pathfinish (h \\<circ> Pair x) = pathstart (h \\<circ> Pair x)", "have \"\\<dots> \\<subseteq> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sphere c r \\<subseteq> A", "by fact"], ["proof (state)\nthis:\n  sphere c r \\<subseteq> A\n\ngoal (4 subgoals):\n 1. h ` ({0..1} \\<times> {0..1}) \\<subseteq> A\n 2. \\<And>x.\n       x \\<in> {0..1} \\<Longrightarrow>\n       h (0, x) = part_circlepath c r a1 b1 x\n 3. \\<And>x.\n       x \\<in> {0..1} \\<Longrightarrow>\n       h (1, x) = part_circlepath c r a2 b2 x\n 4. \\<And>x.\n       x \\<in> {0..1} \\<Longrightarrow>\n       pathfinish (h \\<circ> Pair x) = pathstart (h \\<circ> Pair x)", "finally"], ["proof (chain)\npicking this:\n  h ` ({0..1} \\<times> {0..1}) \\<subseteq> A", "show \"h ` ({0..1} \\<times> {0..1}) \\<subseteq> A\""], ["proof (prove)\nusing this:\n  h ` ({0..1} \\<times> {0..1}) \\<subseteq> A\n\ngoal (1 subgoal):\n 1. h ` ({0..1} \\<times> {0..1}) \\<subseteq> A", "."], ["proof (state)\nthis:\n  h ` ({0..1} \\<times> {0..1}) \\<subseteq> A\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       x \\<in> {0..1} \\<Longrightarrow>\n       h (0, x) = part_circlepath c r a1 b1 x\n 2. \\<And>x.\n       x \\<in> {0..1} \\<Longrightarrow>\n       h (1, x) = part_circlepath c r a2 b2 x\n 3. \\<And>x.\n       x \\<in> {0..1} \\<Longrightarrow>\n       pathfinish (h \\<circ> Pair x) = pathstart (h \\<circ> Pair x)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x.\n       x \\<in> {0..1} \\<Longrightarrow>\n       h (0, x) = part_circlepath c r a1 b1 x\n 2. \\<And>x.\n       x \\<in> {0..1} \\<Longrightarrow>\n       h (1, x) = part_circlepath c r a2 b2 x\n 3. \\<And>x.\n       x \\<in> {0..1} \\<Longrightarrow>\n       pathfinish (h \\<circ> Pair x) = pathstart (h \\<circ> Pair x)", "fix x :: real"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x.\n       x \\<in> {0..1} \\<Longrightarrow>\n       h (0, x) = part_circlepath c r a1 b1 x\n 2. \\<And>x.\n       x \\<in> {0..1} \\<Longrightarrow>\n       h (1, x) = part_circlepath c r a2 b2 x\n 3. \\<And>x.\n       x \\<in> {0..1} \\<Longrightarrow>\n       pathfinish (h \\<circ> Pair x) = pathstart (h \\<circ> Pair x)", "assume x: \"x \\<in> {0..1}\""], ["proof (state)\nthis:\n  x \\<in> {0..1}\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       x \\<in> {0..1} \\<Longrightarrow>\n       h (0, x) = part_circlepath c r a1 b1 x\n 2. \\<And>x.\n       x \\<in> {0..1} \\<Longrightarrow>\n       h (1, x) = part_circlepath c r a2 b2 x\n 3. \\<And>x.\n       x \\<in> {0..1} \\<Longrightarrow>\n       pathfinish (h \\<circ> Pair x) = pathstart (h \\<circ> Pair x)", "show \"h (0, x) = part_circlepath c r a1 b1 x\" and \"h (1, x) = part_circlepath c r a2 b2 x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h (0, x) = part_circlepath c r a1 b1 x &&&\n    h (1, x) = part_circlepath c r a2 b2 x", "by (simp_all add: h_def linepath_def)"], ["proof (state)\nthis:\n  h (0, x) = part_circlepath c r a1 b1 x\n  h (1, x) = part_circlepath c r a2 b2 x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0..1} \\<Longrightarrow>\n       pathfinish (h \\<circ> Pair x) = pathstart (h \\<circ> Pair x)", "have \"cis (pi * (real_of_int k * 2)) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cis (pi * (real_of_int k * 2)) = 1", "using cis.plus_of_int[of 0 k]"], ["proof (prove)\nusing this:\n  cis (0 + real_of_int k * (2 * pi)) = cis 0\n\ngoal (1 subgoal):\n 1. cis (pi * (real_of_int k * 2)) = 1", "by (simp add: algebra_simps)"], ["proof (state)\nthis:\n  cis (pi * (real_of_int k * 2)) = 1\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0..1} \\<Longrightarrow>\n       pathfinish (h \\<circ> Pair x) = pathstart (h \\<circ> Pair x)", "thus \"pathfinish (h \\<circ> Pair x) = pathstart (h \\<circ> Pair x)\""], ["proof (prove)\nusing this:\n  cis (pi * (real_of_int k * 2)) = 1\n\ngoal (1 subgoal):\n 1. pathfinish (h \\<circ> Pair x) = pathstart (h \\<circ> Pair x)", "by (simp add: h_def o_def exp_eq_polar linepath_def algebra_simps\n                    cis_mult [symmetric] cis_divide [symmetric] assms)"], ["proof (state)\nthis:\n  pathfinish (h \\<circ> Pair x) = pathstart (h \\<circ> Pair x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  homotopic_loops A (part_circlepath c r a1 b1) (part_circlepath c r a2 b2)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma homotopic_pathsI:\n  fixes h :: \"real \\<times> real \\<Rightarrow> _\"\n  assumes \"continuous_on ({0..1} \\<times> {0..1}) h\"\n  assumes \"h ` ({0..1} \\<times> {0..1}) \\<subseteq> s\"\n  assumes \"\\<And>x. x \\<in> {0..1} \\<Longrightarrow> h (0, x) = p x\"\n  assumes \"\\<And>x. x \\<in> {0..1} \\<Longrightarrow> h (1, x) = q x\"\n  assumes \"\\<And>x. x \\<in> {0..1} \\<Longrightarrow> pathstart (h \\<circ> Pair x) = pathstart p\"\n  assumes \"\\<And>x. x \\<in> {0..1} \\<Longrightarrow> pathfinish (h \\<circ> Pair x) = pathfinish p\"\n  shows   \"homotopic_paths s p q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. homotopic_paths s p q", "using assms"], ["proof (prove)\nusing this:\n  continuous_on ({0..1} \\<times> {0..1}) h\n  h ` ({0..1} \\<times> {0..1}) \\<subseteq> s\n  ?x \\<in> {0..1} \\<Longrightarrow> h (0, ?x) = p ?x\n  ?x \\<in> {0..1} \\<Longrightarrow> h (1, ?x) = q ?x\n  ?x \\<in> {0..1} \\<Longrightarrow>\n  pathstart (h \\<circ> Pair ?x) = pathstart p\n  ?x \\<in> {0..1} \\<Longrightarrow>\n  pathfinish (h \\<circ> Pair ?x) = pathfinish p\n\ngoal (1 subgoal):\n 1. homotopic_paths s p q", "unfolding homotopic_paths"], ["proof (prove)\nusing this:\n  continuous_on ({0..1} \\<times> {0..1}) h\n  h ` ({0..1} \\<times> {0..1}) \\<subseteq> s\n  ?x \\<in> {0..1} \\<Longrightarrow> h (0, ?x) = p ?x\n  ?x \\<in> {0..1} \\<Longrightarrow> h (1, ?x) = q ?x\n  ?x \\<in> {0..1} \\<Longrightarrow>\n  pathstart (h \\<circ> Pair ?x) = pathstart p\n  ?x \\<in> {0..1} \\<Longrightarrow>\n  pathfinish (h \\<circ> Pair ?x) = pathfinish p\n\ngoal (1 subgoal):\n 1. \\<exists>h.\n       continuous_on ({0..1} \\<times> {0..1}) h \\<and>\n       h ` ({0..1} \\<times> {0..1}) \\<subseteq> s \\<and>\n       (\\<forall>x\\<in>{0..1}. h (0, x) = p x) \\<and>\n       (\\<forall>x\\<in>{0..1}. h (1, x) = q x) \\<and>\n       (\\<forall>t\\<in>{0..1}.\n           pathstart (h \\<circ> Pair t) = pathstart p \\<and>\n           pathfinish (h \\<circ> Pair t) = pathfinish p)", "by (intro exI[of _ h]) auto"], ["", "lemma part_circlepath_conv_subpath:\n  \"part_circlepath c r a b = subpath (a / (2*pi)) (b / (2*pi)) (circlepath c r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. part_circlepath c r a b =\n    subpath (a / (2 * pi)) (b / (2 * pi)) (circlepath c r)", "by (simp add: part_circlepath_def circlepath_def subpath_def linepath_def algebra_simps exp_eq_polar)"], ["", "lemma homotopic_paths_part_circlepath:\n  assumes \"a \\<le> b\" \"b \\<le> c\"\n  assumes \"path_image (part_circlepath C r a c) \\<subseteq> A\" \"r \\<ge> 0\"\n  shows   \"homotopic_paths A (part_circlepath C r a c)\n             (part_circlepath C r a b +++ part_circlepath C r b c)\"\n  (is \"homotopic_paths _ ?g (?h1 +++ ?h2)\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. homotopic_paths A (part_circlepath C r a c)\n     (part_circlepath C r a b +++ part_circlepath C r b c)", "proof (cases \"a = c\")"], ["proof (state)\ngoal (2 subgoals):\n 1. a = c \\<Longrightarrow>\n    homotopic_paths A (part_circlepath C r a c)\n     (part_circlepath C r a b +++ part_circlepath C r b c)\n 2. a \\<noteq> c \\<Longrightarrow>\n    homotopic_paths A (part_circlepath C r a c)\n     (part_circlepath C r a b +++ part_circlepath C r b c)", "case False"], ["proof (state)\nthis:\n  a \\<noteq> c\n\ngoal (2 subgoals):\n 1. a = c \\<Longrightarrow>\n    homotopic_paths A (part_circlepath C r a c)\n     (part_circlepath C r a b +++ part_circlepath C r b c)\n 2. a \\<noteq> c \\<Longrightarrow>\n    homotopic_paths A (part_circlepath C r a c)\n     (part_circlepath C r a b +++ part_circlepath C r b c)", "with assms"], ["proof (chain)\npicking this:\n  a \\<le> b\n  b \\<le> c\n  path_image (part_circlepath C r a c) \\<subseteq> A\n  0 \\<le> r\n  a \\<noteq> c", "have \"a < c\""], ["proof (prove)\nusing this:\n  a \\<le> b\n  b \\<le> c\n  path_image (part_circlepath C r a c) \\<subseteq> A\n  0 \\<le> r\n  a \\<noteq> c\n\ngoal (1 subgoal):\n 1. a < c", "by simp"], ["proof (state)\nthis:\n  a < c\n\ngoal (2 subgoals):\n 1. a = c \\<Longrightarrow>\n    homotopic_paths A (part_circlepath C r a c)\n     (part_circlepath C r a b +++ part_circlepath C r b c)\n 2. a \\<noteq> c \\<Longrightarrow>\n    homotopic_paths A (part_circlepath C r a c)\n     (part_circlepath C r a b +++ part_circlepath C r b c)", "define slope where \"slope = (b - a) / (c - a)\""], ["proof (state)\nthis:\n  slope = (b - a) / (c - a)\n\ngoal (2 subgoals):\n 1. a = c \\<Longrightarrow>\n    homotopic_paths A (part_circlepath C r a c)\n     (part_circlepath C r a b +++ part_circlepath C r b c)\n 2. a \\<noteq> c \\<Longrightarrow>\n    homotopic_paths A (part_circlepath C r a c)\n     (part_circlepath C r a b +++ part_circlepath C r b c)", "from assms and \\<open>a < c\\<close>"], ["proof (chain)\npicking this:\n  a \\<le> b\n  b \\<le> c\n  path_image (part_circlepath C r a c) \\<subseteq> A\n  0 \\<le> r\n  a < c", "have slope: \"slope \\<in> {0..1}\""], ["proof (prove)\nusing this:\n  a \\<le> b\n  b \\<le> c\n  path_image (part_circlepath C r a c) \\<subseteq> A\n  0 \\<le> r\n  a < c\n\ngoal (1 subgoal):\n 1. slope \\<in> {0..1}", "by (auto simp: field_simps slope_def)"], ["proof (state)\nthis:\n  slope \\<in> {0..1}\n\ngoal (2 subgoals):\n 1. a = c \\<Longrightarrow>\n    homotopic_paths A (part_circlepath C r a c)\n     (part_circlepath C r a b +++ part_circlepath C r b c)\n 2. a \\<noteq> c \\<Longrightarrow>\n    homotopic_paths A (part_circlepath C r a c)\n     (part_circlepath C r a b +++ part_circlepath C r b c)", "define f :: \"real \\<Rightarrow> real\" where\n    \"f = linepath 0 slope +++ linepath slope 1\""], ["proof (state)\nthis:\n  f = linepath 0 slope +++ linepath slope 1\n\ngoal (2 subgoals):\n 1. a = c \\<Longrightarrow>\n    homotopic_paths A (part_circlepath C r a c)\n     (part_circlepath C r a b +++ part_circlepath C r b c)\n 2. a \\<noteq> c \\<Longrightarrow>\n    homotopic_paths A (part_circlepath C r a c)\n     (part_circlepath C r a b +++ part_circlepath C r b c)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. homotopic_paths A (part_circlepath C r a c)\n     (part_circlepath C r a b +++ part_circlepath C r b c)", "proof (rule homotopic_paths_reparametrize)"], ["proof (state)\ngoal (7 subgoals):\n 1. path (part_circlepath C r a c)\n 2. path_image (part_circlepath C r a c) \\<subseteq> A\n 3. continuous_on {0..1} ?f\n 4. ?f ` {0..1} \\<subseteq> {0..1}\n 5. ?f 0 = 0\n 6. ?f 1 = 1\n 7. \\<And>t.\n       t \\<in> {0..1} \\<Longrightarrow>\n       (part_circlepath C r a b +++ part_circlepath C r b c) t =\n       part_circlepath C r a c (?f t)", "fix t :: real"], ["proof (state)\ngoal (7 subgoals):\n 1. path (part_circlepath C r a c)\n 2. path_image (part_circlepath C r a c) \\<subseteq> A\n 3. continuous_on {0..1} ?f\n 4. ?f ` {0..1} \\<subseteq> {0..1}\n 5. ?f 0 = 0\n 6. ?f 1 = 1\n 7. \\<And>t.\n       t \\<in> {0..1} \\<Longrightarrow>\n       (part_circlepath C r a b +++ part_circlepath C r b c) t =\n       part_circlepath C r a c (?f t)", "assume t: \"t \\<in> {0..1}\""], ["proof (state)\nthis:\n  t \\<in> {0..1}\n\ngoal (7 subgoals):\n 1. path (part_circlepath C r a c)\n 2. path_image (part_circlepath C r a c) \\<subseteq> A\n 3. continuous_on {0..1} ?f\n 4. ?f ` {0..1} \\<subseteq> {0..1}\n 5. ?f 0 = 0\n 6. ?f 1 = 1\n 7. \\<And>t.\n       t \\<in> {0..1} \\<Longrightarrow>\n       (part_circlepath C r a b +++ part_circlepath C r b c) t =\n       part_circlepath C r a c (?f t)", "show \"(?h1 +++ ?h2) t = ?g (f t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (part_circlepath C r a b +++ part_circlepath C r b c) t =\n    part_circlepath C r a c (f t)", "proof (cases \"t \\<le> 1 / 2\")"], ["proof (state)\ngoal (2 subgoals):\n 1. t \\<le> 1 / 2 \\<Longrightarrow>\n    (part_circlepath C r a b +++ part_circlepath C r b c) t =\n    part_circlepath C r a c (f t)\n 2. \\<not> t \\<le> 1 / 2 \\<Longrightarrow>\n    (part_circlepath C r a b +++ part_circlepath C r b c) t =\n    part_circlepath C r a c (f t)", "case True"], ["proof (state)\nthis:\n  t \\<le> 1 / 2\n\ngoal (2 subgoals):\n 1. t \\<le> 1 / 2 \\<Longrightarrow>\n    (part_circlepath C r a b +++ part_circlepath C r b c) t =\n    part_circlepath C r a c (f t)\n 2. \\<not> t \\<le> 1 / 2 \\<Longrightarrow>\n    (part_circlepath C r a b +++ part_circlepath C r b c) t =\n    part_circlepath C r a c (f t)", "hence \"?g (f t) = C + r * cis ((1 - f t) * a + f t * c)\""], ["proof (prove)\nusing this:\n  t \\<le> 1 / 2\n\ngoal (1 subgoal):\n 1. part_circlepath C r a c (f t) =\n    C + complex_of_real r * cis ((1 - f t) * a + f t * c)", "by (simp add: joinpaths_def part_circlepath_def exp_eq_polar linepath_def)"], ["proof (state)\nthis:\n  part_circlepath C r a c (f t) =\n  C + complex_of_real r * cis ((1 - f t) * a + f t * c)\n\ngoal (2 subgoals):\n 1. t \\<le> 1 / 2 \\<Longrightarrow>\n    (part_circlepath C r a b +++ part_circlepath C r b c) t =\n    part_circlepath C r a c (f t)\n 2. \\<not> t \\<le> 1 / 2 \\<Longrightarrow>\n    (part_circlepath C r a b +++ part_circlepath C r b c) t =\n    part_circlepath C r a c (f t)", "also"], ["proof (state)\nthis:\n  part_circlepath C r a c (f t) =\n  C + complex_of_real r * cis ((1 - f t) * a + f t * c)\n\ngoal (2 subgoals):\n 1. t \\<le> 1 / 2 \\<Longrightarrow>\n    (part_circlepath C r a b +++ part_circlepath C r b c) t =\n    part_circlepath C r a c (f t)\n 2. \\<not> t \\<le> 1 / 2 \\<Longrightarrow>\n    (part_circlepath C r a b +++ part_circlepath C r b c) t =\n    part_circlepath C r a c (f t)", "from True \\<open>a < c\\<close>"], ["proof (chain)\npicking this:\n  t \\<le> 1 / 2\n  a < c", "have \"(1 - f t) * a + f t * c = (1 - 2 * t) * a + 2 * t * b\""], ["proof (prove)\nusing this:\n  t \\<le> 1 / 2\n  a < c\n\ngoal (1 subgoal):\n 1. (1 - f t) * a + f t * c = (1 - 2 * t) * a + 2 * t * b", "unfolding f_def slope_def linepath_def joinpaths_def"], ["proof (prove)\nusing this:\n  t \\<le> 1 / 2\n  a < c\n\ngoal (1 subgoal):\n 1. (1 -\n     (if t \\<le> 1 / 2\n      then (1 - 2 * t) *\\<^sub>R 0 + (2 * t) *\\<^sub>R ((b - a) / (c - a))\n      else (1 - (2 * t - 1)) *\\<^sub>R ((b - a) / (c - a)) +\n           (2 * t - 1) *\\<^sub>R 1)) *\n    a +\n    (if t \\<le> 1 / 2\n     then (1 - 2 * t) *\\<^sub>R 0 + (2 * t) *\\<^sub>R ((b - a) / (c - a))\n     else (1 - (2 * t - 1)) *\\<^sub>R ((b - a) / (c - a)) +\n          (2 * t - 1) *\\<^sub>R 1) *\n    c =\n    (1 - 2 * t) * a + 2 * t * b", "by (simp add: divide_simps del: div_mult_self3 div_mult_self4 div_mult_self2 div_mult_self1)\n           (simp add: algebra_simps)?"], ["proof (state)\nthis:\n  (1 - f t) * a + f t * c = (1 - 2 * t) * a + 2 * t * b\n\ngoal (2 subgoals):\n 1. t \\<le> 1 / 2 \\<Longrightarrow>\n    (part_circlepath C r a b +++ part_circlepath C r b c) t =\n    part_circlepath C r a c (f t)\n 2. \\<not> t \\<le> 1 / 2 \\<Longrightarrow>\n    (part_circlepath C r a b +++ part_circlepath C r b c) t =\n    part_circlepath C r a c (f t)", "also"], ["proof (state)\nthis:\n  (1 - f t) * a + f t * c = (1 - 2 * t) * a + 2 * t * b\n\ngoal (2 subgoals):\n 1. t \\<le> 1 / 2 \\<Longrightarrow>\n    (part_circlepath C r a b +++ part_circlepath C r b c) t =\n    part_circlepath C r a c (f t)\n 2. \\<not> t \\<le> 1 / 2 \\<Longrightarrow>\n    (part_circlepath C r a b +++ part_circlepath C r b c) t =\n    part_circlepath C r a c (f t)", "from True"], ["proof (chain)\npicking this:\n  t \\<le> 1 / 2", "have \"C + r * cis \\<dots> = (?h1 +++ ?h2) t\""], ["proof (prove)\nusing this:\n  t \\<le> 1 / 2\n\ngoal (1 subgoal):\n 1. C + complex_of_real r * cis ((1 - 2 * t) * a + 2 * t * b) =\n    (part_circlepath C r a b +++ part_circlepath C r b c) t", "by (simp add: joinpaths_def part_circlepath_def exp_eq_polar linepath_def)"], ["proof (state)\nthis:\n  C + complex_of_real r * cis ((1 - 2 * t) * a + 2 * t * b) =\n  (part_circlepath C r a b +++ part_circlepath C r b c) t\n\ngoal (2 subgoals):\n 1. t \\<le> 1 / 2 \\<Longrightarrow>\n    (part_circlepath C r a b +++ part_circlepath C r b c) t =\n    part_circlepath C r a c (f t)\n 2. \\<not> t \\<le> 1 / 2 \\<Longrightarrow>\n    (part_circlepath C r a b +++ part_circlepath C r b c) t =\n    part_circlepath C r a c (f t)", "finally"], ["proof (chain)\npicking this:\n  part_circlepath C r a c (f t) =\n  (part_circlepath C r a b +++ part_circlepath C r b c) t", "show ?thesis"], ["proof (prove)\nusing this:\n  part_circlepath C r a c (f t) =\n  (part_circlepath C r a b +++ part_circlepath C r b c) t\n\ngoal (1 subgoal):\n 1. (part_circlepath C r a b +++ part_circlepath C r b c) t =\n    part_circlepath C r a c (f t)", ".."], ["proof (state)\nthis:\n  (part_circlepath C r a b +++ part_circlepath C r b c) t =\n  part_circlepath C r a c (f t)\n\ngoal (1 subgoal):\n 1. \\<not> t \\<le> 1 / 2 \\<Longrightarrow>\n    (part_circlepath C r a b +++ part_circlepath C r b c) t =\n    part_circlepath C r a c (f t)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> t \\<le> 1 / 2 \\<Longrightarrow>\n    (part_circlepath C r a b +++ part_circlepath C r b c) t =\n    part_circlepath C r a c (f t)", "case False"], ["proof (state)\nthis:\n  \\<not> t \\<le> 1 / 2\n\ngoal (1 subgoal):\n 1. \\<not> t \\<le> 1 / 2 \\<Longrightarrow>\n    (part_circlepath C r a b +++ part_circlepath C r b c) t =\n    part_circlepath C r a c (f t)", "hence \"?g (f t) = C + r * cis ((1 - f t) * a + f t * c)\""], ["proof (prove)\nusing this:\n  \\<not> t \\<le> 1 / 2\n\ngoal (1 subgoal):\n 1. part_circlepath C r a c (f t) =\n    C + complex_of_real r * cis ((1 - f t) * a + f t * c)", "by (simp add: joinpaths_def part_circlepath_def exp_eq_polar linepath_def)"], ["proof (state)\nthis:\n  part_circlepath C r a c (f t) =\n  C + complex_of_real r * cis ((1 - f t) * a + f t * c)\n\ngoal (1 subgoal):\n 1. \\<not> t \\<le> 1 / 2 \\<Longrightarrow>\n    (part_circlepath C r a b +++ part_circlepath C r b c) t =\n    part_circlepath C r a c (f t)", "also"], ["proof (state)\nthis:\n  part_circlepath C r a c (f t) =\n  C + complex_of_real r * cis ((1 - f t) * a + f t * c)\n\ngoal (1 subgoal):\n 1. \\<not> t \\<le> 1 / 2 \\<Longrightarrow>\n    (part_circlepath C r a b +++ part_circlepath C r b c) t =\n    part_circlepath C r a c (f t)", "from False \\<open>a < c\\<close>"], ["proof (chain)\npicking this:\n  \\<not> t \\<le> 1 / 2\n  a < c", "have \"(1 - f t) * a + f t * c = (2 - 2 * t) * b + (2 * t - 1) * c\""], ["proof (prove)\nusing this:\n  \\<not> t \\<le> 1 / 2\n  a < c\n\ngoal (1 subgoal):\n 1. (1 - f t) * a + f t * c = (2 - 2 * t) * b + (2 * t - 1) * c", "unfolding f_def slope_def linepath_def joinpaths_def"], ["proof (prove)\nusing this:\n  \\<not> t \\<le> 1 / 2\n  a < c\n\ngoal (1 subgoal):\n 1. (1 -\n     (if t \\<le> 1 / 2\n      then (1 - 2 * t) *\\<^sub>R 0 + (2 * t) *\\<^sub>R ((b - a) / (c - a))\n      else (1 - (2 * t - 1)) *\\<^sub>R ((b - a) / (c - a)) +\n           (2 * t - 1) *\\<^sub>R 1)) *\n    a +\n    (if t \\<le> 1 / 2\n     then (1 - 2 * t) *\\<^sub>R 0 + (2 * t) *\\<^sub>R ((b - a) / (c - a))\n     else (1 - (2 * t - 1)) *\\<^sub>R ((b - a) / (c - a)) +\n          (2 * t - 1) *\\<^sub>R 1) *\n    c =\n    (2 - 2 * t) * b + (2 * t - 1) * c", "by (simp add: divide_simps del: div_mult_self3 div_mult_self4 div_mult_self2 div_mult_self1)\n           (simp add: algebra_simps)?"], ["proof (state)\nthis:\n  (1 - f t) * a + f t * c = (2 - 2 * t) * b + (2 * t - 1) * c\n\ngoal (1 subgoal):\n 1. \\<not> t \\<le> 1 / 2 \\<Longrightarrow>\n    (part_circlepath C r a b +++ part_circlepath C r b c) t =\n    part_circlepath C r a c (f t)", "also"], ["proof (state)\nthis:\n  (1 - f t) * a + f t * c = (2 - 2 * t) * b + (2 * t - 1) * c\n\ngoal (1 subgoal):\n 1. \\<not> t \\<le> 1 / 2 \\<Longrightarrow>\n    (part_circlepath C r a b +++ part_circlepath C r b c) t =\n    part_circlepath C r a c (f t)", "from False"], ["proof (chain)\npicking this:\n  \\<not> t \\<le> 1 / 2", "have \"C + r * cis \\<dots> = (?h1 +++ ?h2) t\""], ["proof (prove)\nusing this:\n  \\<not> t \\<le> 1 / 2\n\ngoal (1 subgoal):\n 1. C + complex_of_real r * cis ((2 - 2 * t) * b + (2 * t - 1) * c) =\n    (part_circlepath C r a b +++ part_circlepath C r b c) t", "by (simp add: joinpaths_def part_circlepath_def exp_eq_polar linepath_def)"], ["proof (state)\nthis:\n  C + complex_of_real r * cis ((2 - 2 * t) * b + (2 * t - 1) * c) =\n  (part_circlepath C r a b +++ part_circlepath C r b c) t\n\ngoal (1 subgoal):\n 1. \\<not> t \\<le> 1 / 2 \\<Longrightarrow>\n    (part_circlepath C r a b +++ part_circlepath C r b c) t =\n    part_circlepath C r a c (f t)", "finally"], ["proof (chain)\npicking this:\n  part_circlepath C r a c (f t) =\n  (part_circlepath C r a b +++ part_circlepath C r b c) t", "show ?thesis"], ["proof (prove)\nusing this:\n  part_circlepath C r a c (f t) =\n  (part_circlepath C r a b +++ part_circlepath C r b c) t\n\ngoal (1 subgoal):\n 1. (part_circlepath C r a b +++ part_circlepath C r b c) t =\n    part_circlepath C r a c (f t)", ".."], ["proof (state)\nthis:\n  (part_circlepath C r a b +++ part_circlepath C r b c) t =\n  part_circlepath C r a c (f t)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (part_circlepath C r a b +++ part_circlepath C r b c) t =\n  part_circlepath C r a c (f t)\n\ngoal (6 subgoals):\n 1. path (part_circlepath C r a c)\n 2. path_image (part_circlepath C r a c) \\<subseteq> A\n 3. continuous_on {0..1} f\n 4. f ` {0..1} \\<subseteq> {0..1}\n 5. f 0 = 0\n 6. f 1 = 1", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. path (part_circlepath C r a c)\n 2. path_image (part_circlepath C r a c) \\<subseteq> A\n 3. continuous_on {0..1} f\n 4. f ` {0..1} \\<subseteq> {0..1}\n 5. f 0 = 0\n 6. f 1 = 1", "from slope"], ["proof (chain)\npicking this:\n  slope \\<in> {0..1}", "have \"path_image f \\<subseteq> {0..1}\""], ["proof (prove)\nusing this:\n  slope \\<in> {0..1}\n\ngoal (1 subgoal):\n 1. path_image f \\<subseteq> {0..1}", "by (auto simp: f_def path_image_join closed_segment_eq_real_ivl)"], ["proof (state)\nthis:\n  path_image f \\<subseteq> {0..1}\n\ngoal (6 subgoals):\n 1. path (part_circlepath C r a c)\n 2. path_image (part_circlepath C r a c) \\<subseteq> A\n 3. continuous_on {0..1} f\n 4. f ` {0..1} \\<subseteq> {0..1}\n 5. f 0 = 0\n 6. f 1 = 1", "thus \"f ` {0..1} \\<subseteq> {0..1}\""], ["proof (prove)\nusing this:\n  path_image f \\<subseteq> {0..1}\n\ngoal (1 subgoal):\n 1. f ` {0..1} \\<subseteq> {0..1}", "by (simp add: path_image_def)"], ["proof (state)\nthis:\n  f ` {0..1} \\<subseteq> {0..1}\n\ngoal (5 subgoals):\n 1. path (part_circlepath C r a c)\n 2. path_image (part_circlepath C r a c) \\<subseteq> A\n 3. continuous_on {0..1} f\n 4. f 0 = 0\n 5. f 1 = 1", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. path (part_circlepath C r a c)\n 2. path_image (part_circlepath C r a c) \\<subseteq> A\n 3. continuous_on {0..1} f\n 4. f 0 = 0\n 5. f 1 = 1", "have \"path f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path f", "unfolding f_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. path (linepath 0 slope +++ linepath slope 1)", "by auto"], ["proof (state)\nthis:\n  path f\n\ngoal (5 subgoals):\n 1. path (part_circlepath C r a c)\n 2. path_image (part_circlepath C r a c) \\<subseteq> A\n 3. continuous_on {0..1} f\n 4. f 0 = 0\n 5. f 1 = 1", "thus \"continuous_on {0..1} f\""], ["proof (prove)\nusing this:\n  path f\n\ngoal (1 subgoal):\n 1. continuous_on {0..1} f", "by (simp add: path_def)"], ["proof (state)\nthis:\n  continuous_on {0..1} f\n\ngoal (4 subgoals):\n 1. path (part_circlepath C r a c)\n 2. path_image (part_circlepath C r a c) \\<subseteq> A\n 3. f 0 = 0\n 4. f 1 = 1", "qed (insert assms, auto simp: f_def joinpaths_def linepath_def)"], ["proof (state)\nthis:\n  homotopic_paths A (part_circlepath C r a c)\n   (part_circlepath C r a b +++ part_circlepath C r b c)\n\ngoal (1 subgoal):\n 1. a = c \\<Longrightarrow>\n    homotopic_paths A (part_circlepath C r a c)\n     (part_circlepath C r a b +++ part_circlepath C r b c)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. a = c \\<Longrightarrow>\n    homotopic_paths A (part_circlepath C r a c)\n     (part_circlepath C r a b +++ part_circlepath C r b c)", "case [simp]: True"], ["proof (state)\nthis:\n  a = c\n\ngoal (1 subgoal):\n 1. a = c \\<Longrightarrow>\n    homotopic_paths A (part_circlepath C r a c)\n     (part_circlepath C r a b +++ part_circlepath C r b c)", "with assms"], ["proof (chain)\npicking this:\n  a \\<le> b\n  b \\<le> c\n  path_image (part_circlepath C r a c) \\<subseteq> A\n  0 \\<le> r\n  a = c", "have [simp]: \"b = c\""], ["proof (prove)\nusing this:\n  a \\<le> b\n  b \\<le> c\n  path_image (part_circlepath C r a c) \\<subseteq> A\n  0 \\<le> r\n  a = c\n\ngoal (1 subgoal):\n 1. b = c", "by auto"], ["proof (state)\nthis:\n  b = c\n\ngoal (1 subgoal):\n 1. a = c \\<Longrightarrow>\n    homotopic_paths A (part_circlepath C r a c)\n     (part_circlepath C r a b +++ part_circlepath C r b c)", "have \"part_circlepath C r c c +++ part_circlepath C r c c = part_circlepath C r c c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. part_circlepath C r c c +++ part_circlepath C r c c =\n    part_circlepath C r c c", "by (simp add: fun_eq_iff joinpaths_def part_circlepath_def)"], ["proof (state)\nthis:\n  part_circlepath C r c c +++ part_circlepath C r c c =\n  part_circlepath C r c c\n\ngoal (1 subgoal):\n 1. a = c \\<Longrightarrow>\n    homotopic_paths A (part_circlepath C r a c)\n     (part_circlepath C r a b +++ part_circlepath C r b c)", "thus ?thesis"], ["proof (prove)\nusing this:\n  part_circlepath C r c c +++ part_circlepath C r c c =\n  part_circlepath C r c c\n\ngoal (1 subgoal):\n 1. homotopic_paths A (part_circlepath C r a c)\n     (part_circlepath C r a b +++ part_circlepath C r b c)", "using assms"], ["proof (prove)\nusing this:\n  part_circlepath C r c c +++ part_circlepath C r c c =\n  part_circlepath C r c c\n  a \\<le> b\n  b \\<le> c\n  path_image (part_circlepath C r a c) \\<subseteq> A\n  0 \\<le> r\n\ngoal (1 subgoal):\n 1. homotopic_paths A (part_circlepath C r a c)\n     (part_circlepath C r a b +++ part_circlepath C r b c)", "by simp"], ["proof (state)\nthis:\n  homotopic_paths A (part_circlepath C r a c)\n   (part_circlepath C r a b +++ part_circlepath C r b c)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma has_contour_integral_mirror_iff:\n  assumes \"valid_path g\"\n  shows   \"(f has_contour_integral I) (-g) \\<longleftrightarrow> ((\\<lambda>x. -f (- x)) has_contour_integral I) g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f has_contour_integral I) (- g) =\n    ((\\<lambda>x. - f (- x)) has_contour_integral I) g", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (f has_contour_integral I) (- g) =\n    ((\\<lambda>x. - f (- x)) has_contour_integral I) g", "from assms"], ["proof (chain)\npicking this:\n  valid_path g", "have \"g piecewise_differentiable_on {0..1}\""], ["proof (prove)\nusing this:\n  valid_path g\n\ngoal (1 subgoal):\n 1. g piecewise_differentiable_on {0..1}", "by (auto simp: valid_path_def piecewise_C1_imp_differentiable)"], ["proof (state)\nthis:\n  g piecewise_differentiable_on {0..1}\n\ngoal (1 subgoal):\n 1. (f has_contour_integral I) (- g) =\n    ((\\<lambda>x. - f (- x)) has_contour_integral I) g", "then"], ["proof (chain)\npicking this:\n  g piecewise_differentiable_on {0..1}", "obtain S where S: \"finite S\" \"\\<And>x. x \\<in> {0..1} - S \\<Longrightarrow> g differentiable at x within {0..1}\""], ["proof (prove)\nusing this:\n  g piecewise_differentiable_on {0..1}\n\ngoal (1 subgoal):\n 1. (\\<And>S.\n        \\<lbrakk>finite S;\n         \\<And>x.\n            x \\<in> {0..1} - S \\<Longrightarrow>\n            g differentiable at x within {0..1}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding piecewise_differentiable_on_def"], ["proof (prove)\nusing this:\n  continuous_on {0..1} g \\<and>\n  (\\<exists>S.\n      finite S \\<and>\n      (\\<forall>x\\<in>{0..1} - S. g differentiable at x within {0..1}))\n\ngoal (1 subgoal):\n 1. (\\<And>S.\n        \\<lbrakk>finite S;\n         \\<And>x.\n            x \\<in> {0..1} - S \\<Longrightarrow>\n            g differentiable at x within {0..1}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  finite S\n  ?x \\<in> {0..1} - S \\<Longrightarrow> g differentiable at ?x within {0..1}\n\ngoal (1 subgoal):\n 1. (f has_contour_integral I) (- g) =\n    ((\\<lambda>x. - f (- x)) has_contour_integral I) g", "have S': \"g differentiable at x\" if \"x \\<in> {0..1} - ({0, 1} \\<union> S)\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. g differentiable at x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. g differentiable at x", "from that"], ["proof (chain)\npicking this:\n  x \\<in> {0..1} - ({0, 1} \\<union> S)", "have \"x \\<in> interior {0..1}\""], ["proof (prove)\nusing this:\n  x \\<in> {0..1} - ({0, 1} \\<union> S)\n\ngoal (1 subgoal):\n 1. x \\<in> interior {0..1}", "by auto"], ["proof (state)\nthis:\n  x \\<in> interior {0..1}\n\ngoal (1 subgoal):\n 1. g differentiable at x", "with S(2)[of x] that"], ["proof (chain)\npicking this:\n  x \\<in> {0..1} - S \\<Longrightarrow> g differentiable at x within {0..1}\n  x \\<in> {0..1} - ({0, 1} \\<union> S)\n  x \\<in> interior {0..1}", "show ?thesis"], ["proof (prove)\nusing this:\n  x \\<in> {0..1} - S \\<Longrightarrow> g differentiable at x within {0..1}\n  x \\<in> {0..1} - ({0, 1} \\<union> S)\n  x \\<in> interior {0..1}\n\ngoal (1 subgoal):\n 1. g differentiable at x", "by (auto simp: at_within_interior[of _ \"{0..1}\"])"], ["proof (state)\nthis:\n  g differentiable at x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?x \\<in> {0..1} - ({0, 1} \\<union> S) \\<Longrightarrow>\n  g differentiable at ?x\n\ngoal (1 subgoal):\n 1. (f has_contour_integral I) (- g) =\n    ((\\<lambda>x. - f (- x)) has_contour_integral I) g", "have \"(f has_contour_integral I) (-g) \\<longleftrightarrow>\n          ((\\<lambda>x. f (- g x) * vector_derivative (-g) (at x)) has_integral I) {0..1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f has_contour_integral I) (- g) =\n    ((\\<lambda>x. f (- g x) * vector_derivative (- g) (at x)) has_integral\n     I)\n     {0..1}", "by (simp add: has_contour_integral)"], ["proof (state)\nthis:\n  (f has_contour_integral I) (- g) =\n  ((\\<lambda>x. f (- g x) * vector_derivative (- g) (at x)) has_integral I)\n   {0..1}\n\ngoal (1 subgoal):\n 1. (f has_contour_integral I) (- g) =\n    ((\\<lambda>x. - f (- x)) has_contour_integral I) g", "also"], ["proof (state)\nthis:\n  (f has_contour_integral I) (- g) =\n  ((\\<lambda>x. f (- g x) * vector_derivative (- g) (at x)) has_integral I)\n   {0..1}\n\ngoal (1 subgoal):\n 1. (f has_contour_integral I) (- g) =\n    ((\\<lambda>x. - f (- x)) has_contour_integral I) g", "have \"\\<dots> \\<longleftrightarrow> ((\\<lambda>x. -f (- g x) * vector_derivative g (at x)) has_integral I) {0..1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x. f (- g x) * vector_derivative (- g) (at x)) has_integral\n     I)\n     {0..1} =\n    ((\\<lambda>x. - f (- g x) * vector_derivative g (at x)) has_integral I)\n     {0..1}", "by (intro has_integral_spike_finite_eq[of \"S \\<union> {0, 1}\"])\n       (insert \\<open>finite S\\<close> S', auto simp: o_def fun_Compl_def)"], ["proof (state)\nthis:\n  ((\\<lambda>x. f (- g x) * vector_derivative (- g) (at x)) has_integral I)\n   {0..1} =\n  ((\\<lambda>x. - f (- g x) * vector_derivative g (at x)) has_integral I)\n   {0..1}\n\ngoal (1 subgoal):\n 1. (f has_contour_integral I) (- g) =\n    ((\\<lambda>x. - f (- x)) has_contour_integral I) g", "also"], ["proof (state)\nthis:\n  ((\\<lambda>x. f (- g x) * vector_derivative (- g) (at x)) has_integral I)\n   {0..1} =\n  ((\\<lambda>x. - f (- g x) * vector_derivative g (at x)) has_integral I)\n   {0..1}\n\ngoal (1 subgoal):\n 1. (f has_contour_integral I) (- g) =\n    ((\\<lambda>x. - f (- x)) has_contour_integral I) g", "have \"\\<dots> \\<longleftrightarrow> ((\\<lambda>x. -f (-x)) has_contour_integral I) g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x. - f (- g x) * vector_derivative g (at x)) has_integral I)\n     {0..1} =\n    ((\\<lambda>x. - f (- x)) has_contour_integral I) g", "by (simp add: has_contour_integral)"], ["proof (state)\nthis:\n  ((\\<lambda>x. - f (- g x) * vector_derivative g (at x)) has_integral I)\n   {0..1} =\n  ((\\<lambda>x. - f (- x)) has_contour_integral I) g\n\ngoal (1 subgoal):\n 1. (f has_contour_integral I) (- g) =\n    ((\\<lambda>x. - f (- x)) has_contour_integral I) g", "finally"], ["proof (chain)\npicking this:\n  (f has_contour_integral I) (- g) =\n  ((\\<lambda>x. - f (- x)) has_contour_integral I) g", "show ?thesis"], ["proof (prove)\nusing this:\n  (f has_contour_integral I) (- g) =\n  ((\\<lambda>x. - f (- x)) has_contour_integral I) g\n\ngoal (1 subgoal):\n 1. (f has_contour_integral I) (- g) =\n    ((\\<lambda>x. - f (- x)) has_contour_integral I) g", "."], ["proof (state)\nthis:\n  (f has_contour_integral I) (- g) =\n  ((\\<lambda>x. - f (- x)) has_contour_integral I) g\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma contour_integral_on_mirror_iff:\n  assumes \"valid_path g\"\n  shows   \"f contour_integrable_on (-g) \\<longleftrightarrow> (\\<lambda>x. -f (- x)) contour_integrable_on g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f contour_integrable_on - g) =\n    ((\\<lambda>x. - f (- x)) contour_integrable_on g)", "by (auto simp: contour_integrable_on_def has_contour_integral_mirror_iff assms)"], ["", "lemma contour_integral_mirror:\n  assumes \"valid_path g\"\n  shows   \"contour_integral (-g) f = contour_integral g (\\<lambda>x. -f (- x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. contour_integral (- g) f = contour_integral g (\\<lambda>x. - f (- x))", "proof (cases \"f contour_integrable_on (-g)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. f contour_integrable_on - g \\<Longrightarrow>\n    contour_integral (- g) f = contour_integral g (\\<lambda>x. - f (- x))\n 2. \\<not> f contour_integrable_on - g \\<Longrightarrow>\n    contour_integral (- g) f = contour_integral g (\\<lambda>x. - f (- x))", "case True"], ["proof (state)\nthis:\n  f contour_integrable_on - g\n\ngoal (2 subgoals):\n 1. f contour_integrable_on - g \\<Longrightarrow>\n    contour_integral (- g) f = contour_integral g (\\<lambda>x. - f (- x))\n 2. \\<not> f contour_integrable_on - g \\<Longrightarrow>\n    contour_integral (- g) f = contour_integral g (\\<lambda>x. - f (- x))", "then"], ["proof (chain)\npicking this:\n  f contour_integrable_on - g", "obtain I where I: \"(f has_contour_integral I) (-g)\""], ["proof (prove)\nusing this:\n  f contour_integrable_on - g\n\ngoal (1 subgoal):\n 1. (\\<And>I.\n        (f has_contour_integral I) (- g) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: contour_integrable_on_def)"], ["proof (state)\nthis:\n  (f has_contour_integral I) (- g)\n\ngoal (2 subgoals):\n 1. f contour_integrable_on - g \\<Longrightarrow>\n    contour_integral (- g) f = contour_integral g (\\<lambda>x. - f (- x))\n 2. \\<not> f contour_integrable_on - g \\<Longrightarrow>\n    contour_integral (- g) f = contour_integral g (\\<lambda>x. - f (- x))", "also"], ["proof (state)\nthis:\n  (f has_contour_integral I) (- g)\n\ngoal (2 subgoals):\n 1. f contour_integrable_on - g \\<Longrightarrow>\n    contour_integral (- g) f = contour_integral g (\\<lambda>x. - f (- x))\n 2. \\<not> f contour_integrable_on - g \\<Longrightarrow>\n    contour_integral (- g) f = contour_integral g (\\<lambda>x. - f (- x))", "note has_contour_integral_mirror_iff[OF assms]"], ["proof (state)\nthis:\n  (?f has_contour_integral ?I) (- g) =\n  ((\\<lambda>x. - ?f (- x)) has_contour_integral ?I) g\n\ngoal (2 subgoals):\n 1. f contour_integrable_on - g \\<Longrightarrow>\n    contour_integral (- g) f = contour_integral g (\\<lambda>x. - f (- x))\n 2. \\<not> f contour_integrable_on - g \\<Longrightarrow>\n    contour_integral (- g) f = contour_integral g (\\<lambda>x. - f (- x))", "finally"], ["proof (chain)\npicking this:\n  ((\\<lambda>x. - f (- x)) has_contour_integral I) g", "have \"((\\<lambda>x. - f (- x)) has_contour_integral I) g\""], ["proof (prove)\nusing this:\n  ((\\<lambda>x. - f (- x)) has_contour_integral I) g\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. - f (- x)) has_contour_integral I) g", "."], ["proof (state)\nthis:\n  ((\\<lambda>x. - f (- x)) has_contour_integral I) g\n\ngoal (2 subgoals):\n 1. f contour_integrable_on - g \\<Longrightarrow>\n    contour_integral (- g) f = contour_integral g (\\<lambda>x. - f (- x))\n 2. \\<not> f contour_integrable_on - g \\<Longrightarrow>\n    contour_integral (- g) f = contour_integral g (\\<lambda>x. - f (- x))", "with I"], ["proof (chain)\npicking this:\n  (f has_contour_integral I) (- g)\n  ((\\<lambda>x. - f (- x)) has_contour_integral I) g", "show ?thesis"], ["proof (prove)\nusing this:\n  (f has_contour_integral I) (- g)\n  ((\\<lambda>x. - f (- x)) has_contour_integral I) g\n\ngoal (1 subgoal):\n 1. contour_integral (- g) f = contour_integral g (\\<lambda>x. - f (- x))", "using contour_integral_unique"], ["proof (prove)\nusing this:\n  (f has_contour_integral I) (- g)\n  ((\\<lambda>x. - f (- x)) has_contour_integral I) g\n  (?f has_contour_integral ?i) ?g \\<Longrightarrow>\n  contour_integral ?g ?f = ?i\n\ngoal (1 subgoal):\n 1. contour_integral (- g) f = contour_integral g (\\<lambda>x. - f (- x))", "by blast"], ["proof (state)\nthis:\n  contour_integral (- g) f = contour_integral g (\\<lambda>x. - f (- x))\n\ngoal (1 subgoal):\n 1. \\<not> f contour_integrable_on - g \\<Longrightarrow>\n    contour_integral (- g) f = contour_integral g (\\<lambda>x. - f (- x))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> f contour_integrable_on - g \\<Longrightarrow>\n    contour_integral (- g) f = contour_integral g (\\<lambda>x. - f (- x))", "case False"], ["proof (state)\nthis:\n  \\<not> f contour_integrable_on - g\n\ngoal (1 subgoal):\n 1. \\<not> f contour_integrable_on - g \\<Longrightarrow>\n    contour_integral (- g) f = contour_integral g (\\<lambda>x. - f (- x))", "hence \"\\<not>(\\<lambda>x. -f (-x)) contour_integrable_on g\""], ["proof (prove)\nusing this:\n  \\<not> f contour_integrable_on - g\n\ngoal (1 subgoal):\n 1. \\<not> (\\<lambda>x. - f (- x)) contour_integrable_on g", "by (auto simp: contour_integral_on_mirror_iff assms)"], ["proof (state)\nthis:\n  \\<not> (\\<lambda>x. - f (- x)) contour_integrable_on g\n\ngoal (1 subgoal):\n 1. \\<not> f contour_integrable_on - g \\<Longrightarrow>\n    contour_integral (- g) f = contour_integral g (\\<lambda>x. - f (- x))", "from False and this"], ["proof (chain)\npicking this:\n  \\<not> f contour_integrable_on - g\n  \\<not> (\\<lambda>x. - f (- x)) contour_integrable_on g", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> f contour_integrable_on - g\n  \\<not> (\\<lambda>x. - f (- x)) contour_integrable_on g\n\ngoal (1 subgoal):\n 1. contour_integral (- g) f = contour_integral g (\\<lambda>x. - f (- x))", "by (simp add: not_integrable_contour_integral)"], ["proof (state)\nthis:\n  contour_integral (- g) f = contour_integral g (\\<lambda>x. - f (- x))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma contour_integrable_neg_iff:\n  \"(\\<lambda>x. -f x) contour_integrable_on g \\<longleftrightarrow> f contour_integrable_on g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x. - f x) contour_integrable_on g) =\n    (f contour_integrable_on g)", "using contour_integrable_neg[of f g] contour_integrable_neg[of \"\\<lambda>x. -f x\" g]"], ["proof (prove)\nusing this:\n  f contour_integrable_on g \\<Longrightarrow>\n  (\\<lambda>x. - f x) contour_integrable_on g\n  (\\<lambda>x. - f x) contour_integrable_on g \\<Longrightarrow>\n  (\\<lambda>x. - (- f x)) contour_integrable_on g\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. - f x) contour_integrable_on g) =\n    (f contour_integrable_on g)", "by auto"], ["", "lemma contour_integral_neg:\n  shows \"contour_integral g (\\<lambda>x. -f x) = -contour_integral g f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. contour_integral g (\\<lambda>x. - f x) = - contour_integral g f", "proof (cases \"f contour_integrable_on g\")"], ["proof (state)\ngoal (2 subgoals):\n 1. f contour_integrable_on g \\<Longrightarrow>\n    contour_integral g (\\<lambda>x. - f x) = - contour_integral g f\n 2. \\<not> f contour_integrable_on g \\<Longrightarrow>\n    contour_integral g (\\<lambda>x. - f x) = - contour_integral g f", "case True"], ["proof (state)\nthis:\n  f contour_integrable_on g\n\ngoal (2 subgoals):\n 1. f contour_integrable_on g \\<Longrightarrow>\n    contour_integral g (\\<lambda>x. - f x) = - contour_integral g f\n 2. \\<not> f contour_integrable_on g \\<Longrightarrow>\n    contour_integral g (\\<lambda>x. - f x) = - contour_integral g f", "thus ?thesis"], ["proof (prove)\nusing this:\n  f contour_integrable_on g\n\ngoal (1 subgoal):\n 1. contour_integral g (\\<lambda>x. - f x) = - contour_integral g f", "by (simp add: contour_integral_neg)"], ["proof (state)\nthis:\n  contour_integral g (\\<lambda>x. - f x) = - contour_integral g f\n\ngoal (1 subgoal):\n 1. \\<not> f contour_integrable_on g \\<Longrightarrow>\n    contour_integral g (\\<lambda>x. - f x) = - contour_integral g f", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> f contour_integrable_on g \\<Longrightarrow>\n    contour_integral g (\\<lambda>x. - f x) = - contour_integral g f", "case False"], ["proof (state)\nthis:\n  \\<not> f contour_integrable_on g\n\ngoal (1 subgoal):\n 1. \\<not> f contour_integrable_on g \\<Longrightarrow>\n    contour_integral g (\\<lambda>x. - f x) = - contour_integral g f", "hence \"\\<not>(\\<lambda>x. -f x) contour_integrable_on g\""], ["proof (prove)\nusing this:\n  \\<not> f contour_integrable_on g\n\ngoal (1 subgoal):\n 1. \\<not> (\\<lambda>x. - f x) contour_integrable_on g", "by (simp add: contour_integrable_neg_iff)"], ["proof (state)\nthis:\n  \\<not> (\\<lambda>x. - f x) contour_integrable_on g\n\ngoal (1 subgoal):\n 1. \\<not> f contour_integrable_on g \\<Longrightarrow>\n    contour_integral g (\\<lambda>x. - f x) = - contour_integral g f", "with False"], ["proof (chain)\npicking this:\n  \\<not> f contour_integrable_on g\n  \\<not> (\\<lambda>x. - f x) contour_integrable_on g", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> f contour_integrable_on g\n  \\<not> (\\<lambda>x. - f x) contour_integrable_on g\n\ngoal (1 subgoal):\n 1. contour_integral g (\\<lambda>x. - f x) = - contour_integral g f", "by (simp add: not_integrable_contour_integral)"], ["proof (state)\nthis:\n  contour_integral g (\\<lambda>x. - f x) = - contour_integral g f\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma minus_cis: \"-cis x = cis (x + pi)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - cis x = cis (x + pi)", "by (simp add: complex_eq_iff)"], ["", "lemma path_image_part_circlepath_subset:\n  assumes \"a \\<le> a'\" \"a' \\<le> b'\" \"b' \\<le> b\"\n  shows   \"path_image (part_circlepath c r a' b') \\<subseteq> path_image (part_circlepath c r a b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path_image (part_circlepath c r a' b')\n    \\<subseteq> path_image (part_circlepath c r a b)", "using assms"], ["proof (prove)\nusing this:\n  a \\<le> a'\n  a' \\<le> b'\n  b' \\<le> b\n\ngoal (1 subgoal):\n 1. path_image (part_circlepath c r a' b')\n    \\<subseteq> path_image (part_circlepath c r a b)", "by (subst (1 2) path_image_part_circlepath) auto"], ["", "lemma part_circlepath_mirror:\n  assumes \"a' = a + pi + 2 * pi * of_int k\" \"b' = b + pi + 2 * pi * of_int k\" \"c' = -c\"\n  shows   \"-part_circlepath c r a b = part_circlepath c' r a' b'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - part_circlepath c r a b = part_circlepath c' r a' b'", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. (- part_circlepath c r a b) x = part_circlepath c' r a' b' x", "fix x :: real"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. (- part_circlepath c r a b) x = part_circlepath c' r a' b' x", "have \"part_circlepath c' r a' b' x = c' + r * cis (linepath a b x + pi + k * (2 * pi))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. part_circlepath c' r a' b' x =\n    c' +\n    complex_of_real r * cis (linepath a b x + pi + real_of_int k * (2 * pi))", "by (simp add: part_circlepath_def exp_eq_polar assms linepath_translate_right mult_ac)"], ["proof (state)\nthis:\n  part_circlepath c' r a' b' x =\n  c' +\n  complex_of_real r * cis (linepath a b x + pi + real_of_int k * (2 * pi))\n\ngoal (1 subgoal):\n 1. \\<And>x. (- part_circlepath c r a b) x = part_circlepath c' r a' b' x", "also"], ["proof (state)\nthis:\n  part_circlepath c' r a' b' x =\n  c' +\n  complex_of_real r * cis (linepath a b x + pi + real_of_int k * (2 * pi))\n\ngoal (1 subgoal):\n 1. \\<And>x. (- part_circlepath c r a b) x = part_circlepath c' r a' b' x", "have \"cis (linepath a b x + pi + k * (2 * pi)) = cis (linepath a b x + pi)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cis (linepath a b x + pi + real_of_int k * (2 * pi)) =\n    cis (linepath a b x + pi)", "by (rule cis.plus_of_int)"], ["proof (state)\nthis:\n  cis (linepath a b x + pi + real_of_int k * (2 * pi)) =\n  cis (linepath a b x + pi)\n\ngoal (1 subgoal):\n 1. \\<And>x. (- part_circlepath c r a b) x = part_circlepath c' r a' b' x", "also"], ["proof (state)\nthis:\n  cis (linepath a b x + pi + real_of_int k * (2 * pi)) =\n  cis (linepath a b x + pi)\n\ngoal (1 subgoal):\n 1. \\<And>x. (- part_circlepath c r a b) x = part_circlepath c' r a' b' x", "have \"\\<dots> = -cis (linepath a b x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cis (linepath a b x + pi) = - cis (linepath a b x)", "by (simp add: minus_cis)"], ["proof (state)\nthis:\n  cis (linepath a b x + pi) = - cis (linepath a b x)\n\ngoal (1 subgoal):\n 1. \\<And>x. (- part_circlepath c r a b) x = part_circlepath c' r a' b' x", "also"], ["proof (state)\nthis:\n  cis (linepath a b x + pi) = - cis (linepath a b x)\n\ngoal (1 subgoal):\n 1. \\<And>x. (- part_circlepath c r a b) x = part_circlepath c' r a' b' x", "have \"c' + r * \\<dots> = -part_circlepath c r a b x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c' + complex_of_real r * - cis (linepath a b x) =\n    - part_circlepath c r a b x", "by (simp add: part_circlepath_def assms exp_eq_polar)"], ["proof (state)\nthis:\n  c' + complex_of_real r * - cis (linepath a b x) =\n  - part_circlepath c r a b x\n\ngoal (1 subgoal):\n 1. \\<And>x. (- part_circlepath c r a b) x = part_circlepath c' r a' b' x", "finally"], ["proof (chain)\npicking this:\n  part_circlepath c' r a' b' x = - part_circlepath c r a b x", "show \"(- part_circlepath c r a b) x = part_circlepath c' r a' b' x\""], ["proof (prove)\nusing this:\n  part_circlepath c' r a' b' x = - part_circlepath c r a b x\n\ngoal (1 subgoal):\n 1. (- part_circlepath c r a b) x = part_circlepath c' r a' b' x", "by simp"], ["proof (state)\nthis:\n  (- part_circlepath c r a b) x = part_circlepath c' r a' b' x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma path_mirror [intro]: \"path (g :: _ \\<Rightarrow> 'b::topological_group_add) \\<Longrightarrow> path (-g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path g \\<Longrightarrow> path (- g)", "by (auto simp: path_def intro!: continuous_intros)"], ["", "lemma path_mirror_iff [simp]: \"path (-g :: _ \\<Rightarrow> 'b::topological_group_add) \\<longleftrightarrow> path g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path (- g) = path g", "using path_mirror[of g] path_mirror[of \"-g\"]"], ["proof (prove)\nusing this:\n  path g \\<Longrightarrow> path (- g)\n  path (- g) \\<Longrightarrow> path (- (- g))\n\ngoal (1 subgoal):\n 1. path (- g) = path g", "by (auto simp: fun_Compl_def)"], ["", "lemma valid_path_mirror [intro]: \"valid_path g \\<Longrightarrow> valid_path (-g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_path g \\<Longrightarrow> valid_path (- g)", "by (auto simp: valid_path_def fun_Compl_def piecewise_C1_differentiable_neg)"], ["", "lemma valid_path_mirror_iff [simp]: \"valid_path (-g) \\<longleftrightarrow> valid_path g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_path (- g) = valid_path g", "using valid_path_mirror[of g] valid_path_mirror[of \"-g\"]"], ["proof (prove)\nusing this:\n  valid_path g \\<Longrightarrow> valid_path (- g)\n  valid_path (- g) \\<Longrightarrow> valid_path (- (- g))\n\ngoal (1 subgoal):\n 1. valid_path (- g) = valid_path g", "by (auto simp: fun_Compl_def)"], ["", "lemma pathstart_mirror [simp]: \"pathstart (-g) = -pathstart g\"\n  and pathfinish_mirror [simp]: \"pathfinish (-g) = -pathfinish g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pathstart (- g) = - pathstart g &&& pathfinish (- g) = - pathfinish g", "by (simp_all add: pathstart_def pathfinish_def)"], ["", "lemma path_image_mirror: \"path_image (-g) = uminus ` path_image g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path_image (- g) = uminus ` path_image g", "by (auto simp: path_image_def)"], ["", "lemma contour_integral_bound_part_circlepath:\n  assumes \"f contour_integrable_on part_circlepath c r a b\"\n  assumes \"B \\<ge> 0\" \"r \\<ge> 0\" \"\\<And>x. x \\<in> path_image (part_circlepath c r a b) \\<Longrightarrow> norm (f x) \\<le> B\"\n  shows   \"norm (contour_integral (part_circlepath c r a b) f) \\<le> B * r * \\<bar>b - a\\<bar>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod (contour_integral (part_circlepath c r a b) f)\n    \\<le> B * r * \\<bar>b - a\\<bar>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cmod (contour_integral (part_circlepath c r a b) f)\n    \\<le> B * r * \\<bar>b - a\\<bar>", "let ?I = \"integral {0..1} (\\<lambda>x. f (part_circlepath c r a b x) * \\<i> * of_real (r * (b - a)) *\n              exp (\\<i> * linepath a b x))\""], ["proof (state)\ngoal (1 subgoal):\n 1. cmod (contour_integral (part_circlepath c r a b) f)\n    \\<le> B * r * \\<bar>b - a\\<bar>", "have \"norm ?I \\<le> integral {0..1} (\\<lambda>x::real. B * 1 * (r * \\<bar>b - a\\<bar>) * 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod\n     (integral {0..1}\n       (\\<lambda>x.\n           f (part_circlepath c r a b x) * \\<i> *\n           complex_of_real (r * (b - a)) *\n           exp (\\<i> * complex_of_real (linepath a b x))))\n    \\<le> integral {0..1} (\\<lambda>x. B * 1 * (r * \\<bar>b - a\\<bar>) * 1)", "proof (rule integral_norm_bound_integral, goal_cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. (\\<lambda>x.\n        f (part_circlepath c r a b x) * \\<i> *\n        complex_of_real (r * (b - a)) *\n        exp (\\<i> * complex_of_real (linepath a b x))) integrable_on\n    {0..1}\n 2. (\\<lambda>x. B * 1 * (r * \\<bar>b - a\\<bar>) * 1) integrable_on {0..1}\n 3. \\<And>x.\n       x \\<in> {0..1} \\<Longrightarrow>\n       cmod\n        (f (part_circlepath c r a b x) * \\<i> *\n         complex_of_real (r * (b - a)) *\n         exp (\\<i> * complex_of_real (linepath a b x)))\n       \\<le> B * 1 * (r * \\<bar>b - a\\<bar>) * 1", "case 1"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. (\\<lambda>x.\n        f (part_circlepath c r a b x) * \\<i> *\n        complex_of_real (r * (b - a)) *\n        exp (\\<i> * complex_of_real (linepath a b x))) integrable_on\n    {0..1}\n 2. (\\<lambda>x. B * 1 * (r * \\<bar>b - a\\<bar>) * 1) integrable_on {0..1}\n 3. \\<And>x.\n       x \\<in> {0..1} \\<Longrightarrow>\n       cmod\n        (f (part_circlepath c r a b x) * \\<i> *\n         complex_of_real (r * (b - a)) *\n         exp (\\<i> * complex_of_real (linepath a b x)))\n       \\<le> B * 1 * (r * \\<bar>b - a\\<bar>) * 1", "with assms(1)"], ["proof (chain)\npicking this:\n  f contour_integrable_on part_circlepath c r a b", "show ?case"], ["proof (prove)\nusing this:\n  f contour_integrable_on part_circlepath c r a b\n\ngoal (1 subgoal):\n 1. (\\<lambda>x.\n        f (part_circlepath c r a b x) * \\<i> *\n        complex_of_real (r * (b - a)) *\n        exp (\\<i> * complex_of_real (linepath a b x))) integrable_on\n    {0..1}", "by (simp add: contour_integrable_on vector_derivative_part_circlepath mult_ac)"], ["proof (state)\nthis:\n  (\\<lambda>x.\n      f (part_circlepath c r a b x) * \\<i> * complex_of_real (r * (b - a)) *\n      exp (\\<i> * complex_of_real (linepath a b x))) integrable_on\n  {0..1}\n\ngoal (2 subgoals):\n 1. (\\<lambda>x. B * 1 * (r * \\<bar>b - a\\<bar>) * 1) integrable_on {0..1}\n 2. \\<And>x.\n       x \\<in> {0..1} \\<Longrightarrow>\n       cmod\n        (f (part_circlepath c r a b x) * \\<i> *\n         complex_of_real (r * (b - a)) *\n         exp (\\<i> * complex_of_real (linepath a b x)))\n       \\<le> B * 1 * (r * \\<bar>b - a\\<bar>) * 1", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<lambda>x. B * 1 * (r * \\<bar>b - a\\<bar>) * 1) integrable_on {0..1}\n 2. \\<And>x.\n       x \\<in> {0..1} \\<Longrightarrow>\n       cmod\n        (f (part_circlepath c r a b x) * \\<i> *\n         complex_of_real (r * (b - a)) *\n         exp (\\<i> * complex_of_real (linepath a b x)))\n       \\<le> B * 1 * (r * \\<bar>b - a\\<bar>) * 1", "case (3 x)"], ["proof (state)\nthis:\n  x \\<in> {0..1}\n\ngoal (2 subgoals):\n 1. (\\<lambda>x. B * 1 * (r * \\<bar>b - a\\<bar>) * 1) integrable_on {0..1}\n 2. \\<And>x.\n       x \\<in> {0..1} \\<Longrightarrow>\n       cmod\n        (f (part_circlepath c r a b x) * \\<i> *\n         complex_of_real (r * (b - a)) *\n         exp (\\<i> * complex_of_real (linepath a b x)))\n       \\<le> B * 1 * (r * \\<bar>b - a\\<bar>) * 1", "with assms(2-)"], ["proof (chain)\npicking this:\n  0 \\<le> B\n  0 \\<le> r\n  ?x \\<in> path_image (part_circlepath c r a b) \\<Longrightarrow>\n  cmod (f ?x) \\<le> B\n  x \\<in> {0..1}", "show ?case"], ["proof (prove)\nusing this:\n  0 \\<le> B\n  0 \\<le> r\n  ?x \\<in> path_image (part_circlepath c r a b) \\<Longrightarrow>\n  cmod (f ?x) \\<le> B\n  x \\<in> {0..1}\n\ngoal (1 subgoal):\n 1. cmod\n     (f (part_circlepath c r a b x) * \\<i> * complex_of_real (r * (b - a)) *\n      exp (\\<i> * complex_of_real (linepath a b x)))\n    \\<le> B * 1 * (r * \\<bar>b - a\\<bar>) * 1", "unfolding norm_mult norm_of_real abs_mult"], ["proof (prove)\nusing this:\n  0 \\<le> B\n  0 \\<le> r\n  ?x \\<in> path_image (part_circlepath c r a b) \\<Longrightarrow>\n  cmod (f ?x) \\<le> B\n  x \\<in> {0..1}\n\ngoal (1 subgoal):\n 1. cmod (f (part_circlepath c r a b x)) * cmod \\<i> *\n    (\\<bar>r\\<bar> * \\<bar>b - a\\<bar>) *\n    cmod (exp (\\<i> * complex_of_real (linepath a b x)))\n    \\<le> B * 1 * (r * \\<bar>b - a\\<bar>) * 1", "by (intro mult_mono) (auto simp: path_image_def)"], ["proof (state)\nthis:\n  cmod\n   (f (part_circlepath c r a b x) * \\<i> * complex_of_real (r * (b - a)) *\n    exp (\\<i> * complex_of_real (linepath a b x)))\n  \\<le> B * 1 * (r * \\<bar>b - a\\<bar>) * 1\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. B * 1 * (r * \\<bar>b - a\\<bar>) * 1) integrable_on {0..1}", "qed auto"], ["proof (state)\nthis:\n  cmod\n   (integral {0..1}\n     (\\<lambda>x.\n         f (part_circlepath c r a b x) * \\<i> *\n         complex_of_real (r * (b - a)) *\n         exp (\\<i> * complex_of_real (linepath a b x))))\n  \\<le> integral {0..1} (\\<lambda>x. B * 1 * (r * \\<bar>b - a\\<bar>) * 1)\n\ngoal (1 subgoal):\n 1. cmod (contour_integral (part_circlepath c r a b) f)\n    \\<le> B * r * \\<bar>b - a\\<bar>", "also"], ["proof (state)\nthis:\n  cmod\n   (integral {0..1}\n     (\\<lambda>x.\n         f (part_circlepath c r a b x) * \\<i> *\n         complex_of_real (r * (b - a)) *\n         exp (\\<i> * complex_of_real (linepath a b x))))\n  \\<le> integral {0..1} (\\<lambda>x. B * 1 * (r * \\<bar>b - a\\<bar>) * 1)\n\ngoal (1 subgoal):\n 1. cmod (contour_integral (part_circlepath c r a b) f)\n    \\<le> B * r * \\<bar>b - a\\<bar>", "have \"?I = contour_integral (part_circlepath c r a b) f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. integral {0..1}\n     (\\<lambda>x.\n         f (part_circlepath c r a b x) * \\<i> *\n         complex_of_real (r * (b - a)) *\n         exp (\\<i> * complex_of_real (linepath a b x))) =\n    contour_integral (part_circlepath c r a b) f", "by (simp add: contour_integral_integral vector_derivative_part_circlepath mult_ac)"], ["proof (state)\nthis:\n  integral {0..1}\n   (\\<lambda>x.\n       f (part_circlepath c r a b x) * \\<i> *\n       complex_of_real (r * (b - a)) *\n       exp (\\<i> * complex_of_real (linepath a b x))) =\n  contour_integral (part_circlepath c r a b) f\n\ngoal (1 subgoal):\n 1. cmod (contour_integral (part_circlepath c r a b) f)\n    \\<le> B * r * \\<bar>b - a\\<bar>", "finally"], ["proof (chain)\npicking this:\n  cmod (contour_integral (part_circlepath c r a b) f)\n  \\<le> integral {0..1} (\\<lambda>x. B * 1 * (r * \\<bar>b - a\\<bar>) * 1)", "show ?thesis"], ["proof (prove)\nusing this:\n  cmod (contour_integral (part_circlepath c r a b) f)\n  \\<le> integral {0..1} (\\<lambda>x. B * 1 * (r * \\<bar>b - a\\<bar>) * 1)\n\ngoal (1 subgoal):\n 1. cmod (contour_integral (part_circlepath c r a b) f)\n    \\<le> B * r * \\<bar>b - a\\<bar>", "by simp"], ["proof (state)\nthis:\n  cmod (contour_integral (part_circlepath c r a b) f)\n  \\<le> B * r * \\<bar>b - a\\<bar>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma contour_integral_spike_finite_simple_path:\n  assumes \"finite A\" \"simple_path g\" \"g = g'\" \"\\<And>x. x \\<in> path_image g - A \\<Longrightarrow> f x = f' x\"\n  shows   \"contour_integral g f = contour_integral g' f'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. contour_integral g f = contour_integral g' f'", "unfolding contour_integral_integral"], ["proof (prove)\ngoal (1 subgoal):\n 1. integral {0..1} (\\<lambda>x. f (g x) * vector_derivative g (at x)) =\n    integral {0..1} (\\<lambda>x. f' (g' x) * vector_derivative g' (at x))", "proof (rule integral_spike)"], ["proof (state)\ngoal (2 subgoals):\n 1. negligible ?S\n 2. \\<And>x.\n       x \\<in> {0..1} - ?S \\<Longrightarrow>\n       f' (g' x) * vector_derivative g' (at x) =\n       f (g x) * vector_derivative g (at x)", "have \"finite (g -` A \\<inter> {0<..<1})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (g -` A \\<inter> {0<..<1})", "using \\<open>simple_path g\\<close> \\<open>finite A\\<close>"], ["proof (prove)\nusing this:\n  simple_path g\n  finite A\n\ngoal (1 subgoal):\n 1. finite (g -` A \\<inter> {0<..<1})", "by (intro finite_vimage_IntI simple_path_inj_on) auto"], ["proof (state)\nthis:\n  finite (g -` A \\<inter> {0<..<1})\n\ngoal (2 subgoals):\n 1. negligible ?S\n 2. \\<And>x.\n       x \\<in> {0..1} - ?S \\<Longrightarrow>\n       f' (g' x) * vector_derivative g' (at x) =\n       f (g x) * vector_derivative g (at x)", "hence \"finite ({0, 1} \\<union> g -` A \\<inter> {0<..<1})\""], ["proof (prove)\nusing this:\n  finite (g -` A \\<inter> {0<..<1})\n\ngoal (1 subgoal):\n 1. finite ({0, 1} \\<union> g -` A \\<inter> {0<..<1})", "by auto"], ["proof (state)\nthis:\n  finite ({0, 1} \\<union> g -` A \\<inter> {0<..<1})\n\ngoal (2 subgoals):\n 1. negligible ?S\n 2. \\<And>x.\n       x \\<in> {0..1} - ?S \\<Longrightarrow>\n       f' (g' x) * vector_derivative g' (at x) =\n       f (g x) * vector_derivative g (at x)", "thus \"negligible ({0, 1} \\<union> g -` A \\<inter> {0<..<1})\""], ["proof (prove)\nusing this:\n  finite ({0, 1} \\<union> g -` A \\<inter> {0<..<1})\n\ngoal (1 subgoal):\n 1. negligible ({0, 1} \\<union> g -` A \\<inter> {0<..<1})", "by (rule negligible_finite)"], ["proof (state)\nthis:\n  negligible ({0, 1} \\<union> g -` A \\<inter> {0<..<1})\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0..1} -\n               ({0, 1} \\<union> g -` A \\<inter> {0<..<1}) \\<Longrightarrow>\n       f' (g' x) * vector_derivative g' (at x) =\n       f (g x) * vector_derivative g (at x)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0..1} -\n               ({0, 1} \\<union> g -` A \\<inter> {0<..<1}) \\<Longrightarrow>\n       f' (g' x) * vector_derivative g' (at x) =\n       f (g x) * vector_derivative g (at x)", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0..1} -\n               ({0, 1} \\<union> g -` A \\<inter> {0<..<1}) \\<Longrightarrow>\n       f' (g' x) * vector_derivative g' (at x) =\n       f (g x) * vector_derivative g (at x)", "assume \"x \\<in> {0..1} - ({0, 1} \\<union> g -` A \\<inter> {0<..<1})\""], ["proof (state)\nthis:\n  x \\<in> {0..1} - ({0, 1} \\<union> g -` A \\<inter> {0<..<1})\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0..1} -\n               ({0, 1} \\<union> g -` A \\<inter> {0<..<1}) \\<Longrightarrow>\n       f' (g' x) * vector_derivative g' (at x) =\n       f (g x) * vector_derivative g (at x)", "hence \"g x \\<in> path_image g - A\""], ["proof (prove)\nusing this:\n  x \\<in> {0..1} - ({0, 1} \\<union> g -` A \\<inter> {0<..<1})\n\ngoal (1 subgoal):\n 1. g x \\<in> path_image g - A", "by (auto simp: path_image_def)"], ["proof (state)\nthis:\n  g x \\<in> path_image g - A\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0..1} -\n               ({0, 1} \\<union> g -` A \\<inter> {0<..<1}) \\<Longrightarrow>\n       f' (g' x) * vector_derivative g' (at x) =\n       f (g x) * vector_derivative g (at x)", "from assms(4)[OF this] and assms(3)"], ["proof (chain)\npicking this:\n  f (g x) = f' (g x)\n  g = g'", "show \"f' (g' x) * vector_derivative g' (at x) = f (g x) * vector_derivative g (at x)\""], ["proof (prove)\nusing this:\n  f (g x) = f' (g x)\n  g = g'\n\ngoal (1 subgoal):\n 1. f' (g' x) * vector_derivative g' (at x) =\n    f (g x) * vector_derivative g (at x)", "by simp"], ["proof (state)\nthis:\n  f' (g' x) * vector_derivative g' (at x) =\n  f (g x) * vector_derivative g (at x)\n\ngoal:\nNo subgoals!", "qed"], ["", "proposition contour_integral_bound_part_circlepath_strong:\n  assumes fi: \"f contour_integrable_on part_circlepath z r s t\"\n      and \"finite k\" and le: \"0 \\<le> B\" \"0 < r\" \"s \\<le> t\"\n      and B: \"\\<And>x. x \\<in> path_image(part_circlepath z r s t) - k \\<Longrightarrow> norm(f x) \\<le> B\"\n    shows \"cmod (contour_integral (part_circlepath z r s t) f) \\<le> B * r * (t - s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod (contour_integral (part_circlepath z r s t) f)\n    \\<le> B * r * (t - s)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cmod (contour_integral (part_circlepath z r s t) f)\n    \\<le> B * r * (t - s)", "from fi"], ["proof (chain)\npicking this:\n  f contour_integrable_on part_circlepath z r s t", "have \"(f has_contour_integral contour_integral (part_circlepath z r s t) f)\n                  (part_circlepath z r s t)\""], ["proof (prove)\nusing this:\n  f contour_integrable_on part_circlepath z r s t\n\ngoal (1 subgoal):\n 1. (f has_contour_integral contour_integral (part_circlepath z r s t) f)\n     (part_circlepath z r s t)", "by (rule has_contour_integral_integral)"], ["proof (state)\nthis:\n  (f has_contour_integral contour_integral (part_circlepath z r s t) f)\n   (part_circlepath z r s t)\n\ngoal (1 subgoal):\n 1. cmod (contour_integral (part_circlepath z r s t) f)\n    \\<le> B * r * (t - s)", "from has_contour_integral_bound_part_circlepath_strong[OF this assms(2-)]"], ["proof (chain)\npicking this:\n  (\\<And>x.\n      x \\<in> path_image (part_circlepath z r s t) - k \\<Longrightarrow>\n      x \\<in> path_image (part_circlepath z r s t) - k) \\<Longrightarrow>\n  cmod (contour_integral (part_circlepath z r s t) f) \\<le> B * r * (t - s)", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<And>x.\n      x \\<in> path_image (part_circlepath z r s t) - k \\<Longrightarrow>\n      x \\<in> path_image (part_circlepath z r s t) - k) \\<Longrightarrow>\n  cmod (contour_integral (part_circlepath z r s t) f) \\<le> B * r * (t - s)\n\ngoal (1 subgoal):\n 1. cmod (contour_integral (part_circlepath z r s t) f)\n    \\<le> B * r * (t - s)", "by auto"], ["proof (state)\nthis:\n  cmod (contour_integral (part_circlepath z r s t) f) \\<le> B * r * (t - s)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cos_le_zero:\n  assumes \"x \\<in> {pi/2..3*pi/2}\"\n  shows   \"cos x \\<le> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cos x \\<le> 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cos x \\<le> 0", "have \"cos x = -cos (x - pi)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cos x = - cos (x - pi)", "by (simp add: cos_diff)"], ["proof (state)\nthis:\n  cos x = - cos (x - pi)\n\ngoal (1 subgoal):\n 1. cos x \\<le> 0", "moreover"], ["proof (state)\nthis:\n  cos x = - cos (x - pi)\n\ngoal (1 subgoal):\n 1. cos x \\<le> 0", "from assms"], ["proof (chain)\npicking this:\n  x \\<in> {pi / 2..3 * pi / 2}", "have \"cos (x - pi) \\<ge> 0\""], ["proof (prove)\nusing this:\n  x \\<in> {pi / 2..3 * pi / 2}\n\ngoal (1 subgoal):\n 1. 0 \\<le> cos (x - pi)", "by (intro cos_ge_zero) auto"], ["proof (state)\nthis:\n  0 \\<le> cos (x - pi)\n\ngoal (1 subgoal):\n 1. cos x \\<le> 0", "ultimately"], ["proof (chain)\npicking this:\n  cos x = - cos (x - pi)\n  0 \\<le> cos (x - pi)", "show ?thesis"], ["proof (prove)\nusing this:\n  cos x = - cos (x - pi)\n  0 \\<le> cos (x - pi)\n\ngoal (1 subgoal):\n 1. cos x \\<le> 0", "by simp"], ["proof (state)\nthis:\n  cos x \\<le> 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cos_le_zero': \"x \\<in> {-3*pi/2..-pi/2} \\<Longrightarrow> cos x \\<le> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> {- 3 * pi / 2..- pi / 2} \\<Longrightarrow> cos x \\<le> 0", "using cos_le_zero[of \"-x\"]"], ["proof (prove)\nusing this:\n  - x \\<in> {pi / 2..3 * pi / 2} \\<Longrightarrow> cos (- x) \\<le> 0\n\ngoal (1 subgoal):\n 1. x \\<in> {- 3 * pi / 2..- pi / 2} \\<Longrightarrow> cos x \\<le> 0", "by simp"], ["", "lemma cis_minus_pi_half [simp]: \"cis (- (pi / 2)) = -\\<i>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cis (- (pi / 2)) = - \\<i>", "by (simp add: complex_eq_iff)"], ["", "lemma winding_number_join_pos_combined':\n     \"\\<lbrakk>valid_path \\<gamma>1 \\<and> z \\<notin> path_image \\<gamma>1 \\<and> 0 < Re (winding_number \\<gamma>1 z);\n       valid_path \\<gamma>2 \\<and> z \\<notin> path_image \\<gamma>2 \\<and> 0 < Re (winding_number \\<gamma>2 z);\n       pathfinish \\<gamma>1 = pathstart \\<gamma>2\\<rbrakk>\n      \\<Longrightarrow> valid_path(\\<gamma>1 +++ \\<gamma>2) \\<and> z \\<notin> path_image(\\<gamma>1 +++ \\<gamma>2) \\<and> 0 < Re(winding_number(\\<gamma>1 +++ \\<gamma>2) z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_path \\<gamma>1 \\<and>\n             z \\<notin> path_image \\<gamma>1 \\<and>\n             0 < Re (winding_number \\<gamma>1 z);\n     valid_path \\<gamma>2 \\<and>\n     z \\<notin> path_image \\<gamma>2 \\<and>\n     0 < Re (winding_number \\<gamma>2 z);\n     pathfinish \\<gamma>1 = pathstart \\<gamma>2\\<rbrakk>\n    \\<Longrightarrow> valid_path (\\<gamma>1 +++ \\<gamma>2) \\<and>\n                      z \\<notin> path_image (\\<gamma>1 +++ \\<gamma>2) \\<and>\n                      0 < Re (winding_number (\\<gamma>1 +++ \\<gamma>2) z)", "by (simp add: valid_path_join path_image_join winding_number_join valid_path_imp_path)"], ["", "lemma Union_atLeastAtMost_real_of_nat:\n  assumes \"a < b\"\n  shows   \"(\\<Union>n\\<in>{a..<b}. {real n..real (n + 1)}) = {real a..real b}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>n\\<in>{a..<b}. {real n..real (n + 1)}) = {real a..real b}", "proof (intro equalityI subsetI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> (\\<Union>n\\<in>{a..<b}.\n                   {real n..real (n + 1)}) \\<Longrightarrow>\n       x \\<in> {real a..real b}\n 2. \\<And>x.\n       x \\<in> {real a..real b} \\<Longrightarrow>\n       x \\<in> (\\<Union>n\\<in>{a..<b}. {real n..real (n + 1)})", "fix x"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> (\\<Union>n\\<in>{a..<b}.\n                   {real n..real (n + 1)}) \\<Longrightarrow>\n       x \\<in> {real a..real b}\n 2. \\<And>x.\n       x \\<in> {real a..real b} \\<Longrightarrow>\n       x \\<in> (\\<Union>n\\<in>{a..<b}. {real n..real (n + 1)})", "assume x: \"x \\<in> {real a..real b}\""], ["proof (state)\nthis:\n  x \\<in> {real a..real b}\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> (\\<Union>n\\<in>{a..<b}.\n                   {real n..real (n + 1)}) \\<Longrightarrow>\n       x \\<in> {real a..real b}\n 2. \\<And>x.\n       x \\<in> {real a..real b} \\<Longrightarrow>\n       x \\<in> (\\<Union>n\\<in>{a..<b}. {real n..real (n + 1)})", "thus \"x \\<in> (\\<Union>n\\<in>{a..<b}. {real n..real (n + 1)})\""], ["proof (prove)\nusing this:\n  x \\<in> {real a..real b}\n\ngoal (1 subgoal):\n 1. x \\<in> (\\<Union>n\\<in>{a..<b}. {real n..real (n + 1)})", "proof (cases \"x = real b\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<in> {real a..real b}; x = real b\\<rbrakk>\n    \\<Longrightarrow> x \\<in> (\\<Union>n\\<in>{a..<b}.\n                                  {real n..real (n + 1)})\n 2. \\<lbrakk>x \\<in> {real a..real b}; x \\<noteq> real b\\<rbrakk>\n    \\<Longrightarrow> x \\<in> (\\<Union>n\\<in>{a..<b}.\n                                  {real n..real (n + 1)})", "case True"], ["proof (state)\nthis:\n  x = real b\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<in> {real a..real b}; x = real b\\<rbrakk>\n    \\<Longrightarrow> x \\<in> (\\<Union>n\\<in>{a..<b}.\n                                  {real n..real (n + 1)})\n 2. \\<lbrakk>x \\<in> {real a..real b}; x \\<noteq> real b\\<rbrakk>\n    \\<Longrightarrow> x \\<in> (\\<Union>n\\<in>{a..<b}.\n                                  {real n..real (n + 1)})", "with assms"], ["proof (chain)\npicking this:\n  a < b\n  x = real b", "show ?thesis"], ["proof (prove)\nusing this:\n  a < b\n  x = real b\n\ngoal (1 subgoal):\n 1. x \\<in> (\\<Union>n\\<in>{a..<b}. {real n..real (n + 1)})", "by (auto intro!: bexI[of _ \"b - 1\"])"], ["proof (state)\nthis:\n  x \\<in> (\\<Union>n\\<in>{a..<b}. {real n..real (n + 1)})\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> {real a..real b}; x \\<noteq> real b\\<rbrakk>\n    \\<Longrightarrow> x \\<in> (\\<Union>n\\<in>{a..<b}.\n                                  {real n..real (n + 1)})", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> {real a..real b}; x \\<noteq> real b\\<rbrakk>\n    \\<Longrightarrow> x \\<in> (\\<Union>n\\<in>{a..<b}.\n                                  {real n..real (n + 1)})", "case False"], ["proof (state)\nthis:\n  x \\<noteq> real b\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> {real a..real b}; x \\<noteq> real b\\<rbrakk>\n    \\<Longrightarrow> x \\<in> (\\<Union>n\\<in>{a..<b}.\n                                  {real n..real (n + 1)})", "with x"], ["proof (chain)\npicking this:\n  x \\<in> {real a..real b}\n  x \\<noteq> real b", "have x: \"x \\<ge> real a\" \"x < real b\""], ["proof (prove)\nusing this:\n  x \\<in> {real a..real b}\n  x \\<noteq> real b\n\ngoal (1 subgoal):\n 1. real a \\<le> x &&& x < real b", "by simp_all"], ["proof (state)\nthis:\n  real a \\<le> x\n  x < real b\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> {real a..real b}; x \\<noteq> real b\\<rbrakk>\n    \\<Longrightarrow> x \\<in> (\\<Union>n\\<in>{a..<b}.\n                                  {real n..real (n + 1)})", "hence \"x \\<ge> real (nat \\<lfloor>x\\<rfloor>)\" \"x \\<le> real (Suc (nat \\<lfloor>x\\<rfloor>))\""], ["proof (prove)\nusing this:\n  real a \\<le> x\n  x < real b\n\ngoal (1 subgoal):\n 1. real (nat \\<lfloor>x\\<rfloor>) \\<le> x &&&\n    x \\<le> real (Suc (nat \\<lfloor>x\\<rfloor>))", "by linarith+"], ["proof (state)\nthis:\n  real (nat \\<lfloor>x\\<rfloor>) \\<le> x\n  x \\<le> real (Suc (nat \\<lfloor>x\\<rfloor>))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> {real a..real b}; x \\<noteq> real b\\<rbrakk>\n    \\<Longrightarrow> x \\<in> (\\<Union>n\\<in>{a..<b}.\n                                  {real n..real (n + 1)})", "moreover"], ["proof (state)\nthis:\n  real (nat \\<lfloor>x\\<rfloor>) \\<le> x\n  x \\<le> real (Suc (nat \\<lfloor>x\\<rfloor>))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> {real a..real b}; x \\<noteq> real b\\<rbrakk>\n    \\<Longrightarrow> x \\<in> (\\<Union>n\\<in>{a..<b}.\n                                  {real n..real (n + 1)})", "from x"], ["proof (chain)\npicking this:\n  real a \\<le> x\n  x < real b", "have \"nat \\<lfloor>x\\<rfloor> \\<ge> a\" \"nat \\<lfloor>x\\<rfloor> < b\""], ["proof (prove)\nusing this:\n  real a \\<le> x\n  x < real b\n\ngoal (1 subgoal):\n 1. a \\<le> nat \\<lfloor>x\\<rfloor> &&& nat \\<lfloor>x\\<rfloor> < b", "by linarith+"], ["proof (state)\nthis:\n  a \\<le> nat \\<lfloor>x\\<rfloor>\n  nat \\<lfloor>x\\<rfloor> < b\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> {real a..real b}; x \\<noteq> real b\\<rbrakk>\n    \\<Longrightarrow> x \\<in> (\\<Union>n\\<in>{a..<b}.\n                                  {real n..real (n + 1)})", "ultimately"], ["proof (chain)\npicking this:\n  real (nat \\<lfloor>x\\<rfloor>) \\<le> x\n  x \\<le> real (Suc (nat \\<lfloor>x\\<rfloor>))\n  a \\<le> nat \\<lfloor>x\\<rfloor>\n  nat \\<lfloor>x\\<rfloor> < b", "have \"\\<exists>n\\<in>{a..<b}. x \\<in> {real n..real (n + 1)}\""], ["proof (prove)\nusing this:\n  real (nat \\<lfloor>x\\<rfloor>) \\<le> x\n  x \\<le> real (Suc (nat \\<lfloor>x\\<rfloor>))\n  a \\<le> nat \\<lfloor>x\\<rfloor>\n  nat \\<lfloor>x\\<rfloor> < b\n\ngoal (1 subgoal):\n 1. \\<exists>n\\<in>{a..<b}. x \\<in> {real n..real (n + 1)}", "by (intro bexI[of _ \"nat \\<lfloor>x\\<rfloor>\"]) simp_all"], ["proof (state)\nthis:\n  \\<exists>n\\<in>{a..<b}. x \\<in> {real n..real (n + 1)}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> {real a..real b}; x \\<noteq> real b\\<rbrakk>\n    \\<Longrightarrow> x \\<in> (\\<Union>n\\<in>{a..<b}.\n                                  {real n..real (n + 1)})", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>n\\<in>{a..<b}. x \\<in> {real n..real (n + 1)}\n\ngoal (1 subgoal):\n 1. x \\<in> (\\<Union>n\\<in>{a..<b}. {real n..real (n + 1)})", "by blast"], ["proof (state)\nthis:\n  x \\<in> (\\<Union>n\\<in>{a..<b}. {real n..real (n + 1)})\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x \\<in> (\\<Union>n\\<in>{a..<b}. {real n..real (n + 1)})\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (\\<Union>n\\<in>{a..<b}.\n                   {real n..real (n + 1)}) \\<Longrightarrow>\n       x \\<in> {real a..real b}", "qed auto"], ["", "lemma nat_sum_has_integral_floor:\n  fixes f :: \"nat \\<Rightarrow> 'a :: banach\"\n  assumes mn: \"m < n\"\n  shows \"((\\<lambda>x. f (nat \\<lfloor>x\\<rfloor>)) has_integral sum f {m..<n}) {real m..real n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x. f (nat \\<lfloor>x\\<rfloor>)) has_integral sum f {m..<n})\n     {real m..real n}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ((\\<lambda>x. f (nat \\<lfloor>x\\<rfloor>)) has_integral sum f {m..<n})\n     {real m..real n}", "define D where \"D = (\\<lambda>i. {real i..real (Suc i)}) ` {m..<n}\""], ["proof (state)\nthis:\n  D = (\\<lambda>i. {real i..real (Suc i)}) ` {m..<n}\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. f (nat \\<lfloor>x\\<rfloor>)) has_integral sum f {m..<n})\n     {real m..real n}", "have D: \"D division_of {m..n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. D division_of {real m..real n}", "using Union_atLeastAtMost_real_of_nat[OF mn]"], ["proof (prove)\nusing this:\n  (\\<Union>n\\<in>{m..<n}. {real n..real (n + 1)}) = {real m..real n}\n\ngoal (1 subgoal):\n 1. D division_of {real m..real n}", "by (simp add: division_of_def D_def)"], ["proof (state)\nthis:\n  D division_of {real m..real n}\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. f (nat \\<lfloor>x\\<rfloor>)) has_integral sum f {m..<n})\n     {real m..real n}", "have \"((\\<lambda>x. f (nat \\<lfloor>x\\<rfloor>)) has_integral (\\<Sum>X\\<in>D. f (nat \\<lfloor>Inf X\\<rfloor>))) {real m..real n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x. f (nat \\<lfloor>x\\<rfloor>)) has_integral\n     (\\<Sum>X\\<in>D. f (nat \\<lfloor>Inf X\\<rfloor>)))\n     {real m..real n}", "proof (rule has_integral_combine_division)"], ["proof (state)\ngoal (2 subgoals):\n 1. D division_of {real m..real n}\n 2. \\<And>k.\n       k \\<in> D \\<Longrightarrow>\n       ((\\<lambda>x. f (nat \\<lfloor>x\\<rfloor>)) has_integral\n        f (nat \\<lfloor>Inf k\\<rfloor>))\n        k", "fix X"], ["proof (state)\ngoal (2 subgoals):\n 1. D division_of {real m..real n}\n 2. \\<And>k.\n       k \\<in> D \\<Longrightarrow>\n       ((\\<lambda>x. f (nat \\<lfloor>x\\<rfloor>)) has_integral\n        f (nat \\<lfloor>Inf k\\<rfloor>))\n        k", "assume X: \"X \\<in> D\""], ["proof (state)\nthis:\n  X \\<in> D\n\ngoal (2 subgoals):\n 1. D division_of {real m..real n}\n 2. \\<And>k.\n       k \\<in> D \\<Longrightarrow>\n       ((\\<lambda>x. f (nat \\<lfloor>x\\<rfloor>)) has_integral\n        f (nat \\<lfloor>Inf k\\<rfloor>))\n        k", "have \"nat \\<lfloor>x\\<rfloor> = nat \\<lfloor>Inf X\\<rfloor>\" if \"x \\<in> X - {Sup X}\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. nat \\<lfloor>x\\<rfloor> = nat \\<lfloor>Inf X\\<rfloor>", "using that X"], ["proof (prove)\nusing this:\n  x \\<in> X - {Sup X}\n  X \\<in> D\n\ngoal (1 subgoal):\n 1. nat \\<lfloor>x\\<rfloor> = nat \\<lfloor>Inf X\\<rfloor>", "by (auto simp: D_def nat_eq_iff floor_eq_iff)"], ["proof (state)\nthis:\n  ?x \\<in> X - {Sup X} \\<Longrightarrow>\n  nat \\<lfloor>?x\\<rfloor> = nat \\<lfloor>Inf X\\<rfloor>\n\ngoal (2 subgoals):\n 1. D division_of {real m..real n}\n 2. \\<And>k.\n       k \\<in> D \\<Longrightarrow>\n       ((\\<lambda>x. f (nat \\<lfloor>x\\<rfloor>)) has_integral\n        f (nat \\<lfloor>Inf k\\<rfloor>))\n        k", "hence \"((\\<lambda>x. f (nat \\<lfloor>x\\<rfloor>)) has_integral f (nat \\<lfloor>Inf X\\<rfloor>)) X \\<longleftrightarrow>\n           ((\\<lambda>x. f (nat \\<lfloor>Inf X\\<rfloor>)) has_integral f (nat \\<lfloor>Inf X\\<rfloor>)) X\""], ["proof (prove)\nusing this:\n  ?x \\<in> X - {Sup X} \\<Longrightarrow>\n  nat \\<lfloor>?x\\<rfloor> = nat \\<lfloor>Inf X\\<rfloor>\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. f (nat \\<lfloor>x\\<rfloor>)) has_integral\n     f (nat \\<lfloor>Inf X\\<rfloor>))\n     X =\n    ((\\<lambda>x. f (nat \\<lfloor>Inf X\\<rfloor>)) has_integral\n     f (nat \\<lfloor>Inf X\\<rfloor>))\n     X", "using X"], ["proof (prove)\nusing this:\n  ?x \\<in> X - {Sup X} \\<Longrightarrow>\n  nat \\<lfloor>?x\\<rfloor> = nat \\<lfloor>Inf X\\<rfloor>\n  X \\<in> D\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. f (nat \\<lfloor>x\\<rfloor>)) has_integral\n     f (nat \\<lfloor>Inf X\\<rfloor>))\n     X =\n    ((\\<lambda>x. f (nat \\<lfloor>Inf X\\<rfloor>)) has_integral\n     f (nat \\<lfloor>Inf X\\<rfloor>))\n     X", "by (intro has_integral_spike_eq[of \"{Sup X}\"]) auto"], ["proof (state)\nthis:\n  ((\\<lambda>x. f (nat \\<lfloor>x\\<rfloor>)) has_integral\n   f (nat \\<lfloor>Inf X\\<rfloor>))\n   X =\n  ((\\<lambda>x. f (nat \\<lfloor>Inf X\\<rfloor>)) has_integral\n   f (nat \\<lfloor>Inf X\\<rfloor>))\n   X\n\ngoal (2 subgoals):\n 1. D division_of {real m..real n}\n 2. \\<And>k.\n       k \\<in> D \\<Longrightarrow>\n       ((\\<lambda>x. f (nat \\<lfloor>x\\<rfloor>)) has_integral\n        f (nat \\<lfloor>Inf k\\<rfloor>))\n        k", "also"], ["proof (state)\nthis:\n  ((\\<lambda>x. f (nat \\<lfloor>x\\<rfloor>)) has_integral\n   f (nat \\<lfloor>Inf X\\<rfloor>))\n   X =\n  ((\\<lambda>x. f (nat \\<lfloor>Inf X\\<rfloor>)) has_integral\n   f (nat \\<lfloor>Inf X\\<rfloor>))\n   X\n\ngoal (2 subgoals):\n 1. D division_of {real m..real n}\n 2. \\<And>k.\n       k \\<in> D \\<Longrightarrow>\n       ((\\<lambda>x. f (nat \\<lfloor>x\\<rfloor>)) has_integral\n        f (nat \\<lfloor>Inf k\\<rfloor>))\n        k", "from X"], ["proof (chain)\npicking this:\n  X \\<in> D", "have \"\\<dots>\""], ["proof (prove)\nusing this:\n  X \\<in> D\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. f (nat \\<lfloor>Inf X\\<rfloor>)) has_integral\n     f (nat \\<lfloor>Inf X\\<rfloor>))\n     X", "using has_integral_const_real[of \"f (nat \\<lfloor>Inf X\\<rfloor>)\" \"Inf X\" \"Sup X\"]"], ["proof (prove)\nusing this:\n  X \\<in> D\n  ((\\<lambda>x. f (nat \\<lfloor>Inf X\\<rfloor>)) has_integral\n   Henstock_Kurzweil_Integration.content {Inf X..Sup X} *\\<^sub>R\n   f (nat \\<lfloor>Inf X\\<rfloor>))\n   {Inf X..Sup X}\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. f (nat \\<lfloor>Inf X\\<rfloor>)) has_integral\n     f (nat \\<lfloor>Inf X\\<rfloor>))\n     X", "by (auto simp: D_def)"], ["proof (state)\nthis:\n  ((\\<lambda>x. f (nat \\<lfloor>Inf X\\<rfloor>)) has_integral\n   f (nat \\<lfloor>Inf X\\<rfloor>))\n   X\n\ngoal (2 subgoals):\n 1. D division_of {real m..real n}\n 2. \\<And>k.\n       k \\<in> D \\<Longrightarrow>\n       ((\\<lambda>x. f (nat \\<lfloor>x\\<rfloor>)) has_integral\n        f (nat \\<lfloor>Inf k\\<rfloor>))\n        k", "finally"], ["proof (chain)\npicking this:\n  ((\\<lambda>x. f (nat \\<lfloor>x\\<rfloor>)) has_integral\n   f (nat \\<lfloor>Inf X\\<rfloor>))\n   X", "show \"((\\<lambda>x. f (nat \\<lfloor>x\\<rfloor>)) has_integral f (nat \\<lfloor>Inf X\\<rfloor>)) X\""], ["proof (prove)\nusing this:\n  ((\\<lambda>x. f (nat \\<lfloor>x\\<rfloor>)) has_integral\n   f (nat \\<lfloor>Inf X\\<rfloor>))\n   X\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. f (nat \\<lfloor>x\\<rfloor>)) has_integral\n     f (nat \\<lfloor>Inf X\\<rfloor>))\n     X", "."], ["proof (state)\nthis:\n  ((\\<lambda>x. f (nat \\<lfloor>x\\<rfloor>)) has_integral\n   f (nat \\<lfloor>Inf X\\<rfloor>))\n   X\n\ngoal (1 subgoal):\n 1. D division_of {real m..real n}", "qed fact+"], ["proof (state)\nthis:\n  ((\\<lambda>x. f (nat \\<lfloor>x\\<rfloor>)) has_integral\n   (\\<Sum>X\\<in>D. f (nat \\<lfloor>Inf X\\<rfloor>)))\n   {real m..real n}\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. f (nat \\<lfloor>x\\<rfloor>)) has_integral sum f {m..<n})\n     {real m..real n}", "also"], ["proof (state)\nthis:\n  ((\\<lambda>x. f (nat \\<lfloor>x\\<rfloor>)) has_integral\n   (\\<Sum>X\\<in>D. f (nat \\<lfloor>Inf X\\<rfloor>)))\n   {real m..real n}\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. f (nat \\<lfloor>x\\<rfloor>)) has_integral sum f {m..<n})\n     {real m..real n}", "have \"(\\<Sum>X\\<in>D. f (nat \\<lfloor>Inf X\\<rfloor>)) = (\\<Sum>k\\<in>{m..<n}. f k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>X\\<in>D. f (nat \\<lfloor>Inf X\\<rfloor>)) = sum f {m..<n}", "unfolding D_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>X\\<in>(\\<lambda>i. {real i..real (Suc i)}) ` {m..<n}.\n       f (nat \\<lfloor>Inf X\\<rfloor>)) =\n    sum f {m..<n}", "by (subst sum.reindex) (auto simp: inj_on_def nat_add_distrib)"], ["proof (state)\nthis:\n  (\\<Sum>X\\<in>D. f (nat \\<lfloor>Inf X\\<rfloor>)) = sum f {m..<n}\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. f (nat \\<lfloor>x\\<rfloor>)) has_integral sum f {m..<n})\n     {real m..real n}", "finally"], ["proof (chain)\npicking this:\n  ((\\<lambda>x. f (nat \\<lfloor>x\\<rfloor>)) has_integral sum f {m..<n})\n   {real m..real n}", "show ?thesis"], ["proof (prove)\nusing this:\n  ((\\<lambda>x. f (nat \\<lfloor>x\\<rfloor>)) has_integral sum f {m..<n})\n   {real m..real n}\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. f (nat \\<lfloor>x\\<rfloor>)) has_integral sum f {m..<n})\n     {real m..real n}", "."], ["proof (state)\nthis:\n  ((\\<lambda>x. f (nat \\<lfloor>x\\<rfloor>)) has_integral sum f {m..<n})\n   {real m..real n}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma nat_sum_has_integral_ceiling:\n  fixes f :: \"nat \\<Rightarrow> 'a :: banach\"\n  assumes mn: \"m < n\"\n  shows \"((\\<lambda>x. f (nat \\<lceil>x\\<rceil>)) has_integral sum f {m<..n}) {real m..real n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x. f (nat \\<lceil>x\\<rceil>)) has_integral sum f {m<..n})\n     {real m..real n}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ((\\<lambda>x. f (nat \\<lceil>x\\<rceil>)) has_integral sum f {m<..n})\n     {real m..real n}", "define D where \"D = (\\<lambda>i. {real i..real (Suc i)}) ` {m..<n}\""], ["proof (state)\nthis:\n  D = (\\<lambda>i. {real i..real (Suc i)}) ` {m..<n}\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. f (nat \\<lceil>x\\<rceil>)) has_integral sum f {m<..n})\n     {real m..real n}", "have D: \"D division_of {m..n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. D division_of {real m..real n}", "using Union_atLeastAtMost_real_of_nat[OF mn]"], ["proof (prove)\nusing this:\n  (\\<Union>n\\<in>{m..<n}. {real n..real (n + 1)}) = {real m..real n}\n\ngoal (1 subgoal):\n 1. D division_of {real m..real n}", "by (simp add: division_of_def D_def)"], ["proof (state)\nthis:\n  D division_of {real m..real n}\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. f (nat \\<lceil>x\\<rceil>)) has_integral sum f {m<..n})\n     {real m..real n}", "have \"((\\<lambda>x. f (nat \\<lceil>x\\<rceil>)) has_integral (\\<Sum>X\\<in>D. f (nat \\<lfloor>Sup X\\<rfloor>))) {real m..real n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x. f (nat \\<lceil>x\\<rceil>)) has_integral\n     (\\<Sum>X\\<in>D. f (nat \\<lfloor>Sup X\\<rfloor>)))\n     {real m..real n}", "proof (rule has_integral_combine_division)"], ["proof (state)\ngoal (2 subgoals):\n 1. D division_of {real m..real n}\n 2. \\<And>k.\n       k \\<in> D \\<Longrightarrow>\n       ((\\<lambda>x. f (nat \\<lceil>x\\<rceil>)) has_integral\n        f (nat \\<lfloor>Sup k\\<rfloor>))\n        k", "fix X"], ["proof (state)\ngoal (2 subgoals):\n 1. D division_of {real m..real n}\n 2. \\<And>k.\n       k \\<in> D \\<Longrightarrow>\n       ((\\<lambda>x. f (nat \\<lceil>x\\<rceil>)) has_integral\n        f (nat \\<lfloor>Sup k\\<rfloor>))\n        k", "assume X: \"X \\<in> D\""], ["proof (state)\nthis:\n  X \\<in> D\n\ngoal (2 subgoals):\n 1. D division_of {real m..real n}\n 2. \\<And>k.\n       k \\<in> D \\<Longrightarrow>\n       ((\\<lambda>x. f (nat \\<lceil>x\\<rceil>)) has_integral\n        f (nat \\<lfloor>Sup k\\<rfloor>))\n        k", "have \"nat \\<lceil>x\\<rceil> = nat \\<lfloor>Sup X\\<rfloor>\" if \"x \\<in> X - {Inf X}\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. nat \\<lceil>x\\<rceil> = nat \\<lfloor>Sup X\\<rfloor>", "using that X"], ["proof (prove)\nusing this:\n  x \\<in> X - {Inf X}\n  X \\<in> D\n\ngoal (1 subgoal):\n 1. nat \\<lceil>x\\<rceil> = nat \\<lfloor>Sup X\\<rfloor>", "by (auto simp: D_def nat_eq_iff ceiling_eq_iff)"], ["proof (state)\nthis:\n  ?x \\<in> X - {Inf X} \\<Longrightarrow>\n  nat \\<lceil>?x\\<rceil> = nat \\<lfloor>Sup X\\<rfloor>\n\ngoal (2 subgoals):\n 1. D division_of {real m..real n}\n 2. \\<And>k.\n       k \\<in> D \\<Longrightarrow>\n       ((\\<lambda>x. f (nat \\<lceil>x\\<rceil>)) has_integral\n        f (nat \\<lfloor>Sup k\\<rfloor>))\n        k", "hence \"((\\<lambda>x. f (nat \\<lceil>x\\<rceil>)) has_integral f (nat \\<lfloor>Sup X\\<rfloor>)) X \\<longleftrightarrow>\n           ((\\<lambda>x. f (nat \\<lfloor>Sup X\\<rfloor>)) has_integral f (nat \\<lfloor>Sup X\\<rfloor>)) X\""], ["proof (prove)\nusing this:\n  ?x \\<in> X - {Inf X} \\<Longrightarrow>\n  nat \\<lceil>?x\\<rceil> = nat \\<lfloor>Sup X\\<rfloor>\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. f (nat \\<lceil>x\\<rceil>)) has_integral\n     f (nat \\<lfloor>Sup X\\<rfloor>))\n     X =\n    ((\\<lambda>x. f (nat \\<lfloor>Sup X\\<rfloor>)) has_integral\n     f (nat \\<lfloor>Sup X\\<rfloor>))\n     X", "using X"], ["proof (prove)\nusing this:\n  ?x \\<in> X - {Inf X} \\<Longrightarrow>\n  nat \\<lceil>?x\\<rceil> = nat \\<lfloor>Sup X\\<rfloor>\n  X \\<in> D\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. f (nat \\<lceil>x\\<rceil>)) has_integral\n     f (nat \\<lfloor>Sup X\\<rfloor>))\n     X =\n    ((\\<lambda>x. f (nat \\<lfloor>Sup X\\<rfloor>)) has_integral\n     f (nat \\<lfloor>Sup X\\<rfloor>))\n     X", "by (intro has_integral_spike_eq[of \"{Inf X}\"]) auto"], ["proof (state)\nthis:\n  ((\\<lambda>x. f (nat \\<lceil>x\\<rceil>)) has_integral\n   f (nat \\<lfloor>Sup X\\<rfloor>))\n   X =\n  ((\\<lambda>x. f (nat \\<lfloor>Sup X\\<rfloor>)) has_integral\n   f (nat \\<lfloor>Sup X\\<rfloor>))\n   X\n\ngoal (2 subgoals):\n 1. D division_of {real m..real n}\n 2. \\<And>k.\n       k \\<in> D \\<Longrightarrow>\n       ((\\<lambda>x. f (nat \\<lceil>x\\<rceil>)) has_integral\n        f (nat \\<lfloor>Sup k\\<rfloor>))\n        k", "also"], ["proof (state)\nthis:\n  ((\\<lambda>x. f (nat \\<lceil>x\\<rceil>)) has_integral\n   f (nat \\<lfloor>Sup X\\<rfloor>))\n   X =\n  ((\\<lambda>x. f (nat \\<lfloor>Sup X\\<rfloor>)) has_integral\n   f (nat \\<lfloor>Sup X\\<rfloor>))\n   X\n\ngoal (2 subgoals):\n 1. D division_of {real m..real n}\n 2. \\<And>k.\n       k \\<in> D \\<Longrightarrow>\n       ((\\<lambda>x. f (nat \\<lceil>x\\<rceil>)) has_integral\n        f (nat \\<lfloor>Sup k\\<rfloor>))\n        k", "from X"], ["proof (chain)\npicking this:\n  X \\<in> D", "have \"\\<dots>\""], ["proof (prove)\nusing this:\n  X \\<in> D\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. f (nat \\<lfloor>Sup X\\<rfloor>)) has_integral\n     f (nat \\<lfloor>Sup X\\<rfloor>))\n     X", "using has_integral_const_real[of \"f (nat \\<lfloor>Sup X\\<rfloor>)\" \"Inf X\" \"Sup X\"]"], ["proof (prove)\nusing this:\n  X \\<in> D\n  ((\\<lambda>x. f (nat \\<lfloor>Sup X\\<rfloor>)) has_integral\n   Henstock_Kurzweil_Integration.content {Inf X..Sup X} *\\<^sub>R\n   f (nat \\<lfloor>Sup X\\<rfloor>))\n   {Inf X..Sup X}\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. f (nat \\<lfloor>Sup X\\<rfloor>)) has_integral\n     f (nat \\<lfloor>Sup X\\<rfloor>))\n     X", "by (auto simp: D_def)"], ["proof (state)\nthis:\n  ((\\<lambda>x. f (nat \\<lfloor>Sup X\\<rfloor>)) has_integral\n   f (nat \\<lfloor>Sup X\\<rfloor>))\n   X\n\ngoal (2 subgoals):\n 1. D division_of {real m..real n}\n 2. \\<And>k.\n       k \\<in> D \\<Longrightarrow>\n       ((\\<lambda>x. f (nat \\<lceil>x\\<rceil>)) has_integral\n        f (nat \\<lfloor>Sup k\\<rfloor>))\n        k", "finally"], ["proof (chain)\npicking this:\n  ((\\<lambda>x. f (nat \\<lceil>x\\<rceil>)) has_integral\n   f (nat \\<lfloor>Sup X\\<rfloor>))\n   X", "show \"((\\<lambda>x. f (nat \\<lceil>x\\<rceil>)) has_integral f (nat \\<lfloor>Sup X\\<rfloor>)) X\""], ["proof (prove)\nusing this:\n  ((\\<lambda>x. f (nat \\<lceil>x\\<rceil>)) has_integral\n   f (nat \\<lfloor>Sup X\\<rfloor>))\n   X\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. f (nat \\<lceil>x\\<rceil>)) has_integral\n     f (nat \\<lfloor>Sup X\\<rfloor>))\n     X", "."], ["proof (state)\nthis:\n  ((\\<lambda>x. f (nat \\<lceil>x\\<rceil>)) has_integral\n   f (nat \\<lfloor>Sup X\\<rfloor>))\n   X\n\ngoal (1 subgoal):\n 1. D division_of {real m..real n}", "qed fact+"], ["proof (state)\nthis:\n  ((\\<lambda>x. f (nat \\<lceil>x\\<rceil>)) has_integral\n   (\\<Sum>X\\<in>D. f (nat \\<lfloor>Sup X\\<rfloor>)))\n   {real m..real n}\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. f (nat \\<lceil>x\\<rceil>)) has_integral sum f {m<..n})\n     {real m..real n}", "also"], ["proof (state)\nthis:\n  ((\\<lambda>x. f (nat \\<lceil>x\\<rceil>)) has_integral\n   (\\<Sum>X\\<in>D. f (nat \\<lfloor>Sup X\\<rfloor>)))\n   {real m..real n}\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. f (nat \\<lceil>x\\<rceil>)) has_integral sum f {m<..n})\n     {real m..real n}", "have \"(\\<Sum>X\\<in>D. f (nat \\<lfloor>Sup X\\<rfloor>)) = (\\<Sum>k\\<in>{m..<n}. f (Suc k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>X\\<in>D. f (nat \\<lfloor>Sup X\\<rfloor>)) =\n    (\\<Sum>k = m..<n. f (Suc k))", "unfolding D_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>X\\<in>(\\<lambda>i. {real i..real (Suc i)}) ` {m..<n}.\n       f (nat \\<lfloor>Sup X\\<rfloor>)) =\n    (\\<Sum>k = m..<n. f (Suc k))", "by (subst sum.reindex) (auto simp: inj_on_def nat_add_distrib)"], ["proof (state)\nthis:\n  (\\<Sum>X\\<in>D. f (nat \\<lfloor>Sup X\\<rfloor>)) =\n  (\\<Sum>k = m..<n. f (Suc k))\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. f (nat \\<lceil>x\\<rceil>)) has_integral sum f {m<..n})\n     {real m..real n}", "also"], ["proof (state)\nthis:\n  (\\<Sum>X\\<in>D. f (nat \\<lfloor>Sup X\\<rfloor>)) =\n  (\\<Sum>k = m..<n. f (Suc k))\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. f (nat \\<lceil>x\\<rceil>)) has_integral sum f {m<..n})\n     {real m..real n}", "have \"\\<dots> = (\\<Sum>k\\<in>{m<..n}. f k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k = m..<n. f (Suc k)) = sum f {m<..n}", "by (intro sum.reindex_bij_witness[of _ \"\\<lambda>x. x - 1\" Suc]) auto"], ["proof (state)\nthis:\n  (\\<Sum>k = m..<n. f (Suc k)) = sum f {m<..n}\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. f (nat \\<lceil>x\\<rceil>)) has_integral sum f {m<..n})\n     {real m..real n}", "finally"], ["proof (chain)\npicking this:\n  ((\\<lambda>x. f (nat \\<lceil>x\\<rceil>)) has_integral sum f {m<..n})\n   {real m..real n}", "show ?thesis"], ["proof (prove)\nusing this:\n  ((\\<lambda>x. f (nat \\<lceil>x\\<rceil>)) has_integral sum f {m<..n})\n   {real m..real n}\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. f (nat \\<lceil>x\\<rceil>)) has_integral sum f {m<..n})\n     {real m..real n}", "."], ["proof (state)\nthis:\n  ((\\<lambda>x. f (nat \\<lceil>x\\<rceil>)) has_integral sum f {m<..n})\n   {real m..real n}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma zeta_partial_sum_le:\n  fixes x :: real and m :: nat\n  assumes x: \"x \\<in> {0<..1}\"\n  shows \"(\\<Sum>k=1..m. real k powr (x - 1)) \\<le> real m powr x / x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k = 1..m. real k powr (x - 1)) \\<le> real m powr x / x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>k = 1..m. real k powr (x - 1)) \\<le> real m powr x / x", "consider \"m = 0\" | \"m = 1\" | \"m > 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>m = 0 \\<Longrightarrow> thesis; m = 1 \\<Longrightarrow> thesis;\n     1 < m \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by force"], ["proof (state)\nthis:\n  \\<lbrakk>m = 0 \\<Longrightarrow> ?thesis; m = 1 \\<Longrightarrow> ?thesis;\n   1 < m \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (\\<Sum>k = 1..m. real k powr (x - 1)) \\<le> real m powr x / x", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>m = 0 \\<Longrightarrow> ?thesis; m = 1 \\<Longrightarrow> ?thesis;\n   1 < m \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (\\<Sum>k = 1..m. real k powr (x - 1)) \\<le> real m powr x / x", "proof cases"], ["proof (state)\ngoal (3 subgoals):\n 1. m = 0 \\<Longrightarrow>\n    (\\<Sum>k = 1..m. real k powr (x - 1)) \\<le> real m powr x / x\n 2. m = 1 \\<Longrightarrow>\n    (\\<Sum>k = 1..m. real k powr (x - 1)) \\<le> real m powr x / x\n 3. 1 < m \\<Longrightarrow>\n    (\\<Sum>k = 1..m. real k powr (x - 1)) \\<le> real m powr x / x", "assume m: \"m > 1\""], ["proof (state)\nthis:\n  1 < m\n\ngoal (3 subgoals):\n 1. m = 0 \\<Longrightarrow>\n    (\\<Sum>k = 1..m. real k powr (x - 1)) \\<le> real m powr x / x\n 2. m = 1 \\<Longrightarrow>\n    (\\<Sum>k = 1..m. real k powr (x - 1)) \\<le> real m powr x / x\n 3. 1 < m \\<Longrightarrow>\n    (\\<Sum>k = 1..m. real k powr (x - 1)) \\<le> real m powr x / x", "hence \"{1..m} = insert 1 {1<..m}\""], ["proof (prove)\nusing this:\n  1 < m\n\ngoal (1 subgoal):\n 1. {1..m} = insert 1 {1<..m}", "by auto"], ["proof (state)\nthis:\n  {1..m} = insert 1 {1<..m}\n\ngoal (3 subgoals):\n 1. m = 0 \\<Longrightarrow>\n    (\\<Sum>k = 1..m. real k powr (x - 1)) \\<le> real m powr x / x\n 2. m = 1 \\<Longrightarrow>\n    (\\<Sum>k = 1..m. real k powr (x - 1)) \\<le> real m powr x / x\n 3. 1 < m \\<Longrightarrow>\n    (\\<Sum>k = 1..m. real k powr (x - 1)) \\<le> real m powr x / x", "also"], ["proof (state)\nthis:\n  {1..m} = insert 1 {1<..m}\n\ngoal (3 subgoals):\n 1. m = 0 \\<Longrightarrow>\n    (\\<Sum>k = 1..m. real k powr (x - 1)) \\<le> real m powr x / x\n 2. m = 1 \\<Longrightarrow>\n    (\\<Sum>k = 1..m. real k powr (x - 1)) \\<le> real m powr x / x\n 3. 1 < m \\<Longrightarrow>\n    (\\<Sum>k = 1..m. real k powr (x - 1)) \\<le> real m powr x / x", "have \"(\\<Sum>k\\<in>\\<dots>. real k powr (x - 1)) = 1 + (\\<Sum>k\\<in>{1<..m}. real k powr (x - 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k\\<in>insert 1 {1<..m}. real k powr (x - 1)) =\n    1 + (\\<Sum>k\\<in>{1<..m}. real k powr (x - 1))", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>k\\<in>insert 1 {1<..m}. real k powr (x - 1)) =\n  1 + (\\<Sum>k\\<in>{1<..m}. real k powr (x - 1))\n\ngoal (3 subgoals):\n 1. m = 0 \\<Longrightarrow>\n    (\\<Sum>k = 1..m. real k powr (x - 1)) \\<le> real m powr x / x\n 2. m = 1 \\<Longrightarrow>\n    (\\<Sum>k = 1..m. real k powr (x - 1)) \\<le> real m powr x / x\n 3. 1 < m \\<Longrightarrow>\n    (\\<Sum>k = 1..m. real k powr (x - 1)) \\<le> real m powr x / x", "also"], ["proof (state)\nthis:\n  (\\<Sum>k\\<in>insert 1 {1<..m}. real k powr (x - 1)) =\n  1 + (\\<Sum>k\\<in>{1<..m}. real k powr (x - 1))\n\ngoal (3 subgoals):\n 1. m = 0 \\<Longrightarrow>\n    (\\<Sum>k = 1..m. real k powr (x - 1)) \\<le> real m powr x / x\n 2. m = 1 \\<Longrightarrow>\n    (\\<Sum>k = 1..m. real k powr (x - 1)) \\<le> real m powr x / x\n 3. 1 < m \\<Longrightarrow>\n    (\\<Sum>k = 1..m. real k powr (x - 1)) \\<le> real m powr x / x", "have \"(\\<Sum>k\\<in>{1<..m}. real k powr (x - 1)) \\<le> real m powr x / x - 1 / x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k\\<in>{1<..m}. real k powr (x - 1))\n    \\<le> real m powr x / x - 1 / x", "proof (rule has_integral_le)"], ["proof (state)\ngoal (3 subgoals):\n 1. (?f has_integral (\\<Sum>k\\<in>{1<..m}. real k powr (x - 1))) ?S\n 2. (?g has_integral real m powr x / x - 1 / x) ?S\n 3. \\<And>x. x \\<in> ?S \\<Longrightarrow> ?f x \\<le> ?g x", "show \"((\\<lambda>t. (nat \\<lceil>t\\<rceil>) powr (x - 1)) has_integral (\\<Sum>n\\<in>{1<..m}. n powr (x - 1))) {real 1..m}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>t. real (nat \\<lceil>t\\<rceil>) powr (x - 1)) has_integral\n     (\\<Sum>n\\<in>{1<..m}. real n powr (x - 1)))\n     {real 1..real m}", "using m"], ["proof (prove)\nusing this:\n  1 < m\n\ngoal (1 subgoal):\n 1. ((\\<lambda>t. real (nat \\<lceil>t\\<rceil>) powr (x - 1)) has_integral\n     (\\<Sum>n\\<in>{1<..m}. real n powr (x - 1)))\n     {real 1..real m}", "by (intro nat_sum_has_integral_ceiling) auto"], ["proof (state)\nthis:\n  ((\\<lambda>t. real (nat \\<lceil>t\\<rceil>) powr (x - 1)) has_integral\n   (\\<Sum>n\\<in>{1<..m}. real n powr (x - 1)))\n   {real 1..real m}\n\ngoal (2 subgoals):\n 1. (?g has_integral real m powr x / x - 1 / x) {real 1..real m}\n 2. \\<And>xa.\n       xa \\<in> {real 1..real m} \\<Longrightarrow>\n       real (nat \\<lceil>xa\\<rceil>) powr (x - 1) \\<le> ?g xa", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. (?g has_integral real m powr x / x - 1 / x) {real 1..real m}\n 2. \\<And>xa.\n       xa \\<in> {real 1..real m} \\<Longrightarrow>\n       real (nat \\<lceil>xa\\<rceil>) powr (x - 1) \\<le> ?g xa", "have \"((\\<lambda>t. t powr (x - 1)) has_integral (real m powr x / x - real 1 powr x / x))\n              {real 1..real m}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>t. t powr (x - 1)) has_integral\n     real m powr x / x - real 1 powr x / x)\n     {real 1..real m}", "by (intro fundamental_theorem_of_calculus)\n           (insert x m, auto simp flip: has_field_derivative_iff_has_vector_derivative\n                             intro!: derivative_eq_intros)"], ["proof (state)\nthis:\n  ((\\<lambda>t. t powr (x - 1)) has_integral\n   real m powr x / x - real 1 powr x / x)\n   {real 1..real m}\n\ngoal (2 subgoals):\n 1. (?g has_integral real m powr x / x - 1 / x) {real 1..real m}\n 2. \\<And>xa.\n       xa \\<in> {real 1..real m} \\<Longrightarrow>\n       real (nat \\<lceil>xa\\<rceil>) powr (x - 1) \\<le> ?g xa", "thus \"((\\<lambda>t. t powr (x - 1)) has_integral (real m powr x / x - 1 / x)) {real 1..real m}\""], ["proof (prove)\nusing this:\n  ((\\<lambda>t. t powr (x - 1)) has_integral\n   real m powr x / x - real 1 powr x / x)\n   {real 1..real m}\n\ngoal (1 subgoal):\n 1. ((\\<lambda>t. t powr (x - 1)) has_integral real m powr x / x - 1 / x)\n     {real 1..real m}", "by simp"], ["proof (state)\nthis:\n  ((\\<lambda>t. t powr (x - 1)) has_integral real m powr x / x - 1 / x)\n   {real 1..real m}\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> {real 1..real m} \\<Longrightarrow>\n       real (nat \\<lceil>xa\\<rceil>) powr (x - 1) \\<le> xa powr (x - 1)", "qed (insert x, auto intro!: powr_mono2')"], ["proof (state)\nthis:\n  (\\<Sum>k\\<in>{1<..m}. real k powr (x - 1)) \\<le> real m powr x / x - 1 / x\n\ngoal (3 subgoals):\n 1. m = 0 \\<Longrightarrow>\n    (\\<Sum>k = 1..m. real k powr (x - 1)) \\<le> real m powr x / x\n 2. m = 1 \\<Longrightarrow>\n    (\\<Sum>k = 1..m. real k powr (x - 1)) \\<le> real m powr x / x\n 3. 1 < m \\<Longrightarrow>\n    (\\<Sum>k = 1..m. real k powr (x - 1)) \\<le> real m powr x / x", "also"], ["proof (state)\nthis:\n  (\\<Sum>k\\<in>{1<..m}. real k powr (x - 1)) \\<le> real m powr x / x - 1 / x\n\ngoal (3 subgoals):\n 1. m = 0 \\<Longrightarrow>\n    (\\<Sum>k = 1..m. real k powr (x - 1)) \\<le> real m powr x / x\n 2. m = 1 \\<Longrightarrow>\n    (\\<Sum>k = 1..m. real k powr (x - 1)) \\<le> real m powr x / x\n 3. 1 < m \\<Longrightarrow>\n    (\\<Sum>k = 1..m. real k powr (x - 1)) \\<le> real m powr x / x", "have \"1 + (real m powr x / x - 1 / x) \\<le> real m powr x / x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 + (real m powr x / x - 1 / x) \\<le> real m powr x / x", "using x"], ["proof (prove)\nusing this:\n  x \\<in> {0<..1}\n\ngoal (1 subgoal):\n 1. 1 + (real m powr x / x - 1 / x) \\<le> real m powr x / x", "by (simp add: field_simps)"], ["proof (state)\nthis:\n  1 + (real m powr x / x - 1 / x) \\<le> real m powr x / x\n\ngoal (3 subgoals):\n 1. m = 0 \\<Longrightarrow>\n    (\\<Sum>k = 1..m. real k powr (x - 1)) \\<le> real m powr x / x\n 2. m = 1 \\<Longrightarrow>\n    (\\<Sum>k = 1..m. real k powr (x - 1)) \\<le> real m powr x / x\n 3. 1 < m \\<Longrightarrow>\n    (\\<Sum>k = 1..m. real k powr (x - 1)) \\<le> real m powr x / x", "finally"], ["proof (chain)\npicking this:\n  (\\<And>x y.\n      x \\<le> y \\<Longrightarrow> 1 + x \\<le> 1 + y) \\<Longrightarrow>\n  (\\<Sum>k = 1..m. real k powr (x - 1)) \\<le> real m powr x / x", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<And>x y.\n      x \\<le> y \\<Longrightarrow> 1 + x \\<le> 1 + y) \\<Longrightarrow>\n  (\\<Sum>k = 1..m. real k powr (x - 1)) \\<le> real m powr x / x\n\ngoal (1 subgoal):\n 1. (\\<Sum>k = 1..m. real k powr (x - 1)) \\<le> real m powr x / x", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>k = 1..m. real k powr (x - 1)) \\<le> real m powr x / x\n\ngoal (2 subgoals):\n 1. m = 0 \\<Longrightarrow>\n    (\\<Sum>k = 1..m. real k powr (x - 1)) \\<le> real m powr x / x\n 2. m = 1 \\<Longrightarrow>\n    (\\<Sum>k = 1..m. real k powr (x - 1)) \\<le> real m powr x / x", "qed (use assms in auto)"], ["proof (state)\nthis:\n  (\\<Sum>k = 1..m. real k powr (x - 1)) \\<le> real m powr x / x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma zeta_partial_sum_le':\n  fixes x :: real and m :: nat\n  assumes x: \"x > 0\" and m: \"m > 0\"\n  shows   \"(\\<Sum>n=1..m. real n powr (x - 1)) \\<le> m powr x * (1 / x + 1 / m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>n = 1..m. real n powr (x - 1))\n    \\<le> real m powr x * (1 / x + 1 / real m)", "proof (cases \"x > 1\")"], ["proof (state)\ngoal (2 subgoals):\n 1. 1 < x \\<Longrightarrow>\n    (\\<Sum>n = 1..m. real n powr (x - 1))\n    \\<le> real m powr x * (1 / x + 1 / real m)\n 2. \\<not> 1 < x \\<Longrightarrow>\n    (\\<Sum>n = 1..m. real n powr (x - 1))\n    \\<le> real m powr x * (1 / x + 1 / real m)", "case False"], ["proof (state)\nthis:\n  \\<not> 1 < x\n\ngoal (2 subgoals):\n 1. 1 < x \\<Longrightarrow>\n    (\\<Sum>n = 1..m. real n powr (x - 1))\n    \\<le> real m powr x * (1 / x + 1 / real m)\n 2. \\<not> 1 < x \\<Longrightarrow>\n    (\\<Sum>n = 1..m. real n powr (x - 1))\n    \\<le> real m powr x * (1 / x + 1 / real m)", "with assms"], ["proof (chain)\npicking this:\n  0 < x\n  0 < m\n  \\<not> 1 < x", "have \"(\\<Sum>n=1..m. real n powr (x - 1)) \\<le> m powr x / x\""], ["proof (prove)\nusing this:\n  0 < x\n  0 < m\n  \\<not> 1 < x\n\ngoal (1 subgoal):\n 1. (\\<Sum>n = 1..m. real n powr (x - 1)) \\<le> real m powr x / x", "by (intro zeta_partial_sum_le) auto"], ["proof (state)\nthis:\n  (\\<Sum>n = 1..m. real n powr (x - 1)) \\<le> real m powr x / x\n\ngoal (2 subgoals):\n 1. 1 < x \\<Longrightarrow>\n    (\\<Sum>n = 1..m. real n powr (x - 1))\n    \\<le> real m powr x * (1 / x + 1 / real m)\n 2. \\<not> 1 < x \\<Longrightarrow>\n    (\\<Sum>n = 1..m. real n powr (x - 1))\n    \\<le> real m powr x * (1 / x + 1 / real m)", "also"], ["proof (state)\nthis:\n  (\\<Sum>n = 1..m. real n powr (x - 1)) \\<le> real m powr x / x\n\ngoal (2 subgoals):\n 1. 1 < x \\<Longrightarrow>\n    (\\<Sum>n = 1..m. real n powr (x - 1))\n    \\<le> real m powr x * (1 / x + 1 / real m)\n 2. \\<not> 1 < x \\<Longrightarrow>\n    (\\<Sum>n = 1..m. real n powr (x - 1))\n    \\<le> real m powr x * (1 / x + 1 / real m)", "have \"\\<dots> \\<le> m powr x * (1 / x + 1 / m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real m powr x / x \\<le> real m powr x * (1 / x + 1 / real m)", "using assms"], ["proof (prove)\nusing this:\n  0 < x\n  0 < m\n\ngoal (1 subgoal):\n 1. real m powr x / x \\<le> real m powr x * (1 / x + 1 / real m)", "by (simp add: field_simps)"], ["proof (state)\nthis:\n  real m powr x / x \\<le> real m powr x * (1 / x + 1 / real m)\n\ngoal (2 subgoals):\n 1. 1 < x \\<Longrightarrow>\n    (\\<Sum>n = 1..m. real n powr (x - 1))\n    \\<le> real m powr x * (1 / x + 1 / real m)\n 2. \\<not> 1 < x \\<Longrightarrow>\n    (\\<Sum>n = 1..m. real n powr (x - 1))\n    \\<le> real m powr x * (1 / x + 1 / real m)", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>n = 1..m. real n powr (x - 1))\n  \\<le> real m powr x * (1 / x + 1 / real m)", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<Sum>n = 1..m. real n powr (x - 1))\n  \\<le> real m powr x * (1 / x + 1 / real m)\n\ngoal (1 subgoal):\n 1. (\\<Sum>n = 1..m. real n powr (x - 1))\n    \\<le> real m powr x * (1 / x + 1 / real m)", "."], ["proof (state)\nthis:\n  (\\<Sum>n = 1..m. real n powr (x - 1))\n  \\<le> real m powr x * (1 / x + 1 / real m)\n\ngoal (1 subgoal):\n 1. 1 < x \\<Longrightarrow>\n    (\\<Sum>n = 1..m. real n powr (x - 1))\n    \\<le> real m powr x * (1 / x + 1 / real m)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. 1 < x \\<Longrightarrow>\n    (\\<Sum>n = 1..m. real n powr (x - 1))\n    \\<le> real m powr x * (1 / x + 1 / real m)", "case True"], ["proof (state)\nthis:\n  1 < x\n\ngoal (1 subgoal):\n 1. 1 < x \\<Longrightarrow>\n    (\\<Sum>n = 1..m. real n powr (x - 1))\n    \\<le> real m powr x * (1 / x + 1 / real m)", "have \"(\\<Sum>n\\<in>{1..m}. n powr (x - 1)) = (\\<Sum>n\\<in>insert m {0..<m}. n powr (x - 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>n = 1..m. real n powr (x - 1)) =\n    (\\<Sum>n\\<in>insert m {0..<m}. real n powr (x - 1))", "by (intro sum.mono_neutral_left) auto"], ["proof (state)\nthis:\n  (\\<Sum>n = 1..m. real n powr (x - 1)) =\n  (\\<Sum>n\\<in>insert m {0..<m}. real n powr (x - 1))\n\ngoal (1 subgoal):\n 1. 1 < x \\<Longrightarrow>\n    (\\<Sum>n = 1..m. real n powr (x - 1))\n    \\<le> real m powr x * (1 / x + 1 / real m)", "also"], ["proof (state)\nthis:\n  (\\<Sum>n = 1..m. real n powr (x - 1)) =\n  (\\<Sum>n\\<in>insert m {0..<m}. real n powr (x - 1))\n\ngoal (1 subgoal):\n 1. 1 < x \\<Longrightarrow>\n    (\\<Sum>n = 1..m. real n powr (x - 1))\n    \\<le> real m powr x * (1 / x + 1 / real m)", "have \"\\<dots> = m powr (x - 1) + (\\<Sum>n\\<in>{0..<m}. n powr (x - 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>n\\<in>insert m {0..<m}. real n powr (x - 1)) =\n    real m powr (x - 1) + (\\<Sum>n = 0..<m. real n powr (x - 1))", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>n\\<in>insert m {0..<m}. real n powr (x - 1)) =\n  real m powr (x - 1) + (\\<Sum>n = 0..<m. real n powr (x - 1))\n\ngoal (1 subgoal):\n 1. 1 < x \\<Longrightarrow>\n    (\\<Sum>n = 1..m. real n powr (x - 1))\n    \\<le> real m powr x * (1 / x + 1 / real m)", "also"], ["proof (state)\nthis:\n  (\\<Sum>n\\<in>insert m {0..<m}. real n powr (x - 1)) =\n  real m powr (x - 1) + (\\<Sum>n = 0..<m. real n powr (x - 1))\n\ngoal (1 subgoal):\n 1. 1 < x \\<Longrightarrow>\n    (\\<Sum>n = 1..m. real n powr (x - 1))\n    \\<le> real m powr x * (1 / x + 1 / real m)", "have \"(\\<Sum>n\\<in>{0..<m}. n powr (x - 1)) \\<le> real m powr x / x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>n = 0..<m. real n powr (x - 1)) \\<le> real m powr x / x", "proof (rule has_integral_le)"], ["proof (state)\ngoal (3 subgoals):\n 1. (?f has_integral (\\<Sum>n = 0..<m. real n powr (x - 1))) ?S\n 2. (?g has_integral real m powr x / x) ?S\n 3. \\<And>x. x \\<in> ?S \\<Longrightarrow> ?f x \\<le> ?g x", "show \"((\\<lambda>t. (nat \\<lfloor>t\\<rfloor>) powr (x - 1)) has_integral (\\<Sum>n\\<in>{0..<m}. n powr (x - 1))) {real 0..m}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>t. real (nat \\<lfloor>t\\<rfloor>) powr (x - 1)) has_integral\n     (\\<Sum>n = 0..<m. real n powr (x - 1)))\n     {real 0..real m}", "using m"], ["proof (prove)\nusing this:\n  0 < m\n\ngoal (1 subgoal):\n 1. ((\\<lambda>t. real (nat \\<lfloor>t\\<rfloor>) powr (x - 1)) has_integral\n     (\\<Sum>n = 0..<m. real n powr (x - 1)))\n     {real 0..real m}", "by (intro nat_sum_has_integral_floor) auto"], ["proof (state)\nthis:\n  ((\\<lambda>t. real (nat \\<lfloor>t\\<rfloor>) powr (x - 1)) has_integral\n   (\\<Sum>n = 0..<m. real n powr (x - 1)))\n   {real 0..real m}\n\ngoal (2 subgoals):\n 1. (?g has_integral real m powr x / x) {real 0..real m}\n 2. \\<And>xa.\n       xa \\<in> {real 0..real m} \\<Longrightarrow>\n       real (nat \\<lfloor>xa\\<rfloor>) powr (x - 1) \\<le> ?g xa", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. (?g has_integral real m powr x / x) {real 0..real m}\n 2. \\<And>xa.\n       xa \\<in> {real 0..real m} \\<Longrightarrow>\n       real (nat \\<lfloor>xa\\<rfloor>) powr (x - 1) \\<le> ?g xa", "show \"((\\<lambda>t. t powr (x - 1)) has_integral (real m powr x / x)) {real 0..real m}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>t. t powr (x - 1)) has_integral real m powr x / x)\n     {real 0..real m}", "using has_integral_powr_from_0[of \"x - 1\"] x"], ["proof (prove)\nusing this:\n  \\<lbrakk>- 1 < x - 1; 0 \\<le> ?c\\<rbrakk>\n  \\<Longrightarrow> ((\\<lambda>xa. xa powr (x - 1)) has_integral\n                     ?c powr (x - 1 + 1) / (x - 1 + 1))\n                     {0..?c}\n  0 < x\n\ngoal (1 subgoal):\n 1. ((\\<lambda>t. t powr (x - 1)) has_integral real m powr x / x)\n     {real 0..real m}", "by auto"], ["proof (state)\nthis:\n  ((\\<lambda>t. t powr (x - 1)) has_integral real m powr x / x)\n   {real 0..real m}\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> {real 0..real m} \\<Longrightarrow>\n       real (nat \\<lfloor>xa\\<rfloor>) powr (x - 1) \\<le> xa powr (x - 1)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> {real 0..real m} \\<Longrightarrow>\n       real (nat \\<lfloor>xa\\<rfloor>) powr (x - 1) \\<le> xa powr (x - 1)", "fix t"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> {real 0..real m} \\<Longrightarrow>\n       real (nat \\<lfloor>xa\\<rfloor>) powr (x - 1) \\<le> xa powr (x - 1)", "assume \"t \\<in> {real 0..real m}\""], ["proof (state)\nthis:\n  t \\<in> {real 0..real m}\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> {real 0..real m} \\<Longrightarrow>\n       real (nat \\<lfloor>xa\\<rfloor>) powr (x - 1) \\<le> xa powr (x - 1)", "with \\<open>x > 1\\<close>"], ["proof (chain)\npicking this:\n  1 < x\n  t \\<in> {real 0..real m}", "show \"real (nat \\<lfloor>t\\<rfloor>) powr (x - 1) \\<le> t powr (x - 1)\""], ["proof (prove)\nusing this:\n  1 < x\n  t \\<in> {real 0..real m}\n\ngoal (1 subgoal):\n 1. real (nat \\<lfloor>t\\<rfloor>) powr (x - 1) \\<le> t powr (x - 1)", "by (cases \"t = 0\") (auto intro: powr_mono2)"], ["proof (state)\nthis:\n  real (nat \\<lfloor>t\\<rfloor>) powr (x - 1) \\<le> t powr (x - 1)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>n = 0..<m. real n powr (x - 1)) \\<le> real m powr x / x\n\ngoal (1 subgoal):\n 1. 1 < x \\<Longrightarrow>\n    (\\<Sum>n = 1..m. real n powr (x - 1))\n    \\<le> real m powr x * (1 / x + 1 / real m)", "also"], ["proof (state)\nthis:\n  (\\<Sum>n = 0..<m. real n powr (x - 1)) \\<le> real m powr x / x\n\ngoal (1 subgoal):\n 1. 1 < x \\<Longrightarrow>\n    (\\<Sum>n = 1..m. real n powr (x - 1))\n    \\<le> real m powr x * (1 / x + 1 / real m)", "have \"m powr (x - 1) + m powr x / x = m powr x * (1 / x + 1 / m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real m powr (x - 1) + real m powr x / x =\n    real m powr x * (1 / x + 1 / real m)", "using m x"], ["proof (prove)\nusing this:\n  0 < m\n  0 < x\n\ngoal (1 subgoal):\n 1. real m powr (x - 1) + real m powr x / x =\n    real m powr x * (1 / x + 1 / real m)", "by (simp add: powr_diff field_simps)"], ["proof (state)\nthis:\n  real m powr (x - 1) + real m powr x / x =\n  real m powr x * (1 / x + 1 / real m)\n\ngoal (1 subgoal):\n 1. 1 < x \\<Longrightarrow>\n    (\\<Sum>n = 1..m. real n powr (x - 1))\n    \\<le> real m powr x * (1 / x + 1 / real m)", "finally"], ["proof (chain)\npicking this:\n  (\\<And>xa y.\n      xa \\<le> y \\<Longrightarrow>\n      real m powr (x - 1) + xa\n      \\<le> real m powr (x - 1) + y) \\<Longrightarrow>\n  (\\<Sum>n = 1..m. real n powr (x - 1))\n  \\<le> real m powr x * (1 / x + 1 / real m)", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<And>xa y.\n      xa \\<le> y \\<Longrightarrow>\n      real m powr (x - 1) + xa\n      \\<le> real m powr (x - 1) + y) \\<Longrightarrow>\n  (\\<Sum>n = 1..m. real n powr (x - 1))\n  \\<le> real m powr x * (1 / x + 1 / real m)\n\ngoal (1 subgoal):\n 1. (\\<Sum>n = 1..m. real n powr (x - 1))\n    \\<le> real m powr x * (1 / x + 1 / real m)", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>n = 1..m. real n powr (x - 1))\n  \\<le> real m powr x * (1 / x + 1 / real m)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma natfun_bigo_1E:\n  assumes \"(f :: nat \\<Rightarrow> _) \\<in> O(\\<lambda>_. 1)\"\n  obtains C where \"C \\<ge> lb\" \"\\<And>n. norm (f n) \\<le> C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>C.\n        \\<lbrakk>lb \\<le> C; \\<And>n. norm (f n) \\<le> C\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>C.\n        \\<lbrakk>lb \\<le> C; \\<And>n. norm (f n) \\<le> C\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from assms"], ["proof (chain)\npicking this:\n  f \\<in> O(\\<lambda>_. 1::'a)", "obtain C N where \"\\<forall>n\\<ge>N. norm (f n) \\<le> C\""], ["proof (prove)\nusing this:\n  f \\<in> O(\\<lambda>_. 1::'a)\n\ngoal (1 subgoal):\n 1. (\\<And>N C.\n        \\<forall>n\\<ge>N. norm (f n) \\<le> C \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (auto elim!: landau_o.bigE simp: eventually_at_top_linorder)"], ["proof (state)\nthis:\n  \\<forall>n\\<ge>N. norm (f n) \\<le> C\n\ngoal (1 subgoal):\n 1. (\\<And>C.\n        \\<lbrakk>lb \\<le> C; \\<And>n. norm (f n) \\<le> C\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "hence *: \"norm (f n) \\<le> Max ({C, lb} \\<union> (norm ` f ` {..<N}))\" for n"], ["proof (prove)\nusing this:\n  \\<forall>n\\<ge>N. norm (f n) \\<le> C\n\ngoal (1 subgoal):\n 1. norm (f n) \\<le> Max ({C, lb} \\<union> norm ` f ` {..<N})", "by (cases \"n \\<ge> N\") (subst Max_ge_iff; force simp: image_iff)+"], ["proof (state)\nthis:\n  norm (f ?n) \\<le> Max ({C, lb} \\<union> norm ` f ` {..<N})\n\ngoal (1 subgoal):\n 1. (\\<And>C.\n        \\<lbrakk>lb \\<le> C; \\<And>n. norm (f n) \\<le> C\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  norm (f ?n) \\<le> Max ({C, lb} \\<union> norm ` f ` {..<N})\n\ngoal (1 subgoal):\n 1. (\\<And>C.\n        \\<lbrakk>lb \\<le> C; \\<And>n. norm (f n) \\<le> C\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"Max ({C, lb} \\<union> (norm ` f ` {..<N})) \\<ge> lb\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lb \\<le> Max ({C, lb} \\<union> norm ` f ` {..<N})", "by (intro Max.coboundedI) auto"], ["proof (state)\nthis:\n  lb \\<le> Max ({C, lb} \\<union> norm ` f ` {..<N})\n\ngoal (1 subgoal):\n 1. (\\<And>C.\n        \\<lbrakk>lb \\<le> C; \\<And>n. norm (f n) \\<le> C\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "ultimately"], ["proof (chain)\npicking this:\n  norm (f ?n) \\<le> Max ({C, lb} \\<union> norm ` f ` {..<N})\n  lb \\<le> Max ({C, lb} \\<union> norm ` f ` {..<N})", "show ?thesis"], ["proof (prove)\nusing this:\n  norm (f ?n) \\<le> Max ({C, lb} \\<union> norm ` f ` {..<N})\n  lb \\<le> Max ({C, lb} \\<union> norm ` f ` {..<N})\n\ngoal (1 subgoal):\n 1. thesis", "using that"], ["proof (prove)\nusing this:\n  norm (f ?n) \\<le> Max ({C, lb} \\<union> norm ` f ` {..<N})\n  lb \\<le> Max ({C, lb} \\<union> norm ` f ` {..<N})\n  \\<lbrakk>lb \\<le> ?C; \\<And>n. norm (f n) \\<le> ?C\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "by blast"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma natfun_bigo_iff_Bseq: \"f \\<in> O(\\<lambda>_. 1) \\<longleftrightarrow> Bseq f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f \\<in> O(\\<lambda>_. 1::'a)) = Bseq f", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. f \\<in> O(\\<lambda>_. 1::'a) \\<Longrightarrow> Bseq f\n 2. Bseq f \\<Longrightarrow> f \\<in> O(\\<lambda>_. 1::'a)", "assume \"Bseq f\""], ["proof (state)\nthis:\n  Bseq f\n\ngoal (2 subgoals):\n 1. f \\<in> O(\\<lambda>_. 1::'a) \\<Longrightarrow> Bseq f\n 2. Bseq f \\<Longrightarrow> f \\<in> O(\\<lambda>_. 1::'a)", "then"], ["proof (chain)\npicking this:\n  Bseq f", "obtain C where \"C > 0\" \"\\<And>n. norm (f n) \\<le> C\""], ["proof (prove)\nusing this:\n  Bseq f\n\ngoal (1 subgoal):\n 1. (\\<And>C.\n        \\<lbrakk>0 < C; \\<And>n. norm (f n) \\<le> C\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: Bseq_def)"], ["proof (state)\nthis:\n  0 < C\n  norm (f ?n) \\<le> C\n\ngoal (2 subgoals):\n 1. f \\<in> O(\\<lambda>_. 1::'a) \\<Longrightarrow> Bseq f\n 2. Bseq f \\<Longrightarrow> f \\<in> O(\\<lambda>_. 1::'a)", "thus \"f \\<in> O(\\<lambda>_. 1)\""], ["proof (prove)\nusing this:\n  0 < C\n  norm (f ?n) \\<le> C\n\ngoal (1 subgoal):\n 1. f \\<in> O(\\<lambda>_. 1::'a)", "by (intro bigoI[of _ C]) auto"], ["proof (state)\nthis:\n  f \\<in> O(\\<lambda>_. 1::'a)\n\ngoal (1 subgoal):\n 1. f \\<in> O(\\<lambda>_. 1::'a) \\<Longrightarrow> Bseq f", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. f \\<in> O(\\<lambda>_. 1::'a) \\<Longrightarrow> Bseq f", "assume \"f \\<in> O(\\<lambda>_. 1)\""], ["proof (state)\nthis:\n  f \\<in> O(\\<lambda>_. 1::'a)\n\ngoal (1 subgoal):\n 1. f \\<in> O(\\<lambda>_. 1::'a) \\<Longrightarrow> Bseq f", "from natfun_bigo_1E[OF this, where lb = 1]"], ["proof (chain)\npicking this:\n  (\\<And>C.\n      \\<lbrakk>1 \\<le> C; \\<And>n. norm (f n) \\<le> C\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis", "obtain C where \"C \\<ge> 1\" \"\\<And>n. norm (f n) \\<le> C\""], ["proof (prove)\nusing this:\n  (\\<And>C.\n      \\<lbrakk>1 \\<le> C; \\<And>n. norm (f n) \\<le> C\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>C.\n        \\<lbrakk>1 \\<le> C; \\<And>n. norm (f n) \\<le> C\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  1 \\<le> C\n  norm (f ?n) \\<le> C\n\ngoal (1 subgoal):\n 1. f \\<in> O(\\<lambda>_. 1::'a) \\<Longrightarrow> Bseq f", "thus \"Bseq f\""], ["proof (prove)\nusing this:\n  1 \\<le> C\n  norm (f ?n) \\<le> C\n\ngoal (1 subgoal):\n 1. Bseq f", "by (auto simp: Bseq_def intro!: exI[of _ C])"], ["proof (state)\nthis:\n  Bseq f\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma enn_decreasing_sum_le_set_nn_integral:\n  fixes f :: \"real \\<Rightarrow> ennreal\"\n  assumes decreasing: \"\\<And>x y. 0 \\<le> x \\<Longrightarrow> x \\<le> y \\<Longrightarrow> f y \\<le> f x\"\n  shows \"(\\<Sum>n. f (real (Suc n))) \\<le> set_nn_integral lborel {0..} f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>n. f (real (Suc n))) \\<le> set_nn_integral lborel {0..} f", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>n. f (real (Suc n))) \\<le> set_nn_integral lborel {0..} f", "have \"(\\<Sum>n. (f (Suc n))) =\n          (\\<Sum>n. \\<integral>\\<^sup>+x\\<in>{real n<..real (Suc n)}. (f (Suc n)) \\<partial>lborel)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>n. f (real (Suc n))) =\n    (\\<Sum>n.\n        \\<integral>\\<^sup>+x\\<in>{real n<..real (Suc n)}. f (real (Suc n))\n        \\<partial>lborel)", "by (subst nn_integral_cmult_indicator) auto"], ["proof (state)\nthis:\n  (\\<Sum>n. f (real (Suc n))) =\n  (\\<Sum>n.\n      \\<integral>\\<^sup>+x\\<in>{real n<..real (Suc n)}. f (real (Suc n))\n      \\<partial>lborel)\n\ngoal (1 subgoal):\n 1. (\\<Sum>n. f (real (Suc n))) \\<le> set_nn_integral lborel {0..} f", "also"], ["proof (state)\nthis:\n  (\\<Sum>n. f (real (Suc n))) =\n  (\\<Sum>n.\n      \\<integral>\\<^sup>+x\\<in>{real n<..real (Suc n)}. f (real (Suc n))\n      \\<partial>lborel)\n\ngoal (1 subgoal):\n 1. (\\<Sum>n. f (real (Suc n))) \\<le> set_nn_integral lborel {0..} f", "have \"nat \\<lceil>x\\<rceil> = Suc n\" if \"x \\<in> {real n<..real (Suc n)}\" for x n"], ["proof (prove)\ngoal (1 subgoal):\n 1. nat \\<lceil>x\\<rceil> = Suc n", "using that"], ["proof (prove)\nusing this:\n  x \\<in> {real n<..real (Suc n)}\n\ngoal (1 subgoal):\n 1. nat \\<lceil>x\\<rceil> = Suc n", "by (auto simp: nat_eq_iff ceiling_eq_iff)"], ["proof (state)\nthis:\n  ?x \\<in> {real ?n<..real (Suc ?n)} \\<Longrightarrow>\n  nat \\<lceil>?x\\<rceil> = Suc ?n\n\ngoal (1 subgoal):\n 1. (\\<Sum>n. f (real (Suc n))) \\<le> set_nn_integral lborel {0..} f", "hence \"(\\<Sum>n. \\<integral>\\<^sup>+x\\<in>{real n<..real (Suc n)}. (f (Suc n)) \\<partial>lborel) =\n          (\\<Sum>n. \\<integral>\\<^sup>+x\\<in>{real n<..real (Suc n)}. (f (real (nat \\<lceil>x\\<rceil>))) \\<partial>lborel)\""], ["proof (prove)\nusing this:\n  ?x \\<in> {real ?n<..real (Suc ?n)} \\<Longrightarrow>\n  nat \\<lceil>?x\\<rceil> = Suc ?n\n\ngoal (1 subgoal):\n 1. (\\<Sum>n.\n        \\<integral>\\<^sup>+x\\<in>{real n<..real (Suc n)}. f (real (Suc n))\n        \\<partial>lborel) =\n    (\\<Sum>n.\n        \\<integral>\\<^sup>+x\\<in>{real n<..real (Suc n)}.\n                           f (real (nat \\<lceil>x\\<rceil>))\n        \\<partial>lborel)", "by (intro suminf_cong nn_integral_cong) (auto simp: indicator_def)"], ["proof (state)\nthis:\n  (\\<Sum>n.\n      \\<integral>\\<^sup>+x\\<in>{real n<..real (Suc n)}. f (real (Suc n))\n      \\<partial>lborel) =\n  (\\<Sum>n.\n      \\<integral>\\<^sup>+x\\<in>{real n<..real (Suc n)}.\n                         f (real (nat \\<lceil>x\\<rceil>))\n      \\<partial>lborel)\n\ngoal (1 subgoal):\n 1. (\\<Sum>n. f (real (Suc n))) \\<le> set_nn_integral lborel {0..} f", "also"], ["proof (state)\nthis:\n  (\\<Sum>n.\n      \\<integral>\\<^sup>+x\\<in>{real n<..real (Suc n)}. f (real (Suc n))\n      \\<partial>lborel) =\n  (\\<Sum>n.\n      \\<integral>\\<^sup>+x\\<in>{real n<..real (Suc n)}.\n                         f (real (nat \\<lceil>x\\<rceil>))\n      \\<partial>lborel)\n\ngoal (1 subgoal):\n 1. (\\<Sum>n. f (real (Suc n))) \\<le> set_nn_integral lborel {0..} f", "have \"\\<dots> = (\\<integral>\\<^sup>+x\\<in>(\\<Union>i. {real i<..real (Suc i)}). (f (nat \\<lceil>x::real\\<rceil>)) \\<partial>lborel)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>n.\n        \\<integral>\\<^sup>+x\\<in>{real n<..real (Suc n)}.\n                           f (real (nat \\<lceil>x\\<rceil>))\n        \\<partial>lborel) =\n    \\<integral>\\<^sup>+x\\<in>(\\<Union>i. {real i<..real (Suc i)}).\n                       f (real (nat \\<lceil>x\\<rceil>))\n    \\<partial>lborel", "by (subst nn_integral_disjoint_family)\n       (auto simp: disjoint_family_on_def)"], ["proof (state)\nthis:\n  (\\<Sum>n.\n      \\<integral>\\<^sup>+x\\<in>{real n<..real (Suc n)}.\n                         f (real (nat \\<lceil>x\\<rceil>))\n      \\<partial>lborel) =\n  \\<integral>\\<^sup>+x\\<in>(\\<Union>i. {real i<..real (Suc i)}).\n                     f (real (nat \\<lceil>x\\<rceil>))\n  \\<partial>lborel\n\ngoal (1 subgoal):\n 1. (\\<Sum>n. f (real (Suc n))) \\<le> set_nn_integral lborel {0..} f", "also"], ["proof (state)\nthis:\n  (\\<Sum>n.\n      \\<integral>\\<^sup>+x\\<in>{real n<..real (Suc n)}.\n                         f (real (nat \\<lceil>x\\<rceil>))\n      \\<partial>lborel) =\n  \\<integral>\\<^sup>+x\\<in>(\\<Union>i. {real i<..real (Suc i)}).\n                     f (real (nat \\<lceil>x\\<rceil>))\n  \\<partial>lborel\n\ngoal (1 subgoal):\n 1. (\\<Sum>n. f (real (Suc n))) \\<le> set_nn_integral lborel {0..} f", "have \"\\<dots> \\<le> (\\<integral>\\<^sup>+x\\<in>{0..}. (f x) \\<partial>lborel)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+x\\<in>(\\<Union>i. {real i<..real (Suc i)}).\n                       f (real (nat \\<lceil>x\\<rceil>))\n    \\<partial>lborel\n    \\<le> set_nn_integral lborel {0..} f", "by (intro nn_integral_mono) (auto simp: indicator_def intro!: decreasing)"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+x\\<in>(\\<Union>i. {real i<..real (Suc i)}).\n                     f (real (nat \\<lceil>x\\<rceil>))\n  \\<partial>lborel\n  \\<le> set_nn_integral lborel {0..} f\n\ngoal (1 subgoal):\n 1. (\\<Sum>n. f (real (Suc n))) \\<le> set_nn_integral lborel {0..} f", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>n. f (real (Suc n))) \\<le> set_nn_integral lborel {0..} f", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<Sum>n. f (real (Suc n))) \\<le> set_nn_integral lborel {0..} f\n\ngoal (1 subgoal):\n 1. (\\<Sum>n. f (real (Suc n))) \\<le> set_nn_integral lborel {0..} f", "."], ["proof (state)\nthis:\n  (\\<Sum>n. f (real (Suc n))) \\<le> set_nn_integral lborel {0..} f\n\ngoal:\nNo subgoals!", "qed"], ["", "(* TODO replace version in library *)"], ["", "lemma nn_integral_has_integral_lebesgue:\n  fixes f :: \"'a::euclidean_space \\<Rightarrow> real\"\n  assumes nonneg: \"\\<And>x. x \\<in> \\<Omega> \\<Longrightarrow> 0 \\<le> f x\" and I: \"(f has_integral I) \\<Omega>\"\n  shows \"integral\\<^sup>N lborel (\\<lambda>x. indicator \\<Omega> x * f x) = I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ x. ennreal (indicat_real \\<Omega> x * f x)\n                       \\<partial>lborel =\n    ennreal I", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ x. ennreal (indicat_real \\<Omega> x * f x)\n                       \\<partial>lborel =\n    ennreal I", "from I"], ["proof (chain)\npicking this:\n  (f has_integral I) \\<Omega>", "have \"(\\<lambda>x. indicator \\<Omega> x *\\<^sub>R f x) \\<in> lebesgue \\<rightarrow>\\<^sub>M borel\""], ["proof (prove)\nusing this:\n  (f has_integral I) \\<Omega>\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. indicat_real \\<Omega> x *\\<^sub>R f x)\n    \\<in> borel_measurable lebesgue", "by (rule has_integral_implies_lebesgue_measurable)"], ["proof (state)\nthis:\n  (\\<lambda>x. indicat_real \\<Omega> x *\\<^sub>R f x)\n  \\<in> borel_measurable lebesgue\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ x. ennreal (indicat_real \\<Omega> x * f x)\n                       \\<partial>lborel =\n    ennreal I", "then"], ["proof (chain)\npicking this:\n  (\\<lambda>x. indicat_real \\<Omega> x *\\<^sub>R f x)\n  \\<in> borel_measurable lebesgue", "obtain f' :: \"'a \\<Rightarrow> real\"\n    where [measurable]: \"f' \\<in> borel \\<rightarrow>\\<^sub>M borel\" and eq: \"AE x in lborel. indicator \\<Omega> x * f x = f' x\""], ["proof (prove)\nusing this:\n  (\\<lambda>x. indicat_real \\<Omega> x *\\<^sub>R f x)\n  \\<in> borel_measurable lebesgue\n\ngoal (1 subgoal):\n 1. (\\<And>f'.\n        \\<lbrakk>f' \\<in> borel_measurable borel;\n         AE x in lborel. indicat_real \\<Omega> x * f x = f' x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto dest: completion_ex_borel_measurable_real)"], ["proof (state)\nthis:\n  f' \\<in> borel_measurable borel\n  AE x in lborel. indicat_real \\<Omega> x * f x = f' x\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ x. ennreal (indicat_real \\<Omega> x * f x)\n                       \\<partial>lborel =\n    ennreal I", "from I"], ["proof (chain)\npicking this:\n  (f has_integral I) \\<Omega>", "have \"((\\<lambda>x. abs (indicator \\<Omega> x * f x)) has_integral I) UNIV\""], ["proof (prove)\nusing this:\n  (f has_integral I) \\<Omega>\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. \\<bar>indicat_real \\<Omega> x * f x\\<bar>) has_integral I)\n     UNIV", "using nonneg"], ["proof (prove)\nusing this:\n  (f has_integral I) \\<Omega>\n  ?x \\<in> \\<Omega> \\<Longrightarrow> 0 \\<le> f ?x\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. \\<bar>indicat_real \\<Omega> x * f x\\<bar>) has_integral I)\n     UNIV", "by (simp add: indicator_def if_distrib[of \"\\<lambda>x. x * f y\" for y] cong: if_cong)"], ["proof (state)\nthis:\n  ((\\<lambda>x. \\<bar>indicat_real \\<Omega> x * f x\\<bar>) has_integral I)\n   UNIV\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ x. ennreal (indicat_real \\<Omega> x * f x)\n                       \\<partial>lborel =\n    ennreal I", "also"], ["proof (state)\nthis:\n  ((\\<lambda>x. \\<bar>indicat_real \\<Omega> x * f x\\<bar>) has_integral I)\n   UNIV\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ x. ennreal (indicat_real \\<Omega> x * f x)\n                       \\<partial>lborel =\n    ennreal I", "have \"((\\<lambda>x. abs (indicator \\<Omega> x * f x)) has_integral I) UNIV \\<longleftrightarrow> ((\\<lambda>x. abs (f' x)) has_integral I) UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x. \\<bar>indicat_real \\<Omega> x * f x\\<bar>) has_integral I)\n     UNIV =\n    ((\\<lambda>x. \\<bar>f' x\\<bar>) has_integral I) UNIV", "using eq"], ["proof (prove)\nusing this:\n  AE x in lborel. indicat_real \\<Omega> x * f x = f' x\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. \\<bar>indicat_real \\<Omega> x * f x\\<bar>) has_integral I)\n     UNIV =\n    ((\\<lambda>x. \\<bar>f' x\\<bar>) has_integral I) UNIV", "by (intro has_integral_AE) auto"], ["proof (state)\nthis:\n  ((\\<lambda>x. \\<bar>indicat_real \\<Omega> x * f x\\<bar>) has_integral I)\n   UNIV =\n  ((\\<lambda>x. \\<bar>f' x\\<bar>) has_integral I) UNIV\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ x. ennreal (indicat_real \\<Omega> x * f x)\n                       \\<partial>lborel =\n    ennreal I", "finally"], ["proof (chain)\npicking this:\n  ((\\<lambda>x. \\<bar>f' x\\<bar>) has_integral I) UNIV", "have \"integral\\<^sup>N lborel (\\<lambda>x. abs (f' x)) = I\""], ["proof (prove)\nusing this:\n  ((\\<lambda>x. \\<bar>f' x\\<bar>) has_integral I) UNIV\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ x. ennreal \\<bar>f' x\\<bar> \\<partial>lborel =\n    ennreal I", "by (rule nn_integral_has_integral_lborel[rotated 2]) auto"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ x. ennreal \\<bar>f' x\\<bar> \\<partial>lborel =\n  ennreal I\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ x. ennreal (indicat_real \\<Omega> x * f x)\n                       \\<partial>lborel =\n    ennreal I", "also"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ x. ennreal \\<bar>f' x\\<bar> \\<partial>lborel =\n  ennreal I\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ x. ennreal (indicat_real \\<Omega> x * f x)\n                       \\<partial>lborel =\n    ennreal I", "have \"integral\\<^sup>N lborel (\\<lambda>x. abs (f' x)) = integral\\<^sup>N lborel (\\<lambda>x. abs (indicator \\<Omega> x * f x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ x. ennreal \\<bar>f' x\\<bar> \\<partial>lborel =\n    \\<integral>\\<^sup>+ x. ennreal \\<bar>indicat_real \\<Omega> x * f x\\<bar>\n                       \\<partial>lborel", "using eq"], ["proof (prove)\nusing this:\n  AE x in lborel. indicat_real \\<Omega> x * f x = f' x\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ x. ennreal \\<bar>f' x\\<bar> \\<partial>lborel =\n    \\<integral>\\<^sup>+ x. ennreal \\<bar>indicat_real \\<Omega> x * f x\\<bar>\n                       \\<partial>lborel", "by (intro nn_integral_cong_AE) auto"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ x. ennreal \\<bar>f' x\\<bar> \\<partial>lborel =\n  \\<integral>\\<^sup>+ x. ennreal \\<bar>indicat_real \\<Omega> x * f x\\<bar>\n                     \\<partial>lborel\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ x. ennreal (indicat_real \\<Omega> x * f x)\n                       \\<partial>lborel =\n    ennreal I", "also"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ x. ennreal \\<bar>f' x\\<bar> \\<partial>lborel =\n  \\<integral>\\<^sup>+ x. ennreal \\<bar>indicat_real \\<Omega> x * f x\\<bar>\n                     \\<partial>lborel\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ x. ennreal (indicat_real \\<Omega> x * f x)\n                       \\<partial>lborel =\n    ennreal I", "have \"(\\<lambda>x. abs (indicator \\<Omega> x * f x)) = (\\<lambda>x. indicator \\<Omega> x * f x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. \\<bar>indicat_real \\<Omega> x * f x\\<bar>) =\n    (\\<lambda>x. indicat_real \\<Omega> x * f x)", "using nonneg"], ["proof (prove)\nusing this:\n  ?x \\<in> \\<Omega> \\<Longrightarrow> 0 \\<le> f ?x\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. \\<bar>indicat_real \\<Omega> x * f x\\<bar>) =\n    (\\<lambda>x. indicat_real \\<Omega> x * f x)", "by (auto simp: indicator_def fun_eq_iff)"], ["proof (state)\nthis:\n  (\\<lambda>x. \\<bar>indicat_real \\<Omega> x * f x\\<bar>) =\n  (\\<lambda>x. indicat_real \\<Omega> x * f x)\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ x. ennreal (indicat_real \\<Omega> x * f x)\n                       \\<partial>lborel =\n    ennreal I", "finally"], ["proof (chain)\npicking this:\n  \\<integral>\\<^sup>+ x. ennreal (indicat_real \\<Omega> x * f x)\n                     \\<partial>lborel =\n  ennreal I", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<integral>\\<^sup>+ x. ennreal (indicat_real \\<Omega> x * f x)\n                     \\<partial>lborel =\n  ennreal I\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ x. ennreal (indicat_real \\<Omega> x * f x)\n                       \\<partial>lborel =\n    ennreal I", "."], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ x. ennreal (indicat_real \\<Omega> x * f x)\n                     \\<partial>lborel =\n  ennreal I\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma decreasing_sum_le_integral:\n  fixes f :: \"real \\<Rightarrow> real\"\n  assumes nonneg: \"\\<And>x. x \\<ge> 0 \\<Longrightarrow> f x \\<ge> 0\"\n  assumes decreasing: \"\\<And>x y. 0 \\<le> x \\<Longrightarrow> x \\<le> y \\<Longrightarrow> f y \\<le> f x\"\n  assumes integral: \"(f has_integral I) {0..}\"\n  shows   \"summable (\\<lambda>i. f (real (Suc i)))\" and \"suminf (\\<lambda>i. f (real (Suc i))) \\<le> I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. summable (\\<lambda>i. f (real (Suc i))) &&&\n    (\\<Sum>i. f (real (Suc i))) \\<le> I", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. summable (\\<lambda>i. f (real (Suc i)))\n 2. (\\<Sum>i. f (real (Suc i))) \\<le> I", "have [simp]: \"I \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> I", "by (intro has_integral_nonneg[OF integral] nonneg) auto"], ["proof (state)\nthis:\n  0 \\<le> I\n\ngoal (2 subgoals):\n 1. summable (\\<lambda>i. f (real (Suc i)))\n 2. (\\<Sum>i. f (real (Suc i))) \\<le> I", "have \"(\\<Sum>n. ennreal (f (Suc n))) =\n          (\\<Sum>n. \\<integral>\\<^sup>+x\\<in>{real n<..real (Suc n)}. ennreal (f (Suc n)) \\<partial>lborel)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>n. ennreal (f (real (Suc n)))) =\n    (\\<Sum>n.\n        \\<integral>\\<^sup>+x\\<in>{real n<..real (Suc n)}.\n                           ennreal (f (real (Suc n)))\n        \\<partial>lborel)", "by (subst nn_integral_cmult_indicator) auto"], ["proof (state)\nthis:\n  (\\<Sum>n. ennreal (f (real (Suc n)))) =\n  (\\<Sum>n.\n      \\<integral>\\<^sup>+x\\<in>{real n<..real (Suc n)}.\n                         ennreal (f (real (Suc n)))\n      \\<partial>lborel)\n\ngoal (2 subgoals):\n 1. summable (\\<lambda>i. f (real (Suc i)))\n 2. (\\<Sum>i. f (real (Suc i))) \\<le> I", "also"], ["proof (state)\nthis:\n  (\\<Sum>n. ennreal (f (real (Suc n)))) =\n  (\\<Sum>n.\n      \\<integral>\\<^sup>+x\\<in>{real n<..real (Suc n)}.\n                         ennreal (f (real (Suc n)))\n      \\<partial>lborel)\n\ngoal (2 subgoals):\n 1. summable (\\<lambda>i. f (real (Suc i)))\n 2. (\\<Sum>i. f (real (Suc i))) \\<le> I", "have \"nat \\<lceil>x\\<rceil> = Suc n\" if \"x \\<in> {real n<..real (Suc n)}\" for x n"], ["proof (prove)\ngoal (1 subgoal):\n 1. nat \\<lceil>x\\<rceil> = Suc n", "using that"], ["proof (prove)\nusing this:\n  x \\<in> {real n<..real (Suc n)}\n\ngoal (1 subgoal):\n 1. nat \\<lceil>x\\<rceil> = Suc n", "by (auto simp: nat_eq_iff ceiling_eq_iff)"], ["proof (state)\nthis:\n  ?x \\<in> {real ?n<..real (Suc ?n)} \\<Longrightarrow>\n  nat \\<lceil>?x\\<rceil> = Suc ?n\n\ngoal (2 subgoals):\n 1. summable (\\<lambda>i. f (real (Suc i)))\n 2. (\\<Sum>i. f (real (Suc i))) \\<le> I", "hence \"(\\<Sum>n. \\<integral>\\<^sup>+x\\<in>{real n<..real (Suc n)}. ennreal (f (Suc n)) \\<partial>lborel) =\n          (\\<Sum>n. \\<integral>\\<^sup>+x\\<in>{real n<..real (Suc n)}. ennreal (f (real (nat \\<lceil>x\\<rceil>))) \\<partial>lborel)\""], ["proof (prove)\nusing this:\n  ?x \\<in> {real ?n<..real (Suc ?n)} \\<Longrightarrow>\n  nat \\<lceil>?x\\<rceil> = Suc ?n\n\ngoal (1 subgoal):\n 1. (\\<Sum>n.\n        \\<integral>\\<^sup>+x\\<in>{real n<..real (Suc n)}.\n                           ennreal (f (real (Suc n)))\n        \\<partial>lborel) =\n    (\\<Sum>n.\n        \\<integral>\\<^sup>+x\\<in>{real n<..real (Suc n)}.\n                           ennreal (f (real (nat \\<lceil>x\\<rceil>)))\n        \\<partial>lborel)", "by (intro suminf_cong nn_integral_cong) (auto simp: indicator_def)"], ["proof (state)\nthis:\n  (\\<Sum>n.\n      \\<integral>\\<^sup>+x\\<in>{real n<..real (Suc n)}.\n                         ennreal (f (real (Suc n)))\n      \\<partial>lborel) =\n  (\\<Sum>n.\n      \\<integral>\\<^sup>+x\\<in>{real n<..real (Suc n)}.\n                         ennreal (f (real (nat \\<lceil>x\\<rceil>)))\n      \\<partial>lborel)\n\ngoal (2 subgoals):\n 1. summable (\\<lambda>i. f (real (Suc i)))\n 2. (\\<Sum>i. f (real (Suc i))) \\<le> I", "also"], ["proof (state)\nthis:\n  (\\<Sum>n.\n      \\<integral>\\<^sup>+x\\<in>{real n<..real (Suc n)}.\n                         ennreal (f (real (Suc n)))\n      \\<partial>lborel) =\n  (\\<Sum>n.\n      \\<integral>\\<^sup>+x\\<in>{real n<..real (Suc n)}.\n                         ennreal (f (real (nat \\<lceil>x\\<rceil>)))\n      \\<partial>lborel)\n\ngoal (2 subgoals):\n 1. summable (\\<lambda>i. f (real (Suc i)))\n 2. (\\<Sum>i. f (real (Suc i))) \\<le> I", "have \"\\<dots> = (\\<integral>\\<^sup>+x\\<in>(\\<Union>i. {real i<..real (Suc i)}). ennreal (f (nat \\<lceil>x::real\\<rceil>)) \\<partial>lborel)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>n.\n        \\<integral>\\<^sup>+x\\<in>{real n<..real (Suc n)}.\n                           ennreal (f (real (nat \\<lceil>x\\<rceil>)))\n        \\<partial>lborel) =\n    \\<integral>\\<^sup>+x\\<in>(\\<Union>i. {real i<..real (Suc i)}).\n                       ennreal (f (real (nat \\<lceil>x\\<rceil>)))\n    \\<partial>lborel", "by (subst nn_integral_disjoint_family)\n       (auto simp: disjoint_family_on_def intro!: measurable_completion)"], ["proof (state)\nthis:\n  (\\<Sum>n.\n      \\<integral>\\<^sup>+x\\<in>{real n<..real (Suc n)}.\n                         ennreal (f (real (nat \\<lceil>x\\<rceil>)))\n      \\<partial>lborel) =\n  \\<integral>\\<^sup>+x\\<in>(\\<Union>i. {real i<..real (Suc i)}).\n                     ennreal (f (real (nat \\<lceil>x\\<rceil>)))\n  \\<partial>lborel\n\ngoal (2 subgoals):\n 1. summable (\\<lambda>i. f (real (Suc i)))\n 2. (\\<Sum>i. f (real (Suc i))) \\<le> I", "also"], ["proof (state)\nthis:\n  (\\<Sum>n.\n      \\<integral>\\<^sup>+x\\<in>{real n<..real (Suc n)}.\n                         ennreal (f (real (nat \\<lceil>x\\<rceil>)))\n      \\<partial>lborel) =\n  \\<integral>\\<^sup>+x\\<in>(\\<Union>i. {real i<..real (Suc i)}).\n                     ennreal (f (real (nat \\<lceil>x\\<rceil>)))\n  \\<partial>lborel\n\ngoal (2 subgoals):\n 1. summable (\\<lambda>i. f (real (Suc i)))\n 2. (\\<Sum>i. f (real (Suc i))) \\<le> I", "have \"\\<dots> \\<le> (\\<integral>\\<^sup>+x\\<in>{0..}. ennreal (f x) \\<partial>lborel)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+x\\<in>(\\<Union>i. {real i<..real (Suc i)}).\n                       ennreal (f (real (nat \\<lceil>x\\<rceil>)))\n    \\<partial>lborel\n    \\<le> \\<integral>\\<^sup>+x\\<in>{0..}. ennreal (f x)\\<partial>lborel", "by (intro nn_integral_mono) (auto simp: indicator_def nonneg intro!: decreasing)"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+x\\<in>(\\<Union>i. {real i<..real (Suc i)}).\n                     ennreal (f (real (nat \\<lceil>x\\<rceil>)))\n  \\<partial>lborel\n  \\<le> \\<integral>\\<^sup>+x\\<in>{0..}. ennreal (f x)\\<partial>lborel\n\ngoal (2 subgoals):\n 1. summable (\\<lambda>i. f (real (Suc i)))\n 2. (\\<Sum>i. f (real (Suc i))) \\<le> I", "also"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+x\\<in>(\\<Union>i. {real i<..real (Suc i)}).\n                     ennreal (f (real (nat \\<lceil>x\\<rceil>)))\n  \\<partial>lborel\n  \\<le> \\<integral>\\<^sup>+x\\<in>{0..}. ennreal (f x)\\<partial>lborel\n\ngoal (2 subgoals):\n 1. summable (\\<lambda>i. f (real (Suc i)))\n 2. (\\<Sum>i. f (real (Suc i))) \\<le> I", "have \"\\<dots> = (\\<integral>\\<^sup>+ x. ennreal (indicat_real {0..} x * f x) \\<partial>lborel)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+x\\<in>{0..}. ennreal (f x)\\<partial>lborel =\n    \\<integral>\\<^sup>+ x. ennreal (indicat_real {0..} x * f x)\n                       \\<partial>lborel", "by (intro nn_integral_cong) (auto simp: indicator_def)"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+x\\<in>{0..}. ennreal (f x)\\<partial>lborel =\n  \\<integral>\\<^sup>+ x. ennreal (indicat_real {0..} x * f x)\n                     \\<partial>lborel\n\ngoal (2 subgoals):\n 1. summable (\\<lambda>i. f (real (Suc i)))\n 2. (\\<Sum>i. f (real (Suc i))) \\<le> I", "also"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+x\\<in>{0..}. ennreal (f x)\\<partial>lborel =\n  \\<integral>\\<^sup>+ x. ennreal (indicat_real {0..} x * f x)\n                     \\<partial>lborel\n\ngoal (2 subgoals):\n 1. summable (\\<lambda>i. f (real (Suc i)))\n 2. (\\<Sum>i. f (real (Suc i))) \\<le> I", "have \"\\<dots> = ennreal I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ x. ennreal (indicat_real {0..} x * f x)\n                       \\<partial>lborel =\n    ennreal I", "using nn_integral_has_integral_lebesgue[OF nonneg integral]"], ["proof (prove)\nusing this:\n  (\\<And>x. x \\<in> {0..} \\<Longrightarrow> 0 \\<le> x) \\<Longrightarrow>\n  \\<integral>\\<^sup>+ x. ennreal (indicat_real {0..} x * f x)\n                     \\<partial>lborel =\n  ennreal I\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ x. ennreal (indicat_real {0..} x * f x)\n                       \\<partial>lborel =\n    ennreal I", "by (auto simp: nonneg)"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ x. ennreal (indicat_real {0..} x * f x)\n                     \\<partial>lborel =\n  ennreal I\n\ngoal (2 subgoals):\n 1. summable (\\<lambda>i. f (real (Suc i)))\n 2. (\\<Sum>i. f (real (Suc i))) \\<le> I", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>n. ennreal (f (real (Suc n)))) \\<le> ennreal I", "have *: \"(\\<Sum>n. ennreal (f (Suc n))) \\<le> ennreal I\""], ["proof (prove)\nusing this:\n  (\\<Sum>n. ennreal (f (real (Suc n)))) \\<le> ennreal I\n\ngoal (1 subgoal):\n 1. (\\<Sum>n. ennreal (f (real (Suc n)))) \\<le> ennreal I", "."], ["proof (state)\nthis:\n  (\\<Sum>n. ennreal (f (real (Suc n)))) \\<le> ennreal I\n\ngoal (2 subgoals):\n 1. summable (\\<lambda>i. f (real (Suc i)))\n 2. (\\<Sum>i. f (real (Suc i))) \\<le> I", "from *"], ["proof (chain)\npicking this:\n  (\\<Sum>n. ennreal (f (real (Suc n)))) \\<le> ennreal I", "show summable: \"summable (\\<lambda>i. f (real (Suc i)))\""], ["proof (prove)\nusing this:\n  (\\<Sum>n. ennreal (f (real (Suc n)))) \\<le> ennreal I\n\ngoal (1 subgoal):\n 1. summable (\\<lambda>i. f (real (Suc i)))", "by (intro summable_suminf_not_top) (auto simp: top_unique intro: nonneg)"], ["proof (state)\nthis:\n  summable (\\<lambda>i. f (real (Suc i)))\n\ngoal (1 subgoal):\n 1. (\\<Sum>i. f (real (Suc i))) \\<le> I", "note *"], ["proof (state)\nthis:\n  (\\<Sum>n. ennreal (f (real (Suc n)))) \\<le> ennreal I\n\ngoal (1 subgoal):\n 1. (\\<Sum>i. f (real (Suc i))) \\<le> I", "also"], ["proof (state)\nthis:\n  (\\<Sum>n. ennreal (f (real (Suc n)))) \\<le> ennreal I\n\ngoal (1 subgoal):\n 1. (\\<Sum>i. f (real (Suc i))) \\<le> I", "from summable"], ["proof (chain)\npicking this:\n  summable (\\<lambda>i. f (real (Suc i)))", "have \"(\\<Sum>n. ennreal (f (Suc n))) = ennreal (\\<Sum>n. f (Suc n))\""], ["proof (prove)\nusing this:\n  summable (\\<lambda>i. f (real (Suc i)))\n\ngoal (1 subgoal):\n 1. (\\<Sum>n. ennreal (f (real (Suc n)))) =\n    ennreal (\\<Sum>n. f (real (Suc n)))", "by (subst suminf_ennreal2) (auto simp: o_def nonneg)"], ["proof (state)\nthis:\n  (\\<Sum>n. ennreal (f (real (Suc n)))) =\n  ennreal (\\<Sum>n. f (real (Suc n)))\n\ngoal (1 subgoal):\n 1. (\\<Sum>i. f (real (Suc i))) \\<le> I", "finally"], ["proof (chain)\npicking this:\n  ennreal (\\<Sum>n. f (real (Suc n))) \\<le> ennreal I", "show \"(\\<Sum>n. f (real (Suc n))) \\<le> I\""], ["proof (prove)\nusing this:\n  ennreal (\\<Sum>n. f (real (Suc n))) \\<le> ennreal I\n\ngoal (1 subgoal):\n 1. (\\<Sum>n. f (real (Suc n))) \\<le> I", "by (subst (asm) ennreal_le_iff) auto"], ["proof (state)\nthis:\n  (\\<Sum>n. f (real (Suc n))) \\<le> I\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma decreasing_sum_le_integral':\n  fixes f :: \"real \\<Rightarrow> real\"\n  assumes \"\\<And>x. x \\<ge> 0 \\<Longrightarrow> f x \\<ge> 0\"\n  assumes \"\\<And>x y. 0 \\<le> x \\<Longrightarrow> x \\<le> y \\<Longrightarrow> f y \\<le> f x\"\n  assumes \"(f has_integral I) {0..}\"\n  shows   \"summable (\\<lambda>i. f (real i))\" and \"suminf (\\<lambda>i. f (real i)) \\<le> f 0 + I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. summable (\\<lambda>i. f (real i)) &&&\n    (\\<Sum>i. f (real i)) \\<le> f 0 + I", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. summable (\\<lambda>i. f (real i))\n 2. (\\<Sum>i. f (real i)) \\<le> f 0 + I", "have \"summable ((\\<lambda>i. f (real (Suc i))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. summable (\\<lambda>i. f (real (Suc i)))", "using decreasing_sum_le_integral[OF assms]"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>x. 0 \\<le> x \\<Longrightarrow> 0 \\<le> x;\n   \\<And>x y.\n      \\<lbrakk>0 \\<le> x; x \\<le> y\\<rbrakk> \\<Longrightarrow> 0 \\<le> x;\n   \\<And>x y.\n      \\<lbrakk>0 \\<le> x; x \\<le> y\\<rbrakk>\n      \\<Longrightarrow> x \\<le> y\\<rbrakk>\n  \\<Longrightarrow> summable (\\<lambda>i. f (real (Suc i)))\n  \\<lbrakk>\\<And>x. 0 \\<le> x \\<Longrightarrow> 0 \\<le> x;\n   \\<And>x y.\n      \\<lbrakk>0 \\<le> x; x \\<le> y\\<rbrakk> \\<Longrightarrow> 0 \\<le> x;\n   \\<And>x y.\n      \\<lbrakk>0 \\<le> x; x \\<le> y\\<rbrakk>\n      \\<Longrightarrow> x \\<le> y\\<rbrakk>\n  \\<Longrightarrow> (\\<Sum>i. f (real (Suc i))) \\<le> I\n\ngoal (1 subgoal):\n 1. summable (\\<lambda>i. f (real (Suc i)))", "by (simp add: o_def)"], ["proof (state)\nthis:\n  summable (\\<lambda>i. f (real (Suc i)))\n\ngoal (2 subgoals):\n 1. summable (\\<lambda>i. f (real i))\n 2. (\\<Sum>i. f (real i)) \\<le> f 0 + I", "thus *: \"summable (\\<lambda>i. f (real i))\""], ["proof (prove)\nusing this:\n  summable (\\<lambda>i. f (real (Suc i)))\n\ngoal (1 subgoal):\n 1. summable (\\<lambda>i. f (real i))", "by (subst (asm) summable_Suc_iff)"], ["proof (state)\nthis:\n  summable (\\<lambda>i. f (real i))\n\ngoal (1 subgoal):\n 1. (\\<Sum>i. f (real i)) \\<le> f 0 + I", "have \"(\\<Sum>n. f (real (Suc n))) \\<le> I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>n. f (real (Suc n))) \\<le> I", "by (intro decreasing_sum_le_integral assms)"], ["proof (state)\nthis:\n  (\\<Sum>n. f (real (Suc n))) \\<le> I\n\ngoal (1 subgoal):\n 1. (\\<Sum>i. f (real i)) \\<le> f 0 + I", "thus \"suminf (\\<lambda>i. f (real i)) \\<le> f 0 + I\""], ["proof (prove)\nusing this:\n  (\\<Sum>n. f (real (Suc n))) \\<le> I\n\ngoal (1 subgoal):\n 1. (\\<Sum>i. f (real i)) \\<le> f 0 + I", "using *"], ["proof (prove)\nusing this:\n  (\\<Sum>n. f (real (Suc n))) \\<le> I\n  summable (\\<lambda>i. f (real i))\n\ngoal (1 subgoal):\n 1. (\\<Sum>i. f (real i)) \\<le> f 0 + I", "by (subst (asm) suminf_split_head) auto"], ["proof (state)\nthis:\n  (\\<Sum>i. f (real i)) \\<le> f 0 + I\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma norm_suminf_le:\n  assumes \"\\<And>n. norm (f n :: 'a :: banach) \\<le> g n\" \"summable g\"\n  shows   \"norm (suminf f) \\<le> suminf g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norm (suminf f) \\<le> suminf g", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. norm (suminf f) \\<le> suminf g", "have *: \"summable (\\<lambda>n. norm (f n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. summable (\\<lambda>n. norm (f n))", "using assms"], ["proof (prove)\nusing this:\n  norm (f ?n) \\<le> g ?n\n  summable g\n\ngoal (1 subgoal):\n 1. summable (\\<lambda>n. norm (f n))", "by (intro summable_norm summable_comparison_test[OF _ assms(2)] exI[of _ 0]) auto"], ["proof (state)\nthis:\n  summable (\\<lambda>n. norm (f n))\n\ngoal (1 subgoal):\n 1. norm (suminf f) \\<le> suminf g", "hence \"norm (suminf f) \\<le> (\\<Sum>n. norm (f n))\""], ["proof (prove)\nusing this:\n  summable (\\<lambda>n. norm (f n))\n\ngoal (1 subgoal):\n 1. norm (suminf f) \\<le> (\\<Sum>n. norm (f n))", "by (intro summable_norm) auto"], ["proof (state)\nthis:\n  norm (suminf f) \\<le> (\\<Sum>n. norm (f n))\n\ngoal (1 subgoal):\n 1. norm (suminf f) \\<le> suminf g", "also"], ["proof (state)\nthis:\n  norm (suminf f) \\<le> (\\<Sum>n. norm (f n))\n\ngoal (1 subgoal):\n 1. norm (suminf f) \\<le> suminf g", "have \"\\<dots> \\<le> suminf g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>n. norm (f n)) \\<le> suminf g", "by (intro suminf_le * assms allI)"], ["proof (state)\nthis:\n  (\\<Sum>n. norm (f n)) \\<le> suminf g\n\ngoal (1 subgoal):\n 1. norm (suminf f) \\<le> suminf g", "finally"], ["proof (chain)\npicking this:\n  norm (suminf f) \\<le> suminf g", "show ?thesis"], ["proof (prove)\nusing this:\n  norm (suminf f) \\<le> suminf g\n\ngoal (1 subgoal):\n 1. norm (suminf f) \\<le> suminf g", "."], ["proof (state)\nthis:\n  norm (suminf f) \\<le> suminf g\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma of_nat_powr_neq_1_complex [simp]:\n  assumes \"n > 1\" \"Re s \\<noteq> 0\"\n  shows   \"of_nat n powr s \\<noteq> (1::complex)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_nat n powr s \\<noteq> 1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. of_nat n powr s \\<noteq> 1", "have \"norm (of_nat n powr s) = real n powr Re s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod (of_nat n powr s) = real n powr Re s", "by (simp add: norm_powr_real_powr)"], ["proof (state)\nthis:\n  cmod (of_nat n powr s) = real n powr Re s\n\ngoal (1 subgoal):\n 1. of_nat n powr s \\<noteq> 1", "also"], ["proof (state)\nthis:\n  cmod (of_nat n powr s) = real n powr Re s\n\ngoal (1 subgoal):\n 1. of_nat n powr s \\<noteq> 1", "have \"\\<dots> \\<noteq> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real n powr Re s \\<noteq> 1", "using assms"], ["proof (prove)\nusing this:\n  1 < n\n  Re s \\<noteq> 0\n\ngoal (1 subgoal):\n 1. real n powr Re s \\<noteq> 1", "by (auto simp: powr_def)"], ["proof (state)\nthis:\n  real n powr Re s \\<noteq> 1\n\ngoal (1 subgoal):\n 1. of_nat n powr s \\<noteq> 1", "finally"], ["proof (chain)\npicking this:\n  cmod (of_nat n powr s) \\<noteq> 1", "show ?thesis"], ["proof (prove)\nusing this:\n  cmod (of_nat n powr s) \\<noteq> 1\n\ngoal (1 subgoal):\n 1. of_nat n powr s \\<noteq> 1", "by auto"], ["proof (state)\nthis:\n  of_nat n powr s \\<noteq> 1\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma abs_summable_on_uminus_iff:\n  \"(\\<lambda>x. -f x) abs_summable_on A \\<longleftrightarrow> f abs_summable_on A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x. - f x) abs_summable_on A) = (f abs_summable_on A)", "using abs_summable_on_uminus[of f A] abs_summable_on_uminus[of \"\\<lambda>x. -f x\" A]"], ["proof (prove)\nusing this:\n  f abs_summable_on A \\<Longrightarrow>\n  (\\<lambda>x. - f x) abs_summable_on A\n  (\\<lambda>x. - f x) abs_summable_on A \\<Longrightarrow>\n  (\\<lambda>x. - (- f x)) abs_summable_on A\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. - f x) abs_summable_on A) = (f abs_summable_on A)", "by auto"], ["", "lemma abs_summable_on_cmult_right_iff:\n  fixes f :: \"'a \\<Rightarrow> 'b :: {banach, real_normed_field, second_countable_topology}\"\n  assumes \"c \\<noteq> 0\"\n  shows   \"(\\<lambda>x. c * f x) abs_summable_on A \\<longleftrightarrow> f abs_summable_on A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x. c * f x) abs_summable_on A) = (f abs_summable_on A)", "using assms abs_summable_on_cmult_right[of c f A]\n        abs_summable_on_cmult_right[of \"inverse c\" \"\\<lambda>x. c * f x\" A]"], ["proof (prove)\nusing this:\n  c \\<noteq> (0::'b)\n  (c \\<noteq> (0::'b) \\<Longrightarrow>\n   f abs_summable_on A) \\<Longrightarrow>\n  (\\<lambda>x. c * f x) abs_summable_on A\n  (inverse c \\<noteq> (0::'b) \\<Longrightarrow>\n   (\\<lambda>x. c * f x) abs_summable_on A) \\<Longrightarrow>\n  (\\<lambda>x. inverse c * (c * f x)) abs_summable_on A\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. c * f x) abs_summable_on A) = (f abs_summable_on A)", "by (auto simp: field_simps)"], ["", "lemma abs_summable_on_cmult_left_iff:\n  fixes f :: \"'a \\<Rightarrow> 'b :: {banach, real_normed_field, second_countable_topology}\"\n  assumes \"c \\<noteq> 0\"\n  shows   \"(\\<lambda>x. f x * c) abs_summable_on A \\<longleftrightarrow> f abs_summable_on A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x. f x * c) abs_summable_on A) = (f abs_summable_on A)", "using assms abs_summable_on_cmult_left[of c f A]\n        abs_summable_on_cmult_left[of \"inverse c\" \"\\<lambda>x. f x * c\" A]"], ["proof (prove)\nusing this:\n  c \\<noteq> (0::'b)\n  (c \\<noteq> (0::'b) \\<Longrightarrow>\n   f abs_summable_on A) \\<Longrightarrow>\n  (\\<lambda>x. f x * c) abs_summable_on A\n  (inverse c \\<noteq> (0::'b) \\<Longrightarrow>\n   (\\<lambda>x. f x * c) abs_summable_on A) \\<Longrightarrow>\n  (\\<lambda>x. f x * c * inverse c) abs_summable_on A\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. f x * c) abs_summable_on A) = (f abs_summable_on A)", "by (auto simp: field_simps)"], ["", "lemma fds_logderiv_completely_multiplicative:\n  fixes f :: \"'a :: {real_normed_field} fds\"\n  assumes \"completely_multiplicative_function (fds_nth f)\" \"fds_nth f 1 \\<noteq> 0\"\n  shows   \"fds_deriv f / f = - fds (\\<lambda>n. fds_nth f n * mangoldt n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fds_deriv f / f = - fds (\\<lambda>n. fds_nth f n * mangoldt n)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. fds_deriv f / f = - fds (\\<lambda>n. fds_nth f n * mangoldt n)", "have \"fds_deriv f / f = - fds (\\<lambda>n. fds_nth f n * mangoldt n) * f / f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fds_deriv f / f = - fds (\\<lambda>n. fds_nth f n * mangoldt n) * f / f", "using completely_multiplicative_fds_deriv[of \"fds_nth f\"] assms"], ["proof (prove)\nusing this:\n  completely_multiplicative_function (fds_nth f) \\<Longrightarrow>\n  fds_deriv (fds (fds_nth f)) =\n  - fds (\\<lambda>n. fds_nth f n * mangoldt n) * fds (fds_nth f)\n  completely_multiplicative_function (fds_nth f)\n  fds_nth f 1 \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. fds_deriv f / f = - fds (\\<lambda>n. fds_nth f n * mangoldt n) * f / f", "by simp"], ["proof (state)\nthis:\n  fds_deriv f / f = - fds (\\<lambda>n. fds_nth f n * mangoldt n) * f / f\n\ngoal (1 subgoal):\n 1. fds_deriv f / f = - fds (\\<lambda>n. fds_nth f n * mangoldt n)", "also"], ["proof (state)\nthis:\n  fds_deriv f / f = - fds (\\<lambda>n. fds_nth f n * mangoldt n) * f / f\n\ngoal (1 subgoal):\n 1. fds_deriv f / f = - fds (\\<lambda>n. fds_nth f n * mangoldt n)", "have \"\\<dots> = - fds (\\<lambda>n. fds_nth f n * mangoldt n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - fds (\\<lambda>n. fds_nth f n * mangoldt n) * f / f =\n    - fds (\\<lambda>n. fds_nth f n * mangoldt n)", "using assms"], ["proof (prove)\nusing this:\n  completely_multiplicative_function (fds_nth f)\n  fds_nth f 1 \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. - fds (\\<lambda>n. fds_nth f n * mangoldt n) * f / f =\n    - fds (\\<lambda>n. fds_nth f n * mangoldt n)", "by (simp add: divide_fds_def fds_right_inverse)"], ["proof (state)\nthis:\n  - fds (\\<lambda>n. fds_nth f n * mangoldt n) * f / f =\n  - fds (\\<lambda>n. fds_nth f n * mangoldt n)\n\ngoal (1 subgoal):\n 1. fds_deriv f / f = - fds (\\<lambda>n. fds_nth f n * mangoldt n)", "finally"], ["proof (chain)\npicking this:\n  fds_deriv f / f = - fds (\\<lambda>n. fds_nth f n * mangoldt n)", "show ?thesis"], ["proof (prove)\nusing this:\n  fds_deriv f / f = - fds (\\<lambda>n. fds_nth f n * mangoldt n)\n\ngoal (1 subgoal):\n 1. fds_deriv f / f = - fds (\\<lambda>n. fds_nth f n * mangoldt n)", "."], ["proof (state)\nthis:\n  fds_deriv f / f = - fds (\\<lambda>n. fds_nth f n * mangoldt n)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma fds_nth_logderiv_completely_multiplicative:\n  fixes f :: \"'a :: {real_normed_field} fds\"\n  assumes \"completely_multiplicative_function (fds_nth f)\" \"fds_nth f 1 \\<noteq> 0\"\n  shows   \"fds_nth (fds_deriv f / f) n = -fds_nth f n * mangoldt n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fds_nth (fds_deriv f / f) n = - fds_nth f n * mangoldt n", "using assms"], ["proof (prove)\nusing this:\n  completely_multiplicative_function (fds_nth f)\n  fds_nth f 1 \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. fds_nth (fds_deriv f / f) n = - fds_nth f n * mangoldt n", "by (subst fds_logderiv_completely_multiplicative) (simp_all add: fds_nth_fds')"], ["", "lemma eval_fds_logderiv_completely_multiplicative:\n  fixes s :: \"'a :: dirichlet_series\" and l :: 'a and f :: \"'a fds\"\n  defines \"h \\<equiv> fds_deriv f / f\"\n  assumes \"completely_multiplicative_function (fds_nth f)\" and [simp]: \"fds_nth f 1 \\<noteq> 0\"\n  assumes \"s \\<bullet> 1 > abs_conv_abscissa f\"\n  shows  \"(\\<lambda>p. of_real (ln (real p)) * (1 / (1 - fds_nth f p / nat_power p s) - 1))\n            abs_summable_on {p. prime p}\" (is ?th1)\n    and  \"eval_fds h s = -(\\<Sum>\\<^sub>ap | prime p. of_real (ln (real p)) *\n                            (1 / (1 - fds_nth f p / nat_power p s) - 1))\" (is ?th2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>p.\n        of_real (ln (real p)) *\n        ((1::'a) / ((1::'a) - fds_nth f p / nat_power p s) -\n         (1::'a))) abs_summable_on\n    {p. prime p} &&&\n    eval_fds h s =\n    - (\\<Sum>\\<^sub>ap | prime p.\n         of_real (ln (real p)) *\n         ((1::'a) / ((1::'a) - fds_nth f p / nat_power p s) - (1::'a)))", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<lambda>p.\n        of_real (ln (real p)) *\n        ((1::'a) / ((1::'a) - fds_nth f p / nat_power p s) -\n         (1::'a))) abs_summable_on\n    {p. prime p}\n 2. eval_fds h s =\n    - (\\<Sum>\\<^sub>ap | prime p.\n         of_real (ln (real p)) *\n         ((1::'a) / ((1::'a) - fds_nth f p / nat_power p s) - (1::'a)))", "let ?P = \"{p::nat. prime p}\""], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<lambda>p.\n        of_real (ln (real p)) *\n        ((1::'a) / ((1::'a) - fds_nth f p / nat_power p s) -\n         (1::'a))) abs_summable_on\n    {p. prime p}\n 2. eval_fds h s =\n    - (\\<Sum>\\<^sub>ap | prime p.\n         of_real (ln (real p)) *\n         ((1::'a) / ((1::'a) - fds_nth f p / nat_power p s) - (1::'a)))", "interpret f: completely_multiplicative_function \"fds_nth f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. completely_multiplicative_function (fds_nth f)", "by fact"], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<lambda>p.\n        of_real (ln (real p)) *\n        ((1::'a) / ((1::'a) - fds_nth f p / nat_power p s) -\n         (1::'a))) abs_summable_on\n    {p. prime p}\n 2. eval_fds h s =\n    - (\\<Sum>\\<^sub>ap | prime p.\n         of_real (ln (real p)) *\n         ((1::'a) / ((1::'a) - fds_nth f p / nat_power p s) - (1::'a)))", "have \"fds_abs_converges h s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fds_abs_converges h s", "using abs_conv_abscissa_completely_multiplicative_log_deriv[OF assms(2)] assms"], ["proof (prove)\nusing this:\n  fds_nth f 1 \\<noteq> (0::'a) \\<Longrightarrow>\n  abs_conv_abscissa (fds_deriv f / f) \\<le> abs_conv_abscissa f\n  h \\<equiv> fds_deriv f / f\n  completely_multiplicative_function (fds_nth f)\n  fds_nth f 1 \\<noteq> (0::'a)\n  abs_conv_abscissa f < ereal (s \\<bullet> (1::'a))\n\ngoal (1 subgoal):\n 1. fds_abs_converges h s", "by (intro fds_abs_converges) auto"], ["proof (state)\nthis:\n  fds_abs_converges h s\n\ngoal (2 subgoals):\n 1. (\\<lambda>p.\n        of_real (ln (real p)) *\n        ((1::'a) / ((1::'a) - fds_nth f p / nat_power p s) -\n         (1::'a))) abs_summable_on\n    {p. prime p}\n 2. eval_fds h s =\n    - (\\<Sum>\\<^sub>ap | prime p.\n         of_real (ln (real p)) *\n         ((1::'a) / ((1::'a) - fds_nth f p / nat_power p s) - (1::'a)))", "hence *: \"(\\<lambda>n. fds_nth h n / nat_power n s) abs_summable_on UNIV\""], ["proof (prove)\nusing this:\n  fds_abs_converges h s\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. fds_nth h n / nat_power n s) abs_summable_on UNIV", "by (auto simp: h_def fds_abs_converges_altdef')"], ["proof (state)\nthis:\n  (\\<lambda>n. fds_nth h n / nat_power n s) abs_summable_on UNIV\n\ngoal (2 subgoals):\n 1. (\\<lambda>p.\n        of_real (ln (real p)) *\n        ((1::'a) / ((1::'a) - fds_nth f p / nat_power p s) -\n         (1::'a))) abs_summable_on\n    {p. prime p}\n 2. eval_fds h s =\n    - (\\<Sum>\\<^sub>ap | prime p.\n         of_real (ln (real p)) *\n         ((1::'a) / ((1::'a) - fds_nth f p / nat_power p s) - (1::'a)))", "note *"], ["proof (state)\nthis:\n  (\\<lambda>n. fds_nth h n / nat_power n s) abs_summable_on UNIV\n\ngoal (2 subgoals):\n 1. (\\<lambda>p.\n        of_real (ln (real p)) *\n        ((1::'a) / ((1::'a) - fds_nth f p / nat_power p s) -\n         (1::'a))) abs_summable_on\n    {p. prime p}\n 2. eval_fds h s =\n    - (\\<Sum>\\<^sub>ap | prime p.\n         of_real (ln (real p)) *\n         ((1::'a) / ((1::'a) - fds_nth f p / nat_power p s) - (1::'a)))", "also"], ["proof (state)\nthis:\n  (\\<lambda>n. fds_nth h n / nat_power n s) abs_summable_on UNIV\n\ngoal (2 subgoals):\n 1. (\\<lambda>p.\n        of_real (ln (real p)) *\n        ((1::'a) / ((1::'a) - fds_nth f p / nat_power p s) -\n         (1::'a))) abs_summable_on\n    {p. prime p}\n 2. eval_fds h s =\n    - (\\<Sum>\\<^sub>ap | prime p.\n         of_real (ln (real p)) *\n         ((1::'a) / ((1::'a) - fds_nth f p / nat_power p s) - (1::'a)))", "have \"(\\<lambda>n. fds_nth h n / nat_power n s) abs_summable_on UNIV \\<longleftrightarrow>\n          (\\<lambda>x. -fds_nth f x * mangoldt x / nat_power x s) abs_summable_on Collect primepow\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>n. fds_nth h n / nat_power n s) abs_summable_on UNIV) =\n    ((\\<lambda>x.\n         - fds_nth f x * mangoldt x / nat_power x s) abs_summable_on\n     Collect primepow)", "unfolding h_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>n.\n         fds_nth (fds_deriv f / f) n / nat_power n s) abs_summable_on\n     UNIV) =\n    ((\\<lambda>x.\n         - fds_nth f x * mangoldt x / nat_power x s) abs_summable_on\n     Collect primepow)", "using fds_nth_logderiv_completely_multiplicative[OF assms(2)]"], ["proof (prove)\nusing this:\n  fds_nth f 1 \\<noteq> (0::'a) \\<Longrightarrow>\n  fds_nth (fds_deriv f / f) ?n = - fds_nth f ?n * mangoldt ?n\n\ngoal (1 subgoal):\n 1. ((\\<lambda>n.\n         fds_nth (fds_deriv f / f) n / nat_power n s) abs_summable_on\n     UNIV) =\n    ((\\<lambda>x.\n         - fds_nth f x * mangoldt x / nat_power x s) abs_summable_on\n     Collect primepow)", "by (intro abs_summable_on_cong_neutral) (auto simp: fds_nth_fds mangoldt_def)"], ["proof (state)\nthis:\n  ((\\<lambda>n. fds_nth h n / nat_power n s) abs_summable_on UNIV) =\n  ((\\<lambda>x. - fds_nth f x * mangoldt x / nat_power x s) abs_summable_on\n   Collect primepow)\n\ngoal (2 subgoals):\n 1. (\\<lambda>p.\n        of_real (ln (real p)) *\n        ((1::'a) / ((1::'a) - fds_nth f p / nat_power p s) -\n         (1::'a))) abs_summable_on\n    {p. prime p}\n 2. eval_fds h s =\n    - (\\<Sum>\\<^sub>ap | prime p.\n         of_real (ln (real p)) *\n         ((1::'a) / ((1::'a) - fds_nth f p / nat_power p s) - (1::'a)))", "finally"], ["proof (chain)\npicking this:\n  (\\<lambda>x. - fds_nth f x * mangoldt x / nat_power x s) abs_summable_on\n  Collect primepow", "have sum1: \"(\\<lambda>x. -fds_nth f x * mangoldt x / nat_power x s)\n                      abs_summable_on Collect primepow\""], ["proof (prove)\nusing this:\n  (\\<lambda>x. - fds_nth f x * mangoldt x / nat_power x s) abs_summable_on\n  Collect primepow\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. - fds_nth f x * mangoldt x / nat_power x s) abs_summable_on\n    Collect primepow", "by (rule abs_summable_on_subset) auto"], ["proof (state)\nthis:\n  (\\<lambda>x. - fds_nth f x * mangoldt x / nat_power x s) abs_summable_on\n  Collect primepow\n\ngoal (2 subgoals):\n 1. (\\<lambda>p.\n        of_real (ln (real p)) *\n        ((1::'a) / ((1::'a) - fds_nth f p / nat_power p s) -\n         (1::'a))) abs_summable_on\n    {p. prime p}\n 2. eval_fds h s =\n    - (\\<Sum>\\<^sub>ap | prime p.\n         of_real (ln (real p)) *\n         ((1::'a) / ((1::'a) - fds_nth f p / nat_power p s) - (1::'a)))", "also"], ["proof (state)\nthis:\n  (\\<lambda>x. - fds_nth f x * mangoldt x / nat_power x s) abs_summable_on\n  Collect primepow\n\ngoal (2 subgoals):\n 1. (\\<lambda>p.\n        of_real (ln (real p)) *\n        ((1::'a) / ((1::'a) - fds_nth f p / nat_power p s) -\n         (1::'a))) abs_summable_on\n    {p. prime p}\n 2. eval_fds h s =\n    - (\\<Sum>\\<^sub>ap | prime p.\n         of_real (ln (real p)) *\n         ((1::'a) / ((1::'a) - fds_nth f p / nat_power p s) - (1::'a)))", "have \"?this \\<longleftrightarrow> (\\<lambda>(p,k). -fds_nth f (p ^ Suc k) * mangoldt (p ^ Suc k) /\n                                nat_power (p ^ Suc k) s) abs_summable_on (?P \\<times> UNIV)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x.\n         - fds_nth f x * mangoldt x / nat_power x s) abs_summable_on\n     Collect primepow) =\n    ((\\<lambda>(p, k).\n         - fds_nth f (p ^ Suc k) * mangoldt (p ^ Suc k) /\n         nat_power (p ^ Suc k) s) abs_summable_on\n     {p. prime p} \\<times> UNIV)", "using bij_betw_primepows"], ["proof (prove)\nusing this:\n  bij_betw (\\<lambda>(p, k). p ^ Suc k) (Collect prime \\<times> UNIV)\n   (Collect primepow)\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x.\n         - fds_nth f x * mangoldt x / nat_power x s) abs_summable_on\n     Collect primepow) =\n    ((\\<lambda>(p, k).\n         - fds_nth f (p ^ Suc k) * mangoldt (p ^ Suc k) /\n         nat_power (p ^ Suc k) s) abs_summable_on\n     {p. prime p} \\<times> UNIV)", "unfolding case_prod_unfold"], ["proof (prove)\nusing this:\n  bij_betw (\\<lambda>p. fst p ^ Suc (snd p)) (Collect prime \\<times> UNIV)\n   (Collect primepow)\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x.\n         - fds_nth f x * mangoldt x / nat_power x s) abs_summable_on\n     Collect primepow) =\n    ((\\<lambda>p.\n         - fds_nth f (fst p ^ Suc (snd p)) *\n         mangoldt (fst p ^ Suc (snd p)) /\n         nat_power (fst p ^ Suc (snd p)) s) abs_summable_on\n     {p. prime p} \\<times> UNIV)", "by (intro abs_summable_on_reindex_bij_betw [symmetric])"], ["proof (state)\nthis:\n  ((\\<lambda>x. - fds_nth f x * mangoldt x / nat_power x s) abs_summable_on\n   Collect primepow) =\n  ((\\<lambda>(p, k).\n       - fds_nth f (p ^ Suc k) * mangoldt (p ^ Suc k) /\n       nat_power (p ^ Suc k) s) abs_summable_on\n   {p. prime p} \\<times> UNIV)\n\ngoal (2 subgoals):\n 1. (\\<lambda>p.\n        of_real (ln (real p)) *\n        ((1::'a) / ((1::'a) - fds_nth f p / nat_power p s) -\n         (1::'a))) abs_summable_on\n    {p. prime p}\n 2. eval_fds h s =\n    - (\\<Sum>\\<^sub>ap | prime p.\n         of_real (ln (real p)) *\n         ((1::'a) / ((1::'a) - fds_nth f p / nat_power p s) - (1::'a)))", "also"], ["proof (state)\nthis:\n  ((\\<lambda>x. - fds_nth f x * mangoldt x / nat_power x s) abs_summable_on\n   Collect primepow) =\n  ((\\<lambda>(p, k).\n       - fds_nth f (p ^ Suc k) * mangoldt (p ^ Suc k) /\n       nat_power (p ^ Suc k) s) abs_summable_on\n   {p. prime p} \\<times> UNIV)\n\ngoal (2 subgoals):\n 1. (\\<lambda>p.\n        of_real (ln (real p)) *\n        ((1::'a) / ((1::'a) - fds_nth f p / nat_power p s) -\n         (1::'a))) abs_summable_on\n    {p. prime p}\n 2. eval_fds h s =\n    - (\\<Sum>\\<^sub>ap | prime p.\n         of_real (ln (real p)) *\n         ((1::'a) / ((1::'a) - fds_nth f p / nat_power p s) - (1::'a)))", "have \"\\<dots> \\<longleftrightarrow> (\\<lambda>(p,k). -((fds_nth f p / nat_power p s) ^ Suc k * of_real (ln (real p))))\n                abs_summable_on (?P \\<times> UNIV)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>(p, k).\n         - fds_nth f (p ^ Suc k) * mangoldt (p ^ Suc k) /\n         nat_power (p ^ Suc k) s) abs_summable_on\n     {p. prime p} \\<times> UNIV) =\n    ((\\<lambda>(p, k).\n         - ((fds_nth f p / nat_power p s) ^ Suc k *\n            of_real (ln (real p)))) abs_summable_on\n     {p. prime p} \\<times> UNIV)", "unfolding case_prod_unfold"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>p.\n         - fds_nth f (fst p ^ Suc (snd p)) *\n         mangoldt (fst p ^ Suc (snd p)) /\n         nat_power (fst p ^ Suc (snd p)) s) abs_summable_on\n     {p. prime p} \\<times> UNIV) =\n    ((\\<lambda>p.\n         - ((fds_nth f (fst p) / nat_power (fst p) s) ^ Suc (snd p) *\n            of_real (ln (real (fst p))))) abs_summable_on\n     {p. prime p} \\<times> UNIV)", "by (intro abs_summable_on_cong, subst mangoldt_primepow)\n       (auto simp: f.mult f.power nat_power_mult_distrib nat_power_power_left power_divide\n             dest: prime_gt_1_nat)"], ["proof (state)\nthis:\n  ((\\<lambda>(p, k).\n       - fds_nth f (p ^ Suc k) * mangoldt (p ^ Suc k) /\n       nat_power (p ^ Suc k) s) abs_summable_on\n   {p. prime p} \\<times> UNIV) =\n  ((\\<lambda>(p, k).\n       - ((fds_nth f p / nat_power p s) ^ Suc k *\n          of_real (ln (real p)))) abs_summable_on\n   {p. prime p} \\<times> UNIV)\n\ngoal (2 subgoals):\n 1. (\\<lambda>p.\n        of_real (ln (real p)) *\n        ((1::'a) / ((1::'a) - fds_nth f p / nat_power p s) -\n         (1::'a))) abs_summable_on\n    {p. prime p}\n 2. eval_fds h s =\n    - (\\<Sum>\\<^sub>ap | prime p.\n         of_real (ln (real p)) *\n         ((1::'a) / ((1::'a) - fds_nth f p / nat_power p s) - (1::'a)))", "finally"], ["proof (chain)\npicking this:\n  (\\<lambda>(p, k).\n      - ((fds_nth f p / nat_power p s) ^ Suc k *\n         of_real (ln (real p)))) abs_summable_on\n  {p. prime p} \\<times> UNIV", "have sum2: \\<dots>"], ["proof (prove)\nusing this:\n  (\\<lambda>(p, k).\n      - ((fds_nth f p / nat_power p s) ^ Suc k *\n         of_real (ln (real p)))) abs_summable_on\n  {p. prime p} \\<times> UNIV\n\ngoal (1 subgoal):\n 1. (\\<lambda>(p, k).\n        - ((fds_nth f p / nat_power p s) ^ Suc k *\n           of_real (ln (real p)))) abs_summable_on\n    {p. prime p} \\<times> UNIV", "."], ["proof (state)\nthis:\n  (\\<lambda>(p, k).\n      - ((fds_nth f p / nat_power p s) ^ Suc k *\n         of_real (ln (real p)))) abs_summable_on\n  {p. prime p} \\<times> UNIV\n\ngoal (2 subgoals):\n 1. (\\<lambda>p.\n        of_real (ln (real p)) *\n        ((1::'a) / ((1::'a) - fds_nth f p / nat_power p s) -\n         (1::'a))) abs_summable_on\n    {p. prime p}\n 2. eval_fds h s =\n    - (\\<Sum>\\<^sub>ap | prime p.\n         of_real (ln (real p)) *\n         ((1::'a) / ((1::'a) - fds_nth f p / nat_power p s) - (1::'a)))", "have sum4: \"summable (\\<lambda>n. (norm (fds_nth f p / nat_power p s)) ^ Suc n)\" if p: \"prime p\" for p"], ["proof (prove)\ngoal (1 subgoal):\n 1. summable (\\<lambda>n. norm (fds_nth f p / nat_power p s) ^ Suc n)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. summable (\\<lambda>n. norm (fds_nth f p / nat_power p s) ^ Suc n)", "have \"summable (\\<lambda>n. \\<bar>ln (real p)\\<bar> * (norm (fds_nth f p / nat_power p s)) ^ Suc n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. summable\n     (\\<lambda>n.\n         \\<bar>ln (real p)\\<bar> *\n         norm (fds_nth f p / nat_power p s) ^ Suc n)", "using p abs_summable_on_Sigma_project2[OF sum2, of p]"], ["proof (prove)\nusing this:\n  prime p\n  p \\<in> {p. prime p} \\<Longrightarrow>\n  (\\<lambda>y.\n      case (p, y) of\n      (p, k) \\<Rightarrow>\n        - ((fds_nth f p / nat_power p s) ^ Suc k *\n           of_real (ln (real p)))) abs_summable_on\n  UNIV\n\ngoal (1 subgoal):\n 1. summable\n     (\\<lambda>n.\n         \\<bar>ln (real p)\\<bar> *\n         norm (fds_nth f p / nat_power p s) ^ Suc n)", "unfolding abs_summable_on_nat_iff'"], ["proof (prove)\nusing this:\n  prime p\n  p \\<in> {p. prime p} \\<Longrightarrow>\n  summable\n   (\\<lambda>n.\n       norm\n        (case (p, n) of\n         (p, k) \\<Rightarrow>\n           - ((fds_nth f p / nat_power p s) ^ Suc k *\n              of_real (ln (real p)))))\n\ngoal (1 subgoal):\n 1. summable\n     (\\<lambda>n.\n         \\<bar>ln (real p)\\<bar> *\n         norm (fds_nth f p / nat_power p s) ^ Suc n)", "by (simp add: norm_power norm_mult norm_divide mult_ac del: power_Suc)"], ["proof (state)\nthis:\n  summable\n   (\\<lambda>n.\n       \\<bar>ln (real p)\\<bar> * norm (fds_nth f p / nat_power p s) ^ Suc n)\n\ngoal (1 subgoal):\n 1. summable (\\<lambda>n. norm (fds_nth f p / nat_power p s) ^ Suc n)", "thus ?thesis"], ["proof (prove)\nusing this:\n  summable\n   (\\<lambda>n.\n       \\<bar>ln (real p)\\<bar> * norm (fds_nth f p / nat_power p s) ^ Suc n)\n\ngoal (1 subgoal):\n 1. summable (\\<lambda>n. norm (fds_nth f p / nat_power p s) ^ Suc n)", "by (rule summable_mult_D) (insert p, auto dest: prime_gt_1_nat)"], ["proof (state)\nthis:\n  summable (\\<lambda>n. norm (fds_nth f p / nat_power p s) ^ Suc n)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  prime ?p \\<Longrightarrow>\n  summable (\\<lambda>n. norm (fds_nth f ?p / nat_power ?p s) ^ Suc n)\n\ngoal (2 subgoals):\n 1. (\\<lambda>p.\n        of_real (ln (real p)) *\n        ((1::'a) / ((1::'a) - fds_nth f p / nat_power p s) -\n         (1::'a))) abs_summable_on\n    {p. prime p}\n 2. eval_fds h s =\n    - (\\<Sum>\\<^sub>ap | prime p.\n         of_real (ln (real p)) *\n         ((1::'a) / ((1::'a) - fds_nth f p / nat_power p s) - (1::'a)))", "have sums: \"(\\<lambda>n. (fds_nth f p / nat_power p s) ^ Suc n) sums\n                (1 / (1 - fds_nth f p / nat_power p s) - 1)\" if p: \"prime p\" for p :: nat"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n. (fds_nth f p / nat_power p s) ^ Suc n) sums\n    ((1::'a) / ((1::'a) - fds_nth f p / nat_power p s) - (1::'a))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<lambda>n. (fds_nth f p / nat_power p s) ^ Suc n) sums\n    ((1::'a) / ((1::'a) - fds_nth f p / nat_power p s) - (1::'a))", "from sum4[OF p]"], ["proof (chain)\npicking this:\n  summable (\\<lambda>n. norm (fds_nth f p / nat_power p s) ^ Suc n)", "have \"norm (fds_nth f p / nat_power p s) < 1\""], ["proof (prove)\nusing this:\n  summable (\\<lambda>n. norm (fds_nth f p / nat_power p s) ^ Suc n)\n\ngoal (1 subgoal):\n 1. norm (fds_nth f p / nat_power p s) < 1", "unfolding summable_Suc_iff"], ["proof (prove)\nusing this:\n  summable ((^) (norm (fds_nth f p / nat_power p s)))\n\ngoal (1 subgoal):\n 1. norm (fds_nth f p / nat_power p s) < 1", "by (simp add: summable_geometric_iff)"], ["proof (state)\nthis:\n  norm (fds_nth f p / nat_power p s) < 1\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. (fds_nth f p / nat_power p s) ^ Suc n) sums\n    ((1::'a) / ((1::'a) - fds_nth f p / nat_power p s) - (1::'a))", "from geometric_sums[OF this]"], ["proof (chain)\npicking this:\n  (^) (fds_nth f p / nat_power p s) sums\n  ((1::'a) / ((1::'a) - fds_nth f p / nat_power p s))", "show ?thesis"], ["proof (prove)\nusing this:\n  (^) (fds_nth f p / nat_power p s) sums\n  ((1::'a) / ((1::'a) - fds_nth f p / nat_power p s))\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. (fds_nth f p / nat_power p s) ^ Suc n) sums\n    ((1::'a) / ((1::'a) - fds_nth f p / nat_power p s) - (1::'a))", "by (subst sums_Suc_iff) auto"], ["proof (state)\nthis:\n  (\\<lambda>n. (fds_nth f p / nat_power p s) ^ Suc n) sums\n  ((1::'a) / ((1::'a) - fds_nth f p / nat_power p s) - (1::'a))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  prime ?p \\<Longrightarrow>\n  (\\<lambda>n. (fds_nth f ?p / nat_power ?p s) ^ Suc n) sums\n  ((1::'a) / ((1::'a) - fds_nth f ?p / nat_power ?p s) - (1::'a))\n\ngoal (2 subgoals):\n 1. (\\<lambda>p.\n        of_real (ln (real p)) *\n        ((1::'a) / ((1::'a) - fds_nth f p / nat_power p s) -\n         (1::'a))) abs_summable_on\n    {p. prime p}\n 2. eval_fds h s =\n    - (\\<Sum>\\<^sub>ap | prime p.\n         of_real (ln (real p)) *\n         ((1::'a) / ((1::'a) - fds_nth f p / nat_power p s) - (1::'a)))", "have eq: \"(\\<Sum>\\<^sub>ak. - ((fds_nth f p / nat_power p s) ^ Suc k * of_real (ln (real p)))) =\n               -(of_real (ln (real p)) * (1 / (1 - fds_nth f p / nat_power p s) - 1))\"\n    if p: \"prime p\" for p"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sub>ak.\n       - ((fds_nth f p / nat_power p s) ^ Suc k * of_real (ln (real p)))) =\n    - (of_real (ln (real p)) *\n       ((1::'a) / ((1::'a) - fds_nth f p / nat_power p s) - (1::'a)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sub>ak.\n       - ((fds_nth f p / nat_power p s) ^ Suc k * of_real (ln (real p)))) =\n    - (of_real (ln (real p)) *\n       ((1::'a) / ((1::'a) - fds_nth f p / nat_power p s) - (1::'a)))", "have \"(\\<Sum>\\<^sub>ak. - ((fds_nth f p / nat_power p s) ^ Suc k * of_real (ln (real p)))) =\n             (\\<Sum>\\<^sub>ak. (fds_nth f p / nat_power p s) ^ Suc k) * of_real (-ln (real p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sub>ak.\n       - ((fds_nth f p / nat_power p s) ^ Suc k * of_real (ln (real p)))) =\n    (\\<Sum>\\<^sub>ak. (fds_nth f p / nat_power p s) ^ Suc k) *\n    of_real (- ln (real p))", "using sum4[of p] p"], ["proof (prove)\nusing this:\n  prime p \\<Longrightarrow>\n  summable (\\<lambda>n. norm (fds_nth f p / nat_power p s) ^ Suc n)\n  prime p\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sub>ak.\n       - ((fds_nth f p / nat_power p s) ^ Suc k * of_real (ln (real p)))) =\n    (\\<Sum>\\<^sub>ak. (fds_nth f p / nat_power p s) ^ Suc k) *\n    of_real (- ln (real p))", "by (subst infsetsum_cmult_left [symmetric])\n         (auto simp: abs_summable_on_nat_iff' norm_power simp del: power_Suc)"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sub>ak.\n     - ((fds_nth f p / nat_power p s) ^ Suc k * of_real (ln (real p)))) =\n  (\\<Sum>\\<^sub>ak. (fds_nth f p / nat_power p s) ^ Suc k) *\n  of_real (- ln (real p))\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sub>ak.\n       - ((fds_nth f p / nat_power p s) ^ Suc k * of_real (ln (real p)))) =\n    - (of_real (ln (real p)) *\n       ((1::'a) / ((1::'a) - fds_nth f p / nat_power p s) - (1::'a)))", "also"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sub>ak.\n     - ((fds_nth f p / nat_power p s) ^ Suc k * of_real (ln (real p)))) =\n  (\\<Sum>\\<^sub>ak. (fds_nth f p / nat_power p s) ^ Suc k) *\n  of_real (- ln (real p))\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sub>ak.\n       - ((fds_nth f p / nat_power p s) ^ Suc k * of_real (ln (real p)))) =\n    - (of_real (ln (real p)) *\n       ((1::'a) / ((1::'a) - fds_nth f p / nat_power p s) - (1::'a)))", "have \"(\\<Sum>\\<^sub>ak. (fds_nth f p / nat_power p s) ^ Suc k) =\n                 (1 / (1 - fds_nth f p / nat_power p s) - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sub>ak. (fds_nth f p / nat_power p s) ^ Suc k) =\n    (1::'a) / ((1::'a) - fds_nth f p / nat_power p s) - (1::'a)", "using sum4[OF p] sums[OF p]"], ["proof (prove)\nusing this:\n  summable (\\<lambda>n. norm (fds_nth f p / nat_power p s) ^ Suc n)\n  (\\<lambda>n. (fds_nth f p / nat_power p s) ^ Suc n) sums\n  ((1::'a) / ((1::'a) - fds_nth f p / nat_power p s) - (1::'a))\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sub>ak. (fds_nth f p / nat_power p s) ^ Suc k) =\n    (1::'a) / ((1::'a) - fds_nth f p / nat_power p s) - (1::'a)", "by (subst infsetsum_nat')\n         (auto simp: sums_iff abs_summable_on_nat_iff' norm_power simp del: power_Suc)"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sub>ak. (fds_nth f p / nat_power p s) ^ Suc k) =\n  (1::'a) / ((1::'a) - fds_nth f p / nat_power p s) - (1::'a)\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sub>ak.\n       - ((fds_nth f p / nat_power p s) ^ Suc k * of_real (ln (real p)))) =\n    - (of_real (ln (real p)) *\n       ((1::'a) / ((1::'a) - fds_nth f p / nat_power p s) - (1::'a)))", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>\\<^sub>ak.\n     - ((fds_nth f p / nat_power p s) ^ Suc k * of_real (ln (real p)))) =\n  ((1::'a) / ((1::'a) - fds_nth f p / nat_power p s) - (1::'a)) *\n  of_real (- ln (real p))", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<Sum>\\<^sub>ak.\n     - ((fds_nth f p / nat_power p s) ^ Suc k * of_real (ln (real p)))) =\n  ((1::'a) / ((1::'a) - fds_nth f p / nat_power p s) - (1::'a)) *\n  of_real (- ln (real p))\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sub>ak.\n       - ((fds_nth f p / nat_power p s) ^ Suc k * of_real (ln (real p)))) =\n    - (of_real (ln (real p)) *\n       ((1::'a) / ((1::'a) - fds_nth f p / nat_power p s) - (1::'a)))", "by (simp add: mult_ac)"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sub>ak.\n     - ((fds_nth f p / nat_power p s) ^ Suc k * of_real (ln (real p)))) =\n  - (of_real (ln (real p)) *\n     ((1::'a) / ((1::'a) - fds_nth f p / nat_power p s) - (1::'a)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  prime ?p \\<Longrightarrow>\n  (\\<Sum>\\<^sub>ak.\n     - ((fds_nth f ?p / nat_power ?p s) ^ Suc k * of_real (ln (real ?p)))) =\n  - (of_real (ln (real ?p)) *\n     ((1::'a) / ((1::'a) - fds_nth f ?p / nat_power ?p s) - (1::'a)))\n\ngoal (2 subgoals):\n 1. (\\<lambda>p.\n        of_real (ln (real p)) *\n        ((1::'a) / ((1::'a) - fds_nth f p / nat_power p s) -\n         (1::'a))) abs_summable_on\n    {p. prime p}\n 2. eval_fds h s =\n    - (\\<Sum>\\<^sub>ap | prime p.\n         of_real (ln (real p)) *\n         ((1::'a) / ((1::'a) - fds_nth f p / nat_power p s) - (1::'a)))", "have sum3: \"(\\<lambda>x. \\<Sum>\\<^sub>ay. - ((fds_nth f x / nat_power x s) ^ Suc y * of_real (ln (real x))))\n                 abs_summable_on {p. prime p}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x.\n        \\<Sum>\\<^sub>ay.\n          - ((fds_nth f x / nat_power x s) ^ Suc y *\n             of_real (ln (real x)))) abs_summable_on\n    {p. prime p}", "using sum2"], ["proof (prove)\nusing this:\n  (\\<lambda>(p, k).\n      - ((fds_nth f p / nat_power p s) ^ Suc k *\n         of_real (ln (real p)))) abs_summable_on\n  {p. prime p} \\<times> UNIV\n\ngoal (1 subgoal):\n 1. (\\<lambda>x.\n        \\<Sum>\\<^sub>ay.\n          - ((fds_nth f x / nat_power x s) ^ Suc y *\n             of_real (ln (real x)))) abs_summable_on\n    {p. prime p}", "by (rule abs_summable_on_Sigma_project1') auto"], ["proof (state)\nthis:\n  (\\<lambda>x.\n      \\<Sum>\\<^sub>ay.\n        - ((fds_nth f x / nat_power x s) ^ Suc y *\n           of_real (ln (real x)))) abs_summable_on\n  {p. prime p}\n\ngoal (2 subgoals):\n 1. (\\<lambda>p.\n        of_real (ln (real p)) *\n        ((1::'a) / ((1::'a) - fds_nth f p / nat_power p s) -\n         (1::'a))) abs_summable_on\n    {p. prime p}\n 2. eval_fds h s =\n    - (\\<Sum>\\<^sub>ap | prime p.\n         of_real (ln (real p)) *\n         ((1::'a) / ((1::'a) - fds_nth f p / nat_power p s) - (1::'a)))", "also"], ["proof (state)\nthis:\n  (\\<lambda>x.\n      \\<Sum>\\<^sub>ay.\n        - ((fds_nth f x / nat_power x s) ^ Suc y *\n           of_real (ln (real x)))) abs_summable_on\n  {p. prime p}\n\ngoal (2 subgoals):\n 1. (\\<lambda>p.\n        of_real (ln (real p)) *\n        ((1::'a) / ((1::'a) - fds_nth f p / nat_power p s) -\n         (1::'a))) abs_summable_on\n    {p. prime p}\n 2. eval_fds h s =\n    - (\\<Sum>\\<^sub>ap | prime p.\n         of_real (ln (real p)) *\n         ((1::'a) / ((1::'a) - fds_nth f p / nat_power p s) - (1::'a)))", "have \"?this \\<longleftrightarrow> (\\<lambda>p. -(of_real (ln (real p)) *\n                (1 / (1 - fds_nth f p / nat_power p s) - 1))) abs_summable_on {p. prime p}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x.\n         \\<Sum>\\<^sub>ay.\n           - ((fds_nth f x / nat_power x s) ^ Suc y *\n              of_real (ln (real x)))) abs_summable_on\n     {p. prime p}) =\n    ((\\<lambda>p.\n         - (of_real (ln (real p)) *\n            ((1::'a) / ((1::'a) - fds_nth f p / nat_power p s) -\n             (1::'a)))) abs_summable_on\n     {p. prime p})", "by (intro abs_summable_on_cong eq) auto"], ["proof (state)\nthis:\n  ((\\<lambda>x.\n       \\<Sum>\\<^sub>ay.\n         - ((fds_nth f x / nat_power x s) ^ Suc y *\n            of_real (ln (real x)))) abs_summable_on\n   {p. prime p}) =\n  ((\\<lambda>p.\n       - (of_real (ln (real p)) *\n          ((1::'a) / ((1::'a) - fds_nth f p / nat_power p s) -\n           (1::'a)))) abs_summable_on\n   {p. prime p})\n\ngoal (2 subgoals):\n 1. (\\<lambda>p.\n        of_real (ln (real p)) *\n        ((1::'a) / ((1::'a) - fds_nth f p / nat_power p s) -\n         (1::'a))) abs_summable_on\n    {p. prime p}\n 2. eval_fds h s =\n    - (\\<Sum>\\<^sub>ap | prime p.\n         of_real (ln (real p)) *\n         ((1::'a) / ((1::'a) - fds_nth f p / nat_power p s) - (1::'a)))", "also"], ["proof (state)\nthis:\n  ((\\<lambda>x.\n       \\<Sum>\\<^sub>ay.\n         - ((fds_nth f x / nat_power x s) ^ Suc y *\n            of_real (ln (real x)))) abs_summable_on\n   {p. prime p}) =\n  ((\\<lambda>p.\n       - (of_real (ln (real p)) *\n          ((1::'a) / ((1::'a) - fds_nth f p / nat_power p s) -\n           (1::'a)))) abs_summable_on\n   {p. prime p})\n\ngoal (2 subgoals):\n 1. (\\<lambda>p.\n        of_real (ln (real p)) *\n        ((1::'a) / ((1::'a) - fds_nth f p / nat_power p s) -\n         (1::'a))) abs_summable_on\n    {p. prime p}\n 2. eval_fds h s =\n    - (\\<Sum>\\<^sub>ap | prime p.\n         of_real (ln (real p)) *\n         ((1::'a) / ((1::'a) - fds_nth f p / nat_power p s) - (1::'a)))", "have \"\\<dots> \\<longleftrightarrow> ?th1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>p.\n         - (of_real (ln (real p)) *\n            ((1::'a) / ((1::'a) - fds_nth f p / nat_power p s) -\n             (1::'a)))) abs_summable_on\n     {p. prime p}) =\n    ((\\<lambda>p.\n         of_real (ln (real p)) *\n         ((1::'a) / ((1::'a) - fds_nth f p / nat_power p s) -\n          (1::'a))) abs_summable_on\n     {p. prime p})", "by (subst abs_summable_on_uminus_iff) auto"], ["proof (state)\nthis:\n  ((\\<lambda>p.\n       - (of_real (ln (real p)) *\n          ((1::'a) / ((1::'a) - fds_nth f p / nat_power p s) -\n           (1::'a)))) abs_summable_on\n   {p. prime p}) =\n  ((\\<lambda>p.\n       of_real (ln (real p)) *\n       ((1::'a) / ((1::'a) - fds_nth f p / nat_power p s) -\n        (1::'a))) abs_summable_on\n   {p. prime p})\n\ngoal (2 subgoals):\n 1. (\\<lambda>p.\n        of_real (ln (real p)) *\n        ((1::'a) / ((1::'a) - fds_nth f p / nat_power p s) -\n         (1::'a))) abs_summable_on\n    {p. prime p}\n 2. eval_fds h s =\n    - (\\<Sum>\\<^sub>ap | prime p.\n         of_real (ln (real p)) *\n         ((1::'a) / ((1::'a) - fds_nth f p / nat_power p s) - (1::'a)))", "finally"], ["proof (chain)\npicking this:\n  (\\<lambda>p.\n      of_real (ln (real p)) *\n      ((1::'a) / ((1::'a) - fds_nth f p / nat_power p s) -\n       (1::'a))) abs_summable_on\n  {p. prime p}", "show ?th1"], ["proof (prove)\nusing this:\n  (\\<lambda>p.\n      of_real (ln (real p)) *\n      ((1::'a) / ((1::'a) - fds_nth f p / nat_power p s) -\n       (1::'a))) abs_summable_on\n  {p. prime p}\n\ngoal (1 subgoal):\n 1. (\\<lambda>p.\n        of_real (ln (real p)) *\n        ((1::'a) / ((1::'a) - fds_nth f p / nat_power p s) -\n         (1::'a))) abs_summable_on\n    {p. prime p}", "."], ["proof (state)\nthis:\n  (\\<lambda>p.\n      of_real (ln (real p)) *\n      ((1::'a) / ((1::'a) - fds_nth f p / nat_power p s) -\n       (1::'a))) abs_summable_on\n  {p. prime p}\n\ngoal (1 subgoal):\n 1. eval_fds h s =\n    - (\\<Sum>\\<^sub>ap | prime p.\n         of_real (ln (real p)) *\n         ((1::'a) / ((1::'a) - fds_nth f p / nat_power p s) - (1::'a)))", "have \"eval_fds h s = (\\<Sum>\\<^sub>an. fds_nth h n / nat_power n s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_fds h s = (\\<Sum>\\<^sub>an. fds_nth h n / nat_power n s)", "using *"], ["proof (prove)\nusing this:\n  (\\<lambda>n. fds_nth h n / nat_power n s) abs_summable_on UNIV\n\ngoal (1 subgoal):\n 1. eval_fds h s = (\\<Sum>\\<^sub>an. fds_nth h n / nat_power n s)", "unfolding eval_fds_def"], ["proof (prove)\nusing this:\n  (\\<lambda>n. fds_nth h n / nat_power n s) abs_summable_on UNIV\n\ngoal (1 subgoal):\n 1. (\\<Sum>n. fds_nth h n / nat_power n s) =\n    (\\<Sum>\\<^sub>an. fds_nth h n / nat_power n s)", "by (subst infsetsum_nat') auto"], ["proof (state)\nthis:\n  eval_fds h s = (\\<Sum>\\<^sub>an. fds_nth h n / nat_power n s)\n\ngoal (1 subgoal):\n 1. eval_fds h s =\n    - (\\<Sum>\\<^sub>ap | prime p.\n         of_real (ln (real p)) *\n         ((1::'a) / ((1::'a) - fds_nth f p / nat_power p s) - (1::'a)))", "also"], ["proof (state)\nthis:\n  eval_fds h s = (\\<Sum>\\<^sub>an. fds_nth h n / nat_power n s)\n\ngoal (1 subgoal):\n 1. eval_fds h s =\n    - (\\<Sum>\\<^sub>ap | prime p.\n         of_real (ln (real p)) *\n         ((1::'a) / ((1::'a) - fds_nth f p / nat_power p s) - (1::'a)))", "have \"\\<dots> = (\\<Sum>\\<^sub>an \\<in> {n. primepow n}. -fds_nth f n * mangoldt n / nat_power n s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sub>an. fds_nth h n / nat_power n s) =\n    (\\<Sum>\\<^sub>an | primepow n.\n       - fds_nth f n * mangoldt n / nat_power n s)", "unfolding h_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sub>an. fds_nth (fds_deriv f / f) n / nat_power n s) =\n    (\\<Sum>\\<^sub>an | primepow n.\n       - fds_nth f n * mangoldt n / nat_power n s)", "using fds_nth_logderiv_completely_multiplicative[OF assms(2)]"], ["proof (prove)\nusing this:\n  fds_nth f 1 \\<noteq> (0::'a) \\<Longrightarrow>\n  fds_nth (fds_deriv f / f) ?n = - fds_nth f ?n * mangoldt ?n\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sub>an. fds_nth (fds_deriv f / f) n / nat_power n s) =\n    (\\<Sum>\\<^sub>an | primepow n.\n       - fds_nth f n * mangoldt n / nat_power n s)", "by (intro infsetsum_cong_neutral) (auto simp: fds_nth_fds mangoldt_def)"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sub>an. fds_nth h n / nat_power n s) =\n  (\\<Sum>\\<^sub>an | primepow n. - fds_nth f n * mangoldt n / nat_power n s)\n\ngoal (1 subgoal):\n 1. eval_fds h s =\n    - (\\<Sum>\\<^sub>ap | prime p.\n         of_real (ln (real p)) *\n         ((1::'a) / ((1::'a) - fds_nth f p / nat_power p s) - (1::'a)))", "also"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sub>an. fds_nth h n / nat_power n s) =\n  (\\<Sum>\\<^sub>an | primepow n. - fds_nth f n * mangoldt n / nat_power n s)\n\ngoal (1 subgoal):\n 1. eval_fds h s =\n    - (\\<Sum>\\<^sub>ap | prime p.\n         of_real (ln (real p)) *\n         ((1::'a) / ((1::'a) - fds_nth f p / nat_power p s) - (1::'a)))", "have \"\\<dots> = (\\<Sum>\\<^sub>a(p,k)\\<in>(?P \\<times> UNIV). -fds_nth f (p ^ Suc k) * mangoldt (p ^ Suc k) /\n                                            nat_power (p ^ Suc k) s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sub>an | primepow n.\n       - fds_nth f n * mangoldt n / nat_power n s) =\n    (\\<Sum>\\<^sub>a(p, k)\\<in>{p. prime p} \\<times> UNIV.\n       - fds_nth f (p ^ Suc k) * mangoldt (p ^ Suc k) /\n       nat_power (p ^ Suc k) s)", "using bij_betw_primepows"], ["proof (prove)\nusing this:\n  bij_betw (\\<lambda>(p, k). p ^ Suc k) (Collect prime \\<times> UNIV)\n   (Collect primepow)\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sub>an | primepow n.\n       - fds_nth f n * mangoldt n / nat_power n s) =\n    (\\<Sum>\\<^sub>a(p, k)\\<in>{p. prime p} \\<times> UNIV.\n       - fds_nth f (p ^ Suc k) * mangoldt (p ^ Suc k) /\n       nat_power (p ^ Suc k) s)", "unfolding case_prod_unfold"], ["proof (prove)\nusing this:\n  bij_betw (\\<lambda>p. fst p ^ Suc (snd p)) (Collect prime \\<times> UNIV)\n   (Collect primepow)\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sub>an | primepow n.\n       - fds_nth f n * mangoldt n / nat_power n s) =\n    (\\<Sum>\\<^sub>ap\\<in>{p. prime p} \\<times> UNIV.\n       - fds_nth f (fst p ^ Suc (snd p)) * mangoldt (fst p ^ Suc (snd p)) /\n       nat_power (fst p ^ Suc (snd p)) s)", "by (intro infsetsum_reindex_bij_betw [symmetric])"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sub>an | primepow n.\n     - fds_nth f n * mangoldt n / nat_power n s) =\n  (\\<Sum>\\<^sub>a(p, k)\\<in>{p. prime p} \\<times> UNIV.\n     - fds_nth f (p ^ Suc k) * mangoldt (p ^ Suc k) /\n     nat_power (p ^ Suc k) s)\n\ngoal (1 subgoal):\n 1. eval_fds h s =\n    - (\\<Sum>\\<^sub>ap | prime p.\n         of_real (ln (real p)) *\n         ((1::'a) / ((1::'a) - fds_nth f p / nat_power p s) - (1::'a)))", "also"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sub>an | primepow n.\n     - fds_nth f n * mangoldt n / nat_power n s) =\n  (\\<Sum>\\<^sub>a(p, k)\\<in>{p. prime p} \\<times> UNIV.\n     - fds_nth f (p ^ Suc k) * mangoldt (p ^ Suc k) /\n     nat_power (p ^ Suc k) s)\n\ngoal (1 subgoal):\n 1. eval_fds h s =\n    - (\\<Sum>\\<^sub>ap | prime p.\n         of_real (ln (real p)) *\n         ((1::'a) / ((1::'a) - fds_nth f p / nat_power p s) - (1::'a)))", "have \"\\<dots> = (\\<Sum>\\<^sub>a(p,k)\\<in>(?P \\<times> UNIV).\n                     -((fds_nth f p / nat_power p s) ^ Suc k) * of_real (ln (real p)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sub>a(p, k)\\<in>{p. prime p} \\<times> UNIV.\n       - fds_nth f (p ^ Suc k) * mangoldt (p ^ Suc k) /\n       nat_power (p ^ Suc k) s) =\n    (\\<Sum>\\<^sub>a(p, k)\\<in>{p. prime p} \\<times> UNIV.\n       - ((fds_nth f p / nat_power p s) ^ Suc k) * of_real (ln (real p)))", "by (intro infsetsum_cong)\n       (auto simp: f.mult f.power mangoldt_def aprimedivisor_prime_power ln_realpow prime_gt_0_nat\n          nat_power_power_left divide_simps simp del: power_Suc)"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sub>a(p, k)\\<in>{p. prime p} \\<times> UNIV.\n     - fds_nth f (p ^ Suc k) * mangoldt (p ^ Suc k) /\n     nat_power (p ^ Suc k) s) =\n  (\\<Sum>\\<^sub>a(p, k)\\<in>{p. prime p} \\<times> UNIV.\n     - ((fds_nth f p / nat_power p s) ^ Suc k) * of_real (ln (real p)))\n\ngoal (1 subgoal):\n 1. eval_fds h s =\n    - (\\<Sum>\\<^sub>ap | prime p.\n         of_real (ln (real p)) *\n         ((1::'a) / ((1::'a) - fds_nth f p / nat_power p s) - (1::'a)))", "also"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sub>a(p, k)\\<in>{p. prime p} \\<times> UNIV.\n     - fds_nth f (p ^ Suc k) * mangoldt (p ^ Suc k) /\n     nat_power (p ^ Suc k) s) =\n  (\\<Sum>\\<^sub>a(p, k)\\<in>{p. prime p} \\<times> UNIV.\n     - ((fds_nth f p / nat_power p s) ^ Suc k) * of_real (ln (real p)))\n\ngoal (1 subgoal):\n 1. eval_fds h s =\n    - (\\<Sum>\\<^sub>ap | prime p.\n         of_real (ln (real p)) *\n         ((1::'a) / ((1::'a) - fds_nth f p / nat_power p s) - (1::'a)))", "have \"\\<dots> = (\\<Sum>\\<^sub>ap | prime p. \\<Sum>\\<^sub>ak.\n                    - ((fds_nth f p / nat_power p s) ^ Suc k) * of_real (ln (real p)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sub>a(p, k)\\<in>{p. prime p} \\<times> UNIV.\n       - ((fds_nth f p / nat_power p s) ^ Suc k) * of_real (ln (real p))) =\n    (\\<Sum>\\<^sub>ap | prime p.\n       \\<Sum>\\<^sub>ak.\n         - ((fds_nth f p / nat_power p s) ^ Suc k) * of_real (ln (real p)))", "using sum2"], ["proof (prove)\nusing this:\n  (\\<lambda>(p, k).\n      - ((fds_nth f p / nat_power p s) ^ Suc k *\n         of_real (ln (real p)))) abs_summable_on\n  {p. prime p} \\<times> UNIV\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sub>a(p, k)\\<in>{p. prime p} \\<times> UNIV.\n       - ((fds_nth f p / nat_power p s) ^ Suc k) * of_real (ln (real p))) =\n    (\\<Sum>\\<^sub>ap | prime p.\n       \\<Sum>\\<^sub>ak.\n         - ((fds_nth f p / nat_power p s) ^ Suc k) * of_real (ln (real p)))", "by (subst infsetsum_Times) (auto simp: case_prod_unfold)"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sub>a(p, k)\\<in>{p. prime p} \\<times> UNIV.\n     - ((fds_nth f p / nat_power p s) ^ Suc k) * of_real (ln (real p))) =\n  (\\<Sum>\\<^sub>ap | prime p.\n     \\<Sum>\\<^sub>ak.\n       - ((fds_nth f p / nat_power p s) ^ Suc k) * of_real (ln (real p)))\n\ngoal (1 subgoal):\n 1. eval_fds h s =\n    - (\\<Sum>\\<^sub>ap | prime p.\n         of_real (ln (real p)) *\n         ((1::'a) / ((1::'a) - fds_nth f p / nat_power p s) - (1::'a)))", "also"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sub>a(p, k)\\<in>{p. prime p} \\<times> UNIV.\n     - ((fds_nth f p / nat_power p s) ^ Suc k) * of_real (ln (real p))) =\n  (\\<Sum>\\<^sub>ap | prime p.\n     \\<Sum>\\<^sub>ak.\n       - ((fds_nth f p / nat_power p s) ^ Suc k) * of_real (ln (real p)))\n\ngoal (1 subgoal):\n 1. eval_fds h s =\n    - (\\<Sum>\\<^sub>ap | prime p.\n         of_real (ln (real p)) *\n         ((1::'a) / ((1::'a) - fds_nth f p / nat_power p s) - (1::'a)))", "have \"\\<dots> = (\\<Sum>\\<^sub>ap | prime p. -(of_real (ln (real p)) *\n                    (1 / (1 - fds_nth f p / nat_power p s) - 1)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sub>ap | prime p.\n       \\<Sum>\\<^sub>ak.\n         - ((fds_nth f p / nat_power p s) ^ Suc k) *\n         of_real (ln (real p))) =\n    (\\<Sum>\\<^sub>ap | prime p.\n       - (of_real (ln (real p)) *\n          ((1::'a) / ((1::'a) - fds_nth f p / nat_power p s) - (1::'a))))", "using eq"], ["proof (prove)\nusing this:\n  prime ?p \\<Longrightarrow>\n  (\\<Sum>\\<^sub>ak.\n     - ((fds_nth f ?p / nat_power ?p s) ^ Suc k * of_real (ln (real ?p)))) =\n  - (of_real (ln (real ?p)) *\n     ((1::'a) / ((1::'a) - fds_nth f ?p / nat_power ?p s) - (1::'a)))\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sub>ap | prime p.\n       \\<Sum>\\<^sub>ak.\n         - ((fds_nth f p / nat_power p s) ^ Suc k) *\n         of_real (ln (real p))) =\n    (\\<Sum>\\<^sub>ap | prime p.\n       - (of_real (ln (real p)) *\n          ((1::'a) / ((1::'a) - fds_nth f p / nat_power p s) - (1::'a))))", "by (intro infsetsum_cong) auto"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sub>ap | prime p.\n     \\<Sum>\\<^sub>ak.\n       - ((fds_nth f p / nat_power p s) ^ Suc k) * of_real (ln (real p))) =\n  (\\<Sum>\\<^sub>ap | prime p.\n     - (of_real (ln (real p)) *\n        ((1::'a) / ((1::'a) - fds_nth f p / nat_power p s) - (1::'a))))\n\ngoal (1 subgoal):\n 1. eval_fds h s =\n    - (\\<Sum>\\<^sub>ap | prime p.\n         of_real (ln (real p)) *\n         ((1::'a) / ((1::'a) - fds_nth f p / nat_power p s) - (1::'a)))", "finally"], ["proof (chain)\npicking this:\n  eval_fds h s =\n  (\\<Sum>\\<^sub>ap | prime p.\n     - (of_real (ln (real p)) *\n        ((1::'a) / ((1::'a) - fds_nth f p / nat_power p s) - (1::'a))))", "show ?th2"], ["proof (prove)\nusing this:\n  eval_fds h s =\n  (\\<Sum>\\<^sub>ap | prime p.\n     - (of_real (ln (real p)) *\n        ((1::'a) / ((1::'a) - fds_nth f p / nat_power p s) - (1::'a))))\n\ngoal (1 subgoal):\n 1. eval_fds h s =\n    - (\\<Sum>\\<^sub>ap | prime p.\n         of_real (ln (real p)) *\n         ((1::'a) / ((1::'a) - fds_nth f p / nat_power p s) - (1::'a)))", "by (subst (asm) infsetsum_uminus)"], ["proof (state)\nthis:\n  eval_fds h s =\n  - (\\<Sum>\\<^sub>ap | prime p.\n       of_real (ln (real p)) *\n       ((1::'a) / ((1::'a) - fds_nth f p / nat_power p s) - (1::'a)))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma eval_fds_logderiv_zeta:\n  assumes \"Re s > 1\"\n  shows  \"(\\<lambda>p. of_real (ln (real p)) / (p powr s - 1))\n            abs_summable_on {p. prime p}\" (is ?th1)\n    and  \"deriv zeta s / zeta s =\n            -(\\<Sum>\\<^sub>ap | prime p. of_real (ln (real p)) / (p powr s - 1))\" (is ?th2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>p.\n        complex_of_real (ln (real p)) /\n        (of_nat p powr s - 1)) abs_summable_on\n    {p. prime p} &&&\n    deriv zeta s / zeta s =\n    - (\\<Sum>\\<^sub>ap | prime p.\n         complex_of_real (ln (real p)) / (of_nat p powr s - 1))", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<lambda>p.\n        complex_of_real (ln (real p)) /\n        (of_nat p powr s - 1)) abs_summable_on\n    {p. prime p}\n 2. deriv zeta s / zeta s =\n    - (\\<Sum>\\<^sub>ap | prime p.\n         complex_of_real (ln (real p)) / (of_nat p powr s - 1))", "have *: \"completely_multiplicative_function (fds_nth fds_zeta :: _ \\<Rightarrow> complex)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. completely_multiplicative_function (fds_nth fds_zeta)", "by standard auto"], ["proof (state)\nthis:\n  completely_multiplicative_function (fds_nth fds_zeta)\n\ngoal (2 subgoals):\n 1. (\\<lambda>p.\n        complex_of_real (ln (real p)) /\n        (of_nat p powr s - 1)) abs_summable_on\n    {p. prime p}\n 2. deriv zeta s / zeta s =\n    - (\\<Sum>\\<^sub>ap | prime p.\n         complex_of_real (ln (real p)) / (of_nat p powr s - 1))", "note abscissa = le_less_trans[OF abs_conv_abscissa_completely_multiplicative_log_deriv[OF *]]"], ["proof (state)\nthis:\n  \\<lbrakk>fds_nth fds_zeta 1 \\<noteq> 0;\n   abs_conv_abscissa fds_zeta < ?z\\<rbrakk>\n  \\<Longrightarrow> abs_conv_abscissa (fds_deriv fds_zeta / fds_zeta) < ?z\n\ngoal (2 subgoals):\n 1. (\\<lambda>p.\n        complex_of_real (ln (real p)) /\n        (of_nat p powr s - 1)) abs_summable_on\n    {p. prime p}\n 2. deriv zeta s / zeta s =\n    - (\\<Sum>\\<^sub>ap | prime p.\n         complex_of_real (ln (real p)) / (of_nat p powr s - 1))", "have \"(\\<lambda>p. ln (real p) * (1 / (1 - fds_nth fds_zeta p / p powr s) - 1))\n           abs_summable_on {p. prime p}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>p.\n        complex_of_real (ln (real p)) *\n        (1 / (1 - fds_nth fds_zeta p / of_nat p powr s) -\n         1)) abs_summable_on\n    {p. prime p}", "using eval_fds_logderiv_completely_multiplicative[OF *, of s] assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>fds_nth fds_zeta 1 \\<noteq> 0;\n   abs_conv_abscissa fds_zeta < ereal (s \\<bullet> 1)\\<rbrakk>\n  \\<Longrightarrow> (\\<lambda>p.\n                        complex_of_real (ln (real p)) *\n                        (1 / (1 - fds_nth fds_zeta p / nat_power p s) -\n                         1)) abs_summable_on\n                    {p. prime p}\n  \\<lbrakk>fds_nth fds_zeta 1 \\<noteq> 0;\n   abs_conv_abscissa fds_zeta < ereal (s \\<bullet> 1)\\<rbrakk>\n  \\<Longrightarrow> eval_fds (fds_deriv fds_zeta / fds_zeta) s =\n                    - (\\<Sum>\\<^sub>ap | prime p.\n                         complex_of_real (ln (real p)) *\n                         (1 / (1 - fds_nth fds_zeta p / nat_power p s) - 1))\n  1 < Re s\n\ngoal (1 subgoal):\n 1. (\\<lambda>p.\n        complex_of_real (ln (real p)) *\n        (1 / (1 - fds_nth fds_zeta p / of_nat p powr s) -\n         1)) abs_summable_on\n    {p. prime p}", "by auto"], ["proof (state)\nthis:\n  (\\<lambda>p.\n      complex_of_real (ln (real p)) *\n      (1 / (1 - fds_nth fds_zeta p / of_nat p powr s) - 1)) abs_summable_on\n  {p. prime p}\n\ngoal (2 subgoals):\n 1. (\\<lambda>p.\n        complex_of_real (ln (real p)) /\n        (of_nat p powr s - 1)) abs_summable_on\n    {p. prime p}\n 2. deriv zeta s / zeta s =\n    - (\\<Sum>\\<^sub>ap | prime p.\n         complex_of_real (ln (real p)) / (of_nat p powr s - 1))", "also"], ["proof (state)\nthis:\n  (\\<lambda>p.\n      complex_of_real (ln (real p)) *\n      (1 / (1 - fds_nth fds_zeta p / of_nat p powr s) - 1)) abs_summable_on\n  {p. prime p}\n\ngoal (2 subgoals):\n 1. (\\<lambda>p.\n        complex_of_real (ln (real p)) /\n        (of_nat p powr s - 1)) abs_summable_on\n    {p. prime p}\n 2. deriv zeta s / zeta s =\n    - (\\<Sum>\\<^sub>ap | prime p.\n         complex_of_real (ln (real p)) / (of_nat p powr s - 1))", "have \"?this \\<longleftrightarrow> (\\<lambda>p. ln (real p) / (p powr s - 1)) abs_summable_on {p. prime p}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>p.\n         complex_of_real (ln (real p)) *\n         (1 / (1 - fds_nth fds_zeta p / of_nat p powr s) -\n          1)) abs_summable_on\n     {p. prime p}) =\n    ((\\<lambda>p.\n         complex_of_real (ln (real p)) /\n         (of_nat p powr s - 1)) abs_summable_on\n     {p. prime p})", "using assms"], ["proof (prove)\nusing this:\n  1 < Re s\n\ngoal (1 subgoal):\n 1. ((\\<lambda>p.\n         complex_of_real (ln (real p)) *\n         (1 / (1 - fds_nth fds_zeta p / of_nat p powr s) -\n          1)) abs_summable_on\n     {p. prime p}) =\n    ((\\<lambda>p.\n         complex_of_real (ln (real p)) /\n         (of_nat p powr s - 1)) abs_summable_on\n     {p. prime p})", "by (intro abs_summable_on_cong) (auto simp: fds_nth_zeta divide_simps dest: prime_gt_1_nat)"], ["proof (state)\nthis:\n  ((\\<lambda>p.\n       complex_of_real (ln (real p)) *\n       (1 / (1 - fds_nth fds_zeta p / of_nat p powr s) - 1)) abs_summable_on\n   {p. prime p}) =\n  ((\\<lambda>p.\n       complex_of_real (ln (real p)) /\n       (of_nat p powr s - 1)) abs_summable_on\n   {p. prime p})\n\ngoal (2 subgoals):\n 1. (\\<lambda>p.\n        complex_of_real (ln (real p)) /\n        (of_nat p powr s - 1)) abs_summable_on\n    {p. prime p}\n 2. deriv zeta s / zeta s =\n    - (\\<Sum>\\<^sub>ap | prime p.\n         complex_of_real (ln (real p)) / (of_nat p powr s - 1))", "finally"], ["proof (chain)\npicking this:\n  (\\<lambda>p.\n      complex_of_real (ln (real p)) / (of_nat p powr s - 1)) abs_summable_on\n  {p. prime p}", "show ?th1"], ["proof (prove)\nusing this:\n  (\\<lambda>p.\n      complex_of_real (ln (real p)) / (of_nat p powr s - 1)) abs_summable_on\n  {p. prime p}\n\ngoal (1 subgoal):\n 1. (\\<lambda>p.\n        complex_of_real (ln (real p)) /\n        (of_nat p powr s - 1)) abs_summable_on\n    {p. prime p}", "."], ["proof (state)\nthis:\n  (\\<lambda>p.\n      complex_of_real (ln (real p)) / (of_nat p powr s - 1)) abs_summable_on\n  {p. prime p}\n\ngoal (1 subgoal):\n 1. deriv zeta s / zeta s =\n    - (\\<Sum>\\<^sub>ap | prime p.\n         complex_of_real (ln (real p)) / (of_nat p powr s - 1))", "from assms"], ["proof (chain)\npicking this:\n  1 < Re s", "have ev: \"eventually (\\<lambda>z. z \\<in> {z. Re z > 1}) (nhds s)\""], ["proof (prove)\nusing this:\n  1 < Re s\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F z in nhds s. z \\<in> {z. 1 < Re z}", "by (intro eventually_nhds_in_open open_halfspace_Re_gt) auto"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F z in nhds s. z \\<in> {z. 1 < Re z}\n\ngoal (1 subgoal):\n 1. deriv zeta s / zeta s =\n    - (\\<Sum>\\<^sub>ap | prime p.\n         complex_of_real (ln (real p)) / (of_nat p powr s - 1))", "have \"deriv zeta s = deriv (eval_fds fds_zeta) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. deriv zeta s = deriv (eval_fds fds_zeta) s", "by (intro deriv_cong_ev[OF eventually_mono[OF ev]]) (auto simp: eval_fds_zeta)"], ["proof (state)\nthis:\n  deriv zeta s = deriv (eval_fds fds_zeta) s\n\ngoal (1 subgoal):\n 1. deriv zeta s / zeta s =\n    - (\\<Sum>\\<^sub>ap | prime p.\n         complex_of_real (ln (real p)) / (of_nat p powr s - 1))", "also"], ["proof (state)\nthis:\n  deriv zeta s = deriv (eval_fds fds_zeta) s\n\ngoal (1 subgoal):\n 1. deriv zeta s / zeta s =\n    - (\\<Sum>\\<^sub>ap | prime p.\n         complex_of_real (ln (real p)) / (of_nat p powr s - 1))", "have \"deriv (eval_fds fds_zeta) s / zeta s = eval_fds (fds_deriv fds_zeta / fds_zeta) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. deriv (eval_fds fds_zeta) s / zeta s =\n    eval_fds (fds_deriv fds_zeta / fds_zeta) s", "using assms zeta_Re_gt_1_nonzero[of s]"], ["proof (prove)\nusing this:\n  1 < Re s\n  1 < Re s \\<Longrightarrow> zeta s \\<noteq> 0\n\ngoal (1 subgoal):\n 1. deriv (eval_fds fds_zeta) s / zeta s =\n    eval_fds (fds_deriv fds_zeta / fds_zeta) s", "by (subst eval_fds_log_deriv) (auto simp: eval_fds_zeta eval_fds_deriv intro!: abscissa)"], ["proof (state)\nthis:\n  deriv (eval_fds fds_zeta) s / zeta s =\n  eval_fds (fds_deriv fds_zeta / fds_zeta) s\n\ngoal (1 subgoal):\n 1. deriv zeta s / zeta s =\n    - (\\<Sum>\\<^sub>ap | prime p.\n         complex_of_real (ln (real p)) / (of_nat p powr s - 1))", "also"], ["proof (state)\nthis:\n  deriv (eval_fds fds_zeta) s / zeta s =\n  eval_fds (fds_deriv fds_zeta / fds_zeta) s\n\ngoal (1 subgoal):\n 1. deriv zeta s / zeta s =\n    - (\\<Sum>\\<^sub>ap | prime p.\n         complex_of_real (ln (real p)) / (of_nat p powr s - 1))", "have \"eval_fds (fds_deriv fds_zeta / fds_zeta) s =\n               -(\\<Sum>\\<^sub>ap | prime p. ln (real p) * (1 / (1 - fds_nth fds_zeta p / p powr s) - 1))\"\n    (is \"_ = -?S\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_fds (fds_deriv fds_zeta / fds_zeta) s =\n    - (\\<Sum>\\<^sub>ap | prime p.\n         complex_of_real (ln (real p)) *\n         (1 / (1 - fds_nth fds_zeta p / of_nat p powr s) - 1))", "using eval_fds_logderiv_completely_multiplicative[OF *, of s] assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>fds_nth fds_zeta 1 \\<noteq> 0;\n   abs_conv_abscissa fds_zeta < ereal (s \\<bullet> 1)\\<rbrakk>\n  \\<Longrightarrow> (\\<lambda>p.\n                        complex_of_real (ln (real p)) *\n                        (1 / (1 - fds_nth fds_zeta p / nat_power p s) -\n                         1)) abs_summable_on\n                    {p. prime p}\n  \\<lbrakk>fds_nth fds_zeta 1 \\<noteq> 0;\n   abs_conv_abscissa fds_zeta < ereal (s \\<bullet> 1)\\<rbrakk>\n  \\<Longrightarrow> eval_fds (fds_deriv fds_zeta / fds_zeta) s =\n                    - (\\<Sum>\\<^sub>ap | prime p.\n                         complex_of_real (ln (real p)) *\n                         (1 / (1 - fds_nth fds_zeta p / nat_power p s) - 1))\n  1 < Re s\n\ngoal (1 subgoal):\n 1. eval_fds (fds_deriv fds_zeta / fds_zeta) s =\n    - (\\<Sum>\\<^sub>ap | prime p.\n         complex_of_real (ln (real p)) *\n         (1 / (1 - fds_nth fds_zeta p / of_nat p powr s) - 1))", "by auto"], ["proof (state)\nthis:\n  eval_fds (fds_deriv fds_zeta / fds_zeta) s =\n  - (\\<Sum>\\<^sub>ap | prime p.\n       complex_of_real (ln (real p)) *\n       (1 / (1 - fds_nth fds_zeta p / of_nat p powr s) - 1))\n\ngoal (1 subgoal):\n 1. deriv zeta s / zeta s =\n    - (\\<Sum>\\<^sub>ap | prime p.\n         complex_of_real (ln (real p)) / (of_nat p powr s - 1))", "also"], ["proof (state)\nthis:\n  eval_fds (fds_deriv fds_zeta / fds_zeta) s =\n  - (\\<Sum>\\<^sub>ap | prime p.\n       complex_of_real (ln (real p)) *\n       (1 / (1 - fds_nth fds_zeta p / of_nat p powr s) - 1))\n\ngoal (1 subgoal):\n 1. deriv zeta s / zeta s =\n    - (\\<Sum>\\<^sub>ap | prime p.\n         complex_of_real (ln (real p)) / (of_nat p powr s - 1))", "have \"?S = (\\<Sum>\\<^sub>ap | prime p. ln (real p) / (p powr s - 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sub>ap | prime p.\n       complex_of_real (ln (real p)) *\n       (1 / (1 - fds_nth fds_zeta p / of_nat p powr s) - 1)) =\n    (\\<Sum>\\<^sub>ap | prime p.\n       complex_of_real (ln (real p)) / (of_nat p powr s - 1))", "using assms"], ["proof (prove)\nusing this:\n  1 < Re s\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sub>ap | prime p.\n       complex_of_real (ln (real p)) *\n       (1 / (1 - fds_nth fds_zeta p / of_nat p powr s) - 1)) =\n    (\\<Sum>\\<^sub>ap | prime p.\n       complex_of_real (ln (real p)) / (of_nat p powr s - 1))", "by (intro infsetsum_cong) (auto simp: fds_nth_zeta divide_simps dest: prime_gt_1_nat)"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sub>ap | prime p.\n     complex_of_real (ln (real p)) *\n     (1 / (1 - fds_nth fds_zeta p / of_nat p powr s) - 1)) =\n  (\\<Sum>\\<^sub>ap | prime p.\n     complex_of_real (ln (real p)) / (of_nat p powr s - 1))\n\ngoal (1 subgoal):\n 1. deriv zeta s / zeta s =\n    - (\\<Sum>\\<^sub>ap | prime p.\n         complex_of_real (ln (real p)) / (of_nat p powr s - 1))", "finally"], ["proof (chain)\npicking this:\n  deriv zeta s / zeta s =\n  - (\\<Sum>\\<^sub>ap | prime p.\n       complex_of_real (ln (real p)) / (of_nat p powr s - 1))", "show ?th2"], ["proof (prove)\nusing this:\n  deriv zeta s / zeta s =\n  - (\\<Sum>\\<^sub>ap | prime p.\n       complex_of_real (ln (real p)) / (of_nat p powr s - 1))\n\ngoal (1 subgoal):\n 1. deriv zeta s / zeta s =\n    - (\\<Sum>\\<^sub>ap | prime p.\n         complex_of_real (ln (real p)) / (of_nat p powr s - 1))", "."], ["proof (state)\nthis:\n  deriv zeta s / zeta s =\n  - (\\<Sum>\\<^sub>ap | prime p.\n       complex_of_real (ln (real p)) / (of_nat p powr s - 1))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sums_logderiv_zeta:\n  assumes \"Re s > 1\"\n  shows   \"(\\<lambda>p. if prime p then of_real (ln (real p)) / (of_nat p powr s - 1) else 0) sums\n             -(deriv zeta s / zeta s)\" (is \"?f sums _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>p.\n        if prime p\n        then complex_of_real (ln (real p)) / (of_nat p powr s - 1)\n        else 0) sums\n    - (deriv zeta s / zeta s)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<lambda>p.\n        if prime p\n        then complex_of_real (ln (real p)) / (of_nat p powr s - 1)\n        else 0) sums\n    - (deriv zeta s / zeta s)", "note * = eval_fds_logderiv_zeta[OF assms]"], ["proof (state)\nthis:\n  (\\<lambda>p.\n      complex_of_real (ln (real p)) / (of_nat p powr s - 1)) abs_summable_on\n  {p. prime p}\n  deriv zeta s / zeta s =\n  - (\\<Sum>\\<^sub>ap | prime p.\n       complex_of_real (ln (real p)) / (of_nat p powr s - 1))\n\ngoal (1 subgoal):\n 1. (\\<lambda>p.\n        if prime p\n        then complex_of_real (ln (real p)) / (of_nat p powr s - 1)\n        else 0) sums\n    - (deriv zeta s / zeta s)", "from sums_infsetsum_nat[OF *(1)] and *(2)"], ["proof (chain)\npicking this:\n  (\\<lambda>n.\n      if n \\<in> {p. prime p}\n      then complex_of_real (ln (real n)) / (of_nat n powr s - 1)\n      else 0) sums\n  (\\<Sum>\\<^sub>ap | prime p.\n     complex_of_real (ln (real p)) / (of_nat p powr s - 1))\n  deriv zeta s / zeta s =\n  - (\\<Sum>\\<^sub>ap | prime p.\n       complex_of_real (ln (real p)) / (of_nat p powr s - 1))", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<lambda>n.\n      if n \\<in> {p. prime p}\n      then complex_of_real (ln (real n)) / (of_nat n powr s - 1)\n      else 0) sums\n  (\\<Sum>\\<^sub>ap | prime p.\n     complex_of_real (ln (real p)) / (of_nat p powr s - 1))\n  deriv zeta s / zeta s =\n  - (\\<Sum>\\<^sub>ap | prime p.\n       complex_of_real (ln (real p)) / (of_nat p powr s - 1))\n\ngoal (1 subgoal):\n 1. (\\<lambda>p.\n        if prime p\n        then complex_of_real (ln (real p)) / (of_nat p powr s - 1)\n        else 0) sums\n    - (deriv zeta s / zeta s)", "by simp"], ["proof (state)\nthis:\n  (\\<lambda>p.\n      if prime p then complex_of_real (ln (real p)) / (of_nat p powr s - 1)\n      else 0) sums\n  - (deriv zeta s / zeta s)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma abs_conv_abscissa_diff_le:\n  \"abs_conv_abscissa (f - g :: 'a :: dirichlet_series fds) \\<le>\n     max (abs_conv_abscissa f) (abs_conv_abscissa g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. abs_conv_abscissa (f - g)\n    \\<le> max (abs_conv_abscissa f) (abs_conv_abscissa g)", "using abs_conv_abscissa_add_le[of f \"-g\"]"], ["proof (prove)\nusing this:\n  abs_conv_abscissa (f + - g)\n  \\<le> max (abs_conv_abscissa f) (abs_conv_abscissa (- g))\n\ngoal (1 subgoal):\n 1. abs_conv_abscissa (f - g)\n    \\<le> max (abs_conv_abscissa f) (abs_conv_abscissa g)", "by auto"], ["", "lemma abs_conv_abscissa_diff_leI:\n  \"abs_conv_abscissa (f :: 'a :: dirichlet_series fds) \\<le> d \\<Longrightarrow> abs_conv_abscissa g \\<le> d \\<Longrightarrow>\n     abs_conv_abscissa (f - g) \\<le> d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>abs_conv_abscissa f \\<le> d;\n     abs_conv_abscissa g \\<le> d\\<rbrakk>\n    \\<Longrightarrow> abs_conv_abscissa (f - g) \\<le> d", "using abs_conv_abscissa_diff_le[of f g]"], ["proof (prove)\nusing this:\n  abs_conv_abscissa (f - g)\n  \\<le> max (abs_conv_abscissa f) (abs_conv_abscissa g)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>abs_conv_abscissa f \\<le> d;\n     abs_conv_abscissa g \\<le> d\\<rbrakk>\n    \\<Longrightarrow> abs_conv_abscissa (f - g) \\<le> d", "by (auto simp: le_max_iff_disj)"], ["", "lemma range_add_nat: \"range (\\<lambda>n. n + c) = {(c::nat)..}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. range (\\<lambda>n. n + c) = {c..}", "proof safe"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x n. n \\<in> UNIV \\<Longrightarrow> c \\<le> n + c\n 2. \\<And>x. c \\<le> x \\<Longrightarrow> x \\<in> range (\\<lambda>n. n + c)", "fix x"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x n. n \\<in> UNIV \\<Longrightarrow> c \\<le> n + c\n 2. \\<And>x. c \\<le> x \\<Longrightarrow> x \\<in> range (\\<lambda>n. n + c)", "assume \"x \\<ge> c\""], ["proof (state)\nthis:\n  c \\<le> x\n\ngoal (2 subgoals):\n 1. \\<And>x n. n \\<in> UNIV \\<Longrightarrow> c \\<le> n + c\n 2. \\<And>x. c \\<le> x \\<Longrightarrow> x \\<in> range (\\<lambda>n. n + c)", "hence \"x = x - c + c\""], ["proof (prove)\nusing this:\n  c \\<le> x\n\ngoal (1 subgoal):\n 1. x = x - c + c", "by simp"], ["proof (state)\nthis:\n  x = x - c + c\n\ngoal (2 subgoals):\n 1. \\<And>x n. n \\<in> UNIV \\<Longrightarrow> c \\<le> n + c\n 2. \\<And>x. c \\<le> x \\<Longrightarrow> x \\<in> range (\\<lambda>n. n + c)", "thus \"x \\<in> range (\\<lambda>n. n + c)\""], ["proof (prove)\nusing this:\n  x = x - c + c\n\ngoal (1 subgoal):\n 1. x \\<in> range (\\<lambda>n. n + c)", "by blast"], ["proof (state)\nthis:\n  x \\<in> range (\\<lambda>n. n + c)\n\ngoal (1 subgoal):\n 1. \\<And>x n. n \\<in> UNIV \\<Longrightarrow> c \\<le> n + c", "qed auto"], ["", "lemma abs_summable_hurwitz_zeta:\n  assumes \"Re s > 1\" \"a + real b > 0\"\n  shows   \"(\\<lambda>n. 1 / (of_nat n + a) powr s) abs_summable_on {b..}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n. 1 / complex_of_real (real n + a) powr s) abs_summable_on\n    {b..}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<lambda>n. 1 / complex_of_real (real n + a) powr s) abs_summable_on\n    {b..}", "from assms"], ["proof (chain)\npicking this:\n  1 < Re s\n  0 < a + real b", "have \"summable (\\<lambda>n. cmod (1 / (of_nat (n + b) + a) powr s))\""], ["proof (prove)\nusing this:\n  1 < Re s\n  0 < a + real b\n\ngoal (1 subgoal):\n 1. summable\n     (\\<lambda>n. cmod (1 / complex_of_real (real (n + b) + a) powr s))", "using summable_hurwitz_zeta_real[of \"Re s\" \"a + b\"]"], ["proof (prove)\nusing this:\n  1 < Re s\n  0 < a + real b\n  \\<lbrakk>1 < Re s; 0 < a + real b\\<rbrakk>\n  \\<Longrightarrow> summable\n                     (\\<lambda>n. (real n + (a + real b)) powr - Re s)\n\ngoal (1 subgoal):\n 1. summable\n     (\\<lambda>n. cmod (1 / complex_of_real (real (n + b) + a) powr s))", "by (auto simp: norm_divide powr_minus field_simps norm_powr_real_powr)"], ["proof (state)\nthis:\n  summable\n   (\\<lambda>n. cmod (1 / complex_of_real (real (n + b) + a) powr s))\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. 1 / complex_of_real (real n + a) powr s) abs_summable_on\n    {b..}", "hence \"(\\<lambda>n. 1 / (of_nat (n + b) + a) powr s) abs_summable_on UNIV\""], ["proof (prove)\nusing this:\n  summable\n   (\\<lambda>n. cmod (1 / complex_of_real (real (n + b) + a) powr s))\n\ngoal (1 subgoal):\n 1. (\\<lambda>n.\n        1 / complex_of_real (real (n + b) + a) powr s) abs_summable_on\n    UNIV", "by (auto simp: abs_summable_on_nat_iff' add_ac)"], ["proof (state)\nthis:\n  (\\<lambda>n.\n      1 / complex_of_real (real (n + b) + a) powr s) abs_summable_on\n  UNIV\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. 1 / complex_of_real (real n + a) powr s) abs_summable_on\n    {b..}", "also"], ["proof (state)\nthis:\n  (\\<lambda>n.\n      1 / complex_of_real (real (n + b) + a) powr s) abs_summable_on\n  UNIV\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. 1 / complex_of_real (real n + a) powr s) abs_summable_on\n    {b..}", "have \"?this \\<longleftrightarrow> (\\<lambda>n. 1 / (of_nat n + a) powr s) abs_summable_on range (\\<lambda>n. n + b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>n.\n         1 / complex_of_real (real (n + b) + a) powr s) abs_summable_on\n     UNIV) =\n    ((\\<lambda>n. 1 / complex_of_real (real n + a) powr s) abs_summable_on\n     range (\\<lambda>n. n + b))", "by (rule abs_summable_on_reindex_iff) auto"], ["proof (state)\nthis:\n  ((\\<lambda>n.\n       1 / complex_of_real (real (n + b) + a) powr s) abs_summable_on\n   UNIV) =\n  ((\\<lambda>n. 1 / complex_of_real (real n + a) powr s) abs_summable_on\n   range (\\<lambda>n. n + b))\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. 1 / complex_of_real (real n + a) powr s) abs_summable_on\n    {b..}", "also"], ["proof (state)\nthis:\n  ((\\<lambda>n.\n       1 / complex_of_real (real (n + b) + a) powr s) abs_summable_on\n   UNIV) =\n  ((\\<lambda>n. 1 / complex_of_real (real n + a) powr s) abs_summable_on\n   range (\\<lambda>n. n + b))\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. 1 / complex_of_real (real n + a) powr s) abs_summable_on\n    {b..}", "have \"range (\\<lambda>n. n + b) = {b..}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. range (\\<lambda>n. n + b) = {b..}", "by (rule range_add_nat)"], ["proof (state)\nthis:\n  range (\\<lambda>n. n + b) = {b..}\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. 1 / complex_of_real (real n + a) powr s) abs_summable_on\n    {b..}", "finally"], ["proof (chain)\npicking this:\n  (\\<lambda>n. 1 / complex_of_real (real n + a) powr s) abs_summable_on\n  {b..}", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<lambda>n. 1 / complex_of_real (real n + a) powr s) abs_summable_on\n  {b..}\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. 1 / complex_of_real (real n + a) powr s) abs_summable_on\n    {b..}", "."], ["proof (state)\nthis:\n  (\\<lambda>n. 1 / complex_of_real (real n + a) powr s) abs_summable_on\n  {b..}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma hurwitz_zeta_nat_conv_infsetsum:\n  assumes \"a > 0\" and \"Re s > 1\"\n  shows   \"hurwitz_zeta (real a) s = (\\<Sum>\\<^sub>an. of_nat (n + a) powr -s)\"\n          \"hurwitz_zeta (real a) s = (\\<Sum>\\<^sub>an\\<in>{a..}. of_nat n powr -s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hurwitz_zeta (real a) s = (\\<Sum>\\<^sub>an. of_nat (n + a) powr - s) &&&\n    hurwitz_zeta (real a) s = (\\<Sum>\\<^sub>an\\<in>{a..}. of_nat n powr - s)", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. hurwitz_zeta (real a) s = (\\<Sum>\\<^sub>an. of_nat (n + a) powr - s)\n 2. hurwitz_zeta (real a) s = (\\<Sum>\\<^sub>an\\<in>{a..}. of_nat n powr - s)", "have \"hurwitz_zeta (real a) s = (\\<Sum>n. of_nat (n + a) powr -s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hurwitz_zeta (real a) s = (\\<Sum>n. of_nat (n + a) powr - s)", "using assms"], ["proof (prove)\nusing this:\n  0 < a\n  1 < Re s\n\ngoal (1 subgoal):\n 1. hurwitz_zeta (real a) s = (\\<Sum>n. of_nat (n + a) powr - s)", "by (subst hurwitz_zeta_conv_suminf) auto"], ["proof (state)\nthis:\n  hurwitz_zeta (real a) s = (\\<Sum>n. of_nat (n + a) powr - s)\n\ngoal (2 subgoals):\n 1. hurwitz_zeta (real a) s = (\\<Sum>\\<^sub>an. of_nat (n + a) powr - s)\n 2. hurwitz_zeta (real a) s = (\\<Sum>\\<^sub>an\\<in>{a..}. of_nat n powr - s)", "also"], ["proof (state)\nthis:\n  hurwitz_zeta (real a) s = (\\<Sum>n. of_nat (n + a) powr - s)\n\ngoal (2 subgoals):\n 1. hurwitz_zeta (real a) s = (\\<Sum>\\<^sub>an. of_nat (n + a) powr - s)\n 2. hurwitz_zeta (real a) s = (\\<Sum>\\<^sub>an\\<in>{a..}. of_nat n powr - s)", "have \"\\<dots> = (\\<Sum>\\<^sub>an. of_nat (n + a) powr -s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>n. of_nat (n + a) powr - s) =\n    (\\<Sum>\\<^sub>an. of_nat (n + a) powr - s)", "using abs_summable_hurwitz_zeta[of s a 0] assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>1 < Re s; 0 < real a + real 0\\<rbrakk>\n  \\<Longrightarrow> (\\<lambda>n.\n                        1 /\n                        complex_of_real (real n + real a) powr\n                        s) abs_summable_on\n                    {0..}\n  0 < a\n  1 < Re s\n\ngoal (1 subgoal):\n 1. (\\<Sum>n. of_nat (n + a) powr - s) =\n    (\\<Sum>\\<^sub>an. of_nat (n + a) powr - s)", "by (intro infsetsum_nat' [symmetric]) (auto simp: powr_minus field_simps)"], ["proof (state)\nthis:\n  (\\<Sum>n. of_nat (n + a) powr - s) =\n  (\\<Sum>\\<^sub>an. of_nat (n + a) powr - s)\n\ngoal (2 subgoals):\n 1. hurwitz_zeta (real a) s = (\\<Sum>\\<^sub>an. of_nat (n + a) powr - s)\n 2. hurwitz_zeta (real a) s = (\\<Sum>\\<^sub>an\\<in>{a..}. of_nat n powr - s)", "finally"], ["proof (chain)\npicking this:\n  hurwitz_zeta (real a) s = (\\<Sum>\\<^sub>an. of_nat (n + a) powr - s)", "show \"hurwitz_zeta (real a) s = (\\<Sum>\\<^sub>an. of_nat (n + a) powr -s)\""], ["proof (prove)\nusing this:\n  hurwitz_zeta (real a) s = (\\<Sum>\\<^sub>an. of_nat (n + a) powr - s)\n\ngoal (1 subgoal):\n 1. hurwitz_zeta (real a) s = (\\<Sum>\\<^sub>an. of_nat (n + a) powr - s)", "."], ["proof (state)\nthis:\n  hurwitz_zeta (real a) s = (\\<Sum>\\<^sub>an. of_nat (n + a) powr - s)\n\ngoal (1 subgoal):\n 1. hurwitz_zeta (real a) s = (\\<Sum>\\<^sub>an\\<in>{a..}. of_nat n powr - s)", "also"], ["proof (state)\nthis:\n  hurwitz_zeta (real a) s = (\\<Sum>\\<^sub>an. of_nat (n + a) powr - s)\n\ngoal (1 subgoal):\n 1. hurwitz_zeta (real a) s = (\\<Sum>\\<^sub>an\\<in>{a..}. of_nat n powr - s)", "have \"\\<dots> = (\\<Sum>\\<^sub>an\\<in>range (\\<lambda>n. n + a). of_nat n powr -s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sub>an. of_nat (n + a) powr - s) =\n    (\\<Sum>\\<^sub>an\\<in>range (\\<lambda>n. n + a). of_nat n powr - s)", "by (rule infsetsum_reindex [symmetric]) auto"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sub>an. of_nat (n + a) powr - s) =\n  (\\<Sum>\\<^sub>an\\<in>range (\\<lambda>n. n + a). of_nat n powr - s)\n\ngoal (1 subgoal):\n 1. hurwitz_zeta (real a) s = (\\<Sum>\\<^sub>an\\<in>{a..}. of_nat n powr - s)", "also"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sub>an. of_nat (n + a) powr - s) =\n  (\\<Sum>\\<^sub>an\\<in>range (\\<lambda>n. n + a). of_nat n powr - s)\n\ngoal (1 subgoal):\n 1. hurwitz_zeta (real a) s = (\\<Sum>\\<^sub>an\\<in>{a..}. of_nat n powr - s)", "have \"range (\\<lambda>n. n + a) = {a..}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. range (\\<lambda>n. n + a) = {a..}", "by (rule range_add_nat)"], ["proof (state)\nthis:\n  range (\\<lambda>n. n + a) = {a..}\n\ngoal (1 subgoal):\n 1. hurwitz_zeta (real a) s = (\\<Sum>\\<^sub>an\\<in>{a..}. of_nat n powr - s)", "finally"], ["proof (chain)\npicking this:\n  hurwitz_zeta (real a) s = (\\<Sum>\\<^sub>an\\<in>{a..}. of_nat n powr - s)", "show \"hurwitz_zeta (real a) s = (\\<Sum>\\<^sub>an\\<in>{a..}. of_nat n powr -s)\""], ["proof (prove)\nusing this:\n  hurwitz_zeta (real a) s = (\\<Sum>\\<^sub>an\\<in>{a..}. of_nat n powr - s)\n\ngoal (1 subgoal):\n 1. hurwitz_zeta (real a) s = (\\<Sum>\\<^sub>an\\<in>{a..}. of_nat n powr - s)", "."], ["proof (state)\nthis:\n  hurwitz_zeta (real a) s = (\\<Sum>\\<^sub>an\\<in>{a..}. of_nat n powr - s)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma continuous_on_pre_zeta [continuous_intros]:\n  assumes \"continuous_on A f\" \"a > 0\"\n  shows   \"continuous_on A (\\<lambda>x. pre_zeta a (f x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_on A (\\<lambda>x. pre_zeta a (f x))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. continuous_on A (\\<lambda>x. pre_zeta a (f x))", "from assms"], ["proof (chain)\npicking this:\n  continuous_on A f\n  0 < a", "have \"continuous_on UNIV (pre_zeta a)\""], ["proof (prove)\nusing this:\n  continuous_on A f\n  0 < a\n\ngoal (1 subgoal):\n 1. continuous_on UNIV (pre_zeta a)", "by (intro holomorphic_on_imp_continuous_on[OF holomorphic_pre_zeta]) auto"], ["proof (state)\nthis:\n  continuous_on UNIV (pre_zeta a)\n\ngoal (1 subgoal):\n 1. continuous_on A (\\<lambda>x. pre_zeta a (f x))", "from continuous_on_compose2[OF this assms(1)]"], ["proof (chain)\npicking this:\n  f ` A \\<subseteq> UNIV \\<Longrightarrow>\n  continuous_on A (\\<lambda>x. pre_zeta a (f x))", "show ?thesis"], ["proof (prove)\nusing this:\n  f ` A \\<subseteq> UNIV \\<Longrightarrow>\n  continuous_on A (\\<lambda>x. pre_zeta a (f x))\n\ngoal (1 subgoal):\n 1. continuous_on A (\\<lambda>x. pre_zeta a (f x))", "by simp"], ["proof (state)\nthis:\n  continuous_on A (\\<lambda>x. pre_zeta a (f x))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma continuous_pre_zeta [continuous_intros]:\n  assumes \"continuous (at x within A) f\" \"a > 0\"\n  shows   \"continuous (at x within A) (\\<lambda>x. pre_zeta a (f x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous (at x within A) (\\<lambda>x. pre_zeta a (f x))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. continuous (at x within A) (\\<lambda>x. pre_zeta a (f x))", "have \"continuous (at z) (pre_zeta a)\" for z"], ["proof (prove)\ngoal (1 subgoal):\n 1. isCont (pre_zeta a) z", "by (rule continuous_on_interior[of UNIV]) (insert assms, auto intro!: continuous_intros)"], ["proof (state)\nthis:\n  isCont (pre_zeta a) ?z\n\ngoal (1 subgoal):\n 1. continuous (at x within A) (\\<lambda>x. pre_zeta a (f x))", "from continuous_within_compose3[OF this assms(1)]"], ["proof (chain)\npicking this:\n  continuous (at x within A) (\\<lambda>x. pre_zeta a (f x))", "show ?thesis"], ["proof (prove)\nusing this:\n  continuous (at x within A) (\\<lambda>x. pre_zeta a (f x))\n\ngoal (1 subgoal):\n 1. continuous (at x within A) (\\<lambda>x. pre_zeta a (f x))", "."], ["proof (state)\nthis:\n  continuous (at x within A) (\\<lambda>x. pre_zeta a (f x))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma pre_zeta_bound:\n  assumes \"0 < Re s\" and a: \"a > 0\"\n  shows   \"norm (pre_zeta a s) \\<le> (1 + norm s / Re s) / 2 * a powr -Re s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod (pre_zeta a s) \\<le> (1 + cmod s / Re s) / 2 * a powr - Re s", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cmod (pre_zeta a s) \\<le> (1 + cmod s / Re s) / 2 * a powr - Re s", "let ?f = \"\\<lambda>x. - (s * (x + a) powr (-1-s))\""], ["proof (state)\ngoal (1 subgoal):\n 1. cmod (pre_zeta a s) \\<le> (1 + cmod s / Re s) / 2 * a powr - Re s", "let ?g' = \"\\<lambda>x. norm s * (x + a) powr (-1-Re s)\""], ["proof (state)\ngoal (1 subgoal):\n 1. cmod (pre_zeta a s) \\<le> (1 + cmod s / Re s) / 2 * a powr - Re s", "let ?g = \"\\<lambda>x. -norm s / Re s * (x + a) powr (-Re s)\""], ["proof (state)\ngoal (1 subgoal):\n 1. cmod (pre_zeta a s) \\<le> (1 + cmod s / Re s) / 2 * a powr - Re s", "define R where \"R = EM_remainder 1 ?f 0\""], ["proof (state)\nthis:\n  R =\n  EM_remainder 1\n   (\\<lambda>x. - (s * complex_of_real (x + a) powr (- 1 - s))) 0\n\ngoal (1 subgoal):\n 1. cmod (pre_zeta a s) \\<le> (1 + cmod s / Re s) / 2 * a powr - Re s", "have [simp]: \"-Re s - 1 = -1 - Re s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - Re s - 1 = - 1 - Re s", "by (simp add: algebra_simps)"], ["proof (state)\nthis:\n  - Re s - 1 = - 1 - Re s\n\ngoal (1 subgoal):\n 1. cmod (pre_zeta a s) \\<le> (1 + cmod s / Re s) / 2 * a powr - Re s", "have \"\\<bar>frac x - 1 / 2\\<bar> \\<le> 1 / 2\" for x :: real"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>frac x - 1 / 2\\<bar> \\<le> 1 / 2", "unfolding frac_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>x - real_of_int \\<lfloor>x\\<rfloor> - 1 / 2\\<bar> \\<le> 1 / 2", "by linarith"], ["proof (state)\nthis:\n  \\<bar>frac ?x - 1 / 2\\<bar> \\<le> 1 / 2\n\ngoal (1 subgoal):\n 1. cmod (pre_zeta a s) \\<le> (1 + cmod s / Re s) / 2 * a powr - Re s", "hence \"\\<bar>pbernpoly (Suc 0) x\\<bar> \\<le> 1 / 2\" for x"], ["proof (prove)\nusing this:\n  \\<bar>frac ?x - 1 / 2\\<bar> \\<le> 1 / 2\n\ngoal (1 subgoal):\n 1. \\<bar>pbernpoly (Suc 0) x\\<bar> \\<le> 1 / 2", "by (simp add: pbernpoly_def bernpoly_def)"], ["proof (state)\nthis:\n  \\<bar>pbernpoly (Suc 0) ?x\\<bar> \\<le> 1 / 2\n\ngoal (1 subgoal):\n 1. cmod (pre_zeta a s) \\<le> (1 + cmod s / Re s) / 2 * a powr - Re s", "moreover"], ["proof (state)\nthis:\n  \\<bar>pbernpoly (Suc 0) ?x\\<bar> \\<le> 1 / 2\n\ngoal (1 subgoal):\n 1. cmod (pre_zeta a s) \\<le> (1 + cmod s / Re s) / 2 * a powr - Re s", "have \"((\\<lambda>b. cmod s * (b + a) powr - Re s / Re s) \\<longlongrightarrow> 0) at_top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>b. cmod s * (b + a) powr - Re s / Re s) \\<longlongrightarrow>\n     0)\n     at_top", "using \\<open>Re s > 0\\<close> \\<open>a > 0\\<close>"], ["proof (prove)\nusing this:\n  0 < Re s\n  0 < a\n\ngoal (1 subgoal):\n 1. ((\\<lambda>b. cmod s * (b + a) powr - Re s / Re s) \\<longlongrightarrow>\n     0)\n     at_top", "by real_asymp"], ["proof (state)\nthis:\n  ((\\<lambda>b. cmod s * (b + a) powr - Re s / Re s) \\<longlongrightarrow>\n   0)\n   at_top\n\ngoal (1 subgoal):\n 1. cmod (pre_zeta a s) \\<le> (1 + cmod s / Re s) / 2 * a powr - Re s", "ultimately"], ["proof (chain)\npicking this:\n  \\<bar>pbernpoly (Suc 0) ?x\\<bar> \\<le> 1 / 2\n  ((\\<lambda>b. cmod s * (b + a) powr - Re s / Re s) \\<longlongrightarrow>\n   0)\n   at_top", "have *: \"\\<forall>x. x \\<ge> real 0 \\<longrightarrow> norm (EM_remainder 1 ?f (int x)) \\<le>\n                           (1 / 2) / fact 1 * (-?g (real x))\""], ["proof (prove)\nusing this:\n  \\<bar>pbernpoly (Suc 0) ?x\\<bar> \\<le> 1 / 2\n  ((\\<lambda>b. cmod s * (b + a) powr - Re s / Re s) \\<longlongrightarrow>\n   0)\n   at_top\n\ngoal (1 subgoal):\n 1. \\<forall>x.\n       real 0 \\<le> real x \\<longrightarrow>\n       cmod\n        (EM_remainder 1\n          (\\<lambda>x. - (s * complex_of_real (x + a) powr (- 1 - s)))\n          (int x))\n       \\<le> 1 / 2 / fact 1 * - (- cmod s / Re s * (real x + a) powr - Re s)", "using \\<open>a > 0\\<close> \\<open>Re s > 0\\<close>"], ["proof (prove)\nusing this:\n  \\<bar>pbernpoly (Suc 0) ?x\\<bar> \\<le> 1 / 2\n  ((\\<lambda>b. cmod s * (b + a) powr - Re s / Re s) \\<longlongrightarrow>\n   0)\n   at_top\n  0 < a\n  0 < Re s\n\ngoal (1 subgoal):\n 1. \\<forall>x.\n       real 0 \\<le> real x \\<longrightarrow>\n       cmod\n        (EM_remainder 1\n          (\\<lambda>x. - (s * complex_of_real (x + a) powr (- 1 - s)))\n          (int x))\n       \\<le> 1 / 2 / fact 1 * - (- cmod s / Re s * (real x + a) powr - Re s)", "by (intro norm_EM_remainder_le_strong_nat'[where g' = ?g' and Y = \"{}\"])\n       (auto intro!: continuous_intros derivative_eq_intros\n             simp: field_simps norm_mult norm_powr_real_powr add_eq_0_iff)"], ["proof (state)\nthis:\n  \\<forall>x.\n     real 0 \\<le> real x \\<longrightarrow>\n     cmod\n      (EM_remainder 1\n        (\\<lambda>x. - (s * complex_of_real (x + a) powr (- 1 - s)))\n        (int x))\n     \\<le> 1 / 2 / fact 1 * - (- cmod s / Re s * (real x + a) powr - Re s)\n\ngoal (1 subgoal):\n 1. cmod (pre_zeta a s) \\<le> (1 + cmod s / Re s) / 2 * a powr - Re s", "have R: \"norm R \\<le> norm s / (2 * Re s) * a powr -Re s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod R \\<le> cmod s / (2 * Re s) * a powr - Re s", "unfolding R_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod\n     (EM_remainder 1\n       (\\<lambda>x. - (s * complex_of_real (x + a) powr (- 1 - s))) 0)\n    \\<le> cmod s / (2 * Re s) * a powr - Re s", "using spec[OF *, of 0]"], ["proof (prove)\nusing this:\n  real 0 \\<le> real 0 \\<longrightarrow>\n  cmod\n   (EM_remainder 1\n     (\\<lambda>x. - (s * complex_of_real (x + a) powr (- 1 - s))) (int 0))\n  \\<le> 1 / 2 / fact 1 * - (- cmod s / Re s * (real 0 + a) powr - Re s)\n\ngoal (1 subgoal):\n 1. cmod\n     (EM_remainder 1\n       (\\<lambda>x. - (s * complex_of_real (x + a) powr (- 1 - s))) 0)\n    \\<le> cmod s / (2 * Re s) * a powr - Re s", "by simp"], ["proof (state)\nthis:\n  cmod R \\<le> cmod s / (2 * Re s) * a powr - Re s\n\ngoal (1 subgoal):\n 1. cmod (pre_zeta a s) \\<le> (1 + cmod s / Re s) / 2 * a powr - Re s", "from assms"], ["proof (chain)\npicking this:\n  0 < Re s\n  0 < a", "have \"pre_zeta a s = a powr -s / 2 + R\""], ["proof (prove)\nusing this:\n  0 < Re s\n  0 < a\n\ngoal (1 subgoal):\n 1. pre_zeta a s = complex_of_real a powr - s / 2 + R", "by (simp add: pre_zeta_def pre_zeta_aux_def R_def)"], ["proof (state)\nthis:\n  pre_zeta a s = complex_of_real a powr - s / 2 + R\n\ngoal (1 subgoal):\n 1. cmod (pre_zeta a s) \\<le> (1 + cmod s / Re s) / 2 * a powr - Re s", "also"], ["proof (state)\nthis:\n  pre_zeta a s = complex_of_real a powr - s / 2 + R\n\ngoal (1 subgoal):\n 1. cmod (pre_zeta a s) \\<le> (1 + cmod s / Re s) / 2 * a powr - Re s", "have \"norm \\<dots> \\<le> a powr -Re s / 2 + norm s / (2 * Re s) * a powr -Re s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod (complex_of_real a powr - s / 2 + R)\n    \\<le> a powr - Re s / 2 + cmod s / (2 * Re s) * a powr - Re s", "using a"], ["proof (prove)\nusing this:\n  0 < a\n\ngoal (1 subgoal):\n 1. cmod (complex_of_real a powr - s / 2 + R)\n    \\<le> a powr - Re s / 2 + cmod s / (2 * Re s) * a powr - Re s", "by (intro order.trans[OF norm_triangle_ineq] add_mono R) (auto simp: norm_powr_real_powr)"], ["proof (state)\nthis:\n  cmod (complex_of_real a powr - s / 2 + R)\n  \\<le> a powr - Re s / 2 + cmod s / (2 * Re s) * a powr - Re s\n\ngoal (1 subgoal):\n 1. cmod (pre_zeta a s) \\<le> (1 + cmod s / Re s) / 2 * a powr - Re s", "also"], ["proof (state)\nthis:\n  cmod (complex_of_real a powr - s / 2 + R)\n  \\<le> a powr - Re s / 2 + cmod s / (2 * Re s) * a powr - Re s\n\ngoal (1 subgoal):\n 1. cmod (pre_zeta a s) \\<le> (1 + cmod s / Re s) / 2 * a powr - Re s", "have \"\\<dots> = (1 + norm s / Re s) / 2 * a powr -Re s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a powr - Re s / 2 + cmod s / (2 * Re s) * a powr - Re s =\n    (1 + cmod s / Re s) / 2 * a powr - Re s", "by (simp add: field_simps)"], ["proof (state)\nthis:\n  a powr - Re s / 2 + cmod s / (2 * Re s) * a powr - Re s =\n  (1 + cmod s / Re s) / 2 * a powr - Re s\n\ngoal (1 subgoal):\n 1. cmod (pre_zeta a s) \\<le> (1 + cmod s / Re s) / 2 * a powr - Re s", "finally"], ["proof (chain)\npicking this:\n  cmod (pre_zeta a s) \\<le> (1 + cmod s / Re s) / 2 * a powr - Re s", "show ?thesis"], ["proof (prove)\nusing this:\n  cmod (pre_zeta a s) \\<le> (1 + cmod s / Re s) / 2 * a powr - Re s\n\ngoal (1 subgoal):\n 1. cmod (pre_zeta a s) \\<le> (1 + cmod s / Re s) / 2 * a powr - Re s", "."], ["proof (state)\nthis:\n  cmod (pre_zeta a s) \\<le> (1 + cmod s / Re s) / 2 * a powr - Re s\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma pre_zeta_bound':\n  assumes \"0 < Re s\" and a: \"a > 0\"\n  shows   \"norm (pre_zeta a s) \\<le> norm s / (Re s * a powr Re s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod (pre_zeta a s) \\<le> cmod s / (Re s * a powr Re s)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cmod (pre_zeta a s) \\<le> cmod s / (Re s * a powr Re s)", "from assms"], ["proof (chain)\npicking this:\n  0 < Re s\n  0 < a", "have \"norm (pre_zeta a s) \\<le> (1 + norm s / Re s) / 2 * a powr -Re s\""], ["proof (prove)\nusing this:\n  0 < Re s\n  0 < a\n\ngoal (1 subgoal):\n 1. cmod (pre_zeta a s) \\<le> (1 + cmod s / Re s) / 2 * a powr - Re s", "by (intro pre_zeta_bound) auto"], ["proof (state)\nthis:\n  cmod (pre_zeta a s) \\<le> (1 + cmod s / Re s) / 2 * a powr - Re s\n\ngoal (1 subgoal):\n 1. cmod (pre_zeta a s) \\<le> cmod s / (Re s * a powr Re s)", "also"], ["proof (state)\nthis:\n  cmod (pre_zeta a s) \\<le> (1 + cmod s / Re s) / 2 * a powr - Re s\n\ngoal (1 subgoal):\n 1. cmod (pre_zeta a s) \\<le> cmod s / (Re s * a powr Re s)", "have \"\\<dots> = (Re s + norm s) / 2 / (Re s * a powr Re s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1 + cmod s / Re s) / 2 * a powr - Re s =\n    (Re s + cmod s) / 2 / (Re s * a powr Re s)", "using assms"], ["proof (prove)\nusing this:\n  0 < Re s\n  0 < a\n\ngoal (1 subgoal):\n 1. (1 + cmod s / Re s) / 2 * a powr - Re s =\n    (Re s + cmod s) / 2 / (Re s * a powr Re s)", "by (auto simp: field_simps powr_minus)"], ["proof (state)\nthis:\n  (1 + cmod s / Re s) / 2 * a powr - Re s =\n  (Re s + cmod s) / 2 / (Re s * a powr Re s)\n\ngoal (1 subgoal):\n 1. cmod (pre_zeta a s) \\<le> cmod s / (Re s * a powr Re s)", "also"], ["proof (state)\nthis:\n  (1 + cmod s / Re s) / 2 * a powr - Re s =\n  (Re s + cmod s) / 2 / (Re s * a powr Re s)\n\ngoal (1 subgoal):\n 1. cmod (pre_zeta a s) \\<le> cmod s / (Re s * a powr Re s)", "have \"Re s + norm s \\<le> norm s + norm s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Re s + cmod s \\<le> cmod s + cmod s", "by (intro add_right_mono complex_Re_le_cmod)"], ["proof (state)\nthis:\n  Re s + cmod s \\<le> cmod s + cmod s\n\ngoal (1 subgoal):\n 1. cmod (pre_zeta a s) \\<le> cmod s / (Re s * a powr Re s)", "also"], ["proof (state)\nthis:\n  Re s + cmod s \\<le> cmod s + cmod s\n\ngoal (1 subgoal):\n 1. cmod (pre_zeta a s) \\<le> cmod s / (Re s * a powr Re s)", "have \"(norm s + norm s) / 2 = norm s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (cmod s + cmod s) / 2 = cmod s", "by simp"], ["proof (state)\nthis:\n  (cmod s + cmod s) / 2 = cmod s\n\ngoal (1 subgoal):\n 1. cmod (pre_zeta a s) \\<le> cmod s / (Re s * a powr Re s)", "finally"], ["proof (chain)\npicking this:\n  (\\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      x / 2 / (Re s * a powr Re s)\n      \\<le> y / 2 / (Re s * a powr Re s)) \\<Longrightarrow>\n  cmod (pre_zeta a s) \\<le> cmod s / (Re s * a powr Re s)", "show \"norm (pre_zeta a s) \\<le> norm s / (Re s * a powr Re s)\""], ["proof (prove)\nusing this:\n  (\\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      x / 2 / (Re s * a powr Re s)\n      \\<le> y / 2 / (Re s * a powr Re s)) \\<Longrightarrow>\n  cmod (pre_zeta a s) \\<le> cmod s / (Re s * a powr Re s)\n\ngoal (1 subgoal):\n 1. cmod (pre_zeta a s) \\<le> cmod s / (Re s * a powr Re s)", "using assms"], ["proof (prove)\nusing this:\n  (\\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      x / 2 / (Re s * a powr Re s)\n      \\<le> y / 2 / (Re s * a powr Re s)) \\<Longrightarrow>\n  cmod (pre_zeta a s) \\<le> cmod s / (Re s * a powr Re s)\n  0 < Re s\n  0 < a\n\ngoal (1 subgoal):\n 1. cmod (pre_zeta a s) \\<le> cmod s / (Re s * a powr Re s)", "by (simp add: divide_right_mono)"], ["proof (state)\nthis:\n  cmod (pre_zeta a s) \\<le> cmod s / (Re s * a powr Re s)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma summable_comparison_test_bigo:\n  fixes f :: \"nat \\<Rightarrow> real\"\n  assumes \"summable (\\<lambda>n. norm (g n))\" \"f \\<in> O(g)\"\n  shows   \"summable f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. summable f", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. summable f", "from \\<open>f \\<in> O(g)\\<close>"], ["proof (chain)\npicking this:\n  f \\<in> O(g)", "obtain C where C: \"eventually (\\<lambda>x. norm (f x) \\<le> C * norm (g x)) at_top\""], ["proof (prove)\nusing this:\n  f \\<in> O(g)\n\ngoal (1 subgoal):\n 1. (\\<And>C.\n        \\<forall>\\<^sub>F x in sequentially.\n           norm (f x) \\<le> C * norm (g x) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (auto elim: landau_o.bigE)"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in sequentially. norm (f x) \\<le> C * norm (g x)\n\ngoal (1 subgoal):\n 1. summable f", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F x in sequentially. norm (f x) \\<le> C * norm (g x)\n\ngoal (1 subgoal):\n 1. summable f", "by (rule summable_comparison_test_ev) (insert assms, auto intro: summable_mult)"], ["proof (state)\nthis:\n  summable f\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma deriv_zeta_eq:\n  assumes s: \"s \\<noteq> 1\"\n  shows   \"deriv zeta s = deriv (pre_zeta 1) s - 1 / (s - 1)\\<^sup>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. deriv zeta s = deriv (pre_zeta 1) s - 1 / (s - 1)\\<^sup>2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. deriv zeta s = deriv (pre_zeta 1) s - 1 / (s - 1)\\<^sup>2", "from s"], ["proof (chain)\npicking this:\n  s \\<noteq> 1", "have ev: \"eventually (\\<lambda>z. z \\<noteq> 1) (nhds s)\""], ["proof (prove)\nusing this:\n  s \\<noteq> 1\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F z in nhds s. z \\<noteq> 1", "by (intro t1_space_nhds)"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F z in nhds s. z \\<noteq> 1\n\ngoal (1 subgoal):\n 1. deriv zeta s = deriv (pre_zeta 1) s - 1 / (s - 1)\\<^sup>2", "have [derivative_intros]: \"(pre_zeta 1 has_field_derivative deriv (pre_zeta 1) s) (at s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (pre_zeta 1 has_field_derivative deriv (pre_zeta 1) s) (at s)", "by (intro holomorphic_derivI[of _ UNIV] holomorphic_intros) auto"], ["proof (state)\nthis:\n  (pre_zeta 1 has_field_derivative deriv (pre_zeta 1) s) (at s)\n\ngoal (1 subgoal):\n 1. deriv zeta s = deriv (pre_zeta 1) s - 1 / (s - 1)\\<^sup>2", "have \"((\\<lambda>s. pre_zeta 1 s + 1 / (s - 1)) has_field_derivative\n          (deriv (pre_zeta 1) s - 1 / (s - 1)\\<^sup>2)) (at s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>s. pre_zeta 1 s + 1 / (s - 1)) has_field_derivative\n     deriv (pre_zeta 1) s - 1 / (s - 1)\\<^sup>2)\n     (at s)", "using s"], ["proof (prove)\nusing this:\n  s \\<noteq> 1\n\ngoal (1 subgoal):\n 1. ((\\<lambda>s. pre_zeta 1 s + 1 / (s - 1)) has_field_derivative\n     deriv (pre_zeta 1) s - 1 / (s - 1)\\<^sup>2)\n     (at s)", "by (auto intro!: derivative_eq_intros simp: power2_eq_square)"], ["proof (state)\nthis:\n  ((\\<lambda>s. pre_zeta 1 s + 1 / (s - 1)) has_field_derivative\n   deriv (pre_zeta 1) s - 1 / (s - 1)\\<^sup>2)\n   (at s)\n\ngoal (1 subgoal):\n 1. deriv zeta s = deriv (pre_zeta 1) s - 1 / (s - 1)\\<^sup>2", "also"], ["proof (state)\nthis:\n  ((\\<lambda>s. pre_zeta 1 s + 1 / (s - 1)) has_field_derivative\n   deriv (pre_zeta 1) s - 1 / (s - 1)\\<^sup>2)\n   (at s)\n\ngoal (1 subgoal):\n 1. deriv zeta s = deriv (pre_zeta 1) s - 1 / (s - 1)\\<^sup>2", "have \"?this \\<longleftrightarrow> (zeta has_field_derivative (deriv (pre_zeta 1) s - 1 / (s - 1)\\<^sup>2)) (at s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>s. pre_zeta 1 s + 1 / (s - 1)) has_field_derivative\n     deriv (pre_zeta 1) s - 1 / (s - 1)\\<^sup>2)\n     (at s) =\n    (zeta has_field_derivative deriv (pre_zeta 1) s - 1 / (s - 1)\\<^sup>2)\n     (at s)", "by (intro has_field_derivative_cong_ev eventually_mono[OF ev])\n       (auto simp: zeta_def hurwitz_zeta_def)"], ["proof (state)\nthis:\n  ((\\<lambda>s. pre_zeta 1 s + 1 / (s - 1)) has_field_derivative\n   deriv (pre_zeta 1) s - 1 / (s - 1)\\<^sup>2)\n   (at s) =\n  (zeta has_field_derivative deriv (pre_zeta 1) s - 1 / (s - 1)\\<^sup>2)\n   (at s)\n\ngoal (1 subgoal):\n 1. deriv zeta s = deriv (pre_zeta 1) s - 1 / (s - 1)\\<^sup>2", "finally"], ["proof (chain)\npicking this:\n  (zeta has_field_derivative deriv (pre_zeta 1) s - 1 / (s - 1)\\<^sup>2)\n   (at s)", "show ?thesis"], ["proof (prove)\nusing this:\n  (zeta has_field_derivative deriv (pre_zeta 1) s - 1 / (s - 1)\\<^sup>2)\n   (at s)\n\ngoal (1 subgoal):\n 1. deriv zeta s = deriv (pre_zeta 1) s - 1 / (s - 1)\\<^sup>2", "by (rule DERIV_imp_deriv)"], ["proof (state)\nthis:\n  deriv zeta s = deriv (pre_zeta 1) s - 1 / (s - 1)\\<^sup>2\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma zeta_remove_zero:\n  assumes \"Re s \\<ge> 1\"\n  shows   \"(s - 1) * pre_zeta 1 s + 1 \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (s - 1) * pre_zeta 1 s + 1 \\<noteq> 0", "proof (cases \"s = 1\")"], ["proof (state)\ngoal (2 subgoals):\n 1. s = 1 \\<Longrightarrow> (s - 1) * pre_zeta 1 s + 1 \\<noteq> 0\n 2. s \\<noteq> 1 \\<Longrightarrow> (s - 1) * pre_zeta 1 s + 1 \\<noteq> 0", "case False"], ["proof (state)\nthis:\n  s \\<noteq> 1\n\ngoal (2 subgoals):\n 1. s = 1 \\<Longrightarrow> (s - 1) * pre_zeta 1 s + 1 \\<noteq> 0\n 2. s \\<noteq> 1 \\<Longrightarrow> (s - 1) * pre_zeta 1 s + 1 \\<noteq> 0", "hence \"(s - 1) * pre_zeta 1 s + 1 = (s - 1) * zeta s\""], ["proof (prove)\nusing this:\n  s \\<noteq> 1\n\ngoal (1 subgoal):\n 1. (s - 1) * pre_zeta 1 s + 1 = (s - 1) * zeta s", "by (simp add: zeta_def hurwitz_zeta_def divide_simps)"], ["proof (state)\nthis:\n  (s - 1) * pre_zeta 1 s + 1 = (s - 1) * zeta s\n\ngoal (2 subgoals):\n 1. s = 1 \\<Longrightarrow> (s - 1) * pre_zeta 1 s + 1 \\<noteq> 0\n 2. s \\<noteq> 1 \\<Longrightarrow> (s - 1) * pre_zeta 1 s + 1 \\<noteq> 0", "also"], ["proof (state)\nthis:\n  (s - 1) * pre_zeta 1 s + 1 = (s - 1) * zeta s\n\ngoal (2 subgoals):\n 1. s = 1 \\<Longrightarrow> (s - 1) * pre_zeta 1 s + 1 \\<noteq> 0\n 2. s \\<noteq> 1 \\<Longrightarrow> (s - 1) * pre_zeta 1 s + 1 \\<noteq> 0", "from False assms"], ["proof (chain)\npicking this:\n  s \\<noteq> 1\n  1 \\<le> Re s", "have \"\\<dots> \\<noteq> 0\""], ["proof (prove)\nusing this:\n  s \\<noteq> 1\n  1 \\<le> Re s\n\ngoal (1 subgoal):\n 1. (s - 1) * zeta s \\<noteq> 0", "using zeta_Re_ge_1_nonzero[of s]"], ["proof (prove)\nusing this:\n  s \\<noteq> 1\n  1 \\<le> Re s\n  \\<lbrakk>1 \\<le> Re s; s \\<noteq> 1\\<rbrakk>\n  \\<Longrightarrow> zeta s \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (s - 1) * zeta s \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  (s - 1) * zeta s \\<noteq> 0\n\ngoal (2 subgoals):\n 1. s = 1 \\<Longrightarrow> (s - 1) * pre_zeta 1 s + 1 \\<noteq> 0\n 2. s \\<noteq> 1 \\<Longrightarrow> (s - 1) * pre_zeta 1 s + 1 \\<noteq> 0", "finally"], ["proof (chain)\npicking this:\n  (s - 1) * pre_zeta 1 s + 1 \\<noteq> 0", "show ?thesis"], ["proof (prove)\nusing this:\n  (s - 1) * pre_zeta 1 s + 1 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (s - 1) * pre_zeta 1 s + 1 \\<noteq> 0", "."], ["proof (state)\nthis:\n  (s - 1) * pre_zeta 1 s + 1 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. s = 1 \\<Longrightarrow> (s - 1) * pre_zeta 1 s + 1 \\<noteq> 0", "qed auto"], ["", "lemma eval_fds_deriv_zeta:\n  assumes \"Re s > 1\"\n  shows   \"eval_fds (fds_deriv fds_zeta) s = deriv zeta s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_fds (fds_deriv fds_zeta) s = deriv zeta s", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. eval_fds (fds_deriv fds_zeta) s = deriv zeta s", "have ev: \"eventually (\\<lambda>z. z \\<in> {z. Re z > 1}) (nhds s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F z in nhds s. z \\<in> {z. 1 < Re z}", "using assms"], ["proof (prove)\nusing this:\n  1 < Re s\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F z in nhds s. z \\<in> {z. 1 < Re z}", "by (intro eventually_nhds_in_open open_halfspace_Re_gt) auto"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F z in nhds s. z \\<in> {z. 1 < Re z}\n\ngoal (1 subgoal):\n 1. eval_fds (fds_deriv fds_zeta) s = deriv zeta s", "from assms"], ["proof (chain)\npicking this:\n  1 < Re s", "have \"eval_fds (fds_deriv fds_zeta) s = deriv (eval_fds fds_zeta) s\""], ["proof (prove)\nusing this:\n  1 < Re s\n\ngoal (1 subgoal):\n 1. eval_fds (fds_deriv fds_zeta) s = deriv (eval_fds fds_zeta) s", "by (subst eval_fds_deriv) auto"], ["proof (state)\nthis:\n  eval_fds (fds_deriv fds_zeta) s = deriv (eval_fds fds_zeta) s\n\ngoal (1 subgoal):\n 1. eval_fds (fds_deriv fds_zeta) s = deriv zeta s", "also"], ["proof (state)\nthis:\n  eval_fds (fds_deriv fds_zeta) s = deriv (eval_fds fds_zeta) s\n\ngoal (1 subgoal):\n 1. eval_fds (fds_deriv fds_zeta) s = deriv zeta s", "have \"\\<dots> = deriv zeta s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. deriv (eval_fds fds_zeta) s = deriv zeta s", "by (intro deriv_cong_ev eventually_mono[OF ev]) (auto simp: eval_fds_zeta)"], ["proof (state)\nthis:\n  deriv (eval_fds fds_zeta) s = deriv zeta s\n\ngoal (1 subgoal):\n 1. eval_fds (fds_deriv fds_zeta) s = deriv zeta s", "finally"], ["proof (chain)\npicking this:\n  eval_fds (fds_deriv fds_zeta) s = deriv zeta s", "show ?thesis"], ["proof (prove)\nusing this:\n  eval_fds (fds_deriv fds_zeta) s = deriv zeta s\n\ngoal (1 subgoal):\n 1. eval_fds (fds_deriv fds_zeta) s = deriv zeta s", "."], ["proof (state)\nthis:\n  eval_fds (fds_deriv fds_zeta) s = deriv zeta s\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma length_sorted_list_of_set [simp]:\n  \"finite A \\<Longrightarrow> length (sorted_list_of_set A) = card A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite A \\<Longrightarrow> length (sorted_list_of_set A) = card A", "by (metis length_remdups_card_conv length_sort set_sorted_list_of_set\n            sorted_list_of_set_sort_remdups)"], ["", "lemma le_nat_iff': \"x \\<le> nat y \\<longleftrightarrow> x = 0 \\<and> y \\<le> 0 \\<or> int x \\<le> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<le> nat y) = (x = 0 \\<and> y \\<le> 0 \\<or> int x \\<le> y)", "by auto"], ["", "lemma sum_upto_plus1:\n  assumes \"x \\<ge> 0\"\n  shows   \"sum_upto f (x + 1) = sum_upto f x + f (Suc (nat \\<lfloor>x\\<rfloor>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_upto f (x + 1) = sum_upto f x + f (Suc (nat \\<lfloor>x\\<rfloor>))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. sum_upto f (x + 1) = sum_upto f x + f (Suc (nat \\<lfloor>x\\<rfloor>))", "have \"sum_upto f (x + 1) = sum f {0<..Suc (nat \\<lfloor>x\\<rfloor>)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_upto f (x + 1) = sum f {0<..Suc (nat \\<lfloor>x\\<rfloor>)}", "using assms"], ["proof (prove)\nusing this:\n  0 \\<le> x\n\ngoal (1 subgoal):\n 1. sum_upto f (x + 1) = sum f {0<..Suc (nat \\<lfloor>x\\<rfloor>)}", "by (simp add: sum_upto_altdef nat_add_distrib)"], ["proof (state)\nthis:\n  sum_upto f (x + 1) = sum f {0<..Suc (nat \\<lfloor>x\\<rfloor>)}\n\ngoal (1 subgoal):\n 1. sum_upto f (x + 1) = sum_upto f x + f (Suc (nat \\<lfloor>x\\<rfloor>))", "also"], ["proof (state)\nthis:\n  sum_upto f (x + 1) = sum f {0<..Suc (nat \\<lfloor>x\\<rfloor>)}\n\ngoal (1 subgoal):\n 1. sum_upto f (x + 1) = sum_upto f x + f (Suc (nat \\<lfloor>x\\<rfloor>))", "have \"{0<..Suc (nat \\<lfloor>x\\<rfloor>)} = insert (Suc (nat \\<lfloor>x\\<rfloor>)) {0<..nat \\<lfloor>x\\<rfloor>}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {0<..Suc (nat \\<lfloor>x\\<rfloor>)} =\n    insert (Suc (nat \\<lfloor>x\\<rfloor>)) {0<..nat \\<lfloor>x\\<rfloor>}", "by auto"], ["proof (state)\nthis:\n  {0<..Suc (nat \\<lfloor>x\\<rfloor>)} =\n  insert (Suc (nat \\<lfloor>x\\<rfloor>)) {0<..nat \\<lfloor>x\\<rfloor>}\n\ngoal (1 subgoal):\n 1. sum_upto f (x + 1) = sum_upto f x + f (Suc (nat \\<lfloor>x\\<rfloor>))", "also"], ["proof (state)\nthis:\n  {0<..Suc (nat \\<lfloor>x\\<rfloor>)} =\n  insert (Suc (nat \\<lfloor>x\\<rfloor>)) {0<..nat \\<lfloor>x\\<rfloor>}\n\ngoal (1 subgoal):\n 1. sum_upto f (x + 1) = sum_upto f x + f (Suc (nat \\<lfloor>x\\<rfloor>))", "have \"sum f \\<dots> = sum_upto f x + f (Suc (nat \\<lfloor>x\\<rfloor>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum f\n     (insert (Suc (nat \\<lfloor>x\\<rfloor>))\n       {0<..nat \\<lfloor>x\\<rfloor>}) =\n    sum_upto f x + f (Suc (nat \\<lfloor>x\\<rfloor>))", "by (subst sum.insert) (auto simp: sum_upto_altdef add_ac)"], ["proof (state)\nthis:\n  sum f\n   (insert (Suc (nat \\<lfloor>x\\<rfloor>)) {0<..nat \\<lfloor>x\\<rfloor>}) =\n  sum_upto f x + f (Suc (nat \\<lfloor>x\\<rfloor>))\n\ngoal (1 subgoal):\n 1. sum_upto f (x + 1) = sum_upto f x + f (Suc (nat \\<lfloor>x\\<rfloor>))", "finally"], ["proof (chain)\npicking this:\n  sum_upto f (x + 1) = sum_upto f x + f (Suc (nat \\<lfloor>x\\<rfloor>))", "show ?thesis"], ["proof (prove)\nusing this:\n  sum_upto f (x + 1) = sum_upto f x + f (Suc (nat \\<lfloor>x\\<rfloor>))\n\ngoal (1 subgoal):\n 1. sum_upto f (x + 1) = sum_upto f x + f (Suc (nat \\<lfloor>x\\<rfloor>))", "."], ["proof (state)\nthis:\n  sum_upto f (x + 1) = sum_upto f x + f (Suc (nat \\<lfloor>x\\<rfloor>))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sum_upto_minus1:\n  assumes \"x \\<ge> 1\"\n  shows   \"sum_upto f (x - 1) = (sum_upto f x - f (nat \\<lfloor>x\\<rfloor>) :: 'a :: ab_group_add)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_upto f (x - 1) = sum_upto f x - f (nat \\<lfloor>x\\<rfloor>)", "using sum_upto_plus1[of \"x - 1\" f] assms"], ["proof (prove)\nusing this:\n  0 \\<le> x - 1 \\<Longrightarrow>\n  sum_upto f (x - 1 + 1) =\n  sum_upto f (x - 1) + f (Suc (nat \\<lfloor>x - 1\\<rfloor>))\n  1 \\<le> x\n\ngoal (1 subgoal):\n 1. sum_upto f (x - 1) = sum_upto f x - f (nat \\<lfloor>x\\<rfloor>)", "by (simp add: algebra_simps nat_diff_distrib)"], ["", "lemma integral_smallo:\n  fixes f g g' :: \"real \\<Rightarrow> real\"\n  assumes \"f \\<in> o(g')\" and \"filterlim g at_top at_top\"\n  assumes \"\\<And>a' x. a \\<le> a' \\<Longrightarrow> a' \\<le> x \\<Longrightarrow> f integrable_on {a'..x}\"\n  assumes deriv: \"\\<And>x. x \\<ge> a \\<Longrightarrow> (g has_field_derivative g' x) (at x)\"\n  assumes cont: \"continuous_on {a..} g'\"\n  assumes nonneg: \"\\<And>x. x \\<ge> a \\<Longrightarrow> g' x \\<ge> 0\"\n  shows   \"(\\<lambda>x. integral {a..x} f) \\<in> o(g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. integral {a..x} f) \\<in> o(g)", "proof (rule landau_o.smallI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>c.\n       0 < c \\<Longrightarrow>\n       \\<forall>\\<^sub>F x in at_top.\n          norm (integral {a..x} f) \\<le> c * norm (g x)", "fix c :: real"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>c.\n       0 < c \\<Longrightarrow>\n       \\<forall>\\<^sub>F x in at_top.\n          norm (integral {a..x} f) \\<le> c * norm (g x)", "assume c: \"c > 0\""], ["proof (state)\nthis:\n  0 < c\n\ngoal (1 subgoal):\n 1. \\<And>c.\n       0 < c \\<Longrightarrow>\n       \\<forall>\\<^sub>F x in at_top.\n          norm (integral {a..x} f) \\<le> c * norm (g x)", "note [continuous_intros] = continuous_on_subset[OF cont]"], ["proof (state)\nthis:\n  ?t \\<subseteq> {a..} \\<Longrightarrow> continuous_on ?t g'\n\ngoal (1 subgoal):\n 1. \\<And>c.\n       0 < c \\<Longrightarrow>\n       \\<forall>\\<^sub>F x in at_top.\n          norm (integral {a..x} f) \\<le> c * norm (g x)", "define c' where \"c' = c / 2\""], ["proof (state)\nthis:\n  c' = c / 2\n\ngoal (1 subgoal):\n 1. \\<And>c.\n       0 < c \\<Longrightarrow>\n       \\<forall>\\<^sub>F x in at_top.\n          norm (integral {a..x} f) \\<le> c * norm (g x)", "from c"], ["proof (chain)\npicking this:\n  0 < c", "have c': \"c' > 0\""], ["proof (prove)\nusing this:\n  0 < c\n\ngoal (1 subgoal):\n 1. 0 < c'", "by (simp add: c'_def)"], ["proof (state)\nthis:\n  0 < c'\n\ngoal (1 subgoal):\n 1. \\<And>c.\n       0 < c \\<Longrightarrow>\n       \\<forall>\\<^sub>F x in at_top.\n          norm (integral {a..x} f) \\<le> c * norm (g x)", "from landau_o.smallD[OF assms(1) this]"], ["proof (chain)\npicking this:\n  \\<forall>\\<^sub>F x in at_top. norm (f x) \\<le> c' * norm (g' x)", "obtain b where b: \"\\<And>x. x \\<ge> b \\<Longrightarrow> norm (f x) \\<le> c' * norm (g' x)\""], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F x in at_top. norm (f x) \\<le> c' * norm (g' x)\n\ngoal (1 subgoal):\n 1. (\\<And>b.\n        (\\<And>x.\n            b \\<le> x \\<Longrightarrow>\n            norm (f x) \\<le> c' * norm (g' x)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding eventually_at_top_linorder"], ["proof (prove)\nusing this:\n  \\<exists>N. \\<forall>n\\<ge>N. norm (f n) \\<le> c' * norm (g' n)\n\ngoal (1 subgoal):\n 1. (\\<And>b.\n        (\\<And>x.\n            b \\<le> x \\<Longrightarrow>\n            norm (f x) \\<le> c' * norm (g' x)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  b \\<le> ?x \\<Longrightarrow> norm (f ?x) \\<le> c' * norm (g' ?x)\n\ngoal (1 subgoal):\n 1. \\<And>c.\n       0 < c \\<Longrightarrow>\n       \\<forall>\\<^sub>F x in at_top.\n          norm (integral {a..x} f) \\<le> c * norm (g x)", "define b' where \"b' = max a b\""], ["proof (state)\nthis:\n  b' = max a b\n\ngoal (1 subgoal):\n 1. \\<And>c.\n       0 < c \\<Longrightarrow>\n       \\<forall>\\<^sub>F x in at_top.\n          norm (integral {a..x} f) \\<le> c * norm (g x)", "define D where \"D = norm (integral {a..b'} f)\""], ["proof (state)\nthis:\n  D = norm (integral {a..b'} f)\n\ngoal (1 subgoal):\n 1. \\<And>c.\n       0 < c \\<Longrightarrow>\n       \\<forall>\\<^sub>F x in at_top.\n          norm (integral {a..x} f) \\<le> c * norm (g x)", "have \"filterlim (\\<lambda>x. c' * g x) at_top at_top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LIM x at_top. c' * g x :> at_top", "using c'"], ["proof (prove)\nusing this:\n  0 < c'\n\ngoal (1 subgoal):\n 1. LIM x at_top. c' * g x :> at_top", "by (intro filterlim_tendsto_pos_mult_at_top[OF tendsto_const] assms)"], ["proof (state)\nthis:\n  LIM x at_top. c' * g x :> at_top\n\ngoal (1 subgoal):\n 1. \\<And>c.\n       0 < c \\<Longrightarrow>\n       \\<forall>\\<^sub>F x in at_top.\n          norm (integral {a..x} f) \\<le> c * norm (g x)", "hence \"eventually (\\<lambda>x. c' * g x \\<ge> D - c' * g b') at_top\""], ["proof (prove)\nusing this:\n  LIM x at_top. c' * g x :> at_top\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_top. D - c' * g b' \\<le> c' * g x", "by (auto simp: filterlim_at_top)"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in at_top. D - c' * g b' \\<le> c' * g x\n\ngoal (1 subgoal):\n 1. \\<And>c.\n       0 < c \\<Longrightarrow>\n       \\<forall>\\<^sub>F x in at_top.\n          norm (integral {a..x} f) \\<le> c * norm (g x)", "thus \"eventually (\\<lambda>x. norm (integral {a..x} f) \\<le> c * norm (g x)) at_top\""], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F x in at_top. D - c' * g b' \\<le> c' * g x\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_top.\n       norm (integral {a..x} f) \\<le> c * norm (g x)", "using eventually_ge_at_top[of b']"], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F x in at_top. D - c' * g b' \\<le> c' * g x\n  eventually ((\\<le>) b') at_top\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_top.\n       norm (integral {a..x} f) \\<le> c * norm (g x)", "proof eventually_elim"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>D - c' * g b' \\<le> c' * g x; b' \\<le> x\\<rbrakk>\n       \\<Longrightarrow> norm (integral {a..x} f) \\<le> c * norm (g x)", "case (elim x)"], ["proof (state)\nthis:\n  D - c' * g b' \\<le> c' * g x\n  b' \\<le> x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>D - c' * g b' \\<le> c' * g x; b' \\<le> x\\<rbrakk>\n       \\<Longrightarrow> norm (integral {a..x} f) \\<le> c * norm (g x)", "have b': \"a \\<le> b'\" \"b \\<le> b'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<le> b' &&& b \\<le> b'", "by (auto simp: b'_def)"], ["proof (state)\nthis:\n  a \\<le> b'\n  b \\<le> b'\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>D - c' * g b' \\<le> c' * g x; b' \\<le> x\\<rbrakk>\n       \\<Longrightarrow> norm (integral {a..x} f) \\<le> c * norm (g x)", "from elim b'"], ["proof (chain)\npicking this:\n  D - c' * g b' \\<le> c' * g x\n  b' \\<le> x\n  a \\<le> b'\n  b \\<le> b'", "have integrable: \"(\\<lambda>x. \\<bar>g' x\\<bar>) integrable_on {b'..x}\""], ["proof (prove)\nusing this:\n  D - c' * g b' \\<le> c' * g x\n  b' \\<le> x\n  a \\<le> b'\n  b \\<le> b'\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. \\<bar>g' x\\<bar>) integrable_on {b'..x}", "by (intro integrable_continuous_real continuous_intros) auto"], ["proof (state)\nthis:\n  (\\<lambda>x. \\<bar>g' x\\<bar>) integrable_on {b'..x}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>D - c' * g b' \\<le> c' * g x; b' \\<le> x\\<rbrakk>\n       \\<Longrightarrow> norm (integral {a..x} f) \\<le> c * norm (g x)", "have \"integral {a..x} f = integral {a..b'} f + integral {b'..x} f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. integral {a..x} f = integral {a..b'} f + integral {b'..x} f", "using elim b'"], ["proof (prove)\nusing this:\n  D - c' * g b' \\<le> c' * g x\n  b' \\<le> x\n  a \\<le> b'\n  b \\<le> b'\n\ngoal (1 subgoal):\n 1. integral {a..x} f = integral {a..b'} f + integral {b'..x} f", "by (intro Henstock_Kurzweil_Integration.integral_combine [symmetric] assms) auto"], ["proof (state)\nthis:\n  integral {a..x} f = integral {a..b'} f + integral {b'..x} f\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>D - c' * g b' \\<le> c' * g x; b' \\<le> x\\<rbrakk>\n       \\<Longrightarrow> norm (integral {a..x} f) \\<le> c * norm (g x)", "also"], ["proof (state)\nthis:\n  integral {a..x} f = integral {a..b'} f + integral {b'..x} f\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>D - c' * g b' \\<le> c' * g x; b' \\<le> x\\<rbrakk>\n       \\<Longrightarrow> norm (integral {a..x} f) \\<le> c * norm (g x)", "have \"norm \\<dots> \\<le> D + norm (integral {b'..x} f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norm (integral {a..b'} f + integral {b'..x} f)\n    \\<le> D + norm (integral {b'..x} f)", "unfolding D_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. norm (integral {a..b'} f + integral {b'..x} f)\n    \\<le> norm (integral {a..b'} f) + norm (integral {b'..x} f)", "by (rule norm_triangle_ineq)"], ["proof (state)\nthis:\n  norm (integral {a..b'} f + integral {b'..x} f)\n  \\<le> D + norm (integral {b'..x} f)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>D - c' * g b' \\<le> c' * g x; b' \\<le> x\\<rbrakk>\n       \\<Longrightarrow> norm (integral {a..x} f) \\<le> c * norm (g x)", "also"], ["proof (state)\nthis:\n  norm (integral {a..b'} f + integral {b'..x} f)\n  \\<le> D + norm (integral {b'..x} f)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>D - c' * g b' \\<le> c' * g x; b' \\<le> x\\<rbrakk>\n       \\<Longrightarrow> norm (integral {a..x} f) \\<le> c * norm (g x)", "have \"norm (integral {b'..x} f) \\<le> integral {b'..x} (\\<lambda>x. c' * norm (g' x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norm (integral {b'..x} f)\n    \\<le> integral {b'..x} (\\<lambda>x. c' * norm (g' x))", "using b' elim assms c' integrable"], ["proof (prove)\nusing this:\n  a \\<le> b'\n  b \\<le> b'\n  D - c' * g b' \\<le> c' * g x\n  b' \\<le> x\n  f \\<in> o(g')\n  filterlim g at_top at_top\n  \\<lbrakk>a \\<le> ?a'; ?a' \\<le> ?x\\<rbrakk>\n  \\<Longrightarrow> f integrable_on {?a'..?x}\n  a \\<le> ?x \\<Longrightarrow> (g has_real_derivative g' ?x) (at ?x)\n  continuous_on {a..} g'\n  a \\<le> ?x \\<Longrightarrow> 0 \\<le> g' ?x\n  0 < c'\n  (\\<lambda>x. \\<bar>g' x\\<bar>) integrable_on {b'..x}\n\ngoal (1 subgoal):\n 1. norm (integral {b'..x} f)\n    \\<le> integral {b'..x} (\\<lambda>x. c' * norm (g' x))", "by (intro integral_norm_bound_integral b assms) auto"], ["proof (state)\nthis:\n  norm (integral {b'..x} f)\n  \\<le> integral {b'..x} (\\<lambda>x. c' * norm (g' x))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>D - c' * g b' \\<le> c' * g x; b' \\<le> x\\<rbrakk>\n       \\<Longrightarrow> norm (integral {a..x} f) \\<le> c * norm (g x)", "also"], ["proof (state)\nthis:\n  norm (integral {b'..x} f)\n  \\<le> integral {b'..x} (\\<lambda>x. c' * norm (g' x))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>D - c' * g b' \\<le> c' * g x; b' \\<le> x\\<rbrakk>\n       \\<Longrightarrow> norm (integral {a..x} f) \\<le> c * norm (g x)", "have \"\\<dots> = c' * integral {b'..x} (\\<lambda>x. \\<bar>g' x\\<bar>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. integral {b'..x} (\\<lambda>x. c' * norm (g' x)) =\n    c' * integral {b'..x} (\\<lambda>x. \\<bar>g' x\\<bar>)", "by simp"], ["proof (state)\nthis:\n  integral {b'..x} (\\<lambda>x. c' * norm (g' x)) =\n  c' * integral {b'..x} (\\<lambda>x. \\<bar>g' x\\<bar>)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>D - c' * g b' \\<le> c' * g x; b' \\<le> x\\<rbrakk>\n       \\<Longrightarrow> norm (integral {a..x} f) \\<le> c * norm (g x)", "also"], ["proof (state)\nthis:\n  integral {b'..x} (\\<lambda>x. c' * norm (g' x)) =\n  c' * integral {b'..x} (\\<lambda>x. \\<bar>g' x\\<bar>)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>D - c' * g b' \\<le> c' * g x; b' \\<le> x\\<rbrakk>\n       \\<Longrightarrow> norm (integral {a..x} f) \\<le> c * norm (g x)", "have \"integral {b'..x} (\\<lambda>x. \\<bar>g' x\\<bar>) = integral {b'..x} g'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. integral {b'..x} (\\<lambda>x. \\<bar>g' x\\<bar>) = integral {b'..x} g'", "using assms b'"], ["proof (prove)\nusing this:\n  f \\<in> o(g')\n  filterlim g at_top at_top\n  \\<lbrakk>a \\<le> ?a'; ?a' \\<le> ?x\\<rbrakk>\n  \\<Longrightarrow> f integrable_on {?a'..?x}\n  a \\<le> ?x \\<Longrightarrow> (g has_real_derivative g' ?x) (at ?x)\n  continuous_on {a..} g'\n  a \\<le> ?x \\<Longrightarrow> 0 \\<le> g' ?x\n  a \\<le> b'\n  b \\<le> b'\n\ngoal (1 subgoal):\n 1. integral {b'..x} (\\<lambda>x. \\<bar>g' x\\<bar>) = integral {b'..x} g'", "by (intro integral_cong) auto"], ["proof (state)\nthis:\n  integral {b'..x} (\\<lambda>x. \\<bar>g' x\\<bar>) = integral {b'..x} g'\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>D - c' * g b' \\<le> c' * g x; b' \\<le> x\\<rbrakk>\n       \\<Longrightarrow> norm (integral {a..x} f) \\<le> c * norm (g x)", "also"], ["proof (state)\nthis:\n  integral {b'..x} (\\<lambda>x. \\<bar>g' x\\<bar>) = integral {b'..x} g'\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>D - c' * g b' \\<le> c' * g x; b' \\<le> x\\<rbrakk>\n       \\<Longrightarrow> norm (integral {a..x} f) \\<le> c * norm (g x)", "have \"(g' has_integral (g x - g b')) {b'..x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (g' has_integral g x - g b') {b'..x}", "using b' elim"], ["proof (prove)\nusing this:\n  a \\<le> b'\n  b \\<le> b'\n  D - c' * g b' \\<le> c' * g x\n  b' \\<le> x\n\ngoal (1 subgoal):\n 1. (g' has_integral g x - g b') {b'..x}", "by (intro fundamental_theorem_of_calculus)\n         (auto simp flip: has_field_derivative_iff_has_vector_derivative\n               intro!: has_field_derivative_at_within[OF deriv])"], ["proof (state)\nthis:\n  (g' has_integral g x - g b') {b'..x}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>D - c' * g b' \\<le> c' * g x; b' \\<le> x\\<rbrakk>\n       \\<Longrightarrow> norm (integral {a..x} f) \\<le> c * norm (g x)", "hence \"integral {b'..x} g' = g x - g b'\""], ["proof (prove)\nusing this:\n  (g' has_integral g x - g b') {b'..x}\n\ngoal (1 subgoal):\n 1. integral {b'..x} g' = g x - g b'", "by (simp add: has_integral_iff)"], ["proof (state)\nthis:\n  integral {b'..x} g' = g x - g b'\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>D - c' * g b' \\<le> c' * g x; b' \\<le> x\\<rbrakk>\n       \\<Longrightarrow> norm (integral {a..x} f) \\<le> c * norm (g x)", "also"], ["proof (state)\nthis:\n  integral {b'..x} g' = g x - g b'\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>D - c' * g b' \\<le> c' * g x; b' \\<le> x\\<rbrakk>\n       \\<Longrightarrow> norm (integral {a..x} f) \\<le> c * norm (g x)", "have \"D + c' * (g x - g b') \\<le> c * g x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. D + c' * (g x - g b') \\<le> c * g x", "using elim"], ["proof (prove)\nusing this:\n  D - c' * g b' \\<le> c' * g x\n  b' \\<le> x\n\ngoal (1 subgoal):\n 1. D + c' * (g x - g b') \\<le> c * g x", "by (simp add: field_simps c'_def)"], ["proof (state)\nthis:\n  D + c' * (g x - g b') \\<le> c * g x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>D - c' * g b' \\<le> c' * g x; b' \\<le> x\\<rbrakk>\n       \\<Longrightarrow> norm (integral {a..x} f) \\<le> c * norm (g x)", "also"], ["proof (state)\nthis:\n  D + c' * (g x - g b') \\<le> c * g x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>D - c' * g b' \\<le> c' * g x; b' \\<le> x\\<rbrakk>\n       \\<Longrightarrow> norm (integral {a..x} f) \\<le> c * norm (g x)", "have \"\\<dots> \\<le> c * norm (g x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c * g x \\<le> c * norm (g x)", "using c"], ["proof (prove)\nusing this:\n  0 < c\n\ngoal (1 subgoal):\n 1. c * g x \\<le> c * norm (g x)", "by (intro mult_left_mono) auto"], ["proof (state)\nthis:\n  c * g x \\<le> c * norm (g x)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>D - c' * g b' \\<le> c' * g x; b' \\<le> x\\<rbrakk>\n       \\<Longrightarrow> norm (integral {a..x} f) \\<le> c * norm (g x)", "finally"], ["proof (chain)\npicking this:\n  (\\<And>x y.\n      x \\<le> y \\<Longrightarrow> D + x \\<le> D + y) \\<Longrightarrow>\n  norm (integral {a..x} f) \\<le> c * norm (g x)", "show ?case"], ["proof (prove)\nusing this:\n  (\\<And>x y.\n      x \\<le> y \\<Longrightarrow> D + x \\<le> D + y) \\<Longrightarrow>\n  norm (integral {a..x} f) \\<le> c * norm (g x)\n\ngoal (1 subgoal):\n 1. norm (integral {a..x} f) \\<le> c * norm (g x)", "by simp"], ["proof (state)\nthis:\n  norm (integral {a..x} f) \\<le> c * norm (g x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in at_top.\n     norm (integral {a..x} f) \\<le> c * norm (g x)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma integral_bigo:\n  fixes f g g' :: \"real \\<Rightarrow> real\"\n  assumes \"f \\<in> O(g')\" and \"filterlim g at_top at_top\"\n  assumes \"\\<And>a' x. a \\<le> a' \\<Longrightarrow> a' \\<le> x \\<Longrightarrow> f integrable_on {a'..x}\"\n  assumes deriv: \"\\<And>x. x \\<ge> a \\<Longrightarrow> (g has_field_derivative g' x) (at x within {a..})\"\n  assumes cont: \"continuous_on {a..} g'\"\n  assumes nonneg: \"\\<And>x. x \\<ge> a \\<Longrightarrow> g' x \\<ge> 0\"\n  shows   \"(\\<lambda>x. integral {a..x} f) \\<in> O(g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. integral {a..x} f) \\<in> O(g)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<lambda>x. integral {a..x} f) \\<in> O(g)", "note [continuous_intros] = continuous_on_subset[OF cont]"], ["proof (state)\nthis:\n  ?t \\<subseteq> {a..} \\<Longrightarrow> continuous_on ?t g'\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. integral {a..x} f) \\<in> O(g)", "from landau_o.bigE[OF assms(1)]"], ["proof (chain)\npicking this:\n  (\\<And>c.\n      \\<lbrakk>0 < c;\n       \\<forall>\\<^sub>F x in at_top.\n          norm (f x) \\<le> c * norm (g' x)\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis", "obtain c b where c: \"c > 0\" and b: \"\\<And>x. x \\<ge> b \\<Longrightarrow> norm (f x) \\<le> c * norm (g' x)\""], ["proof (prove)\nusing this:\n  (\\<And>c.\n      \\<lbrakk>0 < c;\n       \\<forall>\\<^sub>F x in at_top.\n          norm (f x) \\<le> c * norm (g' x)\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>c b.\n        \\<lbrakk>0 < c;\n         \\<And>x.\n            b \\<le> x \\<Longrightarrow>\n            norm (f x) \\<le> c * norm (g' x)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding eventually_at_top_linorder"], ["proof (prove)\nusing this:\n  (\\<And>c.\n      \\<lbrakk>0 < c;\n       \\<exists>N.\n          \\<forall>n\\<ge>N. norm (f n) \\<le> c * norm (g' n)\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>c b.\n        \\<lbrakk>0 < c;\n         \\<And>x.\n            b \\<le> x \\<Longrightarrow>\n            norm (f x) \\<le> c * norm (g' x)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  0 < c\n  b \\<le> ?x \\<Longrightarrow> norm (f ?x) \\<le> c * norm (g' ?x)\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. integral {a..x} f) \\<in> O(g)", "define c' where \"c' = c / 2\""], ["proof (state)\nthis:\n  c' = c / 2\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. integral {a..x} f) \\<in> O(g)", "define b' where \"b' = max a b\""], ["proof (state)\nthis:\n  b' = max a b\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. integral {a..x} f) \\<in> O(g)", "define D where \"D = norm (integral {a..b'} f)\""], ["proof (state)\nthis:\n  D = norm (integral {a..b'} f)\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. integral {a..x} f) \\<in> O(g)", "have \"filterlim (\\<lambda>x. c * g x) at_top at_top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LIM x at_top. c * g x :> at_top", "using c"], ["proof (prove)\nusing this:\n  0 < c\n\ngoal (1 subgoal):\n 1. LIM x at_top. c * g x :> at_top", "by (intro filterlim_tendsto_pos_mult_at_top[OF tendsto_const] assms)"], ["proof (state)\nthis:\n  LIM x at_top. c * g x :> at_top\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. integral {a..x} f) \\<in> O(g)", "hence \"eventually (\\<lambda>x. c * g x \\<ge> D - c * g b') at_top\""], ["proof (prove)\nusing this:\n  LIM x at_top. c * g x :> at_top\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_top. D - c * g b' \\<le> c * g x", "by (auto simp: filterlim_at_top)"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in at_top. D - c * g b' \\<le> c * g x\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. integral {a..x} f) \\<in> O(g)", "hence \"eventually (\\<lambda>x. norm (integral {a..x} f) \\<le> 2 * c * norm (g x)) at_top\""], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F x in at_top. D - c * g b' \\<le> c * g x\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_top.\n       norm (integral {a..x} f) \\<le> 2 * c * norm (g x)", "using eventually_ge_at_top[of b']"], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F x in at_top. D - c * g b' \\<le> c * g x\n  eventually ((\\<le>) b') at_top\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_top.\n       norm (integral {a..x} f) \\<le> 2 * c * norm (g x)", "proof eventually_elim"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>D - c * g b' \\<le> c * g x; b' \\<le> x\\<rbrakk>\n       \\<Longrightarrow> norm (integral {a..x} f) \\<le> 2 * c * norm (g x)", "case (elim x)"], ["proof (state)\nthis:\n  D - c * g b' \\<le> c * g x\n  b' \\<le> x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>D - c * g b' \\<le> c * g x; b' \\<le> x\\<rbrakk>\n       \\<Longrightarrow> norm (integral {a..x} f) \\<le> 2 * c * norm (g x)", "have b': \"a \\<le> b'\" \"b \\<le> b'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<le> b' &&& b \\<le> b'", "by (auto simp: b'_def)"], ["proof (state)\nthis:\n  a \\<le> b'\n  b \\<le> b'\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>D - c * g b' \\<le> c * g x; b' \\<le> x\\<rbrakk>\n       \\<Longrightarrow> norm (integral {a..x} f) \\<le> 2 * c * norm (g x)", "from elim b'"], ["proof (chain)\npicking this:\n  D - c * g b' \\<le> c * g x\n  b' \\<le> x\n  a \\<le> b'\n  b \\<le> b'", "have integrable: \"(\\<lambda>x. \\<bar>g' x\\<bar>) integrable_on {b'..x}\""], ["proof (prove)\nusing this:\n  D - c * g b' \\<le> c * g x\n  b' \\<le> x\n  a \\<le> b'\n  b \\<le> b'\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. \\<bar>g' x\\<bar>) integrable_on {b'..x}", "by (intro integrable_continuous_real continuous_intros) auto"], ["proof (state)\nthis:\n  (\\<lambda>x. \\<bar>g' x\\<bar>) integrable_on {b'..x}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>D - c * g b' \\<le> c * g x; b' \\<le> x\\<rbrakk>\n       \\<Longrightarrow> norm (integral {a..x} f) \\<le> 2 * c * norm (g x)", "have \"integral {a..x} f = integral {a..b'} f + integral {b'..x} f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. integral {a..x} f = integral {a..b'} f + integral {b'..x} f", "using elim b'"], ["proof (prove)\nusing this:\n  D - c * g b' \\<le> c * g x\n  b' \\<le> x\n  a \\<le> b'\n  b \\<le> b'\n\ngoal (1 subgoal):\n 1. integral {a..x} f = integral {a..b'} f + integral {b'..x} f", "by (intro Henstock_Kurzweil_Integration.integral_combine [symmetric] assms) auto"], ["proof (state)\nthis:\n  integral {a..x} f = integral {a..b'} f + integral {b'..x} f\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>D - c * g b' \\<le> c * g x; b' \\<le> x\\<rbrakk>\n       \\<Longrightarrow> norm (integral {a..x} f) \\<le> 2 * c * norm (g x)", "also"], ["proof (state)\nthis:\n  integral {a..x} f = integral {a..b'} f + integral {b'..x} f\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>D - c * g b' \\<le> c * g x; b' \\<le> x\\<rbrakk>\n       \\<Longrightarrow> norm (integral {a..x} f) \\<le> 2 * c * norm (g x)", "have \"norm \\<dots> \\<le> D + norm (integral {b'..x} f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norm (integral {a..b'} f + integral {b'..x} f)\n    \\<le> D + norm (integral {b'..x} f)", "unfolding D_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. norm (integral {a..b'} f + integral {b'..x} f)\n    \\<le> norm (integral {a..b'} f) + norm (integral {b'..x} f)", "by (rule norm_triangle_ineq)"], ["proof (state)\nthis:\n  norm (integral {a..b'} f + integral {b'..x} f)\n  \\<le> D + norm (integral {b'..x} f)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>D - c * g b' \\<le> c * g x; b' \\<le> x\\<rbrakk>\n       \\<Longrightarrow> norm (integral {a..x} f) \\<le> 2 * c * norm (g x)", "also"], ["proof (state)\nthis:\n  norm (integral {a..b'} f + integral {b'..x} f)\n  \\<le> D + norm (integral {b'..x} f)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>D - c * g b' \\<le> c * g x; b' \\<le> x\\<rbrakk>\n       \\<Longrightarrow> norm (integral {a..x} f) \\<le> 2 * c * norm (g x)", "have \"norm (integral {b'..x} f) \\<le> integral {b'..x} (\\<lambda>x. c * norm (g' x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norm (integral {b'..x} f)\n    \\<le> integral {b'..x} (\\<lambda>x. c * norm (g' x))", "using b' elim assms c integrable"], ["proof (prove)\nusing this:\n  a \\<le> b'\n  b \\<le> b'\n  D - c * g b' \\<le> c * g x\n  b' \\<le> x\n  f \\<in> O(g')\n  filterlim g at_top at_top\n  \\<lbrakk>a \\<le> ?a'; ?a' \\<le> ?x\\<rbrakk>\n  \\<Longrightarrow> f integrable_on {?a'..?x}\n  a \\<le> ?x \\<Longrightarrow>\n  (g has_real_derivative g' ?x) (at ?x within {a..})\n  continuous_on {a..} g'\n  a \\<le> ?x \\<Longrightarrow> 0 \\<le> g' ?x\n  0 < c\n  (\\<lambda>x. \\<bar>g' x\\<bar>) integrable_on {b'..x}\n\ngoal (1 subgoal):\n 1. norm (integral {b'..x} f)\n    \\<le> integral {b'..x} (\\<lambda>x. c * norm (g' x))", "by (intro integral_norm_bound_integral b assms) auto"], ["proof (state)\nthis:\n  norm (integral {b'..x} f)\n  \\<le> integral {b'..x} (\\<lambda>x. c * norm (g' x))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>D - c * g b' \\<le> c * g x; b' \\<le> x\\<rbrakk>\n       \\<Longrightarrow> norm (integral {a..x} f) \\<le> 2 * c * norm (g x)", "also"], ["proof (state)\nthis:\n  norm (integral {b'..x} f)\n  \\<le> integral {b'..x} (\\<lambda>x. c * norm (g' x))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>D - c * g b' \\<le> c * g x; b' \\<le> x\\<rbrakk>\n       \\<Longrightarrow> norm (integral {a..x} f) \\<le> 2 * c * norm (g x)", "have \"\\<dots> = c * integral {b'..x} (\\<lambda>x. \\<bar>g' x\\<bar>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. integral {b'..x} (\\<lambda>x. c * norm (g' x)) =\n    c * integral {b'..x} (\\<lambda>x. \\<bar>g' x\\<bar>)", "by simp"], ["proof (state)\nthis:\n  integral {b'..x} (\\<lambda>x. c * norm (g' x)) =\n  c * integral {b'..x} (\\<lambda>x. \\<bar>g' x\\<bar>)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>D - c * g b' \\<le> c * g x; b' \\<le> x\\<rbrakk>\n       \\<Longrightarrow> norm (integral {a..x} f) \\<le> 2 * c * norm (g x)", "also"], ["proof (state)\nthis:\n  integral {b'..x} (\\<lambda>x. c * norm (g' x)) =\n  c * integral {b'..x} (\\<lambda>x. \\<bar>g' x\\<bar>)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>D - c * g b' \\<le> c * g x; b' \\<le> x\\<rbrakk>\n       \\<Longrightarrow> norm (integral {a..x} f) \\<le> 2 * c * norm (g x)", "have \"integral {b'..x} (\\<lambda>x. \\<bar>g' x\\<bar>) = integral {b'..x} g'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. integral {b'..x} (\\<lambda>x. \\<bar>g' x\\<bar>) = integral {b'..x} g'", "using assms b'"], ["proof (prove)\nusing this:\n  f \\<in> O(g')\n  filterlim g at_top at_top\n  \\<lbrakk>a \\<le> ?a'; ?a' \\<le> ?x\\<rbrakk>\n  \\<Longrightarrow> f integrable_on {?a'..?x}\n  a \\<le> ?x \\<Longrightarrow>\n  (g has_real_derivative g' ?x) (at ?x within {a..})\n  continuous_on {a..} g'\n  a \\<le> ?x \\<Longrightarrow> 0 \\<le> g' ?x\n  a \\<le> b'\n  b \\<le> b'\n\ngoal (1 subgoal):\n 1. integral {b'..x} (\\<lambda>x. \\<bar>g' x\\<bar>) = integral {b'..x} g'", "by (intro integral_cong) auto"], ["proof (state)\nthis:\n  integral {b'..x} (\\<lambda>x. \\<bar>g' x\\<bar>) = integral {b'..x} g'\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>D - c * g b' \\<le> c * g x; b' \\<le> x\\<rbrakk>\n       \\<Longrightarrow> norm (integral {a..x} f) \\<le> 2 * c * norm (g x)", "also"], ["proof (state)\nthis:\n  integral {b'..x} (\\<lambda>x. \\<bar>g' x\\<bar>) = integral {b'..x} g'\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>D - c * g b' \\<le> c * g x; b' \\<le> x\\<rbrakk>\n       \\<Longrightarrow> norm (integral {a..x} f) \\<le> 2 * c * norm (g x)", "have \"(g' has_integral (g x - g b')) {b'..x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (g' has_integral g x - g b') {b'..x}", "using b' elim"], ["proof (prove)\nusing this:\n  a \\<le> b'\n  b \\<le> b'\n  D - c * g b' \\<le> c * g x\n  b' \\<le> x\n\ngoal (1 subgoal):\n 1. (g' has_integral g x - g b') {b'..x}", "by (intro fundamental_theorem_of_calculus)\n         (auto simp flip: has_field_derivative_iff_has_vector_derivative\n               intro!: DERIV_subset[OF deriv])"], ["proof (state)\nthis:\n  (g' has_integral g x - g b') {b'..x}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>D - c * g b' \\<le> c * g x; b' \\<le> x\\<rbrakk>\n       \\<Longrightarrow> norm (integral {a..x} f) \\<le> 2 * c * norm (g x)", "hence \"integral {b'..x} g' = g x - g b'\""], ["proof (prove)\nusing this:\n  (g' has_integral g x - g b') {b'..x}\n\ngoal (1 subgoal):\n 1. integral {b'..x} g' = g x - g b'", "by (simp add: has_integral_iff)"], ["proof (state)\nthis:\n  integral {b'..x} g' = g x - g b'\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>D - c * g b' \\<le> c * g x; b' \\<le> x\\<rbrakk>\n       \\<Longrightarrow> norm (integral {a..x} f) \\<le> 2 * c * norm (g x)", "also"], ["proof (state)\nthis:\n  integral {b'..x} g' = g x - g b'\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>D - c * g b' \\<le> c * g x; b' \\<le> x\\<rbrakk>\n       \\<Longrightarrow> norm (integral {a..x} f) \\<le> 2 * c * norm (g x)", "have \"D + c * (g x - g b') \\<le> 2 * c * g x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. D + c * (g x - g b') \\<le> 2 * c * g x", "using elim"], ["proof (prove)\nusing this:\n  D - c * g b' \\<le> c * g x\n  b' \\<le> x\n\ngoal (1 subgoal):\n 1. D + c * (g x - g b') \\<le> 2 * c * g x", "by (simp add: field_simps c'_def)"], ["proof (state)\nthis:\n  D + c * (g x - g b') \\<le> 2 * c * g x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>D - c * g b' \\<le> c * g x; b' \\<le> x\\<rbrakk>\n       \\<Longrightarrow> norm (integral {a..x} f) \\<le> 2 * c * norm (g x)", "also"], ["proof (state)\nthis:\n  D + c * (g x - g b') \\<le> 2 * c * g x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>D - c * g b' \\<le> c * g x; b' \\<le> x\\<rbrakk>\n       \\<Longrightarrow> norm (integral {a..x} f) \\<le> 2 * c * norm (g x)", "have \"\\<dots> \\<le> 2 * c * norm (g x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * c * g x \\<le> 2 * c * norm (g x)", "using c"], ["proof (prove)\nusing this:\n  0 < c\n\ngoal (1 subgoal):\n 1. 2 * c * g x \\<le> 2 * c * norm (g x)", "by (intro mult_left_mono) auto"], ["proof (state)\nthis:\n  2 * c * g x \\<le> 2 * c * norm (g x)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>D - c * g b' \\<le> c * g x; b' \\<le> x\\<rbrakk>\n       \\<Longrightarrow> norm (integral {a..x} f) \\<le> 2 * c * norm (g x)", "finally"], ["proof (chain)\npicking this:\n  (\\<And>x y.\n      x \\<le> y \\<Longrightarrow> D + x \\<le> D + y) \\<Longrightarrow>\n  norm (integral {a..x} f) \\<le> 2 * c * norm (g x)", "show ?case"], ["proof (prove)\nusing this:\n  (\\<And>x y.\n      x \\<le> y \\<Longrightarrow> D + x \\<le> D + y) \\<Longrightarrow>\n  norm (integral {a..x} f) \\<le> 2 * c * norm (g x)\n\ngoal (1 subgoal):\n 1. norm (integral {a..x} f) \\<le> 2 * c * norm (g x)", "by simp"], ["proof (state)\nthis:\n  norm (integral {a..x} f) \\<le> 2 * c * norm (g x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in at_top.\n     norm (integral {a..x} f) \\<le> 2 * c * norm (g x)\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. integral {a..x} f) \\<in> O(g)", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F x in at_top.\n     norm (integral {a..x} f) \\<le> 2 * c * norm (g x)\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. integral {a..x} f) \\<in> O(g)", "by (rule bigoI)"], ["proof (state)\nthis:\n  (\\<lambda>x. integral {a..x} f) \\<in> O(g)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma primepows_le_subset:\n  assumes x: \"x > 0\" and l: \"l > 0\"\n  shows   \"{(p, i). prime p \\<and> l \\<le> i \\<and> real (p ^ i) \\<le> x} \\<subseteq> {..nat \\<lfloor>root l x\\<rfloor>} \\<times> {..nat \\<lfloor>log 2 x\\<rfloor>}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {(p, i). prime p \\<and> l \\<le> i \\<and> real (p ^ i) \\<le> x}\n    \\<subseteq> {..nat \\<lfloor>root l x\\<rfloor>} \\<times>\n                {..nat \\<lfloor>log 2 x\\<rfloor>}", "proof safe"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>prime a; l \\<le> b; real (a ^ b) \\<le> x\\<rbrakk>\n       \\<Longrightarrow> a \\<le> nat \\<lfloor>root l x\\<rfloor>\n 2. \\<And>a b.\n       \\<lbrakk>prime a; l \\<le> b; real (a ^ b) \\<le> x\\<rbrakk>\n       \\<Longrightarrow> b \\<le> nat \\<lfloor>log 2 x\\<rfloor>", "fix p i :: nat"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>prime a; l \\<le> b; real (a ^ b) \\<le> x\\<rbrakk>\n       \\<Longrightarrow> a \\<le> nat \\<lfloor>root l x\\<rfloor>\n 2. \\<And>a b.\n       \\<lbrakk>prime a; l \\<le> b; real (a ^ b) \\<le> x\\<rbrakk>\n       \\<Longrightarrow> b \\<le> nat \\<lfloor>log 2 x\\<rfloor>", "assume pi: \"prime p\" \"i \\<ge> l\" \"real (p ^ i) \\<le> x\""], ["proof (state)\nthis:\n  prime p\n  l \\<le> i\n  real (p ^ i) \\<le> x\n\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>prime a; l \\<le> b; real (a ^ b) \\<le> x\\<rbrakk>\n       \\<Longrightarrow> a \\<le> nat \\<lfloor>root l x\\<rfloor>\n 2. \\<And>a b.\n       \\<lbrakk>prime a; l \\<le> b; real (a ^ b) \\<le> x\\<rbrakk>\n       \\<Longrightarrow> b \\<le> nat \\<lfloor>log 2 x\\<rfloor>", "have \"real p ^ l \\<le> real p ^ i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real p ^ l \\<le> real p ^ i", "using pi x l"], ["proof (prove)\nusing this:\n  prime p\n  l \\<le> i\n  real (p ^ i) \\<le> x\n  0 < x\n  0 < l\n\ngoal (1 subgoal):\n 1. real p ^ l \\<le> real p ^ i", "by (intro power_increasing) (auto dest: prime_gt_0_nat)"], ["proof (state)\nthis:\n  real p ^ l \\<le> real p ^ i\n\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>prime a; l \\<le> b; real (a ^ b) \\<le> x\\<rbrakk>\n       \\<Longrightarrow> a \\<le> nat \\<lfloor>root l x\\<rfloor>\n 2. \\<And>a b.\n       \\<lbrakk>prime a; l \\<le> b; real (a ^ b) \\<le> x\\<rbrakk>\n       \\<Longrightarrow> b \\<le> nat \\<lfloor>log 2 x\\<rfloor>", "also"], ["proof (state)\nthis:\n  real p ^ l \\<le> real p ^ i\n\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>prime a; l \\<le> b; real (a ^ b) \\<le> x\\<rbrakk>\n       \\<Longrightarrow> a \\<le> nat \\<lfloor>root l x\\<rfloor>\n 2. \\<And>a b.\n       \\<lbrakk>prime a; l \\<le> b; real (a ^ b) \\<le> x\\<rbrakk>\n       \\<Longrightarrow> b \\<le> nat \\<lfloor>log 2 x\\<rfloor>", "have \"\\<dots> \\<le> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real p ^ i \\<le> x", "using pi"], ["proof (prove)\nusing this:\n  prime p\n  l \\<le> i\n  real (p ^ i) \\<le> x\n\ngoal (1 subgoal):\n 1. real p ^ i \\<le> x", "by simp"], ["proof (state)\nthis:\n  real p ^ i \\<le> x\n\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>prime a; l \\<le> b; real (a ^ b) \\<le> x\\<rbrakk>\n       \\<Longrightarrow> a \\<le> nat \\<lfloor>root l x\\<rfloor>\n 2. \\<And>a b.\n       \\<lbrakk>prime a; l \\<le> b; real (a ^ b) \\<le> x\\<rbrakk>\n       \\<Longrightarrow> b \\<le> nat \\<lfloor>log 2 x\\<rfloor>", "finally"], ["proof (chain)\npicking this:\n  real p ^ l \\<le> x", "have \"root l (real p ^ l) \\<le> root l x\""], ["proof (prove)\nusing this:\n  real p ^ l \\<le> x\n\ngoal (1 subgoal):\n 1. root l (real p ^ l) \\<le> root l x", "using x pi l"], ["proof (prove)\nusing this:\n  real p ^ l \\<le> x\n  0 < x\n  prime p\n  l \\<le> i\n  real (p ^ i) \\<le> x\n  0 < l\n\ngoal (1 subgoal):\n 1. root l (real p ^ l) \\<le> root l x", "by (subst real_root_le_iff) auto"], ["proof (state)\nthis:\n  root l (real p ^ l) \\<le> root l x\n\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>prime a; l \\<le> b; real (a ^ b) \\<le> x\\<rbrakk>\n       \\<Longrightarrow> a \\<le> nat \\<lfloor>root l x\\<rfloor>\n 2. \\<And>a b.\n       \\<lbrakk>prime a; l \\<le> b; real (a ^ b) \\<le> x\\<rbrakk>\n       \\<Longrightarrow> b \\<le> nat \\<lfloor>log 2 x\\<rfloor>", "also"], ["proof (state)\nthis:\n  root l (real p ^ l) \\<le> root l x\n\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>prime a; l \\<le> b; real (a ^ b) \\<le> x\\<rbrakk>\n       \\<Longrightarrow> a \\<le> nat \\<lfloor>root l x\\<rfloor>\n 2. \\<And>a b.\n       \\<lbrakk>prime a; l \\<le> b; real (a ^ b) \\<le> x\\<rbrakk>\n       \\<Longrightarrow> b \\<le> nat \\<lfloor>log 2 x\\<rfloor>", "have \"root l (real p ^ l) = real p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. root l (real p ^ l) = real p", "using pi l"], ["proof (prove)\nusing this:\n  prime p\n  l \\<le> i\n  real (p ^ i) \\<le> x\n  0 < l\n\ngoal (1 subgoal):\n 1. root l (real p ^ l) = real p", "by (subst real_root_pos2) auto"], ["proof (state)\nthis:\n  root l (real p ^ l) = real p\n\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>prime a; l \\<le> b; real (a ^ b) \\<le> x\\<rbrakk>\n       \\<Longrightarrow> a \\<le> nat \\<lfloor>root l x\\<rfloor>\n 2. \\<And>a b.\n       \\<lbrakk>prime a; l \\<le> b; real (a ^ b) \\<le> x\\<rbrakk>\n       \\<Longrightarrow> b \\<le> nat \\<lfloor>log 2 x\\<rfloor>", "finally"], ["proof (chain)\npicking this:\n  real p \\<le> root l x", "show \"p \\<le> nat \\<lfloor>root l x\\<rfloor>\""], ["proof (prove)\nusing this:\n  real p \\<le> root l x\n\ngoal (1 subgoal):\n 1. p \\<le> nat \\<lfloor>root l x\\<rfloor>", "using pi l x"], ["proof (prove)\nusing this:\n  real p \\<le> root l x\n  prime p\n  l \\<le> i\n  real (p ^ i) \\<le> x\n  0 < l\n  0 < x\n\ngoal (1 subgoal):\n 1. p \\<le> nat \\<lfloor>root l x\\<rfloor>", "by (simp add: le_nat_iff' le_floor_iff)"], ["proof (state)\nthis:\n  p \\<le> nat \\<lfloor>root l x\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>prime a; l \\<le> b; real (a ^ b) \\<le> x\\<rbrakk>\n       \\<Longrightarrow> b \\<le> nat \\<lfloor>log 2 x\\<rfloor>", "from pi"], ["proof (chain)\npicking this:\n  prime p\n  l \\<le> i\n  real (p ^ i) \\<le> x", "have \"2 ^ i \\<le> real p ^ i\""], ["proof (prove)\nusing this:\n  prime p\n  l \\<le> i\n  real (p ^ i) \\<le> x\n\ngoal (1 subgoal):\n 1. 2 ^ i \\<le> real p ^ i", "using l"], ["proof (prove)\nusing this:\n  prime p\n  l \\<le> i\n  real (p ^ i) \\<le> x\n  0 < l\n\ngoal (1 subgoal):\n 1. 2 ^ i \\<le> real p ^ i", "by (intro power_mono) (auto dest: prime_gt_1_nat)"], ["proof (state)\nthis:\n  2 ^ i \\<le> real p ^ i\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>prime a; l \\<le> b; real (a ^ b) \\<le> x\\<rbrakk>\n       \\<Longrightarrow> b \\<le> nat \\<lfloor>log 2 x\\<rfloor>", "also"], ["proof (state)\nthis:\n  2 ^ i \\<le> real p ^ i\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>prime a; l \\<le> b; real (a ^ b) \\<le> x\\<rbrakk>\n       \\<Longrightarrow> b \\<le> nat \\<lfloor>log 2 x\\<rfloor>", "have \"\\<dots> \\<le> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real p ^ i \\<le> x", "using pi"], ["proof (prove)\nusing this:\n  prime p\n  l \\<le> i\n  real (p ^ i) \\<le> x\n\ngoal (1 subgoal):\n 1. real p ^ i \\<le> x", "by simp"], ["proof (state)\nthis:\n  real p ^ i \\<le> x\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>prime a; l \\<le> b; real (a ^ b) \\<le> x\\<rbrakk>\n       \\<Longrightarrow> b \\<le> nat \\<lfloor>log 2 x\\<rfloor>", "finally"], ["proof (chain)\npicking this:\n  2 ^ i \\<le> x", "show \"i \\<le> nat \\<lfloor>log 2 x\\<rfloor>\""], ["proof (prove)\nusing this:\n  2 ^ i \\<le> x\n\ngoal (1 subgoal):\n 1. i \\<le> nat \\<lfloor>log 2 x\\<rfloor>", "using pi x"], ["proof (prove)\nusing this:\n  2 ^ i \\<le> x\n  prime p\n  l \\<le> i\n  real (p ^ i) \\<le> x\n  0 < x\n\ngoal (1 subgoal):\n 1. i \\<le> nat \\<lfloor>log 2 x\\<rfloor>", "by (auto simp: le_nat_iff' le_floor_iff le_log_iff powr_realpow)"], ["proof (state)\nthis:\n  i \\<le> nat \\<lfloor>log 2 x\\<rfloor>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mangoldt_non_primepow: \"\\<not>primepow n \\<Longrightarrow> mangoldt n = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> primepow n \\<Longrightarrow> mangoldt n = (0::'a)", "by (auto simp: mangoldt_def)"], ["", "lemma le_imp_bigo_real:\n  assumes \"c \\<ge> 0\" \"eventually (\\<lambda>x. f x \\<le> c * (g x :: real)) F\" \"eventually (\\<lambda>x. 0 \\<le> f x) F\"\n  shows   \"f \\<in> O[F](g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<in> O[F](g)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. f \\<in> O[F](g)", "have \"eventually (\\<lambda>x. norm (f x) \\<le> c * norm (g x)) F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in F. norm (f x) \\<le> c * norm (g x)", "using assms(2,3)"], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F x in F. f x \\<le> c * g x\n  \\<forall>\\<^sub>F x in F. 0 \\<le> f x\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in F. norm (f x) \\<le> c * norm (g x)", "proof eventually_elim"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>f x \\<le> c * g x; 0 \\<le> f x\\<rbrakk>\n       \\<Longrightarrow> norm (f x) \\<le> c * norm (g x)", "case (elim x)"], ["proof (state)\nthis:\n  f x \\<le> c * g x\n  0 \\<le> f x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>f x \\<le> c * g x; 0 \\<le> f x\\<rbrakk>\n       \\<Longrightarrow> norm (f x) \\<le> c * norm (g x)", "have \"norm (f x) \\<le> c * g x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norm (f x) \\<le> c * g x", "using elim"], ["proof (prove)\nusing this:\n  f x \\<le> c * g x\n  0 \\<le> f x\n\ngoal (1 subgoal):\n 1. norm (f x) \\<le> c * g x", "by simp"], ["proof (state)\nthis:\n  norm (f x) \\<le> c * g x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>f x \\<le> c * g x; 0 \\<le> f x\\<rbrakk>\n       \\<Longrightarrow> norm (f x) \\<le> c * norm (g x)", "also"], ["proof (state)\nthis:\n  norm (f x) \\<le> c * g x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>f x \\<le> c * g x; 0 \\<le> f x\\<rbrakk>\n       \\<Longrightarrow> norm (f x) \\<le> c * norm (g x)", "have \"\\<dots> \\<le> c * norm (g x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c * g x \\<le> c * norm (g x)", "by (intro mult_left_mono assms) auto"], ["proof (state)\nthis:\n  c * g x \\<le> c * norm (g x)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>f x \\<le> c * g x; 0 \\<le> f x\\<rbrakk>\n       \\<Longrightarrow> norm (f x) \\<le> c * norm (g x)", "finally"], ["proof (chain)\npicking this:\n  norm (f x) \\<le> c * norm (g x)", "show ?case"], ["proof (prove)\nusing this:\n  norm (f x) \\<le> c * norm (g x)\n\ngoal (1 subgoal):\n 1. norm (f x) \\<le> c * norm (g x)", "."], ["proof (state)\nthis:\n  norm (f x) \\<le> c * norm (g x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in F. norm (f x) \\<le> c * norm (g x)\n\ngoal (1 subgoal):\n 1. f \\<in> O[F](g)", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F x in F. norm (f x) \\<le> c * norm (g x)\n\ngoal (1 subgoal):\n 1. f \\<in> O[F](g)", "by (intro bigoI[of _ c]) auto"], ["proof (state)\nthis:\n  f \\<in> O[F](g)\n\ngoal:\nNo subgoals!", "qed"], ["", "(* TODO: unneeded. But why does real_asymp not work? *)"], ["", "lemma ln_minus_ln_floor_bigo: \"(\\<lambda>x. ln x - ln (real (nat \\<lfloor>x\\<rfloor>))) \\<in> O(\\<lambda>_. 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. ln x - ln (real (nat \\<lfloor>x\\<rfloor>)))\n    \\<in> O(\\<lambda>_. 1)", "proof (intro le_imp_bigo_real[of 1] eventually_mono[OF eventually_ge_at_top[of 1]])"], ["proof (state)\ngoal (3 subgoals):\n 1. 0 \\<le> 1\n 2. \\<And>x.\n       1 \\<le> x \\<Longrightarrow>\n       ln x - ln (real (nat \\<lfloor>x\\<rfloor>)) \\<le> 1 * 1\n 3. \\<And>x.\n       1 \\<le> x \\<Longrightarrow>\n       0 \\<le> ln x - ln (real (nat \\<lfloor>x\\<rfloor>))", "fix x :: real"], ["proof (state)\ngoal (3 subgoals):\n 1. 0 \\<le> 1\n 2. \\<And>x.\n       1 \\<le> x \\<Longrightarrow>\n       ln x - ln (real (nat \\<lfloor>x\\<rfloor>)) \\<le> 1 * 1\n 3. \\<And>x.\n       1 \\<le> x \\<Longrightarrow>\n       0 \\<le> ln x - ln (real (nat \\<lfloor>x\\<rfloor>))", "assume x: \"x \\<ge> 1\""], ["proof (state)\nthis:\n  1 \\<le> x\n\ngoal (3 subgoals):\n 1. 0 \\<le> 1\n 2. \\<And>x.\n       1 \\<le> x \\<Longrightarrow>\n       ln x - ln (real (nat \\<lfloor>x\\<rfloor>)) \\<le> 1 * 1\n 3. \\<And>x.\n       1 \\<le> x \\<Longrightarrow>\n       0 \\<le> ln x - ln (real (nat \\<lfloor>x\\<rfloor>))", "from x"], ["proof (chain)\npicking this:\n  1 \\<le> x", "have *: \"x - real (nat \\<lfloor>x\\<rfloor>) \\<le> 1\""], ["proof (prove)\nusing this:\n  1 \\<le> x\n\ngoal (1 subgoal):\n 1. x - real (nat \\<lfloor>x\\<rfloor>) \\<le> 1", "by linarith"], ["proof (state)\nthis:\n  x - real (nat \\<lfloor>x\\<rfloor>) \\<le> 1\n\ngoal (3 subgoals):\n 1. 0 \\<le> 1\n 2. \\<And>x.\n       1 \\<le> x \\<Longrightarrow>\n       ln x - ln (real (nat \\<lfloor>x\\<rfloor>)) \\<le> 1 * 1\n 3. \\<And>x.\n       1 \\<le> x \\<Longrightarrow>\n       0 \\<le> ln x - ln (real (nat \\<lfloor>x\\<rfloor>))", "from x"], ["proof (chain)\npicking this:\n  1 \\<le> x", "have \"ln x - ln (real (nat \\<lfloor>x\\<rfloor>)) \\<le> (x - real (nat \\<lfloor>x\\<rfloor>)) / real (nat \\<lfloor>x\\<rfloor>)\""], ["proof (prove)\nusing this:\n  1 \\<le> x\n\ngoal (1 subgoal):\n 1. ln x - ln (real (nat \\<lfloor>x\\<rfloor>))\n    \\<le> (x - real (nat \\<lfloor>x\\<rfloor>)) /\n          real (nat \\<lfloor>x\\<rfloor>)", "by (intro ln_diff_le) auto"], ["proof (state)\nthis:\n  ln x - ln (real (nat \\<lfloor>x\\<rfloor>))\n  \\<le> (x - real (nat \\<lfloor>x\\<rfloor>)) /\n        real (nat \\<lfloor>x\\<rfloor>)\n\ngoal (3 subgoals):\n 1. 0 \\<le> 1\n 2. \\<And>x.\n       1 \\<le> x \\<Longrightarrow>\n       ln x - ln (real (nat \\<lfloor>x\\<rfloor>)) \\<le> 1 * 1\n 3. \\<And>x.\n       1 \\<le> x \\<Longrightarrow>\n       0 \\<le> ln x - ln (real (nat \\<lfloor>x\\<rfloor>))", "also"], ["proof (state)\nthis:\n  ln x - ln (real (nat \\<lfloor>x\\<rfloor>))\n  \\<le> (x - real (nat \\<lfloor>x\\<rfloor>)) /\n        real (nat \\<lfloor>x\\<rfloor>)\n\ngoal (3 subgoals):\n 1. 0 \\<le> 1\n 2. \\<And>x.\n       1 \\<le> x \\<Longrightarrow>\n       ln x - ln (real (nat \\<lfloor>x\\<rfloor>)) \\<le> 1 * 1\n 3. \\<And>x.\n       1 \\<le> x \\<Longrightarrow>\n       0 \\<le> ln x - ln (real (nat \\<lfloor>x\\<rfloor>))", "have \"\\<dots> \\<le> 1 / 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x - real (nat \\<lfloor>x\\<rfloor>)) / real (nat \\<lfloor>x\\<rfloor>)\n    \\<le> 1 / 1", "using x *"], ["proof (prove)\nusing this:\n  1 \\<le> x\n  x - real (nat \\<lfloor>x\\<rfloor>) \\<le> 1\n\ngoal (1 subgoal):\n 1. (x - real (nat \\<lfloor>x\\<rfloor>)) / real (nat \\<lfloor>x\\<rfloor>)\n    \\<le> 1 / 1", "by (intro frac_le) auto"], ["proof (state)\nthis:\n  (x - real (nat \\<lfloor>x\\<rfloor>)) / real (nat \\<lfloor>x\\<rfloor>)\n  \\<le> 1 / 1\n\ngoal (3 subgoals):\n 1. 0 \\<le> 1\n 2. \\<And>x.\n       1 \\<le> x \\<Longrightarrow>\n       ln x - ln (real (nat \\<lfloor>x\\<rfloor>)) \\<le> 1 * 1\n 3. \\<And>x.\n       1 \\<le> x \\<Longrightarrow>\n       0 \\<le> ln x - ln (real (nat \\<lfloor>x\\<rfloor>))", "finally"], ["proof (chain)\npicking this:\n  ln x - ln (real (nat \\<lfloor>x\\<rfloor>)) \\<le> 1 / 1", "show \"ln x - ln (real (nat \\<lfloor>x\\<rfloor>)) \\<le> 1 * 1\""], ["proof (prove)\nusing this:\n  ln x - ln (real (nat \\<lfloor>x\\<rfloor>)) \\<le> 1 / 1\n\ngoal (1 subgoal):\n 1. ln x - ln (real (nat \\<lfloor>x\\<rfloor>)) \\<le> 1 * 1", "by simp"], ["proof (state)\nthis:\n  ln x - ln (real (nat \\<lfloor>x\\<rfloor>)) \\<le> 1 * 1\n\ngoal (2 subgoals):\n 1. 0 \\<le> 1\n 2. \\<And>x.\n       1 \\<le> x \\<Longrightarrow>\n       0 \\<le> ln x - ln (real (nat \\<lfloor>x\\<rfloor>))", "qed auto"], ["", "lemma cos_geD:\n  assumes \"cos x \\<ge> cos a\" \"0 \\<le> a\" \"a \\<le> pi\" \"-pi \\<le> x\" \"x \\<le> pi\"\n  shows   \"x \\<in> {-a..a}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> {- a..a}", "proof (cases \"x \\<ge> 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 \\<le> x \\<Longrightarrow> x \\<in> {- a..a}\n 2. \\<not> 0 \\<le> x \\<Longrightarrow> x \\<in> {- a..a}", "case True"], ["proof (state)\nthis:\n  0 \\<le> x\n\ngoal (2 subgoals):\n 1. 0 \\<le> x \\<Longrightarrow> x \\<in> {- a..a}\n 2. \\<not> 0 \\<le> x \\<Longrightarrow> x \\<in> {- a..a}", "with assms"], ["proof (chain)\npicking this:\n  cos a \\<le> cos x\n  0 \\<le> a\n  a \\<le> pi\n  - pi \\<le> x\n  x \\<le> pi\n  0 \\<le> x", "show ?thesis"], ["proof (prove)\nusing this:\n  cos a \\<le> cos x\n  0 \\<le> a\n  a \\<le> pi\n  - pi \\<le> x\n  x \\<le> pi\n  0 \\<le> x\n\ngoal (1 subgoal):\n 1. x \\<in> {- a..a}", "by (subst (asm) cos_mono_le_eq) auto"], ["proof (state)\nthis:\n  x \\<in> {- a..a}\n\ngoal (1 subgoal):\n 1. \\<not> 0 \\<le> x \\<Longrightarrow> x \\<in> {- a..a}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> 0 \\<le> x \\<Longrightarrow> x \\<in> {- a..a}", "case False"], ["proof (state)\nthis:\n  \\<not> 0 \\<le> x\n\ngoal (1 subgoal):\n 1. \\<not> 0 \\<le> x \\<Longrightarrow> x \\<in> {- a..a}", "with assms"], ["proof (chain)\npicking this:\n  cos a \\<le> cos x\n  0 \\<le> a\n  a \\<le> pi\n  - pi \\<le> x\n  x \\<le> pi\n  \\<not> 0 \\<le> x", "show ?thesis"], ["proof (prove)\nusing this:\n  cos a \\<le> cos x\n  0 \\<le> a\n  a \\<le> pi\n  - pi \\<le> x\n  x \\<le> pi\n  \\<not> 0 \\<le> x\n\ngoal (1 subgoal):\n 1. x \\<in> {- a..a}", "using cos_mono_le_eq[of a \"-x\"]"], ["proof (prove)\nusing this:\n  cos a \\<le> cos x\n  0 \\<le> a\n  a \\<le> pi\n  - pi \\<le> x\n  x \\<le> pi\n  \\<not> 0 \\<le> x\n  \\<lbrakk>0 \\<le> a; a \\<le> pi; 0 \\<le> - x; - x \\<le> pi\\<rbrakk>\n  \\<Longrightarrow> (cos a \\<le> cos (- x)) = (- x \\<le> a)\n\ngoal (1 subgoal):\n 1. x \\<in> {- a..a}", "by auto"], ["proof (state)\nthis:\n  x \\<in> {- a..a}\n\ngoal:\nNo subgoals!", "qed"], ["", "(* TODO: Could be generalised *)"], ["", "lemma path_image_part_circlepath_same_Re:\n  assumes \"0 \\<le> b\" \"b \\<le> pi\" \"a = -b\" \"r \\<ge> 0\"\n  shows   \"path_image (part_circlepath c r a b) = sphere c r \\<inter> {s. Re s \\<ge> Re c + r * cos a}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path_image (part_circlepath c r a b) =\n    sphere c r \\<inter> {s. Re c + r * cos a \\<le> Re s}", "proof safe"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x.\n       x \\<in> path_image (part_circlepath c r a b) \\<Longrightarrow>\n       x \\<in> sphere c r\n 2. \\<And>x.\n       x \\<in> path_image (part_circlepath c r a b) \\<Longrightarrow>\n       Re c + r * cos a \\<le> Re x\n 3. \\<And>x.\n       \\<lbrakk>x \\<in> sphere c r; Re c + r * cos a \\<le> Re x\\<rbrakk>\n       \\<Longrightarrow> x \\<in> path_image (part_circlepath c r a b)", "fix z"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x.\n       x \\<in> path_image (part_circlepath c r a b) \\<Longrightarrow>\n       x \\<in> sphere c r\n 2. \\<And>x.\n       x \\<in> path_image (part_circlepath c r a b) \\<Longrightarrow>\n       Re c + r * cos a \\<le> Re x\n 3. \\<And>x.\n       \\<lbrakk>x \\<in> sphere c r; Re c + r * cos a \\<le> Re x\\<rbrakk>\n       \\<Longrightarrow> x \\<in> path_image (part_circlepath c r a b)", "assume \"z \\<in> path_image (part_circlepath c r a b)\""], ["proof (state)\nthis:\n  z \\<in> path_image (part_circlepath c r a b)\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       x \\<in> path_image (part_circlepath c r a b) \\<Longrightarrow>\n       x \\<in> sphere c r\n 2. \\<And>x.\n       x \\<in> path_image (part_circlepath c r a b) \\<Longrightarrow>\n       Re c + r * cos a \\<le> Re x\n 3. \\<And>x.\n       \\<lbrakk>x \\<in> sphere c r; Re c + r * cos a \\<le> Re x\\<rbrakk>\n       \\<Longrightarrow> x \\<in> path_image (part_circlepath c r a b)", "with assms"], ["proof (chain)\npicking this:\n  0 \\<le> b\n  b \\<le> pi\n  a = - b\n  0 \\<le> r\n  z \\<in> path_image (part_circlepath c r a b)", "obtain t where t: \"t \\<in> {a..b}\" \"z = c + of_real r * cis t\""], ["proof (prove)\nusing this:\n  0 \\<le> b\n  b \\<le> pi\n  a = - b\n  0 \\<le> r\n  z \\<in> path_image (part_circlepath c r a b)\n\ngoal (1 subgoal):\n 1. (\\<And>t.\n        \\<lbrakk>t \\<in> {a..b}; z = c + complex_of_real r * cis t\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: path_image_part_circlepath exp_eq_polar)"], ["proof (state)\nthis:\n  t \\<in> {a..b}\n  z = c + complex_of_real r * cis t\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       x \\<in> path_image (part_circlepath c r a b) \\<Longrightarrow>\n       x \\<in> sphere c r\n 2. \\<And>x.\n       x \\<in> path_image (part_circlepath c r a b) \\<Longrightarrow>\n       Re c + r * cos a \\<le> Re x\n 3. \\<And>x.\n       \\<lbrakk>x \\<in> sphere c r; Re c + r * cos a \\<le> Re x\\<rbrakk>\n       \\<Longrightarrow> x \\<in> path_image (part_circlepath c r a b)", "from t and assms"], ["proof (chain)\npicking this:\n  t \\<in> {a..b}\n  z = c + complex_of_real r * cis t\n  0 \\<le> b\n  b \\<le> pi\n  a = - b\n  0 \\<le> r", "show \"z \\<in> sphere c r\""], ["proof (prove)\nusing this:\n  t \\<in> {a..b}\n  z = c + complex_of_real r * cis t\n  0 \\<le> b\n  b \\<le> pi\n  a = - b\n  0 \\<le> r\n\ngoal (1 subgoal):\n 1. z \\<in> sphere c r", "by (auto simp: dist_norm norm_mult)"], ["proof (state)\nthis:\n  z \\<in> sphere c r\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> path_image (part_circlepath c r a b) \\<Longrightarrow>\n       Re c + r * cos a \\<le> Re x\n 2. \\<And>x.\n       \\<lbrakk>x \\<in> sphere c r; Re c + r * cos a \\<le> Re x\\<rbrakk>\n       \\<Longrightarrow> x \\<in> path_image (part_circlepath c r a b)", "from t and assms"], ["proof (chain)\npicking this:\n  t \\<in> {a..b}\n  z = c + complex_of_real r * cis t\n  0 \\<le> b\n  b \\<le> pi\n  a = - b\n  0 \\<le> r", "show \"Re z \\<ge> Re c + r * cos a\""], ["proof (prove)\nusing this:\n  t \\<in> {a..b}\n  z = c + complex_of_real r * cis t\n  0 \\<le> b\n  b \\<le> pi\n  a = - b\n  0 \\<le> r\n\ngoal (1 subgoal):\n 1. Re c + r * cos a \\<le> Re z", "using cos_monotone_0_pi_le[of t b] cos_monotone_minus_pi_0'[of a t]"], ["proof (prove)\nusing this:\n  t \\<in> {a..b}\n  z = c + complex_of_real r * cis t\n  0 \\<le> b\n  b \\<le> pi\n  a = - b\n  0 \\<le> r\n  \\<lbrakk>0 \\<le> t; t \\<le> b; b \\<le> pi\\<rbrakk>\n  \\<Longrightarrow> cos b \\<le> cos t\n  \\<lbrakk>- pi \\<le> a; a \\<le> t; t \\<le> 0\\<rbrakk>\n  \\<Longrightarrow> cos a \\<le> cos t\n\ngoal (1 subgoal):\n 1. Re c + r * cos a \\<le> Re z", "by (cases \"t \\<ge> 0\") (auto intro!: mult_left_mono)"], ["proof (state)\nthis:\n  Re c + r * cos a \\<le> Re z\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> sphere c r; Re c + r * cos a \\<le> Re x\\<rbrakk>\n       \\<Longrightarrow> x \\<in> path_image (part_circlepath c r a b)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> sphere c r; Re c + r * cos a \\<le> Re x\\<rbrakk>\n       \\<Longrightarrow> x \\<in> path_image (part_circlepath c r a b)", "fix z"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> sphere c r; Re c + r * cos a \\<le> Re x\\<rbrakk>\n       \\<Longrightarrow> x \\<in> path_image (part_circlepath c r a b)", "assume z: \"z \\<in> sphere c r\" \"Re z \\<ge> Re c + r * cos a\""], ["proof (state)\nthis:\n  z \\<in> sphere c r\n  Re c + r * cos a \\<le> Re z\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> sphere c r; Re c + r * cos a \\<le> Re x\\<rbrakk>\n       \\<Longrightarrow> x \\<in> path_image (part_circlepath c r a b)", "show \"z \\<in> path_image (part_circlepath c r a b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z \\<in> path_image (part_circlepath c r a b)", "proof (cases \"r = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. r = 0 \\<Longrightarrow> z \\<in> path_image (part_circlepath c r a b)\n 2. r \\<noteq> 0 \\<Longrightarrow>\n    z \\<in> path_image (part_circlepath c r a b)", "case False"], ["proof (state)\nthis:\n  r \\<noteq> 0\n\ngoal (2 subgoals):\n 1. r = 0 \\<Longrightarrow> z \\<in> path_image (part_circlepath c r a b)\n 2. r \\<noteq> 0 \\<Longrightarrow>\n    z \\<in> path_image (part_circlepath c r a b)", "with assms"], ["proof (chain)\npicking this:\n  0 \\<le> b\n  b \\<le> pi\n  a = - b\n  0 \\<le> r\n  r \\<noteq> 0", "have r: \"r > 0\""], ["proof (prove)\nusing this:\n  0 \\<le> b\n  b \\<le> pi\n  a = - b\n  0 \\<le> r\n  r \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 0 < r", "by simp"], ["proof (state)\nthis:\n  0 < r\n\ngoal (2 subgoals):\n 1. r = 0 \\<Longrightarrow> z \\<in> path_image (part_circlepath c r a b)\n 2. r \\<noteq> 0 \\<Longrightarrow>\n    z \\<in> path_image (part_circlepath c r a b)", "with z"], ["proof (chain)\npicking this:\n  z \\<in> sphere c r\n  Re c + r * cos a \\<le> Re z\n  0 < r", "have z_eq: \"z = c + r * cis (Arg (z - c))\""], ["proof (prove)\nusing this:\n  z \\<in> sphere c r\n  Re c + r * cos a \\<le> Re z\n  0 < r\n\ngoal (1 subgoal):\n 1. z = c + complex_of_real r * cis (Arg (z - c))", "using Arg_eq[of \"z - c\"]"], ["proof (prove)\nusing this:\n  z \\<in> sphere c r\n  Re c + r * cos a \\<le> Re z\n  0 < r\n  z - c \\<noteq> 0 \\<Longrightarrow>\n  z - c =\n  complex_of_real (cmod (z - c)) *\n  exp (\\<i> * complex_of_real (Arg (z - c)))\n\ngoal (1 subgoal):\n 1. z = c + complex_of_real r * cis (Arg (z - c))", "by (auto simp: dist_norm exp_eq_polar norm_minus_commute)"], ["proof (state)\nthis:\n  z = c + complex_of_real r * cis (Arg (z - c))\n\ngoal (2 subgoals):\n 1. r = 0 \\<Longrightarrow> z \\<in> path_image (part_circlepath c r a b)\n 2. r \\<noteq> 0 \\<Longrightarrow>\n    z \\<in> path_image (part_circlepath c r a b)", "moreover"], ["proof (state)\nthis:\n  z = c + complex_of_real r * cis (Arg (z - c))\n\ngoal (2 subgoals):\n 1. r = 0 \\<Longrightarrow> z \\<in> path_image (part_circlepath c r a b)\n 2. r \\<noteq> 0 \\<Longrightarrow>\n    z \\<in> path_image (part_circlepath c r a b)", "from z(2) r assms"], ["proof (chain)\npicking this:\n  Re c + r * cos a \\<le> Re z\n  0 < r\n  0 \\<le> b\n  b \\<le> pi\n  a = - b\n  0 \\<le> r", "have \"cos b \\<le> cos (Arg (z - c))\""], ["proof (prove)\nusing this:\n  Re c + r * cos a \\<le> Re z\n  0 < r\n  0 \\<le> b\n  b \\<le> pi\n  a = - b\n  0 \\<le> r\n\ngoal (1 subgoal):\n 1. cos b \\<le> cos (Arg (z - c))", "by (subst (asm) z_eq) auto"], ["proof (state)\nthis:\n  cos b \\<le> cos (Arg (z - c))\n\ngoal (2 subgoals):\n 1. r = 0 \\<Longrightarrow> z \\<in> path_image (part_circlepath c r a b)\n 2. r \\<noteq> 0 \\<Longrightarrow>\n    z \\<in> path_image (part_circlepath c r a b)", "with assms"], ["proof (chain)\npicking this:\n  0 \\<le> b\n  b \\<le> pi\n  a = - b\n  0 \\<le> r\n  cos b \\<le> cos (Arg (z - c))", "have \"Arg (z - c) \\<in> {-b..b}\""], ["proof (prove)\nusing this:\n  0 \\<le> b\n  b \\<le> pi\n  a = - b\n  0 \\<le> r\n  cos b \\<le> cos (Arg (z - c))\n\ngoal (1 subgoal):\n 1. Arg (z - c) \\<in> {- b..b}", "using Arg_le_pi[of \"z - c\"] mpi_less_Arg[of \"z - c\"]"], ["proof (prove)\nusing this:\n  0 \\<le> b\n  b \\<le> pi\n  a = - b\n  0 \\<le> r\n  cos b \\<le> cos (Arg (z - c))\n  Arg (z - c) \\<le> pi\n  - pi < Arg (z - c)\n\ngoal (1 subgoal):\n 1. Arg (z - c) \\<in> {- b..b}", "by (intro cos_geD) auto"], ["proof (state)\nthis:\n  Arg (z - c) \\<in> {- b..b}\n\ngoal (2 subgoals):\n 1. r = 0 \\<Longrightarrow> z \\<in> path_image (part_circlepath c r a b)\n 2. r \\<noteq> 0 \\<Longrightarrow>\n    z \\<in> path_image (part_circlepath c r a b)", "ultimately"], ["proof (chain)\npicking this:\n  z = c + complex_of_real r * cis (Arg (z - c))\n  Arg (z - c) \\<in> {- b..b}", "show \"z \\<in> path_image (part_circlepath c r a b)\""], ["proof (prove)\nusing this:\n  z = c + complex_of_real r * cis (Arg (z - c))\n  Arg (z - c) \\<in> {- b..b}\n\ngoal (1 subgoal):\n 1. z \\<in> path_image (part_circlepath c r a b)", "using assms"], ["proof (prove)\nusing this:\n  z = c + complex_of_real r * cis (Arg (z - c))\n  Arg (z - c) \\<in> {- b..b}\n  0 \\<le> b\n  b \\<le> pi\n  a = - b\n  0 \\<le> r\n\ngoal (1 subgoal):\n 1. z \\<in> path_image (part_circlepath c r a b)", "by (subst path_image_part_circlepath) (auto simp: exp_eq_polar)"], ["proof (state)\nthis:\n  z \\<in> path_image (part_circlepath c r a b)\n\ngoal (1 subgoal):\n 1. r = 0 \\<Longrightarrow> z \\<in> path_image (part_circlepath c r a b)", "qed (insert assms z, auto simp: path_image_part_circlepath)"], ["proof (state)\nthis:\n  z \\<in> path_image (part_circlepath c r a b)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma part_circlepath_rotate_left:\n  \"part_circlepath c r (x + a) (x + b) = (\\<lambda>z. c + cis x * (z - c)) \\<circ> part_circlepath c r a b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. part_circlepath c r (x + a) (x + b) =\n    (\\<lambda>z. c + cis x * (z - c)) \\<circ> part_circlepath c r a b", "by (simp add: part_circlepath_def exp_eq_polar fun_eq_iff\n                linepath_translate_left linepath_translate_right cis_mult add_ac)"], ["", "lemma part_circlepath_rotate_right:\n  \"part_circlepath c r (a + x) (b + x) = (\\<lambda>z. c + cis x * (z - c)) \\<circ> part_circlepath c r a b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. part_circlepath c r (a + x) (b + x) =\n    (\\<lambda>z. c + cis x * (z - c)) \\<circ> part_circlepath c r a b", "by (simp add: part_circlepath_def exp_eq_polar fun_eq_iff\n                linepath_translate_left linepath_translate_right cis_mult add_ac)"], ["", "lemma path_image_semicircle_Re_ge:\n  assumes \"r \\<ge> 0\"\n  shows   \"path_image (part_circlepath c r (-pi/2) (pi/2)) =\n             sphere c r \\<inter> {s. Re s \\<ge> Re c}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path_image (part_circlepath c r (- pi / 2) (pi / 2)) =\n    sphere c r \\<inter> {s. Re c \\<le> Re s}", "by (subst path_image_part_circlepath_same_Re) (simp_all add: assms)"], ["", "lemma sphere_rotate: \"(\\<lambda>z. c + cis x * (z - c)) ` sphere c r = sphere c r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>z. c + cis x * (z - c)) ` sphere c r = sphere c r", "proof safe"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xa z.\n       z \\<in> sphere c r \\<Longrightarrow>\n       c + cis x * (z - c) \\<in> sphere c r\n 2. \\<And>xa.\n       xa \\<in> sphere c r \\<Longrightarrow>\n       xa \\<in> (\\<lambda>z. c + cis x * (z - c)) ` sphere c r", "fix z"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xa z.\n       z \\<in> sphere c r \\<Longrightarrow>\n       c + cis x * (z - c) \\<in> sphere c r\n 2. \\<And>xa.\n       xa \\<in> sphere c r \\<Longrightarrow>\n       xa \\<in> (\\<lambda>z. c + cis x * (z - c)) ` sphere c r", "assume z: \"z \\<in> sphere c r\""], ["proof (state)\nthis:\n  z \\<in> sphere c r\n\ngoal (2 subgoals):\n 1. \\<And>xa z.\n       z \\<in> sphere c r \\<Longrightarrow>\n       c + cis x * (z - c) \\<in> sphere c r\n 2. \\<And>xa.\n       xa \\<in> sphere c r \\<Longrightarrow>\n       xa \\<in> (\\<lambda>z. c + cis x * (z - c)) ` sphere c r", "hence \"z = c + cis x * (c + cis (-x) * (z - c) - c)\"\n        \"c + cis (-x) * (z - c) \\<in> sphere c r\""], ["proof (prove)\nusing this:\n  z \\<in> sphere c r\n\ngoal (1 subgoal):\n 1. z = c + cis x * (c + cis (- x) * (z - c) - c) &&&\n    c + cis (- x) * (z - c) \\<in> sphere c r", "by (auto simp: dist_norm norm_mult norm_minus_commute\n                   cis_conv_exp exp_minus field_simps norm_divide)"], ["proof (state)\nthis:\n  z = c + cis x * (c + cis (- x) * (z - c) - c)\n  c + cis (- x) * (z - c) \\<in> sphere c r\n\ngoal (2 subgoals):\n 1. \\<And>xa z.\n       z \\<in> sphere c r \\<Longrightarrow>\n       c + cis x * (z - c) \\<in> sphere c r\n 2. \\<And>xa.\n       xa \\<in> sphere c r \\<Longrightarrow>\n       xa \\<in> (\\<lambda>z. c + cis x * (z - c)) ` sphere c r", "with z"], ["proof (chain)\npicking this:\n  z \\<in> sphere c r\n  z = c + cis x * (c + cis (- x) * (z - c) - c)\n  c + cis (- x) * (z - c) \\<in> sphere c r", "show \"z \\<in> (\\<lambda>z. c + cis x * (z - c)) ` sphere c r\""], ["proof (prove)\nusing this:\n  z \\<in> sphere c r\n  z = c + cis x * (c + cis (- x) * (z - c) - c)\n  c + cis (- x) * (z - c) \\<in> sphere c r\n\ngoal (1 subgoal):\n 1. z \\<in> (\\<lambda>z. c + cis x * (z - c)) ` sphere c r", "by blast"], ["proof (state)\nthis:\n  z \\<in> (\\<lambda>z. c + cis x * (z - c)) ` sphere c r\n\ngoal (1 subgoal):\n 1. \\<And>xa z.\n       z \\<in> sphere c r \\<Longrightarrow>\n       c + cis x * (z - c) \\<in> sphere c r", "qed (auto simp: dist_norm norm_minus_commute norm_mult)"], ["", "lemma path_image_semicircle_Re_le:\n  assumes \"r \\<ge> 0\"\n  shows   \"path_image (part_circlepath c r (pi/2) (3/2*pi)) =\n             sphere c r \\<inter> {s. Re s \\<le> Re c}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path_image (part_circlepath c r (pi / 2) (3 / 2 * pi)) =\n    sphere c r \\<inter> {s. Re s \\<le> Re c}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. path_image (part_circlepath c r (pi / 2) (3 / 2 * pi)) =\n    sphere c r \\<inter> {s. Re s \\<le> Re c}", "let ?f = \"(\\<lambda>z. c + cis pi * (z - c))\""], ["proof (state)\ngoal (1 subgoal):\n 1. path_image (part_circlepath c r (pi / 2) (3 / 2 * pi)) =\n    sphere c r \\<inter> {s. Re s \\<le> Re c}", "have *: \"part_circlepath c r (pi/2) (3/2*pi) = part_circlepath c r (pi + (-pi/2)) (pi + pi/2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. part_circlepath c r (pi / 2) (3 / 2 * pi) =\n    part_circlepath c r (pi + - pi / 2) (pi + pi / 2)", "by simp"], ["proof (state)\nthis:\n  part_circlepath c r (pi / 2) (3 / 2 * pi) =\n  part_circlepath c r (pi + - pi / 2) (pi + pi / 2)\n\ngoal (1 subgoal):\n 1. path_image (part_circlepath c r (pi / 2) (3 / 2 * pi)) =\n    sphere c r \\<inter> {s. Re s \\<le> Re c}", "have \"path_image (part_circlepath c r (pi/2) (3/2*pi)) =\n          ?f ` sphere c r \\<inter> ?f ` {s. Re c \\<le> Re s}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path_image (part_circlepath c r (pi / 2) (3 / 2 * pi)) =\n    (\\<lambda>z. c + cis pi * (z - c)) ` sphere c r \\<inter>\n    (\\<lambda>z. c + cis pi * (z - c)) ` {s. Re c \\<le> Re s}", "unfolding * part_circlepath_rotate_left path_image_compose path_image_semicircle_Re_ge[OF assms]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>z. c + cis pi * (z - c)) `\n    (sphere c r \\<inter> {s. Re c \\<le> Re s}) =\n    (\\<lambda>z. c + cis pi * (z - c)) ` sphere c r \\<inter>\n    (\\<lambda>z. c + cis pi * (z - c)) ` {s. Re c \\<le> Re s}", "by auto"], ["proof (state)\nthis:\n  path_image (part_circlepath c r (pi / 2) (3 / 2 * pi)) =\n  (\\<lambda>z. c + cis pi * (z - c)) ` sphere c r \\<inter>\n  (\\<lambda>z. c + cis pi * (z - c)) ` {s. Re c \\<le> Re s}\n\ngoal (1 subgoal):\n 1. path_image (part_circlepath c r (pi / 2) (3 / 2 * pi)) =\n    sphere c r \\<inter> {s. Re s \\<le> Re c}", "also"], ["proof (state)\nthis:\n  path_image (part_circlepath c r (pi / 2) (3 / 2 * pi)) =\n  (\\<lambda>z. c + cis pi * (z - c)) ` sphere c r \\<inter>\n  (\\<lambda>z. c + cis pi * (z - c)) ` {s. Re c \\<le> Re s}\n\ngoal (1 subgoal):\n 1. path_image (part_circlepath c r (pi / 2) (3 / 2 * pi)) =\n    sphere c r \\<inter> {s. Re s \\<le> Re c}", "have \"?f ` sphere c r = sphere c r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>z. c + cis pi * (z - c)) ` sphere c r = sphere c r", "by (rule sphere_rotate)"], ["proof (state)\nthis:\n  (\\<lambda>z. c + cis pi * (z - c)) ` sphere c r = sphere c r\n\ngoal (1 subgoal):\n 1. path_image (part_circlepath c r (pi / 2) (3 / 2 * pi)) =\n    sphere c r \\<inter> {s. Re s \\<le> Re c}", "also"], ["proof (state)\nthis:\n  (\\<lambda>z. c + cis pi * (z - c)) ` sphere c r = sphere c r\n\ngoal (1 subgoal):\n 1. path_image (part_circlepath c r (pi / 2) (3 / 2 * pi)) =\n    sphere c r \\<inter> {s. Re s \\<le> Re c}", "have \"?f ` {s. Re c \\<le> Re s} = {s. Re c \\<ge> Re s}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>z. c + cis pi * (z - c)) ` {s. Re c \\<le> Re s} =\n    {s. Re s \\<le> Re c}", "by (auto simp: image_iff intro!: exI[of _ \"2 * c - x\" for x])"], ["proof (state)\nthis:\n  (\\<lambda>z. c + cis pi * (z - c)) ` {s. Re c \\<le> Re s} =\n  {s. Re s \\<le> Re c}\n\ngoal (1 subgoal):\n 1. path_image (part_circlepath c r (pi / 2) (3 / 2 * pi)) =\n    sphere c r \\<inter> {s. Re s \\<le> Re c}", "finally"], ["proof (chain)\npicking this:\n  path_image (part_circlepath c r (pi / 2) (3 / 2 * pi)) =\n  sphere c r \\<inter> {s. Re s \\<le> Re c}", "show ?thesis"], ["proof (prove)\nusing this:\n  path_image (part_circlepath c r (pi / 2) (3 / 2 * pi)) =\n  sphere c r \\<inter> {s. Re s \\<le> Re c}\n\ngoal (1 subgoal):\n 1. path_image (part_circlepath c r (pi / 2) (3 / 2 * pi)) =\n    sphere c r \\<inter> {s. Re s \\<le> Re c}", "."], ["proof (state)\nthis:\n  path_image (part_circlepath c r (pi / 2) (3 / 2 * pi)) =\n  sphere c r \\<inter> {s. Re s \\<le> Re c}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma path_image_semicircle_Im_ge:\n  assumes \"r \\<ge> 0\"\n  shows   \"path_image (part_circlepath c r 0 pi) =\n             sphere c r \\<inter> {s. Im s \\<ge> Im c}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path_image (part_circlepath c r 0 pi) =\n    sphere c r \\<inter> {s. Im c \\<le> Im s}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. path_image (part_circlepath c r 0 pi) =\n    sphere c r \\<inter> {s. Im c \\<le> Im s}", "let ?f = \"(\\<lambda>z. c + cis (pi/2) * (z - c))\""], ["proof (state)\ngoal (1 subgoal):\n 1. path_image (part_circlepath c r 0 pi) =\n    sphere c r \\<inter> {s. Im c \\<le> Im s}", "have *: \"part_circlepath c r 0 pi = part_circlepath c r (pi / 2 + (-pi/2)) (pi / 2 + pi/2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. part_circlepath c r 0 pi =\n    part_circlepath c r (pi / 2 + - pi / 2) (pi / 2 + pi / 2)", "by simp"], ["proof (state)\nthis:\n  part_circlepath c r 0 pi =\n  part_circlepath c r (pi / 2 + - pi / 2) (pi / 2 + pi / 2)\n\ngoal (1 subgoal):\n 1. path_image (part_circlepath c r 0 pi) =\n    sphere c r \\<inter> {s. Im c \\<le> Im s}", "have \"path_image (part_circlepath c r 0 pi) =\n          ?f ` sphere c r \\<inter> ?f ` {s. Re c \\<le> Re s}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path_image (part_circlepath c r 0 pi) =\n    (\\<lambda>z. c + cis (pi / 2) * (z - c)) ` sphere c r \\<inter>\n    (\\<lambda>z. c + cis (pi / 2) * (z - c)) ` {s. Re c \\<le> Re s}", "unfolding * part_circlepath_rotate_left path_image_compose path_image_semicircle_Re_ge[OF assms]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>z. c + cis (pi / 2) * (z - c)) `\n    (sphere c r \\<inter> {s. Re c \\<le> Re s}) =\n    (\\<lambda>z. c + cis (pi / 2) * (z - c)) ` sphere c r \\<inter>\n    (\\<lambda>z. c + cis (pi / 2) * (z - c)) ` {s. Re c \\<le> Re s}", "by auto"], ["proof (state)\nthis:\n  path_image (part_circlepath c r 0 pi) =\n  (\\<lambda>z. c + cis (pi / 2) * (z - c)) ` sphere c r \\<inter>\n  (\\<lambda>z. c + cis (pi / 2) * (z - c)) ` {s. Re c \\<le> Re s}\n\ngoal (1 subgoal):\n 1. path_image (part_circlepath c r 0 pi) =\n    sphere c r \\<inter> {s. Im c \\<le> Im s}", "also"], ["proof (state)\nthis:\n  path_image (part_circlepath c r 0 pi) =\n  (\\<lambda>z. c + cis (pi / 2) * (z - c)) ` sphere c r \\<inter>\n  (\\<lambda>z. c + cis (pi / 2) * (z - c)) ` {s. Re c \\<le> Re s}\n\ngoal (1 subgoal):\n 1. path_image (part_circlepath c r 0 pi) =\n    sphere c r \\<inter> {s. Im c \\<le> Im s}", "have \"?f ` sphere c r = sphere c r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>z. c + cis (pi / 2) * (z - c)) ` sphere c r = sphere c r", "by (rule sphere_rotate)"], ["proof (state)\nthis:\n  (\\<lambda>z. c + cis (pi / 2) * (z - c)) ` sphere c r = sphere c r\n\ngoal (1 subgoal):\n 1. path_image (part_circlepath c r 0 pi) =\n    sphere c r \\<inter> {s. Im c \\<le> Im s}", "also"], ["proof (state)\nthis:\n  (\\<lambda>z. c + cis (pi / 2) * (z - c)) ` sphere c r = sphere c r\n\ngoal (1 subgoal):\n 1. path_image (part_circlepath c r 0 pi) =\n    sphere c r \\<inter> {s. Im c \\<le> Im s}", "have \"?f ` {s. Re c \\<le> Re s} = {s. Im c \\<le> Im s}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>z. c + cis (pi / 2) * (z - c)) ` {s. Re c \\<le> Re s} =\n    {s. Im c \\<le> Im s}", "by (auto simp: image_iff intro!: exI[of _ \"c - \\<i> * (x - c)\" for x])"], ["proof (state)\nthis:\n  (\\<lambda>z. c + cis (pi / 2) * (z - c)) ` {s. Re c \\<le> Re s} =\n  {s. Im c \\<le> Im s}\n\ngoal (1 subgoal):\n 1. path_image (part_circlepath c r 0 pi) =\n    sphere c r \\<inter> {s. Im c \\<le> Im s}", "finally"], ["proof (chain)\npicking this:\n  path_image (part_circlepath c r 0 pi) =\n  sphere c r \\<inter> {s. Im c \\<le> Im s}", "show ?thesis"], ["proof (prove)\nusing this:\n  path_image (part_circlepath c r 0 pi) =\n  sphere c r \\<inter> {s. Im c \\<le> Im s}\n\ngoal (1 subgoal):\n 1. path_image (part_circlepath c r 0 pi) =\n    sphere c r \\<inter> {s. Im c \\<le> Im s}", "."], ["proof (state)\nthis:\n  path_image (part_circlepath c r 0 pi) =\n  sphere c r \\<inter> {s. Im c \\<le> Im s}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma path_image_semicircle_Im_le:\n  assumes \"r \\<ge> 0\"\n  shows   \"path_image (part_circlepath c r pi (2 * pi)) =\n             sphere c r \\<inter> {s. Im s \\<le> Im c}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path_image (part_circlepath c r pi (2 * pi)) =\n    sphere c r \\<inter> {s. Im s \\<le> Im c}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. path_image (part_circlepath c r pi (2 * pi)) =\n    sphere c r \\<inter> {s. Im s \\<le> Im c}", "let ?f = \"(\\<lambda>z. c + cis (3*pi/2) * (z - c))\""], ["proof (state)\ngoal (1 subgoal):\n 1. path_image (part_circlepath c r pi (2 * pi)) =\n    sphere c r \\<inter> {s. Im s \\<le> Im c}", "have *: \"part_circlepath c r pi (2*pi) = part_circlepath c r (3*pi/2 + (-pi/2)) (3*pi/2 + pi/2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. part_circlepath c r pi (2 * pi) =\n    part_circlepath c r (3 * pi / 2 + - pi / 2) (3 * pi / 2 + pi / 2)", "by simp"], ["proof (state)\nthis:\n  part_circlepath c r pi (2 * pi) =\n  part_circlepath c r (3 * pi / 2 + - pi / 2) (3 * pi / 2 + pi / 2)\n\ngoal (1 subgoal):\n 1. path_image (part_circlepath c r pi (2 * pi)) =\n    sphere c r \\<inter> {s. Im s \\<le> Im c}", "have \"path_image (part_circlepath c r pi (2 * pi)) =\n          ?f ` sphere c r \\<inter> ?f ` {s. Re c \\<le> Re s}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path_image (part_circlepath c r pi (2 * pi)) =\n    (\\<lambda>z. c + cis (3 * pi / 2) * (z - c)) ` sphere c r \\<inter>\n    (\\<lambda>z. c + cis (3 * pi / 2) * (z - c)) ` {s. Re c \\<le> Re s}", "unfolding * part_circlepath_rotate_left path_image_compose path_image_semicircle_Re_ge[OF assms]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>z. c + cis (3 * pi / 2) * (z - c)) `\n    (sphere c r \\<inter> {s. Re c \\<le> Re s}) =\n    (\\<lambda>z. c + cis (3 * pi / 2) * (z - c)) ` sphere c r \\<inter>\n    (\\<lambda>z. c + cis (3 * pi / 2) * (z - c)) ` {s. Re c \\<le> Re s}", "by auto"], ["proof (state)\nthis:\n  path_image (part_circlepath c r pi (2 * pi)) =\n  (\\<lambda>z. c + cis (3 * pi / 2) * (z - c)) ` sphere c r \\<inter>\n  (\\<lambda>z. c + cis (3 * pi / 2) * (z - c)) ` {s. Re c \\<le> Re s}\n\ngoal (1 subgoal):\n 1. path_image (part_circlepath c r pi (2 * pi)) =\n    sphere c r \\<inter> {s. Im s \\<le> Im c}", "also"], ["proof (state)\nthis:\n  path_image (part_circlepath c r pi (2 * pi)) =\n  (\\<lambda>z. c + cis (3 * pi / 2) * (z - c)) ` sphere c r \\<inter>\n  (\\<lambda>z. c + cis (3 * pi / 2) * (z - c)) ` {s. Re c \\<le> Re s}\n\ngoal (1 subgoal):\n 1. path_image (part_circlepath c r pi (2 * pi)) =\n    sphere c r \\<inter> {s. Im s \\<le> Im c}", "have \"?f ` sphere c r = sphere c r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>z. c + cis (3 * pi / 2) * (z - c)) ` sphere c r = sphere c r", "by (rule sphere_rotate)"], ["proof (state)\nthis:\n  (\\<lambda>z. c + cis (3 * pi / 2) * (z - c)) ` sphere c r = sphere c r\n\ngoal (1 subgoal):\n 1. path_image (part_circlepath c r pi (2 * pi)) =\n    sphere c r \\<inter> {s. Im s \\<le> Im c}", "also"], ["proof (state)\nthis:\n  (\\<lambda>z. c + cis (3 * pi / 2) * (z - c)) ` sphere c r = sphere c r\n\ngoal (1 subgoal):\n 1. path_image (part_circlepath c r pi (2 * pi)) =\n    sphere c r \\<inter> {s. Im s \\<le> Im c}", "have \"cis (3 * pi / 2) = -\\<i>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cis (3 * pi / 2) = - \\<i>", "using cis_mult[of pi \"pi / 2\"]"], ["proof (prove)\nusing this:\n  cis pi * cis (pi / 2) = cis (pi + pi / 2)\n\ngoal (1 subgoal):\n 1. cis (3 * pi / 2) = - \\<i>", "by simp"], ["proof (state)\nthis:\n  cis (3 * pi / 2) = - \\<i>\n\ngoal (1 subgoal):\n 1. path_image (part_circlepath c r pi (2 * pi)) =\n    sphere c r \\<inter> {s. Im s \\<le> Im c}", "hence \"?f ` {s. Re c \\<le> Re s} = {s. Im c \\<ge> Im s}\""], ["proof (prove)\nusing this:\n  cis (3 * pi / 2) = - \\<i>\n\ngoal (1 subgoal):\n 1. (\\<lambda>z. c + cis (3 * pi / 2) * (z - c)) ` {s. Re c \\<le> Re s} =\n    {s. Im s \\<le> Im c}", "by (auto simp: image_iff intro!: exI[of _ \"c + \\<i> * (x - c)\" for x])"], ["proof (state)\nthis:\n  (\\<lambda>z. c + cis (3 * pi / 2) * (z - c)) ` {s. Re c \\<le> Re s} =\n  {s. Im s \\<le> Im c}\n\ngoal (1 subgoal):\n 1. path_image (part_circlepath c r pi (2 * pi)) =\n    sphere c r \\<inter> {s. Im s \\<le> Im c}", "finally"], ["proof (chain)\npicking this:\n  path_image (part_circlepath c r pi (2 * pi)) =\n  sphere c r \\<inter> {s. Im s \\<le> Im c}", "show ?thesis"], ["proof (prove)\nusing this:\n  path_image (part_circlepath c r pi (2 * pi)) =\n  sphere c r \\<inter> {s. Im s \\<le> Im c}\n\ngoal (1 subgoal):\n 1. path_image (part_circlepath c r pi (2 * pi)) =\n    sphere c r \\<inter> {s. Im s \\<le> Im c}", "."], ["proof (state)\nthis:\n  path_image (part_circlepath c r pi (2 * pi)) =\n  sphere c r \\<inter> {s. Im s \\<le> Im c}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma powr_numeral [simp]: \"x \\<ge> 0 \\<Longrightarrow> (x::real) powr numeral y = x ^ numeral y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> x \\<Longrightarrow> x powr numeral y = x ^ numeral y", "using powr_numeral[of x y]"], ["proof (prove)\nusing this:\n  0 \\<le> x \\<Longrightarrow> x powr numeral y = x ^ numeral y\n\ngoal (1 subgoal):\n 1. 0 \\<le> x \\<Longrightarrow> x powr numeral y = x ^ numeral y", "by (cases \"x = 0\") auto"], ["", "lemma eval_fds_logderiv_zeta_real:\n  assumes \"x > (1 :: real)\"\n  shows  \"(\\<lambda>p. ln (real p) / (p powr x - 1)) abs_summable_on {p. prime p}\" (is ?th1)\n    and  \"deriv zeta (of_real x) / zeta (of_real x) =\n            -of_real (\\<Sum>\\<^sub>ap | prime p. ln (real p) / (p powr x - 1))\" (is ?th2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>p. ln (real p) / (real p powr x - 1)) abs_summable_on\n    {p. prime p} &&&\n    deriv zeta (complex_of_real x) / zeta (complex_of_real x) =\n    - complex_of_real\n       (\\<Sum>\\<^sub>ap | prime p. ln (real p) / (real p powr x - 1))", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<lambda>p. ln (real p) / (real p powr x - 1)) abs_summable_on\n    {p. prime p}\n 2. deriv zeta (complex_of_real x) / zeta (complex_of_real x) =\n    - complex_of_real\n       (\\<Sum>\\<^sub>ap | prime p. ln (real p) / (real p powr x - 1))", "have \"(\\<lambda>p. Re (of_real (ln (real p)) / (of_nat p powr of_real x - 1)))\n          abs_summable_on {p. prime p}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>p.\n        Re (complex_of_real (ln (real p)) /\n            (of_nat p powr complex_of_real x - 1))) abs_summable_on\n    {p. prime p}", "using assms"], ["proof (prove)\nusing this:\n  1 < x\n\ngoal (1 subgoal):\n 1. (\\<lambda>p.\n        Re (complex_of_real (ln (real p)) /\n            (of_nat p powr complex_of_real x - 1))) abs_summable_on\n    {p. prime p}", "by (intro abs_summable_Re eval_fds_logderiv_zeta) auto"], ["proof (state)\nthis:\n  (\\<lambda>p.\n      Re (complex_of_real (ln (real p)) /\n          (of_nat p powr complex_of_real x - 1))) abs_summable_on\n  {p. prime p}\n\ngoal (2 subgoals):\n 1. (\\<lambda>p. ln (real p) / (real p powr x - 1)) abs_summable_on\n    {p. prime p}\n 2. deriv zeta (complex_of_real x) / zeta (complex_of_real x) =\n    - complex_of_real\n       (\\<Sum>\\<^sub>ap | prime p. ln (real p) / (real p powr x - 1))", "also"], ["proof (state)\nthis:\n  (\\<lambda>p.\n      Re (complex_of_real (ln (real p)) /\n          (of_nat p powr complex_of_real x - 1))) abs_summable_on\n  {p. prime p}\n\ngoal (2 subgoals):\n 1. (\\<lambda>p. ln (real p) / (real p powr x - 1)) abs_summable_on\n    {p. prime p}\n 2. deriv zeta (complex_of_real x) / zeta (complex_of_real x) =\n    - complex_of_real\n       (\\<Sum>\\<^sub>ap | prime p. ln (real p) / (real p powr x - 1))", "have \"?this \\<longleftrightarrow> ?th1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>p.\n         Re (complex_of_real (ln (real p)) /\n             (of_nat p powr complex_of_real x - 1))) abs_summable_on\n     {p. prime p}) =\n    ((\\<lambda>p. ln (real p) / (real p powr x - 1)) abs_summable_on\n     {p. prime p})", "by (intro abs_summable_on_cong) (auto simp: powr_Reals_eq)"], ["proof (state)\nthis:\n  ((\\<lambda>p.\n       Re (complex_of_real (ln (real p)) /\n           (of_nat p powr complex_of_real x - 1))) abs_summable_on\n   {p. prime p}) =\n  ((\\<lambda>p. ln (real p) / (real p powr x - 1)) abs_summable_on\n   {p. prime p})\n\ngoal (2 subgoals):\n 1. (\\<lambda>p. ln (real p) / (real p powr x - 1)) abs_summable_on\n    {p. prime p}\n 2. deriv zeta (complex_of_real x) / zeta (complex_of_real x) =\n    - complex_of_real\n       (\\<Sum>\\<^sub>ap | prime p. ln (real p) / (real p powr x - 1))", "finally"], ["proof (chain)\npicking this:\n  (\\<lambda>p. ln (real p) / (real p powr x - 1)) abs_summable_on\n  {p. prime p}", "show ?th1"], ["proof (prove)\nusing this:\n  (\\<lambda>p. ln (real p) / (real p powr x - 1)) abs_summable_on\n  {p. prime p}\n\ngoal (1 subgoal):\n 1. (\\<lambda>p. ln (real p) / (real p powr x - 1)) abs_summable_on\n    {p. prime p}", "."], ["proof (state)\nthis:\n  (\\<lambda>p. ln (real p) / (real p powr x - 1)) abs_summable_on\n  {p. prime p}\n\ngoal (1 subgoal):\n 1. deriv zeta (complex_of_real x) / zeta (complex_of_real x) =\n    - complex_of_real\n       (\\<Sum>\\<^sub>ap | prime p. ln (real p) / (real p powr x - 1))", "show ?th2"], ["proof (prove)\ngoal (1 subgoal):\n 1. deriv zeta (complex_of_real x) / zeta (complex_of_real x) =\n    - complex_of_real\n       (\\<Sum>\\<^sub>ap | prime p. ln (real p) / (real p powr x - 1))", "using assms"], ["proof (prove)\nusing this:\n  1 < x\n\ngoal (1 subgoal):\n 1. deriv zeta (complex_of_real x) / zeta (complex_of_real x) =\n    - complex_of_real\n       (\\<Sum>\\<^sub>ap | prime p. ln (real p) / (real p powr x - 1))", "by (subst eval_fds_logderiv_zeta) (auto simp: infsetsum_of_real [symmetric] powr_Reals_eq)"], ["proof (state)\nthis:\n  deriv zeta (complex_of_real x) / zeta (complex_of_real x) =\n  - complex_of_real\n     (\\<Sum>\\<^sub>ap | prime p. ln (real p) / (real p powr x - 1))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma\n  fixes a b c d :: real\n  assumes ab: \"d * a + b \\<ge> 1\" and c: \"c < -1\" and d: \"d > 0\"\n  defines \"C \\<equiv> - ((ln (d * a + b) - 1 / (c + 1)) * (d * a + b) powr (c + 1) / (d * (c + 1)))\"\n  shows set_integrable_ln_powr_at_top:\n          \"(\\<lambda>x. (ln (d * x + b) * ((d * x + b) powr c))) absolutely_integrable_on {a<..}\" (is ?th1)\n  and   set_lebesgue_integral_ln_powr_at_top:\n          \"(\\<integral>x\\<in>{a<..}. (ln (d * x + b) * ((d * x + b) powr c)) \\<partial>lborel) = C\" (is ?th2)\n  and   ln_powr_has_integral_at_top:\n          \"((\\<lambda>x. ln (d * x + b) * (d * x + b) powr c) has_integral C) {a<..}\" (is ?th3)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x.\n        ln (d * x + b) * (d * x + b) powr c) absolutely_integrable_on\n    {a<..} &&&\n    LBINT x:{a<..}. ln (d * x + b) * (d * x + b) powr c = C &&&\n    ((\\<lambda>x. ln (d * x + b) * (d * x + b) powr c) has_integral C)\n     {a<..}", "proof -"], ["proof (state)\ngoal (3 subgoals):\n 1. (\\<lambda>x.\n        ln (d * x + b) * (d * x + b) powr c) absolutely_integrable_on\n    {a<..}\n 2. LBINT x:{a<..}. ln (d * x + b) * (d * x + b) powr c = C\n 3. ((\\<lambda>x. ln (d * x + b) * (d * x + b) powr c) has_integral C)\n     {a<..}", "define f where \"f = (\\<lambda>x. ln (d * x + b) * (d * x + b) powr c)\""], ["proof (state)\nthis:\n  f = (\\<lambda>x. ln (d * x + b) * (d * x + b) powr c)\n\ngoal (3 subgoals):\n 1. (\\<lambda>x.\n        ln (d * x + b) * (d * x + b) powr c) absolutely_integrable_on\n    {a<..}\n 2. LBINT x:{a<..}. ln (d * x + b) * (d * x + b) powr c = C\n 3. ((\\<lambda>x. ln (d * x + b) * (d * x + b) powr c) has_integral C)\n     {a<..}", "define F where \"F = (\\<lambda>x. (ln (d * x + b) - 1 / (c + 1)) * (d * x + b) powr (c + 1) / (d * (c + 1)))\""], ["proof (state)\nthis:\n  F =\n  (\\<lambda>x.\n      (ln (d * x + b) - 1 / (c + 1)) * (d * x + b) powr (c + 1) /\n      (d * (c + 1)))\n\ngoal (3 subgoals):\n 1. (\\<lambda>x.\n        ln (d * x + b) * (d * x + b) powr c) absolutely_integrable_on\n    {a<..}\n 2. LBINT x:{a<..}. ln (d * x + b) * (d * x + b) powr c = C\n 3. ((\\<lambda>x. ln (d * x + b) * (d * x + b) powr c) has_integral C)\n     {a<..}", "have *: \"(F has_field_derivative f x) (at x)\" \"isCont f x\" \"f x \\<ge> 0\" if \"x > a\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. (F has_real_derivative f x) (at x) &&& isCont f x &&& 0 \\<le> f x", "proof -"], ["proof (state)\ngoal (3 subgoals):\n 1. (F has_real_derivative f x) (at x)\n 2. isCont f x\n 3. 0 \\<le> f x", "have \"1 \\<le> d * a + b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 \\<le> d * a + b", "by fact"], ["proof (state)\nthis:\n  1 \\<le> d * a + b\n\ngoal (3 subgoals):\n 1. (F has_real_derivative f x) (at x)\n 2. isCont f x\n 3. 0 \\<le> f x", "also"], ["proof (state)\nthis:\n  1 \\<le> d * a + b\n\ngoal (3 subgoals):\n 1. (F has_real_derivative f x) (at x)\n 2. isCont f x\n 3. 0 \\<le> f x", "have \"\\<dots> < d * x + b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d * a + b < d * x + b", "using that assms"], ["proof (prove)\nusing this:\n  a < x\n  1 \\<le> d * a + b\n  c < - 1\n  0 < d\n  C \\<equiv>\n  - ((ln (d * a + b) - 1 / (c + 1)) * (d * a + b) powr (c + 1) /\n     (d * (c + 1)))\n\ngoal (1 subgoal):\n 1. d * a + b < d * x + b", "by (intro add_strict_right_mono mult_strict_left_mono)"], ["proof (state)\nthis:\n  d * a + b < d * x + b\n\ngoal (3 subgoals):\n 1. (F has_real_derivative f x) (at x)\n 2. isCont f x\n 3. 0 \\<le> f x", "finally"], ["proof (chain)\npicking this:\n  1 < d * x + b", "have gt_1: \"d * x + b > 1\""], ["proof (prove)\nusing this:\n  1 < d * x + b\n\ngoal (1 subgoal):\n 1. 1 < d * x + b", "."], ["proof (state)\nthis:\n  1 < d * x + b\n\ngoal (3 subgoals):\n 1. (F has_real_derivative f x) (at x)\n 2. isCont f x\n 3. 0 \\<le> f x", "show \"(F has_field_derivative f x) (at x)\" \"isCont f x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (F has_real_derivative f x) (at x) &&& isCont f x", "using ab c d gt_1"], ["proof (prove)\nusing this:\n  1 \\<le> d * a + b\n  c < - 1\n  0 < d\n  1 < d * x + b\n\ngoal (1 subgoal):\n 1. (F has_real_derivative f x) (at x) &&& isCont f x", "by (auto simp: F_def f_def divide_simps intro!: derivative_eq_intros continuous_intros)\n       (auto simp: algebra_simps powr_add)?"], ["proof (state)\nthis:\n  (F has_real_derivative f x) (at x)\n  isCont f x\n\ngoal (1 subgoal):\n 1. 0 \\<le> f x", "show \"f x \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> f x", "using gt_1"], ["proof (prove)\nusing this:\n  1 < d * x + b\n\ngoal (1 subgoal):\n 1. 0 \\<le> f x", "by (auto simp: f_def)"], ["proof (state)\nthis:\n  0 \\<le> f x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  a < ?x \\<Longrightarrow> (F has_real_derivative f ?x) (at ?x)\n  a < ?x \\<Longrightarrow> isCont f ?x\n  a < ?x \\<Longrightarrow> 0 \\<le> f ?x\n\ngoal (3 subgoals):\n 1. (\\<lambda>x.\n        ln (d * x + b) * (d * x + b) powr c) absolutely_integrable_on\n    {a<..}\n 2. LBINT x:{a<..}. ln (d * x + b) * (d * x + b) powr c = C\n 3. ((\\<lambda>x. ln (d * x + b) * (d * x + b) powr c) has_integral C)\n     {a<..}", "have limits: \"((F \\<circ> real_of_ereal) \\<longlongrightarrow> F a) (at_right (ereal a))\"\n               \"((F \\<circ> real_of_ereal) \\<longlongrightarrow> 0) (at_left \\<infinity>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((F \\<circ> real_of_ereal) \\<longlongrightarrow> F a)\n     (at_right (ereal a)) &&&\n    ((F \\<circ> real_of_ereal) \\<longlongrightarrow> 0)\n     (at_left \\<infinity>)", "using c ab d"], ["proof (prove)\nusing this:\n  c < - 1\n  1 \\<le> d * a + b\n  0 < d\n\ngoal (1 subgoal):\n 1. ((F \\<circ> real_of_ereal) \\<longlongrightarrow> F a)\n     (at_right (ereal a)) &&&\n    ((F \\<circ> real_of_ereal) \\<longlongrightarrow> 0)\n     (at_left \\<infinity>)", "unfolding ereal_tendsto_simps1 F_def"], ["proof (prove)\nusing this:\n  c < - 1\n  1 \\<le> d * a + b\n  0 < d\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x.\n         (ln (d * x + b) - 1 / (c + 1)) * (d * x + b) powr (c + 1) /\n         (d * (c + 1))) \\<longlongrightarrow>\n     (ln (d * a + b) - 1 / (c + 1)) * (d * a + b) powr (c + 1) /\n     (d * (c + 1)))\n     (at_right a) &&&\n    ((\\<lambda>x.\n         (ln (d * x + b) - 1 / (c + 1)) * (d * x + b) powr (c + 1) /\n         (d * (c + 1))) \\<longlongrightarrow>\n     0)\n     at_top", "by (real_asymp; simp add: field_simps)+"], ["proof (state)\nthis:\n  ((F \\<circ> real_of_ereal) \\<longlongrightarrow> F a) (at_right (ereal a))\n  ((F \\<circ> real_of_ereal) \\<longlongrightarrow> 0) (at_left \\<infinity>)\n\ngoal (3 subgoals):\n 1. (\\<lambda>x.\n        ln (d * x + b) * (d * x + b) powr c) absolutely_integrable_on\n    {a<..}\n 2. LBINT x:{a<..}. ln (d * x + b) * (d * x + b) powr c = C\n 3. ((\\<lambda>x. ln (d * x + b) * (d * x + b) powr c) has_integral C)\n     {a<..}", "have 1: \"set_integrable lborel (einterval a \\<infinity>) f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_integrable lborel (einterval (ereal a) \\<infinity>) f", "using ab c limits"], ["proof (prove)\nusing this:\n  1 \\<le> d * a + b\n  c < - 1\n  ((F \\<circ> real_of_ereal) \\<longlongrightarrow> F a) (at_right (ereal a))\n  ((F \\<circ> real_of_ereal) \\<longlongrightarrow> 0) (at_left \\<infinity>)\n\ngoal (1 subgoal):\n 1. set_integrable lborel (einterval (ereal a) \\<infinity>) f", "by (intro interval_integral_FTC_nonneg) (auto intro!: * AE_I2)"], ["proof (state)\nthis:\n  set_integrable lborel (einterval (ereal a) \\<infinity>) f\n\ngoal (3 subgoals):\n 1. (\\<lambda>x.\n        ln (d * x + b) * (d * x + b) powr c) absolutely_integrable_on\n    {a<..}\n 2. LBINT x:{a<..}. ln (d * x + b) * (d * x + b) powr c = C\n 3. ((\\<lambda>x. ln (d * x + b) * (d * x + b) powr c) has_integral C)\n     {a<..}", "thus 2: \"f absolutely_integrable_on {a<..}\""], ["proof (prove)\nusing this:\n  set_integrable lborel (einterval (ereal a) \\<infinity>) f\n\ngoal (1 subgoal):\n 1. f absolutely_integrable_on {a<..}", "by (auto simp: set_integrable_def integrable_completion)"], ["proof (state)\nthis:\n  f absolutely_integrable_on {a<..}\n\ngoal (2 subgoals):\n 1. LBINT x:{a<..}. ln (d * x + b) * (d * x + b) powr c = C\n 2. ((\\<lambda>x. ln (d * x + b) * (d * x + b) powr c) has_integral C)\n     {a<..}", "have \"(LBINT x=ereal a..\\<infinity>. f x) = 0 - F a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. interval_lebesgue_integral lborel (ereal a) \\<infinity> f = 0 - F a", "using ab c limits"], ["proof (prove)\nusing this:\n  1 \\<le> d * a + b\n  c < - 1\n  ((F \\<circ> real_of_ereal) \\<longlongrightarrow> F a) (at_right (ereal a))\n  ((F \\<circ> real_of_ereal) \\<longlongrightarrow> 0) (at_left \\<infinity>)\n\ngoal (1 subgoal):\n 1. interval_lebesgue_integral lborel (ereal a) \\<infinity> f = 0 - F a", "by (intro interval_integral_FTC_nonneg) (auto intro!: *)"], ["proof (state)\nthis:\n  interval_lebesgue_integral lborel (ereal a) \\<infinity> f = 0 - F a\n\ngoal (2 subgoals):\n 1. LBINT x:{a<..}. ln (d * x + b) * (d * x + b) powr c = C\n 2. ((\\<lambda>x. ln (d * x + b) * (d * x + b) powr c) has_integral C)\n     {a<..}", "thus 3: ?th2"], ["proof (prove)\nusing this:\n  interval_lebesgue_integral lborel (ereal a) \\<infinity> f = 0 - F a\n\ngoal (1 subgoal):\n 1. LBINT x:{a<..}. ln (d * x + b) * (d * x + b) powr c = C", "by (simp add: interval_integral_to_infinity_eq F_def f_def C_def)"], ["proof (state)\nthis:\n  LBINT x:{a<..}. ln (d * x + b) * (d * x + b) powr c = C\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. ln (d * x + b) * (d * x + b) powr c) has_integral C)\n     {a<..}", "show ?th3"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x. ln (d * x + b) * (d * x + b) powr c) has_integral C)\n     {a<..}", "using set_borel_integral_eq_integral[OF 1] 3"], ["proof (prove)\nusing this:\n  f integrable_on einterval (ereal a) \\<infinity>\n  set_lebesgue_integral lborel (einterval (ereal a) \\<infinity>) f =\n  integral (einterval (ereal a) \\<infinity>) f\n  LBINT x:{a<..}. ln (d * x + b) * (d * x + b) powr c = C\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. ln (d * x + b) * (d * x + b) powr c) has_integral C)\n     {a<..}", "by (simp add: has_integral_iff f_def C_def)"], ["proof (state)\nthis:\n  ((\\<lambda>x. ln (d * x + b) * (d * x + b) powr c) has_integral C) {a<..}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ln_fact_conv_sum_upto: \"ln (fact n) = sum_upto ln n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ln (fact n) = sum_upto (\\<lambda>x. ln (real x)) (real n)", "by (induction n) (auto simp: sum_upto_plus1 add.commute[of 1] ln_mult)"], ["", "lemma sum_upto_ln_conv_ln_fact: \"sum_upto ln x = ln (fact (nat \\<lfloor>x\\<rfloor>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_upto (\\<lambda>x. ln (real x)) x =\n    ln (fact (nat \\<lfloor>x\\<rfloor>))", "by (simp add: ln_fact_conv_sum_upto sum_upto_altdef)"], ["", "lemma real_of_nat_div: \"real (a div b) = real_of_int \\<lfloor>real a / real b\\<rfloor>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real (a div b) = real_of_int \\<lfloor>real a / real b\\<rfloor>", "by (subst floor_divide_of_nat_eq) auto"], ["", "lemma integral_subset_negligible:\n  fixes f :: \"'a :: euclidean_space \\<Rightarrow> 'b :: banach\"\n  assumes \"S \\<subseteq> T\" \"negligible (T - S)\"\n  shows   \"integral S f = integral T f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. integral S f = integral T f", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. integral S f = integral T f", "have \"integral T f = integral T (\\<lambda>x. if x \\<in> S then f x else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. integral T f =\n    integral T (\\<lambda>x. if x \\<in> S then f x else (0::'b))", "by (rule integral_spike[of \"T - S\"]) (use assms in auto)"], ["proof (state)\nthis:\n  integral T f = integral T (\\<lambda>x. if x \\<in> S then f x else (0::'b))\n\ngoal (1 subgoal):\n 1. integral S f = integral T f", "also"], ["proof (state)\nthis:\n  integral T f = integral T (\\<lambda>x. if x \\<in> S then f x else (0::'b))\n\ngoal (1 subgoal):\n 1. integral S f = integral T f", "have \"\\<dots> = integral (S \\<inter> T) f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. integral T (\\<lambda>x. if x \\<in> S then f x else (0::'b)) =\n    integral (S \\<inter> T) f", "by (subst integral_restrict_Int) auto"], ["proof (state)\nthis:\n  integral T (\\<lambda>x. if x \\<in> S then f x else (0::'b)) =\n  integral (S \\<inter> T) f\n\ngoal (1 subgoal):\n 1. integral S f = integral T f", "also"], ["proof (state)\nthis:\n  integral T (\\<lambda>x. if x \\<in> S then f x else (0::'b)) =\n  integral (S \\<inter> T) f\n\ngoal (1 subgoal):\n 1. integral S f = integral T f", "have \"S \\<inter> T = S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S \\<inter> T = S", "using assms"], ["proof (prove)\nusing this:\n  S \\<subseteq> T\n  negligible (T - S)\n\ngoal (1 subgoal):\n 1. S \\<inter> T = S", "by auto"], ["proof (state)\nthis:\n  S \\<inter> T = S\n\ngoal (1 subgoal):\n 1. integral S f = integral T f", "finally"], ["proof (chain)\npicking this:\n  integral T f = integral S f", "show ?thesis"], ["proof (prove)\nusing this:\n  integral T f = integral S f\n\ngoal (1 subgoal):\n 1. integral S f = integral T f", ".."], ["proof (state)\nthis:\n  integral S f = integral T f\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma integrable_on_cong [cong]:\n  assumes \"\\<And>x. x \\<in> A \\<Longrightarrow> f x = g x\" \"A = B\"\n  shows   \"f integrable_on A \\<longleftrightarrow> g integrable_on B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f integrable_on A) = (g integrable_on B)", "using has_integral_cong[of A f g, OF assms(1)] assms(2)"], ["proof (prove)\nusing this:\n  (\\<And>x. x \\<in> A \\<Longrightarrow> x \\<in> A) \\<Longrightarrow>\n  (f has_integral ?i) A = (g has_integral ?i) A\n  A = B\n\ngoal (1 subgoal):\n 1. (f integrable_on A) = (g integrable_on B)", "by (auto simp: integrable_on_def)"], ["", "lemma measurable_sum_upto [measurable]:\n  fixes f :: \"'a \\<Rightarrow> nat \\<Rightarrow> real\"\n  assumes [measurable]: \"\\<And>y. (\\<lambda>t. f t y) \\<in> M \\<rightarrow>\\<^sub>M borel\"\n  assumes [measurable]: \"x \\<in> M \\<rightarrow>\\<^sub>M borel\"\n  shows \"(\\<lambda>t. sum_upto (f t) (x t)) \\<in> M \\<rightarrow>\\<^sub>M borel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>t. sum_upto (f t) (x t)) \\<in> borel_measurable M", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<lambda>t. sum_upto (f t) (x t)) \\<in> borel_measurable M", "have meas: \"(\\<lambda>t. set_lebesgue_integral lborel {y. y \\<ge> 0 \\<and> y - real (nat \\<lfloor>x t\\<rfloor>) \\<le> 0} (\\<lambda>y. f t (nat \\<lceil>y\\<rceil>)))\n          \\<in> M \\<rightarrow>\\<^sub>M borel\" (is \"?f \\<in> _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>t.\n        LBINT y:{y. 0 \\<le> y \\<and>\n                    y - real (nat \\<lfloor>x t\\<rfloor>) \\<le> 0}.\n           f t (nat \\<lceil>y\\<rceil>))\n    \\<in> borel_measurable M", "unfolding set_lebesgue_integral_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>t.\n        LBINT xa.\n          indicat_real\n           {y. 0 \\<le> y \\<and>\n               y - real (nat \\<lfloor>x t\\<rfloor>) \\<le> 0}\n           xa *\\<^sub>R\n          f t (nat \\<lceil>xa\\<rceil>))\n    \\<in> borel_measurable M", "by measurable"], ["proof (state)\nthis:\n  (\\<lambda>t.\n      LBINT y:{y. 0 \\<le> y \\<and>\n                  y - real (nat \\<lfloor>x t\\<rfloor>) \\<le> 0}.\n         f t (nat \\<lceil>y\\<rceil>))\n  \\<in> borel_measurable M\n\ngoal (1 subgoal):\n 1. (\\<lambda>t. sum_upto (f t) (x t)) \\<in> borel_measurable M", "also"], ["proof (state)\nthis:\n  (\\<lambda>t.\n      LBINT y:{y. 0 \\<le> y \\<and>\n                  y - real (nat \\<lfloor>x t\\<rfloor>) \\<le> 0}.\n         f t (nat \\<lceil>y\\<rceil>))\n  \\<in> borel_measurable M\n\ngoal (1 subgoal):\n 1. (\\<lambda>t. sum_upto (f t) (x t)) \\<in> borel_measurable M", "have \"?f = (\\<lambda>t. sum_upto (f t) (x t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>t.\n        LBINT y:{y. 0 \\<le> y \\<and>\n                    y - real (nat \\<lfloor>x t\\<rfloor>) \\<le> 0}.\n           f t (nat \\<lceil>y\\<rceil>)) =\n    (\\<lambda>t. sum_upto (f t) (x t))", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t.\n       LBINT y:{y. 0 \\<le> y \\<and>\n                   y - real (nat \\<lfloor>x t\\<rfloor>) \\<le> 0}.\n          f t (nat \\<lceil>y\\<rceil>) =\n       sum_upto (f t) (x t)", "fix t :: 'a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t.\n       LBINT y:{y. 0 \\<le> y \\<and>\n                   y - real (nat \\<lfloor>x t\\<rfloor>) \\<le> 0}.\n          f t (nat \\<lceil>y\\<rceil>) =\n       sum_upto (f t) (x t)", "show \"?f t = sum_upto (f t) (x t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LBINT y:{y. 0 \\<le> y \\<and>\n                y - real (nat \\<lfloor>x t\\<rfloor>) \\<le> 0}.\n       f t (nat \\<lceil>y\\<rceil>) =\n    sum_upto (f t) (x t)", "proof (cases \"x t < 1\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x t < 1 \\<Longrightarrow>\n    LBINT y:{y. 0 \\<le> y \\<and>\n                y - real (nat \\<lfloor>x t\\<rfloor>) \\<le> 0}.\n       f t (nat \\<lceil>y\\<rceil>) =\n    sum_upto (f t) (x t)\n 2. \\<not> x t < 1 \\<Longrightarrow>\n    LBINT y:{y. 0 \\<le> y \\<and>\n                y - real (nat \\<lfloor>x t\\<rfloor>) \\<le> 0}.\n       f t (nat \\<lceil>y\\<rceil>) =\n    sum_upto (f t) (x t)", "case True"], ["proof (state)\nthis:\n  x t < 1\n\ngoal (2 subgoals):\n 1. x t < 1 \\<Longrightarrow>\n    LBINT y:{y. 0 \\<le> y \\<and>\n                y - real (nat \\<lfloor>x t\\<rfloor>) \\<le> 0}.\n       f t (nat \\<lceil>y\\<rceil>) =\n    sum_upto (f t) (x t)\n 2. \\<not> x t < 1 \\<Longrightarrow>\n    LBINT y:{y. 0 \\<le> y \\<and>\n                y - real (nat \\<lfloor>x t\\<rfloor>) \\<le> 0}.\n       f t (nat \\<lceil>y\\<rceil>) =\n    sum_upto (f t) (x t)", "hence \"{y. y \\<ge> 0 \\<and> y - real (nat \\<lfloor>x t\\<rfloor>) \\<le> 0} = {0}\""], ["proof (prove)\nusing this:\n  x t < 1\n\ngoal (1 subgoal):\n 1. {y. 0 \\<le> y \\<and> y - real (nat \\<lfloor>x t\\<rfloor>) \\<le> 0} = {0}", "by auto"], ["proof (state)\nthis:\n  {y. 0 \\<le> y \\<and> y - real (nat \\<lfloor>x t\\<rfloor>) \\<le> 0} = {0}\n\ngoal (2 subgoals):\n 1. x t < 1 \\<Longrightarrow>\n    LBINT y:{y. 0 \\<le> y \\<and>\n                y - real (nat \\<lfloor>x t\\<rfloor>) \\<le> 0}.\n       f t (nat \\<lceil>y\\<rceil>) =\n    sum_upto (f t) (x t)\n 2. \\<not> x t < 1 \\<Longrightarrow>\n    LBINT y:{y. 0 \\<le> y \\<and>\n                y - real (nat \\<lfloor>x t\\<rfloor>) \\<le> 0}.\n       f t (nat \\<lceil>y\\<rceil>) =\n    sum_upto (f t) (x t)", "thus ?thesis"], ["proof (prove)\nusing this:\n  {y. 0 \\<le> y \\<and> y - real (nat \\<lfloor>x t\\<rfloor>) \\<le> 0} = {0}\n\ngoal (1 subgoal):\n 1. LBINT y:{y. 0 \\<le> y \\<and>\n                y - real (nat \\<lfloor>x t\\<rfloor>) \\<le> 0}.\n       f t (nat \\<lceil>y\\<rceil>) =\n    sum_upto (f t) (x t)", "using True"], ["proof (prove)\nusing this:\n  {y. 0 \\<le> y \\<and> y - real (nat \\<lfloor>x t\\<rfloor>) \\<le> 0} = {0}\n  x t < 1\n\ngoal (1 subgoal):\n 1. LBINT y:{y. 0 \\<le> y \\<and>\n                y - real (nat \\<lfloor>x t\\<rfloor>) \\<le> 0}.\n       f t (nat \\<lceil>y\\<rceil>) =\n    sum_upto (f t) (x t)", "by (simp add: set_integral_at_point sum_upto_altdef)"], ["proof (state)\nthis:\n  LBINT y:{y. 0 \\<le> y \\<and>\n              y - real (nat \\<lfloor>x t\\<rfloor>) \\<le> 0}.\n     f t (nat \\<lceil>y\\<rceil>) =\n  sum_upto (f t) (x t)\n\ngoal (1 subgoal):\n 1. \\<not> x t < 1 \\<Longrightarrow>\n    LBINT y:{y. 0 \\<le> y \\<and>\n                y - real (nat \\<lfloor>x t\\<rfloor>) \\<le> 0}.\n       f t (nat \\<lceil>y\\<rceil>) =\n    sum_upto (f t) (x t)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> x t < 1 \\<Longrightarrow>\n    LBINT y:{y. 0 \\<le> y \\<and>\n                y - real (nat \\<lfloor>x t\\<rfloor>) \\<le> 0}.\n       f t (nat \\<lceil>y\\<rceil>) =\n    sum_upto (f t) (x t)", "case False"], ["proof (state)\nthis:\n  \\<not> x t < 1\n\ngoal (1 subgoal):\n 1. \\<not> x t < 1 \\<Longrightarrow>\n    LBINT y:{y. 0 \\<le> y \\<and>\n                y - real (nat \\<lfloor>x t\\<rfloor>) \\<le> 0}.\n       f t (nat \\<lceil>y\\<rceil>) =\n    sum_upto (f t) (x t)", "define n where \"n = nat \\<lfloor>x t\\<rfloor>\""], ["proof (state)\nthis:\n  n = nat \\<lfloor>x t\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<not> x t < 1 \\<Longrightarrow>\n    LBINT y:{y. 0 \\<le> y \\<and>\n                y - real (nat \\<lfloor>x t\\<rfloor>) \\<le> 0}.\n       f t (nat \\<lceil>y\\<rceil>) =\n    sum_upto (f t) (x t)", "from False"], ["proof (chain)\npicking this:\n  \\<not> x t < 1", "have \"n > 0\""], ["proof (prove)\nusing this:\n  \\<not> x t < 1\n\ngoal (1 subgoal):\n 1. 0 < n", "by (auto simp: n_def)"], ["proof (state)\nthis:\n  0 < n\n\ngoal (1 subgoal):\n 1. \\<not> x t < 1 \\<Longrightarrow>\n    LBINT y:{y. 0 \\<le> y \\<and>\n                y - real (nat \\<lfloor>x t\\<rfloor>) \\<le> 0}.\n       f t (nat \\<lceil>y\\<rceil>) =\n    sum_upto (f t) (x t)", "have *: \"((\\<lambda>x. f t (nat \\<lceil>x\\<rceil>)) has_integral sum (f t) {0<..n}) {real 0..real n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x. f t (nat \\<lceil>x\\<rceil>)) has_integral\n     sum (f t) {0<..n})\n     {real 0..real n}", "using \\<open>n > 0\\<close>"], ["proof (prove)\nusing this:\n  0 < n\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. f t (nat \\<lceil>x\\<rceil>)) has_integral\n     sum (f t) {0<..n})\n     {real 0..real n}", "by (intro nat_sum_has_integral_ceiling) auto"], ["proof (state)\nthis:\n  ((\\<lambda>x. f t (nat \\<lceil>x\\<rceil>)) has_integral sum (f t) {0<..n})\n   {real 0..real n}\n\ngoal (1 subgoal):\n 1. \\<not> x t < 1 \\<Longrightarrow>\n    LBINT y:{y. 0 \\<le> y \\<and>\n                y - real (nat \\<lfloor>x t\\<rfloor>) \\<le> 0}.\n       f t (nat \\<lceil>y\\<rceil>) =\n    sum_upto (f t) (x t)", "have **: \"(\\<lambda>x. f t (nat \\<lceil>x\\<rceil>)) absolutely_integrable_on {real 0..real n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. f t (nat \\<lceil>x\\<rceil>)) absolutely_integrable_on\n    {real 0..real n}", "proof (rule absolutely_integrable_absolutely_integrable_ubound)"], ["proof (state)\ngoal (3 subgoals):\n 1. (\\<lambda>x. f t (nat \\<lceil>x\\<rceil>)) integrable_on {real 0..real n}\n 2. ?g absolutely_integrable_on {real 0..real n}\n 3. \\<And>x.\n       x \\<in> {real 0..real n} \\<Longrightarrow>\n       f t (nat \\<lceil>x\\<rceil>) \\<le> ?g x", "show \"(\\<lambda>_. MAX n\\<in>{0..n}. \\<bar>f t n\\<bar>) absolutely_integrable_on {real 0..real n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>_.\n        MAX n\\<in>{0..n}. \\<bar>f t n\\<bar>) absolutely_integrable_on\n    {real 0..real n}", "using \\<open>n > 0\\<close>"], ["proof (prove)\nusing this:\n  0 < n\n\ngoal (1 subgoal):\n 1. (\\<lambda>_.\n        MAX n\\<in>{0..n}. \\<bar>f t n\\<bar>) absolutely_integrable_on\n    {real 0..real n}", "by (subst absolutely_integrable_on_iff_nonneg)\n                           (auto simp: Max_ge_iff intro!: exI[of _ \"f t 0\"])"], ["proof (state)\nthis:\n  (\\<lambda>_. MAX n\\<in>{0..n}. \\<bar>f t n\\<bar>) absolutely_integrable_on\n  {real 0..real n}\n\ngoal (2 subgoals):\n 1. (\\<lambda>x. f t (nat \\<lceil>x\\<rceil>)) integrable_on {real 0..real n}\n 2. \\<And>x.\n       x \\<in> {real 0..real n} \\<Longrightarrow>\n       f t (nat \\<lceil>x\\<rceil>)\n       \\<le> (MAX n\\<in>{0..n}. \\<bar>f t n\\<bar>)", "show \"(\\<lambda>x. f t (nat \\<lceil>x\\<rceil>)) integrable_on {real 0..real n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. f t (nat \\<lceil>x\\<rceil>)) integrable_on {real 0..real n}", "using *"], ["proof (prove)\nusing this:\n  ((\\<lambda>x. f t (nat \\<lceil>x\\<rceil>)) has_integral sum (f t) {0<..n})\n   {real 0..real n}\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. f t (nat \\<lceil>x\\<rceil>)) integrable_on {real 0..real n}", "by (simp add: has_integral_iff)"], ["proof (state)\nthis:\n  (\\<lambda>x. f t (nat \\<lceil>x\\<rceil>)) integrable_on {real 0..real n}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {real 0..real n} \\<Longrightarrow>\n       f t (nat \\<lceil>x\\<rceil>)\n       \\<le> (MAX n\\<in>{0..n}. \\<bar>f t n\\<bar>)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {real 0..real n} \\<Longrightarrow>\n       f t (nat \\<lceil>x\\<rceil>)\n       \\<le> (MAX n\\<in>{0..n}. \\<bar>f t n\\<bar>)", "fix y :: real"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {real 0..real n} \\<Longrightarrow>\n       f t (nat \\<lceil>x\\<rceil>)\n       \\<le> (MAX n\\<in>{0..n}. \\<bar>f t n\\<bar>)", "assume y: \"y \\<in> {real 0..real n}\""], ["proof (state)\nthis:\n  y \\<in> {real 0..real n}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {real 0..real n} \\<Longrightarrow>\n       f t (nat \\<lceil>x\\<rceil>)\n       \\<le> (MAX n\\<in>{0..n}. \\<bar>f t n\\<bar>)", "have \"f t (nat \\<lceil>y\\<rceil>) \\<le> \\<bar>f t (nat \\<lceil>y\\<rceil>)\\<bar>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f t (nat \\<lceil>y\\<rceil>)\n    \\<le> \\<bar>f t (nat \\<lceil>y\\<rceil>)\\<bar>", "by simp"], ["proof (state)\nthis:\n  f t (nat \\<lceil>y\\<rceil>) \\<le> \\<bar>f t (nat \\<lceil>y\\<rceil>)\\<bar>\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {real 0..real n} \\<Longrightarrow>\n       f t (nat \\<lceil>x\\<rceil>)\n       \\<le> (MAX n\\<in>{0..n}. \\<bar>f t n\\<bar>)", "also"], ["proof (state)\nthis:\n  f t (nat \\<lceil>y\\<rceil>) \\<le> \\<bar>f t (nat \\<lceil>y\\<rceil>)\\<bar>\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {real 0..real n} \\<Longrightarrow>\n       f t (nat \\<lceil>x\\<rceil>)\n       \\<le> (MAX n\\<in>{0..n}. \\<bar>f t n\\<bar>)", "have \"\\<dots> \\<le> (MAX n\\<in>{0..n}. \\<bar>f t n\\<bar>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>f t (nat \\<lceil>y\\<rceil>)\\<bar>\n    \\<le> (MAX n\\<in>{0..n}. \\<bar>f t n\\<bar>)", "using y"], ["proof (prove)\nusing this:\n  y \\<in> {real 0..real n}\n\ngoal (1 subgoal):\n 1. \\<bar>f t (nat \\<lceil>y\\<rceil>)\\<bar>\n    \\<le> (MAX n\\<in>{0..n}. \\<bar>f t n\\<bar>)", "by (intro Max.coboundedI) auto"], ["proof (state)\nthis:\n  \\<bar>f t (nat \\<lceil>y\\<rceil>)\\<bar>\n  \\<le> (MAX n\\<in>{0..n}. \\<bar>f t n\\<bar>)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {real 0..real n} \\<Longrightarrow>\n       f t (nat \\<lceil>x\\<rceil>)\n       \\<le> (MAX n\\<in>{0..n}. \\<bar>f t n\\<bar>)", "finally"], ["proof (chain)\npicking this:\n  f t (nat \\<lceil>y\\<rceil>) \\<le> (MAX n\\<in>{0..n}. \\<bar>f t n\\<bar>)", "show \"f t (nat \\<lceil>y\\<rceil>) \\<le> (MAX n\\<in>{0..n}. \\<bar>f t n\\<bar>)\""], ["proof (prove)\nusing this:\n  f t (nat \\<lceil>y\\<rceil>) \\<le> (MAX n\\<in>{0..n}. \\<bar>f t n\\<bar>)\n\ngoal (1 subgoal):\n 1. f t (nat \\<lceil>y\\<rceil>) \\<le> (MAX n\\<in>{0..n}. \\<bar>f t n\\<bar>)", "."], ["proof (state)\nthis:\n  f t (nat \\<lceil>y\\<rceil>) \\<le> (MAX n\\<in>{0..n}. \\<bar>f t n\\<bar>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<lambda>x. f t (nat \\<lceil>x\\<rceil>)) absolutely_integrable_on\n  {real 0..real n}\n\ngoal (1 subgoal):\n 1. \\<not> x t < 1 \\<Longrightarrow>\n    LBINT y:{y. 0 \\<le> y \\<and>\n                y - real (nat \\<lfloor>x t\\<rfloor>) \\<le> 0}.\n       f t (nat \\<lceil>y\\<rceil>) =\n    sum_upto (f t) (x t)", "have \"sum (f t) {0<..n} = (\\<integral>x\\<in>{real 0..real n}. f t (nat \\<lceil>x\\<rceil>) \\<partial>lebesgue)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum (f t) {0<..n} =\n    \\<integral>x\\<in>{real 0..real n}. f t (nat \\<lceil>x\\<rceil>)\n    \\<partial>lebesgue", "using has_integral_set_lebesgue[OF **] *"], ["proof (prove)\nusing this:\n  ((\\<lambda>x. f t (nat \\<lceil>x\\<rceil>)) has_integral\n   \\<integral>x\\<in>{real 0..real n}. f t (nat \\<lceil>x\\<rceil>)\n   \\<partial>lebesgue)\n   {real 0..real n}\n  ((\\<lambda>x. f t (nat \\<lceil>x\\<rceil>)) has_integral sum (f t) {0<..n})\n   {real 0..real n}\n\ngoal (1 subgoal):\n 1. sum (f t) {0<..n} =\n    \\<integral>x\\<in>{real 0..real n}. f t (nat \\<lceil>x\\<rceil>)\n    \\<partial>lebesgue", "by (simp add: has_integral_iff)"], ["proof (state)\nthis:\n  sum (f t) {0<..n} =\n  \\<integral>x\\<in>{real 0..real n}. f t (nat \\<lceil>x\\<rceil>)\n  \\<partial>lebesgue\n\ngoal (1 subgoal):\n 1. \\<not> x t < 1 \\<Longrightarrow>\n    LBINT y:{y. 0 \\<le> y \\<and>\n                y - real (nat \\<lfloor>x t\\<rfloor>) \\<le> 0}.\n       f t (nat \\<lceil>y\\<rceil>) =\n    sum_upto (f t) (x t)", "also"], ["proof (state)\nthis:\n  sum (f t) {0<..n} =\n  \\<integral>x\\<in>{real 0..real n}. f t (nat \\<lceil>x\\<rceil>)\n  \\<partial>lebesgue\n\ngoal (1 subgoal):\n 1. \\<not> x t < 1 \\<Longrightarrow>\n    LBINT y:{y. 0 \\<le> y \\<and>\n                y - real (nat \\<lfloor>x t\\<rfloor>) \\<le> 0}.\n       f t (nat \\<lceil>y\\<rceil>) =\n    sum_upto (f t) (x t)", "have \"\\<dots> = (\\<integral>x\\<in>{real 0..real n}. f t (nat \\<lceil>x\\<rceil>) \\<partial>lborel)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>x\\<in>{real 0..real n}. f t (nat \\<lceil>x\\<rceil>)\n    \\<partial>lebesgue =\n    LBINT x:{real 0..real n}. f t (nat \\<lceil>x\\<rceil>)", "unfolding set_lebesgue_integral_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. LINT x|lebesgue.\n       indicat_real {real 0..real n} x *\\<^sub>R\n       f t (nat \\<lceil>x\\<rceil>) =\n    LBINT x.\n      indicat_real {real 0..real n} x *\\<^sub>R f t (nat \\<lceil>x\\<rceil>)", "by (subst integral_completion) auto"], ["proof (state)\nthis:\n  \\<integral>x\\<in>{real 0..real n}. f t (nat \\<lceil>x\\<rceil>)\n  \\<partial>lebesgue =\n  LBINT x:{real 0..real n}. f t (nat \\<lceil>x\\<rceil>)\n\ngoal (1 subgoal):\n 1. \\<not> x t < 1 \\<Longrightarrow>\n    LBINT y:{y. 0 \\<le> y \\<and>\n                y - real (nat \\<lfloor>x t\\<rfloor>) \\<le> 0}.\n       f t (nat \\<lceil>y\\<rceil>) =\n    sum_upto (f t) (x t)", "also"], ["proof (state)\nthis:\n  \\<integral>x\\<in>{real 0..real n}. f t (nat \\<lceil>x\\<rceil>)\n  \\<partial>lebesgue =\n  LBINT x:{real 0..real n}. f t (nat \\<lceil>x\\<rceil>)\n\ngoal (1 subgoal):\n 1. \\<not> x t < 1 \\<Longrightarrow>\n    LBINT y:{y. 0 \\<le> y \\<and>\n                y - real (nat \\<lfloor>x t\\<rfloor>) \\<le> 0}.\n       f t (nat \\<lceil>y\\<rceil>) =\n    sum_upto (f t) (x t)", "have \"{real 0..real n} = {y. 0 \\<le> y \\<and> y - real (nat \\<lfloor>x t\\<rfloor>) \\<le> 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {real 0..real n} =\n    {y. 0 \\<le> y \\<and> y - real (nat \\<lfloor>x t\\<rfloor>) \\<le> 0}", "by (auto simp: n_def)"], ["proof (state)\nthis:\n  {real 0..real n} =\n  {y. 0 \\<le> y \\<and> y - real (nat \\<lfloor>x t\\<rfloor>) \\<le> 0}\n\ngoal (1 subgoal):\n 1. \\<not> x t < 1 \\<Longrightarrow>\n    LBINT y:{y. 0 \\<le> y \\<and>\n                y - real (nat \\<lfloor>x t\\<rfloor>) \\<le> 0}.\n       f t (nat \\<lceil>y\\<rceil>) =\n    sum_upto (f t) (x t)", "also"], ["proof (state)\nthis:\n  {real 0..real n} =\n  {y. 0 \\<le> y \\<and> y - real (nat \\<lfloor>x t\\<rfloor>) \\<le> 0}\n\ngoal (1 subgoal):\n 1. \\<not> x t < 1 \\<Longrightarrow>\n    LBINT y:{y. 0 \\<le> y \\<and>\n                y - real (nat \\<lfloor>x t\\<rfloor>) \\<le> 0}.\n       f t (nat \\<lceil>y\\<rceil>) =\n    sum_upto (f t) (x t)", "have \"sum (f t) {0<..n} = sum_upto (f t) (x t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum (f t) {0<..n} = sum_upto (f t) (x t)", "by (simp add: sum_upto_altdef n_def)"], ["proof (state)\nthis:\n  sum (f t) {0<..n} = sum_upto (f t) (x t)\n\ngoal (1 subgoal):\n 1. \\<not> x t < 1 \\<Longrightarrow>\n    LBINT y:{y. 0 \\<le> y \\<and>\n                y - real (nat \\<lfloor>x t\\<rfloor>) \\<le> 0}.\n       f t (nat \\<lceil>y\\<rceil>) =\n    sum_upto (f t) (x t)", "finally"], ["proof (chain)\npicking this:\n  sum_upto (f t) (x t) =\n  LBINT x:{y. 0 \\<le> y \\<and>\n              y - real (nat \\<lfloor>x t\\<rfloor>) \\<le> 0}.\n     f t (nat \\<lceil>x\\<rceil>)", "show ?thesis"], ["proof (prove)\nusing this:\n  sum_upto (f t) (x t) =\n  LBINT x:{y. 0 \\<le> y \\<and>\n              y - real (nat \\<lfloor>x t\\<rfloor>) \\<le> 0}.\n     f t (nat \\<lceil>x\\<rceil>)\n\ngoal (1 subgoal):\n 1. LBINT y:{y. 0 \\<le> y \\<and>\n                y - real (nat \\<lfloor>x t\\<rfloor>) \\<le> 0}.\n       f t (nat \\<lceil>y\\<rceil>) =\n    sum_upto (f t) (x t)", ".."], ["proof (state)\nthis:\n  LBINT y:{y. 0 \\<le> y \\<and>\n              y - real (nat \\<lfloor>x t\\<rfloor>) \\<le> 0}.\n     f t (nat \\<lceil>y\\<rceil>) =\n  sum_upto (f t) (x t)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  LBINT y:{y. 0 \\<le> y \\<and>\n              y - real (nat \\<lfloor>x t\\<rfloor>) \\<le> 0}.\n     f t (nat \\<lceil>y\\<rceil>) =\n  sum_upto (f t) (x t)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<lambda>t.\n      LBINT y:{y. 0 \\<le> y \\<and>\n                  y - real (nat \\<lfloor>x t\\<rfloor>) \\<le> 0}.\n         f t (nat \\<lceil>y\\<rceil>)) =\n  (\\<lambda>t. sum_upto (f t) (x t))\n\ngoal (1 subgoal):\n 1. (\\<lambda>t. sum_upto (f t) (x t)) \\<in> borel_measurable M", "finally"], ["proof (chain)\npicking this:\n  (\\<lambda>t. sum_upto (f t) (x t)) \\<in> borel_measurable M", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<lambda>t. sum_upto (f t) (x t)) \\<in> borel_measurable M\n\ngoal (1 subgoal):\n 1. (\\<lambda>t. sum_upto (f t) (x t)) \\<in> borel_measurable M", "."], ["proof (state)\nthis:\n  (\\<lambda>t. sum_upto (f t) (x t)) \\<in> borel_measurable M\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}