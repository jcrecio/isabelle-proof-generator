{"file_name": "/home/qj213/afp-2021-10-22/thys/Prime_Number_Theorem/Newman_Ingham_Tauberian.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Prime_Number_Theorem", "problem_names": ["lemma newman_ingham_aux1:\n  fixes R :: real and z :: complex\n  assumes R: \"R > 0\" and z : \"norm z = R\"\n  shows   \"norm (1 / z + z / R\\<^sup>2) = 2 * \\<bar>Re z\\<bar> / R\\<^sup>2\"", "lemma newman_ingham_aux2:\n  fixes m :: nat and w z :: complex\n  assumes \"1 \\<le> m\" \"1 \\<le> Re w\" \"0 < Re z\" and f: \"\\<And>n. 1 \\<le> n \\<Longrightarrow> norm (f n) \\<le> C\"\n  shows \"norm (\\<Sum>n=1..m. f n / n powr (w - z)) \\<le> C * (m powr Re z) * (1 / m + 1 / Re z)\"", "lemma hurwitz_zeta_real_bound_aux:\n  fixes a x :: real\n  assumes ax: \"a > 0\" \"x > 1\"\n  shows \"(\\<Sum>i. (a + real (Suc i)) powr (-x)) \\<le> a powr (1 - x) / (x - 1)\"", "lemma analytic_on_axis_extend:\n  fixes y1 y2 x :: real\n  defines \"S \\<equiv> {z. Re z = x \\<and> Im z \\<in> {y1..y2}}\"\n  assumes \"y1 \\<le> y2\"\n  assumes \"f analytic_on S\"\n  obtains x1 x2 :: real where \"x1 < x\" \"x2 > x\" \"f analytic_on cbox (Complex x1 y1) (Complex x2 y2)\"", "lemma Newman_Ingham_1:\n  fixes F :: \"complex fds\" and f :: \"complex \\<Rightarrow> complex\"\n  assumes coeff_bound:   \"fds_nth F \\<in> O(\\<lambda>_. 1)\"\n  assumes f_analytic:    \"f analytic_on {s. Re s \\<ge> 1}\"\n  assumes F_conv_f:      \"\\<And>s. Re s > 1 \\<Longrightarrow> eval_fds F s = f s\"\n  assumes w:             \"Re w \\<ge> 1\"\n  shows   \"fds_converges F w\" and \"eval_fds F w = f w\"", "theorem Newman_Ingham:\n  fixes F :: \"complex fds\" and f :: \"complex \\<Rightarrow> complex\"\n  assumes coeff_bound:   \"fds_nth F \\<in> O(\\<lambda>n. n powr of_real (\\<sigma> - 1))\"\n  assumes f_analytic:    \"f analytic_on {s. Re s \\<ge> \\<sigma>}\"\n  assumes F_conv_f:      \"\\<And>s. Re s > \\<sigma> \\<Longrightarrow> eval_fds F s = f s\"\n  assumes w:             \"Re w \\<ge> \\<sigma>\"\n  shows   \"fds_converges F w\" and \"eval_fds F w = f w\""], "translations": [["", "lemma newman_ingham_aux1:\n  fixes R :: real and z :: complex\n  assumes R: \"R > 0\" and z : \"norm z = R\"\n  shows   \"norm (1 / z + z / R\\<^sup>2) = 2 * \\<bar>Re z\\<bar> / R\\<^sup>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod (1 / z + z / complex_of_real (R\\<^sup>2)) =\n    2 * \\<bar>Re z\\<bar> / R\\<^sup>2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cmod (1 / z + z / complex_of_real (R\\<^sup>2)) =\n    2 * \\<bar>Re z\\<bar> / R\\<^sup>2", "from z and R"], ["proof (chain)\npicking this:\n  cmod z = R\n  0 < R", "have [simp]: \"z \\<noteq> 0\""], ["proof (prove)\nusing this:\n  cmod z = R\n  0 < R\n\ngoal (1 subgoal):\n 1. z \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  z \\<noteq> 0\n\ngoal (1 subgoal):\n 1. cmod (1 / z + z / complex_of_real (R\\<^sup>2)) =\n    2 * \\<bar>Re z\\<bar> / R\\<^sup>2", "have \"1 / z + z / R\\<^sup>2 = (R\\<^sup>2 + z\\<^sup>2) * (1 / R\\<^sup>2 / z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 / z + z / complex_of_real (R\\<^sup>2) =\n    (complex_of_real (R\\<^sup>2) + z\\<^sup>2) *\n    (complex_of_real (1 / R\\<^sup>2) / z)", "using R"], ["proof (prove)\nusing this:\n  0 < R\n\ngoal (1 subgoal):\n 1. 1 / z + z / complex_of_real (R\\<^sup>2) =\n    (complex_of_real (R\\<^sup>2) + z\\<^sup>2) *\n    (complex_of_real (1 / R\\<^sup>2) / z)", "by (simp add: field_simps power2_eq_square)"], ["proof (state)\nthis:\n  1 / z + z / complex_of_real (R\\<^sup>2) =\n  (complex_of_real (R\\<^sup>2) + z\\<^sup>2) *\n  (complex_of_real (1 / R\\<^sup>2) / z)\n\ngoal (1 subgoal):\n 1. cmod (1 / z + z / complex_of_real (R\\<^sup>2)) =\n    2 * \\<bar>Re z\\<bar> / R\\<^sup>2", "also"], ["proof (state)\nthis:\n  1 / z + z / complex_of_real (R\\<^sup>2) =\n  (complex_of_real (R\\<^sup>2) + z\\<^sup>2) *\n  (complex_of_real (1 / R\\<^sup>2) / z)\n\ngoal (1 subgoal):\n 1. cmod (1 / z + z / complex_of_real (R\\<^sup>2)) =\n    2 * \\<bar>Re z\\<bar> / R\\<^sup>2", "have \"norm \\<dots> = norm (R\\<^sup>2 + z\\<^sup>2) / R ^ 3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod\n     ((complex_of_real (R\\<^sup>2) + z\\<^sup>2) *\n      (complex_of_real (1 / R\\<^sup>2) / z)) =\n    cmod (complex_of_real (R\\<^sup>2) + z\\<^sup>2) / R ^ 3", "by (simp add: numeral_3_eq_3 z norm_divide norm_mult power2_eq_square)"], ["proof (state)\nthis:\n  cmod\n   ((complex_of_real (R\\<^sup>2) + z\\<^sup>2) *\n    (complex_of_real (1 / R\\<^sup>2) / z)) =\n  cmod (complex_of_real (R\\<^sup>2) + z\\<^sup>2) / R ^ 3\n\ngoal (1 subgoal):\n 1. cmod (1 / z + z / complex_of_real (R\\<^sup>2)) =\n    2 * \\<bar>Re z\\<bar> / R\\<^sup>2", "also"], ["proof (state)\nthis:\n  cmod\n   ((complex_of_real (R\\<^sup>2) + z\\<^sup>2) *\n    (complex_of_real (1 / R\\<^sup>2) / z)) =\n  cmod (complex_of_real (R\\<^sup>2) + z\\<^sup>2) / R ^ 3\n\ngoal (1 subgoal):\n 1. cmod (1 / z + z / complex_of_real (R\\<^sup>2)) =\n    2 * \\<bar>Re z\\<bar> / R\\<^sup>2", "have \"R\\<^sup>2 + z\\<^sup>2 = z * (z + cnj z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. complex_of_real (R\\<^sup>2) + z\\<^sup>2 = z * (z + cnj z)", "using complex_norm_square[of z]"], ["proof (prove)\nusing this:\n  complex_of_real ((cmod z)\\<^sup>2) = z * cnj z\n\ngoal (1 subgoal):\n 1. complex_of_real (R\\<^sup>2) + z\\<^sup>2 = z * (z + cnj z)", "by (simp add: z power2_eq_square algebra_simps)"], ["proof (state)\nthis:\n  complex_of_real (R\\<^sup>2) + z\\<^sup>2 = z * (z + cnj z)\n\ngoal (1 subgoal):\n 1. cmod (1 / z + z / complex_of_real (R\\<^sup>2)) =\n    2 * \\<bar>Re z\\<bar> / R\\<^sup>2", "also"], ["proof (state)\nthis:\n  complex_of_real (R\\<^sup>2) + z\\<^sup>2 = z * (z + cnj z)\n\ngoal (1 subgoal):\n 1. cmod (1 / z + z / complex_of_real (R\\<^sup>2)) =\n    2 * \\<bar>Re z\\<bar> / R\\<^sup>2", "have \"norm \\<dots> = 2 * \\<bar>Re z\\<bar> * R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod (z * (z + cnj z)) = 2 * \\<bar>Re z\\<bar> * R", "by (subst complex_add_cnj) (simp_all add: z norm_mult)"], ["proof (state)\nthis:\n  cmod (z * (z + cnj z)) = 2 * \\<bar>Re z\\<bar> * R\n\ngoal (1 subgoal):\n 1. cmod (1 / z + z / complex_of_real (R\\<^sup>2)) =\n    2 * \\<bar>Re z\\<bar> / R\\<^sup>2", "also"], ["proof (state)\nthis:\n  cmod (z * (z + cnj z)) = 2 * \\<bar>Re z\\<bar> * R\n\ngoal (1 subgoal):\n 1. cmod (1 / z + z / complex_of_real (R\\<^sup>2)) =\n    2 * \\<bar>Re z\\<bar> / R\\<^sup>2", "have \"\\<dots> / R ^ 3 = 2 * \\<bar>Re z\\<bar> / R\\<^sup>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * \\<bar>Re z\\<bar> * R / R ^ 3 = 2 * \\<bar>Re z\\<bar> / R\\<^sup>2", "using R"], ["proof (prove)\nusing this:\n  0 < R\n\ngoal (1 subgoal):\n 1. 2 * \\<bar>Re z\\<bar> * R / R ^ 3 = 2 * \\<bar>Re z\\<bar> / R\\<^sup>2", "by (simp add: field_simps numeral_3_eq_3 power2_eq_square)"], ["proof (state)\nthis:\n  2 * \\<bar>Re z\\<bar> * R / R ^ 3 = 2 * \\<bar>Re z\\<bar> / R\\<^sup>2\n\ngoal (1 subgoal):\n 1. cmod (1 / z + z / complex_of_real (R\\<^sup>2)) =\n    2 * \\<bar>Re z\\<bar> / R\\<^sup>2", "finally"], ["proof (chain)\npicking this:\n  cmod (1 / z + z / complex_of_real (R\\<^sup>2)) =\n  2 * \\<bar>Re z\\<bar> / R\\<^sup>2", "show ?thesis"], ["proof (prove)\nusing this:\n  cmod (1 / z + z / complex_of_real (R\\<^sup>2)) =\n  2 * \\<bar>Re z\\<bar> / R\\<^sup>2\n\ngoal (1 subgoal):\n 1. cmod (1 / z + z / complex_of_real (R\\<^sup>2)) =\n    2 * \\<bar>Re z\\<bar> / R\\<^sup>2", "."], ["proof (state)\nthis:\n  cmod (1 / z + z / complex_of_real (R\\<^sup>2)) =\n  2 * \\<bar>Re z\\<bar> / R\\<^sup>2\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma newman_ingham_aux2:\n  fixes m :: nat and w z :: complex\n  assumes \"1 \\<le> m\" \"1 \\<le> Re w\" \"0 < Re z\" and f: \"\\<And>n. 1 \\<le> n \\<Longrightarrow> norm (f n) \\<le> C\"\n  shows \"norm (\\<Sum>n=1..m. f n / n powr (w - z)) \\<le> C * (m powr Re z) * (1 / m + 1 / Re z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod (\\<Sum>n = 1..m. f n / of_nat n powr (w - z))\n    \\<le> C * real m powr Re z * (1 / real m + 1 / Re z)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cmod (\\<Sum>n = 1..m. f n / of_nat n powr (w - z))\n    \\<le> C * real m powr Re z * (1 / real m + 1 / Re z)", "have [simp]: \"C \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> C", "by (rule order.trans[OF _ f[of 1]]) auto"], ["proof (state)\nthis:\n  0 \\<le> C\n\ngoal (1 subgoal):\n 1. cmod (\\<Sum>n = 1..m. f n / of_nat n powr (w - z))\n    \\<le> C * real m powr Re z * (1 / real m + 1 / Re z)", "have \"norm (\\<Sum>n=1..m. f n / n powr (w - z)) \\<le> (\\<Sum>n=1..m. C / n powr (1 - Re z))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod (\\<Sum>n = 1..m. f n / of_nat n powr (w - z))\n    \\<le> (\\<Sum>n = 1..m. C / real n powr (1 - Re z))", "by (rule sum_norm_le)\n       (insert assms, auto simp: norm_divide norm_powr_real_powr intro!: frac_le assms powr_mono)"], ["proof (state)\nthis:\n  cmod (\\<Sum>n = 1..m. f n / of_nat n powr (w - z))\n  \\<le> (\\<Sum>n = 1..m. C / real n powr (1 - Re z))\n\ngoal (1 subgoal):\n 1. cmod (\\<Sum>n = 1..m. f n / of_nat n powr (w - z))\n    \\<le> C * real m powr Re z * (1 / real m + 1 / Re z)", "also"], ["proof (state)\nthis:\n  cmod (\\<Sum>n = 1..m. f n / of_nat n powr (w - z))\n  \\<le> (\\<Sum>n = 1..m. C / real n powr (1 - Re z))\n\ngoal (1 subgoal):\n 1. cmod (\\<Sum>n = 1..m. f n / of_nat n powr (w - z))\n    \\<le> C * real m powr Re z * (1 / real m + 1 / Re z)", "have \"\\<dots> = C * (\\<Sum>n=1..m. n powr (Re z - 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>n = 1..m. C / real n powr (1 - Re z)) =\n    C * (\\<Sum>n = 1..m. real n powr (Re z - 1))", "by (subst sum_distrib_left) (simp_all add: powr_diff)"], ["proof (state)\nthis:\n  (\\<Sum>n = 1..m. C / real n powr (1 - Re z)) =\n  C * (\\<Sum>n = 1..m. real n powr (Re z - 1))\n\ngoal (1 subgoal):\n 1. cmod (\\<Sum>n = 1..m. f n / of_nat n powr (w - z))\n    \\<le> C * real m powr Re z * (1 / real m + 1 / Re z)", "also"], ["proof (state)\nthis:\n  (\\<Sum>n = 1..m. C / real n powr (1 - Re z)) =\n  C * (\\<Sum>n = 1..m. real n powr (Re z - 1))\n\ngoal (1 subgoal):\n 1. cmod (\\<Sum>n = 1..m. f n / of_nat n powr (w - z))\n    \\<le> C * real m powr Re z * (1 / real m + 1 / Re z)", "have \"\\<dots> \\<le> C * (m powr Re z * (1 / Re z + 1 / m))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. C * (\\<Sum>n = 1..m. real n powr (Re z - 1))\n    \\<le> C * (real m powr Re z * (1 / Re z + 1 / real m))", "using zeta_partial_sum_le'[of \"Re z\" m] assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 < Re z; 0 < m\\<rbrakk>\n  \\<Longrightarrow> (\\<Sum>n = 1..m. real n powr (Re z - 1))\n                    \\<le> real m powr Re z * (1 / Re z + 1 / real m)\n  1 \\<le> m\n  1 \\<le> Re w\n  0 < Re z\n  1 \\<le> ?n \\<Longrightarrow> cmod (f ?n) \\<le> C\n\ngoal (1 subgoal):\n 1. C * (\\<Sum>n = 1..m. real n powr (Re z - 1))\n    \\<le> C * (real m powr Re z * (1 / Re z + 1 / real m))", "by (intro mult_left_mono) auto"], ["proof (state)\nthis:\n  C * (\\<Sum>n = 1..m. real n powr (Re z - 1))\n  \\<le> C * (real m powr Re z * (1 / Re z + 1 / real m))\n\ngoal (1 subgoal):\n 1. cmod (\\<Sum>n = 1..m. f n / of_nat n powr (w - z))\n    \\<le> C * real m powr Re z * (1 / real m + 1 / Re z)", "finally"], ["proof (chain)\npicking this:\n  cmod (\\<Sum>n = 1..m. f n / of_nat n powr (w - z))\n  \\<le> C * (real m powr Re z * (1 / Re z + 1 / real m))", "show ?thesis"], ["proof (prove)\nusing this:\n  cmod (\\<Sum>n = 1..m. f n / of_nat n powr (w - z))\n  \\<le> C * (real m powr Re z * (1 / Re z + 1 / real m))\n\ngoal (1 subgoal):\n 1. cmod (\\<Sum>n = 1..m. f n / of_nat n powr (w - z))\n    \\<le> C * real m powr Re z * (1 / real m + 1 / Re z)", "by (simp add: mult_ac add_ac)"], ["proof (state)\nthis:\n  cmod (\\<Sum>n = 1..m. f n / of_nat n powr (w - z))\n  \\<le> C * real m powr Re z * (1 / real m + 1 / Re z)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma hurwitz_zeta_real_bound_aux:\n  fixes a x :: real\n  assumes ax: \"a > 0\" \"x > 1\"\n  shows \"(\\<Sum>i. (a + real (Suc i)) powr (-x)) \\<le> a powr (1 - x) / (x - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i. (a + real (Suc i)) powr - x) \\<le> a powr (1 - x) / (x - 1)", "proof (rule decreasing_sum_le_integral, goal_cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>xa. 0 \\<le> xa \\<Longrightarrow> 0 \\<le> (a + xa) powr - x\n 2. \\<And>xa y.\n       \\<lbrakk>0 \\<le> xa; xa \\<le> y\\<rbrakk>\n       \\<Longrightarrow> (a + y) powr - x \\<le> (a + xa) powr - x\n 3. ((\\<lambda>b. (a + b) powr - x) has_integral a powr (1 - x) / (x - 1))\n     {0..}", "have \"((\\<lambda>t. (a + t) powr -x) has_integral -(a powr (-x + 1)) / (-x + 1)) (interior {0..})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>t. (a + t) powr - x) has_integral\n     - (a powr (- x + 1)) / (- x + 1))\n     (interior {0..})", "using powr_has_integral_at_top[of 0 a \"-x\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 < 0 + a; - x < - 1\\<rbrakk>\n  \\<Longrightarrow> ((\\<lambda>xa. (a + xa) powr - x) has_integral\n                     - ((a + 0) powr (- x + 1) / (- x + 1)))\n                     {0<..}\n\ngoal (1 subgoal):\n 1. ((\\<lambda>t. (a + t) powr - x) has_integral\n     - (a powr (- x + 1)) / (- x + 1))\n     (interior {0..})", "using ax"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 < 0 + a; - x < - 1\\<rbrakk>\n  \\<Longrightarrow> ((\\<lambda>xa. (a + xa) powr - x) has_integral\n                     - ((a + 0) powr (- x + 1) / (- x + 1)))\n                     {0<..}\n  0 < a\n  1 < x\n\ngoal (1 subgoal):\n 1. ((\\<lambda>t. (a + t) powr - x) has_integral\n     - (a powr (- x + 1)) / (- x + 1))\n     (interior {0..})", "by (simp add: interior_real_atLeast)"], ["proof (state)\nthis:\n  ((\\<lambda>t. (a + t) powr - x) has_integral\n   - (a powr (- x + 1)) / (- x + 1))\n   (interior {0..})\n\ngoal (3 subgoals):\n 1. \\<And>xa. 0 \\<le> xa \\<Longrightarrow> 0 \\<le> (a + xa) powr - x\n 2. \\<And>xa y.\n       \\<lbrakk>0 \\<le> xa; xa \\<le> y\\<rbrakk>\n       \\<Longrightarrow> (a + y) powr - x \\<le> (a + xa) powr - x\n 3. ((\\<lambda>b. (a + b) powr - x) has_integral a powr (1 - x) / (x - 1))\n     {0..}", "also"], ["proof (state)\nthis:\n  ((\\<lambda>t. (a + t) powr - x) has_integral\n   - (a powr (- x + 1)) / (- x + 1))\n   (interior {0..})\n\ngoal (3 subgoals):\n 1. \\<And>xa. 0 \\<le> xa \\<Longrightarrow> 0 \\<le> (a + xa) powr - x\n 2. \\<And>xa y.\n       \\<lbrakk>0 \\<le> xa; xa \\<le> y\\<rbrakk>\n       \\<Longrightarrow> (a + y) powr - x \\<le> (a + xa) powr - x\n 3. ((\\<lambda>b. (a + b) powr - x) has_integral a powr (1 - x) / (x - 1))\n     {0..}", "have \"-(a powr (- x + 1)) / (- x + 1) = a powr (1 - x) / (x - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - (a powr (- x + 1)) / (- x + 1) = a powr (1 - x) / (x - 1)", "using ax"], ["proof (prove)\nusing this:\n  0 < a\n  1 < x\n\ngoal (1 subgoal):\n 1. - (a powr (- x + 1)) / (- x + 1) = a powr (1 - x) / (x - 1)", "by (simp add: field_simps)"], ["proof (state)\nthis:\n  - (a powr (- x + 1)) / (- x + 1) = a powr (1 - x) / (x - 1)\n\ngoal (3 subgoals):\n 1. \\<And>xa. 0 \\<le> xa \\<Longrightarrow> 0 \\<le> (a + xa) powr - x\n 2. \\<And>xa y.\n       \\<lbrakk>0 \\<le> xa; xa \\<le> y\\<rbrakk>\n       \\<Longrightarrow> (a + y) powr - x \\<le> (a + xa) powr - x\n 3. ((\\<lambda>b. (a + b) powr - x) has_integral a powr (1 - x) / (x - 1))\n     {0..}", "finally"], ["proof (chain)\npicking this:\n  ((\\<lambda>t. (a + t) powr - x) has_integral a powr (1 - x) / (x - 1))\n   (interior {0..})", "show \"((\\<lambda>t. (a + t) powr -x) has_integral a powr (1 - x) / (x - 1)) {0..}\""], ["proof (prove)\nusing this:\n  ((\\<lambda>t. (a + t) powr - x) has_integral a powr (1 - x) / (x - 1))\n   (interior {0..})\n\ngoal (1 subgoal):\n 1. ((\\<lambda>t. (a + t) powr - x) has_integral a powr (1 - x) / (x - 1))\n     {0..}", "by (subst (asm) has_integral_interior) auto"], ["proof (state)\nthis:\n  ((\\<lambda>t. (a + t) powr - x) has_integral a powr (1 - x) / (x - 1))\n   {0..}\n\ngoal (2 subgoals):\n 1. \\<And>xa. 0 \\<le> xa \\<Longrightarrow> 0 \\<le> (a + xa) powr - x\n 2. \\<And>xa y.\n       \\<lbrakk>0 \\<le> xa; xa \\<le> y\\<rbrakk>\n       \\<Longrightarrow> (a + y) powr - x \\<le> (a + xa) powr - x", "qed (insert ax, auto intro!: powr_mono2')"], ["", "text \\<open>\n  Given a function that is analytic on some vertical line segment, we can find a rectangle\n  around that line segment on which the function is also analytic.\n\\<close>"], ["", "lemma analytic_on_axis_extend:\n  fixes y1 y2 x :: real\n  defines \"S \\<equiv> {z. Re z = x \\<and> Im z \\<in> {y1..y2}}\"\n  assumes \"y1 \\<le> y2\"\n  assumes \"f analytic_on S\"\n  obtains x1 x2 :: real where \"x1 < x\" \"x2 > x\" \"f analytic_on cbox (Complex x1 y1) (Complex x2 y2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x1 x2.\n        \\<lbrakk>x1 < x; x < x2;\n         f analytic_on cbox (Complex x1 y1) (Complex x2 y2)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>x1 x2.\n        \\<lbrakk>x1 < x; x < x2;\n         f analytic_on cbox (Complex x1 y1) (Complex x2 y2)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "define C where \"C = {box a b |a b z. f analytic_on box a b \\<and> z \\<in> box a b \\<and> z \\<in> S}\""], ["proof (state)\nthis:\n  C =\n  {uu_.\n   \\<exists>a b z.\n      uu_ = box a b \\<and>\n      f analytic_on box a b \\<and> z \\<in> box a b \\<and> z \\<in> S}\n\ngoal (1 subgoal):\n 1. (\\<And>x1 x2.\n        \\<lbrakk>x1 < x; x < x2;\n         f analytic_on cbox (Complex x1 y1) (Complex x2 y2)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"S = cbox (Complex x y1) (Complex x y2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S = cbox (Complex x y1) (Complex x y2)", "by (auto simp: S_def in_cbox_complex_iff)"], ["proof (state)\nthis:\n  S = cbox (Complex x y1) (Complex x y2)\n\ngoal (1 subgoal):\n 1. (\\<And>x1 x2.\n        \\<lbrakk>x1 < x; x < x2;\n         f analytic_on cbox (Complex x1 y1) (Complex x2 y2)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "also"], ["proof (state)\nthis:\n  S = cbox (Complex x y1) (Complex x y2)\n\ngoal (1 subgoal):\n 1. (\\<And>x1 x2.\n        \\<lbrakk>x1 < x; x < x2;\n         f analytic_on cbox (Complex x1 y1) (Complex x2 y2)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"compact \\<dots>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. compact (cbox (Complex x y1) (Complex x y2))", "by simp"], ["proof (state)\nthis:\n  compact (cbox (Complex x y1) (Complex x y2))\n\ngoal (1 subgoal):\n 1. (\\<And>x1 x2.\n        \\<lbrakk>x1 < x; x < x2;\n         f analytic_on cbox (Complex x1 y1) (Complex x2 y2)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "finally"], ["proof (chain)\npicking this:\n  compact S", "have 1: \"compact S\""], ["proof (prove)\nusing this:\n  compact S\n\ngoal (1 subgoal):\n 1. compact S", "."], ["proof (state)\nthis:\n  compact S\n\ngoal (1 subgoal):\n 1. (\\<And>x1 x2.\n        \\<lbrakk>x1 < x; x < x2;\n         f analytic_on cbox (Complex x1 y1) (Complex x2 y2)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have 2: \"S \\<subseteq> \\<Union>C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S \\<subseteq> \\<Union> C", "proof (intro subsetI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> S \\<Longrightarrow> x \\<in> \\<Union> C", "fix z"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> S \\<Longrightarrow> x \\<in> \\<Union> C", "assume \"z \\<in> S\""], ["proof (state)\nthis:\n  z \\<in> S\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> S \\<Longrightarrow> x \\<in> \\<Union> C", "from \\<open>f analytic_on S\\<close> and this"], ["proof (chain)\npicking this:\n  f analytic_on S\n  z \\<in> S", "obtain a b where \"z \\<in> box a b\" \"f analytic_on box a b\""], ["proof (prove)\nusing this:\n  f analytic_on S\n  z \\<in> S\n\ngoal (1 subgoal):\n 1. (\\<And>a b.\n        \\<lbrakk>z \\<in> box a b; f analytic_on box a b\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (blast elim: analytic_onE_box)"], ["proof (state)\nthis:\n  z \\<in> box a b\n  f analytic_on box a b\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> S \\<Longrightarrow> x \\<in> \\<Union> C", "with \\<open>z \\<in> S\\<close>"], ["proof (chain)\npicking this:\n  z \\<in> S\n  z \\<in> box a b\n  f analytic_on box a b", "show \"z \\<in> \\<Union>C\""], ["proof (prove)\nusing this:\n  z \\<in> S\n  z \\<in> box a b\n  f analytic_on box a b\n\ngoal (1 subgoal):\n 1. z \\<in> \\<Union> C", "unfolding C_def"], ["proof (prove)\nusing this:\n  z \\<in> S\n  z \\<in> box a b\n  f analytic_on box a b\n\ngoal (1 subgoal):\n 1. z \\<in> \\<Union>\n             {uu_.\n              \\<exists>a b z.\n                 uu_ = box a b \\<and>\n                 f analytic_on box a b \\<and>\n                 z \\<in> box a b \\<and> z \\<in> S}", "by blast"], ["proof (state)\nthis:\n  z \\<in> \\<Union> C\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  S \\<subseteq> \\<Union> C\n\ngoal (1 subgoal):\n 1. (\\<And>x1 x2.\n        \\<lbrakk>x1 < x; x < x2;\n         f analytic_on cbox (Complex x1 y1) (Complex x2 y2)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have 3: \"open X\" if \"X \\<in> C\" for X"], ["proof (prove)\ngoal (1 subgoal):\n 1. open X", "using that"], ["proof (prove)\nusing this:\n  X \\<in> C\n\ngoal (1 subgoal):\n 1. open X", "by (auto simp: C_def)"], ["proof (state)\nthis:\n  ?X \\<in> C \\<Longrightarrow> open ?X\n\ngoal (1 subgoal):\n 1. (\\<And>x1 x2.\n        \\<lbrakk>x1 < x; x < x2;\n         f analytic_on cbox (Complex x1 y1) (Complex x2 y2)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from compactE[OF 1 2 3]"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<And>B. B \\<in> C \\<Longrightarrow> B \\<in> C;\n   \\<And>\\<T>'.\n      \\<lbrakk>\\<T>' \\<subseteq> C; finite \\<T>';\n       S \\<subseteq> \\<Union> \\<T>'\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis", "obtain T where T: \"T \\<subseteq> C\" \"finite T\" \"S \\<subseteq> \\<Union>T\""], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>B. B \\<in> C \\<Longrightarrow> B \\<in> C;\n   \\<And>\\<T>'.\n      \\<lbrakk>\\<T>' \\<subseteq> C; finite \\<T>';\n       S \\<subseteq> \\<Union> \\<T>'\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>T.\n        \\<lbrakk>T \\<subseteq> C; finite T;\n         S \\<subseteq> \\<Union> T\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  T \\<subseteq> C\n  finite T\n  S \\<subseteq> \\<Union> T\n\ngoal (1 subgoal):\n 1. (\\<And>x1 x2.\n        \\<lbrakk>x1 < x; x < x2;\n         f analytic_on cbox (Complex x1 y1) (Complex x2 y2)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "define x1 where \"x1 = Max (insert (x - 1) ((\\<lambda>X. x + (Inf (Re ` X) - x) / 2) ` T))\""], ["proof (state)\nthis:\n  x1 = Max (insert (x - 1) ((\\<lambda>X. x + (Inf (Re ` X) - x) / 2) ` T))\n\ngoal (1 subgoal):\n 1. (\\<And>x1 x2.\n        \\<lbrakk>x1 < x; x < x2;\n         f analytic_on cbox (Complex x1 y1) (Complex x2 y2)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "define x2 where \"x2 = Min (insert (x + 1) ((\\<lambda>X. x + (Sup (Re ` X) - x) / 2) ` T))\""], ["proof (state)\nthis:\n  x2 = Min (insert (x + 1) ((\\<lambda>X. x + (Sup (Re ` X) - x) / 2) ` T))\n\ngoal (1 subgoal):\n 1. (\\<And>x1 x2.\n        \\<lbrakk>x1 < x; x < x2;\n         f analytic_on cbox (Complex x1 y1) (Complex x2 y2)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have *: \"x + (Inf (Re ` X) - x) / 2 < x \\<and> x + (Sup (Re ` X) - x) / 2 > x\" if \"X \\<in> T\" for X"], ["proof (prove)\ngoal (1 subgoal):\n 1. x + (Inf (Re ` X) - x) / 2 < x \\<and> x < x + (Sup (Re ` X) - x) / 2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x + (Inf (Re ` X) - x) / 2 < x \\<and> x < x + (Sup (Re ` X) - x) / 2", "from that and T"], ["proof (chain)\npicking this:\n  X \\<in> T\n  T \\<subseteq> C\n  finite T\n  S \\<subseteq> \\<Union> T", "obtain a b s where [simp]: \"X = box a b\" and s: \"s \\<in> box a b\" \"s \\<in> S\""], ["proof (prove)\nusing this:\n  X \\<in> T\n  T \\<subseteq> C\n  finite T\n  S \\<subseteq> \\<Union> T\n\ngoal (1 subgoal):\n 1. (\\<And>a b s.\n        \\<lbrakk>X = box a b; s \\<in> box a b; s \\<in> S\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (force simp: C_def)"], ["proof (state)\nthis:\n  X = box a b\n  s \\<in> box a b\n  s \\<in> S\n\ngoal (1 subgoal):\n 1. x + (Inf (Re ` X) - x) / 2 < x \\<and> x < x + (Sup (Re ` X) - x) / 2", "hence le: \"Re a < Re b\" \"Im a < Im b\""], ["proof (prove)\nusing this:\n  X = box a b\n  s \\<in> box a b\n  s \\<in> S\n\ngoal (1 subgoal):\n 1. Re a < Re b &&& Im a < Im b", "by (auto simp: in_box_complex_iff)"], ["proof (state)\nthis:\n  Re a < Re b\n  Im a < Im b\n\ngoal (1 subgoal):\n 1. x + (Inf (Re ` X) - x) / 2 < x \\<and> x < x + (Sup (Re ` X) - x) / 2", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. x + (Inf (Re ` X) - x) / 2 < x \\<and> x < x + (Sup (Re ` X) - x) / 2", "using le s"], ["proof (prove)\nusing this:\n  Re a < Re b\n  Im a < Im b\n  s \\<in> box a b\n  s \\<in> S\n\ngoal (1 subgoal):\n 1. x + (Inf (Re ` X) - x) / 2 < x \\<and> x < x + (Sup (Re ` X) - x) / 2", "unfolding \\<open>X = box a b\\<close> Re_image_box[OF le] Im_image_box[OF le]"], ["proof (prove)\nusing this:\n  Re a < Re b\n  Im a < Im b\n  s \\<in> box a b\n  s \\<in> S\n\ngoal (1 subgoal):\n 1. x + (Inf {Re a<..<Re b} - x) / 2 < x \\<and>\n    x < x + (Sup {Re a<..<Re b} - x) / 2", "by (auto simp: S_def in_box_complex_iff)"], ["proof (state)\nthis:\n  x + (Inf (Re ` X) - x) / 2 < x \\<and> x < x + (Sup (Re ` X) - x) / 2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?X \\<in> T \\<Longrightarrow>\n  x + (Inf (Re ` ?X) - x) / 2 < x \\<and> x < x + (Sup (Re ` ?X) - x) / 2\n\ngoal (1 subgoal):\n 1. (\\<And>x1 x2.\n        \\<lbrakk>x1 < x; x < x2;\n         f analytic_on cbox (Complex x1 y1) (Complex x2 y2)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from * T"], ["proof (chain)\npicking this:\n  ?X \\<in> T \\<Longrightarrow>\n  x + (Inf (Re ` ?X) - x) / 2 < x \\<and> x < x + (Sup (Re ` ?X) - x) / 2\n  T \\<subseteq> C\n  finite T\n  S \\<subseteq> \\<Union> T", "have \"x1 < x\""], ["proof (prove)\nusing this:\n  ?X \\<in> T \\<Longrightarrow>\n  x + (Inf (Re ` ?X) - x) / 2 < x \\<and> x < x + (Sup (Re ` ?X) - x) / 2\n  T \\<subseteq> C\n  finite T\n  S \\<subseteq> \\<Union> T\n\ngoal (1 subgoal):\n 1. x1 < x", "unfolding x1_def"], ["proof (prove)\nusing this:\n  ?X \\<in> T \\<Longrightarrow>\n  x + (Inf (Re ` ?X) - x) / 2 < x \\<and> x < x + (Sup (Re ` ?X) - x) / 2\n  T \\<subseteq> C\n  finite T\n  S \\<subseteq> \\<Union> T\n\ngoal (1 subgoal):\n 1. Max (insert (x - 1) ((\\<lambda>X. x + (Inf (Re ` X) - x) / 2) ` T)) < x", "by (subst Max_less_iff) auto"], ["proof (state)\nthis:\n  x1 < x\n\ngoal (1 subgoal):\n 1. (\\<And>x1 x2.\n        \\<lbrakk>x1 < x; x < x2;\n         f analytic_on cbox (Complex x1 y1) (Complex x2 y2)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from * T"], ["proof (chain)\npicking this:\n  ?X \\<in> T \\<Longrightarrow>\n  x + (Inf (Re ` ?X) - x) / 2 < x \\<and> x < x + (Sup (Re ` ?X) - x) / 2\n  T \\<subseteq> C\n  finite T\n  S \\<subseteq> \\<Union> T", "have \"x2 > x\""], ["proof (prove)\nusing this:\n  ?X \\<in> T \\<Longrightarrow>\n  x + (Inf (Re ` ?X) - x) / 2 < x \\<and> x < x + (Sup (Re ` ?X) - x) / 2\n  T \\<subseteq> C\n  finite T\n  S \\<subseteq> \\<Union> T\n\ngoal (1 subgoal):\n 1. x < x2", "unfolding x2_def"], ["proof (prove)\nusing this:\n  ?X \\<in> T \\<Longrightarrow>\n  x + (Inf (Re ` ?X) - x) / 2 < x \\<and> x < x + (Sup (Re ` ?X) - x) / 2\n  T \\<subseteq> C\n  finite T\n  S \\<subseteq> \\<Union> T\n\ngoal (1 subgoal):\n 1. x < Min (insert (x + 1) ((\\<lambda>X. x + (Sup (Re ` X) - x) / 2) ` T))", "by (subst Min_gr_iff) auto"], ["proof (state)\nthis:\n  x < x2\n\ngoal (1 subgoal):\n 1. (\\<And>x1 x2.\n        \\<lbrakk>x1 < x; x < x2;\n         f analytic_on cbox (Complex x1 y1) (Complex x2 y2)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"f analytic_on (\\<Union>T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f analytic_on \\<Union> T", "using T"], ["proof (prove)\nusing this:\n  T \\<subseteq> C\n  finite T\n  S \\<subseteq> \\<Union> T\n\ngoal (1 subgoal):\n 1. f analytic_on \\<Union> T", "by (subst analytic_on_Union) (auto simp: C_def)"], ["proof (state)\nthis:\n  f analytic_on \\<Union> T\n\ngoal (1 subgoal):\n 1. (\\<And>x1 x2.\n        \\<lbrakk>x1 < x; x < x2;\n         f analytic_on cbox (Complex x1 y1) (Complex x2 y2)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  f analytic_on \\<Union> T\n\ngoal (1 subgoal):\n 1. (\\<And>x1 x2.\n        \\<lbrakk>x1 < x; x < x2;\n         f analytic_on cbox (Complex x1 y1) (Complex x2 y2)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"z \\<in> \\<Union>T\" if \"z \\<in> cbox (Complex x1 y1) (Complex x2 y2)\" for z"], ["proof (prove)\ngoal (1 subgoal):\n 1. z \\<in> \\<Union> T", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. z \\<in> \\<Union> T", "from that"], ["proof (chain)\npicking this:\n  z \\<in> cbox (Complex x1 y1) (Complex x2 y2)", "have \"Complex x (Im z) \\<in> S\""], ["proof (prove)\nusing this:\n  z \\<in> cbox (Complex x1 y1) (Complex x2 y2)\n\ngoal (1 subgoal):\n 1. Complex x (Im z) \\<in> S", "by (auto simp: in_cbox_complex_iff S_def)"], ["proof (state)\nthis:\n  Complex x (Im z) \\<in> S\n\ngoal (1 subgoal):\n 1. z \\<in> \\<Union> T", "with T"], ["proof (chain)\npicking this:\n  T \\<subseteq> C\n  finite T\n  S \\<subseteq> \\<Union> T\n  Complex x (Im z) \\<in> S", "obtain X where X: \"X \\<in> T\" \"Complex x (Im z) \\<in> X\""], ["proof (prove)\nusing this:\n  T \\<subseteq> C\n  finite T\n  S \\<subseteq> \\<Union> T\n  Complex x (Im z) \\<in> S\n\ngoal (1 subgoal):\n 1. (\\<And>X.\n        \\<lbrakk>X \\<in> T; Complex x (Im z) \\<in> X\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  X \\<in> T\n  Complex x (Im z) \\<in> X\n\ngoal (1 subgoal):\n 1. z \\<in> \\<Union> T", "with T"], ["proof (chain)\npicking this:\n  T \\<subseteq> C\n  finite T\n  S \\<subseteq> \\<Union> T\n  X \\<in> T\n  Complex x (Im z) \\<in> X", "obtain a b where [simp]: \"X = box a b\""], ["proof (prove)\nusing this:\n  T \\<subseteq> C\n  finite T\n  S \\<subseteq> \\<Union> T\n  X \\<in> T\n  Complex x (Im z) \\<in> X\n\ngoal (1 subgoal):\n 1. (\\<And>a b. X = box a b \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: C_def)"], ["proof (state)\nthis:\n  X = box a b\n\ngoal (1 subgoal):\n 1. z \\<in> \\<Union> T", "from X"], ["proof (chain)\npicking this:\n  X \\<in> T\n  Complex x (Im z) \\<in> X", "have le: \"Re a < Re b\" \"Im a < Im b\""], ["proof (prove)\nusing this:\n  X \\<in> T\n  Complex x (Im z) \\<in> X\n\ngoal (1 subgoal):\n 1. Re a < Re b &&& Im a < Im b", "by (auto simp: in_box_complex_iff)"], ["proof (state)\nthis:\n  Re a < Re b\n  Im a < Im b\n\ngoal (1 subgoal):\n 1. z \\<in> \\<Union> T", "from that"], ["proof (chain)\npicking this:\n  z \\<in> cbox (Complex x1 y1) (Complex x2 y2)", "have \"Re z \\<le> x2\""], ["proof (prove)\nusing this:\n  z \\<in> cbox (Complex x1 y1) (Complex x2 y2)\n\ngoal (1 subgoal):\n 1. Re z \\<le> x2", "by (simp add: in_cbox_complex_iff)"], ["proof (state)\nthis:\n  Re z \\<le> x2\n\ngoal (1 subgoal):\n 1. z \\<in> \\<Union> T", "also"], ["proof (state)\nthis:\n  Re z \\<le> x2\n\ngoal (1 subgoal):\n 1. z \\<in> \\<Union> T", "have \"\\<dots> \\<le> x + (Sup (Re ` X) - x) / 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x2 \\<le> x + (Sup (Re ` X) - x) / 2", "unfolding x2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Min (insert (x + 1) ((\\<lambda>X. x + (Sup (Re ` X) - x) / 2) ` T))\n    \\<le> x + (Sup (Re ` X) - x) / 2", "by (rule Min.coboundedI)(use T X in auto)"], ["proof (state)\nthis:\n  x2 \\<le> x + (Sup (Re ` X) - x) / 2\n\ngoal (1 subgoal):\n 1. z \\<in> \\<Union> T", "also"], ["proof (state)\nthis:\n  x2 \\<le> x + (Sup (Re ` X) - x) / 2\n\ngoal (1 subgoal):\n 1. z \\<in> \\<Union> T", "have \"\\<dots> = (x + Re b) / 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x + (Sup (Re ` X) - x) / 2 = (x + Re b) / 2", "using le"], ["proof (prove)\nusing this:\n  Re a < Re b\n  Im a < Im b\n\ngoal (1 subgoal):\n 1. x + (Sup (Re ` X) - x) / 2 = (x + Re b) / 2", "unfolding \\<open>X = box a b\\<close> Re_image_box[OF le]"], ["proof (prove)\nusing this:\n  Re a < Re b\n  Im a < Im b\n\ngoal (1 subgoal):\n 1. x + (Sup {Re a<..<Re b} - x) / 2 = (x + Re b) / 2", "by (simp add: field_simps)"], ["proof (state)\nthis:\n  x + (Sup (Re ` X) - x) / 2 = (x + Re b) / 2\n\ngoal (1 subgoal):\n 1. z \\<in> \\<Union> T", "also"], ["proof (state)\nthis:\n  x + (Sup (Re ` X) - x) / 2 = (x + Re b) / 2\n\ngoal (1 subgoal):\n 1. z \\<in> \\<Union> T", "have \"\\<dots> < (Re b + Re b) / 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x + Re b) / 2 < (Re b + Re b) / 2", "using X"], ["proof (prove)\nusing this:\n  X \\<in> T\n  Complex x (Im z) \\<in> X\n\ngoal (1 subgoal):\n 1. (x + Re b) / 2 < (Re b + Re b) / 2", "by (intro divide_strict_right_mono add_strict_right_mono)\n                 (auto simp: in_box_complex_iff)"], ["proof (state)\nthis:\n  (x + Re b) / 2 < (Re b + Re b) / 2\n\ngoal (1 subgoal):\n 1. z \\<in> \\<Union> T", "also"], ["proof (state)\nthis:\n  (x + Re b) / 2 < (Re b + Re b) / 2\n\ngoal (1 subgoal):\n 1. z \\<in> \\<Union> T", "have \"\\<dots> = Re b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Re b + Re b) / 2 = Re b", "by simp"], ["proof (state)\nthis:\n  (Re b + Re b) / 2 = Re b\n\ngoal (1 subgoal):\n 1. z \\<in> \\<Union> T", "finally"], ["proof (chain)\npicking this:\n  Re z < Re b", "have [simp]: \"Re z < Re b\""], ["proof (prove)\nusing this:\n  Re z < Re b\n\ngoal (1 subgoal):\n 1. Re z < Re b", "."], ["proof (state)\nthis:\n  Re z < Re b\n\ngoal (1 subgoal):\n 1. z \\<in> \\<Union> T", "have \"Re a = (Re a + Re a) / 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Re a = (Re a + Re a) / 2", "by simp"], ["proof (state)\nthis:\n  Re a = (Re a + Re a) / 2\n\ngoal (1 subgoal):\n 1. z \\<in> \\<Union> T", "also"], ["proof (state)\nthis:\n  Re a = (Re a + Re a) / 2\n\ngoal (1 subgoal):\n 1. z \\<in> \\<Union> T", "have \"\\<dots> < (x + Re a) / 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Re a + Re a) / 2 < (x + Re a) / 2", "using X"], ["proof (prove)\nusing this:\n  X \\<in> T\n  Complex x (Im z) \\<in> X\n\ngoal (1 subgoal):\n 1. (Re a + Re a) / 2 < (x + Re a) / 2", "by (intro divide_strict_right_mono add_strict_right_mono)\n                 (auto simp: in_box_complex_iff)"], ["proof (state)\nthis:\n  (Re a + Re a) / 2 < (x + Re a) / 2\n\ngoal (1 subgoal):\n 1. z \\<in> \\<Union> T", "also"], ["proof (state)\nthis:\n  (Re a + Re a) / 2 < (x + Re a) / 2\n\ngoal (1 subgoal):\n 1. z \\<in> \\<Union> T", "have \"\\<dots> = x + (Inf (Re ` X) - x) / 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x + Re a) / 2 = x + (Inf (Re ` X) - x) / 2", "using le"], ["proof (prove)\nusing this:\n  Re a < Re b\n  Im a < Im b\n\ngoal (1 subgoal):\n 1. (x + Re a) / 2 = x + (Inf (Re ` X) - x) / 2", "unfolding \\<open>X = box a b\\<close> Re_image_box[OF le]"], ["proof (prove)\nusing this:\n  Re a < Re b\n  Im a < Im b\n\ngoal (1 subgoal):\n 1. (x + Re a) / 2 = x + (Inf {Re a<..<Re b} - x) / 2", "by (simp add: field_simps)"], ["proof (state)\nthis:\n  (x + Re a) / 2 = x + (Inf (Re ` X) - x) / 2\n\ngoal (1 subgoal):\n 1. z \\<in> \\<Union> T", "also"], ["proof (state)\nthis:\n  (x + Re a) / 2 = x + (Inf (Re ` X) - x) / 2\n\ngoal (1 subgoal):\n 1. z \\<in> \\<Union> T", "have \"\\<dots> \\<le> x1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x + (Inf (Re ` X) - x) / 2 \\<le> x1", "unfolding x1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. x + (Inf (Re ` X) - x) / 2\n    \\<le> Max (insert (x - 1)\n                ((\\<lambda>X. x + (Inf (Re ` X) - x) / 2) ` T))", "by (rule Max.coboundedI)(use T X in auto)"], ["proof (state)\nthis:\n  x + (Inf (Re ` X) - x) / 2 \\<le> x1\n\ngoal (1 subgoal):\n 1. z \\<in> \\<Union> T", "also"], ["proof (state)\nthis:\n  x + (Inf (Re ` X) - x) / 2 \\<le> x1\n\ngoal (1 subgoal):\n 1. z \\<in> \\<Union> T", "have \"\\<dots> \\<le> Re z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x1 \\<le> Re z", "using that"], ["proof (prove)\nusing this:\n  z \\<in> cbox (Complex x1 y1) (Complex x2 y2)\n\ngoal (1 subgoal):\n 1. x1 \\<le> Re z", "by (simp add: in_cbox_complex_iff)"], ["proof (state)\nthis:\n  x1 \\<le> Re z\n\ngoal (1 subgoal):\n 1. z \\<in> \\<Union> T", "finally"], ["proof (chain)\npicking this:\n  Re a < Re z", "have [simp]: \"Re z > Re a\""], ["proof (prove)\nusing this:\n  Re a < Re z\n\ngoal (1 subgoal):\n 1. Re a < Re z", "."], ["proof (state)\nthis:\n  Re a < Re z\n\ngoal (1 subgoal):\n 1. z \\<in> \\<Union> T", "from X"], ["proof (chain)\npicking this:\n  X \\<in> T\n  Complex x (Im z) \\<in> X", "have \"z \\<in> X\""], ["proof (prove)\nusing this:\n  X \\<in> T\n  Complex x (Im z) \\<in> X\n\ngoal (1 subgoal):\n 1. z \\<in> X", "by (simp add: in_box_complex_iff)"], ["proof (state)\nthis:\n  z \\<in> X\n\ngoal (1 subgoal):\n 1. z \\<in> \\<Union> T", "with T X"], ["proof (chain)\npicking this:\n  T \\<subseteq> C\n  finite T\n  S \\<subseteq> \\<Union> T\n  X \\<in> T\n  Complex x (Im z) \\<in> X\n  z \\<in> X", "show ?thesis"], ["proof (prove)\nusing this:\n  T \\<subseteq> C\n  finite T\n  S \\<subseteq> \\<Union> T\n  X \\<in> T\n  Complex x (Im z) \\<in> X\n  z \\<in> X\n\ngoal (1 subgoal):\n 1. z \\<in> \\<Union> T", "by blast"], ["proof (state)\nthis:\n  z \\<in> \\<Union> T\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?z \\<in> cbox (Complex x1 y1) (Complex x2 y2) \\<Longrightarrow>\n  ?z \\<in> \\<Union> T\n\ngoal (1 subgoal):\n 1. (\\<And>x1 x2.\n        \\<lbrakk>x1 < x; x < x2;\n         f analytic_on cbox (Complex x1 y1) (Complex x2 y2)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "hence \"cbox (Complex x1 y1) (Complex x2 y2) \\<subseteq> \\<Union>T\""], ["proof (prove)\nusing this:\n  ?z \\<in> cbox (Complex x1 y1) (Complex x2 y2) \\<Longrightarrow>\n  ?z \\<in> \\<Union> T\n\ngoal (1 subgoal):\n 1. cbox (Complex x1 y1) (Complex x2 y2) \\<subseteq> \\<Union> T", "by blast"], ["proof (state)\nthis:\n  cbox (Complex x1 y1) (Complex x2 y2) \\<subseteq> \\<Union> T\n\ngoal (1 subgoal):\n 1. (\\<And>x1 x2.\n        \\<lbrakk>x1 < x; x < x2;\n         f analytic_on cbox (Complex x1 y1) (Complex x2 y2)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "ultimately"], ["proof (chain)\npicking this:\n  f analytic_on \\<Union> T\n  cbox (Complex x1 y1) (Complex x2 y2) \\<subseteq> \\<Union> T", "have \"f analytic_on cbox (Complex x1 y1) (Complex x2 y2)\""], ["proof (prove)\nusing this:\n  f analytic_on \\<Union> T\n  cbox (Complex x1 y1) (Complex x2 y2) \\<subseteq> \\<Union> T\n\ngoal (1 subgoal):\n 1. f analytic_on cbox (Complex x1 y1) (Complex x2 y2)", "by (rule analytic_on_subset)"], ["proof (state)\nthis:\n  f analytic_on cbox (Complex x1 y1) (Complex x2 y2)\n\ngoal (1 subgoal):\n 1. (\\<And>x1 x2.\n        \\<lbrakk>x1 < x; x < x2;\n         f analytic_on cbox (Complex x1 y1) (Complex x2 y2)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "with \\<open>x1 < x\\<close> and \\<open>x2 > x\\<close> and that[of x1 x2]"], ["proof (chain)\npicking this:\n  x1 < x\n  x < x2\n  \\<lbrakk>x1 < x; x < x2;\n   f analytic_on cbox (Complex x1 y1) (Complex x2 y2)\\<rbrakk>\n  \\<Longrightarrow> thesis\n  f analytic_on cbox (Complex x1 y1) (Complex x2 y2)", "show ?thesis"], ["proof (prove)\nusing this:\n  x1 < x\n  x < x2\n  \\<lbrakk>x1 < x; x < x2;\n   f analytic_on cbox (Complex x1 y1) (Complex x2 y2)\\<rbrakk>\n  \\<Longrightarrow> thesis\n  f analytic_on cbox (Complex x1 y1) (Complex x2 y2)\n\ngoal (1 subgoal):\n 1. thesis", "by blast"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  We will now prove the theorem. The precise setting is this:\n  Consider a Dirichlet series $F(s) = \\sum a_n n^{-s}$ with bounded coefficients. Clearly,\n  this converges to an analytic function $f(s)$ on $\\{s\\mid \\mathfrak R(s)>1\\}$.\n\n  If $f(s)$ is analytic on the larger set $\\{s\\mid \\mathfrak R(s)\\geq 1\\}$, $F$ converges\n  to $f(s)$ for all $\\mathfrak R(s) \\geq 1$.\n\n  The proof follows Newman's argument very closely, but some of the precise bounds we use\n  are a bit different from his. Also, like Harrison, we choose a combination of a semicircle\n  and a rectangle as our contour, whereas Newman uses a circle with a vertical cut-off. The result\n  of the Residue theorem is the same in both cases, but the bounding of the contributions of the\n  different parts is somewhat different.\n\n  The reason why we picked Harrison's contour over Newman's is because we could not understand how\n  his bounding of the different contributions fits to his contour, and it seems likely that this\n  is also the reason why Harrison altered the contour in the first place.\n\\<close>"], ["", "lemma Newman_Ingham_1:\n  fixes F :: \"complex fds\" and f :: \"complex \\<Rightarrow> complex\"\n  assumes coeff_bound:   \"fds_nth F \\<in> O(\\<lambda>_. 1)\"\n  assumes f_analytic:    \"f analytic_on {s. Re s \\<ge> 1}\"\n  assumes F_conv_f:      \"\\<And>s. Re s > 1 \\<Longrightarrow> eval_fds F s = f s\"\n  assumes w:             \"Re w \\<ge> 1\"\n  shows   \"fds_converges F w\" and \"eval_fds F w = f w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fds_converges F w &&& eval_fds F w = f w", "proof -\n  \\<comment> \\<open>We get a bound on our coefficients and call it \\<open>C\\<close>.\\<close>"], ["proof (state)\ngoal (2 subgoals):\n 1. fds_converges F w\n 2. eval_fds F w = f w", "obtain C where C: \"C \\<ge> 1\" \"\\<And>n. norm (fds_nth F n) \\<le> C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>C.\n        \\<lbrakk>1 \\<le> C; \\<And>n. cmod (fds_nth F n) \\<le> C\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using natfun_bigo_1E[OF coeff_bound, where lb = 1]"], ["proof (prove)\nusing this:\n  (\\<And>C.\n      \\<lbrakk>1 \\<le> C; \\<And>n. cmod (fds_nth F n) \\<le> C\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>C.\n        \\<lbrakk>1 \\<le> C; \\<And>n. cmod (fds_nth F n) \\<le> C\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  1 \\<le> C\n  cmod (fds_nth F ?n) \\<le> C\n\ngoal (2 subgoals):\n 1. fds_converges F w\n 2. eval_fds F w = f w", "write contour_integral (\"\\<ointegral>[_]\")\n\n  \\<comment> \\<open>We show convergence directly by showing that the difference between the \n      partial sums and the limit vanishes.\\<close>"], ["proof (state)\ngoal (2 subgoals):\n 1. fds_converges F w\n 2. eval_fds F w = f w", "have \"(\\<lambda>N. eval_fds (fds_truncate N F) w) \\<longlonglongrightarrow> f w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>N. eval_fds (fds_truncate N F) w)\n    \\<longlonglongrightarrow> f w", "unfolding tendsto_iff dist_norm norm_minus_commute[of \"eval_fds F s\" for F s]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>e>0.\n       \\<forall>\\<^sub>F x in sequentially.\n          cmod (f w - eval_fds (fds_truncate x F) w) < e", "proof safe"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>e.\n       0 < e \\<Longrightarrow>\n       \\<forall>\\<^sub>F x in sequentially.\n          cmod (f w - eval_fds (fds_truncate x F) w) < e", "fix \\<epsilon> :: real"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>e.\n       0 < e \\<Longrightarrow>\n       \\<forall>\\<^sub>F x in sequentially.\n          cmod (f w - eval_fds (fds_truncate x F) w) < e", "assume \\<epsilon>: \"\\<epsilon> > 0\"\n    \\<comment> \\<open>We choose an integration radius that is big enough for the error to be sufficiently small.\\<close>"], ["proof (state)\nthis:\n  0 < \\<epsilon>\n\ngoal (1 subgoal):\n 1. \\<And>e.\n       0 < e \\<Longrightarrow>\n       \\<forall>\\<^sub>F x in sequentially.\n          cmod (f w - eval_fds (fds_truncate x F) w) < e", "define R where \"R = max 1 (3 * C / \\<epsilon>)\""], ["proof (state)\nthis:\n  R = max 1 (3 * C / \\<epsilon>)\n\ngoal (1 subgoal):\n 1. \\<And>e.\n       0 < e \\<Longrightarrow>\n       \\<forall>\\<^sub>F x in sequentially.\n          cmod (f w - eval_fds (fds_truncate x F) w) < e", "have R: \"R \\<ge> 3 * C / \\<epsilon>\" \"R \\<ge> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 3 * C / \\<epsilon> \\<le> R &&& 1 \\<le> R", "by (auto simp: R_def)\n\n    \\<comment> \\<open>Next, we extend the analyticity of \\<open>f (w + z)\\<close> to the left of the complex plane\n        within a thin rectangle that is at least as high as the circle.\\<close>"], ["proof (state)\nthis:\n  3 * C / \\<epsilon> \\<le> R\n  1 \\<le> R\n\ngoal (1 subgoal):\n 1. \\<And>e.\n       0 < e \\<Longrightarrow>\n       \\<forall>\\<^sub>F x in sequentially.\n          cmod (f w - eval_fds (fds_truncate x F) w) < e", "obtain l where l: \"l > 0\"\n      \"(\\<lambda>z. f (w + z)) analytic_on {s. Re s > 0 \\<or> Im s \\<in> {-R-1<..<R+1} \\<and> Re s > -l}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>l.\n        \\<lbrakk>0 < l;\n         (\\<lambda>z. f (w + z)) analytic_on\n         {s. 0 < Re s \\<or>\n             Im s \\<in> {- R - 1<..<R + 1} \\<and> - l < Re s}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>l.\n        \\<lbrakk>0 < l;\n         (\\<lambda>z. f (w + z)) analytic_on\n         {s. 0 < Re s \\<or>\n             Im s \\<in> {- R - 1<..<R + 1} \\<and> - l < Re s}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have f_analytic': \"(\\<lambda>z. f (w + z)) analytic_on {s. Re s \\<ge> 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>z. f (w + z)) analytic_on {s. 0 \\<le> Re s}", "by (rule analytic_on_compose_gen[OF _ f_analytic, unfolded o_def])\n           (insert w, auto intro: analytic_intros)"], ["proof (state)\nthis:\n  (\\<lambda>z. f (w + z)) analytic_on {s. 0 \\<le> Re s}\n\ngoal (1 subgoal):\n 1. (\\<And>l.\n        \\<lbrakk>0 < l;\n         (\\<lambda>z. f (w + z)) analytic_on\n         {s. 0 < Re s \\<or>\n             Im s \\<in> {- R - 1<..<R + 1} \\<and> - l < Re s}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "hence \"(\\<lambda>z. f (w + z)) analytic_on {s. Re s = 0 \\<and> Im s \\<in> {-R-1..R+1}}\""], ["proof (prove)\nusing this:\n  (\\<lambda>z. f (w + z)) analytic_on {s. 0 \\<le> Re s}\n\ngoal (1 subgoal):\n 1. (\\<lambda>z. f (w + z)) analytic_on\n    {s. Re s = 0 \\<and> Im s \\<in> {- R - 1..R + 1}}", "by (rule analytic_on_subset) auto"], ["proof (state)\nthis:\n  (\\<lambda>z. f (w + z)) analytic_on\n  {s. Re s = 0 \\<and> Im s \\<in> {- R - 1..R + 1}}\n\ngoal (1 subgoal):\n 1. (\\<And>l.\n        \\<lbrakk>0 < l;\n         (\\<lambda>z. f (w + z)) analytic_on\n         {s. 0 < Re s \\<or>\n             Im s \\<in> {- R - 1<..<R + 1} \\<and> - l < Re s}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from analytic_on_axis_extend[OF _ this]"], ["proof (chain)\npicking this:\n  \\<lbrakk>- R - 1 \\<le> R + 1;\n   \\<And>x1 x2.\n      \\<lbrakk>x1 < 0; 0 < x2;\n       (\\<lambda>z. f (w + z)) analytic_on\n       cbox (Complex x1 (- R - 1)) (Complex x2 (R + 1))\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis", "obtain x1 x2 where x12: \n        \"x1 < 0\" \"x2 > 0\" \"(\\<lambda>z. f (w + z)) analytic_on cbox (Complex x1 (-R-1)) (Complex x2 (R+1))\""], ["proof (prove)\nusing this:\n  \\<lbrakk>- R - 1 \\<le> R + 1;\n   \\<And>x1 x2.\n      \\<lbrakk>x1 < 0; 0 < x2;\n       (\\<lambda>z. f (w + z)) analytic_on\n       cbox (Complex x1 (- R - 1)) (Complex x2 (R + 1))\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>x1 x2.\n        \\<lbrakk>x1 < 0; 0 < x2;\n         (\\<lambda>z. f (w + z)) analytic_on\n         cbox (Complex x1 (- R - 1)) (Complex x2 (R + 1))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>R \\<ge> 1\\<close>"], ["proof (prove)\nusing this:\n  \\<lbrakk>- R - 1 \\<le> R + 1;\n   \\<And>x1 x2.\n      \\<lbrakk>x1 < 0; 0 < x2;\n       (\\<lambda>z. f (w + z)) analytic_on\n       cbox (Complex x1 (- R - 1)) (Complex x2 (R + 1))\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  1 \\<le> R\n\ngoal (1 subgoal):\n 1. (\\<And>x1 x2.\n        \\<lbrakk>x1 < 0; 0 < x2;\n         (\\<lambda>z. f (w + z)) analytic_on\n         cbox (Complex x1 (- R - 1)) (Complex x2 (R + 1))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  x1 < 0\n  0 < x2\n  (\\<lambda>z. f (w + z)) analytic_on\n  cbox (Complex x1 (- R - 1)) (Complex x2 (R + 1))\n\ngoal (1 subgoal):\n 1. (\\<And>l.\n        \\<lbrakk>0 < l;\n         (\\<lambda>z. f (w + z)) analytic_on\n         {s. 0 < Re s \\<or>\n             Im s \\<in> {- R - 1<..<R + 1} \\<and> - l < Re s}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from this(3)"], ["proof (chain)\npicking this:\n  (\\<lambda>z. f (w + z)) analytic_on\n  cbox (Complex x1 (- R - 1)) (Complex x2 (R + 1))", "have \"(\\<lambda>z. f (w + z)) analytic_on {s. Re s \\<in> {x1..0} \\<and> Im s \\<in> {-R-1..R+1}}\""], ["proof (prove)\nusing this:\n  (\\<lambda>z. f (w + z)) analytic_on\n  cbox (Complex x1 (- R - 1)) (Complex x2 (R + 1))\n\ngoal (1 subgoal):\n 1. (\\<lambda>z. f (w + z)) analytic_on\n    {s. Re s \\<in> {x1..0} \\<and> Im s \\<in> {- R - 1..R + 1}}", "by (rule analytic_on_subset) (insert x12, auto simp: in_cbox_complex_iff)"], ["proof (state)\nthis:\n  (\\<lambda>z. f (w + z)) analytic_on\n  {s. Re s \\<in> {x1..0} \\<and> Im s \\<in> {- R - 1..R + 1}}\n\ngoal (1 subgoal):\n 1. (\\<And>l.\n        \\<lbrakk>0 < l;\n         (\\<lambda>z. f (w + z)) analytic_on\n         {s. 0 < Re s \\<or>\n             Im s \\<in> {- R - 1<..<R + 1} \\<and> - l < Re s}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "with f_analytic'"], ["proof (chain)\npicking this:\n  (\\<lambda>z. f (w + z)) analytic_on {s. 0 \\<le> Re s}\n  (\\<lambda>z. f (w + z)) analytic_on\n  {s. Re s \\<in> {x1..0} \\<and> Im s \\<in> {- R - 1..R + 1}}", "have \"(\\<lambda>z. f (w + z)) analytic_on\n                               ({s. Re s \\<ge> 0} \\<union> {s. Re s \\<in> {x1..0} \\<and> Im s \\<in> {-R-1..R+1}})\""], ["proof (prove)\nusing this:\n  (\\<lambda>z. f (w + z)) analytic_on {s. 0 \\<le> Re s}\n  (\\<lambda>z. f (w + z)) analytic_on\n  {s. Re s \\<in> {x1..0} \\<and> Im s \\<in> {- R - 1..R + 1}}\n\ngoal (1 subgoal):\n 1. (\\<lambda>z. f (w + z)) analytic_on\n    {s. 0 \\<le> Re s} \\<union>\n    {s. Re s \\<in> {x1..0} \\<and> Im s \\<in> {- R - 1..R + 1}}", "by (subst analytic_on_Un) auto"], ["proof (state)\nthis:\n  (\\<lambda>z. f (w + z)) analytic_on\n  {s. 0 \\<le> Re s} \\<union>\n  {s. Re s \\<in> {x1..0} \\<and> Im s \\<in> {- R - 1..R + 1}}\n\ngoal (1 subgoal):\n 1. (\\<And>l.\n        \\<lbrakk>0 < l;\n         (\\<lambda>z. f (w + z)) analytic_on\n         {s. 0 < Re s \\<or>\n             Im s \\<in> {- R - 1<..<R + 1} \\<and> - l < Re s}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "hence \"(\\<lambda>z. f (w + z)) analytic_on {s. Re s > 0 \\<or> Im s \\<in> {-R-1<..<R+1} \\<and> Re s > x1}\""], ["proof (prove)\nusing this:\n  (\\<lambda>z. f (w + z)) analytic_on\n  {s. 0 \\<le> Re s} \\<union>\n  {s. Re s \\<in> {x1..0} \\<and> Im s \\<in> {- R - 1..R + 1}}\n\ngoal (1 subgoal):\n 1. (\\<lambda>z. f (w + z)) analytic_on\n    {s. 0 < Re s \\<or> Im s \\<in> {- R - 1<..<R + 1} \\<and> x1 < Re s}", "by (rule analytic_on_subset) auto"], ["proof (state)\nthis:\n  (\\<lambda>z. f (w + z)) analytic_on\n  {s. 0 < Re s \\<or> Im s \\<in> {- R - 1<..<R + 1} \\<and> x1 < Re s}\n\ngoal (1 subgoal):\n 1. (\\<And>l.\n        \\<lbrakk>0 < l;\n         (\\<lambda>z. f (w + z)) analytic_on\n         {s. 0 < Re s \\<or>\n             Im s \\<in> {- R - 1<..<R + 1} \\<and> - l < Re s}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "with \\<open>x1 < 0\\<close> and that[of \"-x1\"]"], ["proof (chain)\npicking this:\n  x1 < 0\n  \\<lbrakk>0 < - x1;\n   (\\<lambda>z. f (w + z)) analytic_on\n   {s. 0 < Re s \\<or>\n       Im s \\<in> {- R - 1<..<R + 1} \\<and> - (- x1) < Re s}\\<rbrakk>\n  \\<Longrightarrow> thesis\n  (\\<lambda>z. f (w + z)) analytic_on\n  {s. 0 < Re s \\<or> Im s \\<in> {- R - 1<..<R + 1} \\<and> x1 < Re s}", "show ?thesis"], ["proof (prove)\nusing this:\n  x1 < 0\n  \\<lbrakk>0 < - x1;\n   (\\<lambda>z. f (w + z)) analytic_on\n   {s. 0 < Re s \\<or>\n       Im s \\<in> {- R - 1<..<R + 1} \\<and> - (- x1) < Re s}\\<rbrakk>\n  \\<Longrightarrow> thesis\n  (\\<lambda>z. f (w + z)) analytic_on\n  {s. 0 < Re s \\<or> Im s \\<in> {- R - 1<..<R + 1} \\<and> x1 < Re s}\n\ngoal (1 subgoal):\n 1. thesis", "by auto"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed\n\n    \\<comment> \\<open>The function \\<open>f (w + z)\\<close> is now analytic on the open box $(-l; R+1) + i(-R+1; R+1)$.\n        We call this region \\<open>X\\<close>.\\<close>"], ["proof (state)\nthis:\n  0 < l\n  (\\<lambda>z. f (w + z)) analytic_on\n  {s. 0 < Re s \\<or> Im s \\<in> {- R - 1<..<R + 1} \\<and> - l < Re s}\n\ngoal (1 subgoal):\n 1. \\<And>e.\n       0 < e \\<Longrightarrow>\n       \\<forall>\\<^sub>F x in sequentially.\n          cmod (f w - eval_fds (fds_truncate x F) w) < e", "define X where \"X = box (Complex (-l) (-R-1)) (Complex (R+1) (R+1))\""], ["proof (state)\nthis:\n  X = box (Complex (- l) (- R - 1)) (Complex (R + 1) (R + 1))\n\ngoal (1 subgoal):\n 1. \\<And>e.\n       0 < e \\<Longrightarrow>\n       \\<forall>\\<^sub>F x in sequentially.\n          cmod (f w - eval_fds (fds_truncate x F) w) < e", "have [simp, intro]: \"open X\" \"convex X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. open X &&& convex X", "by (simp_all add: X_def open_box)"], ["proof (state)\nthis:\n  open X\n  convex X\n\ngoal (1 subgoal):\n 1. \\<And>e.\n       0 < e \\<Longrightarrow>\n       \\<forall>\\<^sub>F x in sequentially.\n          cmod (f w - eval_fds (fds_truncate x F) w) < e", "from R l"], ["proof (chain)\npicking this:\n  3 * C / \\<epsilon> \\<le> R\n  1 \\<le> R\n  0 < l\n  (\\<lambda>z. f (w + z)) analytic_on\n  {s. 0 < Re s \\<or> Im s \\<in> {- R - 1<..<R + 1} \\<and> - l < Re s}", "have [simp]: \"0 \\<in> X\""], ["proof (prove)\nusing this:\n  3 * C / \\<epsilon> \\<le> R\n  1 \\<le> R\n  0 < l\n  (\\<lambda>z. f (w + z)) analytic_on\n  {s. 0 < Re s \\<or> Im s \\<in> {- R - 1<..<R + 1} \\<and> - l < Re s}\n\ngoal (1 subgoal):\n 1. 0 \\<in> X", "by (auto simp: X_def in_box_complex_iff)"], ["proof (state)\nthis:\n  0 \\<in> X\n\ngoal (1 subgoal):\n 1. \\<And>e.\n       0 < e \\<Longrightarrow>\n       \\<forall>\\<^sub>F x in sequentially.\n          cmod (f w - eval_fds (fds_truncate x F) w) < e", "have analytic: \"(\\<lambda>z. f (w + z)) analytic_on X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>z. f (w + z)) analytic_on X", "by (rule analytic_on_subset[OF l(2)]) (auto simp: X_def in_box_complex_iff)"], ["proof (state)\nthis:\n  (\\<lambda>z. f (w + z)) analytic_on X\n\ngoal (1 subgoal):\n 1. \\<And>e.\n       0 < e \\<Longrightarrow>\n       \\<forall>\\<^sub>F x in sequentially.\n          cmod (f w - eval_fds (fds_truncate x F) w) < e", "note f_analytic' [analytic_intros] = analytic_on_compose_gen[OF _ analytic, unfolded o_def]"], ["proof (state)\nthis:\n  \\<lbrakk>?f analytic_on ?S;\n   \\<And>z. z \\<in> ?S \\<Longrightarrow> ?f z \\<in> X\\<rbrakk>\n  \\<Longrightarrow> (\\<lambda>x. f (w + ?f x)) analytic_on ?S\n\ngoal (1 subgoal):\n 1. \\<And>e.\n       0 < e \\<Longrightarrow>\n       \\<forall>\\<^sub>F x in sequentially.\n          cmod (f w - eval_fds (fds_truncate x F) w) < e", "note f_holo [holomorphic_intros] =\n      holomorphic_on_compose_gen[OF _ analytic_imp_holomorphic[OF analytic], unfolded o_def]"], ["proof (state)\nthis:\n  \\<lbrakk>?f holomorphic_on ?s; ?f ` ?s \\<subseteq> X\\<rbrakk>\n  \\<Longrightarrow> (\\<lambda>x. f (w + ?f x)) holomorphic_on ?s\n\ngoal (1 subgoal):\n 1. \\<And>e.\n       0 < e \\<Longrightarrow>\n       \\<forall>\\<^sub>F x in sequentially.\n          cmod (f w - eval_fds (fds_truncate x F) w) < e", "note f_cont [continuous_intros] = continuous_on_compose2[OF \n      holomorphic_on_imp_continuous_on[OF analytic_imp_holomorphic[OF analytic]]]\n\n    \\<comment> \\<open>We now pick a smaller closed box \\<open>X'\\<close> inside the big open box \\<open>X\\<close>. This is because\n        we need a compact set for the next step. our integration path still lies entirely\n        within \\<open>X'\\<close>, and since \\<open>X'\\<close> is compact, \\<open>f (w + z)\\<close> is bounded on it,\n        so we obtain such a bound and call it \\<open>M\\<close>.\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>continuous_on ?s ?f; ?f ` ?s \\<subseteq> X\\<rbrakk>\n  \\<Longrightarrow> continuous_on ?s (\\<lambda>x. f (w + ?f x))\n\ngoal (1 subgoal):\n 1. \\<And>e.\n       0 < e \\<Longrightarrow>\n       \\<forall>\\<^sub>F x in sequentially.\n          cmod (f w - eval_fds (fds_truncate x F) w) < e", "define \\<delta> where \"\\<delta> = min (1/2) (l/2)\""], ["proof (state)\nthis:\n  \\<delta> = min (1 / 2) (l / 2)\n\ngoal (1 subgoal):\n 1. \\<And>e.\n       0 < e \\<Longrightarrow>\n       \\<forall>\\<^sub>F x in sequentially.\n          cmod (f w - eval_fds (fds_truncate x F) w) < e", "from l"], ["proof (chain)\npicking this:\n  0 < l\n  (\\<lambda>z. f (w + z)) analytic_on\n  {s. 0 < Re s \\<or> Im s \\<in> {- R - 1<..<R + 1} \\<and> - l < Re s}", "have \\<delta>: \"\\<delta> > 0\" \"\\<delta> \\<le> 1/2\" \"\\<delta> < l\""], ["proof (prove)\nusing this:\n  0 < l\n  (\\<lambda>z. f (w + z)) analytic_on\n  {s. 0 < Re s \\<or> Im s \\<in> {- R - 1<..<R + 1} \\<and> - l < Re s}\n\ngoal (1 subgoal):\n 1. 0 < \\<delta> &&& \\<delta> \\<le> 1 / 2 &&& \\<delta> < l", "by (auto simp: \\<delta>_def)"], ["proof (state)\nthis:\n  0 < \\<delta>\n  \\<delta> \\<le> 1 / 2\n  \\<delta> < l\n\ngoal (1 subgoal):\n 1. \\<And>e.\n       0 < e \\<Longrightarrow>\n       \\<forall>\\<^sub>F x in sequentially.\n          cmod (f w - eval_fds (fds_truncate x F) w) < e", "define X' where \"X' = cbox (Complex (-\\<delta>) (-R)) (Complex R R)\""], ["proof (state)\nthis:\n  X' = cbox (Complex (- \\<delta>) (- R)) (Complex R R)\n\ngoal (1 subgoal):\n 1. \\<And>e.\n       0 < e \\<Longrightarrow>\n       \\<forall>\\<^sub>F x in sequentially.\n          cmod (f w - eval_fds (fds_truncate x F) w) < e", "have \"X' \\<subseteq> X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X' \\<subseteq> X", "unfolding X'_def X_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. cbox (Complex (- \\<delta>) (- R)) (Complex R R)\n    \\<subseteq> box (Complex (- l) (- R - 1)) (Complex (R + 1) (R + 1))", "using l(1) R \\<delta>"], ["proof (prove)\nusing this:\n  0 < l\n  3 * C / \\<epsilon> \\<le> R\n  1 \\<le> R\n  0 < \\<delta>\n  \\<delta> \\<le> 1 / 2\n  \\<delta> < l\n\ngoal (1 subgoal):\n 1. cbox (Complex (- \\<delta>) (- R)) (Complex R R)\n    \\<subseteq> box (Complex (- l) (- R - 1)) (Complex (R + 1) (R + 1))", "by (intro subset_box_imp) (auto simp: Basis_complex_def)"], ["proof (state)\nthis:\n  X' \\<subseteq> X\n\ngoal (1 subgoal):\n 1. \\<And>e.\n       0 < e \\<Longrightarrow>\n       \\<forall>\\<^sub>F x in sequentially.\n          cmod (f w - eval_fds (fds_truncate x F) w) < e", "have [intro]: \"compact X'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. compact X'", "by (simp add: X'_def)"], ["proof (state)\nthis:\n  compact X'\n\ngoal (1 subgoal):\n 1. \\<And>e.\n       0 < e \\<Longrightarrow>\n       \\<forall>\\<^sub>F x in sequentially.\n          cmod (f w - eval_fds (fds_truncate x F) w) < e", "moreover"], ["proof (state)\nthis:\n  compact X'\n\ngoal (1 subgoal):\n 1. \\<And>e.\n       0 < e \\<Longrightarrow>\n       \\<forall>\\<^sub>F x in sequentially.\n          cmod (f w - eval_fds (fds_truncate x F) w) < e", "have \"continuous_on X' (\\<lambda>z. f (w + z))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_on X' (\\<lambda>z. f (w + z))", "using w \\<open>X' \\<subseteq> X\\<close>"], ["proof (prove)\nusing this:\n  1 \\<le> Re w\n  X' \\<subseteq> X\n\ngoal (1 subgoal):\n 1. continuous_on X' (\\<lambda>z. f (w + z))", "by (auto intro!: continuous_intros)"], ["proof (state)\nthis:\n  continuous_on X' (\\<lambda>z. f (w + z))\n\ngoal (1 subgoal):\n 1. \\<And>e.\n       0 < e \\<Longrightarrow>\n       \\<forall>\\<^sub>F x in sequentially.\n          cmod (f w - eval_fds (fds_truncate x F) w) < e", "ultimately"], ["proof (chain)\npicking this:\n  compact X'\n  continuous_on X' (\\<lambda>z. f (w + z))", "obtain M where M: \"M \\<ge> 0\" \"\\<And>z. z \\<in> X' \\<Longrightarrow> norm (f (w + z)) \\<le> M\""], ["proof (prove)\nusing this:\n  compact X'\n  continuous_on X' (\\<lambda>z. f (w + z))\n\ngoal (1 subgoal):\n 1. (\\<And>M.\n        \\<lbrakk>0 \\<le> M;\n         \\<And>z.\n            z \\<in> X' \\<Longrightarrow> cmod (f (w + z)) \\<le> M\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using continuous_on_compact_bound"], ["proof (prove)\nusing this:\n  compact X'\n  continuous_on X' (\\<lambda>z. f (w + z))\n  \\<lbrakk>compact ?A; continuous_on ?A ?f;\n   \\<And>B.\n      \\<lbrakk>0 \\<le> B;\n       \\<And>x. x \\<in> ?A \\<Longrightarrow> norm (?f x) \\<le> B\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>M.\n        \\<lbrakk>0 \\<le> M;\n         \\<And>z.\n            z \\<in> X' \\<Longrightarrow> cmod (f (w + z)) \\<le> M\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast\n\n    \\<comment> \\<open>Our objective is now to show that the difference between the \\<open>N\\<close>-th partial sum\n        and the limit is below a certain bound (depending on \\<open>N\\<close>) which tends to \\<open>0\\<close> \n        for \\<open>N \\<rightarrow> \\<infinity>\\<close>. We use the following bound:\\<close>"], ["proof (state)\nthis:\n  0 \\<le> M\n  ?z \\<in> X' \\<Longrightarrow> cmod (f (w + ?z)) \\<le> M\n\ngoal (1 subgoal):\n 1. \\<And>e.\n       0 < e \\<Longrightarrow>\n       \\<forall>\\<^sub>F x in sequentially.\n          cmod (f w - eval_fds (fds_truncate x F) w) < e", "define bound where\n      \"bound = (\\<lambda>N::nat. (2*C/R + C/N + 3*M / (pi*R*ln N) + 3*R*M / (\\<delta>*pi * N powr \\<delta>)))\""], ["proof (state)\nthis:\n  bound =\n  (\\<lambda>x.\n      2 * C / R + C / real x + 3 * M / (pi * R * ln (real x)) +\n      3 * R * M / (\\<delta> * pi * real x powr \\<delta>))\n\ngoal (1 subgoal):\n 1. \\<And>e.\n       0 < e \\<Longrightarrow>\n       \\<forall>\\<^sub>F x in sequentially.\n          cmod (f w - eval_fds (fds_truncate x F) w) < e", "have \"2 * C / R < \\<epsilon>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * C / R < \\<epsilon>", "using M(1) R C(1) \\<delta>(1) \\<epsilon>"], ["proof (prove)\nusing this:\n  0 \\<le> M\n  3 * C / \\<epsilon> \\<le> R\n  1 \\<le> R\n  1 \\<le> C\n  0 < \\<delta>\n  0 < \\<epsilon>\n\ngoal (1 subgoal):\n 1. 2 * C / R < \\<epsilon>", "by (auto simp: field_simps)\n    \\<comment> \\<open>Evidently this is below @{term \\<epsilon>} for sufficiently large \\<open>N\\<close>.\\<close>"], ["proof (state)\nthis:\n  2 * C / R < \\<epsilon>\n\ngoal (1 subgoal):\n 1. \\<And>e.\n       0 < e \\<Longrightarrow>\n       \\<forall>\\<^sub>F x in sequentially.\n          cmod (f w - eval_fds (fds_truncate x F) w) < e", "hence \"eventually (\\<lambda>N::nat. bound N < \\<epsilon>) at_top\""], ["proof (prove)\nusing this:\n  2 * C / R < \\<epsilon>\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F N in sequentially. bound N < \\<epsilon>", "using M(1) R C(1) \\<delta>(1) \\<epsilon>"], ["proof (prove)\nusing this:\n  2 * C / R < \\<epsilon>\n  0 \\<le> M\n  3 * C / \\<epsilon> \\<le> R\n  1 \\<le> R\n  1 \\<le> C\n  0 < \\<delta>\n  0 < \\<epsilon>\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F N in sequentially. bound N < \\<epsilon>", "unfolding bound_def"], ["proof (prove)\nusing this:\n  2 * C / R < \\<epsilon>\n  0 \\<le> M\n  3 * C / \\<epsilon> \\<le> R\n  1 \\<le> R\n  1 \\<le> C\n  0 < \\<delta>\n  0 < \\<epsilon>\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F N in sequentially.\n       2 * C / R + C / real N + 3 * M / (pi * R * ln (real N)) +\n       3 * R * M / (\\<delta> * pi * real N powr \\<delta>)\n       < \\<epsilon>", "by real_asymp\n\n    \\<comment> \\<open>It now only remains to show that the difference is indeed less than the claimed bound.\\<close>"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F N in sequentially. bound N < \\<epsilon>\n\ngoal (1 subgoal):\n 1. \\<And>e.\n       0 < e \\<Longrightarrow>\n       \\<forall>\\<^sub>F x in sequentially.\n          cmod (f w - eval_fds (fds_truncate x F) w) < e", "thus \"eventually (\\<lambda>N. norm (f w - eval_fds (fds_truncate N F) w) < \\<epsilon>) at_top\""], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F N in sequentially. bound N < \\<epsilon>\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F N in sequentially.\n       cmod (f w - eval_fds (fds_truncate N F) w) < \\<epsilon>", "using eventually_gt_at_top[of 1]"], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F N in sequentially. bound N < \\<epsilon>\n  eventually ((<) (1::?'a1)) at_top\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F N in sequentially.\n       cmod (f w - eval_fds (fds_truncate N F) w) < \\<epsilon>", "proof eventually_elim"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>N.\n       \\<lbrakk>bound N < \\<epsilon>; 1 < N\\<rbrakk>\n       \\<Longrightarrow> cmod (f w - eval_fds (fds_truncate N F) w)\n                         < \\<epsilon>", "case (elim N)"], ["proof (state)\nthis:\n  bound N < \\<epsilon>\n  1 < N\n\ngoal (1 subgoal):\n 1. \\<And>N.\n       \\<lbrakk>bound N < \\<epsilon>; 1 < N\\<rbrakk>\n       \\<Longrightarrow> cmod (f w - eval_fds (fds_truncate N F) w)\n                         < \\<epsilon>", "note N = this\n\n      \\<comment> \\<open>Like Harrison (and unlike Newman), our integration path \\<open>\\<Gamma>\\<close> consists of a semicircle \\<open>A\\<close>\n          of radius \\<open>R\\<close> in the right-halfplane and a box of width \\<open>\\<delta>\\<close> and height \\<open>2R\\<close> on\n          the left halfplane. The latter consists of three straight lines, which we call \\<open>B1\\<close>\n          to \\<open>B3\\<close>.\\<close>"], ["proof (state)\nthis:\n  bound N < \\<epsilon>\n  1 < N\n\ngoal (1 subgoal):\n 1. \\<And>N.\n       \\<lbrakk>bound N < \\<epsilon>; 1 < N\\<rbrakk>\n       \\<Longrightarrow> cmod (f w - eval_fds (fds_truncate N F) w)\n                         < \\<epsilon>", "define A where \"A = part_circlepath 0 R (-pi/2) (pi/2)\""], ["proof (state)\nthis:\n  A = part_circlepath 0 R (- pi / 2) (pi / 2)\n\ngoal (1 subgoal):\n 1. \\<And>N.\n       \\<lbrakk>bound N < \\<epsilon>; 1 < N\\<rbrakk>\n       \\<Longrightarrow> cmod (f w - eval_fds (fds_truncate N F) w)\n                         < \\<epsilon>", "define B2 where \"B2 = linepath (Complex (-\\<delta>) R) (Complex (-\\<delta>) (-R))\""], ["proof (state)\nthis:\n  B2 = linepath (Complex (- \\<delta>) R) (Complex (- \\<delta>) (- R))\n\ngoal (1 subgoal):\n 1. \\<And>N.\n       \\<lbrakk>bound N < \\<epsilon>; 1 < N\\<rbrakk>\n       \\<Longrightarrow> cmod (f w - eval_fds (fds_truncate N F) w)\n                         < \\<epsilon>", "define B1 where \"B1 = linepath (R * \\<i>) (R * \\<i> - \\<delta>)\""], ["proof (state)\nthis:\n  B1 =\n  linepath (complex_of_real R * \\<i>)\n   (complex_of_real R * \\<i> - complex_of_real \\<delta>)\n\ngoal (1 subgoal):\n 1. \\<And>N.\n       \\<lbrakk>bound N < \\<epsilon>; 1 < N\\<rbrakk>\n       \\<Longrightarrow> cmod (f w - eval_fds (fds_truncate N F) w)\n                         < \\<epsilon>", "define B3 where \"B3 = linepath (-R * \\<i> - \\<delta>) (-R * \\<i>)\""], ["proof (state)\nthis:\n  B3 =\n  linepath (complex_of_real (- R) * \\<i> - complex_of_real \\<delta>)\n   (complex_of_real (- R) * \\<i>)\n\ngoal (1 subgoal):\n 1. \\<And>N.\n       \\<lbrakk>bound N < \\<epsilon>; 1 < N\\<rbrakk>\n       \\<Longrightarrow> cmod (f w - eval_fds (fds_truncate N F) w)\n                         < \\<epsilon>", "define \\<Gamma> where \"\\<Gamma> = A +++ B1 +++ B2 +++ B3\"\n\n      \\<comment> \\<open>We first need to show some basic facts about the geometry of our integration path.\\<close>"], ["proof (state)\nthis:\n  \\<Gamma> = A +++ B1 +++ B2 +++ B3\n\ngoal (1 subgoal):\n 1. \\<And>N.\n       \\<lbrakk>bound N < \\<epsilon>; 1 < N\\<rbrakk>\n       \\<Longrightarrow> cmod (f w - eval_fds (fds_truncate N F) w)\n                         < \\<epsilon>", "have [simp, intro]:\n        \"path A\" \"path B1\" \"path B3\" \"path B2\"\n        \"valid_path A\" \"valid_path B1\" \"valid_path B3\" \"valid_path B2\"\n        \"arc A\" \"arc B1\" \"arc B3\" \"arc B2\"\n        \"pathstart A = -\\<i> * R\" \"pathfinish A = \\<i> * R\"\n        \"pathstart B1 = \\<i> * R\" \"pathfinish B1 = R * \\<i> - \\<delta>\"\n        \"pathstart B3 = -R * \\<i> - \\<delta>\" \"pathfinish B3 = -\\<i> * R\"\n        \"pathstart B2 = R * \\<i> - \\<delta>\" \"pathfinish B2 = -R * \\<i> - \\<delta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (((path A &&& path B1) &&& path B3 &&& path B2 &&& valid_path A) &&&\n     (valid_path B1 &&& valid_path B3) &&&\n     valid_path B2 &&& arc A &&& arc B1) &&&\n    ((arc B3 &&& arc B2) &&&\n     pathstart A = - \\<i> * complex_of_real R &&&\n     pathfinish A = \\<i> * complex_of_real R &&&\n     pathstart B1 = \\<i> * complex_of_real R) &&&\n    (pathfinish B1 = complex_of_real R * \\<i> - complex_of_real \\<delta> &&&\n     pathstart B3 =\n     complex_of_real (- R) * \\<i> - complex_of_real \\<delta>) &&&\n    pathfinish B3 = - \\<i> * complex_of_real R &&&\n    pathstart B2 = complex_of_real R * \\<i> - complex_of_real \\<delta> &&&\n    pathfinish B2 = complex_of_real (- R) * \\<i> - complex_of_real \\<delta>", "using R \\<delta>"], ["proof (prove)\nusing this:\n  3 * C / \\<epsilon> \\<le> R\n  1 \\<le> R\n  0 < \\<delta>\n  \\<delta> \\<le> 1 / 2\n  \\<delta> < l\n\ngoal (1 subgoal):\n 1. (((path A &&& path B1) &&& path B3 &&& path B2 &&& valid_path A) &&&\n     (valid_path B1 &&& valid_path B3) &&&\n     valid_path B2 &&& arc A &&& arc B1) &&&\n    ((arc B3 &&& arc B2) &&&\n     pathstart A = - \\<i> * complex_of_real R &&&\n     pathfinish A = \\<i> * complex_of_real R &&&\n     pathstart B1 = \\<i> * complex_of_real R) &&&\n    (pathfinish B1 = complex_of_real R * \\<i> - complex_of_real \\<delta> &&&\n     pathstart B3 =\n     complex_of_real (- R) * \\<i> - complex_of_real \\<delta>) &&&\n    pathfinish B3 = - \\<i> * complex_of_real R &&&\n    pathstart B2 = complex_of_real R * \\<i> - complex_of_real \\<delta> &&&\n    pathfinish B2 = complex_of_real (- R) * \\<i> - complex_of_real \\<delta>", "by (simp_all add: A_def B1_def B3_def exp_eq_polar B2_def Complex_eq arc_part_circlepath)"], ["proof (state)\nthis:\n  path A\n  path B1\n  path B3\n  path B2\n  valid_path A\n  valid_path B1\n  valid_path B3\n  valid_path B2\n  arc A\n  arc B1\n  arc B3\n  arc B2\n  pathstart A = - \\<i> * complex_of_real R\n  pathfinish A = \\<i> * complex_of_real R\n  pathstart B1 = \\<i> * complex_of_real R\n  pathfinish B1 = complex_of_real R * \\<i> - complex_of_real \\<delta>\n  pathstart B3 = complex_of_real (- R) * \\<i> - complex_of_real \\<delta>\n  pathfinish B3 = - \\<i> * complex_of_real R\n  pathstart B2 = complex_of_real R * \\<i> - complex_of_real \\<delta>\n  pathfinish B2 = complex_of_real (- R) * \\<i> - complex_of_real \\<delta>\n\ngoal (1 subgoal):\n 1. \\<And>N.\n       \\<lbrakk>bound N < \\<epsilon>; 1 < N\\<rbrakk>\n       \\<Longrightarrow> cmod (f w - eval_fds (fds_truncate N F) w)\n                         < \\<epsilon>", "hence [simp, intro]: \"valid_path \\<Gamma>\""], ["proof (prove)\nusing this:\n  path A\n  path B1\n  path B3\n  path B2\n  valid_path A\n  valid_path B1\n  valid_path B3\n  valid_path B2\n  arc A\n  arc B1\n  arc B3\n  arc B2\n  pathstart A = - \\<i> * complex_of_real R\n  pathfinish A = \\<i> * complex_of_real R\n  pathstart B1 = \\<i> * complex_of_real R\n  pathfinish B1 = complex_of_real R * \\<i> - complex_of_real \\<delta>\n  pathstart B3 = complex_of_real (- R) * \\<i> - complex_of_real \\<delta>\n  pathfinish B3 = - \\<i> * complex_of_real R\n  pathstart B2 = complex_of_real R * \\<i> - complex_of_real \\<delta>\n  pathfinish B2 = complex_of_real (- R) * \\<i> - complex_of_real \\<delta>\n\ngoal (1 subgoal):\n 1. valid_path \\<Gamma>", "by (simp add: \\<Gamma>_def A_def B1_def B3_def B2_def exp_eq_polar Complex_eq)"], ["proof (state)\nthis:\n  valid_path \\<Gamma>\n\ngoal (1 subgoal):\n 1. \\<And>N.\n       \\<lbrakk>bound N < \\<epsilon>; 1 < N\\<rbrakk>\n       \\<Longrightarrow> cmod (f w - eval_fds (fds_truncate N F) w)\n                         < \\<epsilon>", "hence [simp, intro]: \"path \\<Gamma>\""], ["proof (prove)\nusing this:\n  valid_path \\<Gamma>\n\ngoal (1 subgoal):\n 1. path \\<Gamma>", "using valid_path_imp_path"], ["proof (prove)\nusing this:\n  valid_path \\<Gamma>\n  valid_path ?g \\<Longrightarrow> path ?g\n\ngoal (1 subgoal):\n 1. path \\<Gamma>", "by blast"], ["proof (state)\nthis:\n  path \\<Gamma>\n\ngoal (1 subgoal):\n 1. \\<And>N.\n       \\<lbrakk>bound N < \\<epsilon>; 1 < N\\<rbrakk>\n       \\<Longrightarrow> cmod (f w - eval_fds (fds_truncate N F) w)\n                         < \\<epsilon>", "have [simp]: \"pathfinish \\<Gamma> = pathstart \\<Gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pathfinish \\<Gamma> = pathstart \\<Gamma>", "by (simp add: \\<Gamma>_def exp_eq_polar)"], ["proof (state)\nthis:\n  pathfinish \\<Gamma> = pathstart \\<Gamma>\n\ngoal (1 subgoal):\n 1. \\<And>N.\n       \\<lbrakk>bound N < \\<epsilon>; 1 < N\\<rbrakk>\n       \\<Longrightarrow> cmod (f w - eval_fds (fds_truncate N F) w)\n                         < \\<epsilon>", "have image_B2: \"path_image B2 = {s. Re s = -\\<delta> \\<and> Im s \\<in> {-R..R}}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path_image B2 = {s. Re s = - \\<delta> \\<and> Im s \\<in> {- R..R}}", "using R"], ["proof (prove)\nusing this:\n  3 * C / \\<epsilon> \\<le> R\n  1 \\<le> R\n\ngoal (1 subgoal):\n 1. path_image B2 = {s. Re s = - \\<delta> \\<and> Im s \\<in> {- R..R}}", "by (auto simp: closed_segment_same_Re closed_segment_eq_real_ivl B2_def)"], ["proof (state)\nthis:\n  path_image B2 = {s. Re s = - \\<delta> \\<and> Im s \\<in> {- R..R}}\n\ngoal (1 subgoal):\n 1. \\<And>N.\n       \\<lbrakk>bound N < \\<epsilon>; 1 < N\\<rbrakk>\n       \\<Longrightarrow> cmod (f w - eval_fds (fds_truncate N F) w)\n                         < \\<epsilon>", "have image_B1: \"path_image B1 = {s. Re s \\<in> {-\\<delta>..0} \\<and> Im s = R}\"\n       and image_B3: \"path_image B3 = {s. Re s \\<in> {-\\<delta>..0} \\<and> Im s = -R}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path_image B1 = {s. Re s \\<in> {- \\<delta>..0} \\<and> Im s = R} &&&\n    path_image B3 = {s. Re s \\<in> {- \\<delta>..0} \\<and> Im s = - R}", "using \\<delta>"], ["proof (prove)\nusing this:\n  0 < \\<delta>\n  \\<delta> \\<le> 1 / 2\n  \\<delta> < l\n\ngoal (1 subgoal):\n 1. path_image B1 = {s. Re s \\<in> {- \\<delta>..0} \\<and> Im s = R} &&&\n    path_image B3 = {s. Re s \\<in> {- \\<delta>..0} \\<and> Im s = - R}", "by (auto simp: B1_def B3_def closed_segment_same_Im closed_segment_eq_real_ivl)"], ["proof (state)\nthis:\n  path_image B1 = {s. Re s \\<in> {- \\<delta>..0} \\<and> Im s = R}\n  path_image B3 = {s. Re s \\<in> {- \\<delta>..0} \\<and> Im s = - R}\n\ngoal (1 subgoal):\n 1. \\<And>N.\n       \\<lbrakk>bound N < \\<epsilon>; 1 < N\\<rbrakk>\n       \\<Longrightarrow> cmod (f w - eval_fds (fds_truncate N F) w)\n                         < \\<epsilon>", "have image_A: \"path_image A = {s. Re s \\<ge> 0 \\<and> norm s = R}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path_image A = {s. 0 \\<le> Re s \\<and> cmod s = R}", "unfolding A_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. path_image (part_circlepath 0 R (- pi / 2) (pi / 2)) =\n    {s. 0 \\<le> Re s \\<and> cmod s = R}", "using R"], ["proof (prove)\nusing this:\n  3 * C / \\<epsilon> \\<le> R\n  1 \\<le> R\n\ngoal (1 subgoal):\n 1. path_image (part_circlepath 0 R (- pi / 2) (pi / 2)) =\n    {s. 0 \\<le> Re s \\<and> cmod s = R}", "by (subst path_image_semicircle_Re_ge) auto"], ["proof (state)\nthis:\n  path_image A = {s. 0 \\<le> Re s \\<and> cmod s = R}\n\ngoal (1 subgoal):\n 1. \\<And>N.\n       \\<lbrakk>bound N < \\<epsilon>; 1 < N\\<rbrakk>\n       \\<Longrightarrow> cmod (f w - eval_fds (fds_truncate N F) w)\n                         < \\<epsilon>", "also"], ["proof (state)\nthis:\n  path_image A = {s. 0 \\<le> Re s \\<and> cmod s = R}\n\ngoal (1 subgoal):\n 1. \\<And>N.\n       \\<lbrakk>bound N < \\<epsilon>; 1 < N\\<rbrakk>\n       \\<Longrightarrow> cmod (f w - eval_fds (fds_truncate N F) w)\n                         < \\<epsilon>", "have \"z \\<in> \\<dots> \\<longrightarrow> z \\<in> X' - {0}\" for z"], ["proof (prove)\ngoal (1 subgoal):\n 1. z \\<in> {s. 0 \\<le> Re s \\<and> cmod s = R} \\<longrightarrow>\n    z \\<in> X' - {0}", "using complex_Re_le_cmod[of z] abs_Im_le_cmod[of z] \\<delta> R"], ["proof (prove)\nusing this:\n  Re z \\<le> cmod z\n  \\<bar>Im z\\<bar> \\<le> cmod z\n  0 < \\<delta>\n  \\<delta> \\<le> 1 / 2\n  \\<delta> < l\n  3 * C / \\<epsilon> \\<le> R\n  1 \\<le> R\n\ngoal (1 subgoal):\n 1. z \\<in> {s. 0 \\<le> Re s \\<and> cmod s = R} \\<longrightarrow>\n    z \\<in> X' - {0}", "by (auto simp: X'_def in_cbox_complex_iff)"], ["proof (state)\nthis:\n  ?z \\<in> {s. 0 \\<le> Re s \\<and> cmod s = R} \\<longrightarrow>\n  ?z \\<in> X' - {0}\n\ngoal (1 subgoal):\n 1. \\<And>N.\n       \\<lbrakk>bound N < \\<epsilon>; 1 < N\\<rbrakk>\n       \\<Longrightarrow> cmod (f w - eval_fds (fds_truncate N F) w)\n                         < \\<epsilon>", "hence \"{s. Re s \\<ge> 0 \\<and> norm s = R} \\<subseteq> X' - {0}\""], ["proof (prove)\nusing this:\n  ?z \\<in> {s. 0 \\<le> Re s \\<and> cmod s = R} \\<longrightarrow>\n  ?z \\<in> X' - {0}\n\ngoal (1 subgoal):\n 1. {s. 0 \\<le> Re s \\<and> cmod s = R} \\<subseteq> X' - {0}", "by auto"], ["proof (state)\nthis:\n  {s. 0 \\<le> Re s \\<and> cmod s = R} \\<subseteq> X' - {0}\n\ngoal (1 subgoal):\n 1. \\<And>N.\n       \\<lbrakk>bound N < \\<epsilon>; 1 < N\\<rbrakk>\n       \\<Longrightarrow> cmod (f w - eval_fds (fds_truncate N F) w)\n                         < \\<epsilon>", "finally"], ["proof (chain)\npicking this:\n  path_image A \\<subseteq> X' - {0}", "have \"path_image B2 \\<subseteq> X' - {0}\" \"path_image A \\<subseteq> X' - {0}\"\n           \"path_image B1 \\<subseteq> X' - {0}\" \"path_image B3 \\<subseteq> X' - {0}\""], ["proof (prove)\nusing this:\n  path_image A \\<subseteq> X' - {0}\n\ngoal (1 subgoal):\n 1. (path_image B2 \\<subseteq> X' - {0} &&&\n     path_image A \\<subseteq> X' - {0}) &&&\n    path_image B1 \\<subseteq> X' - {0} &&&\n    path_image B3 \\<subseteq> X' - {0}", "using \\<open>\\<delta> > 0\\<close>"], ["proof (prove)\nusing this:\n  path_image A \\<subseteq> X' - {0}\n  0 < \\<delta>\n\ngoal (1 subgoal):\n 1. (path_image B2 \\<subseteq> X' - {0} &&&\n     path_image A \\<subseteq> X' - {0}) &&&\n    path_image B1 \\<subseteq> X' - {0} &&&\n    path_image B3 \\<subseteq> X' - {0}", "by (auto simp: X'_def in_cbox_complex_iff image_B2 image_B1 image_B3)"], ["proof (state)\nthis:\n  path_image B2 \\<subseteq> X' - {0}\n  path_image A \\<subseteq> X' - {0}\n  path_image B1 \\<subseteq> X' - {0}\n  path_image B3 \\<subseteq> X' - {0}\n\ngoal (1 subgoal):\n 1. \\<And>N.\n       \\<lbrakk>bound N < \\<epsilon>; 1 < N\\<rbrakk>\n       \\<Longrightarrow> cmod (f w - eval_fds (fds_truncate N F) w)\n                         < \\<epsilon>", "note path_images = this \\<open>X' \\<subseteq> X\\<close>\n\n      \\<comment> \\<open>\\<open>\\<Gamma>\\<close> is a simple path, which, combined with its simple geometric shape, makes\n          reasoning about its winding numbers trivial.\\<close>"], ["proof (state)\nthis:\n  path_image B2 \\<subseteq> X' - {0}\n  path_image A \\<subseteq> X' - {0}\n  path_image B1 \\<subseteq> X' - {0}\n  path_image B3 \\<subseteq> X' - {0}\n  X' \\<subseteq> X\n\ngoal (1 subgoal):\n 1. \\<And>N.\n       \\<lbrakk>bound N < \\<epsilon>; 1 < N\\<rbrakk>\n       \\<Longrightarrow> cmod (f w - eval_fds (fds_truncate N F) w)\n                         < \\<epsilon>", "from R"], ["proof (chain)\npicking this:\n  3 * C / \\<epsilon> \\<le> R\n  1 \\<le> R", "have \"simple_path A\""], ["proof (prove)\nusing this:\n  3 * C / \\<epsilon> \\<le> R\n  1 \\<le> R\n\ngoal (1 subgoal):\n 1. simple_path A", "unfolding A_def"], ["proof (prove)\nusing this:\n  3 * C / \\<epsilon> \\<le> R\n  1 \\<le> R\n\ngoal (1 subgoal):\n 1. simple_path (part_circlepath 0 R (- pi / 2) (pi / 2))", "by (subst simple_path_part_circlepath) auto"], ["proof (state)\nthis:\n  simple_path A\n\ngoal (1 subgoal):\n 1. \\<And>N.\n       \\<lbrakk>bound N < \\<epsilon>; 1 < N\\<rbrakk>\n       \\<Longrightarrow> cmod (f w - eval_fds (fds_truncate N F) w)\n                         < \\<epsilon>", "have \"simple_path \\<Gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. simple_path \\<Gamma>", "unfolding \\<Gamma>_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. simple_path (A +++ B1 +++ B2 +++ B3)", "proof (intro simple_path_join_loop subsetI arc_join, goal_cases)"], ["proof (state)\ngoal (11 subgoals):\n 1. arc A\n 2. arc B1\n 3. arc B2\n 4. arc B3\n 5. pathfinish B2 = pathstart B3\n 6. \\<And>x.\n       x \\<in> path_image B2 \\<inter> path_image B3 \\<Longrightarrow>\n       x \\<in> {pathstart B3}\n 7. pathfinish B1 = pathstart (B2 +++ B3)\n 8. \\<And>x.\n       x \\<in> path_image B1 \\<inter>\n               path_image (B2 +++ B3) \\<Longrightarrow>\n       x \\<in> {pathstart (B2 +++ B3)}\n 9. pathfinish A = pathstart (B1 +++ B2 +++ B3)\n 10. pathfinish (B1 +++ B2 +++ B3) = pathstart A\nA total of 11 subgoals...", "fix z"], ["proof (state)\ngoal (11 subgoals):\n 1. arc A\n 2. arc B1\n 3. arc B2\n 4. arc B3\n 5. pathfinish B2 = pathstart B3\n 6. \\<And>x.\n       x \\<in> path_image B2 \\<inter> path_image B3 \\<Longrightarrow>\n       x \\<in> {pathstart B3}\n 7. pathfinish B1 = pathstart (B2 +++ B3)\n 8. \\<And>x.\n       x \\<in> path_image B1 \\<inter>\n               path_image (B2 +++ B3) \\<Longrightarrow>\n       x \\<in> {pathstart (B2 +++ B3)}\n 9. pathfinish A = pathstart (B1 +++ B2 +++ B3)\n 10. pathfinish (B1 +++ B2 +++ B3) = pathstart A\nA total of 11 subgoals...", "assume z: \"z \\<in> path_image A \\<inter> path_image (B1 +++ B2 +++ B3)\""], ["proof (state)\nthis:\n  z \\<in> path_image A \\<inter> path_image (B1 +++ B2 +++ B3)\n\ngoal (11 subgoals):\n 1. arc A\n 2. arc B1\n 3. arc B2\n 4. arc B3\n 5. pathfinish B2 = pathstart B3\n 6. \\<And>x.\n       x \\<in> path_image B2 \\<inter> path_image B3 \\<Longrightarrow>\n       x \\<in> {pathstart B3}\n 7. pathfinish B1 = pathstart (B2 +++ B3)\n 8. \\<And>x.\n       x \\<in> path_image B1 \\<inter>\n               path_image (B2 +++ B3) \\<Longrightarrow>\n       x \\<in> {pathstart (B2 +++ B3)}\n 9. pathfinish A = pathstart (B1 +++ B2 +++ B3)\n 10. pathfinish (B1 +++ B2 +++ B3) = pathstart A\nA total of 11 subgoals...", "with image_A"], ["proof (chain)\npicking this:\n  path_image A = {s. 0 \\<le> Re s \\<and> cmod s = R}\n  z \\<in> path_image A \\<inter> path_image (B1 +++ B2 +++ B3)", "have \"Re z \\<ge> 0\" \"norm z = R\""], ["proof (prove)\nusing this:\n  path_image A = {s. 0 \\<le> Re s \\<and> cmod s = R}\n  z \\<in> path_image A \\<inter> path_image (B1 +++ B2 +++ B3)\n\ngoal (1 subgoal):\n 1. 0 \\<le> Re z &&& cmod z = R", "by auto"], ["proof (state)\nthis:\n  0 \\<le> Re z\n  cmod z = R\n\ngoal (11 subgoals):\n 1. arc A\n 2. arc B1\n 3. arc B2\n 4. arc B3\n 5. pathfinish B2 = pathstart B3\n 6. \\<And>x.\n       x \\<in> path_image B2 \\<inter> path_image B3 \\<Longrightarrow>\n       x \\<in> {pathstart B3}\n 7. pathfinish B1 = pathstart (B2 +++ B3)\n 8. \\<And>x.\n       x \\<in> path_image B1 \\<inter>\n               path_image (B2 +++ B3) \\<Longrightarrow>\n       x \\<in> {pathstart (B2 +++ B3)}\n 9. pathfinish A = pathstart (B1 +++ B2 +++ B3)\n 10. pathfinish (B1 +++ B2 +++ B3) = pathstart A\nA total of 11 subgoals...", "with z R \\<delta>"], ["proof (chain)\npicking this:\n  z \\<in> path_image A \\<inter> path_image (B1 +++ B2 +++ B3)\n  3 * C / \\<epsilon> \\<le> R\n  1 \\<le> R\n  0 < \\<delta>\n  \\<delta> \\<le> 1 / 2\n  \\<delta> < l\n  0 \\<le> Re z\n  cmod z = R", "show \"z \\<in> {pathstart A, pathstart (B1 +++ B2 +++ B3)}\""], ["proof (prove)\nusing this:\n  z \\<in> path_image A \\<inter> path_image (B1 +++ B2 +++ B3)\n  3 * C / \\<epsilon> \\<le> R\n  1 \\<le> R\n  0 < \\<delta>\n  \\<delta> \\<le> 1 / 2\n  \\<delta> < l\n  0 \\<le> Re z\n  cmod z = R\n\ngoal (1 subgoal):\n 1. z \\<in> {pathstart A, pathstart (B1 +++ B2 +++ B3)}", "by (auto simp: path_image_join image_B1 image_B2 image_B3 complex_eq_iff)"], ["proof (state)\nthis:\n  z \\<in> {pathstart A, pathstart (B1 +++ B2 +++ B3)}\n\ngoal (10 subgoals):\n 1. arc A\n 2. arc B1\n 3. arc B2\n 4. arc B3\n 5. pathfinish B2 = pathstart B3\n 6. \\<And>x.\n       x \\<in> path_image B2 \\<inter> path_image B3 \\<Longrightarrow>\n       x \\<in> {pathstart B3}\n 7. pathfinish B1 = pathstart (B2 +++ B3)\n 8. \\<And>x.\n       x \\<in> path_image B1 \\<inter>\n               path_image (B2 +++ B3) \\<Longrightarrow>\n       x \\<in> {pathstart (B2 +++ B3)}\n 9. pathfinish A = pathstart (B1 +++ B2 +++ B3)\n 10. pathfinish (B1 +++ B2 +++ B3) = pathstart A", "qed (insert R, auto simp: image_B1 image_B3 path_image_join image_B2 complex_eq_iff)\n    \n      \\<comment> \\<open>We define the integrands in the same fashion as Newman:\\<close>"], ["proof (state)\nthis:\n  simple_path \\<Gamma>\n\ngoal (1 subgoal):\n 1. \\<And>N.\n       \\<lbrakk>bound N < \\<epsilon>; 1 < N\\<rbrakk>\n       \\<Longrightarrow> cmod (f w - eval_fds (fds_truncate N F) w)\n                         < \\<epsilon>", "define g where \"g = (\\<lambda>z::complex. f (w + z) * N powr z * (1 / z + z / R\\<^sup>2))\""], ["proof (state)\nthis:\n  g =\n  (\\<lambda>z.\n      f (w + z) * of_nat N powr z *\n      (1 / z + z / complex_of_real (R\\<^sup>2)))\n\ngoal (1 subgoal):\n 1. \\<And>N.\n       \\<lbrakk>bound N < \\<epsilon>; 1 < N\\<rbrakk>\n       \\<Longrightarrow> cmod (f w - eval_fds (fds_truncate N F) w)\n                         < \\<epsilon>", "define S where \"S = eval_fds (fds_truncate N F)\""], ["proof (state)\nthis:\n  S = eval_fds (fds_truncate N F)\n\ngoal (1 subgoal):\n 1. \\<And>N.\n       \\<lbrakk>bound N < \\<epsilon>; 1 < N\\<rbrakk>\n       \\<Longrightarrow> cmod (f w - eval_fds (fds_truncate N F) w)\n                         < \\<epsilon>", "define g_S where \"g_S = (\\<lambda>z::complex. S (w + z) * N powr z * (1 / z + z / R\\<^sup>2))\""], ["proof (state)\nthis:\n  g_S =\n  (\\<lambda>z.\n      S (w + z) * of_nat N powr z *\n      (1 / z + z / complex_of_real (R\\<^sup>2)))\n\ngoal (1 subgoal):\n 1. \\<And>N.\n       \\<lbrakk>bound N < \\<epsilon>; 1 < N\\<rbrakk>\n       \\<Longrightarrow> cmod (f w - eval_fds (fds_truncate N F) w)\n                         < \\<epsilon>", "define rem where \"rem = (\\<lambda>z::complex. f z - S z)\""], ["proof (state)\nthis:\n  rem = (\\<lambda>z. f z - S z)\n\ngoal (1 subgoal):\n 1. \\<And>N.\n       \\<lbrakk>bound N < \\<epsilon>; 1 < N\\<rbrakk>\n       \\<Longrightarrow> cmod (f w - eval_fds (fds_truncate N F) w)\n                         < \\<epsilon>", "define g_rem where \"g_rem = (\\<lambda>z::complex. rem (w + z) * N powr z * (1 / z + z / R\\<^sup>2))\""], ["proof (state)\nthis:\n  g_rem =\n  (\\<lambda>z.\n      rem (w + z) * of_nat N powr z *\n      (1 / z + z / complex_of_real (R\\<^sup>2)))\n\ngoal (1 subgoal):\n 1. \\<And>N.\n       \\<lbrakk>bound N < \\<epsilon>; 1 < N\\<rbrakk>\n       \\<Longrightarrow> cmod (f w - eval_fds (fds_truncate N F) w)\n                         < \\<epsilon>", "have g_holo: \"g holomorphic_on X - {0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g holomorphic_on X - {0}", "unfolding g_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>z.\n        f (w + z) * of_nat N powr z *\n        (1 / z + z / complex_of_real (R\\<^sup>2))) holomorphic_on\n    X - {0}", "by (auto intro!: holomorphic_intros analytic_imp_holomorphic'[OF analytic])"], ["proof (state)\nthis:\n  g holomorphic_on X - {0}\n\ngoal (1 subgoal):\n 1. \\<And>N.\n       \\<lbrakk>bound N < \\<epsilon>; 1 < N\\<rbrakk>\n       \\<Longrightarrow> cmod (f w - eval_fds (fds_truncate N F) w)\n                         < \\<epsilon>", "have rem_altdef: \"rem z = eval_fds (fds_remainder N F) z\" if \"Re z > 1\" for z"], ["proof (prove)\ngoal (1 subgoal):\n 1. rem z = eval_fds (fds_remainder N F) z", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. rem z = eval_fds (fds_remainder N F) z", "have abscissa: \"abs_conv_abscissa F \\<le> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. abs_conv_abscissa F \\<le> 1", "using assms"], ["proof (prove)\nusing this:\n  fds_nth F \\<in> O(\\<lambda>_. 1)\n  f analytic_on {s. 1 \\<le> Re s}\n  1 < Re ?s \\<Longrightarrow> eval_fds F ?s = f ?s\n  1 \\<le> Re w\n\ngoal (1 subgoal):\n 1. abs_conv_abscissa F \\<le> 1", "by (intro bounded_coeffs_imp_abs_conv_abscissa_le_1)\n                       (simp_all add: natfun_bigo_iff_Bseq)"], ["proof (state)\nthis:\n  abs_conv_abscissa F \\<le> 1\n\ngoal (1 subgoal):\n 1. rem z = eval_fds (fds_remainder N F) z", "from assms and that"], ["proof (chain)\npicking this:\n  fds_nth F \\<in> O(\\<lambda>_. 1)\n  f analytic_on {s. 1 \\<le> Re s}\n  1 < Re ?s \\<Longrightarrow> eval_fds F ?s = f ?s\n  1 \\<le> Re w\n  1 < Re z", "have \"f z = eval_fds F z\""], ["proof (prove)\nusing this:\n  fds_nth F \\<in> O(\\<lambda>_. 1)\n  f analytic_on {s. 1 \\<le> Re s}\n  1 < Re ?s \\<Longrightarrow> eval_fds F ?s = f ?s\n  1 \\<le> Re w\n  1 < Re z\n\ngoal (1 subgoal):\n 1. f z = eval_fds F z", "by auto"], ["proof (state)\nthis:\n  f z = eval_fds F z\n\ngoal (1 subgoal):\n 1. rem z = eval_fds (fds_remainder N F) z", "also"], ["proof (state)\nthis:\n  f z = eval_fds F z\n\ngoal (1 subgoal):\n 1. rem z = eval_fds (fds_remainder N F) z", "have \"F = fds_truncate N F + fds_remainder N F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. F = fds_truncate N F + fds_remainder N F", "by (rule fds_truncate_plus_remainder [symmetric])"], ["proof (state)\nthis:\n  F = fds_truncate N F + fds_remainder N F\n\ngoal (1 subgoal):\n 1. rem z = eval_fds (fds_remainder N F) z", "also"], ["proof (state)\nthis:\n  F = fds_truncate N F + fds_remainder N F\n\ngoal (1 subgoal):\n 1. rem z = eval_fds (fds_remainder N F) z", "from that"], ["proof (chain)\npicking this:\n  1 < Re z", "have \"eval_fds \\<dots> z = S z + eval_fds (fds_remainder N F) z\""], ["proof (prove)\nusing this:\n  1 < Re z\n\ngoal (1 subgoal):\n 1. eval_fds (fds_truncate N F + fds_remainder N F) z =\n    S z + eval_fds (fds_remainder N F) z", "unfolding S_def"], ["proof (prove)\nusing this:\n  1 < Re z\n\ngoal (1 subgoal):\n 1. eval_fds (fds_truncate N F + fds_remainder N F) z =\n    eval_fds (fds_truncate N F) z + eval_fds (fds_remainder N F) z", "by (subst eval_fds_add) (auto intro!: fds_abs_converges_imp_converges \n                                                fds_abs_converges[OF le_less_trans[OF abscissa]])"], ["proof (state)\nthis:\n  eval_fds (fds_truncate N F + fds_remainder N F) z =\n  S z + eval_fds (fds_remainder N F) z\n\ngoal (1 subgoal):\n 1. rem z = eval_fds (fds_remainder N F) z", "finally"], ["proof (chain)\npicking this:\n  f z = S z + eval_fds (fds_remainder N F) z", "show ?thesis"], ["proof (prove)\nusing this:\n  f z = S z + eval_fds (fds_remainder N F) z\n\ngoal (1 subgoal):\n 1. rem z = eval_fds (fds_remainder N F) z", "by (simp add: rem_def)"], ["proof (state)\nthis:\n  rem z = eval_fds (fds_remainder N F) z\n\ngoal:\nNo subgoals!", "qed\n\n      \\<comment> \\<open>We now come to the first application of the residue theorem along the path \\<open>\\<Gamma>\\<close>:\\<close>"], ["proof (state)\nthis:\n  1 < Re ?z \\<Longrightarrow> rem ?z = eval_fds (fds_remainder N F) ?z\n\ngoal (1 subgoal):\n 1. \\<And>N.\n       \\<lbrakk>bound N < \\<epsilon>; 1 < N\\<rbrakk>\n       \\<Longrightarrow> cmod (f w - eval_fds (fds_truncate N F) w)\n                         < \\<epsilon>", "have \"\\<ointegral>[\\<Gamma>] g = 2 * pi * \\<i> * winding_number \\<Gamma> 0 * residue g 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<ointegral>[\\<Gamma>] g =\n    complex_of_real (2 * pi) * \\<i> * winding_number \\<Gamma> 0 *\n    residue g 0", "proof (subst Residue_theorem)"], ["proof (state)\ngoal (9 subgoals):\n 1. open ?s\n 2. connected ?s\n 3. finite ?pts\n 4. g holomorphic_on ?s - ?pts\n 5. valid_path \\<Gamma>\n 6. pathfinish \\<Gamma> = pathstart \\<Gamma>\n 7. path_image \\<Gamma> \\<subseteq> ?s - ?pts\n 8. \\<forall>z.\n       z \\<notin> ?s \\<longrightarrow> winding_number \\<Gamma> z = 0\n 9. complex_of_real (2 * pi) * \\<i> *\n    (\\<Sum>p\\<in>?pts. winding_number \\<Gamma> p * residue g p) =\n    complex_of_real (2 * pi) * \\<i> * winding_number \\<Gamma> 0 *\n    residue g 0", "show \"g holomorphic_on X - {0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g holomorphic_on X - {0}", "by fact"], ["proof (state)\nthis:\n  g holomorphic_on X - {0}\n\ngoal (8 subgoals):\n 1. open X\n 2. connected X\n 3. finite {0}\n 4. valid_path \\<Gamma>\n 5. pathfinish \\<Gamma> = pathstart \\<Gamma>\n 6. path_image \\<Gamma> \\<subseteq> X - {0}\n 7. \\<forall>z. z \\<notin> X \\<longrightarrow> winding_number \\<Gamma> z = 0\n 8. complex_of_real (2 * pi) * \\<i> *\n    (\\<Sum>p\\<in>{0}. winding_number \\<Gamma> p * residue g p) =\n    complex_of_real (2 * pi) * \\<i> * winding_number \\<Gamma> 0 *\n    residue g 0", "show \"path_image \\<Gamma> \\<subseteq> X - {0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path_image \\<Gamma> \\<subseteq> X - {0}", "using path_images"], ["proof (prove)\nusing this:\n  path_image B2 \\<subseteq> X' - {0}\n  path_image A \\<subseteq> X' - {0}\n  path_image B1 \\<subseteq> X' - {0}\n  path_image B3 \\<subseteq> X' - {0}\n  X' \\<subseteq> X\n\ngoal (1 subgoal):\n 1. path_image \\<Gamma> \\<subseteq> X - {0}", "by (auto simp: \\<Gamma>_def path_image_join)"], ["proof (state)\nthis:\n  path_image \\<Gamma> \\<subseteq> X - {0}\n\ngoal (7 subgoals):\n 1. open X\n 2. connected X\n 3. finite {0}\n 4. valid_path \\<Gamma>\n 5. pathfinish \\<Gamma> = pathstart \\<Gamma>\n 6. \\<forall>z. z \\<notin> X \\<longrightarrow> winding_number \\<Gamma> z = 0\n 7. complex_of_real (2 * pi) * \\<i> *\n    (\\<Sum>p\\<in>{0}. winding_number \\<Gamma> p * residue g p) =\n    complex_of_real (2 * pi) * \\<i> * winding_number \\<Gamma> 0 *\n    residue g 0", "thus \"\\<forall>z. z \\<notin> X \\<longrightarrow> winding_number \\<Gamma> z = 0\""], ["proof (prove)\nusing this:\n  path_image \\<Gamma> \\<subseteq> X - {0}\n\ngoal (1 subgoal):\n 1. \\<forall>z. z \\<notin> X \\<longrightarrow> winding_number \\<Gamma> z = 0", "by (auto intro!: simply_connected_imp_winding_number_zero[of X]\n                           convex_imp_simply_connected)"], ["proof (state)\nthis:\n  \\<forall>z. z \\<notin> X \\<longrightarrow> winding_number \\<Gamma> z = 0\n\ngoal (6 subgoals):\n 1. open X\n 2. connected X\n 3. finite {0}\n 4. valid_path \\<Gamma>\n 5. pathfinish \\<Gamma> = pathstart \\<Gamma>\n 6. complex_of_real (2 * pi) * \\<i> *\n    (\\<Sum>p\\<in>{0}. winding_number \\<Gamma> p * residue g p) =\n    complex_of_real (2 * pi) * \\<i> * winding_number \\<Gamma> 0 *\n    residue g 0", "qed (insert path_images, auto intro: convex_connected)"], ["proof (state)\nthis:\n  \\<ointegral>[\\<Gamma>] g =\n  complex_of_real (2 * pi) * \\<i> * winding_number \\<Gamma> 0 * residue g 0\n\ngoal (1 subgoal):\n 1. \\<And>N.\n       \\<lbrakk>bound N < \\<epsilon>; 1 < N\\<rbrakk>\n       \\<Longrightarrow> cmod (f w - eval_fds (fds_truncate N F) w)\n                         < \\<epsilon>", "also"], ["proof (state)\nthis:\n  \\<ointegral>[\\<Gamma>] g =\n  complex_of_real (2 * pi) * \\<i> * winding_number \\<Gamma> 0 * residue g 0\n\ngoal (1 subgoal):\n 1. \\<And>N.\n       \\<lbrakk>bound N < \\<epsilon>; 1 < N\\<rbrakk>\n       \\<Longrightarrow> cmod (f w - eval_fds (fds_truncate N F) w)\n                         < \\<epsilon>", "have \"winding_number \\<Gamma> 0 = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. winding_number \\<Gamma> 0 = 1", "proof (rule simple_closed_path_winding_number_pos)"], ["proof (state)\ngoal (4 subgoals):\n 1. simple_path \\<Gamma>\n 2. pathfinish \\<Gamma> = pathstart \\<Gamma>\n 3. 0 \\<notin> path_image \\<Gamma>\n 4. 0 < Re (winding_number \\<Gamma> 0)", "from R \\<delta>"], ["proof (chain)\npicking this:\n  3 * C / \\<epsilon> \\<le> R\n  1 \\<le> R\n  0 < \\<delta>\n  \\<delta> \\<le> 1 / 2\n  \\<delta> < l", "have \"\\<forall>g\\<in>{A, B1, B2, B3}. Re (winding_number g 0) > 0\""], ["proof (prove)\nusing this:\n  3 * C / \\<epsilon> \\<le> R\n  1 \\<le> R\n  0 < \\<delta>\n  \\<delta> \\<le> 1 / 2\n  \\<delta> < l\n\ngoal (1 subgoal):\n 1. \\<forall>g\\<in>{A, B1, B2, B3}. 0 < Re (winding_number g 0)", "unfolding A_def B1_def B2_def B3_def"], ["proof (prove)\nusing this:\n  3 * C / \\<epsilon> \\<le> R\n  1 \\<le> R\n  0 < \\<delta>\n  \\<delta> \\<le> 1 / 2\n  \\<delta> < l\n\ngoal (1 subgoal):\n 1. \\<forall>g\\<in>{part_circlepath 0 R (- pi / 2) (pi / 2),\n                    linepath (complex_of_real R * \\<i>)\n                     (complex_of_real R * \\<i> - complex_of_real \\<delta>),\n                    linepath (Complex (- \\<delta>) R)\n                     (Complex (- \\<delta>) (- R)),\n                    linepath\n                     (complex_of_real (- R) * \\<i> -\n                      complex_of_real \\<delta>)\n                     (complex_of_real (- R) * \\<i>)}.\n       0 < Re (winding_number g 0)", "by (auto intro!: winding_number_linepath_pos_lt winding_number_part_circlepath_pos_less)"], ["proof (state)\nthis:\n  \\<forall>g\\<in>{A, B1, B2, B3}. 0 < Re (winding_number g 0)\n\ngoal (4 subgoals):\n 1. simple_path \\<Gamma>\n 2. pathfinish \\<Gamma> = pathstart \\<Gamma>\n 3. 0 \\<notin> path_image \\<Gamma>\n 4. 0 < Re (winding_number \\<Gamma> 0)", "hence \"valid_path \\<Gamma> \\<and> 0 \\<notin> path_image \\<Gamma> \\<and> Re (winding_number \\<Gamma> 0) > 0\""], ["proof (prove)\nusing this:\n  \\<forall>g\\<in>{A, B1, B2, B3}. 0 < Re (winding_number g 0)\n\ngoal (1 subgoal):\n 1. valid_path \\<Gamma> \\<and>\n    0 \\<notin> path_image \\<Gamma> \\<and> 0 < Re (winding_number \\<Gamma> 0)", "unfolding \\<Gamma>_def"], ["proof (prove)\nusing this:\n  \\<forall>g\\<in>{A, B1, B2, B3}. 0 < Re (winding_number g 0)\n\ngoal (1 subgoal):\n 1. valid_path (A +++ B1 +++ B2 +++ B3) \\<and>\n    0 \\<notin> path_image (A +++ B1 +++ B2 +++ B3) \\<and>\n    0 < Re (winding_number (A +++ B1 +++ B2 +++ B3) 0)", "using path_images(1-4)"], ["proof (prove)\nusing this:\n  \\<forall>g\\<in>{A, B1, B2, B3}. 0 < Re (winding_number g 0)\n  path_image B2 \\<subseteq> X' - {0}\n  path_image A \\<subseteq> X' - {0}\n  path_image B1 \\<subseteq> X' - {0}\n  path_image B3 \\<subseteq> X' - {0}\n\ngoal (1 subgoal):\n 1. valid_path (A +++ B1 +++ B2 +++ B3) \\<and>\n    0 \\<notin> path_image (A +++ B1 +++ B2 +++ B3) \\<and>\n    0 < Re (winding_number (A +++ B1 +++ B2 +++ B3) 0)", "by (intro winding_number_join_pos_combined') auto"], ["proof (state)\nthis:\n  valid_path \\<Gamma> \\<and>\n  0 \\<notin> path_image \\<Gamma> \\<and> 0 < Re (winding_number \\<Gamma> 0)\n\ngoal (4 subgoals):\n 1. simple_path \\<Gamma>\n 2. pathfinish \\<Gamma> = pathstart \\<Gamma>\n 3. 0 \\<notin> path_image \\<Gamma>\n 4. 0 < Re (winding_number \\<Gamma> 0)", "thus \"Re (winding_number \\<Gamma> 0) > 0\""], ["proof (prove)\nusing this:\n  valid_path \\<Gamma> \\<and>\n  0 \\<notin> path_image \\<Gamma> \\<and> 0 < Re (winding_number \\<Gamma> 0)\n\ngoal (1 subgoal):\n 1. 0 < Re (winding_number \\<Gamma> 0)", "by simp"], ["proof (state)\nthis:\n  0 < Re (winding_number \\<Gamma> 0)\n\ngoal (3 subgoals):\n 1. simple_path \\<Gamma>\n 2. pathfinish \\<Gamma> = pathstart \\<Gamma>\n 3. 0 \\<notin> path_image \\<Gamma>", "qed (insert path_images \\<open>simple_path \\<Gamma>\\<close>, auto simp: \\<Gamma>_def path_image_join)"], ["proof (state)\nthis:\n  winding_number \\<Gamma> 0 = 1\n\ngoal (1 subgoal):\n 1. \\<And>N.\n       \\<lbrakk>bound N < \\<epsilon>; 1 < N\\<rbrakk>\n       \\<Longrightarrow> cmod (f w - eval_fds (fds_truncate N F) w)\n                         < \\<epsilon>", "also"], ["proof (state)\nthis:\n  winding_number \\<Gamma> 0 = 1\n\ngoal (1 subgoal):\n 1. \\<And>N.\n       \\<lbrakk>bound N < \\<epsilon>; 1 < N\\<rbrakk>\n       \\<Longrightarrow> cmod (f w - eval_fds (fds_truncate N F) w)\n                         < \\<epsilon>", "have \"residue g 0 = f w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. residue g 0 = f w", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. residue g 0 = f w", "have \"g = (\\<lambda>z::complex. f (w + z) * N powr z * (1 + z\\<^sup>2 / R\\<^sup>2) / z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g =\n    (\\<lambda>z.\n        f (w + z) * of_nat N powr z *\n        (1 + z\\<^sup>2 / complex_of_real (R\\<^sup>2)) /\n        z)", "by (auto simp: g_def divide_simps fun_eq_iff power2_eq_square\n                   simp del: div_mult_self3 div_mult_self4 div_mult_self2 div_mult_self1)"], ["proof (state)\nthis:\n  g =\n  (\\<lambda>z.\n      f (w + z) * of_nat N powr z *\n      (1 + z\\<^sup>2 / complex_of_real (R\\<^sup>2)) /\n      z)\n\ngoal (1 subgoal):\n 1. residue g 0 = f w", "moreover"], ["proof (state)\nthis:\n  g =\n  (\\<lambda>z.\n      f (w + z) * of_nat N powr z *\n      (1 + z\\<^sup>2 / complex_of_real (R\\<^sup>2)) /\n      z)\n\ngoal (1 subgoal):\n 1. residue g 0 = f w", "from N"], ["proof (chain)\npicking this:\n  bound N < \\<epsilon>\n  1 < N", "have \"residue \\<dots> 0 = f w\""], ["proof (prove)\nusing this:\n  bound N < \\<epsilon>\n  1 < N\n\ngoal (1 subgoal):\n 1. residue\n     (\\<lambda>z.\n         f (w + z) * of_nat N powr z *\n         (1 + z\\<^sup>2 / complex_of_real (R\\<^sup>2)) /\n         z)\n     0 =\n    f w", "by (subst residue_simple'[of X])\n             (auto intro!: holomorphic_intros analytic_imp_holomorphic[OF analytic])"], ["proof (state)\nthis:\n  residue\n   (\\<lambda>z.\n       f (w + z) * of_nat N powr z *\n       (1 + z\\<^sup>2 / complex_of_real (R\\<^sup>2)) /\n       z)\n   0 =\n  f w\n\ngoal (1 subgoal):\n 1. residue g 0 = f w", "ultimately"], ["proof (chain)\npicking this:\n  g =\n  (\\<lambda>z.\n      f (w + z) * of_nat N powr z *\n      (1 + z\\<^sup>2 / complex_of_real (R\\<^sup>2)) /\n      z)\n  residue\n   (\\<lambda>z.\n       f (w + z) * of_nat N powr z *\n       (1 + z\\<^sup>2 / complex_of_real (R\\<^sup>2)) /\n       z)\n   0 =\n  f w", "show ?thesis"], ["proof (prove)\nusing this:\n  g =\n  (\\<lambda>z.\n      f (w + z) * of_nat N powr z *\n      (1 + z\\<^sup>2 / complex_of_real (R\\<^sup>2)) /\n      z)\n  residue\n   (\\<lambda>z.\n       f (w + z) * of_nat N powr z *\n       (1 + z\\<^sup>2 / complex_of_real (R\\<^sup>2)) /\n       z)\n   0 =\n  f w\n\ngoal (1 subgoal):\n 1. residue g 0 = f w", "by (simp only:)"], ["proof (state)\nthis:\n  residue g 0 = f w\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  residue g 0 = f w\n\ngoal (1 subgoal):\n 1. \\<And>N.\n       \\<lbrakk>bound N < \\<epsilon>; 1 < N\\<rbrakk>\n       \\<Longrightarrow> cmod (f w - eval_fds (fds_truncate N F) w)\n                         < \\<epsilon>", "finally"], ["proof (chain)\npicking this:\n  \\<ointegral>[\\<Gamma>] g = complex_of_real (2 * pi) * \\<i> * 1 * f w", "have \"2 * pi * \\<i> * f w = \\<ointegral>[\\<Gamma>] g\""], ["proof (prove)\nusing this:\n  \\<ointegral>[\\<Gamma>] g = complex_of_real (2 * pi) * \\<i> * 1 * f w\n\ngoal (1 subgoal):\n 1. complex_of_real (2 * pi) * \\<i> * f w = \\<ointegral>[\\<Gamma>] g", "by simp"], ["proof (state)\nthis:\n  complex_of_real (2 * pi) * \\<i> * f w = \\<ointegral>[\\<Gamma>] g\n\ngoal (1 subgoal):\n 1. \\<And>N.\n       \\<lbrakk>bound N < \\<epsilon>; 1 < N\\<rbrakk>\n       \\<Longrightarrow> cmod (f w - eval_fds (fds_truncate N F) w)\n                         < \\<epsilon>", "also"], ["proof (state)\nthis:\n  complex_of_real (2 * pi) * \\<i> * f w = \\<ointegral>[\\<Gamma>] g\n\ngoal (1 subgoal):\n 1. \\<And>N.\n       \\<lbrakk>bound N < \\<epsilon>; 1 < N\\<rbrakk>\n       \\<Longrightarrow> cmod (f w - eval_fds (fds_truncate N F) w)\n                         < \\<epsilon>", "have \"\\<dots> = \\<ointegral>[A] g + \\<ointegral>[B2] g + \\<ointegral>[B1] g + \\<ointegral>[B3] g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<ointegral>[\\<Gamma>] g =\n    \\<ointegral>[A] g + \\<ointegral>[B2] g + \\<ointegral>[B1] g +\n    \\<ointegral>[B3] g", "unfolding \\<Gamma>_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<ointegral>[A +++ B1 +++ B2 +++ B3] g =\n    \\<ointegral>[A] g + \\<ointegral>[B2] g + \\<ointegral>[B1] g +\n    \\<ointegral>[B3] g", "by (subst contour_integral_join, (insert path_images,\n            auto intro!: contour_integral_join contour_integrable_holomorphic_simple g_holo)[4])+\n           (simp_all add: add_ac)"], ["proof (state)\nthis:\n  \\<ointegral>[\\<Gamma>] g =\n  \\<ointegral>[A] g + \\<ointegral>[B2] g + \\<ointegral>[B1] g +\n  \\<ointegral>[B3] g\n\ngoal (1 subgoal):\n 1. \\<And>N.\n       \\<lbrakk>bound N < \\<epsilon>; 1 < N\\<rbrakk>\n       \\<Longrightarrow> cmod (f w - eval_fds (fds_truncate N F) w)\n                         < \\<epsilon>", "finally"], ["proof (chain)\npicking this:\n  complex_of_real (2 * pi) * \\<i> * f w =\n  \\<ointegral>[A] g + \\<ointegral>[B2] g + \\<ointegral>[B1] g +\n  \\<ointegral>[B3] g", "have integral1: \"2 * pi * \\<i> * f w = \\<ointegral>[A] g + \\<ointegral>[B2] g + \\<ointegral>[B1] g + \\<ointegral>[B3] g\""], ["proof (prove)\nusing this:\n  complex_of_real (2 * pi) * \\<i> * f w =\n  \\<ointegral>[A] g + \\<ointegral>[B2] g + \\<ointegral>[B1] g +\n  \\<ointegral>[B3] g\n\ngoal (1 subgoal):\n 1. complex_of_real (2 * pi) * \\<i> * f w =\n    \\<ointegral>[A] g + \\<ointegral>[B2] g + \\<ointegral>[B1] g +\n    \\<ointegral>[B3] g", ".\n\n      \\<comment> \\<open>Next, we apply the residue theorem along a circle of radius \\<open>R\\<close> to another\n          integrand that is related to the partial sum:\\<close>"], ["proof (state)\nthis:\n  complex_of_real (2 * pi) * \\<i> * f w =\n  \\<ointegral>[A] g + \\<ointegral>[B2] g + \\<ointegral>[B1] g +\n  \\<ointegral>[B3] g\n\ngoal (1 subgoal):\n 1. \\<And>N.\n       \\<lbrakk>bound N < \\<epsilon>; 1 < N\\<rbrakk>\n       \\<Longrightarrow> cmod (f w - eval_fds (fds_truncate N F) w)\n                         < \\<epsilon>", "have \"\\<ointegral>[circlepath 0 R] g_S = 2 * pi * \\<i> * residue g_S 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<ointegral>[circlepath 0 R] g_S =\n    complex_of_real (2 * pi) * \\<i> * residue g_S 0", "proof (subst Residue_theorem)"], ["proof (state)\ngoal (9 subgoals):\n 1. open ?s\n 2. connected ?s\n 3. finite ?pts\n 4. g_S holomorphic_on ?s - ?pts\n 5. valid_path (circlepath 0 R)\n 6. pathfinish (circlepath 0 R) = pathstart (circlepath 0 R)\n 7. path_image (circlepath 0 R) \\<subseteq> ?s - ?pts\n 8. \\<forall>z.\n       z \\<notin> ?s \\<longrightarrow> winding_number (circlepath 0 R) z = 0\n 9. complex_of_real (2 * pi) * \\<i> *\n    (\\<Sum>p\\<in>?pts. winding_number (circlepath 0 R) p * residue g_S p) =\n    complex_of_real (2 * pi) * \\<i> * residue g_S 0", "show \"g_S holomorphic_on UNIV - {0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g_S holomorphic_on UNIV - {0}", "by (auto simp: g_S_def S_def intro!: holomorphic_intros)"], ["proof (state)\nthis:\n  g_S holomorphic_on UNIV - {0}\n\ngoal (8 subgoals):\n 1. open UNIV\n 2. connected UNIV\n 3. finite {0}\n 4. valid_path (circlepath 0 R)\n 5. pathfinish (circlepath 0 R) = pathstart (circlepath 0 R)\n 6. path_image (circlepath 0 R) \\<subseteq> UNIV - {0}\n 7. \\<forall>z.\n       z \\<notin> UNIV \\<longrightarrow>\n       winding_number (circlepath 0 R) z = 0\n 8. complex_of_real (2 * pi) * \\<i> *\n    (\\<Sum>p\\<in>{0}. winding_number (circlepath 0 R) p * residue g_S p) =\n    complex_of_real (2 * pi) * \\<i> * residue g_S 0", "qed (insert R, auto simp: winding_number_circlepath_centre)"], ["proof (state)\nthis:\n  \\<ointegral>[circlepath 0 R] g_S =\n  complex_of_real (2 * pi) * \\<i> * residue g_S 0\n\ngoal (1 subgoal):\n 1. \\<And>N.\n       \\<lbrakk>bound N < \\<epsilon>; 1 < N\\<rbrakk>\n       \\<Longrightarrow> cmod (f w - eval_fds (fds_truncate N F) w)\n                         < \\<epsilon>", "also"], ["proof (state)\nthis:\n  \\<ointegral>[circlepath 0 R] g_S =\n  complex_of_real (2 * pi) * \\<i> * residue g_S 0\n\ngoal (1 subgoal):\n 1. \\<And>N.\n       \\<lbrakk>bound N < \\<epsilon>; 1 < N\\<rbrakk>\n       \\<Longrightarrow> cmod (f w - eval_fds (fds_truncate N F) w)\n                         < \\<epsilon>", "have \"residue g_S 0 = S w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. residue g_S 0 = S w", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. residue g_S 0 = S w", "have \"g_S = (\\<lambda>z::complex. S (w + z) * N powr z * (1 + z\\<^sup>2 / R\\<^sup>2) / z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g_S =\n    (\\<lambda>z.\n        S (w + z) * of_nat N powr z *\n        (1 + z\\<^sup>2 / complex_of_real (R\\<^sup>2)) /\n        z)", "by (auto simp: g_S_def divide_simps fun_eq_iff power2_eq_square\n                   simp del: div_mult_self3 div_mult_self4 div_mult_self2 div_mult_self1)"], ["proof (state)\nthis:\n  g_S =\n  (\\<lambda>z.\n      S (w + z) * of_nat N powr z *\n      (1 + z\\<^sup>2 / complex_of_real (R\\<^sup>2)) /\n      z)\n\ngoal (1 subgoal):\n 1. residue g_S 0 = S w", "moreover"], ["proof (state)\nthis:\n  g_S =\n  (\\<lambda>z.\n      S (w + z) * of_nat N powr z *\n      (1 + z\\<^sup>2 / complex_of_real (R\\<^sup>2)) /\n      z)\n\ngoal (1 subgoal):\n 1. residue g_S 0 = S w", "from N"], ["proof (chain)\npicking this:\n  bound N < \\<epsilon>\n  1 < N", "have \"residue \\<dots> 0 = S w\""], ["proof (prove)\nusing this:\n  bound N < \\<epsilon>\n  1 < N\n\ngoal (1 subgoal):\n 1. residue\n     (\\<lambda>z.\n         S (w + z) * of_nat N powr z *\n         (1 + z\\<^sup>2 / complex_of_real (R\\<^sup>2)) /\n         z)\n     0 =\n    S w", "by (subst residue_simple'[of X])\n             (auto intro!: holomorphic_intros simp: S_def)"], ["proof (state)\nthis:\n  residue\n   (\\<lambda>z.\n       S (w + z) * of_nat N powr z *\n       (1 + z\\<^sup>2 / complex_of_real (R\\<^sup>2)) /\n       z)\n   0 =\n  S w\n\ngoal (1 subgoal):\n 1. residue g_S 0 = S w", "ultimately"], ["proof (chain)\npicking this:\n  g_S =\n  (\\<lambda>z.\n      S (w + z) * of_nat N powr z *\n      (1 + z\\<^sup>2 / complex_of_real (R\\<^sup>2)) /\n      z)\n  residue\n   (\\<lambda>z.\n       S (w + z) * of_nat N powr z *\n       (1 + z\\<^sup>2 / complex_of_real (R\\<^sup>2)) /\n       z)\n   0 =\n  S w", "show ?thesis"], ["proof (prove)\nusing this:\n  g_S =\n  (\\<lambda>z.\n      S (w + z) * of_nat N powr z *\n      (1 + z\\<^sup>2 / complex_of_real (R\\<^sup>2)) /\n      z)\n  residue\n   (\\<lambda>z.\n       S (w + z) * of_nat N powr z *\n       (1 + z\\<^sup>2 / complex_of_real (R\\<^sup>2)) /\n       z)\n   0 =\n  S w\n\ngoal (1 subgoal):\n 1. residue g_S 0 = S w", "by (simp only:)"], ["proof (state)\nthis:\n  residue g_S 0 = S w\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  residue g_S 0 = S w\n\ngoal (1 subgoal):\n 1. \\<And>N.\n       \\<lbrakk>bound N < \\<epsilon>; 1 < N\\<rbrakk>\n       \\<Longrightarrow> cmod (f w - eval_fds (fds_truncate N F) w)\n                         < \\<epsilon>", "finally"], ["proof (chain)\npicking this:\n  \\<ointegral>[circlepath 0 R] g_S = complex_of_real (2 * pi) * \\<i> * S w", "have \"2 * pi * \\<i> * S w = \\<ointegral>[circlepath 0 R] g_S\""], ["proof (prove)\nusing this:\n  \\<ointegral>[circlepath 0 R] g_S = complex_of_real (2 * pi) * \\<i> * S w\n\ngoal (1 subgoal):\n 1. complex_of_real (2 * pi) * \\<i> * S w = \\<ointegral>[circlepath 0 R] g_S", "..\n\n      \\<comment> \\<open>We split this integral into integrals along two semicircles in the left and right\n          half-plane, respectively:\\<close>"], ["proof (state)\nthis:\n  complex_of_real (2 * pi) * \\<i> * S w = \\<ointegral>[circlepath 0 R] g_S\n\ngoal (1 subgoal):\n 1. \\<And>N.\n       \\<lbrakk>bound N < \\<epsilon>; 1 < N\\<rbrakk>\n       \\<Longrightarrow> cmod (f w - eval_fds (fds_truncate N F) w)\n                         < \\<epsilon>", "also"], ["proof (state)\nthis:\n  complex_of_real (2 * pi) * \\<i> * S w = \\<ointegral>[circlepath 0 R] g_S\n\ngoal (1 subgoal):\n 1. \\<And>N.\n       \\<lbrakk>bound N < \\<epsilon>; 1 < N\\<rbrakk>\n       \\<Longrightarrow> cmod (f w - eval_fds (fds_truncate N F) w)\n                         < \\<epsilon>", "have \"\\<dots> = \\<ointegral>[part_circlepath 0 R (-pi/2) (3*pi/2)] g_S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<ointegral>[circlepath 0 R] g_S =\n    \\<ointegral>[part_circlepath 0 R (- pi / 2) (3 * pi / 2)] g_S", "proof (rule Cauchy_theorem_homotopic_loops)"], ["proof (state)\ngoal (5 subgoals):\n 1. homotopic_loops ?S (circlepath 0 R)\n     (part_circlepath 0 R (- pi / 2) (3 * pi / 2))\n 2. open ?S\n 3. g_S holomorphic_on ?S\n 4. valid_path (circlepath 0 R)\n 5. valid_path (part_circlepath 0 R (- pi / 2) (3 * pi / 2))", "show \"homotopic_loops (-{0}) (circlepath 0 R)\n                (part_circlepath 0 R (- pi / 2) (3 * pi / 2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. homotopic_loops (- {0}) (circlepath 0 R)\n     (part_circlepath 0 R (- pi / 2) (3 * pi / 2))", "unfolding circlepath_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. homotopic_loops (- {0}) (part_circlepath 0 R 0 (2 * pi))\n     (part_circlepath 0 R (- pi / 2) (3 * pi / 2))", "using R"], ["proof (prove)\nusing this:\n  3 * C / \\<epsilon> \\<le> R\n  1 \\<le> R\n\ngoal (1 subgoal):\n 1. homotopic_loops (- {0}) (part_circlepath 0 R 0 (2 * pi))\n     (part_circlepath 0 R (- pi / 2) (3 * pi / 2))", "by (intro homotopic_loops_part_circlepath[where k = 1]) auto"], ["proof (state)\nthis:\n  homotopic_loops (- {0}) (circlepath 0 R)\n   (part_circlepath 0 R (- pi / 2) (3 * pi / 2))\n\ngoal (4 subgoals):\n 1. open (- {0})\n 2. g_S holomorphic_on - {0}\n 3. valid_path (circlepath 0 R)\n 4. valid_path (part_circlepath 0 R (- pi / 2) (3 * pi / 2))", "qed (auto simp: g_S_def S_def intro!: holomorphic_intros)"], ["proof (state)\nthis:\n  \\<ointegral>[circlepath 0 R] g_S =\n  \\<ointegral>[part_circlepath 0 R (- pi / 2) (3 * pi / 2)] g_S\n\ngoal (1 subgoal):\n 1. \\<And>N.\n       \\<lbrakk>bound N < \\<epsilon>; 1 < N\\<rbrakk>\n       \\<Longrightarrow> cmod (f w - eval_fds (fds_truncate N F) w)\n                         < \\<epsilon>", "also"], ["proof (state)\nthis:\n  \\<ointegral>[circlepath 0 R] g_S =\n  \\<ointegral>[part_circlepath 0 R (- pi / 2) (3 * pi / 2)] g_S\n\ngoal (1 subgoal):\n 1. \\<And>N.\n       \\<lbrakk>bound N < \\<epsilon>; 1 < N\\<rbrakk>\n       \\<Longrightarrow> cmod (f w - eval_fds (fds_truncate N F) w)\n                         < \\<epsilon>", "have \"\\<dots> = \\<ointegral>[A +++ -A] g_S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<ointegral>[part_circlepath 0 R (- pi / 2) (3 * pi / 2)] g_S =\n    \\<ointegral>[A +++ - A] g_S", "proof (rule Cauchy_theorem_homotopic_paths)"], ["proof (state)\ngoal (5 subgoals):\n 1. homotopic_paths ?S (part_circlepath 0 R (- pi / 2) (3 * pi / 2))\n     (A +++ - A)\n 2. open ?S\n 3. g_S holomorphic_on ?S\n 4. valid_path (part_circlepath 0 R (- pi / 2) (3 * pi / 2))\n 5. valid_path (A +++ - A)", "have *: \"-A = part_circlepath 0 R (pi/2) (3*pi/2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - A = part_circlepath 0 R (pi / 2) (3 * pi / 2)", "unfolding A_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. - part_circlepath 0 R (- pi / 2) (pi / 2) =\n    part_circlepath 0 R (pi / 2) (3 * pi / 2)", "by (intro part_circlepath_mirror[where k = 0]) auto"], ["proof (state)\nthis:\n  - A = part_circlepath 0 R (pi / 2) (3 * pi / 2)\n\ngoal (5 subgoals):\n 1. homotopic_paths ?S (part_circlepath 0 R (- pi / 2) (3 * pi / 2))\n     (A +++ - A)\n 2. open ?S\n 3. g_S holomorphic_on ?S\n 4. valid_path (part_circlepath 0 R (- pi / 2) (3 * pi / 2))\n 5. valid_path (A +++ - A)", "from R"], ["proof (chain)\npicking this:\n  3 * C / \\<epsilon> \\<le> R\n  1 \\<le> R", "show \"homotopic_paths (-{0}) (part_circlepath 0 R (-pi/2) (3*pi/2)) (A +++ -A)\""], ["proof (prove)\nusing this:\n  3 * C / \\<epsilon> \\<le> R\n  1 \\<le> R\n\ngoal (1 subgoal):\n 1. homotopic_paths (- {0}) (part_circlepath 0 R (- pi / 2) (3 * pi / 2))\n     (A +++ - A)", "unfolding *"], ["proof (prove)\nusing this:\n  3 * C / \\<epsilon> \\<le> R\n  1 \\<le> R\n\ngoal (1 subgoal):\n 1. homotopic_paths (- {0}) (part_circlepath 0 R (- pi / 2) (3 * pi / 2))\n     (A +++ part_circlepath 0 R (pi / 2) (3 * pi / 2))", "unfolding A_def"], ["proof (prove)\nusing this:\n  3 * C / \\<epsilon> \\<le> R\n  1 \\<le> R\n\ngoal (1 subgoal):\n 1. homotopic_paths (- {0}) (part_circlepath 0 R (- pi / 2) (3 * pi / 2))\n     (part_circlepath 0 R (- pi / 2) (pi / 2) +++\n      part_circlepath 0 R (pi / 2) (3 * pi / 2))", "by (intro homotopic_paths_part_circlepath) (auto dest!: in_path_image_part_circlepath)"], ["proof (state)\nthis:\n  homotopic_paths (- {0}) (part_circlepath 0 R (- pi / 2) (3 * pi / 2))\n   (A +++ - A)\n\ngoal (4 subgoals):\n 1. open (- {0})\n 2. g_S holomorphic_on - {0}\n 3. valid_path (part_circlepath 0 R (- pi / 2) (3 * pi / 2))\n 4. valid_path (A +++ - A)", "qed (auto simp: g_S_def S_def A_def exp_eq_polar intro!: holomorphic_intros)"], ["proof (state)\nthis:\n  \\<ointegral>[part_circlepath 0 R (- pi / 2) (3 * pi / 2)] g_S =\n  \\<ointegral>[A +++ - A] g_S\n\ngoal (1 subgoal):\n 1. \\<And>N.\n       \\<lbrakk>bound N < \\<epsilon>; 1 < N\\<rbrakk>\n       \\<Longrightarrow> cmod (f w - eval_fds (fds_truncate N F) w)\n                         < \\<epsilon>", "also"], ["proof (state)\nthis:\n  \\<ointegral>[part_circlepath 0 R (- pi / 2) (3 * pi / 2)] g_S =\n  \\<ointegral>[A +++ - A] g_S\n\ngoal (1 subgoal):\n 1. \\<And>N.\n       \\<lbrakk>bound N < \\<epsilon>; 1 < N\\<rbrakk>\n       \\<Longrightarrow> cmod (f w - eval_fds (fds_truncate N F) w)\n                         < \\<epsilon>", "have \"\\<dots> = \\<ointegral>[A] g_S + \\<ointegral>[-A] g_S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<ointegral>[A +++ - A] g_S =\n    \\<ointegral>[A] g_S + \\<ointegral>[- A] g_S", "using R"], ["proof (prove)\nusing this:\n  3 * C / \\<epsilon> \\<le> R\n  1 \\<le> R\n\ngoal (1 subgoal):\n 1. \\<ointegral>[A +++ - A] g_S =\n    \\<ointegral>[A] g_S + \\<ointegral>[- A] g_S", "by (intro contour_integral_join contour_integrable_holomorphic_simple[of _ \"-{0}\"])\n           (auto simp: A_def g_S_def S_def path_image_mirror dest!: in_path_image_part_circlepath\n                 intro!: holomorphic_intros)"], ["proof (state)\nthis:\n  \\<ointegral>[A +++ - A] g_S = \\<ointegral>[A] g_S + \\<ointegral>[- A] g_S\n\ngoal (1 subgoal):\n 1. \\<And>N.\n       \\<lbrakk>bound N < \\<epsilon>; 1 < N\\<rbrakk>\n       \\<Longrightarrow> cmod (f w - eval_fds (fds_truncate N F) w)\n                         < \\<epsilon>", "also"], ["proof (state)\nthis:\n  \\<ointegral>[A +++ - A] g_S = \\<ointegral>[A] g_S + \\<ointegral>[- A] g_S\n\ngoal (1 subgoal):\n 1. \\<And>N.\n       \\<lbrakk>bound N < \\<epsilon>; 1 < N\\<rbrakk>\n       \\<Longrightarrow> cmod (f w - eval_fds (fds_truncate N F) w)\n                         < \\<epsilon>", "have \"\\<ointegral>[-A] g_S = -\\<ointegral>[A] (\\<lambda>x. g_S (-x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<ointegral>[- A] g_S = - \\<ointegral>[A] (\\<lambda>x. g_S (- x))", "by (simp add: A_def contour_integral_mirror contour_integral_neg)"], ["proof (state)\nthis:\n  \\<ointegral>[- A] g_S = - \\<ointegral>[A] (\\<lambda>x. g_S (- x))\n\ngoal (1 subgoal):\n 1. \\<And>N.\n       \\<lbrakk>bound N < \\<epsilon>; 1 < N\\<rbrakk>\n       \\<Longrightarrow> cmod (f w - eval_fds (fds_truncate N F) w)\n                         < \\<epsilon>", "finally"], ["proof (chain)\npicking this:\n  complex_of_real (2 * pi) * \\<i> * S w =\n  \\<ointegral>[A] g_S + - \\<ointegral>[A] (\\<lambda>x. g_S (- x))", "have integral2: \"2 * pi * \\<i> * S w = \\<ointegral>[A] g_S - \\<ointegral>[A] (\\<lambda>x. g_S (-x))\""], ["proof (prove)\nusing this:\n  complex_of_real (2 * pi) * \\<i> * S w =\n  \\<ointegral>[A] g_S + - \\<ointegral>[A] (\\<lambda>x. g_S (- x))\n\ngoal (1 subgoal):\n 1. complex_of_real (2 * pi) * \\<i> * S w =\n    \\<ointegral>[A] g_S - \\<ointegral>[A] (\\<lambda>x. g_S (- x))", "by simp\n\n      \\<comment> \\<open>Next, we show a small bounding lemma that we will need for the final estimate:\\<close>"], ["proof (state)\nthis:\n  complex_of_real (2 * pi) * \\<i> * S w =\n  \\<ointegral>[A] g_S - \\<ointegral>[A] (\\<lambda>x. g_S (- x))\n\ngoal (1 subgoal):\n 1. \\<And>N.\n       \\<lbrakk>bound N < \\<epsilon>; 1 < N\\<rbrakk>\n       \\<Longrightarrow> cmod (f w - eval_fds (fds_truncate N F) w)\n                         < \\<epsilon>", "have circle_bound: \"norm (1 / z + z / R\\<^sup>2) \\<le> 2 / R\" if [simp]: \"norm z = R\" for z :: complex"], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod (1 / z + z / complex_of_real (R\\<^sup>2)) \\<le> 2 / R", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cmod (1 / z + z / complex_of_real (R\\<^sup>2)) \\<le> 2 / R", "have \"norm (1 / z + z / R\\<^sup>2) \\<le> 1 / R + 1 / R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod (1 / z + z / complex_of_real (R\\<^sup>2)) \\<le> 1 / R + 1 / R", "by (intro order.trans[OF norm_triangle_ineq] add_mono)\n             (insert R, simp_all add: norm_divide norm_mult power2_eq_square)"], ["proof (state)\nthis:\n  cmod (1 / z + z / complex_of_real (R\\<^sup>2)) \\<le> 1 / R + 1 / R\n\ngoal (1 subgoal):\n 1. cmod (1 / z + z / complex_of_real (R\\<^sup>2)) \\<le> 2 / R", "thus ?thesis"], ["proof (prove)\nusing this:\n  cmod (1 / z + z / complex_of_real (R\\<^sup>2)) \\<le> 1 / R + 1 / R\n\ngoal (1 subgoal):\n 1. cmod (1 / z + z / complex_of_real (R\\<^sup>2)) \\<le> 2 / R", "by simp"], ["proof (state)\nthis:\n  cmod (1 / z + z / complex_of_real (R\\<^sup>2)) \\<le> 2 / R\n\ngoal:\nNo subgoals!", "qed\n\n      \\<comment> \\<open>The next bound differs somewhat from Newman's, but it works just as well.\n          Its purpose is to bound the contribution of the two short horizontal line segments.\\<close>"], ["proof (state)\nthis:\n  cmod ?z = R \\<Longrightarrow>\n  cmod (1 / ?z + ?z / complex_of_real (R\\<^sup>2)) \\<le> 2 / R\n\ngoal (1 subgoal):\n 1. \\<And>N.\n       \\<lbrakk>bound N < \\<epsilon>; 1 < N\\<rbrakk>\n       \\<Longrightarrow> cmod (f w - eval_fds (fds_truncate N F) w)\n                         < \\<epsilon>", "have B12_bound: \"norm (integral {- \\<delta>..0} (\\<lambda>x. g (x + R' * \\<i>))) \\<le> 3 * M / R / ln N\"\n        (is \"?I \\<le> _\") if \"\\<bar>R'\\<bar> = R\" for R'"], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod\n     (integral {- \\<delta>..0}\n       (\\<lambda>x. g (complex_of_real x + complex_of_real R' * \\<i>)))\n    \\<le> 3 * M / R / ln (real N)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cmod\n     (integral {- \\<delta>..0}\n       (\\<lambda>x. g (complex_of_real x + complex_of_real R' * \\<i>)))\n    \\<le> 3 * M / R / ln (real N)", "have \"?I \\<le> integral {-\\<delta>..0} (\\<lambda>x. 3 * M / R * N powr x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod\n     (integral {- \\<delta>..0}\n       (\\<lambda>x. g (complex_of_real x + complex_of_real R' * \\<i>)))\n    \\<le> integral {- \\<delta>..0} (\\<lambda>x. 3 * M / R * real N powr x)", "proof (rule integral_norm_bound_integral)"], ["proof (state)\ngoal (3 subgoals):\n 1. (\\<lambda>x.\n        g (complex_of_real x + complex_of_real R' * \\<i>)) integrable_on\n    {- \\<delta>..0}\n 2. (\\<lambda>x. 3 * M / R * real N powr x) integrable_on {- \\<delta>..0}\n 3. \\<And>x.\n       x \\<in> {- \\<delta>..0} \\<Longrightarrow>\n       cmod (g (complex_of_real x + complex_of_real R' * \\<i>))\n       \\<le> 3 * M / R * real N powr x", "fix x"], ["proof (state)\ngoal (3 subgoals):\n 1. (\\<lambda>x.\n        g (complex_of_real x + complex_of_real R' * \\<i>)) integrable_on\n    {- \\<delta>..0}\n 2. (\\<lambda>x. 3 * M / R * real N powr x) integrable_on {- \\<delta>..0}\n 3. \\<And>x.\n       x \\<in> {- \\<delta>..0} \\<Longrightarrow>\n       cmod (g (complex_of_real x + complex_of_real R' * \\<i>))\n       \\<le> 3 * M / R * real N powr x", "assume x: \"x \\<in> {-\\<delta>..0}\""], ["proof (state)\nthis:\n  x \\<in> {- \\<delta>..0}\n\ngoal (3 subgoals):\n 1. (\\<lambda>x.\n        g (complex_of_real x + complex_of_real R' * \\<i>)) integrable_on\n    {- \\<delta>..0}\n 2. (\\<lambda>x. 3 * M / R * real N powr x) integrable_on {- \\<delta>..0}\n 3. \\<And>x.\n       x \\<in> {- \\<delta>..0} \\<Longrightarrow>\n       cmod (g (complex_of_real x + complex_of_real R' * \\<i>))\n       \\<le> 3 * M / R * real N powr x", "define z where \"z = x + \\<i> * R'\""], ["proof (state)\nthis:\n  z = complex_of_real x + \\<i> * complex_of_real R'\n\ngoal (3 subgoals):\n 1. (\\<lambda>x.\n        g (complex_of_real x + complex_of_real R' * \\<i>)) integrable_on\n    {- \\<delta>..0}\n 2. (\\<lambda>x. 3 * M / R * real N powr x) integrable_on {- \\<delta>..0}\n 3. \\<And>x.\n       x \\<in> {- \\<delta>..0} \\<Longrightarrow>\n       cmod (g (complex_of_real x + complex_of_real R' * \\<i>))\n       \\<le> 3 * M / R * real N powr x", "from R that"], ["proof (chain)\npicking this:\n  3 * C / \\<epsilon> \\<le> R\n  1 \\<le> R\n  \\<bar>R'\\<bar> = R", "have [simp]: \"z \\<noteq> 0\" \"Re z = x\" \"Im z = R'\""], ["proof (prove)\nusing this:\n  3 * C / \\<epsilon> \\<le> R\n  1 \\<le> R\n  \\<bar>R'\\<bar> = R\n\ngoal (1 subgoal):\n 1. z \\<noteq> 0 &&& Re z = x &&& Im z = R'", "by (auto simp: z_def complex_eq_iff)"], ["proof (state)\nthis:\n  z \\<noteq> 0\n  Re z = x\n  Im z = R'\n\ngoal (3 subgoals):\n 1. (\\<lambda>x.\n        g (complex_of_real x + complex_of_real R' * \\<i>)) integrable_on\n    {- \\<delta>..0}\n 2. (\\<lambda>x. 3 * M / R * real N powr x) integrable_on {- \\<delta>..0}\n 3. \\<And>x.\n       x \\<in> {- \\<delta>..0} \\<Longrightarrow>\n       cmod (g (complex_of_real x + complex_of_real R' * \\<i>))\n       \\<le> 3 * M / R * real N powr x", "from x R that"], ["proof (chain)\npicking this:\n  x \\<in> {- \\<delta>..0}\n  3 * C / \\<epsilon> \\<le> R\n  1 \\<le> R\n  \\<bar>R'\\<bar> = R", "have \"z \\<in> X'\""], ["proof (prove)\nusing this:\n  x \\<in> {- \\<delta>..0}\n  3 * C / \\<epsilon> \\<le> R\n  1 \\<le> R\n  \\<bar>R'\\<bar> = R\n\ngoal (1 subgoal):\n 1. z \\<in> X'", "by (auto simp: z_def X'_def in_cbox_complex_iff)"], ["proof (state)\nthis:\n  z \\<in> X'\n\ngoal (3 subgoals):\n 1. (\\<lambda>x.\n        g (complex_of_real x + complex_of_real R' * \\<i>)) integrable_on\n    {- \\<delta>..0}\n 2. (\\<lambda>x. 3 * M / R * real N powr x) integrable_on {- \\<delta>..0}\n 3. \\<And>x.\n       x \\<in> {- \\<delta>..0} \\<Longrightarrow>\n       cmod (g (complex_of_real x + complex_of_real R' * \\<i>))\n       \\<le> 3 * M / R * real N powr x", "from x R that"], ["proof (chain)\npicking this:\n  x \\<in> {- \\<delta>..0}\n  3 * C / \\<epsilon> \\<le> R\n  1 \\<le> R\n  \\<bar>R'\\<bar> = R", "have \"norm z \\<le> \\<delta> + R\""], ["proof (prove)\nusing this:\n  x \\<in> {- \\<delta>..0}\n  3 * C / \\<epsilon> \\<le> R\n  1 \\<le> R\n  \\<bar>R'\\<bar> = R\n\ngoal (1 subgoal):\n 1. cmod z \\<le> \\<delta> + R", "by (intro order.trans[OF cmod_le add_mono]) auto"], ["proof (state)\nthis:\n  cmod z \\<le> \\<delta> + R\n\ngoal (3 subgoals):\n 1. (\\<lambda>x.\n        g (complex_of_real x + complex_of_real R' * \\<i>)) integrable_on\n    {- \\<delta>..0}\n 2. (\\<lambda>x. 3 * M / R * real N powr x) integrable_on {- \\<delta>..0}\n 3. \\<And>x.\n       x \\<in> {- \\<delta>..0} \\<Longrightarrow>\n       cmod (g (complex_of_real x + complex_of_real R' * \\<i>))\n       \\<le> 3 * M / R * real N powr x", "hence \"norm (1 / z + z / R\\<^sup>2) \\<le> 1 / R + (\\<delta> / R + 1) / R\""], ["proof (prove)\nusing this:\n  cmod z \\<le> \\<delta> + R\n\ngoal (1 subgoal):\n 1. cmod (1 / z + z / complex_of_real (R\\<^sup>2))\n    \\<le> 1 / R + (\\<delta> / R + 1) / R", "using R that abs_Im_le_cmod[of z]"], ["proof (prove)\nusing this:\n  cmod z \\<le> \\<delta> + R\n  3 * C / \\<epsilon> \\<le> R\n  1 \\<le> R\n  \\<bar>R'\\<bar> = R\n  \\<bar>Im z\\<bar> \\<le> cmod z\n\ngoal (1 subgoal):\n 1. cmod (1 / z + z / complex_of_real (R\\<^sup>2))\n    \\<le> 1 / R + (\\<delta> / R + 1) / R", "by (intro order.trans[OF norm_triangle_ineq add_mono])\n               (auto simp: norm_divide norm_mult power2_eq_square field_simps )"], ["proof (state)\nthis:\n  cmod (1 / z + z / complex_of_real (R\\<^sup>2))\n  \\<le> 1 / R + (\\<delta> / R + 1) / R\n\ngoal (3 subgoals):\n 1. (\\<lambda>x.\n        g (complex_of_real x + complex_of_real R' * \\<i>)) integrable_on\n    {- \\<delta>..0}\n 2. (\\<lambda>x. 3 * M / R * real N powr x) integrable_on {- \\<delta>..0}\n 3. \\<And>x.\n       x \\<in> {- \\<delta>..0} \\<Longrightarrow>\n       cmod (g (complex_of_real x + complex_of_real R' * \\<i>))\n       \\<le> 3 * M / R * real N powr x", "also"], ["proof (state)\nthis:\n  cmod (1 / z + z / complex_of_real (R\\<^sup>2))\n  \\<le> 1 / R + (\\<delta> / R + 1) / R\n\ngoal (3 subgoals):\n 1. (\\<lambda>x.\n        g (complex_of_real x + complex_of_real R' * \\<i>)) integrable_on\n    {- \\<delta>..0}\n 2. (\\<lambda>x. 3 * M / R * real N powr x) integrable_on {- \\<delta>..0}\n 3. \\<And>x.\n       x \\<in> {- \\<delta>..0} \\<Longrightarrow>\n       cmod (g (complex_of_real x + complex_of_real R' * \\<i>))\n       \\<le> 3 * M / R * real N powr x", "have \"\\<delta> / R \\<le> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<delta> / R \\<le> 1", "using \\<delta> R"], ["proof (prove)\nusing this:\n  0 < \\<delta>\n  \\<delta> \\<le> 1 / 2\n  \\<delta> < l\n  3 * C / \\<epsilon> \\<le> R\n  1 \\<le> R\n\ngoal (1 subgoal):\n 1. \\<delta> / R \\<le> 1", "by auto"], ["proof (state)\nthis:\n  \\<delta> / R \\<le> 1\n\ngoal (3 subgoals):\n 1. (\\<lambda>x.\n        g (complex_of_real x + complex_of_real R' * \\<i>)) integrable_on\n    {- \\<delta>..0}\n 2. (\\<lambda>x. 3 * M / R * real N powr x) integrable_on {- \\<delta>..0}\n 3. \\<And>x.\n       x \\<in> {- \\<delta>..0} \\<Longrightarrow>\n       cmod (g (complex_of_real x + complex_of_real R' * \\<i>))\n       \\<le> 3 * M / R * real N powr x", "finally"], ["proof (chain)\npicking this:\n  (\\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      1 / R + (x + 1) / R \\<le> 1 / R + (y + 1) / R) \\<Longrightarrow>\n  cmod (1 / z + z / complex_of_real (R\\<^sup>2)) \\<le> 1 / R + (1 + 1) / R", "have \"norm (1 / z + z / R\\<^sup>2) \\<le> 3 / R\""], ["proof (prove)\nusing this:\n  (\\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      1 / R + (x + 1) / R \\<le> 1 / R + (y + 1) / R) \\<Longrightarrow>\n  cmod (1 / z + z / complex_of_real (R\\<^sup>2)) \\<le> 1 / R + (1 + 1) / R\n\ngoal (1 subgoal):\n 1. cmod (1 / z + z / complex_of_real (R\\<^sup>2)) \\<le> 3 / R", "using R"], ["proof (prove)\nusing this:\n  (\\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      1 / R + (x + 1) / R \\<le> 1 / R + (y + 1) / R) \\<Longrightarrow>\n  cmod (1 / z + z / complex_of_real (R\\<^sup>2)) \\<le> 1 / R + (1 + 1) / R\n  3 * C / \\<epsilon> \\<le> R\n  1 \\<le> R\n\ngoal (1 subgoal):\n 1. cmod (1 / z + z / complex_of_real (R\\<^sup>2)) \\<le> 3 / R", "by (simp add: divide_right_mono)"], ["proof (state)\nthis:\n  cmod (1 / z + z / complex_of_real (R\\<^sup>2)) \\<le> 3 / R\n\ngoal (3 subgoals):\n 1. (\\<lambda>x.\n        g (complex_of_real x + complex_of_real R' * \\<i>)) integrable_on\n    {- \\<delta>..0}\n 2. (\\<lambda>x. 3 * M / R * real N powr x) integrable_on {- \\<delta>..0}\n 3. \\<And>x.\n       x \\<in> {- \\<delta>..0} \\<Longrightarrow>\n       cmod (g (complex_of_real x + complex_of_real R' * \\<i>))\n       \\<le> 3 * M / R * real N powr x", "hence \"norm (g z) \\<le> M * N powr x * (3 / R)\""], ["proof (prove)\nusing this:\n  cmod (1 / z + z / complex_of_real (R\\<^sup>2)) \\<le> 3 / R\n\ngoal (1 subgoal):\n 1. cmod (g z) \\<le> M * real N powr x * (3 / R)", "unfolding g_def norm_mult"], ["proof (prove)\nusing this:\n  cmod (1 / z + z / complex_of_real (R\\<^sup>2)) \\<le> 3 / R\n\ngoal (1 subgoal):\n 1. cmod (f (w + z)) * cmod (of_nat N powr z) *\n    cmod (1 / z + z / complex_of_real (R\\<^sup>2))\n    \\<le> M * real N powr x * (3 / R)", "using \\<open>M \\<ge> 0\\<close> \\<open>z \\<in> X'\\<close>"], ["proof (prove)\nusing this:\n  cmod (1 / z + z / complex_of_real (R\\<^sup>2)) \\<le> 3 / R\n  0 \\<le> M\n  z \\<in> X'\n\ngoal (1 subgoal):\n 1. cmod (f (w + z)) * cmod (of_nat N powr z) *\n    cmod (1 / z + z / complex_of_real (R\\<^sup>2))\n    \\<le> M * real N powr x * (3 / R)", "by (intro mult_mono mult_nonneg_nonneg M) (auto simp: norm_powr_real_powr)"], ["proof (state)\nthis:\n  cmod (g z) \\<le> M * real N powr x * (3 / R)\n\ngoal (3 subgoals):\n 1. (\\<lambda>x.\n        g (complex_of_real x + complex_of_real R' * \\<i>)) integrable_on\n    {- \\<delta>..0}\n 2. (\\<lambda>x. 3 * M / R * real N powr x) integrable_on {- \\<delta>..0}\n 3. \\<And>x.\n       x \\<in> {- \\<delta>..0} \\<Longrightarrow>\n       cmod (g (complex_of_real x + complex_of_real R' * \\<i>))\n       \\<le> 3 * M / R * real N powr x", "thus \"norm (g (x + R' * \\<i>)) \\<le> 3 * M / R * N powr x\""], ["proof (prove)\nusing this:\n  cmod (g z) \\<le> M * real N powr x * (3 / R)\n\ngoal (1 subgoal):\n 1. cmod (g (complex_of_real x + complex_of_real R' * \\<i>))\n    \\<le> 3 * M / R * real N powr x", "by (simp add: mult_ac z_def)"], ["proof (state)\nthis:\n  cmod (g (complex_of_real x + complex_of_real R' * \\<i>))\n  \\<le> 3 * M / R * real N powr x\n\ngoal (2 subgoals):\n 1. (\\<lambda>x.\n        g (complex_of_real x + complex_of_real R' * \\<i>)) integrable_on\n    {- \\<delta>..0}\n 2. (\\<lambda>x. 3 * M / R * real N powr x) integrable_on {- \\<delta>..0}", "qed (insert N R l that \\<delta>, auto intro!: integrable_continuous_real continuous_intros\n                                  simp: g_def X_def complex_eq_iff in_box_complex_iff)"], ["proof (state)\nthis:\n  cmod\n   (integral {- \\<delta>..0}\n     (\\<lambda>x. g (complex_of_real x + complex_of_real R' * \\<i>)))\n  \\<le> integral {- \\<delta>..0} (\\<lambda>x. 3 * M / R * real N powr x)\n\ngoal (1 subgoal):\n 1. cmod\n     (integral {- \\<delta>..0}\n       (\\<lambda>x. g (complex_of_real x + complex_of_real R' * \\<i>)))\n    \\<le> 3 * M / R / ln (real N)", "also"], ["proof (state)\nthis:\n  cmod\n   (integral {- \\<delta>..0}\n     (\\<lambda>x. g (complex_of_real x + complex_of_real R' * \\<i>)))\n  \\<le> integral {- \\<delta>..0} (\\<lambda>x. 3 * M / R * real N powr x)\n\ngoal (1 subgoal):\n 1. cmod\n     (integral {- \\<delta>..0}\n       (\\<lambda>x. g (complex_of_real x + complex_of_real R' * \\<i>)))\n    \\<le> 3 * M / R / ln (real N)", "have \"\\<dots> = 3 * M / R * integral {-\\<delta>..0} (\\<lambda>x. N powr x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. integral {- \\<delta>..0} (\\<lambda>x. 3 * M / R * real N powr x) =\n    3 * M / R * integral {- \\<delta>..0} ((powr) (real N))", "by simp"], ["proof (state)\nthis:\n  integral {- \\<delta>..0} (\\<lambda>x. 3 * M / R * real N powr x) =\n  3 * M / R * integral {- \\<delta>..0} ((powr) (real N))\n\ngoal (1 subgoal):\n 1. cmod\n     (integral {- \\<delta>..0}\n       (\\<lambda>x. g (complex_of_real x + complex_of_real R' * \\<i>)))\n    \\<le> 3 * M / R / ln (real N)", "also"], ["proof (state)\nthis:\n  integral {- \\<delta>..0} (\\<lambda>x. 3 * M / R * real N powr x) =\n  3 * M / R * integral {- \\<delta>..0} ((powr) (real N))\n\ngoal (1 subgoal):\n 1. cmod\n     (integral {- \\<delta>..0}\n       (\\<lambda>x. g (complex_of_real x + complex_of_real R' * \\<i>)))\n    \\<le> 3 * M / R / ln (real N)", "have \"((\\<lambda>x. N powr x) has_integral (N powr 0 / ln N - N powr (-\\<delta>) / ln N)) {-\\<delta>..0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((powr) (real N) has_integral\n     real N powr 0 / ln (real N) - real N powr - \\<delta> / ln (real N))\n     {- \\<delta>..0}", "using \\<delta> N"], ["proof (prove)\nusing this:\n  0 < \\<delta>\n  \\<delta> \\<le> 1 / 2\n  \\<delta> < l\n  bound N < \\<epsilon>\n  1 < N\n\ngoal (1 subgoal):\n 1. ((powr) (real N) has_integral\n     real N powr 0 / ln (real N) - real N powr - \\<delta> / ln (real N))\n     {- \\<delta>..0}", "by (intro fundamental_theorem_of_calculus)\n             (auto simp: has_field_derivative_iff_has_vector_derivative [symmetric] powr_def\n                   intro!: derivative_eq_intros)"], ["proof (state)\nthis:\n  ((powr) (real N) has_integral\n   real N powr 0 / ln (real N) - real N powr - \\<delta> / ln (real N))\n   {- \\<delta>..0}\n\ngoal (1 subgoal):\n 1. cmod\n     (integral {- \\<delta>..0}\n       (\\<lambda>x. g (complex_of_real x + complex_of_real R' * \\<i>)))\n    \\<le> 3 * M / R / ln (real N)", "hence \"integral {-\\<delta>..0} (\\<lambda>x. N powr x) = 1 / ln (real N) - real N powr - \\<delta> / ln (real N)\""], ["proof (prove)\nusing this:\n  ((powr) (real N) has_integral\n   real N powr 0 / ln (real N) - real N powr - \\<delta> / ln (real N))\n   {- \\<delta>..0}\n\ngoal (1 subgoal):\n 1. integral {- \\<delta>..0} ((powr) (real N)) =\n    1 / ln (real N) - real N powr - \\<delta> / ln (real N)", "using N"], ["proof (prove)\nusing this:\n  ((powr) (real N) has_integral\n   real N powr 0 / ln (real N) - real N powr - \\<delta> / ln (real N))\n   {- \\<delta>..0}\n  bound N < \\<epsilon>\n  1 < N\n\ngoal (1 subgoal):\n 1. integral {- \\<delta>..0} ((powr) (real N)) =\n    1 / ln (real N) - real N powr - \\<delta> / ln (real N)", "by (simp add: has_integral_iff)"], ["proof (state)\nthis:\n  integral {- \\<delta>..0} ((powr) (real N)) =\n  1 / ln (real N) - real N powr - \\<delta> / ln (real N)\n\ngoal (1 subgoal):\n 1. cmod\n     (integral {- \\<delta>..0}\n       (\\<lambda>x. g (complex_of_real x + complex_of_real R' * \\<i>)))\n    \\<le> 3 * M / R / ln (real N)", "also"], ["proof (state)\nthis:\n  integral {- \\<delta>..0} ((powr) (real N)) =\n  1 / ln (real N) - real N powr - \\<delta> / ln (real N)\n\ngoal (1 subgoal):\n 1. cmod\n     (integral {- \\<delta>..0}\n       (\\<lambda>x. g (complex_of_real x + complex_of_real R' * \\<i>)))\n    \\<le> 3 * M / R / ln (real N)", "have \"\\<dots> \\<le> 1 / ln (real N)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 / ln (real N) - real N powr - \\<delta> / ln (real N)\n    \\<le> 1 / ln (real N)", "using N"], ["proof (prove)\nusing this:\n  bound N < \\<epsilon>\n  1 < N\n\ngoal (1 subgoal):\n 1. 1 / ln (real N) - real N powr - \\<delta> / ln (real N)\n    \\<le> 1 / ln (real N)", "by simp"], ["proof (state)\nthis:\n  1 / ln (real N) - real N powr - \\<delta> / ln (real N)\n  \\<le> 1 / ln (real N)\n\ngoal (1 subgoal):\n 1. cmod\n     (integral {- \\<delta>..0}\n       (\\<lambda>x. g (complex_of_real x + complex_of_real R' * \\<i>)))\n    \\<le> 3 * M / R / ln (real N)", "finally"], ["proof (chain)\npicking this:\n  (\\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      3 * M / R * x \\<le> 3 * M / R * y) \\<Longrightarrow>\n  cmod\n   (integral {- \\<delta>..0}\n     (\\<lambda>x. g (complex_of_real x + complex_of_real R' * \\<i>)))\n  \\<le> 3 * M / R * (1 / ln (real N))", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      3 * M / R * x \\<le> 3 * M / R * y) \\<Longrightarrow>\n  cmod\n   (integral {- \\<delta>..0}\n     (\\<lambda>x. g (complex_of_real x + complex_of_real R' * \\<i>)))\n  \\<le> 3 * M / R * (1 / ln (real N))\n\ngoal (1 subgoal):\n 1. cmod\n     (integral {- \\<delta>..0}\n       (\\<lambda>x. g (complex_of_real x + complex_of_real R' * \\<i>)))\n    \\<le> 3 * M / R / ln (real N)", "using M R"], ["proof (prove)\nusing this:\n  (\\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      3 * M / R * x \\<le> 3 * M / R * y) \\<Longrightarrow>\n  cmod\n   (integral {- \\<delta>..0}\n     (\\<lambda>x. g (complex_of_real x + complex_of_real R' * \\<i>)))\n  \\<le> 3 * M / R * (1 / ln (real N))\n  0 \\<le> M\n  ?z \\<in> X' \\<Longrightarrow> cmod (f (w + ?z)) \\<le> M\n  3 * C / \\<epsilon> \\<le> R\n  1 \\<le> R\n\ngoal (1 subgoal):\n 1. cmod\n     (integral {- \\<delta>..0}\n       (\\<lambda>x. g (complex_of_real x + complex_of_real R' * \\<i>)))\n    \\<le> 3 * M / R / ln (real N)", "by (simp add: mult_left_mono divide_right_mono)"], ["proof (state)\nthis:\n  cmod\n   (integral {- \\<delta>..0}\n     (\\<lambda>x. g (complex_of_real x + complex_of_real R' * \\<i>)))\n  \\<le> 3 * M / R / ln (real N)\n\ngoal:\nNo subgoals!", "qed\n\n      \\<comment> \\<open>We combine the two results from the residue theorem and obtain an integral\n          representation of the difference between the partial sums and the limit:\\<close>"], ["proof (state)\nthis:\n  \\<bar>?R'\\<bar> = R \\<Longrightarrow>\n  cmod\n   (integral {- \\<delta>..0}\n     (\\<lambda>x. g (complex_of_real x + complex_of_real ?R' * \\<i>)))\n  \\<le> 3 * M / R / ln (real N)\n\ngoal (1 subgoal):\n 1. \\<And>N.\n       \\<lbrakk>bound N < \\<epsilon>; 1 < N\\<rbrakk>\n       \\<Longrightarrow> cmod (f w - eval_fds (fds_truncate N F) w)\n                         < \\<epsilon>", "have \"2 * pi * \\<i> * (f w - S w) =\n              \\<ointegral>[A] g - \\<ointegral>[A] g_S + \\<ointegral>[A] (\\<lambda>x. g_S (-x)) + \\<ointegral>[B1] g + \\<ointegral>[B3] g + \\<ointegral>[B2] g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. complex_of_real (2 * pi) * \\<i> * (f w - S w) =\n    \\<ointegral>[A] g - \\<ointegral>[A] g_S +\n    \\<ointegral>[A] (\\<lambda>x. g_S (- x)) +\n    \\<ointegral>[B1] g +\n    \\<ointegral>[B3] g +\n    \\<ointegral>[B2] g", "unfolding ring_distribs integral1 integral2"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<ointegral>[A] g + \\<ointegral>[B2] g + \\<ointegral>[B1] g +\n    \\<ointegral>[B3] g -\n    (\\<ointegral>[A] g_S - \\<ointegral>[A] (\\<lambda>x. g_S (- x))) =\n    \\<ointegral>[A] g - \\<ointegral>[A] g_S +\n    \\<ointegral>[A] (\\<lambda>x. g_S (- x)) +\n    \\<ointegral>[B1] g +\n    \\<ointegral>[B3] g +\n    \\<ointegral>[B2] g", "by (simp add: algebra_simps)"], ["proof (state)\nthis:\n  complex_of_real (2 * pi) * \\<i> * (f w - S w) =\n  \\<ointegral>[A] g - \\<ointegral>[A] g_S +\n  \\<ointegral>[A] (\\<lambda>x. g_S (- x)) +\n  \\<ointegral>[B1] g +\n  \\<ointegral>[B3] g +\n  \\<ointegral>[B2] g\n\ngoal (1 subgoal):\n 1. \\<And>N.\n       \\<lbrakk>bound N < \\<epsilon>; 1 < N\\<rbrakk>\n       \\<Longrightarrow> cmod (f w - eval_fds (fds_truncate N F) w)\n                         < \\<epsilon>", "also"], ["proof (state)\nthis:\n  complex_of_real (2 * pi) * \\<i> * (f w - S w) =\n  \\<ointegral>[A] g - \\<ointegral>[A] g_S +\n  \\<ointegral>[A] (\\<lambda>x. g_S (- x)) +\n  \\<ointegral>[B1] g +\n  \\<ointegral>[B3] g +\n  \\<ointegral>[B2] g\n\ngoal (1 subgoal):\n 1. \\<And>N.\n       \\<lbrakk>bound N < \\<epsilon>; 1 < N\\<rbrakk>\n       \\<Longrightarrow> cmod (f w - eval_fds (fds_truncate N F) w)\n                         < \\<epsilon>", "have \"\\<ointegral>[A] g - \\<ointegral>[A] g_S = \\<ointegral>[A] (\\<lambda>x. g x - g_S x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<ointegral>[A] g - \\<ointegral>[A] g_S =\n    \\<ointegral>[A] (\\<lambda>x. g x - g_S x)", "using path_images"], ["proof (prove)\nusing this:\n  path_image B2 \\<subseteq> X' - {0}\n  path_image A \\<subseteq> X' - {0}\n  path_image B1 \\<subseteq> X' - {0}\n  path_image B3 \\<subseteq> X' - {0}\n  X' \\<subseteq> X\n\ngoal (1 subgoal):\n 1. \\<ointegral>[A] g - \\<ointegral>[A] g_S =\n    \\<ointegral>[A] (\\<lambda>x. g x - g_S x)", "by (intro contour_integral_diff [symmetric])\n           (auto intro!: contour_integrable_holomorphic_simple[of _ \"X - {0}\"] holomorphic_intros\n                 simp: g_S_def g_holo S_def)"], ["proof (state)\nthis:\n  \\<ointegral>[A] g - \\<ointegral>[A] g_S =\n  \\<ointegral>[A] (\\<lambda>x. g x - g_S x)\n\ngoal (1 subgoal):\n 1. \\<And>N.\n       \\<lbrakk>bound N < \\<epsilon>; 1 < N\\<rbrakk>\n       \\<Longrightarrow> cmod (f w - eval_fds (fds_truncate N F) w)\n                         < \\<epsilon>", "also"], ["proof (state)\nthis:\n  \\<ointegral>[A] g - \\<ointegral>[A] g_S =\n  \\<ointegral>[A] (\\<lambda>x. g x - g_S x)\n\ngoal (1 subgoal):\n 1. \\<And>N.\n       \\<lbrakk>bound N < \\<epsilon>; 1 < N\\<rbrakk>\n       \\<Longrightarrow> cmod (f w - eval_fds (fds_truncate N F) w)\n                         < \\<epsilon>", "have \"\\<dots> = \\<ointegral>[A] g_rem\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<ointegral>[A] (\\<lambda>x. g x - g_S x) = \\<ointegral>[A] g_rem", "by (simp add: g_rem_def g_def g_S_def algebra_simps rem_def)"], ["proof (state)\nthis:\n  \\<ointegral>[A] (\\<lambda>x. g x - g_S x) = \\<ointegral>[A] g_rem\n\ngoal (1 subgoal):\n 1. \\<And>N.\n       \\<lbrakk>bound N < \\<epsilon>; 1 < N\\<rbrakk>\n       \\<Longrightarrow> cmod (f w - eval_fds (fds_truncate N F) w)\n                         < \\<epsilon>", "finally"], ["proof (chain)\npicking this:\n  complex_of_real (2 * pi) * \\<i> * (f w - S w) =\n  \\<ointegral>[A] g_rem + \\<ointegral>[A] (\\<lambda>x. g_S (- x)) +\n  \\<ointegral>[B1] g +\n  \\<ointegral>[B3] g +\n  \\<ointegral>[B2] g", "have \"2 * pi * \\<i> * (f w - S w) =\n                      \\<ointegral>[A] g_rem + \\<ointegral>[A] (\\<lambda>x. g_S (- x)) + \\<ointegral>[B1] g + \\<ointegral>[B3] g + \\<ointegral>[B2] g\""], ["proof (prove)\nusing this:\n  complex_of_real (2 * pi) * \\<i> * (f w - S w) =\n  \\<ointegral>[A] g_rem + \\<ointegral>[A] (\\<lambda>x. g_S (- x)) +\n  \\<ointegral>[B1] g +\n  \\<ointegral>[B3] g +\n  \\<ointegral>[B2] g\n\ngoal (1 subgoal):\n 1. complex_of_real (2 * pi) * \\<i> * (f w - S w) =\n    \\<ointegral>[A] g_rem + \\<ointegral>[A] (\\<lambda>x. g_S (- x)) +\n    \\<ointegral>[B1] g +\n    \\<ointegral>[B3] g +\n    \\<ointegral>[B2] g", ".\n\n      \\<comment> \\<open>We now bound each of these integrals individually:\\<close>"], ["proof (state)\nthis:\n  complex_of_real (2 * pi) * \\<i> * (f w - S w) =\n  \\<ointegral>[A] g_rem + \\<ointegral>[A] (\\<lambda>x. g_S (- x)) +\n  \\<ointegral>[B1] g +\n  \\<ointegral>[B3] g +\n  \\<ointegral>[B2] g\n\ngoal (1 subgoal):\n 1. \\<And>N.\n       \\<lbrakk>bound N < \\<epsilon>; 1 < N\\<rbrakk>\n       \\<Longrightarrow> cmod (f w - eval_fds (fds_truncate N F) w)\n                         < \\<epsilon>", "also"], ["proof (state)\nthis:\n  complex_of_real (2 * pi) * \\<i> * (f w - S w) =\n  \\<ointegral>[A] g_rem + \\<ointegral>[A] (\\<lambda>x. g_S (- x)) +\n  \\<ointegral>[B1] g +\n  \\<ointegral>[B3] g +\n  \\<ointegral>[B2] g\n\ngoal (1 subgoal):\n 1. \\<And>N.\n       \\<lbrakk>bound N < \\<epsilon>; 1 < N\\<rbrakk>\n       \\<Longrightarrow> cmod (f w - eval_fds (fds_truncate N F) w)\n                         < \\<epsilon>", "have \"norm \\<dots> \\<le> 2 * C * pi / R  +  2 * C * pi * (1 / N + 1 / R)  +  3 * M / R / ln N  +\n                             3 * M / R / ln N  +  6 * R * M * N powr (-\\<delta>) / \\<delta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod\n     (\\<ointegral>[A] g_rem + \\<ointegral>[A] (\\<lambda>x. g_S (- x)) +\n      \\<ointegral>[B1] g +\n      \\<ointegral>[B3] g +\n      \\<ointegral>[B2] g)\n    \\<le> 2 * C * pi / R + 2 * C * pi * (1 / real N + 1 / R) +\n          3 * M / R / ln (real N) +\n          3 * M / R / ln (real N) +\n          6 * R * M * real N powr - \\<delta> / \\<delta>", "proof (rule order.trans[OF norm_triangle_ineq] add_mono)+"], ["proof (state)\ngoal (5 subgoals):\n 1. cmod (\\<ointegral>[A] g_rem) \\<le> 2 * C * pi / R\n 2. cmod (\\<ointegral>[A] (\\<lambda>x. g_S (- x)))\n    \\<le> 2 * C * pi * (1 / real N + 1 / R)\n 3. cmod (\\<ointegral>[B1] g) \\<le> 3 * M / R / ln (real N)\n 4. cmod (\\<ointegral>[B3] g) \\<le> 3 * M / R / ln (real N)\n 5. cmod (\\<ointegral>[B2] g)\n    \\<le> 6 * R * M * real N powr - \\<delta> / \\<delta>", "have \"\\<ointegral>[B1] g = -\\<ointegral>[reversepath B1] g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<ointegral>[B1] g = - \\<ointegral>[reversepath B1] g", "by (simp add: contour_integral_reversepath)"], ["proof (state)\nthis:\n  \\<ointegral>[B1] g = - \\<ointegral>[reversepath B1] g\n\ngoal (5 subgoals):\n 1. cmod (\\<ointegral>[A] g_rem) \\<le> 2 * C * pi / R\n 2. cmod (\\<ointegral>[A] (\\<lambda>x. g_S (- x)))\n    \\<le> 2 * C * pi * (1 / real N + 1 / R)\n 3. cmod (\\<ointegral>[B1] g) \\<le> 3 * M / R / ln (real N)\n 4. cmod (\\<ointegral>[B3] g) \\<le> 3 * M / R / ln (real N)\n 5. cmod (\\<ointegral>[B2] g)\n    \\<le> 6 * R * M * real N powr - \\<delta> / \\<delta>", "also"], ["proof (state)\nthis:\n  \\<ointegral>[B1] g = - \\<ointegral>[reversepath B1] g\n\ngoal (5 subgoals):\n 1. cmod (\\<ointegral>[A] g_rem) \\<le> 2 * C * pi / R\n 2. cmod (\\<ointegral>[A] (\\<lambda>x. g_S (- x)))\n    \\<le> 2 * C * pi * (1 / real N + 1 / R)\n 3. cmod (\\<ointegral>[B1] g) \\<le> 3 * M / R / ln (real N)\n 4. cmod (\\<ointegral>[B3] g) \\<le> 3 * M / R / ln (real N)\n 5. cmod (\\<ointegral>[B2] g)\n    \\<le> 6 * R * M * real N powr - \\<delta> / \\<delta>", "have \"\\<ointegral>[reversepath B1] g = integral {-\\<delta>..0} (\\<lambda>x. g (x + R * \\<i>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<ointegral>[reversepath B1] g =\n    integral {- \\<delta>..0}\n     (\\<lambda>x. g (complex_of_real x + complex_of_real R * \\<i>))", "unfolding B1_def reversepath_linepath"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<ointegral>[linepath\n                  (complex_of_real R * \\<i> - complex_of_real \\<delta>)\n                  (complex_of_real R * \\<i>)]\n     g =\n    integral {- \\<delta>..0}\n     (\\<lambda>x. g (complex_of_real x + complex_of_real R * \\<i>))", "using \\<delta>"], ["proof (prove)\nusing this:\n  0 < \\<delta>\n  \\<delta> \\<le> 1 / 2\n  \\<delta> < l\n\ngoal (1 subgoal):\n 1. \\<ointegral>[linepath\n                  (complex_of_real R * \\<i> - complex_of_real \\<delta>)\n                  (complex_of_real R * \\<i>)]\n     g =\n    integral {- \\<delta>..0}\n     (\\<lambda>x. g (complex_of_real x + complex_of_real R * \\<i>))", "by (subst contour_integral_linepath_same_Im) auto"], ["proof (state)\nthis:\n  \\<ointegral>[reversepath B1] g =\n  integral {- \\<delta>..0}\n   (\\<lambda>x. g (complex_of_real x + complex_of_real R * \\<i>))\n\ngoal (5 subgoals):\n 1. cmod (\\<ointegral>[A] g_rem) \\<le> 2 * C * pi / R\n 2. cmod (\\<ointegral>[A] (\\<lambda>x. g_S (- x)))\n    \\<le> 2 * C * pi * (1 / real N + 1 / R)\n 3. cmod (\\<ointegral>[B1] g) \\<le> 3 * M / R / ln (real N)\n 4. cmod (\\<ointegral>[B3] g) \\<le> 3 * M / R / ln (real N)\n 5. cmod (\\<ointegral>[B2] g)\n    \\<le> 6 * R * M * real N powr - \\<delta> / \\<delta>", "also"], ["proof (state)\nthis:\n  \\<ointegral>[reversepath B1] g =\n  integral {- \\<delta>..0}\n   (\\<lambda>x. g (complex_of_real x + complex_of_real R * \\<i>))\n\ngoal (5 subgoals):\n 1. cmod (\\<ointegral>[A] g_rem) \\<le> 2 * C * pi / R\n 2. cmod (\\<ointegral>[A] (\\<lambda>x. g_S (- x)))\n    \\<le> 2 * C * pi * (1 / real N + 1 / R)\n 3. cmod (\\<ointegral>[B1] g) \\<le> 3 * M / R / ln (real N)\n 4. cmod (\\<ointegral>[B3] g) \\<le> 3 * M / R / ln (real N)\n 5. cmod (\\<ointegral>[B2] g)\n    \\<le> 6 * R * M * real N powr - \\<delta> / \\<delta>", "have \"norm (-\\<dots>) = norm \\<dots>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod\n     (- integral {- \\<delta>..0}\n         (\\<lambda>x. g (complex_of_real x + complex_of_real R * \\<i>))) =\n    cmod\n     (integral {- \\<delta>..0}\n       (\\<lambda>x. g (complex_of_real x + complex_of_real R * \\<i>)))", "by simp"], ["proof (state)\nthis:\n  cmod\n   (- integral {- \\<delta>..0}\n       (\\<lambda>x. g (complex_of_real x + complex_of_real R * \\<i>))) =\n  cmod\n   (integral {- \\<delta>..0}\n     (\\<lambda>x. g (complex_of_real x + complex_of_real R * \\<i>)))\n\ngoal (5 subgoals):\n 1. cmod (\\<ointegral>[A] g_rem) \\<le> 2 * C * pi / R\n 2. cmod (\\<ointegral>[A] (\\<lambda>x. g_S (- x)))\n    \\<le> 2 * C * pi * (1 / real N + 1 / R)\n 3. cmod (\\<ointegral>[B1] g) \\<le> 3 * M / R / ln (real N)\n 4. cmod (\\<ointegral>[B3] g) \\<le> 3 * M / R / ln (real N)\n 5. cmod (\\<ointegral>[B2] g)\n    \\<le> 6 * R * M * real N powr - \\<delta> / \\<delta>", "also"], ["proof (state)\nthis:\n  cmod\n   (- integral {- \\<delta>..0}\n       (\\<lambda>x. g (complex_of_real x + complex_of_real R * \\<i>))) =\n  cmod\n   (integral {- \\<delta>..0}\n     (\\<lambda>x. g (complex_of_real x + complex_of_real R * \\<i>)))\n\ngoal (5 subgoals):\n 1. cmod (\\<ointegral>[A] g_rem) \\<le> 2 * C * pi / R\n 2. cmod (\\<ointegral>[A] (\\<lambda>x. g_S (- x)))\n    \\<le> 2 * C * pi * (1 / real N + 1 / R)\n 3. cmod (\\<ointegral>[B1] g) \\<le> 3 * M / R / ln (real N)\n 4. cmod (\\<ointegral>[B3] g) \\<le> 3 * M / R / ln (real N)\n 5. cmod (\\<ointegral>[B2] g)\n    \\<le> 6 * R * M * real N powr - \\<delta> / \\<delta>", "have \"\\<dots> \\<le> 3 * M / R / ln N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod\n     (integral {- \\<delta>..0}\n       (\\<lambda>x. g (complex_of_real x + complex_of_real R * \\<i>)))\n    \\<le> 3 * M / R / ln (real N)", "using R"], ["proof (prove)\nusing this:\n  3 * C / \\<epsilon> \\<le> R\n  1 \\<le> R\n\ngoal (1 subgoal):\n 1. cmod\n     (integral {- \\<delta>..0}\n       (\\<lambda>x. g (complex_of_real x + complex_of_real R * \\<i>)))\n    \\<le> 3 * M / R / ln (real N)", "by (intro B12_bound) auto"], ["proof (state)\nthis:\n  cmod\n   (integral {- \\<delta>..0}\n     (\\<lambda>x. g (complex_of_real x + complex_of_real R * \\<i>)))\n  \\<le> 3 * M / R / ln (real N)\n\ngoal (5 subgoals):\n 1. cmod (\\<ointegral>[A] g_rem) \\<le> 2 * C * pi / R\n 2. cmod (\\<ointegral>[A] (\\<lambda>x. g_S (- x)))\n    \\<le> 2 * C * pi * (1 / real N + 1 / R)\n 3. cmod (\\<ointegral>[B1] g) \\<le> 3 * M / R / ln (real N)\n 4. cmod (\\<ointegral>[B3] g) \\<le> 3 * M / R / ln (real N)\n 5. cmod (\\<ointegral>[B2] g)\n    \\<le> 6 * R * M * real N powr - \\<delta> / \\<delta>", "finally"], ["proof (chain)\npicking this:\n  cmod (\\<ointegral>[B1] g) \\<le> 3 * M / R / ln (real N)", "show \"norm (\\<ointegral>[B1] g) \\<le> \\<dots>\""], ["proof (prove)\nusing this:\n  cmod (\\<ointegral>[B1] g) \\<le> 3 * M / R / ln (real N)\n\ngoal (1 subgoal):\n 1. cmod (\\<ointegral>[B1] g) \\<le> 3 * M / R / ln (real N)", "."], ["proof (state)\nthis:\n  cmod (\\<ointegral>[B1] g) \\<le> 3 * M / R / ln (real N)\n\ngoal (4 subgoals):\n 1. cmod (\\<ointegral>[A] g_rem) \\<le> 2 * C * pi / R\n 2. cmod (\\<ointegral>[A] (\\<lambda>x. g_S (- x)))\n    \\<le> 2 * C * pi * (1 / real N + 1 / R)\n 3. cmod (\\<ointegral>[B3] g) \\<le> 3 * M / R / ln (real N)\n 4. cmod (\\<ointegral>[B2] g)\n    \\<le> 6 * R * M * real N powr - \\<delta> / \\<delta>", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. cmod (\\<ointegral>[A] g_rem) \\<le> 2 * C * pi / R\n 2. cmod (\\<ointegral>[A] (\\<lambda>x. g_S (- x)))\n    \\<le> 2 * C * pi * (1 / real N + 1 / R)\n 3. cmod (\\<ointegral>[B3] g) \\<le> 3 * M / R / ln (real N)\n 4. cmod (\\<ointegral>[B2] g)\n    \\<le> 6 * R * M * real N powr - \\<delta> / \\<delta>", "have \"\\<ointegral>[B3] g = integral {-\\<delta>..0} (\\<lambda>x. g (x + (-R) * \\<i>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<ointegral>[B3] g =\n    integral {- \\<delta>..0}\n     (\\<lambda>x. g (complex_of_real x + complex_of_real (- R) * \\<i>))", "unfolding B3_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<ointegral>[linepath\n                  (complex_of_real (- R) * \\<i> - complex_of_real \\<delta>)\n                  (complex_of_real (- R) * \\<i>)]\n     g =\n    integral {- \\<delta>..0}\n     (\\<lambda>x. g (complex_of_real x + complex_of_real (- R) * \\<i>))", "using \\<delta>"], ["proof (prove)\nusing this:\n  0 < \\<delta>\n  \\<delta> \\<le> 1 / 2\n  \\<delta> < l\n\ngoal (1 subgoal):\n 1. \\<ointegral>[linepath\n                  (complex_of_real (- R) * \\<i> - complex_of_real \\<delta>)\n                  (complex_of_real (- R) * \\<i>)]\n     g =\n    integral {- \\<delta>..0}\n     (\\<lambda>x. g (complex_of_real x + complex_of_real (- R) * \\<i>))", "by (subst contour_integral_linepath_same_Im) auto"], ["proof (state)\nthis:\n  \\<ointegral>[B3] g =\n  integral {- \\<delta>..0}\n   (\\<lambda>x. g (complex_of_real x + complex_of_real (- R) * \\<i>))\n\ngoal (4 subgoals):\n 1. cmod (\\<ointegral>[A] g_rem) \\<le> 2 * C * pi / R\n 2. cmod (\\<ointegral>[A] (\\<lambda>x. g_S (- x)))\n    \\<le> 2 * C * pi * (1 / real N + 1 / R)\n 3. cmod (\\<ointegral>[B3] g) \\<le> 3 * M / R / ln (real N)\n 4. cmod (\\<ointegral>[B2] g)\n    \\<le> 6 * R * M * real N powr - \\<delta> / \\<delta>", "also"], ["proof (state)\nthis:\n  \\<ointegral>[B3] g =\n  integral {- \\<delta>..0}\n   (\\<lambda>x. g (complex_of_real x + complex_of_real (- R) * \\<i>))\n\ngoal (4 subgoals):\n 1. cmod (\\<ointegral>[A] g_rem) \\<le> 2 * C * pi / R\n 2. cmod (\\<ointegral>[A] (\\<lambda>x. g_S (- x)))\n    \\<le> 2 * C * pi * (1 / real N + 1 / R)\n 3. cmod (\\<ointegral>[B3] g) \\<le> 3 * M / R / ln (real N)\n 4. cmod (\\<ointegral>[B2] g)\n    \\<le> 6 * R * M * real N powr - \\<delta> / \\<delta>", "have \"norm \\<dots> \\<le> 3 * M / R / ln N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod\n     (integral {- \\<delta>..0}\n       (\\<lambda>x. g (complex_of_real x + complex_of_real (- R) * \\<i>)))\n    \\<le> 3 * M / R / ln (real N)", "using R"], ["proof (prove)\nusing this:\n  3 * C / \\<epsilon> \\<le> R\n  1 \\<le> R\n\ngoal (1 subgoal):\n 1. cmod\n     (integral {- \\<delta>..0}\n       (\\<lambda>x. g (complex_of_real x + complex_of_real (- R) * \\<i>)))\n    \\<le> 3 * M / R / ln (real N)", "by (intro B12_bound) auto"], ["proof (state)\nthis:\n  cmod\n   (integral {- \\<delta>..0}\n     (\\<lambda>x. g (complex_of_real x + complex_of_real (- R) * \\<i>)))\n  \\<le> 3 * M / R / ln (real N)\n\ngoal (4 subgoals):\n 1. cmod (\\<ointegral>[A] g_rem) \\<le> 2 * C * pi / R\n 2. cmod (\\<ointegral>[A] (\\<lambda>x. g_S (- x)))\n    \\<le> 2 * C * pi * (1 / real N + 1 / R)\n 3. cmod (\\<ointegral>[B3] g) \\<le> 3 * M / R / ln (real N)\n 4. cmod (\\<ointegral>[B2] g)\n    \\<le> 6 * R * M * real N powr - \\<delta> / \\<delta>", "finally"], ["proof (chain)\npicking this:\n  cmod (\\<ointegral>[B3] g) \\<le> 3 * M / R / ln (real N)", "show \"norm (\\<ointegral>[B3] g) \\<le> \\<dots>\""], ["proof (prove)\nusing this:\n  cmod (\\<ointegral>[B3] g) \\<le> 3 * M / R / ln (real N)\n\ngoal (1 subgoal):\n 1. cmod (\\<ointegral>[B3] g) \\<le> 3 * M / R / ln (real N)", "."], ["proof (state)\nthis:\n  cmod (\\<ointegral>[B3] g) \\<le> 3 * M / R / ln (real N)\n\ngoal (3 subgoals):\n 1. cmod (\\<ointegral>[A] g_rem) \\<le> 2 * C * pi / R\n 2. cmod (\\<ointegral>[A] (\\<lambda>x. g_S (- x)))\n    \\<le> 2 * C * pi * (1 / real N + 1 / R)\n 3. cmod (\\<ointegral>[B2] g)\n    \\<le> 6 * R * M * real N powr - \\<delta> / \\<delta>", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. cmod (\\<ointegral>[A] g_rem) \\<le> 2 * C * pi / R\n 2. cmod (\\<ointegral>[A] (\\<lambda>x. g_S (- x)))\n    \\<le> 2 * C * pi * (1 / real N + 1 / R)\n 3. cmod (\\<ointegral>[B2] g)\n    \\<le> 6 * R * M * real N powr - \\<delta> / \\<delta>", "have \"norm (\\<ointegral>[B2] g) \\<le> M * N powr (-\\<delta>) * (3 / \\<delta>) *\n                norm (Complex (- \\<delta>) (-R) - Complex (- \\<delta>) R)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod (\\<ointegral>[B2] g)\n    \\<le> M * real N powr - \\<delta> * (3 / \\<delta>) *\n          cmod (Complex (- \\<delta>) (- R) - Complex (- \\<delta>) R)", "unfolding B2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod\n     (\\<ointegral>[linepath (Complex (- \\<delta>) R)\n                    (Complex (- \\<delta>) (- R))]\n       g)\n    \\<le> M * real N powr - \\<delta> * (3 / \\<delta>) *\n          cmod (Complex (- \\<delta>) (- R) - Complex (- \\<delta>) R)", "proof ((rule contour_integral_bound_linepath; (fold B2_def)?), goal_cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. g contour_integrable_on B2\n 2. 0 \\<le> M * real N powr - \\<delta> * (3 / \\<delta>)\n 3. \\<And>x.\n       x \\<in> closed_segment (Complex (- \\<delta>) R)\n                (Complex (- \\<delta>) (- R)) \\<Longrightarrow>\n       cmod (g x) \\<le> M * real N powr - \\<delta> * (3 / \\<delta>)", "case (3 z)"], ["proof (state)\nthis:\n  z \\<in> closed_segment (Complex (- \\<delta>) R)\n           (Complex (- \\<delta>) (- R))\n\ngoal (3 subgoals):\n 1. g contour_integrable_on B2\n 2. 0 \\<le> M * real N powr - \\<delta> * (3 / \\<delta>)\n 3. \\<And>x.\n       x \\<in> closed_segment (Complex (- \\<delta>) R)\n                (Complex (- \\<delta>) (- R)) \\<Longrightarrow>\n       cmod (g x) \\<le> M * real N powr - \\<delta> * (3 / \\<delta>)", "from 3 \\<delta> R"], ["proof (chain)\npicking this:\n  z \\<in> closed_segment (Complex (- \\<delta>) R)\n           (Complex (- \\<delta>) (- R))\n  0 < \\<delta>\n  \\<delta> \\<le> 1 / 2\n  \\<delta> < l\n  3 * C / \\<epsilon> \\<le> R\n  1 \\<le> R", "have [simp]: \"z \\<noteq> 0\" and Re_z: \"Re z = -\\<delta>\" and Im_z: \"Im z \\<in> {-R..R}\""], ["proof (prove)\nusing this:\n  z \\<in> closed_segment (Complex (- \\<delta>) R)\n           (Complex (- \\<delta>) (- R))\n  0 < \\<delta>\n  \\<delta> \\<le> 1 / 2\n  \\<delta> < l\n  3 * C / \\<epsilon> \\<le> R\n  1 \\<le> R\n\ngoal (1 subgoal):\n 1. z \\<noteq> 0 &&& Re z = - \\<delta> &&& Im z \\<in> {- R..R}", "by (auto simp: closed_segment_same_Re closed_segment_eq_real_ivl)"], ["proof (state)\nthis:\n  z \\<noteq> 0\n  Re z = - \\<delta>\n  Im z \\<in> {- R..R}\n\ngoal (3 subgoals):\n 1. g contour_integrable_on B2\n 2. 0 \\<le> M * real N powr - \\<delta> * (3 / \\<delta>)\n 3. \\<And>x.\n       x \\<in> closed_segment (Complex (- \\<delta>) R)\n                (Complex (- \\<delta>) (- R)) \\<Longrightarrow>\n       cmod (g x) \\<le> M * real N powr - \\<delta> * (3 / \\<delta>)", "from 3"], ["proof (chain)\npicking this:\n  z \\<in> closed_segment (Complex (- \\<delta>) R)\n           (Complex (- \\<delta>) (- R))", "have \"z \\<in> X'\""], ["proof (prove)\nusing this:\n  z \\<in> closed_segment (Complex (- \\<delta>) R)\n           (Complex (- \\<delta>) (- R))\n\ngoal (1 subgoal):\n 1. z \\<in> X'", "using R \\<delta> path_images"], ["proof (prove)\nusing this:\n  z \\<in> closed_segment (Complex (- \\<delta>) R)\n           (Complex (- \\<delta>) (- R))\n  3 * C / \\<epsilon> \\<le> R\n  1 \\<le> R\n  0 < \\<delta>\n  \\<delta> \\<le> 1 / 2\n  \\<delta> < l\n  path_image B2 \\<subseteq> X' - {0}\n  path_image A \\<subseteq> X' - {0}\n  path_image B1 \\<subseteq> X' - {0}\n  path_image B3 \\<subseteq> X' - {0}\n  X' \\<subseteq> X\n\ngoal (1 subgoal):\n 1. z \\<in> X'", "by (auto simp: B2_def)"], ["proof (state)\nthis:\n  z \\<in> X'\n\ngoal (3 subgoals):\n 1. g contour_integrable_on B2\n 2. 0 \\<le> M * real N powr - \\<delta> * (3 / \\<delta>)\n 3. \\<And>x.\n       x \\<in> closed_segment (Complex (- \\<delta>) R)\n                (Complex (- \\<delta>) (- R)) \\<Longrightarrow>\n       cmod (g x) \\<le> M * real N powr - \\<delta> * (3 / \\<delta>)", "from 3 \\<delta> R"], ["proof (chain)\npicking this:\n  z \\<in> closed_segment (Complex (- \\<delta>) R)\n           (Complex (- \\<delta>) (- R))\n  0 < \\<delta>\n  \\<delta> \\<le> 1 / 2\n  \\<delta> < l\n  3 * C / \\<epsilon> \\<le> R\n  1 \\<le> R", "have \"norm z \\<le> sqrt (\\<delta>^2 + R^2)\""], ["proof (prove)\nusing this:\n  z \\<in> closed_segment (Complex (- \\<delta>) R)\n           (Complex (- \\<delta>) (- R))\n  0 < \\<delta>\n  \\<delta> \\<le> 1 / 2\n  \\<delta> < l\n  3 * C / \\<epsilon> \\<le> R\n  1 \\<le> R\n\ngoal (1 subgoal):\n 1. cmod z \\<le> sqrt (\\<delta>\\<^sup>2 + R\\<^sup>2)", "unfolding cmod_def"], ["proof (prove)\nusing this:\n  z \\<in> closed_segment (Complex (- \\<delta>) R)\n           (Complex (- \\<delta>) (- R))\n  0 < \\<delta>\n  \\<delta> \\<le> 1 / 2\n  \\<delta> < l\n  3 * C / \\<epsilon> \\<le> R\n  1 \\<le> R\n\ngoal (1 subgoal):\n 1. sqrt ((Re z)\\<^sup>2 + (Im z)\\<^sup>2)\n    \\<le> sqrt (\\<delta>\\<^sup>2 + R\\<^sup>2)", "using Re_z Im_z"], ["proof (prove)\nusing this:\n  z \\<in> closed_segment (Complex (- \\<delta>) R)\n           (Complex (- \\<delta>) (- R))\n  0 < \\<delta>\n  \\<delta> \\<le> 1 / 2\n  \\<delta> < l\n  3 * C / \\<epsilon> \\<le> R\n  1 \\<le> R\n  Re z = - \\<delta>\n  Im z \\<in> {- R..R}\n\ngoal (1 subgoal):\n 1. sqrt ((Re z)\\<^sup>2 + (Im z)\\<^sup>2)\n    \\<le> sqrt (\\<delta>\\<^sup>2 + R\\<^sup>2)", "by (intro real_sqrt_le_mono add_mono) (auto simp: power2_le_iff_abs_le)"], ["proof (state)\nthis:\n  cmod z \\<le> sqrt (\\<delta>\\<^sup>2 + R\\<^sup>2)\n\ngoal (3 subgoals):\n 1. g contour_integrable_on B2\n 2. 0 \\<le> M * real N powr - \\<delta> * (3 / \\<delta>)\n 3. \\<And>x.\n       x \\<in> closed_segment (Complex (- \\<delta>) R)\n                (Complex (- \\<delta>) (- R)) \\<Longrightarrow>\n       cmod (g x) \\<le> M * real N powr - \\<delta> * (3 / \\<delta>)", "from power_mono[OF this, of 2]"], ["proof (chain)\npicking this:\n  0 \\<le> cmod z \\<Longrightarrow>\n  (cmod z)\\<^sup>2 \\<le> (sqrt (\\<delta>\\<^sup>2 + R\\<^sup>2))\\<^sup>2", "have norm_sqr: \"norm z ^ 2 \\<le> \\<delta>\\<^sup>2 + R\\<^sup>2\""], ["proof (prove)\nusing this:\n  0 \\<le> cmod z \\<Longrightarrow>\n  (cmod z)\\<^sup>2 \\<le> (sqrt (\\<delta>\\<^sup>2 + R\\<^sup>2))\\<^sup>2\n\ngoal (1 subgoal):\n 1. (cmod z)\\<^sup>2 \\<le> \\<delta>\\<^sup>2 + R\\<^sup>2", "by simp"], ["proof (state)\nthis:\n  (cmod z)\\<^sup>2 \\<le> \\<delta>\\<^sup>2 + R\\<^sup>2\n\ngoal (3 subgoals):\n 1. g contour_integrable_on B2\n 2. 0 \\<le> M * real N powr - \\<delta> * (3 / \\<delta>)\n 3. \\<And>x.\n       x \\<in> closed_segment (Complex (- \\<delta>) R)\n                (Complex (- \\<delta>) (- R)) \\<Longrightarrow>\n       cmod (g x) \\<le> M * real N powr - \\<delta> * (3 / \\<delta>)", "have \"norm (1 / z + z / R\\<^sup>2) \\<le> (1 + (norm z)\\<^sup>2 / R\\<^sup>2) / \\<delta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod (1 / z + z / complex_of_real (R\\<^sup>2))\n    \\<le> (1 + (cmod z)\\<^sup>2 / R\\<^sup>2) / \\<delta>", "unfolding add_divide_distrib"], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod (1 / z + z / complex_of_real (R\\<^sup>2))\n    \\<le> 1 / \\<delta> + (cmod z)\\<^sup>2 / R\\<^sup>2 / \\<delta>", "using \\<delta> R abs_Re_le_cmod[of z]"], ["proof (prove)\nusing this:\n  0 < \\<delta>\n  \\<delta> \\<le> 1 / 2\n  \\<delta> < l\n  3 * C / \\<epsilon> \\<le> R\n  1 \\<le> R\n  \\<bar>Re z\\<bar> \\<le> cmod z\n\ngoal (1 subgoal):\n 1. cmod (1 / z + z / complex_of_real (R\\<^sup>2))\n    \\<le> 1 / \\<delta> + (cmod z)\\<^sup>2 / R\\<^sup>2 / \\<delta>", "by (intro order.trans[OF norm_triangle_ineq] add_mono)\n               (auto simp: norm_divide norm_mult field_simps power2_eq_square Re_z)"], ["proof (state)\nthis:\n  cmod (1 / z + z / complex_of_real (R\\<^sup>2))\n  \\<le> (1 + (cmod z)\\<^sup>2 / R\\<^sup>2) / \\<delta>\n\ngoal (3 subgoals):\n 1. g contour_integrable_on B2\n 2. 0 \\<le> M * real N powr - \\<delta> * (3 / \\<delta>)\n 3. \\<And>x.\n       x \\<in> closed_segment (Complex (- \\<delta>) R)\n                (Complex (- \\<delta>) (- R)) \\<Longrightarrow>\n       cmod (g x) \\<le> M * real N powr - \\<delta> * (3 / \\<delta>)", "also"], ["proof (state)\nthis:\n  cmod (1 / z + z / complex_of_real (R\\<^sup>2))\n  \\<le> (1 + (cmod z)\\<^sup>2 / R\\<^sup>2) / \\<delta>\n\ngoal (3 subgoals):\n 1. g contour_integrable_on B2\n 2. 0 \\<le> M * real N powr - \\<delta> * (3 / \\<delta>)\n 3. \\<And>x.\n       x \\<in> closed_segment (Complex (- \\<delta>) R)\n                (Complex (- \\<delta>) (- R)) \\<Longrightarrow>\n       cmod (g x) \\<le> M * real N powr - \\<delta> * (3 / \\<delta>)", "have \"\\<dots> \\<le> (1 + (1 + \\<delta>\\<^sup>2 / R\\<^sup>2)) / \\<delta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1 + (cmod z)\\<^sup>2 / R\\<^sup>2) / \\<delta>\n    \\<le> (1 + (1 + \\<delta>\\<^sup>2 / R\\<^sup>2)) / \\<delta>", "using \\<delta> R \\<open>z \\<in> X'\\<close> norm_sqr"], ["proof (prove)\nusing this:\n  0 < \\<delta>\n  \\<delta> \\<le> 1 / 2\n  \\<delta> < l\n  3 * C / \\<epsilon> \\<le> R\n  1 \\<le> R\n  z \\<in> X'\n  (cmod z)\\<^sup>2 \\<le> \\<delta>\\<^sup>2 + R\\<^sup>2\n\ngoal (1 subgoal):\n 1. (1 + (cmod z)\\<^sup>2 / R\\<^sup>2) / \\<delta>\n    \\<le> (1 + (1 + \\<delta>\\<^sup>2 / R\\<^sup>2)) / \\<delta>", "unfolding X'_def"], ["proof (prove)\nusing this:\n  0 < \\<delta>\n  \\<delta> \\<le> 1 / 2\n  \\<delta> < l\n  3 * C / \\<epsilon> \\<le> R\n  1 \\<le> R\n  z \\<in> cbox (Complex (- \\<delta>) (- R)) (Complex R R)\n  (cmod z)\\<^sup>2 \\<le> \\<delta>\\<^sup>2 + R\\<^sup>2\n\ngoal (1 subgoal):\n 1. (1 + (cmod z)\\<^sup>2 / R\\<^sup>2) / \\<delta>\n    \\<le> (1 + (1 + \\<delta>\\<^sup>2 / R\\<^sup>2)) / \\<delta>", "by (intro divide_right_mono add_left_mono)\n               (auto simp: field_simps in_cbox_complex_iff intro!: power_mono)"], ["proof (state)\nthis:\n  (1 + (cmod z)\\<^sup>2 / R\\<^sup>2) / \\<delta>\n  \\<le> (1 + (1 + \\<delta>\\<^sup>2 / R\\<^sup>2)) / \\<delta>\n\ngoal (3 subgoals):\n 1. g contour_integrable_on B2\n 2. 0 \\<le> M * real N powr - \\<delta> * (3 / \\<delta>)\n 3. \\<And>x.\n       x \\<in> closed_segment (Complex (- \\<delta>) R)\n                (Complex (- \\<delta>) (- R)) \\<Longrightarrow>\n       cmod (g x) \\<le> M * real N powr - \\<delta> * (3 / \\<delta>)", "also"], ["proof (state)\nthis:\n  (1 + (cmod z)\\<^sup>2 / R\\<^sup>2) / \\<delta>\n  \\<le> (1 + (1 + \\<delta>\\<^sup>2 / R\\<^sup>2)) / \\<delta>\n\ngoal (3 subgoals):\n 1. g contour_integrable_on B2\n 2. 0 \\<le> M * real N powr - \\<delta> * (3 / \\<delta>)\n 3. \\<And>x.\n       x \\<in> closed_segment (Complex (- \\<delta>) R)\n                (Complex (- \\<delta>) (- R)) \\<Longrightarrow>\n       cmod (g x) \\<le> M * real N powr - \\<delta> * (3 / \\<delta>)", "have \"\\<delta>\\<^sup>2 / R\\<^sup>2 \\<le> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<delta>\\<^sup>2 / R\\<^sup>2 \\<le> 1", "using \\<delta> R"], ["proof (prove)\nusing this:\n  0 < \\<delta>\n  \\<delta> \\<le> 1 / 2\n  \\<delta> < l\n  3 * C / \\<epsilon> \\<le> R\n  1 \\<le> R\n\ngoal (1 subgoal):\n 1. \\<delta>\\<^sup>2 / R\\<^sup>2 \\<le> 1", "by (auto simp: field_simps intro!: power_mono)"], ["proof (state)\nthis:\n  \\<delta>\\<^sup>2 / R\\<^sup>2 \\<le> 1\n\ngoal (3 subgoals):\n 1. g contour_integrable_on B2\n 2. 0 \\<le> M * real N powr - \\<delta> * (3 / \\<delta>)\n 3. \\<And>x.\n       x \\<in> closed_segment (Complex (- \\<delta>) R)\n                (Complex (- \\<delta>) (- R)) \\<Longrightarrow>\n       cmod (g x) \\<le> M * real N powr - \\<delta> * (3 / \\<delta>)", "finally"], ["proof (chain)\npicking this:\n  (\\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      (1 + (1 + x)) / \\<delta>\n      \\<le> (1 + (1 + y)) / \\<delta>) \\<Longrightarrow>\n  cmod (1 / z + z / complex_of_real (R\\<^sup>2))\n  \\<le> (1 + (1 + 1)) / \\<delta>", "have \"norm (1 / z + z / R\\<^sup>2) \\<le> 3 / \\<delta>\""], ["proof (prove)\nusing this:\n  (\\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      (1 + (1 + x)) / \\<delta>\n      \\<le> (1 + (1 + y)) / \\<delta>) \\<Longrightarrow>\n  cmod (1 / z + z / complex_of_real (R\\<^sup>2))\n  \\<le> (1 + (1 + 1)) / \\<delta>\n\ngoal (1 subgoal):\n 1. cmod (1 / z + z / complex_of_real (R\\<^sup>2)) \\<le> 3 / \\<delta>", "using \\<delta>"], ["proof (prove)\nusing this:\n  (\\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      (1 + (1 + x)) / \\<delta>\n      \\<le> (1 + (1 + y)) / \\<delta>) \\<Longrightarrow>\n  cmod (1 / z + z / complex_of_real (R\\<^sup>2))\n  \\<le> (1 + (1 + 1)) / \\<delta>\n  0 < \\<delta>\n  \\<delta> \\<le> 1 / 2\n  \\<delta> < l\n\ngoal (1 subgoal):\n 1. cmod (1 / z + z / complex_of_real (R\\<^sup>2)) \\<le> 3 / \\<delta>", "by(simp add: divide_right_mono)"], ["proof (state)\nthis:\n  cmod (1 / z + z / complex_of_real (R\\<^sup>2)) \\<le> 3 / \\<delta>\n\ngoal (3 subgoals):\n 1. g contour_integrable_on B2\n 2. 0 \\<le> M * real N powr - \\<delta> * (3 / \\<delta>)\n 3. \\<And>x.\n       x \\<in> closed_segment (Complex (- \\<delta>) R)\n                (Complex (- \\<delta>) (- R)) \\<Longrightarrow>\n       cmod (g x) \\<le> M * real N powr - \\<delta> * (3 / \\<delta>)", "with \\<open>z \\<in> X'\\<close>"], ["proof (chain)\npicking this:\n  z \\<in> X'\n  cmod (1 / z + z / complex_of_real (R\\<^sup>2)) \\<le> 3 / \\<delta>", "show \"norm (g z) \\<le> M * N powr (-\\<delta>) * (3 / \\<delta>)\""], ["proof (prove)\nusing this:\n  z \\<in> X'\n  cmod (1 / z + z / complex_of_real (R\\<^sup>2)) \\<le> 3 / \\<delta>\n\ngoal (1 subgoal):\n 1. cmod (g z) \\<le> M * real N powr - \\<delta> * (3 / \\<delta>)", "unfolding g_def norm_mult"], ["proof (prove)\nusing this:\n  z \\<in> X'\n  cmod (1 / z + z / complex_of_real (R\\<^sup>2)) \\<le> 3 / \\<delta>\n\ngoal (1 subgoal):\n 1. cmod (f (w + z)) * cmod (of_nat N powr z) *\n    cmod (1 / z + z / complex_of_real (R\\<^sup>2))\n    \\<le> M * real N powr - \\<delta> * (3 / \\<delta>)", "by (intro mult_mono mult_nonneg_nonneg M) (auto simp: norm_powr_real_powr Re_z)"], ["proof (state)\nthis:\n  cmod (g z) \\<le> M * real N powr - \\<delta> * (3 / \\<delta>)\n\ngoal (2 subgoals):\n 1. g contour_integrable_on B2\n 2. 0 \\<le> M * real N powr - \\<delta> * (3 / \\<delta>)", "qed (insert path_images M \\<delta>, auto intro!: contour_integrable_holomorphic_simple[OF g_holo])"], ["proof (state)\nthis:\n  cmod (\\<ointegral>[B2] g)\n  \\<le> M * real N powr - \\<delta> * (3 / \\<delta>) *\n        cmod (Complex (- \\<delta>) (- R) - Complex (- \\<delta>) R)\n\ngoal (3 subgoals):\n 1. cmod (\\<ointegral>[A] g_rem) \\<le> 2 * C * pi / R\n 2. cmod (\\<ointegral>[A] (\\<lambda>x. g_S (- x)))\n    \\<le> 2 * C * pi * (1 / real N + 1 / R)\n 3. cmod (\\<ointegral>[B2] g)\n    \\<le> 6 * R * M * real N powr - \\<delta> / \\<delta>", "thus \"norm (\\<ointegral>[B2] g) \\<le> 6 * R * M * N powr (-\\<delta>) / \\<delta>\""], ["proof (prove)\nusing this:\n  cmod (\\<ointegral>[B2] g)\n  \\<le> M * real N powr - \\<delta> * (3 / \\<delta>) *\n        cmod (Complex (- \\<delta>) (- R) - Complex (- \\<delta>) R)\n\ngoal (1 subgoal):\n 1. cmod (\\<ointegral>[B2] g)\n    \\<le> 6 * R * M * real N powr - \\<delta> / \\<delta>", "using R"], ["proof (prove)\nusing this:\n  cmod (\\<ointegral>[B2] g)\n  \\<le> M * real N powr - \\<delta> * (3 / \\<delta>) *\n        cmod (Complex (- \\<delta>) (- R) - Complex (- \\<delta>) R)\n  3 * C / \\<epsilon> \\<le> R\n  1 \\<le> R\n\ngoal (1 subgoal):\n 1. cmod (\\<ointegral>[B2] g)\n    \\<le> 6 * R * M * real N powr - \\<delta> / \\<delta>", "by (simp add: field_simps cmod_def real_sqrt_mult)"], ["proof (state)\nthis:\n  cmod (\\<ointegral>[B2] g)\n  \\<le> 6 * R * M * real N powr - \\<delta> / \\<delta>\n\ngoal (2 subgoals):\n 1. cmod (\\<ointegral>[A] g_rem) \\<le> 2 * C * pi / R\n 2. cmod (\\<ointegral>[A] (\\<lambda>x. g_S (- x)))\n    \\<le> 2 * C * pi * (1 / real N + 1 / R)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. cmod (\\<ointegral>[A] g_rem) \\<le> 2 * C * pi / R\n 2. cmod (\\<ointegral>[A] (\\<lambda>x. g_S (- x)))\n    \\<le> 2 * C * pi * (1 / real N + 1 / R)", "have \"norm (\\<ointegral>[A] (\\<lambda>x. g_S (- x))) \\<le> (2 * C / (real N * R) + 2 * C / R\\<^sup>2) * \n                                R * ((pi/2) - (-pi/2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod (\\<ointegral>[A] (\\<lambda>x. g_S (- x)))\n    \\<le> (2 * C / (real N * R) + 2 * C / R\\<^sup>2) * R *\n          (pi / 2 - - pi / 2)", "unfolding A_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod\n     (\\<ointegral>[part_circlepath 0 R (- pi / 2) (pi / 2)]\n       (\\<lambda>x. g_S (- x)))\n    \\<le> (2 * C / (real N * R) + 2 * C / R\\<^sup>2) * R *\n          (pi / 2 - - pi / 2)", "proof ((rule contour_integral_bound_part_circlepath_strong[where k = \"{R * \\<i>, -R*\\<i>}\"];\n               (fold A_def)?), goal_cases)"], ["proof (state)\ngoal (6 subgoals):\n 1. (\\<lambda>x. g_S (- x)) contour_integrable_on A\n 2. finite {complex_of_real R * \\<i>, complex_of_real (- R) * \\<i>}\n 3. 0 \\<le> 2 * C / (real N * R) + 2 * C / R\\<^sup>2\n 4. 0 < R\n 5. - pi / 2 \\<le> pi / 2\n 6. \\<And>x.\n       x \\<in> path_image A -\n               {complex_of_real R * \\<i>,\n                complex_of_real (- R) * \\<i>} \\<Longrightarrow>\n       cmod (g_S (- x)) \\<le> 2 * C / (real N * R) + 2 * C / R\\<^sup>2", "case (6 z)"], ["proof (state)\nthis:\n  z \\<in> path_image A -\n          {complex_of_real R * \\<i>, complex_of_real (- R) * \\<i>}\n\ngoal (6 subgoals):\n 1. (\\<lambda>x. g_S (- x)) contour_integrable_on A\n 2. finite {complex_of_real R * \\<i>, complex_of_real (- R) * \\<i>}\n 3. 0 \\<le> 2 * C / (real N * R) + 2 * C / R\\<^sup>2\n 4. 0 < R\n 5. - pi / 2 \\<le> pi / 2\n 6. \\<And>x.\n       x \\<in> path_image A -\n               {complex_of_real R * \\<i>,\n                complex_of_real (- R) * \\<i>} \\<Longrightarrow>\n       cmod (g_S (- x)) \\<le> 2 * C / (real N * R) + 2 * C / R\\<^sup>2", "hence [simp]: \"z \\<noteq> 0\" and \"norm z = R\""], ["proof (prove)\nusing this:\n  z \\<in> path_image A -\n          {complex_of_real R * \\<i>, complex_of_real (- R) * \\<i>}\n\ngoal (1 subgoal):\n 1. z \\<noteq> 0 &&& cmod z = R", "using R"], ["proof (prove)\nusing this:\n  z \\<in> path_image A -\n          {complex_of_real R * \\<i>, complex_of_real (- R) * \\<i>}\n  3 * C / \\<epsilon> \\<le> R\n  1 \\<le> R\n\ngoal (1 subgoal):\n 1. z \\<noteq> 0 &&& cmod z = R", "by (auto simp: A_def dest!: in_path_image_part_circlepath)"], ["proof (state)\nthis:\n  z \\<noteq> 0\n  cmod z = R\n\ngoal (6 subgoals):\n 1. (\\<lambda>x. g_S (- x)) contour_integrable_on A\n 2. finite {complex_of_real R * \\<i>, complex_of_real (- R) * \\<i>}\n 3. 0 \\<le> 2 * C / (real N * R) + 2 * C / R\\<^sup>2\n 4. 0 < R\n 5. - pi / 2 \\<le> pi / 2\n 6. \\<And>x.\n       x \\<in> path_image A -\n               {complex_of_real R * \\<i>,\n                complex_of_real (- R) * \\<i>} \\<Longrightarrow>\n       cmod (g_S (- x)) \\<le> 2 * C / (real N * R) + 2 * C / R\\<^sup>2", "from 6"], ["proof (chain)\npicking this:\n  z \\<in> path_image A -\n          {complex_of_real R * \\<i>, complex_of_real (- R) * \\<i>}", "have \"Re z \\<noteq> 0\""], ["proof (prove)\nusing this:\n  z \\<in> path_image A -\n          {complex_of_real R * \\<i>, complex_of_real (- R) * \\<i>}\n\ngoal (1 subgoal):\n 1. Re z \\<noteq> 0", "using \\<open>norm z = R\\<close>"], ["proof (prove)\nusing this:\n  z \\<in> path_image A -\n          {complex_of_real R * \\<i>, complex_of_real (- R) * \\<i>}\n  cmod z = R\n\ngoal (1 subgoal):\n 1. Re z \\<noteq> 0", "by (auto simp: cmod_def abs_if complex_eq_iff split: if_splits)"], ["proof (state)\nthis:\n  Re z \\<noteq> 0\n\ngoal (6 subgoals):\n 1. (\\<lambda>x. g_S (- x)) contour_integrable_on A\n 2. finite {complex_of_real R * \\<i>, complex_of_real (- R) * \\<i>}\n 3. 0 \\<le> 2 * C / (real N * R) + 2 * C / R\\<^sup>2\n 4. 0 < R\n 5. - pi / 2 \\<le> pi / 2\n 6. \\<And>x.\n       x \\<in> path_image A -\n               {complex_of_real R * \\<i>,\n                complex_of_real (- R) * \\<i>} \\<Longrightarrow>\n       cmod (g_S (- x)) \\<le> 2 * C / (real N * R) + 2 * C / R\\<^sup>2", "with 6"], ["proof (chain)\npicking this:\n  z \\<in> path_image A -\n          {complex_of_real R * \\<i>, complex_of_real (- R) * \\<i>}\n  Re z \\<noteq> 0", "have \"Re z > 0\""], ["proof (prove)\nusing this:\n  z \\<in> path_image A -\n          {complex_of_real R * \\<i>, complex_of_real (- R) * \\<i>}\n  Re z \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 0 < Re z", "using image_A"], ["proof (prove)\nusing this:\n  z \\<in> path_image A -\n          {complex_of_real R * \\<i>, complex_of_real (- R) * \\<i>}\n  Re z \\<noteq> 0\n  path_image A = {s. 0 \\<le> Re s \\<and> cmod s = R}\n\ngoal (1 subgoal):\n 1. 0 < Re z", "by auto"], ["proof (state)\nthis:\n  0 < Re z\n\ngoal (6 subgoals):\n 1. (\\<lambda>x. g_S (- x)) contour_integrable_on A\n 2. finite {complex_of_real R * \\<i>, complex_of_real (- R) * \\<i>}\n 3. 0 \\<le> 2 * C / (real N * R) + 2 * C / R\\<^sup>2\n 4. 0 < R\n 5. - pi / 2 \\<le> pi / 2\n 6. \\<And>x.\n       x \\<in> path_image A -\n               {complex_of_real R * \\<i>,\n                complex_of_real (- R) * \\<i>} \\<Longrightarrow>\n       cmod (g_S (- x)) \\<le> 2 * C / (real N * R) + 2 * C / R\\<^sup>2", "have \"S (w - z) = (\\<Sum>k = 1..N. fds_nth F k / of_nat k powr (w - z))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S (w - z) = (\\<Sum>k = 1..N. fds_nth F k / of_nat k powr (w - z))", "by (simp add: S_def eval_fds_truncate)"], ["proof (state)\nthis:\n  S (w - z) = (\\<Sum>k = 1..N. fds_nth F k / of_nat k powr (w - z))\n\ngoal (6 subgoals):\n 1. (\\<lambda>x. g_S (- x)) contour_integrable_on A\n 2. finite {complex_of_real R * \\<i>, complex_of_real (- R) * \\<i>}\n 3. 0 \\<le> 2 * C / (real N * R) + 2 * C / R\\<^sup>2\n 4. 0 < R\n 5. - pi / 2 \\<le> pi / 2\n 6. \\<And>x.\n       x \\<in> path_image A -\n               {complex_of_real R * \\<i>,\n                complex_of_real (- R) * \\<i>} \\<Longrightarrow>\n       cmod (g_S (- x)) \\<le> 2 * C / (real N * R) + 2 * C / R\\<^sup>2", "also"], ["proof (state)\nthis:\n  S (w - z) = (\\<Sum>k = 1..N. fds_nth F k / of_nat k powr (w - z))\n\ngoal (6 subgoals):\n 1. (\\<lambda>x. g_S (- x)) contour_integrable_on A\n 2. finite {complex_of_real R * \\<i>, complex_of_real (- R) * \\<i>}\n 3. 0 \\<le> 2 * C / (real N * R) + 2 * C / R\\<^sup>2\n 4. 0 < R\n 5. - pi / 2 \\<le> pi / 2\n 6. \\<And>x.\n       x \\<in> path_image A -\n               {complex_of_real R * \\<i>,\n                complex_of_real (- R) * \\<i>} \\<Longrightarrow>\n       cmod (g_S (- x)) \\<le> 2 * C / (real N * R) + 2 * C / R\\<^sup>2", "have \"norm \\<dots> \\<le> C * N powr Re z * (1 / N + 1 / Re z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod (\\<Sum>k = 1..N. fds_nth F k / of_nat k powr (w - z))\n    \\<le> C * real N powr Re z * (1 / real N + 1 / Re z)", "using \\<open>Re z > 0\\<close> w N"], ["proof (prove)\nusing this:\n  0 < Re z\n  1 \\<le> Re w\n  bound N < \\<epsilon>\n  1 < N\n\ngoal (1 subgoal):\n 1. cmod (\\<Sum>k = 1..N. fds_nth F k / of_nat k powr (w - z))\n    \\<le> C * real N powr Re z * (1 / real N + 1 / Re z)", "by (intro newman_ingham_aux2 C) auto"], ["proof (state)\nthis:\n  cmod (\\<Sum>k = 1..N. fds_nth F k / of_nat k powr (w - z))\n  \\<le> C * real N powr Re z * (1 / real N + 1 / Re z)\n\ngoal (6 subgoals):\n 1. (\\<lambda>x. g_S (- x)) contour_integrable_on A\n 2. finite {complex_of_real R * \\<i>, complex_of_real (- R) * \\<i>}\n 3. 0 \\<le> 2 * C / (real N * R) + 2 * C / R\\<^sup>2\n 4. 0 < R\n 5. - pi / 2 \\<le> pi / 2\n 6. \\<And>x.\n       x \\<in> path_image A -\n               {complex_of_real R * \\<i>,\n                complex_of_real (- R) * \\<i>} \\<Longrightarrow>\n       cmod (g_S (- x)) \\<le> 2 * C / (real N * R) + 2 * C / R\\<^sup>2", "finally"], ["proof (chain)\npicking this:\n  cmod (S (w - z)) \\<le> C * real N powr Re z * (1 / real N + 1 / Re z)", "have \"norm (S (w - z)) \\<le> \\<dots>\""], ["proof (prove)\nusing this:\n  cmod (S (w - z)) \\<le> C * real N powr Re z * (1 / real N + 1 / Re z)\n\ngoal (1 subgoal):\n 1. cmod (S (w - z)) \\<le> C * real N powr Re z * (1 / real N + 1 / Re z)", "."], ["proof (state)\nthis:\n  cmod (S (w - z)) \\<le> C * real N powr Re z * (1 / real N + 1 / Re z)\n\ngoal (6 subgoals):\n 1. (\\<lambda>x. g_S (- x)) contour_integrable_on A\n 2. finite {complex_of_real R * \\<i>, complex_of_real (- R) * \\<i>}\n 3. 0 \\<le> 2 * C / (real N * R) + 2 * C / R\\<^sup>2\n 4. 0 < R\n 5. - pi / 2 \\<le> pi / 2\n 6. \\<And>x.\n       x \\<in> path_image A -\n               {complex_of_real R * \\<i>,\n                complex_of_real (- R) * \\<i>} \\<Longrightarrow>\n       cmod (g_S (- x)) \\<le> 2 * C / (real N * R) + 2 * C / R\\<^sup>2", "hence \"norm (g_S (-z)) \\<le>\n                   (C * N powr (Re z) * (1 / N + 1 / Re z)) * N powr (-Re z) * (2 * Re z / R\\<^sup>2)\""], ["proof (prove)\nusing this:\n  cmod (S (w - z)) \\<le> C * real N powr Re z * (1 / real N + 1 / Re z)\n\ngoal (1 subgoal):\n 1. cmod (g_S (- z))\n    \\<le> C * real N powr Re z * (1 / real N + 1 / Re z) *\n          real N powr - Re z *\n          (2 * Re z / R\\<^sup>2)", "unfolding g_S_def norm_mult"], ["proof (prove)\nusing this:\n  cmod (S (w - z)) \\<le> C * real N powr Re z * (1 / real N + 1 / Re z)\n\ngoal (1 subgoal):\n 1. cmod (S (w + - z)) * cmod (of_nat N powr - z) *\n    cmod (1 / - z + - z / complex_of_real (R\\<^sup>2))\n    \\<le> C * real N powr Re z * (1 / real N + 1 / Re z) *\n          real N powr - Re z *\n          (2 * Re z / R\\<^sup>2)", "using newman_ingham_aux1[OF _ \\<open>norm z = R\\<close>] \\<open>Re z > 0\\<close> \\<open>C \\<ge> 1\\<close> R"], ["proof (prove)\nusing this:\n  cmod (S (w - z)) \\<le> C * real N powr Re z * (1 / real N + 1 / Re z)\n  0 < R \\<Longrightarrow>\n  cmod (1 / z + z / complex_of_real (R\\<^sup>2)) =\n  2 * \\<bar>Re z\\<bar> / R\\<^sup>2\n  0 < Re z\n  1 \\<le> C\n  3 * C / \\<epsilon> \\<le> R\n  1 \\<le> R\n\ngoal (1 subgoal):\n 1. cmod (S (w + - z)) * cmod (of_nat N powr - z) *\n    cmod (1 / - z + - z / complex_of_real (R\\<^sup>2))\n    \\<le> C * real N powr Re z * (1 / real N + 1 / Re z) *\n          real N powr - Re z *\n          (2 * Re z / R\\<^sup>2)", "by (intro mult_mono mult_nonneg_nonneg circle_bound)\n               (auto simp: norm_powr_real_powr norm_uminus_minus)"], ["proof (state)\nthis:\n  cmod (g_S (- z))\n  \\<le> C * real N powr Re z * (1 / real N + 1 / Re z) *\n        real N powr - Re z *\n        (2 * Re z / R\\<^sup>2)\n\ngoal (6 subgoals):\n 1. (\\<lambda>x. g_S (- x)) contour_integrable_on A\n 2. finite {complex_of_real R * \\<i>, complex_of_real (- R) * \\<i>}\n 3. 0 \\<le> 2 * C / (real N * R) + 2 * C / R\\<^sup>2\n 4. 0 < R\n 5. - pi / 2 \\<le> pi / 2\n 6. \\<And>x.\n       x \\<in> path_image A -\n               {complex_of_real R * \\<i>,\n                complex_of_real (- R) * \\<i>} \\<Longrightarrow>\n       cmod (g_S (- x)) \\<le> 2 * C / (real N * R) + 2 * C / R\\<^sup>2", "also"], ["proof (state)\nthis:\n  cmod (g_S (- z))\n  \\<le> C * real N powr Re z * (1 / real N + 1 / Re z) *\n        real N powr - Re z *\n        (2 * Re z / R\\<^sup>2)\n\ngoal (6 subgoals):\n 1. (\\<lambda>x. g_S (- x)) contour_integrable_on A\n 2. finite {complex_of_real R * \\<i>, complex_of_real (- R) * \\<i>}\n 3. 0 \\<le> 2 * C / (real N * R) + 2 * C / R\\<^sup>2\n 4. 0 < R\n 5. - pi / 2 \\<le> pi / 2\n 6. \\<And>x.\n       x \\<in> path_image A -\n               {complex_of_real R * \\<i>,\n                complex_of_real (- R) * \\<i>} \\<Longrightarrow>\n       cmod (g_S (- x)) \\<le> 2 * C / (real N * R) + 2 * C / R\\<^sup>2", "have \"\\<dots> = 2 * C * (Re z / N + 1) / R\\<^sup>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. C * real N powr Re z * (1 / real N + 1 / Re z) * real N powr - Re z *\n    (2 * Re z / R\\<^sup>2) =\n    2 * C * (Re z / real N + 1) / R\\<^sup>2", "using R N \\<open>Re z > 0\\<close>"], ["proof (prove)\nusing this:\n  3 * C / \\<epsilon> \\<le> R\n  1 \\<le> R\n  bound N < \\<epsilon>\n  1 < N\n  0 < Re z\n\ngoal (1 subgoal):\n 1. C * real N powr Re z * (1 / real N + 1 / Re z) * real N powr - Re z *\n    (2 * Re z / R\\<^sup>2) =\n    2 * C * (Re z / real N + 1) / R\\<^sup>2", "by (simp add: powr_minus algebra_simps)"], ["proof (state)\nthis:\n  C * real N powr Re z * (1 / real N + 1 / Re z) * real N powr - Re z *\n  (2 * Re z / R\\<^sup>2) =\n  2 * C * (Re z / real N + 1) / R\\<^sup>2\n\ngoal (6 subgoals):\n 1. (\\<lambda>x. g_S (- x)) contour_integrable_on A\n 2. finite {complex_of_real R * \\<i>, complex_of_real (- R) * \\<i>}\n 3. 0 \\<le> 2 * C / (real N * R) + 2 * C / R\\<^sup>2\n 4. 0 < R\n 5. - pi / 2 \\<le> pi / 2\n 6. \\<And>x.\n       x \\<in> path_image A -\n               {complex_of_real R * \\<i>,\n                complex_of_real (- R) * \\<i>} \\<Longrightarrow>\n       cmod (g_S (- x)) \\<le> 2 * C / (real N * R) + 2 * C / R\\<^sup>2", "also"], ["proof (state)\nthis:\n  C * real N powr Re z * (1 / real N + 1 / Re z) * real N powr - Re z *\n  (2 * Re z / R\\<^sup>2) =\n  2 * C * (Re z / real N + 1) / R\\<^sup>2\n\ngoal (6 subgoals):\n 1. (\\<lambda>x. g_S (- x)) contour_integrable_on A\n 2. finite {complex_of_real R * \\<i>, complex_of_real (- R) * \\<i>}\n 3. 0 \\<le> 2 * C / (real N * R) + 2 * C / R\\<^sup>2\n 4. 0 < R\n 5. - pi / 2 \\<le> pi / 2\n 6. \\<And>x.\n       x \\<in> path_image A -\n               {complex_of_real R * \\<i>,\n                complex_of_real (- R) * \\<i>} \\<Longrightarrow>\n       cmod (g_S (- x)) \\<le> 2 * C / (real N * R) + 2 * C / R\\<^sup>2", "have \"\\<dots> \\<le> 2 * C / (N * R) + 2 * C / R\\<^sup>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * C * (Re z / real N + 1) / R\\<^sup>2\n    \\<le> 2 * C / (real N * R) + 2 * C / R\\<^sup>2", "unfolding add_divide_distrib ring_distribs"], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * C * (Re z / real N) / R\\<^sup>2 + 2 * C * 1 / R\\<^sup>2\n    \\<le> 2 * C / (real N * R) + 2 * C / R\\<^sup>2", "using R N abs_Re_le_cmod[of z] \\<open>norm z = R\\<close> \\<open>Re z > 0\\<close> \\<open>C \\<ge> 1\\<close>"], ["proof (prove)\nusing this:\n  3 * C / \\<epsilon> \\<le> R\n  1 \\<le> R\n  bound N < \\<epsilon>\n  1 < N\n  \\<bar>Re z\\<bar> \\<le> cmod z\n  cmod z = R\n  0 < Re z\n  1 \\<le> C\n\ngoal (1 subgoal):\n 1. 2 * C * (Re z / real N) / R\\<^sup>2 + 2 * C * 1 / R\\<^sup>2\n    \\<le> 2 * C / (real N * R) + 2 * C / R\\<^sup>2", "by (intro add_mono) (auto simp: power2_eq_square field_simps mult_mono)"], ["proof (state)\nthis:\n  2 * C * (Re z / real N + 1) / R\\<^sup>2\n  \\<le> 2 * C / (real N * R) + 2 * C / R\\<^sup>2\n\ngoal (6 subgoals):\n 1. (\\<lambda>x. g_S (- x)) contour_integrable_on A\n 2. finite {complex_of_real R * \\<i>, complex_of_real (- R) * \\<i>}\n 3. 0 \\<le> 2 * C / (real N * R) + 2 * C / R\\<^sup>2\n 4. 0 < R\n 5. - pi / 2 \\<le> pi / 2\n 6. \\<And>x.\n       x \\<in> path_image A -\n               {complex_of_real R * \\<i>,\n                complex_of_real (- R) * \\<i>} \\<Longrightarrow>\n       cmod (g_S (- x)) \\<le> 2 * C / (real N * R) + 2 * C / R\\<^sup>2", "finally"], ["proof (chain)\npicking this:\n  cmod (g_S (- z)) \\<le> 2 * C / (real N * R) + 2 * C / R\\<^sup>2", "show ?case"], ["proof (prove)\nusing this:\n  cmod (g_S (- z)) \\<le> 2 * C / (real N * R) + 2 * C / R\\<^sup>2\n\ngoal (1 subgoal):\n 1. cmod (g_S (- z)) \\<le> 2 * C / (real N * R) + 2 * C / R\\<^sup>2", "."], ["proof (state)\nthis:\n  cmod (g_S (- z)) \\<le> 2 * C / (real N * R) + 2 * C / R\\<^sup>2\n\ngoal (5 subgoals):\n 1. (\\<lambda>x. g_S (- x)) contour_integrable_on A\n 2. finite {complex_of_real R * \\<i>, complex_of_real (- R) * \\<i>}\n 3. 0 \\<le> 2 * C / (real N * R) + 2 * C / R\\<^sup>2\n 4. 0 < R\n 5. - pi / 2 \\<le> pi / 2", "qed (insert R N image_A C, auto intro!: contour_integrable_holomorphic_simple[of _ \"-{0}\"]\n                                                holomorphic_intros simp: g_S_def S_def)"], ["proof (state)\nthis:\n  cmod (\\<ointegral>[A] (\\<lambda>x. g_S (- x)))\n  \\<le> (2 * C / (real N * R) + 2 * C / R\\<^sup>2) * R * (pi / 2 - - pi / 2)\n\ngoal (2 subgoals):\n 1. cmod (\\<ointegral>[A] g_rem) \\<le> 2 * C * pi / R\n 2. cmod (\\<ointegral>[A] (\\<lambda>x. g_S (- x)))\n    \\<le> 2 * C * pi * (1 / real N + 1 / R)", "also"], ["proof (state)\nthis:\n  cmod (\\<ointegral>[A] (\\<lambda>x. g_S (- x)))\n  \\<le> (2 * C / (real N * R) + 2 * C / R\\<^sup>2) * R * (pi / 2 - - pi / 2)\n\ngoal (2 subgoals):\n 1. cmod (\\<ointegral>[A] g_rem) \\<le> 2 * C * pi / R\n 2. cmod (\\<ointegral>[A] (\\<lambda>x. g_S (- x)))\n    \\<le> 2 * C * pi * (1 / real N + 1 / R)", "have \"\\<dots> = 2 * C * pi * (1 / N + 1 / R)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (2 * C / (real N * R) + 2 * C / R\\<^sup>2) * R * (pi / 2 - - pi / 2) =\n    2 * C * pi * (1 / real N + 1 / R)", "using R N"], ["proof (prove)\nusing this:\n  3 * C / \\<epsilon> \\<le> R\n  1 \\<le> R\n  bound N < \\<epsilon>\n  1 < N\n\ngoal (1 subgoal):\n 1. (2 * C / (real N * R) + 2 * C / R\\<^sup>2) * R * (pi / 2 - - pi / 2) =\n    2 * C * pi * (1 / real N + 1 / R)", "by (simp add: power2_eq_square field_simps)"], ["proof (state)\nthis:\n  (2 * C / (real N * R) + 2 * C / R\\<^sup>2) * R * (pi / 2 - - pi / 2) =\n  2 * C * pi * (1 / real N + 1 / R)\n\ngoal (2 subgoals):\n 1. cmod (\\<ointegral>[A] g_rem) \\<le> 2 * C * pi / R\n 2. cmod (\\<ointegral>[A] (\\<lambda>x. g_S (- x)))\n    \\<le> 2 * C * pi * (1 / real N + 1 / R)", "finally"], ["proof (chain)\npicking this:\n  cmod (\\<ointegral>[A] (\\<lambda>x. g_S (- x)))\n  \\<le> 2 * C * pi * (1 / real N + 1 / R)", "show \"norm (\\<ointegral>[A] (\\<lambda>x. g_S (- x))) \\<le> \\<dots>\""], ["proof (prove)\nusing this:\n  cmod (\\<ointegral>[A] (\\<lambda>x. g_S (- x)))\n  \\<le> 2 * C * pi * (1 / real N + 1 / R)\n\ngoal (1 subgoal):\n 1. cmod (\\<ointegral>[A] (\\<lambda>x. g_S (- x)))\n    \\<le> 2 * C * pi * (1 / real N + 1 / R)", "."], ["proof (state)\nthis:\n  cmod (\\<ointegral>[A] (\\<lambda>x. g_S (- x)))\n  \\<le> 2 * C * pi * (1 / real N + 1 / R)\n\ngoal (1 subgoal):\n 1. cmod (\\<ointegral>[A] g_rem) \\<le> 2 * C * pi / R", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. cmod (\\<ointegral>[A] g_rem) \\<le> 2 * C * pi / R", "have \"norm (\\<ointegral>[A] g_rem) \\<le> (2 * C / R\\<^sup>2) * R * ((pi/2) - (-pi/2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod (\\<ointegral>[A] g_rem)\n    \\<le> 2 * C / R\\<^sup>2 * R * (pi / 2 - - pi / 2)", "unfolding A_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod (\\<ointegral>[part_circlepath 0 R (- pi / 2) (pi / 2)] g_rem)\n    \\<le> 2 * C / R\\<^sup>2 * R * (pi / 2 - - pi / 2)", "proof ((rule contour_integral_bound_part_circlepath_strong[where k = \"{R * \\<i>, -R*\\<i>}\"];\n               (fold A_def)?), goal_cases)"], ["proof (state)\ngoal (6 subgoals):\n 1. g_rem contour_integrable_on A\n 2. finite {complex_of_real R * \\<i>, complex_of_real (- R) * \\<i>}\n 3. 0 \\<le> 2 * C / R\\<^sup>2\n 4. 0 < R\n 5. - pi / 2 \\<le> pi / 2\n 6. \\<And>x.\n       x \\<in> path_image A -\n               {complex_of_real R * \\<i>,\n                complex_of_real (- R) * \\<i>} \\<Longrightarrow>\n       cmod (g_rem x) \\<le> 2 * C / R\\<^sup>2", "case (6 z)"], ["proof (state)\nthis:\n  z \\<in> path_image A -\n          {complex_of_real R * \\<i>, complex_of_real (- R) * \\<i>}\n\ngoal (6 subgoals):\n 1. g_rem contour_integrable_on A\n 2. finite {complex_of_real R * \\<i>, complex_of_real (- R) * \\<i>}\n 3. 0 \\<le> 2 * C / R\\<^sup>2\n 4. 0 < R\n 5. - pi / 2 \\<le> pi / 2\n 6. \\<And>x.\n       x \\<in> path_image A -\n               {complex_of_real R * \\<i>,\n                complex_of_real (- R) * \\<i>} \\<Longrightarrow>\n       cmod (g_rem x) \\<le> 2 * C / R\\<^sup>2", "hence [simp]: \"z \\<noteq> 0\" and \"norm z = R\""], ["proof (prove)\nusing this:\n  z \\<in> path_image A -\n          {complex_of_real R * \\<i>, complex_of_real (- R) * \\<i>}\n\ngoal (1 subgoal):\n 1. z \\<noteq> 0 &&& cmod z = R", "using R"], ["proof (prove)\nusing this:\n  z \\<in> path_image A -\n          {complex_of_real R * \\<i>, complex_of_real (- R) * \\<i>}\n  3 * C / \\<epsilon> \\<le> R\n  1 \\<le> R\n\ngoal (1 subgoal):\n 1. z \\<noteq> 0 &&& cmod z = R", "by (auto simp: A_def dest!: in_path_image_part_circlepath)"], ["proof (state)\nthis:\n  z \\<noteq> 0\n  cmod z = R\n\ngoal (6 subgoals):\n 1. g_rem contour_integrable_on A\n 2. finite {complex_of_real R * \\<i>, complex_of_real (- R) * \\<i>}\n 3. 0 \\<le> 2 * C / R\\<^sup>2\n 4. 0 < R\n 5. - pi / 2 \\<le> pi / 2\n 6. \\<And>x.\n       x \\<in> path_image A -\n               {complex_of_real R * \\<i>,\n                complex_of_real (- R) * \\<i>} \\<Longrightarrow>\n       cmod (g_rem x) \\<le> 2 * C / R\\<^sup>2", "from 6"], ["proof (chain)\npicking this:\n  z \\<in> path_image A -\n          {complex_of_real R * \\<i>, complex_of_real (- R) * \\<i>}", "have \"Re z \\<noteq> 0\""], ["proof (prove)\nusing this:\n  z \\<in> path_image A -\n          {complex_of_real R * \\<i>, complex_of_real (- R) * \\<i>}\n\ngoal (1 subgoal):\n 1. Re z \\<noteq> 0", "using \\<open>norm z = R\\<close>"], ["proof (prove)\nusing this:\n  z \\<in> path_image A -\n          {complex_of_real R * \\<i>, complex_of_real (- R) * \\<i>}\n  cmod z = R\n\ngoal (1 subgoal):\n 1. Re z \\<noteq> 0", "by (auto simp: cmod_def abs_if complex_eq_iff split: if_splits)"], ["proof (state)\nthis:\n  Re z \\<noteq> 0\n\ngoal (6 subgoals):\n 1. g_rem contour_integrable_on A\n 2. finite {complex_of_real R * \\<i>, complex_of_real (- R) * \\<i>}\n 3. 0 \\<le> 2 * C / R\\<^sup>2\n 4. 0 < R\n 5. - pi / 2 \\<le> pi / 2\n 6. \\<And>x.\n       x \\<in> path_image A -\n               {complex_of_real R * \\<i>,\n                complex_of_real (- R) * \\<i>} \\<Longrightarrow>\n       cmod (g_rem x) \\<le> 2 * C / R\\<^sup>2", "with 6"], ["proof (chain)\npicking this:\n  z \\<in> path_image A -\n          {complex_of_real R * \\<i>, complex_of_real (- R) * \\<i>}\n  Re z \\<noteq> 0", "have \"Re z > 0\""], ["proof (prove)\nusing this:\n  z \\<in> path_image A -\n          {complex_of_real R * \\<i>, complex_of_real (- R) * \\<i>}\n  Re z \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 0 < Re z", "using image_A"], ["proof (prove)\nusing this:\n  z \\<in> path_image A -\n          {complex_of_real R * \\<i>, complex_of_real (- R) * \\<i>}\n  Re z \\<noteq> 0\n  path_image A = {s. 0 \\<le> Re s \\<and> cmod s = R}\n\ngoal (1 subgoal):\n 1. 0 < Re z", "by auto"], ["proof (state)\nthis:\n  0 < Re z\n\ngoal (6 subgoals):\n 1. g_rem contour_integrable_on A\n 2. finite {complex_of_real R * \\<i>, complex_of_real (- R) * \\<i>}\n 3. 0 \\<le> 2 * C / R\\<^sup>2\n 4. 0 < R\n 5. - pi / 2 \\<le> pi / 2\n 6. \\<And>x.\n       x \\<in> path_image A -\n               {complex_of_real R * \\<i>,\n                complex_of_real (- R) * \\<i>} \\<Longrightarrow>\n       cmod (g_rem x) \\<le> 2 * C / R\\<^sup>2", "have summable: \"summable (\\<lambda>n. C * (1 / (Suc n + N) powr (Re w + Re z)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. summable (\\<lambda>n. C * (1 / real (Suc n + N) powr (Re w + Re z)))", "using summable_hurwitz_zeta_real[of \"Re w + Re z\" \"Suc N\"] \\<open>Re z > 0\\<close> w"], ["proof (prove)\nusing this:\n  \\<lbrakk>1 < Re w + Re z; 0 < real (Suc N)\\<rbrakk>\n  \\<Longrightarrow> summable\n                     (\\<lambda>n.\n                         (real n + real (Suc N)) powr - (Re w + Re z))\n  0 < Re z\n  1 \\<le> Re w\n\ngoal (1 subgoal):\n 1. summable (\\<lambda>n. C * (1 / real (Suc n + N) powr (Re w + Re z)))", "unfolding powr_minus"], ["proof (prove)\nusing this:\n  \\<lbrakk>1 < Re w + Re z; 0 < real (Suc N)\\<rbrakk>\n  \\<Longrightarrow> summable\n                     (\\<lambda>n.\n                         inverse\n                          ((real n + real (Suc N)) powr (Re w + Re z)))\n  0 < Re z\n  1 \\<le> Re w\n\ngoal (1 subgoal):\n 1. summable (\\<lambda>n. C * (1 / real (Suc n + N) powr (Re w + Re z)))", "by (intro summable_mult) (auto simp: field_simps)"], ["proof (state)\nthis:\n  summable (\\<lambda>n. C * (1 / real (Suc n + N) powr (Re w + Re z)))\n\ngoal (6 subgoals):\n 1. g_rem contour_integrable_on A\n 2. finite {complex_of_real R * \\<i>, complex_of_real (- R) * \\<i>}\n 3. 0 \\<le> 2 * C / R\\<^sup>2\n 4. 0 < R\n 5. - pi / 2 \\<le> pi / 2\n 6. \\<And>x.\n       x \\<in> path_image A -\n               {complex_of_real R * \\<i>,\n                complex_of_real (- R) * \\<i>} \\<Longrightarrow>\n       cmod (g_rem x) \\<le> 2 * C / R\\<^sup>2", "have \"rem (w + z) = (\\<Sum>n. fds_nth F (Suc n + N) / (Suc n + N) powr (w + z))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rem (w + z) =\n    (\\<Sum>n. fds_nth F (Suc n + N) / of_nat (Suc n + N) powr (w + z))", "using \\<open>Re z > 0\\<close> w"], ["proof (prove)\nusing this:\n  0 < Re z\n  1 \\<le> Re w\n\ngoal (1 subgoal):\n 1. rem (w + z) =\n    (\\<Sum>n. fds_nth F (Suc n + N) / of_nat (Suc n + N) powr (w + z))", "by (simp add: rem_altdef eval_fds_remainder)"], ["proof (state)\nthis:\n  rem (w + z) =\n  (\\<Sum>n. fds_nth F (Suc n + N) / of_nat (Suc n + N) powr (w + z))\n\ngoal (6 subgoals):\n 1. g_rem contour_integrable_on A\n 2. finite {complex_of_real R * \\<i>, complex_of_real (- R) * \\<i>}\n 3. 0 \\<le> 2 * C / R\\<^sup>2\n 4. 0 < R\n 5. - pi / 2 \\<le> pi / 2\n 6. \\<And>x.\n       x \\<in> path_image A -\n               {complex_of_real R * \\<i>,\n                complex_of_real (- R) * \\<i>} \\<Longrightarrow>\n       cmod (g_rem x) \\<le> 2 * C / R\\<^sup>2", "also"], ["proof (state)\nthis:\n  rem (w + z) =\n  (\\<Sum>n. fds_nth F (Suc n + N) / of_nat (Suc n + N) powr (w + z))\n\ngoal (6 subgoals):\n 1. g_rem contour_integrable_on A\n 2. finite {complex_of_real R * \\<i>, complex_of_real (- R) * \\<i>}\n 3. 0 \\<le> 2 * C / R\\<^sup>2\n 4. 0 < R\n 5. - pi / 2 \\<le> pi / 2\n 6. \\<And>x.\n       x \\<in> path_image A -\n               {complex_of_real R * \\<i>,\n                complex_of_real (- R) * \\<i>} \\<Longrightarrow>\n       cmod (g_rem x) \\<le> 2 * C / R\\<^sup>2", "have \"norm \\<dots> \\<le> (\\<Sum>n. C / (Suc n + N) powr Re (w + z))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod (\\<Sum>n. fds_nth F (Suc n + N) / of_nat (Suc n + N) powr (w + z))\n    \\<le> (\\<Sum>n. C / real (Suc n + N) powr Re (w + z))", "using summable"], ["proof (prove)\nusing this:\n  summable (\\<lambda>n. C * (1 / real (Suc n + N) powr (Re w + Re z)))\n\ngoal (1 subgoal):\n 1. cmod (\\<Sum>n. fds_nth F (Suc n + N) / of_nat (Suc n + N) powr (w + z))\n    \\<le> (\\<Sum>n. C / real (Suc n + N) powr Re (w + z))", "by (intro norm_suminf_le)\n               (auto simp: norm_divide norm_powr_real_powr intro!: divide_right_mono C)"], ["proof (state)\nthis:\n  cmod (\\<Sum>n. fds_nth F (Suc n + N) / of_nat (Suc n + N) powr (w + z))\n  \\<le> (\\<Sum>n. C / real (Suc n + N) powr Re (w + z))\n\ngoal (6 subgoals):\n 1. g_rem contour_integrable_on A\n 2. finite {complex_of_real R * \\<i>, complex_of_real (- R) * \\<i>}\n 3. 0 \\<le> 2 * C / R\\<^sup>2\n 4. 0 < R\n 5. - pi / 2 \\<le> pi / 2\n 6. \\<And>x.\n       x \\<in> path_image A -\n               {complex_of_real R * \\<i>,\n                complex_of_real (- R) * \\<i>} \\<Longrightarrow>\n       cmod (g_rem x) \\<le> 2 * C / R\\<^sup>2", "also"], ["proof (state)\nthis:\n  cmod (\\<Sum>n. fds_nth F (Suc n + N) / of_nat (Suc n + N) powr (w + z))\n  \\<le> (\\<Sum>n. C / real (Suc n + N) powr Re (w + z))\n\ngoal (6 subgoals):\n 1. g_rem contour_integrable_on A\n 2. finite {complex_of_real R * \\<i>, complex_of_real (- R) * \\<i>}\n 3. 0 \\<le> 2 * C / R\\<^sup>2\n 4. 0 < R\n 5. - pi / 2 \\<le> pi / 2\n 6. \\<And>x.\n       x \\<in> path_image A -\n               {complex_of_real R * \\<i>,\n                complex_of_real (- R) * \\<i>} \\<Longrightarrow>\n       cmod (g_rem x) \\<le> 2 * C / R\\<^sup>2", "have \"\\<dots> = (\\<Sum>n. C * (Suc n + N) powr -Re (w + z))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>n. C / real (Suc n + N) powr Re (w + z)) =\n    (\\<Sum>n. C * real (Suc n + N) powr - Re (w + z))", "unfolding powr_minus"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>n. C / real (Suc n + N) powr Re (w + z)) =\n    (\\<Sum>n. C * inverse (real (Suc n + N) powr Re (w + z)))", "by (simp add: field_simps)"], ["proof (state)\nthis:\n  (\\<Sum>n. C / real (Suc n + N) powr Re (w + z)) =\n  (\\<Sum>n. C * real (Suc n + N) powr - Re (w + z))\n\ngoal (6 subgoals):\n 1. g_rem contour_integrable_on A\n 2. finite {complex_of_real R * \\<i>, complex_of_real (- R) * \\<i>}\n 3. 0 \\<le> 2 * C / R\\<^sup>2\n 4. 0 < R\n 5. - pi / 2 \\<le> pi / 2\n 6. \\<And>x.\n       x \\<in> path_image A -\n               {complex_of_real R * \\<i>,\n                complex_of_real (- R) * \\<i>} \\<Longrightarrow>\n       cmod (g_rem x) \\<le> 2 * C / R\\<^sup>2", "also"], ["proof (state)\nthis:\n  (\\<Sum>n. C / real (Suc n + N) powr Re (w + z)) =\n  (\\<Sum>n. C * real (Suc n + N) powr - Re (w + z))\n\ngoal (6 subgoals):\n 1. g_rem contour_integrable_on A\n 2. finite {complex_of_real R * \\<i>, complex_of_real (- R) * \\<i>}\n 3. 0 \\<le> 2 * C / R\\<^sup>2\n 4. 0 < R\n 5. - pi / 2 \\<le> pi / 2\n 6. \\<And>x.\n       x \\<in> path_image A -\n               {complex_of_real R * \\<i>,\n                complex_of_real (- R) * \\<i>} \\<Longrightarrow>\n       cmod (g_rem x) \\<le> 2 * C / R\\<^sup>2", "have \"\\<dots> = C * (\\<Sum>n. (Suc n + N) powr -Re (w + z))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>n. C * real (Suc n + N) powr - Re (w + z)) =\n    C * (\\<Sum>n. real (Suc n + N) powr - Re (w + z))", "using summable_hurwitz_zeta_real[of \"Re w + Re z\" \"Suc N\"] \\<open>Re z > 0\\<close> w"], ["proof (prove)\nusing this:\n  \\<lbrakk>1 < Re w + Re z; 0 < real (Suc N)\\<rbrakk>\n  \\<Longrightarrow> summable\n                     (\\<lambda>n.\n                         (real n + real (Suc N)) powr - (Re w + Re z))\n  0 < Re z\n  1 \\<le> Re w\n\ngoal (1 subgoal):\n 1. (\\<Sum>n. C * real (Suc n + N) powr - Re (w + z)) =\n    C * (\\<Sum>n. real (Suc n + N) powr - Re (w + z))", "by (subst suminf_mult) (auto simp: add_ac)"], ["proof (state)\nthis:\n  (\\<Sum>n. C * real (Suc n + N) powr - Re (w + z)) =\n  C * (\\<Sum>n. real (Suc n + N) powr - Re (w + z))\n\ngoal (6 subgoals):\n 1. g_rem contour_integrable_on A\n 2. finite {complex_of_real R * \\<i>, complex_of_real (- R) * \\<i>}\n 3. 0 \\<le> 2 * C / R\\<^sup>2\n 4. 0 < R\n 5. - pi / 2 \\<le> pi / 2\n 6. \\<And>x.\n       x \\<in> path_image A -\n               {complex_of_real R * \\<i>,\n                complex_of_real (- R) * \\<i>} \\<Longrightarrow>\n       cmod (g_rem x) \\<le> 2 * C / R\\<^sup>2", "also"], ["proof (state)\nthis:\n  (\\<Sum>n. C * real (Suc n + N) powr - Re (w + z)) =\n  C * (\\<Sum>n. real (Suc n + N) powr - Re (w + z))\n\ngoal (6 subgoals):\n 1. g_rem contour_integrable_on A\n 2. finite {complex_of_real R * \\<i>, complex_of_real (- R) * \\<i>}\n 3. 0 \\<le> 2 * C / R\\<^sup>2\n 4. 0 < R\n 5. - pi / 2 \\<le> pi / 2\n 6. \\<And>x.\n       x \\<in> path_image A -\n               {complex_of_real R * \\<i>,\n                complex_of_real (- R) * \\<i>} \\<Longrightarrow>\n       cmod (g_rem x) \\<le> 2 * C / R\\<^sup>2", "have \"(\\<Sum>n. (Suc n + N) powr -Re (w + z)) \\<le>\n                       N powr (1 - Re (w + z)) / (Re (w + z) - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>n. real (Suc n + N) powr - Re (w + z))\n    \\<le> real N powr (1 - Re (w + z)) / (Re (w + z) - 1)", "using \\<open>Re z > 0\\<close> w N hurwitz_zeta_real_bound_aux[of N \"Re (w + z)\"]"], ["proof (prove)\nusing this:\n  0 < Re z\n  1 \\<le> Re w\n  bound N < \\<epsilon>\n  1 < N\n  \\<lbrakk>0 < real N; 1 < Re (w + z)\\<rbrakk>\n  \\<Longrightarrow> (\\<Sum>i. (real N + real (Suc i)) powr - Re (w + z))\n                    \\<le> real N powr (1 - Re (w + z)) / (Re (w + z) - 1)\n\ngoal (1 subgoal):\n 1. (\\<Sum>n. real (Suc n + N) powr - Re (w + z))\n    \\<le> real N powr (1 - Re (w + z)) / (Re (w + z) - 1)", "by (auto simp: add_ac)"], ["proof (state)\nthis:\n  (\\<Sum>n. real (Suc n + N) powr - Re (w + z))\n  \\<le> real N powr (1 - Re (w + z)) / (Re (w + z) - 1)\n\ngoal (6 subgoals):\n 1. g_rem contour_integrable_on A\n 2. finite {complex_of_real R * \\<i>, complex_of_real (- R) * \\<i>}\n 3. 0 \\<le> 2 * C / R\\<^sup>2\n 4. 0 < R\n 5. - pi / 2 \\<le> pi / 2\n 6. \\<And>x.\n       x \\<in> path_image A -\n               {complex_of_real R * \\<i>,\n                complex_of_real (- R) * \\<i>} \\<Longrightarrow>\n       cmod (g_rem x) \\<le> 2 * C / R\\<^sup>2", "also"], ["proof (state)\nthis:\n  (\\<Sum>n. real (Suc n + N) powr - Re (w + z))\n  \\<le> real N powr (1 - Re (w + z)) / (Re (w + z) - 1)\n\ngoal (6 subgoals):\n 1. g_rem contour_integrable_on A\n 2. finite {complex_of_real R * \\<i>, complex_of_real (- R) * \\<i>}\n 3. 0 \\<le> 2 * C / R\\<^sup>2\n 4. 0 < R\n 5. - pi / 2 \\<le> pi / 2\n 6. \\<And>x.\n       x \\<in> path_image A -\n               {complex_of_real R * \\<i>,\n                complex_of_real (- R) * \\<i>} \\<Longrightarrow>\n       cmod (g_rem x) \\<le> 2 * C / R\\<^sup>2", "have \"\\<dots> \\<le> N powr -Re z / Re z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real N powr (1 - Re (w + z)) / (Re (w + z) - 1)\n    \\<le> real N powr - Re z / Re z", "using w N \\<open>Re z > 0\\<close>"], ["proof (prove)\nusing this:\n  1 \\<le> Re w\n  bound N < \\<epsilon>\n  1 < N\n  0 < Re z\n\ngoal (1 subgoal):\n 1. real N powr (1 - Re (w + z)) / (Re (w + z) - 1)\n    \\<le> real N powr - Re z / Re z", "by (intro frac_le powr_mono) auto"], ["proof (state)\nthis:\n  real N powr (1 - Re (w + z)) / (Re (w + z) - 1)\n  \\<le> real N powr - Re z / Re z\n\ngoal (6 subgoals):\n 1. g_rem contour_integrable_on A\n 2. finite {complex_of_real R * \\<i>, complex_of_real (- R) * \\<i>}\n 3. 0 \\<le> 2 * C / R\\<^sup>2\n 4. 0 < R\n 5. - pi / 2 \\<le> pi / 2\n 6. \\<And>x.\n       x \\<in> path_image A -\n               {complex_of_real R * \\<i>,\n                complex_of_real (- R) * \\<i>} \\<Longrightarrow>\n       cmod (g_rem x) \\<le> 2 * C / R\\<^sup>2", "finally"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<And>x y. x \\<le> y \\<Longrightarrow> C * x \\<le> C * y;\n   \\<And>x y. x \\<le> y \\<Longrightarrow> C * x \\<le> C * y\\<rbrakk>\n  \\<Longrightarrow> cmod (rem (w + z)) \\<le> C * (real N powr - Re z / Re z)", "have \"norm (rem (w + z)) \\<le> C / (Re z * N powr Re z)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>x y. x \\<le> y \\<Longrightarrow> C * x \\<le> C * y;\n   \\<And>x y. x \\<le> y \\<Longrightarrow> C * x \\<le> C * y\\<rbrakk>\n  \\<Longrightarrow> cmod (rem (w + z)) \\<le> C * (real N powr - Re z / Re z)\n\ngoal (1 subgoal):\n 1. cmod (rem (w + z)) \\<le> C / (Re z * real N powr Re z)", "using C"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>x y. x \\<le> y \\<Longrightarrow> C * x \\<le> C * y;\n   \\<And>x y. x \\<le> y \\<Longrightarrow> C * x \\<le> C * y\\<rbrakk>\n  \\<Longrightarrow> cmod (rem (w + z)) \\<le> C * (real N powr - Re z / Re z)\n  1 \\<le> C\n  cmod (fds_nth F ?n) \\<le> C\n\ngoal (1 subgoal):\n 1. cmod (rem (w + z)) \\<le> C / (Re z * real N powr Re z)", "by (simp add: mult_left_mono mult_right_mono powr_minus field_simps)"], ["proof (state)\nthis:\n  cmod (rem (w + z)) \\<le> C / (Re z * real N powr Re z)\n\ngoal (6 subgoals):\n 1. g_rem contour_integrable_on A\n 2. finite {complex_of_real R * \\<i>, complex_of_real (- R) * \\<i>}\n 3. 0 \\<le> 2 * C / R\\<^sup>2\n 4. 0 < R\n 5. - pi / 2 \\<le> pi / 2\n 6. \\<And>x.\n       x \\<in> path_image A -\n               {complex_of_real R * \\<i>,\n                complex_of_real (- R) * \\<i>} \\<Longrightarrow>\n       cmod (g_rem x) \\<le> 2 * C / R\\<^sup>2", "hence \"norm (g_rem z) \\<le> (C / (Re z * N powr Re z)) * N powr (Re z) * (2 * Re z / R\\<^sup>2)\""], ["proof (prove)\nusing this:\n  cmod (rem (w + z)) \\<le> C / (Re z * real N powr Re z)\n\ngoal (1 subgoal):\n 1. cmod (g_rem z)\n    \\<le> C / (Re z * real N powr Re z) * real N powr Re z *\n          (2 * Re z / R\\<^sup>2)", "unfolding g_rem_def norm_mult"], ["proof (prove)\nusing this:\n  cmod (rem (w + z)) \\<le> C / (Re z * real N powr Re z)\n\ngoal (1 subgoal):\n 1. cmod (rem (w + z)) * cmod (of_nat N powr z) *\n    cmod (1 / z + z / complex_of_real (R\\<^sup>2))\n    \\<le> C / (Re z * real N powr Re z) * real N powr Re z *\n          (2 * Re z / R\\<^sup>2)", "using newman_ingham_aux1[OF _ \\<open>norm z = R\\<close>] R \\<open>Re z > 0\\<close> C"], ["proof (prove)\nusing this:\n  cmod (rem (w + z)) \\<le> C / (Re z * real N powr Re z)\n  0 < R \\<Longrightarrow>\n  cmod (1 / z + z / complex_of_real (R\\<^sup>2)) =\n  2 * \\<bar>Re z\\<bar> / R\\<^sup>2\n  3 * C / \\<epsilon> \\<le> R\n  1 \\<le> R\n  0 < Re z\n  1 \\<le> C\n  cmod (fds_nth F ?n) \\<le> C\n\ngoal (1 subgoal):\n 1. cmod (rem (w + z)) * cmod (of_nat N powr z) *\n    cmod (1 / z + z / complex_of_real (R\\<^sup>2))\n    \\<le> C / (Re z * real N powr Re z) * real N powr Re z *\n          (2 * Re z / R\\<^sup>2)", "by (intro mult_mono mult_nonneg_nonneg circle_bound)\n               (auto simp: norm_powr_real_powr norm_uminus_minus)"], ["proof (state)\nthis:\n  cmod (g_rem z)\n  \\<le> C / (Re z * real N powr Re z) * real N powr Re z *\n        (2 * Re z / R\\<^sup>2)\n\ngoal (6 subgoals):\n 1. g_rem contour_integrable_on A\n 2. finite {complex_of_real R * \\<i>, complex_of_real (- R) * \\<i>}\n 3. 0 \\<le> 2 * C / R\\<^sup>2\n 4. 0 < R\n 5. - pi / 2 \\<le> pi / 2\n 6. \\<And>x.\n       x \\<in> path_image A -\n               {complex_of_real R * \\<i>,\n                complex_of_real (- R) * \\<i>} \\<Longrightarrow>\n       cmod (g_rem x) \\<le> 2 * C / R\\<^sup>2", "also"], ["proof (state)\nthis:\n  cmod (g_rem z)\n  \\<le> C / (Re z * real N powr Re z) * real N powr Re z *\n        (2 * Re z / R\\<^sup>2)\n\ngoal (6 subgoals):\n 1. g_rem contour_integrable_on A\n 2. finite {complex_of_real R * \\<i>, complex_of_real (- R) * \\<i>}\n 3. 0 \\<le> 2 * C / R\\<^sup>2\n 4. 0 < R\n 5. - pi / 2 \\<le> pi / 2\n 6. \\<And>x.\n       x \\<in> path_image A -\n               {complex_of_real R * \\<i>,\n                complex_of_real (- R) * \\<i>} \\<Longrightarrow>\n       cmod (g_rem x) \\<le> 2 * C / R\\<^sup>2", "have \"\\<dots> = 2 * C / R\\<^sup>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. C / (Re z * real N powr Re z) * real N powr Re z *\n    (2 * Re z / R\\<^sup>2) =\n    2 * C / R\\<^sup>2", "using R N \\<open>Re z > 0\\<close>"], ["proof (prove)\nusing this:\n  3 * C / \\<epsilon> \\<le> R\n  1 \\<le> R\n  bound N < \\<epsilon>\n  1 < N\n  0 < Re z\n\ngoal (1 subgoal):\n 1. C / (Re z * real N powr Re z) * real N powr Re z *\n    (2 * Re z / R\\<^sup>2) =\n    2 * C / R\\<^sup>2", "by (simp add: powr_minus field_simps)"], ["proof (state)\nthis:\n  C / (Re z * real N powr Re z) * real N powr Re z *\n  (2 * Re z / R\\<^sup>2) =\n  2 * C / R\\<^sup>2\n\ngoal (6 subgoals):\n 1. g_rem contour_integrable_on A\n 2. finite {complex_of_real R * \\<i>, complex_of_real (- R) * \\<i>}\n 3. 0 \\<le> 2 * C / R\\<^sup>2\n 4. 0 < R\n 5. - pi / 2 \\<le> pi / 2\n 6. \\<And>x.\n       x \\<in> path_image A -\n               {complex_of_real R * \\<i>,\n                complex_of_real (- R) * \\<i>} \\<Longrightarrow>\n       cmod (g_rem x) \\<le> 2 * C / R\\<^sup>2", "finally"], ["proof (chain)\npicking this:\n  cmod (g_rem z) \\<le> 2 * C / R\\<^sup>2", "show ?case"], ["proof (prove)\nusing this:\n  cmod (g_rem z) \\<le> 2 * C / R\\<^sup>2\n\ngoal (1 subgoal):\n 1. cmod (g_rem z) \\<le> 2 * C / R\\<^sup>2", "."], ["proof (state)\nthis:\n  cmod (g_rem z) \\<le> 2 * C / R\\<^sup>2\n\ngoal (5 subgoals):\n 1. g_rem contour_integrable_on A\n 2. finite {complex_of_real R * \\<i>, complex_of_real (- R) * \\<i>}\n 3. 0 \\<le> 2 * C / R\\<^sup>2\n 4. 0 < R\n 5. - pi / 2 \\<le> pi / 2", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. g_rem contour_integrable_on A\n 2. finite {complex_of_real R * \\<i>, complex_of_real (- R) * \\<i>}\n 3. 0 \\<le> 2 * C / R\\<^sup>2\n 4. 0 < R\n 5. - pi / 2 \\<le> pi / 2", "show \"g_rem contour_integrable_on A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g_rem contour_integrable_on A", "using path_images"], ["proof (prove)\nusing this:\n  path_image B2 \\<subseteq> X' - {0}\n  path_image A \\<subseteq> X' - {0}\n  path_image B1 \\<subseteq> X' - {0}\n  path_image B3 \\<subseteq> X' - {0}\n  X' \\<subseteq> X\n\ngoal (1 subgoal):\n 1. g_rem contour_integrable_on A", "by (auto simp: g_rem_def rem_def S_def\n                     intro!: contour_integrable_holomorphic_simple[of _ \"X-{0}\"] holomorphic_intros)"], ["proof (state)\nthis:\n  g_rem contour_integrable_on A\n\ngoal (4 subgoals):\n 1. finite {complex_of_real R * \\<i>, complex_of_real (- R) * \\<i>}\n 2. 0 \\<le> 2 * C / R\\<^sup>2\n 3. 0 < R\n 4. - pi / 2 \\<le> pi / 2", "qed (insert R N C, auto)"], ["proof (state)\nthis:\n  cmod (\\<ointegral>[A] g_rem)\n  \\<le> 2 * C / R\\<^sup>2 * R * (pi / 2 - - pi / 2)\n\ngoal (1 subgoal):\n 1. cmod (\\<ointegral>[A] g_rem) \\<le> 2 * C * pi / R", "also"], ["proof (state)\nthis:\n  cmod (\\<ointegral>[A] g_rem)\n  \\<le> 2 * C / R\\<^sup>2 * R * (pi / 2 - - pi / 2)\n\ngoal (1 subgoal):\n 1. cmod (\\<ointegral>[A] g_rem) \\<le> 2 * C * pi / R", "have \"(2 * C / R\\<^sup>2) * R * ((pi/2) - (-pi/2)) = 2 * C * pi / R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * C / R\\<^sup>2 * R * (pi / 2 - - pi / 2) = 2 * C * pi / R", "using R"], ["proof (prove)\nusing this:\n  3 * C / \\<epsilon> \\<le> R\n  1 \\<le> R\n\ngoal (1 subgoal):\n 1. 2 * C / R\\<^sup>2 * R * (pi / 2 - - pi / 2) = 2 * C * pi / R", "by (simp add: power2_eq_square field_simps)"], ["proof (state)\nthis:\n  2 * C / R\\<^sup>2 * R * (pi / 2 - - pi / 2) = 2 * C * pi / R\n\ngoal (1 subgoal):\n 1. cmod (\\<ointegral>[A] g_rem) \\<le> 2 * C * pi / R", "finally"], ["proof (chain)\npicking this:\n  cmod (\\<ointegral>[A] g_rem) \\<le> 2 * C * pi / R", "show \"norm (\\<ointegral>[A] g_rem) \\<le> \\<dots>\""], ["proof (prove)\nusing this:\n  cmod (\\<ointegral>[A] g_rem) \\<le> 2 * C * pi / R\n\ngoal (1 subgoal):\n 1. cmod (\\<ointegral>[A] g_rem) \\<le> 2 * C * pi / R", "."], ["proof (state)\nthis:\n  cmod (\\<ointegral>[A] g_rem) \\<le> 2 * C * pi / R\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  cmod\n   (\\<ointegral>[A] g_rem + \\<ointegral>[A] (\\<lambda>x. g_S (- x)) +\n    \\<ointegral>[B1] g +\n    \\<ointegral>[B3] g +\n    \\<ointegral>[B2] g)\n  \\<le> 2 * C * pi / R + 2 * C * pi * (1 / real N + 1 / R) +\n        3 * M / R / ln (real N) +\n        3 * M / R / ln (real N) +\n        6 * R * M * real N powr - \\<delta> / \\<delta>\n\ngoal (1 subgoal):\n 1. \\<And>N.\n       \\<lbrakk>bound N < \\<epsilon>; 1 < N\\<rbrakk>\n       \\<Longrightarrow> cmod (f w - eval_fds (fds_truncate N F) w)\n                         < \\<epsilon>", "also"], ["proof (state)\nthis:\n  cmod\n   (\\<ointegral>[A] g_rem + \\<ointegral>[A] (\\<lambda>x. g_S (- x)) +\n    \\<ointegral>[B1] g +\n    \\<ointegral>[B3] g +\n    \\<ointegral>[B2] g)\n  \\<le> 2 * C * pi / R + 2 * C * pi * (1 / real N + 1 / R) +\n        3 * M / R / ln (real N) +\n        3 * M / R / ln (real N) +\n        6 * R * M * real N powr - \\<delta> / \\<delta>\n\ngoal (1 subgoal):\n 1. \\<And>N.\n       \\<lbrakk>bound N < \\<epsilon>; 1 < N\\<rbrakk>\n       \\<Longrightarrow> cmod (f w - eval_fds (fds_truncate N F) w)\n                         < \\<epsilon>", "have \"\\<dots> = 4*C*pi/R + 2*C*pi/N + 6*M/R / ln N + 6*R*M*N powr - \\<delta> / \\<delta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * C * pi / R + 2 * C * pi * (1 / real N + 1 / R) +\n    3 * M / R / ln (real N) +\n    3 * M / R / ln (real N) +\n    6 * R * M * real N powr - \\<delta> / \\<delta> =\n    4 * C * pi / R + 2 * C * pi / real N + 6 * M / R / ln (real N) +\n    6 * R * M * real N powr - \\<delta> / \\<delta>", "by (simp add: algebra_simps)"], ["proof (state)\nthis:\n  2 * C * pi / R + 2 * C * pi * (1 / real N + 1 / R) +\n  3 * M / R / ln (real N) +\n  3 * M / R / ln (real N) +\n  6 * R * M * real N powr - \\<delta> / \\<delta> =\n  4 * C * pi / R + 2 * C * pi / real N + 6 * M / R / ln (real N) +\n  6 * R * M * real N powr - \\<delta> / \\<delta>\n\ngoal (1 subgoal):\n 1. \\<And>N.\n       \\<lbrakk>bound N < \\<epsilon>; 1 < N\\<rbrakk>\n       \\<Longrightarrow> cmod (f w - eval_fds (fds_truncate N F) w)\n                         < \\<epsilon>", "also"], ["proof (state)\nthis:\n  2 * C * pi / R + 2 * C * pi * (1 / real N + 1 / R) +\n  3 * M / R / ln (real N) +\n  3 * M / R / ln (real N) +\n  6 * R * M * real N powr - \\<delta> / \\<delta> =\n  4 * C * pi / R + 2 * C * pi / real N + 6 * M / R / ln (real N) +\n  6 * R * M * real N powr - \\<delta> / \\<delta>\n\ngoal (1 subgoal):\n 1. \\<And>N.\n       \\<lbrakk>bound N < \\<epsilon>; 1 < N\\<rbrakk>\n       \\<Longrightarrow> cmod (f w - eval_fds (fds_truncate N F) w)\n                         < \\<epsilon>", "have \"\\<dots> = 2*pi * (2*C/R + C/N + 3*M / (pi*R*ln N) + 3*R*M / (\\<delta>*pi * N powr \\<delta>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 4 * C * pi / R + 2 * C * pi / real N + 6 * M / R / ln (real N) +\n    6 * R * M * real N powr - \\<delta> / \\<delta> =\n    2 * pi *\n    (2 * C / R + C / real N + 3 * M / (pi * R * ln (real N)) +\n     3 * R * M / (\\<delta> * pi * real N powr \\<delta>))", "by (simp add: field_simps powr_minus )"], ["proof (state)\nthis:\n  4 * C * pi / R + 2 * C * pi / real N + 6 * M / R / ln (real N) +\n  6 * R * M * real N powr - \\<delta> / \\<delta> =\n  2 * pi *\n  (2 * C / R + C / real N + 3 * M / (pi * R * ln (real N)) +\n   3 * R * M / (\\<delta> * pi * real N powr \\<delta>))\n\ngoal (1 subgoal):\n 1. \\<And>N.\n       \\<lbrakk>bound N < \\<epsilon>; 1 < N\\<rbrakk>\n       \\<Longrightarrow> cmod (f w - eval_fds (fds_truncate N F) w)\n                         < \\<epsilon>", "also"], ["proof (state)\nthis:\n  4 * C * pi / R + 2 * C * pi / real N + 6 * M / R / ln (real N) +\n  6 * R * M * real N powr - \\<delta> / \\<delta> =\n  2 * pi *\n  (2 * C / R + C / real N + 3 * M / (pi * R * ln (real N)) +\n   3 * R * M / (\\<delta> * pi * real N powr \\<delta>))\n\ngoal (1 subgoal):\n 1. \\<And>N.\n       \\<lbrakk>bound N < \\<epsilon>; 1 < N\\<rbrakk>\n       \\<Longrightarrow> cmod (f w - eval_fds (fds_truncate N F) w)\n                         < \\<epsilon>", "have \"norm (2 * pi * \\<i> * (f w - S w)) = 2 * pi * norm (f w - S w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod (complex_of_real (2 * pi) * \\<i> * (f w - S w)) =\n    2 * pi * cmod (f w - S w)", "by (simp add: norm_mult)"], ["proof (state)\nthis:\n  cmod (complex_of_real (2 * pi) * \\<i> * (f w - S w)) =\n  2 * pi * cmod (f w - S w)\n\ngoal (1 subgoal):\n 1. \\<And>N.\n       \\<lbrakk>bound N < \\<epsilon>; 1 < N\\<rbrakk>\n       \\<Longrightarrow> cmod (f w - eval_fds (fds_truncate N F) w)\n                         < \\<epsilon>", "finally"], ["proof (chain)\npicking this:\n  2 * pi * cmod (f w - S w)\n  \\<le> 2 * pi *\n        (2 * C / R + C / real N + 3 * M / (pi * R * ln (real N)) +\n         3 * R * M / (\\<delta> * pi * real N powr \\<delta>))", "have \"norm (f w - S w) \\<le> bound N\""], ["proof (prove)\nusing this:\n  2 * pi * cmod (f w - S w)\n  \\<le> 2 * pi *\n        (2 * C / R + C / real N + 3 * M / (pi * R * ln (real N)) +\n         3 * R * M / (\\<delta> * pi * real N powr \\<delta>))\n\ngoal (1 subgoal):\n 1. cmod (f w - S w) \\<le> bound N", "by (simp add: bound_def)"], ["proof (state)\nthis:\n  cmod (f w - S w) \\<le> bound N\n\ngoal (1 subgoal):\n 1. \\<And>N.\n       \\<lbrakk>bound N < \\<epsilon>; 1 < N\\<rbrakk>\n       \\<Longrightarrow> cmod (f w - eval_fds (fds_truncate N F) w)\n                         < \\<epsilon>", "also"], ["proof (state)\nthis:\n  cmod (f w - S w) \\<le> bound N\n\ngoal (1 subgoal):\n 1. \\<And>N.\n       \\<lbrakk>bound N < \\<epsilon>; 1 < N\\<rbrakk>\n       \\<Longrightarrow> cmod (f w - eval_fds (fds_truncate N F) w)\n                         < \\<epsilon>", "have \"bound N < \\<epsilon>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bound N < \\<epsilon>", "by fact"], ["proof (state)\nthis:\n  bound N < \\<epsilon>\n\ngoal (1 subgoal):\n 1. \\<And>N.\n       \\<lbrakk>bound N < \\<epsilon>; 1 < N\\<rbrakk>\n       \\<Longrightarrow> cmod (f w - eval_fds (fds_truncate N F) w)\n                         < \\<epsilon>", "finally"], ["proof (chain)\npicking this:\n  cmod (f w - S w) < \\<epsilon>", "show \"norm (f w - S w) < \\<epsilon>\""], ["proof (prove)\nusing this:\n  cmod (f w - S w) < \\<epsilon>\n\ngoal (1 subgoal):\n 1. cmod (f w - S w) < \\<epsilon>", "."], ["proof (state)\nthis:\n  cmod (f w - S w) < \\<epsilon>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F N in sequentially.\n     cmod (f w - eval_fds (fds_truncate N F) w) < \\<epsilon>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<lambda>N. eval_fds (fds_truncate N F) w) \\<longlonglongrightarrow> f w\n\ngoal (2 subgoals):\n 1. fds_converges F w\n 2. eval_fds F w = f w", "thus \"fds_converges F w\""], ["proof (prove)\nusing this:\n  (\\<lambda>N. eval_fds (fds_truncate N F) w) \\<longlonglongrightarrow> f w\n\ngoal (1 subgoal):\n 1. fds_converges F w", "by (auto simp: fds_converges_altdef2 intro: convergentI)"], ["proof (state)\nthis:\n  fds_converges F w\n\ngoal (1 subgoal):\n 1. eval_fds F w = f w", "thus \"eval_fds F w = f w\""], ["proof (prove)\nusing this:\n  fds_converges F w\n\ngoal (1 subgoal):\n 1. eval_fds F w = f w", "using \\<open>(\\<lambda>N. eval_fds (fds_truncate N F) w) \\<longlonglongrightarrow> f w\\<close>"], ["proof (prove)\nusing this:\n  fds_converges F w\n  (\\<lambda>N. eval_fds (fds_truncate N F) w) \\<longlonglongrightarrow> f w\n\ngoal (1 subgoal):\n 1. eval_fds F w = f w", "by (intro tendsto_unique[OF _ tendsto_eval_fds_truncate]) auto"], ["proof (state)\nthis:\n  eval_fds F w = f w\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  The theorem generalises in a trivial way; we can replace the requirement that the\n  coefficients of $f(s)$ be $O(1)$ by $O(n^{\\sigma-1})$ for some $\\sigma\\in\\mathbb{R}$, then\n  $f(s)$ converges for $\\mathfrak{R}(s)>\\sigma$. If it can be analytically continued to\n  $\\mathfrak{R}(s)\\geq\\sigma$, it is also convergent there.\n\\<close>"], ["", "theorem Newman_Ingham:\n  fixes F :: \"complex fds\" and f :: \"complex \\<Rightarrow> complex\"\n  assumes coeff_bound:   \"fds_nth F \\<in> O(\\<lambda>n. n powr of_real (\\<sigma> - 1))\"\n  assumes f_analytic:    \"f analytic_on {s. Re s \\<ge> \\<sigma>}\"\n  assumes F_conv_f:      \"\\<And>s. Re s > \\<sigma> \\<Longrightarrow> eval_fds F s = f s\"\n  assumes w:             \"Re w \\<ge> \\<sigma>\"\n  shows   \"fds_converges F w\" and \"eval_fds F w = f w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fds_converges F w &&& eval_fds F w = f w", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. fds_converges F w\n 2. eval_fds F w = f w", "define F' where \"F' = fds_shift (-of_real (\\<sigma> - 1)) F\""], ["proof (state)\nthis:\n  F' = fds_shift (- complex_of_real (\\<sigma> - 1)) F\n\ngoal (2 subgoals):\n 1. fds_converges F w\n 2. eval_fds F w = f w", "define f' where \"f' = f \\<circ> (\\<lambda>s. s + of_real (\\<sigma> - 1))\""], ["proof (state)\nthis:\n  f' = f \\<circ> (\\<lambda>s. s + complex_of_real (\\<sigma> - 1))\n\ngoal (2 subgoals):\n 1. fds_converges F w\n 2. eval_fds F w = f w", "have \"fds_nth F' = (\\<lambda>n. fds_nth F n * of_nat n powr -of_real(\\<sigma> - 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fds_nth F' =\n    (\\<lambda>n.\n        fds_nth F n * of_nat n powr - complex_of_real (\\<sigma> - 1))", "by (auto simp: fun_eq_iff F'_def)"], ["proof (state)\nthis:\n  fds_nth F' =\n  (\\<lambda>n. fds_nth F n * of_nat n powr - complex_of_real (\\<sigma> - 1))\n\ngoal (2 subgoals):\n 1. fds_converges F w\n 2. eval_fds F w = f w", "also"], ["proof (state)\nthis:\n  fds_nth F' =\n  (\\<lambda>n. fds_nth F n * of_nat n powr - complex_of_real (\\<sigma> - 1))\n\ngoal (2 subgoals):\n 1. fds_converges F w\n 2. eval_fds F w = f w", "have \"\\<dots> \\<in> O(\\<lambda>n. of_nat n powr of_real (\\<sigma> - 1) * of_nat n powr -of_real(\\<sigma> - 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n.\n        fds_nth F n * of_nat n powr - complex_of_real (\\<sigma> - 1))\n    \\<in> O(\\<lambda>n.\n               of_nat n powr complex_of_real (\\<sigma> - 1) *\n               of_nat n powr - complex_of_real (\\<sigma> - 1))", "by (intro landau_o.big.mult_right assms)"], ["proof (state)\nthis:\n  (\\<lambda>n. fds_nth F n * of_nat n powr - complex_of_real (\\<sigma> - 1))\n  \\<in> O(\\<lambda>n.\n             of_nat n powr complex_of_real (\\<sigma> - 1) *\n             of_nat n powr - complex_of_real (\\<sigma> - 1))\n\ngoal (2 subgoals):\n 1. fds_converges F w\n 2. eval_fds F w = f w", "also"], ["proof (state)\nthis:\n  (\\<lambda>n. fds_nth F n * of_nat n powr - complex_of_real (\\<sigma> - 1))\n  \\<in> O(\\<lambda>n.\n             of_nat n powr complex_of_real (\\<sigma> - 1) *\n             of_nat n powr - complex_of_real (\\<sigma> - 1))\n\ngoal (2 subgoals):\n 1. fds_converges F w\n 2. eval_fds F w = f w", "have \"(\\<lambda>n. of_nat n powr of_real (\\<sigma> - 1) * of_nat n powr -of_real (\\<sigma> - 1)) \\<in> \\<Theta>(\\<lambda>_. 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n.\n        of_nat n powr of_real (\\<sigma> - 1) *\n        of_nat n powr - of_real (\\<sigma> - 1))\n    \\<in> \\<Theta>(\\<lambda>_. 1::'a)", "by (intro bigthetaI_cong eventually_mono[OF eventually_gt_at_top[of 0]])\n       (auto simp: powr_minus powr_diff)"], ["proof (state)\nthis:\n  (\\<lambda>n.\n      of_nat n powr of_real (\\<sigma> - 1) *\n      of_nat n powr - of_real (\\<sigma> - 1))\n  \\<in> \\<Theta>(\\<lambda>_. 1::?'a1)\n\ngoal (2 subgoals):\n 1. fds_converges F w\n 2. eval_fds F w = f w", "finally"], ["proof (chain)\npicking this:\n  fds_nth F' \\<in> O(\\<lambda>_. 1)", "have bigo: \"fds_nth F' \\<in> O(\\<lambda>_. 1)\""], ["proof (prove)\nusing this:\n  fds_nth F' \\<in> O(\\<lambda>_. 1)\n\ngoal (1 subgoal):\n 1. fds_nth F' \\<in> O(\\<lambda>_. 1)", "."], ["proof (state)\nthis:\n  fds_nth F' \\<in> O(\\<lambda>_. 1)\n\ngoal (2 subgoals):\n 1. fds_converges F w\n 2. eval_fds F w = f w", "from f_analytic"], ["proof (chain)\npicking this:\n  f analytic_on {s. \\<sigma> \\<le> Re s}", "have analytic: \"f' analytic_on {s. Re s \\<ge> 1}\""], ["proof (prove)\nusing this:\n  f analytic_on {s. \\<sigma> \\<le> Re s}\n\ngoal (1 subgoal):\n 1. f' analytic_on {s. 1 \\<le> Re s}", "unfolding f'_def"], ["proof (prove)\nusing this:\n  f analytic_on {s. \\<sigma> \\<le> Re s}\n\ngoal (1 subgoal):\n 1. f \\<circ> (\\<lambda>s. s + complex_of_real (\\<sigma> - 1)) analytic_on\n    {s. 1 \\<le> Re s}", "by (intro analytic_on_compose_gen[OF _ f_analytic]) (auto intro!: analytic_intros)"], ["proof (state)\nthis:\n  f' analytic_on {s. 1 \\<le> Re s}\n\ngoal (2 subgoals):\n 1. fds_converges F w\n 2. eval_fds F w = f w", "have F'_f: \"eval_fds F' s = f' s\" if \"Re s > 1\" for s"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_fds F' s = f' s", "using assms that"], ["proof (prove)\nusing this:\n  fds_nth F\n  \\<in> O(\\<lambda>x. of_nat x powr complex_of_real (\\<sigma> - 1))\n  f analytic_on {s. \\<sigma> \\<le> Re s}\n  \\<sigma> < Re ?s \\<Longrightarrow> eval_fds F ?s = f ?s\n  \\<sigma> \\<le> Re w\n  1 < Re s\n\ngoal (1 subgoal):\n 1. eval_fds F' s = f' s", "by (auto simp: F'_def f'_def algebra_simps)"], ["proof (state)\nthis:\n  1 < Re ?s1 \\<Longrightarrow> eval_fds F' ?s1 = f' ?s1\n\ngoal (2 subgoals):\n 1. fds_converges F w\n 2. eval_fds F w = f w", "have w': \"1 \\<le> Re (w - of_real (\\<sigma> - 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 \\<le> Re (w - complex_of_real (\\<sigma> - 1))", "using w"], ["proof (prove)\nusing this:\n  \\<sigma> \\<le> Re w\n\ngoal (1 subgoal):\n 1. 1 \\<le> Re (w - complex_of_real (\\<sigma> - 1))", "by simp"], ["proof (state)\nthis:\n  1 \\<le> Re (w - complex_of_real (\\<sigma> - 1))\n\ngoal (2 subgoals):\n 1. fds_converges F w\n 2. eval_fds F w = f w", "have 1: \"fds_converges F' (w - of_real (\\<sigma> - 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fds_converges F' (w - complex_of_real (\\<sigma> - 1))", "using bigo analytic F'_f w'"], ["proof (prove)\nusing this:\n  fds_nth F' \\<in> O(\\<lambda>_. 1)\n  f' analytic_on {s. 1 \\<le> Re s}\n  1 < Re ?s1 \\<Longrightarrow> eval_fds F' ?s1 = f' ?s1\n  1 \\<le> Re (w - complex_of_real (\\<sigma> - 1))\n\ngoal (1 subgoal):\n 1. fds_converges F' (w - complex_of_real (\\<sigma> - 1))", "by (rule Newman_Ingham_1)"], ["proof (state)\nthis:\n  fds_converges F' (w - complex_of_real (\\<sigma> - 1))\n\ngoal (2 subgoals):\n 1. fds_converges F w\n 2. eval_fds F w = f w", "thus \"fds_converges F w\""], ["proof (prove)\nusing this:\n  fds_converges F' (w - complex_of_real (\\<sigma> - 1))\n\ngoal (1 subgoal):\n 1. fds_converges F w", "by (auto simp: F'_def)"], ["proof (state)\nthis:\n  fds_converges F w\n\ngoal (1 subgoal):\n 1. eval_fds F w = f w", "have 2: \"eval_fds F' (w - of_real (\\<sigma> - 1)) = f' (w - of_real (\\<sigma> - 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_fds F' (w - complex_of_real (\\<sigma> - 1)) =\n    f' (w - complex_of_real (\\<sigma> - 1))", "using bigo analytic F'_f w'"], ["proof (prove)\nusing this:\n  fds_nth F' \\<in> O(\\<lambda>_. 1)\n  f' analytic_on {s. 1 \\<le> Re s}\n  1 < Re ?s1 \\<Longrightarrow> eval_fds F' ?s1 = f' ?s1\n  1 \\<le> Re (w - complex_of_real (\\<sigma> - 1))\n\ngoal (1 subgoal):\n 1. eval_fds F' (w - complex_of_real (\\<sigma> - 1)) =\n    f' (w - complex_of_real (\\<sigma> - 1))", "by (rule Newman_Ingham_1)"], ["proof (state)\nthis:\n  eval_fds F' (w - complex_of_real (\\<sigma> - 1)) =\n  f' (w - complex_of_real (\\<sigma> - 1))\n\ngoal (1 subgoal):\n 1. eval_fds F w = f w", "thus \"eval_fds F w = f w\""], ["proof (prove)\nusing this:\n  eval_fds F' (w - complex_of_real (\\<sigma> - 1)) =\n  f' (w - complex_of_real (\\<sigma> - 1))\n\ngoal (1 subgoal):\n 1. eval_fds F w = f w", "using assms"], ["proof (prove)\nusing this:\n  eval_fds F' (w - complex_of_real (\\<sigma> - 1)) =\n  f' (w - complex_of_real (\\<sigma> - 1))\n  fds_nth F\n  \\<in> O(\\<lambda>x. of_nat x powr complex_of_real (\\<sigma> - 1))\n  f analytic_on {s. \\<sigma> \\<le> Re s}\n  \\<sigma> < Re ?s \\<Longrightarrow> eval_fds F ?s = f ?s\n  \\<sigma> \\<le> Re w\n\ngoal (1 subgoal):\n 1. eval_fds F w = f w", "by (simp add: F'_def f'_def)"], ["proof (state)\nthis:\n  eval_fds F w = f w\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}