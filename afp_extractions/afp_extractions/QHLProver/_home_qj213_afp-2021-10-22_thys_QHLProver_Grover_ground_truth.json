{"file_name": "/home/qj213/afp-2021-10-22/thys/QHLProver/Grover.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/QHLProver", "problem_names": ["lemma N_ge_0 [simp]: \"0 < N\"", "lemma M_ge_0 [simp]: \"0 < M\"", "lemma M_neq_0 [simp]: \"M \\<noteq> 0\"", "lemma M_le_N [simp]: \"M < N\"", "lemma M_not_ge_N [simp]: \"\\<not> M \\<ge> N\"", "lemma \\<psi>_dim [simp]:\n  \"\\<psi> \\<in> carrier_vec N\"\n  \"dim_vec \\<psi> = N\"", "lemma \\<psi>_eval:\n  \"i < N \\<Longrightarrow> \\<psi> $ i = 1 / sqrt N\"", "lemma \\<psi>_inner:\n  \"inner_prod \\<psi> \\<psi> = 1\"", "lemma \\<psi>_norm:\n  \"vec_norm \\<psi> = 1\"", "lemma \\<alpha>_dim [simp]:\n  \"\\<alpha> \\<in> carrier_vec N\"\n  \"dim_vec \\<alpha> = N\"", "lemma \\<alpha>_eval:\n  \"i < N \\<Longrightarrow> \\<alpha> $ i = (if f i then 0 else 1 / sqrt (N - M))\"", "lemma \\<alpha>_inner:\n  \"inner_prod \\<alpha> \\<alpha> = 1\"", "lemma \\<beta>_dim [simp]:\n  \"\\<beta> \\<in> carrier_vec N\"\n  \"dim_vec \\<beta> = N\"", "lemma \\<beta>_eval:\n  \"i < N \\<Longrightarrow> \\<beta> $ i = (if f i then 1 / sqrt M else 0)\"", "lemma \\<beta>_inner:\n  \"inner_prod \\<beta> \\<beta> = 1\"", "lemma alpha_beta_orth:\n  \"inner_prod \\<alpha> \\<beta> = 0\"", "lemma beta_alpha_orth:\n  \"inner_prod \\<beta> \\<alpha> = 0\"", "lemma cos_theta_div_2:\n  \"cos (\\<theta> / 2) = sqrt ((N - M) / N)\"", "lemma sin_theta_div_2:\n  \"sin (\\<theta> / 2) = sqrt (M / N)\"", "lemma \\<theta>_neq_0:\n  \"\\<theta> \\<noteq> 0\"", "lemma \\<psi>_eq:\n  \"\\<psi> = ccos (\\<theta> / 2) \\<cdot>\\<^sub>v \\<alpha> + csin (\\<theta> / 2) \\<cdot>\\<^sub>v \\<beta>\"", "lemma psi_inner_alpha:\n  \"inner_prod \\<psi> \\<alpha> = ccos (\\<theta> / 2)\"", "lemma psi_inner_beta:\n  \"inner_prod \\<psi> \\<beta> = csin (\\<theta> / 2)\"", "lemma alpha_l_real:\n  \"alpha_l l \\<in> Reals\"", "lemma cnj_alpha_l:\n  \"conjugate (alpha_l l) = alpha_l l\"", "lemma beta_l_real:\n  \"beta_l l \\<in> Reals\"", "lemma cnj_beta_l:\n  \"conjugate (beta_l l) = beta_l l\"", "lemma csin_ccos_squared_add:\n  \"ccos (a::real) * ccos a + csin a * csin a = 1\"", "lemma alpha_l_beta_l_add_norm:\n  \"alpha_l l * alpha_l l + beta_l l * beta_l l = 1\"", "lemma psi_l_dim:\n  \"psi_l l \\<in> carrier_vec N\"", "lemma inner_psi_l:\n  \"inner_prod (psi_l l) (psi_l l) = 1\"", "lemma psi'_l_dim:\n  \"psi'_l l \\<in> carrier_vec N\"", "lemma proj_psi'_dim:\n  \"proj_psi'_l l \\<in> carrier_mat N N\"", "lemma psi_inner_psi'_l:\n  \"inner_prod \\<psi> (psi'_l l) = (alpha_l l * ccos (\\<theta> / 2) - beta_l l * csin (\\<theta> / 2))\"", "lemma double_ccos_square:\n  \"2 * ccos (a::real) * ccos a = ccos (2 * a) + 1\"", "lemma double_csin_square:\n  \"2 * csin (a::real) * csin a = 1 - ccos (2 * a)\"", "lemma csin_double:\n  \"2 * csin (a::real) * ccos a = csin(2 * a)\"", "lemma ccos_add:\n  \"ccos (x + y) = ccos x * ccos y - csin x * csin y\"", "lemma alpha_l_Suc_l_derive:\n  \"2 * (alpha_l l * ccos (\\<theta> / 2) - beta_l l * csin (\\<theta> / 2)) * ccos (\\<theta> / 2) - alpha_l l = alpha_l (l + 1)\"\n  (is \"?lhs = ?rhs\")", "lemma csin_add:\n  \"csin (x + y) = ccos x * csin y + csin x * ccos y\"", "lemma beta_l_Suc_l_derive:\n  \"2 * (alpha_l l * ccos (\\<theta> / 2) - (beta_l l) * csin (\\<theta> / 2)) * csin (\\<theta> / 2) + beta_l l = beta_l (l + 1)\"\n  (is \"?lhs = ?rhs\")", "lemma psi_l_Suc_l_derive:\n  \"2 * (alpha_l l * ccos (\\<theta> / 2) - beta_l l * csin (\\<theta> / 2)) \\<cdot>\\<^sub>v \\<psi> - psi'_l l = psi_l (l + 1)\"\n  (is \"?lhs = ?rhs\")", "lemma proj_O_dim:\n  \"proj_O \\<in> carrier_mat N N\"", "lemma proj_O_mult_alpha:\n  \"proj_O *\\<^sub>v \\<alpha> = zero_vec N\"", "lemma proj_O_mult_beta:\n  \"proj_O *\\<^sub>v \\<beta> = \\<beta>\"", "lemma mat_O_dim:\n  \"mat_O \\<in> carrier_mat N N\"", "lemma mat_O_mult_alpha:\n  \"mat_O *\\<^sub>v \\<alpha> = \\<alpha>\"", "lemma mat_O_mult_beta:\n  \"mat_O *\\<^sub>v \\<beta> = - \\<beta>\"", "lemma hermitian_mat_O:\n  \"hermitian mat_O\"", "lemma unitary_mat_O:\n  \"unitary mat_O\"", "lemma hermitian_mat_Ph:\n  \"hermitian mat_Ph\"", "lemma unitary_mat_Ph:\n  \"unitary mat_Ph\"", "lemma K_gt_0:\n  \"K > 0\"", "lemma length_dims:\n  \"length dims = n + 1\"", "lemma dims_nth_lt_n:\n  \"l < n \\<Longrightarrow> nth dims l = 2\"", "lemma nths_Suc_n_dims:\n  \"nths dims {0..<(Suc n)} = dims\"", "lemma tensor_P_dim:\n  \"tensor_P A B \\<in> carrier_mat d d\"", "lemma dims_nths_le_n:\n  assumes \"l \\<le> n\"\n  shows \"nths dims {0..<l} = replicate l 2\"", "lemma dims_nths_one_lt_n: \n  assumes \"l < n\"\n  shows \"nths dims {l} = [2]\"", "lemma dims_vars1:\n  \"nths dims vars1 = replicate n 2\"", "lemma nths_rep_2_n:\n  \"nths (replicate n 2) {n} = []\"", "lemma dims_vars2:\n  \"nths dims vars2 = [K]\"", "lemma d_vars1:\n  \"prod_list (nths dims vars1) = N\"", "lemma ps2_P_dims0:\n  \"ps2_P.dims0 = dims\"", "lemma ps2_P_vars1':\n  \"ps2_P.vars1' = vars1\"", "lemma ps2_P_d0:\n  \"ps2_P.d0 = d\"", "lemma ps2_P_d1:\n  \"ps2_P.d1 = N\"", "lemma ps2_P_d2:\n  \"ps2_P.d2 = K\"", "lemma ps_P_d:\n  \"ps_P.d = d\"", "lemma ps_P_d1:\n  \"ps_P.d1 = N\"", "lemma ps_P_d2:\n  \"ps_P.d2 = K\"", "lemma nths_uminus_vars1:\n  \"nths dims (- vars1) = nths dims vars2\"", "lemma tensor_P_mult:\n  assumes \"m1 \\<in> carrier_mat (2^n) (2^n)\"\n    and \"m2 \\<in> carrier_mat (2^n) (2^n)\"\n    and \"m3 \\<in> carrier_mat K K\"\n    and \"m4 \\<in> carrier_mat K K\"\n  shows \"(tensor_P m1 m3) * (tensor_P m2 m4) = tensor_P (m1 * m2) (m3 * m4)\"", "lemma mat_ext_vars1:\n  shows \"mat_extension dims vars1 A = tensor_P A (1\\<^sub>m K)\"", "lemma Utrans_P_is_tensor_P1:\n  \"Utrans_P vars1 A = Utrans (tensor_P A (1\\<^sub>m K))\"", "lemma nths_dims_uminus_vars2:\n  \"nths dims (-vars2) = nths dims vars1\"", "lemma mat_ext_vars2:\n  assumes \"A \\<in> carrier_mat K K\"\n  shows \"mat_extension dims vars2 A = tensor_P (1\\<^sub>m N) A\"", "lemma Utrans_P_is_tensor_P2:\n  assumes \"A \\<in> carrier_mat K K\"\n  shows \"Utrans_P vars2 A = Utrans (tensor_P (1\\<^sub>m N) A)\"", "lemma unitary_ex_mat_O:\n  \"unitary (tensor_P mat_O (1\\<^sub>m K))\"", "lemma unitary_ex_mat_Ph:\n  \"unitary (tensor_P mat_Ph (1\\<^sub>m K))\"", "lemma unitary_hadamard_on_i:\n  assumes \"k < n\"\n  shows \"unitary (hadamard_on_i k)\"", "lemma unitary_exhadamard_on_i:\n  assumes \"k < n\"\n  shows \"unitary (tensor_P (hadamard_on_i k) (1\\<^sub>m K))\"", "lemma hadamard_on_i_dim:\n  assumes \"k < n\"\n  shows \"hadamard_on_i k \\<in> carrier_mat N N\"", "lemma well_com_hadamard_k:\n  \"k \\<le> n \\<Longrightarrow> well_com (hadamard_n k)\"", "lemma well_com_hadamard_n:\n  \"well_com (hadamard_n n)\"", "lemma well_com_mat_O:\n  \"well_com (Utrans_P vars1 mat_O)\"", "lemma well_com_mat_Ph:\n  \"well_com (Utrans_P vars1 mat_Ph)\"", "lemma unitary_exmat_incr:\n  \"unitary (tensor_P (1\\<^sub>m N) (mat_incr K))\"", "lemma well_com_mat_incr:\n  \"well_com (Utrans_P vars2 (mat_incr K))\"", "lemma well_com_D: \"well_com D\"", "lemma hermitian_M0:\n  \"hermitian M0\"", "lemma M0_dim:\n  \"M0 \\<in> carrier_mat K K\"", "lemma M0_mult_M0:\n  \"M0 * M0 = M0\"", "lemma M1_dim:\n  \"M1 \\<in> carrier_mat K K\"", "lemma hermitian_M1:\n  \"hermitian M1\"", "lemma M1_mult_M1:\n  \"M1 * M1 = M1\"", "lemma M1_add_M0:\n  \"M1 + M0 = 1\\<^sub>m K\"", "lemma hermitian_testN:\n  \"hermitian (testN k)\"", "lemma testN_mult_testN:\n  \"testN k * testN k = testN k\"", "lemma testN_dim:\n  \"testN k \\<in> carrier_mat N N\"", "lemma sum_test_k:\n  assumes \"m \\<le> N\"\n  shows \"matrix_sum N (\\<lambda>k. testN k) m = test_fst_k m\"", "lemma test_fst_kN:\n  \"test_fst_k N = 1\\<^sub>m N\"", "lemma matrix_sum_tensor_P1:\n  \"(\\<And>k. k < m \\<Longrightarrow> g k \\<in> carrier_mat N N) \\<Longrightarrow> (A \\<in> carrier_mat K K) \\<Longrightarrow>\n   matrix_sum d (\\<lambda>k. tensor_P (g k) A) m = tensor_P (matrix_sum N g m) A\"", "lemma well_com_if:\n  \"well_com (Measure_P vars1 N testN (replicate N SKIP))\"", "lemma well_com_while:\n  \"well_com (While_P vars2 M0 M1 D)\"", "lemma well_com_Grover:\n  \"well_com Grover\"", "lemma ket_pre_dim:\n  \"ket_pre \\<in> carrier_vec N\"", "lemma pre_dim:\n  \"pre \\<in> carrier_mat N N\"", "lemma norm_pre:\n  \"inner_prod ket_pre ket_pre = 1\"", "lemma pre_trace:\n  \"trace pre = 1\"", "lemma positive_pre:\n  \"positive pre\"", "lemma pre_le_one:\n  \"pre \\<le>\\<^sub>L 1\\<^sub>m N\"", "lemma post_dim:\n  \"post \\<in> carrier_mat N N\"", "lemma hermitian_post:\n  \"hermitian post\"", "lemma ket_zero_dim:\n  \"ket_zero \\<in> carrier_vec 2\"", "lemma ket_plus_dim:\n  \"ket_plus \\<in> carrier_vec 2\"", "lemma ket_plus_eval [simp]:\n  \"i < 2 \\<Longrightarrow> ket_plus $ i = 1 / csqrt 2\"", "lemma csqrt_2_sq [simp]:\n  \"complex_of_real (sqrt 2) * complex_of_real (sqrt 2) = 2\"", "lemma ket_plus_tensor_n:\n  \"partial_state.tensor_vec [2, 2] {0} ket_plus ket_plus = Matrix.vec 4 (\\<lambda>k. 1 / 2)\"", "lemma hadamard_on_zero:\n  \"hadamard *\\<^sub>v ket_zero = ket_plus\"", "lemma H_k_dim:\n  \"k < n \\<Longrightarrow> H_k k \\<in> carrier_mat (2^(Suc k)) (2^(Suc k))\"", "lemma exH_k_eq_H_k:\n  \"k < n \\<Longrightarrow> exH_k k = pmat_extension dims {0..<(Suc k)} {(Suc k)..<n} (H_k k)\"", "lemma mult_exH_k_left:\n  assumes \"Suc k < n\"\n  shows \"hadamard_on_i (Suc k) * exH_k k = exH_k (Suc k)\"", "lemma exH_eq_H:\n  \"exH_k (n - 1) = H_k (n - 1)\"", "lemma ket_zero_k_dim:\n  assumes \"k < n\"\n  shows \"ket_zero_k k \\<in> carrier_vec (2^(Suc k))\"", "lemma ket_plus_k_dim:\n  assumes \"k < n\"\n  shows \"ket_plus_k k \\<in> carrier_vec (2^(Suc k))\"", "lemma H_k_ket_zero_k:\n  \"k < n \\<Longrightarrow> (H_k k) *\\<^sub>v (ket_zero_k k) = (ket_plus_k k)\"", "lemma encode1_replicate_2:\n  \"partial_state.encode1 (replicate (Suc k) 2) {0..<k} i = i mod (2 ^ k)\"", "lemma encode2_replicate_2:\n  assumes \"i < 2 ^ Suc k\"\n  shows \"partial_state.encode2 (replicate (Suc k) 2) {0..<k} i = i div (2 ^ k)\"", "lemma ket_zero_k_decode:\n  \"k < n \\<Longrightarrow> ket_zero_k k = Matrix.vec (2^(Suc k)) (\\<lambda>k. if k = 0 then 1 else 0)\"", "lemma ket_plus_k_decode:\n  \"k < n \\<Longrightarrow> ket_plus_k k = Matrix.vec (2^(Suc k)) (\\<lambda>l. 1 / csqrt (2^(Suc k)))\"", "lemma exH_k_mult_pre_is_psi:\n  \"exH_k (n - 1) *\\<^sub>v ket_pre = \\<psi>\"", "lemma ket_k_dim:\n  \"ket_k k \\<in> carrier_vec K\"", "lemma mat_incr_mult_ket_k:\n  \"k < K \\<Longrightarrow> (mat_incr K) *\\<^sub>v (ket_k k) = (ket_k ((k + 1) mod K))\"", "lemma proj_k_dim:\n  \"proj_k k \\<in> carrier_mat K K\"", "lemma norm_ket_k_lt_K:\n  \"k < K \\<Longrightarrow> inner_prod (ket_k k) (ket_k k) = 1\"", "lemma norm_ket_k_ge_K:\n  \"k \\<ge> K \\<Longrightarrow> inner_prod (ket_k k) (ket_k k) = 0\"", "lemma norm_ket_k:\n  \"inner_prod (ket_k k) (ket_k k) \\<le> 1\"", "lemma proj_k_mat:\n  assumes \"k < K\"\n  shows \"proj_k k = mat K K (\\<lambda>(i, j). if (i = j \\<and> i = k) then 1 else 0)\"", "lemma positive_proj_k:\n  \"positive (proj_k k)\"", "lemma proj_k_le_one:\n  \"(proj_k k) \\<le>\\<^sub>L 1\\<^sub>m K\"", "lemma proj_psi_dim:\n  \"proj_psi \\<in> carrier_mat N N\"", "lemma norm_psi:\n  \"inner_prod \\<psi> \\<psi> = 1\"", "lemma proj_psi_mat:\n  \"proj_psi = mat N N (\\<lambda>k. 1 / N)\"", "lemma hermitian_proj_psi:\n  \"hermitian proj_psi\"", "lemma hermitian_exproj_psi:\n  \"hermitian (tensor_P proj_psi (1\\<^sub>m K))\"", "lemma proj_psi_is_projection:\n  \"proj_psi * proj_psi = proj_psi\"", "lemma proj_psi_trace:\n  \"trace (proj_psi) = 1\"", "lemma positive_proj_psi:\n  \"positive (proj_psi)\"", "lemma proj_psi_le_one:\n  \"(proj_psi) \\<le>\\<^sub>L 1\\<^sub>m N\"", "lemma hermitian_hadamard_on_k:\n  assumes \"k < n\"\n  shows \"hermitian (hadamard_on_i k)\"", "lemma hermitian_H_k:\n  \"k < n \\<Longrightarrow> hermitian (H_k k)\"", "lemma unitary_H_k:\n  \"k < n \\<Longrightarrow> unitary (H_k k)\"", "lemma exH_k_dim:\n  shows \"k < n \\<Longrightarrow> exH_k k \\<in> carrier_mat N N\"", "lemma exH_n_dim:\n  shows \"exH_k (n - 1) \\<in> carrier_mat N N\"", "lemma unitary_exH_k:\n  shows \"k < n \\<Longrightarrow> unitary (exH_k k)\"", "lemma hermitian_exH_n:\n  \"hermitian (exH_k (n - 1))\"", "lemma exH_k_mult_psi_is_pre:\n  \"exH_k (n - 1) *\\<^sub>v \\<psi> = ket_pre\"", "lemma unitary_exexH_k:\n  \"k < n \\<Longrightarrow> unitary (exexH_k k)\"", "lemma exexH_k_dim:\n  \"k < n \\<Longrightarrow> exexH_k k \\<in> carrier_mat d d\"", "lemma hoare_seq_utrans:\n  fixes P :: \"complex mat\"\n  assumes \"unitary U1\" and \"unitary U2\" and \"is_quantum_predicate P\"\n    and dU1: \"U1 \\<in> carrier_mat d d\" and dU2: \"U2 \\<in> carrier_mat d d\"\n  shows \"\n   \\<turnstile>\\<^sub>p \n   {adjoint (U2 * U1) * P * (U2 * U1)} \n   Utrans U1;; Utrans U2\n   {P}\"", "lemma qp_close_after_exexH_k:\n  fixes P :: \"complex mat\"\n  assumes \"is_quantum_predicate P\"\n  shows \"k < n \\<Longrightarrow> is_quantum_predicate (adjoint (exexH_k k) * P * exexH_k k)\"", "lemma hoare_hadamard_n:\n  fixes P :: \"complex mat\"\n  shows \"is_quantum_predicate P \\<Longrightarrow> k < n \\<Longrightarrow> \n   \\<turnstile>\\<^sub>p \n   {adjoint (exexH_k k) * P * exexH_k k} \n   hadamard_n (Suc k)\n   {P}\"", "lemma qp_pre:\n  \"is_quantum_predicate (tensor_P pre (proj_k 0))\"", "lemma qp_init_post:\n  \"is_quantum_predicate (tensor_P proj_psi (proj_k 0))\"", "lemma tensor_P_adjoint_left_right:\n  assumes \"m1 \\<in> carrier_mat N N\" and \"m2 \\<in> carrier_mat K K\" and \"m3 \\<in> carrier_mat N N\" and \"m4 \\<in> carrier_mat K K\"\n  shows \"adjoint (tensor_P m1 m2) * tensor_P m3 m4 * tensor_P m1 m2 = tensor_P (adjoint m1 * m3 * m1) (adjoint m2 * m4 * m2)\"", "lemma hoare_triple_init:\n  \"\\<turnstile>\\<^sub>p \n   {tensor_P pre (proj_k 0)} \n   hadamard_n n\n   {tensor_P proj_psi (proj_k 0)}\"", "lemma positive_psi_l:\n  \"k < K \\<Longrightarrow> positive (proj_psi_l k)\"", "lemma hermitian_proj_psi_l:\n  \"k < K \\<Longrightarrow> hermitian (proj_psi_l k)\"", "lemma proj_psi_l_dim:\n  \"proj_psi_l l \\<in> carrier_mat N N\"", "lemma psi_l_le_id:\n  shows \"proj_psi_l l \\<le>\\<^sub>L 1\\<^sub>m N\"", "lemma positive_proj_psi_l:\n  shows \"positive (proj_psi_l l)\"", "lemma hermitian_proj_fst_k:\n  \"adjoint (proj_fst_k k) = proj_fst_k k\"", "lemma proj_fst_k_is_projection:\n  \"proj_fst_k k * proj_fst_k k = proj_fst_k k\"", "lemma positive_proj_fst_k:\n  \"positive (proj_fst_k k)\"", "lemma proj_fst_k_le_one:\n  \"proj_fst_k k \\<le>\\<^sub>L 1\\<^sub>m K\"", "lemma sum_proj_k:\n  assumes \"m \\<le> K\"\n  shows \"matrix_sum K (\\<lambda>k. proj_k k) m = proj_fst_k m\"", "lemma proj_psi_proj_k_le_exproj_k:\n  shows \"tensor_P (proj_psi_l k) (proj_k l) \\<le>\\<^sub>L tensor_P (1\\<^sub>m N) (proj_k l)\"", "lemma tensor_P_left_right_partial1:\n  assumes \"m1 \\<in> carrier_mat N N\" and \"m2 \\<in> carrier_mat N N\" and \"m3 \\<in> carrier_mat K K\" and \"m4 \\<in> carrier_mat N N\"\n  shows \"tensor_P m1 (1\\<^sub>m K) * tensor_P m2 m3 * tensor_P m4 (1\\<^sub>m K) = tensor_P (m1 * m2 * m4) m3\"", "lemma tensor_P_left_right_partial2:\n  assumes \"m1 \\<in> carrier_mat K K\" and \"m2 \\<in> carrier_mat K K\" and \"m3 \\<in> carrier_mat N N\" and \"m4 \\<in> carrier_mat K K\"\n  shows \"tensor_P (1\\<^sub>m N) m1 * tensor_P m3 m2 * tensor_P (1\\<^sub>m N) m4 = tensor_P m3 (m1 * m2 * m4)\"", "lemma matrix_sum_mult_left_right:\n  fixes A B :: \"complex mat\"\n  assumes dg: \"(\\<And>k. k < l \\<Longrightarrow> g k \\<in> carrier_mat m m) \"\n    and dA: \"A \\<in> carrier_mat m m\" and dB: \"B \\<in> carrier_mat m m\"\n  shows \"matrix_sum m (\\<lambda>k. A * g k * B) l = A * matrix_sum m g l * B\"", "lemma mat_O_split:\n  \"mat_O = 1\\<^sub>m N - 2 \\<cdot>\\<^sub>m proj_O\"", "lemma mat_O_mult_psi'_l:\n  \"mat_O *\\<^sub>v (psi'_l l) = psi_l l\"", "lemma mat_O_times_Q1:\n  \"adjoint (tensor_P mat_O (1\\<^sub>m K)) * Q1 * (tensor_P mat_O (1\\<^sub>m K)) = Q\"", "lemma Q2_dim:\n  \"Q2 \\<in> carrier_mat d d\"", "lemma Q2_le_one:\n  \"Q2 \\<le>\\<^sub>L 1\\<^sub>m d\"", "lemma qp_Q2:\n  \"is_quantum_predicate Q2\"", "lemma pre_mat:\n  \"pre = mat N N (\\<lambda>(i, j). if i = j \\<and> i = 0 then 1 else 0)\"", "lemma mat_Ph_split:\n  \"mat_Ph = 2 \\<cdot>\\<^sub>m pre - 1\\<^sub>m N\"", "lemma H_Ph_H:\n  \"exexH_k (n-1) * tensor_P mat_Ph (1\\<^sub>m K) * exexH_k (n - 1) = 2 \\<cdot>\\<^sub>m tensor_P proj_psi (1\\<^sub>m K) - 1\\<^sub>m d\"", "lemma hermitian_proj_psi_minus_1:\n  \"hermitian (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N)\"", "lemma unitary_proj_psi_minus_1:\n  \"unitary (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N)\"", "lemma proj_psi_minus_1_mult_psi'_l:\n  \"(2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) *\\<^sub>v psi'_l l = psi_l (l + 1)\"", "lemma proj_psi_minus_1_mult_psi_Suc_l:\n  \"(2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) *\\<^sub>v psi_l (l + 1) = psi'_l l\"", "lemma exproj_psi_minus_1_tensor:\n  \"(2 \\<cdot>\\<^sub>m tensor_P proj_psi (1\\<^sub>m K)) - 1\\<^sub>m d = tensor_P (2 \\<cdot>\\<^sub>m proj_psi - (1\\<^sub>m N)) (1\\<^sub>m K)\"", "lemma unitary_exproj_psi_minus_1:\n  \"unitary (2 \\<cdot>\\<^sub>m tensor_P proj_psi (1\\<^sub>m K) - 1\\<^sub>m d)\"", "lemma proj_psi_minus_1_Q2:\n  \"adjoint (2 \\<cdot>\\<^sub>m tensor_P proj_psi (1\\<^sub>m K) - 1\\<^sub>m d) * Q2 * (2 \\<cdot>\\<^sub>m tensor_P proj_psi (1\\<^sub>m K) - 1\\<^sub>m d) = Q1\"", "lemma qp_Q1:\n  \"is_quantum_predicate Q1\"", "lemma qp_Q:\n  \"is_quantum_predicate Q\"", "lemma hoare_triple_D1:\n  \"\\<turnstile>\\<^sub>p \n   {Q} \n   Utrans_P vars1 mat_O\n   {Q1}\"", "lemma hoare_triple_D2:\n  \"\\<turnstile>\\<^sub>p \n   {Q1}\n   hadamard_n n ;;\n   Utrans_P vars1 mat_Ph ;;\n   hadamard_n n \n   {Q2}\"", "lemma M0_mult_ket_k_R:\n  \"M0 *\\<^sub>v ket_k R = ket_k R\"", "lemma exP0_P':\n  \"adjoint exM0 * P' * exM0 = P'\"", "lemma M1_mult_ket_k:\n  assumes \"k < R\"\n  shows \"M1 *\\<^sub>v ket_k k = ket_k k\"", "lemma exP1_Q:\n  \"adjoint exM1 * Q * exM1 = Q\"", "lemma qp_P':\n  \"is_quantum_predicate P'\"", "lemma P'_add_Q:\n  \"P' + Q = matrix_sum d (\\<lambda>l. tensor_P (proj_psi_l l) (proj_k l)) (R + 1)\"", "lemma positive_Qk:\n  \"positive (tensor_P (proj_psi_l l) (proj_k l))\"", "lemma P'_Q_dim:\n  \"P' + Q \\<in> carrier_mat d d\"", "lemma P'_add_Q_le_one:\n  \"P' + Q \\<le>\\<^sub>L 1\\<^sub>m d\"", "lemma qp_P'_Q:\n  \"is_quantum_predicate (P' + Q)\"", "lemma Q2_leq_lemma:\n  \"tensor_P (1\\<^sub>m N) (mat_incr K) * Q2 * adjoint (tensor_P (1\\<^sub>m N) (mat_incr K)) \\<le>\\<^sub>L P' + Q\"", "lemma Q2_leq:\n  \"Q2 \\<le>\\<^sub>L adjoint (tensor_P (1\\<^sub>m N) (mat_incr K)) * (P' + Q) * tensor_P (1\\<^sub>m N) (mat_incr K)\"", "lemma hoare_triple_D3:\n  \"\\<turnstile>\\<^sub>p \n   {Q2}\n   Utrans_P vars2 (mat_incr K)\n   {adjoint exM0 * P' * exM0 + adjoint exM1 * Q * exM1}\"", "lemma qp_D3_post:\n  \"is_quantum_predicate (adjoint exM0 * P' * exM0 + adjoint exM1 * Q * exM1)\"", "lemma hoare_triple_D:\n  \"\\<turnstile>\\<^sub>p \n   {Q} \n   D\n   {adjoint exM0 * P' * exM0 + adjoint exM1 * Q * exM1}\"", "lemma psi_is_psi_l0:\n  \"\\<psi> = psi_l 0\"", "lemma proj_psi_is_proj_psi_l0:\n  \"proj_psi = proj_psi_l 0\"", "lemma lowner_le_Q:\n  \"tensor_P proj_psi (proj_k 0) \\<le>\\<^sub>L adjoint exM0 * P' * exM0 + adjoint exM1 * Q * exM1\"", "lemma hoare_triple_while:\n  \"\\<turnstile>\\<^sub>p \n   {adjoint exM0 * P' * exM0 + adjoint exM1 * Q * exM1} \n   While_P vars2 M0 M1 D\n   {P'}\"", "lemma R_and_a_half_\\<theta>:\n  \"(R + 1/2) * \\<theta> = pi / 2\"", "lemma psi_lR_is_beta:\n  \"psi_l R = \\<beta>\"", "lemma post_mult_beta:\n  \"post *\\<^sub>v \\<beta> = \\<beta>\"", "lemma post_mult_post:\n  \"post * post = post\"", "lemma post_mult_proj_psi_lR:\n  \"post * proj_psi_l R = proj_psi_l R\"", "lemma proj_psi_lR_mult_post:\n  \"proj_psi_l R * post = proj_psi_l R\"", "lemma proj_psi_lR_mult_proj_psi_lR:\n  \"proj_psi_l R * proj_psi_l R = proj_psi_l R\"", "lemma proj_psi_lR_le_post:\n  \"proj_psi_l R \\<le>\\<^sub>L post\"", "lemma P'_le_post_R:\n  \"P' \\<le>\\<^sub>L (tensor_P post (proj_k R))\"", "lemma positive_post:\n  \"positive post\"", "lemma lowner_le_P':\n  \"P' \\<le>\\<^sub>L tensor_P post (1\\<^sub>m K)\"", "lemma post_mult_testNk:\n  assumes \"f k\"\n  shows \"post * (testN k) = testN k\"", "lemma post_mult_testNk_neg:\n  assumes \"\\<not> f k\"\n  shows \"post * testN k = 0\\<^sub>m N N\"", "lemma testN_post1:\n  \"f k \\<Longrightarrow> adjoint (testN k) * post * testN k = testN k\"", "lemma testN_post2:\n  \"\\<not> f k \\<Longrightarrow> adjoint (testN k) * post * testN k = 0\\<^sub>m N N\"", "lemma post_fst_kN:\n  \"post_fst_k N = post\"", "lemma post_fst_k_Suc:\n  \"f i \\<Longrightarrow> post_fst_k (Suc i) = testN i + post_fst_k i\"", "lemma post_fst_k_Suc_neg:\n  \"\\<not> f i \\<Longrightarrow> post_fst_k (Suc i) = post_fst_k i\"", "lemma testN_sum:\n  \"matrix_sum N (\\<lambda>k. adjoint (testN k) * post * testN k) N = post\"", "lemma tensor_P_testN_sum:\n  \"matrix_sum d (\\<lambda>k. adjoint (tensor_P (testN k) (1\\<^sub>m K)) * tensor_P post (1\\<^sub>m K) * tensor_P (testN k) (1\\<^sub>m K)) N =\n   tensor_P post (1\\<^sub>m K)\"", "lemma post_le_one:\n  \"post \\<le>\\<^sub>L 1\\<^sub>m N\"", "lemma qp_post:\n  \"is_quantum_predicate (tensor_P post (1\\<^sub>m K))\"", "lemma hoare_triple_if:\n  \"\\<turnstile>\\<^sub>p \n   {tensor_P post (1\\<^sub>m K)} \n   Measure_P vars1 N testN (replicate N SKIP)\n   {tensor_P post (1\\<^sub>m K)}\"", "theorem grover_partial_deduct:\n  \"\\<turnstile>\\<^sub>p\n   {tensor_P pre (proj_k 0)}\n    Grover\n   {tensor_P post (1\\<^sub>m K)}\"", "theorem grover_partial_correct:\n  \"\\<Turnstile>\\<^sub>p\n   {tensor_P pre (proj_k 0)}\n    Grover\n   {tensor_P post (1\\<^sub>m K)}\""], "translations": [["", "lemma N_ge_0 [simp]: \"0 < N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < N", "by (simp add: N_def)"], ["", "lemma M_ge_0 [simp]: \"0 < M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < M", "by (simp add: M_def dimM N_def)"], ["", "lemma M_neq_0 [simp]: \"M \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M \\<noteq> 0", "by simp"], ["", "lemma M_le_N [simp]: \"M < N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M < N", "by (simp add: M_def dimM N_def)"], ["", "lemma M_not_ge_N [simp]: \"\\<not> M \\<ge> N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> N \\<le> M", "using M_le_N"], ["proof (prove)\nusing this:\n  M < N\n\ngoal (1 subgoal):\n 1. \\<not> N \\<le> M", "by arith"], ["", "definition \\<psi> :: \"complex vec\" where\n  \"\\<psi> = Matrix.vec N (\\<lambda>i. 1 / sqrt N)\""], ["", "lemma \\<psi>_dim [simp]:\n  \"\\<psi> \\<in> carrier_vec N\"\n  \"dim_vec \\<psi> = N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<psi> \\<in> carrier_vec N &&& dim_vec \\<psi> = N", "by (simp add: \\<psi>_def)+"], ["", "lemma \\<psi>_eval:\n  \"i < N \\<Longrightarrow> \\<psi> $ i = 1 / sqrt N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < N \\<Longrightarrow> \\<psi> $ i = complex_of_real (1 / sqrt (real N))", "by (simp add: \\<psi>_def)"], ["", "lemma \\<psi>_inner:\n  \"inner_prod \\<psi> \\<psi> = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inner_prod \\<psi> \\<psi> = 1", "apply (simp add: \\<psi>_eval scalar_prod_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. of_nat N =\n    complex_of_real (sqrt (real N)) * complex_of_real (sqrt (real N))", "by (smt of_nat_less_0_iff of_real_mult of_real_of_nat_eq real_sqrt_mult_self)"], ["", "lemma \\<psi>_norm:\n  \"vec_norm \\<psi> = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_norm \\<psi> = 1", "by (simp add: \\<psi>_eval vec_norm_def scalar_prod_def)"], ["", "definition \\<alpha> :: \"complex vec\" where\n  \"\\<alpha> = Matrix.vec N (\\<lambda>i. if f i then 0 else 1 / sqrt (N - M))\""], ["", "lemma \\<alpha>_dim [simp]:\n  \"\\<alpha> \\<in> carrier_vec N\"\n  \"dim_vec \\<alpha> = N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha> \\<in> carrier_vec N &&& dim_vec \\<alpha> = N", "by (simp add: \\<alpha>_def)+"], ["", "lemma \\<alpha>_eval:\n  \"i < N \\<Longrightarrow> \\<alpha> $ i = (if f i then 0 else 1 / sqrt (N - M))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < N \\<Longrightarrow>\n    \\<alpha> $ i =\n    complex_of_real (if f i then 0 else 1 / sqrt (real (N - M)))", "by (simp add: \\<alpha>_def)"], ["", "lemma \\<alpha>_inner:\n  \"inner_prod \\<alpha> \\<alpha> = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inner_prod \\<alpha> \\<alpha> = 1", "apply (simp add: scalar_prod_def \\<alpha>_eval)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<N.\n        complex_of_real (if f i then 0 else 1 / sqrt (real (N - M))) *\n        complex_of_real (if f i then 0 else 1 / sqrt (real (N - M)))) =\n    1", "apply (subst sum.mono_neutral_cong_right[of \"{0..<N}\" \"{0..<N}-{i. i < N \\<and> f i}\"])"], ["proof (prove)\ngoal (5 subgoals):\n 1. finite {0..<N}\n 2. {0..<N} - {i. i < N \\<and> f i} \\<subseteq> {0..<N}\n 3. \\<forall>i\\<in>{0..<N} - ({0..<N} - {i. i < N \\<and> f i}).\n       complex_of_real (if f i then 0 else 1 / sqrt (real (N - M))) *\n       complex_of_real (if f i then 0 else 1 / sqrt (real (N - M))) =\n       0\n 4. \\<And>x.\n       x \\<in> {0..<N} - {i. i < N \\<and> f i} \\<Longrightarrow>\n       complex_of_real (if f x then 0 else 1 / sqrt (real (N - M))) *\n       complex_of_real (if f x then 0 else 1 / sqrt (real (N - M))) =\n       ?h6 x\n 5. sum ?h6 ({0..<N} - {i. i < N \\<and> f i}) = 1", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. of_nat (card ({0..<N} - {i. i < N \\<and> f i})) =\n    complex_of_real (sqrt (real (N - M))) *\n    complex_of_real (sqrt (real (N - M)))", "apply (subgoal_tac \"card ({0..<N} - {i. i < N \\<and> f i}) = N - M\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. card ({0..<N} - {i. i < N \\<and> f i}) = N - M \\<Longrightarrow>\n    of_nat (card ({0..<N} - {i. i < N \\<and> f i})) =\n    complex_of_real (sqrt (real (N - M))) *\n    complex_of_real (sqrt (real (N - M)))\n 2. card ({0..<N} - {i. i < N \\<and> f i}) = N - M", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. card ({0..<N} - {i. i < N \\<and> f i}) = N - M \\<Longrightarrow>\n    of_nat (card ({0..<N} - {i. i < N \\<and> f i})) =\n    complex_of_real (sqrt (real (N - M))) *\n    complex_of_real (sqrt (real (N - M)))", "by (metis of_nat_0_le_iff of_real_of_nat_eq of_real_power power2_eq_square real_sqrt_pow2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. card ({0..<N} - {i. i < N \\<and> f i}) = N - M", "unfolding N_def M_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. card ({0..<2 ^ n} - {i. i < 2 ^ n \\<and> f i}) =\n    2 ^ n - card {i. i < 2 ^ n \\<and> f i}", "by (metis (no_types, lifting) atLeastLessThan_iff card.infinite card_Diff_subset card_atLeastLessThan diff_zero dimM(1) mem_Collect_eq neq0_conv subsetI zero_order(1))"], ["", "definition \\<beta> :: \"complex vec\" where\n  \"\\<beta> = Matrix.vec N (\\<lambda>i. if f i then 1 / sqrt M else 0)\""], ["", "lemma \\<beta>_dim [simp]:\n  \"\\<beta> \\<in> carrier_vec N\"\n  \"dim_vec \\<beta> = N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<beta> \\<in> carrier_vec N &&& dim_vec \\<beta> = N", "by (simp add: \\<beta>_def)+"], ["", "lemma \\<beta>_eval:\n  \"i < N \\<Longrightarrow> \\<beta> $ i = (if f i then 1 / sqrt M else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < N \\<Longrightarrow>\n    \\<beta> $ i = complex_of_real (if f i then 1 / sqrt (real M) else 0)", "by (simp add: \\<beta>_def)"], ["", "lemma \\<beta>_inner:\n  \"inner_prod \\<beta> \\<beta> = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inner_prod \\<beta> \\<beta> = 1", "apply (simp add: scalar_prod_def \\<beta>_eval)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<N.\n        complex_of_real (if f i then 1 / sqrt (real M) else 0) *\n        complex_of_real (if f i then 1 / sqrt (real M) else 0)) =\n    1", "apply (subst sum.mono_neutral_cong_right[of \"{0..<N}\" \"{i. i < N \\<and> f i}\"])"], ["proof (prove)\ngoal (5 subgoals):\n 1. finite {0..<N}\n 2. {i. i < N \\<and> f i} \\<subseteq> {0..<N}\n 3. \\<forall>i\\<in>{0..<N} - {i. i < N \\<and> f i}.\n       complex_of_real (if f i then 1 / sqrt (real M) else 0) *\n       complex_of_real (if f i then 1 / sqrt (real M) else 0) =\n       0\n 4. \\<And>x.\n       x \\<in> {i. i < N \\<and> f i} \\<Longrightarrow>\n       complex_of_real (if f x then 1 / sqrt (real M) else 0) *\n       complex_of_real (if f x then 1 / sqrt (real M) else 0) =\n       ?h6 x\n 5. sum ?h6 {i. i < N \\<and> f i} = 1", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. of_nat (card {i. i < N \\<and> f i}) =\n    complex_of_real (sqrt (real M)) * complex_of_real (sqrt (real M))", "apply (fold M_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. of_nat M =\n    complex_of_real (sqrt (real M)) * complex_of_real (sqrt (real M))", "by (metis of_nat_0_le_iff of_real_of_nat_eq of_real_power power2_eq_square real_sqrt_pow2)"], ["", "lemma alpha_beta_orth:\n  \"inner_prod \\<alpha> \\<beta> = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inner_prod \\<alpha> \\<beta> = 0", "unfolding \\<alpha>_def \\<beta>_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. inner_prod\n     (Matrix.vec N\n       (\\<lambda>x.\n           complex_of_real (if f x then 0 else 1 / sqrt (real (N - M)))))\n     (Matrix.vec N\n       (\\<lambda>x.\n           complex_of_real (if f x then 1 / sqrt (real M) else 0))) =\n    0", "by (simp add: scalar_prod_def)"], ["", "lemma beta_alpha_orth:\n  \"inner_prod \\<beta> \\<alpha> = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inner_prod \\<beta> \\<alpha> = 0", "unfolding \\<alpha>_def \\<beta>_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. inner_prod\n     (Matrix.vec N\n       (\\<lambda>x. complex_of_real (if f x then 1 / sqrt (real M) else 0)))\n     (Matrix.vec N\n       (\\<lambda>x.\n           complex_of_real (if f x then 0 else 1 / sqrt (real (N - M))))) =\n    0", "by (simp add: scalar_prod_def)"], ["", "definition \\<theta> :: real where\n  \"\\<theta> = 2 * arccos (sqrt ((N - M) / N))\""], ["", "lemma cos_theta_div_2:\n  \"cos (\\<theta> / 2) = sqrt ((N - M) / N)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cos (\\<theta> / 2) = sqrt (real (N - M) / real N)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cos (\\<theta> / 2) = sqrt (real (N - M) / real N)", "have \"\\<theta> / 2 = arccos (sqrt ((N - M) / N))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<theta> / 2 = arccos (sqrt (real (N - M) / real N))", "using \\<theta>_def"], ["proof (prove)\nusing this:\n  \\<theta> = 2 * arccos (sqrt (real (N - M) / real N))\n\ngoal (1 subgoal):\n 1. \\<theta> / 2 = arccos (sqrt (real (N - M) / real N))", "by simp"], ["proof (state)\nthis:\n  \\<theta> / 2 = arccos (sqrt (real (N - M) / real N))\n\ngoal (1 subgoal):\n 1. cos (\\<theta> / 2) = sqrt (real (N - M) / real N)", "then"], ["proof (chain)\npicking this:\n  \\<theta> / 2 = arccos (sqrt (real (N - M) / real N))", "show \"cos (\\<theta> / 2) = sqrt ((N - M) / N)\""], ["proof (prove)\nusing this:\n  \\<theta> / 2 = arccos (sqrt (real (N - M) / real N))\n\ngoal (1 subgoal):\n 1. cos (\\<theta> / 2) = sqrt (real (N - M) / real N)", "by (simp add: cos_arccos_abs)"], ["proof (state)\nthis:\n  cos (\\<theta> / 2) = sqrt (real (N - M) / real N)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sin_theta_div_2:\n  \"sin (\\<theta> / 2) = sqrt (M / N)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sin (\\<theta> / 2) = sqrt (real M / real N)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. sin (\\<theta> / 2) = sqrt (real M / real N)", "have a: \"\\<theta> / 2 = arccos (sqrt ((N - M) / N))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<theta> / 2 = arccos (sqrt (real (N - M) / real N))", "using \\<theta>_def"], ["proof (prove)\nusing this:\n  \\<theta> = 2 * arccos (sqrt (real (N - M) / real N))\n\ngoal (1 subgoal):\n 1. \\<theta> / 2 = arccos (sqrt (real (N - M) / real N))", "by simp"], ["proof (state)\nthis:\n  \\<theta> / 2 = arccos (sqrt (real (N - M) / real N))\n\ngoal (1 subgoal):\n 1. sin (\\<theta> / 2) = sqrt (real M / real N)", "have N: \"N > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < N", "using N_def"], ["proof (prove)\nusing this:\n  N = 2 ^ n\n\ngoal (1 subgoal):\n 1. 0 < N", "by auto"], ["proof (state)\nthis:\n  0 < N\n\ngoal (1 subgoal):\n 1. sin (\\<theta> / 2) = sqrt (real M / real N)", "have M: \"M < N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M < N", "using M_def dimM N_def"], ["proof (prove)\nusing this:\n  M = card {i. i < N \\<and> f i}\n  0 < card {i. i < 2 ^ n \\<and> f i}\n  card {i. i < 2 ^ n \\<and> f i} < 2 ^ n\n  N = 2 ^ n\n\ngoal (1 subgoal):\n 1. M < N", "by auto"], ["proof (state)\nthis:\n  M < N\n\ngoal (1 subgoal):\n 1. sin (\\<theta> / 2) = sqrt (real M / real N)", "then"], ["proof (chain)\npicking this:\n  M < N", "show \"sin (\\<theta> / 2) = sqrt (M / N)\""], ["proof (prove)\nusing this:\n  M < N\n\ngoal (1 subgoal):\n 1. sin (\\<theta> / 2) = sqrt (real M / real N)", "unfolding a"], ["proof (prove)\nusing this:\n  M < N\n\ngoal (1 subgoal):\n 1. sin (arccos (sqrt (real (N - M) / real N))) = sqrt (real M / real N)", "apply (simp add: sin_arccos_abs)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 - real (N - M) / real N = real M / real N", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. 1 - real (N - M) / real N = real M / real N", "have eq: \"real (N - M) = real N - real M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real (N - M) = real N - real M", "using N M"], ["proof (prove)\nusing this:\n  0 < N\n  M < N\n\ngoal (1 subgoal):\n 1. real (N - M) = real N - real M", "using M_not_ge_N nat_le_linear of_nat_diff"], ["proof (prove)\nusing this:\n  0 < N\n  M < N\n  \\<not> N \\<le> M\n  ?m \\<le> ?n \\<or> ?n \\<le> ?m\n  ?n \\<le> ?m \\<Longrightarrow> of_nat (?m - ?n) = of_nat ?m - of_nat ?n\n\ngoal (1 subgoal):\n 1. real (N - M) = real N - real M", "by blast"], ["proof (state)\nthis:\n  real (N - M) = real N - real M\n\ngoal (1 subgoal):\n 1. 1 - real (N - M) / real N = real M / real N", "have \"1 - real (N - M) / real N = (real N - (real N - real M)) / real N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 - real (N - M) / real N = (real N - (real N - real M)) / real N", "unfolding eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 - (real N - real M) / real N = (real N - (real N - real M)) / real N", "using N"], ["proof (prove)\nusing this:\n  0 < N\n\ngoal (1 subgoal):\n 1. 1 - (real N - real M) / real N = (real N - (real N - real M)) / real N", "by (metis diff_divide_distrib divide_self_if eq gr_implies_not0 of_nat_0_eq_iff)"], ["proof (state)\nthis:\n  1 - real (N - M) / real N = (real N - (real N - real M)) / real N\n\ngoal (1 subgoal):\n 1. 1 - real (N - M) / real N = real M / real N", "then"], ["proof (chain)\npicking this:\n  1 - real (N - M) / real N = (real N - (real N - real M)) / real N", "show \"1 - real (N - M) / real N = real M / real N\""], ["proof (prove)\nusing this:\n  1 - real (N - M) / real N = (real N - (real N - real M)) / real N\n\ngoal (1 subgoal):\n 1. 1 - real (N - M) / real N = real M / real N", "by auto"], ["proof (state)\nthis:\n  1 - real (N - M) / real N = real M / real N\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sin (\\<theta> / 2) = sqrt (real M / real N)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma \\<theta>_neq_0:\n  \"\\<theta> \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<theta> \\<noteq> 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<theta> \\<noteq> 0", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<theta> \\<noteq> 0", "assume \"\\<theta> = 0\""], ["proof (state)\nthis:\n  \\<theta> = 0\n\ngoal (1 subgoal):\n 1. \\<theta> \\<noteq> 0", "then"], ["proof (chain)\npicking this:\n  \\<theta> = 0", "have \"\\<theta> / 2 = 0\""], ["proof (prove)\nusing this:\n  \\<theta> = 0\n\ngoal (1 subgoal):\n 1. \\<theta> / 2 = 0", "by auto"], ["proof (state)\nthis:\n  \\<theta> / 2 = 0\n\ngoal (1 subgoal):\n 1. \\<theta> \\<noteq> 0", "then"], ["proof (chain)\npicking this:\n  \\<theta> / 2 = 0", "have \"sin (\\<theta> / 2) = 0\""], ["proof (prove)\nusing this:\n  \\<theta> / 2 = 0\n\ngoal (1 subgoal):\n 1. sin (\\<theta> / 2) = 0", "by auto"], ["proof (state)\nthis:\n  sin (\\<theta> / 2) = 0\n\ngoal (1 subgoal):\n 1. \\<theta> \\<noteq> 0", "}"], ["proof (state)\nthis:\n  \\<theta> = 0 \\<Longrightarrow> sin (\\<theta> / 2) = 0\n\ngoal (1 subgoal):\n 1. \\<theta> \\<noteq> 0", "note z = this"], ["proof (state)\nthis:\n  \\<theta> = 0 \\<Longrightarrow> sin (\\<theta> / 2) = 0\n\ngoal (1 subgoal):\n 1. \\<theta> \\<noteq> 0", "have \"sin (\\<theta> / 2) = sqrt (M / N)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sin (\\<theta> / 2) = sqrt (real M / real N)", "using sin_theta_div_2"], ["proof (prove)\nusing this:\n  sin (\\<theta> / 2) = sqrt (real M / real N)\n\ngoal (1 subgoal):\n 1. sin (\\<theta> / 2) = sqrt (real M / real N)", "by auto"], ["proof (state)\nthis:\n  sin (\\<theta> / 2) = sqrt (real M / real N)\n\ngoal (1 subgoal):\n 1. \\<theta> \\<noteq> 0", "moreover"], ["proof (state)\nthis:\n  sin (\\<theta> / 2) = sqrt (real M / real N)\n\ngoal (1 subgoal):\n 1. \\<theta> \\<noteq> 0", "have \"M > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < M", "unfolding M_def N_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < card {i. i < 2 ^ n \\<and> f i}", "using dimM"], ["proof (prove)\nusing this:\n  0 < card {i. i < 2 ^ n \\<and> f i}\n  card {i. i < 2 ^ n \\<and> f i} < 2 ^ n\n\ngoal (1 subgoal):\n 1. 0 < card {i. i < 2 ^ n \\<and> f i}", "by auto"], ["proof (state)\nthis:\n  0 < M\n\ngoal (1 subgoal):\n 1. \\<theta> \\<noteq> 0", "ultimately"], ["proof (chain)\npicking this:\n  sin (\\<theta> / 2) = sqrt (real M / real N)\n  0 < M", "have \"sin (\\<theta> / 2) > 0\""], ["proof (prove)\nusing this:\n  sin (\\<theta> / 2) = sqrt (real M / real N)\n  0 < M\n\ngoal (1 subgoal):\n 1. 0 < sin (\\<theta> / 2)", "by auto"], ["proof (state)\nthis:\n  0 < sin (\\<theta> / 2)\n\ngoal (1 subgoal):\n 1. \\<theta> \\<noteq> 0", "with z"], ["proof (chain)\npicking this:\n  \\<theta> = 0 \\<Longrightarrow> sin (\\<theta> / 2) = 0\n  0 < sin (\\<theta> / 2)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<theta> = 0 \\<Longrightarrow> sin (\\<theta> / 2) = 0\n  0 < sin (\\<theta> / 2)\n\ngoal (1 subgoal):\n 1. \\<theta> \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  \\<theta> \\<noteq> 0\n\ngoal:\nNo subgoals!", "qed"], ["", "abbreviation ccos where \"ccos \\<phi> \\<equiv> complex_of_real (cos \\<phi>)\""], ["", "abbreviation csin where \"csin \\<phi> \\<equiv> complex_of_real (sin \\<phi>)\""], ["", "lemma \\<psi>_eq:\n  \"\\<psi> = ccos (\\<theta> / 2) \\<cdot>\\<^sub>v \\<alpha> + csin (\\<theta> / 2) \\<cdot>\\<^sub>v \\<beta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<psi> =\n    complex_of_real (cos (\\<theta> / 2)) \\<cdot>\\<^sub>v \\<alpha> +\n    complex_of_real (sin (\\<theta> / 2)) \\<cdot>\\<^sub>v \\<beta>", "apply (simp add: cos_theta_div_2 sin_theta_div_2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<psi> =\n    complex_of_real (sqrt (real (N - M) / real N)) \\<cdot>\\<^sub>v\n    \\<alpha> +\n    complex_of_real (sqrt (real M / real N)) \\<cdot>\\<^sub>v \\<beta>", "apply (rule eq_vecI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i.\n       i < dim_vec\n            (complex_of_real (sqrt (real (N - M) / real N)) \\<cdot>\\<^sub>v\n             \\<alpha> +\n             complex_of_real (sqrt (real M / real N)) \\<cdot>\\<^sub>v\n             \\<beta>) \\<Longrightarrow>\n       \\<psi> $ i =\n       (complex_of_real (sqrt (real (N - M) / real N)) \\<cdot>\\<^sub>v\n        \\<alpha> +\n        complex_of_real (sqrt (real M / real N)) \\<cdot>\\<^sub>v \\<beta>) $\n       i\n 2. dim_vec \\<psi> =\n    dim_vec\n     (complex_of_real (sqrt (real (N - M) / real N)) \\<cdot>\\<^sub>v\n      \\<alpha> +\n      complex_of_real (sqrt (real M / real N)) \\<cdot>\\<^sub>v \\<beta>)", "by (auto simp add: \\<alpha>_def \\<beta>_def \\<psi>_def real_sqrt_divide)"], ["", "lemma psi_inner_alpha:\n  \"inner_prod \\<psi> \\<alpha> = ccos (\\<theta> / 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inner_prod \\<psi> \\<alpha> = complex_of_real (cos (\\<theta> / 2))", "unfolding \\<psi>_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. inner_prod\n     (complex_of_real (cos (\\<theta> / 2)) \\<cdot>\\<^sub>v \\<alpha> +\n      complex_of_real (sin (\\<theta> / 2)) \\<cdot>\\<^sub>v \\<beta>)\n     \\<alpha> =\n    complex_of_real (cos (\\<theta> / 2))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. inner_prod\n     (complex_of_real (cos (\\<theta> / 2)) \\<cdot>\\<^sub>v \\<alpha> +\n      complex_of_real (sin (\\<theta> / 2)) \\<cdot>\\<^sub>v \\<beta>)\n     \\<alpha> =\n    complex_of_real (cos (\\<theta> / 2))", "have \"inner_prod (ccos (\\<theta> / 2) \\<cdot>\\<^sub>v \\<alpha>) \\<alpha> = ccos (\\<theta> / 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inner_prod\n     (complex_of_real (cos (\\<theta> / 2)) \\<cdot>\\<^sub>v \\<alpha>)\n     \\<alpha> =\n    complex_of_real (cos (\\<theta> / 2))", "apply (subst inner_prod_smult_right[of _ N])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<alpha> \\<in> carrier_vec N\n 2. conjugate (complex_of_real (cos (\\<theta> / 2))) *\n    inner_prod \\<alpha> \\<alpha> =\n    complex_of_real (cos (\\<theta> / 2))", "using \\<alpha>_dim \\<alpha>_inner"], ["proof (prove)\nusing this:\n  \\<alpha> \\<in> carrier_vec N\n  dim_vec \\<alpha> = N\n  inner_prod \\<alpha> \\<alpha> = 1\n\ngoal (2 subgoals):\n 1. \\<alpha> \\<in> carrier_vec N\n 2. conjugate (complex_of_real (cos (\\<theta> / 2))) *\n    inner_prod \\<alpha> \\<alpha> =\n    complex_of_real (cos (\\<theta> / 2))", "by auto"], ["proof (state)\nthis:\n  inner_prod (complex_of_real (cos (\\<theta> / 2)) \\<cdot>\\<^sub>v \\<alpha>)\n   \\<alpha> =\n  complex_of_real (cos (\\<theta> / 2))\n\ngoal (1 subgoal):\n 1. inner_prod\n     (complex_of_real (cos (\\<theta> / 2)) \\<cdot>\\<^sub>v \\<alpha> +\n      complex_of_real (sin (\\<theta> / 2)) \\<cdot>\\<^sub>v \\<beta>)\n     \\<alpha> =\n    complex_of_real (cos (\\<theta> / 2))", "moreover"], ["proof (state)\nthis:\n  inner_prod (complex_of_real (cos (\\<theta> / 2)) \\<cdot>\\<^sub>v \\<alpha>)\n   \\<alpha> =\n  complex_of_real (cos (\\<theta> / 2))\n\ngoal (1 subgoal):\n 1. inner_prod\n     (complex_of_real (cos (\\<theta> / 2)) \\<cdot>\\<^sub>v \\<alpha> +\n      complex_of_real (sin (\\<theta> / 2)) \\<cdot>\\<^sub>v \\<beta>)\n     \\<alpha> =\n    complex_of_real (cos (\\<theta> / 2))", "have \"inner_prod (csin (\\<theta> / 2) \\<cdot>\\<^sub>v \\<beta>) \\<alpha> = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inner_prod\n     (complex_of_real (sin (\\<theta> / 2)) \\<cdot>\\<^sub>v \\<beta>)\n     \\<alpha> =\n    0", "apply (subst inner_prod_smult_right[of _ N])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<beta> \\<in> carrier_vec N\n 2. \\<alpha> \\<in> carrier_vec N\n 3. conjugate (complex_of_real (sin (\\<theta> / 2))) *\n    inner_prod \\<beta> \\<alpha> =\n    0", "using \\<alpha>_dim \\<beta>_dim beta_alpha_orth"], ["proof (prove)\nusing this:\n  \\<alpha> \\<in> carrier_vec N\n  dim_vec \\<alpha> = N\n  \\<beta> \\<in> carrier_vec N\n  dim_vec \\<beta> = N\n  inner_prod \\<beta> \\<alpha> = 0\n\ngoal (3 subgoals):\n 1. \\<beta> \\<in> carrier_vec N\n 2. \\<alpha> \\<in> carrier_vec N\n 3. conjugate (complex_of_real (sin (\\<theta> / 2))) *\n    inner_prod \\<beta> \\<alpha> =\n    0", "by auto"], ["proof (state)\nthis:\n  inner_prod (complex_of_real (sin (\\<theta> / 2)) \\<cdot>\\<^sub>v \\<beta>)\n   \\<alpha> =\n  0\n\ngoal (1 subgoal):\n 1. inner_prod\n     (complex_of_real (cos (\\<theta> / 2)) \\<cdot>\\<^sub>v \\<alpha> +\n      complex_of_real (sin (\\<theta> / 2)) \\<cdot>\\<^sub>v \\<beta>)\n     \\<alpha> =\n    complex_of_real (cos (\\<theta> / 2))", "ultimately"], ["proof (chain)\npicking this:\n  inner_prod (complex_of_real (cos (\\<theta> / 2)) \\<cdot>\\<^sub>v \\<alpha>)\n   \\<alpha> =\n  complex_of_real (cos (\\<theta> / 2))\n  inner_prod (complex_of_real (sin (\\<theta> / 2)) \\<cdot>\\<^sub>v \\<beta>)\n   \\<alpha> =\n  0", "show \"inner_prod (ccos (\\<theta> / 2) \\<cdot>\\<^sub>v \\<alpha> + csin (\\<theta> / 2) \\<cdot>\\<^sub>v \\<beta>) \\<alpha> = ccos (\\<theta> / 2)\""], ["proof (prove)\nusing this:\n  inner_prod (complex_of_real (cos (\\<theta> / 2)) \\<cdot>\\<^sub>v \\<alpha>)\n   \\<alpha> =\n  complex_of_real (cos (\\<theta> / 2))\n  inner_prod (complex_of_real (sin (\\<theta> / 2)) \\<cdot>\\<^sub>v \\<beta>)\n   \\<alpha> =\n  0\n\ngoal (1 subgoal):\n 1. inner_prod\n     (complex_of_real (cos (\\<theta> / 2)) \\<cdot>\\<^sub>v \\<alpha> +\n      complex_of_real (sin (\\<theta> / 2)) \\<cdot>\\<^sub>v \\<beta>)\n     \\<alpha> =\n    complex_of_real (cos (\\<theta> / 2))", "apply (subst inner_prod_distrib_left[of _ N])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>inner_prod\n              (complex_of_real (cos (\\<theta> / 2)) \\<cdot>\\<^sub>v\n               \\<alpha>)\n              \\<alpha> =\n             complex_of_real (cos (\\<theta> / 2));\n     inner_prod\n      (complex_of_real (sin (\\<theta> / 2)) \\<cdot>\\<^sub>v \\<beta>)\n      \\<alpha> =\n     0\\<rbrakk>\n    \\<Longrightarrow> \\<alpha> \\<in> carrier_vec N\n 2. \\<lbrakk>inner_prod\n              (complex_of_real (cos (\\<theta> / 2)) \\<cdot>\\<^sub>v\n               \\<alpha>)\n              \\<alpha> =\n             complex_of_real (cos (\\<theta> / 2));\n     inner_prod\n      (complex_of_real (sin (\\<theta> / 2)) \\<cdot>\\<^sub>v \\<beta>)\n      \\<alpha> =\n     0\\<rbrakk>\n    \\<Longrightarrow> complex_of_real (cos (\\<theta> / 2)) \\<cdot>\\<^sub>v\n                      \\<alpha>\n                      \\<in> carrier_vec N\n 3. \\<lbrakk>inner_prod\n              (complex_of_real (cos (\\<theta> / 2)) \\<cdot>\\<^sub>v\n               \\<alpha>)\n              \\<alpha> =\n             complex_of_real (cos (\\<theta> / 2));\n     inner_prod\n      (complex_of_real (sin (\\<theta> / 2)) \\<cdot>\\<^sub>v \\<beta>)\n      \\<alpha> =\n     0\\<rbrakk>\n    \\<Longrightarrow> complex_of_real (sin (\\<theta> / 2)) \\<cdot>\\<^sub>v\n                      \\<beta>\n                      \\<in> carrier_vec N\n 4. \\<lbrakk>inner_prod\n              (complex_of_real (cos (\\<theta> / 2)) \\<cdot>\\<^sub>v\n               \\<alpha>)\n              \\<alpha> =\n             complex_of_real (cos (\\<theta> / 2));\n     inner_prod\n      (complex_of_real (sin (\\<theta> / 2)) \\<cdot>\\<^sub>v \\<beta>)\n      \\<alpha> =\n     0\\<rbrakk>\n    \\<Longrightarrow> inner_prod\n                       (complex_of_real (cos (\\<theta> / 2)) \\<cdot>\\<^sub>v\n                        \\<alpha>)\n                       \\<alpha> +\n                      inner_prod\n                       (complex_of_real (sin (\\<theta> / 2)) \\<cdot>\\<^sub>v\n                        \\<beta>)\n                       \\<alpha> =\n                      complex_of_real (cos (\\<theta> / 2))", "using \\<alpha>_dim \\<beta>_dim"], ["proof (prove)\nusing this:\n  \\<alpha> \\<in> carrier_vec N\n  dim_vec \\<alpha> = N\n  \\<beta> \\<in> carrier_vec N\n  dim_vec \\<beta> = N\n\ngoal (4 subgoals):\n 1. \\<lbrakk>inner_prod\n              (complex_of_real (cos (\\<theta> / 2)) \\<cdot>\\<^sub>v\n               \\<alpha>)\n              \\<alpha> =\n             complex_of_real (cos (\\<theta> / 2));\n     inner_prod\n      (complex_of_real (sin (\\<theta> / 2)) \\<cdot>\\<^sub>v \\<beta>)\n      \\<alpha> =\n     0\\<rbrakk>\n    \\<Longrightarrow> \\<alpha> \\<in> carrier_vec N\n 2. \\<lbrakk>inner_prod\n              (complex_of_real (cos (\\<theta> / 2)) \\<cdot>\\<^sub>v\n               \\<alpha>)\n              \\<alpha> =\n             complex_of_real (cos (\\<theta> / 2));\n     inner_prod\n      (complex_of_real (sin (\\<theta> / 2)) \\<cdot>\\<^sub>v \\<beta>)\n      \\<alpha> =\n     0\\<rbrakk>\n    \\<Longrightarrow> complex_of_real (cos (\\<theta> / 2)) \\<cdot>\\<^sub>v\n                      \\<alpha>\n                      \\<in> carrier_vec N\n 3. \\<lbrakk>inner_prod\n              (complex_of_real (cos (\\<theta> / 2)) \\<cdot>\\<^sub>v\n               \\<alpha>)\n              \\<alpha> =\n             complex_of_real (cos (\\<theta> / 2));\n     inner_prod\n      (complex_of_real (sin (\\<theta> / 2)) \\<cdot>\\<^sub>v \\<beta>)\n      \\<alpha> =\n     0\\<rbrakk>\n    \\<Longrightarrow> complex_of_real (sin (\\<theta> / 2)) \\<cdot>\\<^sub>v\n                      \\<beta>\n                      \\<in> carrier_vec N\n 4. \\<lbrakk>inner_prod\n              (complex_of_real (cos (\\<theta> / 2)) \\<cdot>\\<^sub>v\n               \\<alpha>)\n              \\<alpha> =\n             complex_of_real (cos (\\<theta> / 2));\n     inner_prod\n      (complex_of_real (sin (\\<theta> / 2)) \\<cdot>\\<^sub>v \\<beta>)\n      \\<alpha> =\n     0\\<rbrakk>\n    \\<Longrightarrow> inner_prod\n                       (complex_of_real (cos (\\<theta> / 2)) \\<cdot>\\<^sub>v\n                        \\<alpha>)\n                       \\<alpha> +\n                      inner_prod\n                       (complex_of_real (sin (\\<theta> / 2)) \\<cdot>\\<^sub>v\n                        \\<beta>)\n                       \\<alpha> =\n                      complex_of_real (cos (\\<theta> / 2))", "by auto"], ["proof (state)\nthis:\n  inner_prod\n   (complex_of_real (cos (\\<theta> / 2)) \\<cdot>\\<^sub>v \\<alpha> +\n    complex_of_real (sin (\\<theta> / 2)) \\<cdot>\\<^sub>v \\<beta>)\n   \\<alpha> =\n  complex_of_real (cos (\\<theta> / 2))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma psi_inner_beta:\n  \"inner_prod \\<psi> \\<beta> = csin (\\<theta> / 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inner_prod \\<psi> \\<beta> = complex_of_real (sin (\\<theta> / 2))", "unfolding \\<psi>_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. inner_prod\n     (complex_of_real (cos (\\<theta> / 2)) \\<cdot>\\<^sub>v \\<alpha> +\n      complex_of_real (sin (\\<theta> / 2)) \\<cdot>\\<^sub>v \\<beta>)\n     \\<beta> =\n    complex_of_real (sin (\\<theta> / 2))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. inner_prod\n     (complex_of_real (cos (\\<theta> / 2)) \\<cdot>\\<^sub>v \\<alpha> +\n      complex_of_real (sin (\\<theta> / 2)) \\<cdot>\\<^sub>v \\<beta>)\n     \\<beta> =\n    complex_of_real (sin (\\<theta> / 2))", "have \"inner_prod (ccos (\\<theta> / 2) \\<cdot>\\<^sub>v \\<alpha>) \\<beta> = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inner_prod\n     (complex_of_real (cos (\\<theta> / 2)) \\<cdot>\\<^sub>v \\<alpha>)\n     \\<beta> =\n    0", "apply (subst inner_prod_smult_right[of _ N])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<alpha> \\<in> carrier_vec N\n 2. \\<beta> \\<in> carrier_vec N\n 3. conjugate (complex_of_real (cos (\\<theta> / 2))) *\n    inner_prod \\<alpha> \\<beta> =\n    0", "using \\<alpha>_dim \\<beta>_dim alpha_beta_orth"], ["proof (prove)\nusing this:\n  \\<alpha> \\<in> carrier_vec N\n  dim_vec \\<alpha> = N\n  \\<beta> \\<in> carrier_vec N\n  dim_vec \\<beta> = N\n  inner_prod \\<alpha> \\<beta> = 0\n\ngoal (3 subgoals):\n 1. \\<alpha> \\<in> carrier_vec N\n 2. \\<beta> \\<in> carrier_vec N\n 3. conjugate (complex_of_real (cos (\\<theta> / 2))) *\n    inner_prod \\<alpha> \\<beta> =\n    0", "by auto"], ["proof (state)\nthis:\n  inner_prod (complex_of_real (cos (\\<theta> / 2)) \\<cdot>\\<^sub>v \\<alpha>)\n   \\<beta> =\n  0\n\ngoal (1 subgoal):\n 1. inner_prod\n     (complex_of_real (cos (\\<theta> / 2)) \\<cdot>\\<^sub>v \\<alpha> +\n      complex_of_real (sin (\\<theta> / 2)) \\<cdot>\\<^sub>v \\<beta>)\n     \\<beta> =\n    complex_of_real (sin (\\<theta> / 2))", "moreover"], ["proof (state)\nthis:\n  inner_prod (complex_of_real (cos (\\<theta> / 2)) \\<cdot>\\<^sub>v \\<alpha>)\n   \\<beta> =\n  0\n\ngoal (1 subgoal):\n 1. inner_prod\n     (complex_of_real (cos (\\<theta> / 2)) \\<cdot>\\<^sub>v \\<alpha> +\n      complex_of_real (sin (\\<theta> / 2)) \\<cdot>\\<^sub>v \\<beta>)\n     \\<beta> =\n    complex_of_real (sin (\\<theta> / 2))", "have \"inner_prod (csin (\\<theta> / 2) \\<cdot>\\<^sub>v \\<beta>) \\<beta> = csin (\\<theta> / 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inner_prod\n     (complex_of_real (sin (\\<theta> / 2)) \\<cdot>\\<^sub>v \\<beta>)\n     \\<beta> =\n    complex_of_real (sin (\\<theta> / 2))", "apply (subst inner_prod_smult_right[of _ N])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<beta> \\<in> carrier_vec N\n 2. conjugate (complex_of_real (sin (\\<theta> / 2))) *\n    inner_prod \\<beta> \\<beta> =\n    complex_of_real (sin (\\<theta> / 2))", "using \\<beta>_dim \\<beta>_inner"], ["proof (prove)\nusing this:\n  \\<beta> \\<in> carrier_vec N\n  dim_vec \\<beta> = N\n  inner_prod \\<beta> \\<beta> = 1\n\ngoal (2 subgoals):\n 1. \\<beta> \\<in> carrier_vec N\n 2. conjugate (complex_of_real (sin (\\<theta> / 2))) *\n    inner_prod \\<beta> \\<beta> =\n    complex_of_real (sin (\\<theta> / 2))", "by auto"], ["proof (state)\nthis:\n  inner_prod (complex_of_real (sin (\\<theta> / 2)) \\<cdot>\\<^sub>v \\<beta>)\n   \\<beta> =\n  complex_of_real (sin (\\<theta> / 2))\n\ngoal (1 subgoal):\n 1. inner_prod\n     (complex_of_real (cos (\\<theta> / 2)) \\<cdot>\\<^sub>v \\<alpha> +\n      complex_of_real (sin (\\<theta> / 2)) \\<cdot>\\<^sub>v \\<beta>)\n     \\<beta> =\n    complex_of_real (sin (\\<theta> / 2))", "ultimately"], ["proof (chain)\npicking this:\n  inner_prod (complex_of_real (cos (\\<theta> / 2)) \\<cdot>\\<^sub>v \\<alpha>)\n   \\<beta> =\n  0\n  inner_prod (complex_of_real (sin (\\<theta> / 2)) \\<cdot>\\<^sub>v \\<beta>)\n   \\<beta> =\n  complex_of_real (sin (\\<theta> / 2))", "show \"inner_prod (ccos (\\<theta> / 2) \\<cdot>\\<^sub>v \\<alpha> + csin (\\<theta> / 2) \\<cdot>\\<^sub>v \\<beta>) \\<beta> = csin (\\<theta> / 2)\""], ["proof (prove)\nusing this:\n  inner_prod (complex_of_real (cos (\\<theta> / 2)) \\<cdot>\\<^sub>v \\<alpha>)\n   \\<beta> =\n  0\n  inner_prod (complex_of_real (sin (\\<theta> / 2)) \\<cdot>\\<^sub>v \\<beta>)\n   \\<beta> =\n  complex_of_real (sin (\\<theta> / 2))\n\ngoal (1 subgoal):\n 1. inner_prod\n     (complex_of_real (cos (\\<theta> / 2)) \\<cdot>\\<^sub>v \\<alpha> +\n      complex_of_real (sin (\\<theta> / 2)) \\<cdot>\\<^sub>v \\<beta>)\n     \\<beta> =\n    complex_of_real (sin (\\<theta> / 2))", "apply (subst inner_prod_distrib_left[of _ N])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>inner_prod\n              (complex_of_real (cos (\\<theta> / 2)) \\<cdot>\\<^sub>v\n               \\<alpha>)\n              \\<beta> =\n             0;\n     inner_prod\n      (complex_of_real (sin (\\<theta> / 2)) \\<cdot>\\<^sub>v \\<beta>)\n      \\<beta> =\n     complex_of_real (sin (\\<theta> / 2))\\<rbrakk>\n    \\<Longrightarrow> \\<beta> \\<in> carrier_vec N\n 2. \\<lbrakk>inner_prod\n              (complex_of_real (cos (\\<theta> / 2)) \\<cdot>\\<^sub>v\n               \\<alpha>)\n              \\<beta> =\n             0;\n     inner_prod\n      (complex_of_real (sin (\\<theta> / 2)) \\<cdot>\\<^sub>v \\<beta>)\n      \\<beta> =\n     complex_of_real (sin (\\<theta> / 2))\\<rbrakk>\n    \\<Longrightarrow> complex_of_real (cos (\\<theta> / 2)) \\<cdot>\\<^sub>v\n                      \\<alpha>\n                      \\<in> carrier_vec N\n 3. \\<lbrakk>inner_prod\n              (complex_of_real (cos (\\<theta> / 2)) \\<cdot>\\<^sub>v\n               \\<alpha>)\n              \\<beta> =\n             0;\n     inner_prod\n      (complex_of_real (sin (\\<theta> / 2)) \\<cdot>\\<^sub>v \\<beta>)\n      \\<beta> =\n     complex_of_real (sin (\\<theta> / 2))\\<rbrakk>\n    \\<Longrightarrow> complex_of_real (sin (\\<theta> / 2)) \\<cdot>\\<^sub>v\n                      \\<beta>\n                      \\<in> carrier_vec N\n 4. \\<lbrakk>inner_prod\n              (complex_of_real (cos (\\<theta> / 2)) \\<cdot>\\<^sub>v\n               \\<alpha>)\n              \\<beta> =\n             0;\n     inner_prod\n      (complex_of_real (sin (\\<theta> / 2)) \\<cdot>\\<^sub>v \\<beta>)\n      \\<beta> =\n     complex_of_real (sin (\\<theta> / 2))\\<rbrakk>\n    \\<Longrightarrow> inner_prod\n                       (complex_of_real (cos (\\<theta> / 2)) \\<cdot>\\<^sub>v\n                        \\<alpha>)\n                       \\<beta> +\n                      inner_prod\n                       (complex_of_real (sin (\\<theta> / 2)) \\<cdot>\\<^sub>v\n                        \\<beta>)\n                       \\<beta> =\n                      complex_of_real (sin (\\<theta> / 2))", "using \\<alpha>_dim \\<beta>_dim"], ["proof (prove)\nusing this:\n  \\<alpha> \\<in> carrier_vec N\n  dim_vec \\<alpha> = N\n  \\<beta> \\<in> carrier_vec N\n  dim_vec \\<beta> = N\n\ngoal (4 subgoals):\n 1. \\<lbrakk>inner_prod\n              (complex_of_real (cos (\\<theta> / 2)) \\<cdot>\\<^sub>v\n               \\<alpha>)\n              \\<beta> =\n             0;\n     inner_prod\n      (complex_of_real (sin (\\<theta> / 2)) \\<cdot>\\<^sub>v \\<beta>)\n      \\<beta> =\n     complex_of_real (sin (\\<theta> / 2))\\<rbrakk>\n    \\<Longrightarrow> \\<beta> \\<in> carrier_vec N\n 2. \\<lbrakk>inner_prod\n              (complex_of_real (cos (\\<theta> / 2)) \\<cdot>\\<^sub>v\n               \\<alpha>)\n              \\<beta> =\n             0;\n     inner_prod\n      (complex_of_real (sin (\\<theta> / 2)) \\<cdot>\\<^sub>v \\<beta>)\n      \\<beta> =\n     complex_of_real (sin (\\<theta> / 2))\\<rbrakk>\n    \\<Longrightarrow> complex_of_real (cos (\\<theta> / 2)) \\<cdot>\\<^sub>v\n                      \\<alpha>\n                      \\<in> carrier_vec N\n 3. \\<lbrakk>inner_prod\n              (complex_of_real (cos (\\<theta> / 2)) \\<cdot>\\<^sub>v\n               \\<alpha>)\n              \\<beta> =\n             0;\n     inner_prod\n      (complex_of_real (sin (\\<theta> / 2)) \\<cdot>\\<^sub>v \\<beta>)\n      \\<beta> =\n     complex_of_real (sin (\\<theta> / 2))\\<rbrakk>\n    \\<Longrightarrow> complex_of_real (sin (\\<theta> / 2)) \\<cdot>\\<^sub>v\n                      \\<beta>\n                      \\<in> carrier_vec N\n 4. \\<lbrakk>inner_prod\n              (complex_of_real (cos (\\<theta> / 2)) \\<cdot>\\<^sub>v\n               \\<alpha>)\n              \\<beta> =\n             0;\n     inner_prod\n      (complex_of_real (sin (\\<theta> / 2)) \\<cdot>\\<^sub>v \\<beta>)\n      \\<beta> =\n     complex_of_real (sin (\\<theta> / 2))\\<rbrakk>\n    \\<Longrightarrow> inner_prod\n                       (complex_of_real (cos (\\<theta> / 2)) \\<cdot>\\<^sub>v\n                        \\<alpha>)\n                       \\<beta> +\n                      inner_prod\n                       (complex_of_real (sin (\\<theta> / 2)) \\<cdot>\\<^sub>v\n                        \\<beta>)\n                       \\<beta> =\n                      complex_of_real (sin (\\<theta> / 2))", "by auto"], ["proof (state)\nthis:\n  inner_prod\n   (complex_of_real (cos (\\<theta> / 2)) \\<cdot>\\<^sub>v \\<alpha> +\n    complex_of_real (sin (\\<theta> / 2)) \\<cdot>\\<^sub>v \\<beta>)\n   \\<beta> =\n  complex_of_real (sin (\\<theta> / 2))\n\ngoal:\nNo subgoals!", "qed"], ["", "definition alpha_l :: \"nat \\<Rightarrow> complex\" where\n  \"alpha_l l = ccos ((l + 1 / 2) * \\<theta>)\""], ["", "lemma alpha_l_real:\n  \"alpha_l l \\<in> Reals\""], ["proof (prove)\ngoal (1 subgoal):\n 1. alpha_l l \\<in> \\<real>", "unfolding alpha_l_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. complex_of_real (cos ((real l + 1 / 2) * \\<theta>)) \\<in> \\<real>", "by auto"], ["", "lemma cnj_alpha_l:\n  \"conjugate (alpha_l l) = alpha_l l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. conjugate (alpha_l l) = alpha_l l", "using alpha_l_real Reals_cnj_iff"], ["proof (prove)\nusing this:\n  alpha_l ?l \\<in> \\<real>\n  (?z \\<in> \\<real>) = (cnj ?z = ?z)\n\ngoal (1 subgoal):\n 1. conjugate (alpha_l l) = alpha_l l", "by auto"], ["", "definition beta_l :: \"nat \\<Rightarrow> complex\" where\n  \"beta_l l = csin ((l + 1 / 2) * \\<theta>)\""], ["", "lemma beta_l_real:\n  \"beta_l l \\<in> Reals\""], ["proof (prove)\ngoal (1 subgoal):\n 1. beta_l l \\<in> \\<real>", "unfolding beta_l_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. complex_of_real (sin ((real l + 1 / 2) * \\<theta>)) \\<in> \\<real>", "by auto"], ["", "lemma cnj_beta_l:\n  \"conjugate (beta_l l) = beta_l l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. conjugate (beta_l l) = beta_l l", "using beta_l_real Reals_cnj_iff"], ["proof (prove)\nusing this:\n  beta_l ?l \\<in> \\<real>\n  (?z \\<in> \\<real>) = (cnj ?z = ?z)\n\ngoal (1 subgoal):\n 1. conjugate (beta_l l) = beta_l l", "by auto"], ["", "lemma csin_ccos_squared_add:\n  \"ccos (a::real) * ccos a + csin a * csin a = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. complex_of_real (cos a) * complex_of_real (cos a) +\n    complex_of_real (sin a) * complex_of_real (sin a) =\n    1", "by (smt cos_diff cos_zero of_real_add of_real_hom.hom_one of_real_mult)"], ["", "lemma alpha_l_beta_l_add_norm:\n  \"alpha_l l * alpha_l l + beta_l l * beta_l l = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. alpha_l l * alpha_l l + beta_l l * beta_l l = 1", "using alpha_l_def beta_l_def csin_ccos_squared_add"], ["proof (prove)\nusing this:\n  alpha_l ?l = complex_of_real (cos ((real ?l + 1 / 2) * \\<theta>))\n  beta_l ?l = complex_of_real (sin ((real ?l + 1 / 2) * \\<theta>))\n  complex_of_real (cos ?a) * complex_of_real (cos ?a) +\n  complex_of_real (sin ?a) * complex_of_real (sin ?a) =\n  1\n\ngoal (1 subgoal):\n 1. alpha_l l * alpha_l l + beta_l l * beta_l l = 1", "by auto"], ["", "definition psi_l where\n  \"psi_l l = (alpha_l l) \\<cdot>\\<^sub>v \\<alpha> + (beta_l l) \\<cdot>\\<^sub>v \\<beta>\""], ["", "lemma psi_l_dim:\n  \"psi_l l \\<in> carrier_vec N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. psi_l l \\<in> carrier_vec N", "unfolding psi_l_def \\<alpha>_def \\<beta>_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. alpha_l l \\<cdot>\\<^sub>v\n    Matrix.vec N\n     (\\<lambda>x.\n         complex_of_real (if f x then 0 else 1 / sqrt (real (N - M)))) +\n    beta_l l \\<cdot>\\<^sub>v\n    Matrix.vec N\n     (\\<lambda>x. complex_of_real (if f x then 1 / sqrt (real M) else 0))\n    \\<in> carrier_vec N", "by auto"], ["", "lemma inner_psi_l:\n  \"inner_prod (psi_l l) (psi_l l) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inner_prod (psi_l l) (psi_l l) = 1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. inner_prod (psi_l l) (psi_l l) = 1", "have eq0: \"inner_prod (psi_l l) (psi_l l) \n    = inner_prod ((alpha_l l) \\<cdot>\\<^sub>v \\<alpha>) (psi_l l) + inner_prod ((beta_l l) \\<cdot>\\<^sub>v \\<beta>) (psi_l l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inner_prod (psi_l l) (psi_l l) =\n    inner_prod (alpha_l l \\<cdot>\\<^sub>v \\<alpha>) (psi_l l) +\n    inner_prod (beta_l l \\<cdot>\\<^sub>v \\<beta>) (psi_l l)", "unfolding psi_l_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. inner_prod\n     (alpha_l l \\<cdot>\\<^sub>v \\<alpha> + beta_l l \\<cdot>\\<^sub>v \\<beta>)\n     (alpha_l l \\<cdot>\\<^sub>v \\<alpha> +\n      beta_l l \\<cdot>\\<^sub>v \\<beta>) =\n    inner_prod (alpha_l l \\<cdot>\\<^sub>v \\<alpha>)\n     (alpha_l l \\<cdot>\\<^sub>v \\<alpha> +\n      beta_l l \\<cdot>\\<^sub>v \\<beta>) +\n    inner_prod (beta_l l \\<cdot>\\<^sub>v \\<beta>)\n     (alpha_l l \\<cdot>\\<^sub>v \\<alpha> + beta_l l \\<cdot>\\<^sub>v \\<beta>)", "apply (subst inner_prod_distrib_left)"], ["proof (prove)\ngoal (4 subgoals):\n 1. alpha_l l \\<cdot>\\<^sub>v \\<alpha> + beta_l l \\<cdot>\\<^sub>v \\<beta>\n    \\<in> carrier_vec ?n\n 2. alpha_l l \\<cdot>\\<^sub>v \\<alpha> \\<in> carrier_vec ?n\n 3. beta_l l \\<cdot>\\<^sub>v \\<beta> \\<in> carrier_vec ?n\n 4. inner_prod (alpha_l l \\<cdot>\\<^sub>v \\<alpha>)\n     (alpha_l l \\<cdot>\\<^sub>v \\<alpha> +\n      beta_l l \\<cdot>\\<^sub>v \\<beta>) +\n    inner_prod (beta_l l \\<cdot>\\<^sub>v \\<beta>)\n     (alpha_l l \\<cdot>\\<^sub>v \\<alpha> +\n      beta_l l \\<cdot>\\<^sub>v \\<beta>) =\n    inner_prod (alpha_l l \\<cdot>\\<^sub>v \\<alpha>)\n     (alpha_l l \\<cdot>\\<^sub>v \\<alpha> +\n      beta_l l \\<cdot>\\<^sub>v \\<beta>) +\n    inner_prod (beta_l l \\<cdot>\\<^sub>v \\<beta>)\n     (alpha_l l \\<cdot>\\<^sub>v \\<alpha> + beta_l l \\<cdot>\\<^sub>v \\<beta>)", "using \\<alpha>_def \\<beta>_def"], ["proof (prove)\nusing this:\n  \\<alpha> =\n  Matrix.vec N\n   (\\<lambda>x.\n       complex_of_real (if f x then 0 else 1 / sqrt (real (N - M))))\n  \\<beta> =\n  Matrix.vec N\n   (\\<lambda>x. complex_of_real (if f x then 1 / sqrt (real M) else 0))\n\ngoal (4 subgoals):\n 1. alpha_l l \\<cdot>\\<^sub>v \\<alpha> + beta_l l \\<cdot>\\<^sub>v \\<beta>\n    \\<in> carrier_vec ?n\n 2. alpha_l l \\<cdot>\\<^sub>v \\<alpha> \\<in> carrier_vec ?n\n 3. beta_l l \\<cdot>\\<^sub>v \\<beta> \\<in> carrier_vec ?n\n 4. inner_prod (alpha_l l \\<cdot>\\<^sub>v \\<alpha>)\n     (alpha_l l \\<cdot>\\<^sub>v \\<alpha> +\n      beta_l l \\<cdot>\\<^sub>v \\<beta>) +\n    inner_prod (beta_l l \\<cdot>\\<^sub>v \\<beta>)\n     (alpha_l l \\<cdot>\\<^sub>v \\<alpha> +\n      beta_l l \\<cdot>\\<^sub>v \\<beta>) =\n    inner_prod (alpha_l l \\<cdot>\\<^sub>v \\<alpha>)\n     (alpha_l l \\<cdot>\\<^sub>v \\<alpha> +\n      beta_l l \\<cdot>\\<^sub>v \\<beta>) +\n    inner_prod (beta_l l \\<cdot>\\<^sub>v \\<beta>)\n     (alpha_l l \\<cdot>\\<^sub>v \\<alpha> + beta_l l \\<cdot>\\<^sub>v \\<beta>)", "by auto"], ["proof (state)\nthis:\n  inner_prod (psi_l l) (psi_l l) =\n  inner_prod (alpha_l l \\<cdot>\\<^sub>v \\<alpha>) (psi_l l) +\n  inner_prod (beta_l l \\<cdot>\\<^sub>v \\<beta>) (psi_l l)\n\ngoal (1 subgoal):\n 1. inner_prod (psi_l l) (psi_l l) = 1", "have \"inner_prod ((alpha_l l) \\<cdot>\\<^sub>v \\<alpha>) (psi_l l) \n    = inner_prod ((alpha_l l) \\<cdot>\\<^sub>v \\<alpha>) ((alpha_l l) \\<cdot>\\<^sub>v \\<alpha>) + inner_prod ((alpha_l l) \\<cdot>\\<^sub>v \\<alpha>) ((beta_l l) \\<cdot>\\<^sub>v \\<beta>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inner_prod (alpha_l l \\<cdot>\\<^sub>v \\<alpha>) (psi_l l) =\n    inner_prod (alpha_l l \\<cdot>\\<^sub>v \\<alpha>)\n     (alpha_l l \\<cdot>\\<^sub>v \\<alpha>) +\n    inner_prod (alpha_l l \\<cdot>\\<^sub>v \\<alpha>)\n     (beta_l l \\<cdot>\\<^sub>v \\<beta>)", "unfolding psi_l_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. inner_prod (alpha_l l \\<cdot>\\<^sub>v \\<alpha>)\n     (alpha_l l \\<cdot>\\<^sub>v \\<alpha> +\n      beta_l l \\<cdot>\\<^sub>v \\<beta>) =\n    inner_prod (alpha_l l \\<cdot>\\<^sub>v \\<alpha>)\n     (alpha_l l \\<cdot>\\<^sub>v \\<alpha>) +\n    inner_prod (alpha_l l \\<cdot>\\<^sub>v \\<alpha>)\n     (beta_l l \\<cdot>\\<^sub>v \\<beta>)", "apply (subst inner_prod_distrib_right)"], ["proof (prove)\ngoal (3 subgoals):\n 1. alpha_l l \\<cdot>\\<^sub>v \\<alpha> \\<in> carrier_vec ?n\n 2. beta_l l \\<cdot>\\<^sub>v \\<beta> \\<in> carrier_vec ?n\n 3. inner_prod (alpha_l l \\<cdot>\\<^sub>v \\<alpha>)\n     (alpha_l l \\<cdot>\\<^sub>v \\<alpha>) +\n    inner_prod (alpha_l l \\<cdot>\\<^sub>v \\<alpha>)\n     (beta_l l \\<cdot>\\<^sub>v \\<beta>) =\n    inner_prod (alpha_l l \\<cdot>\\<^sub>v \\<alpha>)\n     (alpha_l l \\<cdot>\\<^sub>v \\<alpha>) +\n    inner_prod (alpha_l l \\<cdot>\\<^sub>v \\<alpha>)\n     (beta_l l \\<cdot>\\<^sub>v \\<beta>)", "using \\<alpha>_def \\<beta>_def"], ["proof (prove)\nusing this:\n  \\<alpha> =\n  Matrix.vec N\n   (\\<lambda>x.\n       complex_of_real (if f x then 0 else 1 / sqrt (real (N - M))))\n  \\<beta> =\n  Matrix.vec N\n   (\\<lambda>x. complex_of_real (if f x then 1 / sqrt (real M) else 0))\n\ngoal (3 subgoals):\n 1. alpha_l l \\<cdot>\\<^sub>v \\<alpha> \\<in> carrier_vec ?n\n 2. beta_l l \\<cdot>\\<^sub>v \\<beta> \\<in> carrier_vec ?n\n 3. inner_prod (alpha_l l \\<cdot>\\<^sub>v \\<alpha>)\n     (alpha_l l \\<cdot>\\<^sub>v \\<alpha>) +\n    inner_prod (alpha_l l \\<cdot>\\<^sub>v \\<alpha>)\n     (beta_l l \\<cdot>\\<^sub>v \\<beta>) =\n    inner_prod (alpha_l l \\<cdot>\\<^sub>v \\<alpha>)\n     (alpha_l l \\<cdot>\\<^sub>v \\<alpha>) +\n    inner_prod (alpha_l l \\<cdot>\\<^sub>v \\<alpha>)\n     (beta_l l \\<cdot>\\<^sub>v \\<beta>)", "by auto"], ["proof (state)\nthis:\n  inner_prod (alpha_l l \\<cdot>\\<^sub>v \\<alpha>) (psi_l l) =\n  inner_prod (alpha_l l \\<cdot>\\<^sub>v \\<alpha>)\n   (alpha_l l \\<cdot>\\<^sub>v \\<alpha>) +\n  inner_prod (alpha_l l \\<cdot>\\<^sub>v \\<alpha>)\n   (beta_l l \\<cdot>\\<^sub>v \\<beta>)\n\ngoal (1 subgoal):\n 1. inner_prod (psi_l l) (psi_l l) = 1", "also"], ["proof (state)\nthis:\n  inner_prod (alpha_l l \\<cdot>\\<^sub>v \\<alpha>) (psi_l l) =\n  inner_prod (alpha_l l \\<cdot>\\<^sub>v \\<alpha>)\n   (alpha_l l \\<cdot>\\<^sub>v \\<alpha>) +\n  inner_prod (alpha_l l \\<cdot>\\<^sub>v \\<alpha>)\n   (beta_l l \\<cdot>\\<^sub>v \\<beta>)\n\ngoal (1 subgoal):\n 1. inner_prod (psi_l l) (psi_l l) = 1", "have \"\\<dots> = (conjugate (alpha_l l)) * (alpha_l l) * inner_prod \\<alpha> \\<alpha> \n                + (conjugate (alpha_l l)) * (beta_l l) * inner_prod \\<alpha> \\<beta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inner_prod (alpha_l l \\<cdot>\\<^sub>v \\<alpha>)\n     (alpha_l l \\<cdot>\\<^sub>v \\<alpha>) +\n    inner_prod (alpha_l l \\<cdot>\\<^sub>v \\<alpha>)\n     (beta_l l \\<cdot>\\<^sub>v \\<beta>) =\n    conjugate (alpha_l l) * alpha_l l * inner_prod \\<alpha> \\<alpha> +\n    conjugate (alpha_l l) * beta_l l * inner_prod \\<alpha> \\<beta>", "apply (subst (1 2) inner_prod_smult_left_right)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<alpha> \\<in> carrier_vec ?n\n 2. \\<beta> \\<in> carrier_vec ?n\n 3. \\<alpha> \\<in> carrier_vec ?n1\n 4. conjugate (alpha_l l) * alpha_l l * inner_prod \\<alpha> \\<alpha> +\n    conjugate (alpha_l l) * beta_l l * inner_prod \\<alpha> \\<beta> =\n    conjugate (alpha_l l) * alpha_l l * inner_prod \\<alpha> \\<alpha> +\n    conjugate (alpha_l l) * beta_l l * inner_prod \\<alpha> \\<beta>", "using \\<alpha>_def \\<beta>_def"], ["proof (prove)\nusing this:\n  \\<alpha> =\n  Matrix.vec N\n   (\\<lambda>x.\n       complex_of_real (if f x then 0 else 1 / sqrt (real (N - M))))\n  \\<beta> =\n  Matrix.vec N\n   (\\<lambda>x. complex_of_real (if f x then 1 / sqrt (real M) else 0))\n\ngoal (4 subgoals):\n 1. \\<alpha> \\<in> carrier_vec ?n\n 2. \\<beta> \\<in> carrier_vec ?n\n 3. \\<alpha> \\<in> carrier_vec ?n1\n 4. conjugate (alpha_l l) * alpha_l l * inner_prod \\<alpha> \\<alpha> +\n    conjugate (alpha_l l) * beta_l l * inner_prod \\<alpha> \\<beta> =\n    conjugate (alpha_l l) * alpha_l l * inner_prod \\<alpha> \\<alpha> +\n    conjugate (alpha_l l) * beta_l l * inner_prod \\<alpha> \\<beta>", "by auto"], ["proof (state)\nthis:\n  inner_prod (alpha_l l \\<cdot>\\<^sub>v \\<alpha>)\n   (alpha_l l \\<cdot>\\<^sub>v \\<alpha>) +\n  inner_prod (alpha_l l \\<cdot>\\<^sub>v \\<alpha>)\n   (beta_l l \\<cdot>\\<^sub>v \\<beta>) =\n  conjugate (alpha_l l) * alpha_l l * inner_prod \\<alpha> \\<alpha> +\n  conjugate (alpha_l l) * beta_l l * inner_prod \\<alpha> \\<beta>\n\ngoal (1 subgoal):\n 1. inner_prod (psi_l l) (psi_l l) = 1", "also"], ["proof (state)\nthis:\n  inner_prod (alpha_l l \\<cdot>\\<^sub>v \\<alpha>)\n   (alpha_l l \\<cdot>\\<^sub>v \\<alpha>) +\n  inner_prod (alpha_l l \\<cdot>\\<^sub>v \\<alpha>)\n   (beta_l l \\<cdot>\\<^sub>v \\<beta>) =\n  conjugate (alpha_l l) * alpha_l l * inner_prod \\<alpha> \\<alpha> +\n  conjugate (alpha_l l) * beta_l l * inner_prod \\<alpha> \\<beta>\n\ngoal (1 subgoal):\n 1. inner_prod (psi_l l) (psi_l l) = 1", "have \"\\<dots> = conjugate (alpha_l l) * (alpha_l l) \""], ["proof (prove)\ngoal (1 subgoal):\n 1. conjugate (alpha_l l) * alpha_l l * inner_prod \\<alpha> \\<alpha> +\n    conjugate (alpha_l l) * beta_l l * inner_prod \\<alpha> \\<beta> =\n    conjugate (alpha_l l) * alpha_l l", "by (simp add: alpha_beta_orth \\<alpha>_inner)"], ["proof (state)\nthis:\n  conjugate (alpha_l l) * alpha_l l * inner_prod \\<alpha> \\<alpha> +\n  conjugate (alpha_l l) * beta_l l * inner_prod \\<alpha> \\<beta> =\n  conjugate (alpha_l l) * alpha_l l\n\ngoal (1 subgoal):\n 1. inner_prod (psi_l l) (psi_l l) = 1", "also"], ["proof (state)\nthis:\n  conjugate (alpha_l l) * alpha_l l * inner_prod \\<alpha> \\<alpha> +\n  conjugate (alpha_l l) * beta_l l * inner_prod \\<alpha> \\<beta> =\n  conjugate (alpha_l l) * alpha_l l\n\ngoal (1 subgoal):\n 1. inner_prod (psi_l l) (psi_l l) = 1", "have \"\\<dots> = (alpha_l l) * (alpha_l l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. conjugate (alpha_l l) * alpha_l l = alpha_l l * alpha_l l", "using cnj_alpha_l"], ["proof (prove)\nusing this:\n  conjugate (alpha_l ?l) = alpha_l ?l\n\ngoal (1 subgoal):\n 1. conjugate (alpha_l l) * alpha_l l = alpha_l l * alpha_l l", "by simp"], ["proof (state)\nthis:\n  conjugate (alpha_l l) * alpha_l l = alpha_l l * alpha_l l\n\ngoal (1 subgoal):\n 1. inner_prod (psi_l l) (psi_l l) = 1", "finally"], ["proof (chain)\npicking this:\n  inner_prod (alpha_l l \\<cdot>\\<^sub>v \\<alpha>) (psi_l l) =\n  alpha_l l * alpha_l l", "have eq1: \"inner_prod (alpha_l l \\<cdot>\\<^sub>v \\<alpha>) (psi_l l) = alpha_l l * alpha_l l\""], ["proof (prove)\nusing this:\n  inner_prod (alpha_l l \\<cdot>\\<^sub>v \\<alpha>) (psi_l l) =\n  alpha_l l * alpha_l l\n\ngoal (1 subgoal):\n 1. inner_prod (alpha_l l \\<cdot>\\<^sub>v \\<alpha>) (psi_l l) =\n    alpha_l l * alpha_l l", "."], ["proof (state)\nthis:\n  inner_prod (alpha_l l \\<cdot>\\<^sub>v \\<alpha>) (psi_l l) =\n  alpha_l l * alpha_l l\n\ngoal (1 subgoal):\n 1. inner_prod (psi_l l) (psi_l l) = 1", "have \"inner_prod ((beta_l l) \\<cdot>\\<^sub>v \\<beta>) (psi_l l) \n    = inner_prod ((beta_l l) \\<cdot>\\<^sub>v \\<beta>) ((alpha_l l) \\<cdot>\\<^sub>v \\<alpha>) + inner_prod ((beta_l l) \\<cdot>\\<^sub>v \\<beta>) ((beta_l l) \\<cdot>\\<^sub>v \\<beta>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inner_prod (beta_l l \\<cdot>\\<^sub>v \\<beta>) (psi_l l) =\n    inner_prod (beta_l l \\<cdot>\\<^sub>v \\<beta>)\n     (alpha_l l \\<cdot>\\<^sub>v \\<alpha>) +\n    inner_prod (beta_l l \\<cdot>\\<^sub>v \\<beta>)\n     (beta_l l \\<cdot>\\<^sub>v \\<beta>)", "unfolding psi_l_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. inner_prod (beta_l l \\<cdot>\\<^sub>v \\<beta>)\n     (alpha_l l \\<cdot>\\<^sub>v \\<alpha> +\n      beta_l l \\<cdot>\\<^sub>v \\<beta>) =\n    inner_prod (beta_l l \\<cdot>\\<^sub>v \\<beta>)\n     (alpha_l l \\<cdot>\\<^sub>v \\<alpha>) +\n    inner_prod (beta_l l \\<cdot>\\<^sub>v \\<beta>)\n     (beta_l l \\<cdot>\\<^sub>v \\<beta>)", "apply (subst inner_prod_distrib_right)"], ["proof (prove)\ngoal (3 subgoals):\n 1. beta_l l \\<cdot>\\<^sub>v \\<beta> \\<in> carrier_vec ?n\n 2. alpha_l l \\<cdot>\\<^sub>v \\<alpha> \\<in> carrier_vec ?n\n 3. inner_prod (beta_l l \\<cdot>\\<^sub>v \\<beta>)\n     (alpha_l l \\<cdot>\\<^sub>v \\<alpha>) +\n    inner_prod (beta_l l \\<cdot>\\<^sub>v \\<beta>)\n     (beta_l l \\<cdot>\\<^sub>v \\<beta>) =\n    inner_prod (beta_l l \\<cdot>\\<^sub>v \\<beta>)\n     (alpha_l l \\<cdot>\\<^sub>v \\<alpha>) +\n    inner_prod (beta_l l \\<cdot>\\<^sub>v \\<beta>)\n     (beta_l l \\<cdot>\\<^sub>v \\<beta>)", "using \\<alpha>_def \\<beta>_def"], ["proof (prove)\nusing this:\n  \\<alpha> =\n  Matrix.vec N\n   (\\<lambda>x.\n       complex_of_real (if f x then 0 else 1 / sqrt (real (N - M))))\n  \\<beta> =\n  Matrix.vec N\n   (\\<lambda>x. complex_of_real (if f x then 1 / sqrt (real M) else 0))\n\ngoal (3 subgoals):\n 1. beta_l l \\<cdot>\\<^sub>v \\<beta> \\<in> carrier_vec ?n\n 2. alpha_l l \\<cdot>\\<^sub>v \\<alpha> \\<in> carrier_vec ?n\n 3. inner_prod (beta_l l \\<cdot>\\<^sub>v \\<beta>)\n     (alpha_l l \\<cdot>\\<^sub>v \\<alpha>) +\n    inner_prod (beta_l l \\<cdot>\\<^sub>v \\<beta>)\n     (beta_l l \\<cdot>\\<^sub>v \\<beta>) =\n    inner_prod (beta_l l \\<cdot>\\<^sub>v \\<beta>)\n     (alpha_l l \\<cdot>\\<^sub>v \\<alpha>) +\n    inner_prod (beta_l l \\<cdot>\\<^sub>v \\<beta>)\n     (beta_l l \\<cdot>\\<^sub>v \\<beta>)", "by auto"], ["proof (state)\nthis:\n  inner_prod (beta_l l \\<cdot>\\<^sub>v \\<beta>) (psi_l l) =\n  inner_prod (beta_l l \\<cdot>\\<^sub>v \\<beta>)\n   (alpha_l l \\<cdot>\\<^sub>v \\<alpha>) +\n  inner_prod (beta_l l \\<cdot>\\<^sub>v \\<beta>)\n   (beta_l l \\<cdot>\\<^sub>v \\<beta>)\n\ngoal (1 subgoal):\n 1. inner_prod (psi_l l) (psi_l l) = 1", "also"], ["proof (state)\nthis:\n  inner_prod (beta_l l \\<cdot>\\<^sub>v \\<beta>) (psi_l l) =\n  inner_prod (beta_l l \\<cdot>\\<^sub>v \\<beta>)\n   (alpha_l l \\<cdot>\\<^sub>v \\<alpha>) +\n  inner_prod (beta_l l \\<cdot>\\<^sub>v \\<beta>)\n   (beta_l l \\<cdot>\\<^sub>v \\<beta>)\n\ngoal (1 subgoal):\n 1. inner_prod (psi_l l) (psi_l l) = 1", "have \"\\<dots> = (conjugate (beta_l l)) * (alpha_l l) * inner_prod \\<beta> \\<alpha> \n                + (conjugate (beta_l l)) * (beta_l l) * inner_prod \\<beta> \\<beta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inner_prod (beta_l l \\<cdot>\\<^sub>v \\<beta>)\n     (alpha_l l \\<cdot>\\<^sub>v \\<alpha>) +\n    inner_prod (beta_l l \\<cdot>\\<^sub>v \\<beta>)\n     (beta_l l \\<cdot>\\<^sub>v \\<beta>) =\n    conjugate (beta_l l) * alpha_l l * inner_prod \\<beta> \\<alpha> +\n    conjugate (beta_l l) * beta_l l * inner_prod \\<beta> \\<beta>", "apply (subst (1 2) inner_prod_smult_left_right)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<beta> \\<in> carrier_vec ?n\n 2. \\<beta> \\<in> carrier_vec ?n1\n 3. \\<alpha> \\<in> carrier_vec ?n1\n 4. conjugate (beta_l l) * alpha_l l * inner_prod \\<beta> \\<alpha> +\n    conjugate (beta_l l) * beta_l l * inner_prod \\<beta> \\<beta> =\n    conjugate (beta_l l) * alpha_l l * inner_prod \\<beta> \\<alpha> +\n    conjugate (beta_l l) * beta_l l * inner_prod \\<beta> \\<beta>", "using \\<alpha>_def \\<beta>_def"], ["proof (prove)\nusing this:\n  \\<alpha> =\n  Matrix.vec N\n   (\\<lambda>x.\n       complex_of_real (if f x then 0 else 1 / sqrt (real (N - M))))\n  \\<beta> =\n  Matrix.vec N\n   (\\<lambda>x. complex_of_real (if f x then 1 / sqrt (real M) else 0))\n\ngoal (4 subgoals):\n 1. \\<beta> \\<in> carrier_vec ?n\n 2. \\<beta> \\<in> carrier_vec ?n1\n 3. \\<alpha> \\<in> carrier_vec ?n1\n 4. conjugate (beta_l l) * alpha_l l * inner_prod \\<beta> \\<alpha> +\n    conjugate (beta_l l) * beta_l l * inner_prod \\<beta> \\<beta> =\n    conjugate (beta_l l) * alpha_l l * inner_prod \\<beta> \\<alpha> +\n    conjugate (beta_l l) * beta_l l * inner_prod \\<beta> \\<beta>", "by auto"], ["proof (state)\nthis:\n  inner_prod (beta_l l \\<cdot>\\<^sub>v \\<beta>)\n   (alpha_l l \\<cdot>\\<^sub>v \\<alpha>) +\n  inner_prod (beta_l l \\<cdot>\\<^sub>v \\<beta>)\n   (beta_l l \\<cdot>\\<^sub>v \\<beta>) =\n  conjugate (beta_l l) * alpha_l l * inner_prod \\<beta> \\<alpha> +\n  conjugate (beta_l l) * beta_l l * inner_prod \\<beta> \\<beta>\n\ngoal (1 subgoal):\n 1. inner_prod (psi_l l) (psi_l l) = 1", "also"], ["proof (state)\nthis:\n  inner_prod (beta_l l \\<cdot>\\<^sub>v \\<beta>)\n   (alpha_l l \\<cdot>\\<^sub>v \\<alpha>) +\n  inner_prod (beta_l l \\<cdot>\\<^sub>v \\<beta>)\n   (beta_l l \\<cdot>\\<^sub>v \\<beta>) =\n  conjugate (beta_l l) * alpha_l l * inner_prod \\<beta> \\<alpha> +\n  conjugate (beta_l l) * beta_l l * inner_prod \\<beta> \\<beta>\n\ngoal (1 subgoal):\n 1. inner_prod (psi_l l) (psi_l l) = 1", "have \"\\<dots> = (conjugate (beta_l l)) * (beta_l l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. conjugate (beta_l l) * alpha_l l * inner_prod \\<beta> \\<alpha> +\n    conjugate (beta_l l) * beta_l l * inner_prod \\<beta> \\<beta> =\n    conjugate (beta_l l) * beta_l l", "using \\<beta>_inner beta_alpha_orth"], ["proof (prove)\nusing this:\n  inner_prod \\<beta> \\<beta> = 1\n  inner_prod \\<beta> \\<alpha> = 0\n\ngoal (1 subgoal):\n 1. conjugate (beta_l l) * alpha_l l * inner_prod \\<beta> \\<alpha> +\n    conjugate (beta_l l) * beta_l l * inner_prod \\<beta> \\<beta> =\n    conjugate (beta_l l) * beta_l l", "by auto"], ["proof (state)\nthis:\n  conjugate (beta_l l) * alpha_l l * inner_prod \\<beta> \\<alpha> +\n  conjugate (beta_l l) * beta_l l * inner_prod \\<beta> \\<beta> =\n  conjugate (beta_l l) * beta_l l\n\ngoal (1 subgoal):\n 1. inner_prod (psi_l l) (psi_l l) = 1", "also"], ["proof (state)\nthis:\n  conjugate (beta_l l) * alpha_l l * inner_prod \\<beta> \\<alpha> +\n  conjugate (beta_l l) * beta_l l * inner_prod \\<beta> \\<beta> =\n  conjugate (beta_l l) * beta_l l\n\ngoal (1 subgoal):\n 1. inner_prod (psi_l l) (psi_l l) = 1", "have \"\\<dots> = (beta_l l) * (beta_l l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. conjugate (beta_l l) * beta_l l = beta_l l * beta_l l", "using cnj_beta_l"], ["proof (prove)\nusing this:\n  conjugate (beta_l ?l) = beta_l ?l\n\ngoal (1 subgoal):\n 1. conjugate (beta_l l) * beta_l l = beta_l l * beta_l l", "by auto"], ["proof (state)\nthis:\n  conjugate (beta_l l) * beta_l l = beta_l l * beta_l l\n\ngoal (1 subgoal):\n 1. inner_prod (psi_l l) (psi_l l) = 1", "finally"], ["proof (chain)\npicking this:\n  inner_prod (beta_l l \\<cdot>\\<^sub>v \\<beta>) (psi_l l) =\n  beta_l l * beta_l l", "have eq2: \"inner_prod (beta_l l \\<cdot>\\<^sub>v \\<beta>) (psi_l l) = beta_l l * beta_l l\""], ["proof (prove)\nusing this:\n  inner_prod (beta_l l \\<cdot>\\<^sub>v \\<beta>) (psi_l l) =\n  beta_l l * beta_l l\n\ngoal (1 subgoal):\n 1. inner_prod (beta_l l \\<cdot>\\<^sub>v \\<beta>) (psi_l l) =\n    beta_l l * beta_l l", "."], ["proof (state)\nthis:\n  inner_prod (beta_l l \\<cdot>\\<^sub>v \\<beta>) (psi_l l) =\n  beta_l l * beta_l l\n\ngoal (1 subgoal):\n 1. inner_prod (psi_l l) (psi_l l) = 1", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. inner_prod (psi_l l) (psi_l l) = 1", "unfolding eq0 eq1 eq2"], ["proof (prove)\ngoal (1 subgoal):\n 1. alpha_l l * alpha_l l + beta_l l * beta_l l = 1", "using alpha_l_beta_l_add_norm"], ["proof (prove)\nusing this:\n  alpha_l ?l * alpha_l ?l + beta_l ?l * beta_l ?l = 1\n\ngoal (1 subgoal):\n 1. alpha_l l * alpha_l l + beta_l l * beta_l l = 1", "by auto"], ["proof (state)\nthis:\n  inner_prod (psi_l l) (psi_l l) = 1\n\ngoal:\nNo subgoals!", "qed"], ["", "abbreviation proj :: \"complex vec \\<Rightarrow> complex mat\" where\n  \"proj v \\<equiv> outer_prod v v\""], ["", "definition psi'_l where\n  \"psi'_l l = (alpha_l l) \\<cdot>\\<^sub>v \\<alpha> - (beta_l l) \\<cdot>\\<^sub>v \\<beta>\""], ["", "lemma psi'_l_dim:\n  \"psi'_l l \\<in> carrier_vec N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. psi'_l l \\<in> carrier_vec N", "unfolding psi'_l_def \\<alpha>_def \\<beta>_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. alpha_l l \\<cdot>\\<^sub>v\n    Matrix.vec N\n     (\\<lambda>x.\n         complex_of_real (if f x then 0 else 1 / sqrt (real (N - M)))) -\n    beta_l l \\<cdot>\\<^sub>v\n    Matrix.vec N\n     (\\<lambda>x. complex_of_real (if f x then 1 / sqrt (real M) else 0))\n    \\<in> carrier_vec N", "by auto"], ["", "definition proj_psi'_l where\n  \"proj_psi'_l l = proj (psi'_l l)\""], ["", "lemma proj_psi'_dim:\n  \"proj_psi'_l l \\<in> carrier_mat N N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proj_psi'_l l \\<in> carrier_mat N N", "unfolding proj_psi'_l_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. outer_prod (psi'_l l) (psi'_l l) \\<in> carrier_mat N N", "using psi'_l_dim"], ["proof (prove)\nusing this:\n  psi'_l ?l \\<in> carrier_vec N\n\ngoal (1 subgoal):\n 1. outer_prod (psi'_l l) (psi'_l l) \\<in> carrier_mat N N", "by auto"], ["", "lemma psi_inner_psi'_l:\n  \"inner_prod \\<psi> (psi'_l l) = (alpha_l l * ccos (\\<theta> / 2) - beta_l l * csin (\\<theta> / 2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inner_prod \\<psi> (psi'_l l) =\n    alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n    beta_l l * complex_of_real (sin (\\<theta> / 2))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. inner_prod \\<psi> (psi'_l l) =\n    alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n    beta_l l * complex_of_real (sin (\\<theta> / 2))", "have \"inner_prod \\<psi> (psi'_l l) = inner_prod \\<psi> (alpha_l l \\<cdot>\\<^sub>v \\<alpha>) - inner_prod \\<psi> (beta_l l \\<cdot>\\<^sub>v \\<beta>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inner_prod \\<psi> (psi'_l l) =\n    inner_prod \\<psi> (alpha_l l \\<cdot>\\<^sub>v \\<alpha>) -\n    inner_prod \\<psi> (beta_l l \\<cdot>\\<^sub>v \\<beta>)", "unfolding psi'_l_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. inner_prod \\<psi>\n     (alpha_l l \\<cdot>\\<^sub>v \\<alpha> -\n      beta_l l \\<cdot>\\<^sub>v \\<beta>) =\n    inner_prod \\<psi> (alpha_l l \\<cdot>\\<^sub>v \\<alpha>) -\n    inner_prod \\<psi> (beta_l l \\<cdot>\\<^sub>v \\<beta>)", "apply (subst inner_prod_minus_distrib_right[of _ N])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<psi> \\<in> carrier_vec N\n 2. alpha_l l \\<cdot>\\<^sub>v \\<alpha> \\<in> carrier_vec N\n 3. beta_l l \\<cdot>\\<^sub>v \\<beta> \\<in> carrier_vec N\n 4. inner_prod \\<psi> (alpha_l l \\<cdot>\\<^sub>v \\<alpha>) -\n    inner_prod \\<psi> (beta_l l \\<cdot>\\<^sub>v \\<beta>) =\n    inner_prod \\<psi> (alpha_l l \\<cdot>\\<^sub>v \\<alpha>) -\n    inner_prod \\<psi> (beta_l l \\<cdot>\\<^sub>v \\<beta>)", "by auto"], ["proof (state)\nthis:\n  inner_prod \\<psi> (psi'_l l) =\n  inner_prod \\<psi> (alpha_l l \\<cdot>\\<^sub>v \\<alpha>) -\n  inner_prod \\<psi> (beta_l l \\<cdot>\\<^sub>v \\<beta>)\n\ngoal (1 subgoal):\n 1. inner_prod \\<psi> (psi'_l l) =\n    alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n    beta_l l * complex_of_real (sin (\\<theta> / 2))", "also"], ["proof (state)\nthis:\n  inner_prod \\<psi> (psi'_l l) =\n  inner_prod \\<psi> (alpha_l l \\<cdot>\\<^sub>v \\<alpha>) -\n  inner_prod \\<psi> (beta_l l \\<cdot>\\<^sub>v \\<beta>)\n\ngoal (1 subgoal):\n 1. inner_prod \\<psi> (psi'_l l) =\n    alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n    beta_l l * complex_of_real (sin (\\<theta> / 2))", "have \"\\<dots> = alpha_l l * (inner_prod \\<psi> \\<alpha>) - beta_l l * (inner_prod \\<psi> \\<beta>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inner_prod \\<psi> (alpha_l l \\<cdot>\\<^sub>v \\<alpha>) -\n    inner_prod \\<psi> (beta_l l \\<cdot>\\<^sub>v \\<beta>) =\n    alpha_l l * inner_prod \\<psi> \\<alpha> -\n    beta_l l * inner_prod \\<psi> \\<beta>", "using \\<psi>_dim \\<alpha>_dim \\<beta>_dim"], ["proof (prove)\nusing this:\n  \\<psi> \\<in> carrier_vec N\n  dim_vec \\<psi> = N\n  \\<alpha> \\<in> carrier_vec N\n  dim_vec \\<alpha> = N\n  \\<beta> \\<in> carrier_vec N\n  dim_vec \\<beta> = N\n\ngoal (1 subgoal):\n 1. inner_prod \\<psi> (alpha_l l \\<cdot>\\<^sub>v \\<alpha>) -\n    inner_prod \\<psi> (beta_l l \\<cdot>\\<^sub>v \\<beta>) =\n    alpha_l l * inner_prod \\<psi> \\<alpha> -\n    beta_l l * inner_prod \\<psi> \\<beta>", "by auto"], ["proof (state)\nthis:\n  inner_prod \\<psi> (alpha_l l \\<cdot>\\<^sub>v \\<alpha>) -\n  inner_prod \\<psi> (beta_l l \\<cdot>\\<^sub>v \\<beta>) =\n  alpha_l l * inner_prod \\<psi> \\<alpha> -\n  beta_l l * inner_prod \\<psi> \\<beta>\n\ngoal (1 subgoal):\n 1. inner_prod \\<psi> (psi'_l l) =\n    alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n    beta_l l * complex_of_real (sin (\\<theta> / 2))", "also"], ["proof (state)\nthis:\n  inner_prod \\<psi> (alpha_l l \\<cdot>\\<^sub>v \\<alpha>) -\n  inner_prod \\<psi> (beta_l l \\<cdot>\\<^sub>v \\<beta>) =\n  alpha_l l * inner_prod \\<psi> \\<alpha> -\n  beta_l l * inner_prod \\<psi> \\<beta>\n\ngoal (1 subgoal):\n 1. inner_prod \\<psi> (psi'_l l) =\n    alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n    beta_l l * complex_of_real (sin (\\<theta> / 2))", "have \"\\<dots> = alpha_l l * (ccos (\\<theta> / 2)) - beta_l l * (csin (\\<theta> / 2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. alpha_l l * inner_prod \\<psi> \\<alpha> -\n    beta_l l * inner_prod \\<psi> \\<beta> =\n    alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n    beta_l l * complex_of_real (sin (\\<theta> / 2))", "using psi_inner_alpha psi_inner_beta"], ["proof (prove)\nusing this:\n  inner_prod \\<psi> \\<alpha> = complex_of_real (cos (\\<theta> / 2))\n  inner_prod \\<psi> \\<beta> = complex_of_real (sin (\\<theta> / 2))\n\ngoal (1 subgoal):\n 1. alpha_l l * inner_prod \\<psi> \\<alpha> -\n    beta_l l * inner_prod \\<psi> \\<beta> =\n    alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n    beta_l l * complex_of_real (sin (\\<theta> / 2))", "by auto"], ["proof (state)\nthis:\n  alpha_l l * inner_prod \\<psi> \\<alpha> -\n  beta_l l * inner_prod \\<psi> \\<beta> =\n  alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n  beta_l l * complex_of_real (sin (\\<theta> / 2))\n\ngoal (1 subgoal):\n 1. inner_prod \\<psi> (psi'_l l) =\n    alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n    beta_l l * complex_of_real (sin (\\<theta> / 2))", "finally"], ["proof (chain)\npicking this:\n  inner_prod \\<psi> (psi'_l l) =\n  alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n  beta_l l * complex_of_real (sin (\\<theta> / 2))", "show ?thesis"], ["proof (prove)\nusing this:\n  inner_prod \\<psi> (psi'_l l) =\n  alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n  beta_l l * complex_of_real (sin (\\<theta> / 2))\n\ngoal (1 subgoal):\n 1. inner_prod \\<psi> (psi'_l l) =\n    alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n    beta_l l * complex_of_real (sin (\\<theta> / 2))", "by auto"], ["proof (state)\nthis:\n  inner_prod \\<psi> (psi'_l l) =\n  alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n  beta_l l * complex_of_real (sin (\\<theta> / 2))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma double_ccos_square:\n  \"2 * ccos (a::real) * ccos a = ccos (2 * a) + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * complex_of_real (cos a) * complex_of_real (cos a) =\n    complex_of_real (cos (2 * a)) + 1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. 2 * complex_of_real (cos a) * complex_of_real (cos a) =\n    complex_of_real (cos (2 * a)) + 1", "have eq: \"ccos (2 * a) = ccos a * ccos a - csin a * csin a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. complex_of_real (cos (2 * a)) =\n    complex_of_real (cos a) * complex_of_real (cos a) -\n    complex_of_real (sin a) * complex_of_real (sin a)", "using cos_add[of a a]"], ["proof (prove)\nusing this:\n  cos (a + a) = cos a * cos a - sin a * sin a\n\ngoal (1 subgoal):\n 1. complex_of_real (cos (2 * a)) =\n    complex_of_real (cos a) * complex_of_real (cos a) -\n    complex_of_real (sin a) * complex_of_real (sin a)", "by auto"], ["proof (state)\nthis:\n  complex_of_real (cos (2 * a)) =\n  complex_of_real (cos a) * complex_of_real (cos a) -\n  complex_of_real (sin a) * complex_of_real (sin a)\n\ngoal (1 subgoal):\n 1. 2 * complex_of_real (cos a) * complex_of_real (cos a) =\n    complex_of_real (cos (2 * a)) + 1", "have \"csin a * csin a = 1 - ccos a * ccos a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. complex_of_real (sin a) * complex_of_real (sin a) =\n    1 - complex_of_real (cos a) * complex_of_real (cos a)", "using csin_ccos_squared_add[of a]"], ["proof (prove)\nusing this:\n  complex_of_real (cos a) * complex_of_real (cos a) +\n  complex_of_real (sin a) * complex_of_real (sin a) =\n  1\n\ngoal (1 subgoal):\n 1. complex_of_real (sin a) * complex_of_real (sin a) =\n    1 - complex_of_real (cos a) * complex_of_real (cos a)", "by (metis add_diff_cancel_left')"], ["proof (state)\nthis:\n  complex_of_real (sin a) * complex_of_real (sin a) =\n  1 - complex_of_real (cos a) * complex_of_real (cos a)\n\ngoal (1 subgoal):\n 1. 2 * complex_of_real (cos a) * complex_of_real (cos a) =\n    complex_of_real (cos (2 * a)) + 1", "then"], ["proof (chain)\npicking this:\n  complex_of_real (sin a) * complex_of_real (sin a) =\n  1 - complex_of_real (cos a) * complex_of_real (cos a)", "have \"ccos a * ccos a - csin a * csin a = 2 * ccos a * ccos a - 1\""], ["proof (prove)\nusing this:\n  complex_of_real (sin a) * complex_of_real (sin a) =\n  1 - complex_of_real (cos a) * complex_of_real (cos a)\n\ngoal (1 subgoal):\n 1. complex_of_real (cos a) * complex_of_real (cos a) -\n    complex_of_real (sin a) * complex_of_real (sin a) =\n    2 * complex_of_real (cos a) * complex_of_real (cos a) - 1", "by simp"], ["proof (state)\nthis:\n  complex_of_real (cos a) * complex_of_real (cos a) -\n  complex_of_real (sin a) * complex_of_real (sin a) =\n  2 * complex_of_real (cos a) * complex_of_real (cos a) - 1\n\ngoal (1 subgoal):\n 1. 2 * complex_of_real (cos a) * complex_of_real (cos a) =\n    complex_of_real (cos (2 * a)) + 1", "with eq"], ["proof (chain)\npicking this:\n  complex_of_real (cos (2 * a)) =\n  complex_of_real (cos a) * complex_of_real (cos a) -\n  complex_of_real (sin a) * complex_of_real (sin a)\n  complex_of_real (cos a) * complex_of_real (cos a) -\n  complex_of_real (sin a) * complex_of_real (sin a) =\n  2 * complex_of_real (cos a) * complex_of_real (cos a) - 1", "show ?thesis"], ["proof (prove)\nusing this:\n  complex_of_real (cos (2 * a)) =\n  complex_of_real (cos a) * complex_of_real (cos a) -\n  complex_of_real (sin a) * complex_of_real (sin a)\n  complex_of_real (cos a) * complex_of_real (cos a) -\n  complex_of_real (sin a) * complex_of_real (sin a) =\n  2 * complex_of_real (cos a) * complex_of_real (cos a) - 1\n\ngoal (1 subgoal):\n 1. 2 * complex_of_real (cos a) * complex_of_real (cos a) =\n    complex_of_real (cos (2 * a)) + 1", "by simp"], ["proof (state)\nthis:\n  2 * complex_of_real (cos a) * complex_of_real (cos a) =\n  complex_of_real (cos (2 * a)) + 1\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma double_csin_square:\n  \"2 * csin (a::real) * csin a = 1 - ccos (2 * a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * complex_of_real (sin a) * complex_of_real (sin a) =\n    1 - complex_of_real (cos (2 * a))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. 2 * complex_of_real (sin a) * complex_of_real (sin a) =\n    1 - complex_of_real (cos (2 * a))", "have eq: \"ccos (2 * a) = ccos a * ccos a - csin a * csin a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. complex_of_real (cos (2 * a)) =\n    complex_of_real (cos a) * complex_of_real (cos a) -\n    complex_of_real (sin a) * complex_of_real (sin a)", "using cos_add[of a a]"], ["proof (prove)\nusing this:\n  cos (a + a) = cos a * cos a - sin a * sin a\n\ngoal (1 subgoal):\n 1. complex_of_real (cos (2 * a)) =\n    complex_of_real (cos a) * complex_of_real (cos a) -\n    complex_of_real (sin a) * complex_of_real (sin a)", "by auto"], ["proof (state)\nthis:\n  complex_of_real (cos (2 * a)) =\n  complex_of_real (cos a) * complex_of_real (cos a) -\n  complex_of_real (sin a) * complex_of_real (sin a)\n\ngoal (1 subgoal):\n 1. 2 * complex_of_real (sin a) * complex_of_real (sin a) =\n    1 - complex_of_real (cos (2 * a))", "have \"ccos a * ccos a = 1 - csin a * csin a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. complex_of_real (cos a) * complex_of_real (cos a) =\n    1 - complex_of_real (sin a) * complex_of_real (sin a)", "using csin_ccos_squared_add[of a]"], ["proof (prove)\nusing this:\n  complex_of_real (cos a) * complex_of_real (cos a) +\n  complex_of_real (sin a) * complex_of_real (sin a) =\n  1\n\ngoal (1 subgoal):\n 1. complex_of_real (cos a) * complex_of_real (cos a) =\n    1 - complex_of_real (sin a) * complex_of_real (sin a)", "by (auto intro: add_implies_diff)"], ["proof (state)\nthis:\n  complex_of_real (cos a) * complex_of_real (cos a) =\n  1 - complex_of_real (sin a) * complex_of_real (sin a)\n\ngoal (1 subgoal):\n 1. 2 * complex_of_real (sin a) * complex_of_real (sin a) =\n    1 - complex_of_real (cos (2 * a))", "then"], ["proof (chain)\npicking this:\n  complex_of_real (cos a) * complex_of_real (cos a) =\n  1 - complex_of_real (sin a) * complex_of_real (sin a)", "have \"ccos a * ccos a - csin a * csin a = 1 - 2 * csin (a::real) * csin a\""], ["proof (prove)\nusing this:\n  complex_of_real (cos a) * complex_of_real (cos a) =\n  1 - complex_of_real (sin a) * complex_of_real (sin a)\n\ngoal (1 subgoal):\n 1. complex_of_real (cos a) * complex_of_real (cos a) -\n    complex_of_real (sin a) * complex_of_real (sin a) =\n    1 - 2 * complex_of_real (sin a) * complex_of_real (sin a)", "by simp"], ["proof (state)\nthis:\n  complex_of_real (cos a) * complex_of_real (cos a) -\n  complex_of_real (sin a) * complex_of_real (sin a) =\n  1 - 2 * complex_of_real (sin a) * complex_of_real (sin a)\n\ngoal (1 subgoal):\n 1. 2 * complex_of_real (sin a) * complex_of_real (sin a) =\n    1 - complex_of_real (cos (2 * a))", "with eq"], ["proof (chain)\npicking this:\n  complex_of_real (cos (2 * a)) =\n  complex_of_real (cos a) * complex_of_real (cos a) -\n  complex_of_real (sin a) * complex_of_real (sin a)\n  complex_of_real (cos a) * complex_of_real (cos a) -\n  complex_of_real (sin a) * complex_of_real (sin a) =\n  1 - 2 * complex_of_real (sin a) * complex_of_real (sin a)", "show ?thesis"], ["proof (prove)\nusing this:\n  complex_of_real (cos (2 * a)) =\n  complex_of_real (cos a) * complex_of_real (cos a) -\n  complex_of_real (sin a) * complex_of_real (sin a)\n  complex_of_real (cos a) * complex_of_real (cos a) -\n  complex_of_real (sin a) * complex_of_real (sin a) =\n  1 - 2 * complex_of_real (sin a) * complex_of_real (sin a)\n\ngoal (1 subgoal):\n 1. 2 * complex_of_real (sin a) * complex_of_real (sin a) =\n    1 - complex_of_real (cos (2 * a))", "by simp"], ["proof (state)\nthis:\n  2 * complex_of_real (sin a) * complex_of_real (sin a) =\n  1 - complex_of_real (cos (2 * a))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma csin_double:\n  \"2 * csin (a::real) * ccos a = csin(2 * a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * complex_of_real (sin a) * complex_of_real (cos a) =\n    complex_of_real (sin (2 * a))", "using sin_add[of a a]"], ["proof (prove)\nusing this:\n  sin (a + a) = sin a * cos a + cos a * sin a\n\ngoal (1 subgoal):\n 1. 2 * complex_of_real (sin a) * complex_of_real (cos a) =\n    complex_of_real (sin (2 * a))", "by simp"], ["", "lemma ccos_add:\n  \"ccos (x + y) = ccos x * ccos y - csin x * csin y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. complex_of_real (cos (x + y)) =\n    complex_of_real (cos x) * complex_of_real (cos y) -\n    complex_of_real (sin x) * complex_of_real (sin y)", "using cos_add[of x y]"], ["proof (prove)\nusing this:\n  cos (x + y) = cos x * cos y - sin x * sin y\n\ngoal (1 subgoal):\n 1. complex_of_real (cos (x + y)) =\n    complex_of_real (cos x) * complex_of_real (cos y) -\n    complex_of_real (sin x) * complex_of_real (sin y)", "by simp"], ["", "lemma alpha_l_Suc_l_derive:\n  \"2 * (alpha_l l * ccos (\\<theta> / 2) - beta_l l * csin (\\<theta> / 2)) * ccos (\\<theta> / 2) - alpha_l l = alpha_l (l + 1)\"\n  (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 *\n    (alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n     beta_l l * complex_of_real (sin (\\<theta> / 2))) *\n    complex_of_real (cos (\\<theta> / 2)) -\n    alpha_l l =\n    alpha_l (l + 1)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. 2 *\n    (alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n     beta_l l * complex_of_real (sin (\\<theta> / 2))) *\n    complex_of_real (cos (\\<theta> / 2)) -\n    alpha_l l =\n    alpha_l (l + 1)", "have \"2 * ((alpha_l l) * ccos (\\<theta> / 2) - (beta_l l) * csin (\\<theta> / 2)) * ccos (\\<theta> / 2)\n    = (alpha_l l) * (2 * ccos (\\<theta> / 2)* ccos (\\<theta> / 2)) - (beta_l l) * (2 * csin (\\<theta> / 2) * ccos (\\<theta> / 2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 *\n    (alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n     beta_l l * complex_of_real (sin (\\<theta> / 2))) *\n    complex_of_real (cos (\\<theta> / 2)) =\n    alpha_l l *\n    (2 * complex_of_real (cos (\\<theta> / 2)) *\n     complex_of_real (cos (\\<theta> / 2))) -\n    beta_l l *\n    (2 * complex_of_real (sin (\\<theta> / 2)) *\n     complex_of_real (cos (\\<theta> / 2)))", "by (simp add: left_diff_distrib)"], ["proof (state)\nthis:\n  2 *\n  (alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n   beta_l l * complex_of_real (sin (\\<theta> / 2))) *\n  complex_of_real (cos (\\<theta> / 2)) =\n  alpha_l l *\n  (2 * complex_of_real (cos (\\<theta> / 2)) *\n   complex_of_real (cos (\\<theta> / 2))) -\n  beta_l l *\n  (2 * complex_of_real (sin (\\<theta> / 2)) *\n   complex_of_real (cos (\\<theta> / 2)))\n\ngoal (1 subgoal):\n 1. 2 *\n    (alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n     beta_l l * complex_of_real (sin (\\<theta> / 2))) *\n    complex_of_real (cos (\\<theta> / 2)) -\n    alpha_l l =\n    alpha_l (l + 1)", "also"], ["proof (state)\nthis:\n  2 *\n  (alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n   beta_l l * complex_of_real (sin (\\<theta> / 2))) *\n  complex_of_real (cos (\\<theta> / 2)) =\n  alpha_l l *\n  (2 * complex_of_real (cos (\\<theta> / 2)) *\n   complex_of_real (cos (\\<theta> / 2))) -\n  beta_l l *\n  (2 * complex_of_real (sin (\\<theta> / 2)) *\n   complex_of_real (cos (\\<theta> / 2)))\n\ngoal (1 subgoal):\n 1. 2 *\n    (alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n     beta_l l * complex_of_real (sin (\\<theta> / 2))) *\n    complex_of_real (cos (\\<theta> / 2)) -\n    alpha_l l =\n    alpha_l (l + 1)", "have \"\\<dots> = (alpha_l l) * (ccos (\\<theta>) + 1) - (beta_l l) * csin \\<theta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. alpha_l l *\n    (2 * complex_of_real (cos (\\<theta> / 2)) *\n     complex_of_real (cos (\\<theta> / 2))) -\n    beta_l l *\n    (2 * complex_of_real (sin (\\<theta> / 2)) *\n     complex_of_real (cos (\\<theta> / 2))) =\n    alpha_l l * (complex_of_real (cos \\<theta>) + 1) -\n    beta_l l * complex_of_real (sin \\<theta>)", "using double_ccos_square csin_double"], ["proof (prove)\nusing this:\n  2 * complex_of_real (cos ?a) * complex_of_real (cos ?a) =\n  complex_of_real (cos (2 * ?a)) + 1\n  2 * complex_of_real (sin ?a) * complex_of_real (cos ?a) =\n  complex_of_real (sin (2 * ?a))\n\ngoal (1 subgoal):\n 1. alpha_l l *\n    (2 * complex_of_real (cos (\\<theta> / 2)) *\n     complex_of_real (cos (\\<theta> / 2))) -\n    beta_l l *\n    (2 * complex_of_real (sin (\\<theta> / 2)) *\n     complex_of_real (cos (\\<theta> / 2))) =\n    alpha_l l * (complex_of_real (cos \\<theta>) + 1) -\n    beta_l l * complex_of_real (sin \\<theta>)", "by auto"], ["proof (state)\nthis:\n  alpha_l l *\n  (2 * complex_of_real (cos (\\<theta> / 2)) *\n   complex_of_real (cos (\\<theta> / 2))) -\n  beta_l l *\n  (2 * complex_of_real (sin (\\<theta> / 2)) *\n   complex_of_real (cos (\\<theta> / 2))) =\n  alpha_l l * (complex_of_real (cos \\<theta>) + 1) -\n  beta_l l * complex_of_real (sin \\<theta>)\n\ngoal (1 subgoal):\n 1. 2 *\n    (alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n     beta_l l * complex_of_real (sin (\\<theta> / 2))) *\n    complex_of_real (cos (\\<theta> / 2)) -\n    alpha_l l =\n    alpha_l (l + 1)", "finally"], ["proof (chain)\npicking this:\n  2 *\n  (alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n   beta_l l * complex_of_real (sin (\\<theta> / 2))) *\n  complex_of_real (cos (\\<theta> / 2)) =\n  alpha_l l * (complex_of_real (cos \\<theta>) + 1) -\n  beta_l l * complex_of_real (sin \\<theta>)", "have \"2 * ((alpha_l l) * ccos (\\<theta> / 2) - (beta_l l) * csin (\\<theta> / 2)) * ccos (\\<theta> / 2) \n    = (alpha_l l) * (ccos (\\<theta>) + 1) - (beta_l l) * csin \\<theta>\""], ["proof (prove)\nusing this:\n  2 *\n  (alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n   beta_l l * complex_of_real (sin (\\<theta> / 2))) *\n  complex_of_real (cos (\\<theta> / 2)) =\n  alpha_l l * (complex_of_real (cos \\<theta>) + 1) -\n  beta_l l * complex_of_real (sin \\<theta>)\n\ngoal (1 subgoal):\n 1. 2 *\n    (alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n     beta_l l * complex_of_real (sin (\\<theta> / 2))) *\n    complex_of_real (cos (\\<theta> / 2)) =\n    alpha_l l * (complex_of_real (cos \\<theta>) + 1) -\n    beta_l l * complex_of_real (sin \\<theta>)", "."], ["proof (state)\nthis:\n  2 *\n  (alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n   beta_l l * complex_of_real (sin (\\<theta> / 2))) *\n  complex_of_real (cos (\\<theta> / 2)) =\n  alpha_l l * (complex_of_real (cos \\<theta>) + 1) -\n  beta_l l * complex_of_real (sin \\<theta>)\n\ngoal (1 subgoal):\n 1. 2 *\n    (alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n     beta_l l * complex_of_real (sin (\\<theta> / 2))) *\n    complex_of_real (cos (\\<theta> / 2)) -\n    alpha_l l =\n    alpha_l (l + 1)", "then"], ["proof (chain)\npicking this:\n  2 *\n  (alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n   beta_l l * complex_of_real (sin (\\<theta> / 2))) *\n  complex_of_real (cos (\\<theta> / 2)) =\n  alpha_l l * (complex_of_real (cos \\<theta>) + 1) -\n  beta_l l * complex_of_real (sin \\<theta>)", "have \"?lhs = (alpha_l l) * ccos (\\<theta>) - (beta_l l) * csin \\<theta>\""], ["proof (prove)\nusing this:\n  2 *\n  (alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n   beta_l l * complex_of_real (sin (\\<theta> / 2))) *\n  complex_of_real (cos (\\<theta> / 2)) =\n  alpha_l l * (complex_of_real (cos \\<theta>) + 1) -\n  beta_l l * complex_of_real (sin \\<theta>)\n\ngoal (1 subgoal):\n 1. 2 *\n    (alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n     beta_l l * complex_of_real (sin (\\<theta> / 2))) *\n    complex_of_real (cos (\\<theta> / 2)) -\n    alpha_l l =\n    alpha_l l * complex_of_real (cos \\<theta>) -\n    beta_l l * complex_of_real (sin \\<theta>)", "by (simp add: algebra_simps)"], ["proof (state)\nthis:\n  2 *\n  (alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n   beta_l l * complex_of_real (sin (\\<theta> / 2))) *\n  complex_of_real (cos (\\<theta> / 2)) -\n  alpha_l l =\n  alpha_l l * complex_of_real (cos \\<theta>) -\n  beta_l l * complex_of_real (sin \\<theta>)\n\ngoal (1 subgoal):\n 1. 2 *\n    (alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n     beta_l l * complex_of_real (sin (\\<theta> / 2))) *\n    complex_of_real (cos (\\<theta> / 2)) -\n    alpha_l l =\n    alpha_l (l + 1)", "also"], ["proof (state)\nthis:\n  2 *\n  (alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n   beta_l l * complex_of_real (sin (\\<theta> / 2))) *\n  complex_of_real (cos (\\<theta> / 2)) -\n  alpha_l l =\n  alpha_l l * complex_of_real (cos \\<theta>) -\n  beta_l l * complex_of_real (sin \\<theta>)\n\ngoal (1 subgoal):\n 1. 2 *\n    (alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n     beta_l l * complex_of_real (sin (\\<theta> / 2))) *\n    complex_of_real (cos (\\<theta> / 2)) -\n    alpha_l l =\n    alpha_l (l + 1)", "have \"\\<dots> = (alpha_l (l + 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. alpha_l l * complex_of_real (cos \\<theta>) -\n    beta_l l * complex_of_real (sin \\<theta>) =\n    alpha_l (l + 1)", "unfolding alpha_l_def beta_l_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. complex_of_real (cos ((real l + 1 / 2) * \\<theta>)) *\n    complex_of_real (cos \\<theta>) -\n    complex_of_real (sin ((real l + 1 / 2) * \\<theta>)) *\n    complex_of_real (sin \\<theta>) =\n    complex_of_real (cos ((real (l + 1) + 1 / 2) * \\<theta>))", "apply (subst ccos_add[of \"(real l + 1 / 2) * \\<theta>\" \"\\<theta>\", symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. complex_of_real (cos ((real l + 1 / 2) * \\<theta> + \\<theta>)) =\n    complex_of_real (cos ((real (l + 1) + 1 / 2) * \\<theta>))", "by (simp add: algebra_simps)"], ["proof (state)\nthis:\n  alpha_l l * complex_of_real (cos \\<theta>) -\n  beta_l l * complex_of_real (sin \\<theta>) =\n  alpha_l (l + 1)\n\ngoal (1 subgoal):\n 1. 2 *\n    (alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n     beta_l l * complex_of_real (sin (\\<theta> / 2))) *\n    complex_of_real (cos (\\<theta> / 2)) -\n    alpha_l l =\n    alpha_l (l + 1)", "finally"], ["proof (chain)\npicking this:\n  2 *\n  (alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n   beta_l l * complex_of_real (sin (\\<theta> / 2))) *\n  complex_of_real (cos (\\<theta> / 2)) -\n  alpha_l l =\n  alpha_l (l + 1)", "show ?thesis"], ["proof (prove)\nusing this:\n  2 *\n  (alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n   beta_l l * complex_of_real (sin (\\<theta> / 2))) *\n  complex_of_real (cos (\\<theta> / 2)) -\n  alpha_l l =\n  alpha_l (l + 1)\n\ngoal (1 subgoal):\n 1. 2 *\n    (alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n     beta_l l * complex_of_real (sin (\\<theta> / 2))) *\n    complex_of_real (cos (\\<theta> / 2)) -\n    alpha_l l =\n    alpha_l (l + 1)", "by auto"], ["proof (state)\nthis:\n  2 *\n  (alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n   beta_l l * complex_of_real (sin (\\<theta> / 2))) *\n  complex_of_real (cos (\\<theta> / 2)) -\n  alpha_l l =\n  alpha_l (l + 1)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma csin_add:\n  \"csin (x + y) = ccos x * csin y + csin x * ccos y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. complex_of_real (sin (x + y)) =\n    complex_of_real (cos x) * complex_of_real (sin y) +\n    complex_of_real (sin x) * complex_of_real (cos y)", "using sin_add[of x y]"], ["proof (prove)\nusing this:\n  sin (x + y) = sin x * cos y + cos x * sin y\n\ngoal (1 subgoal):\n 1. complex_of_real (sin (x + y)) =\n    complex_of_real (cos x) * complex_of_real (sin y) +\n    complex_of_real (sin x) * complex_of_real (cos y)", "by simp"], ["", "lemma beta_l_Suc_l_derive:\n  \"2 * (alpha_l l * ccos (\\<theta> / 2) - (beta_l l) * csin (\\<theta> / 2)) * csin (\\<theta> / 2) + beta_l l = beta_l (l + 1)\"\n  (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 *\n    (alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n     beta_l l * complex_of_real (sin (\\<theta> / 2))) *\n    complex_of_real (sin (\\<theta> / 2)) +\n    beta_l l =\n    beta_l (l + 1)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. 2 *\n    (alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n     beta_l l * complex_of_real (sin (\\<theta> / 2))) *\n    complex_of_real (sin (\\<theta> / 2)) +\n    beta_l l =\n    beta_l (l + 1)", "have \"2 * ((alpha_l l) * ccos (\\<theta> / 2) - (beta_l l) * csin (\\<theta> / 2)) * csin (\\<theta> / 2)\n    = (alpha_l l) * (2 * csin (\\<theta> / 2)* ccos (\\<theta> / 2)) - (beta_l l) * (2 * csin (\\<theta> / 2) * csin (\\<theta> / 2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 *\n    (alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n     beta_l l * complex_of_real (sin (\\<theta> / 2))) *\n    complex_of_real (sin (\\<theta> / 2)) =\n    alpha_l l *\n    (2 * complex_of_real (sin (\\<theta> / 2)) *\n     complex_of_real (cos (\\<theta> / 2))) -\n    beta_l l *\n    (2 * complex_of_real (sin (\\<theta> / 2)) *\n     complex_of_real (sin (\\<theta> / 2)))", "by (simp add: left_diff_distrib)"], ["proof (state)\nthis:\n  2 *\n  (alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n   beta_l l * complex_of_real (sin (\\<theta> / 2))) *\n  complex_of_real (sin (\\<theta> / 2)) =\n  alpha_l l *\n  (2 * complex_of_real (sin (\\<theta> / 2)) *\n   complex_of_real (cos (\\<theta> / 2))) -\n  beta_l l *\n  (2 * complex_of_real (sin (\\<theta> / 2)) *\n   complex_of_real (sin (\\<theta> / 2)))\n\ngoal (1 subgoal):\n 1. 2 *\n    (alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n     beta_l l * complex_of_real (sin (\\<theta> / 2))) *\n    complex_of_real (sin (\\<theta> / 2)) +\n    beta_l l =\n    beta_l (l + 1)", "also"], ["proof (state)\nthis:\n  2 *\n  (alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n   beta_l l * complex_of_real (sin (\\<theta> / 2))) *\n  complex_of_real (sin (\\<theta> / 2)) =\n  alpha_l l *\n  (2 * complex_of_real (sin (\\<theta> / 2)) *\n   complex_of_real (cos (\\<theta> / 2))) -\n  beta_l l *\n  (2 * complex_of_real (sin (\\<theta> / 2)) *\n   complex_of_real (sin (\\<theta> / 2)))\n\ngoal (1 subgoal):\n 1. 2 *\n    (alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n     beta_l l * complex_of_real (sin (\\<theta> / 2))) *\n    complex_of_real (sin (\\<theta> / 2)) +\n    beta_l l =\n    beta_l (l + 1)", "have \"\\<dots> = (alpha_l l) * (csin \\<theta>) - (beta_l l) * (1 - ccos (\\<theta>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. alpha_l l *\n    (2 * complex_of_real (sin (\\<theta> / 2)) *\n     complex_of_real (cos (\\<theta> / 2))) -\n    beta_l l *\n    (2 * complex_of_real (sin (\\<theta> / 2)) *\n     complex_of_real (sin (\\<theta> / 2))) =\n    alpha_l l * complex_of_real (sin \\<theta>) -\n    beta_l l * (1 - complex_of_real (cos \\<theta>))", "using double_csin_square csin_double"], ["proof (prove)\nusing this:\n  2 * complex_of_real (sin ?a) * complex_of_real (sin ?a) =\n  1 - complex_of_real (cos (2 * ?a))\n  2 * complex_of_real (sin ?a) * complex_of_real (cos ?a) =\n  complex_of_real (sin (2 * ?a))\n\ngoal (1 subgoal):\n 1. alpha_l l *\n    (2 * complex_of_real (sin (\\<theta> / 2)) *\n     complex_of_real (cos (\\<theta> / 2))) -\n    beta_l l *\n    (2 * complex_of_real (sin (\\<theta> / 2)) *\n     complex_of_real (sin (\\<theta> / 2))) =\n    alpha_l l * complex_of_real (sin \\<theta>) -\n    beta_l l * (1 - complex_of_real (cos \\<theta>))", "by auto"], ["proof (state)\nthis:\n  alpha_l l *\n  (2 * complex_of_real (sin (\\<theta> / 2)) *\n   complex_of_real (cos (\\<theta> / 2))) -\n  beta_l l *\n  (2 * complex_of_real (sin (\\<theta> / 2)) *\n   complex_of_real (sin (\\<theta> / 2))) =\n  alpha_l l * complex_of_real (sin \\<theta>) -\n  beta_l l * (1 - complex_of_real (cos \\<theta>))\n\ngoal (1 subgoal):\n 1. 2 *\n    (alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n     beta_l l * complex_of_real (sin (\\<theta> / 2))) *\n    complex_of_real (sin (\\<theta> / 2)) +\n    beta_l l =\n    beta_l (l + 1)", "finally"], ["proof (chain)\npicking this:\n  2 *\n  (alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n   beta_l l * complex_of_real (sin (\\<theta> / 2))) *\n  complex_of_real (sin (\\<theta> / 2)) =\n  alpha_l l * complex_of_real (sin \\<theta>) -\n  beta_l l * (1 - complex_of_real (cos \\<theta>))", "have \"2 * ((alpha_l l) * ccos (\\<theta> / 2) - (beta_l l) * csin (\\<theta> / 2)) * csin (\\<theta> / 2)\n    = (alpha_l l) * (csin \\<theta>) - (beta_l l) * (1 - ccos (\\<theta>))\""], ["proof (prove)\nusing this:\n  2 *\n  (alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n   beta_l l * complex_of_real (sin (\\<theta> / 2))) *\n  complex_of_real (sin (\\<theta> / 2)) =\n  alpha_l l * complex_of_real (sin \\<theta>) -\n  beta_l l * (1 - complex_of_real (cos \\<theta>))\n\ngoal (1 subgoal):\n 1. 2 *\n    (alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n     beta_l l * complex_of_real (sin (\\<theta> / 2))) *\n    complex_of_real (sin (\\<theta> / 2)) =\n    alpha_l l * complex_of_real (sin \\<theta>) -\n    beta_l l * (1 - complex_of_real (cos \\<theta>))", "."], ["proof (state)\nthis:\n  2 *\n  (alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n   beta_l l * complex_of_real (sin (\\<theta> / 2))) *\n  complex_of_real (sin (\\<theta> / 2)) =\n  alpha_l l * complex_of_real (sin \\<theta>) -\n  beta_l l * (1 - complex_of_real (cos \\<theta>))\n\ngoal (1 subgoal):\n 1. 2 *\n    (alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n     beta_l l * complex_of_real (sin (\\<theta> / 2))) *\n    complex_of_real (sin (\\<theta> / 2)) +\n    beta_l l =\n    beta_l (l + 1)", "then"], ["proof (chain)\npicking this:\n  2 *\n  (alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n   beta_l l * complex_of_real (sin (\\<theta> / 2))) *\n  complex_of_real (sin (\\<theta> / 2)) =\n  alpha_l l * complex_of_real (sin \\<theta>) -\n  beta_l l * (1 - complex_of_real (cos \\<theta>))", "have \"?lhs = (alpha_l l) * (csin \\<theta>) + (beta_l l) * ccos \\<theta>\""], ["proof (prove)\nusing this:\n  2 *\n  (alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n   beta_l l * complex_of_real (sin (\\<theta> / 2))) *\n  complex_of_real (sin (\\<theta> / 2)) =\n  alpha_l l * complex_of_real (sin \\<theta>) -\n  beta_l l * (1 - complex_of_real (cos \\<theta>))\n\ngoal (1 subgoal):\n 1. 2 *\n    (alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n     beta_l l * complex_of_real (sin (\\<theta> / 2))) *\n    complex_of_real (sin (\\<theta> / 2)) +\n    beta_l l =\n    alpha_l l * complex_of_real (sin \\<theta>) +\n    beta_l l * complex_of_real (cos \\<theta>)", "by (simp add: algebra_simps)"], ["proof (state)\nthis:\n  2 *\n  (alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n   beta_l l * complex_of_real (sin (\\<theta> / 2))) *\n  complex_of_real (sin (\\<theta> / 2)) +\n  beta_l l =\n  alpha_l l * complex_of_real (sin \\<theta>) +\n  beta_l l * complex_of_real (cos \\<theta>)\n\ngoal (1 subgoal):\n 1. 2 *\n    (alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n     beta_l l * complex_of_real (sin (\\<theta> / 2))) *\n    complex_of_real (sin (\\<theta> / 2)) +\n    beta_l l =\n    beta_l (l + 1)", "also"], ["proof (state)\nthis:\n  2 *\n  (alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n   beta_l l * complex_of_real (sin (\\<theta> / 2))) *\n  complex_of_real (sin (\\<theta> / 2)) +\n  beta_l l =\n  alpha_l l * complex_of_real (sin \\<theta>) +\n  beta_l l * complex_of_real (cos \\<theta>)\n\ngoal (1 subgoal):\n 1. 2 *\n    (alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n     beta_l l * complex_of_real (sin (\\<theta> / 2))) *\n    complex_of_real (sin (\\<theta> / 2)) +\n    beta_l l =\n    beta_l (l + 1)", "have \"\\<dots> = (beta_l (l + 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. alpha_l l * complex_of_real (sin \\<theta>) +\n    beta_l l * complex_of_real (cos \\<theta>) =\n    beta_l (l + 1)", "unfolding alpha_l_def beta_l_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. complex_of_real (cos ((real l + 1 / 2) * \\<theta>)) *\n    complex_of_real (sin \\<theta>) +\n    complex_of_real (sin ((real l + 1 / 2) * \\<theta>)) *\n    complex_of_real (cos \\<theta>) =\n    complex_of_real (sin ((real (l + 1) + 1 / 2) * \\<theta>))", "apply (subst csin_add[of \"(real l + 1 / 2) * \\<theta>\" \"\\<theta>\", symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. complex_of_real (sin ((real l + 1 / 2) * \\<theta> + \\<theta>)) =\n    complex_of_real (sin ((real (l + 1) + 1 / 2) * \\<theta>))", "by (simp add: algebra_simps)"], ["proof (state)\nthis:\n  alpha_l l * complex_of_real (sin \\<theta>) +\n  beta_l l * complex_of_real (cos \\<theta>) =\n  beta_l (l + 1)\n\ngoal (1 subgoal):\n 1. 2 *\n    (alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n     beta_l l * complex_of_real (sin (\\<theta> / 2))) *\n    complex_of_real (sin (\\<theta> / 2)) +\n    beta_l l =\n    beta_l (l + 1)", "finally"], ["proof (chain)\npicking this:\n  2 *\n  (alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n   beta_l l * complex_of_real (sin (\\<theta> / 2))) *\n  complex_of_real (sin (\\<theta> / 2)) +\n  beta_l l =\n  beta_l (l + 1)", "show ?thesis"], ["proof (prove)\nusing this:\n  2 *\n  (alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n   beta_l l * complex_of_real (sin (\\<theta> / 2))) *\n  complex_of_real (sin (\\<theta> / 2)) +\n  beta_l l =\n  beta_l (l + 1)\n\ngoal (1 subgoal):\n 1. 2 *\n    (alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n     beta_l l * complex_of_real (sin (\\<theta> / 2))) *\n    complex_of_real (sin (\\<theta> / 2)) +\n    beta_l l =\n    beta_l (l + 1)", "by auto"], ["proof (state)\nthis:\n  2 *\n  (alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n   beta_l l * complex_of_real (sin (\\<theta> / 2))) *\n  complex_of_real (sin (\\<theta> / 2)) +\n  beta_l l =\n  beta_l (l + 1)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma psi_l_Suc_l_derive:\n  \"2 * (alpha_l l * ccos (\\<theta> / 2) - beta_l l * csin (\\<theta> / 2)) \\<cdot>\\<^sub>v \\<psi> - psi'_l l = psi_l (l + 1)\"\n  (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 *\n    (alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n     beta_l l * complex_of_real (sin (\\<theta> / 2))) \\<cdot>\\<^sub>v\n    \\<psi> -\n    psi'_l l =\n    psi_l (l + 1)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. 2 *\n    (alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n     beta_l l * complex_of_real (sin (\\<theta> / 2))) \\<cdot>\\<^sub>v\n    \\<psi> -\n    psi'_l l =\n    psi_l (l + 1)", "let ?l = \"2 * ((alpha_l l) * ccos (\\<theta> / 2) - (beta_l l) * csin (\\<theta> / 2))\""], ["proof (state)\ngoal (1 subgoal):\n 1. 2 *\n    (alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n     beta_l l * complex_of_real (sin (\\<theta> / 2))) \\<cdot>\\<^sub>v\n    \\<psi> -\n    psi'_l l =\n    psi_l (l + 1)", "have \"?l \\<cdot>\\<^sub>v \\<psi> = ?l \\<cdot>\\<^sub>v (ccos (\\<theta> / 2) \\<cdot>\\<^sub>v \\<alpha> + csin (\\<theta> / 2) \\<cdot>\\<^sub>v \\<beta>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 *\n    (alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n     beta_l l * complex_of_real (sin (\\<theta> / 2))) \\<cdot>\\<^sub>v\n    \\<psi> =\n    2 *\n    (alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n     beta_l l * complex_of_real (sin (\\<theta> / 2))) \\<cdot>\\<^sub>v\n    (complex_of_real (cos (\\<theta> / 2)) \\<cdot>\\<^sub>v \\<alpha> +\n     complex_of_real (sin (\\<theta> / 2)) \\<cdot>\\<^sub>v \\<beta>)", "unfolding \\<psi>_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 *\n    (alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n     beta_l l * complex_of_real (sin (\\<theta> / 2))) \\<cdot>\\<^sub>v\n    (complex_of_real (cos (\\<theta> / 2)) \\<cdot>\\<^sub>v \\<alpha> +\n     complex_of_real (sin (\\<theta> / 2)) \\<cdot>\\<^sub>v \\<beta>) =\n    2 *\n    (alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n     beta_l l * complex_of_real (sin (\\<theta> / 2))) \\<cdot>\\<^sub>v\n    (complex_of_real (cos (\\<theta> / 2)) \\<cdot>\\<^sub>v \\<alpha> +\n     complex_of_real (sin (\\<theta> / 2)) \\<cdot>\\<^sub>v \\<beta>)", "by auto"], ["proof (state)\nthis:\n  2 *\n  (alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n   beta_l l * complex_of_real (sin (\\<theta> / 2))) \\<cdot>\\<^sub>v\n  \\<psi> =\n  2 *\n  (alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n   beta_l l * complex_of_real (sin (\\<theta> / 2))) \\<cdot>\\<^sub>v\n  (complex_of_real (cos (\\<theta> / 2)) \\<cdot>\\<^sub>v \\<alpha> +\n   complex_of_real (sin (\\<theta> / 2)) \\<cdot>\\<^sub>v \\<beta>)\n\ngoal (1 subgoal):\n 1. 2 *\n    (alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n     beta_l l * complex_of_real (sin (\\<theta> / 2))) \\<cdot>\\<^sub>v\n    \\<psi> -\n    psi'_l l =\n    psi_l (l + 1)", "also"], ["proof (state)\nthis:\n  2 *\n  (alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n   beta_l l * complex_of_real (sin (\\<theta> / 2))) \\<cdot>\\<^sub>v\n  \\<psi> =\n  2 *\n  (alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n   beta_l l * complex_of_real (sin (\\<theta> / 2))) \\<cdot>\\<^sub>v\n  (complex_of_real (cos (\\<theta> / 2)) \\<cdot>\\<^sub>v \\<alpha> +\n   complex_of_real (sin (\\<theta> / 2)) \\<cdot>\\<^sub>v \\<beta>)\n\ngoal (1 subgoal):\n 1. 2 *\n    (alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n     beta_l l * complex_of_real (sin (\\<theta> / 2))) \\<cdot>\\<^sub>v\n    \\<psi> -\n    psi'_l l =\n    psi_l (l + 1)", "have \"\\<dots> = ?l \\<cdot>\\<^sub>v (ccos (\\<theta> / 2) \\<cdot>\\<^sub>v \\<alpha>) + ?l \\<cdot>\\<^sub>v (csin (\\<theta> / 2) \\<cdot>\\<^sub>v \\<beta>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 *\n    (alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n     beta_l l * complex_of_real (sin (\\<theta> / 2))) \\<cdot>\\<^sub>v\n    (complex_of_real (cos (\\<theta> / 2)) \\<cdot>\\<^sub>v \\<alpha> +\n     complex_of_real (sin (\\<theta> / 2)) \\<cdot>\\<^sub>v \\<beta>) =\n    2 *\n    (alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n     beta_l l * complex_of_real (sin (\\<theta> / 2))) \\<cdot>\\<^sub>v\n    (complex_of_real (cos (\\<theta> / 2)) \\<cdot>\\<^sub>v \\<alpha>) +\n    2 *\n    (alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n     beta_l l * complex_of_real (sin (\\<theta> / 2))) \\<cdot>\\<^sub>v\n    (complex_of_real (sin (\\<theta> / 2)) \\<cdot>\\<^sub>v \\<beta>)", "apply (subst smult_add_distrib_vec[of _ N])"], ["proof (prove)\ngoal (3 subgoals):\n 1. complex_of_real (cos (\\<theta> / 2)) \\<cdot>\\<^sub>v \\<alpha>\n    \\<in> carrier_vec N\n 2. complex_of_real (sin (\\<theta> / 2)) \\<cdot>\\<^sub>v \\<beta>\n    \\<in> carrier_vec N\n 3. 2 *\n    (alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n     beta_l l * complex_of_real (sin (\\<theta> / 2))) \\<cdot>\\<^sub>v\n    (complex_of_real (cos (\\<theta> / 2)) \\<cdot>\\<^sub>v \\<alpha>) +\n    2 *\n    (alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n     beta_l l * complex_of_real (sin (\\<theta> / 2))) \\<cdot>\\<^sub>v\n    (complex_of_real (sin (\\<theta> / 2)) \\<cdot>\\<^sub>v \\<beta>) =\n    2 *\n    (alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n     beta_l l * complex_of_real (sin (\\<theta> / 2))) \\<cdot>\\<^sub>v\n    (complex_of_real (cos (\\<theta> / 2)) \\<cdot>\\<^sub>v \\<alpha>) +\n    2 *\n    (alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n     beta_l l * complex_of_real (sin (\\<theta> / 2))) \\<cdot>\\<^sub>v\n    (complex_of_real (sin (\\<theta> / 2)) \\<cdot>\\<^sub>v \\<beta>)", "using \\<alpha>_dim \\<beta>_dim"], ["proof (prove)\nusing this:\n  \\<alpha> \\<in> carrier_vec N\n  dim_vec \\<alpha> = N\n  \\<beta> \\<in> carrier_vec N\n  dim_vec \\<beta> = N\n\ngoal (3 subgoals):\n 1. complex_of_real (cos (\\<theta> / 2)) \\<cdot>\\<^sub>v \\<alpha>\n    \\<in> carrier_vec N\n 2. complex_of_real (sin (\\<theta> / 2)) \\<cdot>\\<^sub>v \\<beta>\n    \\<in> carrier_vec N\n 3. 2 *\n    (alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n     beta_l l * complex_of_real (sin (\\<theta> / 2))) \\<cdot>\\<^sub>v\n    (complex_of_real (cos (\\<theta> / 2)) \\<cdot>\\<^sub>v \\<alpha>) +\n    2 *\n    (alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n     beta_l l * complex_of_real (sin (\\<theta> / 2))) \\<cdot>\\<^sub>v\n    (complex_of_real (sin (\\<theta> / 2)) \\<cdot>\\<^sub>v \\<beta>) =\n    2 *\n    (alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n     beta_l l * complex_of_real (sin (\\<theta> / 2))) \\<cdot>\\<^sub>v\n    (complex_of_real (cos (\\<theta> / 2)) \\<cdot>\\<^sub>v \\<alpha>) +\n    2 *\n    (alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n     beta_l l * complex_of_real (sin (\\<theta> / 2))) \\<cdot>\\<^sub>v\n    (complex_of_real (sin (\\<theta> / 2)) \\<cdot>\\<^sub>v \\<beta>)", "by auto"], ["proof (state)\nthis:\n  2 *\n  (alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n   beta_l l * complex_of_real (sin (\\<theta> / 2))) \\<cdot>\\<^sub>v\n  (complex_of_real (cos (\\<theta> / 2)) \\<cdot>\\<^sub>v \\<alpha> +\n   complex_of_real (sin (\\<theta> / 2)) \\<cdot>\\<^sub>v \\<beta>) =\n  2 *\n  (alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n   beta_l l * complex_of_real (sin (\\<theta> / 2))) \\<cdot>\\<^sub>v\n  (complex_of_real (cos (\\<theta> / 2)) \\<cdot>\\<^sub>v \\<alpha>) +\n  2 *\n  (alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n   beta_l l * complex_of_real (sin (\\<theta> / 2))) \\<cdot>\\<^sub>v\n  (complex_of_real (sin (\\<theta> / 2)) \\<cdot>\\<^sub>v \\<beta>)\n\ngoal (1 subgoal):\n 1. 2 *\n    (alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n     beta_l l * complex_of_real (sin (\\<theta> / 2))) \\<cdot>\\<^sub>v\n    \\<psi> -\n    psi'_l l =\n    psi_l (l + 1)", "also"], ["proof (state)\nthis:\n  2 *\n  (alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n   beta_l l * complex_of_real (sin (\\<theta> / 2))) \\<cdot>\\<^sub>v\n  (complex_of_real (cos (\\<theta> / 2)) \\<cdot>\\<^sub>v \\<alpha> +\n   complex_of_real (sin (\\<theta> / 2)) \\<cdot>\\<^sub>v \\<beta>) =\n  2 *\n  (alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n   beta_l l * complex_of_real (sin (\\<theta> / 2))) \\<cdot>\\<^sub>v\n  (complex_of_real (cos (\\<theta> / 2)) \\<cdot>\\<^sub>v \\<alpha>) +\n  2 *\n  (alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n   beta_l l * complex_of_real (sin (\\<theta> / 2))) \\<cdot>\\<^sub>v\n  (complex_of_real (sin (\\<theta> / 2)) \\<cdot>\\<^sub>v \\<beta>)\n\ngoal (1 subgoal):\n 1. 2 *\n    (alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n     beta_l l * complex_of_real (sin (\\<theta> / 2))) \\<cdot>\\<^sub>v\n    \\<psi> -\n    psi'_l l =\n    psi_l (l + 1)", "have \"\\<dots> = (?l * ccos (\\<theta> / 2)) \\<cdot>\\<^sub>v \\<alpha> + (?l * csin (\\<theta> / 2)) \\<cdot>\\<^sub>v \\<beta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 *\n    (alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n     beta_l l * complex_of_real (sin (\\<theta> / 2))) \\<cdot>\\<^sub>v\n    (complex_of_real (cos (\\<theta> / 2)) \\<cdot>\\<^sub>v \\<alpha>) +\n    2 *\n    (alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n     beta_l l * complex_of_real (sin (\\<theta> / 2))) \\<cdot>\\<^sub>v\n    (complex_of_real (sin (\\<theta> / 2)) \\<cdot>\\<^sub>v \\<beta>) =\n    2 *\n    (alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n     beta_l l * complex_of_real (sin (\\<theta> / 2))) *\n    complex_of_real (cos (\\<theta> / 2)) \\<cdot>\\<^sub>v\n    \\<alpha> +\n    2 *\n    (alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n     beta_l l * complex_of_real (sin (\\<theta> / 2))) *\n    complex_of_real (sin (\\<theta> / 2)) \\<cdot>\\<^sub>v\n    \\<beta>", "by auto"], ["proof (state)\nthis:\n  2 *\n  (alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n   beta_l l * complex_of_real (sin (\\<theta> / 2))) \\<cdot>\\<^sub>v\n  (complex_of_real (cos (\\<theta> / 2)) \\<cdot>\\<^sub>v \\<alpha>) +\n  2 *\n  (alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n   beta_l l * complex_of_real (sin (\\<theta> / 2))) \\<cdot>\\<^sub>v\n  (complex_of_real (sin (\\<theta> / 2)) \\<cdot>\\<^sub>v \\<beta>) =\n  2 *\n  (alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n   beta_l l * complex_of_real (sin (\\<theta> / 2))) *\n  complex_of_real (cos (\\<theta> / 2)) \\<cdot>\\<^sub>v\n  \\<alpha> +\n  2 *\n  (alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n   beta_l l * complex_of_real (sin (\\<theta> / 2))) *\n  complex_of_real (sin (\\<theta> / 2)) \\<cdot>\\<^sub>v\n  \\<beta>\n\ngoal (1 subgoal):\n 1. 2 *\n    (alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n     beta_l l * complex_of_real (sin (\\<theta> / 2))) \\<cdot>\\<^sub>v\n    \\<psi> -\n    psi'_l l =\n    psi_l (l + 1)", "finally"], ["proof (chain)\npicking this:\n  2 *\n  (alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n   beta_l l * complex_of_real (sin (\\<theta> / 2))) \\<cdot>\\<^sub>v\n  \\<psi> =\n  2 *\n  (alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n   beta_l l * complex_of_real (sin (\\<theta> / 2))) *\n  complex_of_real (cos (\\<theta> / 2)) \\<cdot>\\<^sub>v\n  \\<alpha> +\n  2 *\n  (alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n   beta_l l * complex_of_real (sin (\\<theta> / 2))) *\n  complex_of_real (sin (\\<theta> / 2)) \\<cdot>\\<^sub>v\n  \\<beta>", "have \"?l \\<cdot>\\<^sub>v \\<psi>  = (?l * ccos (\\<theta> / 2)) \\<cdot>\\<^sub>v \\<alpha> + (?l * csin (\\<theta> / 2)) \\<cdot>\\<^sub>v \\<beta>\""], ["proof (prove)\nusing this:\n  2 *\n  (alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n   beta_l l * complex_of_real (sin (\\<theta> / 2))) \\<cdot>\\<^sub>v\n  \\<psi> =\n  2 *\n  (alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n   beta_l l * complex_of_real (sin (\\<theta> / 2))) *\n  complex_of_real (cos (\\<theta> / 2)) \\<cdot>\\<^sub>v\n  \\<alpha> +\n  2 *\n  (alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n   beta_l l * complex_of_real (sin (\\<theta> / 2))) *\n  complex_of_real (sin (\\<theta> / 2)) \\<cdot>\\<^sub>v\n  \\<beta>\n\ngoal (1 subgoal):\n 1. 2 *\n    (alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n     beta_l l * complex_of_real (sin (\\<theta> / 2))) \\<cdot>\\<^sub>v\n    \\<psi> =\n    2 *\n    (alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n     beta_l l * complex_of_real (sin (\\<theta> / 2))) *\n    complex_of_real (cos (\\<theta> / 2)) \\<cdot>\\<^sub>v\n    \\<alpha> +\n    2 *\n    (alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n     beta_l l * complex_of_real (sin (\\<theta> / 2))) *\n    complex_of_real (sin (\\<theta> / 2)) \\<cdot>\\<^sub>v\n    \\<beta>", "."], ["proof (state)\nthis:\n  2 *\n  (alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n   beta_l l * complex_of_real (sin (\\<theta> / 2))) \\<cdot>\\<^sub>v\n  \\<psi> =\n  2 *\n  (alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n   beta_l l * complex_of_real (sin (\\<theta> / 2))) *\n  complex_of_real (cos (\\<theta> / 2)) \\<cdot>\\<^sub>v\n  \\<alpha> +\n  2 *\n  (alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n   beta_l l * complex_of_real (sin (\\<theta> / 2))) *\n  complex_of_real (sin (\\<theta> / 2)) \\<cdot>\\<^sub>v\n  \\<beta>\n\ngoal (1 subgoal):\n 1. 2 *\n    (alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n     beta_l l * complex_of_real (sin (\\<theta> / 2))) \\<cdot>\\<^sub>v\n    \\<psi> -\n    psi'_l l =\n    psi_l (l + 1)", "then"], ["proof (chain)\npicking this:\n  2 *\n  (alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n   beta_l l * complex_of_real (sin (\\<theta> / 2))) \\<cdot>\\<^sub>v\n  \\<psi> =\n  2 *\n  (alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n   beta_l l * complex_of_real (sin (\\<theta> / 2))) *\n  complex_of_real (cos (\\<theta> / 2)) \\<cdot>\\<^sub>v\n  \\<alpha> +\n  2 *\n  (alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n   beta_l l * complex_of_real (sin (\\<theta> / 2))) *\n  complex_of_real (sin (\\<theta> / 2)) \\<cdot>\\<^sub>v\n  \\<beta>", "have \"?l \\<cdot>\\<^sub>v \\<psi> - (psi'_l l) = ((?l * ccos (\\<theta> / 2)) \\<cdot>\\<^sub>v \\<alpha> - (alpha_l l) \\<cdot>\\<^sub>v \\<alpha>) + ((?l * csin (\\<theta> / 2)) \\<cdot>\\<^sub>v \\<beta> + (beta_l l) \\<cdot>\\<^sub>v \\<beta>)\""], ["proof (prove)\nusing this:\n  2 *\n  (alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n   beta_l l * complex_of_real (sin (\\<theta> / 2))) \\<cdot>\\<^sub>v\n  \\<psi> =\n  2 *\n  (alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n   beta_l l * complex_of_real (sin (\\<theta> / 2))) *\n  complex_of_real (cos (\\<theta> / 2)) \\<cdot>\\<^sub>v\n  \\<alpha> +\n  2 *\n  (alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n   beta_l l * complex_of_real (sin (\\<theta> / 2))) *\n  complex_of_real (sin (\\<theta> / 2)) \\<cdot>\\<^sub>v\n  \\<beta>\n\ngoal (1 subgoal):\n 1. 2 *\n    (alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n     beta_l l * complex_of_real (sin (\\<theta> / 2))) \\<cdot>\\<^sub>v\n    \\<psi> -\n    psi'_l l =\n    2 *\n    (alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n     beta_l l * complex_of_real (sin (\\<theta> / 2))) *\n    complex_of_real (cos (\\<theta> / 2)) \\<cdot>\\<^sub>v\n    \\<alpha> -\n    alpha_l l \\<cdot>\\<^sub>v \\<alpha> +\n    (2 *\n     (alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n      beta_l l * complex_of_real (sin (\\<theta> / 2))) *\n     complex_of_real (sin (\\<theta> / 2)) \\<cdot>\\<^sub>v\n     \\<beta> +\n     beta_l l \\<cdot>\\<^sub>v \\<beta>)", "unfolding psi'_l_def"], ["proof (prove)\nusing this:\n  2 *\n  (alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n   beta_l l * complex_of_real (sin (\\<theta> / 2))) \\<cdot>\\<^sub>v\n  \\<psi> =\n  2 *\n  (alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n   beta_l l * complex_of_real (sin (\\<theta> / 2))) *\n  complex_of_real (cos (\\<theta> / 2)) \\<cdot>\\<^sub>v\n  \\<alpha> +\n  2 *\n  (alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n   beta_l l * complex_of_real (sin (\\<theta> / 2))) *\n  complex_of_real (sin (\\<theta> / 2)) \\<cdot>\\<^sub>v\n  \\<beta>\n\ngoal (1 subgoal):\n 1. 2 *\n    (alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n     beta_l l * complex_of_real (sin (\\<theta> / 2))) \\<cdot>\\<^sub>v\n    \\<psi> -\n    (alpha_l l \\<cdot>\\<^sub>v \\<alpha> -\n     beta_l l \\<cdot>\\<^sub>v \\<beta>) =\n    2 *\n    (alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n     beta_l l * complex_of_real (sin (\\<theta> / 2))) *\n    complex_of_real (cos (\\<theta> / 2)) \\<cdot>\\<^sub>v\n    \\<alpha> -\n    alpha_l l \\<cdot>\\<^sub>v \\<alpha> +\n    (2 *\n     (alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n      beta_l l * complex_of_real (sin (\\<theta> / 2))) *\n     complex_of_real (sin (\\<theta> / 2)) \\<cdot>\\<^sub>v\n     \\<beta> +\n     beta_l l \\<cdot>\\<^sub>v \\<beta>)", "by auto"], ["proof (state)\nthis:\n  2 *\n  (alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n   beta_l l * complex_of_real (sin (\\<theta> / 2))) \\<cdot>\\<^sub>v\n  \\<psi> -\n  psi'_l l =\n  2 *\n  (alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n   beta_l l * complex_of_real (sin (\\<theta> / 2))) *\n  complex_of_real (cos (\\<theta> / 2)) \\<cdot>\\<^sub>v\n  \\<alpha> -\n  alpha_l l \\<cdot>\\<^sub>v \\<alpha> +\n  (2 *\n   (alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n    beta_l l * complex_of_real (sin (\\<theta> / 2))) *\n   complex_of_real (sin (\\<theta> / 2)) \\<cdot>\\<^sub>v\n   \\<beta> +\n   beta_l l \\<cdot>\\<^sub>v \\<beta>)\n\ngoal (1 subgoal):\n 1. 2 *\n    (alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n     beta_l l * complex_of_real (sin (\\<theta> / 2))) \\<cdot>\\<^sub>v\n    \\<psi> -\n    psi'_l l =\n    psi_l (l + 1)", "also"], ["proof (state)\nthis:\n  2 *\n  (alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n   beta_l l * complex_of_real (sin (\\<theta> / 2))) \\<cdot>\\<^sub>v\n  \\<psi> -\n  psi'_l l =\n  2 *\n  (alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n   beta_l l * complex_of_real (sin (\\<theta> / 2))) *\n  complex_of_real (cos (\\<theta> / 2)) \\<cdot>\\<^sub>v\n  \\<alpha> -\n  alpha_l l \\<cdot>\\<^sub>v \\<alpha> +\n  (2 *\n   (alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n    beta_l l * complex_of_real (sin (\\<theta> / 2))) *\n   complex_of_real (sin (\\<theta> / 2)) \\<cdot>\\<^sub>v\n   \\<beta> +\n   beta_l l \\<cdot>\\<^sub>v \\<beta>)\n\ngoal (1 subgoal):\n 1. 2 *\n    (alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n     beta_l l * complex_of_real (sin (\\<theta> / 2))) \\<cdot>\\<^sub>v\n    \\<psi> -\n    psi'_l l =\n    psi_l (l + 1)", "have \"\\<dots> = (?l * ccos (\\<theta> / 2) - alpha_l l) \\<cdot>\\<^sub>v \\<alpha> + (?l * csin (\\<theta> / 2) + beta_l l) \\<cdot>\\<^sub>v \\<beta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 *\n    (alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n     beta_l l * complex_of_real (sin (\\<theta> / 2))) *\n    complex_of_real (cos (\\<theta> / 2)) \\<cdot>\\<^sub>v\n    \\<alpha> -\n    alpha_l l \\<cdot>\\<^sub>v \\<alpha> +\n    (2 *\n     (alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n      beta_l l * complex_of_real (sin (\\<theta> / 2))) *\n     complex_of_real (sin (\\<theta> / 2)) \\<cdot>\\<^sub>v\n     \\<beta> +\n     beta_l l \\<cdot>\\<^sub>v \\<beta>) =\n    (2 *\n     (alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n      beta_l l * complex_of_real (sin (\\<theta> / 2))) *\n     complex_of_real (cos (\\<theta> / 2)) -\n     alpha_l l) \\<cdot>\\<^sub>v\n    \\<alpha> +\n    (2 *\n     (alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n      beta_l l * complex_of_real (sin (\\<theta> / 2))) *\n     complex_of_real (sin (\\<theta> / 2)) +\n     beta_l l) \\<cdot>\\<^sub>v\n    \\<beta>", "apply (subst minus_smult_vec_distrib)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 *\n    (alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n     beta_l l * complex_of_real (sin (\\<theta> / 2))) *\n    complex_of_real (cos (\\<theta> / 2)) \\<cdot>\\<^sub>v\n    \\<alpha> -\n    alpha_l l \\<cdot>\\<^sub>v \\<alpha> +\n    (2 *\n     (alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n      beta_l l * complex_of_real (sin (\\<theta> / 2))) *\n     complex_of_real (sin (\\<theta> / 2)) \\<cdot>\\<^sub>v\n     \\<beta> +\n     beta_l l \\<cdot>\\<^sub>v \\<beta>) =\n    2 *\n    (alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n     beta_l l * complex_of_real (sin (\\<theta> / 2))) *\n    complex_of_real (cos (\\<theta> / 2)) \\<cdot>\\<^sub>v\n    \\<alpha> -\n    alpha_l l \\<cdot>\\<^sub>v \\<alpha> +\n    (2 *\n     (alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n      beta_l l * complex_of_real (sin (\\<theta> / 2))) *\n     complex_of_real (sin (\\<theta> / 2)) +\n     beta_l l) \\<cdot>\\<^sub>v\n    \\<beta>", "apply (subst add_smult_distrib_vec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 *\n    (alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n     beta_l l * complex_of_real (sin (\\<theta> / 2))) *\n    complex_of_real (cos (\\<theta> / 2)) \\<cdot>\\<^sub>v\n    \\<alpha> -\n    alpha_l l \\<cdot>\\<^sub>v \\<alpha> +\n    (2 *\n     (alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n      beta_l l * complex_of_real (sin (\\<theta> / 2))) *\n     complex_of_real (sin (\\<theta> / 2)) \\<cdot>\\<^sub>v\n     \\<beta> +\n     beta_l l \\<cdot>\\<^sub>v \\<beta>) =\n    2 *\n    (alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n     beta_l l * complex_of_real (sin (\\<theta> / 2))) *\n    complex_of_real (cos (\\<theta> / 2)) \\<cdot>\\<^sub>v\n    \\<alpha> -\n    alpha_l l \\<cdot>\\<^sub>v \\<alpha> +\n    (2 *\n     (alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n      beta_l l * complex_of_real (sin (\\<theta> / 2))) *\n     complex_of_real (sin (\\<theta> / 2)) \\<cdot>\\<^sub>v\n     \\<beta> +\n     beta_l l \\<cdot>\\<^sub>v \\<beta>)", "by auto"], ["proof (state)\nthis:\n  2 *\n  (alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n   beta_l l * complex_of_real (sin (\\<theta> / 2))) *\n  complex_of_real (cos (\\<theta> / 2)) \\<cdot>\\<^sub>v\n  \\<alpha> -\n  alpha_l l \\<cdot>\\<^sub>v \\<alpha> +\n  (2 *\n   (alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n    beta_l l * complex_of_real (sin (\\<theta> / 2))) *\n   complex_of_real (sin (\\<theta> / 2)) \\<cdot>\\<^sub>v\n   \\<beta> +\n   beta_l l \\<cdot>\\<^sub>v \\<beta>) =\n  (2 *\n   (alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n    beta_l l * complex_of_real (sin (\\<theta> / 2))) *\n   complex_of_real (cos (\\<theta> / 2)) -\n   alpha_l l) \\<cdot>\\<^sub>v\n  \\<alpha> +\n  (2 *\n   (alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n    beta_l l * complex_of_real (sin (\\<theta> / 2))) *\n   complex_of_real (sin (\\<theta> / 2)) +\n   beta_l l) \\<cdot>\\<^sub>v\n  \\<beta>\n\ngoal (1 subgoal):\n 1. 2 *\n    (alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n     beta_l l * complex_of_real (sin (\\<theta> / 2))) \\<cdot>\\<^sub>v\n    \\<psi> -\n    psi'_l l =\n    psi_l (l + 1)", "also"], ["proof (state)\nthis:\n  2 *\n  (alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n   beta_l l * complex_of_real (sin (\\<theta> / 2))) *\n  complex_of_real (cos (\\<theta> / 2)) \\<cdot>\\<^sub>v\n  \\<alpha> -\n  alpha_l l \\<cdot>\\<^sub>v \\<alpha> +\n  (2 *\n   (alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n    beta_l l * complex_of_real (sin (\\<theta> / 2))) *\n   complex_of_real (sin (\\<theta> / 2)) \\<cdot>\\<^sub>v\n   \\<beta> +\n   beta_l l \\<cdot>\\<^sub>v \\<beta>) =\n  (2 *\n   (alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n    beta_l l * complex_of_real (sin (\\<theta> / 2))) *\n   complex_of_real (cos (\\<theta> / 2)) -\n   alpha_l l) \\<cdot>\\<^sub>v\n  \\<alpha> +\n  (2 *\n   (alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n    beta_l l * complex_of_real (sin (\\<theta> / 2))) *\n   complex_of_real (sin (\\<theta> / 2)) +\n   beta_l l) \\<cdot>\\<^sub>v\n  \\<beta>\n\ngoal (1 subgoal):\n 1. 2 *\n    (alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n     beta_l l * complex_of_real (sin (\\<theta> / 2))) \\<cdot>\\<^sub>v\n    \\<psi> -\n    psi'_l l =\n    psi_l (l + 1)", "have \"\\<dots> = (alpha_l (l + 1)) \\<cdot>\\<^sub>v \\<alpha> + (beta_l (l + 1)) \\<cdot>\\<^sub>v \\<beta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (2 *\n     (alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n      beta_l l * complex_of_real (sin (\\<theta> / 2))) *\n     complex_of_real (cos (\\<theta> / 2)) -\n     alpha_l l) \\<cdot>\\<^sub>v\n    \\<alpha> +\n    (2 *\n     (alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n      beta_l l * complex_of_real (sin (\\<theta> / 2))) *\n     complex_of_real (sin (\\<theta> / 2)) +\n     beta_l l) \\<cdot>\\<^sub>v\n    \\<beta> =\n    alpha_l (l + 1) \\<cdot>\\<^sub>v \\<alpha> +\n    beta_l (l + 1) \\<cdot>\\<^sub>v \\<beta>", "using alpha_l_Suc_l_derive beta_l_Suc_l_derive"], ["proof (prove)\nusing this:\n  2 *\n  (alpha_l ?l * complex_of_real (cos (\\<theta> / 2)) -\n   beta_l ?l * complex_of_real (sin (\\<theta> / 2))) *\n  complex_of_real (cos (\\<theta> / 2)) -\n  alpha_l ?l =\n  alpha_l (?l + 1)\n  2 *\n  (alpha_l ?l * complex_of_real (cos (\\<theta> / 2)) -\n   beta_l ?l * complex_of_real (sin (\\<theta> / 2))) *\n  complex_of_real (sin (\\<theta> / 2)) +\n  beta_l ?l =\n  beta_l (?l + 1)\n\ngoal (1 subgoal):\n 1. (2 *\n     (alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n      beta_l l * complex_of_real (sin (\\<theta> / 2))) *\n     complex_of_real (cos (\\<theta> / 2)) -\n     alpha_l l) \\<cdot>\\<^sub>v\n    \\<alpha> +\n    (2 *\n     (alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n      beta_l l * complex_of_real (sin (\\<theta> / 2))) *\n     complex_of_real (sin (\\<theta> / 2)) +\n     beta_l l) \\<cdot>\\<^sub>v\n    \\<beta> =\n    alpha_l (l + 1) \\<cdot>\\<^sub>v \\<alpha> +\n    beta_l (l + 1) \\<cdot>\\<^sub>v \\<beta>", "by auto"], ["proof (state)\nthis:\n  (2 *\n   (alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n    beta_l l * complex_of_real (sin (\\<theta> / 2))) *\n   complex_of_real (cos (\\<theta> / 2)) -\n   alpha_l l) \\<cdot>\\<^sub>v\n  \\<alpha> +\n  (2 *\n   (alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n    beta_l l * complex_of_real (sin (\\<theta> / 2))) *\n   complex_of_real (sin (\\<theta> / 2)) +\n   beta_l l) \\<cdot>\\<^sub>v\n  \\<beta> =\n  alpha_l (l + 1) \\<cdot>\\<^sub>v \\<alpha> +\n  beta_l (l + 1) \\<cdot>\\<^sub>v \\<beta>\n\ngoal (1 subgoal):\n 1. 2 *\n    (alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n     beta_l l * complex_of_real (sin (\\<theta> / 2))) \\<cdot>\\<^sub>v\n    \\<psi> -\n    psi'_l l =\n    psi_l (l + 1)", "finally"], ["proof (chain)\npicking this:\n  2 *\n  (alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n   beta_l l * complex_of_real (sin (\\<theta> / 2))) \\<cdot>\\<^sub>v\n  \\<psi> -\n  psi'_l l =\n  alpha_l (l + 1) \\<cdot>\\<^sub>v \\<alpha> +\n  beta_l (l + 1) \\<cdot>\\<^sub>v \\<beta>", "have \"?l \\<cdot>\\<^sub>v \\<psi> - (psi'_l l) = (alpha_l (l + 1)) \\<cdot>\\<^sub>v \\<alpha> + (beta_l (l + 1)) \\<cdot>\\<^sub>v \\<beta>\""], ["proof (prove)\nusing this:\n  2 *\n  (alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n   beta_l l * complex_of_real (sin (\\<theta> / 2))) \\<cdot>\\<^sub>v\n  \\<psi> -\n  psi'_l l =\n  alpha_l (l + 1) \\<cdot>\\<^sub>v \\<alpha> +\n  beta_l (l + 1) \\<cdot>\\<^sub>v \\<beta>\n\ngoal (1 subgoal):\n 1. 2 *\n    (alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n     beta_l l * complex_of_real (sin (\\<theta> / 2))) \\<cdot>\\<^sub>v\n    \\<psi> -\n    psi'_l l =\n    alpha_l (l + 1) \\<cdot>\\<^sub>v \\<alpha> +\n    beta_l (l + 1) \\<cdot>\\<^sub>v \\<beta>", "."], ["proof (state)\nthis:\n  2 *\n  (alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n   beta_l l * complex_of_real (sin (\\<theta> / 2))) \\<cdot>\\<^sub>v\n  \\<psi> -\n  psi'_l l =\n  alpha_l (l + 1) \\<cdot>\\<^sub>v \\<alpha> +\n  beta_l (l + 1) \\<cdot>\\<^sub>v \\<beta>\n\ngoal (1 subgoal):\n 1. 2 *\n    (alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n     beta_l l * complex_of_real (sin (\\<theta> / 2))) \\<cdot>\\<^sub>v\n    \\<psi> -\n    psi'_l l =\n    psi_l (l + 1)", "then"], ["proof (chain)\npicking this:\n  2 *\n  (alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n   beta_l l * complex_of_real (sin (\\<theta> / 2))) \\<cdot>\\<^sub>v\n  \\<psi> -\n  psi'_l l =\n  alpha_l (l + 1) \\<cdot>\\<^sub>v \\<alpha> +\n  beta_l (l + 1) \\<cdot>\\<^sub>v \\<beta>", "show ?thesis"], ["proof (prove)\nusing this:\n  2 *\n  (alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n   beta_l l * complex_of_real (sin (\\<theta> / 2))) \\<cdot>\\<^sub>v\n  \\<psi> -\n  psi'_l l =\n  alpha_l (l + 1) \\<cdot>\\<^sub>v \\<alpha> +\n  beta_l (l + 1) \\<cdot>\\<^sub>v \\<beta>\n\ngoal (1 subgoal):\n 1. 2 *\n    (alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n     beta_l l * complex_of_real (sin (\\<theta> / 2))) \\<cdot>\\<^sub>v\n    \\<psi> -\n    psi'_l l =\n    psi_l (l + 1)", "unfolding psi_l_def"], ["proof (prove)\nusing this:\n  2 *\n  (alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n   beta_l l * complex_of_real (sin (\\<theta> / 2))) \\<cdot>\\<^sub>v\n  \\<psi> -\n  psi'_l l =\n  alpha_l (l + 1) \\<cdot>\\<^sub>v \\<alpha> +\n  beta_l (l + 1) \\<cdot>\\<^sub>v \\<beta>\n\ngoal (1 subgoal):\n 1. 2 *\n    (alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n     beta_l l * complex_of_real (sin (\\<theta> / 2))) \\<cdot>\\<^sub>v\n    \\<psi> -\n    psi'_l l =\n    alpha_l (l + 1) \\<cdot>\\<^sub>v \\<alpha> +\n    beta_l (l + 1) \\<cdot>\\<^sub>v \\<beta>", "by auto"], ["proof (state)\nthis:\n  2 *\n  (alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n   beta_l l * complex_of_real (sin (\\<theta> / 2))) \\<cdot>\\<^sub>v\n  \\<psi> -\n  psi'_l l =\n  psi_l (l + 1)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Grover operator\\<close>"], ["", "text \\<open>Oracle O\\<close>"], ["", "definition proj_O :: \"complex mat\" where\n  \"proj_O = mat N N (\\<lambda>(i, j). if i = j then (if f i then 1 else 0) else 0)\""], ["", "lemma proj_O_dim:\n  \"proj_O \\<in> carrier_mat N N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proj_O \\<in> carrier_mat N N", "unfolding proj_O_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat N N (\\<lambda>(i, j). if i = j then if f i then 1 else 0 else 0)\n    \\<in> carrier_mat N N", "by auto"], ["", "lemma proj_O_mult_alpha:\n  \"proj_O *\\<^sub>v \\<alpha> = zero_vec N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proj_O *\\<^sub>v \\<alpha> = 0\\<^sub>v N", "by (auto simp add: proj_O_def \\<alpha>_def scalar_prod_def)"], ["", "lemma proj_O_mult_beta:\n  \"proj_O *\\<^sub>v \\<beta> = \\<beta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proj_O *\\<^sub>v \\<beta> = \\<beta>", "by (auto simp add: proj_O_def \\<beta>_def scalar_prod_def sum_only_one_neq_0)"], ["", "definition mat_O :: \"complex mat\" where\n  \"mat_O = mat N N (\\<lambda>(i,j). if i = j then (if f i then -1 else 1) else 0)\""], ["", "lemma mat_O_dim:\n  \"mat_O \\<in> carrier_mat N N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_O \\<in> carrier_mat N N", "unfolding mat_O_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat N N (\\<lambda>(i, j). if i = j then if f i then - 1 else 1 else 0)\n    \\<in> carrier_mat N N", "by auto"], ["", "lemma mat_O_mult_alpha:\n  \"mat_O *\\<^sub>v \\<alpha> = \\<alpha>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_O *\\<^sub>v \\<alpha> = \\<alpha>", "by (auto simp add: mat_O_def \\<alpha>_def scalar_prod_def sum_only_one_neq_0)"], ["", "lemma mat_O_mult_beta:\n  \"mat_O *\\<^sub>v \\<beta> = - \\<beta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_O *\\<^sub>v \\<beta> = - \\<beta>", "by (auto simp add: mat_O_def \\<beta>_def scalar_prod_def sum_only_one_neq_0)"], ["", "lemma hermitian_mat_O:\n  \"hermitian mat_O\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hermitian mat_O", "by (auto simp add: hermitian_def mat_O_def adjoint_eval)"], ["", "lemma unitary_mat_O:\n  \"unitary mat_O\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unitary mat_O", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. unitary mat_O", "have \"mat_O \\<in> carrier_mat N N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_O \\<in> carrier_mat N N", "unfolding mat_O_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat N N (\\<lambda>(i, j). if i = j then if f i then - 1 else 1 else 0)\n    \\<in> carrier_mat N N", "by auto"], ["proof (state)\nthis:\n  mat_O \\<in> carrier_mat N N\n\ngoal (1 subgoal):\n 1. unitary mat_O", "moreover"], ["proof (state)\nthis:\n  mat_O \\<in> carrier_mat N N\n\ngoal (1 subgoal):\n 1. unitary mat_O", "have \"mat_O * adjoint mat_O = mat_O * mat_O\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_O * adjoint mat_O = mat_O * mat_O", "using hermitian_mat_O"], ["proof (prove)\nusing this:\n  hermitian mat_O\n\ngoal (1 subgoal):\n 1. mat_O * adjoint mat_O = mat_O * mat_O", "unfolding hermitian_def"], ["proof (prove)\nusing this:\n  adjoint mat_O = mat_O\n\ngoal (1 subgoal):\n 1. mat_O * adjoint mat_O = mat_O * mat_O", "by auto"], ["proof (state)\nthis:\n  mat_O * adjoint mat_O = mat_O * mat_O\n\ngoal (1 subgoal):\n 1. unitary mat_O", "moreover"], ["proof (state)\nthis:\n  mat_O * adjoint mat_O = mat_O * mat_O\n\ngoal (1 subgoal):\n 1. unitary mat_O", "have \"mat_O * mat_O = 1\\<^sub>m N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_O * mat_O = 1\\<^sub>m N", "apply (rule eq_matI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row (1\\<^sub>m N);\n        j < dim_col (1\\<^sub>m N)\\<rbrakk>\n       \\<Longrightarrow> (mat_O * mat_O) $$ (i, j) = 1\\<^sub>m N $$ (i, j)\n 2. dim_row (mat_O * mat_O) = dim_row (1\\<^sub>m N)\n 3. dim_col (mat_O * mat_O) = dim_col (1\\<^sub>m N)", "unfolding mat_O_def"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row (1\\<^sub>m N);\n        j < dim_col (1\\<^sub>m N)\\<rbrakk>\n       \\<Longrightarrow> (mat N N\n                           (\\<lambda>(i, j).\n                               if i = j then if f i then - 1 else 1\n                               else 0) *\n                          mat N N\n                           (\\<lambda>(i, j).\n                               if i = j then if f i then - 1 else 1\n                               else 0)) $$\n                         (i, j) =\n                         1\\<^sub>m N $$ (i, j)\n 2. dim_row\n     (mat N N\n       (\\<lambda>(i, j). if i = j then if f i then - 1 else 1 else 0) *\n      mat N N\n       (\\<lambda>(i, j). if i = j then if f i then - 1 else 1 else 0)) =\n    dim_row (1\\<^sub>m N)\n 3. dim_col\n     (mat N N\n       (\\<lambda>(i, j). if i = j then if f i then - 1 else 1 else 0) *\n      mat N N\n       (\\<lambda>(i, j). if i = j then if f i then - 1 else 1 else 0)) =\n    dim_col (1\\<^sub>m N)", "apply (simp add: scalar_prod_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < N; j < N\\<rbrakk>\n       \\<Longrightarrow> (f i \\<longrightarrow>\n                          i = j \\<longrightarrow>\n                          (\\<Sum>i = 0..<N.\n                              (if j = i then - 1 else 0) *\n                              (if i = j then if f i then - 1 else 1\n                               else 0)) =\n                          1) \\<and>\n                         (\\<not> f i \\<longrightarrow>\n                          i = j \\<longrightarrow>\n                          (\\<Sum>i = 0..<N.\n                              (if j = i then 1 else 0) *\n                              (if i = j then if f i then - 1 else 1\n                               else 0)) =\n                          1)\n 2. dim_row\n     (mat N N\n       (\\<lambda>(i, j). if i = j then if f i then - 1 else 1 else 0) *\n      mat N N\n       (\\<lambda>(i, j). if i = j then if f i then - 1 else 1 else 0)) =\n    dim_row (1\\<^sub>m N)\n 3. dim_col\n     (mat N N\n       (\\<lambda>(i, j). if i = j then if f i then - 1 else 1 else 0) *\n      mat N N\n       (\\<lambda>(i, j). if i = j then if f i then - 1 else 1 else 0)) =\n    dim_col (1\\<^sub>m N)", "subgoal for i j"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < N; j < N\\<rbrakk>\n    \\<Longrightarrow> (f i \\<longrightarrow>\n                       i = j \\<longrightarrow>\n                       (\\<Sum>i = 0..<N.\n                           (if j = i then - 1 else 0) *\n                           (if i = j then if f i then - 1 else 1 else 0)) =\n                       1) \\<and>\n                      (\\<not> f i \\<longrightarrow>\n                       i = j \\<longrightarrow>\n                       (\\<Sum>i = 0..<N.\n                           (if j = i then 1 else 0) *\n                           (if i = j then if f i then - 1 else 1 else 0)) =\n                       1)", "apply (rule)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>i < N; j < N\\<rbrakk>\n    \\<Longrightarrow> f i \\<longrightarrow>\n                      i = j \\<longrightarrow>\n                      (\\<Sum>i = 0..<N.\n                          (if j = i then - 1 else 0) *\n                          (if i = j then if f i then - 1 else 1 else 0)) =\n                      1\n 2. \\<lbrakk>i < N; j < N\\<rbrakk>\n    \\<Longrightarrow> \\<not> f i \\<longrightarrow>\n                      i = j \\<longrightarrow>\n                      (\\<Sum>i = 0..<N.\n                          (if j = i then 1 else 0) *\n                          (if i = j then if f i then - 1 else 1 else 0)) =\n                      1", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < N; j < N\\<rbrakk>\n    \\<Longrightarrow> f i \\<longrightarrow>\n                      i = j \\<longrightarrow>\n                      (\\<Sum>i = 0..<N.\n                          (if j = i then - 1 else 0) *\n                          (if i = j then if f i then - 1 else 1 else 0)) =\n                      1", "apply (subst sum_only_one_neq_0[of \"{0..<N}\" \"j\"])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>i < N; j < N\\<rbrakk> \\<Longrightarrow> finite {0..<N}\n 2. \\<lbrakk>i < N; j < N\\<rbrakk> \\<Longrightarrow> j \\<in> {0..<N}\n 3. \\<And>ia.\n       \\<lbrakk>i < N; j < N; ia \\<in> {0..<N}; ia \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> (if j = ia then - 1 else 0) *\n                         (if ia = j then if f ia then - 1 else 1 else 0) =\n                         0\n 4. \\<lbrakk>i < N; j < N\\<rbrakk>\n    \\<Longrightarrow> f i \\<longrightarrow>\n                      i = j \\<longrightarrow>\n                      (if j = j then - 1 else 0) *\n                      (if j = j then if f j then - 1 else 1 else 0) =\n                      1", "by auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < N; j < N\\<rbrakk>\n    \\<Longrightarrow> \\<not> f i \\<longrightarrow>\n                      i = j \\<longrightarrow>\n                      (\\<Sum>i = 0..<N.\n                          (if j = i then 1 else 0) *\n                          (if i = j then if f i then - 1 else 1 else 0)) =\n                      1", "apply (subst sum_only_one_neq_0[of \"{0..<N}\" \"j\"])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>i < N; j < N\\<rbrakk> \\<Longrightarrow> finite {0..<N}\n 2. \\<lbrakk>i < N; j < N\\<rbrakk> \\<Longrightarrow> j \\<in> {0..<N}\n 3. \\<And>ia.\n       \\<lbrakk>i < N; j < N; ia \\<in> {0..<N}; ia \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> (if j = ia then 1 else 0) *\n                         (if ia = j then if f ia then - 1 else 1 else 0) =\n                         0\n 4. \\<lbrakk>i < N; j < N\\<rbrakk>\n    \\<Longrightarrow> \\<not> f i \\<longrightarrow>\n                      i = j \\<longrightarrow>\n                      (if j = j then 1 else 0) *\n                      (if j = j then if f j then - 1 else 1 else 0) =\n                      1", "by auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. dim_row\n     (mat N N\n       (\\<lambda>(i, j). if i = j then if f i then - 1 else 1 else 0) *\n      mat N N\n       (\\<lambda>(i, j). if i = j then if f i then - 1 else 1 else 0)) =\n    dim_row (1\\<^sub>m N)\n 2. dim_col\n     (mat N N\n       (\\<lambda>(i, j). if i = j then if f i then - 1 else 1 else 0) *\n      mat N N\n       (\\<lambda>(i, j). if i = j then if f i then - 1 else 1 else 0)) =\n    dim_col (1\\<^sub>m N)", "by auto"], ["proof (state)\nthis:\n  mat_O * mat_O = 1\\<^sub>m N\n\ngoal (1 subgoal):\n 1. unitary mat_O", "ultimately"], ["proof (chain)\npicking this:\n  mat_O \\<in> carrier_mat N N\n  mat_O * adjoint mat_O = mat_O * mat_O\n  mat_O * mat_O = 1\\<^sub>m N", "show ?thesis"], ["proof (prove)\nusing this:\n  mat_O \\<in> carrier_mat N N\n  mat_O * adjoint mat_O = mat_O * mat_O\n  mat_O * mat_O = 1\\<^sub>m N\n\ngoal (1 subgoal):\n 1. unitary mat_O", "unfolding unitary_def inverts_mat_def"], ["proof (prove)\nusing this:\n  mat_O \\<in> carrier_mat N N\n  mat_O * adjoint mat_O = mat_O * mat_O\n  mat_O * mat_O = 1\\<^sub>m N\n\ngoal (1 subgoal):\n 1. mat_O \\<in> carrier_mat (dim_row mat_O) (dim_row mat_O) \\<and>\n    mat_O * adjoint mat_O = 1\\<^sub>m (dim_row mat_O)", "by auto"], ["proof (state)\nthis:\n  unitary mat_O\n\ngoal:\nNo subgoals!", "qed"], ["", "definition mat_Ph :: \"complex mat\" where\n  \"mat_Ph = mat N N (\\<lambda>(i,j). if i = j then if i = 0 then 1 else -1 else 0)\""], ["", "lemma hermitian_mat_Ph:\n  \"hermitian mat_Ph\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hermitian mat_Ph", "unfolding hermitian_def mat_Ph_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. adjoint\n     (mat N N\n       (\\<lambda>(i, j). if i = j then if i = 0 then 1 else - 1 else 0)) =\n    mat N N (\\<lambda>(i, j). if i = j then if i = 0 then 1 else - 1 else 0)", "apply (rule eq_matI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row\n                     (mat N N\n                       (\\<lambda>(i, j).\n                           if i = j then if i = 0 then 1 else - 1 else 0));\n        j < dim_col\n             (mat N N\n               (\\<lambda>(i, j).\n                   if i = j then if i = 0 then 1 else - 1 else 0))\\<rbrakk>\n       \\<Longrightarrow> adjoint\n                          (mat N N\n                            (\\<lambda>(i, j).\n                                if i = j then if i = 0 then 1 else - 1\n                                else 0)) $$\n                         (i, j) =\n                         mat N N\n                          (\\<lambda>(i, j).\n                              if i = j then if i = 0 then 1 else - 1\n                              else 0) $$\n                         (i, j)\n 2. dim_row\n     (adjoint\n       (mat N N\n         (\\<lambda>(i, j).\n             if i = j then if i = 0 then 1 else - 1 else 0))) =\n    dim_row\n     (mat N N\n       (\\<lambda>(i, j). if i = j then if i = 0 then 1 else - 1 else 0))\n 3. dim_col\n     (adjoint\n       (mat N N\n         (\\<lambda>(i, j).\n             if i = j then if i = 0 then 1 else - 1 else 0))) =\n    dim_col\n     (mat N N\n       (\\<lambda>(i, j). if i = j then if i = 0 then 1 else - 1 else 0))", "by (auto simp add: adjoint_eval)"], ["", "lemma unitary_mat_Ph:\n  \"unitary mat_Ph\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unitary mat_Ph", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. unitary mat_Ph", "have \"mat_Ph \\<in> carrier_mat N N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_Ph \\<in> carrier_mat N N", "unfolding mat_Ph_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat N N (\\<lambda>(i, j). if i = j then if i = 0 then 1 else - 1 else 0)\n    \\<in> carrier_mat N N", "by auto"], ["proof (state)\nthis:\n  mat_Ph \\<in> carrier_mat N N\n\ngoal (1 subgoal):\n 1. unitary mat_Ph", "moreover"], ["proof (state)\nthis:\n  mat_Ph \\<in> carrier_mat N N\n\ngoal (1 subgoal):\n 1. unitary mat_Ph", "have \"mat_Ph * adjoint mat_Ph = mat_Ph * mat_Ph\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_Ph * adjoint mat_Ph = mat_Ph * mat_Ph", "using hermitian_mat_Ph"], ["proof (prove)\nusing this:\n  hermitian mat_Ph\n\ngoal (1 subgoal):\n 1. mat_Ph * adjoint mat_Ph = mat_Ph * mat_Ph", "unfolding hermitian_def"], ["proof (prove)\nusing this:\n  adjoint mat_Ph = mat_Ph\n\ngoal (1 subgoal):\n 1. mat_Ph * adjoint mat_Ph = mat_Ph * mat_Ph", "by auto"], ["proof (state)\nthis:\n  mat_Ph * adjoint mat_Ph = mat_Ph * mat_Ph\n\ngoal (1 subgoal):\n 1. unitary mat_Ph", "moreover"], ["proof (state)\nthis:\n  mat_Ph * adjoint mat_Ph = mat_Ph * mat_Ph\n\ngoal (1 subgoal):\n 1. unitary mat_Ph", "have \"mat_Ph * mat_Ph = 1\\<^sub>m N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_Ph * mat_Ph = 1\\<^sub>m N", "apply (rule eq_matI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row (1\\<^sub>m N);\n        j < dim_col (1\\<^sub>m N)\\<rbrakk>\n       \\<Longrightarrow> (mat_Ph * mat_Ph) $$ (i, j) = 1\\<^sub>m N $$ (i, j)\n 2. dim_row (mat_Ph * mat_Ph) = dim_row (1\\<^sub>m N)\n 3. dim_col (mat_Ph * mat_Ph) = dim_col (1\\<^sub>m N)", "unfolding mat_Ph_def"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row (1\\<^sub>m N);\n        j < dim_col (1\\<^sub>m N)\\<rbrakk>\n       \\<Longrightarrow> (mat N N\n                           (\\<lambda>(i, j).\n                               if i = j then if i = 0 then 1 else - 1\n                               else 0) *\n                          mat N N\n                           (\\<lambda>(i, j).\n                               if i = j then if i = 0 then 1 else - 1\n                               else 0)) $$\n                         (i, j) =\n                         1\\<^sub>m N $$ (i, j)\n 2. dim_row\n     (mat N N\n       (\\<lambda>(i, j). if i = j then if i = 0 then 1 else - 1 else 0) *\n      mat N N\n       (\\<lambda>(i, j). if i = j then if i = 0 then 1 else - 1 else 0)) =\n    dim_row (1\\<^sub>m N)\n 3. dim_col\n     (mat N N\n       (\\<lambda>(i, j). if i = j then if i = 0 then 1 else - 1 else 0) *\n      mat N N\n       (\\<lambda>(i, j). if i = j then if i = 0 then 1 else - 1 else 0)) =\n    dim_col (1\\<^sub>m N)", "apply (simp add: scalar_prod_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < N; j < N\\<rbrakk>\n       \\<Longrightarrow> (i = 0 \\<longrightarrow>\n                          j = 0 \\<longrightarrow>\n                          (\\<Sum>i = 0..<N.\n                              (if i = 0 then 1 else 0) *\n                              (if i = 0 then if i = 0 then 1 else - 1\n                               else 0)) =\n                          1) \\<and>\n                         (0 < i \\<longrightarrow>\n                          i = j \\<longrightarrow>\n                          (\\<Sum>i = 0..<N.\n                              (if j = i then - 1 else 0) *\n                              (if i = j then if i = 0 then 1 else - 1\n                               else 0)) =\n                          1)\n 2. dim_row\n     (mat N N\n       (\\<lambda>(i, j). if i = j then if i = 0 then 1 else - 1 else 0) *\n      mat N N\n       (\\<lambda>(i, j). if i = j then if i = 0 then 1 else - 1 else 0)) =\n    dim_row (1\\<^sub>m N)\n 3. dim_col\n     (mat N N\n       (\\<lambda>(i, j). if i = j then if i = 0 then 1 else - 1 else 0) *\n      mat N N\n       (\\<lambda>(i, j). if i = j then if i = 0 then 1 else - 1 else 0)) =\n    dim_col (1\\<^sub>m N)", "subgoal for i j"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < N; j < N\\<rbrakk>\n    \\<Longrightarrow> (i = 0 \\<longrightarrow>\n                       j = 0 \\<longrightarrow>\n                       (\\<Sum>i = 0..<N.\n                           (if i = 0 then 1 else 0) *\n                           (if i = 0 then if i = 0 then 1 else - 1\n                            else 0)) =\n                       1) \\<and>\n                      (0 < i \\<longrightarrow>\n                       i = j \\<longrightarrow>\n                       (\\<Sum>i = 0..<N.\n                           (if j = i then - 1 else 0) *\n                           (if i = j then if i = 0 then 1 else - 1\n                            else 0)) =\n                       1)", "apply (rule)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>i < N; j < N\\<rbrakk>\n    \\<Longrightarrow> i = 0 \\<longrightarrow>\n                      j = 0 \\<longrightarrow>\n                      (\\<Sum>i = 0..<N.\n                          (if i = 0 then 1 else 0) *\n                          (if i = 0 then if i = 0 then 1 else - 1 else 0)) =\n                      1\n 2. \\<lbrakk>i < N; j < N\\<rbrakk>\n    \\<Longrightarrow> 0 < i \\<longrightarrow>\n                      i = j \\<longrightarrow>\n                      (\\<Sum>i = 0..<N.\n                          (if j = i then - 1 else 0) *\n                          (if i = j then if i = 0 then 1 else - 1 else 0)) =\n                      1", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < N; j < N\\<rbrakk>\n    \\<Longrightarrow> i = 0 \\<longrightarrow>\n                      j = 0 \\<longrightarrow>\n                      (\\<Sum>i = 0..<N.\n                          (if i = 0 then 1 else 0) *\n                          (if i = 0 then if i = 0 then 1 else - 1 else 0)) =\n                      1", "apply (subst sum_only_one_neq_0[of \"{0..<N}\" \"0\"])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>i < N; j < N\\<rbrakk> \\<Longrightarrow> finite {0..<N}\n 2. \\<lbrakk>i < N; j < N\\<rbrakk> \\<Longrightarrow> 0 \\<in> {0..<N}\n 3. \\<And>ia.\n       \\<lbrakk>i < N; j < N; ia \\<in> {0..<N}; ia \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> (if ia = 0 then 1 else 0) *\n                         (if ia = 0 then if ia = 0 then 1 else - 1 else 0) =\n                         0\n 4. \\<lbrakk>i < N; j < N\\<rbrakk>\n    \\<Longrightarrow> i = 0 \\<longrightarrow>\n                      j = 0 \\<longrightarrow>\n                      (if 0 = 0 then 1 else 0) *\n                      (if 0 = 0 then if 0 = 0 then 1 else - 1 else 0) =\n                      1", "by auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < N; j < N\\<rbrakk>\n    \\<Longrightarrow> 0 < i \\<longrightarrow>\n                      i = j \\<longrightarrow>\n                      (\\<Sum>i = 0..<N.\n                          (if j = i then - 1 else 0) *\n                          (if i = j then if i = 0 then 1 else - 1 else 0)) =\n                      1", "apply (subst sum_only_one_neq_0[of \"{0..<N}\" \"j\"])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>i < N; j < N\\<rbrakk> \\<Longrightarrow> finite {0..<N}\n 2. \\<lbrakk>i < N; j < N\\<rbrakk> \\<Longrightarrow> j \\<in> {0..<N}\n 3. \\<And>ia.\n       \\<lbrakk>i < N; j < N; ia \\<in> {0..<N}; ia \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> (if j = ia then - 1 else 0) *\n                         (if ia = j then if ia = 0 then 1 else - 1 else 0) =\n                         0\n 4. \\<lbrakk>i < N; j < N\\<rbrakk>\n    \\<Longrightarrow> 0 < i \\<longrightarrow>\n                      i = j \\<longrightarrow>\n                      (if j = j then - 1 else 0) *\n                      (if j = j then if j = 0 then 1 else - 1 else 0) =\n                      1", "by auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. dim_row\n     (mat N N\n       (\\<lambda>(i, j). if i = j then if i = 0 then 1 else - 1 else 0) *\n      mat N N\n       (\\<lambda>(i, j). if i = j then if i = 0 then 1 else - 1 else 0)) =\n    dim_row (1\\<^sub>m N)\n 2. dim_col\n     (mat N N\n       (\\<lambda>(i, j). if i = j then if i = 0 then 1 else - 1 else 0) *\n      mat N N\n       (\\<lambda>(i, j). if i = j then if i = 0 then 1 else - 1 else 0)) =\n    dim_col (1\\<^sub>m N)", "by auto"], ["proof (state)\nthis:\n  mat_Ph * mat_Ph = 1\\<^sub>m N\n\ngoal (1 subgoal):\n 1. unitary mat_Ph", "ultimately"], ["proof (chain)\npicking this:\n  mat_Ph \\<in> carrier_mat N N\n  mat_Ph * adjoint mat_Ph = mat_Ph * mat_Ph\n  mat_Ph * mat_Ph = 1\\<^sub>m N", "show ?thesis"], ["proof (prove)\nusing this:\n  mat_Ph \\<in> carrier_mat N N\n  mat_Ph * adjoint mat_Ph = mat_Ph * mat_Ph\n  mat_Ph * mat_Ph = 1\\<^sub>m N\n\ngoal (1 subgoal):\n 1. unitary mat_Ph", "unfolding unitary_def inverts_mat_def"], ["proof (prove)\nusing this:\n  mat_Ph \\<in> carrier_mat N N\n  mat_Ph * adjoint mat_Ph = mat_Ph * mat_Ph\n  mat_Ph * mat_Ph = 1\\<^sub>m N\n\ngoal (1 subgoal):\n 1. mat_Ph \\<in> carrier_mat (dim_row mat_Ph) (dim_row mat_Ph) \\<and>\n    mat_Ph * adjoint mat_Ph = 1\\<^sub>m (dim_row mat_Ph)", "by auto"], ["proof (state)\nthis:\n  unitary mat_Ph\n\ngoal:\nNo subgoals!", "qed"], ["", "definition mat_G' :: \"complex mat\" where\n  \"mat_G' = mat N N (\\<lambda>(i,j). if i = j then 2 / N - 1 else 2 / N)\""], ["", "text \\<open>Geometrically, the Grover operator G is a rotation\\<close>"], ["", "definition mat_G :: \"complex mat\" where\n  \"mat_G = mat_G' * mat_O\""], ["", "end"], ["", "subsection \\<open>State of Grover's algorithm\\<close>"], ["", "text \\<open>The dimensions are [2, 2, ..., 2, n]. We work with a very special\n  case as in the paper\\<close>"], ["", "locale grover_state_sig = grover_state + state_sig +\n  fixes R :: nat\n  fixes K :: nat\n  assumes dims_def: \"dims = replicate n 2 @ [K]\"\n  assumes R: \"R = pi / (2 * \\<theta>) - 1 / 2\"\n  assumes K: \"K > R\"\n\nbegin"], ["", "lemma K_gt_0:\n  \"K > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < K", "using K"], ["proof (prove)\nusing this:\n  R < K\n\ngoal (1 subgoal):\n 1. 0 < K", "by auto"], ["", "text \\<open>Bits q0 to q\\_(n-1)\\<close>"], ["", "definition vars1 :: \"nat set\" where\n  \"vars1 = {0 ..< n}\""], ["", "text \\<open>Bit r\\<close>"], ["", "definition vars2 :: \"nat set\" where\n  \"vars2 = {n}\""], ["", "lemma length_dims:\n  \"length dims = n + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length dims = n + 1", "unfolding dims_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (replicate n 2 @ [K]) = n + 1", "by auto"], ["", "lemma dims_nth_lt_n:\n  \"l < n \\<Longrightarrow> nth dims l = 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l < n \\<Longrightarrow> dims ! l = 2", "unfolding dims_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. l < n \\<Longrightarrow> (replicate n 2 @ [K]) ! l = 2", "by (simp add: nth_append)"], ["", "lemma nths_Suc_n_dims:\n  \"nths dims {0..<(Suc n)} = dims\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nths dims {0..<Suc n} = dims", "using length_dims nths_upt_eq_take"], ["proof (prove)\nusing this:\n  length dims = n + 1\n  nths ?l {..<?n} = take ?n ?l\n\ngoal (1 subgoal):\n 1. nths dims {0..<Suc n} = dims", "by (metis add_Suc_right add_Suc_shift lessThan_atLeast0 less_add_eq_less less_numeral_extra(4)\n            not_less plus_1_eq_Suc take_all)"], ["", "interpretation ps2_P: partial_state2 dims vars1 vars2"], ["proof (prove)\ngoal (1 subgoal):\n 1. partial_state2 vars1 vars2", "apply unfold_locales"], ["proof (prove)\ngoal (1 subgoal):\n 1. vars1 \\<inter> vars2 = {}", "unfolding vars1_def vars2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {0..<n} \\<inter> {n} = {}", "by auto"], ["", "interpretation ps_P: partial_state ps2_P.dims0 ps2_P.vars1'"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "abbreviation tensor_P where\n\"tensor_P A B \\<equiv> ps2_P.ptensor_mat A B\""], ["", "lemma tensor_P_dim:\n  \"tensor_P A B \\<in> carrier_mat d d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tensor_P A B \\<in> carrier_mat d d", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. tensor_P A B \\<in> carrier_mat d d", "have \"ps2_P.d0 = prod_list (nths dims ({0..<n} \\<union> {n}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ps2_P.d0 = prod_list (nths dims ({0..<n} \\<union> {n}))", "unfolding ps2_P.d0_def ps2_P.dims0_def ps2_P.vars0_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. prod_list (nths dims (vars1 \\<union> vars2)) =\n    prod_list (nths dims ({0..<n} \\<union> {n}))", "by (simp add: vars1_def vars2_def)"], ["proof (state)\nthis:\n  ps2_P.d0 = prod_list (nths dims ({0..<n} \\<union> {n}))\n\ngoal (1 subgoal):\n 1. tensor_P A B \\<in> carrier_mat d d", "also"], ["proof (state)\nthis:\n  ps2_P.d0 = prod_list (nths dims ({0..<n} \\<union> {n}))\n\ngoal (1 subgoal):\n 1. tensor_P A B \\<in> carrier_mat d d", "have \"\\<dots> = prod_list (nths dims ({0..<Suc n}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod_list (nths dims ({0..<n} \\<union> {n})) =\n    prod_list (nths dims {0..<Suc n})", "apply (subgoal_tac \"{0..<n} \\<union> {n} = {0..<(Suc n)}\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. {0..<n} \\<union> {n} = {0..<Suc n} \\<Longrightarrow>\n    prod_list (nths dims ({0..<n} \\<union> {n})) =\n    prod_list (nths dims {0..<Suc n})\n 2. {0..<n} \\<union> {n} = {0..<Suc n}", "by auto"], ["proof (state)\nthis:\n  prod_list (nths dims ({0..<n} \\<union> {n})) =\n  prod_list (nths dims {0..<Suc n})\n\ngoal (1 subgoal):\n 1. tensor_P A B \\<in> carrier_mat d d", "also"], ["proof (state)\nthis:\n  prod_list (nths dims ({0..<n} \\<union> {n})) =\n  prod_list (nths dims {0..<Suc n})\n\ngoal (1 subgoal):\n 1. tensor_P A B \\<in> carrier_mat d d", "have \"\\<dots> = prod_list dims\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod_list (nths dims {0..<Suc n}) = prod_list dims", "using nths_Suc_n_dims"], ["proof (prove)\nusing this:\n  nths dims {0..<Suc n} = dims\n\ngoal (1 subgoal):\n 1. prod_list (nths dims {0..<Suc n}) = prod_list dims", "by auto"], ["proof (state)\nthis:\n  prod_list (nths dims {0..<Suc n}) = prod_list dims\n\ngoal (1 subgoal):\n 1. tensor_P A B \\<in> carrier_mat d d", "also"], ["proof (state)\nthis:\n  prod_list (nths dims {0..<Suc n}) = prod_list dims\n\ngoal (1 subgoal):\n 1. tensor_P A B \\<in> carrier_mat d d", "have \"\\<dots> = d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod_list dims = d", "unfolding d_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. prod_list dims = prod_list dims", "by auto"], ["proof (state)\nthis:\n  prod_list dims = d\n\ngoal (1 subgoal):\n 1. tensor_P A B \\<in> carrier_mat d d", "finally"], ["proof (chain)\npicking this:\n  ps2_P.d0 = d", "show ?thesis"], ["proof (prove)\nusing this:\n  ps2_P.d0 = d\n\ngoal (1 subgoal):\n 1. tensor_P A B \\<in> carrier_mat d d", "using ps2_P.ptensor_mat_carrier"], ["proof (prove)\nusing this:\n  ps2_P.d0 = d\n  tensor_P ?m1.0 ?m2.0 \\<in> carrier_mat ps2_P.d0 ps2_P.d0\n\ngoal (1 subgoal):\n 1. tensor_P A B \\<in> carrier_mat d d", "by auto"], ["proof (state)\nthis:\n  tensor_P A B \\<in> carrier_mat d d\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma dims_nths_le_n:\n  assumes \"l \\<le> n\"\n  shows \"nths dims {0..<l} = replicate l 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nths dims {0..<l} = replicate l 2", "proof (rule nth_equalityI, auto)"], ["proof (state)\ngoal (2 subgoals):\n 1. length (nths dims {0..<l}) = l\n 2. \\<And>i.\n       i < length (nths dims {0..<l}) \\<Longrightarrow>\n       nths dims {0..<l} ! i = replicate l 2 ! i", "have \"l \\<le> n \\<Longrightarrow> (i < Suc n \\<and> i < l) = (i < l)\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. l \\<le> n \\<Longrightarrow> (i < Suc n \\<and> i < l) = (i < l)", "using less_trans"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x < ?y; ?y < ?z\\<rbrakk> \\<Longrightarrow> ?x < ?z\n\ngoal (1 subgoal):\n 1. l \\<le> n \\<Longrightarrow> (i < Suc n \\<and> i < l) = (i < l)", "by fastforce"], ["proof (state)\nthis:\n  l \\<le> n \\<Longrightarrow> (?i2 < Suc n \\<and> ?i2 < l) = (?i2 < l)\n\ngoal (2 subgoals):\n 1. length (nths dims {0..<l}) = l\n 2. \\<And>i.\n       i < length (nths dims {0..<l}) \\<Longrightarrow>\n       nths dims {0..<l} ! i = replicate l 2 ! i", "then"], ["proof (chain)\npicking this:\n  l \\<le> n \\<Longrightarrow> (?i2 < Suc n \\<and> ?i2 < l) = (?i2 < l)", "show l: \"length (nths dims {0..<l}) = l\""], ["proof (prove)\nusing this:\n  l \\<le> n \\<Longrightarrow> (?i2 < Suc n \\<and> ?i2 < l) = (?i2 < l)\n\ngoal (1 subgoal):\n 1. length (nths dims {0..<l}) = l", "using assms"], ["proof (prove)\nusing this:\n  l \\<le> n \\<Longrightarrow> (?i2 < Suc n \\<and> ?i2 < l) = (?i2 < l)\n  l \\<le> n\n\ngoal (1 subgoal):\n 1. length (nths dims {0..<l}) = l", "by (auto simp add: length_nths length_dims)"], ["proof (state)\nthis:\n  length (nths dims {0..<l}) = l\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length (nths dims {0..<l}) \\<Longrightarrow>\n       nths dims {0..<l} ! i = replicate l 2 ! i", "have llt: \"l < length dims\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l < length dims", "using length_dims assms"], ["proof (prove)\nusing this:\n  length dims = n + 1\n  l \\<le> n\n\ngoal (1 subgoal):\n 1. l < length dims", "by auto"], ["proof (state)\nthis:\n  l < length dims\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length (nths dims {0..<l}) \\<Longrightarrow>\n       nths dims {0..<l} ! i = replicate l 2 ! i", "have v1: \"\\<And>i. i < l \\<Longrightarrow> {a. a < i \\<and> a \\<in> {0..<l}} = {0..<i}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < l \\<Longrightarrow> {a. a < i \\<and> a \\<in> {0..<l}} = {0..<i}", "unfolding vars1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < l \\<Longrightarrow> {a. a < i \\<and> a \\<in> {0..<l}} = {0..<i}", "by auto"], ["proof (state)\nthis:\n  ?i2 < l \\<Longrightarrow> {a. a < ?i2 \\<and> a \\<in> {0..<l}} = {0..<?i2}\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length (nths dims {0..<l}) \\<Longrightarrow>\n       nths dims {0..<l} ! i = replicate l 2 ! i", "then"], ["proof (chain)\npicking this:\n  ?i2 < l \\<Longrightarrow> {a. a < ?i2 \\<and> a \\<in> {0..<l}} = {0..<?i2}", "have \"\\<And>i. i < l \\<Longrightarrow> card {j. j < i \\<and> j \\<in> {0..<l}} = i\""], ["proof (prove)\nusing this:\n  ?i2 < l \\<Longrightarrow> {a. a < ?i2 \\<and> a \\<in> {0..<l}} = {0..<?i2}\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < l \\<Longrightarrow> card {j. j < i \\<and> j \\<in> {0..<l}} = i", "by auto"], ["proof (state)\nthis:\n  ?i2 < l \\<Longrightarrow> card {j. j < ?i2 \\<and> j \\<in> {0..<l}} = ?i2\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length (nths dims {0..<l}) \\<Longrightarrow>\n       nths dims {0..<l} ! i = replicate l 2 ! i", "then"], ["proof (chain)\npicking this:\n  ?i2 < l \\<Longrightarrow> card {j. j < ?i2 \\<and> j \\<in> {0..<l}} = ?i2", "have \"nths dims {0..<l} ! i = dims ! i\" if \"i < l\" for i"], ["proof (prove)\nusing this:\n  ?i2 < l \\<Longrightarrow> card {j. j < ?i2 \\<and> j \\<in> {0..<l}} = ?i2\n\ngoal (1 subgoal):\n 1. nths dims {0..<l} ! i = dims ! i", "using nth_nths_card[of i dims \"{0..<l}\"] that llt"], ["proof (prove)\nusing this:\n  ?i2 < l \\<Longrightarrow> card {j. j < ?i2 \\<and> j \\<in> {0..<l}} = ?i2\n  \\<lbrakk>i < length dims; i \\<in> {0..<l}\\<rbrakk>\n  \\<Longrightarrow> nths dims {0..<l} !\n                    card {j0. j0 < i \\<and> j0 \\<in> {0..<l}} =\n                    dims ! i\n  i < l\n  l < length dims\n\ngoal (1 subgoal):\n 1. nths dims {0..<l} ! i = dims ! i", "by auto"], ["proof (state)\nthis:\n  ?i2 < l \\<Longrightarrow> nths dims {0..<l} ! ?i2 = dims ! ?i2\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length (nths dims {0..<l}) \\<Longrightarrow>\n       nths dims {0..<l} ! i = replicate l 2 ! i", "moreover"], ["proof (state)\nthis:\n  ?i2 < l \\<Longrightarrow> nths dims {0..<l} ! ?i2 = dims ! ?i2\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length (nths dims {0..<l}) \\<Longrightarrow>\n       nths dims {0..<l} ! i = replicate l 2 ! i", "have \"dims ! i = replicate n 2 ! i\" if \"i < n\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. dims ! i = replicate n 2 ! i", "unfolding dims_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (replicate n 2 @ [K]) ! i = replicate n 2 ! i", "by (auto simp add: nth_append that)"], ["proof (state)\nthis:\n  ?i2 < n \\<Longrightarrow> dims ! ?i2 = replicate n 2 ! ?i2\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length (nths dims {0..<l}) \\<Longrightarrow>\n       nths dims {0..<l} ! i = replicate l 2 ! i", "moreover"], ["proof (state)\nthis:\n  ?i2 < n \\<Longrightarrow> dims ! ?i2 = replicate n 2 ! ?i2\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length (nths dims {0..<l}) \\<Longrightarrow>\n       nths dims {0..<l} ! i = replicate l 2 ! i", "have \"replicate n 2 ! i = replicate l 2 ! i\" if \"i < l\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. replicate n (2::'a) ! i = replicate l (2::'a) ! i", "using assms that"], ["proof (prove)\nusing this:\n  l \\<le> n\n  i < l\n\ngoal (1 subgoal):\n 1. replicate n (2::'a) ! i = replicate l (2::'a) ! i", "by auto"], ["proof (state)\nthis:\n  ?i3 < l \\<Longrightarrow>\n  replicate n (2::?'a4) ! ?i3 = replicate l (2::?'a4) ! ?i3\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length (nths dims {0..<l}) \\<Longrightarrow>\n       nths dims {0..<l} ! i = replicate l 2 ! i", "ultimately"], ["proof (chain)\npicking this:\n  ?i2 < l \\<Longrightarrow> nths dims {0..<l} ! ?i2 = dims ! ?i2\n  ?i2 < n \\<Longrightarrow> dims ! ?i2 = replicate n 2 ! ?i2\n  ?i3 < l \\<Longrightarrow>\n  replicate n (2::?'a4) ! ?i3 = replicate l (2::?'a4) ! ?i3", "show \"nths dims {0..<l} ! i = replicate l 2 ! i\" if \"i < length (nths dims {0..<l})\" for i"], ["proof (prove)\nusing this:\n  ?i2 < l \\<Longrightarrow> nths dims {0..<l} ! ?i2 = dims ! ?i2\n  ?i2 < n \\<Longrightarrow> dims ! ?i2 = replicate n 2 ! ?i2\n  ?i3 < l \\<Longrightarrow>\n  replicate n (2::?'a4) ! ?i3 = replicate l (2::?'a4) ! ?i3\n\ngoal (1 subgoal):\n 1. nths dims {0..<l} ! i = replicate l 2 ! i", "using l that assms"], ["proof (prove)\nusing this:\n  ?i2 < l \\<Longrightarrow> nths dims {0..<l} ! ?i2 = dims ! ?i2\n  ?i2 < n \\<Longrightarrow> dims ! ?i2 = replicate n 2 ! ?i2\n  ?i3 < l \\<Longrightarrow>\n  replicate n (2::?'a4) ! ?i3 = replicate l (2::?'a4) ! ?i3\n  length (nths dims {0..<l}) = l\n  i < length (nths dims {0..<l})\n  l \\<le> n\n\ngoal (1 subgoal):\n 1. nths dims {0..<l} ! i = replicate l 2 ! i", "by auto"], ["proof (state)\nthis:\n  ?i3 < length (nths dims {0..<l}) \\<Longrightarrow>\n  nths dims {0..<l} ! ?i3 = replicate l 2 ! ?i3\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma dims_nths_one_lt_n: \n  assumes \"l < n\"\n  shows \"nths dims {l} = [2]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nths dims {l} = [2]", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. nths dims {l} = [2]", "have \"{i. i < length dims \\<and> i \\<in> {l}} = {l}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {i. i < length dims \\<and> i \\<in> {l}} = {l}", "using assms length_dims"], ["proof (prove)\nusing this:\n  l < n\n  length dims = n + 1\n\ngoal (1 subgoal):\n 1. {i. i < length dims \\<and> i \\<in> {l}} = {l}", "by auto"], ["proof (state)\nthis:\n  {i. i < length dims \\<and> i \\<in> {l}} = {l}\n\ngoal (1 subgoal):\n 1. nths dims {l} = [2]", "then"], ["proof (chain)\npicking this:\n  {i. i < length dims \\<and> i \\<in> {l}} = {l}", "have \"nths dims {l} = [dims ! l]\""], ["proof (prove)\nusing this:\n  {i. i < length dims \\<and> i \\<in> {l}} = {l}\n\ngoal (1 subgoal):\n 1. nths dims {l} = [dims ! l]", "using nths_only_one[of dims \"{l}\" l]"], ["proof (prove)\nusing this:\n  {i. i < length dims \\<and> i \\<in> {l}} = {l}\n  {i. i < length dims \\<and> i \\<in> {l}} = {l} \\<Longrightarrow>\n  nths dims {l} = [dims ! l]\n\ngoal (1 subgoal):\n 1. nths dims {l} = [dims ! l]", "by auto"], ["proof (state)\nthis:\n  nths dims {l} = [dims ! l]\n\ngoal (1 subgoal):\n 1. nths dims {l} = [2]", "moreover"], ["proof (state)\nthis:\n  nths dims {l} = [dims ! l]\n\ngoal (1 subgoal):\n 1. nths dims {l} = [2]", "have \"dims ! l = 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dims ! l = 2", "unfolding dims_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (replicate n 2 @ [K]) ! l = 2", "using assms"], ["proof (prove)\nusing this:\n  l < n\n\ngoal (1 subgoal):\n 1. (replicate n 2 @ [K]) ! l = 2", "by (simp add: nth_append)"], ["proof (state)\nthis:\n  dims ! l = 2\n\ngoal (1 subgoal):\n 1. nths dims {l} = [2]", "ultimately"], ["proof (chain)\npicking this:\n  nths dims {l} = [dims ! l]\n  dims ! l = 2", "show ?thesis"], ["proof (prove)\nusing this:\n  nths dims {l} = [dims ! l]\n  dims ! l = 2\n\ngoal (1 subgoal):\n 1. nths dims {l} = [2]", "by auto"], ["proof (state)\nthis:\n  nths dims {l} = [2]\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma dims_vars1:\n  \"nths dims vars1 = replicate n 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nths dims vars1 = replicate n 2", "proof (rule nth_equalityI, auto)"], ["proof (state)\ngoal (2 subgoals):\n 1. length (nths dims vars1) = n\n 2. \\<And>i.\n       i < length (nths dims vars1) \\<Longrightarrow>\n       nths dims vars1 ! i = replicate n 2 ! i", "show l: \"length (nths dims vars1) = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (nths dims vars1) = n", "apply (auto simp add: length_nths vars1_def length_dims)"], ["proof (prove)\ngoal (1 subgoal):\n 1. card {i. i < Suc n \\<and> i < n} = n", "by (metis (no_types, lifting) Collect_cong Suc_lessD card_Collect_less_nat not_less_eq)"], ["proof (state)\nthis:\n  length (nths dims vars1) = n\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length (nths dims vars1) \\<Longrightarrow>\n       nths dims vars1 ! i = replicate n 2 ! i", "have v1: \"\\<And>i. i < n \\<Longrightarrow> {a. a < i \\<and> a \\<in> vars1} = {0..<i}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < n \\<Longrightarrow> {a. a < i \\<and> a \\<in> vars1} = {0..<i}", "unfolding vars1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < n \\<Longrightarrow> {a. a < i \\<and> a \\<in> {0..<n}} = {0..<i}", "by auto"], ["proof (state)\nthis:\n  ?i2 < n \\<Longrightarrow> {a. a < ?i2 \\<and> a \\<in> vars1} = {0..<?i2}\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length (nths dims vars1) \\<Longrightarrow>\n       nths dims vars1 ! i = replicate n 2 ! i", "then"], ["proof (chain)\npicking this:\n  ?i2 < n \\<Longrightarrow> {a. a < ?i2 \\<and> a \\<in> vars1} = {0..<?i2}", "have \"\\<And>i. i < n \\<Longrightarrow> card {j. j < i \\<and> j \\<in> vars1} = i\""], ["proof (prove)\nusing this:\n  ?i2 < n \\<Longrightarrow> {a. a < ?i2 \\<and> a \\<in> vars1} = {0..<?i2}\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < n \\<Longrightarrow> card {j. j < i \\<and> j \\<in> vars1} = i", "by auto"], ["proof (state)\nthis:\n  ?i2 < n \\<Longrightarrow> card {j. j < ?i2 \\<and> j \\<in> vars1} = ?i2\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length (nths dims vars1) \\<Longrightarrow>\n       nths dims vars1 ! i = replicate n 2 ! i", "then"], ["proof (chain)\npicking this:\n  ?i2 < n \\<Longrightarrow> card {j. j < ?i2 \\<and> j \\<in> vars1} = ?i2", "have \"nths dims vars1 ! i = dims ! i\" if \"i < n\" for i"], ["proof (prove)\nusing this:\n  ?i2 < n \\<Longrightarrow> card {j. j < ?i2 \\<and> j \\<in> vars1} = ?i2\n\ngoal (1 subgoal):\n 1. nths dims vars1 ! i = dims ! i", "using nth_nths_card[of i dims vars1] that length_dims vars1_def"], ["proof (prove)\nusing this:\n  ?i2 < n \\<Longrightarrow> card {j. j < ?i2 \\<and> j \\<in> vars1} = ?i2\n  \\<lbrakk>i < length dims; i \\<in> vars1\\<rbrakk>\n  \\<Longrightarrow> nths dims vars1 !\n                    card {j0. j0 < i \\<and> j0 \\<in> vars1} =\n                    dims ! i\n  i < n\n  length dims = n + 1\n  vars1 = {0..<n}\n\ngoal (1 subgoal):\n 1. nths dims vars1 ! i = dims ! i", "by auto"], ["proof (state)\nthis:\n  ?i2 < n \\<Longrightarrow> nths dims vars1 ! ?i2 = dims ! ?i2\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length (nths dims vars1) \\<Longrightarrow>\n       nths dims vars1 ! i = replicate n 2 ! i", "moreover"], ["proof (state)\nthis:\n  ?i2 < n \\<Longrightarrow> nths dims vars1 ! ?i2 = dims ! ?i2\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length (nths dims vars1) \\<Longrightarrow>\n       nths dims vars1 ! i = replicate n 2 ! i", "have \"dims ! i = replicate n 2 ! i\" if \"i < n\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. dims ! i = replicate n 2 ! i", "unfolding dims_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (replicate n 2 @ [K]) ! i = replicate n 2 ! i", "by (simp add: nth_append that)"], ["proof (state)\nthis:\n  ?i2 < n \\<Longrightarrow> dims ! ?i2 = replicate n 2 ! ?i2\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length (nths dims vars1) \\<Longrightarrow>\n       nths dims vars1 ! i = replicate n 2 ! i", "ultimately"], ["proof (chain)\npicking this:\n  ?i2 < n \\<Longrightarrow> nths dims vars1 ! ?i2 = dims ! ?i2\n  ?i2 < n \\<Longrightarrow> dims ! ?i2 = replicate n 2 ! ?i2", "show \"nths dims vars1 ! i = replicate n 2 ! i\" if \"i < length (nths dims vars1)\" for i"], ["proof (prove)\nusing this:\n  ?i2 < n \\<Longrightarrow> nths dims vars1 ! ?i2 = dims ! ?i2\n  ?i2 < n \\<Longrightarrow> dims ! ?i2 = replicate n 2 ! ?i2\n\ngoal (1 subgoal):\n 1. nths dims vars1 ! i = replicate n 2 ! i", "using l that"], ["proof (prove)\nusing this:\n  ?i2 < n \\<Longrightarrow> nths dims vars1 ! ?i2 = dims ! ?i2\n  ?i2 < n \\<Longrightarrow> dims ! ?i2 = replicate n 2 ! ?i2\n  length (nths dims vars1) = n\n  i < length (nths dims vars1)\n\ngoal (1 subgoal):\n 1. nths dims vars1 ! i = replicate n 2 ! i", "by auto"], ["proof (state)\nthis:\n  ?i2 < length (nths dims vars1) \\<Longrightarrow>\n  nths dims vars1 ! ?i2 = replicate n 2 ! ?i2\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma nths_rep_2_n:\n  \"nths (replicate n 2) {n} = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nths (replicate n (2::'a)) {n} = []", "by (metis (no_types, lifting) Collect_empty_eq card.empty length_0_conv length_replicate less_Suc_eq not_less_eq nths_replicate singletonD)"], ["", "lemma dims_vars2:\n  \"nths dims vars2 = [K]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nths dims vars2 = [K]", "unfolding dims_def vars2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. nths (replicate n 2 @ [K]) {n} = [K]", "apply (subst nths_append)"], ["proof (prove)\ngoal (1 subgoal):\n 1. nths (replicate n 2) {n} @\n    nths [K] {j. j + length (replicate n 2) \\<in> {n}} =\n    [K]", "apply (subst nths_rep_2_n)"], ["proof (prove)\ngoal (1 subgoal):\n 1. [] @ nths [K] {j. j + length (replicate n 2) \\<in> {n}} = [K]", "by simp"], ["", "lemma d_vars1:\n  \"prod_list (nths dims vars1) = N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod_list (nths dims vars1) = N", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. prod_list (nths dims vars1) = N", "have eq: \"{0..<n} = {..<n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {0..<n} = {..<n}", "by auto"], ["proof (state)\nthis:\n  {0..<n} = {..<n}\n\ngoal (1 subgoal):\n 1. prod_list (nths dims vars1) = N", "have \"nths (replicate n 2 @ [K]) {0..<n} = (replicate n 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nths (replicate n 2 @ [K]) {0..<n} = replicate n 2", "apply (subst eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. nths (replicate n 2 @ [K]) {..<n} = replicate n 2", "using nths_upt_eq_take"], ["proof (prove)\nusing this:\n  nths ?l {..<?n} = take ?n ?l\n\ngoal (1 subgoal):\n 1. nths (replicate n 2 @ [K]) {..<n} = replicate n 2", "by simp"], ["proof (state)\nthis:\n  nths (replicate n 2 @ [K]) {0..<n} = replicate n 2\n\ngoal (1 subgoal):\n 1. prod_list (nths dims vars1) = N", "then"], ["proof (chain)\npicking this:\n  nths (replicate n 2 @ [K]) {0..<n} = replicate n 2", "show ?thesis"], ["proof (prove)\nusing this:\n  nths (replicate n 2 @ [K]) {0..<n} = replicate n 2\n\ngoal (1 subgoal):\n 1. prod_list (nths dims vars1) = N", "unfolding dims_def vars1_def N_def"], ["proof (prove)\nusing this:\n  nths (replicate n 2 @ [K]) {0..<n} = replicate n 2\n\ngoal (1 subgoal):\n 1. prod_list (nths (replicate n 2 @ [K]) {0..<n}) = 2 ^ n", "by auto"], ["proof (state)\nthis:\n  prod_list (nths dims vars1) = N\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ps2_P_dims0:\n  \"ps2_P.dims0 = dims\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ps2_P.dims0 = dims", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ps2_P.dims0 = dims", "have \"vars1 \\<union> vars2 = {0..<Suc n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vars1 \\<union> vars2 = {0..<Suc n}", "unfolding vars1_def vars2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {0..<n} \\<union> {n} = {0..<Suc n}", "by auto"], ["proof (state)\nthis:\n  vars1 \\<union> vars2 = {0..<Suc n}\n\ngoal (1 subgoal):\n 1. ps2_P.dims0 = dims", "then"], ["proof (chain)\npicking this:\n  vars1 \\<union> vars2 = {0..<Suc n}", "have dims: \"nths dims (vars1 \\<union> vars2) = dims\""], ["proof (prove)\nusing this:\n  vars1 \\<union> vars2 = {0..<Suc n}\n\ngoal (1 subgoal):\n 1. nths dims (vars1 \\<union> vars2) = dims", "unfolding vars1_def vars2_def"], ["proof (prove)\nusing this:\n  {0..<n} \\<union> {n} = {0..<Suc n}\n\ngoal (1 subgoal):\n 1. nths dims ({0..<n} \\<union> {n}) = dims", "using nths_Suc_n_dims"], ["proof (prove)\nusing this:\n  {0..<n} \\<union> {n} = {0..<Suc n}\n  nths dims {0..<Suc n} = dims\n\ngoal (1 subgoal):\n 1. nths dims ({0..<n} \\<union> {n}) = dims", "by auto"], ["proof (state)\nthis:\n  nths dims (vars1 \\<union> vars2) = dims\n\ngoal (1 subgoal):\n 1. ps2_P.dims0 = dims", "then"], ["proof (chain)\npicking this:\n  nths dims (vars1 \\<union> vars2) = dims", "show ?thesis"], ["proof (prove)\nusing this:\n  nths dims (vars1 \\<union> vars2) = dims\n\ngoal (1 subgoal):\n 1. ps2_P.dims0 = dims", "unfolding ps2_P.dims0_def ps2_P.vars0_def"], ["proof (prove)\nusing this:\n  nths dims (vars1 \\<union> vars2) = dims\n\ngoal (1 subgoal):\n 1. nths dims (vars1 \\<union> vars2) = dims", "apply (subst dims)"], ["proof (prove)\ngoal (1 subgoal):\n 1. nths dims (vars1 \\<union> vars2) = dims \\<Longrightarrow> dims = dims", "by auto"], ["proof (state)\nthis:\n  ps2_P.dims0 = dims\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ps2_P_vars1':\n  \"ps2_P.vars1' = vars1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ps2_P.vars1' = vars1", "unfolding ps2_P.vars1'_def ps2_P.vars0_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ind_in_set (vars1 \\<union> vars2) ` vars1 = vars1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ind_in_set (vars1 \\<union> vars2) ` vars1 = vars1", "have eq: \"vars1 \\<union> vars2 = {0..<(Suc n)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vars1 \\<union> vars2 = {0..<Suc n}", "unfolding vars1_def vars2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {0..<n} \\<union> {n} = {0..<Suc n}", "by auto"], ["proof (state)\nthis:\n  vars1 \\<union> vars2 = {0..<Suc n}\n\ngoal (1 subgoal):\n 1. ind_in_set (vars1 \\<union> vars2) ` vars1 = vars1", "have \"x < Suc n \\<Longrightarrow> {i \\<in> {0..<Suc n}. i < x} = {i. i < x}\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. x < Suc n \\<Longrightarrow> {i \\<in> {0..<Suc n}. i < x} = {i. i < x}", "by auto"], ["proof (state)\nthis:\n  ?x2 < Suc n \\<Longrightarrow>\n  {i \\<in> {0..<Suc n}. i < ?x2} = {i. i < ?x2}\n\ngoal (1 subgoal):\n 1. ind_in_set (vars1 \\<union> vars2) ` vars1 = vars1", "then"], ["proof (chain)\npicking this:\n  ?x2 < Suc n \\<Longrightarrow>\n  {i \\<in> {0..<Suc n}. i < ?x2} = {i. i < ?x2}", "have \"x < Suc n \\<Longrightarrow> ind_in_set {0..<(Suc n)} x = x\" for x"], ["proof (prove)\nusing this:\n  ?x2 < Suc n \\<Longrightarrow>\n  {i \\<in> {0..<Suc n}. i < ?x2} = {i. i < ?x2}\n\ngoal (1 subgoal):\n 1. x < Suc n \\<Longrightarrow> ind_in_set {0..<Suc n} x = x", "unfolding ind_in_set_def"], ["proof (prove)\nusing this:\n  ?x2 < Suc n \\<Longrightarrow>\n  {i \\<in> {0..<Suc n}. i < ?x2} = {i. i < ?x2}\n\ngoal (1 subgoal):\n 1. x < Suc n \\<Longrightarrow> card {i \\<in> {0..<Suc n}. i < x} = x", "by auto"], ["proof (state)\nthis:\n  ?x2 < Suc n \\<Longrightarrow> ind_in_set {0..<Suc n} ?x2 = ?x2\n\ngoal (1 subgoal):\n 1. ind_in_set (vars1 \\<union> vars2) ` vars1 = vars1", "then"], ["proof (chain)\npicking this:\n  ?x2 < Suc n \\<Longrightarrow> ind_in_set {0..<Suc n} ?x2 = ?x2", "have \"x \\<in> vars1 \\<Longrightarrow> ind_in_set {0..<(Suc n)} x = x\" for x"], ["proof (prove)\nusing this:\n  ?x2 < Suc n \\<Longrightarrow> ind_in_set {0..<Suc n} ?x2 = ?x2\n\ngoal (1 subgoal):\n 1. x \\<in> vars1 \\<Longrightarrow> ind_in_set {0..<Suc n} x = x", "unfolding vars1_def"], ["proof (prove)\nusing this:\n  ?x2 < Suc n \\<Longrightarrow> ind_in_set {0..<Suc n} ?x2 = ?x2\n\ngoal (1 subgoal):\n 1. x \\<in> {0..<n} \\<Longrightarrow> ind_in_set {0..<Suc n} x = x", "by auto"], ["proof (state)\nthis:\n  ?x2 \\<in> vars1 \\<Longrightarrow> ind_in_set {0..<Suc n} ?x2 = ?x2\n\ngoal (1 subgoal):\n 1. ind_in_set (vars1 \\<union> vars2) ` vars1 = vars1", "then"], ["proof (chain)\npicking this:\n  ?x2 \\<in> vars1 \\<Longrightarrow> ind_in_set {0..<Suc n} ?x2 = ?x2", "have \"ind_in_set {0..<(Suc n)} ` vars1 = vars1\""], ["proof (prove)\nusing this:\n  ?x2 \\<in> vars1 \\<Longrightarrow> ind_in_set {0..<Suc n} ?x2 = ?x2\n\ngoal (1 subgoal):\n 1. ind_in_set {0..<Suc n} ` vars1 = vars1", "by force"], ["proof (state)\nthis:\n  ind_in_set {0..<Suc n} ` vars1 = vars1\n\ngoal (1 subgoal):\n 1. ind_in_set (vars1 \\<union> vars2) ` vars1 = vars1", "with eq"], ["proof (chain)\npicking this:\n  vars1 \\<union> vars2 = {0..<Suc n}\n  ind_in_set {0..<Suc n} ` vars1 = vars1", "show \"ind_in_set (vars1 \\<union> vars2) ` vars1 = vars1\""], ["proof (prove)\nusing this:\n  vars1 \\<union> vars2 = {0..<Suc n}\n  ind_in_set {0..<Suc n} ` vars1 = vars1\n\ngoal (1 subgoal):\n 1. ind_in_set (vars1 \\<union> vars2) ` vars1 = vars1", "by auto"], ["proof (state)\nthis:\n  ind_in_set (vars1 \\<union> vars2) ` vars1 = vars1\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ps2_P_d0:\n  \"ps2_P.d0 = d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ps2_P.d0 = d", "unfolding ps2_P.d0_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. prod_list ps2_P.dims0 = d", "using ps2_P_dims0 d_def"], ["proof (prove)\nusing this:\n  ps2_P.dims0 = dims\n  d = prod_list dims\n\ngoal (1 subgoal):\n 1. prod_list ps2_P.dims0 = d", "by auto"], ["", "lemma ps2_P_d1:\n  \"ps2_P.d1 = N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ps2_P.d1 = N", "unfolding ps2_P.d1_def ps2_P.dims1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. prod_list (nths dims vars1) = N", "by (simp add: dims_vars1 N_def)"], ["", "lemma ps2_P_d2:\n  \"ps2_P.d2 = K\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ps2_P.d2 = K", "unfolding ps2_P.d2_def ps2_P.dims2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. prod_list (nths dims vars2) = K", "by (simp add: dims_vars2)"], ["", "lemma ps_P_d:\n  \"ps_P.d = d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ps_P.d = d", "unfolding ps_P.d_def ps2_P_dims0"], ["proof (prove)\ngoal (1 subgoal):\n 1. d = d", "by auto"], ["", "lemma ps_P_d1:\n  \"ps_P.d1 = N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ps_P.d1 = N", "unfolding ps_P.d1_def ps_P.dims1_def ps2_P.nths_vars1'"], ["proof (prove)\ngoal (1 subgoal):\n 1. prod_list ps2_P.dims1 = N", "using ps2_P_d1"], ["proof (prove)\nusing this:\n  ps2_P.d1 = N\n\ngoal (1 subgoal):\n 1. prod_list ps2_P.dims1 = N", "unfolding ps2_P.d1_def"], ["proof (prove)\nusing this:\n  prod_list ps2_P.dims1 = N\n\ngoal (1 subgoal):\n 1. prod_list ps2_P.dims1 = N", "by auto"], ["", "lemma ps_P_d2:\n  \"ps_P.d2 = K\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ps_P.d2 = K", "unfolding ps_P.d2_def ps_P.dims2_def ps2_P.nths_vars2'"], ["proof (prove)\ngoal (1 subgoal):\n 1. prod_list ps2_P.dims2 = K", "using ps2_P_d2"], ["proof (prove)\nusing this:\n  ps2_P.d2 = K\n\ngoal (1 subgoal):\n 1. prod_list ps2_P.dims2 = K", "unfolding ps2_P.d2_def"], ["proof (prove)\nusing this:\n  prod_list ps2_P.dims2 = K\n\ngoal (1 subgoal):\n 1. prod_list ps2_P.dims2 = K", "by auto"], ["", "lemma nths_uminus_vars1:\n  \"nths dims (- vars1) = nths dims vars2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nths dims (- vars1) = nths dims vars2", "using ps2_P.nths_vars2'"], ["proof (prove)\nusing this:\n  nths ps2_P.dims0 (- ps2_P.vars1') = ps2_P.dims2\n\ngoal (1 subgoal):\n 1. nths dims (- vars1) = nths dims vars2", "unfolding ps2_P_dims0 ps2_P_vars1' ps2_P.dims2_def"], ["proof (prove)\nusing this:\n  nths dims (- vars1) = nths dims vars2\n\ngoal (1 subgoal):\n 1. nths dims (- vars1) = nths dims vars2", "by auto"], ["", "lemma tensor_P_mult:\n  assumes \"m1 \\<in> carrier_mat (2^n) (2^n)\"\n    and \"m2 \\<in> carrier_mat (2^n) (2^n)\"\n    and \"m3 \\<in> carrier_mat K K\"\n    and \"m4 \\<in> carrier_mat K K\"\n  shows \"(tensor_P m1 m3) * (tensor_P m2 m4) = tensor_P (m1 * m2) (m3 * m4)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tensor_P m1 m3 * tensor_P m2 m4 = tensor_P (m1 * m2) (m3 * m4)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. tensor_P m1 m3 * tensor_P m2 m4 = tensor_P (m1 * m2) (m3 * m4)", "have eq:\"{0..<n} = {..<n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {0..<n} = {..<n}", "by auto"], ["proof (state)\nthis:\n  {0..<n} = {..<n}\n\ngoal (1 subgoal):\n 1. tensor_P m1 m3 * tensor_P m2 m4 = tensor_P (m1 * m2) (m3 * m4)", "have \"(nths dims vars1) = replicate n 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nths dims vars1 = replicate n 2", "unfolding dims_def vars1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. nths (replicate n 2 @ [K]) {0..<n} = replicate n 2", "apply (subst eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. nths (replicate n 2 @ [K]) {..<n} = replicate n 2", "by (simp add: nths_upt_eq_take[of \"(replicate n 2 @ [K])\" n])"], ["proof (state)\nthis:\n  nths dims vars1 = replicate n 2\n\ngoal (1 subgoal):\n 1. tensor_P m1 m3 * tensor_P m2 m4 = tensor_P (m1 * m2) (m3 * m4)", "have \"ps2_P.d1 = 2^n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ps2_P.d1 = 2 ^ n", "unfolding ps2_P.d1_def ps2_P.dims1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. prod_list (nths dims vars1) = 2 ^ n", "using d_vars1 N_def"], ["proof (prove)\nusing this:\n  prod_list (nths dims vars1) = N\n  N = 2 ^ n\n\ngoal (1 subgoal):\n 1. prod_list (nths dims vars1) = 2 ^ n", "by auto"], ["proof (state)\nthis:\n  ps2_P.d1 = 2 ^ n\n\ngoal (1 subgoal):\n 1. tensor_P m1 m3 * tensor_P m2 m4 = tensor_P (m1 * m2) (m3 * m4)", "moreover"], ["proof (state)\nthis:\n  ps2_P.d1 = 2 ^ n\n\ngoal (1 subgoal):\n 1. tensor_P m1 m3 * tensor_P m2 m4 = tensor_P (m1 * m2) (m3 * m4)", "have \"ps2_P.d2 = K\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ps2_P.d2 = K", "unfolding ps2_P.d2_def ps2_P.dims2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. prod_list (nths dims vars2) = K", "using dims_vars2"], ["proof (prove)\nusing this:\n  nths dims vars2 = [K]\n\ngoal (1 subgoal):\n 1. prod_list (nths dims vars2) = K", "by auto"], ["proof (state)\nthis:\n  ps2_P.d2 = K\n\ngoal (1 subgoal):\n 1. tensor_P m1 m3 * tensor_P m2 m4 = tensor_P (m1 * m2) (m3 * m4)", "ultimately"], ["proof (chain)\npicking this:\n  ps2_P.d1 = 2 ^ n\n  ps2_P.d2 = K", "show ?thesis"], ["proof (prove)\nusing this:\n  ps2_P.d1 = 2 ^ n\n  ps2_P.d2 = K\n\ngoal (1 subgoal):\n 1. tensor_P m1 m3 * tensor_P m2 m4 = tensor_P (m1 * m2) (m3 * m4)", "apply (subst ps2_P.ptensor_mat_mult)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>ps2_P.d1 = 2 ^ n; ps2_P.d2 = K\\<rbrakk>\n    \\<Longrightarrow> m1 \\<in> carrier_mat ps2_P.d1 ps2_P.d1\n 2. \\<lbrakk>ps2_P.d1 = 2 ^ n; ps2_P.d2 = K\\<rbrakk>\n    \\<Longrightarrow> m2 \\<in> carrier_mat ps2_P.d1 ps2_P.d1\n 3. \\<lbrakk>ps2_P.d1 = 2 ^ n; ps2_P.d2 = K\\<rbrakk>\n    \\<Longrightarrow> m3 \\<in> carrier_mat ps2_P.d2 ps2_P.d2\n 4. \\<lbrakk>ps2_P.d1 = 2 ^ n; ps2_P.d2 = K\\<rbrakk>\n    \\<Longrightarrow> m4 \\<in> carrier_mat ps2_P.d2 ps2_P.d2\n 5. \\<lbrakk>ps2_P.d1 = 2 ^ n; ps2_P.d2 = K\\<rbrakk>\n    \\<Longrightarrow> tensor_P m1 m3 * tensor_P m2 m4 =\n                      tensor_P m1 m3 * tensor_P m2 m4", "using assms"], ["proof (prove)\nusing this:\n  m1 \\<in> carrier_mat (2 ^ n) (2 ^ n)\n  m2 \\<in> carrier_mat (2 ^ n) (2 ^ n)\n  m3 \\<in> carrier_mat K K\n  m4 \\<in> carrier_mat K K\n\ngoal (5 subgoals):\n 1. \\<lbrakk>ps2_P.d1 = 2 ^ n; ps2_P.d2 = K\\<rbrakk>\n    \\<Longrightarrow> m1 \\<in> carrier_mat ps2_P.d1 ps2_P.d1\n 2. \\<lbrakk>ps2_P.d1 = 2 ^ n; ps2_P.d2 = K\\<rbrakk>\n    \\<Longrightarrow> m2 \\<in> carrier_mat ps2_P.d1 ps2_P.d1\n 3. \\<lbrakk>ps2_P.d1 = 2 ^ n; ps2_P.d2 = K\\<rbrakk>\n    \\<Longrightarrow> m3 \\<in> carrier_mat ps2_P.d2 ps2_P.d2\n 4. \\<lbrakk>ps2_P.d1 = 2 ^ n; ps2_P.d2 = K\\<rbrakk>\n    \\<Longrightarrow> m4 \\<in> carrier_mat ps2_P.d2 ps2_P.d2\n 5. \\<lbrakk>ps2_P.d1 = 2 ^ n; ps2_P.d2 = K\\<rbrakk>\n    \\<Longrightarrow> tensor_P m1 m3 * tensor_P m2 m4 =\n                      tensor_P m1 m3 * tensor_P m2 m4", "by auto"], ["proof (state)\nthis:\n  tensor_P m1 m3 * tensor_P m2 m4 = tensor_P (m1 * m2) (m3 * m4)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mat_ext_vars1:\n  shows \"mat_extension dims vars1 A = tensor_P A (1\\<^sub>m K)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_extension dims vars1 A = tensor_P A (1\\<^sub>m K)", "unfolding Utrans_P_def ps2_P.ptensor_mat_def partial_state.mat_extension_def\n    partial_state.d2_def partial_state.dims2_def ps2_P.nths_vars2'[simplified ps2_P_dims0 ps2_P_vars1']"], ["proof (prove)\ngoal (1 subgoal):\n 1. tensor_mat dims vars1 A (1\\<^sub>m (prod_list ps2_P.dims2)) =\n    ps_P.tensor_mat A (1\\<^sub>m K)", "using ps2_P_d2"], ["proof (prove)\nusing this:\n  ps2_P.d2 = K\n\ngoal (1 subgoal):\n 1. tensor_mat dims vars1 A (1\\<^sub>m (prod_list ps2_P.dims2)) =\n    ps_P.tensor_mat A (1\\<^sub>m K)", "unfolding ps2_P.d2_def"], ["proof (prove)\nusing this:\n  prod_list ps2_P.dims2 = K\n\ngoal (1 subgoal):\n 1. tensor_mat dims vars1 A (1\\<^sub>m (prod_list ps2_P.dims2)) =\n    ps_P.tensor_mat A (1\\<^sub>m K)", "using ps2_P_dims0 ps2_P_vars1'"], ["proof (prove)\nusing this:\n  prod_list ps2_P.dims2 = K\n  ps2_P.dims0 = dims\n  ps2_P.vars1' = vars1\n\ngoal (1 subgoal):\n 1. tensor_mat dims vars1 A (1\\<^sub>m (prod_list ps2_P.dims2)) =\n    ps_P.tensor_mat A (1\\<^sub>m K)", "by auto"], ["", "lemma Utrans_P_is_tensor_P1:\n  \"Utrans_P vars1 A = Utrans (tensor_P A (1\\<^sub>m K))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Utrans_P vars1 A = Utrans (tensor_P A (1\\<^sub>m K))", "unfolding Utrans_P_def ps2_P.ptensor_mat_def partial_state.mat_extension_def\n    partial_state.d2_def partial_state.dims2_def ps2_P.nths_vars2'[simplified ps2_P_dims0 ps2_P_vars1']"], ["proof (prove)\ngoal (1 subgoal):\n 1. Utrans (tensor_mat dims vars1 A (1\\<^sub>m (prod_list ps2_P.dims2))) =\n    Utrans (ps_P.tensor_mat A (1\\<^sub>m K))", "using ps2_P_d2"], ["proof (prove)\nusing this:\n  ps2_P.d2 = K\n\ngoal (1 subgoal):\n 1. Utrans (tensor_mat dims vars1 A (1\\<^sub>m (prod_list ps2_P.dims2))) =\n    Utrans (ps_P.tensor_mat A (1\\<^sub>m K))", "unfolding ps2_P.d2_def"], ["proof (prove)\nusing this:\n  prod_list ps2_P.dims2 = K\n\ngoal (1 subgoal):\n 1. Utrans (tensor_mat dims vars1 A (1\\<^sub>m (prod_list ps2_P.dims2))) =\n    Utrans (ps_P.tensor_mat A (1\\<^sub>m K))", "using ps2_P_dims0 ps2_P_vars1'"], ["proof (prove)\nusing this:\n  prod_list ps2_P.dims2 = K\n  ps2_P.dims0 = dims\n  ps2_P.vars1' = vars1\n\ngoal (1 subgoal):\n 1. Utrans (tensor_mat dims vars1 A (1\\<^sub>m (prod_list ps2_P.dims2))) =\n    Utrans (ps_P.tensor_mat A (1\\<^sub>m K))", "by auto"], ["", "lemma nths_dims_uminus_vars2:\n  \"nths dims (-vars2) = nths dims vars1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nths dims (- vars2) = nths dims vars1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. nths dims (- vars2) = nths dims vars1", "have \"nths dims (-vars2) = nths dims ({0..<length dims} - vars2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nths dims (- vars2) = nths dims ({0..<length dims} - vars2)", "using nths_minus_eq"], ["proof (prove)\nusing this:\n  {0..<length ?xs} \\<subseteq> ?A \\<Longrightarrow>\n  nths ?xs (- ?B) = nths ?xs (?A - ?B)\n\ngoal (1 subgoal):\n 1. nths dims (- vars2) = nths dims ({0..<length dims} - vars2)", "by auto"], ["proof (state)\nthis:\n  nths dims (- vars2) = nths dims ({0..<length dims} - vars2)\n\ngoal (1 subgoal):\n 1. nths dims (- vars2) = nths dims vars1", "also"], ["proof (state)\nthis:\n  nths dims (- vars2) = nths dims ({0..<length dims} - vars2)\n\ngoal (1 subgoal):\n 1. nths dims (- vars2) = nths dims vars1", "have \"\\<dots> = nths dims vars1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nths dims ({0..<length dims} - vars2) = nths dims vars1", "unfolding vars1_def vars2_def length_dims"], ["proof (prove)\ngoal (1 subgoal):\n 1. nths dims ({0..<n + 1} - {n}) = nths dims {0..<n}", "apply (subgoal_tac \"{0..<n + 1} - {n} = {0..<n}\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. {0..<n + 1} - {n} = {0..<n} \\<Longrightarrow>\n    nths dims ({0..<n + 1} - {n}) = nths dims {0..<n}\n 2. {0..<n + 1} - {n} = {0..<n}", "by auto"], ["proof (state)\nthis:\n  nths dims ({0..<length dims} - vars2) = nths dims vars1\n\ngoal (1 subgoal):\n 1. nths dims (- vars2) = nths dims vars1", "finally"], ["proof (chain)\npicking this:\n  nths dims (- vars2) = nths dims vars1", "show ?thesis"], ["proof (prove)\nusing this:\n  nths dims (- vars2) = nths dims vars1\n\ngoal (1 subgoal):\n 1. nths dims (- vars2) = nths dims vars1", "by auto"], ["proof (state)\nthis:\n  nths dims (- vars2) = nths dims vars1\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mat_ext_vars2:\n  assumes \"A \\<in> carrier_mat K K\"\n  shows \"mat_extension dims vars2 A = tensor_P (1\\<^sub>m N) A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_extension dims vars2 A = tensor_P (1\\<^sub>m N) A", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. mat_extension dims vars2 A = tensor_P (1\\<^sub>m N) A", "have \"mat_extension dims vars2 A = tensor_mat dims vars2 A (1\\<^sub>m N)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_extension dims vars2 A = tensor_mat dims vars2 A (1\\<^sub>m N)", "unfolding Utrans_P_def partial_state.mat_extension_def\n      partial_state.d2_def partial_state.dims2_def\n      nths_dims_uminus_vars2 dims_vars1 N_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. tensor_mat dims vars2 A (1\\<^sub>m (prod_list (replicate n 2))) =\n    tensor_mat dims vars2 A (1\\<^sub>m (2 ^ n))", "by auto"], ["proof (state)\nthis:\n  mat_extension dims vars2 A = tensor_mat dims vars2 A (1\\<^sub>m N)\n\ngoal (1 subgoal):\n 1. mat_extension dims vars2 A = tensor_P (1\\<^sub>m N) A", "also"], ["proof (state)\nthis:\n  mat_extension dims vars2 A = tensor_mat dims vars2 A (1\\<^sub>m N)\n\ngoal (1 subgoal):\n 1. mat_extension dims vars2 A = tensor_P (1\\<^sub>m N) A", "have \"\\<dots> = tensor_mat dims vars1 (1\\<^sub>m N) A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tensor_mat dims vars2 A (1\\<^sub>m N) =\n    tensor_mat dims vars1 (1\\<^sub>m N) A", "apply (subst tensor_mat_comm[of vars1 vars2])"], ["proof (prove)\ngoal (5 subgoals):\n 1. vars1 \\<inter> vars2 = {}\n 2. {0..<length dims} \\<subseteq> vars1 \\<union> vars2\n 3. 1\\<^sub>m N\n    \\<in> carrier_mat (prod_list (nths dims vars1))\n           (prod_list (nths dims vars1))\n 4. A \\<in> carrier_mat (prod_list (nths dims vars2))\n             (prod_list (nths dims vars2))\n 5. tensor_mat dims vars2 A (1\\<^sub>m N) =\n    tensor_mat dims vars2 A (1\\<^sub>m N)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. vars1 \\<inter> vars2 = {}", "unfolding vars1_def vars2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {0..<n} \\<inter> {n} = {}", "by auto"], ["proof (prove)\ngoal (4 subgoals):\n 1. {0..<length dims} \\<subseteq> vars1 \\<union> vars2\n 2. 1\\<^sub>m N\n    \\<in> carrier_mat (prod_list (nths dims vars1))\n           (prod_list (nths dims vars1))\n 3. A \\<in> carrier_mat (prod_list (nths dims vars2))\n             (prod_list (nths dims vars2))\n 4. tensor_mat dims vars2 A (1\\<^sub>m N) =\n    tensor_mat dims vars2 A (1\\<^sub>m N)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. {0..<length dims} \\<subseteq> vars1 \\<union> vars2", "unfolding length_dims vars1_def vars2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {0..<n + 1} \\<subseteq> {0..<n} \\<union> {n}", "by auto"], ["proof (prove)\ngoal (3 subgoals):\n 1. 1\\<^sub>m N\n    \\<in> carrier_mat (prod_list (nths dims vars1))\n           (prod_list (nths dims vars1))\n 2. A \\<in> carrier_mat (prod_list (nths dims vars2))\n             (prod_list (nths dims vars2))\n 3. tensor_mat dims vars2 A (1\\<^sub>m N) =\n    tensor_mat dims vars2 A (1\\<^sub>m N)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1\\<^sub>m N\n    \\<in> carrier_mat (prod_list (nths dims vars1))\n           (prod_list (nths dims vars1))", "unfolding dims_vars1 N_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1\\<^sub>m (2 ^ n)\n    \\<in> carrier_mat (prod_list (replicate n 2))\n           (prod_list (replicate n 2))", "by auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. A \\<in> carrier_mat (prod_list (nths dims vars2))\n             (prod_list (nths dims vars2))\n 2. tensor_mat dims vars2 A (1\\<^sub>m N) =\n    tensor_mat dims vars2 A (1\\<^sub>m N)", "unfolding dims_vars2"], ["proof (prove)\ngoal (2 subgoals):\n 1. A \\<in> carrier_mat (prod_list [K]) (prod_list [K])\n 2. tensor_mat dims vars2 A (1\\<^sub>m N) =\n    tensor_mat dims vars2 A (1\\<^sub>m N)", "using assms"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat K K\n\ngoal (2 subgoals):\n 1. A \\<in> carrier_mat (prod_list [K]) (prod_list [K])\n 2. tensor_mat dims vars2 A (1\\<^sub>m N) =\n    tensor_mat dims vars2 A (1\\<^sub>m N)", "by auto"], ["proof (state)\nthis:\n  tensor_mat dims vars2 A (1\\<^sub>m N) =\n  tensor_mat dims vars1 (1\\<^sub>m N) A\n\ngoal (1 subgoal):\n 1. mat_extension dims vars2 A = tensor_P (1\\<^sub>m N) A", "finally"], ["proof (chain)\npicking this:\n  mat_extension dims vars2 A = tensor_mat dims vars1 (1\\<^sub>m N) A", "show \"mat_extension dims vars2 A = tensor_P (1\\<^sub>m N) A\""], ["proof (prove)\nusing this:\n  mat_extension dims vars2 A = tensor_mat dims vars1 (1\\<^sub>m N) A\n\ngoal (1 subgoal):\n 1. mat_extension dims vars2 A = tensor_P (1\\<^sub>m N) A", "unfolding ps2_P.ptensor_mat_def ps2_P_dims0 ps2_P_vars1'"], ["proof (prove)\nusing this:\n  mat_extension dims vars2 A = tensor_mat dims vars1 (1\\<^sub>m N) A\n\ngoal (1 subgoal):\n 1. mat_extension dims vars2 A = tensor_mat dims vars1 (1\\<^sub>m N) A", "by auto"], ["proof (state)\nthis:\n  mat_extension dims vars2 A = tensor_P (1\\<^sub>m N) A\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Utrans_P_is_tensor_P2:\n  assumes \"A \\<in> carrier_mat K K\"\n  shows \"Utrans_P vars2 A = Utrans (tensor_P (1\\<^sub>m N) A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Utrans_P vars2 A = Utrans (tensor_P (1\\<^sub>m N) A)", "unfolding Utrans_P_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Utrans (mat_extension dims vars2 A) = Utrans (tensor_P (1\\<^sub>m N) A)", "using mat_ext_vars2 assms"], ["proof (prove)\nusing this:\n  ?A \\<in> carrier_mat K K \\<Longrightarrow>\n  mat_extension dims vars2 ?A = tensor_P (1\\<^sub>m N) ?A\n  A \\<in> carrier_mat K K\n\ngoal (1 subgoal):\n 1. Utrans (mat_extension dims vars2 A) = Utrans (tensor_P (1\\<^sub>m N) A)", "by auto"], ["", "subsection \\<open>Grover's algorithm\\<close>"], ["", "text \\<open>Apply hadamard operator to first n variables\\<close>"], ["", "definition hadamard_on_i :: \"nat \\<Rightarrow> complex mat\" where\n  \"hadamard_on_i i = pmat_extension dims {i} (vars1 - {i}) hadamard\""], ["", "declare hadamard_on_i_def [simp]"], ["", "fun hadamard_n :: \"nat \\<Rightarrow> com\" where\n  \"hadamard_n 0 = SKIP\"\n| \"hadamard_n (Suc i) = hadamard_n i ;; Utrans (tensor_P (hadamard_on_i i) (1\\<^sub>m K))\""], ["", "text \\<open>Body of the loop\\<close>"], ["", "definition D :: com where\n  \"D = Utrans_P vars1 mat_O ;;\n       hadamard_n n ;;\n       Utrans_P vars1 mat_Ph ;;\n       hadamard_n n ;;\n       Utrans_P vars2 (mat_incr K)\""], ["", "lemma unitary_ex_mat_O:\n  \"unitary (tensor_P mat_O (1\\<^sub>m K))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unitary (tensor_P mat_O (1\\<^sub>m K))", "unfolding ps2_P.ptensor_mat_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. unitary (ps_P.tensor_mat mat_O (1\\<^sub>m K))", "apply (subst ps_P.tensor_mat_unitary)"], ["proof (prove)\ngoal (5 subgoals):\n 1. mat_O \\<in> carrier_mat ps_P.d1 ps_P.d1\n 2. 1\\<^sub>m K \\<in> carrier_mat ps_P.d2 ps_P.d2\n 3. unitary mat_O\n 4. unitary (1\\<^sub>m K)\n 5. True", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_O \\<in> carrier_mat ps_P.d1 ps_P.d1", "using ps_P_d1 mat_O_def"], ["proof (prove)\nusing this:\n  ps_P.d1 = N\n  mat_O =\n  mat N N (\\<lambda>(i, j). if i = j then if f i then - 1 else 1 else 0)\n\ngoal (1 subgoal):\n 1. mat_O \\<in> carrier_mat ps_P.d1 ps_P.d1", "by auto"], ["proof (prove)\ngoal (4 subgoals):\n 1. 1\\<^sub>m K \\<in> carrier_mat ps_P.d2 ps_P.d2\n 2. unitary mat_O\n 3. unitary (1\\<^sub>m K)\n 4. True", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1\\<^sub>m K \\<in> carrier_mat ps_P.d2 ps_P.d2", "using ps_P_d2"], ["proof (prove)\nusing this:\n  ps_P.d2 = K\n\ngoal (1 subgoal):\n 1. 1\\<^sub>m K \\<in> carrier_mat ps_P.d2 ps_P.d2", "by auto"], ["proof (prove)\ngoal (3 subgoals):\n 1. unitary mat_O\n 2. unitary (1\\<^sub>m K)\n 3. True", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. unitary mat_O", "using unitary_mat_O"], ["proof (prove)\nusing this:\n  unitary mat_O\n\ngoal (1 subgoal):\n 1. unitary mat_O", "by auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. unitary (1\\<^sub>m K)\n 2. True", "using unitary_one"], ["proof (prove)\nusing this:\n  unitary (1\\<^sub>m ?n)\n\ngoal (2 subgoals):\n 1. unitary (1\\<^sub>m K)\n 2. True", "by auto"], ["", "lemma unitary_ex_mat_Ph:\n  \"unitary (tensor_P mat_Ph (1\\<^sub>m K))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unitary (tensor_P mat_Ph (1\\<^sub>m K))", "unfolding ps2_P.ptensor_mat_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. unitary (ps_P.tensor_mat mat_Ph (1\\<^sub>m K))", "apply (subst ps_P.tensor_mat_unitary)"], ["proof (prove)\ngoal (5 subgoals):\n 1. mat_Ph \\<in> carrier_mat ps_P.d1 ps_P.d1\n 2. 1\\<^sub>m K \\<in> carrier_mat ps_P.d2 ps_P.d2\n 3. unitary mat_Ph\n 4. unitary (1\\<^sub>m K)\n 5. True", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_Ph \\<in> carrier_mat ps_P.d1 ps_P.d1", "using ps_P_d1 mat_Ph_def"], ["proof (prove)\nusing this:\n  ps_P.d1 = N\n  mat_Ph =\n  mat N N (\\<lambda>(i, j). if i = j then if i = 0 then 1 else - 1 else 0)\n\ngoal (1 subgoal):\n 1. mat_Ph \\<in> carrier_mat ps_P.d1 ps_P.d1", "by auto"], ["proof (prove)\ngoal (4 subgoals):\n 1. 1\\<^sub>m K \\<in> carrier_mat ps_P.d2 ps_P.d2\n 2. unitary mat_Ph\n 3. unitary (1\\<^sub>m K)\n 4. True", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1\\<^sub>m K \\<in> carrier_mat ps_P.d2 ps_P.d2", "using ps_P_d2"], ["proof (prove)\nusing this:\n  ps_P.d2 = K\n\ngoal (1 subgoal):\n 1. 1\\<^sub>m K \\<in> carrier_mat ps_P.d2 ps_P.d2", "by auto"], ["proof (prove)\ngoal (3 subgoals):\n 1. unitary mat_Ph\n 2. unitary (1\\<^sub>m K)\n 3. True", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. unitary mat_Ph", "using unitary_mat_Ph"], ["proof (prove)\nusing this:\n  unitary mat_Ph\n\ngoal (1 subgoal):\n 1. unitary mat_Ph", "by auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. unitary (1\\<^sub>m K)\n 2. True", "using unitary_one"], ["proof (prove)\nusing this:\n  unitary (1\\<^sub>m ?n)\n\ngoal (2 subgoals):\n 1. unitary (1\\<^sub>m K)\n 2. True", "by auto"], ["", "lemma unitary_hadamard_on_i:\n  assumes \"k < n\"\n  shows \"unitary (hadamard_on_i k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unitary (hadamard_on_i k)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. unitary (hadamard_on_i k)", "interpret st2: partial_state2 dims \"{k}\" \"vars1 - {k}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. partial_state2 {k} (vars1 - {k})", "apply unfold_locales"], ["proof (prove)\ngoal (1 subgoal):\n 1. {k} \\<inter> (vars1 - {k}) = {}", "by auto"], ["proof (state)\ngoal (1 subgoal):\n 1. unitary (hadamard_on_i k)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. unitary (hadamard_on_i k)", "unfolding hadamard_on_i_def st2.pmat_extension_def st2.ptensor_mat_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. unitary (tensor_mat st2.dims0 st2.vars1' hadamard (1\\<^sub>m st2.d2))", "apply (rule partial_state.tensor_mat_unitary)"], ["proof (prove)\ngoal (4 subgoals):\n 1. hadamard\n    \\<in> carrier_mat (partial_state.d1 st2.dims0 st2.vars1')\n           (partial_state.d1 st2.dims0 st2.vars1')\n 2. 1\\<^sub>m st2.d2\n    \\<in> carrier_mat (partial_state.d2 st2.dims0 st2.vars1')\n           (partial_state.d2 st2.dims0 st2.vars1')\n 3. unitary hadamard\n 4. unitary (1\\<^sub>m st2.d2)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. hadamard\n    \\<in> carrier_mat (partial_state.d1 st2.dims0 st2.vars1')\n           (partial_state.d1 st2.dims0 st2.vars1')", "unfolding partial_state.d1_def partial_state.dims1_def st2.nths_vars1' st2.dims1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. hadamard\n    \\<in> carrier_mat (prod_list (nths dims {k}))\n           (prod_list (nths dims {k}))", "using dims_nths_one_lt_n assms hadamard_dim"], ["proof (prove)\nusing this:\n  ?l < n \\<Longrightarrow> nths dims {?l} = [2]\n  k < n\n  hadamard \\<in> carrier_mat 2 2\n\ngoal (1 subgoal):\n 1. hadamard\n    \\<in> carrier_mat (prod_list (nths dims {k}))\n           (prod_list (nths dims {k}))", "by auto"], ["proof (prove)\ngoal (3 subgoals):\n 1. 1\\<^sub>m st2.d2\n    \\<in> carrier_mat (partial_state.d2 st2.dims0 st2.vars1')\n           (partial_state.d2 st2.dims0 st2.vars1')\n 2. unitary hadamard\n 3. unitary (1\\<^sub>m st2.d2)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1\\<^sub>m st2.d2\n    \\<in> carrier_mat (partial_state.d2 st2.dims0 st2.vars1')\n           (partial_state.d2 st2.dims0 st2.vars1')", "unfolding st2.d2_def st2.dims2_def partial_state.d2_def partial_state.dims2_def st2.nths_vars2' st2.dims1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1\\<^sub>m (prod_list (nths dims (vars1 - {k})))\n    \\<in> carrier_mat (prod_list (nths dims (vars1 - {k})))\n           (prod_list (nths dims (vars1 - {k})))", "by auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. unitary hadamard\n 2. unitary (1\\<^sub>m st2.d2)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. unitary hadamard", "using unitary_hadamard"], ["proof (prove)\nusing this:\n  unitary hadamard\n\ngoal (1 subgoal):\n 1. unitary hadamard", "by auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. unitary (1\\<^sub>m st2.d2)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. unitary (1\\<^sub>m st2.d2)", "using unitary_one"], ["proof (prove)\nusing this:\n  unitary (1\\<^sub>m ?n)\n\ngoal (1 subgoal):\n 1. unitary (1\\<^sub>m st2.d2)", "by auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  unitary (hadamard_on_i k)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma unitary_exhadamard_on_i:\n  assumes \"k < n\"\n  shows \"unitary (tensor_P (hadamard_on_i k) (1\\<^sub>m K))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unitary (tensor_P (hadamard_on_i k) (1\\<^sub>m K))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. unitary (tensor_P (hadamard_on_i k) (1\\<^sub>m K))", "interpret st2: partial_state2 dims \"{k}\" \"vars1 - {k}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. partial_state2 {k} (vars1 - {k})", "apply unfold_locales"], ["proof (prove)\ngoal (1 subgoal):\n 1. {k} \\<inter> (vars1 - {k}) = {}", "by auto"], ["proof (state)\ngoal (1 subgoal):\n 1. unitary (tensor_P (hadamard_on_i k) (1\\<^sub>m K))", "have d1: \"st2.d0 = partial_state.d1 ps2_P.dims0 ps2_P.vars1'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. st2.d0 = ps_P.d1", "unfolding partial_state.d1_def partial_state.dims1_def ps2_P.nths_vars1' ps2_P.dims1_def\n      st2.d0_def st2.dims0_def st2.vars0_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. prod_list (nths dims ({k} \\<union> (vars1 - {k}))) =\n    prod_list (nths dims vars1)", "using assms"], ["proof (prove)\nusing this:\n  k < n\n\ngoal (1 subgoal):\n 1. prod_list (nths dims ({k} \\<union> (vars1 - {k}))) =\n    prod_list (nths dims vars1)", "apply (subgoal_tac \"{k} \\<union> (vars1 - {k}) = vars1\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>k < n; {k} \\<union> (vars1 - {k}) = vars1\\<rbrakk>\n    \\<Longrightarrow> prod_list (nths dims ({k} \\<union> (vars1 - {k}))) =\n                      prod_list (nths dims vars1)\n 2. k < n \\<Longrightarrow> {k} \\<union> (vars1 - {k}) = vars1", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. k < n \\<Longrightarrow> {k} \\<union> (vars1 - {k}) = vars1", "unfolding vars1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. k < n \\<Longrightarrow> {k} \\<union> ({0..<n} - {k}) = {0..<n}", "by auto"], ["proof (state)\nthis:\n  st2.d0 = ps_P.d1\n\ngoal (1 subgoal):\n 1. unitary (tensor_P (hadamard_on_i k) (1\\<^sub>m K))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. unitary (tensor_P (hadamard_on_i k) (1\\<^sub>m K))", "unfolding ps2_P.ptensor_mat_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. unitary (ps_P.tensor_mat (hadamard_on_i k) (1\\<^sub>m K))", "apply (rule partial_state.tensor_mat_unitary)"], ["proof (prove)\ngoal (4 subgoals):\n 1. hadamard_on_i k \\<in> carrier_mat ps_P.d1 ps_P.d1\n 2. 1\\<^sub>m K \\<in> carrier_mat ps_P.d2 ps_P.d2\n 3. unitary (hadamard_on_i k)\n 4. unitary (1\\<^sub>m K)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. hadamard_on_i k \\<in> carrier_mat ps_P.d1 ps_P.d1", "unfolding hadamard_on_i_def st2.pmat_extension_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. st2.ptensor_mat hadamard (1\\<^sub>m st2.d2)\n    \\<in> carrier_mat ps_P.d1 ps_P.d1", "using st2.ptensor_mat_carrier[of hadamard \"1\\<^sub>m st2.d2\"]"], ["proof (prove)\nusing this:\n  st2.ptensor_mat hadamard (1\\<^sub>m st2.d2)\n  \\<in> carrier_mat st2.d0 st2.d0\n\ngoal (1 subgoal):\n 1. st2.ptensor_mat hadamard (1\\<^sub>m st2.d2)\n    \\<in> carrier_mat ps_P.d1 ps_P.d1", "using d1"], ["proof (prove)\nusing this:\n  st2.ptensor_mat hadamard (1\\<^sub>m st2.d2)\n  \\<in> carrier_mat st2.d0 st2.d0\n  st2.d0 = ps_P.d1\n\ngoal (1 subgoal):\n 1. st2.ptensor_mat hadamard (1\\<^sub>m st2.d2)\n    \\<in> carrier_mat ps_P.d1 ps_P.d1", "by auto"], ["proof (prove)\ngoal (3 subgoals):\n 1. 1\\<^sub>m K \\<in> carrier_mat ps_P.d2 ps_P.d2\n 2. unitary (hadamard_on_i k)\n 3. unitary (1\\<^sub>m K)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1\\<^sub>m K \\<in> carrier_mat ps_P.d2 ps_P.d2", "unfolding partial_state.d2_def partial_state.dims2_def ps2_P.nths_vars2' ps2_P.dims2_def dims_vars2"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1\\<^sub>m K \\<in> carrier_mat (prod_list [K]) (prod_list [K])", "by auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. unitary (hadamard_on_i k)\n 2. unitary (1\\<^sub>m K)", "using unitary_hadamard_on_i unitary_one assms"], ["proof (prove)\nusing this:\n  ?k < n \\<Longrightarrow> unitary (hadamard_on_i ?k)\n  unitary (1\\<^sub>m ?n)\n  k < n\n\ngoal (2 subgoals):\n 1. unitary (hadamard_on_i k)\n 2. unitary (1\\<^sub>m K)", "by auto"], ["proof (state)\nthis:\n  unitary (tensor_P (hadamard_on_i k) (1\\<^sub>m K))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma hadamard_on_i_dim:\n  assumes \"k < n\"\n  shows \"hadamard_on_i k \\<in> carrier_mat N N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hadamard_on_i k \\<in> carrier_mat N N", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. hadamard_on_i k \\<in> carrier_mat N N", "interpret st: partial_state2 dims \"{k}\" \"(vars1 - {k})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. partial_state2 {k} (vars1 - {k})", "apply unfold_locales"], ["proof (prove)\ngoal (1 subgoal):\n 1. {k} \\<inter> (vars1 - {k}) = {}", "by auto"], ["proof (state)\ngoal (1 subgoal):\n 1. hadamard_on_i k \\<in> carrier_mat N N", "have vars1: \"{k} \\<union> (vars1 - {k}) = vars1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {k} \\<union> (vars1 - {k}) = vars1", "unfolding vars1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {k} \\<union> ({0..<n} - {k}) = {0..<n}", "using assms"], ["proof (prove)\nusing this:\n  k < n\n\ngoal (1 subgoal):\n 1. {k} \\<union> ({0..<n} - {k}) = {0..<n}", "by auto"], ["proof (state)\nthis:\n  {k} \\<union> (vars1 - {k}) = vars1\n\ngoal (1 subgoal):\n 1. hadamard_on_i k \\<in> carrier_mat N N", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. hadamard_on_i k \\<in> carrier_mat N N", "unfolding hadamard_on_i_def N_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. st.pmat_extension hadamard \\<in> carrier_mat (2 ^ n) (2 ^ n)", "using st.pmat_extension_carrier"], ["proof (prove)\nusing this:\n  st.pmat_extension ?m \\<in> carrier_mat st.d0 st.d0\n\ngoal (1 subgoal):\n 1. st.pmat_extension hadamard \\<in> carrier_mat (2 ^ n) (2 ^ n)", "unfolding st.d0_def st.dims0_def st.vars0_def"], ["proof (prove)\nusing this:\n  st.pmat_extension ?m\n  \\<in> carrier_mat (prod_list (nths dims ({k} \\<union> (vars1 - {k}))))\n         (prod_list (nths dims ({k} \\<union> (vars1 - {k}))))\n\ngoal (1 subgoal):\n 1. st.pmat_extension hadamard \\<in> carrier_mat (2 ^ n) (2 ^ n)", "using vars1 dims_vars1"], ["proof (prove)\nusing this:\n  st.pmat_extension ?m\n  \\<in> carrier_mat (prod_list (nths dims ({k} \\<union> (vars1 - {k}))))\n         (prod_list (nths dims ({k} \\<union> (vars1 - {k}))))\n  {k} \\<union> (vars1 - {k}) = vars1\n  nths dims vars1 = replicate n 2\n\ngoal (1 subgoal):\n 1. st.pmat_extension hadamard \\<in> carrier_mat (2 ^ n) (2 ^ n)", "by auto"], ["proof (state)\nthis:\n  hadamard_on_i k \\<in> carrier_mat N N\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma well_com_hadamard_k:\n  \"k \\<le> n \\<Longrightarrow> well_com (hadamard_n k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k \\<le> n \\<Longrightarrow> well_com (hadamard_n k)", "proof (induct k)"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 \\<le> n \\<Longrightarrow> well_com (hadamard_n 0)\n 2. \\<And>k.\n       \\<lbrakk>k \\<le> n \\<Longrightarrow> well_com (hadamard_n k);\n        Suc k \\<le> n\\<rbrakk>\n       \\<Longrightarrow> well_com (hadamard_n (Suc k))", "case 0"], ["proof (state)\nthis:\n  0 \\<le> n\n\ngoal (2 subgoals):\n 1. 0 \\<le> n \\<Longrightarrow> well_com (hadamard_n 0)\n 2. \\<And>k.\n       \\<lbrakk>k \\<le> n \\<Longrightarrow> well_com (hadamard_n k);\n        Suc k \\<le> n\\<rbrakk>\n       \\<Longrightarrow> well_com (hadamard_n (Suc k))", "then"], ["proof (chain)\npicking this:\n  0 \\<le> n", "show ?case"], ["proof (prove)\nusing this:\n  0 \\<le> n\n\ngoal (1 subgoal):\n 1. well_com (hadamard_n 0)", "by auto"], ["proof (state)\nthis:\n  well_com (hadamard_n 0)\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k \\<le> n \\<Longrightarrow> well_com (hadamard_n k);\n        Suc k \\<le> n\\<rbrakk>\n       \\<Longrightarrow> well_com (hadamard_n (Suc k))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k \\<le> n \\<Longrightarrow> well_com (hadamard_n k);\n        Suc k \\<le> n\\<rbrakk>\n       \\<Longrightarrow> well_com (hadamard_n (Suc k))", "case (Suc n)"], ["proof (state)\nthis:\n  n \\<le> n \\<Longrightarrow> well_com (hadamard_n n)\n  Suc n \\<le> n\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k \\<le> n \\<Longrightarrow> well_com (hadamard_n k);\n        Suc k \\<le> n\\<rbrakk>\n       \\<Longrightarrow> well_com (hadamard_n (Suc k))", "then"], ["proof (chain)\npicking this:\n  n \\<le> n \\<Longrightarrow> well_com (hadamard_n n)\n  Suc n \\<le> n", "have \"well_com (hadamard_n n)\""], ["proof (prove)\nusing this:\n  n \\<le> n \\<Longrightarrow> well_com (hadamard_n n)\n  Suc n \\<le> n\n\ngoal (1 subgoal):\n 1. well_com (hadamard_n n)", "by auto"], ["proof (state)\nthis:\n  well_com (hadamard_n n)\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k \\<le> n \\<Longrightarrow> well_com (hadamard_n k);\n        Suc k \\<le> n\\<rbrakk>\n       \\<Longrightarrow> well_com (hadamard_n (Suc k))", "then"], ["proof (chain)\npicking this:\n  well_com (hadamard_n n)", "show ?case"], ["proof (prove)\nusing this:\n  well_com (hadamard_n n)\n\ngoal (1 subgoal):\n 1. well_com (hadamard_n (Suc n))", "unfolding hadamard_n.simps well_com.simps"], ["proof (prove)\nusing this:\n  well_com (hadamard_n n)\n\ngoal (1 subgoal):\n 1. well_com (hadamard_n n) \\<and>\n    tensor_P (hadamard_on_i n) (1\\<^sub>m K) \\<in> carrier_mat d d \\<and>\n    unitary (tensor_P (hadamard_on_i n) (1\\<^sub>m K))", "using tensor_P_dim unitary_exhadamard_on_i Suc"], ["proof (prove)\nusing this:\n  well_com (hadamard_n n)\n  tensor_P ?A ?B \\<in> carrier_mat d d\n  ?k < n \\<Longrightarrow>\n  unitary (tensor_P (hadamard_on_i ?k) (1\\<^sub>m K))\n  n \\<le> n \\<Longrightarrow> well_com (hadamard_n n)\n  Suc n \\<le> n\n\ngoal (1 subgoal):\n 1. well_com (hadamard_n n) \\<and>\n    tensor_P (hadamard_on_i n) (1\\<^sub>m K) \\<in> carrier_mat d d \\<and>\n    unitary (tensor_P (hadamard_on_i n) (1\\<^sub>m K))", "by auto"], ["proof (state)\nthis:\n  well_com (hadamard_n (Suc n))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma well_com_hadamard_n:\n  \"well_com (hadamard_n n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. well_com (hadamard_n n)", "using well_com_hadamard_k"], ["proof (prove)\nusing this:\n  ?k \\<le> n \\<Longrightarrow> well_com (hadamard_n ?k)\n\ngoal (1 subgoal):\n 1. well_com (hadamard_n n)", "by auto"], ["", "lemma well_com_mat_O:\n  \"well_com (Utrans_P vars1 mat_O)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. well_com (Utrans_P vars1 mat_O)", "apply (subst Utrans_P_is_tensor_P1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. well_com (Utrans (tensor_P mat_O (1\\<^sub>m K)))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. tensor_P mat_O (1\\<^sub>m K) \\<in> carrier_mat d d \\<and>\n    unitary (tensor_P mat_O (1\\<^sub>m K))", "using tensor_P_dim unitary_ex_mat_O"], ["proof (prove)\nusing this:\n  tensor_P ?A ?B \\<in> carrier_mat d d\n  unitary (tensor_P mat_O (1\\<^sub>m K))\n\ngoal (1 subgoal):\n 1. tensor_P mat_O (1\\<^sub>m K) \\<in> carrier_mat d d \\<and>\n    unitary (tensor_P mat_O (1\\<^sub>m K))", "by auto"], ["", "lemma well_com_mat_Ph:\n  \"well_com (Utrans_P vars1 mat_Ph)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. well_com (Utrans_P vars1 mat_Ph)", "apply (subst Utrans_P_is_tensor_P1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. well_com (Utrans (tensor_P mat_Ph (1\\<^sub>m K)))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. tensor_P mat_Ph (1\\<^sub>m K) \\<in> carrier_mat d d \\<and>\n    unitary (tensor_P mat_Ph (1\\<^sub>m K))", "using tensor_P_dim unitary_ex_mat_Ph"], ["proof (prove)\nusing this:\n  tensor_P ?A ?B \\<in> carrier_mat d d\n  unitary (tensor_P mat_Ph (1\\<^sub>m K))\n\ngoal (1 subgoal):\n 1. tensor_P mat_Ph (1\\<^sub>m K) \\<in> carrier_mat d d \\<and>\n    unitary (tensor_P mat_Ph (1\\<^sub>m K))", "by auto"], ["", "lemma unitary_exmat_incr:\n  \"unitary (tensor_P (1\\<^sub>m N) (mat_incr K))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unitary (tensor_P (1\\<^sub>m N) (mat_incr K))", "unfolding ps2_P.ptensor_mat_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. unitary (ps_P.tensor_mat (1\\<^sub>m N) (mat_incr K))", "apply (subst ps_P.tensor_mat_unitary)"], ["proof (prove)\ngoal (5 subgoals):\n 1. 1\\<^sub>m N \\<in> carrier_mat ps_P.d1 ps_P.d1\n 2. mat_incr K \\<in> carrier_mat ps_P.d2 ps_P.d2\n 3. unitary (1\\<^sub>m N)\n 4. unitary (mat_incr K)\n 5. True", "using  unitary_mat_incr K unitary_one"], ["proof (prove)\nusing this:\n  unitary (mat_incr ?n)\n  R < K\n  unitary (1\\<^sub>m ?n)\n\ngoal (5 subgoals):\n 1. 1\\<^sub>m N \\<in> carrier_mat ps_P.d1 ps_P.d1\n 2. mat_incr K \\<in> carrier_mat ps_P.d2 ps_P.d2\n 3. unitary (1\\<^sub>m N)\n 4. unitary (mat_incr K)\n 5. True", "by (auto simp add: ps_P_d1 ps_P_d2 mat_incr_def)"], ["", "lemma well_com_mat_incr:\n  \"well_com (Utrans_P vars2 (mat_incr K))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. well_com (Utrans_P vars2 (mat_incr K))", "apply (subst Utrans_P_is_tensor_P2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. mat_incr K \\<in> carrier_mat K K\n 2. well_com (Utrans (tensor_P (1\\<^sub>m N) (mat_incr K)))", "apply (simp add: mat_incr_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. well_com (Utrans (tensor_P (1\\<^sub>m N) (mat_incr K)))", "using tensor_P_dim unitary_exmat_incr"], ["proof (prove)\nusing this:\n  tensor_P ?A ?B \\<in> carrier_mat d d\n  unitary (tensor_P (1\\<^sub>m N) (mat_incr K))\n\ngoal (1 subgoal):\n 1. well_com (Utrans (tensor_P (1\\<^sub>m N) (mat_incr K)))", "by auto"], ["", "lemma well_com_D: \"well_com D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. well_com D", "unfolding D_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. well_com\n     (Utrans_P vars1 mat_O;; hadamard_n n;; Utrans_P vars1 mat_Ph;;\n      hadamard_n n;; Utrans_P vars2 (mat_incr K))", "apply auto"], ["proof (prove)\ngoal (5 subgoals):\n 1. well_com (Utrans_P vars1 mat_O)\n 2. well_com (hadamard_n n)\n 3. well_com (Utrans_P vars1 mat_Ph)\n 4. well_com (hadamard_n n)\n 5. well_com (Utrans_P vars2 (mat_incr K))", "using well_com_hadamard_n well_com_mat_incr well_com_mat_O well_com_mat_Ph"], ["proof (prove)\nusing this:\n  well_com (hadamard_n n)\n  well_com (Utrans_P vars2 (mat_incr K))\n  well_com (Utrans_P vars1 mat_O)\n  well_com (Utrans_P vars1 mat_Ph)\n\ngoal (5 subgoals):\n 1. well_com (Utrans_P vars1 mat_O)\n 2. well_com (hadamard_n n)\n 3. well_com (Utrans_P vars1 mat_Ph)\n 4. well_com (hadamard_n n)\n 5. well_com (Utrans_P vars2 (mat_incr K))", "by auto"], ["", "text \\<open>Test at while loop\\<close>"], ["", "definition M0 :: \"complex mat\" where\n  \"M0 = mat K K (\\<lambda>(i,j). if i = j \\<and> i \\<ge> R then 1 else 0)\""], ["", "lemma hermitian_M0:\n  \"hermitian M0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hermitian M0", "by (auto simp add: hermitian_def M0_def adjoint_eval)"], ["", "lemma M0_dim:\n  \"M0 \\<in> carrier_mat K K\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M0 \\<in> carrier_mat K K", "unfolding M0_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat K K (\\<lambda>(i, j). if i = j \\<and> R \\<le> i then 1 else 0)\n    \\<in> carrier_mat K K", "by auto"], ["", "lemma M0_mult_M0:\n  \"M0 * M0 = M0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M0 * M0 = M0", "by (auto simp add: M0_def scalar_prod_def sum_only_one_neq_0)"], ["", "definition M1 :: \"complex mat\" where\n  \"M1 = mat K K (\\<lambda>(i,j). if i = j \\<and> i < R then 1 else 0)\""], ["", "lemma M1_dim:\n  \"M1 \\<in> carrier_mat K K\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M1 \\<in> carrier_mat K K", "unfolding M1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat K K (\\<lambda>(i, j). if i = j \\<and> i < R then 1 else 0)\n    \\<in> carrier_mat K K", "by auto"], ["", "lemma hermitian_M1:\n  \"hermitian M1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hermitian M1", "by (auto simp add: hermitian_def M1_def adjoint_eval)"], ["", "lemma M1_mult_M1:\n  \"M1 * M1 = M1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M1 * M1 = M1", "by (auto simp add: M1_def scalar_prod_def sum_only_one_neq_0)"], ["", "lemma M1_add_M0:\n  \"M1 + M0 = 1\\<^sub>m K\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M1 + M0 = 1\\<^sub>m K", "unfolding M0_def M1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat K K (\\<lambda>(i, j). if i = j \\<and> i < R then 1 else 0) +\n    mat K K (\\<lambda>(i, j). if i = j \\<and> R \\<le> i then 1 else 0) =\n    1\\<^sub>m K", "by auto"], ["", "text \\<open>Test at the end\\<close>"], ["", "definition testN :: \"nat \\<Rightarrow> complex mat\" where\n  \"testN k = mat N N (\\<lambda>(i,j). if i = k \\<and> j = k then 1 else 0)\""], ["", "lemma hermitian_testN:\n  \"hermitian (testN k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hermitian (testN k)", "unfolding hermitian_def testN_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. adjoint\n     (mat N N (\\<lambda>(i, j). if i = k \\<and> j = k then 1 else 0)) =\n    mat N N (\\<lambda>(i, j). if i = k \\<and> j = k then 1 else 0)", "by (auto simp add: scalar_prod_def adjoint_eval)"], ["", "lemma testN_mult_testN:\n  \"testN k * testN k = testN k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. testN k * testN k = testN k", "unfolding testN_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat N N (\\<lambda>(i, j). if i = k \\<and> j = k then 1 else 0) *\n    mat N N (\\<lambda>(i, j). if i = k \\<and> j = k then 1 else 0) =\n    mat N N (\\<lambda>(i, j). if i = k \\<and> j = k then 1 else 0)", "by (auto simp add: scalar_prod_def sum_only_one_neq_0)"], ["", "lemma testN_dim:\n  \"testN k \\<in> carrier_mat N N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. testN k \\<in> carrier_mat N N", "unfolding testN_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat N N (\\<lambda>(i, j). if i = k \\<and> j = k then 1 else 0)\n    \\<in> carrier_mat N N", "by auto"], ["", "definition test_fst_k :: \"nat \\<Rightarrow> complex mat\" where\n  \"test_fst_k k = mat N N (\\<lambda>(i, j). if (i = j \\<and> i < k) then 1 else 0)\""], ["", "lemma sum_test_k:\n  assumes \"m \\<le> N\"\n  shows \"matrix_sum N (\\<lambda>k. testN k) m = test_fst_k m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_sum N testN m = test_fst_k m", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. matrix_sum N testN m = test_fst_k m", "have \"m \\<le> N \\<Longrightarrow> matrix_sum N (\\<lambda>k. testN k) m = mat N N (\\<lambda>(i, j). if (i = j \\<and> i < m) then 1 else 0)\" for m"], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<le> N \\<Longrightarrow>\n    matrix_sum N testN m =\n    mat N N (\\<lambda>(i, j). if i = j \\<and> i < m then 1 else 0)", "proof (induct m)"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 \\<le> N \\<Longrightarrow>\n    matrix_sum N testN 0 =\n    mat N N (\\<lambda>(i, j). if i = j \\<and> i < 0 then 1 else 0)\n 2. \\<And>m.\n       \\<lbrakk>m \\<le> N \\<Longrightarrow>\n                matrix_sum N testN m =\n                mat N N\n                 (\\<lambda>(i, j). if i = j \\<and> i < m then 1 else 0);\n        Suc m \\<le> N\\<rbrakk>\n       \\<Longrightarrow> matrix_sum N testN (Suc m) =\n                         mat N N\n                          (\\<lambda>(i, j).\n                              if i = j \\<and> i < Suc m then 1 else 0)", "case 0"], ["proof (state)\nthis:\n  0 \\<le> N\n\ngoal (2 subgoals):\n 1. 0 \\<le> N \\<Longrightarrow>\n    matrix_sum N testN 0 =\n    mat N N (\\<lambda>(i, j). if i = j \\<and> i < 0 then 1 else 0)\n 2. \\<And>m.\n       \\<lbrakk>m \\<le> N \\<Longrightarrow>\n                matrix_sum N testN m =\n                mat N N\n                 (\\<lambda>(i, j). if i = j \\<and> i < m then 1 else 0);\n        Suc m \\<le> N\\<rbrakk>\n       \\<Longrightarrow> matrix_sum N testN (Suc m) =\n                         mat N N\n                          (\\<lambda>(i, j).\n                              if i = j \\<and> i < Suc m then 1 else 0)", "then"], ["proof (chain)\npicking this:\n  0 \\<le> N", "show ?case"], ["proof (prove)\nusing this:\n  0 \\<le> N\n\ngoal (1 subgoal):\n 1. matrix_sum N testN 0 =\n    mat N N\n     (\\<lambda>a.\n         case a of (i, j) \\<Rightarrow> if i = j \\<and> i < 0 then 1 else 0)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0\\<^sub>m N N = mat N N (\\<lambda>a. 0)", "apply (rule eq_matI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row (mat N N (\\<lambda>a. 0));\n        j < dim_col (mat N N (\\<lambda>a. 0))\\<rbrakk>\n       \\<Longrightarrow> 0\\<^sub>m N N $$ (i, j) =\n                         mat N N (\\<lambda>a. 0) $$ (i, j)\n 2. dim_row (0\\<^sub>m N N) = dim_row (mat N N (\\<lambda>a. 0))\n 3. dim_col (0\\<^sub>m N N) = dim_col (mat N N (\\<lambda>a. 0))", "by auto"], ["proof (state)\nthis:\n  matrix_sum N testN 0 =\n  mat N N\n   (\\<lambda>a.\n       case a of (i, j) \\<Rightarrow> if i = j \\<and> i < 0 then 1 else 0)\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       \\<lbrakk>m \\<le> N \\<Longrightarrow>\n                matrix_sum N testN m =\n                mat N N\n                 (\\<lambda>(i, j). if i = j \\<and> i < m then 1 else 0);\n        Suc m \\<le> N\\<rbrakk>\n       \\<Longrightarrow> matrix_sum N testN (Suc m) =\n                         mat N N\n                          (\\<lambda>(i, j).\n                              if i = j \\<and> i < Suc m then 1 else 0)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m.\n       \\<lbrakk>m \\<le> N \\<Longrightarrow>\n                matrix_sum N testN m =\n                mat N N\n                 (\\<lambda>(i, j). if i = j \\<and> i < m then 1 else 0);\n        Suc m \\<le> N\\<rbrakk>\n       \\<Longrightarrow> matrix_sum N testN (Suc m) =\n                         mat N N\n                          (\\<lambda>(i, j).\n                              if i = j \\<and> i < Suc m then 1 else 0)", "case (Suc m)"], ["proof (state)\nthis:\n  m \\<le> N \\<Longrightarrow>\n  matrix_sum N testN m =\n  mat N N\n   (\\<lambda>a.\n       case a of (i, j) \\<Rightarrow> if i = j \\<and> i < m then 1 else 0)\n  Suc m \\<le> N\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       \\<lbrakk>m \\<le> N \\<Longrightarrow>\n                matrix_sum N testN m =\n                mat N N\n                 (\\<lambda>(i, j). if i = j \\<and> i < m then 1 else 0);\n        Suc m \\<le> N\\<rbrakk>\n       \\<Longrightarrow> matrix_sum N testN (Suc m) =\n                         mat N N\n                          (\\<lambda>(i, j).\n                              if i = j \\<and> i < Suc m then 1 else 0)", "then"], ["proof (chain)\npicking this:\n  m \\<le> N \\<Longrightarrow>\n  matrix_sum N testN m =\n  mat N N\n   (\\<lambda>a.\n       case a of (i, j) \\<Rightarrow> if i = j \\<and> i < m then 1 else 0)\n  Suc m \\<le> N", "have m: \"m < N\""], ["proof (prove)\nusing this:\n  m \\<le> N \\<Longrightarrow>\n  matrix_sum N testN m =\n  mat N N\n   (\\<lambda>a.\n       case a of (i, j) \\<Rightarrow> if i = j \\<and> i < m then 1 else 0)\n  Suc m \\<le> N\n\ngoal (1 subgoal):\n 1. m < N", "by auto"], ["proof (state)\nthis:\n  m < N\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       \\<lbrakk>m \\<le> N \\<Longrightarrow>\n                matrix_sum N testN m =\n                mat N N\n                 (\\<lambda>(i, j). if i = j \\<and> i < m then 1 else 0);\n        Suc m \\<le> N\\<rbrakk>\n       \\<Longrightarrow> matrix_sum N testN (Suc m) =\n                         mat N N\n                          (\\<lambda>(i, j).\n                              if i = j \\<and> i < Suc m then 1 else 0)", "then"], ["proof (chain)\npicking this:\n  m < N", "have m': \"m \\<le> N\""], ["proof (prove)\nusing this:\n  m < N\n\ngoal (1 subgoal):\n 1. m \\<le> N", "by auto"], ["proof (state)\nthis:\n  m \\<le> N\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       \\<lbrakk>m \\<le> N \\<Longrightarrow>\n                matrix_sum N testN m =\n                mat N N\n                 (\\<lambda>(i, j). if i = j \\<and> i < m then 1 else 0);\n        Suc m \\<le> N\\<rbrakk>\n       \\<Longrightarrow> matrix_sum N testN (Suc m) =\n                         mat N N\n                          (\\<lambda>(i, j).\n                              if i = j \\<and> i < Suc m then 1 else 0)", "have \"matrix_sum N testN (Suc m) = testN m + matrix_sum N testN m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_sum N testN (Suc m) = testN m + matrix_sum N testN m", "by simp"], ["proof (state)\nthis:\n  matrix_sum N testN (Suc m) = testN m + matrix_sum N testN m\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       \\<lbrakk>m \\<le> N \\<Longrightarrow>\n                matrix_sum N testN m =\n                mat N N\n                 (\\<lambda>(i, j). if i = j \\<and> i < m then 1 else 0);\n        Suc m \\<le> N\\<rbrakk>\n       \\<Longrightarrow> matrix_sum N testN (Suc m) =\n                         mat N N\n                          (\\<lambda>(i, j).\n                              if i = j \\<and> i < Suc m then 1 else 0)", "also"], ["proof (state)\nthis:\n  matrix_sum N testN (Suc m) = testN m + matrix_sum N testN m\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       \\<lbrakk>m \\<le> N \\<Longrightarrow>\n                matrix_sum N testN m =\n                mat N N\n                 (\\<lambda>(i, j). if i = j \\<and> i < m then 1 else 0);\n        Suc m \\<le> N\\<rbrakk>\n       \\<Longrightarrow> matrix_sum N testN (Suc m) =\n                         mat N N\n                          (\\<lambda>(i, j).\n                              if i = j \\<and> i < Suc m then 1 else 0)", "have \"\\<dots> = mat N N (\\<lambda>(i, j). if (i = j \\<and> i < (Suc m)) then 1 else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. testN m + matrix_sum N testN m =\n    mat N N (\\<lambda>(i, j). if i = j \\<and> i < Suc m then 1 else 0)", "unfolding testN_def Suc(1)[OF m']"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat N N (\\<lambda>(i, j). if i = m \\<and> j = m then 1 else 0) +\n    mat N N (\\<lambda>(i, j). if i = j \\<and> i < m then 1 else 0) =\n    mat N N (\\<lambda>(i, j). if i = j \\<and> i < Suc m then 1 else 0)", "apply (rule eq_matI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row\n                     (mat N N\n                       (\\<lambda>(i, j).\n                           if i = j \\<and> i < Suc m then 1 else 0));\n        j < dim_col\n             (mat N N\n               (\\<lambda>(i, j).\n                   if i = j \\<and> i < Suc m then 1 else 0))\\<rbrakk>\n       \\<Longrightarrow> (mat N N\n                           (\\<lambda>(i, j).\n                               if i = m \\<and> j = m then 1 else 0) +\n                          mat N N\n                           (\\<lambda>(i, j).\n                               if i = j \\<and> i < m then 1 else 0)) $$\n                         (i, j) =\n                         mat N N\n                          (\\<lambda>(i, j).\n                              if i = j \\<and> i < Suc m then 1 else 0) $$\n                         (i, j)\n 2. dim_row\n     (mat N N (\\<lambda>(i, j). if i = m \\<and> j = m then 1 else 0) +\n      mat N N (\\<lambda>(i, j). if i = j \\<and> i < m then 1 else 0)) =\n    dim_row\n     (mat N N (\\<lambda>(i, j). if i = j \\<and> i < Suc m then 1 else 0))\n 3. dim_col\n     (mat N N (\\<lambda>(i, j). if i = m \\<and> j = m then 1 else 0) +\n      mat N N (\\<lambda>(i, j). if i = j \\<and> i < m then 1 else 0)) =\n    dim_col\n     (mat N N (\\<lambda>(i, j). if i = j \\<and> i < Suc m then 1 else 0))", "by auto"], ["proof (state)\nthis:\n  testN m + matrix_sum N testN m =\n  mat N N (\\<lambda>(i, j). if i = j \\<and> i < Suc m then 1 else 0)\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       \\<lbrakk>m \\<le> N \\<Longrightarrow>\n                matrix_sum N testN m =\n                mat N N\n                 (\\<lambda>(i, j). if i = j \\<and> i < m then 1 else 0);\n        Suc m \\<le> N\\<rbrakk>\n       \\<Longrightarrow> matrix_sum N testN (Suc m) =\n                         mat N N\n                          (\\<lambda>(i, j).\n                              if i = j \\<and> i < Suc m then 1 else 0)", "finally"], ["proof (chain)\npicking this:\n  matrix_sum N testN (Suc m) =\n  mat N N (\\<lambda>(i, j). if i = j \\<and> i < Suc m then 1 else 0)", "show ?case"], ["proof (prove)\nusing this:\n  matrix_sum N testN (Suc m) =\n  mat N N (\\<lambda>(i, j). if i = j \\<and> i < Suc m then 1 else 0)\n\ngoal (1 subgoal):\n 1. matrix_sum N testN (Suc m) =\n    mat N N\n     (\\<lambda>a.\n         case a of\n         (i, j) \\<Rightarrow> if i = j \\<and> i < Suc m then 1 else 0)", "by auto"], ["proof (state)\nthis:\n  matrix_sum N testN (Suc m) =\n  mat N N\n   (\\<lambda>a.\n       case a of\n       (i, j) \\<Rightarrow> if i = j \\<and> i < Suc m then 1 else 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?m2 \\<le> N \\<Longrightarrow>\n  matrix_sum N testN ?m2 =\n  mat N N (\\<lambda>(i, j). if i = j \\<and> i < ?m2 then 1 else 0)\n\ngoal (1 subgoal):\n 1. matrix_sum N testN m = test_fst_k m", "then"], ["proof (chain)\npicking this:\n  ?m2 \\<le> N \\<Longrightarrow>\n  matrix_sum N testN ?m2 =\n  mat N N (\\<lambda>(i, j). if i = j \\<and> i < ?m2 then 1 else 0)", "show ?thesis"], ["proof (prove)\nusing this:\n  ?m2 \\<le> N \\<Longrightarrow>\n  matrix_sum N testN ?m2 =\n  mat N N (\\<lambda>(i, j). if i = j \\<and> i < ?m2 then 1 else 0)\n\ngoal (1 subgoal):\n 1. matrix_sum N testN m = test_fst_k m", "unfolding test_fst_k_def"], ["proof (prove)\nusing this:\n  ?m2 \\<le> N \\<Longrightarrow>\n  matrix_sum N testN ?m2 =\n  mat N N (\\<lambda>(i, j). if i = j \\<and> i < ?m2 then 1 else 0)\n\ngoal (1 subgoal):\n 1. matrix_sum N testN m =\n    mat N N (\\<lambda>(i, j). if i = j \\<and> i < m then 1 else 0)", "using assms"], ["proof (prove)\nusing this:\n  ?m2 \\<le> N \\<Longrightarrow>\n  matrix_sum N testN ?m2 =\n  mat N N (\\<lambda>(i, j). if i = j \\<and> i < ?m2 then 1 else 0)\n  m \\<le> N\n\ngoal (1 subgoal):\n 1. matrix_sum N testN m =\n    mat N N (\\<lambda>(i, j). if i = j \\<and> i < m then 1 else 0)", "by auto"], ["proof (state)\nthis:\n  matrix_sum N testN m = test_fst_k m\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma test_fst_kN:\n  \"test_fst_k N = 1\\<^sub>m N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. test_fst_k N = 1\\<^sub>m N", "apply (rule eq_matI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row (1\\<^sub>m N);\n        j < dim_col (1\\<^sub>m N)\\<rbrakk>\n       \\<Longrightarrow> test_fst_k N $$ (i, j) = 1\\<^sub>m N $$ (i, j)\n 2. dim_row (test_fst_k N) = dim_row (1\\<^sub>m N)\n 3. dim_col (test_fst_k N) = dim_col (1\\<^sub>m N)", "unfolding test_fst_k_def"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row (1\\<^sub>m N);\n        j < dim_col (1\\<^sub>m N)\\<rbrakk>\n       \\<Longrightarrow> mat N N\n                          (\\<lambda>(i, j).\n                              if i = j \\<and> i < N then 1 else 0) $$\n                         (i, j) =\n                         1\\<^sub>m N $$ (i, j)\n 2. dim_row\n     (mat N N (\\<lambda>(i, j). if i = j \\<and> i < N then 1 else 0)) =\n    dim_row (1\\<^sub>m N)\n 3. dim_col\n     (mat N N (\\<lambda>(i, j). if i = j \\<and> i < N then 1 else 0)) =\n    dim_col (1\\<^sub>m N)", "by auto"], ["", "lemma matrix_sum_tensor_P1:\n  \"(\\<And>k. k < m \\<Longrightarrow> g k \\<in> carrier_mat N N) \\<Longrightarrow> (A \\<in> carrier_mat K K) \\<Longrightarrow>\n   matrix_sum d (\\<lambda>k. tensor_P (g k) A) m = tensor_P (matrix_sum N g m) A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>k. k < m \\<Longrightarrow> g k \\<in> carrier_mat N N;\n     A \\<in> carrier_mat K K\\<rbrakk>\n    \\<Longrightarrow> matrix_sum d (\\<lambda>k. tensor_P (g k) A) m =\n                      tensor_P (matrix_sum N g m) A", "proof (induct m)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>k. k < 0 \\<Longrightarrow> g k \\<in> carrier_mat N N;\n     A \\<in> carrier_mat K K\\<rbrakk>\n    \\<Longrightarrow> matrix_sum d (\\<lambda>k. tensor_P (g k) A) 0 =\n                      tensor_P (matrix_sum N g 0) A\n 2. \\<And>m.\n       \\<lbrakk>\\<lbrakk>\\<And>k.\n                            k < m \\<Longrightarrow>\n                            g k \\<in> carrier_mat N N;\n                 A \\<in> carrier_mat K K\\<rbrakk>\n                \\<Longrightarrow> matrix_sum d\n                                   (\\<lambda>k. tensor_P (g k) A) m =\n                                  tensor_P (matrix_sum N g m) A;\n        \\<And>k. k < Suc m \\<Longrightarrow> g k \\<in> carrier_mat N N;\n        A \\<in> carrier_mat K K\\<rbrakk>\n       \\<Longrightarrow> matrix_sum d (\\<lambda>k. tensor_P (g k) A)\n                          (Suc m) =\n                         tensor_P (matrix_sum N g (Suc m)) A", "case 0"], ["proof (state)\nthis:\n  ?k2 < 0 \\<Longrightarrow> g ?k2 \\<in> carrier_mat N N\n  A \\<in> carrier_mat K K\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>k. k < 0 \\<Longrightarrow> g k \\<in> carrier_mat N N;\n     A \\<in> carrier_mat K K\\<rbrakk>\n    \\<Longrightarrow> matrix_sum d (\\<lambda>k. tensor_P (g k) A) 0 =\n                      tensor_P (matrix_sum N g 0) A\n 2. \\<And>m.\n       \\<lbrakk>\\<lbrakk>\\<And>k.\n                            k < m \\<Longrightarrow>\n                            g k \\<in> carrier_mat N N;\n                 A \\<in> carrier_mat K K\\<rbrakk>\n                \\<Longrightarrow> matrix_sum d\n                                   (\\<lambda>k. tensor_P (g k) A) m =\n                                  tensor_P (matrix_sum N g m) A;\n        \\<And>k. k < Suc m \\<Longrightarrow> g k \\<in> carrier_mat N N;\n        A \\<in> carrier_mat K K\\<rbrakk>\n       \\<Longrightarrow> matrix_sum d (\\<lambda>k. tensor_P (g k) A)\n                          (Suc m) =\n                         tensor_P (matrix_sum N g (Suc m)) A", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_sum d (\\<lambda>k. tensor_P (g k) A) 0 =\n    tensor_P (matrix_sum N g 0) A", "apply (simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0\\<^sub>m d d = tensor_P (0\\<^sub>m N N) A", "unfolding ps2_P.ptensor_mat_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0\\<^sub>m d d = ps_P.tensor_mat (0\\<^sub>m N N) A", "using ps_P.tensor_mat_zero1[simplified ps_P_d ps_P_d1, of A]"], ["proof (prove)\nusing this:\n  ps_P.tensor_mat (0\\<^sub>m N N) A = 0\\<^sub>m d d\n\ngoal (1 subgoal):\n 1. 0\\<^sub>m d d = ps_P.tensor_mat (0\\<^sub>m N N) A", "by auto"], ["proof (state)\nthis:\n  matrix_sum d (\\<lambda>k. tensor_P (g k) A) 0 =\n  tensor_P (matrix_sum N g 0) A\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       \\<lbrakk>\\<lbrakk>\\<And>k.\n                            k < m \\<Longrightarrow>\n                            g k \\<in> carrier_mat N N;\n                 A \\<in> carrier_mat K K\\<rbrakk>\n                \\<Longrightarrow> matrix_sum d\n                                   (\\<lambda>k. tensor_P (g k) A) m =\n                                  tensor_P (matrix_sum N g m) A;\n        \\<And>k. k < Suc m \\<Longrightarrow> g k \\<in> carrier_mat N N;\n        A \\<in> carrier_mat K K\\<rbrakk>\n       \\<Longrightarrow> matrix_sum d (\\<lambda>k. tensor_P (g k) A)\n                          (Suc m) =\n                         tensor_P (matrix_sum N g (Suc m)) A", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m.\n       \\<lbrakk>\\<lbrakk>\\<And>k.\n                            k < m \\<Longrightarrow>\n                            g k \\<in> carrier_mat N N;\n                 A \\<in> carrier_mat K K\\<rbrakk>\n                \\<Longrightarrow> matrix_sum d\n                                   (\\<lambda>k. tensor_P (g k) A) m =\n                                  tensor_P (matrix_sum N g m) A;\n        \\<And>k. k < Suc m \\<Longrightarrow> g k \\<in> carrier_mat N N;\n        A \\<in> carrier_mat K K\\<rbrakk>\n       \\<Longrightarrow> matrix_sum d (\\<lambda>k. tensor_P (g k) A)\n                          (Suc m) =\n                         tensor_P (matrix_sum N g (Suc m)) A", "case (Suc m)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<And>k. k < m \\<Longrightarrow> g k \\<in> carrier_mat N N;\n   A \\<in> carrier_mat K K\\<rbrakk>\n  \\<Longrightarrow> matrix_sum d (\\<lambda>k. tensor_P (g k) A) m =\n                    tensor_P (matrix_sum N g m) A\n  ?k2 < Suc m \\<Longrightarrow> g ?k2 \\<in> carrier_mat N N\n  A \\<in> carrier_mat K K\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       \\<lbrakk>\\<lbrakk>\\<And>k.\n                            k < m \\<Longrightarrow>\n                            g k \\<in> carrier_mat N N;\n                 A \\<in> carrier_mat K K\\<rbrakk>\n                \\<Longrightarrow> matrix_sum d\n                                   (\\<lambda>k. tensor_P (g k) A) m =\n                                  tensor_P (matrix_sum N g m) A;\n        \\<And>k. k < Suc m \\<Longrightarrow> g k \\<in> carrier_mat N N;\n        A \\<in> carrier_mat K K\\<rbrakk>\n       \\<Longrightarrow> matrix_sum d (\\<lambda>k. tensor_P (g k) A)\n                          (Suc m) =\n                         tensor_P (matrix_sum N g (Suc m)) A", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<And>k. k < m \\<Longrightarrow> g k \\<in> carrier_mat N N;\n   A \\<in> carrier_mat K K\\<rbrakk>\n  \\<Longrightarrow> matrix_sum d (\\<lambda>k. tensor_P (g k) A) m =\n                    tensor_P (matrix_sum N g m) A\n  ?k2 < Suc m \\<Longrightarrow> g ?k2 \\<in> carrier_mat N N\n  A \\<in> carrier_mat K K", "have ind: \"matrix_sum d (\\<lambda>k. tensor_P (g k) A) m = tensor_P (matrix_sum N g m) A\" \n    and dk: \"\\<And>k. k < m \\<Longrightarrow> g k \\<in> carrier_mat N N\" and \"A \\<in> carrier_mat K K\""], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>k. k < m \\<Longrightarrow> g k \\<in> carrier_mat N N;\n   A \\<in> carrier_mat K K\\<rbrakk>\n  \\<Longrightarrow> matrix_sum d (\\<lambda>k. tensor_P (g k) A) m =\n                    tensor_P (matrix_sum N g m) A\n  ?k2 < Suc m \\<Longrightarrow> g ?k2 \\<in> carrier_mat N N\n  A \\<in> carrier_mat K K\n\ngoal (1 subgoal):\n 1. matrix_sum d (\\<lambda>k. tensor_P (g k) A) m =\n    tensor_P (matrix_sum N g m) A &&&\n    (\\<And>k. k < m \\<Longrightarrow> g k \\<in> carrier_mat N N) &&&\n    A \\<in> carrier_mat K K", "by auto"], ["proof (state)\nthis:\n  matrix_sum d (\\<lambda>k. tensor_P (g k) A) m =\n  tensor_P (matrix_sum N g m) A\n  ?k2 < m \\<Longrightarrow> g ?k2 \\<in> carrier_mat N N\n  A \\<in> carrier_mat K K\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       \\<lbrakk>\\<lbrakk>\\<And>k.\n                            k < m \\<Longrightarrow>\n                            g k \\<in> carrier_mat N N;\n                 A \\<in> carrier_mat K K\\<rbrakk>\n                \\<Longrightarrow> matrix_sum d\n                                   (\\<lambda>k. tensor_P (g k) A) m =\n                                  tensor_P (matrix_sum N g m) A;\n        \\<And>k. k < Suc m \\<Longrightarrow> g k \\<in> carrier_mat N N;\n        A \\<in> carrier_mat K K\\<rbrakk>\n       \\<Longrightarrow> matrix_sum d (\\<lambda>k. tensor_P (g k) A)\n                          (Suc m) =\n                         tensor_P (matrix_sum N g (Suc m)) A", "have ds: \"matrix_sum N g m \\<in> carrier_mat N N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_sum N g m \\<in> carrier_mat N N", "apply (subst matrix_sum_dim)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>k. k < m \\<Longrightarrow> g k \\<in> carrier_mat N N\n 2. True", "using dk"], ["proof (prove)\nusing this:\n  ?k2 < m \\<Longrightarrow> g ?k2 \\<in> carrier_mat N N\n\ngoal (2 subgoals):\n 1. \\<And>k. k < m \\<Longrightarrow> g k \\<in> carrier_mat N N\n 2. True", "by auto"], ["proof (state)\nthis:\n  matrix_sum N g m \\<in> carrier_mat N N\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       \\<lbrakk>\\<lbrakk>\\<And>k.\n                            k < m \\<Longrightarrow>\n                            g k \\<in> carrier_mat N N;\n                 A \\<in> carrier_mat K K\\<rbrakk>\n                \\<Longrightarrow> matrix_sum d\n                                   (\\<lambda>k. tensor_P (g k) A) m =\n                                  tensor_P (matrix_sum N g m) A;\n        \\<And>k. k < Suc m \\<Longrightarrow> g k \\<in> carrier_mat N N;\n        A \\<in> carrier_mat K K\\<rbrakk>\n       \\<Longrightarrow> matrix_sum d (\\<lambda>k. tensor_P (g k) A)\n                          (Suc m) =\n                         tensor_P (matrix_sum N g (Suc m)) A", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_sum d (\\<lambda>k. tensor_P (g k) A) (Suc m) =\n    tensor_P (matrix_sum N g (Suc m)) A", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. tensor_P (g m) A + matrix_sum d (\\<lambda>k. tensor_P (g k) A) m =\n    tensor_P (g m + matrix_sum N g m) A", "apply (subst ind)"], ["proof (prove)\ngoal (1 subgoal):\n 1. tensor_P (g m) A + tensor_P (matrix_sum N g m) A =\n    tensor_P (g m + matrix_sum N g m) A", "unfolding ps2_P.ptensor_mat_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ps_P.tensor_mat (g m) A + ps_P.tensor_mat (matrix_sum N g m) A =\n    ps_P.tensor_mat (g m + matrix_sum N g m) A", "apply (subst ps_P.tensor_mat_add1)"], ["proof (prove)\ngoal (4 subgoals):\n 1. g m \\<in> carrier_mat ps_P.d1 ps_P.d1\n 2. matrix_sum N g m \\<in> carrier_mat ps_P.d1 ps_P.d1\n 3. A \\<in> carrier_mat ps_P.d2 ps_P.d2\n 4. ps_P.tensor_mat (g m) A + ps_P.tensor_mat (matrix_sum N g m) A =\n    ps_P.tensor_mat (g m) A + ps_P.tensor_mat (matrix_sum N g m) A", "unfolding ps_P_d1 ps_P_d2"], ["proof (prove)\ngoal (4 subgoals):\n 1. g m \\<in> carrier_mat N N\n 2. matrix_sum N g m \\<in> carrier_mat N N\n 3. A \\<in> carrier_mat K K\n 4. ps_P.tensor_mat (g m) A + ps_P.tensor_mat (matrix_sum N g m) A =\n    ps_P.tensor_mat (g m) A + ps_P.tensor_mat (matrix_sum N g m) A", "using Suc ds"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>k. k < m \\<Longrightarrow> g k \\<in> carrier_mat N N;\n   A \\<in> carrier_mat K K\\<rbrakk>\n  \\<Longrightarrow> matrix_sum d (\\<lambda>k. tensor_P (g k) A) m =\n                    tensor_P (matrix_sum N g m) A\n  ?k2 < Suc m \\<Longrightarrow> g ?k2 \\<in> carrier_mat N N\n  A \\<in> carrier_mat K K\n  matrix_sum N g m \\<in> carrier_mat N N\n\ngoal (4 subgoals):\n 1. g m \\<in> carrier_mat N N\n 2. matrix_sum N g m \\<in> carrier_mat N N\n 3. A \\<in> carrier_mat K K\n 4. ps_P.tensor_mat (g m) A + ps_P.tensor_mat (matrix_sum N g m) A =\n    ps_P.tensor_mat (g m) A + ps_P.tensor_mat (matrix_sum N g m) A", "by auto"], ["proof (state)\nthis:\n  matrix_sum d (\\<lambda>k. tensor_P (g k) A) (Suc m) =\n  tensor_P (matrix_sum N g (Suc m)) A\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Grover's algorithm. Assume we start in the zero state\\<close>"], ["", "definition Grover :: com where\n  \"Grover = hadamard_n n ;;\n            While_P vars2 M0 M1 D ;;\n            Measure_P vars1 N testN (replicate N SKIP)\""], ["", "lemma well_com_if:\n  \"well_com (Measure_P vars1 N testN (replicate N SKIP))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. well_com (Measure_P vars1 N testN (replicate N SKIP))", "unfolding Measure_P_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. well_com\n     (Measure N (\\<lambda>n. mat_extension dims vars1 (testN n))\n       (replicate N SKIP))", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. measurement d N (\\<lambda>n. mat_extension dims vars1 (testN n))\n 2. list_all well_com (replicate N SKIP)", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. measurement d N (\\<lambda>n. mat_extension dims vars1 (testN n))\n 2. list_all well_com (replicate N SKIP)", "have eq0: \"\\<And>n. mat_extension dims vars1 (testN n) = tensor_P (testN n) (1\\<^sub>m K)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       mat_extension dims vars1 (testN n) = tensor_P (testN n) (1\\<^sub>m K)", "unfolding mat_ext_vars1"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       tensor_P (testN n) (1\\<^sub>m K) = tensor_P (testN n) (1\\<^sub>m K)", "by auto"], ["proof (state)\nthis:\n  mat_extension dims vars1 (testN ?n2) = tensor_P (testN ?n2) (1\\<^sub>m K)\n\ngoal (2 subgoals):\n 1. measurement d N (\\<lambda>n. mat_extension dims vars1 (testN n))\n 2. list_all well_com (replicate N SKIP)", "have eq1: \"adjoint (tensor_P (testN j) (1\\<^sub>m K)) * tensor_P (testN j) (1\\<^sub>m K) = tensor_P (testN j) (1\\<^sub>m K)\" for j"], ["proof (prove)\ngoal (1 subgoal):\n 1. adjoint (tensor_P (testN j) (1\\<^sub>m K)) *\n    tensor_P (testN j) (1\\<^sub>m K) =\n    tensor_P (testN j) (1\\<^sub>m K)", "unfolding ps2_P.ptensor_mat_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. adjoint (ps_P.tensor_mat (testN j) (1\\<^sub>m K)) *\n    ps_P.tensor_mat (testN j) (1\\<^sub>m K) =\n    ps_P.tensor_mat (testN j) (1\\<^sub>m K)", "apply (subst ps_P.tensor_mat_adjoint)"], ["proof (prove)\ngoal (3 subgoals):\n 1. testN j \\<in> carrier_mat ps_P.d1 ps_P.d1\n 2. 1\\<^sub>m K \\<in> carrier_mat ps_P.d2 ps_P.d2\n 3. ps_P.tensor_mat (adjoint (testN j)) (adjoint (1\\<^sub>m K)) *\n    ps_P.tensor_mat (testN j) (1\\<^sub>m K) =\n    ps_P.tensor_mat (testN j) (1\\<^sub>m K)", "apply (auto simp add: ps_P_d1 ps_P_d2 testN_dim hermitian_testN[unfolded hermitian_def] hermitian_one[unfolded hermitian_def])"], ["proof (prove)\ngoal (1 subgoal):\n 1. ps_P.tensor_mat (testN j) (1\\<^sub>m K) *\n    ps_P.tensor_mat (testN j) (1\\<^sub>m K) =\n    ps_P.tensor_mat (testN j) (1\\<^sub>m K)", "apply (subst ps_P.tensor_mat_mult[symmetric])"], ["proof (prove)\ngoal (3 subgoals):\n 1. testN j \\<in> carrier_mat ps_P.d1 ps_P.d1\n 2. 1\\<^sub>m K \\<in> carrier_mat ps_P.d2 ps_P.d2\n 3. ps_P.tensor_mat (testN j * testN j) (1\\<^sub>m K * 1\\<^sub>m K) =\n    ps_P.tensor_mat (testN j) (1\\<^sub>m K)", "by (auto simp add: ps_P_d1 ps_P_d2 testN_dim testN_mult_testN)"], ["proof (state)\nthis:\n  adjoint (tensor_P (testN ?j2) (1\\<^sub>m K)) *\n  tensor_P (testN ?j2) (1\\<^sub>m K) =\n  tensor_P (testN ?j2) (1\\<^sub>m K)\n\ngoal (2 subgoals):\n 1. measurement d N (\\<lambda>n. mat_extension dims vars1 (testN n))\n 2. list_all well_com (replicate N SKIP)", "have \"measurement d N (\\<lambda>n. tensor_P (testN n) (1\\<^sub>m K))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. measurement d N (\\<lambda>n. tensor_P (testN n) (1\\<^sub>m K))", "unfolding measurement_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>j<N.\n        tensor_P (testN j) (1\\<^sub>m K) \\<in> carrier_mat d d) \\<and>\n    matrix_sum d\n     (\\<lambda>j.\n         adjoint (tensor_P (testN j) (1\\<^sub>m K)) *\n         tensor_P (testN j) (1\\<^sub>m K))\n     N =\n    1\\<^sub>m d", "apply (simp add: tensor_P_dim)"], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_sum d\n     (\\<lambda>j.\n         adjoint (tensor_P (testN j) (1\\<^sub>m K)) *\n         tensor_P (testN j) (1\\<^sub>m K))\n     N =\n    1\\<^sub>m d", "apply (subst eq1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_sum d (\\<lambda>j. tensor_P (testN j) (1\\<^sub>m K)) N =\n    1\\<^sub>m d", "apply (subst matrix_sum_tensor_P1)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>k. k < N \\<Longrightarrow> testN k \\<in> carrier_mat N N\n 2. 1\\<^sub>m K \\<in> carrier_mat K K\n 3. tensor_P (matrix_sum N testN N) (1\\<^sub>m K) = 1\\<^sub>m d", "apply (auto simp add: testN_dim)"], ["proof (prove)\ngoal (1 subgoal):\n 1. tensor_P (matrix_sum N testN N) (1\\<^sub>m K) = 1\\<^sub>m d", "apply (subst sum_test_k, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. tensor_P (test_fst_k N) (1\\<^sub>m K) = 1\\<^sub>m d", "apply (subst test_fst_kN)"], ["proof (prove)\ngoal (1 subgoal):\n 1. tensor_P (1\\<^sub>m N) (1\\<^sub>m K) = 1\\<^sub>m d", "unfolding ps2_P.ptensor_mat_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ps_P.tensor_mat (1\\<^sub>m N) (1\\<^sub>m K) = 1\\<^sub>m d", "using ps_P.tensor_mat_id ps_P_d ps_P_d1 ps_P_d2"], ["proof (prove)\nusing this:\n  ps_P.tensor_mat (1\\<^sub>m ps_P.d1) (1\\<^sub>m ps_P.d2) = 1\\<^sub>m ps_P.d\n  ps_P.d = d\n  ps_P.d1 = N\n  ps_P.d2 = K\n\ngoal (1 subgoal):\n 1. ps_P.tensor_mat (1\\<^sub>m N) (1\\<^sub>m K) = 1\\<^sub>m d", "by auto"], ["proof (state)\nthis:\n  measurement d N (\\<lambda>n. tensor_P (testN n) (1\\<^sub>m K))\n\ngoal (2 subgoals):\n 1. measurement d N (\\<lambda>n. mat_extension dims vars1 (testN n))\n 2. list_all well_com (replicate N SKIP)", "then"], ["proof (chain)\npicking this:\n  measurement d N (\\<lambda>n. tensor_P (testN n) (1\\<^sub>m K))", "show \"measurement d N (\\<lambda>n. mat_extension dims vars1 (testN n))\""], ["proof (prove)\nusing this:\n  measurement d N (\\<lambda>n. tensor_P (testN n) (1\\<^sub>m K))\n\ngoal (1 subgoal):\n 1. measurement d N (\\<lambda>n. mat_extension dims vars1 (testN n))", "using eq0"], ["proof (prove)\nusing this:\n  measurement d N (\\<lambda>n. tensor_P (testN n) (1\\<^sub>m K))\n  mat_extension dims vars1 (testN ?n2) = tensor_P (testN ?n2) (1\\<^sub>m K)\n\ngoal (1 subgoal):\n 1. measurement d N (\\<lambda>n. mat_extension dims vars1 (testN n))", "by auto"], ["proof (state)\nthis:\n  measurement d N (\\<lambda>n. mat_extension dims vars1 (testN n))\n\ngoal (1 subgoal):\n 1. list_all well_com (replicate N SKIP)", "show \"list_all well_com (replicate N SKIP)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all well_com (replicate N SKIP)", "apply (subst list_all_length)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>n<length (replicate N SKIP). well_com (replicate N SKIP ! n)", "by simp"], ["proof (state)\nthis:\n  list_all well_com (replicate N SKIP)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma well_com_while:\n  \"well_com (While_P vars2 M0 M1 D)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. well_com (While_P vars2 M0 M1 D)", "unfolding While_P_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. well_com\n     (While\n       (\\<lambda>n.\n           if n = 0 then mat_extension dims vars2 M0\n           else if n = 1 then mat_extension dims vars2 M1 else undefined)\n       D)", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. measurement d 2\n     (\\<lambda>n.\n         if n = 0 then mat_extension dims vars2 M0\n         else if n = 1 then mat_extension dims vars2 M1 else undefined)\n 2. well_com D", "apply (subst (1 2) mat_ext_vars2)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>na. M1 \\<in> carrier_mat K K\n 2. \\<And>na. M0 \\<in> carrier_mat K K\n 3. measurement d 2\n     (\\<lambda>n.\n         if n = 0 then tensor_P (1\\<^sub>m N) M0\n         else if n = 1 then tensor_P (1\\<^sub>m N) M1 else undefined)\n 4. well_com D", "apply (auto simp add: M1_dim M0_dim)"], ["proof (prove)\ngoal (2 subgoals):\n 1. measurement d 2\n     (\\<lambda>n.\n         if n = 0 then tensor_P (1\\<^sub>m N) M0\n         else if n = 1 then tensor_P (1\\<^sub>m N) M1 else undefined)\n 2. well_com D", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. measurement d 2\n     (\\<lambda>n.\n         if n = 0 then tensor_P (1\\<^sub>m N) M0\n         else if n = 1 then tensor_P (1\\<^sub>m N) M1 else undefined)\n 2. well_com D", "have 2: \"2 = Suc (Suc 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 = Suc (Suc 0)", "by auto"], ["proof (state)\nthis:\n  2 = Suc (Suc 0)\n\ngoal (2 subgoals):\n 1. measurement d 2\n     (\\<lambda>n.\n         if n = 0 then tensor_P (1\\<^sub>m N) M0\n         else if n = 1 then tensor_P (1\\<^sub>m N) M1 else undefined)\n 2. well_com D", "have ad0: \"adjoint (tensor_P (1\\<^sub>m N) M0) = (tensor_P (1\\<^sub>m N) M0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adjoint (tensor_P (1\\<^sub>m N) M0) = tensor_P (1\\<^sub>m N) M0", "unfolding ps2_P.ptensor_mat_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. adjoint (ps_P.tensor_mat (1\\<^sub>m N) M0) =\n    ps_P.tensor_mat (1\\<^sub>m N) M0", "apply (subst ps_P.tensor_mat_adjoint)"], ["proof (prove)\ngoal (3 subgoals):\n 1. 1\\<^sub>m N \\<in> carrier_mat ps_P.d1 ps_P.d1\n 2. M0 \\<in> carrier_mat ps_P.d2 ps_P.d2\n 3. ps_P.tensor_mat (adjoint (1\\<^sub>m N)) (adjoint M0) =\n    ps_P.tensor_mat (1\\<^sub>m N) M0", "unfolding ps_P_d1 ps_P_d2"], ["proof (prove)\ngoal (3 subgoals):\n 1. 1\\<^sub>m N \\<in> carrier_mat N N\n 2. M0 \\<in> carrier_mat K K\n 3. ps_P.tensor_mat (adjoint (1\\<^sub>m N)) (adjoint M0) =\n    ps_P.tensor_mat (1\\<^sub>m N) M0", "by (auto simp add: M0_dim adjoint_one hermitian_M0[unfolded hermitian_def])"], ["proof (state)\nthis:\n  adjoint (tensor_P (1\\<^sub>m N) M0) = tensor_P (1\\<^sub>m N) M0\n\ngoal (2 subgoals):\n 1. measurement d 2\n     (\\<lambda>n.\n         if n = 0 then tensor_P (1\\<^sub>m N) M0\n         else if n = 1 then tensor_P (1\\<^sub>m N) M1 else undefined)\n 2. well_com D", "have ad1: \"adjoint (tensor_P (1\\<^sub>m N) M1) = (tensor_P (1\\<^sub>m N) M1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adjoint (tensor_P (1\\<^sub>m N) M1) = tensor_P (1\\<^sub>m N) M1", "unfolding ps2_P.ptensor_mat_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. adjoint (ps_P.tensor_mat (1\\<^sub>m N) M1) =\n    ps_P.tensor_mat (1\\<^sub>m N) M1", "apply (subst ps_P.tensor_mat_adjoint)"], ["proof (prove)\ngoal (3 subgoals):\n 1. 1\\<^sub>m N \\<in> carrier_mat ps_P.d1 ps_P.d1\n 2. M1 \\<in> carrier_mat ps_P.d2 ps_P.d2\n 3. ps_P.tensor_mat (adjoint (1\\<^sub>m N)) (adjoint M1) =\n    ps_P.tensor_mat (1\\<^sub>m N) M1", "unfolding ps_P_d1 ps_P_d2"], ["proof (prove)\ngoal (3 subgoals):\n 1. 1\\<^sub>m N \\<in> carrier_mat N N\n 2. M1 \\<in> carrier_mat K K\n 3. ps_P.tensor_mat (adjoint (1\\<^sub>m N)) (adjoint M1) =\n    ps_P.tensor_mat (1\\<^sub>m N) M1", "by (auto simp add: M1_dim adjoint_one hermitian_M1[unfolded hermitian_def])"], ["proof (state)\nthis:\n  adjoint (tensor_P (1\\<^sub>m N) M1) = tensor_P (1\\<^sub>m N) M1\n\ngoal (2 subgoals):\n 1. measurement d 2\n     (\\<lambda>n.\n         if n = 0 then tensor_P (1\\<^sub>m N) M0\n         else if n = 1 then tensor_P (1\\<^sub>m N) M1 else undefined)\n 2. well_com D", "have m0: \"tensor_P (1\\<^sub>m N) M0 * tensor_P (1\\<^sub>m N) M0 = tensor_P (1\\<^sub>m N) M0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tensor_P (1\\<^sub>m N) M0 * tensor_P (1\\<^sub>m N) M0 =\n    tensor_P (1\\<^sub>m N) M0", "unfolding ps2_P.ptensor_mat_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ps_P.tensor_mat (1\\<^sub>m N) M0 * ps_P.tensor_mat (1\\<^sub>m N) M0 =\n    ps_P.tensor_mat (1\\<^sub>m N) M0", "apply (subst ps_P.tensor_mat_mult[symmetric])"], ["proof (prove)\ngoal (3 subgoals):\n 1. 1\\<^sub>m N \\<in> carrier_mat ps_P.d1 ps_P.d1\n 2. M0 \\<in> carrier_mat ps_P.d2 ps_P.d2\n 3. ps_P.tensor_mat (1\\<^sub>m N * 1\\<^sub>m N) (M0 * M0) =\n    ps_P.tensor_mat (1\\<^sub>m N) M0", "unfolding ps_P_d1 ps_P_d2"], ["proof (prove)\ngoal (3 subgoals):\n 1. 1\\<^sub>m N \\<in> carrier_mat N N\n 2. M0 \\<in> carrier_mat K K\n 3. ps_P.tensor_mat (1\\<^sub>m N * 1\\<^sub>m N) (M0 * M0) =\n    ps_P.tensor_mat (1\\<^sub>m N) M0", "using M0_dim M0_mult_M0"], ["proof (prove)\nusing this:\n  M0 \\<in> carrier_mat K K\n  M0 * M0 = M0\n\ngoal (3 subgoals):\n 1. 1\\<^sub>m N \\<in> carrier_mat N N\n 2. M0 \\<in> carrier_mat K K\n 3. ps_P.tensor_mat (1\\<^sub>m N * 1\\<^sub>m N) (M0 * M0) =\n    ps_P.tensor_mat (1\\<^sub>m N) M0", "by auto"], ["proof (state)\nthis:\n  tensor_P (1\\<^sub>m N) M0 * tensor_P (1\\<^sub>m N) M0 =\n  tensor_P (1\\<^sub>m N) M0\n\ngoal (2 subgoals):\n 1. measurement d 2\n     (\\<lambda>n.\n         if n = 0 then tensor_P (1\\<^sub>m N) M0\n         else if n = 1 then tensor_P (1\\<^sub>m N) M1 else undefined)\n 2. well_com D", "have m1: \"tensor_P (1\\<^sub>m N) M1 * tensor_P (1\\<^sub>m N) M1 = tensor_P (1\\<^sub>m N) M1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tensor_P (1\\<^sub>m N) M1 * tensor_P (1\\<^sub>m N) M1 =\n    tensor_P (1\\<^sub>m N) M1", "unfolding ps2_P.ptensor_mat_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ps_P.tensor_mat (1\\<^sub>m N) M1 * ps_P.tensor_mat (1\\<^sub>m N) M1 =\n    ps_P.tensor_mat (1\\<^sub>m N) M1", "apply (subst ps_P.tensor_mat_mult[symmetric])"], ["proof (prove)\ngoal (3 subgoals):\n 1. 1\\<^sub>m N \\<in> carrier_mat ps_P.d1 ps_P.d1\n 2. M1 \\<in> carrier_mat ps_P.d2 ps_P.d2\n 3. ps_P.tensor_mat (1\\<^sub>m N * 1\\<^sub>m N) (M1 * M1) =\n    ps_P.tensor_mat (1\\<^sub>m N) M1", "unfolding ps_P_d1 ps_P_d2"], ["proof (prove)\ngoal (3 subgoals):\n 1. 1\\<^sub>m N \\<in> carrier_mat N N\n 2. M1 \\<in> carrier_mat K K\n 3. ps_P.tensor_mat (1\\<^sub>m N * 1\\<^sub>m N) (M1 * M1) =\n    ps_P.tensor_mat (1\\<^sub>m N) M1", "using M1_dim M1_mult_M1"], ["proof (prove)\nusing this:\n  M1 \\<in> carrier_mat K K\n  M1 * M1 = M1\n\ngoal (3 subgoals):\n 1. 1\\<^sub>m N \\<in> carrier_mat N N\n 2. M1 \\<in> carrier_mat K K\n 3. ps_P.tensor_mat (1\\<^sub>m N * 1\\<^sub>m N) (M1 * M1) =\n    ps_P.tensor_mat (1\\<^sub>m N) M1", "by auto"], ["proof (state)\nthis:\n  tensor_P (1\\<^sub>m N) M1 * tensor_P (1\\<^sub>m N) M1 =\n  tensor_P (1\\<^sub>m N) M1\n\ngoal (2 subgoals):\n 1. measurement d 2\n     (\\<lambda>n.\n         if n = 0 then tensor_P (1\\<^sub>m N) M0\n         else if n = 1 then tensor_P (1\\<^sub>m N) M1 else undefined)\n 2. well_com D", "have s: \"tensor_P (1\\<^sub>m N) M1 + tensor_P (1\\<^sub>m N) M0 = 1\\<^sub>m d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tensor_P (1\\<^sub>m N) M1 + tensor_P (1\\<^sub>m N) M0 = 1\\<^sub>m d", "unfolding ps2_P.ptensor_mat_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ps_P.tensor_mat (1\\<^sub>m N) M1 + ps_P.tensor_mat (1\\<^sub>m N) M0 =\n    1\\<^sub>m d", "apply (subst ps_P.tensor_mat_add2[symmetric])"], ["proof (prove)\ngoal (4 subgoals):\n 1. 1\\<^sub>m N \\<in> carrier_mat ps_P.d1 ps_P.d1\n 2. M1 \\<in> carrier_mat ps_P.d2 ps_P.d2\n 3. M0 \\<in> carrier_mat ps_P.d2 ps_P.d2\n 4. ps_P.tensor_mat (1\\<^sub>m N) (M1 + M0) = 1\\<^sub>m d", "unfolding ps_P_d1 ps_P_d2"], ["proof (prove)\ngoal (4 subgoals):\n 1. 1\\<^sub>m N \\<in> carrier_mat N N\n 2. M1 \\<in> carrier_mat K K\n 3. M0 \\<in> carrier_mat K K\n 4. ps_P.tensor_mat (1\\<^sub>m N) (M1 + M0) = 1\\<^sub>m d", "by (auto simp add: M1_dim M0_dim M1_add_M0 ps_P.tensor_mat_id[simplified ps_P_d1 ps_P_d2 ps_P_d])"], ["proof (state)\nthis:\n  tensor_P (1\\<^sub>m N) M1 + tensor_P (1\\<^sub>m N) M0 = 1\\<^sub>m d\n\ngoal (2 subgoals):\n 1. measurement d 2\n     (\\<lambda>n.\n         if n = 0 then tensor_P (1\\<^sub>m N) M0\n         else if n = 1 then tensor_P (1\\<^sub>m N) M1 else undefined)\n 2. well_com D", "show \"measurement d 2 (\\<lambda>n. if n = 0 then tensor_P (1\\<^sub>m N) M0 else if n = 1 then tensor_P (1\\<^sub>m N) M1 else undefined)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. measurement d 2\n     (\\<lambda>n.\n         if n = 0 then tensor_P (1\\<^sub>m N) M0\n         else if n = 1 then tensor_P (1\\<^sub>m N) M1 else undefined)", "unfolding measurement_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>j<2.\n        (if j = 0 then tensor_P (1\\<^sub>m N) M0\n         else if j = 1 then tensor_P (1\\<^sub>m N) M1 else undefined)\n        \\<in> carrier_mat d d) \\<and>\n    matrix_sum d\n     (\\<lambda>j.\n         adjoint\n          (if j = 0 then tensor_P (1\\<^sub>m N) M0\n           else if j = 1 then tensor_P (1\\<^sub>m N) M1 else undefined) *\n         (if j = 0 then tensor_P (1\\<^sub>m N) M0\n          else if j = 1 then tensor_P (1\\<^sub>m N) M1 else undefined))\n     2 =\n    1\\<^sub>m d", "apply (auto simp add: tensor_P_dim)"], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_sum d\n     (\\<lambda>j.\n         adjoint\n          (if j = 0 then tensor_P (1\\<^sub>m N) M0\n           else if j = 1 then tensor_P (1\\<^sub>m N) M1 else undefined) *\n         (if j = 0 then tensor_P (1\\<^sub>m N) M0\n          else if j = 1 then tensor_P (1\\<^sub>m N) M1 else undefined))\n     2 =\n    1\\<^sub>m d", "apply (subst 2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_sum d\n     (\\<lambda>j.\n         adjoint\n          (if j = 0 then tensor_P (1\\<^sub>m N) M0\n           else if j = 1 then tensor_P (1\\<^sub>m N) M1 else undefined) *\n         (if j = 0 then tensor_P (1\\<^sub>m N) M0\n          else if j = 1 then tensor_P (1\\<^sub>m N) M1 else undefined))\n     (Suc (Suc 0)) =\n    1\\<^sub>m d", "apply (simp add: ad0 ad1 m0 m1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. tensor_P (1\\<^sub>m N) M1 +\n    (tensor_P (1\\<^sub>m N) M0 + 0\\<^sub>m d d) =\n    1\\<^sub>m d", "apply (subst assoc_add_mat[symmetric, of _ d d])"], ["proof (prove)\ngoal (4 subgoals):\n 1. tensor_P (1\\<^sub>m N) M1 \\<in> carrier_mat d d\n 2. tensor_P (1\\<^sub>m N) M0 \\<in> carrier_mat d d\n 3. 0\\<^sub>m d d \\<in> carrier_mat d d\n 4. tensor_P (1\\<^sub>m N) M1 + tensor_P (1\\<^sub>m N) M0 + 0\\<^sub>m d d =\n    1\\<^sub>m d", "using tensor_P_dim s"], ["proof (prove)\nusing this:\n  tensor_P ?A ?B \\<in> carrier_mat d d\n  tensor_P (1\\<^sub>m N) M1 + tensor_P (1\\<^sub>m N) M0 = 1\\<^sub>m d\n\ngoal (4 subgoals):\n 1. tensor_P (1\\<^sub>m N) M1 \\<in> carrier_mat d d\n 2. tensor_P (1\\<^sub>m N) M0 \\<in> carrier_mat d d\n 3. 0\\<^sub>m d d \\<in> carrier_mat d d\n 4. tensor_P (1\\<^sub>m N) M1 + tensor_P (1\\<^sub>m N) M0 + 0\\<^sub>m d d =\n    1\\<^sub>m d", "by auto"], ["proof (state)\nthis:\n  measurement d 2\n   (\\<lambda>n.\n       if n = 0 then tensor_P (1\\<^sub>m N) M0\n       else if n = 1 then tensor_P (1\\<^sub>m N) M1 else undefined)\n\ngoal (1 subgoal):\n 1. well_com D", "show \"well_com D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. well_com D", "using well_com_D"], ["proof (prove)\nusing this:\n  well_com D\n\ngoal (1 subgoal):\n 1. well_com D", "by auto"], ["proof (state)\nthis:\n  well_com D\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma well_com_Grover:\n  \"well_com Grover\""], ["proof (prove)\ngoal (1 subgoal):\n 1. well_com Grover", "unfolding Grover_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. well_com\n     (hadamard_n n;; While_P vars2 M0 M1 D;;\n      Measure_P vars1 N testN (replicate N SKIP))", "apply auto"], ["proof (prove)\ngoal (3 subgoals):\n 1. well_com (hadamard_n n)\n 2. well_com (While_P vars2 M0 M1 D)\n 3. well_com (Measure_P vars1 N testN (replicate N SKIP))", "using well_com_hadamard_n well_com_if well_com_while"], ["proof (prove)\nusing this:\n  well_com (hadamard_n n)\n  well_com (Measure_P vars1 N testN (replicate N SKIP))\n  well_com (While_P vars2 M0 M1 D)\n\ngoal (3 subgoals):\n 1. well_com (hadamard_n n)\n 2. well_com (While_P vars2 M0 M1 D)\n 3. well_com (Measure_P vars1 N testN (replicate N SKIP))", "by auto"], ["", "subsection \\<open>Correctness\\<close>"], ["", "text \\<open>Pre-condition: assume in the zero state\\<close>"], ["", "definition ket_pre :: \"complex vec\" where\n  \"ket_pre = Matrix.vec N (\\<lambda>k. if k = 0 then 1 else 0)\""], ["", "lemma ket_pre_dim:\n  \"ket_pre \\<in> carrier_vec N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ket_pre \\<in> carrier_vec N", "using ket_pre_def"], ["proof (prove)\nusing this:\n  ket_pre = Matrix.vec N (\\<lambda>k. if k = 0 then 1 else 0)\n\ngoal (1 subgoal):\n 1. ket_pre \\<in> carrier_vec N", "by auto"], ["", "definition pre :: \"complex mat\" where\n  \"pre = proj ket_pre\""], ["", "lemma pre_dim:\n  \"pre \\<in> carrier_mat N N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pre \\<in> carrier_mat N N", "using pre_def ket_pre_def"], ["proof (prove)\nusing this:\n  pre = outer_prod ket_pre ket_pre\n  ket_pre = Matrix.vec N (\\<lambda>k. if k = 0 then 1 else 0)\n\ngoal (1 subgoal):\n 1. pre \\<in> carrier_mat N N", "by auto"], ["", "lemma norm_pre:\n  \"inner_prod ket_pre ket_pre = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inner_prod ket_pre ket_pre = 1", "unfolding ket_pre_def scalar_prod_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<dim_vec\n                    (conjugate\n                      (Matrix.vec N (\\<lambda>k. if k = 0 then 1 else 0))).\n        Matrix.vec N (\\<lambda>k. if k = 0 then 1 else 0) $ i *\n        conjugate (Matrix.vec N (\\<lambda>k. if k = 0 then 1 else 0)) $ i) =\n    1", "using sum_only_one_neq_0[of \"{0..<N}\" 0 \"\\<lambda>i. (if i = 0 then 1 else 0) * cnj (if i = 0 then 1 else 0)\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>finite {0..<N}; 0 \\<in> {0..<N};\n   \\<And>i.\n      \\<lbrakk>i \\<in> {0..<N}; i \\<noteq> 0\\<rbrakk>\n      \\<Longrightarrow> (if i = 0 then 1 else 0) *\n                        cnj (if i = 0 then 1 else 0) =\n                        0\\<rbrakk>\n  \\<Longrightarrow> (\\<Sum>i = 0..<N.\n                        (if i = 0 then 1 else 0) *\n                        cnj (if i = 0 then 1 else 0)) =\n                    (if 0 = 0 then 1 else 0) * cnj (if 0 = 0 then 1 else 0)\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<dim_vec\n                    (conjugate\n                      (Matrix.vec N (\\<lambda>k. if k = 0 then 1 else 0))).\n        Matrix.vec N (\\<lambda>k. if k = 0 then 1 else 0) $ i *\n        conjugate (Matrix.vec N (\\<lambda>k. if k = 0 then 1 else 0)) $ i) =\n    1", "by auto"], ["", "lemma pre_trace:\n  \"trace pre = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace pre = 1", "unfolding pre_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. trace (outer_prod ket_pre ket_pre) = 1", "apply (subst trace_outer_prod[of _ N])"], ["proof (prove)\ngoal (2 subgoals):\n 1. ket_pre \\<in> carrier_vec N\n 2. inner_prod ket_pre ket_pre = 1", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. ket_pre \\<in> carrier_vec N", "unfolding ket_pre_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Matrix.vec N (\\<lambda>k. if k = 0 then 1 else 0) \\<in> carrier_vec N", "by auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. inner_prod ket_pre ket_pre = 1", "using norm_pre"], ["proof (prove)\nusing this:\n  inner_prod ket_pre ket_pre = 1\n\ngoal (1 subgoal):\n 1. inner_prod ket_pre ket_pre = 1", "by auto"], ["", "lemma positive_pre:\n  \"positive pre\""], ["proof (prove)\ngoal (1 subgoal):\n 1. positive pre", "using positive_same_outer_prod"], ["proof (prove)\nusing this:\n  ?v \\<in> carrier_vec ?n \\<Longrightarrow> positive (outer_prod ?v ?v)\n\ngoal (1 subgoal):\n 1. positive pre", "unfolding pre_def ket_pre_def"], ["proof (prove)\nusing this:\n  ?v \\<in> carrier_vec ?n \\<Longrightarrow> positive (outer_prod ?v ?v)\n\ngoal (1 subgoal):\n 1. positive\n     (outer_prod (Matrix.vec N (\\<lambda>k. if k = 0 then 1 else 0))\n       (Matrix.vec N (\\<lambda>k. if k = 0 then 1 else 0)))", "by auto"], ["", "lemma pre_le_one:\n  \"pre \\<le>\\<^sub>L 1\\<^sub>m N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pre \\<le>\\<^sub>L 1\\<^sub>m N", "unfolding pre_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. outer_prod ket_pre ket_pre \\<le>\\<^sub>L 1\\<^sub>m N", "using outer_prod_le_one norm_pre ket_pre_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>?v \\<in> carrier_vec ?n; inner_prod ?v ?v \\<le> 1\\<rbrakk>\n  \\<Longrightarrow> outer_prod ?v ?v \\<le>\\<^sub>L 1\\<^sub>m ?n\n  inner_prod ket_pre ket_pre = 1\n  ket_pre = Matrix.vec N (\\<lambda>k. if k = 0 then 1 else 0)\n\ngoal (1 subgoal):\n 1. outer_prod ket_pre ket_pre \\<le>\\<^sub>L 1\\<^sub>m N", "by auto"], ["", "text \\<open>Post-condition: should be in a state i with f i = 1\\<close>"], ["", "definition post :: \"complex mat\" where\n  \"post = mat N N (\\<lambda>(i, j). if (i = j \\<and> f i) then 1 else 0)\""], ["", "lemma post_dim:\n  \"post \\<in> carrier_mat N N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. post \\<in> carrier_mat N N", "unfolding post_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat N N (\\<lambda>(i, j). if i = j \\<and> f i then 1 else 0)\n    \\<in> carrier_mat N N", "by auto"], ["", "lemma hermitian_post:\n  \"hermitian post\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hermitian post", "unfolding hermitian_def post_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. adjoint (mat N N (\\<lambda>(i, j). if i = j \\<and> f i then 1 else 0)) =\n    mat N N (\\<lambda>(i, j). if i = j \\<and> f i then 1 else 0)", "by (auto simp add: adjoint_eval)"], ["", "text \\<open>Hoare triples of initialization\\<close>"], ["", "definition ket_zero :: \"complex vec\" where\n  \"ket_zero = Matrix.vec 2 (\\<lambda>k. if k = 0 then 1 else 0)\""], ["", "lemma ket_zero_dim:\n  \"ket_zero \\<in> carrier_vec 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ket_zero \\<in> carrier_vec 2", "unfolding ket_zero_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Matrix.vec 2 (\\<lambda>k. if k = 0 then 1 else 0) \\<in> carrier_vec 2", "by auto"], ["", "definition proj_zero where\n  \"proj_zero = proj ket_zero\""], ["", "definition ket_one where\n  \"ket_one = Matrix.vec 2 (\\<lambda>k. if k = 1 then 1 else 0)\""], ["", "definition proj_one where\n  \"proj_one = proj ket_one\""], ["", "definition ket_plus where\n  \"ket_plus = Matrix.vec 2 (\\<lambda>k.1 / csqrt 2) \""], ["", "lemma ket_plus_dim:\n  \"ket_plus \\<in> carrier_vec 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ket_plus \\<in> carrier_vec 2", "unfolding ket_plus_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Matrix.vec 2 (\\<lambda>k. 1 / csqrt 2) \\<in> carrier_vec 2", "by auto"], ["", "lemma ket_plus_eval [simp]:\n  \"i < 2 \\<Longrightarrow> ket_plus $ i = 1 / csqrt 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < 2 \\<Longrightarrow> ket_plus $ i = 1 / csqrt 2", "apply (simp only: ket_plus_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. i < 2 \\<Longrightarrow>\n    Matrix.vec 2 (\\<lambda>k. 1 / csqrt 2) $ i = 1 / csqrt 2", "using index_vec less_2_cases"], ["proof (prove)\nusing this:\n  ?i < ?n \\<Longrightarrow> Matrix.vec ?n ?f $ ?i = ?f ?i\n  ?n < 2 \\<Longrightarrow> ?n = 0 \\<or> ?n = Suc 0\n\ngoal (1 subgoal):\n 1. i < 2 \\<Longrightarrow>\n    Matrix.vec 2 (\\<lambda>k. 1 / csqrt 2) $ i = 1 / csqrt 2", "by force"], ["", "lemma csqrt_2_sq [simp]:\n  \"complex_of_real (sqrt 2) * complex_of_real (sqrt 2) = 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. complex_of_real (sqrt 2) * complex_of_real (sqrt 2) = 2", "by (smt of_real_add of_real_hom.hom_one of_real_power one_add_one power2_eq_square real_sqrt_pow2)"], ["", "lemma ket_plus_tensor_n:\n  \"partial_state.tensor_vec [2, 2] {0} ket_plus ket_plus = Matrix.vec 4 (\\<lambda>k. 1 / 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. partial_state.tensor_vec [2, 2] {0} ket_plus ket_plus =\n    Matrix.vec 4 (\\<lambda>k. 1 / 2)", "unfolding partial_state.tensor_vec_def state_sig.d_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Matrix.vec (prod_list [2, 2])\n     (\\<lambda>i.\n         ket_plus $ partial_state.encode1 [2, 2] {0} i *\n         ket_plus $ partial_state.encode2 [2, 2] {0} i) =\n    Matrix.vec 4 (\\<lambda>k. 1 / 2)", "proof (rule eq_vecI, auto)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < 4 \\<Longrightarrow>\n       ket_plus $ partial_state.encode1 [2, 2] {0} i *\n       ket_plus $ partial_state.encode2 [2, 2] {0} i *\n       2 =\n       1", "fix i :: nat"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < 4 \\<Longrightarrow>\n       ket_plus $ partial_state.encode1 [2, 2] {0} i *\n       ket_plus $ partial_state.encode2 [2, 2] {0} i *\n       2 =\n       1", "assume i: \"i < 4\""], ["proof (state)\nthis:\n  i < 4\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < 4 \\<Longrightarrow>\n       ket_plus $ partial_state.encode1 [2, 2] {0} i *\n       ket_plus $ partial_state.encode2 [2, 2] {0} i *\n       2 =\n       1", "interpret st: partial_state \"[2, 2]\" \"{0}\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < 4 \\<Longrightarrow>\n       ket_plus $ st.encode1 i * ket_plus $ st.encode2 i * 2 = 1", "have d1_eq: \"st.d1 = 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. st.d1 = 2", "by (simp add: st.d1_def st.dims1_def nths_def)"], ["proof (state)\nthis:\n  st.d1 = 2\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < 4 \\<Longrightarrow>\n       ket_plus $ st.encode1 i * ket_plus $ st.encode2 i * 2 = 1", "have \"st.encode1 i < st.d1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. st.encode1 i < st.d1", "by (simp add: st.d_def i)"], ["proof (state)\nthis:\n  st.encode1 i < st.d1\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < 4 \\<Longrightarrow>\n       ket_plus $ st.encode1 i * ket_plus $ st.encode2 i * 2 = 1", "then"], ["proof (chain)\npicking this:\n  st.encode1 i < st.d1", "have i1_lt: \"st.encode1 i < 2\""], ["proof (prove)\nusing this:\n  st.encode1 i < st.d1\n\ngoal (1 subgoal):\n 1. st.encode1 i < 2", "using d1_eq"], ["proof (prove)\nusing this:\n  st.encode1 i < st.d1\n  st.d1 = 2\n\ngoal (1 subgoal):\n 1. st.encode1 i < 2", "by auto"], ["proof (state)\nthis:\n  st.encode1 i < 2\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < 4 \\<Longrightarrow>\n       ket_plus $ st.encode1 i * ket_plus $ st.encode2 i * 2 = 1", "have d2_eq: \"st.d2 = 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. st.d2 = 2", "by (simp add: st.d2_def st.dims2_def nths_def)"], ["proof (state)\nthis:\n  st.d2 = 2\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < 4 \\<Longrightarrow>\n       ket_plus $ st.encode1 i * ket_plus $ st.encode2 i * 2 = 1", "have \"st.encode2 i < st.d2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. st.encode2 i < st.d2", "by (simp add: st.d_def i)"], ["proof (state)\nthis:\n  st.encode2 i < st.d2\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < 4 \\<Longrightarrow>\n       ket_plus $ st.encode1 i * ket_plus $ st.encode2 i * 2 = 1", "then"], ["proof (chain)\npicking this:\n  st.encode2 i < st.d2", "have i2_lt: \"st.encode2 i < 2\""], ["proof (prove)\nusing this:\n  st.encode2 i < st.d2\n\ngoal (1 subgoal):\n 1. st.encode2 i < 2", "using d2_eq"], ["proof (prove)\nusing this:\n  st.encode2 i < st.d2\n  st.d2 = 2\n\ngoal (1 subgoal):\n 1. st.encode2 i < 2", "by auto"], ["proof (state)\nthis:\n  st.encode2 i < 2\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < 4 \\<Longrightarrow>\n       ket_plus $ st.encode1 i * ket_plus $ st.encode2 i * 2 = 1", "show \"ket_plus $ st.encode1 i * ket_plus $ st.encode2 i * 2 = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ket_plus $ st.encode1 i * ket_plus $ st.encode2 i * 2 = 1", "by (auto simp add: i1_lt i2_lt)"], ["proof (state)\nthis:\n  ket_plus $ st.encode1 i * ket_plus $ st.encode2 i * 2 = 1\n\ngoal:\nNo subgoals!", "qed"], ["", "definition proj_plus where\n  \"proj_plus = proj ket_plus\""], ["", "lemma hadamard_on_zero:\n  \"hadamard *\\<^sub>v ket_zero = ket_plus\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hadamard *\\<^sub>v ket_zero = ket_plus", "unfolding hadamard_def ket_zero_def ket_plus_def mat_of_rows_list_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat 2 2\n     (\\<lambda>(i, j).\n         if i = 0 \\<or> j = 0 then 1 / csqrt 2\n         else complex_of_real (- 1 / sqrt 2)) *\\<^sub>v\n    Matrix.vec 2 (\\<lambda>k. if k = 0 then 1 else 0) =\n    Matrix.vec 2 (\\<lambda>k. 1 / csqrt 2)", "apply (rule eq_vecI, auto simp add: scalar_prod_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < 2 \\<Longrightarrow>\n       (\\<Sum>ia = 0..<2.\n           (if i = 0 \\<or> ia = 0 then 1 / csqrt 2\n            else complex_of_real (- 1 / sqrt 2)) *\n           (if ia = 0 then 1 else 0)) =\n       1 / complex_of_real (sqrt 2)", "subgoal for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. i < 2 \\<Longrightarrow>\n    (\\<Sum>ia = 0..<2.\n        (if i = 0 \\<or> ia = 0 then 1 / csqrt 2\n         else complex_of_real (- 1 / sqrt 2)) *\n        (if ia = 0 then 1 else 0)) =\n    1 / complex_of_real (sqrt 2)", "apply (drule less_2_cases)"], ["proof (prove)\ngoal (1 subgoal):\n 1. i = 0 \\<or> i = Suc 0 \\<Longrightarrow>\n    (\\<Sum>ia = 0..<2.\n        (if i = 0 \\<or> ia = 0 then 1 / csqrt 2\n         else complex_of_real (- 1 / sqrt 2)) *\n        (if ia = 0 then 1 else 0)) =\n    1 / complex_of_real (sqrt 2)", "apply (drule disjE, auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow>\n    (\\<Sum>i = 0..<2. (if i = 0 then 1 else 0) / complex_of_real (sqrt 2)) =\n    1 / complex_of_real (sqrt 2)\n 2. i = Suc 0 \\<Longrightarrow>\n    (\\<Sum>i = 0..<2.\n        (if i = 0 then 1 / csqrt 2 else complex_of_real (- 1 / sqrt 2)) *\n        (if i = 0 then 1 else 0)) =\n    1 / complex_of_real (sqrt 2)", "by (subst sum_le_2, auto)+"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "fun exH_k :: \"nat \\<Rightarrow> complex mat\" where\n  \"exH_k 0 = hadamard_on_i 0\"\n| \"exH_k (Suc k) = exH_k k * hadamard_on_i (Suc k)\""], ["", "fun H_k :: \"nat \\<Rightarrow> complex mat\" where\n  \"H_k 0 = hadamard\"\n| \"H_k (Suc k) = ptensor_mat dims {0..<Suc k} {Suc k} (H_k k) hadamard\""], ["", "lemma H_k_dim:\n  \"k < n \\<Longrightarrow> H_k k \\<in> carrier_mat (2^(Suc k)) (2^(Suc k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k < n \\<Longrightarrow> H_k k \\<in> carrier_mat (2 ^ Suc k) (2 ^ Suc k)", "proof (induct k)"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 < n \\<Longrightarrow> H_k 0 \\<in> carrier_mat (2 ^ Suc 0) (2 ^ Suc 0)\n 2. \\<And>k.\n       \\<lbrakk>k < n \\<Longrightarrow>\n                H_k k \\<in> carrier_mat (2 ^ Suc k) (2 ^ Suc k);\n        Suc k < n\\<rbrakk>\n       \\<Longrightarrow> H_k (Suc k)\n                         \\<in> carrier_mat (2 ^ Suc (Suc k))\n                                (2 ^ Suc (Suc k))", "case 0"], ["proof (state)\nthis:\n  0 < n\n\ngoal (2 subgoals):\n 1. 0 < n \\<Longrightarrow> H_k 0 \\<in> carrier_mat (2 ^ Suc 0) (2 ^ Suc 0)\n 2. \\<And>k.\n       \\<lbrakk>k < n \\<Longrightarrow>\n                H_k k \\<in> carrier_mat (2 ^ Suc k) (2 ^ Suc k);\n        Suc k < n\\<rbrakk>\n       \\<Longrightarrow> H_k (Suc k)\n                         \\<in> carrier_mat (2 ^ Suc (Suc k))\n                                (2 ^ Suc (Suc k))", "then"], ["proof (chain)\npicking this:\n  0 < n", "show ?case"], ["proof (prove)\nusing this:\n  0 < n\n\ngoal (1 subgoal):\n 1. H_k 0 \\<in> carrier_mat (2 ^ Suc 0) (2 ^ Suc 0)", "using hadamard_dim"], ["proof (prove)\nusing this:\n  0 < n\n  hadamard \\<in> carrier_mat 2 2\n\ngoal (1 subgoal):\n 1. H_k 0 \\<in> carrier_mat (2 ^ Suc 0) (2 ^ Suc 0)", "by auto"], ["proof (state)\nthis:\n  H_k 0 \\<in> carrier_mat (2 ^ Suc 0) (2 ^ Suc 0)\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < n \\<Longrightarrow>\n                H_k k \\<in> carrier_mat (2 ^ Suc k) (2 ^ Suc k);\n        Suc k < n\\<rbrakk>\n       \\<Longrightarrow> H_k (Suc k)\n                         \\<in> carrier_mat (2 ^ Suc (Suc k))\n                                (2 ^ Suc (Suc k))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < n \\<Longrightarrow>\n                H_k k \\<in> carrier_mat (2 ^ Suc k) (2 ^ Suc k);\n        Suc k < n\\<rbrakk>\n       \\<Longrightarrow> H_k (Suc k)\n                         \\<in> carrier_mat (2 ^ Suc (Suc k))\n                                (2 ^ Suc (Suc k))", "case (Suc k)"], ["proof (state)\nthis:\n  k < n \\<Longrightarrow> H_k k \\<in> carrier_mat (2 ^ Suc k) (2 ^ Suc k)\n  Suc k < n\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < n \\<Longrightarrow>\n                H_k k \\<in> carrier_mat (2 ^ Suc k) (2 ^ Suc k);\n        Suc k < n\\<rbrakk>\n       \\<Longrightarrow> H_k (Suc k)\n                         \\<in> carrier_mat (2 ^ Suc (Suc k))\n                                (2 ^ Suc (Suc k))", "interpret st: partial_state2 dims \"{0..<(Suc k)}\" \"{Suc k}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. partial_state2 {0..<Suc k} {Suc k}", "apply unfold_locales"], ["proof (prove)\ngoal (1 subgoal):\n 1. {0..<Suc k} \\<inter> {Suc k} = {}", "by auto"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < n \\<Longrightarrow>\n                H_k k \\<in> carrier_mat (2 ^ Suc k) (2 ^ Suc k);\n        Suc k < n\\<rbrakk>\n       \\<Longrightarrow> H_k (Suc k)\n                         \\<in> carrier_mat (2 ^ Suc (Suc k))\n                                (2 ^ Suc (Suc k))", "have \"Suc (Suc k) \\<le> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc (Suc k) \\<le> n", "using Suc"], ["proof (prove)\nusing this:\n  k < n \\<Longrightarrow> H_k k \\<in> carrier_mat (2 ^ Suc k) (2 ^ Suc k)\n  Suc k < n\n\ngoal (1 subgoal):\n 1. Suc (Suc k) \\<le> n", "by auto"], ["proof (state)\nthis:\n  Suc (Suc k) \\<le> n\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < n \\<Longrightarrow>\n                H_k k \\<in> carrier_mat (2 ^ Suc k) (2 ^ Suc k);\n        Suc k < n\\<rbrakk>\n       \\<Longrightarrow> H_k (Suc k)\n                         \\<in> carrier_mat (2 ^ Suc (Suc k))\n                                (2 ^ Suc (Suc k))", "then"], ["proof (chain)\npicking this:\n  Suc (Suc k) \\<le> n", "have \"nths dims ({0..<Suc (Suc k)}) = replicate (Suc (Suc k)) 2\""], ["proof (prove)\nusing this:\n  Suc (Suc k) \\<le> n\n\ngoal (1 subgoal):\n 1. nths dims {0..<Suc (Suc k)} = replicate (Suc (Suc k)) 2", "using dims_nths_le_n"], ["proof (prove)\nusing this:\n  Suc (Suc k) \\<le> n\n  ?l \\<le> n \\<Longrightarrow> nths dims {0..<?l} = replicate ?l 2\n\ngoal (1 subgoal):\n 1. nths dims {0..<Suc (Suc k)} = replicate (Suc (Suc k)) 2", "by auto"], ["proof (state)\nthis:\n  nths dims {0..<Suc (Suc k)} = replicate (Suc (Suc k)) 2\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < n \\<Longrightarrow>\n                H_k k \\<in> carrier_mat (2 ^ Suc k) (2 ^ Suc k);\n        Suc k < n\\<rbrakk>\n       \\<Longrightarrow> H_k (Suc k)\n                         \\<in> carrier_mat (2 ^ Suc (Suc k))\n                                (2 ^ Suc (Suc k))", "moreover"], ["proof (state)\nthis:\n  nths dims {0..<Suc (Suc k)} = replicate (Suc (Suc k)) 2\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < n \\<Longrightarrow>\n                H_k k \\<in> carrier_mat (2 ^ Suc k) (2 ^ Suc k);\n        Suc k < n\\<rbrakk>\n       \\<Longrightarrow> H_k (Suc k)\n                         \\<in> carrier_mat (2 ^ Suc (Suc k))\n                                (2 ^ Suc (Suc k))", "have \"prod_list (replicate l 2) = 2^l\" for l"], ["proof (prove)\ngoal (1 subgoal):\n 1. prod_list (replicate l (2::'a)) = (2::'a) ^ l", "by simp"], ["proof (state)\nthis:\n  prod_list (replicate ?l3 (2::?'a4)) = (2::?'a4) ^ ?l3\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < n \\<Longrightarrow>\n                H_k k \\<in> carrier_mat (2 ^ Suc k) (2 ^ Suc k);\n        Suc k < n\\<rbrakk>\n       \\<Longrightarrow> H_k (Suc k)\n                         \\<in> carrier_mat (2 ^ Suc (Suc k))\n                                (2 ^ Suc (Suc k))", "moreover"], ["proof (state)\nthis:\n  prod_list (replicate ?l3 (2::?'a4)) = (2::?'a4) ^ ?l3\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < n \\<Longrightarrow>\n                H_k k \\<in> carrier_mat (2 ^ Suc k) (2 ^ Suc k);\n        Suc k < n\\<rbrakk>\n       \\<Longrightarrow> H_k (Suc k)\n                         \\<in> carrier_mat (2 ^ Suc (Suc k))\n                                (2 ^ Suc (Suc k))", "have \"{0..<Suc k} \\<union> {Suc k} = {0..<(Suc (Suc k))}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {0..<Suc k} \\<union> {Suc k} = {0..<Suc (Suc k)}", "by auto"], ["proof (state)\nthis:\n  {0..<Suc k} \\<union> {Suc k} = {0..<Suc (Suc k)}\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < n \\<Longrightarrow>\n                H_k k \\<in> carrier_mat (2 ^ Suc k) (2 ^ Suc k);\n        Suc k < n\\<rbrakk>\n       \\<Longrightarrow> H_k (Suc k)\n                         \\<in> carrier_mat (2 ^ Suc (Suc k))\n                                (2 ^ Suc (Suc k))", "ultimately"], ["proof (chain)\npicking this:\n  nths dims {0..<Suc (Suc k)} = replicate (Suc (Suc k)) 2\n  prod_list (replicate ?l3 (2::?'a4)) = (2::?'a4) ^ ?l3\n  {0..<Suc k} \\<union> {Suc k} = {0..<Suc (Suc k)}", "have plssk: \"prod_list (nths dims ({0..<Suc k} \\<union> {Suc k})) = 2^(Suc (Suc k))\""], ["proof (prove)\nusing this:\n  nths dims {0..<Suc (Suc k)} = replicate (Suc (Suc k)) 2\n  prod_list (replicate ?l3 (2::?'a4)) = (2::?'a4) ^ ?l3\n  {0..<Suc k} \\<union> {Suc k} = {0..<Suc (Suc k)}\n\ngoal (1 subgoal):\n 1. prod_list (nths dims ({0..<Suc k} \\<union> {Suc k})) = 2 ^ Suc (Suc k)", "by auto"], ["proof (state)\nthis:\n  prod_list (nths dims ({0..<Suc k} \\<union> {Suc k})) = 2 ^ Suc (Suc k)\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < n \\<Longrightarrow>\n                H_k k \\<in> carrier_mat (2 ^ Suc k) (2 ^ Suc k);\n        Suc k < n\\<rbrakk>\n       \\<Longrightarrow> H_k (Suc k)\n                         \\<in> carrier_mat (2 ^ Suc (Suc k))\n                                (2 ^ Suc (Suc k))", "have \"dim_col (H_k (Suc k)) = 2^(Suc (Suc k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_col (H_k (Suc k)) = 2 ^ Suc (Suc k)", "using st.ptensor_mat_dim_col"], ["proof (prove)\nusing this:\n  dim_col (st.ptensor_mat ?m1.0 ?m2.0) = st.d0\n\ngoal (1 subgoal):\n 1. dim_col (H_k (Suc k)) = 2 ^ Suc (Suc k)", "unfolding st.d0_def st.dims0_def st.vars0_def"], ["proof (prove)\nusing this:\n  dim_col (st.ptensor_mat ?m1.0 ?m2.0) =\n  prod_list (nths dims ({0..<Suc k} \\<union> {Suc k}))\n\ngoal (1 subgoal):\n 1. dim_col (H_k (Suc k)) = 2 ^ Suc (Suc k)", "using plssk"], ["proof (prove)\nusing this:\n  dim_col (st.ptensor_mat ?m1.0 ?m2.0) =\n  prod_list (nths dims ({0..<Suc k} \\<union> {Suc k}))\n  prod_list (nths dims ({0..<Suc k} \\<union> {Suc k})) = 2 ^ Suc (Suc k)\n\ngoal (1 subgoal):\n 1. dim_col (H_k (Suc k)) = 2 ^ Suc (Suc k)", "by auto"], ["proof (state)\nthis:\n  dim_col (H_k (Suc k)) = 2 ^ Suc (Suc k)\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < n \\<Longrightarrow>\n                H_k k \\<in> carrier_mat (2 ^ Suc k) (2 ^ Suc k);\n        Suc k < n\\<rbrakk>\n       \\<Longrightarrow> H_k (Suc k)\n                         \\<in> carrier_mat (2 ^ Suc (Suc k))\n                                (2 ^ Suc (Suc k))", "moreover"], ["proof (state)\nthis:\n  dim_col (H_k (Suc k)) = 2 ^ Suc (Suc k)\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < n \\<Longrightarrow>\n                H_k k \\<in> carrier_mat (2 ^ Suc k) (2 ^ Suc k);\n        Suc k < n\\<rbrakk>\n       \\<Longrightarrow> H_k (Suc k)\n                         \\<in> carrier_mat (2 ^ Suc (Suc k))\n                                (2 ^ Suc (Suc k))", "have \"dim_row (H_k (Suc k)) = 2^(Suc (Suc k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_row (H_k (Suc k)) = 2 ^ Suc (Suc k)", "using st.ptensor_mat_dim_row"], ["proof (prove)\nusing this:\n  dim_row (st.ptensor_mat ?m1.0 ?m2.0) = st.d0\n\ngoal (1 subgoal):\n 1. dim_row (H_k (Suc k)) = 2 ^ Suc (Suc k)", "unfolding st.d0_def st.dims0_def st.vars0_def"], ["proof (prove)\nusing this:\n  dim_row (st.ptensor_mat ?m1.0 ?m2.0) =\n  prod_list (nths dims ({0..<Suc k} \\<union> {Suc k}))\n\ngoal (1 subgoal):\n 1. dim_row (H_k (Suc k)) = 2 ^ Suc (Suc k)", "using plssk"], ["proof (prove)\nusing this:\n  dim_row (st.ptensor_mat ?m1.0 ?m2.0) =\n  prod_list (nths dims ({0..<Suc k} \\<union> {Suc k}))\n  prod_list (nths dims ({0..<Suc k} \\<union> {Suc k})) = 2 ^ Suc (Suc k)\n\ngoal (1 subgoal):\n 1. dim_row (H_k (Suc k)) = 2 ^ Suc (Suc k)", "by auto"], ["proof (state)\nthis:\n  dim_row (H_k (Suc k)) = 2 ^ Suc (Suc k)\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < n \\<Longrightarrow>\n                H_k k \\<in> carrier_mat (2 ^ Suc k) (2 ^ Suc k);\n        Suc k < n\\<rbrakk>\n       \\<Longrightarrow> H_k (Suc k)\n                         \\<in> carrier_mat (2 ^ Suc (Suc k))\n                                (2 ^ Suc (Suc k))", "ultimately"], ["proof (chain)\npicking this:\n  dim_col (H_k (Suc k)) = 2 ^ Suc (Suc k)\n  dim_row (H_k (Suc k)) = 2 ^ Suc (Suc k)", "show ?case"], ["proof (prove)\nusing this:\n  dim_col (H_k (Suc k)) = 2 ^ Suc (Suc k)\n  dim_row (H_k (Suc k)) = 2 ^ Suc (Suc k)\n\ngoal (1 subgoal):\n 1. H_k (Suc k) \\<in> carrier_mat (2 ^ Suc (Suc k)) (2 ^ Suc (Suc k))", "by auto"], ["proof (state)\nthis:\n  H_k (Suc k) \\<in> carrier_mat (2 ^ Suc (Suc k)) (2 ^ Suc (Suc k))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma exH_k_eq_H_k:\n  \"k < n \\<Longrightarrow> exH_k k = pmat_extension dims {0..<(Suc k)} {(Suc k)..<n} (H_k k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k < n \\<Longrightarrow>\n    exH_k k =\n    partial_state2.pmat_extension dims {0..<Suc k} {Suc k..<n} (H_k k)", "proof(induct k)"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 < n \\<Longrightarrow>\n    exH_k 0 =\n    partial_state2.pmat_extension dims {0..<Suc 0} {Suc 0..<n} (H_k 0)\n 2. \\<And>k.\n       \\<lbrakk>k < n \\<Longrightarrow>\n                exH_k k =\n                partial_state2.pmat_extension dims {0..<Suc k} {Suc k..<n}\n                 (H_k k);\n        Suc k < n\\<rbrakk>\n       \\<Longrightarrow> exH_k (Suc k) =\n                         partial_state2.pmat_extension dims\n                          {0..<Suc (Suc k)} {Suc (Suc k)..<n} (H_k (Suc k))", "case 0"], ["proof (state)\nthis:\n  0 < n\n\ngoal (2 subgoals):\n 1. 0 < n \\<Longrightarrow>\n    exH_k 0 =\n    partial_state2.pmat_extension dims {0..<Suc 0} {Suc 0..<n} (H_k 0)\n 2. \\<And>k.\n       \\<lbrakk>k < n \\<Longrightarrow>\n                exH_k k =\n                partial_state2.pmat_extension dims {0..<Suc k} {Suc k..<n}\n                 (H_k k);\n        Suc k < n\\<rbrakk>\n       \\<Longrightarrow> exH_k (Suc k) =\n                         partial_state2.pmat_extension dims\n                          {0..<Suc (Suc k)} {Suc (Suc k)..<n} (H_k (Suc k))", "have \"{(Suc 0)..<n} = vars1 - {0..<(Suc 0)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {Suc 0..<n} = vars1 - {0..<Suc 0}", "using vars1_def"], ["proof (prove)\nusing this:\n  vars1 = {0..<n}\n\ngoal (1 subgoal):\n 1. {Suc 0..<n} = vars1 - {0..<Suc 0}", "by fastforce"], ["proof (state)\nthis:\n  {Suc 0..<n} = vars1 - {0..<Suc 0}\n\ngoal (2 subgoals):\n 1. 0 < n \\<Longrightarrow>\n    exH_k 0 =\n    partial_state2.pmat_extension dims {0..<Suc 0} {Suc 0..<n} (H_k 0)\n 2. \\<And>k.\n       \\<lbrakk>k < n \\<Longrightarrow>\n                exH_k k =\n                partial_state2.pmat_extension dims {0..<Suc k} {Suc k..<n}\n                 (H_k k);\n        Suc k < n\\<rbrakk>\n       \\<Longrightarrow> exH_k (Suc k) =\n                         partial_state2.pmat_extension dims\n                          {0..<Suc (Suc k)} {Suc (Suc k)..<n} (H_k (Suc k))", "then"], ["proof (chain)\npicking this:\n  {Suc 0..<n} = vars1 - {0..<Suc 0}", "show ?case"], ["proof (prove)\nusing this:\n  {Suc 0..<n} = vars1 - {0..<Suc 0}\n\ngoal (1 subgoal):\n 1. exH_k 0 =\n    partial_state2.pmat_extension dims {0..<Suc 0} {Suc 0..<n} (H_k 0)", "unfolding exH_k.simps"], ["proof (prove)\nusing this:\n  {Suc 0..<n} = vars1 - {0..<Suc 0}\n\ngoal (1 subgoal):\n 1. hadamard_on_i 0 =\n    partial_state2.pmat_extension dims {0..<Suc 0} {Suc 0..<n} (H_k 0)", "using vars1_def"], ["proof (prove)\nusing this:\n  {Suc 0..<n} = vars1 - {0..<Suc 0}\n  vars1 = {0..<n}\n\ngoal (1 subgoal):\n 1. hadamard_on_i 0 =\n    partial_state2.pmat_extension dims {0..<Suc 0} {Suc 0..<n} (H_k 0)", "by auto"], ["proof (state)\nthis:\n  exH_k 0 =\n  partial_state2.pmat_extension dims {0..<Suc 0} {Suc 0..<n} (H_k 0)\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < n \\<Longrightarrow>\n                exH_k k =\n                partial_state2.pmat_extension dims {0..<Suc k} {Suc k..<n}\n                 (H_k k);\n        Suc k < n\\<rbrakk>\n       \\<Longrightarrow> exH_k (Suc k) =\n                         partial_state2.pmat_extension dims\n                          {0..<Suc (Suc k)} {Suc (Suc k)..<n} (H_k (Suc k))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < n \\<Longrightarrow>\n                exH_k k =\n                partial_state2.pmat_extension dims {0..<Suc k} {Suc k..<n}\n                 (H_k k);\n        Suc k < n\\<rbrakk>\n       \\<Longrightarrow> exH_k (Suc k) =\n                         partial_state2.pmat_extension dims\n                          {0..<Suc (Suc k)} {Suc (Suc k)..<n} (H_k (Suc k))", "case (Suc k)"], ["proof (state)\nthis:\n  k < n \\<Longrightarrow>\n  exH_k k =\n  partial_state2.pmat_extension dims {0..<Suc k} {Suc k..<n} (H_k k)\n  Suc k < n\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < n \\<Longrightarrow>\n                exH_k k =\n                partial_state2.pmat_extension dims {0..<Suc k} {Suc k..<n}\n                 (H_k k);\n        Suc k < n\\<rbrakk>\n       \\<Longrightarrow> exH_k (Suc k) =\n                         partial_state2.pmat_extension dims\n                          {0..<Suc (Suc k)} {Suc (Suc k)..<n} (H_k (Suc k))", "interpret st: partial_state2 dims \"{0..<Suc k}\" \"{(Suc k)..<n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. partial_state2 {0..<Suc k} {Suc k..<n}", "apply unfold_locales"], ["proof (prove)\ngoal (1 subgoal):\n 1. {0..<Suc k} \\<inter> {Suc k..<n} = {}", "by auto"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < n \\<Longrightarrow>\n                exH_k k =\n                partial_state2.pmat_extension dims {0..<Suc k} {Suc k..<n}\n                 (H_k k);\n        Suc k < n\\<rbrakk>\n       \\<Longrightarrow> exH_k (Suc k) =\n                         partial_state2.pmat_extension dims\n                          {0..<Suc (Suc k)} {Suc (Suc k)..<n} (H_k (Suc k))", "interpret st1: partial_state2 dims \"{Suc k}\" \"{(Suc (Suc k))..<n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. partial_state2 {Suc k} {Suc (Suc k)..<n}", "apply unfold_locales"], ["proof (prove)\ngoal (1 subgoal):\n 1. {Suc k} \\<inter> {Suc (Suc k)..<n} = {}", "by auto"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < n \\<Longrightarrow>\n                exH_k k =\n                partial_state2.pmat_extension dims {0..<Suc k} {Suc k..<n}\n                 (H_k k);\n        Suc k < n\\<rbrakk>\n       \\<Longrightarrow> exH_k (Suc k) =\n                         partial_state2.pmat_extension dims\n                          {0..<Suc (Suc k)} {Suc (Suc k)..<n} (H_k (Suc k))", "interpret st2: partial_state2 dims \"{Suc k}\" \"vars1 - {Suc k}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. partial_state2 {Suc k} (vars1 - {Suc k})", "apply unfold_locales"], ["proof (prove)\ngoal (1 subgoal):\n 1. {Suc k} \\<inter> (vars1 - {Suc k}) = {}", "by auto"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < n \\<Longrightarrow>\n                exH_k k =\n                partial_state2.pmat_extension dims {0..<Suc k} {Suc k..<n}\n                 (H_k k);\n        Suc k < n\\<rbrakk>\n       \\<Longrightarrow> exH_k (Suc k) =\n                         partial_state2.pmat_extension dims\n                          {0..<Suc (Suc k)} {Suc (Suc k)..<n} (H_k (Suc k))", "interpret st3: partial_state2 dims \"{0..<Suc k}\" \"{Suc (Suc k)..<n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. partial_state2 {0..<Suc k} {Suc (Suc k)..<n}", "apply unfold_locales"], ["proof (prove)\ngoal (1 subgoal):\n 1. {0..<Suc k} \\<inter> {Suc (Suc k)..<n} = {}", "by auto"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < n \\<Longrightarrow>\n                exH_k k =\n                partial_state2.pmat_extension dims {0..<Suc k} {Suc k..<n}\n                 (H_k k);\n        Suc k < n\\<rbrakk>\n       \\<Longrightarrow> exH_k (Suc k) =\n                         partial_state2.pmat_extension dims\n                          {0..<Suc (Suc k)} {Suc (Suc k)..<n} (H_k (Suc k))", "interpret st4: partial_state2 dims \"{0..<Suc (Suc k)}\" \"{Suc (Suc k)..<n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. partial_state2 {0..<Suc (Suc k)} {Suc (Suc k)..<n}", "apply unfold_locales"], ["proof (prove)\ngoal (1 subgoal):\n 1. {0..<Suc (Suc k)} \\<inter> {Suc (Suc k)..<n} = {}", "by auto"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < n \\<Longrightarrow>\n                exH_k k =\n                partial_state2.pmat_extension dims {0..<Suc k} {Suc k..<n}\n                 (H_k k);\n        Suc k < n\\<rbrakk>\n       \\<Longrightarrow> exH_k (Suc k) =\n                         partial_state2.pmat_extension dims\n                          {0..<Suc (Suc k)} {Suc (Suc k)..<n} (H_k (Suc k))", "from Suc"], ["proof (chain)\npicking this:\n  k < n \\<Longrightarrow> exH_k k = st.pmat_extension (H_k k)\n  Suc k < n", "have eq0: \"exH_k (Suc k) \n    = (st.pmat_extension (H_k k)) * (st2.pmat_extension hadamard)\""], ["proof (prove)\nusing this:\n  k < n \\<Longrightarrow> exH_k k = st.pmat_extension (H_k k)\n  Suc k < n\n\ngoal (1 subgoal):\n 1. exH_k (Suc k) = st.pmat_extension (H_k k) * st2.pmat_extension hadamard", "by auto"], ["proof (state)\nthis:\n  exH_k (Suc k) = st.pmat_extension (H_k k) * st2.pmat_extension hadamard\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < n \\<Longrightarrow>\n                exH_k k =\n                partial_state2.pmat_extension dims {0..<Suc k} {Suc k..<n}\n                 (H_k k);\n        Suc k < n\\<rbrakk>\n       \\<Longrightarrow> exH_k (Suc k) =\n                         partial_state2.pmat_extension dims\n                          {0..<Suc (Suc k)} {Suc (Suc k)..<n} (H_k (Suc k))", "have \"vars1 - {0..<Suc k} = {(Suc k)..<n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vars1 - {0..<Suc k} = {Suc k..<n}", "using vars1_def"], ["proof (prove)\nusing this:\n  vars1 = {0..<n}\n\ngoal (1 subgoal):\n 1. vars1 - {0..<Suc k} = {Suc k..<n}", "by auto"], ["proof (state)\nthis:\n  vars1 - {0..<Suc k} = {Suc k..<n}\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < n \\<Longrightarrow>\n                exH_k k =\n                partial_state2.pmat_extension dims {0..<Suc k} {Suc k..<n}\n                 (H_k k);\n        Suc k < n\\<rbrakk>\n       \\<Longrightarrow> exH_k (Suc k) =\n                         partial_state2.pmat_extension dims\n                          {0..<Suc (Suc k)} {Suc (Suc k)..<n} (H_k (Suc k))", "then"], ["proof (chain)\npicking this:\n  vars1 - {0..<Suc k} = {Suc k..<n}", "have eql1: \"st.pmat_extension (H_k k) = st.ptensor_mat (H_k k) (1\\<^sub>m st.d2)\""], ["proof (prove)\nusing this:\n  vars1 - {0..<Suc k} = {Suc k..<n}\n\ngoal (1 subgoal):\n 1. st.pmat_extension (H_k k) = st.ptensor_mat (H_k k) (1\\<^sub>m st.d2)", "using st.pmat_extension_def"], ["proof (prove)\nusing this:\n  vars1 - {0..<Suc k} = {Suc k..<n}\n  st.pmat_extension ?m = st.ptensor_mat ?m (1\\<^sub>m st.d2)\n\ngoal (1 subgoal):\n 1. st.pmat_extension (H_k k) = st.ptensor_mat (H_k k) (1\\<^sub>m st.d2)", "by auto"], ["proof (state)\nthis:\n  st.pmat_extension (H_k k) = st.ptensor_mat (H_k k) (1\\<^sub>m st.d2)\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < n \\<Longrightarrow>\n                exH_k k =\n                partial_state2.pmat_extension dims {0..<Suc k} {Suc k..<n}\n                 (H_k k);\n        Suc k < n\\<rbrakk>\n       \\<Longrightarrow> exH_k (Suc k) =\n                         partial_state2.pmat_extension dims\n                          {0..<Suc (Suc k)} {Suc (Suc k)..<n} (H_k (Suc k))", "from dims_nths_one_lt_n[OF Suc(2)]"], ["proof (chain)\npicking this:\n  nths dims {Suc k} = [2]", "have st1d1: \"st1.d1 = 2\""], ["proof (prove)\nusing this:\n  nths dims {Suc k} = [2]\n\ngoal (1 subgoal):\n 1. st2.d1 = 2", "unfolding st1.d1_def st1.dims1_def"], ["proof (prove)\nusing this:\n  nths dims {Suc k} = [2]\n\ngoal (1 subgoal):\n 1. prod_list (nths dims {Suc k}) = 2", "by fastforce"], ["proof (state)\nthis:\n  st2.d1 = 2\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < n \\<Longrightarrow>\n                exH_k k =\n                partial_state2.pmat_extension dims {0..<Suc k} {Suc k..<n}\n                 (H_k k);\n        Suc k < n\\<rbrakk>\n       \\<Longrightarrow> exH_k (Suc k) =\n                         partial_state2.pmat_extension dims\n                          {0..<Suc (Suc k)} {Suc (Suc k)..<n} (H_k (Suc k))", "have \"{Suc k} \\<union> {Suc (Suc k)..<n} = {Suc k..<n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {Suc k} \\<union> {Suc (Suc k)..<n} = {Suc k..<n}", "using Suc"], ["proof (prove)\nusing this:\n  k < n \\<Longrightarrow> exH_k k = st.pmat_extension (H_k k)\n  Suc k < n\n\ngoal (1 subgoal):\n 1. {Suc k} \\<union> {Suc (Suc k)..<n} = {Suc k..<n}", "by auto"], ["proof (state)\nthis:\n  {Suc k} \\<union> {Suc (Suc k)..<n} = {Suc k..<n}\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < n \\<Longrightarrow>\n                exH_k k =\n                partial_state2.pmat_extension dims {0..<Suc k} {Suc k..<n}\n                 (H_k k);\n        Suc k < n\\<rbrakk>\n       \\<Longrightarrow> exH_k (Suc k) =\n                         partial_state2.pmat_extension dims\n                          {0..<Suc (Suc k)} {Suc (Suc k)..<n} (H_k (Suc k))", "then"], ["proof (chain)\npicking this:\n  {Suc k} \\<union> {Suc (Suc k)..<n} = {Suc k..<n}", "have \"st1.d0 = st.d2\""], ["proof (prove)\nusing this:\n  {Suc k} \\<union> {Suc (Suc k)..<n} = {Suc k..<n}\n\ngoal (1 subgoal):\n 1. st1.d0 = st.d2", "unfolding st1.d0_def st1.dims0_def st1.vars0_def st.d2_def st.dims2_def"], ["proof (prove)\nusing this:\n  {Suc k} \\<union> {Suc (Suc k)..<n} = {Suc k..<n}\n\ngoal (1 subgoal):\n 1. prod_list (nths dims ({Suc k} \\<union> {Suc (Suc k)..<n})) =\n    prod_list (nths dims {Suc k..<n})", "by fastforce"], ["proof (state)\nthis:\n  st1.d0 = st.d2\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < n \\<Longrightarrow>\n                exH_k k =\n                partial_state2.pmat_extension dims {0..<Suc k} {Suc k..<n}\n                 (H_k k);\n        Suc k < n\\<rbrakk>\n       \\<Longrightarrow> exH_k (Suc k) =\n                         partial_state2.pmat_extension dims\n                          {0..<Suc (Suc k)} {Suc (Suc k)..<n} (H_k (Suc k))", "then"], ["proof (chain)\npicking this:\n  st1.d0 = st.d2", "have eql2: \"st1.ptensor_mat (1\\<^sub>m 2) (1\\<^sub>m st1.d2) = 1\\<^sub>m st.d2\""], ["proof (prove)\nusing this:\n  st1.d0 = st.d2\n\ngoal (1 subgoal):\n 1. st1.ptensor_mat (1\\<^sub>m 2) (1\\<^sub>m st4.d2) = 1\\<^sub>m st.d2", "using st1.ptensor_mat_id st1d1"], ["proof (prove)\nusing this:\n  st1.d0 = st.d2\n  st1.ptensor_mat (1\\<^sub>m st2.d1) (1\\<^sub>m st4.d2) = 1\\<^sub>m st1.d0\n  st2.d1 = 2\n\ngoal (1 subgoal):\n 1. st1.ptensor_mat (1\\<^sub>m 2) (1\\<^sub>m st4.d2) = 1\\<^sub>m st.d2", "by auto"], ["proof (state)\nthis:\n  st1.ptensor_mat (1\\<^sub>m 2) (1\\<^sub>m st4.d2) = 1\\<^sub>m st.d2\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < n \\<Longrightarrow>\n                exH_k k =\n                partial_state2.pmat_extension dims {0..<Suc k} {Suc k..<n}\n                 (H_k k);\n        Suc k < n\\<rbrakk>\n       \\<Longrightarrow> exH_k (Suc k) =\n                         partial_state2.pmat_extension dims\n                          {0..<Suc (Suc k)} {Suc (Suc k)..<n} (H_k (Suc k))", "have eql3: \"st.ptensor_mat (H_k k) (1\\<^sub>m st.d2) = st.ptensor_mat (H_k k) (st1.ptensor_mat (1\\<^sub>m 2) (1\\<^sub>m st1.d2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. st.ptensor_mat (H_k k) (1\\<^sub>m st.d2) =\n    st.ptensor_mat (H_k k)\n     (st1.ptensor_mat (1\\<^sub>m 2) (1\\<^sub>m st4.d2))", "apply (subst eql2[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. st.ptensor_mat (H_k k)\n     (st1.ptensor_mat (1\\<^sub>m 2) (1\\<^sub>m st4.d2)) =\n    st.ptensor_mat (H_k k)\n     (st1.ptensor_mat (1\\<^sub>m 2) (1\\<^sub>m st4.d2))", "by auto"], ["proof (state)\nthis:\n  st.ptensor_mat (H_k k) (1\\<^sub>m st.d2) =\n  st.ptensor_mat (H_k k) (st1.ptensor_mat (1\\<^sub>m 2) (1\\<^sub>m st4.d2))\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < n \\<Longrightarrow>\n                exH_k k =\n                partial_state2.pmat_extension dims {0..<Suc k} {Suc k..<n}\n                 (H_k k);\n        Suc k < n\\<rbrakk>\n       \\<Longrightarrow> exH_k (Suc k) =\n                         partial_state2.pmat_extension dims\n                          {0..<Suc (Suc k)} {Suc (Suc k)..<n} (H_k (Suc k))", "have eqr1: \"(st2.pmat_extension hadamard) = st2.ptensor_mat hadamard (1\\<^sub>m st2.d2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. st2.pmat_extension hadamard =\n    st2.ptensor_mat hadamard (1\\<^sub>m st2.d2)", "using st2.pmat_extension_def"], ["proof (prove)\nusing this:\n  st2.pmat_extension ?m = st2.ptensor_mat ?m (1\\<^sub>m st2.d2)\n\ngoal (1 subgoal):\n 1. st2.pmat_extension hadamard =\n    st2.ptensor_mat hadamard (1\\<^sub>m st2.d2)", "by auto"], ["proof (state)\nthis:\n  st2.pmat_extension hadamard = st2.ptensor_mat hadamard (1\\<^sub>m st2.d2)\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < n \\<Longrightarrow>\n                exH_k k =\n                partial_state2.pmat_extension dims {0..<Suc k} {Suc k..<n}\n                 (H_k k);\n        Suc k < n\\<rbrakk>\n       \\<Longrightarrow> exH_k (Suc k) =\n                         partial_state2.pmat_extension dims\n                          {0..<Suc (Suc k)} {Suc (Suc k)..<n} (H_k (Suc k))", "have splitset: \"{0..<Suc k} \\<union> {Suc (Suc k)..<n} = vars1 - {Suc k}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {0..<Suc k} \\<union> {Suc (Suc k)..<n} = vars1 - {Suc k}", "unfolding vars1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {0..<Suc k} \\<union> {Suc (Suc k)..<n} = {0..<n} - {Suc k}", "using Suc(2)"], ["proof (prove)\nusing this:\n  Suc k < n\n\ngoal (1 subgoal):\n 1. {0..<Suc k} \\<union> {Suc (Suc k)..<n} = {0..<n} - {Suc k}", "by auto"], ["proof (state)\nthis:\n  {0..<Suc k} \\<union> {Suc (Suc k)..<n} = vars1 - {Suc k}\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < n \\<Longrightarrow>\n                exH_k k =\n                partial_state2.pmat_extension dims {0..<Suc k} {Suc k..<n}\n                 (H_k k);\n        Suc k < n\\<rbrakk>\n       \\<Longrightarrow> exH_k (Suc k) =\n                         partial_state2.pmat_extension dims\n                          {0..<Suc (Suc k)} {Suc (Suc k)..<n} (H_k (Suc k))", "have Sksplit: \"{Suc k} \\<union> {Suc (Suc k)..<n} = {Suc k..<n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {Suc k} \\<union> {Suc (Suc k)..<n} = {Suc k..<n}", "using Suc(2)"], ["proof (prove)\nusing this:\n  Suc k < n\n\ngoal (1 subgoal):\n 1. {Suc k} \\<union> {Suc (Suc k)..<n} = {Suc k..<n}", "by auto"], ["proof (state)\nthis:\n  {Suc k} \\<union> {Suc (Suc k)..<n} = {Suc k..<n}\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < n \\<Longrightarrow>\n                exH_k k =\n                partial_state2.pmat_extension dims {0..<Suc k} {Suc k..<n}\n                 (H_k k);\n        Suc k < n\\<rbrakk>\n       \\<Longrightarrow> exH_k (Suc k) =\n                         partial_state2.pmat_extension dims\n                          {0..<Suc (Suc k)} {Suc (Suc k)..<n} (H_k (Suc k))", "have Sksplit1: \"{0..<Suc k}\\<union>{Suc k} = {0..<Suc (Suc k)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {0..<Suc k} \\<union> {Suc k} = {0..<Suc (Suc k)}", "by auto"], ["proof (state)\nthis:\n  {0..<Suc k} \\<union> {Suc k} = {0..<Suc (Suc k)}\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < n \\<Longrightarrow>\n                exH_k k =\n                partial_state2.pmat_extension dims {0..<Suc k} {Suc k..<n}\n                 (H_k k);\n        Suc k < n\\<rbrakk>\n       \\<Longrightarrow> exH_k (Suc k) =\n                         partial_state2.pmat_extension dims\n                          {0..<Suc (Suc k)} {Suc (Suc k)..<n} (H_k (Suc k))", "have \"st.ptensor_mat (H_k k) (st1.ptensor_mat (1\\<^sub>m 2) (1\\<^sub>m st1.d2)) \n    = ptensor_mat dims ({0..<Suc k}\\<union>{Suc k}) {Suc (Suc k)..<n} (ptensor_mat dims {0..<Suc k} {Suc k} (H_k k) (1\\<^sub>m 2)) (1\\<^sub>m st1.d2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. st.ptensor_mat (H_k k)\n     (st1.ptensor_mat (1\\<^sub>m 2) (1\\<^sub>m st4.d2)) =\n    partial_state2.ptensor_mat dims ({0..<Suc k} \\<union> {Suc k})\n     {Suc (Suc k)..<n}\n     (partial_state2.ptensor_mat dims {0..<Suc k} {Suc k} (H_k k)\n       (1\\<^sub>m 2))\n     (1\\<^sub>m st4.d2)", "apply (subst ptensor_mat_assoc[symmetric, of \"{0..<Suc k}\" \"{Suc k}\" \"{Suc (Suc k)..<n}\" \"H_k k\" \"1\\<^sub>m 2\" \"1\\<^sub>m st1.d2\", simplified Sksplit])"], ["proof (prove)\ngoal (4 subgoals):\n 1. {0..<Suc k} \\<inter> {Suc k} = {}\n 2. ({0..<Suc k} \\<union> {Suc k}) \\<inter> {Suc (Suc k)..<n} = {}\n 3. {0..<Suc k} \\<union> {Suc k} \\<union> {Suc (Suc k)..<n}\n    \\<subseteq> {0..<length dims}\n 4. partial_state2.ptensor_mat dims ({0..<Suc k} \\<union> {Suc k})\n     {Suc (Suc k)..<n}\n     (partial_state2.ptensor_mat dims {0..<Suc k} {Suc k} (H_k k)\n       (1\\<^sub>m 2))\n     (1\\<^sub>m st4.d2) =\n    partial_state2.ptensor_mat dims ({0..<Suc k} \\<union> {Suc k})\n     {Suc (Suc k)..<n}\n     (partial_state2.ptensor_mat dims {0..<Suc k} {Suc k} (H_k k)\n       (1\\<^sub>m 2))\n     (1\\<^sub>m st4.d2)", "using Suc length_dims"], ["proof (prove)\nusing this:\n  k < n \\<Longrightarrow> exH_k k = st.pmat_extension (H_k k)\n  Suc k < n\n  length dims = n + 1\n\ngoal (4 subgoals):\n 1. {0..<Suc k} \\<inter> {Suc k} = {}\n 2. ({0..<Suc k} \\<union> {Suc k}) \\<inter> {Suc (Suc k)..<n} = {}\n 3. {0..<Suc k} \\<union> {Suc k} \\<union> {Suc (Suc k)..<n}\n    \\<subseteq> {0..<length dims}\n 4. partial_state2.ptensor_mat dims ({0..<Suc k} \\<union> {Suc k})\n     {Suc (Suc k)..<n}\n     (partial_state2.ptensor_mat dims {0..<Suc k} {Suc k} (H_k k)\n       (1\\<^sub>m 2))\n     (1\\<^sub>m st4.d2) =\n    partial_state2.ptensor_mat dims ({0..<Suc k} \\<union> {Suc k})\n     {Suc (Suc k)..<n}\n     (partial_state2.ptensor_mat dims {0..<Suc k} {Suc k} (H_k k)\n       (1\\<^sub>m 2))\n     (1\\<^sub>m st4.d2)", "by auto"], ["proof (state)\nthis:\n  st.ptensor_mat (H_k k)\n   (st1.ptensor_mat (1\\<^sub>m 2) (1\\<^sub>m st4.d2)) =\n  partial_state2.ptensor_mat dims ({0..<Suc k} \\<union> {Suc k})\n   {Suc (Suc k)..<n}\n   (partial_state2.ptensor_mat dims {0..<Suc k} {Suc k} (H_k k)\n     (1\\<^sub>m 2))\n   (1\\<^sub>m st4.d2)\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < n \\<Longrightarrow>\n                exH_k k =\n                partial_state2.pmat_extension dims {0..<Suc k} {Suc k..<n}\n                 (H_k k);\n        Suc k < n\\<rbrakk>\n       \\<Longrightarrow> exH_k (Suc k) =\n                         partial_state2.pmat_extension dims\n                          {0..<Suc (Suc k)} {Suc (Suc k)..<n} (H_k (Suc k))", "also"], ["proof (state)\nthis:\n  st.ptensor_mat (H_k k)\n   (st1.ptensor_mat (1\\<^sub>m 2) (1\\<^sub>m st4.d2)) =\n  partial_state2.ptensor_mat dims ({0..<Suc k} \\<union> {Suc k})\n   {Suc (Suc k)..<n}\n   (partial_state2.ptensor_mat dims {0..<Suc k} {Suc k} (H_k k)\n     (1\\<^sub>m 2))\n   (1\\<^sub>m st4.d2)\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < n \\<Longrightarrow>\n                exH_k k =\n                partial_state2.pmat_extension dims {0..<Suc k} {Suc k..<n}\n                 (H_k k);\n        Suc k < n\\<rbrakk>\n       \\<Longrightarrow> exH_k (Suc k) =\n                         partial_state2.pmat_extension dims\n                          {0..<Suc (Suc k)} {Suc (Suc k)..<n} (H_k (Suc k))", "have \"\\<dots> = ptensor_mat dims ({0..<Suc k}\\<union>{Suc k}) {Suc (Suc k)..<n} (ptensor_mat dims {Suc k} {0..<Suc k} (1\\<^sub>m 2) (H_k k)) (1\\<^sub>m st1.d2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. partial_state2.ptensor_mat dims ({0..<Suc k} \\<union> {Suc k})\n     {Suc (Suc k)..<n}\n     (partial_state2.ptensor_mat dims {0..<Suc k} {Suc k} (H_k k)\n       (1\\<^sub>m 2))\n     (1\\<^sub>m st4.d2) =\n    partial_state2.ptensor_mat dims ({0..<Suc k} \\<union> {Suc k})\n     {Suc (Suc k)..<n}\n     (partial_state2.ptensor_mat dims {Suc k} {0..<Suc k} (1\\<^sub>m 2)\n       (H_k k))\n     (1\\<^sub>m st4.d2)", "using ptensor_mat_comm[of \"{0..<Suc k}\" \"{Suc k}\"]"], ["proof (prove)\nusing this:\n  {0..<Suc k} \\<inter> {Suc k} = {} \\<Longrightarrow>\n  partial_state2.ptensor_mat dims {0..<Suc k} {Suc k} ?m1.0 ?m2.0 =\n  partial_state2.ptensor_mat dims {Suc k} {0..<Suc k} ?m2.0 ?m1.0\n\ngoal (1 subgoal):\n 1. partial_state2.ptensor_mat dims ({0..<Suc k} \\<union> {Suc k})\n     {Suc (Suc k)..<n}\n     (partial_state2.ptensor_mat dims {0..<Suc k} {Suc k} (H_k k)\n       (1\\<^sub>m 2))\n     (1\\<^sub>m st4.d2) =\n    partial_state2.ptensor_mat dims ({0..<Suc k} \\<union> {Suc k})\n     {Suc (Suc k)..<n}\n     (partial_state2.ptensor_mat dims {Suc k} {0..<Suc k} (1\\<^sub>m 2)\n       (H_k k))\n     (1\\<^sub>m st4.d2)", "by auto"], ["proof (state)\nthis:\n  partial_state2.ptensor_mat dims ({0..<Suc k} \\<union> {Suc k})\n   {Suc (Suc k)..<n}\n   (partial_state2.ptensor_mat dims {0..<Suc k} {Suc k} (H_k k)\n     (1\\<^sub>m 2))\n   (1\\<^sub>m st4.d2) =\n  partial_state2.ptensor_mat dims ({0..<Suc k} \\<union> {Suc k})\n   {Suc (Suc k)..<n}\n   (partial_state2.ptensor_mat dims {Suc k} {0..<Suc k} (1\\<^sub>m 2)\n     (H_k k))\n   (1\\<^sub>m st4.d2)\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < n \\<Longrightarrow>\n                exH_k k =\n                partial_state2.pmat_extension dims {0..<Suc k} {Suc k..<n}\n                 (H_k k);\n        Suc k < n\\<rbrakk>\n       \\<Longrightarrow> exH_k (Suc k) =\n                         partial_state2.pmat_extension dims\n                          {0..<Suc (Suc k)} {Suc (Suc k)..<n} (H_k (Suc k))", "also"], ["proof (state)\nthis:\n  partial_state2.ptensor_mat dims ({0..<Suc k} \\<union> {Suc k})\n   {Suc (Suc k)..<n}\n   (partial_state2.ptensor_mat dims {0..<Suc k} {Suc k} (H_k k)\n     (1\\<^sub>m 2))\n   (1\\<^sub>m st4.d2) =\n  partial_state2.ptensor_mat dims ({0..<Suc k} \\<union> {Suc k})\n   {Suc (Suc k)..<n}\n   (partial_state2.ptensor_mat dims {Suc k} {0..<Suc k} (1\\<^sub>m 2)\n     (H_k k))\n   (1\\<^sub>m st4.d2)\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < n \\<Longrightarrow>\n                exH_k k =\n                partial_state2.pmat_extension dims {0..<Suc k} {Suc k..<n}\n                 (H_k k);\n        Suc k < n\\<rbrakk>\n       \\<Longrightarrow> exH_k (Suc k) =\n                         partial_state2.pmat_extension dims\n                          {0..<Suc (Suc k)} {Suc (Suc k)..<n} (H_k (Suc k))", "have \"\\<dots> = ptensor_mat dims {Suc k} ({0..<Suc k} \\<union> {Suc (Suc k)..<n})\n                  (1\\<^sub>m 2) \n                  (ptensor_mat dims {0..<Suc k} {Suc (Suc k)..<n} (H_k k) (1\\<^sub>m st1.d2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. partial_state2.ptensor_mat dims ({0..<Suc k} \\<union> {Suc k})\n     {Suc (Suc k)..<n}\n     (partial_state2.ptensor_mat dims {Suc k} {0..<Suc k} (1\\<^sub>m 2)\n       (H_k k))\n     (1\\<^sub>m st4.d2) =\n    partial_state2.ptensor_mat dims {Suc k}\n     ({0..<Suc k} \\<union> {Suc (Suc k)..<n}) (1\\<^sub>m 2)\n     (st3.ptensor_mat (H_k k) (1\\<^sub>m st4.d2))", "apply (subst sup_commute)"], ["proof (prove)\ngoal (1 subgoal):\n 1. partial_state2.ptensor_mat dims ({Suc k} \\<union> {0..<Suc k})\n     {Suc (Suc k)..<n}\n     (partial_state2.ptensor_mat dims {Suc k} {0..<Suc k} (1\\<^sub>m 2)\n       (H_k k))\n     (1\\<^sub>m st4.d2) =\n    partial_state2.ptensor_mat dims {Suc k}\n     ({0..<Suc k} \\<union> {Suc (Suc k)..<n}) (1\\<^sub>m 2)\n     (st3.ptensor_mat (H_k k) (1\\<^sub>m st4.d2))", "apply (subst ptensor_mat_assoc[of \"{Suc k}\" \"{0..<Suc k}\" \"{Suc (Suc k)..<n}\" \"(1\\<^sub>m 2)\" \"H_k k\" \"1\\<^sub>m st1.d2\"])"], ["proof (prove)\ngoal (4 subgoals):\n 1. {Suc k} \\<inter> {0..<Suc k} = {}\n 2. ({Suc k} \\<union> {0..<Suc k}) \\<inter> {Suc (Suc k)..<n} = {}\n 3. {Suc k} \\<union> {0..<Suc k} \\<union> {Suc (Suc k)..<n}\n    \\<subseteq> {0..<length dims}\n 4. partial_state2.ptensor_mat dims {Suc k}\n     ({0..<Suc k} \\<union> {Suc (Suc k)..<n}) (1\\<^sub>m 2)\n     (st3.ptensor_mat (H_k k) (1\\<^sub>m st4.d2)) =\n    partial_state2.ptensor_mat dims {Suc k}\n     ({0..<Suc k} \\<union> {Suc (Suc k)..<n}) (1\\<^sub>m 2)\n     (st3.ptensor_mat (H_k k) (1\\<^sub>m st4.d2))", "using Suc length_dims"], ["proof (prove)\nusing this:\n  k < n \\<Longrightarrow> exH_k k = st.pmat_extension (H_k k)\n  Suc k < n\n  length dims = n + 1\n\ngoal (4 subgoals):\n 1. {Suc k} \\<inter> {0..<Suc k} = {}\n 2. ({Suc k} \\<union> {0..<Suc k}) \\<inter> {Suc (Suc k)..<n} = {}\n 3. {Suc k} \\<union> {0..<Suc k} \\<union> {Suc (Suc k)..<n}\n    \\<subseteq> {0..<length dims}\n 4. partial_state2.ptensor_mat dims {Suc k}\n     ({0..<Suc k} \\<union> {Suc (Suc k)..<n}) (1\\<^sub>m 2)\n     (st3.ptensor_mat (H_k k) (1\\<^sub>m st4.d2)) =\n    partial_state2.ptensor_mat dims {Suc k}\n     ({0..<Suc k} \\<union> {Suc (Suc k)..<n}) (1\\<^sub>m 2)\n     (st3.ptensor_mat (H_k k) (1\\<^sub>m st4.d2))", "by auto"], ["proof (state)\nthis:\n  partial_state2.ptensor_mat dims ({0..<Suc k} \\<union> {Suc k})\n   {Suc (Suc k)..<n}\n   (partial_state2.ptensor_mat dims {Suc k} {0..<Suc k} (1\\<^sub>m 2)\n     (H_k k))\n   (1\\<^sub>m st4.d2) =\n  partial_state2.ptensor_mat dims {Suc k}\n   ({0..<Suc k} \\<union> {Suc (Suc k)..<n}) (1\\<^sub>m 2)\n   (st3.ptensor_mat (H_k k) (1\\<^sub>m st4.d2))\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < n \\<Longrightarrow>\n                exH_k k =\n                partial_state2.pmat_extension dims {0..<Suc k} {Suc k..<n}\n                 (H_k k);\n        Suc k < n\\<rbrakk>\n       \\<Longrightarrow> exH_k (Suc k) =\n                         partial_state2.pmat_extension dims\n                          {0..<Suc (Suc k)} {Suc (Suc k)..<n} (H_k (Suc k))", "finally"], ["proof (chain)\npicking this:\n  st.ptensor_mat (H_k k)\n   (st1.ptensor_mat (1\\<^sub>m 2) (1\\<^sub>m st4.d2)) =\n  partial_state2.ptensor_mat dims {Suc k}\n   ({0..<Suc k} \\<union> {Suc (Suc k)..<n}) (1\\<^sub>m 2)\n   (st3.ptensor_mat (H_k k) (1\\<^sub>m st4.d2))", "have eql4: \"st.pmat_extension (H_k k) \n    = st2.ptensor_mat (1\\<^sub>m 2) (st3.ptensor_mat (H_k k) (1\\<^sub>m st3.d2))\""], ["proof (prove)\nusing this:\n  st.ptensor_mat (H_k k)\n   (st1.ptensor_mat (1\\<^sub>m 2) (1\\<^sub>m st4.d2)) =\n  partial_state2.ptensor_mat dims {Suc k}\n   ({0..<Suc k} \\<union> {Suc (Suc k)..<n}) (1\\<^sub>m 2)\n   (st3.ptensor_mat (H_k k) (1\\<^sub>m st4.d2))\n\ngoal (1 subgoal):\n 1. st.pmat_extension (H_k k) =\n    st2.ptensor_mat (1\\<^sub>m 2)\n     (st3.ptensor_mat (H_k k) (1\\<^sub>m st4.d2))", "using eql1 eql3 splitset"], ["proof (prove)\nusing this:\n  st.ptensor_mat (H_k k)\n   (st1.ptensor_mat (1\\<^sub>m 2) (1\\<^sub>m st4.d2)) =\n  partial_state2.ptensor_mat dims {Suc k}\n   ({0..<Suc k} \\<union> {Suc (Suc k)..<n}) (1\\<^sub>m 2)\n   (st3.ptensor_mat (H_k k) (1\\<^sub>m st4.d2))\n  st.pmat_extension (H_k k) = st.ptensor_mat (H_k k) (1\\<^sub>m st.d2)\n  st.ptensor_mat (H_k k) (1\\<^sub>m st.d2) =\n  st.ptensor_mat (H_k k) (st1.ptensor_mat (1\\<^sub>m 2) (1\\<^sub>m st4.d2))\n  {0..<Suc k} \\<union> {Suc (Suc k)..<n} = vars1 - {Suc k}\n\ngoal (1 subgoal):\n 1. st.pmat_extension (H_k k) =\n    st2.ptensor_mat (1\\<^sub>m 2)\n     (st3.ptensor_mat (H_k k) (1\\<^sub>m st4.d2))", "by auto"], ["proof (state)\nthis:\n  st.pmat_extension (H_k k) =\n  st2.ptensor_mat (1\\<^sub>m 2) (st3.ptensor_mat (H_k k) (1\\<^sub>m st4.d2))\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < n \\<Longrightarrow>\n                exH_k k =\n                partial_state2.pmat_extension dims {0..<Suc k} {Suc k..<n}\n                 (H_k k);\n        Suc k < n\\<rbrakk>\n       \\<Longrightarrow> exH_k (Suc k) =\n                         partial_state2.pmat_extension dims\n                          {0..<Suc (Suc k)} {Suc (Suc k)..<n} (H_k (Suc k))", "have \"st2.ptensor_mat (1\\<^sub>m 2) (st3.ptensor_mat (H_k k) (1\\<^sub>m st3.d2)) * st2.ptensor_mat hadamard (1\\<^sub>m st2.d2)\n        = st2.ptensor_mat ((1\\<^sub>m 2)*hadamard) ((st3.ptensor_mat (H_k k) (1\\<^sub>m st3.d2))*(1\\<^sub>m st2.d2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. st2.ptensor_mat (1\\<^sub>m 2)\n     (st3.ptensor_mat (H_k k) (1\\<^sub>m st4.d2)) *\n    st2.ptensor_mat hadamard (1\\<^sub>m st2.d2) =\n    st2.ptensor_mat (1\\<^sub>m 2 * hadamard)\n     (st3.ptensor_mat (H_k k) (1\\<^sub>m st4.d2) * 1\\<^sub>m st2.d2)", "apply (rule st2.ptensor_mat_mult[symmetric, of \"1\\<^sub>m 2\" \"hadamard\" \"(st3.ptensor_mat (H_k k) (1\\<^sub>m st3.d2))\" \"(1\\<^sub>m st2.d2)\"])"], ["proof (prove)\ngoal (4 subgoals):\n 1. 1\\<^sub>m 2 \\<in> carrier_mat st2.d1 st2.d1\n 2. hadamard \\<in> carrier_mat st2.d1 st2.d1\n 3. st3.ptensor_mat (H_k k) (1\\<^sub>m st4.d2)\n    \\<in> carrier_mat st2.d2 st2.d2\n 4. 1\\<^sub>m st2.d2 \\<in> carrier_mat st2.d2 st2.d2", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1\\<^sub>m 2 \\<in> carrier_mat st2.d1 st2.d1", "unfolding st2.d1_def st2.dims1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1\\<^sub>m 2\n    \\<in> carrier_mat (prod_list (nths dims {Suc k}))\n           (prod_list (nths dims {Suc k}))", "by (simp add: dims_nths_one_lt_n Suc(2))"], ["proof (prove)\ngoal (3 subgoals):\n 1. hadamard \\<in> carrier_mat st2.d1 st2.d1\n 2. st3.ptensor_mat (H_k k) (1\\<^sub>m st4.d2)\n    \\<in> carrier_mat st2.d2 st2.d2\n 3. 1\\<^sub>m st2.d2 \\<in> carrier_mat st2.d2 st2.d2", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. hadamard \\<in> carrier_mat st2.d1 st2.d1", "unfolding st2.d1_def st2.dims1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. hadamard\n    \\<in> carrier_mat (prod_list (nths dims {Suc k}))\n           (prod_list (nths dims {Suc k}))", "apply (simp add: dims_nths_one_lt_n Suc(2))"], ["proof (prove)\ngoal (1 subgoal):\n 1. hadamard \\<in> carrier_mat 2 2", "using hadamard_dim"], ["proof (prove)\nusing this:\n  hadamard \\<in> carrier_mat 2 2\n\ngoal (1 subgoal):\n 1. hadamard \\<in> carrier_mat 2 2", "by auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. st3.ptensor_mat (H_k k) (1\\<^sub>m st4.d2)\n    \\<in> carrier_mat st2.d2 st2.d2\n 2. 1\\<^sub>m st2.d2 \\<in> carrier_mat st2.d2 st2.d2", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. st3.ptensor_mat (H_k k) (1\\<^sub>m st4.d2)\n    \\<in> carrier_mat st2.d2 st2.d2", "unfolding st2.d2_def[unfolded st2.dims2_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. st3.ptensor_mat (H_k k) (1\\<^sub>m st4.d2)\n    \\<in> carrier_mat (prod_list (nths dims (vars1 - {Suc k})))\n           (prod_list (nths dims (vars1 - {Suc k})))", "using st3.ptensor_mat_dim_col[unfolded st3.d0_def st3.dims0_def st3.vars0_def, simplified splitset]\n        st3.ptensor_mat_dim_row[unfolded st3.d0_def st3.dims0_def st3.vars0_def, simplified splitset]"], ["proof (prove)\nusing this:\n  dim_col (st3.ptensor_mat ?m1.0 ?m2.0) =\n  prod_list (nths dims (vars1 - {Suc k}))\n  dim_row (st3.ptensor_mat ?m1.0 ?m2.0) =\n  prod_list (nths dims (vars1 - {Suc k}))\n\ngoal (1 subgoal):\n 1. st3.ptensor_mat (H_k k) (1\\<^sub>m st4.d2)\n    \\<in> carrier_mat (prod_list (nths dims (vars1 - {Suc k})))\n           (prod_list (nths dims (vars1 - {Suc k})))", "by auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1\\<^sub>m st2.d2 \\<in> carrier_mat st2.d2 st2.d2", "by auto"], ["proof (state)\nthis:\n  st2.ptensor_mat (1\\<^sub>m 2)\n   (st3.ptensor_mat (H_k k) (1\\<^sub>m st4.d2)) *\n  st2.ptensor_mat hadamard (1\\<^sub>m st2.d2) =\n  st2.ptensor_mat (1\\<^sub>m 2 * hadamard)\n   (st3.ptensor_mat (H_k k) (1\\<^sub>m st4.d2) * 1\\<^sub>m st2.d2)\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < n \\<Longrightarrow>\n                exH_k k =\n                partial_state2.pmat_extension dims {0..<Suc k} {Suc k..<n}\n                 (H_k k);\n        Suc k < n\\<rbrakk>\n       \\<Longrightarrow> exH_k (Suc k) =\n                         partial_state2.pmat_extension dims\n                          {0..<Suc (Suc k)} {Suc (Suc k)..<n} (H_k (Suc k))", "also"], ["proof (state)\nthis:\n  st2.ptensor_mat (1\\<^sub>m 2)\n   (st3.ptensor_mat (H_k k) (1\\<^sub>m st4.d2)) *\n  st2.ptensor_mat hadamard (1\\<^sub>m st2.d2) =\n  st2.ptensor_mat (1\\<^sub>m 2 * hadamard)\n   (st3.ptensor_mat (H_k k) (1\\<^sub>m st4.d2) * 1\\<^sub>m st2.d2)\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < n \\<Longrightarrow>\n                exH_k k =\n                partial_state2.pmat_extension dims {0..<Suc k} {Suc k..<n}\n                 (H_k k);\n        Suc k < n\\<rbrakk>\n       \\<Longrightarrow> exH_k (Suc k) =\n                         partial_state2.pmat_extension dims\n                          {0..<Suc (Suc k)} {Suc (Suc k)..<n} (H_k (Suc k))", "have \"\\<dots> = st2.ptensor_mat (hadamard) (st3.ptensor_mat (H_k k) (1\\<^sub>m st3.d2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. st2.ptensor_mat (1\\<^sub>m 2 * hadamard)\n     (st3.ptensor_mat (H_k k) (1\\<^sub>m st4.d2) * 1\\<^sub>m st2.d2) =\n    st2.ptensor_mat hadamard (st3.ptensor_mat (H_k k) (1\\<^sub>m st4.d2))", "unfolding st2.d2_def[unfolded st2.dims2_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. st2.ptensor_mat (1\\<^sub>m 2 * hadamard)\n     (st3.ptensor_mat (H_k k) (1\\<^sub>m st4.d2) *\n      1\\<^sub>m (prod_list (nths dims (vars1 - {Suc k})))) =\n    st2.ptensor_mat hadamard (st3.ptensor_mat (H_k k) (1\\<^sub>m st4.d2))", "using hadamard_dim st3.ptensor_mat_dim_col[unfolded st3.d0_def st3.dims0_def st3.vars0_def, simplified splitset]\n        st3.ptensor_mat_dim_row[unfolded st3.d0_def st3.dims0_def st3.vars0_def, simplified splitset]"], ["proof (prove)\nusing this:\n  hadamard \\<in> carrier_mat 2 2\n  dim_col (st3.ptensor_mat ?m1.0 ?m2.0) =\n  prod_list (nths dims (vars1 - {Suc k}))\n  dim_row (st3.ptensor_mat ?m1.0 ?m2.0) =\n  prod_list (nths dims (vars1 - {Suc k}))\n\ngoal (1 subgoal):\n 1. st2.ptensor_mat (1\\<^sub>m 2 * hadamard)\n     (st3.ptensor_mat (H_k k) (1\\<^sub>m st4.d2) *\n      1\\<^sub>m (prod_list (nths dims (vars1 - {Suc k})))) =\n    st2.ptensor_mat hadamard (st3.ptensor_mat (H_k k) (1\\<^sub>m st4.d2))", "by auto"], ["proof (state)\nthis:\n  st2.ptensor_mat (1\\<^sub>m 2 * hadamard)\n   (st3.ptensor_mat (H_k k) (1\\<^sub>m st4.d2) * 1\\<^sub>m st2.d2) =\n  st2.ptensor_mat hadamard (st3.ptensor_mat (H_k k) (1\\<^sub>m st4.d2))\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < n \\<Longrightarrow>\n                exH_k k =\n                partial_state2.pmat_extension dims {0..<Suc k} {Suc k..<n}\n                 (H_k k);\n        Suc k < n\\<rbrakk>\n       \\<Longrightarrow> exH_k (Suc k) =\n                         partial_state2.pmat_extension dims\n                          {0..<Suc (Suc k)} {Suc (Suc k)..<n} (H_k (Suc k))", "also"], ["proof (state)\nthis:\n  st2.ptensor_mat (1\\<^sub>m 2 * hadamard)\n   (st3.ptensor_mat (H_k k) (1\\<^sub>m st4.d2) * 1\\<^sub>m st2.d2) =\n  st2.ptensor_mat hadamard (st3.ptensor_mat (H_k k) (1\\<^sub>m st4.d2))\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < n \\<Longrightarrow>\n                exH_k k =\n                partial_state2.pmat_extension dims {0..<Suc k} {Suc k..<n}\n                 (H_k k);\n        Suc k < n\\<rbrakk>\n       \\<Longrightarrow> exH_k (Suc k) =\n                         partial_state2.pmat_extension dims\n                          {0..<Suc (Suc k)} {Suc (Suc k)..<n} (H_k (Suc k))", "have \"\\<dots> = ptensor_mat dims ({0..<Suc k}\\<union>{Suc k}) {Suc (Suc k)..<n} (ptensor_mat dims {Suc k} {0..<Suc k} hadamard (H_k k)) (1\\<^sub>m st3.d2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. st2.ptensor_mat hadamard (st3.ptensor_mat (H_k k) (1\\<^sub>m st4.d2)) =\n    partial_state2.ptensor_mat dims ({0..<Suc k} \\<union> {Suc k})\n     {Suc (Suc k)..<n}\n     (partial_state2.ptensor_mat dims {Suc k} {0..<Suc k} hadamard (H_k k))\n     (1\\<^sub>m st4.d2)", "apply (subst ptensor_mat_assoc[symmetric, of \"{Suc k}\" \"{0..<Suc k}\" \"{Suc (Suc k)..<n}\" \"hadamard\" \"H_k k\" \"1\\<^sub>m st3.d2\", simplified splitset])"], ["proof (prove)\ngoal (4 subgoals):\n 1. {Suc k} \\<inter> {0..<Suc k} = {}\n 2. ({Suc k} \\<union> {0..<Suc k}) \\<inter> {Suc (Suc k)..<n} = {}\n 3. {Suc k} \\<union> {0..<Suc k} \\<union> {Suc (Suc k)..<n}\n    \\<subseteq> {0..<length dims}\n 4. partial_state2.ptensor_mat dims ({Suc k} \\<union> {0..<Suc k})\n     {Suc (Suc k)..<n}\n     (partial_state2.ptensor_mat dims {Suc k} {0..<Suc k} hadamard (H_k k))\n     (1\\<^sub>m st4.d2) =\n    partial_state2.ptensor_mat dims ({0..<Suc k} \\<union> {Suc k})\n     {Suc (Suc k)..<n}\n     (partial_state2.ptensor_mat dims {Suc k} {0..<Suc k} hadamard (H_k k))\n     (1\\<^sub>m st4.d2)", "using Suc length_dims"], ["proof (prove)\nusing this:\n  k < n \\<Longrightarrow> exH_k k = st.pmat_extension (H_k k)\n  Suc k < n\n  length dims = n + 1\n\ngoal (4 subgoals):\n 1. {Suc k} \\<inter> {0..<Suc k} = {}\n 2. ({Suc k} \\<union> {0..<Suc k}) \\<inter> {Suc (Suc k)..<n} = {}\n 3. {Suc k} \\<union> {0..<Suc k} \\<union> {Suc (Suc k)..<n}\n    \\<subseteq> {0..<length dims}\n 4. partial_state2.ptensor_mat dims ({Suc k} \\<union> {0..<Suc k})\n     {Suc (Suc k)..<n}\n     (partial_state2.ptensor_mat dims {Suc k} {0..<Suc k} hadamard (H_k k))\n     (1\\<^sub>m st4.d2) =\n    partial_state2.ptensor_mat dims ({0..<Suc k} \\<union> {Suc k})\n     {Suc (Suc k)..<n}\n     (partial_state2.ptensor_mat dims {Suc k} {0..<Suc k} hadamard (H_k k))\n     (1\\<^sub>m st4.d2)", "by auto"], ["proof (state)\nthis:\n  st2.ptensor_mat hadamard (st3.ptensor_mat (H_k k) (1\\<^sub>m st4.d2)) =\n  partial_state2.ptensor_mat dims ({0..<Suc k} \\<union> {Suc k})\n   {Suc (Suc k)..<n}\n   (partial_state2.ptensor_mat dims {Suc k} {0..<Suc k} hadamard (H_k k))\n   (1\\<^sub>m st4.d2)\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < n \\<Longrightarrow>\n                exH_k k =\n                partial_state2.pmat_extension dims {0..<Suc k} {Suc k..<n}\n                 (H_k k);\n        Suc k < n\\<rbrakk>\n       \\<Longrightarrow> exH_k (Suc k) =\n                         partial_state2.pmat_extension dims\n                          {0..<Suc (Suc k)} {Suc (Suc k)..<n} (H_k (Suc k))", "also"], ["proof (state)\nthis:\n  st2.ptensor_mat hadamard (st3.ptensor_mat (H_k k) (1\\<^sub>m st4.d2)) =\n  partial_state2.ptensor_mat dims ({0..<Suc k} \\<union> {Suc k})\n   {Suc (Suc k)..<n}\n   (partial_state2.ptensor_mat dims {Suc k} {0..<Suc k} hadamard (H_k k))\n   (1\\<^sub>m st4.d2)\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < n \\<Longrightarrow>\n                exH_k k =\n                partial_state2.pmat_extension dims {0..<Suc k} {Suc k..<n}\n                 (H_k k);\n        Suc k < n\\<rbrakk>\n       \\<Longrightarrow> exH_k (Suc k) =\n                         partial_state2.pmat_extension dims\n                          {0..<Suc (Suc k)} {Suc (Suc k)..<n} (H_k (Suc k))", "have \"\\<dots> = ptensor_mat dims ({0..<Suc k}\\<union>{Suc k}) {Suc (Suc k)..<n} (H_k (Suc k)) (1\\<^sub>m st3.d2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. partial_state2.ptensor_mat dims ({0..<Suc k} \\<union> {Suc k})\n     {Suc (Suc k)..<n}\n     (partial_state2.ptensor_mat dims {Suc k} {0..<Suc k} hadamard (H_k k))\n     (1\\<^sub>m st4.d2) =\n    partial_state2.ptensor_mat dims ({0..<Suc k} \\<union> {Suc k})\n     {Suc (Suc k)..<n} (H_k (Suc k)) (1\\<^sub>m st4.d2)", "using ptensor_mat_comm[of \"{Suc k}\"] Sksplit1"], ["proof (prove)\nusing this:\n  {Suc k} \\<inter> ?vars2.0 = {} \\<Longrightarrow>\n  partial_state2.ptensor_mat dims {Suc k} ?vars2.0 ?m1.0 ?m2.0 =\n  partial_state2.ptensor_mat dims ?vars2.0 {Suc k} ?m2.0 ?m1.0\n  {0..<Suc k} \\<union> {Suc k} = {0..<Suc (Suc k)}\n\ngoal (1 subgoal):\n 1. partial_state2.ptensor_mat dims ({0..<Suc k} \\<union> {Suc k})\n     {Suc (Suc k)..<n}\n     (partial_state2.ptensor_mat dims {Suc k} {0..<Suc k} hadamard (H_k k))\n     (1\\<^sub>m st4.d2) =\n    partial_state2.ptensor_mat dims ({0..<Suc k} \\<union> {Suc k})\n     {Suc (Suc k)..<n} (H_k (Suc k)) (1\\<^sub>m st4.d2)", "by auto"], ["proof (state)\nthis:\n  partial_state2.ptensor_mat dims ({0..<Suc k} \\<union> {Suc k})\n   {Suc (Suc k)..<n}\n   (partial_state2.ptensor_mat dims {Suc k} {0..<Suc k} hadamard (H_k k))\n   (1\\<^sub>m st4.d2) =\n  partial_state2.ptensor_mat dims ({0..<Suc k} \\<union> {Suc k})\n   {Suc (Suc k)..<n} (H_k (Suc k)) (1\\<^sub>m st4.d2)\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < n \\<Longrightarrow>\n                exH_k k =\n                partial_state2.pmat_extension dims {0..<Suc k} {Suc k..<n}\n                 (H_k k);\n        Suc k < n\\<rbrakk>\n       \\<Longrightarrow> exH_k (Suc k) =\n                         partial_state2.pmat_extension dims\n                          {0..<Suc (Suc k)} {Suc (Suc k)..<n} (H_k (Suc k))", "also"], ["proof (state)\nthis:\n  partial_state2.ptensor_mat dims ({0..<Suc k} \\<union> {Suc k})\n   {Suc (Suc k)..<n}\n   (partial_state2.ptensor_mat dims {Suc k} {0..<Suc k} hadamard (H_k k))\n   (1\\<^sub>m st4.d2) =\n  partial_state2.ptensor_mat dims ({0..<Suc k} \\<union> {Suc k})\n   {Suc (Suc k)..<n} (H_k (Suc k)) (1\\<^sub>m st4.d2)\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < n \\<Longrightarrow>\n                exH_k k =\n                partial_state2.pmat_extension dims {0..<Suc k} {Suc k..<n}\n                 (H_k k);\n        Suc k < n\\<rbrakk>\n       \\<Longrightarrow> exH_k (Suc k) =\n                         partial_state2.pmat_extension dims\n                          {0..<Suc (Suc k)} {Suc (Suc k)..<n} (H_k (Suc k))", "have \"\\<dots> = ptensor_mat dims ({0..<Suc (Suc k)}) {Suc (Suc k)..<n} (H_k (Suc k)) (1\\<^sub>m st3.d2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. partial_state2.ptensor_mat dims ({0..<Suc k} \\<union> {Suc k})\n     {Suc (Suc k)..<n} (H_k (Suc k)) (1\\<^sub>m st4.d2) =\n    st4.ptensor_mat (H_k (Suc k)) (1\\<^sub>m st4.d2)", "using Sksplit1"], ["proof (prove)\nusing this:\n  {0..<Suc k} \\<union> {Suc k} = {0..<Suc (Suc k)}\n\ngoal (1 subgoal):\n 1. partial_state2.ptensor_mat dims ({0..<Suc k} \\<union> {Suc k})\n     {Suc (Suc k)..<n} (H_k (Suc k)) (1\\<^sub>m st4.d2) =\n    st4.ptensor_mat (H_k (Suc k)) (1\\<^sub>m st4.d2)", "by auto"], ["proof (state)\nthis:\n  partial_state2.ptensor_mat dims ({0..<Suc k} \\<union> {Suc k})\n   {Suc (Suc k)..<n} (H_k (Suc k)) (1\\<^sub>m st4.d2) =\n  st4.ptensor_mat (H_k (Suc k)) (1\\<^sub>m st4.d2)\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < n \\<Longrightarrow>\n                exH_k k =\n                partial_state2.pmat_extension dims {0..<Suc k} {Suc k..<n}\n                 (H_k k);\n        Suc k < n\\<rbrakk>\n       \\<Longrightarrow> exH_k (Suc k) =\n                         partial_state2.pmat_extension dims\n                          {0..<Suc (Suc k)} {Suc (Suc k)..<n} (H_k (Suc k))", "also"], ["proof (state)\nthis:\n  partial_state2.ptensor_mat dims ({0..<Suc k} \\<union> {Suc k})\n   {Suc (Suc k)..<n} (H_k (Suc k)) (1\\<^sub>m st4.d2) =\n  st4.ptensor_mat (H_k (Suc k)) (1\\<^sub>m st4.d2)\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < n \\<Longrightarrow>\n                exH_k k =\n                partial_state2.pmat_extension dims {0..<Suc k} {Suc k..<n}\n                 (H_k k);\n        Suc k < n\\<rbrakk>\n       \\<Longrightarrow> exH_k (Suc k) =\n                         partial_state2.pmat_extension dims\n                          {0..<Suc (Suc k)} {Suc (Suc k)..<n} (H_k (Suc k))", "have \"\\<dots> = pmat_extension dims {0..<Suc (Suc k)} {Suc (Suc k)..<n} (H_k (Suc k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. st4.ptensor_mat (H_k (Suc k)) (1\\<^sub>m st4.d2) =\n    st4.pmat_extension (H_k (Suc k))", "unfolding st4.pmat_extension_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. st4.ptensor_mat (H_k (Suc k)) (1\\<^sub>m st4.d2) =\n    st4.ptensor_mat (H_k (Suc k)) (1\\<^sub>m st4.d2)", "by auto"], ["proof (state)\nthis:\n  st4.ptensor_mat (H_k (Suc k)) (1\\<^sub>m st4.d2) =\n  st4.pmat_extension (H_k (Suc k))\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < n \\<Longrightarrow>\n                exH_k k =\n                partial_state2.pmat_extension dims {0..<Suc k} {Suc k..<n}\n                 (H_k k);\n        Suc k < n\\<rbrakk>\n       \\<Longrightarrow> exH_k (Suc k) =\n                         partial_state2.pmat_extension dims\n                          {0..<Suc (Suc k)} {Suc (Suc k)..<n} (H_k (Suc k))", "finally"], ["proof (chain)\npicking this:\n  st2.ptensor_mat (1\\<^sub>m 2)\n   (st3.ptensor_mat (H_k k) (1\\<^sub>m st4.d2)) *\n  st2.ptensor_mat hadamard (1\\<^sub>m st2.d2) =\n  st4.pmat_extension (H_k (Suc k))", "show ?case"], ["proof (prove)\nusing this:\n  st2.ptensor_mat (1\\<^sub>m 2)\n   (st3.ptensor_mat (H_k k) (1\\<^sub>m st4.d2)) *\n  st2.ptensor_mat hadamard (1\\<^sub>m st2.d2) =\n  st4.pmat_extension (H_k (Suc k))\n\ngoal (1 subgoal):\n 1. exH_k (Suc k) = st4.pmat_extension (H_k (Suc k))", "using eq0 eql4 eqr1"], ["proof (prove)\nusing this:\n  st2.ptensor_mat (1\\<^sub>m 2)\n   (st3.ptensor_mat (H_k k) (1\\<^sub>m st4.d2)) *\n  st2.ptensor_mat hadamard (1\\<^sub>m st2.d2) =\n  st4.pmat_extension (H_k (Suc k))\n  exH_k (Suc k) = st.pmat_extension (H_k k) * st2.pmat_extension hadamard\n  st.pmat_extension (H_k k) =\n  st2.ptensor_mat (1\\<^sub>m 2) (st3.ptensor_mat (H_k k) (1\\<^sub>m st4.d2))\n  st2.pmat_extension hadamard = st2.ptensor_mat hadamard (1\\<^sub>m st2.d2)\n\ngoal (1 subgoal):\n 1. exH_k (Suc k) = st4.pmat_extension (H_k (Suc k))", "by auto"], ["proof (state)\nthis:\n  exH_k (Suc k) = st4.pmat_extension (H_k (Suc k))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mult_exH_k_left:\n  assumes \"Suc k < n\"\n  shows \"hadamard_on_i (Suc k) * exH_k k = exH_k (Suc k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hadamard_on_i (Suc k) * exH_k k = exH_k (Suc k)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. hadamard_on_i (Suc k) * exH_k k = exH_k (Suc k)", "interpret st: partial_state2 dims \"{0..<Suc k}\" \"{(Suc k)..<n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. partial_state2 {0..<Suc k} {Suc k..<n}", "apply unfold_locales"], ["proof (prove)\ngoal (1 subgoal):\n 1. {0..<Suc k} \\<inter> {Suc k..<n} = {}", "by auto"], ["proof (state)\ngoal (1 subgoal):\n 1. hadamard_on_i (Suc k) * exH_k k = exH_k (Suc k)", "interpret st1: partial_state2 dims \"{Suc k}\" \"{(Suc (Suc k))..<n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. partial_state2 {Suc k} {Suc (Suc k)..<n}", "apply unfold_locales"], ["proof (prove)\ngoal (1 subgoal):\n 1. {Suc k} \\<inter> {Suc (Suc k)..<n} = {}", "by auto"], ["proof (state)\ngoal (1 subgoal):\n 1. hadamard_on_i (Suc k) * exH_k k = exH_k (Suc k)", "interpret st2: partial_state2 dims \"{Suc k}\" \"vars1 - {Suc k}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. partial_state2 {Suc k} (vars1 - {Suc k})", "apply unfold_locales"], ["proof (prove)\ngoal (1 subgoal):\n 1. {Suc k} \\<inter> (vars1 - {Suc k}) = {}", "by auto"], ["proof (state)\ngoal (1 subgoal):\n 1. hadamard_on_i (Suc k) * exH_k k = exH_k (Suc k)", "interpret st3: partial_state2 dims \"{0..<Suc k}\" \"{Suc (Suc k)..<n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. partial_state2 {0..<Suc k} {Suc (Suc k)..<n}", "apply unfold_locales"], ["proof (prove)\ngoal (1 subgoal):\n 1. {0..<Suc k} \\<inter> {Suc (Suc k)..<n} = {}", "by auto"], ["proof (state)\ngoal (1 subgoal):\n 1. hadamard_on_i (Suc k) * exH_k k = exH_k (Suc k)", "interpret st4: partial_state2 dims \"{0..<Suc (Suc k)}\" \"{Suc (Suc k)..<n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. partial_state2 {0..<Suc (Suc k)} {Suc (Suc k)..<n}", "apply unfold_locales"], ["proof (prove)\ngoal (1 subgoal):\n 1. {0..<Suc (Suc k)} \\<inter> {Suc (Suc k)..<n} = {}", "by auto"], ["proof (state)\ngoal (1 subgoal):\n 1. hadamard_on_i (Suc k) * exH_k k = exH_k (Suc k)", "from exH_k_eq_H_k assms"], ["proof (chain)\npicking this:\n  ?k < n \\<Longrightarrow>\n  exH_k ?k =\n  partial_state2.pmat_extension dims {0..<Suc ?k} {Suc ?k..<n} (H_k ?k)\n  Suc k < n", "have eq0: \"exH_k (Suc k) \n    = (st.pmat_extension (H_k k)) * (st2.pmat_extension hadamard)\""], ["proof (prove)\nusing this:\n  ?k < n \\<Longrightarrow>\n  exH_k ?k =\n  partial_state2.pmat_extension dims {0..<Suc ?k} {Suc ?k..<n} (H_k ?k)\n  Suc k < n\n\ngoal (1 subgoal):\n 1. exH_k (Suc k) = st.pmat_extension (H_k k) * st2.pmat_extension hadamard", "by auto"], ["proof (state)\nthis:\n  exH_k (Suc k) = st.pmat_extension (H_k k) * st2.pmat_extension hadamard\n\ngoal (1 subgoal):\n 1. hadamard_on_i (Suc k) * exH_k k = exH_k (Suc k)", "have \"vars1 - {0..<Suc k} = {(Suc k)..<n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vars1 - {0..<Suc k} = {Suc k..<n}", "using vars1_def"], ["proof (prove)\nusing this:\n  vars1 = {0..<n}\n\ngoal (1 subgoal):\n 1. vars1 - {0..<Suc k} = {Suc k..<n}", "by auto"], ["proof (state)\nthis:\n  vars1 - {0..<Suc k} = {Suc k..<n}\n\ngoal (1 subgoal):\n 1. hadamard_on_i (Suc k) * exH_k k = exH_k (Suc k)", "then"], ["proof (chain)\npicking this:\n  vars1 - {0..<Suc k} = {Suc k..<n}", "have eql1: \"st.pmat_extension (H_k k) = st.ptensor_mat (H_k k) (1\\<^sub>m st.d2)\""], ["proof (prove)\nusing this:\n  vars1 - {0..<Suc k} = {Suc k..<n}\n\ngoal (1 subgoal):\n 1. st.pmat_extension (H_k k) = st.ptensor_mat (H_k k) (1\\<^sub>m st.d2)", "using st.pmat_extension_def"], ["proof (prove)\nusing this:\n  vars1 - {0..<Suc k} = {Suc k..<n}\n  st.pmat_extension ?m = st.ptensor_mat ?m (1\\<^sub>m st.d2)\n\ngoal (1 subgoal):\n 1. st.pmat_extension (H_k k) = st.ptensor_mat (H_k k) (1\\<^sub>m st.d2)", "by auto"], ["proof (state)\nthis:\n  st.pmat_extension (H_k k) = st.ptensor_mat (H_k k) (1\\<^sub>m st.d2)\n\ngoal (1 subgoal):\n 1. hadamard_on_i (Suc k) * exH_k k = exH_k (Suc k)", "from dims_nths_one_lt_n[OF assms]"], ["proof (chain)\npicking this:\n  nths dims {Suc k} = [2]", "have st1d1: \"st1.d1 = 2\""], ["proof (prove)\nusing this:\n  nths dims {Suc k} = [2]\n\ngoal (1 subgoal):\n 1. st2.d1 = 2", "unfolding st1.d1_def st1.dims1_def"], ["proof (prove)\nusing this:\n  nths dims {Suc k} = [2]\n\ngoal (1 subgoal):\n 1. prod_list (nths dims {Suc k}) = 2", "by fastforce"], ["proof (state)\nthis:\n  st2.d1 = 2\n\ngoal (1 subgoal):\n 1. hadamard_on_i (Suc k) * exH_k k = exH_k (Suc k)", "have \"{Suc k} \\<union> {Suc (Suc k)..<n} = {Suc k..<n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {Suc k} \\<union> {Suc (Suc k)..<n} = {Suc k..<n}", "using assms"], ["proof (prove)\nusing this:\n  Suc k < n\n\ngoal (1 subgoal):\n 1. {Suc k} \\<union> {Suc (Suc k)..<n} = {Suc k..<n}", "by auto"], ["proof (state)\nthis:\n  {Suc k} \\<union> {Suc (Suc k)..<n} = {Suc k..<n}\n\ngoal (1 subgoal):\n 1. hadamard_on_i (Suc k) * exH_k k = exH_k (Suc k)", "then"], ["proof (chain)\npicking this:\n  {Suc k} \\<union> {Suc (Suc k)..<n} = {Suc k..<n}", "have \"st1.d0 = st.d2\""], ["proof (prove)\nusing this:\n  {Suc k} \\<union> {Suc (Suc k)..<n} = {Suc k..<n}\n\ngoal (1 subgoal):\n 1. st1.d0 = st.d2", "unfolding st1.d0_def st1.dims0_def st1.vars0_def st.d2_def st.dims2_def"], ["proof (prove)\nusing this:\n  {Suc k} \\<union> {Suc (Suc k)..<n} = {Suc k..<n}\n\ngoal (1 subgoal):\n 1. prod_list (nths dims ({Suc k} \\<union> {Suc (Suc k)..<n})) =\n    prod_list (nths dims {Suc k..<n})", "by fastforce"], ["proof (state)\nthis:\n  st1.d0 = st.d2\n\ngoal (1 subgoal):\n 1. hadamard_on_i (Suc k) * exH_k k = exH_k (Suc k)", "then"], ["proof (chain)\npicking this:\n  st1.d0 = st.d2", "have eql2: \"st1.ptensor_mat (1\\<^sub>m 2) (1\\<^sub>m st1.d2) = 1\\<^sub>m st.d2\""], ["proof (prove)\nusing this:\n  st1.d0 = st.d2\n\ngoal (1 subgoal):\n 1. st1.ptensor_mat (1\\<^sub>m 2) (1\\<^sub>m st4.d2) = 1\\<^sub>m st.d2", "using st1.ptensor_mat_id st1d1"], ["proof (prove)\nusing this:\n  st1.d0 = st.d2\n  st1.ptensor_mat (1\\<^sub>m st2.d1) (1\\<^sub>m st4.d2) = 1\\<^sub>m st1.d0\n  st2.d1 = 2\n\ngoal (1 subgoal):\n 1. st1.ptensor_mat (1\\<^sub>m 2) (1\\<^sub>m st4.d2) = 1\\<^sub>m st.d2", "by auto"], ["proof (state)\nthis:\n  st1.ptensor_mat (1\\<^sub>m 2) (1\\<^sub>m st4.d2) = 1\\<^sub>m st.d2\n\ngoal (1 subgoal):\n 1. hadamard_on_i (Suc k) * exH_k k = exH_k (Suc k)", "have eql3: \"st.ptensor_mat (H_k k) (1\\<^sub>m st.d2) = st.ptensor_mat (H_k k) (st1.ptensor_mat (1\\<^sub>m 2) (1\\<^sub>m st1.d2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. st.ptensor_mat (H_k k) (1\\<^sub>m st.d2) =\n    st.ptensor_mat (H_k k)\n     (st1.ptensor_mat (1\\<^sub>m 2) (1\\<^sub>m st4.d2))", "apply (subst eql2[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. st.ptensor_mat (H_k k)\n     (st1.ptensor_mat (1\\<^sub>m 2) (1\\<^sub>m st4.d2)) =\n    st.ptensor_mat (H_k k)\n     (st1.ptensor_mat (1\\<^sub>m 2) (1\\<^sub>m st4.d2))", "by auto"], ["proof (state)\nthis:\n  st.ptensor_mat (H_k k) (1\\<^sub>m st.d2) =\n  st.ptensor_mat (H_k k) (st1.ptensor_mat (1\\<^sub>m 2) (1\\<^sub>m st4.d2))\n\ngoal (1 subgoal):\n 1. hadamard_on_i (Suc k) * exH_k k = exH_k (Suc k)", "have eqr1: \"(st2.pmat_extension hadamard) = st2.ptensor_mat hadamard (1\\<^sub>m st2.d2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. st2.pmat_extension hadamard =\n    st2.ptensor_mat hadamard (1\\<^sub>m st2.d2)", "using st2.pmat_extension_def"], ["proof (prove)\nusing this:\n  st2.pmat_extension ?m = st2.ptensor_mat ?m (1\\<^sub>m st2.d2)\n\ngoal (1 subgoal):\n 1. st2.pmat_extension hadamard =\n    st2.ptensor_mat hadamard (1\\<^sub>m st2.d2)", "by auto"], ["proof (state)\nthis:\n  st2.pmat_extension hadamard = st2.ptensor_mat hadamard (1\\<^sub>m st2.d2)\n\ngoal (1 subgoal):\n 1. hadamard_on_i (Suc k) * exH_k k = exH_k (Suc k)", "have splitset: \"{0..<Suc k} \\<union> {Suc (Suc k)..<n} = vars1 - {Suc k}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {0..<Suc k} \\<union> {Suc (Suc k)..<n} = vars1 - {Suc k}", "unfolding vars1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {0..<Suc k} \\<union> {Suc (Suc k)..<n} = {0..<n} - {Suc k}", "using assms"], ["proof (prove)\nusing this:\n  Suc k < n\n\ngoal (1 subgoal):\n 1. {0..<Suc k} \\<union> {Suc (Suc k)..<n} = {0..<n} - {Suc k}", "by auto"], ["proof (state)\nthis:\n  {0..<Suc k} \\<union> {Suc (Suc k)..<n} = vars1 - {Suc k}\n\ngoal (1 subgoal):\n 1. hadamard_on_i (Suc k) * exH_k k = exH_k (Suc k)", "have Sksplit: \"{Suc k} \\<union> {Suc (Suc k)..<n} = {Suc k..<n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {Suc k} \\<union> {Suc (Suc k)..<n} = {Suc k..<n}", "using assms"], ["proof (prove)\nusing this:\n  Suc k < n\n\ngoal (1 subgoal):\n 1. {Suc k} \\<union> {Suc (Suc k)..<n} = {Suc k..<n}", "by auto"], ["proof (state)\nthis:\n  {Suc k} \\<union> {Suc (Suc k)..<n} = {Suc k..<n}\n\ngoal (1 subgoal):\n 1. hadamard_on_i (Suc k) * exH_k k = exH_k (Suc k)", "have Sksplit1: \"{0..<Suc k}\\<union>{Suc k} = {0..<Suc (Suc k)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {0..<Suc k} \\<union> {Suc k} = {0..<Suc (Suc k)}", "by auto"], ["proof (state)\nthis:\n  {0..<Suc k} \\<union> {Suc k} = {0..<Suc (Suc k)}\n\ngoal (1 subgoal):\n 1. hadamard_on_i (Suc k) * exH_k k = exH_k (Suc k)", "have \"st.ptensor_mat (H_k k) (st1.ptensor_mat (1\\<^sub>m 2) (1\\<^sub>m st1.d2)) \n    = ptensor_mat dims ({0..<Suc k}\\<union>{Suc k}) {Suc (Suc k)..<n} (ptensor_mat dims {0..<Suc k} {Suc k} (H_k k) (1\\<^sub>m 2)) (1\\<^sub>m st1.d2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. st.ptensor_mat (H_k k)\n     (st1.ptensor_mat (1\\<^sub>m 2) (1\\<^sub>m st4.d2)) =\n    partial_state2.ptensor_mat dims ({0..<Suc k} \\<union> {Suc k})\n     {Suc (Suc k)..<n}\n     (partial_state2.ptensor_mat dims {0..<Suc k} {Suc k} (H_k k)\n       (1\\<^sub>m 2))\n     (1\\<^sub>m st4.d2)", "apply (subst ptensor_mat_assoc[symmetric, of \"{0..<Suc k}\" \"{Suc k}\" \"{Suc (Suc k)..<n}\" \"H_k k\" \"1\\<^sub>m 2\" \"1\\<^sub>m st1.d2\", simplified Sksplit])"], ["proof (prove)\ngoal (4 subgoals):\n 1. {0..<Suc k} \\<inter> {Suc k} = {}\n 2. ({0..<Suc k} \\<union> {Suc k}) \\<inter> {Suc (Suc k)..<n} = {}\n 3. {0..<Suc k} \\<union> {Suc k} \\<union> {Suc (Suc k)..<n}\n    \\<subseteq> {0..<length dims}\n 4. partial_state2.ptensor_mat dims ({0..<Suc k} \\<union> {Suc k})\n     {Suc (Suc k)..<n}\n     (partial_state2.ptensor_mat dims {0..<Suc k} {Suc k} (H_k k)\n       (1\\<^sub>m 2))\n     (1\\<^sub>m st4.d2) =\n    partial_state2.ptensor_mat dims ({0..<Suc k} \\<union> {Suc k})\n     {Suc (Suc k)..<n}\n     (partial_state2.ptensor_mat dims {0..<Suc k} {Suc k} (H_k k)\n       (1\\<^sub>m 2))\n     (1\\<^sub>m st4.d2)", "using assms length_dims"], ["proof (prove)\nusing this:\n  Suc k < n\n  length dims = n + 1\n\ngoal (4 subgoals):\n 1. {0..<Suc k} \\<inter> {Suc k} = {}\n 2. ({0..<Suc k} \\<union> {Suc k}) \\<inter> {Suc (Suc k)..<n} = {}\n 3. {0..<Suc k} \\<union> {Suc k} \\<union> {Suc (Suc k)..<n}\n    \\<subseteq> {0..<length dims}\n 4. partial_state2.ptensor_mat dims ({0..<Suc k} \\<union> {Suc k})\n     {Suc (Suc k)..<n}\n     (partial_state2.ptensor_mat dims {0..<Suc k} {Suc k} (H_k k)\n       (1\\<^sub>m 2))\n     (1\\<^sub>m st4.d2) =\n    partial_state2.ptensor_mat dims ({0..<Suc k} \\<union> {Suc k})\n     {Suc (Suc k)..<n}\n     (partial_state2.ptensor_mat dims {0..<Suc k} {Suc k} (H_k k)\n       (1\\<^sub>m 2))\n     (1\\<^sub>m st4.d2)", "by auto"], ["proof (state)\nthis:\n  st.ptensor_mat (H_k k)\n   (st1.ptensor_mat (1\\<^sub>m 2) (1\\<^sub>m st4.d2)) =\n  partial_state2.ptensor_mat dims ({0..<Suc k} \\<union> {Suc k})\n   {Suc (Suc k)..<n}\n   (partial_state2.ptensor_mat dims {0..<Suc k} {Suc k} (H_k k)\n     (1\\<^sub>m 2))\n   (1\\<^sub>m st4.d2)\n\ngoal (1 subgoal):\n 1. hadamard_on_i (Suc k) * exH_k k = exH_k (Suc k)", "also"], ["proof (state)\nthis:\n  st.ptensor_mat (H_k k)\n   (st1.ptensor_mat (1\\<^sub>m 2) (1\\<^sub>m st4.d2)) =\n  partial_state2.ptensor_mat dims ({0..<Suc k} \\<union> {Suc k})\n   {Suc (Suc k)..<n}\n   (partial_state2.ptensor_mat dims {0..<Suc k} {Suc k} (H_k k)\n     (1\\<^sub>m 2))\n   (1\\<^sub>m st4.d2)\n\ngoal (1 subgoal):\n 1. hadamard_on_i (Suc k) * exH_k k = exH_k (Suc k)", "have \"\\<dots> = ptensor_mat dims ({0..<Suc k}\\<union>{Suc k}) {Suc (Suc k)..<n} (ptensor_mat dims {Suc k} {0..<Suc k} (1\\<^sub>m 2) (H_k k)) (1\\<^sub>m st1.d2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. partial_state2.ptensor_mat dims ({0..<Suc k} \\<union> {Suc k})\n     {Suc (Suc k)..<n}\n     (partial_state2.ptensor_mat dims {0..<Suc k} {Suc k} (H_k k)\n       (1\\<^sub>m 2))\n     (1\\<^sub>m st4.d2) =\n    partial_state2.ptensor_mat dims ({0..<Suc k} \\<union> {Suc k})\n     {Suc (Suc k)..<n}\n     (partial_state2.ptensor_mat dims {Suc k} {0..<Suc k} (1\\<^sub>m 2)\n       (H_k k))\n     (1\\<^sub>m st4.d2)", "using ptensor_mat_comm[of \"{0..<Suc k}\" \"{Suc k}\"]"], ["proof (prove)\nusing this:\n  {0..<Suc k} \\<inter> {Suc k} = {} \\<Longrightarrow>\n  partial_state2.ptensor_mat dims {0..<Suc k} {Suc k} ?m1.0 ?m2.0 =\n  partial_state2.ptensor_mat dims {Suc k} {0..<Suc k} ?m2.0 ?m1.0\n\ngoal (1 subgoal):\n 1. partial_state2.ptensor_mat dims ({0..<Suc k} \\<union> {Suc k})\n     {Suc (Suc k)..<n}\n     (partial_state2.ptensor_mat dims {0..<Suc k} {Suc k} (H_k k)\n       (1\\<^sub>m 2))\n     (1\\<^sub>m st4.d2) =\n    partial_state2.ptensor_mat dims ({0..<Suc k} \\<union> {Suc k})\n     {Suc (Suc k)..<n}\n     (partial_state2.ptensor_mat dims {Suc k} {0..<Suc k} (1\\<^sub>m 2)\n       (H_k k))\n     (1\\<^sub>m st4.d2)", "by auto"], ["proof (state)\nthis:\n  partial_state2.ptensor_mat dims ({0..<Suc k} \\<union> {Suc k})\n   {Suc (Suc k)..<n}\n   (partial_state2.ptensor_mat dims {0..<Suc k} {Suc k} (H_k k)\n     (1\\<^sub>m 2))\n   (1\\<^sub>m st4.d2) =\n  partial_state2.ptensor_mat dims ({0..<Suc k} \\<union> {Suc k})\n   {Suc (Suc k)..<n}\n   (partial_state2.ptensor_mat dims {Suc k} {0..<Suc k} (1\\<^sub>m 2)\n     (H_k k))\n   (1\\<^sub>m st4.d2)\n\ngoal (1 subgoal):\n 1. hadamard_on_i (Suc k) * exH_k k = exH_k (Suc k)", "also"], ["proof (state)\nthis:\n  partial_state2.ptensor_mat dims ({0..<Suc k} \\<union> {Suc k})\n   {Suc (Suc k)..<n}\n   (partial_state2.ptensor_mat dims {0..<Suc k} {Suc k} (H_k k)\n     (1\\<^sub>m 2))\n   (1\\<^sub>m st4.d2) =\n  partial_state2.ptensor_mat dims ({0..<Suc k} \\<union> {Suc k})\n   {Suc (Suc k)..<n}\n   (partial_state2.ptensor_mat dims {Suc k} {0..<Suc k} (1\\<^sub>m 2)\n     (H_k k))\n   (1\\<^sub>m st4.d2)\n\ngoal (1 subgoal):\n 1. hadamard_on_i (Suc k) * exH_k k = exH_k (Suc k)", "have \"\\<dots> = ptensor_mat dims {Suc k} ({0..<Suc k} \\<union> {Suc (Suc k)..<n})\n                  (1\\<^sub>m 2) \n                  (ptensor_mat dims {0..<Suc k} {Suc (Suc k)..<n} (H_k k) (1\\<^sub>m st1.d2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. partial_state2.ptensor_mat dims ({0..<Suc k} \\<union> {Suc k})\n     {Suc (Suc k)..<n}\n     (partial_state2.ptensor_mat dims {Suc k} {0..<Suc k} (1\\<^sub>m 2)\n       (H_k k))\n     (1\\<^sub>m st4.d2) =\n    partial_state2.ptensor_mat dims {Suc k}\n     ({0..<Suc k} \\<union> {Suc (Suc k)..<n}) (1\\<^sub>m 2)\n     (st3.ptensor_mat (H_k k) (1\\<^sub>m st4.d2))", "apply (subst sup_commute)"], ["proof (prove)\ngoal (1 subgoal):\n 1. partial_state2.ptensor_mat dims ({Suc k} \\<union> {0..<Suc k})\n     {Suc (Suc k)..<n}\n     (partial_state2.ptensor_mat dims {Suc k} {0..<Suc k} (1\\<^sub>m 2)\n       (H_k k))\n     (1\\<^sub>m st4.d2) =\n    partial_state2.ptensor_mat dims {Suc k}\n     ({0..<Suc k} \\<union> {Suc (Suc k)..<n}) (1\\<^sub>m 2)\n     (st3.ptensor_mat (H_k k) (1\\<^sub>m st4.d2))", "apply (subst ptensor_mat_assoc[of \"{Suc k}\" \"{0..<Suc k}\" \"{Suc (Suc k)..<n}\" \"(1\\<^sub>m 2)\" \"H_k k\" \"1\\<^sub>m st1.d2\"])"], ["proof (prove)\ngoal (4 subgoals):\n 1. {Suc k} \\<inter> {0..<Suc k} = {}\n 2. ({Suc k} \\<union> {0..<Suc k}) \\<inter> {Suc (Suc k)..<n} = {}\n 3. {Suc k} \\<union> {0..<Suc k} \\<union> {Suc (Suc k)..<n}\n    \\<subseteq> {0..<length dims}\n 4. partial_state2.ptensor_mat dims {Suc k}\n     ({0..<Suc k} \\<union> {Suc (Suc k)..<n}) (1\\<^sub>m 2)\n     (st3.ptensor_mat (H_k k) (1\\<^sub>m st4.d2)) =\n    partial_state2.ptensor_mat dims {Suc k}\n     ({0..<Suc k} \\<union> {Suc (Suc k)..<n}) (1\\<^sub>m 2)\n     (st3.ptensor_mat (H_k k) (1\\<^sub>m st4.d2))", "using assms length_dims"], ["proof (prove)\nusing this:\n  Suc k < n\n  length dims = n + 1\n\ngoal (4 subgoals):\n 1. {Suc k} \\<inter> {0..<Suc k} = {}\n 2. ({Suc k} \\<union> {0..<Suc k}) \\<inter> {Suc (Suc k)..<n} = {}\n 3. {Suc k} \\<union> {0..<Suc k} \\<union> {Suc (Suc k)..<n}\n    \\<subseteq> {0..<length dims}\n 4. partial_state2.ptensor_mat dims {Suc k}\n     ({0..<Suc k} \\<union> {Suc (Suc k)..<n}) (1\\<^sub>m 2)\n     (st3.ptensor_mat (H_k k) (1\\<^sub>m st4.d2)) =\n    partial_state2.ptensor_mat dims {Suc k}\n     ({0..<Suc k} \\<union> {Suc (Suc k)..<n}) (1\\<^sub>m 2)\n     (st3.ptensor_mat (H_k k) (1\\<^sub>m st4.d2))", "by auto"], ["proof (state)\nthis:\n  partial_state2.ptensor_mat dims ({0..<Suc k} \\<union> {Suc k})\n   {Suc (Suc k)..<n}\n   (partial_state2.ptensor_mat dims {Suc k} {0..<Suc k} (1\\<^sub>m 2)\n     (H_k k))\n   (1\\<^sub>m st4.d2) =\n  partial_state2.ptensor_mat dims {Suc k}\n   ({0..<Suc k} \\<union> {Suc (Suc k)..<n}) (1\\<^sub>m 2)\n   (st3.ptensor_mat (H_k k) (1\\<^sub>m st4.d2))\n\ngoal (1 subgoal):\n 1. hadamard_on_i (Suc k) * exH_k k = exH_k (Suc k)", "finally"], ["proof (chain)\npicking this:\n  st.ptensor_mat (H_k k)\n   (st1.ptensor_mat (1\\<^sub>m 2) (1\\<^sub>m st4.d2)) =\n  partial_state2.ptensor_mat dims {Suc k}\n   ({0..<Suc k} \\<union> {Suc (Suc k)..<n}) (1\\<^sub>m 2)\n   (st3.ptensor_mat (H_k k) (1\\<^sub>m st4.d2))", "have \"st.pmat_extension (H_k k) \n    = st2.ptensor_mat (1\\<^sub>m 2) (st3.ptensor_mat (H_k k) (1\\<^sub>m st3.d2))\""], ["proof (prove)\nusing this:\n  st.ptensor_mat (H_k k)\n   (st1.ptensor_mat (1\\<^sub>m 2) (1\\<^sub>m st4.d2)) =\n  partial_state2.ptensor_mat dims {Suc k}\n   ({0..<Suc k} \\<union> {Suc (Suc k)..<n}) (1\\<^sub>m 2)\n   (st3.ptensor_mat (H_k k) (1\\<^sub>m st4.d2))\n\ngoal (1 subgoal):\n 1. st.pmat_extension (H_k k) =\n    st2.ptensor_mat (1\\<^sub>m 2)\n     (st3.ptensor_mat (H_k k) (1\\<^sub>m st4.d2))", "using eql1 eql3 splitset"], ["proof (prove)\nusing this:\n  st.ptensor_mat (H_k k)\n   (st1.ptensor_mat (1\\<^sub>m 2) (1\\<^sub>m st4.d2)) =\n  partial_state2.ptensor_mat dims {Suc k}\n   ({0..<Suc k} \\<union> {Suc (Suc k)..<n}) (1\\<^sub>m 2)\n   (st3.ptensor_mat (H_k k) (1\\<^sub>m st4.d2))\n  st.pmat_extension (H_k k) = st.ptensor_mat (H_k k) (1\\<^sub>m st.d2)\n  st.ptensor_mat (H_k k) (1\\<^sub>m st.d2) =\n  st.ptensor_mat (H_k k) (st1.ptensor_mat (1\\<^sub>m 2) (1\\<^sub>m st4.d2))\n  {0..<Suc k} \\<union> {Suc (Suc k)..<n} = vars1 - {Suc k}\n\ngoal (1 subgoal):\n 1. st.pmat_extension (H_k k) =\n    st2.ptensor_mat (1\\<^sub>m 2)\n     (st3.ptensor_mat (H_k k) (1\\<^sub>m st4.d2))", "by auto"], ["proof (state)\nthis:\n  st.pmat_extension (H_k k) =\n  st2.ptensor_mat (1\\<^sub>m 2) (st3.ptensor_mat (H_k k) (1\\<^sub>m st4.d2))\n\ngoal (1 subgoal):\n 1. hadamard_on_i (Suc k) * exH_k k = exH_k (Suc k)", "moreover"], ["proof (state)\nthis:\n  st.pmat_extension (H_k k) =\n  st2.ptensor_mat (1\\<^sub>m 2) (st3.ptensor_mat (H_k k) (1\\<^sub>m st4.d2))\n\ngoal (1 subgoal):\n 1. hadamard_on_i (Suc k) * exH_k k = exH_k (Suc k)", "have \"st.pmat_extension (H_k k) = exH_k k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. st.pmat_extension (H_k k) = exH_k k", "using exH_k_eq_H_k assms"], ["proof (prove)\nusing this:\n  ?k < n \\<Longrightarrow>\n  exH_k ?k =\n  partial_state2.pmat_extension dims {0..<Suc ?k} {Suc ?k..<n} (H_k ?k)\n  Suc k < n\n\ngoal (1 subgoal):\n 1. st.pmat_extension (H_k k) = exH_k k", "by auto"], ["proof (state)\nthis:\n  st.pmat_extension (H_k k) = exH_k k\n\ngoal (1 subgoal):\n 1. hadamard_on_i (Suc k) * exH_k k = exH_k (Suc k)", "ultimately"], ["proof (chain)\npicking this:\n  st.pmat_extension (H_k k) =\n  st2.ptensor_mat (1\\<^sub>m 2) (st3.ptensor_mat (H_k k) (1\\<^sub>m st4.d2))\n  st.pmat_extension (H_k k) = exH_k k", "have eql4: \"exH_k k = st2.ptensor_mat (1\\<^sub>m 2) (st3.ptensor_mat (H_k k) (1\\<^sub>m st3.d2))\""], ["proof (prove)\nusing this:\n  st.pmat_extension (H_k k) =\n  st2.ptensor_mat (1\\<^sub>m 2) (st3.ptensor_mat (H_k k) (1\\<^sub>m st4.d2))\n  st.pmat_extension (H_k k) = exH_k k\n\ngoal (1 subgoal):\n 1. exH_k k =\n    st2.ptensor_mat (1\\<^sub>m 2)\n     (st3.ptensor_mat (H_k k) (1\\<^sub>m st4.d2))", "by auto"], ["proof (state)\nthis:\n  exH_k k =\n  st2.ptensor_mat (1\\<^sub>m 2) (st3.ptensor_mat (H_k k) (1\\<^sub>m st4.d2))\n\ngoal (1 subgoal):\n 1. hadamard_on_i (Suc k) * exH_k k = exH_k (Suc k)", "have \"st2.ptensor_mat hadamard (1\\<^sub>m st2.d2) * st2.ptensor_mat (1\\<^sub>m 2) (st3.ptensor_mat (H_k k) (1\\<^sub>m st3.d2))\n        = st2.ptensor_mat (hadamard*(1\\<^sub>m 2)) ((1\\<^sub>m st2.d2)* (st3.ptensor_mat (H_k k) (1\\<^sub>m st3.d2)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. st2.ptensor_mat hadamard (1\\<^sub>m st2.d2) *\n    st2.ptensor_mat (1\\<^sub>m 2)\n     (st3.ptensor_mat (H_k k) (1\\<^sub>m st4.d2)) =\n    st2.ptensor_mat (hadamard * 1\\<^sub>m 2)\n     (1\\<^sub>m st2.d2 * st3.ptensor_mat (H_k k) (1\\<^sub>m st4.d2))", "apply (rule st2.ptensor_mat_mult[symmetric, of \"hadamard\" \"1\\<^sub>m 2\" \"(1\\<^sub>m st2.d2)\" \"(st3.ptensor_mat (H_k k) (1\\<^sub>m st3.d2))\"])"], ["proof (prove)\ngoal (4 subgoals):\n 1. hadamard \\<in> carrier_mat st2.d1 st2.d1\n 2. 1\\<^sub>m 2 \\<in> carrier_mat st2.d1 st2.d1\n 3. 1\\<^sub>m st2.d2 \\<in> carrier_mat st2.d2 st2.d2\n 4. st3.ptensor_mat (H_k k) (1\\<^sub>m st4.d2)\n    \\<in> carrier_mat st2.d2 st2.d2", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. hadamard \\<in> carrier_mat st2.d1 st2.d1", "unfolding st2.d1_def st2.dims1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. hadamard\n    \\<in> carrier_mat (prod_list (nths dims {Suc k}))\n           (prod_list (nths dims {Suc k}))", "apply (simp add: dims_nths_one_lt_n assms)"], ["proof (prove)\ngoal (1 subgoal):\n 1. hadamard \\<in> carrier_mat 2 2", "using hadamard_dim"], ["proof (prove)\nusing this:\n  hadamard \\<in> carrier_mat 2 2\n\ngoal (1 subgoal):\n 1. hadamard \\<in> carrier_mat 2 2", "by auto"], ["proof (prove)\ngoal (3 subgoals):\n 1. 1\\<^sub>m 2 \\<in> carrier_mat st2.d1 st2.d1\n 2. 1\\<^sub>m st2.d2 \\<in> carrier_mat st2.d2 st2.d2\n 3. st3.ptensor_mat (H_k k) (1\\<^sub>m st4.d2)\n    \\<in> carrier_mat st2.d2 st2.d2", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1\\<^sub>m 2 \\<in> carrier_mat st2.d1 st2.d1", "unfolding st2.d1_def st2.dims1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1\\<^sub>m 2\n    \\<in> carrier_mat (prod_list (nths dims {Suc k}))\n           (prod_list (nths dims {Suc k}))", "by (simp add: dims_nths_one_lt_n assms)"], ["proof (prove)\ngoal (2 subgoals):\n 1. 1\\<^sub>m st2.d2 \\<in> carrier_mat st2.d2 st2.d2\n 2. st3.ptensor_mat (H_k k) (1\\<^sub>m st4.d2)\n    \\<in> carrier_mat st2.d2 st2.d2", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1\\<^sub>m st2.d2 \\<in> carrier_mat st2.d2 st2.d2", "by auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. st3.ptensor_mat (H_k k) (1\\<^sub>m st4.d2)\n    \\<in> carrier_mat st2.d2 st2.d2", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. st3.ptensor_mat (H_k k) (1\\<^sub>m st4.d2)\n    \\<in> carrier_mat st2.d2 st2.d2", "unfolding st2.d2_def[unfolded st2.dims2_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. st3.ptensor_mat (H_k k) (1\\<^sub>m st4.d2)\n    \\<in> carrier_mat (prod_list (nths dims (vars1 - {Suc k})))\n           (prod_list (nths dims (vars1 - {Suc k})))", "using st3.ptensor_mat_dim_col[unfolded st3.d0_def st3.dims0_def st3.vars0_def, simplified splitset]\n        st3.ptensor_mat_dim_row[unfolded st3.d0_def st3.dims0_def st3.vars0_def, simplified splitset]"], ["proof (prove)\nusing this:\n  dim_col (st3.ptensor_mat ?m1.0 ?m2.0) =\n  prod_list (nths dims (vars1 - {Suc k}))\n  dim_row (st3.ptensor_mat ?m1.0 ?m2.0) =\n  prod_list (nths dims (vars1 - {Suc k}))\n\ngoal (1 subgoal):\n 1. st3.ptensor_mat (H_k k) (1\\<^sub>m st4.d2)\n    \\<in> carrier_mat (prod_list (nths dims (vars1 - {Suc k})))\n           (prod_list (nths dims (vars1 - {Suc k})))", "by auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  st2.ptensor_mat hadamard (1\\<^sub>m st2.d2) *\n  st2.ptensor_mat (1\\<^sub>m 2)\n   (st3.ptensor_mat (H_k k) (1\\<^sub>m st4.d2)) =\n  st2.ptensor_mat (hadamard * 1\\<^sub>m 2)\n   (1\\<^sub>m st2.d2 * st3.ptensor_mat (H_k k) (1\\<^sub>m st4.d2))\n\ngoal (1 subgoal):\n 1. hadamard_on_i (Suc k) * exH_k k = exH_k (Suc k)", "also"], ["proof (state)\nthis:\n  st2.ptensor_mat hadamard (1\\<^sub>m st2.d2) *\n  st2.ptensor_mat (1\\<^sub>m 2)\n   (st3.ptensor_mat (H_k k) (1\\<^sub>m st4.d2)) =\n  st2.ptensor_mat (hadamard * 1\\<^sub>m 2)\n   (1\\<^sub>m st2.d2 * st3.ptensor_mat (H_k k) (1\\<^sub>m st4.d2))\n\ngoal (1 subgoal):\n 1. hadamard_on_i (Suc k) * exH_k k = exH_k (Suc k)", "have \"\\<dots> = st2.ptensor_mat (hadamard) (st3.ptensor_mat (H_k k) (1\\<^sub>m st3.d2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. st2.ptensor_mat (hadamard * 1\\<^sub>m 2)\n     (1\\<^sub>m st2.d2 * st3.ptensor_mat (H_k k) (1\\<^sub>m st4.d2)) =\n    st2.ptensor_mat hadamard (st3.ptensor_mat (H_k k) (1\\<^sub>m st4.d2))", "unfolding st2.d2_def[unfolded st2.dims2_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. st2.ptensor_mat (hadamard * 1\\<^sub>m 2)\n     (1\\<^sub>m (prod_list (nths dims (vars1 - {Suc k}))) *\n      st3.ptensor_mat (H_k k) (1\\<^sub>m st4.d2)) =\n    st2.ptensor_mat hadamard (st3.ptensor_mat (H_k k) (1\\<^sub>m st4.d2))", "using hadamard_dim st3.ptensor_mat_dim_col[unfolded st3.d0_def st3.dims0_def st3.vars0_def, simplified splitset]\n        st3.ptensor_mat_dim_row[unfolded st3.d0_def st3.dims0_def st3.vars0_def, simplified splitset]"], ["proof (prove)\nusing this:\n  hadamard \\<in> carrier_mat 2 2\n  dim_col (st3.ptensor_mat ?m1.0 ?m2.0) =\n  prod_list (nths dims (vars1 - {Suc k}))\n  dim_row (st3.ptensor_mat ?m1.0 ?m2.0) =\n  prod_list (nths dims (vars1 - {Suc k}))\n\ngoal (1 subgoal):\n 1. st2.ptensor_mat (hadamard * 1\\<^sub>m 2)\n     (1\\<^sub>m (prod_list (nths dims (vars1 - {Suc k}))) *\n      st3.ptensor_mat (H_k k) (1\\<^sub>m st4.d2)) =\n    st2.ptensor_mat hadamard (st3.ptensor_mat (H_k k) (1\\<^sub>m st4.d2))", "by auto"], ["proof (state)\nthis:\n  st2.ptensor_mat (hadamard * 1\\<^sub>m 2)\n   (1\\<^sub>m st2.d2 * st3.ptensor_mat (H_k k) (1\\<^sub>m st4.d2)) =\n  st2.ptensor_mat hadamard (st3.ptensor_mat (H_k k) (1\\<^sub>m st4.d2))\n\ngoal (1 subgoal):\n 1. hadamard_on_i (Suc k) * exH_k k = exH_k (Suc k)", "also"], ["proof (state)\nthis:\n  st2.ptensor_mat (hadamard * 1\\<^sub>m 2)\n   (1\\<^sub>m st2.d2 * st3.ptensor_mat (H_k k) (1\\<^sub>m st4.d2)) =\n  st2.ptensor_mat hadamard (st3.ptensor_mat (H_k k) (1\\<^sub>m st4.d2))\n\ngoal (1 subgoal):\n 1. hadamard_on_i (Suc k) * exH_k k = exH_k (Suc k)", "have \"\\<dots> = ptensor_mat dims ({0..<Suc k}\\<union>{Suc k}) {Suc (Suc k)..<n} (ptensor_mat dims {Suc k} {0..<Suc k} hadamard (H_k k)) (1\\<^sub>m st3.d2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. st2.ptensor_mat hadamard (st3.ptensor_mat (H_k k) (1\\<^sub>m st4.d2)) =\n    partial_state2.ptensor_mat dims ({0..<Suc k} \\<union> {Suc k})\n     {Suc (Suc k)..<n}\n     (partial_state2.ptensor_mat dims {Suc k} {0..<Suc k} hadamard (H_k k))\n     (1\\<^sub>m st4.d2)", "apply (subst ptensor_mat_assoc[symmetric, of \"{Suc k}\" \"{0..<Suc k}\" \"{Suc (Suc k)..<n}\" \"hadamard\" \"H_k k\" \"1\\<^sub>m st3.d2\", simplified splitset])"], ["proof (prove)\ngoal (4 subgoals):\n 1. {Suc k} \\<inter> {0..<Suc k} = {}\n 2. ({Suc k} \\<union> {0..<Suc k}) \\<inter> {Suc (Suc k)..<n} = {}\n 3. {Suc k} \\<union> {0..<Suc k} \\<union> {Suc (Suc k)..<n}\n    \\<subseteq> {0..<length dims}\n 4. partial_state2.ptensor_mat dims ({Suc k} \\<union> {0..<Suc k})\n     {Suc (Suc k)..<n}\n     (partial_state2.ptensor_mat dims {Suc k} {0..<Suc k} hadamard (H_k k))\n     (1\\<^sub>m st4.d2) =\n    partial_state2.ptensor_mat dims ({0..<Suc k} \\<union> {Suc k})\n     {Suc (Suc k)..<n}\n     (partial_state2.ptensor_mat dims {Suc k} {0..<Suc k} hadamard (H_k k))\n     (1\\<^sub>m st4.d2)", "using assms length_dims"], ["proof (prove)\nusing this:\n  Suc k < n\n  length dims = n + 1\n\ngoal (4 subgoals):\n 1. {Suc k} \\<inter> {0..<Suc k} = {}\n 2. ({Suc k} \\<union> {0..<Suc k}) \\<inter> {Suc (Suc k)..<n} = {}\n 3. {Suc k} \\<union> {0..<Suc k} \\<union> {Suc (Suc k)..<n}\n    \\<subseteq> {0..<length dims}\n 4. partial_state2.ptensor_mat dims ({Suc k} \\<union> {0..<Suc k})\n     {Suc (Suc k)..<n}\n     (partial_state2.ptensor_mat dims {Suc k} {0..<Suc k} hadamard (H_k k))\n     (1\\<^sub>m st4.d2) =\n    partial_state2.ptensor_mat dims ({0..<Suc k} \\<union> {Suc k})\n     {Suc (Suc k)..<n}\n     (partial_state2.ptensor_mat dims {Suc k} {0..<Suc k} hadamard (H_k k))\n     (1\\<^sub>m st4.d2)", "by auto"], ["proof (state)\nthis:\n  st2.ptensor_mat hadamard (st3.ptensor_mat (H_k k) (1\\<^sub>m st4.d2)) =\n  partial_state2.ptensor_mat dims ({0..<Suc k} \\<union> {Suc k})\n   {Suc (Suc k)..<n}\n   (partial_state2.ptensor_mat dims {Suc k} {0..<Suc k} hadamard (H_k k))\n   (1\\<^sub>m st4.d2)\n\ngoal (1 subgoal):\n 1. hadamard_on_i (Suc k) * exH_k k = exH_k (Suc k)", "also"], ["proof (state)\nthis:\n  st2.ptensor_mat hadamard (st3.ptensor_mat (H_k k) (1\\<^sub>m st4.d2)) =\n  partial_state2.ptensor_mat dims ({0..<Suc k} \\<union> {Suc k})\n   {Suc (Suc k)..<n}\n   (partial_state2.ptensor_mat dims {Suc k} {0..<Suc k} hadamard (H_k k))\n   (1\\<^sub>m st4.d2)\n\ngoal (1 subgoal):\n 1. hadamard_on_i (Suc k) * exH_k k = exH_k (Suc k)", "have \"\\<dots> = ptensor_mat dims ({0..<Suc k}\\<union>{Suc k}) {Suc (Suc k)..<n} (H_k (Suc k)) (1\\<^sub>m st3.d2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. partial_state2.ptensor_mat dims ({0..<Suc k} \\<union> {Suc k})\n     {Suc (Suc k)..<n}\n     (partial_state2.ptensor_mat dims {Suc k} {0..<Suc k} hadamard (H_k k))\n     (1\\<^sub>m st4.d2) =\n    partial_state2.ptensor_mat dims ({0..<Suc k} \\<union> {Suc k})\n     {Suc (Suc k)..<n} (H_k (Suc k)) (1\\<^sub>m st4.d2)", "using ptensor_mat_comm[of \"{Suc k}\"] Sksplit1"], ["proof (prove)\nusing this:\n  {Suc k} \\<inter> ?vars2.0 = {} \\<Longrightarrow>\n  partial_state2.ptensor_mat dims {Suc k} ?vars2.0 ?m1.0 ?m2.0 =\n  partial_state2.ptensor_mat dims ?vars2.0 {Suc k} ?m2.0 ?m1.0\n  {0..<Suc k} \\<union> {Suc k} = {0..<Suc (Suc k)}\n\ngoal (1 subgoal):\n 1. partial_state2.ptensor_mat dims ({0..<Suc k} \\<union> {Suc k})\n     {Suc (Suc k)..<n}\n     (partial_state2.ptensor_mat dims {Suc k} {0..<Suc k} hadamard (H_k k))\n     (1\\<^sub>m st4.d2) =\n    partial_state2.ptensor_mat dims ({0..<Suc k} \\<union> {Suc k})\n     {Suc (Suc k)..<n} (H_k (Suc k)) (1\\<^sub>m st4.d2)", "by auto"], ["proof (state)\nthis:\n  partial_state2.ptensor_mat dims ({0..<Suc k} \\<union> {Suc k})\n   {Suc (Suc k)..<n}\n   (partial_state2.ptensor_mat dims {Suc k} {0..<Suc k} hadamard (H_k k))\n   (1\\<^sub>m st4.d2) =\n  partial_state2.ptensor_mat dims ({0..<Suc k} \\<union> {Suc k})\n   {Suc (Suc k)..<n} (H_k (Suc k)) (1\\<^sub>m st4.d2)\n\ngoal (1 subgoal):\n 1. hadamard_on_i (Suc k) * exH_k k = exH_k (Suc k)", "also"], ["proof (state)\nthis:\n  partial_state2.ptensor_mat dims ({0..<Suc k} \\<union> {Suc k})\n   {Suc (Suc k)..<n}\n   (partial_state2.ptensor_mat dims {Suc k} {0..<Suc k} hadamard (H_k k))\n   (1\\<^sub>m st4.d2) =\n  partial_state2.ptensor_mat dims ({0..<Suc k} \\<union> {Suc k})\n   {Suc (Suc k)..<n} (H_k (Suc k)) (1\\<^sub>m st4.d2)\n\ngoal (1 subgoal):\n 1. hadamard_on_i (Suc k) * exH_k k = exH_k (Suc k)", "have \"\\<dots> = ptensor_mat dims ({0..<Suc (Suc k)}) {Suc (Suc k)..<n} (H_k (Suc k)) (1\\<^sub>m st3.d2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. partial_state2.ptensor_mat dims ({0..<Suc k} \\<union> {Suc k})\n     {Suc (Suc k)..<n} (H_k (Suc k)) (1\\<^sub>m st4.d2) =\n    st4.ptensor_mat (H_k (Suc k)) (1\\<^sub>m st4.d2)", "using Sksplit1"], ["proof (prove)\nusing this:\n  {0..<Suc k} \\<union> {Suc k} = {0..<Suc (Suc k)}\n\ngoal (1 subgoal):\n 1. partial_state2.ptensor_mat dims ({0..<Suc k} \\<union> {Suc k})\n     {Suc (Suc k)..<n} (H_k (Suc k)) (1\\<^sub>m st4.d2) =\n    st4.ptensor_mat (H_k (Suc k)) (1\\<^sub>m st4.d2)", "by auto"], ["proof (state)\nthis:\n  partial_state2.ptensor_mat dims ({0..<Suc k} \\<union> {Suc k})\n   {Suc (Suc k)..<n} (H_k (Suc k)) (1\\<^sub>m st4.d2) =\n  st4.ptensor_mat (H_k (Suc k)) (1\\<^sub>m st4.d2)\n\ngoal (1 subgoal):\n 1. hadamard_on_i (Suc k) * exH_k k = exH_k (Suc k)", "also"], ["proof (state)\nthis:\n  partial_state2.ptensor_mat dims ({0..<Suc k} \\<union> {Suc k})\n   {Suc (Suc k)..<n} (H_k (Suc k)) (1\\<^sub>m st4.d2) =\n  st4.ptensor_mat (H_k (Suc k)) (1\\<^sub>m st4.d2)\n\ngoal (1 subgoal):\n 1. hadamard_on_i (Suc k) * exH_k k = exH_k (Suc k)", "have \"\\<dots> = pmat_extension dims {0..<Suc (Suc k)} {Suc (Suc k)..<n} (H_k (Suc k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. st4.ptensor_mat (H_k (Suc k)) (1\\<^sub>m st4.d2) =\n    st4.pmat_extension (H_k (Suc k))", "unfolding st4.pmat_extension_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. st4.ptensor_mat (H_k (Suc k)) (1\\<^sub>m st4.d2) =\n    st4.ptensor_mat (H_k (Suc k)) (1\\<^sub>m st4.d2)", "by auto"], ["proof (state)\nthis:\n  st4.ptensor_mat (H_k (Suc k)) (1\\<^sub>m st4.d2) =\n  st4.pmat_extension (H_k (Suc k))\n\ngoal (1 subgoal):\n 1. hadamard_on_i (Suc k) * exH_k k = exH_k (Suc k)", "also"], ["proof (state)\nthis:\n  st4.ptensor_mat (H_k (Suc k)) (1\\<^sub>m st4.d2) =\n  st4.pmat_extension (H_k (Suc k))\n\ngoal (1 subgoal):\n 1. hadamard_on_i (Suc k) * exH_k k = exH_k (Suc k)", "have \"\\<dots> = exH_k (Suc k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. st4.pmat_extension (H_k (Suc k)) = exH_k (Suc k)", "using exH_k_eq_H_k[of \"Suc k\"] assms"], ["proof (prove)\nusing this:\n  Suc k < n \\<Longrightarrow>\n  exH_k (Suc k) = st4.pmat_extension (H_k (Suc k))\n  Suc k < n\n\ngoal (1 subgoal):\n 1. st4.pmat_extension (H_k (Suc k)) = exH_k (Suc k)", "by auto"], ["proof (state)\nthis:\n  st4.pmat_extension (H_k (Suc k)) = exH_k (Suc k)\n\ngoal (1 subgoal):\n 1. hadamard_on_i (Suc k) * exH_k k = exH_k (Suc k)", "finally"], ["proof (chain)\npicking this:\n  st2.ptensor_mat hadamard (1\\<^sub>m st2.d2) *\n  st2.ptensor_mat (1\\<^sub>m 2)\n   (st3.ptensor_mat (H_k k) (1\\<^sub>m st4.d2)) =\n  exH_k (Suc k)", "have \"st2.ptensor_mat hadamard (1\\<^sub>m st2.d2) * st2.ptensor_mat (1\\<^sub>m 2) (st3.ptensor_mat (H_k k) (1\\<^sub>m st3.d2)) \n    =exH_k (Suc k)\""], ["proof (prove)\nusing this:\n  st2.ptensor_mat hadamard (1\\<^sub>m st2.d2) *\n  st2.ptensor_mat (1\\<^sub>m 2)\n   (st3.ptensor_mat (H_k k) (1\\<^sub>m st4.d2)) =\n  exH_k (Suc k)\n\ngoal (1 subgoal):\n 1. st2.ptensor_mat hadamard (1\\<^sub>m st2.d2) *\n    st2.ptensor_mat (1\\<^sub>m 2)\n     (st3.ptensor_mat (H_k k) (1\\<^sub>m st4.d2)) =\n    exH_k (Suc k)", "."], ["proof (state)\nthis:\n  st2.ptensor_mat hadamard (1\\<^sub>m st2.d2) *\n  st2.ptensor_mat (1\\<^sub>m 2)\n   (st3.ptensor_mat (H_k k) (1\\<^sub>m st4.d2)) =\n  exH_k (Suc k)\n\ngoal (1 subgoal):\n 1. hadamard_on_i (Suc k) * exH_k k = exH_k (Suc k)", "then"], ["proof (chain)\npicking this:\n  st2.ptensor_mat hadamard (1\\<^sub>m st2.d2) *\n  st2.ptensor_mat (1\\<^sub>m 2)\n   (st3.ptensor_mat (H_k k) (1\\<^sub>m st4.d2)) =\n  exH_k (Suc k)", "show ?thesis"], ["proof (prove)\nusing this:\n  st2.ptensor_mat hadamard (1\\<^sub>m st2.d2) *\n  st2.ptensor_mat (1\\<^sub>m 2)\n   (st3.ptensor_mat (H_k k) (1\\<^sub>m st4.d2)) =\n  exH_k (Suc k)\n\ngoal (1 subgoal):\n 1. hadamard_on_i (Suc k) * exH_k k = exH_k (Suc k)", "unfolding hadamard_on_i_def"], ["proof (prove)\nusing this:\n  st2.ptensor_mat hadamard (1\\<^sub>m st2.d2) *\n  st2.ptensor_mat (1\\<^sub>m 2)\n   (st3.ptensor_mat (H_k k) (1\\<^sub>m st4.d2)) =\n  exH_k (Suc k)\n\ngoal (1 subgoal):\n 1. st2.pmat_extension hadamard * exH_k k = exH_k (Suc k)", "using eql4 eqr1"], ["proof (prove)\nusing this:\n  st2.ptensor_mat hadamard (1\\<^sub>m st2.d2) *\n  st2.ptensor_mat (1\\<^sub>m 2)\n   (st3.ptensor_mat (H_k k) (1\\<^sub>m st4.d2)) =\n  exH_k (Suc k)\n  exH_k k =\n  st2.ptensor_mat (1\\<^sub>m 2) (st3.ptensor_mat (H_k k) (1\\<^sub>m st4.d2))\n  st2.pmat_extension hadamard = st2.ptensor_mat hadamard (1\\<^sub>m st2.d2)\n\ngoal (1 subgoal):\n 1. st2.pmat_extension hadamard * exH_k k = exH_k (Suc k)", "by auto"], ["proof (state)\nthis:\n  hadamard_on_i (Suc k) * exH_k k = exH_k (Suc k)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma exH_eq_H:\n  \"exH_k (n - 1) = H_k (n - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exH_k (n - 1) = H_k (n - 1)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. exH_k (n - 1) = H_k (n - 1)", "have \"\\<exists>m. n = Suc (Suc m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>m. n = Suc (Suc m)", "using n"], ["proof (prove)\nusing this:\n  1 < n\n\ngoal (1 subgoal):\n 1. \\<exists>m. n = Suc (Suc m)", "by presburger"], ["proof (state)\nthis:\n  \\<exists>m. n = Suc (Suc m)\n\ngoal (1 subgoal):\n 1. exH_k (n - 1) = H_k (n - 1)", "then"], ["proof (chain)\npicking this:\n  \\<exists>m. n = Suc (Suc m)", "obtain m where m: \"n = Suc (Suc m)\""], ["proof (prove)\nusing this:\n  \\<exists>m. n = Suc (Suc m)\n\ngoal (1 subgoal):\n 1. (\\<And>m. n = Suc (Suc m) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using n"], ["proof (prove)\nusing this:\n  \\<exists>m. n = Suc (Suc m)\n  1 < n\n\ngoal (1 subgoal):\n 1. (\\<And>m. n = Suc (Suc m) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  n = Suc (Suc m)\n\ngoal (1 subgoal):\n 1. exH_k (n - 1) = H_k (n - 1)", "then"], ["proof (chain)\npicking this:\n  n = Suc (Suc m)", "have \"exH_k m = pmat_extension dims {0..<(Suc m)} {(Suc m)..<n} (H_k m)\""], ["proof (prove)\nusing this:\n  n = Suc (Suc m)\n\ngoal (1 subgoal):\n 1. exH_k m =\n    partial_state2.pmat_extension dims {0..<Suc m} {Suc m..<n} (H_k m)", "using exH_k_eq_H_k"], ["proof (prove)\nusing this:\n  n = Suc (Suc m)\n  ?k < n \\<Longrightarrow>\n  exH_k ?k =\n  partial_state2.pmat_extension dims {0..<Suc ?k} {Suc ?k..<n} (H_k ?k)\n\ngoal (1 subgoal):\n 1. exH_k m =\n    partial_state2.pmat_extension dims {0..<Suc m} {Suc m..<n} (H_k m)", "by auto"], ["proof (state)\nthis:\n  exH_k m =\n  partial_state2.pmat_extension dims {0..<Suc m} {Suc m..<n} (H_k m)\n\ngoal (1 subgoal):\n 1. exH_k (n - 1) = H_k (n - 1)", "then"], ["proof (chain)\npicking this:\n  exH_k m =\n  partial_state2.pmat_extension dims {0..<Suc m} {Suc m..<n} (H_k m)", "have \"exH_k (Suc m) = pmat_extension dims {0..<(Suc m)} {(Suc m)..<n} (H_k m) \n                            * (pmat_extension dims {Suc m} (vars1 - {Suc m}) hadamard)\""], ["proof (prove)\nusing this:\n  exH_k m =\n  partial_state2.pmat_extension dims {0..<Suc m} {Suc m..<n} (H_k m)\n\ngoal (1 subgoal):\n 1. exH_k (Suc m) =\n    partial_state2.pmat_extension dims {0..<Suc m} {Suc m..<n} (H_k m) *\n    partial_state2.pmat_extension dims {Suc m} (vars1 - {Suc m}) hadamard", "by auto"], ["proof (state)\nthis:\n  exH_k (Suc m) =\n  partial_state2.pmat_extension dims {0..<Suc m} {Suc m..<n} (H_k m) *\n  partial_state2.pmat_extension dims {Suc m} (vars1 - {Suc m}) hadamard\n\ngoal (1 subgoal):\n 1. exH_k (n - 1) = H_k (n - 1)", "moreover"], ["proof (state)\nthis:\n  exH_k (Suc m) =\n  partial_state2.pmat_extension dims {0..<Suc m} {Suc m..<n} (H_k m) *\n  partial_state2.pmat_extension dims {Suc m} (vars1 - {Suc m}) hadamard\n\ngoal (1 subgoal):\n 1. exH_k (n - 1) = H_k (n - 1)", "have \"{(Suc m)..<n} = {Suc m}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {Suc m..<n} = {Suc m}", "using m"], ["proof (prove)\nusing this:\n  n = Suc (Suc m)\n\ngoal (1 subgoal):\n 1. {Suc m..<n} = {Suc m}", "by auto"], ["proof (state)\nthis:\n  {Suc m..<n} = {Suc m}\n\ngoal (1 subgoal):\n 1. exH_k (n - 1) = H_k (n - 1)", "moreover"], ["proof (state)\nthis:\n  {Suc m..<n} = {Suc m}\n\ngoal (1 subgoal):\n 1. exH_k (n - 1) = H_k (n - 1)", "have \"vars1 - {Suc m} = {0..<Suc m}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vars1 - {Suc m} = {0..<Suc m}", "unfolding vars1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {0..<n} - {Suc m} = {0..<Suc m}", "using m"], ["proof (prove)\nusing this:\n  n = Suc (Suc m)\n\ngoal (1 subgoal):\n 1. {0..<n} - {Suc m} = {0..<Suc m}", "by auto"], ["proof (state)\nthis:\n  vars1 - {Suc m} = {0..<Suc m}\n\ngoal (1 subgoal):\n 1. exH_k (n - 1) = H_k (n - 1)", "ultimately"], ["proof (chain)\npicking this:\n  exH_k (Suc m) =\n  partial_state2.pmat_extension dims {0..<Suc m} {Suc m..<n} (H_k m) *\n  partial_state2.pmat_extension dims {Suc m} (vars1 - {Suc m}) hadamard\n  {Suc m..<n} = {Suc m}\n  vars1 - {Suc m} = {0..<Suc m}", "have eqSm: \"exH_k (Suc m) = pmat_extension dims {0..<(Suc m)} {Suc m} (H_k m) \n                            * (pmat_extension dims {Suc m} {0..<Suc m} hadamard)\""], ["proof (prove)\nusing this:\n  exH_k (Suc m) =\n  partial_state2.pmat_extension dims {0..<Suc m} {Suc m..<n} (H_k m) *\n  partial_state2.pmat_extension dims {Suc m} (vars1 - {Suc m}) hadamard\n  {Suc m..<n} = {Suc m}\n  vars1 - {Suc m} = {0..<Suc m}\n\ngoal (1 subgoal):\n 1. exH_k (Suc m) =\n    partial_state2.pmat_extension dims {0..<Suc m} {Suc m} (H_k m) *\n    partial_state2.pmat_extension dims {Suc m} {0..<Suc m} hadamard", "by auto"], ["proof (state)\nthis:\n  exH_k (Suc m) =\n  partial_state2.pmat_extension dims {0..<Suc m} {Suc m} (H_k m) *\n  partial_state2.pmat_extension dims {Suc m} {0..<Suc m} hadamard\n\ngoal (1 subgoal):\n 1. exH_k (n - 1) = H_k (n - 1)", "interpret stm1: partial_state2 dims \"{Suc m}\" \"{0..<Suc m}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. partial_state2 {Suc m} {0..<Suc m}", "apply unfold_locales"], ["proof (prove)\ngoal (1 subgoal):\n 1. {Suc m} \\<inter> {0..<Suc m} = {}", "by auto"], ["proof (state)\ngoal (1 subgoal):\n 1. exH_k (n - 1) = H_k (n - 1)", "interpret stm2: partial_state2 dims \"{0..<Suc m}\" \"{Suc m}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. partial_state2 {0..<Suc m} {Suc m}", "apply unfold_locales"], ["proof (prove)\ngoal (1 subgoal):\n 1. {0..<Suc m} \\<inter> {Suc m} = {}", "by auto"], ["proof (state)\ngoal (1 subgoal):\n 1. exH_k (n - 1) = H_k (n - 1)", "have \"nths dims {0..<Suc m} = replicate (Suc m) 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nths dims {0..<Suc m} = replicate (Suc m) 2", "using dims_nths_le_n m"], ["proof (prove)\nusing this:\n  ?l \\<le> n \\<Longrightarrow> nths dims {0..<?l} = replicate ?l 2\n  n = Suc (Suc m)\n\ngoal (1 subgoal):\n 1. nths dims {0..<Suc m} = replicate (Suc m) 2", "by auto"], ["proof (state)\nthis:\n  nths dims {0..<Suc m} = replicate (Suc m) 2\n\ngoal (1 subgoal):\n 1. exH_k (n - 1) = H_k (n - 1)", "then"], ["proof (chain)\npicking this:\n  nths dims {0..<Suc m} = replicate (Suc m) 2", "have stm2d1: \"stm2.d1 = 2^(Suc m)\""], ["proof (prove)\nusing this:\n  nths dims {0..<Suc m} = replicate (Suc m) 2\n\ngoal (1 subgoal):\n 1. stm2.d1 = 2 ^ Suc m", "unfolding stm2.d1_def stm2.dims1_def"], ["proof (prove)\nusing this:\n  nths dims {0..<Suc m} = replicate (Suc m) 2\n\ngoal (1 subgoal):\n 1. prod_list (nths dims {0..<Suc m}) = 2 ^ Suc m", "by auto"], ["proof (state)\nthis:\n  stm2.d1 = 2 ^ Suc m\n\ngoal (1 subgoal):\n 1. exH_k (n - 1) = H_k (n - 1)", "have stm2d2: \"stm2.d2 = 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stm2.d2 = 2", "unfolding stm2.d2_def stm2.dims2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. prod_list (nths dims {Suc m}) = 2", "using dims_nths_one_lt_n m"], ["proof (prove)\nusing this:\n  ?l < n \\<Longrightarrow> nths dims {?l} = [2]\n  n = Suc (Suc m)\n\ngoal (1 subgoal):\n 1. prod_list (nths dims {Suc m}) = 2", "by auto"], ["proof (state)\nthis:\n  stm2.d2 = 2\n\ngoal (1 subgoal):\n 1. exH_k (n - 1) = H_k (n - 1)", "have \"m < n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m < n", "using m"], ["proof (prove)\nusing this:\n  n = Suc (Suc m)\n\ngoal (1 subgoal):\n 1. m < n", "by auto"], ["proof (state)\nthis:\n  m < n\n\ngoal (1 subgoal):\n 1. exH_k (n - 1) = H_k (n - 1)", "then"], ["proof (chain)\npicking this:\n  m < n", "have \"H_k m \\<in> carrier_mat (2^(Suc m)) (2^(Suc m))\""], ["proof (prove)\nusing this:\n  m < n\n\ngoal (1 subgoal):\n 1. H_k m \\<in> carrier_mat (2 ^ Suc m) (2 ^ Suc m)", "using H_k_dim"], ["proof (prove)\nusing this:\n  m < n\n  ?k < n \\<Longrightarrow>\n  H_k ?k \\<in> carrier_mat (2 ^ Suc ?k) (2 ^ Suc ?k)\n\ngoal (1 subgoal):\n 1. H_k m \\<in> carrier_mat (2 ^ Suc m) (2 ^ Suc m)", "by auto"], ["proof (state)\nthis:\n  H_k m \\<in> carrier_mat (2 ^ Suc m) (2 ^ Suc m)\n\ngoal (1 subgoal):\n 1. exH_k (n - 1) = H_k (n - 1)", "then"], ["proof (chain)\npicking this:\n  H_k m \\<in> carrier_mat (2 ^ Suc m) (2 ^ Suc m)", "have Hkm1: \"(H_k m) * (1\\<^sub>m stm2.d1) = (H_k m)\""], ["proof (prove)\nusing this:\n  H_k m \\<in> carrier_mat (2 ^ Suc m) (2 ^ Suc m)\n\ngoal (1 subgoal):\n 1. H_k m * 1\\<^sub>m stm2.d1 = H_k m", "unfolding stm2d1"], ["proof (prove)\nusing this:\n  H_k m \\<in> carrier_mat (2 ^ Suc m) (2 ^ Suc m)\n\ngoal (1 subgoal):\n 1. H_k m * 1\\<^sub>m (2 ^ Suc m) = H_k m", "by auto"], ["proof (state)\nthis:\n  H_k m * 1\\<^sub>m stm2.d1 = H_k m\n\ngoal (1 subgoal):\n 1. exH_k (n - 1) = H_k (n - 1)", "have eqd12: \"stm1.d2 = stm2.d1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stm1.d2 = stm2.d1", "unfolding stm1.d2_def stm1.dims2_def stm2.d1_def stm2.dims1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. prod_list (nths dims {0..<Suc m}) = prod_list (nths dims {0..<Suc m})", "by auto"], ["proof (state)\nthis:\n  stm1.d2 = stm2.d1\n\ngoal (1 subgoal):\n 1. exH_k (n - 1) = H_k (n - 1)", "have \"pmat_extension dims {Suc m} {0..<Suc m} hadamard = stm1.ptensor_mat hadamard (1\\<^sub>m stm1.d2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stm1.pmat_extension hadamard =\n    stm1.ptensor_mat hadamard (1\\<^sub>m stm1.d2)", "using stm1.pmat_extension_def"], ["proof (prove)\nusing this:\n  stm1.pmat_extension ?m = stm1.ptensor_mat ?m (1\\<^sub>m stm1.d2)\n\ngoal (1 subgoal):\n 1. stm1.pmat_extension hadamard =\n    stm1.ptensor_mat hadamard (1\\<^sub>m stm1.d2)", "by auto"], ["proof (state)\nthis:\n  stm1.pmat_extension hadamard =\n  stm1.ptensor_mat hadamard (1\\<^sub>m stm1.d2)\n\ngoal (1 subgoal):\n 1. exH_k (n - 1) = H_k (n - 1)", "also"], ["proof (state)\nthis:\n  stm1.pmat_extension hadamard =\n  stm1.ptensor_mat hadamard (1\\<^sub>m stm1.d2)\n\ngoal (1 subgoal):\n 1. exH_k (n - 1) = H_k (n - 1)", "have \"\\<dots> = stm2.ptensor_mat (1\\<^sub>m stm2.d1) hadamard\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stm1.ptensor_mat hadamard (1\\<^sub>m stm1.d2) =\n    stm2.ptensor_mat (1\\<^sub>m stm2.d1) hadamard", "using ptensor_mat_comm eqd12"], ["proof (prove)\nusing this:\n  ?vars1.0 \\<inter> ?vars2.0 = {} \\<Longrightarrow>\n  partial_state2.ptensor_mat dims ?vars1.0 ?vars2.0 ?m1.0 ?m2.0 =\n  partial_state2.ptensor_mat dims ?vars2.0 ?vars1.0 ?m2.0 ?m1.0\n  stm1.d2 = stm2.d1\n\ngoal (1 subgoal):\n 1. stm1.ptensor_mat hadamard (1\\<^sub>m stm1.d2) =\n    stm2.ptensor_mat (1\\<^sub>m stm2.d1) hadamard", "by auto"], ["proof (state)\nthis:\n  stm1.ptensor_mat hadamard (1\\<^sub>m stm1.d2) =\n  stm2.ptensor_mat (1\\<^sub>m stm2.d1) hadamard\n\ngoal (1 subgoal):\n 1. exH_k (n - 1) = H_k (n - 1)", "finally"], ["proof (chain)\npicking this:\n  stm1.pmat_extension hadamard =\n  stm2.ptensor_mat (1\\<^sub>m stm2.d1) hadamard", "have eqr: \"(pmat_extension dims {Suc m} {0..<Suc m} hadamard) = stm2.ptensor_mat (1\\<^sub>m stm2.d1) hadamard\""], ["proof (prove)\nusing this:\n  stm1.pmat_extension hadamard =\n  stm2.ptensor_mat (1\\<^sub>m stm2.d1) hadamard\n\ngoal (1 subgoal):\n 1. stm1.pmat_extension hadamard =\n    stm2.ptensor_mat (1\\<^sub>m stm2.d1) hadamard", "."], ["proof (state)\nthis:\n  stm1.pmat_extension hadamard =\n  stm2.ptensor_mat (1\\<^sub>m stm2.d1) hadamard\n\ngoal (1 subgoal):\n 1. exH_k (n - 1) = H_k (n - 1)", "then"], ["proof (chain)\npicking this:\n  stm1.pmat_extension hadamard =\n  stm2.ptensor_mat (1\\<^sub>m stm2.d1) hadamard", "have \"exH_k (Suc m) = stm2.ptensor_mat (H_k m) (1\\<^sub>m stm2.d2) * stm2.ptensor_mat (1\\<^sub>m stm2.d1) hadamard\""], ["proof (prove)\nusing this:\n  stm1.pmat_extension hadamard =\n  stm2.ptensor_mat (1\\<^sub>m stm2.d1) hadamard\n\ngoal (1 subgoal):\n 1. exH_k (Suc m) =\n    stm2.ptensor_mat (H_k m) (1\\<^sub>m stm2.d2) *\n    stm2.ptensor_mat (1\\<^sub>m stm2.d1) hadamard", "using eqSm"], ["proof (prove)\nusing this:\n  stm1.pmat_extension hadamard =\n  stm2.ptensor_mat (1\\<^sub>m stm2.d1) hadamard\n  exH_k (Suc m) = stm2.pmat_extension (H_k m) * stm1.pmat_extension hadamard\n\ngoal (1 subgoal):\n 1. exH_k (Suc m) =\n    stm2.ptensor_mat (H_k m) (1\\<^sub>m stm2.d2) *\n    stm2.ptensor_mat (1\\<^sub>m stm2.d1) hadamard", "unfolding stm2.pmat_extension_def"], ["proof (prove)\nusing this:\n  stm1.pmat_extension hadamard =\n  stm2.ptensor_mat (1\\<^sub>m stm2.d1) hadamard\n  exH_k (Suc m) =\n  stm2.ptensor_mat (H_k m) (1\\<^sub>m stm2.d2) *\n  stm1.pmat_extension hadamard\n\ngoal (1 subgoal):\n 1. exH_k (Suc m) =\n    stm2.ptensor_mat (H_k m) (1\\<^sub>m stm2.d2) *\n    stm2.ptensor_mat (1\\<^sub>m stm2.d1) hadamard", "by auto"], ["proof (state)\nthis:\n  exH_k (Suc m) =\n  stm2.ptensor_mat (H_k m) (1\\<^sub>m stm2.d2) *\n  stm2.ptensor_mat (1\\<^sub>m stm2.d1) hadamard\n\ngoal (1 subgoal):\n 1. exH_k (n - 1) = H_k (n - 1)", "also"], ["proof (state)\nthis:\n  exH_k (Suc m) =\n  stm2.ptensor_mat (H_k m) (1\\<^sub>m stm2.d2) *\n  stm2.ptensor_mat (1\\<^sub>m stm2.d1) hadamard\n\ngoal (1 subgoal):\n 1. exH_k (n - 1) = H_k (n - 1)", "have \"\\<dots> = stm2.ptensor_mat ((H_k m) * (1\\<^sub>m stm2.d1)) (1\\<^sub>m stm2.d2 * hadamard)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stm2.ptensor_mat (H_k m) (1\\<^sub>m stm2.d2) *\n    stm2.ptensor_mat (1\\<^sub>m stm2.d1) hadamard =\n    stm2.ptensor_mat (H_k m * 1\\<^sub>m stm2.d1)\n     (1\\<^sub>m stm2.d2 * hadamard)", "apply (rule stm2.ptensor_mat_mult[symmetric, of \"H_k m\" \"1\\<^sub>m stm2.d1\" \"1\\<^sub>m stm2.d2\" \"hadamard\"])"], ["proof (prove)\ngoal (4 subgoals):\n 1. H_k m \\<in> carrier_mat stm2.d1 stm2.d1\n 2. 1\\<^sub>m stm2.d1 \\<in> carrier_mat stm2.d1 stm2.d1\n 3. 1\\<^sub>m stm2.d2 \\<in> carrier_mat stm2.d2 stm2.d2\n 4. hadamard \\<in> carrier_mat stm2.d2 stm2.d2", "unfolding stm2d1 stm2d2"], ["proof (prove)\ngoal (4 subgoals):\n 1. H_k m \\<in> carrier_mat (2 ^ Suc m) (2 ^ Suc m)\n 2. 1\\<^sub>m (2 ^ Suc m) \\<in> carrier_mat (2 ^ Suc m) (2 ^ Suc m)\n 3. 1\\<^sub>m 2 \\<in> carrier_mat 2 2\n 4. hadamard \\<in> carrier_mat 2 2", "using H_k_dim m hadamard_dim"], ["proof (prove)\nusing this:\n  ?k < n \\<Longrightarrow>\n  H_k ?k \\<in> carrier_mat (2 ^ Suc ?k) (2 ^ Suc ?k)\n  n = Suc (Suc m)\n  hadamard \\<in> carrier_mat 2 2\n\ngoal (4 subgoals):\n 1. H_k m \\<in> carrier_mat (2 ^ Suc m) (2 ^ Suc m)\n 2. 1\\<^sub>m (2 ^ Suc m) \\<in> carrier_mat (2 ^ Suc m) (2 ^ Suc m)\n 3. 1\\<^sub>m 2 \\<in> carrier_mat 2 2\n 4. hadamard \\<in> carrier_mat 2 2", "by auto"], ["proof (state)\nthis:\n  stm2.ptensor_mat (H_k m) (1\\<^sub>m stm2.d2) *\n  stm2.ptensor_mat (1\\<^sub>m stm2.d1) hadamard =\n  stm2.ptensor_mat (H_k m * 1\\<^sub>m stm2.d1)\n   (1\\<^sub>m stm2.d2 * hadamard)\n\ngoal (1 subgoal):\n 1. exH_k (n - 1) = H_k (n - 1)", "also"], ["proof (state)\nthis:\n  stm2.ptensor_mat (H_k m) (1\\<^sub>m stm2.d2) *\n  stm2.ptensor_mat (1\\<^sub>m stm2.d1) hadamard =\n  stm2.ptensor_mat (H_k m * 1\\<^sub>m stm2.d1)\n   (1\\<^sub>m stm2.d2 * hadamard)\n\ngoal (1 subgoal):\n 1. exH_k (n - 1) = H_k (n - 1)", "have \"\\<dots> = stm2.ptensor_mat (H_k m) (hadamard)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stm2.ptensor_mat (H_k m * 1\\<^sub>m stm2.d1)\n     (1\\<^sub>m stm2.d2 * hadamard) =\n    stm2.ptensor_mat (H_k m) hadamard", "using H_k_dim hadamard_dim stm2d1 stm2d2 Hkm1"], ["proof (prove)\nusing this:\n  ?k < n \\<Longrightarrow>\n  H_k ?k \\<in> carrier_mat (2 ^ Suc ?k) (2 ^ Suc ?k)\n  hadamard \\<in> carrier_mat 2 2\n  stm2.d1 = 2 ^ Suc m\n  stm2.d2 = 2\n  H_k m * 1\\<^sub>m stm2.d1 = H_k m\n\ngoal (1 subgoal):\n 1. stm2.ptensor_mat (H_k m * 1\\<^sub>m stm2.d1)\n     (1\\<^sub>m stm2.d2 * hadamard) =\n    stm2.ptensor_mat (H_k m) hadamard", "by auto"], ["proof (state)\nthis:\n  stm2.ptensor_mat (H_k m * 1\\<^sub>m stm2.d1)\n   (1\\<^sub>m stm2.d2 * hadamard) =\n  stm2.ptensor_mat (H_k m) hadamard\n\ngoal (1 subgoal):\n 1. exH_k (n - 1) = H_k (n - 1)", "also"], ["proof (state)\nthis:\n  stm2.ptensor_mat (H_k m * 1\\<^sub>m stm2.d1)\n   (1\\<^sub>m stm2.d2 * hadamard) =\n  stm2.ptensor_mat (H_k m) hadamard\n\ngoal (1 subgoal):\n 1. exH_k (n - 1) = H_k (n - 1)", "have \"\\<dots> = H_k (Suc m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stm2.ptensor_mat (H_k m) hadamard = H_k (Suc m)", "unfolding stm2.ptensor_mat_def H_k.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. tensor_mat stm2.dims0 stm2.vars1' (H_k m) hadamard =\n    tensor_mat stm2.dims0 stm2.vars1' (H_k m) hadamard", "by auto"], ["proof (state)\nthis:\n  stm2.ptensor_mat (H_k m) hadamard = H_k (Suc m)\n\ngoal (1 subgoal):\n 1. exH_k (n - 1) = H_k (n - 1)", "finally"], ["proof (chain)\npicking this:\n  exH_k (Suc m) = H_k (Suc m)", "have  \"exH_k (Suc m) = H_k (Suc m)\""], ["proof (prove)\nusing this:\n  exH_k (Suc m) = H_k (Suc m)\n\ngoal (1 subgoal):\n 1. exH_k (Suc m) = H_k (Suc m)", "by auto"], ["proof (state)\nthis:\n  exH_k (Suc m) = H_k (Suc m)\n\ngoal (1 subgoal):\n 1. exH_k (n - 1) = H_k (n - 1)", "moreover"], ["proof (state)\nthis:\n  exH_k (Suc m) = H_k (Suc m)\n\ngoal (1 subgoal):\n 1. exH_k (n - 1) = H_k (n - 1)", "have \"Suc m = n - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc m = n - 1", "using m"], ["proof (prove)\nusing this:\n  n = Suc (Suc m)\n\ngoal (1 subgoal):\n 1. Suc m = n - 1", "by auto"], ["proof (state)\nthis:\n  Suc m = n - 1\n\ngoal (1 subgoal):\n 1. exH_k (n - 1) = H_k (n - 1)", "ultimately"], ["proof (chain)\npicking this:\n  exH_k (Suc m) = H_k (Suc m)\n  Suc m = n - 1", "show ?thesis"], ["proof (prove)\nusing this:\n  exH_k (Suc m) = H_k (Suc m)\n  Suc m = n - 1\n\ngoal (1 subgoal):\n 1. exH_k (n - 1) = H_k (n - 1)", "by auto"], ["proof (state)\nthis:\n  exH_k (n - 1) = H_k (n - 1)\n\ngoal:\nNo subgoals!", "qed"], ["", "fun ket_zero_k :: \"nat \\<Rightarrow> complex vec\" where\n  \"ket_zero_k 0 = ket_zero\"\n| \"ket_zero_k (Suc k) = ptensor_vec dims {0..<(Suc k)} {Suc k} (ket_zero_k k) ket_zero\""], ["", "lemma ket_zero_k_dim:\n  assumes \"k < n\"\n  shows \"ket_zero_k k \\<in> carrier_vec (2^(Suc k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ket_zero_k k \\<in> carrier_vec (2 ^ Suc k)", "proof (cases k)"], ["proof (state)\ngoal (2 subgoals):\n 1. k = 0 \\<Longrightarrow> ket_zero_k k \\<in> carrier_vec (2 ^ Suc k)\n 2. \\<And>nat.\n       k = Suc nat \\<Longrightarrow>\n       ket_zero_k k \\<in> carrier_vec (2 ^ Suc k)", "case 0"], ["proof (state)\nthis:\n  k = 0\n\ngoal (2 subgoals):\n 1. k = 0 \\<Longrightarrow> ket_zero_k k \\<in> carrier_vec (2 ^ Suc k)\n 2. \\<And>nat.\n       k = Suc nat \\<Longrightarrow>\n       ket_zero_k k \\<in> carrier_vec (2 ^ Suc k)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. ket_zero_k k \\<in> carrier_vec (2 ^ Suc k)", "using ket_zero_dim 0"], ["proof (prove)\nusing this:\n  ket_zero \\<in> carrier_vec 2\n  k = 0\n\ngoal (1 subgoal):\n 1. ket_zero_k k \\<in> carrier_vec (2 ^ Suc k)", "by auto"], ["proof (state)\nthis:\n  ket_zero_k k \\<in> carrier_vec (2 ^ Suc k)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       k = Suc nat \\<Longrightarrow>\n       ket_zero_k k \\<in> carrier_vec (2 ^ Suc k)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       k = Suc nat \\<Longrightarrow>\n       ket_zero_k k \\<in> carrier_vec (2 ^ Suc k)", "case (Suc k)"], ["proof (state)\nthis:\n  k = Suc k\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       k = Suc nat \\<Longrightarrow>\n       ket_zero_k k \\<in> carrier_vec (2 ^ Suc k)", "interpret st: partial_state2 dims \"{0..<(Suc k)}\" \"{Suc k}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. partial_state2 {0..<Suc k} {Suc k}", "apply unfold_locales"], ["proof (prove)\ngoal (1 subgoal):\n 1. {0..<Suc k} \\<inter> {Suc k} = {}", "by auto"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       k = Suc nat \\<Longrightarrow>\n       ket_zero_k k \\<in> carrier_vec (2 ^ Suc k)", "have \"Suc (Suc k) \\<le> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc (Suc k) \\<le> n", "using assms Suc"], ["proof (prove)\nusing this:\n  k < n\n  k = Suc k\n\ngoal (1 subgoal):\n 1. Suc (Suc k) \\<le> n", "by auto"], ["proof (state)\nthis:\n  Suc (Suc k) \\<le> n\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       k = Suc nat \\<Longrightarrow>\n       ket_zero_k k \\<in> carrier_vec (2 ^ Suc k)", "then"], ["proof (chain)\npicking this:\n  Suc (Suc k) \\<le> n", "have \"nths dims ({0..<Suc (Suc k)}) = replicate (Suc (Suc k)) 2\""], ["proof (prove)\nusing this:\n  Suc (Suc k) \\<le> n\n\ngoal (1 subgoal):\n 1. nths dims {0..<Suc (Suc k)} = replicate (Suc (Suc k)) 2", "using dims_nths_le_n"], ["proof (prove)\nusing this:\n  Suc (Suc k) \\<le> n\n  ?l \\<le> n \\<Longrightarrow> nths dims {0..<?l} = replicate ?l 2\n\ngoal (1 subgoal):\n 1. nths dims {0..<Suc (Suc k)} = replicate (Suc (Suc k)) 2", "by auto"], ["proof (state)\nthis:\n  nths dims {0..<Suc (Suc k)} = replicate (Suc (Suc k)) 2\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       k = Suc nat \\<Longrightarrow>\n       ket_zero_k k \\<in> carrier_vec (2 ^ Suc k)", "moreover"], ["proof (state)\nthis:\n  nths dims {0..<Suc (Suc k)} = replicate (Suc (Suc k)) 2\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       k = Suc nat \\<Longrightarrow>\n       ket_zero_k k \\<in> carrier_vec (2 ^ Suc k)", "have \"prod_list (replicate l 2) = 2^l\" for l"], ["proof (prove)\ngoal (1 subgoal):\n 1. prod_list (replicate l (2::'a)) = (2::'a) ^ l", "by simp"], ["proof (state)\nthis:\n  prod_list (replicate ?l3 (2::?'a4)) = (2::?'a4) ^ ?l3\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       k = Suc nat \\<Longrightarrow>\n       ket_zero_k k \\<in> carrier_vec (2 ^ Suc k)", "moreover"], ["proof (state)\nthis:\n  prod_list (replicate ?l3 (2::?'a4)) = (2::?'a4) ^ ?l3\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       k = Suc nat \\<Longrightarrow>\n       ket_zero_k k \\<in> carrier_vec (2 ^ Suc k)", "have \"{0..<Suc k} \\<union> {Suc k} = {0..<(Suc (Suc k))}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {0..<Suc k} \\<union> {Suc k} = {0..<Suc (Suc k)}", "by auto"], ["proof (state)\nthis:\n  {0..<Suc k} \\<union> {Suc k} = {0..<Suc (Suc k)}\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       k = Suc nat \\<Longrightarrow>\n       ket_zero_k k \\<in> carrier_vec (2 ^ Suc k)", "ultimately"], ["proof (chain)\npicking this:\n  nths dims {0..<Suc (Suc k)} = replicate (Suc (Suc k)) 2\n  prod_list (replicate ?l3 (2::?'a4)) = (2::?'a4) ^ ?l3\n  {0..<Suc k} \\<union> {Suc k} = {0..<Suc (Suc k)}", "have plssk: \"prod_list (nths dims ({0..<Suc k} \\<union> {Suc k})) = 2^(Suc (Suc k))\""], ["proof (prove)\nusing this:\n  nths dims {0..<Suc (Suc k)} = replicate (Suc (Suc k)) 2\n  prod_list (replicate ?l3 (2::?'a4)) = (2::?'a4) ^ ?l3\n  {0..<Suc k} \\<union> {Suc k} = {0..<Suc (Suc k)}\n\ngoal (1 subgoal):\n 1. prod_list (nths dims ({0..<Suc k} \\<union> {Suc k})) = 2 ^ Suc (Suc k)", "by auto"], ["proof (state)\nthis:\n  prod_list (nths dims ({0..<Suc k} \\<union> {Suc k})) = 2 ^ Suc (Suc k)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       k = Suc nat \\<Longrightarrow>\n       ket_zero_k k \\<in> carrier_vec (2 ^ Suc k)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. ket_zero_k k \\<in> carrier_vec (2 ^ Suc k)", "apply (rule carrier_vecI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_vec (ket_zero_k k) = 2 ^ Suc k", "unfolding ket_zero_k.simps Suc"], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_vec (st.ptensor_vec (ket_zero_k k) ket_zero) = 2 ^ Suc (Suc k)", "using st.ptensor_vec_dim[of \"ket_zero_k k\" ket_zero] plssk"], ["proof (prove)\nusing this:\n  dim_vec (st.ptensor_vec (ket_zero_k k) ket_zero) = st.d0\n  prod_list (nths dims ({0..<Suc k} \\<union> {Suc k})) = 2 ^ Suc (Suc k)\n\ngoal (1 subgoal):\n 1. dim_vec (st.ptensor_vec (ket_zero_k k) ket_zero) = 2 ^ Suc (Suc k)", "unfolding st.d0_def st.dims0_def st.vars0_def"], ["proof (prove)\nusing this:\n  dim_vec (st.ptensor_vec (ket_zero_k k) ket_zero) =\n  prod_list (nths dims ({0..<Suc k} \\<union> {Suc k}))\n  prod_list (nths dims ({0..<Suc k} \\<union> {Suc k})) = 2 ^ Suc (Suc k)\n\ngoal (1 subgoal):\n 1. dim_vec (st.ptensor_vec (ket_zero_k k) ket_zero) = 2 ^ Suc (Suc k)", "by auto"], ["proof (state)\nthis:\n  ket_zero_k k \\<in> carrier_vec (2 ^ Suc k)\n\ngoal:\nNo subgoals!", "qed"], ["", "fun ket_plus_k where\n  \"ket_plus_k 0 = ket_plus\"\n| \"ket_plus_k (Suc k) = ptensor_vec dims {0..<(Suc k)} {Suc k} (ket_plus_k k) ket_plus\""], ["", "lemma ket_plus_k_dim:\n  assumes \"k < n\"\n  shows \"ket_plus_k k \\<in> carrier_vec (2^(Suc k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ket_plus_k k \\<in> carrier_vec (2 ^ Suc k)", "proof (cases k)"], ["proof (state)\ngoal (2 subgoals):\n 1. k = 0 \\<Longrightarrow> ket_plus_k k \\<in> carrier_vec (2 ^ Suc k)\n 2. \\<And>nat.\n       k = Suc nat \\<Longrightarrow>\n       ket_plus_k k \\<in> carrier_vec (2 ^ Suc k)", "case 0"], ["proof (state)\nthis:\n  k = 0\n\ngoal (2 subgoals):\n 1. k = 0 \\<Longrightarrow> ket_plus_k k \\<in> carrier_vec (2 ^ Suc k)\n 2. \\<And>nat.\n       k = Suc nat \\<Longrightarrow>\n       ket_plus_k k \\<in> carrier_vec (2 ^ Suc k)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. ket_plus_k k \\<in> carrier_vec (2 ^ Suc k)", "using ket_plus_dim 0"], ["proof (prove)\nusing this:\n  ket_plus \\<in> carrier_vec 2\n  k = 0\n\ngoal (1 subgoal):\n 1. ket_plus_k k \\<in> carrier_vec (2 ^ Suc k)", "by auto"], ["proof (state)\nthis:\n  ket_plus_k k \\<in> carrier_vec (2 ^ Suc k)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       k = Suc nat \\<Longrightarrow>\n       ket_plus_k k \\<in> carrier_vec (2 ^ Suc k)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       k = Suc nat \\<Longrightarrow>\n       ket_plus_k k \\<in> carrier_vec (2 ^ Suc k)", "case (Suc k)"], ["proof (state)\nthis:\n  k = Suc k\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       k = Suc nat \\<Longrightarrow>\n       ket_plus_k k \\<in> carrier_vec (2 ^ Suc k)", "interpret st: partial_state2 dims \"{0..<(Suc k)}\" \"{Suc k}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. partial_state2 {0..<Suc k} {Suc k}", "apply unfold_locales"], ["proof (prove)\ngoal (1 subgoal):\n 1. {0..<Suc k} \\<inter> {Suc k} = {}", "by auto"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       k = Suc nat \\<Longrightarrow>\n       ket_plus_k k \\<in> carrier_vec (2 ^ Suc k)", "have \"Suc (Suc k) \\<le> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc (Suc k) \\<le> n", "using assms Suc"], ["proof (prove)\nusing this:\n  k < n\n  k = Suc k\n\ngoal (1 subgoal):\n 1. Suc (Suc k) \\<le> n", "by auto"], ["proof (state)\nthis:\n  Suc (Suc k) \\<le> n\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       k = Suc nat \\<Longrightarrow>\n       ket_plus_k k \\<in> carrier_vec (2 ^ Suc k)", "then"], ["proof (chain)\npicking this:\n  Suc (Suc k) \\<le> n", "have \"nths dims ({0..<Suc (Suc k)}) = replicate (Suc (Suc k)) 2\""], ["proof (prove)\nusing this:\n  Suc (Suc k) \\<le> n\n\ngoal (1 subgoal):\n 1. nths dims {0..<Suc (Suc k)} = replicate (Suc (Suc k)) 2", "using dims_nths_le_n"], ["proof (prove)\nusing this:\n  Suc (Suc k) \\<le> n\n  ?l \\<le> n \\<Longrightarrow> nths dims {0..<?l} = replicate ?l 2\n\ngoal (1 subgoal):\n 1. nths dims {0..<Suc (Suc k)} = replicate (Suc (Suc k)) 2", "by auto"], ["proof (state)\nthis:\n  nths dims {0..<Suc (Suc k)} = replicate (Suc (Suc k)) 2\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       k = Suc nat \\<Longrightarrow>\n       ket_plus_k k \\<in> carrier_vec (2 ^ Suc k)", "moreover"], ["proof (state)\nthis:\n  nths dims {0..<Suc (Suc k)} = replicate (Suc (Suc k)) 2\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       k = Suc nat \\<Longrightarrow>\n       ket_plus_k k \\<in> carrier_vec (2 ^ Suc k)", "have \"prod_list (replicate l 2) = 2^l\" for l"], ["proof (prove)\ngoal (1 subgoal):\n 1. prod_list (replicate l (2::'a)) = (2::'a) ^ l", "by simp"], ["proof (state)\nthis:\n  prod_list (replicate ?l3 (2::?'a4)) = (2::?'a4) ^ ?l3\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       k = Suc nat \\<Longrightarrow>\n       ket_plus_k k \\<in> carrier_vec (2 ^ Suc k)", "moreover"], ["proof (state)\nthis:\n  prod_list (replicate ?l3 (2::?'a4)) = (2::?'a4) ^ ?l3\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       k = Suc nat \\<Longrightarrow>\n       ket_plus_k k \\<in> carrier_vec (2 ^ Suc k)", "have \"{0..<Suc k} \\<union> {Suc k} = {0..<(Suc (Suc k))}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {0..<Suc k} \\<union> {Suc k} = {0..<Suc (Suc k)}", "by auto"], ["proof (state)\nthis:\n  {0..<Suc k} \\<union> {Suc k} = {0..<Suc (Suc k)}\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       k = Suc nat \\<Longrightarrow>\n       ket_plus_k k \\<in> carrier_vec (2 ^ Suc k)", "ultimately"], ["proof (chain)\npicking this:\n  nths dims {0..<Suc (Suc k)} = replicate (Suc (Suc k)) 2\n  prod_list (replicate ?l3 (2::?'a4)) = (2::?'a4) ^ ?l3\n  {0..<Suc k} \\<union> {Suc k} = {0..<Suc (Suc k)}", "have plssk: \"prod_list (nths dims ({0..<Suc k} \\<union> {Suc k})) = 2^(Suc (Suc k))\""], ["proof (prove)\nusing this:\n  nths dims {0..<Suc (Suc k)} = replicate (Suc (Suc k)) 2\n  prod_list (replicate ?l3 (2::?'a4)) = (2::?'a4) ^ ?l3\n  {0..<Suc k} \\<union> {Suc k} = {0..<Suc (Suc k)}\n\ngoal (1 subgoal):\n 1. prod_list (nths dims ({0..<Suc k} \\<union> {Suc k})) = 2 ^ Suc (Suc k)", "by auto"], ["proof (state)\nthis:\n  prod_list (nths dims ({0..<Suc k} \\<union> {Suc k})) = 2 ^ Suc (Suc k)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       k = Suc nat \\<Longrightarrow>\n       ket_plus_k k \\<in> carrier_vec (2 ^ Suc k)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. ket_plus_k k \\<in> carrier_vec (2 ^ Suc k)", "apply (rule carrier_vecI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_vec (ket_plus_k k) = 2 ^ Suc k", "unfolding ket_zero_k.simps Suc"], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_vec (ket_plus_k (Suc k)) = 2 ^ Suc (Suc k)", "using st.ptensor_vec_dim plssk"], ["proof (prove)\nusing this:\n  dim_vec (st.ptensor_vec ?v1.0 ?v2.0) = st.d0\n  prod_list (nths dims ({0..<Suc k} \\<union> {Suc k})) = 2 ^ Suc (Suc k)\n\ngoal (1 subgoal):\n 1. dim_vec (ket_plus_k (Suc k)) = 2 ^ Suc (Suc k)", "unfolding st.d0_def st.dims0_def st.vars0_def"], ["proof (prove)\nusing this:\n  dim_vec (st.ptensor_vec ?v1.0 ?v2.0) =\n  prod_list (nths dims ({0..<Suc k} \\<union> {Suc k}))\n  prod_list (nths dims ({0..<Suc k} \\<union> {Suc k})) = 2 ^ Suc (Suc k)\n\ngoal (1 subgoal):\n 1. dim_vec (ket_plus_k (Suc k)) = 2 ^ Suc (Suc k)", "by auto"], ["proof (state)\nthis:\n  ket_plus_k k \\<in> carrier_vec (2 ^ Suc k)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma H_k_ket_zero_k:\n  \"k < n \\<Longrightarrow> (H_k k) *\\<^sub>v (ket_zero_k k) = (ket_plus_k k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k < n \\<Longrightarrow> H_k k *\\<^sub>v ket_zero_k k = ket_plus_k k", "proof (induct k)"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 < n \\<Longrightarrow> H_k 0 *\\<^sub>v ket_zero_k 0 = ket_plus_k 0\n 2. \\<And>k.\n       \\<lbrakk>k < n \\<Longrightarrow>\n                H_k k *\\<^sub>v ket_zero_k k = ket_plus_k k;\n        Suc k < n\\<rbrakk>\n       \\<Longrightarrow> H_k (Suc k) *\\<^sub>v ket_zero_k (Suc k) =\n                         ket_plus_k (Suc k)", "case 0"], ["proof (state)\nthis:\n  0 < n\n\ngoal (2 subgoals):\n 1. 0 < n \\<Longrightarrow> H_k 0 *\\<^sub>v ket_zero_k 0 = ket_plus_k 0\n 2. \\<And>k.\n       \\<lbrakk>k < n \\<Longrightarrow>\n                H_k k *\\<^sub>v ket_zero_k k = ket_plus_k k;\n        Suc k < n\\<rbrakk>\n       \\<Longrightarrow> H_k (Suc k) *\\<^sub>v ket_zero_k (Suc k) =\n                         ket_plus_k (Suc k)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. H_k 0 *\\<^sub>v ket_zero_k 0 = ket_plus_k 0", "using hadamard_on_zero"], ["proof (prove)\nusing this:\n  hadamard *\\<^sub>v ket_zero = ket_plus\n\ngoal (1 subgoal):\n 1. H_k 0 *\\<^sub>v ket_zero_k 0 = ket_plus_k 0", "unfolding H_k.simps ket_zero_k.simps ket_plus_k.simps"], ["proof (prove)\nusing this:\n  hadamard *\\<^sub>v ket_zero = ket_plus\n\ngoal (1 subgoal):\n 1. hadamard *\\<^sub>v ket_zero = ket_plus", "by auto"], ["proof (state)\nthis:\n  H_k 0 *\\<^sub>v ket_zero_k 0 = ket_plus_k 0\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < n \\<Longrightarrow>\n                H_k k *\\<^sub>v ket_zero_k k = ket_plus_k k;\n        Suc k < n\\<rbrakk>\n       \\<Longrightarrow> H_k (Suc k) *\\<^sub>v ket_zero_k (Suc k) =\n                         ket_plus_k (Suc k)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < n \\<Longrightarrow>\n                H_k k *\\<^sub>v ket_zero_k k = ket_plus_k k;\n        Suc k < n\\<rbrakk>\n       \\<Longrightarrow> H_k (Suc k) *\\<^sub>v ket_zero_k (Suc k) =\n                         ket_plus_k (Suc k)", "case (Suc k)"], ["proof (state)\nthis:\n  k < n \\<Longrightarrow> H_k k *\\<^sub>v ket_zero_k k = ket_plus_k k\n  Suc k < n\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < n \\<Longrightarrow>\n                H_k k *\\<^sub>v ket_zero_k k = ket_plus_k k;\n        Suc k < n\\<rbrakk>\n       \\<Longrightarrow> H_k (Suc k) *\\<^sub>v ket_zero_k (Suc k) =\n                         ket_plus_k (Suc k)", "then"], ["proof (chain)\npicking this:\n  k < n \\<Longrightarrow> H_k k *\\<^sub>v ket_zero_k k = ket_plus_k k\n  Suc k < n", "have k: \"k < n\""], ["proof (prove)\nusing this:\n  k < n \\<Longrightarrow> H_k k *\\<^sub>v ket_zero_k k = ket_plus_k k\n  Suc k < n\n\ngoal (1 subgoal):\n 1. k < n", "by auto"], ["proof (state)\nthis:\n  k < n\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < n \\<Longrightarrow>\n                H_k k *\\<^sub>v ket_zero_k k = ket_plus_k k;\n        Suc k < n\\<rbrakk>\n       \\<Longrightarrow> H_k (Suc k) *\\<^sub>v ket_zero_k (Suc k) =\n                         ket_plus_k (Suc k)", "interpret st: partial_state2 dims \"{0..<(Suc k)}\" \"{Suc k}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. partial_state2 {0..<Suc k} {Suc k}", "apply unfold_locales"], ["proof (prove)\ngoal (1 subgoal):\n 1. {0..<Suc k} \\<inter> {Suc k} = {}", "by auto"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < n \\<Longrightarrow>\n                H_k k *\\<^sub>v ket_zero_k k = ket_plus_k k;\n        Suc k < n\\<rbrakk>\n       \\<Longrightarrow> H_k (Suc k) *\\<^sub>v ket_zero_k (Suc k) =\n                         ket_plus_k (Suc k)", "have \"nths dims {0..<Suc k} = replicate (Suc k) 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nths dims {0..<Suc k} = replicate (Suc k) 2", "using dims_nths_le_n Suc"], ["proof (prove)\nusing this:\n  ?l \\<le> n \\<Longrightarrow> nths dims {0..<?l} = replicate ?l 2\n  k < n \\<Longrightarrow> H_k k *\\<^sub>v ket_zero_k k = ket_plus_k k\n  Suc k < n\n\ngoal (1 subgoal):\n 1. nths dims {0..<Suc k} = replicate (Suc k) 2", "by auto"], ["proof (state)\nthis:\n  nths dims {0..<Suc k} = replicate (Suc k) 2\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < n \\<Longrightarrow>\n                H_k k *\\<^sub>v ket_zero_k k = ket_plus_k k;\n        Suc k < n\\<rbrakk>\n       \\<Longrightarrow> H_k (Suc k) *\\<^sub>v ket_zero_k (Suc k) =\n                         ket_plus_k (Suc k)", "then"], ["proof (chain)\npicking this:\n  nths dims {0..<Suc k} = replicate (Suc k) 2", "have std1: \"st.d1 = 2^(Suc k)\""], ["proof (prove)\nusing this:\n  nths dims {0..<Suc k} = replicate (Suc k) 2\n\ngoal (1 subgoal):\n 1. st.d1 = 2 ^ Suc k", "unfolding st.d1_def st.dims1_def"], ["proof (prove)\nusing this:\n  nths dims {0..<Suc k} = replicate (Suc k) 2\n\ngoal (1 subgoal):\n 1. prod_list (nths dims {0..<Suc k}) = 2 ^ Suc k", "by auto"], ["proof (state)\nthis:\n  st.d1 = 2 ^ Suc k\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < n \\<Longrightarrow>\n                H_k k *\\<^sub>v ket_zero_k k = ket_plus_k k;\n        Suc k < n\\<rbrakk>\n       \\<Longrightarrow> H_k (Suc k) *\\<^sub>v ket_zero_k (Suc k) =\n                         ket_plus_k (Suc k)", "have std2: \"st.d2 = 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. st.d2 = 2", "unfolding st.d2_def st.dims2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. prod_list (nths dims {Suc k}) = 2", "using dims_nths_one_lt_n Suc"], ["proof (prove)\nusing this:\n  ?l < n \\<Longrightarrow> nths dims {?l} = [2]\n  k < n \\<Longrightarrow> H_k k *\\<^sub>v ket_zero_k k = ket_plus_k k\n  Suc k < n\n\ngoal (1 subgoal):\n 1. prod_list (nths dims {Suc k}) = 2", "by auto"], ["proof (state)\nthis:\n  st.d2 = 2\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < n \\<Longrightarrow>\n                H_k k *\\<^sub>v ket_zero_k k = ket_plus_k k;\n        Suc k < n\\<rbrakk>\n       \\<Longrightarrow> H_k (Suc k) *\\<^sub>v ket_zero_k (Suc k) =\n                         ket_plus_k (Suc k)", "have \"H_k (Suc k) *\\<^sub>v ket_zero_k (Suc k) = st.ptensor_mat (H_k k) hadamard *\\<^sub>v st.ptensor_vec (ket_zero_k k) ket_zero\""], ["proof (prove)\ngoal (1 subgoal):\n 1. H_k (Suc k) *\\<^sub>v ket_zero_k (Suc k) =\n    st.ptensor_mat (H_k k) hadamard *\\<^sub>v\n    st.ptensor_vec (ket_zero_k k) ket_zero", "by auto"], ["proof (state)\nthis:\n  H_k (Suc k) *\\<^sub>v ket_zero_k (Suc k) =\n  st.ptensor_mat (H_k k) hadamard *\\<^sub>v\n  st.ptensor_vec (ket_zero_k k) ket_zero\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < n \\<Longrightarrow>\n                H_k k *\\<^sub>v ket_zero_k k = ket_plus_k k;\n        Suc k < n\\<rbrakk>\n       \\<Longrightarrow> H_k (Suc k) *\\<^sub>v ket_zero_k (Suc k) =\n                         ket_plus_k (Suc k)", "also"], ["proof (state)\nthis:\n  H_k (Suc k) *\\<^sub>v ket_zero_k (Suc k) =\n  st.ptensor_mat (H_k k) hadamard *\\<^sub>v\n  st.ptensor_vec (ket_zero_k k) ket_zero\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < n \\<Longrightarrow>\n                H_k k *\\<^sub>v ket_zero_k k = ket_plus_k k;\n        Suc k < n\\<rbrakk>\n       \\<Longrightarrow> H_k (Suc k) *\\<^sub>v ket_zero_k (Suc k) =\n                         ket_plus_k (Suc k)", "have \"\\<dots> = st.ptensor_vec ((H_k k) *\\<^sub>v (ket_zero_k k)) (hadamard *\\<^sub>v ket_zero)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. st.ptensor_mat (H_k k) hadamard *\\<^sub>v\n    st.ptensor_vec (ket_zero_k k) ket_zero =\n    st.ptensor_vec (H_k k *\\<^sub>v ket_zero_k k)\n     (hadamard *\\<^sub>v ket_zero)", "using st.ptensor_mat_mult_vec[unfolded std1 std2, OF H_k_dim[OF k] ket_zero_k_dim[OF k] hadamard_dim ket_zero_dim]"], ["proof (prove)\nusing this:\n  st.ptensor_vec (H_k k *\\<^sub>v ket_zero_k k)\n   (hadamard *\\<^sub>v ket_zero) =\n  st.ptensor_mat (H_k k) hadamard *\\<^sub>v\n  st.ptensor_vec (ket_zero_k k) ket_zero\n\ngoal (1 subgoal):\n 1. st.ptensor_mat (H_k k) hadamard *\\<^sub>v\n    st.ptensor_vec (ket_zero_k k) ket_zero =\n    st.ptensor_vec (H_k k *\\<^sub>v ket_zero_k k)\n     (hadamard *\\<^sub>v ket_zero)", "by auto"], ["proof (state)\nthis:\n  st.ptensor_mat (H_k k) hadamard *\\<^sub>v\n  st.ptensor_vec (ket_zero_k k) ket_zero =\n  st.ptensor_vec (H_k k *\\<^sub>v ket_zero_k k)\n   (hadamard *\\<^sub>v ket_zero)\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < n \\<Longrightarrow>\n                H_k k *\\<^sub>v ket_zero_k k = ket_plus_k k;\n        Suc k < n\\<rbrakk>\n       \\<Longrightarrow> H_k (Suc k) *\\<^sub>v ket_zero_k (Suc k) =\n                         ket_plus_k (Suc k)", "also"], ["proof (state)\nthis:\n  st.ptensor_mat (H_k k) hadamard *\\<^sub>v\n  st.ptensor_vec (ket_zero_k k) ket_zero =\n  st.ptensor_vec (H_k k *\\<^sub>v ket_zero_k k)\n   (hadamard *\\<^sub>v ket_zero)\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < n \\<Longrightarrow>\n                H_k k *\\<^sub>v ket_zero_k k = ket_plus_k k;\n        Suc k < n\\<rbrakk>\n       \\<Longrightarrow> H_k (Suc k) *\\<^sub>v ket_zero_k (Suc k) =\n                         ket_plus_k (Suc k)", "have \"\\<dots> = st.ptensor_vec (ket_plus_k k) ket_plus\""], ["proof (prove)\ngoal (1 subgoal):\n 1. st.ptensor_vec (H_k k *\\<^sub>v ket_zero_k k)\n     (hadamard *\\<^sub>v ket_zero) =\n    st.ptensor_vec (ket_plus_k k) ket_plus", "using Suc hadamard_on_zero"], ["proof (prove)\nusing this:\n  k < n \\<Longrightarrow> H_k k *\\<^sub>v ket_zero_k k = ket_plus_k k\n  Suc k < n\n  hadamard *\\<^sub>v ket_zero = ket_plus\n\ngoal (1 subgoal):\n 1. st.ptensor_vec (H_k k *\\<^sub>v ket_zero_k k)\n     (hadamard *\\<^sub>v ket_zero) =\n    st.ptensor_vec (ket_plus_k k) ket_plus", "by auto"], ["proof (state)\nthis:\n  st.ptensor_vec (H_k k *\\<^sub>v ket_zero_k k)\n   (hadamard *\\<^sub>v ket_zero) =\n  st.ptensor_vec (ket_plus_k k) ket_plus\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < n \\<Longrightarrow>\n                H_k k *\\<^sub>v ket_zero_k k = ket_plus_k k;\n        Suc k < n\\<rbrakk>\n       \\<Longrightarrow> H_k (Suc k) *\\<^sub>v ket_zero_k (Suc k) =\n                         ket_plus_k (Suc k)", "finally"], ["proof (chain)\npicking this:\n  H_k (Suc k) *\\<^sub>v ket_zero_k (Suc k) =\n  st.ptensor_vec (ket_plus_k k) ket_plus", "show ?case"], ["proof (prove)\nusing this:\n  H_k (Suc k) *\\<^sub>v ket_zero_k (Suc k) =\n  st.ptensor_vec (ket_plus_k k) ket_plus\n\ngoal (1 subgoal):\n 1. H_k (Suc k) *\\<^sub>v ket_zero_k (Suc k) = ket_plus_k (Suc k)", "by auto"], ["proof (state)\nthis:\n  H_k (Suc k) *\\<^sub>v ket_zero_k (Suc k) = ket_plus_k (Suc k)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma encode1_replicate_2:\n  \"partial_state.encode1 (replicate (Suc k) 2) {0..<k} i = i mod (2 ^ k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. partial_state.encode1 (replicate (Suc k) 2) {0..<k} i = i mod 2 ^ k", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. partial_state.encode1 (replicate (Suc k) 2) {0..<k} i = i mod 2 ^ k", "have take_Suc: \"take k (replicate (Suc k) 2) = replicate k 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. take k (replicate (Suc k) (2::'a)) = replicate k (2::'a)", "apply (subst take_replicate)"], ["proof (prove)\ngoal (1 subgoal):\n 1. replicate (min k (Suc k)) (2::'a) = replicate k (2::'a)", "by auto"], ["proof (state)\nthis:\n  take k (replicate (Suc k) (2::?'a3)) = replicate k (2::?'a3)\n\ngoal (1 subgoal):\n 1. partial_state.encode1 (replicate (Suc k) 2) {0..<k} i = i mod 2 ^ k", "have take_encode: \"take k (digit_encode (replicate (Suc k) 2) i) = digit_encode (replicate k 2) i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. take k (digit_encode (replicate (Suc k) 2) i) =\n    digit_encode (replicate k 2) i", "apply (subst digit_encode_take)"], ["proof (prove)\ngoal (1 subgoal):\n 1. digit_encode (take k (replicate (Suc k) 2)) i =\n    digit_encode (replicate k 2) i", "using take_Suc"], ["proof (prove)\nusing this:\n  take k (replicate (Suc k) (2::?'a3)) = replicate k (2::?'a3)\n\ngoal (1 subgoal):\n 1. digit_encode (take k (replicate (Suc k) 2)) i =\n    digit_encode (replicate k 2) i", "by metis"], ["proof (state)\nthis:\n  take k (digit_encode (replicate (Suc k) 2) i) =\n  digit_encode (replicate k 2) i\n\ngoal (1 subgoal):\n 1. partial_state.encode1 (replicate (Suc k) 2) {0..<k} i = i mod 2 ^ k", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. partial_state.encode1 (replicate (Suc k) 2) {0..<k} i = i mod 2 ^ k", "unfolding partial_state.encode1_def partial_state.dims1_def\n      nths_upt_eq_take[simplified lessThan_atLeast0] take_Suc take_encode\n      digit_decode_encode prod_list_replicate"], ["proof (prove)\ngoal (1 subgoal):\n 1. i mod 2 ^ k = i mod 2 ^ k", ".."], ["proof (state)\nthis:\n  partial_state.encode1 (replicate (Suc k) 2) {0..<k} i = i mod 2 ^ k\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma encode2_replicate_2:\n  assumes \"i < 2 ^ Suc k\"\n  shows \"partial_state.encode2 (replicate (Suc k) 2) {0..<k} i = i div (2 ^ k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. partial_state.encode2 (replicate (Suc k) 2) {0..<k} i = i div 2 ^ k", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. partial_state.encode2 (replicate (Suc k) 2) {0..<k} i = i div 2 ^ k", "have drop_Suc: \"drop k (replicate (Suc k) 2) = [2]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. drop k (replicate (Suc k) (2::'a)) = [2::'a]", "apply (subst drop_replicate)"], ["proof (prove)\ngoal (1 subgoal):\n 1. replicate (Suc k - k) (2::'a) = [2::'a]", "by auto"], ["proof (state)\nthis:\n  drop k (replicate (Suc k) (2::?'a3)) = [2::?'a3]\n\ngoal (1 subgoal):\n 1. partial_state.encode2 (replicate (Suc k) 2) {0..<k} i = i div 2 ^ k", "have drop_encode: \"drop k (digit_encode (replicate (Suc k) 2) i) = digit_encode [2] (i div (2 ^ k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. drop k (digit_encode (replicate (Suc k) 2) i) =\n    digit_encode [2] (i div 2 ^ k)", "unfolding digit_encode_drop drop_Suc take_replicate prod_list_replicate"], ["proof (prove)\ngoal (1 subgoal):\n 1. digit_encode [2] (i div 2 ^ min k (Suc k)) =\n    digit_encode [2] (i div 2 ^ k)", "by (metis lessI min.strict_order_iff)"], ["proof (state)\nthis:\n  drop k (digit_encode (replicate (Suc k) 2) i) =\n  digit_encode [2] (i div 2 ^ k)\n\ngoal (1 subgoal):\n 1. partial_state.encode2 (replicate (Suc k) 2) {0..<k} i = i div 2 ^ k", "have le2: \"i div 2 ^ k < 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i div 2 ^ k < 2", "using assms"], ["proof (prove)\nusing this:\n  i < 2 ^ Suc k\n\ngoal (1 subgoal):\n 1. i div 2 ^ k < 2", "by (auto simp add: less_mult_imp_div_less)"], ["proof (state)\nthis:\n  i div 2 ^ k < 2\n\ngoal (1 subgoal):\n 1. partial_state.encode2 (replicate (Suc k) 2) {0..<k} i = i div 2 ^ k", "have prod_list_2: \"prod_list [2] = 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod_list [2::'a] = (2::'a)", "by simp"], ["proof (state)\nthis:\n  prod_list [2::?'a4] = (2::?'a4)\n\ngoal (1 subgoal):\n 1. partial_state.encode2 (replicate (Suc k) 2) {0..<k} i = i div 2 ^ k", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. partial_state.encode2 (replicate (Suc k) 2) {0..<k} i = i div 2 ^ k", "unfolding partial_state.encode2_def partial_state.dims2_def\n      nths_minus_upt_eq_drop[simplified lessThan_atLeast0] drop_Suc drop_encode\n      digit_decode_encode prod_list_2"], ["proof (prove)\ngoal (1 subgoal):\n 1. i div 2 ^ k mod 2 = i div 2 ^ k", "using le2"], ["proof (prove)\nusing this:\n  i div 2 ^ k < 2\n\ngoal (1 subgoal):\n 1. i div 2 ^ k mod 2 = i div 2 ^ k", "by auto"], ["proof (state)\nthis:\n  partial_state.encode2 (replicate (Suc k) 2) {0..<k} i = i div 2 ^ k\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ket_zero_k_decode:\n  \"k < n \\<Longrightarrow> ket_zero_k k = Matrix.vec (2^(Suc k)) (\\<lambda>k. if k = 0 then 1 else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k < n \\<Longrightarrow>\n    ket_zero_k k =\n    Matrix.vec (2 ^ Suc k) (\\<lambda>k. if k = 0 then 1 else 0)", "proof (induct k)"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 < n \\<Longrightarrow>\n    ket_zero_k 0 =\n    Matrix.vec (2 ^ Suc 0) (\\<lambda>k. if k = 0 then 1 else 0)\n 2. \\<And>k.\n       \\<lbrakk>k < n \\<Longrightarrow>\n                ket_zero_k k =\n                Matrix.vec (2 ^ Suc k) (\\<lambda>k. if k = 0 then 1 else 0);\n        Suc k < n\\<rbrakk>\n       \\<Longrightarrow> ket_zero_k (Suc k) =\n                         Matrix.vec (2 ^ Suc (Suc k))\n                          (\\<lambda>k. if k = 0 then 1 else 0)", "case 0"], ["proof (state)\nthis:\n  0 < n\n\ngoal (2 subgoals):\n 1. 0 < n \\<Longrightarrow>\n    ket_zero_k 0 =\n    Matrix.vec (2 ^ Suc 0) (\\<lambda>k. if k = 0 then 1 else 0)\n 2. \\<And>k.\n       \\<lbrakk>k < n \\<Longrightarrow>\n                ket_zero_k k =\n                Matrix.vec (2 ^ Suc k) (\\<lambda>k. if k = 0 then 1 else 0);\n        Suc k < n\\<rbrakk>\n       \\<Longrightarrow> ket_zero_k (Suc k) =\n                         Matrix.vec (2 ^ Suc (Suc k))\n                          (\\<lambda>k. if k = 0 then 1 else 0)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. ket_zero_k 0 =\n    Matrix.vec (2 ^ Suc 0) (\\<lambda>k. if k = 0 then 1 else 0)", "apply (rule eq_vecI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i.\n       i < dim_vec\n            (Matrix.vec (2 ^ Suc 0)\n              (\\<lambda>k. if k = 0 then 1 else 0)) \\<Longrightarrow>\n       ket_zero_k 0 $ i =\n       Matrix.vec (2 ^ Suc 0) (\\<lambda>k. if k = 0 then 1 else 0) $ i\n 2. dim_vec (ket_zero_k 0) =\n    dim_vec (Matrix.vec (2 ^ Suc 0) (\\<lambda>k. if k = 0 then 1 else 0))", "by (auto simp add: ket_zero_def)"], ["proof (state)\nthis:\n  ket_zero_k 0 = Matrix.vec (2 ^ Suc 0) (\\<lambda>k. if k = 0 then 1 else 0)\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < n \\<Longrightarrow>\n                ket_zero_k k =\n                Matrix.vec (2 ^ Suc k) (\\<lambda>k. if k = 0 then 1 else 0);\n        Suc k < n\\<rbrakk>\n       \\<Longrightarrow> ket_zero_k (Suc k) =\n                         Matrix.vec (2 ^ Suc (Suc k))\n                          (\\<lambda>k. if k = 0 then 1 else 0)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < n \\<Longrightarrow>\n                ket_zero_k k =\n                Matrix.vec (2 ^ Suc k) (\\<lambda>k. if k = 0 then 1 else 0);\n        Suc k < n\\<rbrakk>\n       \\<Longrightarrow> ket_zero_k (Suc k) =\n                         Matrix.vec (2 ^ Suc (Suc k))\n                          (\\<lambda>k. if k = 0 then 1 else 0)", "case (Suc k)"], ["proof (state)\nthis:\n  k < n \\<Longrightarrow>\n  ket_zero_k k = Matrix.vec (2 ^ Suc k) (\\<lambda>k. if k = 0 then 1 else 0)\n  Suc k < n\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < n \\<Longrightarrow>\n                ket_zero_k k =\n                Matrix.vec (2 ^ Suc k) (\\<lambda>k. if k = 0 then 1 else 0);\n        Suc k < n\\<rbrakk>\n       \\<Longrightarrow> ket_zero_k (Suc k) =\n                         Matrix.vec (2 ^ Suc (Suc k))\n                          (\\<lambda>k. if k = 0 then 1 else 0)", "then"], ["proof (chain)\npicking this:\n  k < n \\<Longrightarrow>\n  ket_zero_k k = Matrix.vec (2 ^ Suc k) (\\<lambda>k. if k = 0 then 1 else 0)\n  Suc k < n", "have k: \"k < n\""], ["proof (prove)\nusing this:\n  k < n \\<Longrightarrow>\n  ket_zero_k k = Matrix.vec (2 ^ Suc k) (\\<lambda>k. if k = 0 then 1 else 0)\n  Suc k < n\n\ngoal (1 subgoal):\n 1. k < n", "by auto"], ["proof (state)\nthis:\n  k < n\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < n \\<Longrightarrow>\n                ket_zero_k k =\n                Matrix.vec (2 ^ Suc k) (\\<lambda>k. if k = 0 then 1 else 0);\n        Suc k < n\\<rbrakk>\n       \\<Longrightarrow> ket_zero_k (Suc k) =\n                         Matrix.vec (2 ^ Suc (Suc k))\n                          (\\<lambda>k. if k = 0 then 1 else 0)", "have kzkk: \"ket_zero_k k = Matrix.vec (2 ^ Suc k) (\\<lambda>k. if (k = 0) then 1 else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ket_zero_k k =\n    Matrix.vec (2 ^ Suc k) (\\<lambda>k. if k = 0 then 1 else 0)", "using Suc(1)[OF k]"], ["proof (prove)\nusing this:\n  ket_zero_k k = Matrix.vec (2 ^ Suc k) (\\<lambda>k. if k = 0 then 1 else 0)\n\ngoal (1 subgoal):\n 1. ket_zero_k k =\n    Matrix.vec (2 ^ Suc k) (\\<lambda>k. if k = 0 then 1 else 0)", "by auto"], ["proof (state)\nthis:\n  ket_zero_k k = Matrix.vec (2 ^ Suc k) (\\<lambda>k. if k = 0 then 1 else 0)\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < n \\<Longrightarrow>\n                ket_zero_k k =\n                Matrix.vec (2 ^ Suc k) (\\<lambda>k. if k = 0 then 1 else 0);\n        Suc k < n\\<rbrakk>\n       \\<Longrightarrow> ket_zero_k (Suc k) =\n                         Matrix.vec (2 ^ Suc (Suc k))\n                          (\\<lambda>k. if k = 0 then 1 else 0)", "have dSk: \"ket_zero_k (Suc k) \\<in> carrier_vec (2^(Suc (Suc k)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ket_zero_k (Suc k) \\<in> carrier_vec (2 ^ Suc (Suc k))", "using ket_zero_k_dim[OF Suc(2)]"], ["proof (prove)\nusing this:\n  ket_zero_k (Suc k) \\<in> carrier_vec (2 ^ Suc (Suc k))\n\ngoal (1 subgoal):\n 1. ket_zero_k (Suc k) \\<in> carrier_vec (2 ^ Suc (Suc k))", "by auto"], ["proof (state)\nthis:\n  ket_zero_k (Suc k) \\<in> carrier_vec (2 ^ Suc (Suc k))\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < n \\<Longrightarrow>\n                ket_zero_k k =\n                Matrix.vec (2 ^ Suc k) (\\<lambda>k. if k = 0 then 1 else 0);\n        Suc k < n\\<rbrakk>\n       \\<Longrightarrow> ket_zero_k (Suc k) =\n                         Matrix.vec (2 ^ Suc (Suc k))\n                          (\\<lambda>k. if k = 0 then 1 else 0)", "interpret st: partial_state \"replicate (Suc (Suc k)) 2\" \"{0..<Suc k}\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < n \\<Longrightarrow>\n                ket_zero_k k =\n                Matrix.vec (2 ^ Suc k) (\\<lambda>k. if k = 0 then 1 else 0);\n        Suc k < n\\<rbrakk>\n       \\<Longrightarrow> ket_zero_k (Suc k) =\n                         Matrix.vec (2 ^ Suc (Suc k))\n                          (\\<lambda>k. if k = 0 then 1 else 0)", "interpret st2: partial_state2 dims \"{0..<Suc k}\" \"{Suc k}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. partial_state2 {0..<Suc k} {Suc k}", "by (unfold_locales, auto)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < n \\<Longrightarrow>\n                ket_zero_k k =\n                Matrix.vec (2 ^ Suc k) (\\<lambda>k. if k = 0 then 1 else 0);\n        Suc k < n\\<rbrakk>\n       \\<Longrightarrow> ket_zero_k (Suc k) =\n                         Matrix.vec (2 ^ Suc (Suc k))\n                          (\\<lambda>k. if k = 0 then 1 else 0)", "have splitset: \"({0..<Suc k} \\<union> {Suc k}) = {0..<Suc (Suc k)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {0..<Suc k} \\<union> {Suc k} = {0..<Suc (Suc k)}", "by auto"], ["proof (state)\nthis:\n  {0..<Suc k} \\<union> {Suc k} = {0..<Suc (Suc k)}\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < n \\<Longrightarrow>\n                ket_zero_k k =\n                Matrix.vec (2 ^ Suc k) (\\<lambda>k. if k = 0 then 1 else 0);\n        Suc k < n\\<rbrakk>\n       \\<Longrightarrow> ket_zero_k (Suc k) =\n                         Matrix.vec (2 ^ Suc (Suc k))\n                          (\\<lambda>k. if k = 0 then 1 else 0)", "then"], ["proof (chain)\npicking this:\n  {0..<Suc k} \\<union> {Suc k} = {0..<Suc (Suc k)}", "have st2dims0: \"st2.dims0 = replicate (Suc (Suc k)) 2\""], ["proof (prove)\nusing this:\n  {0..<Suc k} \\<union> {Suc k} = {0..<Suc (Suc k)}\n\ngoal (1 subgoal):\n 1. st2.dims0 = replicate (Suc (Suc k)) 2", "unfolding st2.dims0_def st2.vars0_def"], ["proof (prove)\nusing this:\n  {0..<Suc k} \\<union> {Suc k} = {0..<Suc (Suc k)}\n\ngoal (1 subgoal):\n 1. nths dims ({0..<Suc k} \\<union> {Suc k}) = replicate (Suc (Suc k)) 2", "using dims_nths_le_n[of \"Suc (Suc k)\"] Suc"], ["proof (prove)\nusing this:\n  {0..<Suc k} \\<union> {Suc k} = {0..<Suc (Suc k)}\n  Suc (Suc k) \\<le> n \\<Longrightarrow>\n  nths dims {0..<Suc (Suc k)} = replicate (Suc (Suc k)) 2\n  k < n \\<Longrightarrow>\n  ket_zero_k k = Matrix.vec (2 ^ Suc k) (\\<lambda>k. if k = 0 then 1 else 0)\n  Suc k < n\n\ngoal (1 subgoal):\n 1. nths dims ({0..<Suc k} \\<union> {Suc k}) = replicate (Suc (Suc k)) 2", "by auto"], ["proof (state)\nthis:\n  st2.dims0 = replicate (Suc (Suc k)) 2\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < n \\<Longrightarrow>\n                ket_zero_k k =\n                Matrix.vec (2 ^ Suc k) (\\<lambda>k. if k = 0 then 1 else 0);\n        Suc k < n\\<rbrakk>\n       \\<Longrightarrow> ket_zero_k (Suc k) =\n                         Matrix.vec (2 ^ Suc (Suc k))\n                          (\\<lambda>k. if k = 0 then 1 else 0)", "have \"\\<And>x. (x \\<in> {0..<Suc k} \\<Longrightarrow> {y \\<in> {0..<Suc (Suc k)}. y < x} = {0..<x})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0..<Suc k} \\<Longrightarrow>\n       {y \\<in> {0..<Suc (Suc k)}. y < x} = {0..<x}", "by auto"], ["proof (state)\nthis:\n  ?x2 \\<in> {0..<Suc k} \\<Longrightarrow>\n  {y \\<in> {0..<Suc (Suc k)}. y < ?x2} = {0..<?x2}\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < n \\<Longrightarrow>\n                ket_zero_k k =\n                Matrix.vec (2 ^ Suc k) (\\<lambda>k. if k = 0 then 1 else 0);\n        Suc k < n\\<rbrakk>\n       \\<Longrightarrow> ket_zero_k (Suc k) =\n                         Matrix.vec (2 ^ Suc (Suc k))\n                          (\\<lambda>k. if k = 0 then 1 else 0)", "then"], ["proof (chain)\npicking this:\n  ?x2 \\<in> {0..<Suc k} \\<Longrightarrow>\n  {y \\<in> {0..<Suc (Suc k)}. y < ?x2} = {0..<?x2}", "have cardeq: \"\\<And>x. (x \\<in> {0..<Suc k} \\<Longrightarrow> card {y \\<in> {0..<Suc (Suc k)}. y < x} = card {0..<x})\""], ["proof (prove)\nusing this:\n  ?x2 \\<in> {0..<Suc k} \\<Longrightarrow>\n  {y \\<in> {0..<Suc (Suc k)}. y < ?x2} = {0..<?x2}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0..<Suc k} \\<Longrightarrow>\n       card {y \\<in> {0..<Suc (Suc k)}. y < x} = card {0..<x}", "by auto"], ["proof (state)\nthis:\n  ?x2 \\<in> {0..<Suc k} \\<Longrightarrow>\n  card {y \\<in> {0..<Suc (Suc k)}. y < ?x2} = card {0..<?x2}\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < n \\<Longrightarrow>\n                ket_zero_k k =\n                Matrix.vec (2 ^ Suc k) (\\<lambda>k. if k = 0 then 1 else 0);\n        Suc k < n\\<rbrakk>\n       \\<Longrightarrow> ket_zero_k (Suc k) =\n                         Matrix.vec (2 ^ Suc (Suc k))\n                          (\\<lambda>k. if k = 0 then 1 else 0)", "have setcong: \"\\<And>g h I. (\\<And>x. (x \\<in> I \\<Longrightarrow> g x = h x)) \\<Longrightarrow> {g x | x. x \\<in> I} = {h x | x. x \\<in> I}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>g h I.\n       (\\<And>x. x \\<in> I \\<Longrightarrow> g x = h x) \\<Longrightarrow>\n       {g x |x. x \\<in> I} = {h x |x. x \\<in> I}", "by metis"], ["proof (state)\nthis:\n  (\\<And>x. x \\<in> ?I2 \\<Longrightarrow> ?g2 x = ?h2 x) \\<Longrightarrow>\n  {?g2 x |x. x \\<in> ?I2} = {?h2 x |x. x \\<in> ?I2}\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < n \\<Longrightarrow>\n                ket_zero_k k =\n                Matrix.vec (2 ^ Suc k) (\\<lambda>k. if k = 0 then 1 else 0);\n        Suc k < n\\<rbrakk>\n       \\<Longrightarrow> ket_zero_k (Suc k) =\n                         Matrix.vec (2 ^ Suc (Suc k))\n                          (\\<lambda>k. if k = 0 then 1 else 0)", "have \"{card {y \\<in> {0..<Suc (Suc k)}. y < x} |x. x \\<in> {0..<Suc k}} = {card {0..<x} |x. x \\<in> {0..<Suc k}} \""], ["proof (prove)\ngoal (1 subgoal):\n 1. {card {y \\<in> {0..<Suc (Suc k)}. y < x} |x. x \\<in> {0..<Suc k}} =\n    {card {0..<x} |x. x \\<in> {0..<Suc k}}", "using setcong[OF cardeq, of \"{0..<Suc k}\"]"], ["proof (prove)\nusing this:\n  (\\<And>x.\n      x \\<in> {0..<Suc k} \\<Longrightarrow>\n      ?x6 x \\<in> {0..<Suc k}) \\<Longrightarrow>\n  {card {y \\<in> {0..<Suc (Suc k)}. y < ?x6 x} |x. x \\<in> {0..<Suc k}} =\n  {card {0..<?x6 x} |x. x \\<in> {0..<Suc k}}\n\ngoal (1 subgoal):\n 1. {card {y \\<in> {0..<Suc (Suc k)}. y < x} |x. x \\<in> {0..<Suc k}} =\n    {card {0..<x} |x. x \\<in> {0..<Suc k}}", "by auto"], ["proof (state)\nthis:\n  {card {y \\<in> {0..<Suc (Suc k)}. y < x} |x. x \\<in> {0..<Suc k}} =\n  {card {0..<x} |x. x \\<in> {0..<Suc k}}\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < n \\<Longrightarrow>\n                ket_zero_k k =\n                Matrix.vec (2 ^ Suc k) (\\<lambda>k. if k = 0 then 1 else 0);\n        Suc k < n\\<rbrakk>\n       \\<Longrightarrow> ket_zero_k (Suc k) =\n                         Matrix.vec (2 ^ Suc (Suc k))\n                          (\\<lambda>k. if k = 0 then 1 else 0)", "also"], ["proof (state)\nthis:\n  {card {y \\<in> {0..<Suc (Suc k)}. y < x} |x. x \\<in> {0..<Suc k}} =\n  {card {0..<x} |x. x \\<in> {0..<Suc k}}\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < n \\<Longrightarrow>\n                ket_zero_k k =\n                Matrix.vec (2 ^ Suc k) (\\<lambda>k. if k = 0 then 1 else 0);\n        Suc k < n\\<rbrakk>\n       \\<Longrightarrow> ket_zero_k (Suc k) =\n                         Matrix.vec (2 ^ Suc (Suc k))\n                          (\\<lambda>k. if k = 0 then 1 else 0)", "have \"\\<dots> = {0..<Suc k}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {card {0..<x} |x. x \\<in> {0..<Suc k}} = {0..<Suc k}", "by auto"], ["proof (state)\nthis:\n  {card {0..<x} |x. x \\<in> {0..<Suc k}} = {0..<Suc k}\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < n \\<Longrightarrow>\n                ket_zero_k k =\n                Matrix.vec (2 ^ Suc k) (\\<lambda>k. if k = 0 then 1 else 0);\n        Suc k < n\\<rbrakk>\n       \\<Longrightarrow> ket_zero_k (Suc k) =\n                         Matrix.vec (2 ^ Suc (Suc k))\n                          (\\<lambda>k. if k = 0 then 1 else 0)", "finally"], ["proof (chain)\npicking this:\n  {card {y \\<in> {0..<Suc (Suc k)}. y < x} |x. x \\<in> {0..<Suc k}} =\n  {0..<Suc k}", "have st2vars1': \"st2.vars1' = {0..<Suc k}\""], ["proof (prove)\nusing this:\n  {card {y \\<in> {0..<Suc (Suc k)}. y < x} |x. x \\<in> {0..<Suc k}} =\n  {0..<Suc k}\n\ngoal (1 subgoal):\n 1. st2.vars1' = {0..<Suc k}", "unfolding st2.vars1'_def st2.vars0_def splitset ind_in_set_def"], ["proof (prove)\nusing this:\n  {card {y \\<in> {0..<Suc (Suc k)}. y < x} |x. x \\<in> {0..<Suc k}} =\n  {0..<Suc k}\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. card {i \\<in> {0..<Suc (Suc k)}. i < x}) ` {0..<Suc k} =\n    {0..<Suc k}", "by fastforce"], ["proof (state)\nthis:\n  st2.vars1' = {0..<Suc k}\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < n \\<Longrightarrow>\n                ket_zero_k k =\n                Matrix.vec (2 ^ Suc k) (\\<lambda>k. if k = 0 then 1 else 0);\n        Suc k < n\\<rbrakk>\n       \\<Longrightarrow> ket_zero_k (Suc k) =\n                         Matrix.vec (2 ^ Suc (Suc k))\n                          (\\<lambda>k. if k = 0 then 1 else 0)", "have st2pvsttv: \"st2.ptensor_vec = st.tensor_vec\""], ["proof (prove)\ngoal (1 subgoal):\n 1. st2.ptensor_vec = st.tensor_vec", "unfolding st2.ptensor_vec_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. partial_state.tensor_vec st2.dims0 st2.vars1' = st.tensor_vec", "using st2dims0 st2vars1'"], ["proof (prove)\nusing this:\n  st2.dims0 = replicate (Suc (Suc k)) 2\n  st2.vars1' = {0..<Suc k}\n\ngoal (1 subgoal):\n 1. partial_state.tensor_vec st2.dims0 st2.vars1' = st.tensor_vec", "by auto"], ["proof (state)\nthis:\n  st2.ptensor_vec = st.tensor_vec\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < n \\<Longrightarrow>\n                ket_zero_k k =\n                Matrix.vec (2 ^ Suc k) (\\<lambda>k. if k = 0 then 1 else 0);\n        Suc k < n\\<rbrakk>\n       \\<Longrightarrow> ket_zero_k (Suc k) =\n                         Matrix.vec (2 ^ Suc (Suc k))\n                          (\\<lambda>k. if k = 0 then 1 else 0)", "have \"st.encode1 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. st.encode1 0 = 0", "using encode1_replicate_2[of \"Suc k\" 0]"], ["proof (prove)\nusing this:\n  st.encode1 0 = 0 mod 2 ^ Suc k\n\ngoal (1 subgoal):\n 1. st.encode1 0 = 0", "by auto"], ["proof (state)\nthis:\n  st.encode1 0 = 0\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < n \\<Longrightarrow>\n                ket_zero_k k =\n                Matrix.vec (2 ^ Suc k) (\\<lambda>k. if k = 0 then 1 else 0);\n        Suc k < n\\<rbrakk>\n       \\<Longrightarrow> ket_zero_k (Suc k) =\n                         Matrix.vec (2 ^ Suc (Suc k))\n                          (\\<lambda>k. if k = 0 then 1 else 0)", "moreover"], ["proof (state)\nthis:\n  st.encode1 0 = 0\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < n \\<Longrightarrow>\n                ket_zero_k k =\n                Matrix.vec (2 ^ Suc k) (\\<lambda>k. if k = 0 then 1 else 0);\n        Suc k < n\\<rbrakk>\n       \\<Longrightarrow> ket_zero_k (Suc k) =\n                         Matrix.vec (2 ^ Suc (Suc k))\n                          (\\<lambda>k. if k = 0 then 1 else 0)", "have \"st.encode2 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. st.encode2 0 = 0", "using encode2_replicate_2[of 0 \"Suc k\"]"], ["proof (prove)\nusing this:\n  0 < 2 ^ Suc (Suc k) \\<Longrightarrow> st.encode2 0 = 0 div 2 ^ Suc k\n\ngoal (1 subgoal):\n 1. st.encode2 0 = 0", "by auto"], ["proof (state)\nthis:\n  st.encode2 0 = 0\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < n \\<Longrightarrow>\n                ket_zero_k k =\n                Matrix.vec (2 ^ Suc k) (\\<lambda>k. if k = 0 then 1 else 0);\n        Suc k < n\\<rbrakk>\n       \\<Longrightarrow> ket_zero_k (Suc k) =\n                         Matrix.vec (2 ^ Suc (Suc k))\n                          (\\<lambda>k. if k = 0 then 1 else 0)", "moreover"], ["proof (state)\nthis:\n  st.encode2 0 = 0\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < n \\<Longrightarrow>\n                ket_zero_k k =\n                Matrix.vec (2 ^ Suc k) (\\<lambda>k. if k = 0 then 1 else 0);\n        Suc k < n\\<rbrakk>\n       \\<Longrightarrow> ket_zero_k (Suc k) =\n                         Matrix.vec (2 ^ Suc (Suc k))\n                          (\\<lambda>k. if k = 0 then 1 else 0)", "have  std: \"st.d = 2^(Suc (Suc k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. st.d = 2 ^ Suc (Suc k)", "unfolding st.d_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. prod_list (replicate (Suc (Suc k)) 2) = 2 ^ Suc (Suc k)", "by auto"], ["proof (state)\nthis:\n  st.d = 2 ^ Suc (Suc k)\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < n \\<Longrightarrow>\n                ket_zero_k k =\n                Matrix.vec (2 ^ Suc k) (\\<lambda>k. if k = 0 then 1 else 0);\n        Suc k < n\\<rbrakk>\n       \\<Longrightarrow> ket_zero_k (Suc k) =\n                         Matrix.vec (2 ^ Suc (Suc k))\n                          (\\<lambda>k. if k = 0 then 1 else 0)", "ultimately"], ["proof (chain)\npicking this:\n  st.encode1 0 = 0\n  st.encode2 0 = 0\n  st.d = 2 ^ Suc (Suc k)", "have kzkk0: \"ket_zero_k (Suc k) $ 0 = 1\""], ["proof (prove)\nusing this:\n  st.encode1 0 = 0\n  st.encode2 0 = 0\n  st.d = 2 ^ Suc (Suc k)\n\ngoal (1 subgoal):\n 1. ket_zero_k (Suc k) $ 0 = 1", "unfolding ket_zero_k.simps st2pvsttv st.tensor_vec_def ket_zero_def"], ["proof (prove)\nusing this:\n  st.encode1 0 = 0\n  st.encode2 0 = 0\n  st.d = 2 ^ Suc (Suc k)\n\ngoal (1 subgoal):\n 1. Matrix.vec st.d\n     (\\<lambda>i.\n         ket_zero_k k $ st.encode1 i *\n         Matrix.vec 2 (\\<lambda>k. if k = 0 then 1 else 0) $ st.encode2 i) $\n    0 =\n    1", "using kzkk"], ["proof (prove)\nusing this:\n  st.encode1 0 = 0\n  st.encode2 0 = 0\n  st.d = 2 ^ Suc (Suc k)\n  ket_zero_k k = Matrix.vec (2 ^ Suc k) (\\<lambda>k. if k = 0 then 1 else 0)\n\ngoal (1 subgoal):\n 1. Matrix.vec st.d\n     (\\<lambda>i.\n         ket_zero_k k $ st.encode1 i *\n         Matrix.vec 2 (\\<lambda>k. if k = 0 then 1 else 0) $ st.encode2 i) $\n    0 =\n    1", "by auto"], ["proof (state)\nthis:\n  ket_zero_k (Suc k) $ 0 = 1\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < n \\<Longrightarrow>\n                ket_zero_k k =\n                Matrix.vec (2 ^ Suc k) (\\<lambda>k. if k = 0 then 1 else 0);\n        Suc k < n\\<rbrakk>\n       \\<Longrightarrow> ket_zero_k (Suc k) =\n                         Matrix.vec (2 ^ Suc (Suc k))\n                          (\\<lambda>k. if k = 0 then 1 else 0)", "have kzkki: \"ket_zero_k (Suc k) $ i = 0\" if ine0: \"i \\<noteq> 0\" and ile: \"i < 2^(Suc (Suc k))\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. ket_zero_k (Suc k) $ i = 0", "proof (cases \"i mod (2 ^ Suc k) \\<noteq> 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i mod 2 ^ Suc k \\<noteq> 0 \\<Longrightarrow> ket_zero_k (Suc k) $ i = 0\n 2. \\<not> i mod 2 ^ Suc k \\<noteq> 0 \\<Longrightarrow>\n    ket_zero_k (Suc k) $ i = 0", "case True"], ["proof (state)\nthis:\n  i mod 2 ^ Suc k \\<noteq> 0\n\ngoal (2 subgoals):\n 1. i mod 2 ^ Suc k \\<noteq> 0 \\<Longrightarrow> ket_zero_k (Suc k) $ i = 0\n 2. \\<not> i mod 2 ^ Suc k \\<noteq> 0 \\<Longrightarrow>\n    ket_zero_k (Suc k) $ i = 0", "then"], ["proof (chain)\npicking this:\n  i mod 2 ^ Suc k \\<noteq> 0", "have \"ket_zero_k k $ st.encode1 i = 0\""], ["proof (prove)\nusing this:\n  i mod 2 ^ Suc k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. ket_zero_k k $ st.encode1 i = 0", "unfolding kzkk"], ["proof (prove)\nusing this:\n  i mod 2 ^ Suc k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. Matrix.vec (2 ^ Suc k) (\\<lambda>k. if k = 0 then 1 else 0) $\n    st.encode1 i =\n    0", "using encode1_replicate_2[of \"Suc k\" i] ile"], ["proof (prove)\nusing this:\n  i mod 2 ^ Suc k \\<noteq> 0\n  st.encode1 i = i mod 2 ^ Suc k\n  i < 2 ^ Suc (Suc k)\n\ngoal (1 subgoal):\n 1. Matrix.vec (2 ^ Suc k) (\\<lambda>k. if k = 0 then 1 else 0) $\n    st.encode1 i =\n    0", "by auto"], ["proof (state)\nthis:\n  ket_zero_k k $ st.encode1 i = 0\n\ngoal (2 subgoals):\n 1. i mod 2 ^ Suc k \\<noteq> 0 \\<Longrightarrow> ket_zero_k (Suc k) $ i = 0\n 2. \\<not> i mod 2 ^ Suc k \\<noteq> 0 \\<Longrightarrow>\n    ket_zero_k (Suc k) $ i = 0", "then"], ["proof (chain)\npicking this:\n  ket_zero_k k $ st.encode1 i = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  ket_zero_k k $ st.encode1 i = 0\n\ngoal (1 subgoal):\n 1. ket_zero_k (Suc k) $ i = 0", "unfolding ket_zero_k.simps st2pvsttv st.tensor_vec_def ket_zero_def std"], ["proof (prove)\nusing this:\n  ket_zero_k k $ st.encode1 i = 0\n\ngoal (1 subgoal):\n 1. Matrix.vec (2 ^ Suc (Suc k))\n     (\\<lambda>i.\n         ket_zero_k k $ st.encode1 i *\n         Matrix.vec 2 (\\<lambda>k. if k = 0 then 1 else 0) $ st.encode2 i) $\n    i =\n    0", "using ile"], ["proof (prove)\nusing this:\n  ket_zero_k k $ st.encode1 i = 0\n  i < 2 ^ Suc (Suc k)\n\ngoal (1 subgoal):\n 1. Matrix.vec (2 ^ Suc (Suc k))\n     (\\<lambda>i.\n         ket_zero_k k $ st.encode1 i *\n         Matrix.vec 2 (\\<lambda>k. if k = 0 then 1 else 0) $ st.encode2 i) $\n    i =\n    0", "by auto"], ["proof (state)\nthis:\n  ket_zero_k (Suc k) $ i = 0\n\ngoal (1 subgoal):\n 1. \\<not> i mod 2 ^ Suc k \\<noteq> 0 \\<Longrightarrow>\n    ket_zero_k (Suc k) $ i = 0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> i mod 2 ^ Suc k \\<noteq> 0 \\<Longrightarrow>\n    ket_zero_k (Suc k) $ i = 0", "case False"], ["proof (state)\nthis:\n  \\<not> i mod 2 ^ Suc k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> i mod 2 ^ Suc k \\<noteq> 0 \\<Longrightarrow>\n    ket_zero_k (Suc k) $ i = 0", "have \"i div (2 ^ Suc k) \\<noteq> 0 \\<or> i mod (2 ^ Suc k) \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i div 2 ^ Suc k \\<noteq> 0 \\<or> i mod 2 ^ Suc k \\<noteq> 0", "using ine0"], ["proof (prove)\nusing this:\n  i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. i div 2 ^ Suc k \\<noteq> 0 \\<or> i mod 2 ^ Suc k \\<noteq> 0", "by fastforce"], ["proof (state)\nthis:\n  i div 2 ^ Suc k \\<noteq> 0 \\<or> i mod 2 ^ Suc k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> i mod 2 ^ Suc k \\<noteq> 0 \\<Longrightarrow>\n    ket_zero_k (Suc k) $ i = 0", "then"], ["proof (chain)\npicking this:\n  i div 2 ^ Suc k \\<noteq> 0 \\<or> i mod 2 ^ Suc k \\<noteq> 0", "have \"i div (2 ^ Suc k) \\<noteq> 0\""], ["proof (prove)\nusing this:\n  i div 2 ^ Suc k \\<noteq> 0 \\<or> i mod 2 ^ Suc k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. i div 2 ^ Suc k \\<noteq> 0", "using False"], ["proof (prove)\nusing this:\n  i div 2 ^ Suc k \\<noteq> 0 \\<or> i mod 2 ^ Suc k \\<noteq> 0\n  \\<not> i mod 2 ^ Suc k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. i div 2 ^ Suc k \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  i div 2 ^ Suc k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> i mod 2 ^ Suc k \\<noteq> 0 \\<Longrightarrow>\n    ket_zero_k (Suc k) $ i = 0", "moreover"], ["proof (state)\nthis:\n  i div 2 ^ Suc k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> i mod 2 ^ Suc k \\<noteq> 0 \\<Longrightarrow>\n    ket_zero_k (Suc k) $ i = 0", "have \"i div (2 ^ Suc k) < 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i div 2 ^ Suc k < 2", "using ile less_mult_imp_div_less"], ["proof (prove)\nusing this:\n  i < 2 ^ Suc (Suc k)\n  ?m < ?i * ?n \\<Longrightarrow> ?m div ?n < ?i\n\ngoal (1 subgoal):\n 1. i div 2 ^ Suc k < 2", "by auto"], ["proof (state)\nthis:\n  i div 2 ^ Suc k < 2\n\ngoal (1 subgoal):\n 1. \\<not> i mod 2 ^ Suc k \\<noteq> 0 \\<Longrightarrow>\n    ket_zero_k (Suc k) $ i = 0", "ultimately"], ["proof (chain)\npicking this:\n  i div 2 ^ Suc k \\<noteq> 0\n  i div 2 ^ Suc k < 2", "have \"i div (2 ^ Suc k) = 1\""], ["proof (prove)\nusing this:\n  i div 2 ^ Suc k \\<noteq> 0\n  i div 2 ^ Suc k < 2\n\ngoal (1 subgoal):\n 1. i div 2 ^ Suc k = 1", "by auto"], ["proof (state)\nthis:\n  i div 2 ^ Suc k = 1\n\ngoal (1 subgoal):\n 1. \\<not> i mod 2 ^ Suc k \\<noteq> 0 \\<Longrightarrow>\n    ket_zero_k (Suc k) $ i = 0", "then"], ["proof (chain)\npicking this:\n  i div 2 ^ Suc k = 1", "have \"st.encode2 i = 1\""], ["proof (prove)\nusing this:\n  i div 2 ^ Suc k = 1\n\ngoal (1 subgoal):\n 1. st.encode2 i = 1", "using encode2_replicate_2[of i \"Suc k\"] ile"], ["proof (prove)\nusing this:\n  i div 2 ^ Suc k = 1\n  i < 2 ^ Suc (Suc k) \\<Longrightarrow> st.encode2 i = i div 2 ^ Suc k\n  i < 2 ^ Suc (Suc k)\n\ngoal (1 subgoal):\n 1. st.encode2 i = 1", "by auto"], ["proof (state)\nthis:\n  st.encode2 i = 1\n\ngoal (1 subgoal):\n 1. \\<not> i mod 2 ^ Suc k \\<noteq> 0 \\<Longrightarrow>\n    ket_zero_k (Suc k) $ i = 0", "then"], ["proof (chain)\npicking this:\n  st.encode2 i = 1", "have \"Matrix.vec 2 (\\<lambda>k. if k = 0 then 1 else 0) $ st.encode2 i = 0\""], ["proof (prove)\nusing this:\n  st.encode2 i = 1\n\ngoal (1 subgoal):\n 1. Matrix.vec 2 (\\<lambda>k. if k = 0 then 1::'a else (0::'a)) $\n    st.encode2 i =\n    (0::'a)", "unfolding kzkk"], ["proof (prove)\nusing this:\n  st.encode2 i = 1\n\ngoal (1 subgoal):\n 1. Matrix.vec 2 (\\<lambda>k. if k = 0 then 1::'a else (0::'a)) $\n    st.encode2 i =\n    (0::'a)", "by fastforce"], ["proof (state)\nthis:\n  Matrix.vec 2 (\\<lambda>k. if k = 0 then 1::?'a5 else (0::?'a5)) $\n  st.encode2 i =\n  (0::?'a5)\n\ngoal (1 subgoal):\n 1. \\<not> i mod 2 ^ Suc k \\<noteq> 0 \\<Longrightarrow>\n    ket_zero_k (Suc k) $ i = 0", "then"], ["proof (chain)\npicking this:\n  Matrix.vec 2 (\\<lambda>k. if k = 0 then 1::?'a5 else (0::?'a5)) $\n  st.encode2 i =\n  (0::?'a5)", "show ?thesis"], ["proof (prove)\nusing this:\n  Matrix.vec 2 (\\<lambda>k. if k = 0 then 1::?'a5 else (0::?'a5)) $\n  st.encode2 i =\n  (0::?'a5)\n\ngoal (1 subgoal):\n 1. ket_zero_k (Suc k) $ i = 0", "unfolding ket_zero_k.simps st2pvsttv st.tensor_vec_def ket_zero_def std"], ["proof (prove)\nusing this:\n  Matrix.vec 2 (\\<lambda>k. if k = 0 then 1::?'a5 else (0::?'a5)) $\n  st.encode2 i =\n  (0::?'a5)\n\ngoal (1 subgoal):\n 1. Matrix.vec (2 ^ Suc (Suc k))\n     (\\<lambda>i.\n         ket_zero_k k $ st.encode1 i *\n         Matrix.vec 2 (\\<lambda>k. if k = 0 then 1 else 0) $ st.encode2 i) $\n    i =\n    0", "using ile"], ["proof (prove)\nusing this:\n  Matrix.vec 2 (\\<lambda>k. if k = 0 then 1::?'a5 else (0::?'a5)) $\n  st.encode2 i =\n  (0::?'a5)\n  i < 2 ^ Suc (Suc k)\n\ngoal (1 subgoal):\n 1. Matrix.vec (2 ^ Suc (Suc k))\n     (\\<lambda>i.\n         ket_zero_k k $ st.encode1 i *\n         Matrix.vec 2 (\\<lambda>k. if k = 0 then 1 else 0) $ st.encode2 i) $\n    i =\n    0", "by auto"], ["proof (state)\nthis:\n  ket_zero_k (Suc k) $ i = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>?i4 \\<noteq> 0; ?i4 < 2 ^ Suc (Suc k)\\<rbrakk>\n  \\<Longrightarrow> ket_zero_k (Suc k) $ ?i4 = 0\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < n \\<Longrightarrow>\n                ket_zero_k k =\n                Matrix.vec (2 ^ Suc k) (\\<lambda>k. if k = 0 then 1 else 0);\n        Suc k < n\\<rbrakk>\n       \\<Longrightarrow> ket_zero_k (Suc k) =\n                         Matrix.vec (2 ^ Suc (Suc k))\n                          (\\<lambda>k. if k = 0 then 1 else 0)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. ket_zero_k (Suc k) =\n    Matrix.vec (2 ^ Suc (Suc k)) (\\<lambda>k. if k = 0 then 1 else 0)", "apply (rule eq_vecI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i.\n       i < dim_vec\n            (Matrix.vec (2 ^ Suc (Suc k))\n              (\\<lambda>k. if k = 0 then 1 else 0)) \\<Longrightarrow>\n       ket_zero_k (Suc k) $ i =\n       Matrix.vec (2 ^ Suc (Suc k)) (\\<lambda>k. if k = 0 then 1 else 0) $ i\n 2. dim_vec (ket_zero_k (Suc k)) =\n    dim_vec\n     (Matrix.vec (2 ^ Suc (Suc k)) (\\<lambda>k. if k = 0 then 1 else 0))", "subgoal for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. i < dim_vec\n         (Matrix.vec (2 ^ Suc (Suc k))\n           (\\<lambda>k. if k = 0 then 1 else 0)) \\<Longrightarrow>\n    ket_zero_k (Suc k) $ i =\n    Matrix.vec (2 ^ Suc (Suc k)) (\\<lambda>k. if k = 0 then 1 else 0) $ i", "using kzkk0 kzkki"], ["proof (prove)\nusing this:\n  ket_zero_k (Suc k) $ 0 = 1\n  \\<lbrakk>?i4 \\<noteq> 0; ?i4 < 2 ^ Suc (Suc k)\\<rbrakk>\n  \\<Longrightarrow> ket_zero_k (Suc k) $ ?i4 = 0\n\ngoal (1 subgoal):\n 1. i < dim_vec\n         (Matrix.vec (2 ^ Suc (Suc k))\n           (\\<lambda>k. if k = 0 then 1 else 0)) \\<Longrightarrow>\n    ket_zero_k (Suc k) $ i =\n    Matrix.vec (2 ^ Suc (Suc k)) (\\<lambda>k. if k = 0 then 1 else 0) $ i", "by auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_vec (ket_zero_k (Suc k)) =\n    dim_vec\n     (Matrix.vec (2 ^ Suc (Suc k)) (\\<lambda>k. if k = 0 then 1 else 0))", "using carrier_vecD[OF dSk]"], ["proof (prove)\nusing this:\n  dim_vec (ket_zero_k (Suc k)) = 2 ^ Suc (Suc k)\n\ngoal (1 subgoal):\n 1. dim_vec (ket_zero_k (Suc k)) =\n    dim_vec\n     (Matrix.vec (2 ^ Suc (Suc k)) (\\<lambda>k. if k = 0 then 1 else 0))", "by auto"], ["proof (state)\nthis:\n  ket_zero_k (Suc k) =\n  Matrix.vec (2 ^ Suc (Suc k)) (\\<lambda>k. if k = 0 then 1 else 0)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ket_plus_k_decode:\n  \"k < n \\<Longrightarrow> ket_plus_k k = Matrix.vec (2^(Suc k)) (\\<lambda>l. 1 / csqrt (2^(Suc k)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k < n \\<Longrightarrow>\n    ket_plus_k k =\n    Matrix.vec (2 ^ Suc k) (\\<lambda>l. 1 / csqrt (2 ^ Suc k))", "proof (induct k)"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 < n \\<Longrightarrow>\n    ket_plus_k 0 =\n    Matrix.vec (2 ^ Suc 0) (\\<lambda>l. 1 / csqrt (2 ^ Suc 0))\n 2. \\<And>k.\n       \\<lbrakk>k < n \\<Longrightarrow>\n                ket_plus_k k =\n                Matrix.vec (2 ^ Suc k) (\\<lambda>l. 1 / csqrt (2 ^ Suc k));\n        Suc k < n\\<rbrakk>\n       \\<Longrightarrow> ket_plus_k (Suc k) =\n                         Matrix.vec (2 ^ Suc (Suc k))\n                          (\\<lambda>l. 1 / csqrt (2 ^ Suc (Suc k)))", "case 0"], ["proof (state)\nthis:\n  0 < n\n\ngoal (2 subgoals):\n 1. 0 < n \\<Longrightarrow>\n    ket_plus_k 0 =\n    Matrix.vec (2 ^ Suc 0) (\\<lambda>l. 1 / csqrt (2 ^ Suc 0))\n 2. \\<And>k.\n       \\<lbrakk>k < n \\<Longrightarrow>\n                ket_plus_k k =\n                Matrix.vec (2 ^ Suc k) (\\<lambda>l. 1 / csqrt (2 ^ Suc k));\n        Suc k < n\\<rbrakk>\n       \\<Longrightarrow> ket_plus_k (Suc k) =\n                         Matrix.vec (2 ^ Suc (Suc k))\n                          (\\<lambda>l. 1 / csqrt (2 ^ Suc (Suc k)))", "then"], ["proof (chain)\npicking this:\n  0 < n", "show ?case"], ["proof (prove)\nusing this:\n  0 < n\n\ngoal (1 subgoal):\n 1. ket_plus_k 0 =\n    Matrix.vec (2 ^ Suc 0) (\\<lambda>l. 1 / csqrt (2 ^ Suc 0))", "unfolding ket_plus_k.simps ket_plus_def"], ["proof (prove)\nusing this:\n  0 < n\n\ngoal (1 subgoal):\n 1. Matrix.vec 2 (\\<lambda>k. 1 / csqrt 2) =\n    Matrix.vec (2 ^ Suc 0) (\\<lambda>l. 1 / csqrt (2 ^ Suc 0))", "by auto"], ["proof (state)\nthis:\n  ket_plus_k 0 = Matrix.vec (2 ^ Suc 0) (\\<lambda>l. 1 / csqrt (2 ^ Suc 0))\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < n \\<Longrightarrow>\n                ket_plus_k k =\n                Matrix.vec (2 ^ Suc k) (\\<lambda>l. 1 / csqrt (2 ^ Suc k));\n        Suc k < n\\<rbrakk>\n       \\<Longrightarrow> ket_plus_k (Suc k) =\n                         Matrix.vec (2 ^ Suc (Suc k))\n                          (\\<lambda>l. 1 / csqrt (2 ^ Suc (Suc k)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < n \\<Longrightarrow>\n                ket_plus_k k =\n                Matrix.vec (2 ^ Suc k) (\\<lambda>l. 1 / csqrt (2 ^ Suc k));\n        Suc k < n\\<rbrakk>\n       \\<Longrightarrow> ket_plus_k (Suc k) =\n                         Matrix.vec (2 ^ Suc (Suc k))\n                          (\\<lambda>l. 1 / csqrt (2 ^ Suc (Suc k)))", "case (Suc k)"], ["proof (state)\nthis:\n  k < n \\<Longrightarrow>\n  ket_plus_k k = Matrix.vec (2 ^ Suc k) (\\<lambda>l. 1 / csqrt (2 ^ Suc k))\n  Suc k < n\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < n \\<Longrightarrow>\n                ket_plus_k k =\n                Matrix.vec (2 ^ Suc k) (\\<lambda>l. 1 / csqrt (2 ^ Suc k));\n        Suc k < n\\<rbrakk>\n       \\<Longrightarrow> ket_plus_k (Suc k) =\n                         Matrix.vec (2 ^ Suc (Suc k))\n                          (\\<lambda>l. 1 / csqrt (2 ^ Suc (Suc k)))", "then"], ["proof (chain)\npicking this:\n  k < n \\<Longrightarrow>\n  ket_plus_k k = Matrix.vec (2 ^ Suc k) (\\<lambda>l. 1 / csqrt (2 ^ Suc k))\n  Suc k < n", "have kpkk: \"ket_plus_k k = Matrix.vec (2 ^ Suc k) (\\<lambda>l. 1 / csqrt (2 ^ Suc k))\""], ["proof (prove)\nusing this:\n  k < n \\<Longrightarrow>\n  ket_plus_k k = Matrix.vec (2 ^ Suc k) (\\<lambda>l. 1 / csqrt (2 ^ Suc k))\n  Suc k < n\n\ngoal (1 subgoal):\n 1. ket_plus_k k =\n    Matrix.vec (2 ^ Suc k) (\\<lambda>l. 1 / csqrt (2 ^ Suc k))", "by auto"], ["proof (state)\nthis:\n  ket_plus_k k = Matrix.vec (2 ^ Suc k) (\\<lambda>l. 1 / csqrt (2 ^ Suc k))\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < n \\<Longrightarrow>\n                ket_plus_k k =\n                Matrix.vec (2 ^ Suc k) (\\<lambda>l. 1 / csqrt (2 ^ Suc k));\n        Suc k < n\\<rbrakk>\n       \\<Longrightarrow> ket_plus_k (Suc k) =\n                         Matrix.vec (2 ^ Suc (Suc k))\n                          (\\<lambda>l. 1 / csqrt (2 ^ Suc (Suc k)))", "have dSk: \"ket_plus_k (Suc k) \\<in> carrier_vec (2^(Suc (Suc k)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ket_plus_k (Suc k) \\<in> carrier_vec (2 ^ Suc (Suc k))", "using ket_plus_k_dim[OF Suc(2)]"], ["proof (prove)\nusing this:\n  ket_plus_k (Suc k) \\<in> carrier_vec (2 ^ Suc (Suc k))\n\ngoal (1 subgoal):\n 1. ket_plus_k (Suc k) \\<in> carrier_vec (2 ^ Suc (Suc k))", "by auto"], ["proof (state)\nthis:\n  ket_plus_k (Suc k) \\<in> carrier_vec (2 ^ Suc (Suc k))\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < n \\<Longrightarrow>\n                ket_plus_k k =\n                Matrix.vec (2 ^ Suc k) (\\<lambda>l. 1 / csqrt (2 ^ Suc k));\n        Suc k < n\\<rbrakk>\n       \\<Longrightarrow> ket_plus_k (Suc k) =\n                         Matrix.vec (2 ^ Suc (Suc k))\n                          (\\<lambda>l. 1 / csqrt (2 ^ Suc (Suc k)))", "interpret st: partial_state \"replicate (Suc (Suc k)) 2\" \"{0..<Suc k}\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < n \\<Longrightarrow>\n                ket_plus_k k =\n                Matrix.vec (2 ^ Suc k) (\\<lambda>l. 1 / csqrt (2 ^ Suc k));\n        Suc k < n\\<rbrakk>\n       \\<Longrightarrow> ket_plus_k (Suc k) =\n                         Matrix.vec (2 ^ Suc (Suc k))\n                          (\\<lambda>l. 1 / csqrt (2 ^ Suc (Suc k)))", "interpret st2: partial_state2 dims \"{0..<Suc k}\" \"{Suc k}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. partial_state2 {0..<Suc k} {Suc k}", "by (unfold_locales, auto)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < n \\<Longrightarrow>\n                ket_plus_k k =\n                Matrix.vec (2 ^ Suc k) (\\<lambda>l. 1 / csqrt (2 ^ Suc k));\n        Suc k < n\\<rbrakk>\n       \\<Longrightarrow> ket_plus_k (Suc k) =\n                         Matrix.vec (2 ^ Suc (Suc k))\n                          (\\<lambda>l. 1 / csqrt (2 ^ Suc (Suc k)))", "have splitset: \"({0..<Suc k} \\<union> {Suc k}) = {0..<Suc (Suc k)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {0..<Suc k} \\<union> {Suc k} = {0..<Suc (Suc k)}", "by auto"], ["proof (state)\nthis:\n  {0..<Suc k} \\<union> {Suc k} = {0..<Suc (Suc k)}\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < n \\<Longrightarrow>\n                ket_plus_k k =\n                Matrix.vec (2 ^ Suc k) (\\<lambda>l. 1 / csqrt (2 ^ Suc k));\n        Suc k < n\\<rbrakk>\n       \\<Longrightarrow> ket_plus_k (Suc k) =\n                         Matrix.vec (2 ^ Suc (Suc k))\n                          (\\<lambda>l. 1 / csqrt (2 ^ Suc (Suc k)))", "then"], ["proof (chain)\npicking this:\n  {0..<Suc k} \\<union> {Suc k} = {0..<Suc (Suc k)}", "have st2dims0: \"st2.dims0 = replicate (Suc (Suc k)) 2\""], ["proof (prove)\nusing this:\n  {0..<Suc k} \\<union> {Suc k} = {0..<Suc (Suc k)}\n\ngoal (1 subgoal):\n 1. st2.dims0 = replicate (Suc (Suc k)) 2", "unfolding st2.dims0_def st2.vars0_def"], ["proof (prove)\nusing this:\n  {0..<Suc k} \\<union> {Suc k} = {0..<Suc (Suc k)}\n\ngoal (1 subgoal):\n 1. nths dims ({0..<Suc k} \\<union> {Suc k}) = replicate (Suc (Suc k)) 2", "using dims_nths_le_n[of \"Suc (Suc k)\"] Suc"], ["proof (prove)\nusing this:\n  {0..<Suc k} \\<union> {Suc k} = {0..<Suc (Suc k)}\n  Suc (Suc k) \\<le> n \\<Longrightarrow>\n  nths dims {0..<Suc (Suc k)} = replicate (Suc (Suc k)) 2\n  k < n \\<Longrightarrow>\n  ket_plus_k k = Matrix.vec (2 ^ Suc k) (\\<lambda>l. 1 / csqrt (2 ^ Suc k))\n  Suc k < n\n\ngoal (1 subgoal):\n 1. nths dims ({0..<Suc k} \\<union> {Suc k}) = replicate (Suc (Suc k)) 2", "by auto"], ["proof (state)\nthis:\n  st2.dims0 = replicate (Suc (Suc k)) 2\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < n \\<Longrightarrow>\n                ket_plus_k k =\n                Matrix.vec (2 ^ Suc k) (\\<lambda>l. 1 / csqrt (2 ^ Suc k));\n        Suc k < n\\<rbrakk>\n       \\<Longrightarrow> ket_plus_k (Suc k) =\n                         Matrix.vec (2 ^ Suc (Suc k))\n                          (\\<lambda>l. 1 / csqrt (2 ^ Suc (Suc k)))", "have \"\\<And>x. (x \\<in> {0..<Suc k} \\<Longrightarrow> {y \\<in> {0..<Suc (Suc k)}. y < x} = {0..<x})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0..<Suc k} \\<Longrightarrow>\n       {y \\<in> {0..<Suc (Suc k)}. y < x} = {0..<x}", "by auto"], ["proof (state)\nthis:\n  ?x2 \\<in> {0..<Suc k} \\<Longrightarrow>\n  {y \\<in> {0..<Suc (Suc k)}. y < ?x2} = {0..<?x2}\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < n \\<Longrightarrow>\n                ket_plus_k k =\n                Matrix.vec (2 ^ Suc k) (\\<lambda>l. 1 / csqrt (2 ^ Suc k));\n        Suc k < n\\<rbrakk>\n       \\<Longrightarrow> ket_plus_k (Suc k) =\n                         Matrix.vec (2 ^ Suc (Suc k))\n                          (\\<lambda>l. 1 / csqrt (2 ^ Suc (Suc k)))", "then"], ["proof (chain)\npicking this:\n  ?x2 \\<in> {0..<Suc k} \\<Longrightarrow>\n  {y \\<in> {0..<Suc (Suc k)}. y < ?x2} = {0..<?x2}", "have cardeq: \"\\<And>x. (x \\<in> {0..<Suc k} \\<Longrightarrow> card {y \\<in> {0..<Suc (Suc k)}. y < x} = card {0..<x})\""], ["proof (prove)\nusing this:\n  ?x2 \\<in> {0..<Suc k} \\<Longrightarrow>\n  {y \\<in> {0..<Suc (Suc k)}. y < ?x2} = {0..<?x2}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0..<Suc k} \\<Longrightarrow>\n       card {y \\<in> {0..<Suc (Suc k)}. y < x} = card {0..<x}", "by auto"], ["proof (state)\nthis:\n  ?x2 \\<in> {0..<Suc k} \\<Longrightarrow>\n  card {y \\<in> {0..<Suc (Suc k)}. y < ?x2} = card {0..<?x2}\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < n \\<Longrightarrow>\n                ket_plus_k k =\n                Matrix.vec (2 ^ Suc k) (\\<lambda>l. 1 / csqrt (2 ^ Suc k));\n        Suc k < n\\<rbrakk>\n       \\<Longrightarrow> ket_plus_k (Suc k) =\n                         Matrix.vec (2 ^ Suc (Suc k))\n                          (\\<lambda>l. 1 / csqrt (2 ^ Suc (Suc k)))", "have setcong: \"\\<And>g h I. (\\<And>x. (x \\<in> I \\<Longrightarrow> g x = h x)) \\<Longrightarrow> {g x | x. x \\<in> I} = {h x | x. x \\<in> I}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>g h I.\n       (\\<And>x. x \\<in> I \\<Longrightarrow> g x = h x) \\<Longrightarrow>\n       {g x |x. x \\<in> I} = {h x |x. x \\<in> I}", "by metis"], ["proof (state)\nthis:\n  (\\<And>x. x \\<in> ?I2 \\<Longrightarrow> ?g2 x = ?h2 x) \\<Longrightarrow>\n  {?g2 x |x. x \\<in> ?I2} = {?h2 x |x. x \\<in> ?I2}\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < n \\<Longrightarrow>\n                ket_plus_k k =\n                Matrix.vec (2 ^ Suc k) (\\<lambda>l. 1 / csqrt (2 ^ Suc k));\n        Suc k < n\\<rbrakk>\n       \\<Longrightarrow> ket_plus_k (Suc k) =\n                         Matrix.vec (2 ^ Suc (Suc k))\n                          (\\<lambda>l. 1 / csqrt (2 ^ Suc (Suc k)))", "have \"{card {y \\<in> {0..<Suc (Suc k)}. y < x} |x. x \\<in> {0..<Suc k}} = {card {0..<x} |x. x \\<in> {0..<Suc k}} \""], ["proof (prove)\ngoal (1 subgoal):\n 1. {card {y \\<in> {0..<Suc (Suc k)}. y < x} |x. x \\<in> {0..<Suc k}} =\n    {card {0..<x} |x. x \\<in> {0..<Suc k}}", "using setcong[OF cardeq, of \"{0..<Suc k}\"]"], ["proof (prove)\nusing this:\n  (\\<And>x.\n      x \\<in> {0..<Suc k} \\<Longrightarrow>\n      ?x6 x \\<in> {0..<Suc k}) \\<Longrightarrow>\n  {card {y \\<in> {0..<Suc (Suc k)}. y < ?x6 x} |x. x \\<in> {0..<Suc k}} =\n  {card {0..<?x6 x} |x. x \\<in> {0..<Suc k}}\n\ngoal (1 subgoal):\n 1. {card {y \\<in> {0..<Suc (Suc k)}. y < x} |x. x \\<in> {0..<Suc k}} =\n    {card {0..<x} |x. x \\<in> {0..<Suc k}}", "by auto"], ["proof (state)\nthis:\n  {card {y \\<in> {0..<Suc (Suc k)}. y < x} |x. x \\<in> {0..<Suc k}} =\n  {card {0..<x} |x. x \\<in> {0..<Suc k}}\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < n \\<Longrightarrow>\n                ket_plus_k k =\n                Matrix.vec (2 ^ Suc k) (\\<lambda>l. 1 / csqrt (2 ^ Suc k));\n        Suc k < n\\<rbrakk>\n       \\<Longrightarrow> ket_plus_k (Suc k) =\n                         Matrix.vec (2 ^ Suc (Suc k))\n                          (\\<lambda>l. 1 / csqrt (2 ^ Suc (Suc k)))", "also"], ["proof (state)\nthis:\n  {card {y \\<in> {0..<Suc (Suc k)}. y < x} |x. x \\<in> {0..<Suc k}} =\n  {card {0..<x} |x. x \\<in> {0..<Suc k}}\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < n \\<Longrightarrow>\n                ket_plus_k k =\n                Matrix.vec (2 ^ Suc k) (\\<lambda>l. 1 / csqrt (2 ^ Suc k));\n        Suc k < n\\<rbrakk>\n       \\<Longrightarrow> ket_plus_k (Suc k) =\n                         Matrix.vec (2 ^ Suc (Suc k))\n                          (\\<lambda>l. 1 / csqrt (2 ^ Suc (Suc k)))", "have \"\\<dots> = {0..<Suc k}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {card {0..<x} |x. x \\<in> {0..<Suc k}} = {0..<Suc k}", "by auto"], ["proof (state)\nthis:\n  {card {0..<x} |x. x \\<in> {0..<Suc k}} = {0..<Suc k}\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < n \\<Longrightarrow>\n                ket_plus_k k =\n                Matrix.vec (2 ^ Suc k) (\\<lambda>l. 1 / csqrt (2 ^ Suc k));\n        Suc k < n\\<rbrakk>\n       \\<Longrightarrow> ket_plus_k (Suc k) =\n                         Matrix.vec (2 ^ Suc (Suc k))\n                          (\\<lambda>l. 1 / csqrt (2 ^ Suc (Suc k)))", "finally"], ["proof (chain)\npicking this:\n  {card {y \\<in> {0..<Suc (Suc k)}. y < x} |x. x \\<in> {0..<Suc k}} =\n  {0..<Suc k}", "have st2vars1': \"st2.vars1' = {0..<Suc k}\""], ["proof (prove)\nusing this:\n  {card {y \\<in> {0..<Suc (Suc k)}. y < x} |x. x \\<in> {0..<Suc k}} =\n  {0..<Suc k}\n\ngoal (1 subgoal):\n 1. st2.vars1' = {0..<Suc k}", "unfolding st2.vars1'_def st2.vars0_def splitset ind_in_set_def"], ["proof (prove)\nusing this:\n  {card {y \\<in> {0..<Suc (Suc k)}. y < x} |x. x \\<in> {0..<Suc k}} =\n  {0..<Suc k}\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. card {i \\<in> {0..<Suc (Suc k)}. i < x}) ` {0..<Suc k} =\n    {0..<Suc k}", "by blast"], ["proof (state)\nthis:\n  st2.vars1' = {0..<Suc k}\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < n \\<Longrightarrow>\n                ket_plus_k k =\n                Matrix.vec (2 ^ Suc k) (\\<lambda>l. 1 / csqrt (2 ^ Suc k));\n        Suc k < n\\<rbrakk>\n       \\<Longrightarrow> ket_plus_k (Suc k) =\n                         Matrix.vec (2 ^ Suc (Suc k))\n                          (\\<lambda>l. 1 / csqrt (2 ^ Suc (Suc k)))", "have st2pvsttv: \"st2.ptensor_vec = st.tensor_vec\""], ["proof (prove)\ngoal (1 subgoal):\n 1. st2.ptensor_vec = st.tensor_vec", "unfolding st2.ptensor_vec_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. partial_state.tensor_vec st2.dims0 st2.vars1' = st.tensor_vec", "using st2dims0 st2vars1'"], ["proof (prove)\nusing this:\n  st2.dims0 = replicate (Suc (Suc k)) 2\n  st2.vars1' = {0..<Suc k}\n\ngoal (1 subgoal):\n 1. partial_state.tensor_vec st2.dims0 st2.vars1' = st.tensor_vec", "by auto"], ["proof (state)\nthis:\n  st2.ptensor_vec = st.tensor_vec\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < n \\<Longrightarrow>\n                ket_plus_k k =\n                Matrix.vec (2 ^ Suc k) (\\<lambda>l. 1 / csqrt (2 ^ Suc k));\n        Suc k < n\\<rbrakk>\n       \\<Longrightarrow> ket_plus_k (Suc k) =\n                         Matrix.vec (2 ^ Suc (Suc k))\n                          (\\<lambda>l. 1 / csqrt (2 ^ Suc (Suc k)))", "have \"csqrt (2 ^ (Suc k)) = complex_of_real (sqrt (2 ^ (Suc k)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. csqrt (2 ^ Suc k) = complex_of_real (sqrt (2 ^ Suc k))", "by simp"], ["proof (state)\nthis:\n  csqrt (2 ^ Suc k) = complex_of_real (sqrt (2 ^ Suc k))\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < n \\<Longrightarrow>\n                ket_plus_k k =\n                Matrix.vec (2 ^ Suc k) (\\<lambda>l. 1 / csqrt (2 ^ Suc k));\n        Suc k < n\\<rbrakk>\n       \\<Longrightarrow> ket_plus_k (Suc k) =\n                         Matrix.vec (2 ^ Suc (Suc k))\n                          (\\<lambda>l. 1 / csqrt (2 ^ Suc (Suc k)))", "moreover"], ["proof (state)\nthis:\n  csqrt (2 ^ Suc k) = complex_of_real (sqrt (2 ^ Suc k))\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < n \\<Longrightarrow>\n                ket_plus_k k =\n                Matrix.vec (2 ^ Suc k) (\\<lambda>l. 1 / csqrt (2 ^ Suc k));\n        Suc k < n\\<rbrakk>\n       \\<Longrightarrow> ket_plus_k (Suc k) =\n                         Matrix.vec (2 ^ Suc (Suc k))\n                          (\\<lambda>l. 1 / csqrt (2 ^ Suc (Suc k)))", "have \"complex_of_real (sqrt (2 ^ (Suc k))) * complex_of_real (sqrt 2) = complex_of_real (sqrt (2 ^ (Suc (Suc k))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. complex_of_real (sqrt (2 ^ Suc k)) * complex_of_real (sqrt 2) =\n    complex_of_real (sqrt (2 ^ Suc (Suc k)))", "by (metis of_real_mult power_Suc power_commutes real_sqrt_power)"], ["proof (state)\nthis:\n  complex_of_real (sqrt (2 ^ Suc k)) * complex_of_real (sqrt 2) =\n  complex_of_real (sqrt (2 ^ Suc (Suc k)))\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < n \\<Longrightarrow>\n                ket_plus_k k =\n                Matrix.vec (2 ^ Suc k) (\\<lambda>l. 1 / csqrt (2 ^ Suc k));\n        Suc k < n\\<rbrakk>\n       \\<Longrightarrow> ket_plus_k (Suc k) =\n                         Matrix.vec (2 ^ Suc (Suc k))\n                          (\\<lambda>l. 1 / csqrt (2 ^ Suc (Suc k)))", "ultimately"], ["proof (chain)\npicking this:\n  csqrt (2 ^ Suc k) = complex_of_real (sqrt (2 ^ Suc k))\n  complex_of_real (sqrt (2 ^ Suc k)) * complex_of_real (sqrt 2) =\n  complex_of_real (sqrt (2 ^ Suc (Suc k)))", "have \"csqrt (2 ^ (Suc k)) * csqrt 2 = csqrt (2 ^ (Suc (Suc k)))\""], ["proof (prove)\nusing this:\n  csqrt (2 ^ Suc k) = complex_of_real (sqrt (2 ^ Suc k))\n  complex_of_real (sqrt (2 ^ Suc k)) * complex_of_real (sqrt 2) =\n  complex_of_real (sqrt (2 ^ Suc (Suc k)))\n\ngoal (1 subgoal):\n 1. csqrt (2 ^ Suc k) * csqrt 2 = csqrt (2 ^ Suc (Suc k))", "by auto"], ["proof (state)\nthis:\n  csqrt (2 ^ Suc k) * csqrt 2 = csqrt (2 ^ Suc (Suc k))\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < n \\<Longrightarrow>\n                ket_plus_k k =\n                Matrix.vec (2 ^ Suc k) (\\<lambda>l. 1 / csqrt (2 ^ Suc k));\n        Suc k < n\\<rbrakk>\n       \\<Longrightarrow> ket_plus_k (Suc k) =\n                         Matrix.vec (2 ^ Suc (Suc k))\n                          (\\<lambda>l. 1 / csqrt (2 ^ Suc (Suc k)))", "moreover"], ["proof (state)\nthis:\n  csqrt (2 ^ Suc k) * csqrt 2 = csqrt (2 ^ Suc (Suc k))\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < n \\<Longrightarrow>\n                ket_plus_k k =\n                Matrix.vec (2 ^ Suc k) (\\<lambda>l. 1 / csqrt (2 ^ Suc k));\n        Suc k < n\\<rbrakk>\n       \\<Longrightarrow> ket_plus_k (Suc k) =\n                         Matrix.vec (2 ^ Suc (Suc k))\n                          (\\<lambda>l. 1 / csqrt (2 ^ Suc (Suc k)))", "have \"1 / csqrt (2 ^ Suc k) * 1 / csqrt 2 = 1 / (csqrt (2 ^ (Suc k)) * csqrt 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 / csqrt (2 ^ Suc k) * 1 / csqrt 2 = 1 / (csqrt (2 ^ Suc k) * csqrt 2)", "by simp"], ["proof (state)\nthis:\n  1 / csqrt (2 ^ Suc k) * 1 / csqrt 2 = 1 / (csqrt (2 ^ Suc k) * csqrt 2)\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < n \\<Longrightarrow>\n                ket_plus_k k =\n                Matrix.vec (2 ^ Suc k) (\\<lambda>l. 1 / csqrt (2 ^ Suc k));\n        Suc k < n\\<rbrakk>\n       \\<Longrightarrow> ket_plus_k (Suc k) =\n                         Matrix.vec (2 ^ Suc (Suc k))\n                          (\\<lambda>l. 1 / csqrt (2 ^ Suc (Suc k)))", "ultimately"], ["proof (chain)\npicking this:\n  csqrt (2 ^ Suc k) * csqrt 2 = csqrt (2 ^ Suc (Suc k))\n  1 / csqrt (2 ^ Suc k) * 1 / csqrt 2 = 1 / (csqrt (2 ^ Suc k) * csqrt 2)", "have csqrt2p :\"1 / csqrt (2 ^ Suc k) * 1 / csqrt 2 = 1 / (csqrt (2 ^ (Suc (Suc k))))\""], ["proof (prove)\nusing this:\n  csqrt (2 ^ Suc k) * csqrt 2 = csqrt (2 ^ Suc (Suc k))\n  1 / csqrt (2 ^ Suc k) * 1 / csqrt 2 = 1 / (csqrt (2 ^ Suc k) * csqrt 2)\n\ngoal (1 subgoal):\n 1. 1 / csqrt (2 ^ Suc k) * 1 / csqrt 2 = 1 / csqrt (2 ^ Suc (Suc k))", "by simp"], ["proof (state)\nthis:\n  1 / csqrt (2 ^ Suc k) * 1 / csqrt 2 = 1 / csqrt (2 ^ Suc (Suc k))\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < n \\<Longrightarrow>\n                ket_plus_k k =\n                Matrix.vec (2 ^ Suc k) (\\<lambda>l. 1 / csqrt (2 ^ Suc k));\n        Suc k < n\\<rbrakk>\n       \\<Longrightarrow> ket_plus_k (Suc k) =\n                         Matrix.vec (2 ^ Suc (Suc k))\n                          (\\<lambda>l. 1 / csqrt (2 ^ Suc (Suc k)))", "have std: \"st.d = 2^(Suc (Suc k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. st.d = 2 ^ Suc (Suc k)", "unfolding st.d_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. prod_list (replicate (Suc (Suc k)) 2) = 2 ^ Suc (Suc k)", "by auto"], ["proof (state)\nthis:\n  st.d = 2 ^ Suc (Suc k)\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < n \\<Longrightarrow>\n                ket_plus_k k =\n                Matrix.vec (2 ^ Suc k) (\\<lambda>l. 1 / csqrt (2 ^ Suc k));\n        Suc k < n\\<rbrakk>\n       \\<Longrightarrow> ket_plus_k (Suc k) =\n                         Matrix.vec (2 ^ Suc (Suc k))\n                          (\\<lambda>l. 1 / csqrt (2 ^ Suc (Suc k)))", "have nthsSSk2: \"nths (replicate (Suc (Suc k)) 2) {0..<Suc k} = replicate (Suc k) 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nths (replicate (Suc (Suc k)) (2::'a)) {0..<Suc k} =\n    replicate (Suc k) (2::'a)", "unfolding nths_replicate[of \"Suc (Suc k)\" 2 \"{0..<Suc k}\"]"], ["proof (prove)\ngoal (1 subgoal):\n 1. replicate (card {i. i < Suc (Suc k) \\<and> i \\<in> {0..<Suc k}})\n     (2::'a) =\n    replicate (Suc k) (2::'a)", "by (smt Collect_cong \\<open>{card {0..<x} |x. x \\<in> {0..<Suc k}} = {0..<Suc k}\\<close> atLeastLessThan_iff card_atLeastLessThan diff_zero less_SucI)"], ["proof (state)\nthis:\n  nths (replicate (Suc (Suc k)) (2::?'a5)) {0..<Suc k} =\n  replicate (Suc k) (2::?'a5)\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < n \\<Longrightarrow>\n                ket_plus_k k =\n                Matrix.vec (2 ^ Suc k) (\\<lambda>l. 1 / csqrt (2 ^ Suc k));\n        Suc k < n\\<rbrakk>\n       \\<Longrightarrow> ket_plus_k (Suc k) =\n                         Matrix.vec (2 ^ Suc (Suc k))\n                          (\\<lambda>l. 1 / csqrt (2 ^ Suc (Suc k)))", "then"], ["proof (chain)\npicking this:\n  nths (replicate (Suc (Suc k)) (2::?'a5)) {0..<Suc k} =\n  replicate (Suc k) (2::?'a5)", "have std1: \"st.d1 = 2^(Suc k)\""], ["proof (prove)\nusing this:\n  nths (replicate (Suc (Suc k)) (2::?'a5)) {0..<Suc k} =\n  replicate (Suc k) (2::?'a5)\n\ngoal (1 subgoal):\n 1. st.d1 = 2 ^ Suc k", "unfolding st.d1_def st.dims1_def nthsSSk2"], ["proof (prove)\nusing this:\n  replicate (Suc k) (2::?'a5) = replicate (Suc k) (2::?'a5)\n\ngoal (1 subgoal):\n 1. prod_list (replicate (Suc k) 2) = 2 ^ Suc k", "by auto"], ["proof (state)\nthis:\n  st.d1 = 2 ^ Suc k\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < n \\<Longrightarrow>\n                ket_plus_k k =\n                Matrix.vec (2 ^ Suc k) (\\<lambda>l. 1 / csqrt (2 ^ Suc k));\n        Suc k < n\\<rbrakk>\n       \\<Longrightarrow> ket_plus_k (Suc k) =\n                         Matrix.vec (2 ^ Suc (Suc k))\n                          (\\<lambda>l. 1 / csqrt (2 ^ Suc (Suc k)))", "have \"{i. i < Suc (Suc k) \\<and> i \\<in> {Suc k..}} = {Suc k}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {i. i < Suc (Suc k) \\<and> i \\<in> {Suc k..}} = {Suc k}", "by auto"], ["proof (state)\nthis:\n  {i. i < Suc (Suc k) \\<and> i \\<in> {Suc k..}} = {Suc k}\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < n \\<Longrightarrow>\n                ket_plus_k k =\n                Matrix.vec (2 ^ Suc k) (\\<lambda>l. 1 / csqrt (2 ^ Suc k));\n        Suc k < n\\<rbrakk>\n       \\<Longrightarrow> ket_plus_k (Suc k) =\n                         Matrix.vec (2 ^ Suc (Suc k))\n                          (\\<lambda>l. 1 / csqrt (2 ^ Suc (Suc k)))", "then"], ["proof (chain)\npicking this:\n  {i. i < Suc (Suc k) \\<and> i \\<in> {Suc k..}} = {Suc k}", "have \"nths (replicate (Suc (Suc k)) 2) ({Suc k..}) = replicate 1 2\""], ["proof (prove)\nusing this:\n  {i. i < Suc (Suc k) \\<and> i \\<in> {Suc k..}} = {Suc k}\n\ngoal (1 subgoal):\n 1. nths (replicate (Suc (Suc k)) (2::'a)) {Suc k..} = replicate 1 (2::'a)", "unfolding nths_replicate"], ["proof (prove)\nusing this:\n  {i. i < Suc (Suc k) \\<and> i \\<in> {Suc k..}} = {Suc k}\n\ngoal (1 subgoal):\n 1. replicate (card {i. i < Suc (Suc k) \\<and> i \\<in> {Suc k..}}) (2::'a) =\n    replicate 1 (2::'a)", "by auto"], ["proof (state)\nthis:\n  nths (replicate (Suc (Suc k)) (2::?'a6)) {Suc k..} = replicate 1 (2::?'a6)\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < n \\<Longrightarrow>\n                ket_plus_k k =\n                Matrix.vec (2 ^ Suc k) (\\<lambda>l. 1 / csqrt (2 ^ Suc k));\n        Suc k < n\\<rbrakk>\n       \\<Longrightarrow> ket_plus_k (Suc k) =\n                         Matrix.vec (2 ^ Suc (Suc k))\n                          (\\<lambda>l. 1 / csqrt (2 ^ Suc (Suc k)))", "moreover"], ["proof (state)\nthis:\n  nths (replicate (Suc (Suc k)) (2::?'a6)) {Suc k..} = replicate 1 (2::?'a6)\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < n \\<Longrightarrow>\n                ket_plus_k k =\n                Matrix.vec (2 ^ Suc k) (\\<lambda>l. 1 / csqrt (2 ^ Suc k));\n        Suc k < n\\<rbrakk>\n       \\<Longrightarrow> ket_plus_k (Suc k) =\n                         Matrix.vec (2 ^ Suc (Suc k))\n                          (\\<lambda>l. 1 / csqrt (2 ^ Suc (Suc k)))", "have \"(- {0..<Suc k}) = {Suc k..}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - {0..<Suc k} = {Suc k..}", "by auto"], ["proof (state)\nthis:\n  - {0..<Suc k} = {Suc k..}\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < n \\<Longrightarrow>\n                ket_plus_k k =\n                Matrix.vec (2 ^ Suc k) (\\<lambda>l. 1 / csqrt (2 ^ Suc k));\n        Suc k < n\\<rbrakk>\n       \\<Longrightarrow> ket_plus_k (Suc k) =\n                         Matrix.vec (2 ^ Suc (Suc k))\n                          (\\<lambda>l. 1 / csqrt (2 ^ Suc (Suc k)))", "ultimately"], ["proof (chain)\npicking this:\n  nths (replicate (Suc (Suc k)) (2::?'a6)) {Suc k..} = replicate 1 (2::?'a6)\n  - {0..<Suc k} = {Suc k..}", "have nthsSSk2c: \"nths (replicate (Suc (Suc k)) 2) (- {0..<Suc k}) = replicate 1 2\""], ["proof (prove)\nusing this:\n  nths (replicate (Suc (Suc k)) (2::?'a6)) {Suc k..} = replicate 1 (2::?'a6)\n  - {0..<Suc k} = {Suc k..}\n\ngoal (1 subgoal):\n 1. nths (replicate (Suc (Suc k)) (2::'a)) (- {0..<Suc k}) =\n    replicate 1 (2::'a)", "by auto"], ["proof (state)\nthis:\n  nths (replicate (Suc (Suc k)) (2::?'a7)) (- {0..<Suc k}) =\n  replicate 1 (2::?'a7)\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < n \\<Longrightarrow>\n                ket_plus_k k =\n                Matrix.vec (2 ^ Suc k) (\\<lambda>l. 1 / csqrt (2 ^ Suc k));\n        Suc k < n\\<rbrakk>\n       \\<Longrightarrow> ket_plus_k (Suc k) =\n                         Matrix.vec (2 ^ Suc (Suc k))\n                          (\\<lambda>l. 1 / csqrt (2 ^ Suc (Suc k)))", "have std2: \"st.d2 = 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. st.d2 = 2", "unfolding st.d2_def st.dims2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. prod_list (nths (replicate (Suc (Suc k)) 2) (- {0..<Suc k})) = 2", "apply (subst nthsSSk2c)"], ["proof (prove)\ngoal (1 subgoal):\n 1. prod_list (replicate 1 2) = 2", "by auto"], ["proof (state)\nthis:\n  st.d2 = 2\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < n \\<Longrightarrow>\n                ket_plus_k k =\n                Matrix.vec (2 ^ Suc k) (\\<lambda>l. 1 / csqrt (2 ^ Suc k));\n        Suc k < n\\<rbrakk>\n       \\<Longrightarrow> ket_plus_k (Suc k) =\n                         Matrix.vec (2 ^ Suc (Suc k))\n                          (\\<lambda>l. 1 / csqrt (2 ^ Suc (Suc k)))", "have \"st.encode1 i < st.d1\" if \"i < st.d\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. st.encode1 i < st.d1", "using that st.encode1_lt[OF that]"], ["proof (prove)\nusing this:\n  i < st.d\n  st.encode1 i < st.d1\n\ngoal (1 subgoal):\n 1. st.encode1 i < st.d1", "by auto"], ["proof (state)\nthis:\n  ?i7 < st.d \\<Longrightarrow> st.encode1 ?i7 < st.d1\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < n \\<Longrightarrow>\n                ket_plus_k k =\n                Matrix.vec (2 ^ Suc k) (\\<lambda>l. 1 / csqrt (2 ^ Suc k));\n        Suc k < n\\<rbrakk>\n       \\<Longrightarrow> ket_plus_k (Suc k) =\n                         Matrix.vec (2 ^ Suc (Suc k))\n                          (\\<lambda>l. 1 / csqrt (2 ^ Suc (Suc k)))", "then"], ["proof (chain)\npicking this:\n  ?i7 < st.d \\<Longrightarrow> st.encode1 ?i7 < st.d1", "have kpkki: \"ket_plus_k k $ st.encode1 i = 1 / csqrt (2^(Suc k))\" if \"i < st.d\" for i"], ["proof (prove)\nusing this:\n  ?i7 < st.d \\<Longrightarrow> st.encode1 ?i7 < st.d1\n\ngoal (1 subgoal):\n 1. ket_plus_k k $ st.encode1 i = 1 / csqrt (2 ^ Suc k)", "unfolding kpkk std1"], ["proof (prove)\nusing this:\n  ?i7 < st.d \\<Longrightarrow> st.encode1 ?i7 < 2 ^ Suc k\n\ngoal (1 subgoal):\n 1. Matrix.vec (2 ^ Suc k) (\\<lambda>l. 1 / csqrt (2 ^ Suc k)) $\n    st.encode1 i =\n    1 / csqrt (2 ^ Suc k)", "using that"], ["proof (prove)\nusing this:\n  ?i7 < st.d \\<Longrightarrow> st.encode1 ?i7 < 2 ^ Suc k\n  i < st.d\n\ngoal (1 subgoal):\n 1. Matrix.vec (2 ^ Suc k) (\\<lambda>l. 1 / csqrt (2 ^ Suc k)) $\n    st.encode1 i =\n    1 / csqrt (2 ^ Suc k)", "by auto"], ["proof (state)\nthis:\n  ?i7 < st.d \\<Longrightarrow>\n  ket_plus_k k $ st.encode1 ?i7 = 1 / csqrt (2 ^ Suc k)\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < n \\<Longrightarrow>\n                ket_plus_k k =\n                Matrix.vec (2 ^ Suc k) (\\<lambda>l. 1 / csqrt (2 ^ Suc k));\n        Suc k < n\\<rbrakk>\n       \\<Longrightarrow> ket_plus_k (Suc k) =\n                         Matrix.vec (2 ^ Suc (Suc k))\n                          (\\<lambda>l. 1 / csqrt (2 ^ Suc (Suc k)))", "have \"st.encode2 i < st.d2\" if \"i < st.d\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. st.encode2 i < st.d2", "using that st.encode2_lt[OF that]"], ["proof (prove)\nusing this:\n  i < st.d\n  st.encode2 i < st.d2\n\ngoal (1 subgoal):\n 1. st.encode2 i < st.d2", "by auto"], ["proof (state)\nthis:\n  ?i7 < st.d \\<Longrightarrow> st.encode2 ?i7 < st.d2\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < n \\<Longrightarrow>\n                ket_plus_k k =\n                Matrix.vec (2 ^ Suc k) (\\<lambda>l. 1 / csqrt (2 ^ Suc k));\n        Suc k < n\\<rbrakk>\n       \\<Longrightarrow> ket_plus_k (Suc k) =\n                         Matrix.vec (2 ^ Suc (Suc k))\n                          (\\<lambda>l. 1 / csqrt (2 ^ Suc (Suc k)))", "then"], ["proof (chain)\npicking this:\n  ?i7 < st.d \\<Longrightarrow> st.encode2 ?i7 < st.d2", "have kpi: \"ket_plus $ st.encode2 i = 1 / csqrt 2\" if \"i < st.d\" for i"], ["proof (prove)\nusing this:\n  ?i7 < st.d \\<Longrightarrow> st.encode2 ?i7 < st.d2\n\ngoal (1 subgoal):\n 1. ket_plus $ st.encode2 i = 1 / csqrt 2", "unfolding ket_plus_def std2"], ["proof (prove)\nusing this:\n  ?i7 < st.d \\<Longrightarrow> st.encode2 ?i7 < 2\n\ngoal (1 subgoal):\n 1. Matrix.vec 2 (\\<lambda>k. 1 / csqrt 2) $ st.encode2 i = 1 / csqrt 2", "using that"], ["proof (prove)\nusing this:\n  ?i7 < st.d \\<Longrightarrow> st.encode2 ?i7 < 2\n  i < st.d\n\ngoal (1 subgoal):\n 1. Matrix.vec 2 (\\<lambda>k. 1 / csqrt 2) $ st.encode2 i = 1 / csqrt 2", "by auto"], ["proof (state)\nthis:\n  ?i7 < st.d \\<Longrightarrow> ket_plus $ st.encode2 ?i7 = 1 / csqrt 2\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < n \\<Longrightarrow>\n                ket_plus_k k =\n                Matrix.vec (2 ^ Suc k) (\\<lambda>l. 1 / csqrt (2 ^ Suc k));\n        Suc k < n\\<rbrakk>\n       \\<Longrightarrow> ket_plus_k (Suc k) =\n                         Matrix.vec (2 ^ Suc (Suc k))\n                          (\\<lambda>l. 1 / csqrt (2 ^ Suc (Suc k)))", "have kzkki: \"ket_plus_k (Suc k) $ i = 1 / (csqrt (2 ^ (Suc (Suc k))))\" if \"i < st.d\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. ket_plus_k (Suc k) $ i = 1 / csqrt (2 ^ Suc (Suc k))", "unfolding ket_plus_k.simps st2pvsttv st.tensor_vec_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Matrix.vec st.d\n     (\\<lambda>i. ket_plus_k k $ st.encode1 i * ket_plus $ st.encode2 i) $\n    i =\n    1 / csqrt (2 ^ Suc (Suc k))", "using csqrt2p kpkki kpi that"], ["proof (prove)\nusing this:\n  1 / csqrt (2 ^ Suc k) * 1 / csqrt 2 = 1 / csqrt (2 ^ Suc (Suc k))\n  ?i7 < st.d \\<Longrightarrow>\n  ket_plus_k k $ st.encode1 ?i7 = 1 / csqrt (2 ^ Suc k)\n  ?i7 < st.d \\<Longrightarrow> ket_plus $ st.encode2 ?i7 = 1 / csqrt 2\n  i < st.d\n\ngoal (1 subgoal):\n 1. Matrix.vec st.d\n     (\\<lambda>i. ket_plus_k k $ st.encode1 i * ket_plus $ st.encode2 i) $\n    i =\n    1 / csqrt (2 ^ Suc (Suc k))", "by auto"], ["proof (state)\nthis:\n  ?i7 < st.d \\<Longrightarrow>\n  ket_plus_k (Suc k) $ ?i7 = 1 / csqrt (2 ^ Suc (Suc k))\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < n \\<Longrightarrow>\n                ket_plus_k k =\n                Matrix.vec (2 ^ Suc k) (\\<lambda>l. 1 / csqrt (2 ^ Suc k));\n        Suc k < n\\<rbrakk>\n       \\<Longrightarrow> ket_plus_k (Suc k) =\n                         Matrix.vec (2 ^ Suc (Suc k))\n                          (\\<lambda>l. 1 / csqrt (2 ^ Suc (Suc k)))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. ket_plus_k (Suc k) =\n    Matrix.vec (2 ^ Suc (Suc k)) (\\<lambda>l. 1 / csqrt (2 ^ Suc (Suc k)))", "apply (rule eq_vecI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i.\n       i < dim_vec\n            (Matrix.vec (2 ^ Suc (Suc k))\n              (\\<lambda>l. 1 / csqrt (2 ^ Suc (Suc k)))) \\<Longrightarrow>\n       ket_plus_k (Suc k) $ i =\n       Matrix.vec (2 ^ Suc (Suc k))\n        (\\<lambda>l. 1 / csqrt (2 ^ Suc (Suc k))) $\n       i\n 2. dim_vec (ket_plus_k (Suc k)) =\n    dim_vec\n     (Matrix.vec (2 ^ Suc (Suc k))\n       (\\<lambda>l. 1 / csqrt (2 ^ Suc (Suc k))))", "subgoal for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. i < dim_vec\n         (Matrix.vec (2 ^ Suc (Suc k))\n           (\\<lambda>l. 1 / csqrt (2 ^ Suc (Suc k)))) \\<Longrightarrow>\n    ket_plus_k (Suc k) $ i =\n    Matrix.vec (2 ^ Suc (Suc k)) (\\<lambda>l. 1 / csqrt (2 ^ Suc (Suc k))) $\n    i", "using kzkki"], ["proof (prove)\nusing this:\n  ?i7 < st.d \\<Longrightarrow>\n  ket_plus_k (Suc k) $ ?i7 = 1 / csqrt (2 ^ Suc (Suc k))\n\ngoal (1 subgoal):\n 1. i < dim_vec\n         (Matrix.vec (2 ^ Suc (Suc k))\n           (\\<lambda>l. 1 / csqrt (2 ^ Suc (Suc k)))) \\<Longrightarrow>\n    ket_plus_k (Suc k) $ i =\n    Matrix.vec (2 ^ Suc (Suc k)) (\\<lambda>l. 1 / csqrt (2 ^ Suc (Suc k))) $\n    i", "unfolding std"], ["proof (prove)\nusing this:\n  ?i7 < 2 ^ Suc (Suc k) \\<Longrightarrow>\n  ket_plus_k (Suc k) $ ?i7 = 1 / csqrt (2 ^ Suc (Suc k))\n\ngoal (1 subgoal):\n 1. i < dim_vec\n         (Matrix.vec (2 ^ Suc (Suc k))\n           (\\<lambda>l. 1 / csqrt (2 ^ Suc (Suc k)))) \\<Longrightarrow>\n    ket_plus_k (Suc k) $ i =\n    Matrix.vec (2 ^ Suc (Suc k)) (\\<lambda>l. 1 / csqrt (2 ^ Suc (Suc k))) $\n    i", "by auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_vec (ket_plus_k (Suc k)) =\n    dim_vec\n     (Matrix.vec (2 ^ Suc (Suc k))\n       (\\<lambda>l. 1 / csqrt (2 ^ Suc (Suc k))))", "using carrier_vecD[OF dSk]"], ["proof (prove)\nusing this:\n  dim_vec (ket_plus_k (Suc k)) = 2 ^ Suc (Suc k)\n\ngoal (1 subgoal):\n 1. dim_vec (ket_plus_k (Suc k)) =\n    dim_vec\n     (Matrix.vec (2 ^ Suc (Suc k))\n       (\\<lambda>l. 1 / csqrt (2 ^ Suc (Suc k))))", "by auto"], ["proof (state)\nthis:\n  ket_plus_k (Suc k) =\n  Matrix.vec (2 ^ Suc (Suc k)) (\\<lambda>l. 1 / csqrt (2 ^ Suc (Suc k)))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma exH_k_mult_pre_is_psi:\n  \"exH_k (n - 1) *\\<^sub>v ket_pre = \\<psi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exH_k (n - 1) *\\<^sub>v ket_pre = \\<psi>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. exH_k (n - 1) *\\<^sub>v ket_pre = \\<psi>", "have \"exH_k (n - 1) = H_k (n - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exH_k (n - 1) = H_k (n - 1)", "using exH_eq_H"], ["proof (prove)\nusing this:\n  exH_k (n - 1) = H_k (n - 1)\n\ngoal (1 subgoal):\n 1. exH_k (n - 1) = H_k (n - 1)", "by auto"], ["proof (state)\nthis:\n  exH_k (n - 1) = H_k (n - 1)\n\ngoal (1 subgoal):\n 1. exH_k (n - 1) *\\<^sub>v ket_pre = \\<psi>", "moreover"], ["proof (state)\nthis:\n  exH_k (n - 1) = H_k (n - 1)\n\ngoal (1 subgoal):\n 1. exH_k (n - 1) *\\<^sub>v ket_pre = \\<psi>", "have \"ket_zero_k (n - 1) = ket_pre\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ket_zero_k (n - 1) = ket_pre", "using ket_zero_k_decode[of \"n - 1\"] ket_pre_def N_def n"], ["proof (prove)\nusing this:\n  n - 1 < n \\<Longrightarrow>\n  ket_zero_k (n - 1) =\n  Matrix.vec (2 ^ Suc (n - 1)) (\\<lambda>k. if k = 0 then 1 else 0)\n  ket_pre = Matrix.vec N (\\<lambda>k. if k = 0 then 1 else 0)\n  N = 2 ^ n\n  1 < n\n\ngoal (1 subgoal):\n 1. ket_zero_k (n - 1) = ket_pre", "by auto"], ["proof (state)\nthis:\n  ket_zero_k (n - 1) = ket_pre\n\ngoal (1 subgoal):\n 1. exH_k (n - 1) *\\<^sub>v ket_pre = \\<psi>", "moreover"], ["proof (state)\nthis:\n  ket_zero_k (n - 1) = ket_pre\n\ngoal (1 subgoal):\n 1. exH_k (n - 1) *\\<^sub>v ket_pre = \\<psi>", "have \"ket_plus_k (n - 1) = \\<psi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ket_plus_k (n - 1) = \\<psi>", "using ket_plus_k_decode[of \"n - 1\"] \\<psi>_def N_def n"], ["proof (prove)\nusing this:\n  n - 1 < n \\<Longrightarrow>\n  ket_plus_k (n - 1) =\n  Matrix.vec (2 ^ Suc (n - 1)) (\\<lambda>l. 1 / csqrt (2 ^ Suc (n - 1)))\n  \\<psi> = Matrix.vec N (\\<lambda>x. complex_of_real (1 / sqrt (real N)))\n  N = 2 ^ n\n  1 < n\n\ngoal (1 subgoal):\n 1. ket_plus_k (n - 1) = \\<psi>", "by auto"], ["proof (state)\nthis:\n  ket_plus_k (n - 1) = \\<psi>\n\ngoal (1 subgoal):\n 1. exH_k (n - 1) *\\<^sub>v ket_pre = \\<psi>", "moreover"], ["proof (state)\nthis:\n  ket_plus_k (n - 1) = \\<psi>\n\ngoal (1 subgoal):\n 1. exH_k (n - 1) *\\<^sub>v ket_pre = \\<psi>", "have \"H_k (n - 1) *\\<^sub>v ket_zero_k (n - 1) = ket_plus_k (n - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. H_k (n - 1) *\\<^sub>v ket_zero_k (n - 1) = ket_plus_k (n - 1)", "using H_k_ket_zero_k n"], ["proof (prove)\nusing this:\n  ?k < n \\<Longrightarrow> H_k ?k *\\<^sub>v ket_zero_k ?k = ket_plus_k ?k\n  1 < n\n\ngoal (1 subgoal):\n 1. H_k (n - 1) *\\<^sub>v ket_zero_k (n - 1) = ket_plus_k (n - 1)", "by auto"], ["proof (state)\nthis:\n  H_k (n - 1) *\\<^sub>v ket_zero_k (n - 1) = ket_plus_k (n - 1)\n\ngoal (1 subgoal):\n 1. exH_k (n - 1) *\\<^sub>v ket_pre = \\<psi>", "ultimately"], ["proof (chain)\npicking this:\n  exH_k (n - 1) = H_k (n - 1)\n  ket_zero_k (n - 1) = ket_pre\n  ket_plus_k (n - 1) = \\<psi>\n  H_k (n - 1) *\\<^sub>v ket_zero_k (n - 1) = ket_plus_k (n - 1)", "show ?thesis"], ["proof (prove)\nusing this:\n  exH_k (n - 1) = H_k (n - 1)\n  ket_zero_k (n - 1) = ket_pre\n  ket_plus_k (n - 1) = \\<psi>\n  H_k (n - 1) *\\<^sub>v ket_zero_k (n - 1) = ket_plus_k (n - 1)\n\ngoal (1 subgoal):\n 1. exH_k (n - 1) *\\<^sub>v ket_pre = \\<psi>", "by auto"], ["proof (state)\nthis:\n  exH_k (n - 1) *\\<^sub>v ket_pre = \\<psi>\n\ngoal:\nNo subgoals!", "qed"], ["", "definition ket_k :: \"nat \\<Rightarrow> complex vec\" where\n  \"ket_k x = Matrix.vec K (\\<lambda>k. if k = x then 1 else 0)\""], ["", "lemma ket_k_dim:\n  \"ket_k k \\<in> carrier_vec K\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ket_k k \\<in> carrier_vec K", "unfolding ket_k_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Matrix.vec K (\\<lambda>ka. if ka = k then 1 else 0) \\<in> carrier_vec K", "by auto"], ["", "lemma mat_incr_mult_ket_k:\n  \"k < K \\<Longrightarrow> (mat_incr K) *\\<^sub>v (ket_k k) = (ket_k ((k + 1) mod K))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k < K \\<Longrightarrow>\n    mat_incr K *\\<^sub>v ket_k k = ket_k ((k + 1) mod K)", "apply (rule eq_vecI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>k < K; i < dim_vec (ket_k ((k + 1) mod K))\\<rbrakk>\n       \\<Longrightarrow> (mat_incr K *\\<^sub>v ket_k k) $ i =\n                         ket_k ((k + 1) mod K) $ i\n 2. k < K \\<Longrightarrow>\n    dim_vec (mat_incr K *\\<^sub>v ket_k k) = dim_vec (ket_k ((k + 1) mod K))", "unfolding mat_incr_def ket_k_def"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>k < K;\n        i < dim_vec\n             (Matrix.vec K\n               (\\<lambda>ka. if ka = (k + 1) mod K then 1 else 0))\\<rbrakk>\n       \\<Longrightarrow> (mat K K\n                           (\\<lambda>(i, j).\n                               if i = 0 then if j = K - 1 then 1 else 0\n                               else if i = j + 1 then 1 else 0) *\\<^sub>v\n                          Matrix.vec K\n                           (\\<lambda>ka. if ka = k then 1 else 0)) $\n                         i =\n                         Matrix.vec K\n                          (\\<lambda>ka.\n                              if ka = (k + 1) mod K then 1 else 0) $\n                         i\n 2. k < K \\<Longrightarrow>\n    dim_vec\n     (mat K K\n       (\\<lambda>(i, j).\n           if i = 0 then if j = K - 1 then 1 else 0\n           else if i = j + 1 then 1 else 0) *\\<^sub>v\n      Matrix.vec K (\\<lambda>ka. if ka = k then 1 else 0)) =\n    dim_vec\n     (Matrix.vec K (\\<lambda>ka. if ka = (k + 1) mod K then 1 else 0))", "apply (simp add: scalar_prod_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>k < K; i < K\\<rbrakk>\n       \\<Longrightarrow> (i = Suc k mod K \\<longrightarrow>\n                          (\\<Sum>ia = 0..<K.\n                              (if Suc k mod K = 0\n                               then if ia = K - 1 then 1 else 0\n                               else if i = ia + 1 then 1 else 0) *\n                              (if ia = k then 1 else 0)) =\n                          1) \\<and>\n                         (i \\<noteq> Suc k mod K \\<longrightarrow>\n                          (\\<Sum>ia = 0..<K.\n                              (if i = 0 then if ia = K - 1 then 1 else 0\n                               else if i = ia + 1 then 1 else 0) *\n                              (if ia = k then 1 else 0)) =\n                          0)\n 2. k < K \\<Longrightarrow>\n    dim_vec\n     (mat K K\n       (\\<lambda>(i, j).\n           if i = 0 then if j = K - 1 then 1 else 0\n           else if i = j + 1 then 1 else 0) *\\<^sub>v\n      Matrix.vec K (\\<lambda>ka. if ka = k then 1 else 0)) =\n    dim_vec\n     (Matrix.vec K (\\<lambda>ka. if ka = (k + 1) mod K then 1 else 0))", "apply (case_tac \"k = K - 1\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>k < K; i < K; k = K - 1\\<rbrakk>\n       \\<Longrightarrow> (i = Suc k mod K \\<longrightarrow>\n                          (\\<Sum>ia = 0..<K.\n                              (if Suc k mod K = 0\n                               then if ia = K - 1 then 1 else 0\n                               else if i = ia + 1 then 1 else 0) *\n                              (if ia = k then 1 else 0)) =\n                          1) \\<and>\n                         (i \\<noteq> Suc k mod K \\<longrightarrow>\n                          (\\<Sum>ia = 0..<K.\n                              (if i = 0 then if ia = K - 1 then 1 else 0\n                               else if i = ia + 1 then 1 else 0) *\n                              (if ia = k then 1 else 0)) =\n                          0)\n 2. \\<And>i.\n       \\<lbrakk>k < K; i < K; k \\<noteq> K - 1\\<rbrakk>\n       \\<Longrightarrow> (i = Suc k mod K \\<longrightarrow>\n                          (\\<Sum>ia = 0..<K.\n                              (if Suc k mod K = 0\n                               then if ia = K - 1 then 1 else 0\n                               else if i = ia + 1 then 1 else 0) *\n                              (if ia = k then 1 else 0)) =\n                          1) \\<and>\n                         (i \\<noteq> Suc k mod K \\<longrightarrow>\n                          (\\<Sum>ia = 0..<K.\n                              (if i = 0 then if ia = K - 1 then 1 else 0\n                               else if i = ia + 1 then 1 else 0) *\n                              (if ia = k then 1 else 0)) =\n                          0)\n 3. k < K \\<Longrightarrow>\n    dim_vec\n     (mat K K\n       (\\<lambda>(i, j).\n           if i = 0 then if j = K - 1 then 1 else 0\n           else if i = j + 1 then 1 else 0) *\\<^sub>v\n      Matrix.vec K (\\<lambda>ka. if ka = k then 1 else 0)) =\n    dim_vec\n     (Matrix.vec K (\\<lambda>ka. if ka = (k + 1) mod K then 1 else 0))", "subgoal for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>k < K; i < K; k = K - 1\\<rbrakk>\n    \\<Longrightarrow> (i = Suc k mod K \\<longrightarrow>\n                       (\\<Sum>ia = 0..<K.\n                           (if Suc k mod K = 0\n                            then if ia = K - 1 then 1 else 0\n                            else if i = ia + 1 then 1 else 0) *\n                           (if ia = k then 1 else 0)) =\n                       1) \\<and>\n                      (i \\<noteq> Suc k mod K \\<longrightarrow>\n                       (\\<Sum>ia = 0..<K.\n                           (if i = 0 then if ia = K - 1 then 1 else 0\n                            else if i = ia + 1 then 1 else 0) *\n                           (if ia = k then 1 else 0)) =\n                       0)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < K; k = K - Suc 0; i = 0\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>i = 0..<K.\n                          (if i = K - Suc 0 then 1 else 0) *\n                          (if i = K - Suc 0 then 1 else 0)) =\n                      1", "by (simp add: sum_only_one_neq_0[of _ \"K - 1\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>k < K; i < K; k \\<noteq> K - 1\\<rbrakk>\n       \\<Longrightarrow> (i = Suc k mod K \\<longrightarrow>\n                          (\\<Sum>ia = 0..<K.\n                              (if Suc k mod K = 0\n                               then if ia = K - 1 then 1 else 0\n                               else if i = ia + 1 then 1 else 0) *\n                              (if ia = k then 1 else 0)) =\n                          1) \\<and>\n                         (i \\<noteq> Suc k mod K \\<longrightarrow>\n                          (\\<Sum>ia = 0..<K.\n                              (if i = 0 then if ia = K - 1 then 1 else 0\n                               else if i = ia + 1 then 1 else 0) *\n                              (if ia = k then 1 else 0)) =\n                          0)\n 2. k < K \\<Longrightarrow>\n    dim_vec\n     (mat K K\n       (\\<lambda>(i, j).\n           if i = 0 then if j = K - 1 then 1 else 0\n           else if i = j + 1 then 1 else 0) *\\<^sub>v\n      Matrix.vec K (\\<lambda>ka. if ka = k then 1 else 0)) =\n    dim_vec\n     (Matrix.vec K (\\<lambda>ka. if ka = (k + 1) mod K then 1 else 0))", "subgoal for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>k < K; i < K; k \\<noteq> K - 1\\<rbrakk>\n    \\<Longrightarrow> (i = Suc k mod K \\<longrightarrow>\n                       (\\<Sum>ia = 0..<K.\n                           (if Suc k mod K = 0\n                            then if ia = K - 1 then 1 else 0\n                            else if i = ia + 1 then 1 else 0) *\n                           (if ia = k then 1 else 0)) =\n                       1) \\<and>\n                      (i \\<noteq> Suc k mod K \\<longrightarrow>\n                       (\\<Sum>ia = 0..<K.\n                           (if i = 0 then if ia = K - 1 then 1 else 0\n                            else if i = ia + 1 then 1 else 0) *\n                           (if ia = k then 1 else 0)) =\n                       0)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Suc k < K; k \\<noteq> K - Suc 0; i = Suc k\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>i = 0..<K.\n                          (if k = i then 1 else 0) *\n                          (if i = k then 1 else 0)) =\n                      1", "by (simp add: sum_only_one_neq_0[of _ \"i - 1\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. k < K \\<Longrightarrow>\n    dim_vec\n     (mat K K\n       (\\<lambda>(i, j).\n           if i = 0 then if j = K - 1 then 1 else 0\n           else if i = j + 1 then 1 else 0) *\\<^sub>v\n      Matrix.vec K (\\<lambda>ka. if ka = k then 1 else 0)) =\n    dim_vec\n     (Matrix.vec K (\\<lambda>ka. if ka = (k + 1) mod K then 1 else 0))", "by auto"], ["", "definition proj_k where\n  \"proj_k x = proj (ket_k x)\""], ["", "lemma proj_k_dim:\n  \"proj_k k \\<in> carrier_mat K K\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proj_k k \\<in> carrier_mat K K", "unfolding proj_k_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. outer_prod (ket_k k) (ket_k k) \\<in> carrier_mat K K", "using ket_k_dim"], ["proof (prove)\nusing this:\n  ket_k ?k \\<in> carrier_vec K\n\ngoal (1 subgoal):\n 1. outer_prod (ket_k k) (ket_k k) \\<in> carrier_mat K K", "by auto"], ["", "lemma norm_ket_k_lt_K:\n  \"k < K \\<Longrightarrow> inner_prod (ket_k k) (ket_k k) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k < K \\<Longrightarrow> inner_prod (ket_k k) (ket_k k) = 1", "unfolding ket_k_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. k < K \\<Longrightarrow>\n    inner_prod (Matrix.vec K (\\<lambda>ka. if ka = k then 1 else 0))\n     (Matrix.vec K (\\<lambda>ka. if ka = k then 1 else 0)) =\n    1", "apply (simp add: scalar_prod_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. k < K \\<Longrightarrow>\n    (\\<Sum>i = 0..<K.\n        (if i = k then 1 else 0) * cnj (if i = k then 1 else 0)) =\n    1", "using sum_only_one_neq_0[of \"{0..<K}\" k \"\\<lambda>i. (if i = k then 1 else 0) * cnj (if i = k then 1 else 0)\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>finite {0..<K}; k \\<in> {0..<K};\n   \\<And>i.\n      \\<lbrakk>i \\<in> {0..<K}; i \\<noteq> k\\<rbrakk>\n      \\<Longrightarrow> (if i = k then 1 else 0) *\n                        cnj (if i = k then 1 else 0) =\n                        0\\<rbrakk>\n  \\<Longrightarrow> (\\<Sum>i = 0..<K.\n                        (if i = k then 1 else 0) *\n                        cnj (if i = k then 1 else 0)) =\n                    (if k = k then 1 else 0) * cnj (if k = k then 1 else 0)\n\ngoal (1 subgoal):\n 1. k < K \\<Longrightarrow>\n    (\\<Sum>i = 0..<K.\n        (if i = k then 1 else 0) * cnj (if i = k then 1 else 0)) =\n    1", "by auto"], ["", "lemma norm_ket_k_ge_K:\n  \"k \\<ge> K \\<Longrightarrow> inner_prod (ket_k k) (ket_k k) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. K \\<le> k \\<Longrightarrow> inner_prod (ket_k k) (ket_k k) = 0", "unfolding ket_k_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. K \\<le> k \\<Longrightarrow>\n    inner_prod (Matrix.vec K (\\<lambda>ka. if ka = k then 1 else 0))\n     (Matrix.vec K (\\<lambda>ka. if ka = k then 1 else 0)) =\n    0", "by (simp add: scalar_prod_def)"], ["", "lemma norm_ket_k:\n  \"inner_prod (ket_k k) (ket_k k) \\<le> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inner_prod (ket_k k) (ket_k k) \\<le> 1", "apply (case_tac \"k < K\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. k < K \\<Longrightarrow> inner_prod (ket_k k) (ket_k k) \\<le> 1\n 2. \\<not> k < K \\<Longrightarrow> inner_prod (ket_k k) (ket_k k) \\<le> 1", "using norm_ket_k_lt_K norm_ket_k_ge_K"], ["proof (prove)\nusing this:\n  ?k < K \\<Longrightarrow> inner_prod (ket_k ?k) (ket_k ?k) = 1\n  K \\<le> ?k \\<Longrightarrow> inner_prod (ket_k ?k) (ket_k ?k) = 0\n\ngoal (2 subgoals):\n 1. k < K \\<Longrightarrow> inner_prod (ket_k k) (ket_k k) \\<le> 1\n 2. \\<not> k < K \\<Longrightarrow> inner_prod (ket_k k) (ket_k k) \\<le> 1", "by auto"], ["", "lemma proj_k_mat:\n  assumes \"k < K\"\n  shows \"proj_k k = mat K K (\\<lambda>(i, j). if (i = j \\<and> i = k) then 1 else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proj_k k =\n    mat K K (\\<lambda>(i, j). if i = j \\<and> i = k then 1 else 0)", "apply (rule eq_matI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row\n                     (mat K K\n                       (\\<lambda>(i, j).\n                           if i = j \\<and> i = k then 1 else 0));\n        j < dim_col\n             (mat K K\n               (\\<lambda>(i, j).\n                   if i = j \\<and> i = k then 1 else 0))\\<rbrakk>\n       \\<Longrightarrow> proj_k k $$ (i, j) =\n                         mat K K\n                          (\\<lambda>(i, j).\n                              if i = j \\<and> i = k then 1 else 0) $$\n                         (i, j)\n 2. dim_row (proj_k k) =\n    dim_row (mat K K (\\<lambda>(i, j). if i = j \\<and> i = k then 1 else 0))\n 3. dim_col (proj_k k) =\n    dim_col (mat K K (\\<lambda>(i, j). if i = j \\<and> i = k then 1 else 0))", "apply (simp add: proj_k_def ket_k_def index_outer_prod)"], ["proof (prove)\ngoal (2 subgoals):\n 1. dim_row (proj_k k) =\n    dim_row (mat K K (\\<lambda>(i, j). if i = j \\<and> i = k then 1 else 0))\n 2. dim_col (proj_k k) =\n    dim_col (mat K K (\\<lambda>(i, j). if i = j \\<and> i = k then 1 else 0))", "using proj_k_dim"], ["proof (prove)\nusing this:\n  proj_k ?k \\<in> carrier_mat K K\n\ngoal (2 subgoals):\n 1. dim_row (proj_k k) =\n    dim_row (mat K K (\\<lambda>(i, j). if i = j \\<and> i = k then 1 else 0))\n 2. dim_col (proj_k k) =\n    dim_col (mat K K (\\<lambda>(i, j). if i = j \\<and> i = k then 1 else 0))", "by auto"], ["", "lemma positive_proj_k:\n  \"positive (proj_k k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. positive (proj_k k)", "using positive_same_outer_prod"], ["proof (prove)\nusing this:\n  ?v \\<in> carrier_vec ?n \\<Longrightarrow> positive (outer_prod ?v ?v)\n\ngoal (1 subgoal):\n 1. positive (proj_k k)", "unfolding proj_k_def ket_k_def"], ["proof (prove)\nusing this:\n  ?v \\<in> carrier_vec ?n \\<Longrightarrow> positive (outer_prod ?v ?v)\n\ngoal (1 subgoal):\n 1. positive\n     (outer_prod (Matrix.vec K (\\<lambda>ka. if ka = k then 1 else 0))\n       (Matrix.vec K (\\<lambda>ka. if ka = k then 1 else 0)))", "by auto"], ["", "lemma proj_k_le_one:\n  \"(proj_k k) \\<le>\\<^sub>L 1\\<^sub>m K\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proj_k k \\<le>\\<^sub>L 1\\<^sub>m K", "unfolding proj_k_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. outer_prod (ket_k k) (ket_k k) \\<le>\\<^sub>L 1\\<^sub>m K", "using outer_prod_le_one norm_ket_k ket_k_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>?v \\<in> carrier_vec ?n; inner_prod ?v ?v \\<le> 1\\<rbrakk>\n  \\<Longrightarrow> outer_prod ?v ?v \\<le>\\<^sub>L 1\\<^sub>m ?n\n  inner_prod (ket_k ?k) (ket_k ?k) \\<le> 1\n  ket_k ?x = Matrix.vec K (\\<lambda>k. if k = ?x then 1 else 0)\n\ngoal (1 subgoal):\n 1. outer_prod (ket_k k) (ket_k k) \\<le>\\<^sub>L 1\\<^sub>m K", "by auto"], ["", "definition proj_psi where\n  \"proj_psi = proj \\<psi>\""], ["", "lemma proj_psi_dim:\n  \"proj_psi \\<in> carrier_mat N N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proj_psi \\<in> carrier_mat N N", "unfolding proj_psi_def \\<psi>_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. outer_prod\n     (Matrix.vec N (\\<lambda>x. complex_of_real (1 / sqrt (real N))))\n     (Matrix.vec N (\\<lambda>x. complex_of_real (1 / sqrt (real N))))\n    \\<in> carrier_mat N N", "by auto"], ["", "lemma norm_psi:\n  \"inner_prod \\<psi> \\<psi> = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inner_prod \\<psi> \\<psi> = 1", "apply (simp add: \\<psi>_eval scalar_prod_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. of_nat N =\n    complex_of_real (sqrt (real N)) * complex_of_real (sqrt (real N))", "by (metis norm_of_nat norm_of_real of_real_mult of_real_of_nat_eq real_sqrt_mult_self)"], ["", "lemma proj_psi_mat:\n  \"proj_psi = mat N N (\\<lambda>k. 1 / N)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proj_psi = mat N N (\\<lambda>x. complex_of_real (1 / real N))", "unfolding proj_psi_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. outer_prod \\<psi> \\<psi> =\n    mat N N (\\<lambda>x. complex_of_real (1 / real N))", "apply (rule eq_matI, simp_all)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < N; j < N\\<rbrakk>\n       \\<Longrightarrow> outer_prod \\<psi> \\<psi> $$ (i, j) = 1 / of_nat N\n 2. dim_row (outer_prod \\<psi> \\<psi>) = N\n 3. dim_col (outer_prod \\<psi> \\<psi>) = N", "apply (simp add: \\<psi>_def index_outer_prod)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < N; j < N\\<rbrakk>\n       \\<Longrightarrow> complex_of_real (sqrt (real N)) *\n                         complex_of_real (sqrt (real N)) =\n                         of_nat N\n 2. dim_row (outer_prod \\<psi> \\<psi>) = N\n 3. dim_col (outer_prod \\<psi> \\<psi>) = N", "apply (smt of_nat_less_0_iff of_real_of_nat_eq of_real_power power2_eq_square real_sqrt_pow2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. dim_row (outer_prod \\<psi> \\<psi>) = N\n 2. dim_col (outer_prod \\<psi> \\<psi>) = N", "by (auto simp add: carrier_matD[OF outer_prod_dim[OF \\<psi>_dim(1) \\<psi>_dim(1)]])"], ["", "lemma hermitian_proj_psi:\n  \"hermitian proj_psi\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hermitian proj_psi", "unfolding hermitian_def proj_psi_mat"], ["proof (prove)\ngoal (1 subgoal):\n 1. adjoint (mat N N (\\<lambda>x. complex_of_real (1 / real N))) =\n    mat N N (\\<lambda>x. complex_of_real (1 / real N))", "apply (rule eq_matI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row\n                     (mat N N (\\<lambda>x. complex_of_real (1 / real N)));\n        j < dim_col\n             (mat N N (\\<lambda>x. complex_of_real (1 / real N)))\\<rbrakk>\n       \\<Longrightarrow> adjoint\n                          (mat N N\n                            (\\<lambda>x. complex_of_real (1 / real N))) $$\n                         (i, j) =\n                         mat N N\n                          (\\<lambda>x. complex_of_real (1 / real N)) $$\n                         (i, j)\n 2. dim_row (adjoint (mat N N (\\<lambda>x. complex_of_real (1 / real N)))) =\n    dim_row (mat N N (\\<lambda>x. complex_of_real (1 / real N)))\n 3. dim_col (adjoint (mat N N (\\<lambda>x. complex_of_real (1 / real N)))) =\n    dim_col (mat N N (\\<lambda>x. complex_of_real (1 / real N)))", "by (auto simp add: adjoint_eval)"], ["", "lemma hermitian_exproj_psi:\n  \"hermitian (tensor_P proj_psi (1\\<^sub>m K))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hermitian (tensor_P proj_psi (1\\<^sub>m K))", "unfolding ps2_P.ptensor_mat_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. hermitian (ps_P.tensor_mat proj_psi (1\\<^sub>m K))", "apply (subst ps_P.tensor_mat_hermitian)"], ["proof (prove)\ngoal (5 subgoals):\n 1. proj_psi \\<in> carrier_mat ps_P.d1 ps_P.d1\n 2. 1\\<^sub>m K \\<in> carrier_mat ps_P.d2 ps_P.d2\n 3. hermitian proj_psi\n 4. hermitian (1\\<^sub>m K)\n 5. True", "using proj_psi_dim ps_P_d1 ps_P_d2 hermitian_proj_psi hermitian_one"], ["proof (prove)\nusing this:\n  proj_psi \\<in> carrier_mat N N\n  ps_P.d1 = N\n  ps_P.d2 = K\n  hermitian proj_psi\n  hermitian (1\\<^sub>m ?n)\n\ngoal (5 subgoals):\n 1. proj_psi \\<in> carrier_mat ps_P.d1 ps_P.d1\n 2. 1\\<^sub>m K \\<in> carrier_mat ps_P.d2 ps_P.d2\n 3. hermitian proj_psi\n 4. hermitian (1\\<^sub>m K)\n 5. True", "by auto"], ["", "lemma proj_psi_is_projection:\n  \"proj_psi * proj_psi = proj_psi\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proj_psi * proj_psi = proj_psi", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. proj_psi * proj_psi = proj_psi", "have \"proj_psi * proj_psi = inner_prod \\<psi> \\<psi> \\<cdot>\\<^sub>m proj_psi\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proj_psi * proj_psi = inner_prod \\<psi> \\<psi> \\<cdot>\\<^sub>m proj_psi", "unfolding proj_psi_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. outer_prod \\<psi> \\<psi> * outer_prod \\<psi> \\<psi> =\n    inner_prod \\<psi> \\<psi> \\<cdot>\\<^sub>m outer_prod \\<psi> \\<psi>", "apply (subst outer_prod_mult_outer_prod)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<psi> \\<in> carrier_vec ?d1.0\n 2. \\<psi> \\<in> carrier_vec ?d2.0\n 3. \\<psi> \\<in> carrier_vec ?d3.0\n 4. inner_prod \\<psi> \\<psi> \\<cdot>\\<^sub>m outer_prod \\<psi> \\<psi> =\n    inner_prod \\<psi> \\<psi> \\<cdot>\\<^sub>m outer_prod \\<psi> \\<psi>", "using  \\<psi>_def"], ["proof (prove)\nusing this:\n  \\<psi> = Matrix.vec N (\\<lambda>x. complex_of_real (1 / sqrt (real N)))\n\ngoal (4 subgoals):\n 1. \\<psi> \\<in> carrier_vec ?d1.0\n 2. \\<psi> \\<in> carrier_vec ?d2.0\n 3. \\<psi> \\<in> carrier_vec ?d3.0\n 4. inner_prod \\<psi> \\<psi> \\<cdot>\\<^sub>m outer_prod \\<psi> \\<psi> =\n    inner_prod \\<psi> \\<psi> \\<cdot>\\<^sub>m outer_prod \\<psi> \\<psi>", "by auto"], ["proof (state)\nthis:\n  proj_psi * proj_psi = inner_prod \\<psi> \\<psi> \\<cdot>\\<^sub>m proj_psi\n\ngoal (1 subgoal):\n 1. proj_psi * proj_psi = proj_psi", "also"], ["proof (state)\nthis:\n  proj_psi * proj_psi = inner_prod \\<psi> \\<psi> \\<cdot>\\<^sub>m proj_psi\n\ngoal (1 subgoal):\n 1. proj_psi * proj_psi = proj_psi", "have \"\\<dots> = proj_psi\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inner_prod \\<psi> \\<psi> \\<cdot>\\<^sub>m proj_psi = proj_psi", "using \\<psi>_inner"], ["proof (prove)\nusing this:\n  inner_prod \\<psi> \\<psi> = 1\n\ngoal (1 subgoal):\n 1. inner_prod \\<psi> \\<psi> \\<cdot>\\<^sub>m proj_psi = proj_psi", "by auto"], ["proof (state)\nthis:\n  inner_prod \\<psi> \\<psi> \\<cdot>\\<^sub>m proj_psi = proj_psi\n\ngoal (1 subgoal):\n 1. proj_psi * proj_psi = proj_psi", "finally"], ["proof (chain)\npicking this:\n  proj_psi * proj_psi = proj_psi", "show ?thesis"], ["proof (prove)\nusing this:\n  proj_psi * proj_psi = proj_psi\n\ngoal (1 subgoal):\n 1. proj_psi * proj_psi = proj_psi", "."], ["proof (state)\nthis:\n  proj_psi * proj_psi = proj_psi\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma proj_psi_trace:\n  \"trace (proj_psi) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace proj_psi = 1", "unfolding proj_psi_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. trace (outer_prod \\<psi> \\<psi>) = 1", "apply (subst trace_outer_prod[of _ N])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<psi> \\<in> carrier_vec N\n 2. inner_prod \\<psi> \\<psi> = 1", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<psi> \\<in> carrier_vec N", "unfolding \\<psi>_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Matrix.vec N (\\<lambda>x. complex_of_real (1 / sqrt (real N)))\n    \\<in> carrier_vec N", "by auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. inner_prod \\<psi> \\<psi> = 1", "using norm_psi"], ["proof (prove)\nusing this:\n  inner_prod \\<psi> \\<psi> = 1\n\ngoal (1 subgoal):\n 1. inner_prod \\<psi> \\<psi> = 1", "by auto"], ["", "lemma positive_proj_psi:\n  \"positive (proj_psi)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. positive proj_psi", "using positive_same_outer_prod"], ["proof (prove)\nusing this:\n  ?v \\<in> carrier_vec ?n \\<Longrightarrow> positive (outer_prod ?v ?v)\n\ngoal (1 subgoal):\n 1. positive proj_psi", "unfolding proj_psi_def \\<psi>_def"], ["proof (prove)\nusing this:\n  ?v \\<in> carrier_vec ?n \\<Longrightarrow> positive (outer_prod ?v ?v)\n\ngoal (1 subgoal):\n 1. positive\n     (outer_prod\n       (Matrix.vec N (\\<lambda>x. complex_of_real (1 / sqrt (real N))))\n       (Matrix.vec N (\\<lambda>x. complex_of_real (1 / sqrt (real N)))))", "by auto"], ["", "lemma proj_psi_le_one:\n  \"(proj_psi) \\<le>\\<^sub>L 1\\<^sub>m N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proj_psi \\<le>\\<^sub>L 1\\<^sub>m N", "unfolding proj_psi_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. outer_prod \\<psi> \\<psi> \\<le>\\<^sub>L 1\\<^sub>m N", "using outer_prod_le_one norm_psi \\<psi>_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>?v \\<in> carrier_vec ?n; inner_prod ?v ?v \\<le> 1\\<rbrakk>\n  \\<Longrightarrow> outer_prod ?v ?v \\<le>\\<^sub>L 1\\<^sub>m ?n\n  inner_prod \\<psi> \\<psi> = 1\n  \\<psi> = Matrix.vec N (\\<lambda>x. complex_of_real (1 / sqrt (real N)))\n\ngoal (1 subgoal):\n 1. outer_prod \\<psi> \\<psi> \\<le>\\<^sub>L 1\\<^sub>m N", "by auto"], ["", "lemma hermitian_hadamard_on_k:\n  assumes \"k < n\"\n  shows \"hermitian (hadamard_on_i k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hermitian (hadamard_on_i k)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. hermitian (hadamard_on_i k)", "interpret st2: partial_state2 dims \"{k}\" \"(vars1 - {k})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. partial_state2 {k} (vars1 - {k})", "apply unfold_locales"], ["proof (prove)\ngoal (1 subgoal):\n 1. {k} \\<inter> (vars1 - {k}) = {}", "by auto"], ["proof (state)\ngoal (1 subgoal):\n 1. hermitian (hadamard_on_i k)", "have st2d1: \"st2.dims1 = [2]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. st2.dims1 = [2]", "unfolding st2.dims1_def dims_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. partial_state2.dims1 (replicate n 2 @ [K]) {k} = [2]", "using assms dims_nths_one_lt_n local.dims_def st2.dims1_def"], ["proof (prove)\nusing this:\n  k < n\n  ?l < n \\<Longrightarrow> nths dims {?l} = [2]\n  dims = replicate n 2 @ [K]\n  st2.dims1 = nths dims {k}\n\ngoal (1 subgoal):\n 1. partial_state2.dims1 (replicate n 2 @ [K]) {k} = [2]", "by auto"], ["proof (state)\nthis:\n  st2.dims1 = [2]\n\ngoal (1 subgoal):\n 1. hermitian (hadamard_on_i k)", "show \"hermitian (hadamard_on_i k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hermitian (hadamard_on_i k)", "unfolding hadamard_on_i_def st2.pmat_extension_def st2.ptensor_mat_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. hermitian (tensor_mat st2.dims0 st2.vars1' hadamard (1\\<^sub>m st2.d2))", "apply (rule partial_state.tensor_mat_hermitian)"], ["proof (prove)\ngoal (4 subgoals):\n 1. hadamard\n    \\<in> carrier_mat (partial_state.d1 st2.dims0 st2.vars1')\n           (partial_state.d1 st2.dims0 st2.vars1')\n 2. 1\\<^sub>m st2.d2\n    \\<in> carrier_mat (partial_state.d2 st2.dims0 st2.vars1')\n           (partial_state.d2 st2.dims0 st2.vars1')\n 3. hermitian hadamard\n 4. hermitian (1\\<^sub>m st2.d2)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. hadamard\n    \\<in> carrier_mat (partial_state.d1 st2.dims0 st2.vars1')\n           (partial_state.d1 st2.dims0 st2.vars1')", "unfolding partial_state.d1_def partial_state.dims1_def st2.nths_vars1' hadamard_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat 2 2\n     (\\<lambda>(i, j).\n         if i = 0 \\<or> j = 0 then 1 / csqrt 2\n         else complex_of_real (- 1 / sqrt 2))\n    \\<in> carrier_mat (prod_list st2.dims1) (prod_list st2.dims1)", "by (simp add: st2d1)"], ["proof (prove)\ngoal (3 subgoals):\n 1. 1\\<^sub>m st2.d2\n    \\<in> carrier_mat (partial_state.d2 st2.dims0 st2.vars1')\n           (partial_state.d2 st2.dims0 st2.vars1')\n 2. hermitian hadamard\n 3. hermitian (1\\<^sub>m st2.d2)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1\\<^sub>m st2.d2\n    \\<in> carrier_mat (partial_state.d2 st2.dims0 st2.vars1')\n           (partial_state.d2 st2.dims0 st2.vars1')", "unfolding partial_state.d2_def partial_state.dims2_def st2.nths_vars2' st2.d2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1\\<^sub>m (prod_list st2.dims2)\n    \\<in> carrier_mat (prod_list st2.dims2) (prod_list st2.dims2)", "by auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. hermitian hadamard\n 2. hermitian (1\\<^sub>m st2.d2)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. hermitian hadamard", "unfolding hermitian_def hadamard_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. adjoint\n     (mat 2 2\n       (\\<lambda>(i, j).\n           if i = 0 \\<or> j = 0 then 1 / csqrt 2\n           else complex_of_real (- 1 / sqrt 2))) =\n    mat 2 2\n     (\\<lambda>(i, j).\n         if i = 0 \\<or> j = 0 then 1 / csqrt 2\n         else complex_of_real (- 1 / sqrt 2))", "apply (rule eq_matI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row\n                     (mat 2 2\n                       (\\<lambda>(i, j).\n                           if i = 0 \\<or> j = 0 then 1 / csqrt 2\n                           else complex_of_real (- 1 / sqrt 2)));\n        j < dim_col\n             (mat 2 2\n               (\\<lambda>(i, j).\n                   if i = 0 \\<or> j = 0 then 1 / csqrt 2\n                   else complex_of_real (- 1 / sqrt 2)))\\<rbrakk>\n       \\<Longrightarrow> adjoint\n                          (mat 2 2\n                            (\\<lambda>(i, j).\n                                if i = 0 \\<or> j = 0 then 1 / csqrt 2\n                                else complex_of_real (- 1 / sqrt 2))) $$\n                         (i, j) =\n                         mat 2 2\n                          (\\<lambda>(i, j).\n                              if i = 0 \\<or> j = 0 then 1 / csqrt 2\n                              else complex_of_real (- 1 / sqrt 2)) $$\n                         (i, j)\n 2. dim_row\n     (adjoint\n       (mat 2 2\n         (\\<lambda>(i, j).\n             if i = 0 \\<or> j = 0 then 1 / csqrt 2\n             else complex_of_real (- 1 / sqrt 2)))) =\n    dim_row\n     (mat 2 2\n       (\\<lambda>(i, j).\n           if i = 0 \\<or> j = 0 then 1 / csqrt 2\n           else complex_of_real (- 1 / sqrt 2)))\n 3. dim_col\n     (adjoint\n       (mat 2 2\n         (\\<lambda>(i, j).\n             if i = 0 \\<or> j = 0 then 1 / csqrt 2\n             else complex_of_real (- 1 / sqrt 2)))) =\n    dim_col\n     (mat 2 2\n       (\\<lambda>(i, j).\n           if i = 0 \\<or> j = 0 then 1 / csqrt 2\n           else complex_of_real (- 1 / sqrt 2)))", "by (auto simp add: adjoint_dim adjoint_eval)"], ["proof (prove)\ngoal (1 subgoal):\n 1. hermitian (1\\<^sub>m st2.d2)", "using hermitian_one"], ["proof (prove)\nusing this:\n  hermitian (1\\<^sub>m ?n)\n\ngoal (1 subgoal):\n 1. hermitian (1\\<^sub>m st2.d2)", "by auto"], ["proof (state)\nthis:\n  hermitian (hadamard_on_i k)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma hermitian_H_k:\n  \"k < n \\<Longrightarrow> hermitian (H_k k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k < n \\<Longrightarrow> hermitian (H_k k)", "proof (induct k)"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 < n \\<Longrightarrow> hermitian (H_k 0)\n 2. \\<And>k.\n       \\<lbrakk>k < n \\<Longrightarrow> hermitian (H_k k);\n        Suc k < n\\<rbrakk>\n       \\<Longrightarrow> hermitian (H_k (Suc k))", "case 0"], ["proof (state)\nthis:\n  0 < n\n\ngoal (2 subgoals):\n 1. 0 < n \\<Longrightarrow> hermitian (H_k 0)\n 2. \\<And>k.\n       \\<lbrakk>k < n \\<Longrightarrow> hermitian (H_k k);\n        Suc k < n\\<rbrakk>\n       \\<Longrightarrow> hermitian (H_k (Suc k))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. hermitian (H_k 0)", "unfolding H_k.simps hermitian_def hadamard_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. adjoint\n     (mat 2 2\n       (\\<lambda>(i, j).\n           if i = 0 \\<or> j = 0 then 1 / csqrt 2\n           else complex_of_real (- 1 / sqrt 2))) =\n    mat 2 2\n     (\\<lambda>(i, j).\n         if i = 0 \\<or> j = 0 then 1 / csqrt 2\n         else complex_of_real (- 1 / sqrt 2))", "apply (rule eq_matI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row\n                     (mat 2 2\n                       (\\<lambda>(i, j).\n                           if i = 0 \\<or> j = 0 then 1 / csqrt 2\n                           else complex_of_real (- 1 / sqrt 2)));\n        j < dim_col\n             (mat 2 2\n               (\\<lambda>(i, j).\n                   if i = 0 \\<or> j = 0 then 1 / csqrt 2\n                   else complex_of_real (- 1 / sqrt 2)))\\<rbrakk>\n       \\<Longrightarrow> adjoint\n                          (mat 2 2\n                            (\\<lambda>(i, j).\n                                if i = 0 \\<or> j = 0 then 1 / csqrt 2\n                                else complex_of_real (- 1 / sqrt 2))) $$\n                         (i, j) =\n                         mat 2 2\n                          (\\<lambda>(i, j).\n                              if i = 0 \\<or> j = 0 then 1 / csqrt 2\n                              else complex_of_real (- 1 / sqrt 2)) $$\n                         (i, j)\n 2. dim_row\n     (adjoint\n       (mat 2 2\n         (\\<lambda>(i, j).\n             if i = 0 \\<or> j = 0 then 1 / csqrt 2\n             else complex_of_real (- 1 / sqrt 2)))) =\n    dim_row\n     (mat 2 2\n       (\\<lambda>(i, j).\n           if i = 0 \\<or> j = 0 then 1 / csqrt 2\n           else complex_of_real (- 1 / sqrt 2)))\n 3. dim_col\n     (adjoint\n       (mat 2 2\n         (\\<lambda>(i, j).\n             if i = 0 \\<or> j = 0 then 1 / csqrt 2\n             else complex_of_real (- 1 / sqrt 2)))) =\n    dim_col\n     (mat 2 2\n       (\\<lambda>(i, j).\n           if i = 0 \\<or> j = 0 then 1 / csqrt 2\n           else complex_of_real (- 1 / sqrt 2)))", "by (auto simp add: adjoint_dim adjoint_eval)"], ["proof (state)\nthis:\n  hermitian (H_k 0)\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < n \\<Longrightarrow> hermitian (H_k k);\n        Suc k < n\\<rbrakk>\n       \\<Longrightarrow> hermitian (H_k (Suc k))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < n \\<Longrightarrow> hermitian (H_k k);\n        Suc k < n\\<rbrakk>\n       \\<Longrightarrow> hermitian (H_k (Suc k))", "case (Suc k)"], ["proof (state)\nthis:\n  k < n \\<Longrightarrow> hermitian (H_k k)\n  Suc k < n\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < n \\<Longrightarrow> hermitian (H_k k);\n        Suc k < n\\<rbrakk>\n       \\<Longrightarrow> hermitian (H_k (Suc k))", "interpret st2: partial_state2 dims \"{0..<Suc k}\" \"{Suc k}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. partial_state2 {0..<Suc k} {Suc k}", "apply unfold_locales"], ["proof (prove)\ngoal (1 subgoal):\n 1. {0..<Suc k} \\<inter> {Suc k} = {}", "by auto"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < n \\<Longrightarrow> hermitian (H_k k);\n        Suc k < n\\<rbrakk>\n       \\<Longrightarrow> hermitian (H_k (Suc k))", "have st2d1: \"prod_list st2.dims1 = (2^(Suc k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod_list st2.dims1 = 2 ^ Suc k", "unfolding st2.dims1_def dims_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. prod_list (partial_state2.dims1 (replicate n 2 @ [K]) {0..<Suc k}) =\n    2 ^ Suc k", "using Suc(2)"], ["proof (prove)\nusing this:\n  Suc k < n\n\ngoal (1 subgoal):\n 1. prod_list (partial_state2.dims1 (replicate n 2 @ [K]) {0..<Suc k}) =\n    2 ^ Suc k", "using dims_nths_le_n local.dims_def st2.dims1_def"], ["proof (prove)\nusing this:\n  Suc k < n\n  ?l \\<le> n \\<Longrightarrow> nths dims {0..<?l} = replicate ?l 2\n  dims = replicate n 2 @ [K]\n  st2.dims1 = nths dims {0..<Suc k}\n\ngoal (1 subgoal):\n 1. prod_list (partial_state2.dims1 (replicate n 2 @ [K]) {0..<Suc k}) =\n    2 ^ Suc k", "by auto"], ["proof (state)\nthis:\n  prod_list st2.dims1 = 2 ^ Suc k\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < n \\<Longrightarrow> hermitian (H_k k);\n        Suc k < n\\<rbrakk>\n       \\<Longrightarrow> hermitian (H_k (Suc k))", "have st2d2: \"st2.dims2 = [2]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. st2.dims2 = [2]", "unfolding st2.dims2_def dims_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. partial_state2.dims2 (replicate n 2 @ [K]) {Suc k} = [2]", "using Suc(2)"], ["proof (prove)\nusing this:\n  Suc k < n\n\ngoal (1 subgoal):\n 1. partial_state2.dims2 (replicate n 2 @ [K]) {Suc k} = [2]", "using dims_nths_one_lt_n local.dims_def st2.dims2_def"], ["proof (prove)\nusing this:\n  Suc k < n\n  ?l < n \\<Longrightarrow> nths dims {?l} = [2]\n  dims = replicate n 2 @ [K]\n  st2.dims2 = nths dims {Suc k}\n\ngoal (1 subgoal):\n 1. partial_state2.dims2 (replicate n 2 @ [K]) {Suc k} = [2]", "by auto"], ["proof (state)\nthis:\n  st2.dims2 = [2]\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < n \\<Longrightarrow> hermitian (H_k k);\n        Suc k < n\\<rbrakk>\n       \\<Longrightarrow> hermitian (H_k (Suc k))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. hermitian (H_k (Suc k))", "unfolding H_k.simps st2.ptensor_mat_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. hermitian (tensor_mat st2.dims0 st2.vars1' (H_k k) hadamard)", "apply (rule partial_state.tensor_mat_hermitian)"], ["proof (prove)\ngoal (4 subgoals):\n 1. H_k k\n    \\<in> carrier_mat (partial_state.d1 st2.dims0 st2.vars1')\n           (partial_state.d1 st2.dims0 st2.vars1')\n 2. hadamard\n    \\<in> carrier_mat (partial_state.d2 st2.dims0 st2.vars1')\n           (partial_state.d2 st2.dims0 st2.vars1')\n 3. hermitian (H_k k)\n 4. hermitian hadamard", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. H_k k\n    \\<in> carrier_mat (partial_state.d1 st2.dims0 st2.vars1')\n           (partial_state.d1 st2.dims0 st2.vars1')", "unfolding partial_state.d1_def partial_state.dims1_def st2.nths_vars1'"], ["proof (prove)\ngoal (1 subgoal):\n 1. H_k k \\<in> carrier_mat (prod_list st2.dims1) (prod_list st2.dims1)", "using st2d1 H_k_dim Suc"], ["proof (prove)\nusing this:\n  prod_list st2.dims1 = 2 ^ Suc k\n  ?k < n \\<Longrightarrow>\n  H_k ?k \\<in> carrier_mat (2 ^ Suc ?k) (2 ^ Suc ?k)\n  k < n \\<Longrightarrow> hermitian (H_k k)\n  Suc k < n\n\ngoal (1 subgoal):\n 1. H_k k \\<in> carrier_mat (prod_list st2.dims1) (prod_list st2.dims1)", "by auto"], ["proof (prove)\ngoal (3 subgoals):\n 1. hadamard\n    \\<in> carrier_mat (partial_state.d2 st2.dims0 st2.vars1')\n           (partial_state.d2 st2.dims0 st2.vars1')\n 2. hermitian (H_k k)\n 3. hermitian hadamard", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. hadamard\n    \\<in> carrier_mat (partial_state.d2 st2.dims0 st2.vars1')\n           (partial_state.d2 st2.dims0 st2.vars1')", "unfolding partial_state.d2_def partial_state.dims2_def st2.nths_vars2' st2.d2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. hadamard \\<in> carrier_mat (prod_list st2.dims2) (prod_list st2.dims2)", "using st2d2"], ["proof (prove)\nusing this:\n  st2.dims2 = [2]\n\ngoal (1 subgoal):\n 1. hadamard \\<in> carrier_mat (prod_list st2.dims2) (prod_list st2.dims2)", "by (simp add: hadamard_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. hermitian (H_k k)\n 2. hermitian hadamard", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. hermitian (H_k k)", "using Suc"], ["proof (prove)\nusing this:\n  k < n \\<Longrightarrow> hermitian (H_k k)\n  Suc k < n\n\ngoal (1 subgoal):\n 1. hermitian (H_k k)", "by auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. hermitian hadamard", "using hermitian_hadamard"], ["proof (prove)\nusing this:\n  hermitian hadamard\n\ngoal (1 subgoal):\n 1. hermitian hadamard", "by auto"], ["proof (state)\nthis:\n  hermitian (H_k (Suc k))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma unitary_H_k:\n  \"k < n \\<Longrightarrow> unitary (H_k k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k < n \\<Longrightarrow> unitary (H_k k)", "proof (induct k)"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 < n \\<Longrightarrow> unitary (H_k 0)\n 2. \\<And>k.\n       \\<lbrakk>k < n \\<Longrightarrow> unitary (H_k k); Suc k < n\\<rbrakk>\n       \\<Longrightarrow> unitary (H_k (Suc k))", "case 0"], ["proof (state)\nthis:\n  0 < n\n\ngoal (2 subgoals):\n 1. 0 < n \\<Longrightarrow> unitary (H_k 0)\n 2. \\<And>k.\n       \\<lbrakk>k < n \\<Longrightarrow> unitary (H_k k); Suc k < n\\<rbrakk>\n       \\<Longrightarrow> unitary (H_k (Suc k))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. unitary (H_k 0)", "using unitary_hadamard"], ["proof (prove)\nusing this:\n  unitary hadamard\n\ngoal (1 subgoal):\n 1. unitary (H_k 0)", "by auto"], ["proof (state)\nthis:\n  unitary (H_k 0)\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < n \\<Longrightarrow> unitary (H_k k); Suc k < n\\<rbrakk>\n       \\<Longrightarrow> unitary (H_k (Suc k))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < n \\<Longrightarrow> unitary (H_k k); Suc k < n\\<rbrakk>\n       \\<Longrightarrow> unitary (H_k (Suc k))", "case (Suc k)"], ["proof (state)\nthis:\n  k < n \\<Longrightarrow> unitary (H_k k)\n  Suc k < n\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < n \\<Longrightarrow> unitary (H_k k); Suc k < n\\<rbrakk>\n       \\<Longrightarrow> unitary (H_k (Suc k))", "then"], ["proof (chain)\npicking this:\n  k < n \\<Longrightarrow> unitary (H_k k)\n  Suc k < n", "have k: \"k < n\""], ["proof (prove)\nusing this:\n  k < n \\<Longrightarrow> unitary (H_k k)\n  Suc k < n\n\ngoal (1 subgoal):\n 1. k < n", "by auto"], ["proof (state)\nthis:\n  k < n\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < n \\<Longrightarrow> unitary (H_k k); Suc k < n\\<rbrakk>\n       \\<Longrightarrow> unitary (H_k (Suc k))", "interpret st2: partial_state2 dims \"{0..<Suc k}\" \"{Suc k}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. partial_state2 {0..<Suc k} {Suc k}", "by (unfold_locales, auto)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < n \\<Longrightarrow> unitary (H_k k); Suc k < n\\<rbrakk>\n       \\<Longrightarrow> unitary (H_k (Suc k))", "have st2d1: \"prod_list st2.dims1 = (2^(Suc k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod_list st2.dims1 = 2 ^ Suc k", "unfolding st2.dims1_def dims_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. prod_list (partial_state2.dims1 (replicate n 2 @ [K]) {0..<Suc k}) =\n    2 ^ Suc k", "using Suc(2)"], ["proof (prove)\nusing this:\n  Suc k < n\n\ngoal (1 subgoal):\n 1. prod_list (partial_state2.dims1 (replicate n 2 @ [K]) {0..<Suc k}) =\n    2 ^ Suc k", "using dims_nths_le_n local.dims_def st2.dims1_def"], ["proof (prove)\nusing this:\n  Suc k < n\n  ?l \\<le> n \\<Longrightarrow> nths dims {0..<?l} = replicate ?l 2\n  dims = replicate n 2 @ [K]\n  st2.dims1 = nths dims {0..<Suc k}\n\ngoal (1 subgoal):\n 1. prod_list (partial_state2.dims1 (replicate n 2 @ [K]) {0..<Suc k}) =\n    2 ^ Suc k", "by auto"], ["proof (state)\nthis:\n  prod_list st2.dims1 = 2 ^ Suc k\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < n \\<Longrightarrow> unitary (H_k k); Suc k < n\\<rbrakk>\n       \\<Longrightarrow> unitary (H_k (Suc k))", "have st2d2: \"st2.dims2 = [2]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. st2.dims2 = [2]", "unfolding st2.dims2_def dims_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. partial_state2.dims2 (replicate n 2 @ [K]) {Suc k} = [2]", "using Suc(2)"], ["proof (prove)\nusing this:\n  Suc k < n\n\ngoal (1 subgoal):\n 1. partial_state2.dims2 (replicate n 2 @ [K]) {Suc k} = [2]", "using dims_nths_one_lt_n local.dims_def st2.dims2_def"], ["proof (prove)\nusing this:\n  Suc k < n\n  ?l < n \\<Longrightarrow> nths dims {?l} = [2]\n  dims = replicate n 2 @ [K]\n  st2.dims2 = nths dims {Suc k}\n\ngoal (1 subgoal):\n 1. partial_state2.dims2 (replicate n 2 @ [K]) {Suc k} = [2]", "by auto"], ["proof (state)\nthis:\n  st2.dims2 = [2]\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < n \\<Longrightarrow> unitary (H_k k); Suc k < n\\<rbrakk>\n       \\<Longrightarrow> unitary (H_k (Suc k))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. unitary (H_k (Suc k))", "unfolding H_k.simps st2.ptensor_mat_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. unitary (tensor_mat st2.dims0 st2.vars1' (H_k k) hadamard)", "apply (rule partial_state.tensor_mat_unitary[of \"H_k k\" st2.dims0 st2.vars1' hadamard]  )"], ["proof (prove)\ngoal (4 subgoals):\n 1. H_k k\n    \\<in> carrier_mat (partial_state.d1 st2.dims0 st2.vars1')\n           (partial_state.d1 st2.dims0 st2.vars1')\n 2. hadamard\n    \\<in> carrier_mat (partial_state.d2 st2.dims0 st2.vars1')\n           (partial_state.d2 st2.dims0 st2.vars1')\n 3. unitary (H_k k)\n 4. unitary hadamard", "unfolding partial_state.d1_def partial_state.dims1_def st2.nths_vars1' partial_state.d2_def partial_state.dims2_def\n      st2.nths_vars2'"], ["proof (prove)\ngoal (4 subgoals):\n 1. H_k k \\<in> carrier_mat (prod_list st2.dims1) (prod_list st2.dims1)\n 2. hadamard \\<in> carrier_mat (prod_list st2.dims2) (prod_list st2.dims2)\n 3. unitary (H_k k)\n 4. unitary hadamard", "apply (auto simp add: st2d1 st2d2 )"], ["proof (prove)\ngoal (4 subgoals):\n 1. H_k k \\<in> carrier_mat (2 * 2 ^ k) (2 * 2 ^ k)\n 2. hadamard \\<in> carrier_mat 2 2\n 3. unitary (H_k k)\n 4. unitary hadamard", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. H_k k \\<in> carrier_mat (2 * 2 ^ k) (2 * 2 ^ k)", "using H_k_dim[OF k]"], ["proof (prove)\nusing this:\n  H_k k \\<in> carrier_mat (2 ^ Suc k) (2 ^ Suc k)\n\ngoal (1 subgoal):\n 1. H_k k \\<in> carrier_mat (2 * 2 ^ k) (2 * 2 ^ k)", "by auto"], ["proof (prove)\ngoal (3 subgoals):\n 1. hadamard \\<in> carrier_mat 2 2\n 2. unitary (H_k k)\n 3. unitary hadamard", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. hadamard \\<in> carrier_mat 2 2", "using hadamard_dim"], ["proof (prove)\nusing this:\n  hadamard \\<in> carrier_mat 2 2\n\ngoal (1 subgoal):\n 1. hadamard \\<in> carrier_mat 2 2", "by auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. unitary (H_k k)\n 2. unitary hadamard", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. unitary (H_k k)", "using Suc"], ["proof (prove)\nusing this:\n  k < n \\<Longrightarrow> unitary (H_k k)\n  Suc k < n\n\ngoal (1 subgoal):\n 1. unitary (H_k k)", "by auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. unitary hadamard", "using unitary_hadamard"], ["proof (prove)\nusing this:\n  unitary hadamard\n\ngoal (1 subgoal):\n 1. unitary hadamard", "by auto"], ["proof (state)\nthis:\n  unitary (H_k (Suc k))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma exH_k_dim:\n  shows \"k < n \\<Longrightarrow> exH_k k \\<in> carrier_mat N N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k < n \\<Longrightarrow> exH_k k \\<in> carrier_mat N N", "apply (induct k)"], ["proof (prove)\ngoal (2 subgoals):\n 1. 0 < n \\<Longrightarrow> exH_k 0 \\<in> carrier_mat N N\n 2. \\<And>k.\n       \\<lbrakk>k < n \\<Longrightarrow> exH_k k \\<in> carrier_mat N N;\n        Suc k < n\\<rbrakk>\n       \\<Longrightarrow> exH_k (Suc k) \\<in> carrier_mat N N", "using hadamard_on_i_dim"], ["proof (prove)\nusing this:\n  ?k < n \\<Longrightarrow> hadamard_on_i ?k \\<in> carrier_mat N N\n\ngoal (2 subgoals):\n 1. 0 < n \\<Longrightarrow> exH_k 0 \\<in> carrier_mat N N\n 2. \\<And>k.\n       \\<lbrakk>k < n \\<Longrightarrow> exH_k k \\<in> carrier_mat N N;\n        Suc k < n\\<rbrakk>\n       \\<Longrightarrow> exH_k (Suc k) \\<in> carrier_mat N N", "by auto"], ["", "lemma exH_n_dim:\n  shows \"exH_k (n - 1) \\<in> carrier_mat N N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exH_k (n - 1) \\<in> carrier_mat N N", "using exH_k_dim n"], ["proof (prove)\nusing this:\n  ?k < n \\<Longrightarrow> exH_k ?k \\<in> carrier_mat N N\n  1 < n\n\ngoal (1 subgoal):\n 1. exH_k (n - 1) \\<in> carrier_mat N N", "by auto"], ["", "lemma unitary_exH_k:\n  shows \"k < n \\<Longrightarrow> unitary (exH_k k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k < n \\<Longrightarrow> unitary (exH_k k)", "proof (induct k)"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 < n \\<Longrightarrow> unitary (exH_k 0)\n 2. \\<And>k.\n       \\<lbrakk>k < n \\<Longrightarrow> unitary (exH_k k);\n        Suc k < n\\<rbrakk>\n       \\<Longrightarrow> unitary (exH_k (Suc k))", "case 0"], ["proof (state)\nthis:\n  0 < n\n\ngoal (2 subgoals):\n 1. 0 < n \\<Longrightarrow> unitary (exH_k 0)\n 2. \\<And>k.\n       \\<lbrakk>k < n \\<Longrightarrow> unitary (exH_k k);\n        Suc k < n\\<rbrakk>\n       \\<Longrightarrow> unitary (exH_k (Suc k))", "then"], ["proof (chain)\npicking this:\n  0 < n", "show ?case"], ["proof (prove)\nusing this:\n  0 < n\n\ngoal (1 subgoal):\n 1. unitary (exH_k 0)", "unfolding exH_k.simps"], ["proof (prove)\nusing this:\n  0 < n\n\ngoal (1 subgoal):\n 1. unitary (hadamard_on_i 0)", "using unitary_hadamard_on_i 0"], ["proof (prove)\nusing this:\n  0 < n\n  ?k < n \\<Longrightarrow> unitary (hadamard_on_i ?k)\n  0 < n\n\ngoal (1 subgoal):\n 1. unitary (hadamard_on_i 0)", "by auto"], ["proof (state)\nthis:\n  unitary (exH_k 0)\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < n \\<Longrightarrow> unitary (exH_k k);\n        Suc k < n\\<rbrakk>\n       \\<Longrightarrow> unitary (exH_k (Suc k))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < n \\<Longrightarrow> unitary (exH_k k);\n        Suc k < n\\<rbrakk>\n       \\<Longrightarrow> unitary (exH_k (Suc k))", "case (Suc k)"], ["proof (state)\nthis:\n  k < n \\<Longrightarrow> unitary (exH_k k)\n  Suc k < n\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < n \\<Longrightarrow> unitary (exH_k k);\n        Suc k < n\\<rbrakk>\n       \\<Longrightarrow> unitary (exH_k (Suc k))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. unitary (exH_k (Suc k))", "unfolding exH_k.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. unitary (exH_k k * hadamard_on_i (Suc k))", "apply (subst unitary_times_unitary[of _ N])"], ["proof (prove)\ngoal (5 subgoals):\n 1. exH_k k \\<in> carrier_mat N N\n 2. hadamard_on_i (Suc k) \\<in> carrier_mat N N\n 3. unitary (exH_k k)\n 4. unitary (hadamard_on_i (Suc k))\n 5. True", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. exH_k k \\<in> carrier_mat N N", "using exH_k_dim Suc"], ["proof (prove)\nusing this:\n  ?k < n \\<Longrightarrow> exH_k ?k \\<in> carrier_mat N N\n  k < n \\<Longrightarrow> unitary (exH_k k)\n  Suc k < n\n\ngoal (1 subgoal):\n 1. exH_k k \\<in> carrier_mat N N", "by auto"], ["proof (prove)\ngoal (4 subgoals):\n 1. hadamard_on_i (Suc k) \\<in> carrier_mat N N\n 2. unitary (exH_k k)\n 3. unitary (hadamard_on_i (Suc k))\n 4. True", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. hadamard_on_i (Suc k) \\<in> carrier_mat N N", "using hadamard_on_i_dim Suc"], ["proof (prove)\nusing this:\n  ?k < n \\<Longrightarrow> hadamard_on_i ?k \\<in> carrier_mat N N\n  k < n \\<Longrightarrow> unitary (exH_k k)\n  Suc k < n\n\ngoal (1 subgoal):\n 1. hadamard_on_i (Suc k) \\<in> carrier_mat N N", "by auto"], ["proof (prove)\ngoal (3 subgoals):\n 1. unitary (exH_k k)\n 2. unitary (hadamard_on_i (Suc k))\n 3. True", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. unitary (exH_k k)", "using Suc"], ["proof (prove)\nusing this:\n  k < n \\<Longrightarrow> unitary (exH_k k)\n  Suc k < n\n\ngoal (1 subgoal):\n 1. unitary (exH_k k)", "by auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. unitary (hadamard_on_i (Suc k))\n 2. True", "using unitary_hadamard_on_i Suc"], ["proof (prove)\nusing this:\n  ?k < n \\<Longrightarrow> unitary (hadamard_on_i ?k)\n  k < n \\<Longrightarrow> unitary (exH_k k)\n  Suc k < n\n\ngoal (2 subgoals):\n 1. unitary (hadamard_on_i (Suc k))\n 2. True", "by auto"], ["proof (state)\nthis:\n  unitary (exH_k (Suc k))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma hermitian_exH_n:\n  \"hermitian (exH_k (n - 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hermitian (exH_k (n - 1))", "using hermitian_H_k exH_eq_H n"], ["proof (prove)\nusing this:\n  ?k < n \\<Longrightarrow> hermitian (H_k ?k)\n  exH_k (n - 1) = H_k (n - 1)\n  1 < n\n\ngoal (1 subgoal):\n 1. hermitian (exH_k (n - 1))", "by auto"], ["", "lemma exH_k_mult_psi_is_pre:\n  \"exH_k (n - 1) *\\<^sub>v \\<psi> = ket_pre\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exH_k (n - 1) *\\<^sub>v \\<psi> = ket_pre", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. exH_k (n - 1) *\\<^sub>v \\<psi> = ket_pre", "let ?H = \"exH_k (n - 1)\""], ["proof (state)\ngoal (1 subgoal):\n 1. exH_k (n - 1) *\\<^sub>v \\<psi> = ket_pre", "have \"hermitian ?H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hermitian (exH_k (n - 1))", "using hermitian_H_k exH_eq_H n"], ["proof (prove)\nusing this:\n  ?k < n \\<Longrightarrow> hermitian (H_k ?k)\n  exH_k (n - 1) = H_k (n - 1)\n  1 < n\n\ngoal (1 subgoal):\n 1. hermitian (exH_k (n - 1))", "by auto"], ["proof (state)\nthis:\n  hermitian (exH_k (n - 1))\n\ngoal (1 subgoal):\n 1. exH_k (n - 1) *\\<^sub>v \\<psi> = ket_pre", "then"], ["proof (chain)\npicking this:\n  hermitian (exH_k (n - 1))", "have eqad: \"adjoint ?H = ?H\""], ["proof (prove)\nusing this:\n  hermitian (exH_k (n - 1))\n\ngoal (1 subgoal):\n 1. adjoint (exH_k (n - 1)) = exH_k (n - 1)", "unfolding hermitian_def"], ["proof (prove)\nusing this:\n  adjoint (exH_k (n - 1)) = exH_k (n - 1)\n\ngoal (1 subgoal):\n 1. adjoint (exH_k (n - 1)) = exH_k (n - 1)", "by auto"], ["proof (state)\nthis:\n  adjoint (exH_k (n - 1)) = exH_k (n - 1)\n\ngoal (1 subgoal):\n 1. exH_k (n - 1) *\\<^sub>v \\<psi> = ket_pre", "have d: \"?H \\<in> carrier_mat N N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exH_k (n - 1) \\<in> carrier_mat N N", "using exH_k_dim n"], ["proof (prove)\nusing this:\n  ?k < n \\<Longrightarrow> exH_k ?k \\<in> carrier_mat N N\n  1 < n\n\ngoal (1 subgoal):\n 1. exH_k (n - 1) \\<in> carrier_mat N N", "by auto"], ["proof (state)\nthis:\n  exH_k (n - 1) \\<in> carrier_mat N N\n\ngoal (1 subgoal):\n 1. exH_k (n - 1) *\\<^sub>v \\<psi> = ket_pre", "have \"unitary ?H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unitary (exH_k (n - 1))", "using unitary_exH_k n"], ["proof (prove)\nusing this:\n  ?k < n \\<Longrightarrow> unitary (exH_k ?k)\n  1 < n\n\ngoal (1 subgoal):\n 1. unitary (exH_k (n - 1))", "by auto"], ["proof (state)\nthis:\n  unitary (exH_k (n - 1))\n\ngoal (1 subgoal):\n 1. exH_k (n - 1) *\\<^sub>v \\<psi> = ket_pre", "then"], ["proof (chain)\npicking this:\n  unitary (exH_k (n - 1))", "have id: \"?H * ?H = 1\\<^sub>m N\""], ["proof (prove)\nusing this:\n  unitary (exH_k (n - 1))\n\ngoal (1 subgoal):\n 1. exH_k (n - 1) * exH_k (n - 1) = 1\\<^sub>m N", "unfolding unitary_def inverts_mat_def"], ["proof (prove)\nusing this:\n  exH_k (n - 1)\n  \\<in> carrier_mat (dim_row (exH_k (n - 1)))\n         (dim_row (exH_k (n - 1))) \\<and>\n  exH_k (n - 1) * adjoint (exH_k (n - 1)) =\n  1\\<^sub>m (dim_row (exH_k (n - 1)))\n\ngoal (1 subgoal):\n 1. exH_k (n - 1) * exH_k (n - 1) = 1\\<^sub>m N", "using d"], ["proof (prove)\nusing this:\n  exH_k (n - 1)\n  \\<in> carrier_mat (dim_row (exH_k (n - 1)))\n         (dim_row (exH_k (n - 1))) \\<and>\n  exH_k (n - 1) * adjoint (exH_k (n - 1)) =\n  1\\<^sub>m (dim_row (exH_k (n - 1)))\n  exH_k (n - 1) \\<in> carrier_mat N N\n\ngoal (1 subgoal):\n 1. exH_k (n - 1) * exH_k (n - 1) = 1\\<^sub>m N", "apply (subst (2) eqad[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>exH_k (n - 1)\n             \\<in> carrier_mat (dim_row (exH_k (n - 1)))\n                    (dim_row (exH_k (n - 1))) \\<and>\n             exH_k (n - 1) * adjoint (exH_k (n - 1)) =\n             1\\<^sub>m (dim_row (exH_k (n - 1)));\n     exH_k (n - 1) \\<in> carrier_mat N N\\<rbrakk>\n    \\<Longrightarrow> exH_k (n - 1) * adjoint (exH_k (n - 1)) = 1\\<^sub>m N", "by auto"], ["proof (state)\nthis:\n  exH_k (n - 1) * exH_k (n - 1) = 1\\<^sub>m N\n\ngoal (1 subgoal):\n 1. exH_k (n - 1) *\\<^sub>v \\<psi> = ket_pre", "have \"?H *\\<^sub>v \\<psi> = ?H *\\<^sub>v (?H *\\<^sub>v ket_pre)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exH_k (n - 1) *\\<^sub>v \\<psi> =\n    exH_k (n - 1) *\\<^sub>v (exH_k (n - 1) *\\<^sub>v ket_pre)", "using exH_k_mult_pre_is_psi"], ["proof (prove)\nusing this:\n  exH_k (n - 1) *\\<^sub>v ket_pre = \\<psi>\n\ngoal (1 subgoal):\n 1. exH_k (n - 1) *\\<^sub>v \\<psi> =\n    exH_k (n - 1) *\\<^sub>v (exH_k (n - 1) *\\<^sub>v ket_pre)", "by auto"], ["proof (state)\nthis:\n  exH_k (n - 1) *\\<^sub>v \\<psi> =\n  exH_k (n - 1) *\\<^sub>v (exH_k (n - 1) *\\<^sub>v ket_pre)\n\ngoal (1 subgoal):\n 1. exH_k (n - 1) *\\<^sub>v \\<psi> = ket_pre", "also"], ["proof (state)\nthis:\n  exH_k (n - 1) *\\<^sub>v \\<psi> =\n  exH_k (n - 1) *\\<^sub>v (exH_k (n - 1) *\\<^sub>v ket_pre)\n\ngoal (1 subgoal):\n 1. exH_k (n - 1) *\\<^sub>v \\<psi> = ket_pre", "have \"\\<dots> = (?H * ?H) *\\<^sub>v ket_pre\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exH_k (n - 1) *\\<^sub>v (exH_k (n - 1) *\\<^sub>v ket_pre) =\n    exH_k (n - 1) * exH_k (n - 1) *\\<^sub>v ket_pre", "using d ket_pre_def"], ["proof (prove)\nusing this:\n  exH_k (n - 1) \\<in> carrier_mat N N\n  ket_pre = Matrix.vec N (\\<lambda>k. if k = 0 then 1 else 0)\n\ngoal (1 subgoal):\n 1. exH_k (n - 1) *\\<^sub>v (exH_k (n - 1) *\\<^sub>v ket_pre) =\n    exH_k (n - 1) * exH_k (n - 1) *\\<^sub>v ket_pre", "by auto"], ["proof (state)\nthis:\n  exH_k (n - 1) *\\<^sub>v (exH_k (n - 1) *\\<^sub>v ket_pre) =\n  exH_k (n - 1) * exH_k (n - 1) *\\<^sub>v ket_pre\n\ngoal (1 subgoal):\n 1. exH_k (n - 1) *\\<^sub>v \\<psi> = ket_pre", "also"], ["proof (state)\nthis:\n  exH_k (n - 1) *\\<^sub>v (exH_k (n - 1) *\\<^sub>v ket_pre) =\n  exH_k (n - 1) * exH_k (n - 1) *\\<^sub>v ket_pre\n\ngoal (1 subgoal):\n 1. exH_k (n - 1) *\\<^sub>v \\<psi> = ket_pre", "have \"\\<dots> = ket_pre\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exH_k (n - 1) * exH_k (n - 1) *\\<^sub>v ket_pre = ket_pre", "using id ket_pre_def"], ["proof (prove)\nusing this:\n  exH_k (n - 1) * exH_k (n - 1) = 1\\<^sub>m N\n  ket_pre = Matrix.vec N (\\<lambda>k. if k = 0 then 1 else 0)\n\ngoal (1 subgoal):\n 1. exH_k (n - 1) * exH_k (n - 1) *\\<^sub>v ket_pre = ket_pre", "by auto"], ["proof (state)\nthis:\n  exH_k (n - 1) * exH_k (n - 1) *\\<^sub>v ket_pre = ket_pre\n\ngoal (1 subgoal):\n 1. exH_k (n - 1) *\\<^sub>v \\<psi> = ket_pre", "finally"], ["proof (chain)\npicking this:\n  exH_k (n - 1) *\\<^sub>v \\<psi> = ket_pre", "show ?thesis"], ["proof (prove)\nusing this:\n  exH_k (n - 1) *\\<^sub>v \\<psi> = ket_pre\n\ngoal (1 subgoal):\n 1. exH_k (n - 1) *\\<^sub>v \\<psi> = ket_pre", "by auto"], ["proof (state)\nthis:\n  exH_k (n - 1) *\\<^sub>v \\<psi> = ket_pre\n\ngoal:\nNo subgoals!", "qed"], ["", "fun exexH_k :: \"nat \\<Rightarrow> complex mat\" where\n  \"exexH_k k = tensor_P (exH_k k) (1\\<^sub>m K)\""], ["", "lemma unitary_exexH_k:\n  \"k < n \\<Longrightarrow> unitary (exexH_k k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k < n \\<Longrightarrow> unitary (exexH_k k)", "unfolding exexH_k.simps ps2_P.ptensor_mat_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. k < n \\<Longrightarrow>\n    unitary (ps_P.tensor_mat (exH_k k) (1\\<^sub>m K))", "apply (subst partial_state.tensor_mat_unitary)"], ["proof (prove)\ngoal (5 subgoals):\n 1. k < n \\<Longrightarrow> exH_k k \\<in> carrier_mat ps_P.d1 ps_P.d1\n 2. k < n \\<Longrightarrow> 1\\<^sub>m K \\<in> carrier_mat ps_P.d2 ps_P.d2\n 3. k < n \\<Longrightarrow> unitary (exH_k k)\n 4. k < n \\<Longrightarrow> unitary (1\\<^sub>m K)\n 5. k < n \\<Longrightarrow> True", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. k < n \\<Longrightarrow> exH_k k \\<in> carrier_mat ps_P.d1 ps_P.d1", "using exH_k_dim"], ["proof (prove)\nusing this:\n  ?k < n \\<Longrightarrow> exH_k ?k \\<in> carrier_mat N N\n\ngoal (1 subgoal):\n 1. k < n \\<Longrightarrow> exH_k k \\<in> carrier_mat ps_P.d1 ps_P.d1", "unfolding partial_state.d1_def partial_state.dims1_def ps2_P.nths_vars1' ps2_P.dims1_def dims_vars1 N_def"], ["proof (prove)\nusing this:\n  ?k < n \\<Longrightarrow> exH_k ?k \\<in> carrier_mat (2 ^ n) (2 ^ n)\n\ngoal (1 subgoal):\n 1. k < n \\<Longrightarrow>\n    exH_k k\n    \\<in> carrier_mat (prod_list (replicate n 2))\n           (prod_list (replicate n 2))", "by auto"], ["proof (prove)\ngoal (4 subgoals):\n 1. k < n \\<Longrightarrow> 1\\<^sub>m K \\<in> carrier_mat ps_P.d2 ps_P.d2\n 2. k < n \\<Longrightarrow> unitary (exH_k k)\n 3. k < n \\<Longrightarrow> unitary (1\\<^sub>m K)\n 4. k < n \\<Longrightarrow> True", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. k < n \\<Longrightarrow> 1\\<^sub>m K \\<in> carrier_mat ps_P.d2 ps_P.d2", "unfolding partial_state.d2_def partial_state.dims2_def ps2_P.nths_vars2' ps2_P.dims2_def dims_vars2"], ["proof (prove)\ngoal (1 subgoal):\n 1. k < n \\<Longrightarrow>\n    1\\<^sub>m K \\<in> carrier_mat (prod_list [K]) (prod_list [K])", "by auto"], ["proof (prove)\ngoal (3 subgoals):\n 1. k < n \\<Longrightarrow> unitary (exH_k k)\n 2. k < n \\<Longrightarrow> unitary (1\\<^sub>m K)\n 3. k < n \\<Longrightarrow> True", "using unitary_exH_k unitary_one"], ["proof (prove)\nusing this:\n  ?k < n \\<Longrightarrow> unitary (exH_k ?k)\n  unitary (1\\<^sub>m ?n)\n\ngoal (3 subgoals):\n 1. k < n \\<Longrightarrow> unitary (exH_k k)\n 2. k < n \\<Longrightarrow> unitary (1\\<^sub>m K)\n 3. k < n \\<Longrightarrow> True", "by auto"], ["", "lemma exexH_k_dim:\n  \"k < n \\<Longrightarrow> exexH_k k \\<in> carrier_mat d d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k < n \\<Longrightarrow> exexH_k k \\<in> carrier_mat d d", "unfolding exexH_k.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. k < n \\<Longrightarrow>\n    tensor_P (exH_k k) (1\\<^sub>m K) \\<in> carrier_mat d d", "using ps2_P.ptensor_mat_carrier ps2_P_d0"], ["proof (prove)\nusing this:\n  tensor_P ?m1.0 ?m2.0 \\<in> carrier_mat ps2_P.d0 ps2_P.d0\n  ps2_P.d0 = d\n\ngoal (1 subgoal):\n 1. k < n \\<Longrightarrow>\n    tensor_P (exH_k k) (1\\<^sub>m K) \\<in> carrier_mat d d", "by auto"], ["", "lemma hoare_seq_utrans:\n  fixes P :: \"complex mat\"\n  assumes \"unitary U1\" and \"unitary U2\" and \"is_quantum_predicate P\"\n    and dU1: \"U1 \\<in> carrier_mat d d\" and dU2: \"U2 \\<in> carrier_mat d d\"\n  shows \"\n   \\<turnstile>\\<^sub>p \n   {adjoint (U2 * U1) * P * (U2 * U1)} \n   Utrans U1;; Utrans U2\n   {P}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>p {adjoint (U2 * U1) * P * (U2 * U1)}\n                         Utrans U1;; Utrans U2 {P}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>p {adjoint (U2 * U1) * P * (U2 * U1)}\n                         Utrans U1;; Utrans U2 {P}", "have hp0: \"\\<turnstile>\\<^sub>p {adjoint (U2) * P * (U2)} Utrans U2 {P}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>p {adjoint U2 * P * U2} Utrans U2 {P}", "using assms hoare_partial.intros"], ["proof (prove)\nusing this:\n  unitary U1\n  unitary U2\n  is_quantum_predicate P\n  U1 \\<in> carrier_mat d d\n  U2 \\<in> carrier_mat d d\n  is_quantum_predicate ?P \\<Longrightarrow>\n  \\<turnstile>\\<^sub>p {?P} SKIP {?P}\n  is_quantum_predicate ?P \\<Longrightarrow>\n  \\<turnstile>\\<^sub>p {adjoint ?U * ?P * ?U} Utrans ?U {?P}\n  \\<lbrakk>is_quantum_predicate ?P; is_quantum_predicate ?Q;\n   is_quantum_predicate ?R; \\<turnstile>\\<^sub>p {?P} ?S1.0 {?Q};\n   \\<turnstile>\\<^sub>p {?Q} ?S2.0 {?R}\\<rbrakk>\n  \\<Longrightarrow> \\<turnstile>\\<^sub>p {?P} ?S1.0;; ?S2.0 {?R}\n  \\<lbrakk>\\<And>k. k < ?n \\<Longrightarrow> is_quantum_predicate (?P k);\n   is_quantum_predicate ?Q;\n   \\<And>k.\n      k < ?n \\<Longrightarrow>\n      \\<turnstile>\\<^sub>p {?P k} ?S ! k {?Q}\\<rbrakk>\n  \\<Longrightarrow> \\<turnstile>\\<^sub>p {matrix_sum d\n     (\\<lambda>k. adjoint (?M k) * ?P k * ?M k) ?n}\n   Measure ?n ?M ?S {?Q}\n  \\<lbrakk>is_quantum_predicate ?P; is_quantum_predicate ?Q;\n   \\<turnstile>\\<^sub>p {?Q} ?S\n                        {adjoint (?M 0) * ?P * ?M 0 +\n                         adjoint (?M 1) * ?Q * ?M 1}\\<rbrakk>\n  \\<Longrightarrow> \\<turnstile>\\<^sub>p {adjoint (?M 0) * ?P * ?M 0 +\n    adjoint (?M 1) * ?Q * ?M 1}\n   While ?M ?S {?P}\n  \\<lbrakk>is_quantum_predicate ?P; is_quantum_predicate ?Q;\n   is_quantum_predicate ?P'; is_quantum_predicate ?Q'; ?P \\<le>\\<^sub>L ?P';\n   \\<turnstile>\\<^sub>p {?P'} ?S {?Q'}; ?Q' \\<le>\\<^sub>L ?Q\\<rbrakk>\n  \\<Longrightarrow> \\<turnstile>\\<^sub>p {?P} ?S {?Q}\n\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>p {adjoint U2 * P * U2} Utrans U2 {P}", "by auto"], ["proof (state)\nthis:\n  \\<turnstile>\\<^sub>p {adjoint U2 * P * U2} Utrans U2 {P}\n\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>p {adjoint (U2 * U1) * P * (U2 * U1)}\n                         Utrans U1;; Utrans U2 {P}", "have qp: \"is_quantum_predicate (adjoint (U2) * P * (U2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_quantum_predicate (adjoint U2 * P * U2)", "using qp_close_under_unitary_operator assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>?U \\<in> carrier_mat d d; unitary ?U;\n   is_quantum_predicate ?P\\<rbrakk>\n  \\<Longrightarrow> is_quantum_predicate (adjoint ?U * ?P * ?U)\n  unitary U1\n  unitary U2\n  is_quantum_predicate P\n  U1 \\<in> carrier_mat d d\n  U2 \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. is_quantum_predicate (adjoint U2 * P * U2)", "by auto"], ["proof (state)\nthis:\n  is_quantum_predicate (adjoint U2 * P * U2)\n\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>p {adjoint (U2 * U1) * P * (U2 * U1)}\n                         Utrans U1;; Utrans U2 {P}", "then"], ["proof (chain)\npicking this:\n  is_quantum_predicate (adjoint U2 * P * U2)", "have hp1: \"\\<turnstile>\\<^sub>p {adjoint U1 * (adjoint (U2) * P * (U2)) * U1} Utrans U1 {adjoint (U2) * P * (U2)}\""], ["proof (prove)\nusing this:\n  is_quantum_predicate (adjoint U2 * P * U2)\n\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>p {adjoint U1 * (adjoint U2 * P * U2) * U1} Utrans U1\n                         {adjoint U2 * P * U2}", "using hoare_partial.intros"], ["proof (prove)\nusing this:\n  is_quantum_predicate (adjoint U2 * P * U2)\n  is_quantum_predicate ?P \\<Longrightarrow>\n  \\<turnstile>\\<^sub>p {?P} SKIP {?P}\n  is_quantum_predicate ?P \\<Longrightarrow>\n  \\<turnstile>\\<^sub>p {adjoint ?U * ?P * ?U} Utrans ?U {?P}\n  \\<lbrakk>is_quantum_predicate ?P; is_quantum_predicate ?Q;\n   is_quantum_predicate ?R; \\<turnstile>\\<^sub>p {?P} ?S1.0 {?Q};\n   \\<turnstile>\\<^sub>p {?Q} ?S2.0 {?R}\\<rbrakk>\n  \\<Longrightarrow> \\<turnstile>\\<^sub>p {?P} ?S1.0;; ?S2.0 {?R}\n  \\<lbrakk>\\<And>k. k < ?n \\<Longrightarrow> is_quantum_predicate (?P k);\n   is_quantum_predicate ?Q;\n   \\<And>k.\n      k < ?n \\<Longrightarrow>\n      \\<turnstile>\\<^sub>p {?P k} ?S ! k {?Q}\\<rbrakk>\n  \\<Longrightarrow> \\<turnstile>\\<^sub>p {matrix_sum d\n     (\\<lambda>k. adjoint (?M k) * ?P k * ?M k) ?n}\n   Measure ?n ?M ?S {?Q}\n  \\<lbrakk>is_quantum_predicate ?P; is_quantum_predicate ?Q;\n   \\<turnstile>\\<^sub>p {?Q} ?S\n                        {adjoint (?M 0) * ?P * ?M 0 +\n                         adjoint (?M 1) * ?Q * ?M 1}\\<rbrakk>\n  \\<Longrightarrow> \\<turnstile>\\<^sub>p {adjoint (?M 0) * ?P * ?M 0 +\n    adjoint (?M 1) * ?Q * ?M 1}\n   While ?M ?S {?P}\n  \\<lbrakk>is_quantum_predicate ?P; is_quantum_predicate ?Q;\n   is_quantum_predicate ?P'; is_quantum_predicate ?Q'; ?P \\<le>\\<^sub>L ?P';\n   \\<turnstile>\\<^sub>p {?P'} ?S {?Q'}; ?Q' \\<le>\\<^sub>L ?Q\\<rbrakk>\n  \\<Longrightarrow> \\<turnstile>\\<^sub>p {?P} ?S {?Q}\n\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>p {adjoint U1 * (adjoint U2 * P * U2) * U1} Utrans U1\n                         {adjoint U2 * P * U2}", "by auto"], ["proof (state)\nthis:\n  \\<turnstile>\\<^sub>p {adjoint U1 * (adjoint U2 * P * U2) * U1} Utrans U1\n                       {adjoint U2 * P * U2}\n\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>p {adjoint (U2 * U1) * P * (U2 * U1)}\n                         Utrans U1;; Utrans U2 {P}", "have dP: \"P \\<in> carrier_mat d d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<in> carrier_mat d d", "using assms is_quantum_predicate_def"], ["proof (prove)\nusing this:\n  unitary U1\n  unitary U2\n  is_quantum_predicate P\n  U1 \\<in> carrier_mat d d\n  U2 \\<in> carrier_mat d d\n  is_quantum_predicate ?P =\n  (?P \\<in> carrier_mat d d \\<and>\n   positive ?P \\<and> ?P \\<le>\\<^sub>L 1\\<^sub>m d)\n\ngoal (1 subgoal):\n 1. P \\<in> carrier_mat d d", "by auto"], ["proof (state)\nthis:\n  P \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>p {adjoint (U2 * U1) * P * (U2 * U1)}\n                         Utrans U1;; Utrans U2 {P}", "have eq: \"adjoint U1 * (adjoint U2 * P * U2) * U1 = adjoint (U2 * U1) * P * (U2 * U1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adjoint U1 * (adjoint U2 * P * U2) * U1 =\n    adjoint (U2 * U1) * P * (U2 * U1)", "using dU1 dU2 dP"], ["proof (prove)\nusing this:\n  U1 \\<in> carrier_mat d d\n  U2 \\<in> carrier_mat d d\n  P \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. adjoint U1 * (adjoint U2 * P * U2) * U1 =\n    adjoint (U2 * U1) * P * (U2 * U1)", "by (mat_assoc d)"], ["proof (state)\nthis:\n  adjoint U1 * (adjoint U2 * P * U2) * U1 =\n  adjoint (U2 * U1) * P * (U2 * U1)\n\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>p {adjoint (U2 * U1) * P * (U2 * U1)}\n                         Utrans U1;; Utrans U2 {P}", "with hp1"], ["proof (chain)\npicking this:\n  \\<turnstile>\\<^sub>p {adjoint U1 * (adjoint U2 * P * U2) * U1} Utrans U1\n                       {adjoint U2 * P * U2}\n  adjoint U1 * (adjoint U2 * P * U2) * U1 =\n  adjoint (U2 * U1) * P * (U2 * U1)", "have hp2: \"\\<turnstile>\\<^sub>p {adjoint (U2 * U1) * P * (U2 * U1)} Utrans U1 {adjoint (U2) * P * (U2)}\""], ["proof (prove)\nusing this:\n  \\<turnstile>\\<^sub>p {adjoint U1 * (adjoint U2 * P * U2) * U1} Utrans U1\n                       {adjoint U2 * P * U2}\n  adjoint U1 * (adjoint U2 * P * U2) * U1 =\n  adjoint (U2 * U1) * P * (U2 * U1)\n\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>p {adjoint (U2 * U1) * P * (U2 * U1)} Utrans U1\n                         {adjoint U2 * P * U2}", "by auto"], ["proof (state)\nthis:\n  \\<turnstile>\\<^sub>p {adjoint (U2 * U1) * P * (U2 * U1)} Utrans U1\n                       {adjoint U2 * P * U2}\n\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>p {adjoint (U2 * U1) * P * (U2 * U1)}\n                         Utrans U1;; Utrans U2 {P}", "have \"is_quantum_predicate (adjoint U1 * (adjoint U2 * P * U2) * U1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_quantum_predicate (adjoint U1 * (adjoint U2 * P * U2) * U1)", "using qp qp_close_under_unitary_operator assms"], ["proof (prove)\nusing this:\n  is_quantum_predicate (adjoint U2 * P * U2)\n  \\<lbrakk>?U \\<in> carrier_mat d d; unitary ?U;\n   is_quantum_predicate ?P\\<rbrakk>\n  \\<Longrightarrow> is_quantum_predicate (adjoint ?U * ?P * ?U)\n  unitary U1\n  unitary U2\n  is_quantum_predicate P\n  U1 \\<in> carrier_mat d d\n  U2 \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. is_quantum_predicate (adjoint U1 * (adjoint U2 * P * U2) * U1)", "by auto"], ["proof (state)\nthis:\n  is_quantum_predicate (adjoint U1 * (adjoint U2 * P * U2) * U1)\n\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>p {adjoint (U2 * U1) * P * (U2 * U1)}\n                         Utrans U1;; Utrans U2 {P}", "then"], ["proof (chain)\npicking this:\n  is_quantum_predicate (adjoint U1 * (adjoint U2 * P * U2) * U1)", "have \"is_quantum_predicate (adjoint (U2 * U1) * P * (U2 * U1))\""], ["proof (prove)\nusing this:\n  is_quantum_predicate (adjoint U1 * (adjoint U2 * P * U2) * U1)\n\ngoal (1 subgoal):\n 1. is_quantum_predicate (adjoint (U2 * U1) * P * (U2 * U1))", "using eq"], ["proof (prove)\nusing this:\n  is_quantum_predicate (adjoint U1 * (adjoint U2 * P * U2) * U1)\n  adjoint U1 * (adjoint U2 * P * U2) * U1 =\n  adjoint (U2 * U1) * P * (U2 * U1)\n\ngoal (1 subgoal):\n 1. is_quantum_predicate (adjoint (U2 * U1) * P * (U2 * U1))", "by auto"], ["proof (state)\nthis:\n  is_quantum_predicate (adjoint (U2 * U1) * P * (U2 * U1))\n\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>p {adjoint (U2 * U1) * P * (U2 * U1)}\n                         Utrans U1;; Utrans U2 {P}", "then"], ["proof (chain)\npicking this:\n  is_quantum_predicate (adjoint (U2 * U1) * P * (U2 * U1))", "show ?thesis"], ["proof (prove)\nusing this:\n  is_quantum_predicate (adjoint (U2 * U1) * P * (U2 * U1))\n\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>p {adjoint (U2 * U1) * P * (U2 * U1)}\n                         Utrans U1;; Utrans U2 {P}", "using hoare_partial.intros(3)[OF _ qp assms(3)] hp0 hp2"], ["proof (prove)\nusing this:\n  is_quantum_predicate (adjoint (U2 * U1) * P * (U2 * U1))\n  \\<lbrakk>is_quantum_predicate ?P;\n   \\<turnstile>\\<^sub>p {?P} ?S1.0 {adjoint U2 * P * U2};\n   \\<turnstile>\\<^sub>p {adjoint U2 * P * U2} ?S2.0 {P}\\<rbrakk>\n  \\<Longrightarrow> \\<turnstile>\\<^sub>p {?P} ?S1.0;; ?S2.0 {P}\n  \\<turnstile>\\<^sub>p {adjoint U2 * P * U2} Utrans U2 {P}\n  \\<turnstile>\\<^sub>p {adjoint (U2 * U1) * P * (U2 * U1)} Utrans U1\n                       {adjoint U2 * P * U2}\n\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>p {adjoint (U2 * U1) * P * (U2 * U1)}\n                         Utrans U1;; Utrans U2 {P}", "by auto"], ["proof (state)\nthis:\n  \\<turnstile>\\<^sub>p {adjoint (U2 * U1) * P * (U2 * U1)}\n                       Utrans U1;; Utrans U2 {P}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma qp_close_after_exexH_k:\n  fixes P :: \"complex mat\"\n  assumes \"is_quantum_predicate P\"\n  shows \"k < n \\<Longrightarrow> is_quantum_predicate (adjoint (exexH_k k) * P * exexH_k k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k < n \\<Longrightarrow>\n    is_quantum_predicate (adjoint (exexH_k k) * P * exexH_k k)", "apply (subst qp_close_under_unitary_operator)"], ["proof (prove)\ngoal (4 subgoals):\n 1. k < n \\<Longrightarrow> exexH_k k \\<in> carrier_mat d d\n 2. k < n \\<Longrightarrow> unitary (exexH_k k)\n 3. k < n \\<Longrightarrow> is_quantum_predicate P\n 4. k < n \\<Longrightarrow> True", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. k < n \\<Longrightarrow> exexH_k k \\<in> carrier_mat d d", "using exexH_k_dim"], ["proof (prove)\nusing this:\n  ?k < n \\<Longrightarrow> exexH_k ?k \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. k < n \\<Longrightarrow> exexH_k k \\<in> carrier_mat d d", "by auto"], ["proof (prove)\ngoal (3 subgoals):\n 1. k < n \\<Longrightarrow> unitary (exexH_k k)\n 2. k < n \\<Longrightarrow> is_quantum_predicate P\n 3. k < n \\<Longrightarrow> True", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. k < n \\<Longrightarrow> unitary (exexH_k k)", "using unitary_exexH_k"], ["proof (prove)\nusing this:\n  ?k < n \\<Longrightarrow> unitary (exexH_k ?k)\n\ngoal (1 subgoal):\n 1. k < n \\<Longrightarrow> unitary (exexH_k k)", "by auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. k < n \\<Longrightarrow> is_quantum_predicate P\n 2. k < n \\<Longrightarrow> True", "using assms"], ["proof (prove)\nusing this:\n  is_quantum_predicate P\n\ngoal (2 subgoals):\n 1. k < n \\<Longrightarrow> is_quantum_predicate P\n 2. k < n \\<Longrightarrow> True", "by auto"], ["", "lemma hoare_hadamard_n:\n  fixes P :: \"complex mat\"\n  shows \"is_quantum_predicate P \\<Longrightarrow> k < n \\<Longrightarrow> \n   \\<turnstile>\\<^sub>p \n   {adjoint (exexH_k k) * P * exexH_k k} \n   hadamard_n (Suc k)\n   {P}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_quantum_predicate P; k < n\\<rbrakk>\n    \\<Longrightarrow> \\<turnstile>\\<^sub>p {adjoint (exexH_k k) * P *\n      exexH_k k}\n     hadamard_n (Suc k) {P}", "proof (induct k arbitrary: P)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>P.\n       \\<lbrakk>is_quantum_predicate P; 0 < n\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>p {adjoint (exexH_k 0) * P *\n         exexH_k 0}\n        hadamard_n (Suc 0) {P}\n 2. \\<And>k P.\n       \\<lbrakk>\\<And>P.\n                   \\<lbrakk>is_quantum_predicate P; k < n\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>p {adjoint\n                      (exexH_k k) *\n                     P *\n                     exexH_k k}\n                    hadamard_n (Suc k) {P};\n        is_quantum_predicate P; Suc k < n\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>p {adjoint (exexH_k (Suc k)) *\n         P *\n         exexH_k (Suc k)}\n        hadamard_n (Suc (Suc k)) {P}", "case 0"], ["proof (state)\nthis:\n  is_quantum_predicate P\n  0 < n\n\ngoal (2 subgoals):\n 1. \\<And>P.\n       \\<lbrakk>is_quantum_predicate P; 0 < n\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>p {adjoint (exexH_k 0) * P *\n         exexH_k 0}\n        hadamard_n (Suc 0) {P}\n 2. \\<And>k P.\n       \\<lbrakk>\\<And>P.\n                   \\<lbrakk>is_quantum_predicate P; k < n\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>p {adjoint\n                      (exexH_k k) *\n                     P *\n                     exexH_k k}\n                    hadamard_n (Suc k) {P};\n        is_quantum_predicate P; Suc k < n\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>p {adjoint (exexH_k (Suc k)) *\n         P *\n         exexH_k (Suc k)}\n        hadamard_n (Suc (Suc k)) {P}", "have qp: \"is_quantum_predicate (adjoint (exexH_k 0) * P * exexH_k 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_quantum_predicate (adjoint (exexH_k 0) * P * exexH_k 0)", "using qp_close_under_unitary_operator[OF _ unitary_exhadamard_on_i[of 0]] tensor_P_dim 0"], ["proof (prove)\nusing this:\n  \\<lbrakk>tensor_P (hadamard_on_i 0) (1\\<^sub>m K) \\<in> carrier_mat d d;\n   0 < n; is_quantum_predicate ?P\\<rbrakk>\n  \\<Longrightarrow> is_quantum_predicate\n                     (adjoint (tensor_P (hadamard_on_i 0) (1\\<^sub>m K)) *\n                      ?P *\n                      tensor_P (hadamard_on_i 0) (1\\<^sub>m K))\n  tensor_P ?A ?B \\<in> carrier_mat d d\n  is_quantum_predicate P\n  0 < n\n\ngoal (1 subgoal):\n 1. is_quantum_predicate (adjoint (exexH_k 0) * P * exexH_k 0)", "by auto"], ["proof (state)\nthis:\n  is_quantum_predicate (adjoint (exexH_k 0) * P * exexH_k 0)\n\ngoal (2 subgoals):\n 1. \\<And>P.\n       \\<lbrakk>is_quantum_predicate P; 0 < n\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>p {adjoint (exexH_k 0) * P *\n         exexH_k 0}\n        hadamard_n (Suc 0) {P}\n 2. \\<And>k P.\n       \\<lbrakk>\\<And>P.\n                   \\<lbrakk>is_quantum_predicate P; k < n\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>p {adjoint\n                      (exexH_k k) *\n                     P *\n                     exexH_k k}\n                    hadamard_n (Suc k) {P};\n        is_quantum_predicate P; Suc k < n\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>p {adjoint (exexH_k (Suc k)) *\n         P *\n         exexH_k (Suc k)}\n        hadamard_n (Suc (Suc k)) {P}", "then"], ["proof (chain)\npicking this:\n  is_quantum_predicate (adjoint (exexH_k 0) * P * exexH_k 0)", "have \"\\<turnstile>\\<^sub>p {adjoint (exexH_k 0) * P * exexH_k 0} SKIP {adjoint (exexH_k 0) * P * exexH_k 0}\""], ["proof (prove)\nusing this:\n  is_quantum_predicate (adjoint (exexH_k 0) * P * exexH_k 0)\n\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>p {adjoint (exexH_k 0) * P * exexH_k 0} SKIP\n                         {adjoint (exexH_k 0) * P * exexH_k 0}", "using hoare_partial.intros(1)"], ["proof (prove)\nusing this:\n  is_quantum_predicate (adjoint (exexH_k 0) * P * exexH_k 0)\n  is_quantum_predicate ?P \\<Longrightarrow>\n  \\<turnstile>\\<^sub>p {?P} SKIP {?P}\n\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>p {adjoint (exexH_k 0) * P * exexH_k 0} SKIP\n                         {adjoint (exexH_k 0) * P * exexH_k 0}", "by auto"], ["proof (state)\nthis:\n  \\<turnstile>\\<^sub>p {adjoint (exexH_k 0) * P * exexH_k 0} SKIP\n                       {adjoint (exexH_k 0) * P * exexH_k 0}\n\ngoal (2 subgoals):\n 1. \\<And>P.\n       \\<lbrakk>is_quantum_predicate P; 0 < n\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>p {adjoint (exexH_k 0) * P *\n         exexH_k 0}\n        hadamard_n (Suc 0) {P}\n 2. \\<And>k P.\n       \\<lbrakk>\\<And>P.\n                   \\<lbrakk>is_quantum_predicate P; k < n\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>p {adjoint\n                      (exexH_k k) *\n                     P *\n                     exexH_k k}\n                    hadamard_n (Suc k) {P};\n        is_quantum_predicate P; Suc k < n\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>p {adjoint (exexH_k (Suc k)) *\n         P *\n         exexH_k (Suc k)}\n        hadamard_n (Suc (Suc k)) {P}", "moreover"], ["proof (state)\nthis:\n  \\<turnstile>\\<^sub>p {adjoint (exexH_k 0) * P * exexH_k 0} SKIP\n                       {adjoint (exexH_k 0) * P * exexH_k 0}\n\ngoal (2 subgoals):\n 1. \\<And>P.\n       \\<lbrakk>is_quantum_predicate P; 0 < n\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>p {adjoint (exexH_k 0) * P *\n         exexH_k 0}\n        hadamard_n (Suc 0) {P}\n 2. \\<And>k P.\n       \\<lbrakk>\\<And>P.\n                   \\<lbrakk>is_quantum_predicate P; k < n\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>p {adjoint\n                      (exexH_k k) *\n                     P *\n                     exexH_k k}\n                    hadamard_n (Suc k) {P};\n        is_quantum_predicate P; Suc k < n\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>p {adjoint (exexH_k (Suc k)) *\n         P *\n         exexH_k (Suc k)}\n        hadamard_n (Suc (Suc k)) {P}", "have \"\\<turnstile>\\<^sub>p {adjoint (exexH_k 0) * P * exexH_k 0} Utrans (tensor_P (hadamard_on_i 0) (1\\<^sub>m K)) {P}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>p {adjoint (exexH_k 0) * P * exexH_k 0}\n                         Utrans (tensor_P (hadamard_on_i 0) (1\\<^sub>m K))\n                         {P}", "using hoare_partial.intros(2) 0"], ["proof (prove)\nusing this:\n  is_quantum_predicate ?P \\<Longrightarrow>\n  \\<turnstile>\\<^sub>p {adjoint ?U * ?P * ?U} Utrans ?U {?P}\n  is_quantum_predicate P\n  0 < n\n\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>p {adjoint (exexH_k 0) * P * exexH_k 0}\n                         Utrans (tensor_P (hadamard_on_i 0) (1\\<^sub>m K))\n                         {P}", "by auto"], ["proof (state)\nthis:\n  \\<turnstile>\\<^sub>p {adjoint (exexH_k 0) * P * exexH_k 0}\n                       Utrans (tensor_P (hadamard_on_i 0) (1\\<^sub>m K)) {P}\n\ngoal (2 subgoals):\n 1. \\<And>P.\n       \\<lbrakk>is_quantum_predicate P; 0 < n\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>p {adjoint (exexH_k 0) * P *\n         exexH_k 0}\n        hadamard_n (Suc 0) {P}\n 2. \\<And>k P.\n       \\<lbrakk>\\<And>P.\n                   \\<lbrakk>is_quantum_predicate P; k < n\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>p {adjoint\n                      (exexH_k k) *\n                     P *\n                     exexH_k k}\n                    hadamard_n (Suc k) {P};\n        is_quantum_predicate P; Suc k < n\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>p {adjoint (exexH_k (Suc k)) *\n         P *\n         exexH_k (Suc k)}\n        hadamard_n (Suc (Suc k)) {P}", "ultimately"], ["proof (chain)\npicking this:\n  \\<turnstile>\\<^sub>p {adjoint (exexH_k 0) * P * exexH_k 0} SKIP\n                       {adjoint (exexH_k 0) * P * exexH_k 0}\n  \\<turnstile>\\<^sub>p {adjoint (exexH_k 0) * P * exexH_k 0}\n                       Utrans (tensor_P (hadamard_on_i 0) (1\\<^sub>m K)) {P}", "have \"\\<turnstile>\\<^sub>p {adjoint (exexH_k 0) * P * exexH_k 0} SKIP;; Utrans (tensor_P (hadamard_on_i 0) (1\\<^sub>m K)) {P}\""], ["proof (prove)\nusing this:\n  \\<turnstile>\\<^sub>p {adjoint (exexH_k 0) * P * exexH_k 0} SKIP\n                       {adjoint (exexH_k 0) * P * exexH_k 0}\n  \\<turnstile>\\<^sub>p {adjoint (exexH_k 0) * P * exexH_k 0}\n                       Utrans (tensor_P (hadamard_on_i 0) (1\\<^sub>m K)) {P}\n\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>p {adjoint (exexH_k 0) * P * exexH_k 0}\n                         SKIP;;\n                         Utrans (tensor_P (hadamard_on_i 0) (1\\<^sub>m K))\n                         {P}", "using hoare_partial.intros(3) qp 0"], ["proof (prove)\nusing this:\n  \\<turnstile>\\<^sub>p {adjoint (exexH_k 0) * P * exexH_k 0} SKIP\n                       {adjoint (exexH_k 0) * P * exexH_k 0}\n  \\<turnstile>\\<^sub>p {adjoint (exexH_k 0) * P * exexH_k 0}\n                       Utrans (tensor_P (hadamard_on_i 0) (1\\<^sub>m K)) {P}\n  \\<lbrakk>is_quantum_predicate ?P; is_quantum_predicate ?Q;\n   is_quantum_predicate ?R; \\<turnstile>\\<^sub>p {?P} ?S1.0 {?Q};\n   \\<turnstile>\\<^sub>p {?Q} ?S2.0 {?R}\\<rbrakk>\n  \\<Longrightarrow> \\<turnstile>\\<^sub>p {?P} ?S1.0;; ?S2.0 {?R}\n  is_quantum_predicate (adjoint (exexH_k 0) * P * exexH_k 0)\n  is_quantum_predicate P\n  0 < n\n\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>p {adjoint (exexH_k 0) * P * exexH_k 0}\n                         SKIP;;\n                         Utrans (tensor_P (hadamard_on_i 0) (1\\<^sub>m K))\n                         {P}", "by auto"], ["proof (state)\nthis:\n  \\<turnstile>\\<^sub>p {adjoint (exexH_k 0) * P * exexH_k 0}\n                       SKIP;;\n                       Utrans (tensor_P (hadamard_on_i 0) (1\\<^sub>m K))\n                       {P}\n\ngoal (2 subgoals):\n 1. \\<And>P.\n       \\<lbrakk>is_quantum_predicate P; 0 < n\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>p {adjoint (exexH_k 0) * P *\n         exexH_k 0}\n        hadamard_n (Suc 0) {P}\n 2. \\<And>k P.\n       \\<lbrakk>\\<And>P.\n                   \\<lbrakk>is_quantum_predicate P; k < n\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>p {adjoint\n                      (exexH_k k) *\n                     P *\n                     exexH_k k}\n                    hadamard_n (Suc k) {P};\n        is_quantum_predicate P; Suc k < n\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>p {adjoint (exexH_k (Suc k)) *\n         P *\n         exexH_k (Suc k)}\n        hadamard_n (Suc (Suc k)) {P}", "then"], ["proof (chain)\npicking this:\n  \\<turnstile>\\<^sub>p {adjoint (exexH_k 0) * P * exexH_k 0}\n                       SKIP;;\n                       Utrans (tensor_P (hadamard_on_i 0) (1\\<^sub>m K))\n                       {P}", "show ?case"], ["proof (prove)\nusing this:\n  \\<turnstile>\\<^sub>p {adjoint (exexH_k 0) * P * exexH_k 0}\n                       SKIP;;\n                       Utrans (tensor_P (hadamard_on_i 0) (1\\<^sub>m K))\n                       {P}\n\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>p {adjoint (exexH_k 0) * P * exexH_k 0}\n                         hadamard_n (Suc 0) {P}", "using qp"], ["proof (prove)\nusing this:\n  \\<turnstile>\\<^sub>p {adjoint (exexH_k 0) * P * exexH_k 0}\n                       SKIP;;\n                       Utrans (tensor_P (hadamard_on_i 0) (1\\<^sub>m K))\n                       {P}\n  is_quantum_predicate (adjoint (exexH_k 0) * P * exexH_k 0)\n\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>p {adjoint (exexH_k 0) * P * exexH_k 0}\n                         hadamard_n (Suc 0) {P}", "by auto"], ["proof (state)\nthis:\n  \\<turnstile>\\<^sub>p {adjoint (exexH_k 0) * P * exexH_k 0}\n                       hadamard_n (Suc 0) {P}\n\ngoal (1 subgoal):\n 1. \\<And>k P.\n       \\<lbrakk>\\<And>P.\n                   \\<lbrakk>is_quantum_predicate P; k < n\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>p {adjoint\n                      (exexH_k k) *\n                     P *\n                     exexH_k k}\n                    hadamard_n (Suc k) {P};\n        is_quantum_predicate P; Suc k < n\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>p {adjoint (exexH_k (Suc k)) *\n         P *\n         exexH_k (Suc k)}\n        hadamard_n (Suc (Suc k)) {P}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k P.\n       \\<lbrakk>\\<And>P.\n                   \\<lbrakk>is_quantum_predicate P; k < n\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>p {adjoint\n                      (exexH_k k) *\n                     P *\n                     exexH_k k}\n                    hadamard_n (Suc k) {P};\n        is_quantum_predicate P; Suc k < n\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>p {adjoint (exexH_k (Suc k)) *\n         P *\n         exexH_k (Suc k)}\n        hadamard_n (Suc (Suc k)) {P}", "case (Suc k)"], ["proof (state)\nthis:\n  \\<lbrakk>is_quantum_predicate ?P2; k < n\\<rbrakk>\n  \\<Longrightarrow> \\<turnstile>\\<^sub>p {adjoint (exexH_k k) * ?P2 *\n    exexH_k k}\n   hadamard_n (Suc k) {?P2}\n  is_quantum_predicate P\n  Suc k < n\n\ngoal (1 subgoal):\n 1. \\<And>k P.\n       \\<lbrakk>\\<And>P.\n                   \\<lbrakk>is_quantum_predicate P; k < n\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>p {adjoint\n                      (exexH_k k) *\n                     P *\n                     exexH_k k}\n                    hadamard_n (Suc k) {P};\n        is_quantum_predicate P; Suc k < n\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>p {adjoint (exexH_k (Suc k)) *\n         P *\n         exexH_k (Suc k)}\n        hadamard_n (Suc (Suc k)) {P}", "have h1: \"\\<turnstile>\\<^sub>p \n    {adjoint (tensor_P (hadamard_on_i (Suc k)) (1\\<^sub>m K)) * P * (tensor_P (hadamard_on_i (Suc k)) (1\\<^sub>m K))} \n    Utrans (tensor_P (hadamard_on_i (Suc k)) (1\\<^sub>m K)) \n    {P}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>p {adjoint\n                           (tensor_P (hadamard_on_i (Suc k))\n                             (1\\<^sub>m K)) *\n                          P *\n                          tensor_P (hadamard_on_i (Suc k)) (1\\<^sub>m K)}\n                         Utrans\n                          (tensor_P (hadamard_on_i (Suc k)) (1\\<^sub>m K))\n                         {P}", "using hoare_partial.intros Suc"], ["proof (prove)\nusing this:\n  is_quantum_predicate ?P \\<Longrightarrow>\n  \\<turnstile>\\<^sub>p {?P} SKIP {?P}\n  is_quantum_predicate ?P \\<Longrightarrow>\n  \\<turnstile>\\<^sub>p {adjoint ?U * ?P * ?U} Utrans ?U {?P}\n  \\<lbrakk>is_quantum_predicate ?P; is_quantum_predicate ?Q;\n   is_quantum_predicate ?R; \\<turnstile>\\<^sub>p {?P} ?S1.0 {?Q};\n   \\<turnstile>\\<^sub>p {?Q} ?S2.0 {?R}\\<rbrakk>\n  \\<Longrightarrow> \\<turnstile>\\<^sub>p {?P} ?S1.0;; ?S2.0 {?R}\n  \\<lbrakk>\\<And>k. k < ?n \\<Longrightarrow> is_quantum_predicate (?P k);\n   is_quantum_predicate ?Q;\n   \\<And>k.\n      k < ?n \\<Longrightarrow>\n      \\<turnstile>\\<^sub>p {?P k} ?S ! k {?Q}\\<rbrakk>\n  \\<Longrightarrow> \\<turnstile>\\<^sub>p {matrix_sum d\n     (\\<lambda>k. adjoint (?M k) * ?P k * ?M k) ?n}\n   Measure ?n ?M ?S {?Q}\n  \\<lbrakk>is_quantum_predicate ?P; is_quantum_predicate ?Q;\n   \\<turnstile>\\<^sub>p {?Q} ?S\n                        {adjoint (?M 0) * ?P * ?M 0 +\n                         adjoint (?M 1) * ?Q * ?M 1}\\<rbrakk>\n  \\<Longrightarrow> \\<turnstile>\\<^sub>p {adjoint (?M 0) * ?P * ?M 0 +\n    adjoint (?M 1) * ?Q * ?M 1}\n   While ?M ?S {?P}\n  \\<lbrakk>is_quantum_predicate ?P; is_quantum_predicate ?Q;\n   is_quantum_predicate ?P'; is_quantum_predicate ?Q'; ?P \\<le>\\<^sub>L ?P';\n   \\<turnstile>\\<^sub>p {?P'} ?S {?Q'}; ?Q' \\<le>\\<^sub>L ?Q\\<rbrakk>\n  \\<Longrightarrow> \\<turnstile>\\<^sub>p {?P} ?S {?Q}\n  \\<lbrakk>is_quantum_predicate ?P2; k < n\\<rbrakk>\n  \\<Longrightarrow> \\<turnstile>\\<^sub>p {adjoint (exexH_k k) * ?P2 *\n    exexH_k k}\n   hadamard_n (Suc k) {?P2}\n  is_quantum_predicate P\n  Suc k < n\n\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>p {adjoint\n                           (tensor_P (hadamard_on_i (Suc k))\n                             (1\\<^sub>m K)) *\n                          P *\n                          tensor_P (hadamard_on_i (Suc k)) (1\\<^sub>m K)}\n                         Utrans\n                          (tensor_P (hadamard_on_i (Suc k)) (1\\<^sub>m K))\n                         {P}", "by auto"], ["proof (state)\nthis:\n  \\<turnstile>\\<^sub>p {adjoint\n                         (tensor_P (hadamard_on_i (Suc k)) (1\\<^sub>m K)) *\n                        P *\n                        tensor_P (hadamard_on_i (Suc k)) (1\\<^sub>m K)}\n                       Utrans\n                        (tensor_P (hadamard_on_i (Suc k)) (1\\<^sub>m K))\n                       {P}\n\ngoal (1 subgoal):\n 1. \\<And>k P.\n       \\<lbrakk>\\<And>P.\n                   \\<lbrakk>is_quantum_predicate P; k < n\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>p {adjoint\n                      (exexH_k k) *\n                     P *\n                     exexH_k k}\n                    hadamard_n (Suc k) {P};\n        is_quantum_predicate P; Suc k < n\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>p {adjoint (exexH_k (Suc k)) *\n         P *\n         exexH_k (Suc k)}\n        hadamard_n (Suc (Suc k)) {P}", "have qp: \"is_quantum_predicate (adjoint (tensor_P (hadamard_on_i (Suc k)) (1\\<^sub>m K)) * P * (tensor_P (hadamard_on_i (Suc k)) (1\\<^sub>m K)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_quantum_predicate\n     (adjoint (tensor_P (hadamard_on_i (Suc k)) (1\\<^sub>m K)) * P *\n      tensor_P (hadamard_on_i (Suc k)) (1\\<^sub>m K))", "apply (subst qp_close_under_unitary_operator)"], ["proof (prove)\ngoal (4 subgoals):\n 1. tensor_P (hadamard_on_i (Suc k)) (1\\<^sub>m K) \\<in> carrier_mat d d\n 2. unitary (tensor_P (hadamard_on_i (Suc k)) (1\\<^sub>m K))\n 3. is_quantum_predicate P\n 4. True", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. tensor_P (hadamard_on_i (Suc k)) (1\\<^sub>m K) \\<in> carrier_mat d d", "using ps2_P.ptensor_mat_carrier ps2_P_d0"], ["proof (prove)\nusing this:\n  tensor_P ?m1.0 ?m2.0 \\<in> carrier_mat ps2_P.d0 ps2_P.d0\n  ps2_P.d0 = d\n\ngoal (1 subgoal):\n 1. tensor_P (hadamard_on_i (Suc k)) (1\\<^sub>m K) \\<in> carrier_mat d d", "by auto"], ["proof (prove)\ngoal (3 subgoals):\n 1. unitary (tensor_P (hadamard_on_i (Suc k)) (1\\<^sub>m K))\n 2. is_quantum_predicate P\n 3. True", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. unitary (tensor_P (hadamard_on_i (Suc k)) (1\\<^sub>m K))", "unfolding ps2_P.ptensor_mat_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. unitary (ps_P.tensor_mat (hadamard_on_i (Suc k)) (1\\<^sub>m K))", "apply (subst partial_state.tensor_mat_unitary )"], ["proof (prove)\ngoal (5 subgoals):\n 1. hadamard_on_i (Suc k) \\<in> carrier_mat ps_P.d1 ps_P.d1\n 2. 1\\<^sub>m K \\<in> carrier_mat ps_P.d2 ps_P.d2\n 3. unitary (hadamard_on_i (Suc k))\n 4. unitary (1\\<^sub>m K)\n 5. True", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. hadamard_on_i (Suc k) \\<in> carrier_mat ps_P.d1 ps_P.d1", "unfolding partial_state.d1_def partial_state.dims1_def ps2_P.nths_vars1' ps2_P.dims1_def d_vars1"], ["proof (prove)\ngoal (1 subgoal):\n 1. hadamard_on_i (Suc k) \\<in> carrier_mat N N", "using hadamard_on_i_dim Suc"], ["proof (prove)\nusing this:\n  ?k < n \\<Longrightarrow> hadamard_on_i ?k \\<in> carrier_mat N N\n  \\<lbrakk>is_quantum_predicate ?P2; k < n\\<rbrakk>\n  \\<Longrightarrow> \\<turnstile>\\<^sub>p {adjoint (exexH_k k) * ?P2 *\n    exexH_k k}\n   hadamard_n (Suc k) {?P2}\n  is_quantum_predicate P\n  Suc k < n\n\ngoal (1 subgoal):\n 1. hadamard_on_i (Suc k) \\<in> carrier_mat N N", "by auto"], ["proof (prove)\ngoal (4 subgoals):\n 1. 1\\<^sub>m K \\<in> carrier_mat ps_P.d2 ps_P.d2\n 2. unitary (hadamard_on_i (Suc k))\n 3. unitary (1\\<^sub>m K)\n 4. True", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1\\<^sub>m K \\<in> carrier_mat ps_P.d2 ps_P.d2", "unfolding partial_state.d2_def partial_state.dims2_def ps2_P.nths_vars2' ps2_P.dims2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1\\<^sub>m K\n    \\<in> carrier_mat (prod_list (nths dims vars2))\n           (prod_list (nths dims vars2))", "using dims_vars2"], ["proof (prove)\nusing this:\n  nths dims vars2 = [K]\n\ngoal (1 subgoal):\n 1. 1\\<^sub>m K\n    \\<in> carrier_mat (prod_list (nths dims vars2))\n           (prod_list (nths dims vars2))", "by auto"], ["proof (prove)\ngoal (3 subgoals):\n 1. unitary (hadamard_on_i (Suc k))\n 2. unitary (1\\<^sub>m K)\n 3. True", "using unitary_hadamard_on_i unitary_one Suc"], ["proof (prove)\nusing this:\n  ?k < n \\<Longrightarrow> unitary (hadamard_on_i ?k)\n  unitary (1\\<^sub>m ?n)\n  \\<lbrakk>is_quantum_predicate ?P2; k < n\\<rbrakk>\n  \\<Longrightarrow> \\<turnstile>\\<^sub>p {adjoint (exexH_k k) * ?P2 *\n    exexH_k k}\n   hadamard_n (Suc k) {?P2}\n  is_quantum_predicate P\n  Suc k < n\n\ngoal (3 subgoals):\n 1. unitary (hadamard_on_i (Suc k))\n 2. unitary (1\\<^sub>m K)\n 3. True", "by auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. is_quantum_predicate P\n 2. True", "using Suc"], ["proof (prove)\nusing this:\n  \\<lbrakk>is_quantum_predicate ?P2; k < n\\<rbrakk>\n  \\<Longrightarrow> \\<turnstile>\\<^sub>p {adjoint (exexH_k k) * ?P2 *\n    exexH_k k}\n   hadamard_n (Suc k) {?P2}\n  is_quantum_predicate P\n  Suc k < n\n\ngoal (2 subgoals):\n 1. is_quantum_predicate P\n 2. True", "by auto"], ["proof (state)\nthis:\n  is_quantum_predicate\n   (adjoint (tensor_P (hadamard_on_i (Suc k)) (1\\<^sub>m K)) * P *\n    tensor_P (hadamard_on_i (Suc k)) (1\\<^sub>m K))\n\ngoal (1 subgoal):\n 1. \\<And>k P.\n       \\<lbrakk>\\<And>P.\n                   \\<lbrakk>is_quantum_predicate P; k < n\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>p {adjoint\n                      (exexH_k k) *\n                     P *\n                     exexH_k k}\n                    hadamard_n (Suc k) {P};\n        is_quantum_predicate P; Suc k < n\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>p {adjoint (exexH_k (Suc k)) *\n         P *\n         exexH_k (Suc k)}\n        hadamard_n (Suc (Suc k)) {P}", "then"], ["proof (chain)\npicking this:\n  is_quantum_predicate\n   (adjoint (tensor_P (hadamard_on_i (Suc k)) (1\\<^sub>m K)) * P *\n    tensor_P (hadamard_on_i (Suc k)) (1\\<^sub>m K))", "have h2: \"\\<turnstile>\\<^sub>p \n    {adjoint (exexH_k k) * (adjoint (tensor_P (hadamard_on_i (Suc k)) (1\\<^sub>m K)) * P * (tensor_P (hadamard_on_i (Suc k)) (1\\<^sub>m K))) * exexH_k k} \n    hadamard_n (Suc k)\n    {adjoint (tensor_P (hadamard_on_i (Suc k)) (1\\<^sub>m K)) * P * (tensor_P (hadamard_on_i (Suc k)) (1\\<^sub>m K))}\""], ["proof (prove)\nusing this:\n  is_quantum_predicate\n   (adjoint (tensor_P (hadamard_on_i (Suc k)) (1\\<^sub>m K)) * P *\n    tensor_P (hadamard_on_i (Suc k)) (1\\<^sub>m K))\n\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>p {adjoint (exexH_k k) *\n                          (adjoint\n                            (tensor_P (hadamard_on_i (Suc k))\n                              (1\\<^sub>m K)) *\n                           P *\n                           tensor_P (hadamard_on_i (Suc k)) (1\\<^sub>m K)) *\n                          exexH_k k}\n                         hadamard_n (Suc k)\n                         {adjoint\n                           (tensor_P (hadamard_on_i (Suc k))\n                             (1\\<^sub>m K)) *\n                          P *\n                          tensor_P (hadamard_on_i (Suc k)) (1\\<^sub>m K)}", "using Suc"], ["proof (prove)\nusing this:\n  is_quantum_predicate\n   (adjoint (tensor_P (hadamard_on_i (Suc k)) (1\\<^sub>m K)) * P *\n    tensor_P (hadamard_on_i (Suc k)) (1\\<^sub>m K))\n  \\<lbrakk>is_quantum_predicate ?P2; k < n\\<rbrakk>\n  \\<Longrightarrow> \\<turnstile>\\<^sub>p {adjoint (exexH_k k) * ?P2 *\n    exexH_k k}\n   hadamard_n (Suc k) {?P2}\n  is_quantum_predicate P\n  Suc k < n\n\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>p {adjoint (exexH_k k) *\n                          (adjoint\n                            (tensor_P (hadamard_on_i (Suc k))\n                              (1\\<^sub>m K)) *\n                           P *\n                           tensor_P (hadamard_on_i (Suc k)) (1\\<^sub>m K)) *\n                          exexH_k k}\n                         hadamard_n (Suc k)\n                         {adjoint\n                           (tensor_P (hadamard_on_i (Suc k))\n                             (1\\<^sub>m K)) *\n                          P *\n                          tensor_P (hadamard_on_i (Suc k)) (1\\<^sub>m K)}", "by auto"], ["proof (state)\nthis:\n  \\<turnstile>\\<^sub>p {adjoint (exexH_k k) *\n                        (adjoint\n                          (tensor_P (hadamard_on_i (Suc k)) (1\\<^sub>m K)) *\n                         P *\n                         tensor_P (hadamard_on_i (Suc k)) (1\\<^sub>m K)) *\n                        exexH_k k}\n                       hadamard_n (Suc k)\n                       {adjoint\n                         (tensor_P (hadamard_on_i (Suc k)) (1\\<^sub>m K)) *\n                        P *\n                        tensor_P (hadamard_on_i (Suc k)) (1\\<^sub>m K)}\n\ngoal (1 subgoal):\n 1. \\<And>k P.\n       \\<lbrakk>\\<And>P.\n                   \\<lbrakk>is_quantum_predicate P; k < n\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>p {adjoint\n                      (exexH_k k) *\n                     P *\n                     exexH_k k}\n                    hadamard_n (Suc k) {P};\n        is_quantum_predicate P; Suc k < n\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>p {adjoint (exexH_k (Suc k)) *\n         P *\n         exexH_k (Suc k)}\n        hadamard_n (Suc (Suc k)) {P}", "have \"(tensor_P (hadamard_on_i (Suc k)) (1\\<^sub>m K)) * exexH_k k\n    = (tensor_P (hadamard_on_i (Suc k) * (exH_k k)) (1\\<^sub>m K * (1\\<^sub>m K)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tensor_P (hadamard_on_i (Suc k)) (1\\<^sub>m K) * exexH_k k =\n    tensor_P (hadamard_on_i (Suc k) * exH_k k) (1\\<^sub>m K * 1\\<^sub>m K)", "apply (subst ps2_P.ptensor_mat_mult)"], ["proof (prove)\ngoal (4 subgoals):\n 1. hadamard_on_i (Suc k) \\<in> carrier_mat ps2_P.d1 ps2_P.d1\n 2. exH_k k \\<in> carrier_mat ps2_P.d1 ps2_P.d1\n 3. 1\\<^sub>m K \\<in> carrier_mat ps2_P.d2 ps2_P.d2\n 4. tensor_P (hadamard_on_i (Suc k)) (1\\<^sub>m K) * exexH_k k =\n    tensor_P (hadamard_on_i (Suc k)) (1\\<^sub>m K) *\n    tensor_P (exH_k k) (1\\<^sub>m K)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. hadamard_on_i (Suc k) \\<in> carrier_mat ps2_P.d1 ps2_P.d1", "using hadamard_on_i_dim ps2_P_d1 Suc"], ["proof (prove)\nusing this:\n  ?k < n \\<Longrightarrow> hadamard_on_i ?k \\<in> carrier_mat N N\n  ps2_P.d1 = N\n  \\<lbrakk>is_quantum_predicate ?P2; k < n\\<rbrakk>\n  \\<Longrightarrow> \\<turnstile>\\<^sub>p {adjoint (exexH_k k) * ?P2 *\n    exexH_k k}\n   hadamard_n (Suc k) {?P2}\n  is_quantum_predicate P\n  Suc k < n\n\ngoal (1 subgoal):\n 1. hadamard_on_i (Suc k) \\<in> carrier_mat ps2_P.d1 ps2_P.d1", "by auto"], ["proof (prove)\ngoal (3 subgoals):\n 1. exH_k k \\<in> carrier_mat ps2_P.d1 ps2_P.d1\n 2. 1\\<^sub>m K \\<in> carrier_mat ps2_P.d2 ps2_P.d2\n 3. tensor_P (hadamard_on_i (Suc k)) (1\\<^sub>m K) * exexH_k k =\n    tensor_P (hadamard_on_i (Suc k)) (1\\<^sub>m K) *\n    tensor_P (exH_k k) (1\\<^sub>m K)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. exH_k k \\<in> carrier_mat ps2_P.d1 ps2_P.d1", "using exH_k_dim ps2_P_d1 Suc"], ["proof (prove)\nusing this:\n  ?k < n \\<Longrightarrow> exH_k ?k \\<in> carrier_mat N N\n  ps2_P.d1 = N\n  \\<lbrakk>is_quantum_predicate ?P2; k < n\\<rbrakk>\n  \\<Longrightarrow> \\<turnstile>\\<^sub>p {adjoint (exexH_k k) * ?P2 *\n    exexH_k k}\n   hadamard_n (Suc k) {?P2}\n  is_quantum_predicate P\n  Suc k < n\n\ngoal (1 subgoal):\n 1. exH_k k \\<in> carrier_mat ps2_P.d1 ps2_P.d1", "by auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. 1\\<^sub>m K \\<in> carrier_mat ps2_P.d2 ps2_P.d2\n 2. tensor_P (hadamard_on_i (Suc k)) (1\\<^sub>m K) * exexH_k k =\n    tensor_P (hadamard_on_i (Suc k)) (1\\<^sub>m K) *\n    tensor_P (exH_k k) (1\\<^sub>m K)", "using ps2_P_d2"], ["proof (prove)\nusing this:\n  ps2_P.d2 = K\n\ngoal (2 subgoals):\n 1. 1\\<^sub>m K \\<in> carrier_mat ps2_P.d2 ps2_P.d2\n 2. tensor_P (hadamard_on_i (Suc k)) (1\\<^sub>m K) * exexH_k k =\n    tensor_P (hadamard_on_i (Suc k)) (1\\<^sub>m K) *\n    tensor_P (exH_k k) (1\\<^sub>m K)", "by auto"], ["proof (state)\nthis:\n  tensor_P (hadamard_on_i (Suc k)) (1\\<^sub>m K) * exexH_k k =\n  tensor_P (hadamard_on_i (Suc k) * exH_k k) (1\\<^sub>m K * 1\\<^sub>m K)\n\ngoal (1 subgoal):\n 1. \\<And>k P.\n       \\<lbrakk>\\<And>P.\n                   \\<lbrakk>is_quantum_predicate P; k < n\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>p {adjoint\n                      (exexH_k k) *\n                     P *\n                     exexH_k k}\n                    hadamard_n (Suc k) {P};\n        is_quantum_predicate P; Suc k < n\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>p {adjoint (exexH_k (Suc k)) *\n         P *\n         exexH_k (Suc k)}\n        hadamard_n (Suc (Suc k)) {P}", "also"], ["proof (state)\nthis:\n  tensor_P (hadamard_on_i (Suc k)) (1\\<^sub>m K) * exexH_k k =\n  tensor_P (hadamard_on_i (Suc k) * exH_k k) (1\\<^sub>m K * 1\\<^sub>m K)\n\ngoal (1 subgoal):\n 1. \\<And>k P.\n       \\<lbrakk>\\<And>P.\n                   \\<lbrakk>is_quantum_predicate P; k < n\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>p {adjoint\n                      (exexH_k k) *\n                     P *\n                     exexH_k k}\n                    hadamard_n (Suc k) {P};\n        is_quantum_predicate P; Suc k < n\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>p {adjoint (exexH_k (Suc k)) *\n         P *\n         exexH_k (Suc k)}\n        hadamard_n (Suc (Suc k)) {P}", "have \"\\<dots> = exexH_k (Suc k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tensor_P (hadamard_on_i (Suc k) * exH_k k) (1\\<^sub>m K * 1\\<^sub>m K) =\n    exexH_k (Suc k)", "using mult_exH_k_left Suc"], ["proof (prove)\nusing this:\n  Suc ?k < n \\<Longrightarrow>\n  hadamard_on_i (Suc ?k) * exH_k ?k = exH_k (Suc ?k)\n  \\<lbrakk>is_quantum_predicate ?P2; k < n\\<rbrakk>\n  \\<Longrightarrow> \\<turnstile>\\<^sub>p {adjoint (exexH_k k) * ?P2 *\n    exexH_k k}\n   hadamard_n (Suc k) {?P2}\n  is_quantum_predicate P\n  Suc k < n\n\ngoal (1 subgoal):\n 1. tensor_P (hadamard_on_i (Suc k) * exH_k k) (1\\<^sub>m K * 1\\<^sub>m K) =\n    exexH_k (Suc k)", "by auto"], ["proof (state)\nthis:\n  tensor_P (hadamard_on_i (Suc k) * exH_k k) (1\\<^sub>m K * 1\\<^sub>m K) =\n  exexH_k (Suc k)\n\ngoal (1 subgoal):\n 1. \\<And>k P.\n       \\<lbrakk>\\<And>P.\n                   \\<lbrakk>is_quantum_predicate P; k < n\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>p {adjoint\n                      (exexH_k k) *\n                     P *\n                     exexH_k k}\n                    hadamard_n (Suc k) {P};\n        is_quantum_predicate P; Suc k < n\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>p {adjoint (exexH_k (Suc k)) *\n         P *\n         exexH_k (Suc k)}\n        hadamard_n (Suc (Suc k)) {P}", "finally"], ["proof (chain)\npicking this:\n  tensor_P (hadamard_on_i (Suc k)) (1\\<^sub>m K) * exexH_k k =\n  exexH_k (Suc k)", "have eq1: \"(tensor_P (hadamard_on_i (Suc k)) (1\\<^sub>m K)) * exexH_k k = exexH_k (Suc k)\""], ["proof (prove)\nusing this:\n  tensor_P (hadamard_on_i (Suc k)) (1\\<^sub>m K) * exexH_k k =\n  exexH_k (Suc k)\n\ngoal (1 subgoal):\n 1. tensor_P (hadamard_on_i (Suc k)) (1\\<^sub>m K) * exexH_k k =\n    exexH_k (Suc k)", "."], ["proof (state)\nthis:\n  tensor_P (hadamard_on_i (Suc k)) (1\\<^sub>m K) * exexH_k k =\n  exexH_k (Suc k)\n\ngoal (1 subgoal):\n 1. \\<And>k P.\n       \\<lbrakk>\\<And>P.\n                   \\<lbrakk>is_quantum_predicate P; k < n\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>p {adjoint\n                      (exexH_k k) *\n                     P *\n                     exexH_k k}\n                    hadamard_n (Suc k) {P};\n        is_quantum_predicate P; Suc k < n\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>p {adjoint (exexH_k (Suc k)) *\n         P *\n         exexH_k (Suc k)}\n        hadamard_n (Suc (Suc k)) {P}", "then"], ["proof (chain)\npicking this:\n  tensor_P (hadamard_on_i (Suc k)) (1\\<^sub>m K) * exexH_k k =\n  exexH_k (Suc k)", "have eq2: \"adjoint (exexH_k k) * adjoint (tensor_P (hadamard_on_i (Suc k)) (1\\<^sub>m K)) = adjoint (exexH_k (Suc k))\""], ["proof (prove)\nusing this:\n  tensor_P (hadamard_on_i (Suc k)) (1\\<^sub>m K) * exexH_k k =\n  exexH_k (Suc k)\n\ngoal (1 subgoal):\n 1. adjoint (exexH_k k) *\n    adjoint (tensor_P (hadamard_on_i (Suc k)) (1\\<^sub>m K)) =\n    adjoint (exexH_k (Suc k))", "apply (subst adjoint_mult[symmetric, of _ d d _ d])"], ["proof (prove)\ngoal (3 subgoals):\n 1. tensor_P (hadamard_on_i (Suc k)) (1\\<^sub>m K) * exexH_k k =\n    exexH_k (Suc k) \\<Longrightarrow>\n    tensor_P (hadamard_on_i (Suc k)) (1\\<^sub>m K) \\<in> carrier_mat d d\n 2. tensor_P (hadamard_on_i (Suc k)) (1\\<^sub>m K) * exexH_k k =\n    exexH_k (Suc k) \\<Longrightarrow>\n    exexH_k k \\<in> carrier_mat d d\n 3. tensor_P (hadamard_on_i (Suc k)) (1\\<^sub>m K) * exexH_k k =\n    exexH_k (Suc k) \\<Longrightarrow>\n    adjoint (tensor_P (hadamard_on_i (Suc k)) (1\\<^sub>m K) * exexH_k k) =\n    adjoint (exexH_k (Suc k))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. tensor_P (hadamard_on_i (Suc k)) (1\\<^sub>m K) * exexH_k k =\n    exexH_k (Suc k) \\<Longrightarrow>\n    tensor_P (hadamard_on_i (Suc k)) (1\\<^sub>m K) \\<in> carrier_mat d d", "using tensor_P_dim"], ["proof (prove)\nusing this:\n  tensor_P ?A ?B \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. tensor_P (hadamard_on_i (Suc k)) (1\\<^sub>m K) * exexH_k k =\n    exexH_k (Suc k) \\<Longrightarrow>\n    tensor_P (hadamard_on_i (Suc k)) (1\\<^sub>m K) \\<in> carrier_mat d d", "by auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. tensor_P (hadamard_on_i (Suc k)) (1\\<^sub>m K) * exexH_k k =\n    exexH_k (Suc k) \\<Longrightarrow>\n    exexH_k k \\<in> carrier_mat d d\n 2. tensor_P (hadamard_on_i (Suc k)) (1\\<^sub>m K) * exexH_k k =\n    exexH_k (Suc k) \\<Longrightarrow>\n    adjoint (tensor_P (hadamard_on_i (Suc k)) (1\\<^sub>m K) * exexH_k k) =\n    adjoint (exexH_k (Suc k))", "using exexH_k_dim Suc"], ["proof (prove)\nusing this:\n  ?k < n \\<Longrightarrow> exexH_k ?k \\<in> carrier_mat d d\n  \\<lbrakk>is_quantum_predicate ?P2; k < n\\<rbrakk>\n  \\<Longrightarrow> \\<turnstile>\\<^sub>p {adjoint (exexH_k k) * ?P2 *\n    exexH_k k}\n   hadamard_n (Suc k) {?P2}\n  is_quantum_predicate P\n  Suc k < n\n\ngoal (2 subgoals):\n 1. tensor_P (hadamard_on_i (Suc k)) (1\\<^sub>m K) * exexH_k k =\n    exexH_k (Suc k) \\<Longrightarrow>\n    exexH_k k \\<in> carrier_mat d d\n 2. tensor_P (hadamard_on_i (Suc k)) (1\\<^sub>m K) * exexH_k k =\n    exexH_k (Suc k) \\<Longrightarrow>\n    adjoint (tensor_P (hadamard_on_i (Suc k)) (1\\<^sub>m K) * exexH_k k) =\n    adjoint (exexH_k (Suc k))", "by auto"], ["proof (state)\nthis:\n  adjoint (exexH_k k) *\n  adjoint (tensor_P (hadamard_on_i (Suc k)) (1\\<^sub>m K)) =\n  adjoint (exexH_k (Suc k))\n\ngoal (1 subgoal):\n 1. \\<And>k P.\n       \\<lbrakk>\\<And>P.\n                   \\<lbrakk>is_quantum_predicate P; k < n\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>p {adjoint\n                      (exexH_k k) *\n                     P *\n                     exexH_k k}\n                    hadamard_n (Suc k) {P};\n        is_quantum_predicate P; Suc k < n\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>p {adjoint (exexH_k (Suc k)) *\n         P *\n         exexH_k (Suc k)}\n        hadamard_n (Suc (Suc k)) {P}", "have dP: \"P \\<in> carrier_mat d d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<in> carrier_mat d d", "using is_quantum_predicate_def Suc"], ["proof (prove)\nusing this:\n  is_quantum_predicate ?P =\n  (?P \\<in> carrier_mat d d \\<and>\n   positive ?P \\<and> ?P \\<le>\\<^sub>L 1\\<^sub>m d)\n  \\<lbrakk>is_quantum_predicate ?P2; k < n\\<rbrakk>\n  \\<Longrightarrow> \\<turnstile>\\<^sub>p {adjoint (exexH_k k) * ?P2 *\n    exexH_k k}\n   hadamard_n (Suc k) {?P2}\n  is_quantum_predicate P\n  Suc k < n\n\ngoal (1 subgoal):\n 1. P \\<in> carrier_mat d d", "by auto"], ["proof (state)\nthis:\n  P \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. \\<And>k P.\n       \\<lbrakk>\\<And>P.\n                   \\<lbrakk>is_quantum_predicate P; k < n\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>p {adjoint\n                      (exexH_k k) *\n                     P *\n                     exexH_k k}\n                    hadamard_n (Suc k) {P};\n        is_quantum_predicate P; Suc k < n\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>p {adjoint (exexH_k (Suc k)) *\n         P *\n         exexH_k (Suc k)}\n        hadamard_n (Suc (Suc k)) {P}", "moreover"], ["proof (state)\nthis:\n  P \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. \\<And>k P.\n       \\<lbrakk>\\<And>P.\n                   \\<lbrakk>is_quantum_predicate P; k < n\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>p {adjoint\n                      (exexH_k k) *\n                     P *\n                     exexH_k k}\n                    hadamard_n (Suc k) {P};\n        is_quantum_predicate P; Suc k < n\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>p {adjoint (exexH_k (Suc k)) *\n         P *\n         exexH_k (Suc k)}\n        hadamard_n (Suc (Suc k)) {P}", "have dH: \"exexH_k k \\<in> carrier_mat d d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exexH_k k \\<in> carrier_mat d d", "using exexH_k_dim Suc"], ["proof (prove)\nusing this:\n  ?k < n \\<Longrightarrow> exexH_k ?k \\<in> carrier_mat d d\n  \\<lbrakk>is_quantum_predicate ?P2; k < n\\<rbrakk>\n  \\<Longrightarrow> \\<turnstile>\\<^sub>p {adjoint (exexH_k k) * ?P2 *\n    exexH_k k}\n   hadamard_n (Suc k) {?P2}\n  is_quantum_predicate P\n  Suc k < n\n\ngoal (1 subgoal):\n 1. exexH_k k \\<in> carrier_mat d d", "by auto"], ["proof (state)\nthis:\n  exexH_k k \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. \\<And>k P.\n       \\<lbrakk>\\<And>P.\n                   \\<lbrakk>is_quantum_predicate P; k < n\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>p {adjoint\n                      (exexH_k k) *\n                     P *\n                     exexH_k k}\n                    hadamard_n (Suc k) {P};\n        is_quantum_predicate P; Suc k < n\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>p {adjoint (exexH_k (Suc k)) *\n         P *\n         exexH_k (Suc k)}\n        hadamard_n (Suc (Suc k)) {P}", "moreover"], ["proof (state)\nthis:\n  exexH_k k \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. \\<And>k P.\n       \\<lbrakk>\\<And>P.\n                   \\<lbrakk>is_quantum_predicate P; k < n\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>p {adjoint\n                      (exexH_k k) *\n                     P *\n                     exexH_k k}\n                    hadamard_n (Suc k) {P};\n        is_quantum_predicate P; Suc k < n\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>p {adjoint (exexH_k (Suc k)) *\n         P *\n         exexH_k (Suc k)}\n        hadamard_n (Suc (Suc k)) {P}", "have dHi: \"tensor_P (hadamard_on_i (Suc k)) (1\\<^sub>m K) \\<in> carrier_mat d d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tensor_P (hadamard_on_i (Suc k)) (1\\<^sub>m K) \\<in> carrier_mat d d", "using tensor_P_dim"], ["proof (prove)\nusing this:\n  tensor_P ?A ?B \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. tensor_P (hadamard_on_i (Suc k)) (1\\<^sub>m K) \\<in> carrier_mat d d", "by auto"], ["proof (state)\nthis:\n  tensor_P (hadamard_on_i (Suc k)) (1\\<^sub>m K) \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. \\<And>k P.\n       \\<lbrakk>\\<And>P.\n                   \\<lbrakk>is_quantum_predicate P; k < n\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>p {adjoint\n                      (exexH_k k) *\n                     P *\n                     exexH_k k}\n                    hadamard_n (Suc k) {P};\n        is_quantum_predicate P; Suc k < n\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>p {adjoint (exexH_k (Suc k)) *\n         P *\n         exexH_k (Suc k)}\n        hadamard_n (Suc (Suc k)) {P}", "ultimately"], ["proof (chain)\npicking this:\n  P \\<in> carrier_mat d d\n  exexH_k k \\<in> carrier_mat d d\n  tensor_P (hadamard_on_i (Suc k)) (1\\<^sub>m K) \\<in> carrier_mat d d", "have eq3: \"adjoint (exexH_k k) * (adjoint (tensor_P (hadamard_on_i (Suc k)) (1\\<^sub>m K)) * P * tensor_P (hadamard_on_i (Suc k)) (1\\<^sub>m K)) * exexH_k k\n    = (adjoint (exexH_k k) * adjoint (tensor_P (hadamard_on_i (Suc k)) (1\\<^sub>m K))) * P * (tensor_P (hadamard_on_i (Suc k)) (1\\<^sub>m K) * exexH_k k)\""], ["proof (prove)\nusing this:\n  P \\<in> carrier_mat d d\n  exexH_k k \\<in> carrier_mat d d\n  tensor_P (hadamard_on_i (Suc k)) (1\\<^sub>m K) \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. adjoint (exexH_k k) *\n    (adjoint (tensor_P (hadamard_on_i (Suc k)) (1\\<^sub>m K)) * P *\n     tensor_P (hadamard_on_i (Suc k)) (1\\<^sub>m K)) *\n    exexH_k k =\n    adjoint (exexH_k k) *\n    adjoint (tensor_P (hadamard_on_i (Suc k)) (1\\<^sub>m K)) *\n    P *\n    (tensor_P (hadamard_on_i (Suc k)) (1\\<^sub>m K) * exexH_k k)", "by (mat_assoc d)"], ["proof (state)\nthis:\n  adjoint (exexH_k k) *\n  (adjoint (tensor_P (hadamard_on_i (Suc k)) (1\\<^sub>m K)) * P *\n   tensor_P (hadamard_on_i (Suc k)) (1\\<^sub>m K)) *\n  exexH_k k =\n  adjoint (exexH_k k) *\n  adjoint (tensor_P (hadamard_on_i (Suc k)) (1\\<^sub>m K)) *\n  P *\n  (tensor_P (hadamard_on_i (Suc k)) (1\\<^sub>m K) * exexH_k k)\n\ngoal (1 subgoal):\n 1. \\<And>k P.\n       \\<lbrakk>\\<And>P.\n                   \\<lbrakk>is_quantum_predicate P; k < n\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>p {adjoint\n                      (exexH_k k) *\n                     P *\n                     exexH_k k}\n                    hadamard_n (Suc k) {P};\n        is_quantum_predicate P; Suc k < n\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>p {adjoint (exexH_k (Suc k)) *\n         P *\n         exexH_k (Suc k)}\n        hadamard_n (Suc (Suc k)) {P}", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>p {adjoint (exexH_k (Suc k)) * P * exexH_k (Suc k)}\n                         hadamard_n (Suc (Suc k)) {P}", "apply (subst hadamard_n.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>p {adjoint (exexH_k (Suc k)) * P * exexH_k (Suc k)}\n                         hadamard_n (Suc k);;\n                         Utrans\n                          (tensor_P (hadamard_on_i (Suc k)) (1\\<^sub>m K))\n                         {P}", "apply (subst hoare_partial.intros(3)[of _ \"adjoint (tensor_P (hadamard_on_i (Suc k)) (1\\<^sub>m K)) * P * (tensor_P (hadamard_on_i (Suc k)) (1\\<^sub>m K))\"])"], ["proof (prove)\ngoal (6 subgoals):\n 1. is_quantum_predicate (adjoint (exexH_k (Suc k)) * P * exexH_k (Suc k))\n 2. is_quantum_predicate\n     (adjoint (tensor_P (hadamard_on_i (Suc k)) (1\\<^sub>m K)) * P *\n      tensor_P (hadamard_on_i (Suc k)) (1\\<^sub>m K))\n 3. is_quantum_predicate P\n 4. \\<turnstile>\\<^sub>p {adjoint (exexH_k (Suc k)) * P * exexH_k (Suc k)}\n                         hadamard_n (Suc k)\n                         {adjoint\n                           (tensor_P (hadamard_on_i (Suc k))\n                             (1\\<^sub>m K)) *\n                          P *\n                          tensor_P (hadamard_on_i (Suc k)) (1\\<^sub>m K)}\n 5. \\<turnstile>\\<^sub>p {adjoint\n                           (tensor_P (hadamard_on_i (Suc k))\n                             (1\\<^sub>m K)) *\n                          P *\n                          tensor_P (hadamard_on_i (Suc k)) (1\\<^sub>m K)}\n                         Utrans\n                          (tensor_P (hadamard_on_i (Suc k)) (1\\<^sub>m K))\n                         {P}\n 6. True", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_quantum_predicate (adjoint (exexH_k (Suc k)) * P * exexH_k (Suc k))", "using qp_close_after_exexH_k[of P \"Suc k\"] Suc"], ["proof (prove)\nusing this:\n  \\<lbrakk>is_quantum_predicate P; Suc k < n\\<rbrakk>\n  \\<Longrightarrow> is_quantum_predicate\n                     (adjoint (exexH_k (Suc k)) * P * exexH_k (Suc k))\n  \\<lbrakk>is_quantum_predicate ?P2; k < n\\<rbrakk>\n  \\<Longrightarrow> \\<turnstile>\\<^sub>p {adjoint (exexH_k k) * ?P2 *\n    exexH_k k}\n   hadamard_n (Suc k) {?P2}\n  is_quantum_predicate P\n  Suc k < n\n\ngoal (1 subgoal):\n 1. is_quantum_predicate (adjoint (exexH_k (Suc k)) * P * exexH_k (Suc k))", "by auto"], ["proof (prove)\ngoal (5 subgoals):\n 1. is_quantum_predicate\n     (adjoint (tensor_P (hadamard_on_i (Suc k)) (1\\<^sub>m K)) * P *\n      tensor_P (hadamard_on_i (Suc k)) (1\\<^sub>m K))\n 2. is_quantum_predicate P\n 3. \\<turnstile>\\<^sub>p {adjoint (exexH_k (Suc k)) * P * exexH_k (Suc k)}\n                         hadamard_n (Suc k)\n                         {adjoint\n                           (tensor_P (hadamard_on_i (Suc k))\n                             (1\\<^sub>m K)) *\n                          P *\n                          tensor_P (hadamard_on_i (Suc k)) (1\\<^sub>m K)}\n 4. \\<turnstile>\\<^sub>p {adjoint\n                           (tensor_P (hadamard_on_i (Suc k))\n                             (1\\<^sub>m K)) *\n                          P *\n                          tensor_P (hadamard_on_i (Suc k)) (1\\<^sub>m K)}\n                         Utrans\n                          (tensor_P (hadamard_on_i (Suc k)) (1\\<^sub>m K))\n                         {P}\n 5. True", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_quantum_predicate\n     (adjoint (tensor_P (hadamard_on_i (Suc k)) (1\\<^sub>m K)) * P *\n      tensor_P (hadamard_on_i (Suc k)) (1\\<^sub>m K))", "using qp"], ["proof (prove)\nusing this:\n  is_quantum_predicate\n   (adjoint (tensor_P (hadamard_on_i (Suc k)) (1\\<^sub>m K)) * P *\n    tensor_P (hadamard_on_i (Suc k)) (1\\<^sub>m K))\n\ngoal (1 subgoal):\n 1. is_quantum_predicate\n     (adjoint (tensor_P (hadamard_on_i (Suc k)) (1\\<^sub>m K)) * P *\n      tensor_P (hadamard_on_i (Suc k)) (1\\<^sub>m K))", "by auto"], ["proof (prove)\ngoal (4 subgoals):\n 1. is_quantum_predicate P\n 2. \\<turnstile>\\<^sub>p {adjoint (exexH_k (Suc k)) * P * exexH_k (Suc k)}\n                         hadamard_n (Suc k)\n                         {adjoint\n                           (tensor_P (hadamard_on_i (Suc k))\n                             (1\\<^sub>m K)) *\n                          P *\n                          tensor_P (hadamard_on_i (Suc k)) (1\\<^sub>m K)}\n 3. \\<turnstile>\\<^sub>p {adjoint\n                           (tensor_P (hadamard_on_i (Suc k))\n                             (1\\<^sub>m K)) *\n                          P *\n                          tensor_P (hadamard_on_i (Suc k)) (1\\<^sub>m K)}\n                         Utrans\n                          (tensor_P (hadamard_on_i (Suc k)) (1\\<^sub>m K))\n                         {P}\n 4. True", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_quantum_predicate P", "using Suc"], ["proof (prove)\nusing this:\n  \\<lbrakk>is_quantum_predicate ?P2; k < n\\<rbrakk>\n  \\<Longrightarrow> \\<turnstile>\\<^sub>p {adjoint (exexH_k k) * ?P2 *\n    exexH_k k}\n   hadamard_n (Suc k) {?P2}\n  is_quantum_predicate P\n  Suc k < n\n\ngoal (1 subgoal):\n 1. is_quantum_predicate P", "by auto"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<turnstile>\\<^sub>p {adjoint (exexH_k (Suc k)) * P * exexH_k (Suc k)}\n                         hadamard_n (Suc k)\n                         {adjoint\n                           (tensor_P (hadamard_on_i (Suc k))\n                             (1\\<^sub>m K)) *\n                          P *\n                          tensor_P (hadamard_on_i (Suc k)) (1\\<^sub>m K)}\n 2. \\<turnstile>\\<^sub>p {adjoint\n                           (tensor_P (hadamard_on_i (Suc k))\n                             (1\\<^sub>m K)) *\n                          P *\n                          tensor_P (hadamard_on_i (Suc k)) (1\\<^sub>m K)}\n                         Utrans\n                          (tensor_P (hadamard_on_i (Suc k)) (1\\<^sub>m K))\n                         {P}\n 3. True", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>p {adjoint (exexH_k (Suc k)) * P * exexH_k (Suc k)}\n                         hadamard_n (Suc k)\n                         {adjoint\n                           (tensor_P (hadamard_on_i (Suc k))\n                             (1\\<^sub>m K)) *\n                          P *\n                          tensor_P (hadamard_on_i (Suc k)) (1\\<^sub>m K)}", "using h2[simplified eq3 eq1 eq2]"], ["proof (prove)\nusing this:\n  \\<turnstile>\\<^sub>p {adjoint (exexH_k (Suc k)) * P * exexH_k (Suc k)}\n                       hadamard_n (Suc k)\n                       {adjoint\n                         (tensor_P (hadamard_on_i (Suc k)) (1\\<^sub>m K)) *\n                        P *\n                        tensor_P (hadamard_on_i (Suc k)) (1\\<^sub>m K)}\n\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>p {adjoint (exexH_k (Suc k)) * P * exexH_k (Suc k)}\n                         hadamard_n (Suc k)\n                         {adjoint\n                           (tensor_P (hadamard_on_i (Suc k))\n                             (1\\<^sub>m K)) *\n                          P *\n                          tensor_P (hadamard_on_i (Suc k)) (1\\<^sub>m K)}", "by auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<turnstile>\\<^sub>p {adjoint\n                           (tensor_P (hadamard_on_i (Suc k))\n                             (1\\<^sub>m K)) *\n                          P *\n                          tensor_P (hadamard_on_i (Suc k)) (1\\<^sub>m K)}\n                         Utrans\n                          (tensor_P (hadamard_on_i (Suc k)) (1\\<^sub>m K))\n                         {P}\n 2. True", "using h1"], ["proof (prove)\nusing this:\n  \\<turnstile>\\<^sub>p {adjoint\n                         (tensor_P (hadamard_on_i (Suc k)) (1\\<^sub>m K)) *\n                        P *\n                        tensor_P (hadamard_on_i (Suc k)) (1\\<^sub>m K)}\n                       Utrans\n                        (tensor_P (hadamard_on_i (Suc k)) (1\\<^sub>m K))\n                       {P}\n\ngoal (2 subgoals):\n 1. \\<turnstile>\\<^sub>p {adjoint\n                           (tensor_P (hadamard_on_i (Suc k))\n                             (1\\<^sub>m K)) *\n                          P *\n                          tensor_P (hadamard_on_i (Suc k)) (1\\<^sub>m K)}\n                         Utrans\n                          (tensor_P (hadamard_on_i (Suc k)) (1\\<^sub>m K))\n                         {P}\n 2. True", "by auto"], ["proof (state)\nthis:\n  \\<turnstile>\\<^sub>p {adjoint (exexH_k (Suc k)) * P * exexH_k (Suc k)}\n                       hadamard_n (Suc (Suc k)) {P}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma qp_pre:\n  \"is_quantum_predicate (tensor_P pre (proj_k 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_quantum_predicate (tensor_P pre (proj_k 0))", "unfolding is_quantum_predicate_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. tensor_P pre (proj_k 0) \\<in> carrier_mat d d \\<and>\n    positive (tensor_P pre (proj_k 0)) \\<and>\n    tensor_P pre (proj_k 0) \\<le>\\<^sub>L 1\\<^sub>m d", "proof (intro conjI)"], ["proof (state)\ngoal (3 subgoals):\n 1. tensor_P pre (proj_k 0) \\<in> carrier_mat d d\n 2. positive (tensor_P pre (proj_k 0))\n 3. tensor_P pre (proj_k 0) \\<le>\\<^sub>L 1\\<^sub>m d", "show \"tensor_P pre (proj_k 0) \\<in> carrier_mat d d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tensor_P pre (proj_k 0) \\<in> carrier_mat d d", "using tensor_P_dim"], ["proof (prove)\nusing this:\n  tensor_P ?A ?B \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. tensor_P pre (proj_k 0) \\<in> carrier_mat d d", "by auto"], ["proof (state)\nthis:\n  tensor_P pre (proj_k 0) \\<in> carrier_mat d d\n\ngoal (2 subgoals):\n 1. positive (tensor_P pre (proj_k 0))\n 2. tensor_P pre (proj_k 0) \\<le>\\<^sub>L 1\\<^sub>m d", "interpret st: partial_state dims vars1"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["proof (state)\ngoal (2 subgoals):\n 1. positive (tensor_P pre (proj_k 0))\n 2. tensor_P pre (proj_k 0) \\<le>\\<^sub>L 1\\<^sub>m d", "have d1: \"st.d1 = N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. st.d1 = N", "unfolding st.d1_def st.dims1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. prod_list (nths dims vars1) = N", "using d_vars1"], ["proof (prove)\nusing this:\n  prod_list (nths dims vars1) = N\n\ngoal (1 subgoal):\n 1. prod_list (nths dims vars1) = N", "by auto"], ["proof (state)\nthis:\n  st.d1 = N\n\ngoal (2 subgoals):\n 1. positive (tensor_P pre (proj_k 0))\n 2. tensor_P pre (proj_k 0) \\<le>\\<^sub>L 1\\<^sub>m d", "have d2: \"st.d2 = K\""], ["proof (prove)\ngoal (1 subgoal):\n 1. st.d2 = K", "unfolding st.d2_def st.dims2_def nths_uminus_vars1 dims_vars2"], ["proof (prove)\ngoal (1 subgoal):\n 1. prod_list [K] = K", "by auto"], ["proof (state)\nthis:\n  st.d2 = K\n\ngoal (2 subgoals):\n 1. positive (tensor_P pre (proj_k 0))\n 2. tensor_P pre (proj_k 0) \\<le>\\<^sub>L 1\\<^sub>m d", "show \"positive (tensor_P pre (proj_k 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. positive (tensor_P pre (proj_k 0))", "unfolding ps2_P.ptensor_mat_def ps2_P_dims0  ps2_P_vars1'"], ["proof (prove)\ngoal (1 subgoal):\n 1. positive (st.tensor_mat pre (proj_k 0))", "apply (subst st.tensor_mat_positive)"], ["proof (prove)\ngoal (5 subgoals):\n 1. pre \\<in> carrier_mat st.d1 st.d1\n 2. proj_k 0 \\<in> carrier_mat st.d2 st.d2\n 3. positive pre\n 4. positive (proj_k 0)\n 5. True", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. pre \\<in> carrier_mat st.d1 st.d1", "unfolding pre_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. outer_prod ket_pre ket_pre \\<in> carrier_mat st.d1 st.d1", "using outer_prod_dim ket_pre_def d1"], ["proof (prove)\nusing this:\n  \\<lbrakk>?v \\<in> carrier_vec ?n; ?w \\<in> carrier_vec ?m\\<rbrakk>\n  \\<Longrightarrow> outer_prod ?v ?w \\<in> carrier_mat ?n ?m\n  ket_pre = Matrix.vec N (\\<lambda>k. if k = 0 then 1 else 0)\n  st.d1 = N\n\ngoal (1 subgoal):\n 1. outer_prod ket_pre ket_pre \\<in> carrier_mat st.d1 st.d1", "by auto"], ["proof (prove)\ngoal (4 subgoals):\n 1. proj_k 0 \\<in> carrier_mat st.d2 st.d2\n 2. positive pre\n 3. positive (proj_k 0)\n 4. True", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. proj_k 0 \\<in> carrier_mat st.d2 st.d2", "unfolding proj_k_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. outer_prod (ket_k 0) (ket_k 0) \\<in> carrier_mat st.d2 st.d2", "using outer_prod_dim ket_k_def d2"], ["proof (prove)\nusing this:\n  \\<lbrakk>?v \\<in> carrier_vec ?n; ?w \\<in> carrier_vec ?m\\<rbrakk>\n  \\<Longrightarrow> outer_prod ?v ?w \\<in> carrier_mat ?n ?m\n  ket_k ?x = Matrix.vec K (\\<lambda>k. if k = ?x then 1 else 0)\n  st.d2 = K\n\ngoal (1 subgoal):\n 1. outer_prod (ket_k 0) (ket_k 0) \\<in> carrier_mat st.d2 st.d2", "by auto"], ["proof (prove)\ngoal (3 subgoals):\n 1. positive pre\n 2. positive (proj_k 0)\n 3. True", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. positive pre", "using positive_pre"], ["proof (prove)\nusing this:\n  positive pre\n\ngoal (1 subgoal):\n 1. positive pre", "by auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. positive (proj_k 0)\n 2. True", "using positive_proj_k[of 0] K_gt_0"], ["proof (prove)\nusing this:\n  positive (proj_k 0)\n  0 < K\n\ngoal (2 subgoals):\n 1. positive (proj_k 0)\n 2. True", "by auto"], ["proof (state)\nthis:\n  positive (tensor_P pre (proj_k 0))\n\ngoal (1 subgoal):\n 1. tensor_P pre (proj_k 0) \\<le>\\<^sub>L 1\\<^sub>m d", "show \"tensor_P pre (proj_k 0) \\<le>\\<^sub>L 1\\<^sub>m d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tensor_P pre (proj_k 0) \\<le>\\<^sub>L 1\\<^sub>m d", "unfolding ps2_P.ptensor_mat_def ps2_P_dims0  ps2_P_vars1'"], ["proof (prove)\ngoal (1 subgoal):\n 1. st.tensor_mat pre (proj_k 0) \\<le>\\<^sub>L 1\\<^sub>m d", "apply (subst st.tensor_mat_le_one)"], ["proof (prove)\ngoal (7 subgoals):\n 1. pre \\<in> carrier_mat st.d1 st.d1\n 2. proj_k 0 \\<in> carrier_mat st.d2 st.d2\n 3. positive pre\n 4. positive (proj_k 0)\n 5. pre \\<le>\\<^sub>L 1\\<^sub>m st.d1\n 6. proj_k 0 \\<le>\\<^sub>L 1\\<^sub>m st.d2\n 7. True", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. pre \\<in> carrier_mat st.d1 st.d1", "using pre_def ket_pre_def outer_prod_dim d1"], ["proof (prove)\nusing this:\n  pre = outer_prod ket_pre ket_pre\n  ket_pre = Matrix.vec N (\\<lambda>k. if k = 0 then 1 else 0)\n  \\<lbrakk>?v \\<in> carrier_vec ?n; ?w \\<in> carrier_vec ?m\\<rbrakk>\n  \\<Longrightarrow> outer_prod ?v ?w \\<in> carrier_mat ?n ?m\n  st.d1 = N\n\ngoal (1 subgoal):\n 1. pre \\<in> carrier_mat st.d1 st.d1", "by auto"], ["proof (prove)\ngoal (6 subgoals):\n 1. proj_k 0 \\<in> carrier_mat st.d2 st.d2\n 2. positive pre\n 3. positive (proj_k 0)\n 4. pre \\<le>\\<^sub>L 1\\<^sub>m st.d1\n 5. proj_k 0 \\<le>\\<^sub>L 1\\<^sub>m st.d2\n 6. True", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. proj_k 0 \\<in> carrier_mat st.d2 st.d2", "using proj_k_def K_gt_0 ket_k_def outer_prod_dim d2"], ["proof (prove)\nusing this:\n  proj_k ?x = outer_prod (ket_k ?x) (ket_k ?x)\n  0 < K\n  ket_k ?x = Matrix.vec K (\\<lambda>k. if k = ?x then 1 else 0)\n  \\<lbrakk>?v \\<in> carrier_vec ?n; ?w \\<in> carrier_vec ?m\\<rbrakk>\n  \\<Longrightarrow> outer_prod ?v ?w \\<in> carrier_mat ?n ?m\n  st.d2 = K\n\ngoal (1 subgoal):\n 1. proj_k 0 \\<in> carrier_mat st.d2 st.d2", "by auto"], ["proof (prove)\ngoal (5 subgoals):\n 1. positive pre\n 2. positive (proj_k 0)\n 3. pre \\<le>\\<^sub>L 1\\<^sub>m st.d1\n 4. proj_k 0 \\<le>\\<^sub>L 1\\<^sub>m st.d2\n 5. True", "using d1 d2  K_gt_0 outer_prod_dim positive_pre positive_proj_k pre_le_one proj_k_le_one"], ["proof (prove)\nusing this:\n  st.d1 = N\n  st.d2 = K\n  0 < K\n  \\<lbrakk>?v \\<in> carrier_vec ?n; ?w \\<in> carrier_vec ?m\\<rbrakk>\n  \\<Longrightarrow> outer_prod ?v ?w \\<in> carrier_mat ?n ?m\n  positive pre\n  positive (proj_k ?k)\n  pre \\<le>\\<^sub>L 1\\<^sub>m N\n  proj_k ?k \\<le>\\<^sub>L 1\\<^sub>m K\n\ngoal (5 subgoals):\n 1. positive pre\n 2. positive (proj_k 0)\n 3. pre \\<le>\\<^sub>L 1\\<^sub>m st.d1\n 4. proj_k 0 \\<le>\\<^sub>L 1\\<^sub>m st.d2\n 5. True", "by auto"], ["proof (state)\nthis:\n  tensor_P pre (proj_k 0) \\<le>\\<^sub>L 1\\<^sub>m d\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma qp_init_post:\n  \"is_quantum_predicate (tensor_P proj_psi (proj_k 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_quantum_predicate (tensor_P proj_psi (proj_k 0))", "unfolding is_quantum_predicate_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. tensor_P proj_psi (proj_k 0) \\<in> carrier_mat d d \\<and>\n    positive (tensor_P proj_psi (proj_k 0)) \\<and>\n    tensor_P proj_psi (proj_k 0) \\<le>\\<^sub>L 1\\<^sub>m d", "proof (intro conjI)"], ["proof (state)\ngoal (3 subgoals):\n 1. tensor_P proj_psi (proj_k 0) \\<in> carrier_mat d d\n 2. positive (tensor_P proj_psi (proj_k 0))\n 3. tensor_P proj_psi (proj_k 0) \\<le>\\<^sub>L 1\\<^sub>m d", "show \"tensor_P proj_psi (proj_k 0) \\<in> carrier_mat d d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tensor_P proj_psi (proj_k 0) \\<in> carrier_mat d d", "using tensor_P_dim"], ["proof (prove)\nusing this:\n  tensor_P ?A ?B \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. tensor_P proj_psi (proj_k 0) \\<in> carrier_mat d d", "by auto"], ["proof (state)\nthis:\n  tensor_P proj_psi (proj_k 0) \\<in> carrier_mat d d\n\ngoal (2 subgoals):\n 1. positive (tensor_P proj_psi (proj_k 0))\n 2. tensor_P proj_psi (proj_k 0) \\<le>\\<^sub>L 1\\<^sub>m d", "interpret st: partial_state dims vars1"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["proof (state)\ngoal (2 subgoals):\n 1. positive (tensor_P proj_psi (proj_k 0))\n 2. tensor_P proj_psi (proj_k 0) \\<le>\\<^sub>L 1\\<^sub>m d", "have d1: \"st.d1 = N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. st.d1 = N", "unfolding st.d1_def st.dims1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. prod_list (nths dims vars1) = N", "using d_vars1"], ["proof (prove)\nusing this:\n  prod_list (nths dims vars1) = N\n\ngoal (1 subgoal):\n 1. prod_list (nths dims vars1) = N", "by auto"], ["proof (state)\nthis:\n  st.d1 = N\n\ngoal (2 subgoals):\n 1. positive (tensor_P proj_psi (proj_k 0))\n 2. tensor_P proj_psi (proj_k 0) \\<le>\\<^sub>L 1\\<^sub>m d", "have d2: \"st.d2 = K\""], ["proof (prove)\ngoal (1 subgoal):\n 1. st.d2 = K", "unfolding st.d2_def st.dims2_def nths_uminus_vars1 dims_vars2"], ["proof (prove)\ngoal (1 subgoal):\n 1. prod_list [K] = K", "by auto"], ["proof (state)\nthis:\n  st.d2 = K\n\ngoal (2 subgoals):\n 1. positive (tensor_P proj_psi (proj_k 0))\n 2. tensor_P proj_psi (proj_k 0) \\<le>\\<^sub>L 1\\<^sub>m d", "show \"positive (tensor_P proj_psi (proj_k 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. positive (tensor_P proj_psi (proj_k 0))", "unfolding ps2_P.ptensor_mat_def ps2_P_dims0  ps2_P_vars1'"], ["proof (prove)\ngoal (1 subgoal):\n 1. positive (st.tensor_mat proj_psi (proj_k 0))", "apply (subst st.tensor_mat_positive)"], ["proof (prove)\ngoal (5 subgoals):\n 1. proj_psi \\<in> carrier_mat st.d1 st.d1\n 2. proj_k 0 \\<in> carrier_mat st.d2 st.d2\n 3. positive proj_psi\n 4. positive (proj_k 0)\n 5. True", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. proj_psi \\<in> carrier_mat st.d1 st.d1", "unfolding proj_psi_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. outer_prod \\<psi> \\<psi> \\<in> carrier_mat st.d1 st.d1", "using outer_prod_dim \\<psi>_def d1"], ["proof (prove)\nusing this:\n  \\<lbrakk>?v \\<in> carrier_vec ?n; ?w \\<in> carrier_vec ?m\\<rbrakk>\n  \\<Longrightarrow> outer_prod ?v ?w \\<in> carrier_mat ?n ?m\n  \\<psi> = Matrix.vec N (\\<lambda>x. complex_of_real (1 / sqrt (real N)))\n  st.d1 = N\n\ngoal (1 subgoal):\n 1. outer_prod \\<psi> \\<psi> \\<in> carrier_mat st.d1 st.d1", "by auto"], ["proof (prove)\ngoal (4 subgoals):\n 1. proj_k 0 \\<in> carrier_mat st.d2 st.d2\n 2. positive proj_psi\n 3. positive (proj_k 0)\n 4. True", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. proj_k 0 \\<in> carrier_mat st.d2 st.d2", "unfolding proj_k_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. outer_prod (ket_k 0) (ket_k 0) \\<in> carrier_mat st.d2 st.d2", "using outer_prod_dim ket_k_def d2"], ["proof (prove)\nusing this:\n  \\<lbrakk>?v \\<in> carrier_vec ?n; ?w \\<in> carrier_vec ?m\\<rbrakk>\n  \\<Longrightarrow> outer_prod ?v ?w \\<in> carrier_mat ?n ?m\n  ket_k ?x = Matrix.vec K (\\<lambda>k. if k = ?x then 1 else 0)\n  st.d2 = K\n\ngoal (1 subgoal):\n 1. outer_prod (ket_k 0) (ket_k 0) \\<in> carrier_mat st.d2 st.d2", "by auto"], ["proof (prove)\ngoal (3 subgoals):\n 1. positive proj_psi\n 2. positive (proj_k 0)\n 3. True", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. positive proj_psi", "using positive_proj_psi"], ["proof (prove)\nusing this:\n  positive proj_psi\n\ngoal (1 subgoal):\n 1. positive proj_psi", "by auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. positive (proj_k 0)\n 2. True", "using positive_proj_k[of 0] K_gt_0"], ["proof (prove)\nusing this:\n  positive (proj_k 0)\n  0 < K\n\ngoal (2 subgoals):\n 1. positive (proj_k 0)\n 2. True", "by auto"], ["proof (state)\nthis:\n  positive (tensor_P proj_psi (proj_k 0))\n\ngoal (1 subgoal):\n 1. tensor_P proj_psi (proj_k 0) \\<le>\\<^sub>L 1\\<^sub>m d", "show \"tensor_P proj_psi (proj_k 0) \\<le>\\<^sub>L 1\\<^sub>m d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tensor_P proj_psi (proj_k 0) \\<le>\\<^sub>L 1\\<^sub>m d", "unfolding ps2_P.ptensor_mat_def ps2_P_dims0  ps2_P_vars1'"], ["proof (prove)\ngoal (1 subgoal):\n 1. st.tensor_mat proj_psi (proj_k 0) \\<le>\\<^sub>L 1\\<^sub>m d", "apply (subst st.tensor_mat_le_one)"], ["proof (prove)\ngoal (7 subgoals):\n 1. proj_psi \\<in> carrier_mat st.d1 st.d1\n 2. proj_k 0 \\<in> carrier_mat st.d2 st.d2\n 3. positive proj_psi\n 4. positive (proj_k 0)\n 5. proj_psi \\<le>\\<^sub>L 1\\<^sub>m st.d1\n 6. proj_k 0 \\<le>\\<^sub>L 1\\<^sub>m st.d2\n 7. True", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. proj_psi \\<in> carrier_mat st.d1 st.d1", "using proj_psi_def outer_prod_dim d1"], ["proof (prove)\nusing this:\n  proj_psi = outer_prod \\<psi> \\<psi>\n  \\<lbrakk>?v \\<in> carrier_vec ?n; ?w \\<in> carrier_vec ?m\\<rbrakk>\n  \\<Longrightarrow> outer_prod ?v ?w \\<in> carrier_mat ?n ?m\n  st.d1 = N\n\ngoal (1 subgoal):\n 1. proj_psi \\<in> carrier_mat st.d1 st.d1", "by auto"], ["proof (prove)\ngoal (6 subgoals):\n 1. proj_k 0 \\<in> carrier_mat st.d2 st.d2\n 2. positive proj_psi\n 3. positive (proj_k 0)\n 4. proj_psi \\<le>\\<^sub>L 1\\<^sub>m st.d1\n 5. proj_k 0 \\<le>\\<^sub>L 1\\<^sub>m st.d2\n 6. True", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. proj_k 0 \\<in> carrier_mat st.d2 st.d2", "using proj_k_def K_gt_0 ket_k_def outer_prod_dim d2"], ["proof (prove)\nusing this:\n  proj_k ?x = outer_prod (ket_k ?x) (ket_k ?x)\n  0 < K\n  ket_k ?x = Matrix.vec K (\\<lambda>k. if k = ?x then 1 else 0)\n  \\<lbrakk>?v \\<in> carrier_vec ?n; ?w \\<in> carrier_vec ?m\\<rbrakk>\n  \\<Longrightarrow> outer_prod ?v ?w \\<in> carrier_mat ?n ?m\n  st.d2 = K\n\ngoal (1 subgoal):\n 1. proj_k 0 \\<in> carrier_mat st.d2 st.d2", "by auto"], ["proof (prove)\ngoal (5 subgoals):\n 1. positive proj_psi\n 2. positive (proj_k 0)\n 3. proj_psi \\<le>\\<^sub>L 1\\<^sub>m st.d1\n 4. proj_k 0 \\<le>\\<^sub>L 1\\<^sub>m st.d2\n 5. True", "using d1 d2  K_gt_0 outer_prod_dim positive_proj_psi positive_proj_k proj_psi_le_one proj_k_le_one"], ["proof (prove)\nusing this:\n  st.d1 = N\n  st.d2 = K\n  0 < K\n  \\<lbrakk>?v \\<in> carrier_vec ?n; ?w \\<in> carrier_vec ?m\\<rbrakk>\n  \\<Longrightarrow> outer_prod ?v ?w \\<in> carrier_mat ?n ?m\n  positive proj_psi\n  positive (proj_k ?k)\n  proj_psi \\<le>\\<^sub>L 1\\<^sub>m N\n  proj_k ?k \\<le>\\<^sub>L 1\\<^sub>m K\n\ngoal (5 subgoals):\n 1. positive proj_psi\n 2. positive (proj_k 0)\n 3. proj_psi \\<le>\\<^sub>L 1\\<^sub>m st.d1\n 4. proj_k 0 \\<le>\\<^sub>L 1\\<^sub>m st.d2\n 5. True", "by auto"], ["proof (state)\nthis:\n  tensor_P proj_psi (proj_k 0) \\<le>\\<^sub>L 1\\<^sub>m d\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma tensor_P_adjoint_left_right:\n  assumes \"m1 \\<in> carrier_mat N N\" and \"m2 \\<in> carrier_mat K K\" and \"m3 \\<in> carrier_mat N N\" and \"m4 \\<in> carrier_mat K K\"\n  shows \"adjoint (tensor_P m1 m2) * tensor_P m3 m4 * tensor_P m1 m2 = tensor_P (adjoint m1 * m3 * m1) (adjoint m2 * m4 * m2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adjoint (tensor_P m1 m2) * tensor_P m3 m4 * tensor_P m1 m2 =\n    tensor_P (adjoint m1 * m3 * m1) (adjoint m2 * m4 * m2)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. adjoint (tensor_P m1 m2) * tensor_P m3 m4 * tensor_P m1 m2 =\n    tensor_P (adjoint m1 * m3 * m1) (adjoint m2 * m4 * m2)", "have eq1: \"adjoint (tensor_P m1 m2) = tensor_P (adjoint m1) (adjoint m2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adjoint (tensor_P m1 m2) = tensor_P (adjoint m1) (adjoint m2)", "unfolding ps2_P.ptensor_mat_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. adjoint (ps_P.tensor_mat m1 m2) =\n    ps_P.tensor_mat (adjoint m1) (adjoint m2)", "apply (subst ps_P.tensor_mat_adjoint)"], ["proof (prove)\ngoal (3 subgoals):\n 1. m1 \\<in> carrier_mat ps_P.d1 ps_P.d1\n 2. m2 \\<in> carrier_mat ps_P.d2 ps_P.d2\n 3. ps_P.tensor_mat (adjoint m1) (adjoint m2) =\n    ps_P.tensor_mat (adjoint m1) (adjoint m2)", "using ps_P_d1 ps_P_d2 assms"], ["proof (prove)\nusing this:\n  ps_P.d1 = N\n  ps_P.d2 = K\n  m1 \\<in> carrier_mat N N\n  m2 \\<in> carrier_mat K K\n  m3 \\<in> carrier_mat N N\n  m4 \\<in> carrier_mat K K\n\ngoal (3 subgoals):\n 1. m1 \\<in> carrier_mat ps_P.d1 ps_P.d1\n 2. m2 \\<in> carrier_mat ps_P.d2 ps_P.d2\n 3. ps_P.tensor_mat (adjoint m1) (adjoint m2) =\n    ps_P.tensor_mat (adjoint m1) (adjoint m2)", "by auto"], ["proof (state)\nthis:\n  adjoint (tensor_P m1 m2) = tensor_P (adjoint m1) (adjoint m2)\n\ngoal (1 subgoal):\n 1. adjoint (tensor_P m1 m2) * tensor_P m3 m4 * tensor_P m1 m2 =\n    tensor_P (adjoint m1 * m3 * m1) (adjoint m2 * m4 * m2)", "have eq2: \"adjoint (tensor_P m1 m2) * tensor_P m3 m4 = tensor_P (adjoint m1 * m3) (adjoint m2 * m4)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adjoint (tensor_P m1 m2) * tensor_P m3 m4 =\n    tensor_P (adjoint m1 * m3) (adjoint m2 * m4)", "unfolding ps2_P.ptensor_mat_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. adjoint (ps_P.tensor_mat m1 m2) * ps_P.tensor_mat m3 m4 =\n    ps_P.tensor_mat (adjoint m1 * m3) (adjoint m2 * m4)", "apply (subst ps_P.tensor_mat_mult)"], ["proof (prove)\ngoal (5 subgoals):\n 1. adjoint m1 \\<in> carrier_mat ps_P.d1 ps_P.d1\n 2. m3 \\<in> carrier_mat ps_P.d1 ps_P.d1\n 3. adjoint m2 \\<in> carrier_mat ps_P.d2 ps_P.d2\n 4. m4 \\<in> carrier_mat ps_P.d2 ps_P.d2\n 5. adjoint (ps_P.tensor_mat m1 m2) * ps_P.tensor_mat m3 m4 =\n    ps_P.tensor_mat (adjoint m1) (adjoint m2) * ps_P.tensor_mat m3 m4", "using ps_P_d1 ps_P_d2 assms eq1"], ["proof (prove)\nusing this:\n  ps_P.d1 = N\n  ps_P.d2 = K\n  m1 \\<in> carrier_mat N N\n  m2 \\<in> carrier_mat K K\n  m3 \\<in> carrier_mat N N\n  m4 \\<in> carrier_mat K K\n  adjoint (tensor_P m1 m2) = tensor_P (adjoint m1) (adjoint m2)\n\ngoal (5 subgoals):\n 1. adjoint m1 \\<in> carrier_mat ps_P.d1 ps_P.d1\n 2. m3 \\<in> carrier_mat ps_P.d1 ps_P.d1\n 3. adjoint m2 \\<in> carrier_mat ps_P.d2 ps_P.d2\n 4. m4 \\<in> carrier_mat ps_P.d2 ps_P.d2\n 5. adjoint (ps_P.tensor_mat m1 m2) * ps_P.tensor_mat m3 m4 =\n    ps_P.tensor_mat (adjoint m1) (adjoint m2) * ps_P.tensor_mat m3 m4", "unfolding ps2_P.ptensor_mat_def"], ["proof (prove)\nusing this:\n  ps_P.d1 = N\n  ps_P.d2 = K\n  m1 \\<in> carrier_mat N N\n  m2 \\<in> carrier_mat K K\n  m3 \\<in> carrier_mat N N\n  m4 \\<in> carrier_mat K K\n  adjoint (ps_P.tensor_mat m1 m2) =\n  ps_P.tensor_mat (adjoint m1) (adjoint m2)\n\ngoal (5 subgoals):\n 1. adjoint m1 \\<in> carrier_mat ps_P.d1 ps_P.d1\n 2. m3 \\<in> carrier_mat ps_P.d1 ps_P.d1\n 3. adjoint m2 \\<in> carrier_mat ps_P.d2 ps_P.d2\n 4. m4 \\<in> carrier_mat ps_P.d2 ps_P.d2\n 5. adjoint (ps_P.tensor_mat m1 m2) * ps_P.tensor_mat m3 m4 =\n    ps_P.tensor_mat (adjoint m1) (adjoint m2) * ps_P.tensor_mat m3 m4", "by (auto simp add: adjoint_dim)"], ["proof (state)\nthis:\n  adjoint (tensor_P m1 m2) * tensor_P m3 m4 =\n  tensor_P (adjoint m1 * m3) (adjoint m2 * m4)\n\ngoal (1 subgoal):\n 1. adjoint (tensor_P m1 m2) * tensor_P m3 m4 * tensor_P m1 m2 =\n    tensor_P (adjoint m1 * m3 * m1) (adjoint m2 * m4 * m2)", "have eq3: \"tensor_P (adjoint m1 * m3) (adjoint m2 * m4) * (tensor_P m1 m2) = tensor_P (adjoint m1 * m3 * m1) (adjoint m2 * m4 * m2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tensor_P (adjoint m1 * m3) (adjoint m2 * m4) * tensor_P m1 m2 =\n    tensor_P (adjoint m1 * m3 * m1) (adjoint m2 * m4 * m2)", "unfolding ps2_P.ptensor_mat_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ps_P.tensor_mat (adjoint m1 * m3) (adjoint m2 * m4) *\n    ps_P.tensor_mat m1 m2 =\n    ps_P.tensor_mat (adjoint m1 * m3 * m1) (adjoint m2 * m4 * m2)", "apply (subst ps_P.tensor_mat_mult[of \"adjoint m1 * m3\"])"], ["proof (prove)\ngoal (5 subgoals):\n 1. adjoint m1 * m3 \\<in> carrier_mat ps_P.d1 ps_P.d1\n 2. m1 \\<in> carrier_mat ps_P.d1 ps_P.d1\n 3. adjoint m2 * m4 \\<in> carrier_mat ps_P.d2 ps_P.d2\n 4. m2 \\<in> carrier_mat ps_P.d2 ps_P.d2\n 5. ps_P.tensor_mat (adjoint m1 * m3) (adjoint m2 * m4) *\n    ps_P.tensor_mat m1 m2 =\n    ps_P.tensor_mat (adjoint m1 * m3) (adjoint m2 * m4) *\n    ps_P.tensor_mat m1 m2", "using ps_P_d1 ps_P_d2 assms"], ["proof (prove)\nusing this:\n  ps_P.d1 = N\n  ps_P.d2 = K\n  m1 \\<in> carrier_mat N N\n  m2 \\<in> carrier_mat K K\n  m3 \\<in> carrier_mat N N\n  m4 \\<in> carrier_mat K K\n\ngoal (5 subgoals):\n 1. adjoint m1 * m3 \\<in> carrier_mat ps_P.d1 ps_P.d1\n 2. m1 \\<in> carrier_mat ps_P.d1 ps_P.d1\n 3. adjoint m2 * m4 \\<in> carrier_mat ps_P.d2 ps_P.d2\n 4. m2 \\<in> carrier_mat ps_P.d2 ps_P.d2\n 5. ps_P.tensor_mat (adjoint m1 * m3) (adjoint m2 * m4) *\n    ps_P.tensor_mat m1 m2 =\n    ps_P.tensor_mat (adjoint m1 * m3) (adjoint m2 * m4) *\n    ps_P.tensor_mat m1 m2", "by (auto simp add: adjoint_dim)"], ["proof (state)\nthis:\n  tensor_P (adjoint m1 * m3) (adjoint m2 * m4) * tensor_P m1 m2 =\n  tensor_P (adjoint m1 * m3 * m1) (adjoint m2 * m4 * m2)\n\ngoal (1 subgoal):\n 1. adjoint (tensor_P m1 m2) * tensor_P m3 m4 * tensor_P m1 m2 =\n    tensor_P (adjoint m1 * m3 * m1) (adjoint m2 * m4 * m2)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. adjoint (tensor_P m1 m2) * tensor_P m3 m4 * tensor_P m1 m2 =\n    tensor_P (adjoint m1 * m3 * m1) (adjoint m2 * m4 * m2)", "using eq1 eq2 eq3"], ["proof (prove)\nusing this:\n  adjoint (tensor_P m1 m2) = tensor_P (adjoint m1) (adjoint m2)\n  adjoint (tensor_P m1 m2) * tensor_P m3 m4 =\n  tensor_P (adjoint m1 * m3) (adjoint m2 * m4)\n  tensor_P (adjoint m1 * m3) (adjoint m2 * m4) * tensor_P m1 m2 =\n  tensor_P (adjoint m1 * m3 * m1) (adjoint m2 * m4 * m2)\n\ngoal (1 subgoal):\n 1. adjoint (tensor_P m1 m2) * tensor_P m3 m4 * tensor_P m1 m2 =\n    tensor_P (adjoint m1 * m3 * m1) (adjoint m2 * m4 * m2)", "by auto"], ["proof (state)\nthis:\n  adjoint (tensor_P m1 m2) * tensor_P m3 m4 * tensor_P m1 m2 =\n  tensor_P (adjoint m1 * m3 * m1) (adjoint m2 * m4 * m2)\n\ngoal:\nNo subgoals!", "qed"], ["", "abbreviation exH_n where\n  \"exH_n \\<equiv> exH_k (n - 1)\""], ["", "lemma hoare_triple_init:\n  \"\\<turnstile>\\<^sub>p \n   {tensor_P pre (proj_k 0)} \n   hadamard_n n\n   {tensor_P proj_psi (proj_k 0)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>p {tensor_P pre (proj_k 0)} hadamard_n n\n                         {tensor_P proj_psi (proj_k 0)}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>p {tensor_P pre (proj_k 0)} hadamard_n n\n                         {tensor_P proj_psi (proj_k 0)}", "have h: \"\\<turnstile>\\<^sub>p \n   {adjoint (exexH_k (n - 1)) * (tensor_P proj_psi (proj_k 0)) * (exexH_k (n - 1))} \n   hadamard_n n\n   {tensor_P proj_psi (proj_k 0)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>p {adjoint (exexH_k (n - 1)) *\n                          tensor_P proj_psi (proj_k 0) *\n                          exexH_k (n - 1)}\n                         hadamard_n n {tensor_P proj_psi (proj_k 0)}", "using hoare_hadamard_n[OF qp_init_post, of \"n - 1\"] qp_init_post n"], ["proof (prove)\nusing this:\n  n - 1 < n \\<Longrightarrow>\n  \\<turnstile>\\<^sub>p {adjoint (exexH_k (n - 1)) *\n                        tensor_P proj_psi (proj_k 0) *\n                        exexH_k (n - 1)}\n                       hadamard_n (Suc (n - 1))\n                       {tensor_P proj_psi (proj_k 0)}\n  is_quantum_predicate (tensor_P proj_psi (proj_k 0))\n  1 < n\n\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>p {adjoint (exexH_k (n - 1)) *\n                          tensor_P proj_psi (proj_k 0) *\n                          exexH_k (n - 1)}\n                         hadamard_n n {tensor_P proj_psi (proj_k 0)}", "by auto"], ["proof (state)\nthis:\n  \\<turnstile>\\<^sub>p {adjoint (exexH_k (n - 1)) *\n                        tensor_P proj_psi (proj_k 0) *\n                        exexH_k (n - 1)}\n                       hadamard_n n {tensor_P proj_psi (proj_k 0)}\n\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>p {tensor_P pre (proj_k 0)} hadamard_n n\n                         {tensor_P proj_psi (proj_k 0)}", "have \"adjoint (exexH_k (n - 1)) * tensor_P proj_psi (proj_k 0) * exexH_k (n - 1) =\n        tensor_P (adjoint exH_n * proj_psi * exH_n) (adjoint (1\\<^sub>m K) * proj_k 0 * 1\\<^sub>m K)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adjoint (exexH_k (n - 1)) * tensor_P proj_psi (proj_k 0) *\n    exexH_k (n - 1) =\n    tensor_P (adjoint exH_n * proj_psi * exH_n)\n     (adjoint (1\\<^sub>m K) * proj_k 0 * 1\\<^sub>m K)", "unfolding exexH_k.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. adjoint (tensor_P exH_n (1\\<^sub>m K)) * tensor_P proj_psi (proj_k 0) *\n    tensor_P exH_n (1\\<^sub>m K) =\n    tensor_P (adjoint exH_n * proj_psi * exH_n)\n     (adjoint (1\\<^sub>m K) * proj_k 0 * 1\\<^sub>m K)", "apply (subst tensor_P_adjoint_left_right)"], ["proof (prove)\ngoal (5 subgoals):\n 1. exH_n \\<in> carrier_mat N N\n 2. 1\\<^sub>m K \\<in> carrier_mat K K\n 3. proj_psi \\<in> carrier_mat N N\n 4. proj_k 0 \\<in> carrier_mat K K\n 5. tensor_P (adjoint exH_n * proj_psi * exH_n)\n     (adjoint (1\\<^sub>m K) * proj_k 0 * 1\\<^sub>m K) =\n    tensor_P (adjoint exH_n * proj_psi * exH_n)\n     (adjoint (1\\<^sub>m K) * proj_k 0 * 1\\<^sub>m K)", "using exH_k_dim proj_psi_def \\<psi>_def  proj_k_def ket_k_def n"], ["proof (prove)\nusing this:\n  ?k < n \\<Longrightarrow> exH_k ?k \\<in> carrier_mat N N\n  proj_psi = outer_prod \\<psi> \\<psi>\n  \\<psi> = Matrix.vec N (\\<lambda>x. complex_of_real (1 / sqrt (real N)))\n  proj_k ?x = outer_prod (ket_k ?x) (ket_k ?x)\n  ket_k ?x = Matrix.vec K (\\<lambda>k. if k = ?x then 1 else 0)\n  1 < n\n\ngoal (5 subgoals):\n 1. exH_n \\<in> carrier_mat N N\n 2. 1\\<^sub>m K \\<in> carrier_mat K K\n 3. proj_psi \\<in> carrier_mat N N\n 4. proj_k 0 \\<in> carrier_mat K K\n 5. tensor_P (adjoint exH_n * proj_psi * exH_n)\n     (adjoint (1\\<^sub>m K) * proj_k 0 * 1\\<^sub>m K) =\n    tensor_P (adjoint exH_n * proj_psi * exH_n)\n     (adjoint (1\\<^sub>m K) * proj_k 0 * 1\\<^sub>m K)", "by (auto)"], ["proof (state)\nthis:\n  adjoint (exexH_k (n - 1)) * tensor_P proj_psi (proj_k 0) *\n  exexH_k (n - 1) =\n  tensor_P (adjoint exH_n * proj_psi * exH_n)\n   (adjoint (1\\<^sub>m K) * proj_k 0 * 1\\<^sub>m K)\n\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>p {tensor_P pre (proj_k 0)} hadamard_n n\n                         {tensor_P proj_psi (proj_k 0)}", "moreover"], ["proof (state)\nthis:\n  adjoint (exexH_k (n - 1)) * tensor_P proj_psi (proj_k 0) *\n  exexH_k (n - 1) =\n  tensor_P (adjoint exH_n * proj_psi * exH_n)\n   (adjoint (1\\<^sub>m K) * proj_k 0 * 1\\<^sub>m K)\n\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>p {tensor_P pre (proj_k 0)} hadamard_n n\n                         {tensor_P proj_psi (proj_k 0)}", "have \"adjoint exH_n * proj_psi * exH_n = pre\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adjoint exH_n * proj_psi * exH_n = pre", "unfolding proj_psi_def pre_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. adjoint exH_n * outer_prod \\<psi> \\<psi> * exH_n =\n    outer_prod ket_pre ket_pre", "apply (subst outer_prod_left_right_mat[of _ N _ N _ N _ N])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<psi> \\<in> carrier_vec N\n 2. adjoint exH_n \\<in> carrier_mat N N\n 3. exH_n \\<in> carrier_mat N N\n 4. outer_prod (adjoint exH_n *\\<^sub>v \\<psi>)\n     (adjoint exH_n *\\<^sub>v \\<psi>) =\n    outer_prod ket_pre ket_pre", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<psi> \\<in> carrier_vec N", "using \\<psi>_def"], ["proof (prove)\nusing this:\n  \\<psi> = Matrix.vec N (\\<lambda>x. complex_of_real (1 / sqrt (real N)))\n\ngoal (1 subgoal):\n 1. \\<psi> \\<in> carrier_vec N", "by auto"], ["proof (prove)\ngoal (3 subgoals):\n 1. adjoint exH_n \\<in> carrier_mat N N\n 2. exH_n \\<in> carrier_mat N N\n 3. outer_prod (adjoint exH_n *\\<^sub>v \\<psi>)\n     (adjoint exH_n *\\<^sub>v \\<psi>) =\n    outer_prod ket_pre ket_pre", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. adjoint exH_n \\<in> carrier_mat N N", "using exH_k_dim n"], ["proof (prove)\nusing this:\n  ?k < n \\<Longrightarrow> exH_k ?k \\<in> carrier_mat N N\n  1 < n\n\ngoal (1 subgoal):\n 1. adjoint exH_n \\<in> carrier_mat N N", "by (simp add: adjoint_dim)"], ["proof (prove)\ngoal (2 subgoals):\n 1. exH_n \\<in> carrier_mat N N\n 2. outer_prod (adjoint exH_n *\\<^sub>v \\<psi>)\n     (adjoint exH_n *\\<^sub>v \\<psi>) =\n    outer_prod ket_pre ket_pre", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. exH_n \\<in> carrier_mat N N", "using exH_k_dim n"], ["proof (prove)\nusing this:\n  ?k < n \\<Longrightarrow> exH_k ?k \\<in> carrier_mat N N\n  1 < n\n\ngoal (1 subgoal):\n 1. exH_n \\<in> carrier_mat N N", "by simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. outer_prod (adjoint exH_n *\\<^sub>v \\<psi>)\n     (adjoint exH_n *\\<^sub>v \\<psi>) =\n    outer_prod ket_pre ket_pre", "apply (subst (1 2) hermitian_exH_n[simplified hermitian_def])"], ["proof (prove)\ngoal (1 subgoal):\n 1. outer_prod (exH_n *\\<^sub>v \\<psi>) (exH_n *\\<^sub>v \\<psi>) =\n    outer_prod ket_pre ket_pre", "apply (subst (1 2) exH_k_mult_psi_is_pre)"], ["proof (prove)\ngoal (1 subgoal):\n 1. outer_prod ket_pre ket_pre = outer_prod ket_pre ket_pre", "by auto"], ["proof (state)\nthis:\n  adjoint exH_n * proj_psi * exH_n = pre\n\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>p {tensor_P pre (proj_k 0)} hadamard_n n\n                         {tensor_P proj_psi (proj_k 0)}", "moreover"], ["proof (state)\nthis:\n  adjoint exH_n * proj_psi * exH_n = pre\n\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>p {tensor_P pre (proj_k 0)} hadamard_n n\n                         {tensor_P proj_psi (proj_k 0)}", "have \"adjoint (1\\<^sub>m K) * (proj_k 0) * (1\\<^sub>m K) = proj_k 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adjoint (1\\<^sub>m K) * proj_k 0 * 1\\<^sub>m K = proj_k 0", "apply (subst adjoint_one)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1\\<^sub>m K * proj_k 0 * 1\\<^sub>m K = proj_k 0", "using proj_k_dim[of 0] K_gt_0"], ["proof (prove)\nusing this:\n  proj_k 0 \\<in> carrier_mat K K\n  0 < K\n\ngoal (1 subgoal):\n 1. 1\\<^sub>m K * proj_k 0 * 1\\<^sub>m K = proj_k 0", "by auto"], ["proof (state)\nthis:\n  adjoint (1\\<^sub>m K) * proj_k 0 * 1\\<^sub>m K = proj_k 0\n\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>p {tensor_P pre (proj_k 0)} hadamard_n n\n                         {tensor_P proj_psi (proj_k 0)}", "ultimately"], ["proof (chain)\npicking this:\n  adjoint (exexH_k (n - 1)) * tensor_P proj_psi (proj_k 0) *\n  exexH_k (n - 1) =\n  tensor_P (adjoint exH_n * proj_psi * exH_n)\n   (adjoint (1\\<^sub>m K) * proj_k 0 * 1\\<^sub>m K)\n  adjoint exH_n * proj_psi * exH_n = pre\n  adjoint (1\\<^sub>m K) * proj_k 0 * 1\\<^sub>m K = proj_k 0", "have \"adjoint (exexH_k (n - 1)) * tensor_P proj_psi (proj_k 0) * exexH_k (n - 1) = tensor_P pre (proj_k 0)\""], ["proof (prove)\nusing this:\n  adjoint (exexH_k (n - 1)) * tensor_P proj_psi (proj_k 0) *\n  exexH_k (n - 1) =\n  tensor_P (adjoint exH_n * proj_psi * exH_n)\n   (adjoint (1\\<^sub>m K) * proj_k 0 * 1\\<^sub>m K)\n  adjoint exH_n * proj_psi * exH_n = pre\n  adjoint (1\\<^sub>m K) * proj_k 0 * 1\\<^sub>m K = proj_k 0\n\ngoal (1 subgoal):\n 1. adjoint (exexH_k (n - 1)) * tensor_P proj_psi (proj_k 0) *\n    exexH_k (n - 1) =\n    tensor_P pre (proj_k 0)", "by auto"], ["proof (state)\nthis:\n  adjoint (exexH_k (n - 1)) * tensor_P proj_psi (proj_k 0) *\n  exexH_k (n - 1) =\n  tensor_P pre (proj_k 0)\n\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>p {tensor_P pre (proj_k 0)} hadamard_n n\n                         {tensor_P proj_psi (proj_k 0)}", "with h"], ["proof (chain)\npicking this:\n  \\<turnstile>\\<^sub>p {adjoint (exexH_k (n - 1)) *\n                        tensor_P proj_psi (proj_k 0) *\n                        exexH_k (n - 1)}\n                       hadamard_n n {tensor_P proj_psi (proj_k 0)}\n  adjoint (exexH_k (n - 1)) * tensor_P proj_psi (proj_k 0) *\n  exexH_k (n - 1) =\n  tensor_P pre (proj_k 0)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<turnstile>\\<^sub>p {adjoint (exexH_k (n - 1)) *\n                        tensor_P proj_psi (proj_k 0) *\n                        exexH_k (n - 1)}\n                       hadamard_n n {tensor_P proj_psi (proj_k 0)}\n  adjoint (exexH_k (n - 1)) * tensor_P proj_psi (proj_k 0) *\n  exexH_k (n - 1) =\n  tensor_P pre (proj_k 0)\n\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>p {tensor_P pre (proj_k 0)} hadamard_n n\n                         {tensor_P proj_psi (proj_k 0)}", "by auto"], ["proof (state)\nthis:\n  \\<turnstile>\\<^sub>p {tensor_P pre (proj_k 0)} hadamard_n n\n                       {tensor_P proj_psi (proj_k 0)}\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Hoare triples of while loop\\<close>"], ["", "definition proj_psi_l where\n  \"proj_psi_l l = proj (psi_l l)\""], ["", "lemma positive_psi_l:\n  \"k < K \\<Longrightarrow> positive (proj_psi_l k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k < K \\<Longrightarrow> positive (proj_psi_l k)", "unfolding proj_psi_l_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. k < K \\<Longrightarrow> positive (outer_prod (psi_l k) (psi_l k))", "apply (subst positive_same_outer_prod)"], ["proof (prove)\ngoal (2 subgoals):\n 1. k < K \\<Longrightarrow> psi_l k \\<in> carrier_vec ?n\n 2. k < K \\<Longrightarrow> True", "using psi_l_dim"], ["proof (prove)\nusing this:\n  psi_l ?l \\<in> carrier_vec N\n\ngoal (2 subgoals):\n 1. k < K \\<Longrightarrow> psi_l k \\<in> carrier_vec ?n\n 2. k < K \\<Longrightarrow> True", "by auto"], ["", "lemma hermitian_proj_psi_l:\n  \"k < K \\<Longrightarrow> hermitian (proj_psi_l k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k < K \\<Longrightarrow> hermitian (proj_psi_l k)", "using positive_psi_l positive_is_hermitian"], ["proof (prove)\nusing this:\n  ?k < K \\<Longrightarrow> positive (proj_psi_l ?k)\n  positive ?A \\<Longrightarrow> hermitian ?A\n\ngoal (1 subgoal):\n 1. k < K \\<Longrightarrow> hermitian (proj_psi_l k)", "by auto"], ["", "definition P' where\n  \"P' = tensor_P (proj_psi_l R) (proj_k R)\""], ["", "lemma proj_psi_l_dim:\n  \"proj_psi_l l \\<in> carrier_mat N N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proj_psi_l l \\<in> carrier_mat N N", "unfolding proj_psi_l_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. outer_prod (psi_l l) (psi_l l) \\<in> carrier_mat N N", "using psi_l_def"], ["proof (prove)\nusing this:\n  psi_l ?l =\n  alpha_l ?l \\<cdot>\\<^sub>v \\<alpha> + beta_l ?l \\<cdot>\\<^sub>v \\<beta>\n\ngoal (1 subgoal):\n 1. outer_prod (psi_l l) (psi_l l) \\<in> carrier_mat N N", "by auto"], ["", "definition Q :: \"complex mat\" where\n  \"Q = matrix_sum d (\\<lambda>l. tensor_P (proj_psi_l l) (proj_k l)) R\""], ["", "lemma psi_l_le_id:\n  shows \"proj_psi_l l \\<le>\\<^sub>L 1\\<^sub>m N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proj_psi_l l \\<le>\\<^sub>L 1\\<^sub>m N", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. proj_psi_l l \\<le>\\<^sub>L 1\\<^sub>m N", "have \"inner_prod (psi_l l) (psi_l l) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inner_prod (psi_l l) (psi_l l) = 1", "using inner_psi_l"], ["proof (prove)\nusing this:\n  inner_prod (psi_l ?l) (psi_l ?l) = 1\n\ngoal (1 subgoal):\n 1. inner_prod (psi_l l) (psi_l l) = 1", "by auto"], ["proof (state)\nthis:\n  inner_prod (psi_l l) (psi_l l) = 1\n\ngoal (1 subgoal):\n 1. proj_psi_l l \\<le>\\<^sub>L 1\\<^sub>m N", "then"], ["proof (chain)\npicking this:\n  inner_prod (psi_l l) (psi_l l) = 1", "show ?thesis"], ["proof (prove)\nusing this:\n  inner_prod (psi_l l) (psi_l l) = 1\n\ngoal (1 subgoal):\n 1. proj_psi_l l \\<le>\\<^sub>L 1\\<^sub>m N", "using outer_prod_le_one psi_l_def proj_psi_l_def"], ["proof (prove)\nusing this:\n  inner_prod (psi_l l) (psi_l l) = 1\n  \\<lbrakk>?v \\<in> carrier_vec ?n; inner_prod ?v ?v \\<le> 1\\<rbrakk>\n  \\<Longrightarrow> outer_prod ?v ?v \\<le>\\<^sub>L 1\\<^sub>m ?n\n  psi_l ?l =\n  alpha_l ?l \\<cdot>\\<^sub>v \\<alpha> + beta_l ?l \\<cdot>\\<^sub>v \\<beta>\n  proj_psi_l ?l = outer_prod (psi_l ?l) (psi_l ?l)\n\ngoal (1 subgoal):\n 1. proj_psi_l l \\<le>\\<^sub>L 1\\<^sub>m N", "by auto"], ["proof (state)\nthis:\n  proj_psi_l l \\<le>\\<^sub>L 1\\<^sub>m N\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma positive_proj_psi_l:\n  shows \"positive (proj_psi_l l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. positive (proj_psi_l l)", "using positive_same_outer_prod proj_psi_l_def psi_l_dim"], ["proof (prove)\nusing this:\n  ?v \\<in> carrier_vec ?n \\<Longrightarrow> positive (outer_prod ?v ?v)\n  proj_psi_l ?l = outer_prod (psi_l ?l) (psi_l ?l)\n  psi_l ?l \\<in> carrier_vec N\n\ngoal (1 subgoal):\n 1. positive (proj_psi_l l)", "by auto"], ["", "definition proj_fst_k :: \"nat \\<Rightarrow> complex mat\" where\n  \"proj_fst_k k = mat K K (\\<lambda>(i, j). if (i = j \\<and> i < k) then 1 else 0)\""], ["", "lemma hermitian_proj_fst_k:\n  \"adjoint (proj_fst_k k) = proj_fst_k k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adjoint (proj_fst_k k) = proj_fst_k k", "by (auto simp add: proj_fst_k_def adjoint_eval)"], ["", "lemma proj_fst_k_is_projection:\n  \"proj_fst_k k * proj_fst_k k = proj_fst_k k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proj_fst_k k * proj_fst_k k = proj_fst_k k", "by (auto simp add: proj_fst_k_def scalar_prod_def sum_only_one_neq_0)"], ["", "lemma positive_proj_fst_k:\n  \"positive (proj_fst_k k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. positive (proj_fst_k k)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. positive (proj_fst_k k)", "have \"(proj_fst_k k) * adjoint (proj_fst_k k) = (proj_fst_k k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proj_fst_k k * adjoint (proj_fst_k k) = proj_fst_k k", "using hermitian_proj_fst_k proj_fst_k_is_projection"], ["proof (prove)\nusing this:\n  adjoint (proj_fst_k ?k) = proj_fst_k ?k\n  proj_fst_k ?k * proj_fst_k ?k = proj_fst_k ?k\n\ngoal (1 subgoal):\n 1. proj_fst_k k * adjoint (proj_fst_k k) = proj_fst_k k", "by auto"], ["proof (state)\nthis:\n  proj_fst_k k * adjoint (proj_fst_k k) = proj_fst_k k\n\ngoal (1 subgoal):\n 1. positive (proj_fst_k k)", "then"], ["proof (chain)\npicking this:\n  proj_fst_k k * adjoint (proj_fst_k k) = proj_fst_k k", "have \"\\<exists>M. M * adjoint M = (proj_fst_k k)\""], ["proof (prove)\nusing this:\n  proj_fst_k k * adjoint (proj_fst_k k) = proj_fst_k k\n\ngoal (1 subgoal):\n 1. \\<exists>M. M * adjoint M = proj_fst_k k", "by auto"], ["proof (state)\nthis:\n  \\<exists>M. M * adjoint M = proj_fst_k k\n\ngoal (1 subgoal):\n 1. positive (proj_fst_k k)", "then"], ["proof (chain)\npicking this:\n  \\<exists>M. M * adjoint M = proj_fst_k k", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>M. M * adjoint M = proj_fst_k k\n\ngoal (1 subgoal):\n 1. positive (proj_fst_k k)", "apply (subst positive_if_decomp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<exists>M. M * adjoint M = proj_fst_k k \\<Longrightarrow>\n    proj_fst_k k \\<in> carrier_mat ?n1 ?n1\n 2. \\<exists>M. M * adjoint M = proj_fst_k k \\<Longrightarrow>\n    \\<exists>M. M * adjoint M = proj_fst_k k\n 3. \\<exists>M. M * adjoint M = proj_fst_k k \\<Longrightarrow> True", "using proj_fst_k_def"], ["proof (prove)\nusing this:\n  proj_fst_k ?k =\n  mat K K (\\<lambda>(i, j). if i = j \\<and> i < ?k then 1 else 0)\n\ngoal (3 subgoals):\n 1. \\<exists>M. M * adjoint M = proj_fst_k k \\<Longrightarrow>\n    proj_fst_k k \\<in> carrier_mat ?n1 ?n1\n 2. \\<exists>M. M * adjoint M = proj_fst_k k \\<Longrightarrow>\n    \\<exists>M. M * adjoint M = proj_fst_k k\n 3. \\<exists>M. M * adjoint M = proj_fst_k k \\<Longrightarrow> True", "by auto"], ["proof (state)\nthis:\n  positive (proj_fst_k k)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma proj_fst_k_le_one:\n  \"proj_fst_k k \\<le>\\<^sub>L 1\\<^sub>m K\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proj_fst_k k \\<le>\\<^sub>L 1\\<^sub>m K", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. proj_fst_k k \\<le>\\<^sub>L 1\\<^sub>m K", "define M where \"M l = mat K K (\\<lambda>(i, j). if (i = j \\<and> i \\<ge> l) then (1::complex) else 0)\" for l"], ["proof (state)\nthis:\n  M ?l = mat K K (\\<lambda>(i, j). if i = j \\<and> ?l \\<le> i then 1 else 0)\n\ngoal (1 subgoal):\n 1. proj_fst_k k \\<le>\\<^sub>L 1\\<^sub>m K", "have eq: \"1\\<^sub>m K - proj_fst_k k = M k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1\\<^sub>m K - proj_fst_k k = M k", "unfolding M_def proj_fst_k_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1\\<^sub>m K -\n    mat K K (\\<lambda>(i, j). if i = j \\<and> i < k then 1 else 0) =\n    mat K K (\\<lambda>(i, j). if i = j \\<and> k \\<le> i then 1 else 0)", "apply (rule eq_matI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row\n                     (mat K K\n                       (\\<lambda>(i, j).\n                           if i = j \\<and> k \\<le> i then 1 else 0));\n        j < dim_col\n             (mat K K\n               (\\<lambda>(i, j).\n                   if i = j \\<and> k \\<le> i then 1 else 0))\\<rbrakk>\n       \\<Longrightarrow> (1\\<^sub>m K -\n                          mat K K\n                           (\\<lambda>(i, j).\n                               if i = j \\<and> i < k then 1 else 0)) $$\n                         (i, j) =\n                         mat K K\n                          (\\<lambda>(i, j).\n                              if i = j \\<and> k \\<le> i then 1 else 0) $$\n                         (i, j)\n 2. dim_row\n     (1\\<^sub>m K -\n      mat K K (\\<lambda>(i, j). if i = j \\<and> i < k then 1 else 0)) =\n    dim_row\n     (mat K K (\\<lambda>(i, j). if i = j \\<and> k \\<le> i then 1 else 0))\n 3. dim_col\n     (1\\<^sub>m K -\n      mat K K (\\<lambda>(i, j). if i = j \\<and> i < k then 1 else 0)) =\n    dim_col\n     (mat K K (\\<lambda>(i, j). if i = j \\<and> k \\<le> i then 1 else 0))", "by auto"], ["proof (state)\nthis:\n  1\\<^sub>m K - proj_fst_k k = M k\n\ngoal (1 subgoal):\n 1. proj_fst_k k \\<le>\\<^sub>L 1\\<^sub>m K", "have \"M k * M k = M k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M k * M k = M k", "unfolding M_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat K K (\\<lambda>(i, j). if i = j \\<and> k \\<le> i then 1 else 0) *\n    mat K K (\\<lambda>(i, j). if i = j \\<and> k \\<le> i then 1 else 0) =\n    mat K K (\\<lambda>(i, j). if i = j \\<and> k \\<le> i then 1 else 0)", "apply (rule eq_matI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row\n                     (mat K K\n                       (\\<lambda>(i, j).\n                           if i = j \\<and> k \\<le> i then 1 else 0));\n        j < dim_col\n             (mat K K\n               (\\<lambda>(i, j).\n                   if i = j \\<and> k \\<le> i then 1 else 0))\\<rbrakk>\n       \\<Longrightarrow> (mat K K\n                           (\\<lambda>(i, j).\n                               if i = j \\<and> k \\<le> i then 1 else 0) *\n                          mat K K\n                           (\\<lambda>(i, j).\n                               if i = j \\<and> k \\<le> i then 1 else 0)) $$\n                         (i, j) =\n                         mat K K\n                          (\\<lambda>(i, j).\n                              if i = j \\<and> k \\<le> i then 1 else 0) $$\n                         (i, j)\n 2. dim_row\n     (mat K K (\\<lambda>(i, j). if i = j \\<and> k \\<le> i then 1 else 0) *\n      mat K K (\\<lambda>(i, j). if i = j \\<and> k \\<le> i then 1 else 0)) =\n    dim_row\n     (mat K K (\\<lambda>(i, j). if i = j \\<and> k \\<le> i then 1 else 0))\n 3. dim_col\n     (mat K K (\\<lambda>(i, j). if i = j \\<and> k \\<le> i then 1 else 0) *\n      mat K K (\\<lambda>(i, j). if i = j \\<and> k \\<le> i then 1 else 0)) =\n    dim_col\n     (mat K K (\\<lambda>(i, j). if i = j \\<and> k \\<le> i then 1 else 0))", "apply (simp add: scalar_prod_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < K; j < K\\<rbrakk>\n       \\<Longrightarrow> i = j \\<and> k \\<le> i \\<longrightarrow>\n                         (\\<Sum>i = 0..<K.\n                             (if j = i then 1 else 0) *\n                             (if i = j \\<and> k \\<le> i then 1 else 0)) =\n                         1\n 2. dim_row\n     (mat K K (\\<lambda>(i, j). if i = j \\<and> k \\<le> i then 1 else 0) *\n      mat K K (\\<lambda>(i, j). if i = j \\<and> k \\<le> i then 1 else 0)) =\n    dim_row\n     (mat K K (\\<lambda>(i, j). if i = j \\<and> k \\<le> i then 1 else 0))\n 3. dim_col\n     (mat K K (\\<lambda>(i, j). if i = j \\<and> k \\<le> i then 1 else 0) *\n      mat K K (\\<lambda>(i, j). if i = j \\<and> k \\<le> i then 1 else 0)) =\n    dim_col\n     (mat K K (\\<lambda>(i, j). if i = j \\<and> k \\<le> i then 1 else 0))", "apply (subst sum_only_one_neq_0[of _ j])"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < K; j < K\\<rbrakk> \\<Longrightarrow> finite {0..<K}\n 2. \\<And>i j.\n       \\<lbrakk>i < K; j < K\\<rbrakk> \\<Longrightarrow> j \\<in> {0..<K}\n 3. \\<And>i j ia.\n       \\<lbrakk>i < K; j < K; ia \\<in> {0..<K}; ia \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> (if j = ia then 1 else 0) *\n                         (if ia = j \\<and> k \\<le> ia then 1 else 0) =\n                         0\n 4. \\<And>i j.\n       \\<lbrakk>i < K; j < K\\<rbrakk>\n       \\<Longrightarrow> i = j \\<and> k \\<le> i \\<longrightarrow>\n                         (if j = j then 1 else 0) *\n                         (if j = j \\<and> k \\<le> j then 1 else 0) =\n                         1\n 5. dim_row\n     (mat K K (\\<lambda>(i, j). if i = j \\<and> k \\<le> i then 1 else 0) *\n      mat K K (\\<lambda>(i, j). if i = j \\<and> k \\<le> i then 1 else 0)) =\n    dim_row\n     (mat K K (\\<lambda>(i, j). if i = j \\<and> k \\<le> i then 1 else 0))\n 6. dim_col\n     (mat K K (\\<lambda>(i, j). if i = j \\<and> k \\<le> i then 1 else 0) *\n      mat K K (\\<lambda>(i, j). if i = j \\<and> k \\<le> i then 1 else 0)) =\n    dim_col\n     (mat K K (\\<lambda>(i, j). if i = j \\<and> k \\<le> i then 1 else 0))", "by auto"], ["proof (state)\nthis:\n  M k * M k = M k\n\ngoal (1 subgoal):\n 1. proj_fst_k k \\<le>\\<^sub>L 1\\<^sub>m K", "moreover"], ["proof (state)\nthis:\n  M k * M k = M k\n\ngoal (1 subgoal):\n 1. proj_fst_k k \\<le>\\<^sub>L 1\\<^sub>m K", "have \"adjoint (M k) = M k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adjoint (M k) = M k", "unfolding M_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. adjoint\n     (mat K K (\\<lambda>(i, j). if i = j \\<and> k \\<le> i then 1 else 0)) =\n    mat K K (\\<lambda>(i, j). if i = j \\<and> k \\<le> i then 1 else 0)", "apply (rule eq_matI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row\n                     (mat K K\n                       (\\<lambda>(i, j).\n                           if i = j \\<and> k \\<le> i then 1 else 0));\n        j < dim_col\n             (mat K K\n               (\\<lambda>(i, j).\n                   if i = j \\<and> k \\<le> i then 1 else 0))\\<rbrakk>\n       \\<Longrightarrow> adjoint\n                          (mat K K\n                            (\\<lambda>(i, j).\n                                if i = j \\<and> k \\<le> i then 1 else 0)) $$\n                         (i, j) =\n                         mat K K\n                          (\\<lambda>(i, j).\n                              if i = j \\<and> k \\<le> i then 1 else 0) $$\n                         (i, j)\n 2. dim_row\n     (adjoint\n       (mat K K\n         (\\<lambda>(i, j). if i = j \\<and> k \\<le> i then 1 else 0))) =\n    dim_row\n     (mat K K (\\<lambda>(i, j). if i = j \\<and> k \\<le> i then 1 else 0))\n 3. dim_col\n     (adjoint\n       (mat K K\n         (\\<lambda>(i, j). if i = j \\<and> k \\<le> i then 1 else 0))) =\n    dim_col\n     (mat K K (\\<lambda>(i, j). if i = j \\<and> k \\<le> i then 1 else 0))", "by (auto simp add: adjoint_eval)"], ["proof (state)\nthis:\n  adjoint (M k) = M k\n\ngoal (1 subgoal):\n 1. proj_fst_k k \\<le>\\<^sub>L 1\\<^sub>m K", "ultimately"], ["proof (chain)\npicking this:\n  M k * M k = M k\n  adjoint (M k) = M k", "have \"M k * adjoint (M k) = M k\""], ["proof (prove)\nusing this:\n  M k * M k = M k\n  adjoint (M k) = M k\n\ngoal (1 subgoal):\n 1. M k * adjoint (M k) = M k", "by auto"], ["proof (state)\nthis:\n  M k * adjoint (M k) = M k\n\ngoal (1 subgoal):\n 1. proj_fst_k k \\<le>\\<^sub>L 1\\<^sub>m K", "then"], ["proof (chain)\npicking this:\n  M k * adjoint (M k) = M k", "have \"\\<exists>M. M * adjoint M = 1\\<^sub>m K - proj_fst_k k\""], ["proof (prove)\nusing this:\n  M k * adjoint (M k) = M k\n\ngoal (1 subgoal):\n 1. \\<exists>M. M * adjoint M = 1\\<^sub>m K - proj_fst_k k", "using eq"], ["proof (prove)\nusing this:\n  M k * adjoint (M k) = M k\n  1\\<^sub>m K - proj_fst_k k = M k\n\ngoal (1 subgoal):\n 1. \\<exists>M. M * adjoint M = 1\\<^sub>m K - proj_fst_k k", "by auto"], ["proof (state)\nthis:\n  \\<exists>M. M * adjoint M = 1\\<^sub>m K - proj_fst_k k\n\ngoal (1 subgoal):\n 1. proj_fst_k k \\<le>\\<^sub>L 1\\<^sub>m K", "then"], ["proof (chain)\npicking this:\n  \\<exists>M. M * adjoint M = 1\\<^sub>m K - proj_fst_k k", "have \"positive (1\\<^sub>m K - proj_fst_k k)\""], ["proof (prove)\nusing this:\n  \\<exists>M. M * adjoint M = 1\\<^sub>m K - proj_fst_k k\n\ngoal (1 subgoal):\n 1. positive (1\\<^sub>m K - proj_fst_k k)", "apply (subst positive_if_decomp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<exists>M. M * adjoint M = 1\\<^sub>m K - proj_fst_k k \\<Longrightarrow>\n    1\\<^sub>m K - proj_fst_k k \\<in> carrier_mat ?n1 ?n1\n 2. \\<exists>M. M * adjoint M = 1\\<^sub>m K - proj_fst_k k \\<Longrightarrow>\n    \\<exists>M. M * adjoint M = 1\\<^sub>m K - proj_fst_k k\n 3. \\<exists>M. M * adjoint M = 1\\<^sub>m K - proj_fst_k k \\<Longrightarrow>\n    True", "using proj_fst_k_def"], ["proof (prove)\nusing this:\n  proj_fst_k ?k =\n  mat K K (\\<lambda>(i, j). if i = j \\<and> i < ?k then 1 else 0)\n\ngoal (3 subgoals):\n 1. \\<exists>M. M * adjoint M = 1\\<^sub>m K - proj_fst_k k \\<Longrightarrow>\n    1\\<^sub>m K - proj_fst_k k \\<in> carrier_mat ?n1 ?n1\n 2. \\<exists>M. M * adjoint M = 1\\<^sub>m K - proj_fst_k k \\<Longrightarrow>\n    \\<exists>M. M * adjoint M = 1\\<^sub>m K - proj_fst_k k\n 3. \\<exists>M. M * adjoint M = 1\\<^sub>m K - proj_fst_k k \\<Longrightarrow>\n    True", "by auto"], ["proof (state)\nthis:\n  positive (1\\<^sub>m K - proj_fst_k k)\n\ngoal (1 subgoal):\n 1. proj_fst_k k \\<le>\\<^sub>L 1\\<^sub>m K", "then"], ["proof (chain)\npicking this:\n  positive (1\\<^sub>m K - proj_fst_k k)", "show ?thesis"], ["proof (prove)\nusing this:\n  positive (1\\<^sub>m K - proj_fst_k k)\n\ngoal (1 subgoal):\n 1. proj_fst_k k \\<le>\\<^sub>L 1\\<^sub>m K", "unfolding lowner_le_def"], ["proof (prove)\nusing this:\n  positive (1\\<^sub>m K - proj_fst_k k)\n\ngoal (1 subgoal):\n 1. dim_row (proj_fst_k k) = dim_row (1\\<^sub>m K) \\<and>\n    dim_col (proj_fst_k k) = dim_col (1\\<^sub>m K) \\<and>\n    positive (1\\<^sub>m K - proj_fst_k k)", "using proj_fst_k_def"], ["proof (prove)\nusing this:\n  positive (1\\<^sub>m K - proj_fst_k k)\n  proj_fst_k ?k =\n  mat K K (\\<lambda>(i, j). if i = j \\<and> i < ?k then 1 else 0)\n\ngoal (1 subgoal):\n 1. dim_row (proj_fst_k k) = dim_row (1\\<^sub>m K) \\<and>\n    dim_col (proj_fst_k k) = dim_col (1\\<^sub>m K) \\<and>\n    positive (1\\<^sub>m K - proj_fst_k k)", "by auto"], ["proof (state)\nthis:\n  proj_fst_k k \\<le>\\<^sub>L 1\\<^sub>m K\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sum_proj_k:\n  assumes \"m \\<le> K\"\n  shows \"matrix_sum K (\\<lambda>k. proj_k k) m = proj_fst_k m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_sum K proj_k m = proj_fst_k m", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. matrix_sum K proj_k m = proj_fst_k m", "have \"m \\<le> K \\<Longrightarrow> matrix_sum K (\\<lambda>k. proj_k k) m = mat K K (\\<lambda>(i, j). if (i = j \\<and> i < m) then 1 else 0)\" for m"], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<le> K \\<Longrightarrow>\n    matrix_sum K proj_k m =\n    mat K K (\\<lambda>(i, j). if i = j \\<and> i < m then 1 else 0)", "proof (induct m)"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 \\<le> K \\<Longrightarrow>\n    matrix_sum K proj_k 0 =\n    mat K K (\\<lambda>(i, j). if i = j \\<and> i < 0 then 1 else 0)\n 2. \\<And>m.\n       \\<lbrakk>m \\<le> K \\<Longrightarrow>\n                matrix_sum K proj_k m =\n                mat K K\n                 (\\<lambda>(i, j). if i = j \\<and> i < m then 1 else 0);\n        Suc m \\<le> K\\<rbrakk>\n       \\<Longrightarrow> matrix_sum K proj_k (Suc m) =\n                         mat K K\n                          (\\<lambda>(i, j).\n                              if i = j \\<and> i < Suc m then 1 else 0)", "case 0"], ["proof (state)\nthis:\n  0 \\<le> K\n\ngoal (2 subgoals):\n 1. 0 \\<le> K \\<Longrightarrow>\n    matrix_sum K proj_k 0 =\n    mat K K (\\<lambda>(i, j). if i = j \\<and> i < 0 then 1 else 0)\n 2. \\<And>m.\n       \\<lbrakk>m \\<le> K \\<Longrightarrow>\n                matrix_sum K proj_k m =\n                mat K K\n                 (\\<lambda>(i, j). if i = j \\<and> i < m then 1 else 0);\n        Suc m \\<le> K\\<rbrakk>\n       \\<Longrightarrow> matrix_sum K proj_k (Suc m) =\n                         mat K K\n                          (\\<lambda>(i, j).\n                              if i = j \\<and> i < Suc m then 1 else 0)", "then"], ["proof (chain)\npicking this:\n  0 \\<le> K", "show ?case"], ["proof (prove)\nusing this:\n  0 \\<le> K\n\ngoal (1 subgoal):\n 1. matrix_sum K proj_k 0 =\n    mat K K\n     (\\<lambda>a.\n         case a of (i, j) \\<Rightarrow> if i = j \\<and> i < 0 then 1 else 0)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0\\<^sub>m K K = mat K K (\\<lambda>a. 0)", "apply (rule eq_matI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row (mat K K (\\<lambda>a. 0));\n        j < dim_col (mat K K (\\<lambda>a. 0))\\<rbrakk>\n       \\<Longrightarrow> 0\\<^sub>m K K $$ (i, j) =\n                         mat K K (\\<lambda>a. 0) $$ (i, j)\n 2. dim_row (0\\<^sub>m K K) = dim_row (mat K K (\\<lambda>a. 0))\n 3. dim_col (0\\<^sub>m K K) = dim_col (mat K K (\\<lambda>a. 0))", "by auto"], ["proof (state)\nthis:\n  matrix_sum K proj_k 0 =\n  mat K K\n   (\\<lambda>a.\n       case a of (i, j) \\<Rightarrow> if i = j \\<and> i < 0 then 1 else 0)\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       \\<lbrakk>m \\<le> K \\<Longrightarrow>\n                matrix_sum K proj_k m =\n                mat K K\n                 (\\<lambda>(i, j). if i = j \\<and> i < m then 1 else 0);\n        Suc m \\<le> K\\<rbrakk>\n       \\<Longrightarrow> matrix_sum K proj_k (Suc m) =\n                         mat K K\n                          (\\<lambda>(i, j).\n                              if i = j \\<and> i < Suc m then 1 else 0)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m.\n       \\<lbrakk>m \\<le> K \\<Longrightarrow>\n                matrix_sum K proj_k m =\n                mat K K\n                 (\\<lambda>(i, j). if i = j \\<and> i < m then 1 else 0);\n        Suc m \\<le> K\\<rbrakk>\n       \\<Longrightarrow> matrix_sum K proj_k (Suc m) =\n                         mat K K\n                          (\\<lambda>(i, j).\n                              if i = j \\<and> i < Suc m then 1 else 0)", "case (Suc m)"], ["proof (state)\nthis:\n  m \\<le> K \\<Longrightarrow>\n  matrix_sum K proj_k m =\n  mat K K\n   (\\<lambda>a.\n       case a of (i, j) \\<Rightarrow> if i = j \\<and> i < m then 1 else 0)\n  Suc m \\<le> K\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       \\<lbrakk>m \\<le> K \\<Longrightarrow>\n                matrix_sum K proj_k m =\n                mat K K\n                 (\\<lambda>(i, j). if i = j \\<and> i < m then 1 else 0);\n        Suc m \\<le> K\\<rbrakk>\n       \\<Longrightarrow> matrix_sum K proj_k (Suc m) =\n                         mat K K\n                          (\\<lambda>(i, j).\n                              if i = j \\<and> i < Suc m then 1 else 0)", "then"], ["proof (chain)\npicking this:\n  m \\<le> K \\<Longrightarrow>\n  matrix_sum K proj_k m =\n  mat K K\n   (\\<lambda>a.\n       case a of (i, j) \\<Rightarrow> if i = j \\<and> i < m then 1 else 0)\n  Suc m \\<le> K", "have m: \"m < K\""], ["proof (prove)\nusing this:\n  m \\<le> K \\<Longrightarrow>\n  matrix_sum K proj_k m =\n  mat K K\n   (\\<lambda>a.\n       case a of (i, j) \\<Rightarrow> if i = j \\<and> i < m then 1 else 0)\n  Suc m \\<le> K\n\ngoal (1 subgoal):\n 1. m < K", "by auto"], ["proof (state)\nthis:\n  m < K\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       \\<lbrakk>m \\<le> K \\<Longrightarrow>\n                matrix_sum K proj_k m =\n                mat K K\n                 (\\<lambda>(i, j). if i = j \\<and> i < m then 1 else 0);\n        Suc m \\<le> K\\<rbrakk>\n       \\<Longrightarrow> matrix_sum K proj_k (Suc m) =\n                         mat K K\n                          (\\<lambda>(i, j).\n                              if i = j \\<and> i < Suc m then 1 else 0)", "then"], ["proof (chain)\npicking this:\n  m < K", "have m': \"m \\<le> K\""], ["proof (prove)\nusing this:\n  m < K\n\ngoal (1 subgoal):\n 1. m \\<le> K", "by auto"], ["proof (state)\nthis:\n  m \\<le> K\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       \\<lbrakk>m \\<le> K \\<Longrightarrow>\n                matrix_sum K proj_k m =\n                mat K K\n                 (\\<lambda>(i, j). if i = j \\<and> i < m then 1 else 0);\n        Suc m \\<le> K\\<rbrakk>\n       \\<Longrightarrow> matrix_sum K proj_k (Suc m) =\n                         mat K K\n                          (\\<lambda>(i, j).\n                              if i = j \\<and> i < Suc m then 1 else 0)", "have \"matrix_sum K proj_k (Suc m) = proj_k m + matrix_sum K proj_k m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_sum K proj_k (Suc m) = proj_k m + matrix_sum K proj_k m", "by simp"], ["proof (state)\nthis:\n  matrix_sum K proj_k (Suc m) = proj_k m + matrix_sum K proj_k m\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       \\<lbrakk>m \\<le> K \\<Longrightarrow>\n                matrix_sum K proj_k m =\n                mat K K\n                 (\\<lambda>(i, j). if i = j \\<and> i < m then 1 else 0);\n        Suc m \\<le> K\\<rbrakk>\n       \\<Longrightarrow> matrix_sum K proj_k (Suc m) =\n                         mat K K\n                          (\\<lambda>(i, j).\n                              if i = j \\<and> i < Suc m then 1 else 0)", "also"], ["proof (state)\nthis:\n  matrix_sum K proj_k (Suc m) = proj_k m + matrix_sum K proj_k m\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       \\<lbrakk>m \\<le> K \\<Longrightarrow>\n                matrix_sum K proj_k m =\n                mat K K\n                 (\\<lambda>(i, j). if i = j \\<and> i < m then 1 else 0);\n        Suc m \\<le> K\\<rbrakk>\n       \\<Longrightarrow> matrix_sum K proj_k (Suc m) =\n                         mat K K\n                          (\\<lambda>(i, j).\n                              if i = j \\<and> i < Suc m then 1 else 0)", "have \"\\<dots> = mat K K (\\<lambda>(i, j). if (i = j \\<and> i < (Suc m)) then 1 else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proj_k m + matrix_sum K proj_k m =\n    mat K K (\\<lambda>(i, j). if i = j \\<and> i < Suc m then 1 else 0)", "unfolding proj_k_mat[OF m] Suc(1)[OF m']"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat K K (\\<lambda>(i, j). if i = j \\<and> i = m then 1 else 0) +\n    mat K K (\\<lambda>(i, j). if i = j \\<and> i < m then 1 else 0) =\n    mat K K (\\<lambda>(i, j). if i = j \\<and> i < Suc m then 1 else 0)", "apply (rule eq_matI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row\n                     (mat K K\n                       (\\<lambda>(i, j).\n                           if i = j \\<and> i < Suc m then 1 else 0));\n        j < dim_col\n             (mat K K\n               (\\<lambda>(i, j).\n                   if i = j \\<and> i < Suc m then 1 else 0))\\<rbrakk>\n       \\<Longrightarrow> (mat K K\n                           (\\<lambda>(i, j).\n                               if i = j \\<and> i = m then 1 else 0) +\n                          mat K K\n                           (\\<lambda>(i, j).\n                               if i = j \\<and> i < m then 1 else 0)) $$\n                         (i, j) =\n                         mat K K\n                          (\\<lambda>(i, j).\n                              if i = j \\<and> i < Suc m then 1 else 0) $$\n                         (i, j)\n 2. dim_row\n     (mat K K (\\<lambda>(i, j). if i = j \\<and> i = m then 1 else 0) +\n      mat K K (\\<lambda>(i, j). if i = j \\<and> i < m then 1 else 0)) =\n    dim_row\n     (mat K K (\\<lambda>(i, j). if i = j \\<and> i < Suc m then 1 else 0))\n 3. dim_col\n     (mat K K (\\<lambda>(i, j). if i = j \\<and> i = m then 1 else 0) +\n      mat K K (\\<lambda>(i, j). if i = j \\<and> i < m then 1 else 0)) =\n    dim_col\n     (mat K K (\\<lambda>(i, j). if i = j \\<and> i < Suc m then 1 else 0))", "by auto"], ["proof (state)\nthis:\n  proj_k m + matrix_sum K proj_k m =\n  mat K K (\\<lambda>(i, j). if i = j \\<and> i < Suc m then 1 else 0)\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       \\<lbrakk>m \\<le> K \\<Longrightarrow>\n                matrix_sum K proj_k m =\n                mat K K\n                 (\\<lambda>(i, j). if i = j \\<and> i < m then 1 else 0);\n        Suc m \\<le> K\\<rbrakk>\n       \\<Longrightarrow> matrix_sum K proj_k (Suc m) =\n                         mat K K\n                          (\\<lambda>(i, j).\n                              if i = j \\<and> i < Suc m then 1 else 0)", "finally"], ["proof (chain)\npicking this:\n  matrix_sum K proj_k (Suc m) =\n  mat K K (\\<lambda>(i, j). if i = j \\<and> i < Suc m then 1 else 0)", "show ?case"], ["proof (prove)\nusing this:\n  matrix_sum K proj_k (Suc m) =\n  mat K K (\\<lambda>(i, j). if i = j \\<and> i < Suc m then 1 else 0)\n\ngoal (1 subgoal):\n 1. matrix_sum K proj_k (Suc m) =\n    mat K K\n     (\\<lambda>a.\n         case a of\n         (i, j) \\<Rightarrow> if i = j \\<and> i < Suc m then 1 else 0)", "by auto"], ["proof (state)\nthis:\n  matrix_sum K proj_k (Suc m) =\n  mat K K\n   (\\<lambda>a.\n       case a of\n       (i, j) \\<Rightarrow> if i = j \\<and> i < Suc m then 1 else 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?m2 \\<le> K \\<Longrightarrow>\n  matrix_sum K proj_k ?m2 =\n  mat K K (\\<lambda>(i, j). if i = j \\<and> i < ?m2 then 1 else 0)\n\ngoal (1 subgoal):\n 1. matrix_sum K proj_k m = proj_fst_k m", "then"], ["proof (chain)\npicking this:\n  ?m2 \\<le> K \\<Longrightarrow>\n  matrix_sum K proj_k ?m2 =\n  mat K K (\\<lambda>(i, j). if i = j \\<and> i < ?m2 then 1 else 0)", "show ?thesis"], ["proof (prove)\nusing this:\n  ?m2 \\<le> K \\<Longrightarrow>\n  matrix_sum K proj_k ?m2 =\n  mat K K (\\<lambda>(i, j). if i = j \\<and> i < ?m2 then 1 else 0)\n\ngoal (1 subgoal):\n 1. matrix_sum K proj_k m = proj_fst_k m", "unfolding proj_fst_k_def"], ["proof (prove)\nusing this:\n  ?m2 \\<le> K \\<Longrightarrow>\n  matrix_sum K proj_k ?m2 =\n  mat K K (\\<lambda>(i, j). if i = j \\<and> i < ?m2 then 1 else 0)\n\ngoal (1 subgoal):\n 1. matrix_sum K proj_k m =\n    mat K K (\\<lambda>(i, j). if i = j \\<and> i < m then 1 else 0)", "using assms"], ["proof (prove)\nusing this:\n  ?m2 \\<le> K \\<Longrightarrow>\n  matrix_sum K proj_k ?m2 =\n  mat K K (\\<lambda>(i, j). if i = j \\<and> i < ?m2 then 1 else 0)\n  m \\<le> K\n\ngoal (1 subgoal):\n 1. matrix_sum K proj_k m =\n    mat K K (\\<lambda>(i, j). if i = j \\<and> i < m then 1 else 0)", "by auto"], ["proof (state)\nthis:\n  matrix_sum K proj_k m = proj_fst_k m\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma proj_psi_proj_k_le_exproj_k:\n  shows \"tensor_P (proj_psi_l k) (proj_k l) \\<le>\\<^sub>L tensor_P (1\\<^sub>m N) (proj_k l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tensor_P (proj_psi_l k) (proj_k l) \\<le>\\<^sub>L\n    tensor_P (1\\<^sub>m N) (proj_k l)", "unfolding ps2_P.ptensor_mat_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ps_P.tensor_mat (proj_psi_l k) (proj_k l) \\<le>\\<^sub>L\n    ps_P.tensor_mat (1\\<^sub>m N) (proj_k l)", "apply (subst ps_P.tensor_mat_positive_le)"], ["proof (prove)\ngoal (7 subgoals):\n 1. proj_psi_l k \\<in> carrier_mat ps_P.d1 ps_P.d1\n 2. proj_k l \\<in> carrier_mat ps_P.d2 ps_P.d2\n 3. positive (proj_psi_l k)\n 4. positive (proj_k l)\n 5. proj_psi_l k \\<le>\\<^sub>L 1\\<^sub>m N\n 6. proj_k l \\<le>\\<^sub>L proj_k l\n 7. True", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. proj_psi_l k \\<in> carrier_mat ps_P.d1 ps_P.d1", "using proj_psi_l_def psi_l_dim ps_P_d1"], ["proof (prove)\nusing this:\n  proj_psi_l ?l = outer_prod (psi_l ?l) (psi_l ?l)\n  psi_l ?l \\<in> carrier_vec N\n  ps_P.d1 = N\n\ngoal (1 subgoal):\n 1. proj_psi_l k \\<in> carrier_mat ps_P.d1 ps_P.d1", "by auto"], ["proof (prove)\ngoal (6 subgoals):\n 1. proj_k l \\<in> carrier_mat ps_P.d2 ps_P.d2\n 2. positive (proj_psi_l k)\n 3. positive (proj_k l)\n 4. proj_psi_l k \\<le>\\<^sub>L 1\\<^sub>m N\n 5. proj_k l \\<le>\\<^sub>L proj_k l\n 6. True", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. proj_k l \\<in> carrier_mat ps_P.d2 ps_P.d2", "using proj_k_def ket_k_def ps_P_d2"], ["proof (prove)\nusing this:\n  proj_k ?x = outer_prod (ket_k ?x) (ket_k ?x)\n  ket_k ?x = Matrix.vec K (\\<lambda>k. if k = ?x then 1 else 0)\n  ps_P.d2 = K\n\ngoal (1 subgoal):\n 1. proj_k l \\<in> carrier_mat ps_P.d2 ps_P.d2", "by auto"], ["proof (prove)\ngoal (5 subgoals):\n 1. positive (proj_psi_l k)\n 2. positive (proj_k l)\n 3. proj_psi_l k \\<le>\\<^sub>L 1\\<^sub>m N\n 4. proj_k l \\<le>\\<^sub>L proj_k l\n 5. True", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. positive (proj_psi_l k)", "using positive_proj_psi_l"], ["proof (prove)\nusing this:\n  positive (proj_psi_l ?l)\n\ngoal (1 subgoal):\n 1. positive (proj_psi_l k)", "by auto"], ["proof (prove)\ngoal (4 subgoals):\n 1. positive (proj_k l)\n 2. proj_psi_l k \\<le>\\<^sub>L 1\\<^sub>m N\n 3. proj_k l \\<le>\\<^sub>L proj_k l\n 4. True", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. positive (proj_k l)", "using positive_same_outer_prod proj_k_def ket_k_def"], ["proof (prove)\nusing this:\n  ?v \\<in> carrier_vec ?n \\<Longrightarrow> positive (outer_prod ?v ?v)\n  proj_k ?x = outer_prod (ket_k ?x) (ket_k ?x)\n  ket_k ?x = Matrix.vec K (\\<lambda>k. if k = ?x then 1 else 0)\n\ngoal (1 subgoal):\n 1. positive (proj_k l)", "by auto"], ["proof (prove)\ngoal (3 subgoals):\n 1. proj_psi_l k \\<le>\\<^sub>L 1\\<^sub>m N\n 2. proj_k l \\<le>\\<^sub>L proj_k l\n 3. True", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. proj_psi_l k \\<le>\\<^sub>L 1\\<^sub>m N", "using psi_l_le_id"], ["proof (prove)\nusing this:\n  proj_psi_l ?l \\<le>\\<^sub>L 1\\<^sub>m N\n\ngoal (1 subgoal):\n 1. proj_psi_l k \\<le>\\<^sub>L 1\\<^sub>m N", "by auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. proj_k l \\<le>\\<^sub>L proj_k l\n 2. True", "apply (subst lowner_le_refl[of _ K])"], ["proof (prove)\ngoal (3 subgoals):\n 1. proj_k l \\<in> carrier_mat K K\n 2. True\n 3. True", "by (auto simp add: proj_k_def ket_k_def)"], ["", "definition Q1 :: \"complex mat\" where\n  \"Q1 = matrix_sum d (\\<lambda>l. tensor_P (proj_psi'_l l) (proj_k l)) R\""], ["", "lemma tensor_P_left_right_partial1:\n  assumes \"m1 \\<in> carrier_mat N N\" and \"m2 \\<in> carrier_mat N N\" and \"m3 \\<in> carrier_mat K K\" and \"m4 \\<in> carrier_mat N N\"\n  shows \"tensor_P m1 (1\\<^sub>m K) * tensor_P m2 m3 * tensor_P m4 (1\\<^sub>m K) = tensor_P (m1 * m2 * m4) m3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tensor_P m1 (1\\<^sub>m K) * tensor_P m2 m3 * tensor_P m4 (1\\<^sub>m K) =\n    tensor_P (m1 * m2 * m4) m3", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. tensor_P m1 (1\\<^sub>m K) * tensor_P m2 m3 * tensor_P m4 (1\\<^sub>m K) =\n    tensor_P (m1 * m2 * m4) m3", "have \"tensor_P m1 (1\\<^sub>m K) * tensor_P m2 m3 = tensor_P (m1 * m2) m3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tensor_P m1 (1\\<^sub>m K) * tensor_P m2 m3 = tensor_P (m1 * m2) m3", "unfolding ps2_P.ptensor_mat_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ps_P.tensor_mat m1 (1\\<^sub>m K) * ps_P.tensor_mat m2 m3 =\n    ps_P.tensor_mat (m1 * m2) m3", "apply (subst ps_P.tensor_mat_mult[symmetric])"], ["proof (prove)\ngoal (5 subgoals):\n 1. m1 \\<in> carrier_mat ps_P.d1 ps_P.d1\n 2. m2 \\<in> carrier_mat ps_P.d1 ps_P.d1\n 3. 1\\<^sub>m K \\<in> carrier_mat ps_P.d2 ps_P.d2\n 4. m3 \\<in> carrier_mat ps_P.d2 ps_P.d2\n 5. ps_P.tensor_mat (m1 * m2) (1\\<^sub>m K * m3) =\n    ps_P.tensor_mat (m1 * m2) m3", "using assms ps_P_d1 ps_P_d2"], ["proof (prove)\nusing this:\n  m1 \\<in> carrier_mat N N\n  m2 \\<in> carrier_mat N N\n  m3 \\<in> carrier_mat K K\n  m4 \\<in> carrier_mat N N\n  ps_P.d1 = N\n  ps_P.d2 = K\n\ngoal (5 subgoals):\n 1. m1 \\<in> carrier_mat ps_P.d1 ps_P.d1\n 2. m2 \\<in> carrier_mat ps_P.d1 ps_P.d1\n 3. 1\\<^sub>m K \\<in> carrier_mat ps_P.d2 ps_P.d2\n 4. m3 \\<in> carrier_mat ps_P.d2 ps_P.d2\n 5. ps_P.tensor_mat (m1 * m2) (1\\<^sub>m K * m3) =\n    ps_P.tensor_mat (m1 * m2) m3", "by auto"], ["proof (state)\nthis:\n  tensor_P m1 (1\\<^sub>m K) * tensor_P m2 m3 = tensor_P (m1 * m2) m3\n\ngoal (1 subgoal):\n 1. tensor_P m1 (1\\<^sub>m K) * tensor_P m2 m3 * tensor_P m4 (1\\<^sub>m K) =\n    tensor_P (m1 * m2 * m4) m3", "moreover"], ["proof (state)\nthis:\n  tensor_P m1 (1\\<^sub>m K) * tensor_P m2 m3 = tensor_P (m1 * m2) m3\n\ngoal (1 subgoal):\n 1. tensor_P m1 (1\\<^sub>m K) * tensor_P m2 m3 * tensor_P m4 (1\\<^sub>m K) =\n    tensor_P (m1 * m2 * m4) m3", "have \"tensor_P (m1 * m2) m3 * tensor_P m4 (1\\<^sub>m K) = tensor_P (m1 * m2 * m4) m3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tensor_P (m1 * m2) m3 * tensor_P m4 (1\\<^sub>m K) =\n    tensor_P (m1 * m2 * m4) m3", "unfolding ps2_P.ptensor_mat_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ps_P.tensor_mat (m1 * m2) m3 * ps_P.tensor_mat m4 (1\\<^sub>m K) =\n    ps_P.tensor_mat (m1 * m2 * m4) m3", "apply (subst ps_P.tensor_mat_mult[symmetric])"], ["proof (prove)\ngoal (5 subgoals):\n 1. m1 * m2 \\<in> carrier_mat ps_P.d1 ps_P.d1\n 2. m4 \\<in> carrier_mat ps_P.d1 ps_P.d1\n 3. m3 \\<in> carrier_mat ps_P.d2 ps_P.d2\n 4. 1\\<^sub>m K \\<in> carrier_mat ps_P.d2 ps_P.d2\n 5. ps_P.tensor_mat (m1 * m2 * m4) (m3 * 1\\<^sub>m K) =\n    ps_P.tensor_mat (m1 * m2 * m4) m3", "using assms ps_P_d1 ps_P_d2"], ["proof (prove)\nusing this:\n  m1 \\<in> carrier_mat N N\n  m2 \\<in> carrier_mat N N\n  m3 \\<in> carrier_mat K K\n  m4 \\<in> carrier_mat N N\n  ps_P.d1 = N\n  ps_P.d2 = K\n\ngoal (5 subgoals):\n 1. m1 * m2 \\<in> carrier_mat ps_P.d1 ps_P.d1\n 2. m4 \\<in> carrier_mat ps_P.d1 ps_P.d1\n 3. m3 \\<in> carrier_mat ps_P.d2 ps_P.d2\n 4. 1\\<^sub>m K \\<in> carrier_mat ps_P.d2 ps_P.d2\n 5. ps_P.tensor_mat (m1 * m2 * m4) (m3 * 1\\<^sub>m K) =\n    ps_P.tensor_mat (m1 * m2 * m4) m3", "by auto"], ["proof (state)\nthis:\n  tensor_P (m1 * m2) m3 * tensor_P m4 (1\\<^sub>m K) =\n  tensor_P (m1 * m2 * m4) m3\n\ngoal (1 subgoal):\n 1. tensor_P m1 (1\\<^sub>m K) * tensor_P m2 m3 * tensor_P m4 (1\\<^sub>m K) =\n    tensor_P (m1 * m2 * m4) m3", "ultimately"], ["proof (chain)\npicking this:\n  tensor_P m1 (1\\<^sub>m K) * tensor_P m2 m3 = tensor_P (m1 * m2) m3\n  tensor_P (m1 * m2) m3 * tensor_P m4 (1\\<^sub>m K) =\n  tensor_P (m1 * m2 * m4) m3", "show ?thesis"], ["proof (prove)\nusing this:\n  tensor_P m1 (1\\<^sub>m K) * tensor_P m2 m3 = tensor_P (m1 * m2) m3\n  tensor_P (m1 * m2) m3 * tensor_P m4 (1\\<^sub>m K) =\n  tensor_P (m1 * m2 * m4) m3\n\ngoal (1 subgoal):\n 1. tensor_P m1 (1\\<^sub>m K) * tensor_P m2 m3 * tensor_P m4 (1\\<^sub>m K) =\n    tensor_P (m1 * m2 * m4) m3", "by auto"], ["proof (state)\nthis:\n  tensor_P m1 (1\\<^sub>m K) * tensor_P m2 m3 * tensor_P m4 (1\\<^sub>m K) =\n  tensor_P (m1 * m2 * m4) m3\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma tensor_P_left_right_partial2:\n  assumes \"m1 \\<in> carrier_mat K K\" and \"m2 \\<in> carrier_mat K K\" and \"m3 \\<in> carrier_mat N N\" and \"m4 \\<in> carrier_mat K K\"\n  shows \"tensor_P (1\\<^sub>m N) m1 * tensor_P m3 m2 * tensor_P (1\\<^sub>m N) m4 = tensor_P m3 (m1 * m2 * m4)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tensor_P (1\\<^sub>m N) m1 * tensor_P m3 m2 * tensor_P (1\\<^sub>m N) m4 =\n    tensor_P m3 (m1 * m2 * m4)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. tensor_P (1\\<^sub>m N) m1 * tensor_P m3 m2 * tensor_P (1\\<^sub>m N) m4 =\n    tensor_P m3 (m1 * m2 * m4)", "have \"tensor_P (1\\<^sub>m N) m1 * tensor_P m3 m2 = tensor_P m3 (m1 * m2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tensor_P (1\\<^sub>m N) m1 * tensor_P m3 m2 = tensor_P m3 (m1 * m2)", "unfolding ps2_P.ptensor_mat_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ps_P.tensor_mat (1\\<^sub>m N) m1 * ps_P.tensor_mat m3 m2 =\n    ps_P.tensor_mat m3 (m1 * m2)", "apply (subst ps_P.tensor_mat_mult[symmetric])"], ["proof (prove)\ngoal (5 subgoals):\n 1. 1\\<^sub>m N \\<in> carrier_mat ps_P.d1 ps_P.d1\n 2. m3 \\<in> carrier_mat ps_P.d1 ps_P.d1\n 3. m1 \\<in> carrier_mat ps_P.d2 ps_P.d2\n 4. m2 \\<in> carrier_mat ps_P.d2 ps_P.d2\n 5. ps_P.tensor_mat (1\\<^sub>m N * m3) (m1 * m2) =\n    ps_P.tensor_mat m3 (m1 * m2)", "using assms ps_P_d1 ps_P_d2"], ["proof (prove)\nusing this:\n  m1 \\<in> carrier_mat K K\n  m2 \\<in> carrier_mat K K\n  m3 \\<in> carrier_mat N N\n  m4 \\<in> carrier_mat K K\n  ps_P.d1 = N\n  ps_P.d2 = K\n\ngoal (5 subgoals):\n 1. 1\\<^sub>m N \\<in> carrier_mat ps_P.d1 ps_P.d1\n 2. m3 \\<in> carrier_mat ps_P.d1 ps_P.d1\n 3. m1 \\<in> carrier_mat ps_P.d2 ps_P.d2\n 4. m2 \\<in> carrier_mat ps_P.d2 ps_P.d2\n 5. ps_P.tensor_mat (1\\<^sub>m N * m3) (m1 * m2) =\n    ps_P.tensor_mat m3 (m1 * m2)", "by auto"], ["proof (state)\nthis:\n  tensor_P (1\\<^sub>m N) m1 * tensor_P m3 m2 = tensor_P m3 (m1 * m2)\n\ngoal (1 subgoal):\n 1. tensor_P (1\\<^sub>m N) m1 * tensor_P m3 m2 * tensor_P (1\\<^sub>m N) m4 =\n    tensor_P m3 (m1 * m2 * m4)", "moreover"], ["proof (state)\nthis:\n  tensor_P (1\\<^sub>m N) m1 * tensor_P m3 m2 = tensor_P m3 (m1 * m2)\n\ngoal (1 subgoal):\n 1. tensor_P (1\\<^sub>m N) m1 * tensor_P m3 m2 * tensor_P (1\\<^sub>m N) m4 =\n    tensor_P m3 (m1 * m2 * m4)", "have \"tensor_P m3 (m1 * m2) * tensor_P (1\\<^sub>m N) m4 = tensor_P m3 (m1 * m2 * m4)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tensor_P m3 (m1 * m2) * tensor_P (1\\<^sub>m N) m4 =\n    tensor_P m3 (m1 * m2 * m4)", "unfolding ps2_P.ptensor_mat_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ps_P.tensor_mat m3 (m1 * m2) * ps_P.tensor_mat (1\\<^sub>m N) m4 =\n    ps_P.tensor_mat m3 (m1 * m2 * m4)", "apply (subst ps_P.tensor_mat_mult[symmetric])"], ["proof (prove)\ngoal (5 subgoals):\n 1. m3 \\<in> carrier_mat ps_P.d1 ps_P.d1\n 2. 1\\<^sub>m N \\<in> carrier_mat ps_P.d1 ps_P.d1\n 3. m1 * m2 \\<in> carrier_mat ps_P.d2 ps_P.d2\n 4. m4 \\<in> carrier_mat ps_P.d2 ps_P.d2\n 5. ps_P.tensor_mat (m3 * 1\\<^sub>m N) (m1 * m2 * m4) =\n    ps_P.tensor_mat m3 (m1 * m2 * m4)", "using assms ps_P_d1 ps_P_d2"], ["proof (prove)\nusing this:\n  m1 \\<in> carrier_mat K K\n  m2 \\<in> carrier_mat K K\n  m3 \\<in> carrier_mat N N\n  m4 \\<in> carrier_mat K K\n  ps_P.d1 = N\n  ps_P.d2 = K\n\ngoal (5 subgoals):\n 1. m3 \\<in> carrier_mat ps_P.d1 ps_P.d1\n 2. 1\\<^sub>m N \\<in> carrier_mat ps_P.d1 ps_P.d1\n 3. m1 * m2 \\<in> carrier_mat ps_P.d2 ps_P.d2\n 4. m4 \\<in> carrier_mat ps_P.d2 ps_P.d2\n 5. ps_P.tensor_mat (m3 * 1\\<^sub>m N) (m1 * m2 * m4) =\n    ps_P.tensor_mat m3 (m1 * m2 * m4)", "by auto"], ["proof (state)\nthis:\n  tensor_P m3 (m1 * m2) * tensor_P (1\\<^sub>m N) m4 =\n  tensor_P m3 (m1 * m2 * m4)\n\ngoal (1 subgoal):\n 1. tensor_P (1\\<^sub>m N) m1 * tensor_P m3 m2 * tensor_P (1\\<^sub>m N) m4 =\n    tensor_P m3 (m1 * m2 * m4)", "ultimately"], ["proof (chain)\npicking this:\n  tensor_P (1\\<^sub>m N) m1 * tensor_P m3 m2 = tensor_P m3 (m1 * m2)\n  tensor_P m3 (m1 * m2) * tensor_P (1\\<^sub>m N) m4 =\n  tensor_P m3 (m1 * m2 * m4)", "show ?thesis"], ["proof (prove)\nusing this:\n  tensor_P (1\\<^sub>m N) m1 * tensor_P m3 m2 = tensor_P m3 (m1 * m2)\n  tensor_P m3 (m1 * m2) * tensor_P (1\\<^sub>m N) m4 =\n  tensor_P m3 (m1 * m2 * m4)\n\ngoal (1 subgoal):\n 1. tensor_P (1\\<^sub>m N) m1 * tensor_P m3 m2 * tensor_P (1\\<^sub>m N) m4 =\n    tensor_P m3 (m1 * m2 * m4)", "by auto"], ["proof (state)\nthis:\n  tensor_P (1\\<^sub>m N) m1 * tensor_P m3 m2 * tensor_P (1\\<^sub>m N) m4 =\n  tensor_P m3 (m1 * m2 * m4)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma matrix_sum_mult_left_right:\n  fixes A B :: \"complex mat\"\n  assumes dg: \"(\\<And>k. k < l \\<Longrightarrow> g k \\<in> carrier_mat m m) \"\n    and dA: \"A \\<in> carrier_mat m m\" and dB: \"B \\<in> carrier_mat m m\"\n  shows \"matrix_sum m (\\<lambda>k. A * g k * B) l = A * matrix_sum m g l * B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_sum m (\\<lambda>k. A * g k * B) l = A * matrix_sum m g l * B", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. matrix_sum m (\\<lambda>k. A * g k * B) l = A * matrix_sum m g l * B", "have eq: \"A * matrix_sum m g l = matrix_sum m (\\<lambda>k. A * g k) l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A * matrix_sum m g l = matrix_sum m (\\<lambda>k. A * g k) l", "using matrix_sum_distrib_left assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>?P \\<in> carrier_mat ?d ?d;\n   \\<And>k. k < ?n \\<Longrightarrow> ?f k \\<in> carrier_mat ?d ?d\\<rbrakk>\n  \\<Longrightarrow> matrix_sum ?d (\\<lambda>k. ?P * ?f k) ?n =\n                    ?P * matrix_sum ?d ?f ?n\n  ?k2 < l \\<Longrightarrow> g ?k2 \\<in> carrier_mat m m\n  A \\<in> carrier_mat m m\n  B \\<in> carrier_mat m m\n\ngoal (1 subgoal):\n 1. A * matrix_sum m g l = matrix_sum m (\\<lambda>k. A * g k) l", "by auto"], ["proof (state)\nthis:\n  A * matrix_sum m g l = matrix_sum m (\\<lambda>k. A * g k) l\n\ngoal (1 subgoal):\n 1. matrix_sum m (\\<lambda>k. A * g k * B) l = A * matrix_sum m g l * B", "have \"A * matrix_sum m g l * B = matrix_sum m (\\<lambda>k. A * g k * B) l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A * matrix_sum m g l * B = matrix_sum m (\\<lambda>k. A * g k * B) l", "apply (subst eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_sum m (\\<lambda>k. A * g k) l * B =\n    matrix_sum m (\\<lambda>k. A * g k * B) l", "using matrix_sum_mult_right[of l \"\\<lambda>k. A * g k\"] assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>k. k < l \\<Longrightarrow> A * g k \\<in> carrier_mat ?d ?d;\n   ?A \\<in> carrier_mat ?d ?d\\<rbrakk>\n  \\<Longrightarrow> matrix_sum ?d (\\<lambda>k. A * g k * ?A) l =\n                    matrix_sum ?d (\\<lambda>k. A * g k) l * ?A\n  ?k2 < l \\<Longrightarrow> g ?k2 \\<in> carrier_mat m m\n  A \\<in> carrier_mat m m\n  B \\<in> carrier_mat m m\n\ngoal (1 subgoal):\n 1. matrix_sum m (\\<lambda>k. A * g k) l * B =\n    matrix_sum m (\\<lambda>k. A * g k * B) l", "by auto"], ["proof (state)\nthis:\n  A * matrix_sum m g l * B = matrix_sum m (\\<lambda>k. A * g k * B) l\n\ngoal (1 subgoal):\n 1. matrix_sum m (\\<lambda>k. A * g k * B) l = A * matrix_sum m g l * B", "then"], ["proof (chain)\npicking this:\n  A * matrix_sum m g l * B = matrix_sum m (\\<lambda>k. A * g k * B) l", "show ?thesis"], ["proof (prove)\nusing this:\n  A * matrix_sum m g l * B = matrix_sum m (\\<lambda>k. A * g k * B) l\n\ngoal (1 subgoal):\n 1. matrix_sum m (\\<lambda>k. A * g k * B) l = A * matrix_sum m g l * B", "by auto"], ["proof (state)\nthis:\n  matrix_sum m (\\<lambda>k. A * g k * B) l = A * matrix_sum m g l * B\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mat_O_split:\n  \"mat_O = 1\\<^sub>m N - 2 \\<cdot>\\<^sub>m proj_O\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_O = 1\\<^sub>m N - 2 \\<cdot>\\<^sub>m proj_O", "apply (rule eq_matI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row (1\\<^sub>m N - 2 \\<cdot>\\<^sub>m proj_O);\n        j < dim_col (1\\<^sub>m N - 2 \\<cdot>\\<^sub>m proj_O)\\<rbrakk>\n       \\<Longrightarrow> mat_O $$ (i, j) =\n                         (1\\<^sub>m N - 2 \\<cdot>\\<^sub>m proj_O) $$ (i, j)\n 2. dim_row mat_O = dim_row (1\\<^sub>m N - 2 \\<cdot>\\<^sub>m proj_O)\n 3. dim_col mat_O = dim_col (1\\<^sub>m N - 2 \\<cdot>\\<^sub>m proj_O)", "unfolding mat_O_def proj_O_def"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row\n                     (1\\<^sub>m N -\n                      2 \\<cdot>\\<^sub>m\n                      mat N N\n                       (\\<lambda>(i, j).\n                           if i = j then if f i then 1 else 0 else 0));\n        j < dim_col\n             (1\\<^sub>m N -\n              2 \\<cdot>\\<^sub>m\n              mat N N\n               (\\<lambda>(i, j).\n                   if i = j then if f i then 1 else 0 else 0))\\<rbrakk>\n       \\<Longrightarrow> mat N N\n                          (\\<lambda>(i, j).\n                              if i = j then if f i then - 1 else 1\n                              else 0) $$\n                         (i, j) =\n                         (1\\<^sub>m N -\n                          2 \\<cdot>\\<^sub>m\n                          mat N N\n                           (\\<lambda>(i, j).\n                               if i = j then if f i then 1 else 0\n                               else 0)) $$\n                         (i, j)\n 2. dim_row\n     (mat N N\n       (\\<lambda>(i, j). if i = j then if f i then - 1 else 1 else 0)) =\n    dim_row\n     (1\\<^sub>m N -\n      2 \\<cdot>\\<^sub>m\n      mat N N (\\<lambda>(i, j). if i = j then if f i then 1 else 0 else 0))\n 3. dim_col\n     (mat N N\n       (\\<lambda>(i, j). if i = j then if f i then - 1 else 1 else 0)) =\n    dim_col\n     (1\\<^sub>m N -\n      2 \\<cdot>\\<^sub>m\n      mat N N (\\<lambda>(i, j). if i = j then if f i then 1 else 0 else 0))", "by auto"], ["", "lemma mat_O_mult_psi'_l:\n  \"mat_O *\\<^sub>v (psi'_l l) = psi_l l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_O *\\<^sub>v psi'_l l = psi_l l", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. mat_O *\\<^sub>v psi'_l l = psi_l l", "have \"mat_O *\\<^sub>v (psi'_l l) = mat_O *\\<^sub>v ((alpha_l l) \\<cdot>\\<^sub>v \\<alpha>) - mat_O *\\<^sub>v ((beta_l l) \\<cdot>\\<^sub>v \\<beta>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_O *\\<^sub>v psi'_l l =\n    mat_O *\\<^sub>v (alpha_l l \\<cdot>\\<^sub>v \\<alpha>) -\n    mat_O *\\<^sub>v (beta_l l \\<cdot>\\<^sub>v \\<beta>)", "unfolding psi'_l_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_O *\\<^sub>v\n    (alpha_l l \\<cdot>\\<^sub>v \\<alpha> -\n     beta_l l \\<cdot>\\<^sub>v \\<beta>) =\n    mat_O *\\<^sub>v (alpha_l l \\<cdot>\\<^sub>v \\<alpha>) -\n    mat_O *\\<^sub>v (beta_l l \\<cdot>\\<^sub>v \\<beta>)", "apply (subst mult_minus_distrib_mat_vec)"], ["proof (prove)\ngoal (4 subgoals):\n 1. mat_O \\<in> carrier_mat ?nr ?nc\n 2. alpha_l l \\<cdot>\\<^sub>v \\<alpha> \\<in> carrier_vec ?nc\n 3. beta_l l \\<cdot>\\<^sub>v \\<beta> \\<in> carrier_vec ?nc\n 4. mat_O *\\<^sub>v (alpha_l l \\<cdot>\\<^sub>v \\<alpha>) -\n    mat_O *\\<^sub>v (beta_l l \\<cdot>\\<^sub>v \\<beta>) =\n    mat_O *\\<^sub>v (alpha_l l \\<cdot>\\<^sub>v \\<alpha>) -\n    mat_O *\\<^sub>v (beta_l l \\<cdot>\\<^sub>v \\<beta>)", "using mat_O_dim \\<alpha>_dim \\<beta>_dim"], ["proof (prove)\nusing this:\n  mat_O \\<in> carrier_mat N N\n  \\<alpha> \\<in> carrier_vec N\n  dim_vec \\<alpha> = N\n  \\<beta> \\<in> carrier_vec N\n  dim_vec \\<beta> = N\n\ngoal (4 subgoals):\n 1. mat_O \\<in> carrier_mat ?nr ?nc\n 2. alpha_l l \\<cdot>\\<^sub>v \\<alpha> \\<in> carrier_vec ?nc\n 3. beta_l l \\<cdot>\\<^sub>v \\<beta> \\<in> carrier_vec ?nc\n 4. mat_O *\\<^sub>v (alpha_l l \\<cdot>\\<^sub>v \\<alpha>) -\n    mat_O *\\<^sub>v (beta_l l \\<cdot>\\<^sub>v \\<beta>) =\n    mat_O *\\<^sub>v (alpha_l l \\<cdot>\\<^sub>v \\<alpha>) -\n    mat_O *\\<^sub>v (beta_l l \\<cdot>\\<^sub>v \\<beta>)", "by auto"], ["proof (state)\nthis:\n  mat_O *\\<^sub>v psi'_l l =\n  mat_O *\\<^sub>v (alpha_l l \\<cdot>\\<^sub>v \\<alpha>) -\n  mat_O *\\<^sub>v (beta_l l \\<cdot>\\<^sub>v \\<beta>)\n\ngoal (1 subgoal):\n 1. mat_O *\\<^sub>v psi'_l l = psi_l l", "also"], ["proof (state)\nthis:\n  mat_O *\\<^sub>v psi'_l l =\n  mat_O *\\<^sub>v (alpha_l l \\<cdot>\\<^sub>v \\<alpha>) -\n  mat_O *\\<^sub>v (beta_l l \\<cdot>\\<^sub>v \\<beta>)\n\ngoal (1 subgoal):\n 1. mat_O *\\<^sub>v psi'_l l = psi_l l", "have \"\\<dots> = (alpha_l l) \\<cdot>\\<^sub>v (mat_O *\\<^sub>v  \\<alpha>) - (beta_l l) \\<cdot>\\<^sub>v (mat_O *\\<^sub>v \\<beta>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_O *\\<^sub>v (alpha_l l \\<cdot>\\<^sub>v \\<alpha>) -\n    mat_O *\\<^sub>v (beta_l l \\<cdot>\\<^sub>v \\<beta>) =\n    alpha_l l \\<cdot>\\<^sub>v (mat_O *\\<^sub>v \\<alpha>) -\n    beta_l l \\<cdot>\\<^sub>v (mat_O *\\<^sub>v \\<beta>)", "using mult_mat_vec_smult_vec_assoc[of mat_O N N] mat_O_dim \\<alpha>_dim \\<beta>_dim"], ["proof (prove)\nusing this:\n  \\<lbrakk>mat_O \\<in> carrier_mat N N; ?w \\<in> carrier_vec N\\<rbrakk>\n  \\<Longrightarrow> mat_O *\\<^sub>v (?a \\<cdot>\\<^sub>v ?w) =\n                    ?a \\<cdot>\\<^sub>v (mat_O *\\<^sub>v ?w)\n  mat_O \\<in> carrier_mat N N\n  \\<alpha> \\<in> carrier_vec N\n  dim_vec \\<alpha> = N\n  \\<beta> \\<in> carrier_vec N\n  dim_vec \\<beta> = N\n\ngoal (1 subgoal):\n 1. mat_O *\\<^sub>v (alpha_l l \\<cdot>\\<^sub>v \\<alpha>) -\n    mat_O *\\<^sub>v (beta_l l \\<cdot>\\<^sub>v \\<beta>) =\n    alpha_l l \\<cdot>\\<^sub>v (mat_O *\\<^sub>v \\<alpha>) -\n    beta_l l \\<cdot>\\<^sub>v (mat_O *\\<^sub>v \\<beta>)", "by auto"], ["proof (state)\nthis:\n  mat_O *\\<^sub>v (alpha_l l \\<cdot>\\<^sub>v \\<alpha>) -\n  mat_O *\\<^sub>v (beta_l l \\<cdot>\\<^sub>v \\<beta>) =\n  alpha_l l \\<cdot>\\<^sub>v (mat_O *\\<^sub>v \\<alpha>) -\n  beta_l l \\<cdot>\\<^sub>v (mat_O *\\<^sub>v \\<beta>)\n\ngoal (1 subgoal):\n 1. mat_O *\\<^sub>v psi'_l l = psi_l l", "also"], ["proof (state)\nthis:\n  mat_O *\\<^sub>v (alpha_l l \\<cdot>\\<^sub>v \\<alpha>) -\n  mat_O *\\<^sub>v (beta_l l \\<cdot>\\<^sub>v \\<beta>) =\n  alpha_l l \\<cdot>\\<^sub>v (mat_O *\\<^sub>v \\<alpha>) -\n  beta_l l \\<cdot>\\<^sub>v (mat_O *\\<^sub>v \\<beta>)\n\ngoal (1 subgoal):\n 1. mat_O *\\<^sub>v psi'_l l = psi_l l", "have \"\\<dots> = (alpha_l l) \\<cdot>\\<^sub>v \\<alpha> - (beta_l l) \\<cdot>\\<^sub>v (- \\<beta>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. alpha_l l \\<cdot>\\<^sub>v (mat_O *\\<^sub>v \\<alpha>) -\n    beta_l l \\<cdot>\\<^sub>v (mat_O *\\<^sub>v \\<beta>) =\n    alpha_l l \\<cdot>\\<^sub>v \\<alpha> - beta_l l \\<cdot>\\<^sub>v - \\<beta>", "using mat_O_mult_alpha mat_O_mult_beta"], ["proof (prove)\nusing this:\n  mat_O *\\<^sub>v \\<alpha> = \\<alpha>\n  mat_O *\\<^sub>v \\<beta> = - \\<beta>\n\ngoal (1 subgoal):\n 1. alpha_l l \\<cdot>\\<^sub>v (mat_O *\\<^sub>v \\<alpha>) -\n    beta_l l \\<cdot>\\<^sub>v (mat_O *\\<^sub>v \\<beta>) =\n    alpha_l l \\<cdot>\\<^sub>v \\<alpha> - beta_l l \\<cdot>\\<^sub>v - \\<beta>", "by auto"], ["proof (state)\nthis:\n  alpha_l l \\<cdot>\\<^sub>v (mat_O *\\<^sub>v \\<alpha>) -\n  beta_l l \\<cdot>\\<^sub>v (mat_O *\\<^sub>v \\<beta>) =\n  alpha_l l \\<cdot>\\<^sub>v \\<alpha> - beta_l l \\<cdot>\\<^sub>v - \\<beta>\n\ngoal (1 subgoal):\n 1. mat_O *\\<^sub>v psi'_l l = psi_l l", "also"], ["proof (state)\nthis:\n  alpha_l l \\<cdot>\\<^sub>v (mat_O *\\<^sub>v \\<alpha>) -\n  beta_l l \\<cdot>\\<^sub>v (mat_O *\\<^sub>v \\<beta>) =\n  alpha_l l \\<cdot>\\<^sub>v \\<alpha> - beta_l l \\<cdot>\\<^sub>v - \\<beta>\n\ngoal (1 subgoal):\n 1. mat_O *\\<^sub>v psi'_l l = psi_l l", "have \"\\<dots> = (alpha_l l) \\<cdot>\\<^sub>v \\<alpha> + (beta_l l) \\<cdot>\\<^sub>v \\<beta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. alpha_l l \\<cdot>\\<^sub>v \\<alpha> -\n    beta_l l \\<cdot>\\<^sub>v - \\<beta> =\n    alpha_l l \\<cdot>\\<^sub>v \\<alpha> + beta_l l \\<cdot>\\<^sub>v \\<beta>", "by auto"], ["proof (state)\nthis:\n  alpha_l l \\<cdot>\\<^sub>v \\<alpha> - beta_l l \\<cdot>\\<^sub>v - \\<beta> =\n  alpha_l l \\<cdot>\\<^sub>v \\<alpha> + beta_l l \\<cdot>\\<^sub>v \\<beta>\n\ngoal (1 subgoal):\n 1. mat_O *\\<^sub>v psi'_l l = psi_l l", "finally"], ["proof (chain)\npicking this:\n  mat_O *\\<^sub>v psi'_l l =\n  alpha_l l \\<cdot>\\<^sub>v \\<alpha> + beta_l l \\<cdot>\\<^sub>v \\<beta>", "show ?thesis"], ["proof (prove)\nusing this:\n  mat_O *\\<^sub>v psi'_l l =\n  alpha_l l \\<cdot>\\<^sub>v \\<alpha> + beta_l l \\<cdot>\\<^sub>v \\<beta>\n\ngoal (1 subgoal):\n 1. mat_O *\\<^sub>v psi'_l l = psi_l l", "unfolding psi_l_def"], ["proof (prove)\nusing this:\n  mat_O *\\<^sub>v psi'_l l =\n  alpha_l l \\<cdot>\\<^sub>v \\<alpha> + beta_l l \\<cdot>\\<^sub>v \\<beta>\n\ngoal (1 subgoal):\n 1. mat_O *\\<^sub>v psi'_l l =\n    alpha_l l \\<cdot>\\<^sub>v \\<alpha> + beta_l l \\<cdot>\\<^sub>v \\<beta>", "by auto"], ["proof (state)\nthis:\n  mat_O *\\<^sub>v psi'_l l = psi_l l\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mat_O_times_Q1:\n  \"adjoint (tensor_P mat_O (1\\<^sub>m K)) * Q1 * (tensor_P mat_O (1\\<^sub>m K)) = Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adjoint (tensor_P mat_O (1\\<^sub>m K)) * Q1 *\n    tensor_P mat_O (1\\<^sub>m K) =\n    Q", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. adjoint (tensor_P mat_O (1\\<^sub>m K)) * Q1 *\n    tensor_P mat_O (1\\<^sub>m K) =\n    Q", "let ?m1 = \"tensor_P mat_O (1\\<^sub>m K)\""], ["proof (state)\ngoal (1 subgoal):\n 1. adjoint (tensor_P mat_O (1\\<^sub>m K)) * Q1 *\n    tensor_P mat_O (1\\<^sub>m K) =\n    Q", "have eq:\"adjoint ?m1 = ?m1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adjoint (tensor_P mat_O (1\\<^sub>m K)) = tensor_P mat_O (1\\<^sub>m K)", "unfolding ps2_P.ptensor_mat_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. adjoint (ps_P.tensor_mat mat_O (1\\<^sub>m K)) =\n    ps_P.tensor_mat mat_O (1\\<^sub>m K)", "apply (subst ps_P.tensor_mat_adjoint)"], ["proof (prove)\ngoal (3 subgoals):\n 1. mat_O \\<in> carrier_mat ps_P.d1 ps_P.d1\n 2. 1\\<^sub>m K \\<in> carrier_mat ps_P.d2 ps_P.d2\n 3. ps_P.tensor_mat (adjoint mat_O) (adjoint (1\\<^sub>m K)) =\n    ps_P.tensor_mat mat_O (1\\<^sub>m K)", "apply (auto simp add: mat_O_dim ps_P_d1 ps_P_d2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ps_P.tensor_mat (adjoint mat_O) (adjoint (1\\<^sub>m K)) =\n    ps_P.tensor_mat mat_O (1\\<^sub>m K)", "by (simp add: hermitian_mat_O[unfolded hermitian_def] hermitian_one[unfolded hermitian_def])"], ["proof (state)\nthis:\n  adjoint (tensor_P mat_O (1\\<^sub>m K)) = tensor_P mat_O (1\\<^sub>m K)\n\ngoal (1 subgoal):\n 1. adjoint (tensor_P mat_O (1\\<^sub>m K)) * Q1 *\n    tensor_P mat_O (1\\<^sub>m K) =\n    Q", "{"], ["proof (state)\nthis:\n  adjoint (tensor_P mat_O (1\\<^sub>m K)) = tensor_P mat_O (1\\<^sub>m K)\n\ngoal (1 subgoal):\n 1. adjoint (tensor_P mat_O (1\\<^sub>m K)) * Q1 *\n    tensor_P mat_O (1\\<^sub>m K) =\n    Q", "fix l"], ["proof (state)\ngoal (1 subgoal):\n 1. adjoint (tensor_P mat_O (1\\<^sub>m K)) * Q1 *\n    tensor_P mat_O (1\\<^sub>m K) =\n    Q", "let ?m2 = \"tensor_P (proj_psi'_l l) (proj_k l)\""], ["proof (state)\ngoal (1 subgoal):\n 1. adjoint (tensor_P mat_O (1\\<^sub>m K)) * Q1 *\n    tensor_P mat_O (1\\<^sub>m K) =\n    Q", "have \"?m1 * ?m2 * ?m1 = tensor_P (mat_O * (proj_psi'_l l) * mat_O) (proj_k l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tensor_P mat_O (1\\<^sub>m K) * tensor_P (proj_psi'_l l) (proj_k l) *\n    tensor_P mat_O (1\\<^sub>m K) =\n    tensor_P (mat_O * proj_psi'_l l * mat_O) (proj_k l)", "apply (subst tensor_P_left_right_partial1)"], ["proof (prove)\ngoal (4 subgoals):\n 1. mat_O \\<in> carrier_mat N N\n 2. proj_psi'_l l \\<in> carrier_mat N N\n 3. proj_k l \\<in> carrier_mat K K\n 4. tensor_P (mat_O * proj_psi'_l l * mat_O) (proj_k l) =\n    tensor_P (mat_O * proj_psi'_l l * mat_O) (proj_k l)", "using mat_O_dim proj_psi'_dim proj_k_dim"], ["proof (prove)\nusing this:\n  mat_O \\<in> carrier_mat N N\n  proj_psi'_l ?l \\<in> carrier_mat N N\n  proj_k ?k \\<in> carrier_mat K K\n\ngoal (4 subgoals):\n 1. mat_O \\<in> carrier_mat N N\n 2. proj_psi'_l l \\<in> carrier_mat N N\n 3. proj_k l \\<in> carrier_mat K K\n 4. tensor_P (mat_O * proj_psi'_l l * mat_O) (proj_k l) =\n    tensor_P (mat_O * proj_psi'_l l * mat_O) (proj_k l)", "by auto"], ["proof (state)\nthis:\n  tensor_P mat_O (1\\<^sub>m K) * tensor_P (proj_psi'_l l) (proj_k l) *\n  tensor_P mat_O (1\\<^sub>m K) =\n  tensor_P (mat_O * proj_psi'_l l * mat_O) (proj_k l)\n\ngoal (1 subgoal):\n 1. adjoint (tensor_P mat_O (1\\<^sub>m K)) * Q1 *\n    tensor_P mat_O (1\\<^sub>m K) =\n    Q", "moreover"], ["proof (state)\nthis:\n  tensor_P mat_O (1\\<^sub>m K) * tensor_P (proj_psi'_l l) (proj_k l) *\n  tensor_P mat_O (1\\<^sub>m K) =\n  tensor_P (mat_O * proj_psi'_l l * mat_O) (proj_k l)\n\ngoal (1 subgoal):\n 1. adjoint (tensor_P mat_O (1\\<^sub>m K)) * Q1 *\n    tensor_P mat_O (1\\<^sub>m K) =\n    Q", "have \"mat_O * (proj_psi'_l l) * mat_O = outer_prod (psi_l l) (psi_l l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_O * proj_psi'_l l * mat_O = outer_prod (psi_l l) (psi_l l)", "unfolding proj_psi'_l_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_O * outer_prod (psi'_l l) (psi'_l l) * mat_O =\n    outer_prod (psi_l l) (psi_l l)", "apply (subst outer_prod_left_right_mat[of _ N _ N  _ N _ N])"], ["proof (prove)\ngoal (3 subgoals):\n 1. psi'_l l \\<in> carrier_vec N\n 2. mat_O \\<in> carrier_mat N N\n 3. outer_prod (mat_O *\\<^sub>v psi'_l l)\n     (adjoint mat_O *\\<^sub>v psi'_l l) =\n    outer_prod (psi_l l) (psi_l l)", "using psi'_l_dim mat_O_dim mat_O_mult_psi'_l hermitian_mat_O[unfolded hermitian_def]"], ["proof (prove)\nusing this:\n  psi'_l ?l \\<in> carrier_vec N\n  mat_O \\<in> carrier_mat N N\n  mat_O *\\<^sub>v psi'_l ?l = psi_l ?l\n  adjoint mat_O = mat_O\n\ngoal (3 subgoals):\n 1. psi'_l l \\<in> carrier_vec N\n 2. mat_O \\<in> carrier_mat N N\n 3. outer_prod (mat_O *\\<^sub>v psi'_l l)\n     (adjoint mat_O *\\<^sub>v psi'_l l) =\n    outer_prod (psi_l l) (psi_l l)", "by auto"], ["proof (state)\nthis:\n  mat_O * proj_psi'_l l * mat_O = outer_prod (psi_l l) (psi_l l)\n\ngoal (1 subgoal):\n 1. adjoint (tensor_P mat_O (1\\<^sub>m K)) * Q1 *\n    tensor_P mat_O (1\\<^sub>m K) =\n    Q", "ultimately"], ["proof (chain)\npicking this:\n  tensor_P mat_O (1\\<^sub>m K) * tensor_P (proj_psi'_l l) (proj_k l) *\n  tensor_P mat_O (1\\<^sub>m K) =\n  tensor_P (mat_O * proj_psi'_l l * mat_O) (proj_k l)\n  mat_O * proj_psi'_l l * mat_O = outer_prod (psi_l l) (psi_l l)", "have \"?m1 * ?m2 * ?m1 = tensor_P (proj_psi_l l) (proj_k l)\""], ["proof (prove)\nusing this:\n  tensor_P mat_O (1\\<^sub>m K) * tensor_P (proj_psi'_l l) (proj_k l) *\n  tensor_P mat_O (1\\<^sub>m K) =\n  tensor_P (mat_O * proj_psi'_l l * mat_O) (proj_k l)\n  mat_O * proj_psi'_l l * mat_O = outer_prod (psi_l l) (psi_l l)\n\ngoal (1 subgoal):\n 1. tensor_P mat_O (1\\<^sub>m K) * tensor_P (proj_psi'_l l) (proj_k l) *\n    tensor_P mat_O (1\\<^sub>m K) =\n    tensor_P (proj_psi_l l) (proj_k l)", "unfolding proj_psi_l_def"], ["proof (prove)\nusing this:\n  tensor_P mat_O (1\\<^sub>m K) * tensor_P (proj_psi'_l l) (proj_k l) *\n  tensor_P mat_O (1\\<^sub>m K) =\n  tensor_P (mat_O * proj_psi'_l l * mat_O) (proj_k l)\n  mat_O * proj_psi'_l l * mat_O = outer_prod (psi_l l) (psi_l l)\n\ngoal (1 subgoal):\n 1. tensor_P mat_O (1\\<^sub>m K) * tensor_P (proj_psi'_l l) (proj_k l) *\n    tensor_P mat_O (1\\<^sub>m K) =\n    tensor_P (outer_prod (psi_l l) (psi_l l)) (proj_k l)", "by auto"], ["proof (state)\nthis:\n  tensor_P mat_O (1\\<^sub>m K) * tensor_P (proj_psi'_l l) (proj_k l) *\n  tensor_P mat_O (1\\<^sub>m K) =\n  tensor_P (proj_psi_l l) (proj_k l)\n\ngoal (1 subgoal):\n 1. adjoint (tensor_P mat_O (1\\<^sub>m K)) * Q1 *\n    tensor_P mat_O (1\\<^sub>m K) =\n    Q", "}"], ["proof (state)\nthis:\n  tensor_P mat_O (1\\<^sub>m K) * tensor_P (proj_psi'_l ?l4) (proj_k ?l4) *\n  tensor_P mat_O (1\\<^sub>m K) =\n  tensor_P (proj_psi_l ?l4) (proj_k ?l4)\n\ngoal (1 subgoal):\n 1. adjoint (tensor_P mat_O (1\\<^sub>m K)) * Q1 *\n    tensor_P mat_O (1\\<^sub>m K) =\n    Q", "note p1 = this"], ["proof (state)\nthis:\n  tensor_P mat_O (1\\<^sub>m K) * tensor_P (proj_psi'_l ?l4) (proj_k ?l4) *\n  tensor_P mat_O (1\\<^sub>m K) =\n  tensor_P (proj_psi_l ?l4) (proj_k ?l4)\n\ngoal (1 subgoal):\n 1. adjoint (tensor_P mat_O (1\\<^sub>m K)) * Q1 *\n    tensor_P mat_O (1\\<^sub>m K) =\n    Q", "have \"adjoint (tensor_P mat_O (1\\<^sub>m K)) * Q1 * (tensor_P mat_O (1\\<^sub>m K)) = ?m1 * Q1 * ?m1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adjoint (tensor_P mat_O (1\\<^sub>m K)) * Q1 *\n    tensor_P mat_O (1\\<^sub>m K) =\n    tensor_P mat_O (1\\<^sub>m K) * Q1 * tensor_P mat_O (1\\<^sub>m K)", "using eq"], ["proof (prove)\nusing this:\n  adjoint (tensor_P mat_O (1\\<^sub>m K)) = tensor_P mat_O (1\\<^sub>m K)\n\ngoal (1 subgoal):\n 1. adjoint (tensor_P mat_O (1\\<^sub>m K)) * Q1 *\n    tensor_P mat_O (1\\<^sub>m K) =\n    tensor_P mat_O (1\\<^sub>m K) * Q1 * tensor_P mat_O (1\\<^sub>m K)", "by auto"], ["proof (state)\nthis:\n  adjoint (tensor_P mat_O (1\\<^sub>m K)) * Q1 *\n  tensor_P mat_O (1\\<^sub>m K) =\n  tensor_P mat_O (1\\<^sub>m K) * Q1 * tensor_P mat_O (1\\<^sub>m K)\n\ngoal (1 subgoal):\n 1. adjoint (tensor_P mat_O (1\\<^sub>m K)) * Q1 *\n    tensor_P mat_O (1\\<^sub>m K) =\n    Q", "also"], ["proof (state)\nthis:\n  adjoint (tensor_P mat_O (1\\<^sub>m K)) * Q1 *\n  tensor_P mat_O (1\\<^sub>m K) =\n  tensor_P mat_O (1\\<^sub>m K) * Q1 * tensor_P mat_O (1\\<^sub>m K)\n\ngoal (1 subgoal):\n 1. adjoint (tensor_P mat_O (1\\<^sub>m K)) * Q1 *\n    tensor_P mat_O (1\\<^sub>m K) =\n    Q", "have \"\\<dots> = matrix_sum d (\\<lambda>l. ?m1 * (tensor_P (proj_psi'_l l) (proj_k l)) * ?m1) R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tensor_P mat_O (1\\<^sub>m K) * Q1 * tensor_P mat_O (1\\<^sub>m K) =\n    matrix_sum d\n     (\\<lambda>l.\n         tensor_P mat_O (1\\<^sub>m K) *\n         tensor_P (proj_psi'_l l) (proj_k l) *\n         tensor_P mat_O (1\\<^sub>m K))\n     R", "unfolding Q1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. tensor_P mat_O (1\\<^sub>m K) *\n    matrix_sum d (\\<lambda>l. tensor_P (proj_psi'_l l) (proj_k l)) R *\n    tensor_P mat_O (1\\<^sub>m K) =\n    matrix_sum d\n     (\\<lambda>l.\n         tensor_P mat_O (1\\<^sub>m K) *\n         tensor_P (proj_psi'_l l) (proj_k l) *\n         tensor_P mat_O (1\\<^sub>m K))\n     R", "apply (subst matrix_sum_mult_left_right)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>k.\n       k < R \\<Longrightarrow>\n       tensor_P (proj_psi'_l k) (proj_k k) \\<in> carrier_mat d d\n 2. tensor_P mat_O (1\\<^sub>m K) \\<in> carrier_mat d d\n 3. tensor_P mat_O (1\\<^sub>m K) *\n    matrix_sum d (\\<lambda>l. tensor_P (proj_psi'_l l) (proj_k l)) R *\n    tensor_P mat_O (1\\<^sub>m K) =\n    tensor_P mat_O (1\\<^sub>m K) *\n    matrix_sum d (\\<lambda>l. tensor_P (proj_psi'_l l) (proj_k l)) R *\n    tensor_P mat_O (1\\<^sub>m K)", "using tensor_P_dim"], ["proof (prove)\nusing this:\n  tensor_P ?A ?B \\<in> carrier_mat d d\n\ngoal (3 subgoals):\n 1. \\<And>k.\n       k < R \\<Longrightarrow>\n       tensor_P (proj_psi'_l k) (proj_k k) \\<in> carrier_mat d d\n 2. tensor_P mat_O (1\\<^sub>m K) \\<in> carrier_mat d d\n 3. tensor_P mat_O (1\\<^sub>m K) *\n    matrix_sum d (\\<lambda>l. tensor_P (proj_psi'_l l) (proj_k l)) R *\n    tensor_P mat_O (1\\<^sub>m K) =\n    tensor_P mat_O (1\\<^sub>m K) *\n    matrix_sum d (\\<lambda>l. tensor_P (proj_psi'_l l) (proj_k l)) R *\n    tensor_P mat_O (1\\<^sub>m K)", "by auto"], ["proof (state)\nthis:\n  tensor_P mat_O (1\\<^sub>m K) * Q1 * tensor_P mat_O (1\\<^sub>m K) =\n  matrix_sum d\n   (\\<lambda>l.\n       tensor_P mat_O (1\\<^sub>m K) * tensor_P (proj_psi'_l l) (proj_k l) *\n       tensor_P mat_O (1\\<^sub>m K))\n   R\n\ngoal (1 subgoal):\n 1. adjoint (tensor_P mat_O (1\\<^sub>m K)) * Q1 *\n    tensor_P mat_O (1\\<^sub>m K) =\n    Q", "also"], ["proof (state)\nthis:\n  tensor_P mat_O (1\\<^sub>m K) * Q1 * tensor_P mat_O (1\\<^sub>m K) =\n  matrix_sum d\n   (\\<lambda>l.\n       tensor_P mat_O (1\\<^sub>m K) * tensor_P (proj_psi'_l l) (proj_k l) *\n       tensor_P mat_O (1\\<^sub>m K))\n   R\n\ngoal (1 subgoal):\n 1. adjoint (tensor_P mat_O (1\\<^sub>m K)) * Q1 *\n    tensor_P mat_O (1\\<^sub>m K) =\n    Q", "have \"\\<dots> = Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_sum d\n     (\\<lambda>l.\n         tensor_P mat_O (1\\<^sub>m K) *\n         tensor_P (proj_psi'_l l) (proj_k l) *\n         tensor_P mat_O (1\\<^sub>m K))\n     R =\n    Q", "unfolding Q_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_sum d\n     (\\<lambda>l.\n         tensor_P mat_O (1\\<^sub>m K) *\n         tensor_P (proj_psi'_l l) (proj_k l) *\n         tensor_P mat_O (1\\<^sub>m K))\n     R =\n    matrix_sum d (\\<lambda>l. tensor_P (proj_psi_l l) (proj_k l)) R", "using p1"], ["proof (prove)\nusing this:\n  tensor_P mat_O (1\\<^sub>m K) * tensor_P (proj_psi'_l ?l4) (proj_k ?l4) *\n  tensor_P mat_O (1\\<^sub>m K) =\n  tensor_P (proj_psi_l ?l4) (proj_k ?l4)\n\ngoal (1 subgoal):\n 1. matrix_sum d\n     (\\<lambda>l.\n         tensor_P mat_O (1\\<^sub>m K) *\n         tensor_P (proj_psi'_l l) (proj_k l) *\n         tensor_P mat_O (1\\<^sub>m K))\n     R =\n    matrix_sum d (\\<lambda>l. tensor_P (proj_psi_l l) (proj_k l)) R", "by auto"], ["proof (state)\nthis:\n  matrix_sum d\n   (\\<lambda>l.\n       tensor_P mat_O (1\\<^sub>m K) * tensor_P (proj_psi'_l l) (proj_k l) *\n       tensor_P mat_O (1\\<^sub>m K))\n   R =\n  Q\n\ngoal (1 subgoal):\n 1. adjoint (tensor_P mat_O (1\\<^sub>m K)) * Q1 *\n    tensor_P mat_O (1\\<^sub>m K) =\n    Q", "finally"], ["proof (chain)\npicking this:\n  adjoint (tensor_P mat_O (1\\<^sub>m K)) * Q1 *\n  tensor_P mat_O (1\\<^sub>m K) =\n  Q", "show ?thesis"], ["proof (prove)\nusing this:\n  adjoint (tensor_P mat_O (1\\<^sub>m K)) * Q1 *\n  tensor_P mat_O (1\\<^sub>m K) =\n  Q\n\ngoal (1 subgoal):\n 1. adjoint (tensor_P mat_O (1\\<^sub>m K)) * Q1 *\n    tensor_P mat_O (1\\<^sub>m K) =\n    Q", "by auto"], ["proof (state)\nthis:\n  adjoint (tensor_P mat_O (1\\<^sub>m K)) * Q1 *\n  tensor_P mat_O (1\\<^sub>m K) =\n  Q\n\ngoal:\nNo subgoals!", "qed"], ["", "definition Q2 where\n  \"Q2 = matrix_sum d (\\<lambda>l. tensor_P (proj_psi_l (l + 1)) (proj_k l)) R\""], ["", "lemma Q2_dim:\n  \"Q2 \\<in> carrier_mat d d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Q2 \\<in> carrier_mat d d", "unfolding Q2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_sum d (\\<lambda>l. tensor_P (proj_psi_l (l + 1)) (proj_k l)) R\n    \\<in> carrier_mat d d", "apply (subst matrix_sum_dim)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>k.\n       k < R \\<Longrightarrow>\n       tensor_P (proj_psi_l (k + 1)) (proj_k k) \\<in> carrier_mat d d\n 2. True", "using tensor_P_dim"], ["proof (prove)\nusing this:\n  tensor_P ?A ?B \\<in> carrier_mat d d\n\ngoal (2 subgoals):\n 1. \\<And>k.\n       k < R \\<Longrightarrow>\n       tensor_P (proj_psi_l (k + 1)) (proj_k k) \\<in> carrier_mat d d\n 2. True", "by auto"], ["", "lemma Q2_le_one:\n  \"Q2 \\<le>\\<^sub>L 1\\<^sub>m d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Q2 \\<le>\\<^sub>L 1\\<^sub>m d", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Q2 \\<le>\\<^sub>L 1\\<^sub>m d", "have leq: \"Q2 \\<le>\\<^sub>L matrix_sum d (\\<lambda>k. tensor_P (1\\<^sub>m N) (proj_k k)) R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Q2 \\<le>\\<^sub>L\n    matrix_sum d (\\<lambda>k. tensor_P (1\\<^sub>m N) (proj_k k)) R", "unfolding Q2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_sum d (\\<lambda>l. tensor_P (proj_psi_l (l + 1)) (proj_k l))\n     R \\<le>\\<^sub>L\n    matrix_sum d (\\<lambda>k. tensor_P (1\\<^sub>m N) (proj_k k)) R", "apply (subst lowner_le_matrix_sum)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>k.\n       k < R \\<Longrightarrow>\n       tensor_P (proj_psi_l (k + 1)) (proj_k k) \\<in> carrier_mat d d\n 2. \\<And>k.\n       k < R \\<Longrightarrow>\n       tensor_P (1\\<^sub>m N) (proj_k k) \\<in> carrier_mat d d\n 3. \\<And>k.\n       k < R \\<Longrightarrow>\n       tensor_P (proj_psi_l (k + 1)) (proj_k k) \\<le>\\<^sub>L\n       tensor_P (1\\<^sub>m N) (proj_k k)\n 4. True", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. k_ < R \\<Longrightarrow>\n    tensor_P (proj_psi_l (k_ + 1)) (proj_k k_) \\<in> carrier_mat d d", "using tensor_P_dim"], ["proof (prove)\nusing this:\n  tensor_P ?A ?B \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. k_ < R \\<Longrightarrow>\n    tensor_P (proj_psi_l (k_ + 1)) (proj_k k_) \\<in> carrier_mat d d", "by auto"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>k.\n       k < R \\<Longrightarrow>\n       tensor_P (1\\<^sub>m N) (proj_k k) \\<in> carrier_mat d d\n 2. \\<And>k.\n       k < R \\<Longrightarrow>\n       tensor_P (proj_psi_l (k + 1)) (proj_k k) \\<le>\\<^sub>L\n       tensor_P (1\\<^sub>m N) (proj_k k)\n 3. True", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. k_ < R \\<Longrightarrow>\n    tensor_P (1\\<^sub>m N) (proj_k k_) \\<in> carrier_mat d d", "using tensor_P_dim"], ["proof (prove)\nusing this:\n  tensor_P ?A ?B \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. k_ < R \\<Longrightarrow>\n    tensor_P (1\\<^sub>m N) (proj_k k_) \\<in> carrier_mat d d", "by auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>k.\n       k < R \\<Longrightarrow>\n       tensor_P (proj_psi_l (k + 1)) (proj_k k) \\<le>\\<^sub>L\n       tensor_P (1\\<^sub>m N) (proj_k k)\n 2. True", "using proj_psi_proj_k_le_exproj_k"], ["proof (prove)\nusing this:\n  tensor_P (proj_psi_l ?k) (proj_k ?l) \\<le>\\<^sub>L\n  tensor_P (1\\<^sub>m N) (proj_k ?l)\n\ngoal (2 subgoals):\n 1. \\<And>k.\n       k < R \\<Longrightarrow>\n       tensor_P (proj_psi_l (k + 1)) (proj_k k) \\<le>\\<^sub>L\n       tensor_P (1\\<^sub>m N) (proj_k k)\n 2. True", "by auto"], ["proof (state)\nthis:\n  Q2 \\<le>\\<^sub>L\n  matrix_sum d (\\<lambda>k. tensor_P (1\\<^sub>m N) (proj_k k)) R\n\ngoal (1 subgoal):\n 1. Q2 \\<le>\\<^sub>L 1\\<^sub>m d", "have \"matrix_sum d (\\<lambda>k. tensor_P (1\\<^sub>m N) (proj_k k)) R\n      = tensor_P (1\\<^sub>m N) (matrix_sum K proj_k R)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_sum d (\\<lambda>k. tensor_P (1\\<^sub>m N) (proj_k k)) R =\n    tensor_P (1\\<^sub>m N) (matrix_sum K proj_k R)", "unfolding ps2_P.ptensor_mat_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_sum d (\\<lambda>k. ps_P.tensor_mat (1\\<^sub>m N) (proj_k k)) R =\n    ps_P.tensor_mat (1\\<^sub>m N) (matrix_sum K proj_k R)", "apply (subst ps_P.tensor_mat_matrix_sum2[simplified ps_P_d ps_P_d2])"], ["proof (prove)\ngoal (3 subgoals):\n 1. 1\\<^sub>m N \\<in> carrier_mat ps_P.d1 ps_P.d1\n 2. \\<And>k. k < R \\<Longrightarrow> proj_k k \\<in> carrier_mat K K\n 3. ps_P.tensor_mat (1\\<^sub>m N) (matrix_sum K proj_k R) =\n    ps_P.tensor_mat (1\\<^sub>m N) (matrix_sum K proj_k R)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1\\<^sub>m N \\<in> carrier_mat ps_P.d1 ps_P.d1", "using ps_P_d1"], ["proof (prove)\nusing this:\n  ps_P.d1 = N\n\ngoal (1 subgoal):\n 1. 1\\<^sub>m N \\<in> carrier_mat ps_P.d1 ps_P.d1", "by auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>k. k < R \\<Longrightarrow> proj_k k \\<in> carrier_mat K K\n 2. ps_P.tensor_mat (1\\<^sub>m N) (matrix_sum K proj_k R) =\n    ps_P.tensor_mat (1\\<^sub>m N) (matrix_sum K proj_k R)", "using proj_k_dim"], ["proof (prove)\nusing this:\n  proj_k ?k \\<in> carrier_mat K K\n\ngoal (2 subgoals):\n 1. \\<And>k. k < R \\<Longrightarrow> proj_k k \\<in> carrier_mat K K\n 2. ps_P.tensor_mat (1\\<^sub>m N) (matrix_sum K proj_k R) =\n    ps_P.tensor_mat (1\\<^sub>m N) (matrix_sum K proj_k R)", "by auto"], ["proof (state)\nthis:\n  matrix_sum d (\\<lambda>k. tensor_P (1\\<^sub>m N) (proj_k k)) R =\n  tensor_P (1\\<^sub>m N) (matrix_sum K proj_k R)\n\ngoal (1 subgoal):\n 1. Q2 \\<le>\\<^sub>L 1\\<^sub>m d", "also"], ["proof (state)\nthis:\n  matrix_sum d (\\<lambda>k. tensor_P (1\\<^sub>m N) (proj_k k)) R =\n  tensor_P (1\\<^sub>m N) (matrix_sum K proj_k R)\n\ngoal (1 subgoal):\n 1. Q2 \\<le>\\<^sub>L 1\\<^sub>m d", "have \"\\<dots> = tensor_P (1\\<^sub>m N) (proj_fst_k R)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tensor_P (1\\<^sub>m N) (matrix_sum K proj_k R) =\n    tensor_P (1\\<^sub>m N) (proj_fst_k R)", "using sum_proj_k K"], ["proof (prove)\nusing this:\n  ?m \\<le> K \\<Longrightarrow> matrix_sum K proj_k ?m = proj_fst_k ?m\n  R < K\n\ngoal (1 subgoal):\n 1. tensor_P (1\\<^sub>m N) (matrix_sum K proj_k R) =\n    tensor_P (1\\<^sub>m N) (proj_fst_k R)", "by auto"], ["proof (state)\nthis:\n  tensor_P (1\\<^sub>m N) (matrix_sum K proj_k R) =\n  tensor_P (1\\<^sub>m N) (proj_fst_k R)\n\ngoal (1 subgoal):\n 1. Q2 \\<le>\\<^sub>L 1\\<^sub>m d", "also"], ["proof (state)\nthis:\n  tensor_P (1\\<^sub>m N) (matrix_sum K proj_k R) =\n  tensor_P (1\\<^sub>m N) (proj_fst_k R)\n\ngoal (1 subgoal):\n 1. Q2 \\<le>\\<^sub>L 1\\<^sub>m d", "have \"\\<dots> \\<le>\\<^sub>L tensor_P (1\\<^sub>m N) (1\\<^sub>m K)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tensor_P (1\\<^sub>m N) (proj_fst_k R) \\<le>\\<^sub>L\n    tensor_P (1\\<^sub>m N) (1\\<^sub>m K)", "unfolding ps2_P.ptensor_mat_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ps_P.tensor_mat (1\\<^sub>m N) (proj_fst_k R) \\<le>\\<^sub>L\n    ps_P.tensor_mat (1\\<^sub>m N) (1\\<^sub>m K)", "apply (subst ps_P.tensor_mat_positive_le)"], ["proof (prove)\ngoal (7 subgoals):\n 1. 1\\<^sub>m N \\<in> carrier_mat ps_P.d1 ps_P.d1\n 2. proj_fst_k R \\<in> carrier_mat ps_P.d2 ps_P.d2\n 3. positive (1\\<^sub>m N)\n 4. positive (proj_fst_k R)\n 5. 1\\<^sub>m N \\<le>\\<^sub>L 1\\<^sub>m N\n 6. proj_fst_k R \\<le>\\<^sub>L 1\\<^sub>m K\n 7. True", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1\\<^sub>m N \\<in> carrier_mat ps_P.d1 ps_P.d1", "using ps_P_d1"], ["proof (prove)\nusing this:\n  ps_P.d1 = N\n\ngoal (1 subgoal):\n 1. 1\\<^sub>m N \\<in> carrier_mat ps_P.d1 ps_P.d1", "by auto"], ["proof (prove)\ngoal (6 subgoals):\n 1. proj_fst_k R \\<in> carrier_mat ps_P.d2 ps_P.d2\n 2. positive (1\\<^sub>m N)\n 3. positive (proj_fst_k R)\n 4. 1\\<^sub>m N \\<le>\\<^sub>L 1\\<^sub>m N\n 5. proj_fst_k R \\<le>\\<^sub>L 1\\<^sub>m K\n 6. True", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. proj_fst_k R \\<in> carrier_mat ps_P.d2 ps_P.d2", "using ps_P_d2 proj_fst_k_def"], ["proof (prove)\nusing this:\n  ps_P.d2 = K\n  proj_fst_k ?k =\n  mat K K (\\<lambda>(i, j). if i = j \\<and> i < ?k then 1 else 0)\n\ngoal (1 subgoal):\n 1. proj_fst_k R \\<in> carrier_mat ps_P.d2 ps_P.d2", "by auto"], ["proof (prove)\ngoal (5 subgoals):\n 1. positive (1\\<^sub>m N)\n 2. positive (proj_fst_k R)\n 3. 1\\<^sub>m N \\<le>\\<^sub>L 1\\<^sub>m N\n 4. proj_fst_k R \\<le>\\<^sub>L 1\\<^sub>m K\n 5. True", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. positive (1\\<^sub>m N)", "using positive_one"], ["proof (prove)\nusing this:\n  positive (1\\<^sub>m ?n)\n\ngoal (1 subgoal):\n 1. positive (1\\<^sub>m N)", "by auto"], ["proof (prove)\ngoal (4 subgoals):\n 1. positive (proj_fst_k R)\n 2. 1\\<^sub>m N \\<le>\\<^sub>L 1\\<^sub>m N\n 3. proj_fst_k R \\<le>\\<^sub>L 1\\<^sub>m K\n 4. True", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. positive (proj_fst_k R)", "using positive_proj_fst_k"], ["proof (prove)\nusing this:\n  positive (proj_fst_k ?k)\n\ngoal (1 subgoal):\n 1. positive (proj_fst_k R)", "by auto"], ["proof (prove)\ngoal (3 subgoals):\n 1. 1\\<^sub>m N \\<le>\\<^sub>L 1\\<^sub>m N\n 2. proj_fst_k R \\<le>\\<^sub>L 1\\<^sub>m K\n 3. True", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1\\<^sub>m N \\<le>\\<^sub>L 1\\<^sub>m N", "using lowner_le_refl[of \"1\\<^sub>m N\" N]"], ["proof (prove)\nusing this:\n  1\\<^sub>m N \\<in> carrier_mat N N \\<Longrightarrow>\n  1\\<^sub>m N \\<le>\\<^sub>L 1\\<^sub>m N\n\ngoal (1 subgoal):\n 1. 1\\<^sub>m N \\<le>\\<^sub>L 1\\<^sub>m N", "by auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. proj_fst_k R \\<le>\\<^sub>L 1\\<^sub>m K\n 2. True", "using proj_fst_k_le_one"], ["proof (prove)\nusing this:\n  proj_fst_k ?k \\<le>\\<^sub>L 1\\<^sub>m K\n\ngoal (2 subgoals):\n 1. proj_fst_k R \\<le>\\<^sub>L 1\\<^sub>m K\n 2. True", "by auto"], ["proof (state)\nthis:\n  tensor_P (1\\<^sub>m N) (proj_fst_k R) \\<le>\\<^sub>L\n  tensor_P (1\\<^sub>m N) (1\\<^sub>m K)\n\ngoal (1 subgoal):\n 1. Q2 \\<le>\\<^sub>L 1\\<^sub>m d", "also"], ["proof (state)\nthis:\n  tensor_P (1\\<^sub>m N) (proj_fst_k R) \\<le>\\<^sub>L\n  tensor_P (1\\<^sub>m N) (1\\<^sub>m K)\n\ngoal (1 subgoal):\n 1. Q2 \\<le>\\<^sub>L 1\\<^sub>m d", "have \"\\<dots> = 1\\<^sub>m d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tensor_P (1\\<^sub>m N) (1\\<^sub>m K) = 1\\<^sub>m d", "unfolding ps2_P.ptensor_mat_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ps_P.tensor_mat (1\\<^sub>m N) (1\\<^sub>m K) = 1\\<^sub>m d", "using ps_P.tensor_mat_id ps_P_d1 ps_P_d2 ps_P_d"], ["proof (prove)\nusing this:\n  ps_P.tensor_mat (1\\<^sub>m ps_P.d1) (1\\<^sub>m ps_P.d2) = 1\\<^sub>m ps_P.d\n  ps_P.d1 = N\n  ps_P.d2 = K\n  ps_P.d = d\n\ngoal (1 subgoal):\n 1. ps_P.tensor_mat (1\\<^sub>m N) (1\\<^sub>m K) = 1\\<^sub>m d", "by auto"], ["proof (state)\nthis:\n  tensor_P (1\\<^sub>m N) (1\\<^sub>m K) = 1\\<^sub>m d\n\ngoal (1 subgoal):\n 1. Q2 \\<le>\\<^sub>L 1\\<^sub>m d", "finally"], ["proof (chain)\npicking this:\n  matrix_sum d (\\<lambda>k. tensor_P (1\\<^sub>m N) (proj_k k))\n   R \\<le>\\<^sub>L\n  1\\<^sub>m d", "have leq2: \"matrix_sum d (\\<lambda>k. tensor_P (1\\<^sub>m N) (proj_k k)) R \\<le>\\<^sub>L 1\\<^sub>m d\""], ["proof (prove)\nusing this:\n  matrix_sum d (\\<lambda>k. tensor_P (1\\<^sub>m N) (proj_k k))\n   R \\<le>\\<^sub>L\n  1\\<^sub>m d\n\ngoal (1 subgoal):\n 1. matrix_sum d (\\<lambda>k. tensor_P (1\\<^sub>m N) (proj_k k))\n     R \\<le>\\<^sub>L\n    1\\<^sub>m d", "by auto"], ["proof (state)\nthis:\n  matrix_sum d (\\<lambda>k. tensor_P (1\\<^sub>m N) (proj_k k))\n   R \\<le>\\<^sub>L\n  1\\<^sub>m d\n\ngoal (1 subgoal):\n 1. Q2 \\<le>\\<^sub>L 1\\<^sub>m d", "have ds: \"matrix_sum d (\\<lambda>k. tensor_P (1\\<^sub>m N) (proj_k k)) R \\<in> carrier_mat d d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_sum d (\\<lambda>k. tensor_P (1\\<^sub>m N) (proj_k k)) R\n    \\<in> carrier_mat d d", "apply (subst matrix_sum_dim)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>k.\n       k < R \\<Longrightarrow>\n       tensor_P (1\\<^sub>m N) (proj_k k) \\<in> carrier_mat d d\n 2. True", "using tensor_P_dim"], ["proof (prove)\nusing this:\n  tensor_P ?A ?B \\<in> carrier_mat d d\n\ngoal (2 subgoals):\n 1. \\<And>k.\n       k < R \\<Longrightarrow>\n       tensor_P (1\\<^sub>m N) (proj_k k) \\<in> carrier_mat d d\n 2. True", "by auto"], ["proof (state)\nthis:\n  matrix_sum d (\\<lambda>k. tensor_P (1\\<^sub>m N) (proj_k k)) R\n  \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. Q2 \\<le>\\<^sub>L 1\\<^sub>m d", "then"], ["proof (chain)\npicking this:\n  matrix_sum d (\\<lambda>k. tensor_P (1\\<^sub>m N) (proj_k k)) R\n  \\<in> carrier_mat d d", "show ?thesis"], ["proof (prove)\nusing this:\n  matrix_sum d (\\<lambda>k. tensor_P (1\\<^sub>m N) (proj_k k)) R\n  \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. Q2 \\<le>\\<^sub>L 1\\<^sub>m d", "using leq leq2 lowner_le_trans[OF Q2_dim ds, of \"1\\<^sub>m d\"]"], ["proof (prove)\nusing this:\n  matrix_sum d (\\<lambda>k. tensor_P (1\\<^sub>m N) (proj_k k)) R\n  \\<in> carrier_mat d d\n  Q2 \\<le>\\<^sub>L\n  matrix_sum d (\\<lambda>k. tensor_P (1\\<^sub>m N) (proj_k k)) R\n  matrix_sum d (\\<lambda>k. tensor_P (1\\<^sub>m N) (proj_k k))\n   R \\<le>\\<^sub>L\n  1\\<^sub>m d\n  \\<lbrakk>1\\<^sub>m d \\<in> carrier_mat d d;\n   Q2 \\<le>\\<^sub>L\n   matrix_sum d (\\<lambda>k. tensor_P (1\\<^sub>m N) (proj_k k)) R;\n   matrix_sum d (\\<lambda>k. tensor_P (1\\<^sub>m N) (proj_k k))\n    R \\<le>\\<^sub>L\n   1\\<^sub>m d\\<rbrakk>\n  \\<Longrightarrow> Q2 \\<le>\\<^sub>L 1\\<^sub>m d\n\ngoal (1 subgoal):\n 1. Q2 \\<le>\\<^sub>L 1\\<^sub>m d", "by auto"], ["proof (state)\nthis:\n  Q2 \\<le>\\<^sub>L 1\\<^sub>m d\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma qp_Q2:\n  \"is_quantum_predicate Q2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_quantum_predicate Q2", "unfolding is_quantum_predicate_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Q2 \\<in> carrier_mat d d \\<and>\n    positive Q2 \\<and> Q2 \\<le>\\<^sub>L 1\\<^sub>m d", "proof (intro conjI)"], ["proof (state)\ngoal (3 subgoals):\n 1. Q2 \\<in> carrier_mat d d\n 2. positive Q2\n 3. Q2 \\<le>\\<^sub>L 1\\<^sub>m d", "show \"Q2 \\<in> carrier_mat d d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Q2 \\<in> carrier_mat d d", "unfolding Q2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_sum d (\\<lambda>l. tensor_P (proj_psi_l (l + 1)) (proj_k l)) R\n    \\<in> carrier_mat d d", "apply (subst matrix_sum_dim)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>k.\n       k < R \\<Longrightarrow>\n       tensor_P (proj_psi_l (k + 1)) (proj_k k) \\<in> carrier_mat d d\n 2. True", "using tensor_P_dim"], ["proof (prove)\nusing this:\n  tensor_P ?A ?B \\<in> carrier_mat d d\n\ngoal (2 subgoals):\n 1. \\<And>k.\n       k < R \\<Longrightarrow>\n       tensor_P (proj_psi_l (k + 1)) (proj_k k) \\<in> carrier_mat d d\n 2. True", "by auto"], ["proof (state)\nthis:\n  Q2 \\<in> carrier_mat d d\n\ngoal (2 subgoals):\n 1. positive Q2\n 2. Q2 \\<le>\\<^sub>L 1\\<^sub>m d", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. positive Q2\n 2. Q2 \\<le>\\<^sub>L 1\\<^sub>m d", "show \"positive Q2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. positive Q2", "unfolding Q2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. positive\n     (matrix_sum d (\\<lambda>l. tensor_P (proj_psi_l (l + 1)) (proj_k l)) R)", "apply (subst matrix_sum_positive)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>k.\n       k < R \\<Longrightarrow>\n       tensor_P (proj_psi_l (k + 1)) (proj_k k) \\<in> carrier_mat d d\n 2. \\<And>k.\n       k < R \\<Longrightarrow>\n       positive (tensor_P (proj_psi_l (k + 1)) (proj_k k))\n 3. True", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. k_ < R \\<Longrightarrow>\n    tensor_P (proj_psi_l (k_ + 1)) (proj_k k_) \\<in> carrier_mat d d", "using tensor_P_dim"], ["proof (prove)\nusing this:\n  tensor_P ?A ?B \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. k_ < R \\<Longrightarrow>\n    tensor_P (proj_psi_l (k_ + 1)) (proj_k k_) \\<in> carrier_mat d d", "by auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>k.\n       k < R \\<Longrightarrow>\n       positive (tensor_P (proj_psi_l (k + 1)) (proj_k k))\n 2. True", "subgoal for k"], ["proof (prove)\ngoal (1 subgoal):\n 1. k < R \\<Longrightarrow>\n    positive (tensor_P (proj_psi_l (k + 1)) (proj_k k))", "unfolding ps2_P.ptensor_mat_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. k < R \\<Longrightarrow>\n    positive (ps_P.tensor_mat (proj_psi_l (k + 1)) (proj_k k))", "apply (subst ps_P.tensor_mat_positive)"], ["proof (prove)\ngoal (5 subgoals):\n 1. k < R \\<Longrightarrow>\n    proj_psi_l (k + 1) \\<in> carrier_mat ps_P.d1 ps_P.d1\n 2. k < R \\<Longrightarrow> proj_k k \\<in> carrier_mat ps_P.d2 ps_P.d2\n 3. k < R \\<Longrightarrow> positive (proj_psi_l (k + 1))\n 4. k < R \\<Longrightarrow> positive (proj_k k)\n 5. k < R \\<Longrightarrow> True", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. k < R \\<Longrightarrow>\n    proj_psi_l (k + 1) \\<in> carrier_mat ps_P.d1 ps_P.d1", "using proj_psi_l_def psi_l_dim ps_P_d1"], ["proof (prove)\nusing this:\n  proj_psi_l ?l = outer_prod (psi_l ?l) (psi_l ?l)\n  psi_l ?l \\<in> carrier_vec N\n  ps_P.d1 = N\n\ngoal (1 subgoal):\n 1. k < R \\<Longrightarrow>\n    proj_psi_l (k + 1) \\<in> carrier_mat ps_P.d1 ps_P.d1", "by auto"], ["proof (prove)\ngoal (4 subgoals):\n 1. k < R \\<Longrightarrow> proj_k k \\<in> carrier_mat ps_P.d2 ps_P.d2\n 2. k < R \\<Longrightarrow> positive (proj_psi_l (k + 1))\n 3. k < R \\<Longrightarrow> positive (proj_k k)\n 4. k < R \\<Longrightarrow> True", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. k < R \\<Longrightarrow> proj_k k \\<in> carrier_mat ps_P.d2 ps_P.d2", "using proj_k_dim ps_P_d2 K"], ["proof (prove)\nusing this:\n  proj_k ?k \\<in> carrier_mat K K\n  ps_P.d2 = K\n  R < K\n\ngoal (1 subgoal):\n 1. k < R \\<Longrightarrow> proj_k k \\<in> carrier_mat ps_P.d2 ps_P.d2", "by auto"], ["proof (prove)\ngoal (3 subgoals):\n 1. k < R \\<Longrightarrow> positive (proj_psi_l (k + 1))\n 2. k < R \\<Longrightarrow> positive (proj_k k)\n 3. k < R \\<Longrightarrow> True", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. k < R \\<Longrightarrow> positive (proj_psi_l (k + 1))", "using positive_proj_psi_l"], ["proof (prove)\nusing this:\n  positive (proj_psi_l ?l)\n\ngoal (1 subgoal):\n 1. k < R \\<Longrightarrow> positive (proj_psi_l (k + 1))", "by auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. k < R \\<Longrightarrow> positive (proj_k k)\n 2. k < R \\<Longrightarrow> True", "using positive_proj_k K"], ["proof (prove)\nusing this:\n  positive (proj_k ?k)\n  R < K\n\ngoal (2 subgoals):\n 1. k < R \\<Longrightarrow> positive (proj_k k)\n 2. k < R \\<Longrightarrow> True", "by auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. True", "by auto"], ["proof (state)\nthis:\n  positive Q2\n\ngoal (1 subgoal):\n 1. Q2 \\<le>\\<^sub>L 1\\<^sub>m d", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. Q2 \\<le>\\<^sub>L 1\\<^sub>m d", "show \"Q2 \\<le>\\<^sub>L 1\\<^sub>m d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Q2 \\<le>\\<^sub>L 1\\<^sub>m d", "using Q2_le_one"], ["proof (prove)\nusing this:\n  Q2 \\<le>\\<^sub>L 1\\<^sub>m d\n\ngoal (1 subgoal):\n 1. Q2 \\<le>\\<^sub>L 1\\<^sub>m d", "by auto"], ["proof (state)\nthis:\n  Q2 \\<le>\\<^sub>L 1\\<^sub>m d\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma pre_mat:\n  \"pre = mat N N (\\<lambda>(i, j). if i = j \\<and> i = 0 then 1 else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pre = mat N N (\\<lambda>(i, j). if i = j \\<and> i = 0 then 1 else 0)", "apply (rule eq_matI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row\n                     (mat N N\n                       (\\<lambda>(i, j).\n                           if i = j \\<and> i = 0 then 1 else 0));\n        j < dim_col\n             (mat N N\n               (\\<lambda>(i, j).\n                   if i = j \\<and> i = 0 then 1 else 0))\\<rbrakk>\n       \\<Longrightarrow> pre $$ (i, j) =\n                         mat N N\n                          (\\<lambda>(i, j).\n                              if i = j \\<and> i = 0 then 1 else 0) $$\n                         (i, j)\n 2. dim_row pre =\n    dim_row (mat N N (\\<lambda>(i, j). if i = j \\<and> i = 0 then 1 else 0))\n 3. dim_col pre =\n    dim_col (mat N N (\\<lambda>(i, j). if i = j \\<and> i = 0 then 1 else 0))", "subgoal for i j"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < dim_row\n                  (mat N N\n                    (\\<lambda>(i, j). if i = j \\<and> i = 0 then 1 else 0));\n     j < dim_col\n          (mat N N\n            (\\<lambda>(i, j). if i = j \\<and> i = 0 then 1 else 0))\\<rbrakk>\n    \\<Longrightarrow> pre $$ (i, j) =\n                      mat N N\n                       (\\<lambda>(i, j).\n                           if i = j \\<and> i = 0 then 1 else 0) $$\n                      (i, j)", "unfolding pre_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < dim_row\n                  (mat N N\n                    (\\<lambda>(i, j). if i = j \\<and> i = 0 then 1 else 0));\n     j < dim_col\n          (mat N N\n            (\\<lambda>(i, j). if i = j \\<and> i = 0 then 1 else 0))\\<rbrakk>\n    \\<Longrightarrow> outer_prod ket_pre ket_pre $$ (i, j) =\n                      mat N N\n                       (\\<lambda>(i, j).\n                           if i = j \\<and> i = 0 then 1 else 0) $$\n                      (i, j)", "apply (subst index_outer_prod[OF ket_pre_dim ket_pre_dim])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>i < dim_row\n                  (mat N N\n                    (\\<lambda>(i, j). if i = j \\<and> i = 0 then 1 else 0));\n     j < dim_col\n          (mat N N\n            (\\<lambda>(i, j). if i = j \\<and> i = 0 then 1 else 0))\\<rbrakk>\n    \\<Longrightarrow> i < N\n 2. \\<lbrakk>i < dim_row\n                  (mat N N\n                    (\\<lambda>(i, j). if i = j \\<and> i = 0 then 1 else 0));\n     j < dim_col\n          (mat N N\n            (\\<lambda>(i, j). if i = j \\<and> i = 0 then 1 else 0))\\<rbrakk>\n    \\<Longrightarrow> j < N\n 3. \\<lbrakk>i < dim_row\n                  (mat N N\n                    (\\<lambda>(i, j). if i = j \\<and> i = 0 then 1 else 0));\n     j < dim_col\n          (mat N N\n            (\\<lambda>(i, j). if i = j \\<and> i = 0 then 1 else 0))\\<rbrakk>\n    \\<Longrightarrow> ket_pre $ i * conjugate (ket_pre $ j) =\n                      mat N N\n                       (\\<lambda>(i, j).\n                           if i = j \\<and> i = 0 then 1 else 0) $$\n                      (i, j)", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < N; j < N\\<rbrakk>\n    \\<Longrightarrow> (i = j \\<and> i = 0 \\<longrightarrow>\n                       ket_pre $ j * cnj (ket_pre $ j) = 1) \\<and>\n                      ((i = j \\<longrightarrow> 0 < j) \\<longrightarrow>\n                       ket_pre $ i = 0 \\<or> ket_pre $ j = 0)", "unfolding ket_pre_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < N; j < N\\<rbrakk>\n    \\<Longrightarrow> (i = j \\<and> i = 0 \\<longrightarrow>\n                       Matrix.vec N (\\<lambda>k. if k = 0 then 1 else 0) $\n                       j *\n                       cnj (Matrix.vec N\n                             (\\<lambda>k. if k = 0 then 1 else 0) $\n                            j) =\n                       1) \\<and>\n                      ((i = j \\<longrightarrow> 0 < j) \\<longrightarrow>\n                       Matrix.vec N (\\<lambda>k. if k = 0 then 1 else 0) $\n                       i =\n                       0 \\<or>\n                       Matrix.vec N (\\<lambda>k. if k = 0 then 1 else 0) $\n                       j =\n                       0)", "by auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. dim_row pre =\n    dim_row (mat N N (\\<lambda>(i, j). if i = j \\<and> i = 0 then 1 else 0))\n 2. dim_col pre =\n    dim_col (mat N N (\\<lambda>(i, j). if i = j \\<and> i = 0 then 1 else 0))", "using outer_prod_dim[OF ket_pre_dim ket_pre_dim, folded pre_def]"], ["proof (prove)\nusing this:\n  pre \\<in> carrier_mat N N\n\ngoal (2 subgoals):\n 1. dim_row pre =\n    dim_row (mat N N (\\<lambda>(i, j). if i = j \\<and> i = 0 then 1 else 0))\n 2. dim_col pre =\n    dim_col (mat N N (\\<lambda>(i, j). if i = j \\<and> i = 0 then 1 else 0))", "by auto"], ["", "lemma mat_Ph_split:\n  \"mat_Ph = 2 \\<cdot>\\<^sub>m pre - 1\\<^sub>m N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_Ph = 2 \\<cdot>\\<^sub>m pre - 1\\<^sub>m N", "unfolding mat_Ph_def pre_mat"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat N N\n     (\\<lambda>(i, j). if i = j then if i = 0 then 1 else - 1 else 0) =\n    2 \\<cdot>\\<^sub>m\n    mat N N (\\<lambda>(i, j). if i = j \\<and> i = 0 then 1 else 0) -\n    1\\<^sub>m N", "apply (rule eq_matI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row\n                     (2 \\<cdot>\\<^sub>m\n                      mat N N\n                       (\\<lambda>(i, j).\n                           if i = j \\<and> i = 0 then 1 else 0) -\n                      1\\<^sub>m N);\n        j < dim_col\n             (2 \\<cdot>\\<^sub>m\n              mat N N\n               (\\<lambda>(i, j). if i = j \\<and> i = 0 then 1 else 0) -\n              1\\<^sub>m N)\\<rbrakk>\n       \\<Longrightarrow> mat N N\n                          (\\<lambda>(i, j).\n                              if i = j then if i = 0 then 1 else - 1\n                              else 0) $$\n                         (i, j) =\n                         (2 \\<cdot>\\<^sub>m\n                          mat N N\n                           (\\<lambda>(i, j).\n                               if i = j \\<and> i = 0 then 1 else 0) -\n                          1\\<^sub>m N) $$\n                         (i, j)\n 2. dim_row\n     (mat N N\n       (\\<lambda>(i, j). if i = j then if i = 0 then 1 else - 1 else 0)) =\n    dim_row\n     (2 \\<cdot>\\<^sub>m\n      mat N N (\\<lambda>(i, j). if i = j \\<and> i = 0 then 1 else 0) -\n      1\\<^sub>m N)\n 3. dim_col\n     (mat N N\n       (\\<lambda>(i, j). if i = j then if i = 0 then 1 else - 1 else 0)) =\n    dim_col\n     (2 \\<cdot>\\<^sub>m\n      mat N N (\\<lambda>(i, j). if i = j \\<and> i = 0 then 1 else 0) -\n      1\\<^sub>m N)", "by auto"], ["", "lemma H_Ph_H:\n  \"exexH_k (n-1) * tensor_P mat_Ph (1\\<^sub>m K) * exexH_k (n - 1) = 2 \\<cdot>\\<^sub>m tensor_P proj_psi (1\\<^sub>m K) - 1\\<^sub>m d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exexH_k (n - 1) * tensor_P mat_Ph (1\\<^sub>m K) * exexH_k (n - 1) =\n    2 \\<cdot>\\<^sub>m tensor_P proj_psi (1\\<^sub>m K) - 1\\<^sub>m d", "unfolding mat_Ph_split exexH_k.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. tensor_P exH_n (1\\<^sub>m K) *\n    tensor_P (2 \\<cdot>\\<^sub>m pre - 1\\<^sub>m N) (1\\<^sub>m K) *\n    tensor_P exH_n (1\\<^sub>m K) =\n    2 \\<cdot>\\<^sub>m tensor_P proj_psi (1\\<^sub>m K) - 1\\<^sub>m d", "apply (subst tensor_P_left_right_partial1)"], ["proof (prove)\ngoal (4 subgoals):\n 1. exH_n \\<in> carrier_mat N N\n 2. 2 \\<cdot>\\<^sub>m pre - 1\\<^sub>m N \\<in> carrier_mat N N\n 3. 1\\<^sub>m K \\<in> carrier_mat K K\n 4. tensor_P (exH_n * (2 \\<cdot>\\<^sub>m pre - 1\\<^sub>m N) * exH_n)\n     (1\\<^sub>m K) =\n    2 \\<cdot>\\<^sub>m tensor_P proj_psi (1\\<^sub>m K) - 1\\<^sub>m d", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. exH_n \\<in> carrier_mat N N", "using exH_k_dim[of \"n - 1\"] n"], ["proof (prove)\nusing this:\n  n - 1 < n \\<Longrightarrow> exH_n \\<in> carrier_mat N N\n  1 < n\n\ngoal (1 subgoal):\n 1. exH_n \\<in> carrier_mat N N", "by auto"], ["proof (prove)\ngoal (3 subgoals):\n 1. 2 \\<cdot>\\<^sub>m pre - 1\\<^sub>m N \\<in> carrier_mat N N\n 2. 1\\<^sub>m K \\<in> carrier_mat K K\n 3. tensor_P (exH_n * (2 \\<cdot>\\<^sub>m pre - 1\\<^sub>m N) * exH_n)\n     (1\\<^sub>m K) =\n    2 \\<cdot>\\<^sub>m tensor_P proj_psi (1\\<^sub>m K) - 1\\<^sub>m d", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 \\<cdot>\\<^sub>m pre - 1\\<^sub>m N \\<in> carrier_mat N N", "using pre_dim"], ["proof (prove)\nusing this:\n  pre \\<in> carrier_mat N N\n\ngoal (1 subgoal):\n 1. 2 \\<cdot>\\<^sub>m pre - 1\\<^sub>m N \\<in> carrier_mat N N", "by auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. 1\\<^sub>m K \\<in> carrier_mat K K\n 2. tensor_P (exH_n * (2 \\<cdot>\\<^sub>m pre - 1\\<^sub>m N) * exH_n)\n     (1\\<^sub>m K) =\n    2 \\<cdot>\\<^sub>m tensor_P proj_psi (1\\<^sub>m K) - 1\\<^sub>m d", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1\\<^sub>m K \\<in> carrier_mat K K", "by auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. tensor_P (exH_n * (2 \\<cdot>\\<^sub>m pre - 1\\<^sub>m N) * exH_n)\n     (1\\<^sub>m K) =\n    2 \\<cdot>\\<^sub>m tensor_P proj_psi (1\\<^sub>m K) - 1\\<^sub>m d", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. tensor_P (exH_n * (2 \\<cdot>\\<^sub>m pre - 1\\<^sub>m N) * exH_n)\n     (1\\<^sub>m K) =\n    2 \\<cdot>\\<^sub>m tensor_P proj_psi (1\\<^sub>m K) - 1\\<^sub>m d", "have eq1: \"exH_n * exH_n = 1\\<^sub>m N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exH_n * exH_n = 1\\<^sub>m N", "using unitary_exH_k[of \"n - 1\"]"], ["proof (prove)\nusing this:\n  n - 1 < n \\<Longrightarrow> unitary exH_n\n\ngoal (1 subgoal):\n 1. exH_n * exH_n = 1\\<^sub>m N", "unfolding unitary_def inverts_mat_def"], ["proof (prove)\nusing this:\n  n - 1 < n \\<Longrightarrow>\n  exH_n \\<in> carrier_mat (dim_row exH_n) (dim_row exH_n) \\<and>\n  exH_n * adjoint exH_n = 1\\<^sub>m (dim_row exH_n)\n\ngoal (1 subgoal):\n 1. exH_n * exH_n = 1\\<^sub>m N", "using n hermitian_exH_n[simplified hermitian_def] exH_n_dim"], ["proof (prove)\nusing this:\n  n - 1 < n \\<Longrightarrow>\n  exH_n \\<in> carrier_mat (dim_row exH_n) (dim_row exH_n) \\<and>\n  exH_n * adjoint exH_n = 1\\<^sub>m (dim_row exH_n)\n  1 < n\n  adjoint exH_n = exH_n\n  exH_n \\<in> carrier_mat N N\n\ngoal (1 subgoal):\n 1. exH_n * exH_n = 1\\<^sub>m N", "by auto"], ["proof (state)\nthis:\n  exH_n * exH_n = 1\\<^sub>m N\n\ngoal (1 subgoal):\n 1. tensor_P (exH_n * (2 \\<cdot>\\<^sub>m pre - 1\\<^sub>m N) * exH_n)\n     (1\\<^sub>m K) =\n    2 \\<cdot>\\<^sub>m tensor_P proj_psi (1\\<^sub>m K) - 1\\<^sub>m d", "have eq2: \"exH_n * pre * exH_n = proj_psi\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exH_n * pre * exH_n = proj_psi", "unfolding pre_def proj_psi_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. exH_n * outer_prod ket_pre ket_pre * exH_n = outer_prod \\<psi> \\<psi>", "apply (subst outer_prod_left_right_mat[of _ N _ N _ N _ N])"], ["proof (prove)\ngoal (3 subgoals):\n 1. ket_pre \\<in> carrier_vec N\n 2. exH_n \\<in> carrier_mat N N\n 3. outer_prod (exH_n *\\<^sub>v ket_pre) (adjoint exH_n *\\<^sub>v ket_pre) =\n    outer_prod \\<psi> \\<psi>", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. ket_pre \\<in> carrier_vec N", "using ket_pre_dim"], ["proof (prove)\nusing this:\n  ket_pre \\<in> carrier_vec N\n\ngoal (1 subgoal):\n 1. ket_pre \\<in> carrier_vec N", "by auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. exH_n \\<in> carrier_mat N N\n 2. outer_prod (exH_n *\\<^sub>v ket_pre) (adjoint exH_n *\\<^sub>v ket_pre) =\n    outer_prod \\<psi> \\<psi>", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. exH_n \\<in> carrier_mat N N", "using exH_n_dim"], ["proof (prove)\nusing this:\n  exH_n \\<in> carrier_mat N N\n\ngoal (1 subgoal):\n 1. exH_n \\<in> carrier_mat N N", "by auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. outer_prod (exH_n *\\<^sub>v ket_pre) (adjoint exH_n *\\<^sub>v ket_pre) =\n    outer_prod \\<psi> \\<psi>", "apply (subst hermitian_exH_n[simplified hermitian_def])"], ["proof (prove)\ngoal (1 subgoal):\n 1. outer_prod (exH_n *\\<^sub>v ket_pre) (exH_n *\\<^sub>v ket_pre) =\n    outer_prod \\<psi> \\<psi>", "using exH_k_mult_pre_is_psi"], ["proof (prove)\nusing this:\n  exH_n *\\<^sub>v ket_pre = \\<psi>\n\ngoal (1 subgoal):\n 1. outer_prod (exH_n *\\<^sub>v ket_pre) (exH_n *\\<^sub>v ket_pre) =\n    outer_prod \\<psi> \\<psi>", "by auto"], ["proof (state)\nthis:\n  exH_n * pre * exH_n = proj_psi\n\ngoal (1 subgoal):\n 1. tensor_P (exH_n * (2 \\<cdot>\\<^sub>m pre - 1\\<^sub>m N) * exH_n)\n     (1\\<^sub>m K) =\n    2 \\<cdot>\\<^sub>m tensor_P proj_psi (1\\<^sub>m K) - 1\\<^sub>m d", "have eq3: \"exH_n * (2 \\<cdot>\\<^sub>m pre) * exH_n = 2 \\<cdot>\\<^sub>m (exH_n * pre * exH_n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exH_n * (2 \\<cdot>\\<^sub>m pre) * exH_n =\n    2 \\<cdot>\\<^sub>m (exH_n * pre * exH_n)", "using pre_dim exH_n_dim"], ["proof (prove)\nusing this:\n  pre \\<in> carrier_mat N N\n  exH_n \\<in> carrier_mat N N\n\ngoal (1 subgoal):\n 1. exH_n * (2 \\<cdot>\\<^sub>m pre) * exH_n =\n    2 \\<cdot>\\<^sub>m (exH_n * pre * exH_n)", "by (mat_assoc N)"], ["proof (state)\nthis:\n  exH_n * (2 \\<cdot>\\<^sub>m pre) * exH_n =\n  2 \\<cdot>\\<^sub>m (exH_n * pre * exH_n)\n\ngoal (1 subgoal):\n 1. tensor_P (exH_n * (2 \\<cdot>\\<^sub>m pre - 1\\<^sub>m N) * exH_n)\n     (1\\<^sub>m K) =\n    2 \\<cdot>\\<^sub>m tensor_P proj_psi (1\\<^sub>m K) - 1\\<^sub>m d", "have \"exH_n * (2 \\<cdot>\\<^sub>m pre - 1\\<^sub>m N) * exH_n = exH_n * (2 \\<cdot>\\<^sub>m pre) * exH_n - exH_n * exH_n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exH_n * (2 \\<cdot>\\<^sub>m pre - 1\\<^sub>m N) * exH_n =\n    exH_n * (2 \\<cdot>\\<^sub>m pre) * exH_n - exH_n * exH_n", "using pre_dim exH_n_dim"], ["proof (prove)\nusing this:\n  pre \\<in> carrier_mat N N\n  exH_n \\<in> carrier_mat N N\n\ngoal (1 subgoal):\n 1. exH_n * (2 \\<cdot>\\<^sub>m pre - 1\\<^sub>m N) * exH_n =\n    exH_n * (2 \\<cdot>\\<^sub>m pre) * exH_n - exH_n * exH_n", "apply (mat_assoc N)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1\\<^sub>m N \\<in> carrier_mat N N", "by auto"], ["proof (state)\nthis:\n  exH_n * (2 \\<cdot>\\<^sub>m pre - 1\\<^sub>m N) * exH_n =\n  exH_n * (2 \\<cdot>\\<^sub>m pre) * exH_n - exH_n * exH_n\n\ngoal (1 subgoal):\n 1. tensor_P (exH_n * (2 \\<cdot>\\<^sub>m pre - 1\\<^sub>m N) * exH_n)\n     (1\\<^sub>m K) =\n    2 \\<cdot>\\<^sub>m tensor_P proj_psi (1\\<^sub>m K) - 1\\<^sub>m d", "also"], ["proof (state)\nthis:\n  exH_n * (2 \\<cdot>\\<^sub>m pre - 1\\<^sub>m N) * exH_n =\n  exH_n * (2 \\<cdot>\\<^sub>m pre) * exH_n - exH_n * exH_n\n\ngoal (1 subgoal):\n 1. tensor_P (exH_n * (2 \\<cdot>\\<^sub>m pre - 1\\<^sub>m N) * exH_n)\n     (1\\<^sub>m K) =\n    2 \\<cdot>\\<^sub>m tensor_P proj_psi (1\\<^sub>m K) - 1\\<^sub>m d", "have \"\\<dots> = 2 \\<cdot>\\<^sub>m (exH_n * pre * exH_n) - 1\\<^sub>m N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exH_n * (2 \\<cdot>\\<^sub>m pre) * exH_n - exH_n * exH_n =\n    2 \\<cdot>\\<^sub>m (exH_n * pre * exH_n) - 1\\<^sub>m N", "using eq1 eq3"], ["proof (prove)\nusing this:\n  exH_n * exH_n = 1\\<^sub>m N\n  exH_n * (2 \\<cdot>\\<^sub>m pre) * exH_n =\n  2 \\<cdot>\\<^sub>m (exH_n * pre * exH_n)\n\ngoal (1 subgoal):\n 1. exH_n * (2 \\<cdot>\\<^sub>m pre) * exH_n - exH_n * exH_n =\n    2 \\<cdot>\\<^sub>m (exH_n * pre * exH_n) - 1\\<^sub>m N", "by auto"], ["proof (state)\nthis:\n  exH_n * (2 \\<cdot>\\<^sub>m pre) * exH_n - exH_n * exH_n =\n  2 \\<cdot>\\<^sub>m (exH_n * pre * exH_n) - 1\\<^sub>m N\n\ngoal (1 subgoal):\n 1. tensor_P (exH_n * (2 \\<cdot>\\<^sub>m pre - 1\\<^sub>m N) * exH_n)\n     (1\\<^sub>m K) =\n    2 \\<cdot>\\<^sub>m tensor_P proj_psi (1\\<^sub>m K) - 1\\<^sub>m d", "finally"], ["proof (chain)\npicking this:\n  exH_n * (2 \\<cdot>\\<^sub>m pre - 1\\<^sub>m N) * exH_n =\n  2 \\<cdot>\\<^sub>m (exH_n * pre * exH_n) - 1\\<^sub>m N", "have eq4: \"exH_n * (2 \\<cdot>\\<^sub>m pre - 1\\<^sub>m N) * exH_n = 2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N\""], ["proof (prove)\nusing this:\n  exH_n * (2 \\<cdot>\\<^sub>m pre - 1\\<^sub>m N) * exH_n =\n  2 \\<cdot>\\<^sub>m (exH_n * pre * exH_n) - 1\\<^sub>m N\n\ngoal (1 subgoal):\n 1. exH_n * (2 \\<cdot>\\<^sub>m pre - 1\\<^sub>m N) * exH_n =\n    2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N", "using eq2"], ["proof (prove)\nusing this:\n  exH_n * (2 \\<cdot>\\<^sub>m pre - 1\\<^sub>m N) * exH_n =\n  2 \\<cdot>\\<^sub>m (exH_n * pre * exH_n) - 1\\<^sub>m N\n  exH_n * pre * exH_n = proj_psi\n\ngoal (1 subgoal):\n 1. exH_n * (2 \\<cdot>\\<^sub>m pre - 1\\<^sub>m N) * exH_n =\n    2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N", "by auto"], ["proof (state)\nthis:\n  exH_n * (2 \\<cdot>\\<^sub>m pre - 1\\<^sub>m N) * exH_n =\n  2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N\n\ngoal (1 subgoal):\n 1. tensor_P (exH_n * (2 \\<cdot>\\<^sub>m pre - 1\\<^sub>m N) * exH_n)\n     (1\\<^sub>m K) =\n    2 \\<cdot>\\<^sub>m tensor_P proj_psi (1\\<^sub>m K) - 1\\<^sub>m d", "show \"tensor_P (exH_n * (2 \\<cdot>\\<^sub>m pre - 1\\<^sub>m N) * exH_n) (1\\<^sub>m K) = 2 \\<cdot>\\<^sub>m tensor_P proj_psi (1\\<^sub>m K) - 1\\<^sub>m d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tensor_P (exH_n * (2 \\<cdot>\\<^sub>m pre - 1\\<^sub>m N) * exH_n)\n     (1\\<^sub>m K) =\n    2 \\<cdot>\\<^sub>m tensor_P proj_psi (1\\<^sub>m K) - 1\\<^sub>m d", "unfolding eq4"], ["proof (prove)\ngoal (1 subgoal):\n 1. tensor_P (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) (1\\<^sub>m K) =\n    2 \\<cdot>\\<^sub>m tensor_P proj_psi (1\\<^sub>m K) - 1\\<^sub>m d", "unfolding ps2_P.ptensor_mat_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ps_P.tensor_mat (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N)\n     (1\\<^sub>m K) =\n    2 \\<cdot>\\<^sub>m ps_P.tensor_mat proj_psi (1\\<^sub>m K) - 1\\<^sub>m d", "apply (subst ps_P.tensor_mat_minus1)"], ["proof (prove)\ngoal (4 subgoals):\n 1. 2 \\<cdot>\\<^sub>m proj_psi \\<in> carrier_mat ps_P.d1 ps_P.d1\n 2. 1\\<^sub>m N \\<in> carrier_mat ps_P.d1 ps_P.d1\n 3. 1\\<^sub>m K \\<in> carrier_mat ps_P.d2 ps_P.d2\n 4. ps_P.tensor_mat (2 \\<cdot>\\<^sub>m proj_psi) (1\\<^sub>m K) -\n    ps_P.tensor_mat (1\\<^sub>m N) (1\\<^sub>m K) =\n    2 \\<cdot>\\<^sub>m ps_P.tensor_mat proj_psi (1\\<^sub>m K) - 1\\<^sub>m d", "unfolding ps_P_d1 ps_P_d2"], ["proof (prove)\ngoal (4 subgoals):\n 1. 2 \\<cdot>\\<^sub>m proj_psi \\<in> carrier_mat N N\n 2. 1\\<^sub>m N \\<in> carrier_mat N N\n 3. 1\\<^sub>m K \\<in> carrier_mat K K\n 4. ps_P.tensor_mat (2 \\<cdot>\\<^sub>m proj_psi) (1\\<^sub>m K) -\n    ps_P.tensor_mat (1\\<^sub>m N) (1\\<^sub>m K) =\n    2 \\<cdot>\\<^sub>m ps_P.tensor_mat proj_psi (1\\<^sub>m K) - 1\\<^sub>m d", "apply (auto simp add: proj_psi_dim)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ps_P.tensor_mat (2 \\<cdot>\\<^sub>m proj_psi) (1\\<^sub>m K) -\n    ps_P.tensor_mat (1\\<^sub>m N) (1\\<^sub>m K) =\n    2 \\<cdot>\\<^sub>m ps_P.tensor_mat proj_psi (1\\<^sub>m K) - 1\\<^sub>m d", "apply (subst ps_P.tensor_mat_scale1)"], ["proof (prove)\ngoal (3 subgoals):\n 1. proj_psi \\<in> carrier_mat ps_P.d1 ps_P.d1\n 2. 1\\<^sub>m K \\<in> carrier_mat ps_P.d2 ps_P.d2\n 3. 2 \\<cdot>\\<^sub>m ps_P.tensor_mat proj_psi (1\\<^sub>m K) -\n    ps_P.tensor_mat (1\\<^sub>m N) (1\\<^sub>m K) =\n    2 \\<cdot>\\<^sub>m ps_P.tensor_mat proj_psi (1\\<^sub>m K) - 1\\<^sub>m d", "unfolding ps_P_d1 ps_P_d2"], ["proof (prove)\ngoal (3 subgoals):\n 1. proj_psi \\<in> carrier_mat N N\n 2. 1\\<^sub>m K \\<in> carrier_mat K K\n 3. 2 \\<cdot>\\<^sub>m ps_P.tensor_mat proj_psi (1\\<^sub>m K) -\n    ps_P.tensor_mat (1\\<^sub>m N) (1\\<^sub>m K) =\n    2 \\<cdot>\\<^sub>m ps_P.tensor_mat proj_psi (1\\<^sub>m K) - 1\\<^sub>m d", "apply (auto simp add: proj_psi_dim)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 \\<cdot>\\<^sub>m ps_P.tensor_mat proj_psi (1\\<^sub>m K) -\n    ps_P.tensor_mat (1\\<^sub>m N) (1\\<^sub>m K) =\n    2 \\<cdot>\\<^sub>m ps_P.tensor_mat proj_psi (1\\<^sub>m K) - 1\\<^sub>m d", "apply (subst ps_P.tensor_mat_id[simplified ps_P_d1 ps_P_d2 ps_P_d])"], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 \\<cdot>\\<^sub>m ps_P.tensor_mat proj_psi (1\\<^sub>m K) - 1\\<^sub>m d =\n    2 \\<cdot>\\<^sub>m ps_P.tensor_mat proj_psi (1\\<^sub>m K) - 1\\<^sub>m d", "by auto"], ["proof (state)\nthis:\n  tensor_P (exH_n * (2 \\<cdot>\\<^sub>m pre - 1\\<^sub>m N) * exH_n)\n   (1\\<^sub>m K) =\n  2 \\<cdot>\\<^sub>m tensor_P proj_psi (1\\<^sub>m K) - 1\\<^sub>m d\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma hermitian_proj_psi_minus_1:\n  \"hermitian (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hermitian (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N)", "unfolding hermitian_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. adjoint (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) =\n    2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N", "apply (subst adjoint_minus[of _ N N])"], ["proof (prove)\ngoal (3 subgoals):\n 1. 2 \\<cdot>\\<^sub>m proj_psi \\<in> carrier_mat N N\n 2. 1\\<^sub>m N \\<in> carrier_mat N N\n 3. adjoint (2 \\<cdot>\\<^sub>m proj_psi) - adjoint (1\\<^sub>m N) =\n    2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N", "apply (auto simp add: proj_psi_dim)"], ["proof (prove)\ngoal (1 subgoal):\n 1. adjoint (2 \\<cdot>\\<^sub>m proj_psi) - adjoint (1\\<^sub>m N) =\n    2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N", "apply (subst adjoint_scale)"], ["proof (prove)\ngoal (1 subgoal):\n 1. conjugate 2 \\<cdot>\\<^sub>m adjoint proj_psi - adjoint (1\\<^sub>m N) =\n    2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N", "using hermitian_proj_psi[simplified hermitian_def] hermitian_def adjoint_one"], ["proof (prove)\nusing this:\n  adjoint proj_psi = proj_psi\n  hermitian ?A = (adjoint ?A = ?A)\n  adjoint (1\\<^sub>m ?n) = 1\\<^sub>m ?n\n\ngoal (1 subgoal):\n 1. conjugate 2 \\<cdot>\\<^sub>m adjoint proj_psi - adjoint (1\\<^sub>m N) =\n    2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N", "by auto"], ["", "lemma unitary_proj_psi_minus_1:\n  \"unitary (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unitary (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. unitary (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N)", "have a: \"adjoint (2 \\<cdot>\\<^sub>m proj_psi) = 2 \\<cdot>\\<^sub>m proj_psi\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adjoint (2 \\<cdot>\\<^sub>m proj_psi) = 2 \\<cdot>\\<^sub>m proj_psi", "apply (subst adjoint_scale)"], ["proof (prove)\ngoal (1 subgoal):\n 1. conjugate 2 \\<cdot>\\<^sub>m adjoint proj_psi =\n    2 \\<cdot>\\<^sub>m proj_psi", "using hermitian_proj_psi[simplified hermitian_def]"], ["proof (prove)\nusing this:\n  adjoint proj_psi = proj_psi\n\ngoal (1 subgoal):\n 1. conjugate 2 \\<cdot>\\<^sub>m adjoint proj_psi =\n    2 \\<cdot>\\<^sub>m proj_psi", "by simp"], ["proof (state)\nthis:\n  adjoint (2 \\<cdot>\\<^sub>m proj_psi) = 2 \\<cdot>\\<^sub>m proj_psi\n\ngoal (1 subgoal):\n 1. unitary (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N)", "have eq: \"adjoint (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) = 2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adjoint (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) =\n    2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N", "apply (subst adjoint_minus)"], ["proof (prove)\ngoal (3 subgoals):\n 1. 2 \\<cdot>\\<^sub>m proj_psi \\<in> carrier_mat ?n ?m\n 2. 1\\<^sub>m N \\<in> carrier_mat ?n ?m\n 3. adjoint (2 \\<cdot>\\<^sub>m proj_psi) - adjoint (1\\<^sub>m N) =\n    2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N", "using proj_psi_dim a adjoint_one"], ["proof (prove)\nusing this:\n  proj_psi \\<in> carrier_mat N N\n  adjoint (2 \\<cdot>\\<^sub>m proj_psi) = 2 \\<cdot>\\<^sub>m proj_psi\n  adjoint (1\\<^sub>m ?n) = 1\\<^sub>m ?n\n\ngoal (3 subgoals):\n 1. 2 \\<cdot>\\<^sub>m proj_psi \\<in> carrier_mat ?n ?m\n 2. 1\\<^sub>m N \\<in> carrier_mat ?n ?m\n 3. adjoint (2 \\<cdot>\\<^sub>m proj_psi) - adjoint (1\\<^sub>m N) =\n    2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N", "by auto"], ["proof (state)\nthis:\n  adjoint (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) =\n  2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N\n\ngoal (1 subgoal):\n 1. unitary (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N)", "have \"(2 \\<cdot>\\<^sub>m proj_psi) * (2 \\<cdot>\\<^sub>m proj_psi) = 4 \\<cdot>\\<^sub>m (proj_psi * proj_psi)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 \\<cdot>\\<^sub>m proj_psi * (2 \\<cdot>\\<^sub>m proj_psi) =\n    4 \\<cdot>\\<^sub>m (proj_psi * proj_psi)", "using proj_psi_dim"], ["proof (prove)\nusing this:\n  proj_psi \\<in> carrier_mat N N\n\ngoal (1 subgoal):\n 1. 2 \\<cdot>\\<^sub>m proj_psi * (2 \\<cdot>\\<^sub>m proj_psi) =\n    4 \\<cdot>\\<^sub>m (proj_psi * proj_psi)", "by auto"], ["proof (state)\nthis:\n  2 \\<cdot>\\<^sub>m proj_psi * (2 \\<cdot>\\<^sub>m proj_psi) =\n  4 \\<cdot>\\<^sub>m (proj_psi * proj_psi)\n\ngoal (1 subgoal):\n 1. unitary (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N)", "also"], ["proof (state)\nthis:\n  2 \\<cdot>\\<^sub>m proj_psi * (2 \\<cdot>\\<^sub>m proj_psi) =\n  4 \\<cdot>\\<^sub>m (proj_psi * proj_psi)\n\ngoal (1 subgoal):\n 1. unitary (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N)", "have \"\\<dots> = 4 \\<cdot>\\<^sub>m proj_psi\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 4 \\<cdot>\\<^sub>m (proj_psi * proj_psi) = 4 \\<cdot>\\<^sub>m proj_psi", "using proj_psi_is_projection"], ["proof (prove)\nusing this:\n  proj_psi * proj_psi = proj_psi\n\ngoal (1 subgoal):\n 1. 4 \\<cdot>\\<^sub>m (proj_psi * proj_psi) = 4 \\<cdot>\\<^sub>m proj_psi", "by auto"], ["proof (state)\nthis:\n  4 \\<cdot>\\<^sub>m (proj_psi * proj_psi) = 4 \\<cdot>\\<^sub>m proj_psi\n\ngoal (1 subgoal):\n 1. unitary (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N)", "finally"], ["proof (chain)\npicking this:\n  2 \\<cdot>\\<^sub>m proj_psi * (2 \\<cdot>\\<^sub>m proj_psi) =\n  4 \\<cdot>\\<^sub>m proj_psi", "have sq: \"(2 \\<cdot>\\<^sub>m proj_psi) * (2 \\<cdot>\\<^sub>m proj_psi) = 4 \\<cdot>\\<^sub>m proj_psi\""], ["proof (prove)\nusing this:\n  2 \\<cdot>\\<^sub>m proj_psi * (2 \\<cdot>\\<^sub>m proj_psi) =\n  4 \\<cdot>\\<^sub>m proj_psi\n\ngoal (1 subgoal):\n 1. 2 \\<cdot>\\<^sub>m proj_psi * (2 \\<cdot>\\<^sub>m proj_psi) =\n    4 \\<cdot>\\<^sub>m proj_psi", "."], ["proof (state)\nthis:\n  2 \\<cdot>\\<^sub>m proj_psi * (2 \\<cdot>\\<^sub>m proj_psi) =\n  4 \\<cdot>\\<^sub>m proj_psi\n\ngoal (1 subgoal):\n 1. unitary (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N)", "have l: \"(2 \\<cdot>\\<^sub>m proj_psi) * (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) = 4 \\<cdot>\\<^sub>m proj_psi - (2 \\<cdot>\\<^sub>m proj_psi)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 \\<cdot>\\<^sub>m proj_psi *\n    (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) =\n    4 \\<cdot>\\<^sub>m proj_psi - 2 \\<cdot>\\<^sub>m proj_psi", "apply (subst mult_minus_distrib_mat)"], ["proof (prove)\ngoal (4 subgoals):\n 1. 2 \\<cdot>\\<^sub>m proj_psi \\<in> carrier_mat ?nr ?n\n 2. 2 \\<cdot>\\<^sub>m proj_psi \\<in> carrier_mat ?n ?nc\n 3. 1\\<^sub>m N \\<in> carrier_mat ?n ?nc\n 4. 2 \\<cdot>\\<^sub>m proj_psi * (2 \\<cdot>\\<^sub>m proj_psi) -\n    2 \\<cdot>\\<^sub>m proj_psi * 1\\<^sub>m N =\n    4 \\<cdot>\\<^sub>m proj_psi - 2 \\<cdot>\\<^sub>m proj_psi", "using proj_psi_dim sq"], ["proof (prove)\nusing this:\n  proj_psi \\<in> carrier_mat N N\n  2 \\<cdot>\\<^sub>m proj_psi * (2 \\<cdot>\\<^sub>m proj_psi) =\n  4 \\<cdot>\\<^sub>m proj_psi\n\ngoal (4 subgoals):\n 1. 2 \\<cdot>\\<^sub>m proj_psi \\<in> carrier_mat ?nr ?n\n 2. 2 \\<cdot>\\<^sub>m proj_psi \\<in> carrier_mat ?n ?nc\n 3. 1\\<^sub>m N \\<in> carrier_mat ?n ?nc\n 4. 2 \\<cdot>\\<^sub>m proj_psi * (2 \\<cdot>\\<^sub>m proj_psi) -\n    2 \\<cdot>\\<^sub>m proj_psi * 1\\<^sub>m N =\n    4 \\<cdot>\\<^sub>m proj_psi - 2 \\<cdot>\\<^sub>m proj_psi", "by auto"], ["proof (state)\nthis:\n  2 \\<cdot>\\<^sub>m proj_psi * (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) =\n  4 \\<cdot>\\<^sub>m proj_psi - 2 \\<cdot>\\<^sub>m proj_psi\n\ngoal (1 subgoal):\n 1. unitary (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N)", "have \"(2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) * adjoint (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N)\n    = (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) * (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) *\n    adjoint (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) =\n    (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) *\n    (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N)", "using eq"], ["proof (prove)\nusing this:\n  adjoint (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) =\n  2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N\n\ngoal (1 subgoal):\n 1. (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) *\n    adjoint (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) =\n    (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) *\n    (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N)", "by auto"], ["proof (state)\nthis:\n  (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) *\n  adjoint (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) =\n  (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) *\n  (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N)\n\ngoal (1 subgoal):\n 1. unitary (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N)", "also"], ["proof (state)\nthis:\n  (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) *\n  adjoint (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) =\n  (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) *\n  (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N)\n\ngoal (1 subgoal):\n 1. unitary (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N)", "have \"\\<dots> = (2 \\<cdot>\\<^sub>m proj_psi) * (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) - 2 \\<cdot>\\<^sub>m proj_psi + 1\\<^sub>m N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) *\n    (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) =\n    2 \\<cdot>\\<^sub>m proj_psi *\n    (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) -\n    2 \\<cdot>\\<^sub>m proj_psi +\n    1\\<^sub>m N", "apply (subst minus_mult_distrib_mat[of _ N N])"], ["proof (prove)\ngoal (4 subgoals):\n 1. 2 \\<cdot>\\<^sub>m proj_psi \\<in> carrier_mat N N\n 2. 1\\<^sub>m N \\<in> carrier_mat N N\n 3. 2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N \\<in> carrier_mat N ?nc\n 4. 2 \\<cdot>\\<^sub>m proj_psi *\n    (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) -\n    1\\<^sub>m N * (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) =\n    2 \\<cdot>\\<^sub>m proj_psi *\n    (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) -\n    2 \\<cdot>\\<^sub>m proj_psi +\n    1\\<^sub>m N", "using proj_psi_dim"], ["proof (prove)\nusing this:\n  proj_psi \\<in> carrier_mat N N\n\ngoal (4 subgoals):\n 1. 2 \\<cdot>\\<^sub>m proj_psi \\<in> carrier_mat N N\n 2. 1\\<^sub>m N \\<in> carrier_mat N N\n 3. 2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N \\<in> carrier_mat N ?nc\n 4. 2 \\<cdot>\\<^sub>m proj_psi *\n    (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) -\n    1\\<^sub>m N * (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) =\n    2 \\<cdot>\\<^sub>m proj_psi *\n    (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) -\n    2 \\<cdot>\\<^sub>m proj_psi +\n    1\\<^sub>m N", "by auto"], ["proof (state)\nthis:\n  (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) *\n  (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) =\n  2 \\<cdot>\\<^sub>m proj_psi * (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) -\n  2 \\<cdot>\\<^sub>m proj_psi +\n  1\\<^sub>m N\n\ngoal (1 subgoal):\n 1. unitary (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N)", "also"], ["proof (state)\nthis:\n  (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) *\n  (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) =\n  2 \\<cdot>\\<^sub>m proj_psi * (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) -\n  2 \\<cdot>\\<^sub>m proj_psi +\n  1\\<^sub>m N\n\ngoal (1 subgoal):\n 1. unitary (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N)", "have \"\\<dots> = 4 \\<cdot>\\<^sub>m proj_psi - (2 \\<cdot>\\<^sub>m proj_psi) - 2 \\<cdot>\\<^sub>m proj_psi + 1\\<^sub>m N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 \\<cdot>\\<^sub>m proj_psi *\n    (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) -\n    2 \\<cdot>\\<^sub>m proj_psi +\n    1\\<^sub>m N =\n    4 \\<cdot>\\<^sub>m proj_psi - 2 \\<cdot>\\<^sub>m proj_psi -\n    2 \\<cdot>\\<^sub>m proj_psi +\n    1\\<^sub>m N", "using l"], ["proof (prove)\nusing this:\n  2 \\<cdot>\\<^sub>m proj_psi * (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) =\n  4 \\<cdot>\\<^sub>m proj_psi - 2 \\<cdot>\\<^sub>m proj_psi\n\ngoal (1 subgoal):\n 1. 2 \\<cdot>\\<^sub>m proj_psi *\n    (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) -\n    2 \\<cdot>\\<^sub>m proj_psi +\n    1\\<^sub>m N =\n    4 \\<cdot>\\<^sub>m proj_psi - 2 \\<cdot>\\<^sub>m proj_psi -\n    2 \\<cdot>\\<^sub>m proj_psi +\n    1\\<^sub>m N", "by auto"], ["proof (state)\nthis:\n  2 \\<cdot>\\<^sub>m proj_psi * (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) -\n  2 \\<cdot>\\<^sub>m proj_psi +\n  1\\<^sub>m N =\n  4 \\<cdot>\\<^sub>m proj_psi - 2 \\<cdot>\\<^sub>m proj_psi -\n  2 \\<cdot>\\<^sub>m proj_psi +\n  1\\<^sub>m N\n\ngoal (1 subgoal):\n 1. unitary (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N)", "also"], ["proof (state)\nthis:\n  2 \\<cdot>\\<^sub>m proj_psi * (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) -\n  2 \\<cdot>\\<^sub>m proj_psi +\n  1\\<^sub>m N =\n  4 \\<cdot>\\<^sub>m proj_psi - 2 \\<cdot>\\<^sub>m proj_psi -\n  2 \\<cdot>\\<^sub>m proj_psi +\n  1\\<^sub>m N\n\ngoal (1 subgoal):\n 1. unitary (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N)", "have \"\\<dots> = 1\\<^sub>m N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 4 \\<cdot>\\<^sub>m proj_psi - 2 \\<cdot>\\<^sub>m proj_psi -\n    2 \\<cdot>\\<^sub>m proj_psi +\n    1\\<^sub>m N =\n    1\\<^sub>m N", "using proj_psi_dim"], ["proof (prove)\nusing this:\n  proj_psi \\<in> carrier_mat N N\n\ngoal (1 subgoal):\n 1. 4 \\<cdot>\\<^sub>m proj_psi - 2 \\<cdot>\\<^sub>m proj_psi -\n    2 \\<cdot>\\<^sub>m proj_psi +\n    1\\<^sub>m N =\n    1\\<^sub>m N", "by auto"], ["proof (state)\nthis:\n  4 \\<cdot>\\<^sub>m proj_psi - 2 \\<cdot>\\<^sub>m proj_psi -\n  2 \\<cdot>\\<^sub>m proj_psi +\n  1\\<^sub>m N =\n  1\\<^sub>m N\n\ngoal (1 subgoal):\n 1. unitary (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N)", "finally"], ["proof (chain)\npicking this:\n  (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) *\n  adjoint (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) =\n  1\\<^sub>m N", "have \"(2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) * adjoint (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) = 1\\<^sub>m N\""], ["proof (prove)\nusing this:\n  (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) *\n  adjoint (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) =\n  1\\<^sub>m N\n\ngoal (1 subgoal):\n 1. (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) *\n    adjoint (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) =\n    1\\<^sub>m N", "."], ["proof (state)\nthis:\n  (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) *\n  adjoint (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) =\n  1\\<^sub>m N\n\ngoal (1 subgoal):\n 1. unitary (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N)", "then"], ["proof (chain)\npicking this:\n  (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) *\n  adjoint (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) =\n  1\\<^sub>m N", "show ?thesis"], ["proof (prove)\nusing this:\n  (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) *\n  adjoint (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) =\n  1\\<^sub>m N\n\ngoal (1 subgoal):\n 1. unitary (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N)", "unfolding unitary_def inverts_mat_def"], ["proof (prove)\nusing this:\n  (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) *\n  adjoint (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) =\n  1\\<^sub>m N\n\ngoal (1 subgoal):\n 1. 2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N\n    \\<in> carrier_mat (dim_row (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N))\n           (dim_row (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N)) \\<and>\n    (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) *\n    adjoint (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) =\n    1\\<^sub>m (dim_row (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N))", "using proj_psi_dim"], ["proof (prove)\nusing this:\n  (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) *\n  adjoint (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) =\n  1\\<^sub>m N\n  proj_psi \\<in> carrier_mat N N\n\ngoal (1 subgoal):\n 1. 2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N\n    \\<in> carrier_mat (dim_row (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N))\n           (dim_row (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N)) \\<and>\n    (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) *\n    adjoint (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) =\n    1\\<^sub>m (dim_row (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N))", "by auto"], ["proof (state)\nthis:\n  unitary (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma proj_psi_minus_1_mult_psi'_l:\n  \"(2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) *\\<^sub>v psi'_l l = psi_l (l + 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) *\\<^sub>v psi'_l l =\n    psi_l (l + 1)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) *\\<^sub>v psi'_l l =\n    psi_l (l + 1)", "have eq1: \"(2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) *\\<^sub>v psi'_l l = 2 \\<cdot>\\<^sub>m proj_psi *\\<^sub>v psi'_l l - psi'_l l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) *\\<^sub>v psi'_l l =\n    2 \\<cdot>\\<^sub>m proj_psi *\\<^sub>v psi'_l l - psi'_l l", "apply (subst minus_mult_distrib_mat_vec)"], ["proof (prove)\ngoal (4 subgoals):\n 1. 2 \\<cdot>\\<^sub>m proj_psi \\<in> carrier_mat ?nr ?nc\n 2. 1\\<^sub>m N \\<in> carrier_mat ?nr ?nc\n 3. psi'_l l \\<in> carrier_vec ?nc\n 4. 2 \\<cdot>\\<^sub>m proj_psi *\\<^sub>v psi'_l l -\n    1\\<^sub>m N *\\<^sub>v psi'_l l =\n    2 \\<cdot>\\<^sub>m proj_psi *\\<^sub>v psi'_l l - psi'_l l", "using psi'_l_dim proj_psi'_dim proj_psi_dim"], ["proof (prove)\nusing this:\n  psi'_l ?l \\<in> carrier_vec N\n  proj_psi'_l ?l \\<in> carrier_mat N N\n  proj_psi \\<in> carrier_mat N N\n\ngoal (4 subgoals):\n 1. 2 \\<cdot>\\<^sub>m proj_psi \\<in> carrier_mat ?nr ?nc\n 2. 1\\<^sub>m N \\<in> carrier_mat ?nr ?nc\n 3. psi'_l l \\<in> carrier_vec ?nc\n 4. 2 \\<cdot>\\<^sub>m proj_psi *\\<^sub>v psi'_l l -\n    1\\<^sub>m N *\\<^sub>v psi'_l l =\n    2 \\<cdot>\\<^sub>m proj_psi *\\<^sub>v psi'_l l - psi'_l l", "by auto"], ["proof (state)\nthis:\n  (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) *\\<^sub>v psi'_l l =\n  2 \\<cdot>\\<^sub>m proj_psi *\\<^sub>v psi'_l l - psi'_l l\n\ngoal (1 subgoal):\n 1. (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) *\\<^sub>v psi'_l l =\n    psi_l (l + 1)", "have eq2: \"2 \\<cdot>\\<^sub>m proj_psi *\\<^sub>v (psi'_l l) = 2 \\<cdot>\\<^sub>v (proj_psi *\\<^sub>v (psi'_l l))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 \\<cdot>\\<^sub>m proj_psi *\\<^sub>v psi'_l l =\n    2 \\<cdot>\\<^sub>v (proj_psi *\\<^sub>v psi'_l l)", "apply (subst smult_mat_mult_mat_vec_assoc)"], ["proof (prove)\ngoal (3 subgoals):\n 1. proj_psi \\<in> carrier_mat ?n ?m\n 2. psi'_l l \\<in> carrier_vec ?m\n 3. 2 \\<cdot>\\<^sub>v (proj_psi *\\<^sub>v psi'_l l) =\n    2 \\<cdot>\\<^sub>v (proj_psi *\\<^sub>v psi'_l l)", "using proj_psi_dim psi'_l_dim"], ["proof (prove)\nusing this:\n  proj_psi \\<in> carrier_mat N N\n  psi'_l ?l \\<in> carrier_vec N\n\ngoal (3 subgoals):\n 1. proj_psi \\<in> carrier_mat ?n ?m\n 2. psi'_l l \\<in> carrier_vec ?m\n 3. 2 \\<cdot>\\<^sub>v (proj_psi *\\<^sub>v psi'_l l) =\n    2 \\<cdot>\\<^sub>v (proj_psi *\\<^sub>v psi'_l l)", "by auto"], ["proof (state)\nthis:\n  2 \\<cdot>\\<^sub>m proj_psi *\\<^sub>v psi'_l l =\n  2 \\<cdot>\\<^sub>v (proj_psi *\\<^sub>v psi'_l l)\n\ngoal (1 subgoal):\n 1. (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) *\\<^sub>v psi'_l l =\n    psi_l (l + 1)", "have \"proj_psi *\\<^sub>v (psi'_l l) = inner_prod \\<psi> (psi'_l l) \\<cdot>\\<^sub>v \\<psi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proj_psi *\\<^sub>v psi'_l l =\n    inner_prod \\<psi> (psi'_l l) \\<cdot>\\<^sub>v \\<psi>", "unfolding proj_psi_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. outer_prod \\<psi> \\<psi> *\\<^sub>v psi'_l l =\n    inner_prod \\<psi> (psi'_l l) \\<cdot>\\<^sub>v \\<psi>", "apply (subst outer_prod_mult_vec[of _ N _ N])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<psi> \\<in> carrier_vec N\n 2. psi'_l l \\<in> carrier_vec N\n 3. inner_prod \\<psi> (psi'_l l) \\<cdot>\\<^sub>v \\<psi> =\n    inner_prod \\<psi> (psi'_l l) \\<cdot>\\<^sub>v \\<psi>", "using \\<psi>_dim psi'_l_dim"], ["proof (prove)\nusing this:\n  \\<psi> \\<in> carrier_vec N\n  dim_vec \\<psi> = N\n  psi'_l ?l \\<in> carrier_vec N\n\ngoal (3 subgoals):\n 1. \\<psi> \\<in> carrier_vec N\n 2. psi'_l l \\<in> carrier_vec N\n 3. inner_prod \\<psi> (psi'_l l) \\<cdot>\\<^sub>v \\<psi> =\n    inner_prod \\<psi> (psi'_l l) \\<cdot>\\<^sub>v \\<psi>", "by auto"], ["proof (state)\nthis:\n  proj_psi *\\<^sub>v psi'_l l =\n  inner_prod \\<psi> (psi'_l l) \\<cdot>\\<^sub>v \\<psi>\n\ngoal (1 subgoal):\n 1. (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) *\\<^sub>v psi'_l l =\n    psi_l (l + 1)", "also"], ["proof (state)\nthis:\n  proj_psi *\\<^sub>v psi'_l l =\n  inner_prod \\<psi> (psi'_l l) \\<cdot>\\<^sub>v \\<psi>\n\ngoal (1 subgoal):\n 1. (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) *\\<^sub>v psi'_l l =\n    psi_l (l + 1)", "have \"\\<dots> = ((alpha_l l) * ccos (\\<theta> / 2) - (beta_l l) * csin (\\<theta> / 2)) \\<cdot>\\<^sub>v \\<psi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inner_prod \\<psi> (psi'_l l) \\<cdot>\\<^sub>v \\<psi> =\n    (alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n     beta_l l * complex_of_real (sin (\\<theta> / 2))) \\<cdot>\\<^sub>v\n    \\<psi>", "using psi_inner_psi'_l"], ["proof (prove)\nusing this:\n  inner_prod \\<psi> (psi'_l ?l) =\n  alpha_l ?l * complex_of_real (cos (\\<theta> / 2)) -\n  beta_l ?l * complex_of_real (sin (\\<theta> / 2))\n\ngoal (1 subgoal):\n 1. inner_prod \\<psi> (psi'_l l) \\<cdot>\\<^sub>v \\<psi> =\n    (alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n     beta_l l * complex_of_real (sin (\\<theta> / 2))) \\<cdot>\\<^sub>v\n    \\<psi>", "by auto"], ["proof (state)\nthis:\n  inner_prod \\<psi> (psi'_l l) \\<cdot>\\<^sub>v \\<psi> =\n  (alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n   beta_l l * complex_of_real (sin (\\<theta> / 2))) \\<cdot>\\<^sub>v\n  \\<psi>\n\ngoal (1 subgoal):\n 1. (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) *\\<^sub>v psi'_l l =\n    psi_l (l + 1)", "finally"], ["proof (chain)\npicking this:\n  proj_psi *\\<^sub>v psi'_l l =\n  (alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n   beta_l l * complex_of_real (sin (\\<theta> / 2))) \\<cdot>\\<^sub>v\n  \\<psi>", "have \"proj_psi *\\<^sub>v (psi'_l l) = ((alpha_l l) * ccos (\\<theta> / 2) - (beta_l l) * csin (\\<theta> / 2)) \\<cdot>\\<^sub>v \\<psi>\""], ["proof (prove)\nusing this:\n  proj_psi *\\<^sub>v psi'_l l =\n  (alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n   beta_l l * complex_of_real (sin (\\<theta> / 2))) \\<cdot>\\<^sub>v\n  \\<psi>\n\ngoal (1 subgoal):\n 1. proj_psi *\\<^sub>v psi'_l l =\n    (alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n     beta_l l * complex_of_real (sin (\\<theta> / 2))) \\<cdot>\\<^sub>v\n    \\<psi>", "by auto"], ["proof (state)\nthis:\n  proj_psi *\\<^sub>v psi'_l l =\n  (alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n   beta_l l * complex_of_real (sin (\\<theta> / 2))) \\<cdot>\\<^sub>v\n  \\<psi>\n\ngoal (1 subgoal):\n 1. (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) *\\<^sub>v psi'_l l =\n    psi_l (l + 1)", "then"], ["proof (chain)\npicking this:\n  proj_psi *\\<^sub>v psi'_l l =\n  (alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n   beta_l l * complex_of_real (sin (\\<theta> / 2))) \\<cdot>\\<^sub>v\n  \\<psi>", "have eq3: \"2 \\<cdot>\\<^sub>v (proj_psi *\\<^sub>v (psi'_l l)) = 2 * ((alpha_l l) * ccos (\\<theta> / 2) - (beta_l l) * csin (\\<theta> / 2)) \\<cdot>\\<^sub>v \\<psi>\""], ["proof (prove)\nusing this:\n  proj_psi *\\<^sub>v psi'_l l =\n  (alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n   beta_l l * complex_of_real (sin (\\<theta> / 2))) \\<cdot>\\<^sub>v\n  \\<psi>\n\ngoal (1 subgoal):\n 1. 2 \\<cdot>\\<^sub>v (proj_psi *\\<^sub>v psi'_l l) =\n    2 *\n    (alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n     beta_l l * complex_of_real (sin (\\<theta> / 2))) \\<cdot>\\<^sub>v\n    \\<psi>", "by auto"], ["proof (state)\nthis:\n  2 \\<cdot>\\<^sub>v (proj_psi *\\<^sub>v psi'_l l) =\n  2 *\n  (alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n   beta_l l * complex_of_real (sin (\\<theta> / 2))) \\<cdot>\\<^sub>v\n  \\<psi>\n\ngoal (1 subgoal):\n 1. (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) *\\<^sub>v psi'_l l =\n    psi_l (l + 1)", "then"], ["proof (chain)\npicking this:\n  2 \\<cdot>\\<^sub>v (proj_psi *\\<^sub>v psi'_l l) =\n  2 *\n  (alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n   beta_l l * complex_of_real (sin (\\<theta> / 2))) \\<cdot>\\<^sub>v\n  \\<psi>", "show \"(2 \\<cdot>\\<^sub>m proj_psi - (1\\<^sub>m N)) *\\<^sub>v (psi'_l l) = psi_l (l + 1)\""], ["proof (prove)\nusing this:\n  2 \\<cdot>\\<^sub>v (proj_psi *\\<^sub>v psi'_l l) =\n  2 *\n  (alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n   beta_l l * complex_of_real (sin (\\<theta> / 2))) \\<cdot>\\<^sub>v\n  \\<psi>\n\ngoal (1 subgoal):\n 1. (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) *\\<^sub>v psi'_l l =\n    psi_l (l + 1)", "using eq1 eq2 eq3 psi_l_Suc_l_derive"], ["proof (prove)\nusing this:\n  2 \\<cdot>\\<^sub>v (proj_psi *\\<^sub>v psi'_l l) =\n  2 *\n  (alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n   beta_l l * complex_of_real (sin (\\<theta> / 2))) \\<cdot>\\<^sub>v\n  \\<psi>\n  (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) *\\<^sub>v psi'_l l =\n  2 \\<cdot>\\<^sub>m proj_psi *\\<^sub>v psi'_l l - psi'_l l\n  2 \\<cdot>\\<^sub>m proj_psi *\\<^sub>v psi'_l l =\n  2 \\<cdot>\\<^sub>v (proj_psi *\\<^sub>v psi'_l l)\n  2 \\<cdot>\\<^sub>v (proj_psi *\\<^sub>v psi'_l l) =\n  2 *\n  (alpha_l l * complex_of_real (cos (\\<theta> / 2)) -\n   beta_l l * complex_of_real (sin (\\<theta> / 2))) \\<cdot>\\<^sub>v\n  \\<psi>\n  2 *\n  (alpha_l ?l * complex_of_real (cos (\\<theta> / 2)) -\n   beta_l ?l * complex_of_real (sin (\\<theta> / 2))) \\<cdot>\\<^sub>v\n  \\<psi> -\n  psi'_l ?l =\n  psi_l (?l + 1)\n\ngoal (1 subgoal):\n 1. (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) *\\<^sub>v psi'_l l =\n    psi_l (l + 1)", "by simp"], ["proof (state)\nthis:\n  (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) *\\<^sub>v psi'_l l =\n  psi_l (l + 1)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma proj_psi_minus_1_mult_psi_Suc_l:\n  \"(2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) *\\<^sub>v psi_l (l + 1) = psi'_l l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) *\\<^sub>v psi_l (l + 1) =\n    psi'_l l", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) *\\<^sub>v psi_l (l + 1) =\n    psi'_l l", "have id: \"(2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) * (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) = 1\\<^sub>m N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) *\n    (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) =\n    1\\<^sub>m N", "using unitary_proj_psi_minus_1"], ["proof (prove)\nusing this:\n  unitary (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N)\n\ngoal (1 subgoal):\n 1. (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) *\n    (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) =\n    1\\<^sub>m N", "unfolding unitary_def hermitian_proj_psi_minus_1[simplified hermitian_def]"], ["proof (prove)\nusing this:\n  2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N\n  \\<in> carrier_mat (dim_row (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N))\n         (dim_row (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N)) \\<and>\n  inverts_mat (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N)\n   (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N)\n\ngoal (1 subgoal):\n 1. (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) *\n    (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) =\n    1\\<^sub>m N", "unfolding inverts_mat_def"], ["proof (prove)\nusing this:\n  2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N\n  \\<in> carrier_mat (dim_row (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N))\n         (dim_row (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N)) \\<and>\n  (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) *\n  (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) =\n  1\\<^sub>m (dim_row (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N))\n\ngoal (1 subgoal):\n 1. (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) *\n    (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) =\n    1\\<^sub>m N", "by auto"], ["proof (state)\nthis:\n  (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) *\n  (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) =\n  1\\<^sub>m N\n\ngoal (1 subgoal):\n 1. (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) *\\<^sub>v psi_l (l + 1) =\n    psi'_l l", "have \"(2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) *\\<^sub>v psi_l (l + 1) = (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) *\\<^sub>v ((2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) *\\<^sub>v psi'_l l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) *\\<^sub>v psi_l (l + 1) =\n    (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) *\\<^sub>v\n    ((2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) *\\<^sub>v psi'_l l)", "using proj_psi_minus_1_mult_psi'_l"], ["proof (prove)\nusing this:\n  (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) *\\<^sub>v psi'_l ?l =\n  psi_l (?l + 1)\n\ngoal (1 subgoal):\n 1. (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) *\\<^sub>v psi_l (l + 1) =\n    (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) *\\<^sub>v\n    ((2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) *\\<^sub>v psi'_l l)", "by auto"], ["proof (state)\nthis:\n  (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) *\\<^sub>v psi_l (l + 1) =\n  (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) *\\<^sub>v\n  ((2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) *\\<^sub>v psi'_l l)\n\ngoal (1 subgoal):\n 1. (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) *\\<^sub>v psi_l (l + 1) =\n    psi'_l l", "also"], ["proof (state)\nthis:\n  (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) *\\<^sub>v psi_l (l + 1) =\n  (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) *\\<^sub>v\n  ((2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) *\\<^sub>v psi'_l l)\n\ngoal (1 subgoal):\n 1. (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) *\\<^sub>v psi_l (l + 1) =\n    psi'_l l", "have \"\\<dots> = ((2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) * (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) *\\<^sub>v psi'_l l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) *\\<^sub>v\n    ((2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) *\\<^sub>v psi'_l l) =\n    (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) *\n    (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) *\\<^sub>v\n    psi'_l l", "apply (subst assoc_mult_mat_vec)"], ["proof (prove)\ngoal (4 subgoals):\n 1. 2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N\n    \\<in> carrier_mat ?n\\<^sub>1 ?n\\<^sub>2\n 2. 2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N\n    \\<in> carrier_mat ?n\\<^sub>2 ?n\\<^sub>3\n 3. psi'_l l \\<in> carrier_vec ?n\\<^sub>3\n 4. (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) *\\<^sub>v\n    ((2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) *\\<^sub>v psi'_l l) =\n    (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) *\\<^sub>v\n    ((2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) *\\<^sub>v psi'_l l)", "using proj_psi_dim psi'_l_dim"], ["proof (prove)\nusing this:\n  proj_psi \\<in> carrier_mat N N\n  psi'_l ?l \\<in> carrier_vec N\n\ngoal (4 subgoals):\n 1. 2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N\n    \\<in> carrier_mat ?n\\<^sub>1 ?n\\<^sub>2\n 2. 2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N\n    \\<in> carrier_mat ?n\\<^sub>2 ?n\\<^sub>3\n 3. psi'_l l \\<in> carrier_vec ?n\\<^sub>3\n 4. (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) *\\<^sub>v\n    ((2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) *\\<^sub>v psi'_l l) =\n    (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) *\\<^sub>v\n    ((2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) *\\<^sub>v psi'_l l)", "by auto"], ["proof (state)\nthis:\n  (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) *\\<^sub>v\n  ((2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) *\\<^sub>v psi'_l l) =\n  (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) *\n  (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) *\\<^sub>v\n  psi'_l l\n\ngoal (1 subgoal):\n 1. (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) *\\<^sub>v psi_l (l + 1) =\n    psi'_l l", "also"], ["proof (state)\nthis:\n  (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) *\\<^sub>v\n  ((2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) *\\<^sub>v psi'_l l) =\n  (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) *\n  (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) *\\<^sub>v\n  psi'_l l\n\ngoal (1 subgoal):\n 1. (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) *\\<^sub>v psi_l (l + 1) =\n    psi'_l l", "have \"\\<dots> = psi'_l l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) *\n    (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) *\\<^sub>v\n    psi'_l l =\n    psi'_l l", "using psi'_l_dim id"], ["proof (prove)\nusing this:\n  psi'_l ?l \\<in> carrier_vec N\n  (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) *\n  (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) =\n  1\\<^sub>m N\n\ngoal (1 subgoal):\n 1. (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) *\n    (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) *\\<^sub>v\n    psi'_l l =\n    psi'_l l", "by auto"], ["proof (state)\nthis:\n  (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) *\n  (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) *\\<^sub>v\n  psi'_l l =\n  psi'_l l\n\ngoal (1 subgoal):\n 1. (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) *\\<^sub>v psi_l (l + 1) =\n    psi'_l l", "finally"], ["proof (chain)\npicking this:\n  (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) *\\<^sub>v psi_l (l + 1) =\n  psi'_l l", "show ?thesis"], ["proof (prove)\nusing this:\n  (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) *\\<^sub>v psi_l (l + 1) =\n  psi'_l l\n\ngoal (1 subgoal):\n 1. (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) *\\<^sub>v psi_l (l + 1) =\n    psi'_l l", "by auto"], ["proof (state)\nthis:\n  (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) *\\<^sub>v psi_l (l + 1) =\n  psi'_l l\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma exproj_psi_minus_1_tensor:\n  \"(2 \\<cdot>\\<^sub>m tensor_P proj_psi (1\\<^sub>m K)) - 1\\<^sub>m d = tensor_P (2 \\<cdot>\\<^sub>m proj_psi - (1\\<^sub>m N)) (1\\<^sub>m K)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 \\<cdot>\\<^sub>m tensor_P proj_psi (1\\<^sub>m K) - 1\\<^sub>m d =\n    tensor_P (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) (1\\<^sub>m K)", "unfolding ps2_P.ptensor_mat_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 \\<cdot>\\<^sub>m ps_P.tensor_mat proj_psi (1\\<^sub>m K) - 1\\<^sub>m d =\n    ps_P.tensor_mat (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) (1\\<^sub>m K)", "apply (subst ps_P.tensor_mat_id[symmetric, simplified ps_P_d])"], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 \\<cdot>\\<^sub>m ps_P.tensor_mat proj_psi (1\\<^sub>m K) -\n    ps_P.tensor_mat (1\\<^sub>m ps_P.d1) (1\\<^sub>m ps_P.d2) =\n    ps_P.tensor_mat (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) (1\\<^sub>m K)", "apply (auto simp add: ps_P_d1 ps_P_d2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 \\<cdot>\\<^sub>m ps_P.tensor_mat proj_psi (1\\<^sub>m K) -\n    ps_P.tensor_mat (1\\<^sub>m N) (1\\<^sub>m K) =\n    ps_P.tensor_mat (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) (1\\<^sub>m K)", "apply (subst ps_P.tensor_mat_scale1[symmetric])"], ["proof (prove)\ngoal (3 subgoals):\n 1. proj_psi \\<in> carrier_mat ps_P.d1 ps_P.d1\n 2. 1\\<^sub>m K \\<in> carrier_mat ps_P.d2 ps_P.d2\n 3. ps_P.tensor_mat (2 \\<cdot>\\<^sub>m proj_psi) (1\\<^sub>m K) -\n    ps_P.tensor_mat (1\\<^sub>m N) (1\\<^sub>m K) =\n    ps_P.tensor_mat (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) (1\\<^sub>m K)", "apply (auto simp add: ps_P_d1 ps_P_d2 proj_psi_dim)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ps_P.tensor_mat (2 \\<cdot>\\<^sub>m proj_psi) (1\\<^sub>m K) -\n    ps_P.tensor_mat (1\\<^sub>m N) (1\\<^sub>m K) =\n    ps_P.tensor_mat (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) (1\\<^sub>m K)", "apply (subst ps_P.tensor_mat_minus1)"], ["proof (prove)\ngoal (4 subgoals):\n 1. 2 \\<cdot>\\<^sub>m proj_psi \\<in> carrier_mat ps_P.d1 ps_P.d1\n 2. 1\\<^sub>m N \\<in> carrier_mat ps_P.d1 ps_P.d1\n 3. 1\\<^sub>m K \\<in> carrier_mat ps_P.d2 ps_P.d2\n 4. ps_P.tensor_mat (2 \\<cdot>\\<^sub>m proj_psi) (1\\<^sub>m K) -\n    ps_P.tensor_mat (1\\<^sub>m N) (1\\<^sub>m K) =\n    ps_P.tensor_mat (2 \\<cdot>\\<^sub>m proj_psi) (1\\<^sub>m K) -\n    ps_P.tensor_mat (1\\<^sub>m N) (1\\<^sub>m K)", "by (auto simp add: ps_P_d1 ps_P_d2 proj_psi_dim)"], ["", "lemma unitary_exproj_psi_minus_1:\n  \"unitary (2 \\<cdot>\\<^sub>m tensor_P proj_psi (1\\<^sub>m K) - 1\\<^sub>m d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unitary\n     (2 \\<cdot>\\<^sub>m tensor_P proj_psi (1\\<^sub>m K) - 1\\<^sub>m d)", "unfolding exproj_psi_minus_1_tensor"], ["proof (prove)\ngoal (1 subgoal):\n 1. unitary\n     (tensor_P (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) (1\\<^sub>m K))", "unfolding ps2_P.ptensor_mat_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. unitary\n     (ps_P.tensor_mat (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N)\n       (1\\<^sub>m K))", "apply (subst ps_P.tensor_mat_unitary)"], ["proof (prove)\ngoal (5 subgoals):\n 1. 2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N\n    \\<in> carrier_mat ps_P.d1 ps_P.d1\n 2. 1\\<^sub>m K \\<in> carrier_mat ps_P.d2 ps_P.d2\n 3. unitary (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N)\n 4. unitary (1\\<^sub>m K)\n 5. True", "using ps_P_d1 ps_P_d2 unitary_proj_psi_minus_1 unitary_one"], ["proof (prove)\nusing this:\n  ps_P.d1 = N\n  ps_P.d2 = K\n  unitary (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N)\n  unitary (1\\<^sub>m ?n)\n\ngoal (5 subgoals):\n 1. 2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N\n    \\<in> carrier_mat ps_P.d1 ps_P.d1\n 2. 1\\<^sub>m K \\<in> carrier_mat ps_P.d2 ps_P.d2\n 3. unitary (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N)\n 4. unitary (1\\<^sub>m K)\n 5. True", "by auto"], ["", "lemma proj_psi_minus_1_Q2:\n  \"adjoint (2 \\<cdot>\\<^sub>m tensor_P proj_psi (1\\<^sub>m K) - 1\\<^sub>m d) * Q2 * (2 \\<cdot>\\<^sub>m tensor_P proj_psi (1\\<^sub>m K) - 1\\<^sub>m d) = Q1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adjoint\n     (2 \\<cdot>\\<^sub>m tensor_P proj_psi (1\\<^sub>m K) - 1\\<^sub>m d) *\n    Q2 *\n    (2 \\<cdot>\\<^sub>m tensor_P proj_psi (1\\<^sub>m K) - 1\\<^sub>m d) =\n    Q1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. adjoint\n     (2 \\<cdot>\\<^sub>m tensor_P proj_psi (1\\<^sub>m K) - 1\\<^sub>m d) *\n    Q2 *\n    (2 \\<cdot>\\<^sub>m tensor_P proj_psi (1\\<^sub>m K) - 1\\<^sub>m d) =\n    Q1", "have eq1: \"adjoint (2 \\<cdot>\\<^sub>m tensor_P proj_psi (1\\<^sub>m K) - 1\\<^sub>m d) = 2 \\<cdot>\\<^sub>m tensor_P proj_psi (1\\<^sub>m K) - 1\\<^sub>m d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adjoint\n     (2 \\<cdot>\\<^sub>m tensor_P proj_psi (1\\<^sub>m K) - 1\\<^sub>m d) =\n    2 \\<cdot>\\<^sub>m tensor_P proj_psi (1\\<^sub>m K) - 1\\<^sub>m d", "apply (subst adjoint_minus[of _ d d])"], ["proof (prove)\ngoal (3 subgoals):\n 1. 2 \\<cdot>\\<^sub>m tensor_P proj_psi (1\\<^sub>m K) \\<in> carrier_mat d d\n 2. 1\\<^sub>m d \\<in> carrier_mat d d\n 3. adjoint (2 \\<cdot>\\<^sub>m tensor_P proj_psi (1\\<^sub>m K)) -\n    adjoint (1\\<^sub>m d) =\n    2 \\<cdot>\\<^sub>m tensor_P proj_psi (1\\<^sub>m K) - 1\\<^sub>m d", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 \\<cdot>\\<^sub>m tensor_P proj_psi (1\\<^sub>m K) \\<in> carrier_mat d d", "using tensor_P_dim[of proj_psi]"], ["proof (prove)\nusing this:\n  tensor_P proj_psi ?B \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. 2 \\<cdot>\\<^sub>m tensor_P proj_psi (1\\<^sub>m K) \\<in> carrier_mat d d", "by auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. 1\\<^sub>m d \\<in> carrier_mat d d\n 2. adjoint (2 \\<cdot>\\<^sub>m tensor_P proj_psi (1\\<^sub>m K)) -\n    adjoint (1\\<^sub>m d) =\n    2 \\<cdot>\\<^sub>m tensor_P proj_psi (1\\<^sub>m K) - 1\\<^sub>m d", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1\\<^sub>m d \\<in> carrier_mat d d", "by auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. adjoint (2 \\<cdot>\\<^sub>m tensor_P proj_psi (1\\<^sub>m K)) -\n    adjoint (1\\<^sub>m d) =\n    2 \\<cdot>\\<^sub>m tensor_P proj_psi (1\\<^sub>m K) - 1\\<^sub>m d", "apply (subst adjoint_one)"], ["proof (prove)\ngoal (1 subgoal):\n 1. adjoint (2 \\<cdot>\\<^sub>m tensor_P proj_psi (1\\<^sub>m K)) -\n    1\\<^sub>m d =\n    2 \\<cdot>\\<^sub>m tensor_P proj_psi (1\\<^sub>m K) - 1\\<^sub>m d", "apply (subst adjoint_scale)"], ["proof (prove)\ngoal (1 subgoal):\n 1. conjugate 2 \\<cdot>\\<^sub>m adjoint (tensor_P proj_psi (1\\<^sub>m K)) -\n    1\\<^sub>m d =\n    2 \\<cdot>\\<^sub>m tensor_P proj_psi (1\\<^sub>m K) - 1\\<^sub>m d", "using hermitian_exproj_psi[simplified hermitian_def]"], ["proof (prove)\nusing this:\n  adjoint (tensor_P proj_psi (1\\<^sub>m K)) =\n  tensor_P proj_psi (1\\<^sub>m K)\n\ngoal (1 subgoal):\n 1. conjugate 2 \\<cdot>\\<^sub>m adjoint (tensor_P proj_psi (1\\<^sub>m K)) -\n    1\\<^sub>m d =\n    2 \\<cdot>\\<^sub>m tensor_P proj_psi (1\\<^sub>m K) - 1\\<^sub>m d", "by auto"], ["proof (state)\nthis:\n  adjoint\n   (2 \\<cdot>\\<^sub>m tensor_P proj_psi (1\\<^sub>m K) - 1\\<^sub>m d) =\n  2 \\<cdot>\\<^sub>m tensor_P proj_psi (1\\<^sub>m K) - 1\\<^sub>m d\n\ngoal (1 subgoal):\n 1. adjoint\n     (2 \\<cdot>\\<^sub>m tensor_P proj_psi (1\\<^sub>m K) - 1\\<^sub>m d) *\n    Q2 *\n    (2 \\<cdot>\\<^sub>m tensor_P proj_psi (1\\<^sub>m K) - 1\\<^sub>m d) =\n    Q1", "let ?m1 = \"tensor_P (2 \\<cdot>\\<^sub>m proj_psi - (1\\<^sub>m N)) (1\\<^sub>m K)\""], ["proof (state)\ngoal (1 subgoal):\n 1. adjoint\n     (2 \\<cdot>\\<^sub>m tensor_P proj_psi (1\\<^sub>m K) - 1\\<^sub>m d) *\n    Q2 *\n    (2 \\<cdot>\\<^sub>m tensor_P proj_psi (1\\<^sub>m K) - 1\\<^sub>m d) =\n    Q1", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. adjoint\n     (2 \\<cdot>\\<^sub>m tensor_P proj_psi (1\\<^sub>m K) - 1\\<^sub>m d) *\n    Q2 *\n    (2 \\<cdot>\\<^sub>m tensor_P proj_psi (1\\<^sub>m K) - 1\\<^sub>m d) =\n    Q1", "fix l"], ["proof (state)\ngoal (1 subgoal):\n 1. adjoint\n     (2 \\<cdot>\\<^sub>m tensor_P proj_psi (1\\<^sub>m K) - 1\\<^sub>m d) *\n    Q2 *\n    (2 \\<cdot>\\<^sub>m tensor_P proj_psi (1\\<^sub>m K) - 1\\<^sub>m d) =\n    Q1", "let ?m2 = \"tensor_P (proj_psi_l (l + 1)) (proj_k l)\""], ["proof (state)\ngoal (1 subgoal):\n 1. adjoint\n     (2 \\<cdot>\\<^sub>m tensor_P proj_psi (1\\<^sub>m K) - 1\\<^sub>m d) *\n    Q2 *\n    (2 \\<cdot>\\<^sub>m tensor_P proj_psi (1\\<^sub>m K) - 1\\<^sub>m d) =\n    Q1", "have 121: \"?m1 * ?m2 * ?m1 \n        = tensor_P ((2 \\<cdot>\\<^sub>m proj_psi - (1\\<^sub>m N)) * (proj_psi_l (l + 1)) * (2 \\<cdot>\\<^sub>m proj_psi - (1\\<^sub>m N)))\n            (proj_k l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tensor_P (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) (1\\<^sub>m K) *\n    tensor_P (proj_psi_l (l + 1)) (proj_k l) *\n    tensor_P (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) (1\\<^sub>m K) =\n    tensor_P\n     ((2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) * proj_psi_l (l + 1) *\n      (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N))\n     (proj_k l)", "apply (subst tensor_P_left_right_partial1)"], ["proof (prove)\ngoal (4 subgoals):\n 1. 2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N \\<in> carrier_mat N N\n 2. proj_psi_l (l + 1) \\<in> carrier_mat N N\n 3. proj_k l \\<in> carrier_mat K K\n 4. tensor_P\n     ((2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) * proj_psi_l (l + 1) *\n      (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N))\n     (proj_k l) =\n    tensor_P\n     ((2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) * proj_psi_l (l + 1) *\n      (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N))\n     (proj_k l)", "using proj_psi_dim proj_psi_l_dim proj_k_dim"], ["proof (prove)\nusing this:\n  proj_psi \\<in> carrier_mat N N\n  proj_psi_l ?l \\<in> carrier_mat N N\n  proj_k ?k \\<in> carrier_mat K K\n\ngoal (4 subgoals):\n 1. 2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N \\<in> carrier_mat N N\n 2. proj_psi_l (l + 1) \\<in> carrier_mat N N\n 3. proj_k l \\<in> carrier_mat K K\n 4. tensor_P\n     ((2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) * proj_psi_l (l + 1) *\n      (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N))\n     (proj_k l) =\n    tensor_P\n     ((2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) * proj_psi_l (l + 1) *\n      (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N))\n     (proj_k l)", "by auto"], ["proof (state)\nthis:\n  tensor_P (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) (1\\<^sub>m K) *\n  tensor_P (proj_psi_l (l + 1)) (proj_k l) *\n  tensor_P (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) (1\\<^sub>m K) =\n  tensor_P\n   ((2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) * proj_psi_l (l + 1) *\n    (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N))\n   (proj_k l)\n\ngoal (1 subgoal):\n 1. adjoint\n     (2 \\<cdot>\\<^sub>m tensor_P proj_psi (1\\<^sub>m K) - 1\\<^sub>m d) *\n    Q2 *\n    (2 \\<cdot>\\<^sub>m tensor_P proj_psi (1\\<^sub>m K) - 1\\<^sub>m d) =\n    Q1", "have \"(2 \\<cdot>\\<^sub>m proj_psi - (1\\<^sub>m N)) * (proj_psi_l (l + 1)) * (2 \\<cdot>\\<^sub>m proj_psi - (1\\<^sub>m N))\n      = outer_prod ((2 \\<cdot>\\<^sub>m proj_psi - (1\\<^sub>m N)) *\\<^sub>v (psi_l (l + 1))) ((2 \\<cdot>\\<^sub>m proj_psi - (1\\<^sub>m N)) *\\<^sub>v (psi_l (l + 1)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) * proj_psi_l (l + 1) *\n    (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) =\n    outer_prod\n     ((2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) *\\<^sub>v psi_l (l + 1))\n     ((2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) *\\<^sub>v psi_l (l + 1))", "unfolding proj_psi_l_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) *\n    outer_prod (psi_l (l + 1)) (psi_l (l + 1)) *\n    (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) =\n    outer_prod\n     ((2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) *\\<^sub>v psi_l (l + 1))\n     ((2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) *\\<^sub>v psi_l (l + 1))", "apply (subst outer_prod_left_right_mat[of _ N _ N _ N _ N])"], ["proof (prove)\ngoal (3 subgoals):\n 1. psi_l (l + 1) \\<in> carrier_vec N\n 2. 2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N \\<in> carrier_mat N N\n 3. outer_prod\n     ((2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) *\\<^sub>v psi_l (l + 1))\n     (adjoint (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) *\\<^sub>v\n      psi_l (l + 1)) =\n    outer_prod\n     ((2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) *\\<^sub>v psi_l (l + 1))\n     ((2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) *\\<^sub>v psi_l (l + 1))", "using proj_psi_dim psi_l_dim hermitian_proj_psi_minus_1[simplified hermitian_def]"], ["proof (prove)\nusing this:\n  proj_psi \\<in> carrier_mat N N\n  psi_l ?l \\<in> carrier_vec N\n  adjoint (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) =\n  2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N\n\ngoal (3 subgoals):\n 1. psi_l (l + 1) \\<in> carrier_vec N\n 2. 2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N \\<in> carrier_mat N N\n 3. outer_prod\n     ((2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) *\\<^sub>v psi_l (l + 1))\n     (adjoint (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) *\\<^sub>v\n      psi_l (l + 1)) =\n    outer_prod\n     ((2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) *\\<^sub>v psi_l (l + 1))\n     ((2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) *\\<^sub>v psi_l (l + 1))", "by auto"], ["proof (state)\nthis:\n  (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) * proj_psi_l (l + 1) *\n  (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) =\n  outer_prod\n   ((2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) *\\<^sub>v psi_l (l + 1))\n   ((2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) *\\<^sub>v psi_l (l + 1))\n\ngoal (1 subgoal):\n 1. adjoint\n     (2 \\<cdot>\\<^sub>m tensor_P proj_psi (1\\<^sub>m K) - 1\\<^sub>m d) *\n    Q2 *\n    (2 \\<cdot>\\<^sub>m tensor_P proj_psi (1\\<^sub>m K) - 1\\<^sub>m d) =\n    Q1", "also"], ["proof (state)\nthis:\n  (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) * proj_psi_l (l + 1) *\n  (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) =\n  outer_prod\n   ((2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) *\\<^sub>v psi_l (l + 1))\n   ((2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) *\\<^sub>v psi_l (l + 1))\n\ngoal (1 subgoal):\n 1. adjoint\n     (2 \\<cdot>\\<^sub>m tensor_P proj_psi (1\\<^sub>m K) - 1\\<^sub>m d) *\n    Q2 *\n    (2 \\<cdot>\\<^sub>m tensor_P proj_psi (1\\<^sub>m K) - 1\\<^sub>m d) =\n    Q1", "have \"\\<dots> = outer_prod (psi'_l l) (psi'_l l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. outer_prod\n     ((2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) *\\<^sub>v psi_l (l + 1))\n     ((2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) *\\<^sub>v psi_l (l + 1)) =\n    outer_prod (psi'_l l) (psi'_l l)", "using proj_psi_minus_1_mult_psi_Suc_l"], ["proof (prove)\nusing this:\n  (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) *\\<^sub>v psi_l (?l + 1) =\n  psi'_l ?l\n\ngoal (1 subgoal):\n 1. outer_prod\n     ((2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) *\\<^sub>v psi_l (l + 1))\n     ((2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) *\\<^sub>v psi_l (l + 1)) =\n    outer_prod (psi'_l l) (psi'_l l)", "by auto"], ["proof (state)\nthis:\n  outer_prod\n   ((2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) *\\<^sub>v psi_l (l + 1))\n   ((2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) *\\<^sub>v psi_l (l + 1)) =\n  outer_prod (psi'_l l) (psi'_l l)\n\ngoal (1 subgoal):\n 1. adjoint\n     (2 \\<cdot>\\<^sub>m tensor_P proj_psi (1\\<^sub>m K) - 1\\<^sub>m d) *\n    Q2 *\n    (2 \\<cdot>\\<^sub>m tensor_P proj_psi (1\\<^sub>m K) - 1\\<^sub>m d) =\n    Q1", "finally"], ["proof (chain)\npicking this:\n  (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) * proj_psi_l (l + 1) *\n  (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) =\n  outer_prod (psi'_l l) (psi'_l l)", "have \"(2 \\<cdot>\\<^sub>m proj_psi - (1\\<^sub>m N)) * (proj_psi_l (l + 1)) * (2 \\<cdot>\\<^sub>m proj_psi - (1\\<^sub>m N)) \n      = outer_prod (psi'_l l) (psi'_l l)\""], ["proof (prove)\nusing this:\n  (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) * proj_psi_l (l + 1) *\n  (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) =\n  outer_prod (psi'_l l) (psi'_l l)\n\ngoal (1 subgoal):\n 1. (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) * proj_psi_l (l + 1) *\n    (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) =\n    outer_prod (psi'_l l) (psi'_l l)", "."], ["proof (state)\nthis:\n  (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) * proj_psi_l (l + 1) *\n  (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) =\n  outer_prod (psi'_l l) (psi'_l l)\n\ngoal (1 subgoal):\n 1. adjoint\n     (2 \\<cdot>\\<^sub>m tensor_P proj_psi (1\\<^sub>m K) - 1\\<^sub>m d) *\n    Q2 *\n    (2 \\<cdot>\\<^sub>m tensor_P proj_psi (1\\<^sub>m K) - 1\\<^sub>m d) =\n    Q1", "then"], ["proof (chain)\npicking this:\n  (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) * proj_psi_l (l + 1) *\n  (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) =\n  outer_prod (psi'_l l) (psi'_l l)", "have \"?m1 * ?m2 * ?m1 = tensor_P (proj_psi'_l l) (proj_k l)\""], ["proof (prove)\nusing this:\n  (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) * proj_psi_l (l + 1) *\n  (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) =\n  outer_prod (psi'_l l) (psi'_l l)\n\ngoal (1 subgoal):\n 1. tensor_P (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) (1\\<^sub>m K) *\n    tensor_P (proj_psi_l (l + 1)) (proj_k l) *\n    tensor_P (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) (1\\<^sub>m K) =\n    tensor_P (proj_psi'_l l) (proj_k l)", "using 121 proj_psi'_l_def"], ["proof (prove)\nusing this:\n  (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) * proj_psi_l (l + 1) *\n  (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) =\n  outer_prod (psi'_l l) (psi'_l l)\n  tensor_P (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) (1\\<^sub>m K) *\n  tensor_P (proj_psi_l (l + 1)) (proj_k l) *\n  tensor_P (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) (1\\<^sub>m K) =\n  tensor_P\n   ((2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) * proj_psi_l (l + 1) *\n    (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N))\n   (proj_k l)\n  proj_psi'_l ?l = outer_prod (psi'_l ?l) (psi'_l ?l)\n\ngoal (1 subgoal):\n 1. tensor_P (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) (1\\<^sub>m K) *\n    tensor_P (proj_psi_l (l + 1)) (proj_k l) *\n    tensor_P (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) (1\\<^sub>m K) =\n    tensor_P (proj_psi'_l l) (proj_k l)", "by auto"], ["proof (state)\nthis:\n  tensor_P (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) (1\\<^sub>m K) *\n  tensor_P (proj_psi_l (l + 1)) (proj_k l) *\n  tensor_P (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) (1\\<^sub>m K) =\n  tensor_P (proj_psi'_l l) (proj_k l)\n\ngoal (1 subgoal):\n 1. adjoint\n     (2 \\<cdot>\\<^sub>m tensor_P proj_psi (1\\<^sub>m K) - 1\\<^sub>m d) *\n    Q2 *\n    (2 \\<cdot>\\<^sub>m tensor_P proj_psi (1\\<^sub>m K) - 1\\<^sub>m d) =\n    Q1", "}"], ["proof (state)\nthis:\n  tensor_P (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) (1\\<^sub>m K) *\n  tensor_P (proj_psi_l (?l4 + 1)) (proj_k ?l4) *\n  tensor_P (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) (1\\<^sub>m K) =\n  tensor_P (proj_psi'_l ?l4) (proj_k ?l4)\n\ngoal (1 subgoal):\n 1. adjoint\n     (2 \\<cdot>\\<^sub>m tensor_P proj_psi (1\\<^sub>m K) - 1\\<^sub>m d) *\n    Q2 *\n    (2 \\<cdot>\\<^sub>m tensor_P proj_psi (1\\<^sub>m K) - 1\\<^sub>m d) =\n    Q1", "note p1 = this"], ["proof (state)\nthis:\n  tensor_P (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) (1\\<^sub>m K) *\n  tensor_P (proj_psi_l (?l4 + 1)) (proj_k ?l4) *\n  tensor_P (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) (1\\<^sub>m K) =\n  tensor_P (proj_psi'_l ?l4) (proj_k ?l4)\n\ngoal (1 subgoal):\n 1. adjoint\n     (2 \\<cdot>\\<^sub>m tensor_P proj_psi (1\\<^sub>m K) - 1\\<^sub>m d) *\n    Q2 *\n    (2 \\<cdot>\\<^sub>m tensor_P proj_psi (1\\<^sub>m K) - 1\\<^sub>m d) =\n    Q1", "have \"adjoint (2 \\<cdot>\\<^sub>m tensor_P proj_psi (1\\<^sub>m K) - 1\\<^sub>m d) * Q2 * (2 \\<cdot>\\<^sub>m tensor_P proj_psi (1\\<^sub>m K) - 1\\<^sub>m d)\n    = (2 \\<cdot>\\<^sub>m tensor_P proj_psi (1\\<^sub>m K) - 1\\<^sub>m d) * Q2 * (2 \\<cdot>\\<^sub>m tensor_P proj_psi (1\\<^sub>m K) - 1\\<^sub>m d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adjoint\n     (2 \\<cdot>\\<^sub>m tensor_P proj_psi (1\\<^sub>m K) - 1\\<^sub>m d) *\n    Q2 *\n    (2 \\<cdot>\\<^sub>m tensor_P proj_psi (1\\<^sub>m K) - 1\\<^sub>m d) =\n    (2 \\<cdot>\\<^sub>m tensor_P proj_psi (1\\<^sub>m K) - 1\\<^sub>m d) * Q2 *\n    (2 \\<cdot>\\<^sub>m tensor_P proj_psi (1\\<^sub>m K) - 1\\<^sub>m d)", "using eq1"], ["proof (prove)\nusing this:\n  adjoint\n   (2 \\<cdot>\\<^sub>m tensor_P proj_psi (1\\<^sub>m K) - 1\\<^sub>m d) =\n  2 \\<cdot>\\<^sub>m tensor_P proj_psi (1\\<^sub>m K) - 1\\<^sub>m d\n\ngoal (1 subgoal):\n 1. adjoint\n     (2 \\<cdot>\\<^sub>m tensor_P proj_psi (1\\<^sub>m K) - 1\\<^sub>m d) *\n    Q2 *\n    (2 \\<cdot>\\<^sub>m tensor_P proj_psi (1\\<^sub>m K) - 1\\<^sub>m d) =\n    (2 \\<cdot>\\<^sub>m tensor_P proj_psi (1\\<^sub>m K) - 1\\<^sub>m d) * Q2 *\n    (2 \\<cdot>\\<^sub>m tensor_P proj_psi (1\\<^sub>m K) - 1\\<^sub>m d)", "by auto"], ["proof (state)\nthis:\n  adjoint\n   (2 \\<cdot>\\<^sub>m tensor_P proj_psi (1\\<^sub>m K) - 1\\<^sub>m d) *\n  Q2 *\n  (2 \\<cdot>\\<^sub>m tensor_P proj_psi (1\\<^sub>m K) - 1\\<^sub>m d) =\n  (2 \\<cdot>\\<^sub>m tensor_P proj_psi (1\\<^sub>m K) - 1\\<^sub>m d) * Q2 *\n  (2 \\<cdot>\\<^sub>m tensor_P proj_psi (1\\<^sub>m K) - 1\\<^sub>m d)\n\ngoal (1 subgoal):\n 1. adjoint\n     (2 \\<cdot>\\<^sub>m tensor_P proj_psi (1\\<^sub>m K) - 1\\<^sub>m d) *\n    Q2 *\n    (2 \\<cdot>\\<^sub>m tensor_P proj_psi (1\\<^sub>m K) - 1\\<^sub>m d) =\n    Q1", "also"], ["proof (state)\nthis:\n  adjoint\n   (2 \\<cdot>\\<^sub>m tensor_P proj_psi (1\\<^sub>m K) - 1\\<^sub>m d) *\n  Q2 *\n  (2 \\<cdot>\\<^sub>m tensor_P proj_psi (1\\<^sub>m K) - 1\\<^sub>m d) =\n  (2 \\<cdot>\\<^sub>m tensor_P proj_psi (1\\<^sub>m K) - 1\\<^sub>m d) * Q2 *\n  (2 \\<cdot>\\<^sub>m tensor_P proj_psi (1\\<^sub>m K) - 1\\<^sub>m d)\n\ngoal (1 subgoal):\n 1. adjoint\n     (2 \\<cdot>\\<^sub>m tensor_P proj_psi (1\\<^sub>m K) - 1\\<^sub>m d) *\n    Q2 *\n    (2 \\<cdot>\\<^sub>m tensor_P proj_psi (1\\<^sub>m K) - 1\\<^sub>m d) =\n    Q1", "have \"\\<dots> = matrix_sum d\n    (\\<lambda>l. (2 \\<cdot>\\<^sub>m tensor_P proj_psi (1\\<^sub>m K) - 1\\<^sub>m d) * tensor_P (proj_psi_l (l + 1)) (proj_k l) * (2 \\<cdot>\\<^sub>m tensor_P proj_psi (1\\<^sub>m K) - 1\\<^sub>m d))\n    R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (2 \\<cdot>\\<^sub>m tensor_P proj_psi (1\\<^sub>m K) - 1\\<^sub>m d) * Q2 *\n    (2 \\<cdot>\\<^sub>m tensor_P proj_psi (1\\<^sub>m K) - 1\\<^sub>m d) =\n    matrix_sum d\n     (\\<lambda>l.\n         (2 \\<cdot>\\<^sub>m tensor_P proj_psi (1\\<^sub>m K) - 1\\<^sub>m d) *\n         tensor_P (proj_psi_l (l + 1)) (proj_k l) *\n         (2 \\<cdot>\\<^sub>m tensor_P proj_psi (1\\<^sub>m K) - 1\\<^sub>m d))\n     R", "unfolding Q2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (2 \\<cdot>\\<^sub>m tensor_P proj_psi (1\\<^sub>m K) - 1\\<^sub>m d) *\n    matrix_sum d (\\<lambda>l. tensor_P (proj_psi_l (l + 1)) (proj_k l)) R *\n    (2 \\<cdot>\\<^sub>m tensor_P proj_psi (1\\<^sub>m K) - 1\\<^sub>m d) =\n    matrix_sum d\n     (\\<lambda>l.\n         (2 \\<cdot>\\<^sub>m tensor_P proj_psi (1\\<^sub>m K) - 1\\<^sub>m d) *\n         tensor_P (proj_psi_l (l + 1)) (proj_k l) *\n         (2 \\<cdot>\\<^sub>m tensor_P proj_psi (1\\<^sub>m K) - 1\\<^sub>m d))\n     R", "apply (subst matrix_sum_mult_left_right)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>k.\n       k < R \\<Longrightarrow>\n       tensor_P (proj_psi_l (k + 1)) (proj_k k) \\<in> carrier_mat d d\n 2. 2 \\<cdot>\\<^sub>m tensor_P proj_psi (1\\<^sub>m K) - 1\\<^sub>m d\n    \\<in> carrier_mat d d\n 3. (2 \\<cdot>\\<^sub>m tensor_P proj_psi (1\\<^sub>m K) - 1\\<^sub>m d) *\n    matrix_sum d (\\<lambda>l. tensor_P (proj_psi_l (l + 1)) (proj_k l)) R *\n    (2 \\<cdot>\\<^sub>m tensor_P proj_psi (1\\<^sub>m K) - 1\\<^sub>m d) =\n    (2 \\<cdot>\\<^sub>m tensor_P proj_psi (1\\<^sub>m K) - 1\\<^sub>m d) *\n    matrix_sum d (\\<lambda>l. tensor_P (proj_psi_l (l + 1)) (proj_k l)) R *\n    (2 \\<cdot>\\<^sub>m tensor_P proj_psi (1\\<^sub>m K) - 1\\<^sub>m d)", "using tensor_P_dim"], ["proof (prove)\nusing this:\n  tensor_P ?A ?B \\<in> carrier_mat d d\n\ngoal (3 subgoals):\n 1. \\<And>k.\n       k < R \\<Longrightarrow>\n       tensor_P (proj_psi_l (k + 1)) (proj_k k) \\<in> carrier_mat d d\n 2. 2 \\<cdot>\\<^sub>m tensor_P proj_psi (1\\<^sub>m K) - 1\\<^sub>m d\n    \\<in> carrier_mat d d\n 3. (2 \\<cdot>\\<^sub>m tensor_P proj_psi (1\\<^sub>m K) - 1\\<^sub>m d) *\n    matrix_sum d (\\<lambda>l. tensor_P (proj_psi_l (l + 1)) (proj_k l)) R *\n    (2 \\<cdot>\\<^sub>m tensor_P proj_psi (1\\<^sub>m K) - 1\\<^sub>m d) =\n    (2 \\<cdot>\\<^sub>m tensor_P proj_psi (1\\<^sub>m K) - 1\\<^sub>m d) *\n    matrix_sum d (\\<lambda>l. tensor_P (proj_psi_l (l + 1)) (proj_k l)) R *\n    (2 \\<cdot>\\<^sub>m tensor_P proj_psi (1\\<^sub>m K) - 1\\<^sub>m d)", "by auto"], ["proof (state)\nthis:\n  (2 \\<cdot>\\<^sub>m tensor_P proj_psi (1\\<^sub>m K) - 1\\<^sub>m d) * Q2 *\n  (2 \\<cdot>\\<^sub>m tensor_P proj_psi (1\\<^sub>m K) - 1\\<^sub>m d) =\n  matrix_sum d\n   (\\<lambda>l.\n       (2 \\<cdot>\\<^sub>m tensor_P proj_psi (1\\<^sub>m K) - 1\\<^sub>m d) *\n       tensor_P (proj_psi_l (l + 1)) (proj_k l) *\n       (2 \\<cdot>\\<^sub>m tensor_P proj_psi (1\\<^sub>m K) - 1\\<^sub>m d))\n   R\n\ngoal (1 subgoal):\n 1. adjoint\n     (2 \\<cdot>\\<^sub>m tensor_P proj_psi (1\\<^sub>m K) - 1\\<^sub>m d) *\n    Q2 *\n    (2 \\<cdot>\\<^sub>m tensor_P proj_psi (1\\<^sub>m K) - 1\\<^sub>m d) =\n    Q1", "also"], ["proof (state)\nthis:\n  (2 \\<cdot>\\<^sub>m tensor_P proj_psi (1\\<^sub>m K) - 1\\<^sub>m d) * Q2 *\n  (2 \\<cdot>\\<^sub>m tensor_P proj_psi (1\\<^sub>m K) - 1\\<^sub>m d) =\n  matrix_sum d\n   (\\<lambda>l.\n       (2 \\<cdot>\\<^sub>m tensor_P proj_psi (1\\<^sub>m K) - 1\\<^sub>m d) *\n       tensor_P (proj_psi_l (l + 1)) (proj_k l) *\n       (2 \\<cdot>\\<^sub>m tensor_P proj_psi (1\\<^sub>m K) - 1\\<^sub>m d))\n   R\n\ngoal (1 subgoal):\n 1. adjoint\n     (2 \\<cdot>\\<^sub>m tensor_P proj_psi (1\\<^sub>m K) - 1\\<^sub>m d) *\n    Q2 *\n    (2 \\<cdot>\\<^sub>m tensor_P proj_psi (1\\<^sub>m K) - 1\\<^sub>m d) =\n    Q1", "have \"\\<dots> = matrix_sum d (\\<lambda>l. tensor_P (proj_psi'_l l) (proj_k l)) R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_sum d\n     (\\<lambda>l.\n         (2 \\<cdot>\\<^sub>m tensor_P proj_psi (1\\<^sub>m K) - 1\\<^sub>m d) *\n         tensor_P (proj_psi_l (l + 1)) (proj_k l) *\n         (2 \\<cdot>\\<^sub>m tensor_P proj_psi (1\\<^sub>m K) - 1\\<^sub>m d))\n     R =\n    matrix_sum d (\\<lambda>l. tensor_P (proj_psi'_l l) (proj_k l)) R", "using p1 exproj_psi_minus_1_tensor"], ["proof (prove)\nusing this:\n  tensor_P (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) (1\\<^sub>m K) *\n  tensor_P (proj_psi_l (?l4 + 1)) (proj_k ?l4) *\n  tensor_P (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) (1\\<^sub>m K) =\n  tensor_P (proj_psi'_l ?l4) (proj_k ?l4)\n  2 \\<cdot>\\<^sub>m tensor_P proj_psi (1\\<^sub>m K) - 1\\<^sub>m d =\n  tensor_P (2 \\<cdot>\\<^sub>m proj_psi - 1\\<^sub>m N) (1\\<^sub>m K)\n\ngoal (1 subgoal):\n 1. matrix_sum d\n     (\\<lambda>l.\n         (2 \\<cdot>\\<^sub>m tensor_P proj_psi (1\\<^sub>m K) - 1\\<^sub>m d) *\n         tensor_P (proj_psi_l (l + 1)) (proj_k l) *\n         (2 \\<cdot>\\<^sub>m tensor_P proj_psi (1\\<^sub>m K) - 1\\<^sub>m d))\n     R =\n    matrix_sum d (\\<lambda>l. tensor_P (proj_psi'_l l) (proj_k l)) R", "by auto"], ["proof (state)\nthis:\n  matrix_sum d\n   (\\<lambda>l.\n       (2 \\<cdot>\\<^sub>m tensor_P proj_psi (1\\<^sub>m K) - 1\\<^sub>m d) *\n       tensor_P (proj_psi_l (l + 1)) (proj_k l) *\n       (2 \\<cdot>\\<^sub>m tensor_P proj_psi (1\\<^sub>m K) - 1\\<^sub>m d))\n   R =\n  matrix_sum d (\\<lambda>l. tensor_P (proj_psi'_l l) (proj_k l)) R\n\ngoal (1 subgoal):\n 1. adjoint\n     (2 \\<cdot>\\<^sub>m tensor_P proj_psi (1\\<^sub>m K) - 1\\<^sub>m d) *\n    Q2 *\n    (2 \\<cdot>\\<^sub>m tensor_P proj_psi (1\\<^sub>m K) - 1\\<^sub>m d) =\n    Q1", "also"], ["proof (state)\nthis:\n  matrix_sum d\n   (\\<lambda>l.\n       (2 \\<cdot>\\<^sub>m tensor_P proj_psi (1\\<^sub>m K) - 1\\<^sub>m d) *\n       tensor_P (proj_psi_l (l + 1)) (proj_k l) *\n       (2 \\<cdot>\\<^sub>m tensor_P proj_psi (1\\<^sub>m K) - 1\\<^sub>m d))\n   R =\n  matrix_sum d (\\<lambda>l. tensor_P (proj_psi'_l l) (proj_k l)) R\n\ngoal (1 subgoal):\n 1. adjoint\n     (2 \\<cdot>\\<^sub>m tensor_P proj_psi (1\\<^sub>m K) - 1\\<^sub>m d) *\n    Q2 *\n    (2 \\<cdot>\\<^sub>m tensor_P proj_psi (1\\<^sub>m K) - 1\\<^sub>m d) =\n    Q1", "have \"\\<dots> = Q1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_sum d (\\<lambda>l. tensor_P (proj_psi'_l l) (proj_k l)) R = Q1", "unfolding Q1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_sum d (\\<lambda>l. tensor_P (proj_psi'_l l) (proj_k l)) R =\n    matrix_sum d (\\<lambda>l. tensor_P (proj_psi'_l l) (proj_k l)) R", "by auto"], ["proof (state)\nthis:\n  matrix_sum d (\\<lambda>l. tensor_P (proj_psi'_l l) (proj_k l)) R = Q1\n\ngoal (1 subgoal):\n 1. adjoint\n     (2 \\<cdot>\\<^sub>m tensor_P proj_psi (1\\<^sub>m K) - 1\\<^sub>m d) *\n    Q2 *\n    (2 \\<cdot>\\<^sub>m tensor_P proj_psi (1\\<^sub>m K) - 1\\<^sub>m d) =\n    Q1", "finally"], ["proof (chain)\npicking this:\n  adjoint\n   (2 \\<cdot>\\<^sub>m tensor_P proj_psi (1\\<^sub>m K) - 1\\<^sub>m d) *\n  Q2 *\n  (2 \\<cdot>\\<^sub>m tensor_P proj_psi (1\\<^sub>m K) - 1\\<^sub>m d) =\n  Q1", "show ?thesis"], ["proof (prove)\nusing this:\n  adjoint\n   (2 \\<cdot>\\<^sub>m tensor_P proj_psi (1\\<^sub>m K) - 1\\<^sub>m d) *\n  Q2 *\n  (2 \\<cdot>\\<^sub>m tensor_P proj_psi (1\\<^sub>m K) - 1\\<^sub>m d) =\n  Q1\n\ngoal (1 subgoal):\n 1. adjoint\n     (2 \\<cdot>\\<^sub>m tensor_P proj_psi (1\\<^sub>m K) - 1\\<^sub>m d) *\n    Q2 *\n    (2 \\<cdot>\\<^sub>m tensor_P proj_psi (1\\<^sub>m K) - 1\\<^sub>m d) =\n    Q1", "using eq1"], ["proof (prove)\nusing this:\n  adjoint\n   (2 \\<cdot>\\<^sub>m tensor_P proj_psi (1\\<^sub>m K) - 1\\<^sub>m d) *\n  Q2 *\n  (2 \\<cdot>\\<^sub>m tensor_P proj_psi (1\\<^sub>m K) - 1\\<^sub>m d) =\n  Q1\n  adjoint\n   (2 \\<cdot>\\<^sub>m tensor_P proj_psi (1\\<^sub>m K) - 1\\<^sub>m d) =\n  2 \\<cdot>\\<^sub>m tensor_P proj_psi (1\\<^sub>m K) - 1\\<^sub>m d\n\ngoal (1 subgoal):\n 1. adjoint\n     (2 \\<cdot>\\<^sub>m tensor_P proj_psi (1\\<^sub>m K) - 1\\<^sub>m d) *\n    Q2 *\n    (2 \\<cdot>\\<^sub>m tensor_P proj_psi (1\\<^sub>m K) - 1\\<^sub>m d) =\n    Q1", "by auto"], ["proof (state)\nthis:\n  adjoint\n   (2 \\<cdot>\\<^sub>m tensor_P proj_psi (1\\<^sub>m K) - 1\\<^sub>m d) *\n  Q2 *\n  (2 \\<cdot>\\<^sub>m tensor_P proj_psi (1\\<^sub>m K) - 1\\<^sub>m d) =\n  Q1\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma qp_Q1:\n  \"is_quantum_predicate Q1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_quantum_predicate Q1", "unfolding proj_psi_minus_1_Q2[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_quantum_predicate\n     (adjoint\n       (2 \\<cdot>\\<^sub>m tensor_P proj_psi (1\\<^sub>m K) - 1\\<^sub>m d) *\n      Q2 *\n      (2 \\<cdot>\\<^sub>m tensor_P proj_psi (1\\<^sub>m K) - 1\\<^sub>m d))", "apply (subst qp_close_under_unitary_operator)"], ["proof (prove)\ngoal (4 subgoals):\n 1. 2 \\<cdot>\\<^sub>m tensor_P proj_psi (1\\<^sub>m K) - 1\\<^sub>m d\n    \\<in> carrier_mat d d\n 2. unitary\n     (2 \\<cdot>\\<^sub>m tensor_P proj_psi (1\\<^sub>m K) - 1\\<^sub>m d)\n 3. is_quantum_predicate Q2\n 4. True", "using tensor_P_dim unitary_exproj_psi_minus_1 qp_Q2"], ["proof (prove)\nusing this:\n  tensor_P ?A ?B \\<in> carrier_mat d d\n  unitary (2 \\<cdot>\\<^sub>m tensor_P proj_psi (1\\<^sub>m K) - 1\\<^sub>m d)\n  is_quantum_predicate Q2\n\ngoal (4 subgoals):\n 1. 2 \\<cdot>\\<^sub>m tensor_P proj_psi (1\\<^sub>m K) - 1\\<^sub>m d\n    \\<in> carrier_mat d d\n 2. unitary\n     (2 \\<cdot>\\<^sub>m tensor_P proj_psi (1\\<^sub>m K) - 1\\<^sub>m d)\n 3. is_quantum_predicate Q2\n 4. True", "by auto"], ["", "lemma qp_Q:\n  \"is_quantum_predicate Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_quantum_predicate Q", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. is_quantum_predicate Q", "have u: \"unitary (tensor_P mat_O (1\\<^sub>m K))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unitary (tensor_P mat_O (1\\<^sub>m K))", "unfolding ps2_P.ptensor_mat_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. unitary (ps_P.tensor_mat mat_O (1\\<^sub>m K))", "apply (subst ps_P.tensor_mat_unitary)"], ["proof (prove)\ngoal (5 subgoals):\n 1. mat_O \\<in> carrier_mat ps_P.d1 ps_P.d1\n 2. 1\\<^sub>m K \\<in> carrier_mat ps_P.d2 ps_P.d2\n 3. unitary mat_O\n 4. unitary (1\\<^sub>m K)\n 5. True", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_O \\<in> carrier_mat ps_P.d1 ps_P.d1", "unfolding ps_P_d1 mat_O_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat N N (\\<lambda>(i, j). if i = j then if f i then - 1 else 1 else 0)\n    \\<in> carrier_mat N N", "by auto"], ["proof (prove)\ngoal (4 subgoals):\n 1. 1\\<^sub>m K \\<in> carrier_mat ps_P.d2 ps_P.d2\n 2. unitary mat_O\n 3. unitary (1\\<^sub>m K)\n 4. True", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1\\<^sub>m K \\<in> carrier_mat ps_P.d2 ps_P.d2", "unfolding ps_P_d2"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1\\<^sub>m K \\<in> carrier_mat K K", "by auto"], ["proof (prove)\ngoal (3 subgoals):\n 1. unitary mat_O\n 2. unitary (1\\<^sub>m K)\n 3. True", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. unitary mat_O", "using unitary_mat_O"], ["proof (prove)\nusing this:\n  unitary mat_O\n\ngoal (1 subgoal):\n 1. unitary mat_O", "by auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. unitary (1\\<^sub>m K)\n 2. True", "using unitary_one"], ["proof (prove)\nusing this:\n  unitary (1\\<^sub>m ?n)\n\ngoal (2 subgoals):\n 1. unitary (1\\<^sub>m K)\n 2. True", "by auto"], ["proof (state)\nthis:\n  unitary (tensor_P mat_O (1\\<^sub>m K))\n\ngoal (1 subgoal):\n 1. is_quantum_predicate Q", "then"], ["proof (chain)\npicking this:\n  unitary (tensor_P mat_O (1\\<^sub>m K))", "show ?thesis"], ["proof (prove)\nusing this:\n  unitary (tensor_P mat_O (1\\<^sub>m K))\n\ngoal (1 subgoal):\n 1. is_quantum_predicate Q", "using tensor_P_dim qp_Q1"], ["proof (prove)\nusing this:\n  unitary (tensor_P mat_O (1\\<^sub>m K))\n  tensor_P ?A ?B \\<in> carrier_mat d d\n  is_quantum_predicate Q1\n\ngoal (1 subgoal):\n 1. is_quantum_predicate Q", "using qp_close_under_unitary_operator[OF tensor_P_dim u qp_Q1]"], ["proof (prove)\nusing this:\n  unitary (tensor_P mat_O (1\\<^sub>m K))\n  tensor_P ?A ?B \\<in> carrier_mat d d\n  is_quantum_predicate Q1\n  is_quantum_predicate\n   (adjoint (tensor_P mat_O (1\\<^sub>m K)) * Q1 *\n    tensor_P mat_O (1\\<^sub>m K))\n\ngoal (1 subgoal):\n 1. is_quantum_predicate Q", "by (simp add: mat_O_times_Q1 )"], ["proof (state)\nthis:\n  is_quantum_predicate Q\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma hoare_triple_D1:\n  \"\\<turnstile>\\<^sub>p \n   {Q} \n   Utrans_P vars1 mat_O\n   {Q1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>p {Q} Utrans_P vars1 mat_O {Q1}", "unfolding Utrans_P_is_tensor_P1\n    mat_O_times_Q1[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>p {adjoint (tensor_P mat_O (1\\<^sub>m K)) * Q1 *\n                          tensor_P mat_O (1\\<^sub>m K)}\n                         Utrans (tensor_P mat_O (1\\<^sub>m K)) {Q1}", "apply (subst hoare_partial.intros(2))"], ["proof (prove)\ngoal (2 subgoals):\n 1. is_quantum_predicate Q1\n 2. True", "using qp_Q1"], ["proof (prove)\nusing this:\n  is_quantum_predicate Q1\n\ngoal (2 subgoals):\n 1. is_quantum_predicate Q1\n 2. True", "by auto"], ["", "lemma hoare_triple_D2:\n  \"\\<turnstile>\\<^sub>p \n   {Q1}\n   hadamard_n n ;;\n   Utrans_P vars1 mat_Ph ;;\n   hadamard_n n \n   {Q2}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>p {Q1}\n                         hadamard_n n;; Utrans_P vars1 mat_Ph;; hadamard_n n\n                         {Q2}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>p {Q1}\n                         hadamard_n n;; Utrans_P vars1 mat_Ph;; hadamard_n n\n                         {Q2}", "let ?H = \"exexH_k (n - 1)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>p {Q1}\n                         hadamard_n n;; Utrans_P vars1 mat_Ph;; hadamard_n n\n                         {Q2}", "let ?Ph = \"tensor_P mat_Ph (1\\<^sub>m K)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>p {Q1}\n                         hadamard_n n;; Utrans_P vars1 mat_Ph;; hadamard_n n\n                         {Q2}", "let ?O = \"tensor_P mat_O (1\\<^sub>m K)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>p {Q1}\n                         hadamard_n n;; Utrans_P vars1 mat_Ph;; hadamard_n n\n                         {Q2}", "have h1: \"\\<turnstile>\\<^sub>p \n    {adjoint ?H * Q2 * ?H} \n    hadamard_n n \n    {Q2}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>p {adjoint (exexH_k (n - 1)) * Q2 * exexH_k (n - 1)}\n                         hadamard_n n {Q2}", "using hoare_hadamard_n[OF qp_Q2, of \"n - 1\"] n"], ["proof (prove)\nusing this:\n  n - 1 < n \\<Longrightarrow>\n  \\<turnstile>\\<^sub>p {adjoint (exexH_k (n - 1)) * Q2 * exexH_k (n - 1)}\n                       hadamard_n (Suc (n - 1)) {Q2}\n  1 < n\n\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>p {adjoint (exexH_k (n - 1)) * Q2 * exexH_k (n - 1)}\n                         hadamard_n n {Q2}", "by auto"], ["proof (state)\nthis:\n  \\<turnstile>\\<^sub>p {adjoint (exexH_k (n - 1)) * Q2 * exexH_k (n - 1)}\n                       hadamard_n n {Q2}\n\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>p {Q1}\n                         hadamard_n n;; Utrans_P vars1 mat_Ph;; hadamard_n n\n                         {Q2}", "have qp1: \"is_quantum_predicate ((adjoint ?H) * Q2 * ?H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_quantum_predicate (adjoint (exexH_k (n - 1)) * Q2 * exexH_k (n - 1))", "using qp_close_under_unitary_operator unitary_exexH_k n exexH_k_dim qp_Q2"], ["proof (prove)\nusing this:\n  \\<lbrakk>?U \\<in> carrier_mat d d; unitary ?U;\n   is_quantum_predicate ?P\\<rbrakk>\n  \\<Longrightarrow> is_quantum_predicate (adjoint ?U * ?P * ?U)\n  ?k < n \\<Longrightarrow> unitary (exexH_k ?k)\n  1 < n\n  ?k < n \\<Longrightarrow> exexH_k ?k \\<in> carrier_mat d d\n  is_quantum_predicate Q2\n\ngoal (1 subgoal):\n 1. is_quantum_predicate (adjoint (exexH_k (n - 1)) * Q2 * exexH_k (n - 1))", "by auto"], ["proof (state)\nthis:\n  is_quantum_predicate (adjoint (exexH_k (n - 1)) * Q2 * exexH_k (n - 1))\n\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>p {Q1}\n                         hadamard_n n;; Utrans_P vars1 mat_Ph;; hadamard_n n\n                         {Q2}", "then"], ["proof (chain)\npicking this:\n  is_quantum_predicate (adjoint (exexH_k (n - 1)) * Q2 * exexH_k (n - 1))", "have h2: \"\\<turnstile>\\<^sub>p \n    {adjoint ?Ph * (adjoint ?H * Q2 * ?H) * ?Ph} \n    Utrans_P vars1 mat_Ph \n    {adjoint ?H * Q2 * ?H}\""], ["proof (prove)\nusing this:\n  is_quantum_predicate (adjoint (exexH_k (n - 1)) * Q2 * exexH_k (n - 1))\n\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>p {adjoint (tensor_P mat_Ph (1\\<^sub>m K)) *\n                          (adjoint (exexH_k (n - 1)) * Q2 *\n                           exexH_k (n - 1)) *\n                          tensor_P mat_Ph (1\\<^sub>m K)}\n                         Utrans_P vars1 mat_Ph\n                         {adjoint (exexH_k (n - 1)) * Q2 * exexH_k (n - 1)}", "using qp1 Utrans_P_is_tensor_P1 hoare_partial.intros"], ["proof (prove)\nusing this:\n  is_quantum_predicate (adjoint (exexH_k (n - 1)) * Q2 * exexH_k (n - 1))\n  is_quantum_predicate (adjoint (exexH_k (n - 1)) * Q2 * exexH_k (n - 1))\n  Utrans_P vars1 ?A = Utrans (tensor_P ?A (1\\<^sub>m K))\n  is_quantum_predicate ?P \\<Longrightarrow>\n  \\<turnstile>\\<^sub>p {?P} SKIP {?P}\n  is_quantum_predicate ?P \\<Longrightarrow>\n  \\<turnstile>\\<^sub>p {adjoint ?U * ?P * ?U} Utrans ?U {?P}\n  \\<lbrakk>is_quantum_predicate ?P; is_quantum_predicate ?Q;\n   is_quantum_predicate ?R; \\<turnstile>\\<^sub>p {?P} ?S1.0 {?Q};\n   \\<turnstile>\\<^sub>p {?Q} ?S2.0 {?R}\\<rbrakk>\n  \\<Longrightarrow> \\<turnstile>\\<^sub>p {?P} ?S1.0;; ?S2.0 {?R}\n  \\<lbrakk>\\<And>k. k < ?n \\<Longrightarrow> is_quantum_predicate (?P k);\n   is_quantum_predicate ?Q;\n   \\<And>k.\n      k < ?n \\<Longrightarrow>\n      \\<turnstile>\\<^sub>p {?P k} ?S ! k {?Q}\\<rbrakk>\n  \\<Longrightarrow> \\<turnstile>\\<^sub>p {matrix_sum d\n     (\\<lambda>k. adjoint (?M k) * ?P k * ?M k) ?n}\n   Measure ?n ?M ?S {?Q}\n  \\<lbrakk>is_quantum_predicate ?P; is_quantum_predicate ?Q;\n   \\<turnstile>\\<^sub>p {?Q} ?S\n                        {adjoint (?M 0) * ?P * ?M 0 +\n                         adjoint (?M 1) * ?Q * ?M 1}\\<rbrakk>\n  \\<Longrightarrow> \\<turnstile>\\<^sub>p {adjoint (?M 0) * ?P * ?M 0 +\n    adjoint (?M 1) * ?Q * ?M 1}\n   While ?M ?S {?P}\n  \\<lbrakk>is_quantum_predicate ?P; is_quantum_predicate ?Q;\n   is_quantum_predicate ?P'; is_quantum_predicate ?Q'; ?P \\<le>\\<^sub>L ?P';\n   \\<turnstile>\\<^sub>p {?P'} ?S {?Q'}; ?Q' \\<le>\\<^sub>L ?Q\\<rbrakk>\n  \\<Longrightarrow> \\<turnstile>\\<^sub>p {?P} ?S {?Q}\n\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>p {adjoint (tensor_P mat_Ph (1\\<^sub>m K)) *\n                          (adjoint (exexH_k (n - 1)) * Q2 *\n                           exexH_k (n - 1)) *\n                          tensor_P mat_Ph (1\\<^sub>m K)}\n                         Utrans_P vars1 mat_Ph\n                         {adjoint (exexH_k (n - 1)) * Q2 * exexH_k (n - 1)}", "by auto"], ["proof (state)\nthis:\n  \\<turnstile>\\<^sub>p {adjoint (tensor_P mat_Ph (1\\<^sub>m K)) *\n                        (adjoint (exexH_k (n - 1)) * Q2 * exexH_k (n - 1)) *\n                        tensor_P mat_Ph (1\\<^sub>m K)}\n                       Utrans_P vars1 mat_Ph\n                       {adjoint (exexH_k (n - 1)) * Q2 * exexH_k (n - 1)}\n\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>p {Q1}\n                         hadamard_n n;; Utrans_P vars1 mat_Ph;; hadamard_n n\n                         {Q2}", "have qp2: \"is_quantum_predicate (adjoint ?Ph * (adjoint ?H * Q2 * ?H) * ?Ph)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_quantum_predicate\n     (adjoint (tensor_P mat_Ph (1\\<^sub>m K)) *\n      (adjoint (exexH_k (n - 1)) * Q2 * exexH_k (n - 1)) *\n      tensor_P mat_Ph (1\\<^sub>m K))", "using qp_close_under_unitary_operator[of \"tensor_P mat_Ph (1\\<^sub>m K)\"] ps2_P.ptensor_mat_carrier ps2_P_d0 unitary_ex_mat_Ph qp1"], ["proof (prove)\nusing this:\n  \\<lbrakk>tensor_P mat_Ph (1\\<^sub>m K) \\<in> carrier_mat d d;\n   unitary (tensor_P mat_Ph (1\\<^sub>m K)); is_quantum_predicate ?P\\<rbrakk>\n  \\<Longrightarrow> is_quantum_predicate\n                     (adjoint (tensor_P mat_Ph (1\\<^sub>m K)) * ?P *\n                      tensor_P mat_Ph (1\\<^sub>m K))\n  tensor_P ?m1.0 ?m2.0 \\<in> carrier_mat ps2_P.d0 ps2_P.d0\n  ps2_P.d0 = d\n  unitary (tensor_P mat_Ph (1\\<^sub>m K))\n  is_quantum_predicate (adjoint (exexH_k (n - 1)) * Q2 * exexH_k (n - 1))\n\ngoal (1 subgoal):\n 1. is_quantum_predicate\n     (adjoint (tensor_P mat_Ph (1\\<^sub>m K)) *\n      (adjoint (exexH_k (n - 1)) * Q2 * exexH_k (n - 1)) *\n      tensor_P mat_Ph (1\\<^sub>m K))", "by auto"], ["proof (state)\nthis:\n  is_quantum_predicate\n   (adjoint (tensor_P mat_Ph (1\\<^sub>m K)) *\n    (adjoint (exexH_k (n - 1)) * Q2 * exexH_k (n - 1)) *\n    tensor_P mat_Ph (1\\<^sub>m K))\n\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>p {Q1}\n                         hadamard_n n;; Utrans_P vars1 mat_Ph;; hadamard_n n\n                         {Q2}", "then"], ["proof (chain)\npicking this:\n  is_quantum_predicate\n   (adjoint (tensor_P mat_Ph (1\\<^sub>m K)) *\n    (adjoint (exexH_k (n - 1)) * Q2 * exexH_k (n - 1)) *\n    tensor_P mat_Ph (1\\<^sub>m K))", "have  h3: \"\\<turnstile>\\<^sub>p \n    {adjoint ?H * (adjoint ?Ph * (adjoint ?H * Q2 * ?H) * ?Ph) * ?H} \n    hadamard_n n \n    {adjoint ?Ph * (adjoint ?H * Q2 * ?H) * ?Ph}\""], ["proof (prove)\nusing this:\n  is_quantum_predicate\n   (adjoint (tensor_P mat_Ph (1\\<^sub>m K)) *\n    (adjoint (exexH_k (n - 1)) * Q2 * exexH_k (n - 1)) *\n    tensor_P mat_Ph (1\\<^sub>m K))\n\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>p {adjoint (exexH_k (n - 1)) *\n                          (adjoint (tensor_P mat_Ph (1\\<^sub>m K)) *\n                           (adjoint (exexH_k (n - 1)) * Q2 *\n                            exexH_k (n - 1)) *\n                           tensor_P mat_Ph (1\\<^sub>m K)) *\n                          exexH_k (n - 1)}\n                         hadamard_n n\n                         {adjoint (tensor_P mat_Ph (1\\<^sub>m K)) *\n                          (adjoint (exexH_k (n - 1)) * Q2 *\n                           exexH_k (n - 1)) *\n                          tensor_P mat_Ph (1\\<^sub>m K)}", "using hoare_hadamard_n[OF qp2, of \"n - 1\"] n"], ["proof (prove)\nusing this:\n  is_quantum_predicate\n   (adjoint (tensor_P mat_Ph (1\\<^sub>m K)) *\n    (adjoint (exexH_k (n - 1)) * Q2 * exexH_k (n - 1)) *\n    tensor_P mat_Ph (1\\<^sub>m K))\n  n - 1 < n \\<Longrightarrow>\n  \\<turnstile>\\<^sub>p {adjoint (exexH_k (n - 1)) *\n                        (adjoint (tensor_P mat_Ph (1\\<^sub>m K)) *\n                         (adjoint (exexH_k (n - 1)) * Q2 *\n                          exexH_k (n - 1)) *\n                         tensor_P mat_Ph (1\\<^sub>m K)) *\n                        exexH_k (n - 1)}\n                       hadamard_n (Suc (n - 1))\n                       {adjoint (tensor_P mat_Ph (1\\<^sub>m K)) *\n                        (adjoint (exexH_k (n - 1)) * Q2 * exexH_k (n - 1)) *\n                        tensor_P mat_Ph (1\\<^sub>m K)}\n  1 < n\n\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>p {adjoint (exexH_k (n - 1)) *\n                          (adjoint (tensor_P mat_Ph (1\\<^sub>m K)) *\n                           (adjoint (exexH_k (n - 1)) * Q2 *\n                            exexH_k (n - 1)) *\n                           tensor_P mat_Ph (1\\<^sub>m K)) *\n                          exexH_k (n - 1)}\n                         hadamard_n n\n                         {adjoint (tensor_P mat_Ph (1\\<^sub>m K)) *\n                          (adjoint (exexH_k (n - 1)) * Q2 *\n                           exexH_k (n - 1)) *\n                          tensor_P mat_Ph (1\\<^sub>m K)}", "by auto"], ["proof (state)\nthis:\n  \\<turnstile>\\<^sub>p {adjoint (exexH_k (n - 1)) *\n                        (adjoint (tensor_P mat_Ph (1\\<^sub>m K)) *\n                         (adjoint (exexH_k (n - 1)) * Q2 *\n                          exexH_k (n - 1)) *\n                         tensor_P mat_Ph (1\\<^sub>m K)) *\n                        exexH_k (n - 1)}\n                       hadamard_n n\n                       {adjoint (tensor_P mat_Ph (1\\<^sub>m K)) *\n                        (adjoint (exexH_k (n - 1)) * Q2 * exexH_k (n - 1)) *\n                        tensor_P mat_Ph (1\\<^sub>m K)}\n\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>p {Q1}\n                         hadamard_n n;; Utrans_P vars1 mat_Ph;; hadamard_n n\n                         {Q2}", "have qp3: \"is_quantum_predicate (adjoint ?H * (adjoint ?Ph * (adjoint ?H * Q2 * ?H) * ?Ph) * ?H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_quantum_predicate\n     (adjoint (exexH_k (n - 1)) *\n      (adjoint (tensor_P mat_Ph (1\\<^sub>m K)) *\n       (adjoint (exexH_k (n - 1)) * Q2 * exexH_k (n - 1)) *\n       tensor_P mat_Ph (1\\<^sub>m K)) *\n      exexH_k (n - 1))", "using qp_close_under_unitary_operator[of \"?H\"] exexH_k_dim unitary_exexH_k qp2 n"], ["proof (prove)\nusing this:\n  \\<lbrakk>exexH_k (n - 1) \\<in> carrier_mat d d; unitary (exexH_k (n - 1));\n   is_quantum_predicate ?P\\<rbrakk>\n  \\<Longrightarrow> is_quantum_predicate\n                     (adjoint (exexH_k (n - 1)) * ?P * exexH_k (n - 1))\n  ?k < n \\<Longrightarrow> exexH_k ?k \\<in> carrier_mat d d\n  ?k < n \\<Longrightarrow> unitary (exexH_k ?k)\n  is_quantum_predicate\n   (adjoint (tensor_P mat_Ph (1\\<^sub>m K)) *\n    (adjoint (exexH_k (n - 1)) * Q2 * exexH_k (n - 1)) *\n    tensor_P mat_Ph (1\\<^sub>m K))\n  1 < n\n\ngoal (1 subgoal):\n 1. is_quantum_predicate\n     (adjoint (exexH_k (n - 1)) *\n      (adjoint (tensor_P mat_Ph (1\\<^sub>m K)) *\n       (adjoint (exexH_k (n - 1)) * Q2 * exexH_k (n - 1)) *\n       tensor_P mat_Ph (1\\<^sub>m K)) *\n      exexH_k (n - 1))", "by auto"], ["proof (state)\nthis:\n  is_quantum_predicate\n   (adjoint (exexH_k (n - 1)) *\n    (adjoint (tensor_P mat_Ph (1\\<^sub>m K)) *\n     (adjoint (exexH_k (n - 1)) * Q2 * exexH_k (n - 1)) *\n     tensor_P mat_Ph (1\\<^sub>m K)) *\n    exexH_k (n - 1))\n\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>p {Q1}\n                         hadamard_n n;; Utrans_P vars1 mat_Ph;; hadamard_n n\n                         {Q2}", "have h4: \"\\<turnstile>\\<^sub>p \n    {adjoint ?H * (adjoint ?Ph * (adjoint ?H * Q2 * ?H) * ?Ph) * ?H} \n    hadamard_n n ;;\n    Utrans_P vars1 mat_Ph\n    {adjoint ?H * Q2 * ?H}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>p {adjoint (exexH_k (n - 1)) *\n                          (adjoint (tensor_P mat_Ph (1\\<^sub>m K)) *\n                           (adjoint (exexH_k (n - 1)) * Q2 *\n                            exexH_k (n - 1)) *\n                           tensor_P mat_Ph (1\\<^sub>m K)) *\n                          exexH_k (n - 1)}\n                         hadamard_n n;; Utrans_P vars1 mat_Ph\n                         {adjoint (exexH_k (n - 1)) * Q2 * exexH_k (n - 1)}", "using h2 h3 qp1 qp2 qp3 hoare_partial.intros"], ["proof (prove)\nusing this:\n  \\<turnstile>\\<^sub>p {adjoint (tensor_P mat_Ph (1\\<^sub>m K)) *\n                        (adjoint (exexH_k (n - 1)) * Q2 * exexH_k (n - 1)) *\n                        tensor_P mat_Ph (1\\<^sub>m K)}\n                       Utrans_P vars1 mat_Ph\n                       {adjoint (exexH_k (n - 1)) * Q2 * exexH_k (n - 1)}\n  \\<turnstile>\\<^sub>p {adjoint (exexH_k (n - 1)) *\n                        (adjoint (tensor_P mat_Ph (1\\<^sub>m K)) *\n                         (adjoint (exexH_k (n - 1)) * Q2 *\n                          exexH_k (n - 1)) *\n                         tensor_P mat_Ph (1\\<^sub>m K)) *\n                        exexH_k (n - 1)}\n                       hadamard_n n\n                       {adjoint (tensor_P mat_Ph (1\\<^sub>m K)) *\n                        (adjoint (exexH_k (n - 1)) * Q2 * exexH_k (n - 1)) *\n                        tensor_P mat_Ph (1\\<^sub>m K)}\n  is_quantum_predicate (adjoint (exexH_k (n - 1)) * Q2 * exexH_k (n - 1))\n  is_quantum_predicate\n   (adjoint (tensor_P mat_Ph (1\\<^sub>m K)) *\n    (adjoint (exexH_k (n - 1)) * Q2 * exexH_k (n - 1)) *\n    tensor_P mat_Ph (1\\<^sub>m K))\n  is_quantum_predicate\n   (adjoint (exexH_k (n - 1)) *\n    (adjoint (tensor_P mat_Ph (1\\<^sub>m K)) *\n     (adjoint (exexH_k (n - 1)) * Q2 * exexH_k (n - 1)) *\n     tensor_P mat_Ph (1\\<^sub>m K)) *\n    exexH_k (n - 1))\n  is_quantum_predicate ?P \\<Longrightarrow>\n  \\<turnstile>\\<^sub>p {?P} SKIP {?P}\n  is_quantum_predicate ?P \\<Longrightarrow>\n  \\<turnstile>\\<^sub>p {adjoint ?U * ?P * ?U} Utrans ?U {?P}\n  \\<lbrakk>is_quantum_predicate ?P; is_quantum_predicate ?Q;\n   is_quantum_predicate ?R; \\<turnstile>\\<^sub>p {?P} ?S1.0 {?Q};\n   \\<turnstile>\\<^sub>p {?Q} ?S2.0 {?R}\\<rbrakk>\n  \\<Longrightarrow> \\<turnstile>\\<^sub>p {?P} ?S1.0;; ?S2.0 {?R}\n  \\<lbrakk>\\<And>k. k < ?n \\<Longrightarrow> is_quantum_predicate (?P k);\n   is_quantum_predicate ?Q;\n   \\<And>k.\n      k < ?n \\<Longrightarrow>\n      \\<turnstile>\\<^sub>p {?P k} ?S ! k {?Q}\\<rbrakk>\n  \\<Longrightarrow> \\<turnstile>\\<^sub>p {matrix_sum d\n     (\\<lambda>k. adjoint (?M k) * ?P k * ?M k) ?n}\n   Measure ?n ?M ?S {?Q}\n  \\<lbrakk>is_quantum_predicate ?P; is_quantum_predicate ?Q;\n   \\<turnstile>\\<^sub>p {?Q} ?S\n                        {adjoint (?M 0) * ?P * ?M 0 +\n                         adjoint (?M 1) * ?Q * ?M 1}\\<rbrakk>\n  \\<Longrightarrow> \\<turnstile>\\<^sub>p {adjoint (?M 0) * ?P * ?M 0 +\n    adjoint (?M 1) * ?Q * ?M 1}\n   While ?M ?S {?P}\n  \\<lbrakk>is_quantum_predicate ?P; is_quantum_predicate ?Q;\n   is_quantum_predicate ?P'; is_quantum_predicate ?Q'; ?P \\<le>\\<^sub>L ?P';\n   \\<turnstile>\\<^sub>p {?P'} ?S {?Q'}; ?Q' \\<le>\\<^sub>L ?Q\\<rbrakk>\n  \\<Longrightarrow> \\<turnstile>\\<^sub>p {?P} ?S {?Q}\n\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>p {adjoint (exexH_k (n - 1)) *\n                          (adjoint (tensor_P mat_Ph (1\\<^sub>m K)) *\n                           (adjoint (exexH_k (n - 1)) * Q2 *\n                            exexH_k (n - 1)) *\n                           tensor_P mat_Ph (1\\<^sub>m K)) *\n                          exexH_k (n - 1)}\n                         hadamard_n n;; Utrans_P vars1 mat_Ph\n                         {adjoint (exexH_k (n - 1)) * Q2 * exexH_k (n - 1)}", "by auto"], ["proof (state)\nthis:\n  \\<turnstile>\\<^sub>p {adjoint (exexH_k (n - 1)) *\n                        (adjoint (tensor_P mat_Ph (1\\<^sub>m K)) *\n                         (adjoint (exexH_k (n - 1)) * Q2 *\n                          exexH_k (n - 1)) *\n                         tensor_P mat_Ph (1\\<^sub>m K)) *\n                        exexH_k (n - 1)}\n                       hadamard_n n;; Utrans_P vars1 mat_Ph\n                       {adjoint (exexH_k (n - 1)) * Q2 * exexH_k (n - 1)}\n\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>p {Q1}\n                         hadamard_n n;; Utrans_P vars1 mat_Ph;; hadamard_n n\n                         {Q2}", "then"], ["proof (chain)\npicking this:\n  \\<turnstile>\\<^sub>p {adjoint (exexH_k (n - 1)) *\n                        (adjoint (tensor_P mat_Ph (1\\<^sub>m K)) *\n                         (adjoint (exexH_k (n - 1)) * Q2 *\n                          exexH_k (n - 1)) *\n                         tensor_P mat_Ph (1\\<^sub>m K)) *\n                        exexH_k (n - 1)}\n                       hadamard_n n;; Utrans_P vars1 mat_Ph\n                       {adjoint (exexH_k (n - 1)) * Q2 * exexH_k (n - 1)}", "have h5: \"\\<turnstile>\\<^sub>p \n   {adjoint ?H * (adjoint ?Ph * (adjoint ?H * Q2 * ?H) * ?Ph) * ?H}\n   hadamard_n n ;;\n   Utrans_P vars1 mat_Ph ;;\n   hadamard_n n \n   {Q2}\""], ["proof (prove)\nusing this:\n  \\<turnstile>\\<^sub>p {adjoint (exexH_k (n - 1)) *\n                        (adjoint (tensor_P mat_Ph (1\\<^sub>m K)) *\n                         (adjoint (exexH_k (n - 1)) * Q2 *\n                          exexH_k (n - 1)) *\n                         tensor_P mat_Ph (1\\<^sub>m K)) *\n                        exexH_k (n - 1)}\n                       hadamard_n n;; Utrans_P vars1 mat_Ph\n                       {adjoint (exexH_k (n - 1)) * Q2 * exexH_k (n - 1)}\n\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>p {adjoint (exexH_k (n - 1)) *\n                          (adjoint (tensor_P mat_Ph (1\\<^sub>m K)) *\n                           (adjoint (exexH_k (n - 1)) * Q2 *\n                            exexH_k (n - 1)) *\n                           tensor_P mat_Ph (1\\<^sub>m K)) *\n                          exexH_k (n - 1)}\n                         hadamard_n n;; Utrans_P vars1 mat_Ph;; hadamard_n n\n                         {Q2}", "using h1 qp_Q2 qp3 qp1 hoare_partial.intros(3)[OF qp3 qp1 qp_Q2 h4 h1]"], ["proof (prove)\nusing this:\n  \\<turnstile>\\<^sub>p {adjoint (exexH_k (n - 1)) *\n                        (adjoint (tensor_P mat_Ph (1\\<^sub>m K)) *\n                         (adjoint (exexH_k (n - 1)) * Q2 *\n                          exexH_k (n - 1)) *\n                         tensor_P mat_Ph (1\\<^sub>m K)) *\n                        exexH_k (n - 1)}\n                       hadamard_n n;; Utrans_P vars1 mat_Ph\n                       {adjoint (exexH_k (n - 1)) * Q2 * exexH_k (n - 1)}\n  \\<turnstile>\\<^sub>p {adjoint (exexH_k (n - 1)) * Q2 * exexH_k (n - 1)}\n                       hadamard_n n {Q2}\n  is_quantum_predicate Q2\n  is_quantum_predicate\n   (adjoint (exexH_k (n - 1)) *\n    (adjoint (tensor_P mat_Ph (1\\<^sub>m K)) *\n     (adjoint (exexH_k (n - 1)) * Q2 * exexH_k (n - 1)) *\n     tensor_P mat_Ph (1\\<^sub>m K)) *\n    exexH_k (n - 1))\n  is_quantum_predicate (adjoint (exexH_k (n - 1)) * Q2 * exexH_k (n - 1))\n  \\<turnstile>\\<^sub>p {adjoint (exexH_k (n - 1)) *\n                        (adjoint (tensor_P mat_Ph (1\\<^sub>m K)) *\n                         (adjoint (exexH_k (n - 1)) * Q2 *\n                          exexH_k (n - 1)) *\n                         tensor_P mat_Ph (1\\<^sub>m K)) *\n                        exexH_k (n - 1)}\n                       hadamard_n n;; Utrans_P vars1 mat_Ph;; hadamard_n n\n                       {Q2}\n\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>p {adjoint (exexH_k (n - 1)) *\n                          (adjoint (tensor_P mat_Ph (1\\<^sub>m K)) *\n                           (adjoint (exexH_k (n - 1)) * Q2 *\n                            exexH_k (n - 1)) *\n                           tensor_P mat_Ph (1\\<^sub>m K)) *\n                          exexH_k (n - 1)}\n                         hadamard_n n;; Utrans_P vars1 mat_Ph;; hadamard_n n\n                         {Q2}", "by auto"], ["proof (state)\nthis:\n  \\<turnstile>\\<^sub>p {adjoint (exexH_k (n - 1)) *\n                        (adjoint (tensor_P mat_Ph (1\\<^sub>m K)) *\n                         (adjoint (exexH_k (n - 1)) * Q2 *\n                          exexH_k (n - 1)) *\n                         tensor_P mat_Ph (1\\<^sub>m K)) *\n                        exexH_k (n - 1)}\n                       hadamard_n n;; Utrans_P vars1 mat_Ph;; hadamard_n n\n                       {Q2}\n\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>p {Q1}\n                         hadamard_n n;; Utrans_P vars1 mat_Ph;; hadamard_n n\n                         {Q2}", "have \"adjoint ?H * (adjoint ?Ph * (adjoint ?H * Q2 * ?H) * ?Ph) * ?H =\n        adjoint (?H * ?Ph * ?H) * Q2 * (?H * ?Ph * ?H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adjoint (exexH_k (n - 1)) *\n    (adjoint (tensor_P mat_Ph (1\\<^sub>m K)) *\n     (adjoint (exexH_k (n - 1)) * Q2 * exexH_k (n - 1)) *\n     tensor_P mat_Ph (1\\<^sub>m K)) *\n    exexH_k (n - 1) =\n    adjoint\n     (exexH_k (n - 1) * tensor_P mat_Ph (1\\<^sub>m K) * exexH_k (n - 1)) *\n    Q2 *\n    (exexH_k (n - 1) * tensor_P mat_Ph (1\\<^sub>m K) * exexH_k (n - 1))", "apply (mat_assoc d)"], ["proof (prove)\ngoal (3 subgoals):\n 1. tensor_P mat_Ph (1\\<^sub>m K) \\<in> carrier_mat d d\n 2. Q2 \\<in> carrier_mat d d\n 3. exexH_k (n - 1) \\<in> carrier_mat d d", "using exexH_k_dim n tensor_P_dim Q2_dim"], ["proof (prove)\nusing this:\n  ?k < n \\<Longrightarrow> exexH_k ?k \\<in> carrier_mat d d\n  1 < n\n  tensor_P ?A ?B \\<in> carrier_mat d d\n  Q2 \\<in> carrier_mat d d\n\ngoal (3 subgoals):\n 1. tensor_P mat_Ph (1\\<^sub>m K) \\<in> carrier_mat d d\n 2. Q2 \\<in> carrier_mat d d\n 3. exexH_k (n - 1) \\<in> carrier_mat d d", "by auto"], ["proof (state)\nthis:\n  adjoint (exexH_k (n - 1)) *\n  (adjoint (tensor_P mat_Ph (1\\<^sub>m K)) *\n   (adjoint (exexH_k (n - 1)) * Q2 * exexH_k (n - 1)) *\n   tensor_P mat_Ph (1\\<^sub>m K)) *\n  exexH_k (n - 1) =\n  adjoint\n   (exexH_k (n - 1) * tensor_P mat_Ph (1\\<^sub>m K) * exexH_k (n - 1)) *\n  Q2 *\n  (exexH_k (n - 1) * tensor_P mat_Ph (1\\<^sub>m K) * exexH_k (n - 1))\n\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>p {Q1}\n                         hadamard_n n;; Utrans_P vars1 mat_Ph;; hadamard_n n\n                         {Q2}", "also"], ["proof (state)\nthis:\n  adjoint (exexH_k (n - 1)) *\n  (adjoint (tensor_P mat_Ph (1\\<^sub>m K)) *\n   (adjoint (exexH_k (n - 1)) * Q2 * exexH_k (n - 1)) *\n   tensor_P mat_Ph (1\\<^sub>m K)) *\n  exexH_k (n - 1) =\n  adjoint\n   (exexH_k (n - 1) * tensor_P mat_Ph (1\\<^sub>m K) * exexH_k (n - 1)) *\n  Q2 *\n  (exexH_k (n - 1) * tensor_P mat_Ph (1\\<^sub>m K) * exexH_k (n - 1))\n\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>p {Q1}\n                         hadamard_n n;; Utrans_P vars1 mat_Ph;; hadamard_n n\n                         {Q2}", "have \"\\<dots> = Q1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adjoint\n     (exexH_k (n - 1) * tensor_P mat_Ph (1\\<^sub>m K) * exexH_k (n - 1)) *\n    Q2 *\n    (exexH_k (n - 1) * tensor_P mat_Ph (1\\<^sub>m K) * exexH_k (n - 1)) =\n    Q1", "using H_Ph_H proj_psi_minus_1_Q2"], ["proof (prove)\nusing this:\n  exexH_k (n - 1) * tensor_P mat_Ph (1\\<^sub>m K) * exexH_k (n - 1) =\n  2 \\<cdot>\\<^sub>m tensor_P proj_psi (1\\<^sub>m K) - 1\\<^sub>m d\n  adjoint\n   (2 \\<cdot>\\<^sub>m tensor_P proj_psi (1\\<^sub>m K) - 1\\<^sub>m d) *\n  Q2 *\n  (2 \\<cdot>\\<^sub>m tensor_P proj_psi (1\\<^sub>m K) - 1\\<^sub>m d) =\n  Q1\n\ngoal (1 subgoal):\n 1. adjoint\n     (exexH_k (n - 1) * tensor_P mat_Ph (1\\<^sub>m K) * exexH_k (n - 1)) *\n    Q2 *\n    (exexH_k (n - 1) * tensor_P mat_Ph (1\\<^sub>m K) * exexH_k (n - 1)) =\n    Q1", "by auto"], ["proof (state)\nthis:\n  adjoint\n   (exexH_k (n - 1) * tensor_P mat_Ph (1\\<^sub>m K) * exexH_k (n - 1)) *\n  Q2 *\n  (exexH_k (n - 1) * tensor_P mat_Ph (1\\<^sub>m K) * exexH_k (n - 1)) =\n  Q1\n\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>p {Q1}\n                         hadamard_n n;; Utrans_P vars1 mat_Ph;; hadamard_n n\n                         {Q2}", "finally"], ["proof (chain)\npicking this:\n  adjoint (exexH_k (n - 1)) *\n  (adjoint (tensor_P mat_Ph (1\\<^sub>m K)) *\n   (adjoint (exexH_k (n - 1)) * Q2 * exexH_k (n - 1)) *\n   tensor_P mat_Ph (1\\<^sub>m K)) *\n  exexH_k (n - 1) =\n  Q1", "show ?thesis"], ["proof (prove)\nusing this:\n  adjoint (exexH_k (n - 1)) *\n  (adjoint (tensor_P mat_Ph (1\\<^sub>m K)) *\n   (adjoint (exexH_k (n - 1)) * Q2 * exexH_k (n - 1)) *\n   tensor_P mat_Ph (1\\<^sub>m K)) *\n  exexH_k (n - 1) =\n  Q1\n\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>p {Q1}\n                         hadamard_n n;; Utrans_P vars1 mat_Ph;; hadamard_n n\n                         {Q2}", "using h5"], ["proof (prove)\nusing this:\n  adjoint (exexH_k (n - 1)) *\n  (adjoint (tensor_P mat_Ph (1\\<^sub>m K)) *\n   (adjoint (exexH_k (n - 1)) * Q2 * exexH_k (n - 1)) *\n   tensor_P mat_Ph (1\\<^sub>m K)) *\n  exexH_k (n - 1) =\n  Q1\n  \\<turnstile>\\<^sub>p {adjoint (exexH_k (n - 1)) *\n                        (adjoint (tensor_P mat_Ph (1\\<^sub>m K)) *\n                         (adjoint (exexH_k (n - 1)) * Q2 *\n                          exexH_k (n - 1)) *\n                         tensor_P mat_Ph (1\\<^sub>m K)) *\n                        exexH_k (n - 1)}\n                       hadamard_n n;; Utrans_P vars1 mat_Ph;; hadamard_n n\n                       {Q2}\n\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>p {Q1}\n                         hadamard_n n;; Utrans_P vars1 mat_Ph;; hadamard_n n\n                         {Q2}", "by auto"], ["proof (state)\nthis:\n  \\<turnstile>\\<^sub>p {Q1}\n                       hadamard_n n;; Utrans_P vars1 mat_Ph;; hadamard_n n\n                       {Q2}\n\ngoal:\nNo subgoals!", "qed"], ["", "definition exM0 where\n  \"exM0 = tensor_P (1\\<^sub>m N) M0\""], ["", "lemma M0_mult_ket_k_R:\n  \"M0 *\\<^sub>v ket_k R = ket_k R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M0 *\\<^sub>v ket_k R = ket_k R", "apply (rule eq_vecI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i.\n       i < dim_vec (ket_k R) \\<Longrightarrow>\n       (M0 *\\<^sub>v ket_k R) $ i = ket_k R $ i\n 2. dim_vec (M0 *\\<^sub>v ket_k R) = dim_vec (ket_k R)", "unfolding M0_def ket_k_def"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i.\n       i < dim_vec\n            (Matrix.vec K\n              (\\<lambda>k. if k = R then 1 else 0)) \\<Longrightarrow>\n       (mat K K\n         (\\<lambda>(i, j).\n             if i = j \\<and> R \\<le> i then 1 else 0) *\\<^sub>v\n        Matrix.vec K (\\<lambda>k. if k = R then 1 else 0)) $\n       i =\n       Matrix.vec K (\\<lambda>k. if k = R then 1 else 0) $ i\n 2. dim_vec\n     (mat K K\n       (\\<lambda>(i, j). if i = j \\<and> R \\<le> i then 1 else 0) *\\<^sub>v\n      Matrix.vec K (\\<lambda>k. if k = R then 1 else 0)) =\n    dim_vec (Matrix.vec K (\\<lambda>k. if k = R then 1 else 0))", "by (auto simp add: scalar_prod_def sum_only_one_neq_0)"], ["", "lemma exP0_P':\n  \"adjoint exM0 * P' * exM0 = P'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adjoint exM0 * P' * exM0 = P'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. adjoint exM0 * P' * exM0 = P'", "have eq: \"adjoint exM0 = exM0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adjoint exM0 = exM0", "unfolding exM0_def ps2_P.ptensor_mat_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. adjoint (ps_P.tensor_mat (1\\<^sub>m N) M0) =\n    ps_P.tensor_mat (1\\<^sub>m N) M0", "apply (subst ps_P.tensor_mat_adjoint)"], ["proof (prove)\ngoal (3 subgoals):\n 1. 1\\<^sub>m N \\<in> carrier_mat ps_P.d1 ps_P.d1\n 2. M0 \\<in> carrier_mat ps_P.d2 ps_P.d2\n 3. ps_P.tensor_mat (adjoint (1\\<^sub>m N)) (adjoint M0) =\n    ps_P.tensor_mat (1\\<^sub>m N) M0", "unfolding ps_P_d1 ps_P_d2"], ["proof (prove)\ngoal (3 subgoals):\n 1. 1\\<^sub>m N \\<in> carrier_mat N N\n 2. M0 \\<in> carrier_mat K K\n 3. ps_P.tensor_mat (adjoint (1\\<^sub>m N)) (adjoint M0) =\n    ps_P.tensor_mat (1\\<^sub>m N) M0", "using M0_dim adjoint_one hermitian_M0[unfolded hermitian_def]"], ["proof (prove)\nusing this:\n  M0 \\<in> carrier_mat K K\n  adjoint (1\\<^sub>m ?n) = 1\\<^sub>m ?n\n  adjoint M0 = M0\n\ngoal (3 subgoals):\n 1. 1\\<^sub>m N \\<in> carrier_mat N N\n 2. M0 \\<in> carrier_mat K K\n 3. ps_P.tensor_mat (adjoint (1\\<^sub>m N)) (adjoint M0) =\n    ps_P.tensor_mat (1\\<^sub>m N) M0", "by auto"], ["proof (state)\nthis:\n  adjoint exM0 = exM0\n\ngoal (1 subgoal):\n 1. adjoint exM0 * P' * exM0 = P'", "have eq2: \"M0 * (proj_k R) * M0 = (proj_k R)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M0 * proj_k R * M0 = proj_k R", "unfolding proj_k_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. M0 * outer_prod (ket_k R) (ket_k R) * M0 =\n    outer_prod (ket_k R) (ket_k R)", "apply (subst outer_prod_left_right_mat[of _ K _ K _ K _ K])"], ["proof (prove)\ngoal (3 subgoals):\n 1. ket_k R \\<in> carrier_vec K\n 2. M0 \\<in> carrier_mat K K\n 3. outer_prod (M0 *\\<^sub>v ket_k R) (adjoint M0 *\\<^sub>v ket_k R) =\n    outer_prod (ket_k R) (ket_k R)", "unfolding hermitian_M0[unfolded hermitian_def] M0_mult_ket_k_R"], ["proof (prove)\ngoal (3 subgoals):\n 1. ket_k R \\<in> carrier_vec K\n 2. M0 \\<in> carrier_mat K K\n 3. outer_prod (ket_k R) (ket_k R) = outer_prod (ket_k R) (ket_k R)", "using ket_k_dim M0_dim"], ["proof (prove)\nusing this:\n  ket_k ?k \\<in> carrier_vec K\n  M0 \\<in> carrier_mat K K\n\ngoal (3 subgoals):\n 1. ket_k R \\<in> carrier_vec K\n 2. M0 \\<in> carrier_mat K K\n 3. outer_prod (ket_k R) (ket_k R) = outer_prod (ket_k R) (ket_k R)", "by auto"], ["proof (state)\nthis:\n  M0 * proj_k R * M0 = proj_k R\n\ngoal (1 subgoal):\n 1. adjoint exM0 * P' * exM0 = P'", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. adjoint exM0 * P' * exM0 = P'", "unfolding eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. exM0 * P' * exM0 = P'", "unfolding exM0_def P'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. tensor_P (1\\<^sub>m N) M0 * tensor_P (proj_psi_l R) (proj_k R) *\n    tensor_P (1\\<^sub>m N) M0 =\n    tensor_P (proj_psi_l R) (proj_k R)", "apply (subst tensor_P_left_right_partial2)"], ["proof (prove)\ngoal (4 subgoals):\n 1. M0 \\<in> carrier_mat K K\n 2. proj_k R \\<in> carrier_mat K K\n 3. proj_psi_l R \\<in> carrier_mat N N\n 4. tensor_P (proj_psi_l R) (M0 * proj_k R * M0) =\n    tensor_P (proj_psi_l R) (proj_k R)", "using M0_dim proj_k_dim eq2 proj_psi_l_dim"], ["proof (prove)\nusing this:\n  M0 \\<in> carrier_mat K K\n  proj_k ?k \\<in> carrier_mat K K\n  M0 * proj_k R * M0 = proj_k R\n  proj_psi_l ?l \\<in> carrier_mat N N\n\ngoal (4 subgoals):\n 1. M0 \\<in> carrier_mat K K\n 2. proj_k R \\<in> carrier_mat K K\n 3. proj_psi_l R \\<in> carrier_mat N N\n 4. tensor_P (proj_psi_l R) (M0 * proj_k R * M0) =\n    tensor_P (proj_psi_l R) (proj_k R)", "by auto"], ["proof (state)\nthis:\n  adjoint exM0 * P' * exM0 = P'\n\ngoal:\nNo subgoals!", "qed"], ["", "definition exM1 where\n  \"exM1 = tensor_P (1\\<^sub>m N) M1\""], ["", "lemma M1_mult_ket_k:\n  assumes \"k < R\"\n  shows \"M1 *\\<^sub>v ket_k k = ket_k k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M1 *\\<^sub>v ket_k k = ket_k k", "apply (rule eq_vecI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i.\n       i < dim_vec (ket_k k) \\<Longrightarrow>\n       (M1 *\\<^sub>v ket_k k) $ i = ket_k k $ i\n 2. dim_vec (M1 *\\<^sub>v ket_k k) = dim_vec (ket_k k)", "unfolding M1_def ket_k_def"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i.\n       i < dim_vec\n            (Matrix.vec K\n              (\\<lambda>ka. if ka = k then 1 else 0)) \\<Longrightarrow>\n       (mat K K\n         (\\<lambda>(i, j). if i = j \\<and> i < R then 1 else 0) *\\<^sub>v\n        Matrix.vec K (\\<lambda>ka. if ka = k then 1 else 0)) $\n       i =\n       Matrix.vec K (\\<lambda>ka. if ka = k then 1 else 0) $ i\n 2. dim_vec\n     (mat K K\n       (\\<lambda>(i, j). if i = j \\<and> i < R then 1 else 0) *\\<^sub>v\n      Matrix.vec K (\\<lambda>ka. if ka = k then 1 else 0)) =\n    dim_vec (Matrix.vec K (\\<lambda>ka. if ka = k then 1 else 0))", "by (auto simp add: scalar_prod_def assms R sum_only_one_neq_0)"], ["", "lemma exP1_Q:\n  \"adjoint exM1 * Q * exM1 = Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adjoint exM1 * Q * exM1 = Q", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. adjoint exM1 * Q * exM1 = Q", "have eq: \"adjoint exM1 = exM1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adjoint exM1 = exM1", "unfolding exM1_def ps2_P.ptensor_mat_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. adjoint (ps_P.tensor_mat (1\\<^sub>m N) M1) =\n    ps_P.tensor_mat (1\\<^sub>m N) M1", "apply (subst ps_P.tensor_mat_adjoint)"], ["proof (prove)\ngoal (3 subgoals):\n 1. 1\\<^sub>m N \\<in> carrier_mat ps_P.d1 ps_P.d1\n 2. M1 \\<in> carrier_mat ps_P.d2 ps_P.d2\n 3. ps_P.tensor_mat (adjoint (1\\<^sub>m N)) (adjoint M1) =\n    ps_P.tensor_mat (1\\<^sub>m N) M1", "unfolding ps_P_d1 ps_P_d2"], ["proof (prove)\ngoal (3 subgoals):\n 1. 1\\<^sub>m N \\<in> carrier_mat N N\n 2. M1 \\<in> carrier_mat K K\n 3. ps_P.tensor_mat (adjoint (1\\<^sub>m N)) (adjoint M1) =\n    ps_P.tensor_mat (1\\<^sub>m N) M1", "using M1_dim adjoint_one hermitian_M1[unfolded hermitian_def]"], ["proof (prove)\nusing this:\n  M1 \\<in> carrier_mat K K\n  adjoint (1\\<^sub>m ?n) = 1\\<^sub>m ?n\n  adjoint M1 = M1\n\ngoal (3 subgoals):\n 1. 1\\<^sub>m N \\<in> carrier_mat N N\n 2. M1 \\<in> carrier_mat K K\n 3. ps_P.tensor_mat (adjoint (1\\<^sub>m N)) (adjoint M1) =\n    ps_P.tensor_mat (1\\<^sub>m N) M1", "by auto"], ["proof (state)\nthis:\n  adjoint exM1 = exM1\n\ngoal (1 subgoal):\n 1. adjoint exM1 * Q * exM1 = Q", "{"], ["proof (state)\nthis:\n  adjoint exM1 = exM1\n\ngoal (1 subgoal):\n 1. adjoint exM1 * Q * exM1 = Q", "fix k"], ["proof (state)\ngoal (1 subgoal):\n 1. adjoint exM1 * Q * exM1 = Q", "assume k: \"k < R\""], ["proof (state)\nthis:\n  k < R\n\ngoal (1 subgoal):\n 1. adjoint exM1 * Q * exM1 = Q", "let ?m = \"tensor_P (proj_psi_l k) (proj_k k)\""], ["proof (state)\ngoal (1 subgoal):\n 1. adjoint exM1 * Q * exM1 = Q", "have \"exM1 * ?m * exM1 = tensor_P (proj_psi_l k) (M1 * (proj_k k) * M1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exM1 * tensor_P (proj_psi_l k) (proj_k k) * exM1 =\n    tensor_P (proj_psi_l k) (M1 * proj_k k * M1)", "unfolding exM1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. tensor_P (1\\<^sub>m N) M1 * tensor_P (proj_psi_l k) (proj_k k) *\n    tensor_P (1\\<^sub>m N) M1 =\n    tensor_P (proj_psi_l k) (M1 * proj_k k * M1)", "apply (subst tensor_P_left_right_partial2)"], ["proof (prove)\ngoal (4 subgoals):\n 1. M1 \\<in> carrier_mat K K\n 2. proj_k k \\<in> carrier_mat K K\n 3. proj_psi_l k \\<in> carrier_mat N N\n 4. tensor_P (proj_psi_l k) (M1 * proj_k k * M1) =\n    tensor_P (proj_psi_l k) (M1 * proj_k k * M1)", "using M1_dim proj_k_dim proj_psi_l_dim"], ["proof (prove)\nusing this:\n  M1 \\<in> carrier_mat K K\n  proj_k ?k \\<in> carrier_mat K K\n  proj_psi_l ?l \\<in> carrier_mat N N\n\ngoal (4 subgoals):\n 1. M1 \\<in> carrier_mat K K\n 2. proj_k k \\<in> carrier_mat K K\n 3. proj_psi_l k \\<in> carrier_mat N N\n 4. tensor_P (proj_psi_l k) (M1 * proj_k k * M1) =\n    tensor_P (proj_psi_l k) (M1 * proj_k k * M1)", "by auto"], ["proof (state)\nthis:\n  exM1 * tensor_P (proj_psi_l k) (proj_k k) * exM1 =\n  tensor_P (proj_psi_l k) (M1 * proj_k k * M1)\n\ngoal (1 subgoal):\n 1. adjoint exM1 * Q * exM1 = Q", "also"], ["proof (state)\nthis:\n  exM1 * tensor_P (proj_psi_l k) (proj_k k) * exM1 =\n  tensor_P (proj_psi_l k) (M1 * proj_k k * M1)\n\ngoal (1 subgoal):\n 1. adjoint exM1 * Q * exM1 = Q", "have \"\\<dots> = tensor_P (proj_psi_l k) (outer_prod (M1 *\\<^sub>v ket_k k) (M1 *\\<^sub>v ket_k k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tensor_P (proj_psi_l k) (M1 * proj_k k * M1) =\n    tensor_P (proj_psi_l k)\n     (outer_prod (M1 *\\<^sub>v ket_k k) (M1 *\\<^sub>v ket_k k))", "unfolding proj_k_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. tensor_P (proj_psi_l k) (M1 * outer_prod (ket_k k) (ket_k k) * M1) =\n    tensor_P (proj_psi_l k)\n     (outer_prod (M1 *\\<^sub>v ket_k k) (M1 *\\<^sub>v ket_k k))", "apply (subst outer_prod_left_right_mat[of _ K _ K _ K _ K])"], ["proof (prove)\ngoal (3 subgoals):\n 1. ket_k k \\<in> carrier_vec K\n 2. M1 \\<in> carrier_mat K K\n 3. tensor_P (proj_psi_l k)\n     (outer_prod (M1 *\\<^sub>v ket_k k) (adjoint M1 *\\<^sub>v ket_k k)) =\n    tensor_P (proj_psi_l k)\n     (outer_prod (M1 *\\<^sub>v ket_k k) (M1 *\\<^sub>v ket_k k))", "unfolding hermitian_M1[unfolded hermitian_def]"], ["proof (prove)\ngoal (3 subgoals):\n 1. ket_k k \\<in> carrier_vec K\n 2. M1 \\<in> carrier_mat K K\n 3. tensor_P (proj_psi_l k)\n     (outer_prod (M1 *\\<^sub>v ket_k k) (M1 *\\<^sub>v ket_k k)) =\n    tensor_P (proj_psi_l k)\n     (outer_prod (M1 *\\<^sub>v ket_k k) (M1 *\\<^sub>v ket_k k))", "using ket_k_dim M1_dim"], ["proof (prove)\nusing this:\n  ket_k ?k \\<in> carrier_vec K\n  M1 \\<in> carrier_mat K K\n\ngoal (3 subgoals):\n 1. ket_k k \\<in> carrier_vec K\n 2. M1 \\<in> carrier_mat K K\n 3. tensor_P (proj_psi_l k)\n     (outer_prod (M1 *\\<^sub>v ket_k k) (M1 *\\<^sub>v ket_k k)) =\n    tensor_P (proj_psi_l k)\n     (outer_prod (M1 *\\<^sub>v ket_k k) (M1 *\\<^sub>v ket_k k))", "by auto"], ["proof (state)\nthis:\n  tensor_P (proj_psi_l k) (M1 * proj_k k * M1) =\n  tensor_P (proj_psi_l k)\n   (outer_prod (M1 *\\<^sub>v ket_k k) (M1 *\\<^sub>v ket_k k))\n\ngoal (1 subgoal):\n 1. adjoint exM1 * Q * exM1 = Q", "finally"], ["proof (chain)\npicking this:\n  exM1 * tensor_P (proj_psi_l k) (proj_k k) * exM1 =\n  tensor_P (proj_psi_l k)\n   (outer_prod (M1 *\\<^sub>v ket_k k) (M1 *\\<^sub>v ket_k k))", "have \"exM1 * ?m * exM1 = ?m\""], ["proof (prove)\nusing this:\n  exM1 * tensor_P (proj_psi_l k) (proj_k k) * exM1 =\n  tensor_P (proj_psi_l k)\n   (outer_prod (M1 *\\<^sub>v ket_k k) (M1 *\\<^sub>v ket_k k))\n\ngoal (1 subgoal):\n 1. exM1 * tensor_P (proj_psi_l k) (proj_k k) * exM1 =\n    tensor_P (proj_psi_l k) (proj_k k)", "unfolding proj_k_def"], ["proof (prove)\nusing this:\n  exM1 * tensor_P (proj_psi_l k) (outer_prod (ket_k k) (ket_k k)) * exM1 =\n  tensor_P (proj_psi_l k)\n   (outer_prod (M1 *\\<^sub>v ket_k k) (M1 *\\<^sub>v ket_k k))\n\ngoal (1 subgoal):\n 1. exM1 * tensor_P (proj_psi_l k) (outer_prod (ket_k k) (ket_k k)) * exM1 =\n    tensor_P (proj_psi_l k) (outer_prod (ket_k k) (ket_k k))", "using k M1_mult_ket_k"], ["proof (prove)\nusing this:\n  exM1 * tensor_P (proj_psi_l k) (outer_prod (ket_k k) (ket_k k)) * exM1 =\n  tensor_P (proj_psi_l k)\n   (outer_prod (M1 *\\<^sub>v ket_k k) (M1 *\\<^sub>v ket_k k))\n  k < R\n  ?k < R \\<Longrightarrow> M1 *\\<^sub>v ket_k ?k = ket_k ?k\n\ngoal (1 subgoal):\n 1. exM1 * tensor_P (proj_psi_l k) (outer_prod (ket_k k) (ket_k k)) * exM1 =\n    tensor_P (proj_psi_l k) (outer_prod (ket_k k) (ket_k k))", "by auto"], ["proof (state)\nthis:\n  exM1 * tensor_P (proj_psi_l k) (proj_k k) * exM1 =\n  tensor_P (proj_psi_l k) (proj_k k)\n\ngoal (1 subgoal):\n 1. adjoint exM1 * Q * exM1 = Q", "}"], ["proof (state)\nthis:\n  ?k4 < R \\<Longrightarrow>\n  exM1 * tensor_P (proj_psi_l ?k4) (proj_k ?k4) * exM1 =\n  tensor_P (proj_psi_l ?k4) (proj_k ?k4)\n\ngoal (1 subgoal):\n 1. adjoint exM1 * Q * exM1 = Q", "note p1 = this"], ["proof (state)\nthis:\n  ?k4 < R \\<Longrightarrow>\n  exM1 * tensor_P (proj_psi_l ?k4) (proj_k ?k4) * exM1 =\n  tensor_P (proj_psi_l ?k4) (proj_k ?k4)\n\ngoal (1 subgoal):\n 1. adjoint exM1 * Q * exM1 = Q", "have \"adjoint exM1 * Q * exM1 = exM1 * Q * exM1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adjoint exM1 * Q * exM1 = exM1 * Q * exM1", "using eq"], ["proof (prove)\nusing this:\n  adjoint exM1 = exM1\n\ngoal (1 subgoal):\n 1. adjoint exM1 * Q * exM1 = exM1 * Q * exM1", "by auto"], ["proof (state)\nthis:\n  adjoint exM1 * Q * exM1 = exM1 * Q * exM1\n\ngoal (1 subgoal):\n 1. adjoint exM1 * Q * exM1 = Q", "also"], ["proof (state)\nthis:\n  adjoint exM1 * Q * exM1 = exM1 * Q * exM1\n\ngoal (1 subgoal):\n 1. adjoint exM1 * Q * exM1 = Q", "have \"\\<dots> = matrix_sum d (\\<lambda>k. exM1 * (tensor_P (proj_psi_l k) (proj_k k)) * exM1) R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exM1 * Q * exM1 =\n    matrix_sum d\n     (\\<lambda>k. exM1 * tensor_P (proj_psi_l k) (proj_k k) * exM1) R", "unfolding Q_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. exM1 * matrix_sum d (\\<lambda>l. tensor_P (proj_psi_l l) (proj_k l)) R *\n    exM1 =\n    matrix_sum d\n     (\\<lambda>k. exM1 * tensor_P (proj_psi_l k) (proj_k k) * exM1) R", "apply (subst matrix_sum_mult_left_right)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>k.\n       k < R \\<Longrightarrow>\n       tensor_P (proj_psi_l k) (proj_k k) \\<in> carrier_mat d d\n 2. exM1 \\<in> carrier_mat d d\n 3. exM1 * matrix_sum d (\\<lambda>l. tensor_P (proj_psi_l l) (proj_k l)) R *\n    exM1 =\n    exM1 * matrix_sum d (\\<lambda>k. tensor_P (proj_psi_l k) (proj_k k)) R *\n    exM1", "using tensor_P_dim exM1_def"], ["proof (prove)\nusing this:\n  tensor_P ?A ?B \\<in> carrier_mat d d\n  exM1 = tensor_P (1\\<^sub>m N) M1\n\ngoal (3 subgoals):\n 1. \\<And>k.\n       k < R \\<Longrightarrow>\n       tensor_P (proj_psi_l k) (proj_k k) \\<in> carrier_mat d d\n 2. exM1 \\<in> carrier_mat d d\n 3. exM1 * matrix_sum d (\\<lambda>l. tensor_P (proj_psi_l l) (proj_k l)) R *\n    exM1 =\n    exM1 * matrix_sum d (\\<lambda>k. tensor_P (proj_psi_l k) (proj_k k)) R *\n    exM1", "by auto"], ["proof (state)\nthis:\n  exM1 * Q * exM1 =\n  matrix_sum d\n   (\\<lambda>k. exM1 * tensor_P (proj_psi_l k) (proj_k k) * exM1) R\n\ngoal (1 subgoal):\n 1. adjoint exM1 * Q * exM1 = Q", "also"], ["proof (state)\nthis:\n  exM1 * Q * exM1 =\n  matrix_sum d\n   (\\<lambda>k. exM1 * tensor_P (proj_psi_l k) (proj_k k) * exM1) R\n\ngoal (1 subgoal):\n 1. adjoint exM1 * Q * exM1 = Q", "have \"\\<dots> = matrix_sum d (\\<lambda>k. tensor_P (proj_psi_l k) (proj_k k)) R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_sum d\n     (\\<lambda>k. exM1 * tensor_P (proj_psi_l k) (proj_k k) * exM1) R =\n    matrix_sum d (\\<lambda>k. tensor_P (proj_psi_l k) (proj_k k)) R", "apply (subst matrix_sum_cong)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>k.\n       k < R \\<Longrightarrow>\n       exM1 * tensor_P (proj_psi_l k) (proj_k k) * exM1 = ?f' k\n 2. matrix_sum d ?f' R =\n    matrix_sum d (\\<lambda>k. tensor_P (proj_psi_l k) (proj_k k)) R", "using p1"], ["proof (prove)\nusing this:\n  ?k4 < R \\<Longrightarrow>\n  exM1 * tensor_P (proj_psi_l ?k4) (proj_k ?k4) * exM1 =\n  tensor_P (proj_psi_l ?k4) (proj_k ?k4)\n\ngoal (2 subgoals):\n 1. \\<And>k.\n       k < R \\<Longrightarrow>\n       exM1 * tensor_P (proj_psi_l k) (proj_k k) * exM1 = ?f' k\n 2. matrix_sum d ?f' R =\n    matrix_sum d (\\<lambda>k. tensor_P (proj_psi_l k) (proj_k k)) R", "by auto"], ["proof (state)\nthis:\n  matrix_sum d\n   (\\<lambda>k. exM1 * tensor_P (proj_psi_l k) (proj_k k) * exM1) R =\n  matrix_sum d (\\<lambda>k. tensor_P (proj_psi_l k) (proj_k k)) R\n\ngoal (1 subgoal):\n 1. adjoint exM1 * Q * exM1 = Q", "finally"], ["proof (chain)\npicking this:\n  adjoint exM1 * Q * exM1 =\n  matrix_sum d (\\<lambda>k. tensor_P (proj_psi_l k) (proj_k k)) R", "show ?thesis"], ["proof (prove)\nusing this:\n  adjoint exM1 * Q * exM1 =\n  matrix_sum d (\\<lambda>k. tensor_P (proj_psi_l k) (proj_k k)) R\n\ngoal (1 subgoal):\n 1. adjoint exM1 * Q * exM1 = Q", "using Q_def"], ["proof (prove)\nusing this:\n  adjoint exM1 * Q * exM1 =\n  matrix_sum d (\\<lambda>k. tensor_P (proj_psi_l k) (proj_k k)) R\n  Q = matrix_sum d (\\<lambda>l. tensor_P (proj_psi_l l) (proj_k l)) R\n\ngoal (1 subgoal):\n 1. adjoint exM1 * Q * exM1 = Q", "by auto"], ["proof (state)\nthis:\n  adjoint exM1 * Q * exM1 = Q\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma qp_P':\n  \"is_quantum_predicate P'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_quantum_predicate P'", "unfolding is_quantum_predicate_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. P' \\<in> carrier_mat d d \\<and>\n    positive P' \\<and> P' \\<le>\\<^sub>L 1\\<^sub>m d", "proof (intro conjI)"], ["proof (state)\ngoal (3 subgoals):\n 1. P' \\<in> carrier_mat d d\n 2. positive P'\n 3. P' \\<le>\\<^sub>L 1\\<^sub>m d", "show \"P' \\<in> carrier_mat d d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P' \\<in> carrier_mat d d", "unfolding P'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. tensor_P (proj_psi_l R) (proj_k R) \\<in> carrier_mat d d", "using tensor_P_dim"], ["proof (prove)\nusing this:\n  tensor_P ?A ?B \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. tensor_P (proj_psi_l R) (proj_k R) \\<in> carrier_mat d d", "by auto"], ["proof (state)\nthis:\n  P' \\<in> carrier_mat d d\n\ngoal (2 subgoals):\n 1. positive P'\n 2. P' \\<le>\\<^sub>L 1\\<^sub>m d", "show \"positive P'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. positive P'", "unfolding P'_def ps2_P.ptensor_mat_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. positive (ps_P.tensor_mat (proj_psi_l R) (proj_k R))", "apply (subst ps_P.tensor_mat_positive)"], ["proof (prove)\ngoal (5 subgoals):\n 1. proj_psi_l R \\<in> carrier_mat ps_P.d1 ps_P.d1\n 2. proj_k R \\<in> carrier_mat ps_P.d2 ps_P.d2\n 3. positive (proj_psi_l R)\n 4. positive (proj_k R)\n 5. True", "apply (auto simp add: ps_P_d1 ps_P_d2 proj_O_dim proj_k_dim)"], ["proof (prove)\ngoal (3 subgoals):\n 1. proj_psi_l R \\<in> carrier_mat N N\n 2. positive (proj_psi_l R)\n 3. positive (proj_k R)", "using proj_psi_l_dim positive_proj_psi_l positive_proj_k K"], ["proof (prove)\nusing this:\n  proj_psi_l ?l \\<in> carrier_mat N N\n  positive (proj_psi_l ?l)\n  positive (proj_k ?k)\n  R < K\n\ngoal (3 subgoals):\n 1. proj_psi_l R \\<in> carrier_mat N N\n 2. positive (proj_psi_l R)\n 3. positive (proj_k R)", "by auto"], ["proof (state)\nthis:\n  positive P'\n\ngoal (1 subgoal):\n 1. P' \\<le>\\<^sub>L 1\\<^sub>m d", "show \"P' \\<le>\\<^sub>L 1\\<^sub>m d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P' \\<le>\\<^sub>L 1\\<^sub>m d", "unfolding P'_def ps2_P.ptensor_mat_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ps_P.tensor_mat (proj_psi_l R) (proj_k R) \\<le>\\<^sub>L 1\\<^sub>m d", "apply (subst ps_P.tensor_mat_le_one[simplified ps_P_d])"], ["proof (prove)\ngoal (7 subgoals):\n 1. proj_psi_l R \\<in> carrier_mat ps_P.d1 ps_P.d1\n 2. proj_k R \\<in> carrier_mat ps_P.d2 ps_P.d2\n 3. positive (proj_psi_l R)\n 4. positive (proj_k R)\n 5. proj_psi_l R \\<le>\\<^sub>L 1\\<^sub>m ps_P.d1\n 6. proj_k R \\<le>\\<^sub>L 1\\<^sub>m ps_P.d2\n 7. True", "by (auto simp add: ps_P_d1 ps_P_d2 proj_psi_l_dim K proj_k_dim positive_proj_psi_l positive_proj_k proj_k_le_one psi_l_le_id)"], ["proof (state)\nthis:\n  P' \\<le>\\<^sub>L 1\\<^sub>m d\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma P'_add_Q:\n  \"P' + Q = matrix_sum d (\\<lambda>l. tensor_P (proj_psi_l l) (proj_k l)) (R + 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P' + Q =\n    matrix_sum d (\\<lambda>l. tensor_P (proj_psi_l l) (proj_k l)) (R + 1)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. P' + Q =\n    tensor_P (proj_psi_l R) (proj_k R) +\n    matrix_sum d (\\<lambda>l. tensor_P (proj_psi_l l) (proj_k l)) R", "unfolding P'_def Q_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. tensor_P (proj_psi_l R) (proj_k R) +\n    matrix_sum d (\\<lambda>l. tensor_P (proj_psi_l l) (proj_k l)) R =\n    tensor_P (proj_psi_l R) (proj_k R) +\n    matrix_sum d (\\<lambda>l. tensor_P (proj_psi_l l) (proj_k l)) R", "by auto"], ["", "lemma positive_Qk:\n  \"positive (tensor_P (proj_psi_l l) (proj_k l))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. positive (tensor_P (proj_psi_l l) (proj_k l))", "unfolding ps2_P.ptensor_mat_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. positive (ps_P.tensor_mat (proj_psi_l l) (proj_k l))", "apply (subst ps_P.tensor_mat_positive)"], ["proof (prove)\ngoal (5 subgoals):\n 1. proj_psi_l l \\<in> carrier_mat ps_P.d1 ps_P.d1\n 2. proj_k l \\<in> carrier_mat ps_P.d2 ps_P.d2\n 3. positive (proj_psi_l l)\n 4. positive (proj_k l)\n 5. True", "unfolding ps_P_d1 ps_P_d2"], ["proof (prove)\ngoal (5 subgoals):\n 1. proj_psi_l l \\<in> carrier_mat N N\n 2. proj_k l \\<in> carrier_mat K K\n 3. positive (proj_psi_l l)\n 4. positive (proj_k l)\n 5. True", "using proj_psi_l_dim proj_k_dim positive_proj_psi_l positive_proj_k"], ["proof (prove)\nusing this:\n  proj_psi_l ?l \\<in> carrier_mat N N\n  proj_k ?k \\<in> carrier_mat K K\n  positive (proj_psi_l ?l)\n  positive (proj_k ?k)\n\ngoal (5 subgoals):\n 1. proj_psi_l l \\<in> carrier_mat N N\n 2. proj_k l \\<in> carrier_mat K K\n 3. positive (proj_psi_l l)\n 4. positive (proj_k l)\n 5. True", "by auto"], ["", "lemma P'_Q_dim:\n  \"P' + Q \\<in> carrier_mat d d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P' + Q \\<in> carrier_mat d d", "unfolding P'_add_Q"], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_sum d (\\<lambda>l. tensor_P (proj_psi_l l) (proj_k l)) (R + 1)\n    \\<in> carrier_mat d d", "apply (subst matrix_sum_dim)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>k.\n       k < R + 1 \\<Longrightarrow>\n       tensor_P (proj_psi_l k) (proj_k k) \\<in> carrier_mat d d\n 2. True", "using tensor_P_dim"], ["proof (prove)\nusing this:\n  tensor_P ?A ?B \\<in> carrier_mat d d\n\ngoal (2 subgoals):\n 1. \\<And>k.\n       k < R + 1 \\<Longrightarrow>\n       tensor_P (proj_psi_l k) (proj_k k) \\<in> carrier_mat d d\n 2. True", "by auto"], ["", "lemma P'_add_Q_le_one:\n  \"P' + Q \\<le>\\<^sub>L 1\\<^sub>m d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P' + Q \\<le>\\<^sub>L 1\\<^sub>m d", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. P' + Q \\<le>\\<^sub>L 1\\<^sub>m d", "have leq: \"matrix_sum d (\\<lambda>l. tensor_P (proj_psi_l l) (proj_k l)) (R + 1) \n      \\<le>\\<^sub>L matrix_sum d (\\<lambda>k. tensor_P (1\\<^sub>m N) (proj_k k)) (R + 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_sum d (\\<lambda>l. tensor_P (proj_psi_l l) (proj_k l))\n     (R + 1) \\<le>\\<^sub>L\n    matrix_sum d (\\<lambda>k. tensor_P (1\\<^sub>m N) (proj_k k)) (R + 1)", "unfolding Q2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_sum d (\\<lambda>l. tensor_P (proj_psi_l l) (proj_k l))\n     (R + 1) \\<le>\\<^sub>L\n    matrix_sum d (\\<lambda>k. tensor_P (1\\<^sub>m N) (proj_k k)) (R + 1)", "apply (subst lowner_le_matrix_sum)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>k.\n       k < R + 1 \\<Longrightarrow>\n       tensor_P (proj_psi_l k) (proj_k k) \\<in> carrier_mat d d\n 2. \\<And>k.\n       k < R + 1 \\<Longrightarrow>\n       tensor_P (1\\<^sub>m N) (proj_k k) \\<in> carrier_mat d d\n 3. \\<And>k.\n       k < R + 1 \\<Longrightarrow>\n       tensor_P (proj_psi_l k) (proj_k k) \\<le>\\<^sub>L\n       tensor_P (1\\<^sub>m N) (proj_k k)\n 4. True", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. k_ < R + 1 \\<Longrightarrow>\n    tensor_P (proj_psi_l k_) (proj_k k_) \\<in> carrier_mat d d", "using tensor_P_dim"], ["proof (prove)\nusing this:\n  tensor_P ?A ?B \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. k_ < R + 1 \\<Longrightarrow>\n    tensor_P (proj_psi_l k_) (proj_k k_) \\<in> carrier_mat d d", "by auto"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>k.\n       k < R + 1 \\<Longrightarrow>\n       tensor_P (1\\<^sub>m N) (proj_k k) \\<in> carrier_mat d d\n 2. \\<And>k.\n       k < R + 1 \\<Longrightarrow>\n       tensor_P (proj_psi_l k) (proj_k k) \\<le>\\<^sub>L\n       tensor_P (1\\<^sub>m N) (proj_k k)\n 3. True", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. k_ < R + 1 \\<Longrightarrow>\n    tensor_P (1\\<^sub>m N) (proj_k k_) \\<in> carrier_mat d d", "using tensor_P_dim"], ["proof (prove)\nusing this:\n  tensor_P ?A ?B \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. k_ < R + 1 \\<Longrightarrow>\n    tensor_P (1\\<^sub>m N) (proj_k k_) \\<in> carrier_mat d d", "by auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>k.\n       k < R + 1 \\<Longrightarrow>\n       tensor_P (proj_psi_l k) (proj_k k) \\<le>\\<^sub>L\n       tensor_P (1\\<^sub>m N) (proj_k k)\n 2. True", "using proj_psi_proj_k_le_exproj_k"], ["proof (prove)\nusing this:\n  tensor_P (proj_psi_l ?k) (proj_k ?l) \\<le>\\<^sub>L\n  tensor_P (1\\<^sub>m N) (proj_k ?l)\n\ngoal (2 subgoals):\n 1. \\<And>k.\n       k < R + 1 \\<Longrightarrow>\n       tensor_P (proj_psi_l k) (proj_k k) \\<le>\\<^sub>L\n       tensor_P (1\\<^sub>m N) (proj_k k)\n 2. True", "by auto"], ["proof (state)\nthis:\n  matrix_sum d (\\<lambda>l. tensor_P (proj_psi_l l) (proj_k l))\n   (R + 1) \\<le>\\<^sub>L\n  matrix_sum d (\\<lambda>k. tensor_P (1\\<^sub>m N) (proj_k k)) (R + 1)\n\ngoal (1 subgoal):\n 1. P' + Q \\<le>\\<^sub>L 1\\<^sub>m d", "have \"matrix_sum d (\\<lambda>k. tensor_P (1\\<^sub>m N) (proj_k k)) (R + 1)\n      = tensor_P (1\\<^sub>m N) (matrix_sum K proj_k (R + 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_sum d (\\<lambda>k. tensor_P (1\\<^sub>m N) (proj_k k)) (R + 1) =\n    tensor_P (1\\<^sub>m N) (matrix_sum K proj_k (R + 1))", "unfolding ps2_P.ptensor_mat_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_sum d (\\<lambda>k. ps_P.tensor_mat (1\\<^sub>m N) (proj_k k))\n     (R + 1) =\n    ps_P.tensor_mat (1\\<^sub>m N) (matrix_sum K proj_k (R + 1))", "apply (subst ps_P.tensor_mat_matrix_sum2[simplified ps_P_d ps_P_d2])"], ["proof (prove)\ngoal (3 subgoals):\n 1. 1\\<^sub>m N \\<in> carrier_mat ps_P.d1 ps_P.d1\n 2. \\<And>k. k < R + 1 \\<Longrightarrow> proj_k k \\<in> carrier_mat K K\n 3. ps_P.tensor_mat (1\\<^sub>m N) (matrix_sum K proj_k (R + 1)) =\n    ps_P.tensor_mat (1\\<^sub>m N) (matrix_sum K proj_k (R + 1))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1\\<^sub>m N \\<in> carrier_mat ps_P.d1 ps_P.d1", "using ps_P_d1"], ["proof (prove)\nusing this:\n  ps_P.d1 = N\n\ngoal (1 subgoal):\n 1. 1\\<^sub>m N \\<in> carrier_mat ps_P.d1 ps_P.d1", "by auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>k. k < R + 1 \\<Longrightarrow> proj_k k \\<in> carrier_mat K K\n 2. ps_P.tensor_mat (1\\<^sub>m N) (matrix_sum K proj_k (R + 1)) =\n    ps_P.tensor_mat (1\\<^sub>m N) (matrix_sum K proj_k (R + 1))", "using proj_k_dim"], ["proof (prove)\nusing this:\n  proj_k ?k \\<in> carrier_mat K K\n\ngoal (2 subgoals):\n 1. \\<And>k. k < R + 1 \\<Longrightarrow> proj_k k \\<in> carrier_mat K K\n 2. ps_P.tensor_mat (1\\<^sub>m N) (matrix_sum K proj_k (R + 1)) =\n    ps_P.tensor_mat (1\\<^sub>m N) (matrix_sum K proj_k (R + 1))", "by auto"], ["proof (state)\nthis:\n  matrix_sum d (\\<lambda>k. tensor_P (1\\<^sub>m N) (proj_k k)) (R + 1) =\n  tensor_P (1\\<^sub>m N) (matrix_sum K proj_k (R + 1))\n\ngoal (1 subgoal):\n 1. P' + Q \\<le>\\<^sub>L 1\\<^sub>m d", "also"], ["proof (state)\nthis:\n  matrix_sum d (\\<lambda>k. tensor_P (1\\<^sub>m N) (proj_k k)) (R + 1) =\n  tensor_P (1\\<^sub>m N) (matrix_sum K proj_k (R + 1))\n\ngoal (1 subgoal):\n 1. P' + Q \\<le>\\<^sub>L 1\\<^sub>m d", "have \"\\<dots> = tensor_P (1\\<^sub>m N) (proj_fst_k (R + 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tensor_P (1\\<^sub>m N) (matrix_sum K proj_k (R + 1)) =\n    tensor_P (1\\<^sub>m N) (proj_fst_k (R + 1))", "using sum_proj_k[of \"R + 1\"] K"], ["proof (prove)\nusing this:\n  R + 1 \\<le> K \\<Longrightarrow>\n  matrix_sum K proj_k (R + 1) = proj_fst_k (R + 1)\n  R < K\n\ngoal (1 subgoal):\n 1. tensor_P (1\\<^sub>m N) (matrix_sum K proj_k (R + 1)) =\n    tensor_P (1\\<^sub>m N) (proj_fst_k (R + 1))", "by auto"], ["proof (state)\nthis:\n  tensor_P (1\\<^sub>m N) (matrix_sum K proj_k (R + 1)) =\n  tensor_P (1\\<^sub>m N) (proj_fst_k (R + 1))\n\ngoal (1 subgoal):\n 1. P' + Q \\<le>\\<^sub>L 1\\<^sub>m d", "also"], ["proof (state)\nthis:\n  tensor_P (1\\<^sub>m N) (matrix_sum K proj_k (R + 1)) =\n  tensor_P (1\\<^sub>m N) (proj_fst_k (R + 1))\n\ngoal (1 subgoal):\n 1. P' + Q \\<le>\\<^sub>L 1\\<^sub>m d", "have \"\\<dots> \\<le>\\<^sub>L tensor_P (1\\<^sub>m N) (1\\<^sub>m K)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tensor_P (1\\<^sub>m N) (proj_fst_k (R + 1)) \\<le>\\<^sub>L\n    tensor_P (1\\<^sub>m N) (1\\<^sub>m K)", "unfolding ps2_P.ptensor_mat_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ps_P.tensor_mat (1\\<^sub>m N) (proj_fst_k (R + 1)) \\<le>\\<^sub>L\n    ps_P.tensor_mat (1\\<^sub>m N) (1\\<^sub>m K)", "apply (subst ps_P.tensor_mat_positive_le)"], ["proof (prove)\ngoal (7 subgoals):\n 1. 1\\<^sub>m N \\<in> carrier_mat ps_P.d1 ps_P.d1\n 2. proj_fst_k (R + 1) \\<in> carrier_mat ps_P.d2 ps_P.d2\n 3. positive (1\\<^sub>m N)\n 4. positive (proj_fst_k (R + 1))\n 5. 1\\<^sub>m N \\<le>\\<^sub>L 1\\<^sub>m N\n 6. proj_fst_k (R + 1) \\<le>\\<^sub>L 1\\<^sub>m K\n 7. True", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1\\<^sub>m N \\<in> carrier_mat ps_P.d1 ps_P.d1", "using ps_P_d1"], ["proof (prove)\nusing this:\n  ps_P.d1 = N\n\ngoal (1 subgoal):\n 1. 1\\<^sub>m N \\<in> carrier_mat ps_P.d1 ps_P.d1", "by auto"], ["proof (prove)\ngoal (6 subgoals):\n 1. proj_fst_k (R + 1) \\<in> carrier_mat ps_P.d2 ps_P.d2\n 2. positive (1\\<^sub>m N)\n 3. positive (proj_fst_k (R + 1))\n 4. 1\\<^sub>m N \\<le>\\<^sub>L 1\\<^sub>m N\n 5. proj_fst_k (R + 1) \\<le>\\<^sub>L 1\\<^sub>m K\n 6. True", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. proj_fst_k (R + 1) \\<in> carrier_mat ps_P.d2 ps_P.d2", "using ps_P_d2 proj_fst_k_def"], ["proof (prove)\nusing this:\n  ps_P.d2 = K\n  proj_fst_k ?k =\n  mat K K (\\<lambda>(i, j). if i = j \\<and> i < ?k then 1 else 0)\n\ngoal (1 subgoal):\n 1. proj_fst_k (R + 1) \\<in> carrier_mat ps_P.d2 ps_P.d2", "by auto"], ["proof (prove)\ngoal (5 subgoals):\n 1. positive (1\\<^sub>m N)\n 2. positive (proj_fst_k (R + 1))\n 3. 1\\<^sub>m N \\<le>\\<^sub>L 1\\<^sub>m N\n 4. proj_fst_k (R + 1) \\<le>\\<^sub>L 1\\<^sub>m K\n 5. True", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. positive (1\\<^sub>m N)", "using positive_one"], ["proof (prove)\nusing this:\n  positive (1\\<^sub>m ?n)\n\ngoal (1 subgoal):\n 1. positive (1\\<^sub>m N)", "by auto"], ["proof (prove)\ngoal (4 subgoals):\n 1. positive (proj_fst_k (R + 1))\n 2. 1\\<^sub>m N \\<le>\\<^sub>L 1\\<^sub>m N\n 3. proj_fst_k (R + 1) \\<le>\\<^sub>L 1\\<^sub>m K\n 4. True", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. positive (proj_fst_k (R + 1))", "using positive_proj_fst_k"], ["proof (prove)\nusing this:\n  positive (proj_fst_k ?k)\n\ngoal (1 subgoal):\n 1. positive (proj_fst_k (R + 1))", "by auto"], ["proof (prove)\ngoal (3 subgoals):\n 1. 1\\<^sub>m N \\<le>\\<^sub>L 1\\<^sub>m N\n 2. proj_fst_k (R + 1) \\<le>\\<^sub>L 1\\<^sub>m K\n 3. True", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1\\<^sub>m N \\<le>\\<^sub>L 1\\<^sub>m N", "using lowner_le_refl[of \"1\\<^sub>m N\" N]"], ["proof (prove)\nusing this:\n  1\\<^sub>m N \\<in> carrier_mat N N \\<Longrightarrow>\n  1\\<^sub>m N \\<le>\\<^sub>L 1\\<^sub>m N\n\ngoal (1 subgoal):\n 1. 1\\<^sub>m N \\<le>\\<^sub>L 1\\<^sub>m N", "by auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. proj_fst_k (R + 1) \\<le>\\<^sub>L 1\\<^sub>m K\n 2. True", "using proj_fst_k_le_one"], ["proof (prove)\nusing this:\n  proj_fst_k ?k \\<le>\\<^sub>L 1\\<^sub>m K\n\ngoal (2 subgoals):\n 1. proj_fst_k (R + 1) \\<le>\\<^sub>L 1\\<^sub>m K\n 2. True", "by auto"], ["proof (state)\nthis:\n  tensor_P (1\\<^sub>m N) (proj_fst_k (R + 1)) \\<le>\\<^sub>L\n  tensor_P (1\\<^sub>m N) (1\\<^sub>m K)\n\ngoal (1 subgoal):\n 1. P' + Q \\<le>\\<^sub>L 1\\<^sub>m d", "also"], ["proof (state)\nthis:\n  tensor_P (1\\<^sub>m N) (proj_fst_k (R + 1)) \\<le>\\<^sub>L\n  tensor_P (1\\<^sub>m N) (1\\<^sub>m K)\n\ngoal (1 subgoal):\n 1. P' + Q \\<le>\\<^sub>L 1\\<^sub>m d", "have \"\\<dots> = 1\\<^sub>m d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tensor_P (1\\<^sub>m N) (1\\<^sub>m K) = 1\\<^sub>m d", "unfolding ps2_P.ptensor_mat_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ps_P.tensor_mat (1\\<^sub>m N) (1\\<^sub>m K) = 1\\<^sub>m d", "using ps_P.tensor_mat_id ps_P_d1 ps_P_d2 ps_P_d"], ["proof (prove)\nusing this:\n  ps_P.tensor_mat (1\\<^sub>m ps_P.d1) (1\\<^sub>m ps_P.d2) = 1\\<^sub>m ps_P.d\n  ps_P.d1 = N\n  ps_P.d2 = K\n  ps_P.d = d\n\ngoal (1 subgoal):\n 1. ps_P.tensor_mat (1\\<^sub>m N) (1\\<^sub>m K) = 1\\<^sub>m d", "by auto"], ["proof (state)\nthis:\n  tensor_P (1\\<^sub>m N) (1\\<^sub>m K) = 1\\<^sub>m d\n\ngoal (1 subgoal):\n 1. P' + Q \\<le>\\<^sub>L 1\\<^sub>m d", "finally"], ["proof (chain)\npicking this:\n  matrix_sum d (\\<lambda>k. tensor_P (1\\<^sub>m N) (proj_k k))\n   (R + 1) \\<le>\\<^sub>L\n  1\\<^sub>m d", "have leq2: \"matrix_sum d (\\<lambda>k. tensor_P (1\\<^sub>m N) (proj_k k)) (R + 1) \\<le>\\<^sub>L 1\\<^sub>m d\""], ["proof (prove)\nusing this:\n  matrix_sum d (\\<lambda>k. tensor_P (1\\<^sub>m N) (proj_k k))\n   (R + 1) \\<le>\\<^sub>L\n  1\\<^sub>m d\n\ngoal (1 subgoal):\n 1. matrix_sum d (\\<lambda>k. tensor_P (1\\<^sub>m N) (proj_k k))\n     (R + 1) \\<le>\\<^sub>L\n    1\\<^sub>m d", "by auto"], ["proof (state)\nthis:\n  matrix_sum d (\\<lambda>k. tensor_P (1\\<^sub>m N) (proj_k k))\n   (R + 1) \\<le>\\<^sub>L\n  1\\<^sub>m d\n\ngoal (1 subgoal):\n 1. P' + Q \\<le>\\<^sub>L 1\\<^sub>m d", "have ds: \"matrix_sum d (\\<lambda>k. tensor_P (1\\<^sub>m N) (proj_k k)) (R + 1) \\<in> carrier_mat d d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_sum d (\\<lambda>k. tensor_P (1\\<^sub>m N) (proj_k k)) (R + 1)\n    \\<in> carrier_mat d d", "apply (subst matrix_sum_dim)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>k.\n       k < R + 1 \\<Longrightarrow>\n       tensor_P (1\\<^sub>m N) (proj_k k) \\<in> carrier_mat d d\n 2. True", "using tensor_P_dim"], ["proof (prove)\nusing this:\n  tensor_P ?A ?B \\<in> carrier_mat d d\n\ngoal (2 subgoals):\n 1. \\<And>k.\n       k < R + 1 \\<Longrightarrow>\n       tensor_P (1\\<^sub>m N) (proj_k k) \\<in> carrier_mat d d\n 2. True", "by auto"], ["proof (state)\nthis:\n  matrix_sum d (\\<lambda>k. tensor_P (1\\<^sub>m N) (proj_k k)) (R + 1)\n  \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. P' + Q \\<le>\\<^sub>L 1\\<^sub>m d", "then"], ["proof (chain)\npicking this:\n  matrix_sum d (\\<lambda>k. tensor_P (1\\<^sub>m N) (proj_k k)) (R + 1)\n  \\<in> carrier_mat d d", "show ?thesis"], ["proof (prove)\nusing this:\n  matrix_sum d (\\<lambda>k. tensor_P (1\\<^sub>m N) (proj_k k)) (R + 1)\n  \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. P' + Q \\<le>\\<^sub>L 1\\<^sub>m d", "using leq leq2 lowner_le_trans[OF P'_Q_dim ds, of \"1\\<^sub>m d\"]"], ["proof (prove)\nusing this:\n  matrix_sum d (\\<lambda>k. tensor_P (1\\<^sub>m N) (proj_k k)) (R + 1)\n  \\<in> carrier_mat d d\n  matrix_sum d (\\<lambda>l. tensor_P (proj_psi_l l) (proj_k l))\n   (R + 1) \\<le>\\<^sub>L\n  matrix_sum d (\\<lambda>k. tensor_P (1\\<^sub>m N) (proj_k k)) (R + 1)\n  matrix_sum d (\\<lambda>k. tensor_P (1\\<^sub>m N) (proj_k k))\n   (R + 1) \\<le>\\<^sub>L\n  1\\<^sub>m d\n  \\<lbrakk>1\\<^sub>m d \\<in> carrier_mat d d;\n   P' + Q \\<le>\\<^sub>L\n   matrix_sum d (\\<lambda>k. tensor_P (1\\<^sub>m N) (proj_k k)) (R + 1);\n   matrix_sum d (\\<lambda>k. tensor_P (1\\<^sub>m N) (proj_k k))\n    (R + 1) \\<le>\\<^sub>L\n   1\\<^sub>m d\\<rbrakk>\n  \\<Longrightarrow> P' + Q \\<le>\\<^sub>L 1\\<^sub>m d\n\ngoal (1 subgoal):\n 1. P' + Q \\<le>\\<^sub>L 1\\<^sub>m d", "unfolding P'_add_Q"], ["proof (prove)\nusing this:\n  matrix_sum d (\\<lambda>k. tensor_P (1\\<^sub>m N) (proj_k k)) (R + 1)\n  \\<in> carrier_mat d d\n  matrix_sum d (\\<lambda>l. tensor_P (proj_psi_l l) (proj_k l))\n   (R + 1) \\<le>\\<^sub>L\n  matrix_sum d (\\<lambda>k. tensor_P (1\\<^sub>m N) (proj_k k)) (R + 1)\n  matrix_sum d (\\<lambda>k. tensor_P (1\\<^sub>m N) (proj_k k))\n   (R + 1) \\<le>\\<^sub>L\n  1\\<^sub>m d\n  \\<lbrakk>1\\<^sub>m d \\<in> carrier_mat d d;\n   matrix_sum d (\\<lambda>l. tensor_P (proj_psi_l l) (proj_k l))\n    (R + 1) \\<le>\\<^sub>L\n   matrix_sum d (\\<lambda>k. tensor_P (1\\<^sub>m N) (proj_k k)) (R + 1);\n   matrix_sum d (\\<lambda>k. tensor_P (1\\<^sub>m N) (proj_k k))\n    (R + 1) \\<le>\\<^sub>L\n   1\\<^sub>m d\\<rbrakk>\n  \\<Longrightarrow> matrix_sum d\n                     (\\<lambda>l. tensor_P (proj_psi_l l) (proj_k l))\n                     (R + 1) \\<le>\\<^sub>L\n                    1\\<^sub>m d\n\ngoal (1 subgoal):\n 1. matrix_sum d (\\<lambda>l. tensor_P (proj_psi_l l) (proj_k l))\n     (R + 1) \\<le>\\<^sub>L\n    1\\<^sub>m d", "by auto"], ["proof (state)\nthis:\n  P' + Q \\<le>\\<^sub>L 1\\<^sub>m d\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma qp_P'_Q:\n  \"is_quantum_predicate (P' + Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_quantum_predicate (P' + Q)", "unfolding is_quantum_predicate_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. P' + Q \\<in> carrier_mat d d \\<and>\n    positive (P' + Q) \\<and> P' + Q \\<le>\\<^sub>L 1\\<^sub>m d", "proof (intro conjI)"], ["proof (state)\ngoal (3 subgoals):\n 1. P' + Q \\<in> carrier_mat d d\n 2. positive (P' + Q)\n 3. P' + Q \\<le>\\<^sub>L 1\\<^sub>m d", "show \"P' + Q \\<in> carrier_mat d d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P' + Q \\<in> carrier_mat d d", "unfolding P'_add_Q"], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_sum d (\\<lambda>l. tensor_P (proj_psi_l l) (proj_k l)) (R + 1)\n    \\<in> carrier_mat d d", "apply (subst matrix_sum_dim)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>k.\n       k < R + 1 \\<Longrightarrow>\n       tensor_P (proj_psi_l k) (proj_k k) \\<in> carrier_mat d d\n 2. True", "using tensor_P_dim"], ["proof (prove)\nusing this:\n  tensor_P ?A ?B \\<in> carrier_mat d d\n\ngoal (2 subgoals):\n 1. \\<And>k.\n       k < R + 1 \\<Longrightarrow>\n       tensor_P (proj_psi_l k) (proj_k k) \\<in> carrier_mat d d\n 2. True", "by auto"], ["proof (state)\nthis:\n  P' + Q \\<in> carrier_mat d d\n\ngoal (2 subgoals):\n 1. positive (P' + Q)\n 2. P' + Q \\<le>\\<^sub>L 1\\<^sub>m d", "show \"positive (P' + Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. positive (P' + Q)", "unfolding P'_add_Q"], ["proof (prove)\ngoal (1 subgoal):\n 1. positive\n     (matrix_sum d (\\<lambda>l. tensor_P (proj_psi_l l) (proj_k l)) (R + 1))", "apply (subst matrix_sum_positive)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>k.\n       k < R + 1 \\<Longrightarrow>\n       tensor_P (proj_psi_l k) (proj_k k) \\<in> carrier_mat d d\n 2. \\<And>k.\n       k < R + 1 \\<Longrightarrow>\n       positive (tensor_P (proj_psi_l k) (proj_k k))\n 3. True", "using tensor_P_dim positive_Qk"], ["proof (prove)\nusing this:\n  tensor_P ?A ?B \\<in> carrier_mat d d\n  positive (tensor_P (proj_psi_l ?l) (proj_k ?l))\n\ngoal (3 subgoals):\n 1. \\<And>k.\n       k < R + 1 \\<Longrightarrow>\n       tensor_P (proj_psi_l k) (proj_k k) \\<in> carrier_mat d d\n 2. \\<And>k.\n       k < R + 1 \\<Longrightarrow>\n       positive (tensor_P (proj_psi_l k) (proj_k k))\n 3. True", "by auto"], ["proof (state)\nthis:\n  positive (P' + Q)\n\ngoal (1 subgoal):\n 1. P' + Q \\<le>\\<^sub>L 1\\<^sub>m d", "show \" P' + Q \\<le>\\<^sub>L 1\\<^sub>m d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P' + Q \\<le>\\<^sub>L 1\\<^sub>m d", "using P'_add_Q_le_one"], ["proof (prove)\nusing this:\n  P' + Q \\<le>\\<^sub>L 1\\<^sub>m d\n\ngoal (1 subgoal):\n 1. P' + Q \\<le>\\<^sub>L 1\\<^sub>m d", "by auto"], ["proof (state)\nthis:\n  P' + Q \\<le>\\<^sub>L 1\\<^sub>m d\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Q2_leq_lemma:\n  \"tensor_P (1\\<^sub>m N) (mat_incr K) * Q2 * adjoint (tensor_P (1\\<^sub>m N) (mat_incr K)) \\<le>\\<^sub>L P' + Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tensor_P (1\\<^sub>m N) (mat_incr K) * Q2 *\n    adjoint (tensor_P (1\\<^sub>m N) (mat_incr K)) \\<le>\\<^sub>L\n    P' + Q", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. tensor_P (1\\<^sub>m N) (mat_incr K) * Q2 *\n    adjoint (tensor_P (1\\<^sub>m N) (mat_incr K)) \\<le>\\<^sub>L\n    P' + Q", "have ad: \"adjoint (tensor_P (1\\<^sub>m N) (mat_incr K)) = tensor_P (1\\<^sub>m N) (adjoint (mat_incr K))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adjoint (tensor_P (1\\<^sub>m N) (mat_incr K)) =\n    tensor_P (1\\<^sub>m N) (adjoint (mat_incr K))", "unfolding ps2_P.ptensor_mat_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. adjoint (ps_P.tensor_mat (1\\<^sub>m N) (mat_incr K)) =\n    ps_P.tensor_mat (1\\<^sub>m N) (adjoint (mat_incr K))", "apply (subst ps_P.tensor_mat_adjoint)"], ["proof (prove)\ngoal (3 subgoals):\n 1. 1\\<^sub>m N \\<in> carrier_mat ps_P.d1 ps_P.d1\n 2. mat_incr K \\<in> carrier_mat ps_P.d2 ps_P.d2\n 3. ps_P.tensor_mat (adjoint (1\\<^sub>m N)) (adjoint (mat_incr K)) =\n    ps_P.tensor_mat (1\\<^sub>m N) (adjoint (mat_incr K))", "using ps_P_d1 ps_P_d2 mat_incr_dim adjoint_one"], ["proof (prove)\nusing this:\n  ps_P.d1 = N\n  ps_P.d2 = K\n  mat_incr ?n \\<in> carrier_mat ?n ?n\n  adjoint (1\\<^sub>m ?n) = 1\\<^sub>m ?n\n\ngoal (3 subgoals):\n 1. 1\\<^sub>m N \\<in> carrier_mat ps_P.d1 ps_P.d1\n 2. mat_incr K \\<in> carrier_mat ps_P.d2 ps_P.d2\n 3. ps_P.tensor_mat (adjoint (1\\<^sub>m N)) (adjoint (mat_incr K)) =\n    ps_P.tensor_mat (1\\<^sub>m N) (adjoint (mat_incr K))", "by auto"], ["proof (state)\nthis:\n  adjoint (tensor_P (1\\<^sub>m N) (mat_incr K)) =\n  tensor_P (1\\<^sub>m N) (adjoint (mat_incr K))\n\ngoal (1 subgoal):\n 1. tensor_P (1\\<^sub>m N) (mat_incr K) * Q2 *\n    adjoint (tensor_P (1\\<^sub>m N) (mat_incr K)) \\<le>\\<^sub>L\n    P' + Q", "let ?m1 = \"tensor_P (1\\<^sub>m N) (mat_incr K)\""], ["proof (state)\ngoal (1 subgoal):\n 1. tensor_P (1\\<^sub>m N) (mat_incr K) * Q2 *\n    adjoint (tensor_P (1\\<^sub>m N) (mat_incr K)) \\<le>\\<^sub>L\n    P' + Q", "let ?m3 = \"tensor_P (1\\<^sub>m N) (adjoint (mat_incr K))\""], ["proof (state)\ngoal (1 subgoal):\n 1. tensor_P (1\\<^sub>m N) (mat_incr K) * Q2 *\n    adjoint (tensor_P (1\\<^sub>m N) (mat_incr K)) \\<le>\\<^sub>L\n    P' + Q", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. tensor_P (1\\<^sub>m N) (mat_incr K) * Q2 *\n    adjoint (tensor_P (1\\<^sub>m N) (mat_incr K)) \\<le>\\<^sub>L\n    P' + Q", "fix l"], ["proof (state)\ngoal (1 subgoal):\n 1. tensor_P (1\\<^sub>m N) (mat_incr K) * Q2 *\n    adjoint (tensor_P (1\\<^sub>m N) (mat_incr K)) \\<le>\\<^sub>L\n    P' + Q", "assume \"l < R\""], ["proof (state)\nthis:\n  l < R\n\ngoal (1 subgoal):\n 1. tensor_P (1\\<^sub>m N) (mat_incr K) * Q2 *\n    adjoint (tensor_P (1\\<^sub>m N) (mat_incr K)) \\<le>\\<^sub>L\n    P' + Q", "then"], ["proof (chain)\npicking this:\n  l < R", "have \"l < K - 1\""], ["proof (prove)\nusing this:\n  l < R\n\ngoal (1 subgoal):\n 1. l < K - 1", "using K"], ["proof (prove)\nusing this:\n  l < R\n  R < K\n\ngoal (1 subgoal):\n 1. l < K - 1", "by auto"], ["proof (state)\nthis:\n  l < K - 1\n\ngoal (1 subgoal):\n 1. tensor_P (1\\<^sub>m N) (mat_incr K) * Q2 *\n    adjoint (tensor_P (1\\<^sub>m N) (mat_incr K)) \\<le>\\<^sub>L\n    P' + Q", "then"], ["proof (chain)\npicking this:\n  l < K - 1", "have m: \"(mat_incr K) *\\<^sub>v (ket_k l) = (ket_k (l + 1))\""], ["proof (prove)\nusing this:\n  l < K - 1\n\ngoal (1 subgoal):\n 1. mat_incr K *\\<^sub>v ket_k l = ket_k (l + 1)", "using mat_incr_mult_ket_k"], ["proof (prove)\nusing this:\n  l < K - 1\n  ?k < K \\<Longrightarrow>\n  mat_incr K *\\<^sub>v ket_k ?k = ket_k ((?k + 1) mod K)\n\ngoal (1 subgoal):\n 1. mat_incr K *\\<^sub>v ket_k l = ket_k (l + 1)", "by auto"], ["proof (state)\nthis:\n  mat_incr K *\\<^sub>v ket_k l = ket_k (l + 1)\n\ngoal (1 subgoal):\n 1. tensor_P (1\\<^sub>m N) (mat_incr K) * Q2 *\n    adjoint (tensor_P (1\\<^sub>m N) (mat_incr K)) \\<le>\\<^sub>L\n    P' + Q", "let ?m2 = \"tensor_P (proj_psi_l (l + 1)) (proj_k l)\""], ["proof (state)\ngoal (1 subgoal):\n 1. tensor_P (1\\<^sub>m N) (mat_incr K) * Q2 *\n    adjoint (tensor_P (1\\<^sub>m N) (mat_incr K)) \\<le>\\<^sub>L\n    P' + Q", "have eq: \"?m1 * ?m2 * ?m3 = tensor_P (proj_psi_l (l + 1)) ((mat_incr K) * (proj_k l) * adjoint (mat_incr K))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tensor_P (1\\<^sub>m N) (mat_incr K) *\n    tensor_P (proj_psi_l (l + 1)) (proj_k l) *\n    tensor_P (1\\<^sub>m N) (adjoint (mat_incr K)) =\n    tensor_P (proj_psi_l (l + 1))\n     (mat_incr K * proj_k l * adjoint (mat_incr K))", "apply (subst tensor_P_left_right_partial2)"], ["proof (prove)\ngoal (5 subgoals):\n 1. mat_incr K \\<in> carrier_mat K K\n 2. proj_k l \\<in> carrier_mat K K\n 3. proj_psi_l (l + 1) \\<in> carrier_mat N N\n 4. adjoint (mat_incr K) \\<in> carrier_mat K K\n 5. tensor_P (proj_psi_l (l + 1))\n     (mat_incr K * proj_k l * adjoint (mat_incr K)) =\n    tensor_P (proj_psi_l (l + 1))\n     (mat_incr K * proj_k l * adjoint (mat_incr K))", "using proj_k_dim proj_psi_l_dim mat_incr_dim adjoint_dim[OF mat_incr_dim]"], ["proof (prove)\nusing this:\n  proj_k ?k \\<in> carrier_mat K K\n  proj_psi_l ?l \\<in> carrier_mat N N\n  mat_incr ?n \\<in> carrier_mat ?n ?n\n  adjoint (mat_incr ?n) \\<in> carrier_mat ?n ?n\n\ngoal (5 subgoals):\n 1. mat_incr K \\<in> carrier_mat K K\n 2. proj_k l \\<in> carrier_mat K K\n 3. proj_psi_l (l + 1) \\<in> carrier_mat N N\n 4. adjoint (mat_incr K) \\<in> carrier_mat K K\n 5. tensor_P (proj_psi_l (l + 1))\n     (mat_incr K * proj_k l * adjoint (mat_incr K)) =\n    tensor_P (proj_psi_l (l + 1))\n     (mat_incr K * proj_k l * adjoint (mat_incr K))", "by auto"], ["proof (state)\nthis:\n  tensor_P (1\\<^sub>m N) (mat_incr K) *\n  tensor_P (proj_psi_l (l + 1)) (proj_k l) *\n  tensor_P (1\\<^sub>m N) (adjoint (mat_incr K)) =\n  tensor_P (proj_psi_l (l + 1))\n   (mat_incr K * proj_k l * adjoint (mat_incr K))\n\ngoal (1 subgoal):\n 1. tensor_P (1\\<^sub>m N) (mat_incr K) * Q2 *\n    adjoint (tensor_P (1\\<^sub>m N) (mat_incr K)) \\<le>\\<^sub>L\n    P' + Q", "have \"(mat_incr K) * (proj_k l) * adjoint (mat_incr K) = outer_prod ((mat_incr K) *\\<^sub>v (ket_k l)) ((mat_incr K) *\\<^sub>v (ket_k l))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_incr K * proj_k l * adjoint (mat_incr K) =\n    outer_prod (mat_incr K *\\<^sub>v ket_k l) (mat_incr K *\\<^sub>v ket_k l)", "unfolding proj_k_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_incr K * outer_prod (ket_k l) (ket_k l) * adjoint (mat_incr K) =\n    outer_prod (mat_incr K *\\<^sub>v ket_k l) (mat_incr K *\\<^sub>v ket_k l)", "apply (subst outer_prod_left_right_mat[of _ K _ K _ K _ K])"], ["proof (prove)\ngoal (4 subgoals):\n 1. ket_k l \\<in> carrier_vec K\n 2. mat_incr K \\<in> carrier_mat K K\n 3. adjoint (mat_incr K) \\<in> carrier_mat K K\n 4. outer_prod (mat_incr K *\\<^sub>v ket_k l)\n     (adjoint (adjoint (mat_incr K)) *\\<^sub>v ket_k l) =\n    outer_prod (mat_incr K *\\<^sub>v ket_k l) (mat_incr K *\\<^sub>v ket_k l)", "using ket_k_dim mat_incr_dim adjoint_dim[OF mat_incr_dim] adjoint_adjoint[of \"mat_incr K\"]"], ["proof (prove)\nusing this:\n  ket_k ?k \\<in> carrier_vec K\n  mat_incr ?n \\<in> carrier_mat ?n ?n\n  adjoint (mat_incr ?n) \\<in> carrier_mat ?n ?n\n  adjoint (adjoint (mat_incr K)) = mat_incr K\n\ngoal (4 subgoals):\n 1. ket_k l \\<in> carrier_vec K\n 2. mat_incr K \\<in> carrier_mat K K\n 3. adjoint (mat_incr K) \\<in> carrier_mat K K\n 4. outer_prod (mat_incr K *\\<^sub>v ket_k l)\n     (adjoint (adjoint (mat_incr K)) *\\<^sub>v ket_k l) =\n    outer_prod (mat_incr K *\\<^sub>v ket_k l) (mat_incr K *\\<^sub>v ket_k l)", "by auto"], ["proof (state)\nthis:\n  mat_incr K * proj_k l * adjoint (mat_incr K) =\n  outer_prod (mat_incr K *\\<^sub>v ket_k l) (mat_incr K *\\<^sub>v ket_k l)\n\ngoal (1 subgoal):\n 1. tensor_P (1\\<^sub>m N) (mat_incr K) * Q2 *\n    adjoint (tensor_P (1\\<^sub>m N) (mat_incr K)) \\<le>\\<^sub>L\n    P' + Q", "also"], ["proof (state)\nthis:\n  mat_incr K * proj_k l * adjoint (mat_incr K) =\n  outer_prod (mat_incr K *\\<^sub>v ket_k l) (mat_incr K *\\<^sub>v ket_k l)\n\ngoal (1 subgoal):\n 1. tensor_P (1\\<^sub>m N) (mat_incr K) * Q2 *\n    adjoint (tensor_P (1\\<^sub>m N) (mat_incr K)) \\<le>\\<^sub>L\n    P' + Q", "have \"\\<dots> = proj_k (l + 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. outer_prod (mat_incr K *\\<^sub>v ket_k l)\n     (mat_incr K *\\<^sub>v ket_k l) =\n    proj_k (l + 1)", "unfolding proj_k_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. outer_prod (mat_incr K *\\<^sub>v ket_k l)\n     (mat_incr K *\\<^sub>v ket_k l) =\n    outer_prod (ket_k (l + 1)) (ket_k (l + 1))", "using m"], ["proof (prove)\nusing this:\n  mat_incr K *\\<^sub>v ket_k l = ket_k (l + 1)\n\ngoal (1 subgoal):\n 1. outer_prod (mat_incr K *\\<^sub>v ket_k l)\n     (mat_incr K *\\<^sub>v ket_k l) =\n    outer_prod (ket_k (l + 1)) (ket_k (l + 1))", "by auto"], ["proof (state)\nthis:\n  outer_prod (mat_incr K *\\<^sub>v ket_k l) (mat_incr K *\\<^sub>v ket_k l) =\n  proj_k (l + 1)\n\ngoal (1 subgoal):\n 1. tensor_P (1\\<^sub>m N) (mat_incr K) * Q2 *\n    adjoint (tensor_P (1\\<^sub>m N) (mat_incr K)) \\<le>\\<^sub>L\n    P' + Q", "finally"], ["proof (chain)\npicking this:\n  mat_incr K * proj_k l * adjoint (mat_incr K) = proj_k (l + 1)", "have \"?m1 * ?m2 * ?m3 = tensor_P (proj_psi_l (l + 1)) (proj_k (l + 1))\""], ["proof (prove)\nusing this:\n  mat_incr K * proj_k l * adjoint (mat_incr K) = proj_k (l + 1)\n\ngoal (1 subgoal):\n 1. tensor_P (1\\<^sub>m N) (mat_incr K) *\n    tensor_P (proj_psi_l (l + 1)) (proj_k l) *\n    tensor_P (1\\<^sub>m N) (adjoint (mat_incr K)) =\n    tensor_P (proj_psi_l (l + 1)) (proj_k (l + 1))", "using eq"], ["proof (prove)\nusing this:\n  mat_incr K * proj_k l * adjoint (mat_incr K) = proj_k (l + 1)\n  tensor_P (1\\<^sub>m N) (mat_incr K) *\n  tensor_P (proj_psi_l (l + 1)) (proj_k l) *\n  tensor_P (1\\<^sub>m N) (adjoint (mat_incr K)) =\n  tensor_P (proj_psi_l (l + 1))\n   (mat_incr K * proj_k l * adjoint (mat_incr K))\n\ngoal (1 subgoal):\n 1. tensor_P (1\\<^sub>m N) (mat_incr K) *\n    tensor_P (proj_psi_l (l + 1)) (proj_k l) *\n    tensor_P (1\\<^sub>m N) (adjoint (mat_incr K)) =\n    tensor_P (proj_psi_l (l + 1)) (proj_k (l + 1))", "by auto"], ["proof (state)\nthis:\n  tensor_P (1\\<^sub>m N) (mat_incr K) *\n  tensor_P (proj_psi_l (l + 1)) (proj_k l) *\n  tensor_P (1\\<^sub>m N) (adjoint (mat_incr K)) =\n  tensor_P (proj_psi_l (l + 1)) (proj_k (l + 1))\n\ngoal (1 subgoal):\n 1. tensor_P (1\\<^sub>m N) (mat_incr K) * Q2 *\n    adjoint (tensor_P (1\\<^sub>m N) (mat_incr K)) \\<le>\\<^sub>L\n    P' + Q", "}"], ["proof (state)\nthis:\n  ?l4 < R \\<Longrightarrow>\n  tensor_P (1\\<^sub>m N) (mat_incr K) *\n  tensor_P (proj_psi_l (?l4 + 1)) (proj_k ?l4) *\n  tensor_P (1\\<^sub>m N) (adjoint (mat_incr K)) =\n  tensor_P (proj_psi_l (?l4 + 1)) (proj_k (?l4 + 1))\n\ngoal (1 subgoal):\n 1. tensor_P (1\\<^sub>m N) (mat_incr K) * Q2 *\n    adjoint (tensor_P (1\\<^sub>m N) (mat_incr K)) \\<le>\\<^sub>L\n    P' + Q", "note p1 = this"], ["proof (state)\nthis:\n  ?l4 < R \\<Longrightarrow>\n  tensor_P (1\\<^sub>m N) (mat_incr K) *\n  tensor_P (proj_psi_l (?l4 + 1)) (proj_k ?l4) *\n  tensor_P (1\\<^sub>m N) (adjoint (mat_incr K)) =\n  tensor_P (proj_psi_l (?l4 + 1)) (proj_k (?l4 + 1))\n\ngoal (1 subgoal):\n 1. tensor_P (1\\<^sub>m N) (mat_incr K) * Q2 *\n    adjoint (tensor_P (1\\<^sub>m N) (mat_incr K)) \\<le>\\<^sub>L\n    P' + Q", "have \"?m1 * Q2 * ?m3\n    = matrix_sum d (\\<lambda>l. ?m1 * (tensor_P (proj_psi_l (l + 1)) (proj_k l)) * ?m3) R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tensor_P (1\\<^sub>m N) (mat_incr K) * Q2 *\n    tensor_P (1\\<^sub>m N) (adjoint (mat_incr K)) =\n    matrix_sum d\n     (\\<lambda>l.\n         tensor_P (1\\<^sub>m N) (mat_incr K) *\n         tensor_P (proj_psi_l (l + 1)) (proj_k l) *\n         tensor_P (1\\<^sub>m N) (adjoint (mat_incr K)))\n     R", "unfolding Q2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. tensor_P (1\\<^sub>m N) (mat_incr K) *\n    matrix_sum d (\\<lambda>l. tensor_P (proj_psi_l (l + 1)) (proj_k l)) R *\n    tensor_P (1\\<^sub>m N) (adjoint (mat_incr K)) =\n    matrix_sum d\n     (\\<lambda>l.\n         tensor_P (1\\<^sub>m N) (mat_incr K) *\n         tensor_P (proj_psi_l (l + 1)) (proj_k l) *\n         tensor_P (1\\<^sub>m N) (adjoint (mat_incr K)))\n     R", "apply(subst matrix_sum_mult_left_right)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>k.\n       k < R \\<Longrightarrow>\n       tensor_P (proj_psi_l (k + 1)) (proj_k k) \\<in> carrier_mat d d\n 2. tensor_P (1\\<^sub>m N) (mat_incr K) \\<in> carrier_mat d d\n 3. tensor_P (1\\<^sub>m N) (adjoint (mat_incr K)) \\<in> carrier_mat d d\n 4. tensor_P (1\\<^sub>m N) (mat_incr K) *\n    matrix_sum d (\\<lambda>l. tensor_P (proj_psi_l (l + 1)) (proj_k l)) R *\n    tensor_P (1\\<^sub>m N) (adjoint (mat_incr K)) =\n    tensor_P (1\\<^sub>m N) (mat_incr K) *\n    matrix_sum d (\\<lambda>l. tensor_P (proj_psi_l (l + 1)) (proj_k l)) R *\n    tensor_P (1\\<^sub>m N) (adjoint (mat_incr K))", "using tensor_P_dim"], ["proof (prove)\nusing this:\n  tensor_P ?A ?B \\<in> carrier_mat d d\n\ngoal (4 subgoals):\n 1. \\<And>k.\n       k < R \\<Longrightarrow>\n       tensor_P (proj_psi_l (k + 1)) (proj_k k) \\<in> carrier_mat d d\n 2. tensor_P (1\\<^sub>m N) (mat_incr K) \\<in> carrier_mat d d\n 3. tensor_P (1\\<^sub>m N) (adjoint (mat_incr K)) \\<in> carrier_mat d d\n 4. tensor_P (1\\<^sub>m N) (mat_incr K) *\n    matrix_sum d (\\<lambda>l. tensor_P (proj_psi_l (l + 1)) (proj_k l)) R *\n    tensor_P (1\\<^sub>m N) (adjoint (mat_incr K)) =\n    tensor_P (1\\<^sub>m N) (mat_incr K) *\n    matrix_sum d (\\<lambda>l. tensor_P (proj_psi_l (l + 1)) (proj_k l)) R *\n    tensor_P (1\\<^sub>m N) (adjoint (mat_incr K))", "by auto"], ["proof (state)\nthis:\n  tensor_P (1\\<^sub>m N) (mat_incr K) * Q2 *\n  tensor_P (1\\<^sub>m N) (adjoint (mat_incr K)) =\n  matrix_sum d\n   (\\<lambda>l.\n       tensor_P (1\\<^sub>m N) (mat_incr K) *\n       tensor_P (proj_psi_l (l + 1)) (proj_k l) *\n       tensor_P (1\\<^sub>m N) (adjoint (mat_incr K)))\n   R\n\ngoal (1 subgoal):\n 1. tensor_P (1\\<^sub>m N) (mat_incr K) * Q2 *\n    adjoint (tensor_P (1\\<^sub>m N) (mat_incr K)) \\<le>\\<^sub>L\n    P' + Q", "also"], ["proof (state)\nthis:\n  tensor_P (1\\<^sub>m N) (mat_incr K) * Q2 *\n  tensor_P (1\\<^sub>m N) (adjoint (mat_incr K)) =\n  matrix_sum d\n   (\\<lambda>l.\n       tensor_P (1\\<^sub>m N) (mat_incr K) *\n       tensor_P (proj_psi_l (l + 1)) (proj_k l) *\n       tensor_P (1\\<^sub>m N) (adjoint (mat_incr K)))\n   R\n\ngoal (1 subgoal):\n 1. tensor_P (1\\<^sub>m N) (mat_incr K) * Q2 *\n    adjoint (tensor_P (1\\<^sub>m N) (mat_incr K)) \\<le>\\<^sub>L\n    P' + Q", "have \"\\<dots> = matrix_sum d (\\<lambda>l. tensor_P (proj_psi_l (l + 1)) (proj_k (l + 1))) R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_sum d\n     (\\<lambda>l.\n         tensor_P (1\\<^sub>m N) (mat_incr K) *\n         tensor_P (proj_psi_l (l + 1)) (proj_k l) *\n         tensor_P (1\\<^sub>m N) (adjoint (mat_incr K)))\n     R =\n    matrix_sum d\n     (\\<lambda>l. tensor_P (proj_psi_l (l + 1)) (proj_k (l + 1))) R", "apply (subst matrix_sum_cong)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>k.\n       k < R \\<Longrightarrow>\n       tensor_P (1\\<^sub>m N) (mat_incr K) *\n       tensor_P (proj_psi_l (k + 1)) (proj_k k) *\n       tensor_P (1\\<^sub>m N) (adjoint (mat_incr K)) =\n       ?f' k\n 2. matrix_sum d ?f' R =\n    matrix_sum d\n     (\\<lambda>l. tensor_P (proj_psi_l (l + 1)) (proj_k (l + 1))) R", "using p1"], ["proof (prove)\nusing this:\n  ?l4 < R \\<Longrightarrow>\n  tensor_P (1\\<^sub>m N) (mat_incr K) *\n  tensor_P (proj_psi_l (?l4 + 1)) (proj_k ?l4) *\n  tensor_P (1\\<^sub>m N) (adjoint (mat_incr K)) =\n  tensor_P (proj_psi_l (?l4 + 1)) (proj_k (?l4 + 1))\n\ngoal (2 subgoals):\n 1. \\<And>k.\n       k < R \\<Longrightarrow>\n       tensor_P (1\\<^sub>m N) (mat_incr K) *\n       tensor_P (proj_psi_l (k + 1)) (proj_k k) *\n       tensor_P (1\\<^sub>m N) (adjoint (mat_incr K)) =\n       ?f' k\n 2. matrix_sum d ?f' R =\n    matrix_sum d\n     (\\<lambda>l. tensor_P (proj_psi_l (l + 1)) (proj_k (l + 1))) R", "by auto"], ["proof (state)\nthis:\n  matrix_sum d\n   (\\<lambda>l.\n       tensor_P (1\\<^sub>m N) (mat_incr K) *\n       tensor_P (proj_psi_l (l + 1)) (proj_k l) *\n       tensor_P (1\\<^sub>m N) (adjoint (mat_incr K)))\n   R =\n  matrix_sum d (\\<lambda>l. tensor_P (proj_psi_l (l + 1)) (proj_k (l + 1)))\n   R\n\ngoal (1 subgoal):\n 1. tensor_P (1\\<^sub>m N) (mat_incr K) * Q2 *\n    adjoint (tensor_P (1\\<^sub>m N) (mat_incr K)) \\<le>\\<^sub>L\n    P' + Q", "finally"], ["proof (chain)\npicking this:\n  tensor_P (1\\<^sub>m N) (mat_incr K) * Q2 *\n  tensor_P (1\\<^sub>m N) (adjoint (mat_incr K)) =\n  matrix_sum d (\\<lambda>l. tensor_P (proj_psi_l (l + 1)) (proj_k (l + 1)))\n   R", "have eq1: \"?m1 * Q2 * ?m3 = matrix_sum d (\\<lambda>l. tensor_P (proj_psi_l (l + 1)) (proj_k (l + 1))) R\" (is \"_=?r\")"], ["proof (prove)\nusing this:\n  tensor_P (1\\<^sub>m N) (mat_incr K) * Q2 *\n  tensor_P (1\\<^sub>m N) (adjoint (mat_incr K)) =\n  matrix_sum d (\\<lambda>l. tensor_P (proj_psi_l (l + 1)) (proj_k (l + 1)))\n   R\n\ngoal (1 subgoal):\n 1. tensor_P (1\\<^sub>m N) (mat_incr K) * Q2 *\n    tensor_P (1\\<^sub>m N) (adjoint (mat_incr K)) =\n    matrix_sum d\n     (\\<lambda>l. tensor_P (proj_psi_l (l + 1)) (proj_k (l + 1))) R", "."], ["proof (state)\nthis:\n  tensor_P (1\\<^sub>m N) (mat_incr K) * Q2 *\n  tensor_P (1\\<^sub>m N) (adjoint (mat_incr K)) =\n  matrix_sum d (\\<lambda>l. tensor_P (proj_psi_l (l + 1)) (proj_k (l + 1)))\n   R\n\ngoal (1 subgoal):\n 1. tensor_P (1\\<^sub>m N) (mat_incr K) * Q2 *\n    adjoint (tensor_P (1\\<^sub>m N) (mat_incr K)) \\<le>\\<^sub>L\n    P' + Q", "have eq2: \"P' + Q = tensor_P (proj_psi_l 0) (proj_k 0) + ?r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P' + Q =\n    tensor_P (proj_psi_l 0) (proj_k 0) +\n    matrix_sum d\n     (\\<lambda>l. tensor_P (proj_psi_l (l + 1)) (proj_k (l + 1))) R", "unfolding P'_add_Q"], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_sum d (\\<lambda>l. tensor_P (proj_psi_l l) (proj_k l)) (R + 1) =\n    tensor_P (proj_psi_l 0) (proj_k 0) +\n    matrix_sum d\n     (\\<lambda>l. tensor_P (proj_psi_l (l + 1)) (proj_k (l + 1))) R", "apply (subst matrix_sum_Suc_remove_head)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>k.\n       k < R + 1 \\<Longrightarrow>\n       tensor_P (proj_psi_l k) (proj_k k) \\<in> carrier_mat d d\n 2. tensor_P (proj_psi_l 0) (proj_k 0) +\n    matrix_sum d\n     (\\<lambda>k. tensor_P (proj_psi_l (k + 1)) (proj_k (k + 1))) R =\n    tensor_P (proj_psi_l 0) (proj_k 0) +\n    matrix_sum d\n     (\\<lambda>l. tensor_P (proj_psi_l (l + 1)) (proj_k (l + 1))) R", "using tensor_P_dim"], ["proof (prove)\nusing this:\n  tensor_P ?A ?B \\<in> carrier_mat d d\n\ngoal (2 subgoals):\n 1. \\<And>k.\n       k < R + 1 \\<Longrightarrow>\n       tensor_P (proj_psi_l k) (proj_k k) \\<in> carrier_mat d d\n 2. tensor_P (proj_psi_l 0) (proj_k 0) +\n    matrix_sum d\n     (\\<lambda>k. tensor_P (proj_psi_l (k + 1)) (proj_k (k + 1))) R =\n    tensor_P (proj_psi_l 0) (proj_k 0) +\n    matrix_sum d\n     (\\<lambda>l. tensor_P (proj_psi_l (l + 1)) (proj_k (l + 1))) R", "by auto"], ["proof (state)\nthis:\n  P' + Q =\n  tensor_P (proj_psi_l 0) (proj_k 0) +\n  matrix_sum d (\\<lambda>l. tensor_P (proj_psi_l (l + 1)) (proj_k (l + 1)))\n   R\n\ngoal (1 subgoal):\n 1. tensor_P (1\\<^sub>m N) (mat_incr K) * Q2 *\n    adjoint (tensor_P (1\\<^sub>m N) (mat_incr K)) \\<le>\\<^sub>L\n    P' + Q", "have \"tensor_P (proj_psi_l 0) (proj_k 0) + ?r \\<le>\\<^sub>L P' + Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tensor_P (proj_psi_l 0) (proj_k 0) +\n    matrix_sum d\n     (\\<lambda>l. tensor_P (proj_psi_l (l + 1)) (proj_k (l + 1)))\n     R \\<le>\\<^sub>L\n    P' + Q", "unfolding eq2[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. P' + Q \\<le>\\<^sub>L P' + Q", "apply (subst lowner_le_refl)"], ["proof (prove)\ngoal (2 subgoals):\n 1. P' + Q \\<in> carrier_mat ?n ?n\n 2. True", "using P'_Q_dim"], ["proof (prove)\nusing this:\n  P' + Q \\<in> carrier_mat d d\n\ngoal (2 subgoals):\n 1. P' + Q \\<in> carrier_mat ?n ?n\n 2. True", "by auto"], ["proof (state)\nthis:\n  tensor_P (proj_psi_l 0) (proj_k 0) +\n  matrix_sum d (\\<lambda>l. tensor_P (proj_psi_l (l + 1)) (proj_k (l + 1)))\n   R \\<le>\\<^sub>L\n  P' + Q\n\ngoal (1 subgoal):\n 1. tensor_P (1\\<^sub>m N) (mat_incr K) * Q2 *\n    adjoint (tensor_P (1\\<^sub>m N) (mat_incr K)) \\<le>\\<^sub>L\n    P' + Q", "moreover"], ["proof (state)\nthis:\n  tensor_P (proj_psi_l 0) (proj_k 0) +\n  matrix_sum d (\\<lambda>l. tensor_P (proj_psi_l (l + 1)) (proj_k (l + 1)))\n   R \\<le>\\<^sub>L\n  P' + Q\n\ngoal (1 subgoal):\n 1. tensor_P (1\\<^sub>m N) (mat_incr K) * Q2 *\n    adjoint (tensor_P (1\\<^sub>m N) (mat_incr K)) \\<le>\\<^sub>L\n    P' + Q", "have \"positive (tensor_P (proj_psi_l 0) (proj_k 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. positive (tensor_P (proj_psi_l 0) (proj_k 0))", "unfolding ps2_P.ptensor_mat_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. positive (ps_P.tensor_mat (proj_psi_l 0) (proj_k 0))", "apply (subst ps_P.tensor_mat_positive)"], ["proof (prove)\ngoal (5 subgoals):\n 1. proj_psi_l 0 \\<in> carrier_mat ps_P.d1 ps_P.d1\n 2. proj_k 0 \\<in> carrier_mat ps_P.d2 ps_P.d2\n 3. positive (proj_psi_l 0)\n 4. positive (proj_k 0)\n 5. True", "unfolding ps_P_d1 ps_P_d2"], ["proof (prove)\ngoal (5 subgoals):\n 1. proj_psi_l 0 \\<in> carrier_mat N N\n 2. proj_k 0 \\<in> carrier_mat K K\n 3. positive (proj_psi_l 0)\n 4. positive (proj_k 0)\n 5. True", "using proj_psi_l_dim proj_k_dim positive_proj_psi_l positive_proj_k"], ["proof (prove)\nusing this:\n  proj_psi_l ?l \\<in> carrier_mat N N\n  proj_k ?k \\<in> carrier_mat K K\n  positive (proj_psi_l ?l)\n  positive (proj_k ?k)\n\ngoal (5 subgoals):\n 1. proj_psi_l 0 \\<in> carrier_mat N N\n 2. proj_k 0 \\<in> carrier_mat K K\n 3. positive (proj_psi_l 0)\n 4. positive (proj_k 0)\n 5. True", "by auto"], ["proof (state)\nthis:\n  positive (tensor_P (proj_psi_l 0) (proj_k 0))\n\ngoal (1 subgoal):\n 1. tensor_P (1\\<^sub>m N) (mat_incr K) * Q2 *\n    adjoint (tensor_P (1\\<^sub>m N) (mat_incr K)) \\<le>\\<^sub>L\n    P' + Q", "moreover"], ["proof (state)\nthis:\n  positive (tensor_P (proj_psi_l 0) (proj_k 0))\n\ngoal (1 subgoal):\n 1. tensor_P (1\\<^sub>m N) (mat_incr K) * Q2 *\n    adjoint (tensor_P (1\\<^sub>m N) (mat_incr K)) \\<le>\\<^sub>L\n    P' + Q", "have \"matrix_sum d (\\<lambda>l. tensor_P (proj_psi_l (l + 1)) (proj_k (l + 1))) R \\<in> carrier_mat d d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_sum d\n     (\\<lambda>l. tensor_P (proj_psi_l (l + 1)) (proj_k (l + 1))) R\n    \\<in> carrier_mat d d", "apply (subst matrix_sum_dim)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>k.\n       k < R \\<Longrightarrow>\n       tensor_P (proj_psi_l (k + 1)) (proj_k (k + 1)) \\<in> carrier_mat d d\n 2. True", "using tensor_P_dim"], ["proof (prove)\nusing this:\n  tensor_P ?A ?B \\<in> carrier_mat d d\n\ngoal (2 subgoals):\n 1. \\<And>k.\n       k < R \\<Longrightarrow>\n       tensor_P (proj_psi_l (k + 1)) (proj_k (k + 1)) \\<in> carrier_mat d d\n 2. True", "by auto"], ["proof (state)\nthis:\n  matrix_sum d (\\<lambda>l. tensor_P (proj_psi_l (l + 1)) (proj_k (l + 1)))\n   R\n  \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. tensor_P (1\\<^sub>m N) (mat_incr K) * Q2 *\n    adjoint (tensor_P (1\\<^sub>m N) (mat_incr K)) \\<le>\\<^sub>L\n    P' + Q", "ultimately"], ["proof (chain)\npicking this:\n  tensor_P (proj_psi_l 0) (proj_k 0) +\n  matrix_sum d (\\<lambda>l. tensor_P (proj_psi_l (l + 1)) (proj_k (l + 1)))\n   R \\<le>\\<^sub>L\n  P' + Q\n  positive (tensor_P (proj_psi_l 0) (proj_k 0))\n  matrix_sum d (\\<lambda>l. tensor_P (proj_psi_l (l + 1)) (proj_k (l + 1)))\n   R\n  \\<in> carrier_mat d d", "have \"?r \\<le>\\<^sub>L P' + Q\""], ["proof (prove)\nusing this:\n  tensor_P (proj_psi_l 0) (proj_k 0) +\n  matrix_sum d (\\<lambda>l. tensor_P (proj_psi_l (l + 1)) (proj_k (l + 1)))\n   R \\<le>\\<^sub>L\n  P' + Q\n  positive (tensor_P (proj_psi_l 0) (proj_k 0))\n  matrix_sum d (\\<lambda>l. tensor_P (proj_psi_l (l + 1)) (proj_k (l + 1)))\n   R\n  \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. matrix_sum d\n     (\\<lambda>l. tensor_P (proj_psi_l (l + 1)) (proj_k (l + 1)))\n     R \\<le>\\<^sub>L\n    P' + Q", "apply (subst add_positive_le_reduce2[of ?r d \"tensor_P (proj_psi_l 0) (proj_k 0)\" \"P' + Q\"])"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>tensor_P (proj_psi_l 0) (proj_k 0) +\n             matrix_sum d\n              (\\<lambda>l. tensor_P (proj_psi_l (l + 1)) (proj_k (l + 1)))\n              R \\<le>\\<^sub>L\n             P' + Q;\n     positive (tensor_P (proj_psi_l 0) (proj_k 0));\n     matrix_sum d\n      (\\<lambda>l. tensor_P (proj_psi_l (l + 1)) (proj_k (l + 1))) R\n     \\<in> carrier_mat d d\\<rbrakk>\n    \\<Longrightarrow> matrix_sum d\n                       (\\<lambda>l.\n                           tensor_P (proj_psi_l (l + 1)) (proj_k (l + 1)))\n                       R\n                      \\<in> carrier_mat d d\n 2. \\<lbrakk>tensor_P (proj_psi_l 0) (proj_k 0) +\n             matrix_sum d\n              (\\<lambda>l. tensor_P (proj_psi_l (l + 1)) (proj_k (l + 1)))\n              R \\<le>\\<^sub>L\n             P' + Q;\n     positive (tensor_P (proj_psi_l 0) (proj_k 0));\n     matrix_sum d\n      (\\<lambda>l. tensor_P (proj_psi_l (l + 1)) (proj_k (l + 1))) R\n     \\<in> carrier_mat d d\\<rbrakk>\n    \\<Longrightarrow> tensor_P (proj_psi_l 0) (proj_k 0)\n                      \\<in> carrier_mat d d\n 3. \\<lbrakk>tensor_P (proj_psi_l 0) (proj_k 0) +\n             matrix_sum d\n              (\\<lambda>l. tensor_P (proj_psi_l (l + 1)) (proj_k (l + 1)))\n              R \\<le>\\<^sub>L\n             P' + Q;\n     positive (tensor_P (proj_psi_l 0) (proj_k 0));\n     matrix_sum d\n      (\\<lambda>l. tensor_P (proj_psi_l (l + 1)) (proj_k (l + 1))) R\n     \\<in> carrier_mat d d\\<rbrakk>\n    \\<Longrightarrow> P' + Q \\<in> carrier_mat d d\n 4. \\<lbrakk>tensor_P (proj_psi_l 0) (proj_k 0) +\n             matrix_sum d\n              (\\<lambda>l. tensor_P (proj_psi_l (l + 1)) (proj_k (l + 1)))\n              R \\<le>\\<^sub>L\n             P' + Q;\n     positive (tensor_P (proj_psi_l 0) (proj_k 0));\n     matrix_sum d\n      (\\<lambda>l. tensor_P (proj_psi_l (l + 1)) (proj_k (l + 1))) R\n     \\<in> carrier_mat d d\\<rbrakk>\n    \\<Longrightarrow> positive (tensor_P (proj_psi_l 0) (proj_k 0))\n 5. \\<lbrakk>tensor_P (proj_psi_l 0) (proj_k 0) +\n             matrix_sum d\n              (\\<lambda>l. tensor_P (proj_psi_l (l + 1)) (proj_k (l + 1)))\n              R \\<le>\\<^sub>L\n             P' + Q;\n     positive (tensor_P (proj_psi_l 0) (proj_k 0));\n     matrix_sum d\n      (\\<lambda>l. tensor_P (proj_psi_l (l + 1)) (proj_k (l + 1))) R\n     \\<in> carrier_mat d d\\<rbrakk>\n    \\<Longrightarrow> tensor_P (proj_psi_l 0) (proj_k 0) +\n                      matrix_sum d\n                       (\\<lambda>l.\n                           tensor_P (proj_psi_l (l + 1)) (proj_k (l + 1)))\n                       R \\<le>\\<^sub>L\n                      P' + Q\n 6. \\<lbrakk>tensor_P (proj_psi_l 0) (proj_k 0) +\n             matrix_sum d\n              (\\<lambda>l. tensor_P (proj_psi_l (l + 1)) (proj_k (l + 1)))\n              R \\<le>\\<^sub>L\n             P' + Q;\n     positive (tensor_P (proj_psi_l 0) (proj_k 0));\n     matrix_sum d\n      (\\<lambda>l. tensor_P (proj_psi_l (l + 1)) (proj_k (l + 1))) R\n     \\<in> carrier_mat d d\\<rbrakk>\n    \\<Longrightarrow> True", "using tensor_P_dim P'_Q_dim"], ["proof (prove)\nusing this:\n  tensor_P ?A ?B \\<in> carrier_mat d d\n  P' + Q \\<in> carrier_mat d d\n\ngoal (6 subgoals):\n 1. \\<lbrakk>tensor_P (proj_psi_l 0) (proj_k 0) +\n             matrix_sum d\n              (\\<lambda>l. tensor_P (proj_psi_l (l + 1)) (proj_k (l + 1)))\n              R \\<le>\\<^sub>L\n             P' + Q;\n     positive (tensor_P (proj_psi_l 0) (proj_k 0));\n     matrix_sum d\n      (\\<lambda>l. tensor_P (proj_psi_l (l + 1)) (proj_k (l + 1))) R\n     \\<in> carrier_mat d d\\<rbrakk>\n    \\<Longrightarrow> matrix_sum d\n                       (\\<lambda>l.\n                           tensor_P (proj_psi_l (l + 1)) (proj_k (l + 1)))\n                       R\n                      \\<in> carrier_mat d d\n 2. \\<lbrakk>tensor_P (proj_psi_l 0) (proj_k 0) +\n             matrix_sum d\n              (\\<lambda>l. tensor_P (proj_psi_l (l + 1)) (proj_k (l + 1)))\n              R \\<le>\\<^sub>L\n             P' + Q;\n     positive (tensor_P (proj_psi_l 0) (proj_k 0));\n     matrix_sum d\n      (\\<lambda>l. tensor_P (proj_psi_l (l + 1)) (proj_k (l + 1))) R\n     \\<in> carrier_mat d d\\<rbrakk>\n    \\<Longrightarrow> tensor_P (proj_psi_l 0) (proj_k 0)\n                      \\<in> carrier_mat d d\n 3. \\<lbrakk>tensor_P (proj_psi_l 0) (proj_k 0) +\n             matrix_sum d\n              (\\<lambda>l. tensor_P (proj_psi_l (l + 1)) (proj_k (l + 1)))\n              R \\<le>\\<^sub>L\n             P' + Q;\n     positive (tensor_P (proj_psi_l 0) (proj_k 0));\n     matrix_sum d\n      (\\<lambda>l. tensor_P (proj_psi_l (l + 1)) (proj_k (l + 1))) R\n     \\<in> carrier_mat d d\\<rbrakk>\n    \\<Longrightarrow> P' + Q \\<in> carrier_mat d d\n 4. \\<lbrakk>tensor_P (proj_psi_l 0) (proj_k 0) +\n             matrix_sum d\n              (\\<lambda>l. tensor_P (proj_psi_l (l + 1)) (proj_k (l + 1)))\n              R \\<le>\\<^sub>L\n             P' + Q;\n     positive (tensor_P (proj_psi_l 0) (proj_k 0));\n     matrix_sum d\n      (\\<lambda>l. tensor_P (proj_psi_l (l + 1)) (proj_k (l + 1))) R\n     \\<in> carrier_mat d d\\<rbrakk>\n    \\<Longrightarrow> positive (tensor_P (proj_psi_l 0) (proj_k 0))\n 5. \\<lbrakk>tensor_P (proj_psi_l 0) (proj_k 0) +\n             matrix_sum d\n              (\\<lambda>l. tensor_P (proj_psi_l (l + 1)) (proj_k (l + 1)))\n              R \\<le>\\<^sub>L\n             P' + Q;\n     positive (tensor_P (proj_psi_l 0) (proj_k 0));\n     matrix_sum d\n      (\\<lambda>l. tensor_P (proj_psi_l (l + 1)) (proj_k (l + 1))) R\n     \\<in> carrier_mat d d\\<rbrakk>\n    \\<Longrightarrow> tensor_P (proj_psi_l 0) (proj_k 0) +\n                      matrix_sum d\n                       (\\<lambda>l.\n                           tensor_P (proj_psi_l (l + 1)) (proj_k (l + 1)))\n                       R \\<le>\\<^sub>L\n                      P' + Q\n 6. \\<lbrakk>tensor_P (proj_psi_l 0) (proj_k 0) +\n             matrix_sum d\n              (\\<lambda>l. tensor_P (proj_psi_l (l + 1)) (proj_k (l + 1)))\n              R \\<le>\\<^sub>L\n             P' + Q;\n     positive (tensor_P (proj_psi_l 0) (proj_k 0));\n     matrix_sum d\n      (\\<lambda>l. tensor_P (proj_psi_l (l + 1)) (proj_k (l + 1))) R\n     \\<in> carrier_mat d d\\<rbrakk>\n    \\<Longrightarrow> True", "by auto"], ["proof (state)\nthis:\n  matrix_sum d (\\<lambda>l. tensor_P (proj_psi_l (l + 1)) (proj_k (l + 1)))\n   R \\<le>\\<^sub>L\n  P' + Q\n\ngoal (1 subgoal):\n 1. tensor_P (1\\<^sub>m N) (mat_incr K) * Q2 *\n    adjoint (tensor_P (1\\<^sub>m N) (mat_incr K)) \\<le>\\<^sub>L\n    P' + Q", "then"], ["proof (chain)\npicking this:\n  matrix_sum d (\\<lambda>l. tensor_P (proj_psi_l (l + 1)) (proj_k (l + 1)))\n   R \\<le>\\<^sub>L\n  P' + Q", "show ?thesis"], ["proof (prove)\nusing this:\n  matrix_sum d (\\<lambda>l. tensor_P (proj_psi_l (l + 1)) (proj_k (l + 1)))\n   R \\<le>\\<^sub>L\n  P' + Q\n\ngoal (1 subgoal):\n 1. tensor_P (1\\<^sub>m N) (mat_incr K) * Q2 *\n    adjoint (tensor_P (1\\<^sub>m N) (mat_incr K)) \\<le>\\<^sub>L\n    P' + Q", "using eq1 ad"], ["proof (prove)\nusing this:\n  matrix_sum d (\\<lambda>l. tensor_P (proj_psi_l (l + 1)) (proj_k (l + 1)))\n   R \\<le>\\<^sub>L\n  P' + Q\n  tensor_P (1\\<^sub>m N) (mat_incr K) * Q2 *\n  tensor_P (1\\<^sub>m N) (adjoint (mat_incr K)) =\n  matrix_sum d (\\<lambda>l. tensor_P (proj_psi_l (l + 1)) (proj_k (l + 1)))\n   R\n  adjoint (tensor_P (1\\<^sub>m N) (mat_incr K)) =\n  tensor_P (1\\<^sub>m N) (adjoint (mat_incr K))\n\ngoal (1 subgoal):\n 1. tensor_P (1\\<^sub>m N) (mat_incr K) * Q2 *\n    adjoint (tensor_P (1\\<^sub>m N) (mat_incr K)) \\<le>\\<^sub>L\n    P' + Q", "by auto"], ["proof (state)\nthis:\n  tensor_P (1\\<^sub>m N) (mat_incr K) * Q2 *\n  adjoint (tensor_P (1\\<^sub>m N) (mat_incr K)) \\<le>\\<^sub>L\n  P' + Q\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Q2_leq:\n  \"Q2 \\<le>\\<^sub>L adjoint (tensor_P (1\\<^sub>m N) (mat_incr K)) * (P' + Q) * tensor_P (1\\<^sub>m N) (mat_incr K)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Q2 \\<le>\\<^sub>L\n    adjoint (tensor_P (1\\<^sub>m N) (mat_incr K)) * (P' + Q) *\n    tensor_P (1\\<^sub>m N) (mat_incr K)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Q2 \\<le>\\<^sub>L\n    adjoint (tensor_P (1\\<^sub>m N) (mat_incr K)) * (P' + Q) *\n    tensor_P (1\\<^sub>m N) (mat_incr K)", "let ?m1 = \"tensor_P (1\\<^sub>m N) (mat_incr K)\""], ["proof (state)\ngoal (1 subgoal):\n 1. Q2 \\<le>\\<^sub>L\n    adjoint (tensor_P (1\\<^sub>m N) (mat_incr K)) * (P' + Q) *\n    tensor_P (1\\<^sub>m N) (mat_incr K)", "let ?m2 = \"adjoint (tensor_P (1\\<^sub>m N) (mat_incr K))\""], ["proof (state)\ngoal (1 subgoal):\n 1. Q2 \\<le>\\<^sub>L\n    adjoint (tensor_P (1\\<^sub>m N) (mat_incr K)) * (P' + Q) *\n    tensor_P (1\\<^sub>m N) (mat_incr K)", "have \"?m1 * ?m2 = 1\\<^sub>m d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tensor_P (1\\<^sub>m N) (mat_incr K) *\n    adjoint (tensor_P (1\\<^sub>m N) (mat_incr K)) =\n    1\\<^sub>m d", "unfolding ps2_P.ptensor_mat_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ps_P.tensor_mat (1\\<^sub>m N) (mat_incr K) *\n    adjoint (ps_P.tensor_mat (1\\<^sub>m N) (mat_incr K)) =\n    1\\<^sub>m d", "apply (subst ps_P.tensor_mat_adjoint)"], ["proof (prove)\ngoal (3 subgoals):\n 1. 1\\<^sub>m N \\<in> carrier_mat ps_P.d1 ps_P.d1\n 2. mat_incr K \\<in> carrier_mat ps_P.d2 ps_P.d2\n 3. ps_P.tensor_mat (1\\<^sub>m N) (mat_incr K) *\n    ps_P.tensor_mat (adjoint (1\\<^sub>m N)) (adjoint (mat_incr K)) =\n    1\\<^sub>m d", "unfolding ps_P_d1 ps_P_d2"], ["proof (prove)\ngoal (3 subgoals):\n 1. 1\\<^sub>m N \\<in> carrier_mat N N\n 2. mat_incr K \\<in> carrier_mat K K\n 3. ps_P.tensor_mat (1\\<^sub>m N) (mat_incr K) *\n    ps_P.tensor_mat (adjoint (1\\<^sub>m N)) (adjoint (mat_incr K)) =\n    1\\<^sub>m d", "apply (auto simp add: mat_incr_dim adjoint_one)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ps_P.tensor_mat (1\\<^sub>m N) (mat_incr K) *\n    ps_P.tensor_mat (1\\<^sub>m N) (adjoint (mat_incr K)) =\n    1\\<^sub>m d", "apply (subst ps_P.tensor_mat_mult[symmetric])"], ["proof (prove)\ngoal (4 subgoals):\n 1. 1\\<^sub>m N \\<in> carrier_mat ps_P.d1 ps_P.d1\n 2. mat_incr K \\<in> carrier_mat ps_P.d2 ps_P.d2\n 3. adjoint (mat_incr K) \\<in> carrier_mat ps_P.d2 ps_P.d2\n 4. ps_P.tensor_mat (1\\<^sub>m N * 1\\<^sub>m N)\n     (mat_incr K * adjoint (mat_incr K)) =\n    1\\<^sub>m d", "unfolding ps_P_d1 ps_P_d2"], ["proof (prove)\ngoal (4 subgoals):\n 1. 1\\<^sub>m N \\<in> carrier_mat N N\n 2. mat_incr K \\<in> carrier_mat K K\n 3. adjoint (mat_incr K) \\<in> carrier_mat K K\n 4. ps_P.tensor_mat (1\\<^sub>m N * 1\\<^sub>m N)\n     (mat_incr K * adjoint (mat_incr K)) =\n    1\\<^sub>m d", "apply (auto simp add: mat_incr_dim adjoint_dim mat_incr_mult_adjoint_mat_incr)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ps_P.tensor_mat (1\\<^sub>m N) (1\\<^sub>m K) = 1\\<^sub>m d", "using ps_P.tensor_mat_id ps_P_d ps_P_d1 ps_P_d2"], ["proof (prove)\nusing this:\n  ps_P.tensor_mat (1\\<^sub>m ps_P.d1) (1\\<^sub>m ps_P.d2) = 1\\<^sub>m ps_P.d\n  ps_P.d = d\n  ps_P.d1 = N\n  ps_P.d2 = K\n\ngoal (1 subgoal):\n 1. ps_P.tensor_mat (1\\<^sub>m N) (1\\<^sub>m K) = 1\\<^sub>m d", "by auto"], ["proof (state)\nthis:\n  tensor_P (1\\<^sub>m N) (mat_incr K) *\n  adjoint (tensor_P (1\\<^sub>m N) (mat_incr K)) =\n  1\\<^sub>m d\n\ngoal (1 subgoal):\n 1. Q2 \\<le>\\<^sub>L\n    adjoint (tensor_P (1\\<^sub>m N) (mat_incr K)) * (P' + Q) *\n    tensor_P (1\\<^sub>m N) (mat_incr K)", "then"], ["proof (chain)\npicking this:\n  tensor_P (1\\<^sub>m N) (mat_incr K) *\n  adjoint (tensor_P (1\\<^sub>m N) (mat_incr K)) =\n  1\\<^sub>m d", "have inv: \"?m2 * ?m1 = 1\\<^sub>m d\""], ["proof (prove)\nusing this:\n  tensor_P (1\\<^sub>m N) (mat_incr K) *\n  adjoint (tensor_P (1\\<^sub>m N) (mat_incr K)) =\n  1\\<^sub>m d\n\ngoal (1 subgoal):\n 1. adjoint (tensor_P (1\\<^sub>m N) (mat_incr K)) *\n    tensor_P (1\\<^sub>m N) (mat_incr K) =\n    1\\<^sub>m d", "using mat_mult_left_right_inverse[of ?m1 d ?m2] \n        tensor_P_dim adjoint_dim"], ["proof (prove)\nusing this:\n  tensor_P (1\\<^sub>m N) (mat_incr K) *\n  adjoint (tensor_P (1\\<^sub>m N) (mat_incr K)) =\n  1\\<^sub>m d\n  \\<lbrakk>tensor_P (1\\<^sub>m N) (mat_incr K) \\<in> carrier_mat d d;\n   adjoint (tensor_P (1\\<^sub>m N) (mat_incr K)) \\<in> carrier_mat d d;\n   tensor_P (1\\<^sub>m N) (mat_incr K) *\n   adjoint (tensor_P (1\\<^sub>m N) (mat_incr K)) =\n   1\\<^sub>m d\\<rbrakk>\n  \\<Longrightarrow> adjoint (tensor_P (1\\<^sub>m N) (mat_incr K)) *\n                    tensor_P (1\\<^sub>m N) (mat_incr K) =\n                    1\\<^sub>m d\n  tensor_P ?A ?B \\<in> carrier_mat d d\n  ?A \\<in> carrier_mat ?n ?n \\<Longrightarrow>\n  adjoint ?A \\<in> carrier_mat ?n ?n\n\ngoal (1 subgoal):\n 1. adjoint (tensor_P (1\\<^sub>m N) (mat_incr K)) *\n    tensor_P (1\\<^sub>m N) (mat_incr K) =\n    1\\<^sub>m d", "by auto"], ["proof (state)\nthis:\n  adjoint (tensor_P (1\\<^sub>m N) (mat_incr K)) *\n  tensor_P (1\\<^sub>m N) (mat_incr K) =\n  1\\<^sub>m d\n\ngoal (1 subgoal):\n 1. Q2 \\<le>\\<^sub>L\n    adjoint (tensor_P (1\\<^sub>m N) (mat_incr K)) * (P' + Q) *\n    tensor_P (1\\<^sub>m N) (mat_incr K)", "have d: \"?m1 * Q2 * ?m2 \\<in> carrier_mat d d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tensor_P (1\\<^sub>m N) (mat_incr K) * Q2 *\n    adjoint (tensor_P (1\\<^sub>m N) (mat_incr K))\n    \\<in> carrier_mat d d", "using tensor_P_dim adjoint_dim[OF tensor_P_dim] Q2_dim"], ["proof (prove)\nusing this:\n  tensor_P ?A ?B \\<in> carrier_mat d d\n  adjoint (tensor_P ?A1 ?B1) \\<in> carrier_mat d d\n  Q2 \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. tensor_P (1\\<^sub>m N) (mat_incr K) * Q2 *\n    adjoint (tensor_P (1\\<^sub>m N) (mat_incr K))\n    \\<in> carrier_mat d d", "by fastforce"], ["proof (state)\nthis:\n  tensor_P (1\\<^sub>m N) (mat_incr K) * Q2 *\n  adjoint (tensor_P (1\\<^sub>m N) (mat_incr K))\n  \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. Q2 \\<le>\\<^sub>L\n    adjoint (tensor_P (1\\<^sub>m N) (mat_incr K)) * (P' + Q) *\n    tensor_P (1\\<^sub>m N) (mat_incr K)", "have le: \"?m2 * (?m1 * Q2 * ?m2) * ?m1 \\<le>\\<^sub>L ?m2 * (P' + Q) * ?m1\" (is \"lowner_le ?l ?r\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. adjoint (tensor_P (1\\<^sub>m N) (mat_incr K)) *\n    (tensor_P (1\\<^sub>m N) (mat_incr K) * Q2 *\n     adjoint (tensor_P (1\\<^sub>m N) (mat_incr K))) *\n    tensor_P (1\\<^sub>m N) (mat_incr K) \\<le>\\<^sub>L\n    adjoint (tensor_P (1\\<^sub>m N) (mat_incr K)) * (P' + Q) *\n    tensor_P (1\\<^sub>m N) (mat_incr K)", "apply (subst lowner_le_keep_under_measurement[of _ d])"], ["proof (prove)\ngoal (5 subgoals):\n 1. tensor_P (1\\<^sub>m N) (mat_incr K) \\<in> carrier_mat d d\n 2. tensor_P (1\\<^sub>m N) (mat_incr K) * Q2 *\n    adjoint (tensor_P (1\\<^sub>m N) (mat_incr K))\n    \\<in> carrier_mat d d\n 3. P' + Q \\<in> carrier_mat d d\n 4. tensor_P (1\\<^sub>m N) (mat_incr K) * Q2 *\n    adjoint (tensor_P (1\\<^sub>m N) (mat_incr K)) \\<le>\\<^sub>L\n    P' + Q\n 5. True", "using Q2_leq_lemma tensor_P_dim P'_Q_dim d"], ["proof (prove)\nusing this:\n  tensor_P (1\\<^sub>m N) (mat_incr K) * Q2 *\n  adjoint (tensor_P (1\\<^sub>m N) (mat_incr K)) \\<le>\\<^sub>L\n  P' + Q\n  tensor_P ?A ?B \\<in> carrier_mat d d\n  P' + Q \\<in> carrier_mat d d\n  tensor_P (1\\<^sub>m N) (mat_incr K) * Q2 *\n  adjoint (tensor_P (1\\<^sub>m N) (mat_incr K))\n  \\<in> carrier_mat d d\n\ngoal (5 subgoals):\n 1. tensor_P (1\\<^sub>m N) (mat_incr K) \\<in> carrier_mat d d\n 2. tensor_P (1\\<^sub>m N) (mat_incr K) * Q2 *\n    adjoint (tensor_P (1\\<^sub>m N) (mat_incr K))\n    \\<in> carrier_mat d d\n 3. P' + Q \\<in> carrier_mat d d\n 4. tensor_P (1\\<^sub>m N) (mat_incr K) * Q2 *\n    adjoint (tensor_P (1\\<^sub>m N) (mat_incr K)) \\<le>\\<^sub>L\n    P' + Q\n 5. True", "by auto"], ["proof (state)\nthis:\n  adjoint (tensor_P (1\\<^sub>m N) (mat_incr K)) *\n  (tensor_P (1\\<^sub>m N) (mat_incr K) * Q2 *\n   adjoint (tensor_P (1\\<^sub>m N) (mat_incr K))) *\n  tensor_P (1\\<^sub>m N) (mat_incr K) \\<le>\\<^sub>L\n  adjoint (tensor_P (1\\<^sub>m N) (mat_incr K)) * (P' + Q) *\n  tensor_P (1\\<^sub>m N) (mat_incr K)\n\ngoal (1 subgoal):\n 1. Q2 \\<le>\\<^sub>L\n    adjoint (tensor_P (1\\<^sub>m N) (mat_incr K)) * (P' + Q) *\n    tensor_P (1\\<^sub>m N) (mat_incr K)", "have \"?l = (?m2 * ?m1) * Q2 * (?m2 * ?m1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adjoint (tensor_P (1\\<^sub>m N) (mat_incr K)) *\n    (tensor_P (1\\<^sub>m N) (mat_incr K) * Q2 *\n     adjoint (tensor_P (1\\<^sub>m N) (mat_incr K))) *\n    tensor_P (1\\<^sub>m N) (mat_incr K) =\n    adjoint (tensor_P (1\\<^sub>m N) (mat_incr K)) *\n    tensor_P (1\\<^sub>m N) (mat_incr K) *\n    Q2 *\n    (adjoint (tensor_P (1\\<^sub>m N) (mat_incr K)) *\n     tensor_P (1\\<^sub>m N) (mat_incr K))", "apply (mat_assoc d)"], ["proof (prove)\ngoal (2 subgoals):\n 1. tensor_P (1\\<^sub>m N) (mat_incr K) \\<in> carrier_mat d d\n 2. Q2 \\<in> carrier_mat d d", "using tensor_P_dim Q2_dim"], ["proof (prove)\nusing this:\n  tensor_P ?A ?B \\<in> carrier_mat d d\n  Q2 \\<in> carrier_mat d d\n\ngoal (2 subgoals):\n 1. tensor_P (1\\<^sub>m N) (mat_incr K) \\<in> carrier_mat d d\n 2. Q2 \\<in> carrier_mat d d", "by auto"], ["proof (state)\nthis:\n  adjoint (tensor_P (1\\<^sub>m N) (mat_incr K)) *\n  (tensor_P (1\\<^sub>m N) (mat_incr K) * Q2 *\n   adjoint (tensor_P (1\\<^sub>m N) (mat_incr K))) *\n  tensor_P (1\\<^sub>m N) (mat_incr K) =\n  adjoint (tensor_P (1\\<^sub>m N) (mat_incr K)) *\n  tensor_P (1\\<^sub>m N) (mat_incr K) *\n  Q2 *\n  (adjoint (tensor_P (1\\<^sub>m N) (mat_incr K)) *\n   tensor_P (1\\<^sub>m N) (mat_incr K))\n\ngoal (1 subgoal):\n 1. Q2 \\<le>\\<^sub>L\n    adjoint (tensor_P (1\\<^sub>m N) (mat_incr K)) * (P' + Q) *\n    tensor_P (1\\<^sub>m N) (mat_incr K)", "also"], ["proof (state)\nthis:\n  adjoint (tensor_P (1\\<^sub>m N) (mat_incr K)) *\n  (tensor_P (1\\<^sub>m N) (mat_incr K) * Q2 *\n   adjoint (tensor_P (1\\<^sub>m N) (mat_incr K))) *\n  tensor_P (1\\<^sub>m N) (mat_incr K) =\n  adjoint (tensor_P (1\\<^sub>m N) (mat_incr K)) *\n  tensor_P (1\\<^sub>m N) (mat_incr K) *\n  Q2 *\n  (adjoint (tensor_P (1\\<^sub>m N) (mat_incr K)) *\n   tensor_P (1\\<^sub>m N) (mat_incr K))\n\ngoal (1 subgoal):\n 1. Q2 \\<le>\\<^sub>L\n    adjoint (tensor_P (1\\<^sub>m N) (mat_incr K)) * (P' + Q) *\n    tensor_P (1\\<^sub>m N) (mat_incr K)", "have \"\\<dots> = 1\\<^sub>m d * Q2 * 1\\<^sub>m d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adjoint (tensor_P (1\\<^sub>m N) (mat_incr K)) *\n    tensor_P (1\\<^sub>m N) (mat_incr K) *\n    Q2 *\n    (adjoint (tensor_P (1\\<^sub>m N) (mat_incr K)) *\n     tensor_P (1\\<^sub>m N) (mat_incr K)) =\n    1\\<^sub>m d * Q2 * 1\\<^sub>m d", "using inv"], ["proof (prove)\nusing this:\n  adjoint (tensor_P (1\\<^sub>m N) (mat_incr K)) *\n  tensor_P (1\\<^sub>m N) (mat_incr K) =\n  1\\<^sub>m d\n\ngoal (1 subgoal):\n 1. adjoint (tensor_P (1\\<^sub>m N) (mat_incr K)) *\n    tensor_P (1\\<^sub>m N) (mat_incr K) *\n    Q2 *\n    (adjoint (tensor_P (1\\<^sub>m N) (mat_incr K)) *\n     tensor_P (1\\<^sub>m N) (mat_incr K)) =\n    1\\<^sub>m d * Q2 * 1\\<^sub>m d", "by auto"], ["proof (state)\nthis:\n  adjoint (tensor_P (1\\<^sub>m N) (mat_incr K)) *\n  tensor_P (1\\<^sub>m N) (mat_incr K) *\n  Q2 *\n  (adjoint (tensor_P (1\\<^sub>m N) (mat_incr K)) *\n   tensor_P (1\\<^sub>m N) (mat_incr K)) =\n  1\\<^sub>m d * Q2 * 1\\<^sub>m d\n\ngoal (1 subgoal):\n 1. Q2 \\<le>\\<^sub>L\n    adjoint (tensor_P (1\\<^sub>m N) (mat_incr K)) * (P' + Q) *\n    tensor_P (1\\<^sub>m N) (mat_incr K)", "also"], ["proof (state)\nthis:\n  adjoint (tensor_P (1\\<^sub>m N) (mat_incr K)) *\n  tensor_P (1\\<^sub>m N) (mat_incr K) *\n  Q2 *\n  (adjoint (tensor_P (1\\<^sub>m N) (mat_incr K)) *\n   tensor_P (1\\<^sub>m N) (mat_incr K)) =\n  1\\<^sub>m d * Q2 * 1\\<^sub>m d\n\ngoal (1 subgoal):\n 1. Q2 \\<le>\\<^sub>L\n    adjoint (tensor_P (1\\<^sub>m N) (mat_incr K)) * (P' + Q) *\n    tensor_P (1\\<^sub>m N) (mat_incr K)", "have \"\\<dots> = Q2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1\\<^sub>m d * Q2 * 1\\<^sub>m d = Q2", "using Q2_dim"], ["proof (prove)\nusing this:\n  Q2 \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. 1\\<^sub>m d * Q2 * 1\\<^sub>m d = Q2", "by auto"], ["proof (state)\nthis:\n  1\\<^sub>m d * Q2 * 1\\<^sub>m d = Q2\n\ngoal (1 subgoal):\n 1. Q2 \\<le>\\<^sub>L\n    adjoint (tensor_P (1\\<^sub>m N) (mat_incr K)) * (P' + Q) *\n    tensor_P (1\\<^sub>m N) (mat_incr K)", "finally"], ["proof (chain)\npicking this:\n  adjoint (tensor_P (1\\<^sub>m N) (mat_incr K)) *\n  (tensor_P (1\\<^sub>m N) (mat_incr K) * Q2 *\n   adjoint (tensor_P (1\\<^sub>m N) (mat_incr K))) *\n  tensor_P (1\\<^sub>m N) (mat_incr K) =\n  Q2", "have eq: \"?l = Q2\""], ["proof (prove)\nusing this:\n  adjoint (tensor_P (1\\<^sub>m N) (mat_incr K)) *\n  (tensor_P (1\\<^sub>m N) (mat_incr K) * Q2 *\n   adjoint (tensor_P (1\\<^sub>m N) (mat_incr K))) *\n  tensor_P (1\\<^sub>m N) (mat_incr K) =\n  Q2\n\ngoal (1 subgoal):\n 1. adjoint (tensor_P (1\\<^sub>m N) (mat_incr K)) *\n    (tensor_P (1\\<^sub>m N) (mat_incr K) * Q2 *\n     adjoint (tensor_P (1\\<^sub>m N) (mat_incr K))) *\n    tensor_P (1\\<^sub>m N) (mat_incr K) =\n    Q2", "."], ["proof (state)\nthis:\n  adjoint (tensor_P (1\\<^sub>m N) (mat_incr K)) *\n  (tensor_P (1\\<^sub>m N) (mat_incr K) * Q2 *\n   adjoint (tensor_P (1\\<^sub>m N) (mat_incr K))) *\n  tensor_P (1\\<^sub>m N) (mat_incr K) =\n  Q2\n\ngoal (1 subgoal):\n 1. Q2 \\<le>\\<^sub>L\n    adjoint (tensor_P (1\\<^sub>m N) (mat_incr K)) * (P' + Q) *\n    tensor_P (1\\<^sub>m N) (mat_incr K)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. Q2 \\<le>\\<^sub>L\n    adjoint (tensor_P (1\\<^sub>m N) (mat_incr K)) * (P' + Q) *\n    tensor_P (1\\<^sub>m N) (mat_incr K)", "using eq le"], ["proof (prove)\nusing this:\n  adjoint (tensor_P (1\\<^sub>m N) (mat_incr K)) *\n  (tensor_P (1\\<^sub>m N) (mat_incr K) * Q2 *\n   adjoint (tensor_P (1\\<^sub>m N) (mat_incr K))) *\n  tensor_P (1\\<^sub>m N) (mat_incr K) =\n  Q2\n  adjoint (tensor_P (1\\<^sub>m N) (mat_incr K)) *\n  (tensor_P (1\\<^sub>m N) (mat_incr K) * Q2 *\n   adjoint (tensor_P (1\\<^sub>m N) (mat_incr K))) *\n  tensor_P (1\\<^sub>m N) (mat_incr K) \\<le>\\<^sub>L\n  adjoint (tensor_P (1\\<^sub>m N) (mat_incr K)) * (P' + Q) *\n  tensor_P (1\\<^sub>m N) (mat_incr K)\n\ngoal (1 subgoal):\n 1. Q2 \\<le>\\<^sub>L\n    adjoint (tensor_P (1\\<^sub>m N) (mat_incr K)) * (P' + Q) *\n    tensor_P (1\\<^sub>m N) (mat_incr K)", "by auto"], ["proof (state)\nthis:\n  Q2 \\<le>\\<^sub>L\n  adjoint (tensor_P (1\\<^sub>m N) (mat_incr K)) * (P' + Q) *\n  tensor_P (1\\<^sub>m N) (mat_incr K)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma hoare_triple_D3:\n  \"\\<turnstile>\\<^sub>p \n   {Q2}\n   Utrans_P vars2 (mat_incr K)\n   {adjoint exM0 * P' * exM0 + adjoint exM1 * Q * exM1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>p {Q2} Utrans_P vars2 (mat_incr K)\n                         {adjoint exM0 * P' * exM0 +\n                          adjoint exM1 * Q * exM1}", "unfolding exP0_P' exP1_Q"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>p {Q2} Utrans_P vars2 (mat_incr K) {P' + Q}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>p {Q2} Utrans_P vars2 (mat_incr K) {P' + Q}", "let ?m = \"tensor_P (1\\<^sub>m N) (mat_incr K)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>p {Q2} Utrans_P vars2 (mat_incr K) {P' + Q}", "have h1: \"\\<turnstile>\\<^sub>p \n    {adjoint ?m * (P' + Q) * ?m} \n    Utrans ?m\n    {P' + Q}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>p {adjoint (tensor_P (1\\<^sub>m N) (mat_incr K)) *\n                          (P' + Q) *\n                          tensor_P (1\\<^sub>m N) (mat_incr K)}\n                         Utrans (tensor_P (1\\<^sub>m N) (mat_incr K))\n                         {P' + Q}", "using qp_P'_Q hoare_partial.intros"], ["proof (prove)\nusing this:\n  is_quantum_predicate (P' + Q)\n  is_quantum_predicate ?P \\<Longrightarrow>\n  \\<turnstile>\\<^sub>p {?P} SKIP {?P}\n  is_quantum_predicate ?P \\<Longrightarrow>\n  \\<turnstile>\\<^sub>p {adjoint ?U * ?P * ?U} Utrans ?U {?P}\n  \\<lbrakk>is_quantum_predicate ?P; is_quantum_predicate ?Q;\n   is_quantum_predicate ?R; \\<turnstile>\\<^sub>p {?P} ?S1.0 {?Q};\n   \\<turnstile>\\<^sub>p {?Q} ?S2.0 {?R}\\<rbrakk>\n  \\<Longrightarrow> \\<turnstile>\\<^sub>p {?P} ?S1.0;; ?S2.0 {?R}\n  \\<lbrakk>\\<And>k. k < ?n \\<Longrightarrow> is_quantum_predicate (?P k);\n   is_quantum_predicate ?Q;\n   \\<And>k.\n      k < ?n \\<Longrightarrow>\n      \\<turnstile>\\<^sub>p {?P k} ?S ! k {?Q}\\<rbrakk>\n  \\<Longrightarrow> \\<turnstile>\\<^sub>p {matrix_sum d\n     (\\<lambda>k. adjoint (?M k) * ?P k * ?M k) ?n}\n   Measure ?n ?M ?S {?Q}\n  \\<lbrakk>is_quantum_predicate ?P; is_quantum_predicate ?Q;\n   \\<turnstile>\\<^sub>p {?Q} ?S\n                        {adjoint (?M 0) * ?P * ?M 0 +\n                         adjoint (?M 1) * ?Q * ?M 1}\\<rbrakk>\n  \\<Longrightarrow> \\<turnstile>\\<^sub>p {adjoint (?M 0) * ?P * ?M 0 +\n    adjoint (?M 1) * ?Q * ?M 1}\n   While ?M ?S {?P}\n  \\<lbrakk>is_quantum_predicate ?P; is_quantum_predicate ?Q;\n   is_quantum_predicate ?P'; is_quantum_predicate ?Q'; ?P \\<le>\\<^sub>L ?P';\n   \\<turnstile>\\<^sub>p {?P'} ?S {?Q'}; ?Q' \\<le>\\<^sub>L ?Q\\<rbrakk>\n  \\<Longrightarrow> \\<turnstile>\\<^sub>p {?P} ?S {?Q}\n\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>p {adjoint (tensor_P (1\\<^sub>m N) (mat_incr K)) *\n                          (P' + Q) *\n                          tensor_P (1\\<^sub>m N) (mat_incr K)}\n                         Utrans (tensor_P (1\\<^sub>m N) (mat_incr K))\n                         {P' + Q}", "by auto"], ["proof (state)\nthis:\n  \\<turnstile>\\<^sub>p {adjoint (tensor_P (1\\<^sub>m N) (mat_incr K)) *\n                        (P' + Q) *\n                        tensor_P (1\\<^sub>m N) (mat_incr K)}\n                       Utrans (tensor_P (1\\<^sub>m N) (mat_incr K)) {P' + Q}\n\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>p {Q2} Utrans_P vars2 (mat_incr K) {P' + Q}", "have qp: \"is_quantum_predicate (adjoint ?m * (P' + Q) * ?m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_quantum_predicate\n     (adjoint (tensor_P (1\\<^sub>m N) (mat_incr K)) * (P' + Q) *\n      tensor_P (1\\<^sub>m N) (mat_incr K))", "using qp_close_under_unitary_operator tensor_P_dim qp_P'_Q unitary_exmat_incr"], ["proof (prove)\nusing this:\n  \\<lbrakk>?U \\<in> carrier_mat d d; unitary ?U;\n   is_quantum_predicate ?P\\<rbrakk>\n  \\<Longrightarrow> is_quantum_predicate (adjoint ?U * ?P * ?U)\n  tensor_P ?A ?B \\<in> carrier_mat d d\n  is_quantum_predicate (P' + Q)\n  unitary (tensor_P (1\\<^sub>m N) (mat_incr K))\n\ngoal (1 subgoal):\n 1. is_quantum_predicate\n     (adjoint (tensor_P (1\\<^sub>m N) (mat_incr K)) * (P' + Q) *\n      tensor_P (1\\<^sub>m N) (mat_incr K))", "by auto"], ["proof (state)\nthis:\n  is_quantum_predicate\n   (adjoint (tensor_P (1\\<^sub>m N) (mat_incr K)) * (P' + Q) *\n    tensor_P (1\\<^sub>m N) (mat_incr K))\n\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>p {Q2} Utrans_P vars2 (mat_incr K) {P' + Q}", "then"], ["proof (chain)\npicking this:\n  is_quantum_predicate\n   (adjoint (tensor_P (1\\<^sub>m N) (mat_incr K)) * (P' + Q) *\n    tensor_P (1\\<^sub>m N) (mat_incr K))", "have \"\\<turnstile>\\<^sub>p \n    {Q2} \n    Utrans ?m\n    {P' + Q}\""], ["proof (prove)\nusing this:\n  is_quantum_predicate\n   (adjoint (tensor_P (1\\<^sub>m N) (mat_incr K)) * (P' + Q) *\n    tensor_P (1\\<^sub>m N) (mat_incr K))\n\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>p {Q2} Utrans (tensor_P (1\\<^sub>m N) (mat_incr K))\n                         {P' + Q}", "using hoare_partial.intros(6)[OF qp_Q2 qp_P'_Q qp qp_P'_Q] Q2_leq h1 lowner_le_refl[OF P'_Q_dim]"], ["proof (prove)\nusing this:\n  is_quantum_predicate\n   (adjoint (tensor_P (1\\<^sub>m N) (mat_incr K)) * (P' + Q) *\n    tensor_P (1\\<^sub>m N) (mat_incr K))\n  \\<lbrakk>Q2 \\<le>\\<^sub>L\n           adjoint (tensor_P (1\\<^sub>m N) (mat_incr K)) * (P' + Q) *\n           tensor_P (1\\<^sub>m N) (mat_incr K);\n   \\<turnstile>\\<^sub>p {adjoint (tensor_P (1\\<^sub>m N) (mat_incr K)) *\n                         (P' + Q) *\n                         tensor_P (1\\<^sub>m N) (mat_incr K)}\n                        ?S {P' + Q};\n   P' + Q \\<le>\\<^sub>L P' + Q\\<rbrakk>\n  \\<Longrightarrow> \\<turnstile>\\<^sub>p {Q2} ?S {P' + Q}\n  Q2 \\<le>\\<^sub>L\n  adjoint (tensor_P (1\\<^sub>m N) (mat_incr K)) * (P' + Q) *\n  tensor_P (1\\<^sub>m N) (mat_incr K)\n  \\<turnstile>\\<^sub>p {adjoint (tensor_P (1\\<^sub>m N) (mat_incr K)) *\n                        (P' + Q) *\n                        tensor_P (1\\<^sub>m N) (mat_incr K)}\n                       Utrans (tensor_P (1\\<^sub>m N) (mat_incr K)) {P' + Q}\n  P' + Q \\<le>\\<^sub>L P' + Q\n\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>p {Q2} Utrans (tensor_P (1\\<^sub>m N) (mat_incr K))\n                         {P' + Q}", "by auto"], ["proof (state)\nthis:\n  \\<turnstile>\\<^sub>p {Q2} Utrans (tensor_P (1\\<^sub>m N) (mat_incr K))\n                       {P' + Q}\n\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>p {Q2} Utrans_P vars2 (mat_incr K) {P' + Q}", "moreover"], ["proof (state)\nthis:\n  \\<turnstile>\\<^sub>p {Q2} Utrans (tensor_P (1\\<^sub>m N) (mat_incr K))\n                       {P' + Q}\n\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>p {Q2} Utrans_P vars2 (mat_incr K) {P' + Q}", "have \"Utrans ?m = Utrans_P vars2 (mat_incr K)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Utrans (tensor_P (1\\<^sub>m N) (mat_incr K)) =\n    Utrans_P vars2 (mat_incr K)", "apply (subst Utrans_P_is_tensor_P2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. mat_incr K \\<in> carrier_mat K K\n 2. Utrans (tensor_P (1\\<^sub>m N) (mat_incr K)) =\n    Utrans (tensor_P (1\\<^sub>m N) (mat_incr K))", "unfolding mat_incr_def"], ["proof (prove)\ngoal (2 subgoals):\n 1. mat K K\n     (\\<lambda>(i, j).\n         if i = 0 then if j = K - 1 then 1 else 0\n         else if i = j + 1 then 1 else 0)\n    \\<in> carrier_mat K K\n 2. Utrans\n     (tensor_P (1\\<^sub>m N)\n       (mat K K\n         (\\<lambda>(i, j).\n             if i = 0 then if j = K - 1 then 1 else 0\n             else if i = j + 1 then 1 else 0))) =\n    Utrans\n     (tensor_P (1\\<^sub>m N)\n       (mat K K\n         (\\<lambda>(i, j).\n             if i = 0 then if j = K - 1 then 1 else 0\n             else if i = j + 1 then 1 else 0)))", "by auto"], ["proof (state)\nthis:\n  Utrans (tensor_P (1\\<^sub>m N) (mat_incr K)) = Utrans_P vars2 (mat_incr K)\n\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>p {Q2} Utrans_P vars2 (mat_incr K) {P' + Q}", "ultimately"], ["proof (chain)\npicking this:\n  \\<turnstile>\\<^sub>p {Q2} Utrans (tensor_P (1\\<^sub>m N) (mat_incr K))\n                       {P' + Q}\n  Utrans (tensor_P (1\\<^sub>m N) (mat_incr K)) = Utrans_P vars2 (mat_incr K)", "show \"\\<turnstile>\\<^sub>p {Q2} Utrans_P vars2 (mat_incr K) {P' + Q}\""], ["proof (prove)\nusing this:\n  \\<turnstile>\\<^sub>p {Q2} Utrans (tensor_P (1\\<^sub>m N) (mat_incr K))\n                       {P' + Q}\n  Utrans (tensor_P (1\\<^sub>m N) (mat_incr K)) = Utrans_P vars2 (mat_incr K)\n\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>p {Q2} Utrans_P vars2 (mat_incr K) {P' + Q}", "by auto"], ["proof (state)\nthis:\n  \\<turnstile>\\<^sub>p {Q2} Utrans_P vars2 (mat_incr K) {P' + Q}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma qp_D3_post:\n  \"is_quantum_predicate (adjoint exM0 * P' * exM0 + adjoint exM1 * Q * exM1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_quantum_predicate\n     (adjoint exM0 * P' * exM0 + adjoint exM1 * Q * exM1)", "unfolding exP0_P' exP1_Q"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_quantum_predicate (P' + Q)", "using qp_P'_Q"], ["proof (prove)\nusing this:\n  is_quantum_predicate (P' + Q)\n\ngoal (1 subgoal):\n 1. is_quantum_predicate (P' + Q)", "by auto"], ["", "lemma hoare_triple_D:\n  \"\\<turnstile>\\<^sub>p \n   {Q} \n   D\n   {adjoint exM0 * P' * exM0 + adjoint exM1 * Q * exM1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>p {Q} D\n                         {adjoint exM0 * P' * exM0 +\n                          adjoint exM1 * Q * exM1}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>p {Q} D\n                         {adjoint exM0 * P' * exM0 +\n                          adjoint exM1 * Q * exM1}", "have \"\\<turnstile>\\<^sub>p {Q1} hadamard_n n;; (Utrans_P vars1 mat_Ph;; hadamard_n n) {Q2}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>p {Q1}\n                         hadamard_n n;;\n                         (Utrans_P vars1 mat_Ph;; hadamard_n n)\n                         {Q2}", "using  well_com_hadamard_n well_com_mat_Ph hoare_triple_D2 qp_Q1 qp_Q2"], ["proof (prove)\nusing this:\n  well_com (hadamard_n n)\n  well_com (Utrans_P vars1 mat_Ph)\n  \\<turnstile>\\<^sub>p {Q1}\n                       hadamard_n n;; Utrans_P vars1 mat_Ph;; hadamard_n n\n                       {Q2}\n  is_quantum_predicate Q1\n  is_quantum_predicate Q2\n\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>p {Q1}\n                         hadamard_n n;;\n                         (Utrans_P vars1 mat_Ph;; hadamard_n n)\n                         {Q2}", "by (auto simp add: hoare_patial_seq_assoc)"], ["proof (state)\nthis:\n  \\<turnstile>\\<^sub>p {Q1}\n                       hadamard_n n;; (Utrans_P vars1 mat_Ph;; hadamard_n n)\n                       {Q2}\n\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>p {Q} D\n                         {adjoint exM0 * P' * exM0 +\n                          adjoint exM1 * Q * exM1}", "then"], ["proof (chain)\npicking this:\n  \\<turnstile>\\<^sub>p {Q1}\n                       hadamard_n n;; (Utrans_P vars1 mat_Ph;; hadamard_n n)\n                       {Q2}", "have \"\\<turnstile>\\<^sub>p {Q} Utrans_P vars1 mat_O;; (hadamard_n n;; (Utrans_P vars1 mat_Ph;; hadamard_n n)) {Q2}\""], ["proof (prove)\nusing this:\n  \\<turnstile>\\<^sub>p {Q1}\n                       hadamard_n n;; (Utrans_P vars1 mat_Ph;; hadamard_n n)\n                       {Q2}\n\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>p {Q}\n                         Utrans_P vars1 mat_O;;\n                         (hadamard_n n;;\n                          (Utrans_P vars1 mat_Ph;; hadamard_n n))\n                         {Q2}", "using hoare_triple_D1 qp_Q qp_Q1 qp_Q2 hoare_partial.intros(3)"], ["proof (prove)\nusing this:\n  \\<turnstile>\\<^sub>p {Q1}\n                       hadamard_n n;; (Utrans_P vars1 mat_Ph;; hadamard_n n)\n                       {Q2}\n  \\<turnstile>\\<^sub>p {Q} Utrans_P vars1 mat_O {Q1}\n  is_quantum_predicate Q\n  is_quantum_predicate Q1\n  is_quantum_predicate Q2\n  \\<lbrakk>is_quantum_predicate ?P; is_quantum_predicate ?Q;\n   is_quantum_predicate ?R; \\<turnstile>\\<^sub>p {?P} ?S1.0 {?Q};\n   \\<turnstile>\\<^sub>p {?Q} ?S2.0 {?R}\\<rbrakk>\n  \\<Longrightarrow> \\<turnstile>\\<^sub>p {?P} ?S1.0;; ?S2.0 {?R}\n\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>p {Q}\n                         Utrans_P vars1 mat_O;;\n                         (hadamard_n n;;\n                          (Utrans_P vars1 mat_Ph;; hadamard_n n))\n                         {Q2}", "by auto"], ["proof (state)\nthis:\n  \\<turnstile>\\<^sub>p {Q}\n                       Utrans_P vars1 mat_O;;\n                       (hadamard_n n;;\n                        (Utrans_P vars1 mat_Ph;; hadamard_n n))\n                       {Q2}\n\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>p {Q} D\n                         {adjoint exM0 * P' * exM0 +\n                          adjoint exM1 * Q * exM1}", "moreover"], ["proof (state)\nthis:\n  \\<turnstile>\\<^sub>p {Q}\n                       Utrans_P vars1 mat_O;;\n                       (hadamard_n n;;\n                        (Utrans_P vars1 mat_Ph;; hadamard_n n))\n                       {Q2}\n\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>p {Q} D\n                         {adjoint exM0 * P' * exM0 +\n                          adjoint exM1 * Q * exM1}", "have \"well_com (Utrans_P vars1 mat_Ph;; hadamard_n n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. well_com (Utrans_P vars1 mat_Ph;; hadamard_n n)", "using well_com_hadamard_n well_com_mat_Ph"], ["proof (prove)\nusing this:\n  well_com (hadamard_n n)\n  well_com (Utrans_P vars1 mat_Ph)\n\ngoal (1 subgoal):\n 1. well_com (Utrans_P vars1 mat_Ph;; hadamard_n n)", "by auto"], ["proof (state)\nthis:\n  well_com (Utrans_P vars1 mat_Ph;; hadamard_n n)\n\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>p {Q} D\n                         {adjoint exM0 * P' * exM0 +\n                          adjoint exM1 * Q * exM1}", "ultimately"], ["proof (chain)\npicking this:\n  \\<turnstile>\\<^sub>p {Q}\n                       Utrans_P vars1 mat_O;;\n                       (hadamard_n n;;\n                        (Utrans_P vars1 mat_Ph;; hadamard_n n))\n                       {Q2}\n  well_com (Utrans_P vars1 mat_Ph;; hadamard_n n)", "have \"\\<turnstile>\\<^sub>p {Q} (Utrans_P vars1 mat_O;; hadamard_n n);; (Utrans_P vars1 mat_Ph;; hadamard_n n) {Q2}\""], ["proof (prove)\nusing this:\n  \\<turnstile>\\<^sub>p {Q}\n                       Utrans_P vars1 mat_O;;\n                       (hadamard_n n;;\n                        (Utrans_P vars1 mat_Ph;; hadamard_n n))\n                       {Q2}\n  well_com (Utrans_P vars1 mat_Ph;; hadamard_n n)\n\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>p {Q}\n                         Utrans_P vars1 mat_O;; hadamard_n n;;\n                         (Utrans_P vars1 mat_Ph;; hadamard_n n)\n                         {Q2}", "using well_com_hadamard_n well_com_mat_O qp_Q qp_Q2"], ["proof (prove)\nusing this:\n  \\<turnstile>\\<^sub>p {Q}\n                       Utrans_P vars1 mat_O;;\n                       (hadamard_n n;;\n                        (Utrans_P vars1 mat_Ph;; hadamard_n n))\n                       {Q2}\n  well_com (Utrans_P vars1 mat_Ph;; hadamard_n n)\n  well_com (hadamard_n n)\n  well_com (Utrans_P vars1 mat_O)\n  is_quantum_predicate Q\n  is_quantum_predicate Q2\n\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>p {Q}\n                         Utrans_P vars1 mat_O;; hadamard_n n;;\n                         (Utrans_P vars1 mat_Ph;; hadamard_n n)\n                         {Q2}", "by (auto simp add: hoare_patial_seq_assoc)"], ["proof (state)\nthis:\n  \\<turnstile>\\<^sub>p {Q}\n                       Utrans_P vars1 mat_O;; hadamard_n n;;\n                       (Utrans_P vars1 mat_Ph;; hadamard_n n)\n                       {Q2}\n\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>p {Q} D\n                         {adjoint exM0 * P' * exM0 +\n                          adjoint exM1 * Q * exM1}", "moreover"], ["proof (state)\nthis:\n  \\<turnstile>\\<^sub>p {Q}\n                       Utrans_P vars1 mat_O;; hadamard_n n;;\n                       (Utrans_P vars1 mat_Ph;; hadamard_n n)\n                       {Q2}\n\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>p {Q} D\n                         {adjoint exM0 * P' * exM0 +\n                          adjoint exM1 * Q * exM1}", "have \"well_com (Utrans_P vars1 mat_O;; hadamard_n n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. well_com (Utrans_P vars1 mat_O;; hadamard_n n)", "using well_com_mat_O well_com_hadamard_n"], ["proof (prove)\nusing this:\n  well_com (Utrans_P vars1 mat_O)\n  well_com (hadamard_n n)\n\ngoal (1 subgoal):\n 1. well_com (Utrans_P vars1 mat_O;; hadamard_n n)", "by auto"], ["proof (state)\nthis:\n  well_com (Utrans_P vars1 mat_O;; hadamard_n n)\n\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>p {Q} D\n                         {adjoint exM0 * P' * exM0 +\n                          adjoint exM1 * Q * exM1}", "ultimately"], ["proof (chain)\npicking this:\n  \\<turnstile>\\<^sub>p {Q}\n                       Utrans_P vars1 mat_O;; hadamard_n n;;\n                       (Utrans_P vars1 mat_Ph;; hadamard_n n)\n                       {Q2}\n  well_com (Utrans_P vars1 mat_O;; hadamard_n n)", "have \"\\<turnstile>\\<^sub>p {Q} Utrans_P vars1 mat_O;; hadamard_n n;; Utrans_P vars1 mat_Ph;; hadamard_n n {Q2}\""], ["proof (prove)\nusing this:\n  \\<turnstile>\\<^sub>p {Q}\n                       Utrans_P vars1 mat_O;; hadamard_n n;;\n                       (Utrans_P vars1 mat_Ph;; hadamard_n n)\n                       {Q2}\n  well_com (Utrans_P vars1 mat_O;; hadamard_n n)\n\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>p {Q}\n                         Utrans_P vars1 mat_O;; hadamard_n n;;\n                         Utrans_P vars1 mat_Ph;; hadamard_n n\n                         {Q2}", "using well_com_hadamard_n well_com_mat_Ph qp_Q qp_Q2"], ["proof (prove)\nusing this:\n  \\<turnstile>\\<^sub>p {Q}\n                       Utrans_P vars1 mat_O;; hadamard_n n;;\n                       (Utrans_P vars1 mat_Ph;; hadamard_n n)\n                       {Q2}\n  well_com (Utrans_P vars1 mat_O;; hadamard_n n)\n  well_com (hadamard_n n)\n  well_com (Utrans_P vars1 mat_Ph)\n  is_quantum_predicate Q\n  is_quantum_predicate Q2\n\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>p {Q}\n                         Utrans_P vars1 mat_O;; hadamard_n n;;\n                         Utrans_P vars1 mat_Ph;; hadamard_n n\n                         {Q2}", "by (auto simp add: hoare_patial_seq_assoc)"], ["proof (state)\nthis:\n  \\<turnstile>\\<^sub>p {Q}\n                       Utrans_P vars1 mat_O;; hadamard_n n;;\n                       Utrans_P vars1 mat_Ph;; hadamard_n n\n                       {Q2}\n\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>p {Q} D\n                         {adjoint exM0 * P' * exM0 +\n                          adjoint exM1 * Q * exM1}", "with qp_Q qp_Q2 qp_D3_post hoare_triple_D3"], ["proof (chain)\npicking this:\n  is_quantum_predicate Q\n  is_quantum_predicate Q2\n  is_quantum_predicate (adjoint exM0 * P' * exM0 + adjoint exM1 * Q * exM1)\n  \\<turnstile>\\<^sub>p {Q2} Utrans_P vars2 (mat_incr K)\n                       {adjoint exM0 * P' * exM0 + adjoint exM1 * Q * exM1}\n  \\<turnstile>\\<^sub>p {Q}\n                       Utrans_P vars1 mat_O;; hadamard_n n;;\n                       Utrans_P vars1 mat_Ph;; hadamard_n n\n                       {Q2}", "show \"\\<turnstile>\\<^sub>p \n   {Q} \n   D\n   {adjoint exM0 * P' * exM0 + adjoint exM1 * Q * exM1}\""], ["proof (prove)\nusing this:\n  is_quantum_predicate Q\n  is_quantum_predicate Q2\n  is_quantum_predicate (adjoint exM0 * P' * exM0 + adjoint exM1 * Q * exM1)\n  \\<turnstile>\\<^sub>p {Q2} Utrans_P vars2 (mat_incr K)\n                       {adjoint exM0 * P' * exM0 + adjoint exM1 * Q * exM1}\n  \\<turnstile>\\<^sub>p {Q}\n                       Utrans_P vars1 mat_O;; hadamard_n n;;\n                       Utrans_P vars1 mat_Ph;; hadamard_n n\n                       {Q2}\n\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>p {Q} D\n                         {adjoint exM0 * P' * exM0 +\n                          adjoint exM1 * Q * exM1}", "unfolding D_def"], ["proof (prove)\nusing this:\n  is_quantum_predicate Q\n  is_quantum_predicate Q2\n  is_quantum_predicate (adjoint exM0 * P' * exM0 + adjoint exM1 * Q * exM1)\n  \\<turnstile>\\<^sub>p {Q2} Utrans_P vars2 (mat_incr K)\n                       {adjoint exM0 * P' * exM0 + adjoint exM1 * Q * exM1}\n  \\<turnstile>\\<^sub>p {Q}\n                       Utrans_P vars1 mat_O;; hadamard_n n;;\n                       Utrans_P vars1 mat_Ph;; hadamard_n n\n                       {Q2}\n\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>p {Q}\n                         Utrans_P vars1 mat_O;; hadamard_n n;;\n                         Utrans_P vars1 mat_Ph;; hadamard_n n;;\n                         Utrans_P vars2 (mat_incr K)\n                         {adjoint exM0 * P' * exM0 +\n                          adjoint exM1 * Q * exM1}", "using hoare_partial.intros(3)"], ["proof (prove)\nusing this:\n  is_quantum_predicate Q\n  is_quantum_predicate Q2\n  is_quantum_predicate (adjoint exM0 * P' * exM0 + adjoint exM1 * Q * exM1)\n  \\<turnstile>\\<^sub>p {Q2} Utrans_P vars2 (mat_incr K)\n                       {adjoint exM0 * P' * exM0 + adjoint exM1 * Q * exM1}\n  \\<turnstile>\\<^sub>p {Q}\n                       Utrans_P vars1 mat_O;; hadamard_n n;;\n                       Utrans_P vars1 mat_Ph;; hadamard_n n\n                       {Q2}\n  \\<lbrakk>is_quantum_predicate ?P; is_quantum_predicate ?Q;\n   is_quantum_predicate ?R; \\<turnstile>\\<^sub>p {?P} ?S1.0 {?Q};\n   \\<turnstile>\\<^sub>p {?Q} ?S2.0 {?R}\\<rbrakk>\n  \\<Longrightarrow> \\<turnstile>\\<^sub>p {?P} ?S1.0;; ?S2.0 {?R}\n\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>p {Q}\n                         Utrans_P vars1 mat_O;; hadamard_n n;;\n                         Utrans_P vars1 mat_Ph;; hadamard_n n;;\n                         Utrans_P vars2 (mat_incr K)\n                         {adjoint exM0 * P' * exM0 +\n                          adjoint exM1 * Q * exM1}", "by auto"], ["proof (state)\nthis:\n  \\<turnstile>\\<^sub>p {Q} D\n                       {adjoint exM0 * P' * exM0 + adjoint exM1 * Q * exM1}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma psi_is_psi_l0:\n  \"\\<psi> = psi_l 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<psi> = psi_l 0", "unfolding \\<psi>_eq psi_l_def alpha_l_def beta_l_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. complex_of_real (cos (\\<theta> / 2)) \\<cdot>\\<^sub>v \\<alpha> +\n    complex_of_real (sin (\\<theta> / 2)) \\<cdot>\\<^sub>v \\<beta> =\n    complex_of_real (cos ((real 0 + 1 / 2) * \\<theta>)) \\<cdot>\\<^sub>v\n    \\<alpha> +\n    complex_of_real (sin ((real 0 + 1 / 2) * \\<theta>)) \\<cdot>\\<^sub>v\n    \\<beta>", "by auto"], ["", "lemma proj_psi_is_proj_psi_l0:\n  \"proj_psi = proj_psi_l 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proj_psi = proj_psi_l 0", "unfolding proj_psi_def psi_is_psi_l0 proj_psi_l_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. outer_prod (psi_l 0) (psi_l 0) = outer_prod (psi_l 0) (psi_l 0)", "by auto"], ["", "lemma lowner_le_Q:\n  \"tensor_P proj_psi (proj_k 0) \\<le>\\<^sub>L adjoint exM0 * P' * exM0 + adjoint exM1 * Q * exM1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tensor_P proj_psi (proj_k 0) \\<le>\\<^sub>L\n    adjoint exM0 * P' * exM0 + adjoint exM1 * Q * exM1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. tensor_P proj_psi (proj_k 0) \\<le>\\<^sub>L\n    adjoint exM0 * P' * exM0 + adjoint exM1 * Q * exM1", "let ?r = \"matrix_sum d (\\<lambda>l. tensor_P (proj_psi_l l) (proj_k l)) (R + 1)\""], ["proof (state)\ngoal (1 subgoal):\n 1. tensor_P proj_psi (proj_k 0) \\<le>\\<^sub>L\n    adjoint exM0 * P' * exM0 + adjoint exM1 * Q * exM1", "let ?l = \"tensor_P (proj_psi_l 0) (proj_k 0)\""], ["proof (state)\ngoal (1 subgoal):\n 1. tensor_P proj_psi (proj_k 0) \\<le>\\<^sub>L\n    adjoint exM0 * P' * exM0 + adjoint exM1 * Q * exM1", "have eq: \"?r = ?l + matrix_sum d (\\<lambda>l. tensor_P (proj_psi_l (l + 1)) (proj_k (l + 1))) R\" (is \"_ = _ + ?s\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_sum d (\\<lambda>l. tensor_P (proj_psi_l l) (proj_k l)) (R + 1) =\n    tensor_P (proj_psi_l 0) (proj_k 0) +\n    matrix_sum d\n     (\\<lambda>l. tensor_P (proj_psi_l (l + 1)) (proj_k (l + 1))) R", "apply (subst matrix_sum_Suc_remove_head)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>k.\n       k < R + 1 \\<Longrightarrow>\n       tensor_P (proj_psi_l k) (proj_k k) \\<in> carrier_mat d d\n 2. tensor_P (proj_psi_l 0) (proj_k 0) +\n    matrix_sum d\n     (\\<lambda>k. tensor_P (proj_psi_l (k + 1)) (proj_k (k + 1))) R =\n    tensor_P (proj_psi_l 0) (proj_k 0) +\n    matrix_sum d\n     (\\<lambda>l. tensor_P (proj_psi_l (l + 1)) (proj_k (l + 1))) R", "using tensor_P_dim"], ["proof (prove)\nusing this:\n  tensor_P ?A ?B \\<in> carrier_mat d d\n\ngoal (2 subgoals):\n 1. \\<And>k.\n       k < R + 1 \\<Longrightarrow>\n       tensor_P (proj_psi_l k) (proj_k k) \\<in> carrier_mat d d\n 2. tensor_P (proj_psi_l 0) (proj_k 0) +\n    matrix_sum d\n     (\\<lambda>k. tensor_P (proj_psi_l (k + 1)) (proj_k (k + 1))) R =\n    tensor_P (proj_psi_l 0) (proj_k 0) +\n    matrix_sum d\n     (\\<lambda>l. tensor_P (proj_psi_l (l + 1)) (proj_k (l + 1))) R", "by auto"], ["proof (state)\nthis:\n  matrix_sum d (\\<lambda>l. tensor_P (proj_psi_l l) (proj_k l)) (R + 1) =\n  tensor_P (proj_psi_l 0) (proj_k 0) +\n  matrix_sum d (\\<lambda>l. tensor_P (proj_psi_l (l + 1)) (proj_k (l + 1)))\n   R\n\ngoal (1 subgoal):\n 1. tensor_P proj_psi (proj_k 0) \\<le>\\<^sub>L\n    adjoint exM0 * P' * exM0 + adjoint exM1 * Q * exM1", "have d: \"?s \\<in> carrier_mat d d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_sum d\n     (\\<lambda>l. tensor_P (proj_psi_l (l + 1)) (proj_k (l + 1))) R\n    \\<in> carrier_mat d d", "apply (subst matrix_sum_dim)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>k.\n       k < R \\<Longrightarrow>\n       tensor_P (proj_psi_l (k + 1)) (proj_k (k + 1)) \\<in> carrier_mat d d\n 2. True", "using tensor_P_dim"], ["proof (prove)\nusing this:\n  tensor_P ?A ?B \\<in> carrier_mat d d\n\ngoal (2 subgoals):\n 1. \\<And>k.\n       k < R \\<Longrightarrow>\n       tensor_P (proj_psi_l (k + 1)) (proj_k (k + 1)) \\<in> carrier_mat d d\n 2. True", "by auto"], ["proof (state)\nthis:\n  matrix_sum d (\\<lambda>l. tensor_P (proj_psi_l (l + 1)) (proj_k (l + 1)))\n   R\n  \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. tensor_P proj_psi (proj_k 0) \\<le>\\<^sub>L\n    adjoint exM0 * P' * exM0 + adjoint exM1 * Q * exM1", "have pt: \"positive (tensor_P (proj_psi_l l) (proj_k l))\" for l"], ["proof (prove)\ngoal (1 subgoal):\n 1. positive (tensor_P (proj_psi_l l) (proj_k l))", "unfolding ps2_P.ptensor_mat_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. positive (ps_P.tensor_mat (proj_psi_l l) (proj_k l))", "apply (subst ps_P.tensor_mat_positive)"], ["proof (prove)\ngoal (5 subgoals):\n 1. proj_psi_l l \\<in> carrier_mat ps_P.d1 ps_P.d1\n 2. proj_k l \\<in> carrier_mat ps_P.d2 ps_P.d2\n 3. positive (proj_psi_l l)\n 4. positive (proj_k l)\n 5. True", "unfolding ps_P_d1 ps_P_d2"], ["proof (prove)\ngoal (5 subgoals):\n 1. proj_psi_l l \\<in> carrier_mat N N\n 2. proj_k l \\<in> carrier_mat K K\n 3. positive (proj_psi_l l)\n 4. positive (proj_k l)\n 5. True", "using proj_psi_l_dim proj_k_dim positive_proj_psi_l positive_proj_k"], ["proof (prove)\nusing this:\n  proj_psi_l ?l \\<in> carrier_mat N N\n  proj_k ?k \\<in> carrier_mat K K\n  positive (proj_psi_l ?l)\n  positive (proj_k ?k)\n\ngoal (5 subgoals):\n 1. proj_psi_l l \\<in> carrier_mat N N\n 2. proj_k l \\<in> carrier_mat K K\n 3. positive (proj_psi_l l)\n 4. positive (proj_k l)\n 5. True", "by auto"], ["proof (state)\nthis:\n  positive (tensor_P (proj_psi_l ?l2) (proj_k ?l2))\n\ngoal (1 subgoal):\n 1. tensor_P proj_psi (proj_k 0) \\<le>\\<^sub>L\n    adjoint exM0 * P' * exM0 + adjoint exM1 * Q * exM1", "have ps: \"positive ?s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. positive\n     (matrix_sum d\n       (\\<lambda>l. tensor_P (proj_psi_l (l + 1)) (proj_k (l + 1))) R)", "apply (subst matrix_sum_positive)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>k.\n       k < R \\<Longrightarrow>\n       tensor_P (proj_psi_l (k + 1)) (proj_k (k + 1)) \\<in> carrier_mat d d\n 2. \\<And>k.\n       k < R \\<Longrightarrow>\n       positive (tensor_P (proj_psi_l (k + 1)) (proj_k (k + 1)))\n 3. True", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. k_ < R \\<Longrightarrow>\n    tensor_P (proj_psi_l (k_ + 1)) (proj_k (k_ + 1)) \\<in> carrier_mat d d", "using tensor_P_dim"], ["proof (prove)\nusing this:\n  tensor_P ?A ?B \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. k_ < R \\<Longrightarrow>\n    tensor_P (proj_psi_l (k_ + 1)) (proj_k (k_ + 1)) \\<in> carrier_mat d d", "by auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>k.\n       k < R \\<Longrightarrow>\n       positive (tensor_P (proj_psi_l (k + 1)) (proj_k (k + 1)))\n 2. True", "using pt"], ["proof (prove)\nusing this:\n  positive (tensor_P (proj_psi_l ?l2) (proj_k ?l2))\n\ngoal (2 subgoals):\n 1. \\<And>k.\n       k < R \\<Longrightarrow>\n       positive (tensor_P (proj_psi_l (k + 1)) (proj_k (k + 1)))\n 2. True", "by auto"], ["proof (state)\nthis:\n  positive\n   (matrix_sum d\n     (\\<lambda>l. tensor_P (proj_psi_l (l + 1)) (proj_k (l + 1))) R)\n\ngoal (1 subgoal):\n 1. tensor_P proj_psi (proj_k 0) \\<le>\\<^sub>L\n    adjoint exM0 * P' * exM0 + adjoint exM1 * Q * exM1", "have \"?l \\<le>\\<^sub>L ?r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tensor_P (proj_psi_l 0) (proj_k 0) \\<le>\\<^sub>L\n    matrix_sum d (\\<lambda>l. tensor_P (proj_psi_l l) (proj_k l)) (R + 1)", "unfolding eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. tensor_P (proj_psi_l 0) (proj_k 0) \\<le>\\<^sub>L\n    tensor_P (proj_psi_l 0) (proj_k 0) +\n    matrix_sum d\n     (\\<lambda>l. tensor_P (proj_psi_l (l + 1)) (proj_k (l + 1))) R", "apply (subst add_positive_le_reduce1[of ?l d ?s])"], ["proof (prove)\ngoal (6 subgoals):\n 1. tensor_P (proj_psi_l 0) (proj_k 0) \\<in> carrier_mat d d\n 2. matrix_sum d\n     (\\<lambda>l. tensor_P (proj_psi_l (l + 1)) (proj_k (l + 1))) R\n    \\<in> carrier_mat d d\n 3. tensor_P (proj_psi_l 0) (proj_k 0) +\n    matrix_sum d\n     (\\<lambda>l. tensor_P (proj_psi_l (l + 1)) (proj_k (l + 1))) R\n    \\<in> carrier_mat d d\n 4. positive\n     (matrix_sum d\n       (\\<lambda>l. tensor_P (proj_psi_l (l + 1)) (proj_k (l + 1))) R)\n 5. tensor_P (proj_psi_l 0) (proj_k 0) +\n    matrix_sum d\n     (\\<lambda>l. tensor_P (proj_psi_l (l + 1)) (proj_k (l + 1)))\n     R \\<le>\\<^sub>L\n    tensor_P (proj_psi_l 0) (proj_k 0) +\n    matrix_sum d\n     (\\<lambda>l. tensor_P (proj_psi_l (l + 1)) (proj_k (l + 1))) R\n 6. True", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. tensor_P (proj_psi_l 0) (proj_k 0) \\<in> carrier_mat d d", "using tensor_P_dim"], ["proof (prove)\nusing this:\n  tensor_P ?A ?B \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. tensor_P (proj_psi_l 0) (proj_k 0) \\<in> carrier_mat d d", "by auto"], ["proof (prove)\ngoal (5 subgoals):\n 1. matrix_sum d\n     (\\<lambda>l. tensor_P (proj_psi_l (l + 1)) (proj_k (l + 1))) R\n    \\<in> carrier_mat d d\n 2. tensor_P (proj_psi_l 0) (proj_k 0) +\n    matrix_sum d\n     (\\<lambda>l. tensor_P (proj_psi_l (l + 1)) (proj_k (l + 1))) R\n    \\<in> carrier_mat d d\n 3. positive\n     (matrix_sum d\n       (\\<lambda>l. tensor_P (proj_psi_l (l + 1)) (proj_k (l + 1))) R)\n 4. tensor_P (proj_psi_l 0) (proj_k 0) +\n    matrix_sum d\n     (\\<lambda>l. tensor_P (proj_psi_l (l + 1)) (proj_k (l + 1)))\n     R \\<le>\\<^sub>L\n    tensor_P (proj_psi_l 0) (proj_k 0) +\n    matrix_sum d\n     (\\<lambda>l. tensor_P (proj_psi_l (l + 1)) (proj_k (l + 1))) R\n 5. True", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_sum d\n     (\\<lambda>l. tensor_P (proj_psi_l (l + 1)) (proj_k (l + 1))) R\n    \\<in> carrier_mat d d", "using d"], ["proof (prove)\nusing this:\n  matrix_sum d (\\<lambda>l. tensor_P (proj_psi_l (l + 1)) (proj_k (l + 1)))\n   R\n  \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. matrix_sum d\n     (\\<lambda>l. tensor_P (proj_psi_l (l + 1)) (proj_k (l + 1))) R\n    \\<in> carrier_mat d d", "by auto"], ["proof (prove)\ngoal (4 subgoals):\n 1. tensor_P (proj_psi_l 0) (proj_k 0) +\n    matrix_sum d\n     (\\<lambda>l. tensor_P (proj_psi_l (l + 1)) (proj_k (l + 1))) R\n    \\<in> carrier_mat d d\n 2. positive\n     (matrix_sum d\n       (\\<lambda>l. tensor_P (proj_psi_l (l + 1)) (proj_k (l + 1))) R)\n 3. tensor_P (proj_psi_l 0) (proj_k 0) +\n    matrix_sum d\n     (\\<lambda>l. tensor_P (proj_psi_l (l + 1)) (proj_k (l + 1)))\n     R \\<le>\\<^sub>L\n    tensor_P (proj_psi_l 0) (proj_k 0) +\n    matrix_sum d\n     (\\<lambda>l. tensor_P (proj_psi_l (l + 1)) (proj_k (l + 1))) R\n 4. True", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. tensor_P (proj_psi_l 0) (proj_k 0) +\n    matrix_sum d\n     (\\<lambda>l. tensor_P (proj_psi_l (l + 1)) (proj_k (l + 1))) R\n    \\<in> carrier_mat d d", "using tensor_P_dim d"], ["proof (prove)\nusing this:\n  tensor_P ?A ?B \\<in> carrier_mat d d\n  matrix_sum d (\\<lambda>l. tensor_P (proj_psi_l (l + 1)) (proj_k (l + 1)))\n   R\n  \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. tensor_P (proj_psi_l 0) (proj_k 0) +\n    matrix_sum d\n     (\\<lambda>l. tensor_P (proj_psi_l (l + 1)) (proj_k (l + 1))) R\n    \\<in> carrier_mat d d", "by auto"], ["proof (prove)\ngoal (3 subgoals):\n 1. positive\n     (matrix_sum d\n       (\\<lambda>l. tensor_P (proj_psi_l (l + 1)) (proj_k (l + 1))) R)\n 2. tensor_P (proj_psi_l 0) (proj_k 0) +\n    matrix_sum d\n     (\\<lambda>l. tensor_P (proj_psi_l (l + 1)) (proj_k (l + 1)))\n     R \\<le>\\<^sub>L\n    tensor_P (proj_psi_l 0) (proj_k 0) +\n    matrix_sum d\n     (\\<lambda>l. tensor_P (proj_psi_l (l + 1)) (proj_k (l + 1))) R\n 3. True", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. positive\n     (matrix_sum d\n       (\\<lambda>l. tensor_P (proj_psi_l (l + 1)) (proj_k (l + 1))) R)", "using ps"], ["proof (prove)\nusing this:\n  positive\n   (matrix_sum d\n     (\\<lambda>l. tensor_P (proj_psi_l (l + 1)) (proj_k (l + 1))) R)\n\ngoal (1 subgoal):\n 1. positive\n     (matrix_sum d\n       (\\<lambda>l. tensor_P (proj_psi_l (l + 1)) (proj_k (l + 1))) R)", "by auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. tensor_P (proj_psi_l 0) (proj_k 0) +\n    matrix_sum d\n     (\\<lambda>l. tensor_P (proj_psi_l (l + 1)) (proj_k (l + 1)))\n     R \\<le>\\<^sub>L\n    tensor_P (proj_psi_l 0) (proj_k 0) +\n    matrix_sum d\n     (\\<lambda>l. tensor_P (proj_psi_l (l + 1)) (proj_k (l + 1))) R\n 2. True", "apply (subst lowner_le_refl[of _ d])"], ["proof (prove)\ngoal (3 subgoals):\n 1. tensor_P (proj_psi_l 0) (proj_k 0) +\n    matrix_sum d\n     (\\<lambda>l. tensor_P (proj_psi_l (l + 1)) (proj_k (l + 1))) R\n    \\<in> carrier_mat d d\n 2. True\n 3. True", "using tensor_P_dim d"], ["proof (prove)\nusing this:\n  tensor_P ?A ?B \\<in> carrier_mat d d\n  matrix_sum d (\\<lambda>l. tensor_P (proj_psi_l (l + 1)) (proj_k (l + 1)))\n   R\n  \\<in> carrier_mat d d\n\ngoal (3 subgoals):\n 1. tensor_P (proj_psi_l 0) (proj_k 0) +\n    matrix_sum d\n     (\\<lambda>l. tensor_P (proj_psi_l (l + 1)) (proj_k (l + 1))) R\n    \\<in> carrier_mat d d\n 2. True\n 3. True", "by auto"], ["proof (state)\nthis:\n  tensor_P (proj_psi_l 0) (proj_k 0) \\<le>\\<^sub>L\n  matrix_sum d (\\<lambda>l. tensor_P (proj_psi_l l) (proj_k l)) (R + 1)\n\ngoal (1 subgoal):\n 1. tensor_P proj_psi (proj_k 0) \\<le>\\<^sub>L\n    adjoint exM0 * P' * exM0 + adjoint exM1 * Q * exM1", "then"], ["proof (chain)\npicking this:\n  tensor_P (proj_psi_l 0) (proj_k 0) \\<le>\\<^sub>L\n  matrix_sum d (\\<lambda>l. tensor_P (proj_psi_l l) (proj_k l)) (R + 1)", "show ?thesis"], ["proof (prove)\nusing this:\n  tensor_P (proj_psi_l 0) (proj_k 0) \\<le>\\<^sub>L\n  matrix_sum d (\\<lambda>l. tensor_P (proj_psi_l l) (proj_k l)) (R + 1)\n\ngoal (1 subgoal):\n 1. tensor_P proj_psi (proj_k 0) \\<le>\\<^sub>L\n    adjoint exM0 * P' * exM0 + adjoint exM1 * Q * exM1", "unfolding exP0_P' exP1_Q P'_add_Q proj_psi_is_proj_psi_l0"], ["proof (prove)\nusing this:\n  tensor_P (proj_psi_l 0) (proj_k 0) \\<le>\\<^sub>L\n  matrix_sum d (\\<lambda>l. tensor_P (proj_psi_l l) (proj_k l)) (R + 1)\n\ngoal (1 subgoal):\n 1. tensor_P (proj_psi_l 0) (proj_k 0) \\<le>\\<^sub>L\n    matrix_sum d (\\<lambda>l. tensor_P (proj_psi_l l) (proj_k l)) (R + 1)", "by auto"], ["proof (state)\nthis:\n  tensor_P proj_psi (proj_k 0) \\<le>\\<^sub>L\n  adjoint exM0 * P' * exM0 + adjoint exM1 * Q * exM1\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma hoare_triple_while:\n  \"\\<turnstile>\\<^sub>p \n   {adjoint exM0 * P' * exM0 + adjoint exM1 * Q * exM1} \n   While_P vars2 M0 M1 D\n   {P'}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>p {adjoint exM0 * P' * exM0 +\n                          adjoint exM1 * Q * exM1}\n                         While_P vars2 M0 M1 D {P'}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>p {adjoint exM0 * P' * exM0 +\n                          adjoint exM1 * Q * exM1}\n                         While_P vars2 M0 M1 D {P'}", "let ?m = \"\\<lambda>(n::nat). if n = 0 then mat_extension dims vars2 M0 else\n                       if n = 1 then mat_extension dims vars2 M1 else undefined\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>p {adjoint exM0 * P' * exM0 +\n                          adjoint exM1 * Q * exM1}\n                         While_P vars2 M0 M1 D {P'}", "have dM0: \"M0 \\<in> carrier_mat K K\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M0 \\<in> carrier_mat K K", "unfolding M0_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat K K (\\<lambda>(i, j). if i = j \\<and> R \\<le> i then 1 else 0)\n    \\<in> carrier_mat K K", "by auto"], ["proof (state)\nthis:\n  M0 \\<in> carrier_mat K K\n\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>p {adjoint exM0 * P' * exM0 +\n                          adjoint exM1 * Q * exM1}\n                         While_P vars2 M0 M1 D {P'}", "have dM1: \"M1 \\<in> carrier_mat K K\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M1 \\<in> carrier_mat K K", "unfolding M1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat K K (\\<lambda>(i, j). if i = j \\<and> i < R then 1 else 0)\n    \\<in> carrier_mat K K", "by auto"], ["proof (state)\nthis:\n  M1 \\<in> carrier_mat K K\n\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>p {adjoint exM0 * P' * exM0 +\n                          adjoint exM1 * Q * exM1}\n                         While_P vars2 M0 M1 D {P'}", "have m0: \"?m 0 = exM0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if 0 = 0 then mat_extension dims vars2 M0\n     else if 0 = 1 then mat_extension dims vars2 M1 else undefined) =\n    exM0", "apply (simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_extension dims vars2 M0 = exM0", "unfolding exM0_def ps2_P.ptensor_mat_def mat_ext_vars2[OF dM0]"], ["proof (prove)\ngoal (1 subgoal):\n 1. ps_P.tensor_mat (1\\<^sub>m N) M0 = ps_P.tensor_mat (1\\<^sub>m N) M0", "by auto"], ["proof (state)\nthis:\n  (if 0 = 0 then mat_extension dims vars2 M0\n   else if 0 = 1 then mat_extension dims vars2 M1 else undefined) =\n  exM0\n\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>p {adjoint exM0 * P' * exM0 +\n                          adjoint exM1 * Q * exM1}\n                         While_P vars2 M0 M1 D {P'}", "have m1: \"?m 1 = exM1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if 1 = 0 then mat_extension dims vars2 M0\n     else if 1 = 1 then mat_extension dims vars2 M1 else undefined) =\n    exM1", "unfolding exM1_def ps2_P.ptensor_mat_def mat_ext_vars2[OF dM1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if 1 = 0 then mat_extension dims vars2 M0\n     else if 1 = 1 then ps_P.tensor_mat (1\\<^sub>m N) M1 else undefined) =\n    ps_P.tensor_mat (1\\<^sub>m N) M1", "by auto"], ["proof (state)\nthis:\n  (if 1 = 0 then mat_extension dims vars2 M0\n   else if 1 = 1 then mat_extension dims vars2 M1 else undefined) =\n  exM1\n\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>p {adjoint exM0 * P' * exM0 +\n                          adjoint exM1 * Q * exM1}\n                         While_P vars2 M0 M1 D {P'}", "have \"\\<turnstile>\\<^sub>p {Q} D {adjoint (?m 0) * P' * (?m 0) + adjoint (?m 1) * Q * (?m 1)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>p {Q} D\n                         {adjoint\n                           (if 0 = 0 then mat_extension dims vars2 M0\n                            else if 0 = 1 then mat_extension dims vars2 M1\n                                 else undefined) *\n                          P' *\n                          (if 0 = 0 then mat_extension dims vars2 M0\n                           else if 0 = 1 then mat_extension dims vars2 M1\n                                else undefined) +\n                          adjoint\n                           (if 1 = 0 then mat_extension dims vars2 M0\n                            else if 1 = 1 then mat_extension dims vars2 M1\n                                 else undefined) *\n                          Q *\n                          (if 1 = 0 then mat_extension dims vars2 M0\n                           else if 1 = 1 then mat_extension dims vars2 M1\n                                else undefined)}", "using hoare_triple_D m0 m1"], ["proof (prove)\nusing this:\n  \\<turnstile>\\<^sub>p {Q} D\n                       {adjoint exM0 * P' * exM0 + adjoint exM1 * Q * exM1}\n  (if 0 = 0 then mat_extension dims vars2 M0\n   else if 0 = 1 then mat_extension dims vars2 M1 else undefined) =\n  exM0\n  (if 1 = 0 then mat_extension dims vars2 M0\n   else if 1 = 1 then mat_extension dims vars2 M1 else undefined) =\n  exM1\n\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>p {Q} D\n                         {adjoint\n                           (if 0 = 0 then mat_extension dims vars2 M0\n                            else if 0 = 1 then mat_extension dims vars2 M1\n                                 else undefined) *\n                          P' *\n                          (if 0 = 0 then mat_extension dims vars2 M0\n                           else if 0 = 1 then mat_extension dims vars2 M1\n                                else undefined) +\n                          adjoint\n                           (if 1 = 0 then mat_extension dims vars2 M0\n                            else if 1 = 1 then mat_extension dims vars2 M1\n                                 else undefined) *\n                          Q *\n                          (if 1 = 0 then mat_extension dims vars2 M0\n                           else if 1 = 1 then mat_extension dims vars2 M1\n                                else undefined)}", "by auto"], ["proof (state)\nthis:\n  \\<turnstile>\\<^sub>p {Q} D\n                       {adjoint\n                         (if 0 = 0 then mat_extension dims vars2 M0\n                          else if 0 = 1 then mat_extension dims vars2 M1\n                               else undefined) *\n                        P' *\n                        (if 0 = 0 then mat_extension dims vars2 M0\n                         else if 0 = 1 then mat_extension dims vars2 M1\n                              else undefined) +\n                        adjoint\n                         (if 1 = 0 then mat_extension dims vars2 M0\n                          else if 1 = 1 then mat_extension dims vars2 M1\n                               else undefined) *\n                        Q *\n                        (if 1 = 0 then mat_extension dims vars2 M0\n                         else if 1 = 1 then mat_extension dims vars2 M1\n                              else undefined)}\n\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>p {adjoint exM0 * P' * exM0 +\n                          adjoint exM1 * Q * exM1}\n                         While_P vars2 M0 M1 D {P'}", "then"], ["proof (chain)\npicking this:\n  \\<turnstile>\\<^sub>p {Q} D\n                       {adjoint\n                         (if 0 = 0 then mat_extension dims vars2 M0\n                          else if 0 = 1 then mat_extension dims vars2 M1\n                               else undefined) *\n                        P' *\n                        (if 0 = 0 then mat_extension dims vars2 M0\n                         else if 0 = 1 then mat_extension dims vars2 M1\n                              else undefined) +\n                        adjoint\n                         (if 1 = 0 then mat_extension dims vars2 M0\n                          else if 1 = 1 then mat_extension dims vars2 M1\n                               else undefined) *\n                        Q *\n                        (if 1 = 0 then mat_extension dims vars2 M0\n                         else if 1 = 1 then mat_extension dims vars2 M1\n                              else undefined)}", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<turnstile>\\<^sub>p {Q} D\n                       {adjoint\n                         (if 0 = 0 then mat_extension dims vars2 M0\n                          else if 0 = 1 then mat_extension dims vars2 M1\n                               else undefined) *\n                        P' *\n                        (if 0 = 0 then mat_extension dims vars2 M0\n                         else if 0 = 1 then mat_extension dims vars2 M1\n                              else undefined) +\n                        adjoint\n                         (if 1 = 0 then mat_extension dims vars2 M0\n                          else if 1 = 1 then mat_extension dims vars2 M1\n                               else undefined) *\n                        Q *\n                        (if 1 = 0 then mat_extension dims vars2 M0\n                         else if 1 = 1 then mat_extension dims vars2 M1\n                              else undefined)}\n\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>p {adjoint exM0 * P' * exM0 +\n                          adjoint exM1 * Q * exM1}\n                         While_P vars2 M0 M1 D {P'}", "unfolding While_P_def"], ["proof (prove)\nusing this:\n  \\<turnstile>\\<^sub>p {Q} D\n                       {adjoint\n                         (if 0 = 0 then mat_extension dims vars2 M0\n                          else if 0 = 1 then mat_extension dims vars2 M1\n                               else undefined) *\n                        P' *\n                        (if 0 = 0 then mat_extension dims vars2 M0\n                         else if 0 = 1 then mat_extension dims vars2 M1\n                              else undefined) +\n                        adjoint\n                         (if 1 = 0 then mat_extension dims vars2 M0\n                          else if 1 = 1 then mat_extension dims vars2 M1\n                               else undefined) *\n                        Q *\n                        (if 1 = 0 then mat_extension dims vars2 M0\n                         else if 1 = 1 then mat_extension dims vars2 M1\n                              else undefined)}\n\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>p {adjoint exM0 * P' * exM0 +\n                          adjoint exM1 * Q * exM1}\n                         While\n                          (\\<lambda>n.\n                              if n = 0 then mat_extension dims vars2 M0\n                              else if n = 1 then mat_extension dims vars2 M1\n                                   else undefined)\n                          D\n                         {P'}", "using qp_D3_post qp_P' hoare_partial.intros(5)[OF qp_P' qp_Q, of D ?m] m0 m1"], ["proof (prove)\nusing this:\n  \\<turnstile>\\<^sub>p {Q} D\n                       {adjoint\n                         (if 0 = 0 then mat_extension dims vars2 M0\n                          else if 0 = 1 then mat_extension dims vars2 M1\n                               else undefined) *\n                        P' *\n                        (if 0 = 0 then mat_extension dims vars2 M0\n                         else if 0 = 1 then mat_extension dims vars2 M1\n                              else undefined) +\n                        adjoint\n                         (if 1 = 0 then mat_extension dims vars2 M0\n                          else if 1 = 1 then mat_extension dims vars2 M1\n                               else undefined) *\n                        Q *\n                        (if 1 = 0 then mat_extension dims vars2 M0\n                         else if 1 = 1 then mat_extension dims vars2 M1\n                              else undefined)}\n  is_quantum_predicate (adjoint exM0 * P' * exM0 + adjoint exM1 * Q * exM1)\n  is_quantum_predicate P'\n  \\<turnstile>\\<^sub>p {Q} D\n                       {adjoint\n                         (if 0 = 0 then mat_extension dims vars2 M0\n                          else if 0 = 1 then mat_extension dims vars2 M1\n                               else undefined) *\n                        P' *\n                        (if 0 = 0 then mat_extension dims vars2 M0\n                         else if 0 = 1 then mat_extension dims vars2 M1\n                              else undefined) +\n                        adjoint\n                         (if 1 = 0 then mat_extension dims vars2 M0\n                          else if 1 = 1 then mat_extension dims vars2 M1\n                               else undefined) *\n                        Q *\n                        (if 1 = 0 then mat_extension dims vars2 M0\n                         else if 1 = 1 then mat_extension dims vars2 M1\n                              else undefined)} \\<Longrightarrow>\n  \\<turnstile>\\<^sub>p {adjoint\n                         (if 0 = 0 then mat_extension dims vars2 M0\n                          else if 0 = 1 then mat_extension dims vars2 M1\n                               else undefined) *\n                        P' *\n                        (if 0 = 0 then mat_extension dims vars2 M0\n                         else if 0 = 1 then mat_extension dims vars2 M1\n                              else undefined) +\n                        adjoint\n                         (if 1 = 0 then mat_extension dims vars2 M0\n                          else if 1 = 1 then mat_extension dims vars2 M1\n                               else undefined) *\n                        Q *\n                        (if 1 = 0 then mat_extension dims vars2 M0\n                         else if 1 = 1 then mat_extension dims vars2 M1\n                              else undefined)}\n                       While\n                        (\\<lambda>n.\n                            if n = 0 then mat_extension dims vars2 M0\n                            else if n = 1 then mat_extension dims vars2 M1\n                                 else undefined)\n                        D\n                       {P'}\n  (if 0 = 0 then mat_extension dims vars2 M0\n   else if 0 = 1 then mat_extension dims vars2 M1 else undefined) =\n  exM0\n  (if 1 = 0 then mat_extension dims vars2 M0\n   else if 1 = 1 then mat_extension dims vars2 M1 else undefined) =\n  exM1\n\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>p {adjoint exM0 * P' * exM0 +\n                          adjoint exM1 * Q * exM1}\n                         While\n                          (\\<lambda>n.\n                              if n = 0 then mat_extension dims vars2 M0\n                              else if n = 1 then mat_extension dims vars2 M1\n                                   else undefined)\n                          D\n                         {P'}", "by auto"], ["proof (state)\nthis:\n  \\<turnstile>\\<^sub>p {adjoint exM0 * P' * exM0 + adjoint exM1 * Q * exM1}\n                       While_P vars2 M0 M1 D {P'}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma R_and_a_half_\\<theta>:\n  \"(R + 1/2) * \\<theta> = pi / 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (real R + 1 / 2) * \\<theta> = pi / 2", "using R \\<theta>_neq_0"], ["proof (prove)\nusing this:\n  real R = pi / (2 * \\<theta>) - 1 / 2\n  \\<theta> \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (real R + 1 / 2) * \\<theta> = pi / 2", "by auto"], ["", "lemma psi_lR_is_beta:\n  \"psi_l R = \\<beta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. psi_l R = \\<beta>", "unfolding psi_l_def alpha_l_def beta_l_def R_and_a_half_\\<theta>"], ["proof (prove)\ngoal (1 subgoal):\n 1. complex_of_real (cos (pi / 2)) \\<cdot>\\<^sub>v \\<alpha> +\n    complex_of_real (sin (pi / 2)) \\<cdot>\\<^sub>v \\<beta> =\n    \\<beta>", "by auto"], ["", "lemma post_mult_beta:\n  \"post *\\<^sub>v \\<beta> = \\<beta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. post *\\<^sub>v \\<beta> = \\<beta>", "by (auto simp add: post_def \\<beta>_def scalar_prod_def sum_only_one_neq_0)"], ["", "lemma post_mult_post:\n  \"post * post = post\""], ["proof (prove)\ngoal (1 subgoal):\n 1. post * post = post", "by (auto simp add: post_def scalar_prod_def sum_only_one_neq_0)"], ["", "lemma post_mult_proj_psi_lR:\n  \"post * proj_psi_l R = proj_psi_l R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. post * proj_psi_l R = proj_psi_l R", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. post * proj_psi_l R = proj_psi_l R", "let ?R = \"proj_psi_l R\""], ["proof (state)\ngoal (1 subgoal):\n 1. post * proj_psi_l R = proj_psi_l R", "have \"post * ?R = post * ?R * 1\\<^sub>m N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. post * proj_psi_l R = post * proj_psi_l R * 1\\<^sub>m N", "using post_dim proj_psi_l_dim[of R]"], ["proof (prove)\nusing this:\n  post \\<in> carrier_mat N N\n  proj_psi_l R \\<in> carrier_mat N N\n\ngoal (1 subgoal):\n 1. post * proj_psi_l R = post * proj_psi_l R * 1\\<^sub>m N", "by auto"], ["proof (state)\nthis:\n  post * proj_psi_l R = post * proj_psi_l R * 1\\<^sub>m N\n\ngoal (1 subgoal):\n 1. post * proj_psi_l R = proj_psi_l R", "also"], ["proof (state)\nthis:\n  post * proj_psi_l R = post * proj_psi_l R * 1\\<^sub>m N\n\ngoal (1 subgoal):\n 1. post * proj_psi_l R = proj_psi_l R", "have \"\\<dots> = outer_prod (post *\\<^sub>v psi_l R) ((1\\<^sub>m N) *\\<^sub>v psi_l R)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. post * proj_psi_l R * 1\\<^sub>m N =\n    outer_prod (post *\\<^sub>v psi_l R) (1\\<^sub>m N *\\<^sub>v psi_l R)", "unfolding proj_psi_l_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. post * outer_prod (psi_l R) (psi_l R) * 1\\<^sub>m N =\n    outer_prod (post *\\<^sub>v psi_l R) (1\\<^sub>m N *\\<^sub>v psi_l R)", "apply (subst outer_prod_left_right_mat[of _ N _ N _ N _ N])"], ["proof (prove)\ngoal (4 subgoals):\n 1. psi_l R \\<in> carrier_vec N\n 2. post \\<in> carrier_mat N N\n 3. 1\\<^sub>m N \\<in> carrier_mat N N\n 4. outer_prod (post *\\<^sub>v psi_l R)\n     (adjoint (1\\<^sub>m N) *\\<^sub>v psi_l R) =\n    outer_prod (post *\\<^sub>v psi_l R) (1\\<^sub>m N *\\<^sub>v psi_l R)", "by (auto simp add: psi_l_dim post_dim adjoint_one)"], ["proof (state)\nthis:\n  post * proj_psi_l R * 1\\<^sub>m N =\n  outer_prod (post *\\<^sub>v psi_l R) (1\\<^sub>m N *\\<^sub>v psi_l R)\n\ngoal (1 subgoal):\n 1. post * proj_psi_l R = proj_psi_l R", "also"], ["proof (state)\nthis:\n  post * proj_psi_l R * 1\\<^sub>m N =\n  outer_prod (post *\\<^sub>v psi_l R) (1\\<^sub>m N *\\<^sub>v psi_l R)\n\ngoal (1 subgoal):\n 1. post * proj_psi_l R = proj_psi_l R", "have \"\\<dots> = ?R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. outer_prod (post *\\<^sub>v psi_l R) (1\\<^sub>m N *\\<^sub>v psi_l R) =\n    proj_psi_l R", "unfolding proj_psi_l_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. outer_prod (post *\\<^sub>v psi_l R) (1\\<^sub>m N *\\<^sub>v psi_l R) =\n    outer_prod (psi_l R) (psi_l R)", "unfolding psi_lR_is_beta"], ["proof (prove)\ngoal (1 subgoal):\n 1. outer_prod (post *\\<^sub>v \\<beta>) (1\\<^sub>m N *\\<^sub>v \\<beta>) =\n    outer_prod \\<beta> \\<beta>", "unfolding post_mult_beta"], ["proof (prove)\ngoal (1 subgoal):\n 1. outer_prod \\<beta> (1\\<^sub>m N *\\<^sub>v \\<beta>) =\n    outer_prod \\<beta> \\<beta>", "using \\<beta>_dim"], ["proof (prove)\nusing this:\n  \\<beta> \\<in> carrier_vec N\n  dim_vec \\<beta> = N\n\ngoal (1 subgoal):\n 1. outer_prod \\<beta> (1\\<^sub>m N *\\<^sub>v \\<beta>) =\n    outer_prod \\<beta> \\<beta>", "by auto"], ["proof (state)\nthis:\n  outer_prod (post *\\<^sub>v psi_l R) (1\\<^sub>m N *\\<^sub>v psi_l R) =\n  proj_psi_l R\n\ngoal (1 subgoal):\n 1. post * proj_psi_l R = proj_psi_l R", "finally"], ["proof (chain)\npicking this:\n  post * proj_psi_l R = proj_psi_l R", "show \"post * ?R = ?R\""], ["proof (prove)\nusing this:\n  post * proj_psi_l R = proj_psi_l R\n\ngoal (1 subgoal):\n 1. post * proj_psi_l R = proj_psi_l R", "."], ["proof (state)\nthis:\n  post * proj_psi_l R = proj_psi_l R\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma proj_psi_lR_mult_post:\n  \"proj_psi_l R * post = proj_psi_l R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proj_psi_l R * post = proj_psi_l R", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. proj_psi_l R * post = proj_psi_l R", "let ?R = \"proj_psi_l R\""], ["proof (state)\ngoal (1 subgoal):\n 1. proj_psi_l R * post = proj_psi_l R", "have \"?R * post = 1\\<^sub>m N * ?R * post\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proj_psi_l R * post = 1\\<^sub>m N * proj_psi_l R * post", "using post_dim proj_psi_l_dim[of R]"], ["proof (prove)\nusing this:\n  post \\<in> carrier_mat N N\n  proj_psi_l R \\<in> carrier_mat N N\n\ngoal (1 subgoal):\n 1. proj_psi_l R * post = 1\\<^sub>m N * proj_psi_l R * post", "by auto"], ["proof (state)\nthis:\n  proj_psi_l R * post = 1\\<^sub>m N * proj_psi_l R * post\n\ngoal (1 subgoal):\n 1. proj_psi_l R * post = proj_psi_l R", "also"], ["proof (state)\nthis:\n  proj_psi_l R * post = 1\\<^sub>m N * proj_psi_l R * post\n\ngoal (1 subgoal):\n 1. proj_psi_l R * post = proj_psi_l R", "have \"\\<dots> = outer_prod ((1\\<^sub>m N) *\\<^sub>v psi_l R) (post *\\<^sub>v psi_l R)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1\\<^sub>m N * proj_psi_l R * post =\n    outer_prod (1\\<^sub>m N *\\<^sub>v psi_l R) (post *\\<^sub>v psi_l R)", "unfolding proj_psi_l_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1\\<^sub>m N * outer_prod (psi_l R) (psi_l R) * post =\n    outer_prod (1\\<^sub>m N *\\<^sub>v psi_l R) (post *\\<^sub>v psi_l R)", "apply (subst outer_prod_left_right_mat[of _ N _ N _ N _ N])"], ["proof (prove)\ngoal (4 subgoals):\n 1. psi_l R \\<in> carrier_vec N\n 2. 1\\<^sub>m N \\<in> carrier_mat N N\n 3. post \\<in> carrier_mat N N\n 4. outer_prod (1\\<^sub>m N *\\<^sub>v psi_l R)\n     (adjoint post *\\<^sub>v psi_l R) =\n    outer_prod (1\\<^sub>m N *\\<^sub>v psi_l R) (post *\\<^sub>v psi_l R)", "by (auto simp add: psi_l_dim post_dim hermitian_post[unfolded hermitian_def])"], ["proof (state)\nthis:\n  1\\<^sub>m N * proj_psi_l R * post =\n  outer_prod (1\\<^sub>m N *\\<^sub>v psi_l R) (post *\\<^sub>v psi_l R)\n\ngoal (1 subgoal):\n 1. proj_psi_l R * post = proj_psi_l R", "also"], ["proof (state)\nthis:\n  1\\<^sub>m N * proj_psi_l R * post =\n  outer_prod (1\\<^sub>m N *\\<^sub>v psi_l R) (post *\\<^sub>v psi_l R)\n\ngoal (1 subgoal):\n 1. proj_psi_l R * post = proj_psi_l R", "have \"\\<dots> = ?R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. outer_prod (1\\<^sub>m N *\\<^sub>v psi_l R) (post *\\<^sub>v psi_l R) =\n    proj_psi_l R", "unfolding proj_psi_l_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. outer_prod (1\\<^sub>m N *\\<^sub>v psi_l R) (post *\\<^sub>v psi_l R) =\n    outer_prod (psi_l R) (psi_l R)", "unfolding psi_lR_is_beta"], ["proof (prove)\ngoal (1 subgoal):\n 1. outer_prod (1\\<^sub>m N *\\<^sub>v \\<beta>) (post *\\<^sub>v \\<beta>) =\n    outer_prod \\<beta> \\<beta>", "unfolding post_mult_beta"], ["proof (prove)\ngoal (1 subgoal):\n 1. outer_prod (1\\<^sub>m N *\\<^sub>v \\<beta>) \\<beta> =\n    outer_prod \\<beta> \\<beta>", "using \\<beta>_dim"], ["proof (prove)\nusing this:\n  \\<beta> \\<in> carrier_vec N\n  dim_vec \\<beta> = N\n\ngoal (1 subgoal):\n 1. outer_prod (1\\<^sub>m N *\\<^sub>v \\<beta>) \\<beta> =\n    outer_prod \\<beta> \\<beta>", "by auto"], ["proof (state)\nthis:\n  outer_prod (1\\<^sub>m N *\\<^sub>v psi_l R) (post *\\<^sub>v psi_l R) =\n  proj_psi_l R\n\ngoal (1 subgoal):\n 1. proj_psi_l R * post = proj_psi_l R", "finally"], ["proof (chain)\npicking this:\n  proj_psi_l R * post = proj_psi_l R", "show \"?R * post = ?R\""], ["proof (prove)\nusing this:\n  proj_psi_l R * post = proj_psi_l R\n\ngoal (1 subgoal):\n 1. proj_psi_l R * post = proj_psi_l R", "."], ["proof (state)\nthis:\n  proj_psi_l R * post = proj_psi_l R\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma proj_psi_lR_mult_proj_psi_lR:\n  \"proj_psi_l R * proj_psi_l R = proj_psi_l R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proj_psi_l R * proj_psi_l R = proj_psi_l R", "unfolding proj_psi_l_def psi_lR_is_beta"], ["proof (prove)\ngoal (1 subgoal):\n 1. outer_prod \\<beta> \\<beta> * outer_prod \\<beta> \\<beta> =\n    outer_prod \\<beta> \\<beta>", "apply (subst outer_prod_mult_outer_prod[of _ N _ N _ _ N])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<beta> \\<in> carrier_vec N\n 2. inner_prod \\<beta> \\<beta> \\<cdot>\\<^sub>m outer_prod \\<beta> \\<beta> =\n    outer_prod \\<beta> \\<beta>", "by (auto simp add: \\<beta>_inner)"], ["", "lemma proj_psi_lR_le_post:\n  \"proj_psi_l R \\<le>\\<^sub>L post\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proj_psi_l R \\<le>\\<^sub>L post", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. proj_psi_l R \\<le>\\<^sub>L post", "let ?R = \"proj_psi_l R\""], ["proof (state)\ngoal (1 subgoal):\n 1. proj_psi_l R \\<le>\\<^sub>L post", "let ?s = \"post - ?R\""], ["proof (state)\ngoal (1 subgoal):\n 1. proj_psi_l R \\<le>\\<^sub>L post", "have eq1: \"post * (post - ?R) = post - ?R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. post * (post - proj_psi_l R) = post - proj_psi_l R", "apply (subst mult_minus_distrib_mat[of _ N N _ N])"], ["proof (prove)\ngoal (3 subgoals):\n 1. post \\<in> carrier_mat N N\n 2. proj_psi_l R \\<in> carrier_mat N N\n 3. post * post - post * proj_psi_l R = post - proj_psi_l R", "apply (auto simp add: post_dim proj_psi_l_dim[of R])"], ["proof (prove)\ngoal (1 subgoal):\n 1. post * post - post * proj_psi_l R = post - proj_psi_l R", "using post_mult_post post_mult_proj_psi_lR"], ["proof (prove)\nusing this:\n  post * post = post\n  post * proj_psi_l R = proj_psi_l R\n\ngoal (1 subgoal):\n 1. post * post - post * proj_psi_l R = post - proj_psi_l R", "by auto"], ["proof (state)\nthis:\n  post * (post - proj_psi_l R) = post - proj_psi_l R\n\ngoal (1 subgoal):\n 1. proj_psi_l R \\<le>\\<^sub>L post", "have eq2: \"?R * (post - ?R) = 0\\<^sub>m N N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proj_psi_l R * (post - proj_psi_l R) = 0\\<^sub>m N N", "apply (subst mult_minus_distrib_mat[of _ N N _ N])"], ["proof (prove)\ngoal (3 subgoals):\n 1. proj_psi_l R \\<in> carrier_mat N N\n 2. post \\<in> carrier_mat N N\n 3. proj_psi_l R * post - proj_psi_l R * proj_psi_l R = 0\\<^sub>m N N", "apply (auto simp add: post_dim proj_psi_l_dim[of R])"], ["proof (prove)\ngoal (1 subgoal):\n 1. proj_psi_l R * post - proj_psi_l R * proj_psi_l R = 0\\<^sub>m N N", "unfolding proj_psi_lR_mult_post proj_psi_lR_mult_proj_psi_lR"], ["proof (prove)\ngoal (1 subgoal):\n 1. proj_psi_l R - proj_psi_l R = 0\\<^sub>m N N", "using proj_psi_l_dim[of R]"], ["proof (prove)\nusing this:\n  proj_psi_l R \\<in> carrier_mat N N\n\ngoal (1 subgoal):\n 1. proj_psi_l R - proj_psi_l R = 0\\<^sub>m N N", "by auto"], ["proof (state)\nthis:\n  proj_psi_l R * (post - proj_psi_l R) = 0\\<^sub>m N N\n\ngoal (1 subgoal):\n 1. proj_psi_l R \\<le>\\<^sub>L post", "have \"adjoint ?s = ?s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adjoint (post - proj_psi_l R) = post - proj_psi_l R", "apply (subst adjoint_minus[of _ N N])"], ["proof (prove)\ngoal (3 subgoals):\n 1. post \\<in> carrier_mat N N\n 2. proj_psi_l R \\<in> carrier_mat N N\n 3. adjoint post - adjoint (proj_psi_l R) = post - proj_psi_l R", "using post_dim proj_psi_l_dim hermitian_post hermitian_proj_psi_l K"], ["proof (prove)\nusing this:\n  post \\<in> carrier_mat N N\n  proj_psi_l ?l \\<in> carrier_mat N N\n  hermitian post\n  ?k < K \\<Longrightarrow> hermitian (proj_psi_l ?k)\n  R < K\n\ngoal (3 subgoals):\n 1. post \\<in> carrier_mat N N\n 2. proj_psi_l R \\<in> carrier_mat N N\n 3. adjoint post - adjoint (proj_psi_l R) = post - proj_psi_l R", "by (auto simp add: hermitian_def)"], ["proof (state)\nthis:\n  adjoint (post - proj_psi_l R) = post - proj_psi_l R\n\ngoal (1 subgoal):\n 1. proj_psi_l R \\<le>\\<^sub>L post", "then"], ["proof (chain)\npicking this:\n  adjoint (post - proj_psi_l R) = post - proj_psi_l R", "have \"?s * adjoint ?s = ?s * ?s\""], ["proof (prove)\nusing this:\n  adjoint (post - proj_psi_l R) = post - proj_psi_l R\n\ngoal (1 subgoal):\n 1. (post - proj_psi_l R) * adjoint (post - proj_psi_l R) =\n    (post - proj_psi_l R) * (post - proj_psi_l R)", "by auto"], ["proof (state)\nthis:\n  (post - proj_psi_l R) * adjoint (post - proj_psi_l R) =\n  (post - proj_psi_l R) * (post - proj_psi_l R)\n\ngoal (1 subgoal):\n 1. proj_psi_l R \\<le>\\<^sub>L post", "also"], ["proof (state)\nthis:\n  (post - proj_psi_l R) * adjoint (post - proj_psi_l R) =\n  (post - proj_psi_l R) * (post - proj_psi_l R)\n\ngoal (1 subgoal):\n 1. proj_psi_l R \\<le>\\<^sub>L post", "have \"\\<dots> = post * (post - ?R) - ?R * (post - ?R)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (post - proj_psi_l R) * (post - proj_psi_l R) =\n    post * (post - proj_psi_l R) - proj_psi_l R * (post - proj_psi_l R)", "using post_dim proj_psi_l_dim[of R]"], ["proof (prove)\nusing this:\n  post \\<in> carrier_mat N N\n  proj_psi_l R \\<in> carrier_mat N N\n\ngoal (1 subgoal):\n 1. (post - proj_psi_l R) * (post - proj_psi_l R) =\n    post * (post - proj_psi_l R) - proj_psi_l R * (post - proj_psi_l R)", "by (mat_assoc N)"], ["proof (state)\nthis:\n  (post - proj_psi_l R) * (post - proj_psi_l R) =\n  post * (post - proj_psi_l R) - proj_psi_l R * (post - proj_psi_l R)\n\ngoal (1 subgoal):\n 1. proj_psi_l R \\<le>\\<^sub>L post", "also"], ["proof (state)\nthis:\n  (post - proj_psi_l R) * (post - proj_psi_l R) =\n  post * (post - proj_psi_l R) - proj_psi_l R * (post - proj_psi_l R)\n\ngoal (1 subgoal):\n 1. proj_psi_l R \\<le>\\<^sub>L post", "have \"\\<dots> = post - ?R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. post * (post - proj_psi_l R) - proj_psi_l R * (post - proj_psi_l R) =\n    post - proj_psi_l R", "unfolding eq1 eq2"], ["proof (prove)\ngoal (1 subgoal):\n 1. post - proj_psi_l R - 0\\<^sub>m N N = post - proj_psi_l R", "using post_dim proj_psi_l_dim[of R]"], ["proof (prove)\nusing this:\n  post \\<in> carrier_mat N N\n  proj_psi_l R \\<in> carrier_mat N N\n\ngoal (1 subgoal):\n 1. post - proj_psi_l R - 0\\<^sub>m N N = post - proj_psi_l R", "by auto"], ["proof (state)\nthis:\n  post * (post - proj_psi_l R) - proj_psi_l R * (post - proj_psi_l R) =\n  post - proj_psi_l R\n\ngoal (1 subgoal):\n 1. proj_psi_l R \\<le>\\<^sub>L post", "finally"], ["proof (chain)\npicking this:\n  (post - proj_psi_l R) * adjoint (post - proj_psi_l R) =\n  post - proj_psi_l R", "have \"?s * adjoint ?s = ?s\""], ["proof (prove)\nusing this:\n  (post - proj_psi_l R) * adjoint (post - proj_psi_l R) =\n  post - proj_psi_l R\n\ngoal (1 subgoal):\n 1. (post - proj_psi_l R) * adjoint (post - proj_psi_l R) =\n    post - proj_psi_l R", "."], ["proof (state)\nthis:\n  (post - proj_psi_l R) * adjoint (post - proj_psi_l R) =\n  post - proj_psi_l R\n\ngoal (1 subgoal):\n 1. proj_psi_l R \\<le>\\<^sub>L post", "then"], ["proof (chain)\npicking this:\n  (post - proj_psi_l R) * adjoint (post - proj_psi_l R) =\n  post - proj_psi_l R", "have \"\\<exists>M. M * adjoint M = ?s\""], ["proof (prove)\nusing this:\n  (post - proj_psi_l R) * adjoint (post - proj_psi_l R) =\n  post - proj_psi_l R\n\ngoal (1 subgoal):\n 1. \\<exists>M. M * adjoint M = post - proj_psi_l R", "by auto"], ["proof (state)\nthis:\n  \\<exists>M. M * adjoint M = post - proj_psi_l R\n\ngoal (1 subgoal):\n 1. proj_psi_l R \\<le>\\<^sub>L post", "then"], ["proof (chain)\npicking this:\n  \\<exists>M. M * adjoint M = post - proj_psi_l R", "have \"positive ?s\""], ["proof (prove)\nusing this:\n  \\<exists>M. M * adjoint M = post - proj_psi_l R\n\ngoal (1 subgoal):\n 1. positive (post - proj_psi_l R)", "apply (subst positive_if_decomp[of ?s N])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<exists>M. M * adjoint M = post - proj_psi_l R \\<Longrightarrow>\n    post - proj_psi_l R \\<in> carrier_mat N N\n 2. \\<exists>M. M * adjoint M = post - proj_psi_l R \\<Longrightarrow>\n    \\<exists>M. M * adjoint M = post - proj_psi_l R\n 3. \\<exists>M. M * adjoint M = post - proj_psi_l R \\<Longrightarrow> True", "using post_dim proj_psi_l_dim[of R]"], ["proof (prove)\nusing this:\n  post \\<in> carrier_mat N N\n  proj_psi_l R \\<in> carrier_mat N N\n\ngoal (3 subgoals):\n 1. \\<exists>M. M * adjoint M = post - proj_psi_l R \\<Longrightarrow>\n    post - proj_psi_l R \\<in> carrier_mat N N\n 2. \\<exists>M. M * adjoint M = post - proj_psi_l R \\<Longrightarrow>\n    \\<exists>M. M * adjoint M = post - proj_psi_l R\n 3. \\<exists>M. M * adjoint M = post - proj_psi_l R \\<Longrightarrow> True", "by auto"], ["proof (state)\nthis:\n  positive (post - proj_psi_l R)\n\ngoal (1 subgoal):\n 1. proj_psi_l R \\<le>\\<^sub>L post", "then"], ["proof (chain)\npicking this:\n  positive (post - proj_psi_l R)", "show ?thesis"], ["proof (prove)\nusing this:\n  positive (post - proj_psi_l R)\n\ngoal (1 subgoal):\n 1. proj_psi_l R \\<le>\\<^sub>L post", "unfolding lowner_le_def"], ["proof (prove)\nusing this:\n  positive (post - proj_psi_l R)\n\ngoal (1 subgoal):\n 1. dim_row (proj_psi_l R) = dim_row post \\<and>\n    dim_col (proj_psi_l R) = dim_col post \\<and>\n    positive (post - proj_psi_l R)", "using post_dim proj_psi_l_dim[of R]"], ["proof (prove)\nusing this:\n  positive (post - proj_psi_l R)\n  post \\<in> carrier_mat N N\n  proj_psi_l R \\<in> carrier_mat N N\n\ngoal (1 subgoal):\n 1. dim_row (proj_psi_l R) = dim_row post \\<and>\n    dim_col (proj_psi_l R) = dim_col post \\<and>\n    positive (post - proj_psi_l R)", "by auto"], ["proof (state)\nthis:\n  proj_psi_l R \\<le>\\<^sub>L post\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma P'_le_post_R:\n  \"P' \\<le>\\<^sub>L (tensor_P post (proj_k R))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P' \\<le>\\<^sub>L tensor_P post (proj_k R)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. P' \\<le>\\<^sub>L tensor_P post (proj_k R)", "let ?r = \"tensor_P post (proj_k R)\""], ["proof (state)\ngoal (1 subgoal):\n 1. P' \\<le>\\<^sub>L tensor_P post (proj_k R)", "have \"?r - P' = tensor_P (post - proj_psi_l R) (proj_k R)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tensor_P post (proj_k R) - P' =\n    tensor_P (post - proj_psi_l R) (proj_k R)", "unfolding P'_def ps2_P.ptensor_mat_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ps_P.tensor_mat post (proj_k R) -\n    ps_P.tensor_mat (proj_psi_l R) (proj_k R) =\n    ps_P.tensor_mat (post - proj_psi_l R) (proj_k R)", "apply (subst ps_P.tensor_mat_minus1)"], ["proof (prove)\ngoal (4 subgoals):\n 1. post \\<in> carrier_mat ps_P.d1 ps_P.d1\n 2. proj_psi_l R \\<in> carrier_mat ps_P.d1 ps_P.d1\n 3. proj_k R \\<in> carrier_mat ps_P.d2 ps_P.d2\n 4. ps_P.tensor_mat post (proj_k R) -\n    ps_P.tensor_mat (proj_psi_l R) (proj_k R) =\n    ps_P.tensor_mat post (proj_k R) -\n    ps_P.tensor_mat (proj_psi_l R) (proj_k R)", "unfolding ps_P_d1 ps_P_d2"], ["proof (prove)\ngoal (4 subgoals):\n 1. post \\<in> carrier_mat N N\n 2. proj_psi_l R \\<in> carrier_mat N N\n 3. proj_k R \\<in> carrier_mat K K\n 4. ps_P.tensor_mat post (proj_k R) -\n    ps_P.tensor_mat (proj_psi_l R) (proj_k R) =\n    ps_P.tensor_mat post (proj_k R) -\n    ps_P.tensor_mat (proj_psi_l R) (proj_k R)", "using post_dim proj_psi_l_dim proj_k_dim"], ["proof (prove)\nusing this:\n  post \\<in> carrier_mat N N\n  proj_psi_l ?l \\<in> carrier_mat N N\n  proj_k ?k \\<in> carrier_mat K K\n\ngoal (4 subgoals):\n 1. post \\<in> carrier_mat N N\n 2. proj_psi_l R \\<in> carrier_mat N N\n 3. proj_k R \\<in> carrier_mat K K\n 4. ps_P.tensor_mat post (proj_k R) -\n    ps_P.tensor_mat (proj_psi_l R) (proj_k R) =\n    ps_P.tensor_mat post (proj_k R) -\n    ps_P.tensor_mat (proj_psi_l R) (proj_k R)", "by auto"], ["proof (state)\nthis:\n  tensor_P post (proj_k R) - P' = tensor_P (post - proj_psi_l R) (proj_k R)\n\ngoal (1 subgoal):\n 1. P' \\<le>\\<^sub>L tensor_P post (proj_k R)", "moreover"], ["proof (state)\nthis:\n  tensor_P post (proj_k R) - P' = tensor_P (post - proj_psi_l R) (proj_k R)\n\ngoal (1 subgoal):\n 1. P' \\<le>\\<^sub>L tensor_P post (proj_k R)", "have \"positive (tensor_P (post - proj_psi_l R) (proj_k R))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. positive (tensor_P (post - proj_psi_l R) (proj_k R))", "unfolding ps2_P.ptensor_mat_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. positive (ps_P.tensor_mat (post - proj_psi_l R) (proj_k R))", "apply (subst ps_P.tensor_mat_positive)"], ["proof (prove)\ngoal (5 subgoals):\n 1. post - proj_psi_l R \\<in> carrier_mat ps_P.d1 ps_P.d1\n 2. proj_k R \\<in> carrier_mat ps_P.d2 ps_P.d2\n 3. positive (post - proj_psi_l R)\n 4. positive (proj_k R)\n 5. True", "unfolding ps_P_d1 ps_P_d2"], ["proof (prove)\ngoal (5 subgoals):\n 1. post - proj_psi_l R \\<in> carrier_mat N N\n 2. proj_k R \\<in> carrier_mat K K\n 3. positive (post - proj_psi_l R)\n 4. positive (proj_k R)\n 5. True", "using proj_psi_lR_le_post[unfolded lowner_le_def]\n      post_dim proj_psi_l_dim[of R] proj_k_dim positive_proj_k"], ["proof (prove)\nusing this:\n  dim_row (proj_psi_l R) = dim_row post \\<and>\n  dim_col (proj_psi_l R) = dim_col post \\<and>\n  positive (post - proj_psi_l R)\n  post \\<in> carrier_mat N N\n  proj_psi_l R \\<in> carrier_mat N N\n  proj_k ?k \\<in> carrier_mat K K\n  positive (proj_k ?k)\n\ngoal (5 subgoals):\n 1. post - proj_psi_l R \\<in> carrier_mat N N\n 2. proj_k R \\<in> carrier_mat K K\n 3. positive (post - proj_psi_l R)\n 4. positive (proj_k R)\n 5. True", "by auto"], ["proof (state)\nthis:\n  positive (tensor_P (post - proj_psi_l R) (proj_k R))\n\ngoal (1 subgoal):\n 1. P' \\<le>\\<^sub>L tensor_P post (proj_k R)", "ultimately"], ["proof (chain)\npicking this:\n  tensor_P post (proj_k R) - P' = tensor_P (post - proj_psi_l R) (proj_k R)\n  positive (tensor_P (post - proj_psi_l R) (proj_k R))", "show \"P' \\<le>\\<^sub>L ?r\""], ["proof (prove)\nusing this:\n  tensor_P post (proj_k R) - P' = tensor_P (post - proj_psi_l R) (proj_k R)\n  positive (tensor_P (post - proj_psi_l R) (proj_k R))\n\ngoal (1 subgoal):\n 1. P' \\<le>\\<^sub>L tensor_P post (proj_k R)", "unfolding lowner_le_def P'_def"], ["proof (prove)\nusing this:\n  tensor_P post (proj_k R) - tensor_P (proj_psi_l R) (proj_k R) =\n  tensor_P (post - proj_psi_l R) (proj_k R)\n  positive (tensor_P (post - proj_psi_l R) (proj_k R))\n\ngoal (1 subgoal):\n 1. dim_row (tensor_P (proj_psi_l R) (proj_k R)) =\n    dim_row (tensor_P post (proj_k R)) \\<and>\n    dim_col (tensor_P (proj_psi_l R) (proj_k R)) =\n    dim_col (tensor_P post (proj_k R)) \\<and>\n    positive (tensor_P post (proj_k R) - tensor_P (proj_psi_l R) (proj_k R))", "using tensor_P_dim"], ["proof (prove)\nusing this:\n  tensor_P post (proj_k R) - tensor_P (proj_psi_l R) (proj_k R) =\n  tensor_P (post - proj_psi_l R) (proj_k R)\n  positive (tensor_P (post - proj_psi_l R) (proj_k R))\n  tensor_P ?A ?B \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. dim_row (tensor_P (proj_psi_l R) (proj_k R)) =\n    dim_row (tensor_P post (proj_k R)) \\<and>\n    dim_col (tensor_P (proj_psi_l R) (proj_k R)) =\n    dim_col (tensor_P post (proj_k R)) \\<and>\n    positive (tensor_P post (proj_k R) - tensor_P (proj_psi_l R) (proj_k R))", "by auto"], ["proof (state)\nthis:\n  P' \\<le>\\<^sub>L tensor_P post (proj_k R)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma positive_post:\n  \"positive post\""], ["proof (prove)\ngoal (1 subgoal):\n 1. positive post", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. positive post", "have ad: \"adjoint post = post\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adjoint post = post", "using hermitian_post[unfolded hermitian_def]"], ["proof (prove)\nusing this:\n  adjoint post = post\n\ngoal (1 subgoal):\n 1. adjoint post = post", "by auto"], ["proof (state)\nthis:\n  adjoint post = post\n\ngoal (1 subgoal):\n 1. positive post", "then"], ["proof (chain)\npicking this:\n  adjoint post = post", "have \"post * adjoint post = post\""], ["proof (prove)\nusing this:\n  adjoint post = post\n\ngoal (1 subgoal):\n 1. post * adjoint post = post", "unfolding ad post_mult_post"], ["proof (prove)\nusing this:\n  post = post\n\ngoal (1 subgoal):\n 1. post = post", "by auto"], ["proof (state)\nthis:\n  post * adjoint post = post\n\ngoal (1 subgoal):\n 1. positive post", "then"], ["proof (chain)\npicking this:\n  post * adjoint post = post", "have \"\\<exists>M. M * adjoint M = post\""], ["proof (prove)\nusing this:\n  post * adjoint post = post\n\ngoal (1 subgoal):\n 1. \\<exists>M. M * adjoint M = post", "by auto"], ["proof (state)\nthis:\n  \\<exists>M. M * adjoint M = post\n\ngoal (1 subgoal):\n 1. positive post", "then"], ["proof (chain)\npicking this:\n  \\<exists>M. M * adjoint M = post", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>M. M * adjoint M = post\n\ngoal (1 subgoal):\n 1. positive post", "using positive_if_decomp post_dim"], ["proof (prove)\nusing this:\n  \\<exists>M. M * adjoint M = post\n  \\<lbrakk>?A \\<in> carrier_mat ?n ?n;\n   \\<exists>M. M * adjoint M = ?A\\<rbrakk>\n  \\<Longrightarrow> positive ?A\n  post \\<in> carrier_mat N N\n\ngoal (1 subgoal):\n 1. positive post", "by auto"], ["proof (state)\nthis:\n  positive post\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lowner_le_P':\n  \"P' \\<le>\\<^sub>L tensor_P post (1\\<^sub>m K)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P' \\<le>\\<^sub>L tensor_P post (1\\<^sub>m K)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. P' \\<le>\\<^sub>L tensor_P post (1\\<^sub>m K)", "let ?r = \"tensor_P post (1\\<^sub>m K)\""], ["proof (state)\ngoal (1 subgoal):\n 1. P' \\<le>\\<^sub>L tensor_P post (1\\<^sub>m K)", "let ?m = \"tensor_P post (proj_k R)\""], ["proof (state)\ngoal (1 subgoal):\n 1. P' \\<le>\\<^sub>L tensor_P post (1\\<^sub>m K)", "have \"?m \\<le>\\<^sub>L ?r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tensor_P post (proj_k R) \\<le>\\<^sub>L tensor_P post (1\\<^sub>m K)", "unfolding ps2_P.ptensor_mat_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ps_P.tensor_mat post (proj_k R) \\<le>\\<^sub>L\n    ps_P.tensor_mat post (1\\<^sub>m K)", "apply (subst ps_P.tensor_mat_positive_le)"], ["proof (prove)\ngoal (7 subgoals):\n 1. post \\<in> carrier_mat ps_P.d1 ps_P.d1\n 2. proj_k R \\<in> carrier_mat ps_P.d2 ps_P.d2\n 3. positive post\n 4. positive (proj_k R)\n 5. post \\<le>\\<^sub>L post\n 6. proj_k R \\<le>\\<^sub>L 1\\<^sub>m K\n 7. True", "unfolding ps_P_d1 ps_P_d2"], ["proof (prove)\ngoal (7 subgoals):\n 1. post \\<in> carrier_mat N N\n 2. proj_k R \\<in> carrier_mat K K\n 3. positive post\n 4. positive (proj_k R)\n 5. post \\<le>\\<^sub>L post\n 6. proj_k R \\<le>\\<^sub>L 1\\<^sub>m K\n 7. True", "using post_dim proj_k_dim positive_post positive_proj_k\n      lowner_le_refl[of post] proj_k_le_one"], ["proof (prove)\nusing this:\n  post \\<in> carrier_mat N N\n  proj_k ?k \\<in> carrier_mat K K\n  positive post\n  positive (proj_k ?k)\n  post \\<in> carrier_mat ?n ?n \\<Longrightarrow> post \\<le>\\<^sub>L post\n  proj_k ?k \\<le>\\<^sub>L 1\\<^sub>m K\n\ngoal (7 subgoals):\n 1. post \\<in> carrier_mat N N\n 2. proj_k R \\<in> carrier_mat K K\n 3. positive post\n 4. positive (proj_k R)\n 5. post \\<le>\\<^sub>L post\n 6. proj_k R \\<le>\\<^sub>L 1\\<^sub>m K\n 7. True", "by auto"], ["proof (state)\nthis:\n  tensor_P post (proj_k R) \\<le>\\<^sub>L tensor_P post (1\\<^sub>m K)\n\ngoal (1 subgoal):\n 1. P' \\<le>\\<^sub>L tensor_P post (1\\<^sub>m K)", "then"], ["proof (chain)\npicking this:\n  tensor_P post (proj_k R) \\<le>\\<^sub>L tensor_P post (1\\<^sub>m K)", "show \"P' \\<le>\\<^sub>L ?r\""], ["proof (prove)\nusing this:\n  tensor_P post (proj_k R) \\<le>\\<^sub>L tensor_P post (1\\<^sub>m K)\n\ngoal (1 subgoal):\n 1. P' \\<le>\\<^sub>L tensor_P post (1\\<^sub>m K)", "using lowner_le_trans[of P' d ?m ?r] P'_le_post_R"], ["proof (prove)\nusing this:\n  tensor_P post (proj_k R) \\<le>\\<^sub>L tensor_P post (1\\<^sub>m K)\n  \\<lbrakk>P' \\<in> carrier_mat d d;\n   tensor_P post (proj_k R) \\<in> carrier_mat d d;\n   tensor_P post (1\\<^sub>m K) \\<in> carrier_mat d d;\n   P' \\<le>\\<^sub>L tensor_P post (proj_k R);\n   tensor_P post (proj_k R) \\<le>\\<^sub>L\n   tensor_P post (1\\<^sub>m K)\\<rbrakk>\n  \\<Longrightarrow> P' \\<le>\\<^sub>L tensor_P post (1\\<^sub>m K)\n  P' \\<le>\\<^sub>L tensor_P post (proj_k R)\n\ngoal (1 subgoal):\n 1. P' \\<le>\\<^sub>L tensor_P post (1\\<^sub>m K)", "unfolding P'_def"], ["proof (prove)\nusing this:\n  tensor_P post (proj_k R) \\<le>\\<^sub>L tensor_P post (1\\<^sub>m K)\n  \\<lbrakk>tensor_P (proj_psi_l R) (proj_k R) \\<in> carrier_mat d d;\n   tensor_P post (proj_k R) \\<in> carrier_mat d d;\n   tensor_P post (1\\<^sub>m K) \\<in> carrier_mat d d;\n   tensor_P (proj_psi_l R) (proj_k R) \\<le>\\<^sub>L\n   tensor_P post (proj_k R);\n   tensor_P post (proj_k R) \\<le>\\<^sub>L\n   tensor_P post (1\\<^sub>m K)\\<rbrakk>\n  \\<Longrightarrow> tensor_P (proj_psi_l R) (proj_k R) \\<le>\\<^sub>L\n                    tensor_P post (1\\<^sub>m K)\n  tensor_P (proj_psi_l R) (proj_k R) \\<le>\\<^sub>L tensor_P post (proj_k R)\n\ngoal (1 subgoal):\n 1. tensor_P (proj_psi_l R) (proj_k R) \\<le>\\<^sub>L\n    tensor_P post (1\\<^sub>m K)", "using tensor_P_dim"], ["proof (prove)\nusing this:\n  tensor_P post (proj_k R) \\<le>\\<^sub>L tensor_P post (1\\<^sub>m K)\n  \\<lbrakk>tensor_P (proj_psi_l R) (proj_k R) \\<in> carrier_mat d d;\n   tensor_P post (proj_k R) \\<in> carrier_mat d d;\n   tensor_P post (1\\<^sub>m K) \\<in> carrier_mat d d;\n   tensor_P (proj_psi_l R) (proj_k R) \\<le>\\<^sub>L\n   tensor_P post (proj_k R);\n   tensor_P post (proj_k R) \\<le>\\<^sub>L\n   tensor_P post (1\\<^sub>m K)\\<rbrakk>\n  \\<Longrightarrow> tensor_P (proj_psi_l R) (proj_k R) \\<le>\\<^sub>L\n                    tensor_P post (1\\<^sub>m K)\n  tensor_P (proj_psi_l R) (proj_k R) \\<le>\\<^sub>L tensor_P post (proj_k R)\n  tensor_P ?A ?B \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. tensor_P (proj_psi_l R) (proj_k R) \\<le>\\<^sub>L\n    tensor_P post (1\\<^sub>m K)", "by auto"], ["proof (state)\nthis:\n  P' \\<le>\\<^sub>L tensor_P post (1\\<^sub>m K)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma post_mult_testNk:\n  assumes \"f k\"\n  shows \"post * (testN k) = testN k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. post * testN k = testN k", "using assms"], ["proof (prove)\nusing this:\n  f k\n\ngoal (1 subgoal):\n 1. post * testN k = testN k", "by (auto simp add: post_def testN_def scalar_prod_def sum_only_one_neq_0)"], ["", "lemma post_mult_testNk_neg:\n  assumes \"\\<not> f k\"\n  shows \"post * testN k = 0\\<^sub>m N N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. post * testN k = 0\\<^sub>m N N", "using assms"], ["proof (prove)\nusing this:\n  \\<not> f k\n\ngoal (1 subgoal):\n 1. post * testN k = 0\\<^sub>m N N", "by (auto simp add: post_def testN_def scalar_prod_def sum_only_one_neq_0)"], ["", "lemma testN_post1:\n  \"f k \\<Longrightarrow> adjoint (testN k) * post * testN k = testN k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f k \\<Longrightarrow> adjoint (testN k) * post * testN k = testN k", "apply (subst assoc_mult_mat[of _ N N _ N _ N])"], ["proof (prove)\ngoal (4 subgoals):\n 1. f k \\<Longrightarrow> adjoint (testN k) \\<in> carrier_mat N N\n 2. f k \\<Longrightarrow> post \\<in> carrier_mat N N\n 3. f k \\<Longrightarrow> testN k \\<in> carrier_mat N N\n 4. f k \\<Longrightarrow> adjoint (testN k) * (post * testN k) = testN k", "apply (auto simp add: adjoint_dim testN_dim post_dim)"], ["proof (prove)\ngoal (1 subgoal):\n 1. f k \\<Longrightarrow> adjoint (testN k) * (post * testN k) = testN k", "apply (subst post_mult_testNk, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. f k \\<Longrightarrow> adjoint (testN k) * testN k = testN k", "unfolding hermitian_testN[unfolded hermitian_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. f k \\<Longrightarrow> testN k * testN k = testN k", "using testN_mult_testN"], ["proof (prove)\nusing this:\n  testN ?k * testN ?k = testN ?k\n\ngoal (1 subgoal):\n 1. f k \\<Longrightarrow> testN k * testN k = testN k", "by auto"], ["", "lemma testN_post2:\n  \"\\<not> f k \\<Longrightarrow> adjoint (testN k) * post * testN k = 0\\<^sub>m N N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> f k \\<Longrightarrow>\n    adjoint (testN k) * post * testN k = 0\\<^sub>m N N", "apply (subst assoc_mult_mat[of _ N N _ N _ N])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<not> f k \\<Longrightarrow> adjoint (testN k) \\<in> carrier_mat N N\n 2. \\<not> f k \\<Longrightarrow> post \\<in> carrier_mat N N\n 3. \\<not> f k \\<Longrightarrow> testN k \\<in> carrier_mat N N\n 4. \\<not> f k \\<Longrightarrow>\n    adjoint (testN k) * (post * testN k) = 0\\<^sub>m N N", "apply (auto simp add: adjoint_dim testN_dim post_dim)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> f k \\<Longrightarrow>\n    adjoint (testN k) * (post * testN k) = 0\\<^sub>m N N", "apply (subst post_mult_testNk_neg, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> f k \\<Longrightarrow>\n    adjoint (testN k) * 0\\<^sub>m N N = 0\\<^sub>m N N", "unfolding hermitian_testN[unfolded hermitian_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> f k \\<Longrightarrow> testN k * 0\\<^sub>m N N = 0\\<^sub>m N N", "using testN_dim[of k]"], ["proof (prove)\nusing this:\n  testN k \\<in> carrier_mat N N\n\ngoal (1 subgoal):\n 1. \\<not> f k \\<Longrightarrow> testN k * 0\\<^sub>m N N = 0\\<^sub>m N N", "by auto"], ["", "definition post_fst_k :: \"nat \\<Rightarrow> complex mat\" where\n  \"post_fst_k k = mat N N (\\<lambda>(i, j). if (i = j \\<and> f i \\<and> i < k) then 1 else 0)\""], ["", "lemma post_fst_kN:\n  \"post_fst_k N = post\""], ["proof (prove)\ngoal (1 subgoal):\n 1. post_fst_k N = post", "unfolding post_fst_k_def post_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat N N\n     (\\<lambda>(i, j). if i = j \\<and> f i \\<and> i < N then 1 else 0) =\n    mat N N (\\<lambda>(i, j). if i = j \\<and> f i then 1 else 0)", "by auto"], ["", "lemma post_fst_k_Suc:\n  \"f i \\<Longrightarrow> post_fst_k (Suc i) = testN i + post_fst_k i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f i \\<Longrightarrow> post_fst_k (Suc i) = testN i + post_fst_k i", "apply (rule eq_matI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>ia j.\n       \\<lbrakk>f i; ia < dim_row (testN i + post_fst_k i);\n        j < dim_col (testN i + post_fst_k i)\\<rbrakk>\n       \\<Longrightarrow> post_fst_k (Suc i) $$ (ia, j) =\n                         (testN i + post_fst_k i) $$ (ia, j)\n 2. f i \\<Longrightarrow>\n    dim_row (post_fst_k (Suc i)) = dim_row (testN i + post_fst_k i)\n 3. f i \\<Longrightarrow>\n    dim_col (post_fst_k (Suc i)) = dim_col (testN i + post_fst_k i)", "unfolding post_fst_k_def testN_def"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>ia j.\n       \\<lbrakk>f i;\n        ia < dim_row\n              (mat N N\n                (\\<lambda>(ia, j). if ia = i \\<and> j = i then 1 else 0) +\n               mat N N\n                (\\<lambda>(ia, j).\n                    if ia = j \\<and> f ia \\<and> ia < i then 1 else 0));\n        j < dim_col\n             (mat N N\n               (\\<lambda>(ia, j). if ia = i \\<and> j = i then 1 else 0) +\n              mat N N\n               (\\<lambda>(ia, j).\n                   if ia = j \\<and> f ia \\<and> ia < i then 1\n                   else 0))\\<rbrakk>\n       \\<Longrightarrow> mat N N\n                          (\\<lambda>(ia, j).\n                              if ia = j \\<and> f ia \\<and> ia < Suc i then 1\n                              else 0) $$\n                         (ia, j) =\n                         (mat N N\n                           (\\<lambda>(ia, j).\n                               if ia = i \\<and> j = i then 1 else 0) +\n                          mat N N\n                           (\\<lambda>(ia, j).\n                               if ia = j \\<and> f ia \\<and> ia < i then 1\n                               else 0)) $$\n                         (ia, j)\n 2. f i \\<Longrightarrow>\n    dim_row\n     (mat N N\n       (\\<lambda>(ia, j).\n           if ia = j \\<and> f ia \\<and> ia < Suc i then 1 else 0)) =\n    dim_row\n     (mat N N (\\<lambda>(ia, j). if ia = i \\<and> j = i then 1 else 0) +\n      mat N N\n       (\\<lambda>(ia, j).\n           if ia = j \\<and> f ia \\<and> ia < i then 1 else 0))\n 3. f i \\<Longrightarrow>\n    dim_col\n     (mat N N\n       (\\<lambda>(ia, j).\n           if ia = j \\<and> f ia \\<and> ia < Suc i then 1 else 0)) =\n    dim_col\n     (mat N N (\\<lambda>(ia, j). if ia = i \\<and> j = i then 1 else 0) +\n      mat N N\n       (\\<lambda>(ia, j).\n           if ia = j \\<and> f ia \\<and> ia < i then 1 else 0))", "by auto"], ["", "lemma post_fst_k_Suc_neg:\n  \"\\<not> f i \\<Longrightarrow> post_fst_k (Suc i) = post_fst_k i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> f i \\<Longrightarrow> post_fst_k (Suc i) = post_fst_k i", "apply (rule eq_matI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>ia j.\n       \\<lbrakk>\\<not> f i; ia < dim_row (post_fst_k i);\n        j < dim_col (post_fst_k i)\\<rbrakk>\n       \\<Longrightarrow> post_fst_k (Suc i) $$ (ia, j) =\n                         post_fst_k i $$ (ia, j)\n 2. \\<not> f i \\<Longrightarrow>\n    dim_row (post_fst_k (Suc i)) = dim_row (post_fst_k i)\n 3. \\<not> f i \\<Longrightarrow>\n    dim_col (post_fst_k (Suc i)) = dim_col (post_fst_k i)", "unfolding post_fst_k_def"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>ia j.\n       \\<lbrakk>\\<not> f i;\n        ia < dim_row\n              (mat N N\n                (\\<lambda>(ia, j).\n                    if ia = j \\<and> f ia \\<and> ia < i then 1 else 0));\n        j < dim_col\n             (mat N N\n               (\\<lambda>(ia, j).\n                   if ia = j \\<and> f ia \\<and> ia < i then 1\n                   else 0))\\<rbrakk>\n       \\<Longrightarrow> mat N N\n                          (\\<lambda>(ia, j).\n                              if ia = j \\<and> f ia \\<and> ia < Suc i then 1\n                              else 0) $$\n                         (ia, j) =\n                         mat N N\n                          (\\<lambda>(ia, j).\n                              if ia = j \\<and> f ia \\<and> ia < i then 1\n                              else 0) $$\n                         (ia, j)\n 2. \\<not> f i \\<Longrightarrow>\n    dim_row\n     (mat N N\n       (\\<lambda>(ia, j).\n           if ia = j \\<and> f ia \\<and> ia < Suc i then 1 else 0)) =\n    dim_row\n     (mat N N\n       (\\<lambda>(ia, j).\n           if ia = j \\<and> f ia \\<and> ia < i then 1 else 0))\n 3. \\<not> f i \\<Longrightarrow>\n    dim_col\n     (mat N N\n       (\\<lambda>(ia, j).\n           if ia = j \\<and> f ia \\<and> ia < Suc i then 1 else 0)) =\n    dim_col\n     (mat N N\n       (\\<lambda>(ia, j).\n           if ia = j \\<and> f ia \\<and> ia < i then 1 else 0))", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>\\<not> f i; j < N; f j; j < Suc i\\<rbrakk>\n       \\<Longrightarrow> j < i", "using less_antisym"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> ?n < ?m; ?n < Suc ?m\\<rbrakk> \\<Longrightarrow> ?m = ?n\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>\\<not> f i; j < N; f j; j < Suc i\\<rbrakk>\n       \\<Longrightarrow> j < i", "by fastforce"], ["", "lemma testN_sum:\n  \"matrix_sum N (\\<lambda>k. adjoint (testN k) * post * testN k) N = post\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_sum N (\\<lambda>k. adjoint (testN k) * post * testN k) N = post", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. matrix_sum N (\\<lambda>k. adjoint (testN k) * post * testN k) N = post", "have \"m \\<le> N \\<Longrightarrow> matrix_sum N (\\<lambda>k. adjoint (testN k) * post * testN k) m = post_fst_k m\" for m"], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<le> N \\<Longrightarrow>\n    matrix_sum N (\\<lambda>k. adjoint (testN k) * post * testN k) m =\n    post_fst_k m", "proof (induct m)"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 \\<le> N \\<Longrightarrow>\n    matrix_sum N (\\<lambda>k. adjoint (testN k) * post * testN k) 0 =\n    post_fst_k 0\n 2. \\<And>m.\n       \\<lbrakk>m \\<le> N \\<Longrightarrow>\n                matrix_sum N\n                 (\\<lambda>k. adjoint (testN k) * post * testN k) m =\n                post_fst_k m;\n        Suc m \\<le> N\\<rbrakk>\n       \\<Longrightarrow> matrix_sum N\n                          (\\<lambda>k. adjoint (testN k) * post * testN k)\n                          (Suc m) =\n                         post_fst_k (Suc m)", "case 0"], ["proof (state)\nthis:\n  0 \\<le> N\n\ngoal (2 subgoals):\n 1. 0 \\<le> N \\<Longrightarrow>\n    matrix_sum N (\\<lambda>k. adjoint (testN k) * post * testN k) 0 =\n    post_fst_k 0\n 2. \\<And>m.\n       \\<lbrakk>m \\<le> N \\<Longrightarrow>\n                matrix_sum N\n                 (\\<lambda>k. adjoint (testN k) * post * testN k) m =\n                post_fst_k m;\n        Suc m \\<le> N\\<rbrakk>\n       \\<Longrightarrow> matrix_sum N\n                          (\\<lambda>k. adjoint (testN k) * post * testN k)\n                          (Suc m) =\n                         post_fst_k (Suc m)", "then"], ["proof (chain)\npicking this:\n  0 \\<le> N", "show ?case"], ["proof (prove)\nusing this:\n  0 \\<le> N\n\ngoal (1 subgoal):\n 1. matrix_sum N (\\<lambda>k. adjoint (testN k) * post * testN k) 0 =\n    post_fst_k 0", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0\\<^sub>m N N = post_fst_k 0", "unfolding post_fst_k_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0\\<^sub>m N N =\n    mat N N\n     (\\<lambda>(i, j). if i = j \\<and> f i \\<and> i < 0 then 1 else 0)", "by auto"], ["proof (state)\nthis:\n  matrix_sum N (\\<lambda>k. adjoint (testN k) * post * testN k) 0 =\n  post_fst_k 0\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       \\<lbrakk>m \\<le> N \\<Longrightarrow>\n                matrix_sum N\n                 (\\<lambda>k. adjoint (testN k) * post * testN k) m =\n                post_fst_k m;\n        Suc m \\<le> N\\<rbrakk>\n       \\<Longrightarrow> matrix_sum N\n                          (\\<lambda>k. adjoint (testN k) * post * testN k)\n                          (Suc m) =\n                         post_fst_k (Suc m)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m.\n       \\<lbrakk>m \\<le> N \\<Longrightarrow>\n                matrix_sum N\n                 (\\<lambda>k. adjoint (testN k) * post * testN k) m =\n                post_fst_k m;\n        Suc m \\<le> N\\<rbrakk>\n       \\<Longrightarrow> matrix_sum N\n                          (\\<lambda>k. adjoint (testN k) * post * testN k)\n                          (Suc m) =\n                         post_fst_k (Suc m)", "case (Suc m)"], ["proof (state)\nthis:\n  m \\<le> N \\<Longrightarrow>\n  matrix_sum N (\\<lambda>k. adjoint (testN k) * post * testN k) m =\n  post_fst_k m\n  Suc m \\<le> N\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       \\<lbrakk>m \\<le> N \\<Longrightarrow>\n                matrix_sum N\n                 (\\<lambda>k. adjoint (testN k) * post * testN k) m =\n                post_fst_k m;\n        Suc m \\<le> N\\<rbrakk>\n       \\<Longrightarrow> matrix_sum N\n                          (\\<lambda>k. adjoint (testN k) * post * testN k)\n                          (Suc m) =\n                         post_fst_k (Suc m)", "then"], ["proof (chain)\npicking this:\n  m \\<le> N \\<Longrightarrow>\n  matrix_sum N (\\<lambda>k. adjoint (testN k) * post * testN k) m =\n  post_fst_k m\n  Suc m \\<le> N", "have m: \"m \\<le> N\""], ["proof (prove)\nusing this:\n  m \\<le> N \\<Longrightarrow>\n  matrix_sum N (\\<lambda>k. adjoint (testN k) * post * testN k) m =\n  post_fst_k m\n  Suc m \\<le> N\n\ngoal (1 subgoal):\n 1. m \\<le> N", "by auto"], ["proof (state)\nthis:\n  m \\<le> N\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       \\<lbrakk>m \\<le> N \\<Longrightarrow>\n                matrix_sum N\n                 (\\<lambda>k. adjoint (testN k) * post * testN k) m =\n                post_fst_k m;\n        Suc m \\<le> N\\<rbrakk>\n       \\<Longrightarrow> matrix_sum N\n                          (\\<lambda>k. adjoint (testN k) * post * testN k)\n                          (Suc m) =\n                         post_fst_k (Suc m)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_sum N (\\<lambda>k. adjoint (testN k) * post * testN k) (Suc m) =\n    post_fst_k (Suc m)", "proof (cases \"f m\")"], ["proof (state)\ngoal (2 subgoals):\n 1. f m \\<Longrightarrow>\n    matrix_sum N (\\<lambda>k. adjoint (testN k) * post * testN k) (Suc m) =\n    post_fst_k (Suc m)\n 2. \\<not> f m \\<Longrightarrow>\n    matrix_sum N (\\<lambda>k. adjoint (testN k) * post * testN k) (Suc m) =\n    post_fst_k (Suc m)", "case True"], ["proof (state)\nthis:\n  f m\n\ngoal (2 subgoals):\n 1. f m \\<Longrightarrow>\n    matrix_sum N (\\<lambda>k. adjoint (testN k) * post * testN k) (Suc m) =\n    post_fst_k (Suc m)\n 2. \\<not> f m \\<Longrightarrow>\n    matrix_sum N (\\<lambda>k. adjoint (testN k) * post * testN k) (Suc m) =\n    post_fst_k (Suc m)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_sum N (\\<lambda>k. adjoint (testN k) * post * testN k) (Suc m) =\n    post_fst_k (Suc m)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. adjoint (testN m) * post * testN m +\n    matrix_sum N (\\<lambda>k. adjoint (testN k) * post * testN k) m =\n    post_fst_k (Suc m)", "apply (subst testN_post1[OF True])"], ["proof (prove)\ngoal (1 subgoal):\n 1. testN m +\n    matrix_sum N (\\<lambda>k. adjoint (testN k) * post * testN k) m =\n    post_fst_k (Suc m)", "apply (subst Suc(1)[OF m])"], ["proof (prove)\ngoal (1 subgoal):\n 1. testN m + post_fst_k m = post_fst_k (Suc m)", "using post_fst_k_Suc True"], ["proof (prove)\nusing this:\n  f ?i \\<Longrightarrow> post_fst_k (Suc ?i) = testN ?i + post_fst_k ?i\n  f m\n\ngoal (1 subgoal):\n 1. testN m + post_fst_k m = post_fst_k (Suc m)", "by auto"], ["proof (state)\nthis:\n  matrix_sum N (\\<lambda>k. adjoint (testN k) * post * testN k) (Suc m) =\n  post_fst_k (Suc m)\n\ngoal (1 subgoal):\n 1. \\<not> f m \\<Longrightarrow>\n    matrix_sum N (\\<lambda>k. adjoint (testN k) * post * testN k) (Suc m) =\n    post_fst_k (Suc m)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> f m \\<Longrightarrow>\n    matrix_sum N (\\<lambda>k. adjoint (testN k) * post * testN k) (Suc m) =\n    post_fst_k (Suc m)", "case False"], ["proof (state)\nthis:\n  \\<not> f m\n\ngoal (1 subgoal):\n 1. \\<not> f m \\<Longrightarrow>\n    matrix_sum N (\\<lambda>k. adjoint (testN k) * post * testN k) (Suc m) =\n    post_fst_k (Suc m)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_sum N (\\<lambda>k. adjoint (testN k) * post * testN k) (Suc m) =\n    post_fst_k (Suc m)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. adjoint (testN m) * post * testN m +\n    matrix_sum N (\\<lambda>k. adjoint (testN k) * post * testN k) m =\n    post_fst_k (Suc m)", "apply (subst testN_post2[OF False])"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0\\<^sub>m N N +\n    matrix_sum N (\\<lambda>k. adjoint (testN k) * post * testN k) m =\n    post_fst_k (Suc m)", "apply (subst Suc(1)[OF m])"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0\\<^sub>m N N + post_fst_k m = post_fst_k (Suc m)", "using post_fst_k_Suc_neg False post_fst_k_def"], ["proof (prove)\nusing this:\n  \\<not> f ?i \\<Longrightarrow> post_fst_k (Suc ?i) = post_fst_k ?i\n  \\<not> f m\n  post_fst_k ?k =\n  mat N N (\\<lambda>(i, j). if i = j \\<and> f i \\<and> i < ?k then 1 else 0)\n\ngoal (1 subgoal):\n 1. 0\\<^sub>m N N + post_fst_k m = post_fst_k (Suc m)", "by auto"], ["proof (state)\nthis:\n  matrix_sum N (\\<lambda>k. adjoint (testN k) * post * testN k) (Suc m) =\n  post_fst_k (Suc m)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  matrix_sum N (\\<lambda>k. adjoint (testN k) * post * testN k) (Suc m) =\n  post_fst_k (Suc m)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?m2 \\<le> N \\<Longrightarrow>\n  matrix_sum N (\\<lambda>k. adjoint (testN k) * post * testN k) ?m2 =\n  post_fst_k ?m2\n\ngoal (1 subgoal):\n 1. matrix_sum N (\\<lambda>k. adjoint (testN k) * post * testN k) N = post", "then"], ["proof (chain)\npicking this:\n  ?m2 \\<le> N \\<Longrightarrow>\n  matrix_sum N (\\<lambda>k. adjoint (testN k) * post * testN k) ?m2 =\n  post_fst_k ?m2", "show ?thesis"], ["proof (prove)\nusing this:\n  ?m2 \\<le> N \\<Longrightarrow>\n  matrix_sum N (\\<lambda>k. adjoint (testN k) * post * testN k) ?m2 =\n  post_fst_k ?m2\n\ngoal (1 subgoal):\n 1. matrix_sum N (\\<lambda>k. adjoint (testN k) * post * testN k) N = post", "using post_fst_kN"], ["proof (prove)\nusing this:\n  ?m2 \\<le> N \\<Longrightarrow>\n  matrix_sum N (\\<lambda>k. adjoint (testN k) * post * testN k) ?m2 =\n  post_fst_k ?m2\n  post_fst_k N = post\n\ngoal (1 subgoal):\n 1. matrix_sum N (\\<lambda>k. adjoint (testN k) * post * testN k) N = post", "by auto"], ["proof (state)\nthis:\n  matrix_sum N (\\<lambda>k. adjoint (testN k) * post * testN k) N = post\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma tensor_P_testN_sum:\n  \"matrix_sum d (\\<lambda>k. adjoint (tensor_P (testN k) (1\\<^sub>m K)) * tensor_P post (1\\<^sub>m K) * tensor_P (testN k) (1\\<^sub>m K)) N =\n   tensor_P post (1\\<^sub>m K)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_sum d\n     (\\<lambda>k.\n         adjoint (tensor_P (testN k) (1\\<^sub>m K)) *\n         tensor_P post (1\\<^sub>m K) *\n         tensor_P (testN k) (1\\<^sub>m K))\n     N =\n    tensor_P post (1\\<^sub>m K)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. matrix_sum d\n     (\\<lambda>k.\n         adjoint (tensor_P (testN k) (1\\<^sub>m K)) *\n         tensor_P post (1\\<^sub>m K) *\n         tensor_P (testN k) (1\\<^sub>m K))\n     N =\n    tensor_P post (1\\<^sub>m K)", "have eq: \"adjoint (tensor_P (testN k) (1\\<^sub>m K)) * tensor_P post (1\\<^sub>m K) * tensor_P (testN k) (1\\<^sub>m K) =\n            tensor_P (adjoint (testN k) * post * (testN k)) (1\\<^sub>m K)\" for k"], ["proof (prove)\ngoal (1 subgoal):\n 1. adjoint (tensor_P (testN k) (1\\<^sub>m K)) *\n    tensor_P post (1\\<^sub>m K) *\n    tensor_P (testN k) (1\\<^sub>m K) =\n    tensor_P (adjoint (testN k) * post * testN k) (1\\<^sub>m K)", "apply (subst tensor_P_adjoint_left_right)"], ["proof (prove)\ngoal (4 subgoals):\n 1. testN k \\<in> carrier_mat N N\n 2. 1\\<^sub>m K \\<in> carrier_mat K K\n 3. post \\<in> carrier_mat N N\n 4. tensor_P (adjoint (testN k) * post * testN k)\n     (adjoint (1\\<^sub>m K) * 1\\<^sub>m K * 1\\<^sub>m K) =\n    tensor_P (adjoint (testN k) * post * testN k) (1\\<^sub>m K)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. testN k \\<in> carrier_mat N N", "unfolding testN_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat N N (\\<lambda>(i, j). if i = k \\<and> j = k then 1 else 0)\n    \\<in> carrier_mat N N", "by auto"], ["proof (prove)\ngoal (3 subgoals):\n 1. 1\\<^sub>m K \\<in> carrier_mat K K\n 2. post \\<in> carrier_mat N N\n 3. tensor_P (adjoint (testN k) * post * testN k)\n     (adjoint (1\\<^sub>m K) * 1\\<^sub>m K * 1\\<^sub>m K) =\n    tensor_P (adjoint (testN k) * post * testN k) (1\\<^sub>m K)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1\\<^sub>m K \\<in> carrier_mat K K", "by auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. post \\<in> carrier_mat N N\n 2. tensor_P (adjoint (testN k) * post * testN k)\n     (adjoint (1\\<^sub>m K) * 1\\<^sub>m K * 1\\<^sub>m K) =\n    tensor_P (adjoint (testN k) * post * testN k) (1\\<^sub>m K)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. post \\<in> carrier_mat N N", "using post_dim"], ["proof (prove)\nusing this:\n  post \\<in> carrier_mat N N\n\ngoal (1 subgoal):\n 1. post \\<in> carrier_mat N N", "by auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. tensor_P (adjoint (testN k) * post * testN k)\n     (adjoint (1\\<^sub>m K) * 1\\<^sub>m K * 1\\<^sub>m K) =\n    tensor_P (adjoint (testN k) * post * testN k) (1\\<^sub>m K)", "using adjoint_one"], ["proof (prove)\nusing this:\n  adjoint (1\\<^sub>m ?n) = 1\\<^sub>m ?n\n\ngoal (1 subgoal):\n 1. tensor_P (adjoint (testN k) * post * testN k)\n     (adjoint (1\\<^sub>m K) * 1\\<^sub>m K * 1\\<^sub>m K) =\n    tensor_P (adjoint (testN k) * post * testN k) (1\\<^sub>m K)", "by auto"], ["proof (state)\nthis:\n  adjoint (tensor_P (testN ?k2) (1\\<^sub>m K)) *\n  tensor_P post (1\\<^sub>m K) *\n  tensor_P (testN ?k2) (1\\<^sub>m K) =\n  tensor_P (adjoint (testN ?k2) * post * testN ?k2) (1\\<^sub>m K)\n\ngoal (1 subgoal):\n 1. matrix_sum d\n     (\\<lambda>k.\n         adjoint (tensor_P (testN k) (1\\<^sub>m K)) *\n         tensor_P post (1\\<^sub>m K) *\n         tensor_P (testN k) (1\\<^sub>m K))\n     N =\n    tensor_P post (1\\<^sub>m K)", "moreover"], ["proof (state)\nthis:\n  adjoint (tensor_P (testN ?k2) (1\\<^sub>m K)) *\n  tensor_P post (1\\<^sub>m K) *\n  tensor_P (testN ?k2) (1\\<^sub>m K) =\n  tensor_P (adjoint (testN ?k2) * post * testN ?k2) (1\\<^sub>m K)\n\ngoal (1 subgoal):\n 1. matrix_sum d\n     (\\<lambda>k.\n         adjoint (tensor_P (testN k) (1\\<^sub>m K)) *\n         tensor_P post (1\\<^sub>m K) *\n         tensor_P (testN k) (1\\<^sub>m K))\n     N =\n    tensor_P post (1\\<^sub>m K)", "have \"matrix_sum N (\\<lambda>k. adjoint (testN k) * post * testN k) N = post\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_sum N (\\<lambda>k. adjoint (testN k) * post * testN k) N = post", "using testN_sum"], ["proof (prove)\nusing this:\n  matrix_sum N (\\<lambda>k. adjoint (testN k) * post * testN k) N = post\n\ngoal (1 subgoal):\n 1. matrix_sum N (\\<lambda>k. adjoint (testN k) * post * testN k) N = post", "by auto"], ["proof (state)\nthis:\n  matrix_sum N (\\<lambda>k. adjoint (testN k) * post * testN k) N = post\n\ngoal (1 subgoal):\n 1. matrix_sum d\n     (\\<lambda>k.\n         adjoint (tensor_P (testN k) (1\\<^sub>m K)) *\n         tensor_P post (1\\<^sub>m K) *\n         tensor_P (testN k) (1\\<^sub>m K))\n     N =\n    tensor_P post (1\\<^sub>m K)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_sum d\n     (\\<lambda>k.\n         adjoint (tensor_P (testN k) (1\\<^sub>m K)) *\n         tensor_P post (1\\<^sub>m K) *\n         tensor_P (testN k) (1\\<^sub>m K))\n     N =\n    tensor_P post (1\\<^sub>m K)", "unfolding eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_sum d\n     (\\<lambda>k.\n         tensor_P (adjoint (testN k) * post * testN k) (1\\<^sub>m K))\n     N =\n    tensor_P post (1\\<^sub>m K)", "apply (subst matrix_sum_tensor_P1)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>k.\n       k < N \\<Longrightarrow>\n       adjoint (testN k) * post * testN k \\<in> carrier_mat N N\n 2. 1\\<^sub>m K \\<in> carrier_mat K K\n 3. tensor_P\n     (matrix_sum N (\\<lambda>k. adjoint (testN k) * post * testN k) N)\n     (1\\<^sub>m K) =\n    tensor_P post (1\\<^sub>m K)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. k_ < N \\<Longrightarrow>\n    adjoint (testN k_) * post * testN k_ \\<in> carrier_mat N N", "unfolding testN_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. k_ < N \\<Longrightarrow>\n    adjoint\n     (mat N N (\\<lambda>(i, j). if i = k_ \\<and> j = k_ then 1 else 0)) *\n    post *\n    mat N N (\\<lambda>(i, j). if i = k_ \\<and> j = k_ then 1 else 0)\n    \\<in> carrier_mat N N", "by auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. 1\\<^sub>m K \\<in> carrier_mat K K\n 2. tensor_P\n     (matrix_sum N (\\<lambda>k. adjoint (testN k) * post * testN k) N)\n     (1\\<^sub>m K) =\n    tensor_P post (1\\<^sub>m K)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1\\<^sub>m K \\<in> carrier_mat K K", "by auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. tensor_P\n     (matrix_sum N (\\<lambda>k. adjoint (testN k) * post * testN k) N)\n     (1\\<^sub>m K) =\n    tensor_P post (1\\<^sub>m K)", "using testN_sum"], ["proof (prove)\nusing this:\n  matrix_sum N (\\<lambda>k. adjoint (testN k) * post * testN k) N = post\n\ngoal (1 subgoal):\n 1. tensor_P\n     (matrix_sum N (\\<lambda>k. adjoint (testN k) * post * testN k) N)\n     (1\\<^sub>m K) =\n    tensor_P post (1\\<^sub>m K)", "by auto"], ["proof (state)\nthis:\n  matrix_sum d\n   (\\<lambda>k.\n       adjoint (tensor_P (testN k) (1\\<^sub>m K)) *\n       tensor_P post (1\\<^sub>m K) *\n       tensor_P (testN k) (1\\<^sub>m K))\n   N =\n  tensor_P post (1\\<^sub>m K)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma post_le_one:\n  \"post \\<le>\\<^sub>L 1\\<^sub>m N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. post \\<le>\\<^sub>L 1\\<^sub>m N", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. post \\<le>\\<^sub>L 1\\<^sub>m N", "let ?s = \"1\\<^sub>m N - post\""], ["proof (state)\ngoal (1 subgoal):\n 1. post \\<le>\\<^sub>L 1\\<^sub>m N", "have eq1: \"1\\<^sub>m N * (1\\<^sub>m N - post) = 1\\<^sub>m N - post\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1\\<^sub>m N * (1\\<^sub>m N - post) = 1\\<^sub>m N - post", "apply (mat_assoc N)"], ["proof (prove)\ngoal (2 subgoals):\n 1. post \\<in> carrier_mat N N\n 2. 1\\<^sub>m N \\<in> carrier_mat N N", "using post_dim"], ["proof (prove)\nusing this:\n  post \\<in> carrier_mat N N\n\ngoal (2 subgoals):\n 1. post \\<in> carrier_mat N N\n 2. 1\\<^sub>m N \\<in> carrier_mat N N", "by auto"], ["proof (state)\nthis:\n  1\\<^sub>m N * (1\\<^sub>m N - post) = 1\\<^sub>m N - post\n\ngoal (1 subgoal):\n 1. post \\<le>\\<^sub>L 1\\<^sub>m N", "have eq2: \"post * (1\\<^sub>m N - post) = 0\\<^sub>m N N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. post * (1\\<^sub>m N - post) = 0\\<^sub>m N N", "apply (subst mult_minus_distrib_mat[of _ N N])"], ["proof (prove)\ngoal (4 subgoals):\n 1. post \\<in> carrier_mat N N\n 2. 1\\<^sub>m N \\<in> carrier_mat N ?nc\n 3. post \\<in> carrier_mat N ?nc\n 4. post * 1\\<^sub>m N - post * post = 0\\<^sub>m N N", "using post_dim"], ["proof (prove)\nusing this:\n  post \\<in> carrier_mat N N\n\ngoal (4 subgoals):\n 1. post \\<in> carrier_mat N N\n 2. 1\\<^sub>m N \\<in> carrier_mat N ?nc\n 3. post \\<in> carrier_mat N ?nc\n 4. post * 1\\<^sub>m N - post * post = 0\\<^sub>m N N", "by (auto simp add: post_mult_post)"], ["proof (state)\nthis:\n  post * (1\\<^sub>m N - post) = 0\\<^sub>m N N\n\ngoal (1 subgoal):\n 1. post \\<le>\\<^sub>L 1\\<^sub>m N", "have \"adjoint ?s = ?s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adjoint (1\\<^sub>m N - post) = 1\\<^sub>m N - post", "apply (subst adjoint_minus)"], ["proof (prove)\ngoal (3 subgoals):\n 1. 1\\<^sub>m N \\<in> carrier_mat ?n ?m\n 2. post \\<in> carrier_mat ?n ?m\n 3. adjoint (1\\<^sub>m N) - adjoint post = 1\\<^sub>m N - post", "apply (auto simp add: post_dim adjoint_dim)"], ["proof (prove)\ngoal (1 subgoal):\n 1. adjoint (1\\<^sub>m N) - adjoint post = 1\\<^sub>m N - post", "using adjoint_one hermitian_post[unfolded hermitian_def]"], ["proof (prove)\nusing this:\n  adjoint (1\\<^sub>m ?n) = 1\\<^sub>m ?n\n  adjoint post = post\n\ngoal (1 subgoal):\n 1. adjoint (1\\<^sub>m N) - adjoint post = 1\\<^sub>m N - post", "by auto"], ["proof (state)\nthis:\n  adjoint (1\\<^sub>m N - post) = 1\\<^sub>m N - post\n\ngoal (1 subgoal):\n 1. post \\<le>\\<^sub>L 1\\<^sub>m N", "then"], ["proof (chain)\npicking this:\n  adjoint (1\\<^sub>m N - post) = 1\\<^sub>m N - post", "have \"?s * adjoint ?s = ?s * ?s\""], ["proof (prove)\nusing this:\n  adjoint (1\\<^sub>m N - post) = 1\\<^sub>m N - post\n\ngoal (1 subgoal):\n 1. (1\\<^sub>m N - post) * adjoint (1\\<^sub>m N - post) =\n    (1\\<^sub>m N - post) * (1\\<^sub>m N - post)", "by auto"], ["proof (state)\nthis:\n  (1\\<^sub>m N - post) * adjoint (1\\<^sub>m N - post) =\n  (1\\<^sub>m N - post) * (1\\<^sub>m N - post)\n\ngoal (1 subgoal):\n 1. post \\<le>\\<^sub>L 1\\<^sub>m N", "also"], ["proof (state)\nthis:\n  (1\\<^sub>m N - post) * adjoint (1\\<^sub>m N - post) =\n  (1\\<^sub>m N - post) * (1\\<^sub>m N - post)\n\ngoal (1 subgoal):\n 1. post \\<le>\\<^sub>L 1\\<^sub>m N", "have \"\\<dots> = 1\\<^sub>m N * (1\\<^sub>m N - post) - post * (1\\<^sub>m N - post)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1\\<^sub>m N - post) * (1\\<^sub>m N - post) =\n    1\\<^sub>m N * (1\\<^sub>m N - post) - post * (1\\<^sub>m N - post)", "apply (mat_assoc N)"], ["proof (prove)\ngoal (2 subgoals):\n 1. post \\<in> carrier_mat N N\n 2. 1\\<^sub>m N \\<in> carrier_mat N N", "using post_dim"], ["proof (prove)\nusing this:\n  post \\<in> carrier_mat N N\n\ngoal (2 subgoals):\n 1. post \\<in> carrier_mat N N\n 2. 1\\<^sub>m N \\<in> carrier_mat N N", "by auto"], ["proof (state)\nthis:\n  (1\\<^sub>m N - post) * (1\\<^sub>m N - post) =\n  1\\<^sub>m N * (1\\<^sub>m N - post) - post * (1\\<^sub>m N - post)\n\ngoal (1 subgoal):\n 1. post \\<le>\\<^sub>L 1\\<^sub>m N", "also"], ["proof (state)\nthis:\n  (1\\<^sub>m N - post) * (1\\<^sub>m N - post) =\n  1\\<^sub>m N * (1\\<^sub>m N - post) - post * (1\\<^sub>m N - post)\n\ngoal (1 subgoal):\n 1. post \\<le>\\<^sub>L 1\\<^sub>m N", "have \"\\<dots> = ?s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1\\<^sub>m N * (1\\<^sub>m N - post) - post * (1\\<^sub>m N - post) =\n    1\\<^sub>m N - post", "unfolding eq1 eq2"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1\\<^sub>m N - post - 0\\<^sub>m N N = 1\\<^sub>m N - post", "using post_dim"], ["proof (prove)\nusing this:\n  post \\<in> carrier_mat N N\n\ngoal (1 subgoal):\n 1. 1\\<^sub>m N - post - 0\\<^sub>m N N = 1\\<^sub>m N - post", "by auto"], ["proof (state)\nthis:\n  1\\<^sub>m N * (1\\<^sub>m N - post) - post * (1\\<^sub>m N - post) =\n  1\\<^sub>m N - post\n\ngoal (1 subgoal):\n 1. post \\<le>\\<^sub>L 1\\<^sub>m N", "finally"], ["proof (chain)\npicking this:\n  (1\\<^sub>m N - post) * adjoint (1\\<^sub>m N - post) = 1\\<^sub>m N - post", "have \"?s * adjoint ?s = ?s\""], ["proof (prove)\nusing this:\n  (1\\<^sub>m N - post) * adjoint (1\\<^sub>m N - post) = 1\\<^sub>m N - post\n\ngoal (1 subgoal):\n 1. (1\\<^sub>m N - post) * adjoint (1\\<^sub>m N - post) = 1\\<^sub>m N - post", "."], ["proof (state)\nthis:\n  (1\\<^sub>m N - post) * adjoint (1\\<^sub>m N - post) = 1\\<^sub>m N - post\n\ngoal (1 subgoal):\n 1. post \\<le>\\<^sub>L 1\\<^sub>m N", "then"], ["proof (chain)\npicking this:\n  (1\\<^sub>m N - post) * adjoint (1\\<^sub>m N - post) = 1\\<^sub>m N - post", "have \"\\<exists>M. M * adjoint M = ?s\""], ["proof (prove)\nusing this:\n  (1\\<^sub>m N - post) * adjoint (1\\<^sub>m N - post) = 1\\<^sub>m N - post\n\ngoal (1 subgoal):\n 1. \\<exists>M. M * adjoint M = 1\\<^sub>m N - post", "by auto"], ["proof (state)\nthis:\n  \\<exists>M. M * adjoint M = 1\\<^sub>m N - post\n\ngoal (1 subgoal):\n 1. post \\<le>\\<^sub>L 1\\<^sub>m N", "then"], ["proof (chain)\npicking this:\n  \\<exists>M. M * adjoint M = 1\\<^sub>m N - post", "have \"positive ?s\""], ["proof (prove)\nusing this:\n  \\<exists>M. M * adjoint M = 1\\<^sub>m N - post\n\ngoal (1 subgoal):\n 1. positive (1\\<^sub>m N - post)", "apply (subst positive_if_decomp[of ?s N])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<exists>M. M * adjoint M = 1\\<^sub>m N - post \\<Longrightarrow>\n    1\\<^sub>m N - post \\<in> carrier_mat N N\n 2. \\<exists>M. M * adjoint M = 1\\<^sub>m N - post \\<Longrightarrow>\n    \\<exists>M. M * adjoint M = 1\\<^sub>m N - post\n 3. \\<exists>M. M * adjoint M = 1\\<^sub>m N - post \\<Longrightarrow> True", "using post_dim"], ["proof (prove)\nusing this:\n  post \\<in> carrier_mat N N\n\ngoal (3 subgoals):\n 1. \\<exists>M. M * adjoint M = 1\\<^sub>m N - post \\<Longrightarrow>\n    1\\<^sub>m N - post \\<in> carrier_mat N N\n 2. \\<exists>M. M * adjoint M = 1\\<^sub>m N - post \\<Longrightarrow>\n    \\<exists>M. M * adjoint M = 1\\<^sub>m N - post\n 3. \\<exists>M. M * adjoint M = 1\\<^sub>m N - post \\<Longrightarrow> True", "by auto"], ["proof (state)\nthis:\n  positive (1\\<^sub>m N - post)\n\ngoal (1 subgoal):\n 1. post \\<le>\\<^sub>L 1\\<^sub>m N", "then"], ["proof (chain)\npicking this:\n  positive (1\\<^sub>m N - post)", "show ?thesis"], ["proof (prove)\nusing this:\n  positive (1\\<^sub>m N - post)\n\ngoal (1 subgoal):\n 1. post \\<le>\\<^sub>L 1\\<^sub>m N", "unfolding lowner_le_def"], ["proof (prove)\nusing this:\n  positive (1\\<^sub>m N - post)\n\ngoal (1 subgoal):\n 1. dim_row post = dim_row (1\\<^sub>m N) \\<and>\n    dim_col post = dim_col (1\\<^sub>m N) \\<and>\n    positive (1\\<^sub>m N - post)", "using post_dim"], ["proof (prove)\nusing this:\n  positive (1\\<^sub>m N - post)\n  post \\<in> carrier_mat N N\n\ngoal (1 subgoal):\n 1. dim_row post = dim_row (1\\<^sub>m N) \\<and>\n    dim_col post = dim_col (1\\<^sub>m N) \\<and>\n    positive (1\\<^sub>m N - post)", "by auto"], ["proof (state)\nthis:\n  post \\<le>\\<^sub>L 1\\<^sub>m N\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma qp_post:\n  \"is_quantum_predicate (tensor_P post (1\\<^sub>m K))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_quantum_predicate (tensor_P post (1\\<^sub>m K))", "unfolding is_quantum_predicate_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. tensor_P post (1\\<^sub>m K) \\<in> carrier_mat d d \\<and>\n    positive (tensor_P post (1\\<^sub>m K)) \\<and>\n    tensor_P post (1\\<^sub>m K) \\<le>\\<^sub>L 1\\<^sub>m d", "proof (intro conjI)"], ["proof (state)\ngoal (3 subgoals):\n 1. tensor_P post (1\\<^sub>m K) \\<in> carrier_mat d d\n 2. positive (tensor_P post (1\\<^sub>m K))\n 3. tensor_P post (1\\<^sub>m K) \\<le>\\<^sub>L 1\\<^sub>m d", "show \"tensor_P post (1\\<^sub>m K) \\<in> carrier_mat d d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tensor_P post (1\\<^sub>m K) \\<in> carrier_mat d d", "using tensor_P_dim"], ["proof (prove)\nusing this:\n  tensor_P ?A ?B \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. tensor_P post (1\\<^sub>m K) \\<in> carrier_mat d d", "by auto"], ["proof (state)\nthis:\n  tensor_P post (1\\<^sub>m K) \\<in> carrier_mat d d\n\ngoal (2 subgoals):\n 1. positive (tensor_P post (1\\<^sub>m K))\n 2. tensor_P post (1\\<^sub>m K) \\<le>\\<^sub>L 1\\<^sub>m d", "show \"positive (tensor_P post (1\\<^sub>m K))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. positive (tensor_P post (1\\<^sub>m K))", "unfolding ps2_P.ptensor_mat_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. positive (ps_P.tensor_mat post (1\\<^sub>m K))", "apply (subst ps_P.tensor_mat_positive)"], ["proof (prove)\ngoal (5 subgoals):\n 1. post \\<in> carrier_mat ps_P.d1 ps_P.d1\n 2. 1\\<^sub>m K \\<in> carrier_mat ps_P.d2 ps_P.d2\n 3. positive post\n 4. positive (1\\<^sub>m K)\n 5. True", "by (auto simp add: ps_P_d1 ps_P_d2 post_dim positive_post positive_one)"], ["proof (state)\nthis:\n  positive (tensor_P post (1\\<^sub>m K))\n\ngoal (1 subgoal):\n 1. tensor_P post (1\\<^sub>m K) \\<le>\\<^sub>L 1\\<^sub>m d", "show \"tensor_P post (1\\<^sub>m K) \\<le>\\<^sub>L 1\\<^sub>m d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tensor_P post (1\\<^sub>m K) \\<le>\\<^sub>L 1\\<^sub>m d", "unfolding ps_P.tensor_mat_id[symmetric, unfolded ps_P_d ps_P_d1 ps_P_d2]"], ["proof (prove)\ngoal (1 subgoal):\n 1. tensor_P post (1\\<^sub>m K) \\<le>\\<^sub>L\n    ps_P.tensor_mat (1\\<^sub>m N) (1\\<^sub>m K)", "unfolding ps2_P.ptensor_mat_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ps_P.tensor_mat post (1\\<^sub>m K) \\<le>\\<^sub>L\n    ps_P.tensor_mat (1\\<^sub>m N) (1\\<^sub>m K)", "apply (subst ps_P.tensor_mat_positive_le)"], ["proof (prove)\ngoal (7 subgoals):\n 1. post \\<in> carrier_mat ps_P.d1 ps_P.d1\n 2. 1\\<^sub>m K \\<in> carrier_mat ps_P.d2 ps_P.d2\n 3. positive post\n 4. positive (1\\<^sub>m K)\n 5. post \\<le>\\<^sub>L 1\\<^sub>m N\n 6. 1\\<^sub>m K \\<le>\\<^sub>L 1\\<^sub>m K\n 7. True", "unfolding ps_P_d1 ps_P_d2"], ["proof (prove)\ngoal (7 subgoals):\n 1. post \\<in> carrier_mat N N\n 2. 1\\<^sub>m K \\<in> carrier_mat K K\n 3. positive post\n 4. positive (1\\<^sub>m K)\n 5. post \\<le>\\<^sub>L 1\\<^sub>m N\n 6. 1\\<^sub>m K \\<le>\\<^sub>L 1\\<^sub>m K\n 7. True", "using post_dim positive_post positive_one post_le_one lowner_le_refl[of \"1\\<^sub>m K\" K]"], ["proof (prove)\nusing this:\n  post \\<in> carrier_mat N N\n  positive post\n  positive (1\\<^sub>m ?n)\n  post \\<le>\\<^sub>L 1\\<^sub>m N\n  1\\<^sub>m K \\<in> carrier_mat K K \\<Longrightarrow>\n  1\\<^sub>m K \\<le>\\<^sub>L 1\\<^sub>m K\n\ngoal (7 subgoals):\n 1. post \\<in> carrier_mat N N\n 2. 1\\<^sub>m K \\<in> carrier_mat K K\n 3. positive post\n 4. positive (1\\<^sub>m K)\n 5. post \\<le>\\<^sub>L 1\\<^sub>m N\n 6. 1\\<^sub>m K \\<le>\\<^sub>L 1\\<^sub>m K\n 7. True", "by auto"], ["proof (state)\nthis:\n  tensor_P post (1\\<^sub>m K) \\<le>\\<^sub>L 1\\<^sub>m d\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma hoare_triple_if:\n  \"\\<turnstile>\\<^sub>p \n   {tensor_P post (1\\<^sub>m K)} \n   Measure_P vars1 N testN (replicate N SKIP)\n   {tensor_P post (1\\<^sub>m K)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>p {tensor_P post (1\\<^sub>m K)}\n                         Measure_P vars1 N testN (replicate N SKIP)\n                         {tensor_P post (1\\<^sub>m K)}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>p {tensor_P post (1\\<^sub>m K)}\n                         Measure_P vars1 N testN (replicate N SKIP)\n                         {tensor_P post (1\\<^sub>m K)}", "define M where \"M = (\\<lambda>n. mat_extension dims vars1 (testN n))\""], ["proof (state)\nthis:\n  M = (\\<lambda>n. mat_extension dims vars1 (testN n))\n\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>p {tensor_P post (1\\<^sub>m K)}\n                         Measure_P vars1 N testN (replicate N SKIP)\n                         {tensor_P post (1\\<^sub>m K)}", "define Post where \"Post = (\\<lambda>(k::nat). tensor_P post (1\\<^sub>m K))\""], ["proof (state)\nthis:\n  Post = (\\<lambda>k. tensor_P post (1\\<^sub>m K))\n\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>p {tensor_P post (1\\<^sub>m K)}\n                         Measure_P vars1 N testN (replicate N SKIP)\n                         {tensor_P post (1\\<^sub>m K)}", "have M: \"M = (\\<lambda>n. tensor_P (testN n) (1\\<^sub>m K))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M = (\\<lambda>n. tensor_P (testN n) (1\\<^sub>m K))", "unfolding M_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n. mat_extension dims vars1 (testN n)) =\n    (\\<lambda>n. tensor_P (testN n) (1\\<^sub>m K))", "using mat_ext_vars1"], ["proof (prove)\nusing this:\n  mat_extension dims vars1 ?A = tensor_P ?A (1\\<^sub>m K)\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. mat_extension dims vars1 (testN n)) =\n    (\\<lambda>n. tensor_P (testN n) (1\\<^sub>m K))", "by auto"], ["proof (state)\nthis:\n  M = (\\<lambda>n. tensor_P (testN n) (1\\<^sub>m K))\n\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>p {tensor_P post (1\\<^sub>m K)}\n                         Measure_P vars1 N testN (replicate N SKIP)\n                         {tensor_P post (1\\<^sub>m K)}", "have skip: \"\\<And>k. k < N \\<Longrightarrow> (replicate N SKIP) ! k = SKIP\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>k. k < N \\<Longrightarrow> replicate N SKIP ! k = SKIP", "by simp"], ["proof (state)\nthis:\n  ?k2 < N \\<Longrightarrow> replicate N SKIP ! ?k2 = SKIP\n\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>p {tensor_P post (1\\<^sub>m K)}\n                         Measure_P vars1 N testN (replicate N SKIP)\n                         {tensor_P post (1\\<^sub>m K)}", "have h: \"\\<And>k. k < N \\<Longrightarrow> \\<turnstile>\\<^sub>p {Post k} replicate N SKIP ! k {tensor_P post (1\\<^sub>m K)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>k.\n       k < N \\<Longrightarrow>\n       \\<turnstile>\\<^sub>p {Post k} replicate N SKIP ! k\n                            {tensor_P post (1\\<^sub>m K)}", "unfolding Post_def skip"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>k.\n       k < N \\<Longrightarrow>\n       \\<turnstile>\\<^sub>p {tensor_P post (1\\<^sub>m K)} SKIP\n                            {tensor_P post (1\\<^sub>m K)}", "using qp_post hoare_partial.intros"], ["proof (prove)\nusing this:\n  is_quantum_predicate (tensor_P post (1\\<^sub>m K))\n  is_quantum_predicate ?P \\<Longrightarrow>\n  \\<turnstile>\\<^sub>p {?P} SKIP {?P}\n  is_quantum_predicate ?P \\<Longrightarrow>\n  \\<turnstile>\\<^sub>p {adjoint ?U * ?P * ?U} Utrans ?U {?P}\n  \\<lbrakk>is_quantum_predicate ?P; is_quantum_predicate ?Q;\n   is_quantum_predicate ?R; \\<turnstile>\\<^sub>p {?P} ?S1.0 {?Q};\n   \\<turnstile>\\<^sub>p {?Q} ?S2.0 {?R}\\<rbrakk>\n  \\<Longrightarrow> \\<turnstile>\\<^sub>p {?P} ?S1.0;; ?S2.0 {?R}\n  \\<lbrakk>\\<And>k. k < ?n \\<Longrightarrow> is_quantum_predicate (?P k);\n   is_quantum_predicate ?Q;\n   \\<And>k.\n      k < ?n \\<Longrightarrow>\n      \\<turnstile>\\<^sub>p {?P k} ?S ! k {?Q}\\<rbrakk>\n  \\<Longrightarrow> \\<turnstile>\\<^sub>p {matrix_sum d\n     (\\<lambda>k. adjoint (?M k) * ?P k * ?M k) ?n}\n   Measure ?n ?M ?S {?Q}\n  \\<lbrakk>is_quantum_predicate ?P; is_quantum_predicate ?Q;\n   \\<turnstile>\\<^sub>p {?Q} ?S\n                        {adjoint (?M 0) * ?P * ?M 0 +\n                         adjoint (?M 1) * ?Q * ?M 1}\\<rbrakk>\n  \\<Longrightarrow> \\<turnstile>\\<^sub>p {adjoint (?M 0) * ?P * ?M 0 +\n    adjoint (?M 1) * ?Q * ?M 1}\n   While ?M ?S {?P}\n  \\<lbrakk>is_quantum_predicate ?P; is_quantum_predicate ?Q;\n   is_quantum_predicate ?P'; is_quantum_predicate ?Q'; ?P \\<le>\\<^sub>L ?P';\n   \\<turnstile>\\<^sub>p {?P'} ?S {?Q'}; ?Q' \\<le>\\<^sub>L ?Q\\<rbrakk>\n  \\<Longrightarrow> \\<turnstile>\\<^sub>p {?P} ?S {?Q}\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       k < N \\<Longrightarrow>\n       \\<turnstile>\\<^sub>p {tensor_P post (1\\<^sub>m K)} SKIP\n                            {tensor_P post (1\\<^sub>m K)}", "by auto"], ["proof (state)\nthis:\n  ?k2 < N \\<Longrightarrow>\n  \\<turnstile>\\<^sub>p {Post ?k2} replicate N SKIP ! ?k2\n                       {tensor_P post (1\\<^sub>m K)}\n\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>p {tensor_P post (1\\<^sub>m K)}\n                         Measure_P vars1 N testN (replicate N SKIP)\n                         {tensor_P post (1\\<^sub>m K)}", "moreover"], ["proof (state)\nthis:\n  ?k2 < N \\<Longrightarrow>\n  \\<turnstile>\\<^sub>p {Post ?k2} replicate N SKIP ! ?k2\n                       {tensor_P post (1\\<^sub>m K)}\n\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>p {tensor_P post (1\\<^sub>m K)}\n                         Measure_P vars1 N testN (replicate N SKIP)\n                         {tensor_P post (1\\<^sub>m K)}", "have \"\\<And>k. k < N \\<Longrightarrow> is_quantum_predicate (Post k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>k. k < N \\<Longrightarrow> is_quantum_predicate (Post k)", "unfolding Post_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>k.\n       k < N \\<Longrightarrow>\n       is_quantum_predicate (tensor_P post (1\\<^sub>m K))", "using qp_post"], ["proof (prove)\nusing this:\n  is_quantum_predicate (tensor_P post (1\\<^sub>m K))\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       k < N \\<Longrightarrow>\n       is_quantum_predicate (tensor_P post (1\\<^sub>m K))", "by auto"], ["proof (state)\nthis:\n  ?k2 < N \\<Longrightarrow> is_quantum_predicate (Post ?k2)\n\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>p {tensor_P post (1\\<^sub>m K)}\n                         Measure_P vars1 N testN (replicate N SKIP)\n                         {tensor_P post (1\\<^sub>m K)}", "ultimately"], ["proof (chain)\npicking this:\n  ?k2 < N \\<Longrightarrow>\n  \\<turnstile>\\<^sub>p {Post ?k2} replicate N SKIP ! ?k2\n                       {tensor_P post (1\\<^sub>m K)}\n  ?k2 < N \\<Longrightarrow> is_quantum_predicate (Post ?k2)", "show ?thesis"], ["proof (prove)\nusing this:\n  ?k2 < N \\<Longrightarrow>\n  \\<turnstile>\\<^sub>p {Post ?k2} replicate N SKIP ! ?k2\n                       {tensor_P post (1\\<^sub>m K)}\n  ?k2 < N \\<Longrightarrow> is_quantum_predicate (Post ?k2)\n\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>p {tensor_P post (1\\<^sub>m K)}\n                         Measure_P vars1 N testN (replicate N SKIP)\n                         {tensor_P post (1\\<^sub>m K)}", "unfolding Measure_P_def"], ["proof (prove)\nusing this:\n  ?k2 < N \\<Longrightarrow>\n  \\<turnstile>\\<^sub>p {Post ?k2} replicate N SKIP ! ?k2\n                       {tensor_P post (1\\<^sub>m K)}\n  ?k2 < N \\<Longrightarrow> is_quantum_predicate (Post ?k2)\n\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>p {tensor_P post (1\\<^sub>m K)}\n                         Measure N\n                          (\\<lambda>n. mat_extension dims vars1 (testN n))\n                          (replicate N SKIP)\n                         {tensor_P post (1\\<^sub>m K)}", "apply (fold M_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>k.\n                k < N \\<Longrightarrow>\n                \\<turnstile>\\<^sub>p {Post k} replicate N SKIP ! k\n                                     {tensor_P post (1\\<^sub>m K)};\n     \\<And>k. k < N \\<Longrightarrow> is_quantum_predicate (Post k)\\<rbrakk>\n    \\<Longrightarrow> \\<turnstile>\\<^sub>p {tensor_P post (1\\<^sub>m K)}\n     Measure N M (replicate N SKIP) {tensor_P post (1\\<^sub>m K)}", "using hoare_partial.intros(4)[of N Post \"tensor_P post (1\\<^sub>m K)\" \"replicate N SKIP\" M]"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>k. k < N \\<Longrightarrow> is_quantum_predicate (Post k);\n   is_quantum_predicate (tensor_P post (1\\<^sub>m K));\n   \\<And>k.\n      k < N \\<Longrightarrow>\n      \\<turnstile>\\<^sub>p {Post k} replicate N SKIP ! k\n                           {tensor_P post (1\\<^sub>m K)}\\<rbrakk>\n  \\<Longrightarrow> \\<turnstile>\\<^sub>p {matrix_sum d\n     (\\<lambda>k. adjoint (M k) * Post k * M k) N}\n   Measure N M (replicate N SKIP) {tensor_P post (1\\<^sub>m K)}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>k.\n                k < N \\<Longrightarrow>\n                \\<turnstile>\\<^sub>p {Post k} replicate N SKIP ! k\n                                     {tensor_P post (1\\<^sub>m K)};\n     \\<And>k. k < N \\<Longrightarrow> is_quantum_predicate (Post k)\\<rbrakk>\n    \\<Longrightarrow> \\<turnstile>\\<^sub>p {tensor_P post (1\\<^sub>m K)}\n     Measure N M (replicate N SKIP) {tensor_P post (1\\<^sub>m K)}", "unfolding M Post_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>k.\n              k < N \\<Longrightarrow>\n              is_quantum_predicate (tensor_P post (1\\<^sub>m K));\n   is_quantum_predicate (tensor_P post (1\\<^sub>m K));\n   \\<And>k.\n      k < N \\<Longrightarrow>\n      \\<turnstile>\\<^sub>p {tensor_P post (1\\<^sub>m K)}\n                           replicate N SKIP ! k\n                           {tensor_P post (1\\<^sub>m K)}\\<rbrakk>\n  \\<Longrightarrow> \\<turnstile>\\<^sub>p {matrix_sum d\n     (\\<lambda>k.\n         adjoint (tensor_P (testN k) (1\\<^sub>m K)) *\n         tensor_P post (1\\<^sub>m K) *\n         tensor_P (testN k) (1\\<^sub>m K))\n     N}\n   Measure N (\\<lambda>n. tensor_P (testN n) (1\\<^sub>m K))\n    (replicate N SKIP)\n   {tensor_P post (1\\<^sub>m K)}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>k.\n                k < N \\<Longrightarrow>\n                \\<turnstile>\\<^sub>p {tensor_P post (1\\<^sub>m K)}\n                                     replicate N SKIP ! k\n                                     {tensor_P post (1\\<^sub>m K)};\n     \\<And>k.\n        k < N \\<Longrightarrow>\n        is_quantum_predicate (tensor_P post (1\\<^sub>m K))\\<rbrakk>\n    \\<Longrightarrow> \\<turnstile>\\<^sub>p {tensor_P post (1\\<^sub>m K)}\n     Measure N (\\<lambda>n. tensor_P (testN n) (1\\<^sub>m K))\n      (replicate N SKIP)\n     {tensor_P post (1\\<^sub>m K)}", "using tensor_P_testN_sum qp_post"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>k.\n              k < N \\<Longrightarrow>\n              is_quantum_predicate (tensor_P post (1\\<^sub>m K));\n   is_quantum_predicate (tensor_P post (1\\<^sub>m K));\n   \\<And>k.\n      k < N \\<Longrightarrow>\n      \\<turnstile>\\<^sub>p {tensor_P post (1\\<^sub>m K)}\n                           replicate N SKIP ! k\n                           {tensor_P post (1\\<^sub>m K)}\\<rbrakk>\n  \\<Longrightarrow> \\<turnstile>\\<^sub>p {matrix_sum d\n     (\\<lambda>k.\n         adjoint (tensor_P (testN k) (1\\<^sub>m K)) *\n         tensor_P post (1\\<^sub>m K) *\n         tensor_P (testN k) (1\\<^sub>m K))\n     N}\n   Measure N (\\<lambda>n. tensor_P (testN n) (1\\<^sub>m K))\n    (replicate N SKIP)\n   {tensor_P post (1\\<^sub>m K)}\n  matrix_sum d\n   (\\<lambda>k.\n       adjoint (tensor_P (testN k) (1\\<^sub>m K)) *\n       tensor_P post (1\\<^sub>m K) *\n       tensor_P (testN k) (1\\<^sub>m K))\n   N =\n  tensor_P post (1\\<^sub>m K)\n  is_quantum_predicate (tensor_P post (1\\<^sub>m K))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>k.\n                k < N \\<Longrightarrow>\n                \\<turnstile>\\<^sub>p {tensor_P post (1\\<^sub>m K)}\n                                     replicate N SKIP ! k\n                                     {tensor_P post (1\\<^sub>m K)};\n     \\<And>k.\n        k < N \\<Longrightarrow>\n        is_quantum_predicate (tensor_P post (1\\<^sub>m K))\\<rbrakk>\n    \\<Longrightarrow> \\<turnstile>\\<^sub>p {tensor_P post (1\\<^sub>m K)}\n     Measure N (\\<lambda>n. tensor_P (testN n) (1\\<^sub>m K))\n      (replicate N SKIP)\n     {tensor_P post (1\\<^sub>m K)}", "by auto"], ["proof (state)\nthis:\n  \\<turnstile>\\<^sub>p {tensor_P post (1\\<^sub>m K)}\n                       Measure_P vars1 N testN (replicate N SKIP)\n                       {tensor_P post (1\\<^sub>m K)}\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem grover_partial_deduct:\n  \"\\<turnstile>\\<^sub>p\n   {tensor_P pre (proj_k 0)}\n    Grover\n   {tensor_P post (1\\<^sub>m K)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>p {tensor_P pre (proj_k 0)} Grover\n                         {tensor_P post (1\\<^sub>m K)}", "unfolding Grover_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>p {tensor_P pre (proj_k 0)}\n                         hadamard_n n;; While_P vars2 M0 M1 D;;\n                         Measure_P vars1 N testN (replicate N SKIP)\n                         {tensor_P post (1\\<^sub>m K)}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>p {tensor_P pre (proj_k 0)}\n                         hadamard_n n;; While_P vars2 M0 M1 D;;\n                         Measure_P vars1 N testN (replicate N SKIP)\n                         {tensor_P post (1\\<^sub>m K)}", "have \"\\<turnstile>\\<^sub>p\n   {tensor_P pre (proj_k 0)}\n    hadamard_n n\n   {adjoint exM0 * P' * exM0 + adjoint exM1 * Q * exM1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>p {tensor_P pre (proj_k 0)} hadamard_n n\n                         {adjoint exM0 * P' * exM0 +\n                          adjoint exM1 * Q * exM1}", "using hoare_partial.intros(6)[OF qp_pre qp_D3_post qp_pre qp_init_post]\n    hoare_triple_init lowner_le_refl[OF tensor_P_dim] lowner_le_Q"], ["proof (prove)\nusing this:\n  \\<lbrakk>tensor_P pre (proj_k 0) \\<le>\\<^sub>L tensor_P pre (proj_k 0);\n   \\<turnstile>\\<^sub>p {tensor_P pre (proj_k 0)} ?S\n                        {tensor_P proj_psi (proj_k 0)};\n   tensor_P proj_psi (proj_k 0) \\<le>\\<^sub>L\n   adjoint exM0 * P' * exM0 + adjoint exM1 * Q * exM1\\<rbrakk>\n  \\<Longrightarrow> \\<turnstile>\\<^sub>p {tensor_P pre (proj_k 0)} ?S\n   {adjoint exM0 * P' * exM0 + adjoint exM1 * Q * exM1}\n  \\<turnstile>\\<^sub>p {tensor_P pre (proj_k 0)} hadamard_n n\n                       {tensor_P proj_psi (proj_k 0)}\n  tensor_P ?A1 ?B1 \\<le>\\<^sub>L tensor_P ?A1 ?B1\n  tensor_P proj_psi (proj_k 0) \\<le>\\<^sub>L\n  adjoint exM0 * P' * exM0 + adjoint exM1 * Q * exM1\n\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>p {tensor_P pre (proj_k 0)} hadamard_n n\n                         {adjoint exM0 * P' * exM0 +\n                          adjoint exM1 * Q * exM1}", "by auto"], ["proof (state)\nthis:\n  \\<turnstile>\\<^sub>p {tensor_P pre (proj_k 0)} hadamard_n n\n                       {adjoint exM0 * P' * exM0 + adjoint exM1 * Q * exM1}\n\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>p {tensor_P pre (proj_k 0)}\n                         hadamard_n n;; While_P vars2 M0 M1 D;;\n                         Measure_P vars1 N testN (replicate N SKIP)\n                         {tensor_P post (1\\<^sub>m K)}", "then"], ["proof (chain)\npicking this:\n  \\<turnstile>\\<^sub>p {tensor_P pre (proj_k 0)} hadamard_n n\n                       {adjoint exM0 * P' * exM0 + adjoint exM1 * Q * exM1}", "have \"\\<turnstile>\\<^sub>p\n   {tensor_P pre (proj_k 0)}\n    hadamard_n n;;\n    While_P vars2 M0 M1 D\n   {P'}\""], ["proof (prove)\nusing this:\n  \\<turnstile>\\<^sub>p {tensor_P pre (proj_k 0)} hadamard_n n\n                       {adjoint exM0 * P' * exM0 + adjoint exM1 * Q * exM1}\n\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>p {tensor_P pre (proj_k 0)}\n                         hadamard_n n;; While_P vars2 M0 M1 D {P'}", "using hoare_triple_while hoare_partial.intros(3) qp_pre qp_D3_post qp_P'"], ["proof (prove)\nusing this:\n  \\<turnstile>\\<^sub>p {tensor_P pre (proj_k 0)} hadamard_n n\n                       {adjoint exM0 * P' * exM0 + adjoint exM1 * Q * exM1}\n  \\<turnstile>\\<^sub>p {adjoint exM0 * P' * exM0 + adjoint exM1 * Q * exM1}\n                       While_P vars2 M0 M1 D {P'}\n  \\<lbrakk>is_quantum_predicate ?P; is_quantum_predicate ?Q;\n   is_quantum_predicate ?R; \\<turnstile>\\<^sub>p {?P} ?S1.0 {?Q};\n   \\<turnstile>\\<^sub>p {?Q} ?S2.0 {?R}\\<rbrakk>\n  \\<Longrightarrow> \\<turnstile>\\<^sub>p {?P} ?S1.0;; ?S2.0 {?R}\n  is_quantum_predicate (tensor_P pre (proj_k 0))\n  is_quantum_predicate (adjoint exM0 * P' * exM0 + adjoint exM1 * Q * exM1)\n  is_quantum_predicate P'\n\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>p {tensor_P pre (proj_k 0)}\n                         hadamard_n n;; While_P vars2 M0 M1 D {P'}", "by auto"], ["proof (state)\nthis:\n  \\<turnstile>\\<^sub>p {tensor_P pre (proj_k 0)}\n                       hadamard_n n;; While_P vars2 M0 M1 D {P'}\n\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>p {tensor_P pre (proj_k 0)}\n                         hadamard_n n;; While_P vars2 M0 M1 D;;\n                         Measure_P vars1 N testN (replicate N SKIP)\n                         {tensor_P post (1\\<^sub>m K)}", "then"], ["proof (chain)\npicking this:\n  \\<turnstile>\\<^sub>p {tensor_P pre (proj_k 0)}\n                       hadamard_n n;; While_P vars2 M0 M1 D {P'}", "have \"\\<turnstile>\\<^sub>p\n   {tensor_P pre (proj_k 0)}\n    hadamard_n n;;\n    While_P vars2 M0 M1 D\n   {tensor_P post (1\\<^sub>m K)}\""], ["proof (prove)\nusing this:\n  \\<turnstile>\\<^sub>p {tensor_P pre (proj_k 0)}\n                       hadamard_n n;; While_P vars2 M0 M1 D {P'}\n\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>p {tensor_P pre (proj_k 0)}\n                         hadamard_n n;; While_P vars2 M0 M1 D\n                         {tensor_P post (1\\<^sub>m K)}", "using lowner_le_P' hoare_partial.intros(6)[OF qp_pre qp_post qp_pre qp_P'] \n      lowner_le_P' lowner_le_refl[OF tensor_P_dim]"], ["proof (prove)\nusing this:\n  \\<turnstile>\\<^sub>p {tensor_P pre (proj_k 0)}\n                       hadamard_n n;; While_P vars2 M0 M1 D {P'}\n  P' \\<le>\\<^sub>L tensor_P post (1\\<^sub>m K)\n  \\<lbrakk>tensor_P pre (proj_k 0) \\<le>\\<^sub>L tensor_P pre (proj_k 0);\n   \\<turnstile>\\<^sub>p {tensor_P pre (proj_k 0)} ?S {P'};\n   P' \\<le>\\<^sub>L tensor_P post (1\\<^sub>m K)\\<rbrakk>\n  \\<Longrightarrow> \\<turnstile>\\<^sub>p {tensor_P pre (proj_k 0)} ?S\n   {tensor_P post (1\\<^sub>m K)}\n  P' \\<le>\\<^sub>L tensor_P post (1\\<^sub>m K)\n  tensor_P ?A1 ?B1 \\<le>\\<^sub>L tensor_P ?A1 ?B1\n\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>p {tensor_P pre (proj_k 0)}\n                         hadamard_n n;; While_P vars2 M0 M1 D\n                         {tensor_P post (1\\<^sub>m K)}", "by auto"], ["proof (state)\nthis:\n  \\<turnstile>\\<^sub>p {tensor_P pre (proj_k 0)}\n                       hadamard_n n;; While_P vars2 M0 M1 D\n                       {tensor_P post (1\\<^sub>m K)}\n\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>p {tensor_P pre (proj_k 0)}\n                         hadamard_n n;; While_P vars2 M0 M1 D;;\n                         Measure_P vars1 N testN (replicate N SKIP)\n                         {tensor_P post (1\\<^sub>m K)}", "then"], ["proof (chain)\npicking this:\n  \\<turnstile>\\<^sub>p {tensor_P pre (proj_k 0)}\n                       hadamard_n n;; While_P vars2 M0 M1 D\n                       {tensor_P post (1\\<^sub>m K)}", "show \" \\<turnstile>\\<^sub>p\n   {tensor_P pre (proj_k 0)}\n    hadamard_n n;;\n    While_P vars2 M0 M1 D;;\n    Measure_P vars1 N testN (replicate N SKIP)\n   {tensor_P post (1\\<^sub>m K)}\""], ["proof (prove)\nusing this:\n  \\<turnstile>\\<^sub>p {tensor_P pre (proj_k 0)}\n                       hadamard_n n;; While_P vars2 M0 M1 D\n                       {tensor_P post (1\\<^sub>m K)}\n\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>p {tensor_P pre (proj_k 0)}\n                         hadamard_n n;; While_P vars2 M0 M1 D;;\n                         Measure_P vars1 N testN (replicate N SKIP)\n                         {tensor_P post (1\\<^sub>m K)}", "using hoare_triple_if qp_pre qp_post hoare_partial.intros(3)"], ["proof (prove)\nusing this:\n  \\<turnstile>\\<^sub>p {tensor_P pre (proj_k 0)}\n                       hadamard_n n;; While_P vars2 M0 M1 D\n                       {tensor_P post (1\\<^sub>m K)}\n  \\<turnstile>\\<^sub>p {tensor_P post (1\\<^sub>m K)}\n                       Measure_P vars1 N testN (replicate N SKIP)\n                       {tensor_P post (1\\<^sub>m K)}\n  is_quantum_predicate (tensor_P pre (proj_k 0))\n  is_quantum_predicate (tensor_P post (1\\<^sub>m K))\n  \\<lbrakk>is_quantum_predicate ?P; is_quantum_predicate ?Q;\n   is_quantum_predicate ?R; \\<turnstile>\\<^sub>p {?P} ?S1.0 {?Q};\n   \\<turnstile>\\<^sub>p {?Q} ?S2.0 {?R}\\<rbrakk>\n  \\<Longrightarrow> \\<turnstile>\\<^sub>p {?P} ?S1.0;; ?S2.0 {?R}\n\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>p {tensor_P pre (proj_k 0)}\n                         hadamard_n n;; While_P vars2 M0 M1 D;;\n                         Measure_P vars1 N testN (replicate N SKIP)\n                         {tensor_P post (1\\<^sub>m K)}", "by auto"], ["proof (state)\nthis:\n  \\<turnstile>\\<^sub>p {tensor_P pre (proj_k 0)}\n                       hadamard_n n;; While_P vars2 M0 M1 D;;\n                       Measure_P vars1 N testN (replicate N SKIP)\n                       {tensor_P post (1\\<^sub>m K)}\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem grover_partial_correct:\n  \"\\<Turnstile>\\<^sub>p\n   {tensor_P pre (proj_k 0)}\n    Grover\n   {tensor_P post (1\\<^sub>m K)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Turnstile>\\<^sub>p {tensor_P pre (proj_k 0)} Grover\n    {tensor_P post (1\\<^sub>m K)}", "using grover_partial_deduct well_com_Grover qp_pre qp_post hoare_partial_sound"], ["proof (prove)\nusing this:\n  \\<turnstile>\\<^sub>p {tensor_P pre (proj_k 0)} Grover\n                       {tensor_P post (1\\<^sub>m K)}\n  well_com Grover\n  is_quantum_predicate (tensor_P pre (proj_k 0))\n  is_quantum_predicate (tensor_P post (1\\<^sub>m K))\n  \\<lbrakk>\\<turnstile>\\<^sub>p {?P} ?S {?Q}; well_com ?S\\<rbrakk>\n  \\<Longrightarrow> \\<Turnstile>\\<^sub>p {?P} ?S {?Q}\n\ngoal (1 subgoal):\n 1. \\<Turnstile>\\<^sub>p {tensor_P pre (proj_k 0)} Grover\n    {tensor_P post (1\\<^sub>m K)}", "by auto"], ["", "end"], ["", "end"]]}