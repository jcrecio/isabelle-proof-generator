{"file_name": "/home/qj213/afp-2021-10-22/thys/QHLProver/Quantum_Hoare.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/QHLProver", "problem_names": ["lemma denote_density_states:\n  \"\\<rho> \\<in> density_states \\<Longrightarrow> well_com S \\<Longrightarrow> denote S \\<rho> \\<in> density_states\"", "lemma trace_measurement2:\n  assumes m: \"measurement n 2 M\" and dA: \"A \\<in> carrier_mat n n\"\n  shows \"trace ((M 0) * A * adjoint (M 0)) + trace ((M 1) * A * adjoint (M 1)) = trace A\"", "lemma qp_close_under_unitary_operator:\n  fixes U P :: \"complex mat\"\n  assumes dU: \"U \\<in> carrier_mat d d\"\n    and u: \"unitary U\"\n    and qp: \"is_quantum_predicate P\"\n  shows \"is_quantum_predicate (adjoint U * P * U)\"", "lemma qps_after_measure_is_qp:\n  assumes m: \"measurement d n M \" and qpk: \"\\<And>k. k < n \\<Longrightarrow> is_quantum_predicate (P k)\"\n  shows \"is_quantum_predicate (matrix_sum d (\\<lambda>k. adjoint (M k) * P k  * M k) n)\"", "lemma total_implies_partial:\n  assumes S: \"well_com S\"\n    and total: \"\\<Turnstile>\\<^sub>t {P} S {Q}\"\n  shows \"\\<Turnstile>\\<^sub>p {P} S {Q}\"", "lemma predicate_prob_positive:\n  assumes \"0\\<^sub>m d d \\<le>\\<^sub>L P\"\n    and \"\\<rho> \\<in> density_states\"\n  shows \"0 \\<le> trace (P * \\<rho>)\"", "lemma total_pre_zero:\n  assumes S: \"well_com S\"\n    and Q: \"is_quantum_predicate Q\"\n  shows \"\\<Turnstile>\\<^sub>t {0\\<^sub>m d d} S {Q}\"", "lemma partial_post_identity:\n  assumes S: \"well_com S\"\n    and P: \"is_quantum_predicate P\"\n  shows \"\\<Turnstile>\\<^sub>p {P} S {1\\<^sub>m d}\"", "lemma measurement2_leq_one_mat:\n  assumes dP: \"P \\<in> carrier_mat d d\" and dQ: \"Q \\<in> carrier_mat d d\"\n    and leP: \"P \\<le>\\<^sub>L 1\\<^sub>m d\" and leQ: \"Q \\<le>\\<^sub>L 1\\<^sub>m d\" and m: \"measurement d 2 M\"\n  shows \"(adjoint (M 0) * P * (M 0) + adjoint (M 1) * Q * (M 1)) \\<le>\\<^sub>L 1\\<^sub>m d\"", "lemma wlp_while_n_close:\n  assumes close: \"\\<And>P. is_quantum_predicate P \\<Longrightarrow> is_quantum_predicate (WS P)\"\n    and m: \"measurement d 2 M\" and qpP: \"is_quantum_predicate P\"\n  shows \"is_quantum_predicate (wlp_while_n (M 0) (M 1) WS k P)\"", "lemma wlp_while_n_mono:\n  assumes \"\\<And>P. is_quantum_predicate P \\<Longrightarrow> is_quantum_predicate (WS P)\"\n    and \"\\<And>P Q. is_quantum_predicate P \\<Longrightarrow> is_quantum_predicate Q \\<Longrightarrow> P \\<le>\\<^sub>L Q \\<Longrightarrow> WS P \\<le>\\<^sub>L WS Q\"\n    and \"measurement d 2 M\"\n    and \"is_quantum_predicate P\"\n    and \"is_quantum_predicate Q\"\n    and \"P \\<le>\\<^sub>L Q\"\n  shows \"(wlp_while_n (M 0) (M 1) WS k P) \\<le>\\<^sub>L (wlp_while_n (M 0) (M 1) WS k Q)\"", "lemma wlp_while_exists:\n  assumes \"\\<And>P. is_quantum_predicate P \\<Longrightarrow> is_quantum_predicate (WS P)\"\n    and \"\\<And>P Q. is_quantum_predicate P \\<Longrightarrow> is_quantum_predicate Q \\<Longrightarrow> P \\<le>\\<^sub>L Q \\<Longrightarrow> WS P \\<le>\\<^sub>L WS Q\"\n    and m: \"measurement d 2 M\"\n    and qpP: \"is_quantum_predicate P\"\n  shows \"is_quantum_predicate (wlp_while (M 0) (M 1) WS P) \n    \\<and> (\\<forall>n. (wlp_while (M 0) (M 1) WS P) \\<le>\\<^sub>L (wlp_while_n (M 0) (M 1) WS n P))\n    \\<and> (\\<forall>W'. (\\<forall>n. W' \\<le>\\<^sub>L (wlp_while_n (M 0) (M 1) WS n P)) \\<longrightarrow> W' \\<le>\\<^sub>L (wlp_while (M 0) (M 1) WS P))\n    \\<and> limit_mat (\\<lambda>n. wlp_while_n (M 0) (M 1) WS n P) (wlp_while (M 0) (M 1) WS P) d\"", "lemma wlp_while_mono:\n  assumes \"\\<And>P. is_quantum_predicate P \\<Longrightarrow> is_quantum_predicate (WS P)\"\n    and \"\\<And>P Q. is_quantum_predicate P \\<Longrightarrow> is_quantum_predicate Q \\<Longrightarrow> P \\<le>\\<^sub>L Q \\<Longrightarrow> WS P \\<le>\\<^sub>L WS Q\"\n    and \"measurement d 2 M\"\n    and \"is_quantum_predicate P\"\n    and \"is_quantum_predicate Q\"\n    and \"P \\<le>\\<^sub>L Q\"\n  shows \"wlp_while (M 0) (M 1) WS P \\<le>\\<^sub>L wlp_while (M 0) (M 1) WS Q\"", "lemma wlp_measure_expand_m:\n  assumes m: \"m \\<le> n\" and wc: \"well_com (Measure n M S)\"  \n  shows \"wlp (Measure m M S) P = matrix_sum d (\\<lambda>k. adjoint (M k) * (wlp (S!k) P) * (M k)) m\"", "lemma wlp_measure_expand:\n  assumes wc: \"well_com (Measure n M S)\"  \n  shows \"wlp (Measure n M S) P = matrix_sum d (\\<lambda>k. adjoint (M k) * (wlp (S!k) P) * (M k)) n\"", "lemma wlp_mono_and_close:\n  shows \"well_com S \\<Longrightarrow> is_quantum_predicate P \\<Longrightarrow> is_quantum_predicate Q \\<Longrightarrow> P \\<le>\\<^sub>L Q \n        \\<Longrightarrow> is_quantum_predicate (wlp S P) \\<and> wlp S P \\<le>\\<^sub>L wlp S Q\"", "lemma wlp_close:\n  assumes wc: \"well_com S\" and qp: \"is_quantum_predicate P\"\n  shows \"is_quantum_predicate (wlp S P)\"", "lemma wlp_soundness:\n  \"well_com S \\<Longrightarrow> \n    (\\<And>P. (is_quantum_predicate P \\<Longrightarrow> \n      (\\<forall>\\<rho> \\<in> density_states. trace (wlp S P * \\<rho>) = trace (P * (denote S \\<rho>)) + trace \\<rho> - trace (denote S \\<rho>))))\"", "lemma denote_while_split:\n  assumes wc: \"well_com (While M S)\" and dsr: \"\\<rho> \\<in> density_states\"\n  shows \"denote (While M S) \\<rho> = (M 0) * \\<rho> * adjoint (M 0) + denote (While M S) (denote S (M 1 * \\<rho> * adjoint (M 1)))\"", "lemma wlp_while_split:\n  assumes wc: \"well_com (While M S)\" and qpP: \"is_quantum_predicate P\"\n  shows \"wlp (While M S) P = adjoint (M 0) * P * (M 0) + adjoint (M 1) * (wlp S (wlp (While M S) P)) * (M 1)\"", "lemma wlp_is_weakest_liberal_precondition:\n  assumes \"well_com S\" and \"is_quantum_predicate P\"\n  shows \"is_weakest_liberal_precondition (wlp S P) S P\"", "theorem hoare_partial_sound:\n  \"\\<turnstile>\\<^sub>p {P} S {Q} \\<Longrightarrow> well_com S \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P} S {Q}\"", "lemma wlp_complete:\n  \"well_com S \\<Longrightarrow> is_quantum_predicate P \\<Longrightarrow> \\<turnstile>\\<^sub>p {wlp S P} S {P}\"", "theorem hoare_partial_complete:\n  \"\\<Turnstile>\\<^sub>p {P} S {Q} \\<Longrightarrow> well_com S \\<Longrightarrow> is_quantum_predicate P \\<Longrightarrow> is_quantum_predicate Q \\<Longrightarrow> \\<turnstile>\\<^sub>p {P} S {Q}\"", "lemma hoare_patial_seq_assoc_sem:\n  shows \"\\<Turnstile>\\<^sub>p {A} (S1 ;; S2) ;; S3 {B} \\<longleftrightarrow> \\<Turnstile>\\<^sub>p {A} S1 ;; (S2 ;; S3) {B}\"", "lemma hoare_patial_seq_assoc:\n  assumes \"well_com S1\" and \"well_com S2\" and \"well_com S3\"\n    and \"is_quantum_predicate A\" and \"is_quantum_predicate B\"\n  shows \"\\<turnstile>\\<^sub>p {A} (S1 ;; S2) ;; S3 {B} \\<longleftrightarrow> \\<turnstile>\\<^sub>p {A} S1 ;; (S2 ;; S3) {B}\""], "translations": [["", "lemma denote_density_states:\n  \"\\<rho> \\<in> density_states \\<Longrightarrow> well_com S \\<Longrightarrow> denote S \\<rho> \\<in> density_states\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<rho> \\<in> density_states; well_com S\\<rbrakk>\n    \\<Longrightarrow> denote S \\<rho> \\<in> density_states", "by (simp add: denote_dim_pdo density_states_def)"], ["", "definition is_quantum_predicate :: \"complex mat \\<Rightarrow> bool\" where\n  \"is_quantum_predicate P \\<longleftrightarrow> P \\<in> carrier_mat d d \\<and> positive P \\<and> P \\<le>\\<^sub>L 1\\<^sub>m d\""], ["", "lemma trace_measurement2:\n  assumes m: \"measurement n 2 M\" and dA: \"A \\<in> carrier_mat n n\"\n  shows \"trace ((M 0) * A * adjoint (M 0)) + trace ((M 1) * A * adjoint (M 1)) = trace A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace (M 0 * A * adjoint (M 0)) + trace (M 1 * A * adjoint (M 1)) =\n    trace A", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. trace (M 0 * A * adjoint (M 0)) + trace (M 1 * A * adjoint (M 1)) =\n    trace A", "from m"], ["proof (chain)\npicking this:\n  measurement n 2 M", "have dM0: \"M 0 \\<in> carrier_mat n n\" and dM1: \"M 1 \\<in> carrier_mat n n\" and id: \"adjoint (M 0) * (M 0) + adjoint (M 1) * (M 1) = 1\\<^sub>m n\""], ["proof (prove)\nusing this:\n  measurement n 2 M\n\ngoal (1 subgoal):\n 1. M 0 \\<in> carrier_mat n n &&&\n    M 1 \\<in> carrier_mat n n &&&\n    adjoint (M 0) * M 0 + adjoint (M 1) * M 1 = 1\\<^sub>m n", "using measurement_def measurement_id2"], ["proof (prove)\nusing this:\n  measurement n 2 M\n  measurement ?d ?n ?M =\n  ((\\<forall>j<?n. ?M j \\<in> carrier_mat ?d ?d) \\<and>\n   matrix_sum ?d (\\<lambda>j. adjoint (?M j) * ?M j) ?n = 1\\<^sub>m ?d)\n  measurement ?d 2 ?M \\<Longrightarrow>\n  adjoint (?M 0) * ?M 0 + adjoint (?M 1) * ?M 1 = 1\\<^sub>m ?d\n\ngoal (1 subgoal):\n 1. M 0 \\<in> carrier_mat n n &&&\n    M 1 \\<in> carrier_mat n n &&&\n    adjoint (M 0) * M 0 + adjoint (M 1) * M 1 = 1\\<^sub>m n", "by auto"], ["proof (state)\nthis:\n  M 0 \\<in> carrier_mat n n\n  M 1 \\<in> carrier_mat n n\n  adjoint (M 0) * M 0 + adjoint (M 1) * M 1 = 1\\<^sub>m n\n\ngoal (1 subgoal):\n 1. trace (M 0 * A * adjoint (M 0)) + trace (M 1 * A * adjoint (M 1)) =\n    trace A", "have \"trace (M 1 * A * adjoint (M 1)) + trace (M 0 * A * adjoint (M 0))\n    = trace ((adjoint (M 0) * M 0 + adjoint (M 1) * M 1) * A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace (M 1 * A * adjoint (M 1)) + trace (M 0 * A * adjoint (M 0)) =\n    trace ((adjoint (M 0) * M 0 + adjoint (M 1) * M 1) * A)", "using dM0 dM1 dA"], ["proof (prove)\nusing this:\n  M 0 \\<in> carrier_mat n n\n  M 1 \\<in> carrier_mat n n\n  A \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. trace (M 1 * A * adjoint (M 1)) + trace (M 0 * A * adjoint (M 0)) =\n    trace ((adjoint (M 0) * M 0 + adjoint (M 1) * M 1) * A)", "by (mat_assoc n)"], ["proof (state)\nthis:\n  trace (M 1 * A * adjoint (M 1)) + trace (M 0 * A * adjoint (M 0)) =\n  trace ((adjoint (M 0) * M 0 + adjoint (M 1) * M 1) * A)\n\ngoal (1 subgoal):\n 1. trace (M 0 * A * adjoint (M 0)) + trace (M 1 * A * adjoint (M 1)) =\n    trace A", "also"], ["proof (state)\nthis:\n  trace (M 1 * A * adjoint (M 1)) + trace (M 0 * A * adjoint (M 0)) =\n  trace ((adjoint (M 0) * M 0 + adjoint (M 1) * M 1) * A)\n\ngoal (1 subgoal):\n 1. trace (M 0 * A * adjoint (M 0)) + trace (M 1 * A * adjoint (M 1)) =\n    trace A", "have \"\\<dots> = trace (1\\<^sub>m n * A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace ((adjoint (M 0) * M 0 + adjoint (M 1) * M 1) * A) =\n    trace (1\\<^sub>m n * A)", "using id"], ["proof (prove)\nusing this:\n  adjoint (M 0) * M 0 + adjoint (M 1) * M 1 = 1\\<^sub>m n\n\ngoal (1 subgoal):\n 1. trace ((adjoint (M 0) * M 0 + adjoint (M 1) * M 1) * A) =\n    trace (1\\<^sub>m n * A)", "by auto"], ["proof (state)\nthis:\n  trace ((adjoint (M 0) * M 0 + adjoint (M 1) * M 1) * A) =\n  trace (1\\<^sub>m n * A)\n\ngoal (1 subgoal):\n 1. trace (M 0 * A * adjoint (M 0)) + trace (M 1 * A * adjoint (M 1)) =\n    trace A", "also"], ["proof (state)\nthis:\n  trace ((adjoint (M 0) * M 0 + adjoint (M 1) * M 1) * A) =\n  trace (1\\<^sub>m n * A)\n\ngoal (1 subgoal):\n 1. trace (M 0 * A * adjoint (M 0)) + trace (M 1 * A * adjoint (M 1)) =\n    trace A", "have \"\\<dots> = trace A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace (1\\<^sub>m n * A) = trace A", "using dA"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. trace (1\\<^sub>m n * A) = trace A", "by auto"], ["proof (state)\nthis:\n  trace (1\\<^sub>m n * A) = trace A\n\ngoal (1 subgoal):\n 1. trace (M 0 * A * adjoint (M 0)) + trace (M 1 * A * adjoint (M 1)) =\n    trace A", "finally"], ["proof (chain)\npicking this:\n  trace (M 1 * A * adjoint (M 1)) + trace (M 0 * A * adjoint (M 0)) =\n  trace A", "show ?thesis"], ["proof (prove)\nusing this:\n  trace (M 1 * A * adjoint (M 1)) + trace (M 0 * A * adjoint (M 0)) =\n  trace A\n\ngoal (1 subgoal):\n 1. trace (M 0 * A * adjoint (M 0)) + trace (M 1 * A * adjoint (M 1)) =\n    trace A", "using dA dM0 dM1 local.id state_sig.trace_measure2_id"], ["proof (prove)\nusing this:\n  trace (M 1 * A * adjoint (M 1)) + trace (M 0 * A * adjoint (M 0)) =\n  trace A\n  A \\<in> carrier_mat n n\n  M 0 \\<in> carrier_mat n n\n  M 1 \\<in> carrier_mat n n\n  adjoint (M 0) * M 0 + adjoint (M 1) * M 1 = 1\\<^sub>m n\n  \\<lbrakk>?M0.0 \\<in> carrier_mat ?n ?n; ?M1.0 \\<in> carrier_mat ?n ?n;\n   adjoint ?M0.0 * ?M0.0 + adjoint ?M1.0 * ?M1.0 = 1\\<^sub>m ?n;\n   ?A \\<in> carrier_mat ?n ?n\\<rbrakk>\n  \\<Longrightarrow> trace (?M0.0 * ?A * adjoint ?M0.0) +\n                    trace (?M1.0 * ?A * adjoint ?M1.0) =\n                    trace ?A\n\ngoal (1 subgoal):\n 1. trace (M 0 * A * adjoint (M 0)) + trace (M 1 * A * adjoint (M 1)) =\n    trace A", "by blast"], ["proof (state)\nthis:\n  trace (M 0 * A * adjoint (M 0)) + trace (M 1 * A * adjoint (M 1)) =\n  trace A\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma qp_close_under_unitary_operator:\n  fixes U P :: \"complex mat\"\n  assumes dU: \"U \\<in> carrier_mat d d\"\n    and u: \"unitary U\"\n    and qp: \"is_quantum_predicate P\"\n  shows \"is_quantum_predicate (adjoint U * P * U)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_quantum_predicate (adjoint U * P * U)", "unfolding is_quantum_predicate_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. adjoint U * P * U \\<in> carrier_mat d d \\<and>\n    positive (adjoint U * P * U) \\<and>\n    adjoint U * P * U \\<le>\\<^sub>L 1\\<^sub>m d", "proof (auto)"], ["proof (state)\ngoal (3 subgoals):\n 1. adjoint U * P * U \\<in> carrier_mat d d\n 2. positive (adjoint U * P * U)\n 3. adjoint U * P * U \\<le>\\<^sub>L 1\\<^sub>m d", "have dP: \"P \\<in> carrier_mat d d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<in> carrier_mat d d", "using qp is_quantum_predicate_def"], ["proof (prove)\nusing this:\n  is_quantum_predicate P\n  is_quantum_predicate ?P =\n  (?P \\<in> carrier_mat d d \\<and>\n   positive ?P \\<and> ?P \\<le>\\<^sub>L 1\\<^sub>m d)\n\ngoal (1 subgoal):\n 1. P \\<in> carrier_mat d d", "by auto"], ["proof (state)\nthis:\n  P \\<in> carrier_mat d d\n\ngoal (3 subgoals):\n 1. adjoint U * P * U \\<in> carrier_mat d d\n 2. positive (adjoint U * P * U)\n 3. adjoint U * P * U \\<le>\\<^sub>L 1\\<^sub>m d", "show \"adjoint U * P * U \\<in> carrier_mat d d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adjoint U * P * U \\<in> carrier_mat d d", "using dU dP"], ["proof (prove)\nusing this:\n  U \\<in> carrier_mat d d\n  P \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. adjoint U * P * U \\<in> carrier_mat d d", "by fastforce"], ["proof (state)\nthis:\n  adjoint U * P * U \\<in> carrier_mat d d\n\ngoal (2 subgoals):\n 1. positive (adjoint U * P * U)\n 2. adjoint U * P * U \\<le>\\<^sub>L 1\\<^sub>m d", "have \"positive P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. positive P", "using qp is_quantum_predicate_def"], ["proof (prove)\nusing this:\n  is_quantum_predicate P\n  is_quantum_predicate ?P =\n  (?P \\<in> carrier_mat d d \\<and>\n   positive ?P \\<and> ?P \\<le>\\<^sub>L 1\\<^sub>m d)\n\ngoal (1 subgoal):\n 1. positive P", "by auto"], ["proof (state)\nthis:\n  positive P\n\ngoal (2 subgoals):\n 1. positive (adjoint U * P * U)\n 2. adjoint U * P * U \\<le>\\<^sub>L 1\\<^sub>m d", "then"], ["proof (chain)\npicking this:\n  positive P", "show \"positive (adjoint U * P * U)\""], ["proof (prove)\nusing this:\n  positive P\n\ngoal (1 subgoal):\n 1. positive (adjoint U * P * U)", "using positive_close_under_left_right_mult_adjoint[OF adjoint_dim[OF dU] dP, simplified adjoint_adjoint]"], ["proof (prove)\nusing this:\n  positive P\n  positive P \\<Longrightarrow> positive (adjoint U * P * U)\n\ngoal (1 subgoal):\n 1. positive (adjoint U * P * U)", "by fastforce"], ["proof (state)\nthis:\n  positive (adjoint U * P * U)\n\ngoal (1 subgoal):\n 1. adjoint U * P * U \\<le>\\<^sub>L 1\\<^sub>m d", "have \"adjoint U * U = 1\\<^sub>m d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adjoint U * U = 1\\<^sub>m d", "apply (subgoal_tac \"inverts_mat (adjoint U) U\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. inverts_mat (adjoint U) U \\<Longrightarrow> adjoint U * U = 1\\<^sub>m d\n 2. inverts_mat (adjoint U) U", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. inverts_mat (adjoint U) U \\<Longrightarrow> adjoint U * U = 1\\<^sub>m d", "unfolding inverts_mat_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. adjoint U * U = 1\\<^sub>m (dim_row (adjoint U)) \\<Longrightarrow>\n    adjoint U * U = 1\\<^sub>m d", "using dU"], ["proof (prove)\nusing this:\n  U \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. adjoint U * U = 1\\<^sub>m (dim_row (adjoint U)) \\<Longrightarrow>\n    adjoint U * U = 1\\<^sub>m d", "by auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. inverts_mat (adjoint U) U", "using u"], ["proof (prove)\nusing this:\n  unitary U\n\ngoal (1 subgoal):\n 1. inverts_mat (adjoint U) U", "unfolding unitary_def"], ["proof (prove)\nusing this:\n  U \\<in> carrier_mat (dim_row U) (dim_row U) \\<and>\n  inverts_mat U (adjoint U)\n\ngoal (1 subgoal):\n 1. inverts_mat (adjoint U) U", "using inverts_mat_symm[OF dU adjoint_dim[OF dU]]"], ["proof (prove)\nusing this:\n  U \\<in> carrier_mat (dim_row U) (dim_row U) \\<and>\n  inverts_mat U (adjoint U)\n  inverts_mat U (adjoint U) \\<Longrightarrow> inverts_mat (adjoint U) U\n\ngoal (1 subgoal):\n 1. inverts_mat (adjoint U) U", "by auto"], ["proof (state)\nthis:\n  adjoint U * U = 1\\<^sub>m d\n\ngoal (1 subgoal):\n 1. adjoint U * P * U \\<le>\\<^sub>L 1\\<^sub>m d", "then"], ["proof (chain)\npicking this:\n  adjoint U * U = 1\\<^sub>m d", "have u': \"adjoint U * 1\\<^sub>m d * U = 1\\<^sub>m d\""], ["proof (prove)\nusing this:\n  adjoint U * U = 1\\<^sub>m d\n\ngoal (1 subgoal):\n 1. adjoint U * 1\\<^sub>m d * U = 1\\<^sub>m d", "using dU"], ["proof (prove)\nusing this:\n  adjoint U * U = 1\\<^sub>m d\n  U \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. adjoint U * 1\\<^sub>m d * U = 1\\<^sub>m d", "by auto"], ["proof (state)\nthis:\n  adjoint U * 1\\<^sub>m d * U = 1\\<^sub>m d\n\ngoal (1 subgoal):\n 1. adjoint U * P * U \\<le>\\<^sub>L 1\\<^sub>m d", "have le: \"P \\<le>\\<^sub>L 1\\<^sub>m d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<le>\\<^sub>L 1\\<^sub>m d", "using qp is_quantum_predicate_def"], ["proof (prove)\nusing this:\n  is_quantum_predicate P\n  is_quantum_predicate ?P =\n  (?P \\<in> carrier_mat d d \\<and>\n   positive ?P \\<and> ?P \\<le>\\<^sub>L 1\\<^sub>m d)\n\ngoal (1 subgoal):\n 1. P \\<le>\\<^sub>L 1\\<^sub>m d", "by auto"], ["proof (state)\nthis:\n  P \\<le>\\<^sub>L 1\\<^sub>m d\n\ngoal (1 subgoal):\n 1. adjoint U * P * U \\<le>\\<^sub>L 1\\<^sub>m d", "show \"adjoint U * P * U \\<le>\\<^sub>L 1\\<^sub>m d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adjoint U * P * U \\<le>\\<^sub>L 1\\<^sub>m d", "using lowner_le_keep_under_measurement[OF dU dP one_carrier_mat le] u'"], ["proof (prove)\nusing this:\n  adjoint U * P * U \\<le>\\<^sub>L adjoint U * 1\\<^sub>m d * U\n  adjoint U * 1\\<^sub>m d * U = 1\\<^sub>m d\n\ngoal (1 subgoal):\n 1. adjoint U * P * U \\<le>\\<^sub>L 1\\<^sub>m d", "by auto"], ["proof (state)\nthis:\n  adjoint U * P * U \\<le>\\<^sub>L 1\\<^sub>m d\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma qps_after_measure_is_qp:\n  assumes m: \"measurement d n M \" and qpk: \"\\<And>k. k < n \\<Longrightarrow> is_quantum_predicate (P k)\"\n  shows \"is_quantum_predicate (matrix_sum d (\\<lambda>k. adjoint (M k) * P k  * M k) n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_quantum_predicate\n     (matrix_sum d (\\<lambda>k. adjoint (M k) * P k * M k) n)", "unfolding is_quantum_predicate_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_sum d (\\<lambda>k. adjoint (M k) * P k * M k) n\n    \\<in> carrier_mat d d \\<and>\n    positive (matrix_sum d (\\<lambda>k. adjoint (M k) * P k * M k) n) \\<and>\n    matrix_sum d (\\<lambda>k. adjoint (M k) * P k * M k) n \\<le>\\<^sub>L\n    1\\<^sub>m d", "proof (auto)"], ["proof (state)\ngoal (3 subgoals):\n 1. matrix_sum d (\\<lambda>k. adjoint (M k) * P k * M k) n\n    \\<in> carrier_mat d d\n 2. positive (matrix_sum d (\\<lambda>k. adjoint (M k) * P k * M k) n)\n 3. matrix_sum d (\\<lambda>k. adjoint (M k) * P k * M k) n \\<le>\\<^sub>L\n    1\\<^sub>m d", "have dMk: \"k < n \\<Longrightarrow> M k \\<in> carrier_mat d d\" for k"], ["proof (prove)\ngoal (1 subgoal):\n 1. k < n \\<Longrightarrow> M k \\<in> carrier_mat d d", "using m measurement_def"], ["proof (prove)\nusing this:\n  measurement d n M\n  measurement ?d ?n ?M =\n  ((\\<forall>j<?n. ?M j \\<in> carrier_mat ?d ?d) \\<and>\n   matrix_sum ?d (\\<lambda>j. adjoint (?M j) * ?M j) ?n = 1\\<^sub>m ?d)\n\ngoal (1 subgoal):\n 1. k < n \\<Longrightarrow> M k \\<in> carrier_mat d d", "by auto"], ["proof (state)\nthis:\n  ?k < n \\<Longrightarrow> M ?k \\<in> carrier_mat d d\n\ngoal (3 subgoals):\n 1. matrix_sum d (\\<lambda>k. adjoint (M k) * P k * M k) n\n    \\<in> carrier_mat d d\n 2. positive (matrix_sum d (\\<lambda>k. adjoint (M k) * P k * M k) n)\n 3. matrix_sum d (\\<lambda>k. adjoint (M k) * P k * M k) n \\<le>\\<^sub>L\n    1\\<^sub>m d", "moreover"], ["proof (state)\nthis:\n  ?k < n \\<Longrightarrow> M ?k \\<in> carrier_mat d d\n\ngoal (3 subgoals):\n 1. matrix_sum d (\\<lambda>k. adjoint (M k) * P k * M k) n\n    \\<in> carrier_mat d d\n 2. positive (matrix_sum d (\\<lambda>k. adjoint (M k) * P k * M k) n)\n 3. matrix_sum d (\\<lambda>k. adjoint (M k) * P k * M k) n \\<le>\\<^sub>L\n    1\\<^sub>m d", "have dPk: \"k < n \\<Longrightarrow> P k \\<in> carrier_mat d d\" for k"], ["proof (prove)\ngoal (1 subgoal):\n 1. k < n \\<Longrightarrow> P k \\<in> carrier_mat d d", "using qpk is_quantum_predicate_def"], ["proof (prove)\nusing this:\n  ?k < n \\<Longrightarrow> is_quantum_predicate (P ?k)\n  is_quantum_predicate ?P =\n  (?P \\<in> carrier_mat d d \\<and>\n   positive ?P \\<and> ?P \\<le>\\<^sub>L 1\\<^sub>m d)\n\ngoal (1 subgoal):\n 1. k < n \\<Longrightarrow> P k \\<in> carrier_mat d d", "by auto"], ["proof (state)\nthis:\n  ?k < n \\<Longrightarrow> P ?k \\<in> carrier_mat d d\n\ngoal (3 subgoals):\n 1. matrix_sum d (\\<lambda>k. adjoint (M k) * P k * M k) n\n    \\<in> carrier_mat d d\n 2. positive (matrix_sum d (\\<lambda>k. adjoint (M k) * P k * M k) n)\n 3. matrix_sum d (\\<lambda>k. adjoint (M k) * P k * M k) n \\<le>\\<^sub>L\n    1\\<^sub>m d", "ultimately"], ["proof (chain)\npicking this:\n  ?k < n \\<Longrightarrow> M ?k \\<in> carrier_mat d d\n  ?k < n \\<Longrightarrow> P ?k \\<in> carrier_mat d d", "have dk: \"k < n \\<Longrightarrow> adjoint (M k) * P k  * M k \\<in> carrier_mat d d\" for k"], ["proof (prove)\nusing this:\n  ?k < n \\<Longrightarrow> M ?k \\<in> carrier_mat d d\n  ?k < n \\<Longrightarrow> P ?k \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. k < n \\<Longrightarrow> adjoint (M k) * P k * M k \\<in> carrier_mat d d", "by fastforce"], ["proof (state)\nthis:\n  ?k < n \\<Longrightarrow>\n  adjoint (M ?k) * P ?k * M ?k \\<in> carrier_mat d d\n\ngoal (3 subgoals):\n 1. matrix_sum d (\\<lambda>k. adjoint (M k) * P k * M k) n\n    \\<in> carrier_mat d d\n 2. positive (matrix_sum d (\\<lambda>k. adjoint (M k) * P k * M k) n)\n 3. matrix_sum d (\\<lambda>k. adjoint (M k) * P k * M k) n \\<le>\\<^sub>L\n    1\\<^sub>m d", "then"], ["proof (chain)\npicking this:\n  ?k < n \\<Longrightarrow>\n  adjoint (M ?k) * P ?k * M ?k \\<in> carrier_mat d d", "show d: \"matrix_sum d (\\<lambda>k. adjoint (M k) * P k  * M k) n \\<in> carrier_mat d d\""], ["proof (prove)\nusing this:\n  ?k < n \\<Longrightarrow>\n  adjoint (M ?k) * P ?k * M ?k \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. matrix_sum d (\\<lambda>k. adjoint (M k) * P k * M k) n\n    \\<in> carrier_mat d d", "using matrix_sum_dim[of n \"\\<lambda>k. adjoint (M k) * P k  * M k\"]"], ["proof (prove)\nusing this:\n  ?k < n \\<Longrightarrow>\n  adjoint (M ?k) * P ?k * M ?k \\<in> carrier_mat d d\n  (\\<And>k.\n      k < n \\<Longrightarrow>\n      adjoint (M k) * P k * M k \\<in> carrier_mat ?d ?d) \\<Longrightarrow>\n  matrix_sum ?d (\\<lambda>k. adjoint (M k) * P k * M k) n\n  \\<in> carrier_mat ?d ?d\n\ngoal (1 subgoal):\n 1. matrix_sum d (\\<lambda>k. adjoint (M k) * P k * M k) n\n    \\<in> carrier_mat d d", "by auto"], ["proof (state)\nthis:\n  matrix_sum d (\\<lambda>k. adjoint (M k) * P k * M k) n\n  \\<in> carrier_mat d d\n\ngoal (2 subgoals):\n 1. positive (matrix_sum d (\\<lambda>k. adjoint (M k) * P k * M k) n)\n 2. matrix_sum d (\\<lambda>k. adjoint (M k) * P k * M k) n \\<le>\\<^sub>L\n    1\\<^sub>m d", "have \"k < n \\<Longrightarrow> positive (P k)\" for k"], ["proof (prove)\ngoal (1 subgoal):\n 1. k < n \\<Longrightarrow> positive (P k)", "using qpk is_quantum_predicate_def"], ["proof (prove)\nusing this:\n  ?k < n \\<Longrightarrow> is_quantum_predicate (P ?k)\n  is_quantum_predicate ?P =\n  (?P \\<in> carrier_mat d d \\<and>\n   positive ?P \\<and> ?P \\<le>\\<^sub>L 1\\<^sub>m d)\n\ngoal (1 subgoal):\n 1. k < n \\<Longrightarrow> positive (P k)", "by auto"], ["proof (state)\nthis:\n  ?k < n \\<Longrightarrow> positive (P ?k)\n\ngoal (2 subgoals):\n 1. positive (matrix_sum d (\\<lambda>k. adjoint (M k) * P k * M k) n)\n 2. matrix_sum d (\\<lambda>k. adjoint (M k) * P k * M k) n \\<le>\\<^sub>L\n    1\\<^sub>m d", "then"], ["proof (chain)\npicking this:\n  ?k < n \\<Longrightarrow> positive (P ?k)", "have \"k < n \\<Longrightarrow> positive (adjoint (M k) * P k * M k)\" for k"], ["proof (prove)\nusing this:\n  ?k < n \\<Longrightarrow> positive (P ?k)\n\ngoal (1 subgoal):\n 1. k < n \\<Longrightarrow> positive (adjoint (M k) * P k * M k)", "using positive_close_under_left_right_mult_adjoint[OF adjoint_dim[OF dMk] dPk, simplified adjoint_adjoint]"], ["proof (prove)\nusing this:\n  ?k < n \\<Longrightarrow> positive (P ?k)\n  \\<lbrakk>?k3 < n; ?k1 < n; positive (P ?k1)\\<rbrakk>\n  \\<Longrightarrow> positive (adjoint (M ?k3) * P ?k1 * M ?k3)\n\ngoal (1 subgoal):\n 1. k < n \\<Longrightarrow> positive (adjoint (M k) * P k * M k)", "by fastforce"], ["proof (state)\nthis:\n  ?k < n \\<Longrightarrow> positive (adjoint (M ?k) * P ?k * M ?k)\n\ngoal (2 subgoals):\n 1. positive (matrix_sum d (\\<lambda>k. adjoint (M k) * P k * M k) n)\n 2. matrix_sum d (\\<lambda>k. adjoint (M k) * P k * M k) n \\<le>\\<^sub>L\n    1\\<^sub>m d", "then"], ["proof (chain)\npicking this:\n  ?k < n \\<Longrightarrow> positive (adjoint (M ?k) * P ?k * M ?k)", "show \"positive (matrix_sum d (\\<lambda>k. adjoint (M k) * P k * M k) n)\""], ["proof (prove)\nusing this:\n  ?k < n \\<Longrightarrow> positive (adjoint (M ?k) * P ?k * M ?k)\n\ngoal (1 subgoal):\n 1. positive (matrix_sum d (\\<lambda>k. adjoint (M k) * P k * M k) n)", "using matrix_sum_positive dk"], ["proof (prove)\nusing this:\n  ?k < n \\<Longrightarrow> positive (adjoint (M ?k) * P ?k * M ?k)\n  \\<lbrakk>\\<And>k. k < ?n \\<Longrightarrow> ?f k \\<in> carrier_mat ?d ?d;\n   \\<And>k. k < ?n \\<Longrightarrow> positive (?f k)\\<rbrakk>\n  \\<Longrightarrow> positive (matrix_sum ?d ?f ?n)\n  ?k < n \\<Longrightarrow>\n  adjoint (M ?k) * P ?k * M ?k \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. positive (matrix_sum d (\\<lambda>k. adjoint (M k) * P k * M k) n)", "by auto"], ["proof (state)\nthis:\n  positive (matrix_sum d (\\<lambda>k. adjoint (M k) * P k * M k) n)\n\ngoal (1 subgoal):\n 1. matrix_sum d (\\<lambda>k. adjoint (M k) * P k * M k) n \\<le>\\<^sub>L\n    1\\<^sub>m d", "have \"k < n \\<Longrightarrow> P k \\<le>\\<^sub>L 1\\<^sub>m d\" for k"], ["proof (prove)\ngoal (1 subgoal):\n 1. k < n \\<Longrightarrow> P k \\<le>\\<^sub>L 1\\<^sub>m d", "using qpk is_quantum_predicate_def"], ["proof (prove)\nusing this:\n  ?k < n \\<Longrightarrow> is_quantum_predicate (P ?k)\n  is_quantum_predicate ?P =\n  (?P \\<in> carrier_mat d d \\<and>\n   positive ?P \\<and> ?P \\<le>\\<^sub>L 1\\<^sub>m d)\n\ngoal (1 subgoal):\n 1. k < n \\<Longrightarrow> P k \\<le>\\<^sub>L 1\\<^sub>m d", "by auto"], ["proof (state)\nthis:\n  ?k < n \\<Longrightarrow> P ?k \\<le>\\<^sub>L 1\\<^sub>m d\n\ngoal (1 subgoal):\n 1. matrix_sum d (\\<lambda>k. adjoint (M k) * P k * M k) n \\<le>\\<^sub>L\n    1\\<^sub>m d", "then"], ["proof (chain)\npicking this:\n  ?k < n \\<Longrightarrow> P ?k \\<le>\\<^sub>L 1\\<^sub>m d", "have \"k < n \\<Longrightarrow> positive (1\\<^sub>m d - P k)\" for k"], ["proof (prove)\nusing this:\n  ?k < n \\<Longrightarrow> P ?k \\<le>\\<^sub>L 1\\<^sub>m d\n\ngoal (1 subgoal):\n 1. k < n \\<Longrightarrow> positive (1\\<^sub>m d - P k)", "using lowner_le_def"], ["proof (prove)\nusing this:\n  ?k < n \\<Longrightarrow> P ?k \\<le>\\<^sub>L 1\\<^sub>m d\n  (?A \\<le>\\<^sub>L ?B) =\n  (dim_row ?A = dim_row ?B \\<and>\n   dim_col ?A = dim_col ?B \\<and> positive (?B - ?A))\n\ngoal (1 subgoal):\n 1. k < n \\<Longrightarrow> positive (1\\<^sub>m d - P k)", "by auto"], ["proof (state)\nthis:\n  ?k < n \\<Longrightarrow> positive (1\\<^sub>m d - P ?k)\n\ngoal (1 subgoal):\n 1. matrix_sum d (\\<lambda>k. adjoint (M k) * P k * M k) n \\<le>\\<^sub>L\n    1\\<^sub>m d", "then"], ["proof (chain)\npicking this:\n  ?k < n \\<Longrightarrow> positive (1\\<^sub>m d - P ?k)", "have p: \"k < n \\<Longrightarrow> positive (adjoint (M k) * (1\\<^sub>m d - P k) * M k)\" for k"], ["proof (prove)\nusing this:\n  ?k < n \\<Longrightarrow> positive (1\\<^sub>m d - P ?k)\n\ngoal (1 subgoal):\n 1. k < n \\<Longrightarrow>\n    positive (adjoint (M k) * (1\\<^sub>m d - P k) * M k)", "using positive_close_under_left_right_mult_adjoint[OF adjoint_dim[OF dMk], simplified adjoint_adjoint, of _ \"1\\<^sub>m d - P k\"] dPk"], ["proof (prove)\nusing this:\n  ?k < n \\<Longrightarrow> positive (1\\<^sub>m d - P ?k)\n  \\<lbrakk>?k2 < n; 1\\<^sub>m d - P k \\<in> carrier_mat d d;\n   positive (1\\<^sub>m d - P k)\\<rbrakk>\n  \\<Longrightarrow> positive (adjoint (M ?k2) * (1\\<^sub>m d - P k) * M ?k2)\n  ?k < n \\<Longrightarrow> P ?k \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. k < n \\<Longrightarrow>\n    positive (adjoint (M k) * (1\\<^sub>m d - P k) * M k)", "by fastforce"], ["proof (state)\nthis:\n  ?k < n \\<Longrightarrow>\n  positive (adjoint (M ?k) * (1\\<^sub>m d - P ?k) * M ?k)\n\ngoal (1 subgoal):\n 1. matrix_sum d (\\<lambda>k. adjoint (M k) * P k * M k) n \\<le>\\<^sub>L\n    1\\<^sub>m d", "{"], ["proof (state)\nthis:\n  ?k < n \\<Longrightarrow>\n  positive (adjoint (M ?k) * (1\\<^sub>m d - P ?k) * M ?k)\n\ngoal (1 subgoal):\n 1. matrix_sum d (\\<lambda>k. adjoint (M k) * P k * M k) n \\<le>\\<^sub>L\n    1\\<^sub>m d", "fix k"], ["proof (state)\ngoal (1 subgoal):\n 1. matrix_sum d (\\<lambda>k. adjoint (M k) * P k * M k) n \\<le>\\<^sub>L\n    1\\<^sub>m d", "assume k: \"k < n\""], ["proof (state)\nthis:\n  k < n\n\ngoal (1 subgoal):\n 1. matrix_sum d (\\<lambda>k. adjoint (M k) * P k * M k) n \\<le>\\<^sub>L\n    1\\<^sub>m d", "have \"adjoint (M k) * (1\\<^sub>m d - P k) * M k = adjoint (M k) * M k - adjoint (M k) * P k * M k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adjoint (M k) * (1\\<^sub>m d - P k) * M k =\n    adjoint (M k) * M k - adjoint (M k) * P k * M k", "apply (mat_assoc d)"], ["proof (prove)\ngoal (3 subgoals):\n 1. P k \\<in> carrier_mat d d\n 2. M k \\<in> carrier_mat d d\n 3. 1\\<^sub>m d \\<in> carrier_mat d d", "using dMk dPk k"], ["proof (prove)\nusing this:\n  ?k < n \\<Longrightarrow> M ?k \\<in> carrier_mat d d\n  ?k < n \\<Longrightarrow> P ?k \\<in> carrier_mat d d\n  k < n\n\ngoal (3 subgoals):\n 1. P k \\<in> carrier_mat d d\n 2. M k \\<in> carrier_mat d d\n 3. 1\\<^sub>m d \\<in> carrier_mat d d", "by auto"], ["proof (state)\nthis:\n  adjoint (M k) * (1\\<^sub>m d - P k) * M k =\n  adjoint (M k) * M k - adjoint (M k) * P k * M k\n\ngoal (1 subgoal):\n 1. matrix_sum d (\\<lambda>k. adjoint (M k) * P k * M k) n \\<le>\\<^sub>L\n    1\\<^sub>m d", "}"], ["proof (state)\nthis:\n  ?k2 < n \\<Longrightarrow>\n  adjoint (M ?k2) * (1\\<^sub>m d - P ?k2) * M ?k2 =\n  adjoint (M ?k2) * M ?k2 - adjoint (M ?k2) * P ?k2 * M ?k2\n\ngoal (1 subgoal):\n 1. matrix_sum d (\\<lambda>k. adjoint (M k) * P k * M k) n \\<le>\\<^sub>L\n    1\\<^sub>m d", "note split = this"], ["proof (state)\nthis:\n  ?k2 < n \\<Longrightarrow>\n  adjoint (M ?k2) * (1\\<^sub>m d - P ?k2) * M ?k2 =\n  adjoint (M ?k2) * M ?k2 - adjoint (M ?k2) * P ?k2 * M ?k2\n\ngoal (1 subgoal):\n 1. matrix_sum d (\\<lambda>k. adjoint (M k) * P k * M k) n \\<le>\\<^sub>L\n    1\\<^sub>m d", "have dk': \"k < n \\<Longrightarrow> adjoint (M k) * M k - adjoint (M k) * P k * M k \\<in> carrier_mat d d\" for k"], ["proof (prove)\ngoal (1 subgoal):\n 1. k < n \\<Longrightarrow>\n    adjoint (M k) * M k - adjoint (M k) * P k * M k \\<in> carrier_mat d d", "using dMk dPk"], ["proof (prove)\nusing this:\n  ?k < n \\<Longrightarrow> M ?k \\<in> carrier_mat d d\n  ?k < n \\<Longrightarrow> P ?k \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. k < n \\<Longrightarrow>\n    adjoint (M k) * M k - adjoint (M k) * P k * M k \\<in> carrier_mat d d", "by fastforce"], ["proof (state)\nthis:\n  ?k < n \\<Longrightarrow>\n  adjoint (M ?k) * M ?k - adjoint (M ?k) * P ?k * M ?k \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. matrix_sum d (\\<lambda>k. adjoint (M k) * P k * M k) n \\<le>\\<^sub>L\n    1\\<^sub>m d", "have \"k < n \\<Longrightarrow> positive (adjoint (M k) * M k - adjoint (M k) * P k * M k)\" for k"], ["proof (prove)\ngoal (1 subgoal):\n 1. k < n \\<Longrightarrow>\n    positive (adjoint (M k) * M k - adjoint (M k) * P k * M k)", "using p split"], ["proof (prove)\nusing this:\n  ?k < n \\<Longrightarrow>\n  positive (adjoint (M ?k) * (1\\<^sub>m d - P ?k) * M ?k)\n  ?k2 < n \\<Longrightarrow>\n  adjoint (M ?k2) * (1\\<^sub>m d - P ?k2) * M ?k2 =\n  adjoint (M ?k2) * M ?k2 - adjoint (M ?k2) * P ?k2 * M ?k2\n\ngoal (1 subgoal):\n 1. k < n \\<Longrightarrow>\n    positive (adjoint (M k) * M k - adjoint (M k) * P k * M k)", "by auto"], ["proof (state)\nthis:\n  ?k < n \\<Longrightarrow>\n  positive (adjoint (M ?k) * M ?k - adjoint (M ?k) * P ?k * M ?k)\n\ngoal (1 subgoal):\n 1. matrix_sum d (\\<lambda>k. adjoint (M k) * P k * M k) n \\<le>\\<^sub>L\n    1\\<^sub>m d", "then"], ["proof (chain)\npicking this:\n  ?k < n \\<Longrightarrow>\n  positive (adjoint (M ?k) * M ?k - adjoint (M ?k) * P ?k * M ?k)", "have p': \"positive (matrix_sum d (\\<lambda>k. adjoint (M k) * M k - adjoint (M k) * P k * M k) n)\""], ["proof (prove)\nusing this:\n  ?k < n \\<Longrightarrow>\n  positive (adjoint (M ?k) * M ?k - adjoint (M ?k) * P ?k * M ?k)\n\ngoal (1 subgoal):\n 1. positive\n     (matrix_sum d\n       (\\<lambda>k. adjoint (M k) * M k - adjoint (M k) * P k * M k) n)", "using matrix_sum_positive[OF dk', of n id, simplified]"], ["proof (prove)\nusing this:\n  ?k < n \\<Longrightarrow>\n  positive (adjoint (M ?k) * M ?k - adjoint (M ?k) * P ?k * M ?k)\n  (\\<And>k.\n      k < n \\<Longrightarrow>\n      positive\n       (adjoint (M k) * M k - adjoint (M k) * P k * M k)) \\<Longrightarrow>\n  positive\n   (matrix_sum d\n     (\\<lambda>k. adjoint (M k) * M k - adjoint (M k) * P k * M k) n)\n\ngoal (1 subgoal):\n 1. positive\n     (matrix_sum d\n       (\\<lambda>k. adjoint (M k) * M k - adjoint (M k) * P k * M k) n)", "by auto"], ["proof (state)\nthis:\n  positive\n   (matrix_sum d\n     (\\<lambda>k. adjoint (M k) * M k - adjoint (M k) * P k * M k) n)\n\ngoal (1 subgoal):\n 1. matrix_sum d (\\<lambda>k. adjoint (M k) * P k * M k) n \\<le>\\<^sub>L\n    1\\<^sub>m d", "have daMMk: \"k < n \\<Longrightarrow> adjoint (M k) * M k \\<in> carrier_mat d d\" for k"], ["proof (prove)\ngoal (1 subgoal):\n 1. k < n \\<Longrightarrow> adjoint (M k) * M k \\<in> carrier_mat d d", "using dMk"], ["proof (prove)\nusing this:\n  ?k < n \\<Longrightarrow> M ?k \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. k < n \\<Longrightarrow> adjoint (M k) * M k \\<in> carrier_mat d d", "by fastforce"], ["proof (state)\nthis:\n  ?k < n \\<Longrightarrow> adjoint (M ?k) * M ?k \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. matrix_sum d (\\<lambda>k. adjoint (M k) * P k * M k) n \\<le>\\<^sub>L\n    1\\<^sub>m d", "have daMPMk: \"k < n \\<Longrightarrow> adjoint (M k) * P k * M k \\<in> carrier_mat d d\" for k"], ["proof (prove)\ngoal (1 subgoal):\n 1. k < n \\<Longrightarrow> adjoint (M k) * P k * M k \\<in> carrier_mat d d", "using dMk dPk"], ["proof (prove)\nusing this:\n  ?k < n \\<Longrightarrow> M ?k \\<in> carrier_mat d d\n  ?k < n \\<Longrightarrow> P ?k \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. k < n \\<Longrightarrow> adjoint (M k) * P k * M k \\<in> carrier_mat d d", "by fastforce"], ["proof (state)\nthis:\n  ?k < n \\<Longrightarrow>\n  adjoint (M ?k) * P ?k * M ?k \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. matrix_sum d (\\<lambda>k. adjoint (M k) * P k * M k) n \\<le>\\<^sub>L\n    1\\<^sub>m d", "have \"matrix_sum d (\\<lambda>k. adjoint (M k) * M k - adjoint (M k) * P k * M k) n \n    = matrix_sum d (\\<lambda>k. adjoint (M k) * M k) n - matrix_sum d (\\<lambda>k. adjoint (M k) * P k * M k) n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_sum d\n     (\\<lambda>k. adjoint (M k) * M k - adjoint (M k) * P k * M k) n =\n    matrix_sum d (\\<lambda>k. adjoint (M k) * M k) n -\n    matrix_sum d (\\<lambda>k. adjoint (M k) * P k * M k) n", "using matrix_sum_minus_distrib[OF daMMk daMPMk]"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>k. k < ?n \\<Longrightarrow> ?k2 k < n;\n   \\<And>k. k < ?n \\<Longrightarrow> ?k1 k < n\\<rbrakk>\n  \\<Longrightarrow> matrix_sum d\n                     (\\<lambda>k.\n                         adjoint (M (?k2 k)) * M (?k2 k) -\n                         adjoint (M (?k1 k)) * P (?k1 k) * M (?k1 k))\n                     ?n =\n                    matrix_sum d\n                     (\\<lambda>k. adjoint (M (?k2 k)) * M (?k2 k)) ?n -\n                    matrix_sum d\n                     (\\<lambda>k.\n                         adjoint (M (?k1 k)) * P (?k1 k) * M (?k1 k))\n                     ?n\n\ngoal (1 subgoal):\n 1. matrix_sum d\n     (\\<lambda>k. adjoint (M k) * M k - adjoint (M k) * P k * M k) n =\n    matrix_sum d (\\<lambda>k. adjoint (M k) * M k) n -\n    matrix_sum d (\\<lambda>k. adjoint (M k) * P k * M k) n", "by auto"], ["proof (state)\nthis:\n  matrix_sum d (\\<lambda>k. adjoint (M k) * M k - adjoint (M k) * P k * M k)\n   n =\n  matrix_sum d (\\<lambda>k. adjoint (M k) * M k) n -\n  matrix_sum d (\\<lambda>k. adjoint (M k) * P k * M k) n\n\ngoal (1 subgoal):\n 1. matrix_sum d (\\<lambda>k. adjoint (M k) * P k * M k) n \\<le>\\<^sub>L\n    1\\<^sub>m d", "also"], ["proof (state)\nthis:\n  matrix_sum d (\\<lambda>k. adjoint (M k) * M k - adjoint (M k) * P k * M k)\n   n =\n  matrix_sum d (\\<lambda>k. adjoint (M k) * M k) n -\n  matrix_sum d (\\<lambda>k. adjoint (M k) * P k * M k) n\n\ngoal (1 subgoal):\n 1. matrix_sum d (\\<lambda>k. adjoint (M k) * P k * M k) n \\<le>\\<^sub>L\n    1\\<^sub>m d", "have \"\\<dots> = 1\\<^sub>m d - matrix_sum d (\\<lambda>k. adjoint (M k) * P k  * M k) n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_sum d (\\<lambda>k. adjoint (M k) * M k) n -\n    matrix_sum d (\\<lambda>k. adjoint (M k) * P k * M k) n =\n    1\\<^sub>m d - matrix_sum d (\\<lambda>k. adjoint (M k) * P k * M k) n", "using m measurement_def"], ["proof (prove)\nusing this:\n  measurement d n M\n  measurement ?d ?n ?M =\n  ((\\<forall>j<?n. ?M j \\<in> carrier_mat ?d ?d) \\<and>\n   matrix_sum ?d (\\<lambda>j. adjoint (?M j) * ?M j) ?n = 1\\<^sub>m ?d)\n\ngoal (1 subgoal):\n 1. matrix_sum d (\\<lambda>k. adjoint (M k) * M k) n -\n    matrix_sum d (\\<lambda>k. adjoint (M k) * P k * M k) n =\n    1\\<^sub>m d - matrix_sum d (\\<lambda>k. adjoint (M k) * P k * M k) n", "by auto"], ["proof (state)\nthis:\n  matrix_sum d (\\<lambda>k. adjoint (M k) * M k) n -\n  matrix_sum d (\\<lambda>k. adjoint (M k) * P k * M k) n =\n  1\\<^sub>m d - matrix_sum d (\\<lambda>k. adjoint (M k) * P k * M k) n\n\ngoal (1 subgoal):\n 1. matrix_sum d (\\<lambda>k. adjoint (M k) * P k * M k) n \\<le>\\<^sub>L\n    1\\<^sub>m d", "finally"], ["proof (chain)\npicking this:\n  matrix_sum d (\\<lambda>k. adjoint (M k) * M k - adjoint (M k) * P k * M k)\n   n =\n  1\\<^sub>m d - matrix_sum d (\\<lambda>k. adjoint (M k) * P k * M k) n", "have \"positive (1\\<^sub>m d - matrix_sum d (\\<lambda>k. adjoint (M k) * P k * M k) n)\""], ["proof (prove)\nusing this:\n  matrix_sum d (\\<lambda>k. adjoint (M k) * M k - adjoint (M k) * P k * M k)\n   n =\n  1\\<^sub>m d - matrix_sum d (\\<lambda>k. adjoint (M k) * P k * M k) n\n\ngoal (1 subgoal):\n 1. positive\n     (1\\<^sub>m d - matrix_sum d (\\<lambda>k. adjoint (M k) * P k * M k) n)", "using p'"], ["proof (prove)\nusing this:\n  matrix_sum d (\\<lambda>k. adjoint (M k) * M k - adjoint (M k) * P k * M k)\n   n =\n  1\\<^sub>m d - matrix_sum d (\\<lambda>k. adjoint (M k) * P k * M k) n\n  positive\n   (matrix_sum d\n     (\\<lambda>k. adjoint (M k) * M k - adjoint (M k) * P k * M k) n)\n\ngoal (1 subgoal):\n 1. positive\n     (1\\<^sub>m d - matrix_sum d (\\<lambda>k. adjoint (M k) * P k * M k) n)", "by auto"], ["proof (state)\nthis:\n  positive\n   (1\\<^sub>m d - matrix_sum d (\\<lambda>k. adjoint (M k) * P k * M k) n)\n\ngoal (1 subgoal):\n 1. matrix_sum d (\\<lambda>k. adjoint (M k) * P k * M k) n \\<le>\\<^sub>L\n    1\\<^sub>m d", "then"], ["proof (chain)\npicking this:\n  positive\n   (1\\<^sub>m d - matrix_sum d (\\<lambda>k. adjoint (M k) * P k * M k) n)", "show \"matrix_sum d (\\<lambda>k. adjoint (M k) * P k * M k) n \\<le>\\<^sub>L 1\\<^sub>m d\""], ["proof (prove)\nusing this:\n  positive\n   (1\\<^sub>m d - matrix_sum d (\\<lambda>k. adjoint (M k) * P k * M k) n)\n\ngoal (1 subgoal):\n 1. matrix_sum d (\\<lambda>k. adjoint (M k) * P k * M k) n \\<le>\\<^sub>L\n    1\\<^sub>m d", "using lowner_le_def d"], ["proof (prove)\nusing this:\n  positive\n   (1\\<^sub>m d - matrix_sum d (\\<lambda>k. adjoint (M k) * P k * M k) n)\n  (?A \\<le>\\<^sub>L ?B) =\n  (dim_row ?A = dim_row ?B \\<and>\n   dim_col ?A = dim_col ?B \\<and> positive (?B - ?A))\n  matrix_sum d (\\<lambda>k. adjoint (M k) * P k * M k) n\n  \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. matrix_sum d (\\<lambda>k. adjoint (M k) * P k * M k) n \\<le>\\<^sub>L\n    1\\<^sub>m d", "by auto"], ["proof (state)\nthis:\n  matrix_sum d (\\<lambda>k. adjoint (M k) * P k * M k) n \\<le>\\<^sub>L\n  1\\<^sub>m d\n\ngoal:\nNo subgoals!", "qed"], ["", "definition hoare_total_correct :: \"complex mat \\<Rightarrow> com \\<Rightarrow> complex mat \\<Rightarrow> bool\" (\"\\<Turnstile>\\<^sub>t {(1_)}/ (_)/ {(1_)}\" 50) where\n  \"\\<Turnstile>\\<^sub>t {P} S {Q} \\<longleftrightarrow> (\\<forall>\\<rho>\\<in>density_states. trace (P * \\<rho>) \\<le> trace (Q * denote S \\<rho>))\""], ["", "definition hoare_partial_correct :: \"complex mat \\<Rightarrow> com \\<Rightarrow> complex mat \\<Rightarrow> bool\" (\"\\<Turnstile>\\<^sub>p {(1_)}/ (_)/ {(1_)}\" 50) where\n  \"\\<Turnstile>\\<^sub>p {P} S {Q} \\<longleftrightarrow> (\\<forall>\\<rho>\\<in>density_states. trace (P * \\<rho>) \\<le> trace (Q * denote S \\<rho>) + (trace \\<rho> - trace (denote S \\<rho>)))\""], ["", "(* Proposition 6.1 (1) *)"], ["", "lemma total_implies_partial:\n  assumes S: \"well_com S\"\n    and total: \"\\<Turnstile>\\<^sub>t {P} S {Q}\"\n  shows \"\\<Turnstile>\\<^sub>p {P} S {Q}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Turnstile>\\<^sub>p {P} S {Q}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Turnstile>\\<^sub>p {P} S {Q}", "have \"trace (P * \\<rho>) \\<le> trace (Q * denote S \\<rho>) + (trace \\<rho> - trace (denote S \\<rho>))\" if \\<rho>: \"\\<rho> \\<in> density_states\" for \\<rho>"], ["proof (prove)\ngoal (1 subgoal):\n 1. trace (P * \\<rho>)\n    \\<le> trace (Q * denote S \\<rho>) +\n          (trace \\<rho> - trace (denote S \\<rho>))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. trace (P * \\<rho>)\n    \\<le> trace (Q * denote S \\<rho>) +\n          (trace \\<rho> - trace (denote S \\<rho>))", "have \"trace (P * \\<rho>) \\<le> trace (Q * denote S \\<rho>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace (P * \\<rho>) \\<le> trace (Q * denote S \\<rho>)", "using total hoare_total_correct_def \\<rho>"], ["proof (prove)\nusing this:\n  \\<Turnstile>\\<^sub>t {P} S {Q}\n  (\\<Turnstile>\\<^sub>t {?P} ?S {?Q}) =\n  (\\<forall>\\<rho>\\<in>density_states.\n      trace (?P * \\<rho>) \\<le> trace (?Q * denote ?S \\<rho>))\n  \\<rho> \\<in> density_states\n\ngoal (1 subgoal):\n 1. trace (P * \\<rho>) \\<le> trace (Q * denote S \\<rho>)", "by auto"], ["proof (state)\nthis:\n  trace (P * \\<rho>) \\<le> trace (Q * denote S \\<rho>)\n\ngoal (1 subgoal):\n 1. trace (P * \\<rho>)\n    \\<le> trace (Q * denote S \\<rho>) +\n          (trace \\<rho> - trace (denote S \\<rho>))", "moreover"], ["proof (state)\nthis:\n  trace (P * \\<rho>) \\<le> trace (Q * denote S \\<rho>)\n\ngoal (1 subgoal):\n 1. trace (P * \\<rho>)\n    \\<le> trace (Q * denote S \\<rho>) +\n          (trace \\<rho> - trace (denote S \\<rho>))", "have \"trace (denote S \\<rho>) \\<le> trace \\<rho>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace (denote S \\<rho>) \\<le> trace \\<rho>", "using denote_trace[OF S] \\<rho> density_states_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>?\\<rho> \\<in> carrier_mat d d;\n   partial_density_operator ?\\<rho>\\<rbrakk>\n  \\<Longrightarrow> trace (denote S ?\\<rho>) \\<le> trace ?\\<rho>\n  \\<rho> \\<in> density_states\n  density_states =\n  {\\<rho> \\<in> carrier_mat d d. partial_density_operator \\<rho>}\n\ngoal (1 subgoal):\n 1. trace (denote S \\<rho>) \\<le> trace \\<rho>", "by auto"], ["proof (state)\nthis:\n  trace (denote S \\<rho>) \\<le> trace \\<rho>\n\ngoal (1 subgoal):\n 1. trace (P * \\<rho>)\n    \\<le> trace (Q * denote S \\<rho>) +\n          (trace \\<rho> - trace (denote S \\<rho>))", "ultimately"], ["proof (chain)\npicking this:\n  trace (P * \\<rho>) \\<le> trace (Q * denote S \\<rho>)\n  trace (denote S \\<rho>) \\<le> trace \\<rho>", "show ?thesis"], ["proof (prove)\nusing this:\n  trace (P * \\<rho>) \\<le> trace (Q * denote S \\<rho>)\n  trace (denote S \\<rho>) \\<le> trace \\<rho>\n\ngoal (1 subgoal):\n 1. trace (P * \\<rho>)\n    \\<le> trace (Q * denote S \\<rho>) +\n          (trace \\<rho> - trace (denote S \\<rho>))", "by auto"], ["proof (state)\nthis:\n  trace (P * \\<rho>)\n  \\<le> trace (Q * denote S \\<rho>) +\n        (trace \\<rho> - trace (denote S \\<rho>))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?\\<rho> \\<in> density_states \\<Longrightarrow>\n  trace (P * ?\\<rho>)\n  \\<le> trace (Q * denote S ?\\<rho>) +\n        (trace ?\\<rho> - trace (denote S ?\\<rho>))\n\ngoal (1 subgoal):\n 1. \\<Turnstile>\\<^sub>p {P} S {Q}", "then"], ["proof (chain)\npicking this:\n  ?\\<rho> \\<in> density_states \\<Longrightarrow>\n  trace (P * ?\\<rho>)\n  \\<le> trace (Q * denote S ?\\<rho>) +\n        (trace ?\\<rho> - trace (denote S ?\\<rho>))", "show ?thesis"], ["proof (prove)\nusing this:\n  ?\\<rho> \\<in> density_states \\<Longrightarrow>\n  trace (P * ?\\<rho>)\n  \\<le> trace (Q * denote S ?\\<rho>) +\n        (trace ?\\<rho> - trace (denote S ?\\<rho>))\n\ngoal (1 subgoal):\n 1. \\<Turnstile>\\<^sub>p {P} S {Q}", "using hoare_partial_correct_def"], ["proof (prove)\nusing this:\n  ?\\<rho> \\<in> density_states \\<Longrightarrow>\n  trace (P * ?\\<rho>)\n  \\<le> trace (Q * denote S ?\\<rho>) +\n        (trace ?\\<rho> - trace (denote S ?\\<rho>))\n  (\\<Turnstile>\\<^sub>p {?P} ?S {?Q}) =\n  (\\<forall>\\<rho>\\<in>density_states.\n      trace (?P * \\<rho>)\n      \\<le> trace (?Q * denote ?S \\<rho>) +\n            (trace \\<rho> - trace (denote ?S \\<rho>)))\n\ngoal (1 subgoal):\n 1. \\<Turnstile>\\<^sub>p {P} S {Q}", "by auto"], ["proof (state)\nthis:\n  \\<Turnstile>\\<^sub>p {P} S {Q}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma predicate_prob_positive:\n  assumes \"0\\<^sub>m d d \\<le>\\<^sub>L P\"\n    and \"\\<rho> \\<in> density_states\"\n  shows \"0 \\<le> trace (P * \\<rho>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> trace (P * \\<rho>)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. 0 \\<le> trace (P * \\<rho>)", "have \"trace (0\\<^sub>m d d * \\<rho>) \\<le> trace (P * \\<rho>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace (0\\<^sub>m d d * \\<rho>) \\<le> trace (P * \\<rho>)", "apply (rule lowner_le_traceD)"], ["proof (prove)\ngoal (5 subgoals):\n 1. 0\\<^sub>m d d \\<in> carrier_mat ?n ?n\n 2. P \\<in> carrier_mat ?n ?n\n 3. \\<rho> \\<in> carrier_mat ?n ?n\n 4. 0\\<^sub>m d d \\<le>\\<^sub>L P\n 5. partial_density_operator \\<rho>", "using assms"], ["proof (prove)\nusing this:\n  0\\<^sub>m d d \\<le>\\<^sub>L P\n  \\<rho> \\<in> density_states\n\ngoal (5 subgoals):\n 1. 0\\<^sub>m d d \\<in> carrier_mat ?n ?n\n 2. P \\<in> carrier_mat ?n ?n\n 3. \\<rho> \\<in> carrier_mat ?n ?n\n 4. 0\\<^sub>m d d \\<le>\\<^sub>L P\n 5. partial_density_operator \\<rho>", "unfolding lowner_le_def density_states_def"], ["proof (prove)\nusing this:\n  dim_row (0\\<^sub>m d d) = dim_row P \\<and>\n  dim_col (0\\<^sub>m d d) = dim_col P \\<and> positive (P - 0\\<^sub>m d d)\n  \\<rho>\n  \\<in> {\\<rho> \\<in> carrier_mat d d. partial_density_operator \\<rho>}\n\ngoal (5 subgoals):\n 1. 0\\<^sub>m d d \\<in> carrier_mat ?n ?n\n 2. P \\<in> carrier_mat ?n ?n\n 3. \\<rho> \\<in> carrier_mat ?n ?n\n 4. dim_row (0\\<^sub>m d d) = dim_row P \\<and>\n    dim_col (0\\<^sub>m d d) = dim_col P \\<and> positive (P - 0\\<^sub>m d d)\n 5. partial_density_operator \\<rho>", "by auto"], ["proof (state)\nthis:\n  trace (0\\<^sub>m d d * \\<rho>) \\<le> trace (P * \\<rho>)\n\ngoal (1 subgoal):\n 1. 0 \\<le> trace (P * \\<rho>)", "then"], ["proof (chain)\npicking this:\n  trace (0\\<^sub>m d d * \\<rho>) \\<le> trace (P * \\<rho>)", "show ?thesis"], ["proof (prove)\nusing this:\n  trace (0\\<^sub>m d d * \\<rho>) \\<le> trace (P * \\<rho>)\n\ngoal (1 subgoal):\n 1. 0 \\<le> trace (P * \\<rho>)", "using assms(2) density_states_def"], ["proof (prove)\nusing this:\n  trace (0\\<^sub>m d d * \\<rho>) \\<le> trace (P * \\<rho>)\n  \\<rho> \\<in> density_states\n  density_states =\n  {\\<rho> \\<in> carrier_mat d d. partial_density_operator \\<rho>}\n\ngoal (1 subgoal):\n 1. 0 \\<le> trace (P * \\<rho>)", "by auto"], ["proof (state)\nthis:\n  0 \\<le> trace (P * \\<rho>)\n\ngoal:\nNo subgoals!", "qed"], ["", "(* Proposition 6.1 (2a) *)"], ["", "lemma total_pre_zero:\n  assumes S: \"well_com S\"\n    and Q: \"is_quantum_predicate Q\"\n  shows \"\\<Turnstile>\\<^sub>t {0\\<^sub>m d d} S {Q}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Turnstile>\\<^sub>t {0\\<^sub>m d d} S {Q}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Turnstile>\\<^sub>t {0\\<^sub>m d d} S {Q}", "have \"trace (0\\<^sub>m d d * \\<rho>) \\<le> trace (Q * denote S \\<rho>)\" if \\<rho>: \"\\<rho> \\<in> density_states\" for \\<rho>"], ["proof (prove)\ngoal (1 subgoal):\n 1. trace (0\\<^sub>m d d * \\<rho>) \\<le> trace (Q * denote S \\<rho>)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. trace (0\\<^sub>m d d * \\<rho>) \\<le> trace (Q * denote S \\<rho>)", "have 1: \"trace (0\\<^sub>m d d * \\<rho>) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace (0\\<^sub>m d d * \\<rho>) = 0", "using \\<rho>"], ["proof (prove)\nusing this:\n  \\<rho> \\<in> density_states\n\ngoal (1 subgoal):\n 1. trace (0\\<^sub>m d d * \\<rho>) = 0", "unfolding density_states_def"], ["proof (prove)\nusing this:\n  \\<rho>\n  \\<in> {\\<rho> \\<in> carrier_mat d d. partial_density_operator \\<rho>}\n\ngoal (1 subgoal):\n 1. trace (0\\<^sub>m d d * \\<rho>) = 0", "by auto"], ["proof (state)\nthis:\n  trace (0\\<^sub>m d d * \\<rho>) = 0\n\ngoal (1 subgoal):\n 1. trace (0\\<^sub>m d d * \\<rho>) \\<le> trace (Q * denote S \\<rho>)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. trace (0\\<^sub>m d d * \\<rho>) \\<le> trace (Q * denote S \\<rho>)", "apply (subst 1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> trace (Q * denote S \\<rho>)", "apply (rule predicate_prob_positive)"], ["proof (prove)\ngoal (2 subgoals):\n 1. 0\\<^sub>m d d \\<le>\\<^sub>L Q\n 2. denote S \\<rho> \\<in> density_states", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0\\<^sub>m d d \\<le>\\<^sub>L Q", "apply (simp add: lowner_le_def, subgoal_tac \"Q - 0\\<^sub>m d d = Q\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. Q - 0\\<^sub>m d d = Q \\<Longrightarrow>\n    d = dim_row Q \\<and> d = dim_col Q \\<and> positive (Q - 0\\<^sub>m d d)\n 2. Q - 0\\<^sub>m d d = Q", "using Q is_quantum_predicate_def[of Q]"], ["proof (prove)\nusing this:\n  is_quantum_predicate Q\n  is_quantum_predicate Q =\n  (Q \\<in> carrier_mat d d \\<and>\n   positive Q \\<and> Q \\<le>\\<^sub>L 1\\<^sub>m d)\n\ngoal (2 subgoals):\n 1. Q - 0\\<^sub>m d d = Q \\<Longrightarrow>\n    d = dim_row Q \\<and> d = dim_col Q \\<and> positive (Q - 0\\<^sub>m d d)\n 2. Q - 0\\<^sub>m d d = Q", "by auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. denote S \\<rho> \\<in> density_states", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. denote S \\<rho> \\<in> density_states", "using denote_density_states \\<rho> S"], ["proof (prove)\nusing this:\n  \\<lbrakk>?\\<rho> \\<in> density_states; well_com ?S\\<rbrakk>\n  \\<Longrightarrow> denote ?S ?\\<rho> \\<in> density_states\n  \\<rho> \\<in> density_states\n  well_com S\n\ngoal (1 subgoal):\n 1. denote S \\<rho> \\<in> density_states", "by auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  trace (0\\<^sub>m d d * \\<rho>) \\<le> trace (Q * denote S \\<rho>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?\\<rho> \\<in> density_states \\<Longrightarrow>\n  trace (0\\<^sub>m d d * ?\\<rho>) \\<le> trace (Q * denote S ?\\<rho>)\n\ngoal (1 subgoal):\n 1. \\<Turnstile>\\<^sub>t {0\\<^sub>m d d} S {Q}", "then"], ["proof (chain)\npicking this:\n  ?\\<rho> \\<in> density_states \\<Longrightarrow>\n  trace (0\\<^sub>m d d * ?\\<rho>) \\<le> trace (Q * denote S ?\\<rho>)", "show ?thesis"], ["proof (prove)\nusing this:\n  ?\\<rho> \\<in> density_states \\<Longrightarrow>\n  trace (0\\<^sub>m d d * ?\\<rho>) \\<le> trace (Q * denote S ?\\<rho>)\n\ngoal (1 subgoal):\n 1. \\<Turnstile>\\<^sub>t {0\\<^sub>m d d} S {Q}", "using hoare_total_correct_def"], ["proof (prove)\nusing this:\n  ?\\<rho> \\<in> density_states \\<Longrightarrow>\n  trace (0\\<^sub>m d d * ?\\<rho>) \\<le> trace (Q * denote S ?\\<rho>)\n  (\\<Turnstile>\\<^sub>t {?P} ?S {?Q}) =\n  (\\<forall>\\<rho>\\<in>density_states.\n      trace (?P * \\<rho>) \\<le> trace (?Q * denote ?S \\<rho>))\n\ngoal (1 subgoal):\n 1. \\<Turnstile>\\<^sub>t {0\\<^sub>m d d} S {Q}", "by auto"], ["proof (state)\nthis:\n  \\<Turnstile>\\<^sub>t {0\\<^sub>m d d} S {Q}\n\ngoal:\nNo subgoals!", "qed"], ["", "(* Proposition 6.1 (2b) *)"], ["", "lemma partial_post_identity:\n  assumes S: \"well_com S\"\n    and P: \"is_quantum_predicate P\"\n  shows \"\\<Turnstile>\\<^sub>p {P} S {1\\<^sub>m d}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Turnstile>\\<^sub>p {P} S {1\\<^sub>m d}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Turnstile>\\<^sub>p {P} S {1\\<^sub>m d}", "have \"trace (P * \\<rho>) \\<le> trace (1\\<^sub>m d * denote S \\<rho>) + (trace \\<rho> - trace (denote S \\<rho>))\" if \\<rho>: \"\\<rho> \\<in> density_states\" for \\<rho>"], ["proof (prove)\ngoal (1 subgoal):\n 1. trace (P * \\<rho>)\n    \\<le> trace (1\\<^sub>m d * denote S \\<rho>) +\n          (trace \\<rho> - trace (denote S \\<rho>))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. trace (P * \\<rho>)\n    \\<le> trace (1\\<^sub>m d * denote S \\<rho>) +\n          (trace \\<rho> - trace (denote S \\<rho>))", "have \"denote S \\<rho> \\<in> carrier_mat d d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. denote S \\<rho> \\<in> carrier_mat d d", "using S denote_dim \\<rho> density_states_def"], ["proof (prove)\nusing this:\n  well_com S\n  \\<lbrakk>well_com ?S; ?\\<rho> \\<in> carrier_mat d d;\n   partial_density_operator ?\\<rho>\\<rbrakk>\n  \\<Longrightarrow> denote ?S ?\\<rho> \\<in> carrier_mat d d\n  \\<rho> \\<in> density_states\n  density_states =\n  {\\<rho> \\<in> carrier_mat d d. partial_density_operator \\<rho>}\n\ngoal (1 subgoal):\n 1. denote S \\<rho> \\<in> carrier_mat d d", "by auto"], ["proof (state)\nthis:\n  denote S \\<rho> \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. trace (P * \\<rho>)\n    \\<le> trace (1\\<^sub>m d * denote S \\<rho>) +\n          (trace \\<rho> - trace (denote S \\<rho>))", "then"], ["proof (chain)\npicking this:\n  denote S \\<rho> \\<in> carrier_mat d d", "have \"trace (1\\<^sub>m d * denote S \\<rho>) = trace (denote S \\<rho>)\""], ["proof (prove)\nusing this:\n  denote S \\<rho> \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. trace (1\\<^sub>m d * denote S \\<rho>) = trace (denote S \\<rho>)", "by auto"], ["proof (state)\nthis:\n  trace (1\\<^sub>m d * denote S \\<rho>) = trace (denote S \\<rho>)\n\ngoal (1 subgoal):\n 1. trace (P * \\<rho>)\n    \\<le> trace (1\\<^sub>m d * denote S \\<rho>) +\n          (trace \\<rho> - trace (denote S \\<rho>))", "moreover"], ["proof (state)\nthis:\n  trace (1\\<^sub>m d * denote S \\<rho>) = trace (denote S \\<rho>)\n\ngoal (1 subgoal):\n 1. trace (P * \\<rho>)\n    \\<le> trace (1\\<^sub>m d * denote S \\<rho>) +\n          (trace \\<rho> - trace (denote S \\<rho>))", "have \"trace (P * \\<rho>) \\<le> trace (1\\<^sub>m d * \\<rho>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace (P * \\<rho>) \\<le> trace (1\\<^sub>m d * \\<rho>)", "apply (rule lowner_le_traceD)"], ["proof (prove)\ngoal (5 subgoals):\n 1. P \\<in> carrier_mat ?n ?n\n 2. 1\\<^sub>m d \\<in> carrier_mat ?n ?n\n 3. \\<rho> \\<in> carrier_mat ?n ?n\n 4. P \\<le>\\<^sub>L 1\\<^sub>m d\n 5. partial_density_operator \\<rho>", "using \\<rho>"], ["proof (prove)\nusing this:\n  \\<rho> \\<in> density_states\n\ngoal (5 subgoals):\n 1. P \\<in> carrier_mat ?n ?n\n 2. 1\\<^sub>m d \\<in> carrier_mat ?n ?n\n 3. \\<rho> \\<in> carrier_mat ?n ?n\n 4. P \\<le>\\<^sub>L 1\\<^sub>m d\n 5. partial_density_operator \\<rho>", "unfolding density_states_def"], ["proof (prove)\nusing this:\n  \\<rho>\n  \\<in> {\\<rho> \\<in> carrier_mat d d. partial_density_operator \\<rho>}\n\ngoal (5 subgoals):\n 1. P \\<in> carrier_mat ?n ?n\n 2. 1\\<^sub>m d \\<in> carrier_mat ?n ?n\n 3. \\<rho> \\<in> carrier_mat ?n ?n\n 4. P \\<le>\\<^sub>L 1\\<^sub>m d\n 5. partial_density_operator \\<rho>", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<rho> \\<in> carrier_mat d d;\n     partial_density_operator \\<rho>\\<rbrakk>\n    \\<Longrightarrow> P \\<in> carrier_mat d d\n 2. \\<lbrakk>\\<rho> \\<in> carrier_mat d d;\n     partial_density_operator \\<rho>\\<rbrakk>\n    \\<Longrightarrow> P \\<le>\\<^sub>L 1\\<^sub>m d", "using P is_quantum_predicate_def"], ["proof (prove)\nusing this:\n  is_quantum_predicate P\n  is_quantum_predicate ?P =\n  (?P \\<in> carrier_mat d d \\<and>\n   positive ?P \\<and> ?P \\<le>\\<^sub>L 1\\<^sub>m d)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<rho> \\<in> carrier_mat d d;\n     partial_density_operator \\<rho>\\<rbrakk>\n    \\<Longrightarrow> P \\<in> carrier_mat d d\n 2. \\<lbrakk>\\<rho> \\<in> carrier_mat d d;\n     partial_density_operator \\<rho>\\<rbrakk>\n    \\<Longrightarrow> P \\<le>\\<^sub>L 1\\<^sub>m d", "by auto"], ["proof (state)\nthis:\n  trace (P * \\<rho>) \\<le> trace (1\\<^sub>m d * \\<rho>)\n\ngoal (1 subgoal):\n 1. trace (P * \\<rho>)\n    \\<le> trace (1\\<^sub>m d * denote S \\<rho>) +\n          (trace \\<rho> - trace (denote S \\<rho>))", "ultimately"], ["proof (chain)\npicking this:\n  trace (1\\<^sub>m d * denote S \\<rho>) = trace (denote S \\<rho>)\n  trace (P * \\<rho>) \\<le> trace (1\\<^sub>m d * \\<rho>)", "show ?thesis"], ["proof (prove)\nusing this:\n  trace (1\\<^sub>m d * denote S \\<rho>) = trace (denote S \\<rho>)\n  trace (P * \\<rho>) \\<le> trace (1\\<^sub>m d * \\<rho>)\n\ngoal (1 subgoal):\n 1. trace (P * \\<rho>)\n    \\<le> trace (1\\<^sub>m d * denote S \\<rho>) +\n          (trace \\<rho> - trace (denote S \\<rho>))", "using density_states_def that"], ["proof (prove)\nusing this:\n  trace (1\\<^sub>m d * denote S \\<rho>) = trace (denote S \\<rho>)\n  trace (P * \\<rho>) \\<le> trace (1\\<^sub>m d * \\<rho>)\n  density_states =\n  {\\<rho> \\<in> carrier_mat d d. partial_density_operator \\<rho>}\n  \\<rho> \\<in> density_states\n\ngoal (1 subgoal):\n 1. trace (P * \\<rho>)\n    \\<le> trace (1\\<^sub>m d * denote S \\<rho>) +\n          (trace \\<rho> - trace (denote S \\<rho>))", "by auto"], ["proof (state)\nthis:\n  trace (P * \\<rho>)\n  \\<le> trace (1\\<^sub>m d * denote S \\<rho>) +\n        (trace \\<rho> - trace (denote S \\<rho>))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?\\<rho> \\<in> density_states \\<Longrightarrow>\n  trace (P * ?\\<rho>)\n  \\<le> trace (1\\<^sub>m d * denote S ?\\<rho>) +\n        (trace ?\\<rho> - trace (denote S ?\\<rho>))\n\ngoal (1 subgoal):\n 1. \\<Turnstile>\\<^sub>p {P} S {1\\<^sub>m d}", "then"], ["proof (chain)\npicking this:\n  ?\\<rho> \\<in> density_states \\<Longrightarrow>\n  trace (P * ?\\<rho>)\n  \\<le> trace (1\\<^sub>m d * denote S ?\\<rho>) +\n        (trace ?\\<rho> - trace (denote S ?\\<rho>))", "show ?thesis"], ["proof (prove)\nusing this:\n  ?\\<rho> \\<in> density_states \\<Longrightarrow>\n  trace (P * ?\\<rho>)\n  \\<le> trace (1\\<^sub>m d * denote S ?\\<rho>) +\n        (trace ?\\<rho> - trace (denote S ?\\<rho>))\n\ngoal (1 subgoal):\n 1. \\<Turnstile>\\<^sub>p {P} S {1\\<^sub>m d}", "using hoare_partial_correct_def"], ["proof (prove)\nusing this:\n  ?\\<rho> \\<in> density_states \\<Longrightarrow>\n  trace (P * ?\\<rho>)\n  \\<le> trace (1\\<^sub>m d * denote S ?\\<rho>) +\n        (trace ?\\<rho> - trace (denote S ?\\<rho>))\n  (\\<Turnstile>\\<^sub>p {?P} ?S {?Q}) =\n  (\\<forall>\\<rho>\\<in>density_states.\n      trace (?P * \\<rho>)\n      \\<le> trace (?Q * denote ?S \\<rho>) +\n            (trace \\<rho> - trace (denote ?S \\<rho>)))\n\ngoal (1 subgoal):\n 1. \\<Turnstile>\\<^sub>p {P} S {1\\<^sub>m d}", "by auto"], ["proof (state)\nthis:\n  \\<Turnstile>\\<^sub>p {P} S {1\\<^sub>m d}\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Weakest liberal preconditions\\<close>"], ["", "definition is_weakest_liberal_precondition :: \"complex mat \\<Rightarrow> com \\<Rightarrow> complex mat \\<Rightarrow> bool\"  where\n  \"is_weakest_liberal_precondition W S P \\<longleftrightarrow>\n    is_quantum_predicate W \\<and> \\<Turnstile>\\<^sub>p {W} S {P} \\<and> (\\<forall>Q. is_quantum_predicate Q \\<longrightarrow> \\<Turnstile>\\<^sub>p {Q} S {P} \\<longrightarrow> Q \\<le>\\<^sub>L W)\""], ["", "definition wlp_measure :: \"nat \\<Rightarrow> (nat \\<Rightarrow> complex mat) \\<Rightarrow> ((complex mat \\<Rightarrow> complex mat) list) \\<Rightarrow> complex mat \\<Rightarrow> complex mat\" where\n\"wlp_measure n M WS P = matrix_sum d (\\<lambda>k. adjoint (M k) * ((WS!k) P) * (M k)) n\""], ["", "fun wlp_while_n :: \"complex mat \\<Rightarrow> complex mat \\<Rightarrow> (complex mat \\<Rightarrow> complex mat) \\<Rightarrow> nat \\<Rightarrow> complex mat \\<Rightarrow> complex mat\" where\n  \"wlp_while_n M0 M1 WS 0 P = 1\\<^sub>m d\"\n| \"wlp_while_n M0 M1 WS (Suc n) P = adjoint M0 * P * M0 + adjoint M1 * (WS (wlp_while_n M0 M1 WS n P)) * M1\""], ["", "lemma measurement2_leq_one_mat:\n  assumes dP: \"P \\<in> carrier_mat d d\" and dQ: \"Q \\<in> carrier_mat d d\"\n    and leP: \"P \\<le>\\<^sub>L 1\\<^sub>m d\" and leQ: \"Q \\<le>\\<^sub>L 1\\<^sub>m d\" and m: \"measurement d 2 M\"\n  shows \"(adjoint (M 0) * P * (M 0) + adjoint (M 1) * Q * (M 1)) \\<le>\\<^sub>L 1\\<^sub>m d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adjoint (M 0) * P * M 0 + adjoint (M 1) * Q * M 1 \\<le>\\<^sub>L\n    1\\<^sub>m d", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. adjoint (M 0) * P * M 0 + adjoint (M 1) * Q * M 1 \\<le>\\<^sub>L\n    1\\<^sub>m d", "define M0 where \"M0 = M 0\""], ["proof (state)\nthis:\n  M0 = M 0\n\ngoal (1 subgoal):\n 1. adjoint (M 0) * P * M 0 + adjoint (M 1) * Q * M 1 \\<le>\\<^sub>L\n    1\\<^sub>m d", "define M1 where \"M1 = M 1\""], ["proof (state)\nthis:\n  M1 = M 1\n\ngoal (1 subgoal):\n 1. adjoint (M 0) * P * M 0 + adjoint (M 1) * Q * M 1 \\<le>\\<^sub>L\n    1\\<^sub>m d", "have dM0: \"M0 \\<in> carrier_mat d d\" and dM1: \"M1 \\<in> carrier_mat d d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M0 \\<in> carrier_mat d d &&& M1 \\<in> carrier_mat d d", "using m M0_def M1_def measurement_def"], ["proof (prove)\nusing this:\n  measurement d 2 M\n  M0 = M 0\n  M1 = M 1\n  measurement ?d ?n ?M =\n  ((\\<forall>j<?n. ?M j \\<in> carrier_mat ?d ?d) \\<and>\n   matrix_sum ?d (\\<lambda>j. adjoint (?M j) * ?M j) ?n = 1\\<^sub>m ?d)\n\ngoal (1 subgoal):\n 1. M0 \\<in> carrier_mat d d &&& M1 \\<in> carrier_mat d d", "by auto"], ["proof (state)\nthis:\n  M0 \\<in> carrier_mat d d\n  M1 \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. adjoint (M 0) * P * M 0 + adjoint (M 1) * Q * M 1 \\<le>\\<^sub>L\n    1\\<^sub>m d", "have \"adjoint M1 * Q * M1 \\<le>\\<^sub>L adjoint M1 * 1\\<^sub>m d * M1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adjoint M1 * Q * M1 \\<le>\\<^sub>L adjoint M1 * 1\\<^sub>m d * M1", "using lowner_le_keep_under_measurement[OF dM1 dQ _ leQ]"], ["proof (prove)\nusing this:\n  1\\<^sub>m d \\<in> carrier_mat d d \\<Longrightarrow>\n  adjoint M1 * Q * M1 \\<le>\\<^sub>L adjoint M1 * 1\\<^sub>m d * M1\n\ngoal (1 subgoal):\n 1. adjoint M1 * Q * M1 \\<le>\\<^sub>L adjoint M1 * 1\\<^sub>m d * M1", "by auto"], ["proof (state)\nthis:\n  adjoint M1 * Q * M1 \\<le>\\<^sub>L adjoint M1 * 1\\<^sub>m d * M1\n\ngoal (1 subgoal):\n 1. adjoint (M 0) * P * M 0 + adjoint (M 1) * Q * M 1 \\<le>\\<^sub>L\n    1\\<^sub>m d", "then"], ["proof (chain)\npicking this:\n  adjoint M1 * Q * M1 \\<le>\\<^sub>L adjoint M1 * 1\\<^sub>m d * M1", "have le1: \"adjoint M1 * Q * M1 \\<le>\\<^sub>L adjoint M1 * M1\""], ["proof (prove)\nusing this:\n  adjoint M1 * Q * M1 \\<le>\\<^sub>L adjoint M1 * 1\\<^sub>m d * M1\n\ngoal (1 subgoal):\n 1. adjoint M1 * Q * M1 \\<le>\\<^sub>L adjoint M1 * M1", "using dM1 dQ"], ["proof (prove)\nusing this:\n  adjoint M1 * Q * M1 \\<le>\\<^sub>L adjoint M1 * 1\\<^sub>m d * M1\n  M1 \\<in> carrier_mat d d\n  Q \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. adjoint M1 * Q * M1 \\<le>\\<^sub>L adjoint M1 * M1", "by fastforce"], ["proof (state)\nthis:\n  adjoint M1 * Q * M1 \\<le>\\<^sub>L adjoint M1 * M1\n\ngoal (1 subgoal):\n 1. adjoint (M 0) * P * M 0 + adjoint (M 1) * Q * M 1 \\<le>\\<^sub>L\n    1\\<^sub>m d", "have \"adjoint M0 * P * M0 \\<le>\\<^sub>L adjoint M0 * 1\\<^sub>m d * M0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adjoint M0 * P * M0 \\<le>\\<^sub>L adjoint M0 * 1\\<^sub>m d * M0", "using lowner_le_keep_under_measurement[OF dM0 dP _ leP]"], ["proof (prove)\nusing this:\n  1\\<^sub>m d \\<in> carrier_mat d d \\<Longrightarrow>\n  adjoint M0 * P * M0 \\<le>\\<^sub>L adjoint M0 * 1\\<^sub>m d * M0\n\ngoal (1 subgoal):\n 1. adjoint M0 * P * M0 \\<le>\\<^sub>L adjoint M0 * 1\\<^sub>m d * M0", "by auto"], ["proof (state)\nthis:\n  adjoint M0 * P * M0 \\<le>\\<^sub>L adjoint M0 * 1\\<^sub>m d * M0\n\ngoal (1 subgoal):\n 1. adjoint (M 0) * P * M 0 + adjoint (M 1) * Q * M 1 \\<le>\\<^sub>L\n    1\\<^sub>m d", "then"], ["proof (chain)\npicking this:\n  adjoint M0 * P * M0 \\<le>\\<^sub>L adjoint M0 * 1\\<^sub>m d * M0", "have le0: \"adjoint M0 * P * M0 \\<le>\\<^sub>L adjoint M0 * M0\""], ["proof (prove)\nusing this:\n  adjoint M0 * P * M0 \\<le>\\<^sub>L adjoint M0 * 1\\<^sub>m d * M0\n\ngoal (1 subgoal):\n 1. adjoint M0 * P * M0 \\<le>\\<^sub>L adjoint M0 * M0", "using dM0 dP"], ["proof (prove)\nusing this:\n  adjoint M0 * P * M0 \\<le>\\<^sub>L adjoint M0 * 1\\<^sub>m d * M0\n  M0 \\<in> carrier_mat d d\n  P \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. adjoint M0 * P * M0 \\<le>\\<^sub>L adjoint M0 * M0", "by fastforce"], ["proof (state)\nthis:\n  adjoint M0 * P * M0 \\<le>\\<^sub>L adjoint M0 * M0\n\ngoal (1 subgoal):\n 1. adjoint (M 0) * P * M 0 + adjoint (M 1) * Q * M 1 \\<le>\\<^sub>L\n    1\\<^sub>m d", "have \"adjoint M0 * P * M0 + adjoint M1 * Q * M1 \\<le>\\<^sub>L adjoint M0 * M0 + adjoint M1 * M1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adjoint M0 * P * M0 + adjoint M1 * Q * M1 \\<le>\\<^sub>L\n    adjoint M0 * M0 + adjoint M1 * M1", "apply (rule lowner_le_add[of \"adjoint M0 * P * M0\" d \"adjoint M0 * M0\" \"adjoint M1 * Q * M1\" \"adjoint M1 * M1\"])"], ["proof (prove)\ngoal (6 subgoals):\n 1. adjoint M0 * P * M0 \\<in> carrier_mat d d\n 2. adjoint M0 * M0 \\<in> carrier_mat d d\n 3. adjoint M1 * Q * M1 \\<in> carrier_mat d d\n 4. adjoint M1 * M1 \\<in> carrier_mat d d\n 5. adjoint M0 * P * M0 \\<le>\\<^sub>L adjoint M0 * M0\n 6. adjoint M1 * Q * M1 \\<le>\\<^sub>L adjoint M1 * M1", "using dM0 dP dM1 dQ le0 le1"], ["proof (prove)\nusing this:\n  M0 \\<in> carrier_mat d d\n  P \\<in> carrier_mat d d\n  M1 \\<in> carrier_mat d d\n  Q \\<in> carrier_mat d d\n  adjoint M0 * P * M0 \\<le>\\<^sub>L adjoint M0 * M0\n  adjoint M1 * Q * M1 \\<le>\\<^sub>L adjoint M1 * M1\n\ngoal (6 subgoals):\n 1. adjoint M0 * P * M0 \\<in> carrier_mat d d\n 2. adjoint M0 * M0 \\<in> carrier_mat d d\n 3. adjoint M1 * Q * M1 \\<in> carrier_mat d d\n 4. adjoint M1 * M1 \\<in> carrier_mat d d\n 5. adjoint M0 * P * M0 \\<le>\\<^sub>L adjoint M0 * M0\n 6. adjoint M1 * Q * M1 \\<le>\\<^sub>L adjoint M1 * M1", "by auto"], ["proof (state)\nthis:\n  adjoint M0 * P * M0 + adjoint M1 * Q * M1 \\<le>\\<^sub>L\n  adjoint M0 * M0 + adjoint M1 * M1\n\ngoal (1 subgoal):\n 1. adjoint (M 0) * P * M 0 + adjoint (M 1) * Q * M 1 \\<le>\\<^sub>L\n    1\\<^sub>m d", "also"], ["proof (state)\nthis:\n  adjoint M0 * P * M0 + adjoint M1 * Q * M1 \\<le>\\<^sub>L\n  adjoint M0 * M0 + adjoint M1 * M1\n\ngoal (1 subgoal):\n 1. adjoint (M 0) * P * M 0 + adjoint (M 1) * Q * M 1 \\<le>\\<^sub>L\n    1\\<^sub>m d", "have \"\\<dots> = 1\\<^sub>m d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adjoint M0 * M0 + adjoint M1 * M1 = 1\\<^sub>m d", "using m M0_def M1_def measurement_id2"], ["proof (prove)\nusing this:\n  measurement d 2 M\n  M0 = M 0\n  M1 = M 1\n  measurement ?d 2 ?M \\<Longrightarrow>\n  adjoint (?M 0) * ?M 0 + adjoint (?M 1) * ?M 1 = 1\\<^sub>m ?d\n\ngoal (1 subgoal):\n 1. adjoint M0 * M0 + adjoint M1 * M1 = 1\\<^sub>m d", "by auto"], ["proof (state)\nthis:\n  adjoint M0 * M0 + adjoint M1 * M1 = 1\\<^sub>m d\n\ngoal (1 subgoal):\n 1. adjoint (M 0) * P * M 0 + adjoint (M 1) * Q * M 1 \\<le>\\<^sub>L\n    1\\<^sub>m d", "finally"], ["proof (chain)\npicking this:\n  adjoint M0 * P * M0 + adjoint M1 * Q * M1 \\<le>\\<^sub>L 1\\<^sub>m d", "show \"adjoint M0 * P * M0 + adjoint M1 * Q * M1 \\<le>\\<^sub>L 1\\<^sub>m d\""], ["proof (prove)\nusing this:\n  adjoint M0 * P * M0 + adjoint M1 * Q * M1 \\<le>\\<^sub>L 1\\<^sub>m d\n\ngoal (1 subgoal):\n 1. adjoint M0 * P * M0 + adjoint M1 * Q * M1 \\<le>\\<^sub>L 1\\<^sub>m d", "."], ["proof (state)\nthis:\n  adjoint M0 * P * M0 + adjoint M1 * Q * M1 \\<le>\\<^sub>L 1\\<^sub>m d\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma wlp_while_n_close:\n  assumes close: \"\\<And>P. is_quantum_predicate P \\<Longrightarrow> is_quantum_predicate (WS P)\"\n    and m: \"measurement d 2 M\" and qpP: \"is_quantum_predicate P\"\n  shows \"is_quantum_predicate (wlp_while_n (M 0) (M 1) WS k P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_quantum_predicate (wlp_while_n (M 0) (M 1) WS k P)", "proof (induct k)"], ["proof (state)\ngoal (2 subgoals):\n 1. is_quantum_predicate (wlp_while_n (M 0) (M 1) WS 0 P)\n 2. \\<And>k.\n       is_quantum_predicate\n        (wlp_while_n (M 0) (M 1) WS k P) \\<Longrightarrow>\n       is_quantum_predicate (wlp_while_n (M 0) (M 1) WS (Suc k) P)", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. is_quantum_predicate (wlp_while_n (M 0) (M 1) WS 0 P)\n 2. \\<And>k.\n       is_quantum_predicate\n        (wlp_while_n (M 0) (M 1) WS k P) \\<Longrightarrow>\n       is_quantum_predicate (wlp_while_n (M 0) (M 1) WS (Suc k) P)", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_quantum_predicate (wlp_while_n (M 0) (M 1) WS 0 P)", "unfolding wlp_while_n.simps is_quantum_predicate_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1\\<^sub>m d \\<in> carrier_mat d d \\<and>\n    positive (1\\<^sub>m d) \\<and> 1\\<^sub>m d \\<le>\\<^sub>L 1\\<^sub>m d", "using positive_one[of d] lowner_le_refl[of \"1\\<^sub>m d\"]"], ["proof (prove)\nusing this:\n  positive (1\\<^sub>m d)\n  1\\<^sub>m d \\<in> carrier_mat ?n ?n \\<Longrightarrow>\n  1\\<^sub>m d \\<le>\\<^sub>L 1\\<^sub>m d\n\ngoal (1 subgoal):\n 1. 1\\<^sub>m d \\<in> carrier_mat d d \\<and>\n    positive (1\\<^sub>m d) \\<and> 1\\<^sub>m d \\<le>\\<^sub>L 1\\<^sub>m d", "by fastforce"], ["proof (state)\nthis:\n  is_quantum_predicate (wlp_while_n (M 0) (M 1) WS 0 P)\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       is_quantum_predicate\n        (wlp_while_n (M 0) (M 1) WS k P) \\<Longrightarrow>\n       is_quantum_predicate (wlp_while_n (M 0) (M 1) WS (Suc k) P)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k.\n       is_quantum_predicate\n        (wlp_while_n (M 0) (M 1) WS k P) \\<Longrightarrow>\n       is_quantum_predicate (wlp_while_n (M 0) (M 1) WS (Suc k) P)", "case (Suc k)"], ["proof (state)\nthis:\n  is_quantum_predicate (wlp_while_n (M 0) (M 1) WS k P)\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       is_quantum_predicate\n        (wlp_while_n (M 0) (M 1) WS k P) \\<Longrightarrow>\n       is_quantum_predicate (wlp_while_n (M 0) (M 1) WS (Suc k) P)", "define M0 where \"M0 = M 0\""], ["proof (state)\nthis:\n  M0 = M 0\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       is_quantum_predicate\n        (wlp_while_n (M 0) (M 1) WS k P) \\<Longrightarrow>\n       is_quantum_predicate (wlp_while_n (M 0) (M 1) WS (Suc k) P)", "define M1 where \"M1 = M 1\""], ["proof (state)\nthis:\n  M1 = M 1\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       is_quantum_predicate\n        (wlp_while_n (M 0) (M 1) WS k P) \\<Longrightarrow>\n       is_quantum_predicate (wlp_while_n (M 0) (M 1) WS (Suc k) P)", "define W where \"W k = wlp_while_n M0 M1 WS k P\" for k"], ["proof (state)\nthis:\n  W ?k = wlp_while_n M0 M1 WS ?k P\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       is_quantum_predicate\n        (wlp_while_n (M 0) (M 1) WS k P) \\<Longrightarrow>\n       is_quantum_predicate (wlp_while_n (M 0) (M 1) WS (Suc k) P)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_quantum_predicate (wlp_while_n (M 0) (M 1) WS (Suc k) P)", "unfolding wlp_while_n.simps is_quantum_predicate_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. adjoint (M 0) * P * M 0 +\n    adjoint (M 1) * WS (wlp_while_n (M 0) (M 1) WS k P) * M 1\n    \\<in> carrier_mat d d \\<and>\n    positive\n     (adjoint (M 0) * P * M 0 +\n      adjoint (M 1) * WS (wlp_while_n (M 0) (M 1) WS k P) * M 1) \\<and>\n    adjoint (M 0) * P * M 0 +\n    adjoint (M 1) * WS (wlp_while_n (M 0) (M 1) WS k P) * M 1 \\<le>\\<^sub>L\n    1\\<^sub>m d", "proof (fold M0_def M1_def, fold W_def, auto)"], ["proof (state)\ngoal (3 subgoals):\n 1. adjoint M0 * P * M0 + adjoint M1 * WS (W k) * M1 \\<in> carrier_mat d d\n 2. positive (adjoint M0 * P * M0 + adjoint M1 * WS (W k) * M1)\n 3. adjoint M0 * P * M0 + adjoint M1 * WS (W k) * M1 \\<le>\\<^sub>L\n    1\\<^sub>m d", "have dM0: \"M0 \\<in> carrier_mat d d\" and dM1: \"M1 \\<in> carrier_mat d d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M0 \\<in> carrier_mat d d &&& M1 \\<in> carrier_mat d d", "using m M0_def M1_def measurement_def"], ["proof (prove)\nusing this:\n  measurement d 2 M\n  M0 = M 0\n  M1 = M 1\n  measurement ?d ?n ?M =\n  ((\\<forall>j<?n. ?M j \\<in> carrier_mat ?d ?d) \\<and>\n   matrix_sum ?d (\\<lambda>j. adjoint (?M j) * ?M j) ?n = 1\\<^sub>m ?d)\n\ngoal (1 subgoal):\n 1. M0 \\<in> carrier_mat d d &&& M1 \\<in> carrier_mat d d", "by auto"], ["proof (state)\nthis:\n  M0 \\<in> carrier_mat d d\n  M1 \\<in> carrier_mat d d\n\ngoal (3 subgoals):\n 1. adjoint M0 * P * M0 + adjoint M1 * WS (W k) * M1 \\<in> carrier_mat d d\n 2. positive (adjoint M0 * P * M0 + adjoint M1 * WS (W k) * M1)\n 3. adjoint M0 * P * M0 + adjoint M1 * WS (W k) * M1 \\<le>\\<^sub>L\n    1\\<^sub>m d", "have dP:  \"P \\<in> carrier_mat d d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<in> carrier_mat d d", "using qpP is_quantum_predicate_def"], ["proof (prove)\nusing this:\n  is_quantum_predicate P\n  is_quantum_predicate ?P =\n  (?P \\<in> carrier_mat d d \\<and>\n   positive ?P \\<and> ?P \\<le>\\<^sub>L 1\\<^sub>m d)\n\ngoal (1 subgoal):\n 1. P \\<in> carrier_mat d d", "by auto"], ["proof (state)\nthis:\n  P \\<in> carrier_mat d d\n\ngoal (3 subgoals):\n 1. adjoint M0 * P * M0 + adjoint M1 * WS (W k) * M1 \\<in> carrier_mat d d\n 2. positive (adjoint M0 * P * M0 + adjoint M1 * WS (W k) * M1)\n 3. adjoint M0 * P * M0 + adjoint M1 * WS (W k) * M1 \\<le>\\<^sub>L\n    1\\<^sub>m d", "have qpWk: \"is_quantum_predicate (W k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_quantum_predicate (W k)", "using Suc M0_def M1_def W_def"], ["proof (prove)\nusing this:\n  is_quantum_predicate (wlp_while_n (M 0) (M 1) WS k P)\n  M0 = M 0\n  M1 = M 1\n  W ?k = wlp_while_n M0 M1 WS ?k P\n\ngoal (1 subgoal):\n 1. is_quantum_predicate (W k)", "by auto"], ["proof (state)\nthis:\n  is_quantum_predicate (W k)\n\ngoal (3 subgoals):\n 1. adjoint M0 * P * M0 + adjoint M1 * WS (W k) * M1 \\<in> carrier_mat d d\n 2. positive (adjoint M0 * P * M0 + adjoint M1 * WS (W k) * M1)\n 3. adjoint M0 * P * M0 + adjoint M1 * WS (W k) * M1 \\<le>\\<^sub>L\n    1\\<^sub>m d", "then"], ["proof (chain)\npicking this:\n  is_quantum_predicate (W k)", "have qpWWk: \"is_quantum_predicate (WS (W k))\""], ["proof (prove)\nusing this:\n  is_quantum_predicate (W k)\n\ngoal (1 subgoal):\n 1. is_quantum_predicate (WS (W k))", "using close"], ["proof (prove)\nusing this:\n  is_quantum_predicate (W k)\n  is_quantum_predicate ?P \\<Longrightarrow> is_quantum_predicate (WS ?P)\n\ngoal (1 subgoal):\n 1. is_quantum_predicate (WS (W k))", "by auto"], ["proof (state)\nthis:\n  is_quantum_predicate (WS (W k))\n\ngoal (3 subgoals):\n 1. adjoint M0 * P * M0 + adjoint M1 * WS (W k) * M1 \\<in> carrier_mat d d\n 2. positive (adjoint M0 * P * M0 + adjoint M1 * WS (W k) * M1)\n 3. adjoint M0 * P * M0 + adjoint M1 * WS (W k) * M1 \\<le>\\<^sub>L\n    1\\<^sub>m d", "from qpWk"], ["proof (chain)\npicking this:\n  is_quantum_predicate (W k)", "have dWk: \"W k \\<in> carrier_mat d d\""], ["proof (prove)\nusing this:\n  is_quantum_predicate (W k)\n\ngoal (1 subgoal):\n 1. W k \\<in> carrier_mat d d", "using is_quantum_predicate_def"], ["proof (prove)\nusing this:\n  is_quantum_predicate (W k)\n  is_quantum_predicate ?P =\n  (?P \\<in> carrier_mat d d \\<and>\n   positive ?P \\<and> ?P \\<le>\\<^sub>L 1\\<^sub>m d)\n\ngoal (1 subgoal):\n 1. W k \\<in> carrier_mat d d", "by auto"], ["proof (state)\nthis:\n  W k \\<in> carrier_mat d d\n\ngoal (3 subgoals):\n 1. adjoint M0 * P * M0 + adjoint M1 * WS (W k) * M1 \\<in> carrier_mat d d\n 2. positive (adjoint M0 * P * M0 + adjoint M1 * WS (W k) * M1)\n 3. adjoint M0 * P * M0 + adjoint M1 * WS (W k) * M1 \\<le>\\<^sub>L\n    1\\<^sub>m d", "from qpWWk"], ["proof (chain)\npicking this:\n  is_quantum_predicate (WS (W k))", "have dWWk: \"WS (W k) \\<in> carrier_mat d d\""], ["proof (prove)\nusing this:\n  is_quantum_predicate (WS (W k))\n\ngoal (1 subgoal):\n 1. WS (W k) \\<in> carrier_mat d d", "using is_quantum_predicate_def"], ["proof (prove)\nusing this:\n  is_quantum_predicate (WS (W k))\n  is_quantum_predicate ?P =\n  (?P \\<in> carrier_mat d d \\<and>\n   positive ?P \\<and> ?P \\<le>\\<^sub>L 1\\<^sub>m d)\n\ngoal (1 subgoal):\n 1. WS (W k) \\<in> carrier_mat d d", "by auto"], ["proof (state)\nthis:\n  WS (W k) \\<in> carrier_mat d d\n\ngoal (3 subgoals):\n 1. adjoint M0 * P * M0 + adjoint M1 * WS (W k) * M1 \\<in> carrier_mat d d\n 2. positive (adjoint M0 * P * M0 + adjoint M1 * WS (W k) * M1)\n 3. adjoint M0 * P * M0 + adjoint M1 * WS (W k) * M1 \\<le>\\<^sub>L\n    1\\<^sub>m d", "show \"adjoint M0 * P * M0 + adjoint M1 * WS (W k) * M1 \\<in> carrier_mat d d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adjoint M0 * P * M0 + adjoint M1 * WS (W k) * M1 \\<in> carrier_mat d d", "using dM0 dP dM1 dWWk"], ["proof (prove)\nusing this:\n  M0 \\<in> carrier_mat d d\n  P \\<in> carrier_mat d d\n  M1 \\<in> carrier_mat d d\n  WS (W k) \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. adjoint M0 * P * M0 + adjoint M1 * WS (W k) * M1 \\<in> carrier_mat d d", "by auto"], ["proof (state)\nthis:\n  adjoint M0 * P * M0 + adjoint M1 * WS (W k) * M1 \\<in> carrier_mat d d\n\ngoal (2 subgoals):\n 1. positive (adjoint M0 * P * M0 + adjoint M1 * WS (W k) * M1)\n 2. adjoint M0 * P * M0 + adjoint M1 * WS (W k) * M1 \\<le>\\<^sub>L\n    1\\<^sub>m d", "have pP: \"positive P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. positive P", "using qpP is_quantum_predicate_def"], ["proof (prove)\nusing this:\n  is_quantum_predicate P\n  is_quantum_predicate ?P =\n  (?P \\<in> carrier_mat d d \\<and>\n   positive ?P \\<and> ?P \\<le>\\<^sub>L 1\\<^sub>m d)\n\ngoal (1 subgoal):\n 1. positive P", "by auto"], ["proof (state)\nthis:\n  positive P\n\ngoal (2 subgoals):\n 1. positive (adjoint M0 * P * M0 + adjoint M1 * WS (W k) * M1)\n 2. adjoint M0 * P * M0 + adjoint M1 * WS (W k) * M1 \\<le>\\<^sub>L\n    1\\<^sub>m d", "then"], ["proof (chain)\npicking this:\n  positive P", "have pM0P: \"positive (adjoint M0 * P * M0)\""], ["proof (prove)\nusing this:\n  positive P\n\ngoal (1 subgoal):\n 1. positive (adjoint M0 * P * M0)", "using positive_close_under_left_right_mult_adjoint[OF adjoint_dim[OF dM0]] dM0 dP adjoint_adjoint[of M0]"], ["proof (prove)\nusing this:\n  positive P\n  \\<lbrakk>?A \\<in> carrier_mat d d; positive ?A\\<rbrakk>\n  \\<Longrightarrow> positive (adjoint M0 * ?A * adjoint (adjoint M0))\n  M0 \\<in> carrier_mat d d\n  P \\<in> carrier_mat d d\n  adjoint (adjoint M0) = M0\n\ngoal (1 subgoal):\n 1. positive (adjoint M0 * P * M0)", "by auto"], ["proof (state)\nthis:\n  positive (adjoint M0 * P * M0)\n\ngoal (2 subgoals):\n 1. positive (adjoint M0 * P * M0 + adjoint M1 * WS (W k) * M1)\n 2. adjoint M0 * P * M0 + adjoint M1 * WS (W k) * M1 \\<le>\\<^sub>L\n    1\\<^sub>m d", "have pWWk: \"positive (WS (W k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. positive (WS (W k))", "using qpWWk is_quantum_predicate_def"], ["proof (prove)\nusing this:\n  is_quantum_predicate (WS (W k))\n  is_quantum_predicate ?P =\n  (?P \\<in> carrier_mat d d \\<and>\n   positive ?P \\<and> ?P \\<le>\\<^sub>L 1\\<^sub>m d)\n\ngoal (1 subgoal):\n 1. positive (WS (W k))", "by auto"], ["proof (state)\nthis:\n  positive (WS (W k))\n\ngoal (2 subgoals):\n 1. positive (adjoint M0 * P * M0 + adjoint M1 * WS (W k) * M1)\n 2. adjoint M0 * P * M0 + adjoint M1 * WS (W k) * M1 \\<le>\\<^sub>L\n    1\\<^sub>m d", "then"], ["proof (chain)\npicking this:\n  positive (WS (W k))", "have pM1WWk: \"positive (adjoint M1 * WS (W k) * M1)\""], ["proof (prove)\nusing this:\n  positive (WS (W k))\n\ngoal (1 subgoal):\n 1. positive (adjoint M1 * WS (W k) * M1)", "using positive_close_under_left_right_mult_adjoint[OF adjoint_dim[OF dM1]] dM1 dWWk adjoint_adjoint[of M1]"], ["proof (prove)\nusing this:\n  positive (WS (W k))\n  \\<lbrakk>?A \\<in> carrier_mat d d; positive ?A\\<rbrakk>\n  \\<Longrightarrow> positive (adjoint M1 * ?A * adjoint (adjoint M1))\n  M1 \\<in> carrier_mat d d\n  WS (W k) \\<in> carrier_mat d d\n  adjoint (adjoint M1) = M1\n\ngoal (1 subgoal):\n 1. positive (adjoint M1 * WS (W k) * M1)", "by auto"], ["proof (state)\nthis:\n  positive (adjoint M1 * WS (W k) * M1)\n\ngoal (2 subgoals):\n 1. positive (adjoint M0 * P * M0 + adjoint M1 * WS (W k) * M1)\n 2. adjoint M0 * P * M0 + adjoint M1 * WS (W k) * M1 \\<le>\\<^sub>L\n    1\\<^sub>m d", "then"], ["proof (chain)\npicking this:\n  positive (adjoint M1 * WS (W k) * M1)", "show \"positive (adjoint M0 * P * M0 + adjoint M1 * WS (W k) * M1)\""], ["proof (prove)\nusing this:\n  positive (adjoint M1 * WS (W k) * M1)\n\ngoal (1 subgoal):\n 1. positive (adjoint M0 * P * M0 + adjoint M1 * WS (W k) * M1)", "using positive_add[OF pM0P pM1WWk] dM0 dP dM1 dWWk"], ["proof (prove)\nusing this:\n  positive (adjoint M1 * WS (W k) * M1)\n  \\<lbrakk>adjoint M0 * P * M0 \\<in> carrier_mat ?n ?n;\n   adjoint M1 * WS (W k) * M1 \\<in> carrier_mat ?n ?n\\<rbrakk>\n  \\<Longrightarrow> positive\n                     (adjoint M0 * P * M0 + adjoint M1 * WS (W k) * M1)\n  M0 \\<in> carrier_mat d d\n  P \\<in> carrier_mat d d\n  M1 \\<in> carrier_mat d d\n  WS (W k) \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. positive (adjoint M0 * P * M0 + adjoint M1 * WS (W k) * M1)", "by fastforce"], ["proof (state)\nthis:\n  positive (adjoint M0 * P * M0 + adjoint M1 * WS (W k) * M1)\n\ngoal (1 subgoal):\n 1. adjoint M0 * P * M0 + adjoint M1 * WS (W k) * M1 \\<le>\\<^sub>L\n    1\\<^sub>m d", "have leWWk: \"WS (W k) \\<le>\\<^sub>L 1\\<^sub>m d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. WS (W k) \\<le>\\<^sub>L 1\\<^sub>m d", "using qpWWk is_quantum_predicate_def"], ["proof (prove)\nusing this:\n  is_quantum_predicate (WS (W k))\n  is_quantum_predicate ?P =\n  (?P \\<in> carrier_mat d d \\<and>\n   positive ?P \\<and> ?P \\<le>\\<^sub>L 1\\<^sub>m d)\n\ngoal (1 subgoal):\n 1. WS (W k) \\<le>\\<^sub>L 1\\<^sub>m d", "by auto"], ["proof (state)\nthis:\n  WS (W k) \\<le>\\<^sub>L 1\\<^sub>m d\n\ngoal (1 subgoal):\n 1. adjoint M0 * P * M0 + adjoint M1 * WS (W k) * M1 \\<le>\\<^sub>L\n    1\\<^sub>m d", "have leP: \"P \\<le>\\<^sub>L 1\\<^sub>m d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<le>\\<^sub>L 1\\<^sub>m d", "using qpP is_quantum_predicate_def"], ["proof (prove)\nusing this:\n  is_quantum_predicate P\n  is_quantum_predicate ?P =\n  (?P \\<in> carrier_mat d d \\<and>\n   positive ?P \\<and> ?P \\<le>\\<^sub>L 1\\<^sub>m d)\n\ngoal (1 subgoal):\n 1. P \\<le>\\<^sub>L 1\\<^sub>m d", "by auto"], ["proof (state)\nthis:\n  P \\<le>\\<^sub>L 1\\<^sub>m d\n\ngoal (1 subgoal):\n 1. adjoint M0 * P * M0 + adjoint M1 * WS (W k) * M1 \\<le>\\<^sub>L\n    1\\<^sub>m d", "show \"(adjoint M0 * P * M0 + adjoint M1 * WS (W k) * M1) \\<le>\\<^sub>L 1\\<^sub>m d \""], ["proof (prove)\ngoal (1 subgoal):\n 1. adjoint M0 * P * M0 + adjoint M1 * WS (W k) * M1 \\<le>\\<^sub>L\n    1\\<^sub>m d", "using measurement2_leq_one_mat[OF dP dWWk leP leWWk m] M0_def M1_def"], ["proof (prove)\nusing this:\n  adjoint (M 0) * P * M 0 + adjoint (M 1) * WS (W k) * M 1 \\<le>\\<^sub>L\n  1\\<^sub>m d\n  M0 = M 0\n  M1 = M 1\n\ngoal (1 subgoal):\n 1. adjoint M0 * P * M0 + adjoint M1 * WS (W k) * M1 \\<le>\\<^sub>L\n    1\\<^sub>m d", "by auto"], ["proof (state)\nthis:\n  adjoint M0 * P * M0 + adjoint M1 * WS (W k) * M1 \\<le>\\<^sub>L 1\\<^sub>m d\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  is_quantum_predicate (wlp_while_n (M 0) (M 1) WS (Suc k) P)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma wlp_while_n_mono:\n  assumes \"\\<And>P. is_quantum_predicate P \\<Longrightarrow> is_quantum_predicate (WS P)\"\n    and \"\\<And>P Q. is_quantum_predicate P \\<Longrightarrow> is_quantum_predicate Q \\<Longrightarrow> P \\<le>\\<^sub>L Q \\<Longrightarrow> WS P \\<le>\\<^sub>L WS Q\"\n    and \"measurement d 2 M\"\n    and \"is_quantum_predicate P\"\n    and \"is_quantum_predicate Q\"\n    and \"P \\<le>\\<^sub>L Q\"\n  shows \"(wlp_while_n (M 0) (M 1) WS k P) \\<le>\\<^sub>L (wlp_while_n (M 0) (M 1) WS k Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wlp_while_n (M 0) (M 1) WS k P \\<le>\\<^sub>L\n    wlp_while_n (M 0) (M 1) WS k Q", "proof (induct k)"], ["proof (state)\ngoal (2 subgoals):\n 1. wlp_while_n (M 0) (M 1) WS 0 P \\<le>\\<^sub>L\n    wlp_while_n (M 0) (M 1) WS 0 Q\n 2. \\<And>k.\n       wlp_while_n (M 0) (M 1) WS k P \\<le>\\<^sub>L\n       wlp_while_n (M 0) (M 1) WS k Q \\<Longrightarrow>\n       wlp_while_n (M 0) (M 1) WS (Suc k) P \\<le>\\<^sub>L\n       wlp_while_n (M 0) (M 1) WS (Suc k) Q", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. wlp_while_n (M 0) (M 1) WS 0 P \\<le>\\<^sub>L\n    wlp_while_n (M 0) (M 1) WS 0 Q\n 2. \\<And>k.\n       wlp_while_n (M 0) (M 1) WS k P \\<le>\\<^sub>L\n       wlp_while_n (M 0) (M 1) WS k Q \\<Longrightarrow>\n       wlp_while_n (M 0) (M 1) WS (Suc k) P \\<le>\\<^sub>L\n       wlp_while_n (M 0) (M 1) WS (Suc k) Q", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. wlp_while_n (M 0) (M 1) WS 0 P \\<le>\\<^sub>L\n    wlp_while_n (M 0) (M 1) WS 0 Q", "unfolding wlp_while_n.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1\\<^sub>m d \\<le>\\<^sub>L 1\\<^sub>m d", "using lowner_le_refl[of \"1\\<^sub>m d\"]"], ["proof (prove)\nusing this:\n  1\\<^sub>m d \\<in> carrier_mat ?n ?n \\<Longrightarrow>\n  1\\<^sub>m d \\<le>\\<^sub>L 1\\<^sub>m d\n\ngoal (1 subgoal):\n 1. 1\\<^sub>m d \\<le>\\<^sub>L 1\\<^sub>m d", "by fastforce"], ["proof (state)\nthis:\n  wlp_while_n (M 0) (M 1) WS 0 P \\<le>\\<^sub>L\n  wlp_while_n (M 0) (M 1) WS 0 Q\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       wlp_while_n (M 0) (M 1) WS k P \\<le>\\<^sub>L\n       wlp_while_n (M 0) (M 1) WS k Q \\<Longrightarrow>\n       wlp_while_n (M 0) (M 1) WS (Suc k) P \\<le>\\<^sub>L\n       wlp_while_n (M 0) (M 1) WS (Suc k) Q", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k.\n       wlp_while_n (M 0) (M 1) WS k P \\<le>\\<^sub>L\n       wlp_while_n (M 0) (M 1) WS k Q \\<Longrightarrow>\n       wlp_while_n (M 0) (M 1) WS (Suc k) P \\<le>\\<^sub>L\n       wlp_while_n (M 0) (M 1) WS (Suc k) Q", "case (Suc k)"], ["proof (state)\nthis:\n  wlp_while_n (M 0) (M 1) WS k P \\<le>\\<^sub>L\n  wlp_while_n (M 0) (M 1) WS k Q\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       wlp_while_n (M 0) (M 1) WS k P \\<le>\\<^sub>L\n       wlp_while_n (M 0) (M 1) WS k Q \\<Longrightarrow>\n       wlp_while_n (M 0) (M 1) WS (Suc k) P \\<le>\\<^sub>L\n       wlp_while_n (M 0) (M 1) WS (Suc k) Q", "define M0 where \"M0 = M 0\""], ["proof (state)\nthis:\n  M0 = M 0\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       wlp_while_n (M 0) (M 1) WS k P \\<le>\\<^sub>L\n       wlp_while_n (M 0) (M 1) WS k Q \\<Longrightarrow>\n       wlp_while_n (M 0) (M 1) WS (Suc k) P \\<le>\\<^sub>L\n       wlp_while_n (M 0) (M 1) WS (Suc k) Q", "define M1 where \"M1 = M 1\""], ["proof (state)\nthis:\n  M1 = M 1\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       wlp_while_n (M 0) (M 1) WS k P \\<le>\\<^sub>L\n       wlp_while_n (M 0) (M 1) WS k Q \\<Longrightarrow>\n       wlp_while_n (M 0) (M 1) WS (Suc k) P \\<le>\\<^sub>L\n       wlp_while_n (M 0) (M 1) WS (Suc k) Q", "have dM0: \"M0 \\<in> carrier_mat d d\" and dM1: \"M1 \\<in> carrier_mat d d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M0 \\<in> carrier_mat d d &&& M1 \\<in> carrier_mat d d", "using assms M0_def M1_def measurement_def"], ["proof (prove)\nusing this:\n  is_quantum_predicate ?P \\<Longrightarrow> is_quantum_predicate (WS ?P)\n  \\<lbrakk>is_quantum_predicate ?P; is_quantum_predicate ?Q;\n   ?P \\<le>\\<^sub>L ?Q\\<rbrakk>\n  \\<Longrightarrow> WS ?P \\<le>\\<^sub>L WS ?Q\n  measurement d 2 M\n  is_quantum_predicate P\n  is_quantum_predicate Q\n  P \\<le>\\<^sub>L Q\n  M0 = M 0\n  M1 = M 1\n  measurement ?d ?n ?M =\n  ((\\<forall>j<?n. ?M j \\<in> carrier_mat ?d ?d) \\<and>\n   matrix_sum ?d (\\<lambda>j. adjoint (?M j) * ?M j) ?n = 1\\<^sub>m ?d)\n\ngoal (1 subgoal):\n 1. M0 \\<in> carrier_mat d d &&& M1 \\<in> carrier_mat d d", "by auto"], ["proof (state)\nthis:\n  M0 \\<in> carrier_mat d d\n  M1 \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       wlp_while_n (M 0) (M 1) WS k P \\<le>\\<^sub>L\n       wlp_while_n (M 0) (M 1) WS k Q \\<Longrightarrow>\n       wlp_while_n (M 0) (M 1) WS (Suc k) P \\<le>\\<^sub>L\n       wlp_while_n (M 0) (M 1) WS (Suc k) Q", "define W where \"W P k = wlp_while_n M0 M1 WS k P\" for k P"], ["proof (state)\nthis:\n  W ?P ?k = wlp_while_n M0 M1 WS ?k ?P\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       wlp_while_n (M 0) (M 1) WS k P \\<le>\\<^sub>L\n       wlp_while_n (M 0) (M 1) WS k Q \\<Longrightarrow>\n       wlp_while_n (M 0) (M 1) WS (Suc k) P \\<le>\\<^sub>L\n       wlp_while_n (M 0) (M 1) WS (Suc k) Q", "have dP: \"P \\<in> carrier_mat d d\" and dQ: \"Q \\<in> carrier_mat d d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<in> carrier_mat d d &&& Q \\<in> carrier_mat d d", "using assms is_quantum_predicate_def"], ["proof (prove)\nusing this:\n  is_quantum_predicate ?P \\<Longrightarrow> is_quantum_predicate (WS ?P)\n  \\<lbrakk>is_quantum_predicate ?P; is_quantum_predicate ?Q;\n   ?P \\<le>\\<^sub>L ?Q\\<rbrakk>\n  \\<Longrightarrow> WS ?P \\<le>\\<^sub>L WS ?Q\n  measurement d 2 M\n  is_quantum_predicate P\n  is_quantum_predicate Q\n  P \\<le>\\<^sub>L Q\n  is_quantum_predicate ?P =\n  (?P \\<in> carrier_mat d d \\<and>\n   positive ?P \\<and> ?P \\<le>\\<^sub>L 1\\<^sub>m d)\n\ngoal (1 subgoal):\n 1. P \\<in> carrier_mat d d &&& Q \\<in> carrier_mat d d", "by auto"], ["proof (state)\nthis:\n  P \\<in> carrier_mat d d\n  Q \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       wlp_while_n (M 0) (M 1) WS k P \\<le>\\<^sub>L\n       wlp_while_n (M 0) (M 1) WS k Q \\<Longrightarrow>\n       wlp_while_n (M 0) (M 1) WS (Suc k) P \\<le>\\<^sub>L\n       wlp_while_n (M 0) (M 1) WS (Suc k) Q", "have eq1: \"W P (Suc k) = adjoint M0 * P * M0 + adjoint M1 * (WS (W P k)) * M1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. W P (Suc k) = adjoint M0 * P * M0 + adjoint M1 * WS (W P k) * M1", "unfolding W_def wlp_while_n.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. adjoint M0 * P * M0 + adjoint M1 * WS (wlp_while_n M0 M1 WS k P) * M1 =\n    adjoint M0 * P * M0 + adjoint M1 * WS (wlp_while_n M0 M1 WS k P) * M1", "by auto"], ["proof (state)\nthis:\n  W P (Suc k) = adjoint M0 * P * M0 + adjoint M1 * WS (W P k) * M1\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       wlp_while_n (M 0) (M 1) WS k P \\<le>\\<^sub>L\n       wlp_while_n (M 0) (M 1) WS k Q \\<Longrightarrow>\n       wlp_while_n (M 0) (M 1) WS (Suc k) P \\<le>\\<^sub>L\n       wlp_while_n (M 0) (M 1) WS (Suc k) Q", "have eq2: \"W Q (Suc k) = adjoint M0 * Q * M0 + adjoint M1 * (WS (W Q k)) * M1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. W Q (Suc k) = adjoint M0 * Q * M0 + adjoint M1 * WS (W Q k) * M1", "unfolding W_def wlp_while_n.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. adjoint M0 * Q * M0 + adjoint M1 * WS (wlp_while_n M0 M1 WS k Q) * M1 =\n    adjoint M0 * Q * M0 + adjoint M1 * WS (wlp_while_n M0 M1 WS k Q) * M1", "by auto"], ["proof (state)\nthis:\n  W Q (Suc k) = adjoint M0 * Q * M0 + adjoint M1 * WS (W Q k) * M1\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       wlp_while_n (M 0) (M 1) WS k P \\<le>\\<^sub>L\n       wlp_while_n (M 0) (M 1) WS k Q \\<Longrightarrow>\n       wlp_while_n (M 0) (M 1) WS (Suc k) P \\<le>\\<^sub>L\n       wlp_while_n (M 0) (M 1) WS (Suc k) Q", "have le1: \"adjoint M0 * P * M0 \\<le>\\<^sub>L adjoint M0 * Q * M0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adjoint M0 * P * M0 \\<le>\\<^sub>L adjoint M0 * Q * M0", "using lowner_le_keep_under_measurement dM0 dP dQ assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>?M \\<in> carrier_mat ?n ?n; ?A \\<in> carrier_mat ?n ?n;\n   ?B \\<in> carrier_mat ?n ?n; ?A \\<le>\\<^sub>L ?B\\<rbrakk>\n  \\<Longrightarrow> adjoint ?M * ?A * ?M \\<le>\\<^sub>L adjoint ?M * ?B * ?M\n  M0 \\<in> carrier_mat d d\n  P \\<in> carrier_mat d d\n  Q \\<in> carrier_mat d d\n  is_quantum_predicate ?P \\<Longrightarrow> is_quantum_predicate (WS ?P)\n  \\<lbrakk>is_quantum_predicate ?P; is_quantum_predicate ?Q;\n   ?P \\<le>\\<^sub>L ?Q\\<rbrakk>\n  \\<Longrightarrow> WS ?P \\<le>\\<^sub>L WS ?Q\n  measurement d 2 M\n  is_quantum_predicate P\n  is_quantum_predicate Q\n  P \\<le>\\<^sub>L Q\n\ngoal (1 subgoal):\n 1. adjoint M0 * P * M0 \\<le>\\<^sub>L adjoint M0 * Q * M0", "by auto"], ["proof (state)\nthis:\n  adjoint M0 * P * M0 \\<le>\\<^sub>L adjoint M0 * Q * M0\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       wlp_while_n (M 0) (M 1) WS k P \\<le>\\<^sub>L\n       wlp_while_n (M 0) (M 1) WS k Q \\<Longrightarrow>\n       wlp_while_n (M 0) (M 1) WS (Suc k) P \\<le>\\<^sub>L\n       wlp_while_n (M 0) (M 1) WS (Suc k) Q", "have leWk: \"(W P k) \\<le>\\<^sub>L (W Q k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. W P k \\<le>\\<^sub>L W Q k", "unfolding W_def M0_def M1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. wlp_while_n (M 0) (M 1) WS k P \\<le>\\<^sub>L\n    wlp_while_n (M 0) (M 1) WS k Q", "using Suc"], ["proof (prove)\nusing this:\n  wlp_while_n (M 0) (M 1) WS k P \\<le>\\<^sub>L\n  wlp_while_n (M 0) (M 1) WS k Q\n\ngoal (1 subgoal):\n 1. wlp_while_n (M 0) (M 1) WS k P \\<le>\\<^sub>L\n    wlp_while_n (M 0) (M 1) WS k Q", "by auto"], ["proof (state)\nthis:\n  W P k \\<le>\\<^sub>L W Q k\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       wlp_while_n (M 0) (M 1) WS k P \\<le>\\<^sub>L\n       wlp_while_n (M 0) (M 1) WS k Q \\<Longrightarrow>\n       wlp_while_n (M 0) (M 1) WS (Suc k) P \\<le>\\<^sub>L\n       wlp_while_n (M 0) (M 1) WS (Suc k) Q", "have qpWPk: \"is_quantum_predicate (W P k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_quantum_predicate (W P k)", "unfolding W_def M0_def M1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_quantum_predicate (wlp_while_n (M 0) (M 1) WS k P)", "using wlp_while_n_close assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>P.\n              is_quantum_predicate P \\<Longrightarrow>\n              is_quantum_predicate (?WS P);\n   measurement d 2 ?M; is_quantum_predicate ?P\\<rbrakk>\n  \\<Longrightarrow> is_quantum_predicate\n                     (wlp_while_n (?M 0) (?M 1) ?WS ?k ?P)\n  is_quantum_predicate ?P \\<Longrightarrow> is_quantum_predicate (WS ?P)\n  \\<lbrakk>is_quantum_predicate ?P; is_quantum_predicate ?Q;\n   ?P \\<le>\\<^sub>L ?Q\\<rbrakk>\n  \\<Longrightarrow> WS ?P \\<le>\\<^sub>L WS ?Q\n  measurement d 2 M\n  is_quantum_predicate P\n  is_quantum_predicate Q\n  P \\<le>\\<^sub>L Q\n\ngoal (1 subgoal):\n 1. is_quantum_predicate (wlp_while_n (M 0) (M 1) WS k P)", "by auto"], ["proof (state)\nthis:\n  is_quantum_predicate (W P k)\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       wlp_while_n (M 0) (M 1) WS k P \\<le>\\<^sub>L\n       wlp_while_n (M 0) (M 1) WS k Q \\<Longrightarrow>\n       wlp_while_n (M 0) (M 1) WS (Suc k) P \\<le>\\<^sub>L\n       wlp_while_n (M 0) (M 1) WS (Suc k) Q", "then"], ["proof (chain)\npicking this:\n  is_quantum_predicate (W P k)", "have \"is_quantum_predicate (WS (W P k))\""], ["proof (prove)\nusing this:\n  is_quantum_predicate (W P k)\n\ngoal (1 subgoal):\n 1. is_quantum_predicate (WS (W P k))", "unfolding W_def M0_def M1_def"], ["proof (prove)\nusing this:\n  is_quantum_predicate (wlp_while_n (M 0) (M 1) WS k P)\n\ngoal (1 subgoal):\n 1. is_quantum_predicate (WS (wlp_while_n (M 0) (M 1) WS k P))", "using assms"], ["proof (prove)\nusing this:\n  is_quantum_predicate (wlp_while_n (M 0) (M 1) WS k P)\n  is_quantum_predicate ?P \\<Longrightarrow> is_quantum_predicate (WS ?P)\n  \\<lbrakk>is_quantum_predicate ?P; is_quantum_predicate ?Q;\n   ?P \\<le>\\<^sub>L ?Q\\<rbrakk>\n  \\<Longrightarrow> WS ?P \\<le>\\<^sub>L WS ?Q\n  measurement d 2 M\n  is_quantum_predicate P\n  is_quantum_predicate Q\n  P \\<le>\\<^sub>L Q\n\ngoal (1 subgoal):\n 1. is_quantum_predicate (WS (wlp_while_n (M 0) (M 1) WS k P))", "by auto"], ["proof (state)\nthis:\n  is_quantum_predicate (WS (W P k))\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       wlp_while_n (M 0) (M 1) WS k P \\<le>\\<^sub>L\n       wlp_while_n (M 0) (M 1) WS k Q \\<Longrightarrow>\n       wlp_while_n (M 0) (M 1) WS (Suc k) P \\<le>\\<^sub>L\n       wlp_while_n (M 0) (M 1) WS (Suc k) Q", "then"], ["proof (chain)\npicking this:\n  is_quantum_predicate (WS (W P k))", "have dWWPk: \"(WS (W P k)) \\<in> carrier_mat d d\""], ["proof (prove)\nusing this:\n  is_quantum_predicate (WS (W P k))\n\ngoal (1 subgoal):\n 1. WS (W P k) \\<in> carrier_mat d d", "using is_quantum_predicate_def"], ["proof (prove)\nusing this:\n  is_quantum_predicate (WS (W P k))\n  is_quantum_predicate ?P =\n  (?P \\<in> carrier_mat d d \\<and>\n   positive ?P \\<and> ?P \\<le>\\<^sub>L 1\\<^sub>m d)\n\ngoal (1 subgoal):\n 1. WS (W P k) \\<in> carrier_mat d d", "by auto"], ["proof (state)\nthis:\n  WS (W P k) \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       wlp_while_n (M 0) (M 1) WS k P \\<le>\\<^sub>L\n       wlp_while_n (M 0) (M 1) WS k Q \\<Longrightarrow>\n       wlp_while_n (M 0) (M 1) WS (Suc k) P \\<le>\\<^sub>L\n       wlp_while_n (M 0) (M 1) WS (Suc k) Q", "have qpWQk: \"is_quantum_predicate (W Q k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_quantum_predicate (W Q k)", "unfolding W_def M0_def M1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_quantum_predicate (wlp_while_n (M 0) (M 1) WS k Q)", "using wlp_while_n_close assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>P.\n              is_quantum_predicate P \\<Longrightarrow>\n              is_quantum_predicate (?WS P);\n   measurement d 2 ?M; is_quantum_predicate ?P\\<rbrakk>\n  \\<Longrightarrow> is_quantum_predicate\n                     (wlp_while_n (?M 0) (?M 1) ?WS ?k ?P)\n  is_quantum_predicate ?P \\<Longrightarrow> is_quantum_predicate (WS ?P)\n  \\<lbrakk>is_quantum_predicate ?P; is_quantum_predicate ?Q;\n   ?P \\<le>\\<^sub>L ?Q\\<rbrakk>\n  \\<Longrightarrow> WS ?P \\<le>\\<^sub>L WS ?Q\n  measurement d 2 M\n  is_quantum_predicate P\n  is_quantum_predicate Q\n  P \\<le>\\<^sub>L Q\n\ngoal (1 subgoal):\n 1. is_quantum_predicate (wlp_while_n (M 0) (M 1) WS k Q)", "by auto"], ["proof (state)\nthis:\n  is_quantum_predicate (W Q k)\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       wlp_while_n (M 0) (M 1) WS k P \\<le>\\<^sub>L\n       wlp_while_n (M 0) (M 1) WS k Q \\<Longrightarrow>\n       wlp_while_n (M 0) (M 1) WS (Suc k) P \\<le>\\<^sub>L\n       wlp_while_n (M 0) (M 1) WS (Suc k) Q", "then"], ["proof (chain)\npicking this:\n  is_quantum_predicate (W Q k)", "have \"is_quantum_predicate (WS (W Q k))\""], ["proof (prove)\nusing this:\n  is_quantum_predicate (W Q k)\n\ngoal (1 subgoal):\n 1. is_quantum_predicate (WS (W Q k))", "unfolding W_def M0_def M1_def"], ["proof (prove)\nusing this:\n  is_quantum_predicate (wlp_while_n (M 0) (M 1) WS k Q)\n\ngoal (1 subgoal):\n 1. is_quantum_predicate (WS (wlp_while_n (M 0) (M 1) WS k Q))", "using assms"], ["proof (prove)\nusing this:\n  is_quantum_predicate (wlp_while_n (M 0) (M 1) WS k Q)\n  is_quantum_predicate ?P \\<Longrightarrow> is_quantum_predicate (WS ?P)\n  \\<lbrakk>is_quantum_predicate ?P; is_quantum_predicate ?Q;\n   ?P \\<le>\\<^sub>L ?Q\\<rbrakk>\n  \\<Longrightarrow> WS ?P \\<le>\\<^sub>L WS ?Q\n  measurement d 2 M\n  is_quantum_predicate P\n  is_quantum_predicate Q\n  P \\<le>\\<^sub>L Q\n\ngoal (1 subgoal):\n 1. is_quantum_predicate (WS (wlp_while_n (M 0) (M 1) WS k Q))", "by auto"], ["proof (state)\nthis:\n  is_quantum_predicate (WS (W Q k))\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       wlp_while_n (M 0) (M 1) WS k P \\<le>\\<^sub>L\n       wlp_while_n (M 0) (M 1) WS k Q \\<Longrightarrow>\n       wlp_while_n (M 0) (M 1) WS (Suc k) P \\<le>\\<^sub>L\n       wlp_while_n (M 0) (M 1) WS (Suc k) Q", "then"], ["proof (chain)\npicking this:\n  is_quantum_predicate (WS (W Q k))", "have dWWQk: \"(WS (W Q k)) \\<in> carrier_mat d d\""], ["proof (prove)\nusing this:\n  is_quantum_predicate (WS (W Q k))\n\ngoal (1 subgoal):\n 1. WS (W Q k) \\<in> carrier_mat d d", "using is_quantum_predicate_def"], ["proof (prove)\nusing this:\n  is_quantum_predicate (WS (W Q k))\n  is_quantum_predicate ?P =\n  (?P \\<in> carrier_mat d d \\<and>\n   positive ?P \\<and> ?P \\<le>\\<^sub>L 1\\<^sub>m d)\n\ngoal (1 subgoal):\n 1. WS (W Q k) \\<in> carrier_mat d d", "by auto"], ["proof (state)\nthis:\n  WS (W Q k) \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       wlp_while_n (M 0) (M 1) WS k P \\<le>\\<^sub>L\n       wlp_while_n (M 0) (M 1) WS k Q \\<Longrightarrow>\n       wlp_while_n (M 0) (M 1) WS (Suc k) P \\<le>\\<^sub>L\n       wlp_while_n (M 0) (M 1) WS (Suc k) Q", "have \"(WS (W P k)) \\<le>\\<^sub>L (WS (W Q k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. WS (W P k) \\<le>\\<^sub>L WS (W Q k)", "using qpWPk qpWQk leWk assms"], ["proof (prove)\nusing this:\n  is_quantum_predicate (W P k)\n  is_quantum_predicate (W Q k)\n  W P k \\<le>\\<^sub>L W Q k\n  is_quantum_predicate ?P \\<Longrightarrow> is_quantum_predicate (WS ?P)\n  \\<lbrakk>is_quantum_predicate ?P; is_quantum_predicate ?Q;\n   ?P \\<le>\\<^sub>L ?Q\\<rbrakk>\n  \\<Longrightarrow> WS ?P \\<le>\\<^sub>L WS ?Q\n  measurement d 2 M\n  is_quantum_predicate P\n  is_quantum_predicate Q\n  P \\<le>\\<^sub>L Q\n\ngoal (1 subgoal):\n 1. WS (W P k) \\<le>\\<^sub>L WS (W Q k)", "by auto"], ["proof (state)\nthis:\n  WS (W P k) \\<le>\\<^sub>L WS (W Q k)\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       wlp_while_n (M 0) (M 1) WS k P \\<le>\\<^sub>L\n       wlp_while_n (M 0) (M 1) WS k Q \\<Longrightarrow>\n       wlp_while_n (M 0) (M 1) WS (Suc k) P \\<le>\\<^sub>L\n       wlp_while_n (M 0) (M 1) WS (Suc k) Q", "then"], ["proof (chain)\npicking this:\n  WS (W P k) \\<le>\\<^sub>L WS (W Q k)", "have le2: \"adjoint M1 * (WS (W P k)) * M1 \\<le>\\<^sub>L adjoint M1 * (WS (W Q k)) * M1\""], ["proof (prove)\nusing this:\n  WS (W P k) \\<le>\\<^sub>L WS (W Q k)\n\ngoal (1 subgoal):\n 1. adjoint M1 * WS (W P k) * M1 \\<le>\\<^sub>L adjoint M1 * WS (W Q k) * M1", "using lowner_le_keep_under_measurement dM1 dWWPk dWWQk"], ["proof (prove)\nusing this:\n  WS (W P k) \\<le>\\<^sub>L WS (W Q k)\n  \\<lbrakk>?M \\<in> carrier_mat ?n ?n; ?A \\<in> carrier_mat ?n ?n;\n   ?B \\<in> carrier_mat ?n ?n; ?A \\<le>\\<^sub>L ?B\\<rbrakk>\n  \\<Longrightarrow> adjoint ?M * ?A * ?M \\<le>\\<^sub>L adjoint ?M * ?B * ?M\n  M1 \\<in> carrier_mat d d\n  WS (W P k) \\<in> carrier_mat d d\n  WS (W Q k) \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. adjoint M1 * WS (W P k) * M1 \\<le>\\<^sub>L adjoint M1 * WS (W Q k) * M1", "by auto"], ["proof (state)\nthis:\n  adjoint M1 * WS (W P k) * M1 \\<le>\\<^sub>L adjoint M1 * WS (W Q k) * M1\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       wlp_while_n (M 0) (M 1) WS k P \\<le>\\<^sub>L\n       wlp_while_n (M 0) (M 1) WS k Q \\<Longrightarrow>\n       wlp_while_n (M 0) (M 1) WS (Suc k) P \\<le>\\<^sub>L\n       wlp_while_n (M 0) (M 1) WS (Suc k) Q", "have \"(adjoint M0 * P * M0 + adjoint M1 * (WS (W P k)) * M1) \\<le>\\<^sub>L (adjoint M0 * Q * M0 + adjoint M1 * (WS (W Q k)) * M1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adjoint M0 * P * M0 + adjoint M1 * WS (W P k) * M1 \\<le>\\<^sub>L\n    adjoint M0 * Q * M0 + adjoint M1 * WS (W Q k) * M1", "using lowner_le_add[OF _ _ _ _ le1 le2] dM0 dP dM1 dQ dWWPk dWWQk le1 le2"], ["proof (prove)\nusing this:\n  \\<lbrakk>adjoint M0 * P * M0 \\<in> carrier_mat ?n ?n;\n   adjoint M0 * Q * M0 \\<in> carrier_mat ?n ?n;\n   adjoint M1 * WS (W P k) * M1 \\<in> carrier_mat ?n ?n;\n   adjoint M1 * WS (W Q k) * M1 \\<in> carrier_mat ?n ?n\\<rbrakk>\n  \\<Longrightarrow> adjoint M0 * P * M0 +\n                    adjoint M1 * WS (W P k) * M1 \\<le>\\<^sub>L\n                    adjoint M0 * Q * M0 + adjoint M1 * WS (W Q k) * M1\n  M0 \\<in> carrier_mat d d\n  P \\<in> carrier_mat d d\n  M1 \\<in> carrier_mat d d\n  Q \\<in> carrier_mat d d\n  WS (W P k) \\<in> carrier_mat d d\n  WS (W Q k) \\<in> carrier_mat d d\n  adjoint M0 * P * M0 \\<le>\\<^sub>L adjoint M0 * Q * M0\n  adjoint M1 * WS (W P k) * M1 \\<le>\\<^sub>L adjoint M1 * WS (W Q k) * M1\n\ngoal (1 subgoal):\n 1. adjoint M0 * P * M0 + adjoint M1 * WS (W P k) * M1 \\<le>\\<^sub>L\n    adjoint M0 * Q * M0 + adjoint M1 * WS (W Q k) * M1", "by fastforce"], ["proof (state)\nthis:\n  adjoint M0 * P * M0 + adjoint M1 * WS (W P k) * M1 \\<le>\\<^sub>L\n  adjoint M0 * Q * M0 + adjoint M1 * WS (W Q k) * M1\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       wlp_while_n (M 0) (M 1) WS k P \\<le>\\<^sub>L\n       wlp_while_n (M 0) (M 1) WS k Q \\<Longrightarrow>\n       wlp_while_n (M 0) (M 1) WS (Suc k) P \\<le>\\<^sub>L\n       wlp_while_n (M 0) (M 1) WS (Suc k) Q", "then"], ["proof (chain)\npicking this:\n  adjoint M0 * P * M0 + adjoint M1 * WS (W P k) * M1 \\<le>\\<^sub>L\n  adjoint M0 * Q * M0 + adjoint M1 * WS (W Q k) * M1", "have \"W P (Suc k) \\<le>\\<^sub>L W Q (Suc k)\""], ["proof (prove)\nusing this:\n  adjoint M0 * P * M0 + adjoint M1 * WS (W P k) * M1 \\<le>\\<^sub>L\n  adjoint M0 * Q * M0 + adjoint M1 * WS (W Q k) * M1\n\ngoal (1 subgoal):\n 1. W P (Suc k) \\<le>\\<^sub>L W Q (Suc k)", "using eq1 eq2"], ["proof (prove)\nusing this:\n  adjoint M0 * P * M0 + adjoint M1 * WS (W P k) * M1 \\<le>\\<^sub>L\n  adjoint M0 * Q * M0 + adjoint M1 * WS (W Q k) * M1\n  W P (Suc k) = adjoint M0 * P * M0 + adjoint M1 * WS (W P k) * M1\n  W Q (Suc k) = adjoint M0 * Q * M0 + adjoint M1 * WS (W Q k) * M1\n\ngoal (1 subgoal):\n 1. W P (Suc k) \\<le>\\<^sub>L W Q (Suc k)", "by auto"], ["proof (state)\nthis:\n  W P (Suc k) \\<le>\\<^sub>L W Q (Suc k)\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       wlp_while_n (M 0) (M 1) WS k P \\<le>\\<^sub>L\n       wlp_while_n (M 0) (M 1) WS k Q \\<Longrightarrow>\n       wlp_while_n (M 0) (M 1) WS (Suc k) P \\<le>\\<^sub>L\n       wlp_while_n (M 0) (M 1) WS (Suc k) Q", "then"], ["proof (chain)\npicking this:\n  W P (Suc k) \\<le>\\<^sub>L W Q (Suc k)", "show ?case"], ["proof (prove)\nusing this:\n  W P (Suc k) \\<le>\\<^sub>L W Q (Suc k)\n\ngoal (1 subgoal):\n 1. wlp_while_n (M 0) (M 1) WS (Suc k) P \\<le>\\<^sub>L\n    wlp_while_n (M 0) (M 1) WS (Suc k) Q", "unfolding W_def M0_def M1_def"], ["proof (prove)\nusing this:\n  wlp_while_n (M 0) (M 1) WS (Suc k) P \\<le>\\<^sub>L\n  wlp_while_n (M 0) (M 1) WS (Suc k) Q\n\ngoal (1 subgoal):\n 1. wlp_while_n (M 0) (M 1) WS (Suc k) P \\<le>\\<^sub>L\n    wlp_while_n (M 0) (M 1) WS (Suc k) Q", "by auto"], ["proof (state)\nthis:\n  wlp_while_n (M 0) (M 1) WS (Suc k) P \\<le>\\<^sub>L\n  wlp_while_n (M 0) (M 1) WS (Suc k) Q\n\ngoal:\nNo subgoals!", "qed"], ["", "definition wlp_while :: \"complex mat \\<Rightarrow> complex mat \\<Rightarrow> (complex mat \\<Rightarrow> complex mat) \\<Rightarrow> complex mat \\<Rightarrow> complex mat\" where\n  \"wlp_while M0 M1 WS P = (THE Q. limit_mat (\\<lambda>n. wlp_while_n M0 M1 WS n P) Q d)\""], ["", "lemma wlp_while_exists:\n  assumes \"\\<And>P. is_quantum_predicate P \\<Longrightarrow> is_quantum_predicate (WS P)\"\n    and \"\\<And>P Q. is_quantum_predicate P \\<Longrightarrow> is_quantum_predicate Q \\<Longrightarrow> P \\<le>\\<^sub>L Q \\<Longrightarrow> WS P \\<le>\\<^sub>L WS Q\"\n    and m: \"measurement d 2 M\"\n    and qpP: \"is_quantum_predicate P\"\n  shows \"is_quantum_predicate (wlp_while (M 0) (M 1) WS P) \n    \\<and> (\\<forall>n. (wlp_while (M 0) (M 1) WS P) \\<le>\\<^sub>L (wlp_while_n (M 0) (M 1) WS n P))\n    \\<and> (\\<forall>W'. (\\<forall>n. W' \\<le>\\<^sub>L (wlp_while_n (M 0) (M 1) WS n P)) \\<longrightarrow> W' \\<le>\\<^sub>L (wlp_while (M 0) (M 1) WS P))\n    \\<and> limit_mat (\\<lambda>n. wlp_while_n (M 0) (M 1) WS n P) (wlp_while (M 0) (M 1) WS P) d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_quantum_predicate (wlp_while (M 0) (M 1) WS P) \\<and>\n    (\\<forall>n.\n        wlp_while (M 0) (M 1) WS P \\<le>\\<^sub>L\n        wlp_while_n (M 0) (M 1) WS n P) \\<and>\n    (\\<forall>W'.\n        (\\<forall>n.\n            W' \\<le>\\<^sub>L\n            wlp_while_n (M 0) (M 1) WS n P) \\<longrightarrow>\n        W' \\<le>\\<^sub>L wlp_while (M 0) (M 1) WS P) \\<and>\n    limit_mat (\\<lambda>n. wlp_while_n (M 0) (M 1) WS n P)\n     (wlp_while (M 0) (M 1) WS P) d", "proof (auto)"], ["proof (state)\ngoal (4 subgoals):\n 1. is_quantum_predicate (wlp_while (M 0) (M (Suc 0)) WS P)\n 2. \\<And>n.\n       wlp_while (M 0) (M (Suc 0)) WS P \\<le>\\<^sub>L\n       wlp_while_n (M 0) (M (Suc 0)) WS n P\n 3. \\<And>W'.\n       \\<forall>n.\n          W' \\<le>\\<^sub>L\n          wlp_while_n (M 0) (M (Suc 0)) WS n P \\<Longrightarrow>\n       W' \\<le>\\<^sub>L wlp_while (M 0) (M (Suc 0)) WS P\n 4. limit_mat (\\<lambda>n. wlp_while_n (M 0) (M (Suc 0)) WS n P)\n     (wlp_while (M 0) (M (Suc 0)) WS P) d", "define M0 where \"M0 = M 0\""], ["proof (state)\nthis:\n  M0 = M 0\n\ngoal (4 subgoals):\n 1. is_quantum_predicate (wlp_while (M 0) (M (Suc 0)) WS P)\n 2. \\<And>n.\n       wlp_while (M 0) (M (Suc 0)) WS P \\<le>\\<^sub>L\n       wlp_while_n (M 0) (M (Suc 0)) WS n P\n 3. \\<And>W'.\n       \\<forall>n.\n          W' \\<le>\\<^sub>L\n          wlp_while_n (M 0) (M (Suc 0)) WS n P \\<Longrightarrow>\n       W' \\<le>\\<^sub>L wlp_while (M 0) (M (Suc 0)) WS P\n 4. limit_mat (\\<lambda>n. wlp_while_n (M 0) (M (Suc 0)) WS n P)\n     (wlp_while (M 0) (M (Suc 0)) WS P) d", "define M1 where \"M1 = M 1\""], ["proof (state)\nthis:\n  M1 = M 1\n\ngoal (4 subgoals):\n 1. is_quantum_predicate (wlp_while (M 0) (M (Suc 0)) WS P)\n 2. \\<And>n.\n       wlp_while (M 0) (M (Suc 0)) WS P \\<le>\\<^sub>L\n       wlp_while_n (M 0) (M (Suc 0)) WS n P\n 3. \\<And>W'.\n       \\<forall>n.\n          W' \\<le>\\<^sub>L\n          wlp_while_n (M 0) (M (Suc 0)) WS n P \\<Longrightarrow>\n       W' \\<le>\\<^sub>L wlp_while (M 0) (M (Suc 0)) WS P\n 4. limit_mat (\\<lambda>n. wlp_while_n (M 0) (M (Suc 0)) WS n P)\n     (wlp_while (M 0) (M (Suc 0)) WS P) d", "have dM0: \"M0 \\<in> carrier_mat d d\" and dM1: \"M1 \\<in> carrier_mat d d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M0 \\<in> carrier_mat d d &&& M1 \\<in> carrier_mat d d", "using assms M0_def M1_def measurement_def"], ["proof (prove)\nusing this:\n  is_quantum_predicate ?P \\<Longrightarrow> is_quantum_predicate (WS ?P)\n  \\<lbrakk>is_quantum_predicate ?P; is_quantum_predicate ?Q;\n   ?P \\<le>\\<^sub>L ?Q\\<rbrakk>\n  \\<Longrightarrow> WS ?P \\<le>\\<^sub>L WS ?Q\n  measurement d 2 M\n  is_quantum_predicate P\n  M0 = M 0\n  M1 = M 1\n  measurement ?d ?n ?M =\n  ((\\<forall>j<?n. ?M j \\<in> carrier_mat ?d ?d) \\<and>\n   matrix_sum ?d (\\<lambda>j. adjoint (?M j) * ?M j) ?n = 1\\<^sub>m ?d)\n\ngoal (1 subgoal):\n 1. M0 \\<in> carrier_mat d d &&& M1 \\<in> carrier_mat d d", "by auto"], ["proof (state)\nthis:\n  M0 \\<in> carrier_mat d d\n  M1 \\<in> carrier_mat d d\n\ngoal (4 subgoals):\n 1. is_quantum_predicate (wlp_while (M 0) (M (Suc 0)) WS P)\n 2. \\<And>n.\n       wlp_while (M 0) (M (Suc 0)) WS P \\<le>\\<^sub>L\n       wlp_while_n (M 0) (M (Suc 0)) WS n P\n 3. \\<And>W'.\n       \\<forall>n.\n          W' \\<le>\\<^sub>L\n          wlp_while_n (M 0) (M (Suc 0)) WS n P \\<Longrightarrow>\n       W' \\<le>\\<^sub>L wlp_while (M 0) (M (Suc 0)) WS P\n 4. limit_mat (\\<lambda>n. wlp_while_n (M 0) (M (Suc 0)) WS n P)\n     (wlp_while (M 0) (M (Suc 0)) WS P) d", "define W where \"W k = wlp_while_n M0 M1 WS k P\" for k"], ["proof (state)\nthis:\n  W ?k = wlp_while_n M0 M1 WS ?k P\n\ngoal (4 subgoals):\n 1. is_quantum_predicate (wlp_while (M 0) (M (Suc 0)) WS P)\n 2. \\<And>n.\n       wlp_while (M 0) (M (Suc 0)) WS P \\<le>\\<^sub>L\n       wlp_while_n (M 0) (M (Suc 0)) WS n P\n 3. \\<And>W'.\n       \\<forall>n.\n          W' \\<le>\\<^sub>L\n          wlp_while_n (M 0) (M (Suc 0)) WS n P \\<Longrightarrow>\n       W' \\<le>\\<^sub>L wlp_while (M 0) (M (Suc 0)) WS P\n 4. limit_mat (\\<lambda>n. wlp_while_n (M 0) (M (Suc 0)) WS n P)\n     (wlp_while (M 0) (M (Suc 0)) WS P) d", "have leP: \"P \\<le>\\<^sub>L 1\\<^sub>m d\" and dP: \"P \\<in> carrier_mat d d\" and pP: \"positive P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<le>\\<^sub>L 1\\<^sub>m d &&& P \\<in> carrier_mat d d &&& positive P", "using qpP is_quantum_predicate_def"], ["proof (prove)\nusing this:\n  is_quantum_predicate P\n  is_quantum_predicate ?P =\n  (?P \\<in> carrier_mat d d \\<and>\n   positive ?P \\<and> ?P \\<le>\\<^sub>L 1\\<^sub>m d)\n\ngoal (1 subgoal):\n 1. P \\<le>\\<^sub>L 1\\<^sub>m d &&& P \\<in> carrier_mat d d &&& positive P", "by auto"], ["proof (state)\nthis:\n  P \\<le>\\<^sub>L 1\\<^sub>m d\n  P \\<in> carrier_mat d d\n  positive P\n\ngoal (4 subgoals):\n 1. is_quantum_predicate (wlp_while (M 0) (M (Suc 0)) WS P)\n 2. \\<And>n.\n       wlp_while (M 0) (M (Suc 0)) WS P \\<le>\\<^sub>L\n       wlp_while_n (M 0) (M (Suc 0)) WS n P\n 3. \\<And>W'.\n       \\<forall>n.\n          W' \\<le>\\<^sub>L\n          wlp_while_n (M 0) (M (Suc 0)) WS n P \\<Longrightarrow>\n       W' \\<le>\\<^sub>L wlp_while (M 0) (M (Suc 0)) WS P\n 4. limit_mat (\\<lambda>n. wlp_while_n (M 0) (M (Suc 0)) WS n P)\n     (wlp_while (M 0) (M (Suc 0)) WS P) d", "have pM0P: \"positive (adjoint M0 * P * M0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. positive (adjoint M0 * P * M0)", "using positive_close_under_left_right_mult_adjoint[OF adjoint_dim[OF dM0]] adjoint_adjoint[of \"M0\"] dP pP"], ["proof (prove)\nusing this:\n  \\<lbrakk>?A \\<in> carrier_mat d d; positive ?A\\<rbrakk>\n  \\<Longrightarrow> positive (adjoint M0 * ?A * adjoint (adjoint M0))\n  adjoint (adjoint M0) = M0\n  P \\<in> carrier_mat d d\n  positive P\n\ngoal (1 subgoal):\n 1. positive (adjoint M0 * P * M0)", "by  auto"], ["proof (state)\nthis:\n  positive (adjoint M0 * P * M0)\n\ngoal (4 subgoals):\n 1. is_quantum_predicate (wlp_while (M 0) (M (Suc 0)) WS P)\n 2. \\<And>n.\n       wlp_while (M 0) (M (Suc 0)) WS P \\<le>\\<^sub>L\n       wlp_while_n (M 0) (M (Suc 0)) WS n P\n 3. \\<And>W'.\n       \\<forall>n.\n          W' \\<le>\\<^sub>L\n          wlp_while_n (M 0) (M (Suc 0)) WS n P \\<Longrightarrow>\n       W' \\<le>\\<^sub>L wlp_while (M 0) (M (Suc 0)) WS P\n 4. limit_mat (\\<lambda>n. wlp_while_n (M 0) (M (Suc 0)) WS n P)\n     (wlp_while (M 0) (M (Suc 0)) WS P) d", "have le_qp: \"W (Suc k) \\<le>\\<^sub>L W k \\<and> is_quantum_predicate (W k)\" for k"], ["proof (prove)\ngoal (1 subgoal):\n 1. W (Suc k) \\<le>\\<^sub>L W k \\<and> is_quantum_predicate (W k)", "proof (induct k)"], ["proof (state)\ngoal (2 subgoals):\n 1. W (Suc 0) \\<le>\\<^sub>L W 0 \\<and> is_quantum_predicate (W 0)\n 2. \\<And>k.\n       W (Suc k) \\<le>\\<^sub>L W k \\<and>\n       is_quantum_predicate (W k) \\<Longrightarrow>\n       W (Suc (Suc k)) \\<le>\\<^sub>L W (Suc k) \\<and>\n       is_quantum_predicate (W (Suc k))", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. W (Suc 0) \\<le>\\<^sub>L W 0 \\<and> is_quantum_predicate (W 0)\n 2. \\<And>k.\n       W (Suc k) \\<le>\\<^sub>L W k \\<and>\n       is_quantum_predicate (W k) \\<Longrightarrow>\n       W (Suc (Suc k)) \\<le>\\<^sub>L W (Suc k) \\<and>\n       is_quantum_predicate (W (Suc k))", "have \"is_quantum_predicate (1\\<^sub>m d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_quantum_predicate (1\\<^sub>m d)", "unfolding is_quantum_predicate_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1\\<^sub>m d \\<in> carrier_mat d d \\<and>\n    positive (1\\<^sub>m d) \\<and> 1\\<^sub>m d \\<le>\\<^sub>L 1\\<^sub>m d", "using positive_one lowner_le_refl[of \"1\\<^sub>m d\"]"], ["proof (prove)\nusing this:\n  positive (1\\<^sub>m ?n)\n  1\\<^sub>m d \\<in> carrier_mat ?n ?n \\<Longrightarrow>\n  1\\<^sub>m d \\<le>\\<^sub>L 1\\<^sub>m d\n\ngoal (1 subgoal):\n 1. 1\\<^sub>m d \\<in> carrier_mat d d \\<and>\n    positive (1\\<^sub>m d) \\<and> 1\\<^sub>m d \\<le>\\<^sub>L 1\\<^sub>m d", "by fastforce"], ["proof (state)\nthis:\n  is_quantum_predicate (1\\<^sub>m d)\n\ngoal (2 subgoals):\n 1. W (Suc 0) \\<le>\\<^sub>L W 0 \\<and> is_quantum_predicate (W 0)\n 2. \\<And>k.\n       W (Suc k) \\<le>\\<^sub>L W k \\<and>\n       is_quantum_predicate (W k) \\<Longrightarrow>\n       W (Suc (Suc k)) \\<le>\\<^sub>L W (Suc k) \\<and>\n       is_quantum_predicate (W (Suc k))", "then"], ["proof (chain)\npicking this:\n  is_quantum_predicate (1\\<^sub>m d)", "have \"is_quantum_predicate (WS (1\\<^sub>m d))\""], ["proof (prove)\nusing this:\n  is_quantum_predicate (1\\<^sub>m d)\n\ngoal (1 subgoal):\n 1. is_quantum_predicate (WS (1\\<^sub>m d))", "using assms"], ["proof (prove)\nusing this:\n  is_quantum_predicate (1\\<^sub>m d)\n  is_quantum_predicate ?P \\<Longrightarrow> is_quantum_predicate (WS ?P)\n  \\<lbrakk>is_quantum_predicate ?P; is_quantum_predicate ?Q;\n   ?P \\<le>\\<^sub>L ?Q\\<rbrakk>\n  \\<Longrightarrow> WS ?P \\<le>\\<^sub>L WS ?Q\n  measurement d 2 M\n  is_quantum_predicate P\n\ngoal (1 subgoal):\n 1. is_quantum_predicate (WS (1\\<^sub>m d))", "by auto"], ["proof (state)\nthis:\n  is_quantum_predicate (WS (1\\<^sub>m d))\n\ngoal (2 subgoals):\n 1. W (Suc 0) \\<le>\\<^sub>L W 0 \\<and> is_quantum_predicate (W 0)\n 2. \\<And>k.\n       W (Suc k) \\<le>\\<^sub>L W k \\<and>\n       is_quantum_predicate (W k) \\<Longrightarrow>\n       W (Suc (Suc k)) \\<le>\\<^sub>L W (Suc k) \\<and>\n       is_quantum_predicate (W (Suc k))", "then"], ["proof (chain)\npicking this:\n  is_quantum_predicate (WS (1\\<^sub>m d))", "have \"(WS (1\\<^sub>m d)) \\<in> carrier_mat d d\" and \"(WS (1\\<^sub>m d)) \\<le>\\<^sub>L 1\\<^sub>m d\""], ["proof (prove)\nusing this:\n  is_quantum_predicate (WS (1\\<^sub>m d))\n\ngoal (1 subgoal):\n 1. WS (1\\<^sub>m d) \\<in> carrier_mat d d &&&\n    WS (1\\<^sub>m d) \\<le>\\<^sub>L 1\\<^sub>m d", "using is_quantum_predicate_def"], ["proof (prove)\nusing this:\n  is_quantum_predicate (WS (1\\<^sub>m d))\n  is_quantum_predicate ?P =\n  (?P \\<in> carrier_mat d d \\<and>\n   positive ?P \\<and> ?P \\<le>\\<^sub>L 1\\<^sub>m d)\n\ngoal (1 subgoal):\n 1. WS (1\\<^sub>m d) \\<in> carrier_mat d d &&&\n    WS (1\\<^sub>m d) \\<le>\\<^sub>L 1\\<^sub>m d", "by auto"], ["proof (state)\nthis:\n  WS (1\\<^sub>m d) \\<in> carrier_mat d d\n  WS (1\\<^sub>m d) \\<le>\\<^sub>L 1\\<^sub>m d\n\ngoal (2 subgoals):\n 1. W (Suc 0) \\<le>\\<^sub>L W 0 \\<and> is_quantum_predicate (W 0)\n 2. \\<And>k.\n       W (Suc k) \\<le>\\<^sub>L W k \\<and>\n       is_quantum_predicate (W k) \\<Longrightarrow>\n       W (Suc (Suc k)) \\<le>\\<^sub>L W (Suc k) \\<and>\n       is_quantum_predicate (W (Suc k))", "then"], ["proof (chain)\npicking this:\n  WS (1\\<^sub>m d) \\<in> carrier_mat d d\n  WS (1\\<^sub>m d) \\<le>\\<^sub>L 1\\<^sub>m d", "have \"W 1 \\<le>\\<^sub>L W 0\""], ["proof (prove)\nusing this:\n  WS (1\\<^sub>m d) \\<in> carrier_mat d d\n  WS (1\\<^sub>m d) \\<le>\\<^sub>L 1\\<^sub>m d\n\ngoal (1 subgoal):\n 1. W 1 \\<le>\\<^sub>L W 0", "unfolding W_def wlp_while_n.simps M0_def M1_def"], ["proof (prove)\nusing this:\n  WS (1\\<^sub>m d) \\<in> carrier_mat d d\n  WS (1\\<^sub>m d) \\<le>\\<^sub>L 1\\<^sub>m d\n\ngoal (1 subgoal):\n 1. wlp_while_n (M 0) (M 1) WS 1 P \\<le>\\<^sub>L 1\\<^sub>m d", "using measurement2_leq_one_mat[OF dP _ leP _ m]"], ["proof (prove)\nusing this:\n  WS (1\\<^sub>m d) \\<in> carrier_mat d d\n  WS (1\\<^sub>m d) \\<le>\\<^sub>L 1\\<^sub>m d\n  \\<lbrakk>?Q \\<in> carrier_mat d d; ?Q \\<le>\\<^sub>L 1\\<^sub>m d\\<rbrakk>\n  \\<Longrightarrow> adjoint (M 0) * P * M 0 +\n                    adjoint (M 1) * ?Q * M 1 \\<le>\\<^sub>L\n                    1\\<^sub>m d\n\ngoal (1 subgoal):\n 1. wlp_while_n (M 0) (M 1) WS 1 P \\<le>\\<^sub>L 1\\<^sub>m d", "by auto"], ["proof (state)\nthis:\n  W 1 \\<le>\\<^sub>L W 0\n\ngoal (2 subgoals):\n 1. W (Suc 0) \\<le>\\<^sub>L W 0 \\<and> is_quantum_predicate (W 0)\n 2. \\<And>k.\n       W (Suc k) \\<le>\\<^sub>L W k \\<and>\n       is_quantum_predicate (W k) \\<Longrightarrow>\n       W (Suc (Suc k)) \\<le>\\<^sub>L W (Suc k) \\<and>\n       is_quantum_predicate (W (Suc k))", "moreover"], ["proof (state)\nthis:\n  W 1 \\<le>\\<^sub>L W 0\n\ngoal (2 subgoals):\n 1. W (Suc 0) \\<le>\\<^sub>L W 0 \\<and> is_quantum_predicate (W 0)\n 2. \\<And>k.\n       W (Suc k) \\<le>\\<^sub>L W k \\<and>\n       is_quantum_predicate (W k) \\<Longrightarrow>\n       W (Suc (Suc k)) \\<le>\\<^sub>L W (Suc k) \\<and>\n       is_quantum_predicate (W (Suc k))", "have \"is_quantum_predicate (W 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_quantum_predicate (W 0)", "unfolding W_def wlp_while_n.simps is_quantum_predicate_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1\\<^sub>m d \\<in> carrier_mat d d \\<and>\n    positive (1\\<^sub>m d) \\<and> 1\\<^sub>m d \\<le>\\<^sub>L 1\\<^sub>m d", "using positive_one lowner_le_refl[of \"1\\<^sub>m d\"]"], ["proof (prove)\nusing this:\n  positive (1\\<^sub>m ?n)\n  1\\<^sub>m d \\<in> carrier_mat ?n ?n \\<Longrightarrow>\n  1\\<^sub>m d \\<le>\\<^sub>L 1\\<^sub>m d\n\ngoal (1 subgoal):\n 1. 1\\<^sub>m d \\<in> carrier_mat d d \\<and>\n    positive (1\\<^sub>m d) \\<and> 1\\<^sub>m d \\<le>\\<^sub>L 1\\<^sub>m d", "by fastforce"], ["proof (state)\nthis:\n  is_quantum_predicate (W 0)\n\ngoal (2 subgoals):\n 1. W (Suc 0) \\<le>\\<^sub>L W 0 \\<and> is_quantum_predicate (W 0)\n 2. \\<And>k.\n       W (Suc k) \\<le>\\<^sub>L W k \\<and>\n       is_quantum_predicate (W k) \\<Longrightarrow>\n       W (Suc (Suc k)) \\<le>\\<^sub>L W (Suc k) \\<and>\n       is_quantum_predicate (W (Suc k))", "ultimately"], ["proof (chain)\npicking this:\n  W 1 \\<le>\\<^sub>L W 0\n  is_quantum_predicate (W 0)", "show ?case"], ["proof (prove)\nusing this:\n  W 1 \\<le>\\<^sub>L W 0\n  is_quantum_predicate (W 0)\n\ngoal (1 subgoal):\n 1. W (Suc 0) \\<le>\\<^sub>L W 0 \\<and> is_quantum_predicate (W 0)", "by auto"], ["proof (state)\nthis:\n  W (Suc 0) \\<le>\\<^sub>L W 0 \\<and> is_quantum_predicate (W 0)\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       W (Suc k) \\<le>\\<^sub>L W k \\<and>\n       is_quantum_predicate (W k) \\<Longrightarrow>\n       W (Suc (Suc k)) \\<le>\\<^sub>L W (Suc k) \\<and>\n       is_quantum_predicate (W (Suc k))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k.\n       W (Suc k) \\<le>\\<^sub>L W k \\<and>\n       is_quantum_predicate (W k) \\<Longrightarrow>\n       W (Suc (Suc k)) \\<le>\\<^sub>L W (Suc k) \\<and>\n       is_quantum_predicate (W (Suc k))", "case (Suc k)"], ["proof (state)\nthis:\n  W (Suc k) \\<le>\\<^sub>L W k \\<and> is_quantum_predicate (W k)\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       W (Suc k) \\<le>\\<^sub>L W k \\<and>\n       is_quantum_predicate (W k) \\<Longrightarrow>\n       W (Suc (Suc k)) \\<le>\\<^sub>L W (Suc k) \\<and>\n       is_quantum_predicate (W (Suc k))", "then"], ["proof (chain)\npicking this:\n  W (Suc k) \\<le>\\<^sub>L W k \\<and> is_quantum_predicate (W k)", "have leWSk: \"W (Suc k) \\<le>\\<^sub>L W k\" and qpWk: \"is_quantum_predicate (W k)\""], ["proof (prove)\nusing this:\n  W (Suc k) \\<le>\\<^sub>L W k \\<and> is_quantum_predicate (W k)\n\ngoal (1 subgoal):\n 1. W (Suc k) \\<le>\\<^sub>L W k &&& is_quantum_predicate (W k)", "by auto"], ["proof (state)\nthis:\n  W (Suc k) \\<le>\\<^sub>L W k\n  is_quantum_predicate (W k)\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       W (Suc k) \\<le>\\<^sub>L W k \\<and>\n       is_quantum_predicate (W k) \\<Longrightarrow>\n       W (Suc (Suc k)) \\<le>\\<^sub>L W (Suc k) \\<and>\n       is_quantum_predicate (W (Suc k))", "then"], ["proof (chain)\npicking this:\n  W (Suc k) \\<le>\\<^sub>L W k\n  is_quantum_predicate (W k)", "have \"is_quantum_predicate (WS (W k))\""], ["proof (prove)\nusing this:\n  W (Suc k) \\<le>\\<^sub>L W k\n  is_quantum_predicate (W k)\n\ngoal (1 subgoal):\n 1. is_quantum_predicate (WS (W k))", "using assms"], ["proof (prove)\nusing this:\n  W (Suc k) \\<le>\\<^sub>L W k\n  is_quantum_predicate (W k)\n  is_quantum_predicate ?P \\<Longrightarrow> is_quantum_predicate (WS ?P)\n  \\<lbrakk>is_quantum_predicate ?P; is_quantum_predicate ?Q;\n   ?P \\<le>\\<^sub>L ?Q\\<rbrakk>\n  \\<Longrightarrow> WS ?P \\<le>\\<^sub>L WS ?Q\n  measurement d 2 M\n  is_quantum_predicate P\n\ngoal (1 subgoal):\n 1. is_quantum_predicate (WS (W k))", "by auto"], ["proof (state)\nthis:\n  is_quantum_predicate (WS (W k))\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       W (Suc k) \\<le>\\<^sub>L W k \\<and>\n       is_quantum_predicate (W k) \\<Longrightarrow>\n       W (Suc (Suc k)) \\<le>\\<^sub>L W (Suc k) \\<and>\n       is_quantum_predicate (W (Suc k))", "then"], ["proof (chain)\npicking this:\n  is_quantum_predicate (WS (W k))", "have dWWk: \"WS (W k) \\<in> carrier_mat d d\" and leWWk1: \"(WS (W k)) \\<le>\\<^sub>L 1\\<^sub>m d\" and pWWk: \"positive (WS (W k))\""], ["proof (prove)\nusing this:\n  is_quantum_predicate (WS (W k))\n\ngoal (1 subgoal):\n 1. WS (W k) \\<in> carrier_mat d d &&&\n    WS (W k) \\<le>\\<^sub>L 1\\<^sub>m d &&& positive (WS (W k))", "using is_quantum_predicate_def"], ["proof (prove)\nusing this:\n  is_quantum_predicate (WS (W k))\n  is_quantum_predicate ?P =\n  (?P \\<in> carrier_mat d d \\<and>\n   positive ?P \\<and> ?P \\<le>\\<^sub>L 1\\<^sub>m d)\n\ngoal (1 subgoal):\n 1. WS (W k) \\<in> carrier_mat d d &&&\n    WS (W k) \\<le>\\<^sub>L 1\\<^sub>m d &&& positive (WS (W k))", "by auto"], ["proof (state)\nthis:\n  WS (W k) \\<in> carrier_mat d d\n  WS (W k) \\<le>\\<^sub>L 1\\<^sub>m d\n  positive (WS (W k))\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       W (Suc k) \\<le>\\<^sub>L W k \\<and>\n       is_quantum_predicate (W k) \\<Longrightarrow>\n       W (Suc (Suc k)) \\<le>\\<^sub>L W (Suc k) \\<and>\n       is_quantum_predicate (W (Suc k))", "then"], ["proof (chain)\npicking this:\n  WS (W k) \\<in> carrier_mat d d\n  WS (W k) \\<le>\\<^sub>L 1\\<^sub>m d\n  positive (WS (W k))", "have leWSk1: \"W (Suc k) \\<le>\\<^sub>L 1\\<^sub>m d\""], ["proof (prove)\nusing this:\n  WS (W k) \\<in> carrier_mat d d\n  WS (W k) \\<le>\\<^sub>L 1\\<^sub>m d\n  positive (WS (W k))\n\ngoal (1 subgoal):\n 1. W (Suc k) \\<le>\\<^sub>L 1\\<^sub>m d", "using measurement2_leq_one_mat[OF dP dWWk leP leWWk1 m]"], ["proof (prove)\nusing this:\n  WS (W k) \\<in> carrier_mat d d\n  WS (W k) \\<le>\\<^sub>L 1\\<^sub>m d\n  positive (WS (W k))\n  adjoint (M 0) * P * M 0 + adjoint (M 1) * WS (W k) * M 1 \\<le>\\<^sub>L\n  1\\<^sub>m d\n\ngoal (1 subgoal):\n 1. W (Suc k) \\<le>\\<^sub>L 1\\<^sub>m d", "unfolding W_def wlp_while_n.simps M0_def M1_def"], ["proof (prove)\nusing this:\n  WS (wlp_while_n (M 0) (M 1) WS k P) \\<in> carrier_mat d d\n  WS (wlp_while_n (M 0) (M 1) WS k P) \\<le>\\<^sub>L 1\\<^sub>m d\n  positive (WS (wlp_while_n (M 0) (M 1) WS k P))\n  adjoint (M 0) * P * M 0 +\n  adjoint (M 1) * WS (wlp_while_n (M 0) (M 1) WS k P) * M 1 \\<le>\\<^sub>L\n  1\\<^sub>m d\n\ngoal (1 subgoal):\n 1. adjoint (M 0) * P * M 0 +\n    adjoint (M 1) * WS (wlp_while_n (M 0) (M 1) WS k P) * M 1 \\<le>\\<^sub>L\n    1\\<^sub>m d", "by auto"], ["proof (state)\nthis:\n  W (Suc k) \\<le>\\<^sub>L 1\\<^sub>m d\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       W (Suc k) \\<le>\\<^sub>L W k \\<and>\n       is_quantum_predicate (W k) \\<Longrightarrow>\n       W (Suc (Suc k)) \\<le>\\<^sub>L W (Suc k) \\<and>\n       is_quantum_predicate (W (Suc k))", "then"], ["proof (chain)\npicking this:\n  W (Suc k) \\<le>\\<^sub>L 1\\<^sub>m d", "have dWSk: \"W (Suc k) \\<in> carrier_mat d d\""], ["proof (prove)\nusing this:\n  W (Suc k) \\<le>\\<^sub>L 1\\<^sub>m d\n\ngoal (1 subgoal):\n 1. W (Suc k) \\<in> carrier_mat d d", "using lowner_le_def"], ["proof (prove)\nusing this:\n  W (Suc k) \\<le>\\<^sub>L 1\\<^sub>m d\n  (?A \\<le>\\<^sub>L ?B) =\n  (dim_row ?A = dim_row ?B \\<and>\n   dim_col ?A = dim_col ?B \\<and> positive (?B - ?A))\n\ngoal (1 subgoal):\n 1. W (Suc k) \\<in> carrier_mat d d", "by fastforce"], ["proof (state)\nthis:\n  W (Suc k) \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       W (Suc k) \\<le>\\<^sub>L W k \\<and>\n       is_quantum_predicate (W k) \\<Longrightarrow>\n       W (Suc (Suc k)) \\<le>\\<^sub>L W (Suc k) \\<and>\n       is_quantum_predicate (W (Suc k))", "have pM1WWk: \"positive (adjoint M1 * (WS (W k)) * M1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. positive (adjoint M1 * WS (W k) * M1)", "using positive_close_under_left_right_mult_adjoint[OF adjoint_dim[OF dM1] dWWk pWWk] adjoint_adjoint[of \"M1\"]"], ["proof (prove)\nusing this:\n  positive (adjoint M1 * WS (W k) * adjoint (adjoint M1))\n  adjoint (adjoint M1) = M1\n\ngoal (1 subgoal):\n 1. positive (adjoint M1 * WS (W k) * M1)", "by auto"], ["proof (state)\nthis:\n  positive (adjoint M1 * WS (W k) * M1)\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       W (Suc k) \\<le>\\<^sub>L W k \\<and>\n       is_quantum_predicate (W k) \\<Longrightarrow>\n       W (Suc (Suc k)) \\<le>\\<^sub>L W (Suc k) \\<and>\n       is_quantum_predicate (W (Suc k))", "have pWSk: \"positive (W (Suc k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. positive (W (Suc k))", "unfolding W_def wlp_while_n.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. positive\n     (adjoint M0 * P * M0 + adjoint M1 * WS (wlp_while_n M0 M1 WS k P) * M1)", "apply (fold W_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. positive (adjoint M0 * P * M0 + adjoint M1 * WS (W k) * M1)", "using positive_add[OF pM0P pM1WWk] dM0 dP dM1"], ["proof (prove)\nusing this:\n  \\<lbrakk>adjoint M0 * P * M0 \\<in> carrier_mat ?n ?n;\n   adjoint M1 * WS (W k) * M1 \\<in> carrier_mat ?n ?n\\<rbrakk>\n  \\<Longrightarrow> positive\n                     (adjoint M0 * P * M0 + adjoint M1 * WS (W k) * M1)\n  M0 \\<in> carrier_mat d d\n  P \\<in> carrier_mat d d\n  M1 \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. positive (adjoint M0 * P * M0 + adjoint M1 * WS (W k) * M1)", "by fastforce"], ["proof (state)\nthis:\n  positive (W (Suc k))\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       W (Suc k) \\<le>\\<^sub>L W k \\<and>\n       is_quantum_predicate (W k) \\<Longrightarrow>\n       W (Suc (Suc k)) \\<le>\\<^sub>L W (Suc k) \\<and>\n       is_quantum_predicate (W (Suc k))", "have qpWSk:\"is_quantum_predicate (W (Suc k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_quantum_predicate (W (Suc k))", "unfolding is_quantum_predicate_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. W (Suc k) \\<in> carrier_mat d d \\<and>\n    positive (W (Suc k)) \\<and> W (Suc k) \\<le>\\<^sub>L 1\\<^sub>m d", "using dWSk pWSk leWSk1"], ["proof (prove)\nusing this:\n  W (Suc k) \\<in> carrier_mat d d\n  positive (W (Suc k))\n  W (Suc k) \\<le>\\<^sub>L 1\\<^sub>m d\n\ngoal (1 subgoal):\n 1. W (Suc k) \\<in> carrier_mat d d \\<and>\n    positive (W (Suc k)) \\<and> W (Suc k) \\<le>\\<^sub>L 1\\<^sub>m d", "by auto"], ["proof (state)\nthis:\n  is_quantum_predicate (W (Suc k))\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       W (Suc k) \\<le>\\<^sub>L W k \\<and>\n       is_quantum_predicate (W k) \\<Longrightarrow>\n       W (Suc (Suc k)) \\<le>\\<^sub>L W (Suc k) \\<and>\n       is_quantum_predicate (W (Suc k))", "then"], ["proof (chain)\npicking this:\n  is_quantum_predicate (W (Suc k))", "have qpWWSk: \"is_quantum_predicate (WS (W (Suc k)))\""], ["proof (prove)\nusing this:\n  is_quantum_predicate (W (Suc k))\n\ngoal (1 subgoal):\n 1. is_quantum_predicate (WS (W (Suc k)))", "using assms(1)"], ["proof (prove)\nusing this:\n  is_quantum_predicate (W (Suc k))\n  is_quantum_predicate ?P \\<Longrightarrow> is_quantum_predicate (WS ?P)\n\ngoal (1 subgoal):\n 1. is_quantum_predicate (WS (W (Suc k)))", "by auto"], ["proof (state)\nthis:\n  is_quantum_predicate (WS (W (Suc k)))\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       W (Suc k) \\<le>\\<^sub>L W k \\<and>\n       is_quantum_predicate (W k) \\<Longrightarrow>\n       W (Suc (Suc k)) \\<le>\\<^sub>L W (Suc k) \\<and>\n       is_quantum_predicate (W (Suc k))", "then"], ["proof (chain)\npicking this:\n  is_quantum_predicate (WS (W (Suc k)))", "have dWWSk: \"(WS (W (Suc k))) \\<in> carrier_mat d d\""], ["proof (prove)\nusing this:\n  is_quantum_predicate (WS (W (Suc k)))\n\ngoal (1 subgoal):\n 1. WS (W (Suc k)) \\<in> carrier_mat d d", "using is_quantum_predicate_def"], ["proof (prove)\nusing this:\n  is_quantum_predicate (WS (W (Suc k)))\n  is_quantum_predicate ?P =\n  (?P \\<in> carrier_mat d d \\<and>\n   positive ?P \\<and> ?P \\<le>\\<^sub>L 1\\<^sub>m d)\n\ngoal (1 subgoal):\n 1. WS (W (Suc k)) \\<in> carrier_mat d d", "by auto"], ["proof (state)\nthis:\n  WS (W (Suc k)) \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       W (Suc k) \\<le>\\<^sub>L W k \\<and>\n       is_quantum_predicate (W k) \\<Longrightarrow>\n       W (Suc (Suc k)) \\<le>\\<^sub>L W (Suc k) \\<and>\n       is_quantum_predicate (W (Suc k))", "have \"WS (W (Suc k)) \\<le>\\<^sub>L WS (W k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. WS (W (Suc k)) \\<le>\\<^sub>L WS (W k)", "using assms(2)[OF qpWSk qpWk] leWSk"], ["proof (prove)\nusing this:\n  W (Suc k) \\<le>\\<^sub>L W k \\<Longrightarrow>\n  WS (W (Suc k)) \\<le>\\<^sub>L WS (W k)\n  W (Suc k) \\<le>\\<^sub>L W k\n\ngoal (1 subgoal):\n 1. WS (W (Suc k)) \\<le>\\<^sub>L WS (W k)", "by auto"], ["proof (state)\nthis:\n  WS (W (Suc k)) \\<le>\\<^sub>L WS (W k)\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       W (Suc k) \\<le>\\<^sub>L W k \\<and>\n       is_quantum_predicate (W k) \\<Longrightarrow>\n       W (Suc (Suc k)) \\<le>\\<^sub>L W (Suc k) \\<and>\n       is_quantum_predicate (W (Suc k))", "then"], ["proof (chain)\npicking this:\n  WS (W (Suc k)) \\<le>\\<^sub>L WS (W k)", "have \"adjoint M1 * WS (W (Suc k)) * M1 \\<le>\\<^sub>L adjoint M1 * WS (W k) * M1\""], ["proof (prove)\nusing this:\n  WS (W (Suc k)) \\<le>\\<^sub>L WS (W k)\n\ngoal (1 subgoal):\n 1. adjoint M1 * WS (W (Suc k)) * M1 \\<le>\\<^sub>L\n    adjoint M1 * WS (W k) * M1", "using lowner_le_keep_under_measurement[OF dM1 dWWSk dWWk]"], ["proof (prove)\nusing this:\n  WS (W (Suc k)) \\<le>\\<^sub>L WS (W k)\n  WS (W (Suc k)) \\<le>\\<^sub>L WS (W k) \\<Longrightarrow>\n  adjoint M1 * WS (W (Suc k)) * M1 \\<le>\\<^sub>L adjoint M1 * WS (W k) * M1\n\ngoal (1 subgoal):\n 1. adjoint M1 * WS (W (Suc k)) * M1 \\<le>\\<^sub>L\n    adjoint M1 * WS (W k) * M1", "by auto"], ["proof (state)\nthis:\n  adjoint M1 * WS (W (Suc k)) * M1 \\<le>\\<^sub>L adjoint M1 * WS (W k) * M1\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       W (Suc k) \\<le>\\<^sub>L W k \\<and>\n       is_quantum_predicate (W k) \\<Longrightarrow>\n       W (Suc (Suc k)) \\<le>\\<^sub>L W (Suc k) \\<and>\n       is_quantum_predicate (W (Suc k))", "then"], ["proof (chain)\npicking this:\n  adjoint M1 * WS (W (Suc k)) * M1 \\<le>\\<^sub>L adjoint M1 * WS (W k) * M1", "have \"(adjoint M0 * P * M0 + adjoint M1 * WS (W (Suc k)) * M1)\n              \\<le>\\<^sub>L (adjoint M0 * P * M0 + adjoint M1 * WS (W k) * M1)\""], ["proof (prove)\nusing this:\n  adjoint M1 * WS (W (Suc k)) * M1 \\<le>\\<^sub>L adjoint M1 * WS (W k) * M1\n\ngoal (1 subgoal):\n 1. adjoint M0 * P * M0 + adjoint M1 * WS (W (Suc k)) * M1 \\<le>\\<^sub>L\n    adjoint M0 * P * M0 + adjoint M1 * WS (W k) * M1", "using lowner_le_add[of _ d _ \"adjoint M1 * WS (W (Suc k)) * M1\" \"adjoint M1 * WS (W k) * M1\", \n            OF _ _ _ _ lowner_le_refl[of \"adjoint M0 * P * M0\"]] dM0 dM1 dP dWWSk dWWk"], ["proof (prove)\nusing this:\n  adjoint M1 * WS (W (Suc k)) * M1 \\<le>\\<^sub>L adjoint M1 * WS (W k) * M1\n  \\<lbrakk>adjoint M0 * P * M0 \\<in> carrier_mat d d;\n   adjoint M0 * P * M0 \\<in> carrier_mat d d;\n   adjoint M1 * WS (W (Suc k)) * M1 \\<in> carrier_mat d d;\n   adjoint M1 * WS (W k) * M1 \\<in> carrier_mat d d;\n   adjoint M0 * P * M0 \\<in> carrier_mat ?n1 ?n1;\n   adjoint M1 * WS (W (Suc k)) * M1 \\<le>\\<^sub>L\n   adjoint M1 * WS (W k) * M1\\<rbrakk>\n  \\<Longrightarrow> adjoint M0 * P * M0 +\n                    adjoint M1 * WS (W (Suc k)) * M1 \\<le>\\<^sub>L\n                    adjoint M0 * P * M0 + adjoint M1 * WS (W k) * M1\n  M0 \\<in> carrier_mat d d\n  M1 \\<in> carrier_mat d d\n  P \\<in> carrier_mat d d\n  WS (W (Suc k)) \\<in> carrier_mat d d\n  WS (W k) \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. adjoint M0 * P * M0 + adjoint M1 * WS (W (Suc k)) * M1 \\<le>\\<^sub>L\n    adjoint M0 * P * M0 + adjoint M1 * WS (W k) * M1", "by fastforce"], ["proof (state)\nthis:\n  adjoint M0 * P * M0 + adjoint M1 * WS (W (Suc k)) * M1 \\<le>\\<^sub>L\n  adjoint M0 * P * M0 + adjoint M1 * WS (W k) * M1\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       W (Suc k) \\<le>\\<^sub>L W k \\<and>\n       is_quantum_predicate (W k) \\<Longrightarrow>\n       W (Suc (Suc k)) \\<le>\\<^sub>L W (Suc k) \\<and>\n       is_quantum_predicate (W (Suc k))", "then"], ["proof (chain)\npicking this:\n  adjoint M0 * P * M0 + adjoint M1 * WS (W (Suc k)) * M1 \\<le>\\<^sub>L\n  adjoint M0 * P * M0 + adjoint M1 * WS (W k) * M1", "have \"W (Suc (Suc k)) \\<le>\\<^sub>L W (Suc k)\""], ["proof (prove)\nusing this:\n  adjoint M0 * P * M0 + adjoint M1 * WS (W (Suc k)) * M1 \\<le>\\<^sub>L\n  adjoint M0 * P * M0 + adjoint M1 * WS (W k) * M1\n\ngoal (1 subgoal):\n 1. W (Suc (Suc k)) \\<le>\\<^sub>L W (Suc k)", "unfolding W_def wlp_while_n.simps"], ["proof (prove)\nusing this:\n  adjoint M0 * P * M0 +\n  adjoint M1 *\n  WS (adjoint M0 * P * M0 +\n      adjoint M1 * WS (wlp_while_n M0 M1 WS k P) * M1) *\n  M1 \\<le>\\<^sub>L\n  adjoint M0 * P * M0 + adjoint M1 * WS (wlp_while_n M0 M1 WS k P) * M1\n\ngoal (1 subgoal):\n 1. adjoint M0 * P * M0 +\n    adjoint M1 *\n    WS (adjoint M0 * P * M0 +\n        adjoint M1 * WS (wlp_while_n M0 M1 WS k P) * M1) *\n    M1 \\<le>\\<^sub>L\n    adjoint M0 * P * M0 + adjoint M1 * WS (wlp_while_n M0 M1 WS k P) * M1", "by auto"], ["proof (state)\nthis:\n  W (Suc (Suc k)) \\<le>\\<^sub>L W (Suc k)\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       W (Suc k) \\<le>\\<^sub>L W k \\<and>\n       is_quantum_predicate (W k) \\<Longrightarrow>\n       W (Suc (Suc k)) \\<le>\\<^sub>L W (Suc k) \\<and>\n       is_quantum_predicate (W (Suc k))", "with qpWSk"], ["proof (chain)\npicking this:\n  is_quantum_predicate (W (Suc k))\n  W (Suc (Suc k)) \\<le>\\<^sub>L W (Suc k)", "show ?case"], ["proof (prove)\nusing this:\n  is_quantum_predicate (W (Suc k))\n  W (Suc (Suc k)) \\<le>\\<^sub>L W (Suc k)\n\ngoal (1 subgoal):\n 1. W (Suc (Suc k)) \\<le>\\<^sub>L W (Suc k) \\<and>\n    is_quantum_predicate (W (Suc k))", "by auto"], ["proof (state)\nthis:\n  W (Suc (Suc k)) \\<le>\\<^sub>L W (Suc k) \\<and>\n  is_quantum_predicate (W (Suc k))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  W (Suc ?k) \\<le>\\<^sub>L W ?k \\<and> is_quantum_predicate (W ?k)\n\ngoal (4 subgoals):\n 1. is_quantum_predicate (wlp_while (M 0) (M (Suc 0)) WS P)\n 2. \\<And>n.\n       wlp_while (M 0) (M (Suc 0)) WS P \\<le>\\<^sub>L\n       wlp_while_n (M 0) (M (Suc 0)) WS n P\n 3. \\<And>W'.\n       \\<forall>n.\n          W' \\<le>\\<^sub>L\n          wlp_while_n (M 0) (M (Suc 0)) WS n P \\<Longrightarrow>\n       W' \\<le>\\<^sub>L wlp_while (M 0) (M (Suc 0)) WS P\n 4. limit_mat (\\<lambda>n. wlp_while_n (M 0) (M (Suc 0)) WS n P)\n     (wlp_while (M 0) (M (Suc 0)) WS P) d", "then"], ["proof (chain)\npicking this:\n  W (Suc ?k) \\<le>\\<^sub>L W ?k \\<and> is_quantum_predicate (W ?k)", "have dWk: \"W k \\<in> carrier_mat d d\" for k"], ["proof (prove)\nusing this:\n  W (Suc ?k) \\<le>\\<^sub>L W ?k \\<and> is_quantum_predicate (W ?k)\n\ngoal (1 subgoal):\n 1. W k \\<in> carrier_mat d d", "using is_quantum_predicate_def"], ["proof (prove)\nusing this:\n  W (Suc ?k) \\<le>\\<^sub>L W ?k \\<and> is_quantum_predicate (W ?k)\n  is_quantum_predicate ?P =\n  (?P \\<in> carrier_mat d d \\<and>\n   positive ?P \\<and> ?P \\<le>\\<^sub>L 1\\<^sub>m d)\n\ngoal (1 subgoal):\n 1. W k \\<in> carrier_mat d d", "by auto"], ["proof (state)\nthis:\n  W ?k \\<in> carrier_mat d d\n\ngoal (4 subgoals):\n 1. is_quantum_predicate (wlp_while (M 0) (M (Suc 0)) WS P)\n 2. \\<And>n.\n       wlp_while (M 0) (M (Suc 0)) WS P \\<le>\\<^sub>L\n       wlp_while_n (M 0) (M (Suc 0)) WS n P\n 3. \\<And>W'.\n       \\<forall>n.\n          W' \\<le>\\<^sub>L\n          wlp_while_n (M 0) (M (Suc 0)) WS n P \\<Longrightarrow>\n       W' \\<le>\\<^sub>L wlp_while (M 0) (M (Suc 0)) WS P\n 4. limit_mat (\\<lambda>n. wlp_while_n (M 0) (M (Suc 0)) WS n P)\n     (wlp_while (M 0) (M (Suc 0)) WS P) d", "then"], ["proof (chain)\npicking this:\n  W ?k \\<in> carrier_mat d d", "have dmWk: \"- W k \\<in> carrier_mat d d\" for k"], ["proof (prove)\nusing this:\n  W ?k \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. - W k \\<in> carrier_mat d d", "by auto"], ["proof (state)\nthis:\n  - W ?k \\<in> carrier_mat d d\n\ngoal (4 subgoals):\n 1. is_quantum_predicate (wlp_while (M 0) (M (Suc 0)) WS P)\n 2. \\<And>n.\n       wlp_while (M 0) (M (Suc 0)) WS P \\<le>\\<^sub>L\n       wlp_while_n (M 0) (M (Suc 0)) WS n P\n 3. \\<And>W'.\n       \\<forall>n.\n          W' \\<le>\\<^sub>L\n          wlp_while_n (M 0) (M (Suc 0)) WS n P \\<Longrightarrow>\n       W' \\<le>\\<^sub>L wlp_while (M 0) (M (Suc 0)) WS P\n 4. limit_mat (\\<lambda>n. wlp_while_n (M 0) (M (Suc 0)) WS n P)\n     (wlp_while (M 0) (M (Suc 0)) WS P) d", "have incmWk: \"- (W k) \\<le>\\<^sub>L - (W (Suc k))\" for k"], ["proof (prove)\ngoal (1 subgoal):\n 1. - W k \\<le>\\<^sub>L - W (Suc k)", "using lowner_le_swap[of \"W (Suc k)\" d \"W k\"] dWk le_qp"], ["proof (prove)\nusing this:\n  \\<lbrakk>W (Suc k) \\<in> carrier_mat d d; W k \\<in> carrier_mat d d;\n   W (Suc k) \\<le>\\<^sub>L W k\\<rbrakk>\n  \\<Longrightarrow> - W k \\<le>\\<^sub>L - W (Suc k)\n  W ?k \\<in> carrier_mat d d\n  W (Suc ?k) \\<le>\\<^sub>L W ?k \\<and> is_quantum_predicate (W ?k)\n\ngoal (1 subgoal):\n 1. - W k \\<le>\\<^sub>L - W (Suc k)", "by auto"], ["proof (state)\nthis:\n  - W ?k \\<le>\\<^sub>L - W (Suc ?k)\n\ngoal (4 subgoals):\n 1. is_quantum_predicate (wlp_while (M 0) (M (Suc 0)) WS P)\n 2. \\<And>n.\n       wlp_while (M 0) (M (Suc 0)) WS P \\<le>\\<^sub>L\n       wlp_while_n (M 0) (M (Suc 0)) WS n P\n 3. \\<And>W'.\n       \\<forall>n.\n          W' \\<le>\\<^sub>L\n          wlp_while_n (M 0) (M (Suc 0)) WS n P \\<Longrightarrow>\n       W' \\<le>\\<^sub>L wlp_while (M 0) (M (Suc 0)) WS P\n 4. limit_mat (\\<lambda>n. wlp_while_n (M 0) (M (Suc 0)) WS n P)\n     (wlp_while (M 0) (M (Suc 0)) WS P) d", "have pWk: \"positive (W k)\" for k"], ["proof (prove)\ngoal (1 subgoal):\n 1. positive (W k)", "using le_qp is_quantum_predicate_def"], ["proof (prove)\nusing this:\n  W (Suc ?k) \\<le>\\<^sub>L W ?k \\<and> is_quantum_predicate (W ?k)\n  is_quantum_predicate ?P =\n  (?P \\<in> carrier_mat d d \\<and>\n   positive ?P \\<and> ?P \\<le>\\<^sub>L 1\\<^sub>m d)\n\ngoal (1 subgoal):\n 1. positive (W k)", "by auto"], ["proof (state)\nthis:\n  positive (W ?k)\n\ngoal (4 subgoals):\n 1. is_quantum_predicate (wlp_while (M 0) (M (Suc 0)) WS P)\n 2. \\<And>n.\n       wlp_while (M 0) (M (Suc 0)) WS P \\<le>\\<^sub>L\n       wlp_while_n (M 0) (M (Suc 0)) WS n P\n 3. \\<And>W'.\n       \\<forall>n.\n          W' \\<le>\\<^sub>L\n          wlp_while_n (M 0) (M (Suc 0)) WS n P \\<Longrightarrow>\n       W' \\<le>\\<^sub>L wlp_while (M 0) (M (Suc 0)) WS P\n 4. limit_mat (\\<lambda>n. wlp_while_n (M 0) (M (Suc 0)) WS n P)\n     (wlp_while (M 0) (M (Suc 0)) WS P) d", "have ubmWk: \"- W k \\<le>\\<^sub>L 0\\<^sub>m d d\" for k"], ["proof (prove)\ngoal (1 subgoal):\n 1. - W k \\<le>\\<^sub>L 0\\<^sub>m d d", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. - W k \\<le>\\<^sub>L 0\\<^sub>m d d", "have \"0\\<^sub>m d d \\<le>\\<^sub>L W k\" for k"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0\\<^sub>m d d \\<le>\\<^sub>L W k", "using zero_lowner_le_positiveI dWk pWk"], ["proof (prove)\nusing this:\n  \\<lbrakk>?A \\<in> carrier_mat ?n ?n; positive ?A\\<rbrakk>\n  \\<Longrightarrow> 0\\<^sub>m ?n ?n \\<le>\\<^sub>L ?A\n  W ?k \\<in> carrier_mat d d\n  positive (W ?k)\n\ngoal (1 subgoal):\n 1. 0\\<^sub>m d d \\<le>\\<^sub>L W k", "by auto"], ["proof (state)\nthis:\n  0\\<^sub>m d d \\<le>\\<^sub>L W ?k\n\ngoal (1 subgoal):\n 1. - W k \\<le>\\<^sub>L 0\\<^sub>m d d", "then"], ["proof (chain)\npicking this:\n  0\\<^sub>m d d \\<le>\\<^sub>L W ?k", "have \"- W k \\<le>\\<^sub>L - 0\\<^sub>m d d\" for k"], ["proof (prove)\nusing this:\n  0\\<^sub>m d d \\<le>\\<^sub>L W ?k\n\ngoal (1 subgoal):\n 1. - W k \\<le>\\<^sub>L - 0\\<^sub>m d d", "using lowner_le_swap[of \"0\\<^sub>m d d\" d \"W k\"] dWk"], ["proof (prove)\nusing this:\n  0\\<^sub>m d d \\<le>\\<^sub>L W ?k\n  \\<lbrakk>0\\<^sub>m d d \\<in> carrier_mat d d; W k \\<in> carrier_mat d d;\n   0\\<^sub>m d d \\<le>\\<^sub>L W k\\<rbrakk>\n  \\<Longrightarrow> - W k \\<le>\\<^sub>L - 0\\<^sub>m d d\n  W ?k \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. - W k \\<le>\\<^sub>L - 0\\<^sub>m d d", "by auto"], ["proof (state)\nthis:\n  - W ?k \\<le>\\<^sub>L - 0\\<^sub>m d d\n\ngoal (1 subgoal):\n 1. - W k \\<le>\\<^sub>L 0\\<^sub>m d d", "moreover"], ["proof (state)\nthis:\n  - W ?k \\<le>\\<^sub>L - 0\\<^sub>m d d\n\ngoal (1 subgoal):\n 1. - W k \\<le>\\<^sub>L 0\\<^sub>m d d", "have \"(- 0\\<^sub>m d d :: complex mat) = (0\\<^sub>m d d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - 0\\<^sub>m d d = 0\\<^sub>m d d", "by auto"], ["proof (state)\nthis:\n  - 0\\<^sub>m d d = 0\\<^sub>m d d\n\ngoal (1 subgoal):\n 1. - W k \\<le>\\<^sub>L 0\\<^sub>m d d", "ultimately"], ["proof (chain)\npicking this:\n  - W ?k \\<le>\\<^sub>L - 0\\<^sub>m d d\n  - 0\\<^sub>m d d = 0\\<^sub>m d d", "show ?thesis"], ["proof (prove)\nusing this:\n  - W ?k \\<le>\\<^sub>L - 0\\<^sub>m d d\n  - 0\\<^sub>m d d = 0\\<^sub>m d d\n\ngoal (1 subgoal):\n 1. - W k \\<le>\\<^sub>L 0\\<^sub>m d d", "by auto"], ["proof (state)\nthis:\n  - W k \\<le>\\<^sub>L 0\\<^sub>m d d\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  - W ?k \\<le>\\<^sub>L 0\\<^sub>m d d\n\ngoal (4 subgoals):\n 1. is_quantum_predicate (wlp_while (M 0) (M (Suc 0)) WS P)\n 2. \\<And>n.\n       wlp_while (M 0) (M (Suc 0)) WS P \\<le>\\<^sub>L\n       wlp_while_n (M 0) (M (Suc 0)) WS n P\n 3. \\<And>W'.\n       \\<forall>n.\n          W' \\<le>\\<^sub>L\n          wlp_while_n (M 0) (M (Suc 0)) WS n P \\<Longrightarrow>\n       W' \\<le>\\<^sub>L wlp_while (M 0) (M (Suc 0)) WS P\n 4. limit_mat (\\<lambda>n. wlp_while_n (M 0) (M (Suc 0)) WS n P)\n     (wlp_while (M 0) (M (Suc 0)) WS P) d", "have \"\\<exists>B. lowner_is_lub (\\<lambda>k. - W k) B \\<and> limit_mat (\\<lambda>k. - W k) B d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>B.\n       lowner_is_lub (\\<lambda>k. - W k) B \\<and>\n       limit_mat (\\<lambda>k. - W k) B d", "using mat_inc_seq_lub[of \"\\<lambda>k. - W k\" d \"0\\<^sub>m d d\"] dmWk incmWk ubmWk"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>n. - W n \\<in> carrier_mat d d;\n   \\<And>n. - W n \\<le>\\<^sub>L - W (Suc n);\n   \\<And>n. - W n \\<le>\\<^sub>L 0\\<^sub>m d d\\<rbrakk>\n  \\<Longrightarrow> \\<exists>B.\n                       lowner_is_lub (\\<lambda>k. - W k) B \\<and>\n                       limit_mat (\\<lambda>k. - W k) B d\n  - W ?k \\<in> carrier_mat d d\n  - W ?k \\<le>\\<^sub>L - W (Suc ?k)\n  - W ?k \\<le>\\<^sub>L 0\\<^sub>m d d\n\ngoal (1 subgoal):\n 1. \\<exists>B.\n       lowner_is_lub (\\<lambda>k. - W k) B \\<and>\n       limit_mat (\\<lambda>k. - W k) B d", "by auto"], ["proof (state)\nthis:\n  \\<exists>B.\n     lowner_is_lub (\\<lambda>k. - W k) B \\<and>\n     limit_mat (\\<lambda>k. - W k) B d\n\ngoal (4 subgoals):\n 1. is_quantum_predicate (wlp_while (M 0) (M (Suc 0)) WS P)\n 2. \\<And>n.\n       wlp_while (M 0) (M (Suc 0)) WS P \\<le>\\<^sub>L\n       wlp_while_n (M 0) (M (Suc 0)) WS n P\n 3. \\<And>W'.\n       \\<forall>n.\n          W' \\<le>\\<^sub>L\n          wlp_while_n (M 0) (M (Suc 0)) WS n P \\<Longrightarrow>\n       W' \\<le>\\<^sub>L wlp_while (M 0) (M (Suc 0)) WS P\n 4. limit_mat (\\<lambda>n. wlp_while_n (M 0) (M (Suc 0)) WS n P)\n     (wlp_while (M 0) (M (Suc 0)) WS P) d", "then"], ["proof (chain)\npicking this:\n  \\<exists>B.\n     lowner_is_lub (\\<lambda>k. - W k) B \\<and>\n     limit_mat (\\<lambda>k. - W k) B d", "obtain B where lubB: \"lowner_is_lub (\\<lambda>k. - W k) B\" and limB: \"limit_mat (\\<lambda>k. - W k) B d\""], ["proof (prove)\nusing this:\n  \\<exists>B.\n     lowner_is_lub (\\<lambda>k. - W k) B \\<and>\n     limit_mat (\\<lambda>k. - W k) B d\n\ngoal (1 subgoal):\n 1. (\\<And>B.\n        \\<lbrakk>lowner_is_lub (\\<lambda>k. - W k) B;\n         limit_mat (\\<lambda>k. - W k) B d\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  lowner_is_lub (\\<lambda>k. - W k) B\n  limit_mat (\\<lambda>k. - W k) B d\n\ngoal (4 subgoals):\n 1. is_quantum_predicate (wlp_while (M 0) (M (Suc 0)) WS P)\n 2. \\<And>n.\n       wlp_while (M 0) (M (Suc 0)) WS P \\<le>\\<^sub>L\n       wlp_while_n (M 0) (M (Suc 0)) WS n P\n 3. \\<And>W'.\n       \\<forall>n.\n          W' \\<le>\\<^sub>L\n          wlp_while_n (M 0) (M (Suc 0)) WS n P \\<Longrightarrow>\n       W' \\<le>\\<^sub>L wlp_while (M 0) (M (Suc 0)) WS P\n 4. limit_mat (\\<lambda>n. wlp_while_n (M 0) (M (Suc 0)) WS n P)\n     (wlp_while (M 0) (M (Suc 0)) WS P) d", "then"], ["proof (chain)\npicking this:\n  lowner_is_lub (\\<lambda>k. - W k) B\n  limit_mat (\\<lambda>k. - W k) B d", "have dB: \"B \\<in> carrier_mat d d\""], ["proof (prove)\nusing this:\n  lowner_is_lub (\\<lambda>k. - W k) B\n  limit_mat (\\<lambda>k. - W k) B d\n\ngoal (1 subgoal):\n 1. B \\<in> carrier_mat d d", "using limit_mat_def"], ["proof (prove)\nusing this:\n  lowner_is_lub (\\<lambda>k. - W k) B\n  limit_mat (\\<lambda>k. - W k) B d\n  limit_mat ?X ?A ?m =\n  (\\<forall>n.\n      ?X n \\<in> carrier_mat ?m ?m \\<and>\n      ?A \\<in> carrier_mat ?m ?m \\<and>\n      (\\<forall>i<?m.\n          \\<forall>j<?m.\n             (\\<lambda>n. ?X n $$ (i, j))\n             \\<longlonglongrightarrow> ?A $$ (i, j)))\n\ngoal (1 subgoal):\n 1. B \\<in> carrier_mat d d", "by auto"], ["proof (state)\nthis:\n  B \\<in> carrier_mat d d\n\ngoal (4 subgoals):\n 1. is_quantum_predicate (wlp_while (M 0) (M (Suc 0)) WS P)\n 2. \\<And>n.\n       wlp_while (M 0) (M (Suc 0)) WS P \\<le>\\<^sub>L\n       wlp_while_n (M 0) (M (Suc 0)) WS n P\n 3. \\<And>W'.\n       \\<forall>n.\n          W' \\<le>\\<^sub>L\n          wlp_while_n (M 0) (M (Suc 0)) WS n P \\<Longrightarrow>\n       W' \\<le>\\<^sub>L wlp_while (M 0) (M (Suc 0)) WS P\n 4. limit_mat (\\<lambda>n. wlp_while_n (M 0) (M (Suc 0)) WS n P)\n     (wlp_while (M 0) (M (Suc 0)) WS P) d", "define A where \"A = - B\""], ["proof (state)\nthis:\n  A = - B\n\ngoal (4 subgoals):\n 1. is_quantum_predicate (wlp_while (M 0) (M (Suc 0)) WS P)\n 2. \\<And>n.\n       wlp_while (M 0) (M (Suc 0)) WS P \\<le>\\<^sub>L\n       wlp_while_n (M 0) (M (Suc 0)) WS n P\n 3. \\<And>W'.\n       \\<forall>n.\n          W' \\<le>\\<^sub>L\n          wlp_while_n (M 0) (M (Suc 0)) WS n P \\<Longrightarrow>\n       W' \\<le>\\<^sub>L wlp_while (M 0) (M (Suc 0)) WS P\n 4. limit_mat (\\<lambda>n. wlp_while_n (M 0) (M (Suc 0)) WS n P)\n     (wlp_while (M 0) (M (Suc 0)) WS P) d", "then"], ["proof (chain)\npicking this:\n  A = - B", "have dA: \"A \\<in> carrier_mat d d\""], ["proof (prove)\nusing this:\n  A = - B\n\ngoal (1 subgoal):\n 1. A \\<in> carrier_mat d d", "using dB"], ["proof (prove)\nusing this:\n  A = - B\n  B \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. A \\<in> carrier_mat d d", "by auto"], ["proof (state)\nthis:\n  A \\<in> carrier_mat d d\n\ngoal (4 subgoals):\n 1. is_quantum_predicate (wlp_while (M 0) (M (Suc 0)) WS P)\n 2. \\<And>n.\n       wlp_while (M 0) (M (Suc 0)) WS P \\<le>\\<^sub>L\n       wlp_while_n (M 0) (M (Suc 0)) WS n P\n 3. \\<And>W'.\n       \\<forall>n.\n          W' \\<le>\\<^sub>L\n          wlp_while_n (M 0) (M (Suc 0)) WS n P \\<Longrightarrow>\n       W' \\<le>\\<^sub>L wlp_while (M 0) (M (Suc 0)) WS P\n 4. limit_mat (\\<lambda>n. wlp_while_n (M 0) (M (Suc 0)) WS n P)\n     (wlp_while (M 0) (M (Suc 0)) WS P) d", "have \"limit_mat (\\<lambda>k. (-1) \\<cdot>\\<^sub>m (- W k)) (-1 \\<cdot>\\<^sub>m B) d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. limit_mat (\\<lambda>k. - 1 \\<cdot>\\<^sub>m - W k)\n     (- 1 \\<cdot>\\<^sub>m B) d", "using limit_mat_scale[OF limB]"], ["proof (prove)\nusing this:\n  limit_mat (\\<lambda>n. ?c \\<cdot>\\<^sub>m - W n) (?c \\<cdot>\\<^sub>m B) d\n\ngoal (1 subgoal):\n 1. limit_mat (\\<lambda>k. - 1 \\<cdot>\\<^sub>m - W k)\n     (- 1 \\<cdot>\\<^sub>m B) d", "by auto"], ["proof (state)\nthis:\n  limit_mat (\\<lambda>k. - 1 \\<cdot>\\<^sub>m - W k) (- 1 \\<cdot>\\<^sub>m B)\n   d\n\ngoal (4 subgoals):\n 1. is_quantum_predicate (wlp_while (M 0) (M (Suc 0)) WS P)\n 2. \\<And>n.\n       wlp_while (M 0) (M (Suc 0)) WS P \\<le>\\<^sub>L\n       wlp_while_n (M 0) (M (Suc 0)) WS n P\n 3. \\<And>W'.\n       \\<forall>n.\n          W' \\<le>\\<^sub>L\n          wlp_while_n (M 0) (M (Suc 0)) WS n P \\<Longrightarrow>\n       W' \\<le>\\<^sub>L wlp_while (M 0) (M (Suc 0)) WS P\n 4. limit_mat (\\<lambda>n. wlp_while_n (M 0) (M (Suc 0)) WS n P)\n     (wlp_while (M 0) (M (Suc 0)) WS P) d", "moreover"], ["proof (state)\nthis:\n  limit_mat (\\<lambda>k. - 1 \\<cdot>\\<^sub>m - W k) (- 1 \\<cdot>\\<^sub>m B)\n   d\n\ngoal (4 subgoals):\n 1. is_quantum_predicate (wlp_while (M 0) (M (Suc 0)) WS P)\n 2. \\<And>n.\n       wlp_while (M 0) (M (Suc 0)) WS P \\<le>\\<^sub>L\n       wlp_while_n (M 0) (M (Suc 0)) WS n P\n 3. \\<And>W'.\n       \\<forall>n.\n          W' \\<le>\\<^sub>L\n          wlp_while_n (M 0) (M (Suc 0)) WS n P \\<Longrightarrow>\n       W' \\<le>\\<^sub>L wlp_while (M 0) (M (Suc 0)) WS P\n 4. limit_mat (\\<lambda>n. wlp_while_n (M 0) (M (Suc 0)) WS n P)\n     (wlp_while (M 0) (M (Suc 0)) WS P) d", "have \"W k = -1 \\<cdot>\\<^sub>m (- W k)\" for k"], ["proof (prove)\ngoal (1 subgoal):\n 1. W k = - 1 \\<cdot>\\<^sub>m - W k", "using dWk"], ["proof (prove)\nusing this:\n  W ?k \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. W k = - 1 \\<cdot>\\<^sub>m - W k", "by auto"], ["proof (state)\nthis:\n  W ?k = - 1 \\<cdot>\\<^sub>m - W ?k\n\ngoal (4 subgoals):\n 1. is_quantum_predicate (wlp_while (M 0) (M (Suc 0)) WS P)\n 2. \\<And>n.\n       wlp_while (M 0) (M (Suc 0)) WS P \\<le>\\<^sub>L\n       wlp_while_n (M 0) (M (Suc 0)) WS n P\n 3. \\<And>W'.\n       \\<forall>n.\n          W' \\<le>\\<^sub>L\n          wlp_while_n (M 0) (M (Suc 0)) WS n P \\<Longrightarrow>\n       W' \\<le>\\<^sub>L wlp_while (M 0) (M (Suc 0)) WS P\n 4. limit_mat (\\<lambda>n. wlp_while_n (M 0) (M (Suc 0)) WS n P)\n     (wlp_while (M 0) (M (Suc 0)) WS P) d", "moreover"], ["proof (state)\nthis:\n  W ?k = - 1 \\<cdot>\\<^sub>m - W ?k\n\ngoal (4 subgoals):\n 1. is_quantum_predicate (wlp_while (M 0) (M (Suc 0)) WS P)\n 2. \\<And>n.\n       wlp_while (M 0) (M (Suc 0)) WS P \\<le>\\<^sub>L\n       wlp_while_n (M 0) (M (Suc 0)) WS n P\n 3. \\<And>W'.\n       \\<forall>n.\n          W' \\<le>\\<^sub>L\n          wlp_while_n (M 0) (M (Suc 0)) WS n P \\<Longrightarrow>\n       W' \\<le>\\<^sub>L wlp_while (M 0) (M (Suc 0)) WS P\n 4. limit_mat (\\<lambda>n. wlp_while_n (M 0) (M (Suc 0)) WS n P)\n     (wlp_while (M 0) (M (Suc 0)) WS P) d", "have \"-1 \\<cdot>\\<^sub>m B = - B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - 1 \\<cdot>\\<^sub>m B = - B", "by auto"], ["proof (state)\nthis:\n  - 1 \\<cdot>\\<^sub>m B = - B\n\ngoal (4 subgoals):\n 1. is_quantum_predicate (wlp_while (M 0) (M (Suc 0)) WS P)\n 2. \\<And>n.\n       wlp_while (M 0) (M (Suc 0)) WS P \\<le>\\<^sub>L\n       wlp_while_n (M 0) (M (Suc 0)) WS n P\n 3. \\<And>W'.\n       \\<forall>n.\n          W' \\<le>\\<^sub>L\n          wlp_while_n (M 0) (M (Suc 0)) WS n P \\<Longrightarrow>\n       W' \\<le>\\<^sub>L wlp_while (M 0) (M (Suc 0)) WS P\n 4. limit_mat (\\<lambda>n. wlp_while_n (M 0) (M (Suc 0)) WS n P)\n     (wlp_while (M 0) (M (Suc 0)) WS P) d", "ultimately"], ["proof (chain)\npicking this:\n  limit_mat (\\<lambda>k. - 1 \\<cdot>\\<^sub>m - W k) (- 1 \\<cdot>\\<^sub>m B)\n   d\n  W ?k = - 1 \\<cdot>\\<^sub>m - W ?k\n  - 1 \\<cdot>\\<^sub>m B = - B", "have limA: \"limit_mat W A d\""], ["proof (prove)\nusing this:\n  limit_mat (\\<lambda>k. - 1 \\<cdot>\\<^sub>m - W k) (- 1 \\<cdot>\\<^sub>m B)\n   d\n  W ?k = - 1 \\<cdot>\\<^sub>m - W ?k\n  - 1 \\<cdot>\\<^sub>m B = - B\n\ngoal (1 subgoal):\n 1. limit_mat W A d", "using A_def"], ["proof (prove)\nusing this:\n  limit_mat (\\<lambda>k. - 1 \\<cdot>\\<^sub>m - W k) (- 1 \\<cdot>\\<^sub>m B)\n   d\n  W ?k = - 1 \\<cdot>\\<^sub>m - W ?k\n  - 1 \\<cdot>\\<^sub>m B = - B\n  A = - B\n\ngoal (1 subgoal):\n 1. limit_mat W A d", "by auto"], ["proof (state)\nthis:\n  limit_mat W A d\n\ngoal (4 subgoals):\n 1. is_quantum_predicate (wlp_while (M 0) (M (Suc 0)) WS P)\n 2. \\<And>n.\n       wlp_while (M 0) (M (Suc 0)) WS P \\<le>\\<^sub>L\n       wlp_while_n (M 0) (M (Suc 0)) WS n P\n 3. \\<And>W'.\n       \\<forall>n.\n          W' \\<le>\\<^sub>L\n          wlp_while_n (M 0) (M (Suc 0)) WS n P \\<Longrightarrow>\n       W' \\<le>\\<^sub>L wlp_while (M 0) (M (Suc 0)) WS P\n 4. limit_mat (\\<lambda>n. wlp_while_n (M 0) (M (Suc 0)) WS n P)\n     (wlp_while (M 0) (M (Suc 0)) WS P) d", "moreover"], ["proof (state)\nthis:\n  limit_mat W A d\n\ngoal (4 subgoals):\n 1. is_quantum_predicate (wlp_while (M 0) (M (Suc 0)) WS P)\n 2. \\<And>n.\n       wlp_while (M 0) (M (Suc 0)) WS P \\<le>\\<^sub>L\n       wlp_while_n (M 0) (M (Suc 0)) WS n P\n 3. \\<And>W'.\n       \\<forall>n.\n          W' \\<le>\\<^sub>L\n          wlp_while_n (M 0) (M (Suc 0)) WS n P \\<Longrightarrow>\n       W' \\<le>\\<^sub>L wlp_while (M 0) (M (Suc 0)) WS P\n 4. limit_mat (\\<lambda>n. wlp_while_n (M 0) (M (Suc 0)) WS n P)\n     (wlp_while (M 0) (M (Suc 0)) WS P) d", "have \"(limit_mat W A' d \\<Longrightarrow> A' = A)\" for A'"], ["proof (prove)\ngoal (1 subgoal):\n 1. limit_mat W A' d \\<Longrightarrow> A' = A", "using limit_mat_unique[of W A d] limA"], ["proof (prove)\nusing this:\n  \\<lbrakk>limit_mat W A d; limit_mat W ?B d\\<rbrakk>\n  \\<Longrightarrow> A = ?B\n  limit_mat W A d\n\ngoal (1 subgoal):\n 1. limit_mat W A' d \\<Longrightarrow> A' = A", "by auto"], ["proof (state)\nthis:\n  limit_mat W ?A' d \\<Longrightarrow> ?A' = A\n\ngoal (4 subgoals):\n 1. is_quantum_predicate (wlp_while (M 0) (M (Suc 0)) WS P)\n 2. \\<And>n.\n       wlp_while (M 0) (M (Suc 0)) WS P \\<le>\\<^sub>L\n       wlp_while_n (M 0) (M (Suc 0)) WS n P\n 3. \\<And>W'.\n       \\<forall>n.\n          W' \\<le>\\<^sub>L\n          wlp_while_n (M 0) (M (Suc 0)) WS n P \\<Longrightarrow>\n       W' \\<le>\\<^sub>L wlp_while (M 0) (M (Suc 0)) WS P\n 4. limit_mat (\\<lambda>n. wlp_while_n (M 0) (M (Suc 0)) WS n P)\n     (wlp_while (M 0) (M (Suc 0)) WS P) d", "ultimately"], ["proof (chain)\npicking this:\n  limit_mat W A d\n  limit_mat W ?A' d \\<Longrightarrow> ?A' = A", "have eqA: \"(wlp_while (M 0) (M 1) WS P) = A\""], ["proof (prove)\nusing this:\n  limit_mat W A d\n  limit_mat W ?A' d \\<Longrightarrow> ?A' = A\n\ngoal (1 subgoal):\n 1. wlp_while (M 0) (M 1) WS P = A", "unfolding wlp_while_def W_def M0_def M1_def"], ["proof (prove)\nusing this:\n  limit_mat (\\<lambda>k. wlp_while_n (M 0) (M 1) WS k P) A d\n  limit_mat (\\<lambda>k. wlp_while_n (M 0) (M 1) WS k P) ?A'\n   d \\<Longrightarrow>\n  ?A' = A\n\ngoal (1 subgoal):\n 1. (THE Q. limit_mat (\\<lambda>n. wlp_while_n (M 0) (M 1) WS n P) Q d) = A", "using the_equality[of \"\\<lambda>X. limit_mat (\\<lambda>n. wlp_while_n (M 0) (M 1) WS n P) X d\" A]"], ["proof (prove)\nusing this:\n  limit_mat (\\<lambda>k. wlp_while_n (M 0) (M 1) WS k P) A d\n  limit_mat (\\<lambda>k. wlp_while_n (M 0) (M 1) WS k P) ?A'\n   d \\<Longrightarrow>\n  ?A' = A\n  \\<lbrakk>limit_mat (\\<lambda>n. wlp_while_n (M 0) (M 1) WS n P) A d;\n   \\<And>x.\n      limit_mat (\\<lambda>n. wlp_while_n (M 0) (M 1) WS n P) x\n       d \\<Longrightarrow>\n      x = A\\<rbrakk>\n  \\<Longrightarrow> (THE x.\n                        limit_mat\n                         (\\<lambda>n. wlp_while_n (M 0) (M 1) WS n P) x d) =\n                    A\n\ngoal (1 subgoal):\n 1. (THE Q. limit_mat (\\<lambda>n. wlp_while_n (M 0) (M 1) WS n P) Q d) = A", "by fastforce"], ["proof (state)\nthis:\n  wlp_while (M 0) (M 1) WS P = A\n\ngoal (4 subgoals):\n 1. is_quantum_predicate (wlp_while (M 0) (M (Suc 0)) WS P)\n 2. \\<And>n.\n       wlp_while (M 0) (M (Suc 0)) WS P \\<le>\\<^sub>L\n       wlp_while_n (M 0) (M (Suc 0)) WS n P\n 3. \\<And>W'.\n       \\<forall>n.\n          W' \\<le>\\<^sub>L\n          wlp_while_n (M 0) (M (Suc 0)) WS n P \\<Longrightarrow>\n       W' \\<le>\\<^sub>L wlp_while (M 0) (M (Suc 0)) WS P\n 4. limit_mat (\\<lambda>n. wlp_while_n (M 0) (M (Suc 0)) WS n P)\n     (wlp_while (M 0) (M (Suc 0)) WS P) d", "show \"limit_mat (\\<lambda>n. wlp_while_n (M 0) (M (Suc 0)) WS n P) (wlp_while (M 0) (M (Suc 0)) WS P) d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. limit_mat (\\<lambda>n. wlp_while_n (M 0) (M (Suc 0)) WS n P)\n     (wlp_while (M 0) (M (Suc 0)) WS P) d", "using limA eqA"], ["proof (prove)\nusing this:\n  limit_mat W A d\n  wlp_while (M 0) (M 1) WS P = A\n\ngoal (1 subgoal):\n 1. limit_mat (\\<lambda>n. wlp_while_n (M 0) (M (Suc 0)) WS n P)\n     (wlp_while (M 0) (M (Suc 0)) WS P) d", "unfolding W_def M0_def M1_def"], ["proof (prove)\nusing this:\n  limit_mat (\\<lambda>k. wlp_while_n (M 0) (M 1) WS k P) A d\n  wlp_while (M 0) (M 1) WS P = A\n\ngoal (1 subgoal):\n 1. limit_mat (\\<lambda>n. wlp_while_n (M 0) (M (Suc 0)) WS n P)\n     (wlp_while (M 0) (M (Suc 0)) WS P) d", "by auto"], ["proof (state)\nthis:\n  limit_mat (\\<lambda>n. wlp_while_n (M 0) (M (Suc 0)) WS n P)\n   (wlp_while (M 0) (M (Suc 0)) WS P) d\n\ngoal (3 subgoals):\n 1. is_quantum_predicate (wlp_while (M 0) (M (Suc 0)) WS P)\n 2. \\<And>n.\n       wlp_while (M 0) (M (Suc 0)) WS P \\<le>\\<^sub>L\n       wlp_while_n (M 0) (M (Suc 0)) WS n P\n 3. \\<And>W'.\n       \\<forall>n.\n          W' \\<le>\\<^sub>L\n          wlp_while_n (M 0) (M (Suc 0)) WS n P \\<Longrightarrow>\n       W' \\<le>\\<^sub>L wlp_while (M 0) (M (Suc 0)) WS P", "have \"- W k \\<le>\\<^sub>L B\" for k"], ["proof (prove)\ngoal (1 subgoal):\n 1. - W k \\<le>\\<^sub>L B", "using lubB lowner_is_lub_def"], ["proof (prove)\nusing this:\n  lowner_is_lub (\\<lambda>k. - W k) B\n  lowner_is_lub ?f ?M =\n  ((\\<forall>n. ?f n \\<le>\\<^sub>L ?M) \\<and>\n   (\\<forall>M'.\n       (\\<forall>n. ?f n \\<le>\\<^sub>L M') \\<longrightarrow>\n       ?M \\<le>\\<^sub>L M'))\n\ngoal (1 subgoal):\n 1. - W k \\<le>\\<^sub>L B", "by auto"], ["proof (state)\nthis:\n  - W ?k \\<le>\\<^sub>L B\n\ngoal (3 subgoals):\n 1. is_quantum_predicate (wlp_while (M 0) (M (Suc 0)) WS P)\n 2. \\<And>n.\n       wlp_while (M 0) (M (Suc 0)) WS P \\<le>\\<^sub>L\n       wlp_while_n (M 0) (M (Suc 0)) WS n P\n 3. \\<And>W'.\n       \\<forall>n.\n          W' \\<le>\\<^sub>L\n          wlp_while_n (M 0) (M (Suc 0)) WS n P \\<Longrightarrow>\n       W' \\<le>\\<^sub>L wlp_while (M 0) (M (Suc 0)) WS P", "then"], ["proof (chain)\npicking this:\n  - W ?k \\<le>\\<^sub>L B", "have glbA: \"A \\<le>\\<^sub>L W k\" for k"], ["proof (prove)\nusing this:\n  - W ?k \\<le>\\<^sub>L B\n\ngoal (1 subgoal):\n 1. A \\<le>\\<^sub>L W k", "unfolding A_def"], ["proof (prove)\nusing this:\n  - W ?k \\<le>\\<^sub>L B\n\ngoal (1 subgoal):\n 1. - B \\<le>\\<^sub>L W k", "using lowner_le_swap[of \"- W k\" d] dB dWk"], ["proof (prove)\nusing this:\n  - W ?k \\<le>\\<^sub>L B\n  \\<lbrakk>- W k \\<in> carrier_mat d d; ?B \\<in> carrier_mat d d;\n   - W k \\<le>\\<^sub>L ?B\\<rbrakk>\n  \\<Longrightarrow> - ?B \\<le>\\<^sub>L - (- W k)\n  B \\<in> carrier_mat d d\n  W ?k \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. - B \\<le>\\<^sub>L W k", "by fastforce"], ["proof (state)\nthis:\n  A \\<le>\\<^sub>L W ?k\n\ngoal (3 subgoals):\n 1. is_quantum_predicate (wlp_while (M 0) (M (Suc 0)) WS P)\n 2. \\<And>n.\n       wlp_while (M 0) (M (Suc 0)) WS P \\<le>\\<^sub>L\n       wlp_while_n (M 0) (M (Suc 0)) WS n P\n 3. \\<And>W'.\n       \\<forall>n.\n          W' \\<le>\\<^sub>L\n          wlp_while_n (M 0) (M (Suc 0)) WS n P \\<Longrightarrow>\n       W' \\<le>\\<^sub>L wlp_while (M 0) (M (Suc 0)) WS P", "then"], ["proof (chain)\npicking this:\n  A \\<le>\\<^sub>L W ?k", "show \"\\<And>n. wlp_while (M 0) (M (Suc 0)) WS P \\<le>\\<^sub>L wlp_while_n (M 0) (M (Suc 0)) WS n P\""], ["proof (prove)\nusing this:\n  A \\<le>\\<^sub>L W ?k\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       wlp_while (M 0) (M (Suc 0)) WS P \\<le>\\<^sub>L\n       wlp_while_n (M 0) (M (Suc 0)) WS n P", "using eqA"], ["proof (prove)\nusing this:\n  A \\<le>\\<^sub>L W ?k\n  wlp_while (M 0) (M 1) WS P = A\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       wlp_while (M 0) (M (Suc 0)) WS P \\<le>\\<^sub>L\n       wlp_while_n (M 0) (M (Suc 0)) WS n P", "unfolding W_def M0_def M1_def"], ["proof (prove)\nusing this:\n  A \\<le>\\<^sub>L wlp_while_n (M 0) (M 1) WS ?k P\n  wlp_while (M 0) (M 1) WS P = A\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       wlp_while (M 0) (M (Suc 0)) WS P \\<le>\\<^sub>L\n       wlp_while_n (M 0) (M (Suc 0)) WS n P", "by auto"], ["proof (state)\nthis:\n  wlp_while (M 0) (M (Suc 0)) WS P \\<le>\\<^sub>L\n  wlp_while_n (M 0) (M (Suc 0)) WS ?n P\n\ngoal (2 subgoals):\n 1. is_quantum_predicate (wlp_while (M 0) (M (Suc 0)) WS P)\n 2. \\<And>W'.\n       \\<forall>n.\n          W' \\<le>\\<^sub>L\n          wlp_while_n (M 0) (M (Suc 0)) WS n P \\<Longrightarrow>\n       W' \\<le>\\<^sub>L wlp_while (M 0) (M (Suc 0)) WS P", "have \"W k \\<le>\\<^sub>L 1\\<^sub>m d\" for k"], ["proof (prove)\ngoal (1 subgoal):\n 1. W k \\<le>\\<^sub>L 1\\<^sub>m d", "using le_qp"], ["proof (prove)\nusing this:\n  W (Suc ?k) \\<le>\\<^sub>L W ?k \\<and> is_quantum_predicate (W ?k)\n\ngoal (1 subgoal):\n 1. W k \\<le>\\<^sub>L 1\\<^sub>m d", "unfolding is_quantum_predicate_def"], ["proof (prove)\nusing this:\n  W (Suc ?k) \\<le>\\<^sub>L W ?k \\<and>\n  W ?k \\<in> carrier_mat d d \\<and>\n  positive (W ?k) \\<and> W ?k \\<le>\\<^sub>L 1\\<^sub>m d\n\ngoal (1 subgoal):\n 1. W k \\<le>\\<^sub>L 1\\<^sub>m d", "by auto"], ["proof (state)\nthis:\n  W ?k \\<le>\\<^sub>L 1\\<^sub>m d\n\ngoal (2 subgoals):\n 1. is_quantum_predicate (wlp_while (M 0) (M (Suc 0)) WS P)\n 2. \\<And>W'.\n       \\<forall>n.\n          W' \\<le>\\<^sub>L\n          wlp_while_n (M 0) (M (Suc 0)) WS n P \\<Longrightarrow>\n       W' \\<le>\\<^sub>L wlp_while (M 0) (M (Suc 0)) WS P", "then"], ["proof (chain)\npicking this:\n  W ?k \\<le>\\<^sub>L 1\\<^sub>m d", "have \"positive (1\\<^sub>m d - W k)\" for k"], ["proof (prove)\nusing this:\n  W ?k \\<le>\\<^sub>L 1\\<^sub>m d\n\ngoal (1 subgoal):\n 1. positive (1\\<^sub>m d - W k)", "using lowner_le_def"], ["proof (prove)\nusing this:\n  W ?k \\<le>\\<^sub>L 1\\<^sub>m d\n  (?A \\<le>\\<^sub>L ?B) =\n  (dim_row ?A = dim_row ?B \\<and>\n   dim_col ?A = dim_col ?B \\<and> positive (?B - ?A))\n\ngoal (1 subgoal):\n 1. positive (1\\<^sub>m d - W k)", "by auto"], ["proof (state)\nthis:\n  positive (1\\<^sub>m d - W ?k)\n\ngoal (2 subgoals):\n 1. is_quantum_predicate (wlp_while (M 0) (M (Suc 0)) WS P)\n 2. \\<And>W'.\n       \\<forall>n.\n          W' \\<le>\\<^sub>L\n          wlp_while_n (M 0) (M (Suc 0)) WS n P \\<Longrightarrow>\n       W' \\<le>\\<^sub>L wlp_while (M 0) (M (Suc 0)) WS P", "moreover"], ["proof (state)\nthis:\n  positive (1\\<^sub>m d - W ?k)\n\ngoal (2 subgoals):\n 1. is_quantum_predicate (wlp_while (M 0) (M (Suc 0)) WS P)\n 2. \\<And>W'.\n       \\<forall>n.\n          W' \\<le>\\<^sub>L\n          wlp_while_n (M 0) (M (Suc 0)) WS n P \\<Longrightarrow>\n       W' \\<le>\\<^sub>L wlp_while (M 0) (M (Suc 0)) WS P", "have \"limit_mat (\\<lambda>k. 1\\<^sub>m d - W k) (1\\<^sub>m d - A) d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. limit_mat (\\<lambda>k. 1\\<^sub>m d - W k) (1\\<^sub>m d - A) d", "using mat_minus_limit limA"], ["proof (prove)\nusing this:\n  \\<lbrakk>?B \\<in> carrier_mat ?m ?m; limit_mat ?X ?A ?m\\<rbrakk>\n  \\<Longrightarrow> limit_mat (\\<lambda>n. ?B - ?X n) (?B - ?A) ?m\n  limit_mat W A d\n\ngoal (1 subgoal):\n 1. limit_mat (\\<lambda>k. 1\\<^sub>m d - W k) (1\\<^sub>m d - A) d", "by auto"], ["proof (state)\nthis:\n  limit_mat (\\<lambda>k. 1\\<^sub>m d - W k) (1\\<^sub>m d - A) d\n\ngoal (2 subgoals):\n 1. is_quantum_predicate (wlp_while (M 0) (M (Suc 0)) WS P)\n 2. \\<And>W'.\n       \\<forall>n.\n          W' \\<le>\\<^sub>L\n          wlp_while_n (M 0) (M (Suc 0)) WS n P \\<Longrightarrow>\n       W' \\<le>\\<^sub>L wlp_while (M 0) (M (Suc 0)) WS P", "ultimately"], ["proof (chain)\npicking this:\n  positive (1\\<^sub>m d - W ?k)\n  limit_mat (\\<lambda>k. 1\\<^sub>m d - W k) (1\\<^sub>m d - A) d", "have \"positive (1\\<^sub>m d - A)\""], ["proof (prove)\nusing this:\n  positive (1\\<^sub>m d - W ?k)\n  limit_mat (\\<lambda>k. 1\\<^sub>m d - W k) (1\\<^sub>m d - A) d\n\ngoal (1 subgoal):\n 1. positive (1\\<^sub>m d - A)", "using pos_mat_lim_is_pos"], ["proof (prove)\nusing this:\n  positive (1\\<^sub>m d - W ?k)\n  limit_mat (\\<lambda>k. 1\\<^sub>m d - W k) (1\\<^sub>m d - A) d\n  \\<lbrakk>limit_mat ?X ?A ?m; \\<forall>n. positive (?X n)\\<rbrakk>\n  \\<Longrightarrow> positive ?A\n\ngoal (1 subgoal):\n 1. positive (1\\<^sub>m d - A)", "by auto"], ["proof (state)\nthis:\n  positive (1\\<^sub>m d - A)\n\ngoal (2 subgoals):\n 1. is_quantum_predicate (wlp_while (M 0) (M (Suc 0)) WS P)\n 2. \\<And>W'.\n       \\<forall>n.\n          W' \\<le>\\<^sub>L\n          wlp_while_n (M 0) (M (Suc 0)) WS n P \\<Longrightarrow>\n       W' \\<le>\\<^sub>L wlp_while (M 0) (M (Suc 0)) WS P", "then"], ["proof (chain)\npicking this:\n  positive (1\\<^sub>m d - A)", "have leA1: \"A \\<le>\\<^sub>L 1\\<^sub>m d\""], ["proof (prove)\nusing this:\n  positive (1\\<^sub>m d - A)\n\ngoal (1 subgoal):\n 1. A \\<le>\\<^sub>L 1\\<^sub>m d", "using dA lowner_le_def"], ["proof (prove)\nusing this:\n  positive (1\\<^sub>m d - A)\n  A \\<in> carrier_mat d d\n  (?A \\<le>\\<^sub>L ?B) =\n  (dim_row ?A = dim_row ?B \\<and>\n   dim_col ?A = dim_col ?B \\<and> positive (?B - ?A))\n\ngoal (1 subgoal):\n 1. A \\<le>\\<^sub>L 1\\<^sub>m d", "by auto"], ["proof (state)\nthis:\n  A \\<le>\\<^sub>L 1\\<^sub>m d\n\ngoal (2 subgoals):\n 1. is_quantum_predicate (wlp_while (M 0) (M (Suc 0)) WS P)\n 2. \\<And>W'.\n       \\<forall>n.\n          W' \\<le>\\<^sub>L\n          wlp_while_n (M 0) (M (Suc 0)) WS n P \\<Longrightarrow>\n       W' \\<le>\\<^sub>L wlp_while (M 0) (M (Suc 0)) WS P", "have pA: \"positive A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. positive A", "using pos_mat_lim_is_pos limA pWk"], ["proof (prove)\nusing this:\n  \\<lbrakk>limit_mat ?X ?A ?m; \\<forall>n. positive (?X n)\\<rbrakk>\n  \\<Longrightarrow> positive ?A\n  limit_mat W A d\n  positive (W ?k)\n\ngoal (1 subgoal):\n 1. positive A", "by auto"], ["proof (state)\nthis:\n  positive A\n\ngoal (2 subgoals):\n 1. is_quantum_predicate (wlp_while (M 0) (M (Suc 0)) WS P)\n 2. \\<And>W'.\n       \\<forall>n.\n          W' \\<le>\\<^sub>L\n          wlp_while_n (M 0) (M (Suc 0)) WS n P \\<Longrightarrow>\n       W' \\<le>\\<^sub>L wlp_while (M 0) (M (Suc 0)) WS P", "show \"is_quantum_predicate (wlp_while (M 0) (M (Suc 0)) WS P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_quantum_predicate (wlp_while (M 0) (M (Suc 0)) WS P)", "unfolding is_quantum_predicate_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. wlp_while (M 0) (M (Suc 0)) WS P \\<in> carrier_mat d d \\<and>\n    positive (wlp_while (M 0) (M (Suc 0)) WS P) \\<and>\n    wlp_while (M 0) (M (Suc 0)) WS P \\<le>\\<^sub>L 1\\<^sub>m d", "using pA dA leA1 eqA"], ["proof (prove)\nusing this:\n  positive A\n  A \\<in> carrier_mat d d\n  A \\<le>\\<^sub>L 1\\<^sub>m d\n  wlp_while (M 0) (M 1) WS P = A\n\ngoal (1 subgoal):\n 1. wlp_while (M 0) (M (Suc 0)) WS P \\<in> carrier_mat d d \\<and>\n    positive (wlp_while (M 0) (M (Suc 0)) WS P) \\<and>\n    wlp_while (M 0) (M (Suc 0)) WS P \\<le>\\<^sub>L 1\\<^sub>m d", "by auto"], ["proof (state)\nthis:\n  is_quantum_predicate (wlp_while (M 0) (M (Suc 0)) WS P)\n\ngoal (1 subgoal):\n 1. \\<And>W'.\n       \\<forall>n.\n          W' \\<le>\\<^sub>L\n          wlp_while_n (M 0) (M (Suc 0)) WS n P \\<Longrightarrow>\n       W' \\<le>\\<^sub>L wlp_while (M 0) (M (Suc 0)) WS P", "{"], ["proof (state)\nthis:\n  is_quantum_predicate (wlp_while (M 0) (M (Suc 0)) WS P)\n\ngoal (1 subgoal):\n 1. \\<And>W'.\n       \\<forall>n.\n          W' \\<le>\\<^sub>L\n          wlp_while_n (M 0) (M (Suc 0)) WS n P \\<Longrightarrow>\n       W' \\<le>\\<^sub>L wlp_while (M 0) (M (Suc 0)) WS P", "fix W'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>W'.\n       \\<forall>n.\n          W' \\<le>\\<^sub>L\n          wlp_while_n (M 0) (M (Suc 0)) WS n P \\<Longrightarrow>\n       W' \\<le>\\<^sub>L wlp_while (M 0) (M (Suc 0)) WS P", "assume asmW': \"\\<forall>k. W' \\<le>\\<^sub>L W k\""], ["proof (state)\nthis:\n  \\<forall>k. W' \\<le>\\<^sub>L W k\n\ngoal (1 subgoal):\n 1. \\<And>W'.\n       \\<forall>n.\n          W' \\<le>\\<^sub>L\n          wlp_while_n (M 0) (M (Suc 0)) WS n P \\<Longrightarrow>\n       W' \\<le>\\<^sub>L wlp_while (M 0) (M (Suc 0)) WS P", "then"], ["proof (chain)\npicking this:\n  \\<forall>k. W' \\<le>\\<^sub>L W k", "have dW': \"W' \\<in> carrier_mat d d\""], ["proof (prove)\nusing this:\n  \\<forall>k. W' \\<le>\\<^sub>L W k\n\ngoal (1 subgoal):\n 1. W' \\<in> carrier_mat d d", "unfolding lowner_le_def"], ["proof (prove)\nusing this:\n  \\<forall>k.\n     dim_row W' = dim_row (W k) \\<and>\n     dim_col W' = dim_col (W k) \\<and> positive (W k - W')\n\ngoal (1 subgoal):\n 1. W' \\<in> carrier_mat d d", "using carrier_matD[OF dWk]"], ["proof (prove)\nusing this:\n  \\<forall>k.\n     dim_row W' = dim_row (W k) \\<and>\n     dim_col W' = dim_col (W k) \\<and> positive (W k - W')\n  dim_row (W ?k1) = d\n  dim_col (W ?k1) = d\n\ngoal (1 subgoal):\n 1. W' \\<in> carrier_mat d d", "by auto"], ["proof (state)\nthis:\n  W' \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. \\<And>W'.\n       \\<forall>n.\n          W' \\<le>\\<^sub>L\n          wlp_while_n (M 0) (M (Suc 0)) WS n P \\<Longrightarrow>\n       W' \\<le>\\<^sub>L wlp_while (M 0) (M (Suc 0)) WS P", "then"], ["proof (chain)\npicking this:\n  W' \\<in> carrier_mat d d", "have \"- W k \\<le>\\<^sub>L - W'\" for k"], ["proof (prove)\nusing this:\n  W' \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. - W k \\<le>\\<^sub>L - W'", "using lowner_le_swap dWk asmW'"], ["proof (prove)\nusing this:\n  W' \\<in> carrier_mat d d\n  \\<lbrakk>?A \\<in> carrier_mat ?n ?n; ?B \\<in> carrier_mat ?n ?n;\n   ?A \\<le>\\<^sub>L ?B\\<rbrakk>\n  \\<Longrightarrow> - ?B \\<le>\\<^sub>L - ?A\n  W ?k \\<in> carrier_mat d d\n  \\<forall>k. W' \\<le>\\<^sub>L W k\n\ngoal (1 subgoal):\n 1. - W k \\<le>\\<^sub>L - W'", "by auto"], ["proof (state)\nthis:\n  - W ?k \\<le>\\<^sub>L - W'\n\ngoal (1 subgoal):\n 1. \\<And>W'.\n       \\<forall>n.\n          W' \\<le>\\<^sub>L\n          wlp_while_n (M 0) (M (Suc 0)) WS n P \\<Longrightarrow>\n       W' \\<le>\\<^sub>L wlp_while (M 0) (M (Suc 0)) WS P", "then"], ["proof (chain)\npicking this:\n  - W ?k \\<le>\\<^sub>L - W'", "have \"B \\<le>\\<^sub>L - W'\""], ["proof (prove)\nusing this:\n  - W ?k \\<le>\\<^sub>L - W'\n\ngoal (1 subgoal):\n 1. B \\<le>\\<^sub>L - W'", "using lubB"], ["proof (prove)\nusing this:\n  - W ?k \\<le>\\<^sub>L - W'\n  lowner_is_lub (\\<lambda>k. - W k) B\n\ngoal (1 subgoal):\n 1. B \\<le>\\<^sub>L - W'", "unfolding lowner_is_lub_def"], ["proof (prove)\nusing this:\n  - W ?k \\<le>\\<^sub>L - W'\n  (\\<forall>n. - W n \\<le>\\<^sub>L B) \\<and>\n  (\\<forall>M'.\n      (\\<forall>n. - W n \\<le>\\<^sub>L M') \\<longrightarrow>\n      B \\<le>\\<^sub>L M')\n\ngoal (1 subgoal):\n 1. B \\<le>\\<^sub>L - W'", "by auto"], ["proof (state)\nthis:\n  B \\<le>\\<^sub>L - W'\n\ngoal (1 subgoal):\n 1. \\<And>W'.\n       \\<forall>n.\n          W' \\<le>\\<^sub>L\n          wlp_while_n (M 0) (M (Suc 0)) WS n P \\<Longrightarrow>\n       W' \\<le>\\<^sub>L wlp_while (M 0) (M (Suc 0)) WS P", "then"], ["proof (chain)\npicking this:\n  B \\<le>\\<^sub>L - W'", "have \"W' \\<le>\\<^sub>L A\""], ["proof (prove)\nusing this:\n  B \\<le>\\<^sub>L - W'\n\ngoal (1 subgoal):\n 1. W' \\<le>\\<^sub>L A", "unfolding A_def"], ["proof (prove)\nusing this:\n  B \\<le>\\<^sub>L - W'\n\ngoal (1 subgoal):\n 1. W' \\<le>\\<^sub>L - B", "using lowner_le_swap[of \"B\" d \"- W'\"] dB dW'"], ["proof (prove)\nusing this:\n  B \\<le>\\<^sub>L - W'\n  \\<lbrakk>B \\<in> carrier_mat d d; - W' \\<in> carrier_mat d d;\n   B \\<le>\\<^sub>L - W'\\<rbrakk>\n  \\<Longrightarrow> - (- W') \\<le>\\<^sub>L - B\n  B \\<in> carrier_mat d d\n  W' \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. W' \\<le>\\<^sub>L - B", "by auto"], ["proof (state)\nthis:\n  W' \\<le>\\<^sub>L A\n\ngoal (1 subgoal):\n 1. \\<And>W'.\n       \\<forall>n.\n          W' \\<le>\\<^sub>L\n          wlp_while_n (M 0) (M (Suc 0)) WS n P \\<Longrightarrow>\n       W' \\<le>\\<^sub>L wlp_while (M 0) (M (Suc 0)) WS P", "then"], ["proof (chain)\npicking this:\n  W' \\<le>\\<^sub>L A", "have \"W' \\<le>\\<^sub>L wlp_while (M 0) (M 1) WS P\""], ["proof (prove)\nusing this:\n  W' \\<le>\\<^sub>L A\n\ngoal (1 subgoal):\n 1. W' \\<le>\\<^sub>L wlp_while (M 0) (M 1) WS P", "using eqA"], ["proof (prove)\nusing this:\n  W' \\<le>\\<^sub>L A\n  wlp_while (M 0) (M 1) WS P = A\n\ngoal (1 subgoal):\n 1. W' \\<le>\\<^sub>L wlp_while (M 0) (M 1) WS P", "by auto"], ["proof (state)\nthis:\n  W' \\<le>\\<^sub>L wlp_while (M 0) (M 1) WS P\n\ngoal (1 subgoal):\n 1. \\<And>W'.\n       \\<forall>n.\n          W' \\<le>\\<^sub>L\n          wlp_while_n (M 0) (M (Suc 0)) WS n P \\<Longrightarrow>\n       W' \\<le>\\<^sub>L wlp_while (M 0) (M (Suc 0)) WS P", "}"], ["proof (state)\nthis:\n  \\<forall>k. ?W'2 \\<le>\\<^sub>L W k \\<Longrightarrow>\n  ?W'2 \\<le>\\<^sub>L wlp_while (M 0) (M 1) WS P\n\ngoal (1 subgoal):\n 1. \\<And>W'.\n       \\<forall>n.\n          W' \\<le>\\<^sub>L\n          wlp_while_n (M 0) (M (Suc 0)) WS n P \\<Longrightarrow>\n       W' \\<le>\\<^sub>L wlp_while (M 0) (M (Suc 0)) WS P", "then"], ["proof (chain)\npicking this:\n  \\<forall>k. ?W'2 \\<le>\\<^sub>L W k \\<Longrightarrow>\n  ?W'2 \\<le>\\<^sub>L wlp_while (M 0) (M 1) WS P", "show \"\\<And>W'. \\<forall>n. W' \\<le>\\<^sub>L wlp_while_n (M 0) (M (Suc 0)) WS n P \\<Longrightarrow> W' \\<le>\\<^sub>L wlp_while (M 0) (M (Suc 0)) WS P\""], ["proof (prove)\nusing this:\n  \\<forall>k. ?W'2 \\<le>\\<^sub>L W k \\<Longrightarrow>\n  ?W'2 \\<le>\\<^sub>L wlp_while (M 0) (M 1) WS P\n\ngoal (1 subgoal):\n 1. \\<And>W'.\n       \\<forall>n.\n          W' \\<le>\\<^sub>L\n          wlp_while_n (M 0) (M (Suc 0)) WS n P \\<Longrightarrow>\n       W' \\<le>\\<^sub>L wlp_while (M 0) (M (Suc 0)) WS P", "unfolding W_def M0_def M1_def"], ["proof (prove)\nusing this:\n  \\<forall>k.\n     ?W'2 \\<le>\\<^sub>L wlp_while_n (M 0) (M 1) WS k P \\<Longrightarrow>\n  ?W'2 \\<le>\\<^sub>L wlp_while (M 0) (M 1) WS P\n\ngoal (1 subgoal):\n 1. \\<And>W'.\n       \\<forall>n.\n          W' \\<le>\\<^sub>L\n          wlp_while_n (M 0) (M (Suc 0)) WS n P \\<Longrightarrow>\n       W' \\<le>\\<^sub>L wlp_while (M 0) (M (Suc 0)) WS P", "by auto"], ["proof (state)\nthis:\n  \\<forall>n.\n     ?W' \\<le>\\<^sub>L\n     wlp_while_n (M 0) (M (Suc 0)) WS n P \\<Longrightarrow>\n  ?W' \\<le>\\<^sub>L wlp_while (M 0) (M (Suc 0)) WS P\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma wlp_while_mono:\n  assumes \"\\<And>P. is_quantum_predicate P \\<Longrightarrow> is_quantum_predicate (WS P)\"\n    and \"\\<And>P Q. is_quantum_predicate P \\<Longrightarrow> is_quantum_predicate Q \\<Longrightarrow> P \\<le>\\<^sub>L Q \\<Longrightarrow> WS P \\<le>\\<^sub>L WS Q\"\n    and \"measurement d 2 M\"\n    and \"is_quantum_predicate P\"\n    and \"is_quantum_predicate Q\"\n    and \"P \\<le>\\<^sub>L Q\"\n  shows \"wlp_while (M 0) (M 1) WS P \\<le>\\<^sub>L wlp_while (M 0) (M 1) WS Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wlp_while (M 0) (M 1) WS P \\<le>\\<^sub>L wlp_while (M 0) (M 1) WS Q", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. wlp_while (M 0) (M 1) WS P \\<le>\\<^sub>L wlp_while (M 0) (M 1) WS Q", "define M0 where \"M0 = M 0\""], ["proof (state)\nthis:\n  M0 = M 0\n\ngoal (1 subgoal):\n 1. wlp_while (M 0) (M 1) WS P \\<le>\\<^sub>L wlp_while (M 0) (M 1) WS Q", "define M1 where \"M1 = M 1\""], ["proof (state)\nthis:\n  M1 = M 1\n\ngoal (1 subgoal):\n 1. wlp_while (M 0) (M 1) WS P \\<le>\\<^sub>L wlp_while (M 0) (M 1) WS Q", "have dM0: \"M0 \\<in> carrier_mat d d\" and dM1: \"M1 \\<in> carrier_mat d d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M0 \\<in> carrier_mat d d &&& M1 \\<in> carrier_mat d d", "using assms M0_def M1_def measurement_def"], ["proof (prove)\nusing this:\n  is_quantum_predicate ?P \\<Longrightarrow> is_quantum_predicate (WS ?P)\n  \\<lbrakk>is_quantum_predicate ?P; is_quantum_predicate ?Q;\n   ?P \\<le>\\<^sub>L ?Q\\<rbrakk>\n  \\<Longrightarrow> WS ?P \\<le>\\<^sub>L WS ?Q\n  measurement d 2 M\n  is_quantum_predicate P\n  is_quantum_predicate Q\n  P \\<le>\\<^sub>L Q\n  M0 = M 0\n  M1 = M 1\n  measurement ?d ?n ?M =\n  ((\\<forall>j<?n. ?M j \\<in> carrier_mat ?d ?d) \\<and>\n   matrix_sum ?d (\\<lambda>j. adjoint (?M j) * ?M j) ?n = 1\\<^sub>m ?d)\n\ngoal (1 subgoal):\n 1. M0 \\<in> carrier_mat d d &&& M1 \\<in> carrier_mat d d", "by auto"], ["proof (state)\nthis:\n  M0 \\<in> carrier_mat d d\n  M1 \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. wlp_while (M 0) (M 1) WS P \\<le>\\<^sub>L wlp_while (M 0) (M 1) WS Q", "define Wn where \"Wn P k = wlp_while_n M0 M1 WS k P\" for P k"], ["proof (state)\nthis:\n  Wn ?P ?k = wlp_while_n M0 M1 WS ?k ?P\n\ngoal (1 subgoal):\n 1. wlp_while (M 0) (M 1) WS P \\<le>\\<^sub>L wlp_while (M 0) (M 1) WS Q", "define W where \"W P = wlp_while M0 M1 WS P\" for P"], ["proof (state)\nthis:\n  W ?P = wlp_while M0 M1 WS ?P\n\ngoal (1 subgoal):\n 1. wlp_while (M 0) (M 1) WS P \\<le>\\<^sub>L wlp_while (M 0) (M 1) WS Q", "have lePQk: \"Wn P k \\<le>\\<^sub>L Wn Q k\" for k"], ["proof (prove)\ngoal (1 subgoal):\n 1. Wn P k \\<le>\\<^sub>L Wn Q k", "unfolding Wn_def M0_def M1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. wlp_while_n (M 0) (M 1) WS k P \\<le>\\<^sub>L\n    wlp_while_n (M 0) (M 1) WS k Q", "using wlp_while_n_mono assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>P.\n              is_quantum_predicate P \\<Longrightarrow>\n              is_quantum_predicate (?WS P);\n   \\<And>P Q.\n      \\<lbrakk>is_quantum_predicate P; is_quantum_predicate Q;\n       P \\<le>\\<^sub>L Q\\<rbrakk>\n      \\<Longrightarrow> ?WS P \\<le>\\<^sub>L ?WS Q;\n   measurement d 2 ?M; is_quantum_predicate ?P; is_quantum_predicate ?Q;\n   ?P \\<le>\\<^sub>L ?Q\\<rbrakk>\n  \\<Longrightarrow> wlp_while_n (?M 0) (?M 1) ?WS ?k ?P \\<le>\\<^sub>L\n                    wlp_while_n (?M 0) (?M 1) ?WS ?k ?Q\n  is_quantum_predicate ?P \\<Longrightarrow> is_quantum_predicate (WS ?P)\n  \\<lbrakk>is_quantum_predicate ?P; is_quantum_predicate ?Q;\n   ?P \\<le>\\<^sub>L ?Q\\<rbrakk>\n  \\<Longrightarrow> WS ?P \\<le>\\<^sub>L WS ?Q\n  measurement d 2 M\n  is_quantum_predicate P\n  is_quantum_predicate Q\n  P \\<le>\\<^sub>L Q\n\ngoal (1 subgoal):\n 1. wlp_while_n (M 0) (M 1) WS k P \\<le>\\<^sub>L\n    wlp_while_n (M 0) (M 1) WS k Q", "by auto"], ["proof (state)\nthis:\n  Wn P ?k \\<le>\\<^sub>L Wn Q ?k\n\ngoal (1 subgoal):\n 1. wlp_while (M 0) (M 1) WS P \\<le>\\<^sub>L wlp_while (M 0) (M 1) WS Q", "have \"is_quantum_predicate (Wn P k)\" for k"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_quantum_predicate (Wn P k)", "unfolding Wn_def M0_def M1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_quantum_predicate (wlp_while_n (M 0) (M 1) WS k P)", "using wlp_while_n_close assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>P.\n              is_quantum_predicate P \\<Longrightarrow>\n              is_quantum_predicate (?WS P);\n   measurement d 2 ?M; is_quantum_predicate ?P\\<rbrakk>\n  \\<Longrightarrow> is_quantum_predicate\n                     (wlp_while_n (?M 0) (?M 1) ?WS ?k ?P)\n  is_quantum_predicate ?P \\<Longrightarrow> is_quantum_predicate (WS ?P)\n  \\<lbrakk>is_quantum_predicate ?P; is_quantum_predicate ?Q;\n   ?P \\<le>\\<^sub>L ?Q\\<rbrakk>\n  \\<Longrightarrow> WS ?P \\<le>\\<^sub>L WS ?Q\n  measurement d 2 M\n  is_quantum_predicate P\n  is_quantum_predicate Q\n  P \\<le>\\<^sub>L Q\n\ngoal (1 subgoal):\n 1. is_quantum_predicate (wlp_while_n (M 0) (M 1) WS k P)", "by auto"], ["proof (state)\nthis:\n  is_quantum_predicate (Wn P ?k)\n\ngoal (1 subgoal):\n 1. wlp_while (M 0) (M 1) WS P \\<le>\\<^sub>L wlp_while (M 0) (M 1) WS Q", "then"], ["proof (chain)\npicking this:\n  is_quantum_predicate (Wn P ?k)", "have dWPk: \"Wn P k \\<in> carrier_mat d d\" for k"], ["proof (prove)\nusing this:\n  is_quantum_predicate (Wn P ?k)\n\ngoal (1 subgoal):\n 1. Wn P k \\<in> carrier_mat d d", "using is_quantum_predicate_def"], ["proof (prove)\nusing this:\n  is_quantum_predicate (Wn P ?k)\n  is_quantum_predicate ?P =\n  (?P \\<in> carrier_mat d d \\<and>\n   positive ?P \\<and> ?P \\<le>\\<^sub>L 1\\<^sub>m d)\n\ngoal (1 subgoal):\n 1. Wn P k \\<in> carrier_mat d d", "by auto"], ["proof (state)\nthis:\n  Wn P ?k \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. wlp_while (M 0) (M 1) WS P \\<le>\\<^sub>L wlp_while (M 0) (M 1) WS Q", "have \"is_quantum_predicate (Wn Q k)\" for k"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_quantum_predicate (Wn Q k)", "unfolding Wn_def M0_def M1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_quantum_predicate (wlp_while_n (M 0) (M 1) WS k Q)", "using wlp_while_n_close assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>P.\n              is_quantum_predicate P \\<Longrightarrow>\n              is_quantum_predicate (?WS P);\n   measurement d 2 ?M; is_quantum_predicate ?P\\<rbrakk>\n  \\<Longrightarrow> is_quantum_predicate\n                     (wlp_while_n (?M 0) (?M 1) ?WS ?k ?P)\n  is_quantum_predicate ?P \\<Longrightarrow> is_quantum_predicate (WS ?P)\n  \\<lbrakk>is_quantum_predicate ?P; is_quantum_predicate ?Q;\n   ?P \\<le>\\<^sub>L ?Q\\<rbrakk>\n  \\<Longrightarrow> WS ?P \\<le>\\<^sub>L WS ?Q\n  measurement d 2 M\n  is_quantum_predicate P\n  is_quantum_predicate Q\n  P \\<le>\\<^sub>L Q\n\ngoal (1 subgoal):\n 1. is_quantum_predicate (wlp_while_n (M 0) (M 1) WS k Q)", "by auto"], ["proof (state)\nthis:\n  is_quantum_predicate (Wn Q ?k)\n\ngoal (1 subgoal):\n 1. wlp_while (M 0) (M 1) WS P \\<le>\\<^sub>L wlp_while (M 0) (M 1) WS Q", "then"], ["proof (chain)\npicking this:\n  is_quantum_predicate (Wn Q ?k)", "have dWQk:\"Wn Q k \\<in> carrier_mat d d\" for k"], ["proof (prove)\nusing this:\n  is_quantum_predicate (Wn Q ?k)\n\ngoal (1 subgoal):\n 1. Wn Q k \\<in> carrier_mat d d", "using is_quantum_predicate_def"], ["proof (prove)\nusing this:\n  is_quantum_predicate (Wn Q ?k)\n  is_quantum_predicate ?P =\n  (?P \\<in> carrier_mat d d \\<and>\n   positive ?P \\<and> ?P \\<le>\\<^sub>L 1\\<^sub>m d)\n\ngoal (1 subgoal):\n 1. Wn Q k \\<in> carrier_mat d d", "by auto"], ["proof (state)\nthis:\n  Wn Q ?k \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. wlp_while (M 0) (M 1) WS P \\<le>\\<^sub>L wlp_while (M 0) (M 1) WS Q", "have \"is_quantum_predicate (W P)\" and lePk: \"(W P) \\<le>\\<^sub>L (Wn P k)\" and \"limit_mat (Wn P) (W P) d\" for k"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_quantum_predicate (W P) &&&\n    W P \\<le>\\<^sub>L Wn P k &&& limit_mat (Wn P) (W P) d", "unfolding W_def Wn_def M0_def M1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_quantum_predicate (wlp_while (M 0) (M 1) WS P) &&&\n    wlp_while (M 0) (M 1) WS P \\<le>\\<^sub>L\n    wlp_while_n (M 0) (M 1) WS k P &&&\n    limit_mat (\\<lambda>k. wlp_while_n (M 0) (M 1) WS k P)\n     (wlp_while (M 0) (M 1) WS P) d", "using wlp_while_exists assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>P.\n              is_quantum_predicate P \\<Longrightarrow>\n              is_quantum_predicate (?WS P);\n   \\<And>P Q.\n      \\<lbrakk>is_quantum_predicate P; is_quantum_predicate Q;\n       P \\<le>\\<^sub>L Q\\<rbrakk>\n      \\<Longrightarrow> ?WS P \\<le>\\<^sub>L ?WS Q;\n   measurement d 2 ?M; is_quantum_predicate ?P\\<rbrakk>\n  \\<Longrightarrow> is_quantum_predicate\n                     (wlp_while (?M 0) (?M 1) ?WS ?P) \\<and>\n                    (\\<forall>n.\n                        wlp_while (?M 0) (?M 1) ?WS ?P \\<le>\\<^sub>L\n                        wlp_while_n (?M 0) (?M 1) ?WS n ?P) \\<and>\n                    (\\<forall>W'.\n                        (\\<forall>n.\n                            W' \\<le>\\<^sub>L\n                            wlp_while_n (?M 0) (?M 1) ?WS n\n                             ?P) \\<longrightarrow>\n                        W' \\<le>\\<^sub>L\n                        wlp_while (?M 0) (?M 1) ?WS ?P) \\<and>\n                    limit_mat\n                     (\\<lambda>n. wlp_while_n (?M 0) (?M 1) ?WS n ?P)\n                     (wlp_while (?M 0) (?M 1) ?WS ?P) d\n  is_quantum_predicate ?P \\<Longrightarrow> is_quantum_predicate (WS ?P)\n  \\<lbrakk>is_quantum_predicate ?P; is_quantum_predicate ?Q;\n   ?P \\<le>\\<^sub>L ?Q\\<rbrakk>\n  \\<Longrightarrow> WS ?P \\<le>\\<^sub>L WS ?Q\n  measurement d 2 M\n  is_quantum_predicate P\n  is_quantum_predicate Q\n  P \\<le>\\<^sub>L Q\n\ngoal (1 subgoal):\n 1. is_quantum_predicate (wlp_while (M 0) (M 1) WS P) &&&\n    wlp_while (M 0) (M 1) WS P \\<le>\\<^sub>L\n    wlp_while_n (M 0) (M 1) WS k P &&&\n    limit_mat (\\<lambda>k. wlp_while_n (M 0) (M 1) WS k P)\n     (wlp_while (M 0) (M 1) WS P) d", "by auto"], ["proof (state)\nthis:\n  is_quantum_predicate (W P)\n  W P \\<le>\\<^sub>L Wn P ?k\n  limit_mat (Wn P) (W P) d\n\ngoal (1 subgoal):\n 1. wlp_while (M 0) (M 1) WS P \\<le>\\<^sub>L wlp_while (M 0) (M 1) WS Q", "then"], ["proof (chain)\npicking this:\n  is_quantum_predicate (W P)\n  W P \\<le>\\<^sub>L Wn P ?k\n  limit_mat (Wn P) (W P) d", "have dWP: \"W P \\<in> carrier_mat d d\""], ["proof (prove)\nusing this:\n  is_quantum_predicate (W P)\n  W P \\<le>\\<^sub>L Wn P ?k\n  limit_mat (Wn P) (W P) d\n\ngoal (1 subgoal):\n 1. W P \\<in> carrier_mat d d", "using is_quantum_predicate_def"], ["proof (prove)\nusing this:\n  is_quantum_predicate (W P)\n  W P \\<le>\\<^sub>L Wn P ?k\n  limit_mat (Wn P) (W P) d\n  is_quantum_predicate ?P =\n  (?P \\<in> carrier_mat d d \\<and>\n   positive ?P \\<and> ?P \\<le>\\<^sub>L 1\\<^sub>m d)\n\ngoal (1 subgoal):\n 1. W P \\<in> carrier_mat d d", "by auto"], ["proof (state)\nthis:\n  W P \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. wlp_while (M 0) (M 1) WS P \\<le>\\<^sub>L wlp_while (M 0) (M 1) WS Q", "have \"is_quantum_predicate (W Q)\" and \"(W Q) \\<le>\\<^sub>L (Wn Q k)\" \n    and glb:\"(\\<forall>k. W' \\<le>\\<^sub>L (Wn Q k)) \\<longrightarrow> W' \\<le>\\<^sub>L (W Q)\" and \"limit_mat (Wn Q) (W Q) d\" for k W'"], ["proof (prove)\ngoal (1 subgoal):\n 1. (is_quantum_predicate (W Q) &&& W Q \\<le>\\<^sub>L Wn Q k) &&&\n    (\\<forall>k. W' \\<le>\\<^sub>L Wn Q k) \\<longrightarrow>\n    W' \\<le>\\<^sub>L W Q &&&\n    limit_mat (Wn Q) (W Q) d", "unfolding W_def Wn_def M0_def M1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (is_quantum_predicate (wlp_while (M 0) (M 1) WS Q) &&&\n     wlp_while (M 0) (M 1) WS Q \\<le>\\<^sub>L\n     wlp_while_n (M 0) (M 1) WS k Q) &&&\n    (\\<forall>k.\n        W' \\<le>\\<^sub>L wlp_while_n (M 0) (M 1) WS k Q) \\<longrightarrow>\n    W' \\<le>\\<^sub>L wlp_while (M 0) (M 1) WS Q &&&\n    limit_mat (\\<lambda>k. wlp_while_n (M 0) (M 1) WS k Q)\n     (wlp_while (M 0) (M 1) WS Q) d", "using wlp_while_exists assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>P.\n              is_quantum_predicate P \\<Longrightarrow>\n              is_quantum_predicate (?WS P);\n   \\<And>P Q.\n      \\<lbrakk>is_quantum_predicate P; is_quantum_predicate Q;\n       P \\<le>\\<^sub>L Q\\<rbrakk>\n      \\<Longrightarrow> ?WS P \\<le>\\<^sub>L ?WS Q;\n   measurement d 2 ?M; is_quantum_predicate ?P\\<rbrakk>\n  \\<Longrightarrow> is_quantum_predicate\n                     (wlp_while (?M 0) (?M 1) ?WS ?P) \\<and>\n                    (\\<forall>n.\n                        wlp_while (?M 0) (?M 1) ?WS ?P \\<le>\\<^sub>L\n                        wlp_while_n (?M 0) (?M 1) ?WS n ?P) \\<and>\n                    (\\<forall>W'.\n                        (\\<forall>n.\n                            W' \\<le>\\<^sub>L\n                            wlp_while_n (?M 0) (?M 1) ?WS n\n                             ?P) \\<longrightarrow>\n                        W' \\<le>\\<^sub>L\n                        wlp_while (?M 0) (?M 1) ?WS ?P) \\<and>\n                    limit_mat\n                     (\\<lambda>n. wlp_while_n (?M 0) (?M 1) ?WS n ?P)\n                     (wlp_while (?M 0) (?M 1) ?WS ?P) d\n  is_quantum_predicate ?P \\<Longrightarrow> is_quantum_predicate (WS ?P)\n  \\<lbrakk>is_quantum_predicate ?P; is_quantum_predicate ?Q;\n   ?P \\<le>\\<^sub>L ?Q\\<rbrakk>\n  \\<Longrightarrow> WS ?P \\<le>\\<^sub>L WS ?Q\n  measurement d 2 M\n  is_quantum_predicate P\n  is_quantum_predicate Q\n  P \\<le>\\<^sub>L Q\n\ngoal (1 subgoal):\n 1. (is_quantum_predicate (wlp_while (M 0) (M 1) WS Q) &&&\n     wlp_while (M 0) (M 1) WS Q \\<le>\\<^sub>L\n     wlp_while_n (M 0) (M 1) WS k Q) &&&\n    (\\<forall>k.\n        W' \\<le>\\<^sub>L wlp_while_n (M 0) (M 1) WS k Q) \\<longrightarrow>\n    W' \\<le>\\<^sub>L wlp_while (M 0) (M 1) WS Q &&&\n    limit_mat (\\<lambda>k. wlp_while_n (M 0) (M 1) WS k Q)\n     (wlp_while (M 0) (M 1) WS Q) d", "by auto"], ["proof (state)\nthis:\n  is_quantum_predicate (W Q)\n  W Q \\<le>\\<^sub>L Wn Q ?k\n  (\\<forall>k. ?W' \\<le>\\<^sub>L Wn Q k) \\<longrightarrow>\n  ?W' \\<le>\\<^sub>L W Q\n  limit_mat (Wn Q) (W Q) d\n\ngoal (1 subgoal):\n 1. wlp_while (M 0) (M 1) WS P \\<le>\\<^sub>L wlp_while (M 0) (M 1) WS Q", "have \"W P \\<le>\\<^sub>L Wn Q k\" for k"], ["proof (prove)\ngoal (1 subgoal):\n 1. W P \\<le>\\<^sub>L Wn Q k", "using lowner_le_trans[of \"W P\" d \"Wn P k\" \"Wn Q k\"] lePk lePQk dWPk dWQk dWP"], ["proof (prove)\nusing this:\n  \\<lbrakk>W P \\<in> carrier_mat d d; Wn P k \\<in> carrier_mat d d;\n   Wn Q k \\<in> carrier_mat d d; W P \\<le>\\<^sub>L Wn P k;\n   Wn P k \\<le>\\<^sub>L Wn Q k\\<rbrakk>\n  \\<Longrightarrow> W P \\<le>\\<^sub>L Wn Q k\n  W P \\<le>\\<^sub>L Wn P ?k\n  Wn P ?k \\<le>\\<^sub>L Wn Q ?k\n  Wn P ?k \\<in> carrier_mat d d\n  Wn Q ?k \\<in> carrier_mat d d\n  W P \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. W P \\<le>\\<^sub>L Wn Q k", "by auto"], ["proof (state)\nthis:\n  W P \\<le>\\<^sub>L Wn Q ?k\n\ngoal (1 subgoal):\n 1. wlp_while (M 0) (M 1) WS P \\<le>\\<^sub>L wlp_while (M 0) (M 1) WS Q", "then"], ["proof (chain)\npicking this:\n  W P \\<le>\\<^sub>L Wn Q ?k", "show \"W P \\<le>\\<^sub>L W Q\""], ["proof (prove)\nusing this:\n  W P \\<le>\\<^sub>L Wn Q ?k\n\ngoal (1 subgoal):\n 1. W P \\<le>\\<^sub>L W Q", "using glb"], ["proof (prove)\nusing this:\n  W P \\<le>\\<^sub>L Wn Q ?k\n  (\\<forall>k. ?W' \\<le>\\<^sub>L Wn Q k) \\<longrightarrow>\n  ?W' \\<le>\\<^sub>L W Q\n\ngoal (1 subgoal):\n 1. W P \\<le>\\<^sub>L W Q", "by auto"], ["proof (state)\nthis:\n  W P \\<le>\\<^sub>L W Q\n\ngoal:\nNo subgoals!", "qed"], ["", "fun wlp :: \"com \\<Rightarrow> complex mat \\<Rightarrow> complex mat\" where\n  \"wlp SKIP P = P\"\n| \"wlp (Utrans U) P = adjoint U * P * U\"\n| \"wlp (Seq S1 S2) P = wlp S1 (wlp S2 P)\"\n| \"wlp (Measure n M S) P = wlp_measure n M (map wlp S) P\"\n| \"wlp (While M S) P = wlp_while (M 0) (M 1) (wlp S) P\""], ["", "lemma wlp_measure_expand_m:\n  assumes m: \"m \\<le> n\" and wc: \"well_com (Measure n M S)\"  \n  shows \"wlp (Measure m M S) P = matrix_sum d (\\<lambda>k. adjoint (M k) * (wlp (S!k) P) * (M k)) m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wlp (Measure m M S) P =\n    matrix_sum d (\\<lambda>k. adjoint (M k) * wlp (S ! k) P * M k) m", "unfolding wlp.simps wlp_measure_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_sum d (\\<lambda>k. adjoint (M k) * (map wlp S ! k) P * M k) m =\n    matrix_sum d (\\<lambda>k. adjoint (M k) * wlp (S ! k) P * M k) m", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. matrix_sum d (\\<lambda>k. adjoint (M k) * (map wlp S ! k) P * M k) m =\n    matrix_sum d (\\<lambda>k. adjoint (M k) * wlp (S ! k) P * M k) m", "have \"k < m \\<Longrightarrow> map wlp S ! k = wlp (S!k)\" for k"], ["proof (prove)\ngoal (1 subgoal):\n 1. k < m \\<Longrightarrow> map wlp S ! k = wlp (S ! k)", "using wc m"], ["proof (prove)\nusing this:\n  well_com (Measure n M S)\n  m \\<le> n\n\ngoal (1 subgoal):\n 1. k < m \\<Longrightarrow> map wlp S ! k = wlp (S ! k)", "by auto"], ["proof (state)\nthis:\n  ?k < m \\<Longrightarrow> map wlp S ! ?k = wlp (S ! ?k)\n\ngoal (1 subgoal):\n 1. matrix_sum d (\\<lambda>k. adjoint (M k) * (map wlp S ! k) P * M k) m =\n    matrix_sum d (\\<lambda>k. adjoint (M k) * wlp (S ! k) P * M k) m", "then"], ["proof (chain)\npicking this:\n  ?k < m \\<Longrightarrow> map wlp S ! ?k = wlp (S ! ?k)", "have \"k < m \\<Longrightarrow> (map wlp S ! k) P = wlp (S!k) P\" for k"], ["proof (prove)\nusing this:\n  ?k < m \\<Longrightarrow> map wlp S ! ?k = wlp (S ! ?k)\n\ngoal (1 subgoal):\n 1. k < m \\<Longrightarrow> (map wlp S ! k) P = wlp (S ! k) P", "by auto"], ["proof (state)\nthis:\n  ?k < m \\<Longrightarrow> (map wlp S ! ?k) P = wlp (S ! ?k) P\n\ngoal (1 subgoal):\n 1. matrix_sum d (\\<lambda>k. adjoint (M k) * (map wlp S ! k) P * M k) m =\n    matrix_sum d (\\<lambda>k. adjoint (M k) * wlp (S ! k) P * M k) m", "then"], ["proof (chain)\npicking this:\n  ?k < m \\<Longrightarrow> (map wlp S ! ?k) P = wlp (S ! ?k) P", "show \"matrix_sum d (\\<lambda>k. adjoint (M k) * ((map wlp S ! k) P) * (M k)) m\n    = matrix_sum d (\\<lambda>k. adjoint (M k) * (wlp (S!k) P) * (M k)) m\""], ["proof (prove)\nusing this:\n  ?k < m \\<Longrightarrow> (map wlp S ! ?k) P = wlp (S ! ?k) P\n\ngoal (1 subgoal):\n 1. matrix_sum d (\\<lambda>k. adjoint (M k) * (map wlp S ! k) P * M k) m =\n    matrix_sum d (\\<lambda>k. adjoint (M k) * wlp (S ! k) P * M k) m", "using matrix_sum_cong[of m \"\\<lambda>k. adjoint (M k) * ((map wlp S ! k) P) * (M k)\" \"\\<lambda>k. adjoint (M k) * (wlp (S!k) P) * (M k)\"]"], ["proof (prove)\nusing this:\n  ?k < m \\<Longrightarrow> (map wlp S ! ?k) P = wlp (S ! ?k) P\n  (\\<And>k.\n      k < m \\<Longrightarrow>\n      adjoint (M k) * (map wlp S ! k) P * M k =\n      adjoint (M k) * wlp (S ! k) P * M k) \\<Longrightarrow>\n  matrix_sum ?d (\\<lambda>k. adjoint (M k) * (map wlp S ! k) P * M k) m =\n  matrix_sum ?d (\\<lambda>k. adjoint (M k) * wlp (S ! k) P * M k) m\n\ngoal (1 subgoal):\n 1. matrix_sum d (\\<lambda>k. adjoint (M k) * (map wlp S ! k) P * M k) m =\n    matrix_sum d (\\<lambda>k. adjoint (M k) * wlp (S ! k) P * M k) m", "by auto"], ["proof (state)\nthis:\n  matrix_sum d (\\<lambda>k. adjoint (M k) * (map wlp S ! k) P * M k) m =\n  matrix_sum d (\\<lambda>k. adjoint (M k) * wlp (S ! k) P * M k) m\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma wlp_measure_expand:\n  assumes wc: \"well_com (Measure n M S)\"  \n  shows \"wlp (Measure n M S) P = matrix_sum d (\\<lambda>k. adjoint (M k) * (wlp (S!k) P) * (M k)) n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wlp (Measure n M S) P =\n    matrix_sum d (\\<lambda>k. adjoint (M k) * wlp (S ! k) P * M k) n", "using wlp_measure_expand_m[OF Nat.le_refl[of n]] wc"], ["proof (prove)\nusing this:\n  well_com (Measure n ?M ?S) \\<Longrightarrow>\n  wlp (Measure n ?M ?S) ?P =\n  matrix_sum d (\\<lambda>k. adjoint (?M k) * wlp (?S ! k) ?P * ?M k) n\n  well_com (Measure n M S)\n\ngoal (1 subgoal):\n 1. wlp (Measure n M S) P =\n    matrix_sum d (\\<lambda>k. adjoint (M k) * wlp (S ! k) P * M k) n", "by auto"], ["", "lemma wlp_mono_and_close:\n  shows \"well_com S \\<Longrightarrow> is_quantum_predicate P \\<Longrightarrow> is_quantum_predicate Q \\<Longrightarrow> P \\<le>\\<^sub>L Q \n        \\<Longrightarrow> is_quantum_predicate (wlp S P) \\<and> wlp S P \\<le>\\<^sub>L wlp S Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>well_com S; is_quantum_predicate P; is_quantum_predicate Q;\n     P \\<le>\\<^sub>L Q\\<rbrakk>\n    \\<Longrightarrow> is_quantum_predicate (wlp S P) \\<and>\n                      wlp S P \\<le>\\<^sub>L wlp S Q", "proof (induct S arbitrary: P Q)"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>P Q.\n       \\<lbrakk>well_com SKIP; is_quantum_predicate P;\n        is_quantum_predicate Q; P \\<le>\\<^sub>L Q\\<rbrakk>\n       \\<Longrightarrow> is_quantum_predicate (wlp SKIP P) \\<and>\n                         wlp SKIP P \\<le>\\<^sub>L wlp SKIP Q\n 2. \\<And>x P Q.\n       \\<lbrakk>well_com (Utrans x); is_quantum_predicate P;\n        is_quantum_predicate Q; P \\<le>\\<^sub>L Q\\<rbrakk>\n       \\<Longrightarrow> is_quantum_predicate (wlp (Utrans x) P) \\<and>\n                         wlp (Utrans x) P \\<le>\\<^sub>L wlp (Utrans x) Q\n 3. \\<And>S1 S2 P Q.\n       \\<lbrakk>\\<And>P Q.\n                   \\<lbrakk>well_com S1; is_quantum_predicate P;\n                    is_quantum_predicate Q; P \\<le>\\<^sub>L Q\\<rbrakk>\n                   \\<Longrightarrow> is_quantum_predicate (wlp S1 P) \\<and>\n                                     wlp S1 P \\<le>\\<^sub>L wlp S1 Q;\n        \\<And>P Q.\n           \\<lbrakk>well_com S2; is_quantum_predicate P;\n            is_quantum_predicate Q; P \\<le>\\<^sub>L Q\\<rbrakk>\n           \\<Longrightarrow> is_quantum_predicate (wlp S2 P) \\<and>\n                             wlp S2 P \\<le>\\<^sub>L wlp S2 Q;\n        well_com (S1;; S2); is_quantum_predicate P; is_quantum_predicate Q;\n        P \\<le>\\<^sub>L Q\\<rbrakk>\n       \\<Longrightarrow> is_quantum_predicate (wlp (S1;; S2) P) \\<and>\n                         wlp (S1;; S2) P \\<le>\\<^sub>L wlp (S1;; S2) Q\n 4. \\<And>x1 x2a x3 P Q.\n       \\<lbrakk>\\<And>x3a P Q.\n                   \\<lbrakk>x3a \\<in> set x3; well_com x3a;\n                    is_quantum_predicate P; is_quantum_predicate Q;\n                    P \\<le>\\<^sub>L Q\\<rbrakk>\n                   \\<Longrightarrow> is_quantum_predicate (wlp x3a P) \\<and>\n                                     wlp x3a P \\<le>\\<^sub>L wlp x3a Q;\n        well_com (Measure x1 x2a x3); is_quantum_predicate P;\n        is_quantum_predicate Q; P \\<le>\\<^sub>L Q\\<rbrakk>\n       \\<Longrightarrow> is_quantum_predicate\n                          (wlp (Measure x1 x2a x3) P) \\<and>\n                         wlp (Measure x1 x2a x3) P \\<le>\\<^sub>L\n                         wlp (Measure x1 x2a x3) Q\n 5. \\<And>x1 S P Q.\n       \\<lbrakk>\\<And>P Q.\n                   \\<lbrakk>well_com S; is_quantum_predicate P;\n                    is_quantum_predicate Q; P \\<le>\\<^sub>L Q\\<rbrakk>\n                   \\<Longrightarrow> is_quantum_predicate (wlp S P) \\<and>\n                                     wlp S P \\<le>\\<^sub>L wlp S Q;\n        well_com (While x1 S); is_quantum_predicate P;\n        is_quantum_predicate Q; P \\<le>\\<^sub>L Q\\<rbrakk>\n       \\<Longrightarrow> is_quantum_predicate (wlp (While x1 S) P) \\<and>\n                         wlp (While x1 S) P \\<le>\\<^sub>L wlp (While x1 S) Q", "case SKIP"], ["proof (state)\nthis:\n  well_com SKIP\n  is_quantum_predicate P\n  is_quantum_predicate Q\n  P \\<le>\\<^sub>L Q\n\ngoal (5 subgoals):\n 1. \\<And>P Q.\n       \\<lbrakk>well_com SKIP; is_quantum_predicate P;\n        is_quantum_predicate Q; P \\<le>\\<^sub>L Q\\<rbrakk>\n       \\<Longrightarrow> is_quantum_predicate (wlp SKIP P) \\<and>\n                         wlp SKIP P \\<le>\\<^sub>L wlp SKIP Q\n 2. \\<And>x P Q.\n       \\<lbrakk>well_com (Utrans x); is_quantum_predicate P;\n        is_quantum_predicate Q; P \\<le>\\<^sub>L Q\\<rbrakk>\n       \\<Longrightarrow> is_quantum_predicate (wlp (Utrans x) P) \\<and>\n                         wlp (Utrans x) P \\<le>\\<^sub>L wlp (Utrans x) Q\n 3. \\<And>S1 S2 P Q.\n       \\<lbrakk>\\<And>P Q.\n                   \\<lbrakk>well_com S1; is_quantum_predicate P;\n                    is_quantum_predicate Q; P \\<le>\\<^sub>L Q\\<rbrakk>\n                   \\<Longrightarrow> is_quantum_predicate (wlp S1 P) \\<and>\n                                     wlp S1 P \\<le>\\<^sub>L wlp S1 Q;\n        \\<And>P Q.\n           \\<lbrakk>well_com S2; is_quantum_predicate P;\n            is_quantum_predicate Q; P \\<le>\\<^sub>L Q\\<rbrakk>\n           \\<Longrightarrow> is_quantum_predicate (wlp S2 P) \\<and>\n                             wlp S2 P \\<le>\\<^sub>L wlp S2 Q;\n        well_com (S1;; S2); is_quantum_predicate P; is_quantum_predicate Q;\n        P \\<le>\\<^sub>L Q\\<rbrakk>\n       \\<Longrightarrow> is_quantum_predicate (wlp (S1;; S2) P) \\<and>\n                         wlp (S1;; S2) P \\<le>\\<^sub>L wlp (S1;; S2) Q\n 4. \\<And>x1 x2a x3 P Q.\n       \\<lbrakk>\\<And>x3a P Q.\n                   \\<lbrakk>x3a \\<in> set x3; well_com x3a;\n                    is_quantum_predicate P; is_quantum_predicate Q;\n                    P \\<le>\\<^sub>L Q\\<rbrakk>\n                   \\<Longrightarrow> is_quantum_predicate (wlp x3a P) \\<and>\n                                     wlp x3a P \\<le>\\<^sub>L wlp x3a Q;\n        well_com (Measure x1 x2a x3); is_quantum_predicate P;\n        is_quantum_predicate Q; P \\<le>\\<^sub>L Q\\<rbrakk>\n       \\<Longrightarrow> is_quantum_predicate\n                          (wlp (Measure x1 x2a x3) P) \\<and>\n                         wlp (Measure x1 x2a x3) P \\<le>\\<^sub>L\n                         wlp (Measure x1 x2a x3) Q\n 5. \\<And>x1 S P Q.\n       \\<lbrakk>\\<And>P Q.\n                   \\<lbrakk>well_com S; is_quantum_predicate P;\n                    is_quantum_predicate Q; P \\<le>\\<^sub>L Q\\<rbrakk>\n                   \\<Longrightarrow> is_quantum_predicate (wlp S P) \\<and>\n                                     wlp S P \\<le>\\<^sub>L wlp S Q;\n        well_com (While x1 S); is_quantum_predicate P;\n        is_quantum_predicate Q; P \\<le>\\<^sub>L Q\\<rbrakk>\n       \\<Longrightarrow> is_quantum_predicate (wlp (While x1 S) P) \\<and>\n                         wlp (While x1 S) P \\<le>\\<^sub>L wlp (While x1 S) Q", "then"], ["proof (chain)\npicking this:\n  well_com SKIP\n  is_quantum_predicate P\n  is_quantum_predicate Q\n  P \\<le>\\<^sub>L Q", "show ?case"], ["proof (prove)\nusing this:\n  well_com SKIP\n  is_quantum_predicate P\n  is_quantum_predicate Q\n  P \\<le>\\<^sub>L Q\n\ngoal (1 subgoal):\n 1. is_quantum_predicate (wlp SKIP P) \\<and>\n    wlp SKIP P \\<le>\\<^sub>L wlp SKIP Q", "by auto"], ["proof (state)\nthis:\n  is_quantum_predicate (wlp SKIP P) \\<and>\n  wlp SKIP P \\<le>\\<^sub>L wlp SKIP Q\n\ngoal (4 subgoals):\n 1. \\<And>x P Q.\n       \\<lbrakk>well_com (Utrans x); is_quantum_predicate P;\n        is_quantum_predicate Q; P \\<le>\\<^sub>L Q\\<rbrakk>\n       \\<Longrightarrow> is_quantum_predicate (wlp (Utrans x) P) \\<and>\n                         wlp (Utrans x) P \\<le>\\<^sub>L wlp (Utrans x) Q\n 2. \\<And>S1 S2 P Q.\n       \\<lbrakk>\\<And>P Q.\n                   \\<lbrakk>well_com S1; is_quantum_predicate P;\n                    is_quantum_predicate Q; P \\<le>\\<^sub>L Q\\<rbrakk>\n                   \\<Longrightarrow> is_quantum_predicate (wlp S1 P) \\<and>\n                                     wlp S1 P \\<le>\\<^sub>L wlp S1 Q;\n        \\<And>P Q.\n           \\<lbrakk>well_com S2; is_quantum_predicate P;\n            is_quantum_predicate Q; P \\<le>\\<^sub>L Q\\<rbrakk>\n           \\<Longrightarrow> is_quantum_predicate (wlp S2 P) \\<and>\n                             wlp S2 P \\<le>\\<^sub>L wlp S2 Q;\n        well_com (S1;; S2); is_quantum_predicate P; is_quantum_predicate Q;\n        P \\<le>\\<^sub>L Q\\<rbrakk>\n       \\<Longrightarrow> is_quantum_predicate (wlp (S1;; S2) P) \\<and>\n                         wlp (S1;; S2) P \\<le>\\<^sub>L wlp (S1;; S2) Q\n 3. \\<And>x1 x2a x3 P Q.\n       \\<lbrakk>\\<And>x3a P Q.\n                   \\<lbrakk>x3a \\<in> set x3; well_com x3a;\n                    is_quantum_predicate P; is_quantum_predicate Q;\n                    P \\<le>\\<^sub>L Q\\<rbrakk>\n                   \\<Longrightarrow> is_quantum_predicate (wlp x3a P) \\<and>\n                                     wlp x3a P \\<le>\\<^sub>L wlp x3a Q;\n        well_com (Measure x1 x2a x3); is_quantum_predicate P;\n        is_quantum_predicate Q; P \\<le>\\<^sub>L Q\\<rbrakk>\n       \\<Longrightarrow> is_quantum_predicate\n                          (wlp (Measure x1 x2a x3) P) \\<and>\n                         wlp (Measure x1 x2a x3) P \\<le>\\<^sub>L\n                         wlp (Measure x1 x2a x3) Q\n 4. \\<And>x1 S P Q.\n       \\<lbrakk>\\<And>P Q.\n                   \\<lbrakk>well_com S; is_quantum_predicate P;\n                    is_quantum_predicate Q; P \\<le>\\<^sub>L Q\\<rbrakk>\n                   \\<Longrightarrow> is_quantum_predicate (wlp S P) \\<and>\n                                     wlp S P \\<le>\\<^sub>L wlp S Q;\n        well_com (While x1 S); is_quantum_predicate P;\n        is_quantum_predicate Q; P \\<le>\\<^sub>L Q\\<rbrakk>\n       \\<Longrightarrow> is_quantum_predicate (wlp (While x1 S) P) \\<and>\n                         wlp (While x1 S) P \\<le>\\<^sub>L wlp (While x1 S) Q", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x P Q.\n       \\<lbrakk>well_com (Utrans x); is_quantum_predicate P;\n        is_quantum_predicate Q; P \\<le>\\<^sub>L Q\\<rbrakk>\n       \\<Longrightarrow> is_quantum_predicate (wlp (Utrans x) P) \\<and>\n                         wlp (Utrans x) P \\<le>\\<^sub>L wlp (Utrans x) Q\n 2. \\<And>S1 S2 P Q.\n       \\<lbrakk>\\<And>P Q.\n                   \\<lbrakk>well_com S1; is_quantum_predicate P;\n                    is_quantum_predicate Q; P \\<le>\\<^sub>L Q\\<rbrakk>\n                   \\<Longrightarrow> is_quantum_predicate (wlp S1 P) \\<and>\n                                     wlp S1 P \\<le>\\<^sub>L wlp S1 Q;\n        \\<And>P Q.\n           \\<lbrakk>well_com S2; is_quantum_predicate P;\n            is_quantum_predicate Q; P \\<le>\\<^sub>L Q\\<rbrakk>\n           \\<Longrightarrow> is_quantum_predicate (wlp S2 P) \\<and>\n                             wlp S2 P \\<le>\\<^sub>L wlp S2 Q;\n        well_com (S1;; S2); is_quantum_predicate P; is_quantum_predicate Q;\n        P \\<le>\\<^sub>L Q\\<rbrakk>\n       \\<Longrightarrow> is_quantum_predicate (wlp (S1;; S2) P) \\<and>\n                         wlp (S1;; S2) P \\<le>\\<^sub>L wlp (S1;; S2) Q\n 3. \\<And>x1 x2a x3 P Q.\n       \\<lbrakk>\\<And>x3a P Q.\n                   \\<lbrakk>x3a \\<in> set x3; well_com x3a;\n                    is_quantum_predicate P; is_quantum_predicate Q;\n                    P \\<le>\\<^sub>L Q\\<rbrakk>\n                   \\<Longrightarrow> is_quantum_predicate (wlp x3a P) \\<and>\n                                     wlp x3a P \\<le>\\<^sub>L wlp x3a Q;\n        well_com (Measure x1 x2a x3); is_quantum_predicate P;\n        is_quantum_predicate Q; P \\<le>\\<^sub>L Q\\<rbrakk>\n       \\<Longrightarrow> is_quantum_predicate\n                          (wlp (Measure x1 x2a x3) P) \\<and>\n                         wlp (Measure x1 x2a x3) P \\<le>\\<^sub>L\n                         wlp (Measure x1 x2a x3) Q\n 4. \\<And>x1 S P Q.\n       \\<lbrakk>\\<And>P Q.\n                   \\<lbrakk>well_com S; is_quantum_predicate P;\n                    is_quantum_predicate Q; P \\<le>\\<^sub>L Q\\<rbrakk>\n                   \\<Longrightarrow> is_quantum_predicate (wlp S P) \\<and>\n                                     wlp S P \\<le>\\<^sub>L wlp S Q;\n        well_com (While x1 S); is_quantum_predicate P;\n        is_quantum_predicate Q; P \\<le>\\<^sub>L Q\\<rbrakk>\n       \\<Longrightarrow> is_quantum_predicate (wlp (While x1 S) P) \\<and>\n                         wlp (While x1 S) P \\<le>\\<^sub>L wlp (While x1 S) Q", "case (Utrans U)"], ["proof (state)\nthis:\n  well_com (Utrans U)\n  is_quantum_predicate P\n  is_quantum_predicate Q\n  P \\<le>\\<^sub>L Q\n\ngoal (4 subgoals):\n 1. \\<And>x P Q.\n       \\<lbrakk>well_com (Utrans x); is_quantum_predicate P;\n        is_quantum_predicate Q; P \\<le>\\<^sub>L Q\\<rbrakk>\n       \\<Longrightarrow> is_quantum_predicate (wlp (Utrans x) P) \\<and>\n                         wlp (Utrans x) P \\<le>\\<^sub>L wlp (Utrans x) Q\n 2. \\<And>S1 S2 P Q.\n       \\<lbrakk>\\<And>P Q.\n                   \\<lbrakk>well_com S1; is_quantum_predicate P;\n                    is_quantum_predicate Q; P \\<le>\\<^sub>L Q\\<rbrakk>\n                   \\<Longrightarrow> is_quantum_predicate (wlp S1 P) \\<and>\n                                     wlp S1 P \\<le>\\<^sub>L wlp S1 Q;\n        \\<And>P Q.\n           \\<lbrakk>well_com S2; is_quantum_predicate P;\n            is_quantum_predicate Q; P \\<le>\\<^sub>L Q\\<rbrakk>\n           \\<Longrightarrow> is_quantum_predicate (wlp S2 P) \\<and>\n                             wlp S2 P \\<le>\\<^sub>L wlp S2 Q;\n        well_com (S1;; S2); is_quantum_predicate P; is_quantum_predicate Q;\n        P \\<le>\\<^sub>L Q\\<rbrakk>\n       \\<Longrightarrow> is_quantum_predicate (wlp (S1;; S2) P) \\<and>\n                         wlp (S1;; S2) P \\<le>\\<^sub>L wlp (S1;; S2) Q\n 3. \\<And>x1 x2a x3 P Q.\n       \\<lbrakk>\\<And>x3a P Q.\n                   \\<lbrakk>x3a \\<in> set x3; well_com x3a;\n                    is_quantum_predicate P; is_quantum_predicate Q;\n                    P \\<le>\\<^sub>L Q\\<rbrakk>\n                   \\<Longrightarrow> is_quantum_predicate (wlp x3a P) \\<and>\n                                     wlp x3a P \\<le>\\<^sub>L wlp x3a Q;\n        well_com (Measure x1 x2a x3); is_quantum_predicate P;\n        is_quantum_predicate Q; P \\<le>\\<^sub>L Q\\<rbrakk>\n       \\<Longrightarrow> is_quantum_predicate\n                          (wlp (Measure x1 x2a x3) P) \\<and>\n                         wlp (Measure x1 x2a x3) P \\<le>\\<^sub>L\n                         wlp (Measure x1 x2a x3) Q\n 4. \\<And>x1 S P Q.\n       \\<lbrakk>\\<And>P Q.\n                   \\<lbrakk>well_com S; is_quantum_predicate P;\n                    is_quantum_predicate Q; P \\<le>\\<^sub>L Q\\<rbrakk>\n                   \\<Longrightarrow> is_quantum_predicate (wlp S P) \\<and>\n                                     wlp S P \\<le>\\<^sub>L wlp S Q;\n        well_com (While x1 S); is_quantum_predicate P;\n        is_quantum_predicate Q; P \\<le>\\<^sub>L Q\\<rbrakk>\n       \\<Longrightarrow> is_quantum_predicate (wlp (While x1 S) P) \\<and>\n                         wlp (While x1 S) P \\<le>\\<^sub>L wlp (While x1 S) Q", "then"], ["proof (chain)\npicking this:\n  well_com (Utrans U)\n  is_quantum_predicate P\n  is_quantum_predicate Q\n  P \\<le>\\<^sub>L Q", "have dU: \"U \\<in> carrier_mat d d\" and u: \"unitary U\" and qp: \"is_quantum_predicate P\"  and le: \"P \\<le>\\<^sub>L Q\"\n    and dP: \"P \\<in> carrier_mat d d\" and dQ: \"Q \\<in> carrier_mat d d\""], ["proof (prove)\nusing this:\n  well_com (Utrans U)\n  is_quantum_predicate P\n  is_quantum_predicate Q\n  P \\<le>\\<^sub>L Q\n\ngoal (1 subgoal):\n 1. (U \\<in> carrier_mat d d &&& unitary U &&& is_quantum_predicate P) &&&\n    P \\<le>\\<^sub>L Q &&&\n    P \\<in> carrier_mat d d &&& Q \\<in> carrier_mat d d", "using is_quantum_predicate_def"], ["proof (prove)\nusing this:\n  well_com (Utrans U)\n  is_quantum_predicate P\n  is_quantum_predicate Q\n  P \\<le>\\<^sub>L Q\n  is_quantum_predicate ?P =\n  (?P \\<in> carrier_mat d d \\<and>\n   positive ?P \\<and> ?P \\<le>\\<^sub>L 1\\<^sub>m d)\n\ngoal (1 subgoal):\n 1. (U \\<in> carrier_mat d d &&& unitary U &&& is_quantum_predicate P) &&&\n    P \\<le>\\<^sub>L Q &&&\n    P \\<in> carrier_mat d d &&& Q \\<in> carrier_mat d d", "by auto"], ["proof (state)\nthis:\n  U \\<in> carrier_mat d d\n  unitary U\n  is_quantum_predicate P\n  P \\<le>\\<^sub>L Q\n  P \\<in> carrier_mat d d\n  Q \\<in> carrier_mat d d\n\ngoal (4 subgoals):\n 1. \\<And>x P Q.\n       \\<lbrakk>well_com (Utrans x); is_quantum_predicate P;\n        is_quantum_predicate Q; P \\<le>\\<^sub>L Q\\<rbrakk>\n       \\<Longrightarrow> is_quantum_predicate (wlp (Utrans x) P) \\<and>\n                         wlp (Utrans x) P \\<le>\\<^sub>L wlp (Utrans x) Q\n 2. \\<And>S1 S2 P Q.\n       \\<lbrakk>\\<And>P Q.\n                   \\<lbrakk>well_com S1; is_quantum_predicate P;\n                    is_quantum_predicate Q; P \\<le>\\<^sub>L Q\\<rbrakk>\n                   \\<Longrightarrow> is_quantum_predicate (wlp S1 P) \\<and>\n                                     wlp S1 P \\<le>\\<^sub>L wlp S1 Q;\n        \\<And>P Q.\n           \\<lbrakk>well_com S2; is_quantum_predicate P;\n            is_quantum_predicate Q; P \\<le>\\<^sub>L Q\\<rbrakk>\n           \\<Longrightarrow> is_quantum_predicate (wlp S2 P) \\<and>\n                             wlp S2 P \\<le>\\<^sub>L wlp S2 Q;\n        well_com (S1;; S2); is_quantum_predicate P; is_quantum_predicate Q;\n        P \\<le>\\<^sub>L Q\\<rbrakk>\n       \\<Longrightarrow> is_quantum_predicate (wlp (S1;; S2) P) \\<and>\n                         wlp (S1;; S2) P \\<le>\\<^sub>L wlp (S1;; S2) Q\n 3. \\<And>x1 x2a x3 P Q.\n       \\<lbrakk>\\<And>x3a P Q.\n                   \\<lbrakk>x3a \\<in> set x3; well_com x3a;\n                    is_quantum_predicate P; is_quantum_predicate Q;\n                    P \\<le>\\<^sub>L Q\\<rbrakk>\n                   \\<Longrightarrow> is_quantum_predicate (wlp x3a P) \\<and>\n                                     wlp x3a P \\<le>\\<^sub>L wlp x3a Q;\n        well_com (Measure x1 x2a x3); is_quantum_predicate P;\n        is_quantum_predicate Q; P \\<le>\\<^sub>L Q\\<rbrakk>\n       \\<Longrightarrow> is_quantum_predicate\n                          (wlp (Measure x1 x2a x3) P) \\<and>\n                         wlp (Measure x1 x2a x3) P \\<le>\\<^sub>L\n                         wlp (Measure x1 x2a x3) Q\n 4. \\<And>x1 S P Q.\n       \\<lbrakk>\\<And>P Q.\n                   \\<lbrakk>well_com S; is_quantum_predicate P;\n                    is_quantum_predicate Q; P \\<le>\\<^sub>L Q\\<rbrakk>\n                   \\<Longrightarrow> is_quantum_predicate (wlp S P) \\<and>\n                                     wlp S P \\<le>\\<^sub>L wlp S Q;\n        well_com (While x1 S); is_quantum_predicate P;\n        is_quantum_predicate Q; P \\<le>\\<^sub>L Q\\<rbrakk>\n       \\<Longrightarrow> is_quantum_predicate (wlp (While x1 S) P) \\<and>\n                         wlp (While x1 S) P \\<le>\\<^sub>L wlp (While x1 S) Q", "then"], ["proof (chain)\npicking this:\n  U \\<in> carrier_mat d d\n  unitary U\n  is_quantum_predicate P\n  P \\<le>\\<^sub>L Q\n  P \\<in> carrier_mat d d\n  Q \\<in> carrier_mat d d", "have qp': \"is_quantum_predicate (wlp (Utrans U) P)\""], ["proof (prove)\nusing this:\n  U \\<in> carrier_mat d d\n  unitary U\n  is_quantum_predicate P\n  P \\<le>\\<^sub>L Q\n  P \\<in> carrier_mat d d\n  Q \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. is_quantum_predicate (wlp (Utrans U) P)", "using qp_close_under_unitary_operator"], ["proof (prove)\nusing this:\n  U \\<in> carrier_mat d d\n  unitary U\n  is_quantum_predicate P\n  P \\<le>\\<^sub>L Q\n  P \\<in> carrier_mat d d\n  Q \\<in> carrier_mat d d\n  \\<lbrakk>?U \\<in> carrier_mat d d; unitary ?U;\n   is_quantum_predicate ?P\\<rbrakk>\n  \\<Longrightarrow> is_quantum_predicate (adjoint ?U * ?P * ?U)\n\ngoal (1 subgoal):\n 1. is_quantum_predicate (wlp (Utrans U) P)", "by auto"], ["proof (state)\nthis:\n  is_quantum_predicate (wlp (Utrans U) P)\n\ngoal (4 subgoals):\n 1. \\<And>x P Q.\n       \\<lbrakk>well_com (Utrans x); is_quantum_predicate P;\n        is_quantum_predicate Q; P \\<le>\\<^sub>L Q\\<rbrakk>\n       \\<Longrightarrow> is_quantum_predicate (wlp (Utrans x) P) \\<and>\n                         wlp (Utrans x) P \\<le>\\<^sub>L wlp (Utrans x) Q\n 2. \\<And>S1 S2 P Q.\n       \\<lbrakk>\\<And>P Q.\n                   \\<lbrakk>well_com S1; is_quantum_predicate P;\n                    is_quantum_predicate Q; P \\<le>\\<^sub>L Q\\<rbrakk>\n                   \\<Longrightarrow> is_quantum_predicate (wlp S1 P) \\<and>\n                                     wlp S1 P \\<le>\\<^sub>L wlp S1 Q;\n        \\<And>P Q.\n           \\<lbrakk>well_com S2; is_quantum_predicate P;\n            is_quantum_predicate Q; P \\<le>\\<^sub>L Q\\<rbrakk>\n           \\<Longrightarrow> is_quantum_predicate (wlp S2 P) \\<and>\n                             wlp S2 P \\<le>\\<^sub>L wlp S2 Q;\n        well_com (S1;; S2); is_quantum_predicate P; is_quantum_predicate Q;\n        P \\<le>\\<^sub>L Q\\<rbrakk>\n       \\<Longrightarrow> is_quantum_predicate (wlp (S1;; S2) P) \\<and>\n                         wlp (S1;; S2) P \\<le>\\<^sub>L wlp (S1;; S2) Q\n 3. \\<And>x1 x2a x3 P Q.\n       \\<lbrakk>\\<And>x3a P Q.\n                   \\<lbrakk>x3a \\<in> set x3; well_com x3a;\n                    is_quantum_predicate P; is_quantum_predicate Q;\n                    P \\<le>\\<^sub>L Q\\<rbrakk>\n                   \\<Longrightarrow> is_quantum_predicate (wlp x3a P) \\<and>\n                                     wlp x3a P \\<le>\\<^sub>L wlp x3a Q;\n        well_com (Measure x1 x2a x3); is_quantum_predicate P;\n        is_quantum_predicate Q; P \\<le>\\<^sub>L Q\\<rbrakk>\n       \\<Longrightarrow> is_quantum_predicate\n                          (wlp (Measure x1 x2a x3) P) \\<and>\n                         wlp (Measure x1 x2a x3) P \\<le>\\<^sub>L\n                         wlp (Measure x1 x2a x3) Q\n 4. \\<And>x1 S P Q.\n       \\<lbrakk>\\<And>P Q.\n                   \\<lbrakk>well_com S; is_quantum_predicate P;\n                    is_quantum_predicate Q; P \\<le>\\<^sub>L Q\\<rbrakk>\n                   \\<Longrightarrow> is_quantum_predicate (wlp S P) \\<and>\n                                     wlp S P \\<le>\\<^sub>L wlp S Q;\n        well_com (While x1 S); is_quantum_predicate P;\n        is_quantum_predicate Q; P \\<le>\\<^sub>L Q\\<rbrakk>\n       \\<Longrightarrow> is_quantum_predicate (wlp (While x1 S) P) \\<and>\n                         wlp (While x1 S) P \\<le>\\<^sub>L wlp (While x1 S) Q", "moreover"], ["proof (state)\nthis:\n  is_quantum_predicate (wlp (Utrans U) P)\n\ngoal (4 subgoals):\n 1. \\<And>x P Q.\n       \\<lbrakk>well_com (Utrans x); is_quantum_predicate P;\n        is_quantum_predicate Q; P \\<le>\\<^sub>L Q\\<rbrakk>\n       \\<Longrightarrow> is_quantum_predicate (wlp (Utrans x) P) \\<and>\n                         wlp (Utrans x) P \\<le>\\<^sub>L wlp (Utrans x) Q\n 2. \\<And>S1 S2 P Q.\n       \\<lbrakk>\\<And>P Q.\n                   \\<lbrakk>well_com S1; is_quantum_predicate P;\n                    is_quantum_predicate Q; P \\<le>\\<^sub>L Q\\<rbrakk>\n                   \\<Longrightarrow> is_quantum_predicate (wlp S1 P) \\<and>\n                                     wlp S1 P \\<le>\\<^sub>L wlp S1 Q;\n        \\<And>P Q.\n           \\<lbrakk>well_com S2; is_quantum_predicate P;\n            is_quantum_predicate Q; P \\<le>\\<^sub>L Q\\<rbrakk>\n           \\<Longrightarrow> is_quantum_predicate (wlp S2 P) \\<and>\n                             wlp S2 P \\<le>\\<^sub>L wlp S2 Q;\n        well_com (S1;; S2); is_quantum_predicate P; is_quantum_predicate Q;\n        P \\<le>\\<^sub>L Q\\<rbrakk>\n       \\<Longrightarrow> is_quantum_predicate (wlp (S1;; S2) P) \\<and>\n                         wlp (S1;; S2) P \\<le>\\<^sub>L wlp (S1;; S2) Q\n 3. \\<And>x1 x2a x3 P Q.\n       \\<lbrakk>\\<And>x3a P Q.\n                   \\<lbrakk>x3a \\<in> set x3; well_com x3a;\n                    is_quantum_predicate P; is_quantum_predicate Q;\n                    P \\<le>\\<^sub>L Q\\<rbrakk>\n                   \\<Longrightarrow> is_quantum_predicate (wlp x3a P) \\<and>\n                                     wlp x3a P \\<le>\\<^sub>L wlp x3a Q;\n        well_com (Measure x1 x2a x3); is_quantum_predicate P;\n        is_quantum_predicate Q; P \\<le>\\<^sub>L Q\\<rbrakk>\n       \\<Longrightarrow> is_quantum_predicate\n                          (wlp (Measure x1 x2a x3) P) \\<and>\n                         wlp (Measure x1 x2a x3) P \\<le>\\<^sub>L\n                         wlp (Measure x1 x2a x3) Q\n 4. \\<And>x1 S P Q.\n       \\<lbrakk>\\<And>P Q.\n                   \\<lbrakk>well_com S; is_quantum_predicate P;\n                    is_quantum_predicate Q; P \\<le>\\<^sub>L Q\\<rbrakk>\n                   \\<Longrightarrow> is_quantum_predicate (wlp S P) \\<and>\n                                     wlp S P \\<le>\\<^sub>L wlp S Q;\n        well_com (While x1 S); is_quantum_predicate P;\n        is_quantum_predicate Q; P \\<le>\\<^sub>L Q\\<rbrakk>\n       \\<Longrightarrow> is_quantum_predicate (wlp (While x1 S) P) \\<and>\n                         wlp (While x1 S) P \\<le>\\<^sub>L wlp (While x1 S) Q", "have \"adjoint U * P * U \\<le>\\<^sub>L adjoint U * Q * U\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adjoint U * P * U \\<le>\\<^sub>L adjoint U * Q * U", "using lowner_le_keep_under_measurement[OF dU dP dQ le]"], ["proof (prove)\nusing this:\n  adjoint U * P * U \\<le>\\<^sub>L adjoint U * Q * U\n\ngoal (1 subgoal):\n 1. adjoint U * P * U \\<le>\\<^sub>L adjoint U * Q * U", "by auto"], ["proof (state)\nthis:\n  adjoint U * P * U \\<le>\\<^sub>L adjoint U * Q * U\n\ngoal (4 subgoals):\n 1. \\<And>x P Q.\n       \\<lbrakk>well_com (Utrans x); is_quantum_predicate P;\n        is_quantum_predicate Q; P \\<le>\\<^sub>L Q\\<rbrakk>\n       \\<Longrightarrow> is_quantum_predicate (wlp (Utrans x) P) \\<and>\n                         wlp (Utrans x) P \\<le>\\<^sub>L wlp (Utrans x) Q\n 2. \\<And>S1 S2 P Q.\n       \\<lbrakk>\\<And>P Q.\n                   \\<lbrakk>well_com S1; is_quantum_predicate P;\n                    is_quantum_predicate Q; P \\<le>\\<^sub>L Q\\<rbrakk>\n                   \\<Longrightarrow> is_quantum_predicate (wlp S1 P) \\<and>\n                                     wlp S1 P \\<le>\\<^sub>L wlp S1 Q;\n        \\<And>P Q.\n           \\<lbrakk>well_com S2; is_quantum_predicate P;\n            is_quantum_predicate Q; P \\<le>\\<^sub>L Q\\<rbrakk>\n           \\<Longrightarrow> is_quantum_predicate (wlp S2 P) \\<and>\n                             wlp S2 P \\<le>\\<^sub>L wlp S2 Q;\n        well_com (S1;; S2); is_quantum_predicate P; is_quantum_predicate Q;\n        P \\<le>\\<^sub>L Q\\<rbrakk>\n       \\<Longrightarrow> is_quantum_predicate (wlp (S1;; S2) P) \\<and>\n                         wlp (S1;; S2) P \\<le>\\<^sub>L wlp (S1;; S2) Q\n 3. \\<And>x1 x2a x3 P Q.\n       \\<lbrakk>\\<And>x3a P Q.\n                   \\<lbrakk>x3a \\<in> set x3; well_com x3a;\n                    is_quantum_predicate P; is_quantum_predicate Q;\n                    P \\<le>\\<^sub>L Q\\<rbrakk>\n                   \\<Longrightarrow> is_quantum_predicate (wlp x3a P) \\<and>\n                                     wlp x3a P \\<le>\\<^sub>L wlp x3a Q;\n        well_com (Measure x1 x2a x3); is_quantum_predicate P;\n        is_quantum_predicate Q; P \\<le>\\<^sub>L Q\\<rbrakk>\n       \\<Longrightarrow> is_quantum_predicate\n                          (wlp (Measure x1 x2a x3) P) \\<and>\n                         wlp (Measure x1 x2a x3) P \\<le>\\<^sub>L\n                         wlp (Measure x1 x2a x3) Q\n 4. \\<And>x1 S P Q.\n       \\<lbrakk>\\<And>P Q.\n                   \\<lbrakk>well_com S; is_quantum_predicate P;\n                    is_quantum_predicate Q; P \\<le>\\<^sub>L Q\\<rbrakk>\n                   \\<Longrightarrow> is_quantum_predicate (wlp S P) \\<and>\n                                     wlp S P \\<le>\\<^sub>L wlp S Q;\n        well_com (While x1 S); is_quantum_predicate P;\n        is_quantum_predicate Q; P \\<le>\\<^sub>L Q\\<rbrakk>\n       \\<Longrightarrow> is_quantum_predicate (wlp (While x1 S) P) \\<and>\n                         wlp (While x1 S) P \\<le>\\<^sub>L wlp (While x1 S) Q", "ultimately"], ["proof (chain)\npicking this:\n  is_quantum_predicate (wlp (Utrans U) P)\n  adjoint U * P * U \\<le>\\<^sub>L adjoint U * Q * U", "show ?case"], ["proof (prove)\nusing this:\n  is_quantum_predicate (wlp (Utrans U) P)\n  adjoint U * P * U \\<le>\\<^sub>L adjoint U * Q * U\n\ngoal (1 subgoal):\n 1. is_quantum_predicate (wlp (Utrans U) P) \\<and>\n    wlp (Utrans U) P \\<le>\\<^sub>L wlp (Utrans U) Q", "by auto"], ["proof (state)\nthis:\n  is_quantum_predicate (wlp (Utrans U) P) \\<and>\n  wlp (Utrans U) P \\<le>\\<^sub>L wlp (Utrans U) Q\n\ngoal (3 subgoals):\n 1. \\<And>S1 S2 P Q.\n       \\<lbrakk>\\<And>P Q.\n                   \\<lbrakk>well_com S1; is_quantum_predicate P;\n                    is_quantum_predicate Q; P \\<le>\\<^sub>L Q\\<rbrakk>\n                   \\<Longrightarrow> is_quantum_predicate (wlp S1 P) \\<and>\n                                     wlp S1 P \\<le>\\<^sub>L wlp S1 Q;\n        \\<And>P Q.\n           \\<lbrakk>well_com S2; is_quantum_predicate P;\n            is_quantum_predicate Q; P \\<le>\\<^sub>L Q\\<rbrakk>\n           \\<Longrightarrow> is_quantum_predicate (wlp S2 P) \\<and>\n                             wlp S2 P \\<le>\\<^sub>L wlp S2 Q;\n        well_com (S1;; S2); is_quantum_predicate P; is_quantum_predicate Q;\n        P \\<le>\\<^sub>L Q\\<rbrakk>\n       \\<Longrightarrow> is_quantum_predicate (wlp (S1;; S2) P) \\<and>\n                         wlp (S1;; S2) P \\<le>\\<^sub>L wlp (S1;; S2) Q\n 2. \\<And>x1 x2a x3 P Q.\n       \\<lbrakk>\\<And>x3a P Q.\n                   \\<lbrakk>x3a \\<in> set x3; well_com x3a;\n                    is_quantum_predicate P; is_quantum_predicate Q;\n                    P \\<le>\\<^sub>L Q\\<rbrakk>\n                   \\<Longrightarrow> is_quantum_predicate (wlp x3a P) \\<and>\n                                     wlp x3a P \\<le>\\<^sub>L wlp x3a Q;\n        well_com (Measure x1 x2a x3); is_quantum_predicate P;\n        is_quantum_predicate Q; P \\<le>\\<^sub>L Q\\<rbrakk>\n       \\<Longrightarrow> is_quantum_predicate\n                          (wlp (Measure x1 x2a x3) P) \\<and>\n                         wlp (Measure x1 x2a x3) P \\<le>\\<^sub>L\n                         wlp (Measure x1 x2a x3) Q\n 3. \\<And>x1 S P Q.\n       \\<lbrakk>\\<And>P Q.\n                   \\<lbrakk>well_com S; is_quantum_predicate P;\n                    is_quantum_predicate Q; P \\<le>\\<^sub>L Q\\<rbrakk>\n                   \\<Longrightarrow> is_quantum_predicate (wlp S P) \\<and>\n                                     wlp S P \\<le>\\<^sub>L wlp S Q;\n        well_com (While x1 S); is_quantum_predicate P;\n        is_quantum_predicate Q; P \\<le>\\<^sub>L Q\\<rbrakk>\n       \\<Longrightarrow> is_quantum_predicate (wlp (While x1 S) P) \\<and>\n                         wlp (While x1 S) P \\<le>\\<^sub>L wlp (While x1 S) Q", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>S1 S2 P Q.\n       \\<lbrakk>\\<And>P Q.\n                   \\<lbrakk>well_com S1; is_quantum_predicate P;\n                    is_quantum_predicate Q; P \\<le>\\<^sub>L Q\\<rbrakk>\n                   \\<Longrightarrow> is_quantum_predicate (wlp S1 P) \\<and>\n                                     wlp S1 P \\<le>\\<^sub>L wlp S1 Q;\n        \\<And>P Q.\n           \\<lbrakk>well_com S2; is_quantum_predicate P;\n            is_quantum_predicate Q; P \\<le>\\<^sub>L Q\\<rbrakk>\n           \\<Longrightarrow> is_quantum_predicate (wlp S2 P) \\<and>\n                             wlp S2 P \\<le>\\<^sub>L wlp S2 Q;\n        well_com (S1;; S2); is_quantum_predicate P; is_quantum_predicate Q;\n        P \\<le>\\<^sub>L Q\\<rbrakk>\n       \\<Longrightarrow> is_quantum_predicate (wlp (S1;; S2) P) \\<and>\n                         wlp (S1;; S2) P \\<le>\\<^sub>L wlp (S1;; S2) Q\n 2. \\<And>x1 x2a x3 P Q.\n       \\<lbrakk>\\<And>x3a P Q.\n                   \\<lbrakk>x3a \\<in> set x3; well_com x3a;\n                    is_quantum_predicate P; is_quantum_predicate Q;\n                    P \\<le>\\<^sub>L Q\\<rbrakk>\n                   \\<Longrightarrow> is_quantum_predicate (wlp x3a P) \\<and>\n                                     wlp x3a P \\<le>\\<^sub>L wlp x3a Q;\n        well_com (Measure x1 x2a x3); is_quantum_predicate P;\n        is_quantum_predicate Q; P \\<le>\\<^sub>L Q\\<rbrakk>\n       \\<Longrightarrow> is_quantum_predicate\n                          (wlp (Measure x1 x2a x3) P) \\<and>\n                         wlp (Measure x1 x2a x3) P \\<le>\\<^sub>L\n                         wlp (Measure x1 x2a x3) Q\n 3. \\<And>x1 S P Q.\n       \\<lbrakk>\\<And>P Q.\n                   \\<lbrakk>well_com S; is_quantum_predicate P;\n                    is_quantum_predicate Q; P \\<le>\\<^sub>L Q\\<rbrakk>\n                   \\<Longrightarrow> is_quantum_predicate (wlp S P) \\<and>\n                                     wlp S P \\<le>\\<^sub>L wlp S Q;\n        well_com (While x1 S); is_quantum_predicate P;\n        is_quantum_predicate Q; P \\<le>\\<^sub>L Q\\<rbrakk>\n       \\<Longrightarrow> is_quantum_predicate (wlp (While x1 S) P) \\<and>\n                         wlp (While x1 S) P \\<le>\\<^sub>L wlp (While x1 S) Q", "case (Seq S1 S2)"], ["proof (state)\nthis:\n  \\<lbrakk>well_com S1; is_quantum_predicate ?P; is_quantum_predicate ?Q;\n   ?P \\<le>\\<^sub>L ?Q\\<rbrakk>\n  \\<Longrightarrow> is_quantum_predicate (wlp S1 ?P) \\<and>\n                    wlp S1 ?P \\<le>\\<^sub>L wlp S1 ?Q\n  \\<lbrakk>well_com S2; is_quantum_predicate ?P; is_quantum_predicate ?Q;\n   ?P \\<le>\\<^sub>L ?Q\\<rbrakk>\n  \\<Longrightarrow> is_quantum_predicate (wlp S2 ?P) \\<and>\n                    wlp S2 ?P \\<le>\\<^sub>L wlp S2 ?Q\n  well_com (S1;; S2)\n  is_quantum_predicate P\n  is_quantum_predicate Q\n  P \\<le>\\<^sub>L Q\n\ngoal (3 subgoals):\n 1. \\<And>S1 S2 P Q.\n       \\<lbrakk>\\<And>P Q.\n                   \\<lbrakk>well_com S1; is_quantum_predicate P;\n                    is_quantum_predicate Q; P \\<le>\\<^sub>L Q\\<rbrakk>\n                   \\<Longrightarrow> is_quantum_predicate (wlp S1 P) \\<and>\n                                     wlp S1 P \\<le>\\<^sub>L wlp S1 Q;\n        \\<And>P Q.\n           \\<lbrakk>well_com S2; is_quantum_predicate P;\n            is_quantum_predicate Q; P \\<le>\\<^sub>L Q\\<rbrakk>\n           \\<Longrightarrow> is_quantum_predicate (wlp S2 P) \\<and>\n                             wlp S2 P \\<le>\\<^sub>L wlp S2 Q;\n        well_com (S1;; S2); is_quantum_predicate P; is_quantum_predicate Q;\n        P \\<le>\\<^sub>L Q\\<rbrakk>\n       \\<Longrightarrow> is_quantum_predicate (wlp (S1;; S2) P) \\<and>\n                         wlp (S1;; S2) P \\<le>\\<^sub>L wlp (S1;; S2) Q\n 2. \\<And>x1 x2a x3 P Q.\n       \\<lbrakk>\\<And>x3a P Q.\n                   \\<lbrakk>x3a \\<in> set x3; well_com x3a;\n                    is_quantum_predicate P; is_quantum_predicate Q;\n                    P \\<le>\\<^sub>L Q\\<rbrakk>\n                   \\<Longrightarrow> is_quantum_predicate (wlp x3a P) \\<and>\n                                     wlp x3a P \\<le>\\<^sub>L wlp x3a Q;\n        well_com (Measure x1 x2a x3); is_quantum_predicate P;\n        is_quantum_predicate Q; P \\<le>\\<^sub>L Q\\<rbrakk>\n       \\<Longrightarrow> is_quantum_predicate\n                          (wlp (Measure x1 x2a x3) P) \\<and>\n                         wlp (Measure x1 x2a x3) P \\<le>\\<^sub>L\n                         wlp (Measure x1 x2a x3) Q\n 3. \\<And>x1 S P Q.\n       \\<lbrakk>\\<And>P Q.\n                   \\<lbrakk>well_com S; is_quantum_predicate P;\n                    is_quantum_predicate Q; P \\<le>\\<^sub>L Q\\<rbrakk>\n                   \\<Longrightarrow> is_quantum_predicate (wlp S P) \\<and>\n                                     wlp S P \\<le>\\<^sub>L wlp S Q;\n        well_com (While x1 S); is_quantum_predicate P;\n        is_quantum_predicate Q; P \\<le>\\<^sub>L Q\\<rbrakk>\n       \\<Longrightarrow> is_quantum_predicate (wlp (While x1 S) P) \\<and>\n                         wlp (While x1 S) P \\<le>\\<^sub>L wlp (While x1 S) Q", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>well_com S1; is_quantum_predicate ?P; is_quantum_predicate ?Q;\n   ?P \\<le>\\<^sub>L ?Q\\<rbrakk>\n  \\<Longrightarrow> is_quantum_predicate (wlp S1 ?P) \\<and>\n                    wlp S1 ?P \\<le>\\<^sub>L wlp S1 ?Q\n  \\<lbrakk>well_com S2; is_quantum_predicate ?P; is_quantum_predicate ?Q;\n   ?P \\<le>\\<^sub>L ?Q\\<rbrakk>\n  \\<Longrightarrow> is_quantum_predicate (wlp S2 ?P) \\<and>\n                    wlp S2 ?P \\<le>\\<^sub>L wlp S2 ?Q\n  well_com (S1;; S2)\n  is_quantum_predicate P\n  is_quantum_predicate Q\n  P \\<le>\\<^sub>L Q", "have qpP: \"is_quantum_predicate P\" and qpQ: \"is_quantum_predicate Q\" and wc1: \"well_com S1\" and wc2: \"well_com S2\" \n    and dP: \"P \\<in> carrier_mat d d\" and dQ: \"Q \\<in> carrier_mat d d\" and le: \"P \\<le>\\<^sub>L Q\""], ["proof (prove)\nusing this:\n  \\<lbrakk>well_com S1; is_quantum_predicate ?P; is_quantum_predicate ?Q;\n   ?P \\<le>\\<^sub>L ?Q\\<rbrakk>\n  \\<Longrightarrow> is_quantum_predicate (wlp S1 ?P) \\<and>\n                    wlp S1 ?P \\<le>\\<^sub>L wlp S1 ?Q\n  \\<lbrakk>well_com S2; is_quantum_predicate ?P; is_quantum_predicate ?Q;\n   ?P \\<le>\\<^sub>L ?Q\\<rbrakk>\n  \\<Longrightarrow> is_quantum_predicate (wlp S2 ?P) \\<and>\n                    wlp S2 ?P \\<le>\\<^sub>L wlp S2 ?Q\n  well_com (S1;; S2)\n  is_quantum_predicate P\n  is_quantum_predicate Q\n  P \\<le>\\<^sub>L Q\n\ngoal (1 subgoal):\n 1. (is_quantum_predicate P &&& is_quantum_predicate Q &&& well_com S1) &&&\n    (well_com S2 &&& P \\<in> carrier_mat d d) &&&\n    Q \\<in> carrier_mat d d &&& P \\<le>\\<^sub>L Q", "using is_quantum_predicate_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>well_com S1; is_quantum_predicate ?P; is_quantum_predicate ?Q;\n   ?P \\<le>\\<^sub>L ?Q\\<rbrakk>\n  \\<Longrightarrow> is_quantum_predicate (wlp S1 ?P) \\<and>\n                    wlp S1 ?P \\<le>\\<^sub>L wlp S1 ?Q\n  \\<lbrakk>well_com S2; is_quantum_predicate ?P; is_quantum_predicate ?Q;\n   ?P \\<le>\\<^sub>L ?Q\\<rbrakk>\n  \\<Longrightarrow> is_quantum_predicate (wlp S2 ?P) \\<and>\n                    wlp S2 ?P \\<le>\\<^sub>L wlp S2 ?Q\n  well_com (S1;; S2)\n  is_quantum_predicate P\n  is_quantum_predicate Q\n  P \\<le>\\<^sub>L Q\n  is_quantum_predicate ?P =\n  (?P \\<in> carrier_mat d d \\<and>\n   positive ?P \\<and> ?P \\<le>\\<^sub>L 1\\<^sub>m d)\n\ngoal (1 subgoal):\n 1. (is_quantum_predicate P &&& is_quantum_predicate Q &&& well_com S1) &&&\n    (well_com S2 &&& P \\<in> carrier_mat d d) &&&\n    Q \\<in> carrier_mat d d &&& P \\<le>\\<^sub>L Q", "by auto"], ["proof (state)\nthis:\n  is_quantum_predicate P\n  is_quantum_predicate Q\n  well_com S1\n  well_com S2\n  P \\<in> carrier_mat d d\n  Q \\<in> carrier_mat d d\n  P \\<le>\\<^sub>L Q\n\ngoal (3 subgoals):\n 1. \\<And>S1 S2 P Q.\n       \\<lbrakk>\\<And>P Q.\n                   \\<lbrakk>well_com S1; is_quantum_predicate P;\n                    is_quantum_predicate Q; P \\<le>\\<^sub>L Q\\<rbrakk>\n                   \\<Longrightarrow> is_quantum_predicate (wlp S1 P) \\<and>\n                                     wlp S1 P \\<le>\\<^sub>L wlp S1 Q;\n        \\<And>P Q.\n           \\<lbrakk>well_com S2; is_quantum_predicate P;\n            is_quantum_predicate Q; P \\<le>\\<^sub>L Q\\<rbrakk>\n           \\<Longrightarrow> is_quantum_predicate (wlp S2 P) \\<and>\n                             wlp S2 P \\<le>\\<^sub>L wlp S2 Q;\n        well_com (S1;; S2); is_quantum_predicate P; is_quantum_predicate Q;\n        P \\<le>\\<^sub>L Q\\<rbrakk>\n       \\<Longrightarrow> is_quantum_predicate (wlp (S1;; S2) P) \\<and>\n                         wlp (S1;; S2) P \\<le>\\<^sub>L wlp (S1;; S2) Q\n 2. \\<And>x1 x2a x3 P Q.\n       \\<lbrakk>\\<And>x3a P Q.\n                   \\<lbrakk>x3a \\<in> set x3; well_com x3a;\n                    is_quantum_predicate P; is_quantum_predicate Q;\n                    P \\<le>\\<^sub>L Q\\<rbrakk>\n                   \\<Longrightarrow> is_quantum_predicate (wlp x3a P) \\<and>\n                                     wlp x3a P \\<le>\\<^sub>L wlp x3a Q;\n        well_com (Measure x1 x2a x3); is_quantum_predicate P;\n        is_quantum_predicate Q; P \\<le>\\<^sub>L Q\\<rbrakk>\n       \\<Longrightarrow> is_quantum_predicate\n                          (wlp (Measure x1 x2a x3) P) \\<and>\n                         wlp (Measure x1 x2a x3) P \\<le>\\<^sub>L\n                         wlp (Measure x1 x2a x3) Q\n 3. \\<And>x1 S P Q.\n       \\<lbrakk>\\<And>P Q.\n                   \\<lbrakk>well_com S; is_quantum_predicate P;\n                    is_quantum_predicate Q; P \\<le>\\<^sub>L Q\\<rbrakk>\n                   \\<Longrightarrow> is_quantum_predicate (wlp S P) \\<and>\n                                     wlp S P \\<le>\\<^sub>L wlp S Q;\n        well_com (While x1 S); is_quantum_predicate P;\n        is_quantum_predicate Q; P \\<le>\\<^sub>L Q\\<rbrakk>\n       \\<Longrightarrow> is_quantum_predicate (wlp (While x1 S) P) \\<and>\n                         wlp (While x1 S) P \\<le>\\<^sub>L wlp (While x1 S) Q", "have qpP2: \"is_quantum_predicate (wlp S2 P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_quantum_predicate (wlp S2 P)", "using Seq qpP wc2"], ["proof (prove)\nusing this:\n  \\<lbrakk>well_com S1; is_quantum_predicate ?P; is_quantum_predicate ?Q;\n   ?P \\<le>\\<^sub>L ?Q\\<rbrakk>\n  \\<Longrightarrow> is_quantum_predicate (wlp S1 ?P) \\<and>\n                    wlp S1 ?P \\<le>\\<^sub>L wlp S1 ?Q\n  \\<lbrakk>well_com S2; is_quantum_predicate ?P; is_quantum_predicate ?Q;\n   ?P \\<le>\\<^sub>L ?Q\\<rbrakk>\n  \\<Longrightarrow> is_quantum_predicate (wlp S2 ?P) \\<and>\n                    wlp S2 ?P \\<le>\\<^sub>L wlp S2 ?Q\n  well_com (S1;; S2)\n  is_quantum_predicate P\n  is_quantum_predicate Q\n  P \\<le>\\<^sub>L Q\n  is_quantum_predicate P\n  well_com S2\n\ngoal (1 subgoal):\n 1. is_quantum_predicate (wlp S2 P)", "by auto"], ["proof (state)\nthis:\n  is_quantum_predicate (wlp S2 P)\n\ngoal (3 subgoals):\n 1. \\<And>S1 S2 P Q.\n       \\<lbrakk>\\<And>P Q.\n                   \\<lbrakk>well_com S1; is_quantum_predicate P;\n                    is_quantum_predicate Q; P \\<le>\\<^sub>L Q\\<rbrakk>\n                   \\<Longrightarrow> is_quantum_predicate (wlp S1 P) \\<and>\n                                     wlp S1 P \\<le>\\<^sub>L wlp S1 Q;\n        \\<And>P Q.\n           \\<lbrakk>well_com S2; is_quantum_predicate P;\n            is_quantum_predicate Q; P \\<le>\\<^sub>L Q\\<rbrakk>\n           \\<Longrightarrow> is_quantum_predicate (wlp S2 P) \\<and>\n                             wlp S2 P \\<le>\\<^sub>L wlp S2 Q;\n        well_com (S1;; S2); is_quantum_predicate P; is_quantum_predicate Q;\n        P \\<le>\\<^sub>L Q\\<rbrakk>\n       \\<Longrightarrow> is_quantum_predicate (wlp (S1;; S2) P) \\<and>\n                         wlp (S1;; S2) P \\<le>\\<^sub>L wlp (S1;; S2) Q\n 2. \\<And>x1 x2a x3 P Q.\n       \\<lbrakk>\\<And>x3a P Q.\n                   \\<lbrakk>x3a \\<in> set x3; well_com x3a;\n                    is_quantum_predicate P; is_quantum_predicate Q;\n                    P \\<le>\\<^sub>L Q\\<rbrakk>\n                   \\<Longrightarrow> is_quantum_predicate (wlp x3a P) \\<and>\n                                     wlp x3a P \\<le>\\<^sub>L wlp x3a Q;\n        well_com (Measure x1 x2a x3); is_quantum_predicate P;\n        is_quantum_predicate Q; P \\<le>\\<^sub>L Q\\<rbrakk>\n       \\<Longrightarrow> is_quantum_predicate\n                          (wlp (Measure x1 x2a x3) P) \\<and>\n                         wlp (Measure x1 x2a x3) P \\<le>\\<^sub>L\n                         wlp (Measure x1 x2a x3) Q\n 3. \\<And>x1 S P Q.\n       \\<lbrakk>\\<And>P Q.\n                   \\<lbrakk>well_com S; is_quantum_predicate P;\n                    is_quantum_predicate Q; P \\<le>\\<^sub>L Q\\<rbrakk>\n                   \\<Longrightarrow> is_quantum_predicate (wlp S P) \\<and>\n                                     wlp S P \\<le>\\<^sub>L wlp S Q;\n        well_com (While x1 S); is_quantum_predicate P;\n        is_quantum_predicate Q; P \\<le>\\<^sub>L Q\\<rbrakk>\n       \\<Longrightarrow> is_quantum_predicate (wlp (While x1 S) P) \\<and>\n                         wlp (While x1 S) P \\<le>\\<^sub>L wlp (While x1 S) Q", "have qpQ2: \"is_quantum_predicate (wlp S2 Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_quantum_predicate (wlp S2 Q)", "using Seq(2)[OF wc2 qpQ qpQ] lowner_le_refl dQ"], ["proof (prove)\nusing this:\n  Q \\<le>\\<^sub>L Q \\<Longrightarrow>\n  is_quantum_predicate (wlp S2 Q) \\<and> wlp S2 Q \\<le>\\<^sub>L wlp S2 Q\n  ?A \\<in> carrier_mat ?n ?n \\<Longrightarrow> ?A \\<le>\\<^sub>L ?A\n  Q \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. is_quantum_predicate (wlp S2 Q)", "by blast"], ["proof (state)\nthis:\n  is_quantum_predicate (wlp S2 Q)\n\ngoal (3 subgoals):\n 1. \\<And>S1 S2 P Q.\n       \\<lbrakk>\\<And>P Q.\n                   \\<lbrakk>well_com S1; is_quantum_predicate P;\n                    is_quantum_predicate Q; P \\<le>\\<^sub>L Q\\<rbrakk>\n                   \\<Longrightarrow> is_quantum_predicate (wlp S1 P) \\<and>\n                                     wlp S1 P \\<le>\\<^sub>L wlp S1 Q;\n        \\<And>P Q.\n           \\<lbrakk>well_com S2; is_quantum_predicate P;\n            is_quantum_predicate Q; P \\<le>\\<^sub>L Q\\<rbrakk>\n           \\<Longrightarrow> is_quantum_predicate (wlp S2 P) \\<and>\n                             wlp S2 P \\<le>\\<^sub>L wlp S2 Q;\n        well_com (S1;; S2); is_quantum_predicate P; is_quantum_predicate Q;\n        P \\<le>\\<^sub>L Q\\<rbrakk>\n       \\<Longrightarrow> is_quantum_predicate (wlp (S1;; S2) P) \\<and>\n                         wlp (S1;; S2) P \\<le>\\<^sub>L wlp (S1;; S2) Q\n 2. \\<And>x1 x2a x3 P Q.\n       \\<lbrakk>\\<And>x3a P Q.\n                   \\<lbrakk>x3a \\<in> set x3; well_com x3a;\n                    is_quantum_predicate P; is_quantum_predicate Q;\n                    P \\<le>\\<^sub>L Q\\<rbrakk>\n                   \\<Longrightarrow> is_quantum_predicate (wlp x3a P) \\<and>\n                                     wlp x3a P \\<le>\\<^sub>L wlp x3a Q;\n        well_com (Measure x1 x2a x3); is_quantum_predicate P;\n        is_quantum_predicate Q; P \\<le>\\<^sub>L Q\\<rbrakk>\n       \\<Longrightarrow> is_quantum_predicate\n                          (wlp (Measure x1 x2a x3) P) \\<and>\n                         wlp (Measure x1 x2a x3) P \\<le>\\<^sub>L\n                         wlp (Measure x1 x2a x3) Q\n 3. \\<And>x1 S P Q.\n       \\<lbrakk>\\<And>P Q.\n                   \\<lbrakk>well_com S; is_quantum_predicate P;\n                    is_quantum_predicate Q; P \\<le>\\<^sub>L Q\\<rbrakk>\n                   \\<Longrightarrow> is_quantum_predicate (wlp S P) \\<and>\n                                     wlp S P \\<le>\\<^sub>L wlp S Q;\n        well_com (While x1 S); is_quantum_predicate P;\n        is_quantum_predicate Q; P \\<le>\\<^sub>L Q\\<rbrakk>\n       \\<Longrightarrow> is_quantum_predicate (wlp (While x1 S) P) \\<and>\n                         wlp (While x1 S) P \\<le>\\<^sub>L wlp (While x1 S) Q", "have qpP1: \"is_quantum_predicate (wlp S1 (wlp S2 P))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_quantum_predicate (wlp S1 (wlp S2 P))", "using Seq(1)[OF wc1 qpP2 qpP2] qpP2 is_quantum_predicate_def[of \"wlp S2 P\"] lowner_le_refl"], ["proof (prove)\nusing this:\n  wlp S2 P \\<le>\\<^sub>L wlp S2 P \\<Longrightarrow>\n  is_quantum_predicate (wlp S1 (wlp S2 P)) \\<and>\n  wlp S1 (wlp S2 P) \\<le>\\<^sub>L wlp S1 (wlp S2 P)\n  is_quantum_predicate (wlp S2 P)\n  is_quantum_predicate (wlp S2 P) =\n  (wlp S2 P \\<in> carrier_mat d d \\<and>\n   positive (wlp S2 P) \\<and> wlp S2 P \\<le>\\<^sub>L 1\\<^sub>m d)\n  ?A \\<in> carrier_mat ?n ?n \\<Longrightarrow> ?A \\<le>\\<^sub>L ?A\n\ngoal (1 subgoal):\n 1. is_quantum_predicate (wlp S1 (wlp S2 P))", "by auto"], ["proof (state)\nthis:\n  is_quantum_predicate (wlp S1 (wlp S2 P))\n\ngoal (3 subgoals):\n 1. \\<And>S1 S2 P Q.\n       \\<lbrakk>\\<And>P Q.\n                   \\<lbrakk>well_com S1; is_quantum_predicate P;\n                    is_quantum_predicate Q; P \\<le>\\<^sub>L Q\\<rbrakk>\n                   \\<Longrightarrow> is_quantum_predicate (wlp S1 P) \\<and>\n                                     wlp S1 P \\<le>\\<^sub>L wlp S1 Q;\n        \\<And>P Q.\n           \\<lbrakk>well_com S2; is_quantum_predicate P;\n            is_quantum_predicate Q; P \\<le>\\<^sub>L Q\\<rbrakk>\n           \\<Longrightarrow> is_quantum_predicate (wlp S2 P) \\<and>\n                             wlp S2 P \\<le>\\<^sub>L wlp S2 Q;\n        well_com (S1;; S2); is_quantum_predicate P; is_quantum_predicate Q;\n        P \\<le>\\<^sub>L Q\\<rbrakk>\n       \\<Longrightarrow> is_quantum_predicate (wlp (S1;; S2) P) \\<and>\n                         wlp (S1;; S2) P \\<le>\\<^sub>L wlp (S1;; S2) Q\n 2. \\<And>x1 x2a x3 P Q.\n       \\<lbrakk>\\<And>x3a P Q.\n                   \\<lbrakk>x3a \\<in> set x3; well_com x3a;\n                    is_quantum_predicate P; is_quantum_predicate Q;\n                    P \\<le>\\<^sub>L Q\\<rbrakk>\n                   \\<Longrightarrow> is_quantum_predicate (wlp x3a P) \\<and>\n                                     wlp x3a P \\<le>\\<^sub>L wlp x3a Q;\n        well_com (Measure x1 x2a x3); is_quantum_predicate P;\n        is_quantum_predicate Q; P \\<le>\\<^sub>L Q\\<rbrakk>\n       \\<Longrightarrow> is_quantum_predicate\n                          (wlp (Measure x1 x2a x3) P) \\<and>\n                         wlp (Measure x1 x2a x3) P \\<le>\\<^sub>L\n                         wlp (Measure x1 x2a x3) Q\n 3. \\<And>x1 S P Q.\n       \\<lbrakk>\\<And>P Q.\n                   \\<lbrakk>well_com S; is_quantum_predicate P;\n                    is_quantum_predicate Q; P \\<le>\\<^sub>L Q\\<rbrakk>\n                   \\<Longrightarrow> is_quantum_predicate (wlp S P) \\<and>\n                                     wlp S P \\<le>\\<^sub>L wlp S Q;\n        well_com (While x1 S); is_quantum_predicate P;\n        is_quantum_predicate Q; P \\<le>\\<^sub>L Q\\<rbrakk>\n       \\<Longrightarrow> is_quantum_predicate (wlp (While x1 S) P) \\<and>\n                         wlp (While x1 S) P \\<le>\\<^sub>L wlp (While x1 S) Q", "have \"wlp S2 P \\<le>\\<^sub>L wlp S2 Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wlp S2 P \\<le>\\<^sub>L wlp S2 Q", "using Seq(2) wc2 qpP qpQ le"], ["proof (prove)\nusing this:\n  \\<lbrakk>well_com S2; is_quantum_predicate ?P; is_quantum_predicate ?Q;\n   ?P \\<le>\\<^sub>L ?Q\\<rbrakk>\n  \\<Longrightarrow> is_quantum_predicate (wlp S2 ?P) \\<and>\n                    wlp S2 ?P \\<le>\\<^sub>L wlp S2 ?Q\n  well_com S2\n  is_quantum_predicate P\n  is_quantum_predicate Q\n  P \\<le>\\<^sub>L Q\n\ngoal (1 subgoal):\n 1. wlp S2 P \\<le>\\<^sub>L wlp S2 Q", "by auto"], ["proof (state)\nthis:\n  wlp S2 P \\<le>\\<^sub>L wlp S2 Q\n\ngoal (3 subgoals):\n 1. \\<And>S1 S2 P Q.\n       \\<lbrakk>\\<And>P Q.\n                   \\<lbrakk>well_com S1; is_quantum_predicate P;\n                    is_quantum_predicate Q; P \\<le>\\<^sub>L Q\\<rbrakk>\n                   \\<Longrightarrow> is_quantum_predicate (wlp S1 P) \\<and>\n                                     wlp S1 P \\<le>\\<^sub>L wlp S1 Q;\n        \\<And>P Q.\n           \\<lbrakk>well_com S2; is_quantum_predicate P;\n            is_quantum_predicate Q; P \\<le>\\<^sub>L Q\\<rbrakk>\n           \\<Longrightarrow> is_quantum_predicate (wlp S2 P) \\<and>\n                             wlp S2 P \\<le>\\<^sub>L wlp S2 Q;\n        well_com (S1;; S2); is_quantum_predicate P; is_quantum_predicate Q;\n        P \\<le>\\<^sub>L Q\\<rbrakk>\n       \\<Longrightarrow> is_quantum_predicate (wlp (S1;; S2) P) \\<and>\n                         wlp (S1;; S2) P \\<le>\\<^sub>L wlp (S1;; S2) Q\n 2. \\<And>x1 x2a x3 P Q.\n       \\<lbrakk>\\<And>x3a P Q.\n                   \\<lbrakk>x3a \\<in> set x3; well_com x3a;\n                    is_quantum_predicate P; is_quantum_predicate Q;\n                    P \\<le>\\<^sub>L Q\\<rbrakk>\n                   \\<Longrightarrow> is_quantum_predicate (wlp x3a P) \\<and>\n                                     wlp x3a P \\<le>\\<^sub>L wlp x3a Q;\n        well_com (Measure x1 x2a x3); is_quantum_predicate P;\n        is_quantum_predicate Q; P \\<le>\\<^sub>L Q\\<rbrakk>\n       \\<Longrightarrow> is_quantum_predicate\n                          (wlp (Measure x1 x2a x3) P) \\<and>\n                         wlp (Measure x1 x2a x3) P \\<le>\\<^sub>L\n                         wlp (Measure x1 x2a x3) Q\n 3. \\<And>x1 S P Q.\n       \\<lbrakk>\\<And>P Q.\n                   \\<lbrakk>well_com S; is_quantum_predicate P;\n                    is_quantum_predicate Q; P \\<le>\\<^sub>L Q\\<rbrakk>\n                   \\<Longrightarrow> is_quantum_predicate (wlp S P) \\<and>\n                                     wlp S P \\<le>\\<^sub>L wlp S Q;\n        well_com (While x1 S); is_quantum_predicate P;\n        is_quantum_predicate Q; P \\<le>\\<^sub>L Q\\<rbrakk>\n       \\<Longrightarrow> is_quantum_predicate (wlp (While x1 S) P) \\<and>\n                         wlp (While x1 S) P \\<le>\\<^sub>L wlp (While x1 S) Q", "then"], ["proof (chain)\npicking this:\n  wlp S2 P \\<le>\\<^sub>L wlp S2 Q", "have \"wlp S1 (wlp S2 P) \\<le>\\<^sub>L wlp S1 (wlp S2 Q)\""], ["proof (prove)\nusing this:\n  wlp S2 P \\<le>\\<^sub>L wlp S2 Q\n\ngoal (1 subgoal):\n 1. wlp S1 (wlp S2 P) \\<le>\\<^sub>L wlp S1 (wlp S2 Q)", "using Seq(1) wc1 qpP2 qpQ2"], ["proof (prove)\nusing this:\n  wlp S2 P \\<le>\\<^sub>L wlp S2 Q\n  \\<lbrakk>well_com S1; is_quantum_predicate ?P; is_quantum_predicate ?Q;\n   ?P \\<le>\\<^sub>L ?Q\\<rbrakk>\n  \\<Longrightarrow> is_quantum_predicate (wlp S1 ?P) \\<and>\n                    wlp S1 ?P \\<le>\\<^sub>L wlp S1 ?Q\n  well_com S1\n  is_quantum_predicate (wlp S2 P)\n  is_quantum_predicate (wlp S2 Q)\n\ngoal (1 subgoal):\n 1. wlp S1 (wlp S2 P) \\<le>\\<^sub>L wlp S1 (wlp S2 Q)", "by auto"], ["proof (state)\nthis:\n  wlp S1 (wlp S2 P) \\<le>\\<^sub>L wlp S1 (wlp S2 Q)\n\ngoal (3 subgoals):\n 1. \\<And>S1 S2 P Q.\n       \\<lbrakk>\\<And>P Q.\n                   \\<lbrakk>well_com S1; is_quantum_predicate P;\n                    is_quantum_predicate Q; P \\<le>\\<^sub>L Q\\<rbrakk>\n                   \\<Longrightarrow> is_quantum_predicate (wlp S1 P) \\<and>\n                                     wlp S1 P \\<le>\\<^sub>L wlp S1 Q;\n        \\<And>P Q.\n           \\<lbrakk>well_com S2; is_quantum_predicate P;\n            is_quantum_predicate Q; P \\<le>\\<^sub>L Q\\<rbrakk>\n           \\<Longrightarrow> is_quantum_predicate (wlp S2 P) \\<and>\n                             wlp S2 P \\<le>\\<^sub>L wlp S2 Q;\n        well_com (S1;; S2); is_quantum_predicate P; is_quantum_predicate Q;\n        P \\<le>\\<^sub>L Q\\<rbrakk>\n       \\<Longrightarrow> is_quantum_predicate (wlp (S1;; S2) P) \\<and>\n                         wlp (S1;; S2) P \\<le>\\<^sub>L wlp (S1;; S2) Q\n 2. \\<And>x1 x2a x3 P Q.\n       \\<lbrakk>\\<And>x3a P Q.\n                   \\<lbrakk>x3a \\<in> set x3; well_com x3a;\n                    is_quantum_predicate P; is_quantum_predicate Q;\n                    P \\<le>\\<^sub>L Q\\<rbrakk>\n                   \\<Longrightarrow> is_quantum_predicate (wlp x3a P) \\<and>\n                                     wlp x3a P \\<le>\\<^sub>L wlp x3a Q;\n        well_com (Measure x1 x2a x3); is_quantum_predicate P;\n        is_quantum_predicate Q; P \\<le>\\<^sub>L Q\\<rbrakk>\n       \\<Longrightarrow> is_quantum_predicate\n                          (wlp (Measure x1 x2a x3) P) \\<and>\n                         wlp (Measure x1 x2a x3) P \\<le>\\<^sub>L\n                         wlp (Measure x1 x2a x3) Q\n 3. \\<And>x1 S P Q.\n       \\<lbrakk>\\<And>P Q.\n                   \\<lbrakk>well_com S; is_quantum_predicate P;\n                    is_quantum_predicate Q; P \\<le>\\<^sub>L Q\\<rbrakk>\n                   \\<Longrightarrow> is_quantum_predicate (wlp S P) \\<and>\n                                     wlp S P \\<le>\\<^sub>L wlp S Q;\n        well_com (While x1 S); is_quantum_predicate P;\n        is_quantum_predicate Q; P \\<le>\\<^sub>L Q\\<rbrakk>\n       \\<Longrightarrow> is_quantum_predicate (wlp (While x1 S) P) \\<and>\n                         wlp (While x1 S) P \\<le>\\<^sub>L wlp (While x1 S) Q", "then"], ["proof (chain)\npicking this:\n  wlp S1 (wlp S2 P) \\<le>\\<^sub>L wlp S1 (wlp S2 Q)", "show ?case"], ["proof (prove)\nusing this:\n  wlp S1 (wlp S2 P) \\<le>\\<^sub>L wlp S1 (wlp S2 Q)\n\ngoal (1 subgoal):\n 1. is_quantum_predicate (wlp (S1;; S2) P) \\<and>\n    wlp (S1;; S2) P \\<le>\\<^sub>L wlp (S1;; S2) Q", "using qpP1"], ["proof (prove)\nusing this:\n  wlp S1 (wlp S2 P) \\<le>\\<^sub>L wlp S1 (wlp S2 Q)\n  is_quantum_predicate (wlp S1 (wlp S2 P))\n\ngoal (1 subgoal):\n 1. is_quantum_predicate (wlp (S1;; S2) P) \\<and>\n    wlp (S1;; S2) P \\<le>\\<^sub>L wlp (S1;; S2) Q", "by auto"], ["proof (state)\nthis:\n  is_quantum_predicate (wlp (S1;; S2) P) \\<and>\n  wlp (S1;; S2) P \\<le>\\<^sub>L wlp (S1;; S2) Q\n\ngoal (2 subgoals):\n 1. \\<And>x1 x2a x3 P Q.\n       \\<lbrakk>\\<And>x3a P Q.\n                   \\<lbrakk>x3a \\<in> set x3; well_com x3a;\n                    is_quantum_predicate P; is_quantum_predicate Q;\n                    P \\<le>\\<^sub>L Q\\<rbrakk>\n                   \\<Longrightarrow> is_quantum_predicate (wlp x3a P) \\<and>\n                                     wlp x3a P \\<le>\\<^sub>L wlp x3a Q;\n        well_com (Measure x1 x2a x3); is_quantum_predicate P;\n        is_quantum_predicate Q; P \\<le>\\<^sub>L Q\\<rbrakk>\n       \\<Longrightarrow> is_quantum_predicate\n                          (wlp (Measure x1 x2a x3) P) \\<and>\n                         wlp (Measure x1 x2a x3) P \\<le>\\<^sub>L\n                         wlp (Measure x1 x2a x3) Q\n 2. \\<And>x1 S P Q.\n       \\<lbrakk>\\<And>P Q.\n                   \\<lbrakk>well_com S; is_quantum_predicate P;\n                    is_quantum_predicate Q; P \\<le>\\<^sub>L Q\\<rbrakk>\n                   \\<Longrightarrow> is_quantum_predicate (wlp S P) \\<and>\n                                     wlp S P \\<le>\\<^sub>L wlp S Q;\n        well_com (While x1 S); is_quantum_predicate P;\n        is_quantum_predicate Q; P \\<le>\\<^sub>L Q\\<rbrakk>\n       \\<Longrightarrow> is_quantum_predicate (wlp (While x1 S) P) \\<and>\n                         wlp (While x1 S) P \\<le>\\<^sub>L wlp (While x1 S) Q", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1 x2a x3 P Q.\n       \\<lbrakk>\\<And>x3a P Q.\n                   \\<lbrakk>x3a \\<in> set x3; well_com x3a;\n                    is_quantum_predicate P; is_quantum_predicate Q;\n                    P \\<le>\\<^sub>L Q\\<rbrakk>\n                   \\<Longrightarrow> is_quantum_predicate (wlp x3a P) \\<and>\n                                     wlp x3a P \\<le>\\<^sub>L wlp x3a Q;\n        well_com (Measure x1 x2a x3); is_quantum_predicate P;\n        is_quantum_predicate Q; P \\<le>\\<^sub>L Q\\<rbrakk>\n       \\<Longrightarrow> is_quantum_predicate\n                          (wlp (Measure x1 x2a x3) P) \\<and>\n                         wlp (Measure x1 x2a x3) P \\<le>\\<^sub>L\n                         wlp (Measure x1 x2a x3) Q\n 2. \\<And>x1 S P Q.\n       \\<lbrakk>\\<And>P Q.\n                   \\<lbrakk>well_com S; is_quantum_predicate P;\n                    is_quantum_predicate Q; P \\<le>\\<^sub>L Q\\<rbrakk>\n                   \\<Longrightarrow> is_quantum_predicate (wlp S P) \\<and>\n                                     wlp S P \\<le>\\<^sub>L wlp S Q;\n        well_com (While x1 S); is_quantum_predicate P;\n        is_quantum_predicate Q; P \\<le>\\<^sub>L Q\\<rbrakk>\n       \\<Longrightarrow> is_quantum_predicate (wlp (While x1 S) P) \\<and>\n                         wlp (While x1 S) P \\<le>\\<^sub>L wlp (While x1 S) Q", "case (Measure n M S)"], ["proof (state)\nthis:\n  \\<lbrakk>?x3a \\<in> set S; well_com ?x3a; is_quantum_predicate ?P;\n   is_quantum_predicate ?Q; ?P \\<le>\\<^sub>L ?Q\\<rbrakk>\n  \\<Longrightarrow> is_quantum_predicate (wlp ?x3a ?P) \\<and>\n                    wlp ?x3a ?P \\<le>\\<^sub>L wlp ?x3a ?Q\n  well_com (Measure n M S)\n  is_quantum_predicate P\n  is_quantum_predicate Q\n  P \\<le>\\<^sub>L Q\n\ngoal (2 subgoals):\n 1. \\<And>x1 x2a x3 P Q.\n       \\<lbrakk>\\<And>x3a P Q.\n                   \\<lbrakk>x3a \\<in> set x3; well_com x3a;\n                    is_quantum_predicate P; is_quantum_predicate Q;\n                    P \\<le>\\<^sub>L Q\\<rbrakk>\n                   \\<Longrightarrow> is_quantum_predicate (wlp x3a P) \\<and>\n                                     wlp x3a P \\<le>\\<^sub>L wlp x3a Q;\n        well_com (Measure x1 x2a x3); is_quantum_predicate P;\n        is_quantum_predicate Q; P \\<le>\\<^sub>L Q\\<rbrakk>\n       \\<Longrightarrow> is_quantum_predicate\n                          (wlp (Measure x1 x2a x3) P) \\<and>\n                         wlp (Measure x1 x2a x3) P \\<le>\\<^sub>L\n                         wlp (Measure x1 x2a x3) Q\n 2. \\<And>x1 S P Q.\n       \\<lbrakk>\\<And>P Q.\n                   \\<lbrakk>well_com S; is_quantum_predicate P;\n                    is_quantum_predicate Q; P \\<le>\\<^sub>L Q\\<rbrakk>\n                   \\<Longrightarrow> is_quantum_predicate (wlp S P) \\<and>\n                                     wlp S P \\<le>\\<^sub>L wlp S Q;\n        well_com (While x1 S); is_quantum_predicate P;\n        is_quantum_predicate Q; P \\<le>\\<^sub>L Q\\<rbrakk>\n       \\<Longrightarrow> is_quantum_predicate (wlp (While x1 S) P) \\<and>\n                         wlp (While x1 S) P \\<le>\\<^sub>L wlp (While x1 S) Q", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>?x3a \\<in> set S; well_com ?x3a; is_quantum_predicate ?P;\n   is_quantum_predicate ?Q; ?P \\<le>\\<^sub>L ?Q\\<rbrakk>\n  \\<Longrightarrow> is_quantum_predicate (wlp ?x3a ?P) \\<and>\n                    wlp ?x3a ?P \\<le>\\<^sub>L wlp ?x3a ?Q\n  well_com (Measure n M S)\n  is_quantum_predicate P\n  is_quantum_predicate Q\n  P \\<le>\\<^sub>L Q", "have wc: \"well_com (Measure n M S)\" and wck: \"k < n \\<Longrightarrow> well_com (S!k)\" and l: \"length S = n\"\n    and m: \"measurement d n M\" and le: \"P \\<le>\\<^sub>L Q\"\n    and qpP: \"is_quantum_predicate P\" and dP: \"P \\<in> carrier_mat d d\" \n    and qpQ: \"is_quantum_predicate Q\" and dQ: \"Q \\<in> carrier_mat d d\"\n    for k"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x3a \\<in> set S; well_com ?x3a; is_quantum_predicate ?P;\n   is_quantum_predicate ?Q; ?P \\<le>\\<^sub>L ?Q\\<rbrakk>\n  \\<Longrightarrow> is_quantum_predicate (wlp ?x3a ?P) \\<and>\n                    wlp ?x3a ?P \\<le>\\<^sub>L wlp ?x3a ?Q\n  well_com (Measure n M S)\n  is_quantum_predicate P\n  is_quantum_predicate Q\n  P \\<le>\\<^sub>L Q\n\ngoal (1 subgoal):\n 1. ((well_com (Measure n M S) &&&\n      (k < n \\<Longrightarrow> well_com (S ! k))) &&&\n     length S = n &&& measurement d n M) &&&\n    (P \\<le>\\<^sub>L Q &&& is_quantum_predicate P) &&&\n    P \\<in> carrier_mat d d &&&\n    is_quantum_predicate Q &&& Q \\<in> carrier_mat d d", "using measure_well_com is_quantum_predicate_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x3a \\<in> set S; well_com ?x3a; is_quantum_predicate ?P;\n   is_quantum_predicate ?Q; ?P \\<le>\\<^sub>L ?Q\\<rbrakk>\n  \\<Longrightarrow> is_quantum_predicate (wlp ?x3a ?P) \\<and>\n                    wlp ?x3a ?P \\<le>\\<^sub>L wlp ?x3a ?Q\n  well_com (Measure n M S)\n  is_quantum_predicate P\n  is_quantum_predicate Q\n  P \\<le>\\<^sub>L Q\n  \\<lbrakk>well_com (Measure ?n ?M ?S); ?k < ?n\\<rbrakk>\n  \\<Longrightarrow> well_com (?S ! ?k)\n  is_quantum_predicate ?P =\n  (?P \\<in> carrier_mat d d \\<and>\n   positive ?P \\<and> ?P \\<le>\\<^sub>L 1\\<^sub>m d)\n\ngoal (1 subgoal):\n 1. ((well_com (Measure n M S) &&&\n      (k < n \\<Longrightarrow> well_com (S ! k))) &&&\n     length S = n &&& measurement d n M) &&&\n    (P \\<le>\\<^sub>L Q &&& is_quantum_predicate P) &&&\n    P \\<in> carrier_mat d d &&&\n    is_quantum_predicate Q &&& Q \\<in> carrier_mat d d", "by auto"], ["proof (state)\nthis:\n  well_com (Measure n M S)\n  ?k < n \\<Longrightarrow> well_com (S ! ?k)\n  length S = n\n  measurement d n M\n  P \\<le>\\<^sub>L Q\n  is_quantum_predicate P\n  P \\<in> carrier_mat d d\n  is_quantum_predicate Q\n  Q \\<in> carrier_mat d d\n\ngoal (2 subgoals):\n 1. \\<And>x1 x2a x3 P Q.\n       \\<lbrakk>\\<And>x3a P Q.\n                   \\<lbrakk>x3a \\<in> set x3; well_com x3a;\n                    is_quantum_predicate P; is_quantum_predicate Q;\n                    P \\<le>\\<^sub>L Q\\<rbrakk>\n                   \\<Longrightarrow> is_quantum_predicate (wlp x3a P) \\<and>\n                                     wlp x3a P \\<le>\\<^sub>L wlp x3a Q;\n        well_com (Measure x1 x2a x3); is_quantum_predicate P;\n        is_quantum_predicate Q; P \\<le>\\<^sub>L Q\\<rbrakk>\n       \\<Longrightarrow> is_quantum_predicate\n                          (wlp (Measure x1 x2a x3) P) \\<and>\n                         wlp (Measure x1 x2a x3) P \\<le>\\<^sub>L\n                         wlp (Measure x1 x2a x3) Q\n 2. \\<And>x1 S P Q.\n       \\<lbrakk>\\<And>P Q.\n                   \\<lbrakk>well_com S; is_quantum_predicate P;\n                    is_quantum_predicate Q; P \\<le>\\<^sub>L Q\\<rbrakk>\n                   \\<Longrightarrow> is_quantum_predicate (wlp S P) \\<and>\n                                     wlp S P \\<le>\\<^sub>L wlp S Q;\n        well_com (While x1 S); is_quantum_predicate P;\n        is_quantum_predicate Q; P \\<le>\\<^sub>L Q\\<rbrakk>\n       \\<Longrightarrow> is_quantum_predicate (wlp (While x1 S) P) \\<and>\n                         wlp (While x1 S) P \\<le>\\<^sub>L wlp (While x1 S) Q", "have dMk: \"k < n \\<Longrightarrow> M k \\<in> carrier_mat d d\" for k"], ["proof (prove)\ngoal (1 subgoal):\n 1. k < n \\<Longrightarrow> M k \\<in> carrier_mat d d", "using m measurement_def"], ["proof (prove)\nusing this:\n  measurement d n M\n  measurement ?d ?n ?M =\n  ((\\<forall>j<?n. ?M j \\<in> carrier_mat ?d ?d) \\<and>\n   matrix_sum ?d (\\<lambda>j. adjoint (?M j) * ?M j) ?n = 1\\<^sub>m ?d)\n\ngoal (1 subgoal):\n 1. k < n \\<Longrightarrow> M k \\<in> carrier_mat d d", "by auto"], ["proof (state)\nthis:\n  ?k < n \\<Longrightarrow> M ?k \\<in> carrier_mat d d\n\ngoal (2 subgoals):\n 1. \\<And>x1 x2a x3 P Q.\n       \\<lbrakk>\\<And>x3a P Q.\n                   \\<lbrakk>x3a \\<in> set x3; well_com x3a;\n                    is_quantum_predicate P; is_quantum_predicate Q;\n                    P \\<le>\\<^sub>L Q\\<rbrakk>\n                   \\<Longrightarrow> is_quantum_predicate (wlp x3a P) \\<and>\n                                     wlp x3a P \\<le>\\<^sub>L wlp x3a Q;\n        well_com (Measure x1 x2a x3); is_quantum_predicate P;\n        is_quantum_predicate Q; P \\<le>\\<^sub>L Q\\<rbrakk>\n       \\<Longrightarrow> is_quantum_predicate\n                          (wlp (Measure x1 x2a x3) P) \\<and>\n                         wlp (Measure x1 x2a x3) P \\<le>\\<^sub>L\n                         wlp (Measure x1 x2a x3) Q\n 2. \\<And>x1 S P Q.\n       \\<lbrakk>\\<And>P Q.\n                   \\<lbrakk>well_com S; is_quantum_predicate P;\n                    is_quantum_predicate Q; P \\<le>\\<^sub>L Q\\<rbrakk>\n                   \\<Longrightarrow> is_quantum_predicate (wlp S P) \\<and>\n                                     wlp S P \\<le>\\<^sub>L wlp S Q;\n        well_com (While x1 S); is_quantum_predicate P;\n        is_quantum_predicate Q; P \\<le>\\<^sub>L Q\\<rbrakk>\n       \\<Longrightarrow> is_quantum_predicate (wlp (While x1 S) P) \\<and>\n                         wlp (While x1 S) P \\<le>\\<^sub>L wlp (While x1 S) Q", "have set: \"k < n \\<Longrightarrow> S!k \\<in> set S\" for k"], ["proof (prove)\ngoal (1 subgoal):\n 1. k < n \\<Longrightarrow> S ! k \\<in> set S", "using l"], ["proof (prove)\nusing this:\n  length S = n\n\ngoal (1 subgoal):\n 1. k < n \\<Longrightarrow> S ! k \\<in> set S", "by auto"], ["proof (state)\nthis:\n  ?k < n \\<Longrightarrow> S ! ?k \\<in> set S\n\ngoal (2 subgoals):\n 1. \\<And>x1 x2a x3 P Q.\n       \\<lbrakk>\\<And>x3a P Q.\n                   \\<lbrakk>x3a \\<in> set x3; well_com x3a;\n                    is_quantum_predicate P; is_quantum_predicate Q;\n                    P \\<le>\\<^sub>L Q\\<rbrakk>\n                   \\<Longrightarrow> is_quantum_predicate (wlp x3a P) \\<and>\n                                     wlp x3a P \\<le>\\<^sub>L wlp x3a Q;\n        well_com (Measure x1 x2a x3); is_quantum_predicate P;\n        is_quantum_predicate Q; P \\<le>\\<^sub>L Q\\<rbrakk>\n       \\<Longrightarrow> is_quantum_predicate\n                          (wlp (Measure x1 x2a x3) P) \\<and>\n                         wlp (Measure x1 x2a x3) P \\<le>\\<^sub>L\n                         wlp (Measure x1 x2a x3) Q\n 2. \\<And>x1 S P Q.\n       \\<lbrakk>\\<And>P Q.\n                   \\<lbrakk>well_com S; is_quantum_predicate P;\n                    is_quantum_predicate Q; P \\<le>\\<^sub>L Q\\<rbrakk>\n                   \\<Longrightarrow> is_quantum_predicate (wlp S P) \\<and>\n                                     wlp S P \\<le>\\<^sub>L wlp S Q;\n        well_com (While x1 S); is_quantum_predicate P;\n        is_quantum_predicate Q; P \\<le>\\<^sub>L Q\\<rbrakk>\n       \\<Longrightarrow> is_quantum_predicate (wlp (While x1 S) P) \\<and>\n                         wlp (While x1 S) P \\<le>\\<^sub>L wlp (While x1 S) Q", "have qpk: \"k < n \\<Longrightarrow> is_quantum_predicate (wlp (S!k) P)\" for k"], ["proof (prove)\ngoal (1 subgoal):\n 1. k < n \\<Longrightarrow> is_quantum_predicate (wlp (S ! k) P)", "using Measure(1)[OF set wck qpP qpP] lowner_le_refl[of P] dP"], ["proof (prove)\nusing this:\n  \\<lbrakk>?k1 < n; ?k1 < n; P \\<le>\\<^sub>L P\\<rbrakk>\n  \\<Longrightarrow> is_quantum_predicate (wlp (S ! ?k1) P) \\<and>\n                    wlp (S ! ?k1) P \\<le>\\<^sub>L wlp (S ! ?k1) P\n  P \\<in> carrier_mat ?n ?n \\<Longrightarrow> P \\<le>\\<^sub>L P\n  P \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. k < n \\<Longrightarrow> is_quantum_predicate (wlp (S ! k) P)", "by auto"], ["proof (state)\nthis:\n  ?k < n \\<Longrightarrow> is_quantum_predicate (wlp (S ! ?k) P)\n\ngoal (2 subgoals):\n 1. \\<And>x1 x2a x3 P Q.\n       \\<lbrakk>\\<And>x3a P Q.\n                   \\<lbrakk>x3a \\<in> set x3; well_com x3a;\n                    is_quantum_predicate P; is_quantum_predicate Q;\n                    P \\<le>\\<^sub>L Q\\<rbrakk>\n                   \\<Longrightarrow> is_quantum_predicate (wlp x3a P) \\<and>\n                                     wlp x3a P \\<le>\\<^sub>L wlp x3a Q;\n        well_com (Measure x1 x2a x3); is_quantum_predicate P;\n        is_quantum_predicate Q; P \\<le>\\<^sub>L Q\\<rbrakk>\n       \\<Longrightarrow> is_quantum_predicate\n                          (wlp (Measure x1 x2a x3) P) \\<and>\n                         wlp (Measure x1 x2a x3) P \\<le>\\<^sub>L\n                         wlp (Measure x1 x2a x3) Q\n 2. \\<And>x1 S P Q.\n       \\<lbrakk>\\<And>P Q.\n                   \\<lbrakk>well_com S; is_quantum_predicate P;\n                    is_quantum_predicate Q; P \\<le>\\<^sub>L Q\\<rbrakk>\n                   \\<Longrightarrow> is_quantum_predicate (wlp S P) \\<and>\n                                     wlp S P \\<le>\\<^sub>L wlp S Q;\n        well_com (While x1 S); is_quantum_predicate P;\n        is_quantum_predicate Q; P \\<le>\\<^sub>L Q\\<rbrakk>\n       \\<Longrightarrow> is_quantum_predicate (wlp (While x1 S) P) \\<and>\n                         wlp (While x1 S) P \\<le>\\<^sub>L wlp (While x1 S) Q", "then"], ["proof (chain)\npicking this:\n  ?k < n \\<Longrightarrow> is_quantum_predicate (wlp (S ! ?k) P)", "have dWkP: \"k < n \\<Longrightarrow> wlp (S!k) P \\<in> carrier_mat d d\" for k"], ["proof (prove)\nusing this:\n  ?k < n \\<Longrightarrow> is_quantum_predicate (wlp (S ! ?k) P)\n\ngoal (1 subgoal):\n 1. k < n \\<Longrightarrow> wlp (S ! k) P \\<in> carrier_mat d d", "using is_quantum_predicate_def"], ["proof (prove)\nusing this:\n  ?k < n \\<Longrightarrow> is_quantum_predicate (wlp (S ! ?k) P)\n  is_quantum_predicate ?P =\n  (?P \\<in> carrier_mat d d \\<and>\n   positive ?P \\<and> ?P \\<le>\\<^sub>L 1\\<^sub>m d)\n\ngoal (1 subgoal):\n 1. k < n \\<Longrightarrow> wlp (S ! k) P \\<in> carrier_mat d d", "by auto"], ["proof (state)\nthis:\n  ?k < n \\<Longrightarrow> wlp (S ! ?k) P \\<in> carrier_mat d d\n\ngoal (2 subgoals):\n 1. \\<And>x1 x2a x3 P Q.\n       \\<lbrakk>\\<And>x3a P Q.\n                   \\<lbrakk>x3a \\<in> set x3; well_com x3a;\n                    is_quantum_predicate P; is_quantum_predicate Q;\n                    P \\<le>\\<^sub>L Q\\<rbrakk>\n                   \\<Longrightarrow> is_quantum_predicate (wlp x3a P) \\<and>\n                                     wlp x3a P \\<le>\\<^sub>L wlp x3a Q;\n        well_com (Measure x1 x2a x3); is_quantum_predicate P;\n        is_quantum_predicate Q; P \\<le>\\<^sub>L Q\\<rbrakk>\n       \\<Longrightarrow> is_quantum_predicate\n                          (wlp (Measure x1 x2a x3) P) \\<and>\n                         wlp (Measure x1 x2a x3) P \\<le>\\<^sub>L\n                         wlp (Measure x1 x2a x3) Q\n 2. \\<And>x1 S P Q.\n       \\<lbrakk>\\<And>P Q.\n                   \\<lbrakk>well_com S; is_quantum_predicate P;\n                    is_quantum_predicate Q; P \\<le>\\<^sub>L Q\\<rbrakk>\n                   \\<Longrightarrow> is_quantum_predicate (wlp S P) \\<and>\n                                     wlp S P \\<le>\\<^sub>L wlp S Q;\n        well_com (While x1 S); is_quantum_predicate P;\n        is_quantum_predicate Q; P \\<le>\\<^sub>L Q\\<rbrakk>\n       \\<Longrightarrow> is_quantum_predicate (wlp (While x1 S) P) \\<and>\n                         wlp (While x1 S) P \\<le>\\<^sub>L wlp (While x1 S) Q", "then"], ["proof (chain)\npicking this:\n  ?k < n \\<Longrightarrow> wlp (S ! ?k) P \\<in> carrier_mat d d", "have dMkP: \"k < n \\<Longrightarrow> adjoint (M k) * (wlp (S!k) P) * (M k) \\<in> carrier_mat d d\" for k"], ["proof (prove)\nusing this:\n  ?k < n \\<Longrightarrow> wlp (S ! ?k) P \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. k < n \\<Longrightarrow>\n    adjoint (M k) * wlp (S ! k) P * M k \\<in> carrier_mat d d", "using dMk"], ["proof (prove)\nusing this:\n  ?k < n \\<Longrightarrow> wlp (S ! ?k) P \\<in> carrier_mat d d\n  ?k < n \\<Longrightarrow> M ?k \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. k < n \\<Longrightarrow>\n    adjoint (M k) * wlp (S ! k) P * M k \\<in> carrier_mat d d", "by fastforce"], ["proof (state)\nthis:\n  ?k < n \\<Longrightarrow>\n  adjoint (M ?k) * wlp (S ! ?k) P * M ?k \\<in> carrier_mat d d\n\ngoal (2 subgoals):\n 1. \\<And>x1 x2a x3 P Q.\n       \\<lbrakk>\\<And>x3a P Q.\n                   \\<lbrakk>x3a \\<in> set x3; well_com x3a;\n                    is_quantum_predicate P; is_quantum_predicate Q;\n                    P \\<le>\\<^sub>L Q\\<rbrakk>\n                   \\<Longrightarrow> is_quantum_predicate (wlp x3a P) \\<and>\n                                     wlp x3a P \\<le>\\<^sub>L wlp x3a Q;\n        well_com (Measure x1 x2a x3); is_quantum_predicate P;\n        is_quantum_predicate Q; P \\<le>\\<^sub>L Q\\<rbrakk>\n       \\<Longrightarrow> is_quantum_predicate\n                          (wlp (Measure x1 x2a x3) P) \\<and>\n                         wlp (Measure x1 x2a x3) P \\<le>\\<^sub>L\n                         wlp (Measure x1 x2a x3) Q\n 2. \\<And>x1 S P Q.\n       \\<lbrakk>\\<And>P Q.\n                   \\<lbrakk>well_com S; is_quantum_predicate P;\n                    is_quantum_predicate Q; P \\<le>\\<^sub>L Q\\<rbrakk>\n                   \\<Longrightarrow> is_quantum_predicate (wlp S P) \\<and>\n                                     wlp S P \\<le>\\<^sub>L wlp S Q;\n        well_com (While x1 S); is_quantum_predicate P;\n        is_quantum_predicate Q; P \\<le>\\<^sub>L Q\\<rbrakk>\n       \\<Longrightarrow> is_quantum_predicate (wlp (While x1 S) P) \\<and>\n                         wlp (While x1 S) P \\<le>\\<^sub>L wlp (While x1 S) Q", "have \"k < n \\<Longrightarrow> is_quantum_predicate (wlp (S!k) Q)\" for k"], ["proof (prove)\ngoal (1 subgoal):\n 1. k < n \\<Longrightarrow> is_quantum_predicate (wlp (S ! k) Q)", "using Measure(1)[OF set wck qpQ qpQ] lowner_le_refl[of Q] dQ"], ["proof (prove)\nusing this:\n  \\<lbrakk>?k1 < n; ?k1 < n; Q \\<le>\\<^sub>L Q\\<rbrakk>\n  \\<Longrightarrow> is_quantum_predicate (wlp (S ! ?k1) Q) \\<and>\n                    wlp (S ! ?k1) Q \\<le>\\<^sub>L wlp (S ! ?k1) Q\n  Q \\<in> carrier_mat ?n ?n \\<Longrightarrow> Q \\<le>\\<^sub>L Q\n  Q \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. k < n \\<Longrightarrow> is_quantum_predicate (wlp (S ! k) Q)", "by auto"], ["proof (state)\nthis:\n  ?k < n \\<Longrightarrow> is_quantum_predicate (wlp (S ! ?k) Q)\n\ngoal (2 subgoals):\n 1. \\<And>x1 x2a x3 P Q.\n       \\<lbrakk>\\<And>x3a P Q.\n                   \\<lbrakk>x3a \\<in> set x3; well_com x3a;\n                    is_quantum_predicate P; is_quantum_predicate Q;\n                    P \\<le>\\<^sub>L Q\\<rbrakk>\n                   \\<Longrightarrow> is_quantum_predicate (wlp x3a P) \\<and>\n                                     wlp x3a P \\<le>\\<^sub>L wlp x3a Q;\n        well_com (Measure x1 x2a x3); is_quantum_predicate P;\n        is_quantum_predicate Q; P \\<le>\\<^sub>L Q\\<rbrakk>\n       \\<Longrightarrow> is_quantum_predicate\n                          (wlp (Measure x1 x2a x3) P) \\<and>\n                         wlp (Measure x1 x2a x3) P \\<le>\\<^sub>L\n                         wlp (Measure x1 x2a x3) Q\n 2. \\<And>x1 S P Q.\n       \\<lbrakk>\\<And>P Q.\n                   \\<lbrakk>well_com S; is_quantum_predicate P;\n                    is_quantum_predicate Q; P \\<le>\\<^sub>L Q\\<rbrakk>\n                   \\<Longrightarrow> is_quantum_predicate (wlp S P) \\<and>\n                                     wlp S P \\<le>\\<^sub>L wlp S Q;\n        well_com (While x1 S); is_quantum_predicate P;\n        is_quantum_predicate Q; P \\<le>\\<^sub>L Q\\<rbrakk>\n       \\<Longrightarrow> is_quantum_predicate (wlp (While x1 S) P) \\<and>\n                         wlp (While x1 S) P \\<le>\\<^sub>L wlp (While x1 S) Q", "then"], ["proof (chain)\npicking this:\n  ?k < n \\<Longrightarrow> is_quantum_predicate (wlp (S ! ?k) Q)", "have dWkQ: \"k < n \\<Longrightarrow> wlp (S!k) Q \\<in> carrier_mat d d\" for k"], ["proof (prove)\nusing this:\n  ?k < n \\<Longrightarrow> is_quantum_predicate (wlp (S ! ?k) Q)\n\ngoal (1 subgoal):\n 1. k < n \\<Longrightarrow> wlp (S ! k) Q \\<in> carrier_mat d d", "using is_quantum_predicate_def"], ["proof (prove)\nusing this:\n  ?k < n \\<Longrightarrow> is_quantum_predicate (wlp (S ! ?k) Q)\n  is_quantum_predicate ?P =\n  (?P \\<in> carrier_mat d d \\<and>\n   positive ?P \\<and> ?P \\<le>\\<^sub>L 1\\<^sub>m d)\n\ngoal (1 subgoal):\n 1. k < n \\<Longrightarrow> wlp (S ! k) Q \\<in> carrier_mat d d", "by auto"], ["proof (state)\nthis:\n  ?k < n \\<Longrightarrow> wlp (S ! ?k) Q \\<in> carrier_mat d d\n\ngoal (2 subgoals):\n 1. \\<And>x1 x2a x3 P Q.\n       \\<lbrakk>\\<And>x3a P Q.\n                   \\<lbrakk>x3a \\<in> set x3; well_com x3a;\n                    is_quantum_predicate P; is_quantum_predicate Q;\n                    P \\<le>\\<^sub>L Q\\<rbrakk>\n                   \\<Longrightarrow> is_quantum_predicate (wlp x3a P) \\<and>\n                                     wlp x3a P \\<le>\\<^sub>L wlp x3a Q;\n        well_com (Measure x1 x2a x3); is_quantum_predicate P;\n        is_quantum_predicate Q; P \\<le>\\<^sub>L Q\\<rbrakk>\n       \\<Longrightarrow> is_quantum_predicate\n                          (wlp (Measure x1 x2a x3) P) \\<and>\n                         wlp (Measure x1 x2a x3) P \\<le>\\<^sub>L\n                         wlp (Measure x1 x2a x3) Q\n 2. \\<And>x1 S P Q.\n       \\<lbrakk>\\<And>P Q.\n                   \\<lbrakk>well_com S; is_quantum_predicate P;\n                    is_quantum_predicate Q; P \\<le>\\<^sub>L Q\\<rbrakk>\n                   \\<Longrightarrow> is_quantum_predicate (wlp S P) \\<and>\n                                     wlp S P \\<le>\\<^sub>L wlp S Q;\n        well_com (While x1 S); is_quantum_predicate P;\n        is_quantum_predicate Q; P \\<le>\\<^sub>L Q\\<rbrakk>\n       \\<Longrightarrow> is_quantum_predicate (wlp (While x1 S) P) \\<and>\n                         wlp (While x1 S) P \\<le>\\<^sub>L wlp (While x1 S) Q", "then"], ["proof (chain)\npicking this:\n  ?k < n \\<Longrightarrow> wlp (S ! ?k) Q \\<in> carrier_mat d d", "have dMkQ: \"k < n \\<Longrightarrow> adjoint (M k) * (wlp (S!k) Q) * (M k) \\<in> carrier_mat d d\" for k"], ["proof (prove)\nusing this:\n  ?k < n \\<Longrightarrow> wlp (S ! ?k) Q \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. k < n \\<Longrightarrow>\n    adjoint (M k) * wlp (S ! k) Q * M k \\<in> carrier_mat d d", "using dMk"], ["proof (prove)\nusing this:\n  ?k < n \\<Longrightarrow> wlp (S ! ?k) Q \\<in> carrier_mat d d\n  ?k < n \\<Longrightarrow> M ?k \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. k < n \\<Longrightarrow>\n    adjoint (M k) * wlp (S ! k) Q * M k \\<in> carrier_mat d d", "by fastforce"], ["proof (state)\nthis:\n  ?k < n \\<Longrightarrow>\n  adjoint (M ?k) * wlp (S ! ?k) Q * M ?k \\<in> carrier_mat d d\n\ngoal (2 subgoals):\n 1. \\<And>x1 x2a x3 P Q.\n       \\<lbrakk>\\<And>x3a P Q.\n                   \\<lbrakk>x3a \\<in> set x3; well_com x3a;\n                    is_quantum_predicate P; is_quantum_predicate Q;\n                    P \\<le>\\<^sub>L Q\\<rbrakk>\n                   \\<Longrightarrow> is_quantum_predicate (wlp x3a P) \\<and>\n                                     wlp x3a P \\<le>\\<^sub>L wlp x3a Q;\n        well_com (Measure x1 x2a x3); is_quantum_predicate P;\n        is_quantum_predicate Q; P \\<le>\\<^sub>L Q\\<rbrakk>\n       \\<Longrightarrow> is_quantum_predicate\n                          (wlp (Measure x1 x2a x3) P) \\<and>\n                         wlp (Measure x1 x2a x3) P \\<le>\\<^sub>L\n                         wlp (Measure x1 x2a x3) Q\n 2. \\<And>x1 S P Q.\n       \\<lbrakk>\\<And>P Q.\n                   \\<lbrakk>well_com S; is_quantum_predicate P;\n                    is_quantum_predicate Q; P \\<le>\\<^sub>L Q\\<rbrakk>\n                   \\<Longrightarrow> is_quantum_predicate (wlp S P) \\<and>\n                                     wlp S P \\<le>\\<^sub>L wlp S Q;\n        well_com (While x1 S); is_quantum_predicate P;\n        is_quantum_predicate Q; P \\<le>\\<^sub>L Q\\<rbrakk>\n       \\<Longrightarrow> is_quantum_predicate (wlp (While x1 S) P) \\<and>\n                         wlp (While x1 S) P \\<le>\\<^sub>L wlp (While x1 S) Q", "have \"k < n \\<Longrightarrow> wlp (S!k) P \\<le>\\<^sub>L wlp (S!k) Q\" for k"], ["proof (prove)\ngoal (1 subgoal):\n 1. k < n \\<Longrightarrow> wlp (S ! k) P \\<le>\\<^sub>L wlp (S ! k) Q", "using Measure(1)[OF set wck qpP qpQ le]"], ["proof (prove)\nusing this:\n  \\<lbrakk>?k1 < n; ?k1 < n\\<rbrakk>\n  \\<Longrightarrow> is_quantum_predicate (wlp (S ! ?k1) P) \\<and>\n                    wlp (S ! ?k1) P \\<le>\\<^sub>L wlp (S ! ?k1) Q\n\ngoal (1 subgoal):\n 1. k < n \\<Longrightarrow> wlp (S ! k) P \\<le>\\<^sub>L wlp (S ! k) Q", "by auto"], ["proof (state)\nthis:\n  ?k < n \\<Longrightarrow> wlp (S ! ?k) P \\<le>\\<^sub>L wlp (S ! ?k) Q\n\ngoal (2 subgoals):\n 1. \\<And>x1 x2a x3 P Q.\n       \\<lbrakk>\\<And>x3a P Q.\n                   \\<lbrakk>x3a \\<in> set x3; well_com x3a;\n                    is_quantum_predicate P; is_quantum_predicate Q;\n                    P \\<le>\\<^sub>L Q\\<rbrakk>\n                   \\<Longrightarrow> is_quantum_predicate (wlp x3a P) \\<and>\n                                     wlp x3a P \\<le>\\<^sub>L wlp x3a Q;\n        well_com (Measure x1 x2a x3); is_quantum_predicate P;\n        is_quantum_predicate Q; P \\<le>\\<^sub>L Q\\<rbrakk>\n       \\<Longrightarrow> is_quantum_predicate\n                          (wlp (Measure x1 x2a x3) P) \\<and>\n                         wlp (Measure x1 x2a x3) P \\<le>\\<^sub>L\n                         wlp (Measure x1 x2a x3) Q\n 2. \\<And>x1 S P Q.\n       \\<lbrakk>\\<And>P Q.\n                   \\<lbrakk>well_com S; is_quantum_predicate P;\n                    is_quantum_predicate Q; P \\<le>\\<^sub>L Q\\<rbrakk>\n                   \\<Longrightarrow> is_quantum_predicate (wlp S P) \\<and>\n                                     wlp S P \\<le>\\<^sub>L wlp S Q;\n        well_com (While x1 S); is_quantum_predicate P;\n        is_quantum_predicate Q; P \\<le>\\<^sub>L Q\\<rbrakk>\n       \\<Longrightarrow> is_quantum_predicate (wlp (While x1 S) P) \\<and>\n                         wlp (While x1 S) P \\<le>\\<^sub>L wlp (While x1 S) Q", "then"], ["proof (chain)\npicking this:\n  ?k < n \\<Longrightarrow> wlp (S ! ?k) P \\<le>\\<^sub>L wlp (S ! ?k) Q", "have \"k < n \\<Longrightarrow> adjoint (M k) * (wlp (S!k) P) * (M k) \\<le>\\<^sub>L adjoint (M k) * (wlp (S!k) Q) * (M k)\" for k"], ["proof (prove)\nusing this:\n  ?k < n \\<Longrightarrow> wlp (S ! ?k) P \\<le>\\<^sub>L wlp (S ! ?k) Q\n\ngoal (1 subgoal):\n 1. k < n \\<Longrightarrow>\n    adjoint (M k) * wlp (S ! k) P * M k \\<le>\\<^sub>L\n    adjoint (M k) * wlp (S ! k) Q * M k", "using lowner_le_keep_under_measurement[OF dMk dWkP dWkQ]"], ["proof (prove)\nusing this:\n  ?k < n \\<Longrightarrow> wlp (S ! ?k) P \\<le>\\<^sub>L wlp (S ! ?k) Q\n  \\<lbrakk>?k3 < n; ?k2 < n; ?k1 < n;\n   wlp (S ! ?k2) P \\<le>\\<^sub>L wlp (S ! ?k1) Q\\<rbrakk>\n  \\<Longrightarrow> adjoint (M ?k3) * wlp (S ! ?k2) P * M ?k3 \\<le>\\<^sub>L\n                    adjoint (M ?k3) * wlp (S ! ?k1) Q * M ?k3\n\ngoal (1 subgoal):\n 1. k < n \\<Longrightarrow>\n    adjoint (M k) * wlp (S ! k) P * M k \\<le>\\<^sub>L\n    adjoint (M k) * wlp (S ! k) Q * M k", "by auto"], ["proof (state)\nthis:\n  ?k < n \\<Longrightarrow>\n  adjoint (M ?k) * wlp (S ! ?k) P * M ?k \\<le>\\<^sub>L\n  adjoint (M ?k) * wlp (S ! ?k) Q * M ?k\n\ngoal (2 subgoals):\n 1. \\<And>x1 x2a x3 P Q.\n       \\<lbrakk>\\<And>x3a P Q.\n                   \\<lbrakk>x3a \\<in> set x3; well_com x3a;\n                    is_quantum_predicate P; is_quantum_predicate Q;\n                    P \\<le>\\<^sub>L Q\\<rbrakk>\n                   \\<Longrightarrow> is_quantum_predicate (wlp x3a P) \\<and>\n                                     wlp x3a P \\<le>\\<^sub>L wlp x3a Q;\n        well_com (Measure x1 x2a x3); is_quantum_predicate P;\n        is_quantum_predicate Q; P \\<le>\\<^sub>L Q\\<rbrakk>\n       \\<Longrightarrow> is_quantum_predicate\n                          (wlp (Measure x1 x2a x3) P) \\<and>\n                         wlp (Measure x1 x2a x3) P \\<le>\\<^sub>L\n                         wlp (Measure x1 x2a x3) Q\n 2. \\<And>x1 S P Q.\n       \\<lbrakk>\\<And>P Q.\n                   \\<lbrakk>well_com S; is_quantum_predicate P;\n                    is_quantum_predicate Q; P \\<le>\\<^sub>L Q\\<rbrakk>\n                   \\<Longrightarrow> is_quantum_predicate (wlp S P) \\<and>\n                                     wlp S P \\<le>\\<^sub>L wlp S Q;\n        well_com (While x1 S); is_quantum_predicate P;\n        is_quantum_predicate Q; P \\<le>\\<^sub>L Q\\<rbrakk>\n       \\<Longrightarrow> is_quantum_predicate (wlp (While x1 S) P) \\<and>\n                         wlp (While x1 S) P \\<le>\\<^sub>L wlp (While x1 S) Q", "then"], ["proof (chain)\npicking this:\n  ?k < n \\<Longrightarrow>\n  adjoint (M ?k) * wlp (S ! ?k) P * M ?k \\<le>\\<^sub>L\n  adjoint (M ?k) * wlp (S ! ?k) Q * M ?k", "have le': \"wlp (Measure n M S) P \\<le>\\<^sub>L wlp (Measure n M S) Q\""], ["proof (prove)\nusing this:\n  ?k < n \\<Longrightarrow>\n  adjoint (M ?k) * wlp (S ! ?k) P * M ?k \\<le>\\<^sub>L\n  adjoint (M ?k) * wlp (S ! ?k) Q * M ?k\n\ngoal (1 subgoal):\n 1. wlp (Measure n M S) P \\<le>\\<^sub>L wlp (Measure n M S) Q", "unfolding wlp_measure_expand[OF wc]"], ["proof (prove)\nusing this:\n  ?k < n \\<Longrightarrow>\n  adjoint (M ?k) * wlp (S ! ?k) P * M ?k \\<le>\\<^sub>L\n  adjoint (M ?k) * wlp (S ! ?k) Q * M ?k\n\ngoal (1 subgoal):\n 1. matrix_sum d (\\<lambda>k. adjoint (M k) * wlp (S ! k) P * M k)\n     n \\<le>\\<^sub>L\n    matrix_sum d (\\<lambda>k. adjoint (M k) * wlp (S ! k) Q * M k) n", "using lowner_le_matrix_sum dMkP dMkQ"], ["proof (prove)\nusing this:\n  ?k < n \\<Longrightarrow>\n  adjoint (M ?k) * wlp (S ! ?k) P * M ?k \\<le>\\<^sub>L\n  adjoint (M ?k) * wlp (S ! ?k) Q * M ?k\n  \\<lbrakk>\\<And>k. k < ?n \\<Longrightarrow> ?f k \\<in> carrier_mat ?d ?d;\n   \\<And>k. k < ?n \\<Longrightarrow> ?g k \\<in> carrier_mat ?d ?d;\n   \\<And>k. k < ?n \\<Longrightarrow> ?f k \\<le>\\<^sub>L ?g k\\<rbrakk>\n  \\<Longrightarrow> matrix_sum ?d ?f ?n \\<le>\\<^sub>L matrix_sum ?d ?g ?n\n  ?k < n \\<Longrightarrow>\n  adjoint (M ?k) * wlp (S ! ?k) P * M ?k \\<in> carrier_mat d d\n  ?k < n \\<Longrightarrow>\n  adjoint (M ?k) * wlp (S ! ?k) Q * M ?k \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. matrix_sum d (\\<lambda>k. adjoint (M k) * wlp (S ! k) P * M k)\n     n \\<le>\\<^sub>L\n    matrix_sum d (\\<lambda>k. adjoint (M k) * wlp (S ! k) Q * M k) n", "by auto"], ["proof (state)\nthis:\n  wlp (Measure n M S) P \\<le>\\<^sub>L wlp (Measure n M S) Q\n\ngoal (2 subgoals):\n 1. \\<And>x1 x2a x3 P Q.\n       \\<lbrakk>\\<And>x3a P Q.\n                   \\<lbrakk>x3a \\<in> set x3; well_com x3a;\n                    is_quantum_predicate P; is_quantum_predicate Q;\n                    P \\<le>\\<^sub>L Q\\<rbrakk>\n                   \\<Longrightarrow> is_quantum_predicate (wlp x3a P) \\<and>\n                                     wlp x3a P \\<le>\\<^sub>L wlp x3a Q;\n        well_com (Measure x1 x2a x3); is_quantum_predicate P;\n        is_quantum_predicate Q; P \\<le>\\<^sub>L Q\\<rbrakk>\n       \\<Longrightarrow> is_quantum_predicate\n                          (wlp (Measure x1 x2a x3) P) \\<and>\n                         wlp (Measure x1 x2a x3) P \\<le>\\<^sub>L\n                         wlp (Measure x1 x2a x3) Q\n 2. \\<And>x1 S P Q.\n       \\<lbrakk>\\<And>P Q.\n                   \\<lbrakk>well_com S; is_quantum_predicate P;\n                    is_quantum_predicate Q; P \\<le>\\<^sub>L Q\\<rbrakk>\n                   \\<Longrightarrow> is_quantum_predicate (wlp S P) \\<and>\n                                     wlp S P \\<le>\\<^sub>L wlp S Q;\n        well_com (While x1 S); is_quantum_predicate P;\n        is_quantum_predicate Q; P \\<le>\\<^sub>L Q\\<rbrakk>\n       \\<Longrightarrow> is_quantum_predicate (wlp (While x1 S) P) \\<and>\n                         wlp (While x1 S) P \\<le>\\<^sub>L wlp (While x1 S) Q", "have qp': \"is_quantum_predicate (wlp (Measure n M S) P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_quantum_predicate (wlp (Measure n M S) P)", "unfolding wlp_measure_expand[OF wc]"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_quantum_predicate\n     (matrix_sum d (\\<lambda>k. adjoint (M k) * wlp (S ! k) P * M k) n)", "using qps_after_measure_is_qp[OF m] qpk"], ["proof (prove)\nusing this:\n  (\\<And>k.\n      k < n \\<Longrightarrow> is_quantum_predicate (?P k)) \\<Longrightarrow>\n  is_quantum_predicate\n   (matrix_sum d (\\<lambda>k. adjoint (M k) * ?P k * M k) n)\n  ?k < n \\<Longrightarrow> is_quantum_predicate (wlp (S ! ?k) P)\n\ngoal (1 subgoal):\n 1. is_quantum_predicate\n     (matrix_sum d (\\<lambda>k. adjoint (M k) * wlp (S ! k) P * M k) n)", "by auto"], ["proof (state)\nthis:\n  is_quantum_predicate (wlp (Measure n M S) P)\n\ngoal (2 subgoals):\n 1. \\<And>x1 x2a x3 P Q.\n       \\<lbrakk>\\<And>x3a P Q.\n                   \\<lbrakk>x3a \\<in> set x3; well_com x3a;\n                    is_quantum_predicate P; is_quantum_predicate Q;\n                    P \\<le>\\<^sub>L Q\\<rbrakk>\n                   \\<Longrightarrow> is_quantum_predicate (wlp x3a P) \\<and>\n                                     wlp x3a P \\<le>\\<^sub>L wlp x3a Q;\n        well_com (Measure x1 x2a x3); is_quantum_predicate P;\n        is_quantum_predicate Q; P \\<le>\\<^sub>L Q\\<rbrakk>\n       \\<Longrightarrow> is_quantum_predicate\n                          (wlp (Measure x1 x2a x3) P) \\<and>\n                         wlp (Measure x1 x2a x3) P \\<le>\\<^sub>L\n                         wlp (Measure x1 x2a x3) Q\n 2. \\<And>x1 S P Q.\n       \\<lbrakk>\\<And>P Q.\n                   \\<lbrakk>well_com S; is_quantum_predicate P;\n                    is_quantum_predicate Q; P \\<le>\\<^sub>L Q\\<rbrakk>\n                   \\<Longrightarrow> is_quantum_predicate (wlp S P) \\<and>\n                                     wlp S P \\<le>\\<^sub>L wlp S Q;\n        well_com (While x1 S); is_quantum_predicate P;\n        is_quantum_predicate Q; P \\<le>\\<^sub>L Q\\<rbrakk>\n       \\<Longrightarrow> is_quantum_predicate (wlp (While x1 S) P) \\<and>\n                         wlp (While x1 S) P \\<le>\\<^sub>L wlp (While x1 S) Q", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_quantum_predicate (wlp (Measure n M S) P) \\<and>\n    wlp (Measure n M S) P \\<le>\\<^sub>L wlp (Measure n M S) Q", "using le' qp'"], ["proof (prove)\nusing this:\n  wlp (Measure n M S) P \\<le>\\<^sub>L wlp (Measure n M S) Q\n  is_quantum_predicate (wlp (Measure n M S) P)\n\ngoal (1 subgoal):\n 1. is_quantum_predicate (wlp (Measure n M S) P) \\<and>\n    wlp (Measure n M S) P \\<le>\\<^sub>L wlp (Measure n M S) Q", "by auto"], ["proof (state)\nthis:\n  is_quantum_predicate (wlp (Measure n M S) P) \\<and>\n  wlp (Measure n M S) P \\<le>\\<^sub>L wlp (Measure n M S) Q\n\ngoal (1 subgoal):\n 1. \\<And>x1 S P Q.\n       \\<lbrakk>\\<And>P Q.\n                   \\<lbrakk>well_com S; is_quantum_predicate P;\n                    is_quantum_predicate Q; P \\<le>\\<^sub>L Q\\<rbrakk>\n                   \\<Longrightarrow> is_quantum_predicate (wlp S P) \\<and>\n                                     wlp S P \\<le>\\<^sub>L wlp S Q;\n        well_com (While x1 S); is_quantum_predicate P;\n        is_quantum_predicate Q; P \\<le>\\<^sub>L Q\\<rbrakk>\n       \\<Longrightarrow> is_quantum_predicate (wlp (While x1 S) P) \\<and>\n                         wlp (While x1 S) P \\<le>\\<^sub>L wlp (While x1 S) Q", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1 S P Q.\n       \\<lbrakk>\\<And>P Q.\n                   \\<lbrakk>well_com S; is_quantum_predicate P;\n                    is_quantum_predicate Q; P \\<le>\\<^sub>L Q\\<rbrakk>\n                   \\<Longrightarrow> is_quantum_predicate (wlp S P) \\<and>\n                                     wlp S P \\<le>\\<^sub>L wlp S Q;\n        well_com (While x1 S); is_quantum_predicate P;\n        is_quantum_predicate Q; P \\<le>\\<^sub>L Q\\<rbrakk>\n       \\<Longrightarrow> is_quantum_predicate (wlp (While x1 S) P) \\<and>\n                         wlp (While x1 S) P \\<le>\\<^sub>L wlp (While x1 S) Q", "case (While M S)"], ["proof (state)\nthis:\n  \\<lbrakk>well_com S; is_quantum_predicate ?P; is_quantum_predicate ?Q;\n   ?P \\<le>\\<^sub>L ?Q\\<rbrakk>\n  \\<Longrightarrow> is_quantum_predicate (wlp S ?P) \\<and>\n                    wlp S ?P \\<le>\\<^sub>L wlp S ?Q\n  well_com (While M S)\n  is_quantum_predicate P\n  is_quantum_predicate Q\n  P \\<le>\\<^sub>L Q\n\ngoal (1 subgoal):\n 1. \\<And>x1 S P Q.\n       \\<lbrakk>\\<And>P Q.\n                   \\<lbrakk>well_com S; is_quantum_predicate P;\n                    is_quantum_predicate Q; P \\<le>\\<^sub>L Q\\<rbrakk>\n                   \\<Longrightarrow> is_quantum_predicate (wlp S P) \\<and>\n                                     wlp S P \\<le>\\<^sub>L wlp S Q;\n        well_com (While x1 S); is_quantum_predicate P;\n        is_quantum_predicate Q; P \\<le>\\<^sub>L Q\\<rbrakk>\n       \\<Longrightarrow> is_quantum_predicate (wlp (While x1 S) P) \\<and>\n                         wlp (While x1 S) P \\<le>\\<^sub>L wlp (While x1 S) Q", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>well_com S; is_quantum_predicate ?P; is_quantum_predicate ?Q;\n   ?P \\<le>\\<^sub>L ?Q\\<rbrakk>\n  \\<Longrightarrow> is_quantum_predicate (wlp S ?P) \\<and>\n                    wlp S ?P \\<le>\\<^sub>L wlp S ?Q\n  well_com (While M S)\n  is_quantum_predicate P\n  is_quantum_predicate Q\n  P \\<le>\\<^sub>L Q", "have m: \"measurement d 2 M\" and wcs: \"well_com S\" \n    and qpP: \"is_quantum_predicate P\""], ["proof (prove)\nusing this:\n  \\<lbrakk>well_com S; is_quantum_predicate ?P; is_quantum_predicate ?Q;\n   ?P \\<le>\\<^sub>L ?Q\\<rbrakk>\n  \\<Longrightarrow> is_quantum_predicate (wlp S ?P) \\<and>\n                    wlp S ?P \\<le>\\<^sub>L wlp S ?Q\n  well_com (While M S)\n  is_quantum_predicate P\n  is_quantum_predicate Q\n  P \\<le>\\<^sub>L Q\n\ngoal (1 subgoal):\n 1. measurement d 2 M &&& well_com S &&& is_quantum_predicate P", "by auto"], ["proof (state)\nthis:\n  measurement d 2 M\n  well_com S\n  is_quantum_predicate P\n\ngoal (1 subgoal):\n 1. \\<And>x1 S P Q.\n       \\<lbrakk>\\<And>P Q.\n                   \\<lbrakk>well_com S; is_quantum_predicate P;\n                    is_quantum_predicate Q; P \\<le>\\<^sub>L Q\\<rbrakk>\n                   \\<Longrightarrow> is_quantum_predicate (wlp S P) \\<and>\n                                     wlp S P \\<le>\\<^sub>L wlp S Q;\n        well_com (While x1 S); is_quantum_predicate P;\n        is_quantum_predicate Q; P \\<le>\\<^sub>L Q\\<rbrakk>\n       \\<Longrightarrow> is_quantum_predicate (wlp (While x1 S) P) \\<and>\n                         wlp (While x1 S) P \\<le>\\<^sub>L wlp (While x1 S) Q", "have closeWS: \"is_quantum_predicate P \\<Longrightarrow> is_quantum_predicate (wlp S P)\" for P"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_quantum_predicate P \\<Longrightarrow> is_quantum_predicate (wlp S P)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. is_quantum_predicate P \\<Longrightarrow> is_quantum_predicate (wlp S P)", "assume asm: \"is_quantum_predicate P\""], ["proof (state)\nthis:\n  is_quantum_predicate P\n\ngoal (1 subgoal):\n 1. is_quantum_predicate P \\<Longrightarrow> is_quantum_predicate (wlp S P)", "then"], ["proof (chain)\npicking this:\n  is_quantum_predicate P", "have dP: \"P \\<in> carrier_mat d d\""], ["proof (prove)\nusing this:\n  is_quantum_predicate P\n\ngoal (1 subgoal):\n 1. P \\<in> carrier_mat d d", "using is_quantum_predicate_def"], ["proof (prove)\nusing this:\n  is_quantum_predicate P\n  is_quantum_predicate ?P =\n  (?P \\<in> carrier_mat d d \\<and>\n   positive ?P \\<and> ?P \\<le>\\<^sub>L 1\\<^sub>m d)\n\ngoal (1 subgoal):\n 1. P \\<in> carrier_mat d d", "by auto"], ["proof (state)\nthis:\n  P \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. is_quantum_predicate P \\<Longrightarrow> is_quantum_predicate (wlp S P)", "then"], ["proof (chain)\npicking this:\n  P \\<in> carrier_mat d d", "show \"is_quantum_predicate (wlp S P)\""], ["proof (prove)\nusing this:\n  P \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. is_quantum_predicate (wlp S P)", "using While(1)[OF wcs asm asm lowner_le_refl] dP"], ["proof (prove)\nusing this:\n  P \\<in> carrier_mat d d\n  P \\<in> carrier_mat ?n1 ?n1 \\<Longrightarrow>\n  is_quantum_predicate (wlp S P) \\<and> wlp S P \\<le>\\<^sub>L wlp S P\n  P \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. is_quantum_predicate (wlp S P)", "by auto"], ["proof (state)\nthis:\n  is_quantum_predicate (wlp S P)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  is_quantum_predicate ?P \\<Longrightarrow> is_quantum_predicate (wlp S ?P)\n\ngoal (1 subgoal):\n 1. \\<And>x1 S P Q.\n       \\<lbrakk>\\<And>P Q.\n                   \\<lbrakk>well_com S; is_quantum_predicate P;\n                    is_quantum_predicate Q; P \\<le>\\<^sub>L Q\\<rbrakk>\n                   \\<Longrightarrow> is_quantum_predicate (wlp S P) \\<and>\n                                     wlp S P \\<le>\\<^sub>L wlp S Q;\n        well_com (While x1 S); is_quantum_predicate P;\n        is_quantum_predicate Q; P \\<le>\\<^sub>L Q\\<rbrakk>\n       \\<Longrightarrow> is_quantum_predicate (wlp (While x1 S) P) \\<and>\n                         wlp (While x1 S) P \\<le>\\<^sub>L wlp (While x1 S) Q", "have monoWS: \"is_quantum_predicate P \\<Longrightarrow> is_quantum_predicate Q \\<Longrightarrow> P \\<le>\\<^sub>L Q \\<Longrightarrow> wlp S P \\<le>\\<^sub>L wlp S Q\" for P Q"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_quantum_predicate P; is_quantum_predicate Q;\n     P \\<le>\\<^sub>L Q\\<rbrakk>\n    \\<Longrightarrow> wlp S P \\<le>\\<^sub>L wlp S Q", "using While(1)[OF wcs]"], ["proof (prove)\nusing this:\n  \\<lbrakk>is_quantum_predicate ?P; is_quantum_predicate ?Q;\n   ?P \\<le>\\<^sub>L ?Q\\<rbrakk>\n  \\<Longrightarrow> is_quantum_predicate (wlp S ?P) \\<and>\n                    wlp S ?P \\<le>\\<^sub>L wlp S ?Q\n\ngoal (1 subgoal):\n 1. \\<lbrakk>is_quantum_predicate P; is_quantum_predicate Q;\n     P \\<le>\\<^sub>L Q\\<rbrakk>\n    \\<Longrightarrow> wlp S P \\<le>\\<^sub>L wlp S Q", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>is_quantum_predicate ?P; is_quantum_predicate ?Q;\n   ?P \\<le>\\<^sub>L ?Q\\<rbrakk>\n  \\<Longrightarrow> wlp S ?P \\<le>\\<^sub>L wlp S ?Q\n\ngoal (1 subgoal):\n 1. \\<And>x1 S P Q.\n       \\<lbrakk>\\<And>P Q.\n                   \\<lbrakk>well_com S; is_quantum_predicate P;\n                    is_quantum_predicate Q; P \\<le>\\<^sub>L Q\\<rbrakk>\n                   \\<Longrightarrow> is_quantum_predicate (wlp S P) \\<and>\n                                     wlp S P \\<le>\\<^sub>L wlp S Q;\n        well_com (While x1 S); is_quantum_predicate P;\n        is_quantum_predicate Q; P \\<le>\\<^sub>L Q\\<rbrakk>\n       \\<Longrightarrow> is_quantum_predicate (wlp (While x1 S) P) \\<and>\n                         wlp (While x1 S) P \\<le>\\<^sub>L wlp (While x1 S) Q", "have \"is_quantum_predicate (wlp (While M S) P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_quantum_predicate (wlp (While M S) P)", "using wlp_while_exists[of \"wlp S\" M P] closeWS monoWS m qpP"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>P.\n              is_quantum_predicate P \\<Longrightarrow>\n              is_quantum_predicate (wlp S P);\n   \\<And>P Q.\n      \\<lbrakk>is_quantum_predicate P; is_quantum_predicate Q;\n       P \\<le>\\<^sub>L Q\\<rbrakk>\n      \\<Longrightarrow> wlp S P \\<le>\\<^sub>L wlp S Q;\n   measurement d 2 M; is_quantum_predicate P\\<rbrakk>\n  \\<Longrightarrow> is_quantum_predicate\n                     (wlp_while (M 0) (M 1) (wlp S) P) \\<and>\n                    (\\<forall>n.\n                        wlp_while (M 0) (M 1) (wlp S) P \\<le>\\<^sub>L\n                        wlp_while_n (M 0) (M 1) (wlp S) n P) \\<and>\n                    (\\<forall>W'.\n                        (\\<forall>n.\n                            W' \\<le>\\<^sub>L\n                            wlp_while_n (M 0) (M 1) (wlp S) n\n                             P) \\<longrightarrow>\n                        W' \\<le>\\<^sub>L\n                        wlp_while (M 0) (M 1) (wlp S) P) \\<and>\n                    limit_mat\n                     (\\<lambda>n. wlp_while_n (M 0) (M 1) (wlp S) n P)\n                     (wlp_while (M 0) (M 1) (wlp S) P) d\n  is_quantum_predicate ?P \\<Longrightarrow> is_quantum_predicate (wlp S ?P)\n  \\<lbrakk>is_quantum_predicate ?P; is_quantum_predicate ?Q;\n   ?P \\<le>\\<^sub>L ?Q\\<rbrakk>\n  \\<Longrightarrow> wlp S ?P \\<le>\\<^sub>L wlp S ?Q\n  measurement d 2 M\n  is_quantum_predicate P\n\ngoal (1 subgoal):\n 1. is_quantum_predicate (wlp (While M S) P)", "by auto"], ["proof (state)\nthis:\n  is_quantum_predicate (wlp (While M S) P)\n\ngoal (1 subgoal):\n 1. \\<And>x1 S P Q.\n       \\<lbrakk>\\<And>P Q.\n                   \\<lbrakk>well_com S; is_quantum_predicate P;\n                    is_quantum_predicate Q; P \\<le>\\<^sub>L Q\\<rbrakk>\n                   \\<Longrightarrow> is_quantum_predicate (wlp S P) \\<and>\n                                     wlp S P \\<le>\\<^sub>L wlp S Q;\n        well_com (While x1 S); is_quantum_predicate P;\n        is_quantum_predicate Q; P \\<le>\\<^sub>L Q\\<rbrakk>\n       \\<Longrightarrow> is_quantum_predicate (wlp (While x1 S) P) \\<and>\n                         wlp (While x1 S) P \\<le>\\<^sub>L wlp (While x1 S) Q", "moreover"], ["proof (state)\nthis:\n  is_quantum_predicate (wlp (While M S) P)\n\ngoal (1 subgoal):\n 1. \\<And>x1 S P Q.\n       \\<lbrakk>\\<And>P Q.\n                   \\<lbrakk>well_com S; is_quantum_predicate P;\n                    is_quantum_predicate Q; P \\<le>\\<^sub>L Q\\<rbrakk>\n                   \\<Longrightarrow> is_quantum_predicate (wlp S P) \\<and>\n                                     wlp S P \\<le>\\<^sub>L wlp S Q;\n        well_com (While x1 S); is_quantum_predicate P;\n        is_quantum_predicate Q; P \\<le>\\<^sub>L Q\\<rbrakk>\n       \\<Longrightarrow> is_quantum_predicate (wlp (While x1 S) P) \\<and>\n                         wlp (While x1 S) P \\<le>\\<^sub>L wlp (While x1 S) Q", "have \"wlp (While M S) P \\<le>\\<^sub>L wlp (While M S) Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wlp (While M S) P \\<le>\\<^sub>L wlp (While M S) Q", "using wlp_while_mono[of \"wlp S\" M P Q] closeWS monoWS m While"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>P.\n              is_quantum_predicate P \\<Longrightarrow>\n              is_quantum_predicate (wlp S P);\n   \\<And>P Q.\n      \\<lbrakk>is_quantum_predicate P; is_quantum_predicate Q;\n       P \\<le>\\<^sub>L Q\\<rbrakk>\n      \\<Longrightarrow> wlp S P \\<le>\\<^sub>L wlp S Q;\n   measurement d 2 M; is_quantum_predicate P; is_quantum_predicate Q;\n   P \\<le>\\<^sub>L Q\\<rbrakk>\n  \\<Longrightarrow> wlp_while (M 0) (M 1) (wlp S) P \\<le>\\<^sub>L\n                    wlp_while (M 0) (M 1) (wlp S) Q\n  is_quantum_predicate ?P \\<Longrightarrow> is_quantum_predicate (wlp S ?P)\n  \\<lbrakk>is_quantum_predicate ?P; is_quantum_predicate ?Q;\n   ?P \\<le>\\<^sub>L ?Q\\<rbrakk>\n  \\<Longrightarrow> wlp S ?P \\<le>\\<^sub>L wlp S ?Q\n  measurement d 2 M\n  \\<lbrakk>well_com S; is_quantum_predicate ?P; is_quantum_predicate ?Q;\n   ?P \\<le>\\<^sub>L ?Q\\<rbrakk>\n  \\<Longrightarrow> is_quantum_predicate (wlp S ?P) \\<and>\n                    wlp S ?P \\<le>\\<^sub>L wlp S ?Q\n  well_com (While M S)\n  is_quantum_predicate P\n  is_quantum_predicate Q\n  P \\<le>\\<^sub>L Q\n\ngoal (1 subgoal):\n 1. wlp (While M S) P \\<le>\\<^sub>L wlp (While M S) Q", "by auto"], ["proof (state)\nthis:\n  wlp (While M S) P \\<le>\\<^sub>L wlp (While M S) Q\n\ngoal (1 subgoal):\n 1. \\<And>x1 S P Q.\n       \\<lbrakk>\\<And>P Q.\n                   \\<lbrakk>well_com S; is_quantum_predicate P;\n                    is_quantum_predicate Q; P \\<le>\\<^sub>L Q\\<rbrakk>\n                   \\<Longrightarrow> is_quantum_predicate (wlp S P) \\<and>\n                                     wlp S P \\<le>\\<^sub>L wlp S Q;\n        well_com (While x1 S); is_quantum_predicate P;\n        is_quantum_predicate Q; P \\<le>\\<^sub>L Q\\<rbrakk>\n       \\<Longrightarrow> is_quantum_predicate (wlp (While x1 S) P) \\<and>\n                         wlp (While x1 S) P \\<le>\\<^sub>L wlp (While x1 S) Q", "ultimately"], ["proof (chain)\npicking this:\n  is_quantum_predicate (wlp (While M S) P)\n  wlp (While M S) P \\<le>\\<^sub>L wlp (While M S) Q", "show ?case"], ["proof (prove)\nusing this:\n  is_quantum_predicate (wlp (While M S) P)\n  wlp (While M S) P \\<le>\\<^sub>L wlp (While M S) Q\n\ngoal (1 subgoal):\n 1. is_quantum_predicate (wlp (While M S) P) \\<and>\n    wlp (While M S) P \\<le>\\<^sub>L wlp (While M S) Q", "by auto"], ["proof (state)\nthis:\n  is_quantum_predicate (wlp (While M S) P) \\<and>\n  wlp (While M S) P \\<le>\\<^sub>L wlp (While M S) Q\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma wlp_close:\n  assumes wc: \"well_com S\" and qp: \"is_quantum_predicate P\"\n  shows \"is_quantum_predicate (wlp S P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_quantum_predicate (wlp S P)", "using wlp_mono_and_close[OF wc qp qp] is_quantum_predicate_def[of P] qp lowner_le_refl"], ["proof (prove)\nusing this:\n  P \\<le>\\<^sub>L P \\<Longrightarrow>\n  is_quantum_predicate (wlp S P) \\<and> wlp S P \\<le>\\<^sub>L wlp S P\n  is_quantum_predicate P =\n  (P \\<in> carrier_mat d d \\<and>\n   positive P \\<and> P \\<le>\\<^sub>L 1\\<^sub>m d)\n  is_quantum_predicate P\n  ?A \\<in> carrier_mat ?n ?n \\<Longrightarrow> ?A \\<le>\\<^sub>L ?A\n\ngoal (1 subgoal):\n 1. is_quantum_predicate (wlp S P)", "by auto"], ["", "lemma wlp_soundness:\n  \"well_com S \\<Longrightarrow> \n    (\\<And>P. (is_quantum_predicate P \\<Longrightarrow> \n      (\\<forall>\\<rho> \\<in> density_states. trace (wlp S P * \\<rho>) = trace (P * (denote S \\<rho>)) + trace \\<rho> - trace (denote S \\<rho>))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. well_com S \\<Longrightarrow>\n    (\\<And>P.\n        is_quantum_predicate P \\<Longrightarrow>\n        \\<forall>\\<rho>\\<in>density_states.\n           trace (wlp S P * \\<rho>) =\n           trace (P * denote S \\<rho>) + trace \\<rho> -\n           trace (denote S \\<rho>))", "proof (induct S)"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>P.\n       \\<lbrakk>well_com SKIP; is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                            trace (wlp SKIP P * \\<rho>) =\n                            trace (P * denote SKIP \\<rho>) + trace \\<rho> -\n                            trace (denote SKIP \\<rho>)\n 2. \\<And>x P.\n       \\<lbrakk>well_com (Utrans x); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                            trace (wlp (Utrans x) P * \\<rho>) =\n                            trace (P * denote (Utrans x) \\<rho>) +\n                            trace \\<rho> -\n                            trace (denote (Utrans x) \\<rho>)\n 3. \\<And>S1 S2 P.\n       \\<lbrakk>\\<And>P.\n                   \\<lbrakk>well_com S1; is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n  trace (wlp S1 P * \\<rho>) =\n  trace (P * denote S1 \\<rho>) + trace \\<rho> - trace (denote S1 \\<rho>);\n        \\<And>P.\n           \\<lbrakk>well_com S2; is_quantum_predicate P\\<rbrakk>\n           \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                                trace (wlp S2 P * \\<rho>) =\n                                trace (P * denote S2 \\<rho>) +\n                                trace \\<rho> -\n                                trace (denote S2 \\<rho>);\n        well_com (S1;; S2); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                            trace (wlp (S1;; S2) P * \\<rho>) =\n                            trace (P * denote (S1;; S2) \\<rho>) +\n                            trace \\<rho> -\n                            trace (denote (S1;; S2) \\<rho>)\n 4. \\<And>x1 x2a x3 P.\n       \\<lbrakk>\\<And>x3a P.\n                   \\<lbrakk>x3a \\<in> set x3; well_com x3a;\n                    is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n  trace (wlp x3a P * \\<rho>) =\n  trace (P * denote x3a \\<rho>) + trace \\<rho> - trace (denote x3a \\<rho>);\n        well_com (Measure x1 x2a x3); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                            trace (wlp (Measure x1 x2a x3) P * \\<rho>) =\n                            trace (P * denote (Measure x1 x2a x3) \\<rho>) +\n                            trace \\<rho> -\n                            trace (denote (Measure x1 x2a x3) \\<rho>)\n 5. \\<And>x1 S P.\n       \\<lbrakk>\\<And>P.\n                   \\<lbrakk>well_com S; is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n  trace (wlp S P * \\<rho>) =\n  trace (P * denote S \\<rho>) + trace \\<rho> - trace (denote S \\<rho>);\n        well_com (While x1 S); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                            trace (wlp (While x1 S) P * \\<rho>) =\n                            trace (P * denote (While x1 S) \\<rho>) +\n                            trace \\<rho> -\n                            trace (denote (While x1 S) \\<rho>)", "case SKIP"], ["proof (state)\nthis:\n  well_com SKIP\n  is_quantum_predicate P\n\ngoal (5 subgoals):\n 1. \\<And>P.\n       \\<lbrakk>well_com SKIP; is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                            trace (wlp SKIP P * \\<rho>) =\n                            trace (P * denote SKIP \\<rho>) + trace \\<rho> -\n                            trace (denote SKIP \\<rho>)\n 2. \\<And>x P.\n       \\<lbrakk>well_com (Utrans x); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                            trace (wlp (Utrans x) P * \\<rho>) =\n                            trace (P * denote (Utrans x) \\<rho>) +\n                            trace \\<rho> -\n                            trace (denote (Utrans x) \\<rho>)\n 3. \\<And>S1 S2 P.\n       \\<lbrakk>\\<And>P.\n                   \\<lbrakk>well_com S1; is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n  trace (wlp S1 P * \\<rho>) =\n  trace (P * denote S1 \\<rho>) + trace \\<rho> - trace (denote S1 \\<rho>);\n        \\<And>P.\n           \\<lbrakk>well_com S2; is_quantum_predicate P\\<rbrakk>\n           \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                                trace (wlp S2 P * \\<rho>) =\n                                trace (P * denote S2 \\<rho>) +\n                                trace \\<rho> -\n                                trace (denote S2 \\<rho>);\n        well_com (S1;; S2); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                            trace (wlp (S1;; S2) P * \\<rho>) =\n                            trace (P * denote (S1;; S2) \\<rho>) +\n                            trace \\<rho> -\n                            trace (denote (S1;; S2) \\<rho>)\n 4. \\<And>x1 x2a x3 P.\n       \\<lbrakk>\\<And>x3a P.\n                   \\<lbrakk>x3a \\<in> set x3; well_com x3a;\n                    is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n  trace (wlp x3a P * \\<rho>) =\n  trace (P * denote x3a \\<rho>) + trace \\<rho> - trace (denote x3a \\<rho>);\n        well_com (Measure x1 x2a x3); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                            trace (wlp (Measure x1 x2a x3) P * \\<rho>) =\n                            trace (P * denote (Measure x1 x2a x3) \\<rho>) +\n                            trace \\<rho> -\n                            trace (denote (Measure x1 x2a x3) \\<rho>)\n 5. \\<And>x1 S P.\n       \\<lbrakk>\\<And>P.\n                   \\<lbrakk>well_com S; is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n  trace (wlp S P * \\<rho>) =\n  trace (P * denote S \\<rho>) + trace \\<rho> - trace (denote S \\<rho>);\n        well_com (While x1 S); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                            trace (wlp (While x1 S) P * \\<rho>) =\n                            trace (P * denote (While x1 S) \\<rho>) +\n                            trace \\<rho> -\n                            trace (denote (While x1 S) \\<rho>)", "then"], ["proof (chain)\npicking this:\n  well_com SKIP\n  is_quantum_predicate P", "show ?case"], ["proof (prove)\nusing this:\n  well_com SKIP\n  is_quantum_predicate P\n\ngoal (1 subgoal):\n 1. \\<forall>\\<rho>\\<in>density_states.\n       trace (wlp SKIP P * \\<rho>) =\n       trace (P * denote SKIP \\<rho>) + trace \\<rho> -\n       trace (denote SKIP \\<rho>)", "by auto"], ["proof (state)\nthis:\n  \\<forall>\\<rho>\\<in>density_states.\n     trace (wlp SKIP P * \\<rho>) =\n     trace (P * denote SKIP \\<rho>) + trace \\<rho> -\n     trace (denote SKIP \\<rho>)\n\ngoal (4 subgoals):\n 1. \\<And>x P.\n       \\<lbrakk>well_com (Utrans x); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                            trace (wlp (Utrans x) P * \\<rho>) =\n                            trace (P * denote (Utrans x) \\<rho>) +\n                            trace \\<rho> -\n                            trace (denote (Utrans x) \\<rho>)\n 2. \\<And>S1 S2 P.\n       \\<lbrakk>\\<And>P.\n                   \\<lbrakk>well_com S1; is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n  trace (wlp S1 P * \\<rho>) =\n  trace (P * denote S1 \\<rho>) + trace \\<rho> - trace (denote S1 \\<rho>);\n        \\<And>P.\n           \\<lbrakk>well_com S2; is_quantum_predicate P\\<rbrakk>\n           \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                                trace (wlp S2 P * \\<rho>) =\n                                trace (P * denote S2 \\<rho>) +\n                                trace \\<rho> -\n                                trace (denote S2 \\<rho>);\n        well_com (S1;; S2); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                            trace (wlp (S1;; S2) P * \\<rho>) =\n                            trace (P * denote (S1;; S2) \\<rho>) +\n                            trace \\<rho> -\n                            trace (denote (S1;; S2) \\<rho>)\n 3. \\<And>x1 x2a x3 P.\n       \\<lbrakk>\\<And>x3a P.\n                   \\<lbrakk>x3a \\<in> set x3; well_com x3a;\n                    is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n  trace (wlp x3a P * \\<rho>) =\n  trace (P * denote x3a \\<rho>) + trace \\<rho> - trace (denote x3a \\<rho>);\n        well_com (Measure x1 x2a x3); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                            trace (wlp (Measure x1 x2a x3) P * \\<rho>) =\n                            trace (P * denote (Measure x1 x2a x3) \\<rho>) +\n                            trace \\<rho> -\n                            trace (denote (Measure x1 x2a x3) \\<rho>)\n 4. \\<And>x1 S P.\n       \\<lbrakk>\\<And>P.\n                   \\<lbrakk>well_com S; is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n  trace (wlp S P * \\<rho>) =\n  trace (P * denote S \\<rho>) + trace \\<rho> - trace (denote S \\<rho>);\n        well_com (While x1 S); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                            trace (wlp (While x1 S) P * \\<rho>) =\n                            trace (P * denote (While x1 S) \\<rho>) +\n                            trace \\<rho> -\n                            trace (denote (While x1 S) \\<rho>)", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x P.\n       \\<lbrakk>well_com (Utrans x); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                            trace (wlp (Utrans x) P * \\<rho>) =\n                            trace (P * denote (Utrans x) \\<rho>) +\n                            trace \\<rho> -\n                            trace (denote (Utrans x) \\<rho>)\n 2. \\<And>S1 S2 P.\n       \\<lbrakk>\\<And>P.\n                   \\<lbrakk>well_com S1; is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n  trace (wlp S1 P * \\<rho>) =\n  trace (P * denote S1 \\<rho>) + trace \\<rho> - trace (denote S1 \\<rho>);\n        \\<And>P.\n           \\<lbrakk>well_com S2; is_quantum_predicate P\\<rbrakk>\n           \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                                trace (wlp S2 P * \\<rho>) =\n                                trace (P * denote S2 \\<rho>) +\n                                trace \\<rho> -\n                                trace (denote S2 \\<rho>);\n        well_com (S1;; S2); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                            trace (wlp (S1;; S2) P * \\<rho>) =\n                            trace (P * denote (S1;; S2) \\<rho>) +\n                            trace \\<rho> -\n                            trace (denote (S1;; S2) \\<rho>)\n 3. \\<And>x1 x2a x3 P.\n       \\<lbrakk>\\<And>x3a P.\n                   \\<lbrakk>x3a \\<in> set x3; well_com x3a;\n                    is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n  trace (wlp x3a P * \\<rho>) =\n  trace (P * denote x3a \\<rho>) + trace \\<rho> - trace (denote x3a \\<rho>);\n        well_com (Measure x1 x2a x3); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                            trace (wlp (Measure x1 x2a x3) P * \\<rho>) =\n                            trace (P * denote (Measure x1 x2a x3) \\<rho>) +\n                            trace \\<rho> -\n                            trace (denote (Measure x1 x2a x3) \\<rho>)\n 4. \\<And>x1 S P.\n       \\<lbrakk>\\<And>P.\n                   \\<lbrakk>well_com S; is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n  trace (wlp S P * \\<rho>) =\n  trace (P * denote S \\<rho>) + trace \\<rho> - trace (denote S \\<rho>);\n        well_com (While x1 S); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                            trace (wlp (While x1 S) P * \\<rho>) =\n                            trace (P * denote (While x1 S) \\<rho>) +\n                            trace \\<rho> -\n                            trace (denote (While x1 S) \\<rho>)", "case (Utrans U)"], ["proof (state)\nthis:\n  well_com (Utrans U)\n  is_quantum_predicate P\n\ngoal (4 subgoals):\n 1. \\<And>x P.\n       \\<lbrakk>well_com (Utrans x); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                            trace (wlp (Utrans x) P * \\<rho>) =\n                            trace (P * denote (Utrans x) \\<rho>) +\n                            trace \\<rho> -\n                            trace (denote (Utrans x) \\<rho>)\n 2. \\<And>S1 S2 P.\n       \\<lbrakk>\\<And>P.\n                   \\<lbrakk>well_com S1; is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n  trace (wlp S1 P * \\<rho>) =\n  trace (P * denote S1 \\<rho>) + trace \\<rho> - trace (denote S1 \\<rho>);\n        \\<And>P.\n           \\<lbrakk>well_com S2; is_quantum_predicate P\\<rbrakk>\n           \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                                trace (wlp S2 P * \\<rho>) =\n                                trace (P * denote S2 \\<rho>) +\n                                trace \\<rho> -\n                                trace (denote S2 \\<rho>);\n        well_com (S1;; S2); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                            trace (wlp (S1;; S2) P * \\<rho>) =\n                            trace (P * denote (S1;; S2) \\<rho>) +\n                            trace \\<rho> -\n                            trace (denote (S1;; S2) \\<rho>)\n 3. \\<And>x1 x2a x3 P.\n       \\<lbrakk>\\<And>x3a P.\n                   \\<lbrakk>x3a \\<in> set x3; well_com x3a;\n                    is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n  trace (wlp x3a P * \\<rho>) =\n  trace (P * denote x3a \\<rho>) + trace \\<rho> - trace (denote x3a \\<rho>);\n        well_com (Measure x1 x2a x3); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                            trace (wlp (Measure x1 x2a x3) P * \\<rho>) =\n                            trace (P * denote (Measure x1 x2a x3) \\<rho>) +\n                            trace \\<rho> -\n                            trace (denote (Measure x1 x2a x3) \\<rho>)\n 4. \\<And>x1 S P.\n       \\<lbrakk>\\<And>P.\n                   \\<lbrakk>well_com S; is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n  trace (wlp S P * \\<rho>) =\n  trace (P * denote S \\<rho>) + trace \\<rho> - trace (denote S \\<rho>);\n        well_com (While x1 S); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                            trace (wlp (While x1 S) P * \\<rho>) =\n                            trace (P * denote (While x1 S) \\<rho>) +\n                            trace \\<rho> -\n                            trace (denote (While x1 S) \\<rho>)", "then"], ["proof (chain)\npicking this:\n  well_com (Utrans U)\n  is_quantum_predicate P", "have dU: \"U \\<in> carrier_mat d d\" and u: \"unitary U\" and wc: \"well_com (Utrans U)\" \n    and qp: \"is_quantum_predicate P\" and dP: \"P \\<in> carrier_mat d d\""], ["proof (prove)\nusing this:\n  well_com (Utrans U)\n  is_quantum_predicate P\n\ngoal (1 subgoal):\n 1. (U \\<in> carrier_mat d d &&& unitary U) &&&\n    well_com (Utrans U) &&&\n    is_quantum_predicate P &&& P \\<in> carrier_mat d d", "using is_quantum_predicate_def"], ["proof (prove)\nusing this:\n  well_com (Utrans U)\n  is_quantum_predicate P\n  is_quantum_predicate ?P =\n  (?P \\<in> carrier_mat d d \\<and>\n   positive ?P \\<and> ?P \\<le>\\<^sub>L 1\\<^sub>m d)\n\ngoal (1 subgoal):\n 1. (U \\<in> carrier_mat d d &&& unitary U) &&&\n    well_com (Utrans U) &&&\n    is_quantum_predicate P &&& P \\<in> carrier_mat d d", "by auto"], ["proof (state)\nthis:\n  U \\<in> carrier_mat d d\n  unitary U\n  well_com (Utrans U)\n  is_quantum_predicate P\n  P \\<in> carrier_mat d d\n\ngoal (4 subgoals):\n 1. \\<And>x P.\n       \\<lbrakk>well_com (Utrans x); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                            trace (wlp (Utrans x) P * \\<rho>) =\n                            trace (P * denote (Utrans x) \\<rho>) +\n                            trace \\<rho> -\n                            trace (denote (Utrans x) \\<rho>)\n 2. \\<And>S1 S2 P.\n       \\<lbrakk>\\<And>P.\n                   \\<lbrakk>well_com S1; is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n  trace (wlp S1 P * \\<rho>) =\n  trace (P * denote S1 \\<rho>) + trace \\<rho> - trace (denote S1 \\<rho>);\n        \\<And>P.\n           \\<lbrakk>well_com S2; is_quantum_predicate P\\<rbrakk>\n           \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                                trace (wlp S2 P * \\<rho>) =\n                                trace (P * denote S2 \\<rho>) +\n                                trace \\<rho> -\n                                trace (denote S2 \\<rho>);\n        well_com (S1;; S2); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                            trace (wlp (S1;; S2) P * \\<rho>) =\n                            trace (P * denote (S1;; S2) \\<rho>) +\n                            trace \\<rho> -\n                            trace (denote (S1;; S2) \\<rho>)\n 3. \\<And>x1 x2a x3 P.\n       \\<lbrakk>\\<And>x3a P.\n                   \\<lbrakk>x3a \\<in> set x3; well_com x3a;\n                    is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n  trace (wlp x3a P * \\<rho>) =\n  trace (P * denote x3a \\<rho>) + trace \\<rho> - trace (denote x3a \\<rho>);\n        well_com (Measure x1 x2a x3); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                            trace (wlp (Measure x1 x2a x3) P * \\<rho>) =\n                            trace (P * denote (Measure x1 x2a x3) \\<rho>) +\n                            trace \\<rho> -\n                            trace (denote (Measure x1 x2a x3) \\<rho>)\n 4. \\<And>x1 S P.\n       \\<lbrakk>\\<And>P.\n                   \\<lbrakk>well_com S; is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n  trace (wlp S P * \\<rho>) =\n  trace (P * denote S \\<rho>) + trace \\<rho> - trace (denote S \\<rho>);\n        well_com (While x1 S); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                            trace (wlp (While x1 S) P * \\<rho>) =\n                            trace (P * denote (While x1 S) \\<rho>) +\n                            trace \\<rho> -\n                            trace (denote (While x1 S) \\<rho>)", "have qp': \"is_quantum_predicate (wlp (Utrans U) P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_quantum_predicate (wlp (Utrans U) P)", "using wlp_close[OF wc qp]"], ["proof (prove)\nusing this:\n  is_quantum_predicate (wlp (Utrans U) P)\n\ngoal (1 subgoal):\n 1. is_quantum_predicate (wlp (Utrans U) P)", "by auto"], ["proof (state)\nthis:\n  is_quantum_predicate (wlp (Utrans U) P)\n\ngoal (4 subgoals):\n 1. \\<And>x P.\n       \\<lbrakk>well_com (Utrans x); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                            trace (wlp (Utrans x) P * \\<rho>) =\n                            trace (P * denote (Utrans x) \\<rho>) +\n                            trace \\<rho> -\n                            trace (denote (Utrans x) \\<rho>)\n 2. \\<And>S1 S2 P.\n       \\<lbrakk>\\<And>P.\n                   \\<lbrakk>well_com S1; is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n  trace (wlp S1 P * \\<rho>) =\n  trace (P * denote S1 \\<rho>) + trace \\<rho> - trace (denote S1 \\<rho>);\n        \\<And>P.\n           \\<lbrakk>well_com S2; is_quantum_predicate P\\<rbrakk>\n           \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                                trace (wlp S2 P * \\<rho>) =\n                                trace (P * denote S2 \\<rho>) +\n                                trace \\<rho> -\n                                trace (denote S2 \\<rho>);\n        well_com (S1;; S2); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                            trace (wlp (S1;; S2) P * \\<rho>) =\n                            trace (P * denote (S1;; S2) \\<rho>) +\n                            trace \\<rho> -\n                            trace (denote (S1;; S2) \\<rho>)\n 3. \\<And>x1 x2a x3 P.\n       \\<lbrakk>\\<And>x3a P.\n                   \\<lbrakk>x3a \\<in> set x3; well_com x3a;\n                    is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n  trace (wlp x3a P * \\<rho>) =\n  trace (P * denote x3a \\<rho>) + trace \\<rho> - trace (denote x3a \\<rho>);\n        well_com (Measure x1 x2a x3); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                            trace (wlp (Measure x1 x2a x3) P * \\<rho>) =\n                            trace (P * denote (Measure x1 x2a x3) \\<rho>) +\n                            trace \\<rho> -\n                            trace (denote (Measure x1 x2a x3) \\<rho>)\n 4. \\<And>x1 S P.\n       \\<lbrakk>\\<And>P.\n                   \\<lbrakk>well_com S; is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n  trace (wlp S P * \\<rho>) =\n  trace (P * denote S \\<rho>) + trace \\<rho> - trace (denote S \\<rho>);\n        well_com (While x1 S); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                            trace (wlp (While x1 S) P * \\<rho>) =\n                            trace (P * denote (While x1 S) \\<rho>) +\n                            trace \\<rho> -\n                            trace (denote (While x1 S) \\<rho>)", "have eq1: \"trace (adjoint U * P * U * \\<rho>) = trace (P * (U * \\<rho> * adjoint U))\" if dr: \"\\<rho> \\<in> carrier_mat d d\" for \\<rho>"], ["proof (prove)\ngoal (1 subgoal):\n 1. trace (adjoint U * P * U * \\<rho>) =\n    trace (P * (U * \\<rho> * adjoint U))", "using dr dP"], ["proof (prove)\nusing this:\n  \\<rho> \\<in> carrier_mat d d\n  P \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. trace (adjoint U * P * U * \\<rho>) =\n    trace (P * (U * \\<rho> * adjoint U))", "apply (mat_assoc d)"], ["proof (prove)\ngoal (1 subgoal):\n 1. U \\<in> carrier_mat d d", "using wc"], ["proof (prove)\nusing this:\n  well_com (Utrans U)\n\ngoal (1 subgoal):\n 1. U \\<in> carrier_mat d d", "by auto"], ["proof (state)\nthis:\n  ?\\<rho> \\<in> carrier_mat d d \\<Longrightarrow>\n  trace (adjoint U * P * U * ?\\<rho>) =\n  trace (P * (U * ?\\<rho> * adjoint U))\n\ngoal (4 subgoals):\n 1. \\<And>x P.\n       \\<lbrakk>well_com (Utrans x); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                            trace (wlp (Utrans x) P * \\<rho>) =\n                            trace (P * denote (Utrans x) \\<rho>) +\n                            trace \\<rho> -\n                            trace (denote (Utrans x) \\<rho>)\n 2. \\<And>S1 S2 P.\n       \\<lbrakk>\\<And>P.\n                   \\<lbrakk>well_com S1; is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n  trace (wlp S1 P * \\<rho>) =\n  trace (P * denote S1 \\<rho>) + trace \\<rho> - trace (denote S1 \\<rho>);\n        \\<And>P.\n           \\<lbrakk>well_com S2; is_quantum_predicate P\\<rbrakk>\n           \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                                trace (wlp S2 P * \\<rho>) =\n                                trace (P * denote S2 \\<rho>) +\n                                trace \\<rho> -\n                                trace (denote S2 \\<rho>);\n        well_com (S1;; S2); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                            trace (wlp (S1;; S2) P * \\<rho>) =\n                            trace (P * denote (S1;; S2) \\<rho>) +\n                            trace \\<rho> -\n                            trace (denote (S1;; S2) \\<rho>)\n 3. \\<And>x1 x2a x3 P.\n       \\<lbrakk>\\<And>x3a P.\n                   \\<lbrakk>x3a \\<in> set x3; well_com x3a;\n                    is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n  trace (wlp x3a P * \\<rho>) =\n  trace (P * denote x3a \\<rho>) + trace \\<rho> - trace (denote x3a \\<rho>);\n        well_com (Measure x1 x2a x3); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                            trace (wlp (Measure x1 x2a x3) P * \\<rho>) =\n                            trace (P * denote (Measure x1 x2a x3) \\<rho>) +\n                            trace \\<rho> -\n                            trace (denote (Measure x1 x2a x3) \\<rho>)\n 4. \\<And>x1 S P.\n       \\<lbrakk>\\<And>P.\n                   \\<lbrakk>well_com S; is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n  trace (wlp S P * \\<rho>) =\n  trace (P * denote S \\<rho>) + trace \\<rho> - trace (denote S \\<rho>);\n        well_com (While x1 S); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                            trace (wlp (While x1 S) P * \\<rho>) =\n                            trace (P * denote (While x1 S) \\<rho>) +\n                            trace \\<rho> -\n                            trace (denote (While x1 S) \\<rho>)", "have eq2: \"trace (U * \\<rho> * adjoint U) = trace \\<rho>\" if dr: \"\\<rho> \\<in> carrier_mat d d\" for \\<rho>"], ["proof (prove)\ngoal (1 subgoal):\n 1. trace (U * \\<rho> * adjoint U) = trace \\<rho>", "using unitary_operator_keep_trace[OF adjoint_dim[OF dU] dr unitary_adjoint[OF dU u]] adjoint_adjoint[of U]"], ["proof (prove)\nusing this:\n  trace \\<rho> = trace (adjoint (adjoint U) * \\<rho> * adjoint U)\n  adjoint (adjoint U) = U\n\ngoal (1 subgoal):\n 1. trace (U * \\<rho> * adjoint U) = trace \\<rho>", "by auto"], ["proof (state)\nthis:\n  ?\\<rho> \\<in> carrier_mat d d \\<Longrightarrow>\n  trace (U * ?\\<rho> * adjoint U) = trace ?\\<rho>\n\ngoal (4 subgoals):\n 1. \\<And>x P.\n       \\<lbrakk>well_com (Utrans x); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                            trace (wlp (Utrans x) P * \\<rho>) =\n                            trace (P * denote (Utrans x) \\<rho>) +\n                            trace \\<rho> -\n                            trace (denote (Utrans x) \\<rho>)\n 2. \\<And>S1 S2 P.\n       \\<lbrakk>\\<And>P.\n                   \\<lbrakk>well_com S1; is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n  trace (wlp S1 P * \\<rho>) =\n  trace (P * denote S1 \\<rho>) + trace \\<rho> - trace (denote S1 \\<rho>);\n        \\<And>P.\n           \\<lbrakk>well_com S2; is_quantum_predicate P\\<rbrakk>\n           \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                                trace (wlp S2 P * \\<rho>) =\n                                trace (P * denote S2 \\<rho>) +\n                                trace \\<rho> -\n                                trace (denote S2 \\<rho>);\n        well_com (S1;; S2); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                            trace (wlp (S1;; S2) P * \\<rho>) =\n                            trace (P * denote (S1;; S2) \\<rho>) +\n                            trace \\<rho> -\n                            trace (denote (S1;; S2) \\<rho>)\n 3. \\<And>x1 x2a x3 P.\n       \\<lbrakk>\\<And>x3a P.\n                   \\<lbrakk>x3a \\<in> set x3; well_com x3a;\n                    is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n  trace (wlp x3a P * \\<rho>) =\n  trace (P * denote x3a \\<rho>) + trace \\<rho> - trace (denote x3a \\<rho>);\n        well_com (Measure x1 x2a x3); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                            trace (wlp (Measure x1 x2a x3) P * \\<rho>) =\n                            trace (P * denote (Measure x1 x2a x3) \\<rho>) +\n                            trace \\<rho> -\n                            trace (denote (Measure x1 x2a x3) \\<rho>)\n 4. \\<And>x1 S P.\n       \\<lbrakk>\\<And>P.\n                   \\<lbrakk>well_com S; is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n  trace (wlp S P * \\<rho>) =\n  trace (P * denote S \\<rho>) + trace \\<rho> - trace (denote S \\<rho>);\n        well_com (While x1 S); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                            trace (wlp (While x1 S) P * \\<rho>) =\n                            trace (P * denote (While x1 S) \\<rho>) +\n                            trace \\<rho> -\n                            trace (denote (While x1 S) \\<rho>)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<rho>\\<in>density_states.\n       trace (wlp (Utrans U) P * \\<rho>) =\n       trace (P * denote (Utrans U) \\<rho>) + trace \\<rho> -\n       trace (denote (Utrans U) \\<rho>)", "using qp' eq1 eq2 density_states_def"], ["proof (prove)\nusing this:\n  is_quantum_predicate (wlp (Utrans U) P)\n  ?\\<rho> \\<in> carrier_mat d d \\<Longrightarrow>\n  trace (adjoint U * P * U * ?\\<rho>) =\n  trace (P * (U * ?\\<rho> * adjoint U))\n  ?\\<rho> \\<in> carrier_mat d d \\<Longrightarrow>\n  trace (U * ?\\<rho> * adjoint U) = trace ?\\<rho>\n  density_states =\n  {\\<rho> \\<in> carrier_mat d d. partial_density_operator \\<rho>}\n\ngoal (1 subgoal):\n 1. \\<forall>\\<rho>\\<in>density_states.\n       trace (wlp (Utrans U) P * \\<rho>) =\n       trace (P * denote (Utrans U) \\<rho>) + trace \\<rho> -\n       trace (denote (Utrans U) \\<rho>)", "by auto"], ["proof (state)\nthis:\n  \\<forall>\\<rho>\\<in>density_states.\n     trace (wlp (Utrans U) P * \\<rho>) =\n     trace (P * denote (Utrans U) \\<rho>) + trace \\<rho> -\n     trace (denote (Utrans U) \\<rho>)\n\ngoal (3 subgoals):\n 1. \\<And>S1 S2 P.\n       \\<lbrakk>\\<And>P.\n                   \\<lbrakk>well_com S1; is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n  trace (wlp S1 P * \\<rho>) =\n  trace (P * denote S1 \\<rho>) + trace \\<rho> - trace (denote S1 \\<rho>);\n        \\<And>P.\n           \\<lbrakk>well_com S2; is_quantum_predicate P\\<rbrakk>\n           \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                                trace (wlp S2 P * \\<rho>) =\n                                trace (P * denote S2 \\<rho>) +\n                                trace \\<rho> -\n                                trace (denote S2 \\<rho>);\n        well_com (S1;; S2); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                            trace (wlp (S1;; S2) P * \\<rho>) =\n                            trace (P * denote (S1;; S2) \\<rho>) +\n                            trace \\<rho> -\n                            trace (denote (S1;; S2) \\<rho>)\n 2. \\<And>x1 x2a x3 P.\n       \\<lbrakk>\\<And>x3a P.\n                   \\<lbrakk>x3a \\<in> set x3; well_com x3a;\n                    is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n  trace (wlp x3a P * \\<rho>) =\n  trace (P * denote x3a \\<rho>) + trace \\<rho> - trace (denote x3a \\<rho>);\n        well_com (Measure x1 x2a x3); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                            trace (wlp (Measure x1 x2a x3) P * \\<rho>) =\n                            trace (P * denote (Measure x1 x2a x3) \\<rho>) +\n                            trace \\<rho> -\n                            trace (denote (Measure x1 x2a x3) \\<rho>)\n 3. \\<And>x1 S P.\n       \\<lbrakk>\\<And>P.\n                   \\<lbrakk>well_com S; is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n  trace (wlp S P * \\<rho>) =\n  trace (P * denote S \\<rho>) + trace \\<rho> - trace (denote S \\<rho>);\n        well_com (While x1 S); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                            trace (wlp (While x1 S) P * \\<rho>) =\n                            trace (P * denote (While x1 S) \\<rho>) +\n                            trace \\<rho> -\n                            trace (denote (While x1 S) \\<rho>)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>S1 S2 P.\n       \\<lbrakk>\\<And>P.\n                   \\<lbrakk>well_com S1; is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n  trace (wlp S1 P * \\<rho>) =\n  trace (P * denote S1 \\<rho>) + trace \\<rho> - trace (denote S1 \\<rho>);\n        \\<And>P.\n           \\<lbrakk>well_com S2; is_quantum_predicate P\\<rbrakk>\n           \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                                trace (wlp S2 P * \\<rho>) =\n                                trace (P * denote S2 \\<rho>) +\n                                trace \\<rho> -\n                                trace (denote S2 \\<rho>);\n        well_com (S1;; S2); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                            trace (wlp (S1;; S2) P * \\<rho>) =\n                            trace (P * denote (S1;; S2) \\<rho>) +\n                            trace \\<rho> -\n                            trace (denote (S1;; S2) \\<rho>)\n 2. \\<And>x1 x2a x3 P.\n       \\<lbrakk>\\<And>x3a P.\n                   \\<lbrakk>x3a \\<in> set x3; well_com x3a;\n                    is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n  trace (wlp x3a P * \\<rho>) =\n  trace (P * denote x3a \\<rho>) + trace \\<rho> - trace (denote x3a \\<rho>);\n        well_com (Measure x1 x2a x3); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                            trace (wlp (Measure x1 x2a x3) P * \\<rho>) =\n                            trace (P * denote (Measure x1 x2a x3) \\<rho>) +\n                            trace \\<rho> -\n                            trace (denote (Measure x1 x2a x3) \\<rho>)\n 3. \\<And>x1 S P.\n       \\<lbrakk>\\<And>P.\n                   \\<lbrakk>well_com S; is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n  trace (wlp S P * \\<rho>) =\n  trace (P * denote S \\<rho>) + trace \\<rho> - trace (denote S \\<rho>);\n        well_com (While x1 S); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                            trace (wlp (While x1 S) P * \\<rho>) =\n                            trace (P * denote (While x1 S) \\<rho>) +\n                            trace \\<rho> -\n                            trace (denote (While x1 S) \\<rho>)", "case (Seq S1 S2)"], ["proof (state)\nthis:\n  \\<lbrakk>well_com S1; is_quantum_predicate ?P\\<rbrakk>\n  \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                       trace (wlp S1 ?P * \\<rho>) =\n                       trace (?P * denote S1 \\<rho>) + trace \\<rho> -\n                       trace (denote S1 \\<rho>)\n  \\<lbrakk>well_com S2; is_quantum_predicate ?P\\<rbrakk>\n  \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                       trace (wlp S2 ?P * \\<rho>) =\n                       trace (?P * denote S2 \\<rho>) + trace \\<rho> -\n                       trace (denote S2 \\<rho>)\n  well_com (S1;; S2)\n  is_quantum_predicate P\n\ngoal (3 subgoals):\n 1. \\<And>S1 S2 P.\n       \\<lbrakk>\\<And>P.\n                   \\<lbrakk>well_com S1; is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n  trace (wlp S1 P * \\<rho>) =\n  trace (P * denote S1 \\<rho>) + trace \\<rho> - trace (denote S1 \\<rho>);\n        \\<And>P.\n           \\<lbrakk>well_com S2; is_quantum_predicate P\\<rbrakk>\n           \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                                trace (wlp S2 P * \\<rho>) =\n                                trace (P * denote S2 \\<rho>) +\n                                trace \\<rho> -\n                                trace (denote S2 \\<rho>);\n        well_com (S1;; S2); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                            trace (wlp (S1;; S2) P * \\<rho>) =\n                            trace (P * denote (S1;; S2) \\<rho>) +\n                            trace \\<rho> -\n                            trace (denote (S1;; S2) \\<rho>)\n 2. \\<And>x1 x2a x3 P.\n       \\<lbrakk>\\<And>x3a P.\n                   \\<lbrakk>x3a \\<in> set x3; well_com x3a;\n                    is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n  trace (wlp x3a P * \\<rho>) =\n  trace (P * denote x3a \\<rho>) + trace \\<rho> - trace (denote x3a \\<rho>);\n        well_com (Measure x1 x2a x3); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                            trace (wlp (Measure x1 x2a x3) P * \\<rho>) =\n                            trace (P * denote (Measure x1 x2a x3) \\<rho>) +\n                            trace \\<rho> -\n                            trace (denote (Measure x1 x2a x3) \\<rho>)\n 3. \\<And>x1 S P.\n       \\<lbrakk>\\<And>P.\n                   \\<lbrakk>well_com S; is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n  trace (wlp S P * \\<rho>) =\n  trace (P * denote S \\<rho>) + trace \\<rho> - trace (denote S \\<rho>);\n        well_com (While x1 S); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                            trace (wlp (While x1 S) P * \\<rho>) =\n                            trace (P * denote (While x1 S) \\<rho>) +\n                            trace \\<rho> -\n                            trace (denote (While x1 S) \\<rho>)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>well_com S1; is_quantum_predicate ?P\\<rbrakk>\n  \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                       trace (wlp S1 ?P * \\<rho>) =\n                       trace (?P * denote S1 \\<rho>) + trace \\<rho> -\n                       trace (denote S1 \\<rho>)\n  \\<lbrakk>well_com S2; is_quantum_predicate ?P\\<rbrakk>\n  \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                       trace (wlp S2 ?P * \\<rho>) =\n                       trace (?P * denote S2 \\<rho>) + trace \\<rho> -\n                       trace (denote S2 \\<rho>)\n  well_com (S1;; S2)\n  is_quantum_predicate P", "have qp: \"is_quantum_predicate P\" and wc1: \"well_com S1\" and wc2: \"well_com S2\""], ["proof (prove)\nusing this:\n  \\<lbrakk>well_com S1; is_quantum_predicate ?P\\<rbrakk>\n  \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                       trace (wlp S1 ?P * \\<rho>) =\n                       trace (?P * denote S1 \\<rho>) + trace \\<rho> -\n                       trace (denote S1 \\<rho>)\n  \\<lbrakk>well_com S2; is_quantum_predicate ?P\\<rbrakk>\n  \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                       trace (wlp S2 ?P * \\<rho>) =\n                       trace (?P * denote S2 \\<rho>) + trace \\<rho> -\n                       trace (denote S2 \\<rho>)\n  well_com (S1;; S2)\n  is_quantum_predicate P\n\ngoal (1 subgoal):\n 1. is_quantum_predicate P &&& well_com S1 &&& well_com S2", "by auto"], ["proof (state)\nthis:\n  is_quantum_predicate P\n  well_com S1\n  well_com S2\n\ngoal (3 subgoals):\n 1. \\<And>S1 S2 P.\n       \\<lbrakk>\\<And>P.\n                   \\<lbrakk>well_com S1; is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n  trace (wlp S1 P * \\<rho>) =\n  trace (P * denote S1 \\<rho>) + trace \\<rho> - trace (denote S1 \\<rho>);\n        \\<And>P.\n           \\<lbrakk>well_com S2; is_quantum_predicate P\\<rbrakk>\n           \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                                trace (wlp S2 P * \\<rho>) =\n                                trace (P * denote S2 \\<rho>) +\n                                trace \\<rho> -\n                                trace (denote S2 \\<rho>);\n        well_com (S1;; S2); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                            trace (wlp (S1;; S2) P * \\<rho>) =\n                            trace (P * denote (S1;; S2) \\<rho>) +\n                            trace \\<rho> -\n                            trace (denote (S1;; S2) \\<rho>)\n 2. \\<And>x1 x2a x3 P.\n       \\<lbrakk>\\<And>x3a P.\n                   \\<lbrakk>x3a \\<in> set x3; well_com x3a;\n                    is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n  trace (wlp x3a P * \\<rho>) =\n  trace (P * denote x3a \\<rho>) + trace \\<rho> - trace (denote x3a \\<rho>);\n        well_com (Measure x1 x2a x3); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                            trace (wlp (Measure x1 x2a x3) P * \\<rho>) =\n                            trace (P * denote (Measure x1 x2a x3) \\<rho>) +\n                            trace \\<rho> -\n                            trace (denote (Measure x1 x2a x3) \\<rho>)\n 3. \\<And>x1 S P.\n       \\<lbrakk>\\<And>P.\n                   \\<lbrakk>well_com S; is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n  trace (wlp S P * \\<rho>) =\n  trace (P * denote S \\<rho>) + trace \\<rho> - trace (denote S \\<rho>);\n        well_com (While x1 S); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                            trace (wlp (While x1 S) P * \\<rho>) =\n                            trace (P * denote (While x1 S) \\<rho>) +\n                            trace \\<rho> -\n                            trace (denote (While x1 S) \\<rho>)", "then"], ["proof (chain)\npicking this:\n  is_quantum_predicate P\n  well_com S1\n  well_com S2", "have qp2: \"is_quantum_predicate (wlp S2 P)\""], ["proof (prove)\nusing this:\n  is_quantum_predicate P\n  well_com S1\n  well_com S2\n\ngoal (1 subgoal):\n 1. is_quantum_predicate (wlp S2 P)", "using wlp_close"], ["proof (prove)\nusing this:\n  is_quantum_predicate P\n  well_com S1\n  well_com S2\n  \\<lbrakk>well_com ?S; is_quantum_predicate ?P\\<rbrakk>\n  \\<Longrightarrow> is_quantum_predicate (wlp ?S ?P)\n\ngoal (1 subgoal):\n 1. is_quantum_predicate (wlp S2 P)", "by auto"], ["proof (state)\nthis:\n  is_quantum_predicate (wlp S2 P)\n\ngoal (3 subgoals):\n 1. \\<And>S1 S2 P.\n       \\<lbrakk>\\<And>P.\n                   \\<lbrakk>well_com S1; is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n  trace (wlp S1 P * \\<rho>) =\n  trace (P * denote S1 \\<rho>) + trace \\<rho> - trace (denote S1 \\<rho>);\n        \\<And>P.\n           \\<lbrakk>well_com S2; is_quantum_predicate P\\<rbrakk>\n           \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                                trace (wlp S2 P * \\<rho>) =\n                                trace (P * denote S2 \\<rho>) +\n                                trace \\<rho> -\n                                trace (denote S2 \\<rho>);\n        well_com (S1;; S2); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                            trace (wlp (S1;; S2) P * \\<rho>) =\n                            trace (P * denote (S1;; S2) \\<rho>) +\n                            trace \\<rho> -\n                            trace (denote (S1;; S2) \\<rho>)\n 2. \\<And>x1 x2a x3 P.\n       \\<lbrakk>\\<And>x3a P.\n                   \\<lbrakk>x3a \\<in> set x3; well_com x3a;\n                    is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n  trace (wlp x3a P * \\<rho>) =\n  trace (P * denote x3a \\<rho>) + trace \\<rho> - trace (denote x3a \\<rho>);\n        well_com (Measure x1 x2a x3); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                            trace (wlp (Measure x1 x2a x3) P * \\<rho>) =\n                            trace (P * denote (Measure x1 x2a x3) \\<rho>) +\n                            trace \\<rho> -\n                            trace (denote (Measure x1 x2a x3) \\<rho>)\n 3. \\<And>x1 S P.\n       \\<lbrakk>\\<And>P.\n                   \\<lbrakk>well_com S; is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n  trace (wlp S P * \\<rho>) =\n  trace (P * denote S \\<rho>) + trace \\<rho> - trace (denote S \\<rho>);\n        well_com (While x1 S); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                            trace (wlp (While x1 S) P * \\<rho>) =\n                            trace (P * denote (While x1 S) \\<rho>) +\n                            trace \\<rho> -\n                            trace (denote (While x1 S) \\<rho>)", "then"], ["proof (chain)\npicking this:\n  is_quantum_predicate (wlp S2 P)", "have qp1: \"is_quantum_predicate (wlp S1 (wlp S2 P))\""], ["proof (prove)\nusing this:\n  is_quantum_predicate (wlp S2 P)\n\ngoal (1 subgoal):\n 1. is_quantum_predicate (wlp S1 (wlp S2 P))", "using wlp_close wc1"], ["proof (prove)\nusing this:\n  is_quantum_predicate (wlp S2 P)\n  \\<lbrakk>well_com ?S; is_quantum_predicate ?P\\<rbrakk>\n  \\<Longrightarrow> is_quantum_predicate (wlp ?S ?P)\n  well_com S1\n\ngoal (1 subgoal):\n 1. is_quantum_predicate (wlp S1 (wlp S2 P))", "by auto"], ["proof (state)\nthis:\n  is_quantum_predicate (wlp S1 (wlp S2 P))\n\ngoal (3 subgoals):\n 1. \\<And>S1 S2 P.\n       \\<lbrakk>\\<And>P.\n                   \\<lbrakk>well_com S1; is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n  trace (wlp S1 P * \\<rho>) =\n  trace (P * denote S1 \\<rho>) + trace \\<rho> - trace (denote S1 \\<rho>);\n        \\<And>P.\n           \\<lbrakk>well_com S2; is_quantum_predicate P\\<rbrakk>\n           \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                                trace (wlp S2 P * \\<rho>) =\n                                trace (P * denote S2 \\<rho>) +\n                                trace \\<rho> -\n                                trace (denote S2 \\<rho>);\n        well_com (S1;; S2); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                            trace (wlp (S1;; S2) P * \\<rho>) =\n                            trace (P * denote (S1;; S2) \\<rho>) +\n                            trace \\<rho> -\n                            trace (denote (S1;; S2) \\<rho>)\n 2. \\<And>x1 x2a x3 P.\n       \\<lbrakk>\\<And>x3a P.\n                   \\<lbrakk>x3a \\<in> set x3; well_com x3a;\n                    is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n  trace (wlp x3a P * \\<rho>) =\n  trace (P * denote x3a \\<rho>) + trace \\<rho> - trace (denote x3a \\<rho>);\n        well_com (Measure x1 x2a x3); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                            trace (wlp (Measure x1 x2a x3) P * \\<rho>) =\n                            trace (P * denote (Measure x1 x2a x3) \\<rho>) +\n                            trace \\<rho> -\n                            trace (denote (Measure x1 x2a x3) \\<rho>)\n 3. \\<And>x1 S P.\n       \\<lbrakk>\\<And>P.\n                   \\<lbrakk>well_com S; is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n  trace (wlp S P * \\<rho>) =\n  trace (P * denote S \\<rho>) + trace \\<rho> - trace (denote S \\<rho>);\n        well_com (While x1 S); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                            trace (wlp (While x1 S) P * \\<rho>) =\n                            trace (P * denote (While x1 S) \\<rho>) +\n                            trace \\<rho> -\n                            trace (denote (While x1 S) \\<rho>)", "have eq1: \"trace (wlp S2 P * \\<rho>) = trace (P * denote S2 \\<rho>) + trace \\<rho> - trace (denote S2 \\<rho>)\" \n    if ds: \"\\<rho> \\<in> density_states\" for \\<rho>"], ["proof (prove)\ngoal (1 subgoal):\n 1. trace (wlp S2 P * \\<rho>) =\n    trace (P * denote S2 \\<rho>) + trace \\<rho> - trace (denote S2 \\<rho>)", "using Seq(2) wc2 qp ds"], ["proof (prove)\nusing this:\n  \\<lbrakk>well_com S2; is_quantum_predicate ?P\\<rbrakk>\n  \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                       trace (wlp S2 ?P * \\<rho>) =\n                       trace (?P * denote S2 \\<rho>) + trace \\<rho> -\n                       trace (denote S2 \\<rho>)\n  well_com S2\n  is_quantum_predicate P\n  \\<rho> \\<in> density_states\n\ngoal (1 subgoal):\n 1. trace (wlp S2 P * \\<rho>) =\n    trace (P * denote S2 \\<rho>) + trace \\<rho> - trace (denote S2 \\<rho>)", "by auto"], ["proof (state)\nthis:\n  ?\\<rho> \\<in> density_states \\<Longrightarrow>\n  trace (wlp S2 P * ?\\<rho>) =\n  trace (P * denote S2 ?\\<rho>) + trace ?\\<rho> - trace (denote S2 ?\\<rho>)\n\ngoal (3 subgoals):\n 1. \\<And>S1 S2 P.\n       \\<lbrakk>\\<And>P.\n                   \\<lbrakk>well_com S1; is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n  trace (wlp S1 P * \\<rho>) =\n  trace (P * denote S1 \\<rho>) + trace \\<rho> - trace (denote S1 \\<rho>);\n        \\<And>P.\n           \\<lbrakk>well_com S2; is_quantum_predicate P\\<rbrakk>\n           \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                                trace (wlp S2 P * \\<rho>) =\n                                trace (P * denote S2 \\<rho>) +\n                                trace \\<rho> -\n                                trace (denote S2 \\<rho>);\n        well_com (S1;; S2); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                            trace (wlp (S1;; S2) P * \\<rho>) =\n                            trace (P * denote (S1;; S2) \\<rho>) +\n                            trace \\<rho> -\n                            trace (denote (S1;; S2) \\<rho>)\n 2. \\<And>x1 x2a x3 P.\n       \\<lbrakk>\\<And>x3a P.\n                   \\<lbrakk>x3a \\<in> set x3; well_com x3a;\n                    is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n  trace (wlp x3a P * \\<rho>) =\n  trace (P * denote x3a \\<rho>) + trace \\<rho> - trace (denote x3a \\<rho>);\n        well_com (Measure x1 x2a x3); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                            trace (wlp (Measure x1 x2a x3) P * \\<rho>) =\n                            trace (P * denote (Measure x1 x2a x3) \\<rho>) +\n                            trace \\<rho> -\n                            trace (denote (Measure x1 x2a x3) \\<rho>)\n 3. \\<And>x1 S P.\n       \\<lbrakk>\\<And>P.\n                   \\<lbrakk>well_com S; is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n  trace (wlp S P * \\<rho>) =\n  trace (P * denote S \\<rho>) + trace \\<rho> - trace (denote S \\<rho>);\n        well_com (While x1 S); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                            trace (wlp (While x1 S) P * \\<rho>) =\n                            trace (P * denote (While x1 S) \\<rho>) +\n                            trace \\<rho> -\n                            trace (denote (While x1 S) \\<rho>)", "have eq2: \"trace (wlp S1 (wlp S2 P) * \\<rho>) = trace ((wlp S2 P) * denote S1 \\<rho>) + trace \\<rho> - trace (denote S1 \\<rho>)\" \n    if ds: \"\\<rho> \\<in> density_states\" for \\<rho>"], ["proof (prove)\ngoal (1 subgoal):\n 1. trace (wlp S1 (wlp S2 P) * \\<rho>) =\n    trace (wlp S2 P * denote S1 \\<rho>) + trace \\<rho> -\n    trace (denote S1 \\<rho>)", "using Seq(1) wc1 qp2 ds"], ["proof (prove)\nusing this:\n  \\<lbrakk>well_com S1; is_quantum_predicate ?P\\<rbrakk>\n  \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                       trace (wlp S1 ?P * \\<rho>) =\n                       trace (?P * denote S1 \\<rho>) + trace \\<rho> -\n                       trace (denote S1 \\<rho>)\n  well_com S1\n  is_quantum_predicate (wlp S2 P)\n  \\<rho> \\<in> density_states\n\ngoal (1 subgoal):\n 1. trace (wlp S1 (wlp S2 P) * \\<rho>) =\n    trace (wlp S2 P * denote S1 \\<rho>) + trace \\<rho> -\n    trace (denote S1 \\<rho>)", "by auto"], ["proof (state)\nthis:\n  ?\\<rho> \\<in> density_states \\<Longrightarrow>\n  trace (wlp S1 (wlp S2 P) * ?\\<rho>) =\n  trace (wlp S2 P * denote S1 ?\\<rho>) + trace ?\\<rho> -\n  trace (denote S1 ?\\<rho>)\n\ngoal (3 subgoals):\n 1. \\<And>S1 S2 P.\n       \\<lbrakk>\\<And>P.\n                   \\<lbrakk>well_com S1; is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n  trace (wlp S1 P * \\<rho>) =\n  trace (P * denote S1 \\<rho>) + trace \\<rho> - trace (denote S1 \\<rho>);\n        \\<And>P.\n           \\<lbrakk>well_com S2; is_quantum_predicate P\\<rbrakk>\n           \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                                trace (wlp S2 P * \\<rho>) =\n                                trace (P * denote S2 \\<rho>) +\n                                trace \\<rho> -\n                                trace (denote S2 \\<rho>);\n        well_com (S1;; S2); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                            trace (wlp (S1;; S2) P * \\<rho>) =\n                            trace (P * denote (S1;; S2) \\<rho>) +\n                            trace \\<rho> -\n                            trace (denote (S1;; S2) \\<rho>)\n 2. \\<And>x1 x2a x3 P.\n       \\<lbrakk>\\<And>x3a P.\n                   \\<lbrakk>x3a \\<in> set x3; well_com x3a;\n                    is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n  trace (wlp x3a P * \\<rho>) =\n  trace (P * denote x3a \\<rho>) + trace \\<rho> - trace (denote x3a \\<rho>);\n        well_com (Measure x1 x2a x3); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                            trace (wlp (Measure x1 x2a x3) P * \\<rho>) =\n                            trace (P * denote (Measure x1 x2a x3) \\<rho>) +\n                            trace \\<rho> -\n                            trace (denote (Measure x1 x2a x3) \\<rho>)\n 3. \\<And>x1 S P.\n       \\<lbrakk>\\<And>P.\n                   \\<lbrakk>well_com S; is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n  trace (wlp S P * \\<rho>) =\n  trace (P * denote S \\<rho>) + trace \\<rho> - trace (denote S \\<rho>);\n        well_com (While x1 S); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                            trace (wlp (While x1 S) P * \\<rho>) =\n                            trace (P * denote (While x1 S) \\<rho>) +\n                            trace \\<rho> -\n                            trace (denote (While x1 S) \\<rho>)", "have eq3: \"trace (wlp S1 (wlp S2 P) * \\<rho>) = trace (P * (denote S2 (denote S1 \\<rho>))) + trace \\<rho> - trace (denote S2 (denote S1 \\<rho>))\" \n    if ds: \"\\<rho> \\<in> density_states\" for \\<rho>"], ["proof (prove)\ngoal (1 subgoal):\n 1. trace (wlp S1 (wlp S2 P) * \\<rho>) =\n    trace (P * denote S2 (denote S1 \\<rho>)) + trace \\<rho> -\n    trace (denote S2 (denote S1 \\<rho>))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. trace (wlp S1 (wlp S2 P) * \\<rho>) =\n    trace (P * denote S2 (denote S1 \\<rho>)) + trace \\<rho> -\n    trace (denote S2 (denote S1 \\<rho>))", "have \"denote S1 \\<rho> \\<in> density_states\""], ["proof (prove)\ngoal (1 subgoal):\n 1. denote S1 \\<rho> \\<in> density_states", "using ds denote_density_states wc1"], ["proof (prove)\nusing this:\n  \\<rho> \\<in> density_states\n  \\<lbrakk>?\\<rho> \\<in> density_states; well_com ?S\\<rbrakk>\n  \\<Longrightarrow> denote ?S ?\\<rho> \\<in> density_states\n  well_com S1\n\ngoal (1 subgoal):\n 1. denote S1 \\<rho> \\<in> density_states", "by auto"], ["proof (state)\nthis:\n  denote S1 \\<rho> \\<in> density_states\n\ngoal (1 subgoal):\n 1. trace (wlp S1 (wlp S2 P) * \\<rho>) =\n    trace (P * denote S2 (denote S1 \\<rho>)) + trace \\<rho> -\n    trace (denote S2 (denote S1 \\<rho>))", "then"], ["proof (chain)\npicking this:\n  denote S1 \\<rho> \\<in> density_states", "have  \"trace ((wlp S2 P) * denote S1 \\<rho>) = trace (P * denote S2 (denote S1 \\<rho>)) + trace (denote S1 \\<rho>) - trace (denote S2 (denote S1 \\<rho>))\""], ["proof (prove)\nusing this:\n  denote S1 \\<rho> \\<in> density_states\n\ngoal (1 subgoal):\n 1. trace (wlp S2 P * denote S1 \\<rho>) =\n    trace (P * denote S2 (denote S1 \\<rho>)) + trace (denote S1 \\<rho>) -\n    trace (denote S2 (denote S1 \\<rho>))", "using eq1"], ["proof (prove)\nusing this:\n  denote S1 \\<rho> \\<in> density_states\n  ?\\<rho> \\<in> density_states \\<Longrightarrow>\n  trace (wlp S2 P * ?\\<rho>) =\n  trace (P * denote S2 ?\\<rho>) + trace ?\\<rho> - trace (denote S2 ?\\<rho>)\n\ngoal (1 subgoal):\n 1. trace (wlp S2 P * denote S1 \\<rho>) =\n    trace (P * denote S2 (denote S1 \\<rho>)) + trace (denote S1 \\<rho>) -\n    trace (denote S2 (denote S1 \\<rho>))", "by auto"], ["proof (state)\nthis:\n  trace (wlp S2 P * denote S1 \\<rho>) =\n  trace (P * denote S2 (denote S1 \\<rho>)) + trace (denote S1 \\<rho>) -\n  trace (denote S2 (denote S1 \\<rho>))\n\ngoal (1 subgoal):\n 1. trace (wlp S1 (wlp S2 P) * \\<rho>) =\n    trace (P * denote S2 (denote S1 \\<rho>)) + trace \\<rho> -\n    trace (denote S2 (denote S1 \\<rho>))", "then"], ["proof (chain)\npicking this:\n  trace (wlp S2 P * denote S1 \\<rho>) =\n  trace (P * denote S2 (denote S1 \\<rho>)) + trace (denote S1 \\<rho>) -\n  trace (denote S2 (denote S1 \\<rho>))", "show \"trace (wlp S1 (wlp S2 P) * \\<rho>) = trace (P * (denote S2 (denote S1 \\<rho>))) + trace \\<rho> - trace (denote S2 (denote S1 \\<rho>))\""], ["proof (prove)\nusing this:\n  trace (wlp S2 P * denote S1 \\<rho>) =\n  trace (P * denote S2 (denote S1 \\<rho>)) + trace (denote S1 \\<rho>) -\n  trace (denote S2 (denote S1 \\<rho>))\n\ngoal (1 subgoal):\n 1. trace (wlp S1 (wlp S2 P) * \\<rho>) =\n    trace (P * denote S2 (denote S1 \\<rho>)) + trace \\<rho> -\n    trace (denote S2 (denote S1 \\<rho>))", "using eq2 ds"], ["proof (prove)\nusing this:\n  trace (wlp S2 P * denote S1 \\<rho>) =\n  trace (P * denote S2 (denote S1 \\<rho>)) + trace (denote S1 \\<rho>) -\n  trace (denote S2 (denote S1 \\<rho>))\n  ?\\<rho> \\<in> density_states \\<Longrightarrow>\n  trace (wlp S1 (wlp S2 P) * ?\\<rho>) =\n  trace (wlp S2 P * denote S1 ?\\<rho>) + trace ?\\<rho> -\n  trace (denote S1 ?\\<rho>)\n  \\<rho> \\<in> density_states\n\ngoal (1 subgoal):\n 1. trace (wlp S1 (wlp S2 P) * \\<rho>) =\n    trace (P * denote S2 (denote S1 \\<rho>)) + trace \\<rho> -\n    trace (denote S2 (denote S1 \\<rho>))", "by auto"], ["proof (state)\nthis:\n  trace (wlp S1 (wlp S2 P) * \\<rho>) =\n  trace (P * denote S2 (denote S1 \\<rho>)) + trace \\<rho> -\n  trace (denote S2 (denote S1 \\<rho>))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?\\<rho> \\<in> density_states \\<Longrightarrow>\n  trace (wlp S1 (wlp S2 P) * ?\\<rho>) =\n  trace (P * denote S2 (denote S1 ?\\<rho>)) + trace ?\\<rho> -\n  trace (denote S2 (denote S1 ?\\<rho>))\n\ngoal (3 subgoals):\n 1. \\<And>S1 S2 P.\n       \\<lbrakk>\\<And>P.\n                   \\<lbrakk>well_com S1; is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n  trace (wlp S1 P * \\<rho>) =\n  trace (P * denote S1 \\<rho>) + trace \\<rho> - trace (denote S1 \\<rho>);\n        \\<And>P.\n           \\<lbrakk>well_com S2; is_quantum_predicate P\\<rbrakk>\n           \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                                trace (wlp S2 P * \\<rho>) =\n                                trace (P * denote S2 \\<rho>) +\n                                trace \\<rho> -\n                                trace (denote S2 \\<rho>);\n        well_com (S1;; S2); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                            trace (wlp (S1;; S2) P * \\<rho>) =\n                            trace (P * denote (S1;; S2) \\<rho>) +\n                            trace \\<rho> -\n                            trace (denote (S1;; S2) \\<rho>)\n 2. \\<And>x1 x2a x3 P.\n       \\<lbrakk>\\<And>x3a P.\n                   \\<lbrakk>x3a \\<in> set x3; well_com x3a;\n                    is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n  trace (wlp x3a P * \\<rho>) =\n  trace (P * denote x3a \\<rho>) + trace \\<rho> - trace (denote x3a \\<rho>);\n        well_com (Measure x1 x2a x3); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                            trace (wlp (Measure x1 x2a x3) P * \\<rho>) =\n                            trace (P * denote (Measure x1 x2a x3) \\<rho>) +\n                            trace \\<rho> -\n                            trace (denote (Measure x1 x2a x3) \\<rho>)\n 3. \\<And>x1 S P.\n       \\<lbrakk>\\<And>P.\n                   \\<lbrakk>well_com S; is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n  trace (wlp S P * \\<rho>) =\n  trace (P * denote S \\<rho>) + trace \\<rho> - trace (denote S \\<rho>);\n        well_com (While x1 S); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                            trace (wlp (While x1 S) P * \\<rho>) =\n                            trace (P * denote (While x1 S) \\<rho>) +\n                            trace \\<rho> -\n                            trace (denote (While x1 S) \\<rho>)", "then"], ["proof (chain)\npicking this:\n  ?\\<rho> \\<in> density_states \\<Longrightarrow>\n  trace (wlp S1 (wlp S2 P) * ?\\<rho>) =\n  trace (P * denote S2 (denote S1 ?\\<rho>)) + trace ?\\<rho> -\n  trace (denote S2 (denote S1 ?\\<rho>))", "show ?case"], ["proof (prove)\nusing this:\n  ?\\<rho> \\<in> density_states \\<Longrightarrow>\n  trace (wlp S1 (wlp S2 P) * ?\\<rho>) =\n  trace (P * denote S2 (denote S1 ?\\<rho>)) + trace ?\\<rho> -\n  trace (denote S2 (denote S1 ?\\<rho>))\n\ngoal (1 subgoal):\n 1. \\<forall>\\<rho>\\<in>density_states.\n       trace (wlp (S1;; S2) P * \\<rho>) =\n       trace (P * denote (S1;; S2) \\<rho>) + trace \\<rho> -\n       trace (denote (S1;; S2) \\<rho>)", "using qp1"], ["proof (prove)\nusing this:\n  ?\\<rho> \\<in> density_states \\<Longrightarrow>\n  trace (wlp S1 (wlp S2 P) * ?\\<rho>) =\n  trace (P * denote S2 (denote S1 ?\\<rho>)) + trace ?\\<rho> -\n  trace (denote S2 (denote S1 ?\\<rho>))\n  is_quantum_predicate (wlp S1 (wlp S2 P))\n\ngoal (1 subgoal):\n 1. \\<forall>\\<rho>\\<in>density_states.\n       trace (wlp (S1;; S2) P * \\<rho>) =\n       trace (P * denote (S1;; S2) \\<rho>) + trace \\<rho> -\n       trace (denote (S1;; S2) \\<rho>)", "by auto"], ["proof (state)\nthis:\n  \\<forall>\\<rho>\\<in>density_states.\n     trace (wlp (S1;; S2) P * \\<rho>) =\n     trace (P * denote (S1;; S2) \\<rho>) + trace \\<rho> -\n     trace (denote (S1;; S2) \\<rho>)\n\ngoal (2 subgoals):\n 1. \\<And>x1 x2a x3 P.\n       \\<lbrakk>\\<And>x3a P.\n                   \\<lbrakk>x3a \\<in> set x3; well_com x3a;\n                    is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n  trace (wlp x3a P * \\<rho>) =\n  trace (P * denote x3a \\<rho>) + trace \\<rho> - trace (denote x3a \\<rho>);\n        well_com (Measure x1 x2a x3); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                            trace (wlp (Measure x1 x2a x3) P * \\<rho>) =\n                            trace (P * denote (Measure x1 x2a x3) \\<rho>) +\n                            trace \\<rho> -\n                            trace (denote (Measure x1 x2a x3) \\<rho>)\n 2. \\<And>x1 S P.\n       \\<lbrakk>\\<And>P.\n                   \\<lbrakk>well_com S; is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n  trace (wlp S P * \\<rho>) =\n  trace (P * denote S \\<rho>) + trace \\<rho> - trace (denote S \\<rho>);\n        well_com (While x1 S); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                            trace (wlp (While x1 S) P * \\<rho>) =\n                            trace (P * denote (While x1 S) \\<rho>) +\n                            trace \\<rho> -\n                            trace (denote (While x1 S) \\<rho>)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1 x2a x3 P.\n       \\<lbrakk>\\<And>x3a P.\n                   \\<lbrakk>x3a \\<in> set x3; well_com x3a;\n                    is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n  trace (wlp x3a P * \\<rho>) =\n  trace (P * denote x3a \\<rho>) + trace \\<rho> - trace (denote x3a \\<rho>);\n        well_com (Measure x1 x2a x3); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                            trace (wlp (Measure x1 x2a x3) P * \\<rho>) =\n                            trace (P * denote (Measure x1 x2a x3) \\<rho>) +\n                            trace \\<rho> -\n                            trace (denote (Measure x1 x2a x3) \\<rho>)\n 2. \\<And>x1 S P.\n       \\<lbrakk>\\<And>P.\n                   \\<lbrakk>well_com S; is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n  trace (wlp S P * \\<rho>) =\n  trace (P * denote S \\<rho>) + trace \\<rho> - trace (denote S \\<rho>);\n        well_com (While x1 S); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                            trace (wlp (While x1 S) P * \\<rho>) =\n                            trace (P * denote (While x1 S) \\<rho>) +\n                            trace \\<rho> -\n                            trace (denote (While x1 S) \\<rho>)", "case (Measure n M S)"], ["proof (state)\nthis:\n  \\<lbrakk>?x3a \\<in> set S; well_com ?x3a; is_quantum_predicate ?P\\<rbrakk>\n  \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                       trace (wlp ?x3a ?P * \\<rho>) =\n                       trace (?P * denote ?x3a \\<rho>) + trace \\<rho> -\n                       trace (denote ?x3a \\<rho>)\n  well_com (Measure n M S)\n  is_quantum_predicate P\n\ngoal (2 subgoals):\n 1. \\<And>x1 x2a x3 P.\n       \\<lbrakk>\\<And>x3a P.\n                   \\<lbrakk>x3a \\<in> set x3; well_com x3a;\n                    is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n  trace (wlp x3a P * \\<rho>) =\n  trace (P * denote x3a \\<rho>) + trace \\<rho> - trace (denote x3a \\<rho>);\n        well_com (Measure x1 x2a x3); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                            trace (wlp (Measure x1 x2a x3) P * \\<rho>) =\n                            trace (P * denote (Measure x1 x2a x3) \\<rho>) +\n                            trace \\<rho> -\n                            trace (denote (Measure x1 x2a x3) \\<rho>)\n 2. \\<And>x1 S P.\n       \\<lbrakk>\\<And>P.\n                   \\<lbrakk>well_com S; is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n  trace (wlp S P * \\<rho>) =\n  trace (P * denote S \\<rho>) + trace \\<rho> - trace (denote S \\<rho>);\n        well_com (While x1 S); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                            trace (wlp (While x1 S) P * \\<rho>) =\n                            trace (P * denote (While x1 S) \\<rho>) +\n                            trace \\<rho> -\n                            trace (denote (While x1 S) \\<rho>)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>?x3a \\<in> set S; well_com ?x3a; is_quantum_predicate ?P\\<rbrakk>\n  \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                       trace (wlp ?x3a ?P * \\<rho>) =\n                       trace (?P * denote ?x3a \\<rho>) + trace \\<rho> -\n                       trace (denote ?x3a \\<rho>)\n  well_com (Measure n M S)\n  is_quantum_predicate P", "have wc: \"well_com (Measure n M S)\"\n    and wck: \"k < n \\<Longrightarrow> well_com (S!k)\"\n    and qpP: \"is_quantum_predicate P\"\n    and dP: \"P \\<in> carrier_mat d d\"\n    and qpWk: \"k < n \\<Longrightarrow> is_quantum_predicate (wlp (S!k) P)\"\n    and dWk: \"k < n \\<Longrightarrow> (wlp (S!k) P) \\<in> carrier_mat d d\"\n    and c: \"k < n \\<Longrightarrow> \\<rho> \\<in> density_states \\<Longrightarrow> trace (wlp (S!k) P * \\<rho>) = trace (P * denote (S!k) \\<rho>) + trace \\<rho> - trace (denote (S!k) \\<rho>)\" \n    and m: \"measurement d n M\"\n    and aMMkleq: \"k < n \\<Longrightarrow> adjoint (M k) * M k \\<le>\\<^sub>L 1\\<^sub>m d\"\n    and dMk: \"k < n \\<Longrightarrow> M k \\<in> carrier_mat d d\"\n    for k \\<rho>"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x3a \\<in> set S; well_com ?x3a; is_quantum_predicate ?P\\<rbrakk>\n  \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                       trace (wlp ?x3a ?P * \\<rho>) =\n                       trace (?P * denote ?x3a \\<rho>) + trace \\<rho> -\n                       trace (denote ?x3a \\<rho>)\n  well_com (Measure n M S)\n  is_quantum_predicate P\n\ngoal (1 subgoal):\n 1. ((well_com (Measure n M S) &&&\n      (k < n \\<Longrightarrow> well_com (S ! k))) &&&\n     is_quantum_predicate P &&&\n     P \\<in> carrier_mat d d &&&\n     (k < n \\<Longrightarrow> is_quantum_predicate (wlp (S ! k) P))) &&&\n    ((k < n \\<Longrightarrow> wlp (S ! k) P \\<in> carrier_mat d d) &&&\n     (\\<lbrakk>k < n; \\<rho> \\<in> density_states\\<rbrakk>\n      \\<Longrightarrow> trace (wlp (S ! k) P * \\<rho>) =\n                        trace (P * denote (S ! k) \\<rho>) + trace \\<rho> -\n                        trace (denote (S ! k) \\<rho>))) &&&\n    measurement d n M &&&\n    (k < n \\<Longrightarrow>\n     adjoint (M k) * M k \\<le>\\<^sub>L 1\\<^sub>m d) &&&\n    (k < n \\<Longrightarrow> M k \\<in> carrier_mat d d)", "using is_quantum_predicate_def measurement_def measure_well_com measurement_le_one_mat wlp_close"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x3a \\<in> set S; well_com ?x3a; is_quantum_predicate ?P\\<rbrakk>\n  \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                       trace (wlp ?x3a ?P * \\<rho>) =\n                       trace (?P * denote ?x3a \\<rho>) + trace \\<rho> -\n                       trace (denote ?x3a \\<rho>)\n  well_com (Measure n M S)\n  is_quantum_predicate P\n  is_quantum_predicate ?P =\n  (?P \\<in> carrier_mat d d \\<and>\n   positive ?P \\<and> ?P \\<le>\\<^sub>L 1\\<^sub>m d)\n  measurement ?d ?n ?M =\n  ((\\<forall>j<?n. ?M j \\<in> carrier_mat ?d ?d) \\<and>\n   matrix_sum ?d (\\<lambda>j. adjoint (?M j) * ?M j) ?n = 1\\<^sub>m ?d)\n  \\<lbrakk>well_com (Measure ?n ?M ?S); ?k < ?n\\<rbrakk>\n  \\<Longrightarrow> well_com (?S ! ?k)\n  \\<lbrakk>measurement ?d ?n ?f; ?j < ?n\\<rbrakk>\n  \\<Longrightarrow> adjoint (?f ?j) * ?f ?j \\<le>\\<^sub>L 1\\<^sub>m ?d\n  \\<lbrakk>well_com ?S; is_quantum_predicate ?P\\<rbrakk>\n  \\<Longrightarrow> is_quantum_predicate (wlp ?S ?P)\n\ngoal (1 subgoal):\n 1. ((well_com (Measure n M S) &&&\n      (k < n \\<Longrightarrow> well_com (S ! k))) &&&\n     is_quantum_predicate P &&&\n     P \\<in> carrier_mat d d &&&\n     (k < n \\<Longrightarrow> is_quantum_predicate (wlp (S ! k) P))) &&&\n    ((k < n \\<Longrightarrow> wlp (S ! k) P \\<in> carrier_mat d d) &&&\n     (\\<lbrakk>k < n; \\<rho> \\<in> density_states\\<rbrakk>\n      \\<Longrightarrow> trace (wlp (S ! k) P * \\<rho>) =\n                        trace (P * denote (S ! k) \\<rho>) + trace \\<rho> -\n                        trace (denote (S ! k) \\<rho>))) &&&\n    measurement d n M &&&\n    (k < n \\<Longrightarrow>\n     adjoint (M k) * M k \\<le>\\<^sub>L 1\\<^sub>m d) &&&\n    (k < n \\<Longrightarrow> M k \\<in> carrier_mat d d)", "by auto"], ["proof (state)\nthis:\n  well_com (Measure n M S)\n  ?k < n \\<Longrightarrow> well_com (S ! ?k)\n  is_quantum_predicate P\n  P \\<in> carrier_mat d d\n  ?k < n \\<Longrightarrow> is_quantum_predicate (wlp (S ! ?k) P)\n  ?k < n \\<Longrightarrow> wlp (S ! ?k) P \\<in> carrier_mat d d\n  \\<lbrakk>?k < n; ?\\<rho> \\<in> density_states\\<rbrakk>\n  \\<Longrightarrow> trace (wlp (S ! ?k) P * ?\\<rho>) =\n                    trace (P * denote (S ! ?k) ?\\<rho>) + trace ?\\<rho> -\n                    trace (denote (S ! ?k) ?\\<rho>)\n  measurement d n M\n  ?k < n \\<Longrightarrow> adjoint (M ?k) * M ?k \\<le>\\<^sub>L 1\\<^sub>m d\n  ?k < n \\<Longrightarrow> M ?k \\<in> carrier_mat d d\n\ngoal (2 subgoals):\n 1. \\<And>x1 x2a x3 P.\n       \\<lbrakk>\\<And>x3a P.\n                   \\<lbrakk>x3a \\<in> set x3; well_com x3a;\n                    is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n  trace (wlp x3a P * \\<rho>) =\n  trace (P * denote x3a \\<rho>) + trace \\<rho> - trace (denote x3a \\<rho>);\n        well_com (Measure x1 x2a x3); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                            trace (wlp (Measure x1 x2a x3) P * \\<rho>) =\n                            trace (P * denote (Measure x1 x2a x3) \\<rho>) +\n                            trace \\<rho> -\n                            trace (denote (Measure x1 x2a x3) \\<rho>)\n 2. \\<And>x1 S P.\n       \\<lbrakk>\\<And>P.\n                   \\<lbrakk>well_com S; is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n  trace (wlp S P * \\<rho>) =\n  trace (P * denote S \\<rho>) + trace \\<rho> - trace (denote S \\<rho>);\n        well_com (While x1 S); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                            trace (wlp (While x1 S) P * \\<rho>) =\n                            trace (P * denote (While x1 S) \\<rho>) +\n                            trace \\<rho> -\n                            trace (denote (While x1 S) \\<rho>)", "{"], ["proof (state)\nthis:\n  well_com (Measure n M S)\n  ?k < n \\<Longrightarrow> well_com (S ! ?k)\n  is_quantum_predicate P\n  P \\<in> carrier_mat d d\n  ?k < n \\<Longrightarrow> is_quantum_predicate (wlp (S ! ?k) P)\n  ?k < n \\<Longrightarrow> wlp (S ! ?k) P \\<in> carrier_mat d d\n  \\<lbrakk>?k < n; ?\\<rho> \\<in> density_states\\<rbrakk>\n  \\<Longrightarrow> trace (wlp (S ! ?k) P * ?\\<rho>) =\n                    trace (P * denote (S ! ?k) ?\\<rho>) + trace ?\\<rho> -\n                    trace (denote (S ! ?k) ?\\<rho>)\n  measurement d n M\n  ?k < n \\<Longrightarrow> adjoint (M ?k) * M ?k \\<le>\\<^sub>L 1\\<^sub>m d\n  ?k < n \\<Longrightarrow> M ?k \\<in> carrier_mat d d\n\ngoal (2 subgoals):\n 1. \\<And>x1 x2a x3 P.\n       \\<lbrakk>\\<And>x3a P.\n                   \\<lbrakk>x3a \\<in> set x3; well_com x3a;\n                    is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n  trace (wlp x3a P * \\<rho>) =\n  trace (P * denote x3a \\<rho>) + trace \\<rho> - trace (denote x3a \\<rho>);\n        well_com (Measure x1 x2a x3); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                            trace (wlp (Measure x1 x2a x3) P * \\<rho>) =\n                            trace (P * denote (Measure x1 x2a x3) \\<rho>) +\n                            trace \\<rho> -\n                            trace (denote (Measure x1 x2a x3) \\<rho>)\n 2. \\<And>x1 S P.\n       \\<lbrakk>\\<And>P.\n                   \\<lbrakk>well_com S; is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n  trace (wlp S P * \\<rho>) =\n  trace (P * denote S \\<rho>) + trace \\<rho> - trace (denote S \\<rho>);\n        well_com (While x1 S); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                            trace (wlp (While x1 S) P * \\<rho>) =\n                            trace (P * denote (While x1 S) \\<rho>) +\n                            trace \\<rho> -\n                            trace (denote (While x1 S) \\<rho>)", "fix \\<rho>"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1 x2a x3 P.\n       \\<lbrakk>\\<And>x3a P.\n                   \\<lbrakk>x3a \\<in> set x3; well_com x3a;\n                    is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n  trace (wlp x3a P * \\<rho>) =\n  trace (P * denote x3a \\<rho>) + trace \\<rho> - trace (denote x3a \\<rho>);\n        well_com (Measure x1 x2a x3); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                            trace (wlp (Measure x1 x2a x3) P * \\<rho>) =\n                            trace (P * denote (Measure x1 x2a x3) \\<rho>) +\n                            trace \\<rho> -\n                            trace (denote (Measure x1 x2a x3) \\<rho>)\n 2. \\<And>x1 S P.\n       \\<lbrakk>\\<And>P.\n                   \\<lbrakk>well_com S; is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n  trace (wlp S P * \\<rho>) =\n  trace (P * denote S \\<rho>) + trace \\<rho> - trace (denote S \\<rho>);\n        well_com (While x1 S); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                            trace (wlp (While x1 S) P * \\<rho>) =\n                            trace (P * denote (While x1 S) \\<rho>) +\n                            trace \\<rho> -\n                            trace (denote (While x1 S) \\<rho>)", "assume \\<rho>: \"\\<rho> \\<in> density_states\""], ["proof (state)\nthis:\n  \\<rho> \\<in> density_states\n\ngoal (2 subgoals):\n 1. \\<And>x1 x2a x3 P.\n       \\<lbrakk>\\<And>x3a P.\n                   \\<lbrakk>x3a \\<in> set x3; well_com x3a;\n                    is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n  trace (wlp x3a P * \\<rho>) =\n  trace (P * denote x3a \\<rho>) + trace \\<rho> - trace (denote x3a \\<rho>);\n        well_com (Measure x1 x2a x3); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                            trace (wlp (Measure x1 x2a x3) P * \\<rho>) =\n                            trace (P * denote (Measure x1 x2a x3) \\<rho>) +\n                            trace \\<rho> -\n                            trace (denote (Measure x1 x2a x3) \\<rho>)\n 2. \\<And>x1 S P.\n       \\<lbrakk>\\<And>P.\n                   \\<lbrakk>well_com S; is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n  trace (wlp S P * \\<rho>) =\n  trace (P * denote S \\<rho>) + trace \\<rho> - trace (denote S \\<rho>);\n        well_com (While x1 S); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                            trace (wlp (While x1 S) P * \\<rho>) =\n                            trace (P * denote (While x1 S) \\<rho>) +\n                            trace \\<rho> -\n                            trace (denote (While x1 S) \\<rho>)", "then"], ["proof (chain)\npicking this:\n  \\<rho> \\<in> density_states", "have dr: \"\\<rho> \\<in> carrier_mat d d\" and pdor: \"partial_density_operator \\<rho>\""], ["proof (prove)\nusing this:\n  \\<rho> \\<in> density_states\n\ngoal (1 subgoal):\n 1. \\<rho> \\<in> carrier_mat d d &&& partial_density_operator \\<rho>", "using density_states_def"], ["proof (prove)\nusing this:\n  \\<rho> \\<in> density_states\n  density_states =\n  {\\<rho> \\<in> carrier_mat d d. partial_density_operator \\<rho>}\n\ngoal (1 subgoal):\n 1. \\<rho> \\<in> carrier_mat d d &&& partial_density_operator \\<rho>", "by auto"], ["proof (state)\nthis:\n  \\<rho> \\<in> carrier_mat d d\n  partial_density_operator \\<rho>\n\ngoal (2 subgoals):\n 1. \\<And>x1 x2a x3 P.\n       \\<lbrakk>\\<And>x3a P.\n                   \\<lbrakk>x3a \\<in> set x3; well_com x3a;\n                    is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n  trace (wlp x3a P * \\<rho>) =\n  trace (P * denote x3a \\<rho>) + trace \\<rho> - trace (denote x3a \\<rho>);\n        well_com (Measure x1 x2a x3); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                            trace (wlp (Measure x1 x2a x3) P * \\<rho>) =\n                            trace (P * denote (Measure x1 x2a x3) \\<rho>) +\n                            trace \\<rho> -\n                            trace (denote (Measure x1 x2a x3) \\<rho>)\n 2. \\<And>x1 S P.\n       \\<lbrakk>\\<And>P.\n                   \\<lbrakk>well_com S; is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n  trace (wlp S P * \\<rho>) =\n  trace (P * denote S \\<rho>) + trace \\<rho> - trace (denote S \\<rho>);\n        well_com (While x1 S); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                            trace (wlp (While x1 S) P * \\<rho>) =\n                            trace (P * denote (While x1 S) \\<rho>) +\n                            trace \\<rho> -\n                            trace (denote (While x1 S) \\<rho>)", "have dsr: \"k < n \\<Longrightarrow> (M k) * \\<rho> * adjoint (M k) \\<in> density_states\" for k"], ["proof (prove)\ngoal (1 subgoal):\n 1. k < n \\<Longrightarrow>\n    M k * \\<rho> * adjoint (M k) \\<in> density_states", "unfolding density_states_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. k < n \\<Longrightarrow>\n    M k * \\<rho> * adjoint (M k)\n    \\<in> {\\<rho> \\<in> carrier_mat d d. partial_density_operator \\<rho>}", "using dMk pdo_close_under_measurement[OF dMk dr pdor aMMkleq] dr"], ["proof (prove)\nusing this:\n  ?k < n \\<Longrightarrow> M ?k \\<in> carrier_mat d d\n  \\<lbrakk>?k1 < n; ?k1 < n\\<rbrakk>\n  \\<Longrightarrow> partial_density_operator\n                     (M ?k1 * \\<rho> * adjoint (M ?k1))\n  \\<rho> \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. k < n \\<Longrightarrow>\n    M k * \\<rho> * adjoint (M k)\n    \\<in> {\\<rho> \\<in> carrier_mat d d. partial_density_operator \\<rho>}", "by fastforce"], ["proof (state)\nthis:\n  ?k < n \\<Longrightarrow>\n  M ?k * \\<rho> * adjoint (M ?k) \\<in> density_states\n\ngoal (2 subgoals):\n 1. \\<And>x1 x2a x3 P.\n       \\<lbrakk>\\<And>x3a P.\n                   \\<lbrakk>x3a \\<in> set x3; well_com x3a;\n                    is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n  trace (wlp x3a P * \\<rho>) =\n  trace (P * denote x3a \\<rho>) + trace \\<rho> - trace (denote x3a \\<rho>);\n        well_com (Measure x1 x2a x3); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                            trace (wlp (Measure x1 x2a x3) P * \\<rho>) =\n                            trace (P * denote (Measure x1 x2a x3) \\<rho>) +\n                            trace \\<rho> -\n                            trace (denote (Measure x1 x2a x3) \\<rho>)\n 2. \\<And>x1 S P.\n       \\<lbrakk>\\<And>P.\n                   \\<lbrakk>well_com S; is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n  trace (wlp S P * \\<rho>) =\n  trace (P * denote S \\<rho>) + trace \\<rho> - trace (denote S \\<rho>);\n        well_com (While x1 S); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                            trace (wlp (While x1 S) P * \\<rho>) =\n                            trace (P * denote (While x1 S) \\<rho>) +\n                            trace \\<rho> -\n                            trace (denote (While x1 S) \\<rho>)", "then"], ["proof (chain)\npicking this:\n  ?k < n \\<Longrightarrow>\n  M ?k * \\<rho> * adjoint (M ?k) \\<in> density_states", "have leqk: \"k < n \\<Longrightarrow> trace (wlp (S!k) P * ((M k) * \\<rho> * adjoint (M k))) = \n      trace (P * (denote (S!k) ((M k) * \\<rho> * adjoint (M k)))) + \n      (trace ((M k) * \\<rho> * adjoint (M k)) - trace (denote (S ! k) ((M k) * \\<rho> * adjoint (M k))))\" for k"], ["proof (prove)\nusing this:\n  ?k < n \\<Longrightarrow>\n  M ?k * \\<rho> * adjoint (M ?k) \\<in> density_states\n\ngoal (1 subgoal):\n 1. k < n \\<Longrightarrow>\n    trace (wlp (S ! k) P * (M k * \\<rho> * adjoint (M k))) =\n    trace (P * denote (S ! k) (M k * \\<rho> * adjoint (M k))) +\n    (trace (M k * \\<rho> * adjoint (M k)) -\n     trace (denote (S ! k) (M k * \\<rho> * adjoint (M k))))", "using c"], ["proof (prove)\nusing this:\n  ?k < n \\<Longrightarrow>\n  M ?k * \\<rho> * adjoint (M ?k) \\<in> density_states\n  \\<lbrakk>?k < n; ?\\<rho> \\<in> density_states\\<rbrakk>\n  \\<Longrightarrow> trace (wlp (S ! ?k) P * ?\\<rho>) =\n                    trace (P * denote (S ! ?k) ?\\<rho>) + trace ?\\<rho> -\n                    trace (denote (S ! ?k) ?\\<rho>)\n\ngoal (1 subgoal):\n 1. k < n \\<Longrightarrow>\n    trace (wlp (S ! k) P * (M k * \\<rho> * adjoint (M k))) =\n    trace (P * denote (S ! k) (M k * \\<rho> * adjoint (M k))) +\n    (trace (M k * \\<rho> * adjoint (M k)) -\n     trace (denote (S ! k) (M k * \\<rho> * adjoint (M k))))", "by auto"], ["proof (state)\nthis:\n  ?k < n \\<Longrightarrow>\n  trace (wlp (S ! ?k) P * (M ?k * \\<rho> * adjoint (M ?k))) =\n  trace (P * denote (S ! ?k) (M ?k * \\<rho> * adjoint (M ?k))) +\n  (trace (M ?k * \\<rho> * adjoint (M ?k)) -\n   trace (denote (S ! ?k) (M ?k * \\<rho> * adjoint (M ?k))))\n\ngoal (2 subgoals):\n 1. \\<And>x1 x2a x3 P.\n       \\<lbrakk>\\<And>x3a P.\n                   \\<lbrakk>x3a \\<in> set x3; well_com x3a;\n                    is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n  trace (wlp x3a P * \\<rho>) =\n  trace (P * denote x3a \\<rho>) + trace \\<rho> - trace (denote x3a \\<rho>);\n        well_com (Measure x1 x2a x3); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                            trace (wlp (Measure x1 x2a x3) P * \\<rho>) =\n                            trace (P * denote (Measure x1 x2a x3) \\<rho>) +\n                            trace \\<rho> -\n                            trace (denote (Measure x1 x2a x3) \\<rho>)\n 2. \\<And>x1 S P.\n       \\<lbrakk>\\<And>P.\n                   \\<lbrakk>well_com S; is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n  trace (wlp S P * \\<rho>) =\n  trace (P * denote S \\<rho>) + trace \\<rho> - trace (denote S \\<rho>);\n        well_com (While x1 S); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                            trace (wlp (While x1 S) P * \\<rho>) =\n                            trace (P * denote (While x1 S) \\<rho>) +\n                            trace \\<rho> -\n                            trace (denote (While x1 S) \\<rho>)", "have \"k < n \\<Longrightarrow> M k * \\<rho> * adjoint (M k) \\<in> carrier_mat d d\" for k"], ["proof (prove)\ngoal (1 subgoal):\n 1. k < n \\<Longrightarrow>\n    M k * \\<rho> * adjoint (M k) \\<in> carrier_mat d d", "using dMk dr"], ["proof (prove)\nusing this:\n  ?k < n \\<Longrightarrow> M ?k \\<in> carrier_mat d d\n  \\<rho> \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. k < n \\<Longrightarrow>\n    M k * \\<rho> * adjoint (M k) \\<in> carrier_mat d d", "by fastforce"], ["proof (state)\nthis:\n  ?k < n \\<Longrightarrow>\n  M ?k * \\<rho> * adjoint (M ?k) \\<in> carrier_mat d d\n\ngoal (2 subgoals):\n 1. \\<And>x1 x2a x3 P.\n       \\<lbrakk>\\<And>x3a P.\n                   \\<lbrakk>x3a \\<in> set x3; well_com x3a;\n                    is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n  trace (wlp x3a P * \\<rho>) =\n  trace (P * denote x3a \\<rho>) + trace \\<rho> - trace (denote x3a \\<rho>);\n        well_com (Measure x1 x2a x3); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                            trace (wlp (Measure x1 x2a x3) P * \\<rho>) =\n                            trace (P * denote (Measure x1 x2a x3) \\<rho>) +\n                            trace \\<rho> -\n                            trace (denote (Measure x1 x2a x3) \\<rho>)\n 2. \\<And>x1 S P.\n       \\<lbrakk>\\<And>P.\n                   \\<lbrakk>well_com S; is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n  trace (wlp S P * \\<rho>) =\n  trace (P * denote S \\<rho>) + trace \\<rho> - trace (denote S \\<rho>);\n        well_com (While x1 S); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                            trace (wlp (While x1 S) P * \\<rho>) =\n                            trace (P * denote (While x1 S) \\<rho>) +\n                            trace \\<rho> -\n                            trace (denote (While x1 S) \\<rho>)", "then"], ["proof (chain)\npicking this:\n  ?k < n \\<Longrightarrow>\n  M ?k * \\<rho> * adjoint (M ?k) \\<in> carrier_mat d d", "have dsMrk: \"k < n \\<Longrightarrow> matrix_sum d (\\<lambda>k. (M k * \\<rho> * adjoint (M k))) k \\<in> carrier_mat d d\" for k"], ["proof (prove)\nusing this:\n  ?k < n \\<Longrightarrow>\n  M ?k * \\<rho> * adjoint (M ?k) \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. k < n \\<Longrightarrow>\n    matrix_sum d (\\<lambda>k. M k * \\<rho> * adjoint (M k)) k\n    \\<in> carrier_mat d d", "using matrix_sum_dim[of k \"\\<lambda>k. (M k * \\<rho> * adjoint (M k))\" d]"], ["proof (prove)\nusing this:\n  ?k < n \\<Longrightarrow>\n  M ?k * \\<rho> * adjoint (M ?k) \\<in> carrier_mat d d\n  (\\<And>ka.\n      ka < k \\<Longrightarrow>\n      M ka * \\<rho> * adjoint (M ka)\n      \\<in> carrier_mat d d) \\<Longrightarrow>\n  matrix_sum d (\\<lambda>k. M k * \\<rho> * adjoint (M k)) k\n  \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. k < n \\<Longrightarrow>\n    matrix_sum d (\\<lambda>k. M k * \\<rho> * adjoint (M k)) k\n    \\<in> carrier_mat d d", "by fastforce"], ["proof (state)\nthis:\n  ?k < n \\<Longrightarrow>\n  matrix_sum d (\\<lambda>k. M k * \\<rho> * adjoint (M k)) ?k\n  \\<in> carrier_mat d d\n\ngoal (2 subgoals):\n 1. \\<And>x1 x2a x3 P.\n       \\<lbrakk>\\<And>x3a P.\n                   \\<lbrakk>x3a \\<in> set x3; well_com x3a;\n                    is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n  trace (wlp x3a P * \\<rho>) =\n  trace (P * denote x3a \\<rho>) + trace \\<rho> - trace (denote x3a \\<rho>);\n        well_com (Measure x1 x2a x3); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                            trace (wlp (Measure x1 x2a x3) P * \\<rho>) =\n                            trace (P * denote (Measure x1 x2a x3) \\<rho>) +\n                            trace \\<rho> -\n                            trace (denote (Measure x1 x2a x3) \\<rho>)\n 2. \\<And>x1 S P.\n       \\<lbrakk>\\<And>P.\n                   \\<lbrakk>well_com S; is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n  trace (wlp S P * \\<rho>) =\n  trace (P * denote S \\<rho>) + trace \\<rho> - trace (denote S \\<rho>);\n        well_com (While x1 S); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                            trace (wlp (While x1 S) P * \\<rho>) =\n                            trace (P * denote (While x1 S) \\<rho>) +\n                            trace \\<rho> -\n                            trace (denote (While x1 S) \\<rho>)", "have \"k < n \\<Longrightarrow> adjoint (M k) * (wlp (S!k) P) * M k \\<in> carrier_mat d d\" for k"], ["proof (prove)\ngoal (1 subgoal):\n 1. k < n \\<Longrightarrow>\n    adjoint (M k) * wlp (S ! k) P * M k \\<in> carrier_mat d d", "using dMk"], ["proof (prove)\nusing this:\n  ?k < n \\<Longrightarrow> M ?k \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. k < n \\<Longrightarrow>\n    adjoint (M k) * wlp (S ! k) P * M k \\<in> carrier_mat d d", "by fastforce"], ["proof (state)\nthis:\n  ?k < n \\<Longrightarrow>\n  adjoint (M ?k) * wlp (S ! ?k) P * M ?k \\<in> carrier_mat d d\n\ngoal (2 subgoals):\n 1. \\<And>x1 x2a x3 P.\n       \\<lbrakk>\\<And>x3a P.\n                   \\<lbrakk>x3a \\<in> set x3; well_com x3a;\n                    is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n  trace (wlp x3a P * \\<rho>) =\n  trace (P * denote x3a \\<rho>) + trace \\<rho> - trace (denote x3a \\<rho>);\n        well_com (Measure x1 x2a x3); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                            trace (wlp (Measure x1 x2a x3) P * \\<rho>) =\n                            trace (P * denote (Measure x1 x2a x3) \\<rho>) +\n                            trace \\<rho> -\n                            trace (denote (Measure x1 x2a x3) \\<rho>)\n 2. \\<And>x1 S P.\n       \\<lbrakk>\\<And>P.\n                   \\<lbrakk>well_com S; is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n  trace (wlp S P * \\<rho>) =\n  trace (P * denote S \\<rho>) + trace \\<rho> - trace (denote S \\<rho>);\n        well_com (While x1 S); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                            trace (wlp (While x1 S) P * \\<rho>) =\n                            trace (P * denote (While x1 S) \\<rho>) +\n                            trace \\<rho> -\n                            trace (denote (While x1 S) \\<rho>)", "then"], ["proof (chain)\npicking this:\n  ?k < n \\<Longrightarrow>\n  adjoint (M ?k) * wlp (S ! ?k) P * M ?k \\<in> carrier_mat d d", "have dsMW: \"k < n \\<Longrightarrow> matrix_sum d (\\<lambda>k. adjoint (M k) * (wlp (S!k) P) * M k) k \\<in> carrier_mat d d\" for k"], ["proof (prove)\nusing this:\n  ?k < n \\<Longrightarrow>\n  adjoint (M ?k) * wlp (S ! ?k) P * M ?k \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. k < n \\<Longrightarrow>\n    matrix_sum d (\\<lambda>k. adjoint (M k) * wlp (S ! k) P * M k) k\n    \\<in> carrier_mat d d", "using matrix_sum_dim[of k \"\\<lambda>k. adjoint (M k) * (wlp (S!k) P) * M k\" d]"], ["proof (prove)\nusing this:\n  ?k < n \\<Longrightarrow>\n  adjoint (M ?k) * wlp (S ! ?k) P * M ?k \\<in> carrier_mat d d\n  (\\<And>ka.\n      ka < k \\<Longrightarrow>\n      adjoint (M ka) * wlp (S ! ka) P * M ka\n      \\<in> carrier_mat d d) \\<Longrightarrow>\n  matrix_sum d (\\<lambda>k. adjoint (M k) * wlp (S ! k) P * M k) k\n  \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. k < n \\<Longrightarrow>\n    matrix_sum d (\\<lambda>k. adjoint (M k) * wlp (S ! k) P * M k) k\n    \\<in> carrier_mat d d", "by fastforce"], ["proof (state)\nthis:\n  ?k < n \\<Longrightarrow>\n  matrix_sum d (\\<lambda>k. adjoint (M k) * wlp (S ! k) P * M k) ?k\n  \\<in> carrier_mat d d\n\ngoal (2 subgoals):\n 1. \\<And>x1 x2a x3 P.\n       \\<lbrakk>\\<And>x3a P.\n                   \\<lbrakk>x3a \\<in> set x3; well_com x3a;\n                    is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n  trace (wlp x3a P * \\<rho>) =\n  trace (P * denote x3a \\<rho>) + trace \\<rho> - trace (denote x3a \\<rho>);\n        well_com (Measure x1 x2a x3); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                            trace (wlp (Measure x1 x2a x3) P * \\<rho>) =\n                            trace (P * denote (Measure x1 x2a x3) \\<rho>) +\n                            trace \\<rho> -\n                            trace (denote (Measure x1 x2a x3) \\<rho>)\n 2. \\<And>x1 S P.\n       \\<lbrakk>\\<And>P.\n                   \\<lbrakk>well_com S; is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n  trace (wlp S P * \\<rho>) =\n  trace (P * denote S \\<rho>) + trace \\<rho> - trace (denote S \\<rho>);\n        well_com (While x1 S); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                            trace (wlp (While x1 S) P * \\<rho>) =\n                            trace (P * denote (While x1 S) \\<rho>) +\n                            trace \\<rho> -\n                            trace (denote (While x1 S) \\<rho>)", "have dSMrk: \"k < n \\<Longrightarrow> denote (S ! k) (M k * \\<rho> * adjoint (M k)) \\<in> carrier_mat d d\" for k"], ["proof (prove)\ngoal (1 subgoal):\n 1. k < n \\<Longrightarrow>\n    denote (S ! k) (M k * \\<rho> * adjoint (M k)) \\<in> carrier_mat d d", "using denote_dim[OF wck, of k \"M k * \\<rho> * adjoint (M k)\"] dsr density_states_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>k < n; M k * \\<rho> * adjoint (M k) \\<in> carrier_mat d d;\n   partial_density_operator (M k * \\<rho> * adjoint (M k))\\<rbrakk>\n  \\<Longrightarrow> denote (S ! k) (M k * \\<rho> * adjoint (M k))\n                    \\<in> carrier_mat d d\n  ?k < n \\<Longrightarrow>\n  M ?k * \\<rho> * adjoint (M ?k) \\<in> density_states\n  density_states =\n  {\\<rho> \\<in> carrier_mat d d. partial_density_operator \\<rho>}\n\ngoal (1 subgoal):\n 1. k < n \\<Longrightarrow>\n    denote (S ! k) (M k * \\<rho> * adjoint (M k)) \\<in> carrier_mat d d", "by fastforce"], ["proof (state)\nthis:\n  ?k < n \\<Longrightarrow>\n  denote (S ! ?k) (M ?k * \\<rho> * adjoint (M ?k)) \\<in> carrier_mat d d\n\ngoal (2 subgoals):\n 1. \\<And>x1 x2a x3 P.\n       \\<lbrakk>\\<And>x3a P.\n                   \\<lbrakk>x3a \\<in> set x3; well_com x3a;\n                    is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n  trace (wlp x3a P * \\<rho>) =\n  trace (P * denote x3a \\<rho>) + trace \\<rho> - trace (denote x3a \\<rho>);\n        well_com (Measure x1 x2a x3); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                            trace (wlp (Measure x1 x2a x3) P * \\<rho>) =\n                            trace (P * denote (Measure x1 x2a x3) \\<rho>) +\n                            trace \\<rho> -\n                            trace (denote (Measure x1 x2a x3) \\<rho>)\n 2. \\<And>x1 S P.\n       \\<lbrakk>\\<And>P.\n                   \\<lbrakk>well_com S; is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n  trace (wlp S P * \\<rho>) =\n  trace (P * denote S \\<rho>) + trace \\<rho> - trace (denote S \\<rho>);\n        well_com (While x1 S); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                            trace (wlp (While x1 S) P * \\<rho>) =\n                            trace (P * denote (While x1 S) \\<rho>) +\n                            trace \\<rho> -\n                            trace (denote (While x1 S) \\<rho>)", "have dsSMrk: \"k < n \\<Longrightarrow> matrix_sum d (\\<lambda>k. denote (S!k) (M k * \\<rho> * adjoint (M k))) k \\<in> carrier_mat d d\" for k"], ["proof (prove)\ngoal (1 subgoal):\n 1. k < n \\<Longrightarrow>\n    matrix_sum d (\\<lambda>k. denote (S ! k) (M k * \\<rho> * adjoint (M k)))\n     k\n    \\<in> carrier_mat d d", "using matrix_sum_dim[of k \"\\<lambda>k. denote (S ! k) (M k * \\<rho> * adjoint (M k))\" d, OF dSMrk]"], ["proof (prove)\nusing this:\n  (\\<And>ka. ka < k \\<Longrightarrow> ka < n) \\<Longrightarrow>\n  matrix_sum d (\\<lambda>k. denote (S ! k) (M k * \\<rho> * adjoint (M k))) k\n  \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. k < n \\<Longrightarrow>\n    matrix_sum d (\\<lambda>k. denote (S ! k) (M k * \\<rho> * adjoint (M k)))\n     k\n    \\<in> carrier_mat d d", "by fastforce"], ["proof (state)\nthis:\n  ?k < n \\<Longrightarrow>\n  matrix_sum d (\\<lambda>k. denote (S ! k) (M k * \\<rho> * adjoint (M k)))\n   ?k\n  \\<in> carrier_mat d d\n\ngoal (2 subgoals):\n 1. \\<And>x1 x2a x3 P.\n       \\<lbrakk>\\<And>x3a P.\n                   \\<lbrakk>x3a \\<in> set x3; well_com x3a;\n                    is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n  trace (wlp x3a P * \\<rho>) =\n  trace (P * denote x3a \\<rho>) + trace \\<rho> - trace (denote x3a \\<rho>);\n        well_com (Measure x1 x2a x3); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                            trace (wlp (Measure x1 x2a x3) P * \\<rho>) =\n                            trace (P * denote (Measure x1 x2a x3) \\<rho>) +\n                            trace \\<rho> -\n                            trace (denote (Measure x1 x2a x3) \\<rho>)\n 2. \\<And>x1 S P.\n       \\<lbrakk>\\<And>P.\n                   \\<lbrakk>well_com S; is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n  trace (wlp S P * \\<rho>) =\n  trace (P * denote S \\<rho>) + trace \\<rho> - trace (denote S \\<rho>);\n        well_com (While x1 S); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                            trace (wlp (While x1 S) P * \\<rho>) =\n                            trace (P * denote (While x1 S) \\<rho>) +\n                            trace \\<rho> -\n                            trace (denote (While x1 S) \\<rho>)", "have \"k \\<le> n \\<Longrightarrow> \n        trace (matrix_sum d (\\<lambda>k. adjoint (M k) * (wlp (S!k) P) * M k) k * \\<rho>)\n       = trace (P * (denote (Measure k M S) \\<rho>)) + (trace (matrix_sum d (\\<lambda>k. (M k) * \\<rho> * adjoint (M k)) k) - trace (denote (Measure k M S) \\<rho>))\" for k"], ["proof (prove)\ngoal (1 subgoal):\n 1. k \\<le> n \\<Longrightarrow>\n    trace\n     (matrix_sum d (\\<lambda>k. adjoint (M k) * wlp (S ! k) P * M k) k *\n      \\<rho>) =\n    trace (P * denote (Measure k M S) \\<rho>) +\n    (trace (matrix_sum d (\\<lambda>k. M k * \\<rho> * adjoint (M k)) k) -\n     trace (denote (Measure k M S) \\<rho>))", "unfolding denote_measure_expand[OF _ wc]"], ["proof (prove)\ngoal (1 subgoal):\n 1. k \\<le> n \\<Longrightarrow>\n    trace\n     (matrix_sum d (\\<lambda>k. adjoint (M k) * wlp (S ! k) P * M k) k *\n      \\<rho>) =\n    trace\n     (P *\n      matrix_sum d\n       (\\<lambda>k. denote (S ! k) (M k * \\<rho> * adjoint (M k))) k) +\n    (trace (matrix_sum d (\\<lambda>k. M k * \\<rho> * adjoint (M k)) k) -\n     trace\n      (matrix_sum d\n        (\\<lambda>k. denote (S ! k) (M k * \\<rho> * adjoint (M k))) k))", "proof (induct k)"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 \\<le> n \\<Longrightarrow>\n    trace\n     (matrix_sum d (\\<lambda>k. adjoint (M k) * wlp (S ! k) P * M k) 0 *\n      \\<rho>) =\n    trace\n     (P *\n      matrix_sum d\n       (\\<lambda>k. denote (S ! k) (M k * \\<rho> * adjoint (M k))) 0) +\n    (trace (matrix_sum d (\\<lambda>k. M k * \\<rho> * adjoint (M k)) 0) -\n     trace\n      (matrix_sum d\n        (\\<lambda>k. denote (S ! k) (M k * \\<rho> * adjoint (M k))) 0))\n 2. \\<And>k.\n       \\<lbrakk>k \\<le> n \\<Longrightarrow>\n                trace\n                 (matrix_sum d\n                   (\\<lambda>k. adjoint (M k) * wlp (S ! k) P * M k) k *\n                  \\<rho>) =\n                trace\n                 (P *\n                  matrix_sum d\n                   (\\<lambda>k.\n                       denote (S ! k) (M k * \\<rho> * adjoint (M k)))\n                   k) +\n                (trace\n                  (matrix_sum d (\\<lambda>k. M k * \\<rho> * adjoint (M k))\n                    k) -\n                 trace\n                  (matrix_sum d\n                    (\\<lambda>k.\n                        denote (S ! k) (M k * \\<rho> * adjoint (M k)))\n                    k));\n        Suc k \\<le> n\\<rbrakk>\n       \\<Longrightarrow> trace\n                          (matrix_sum d\n                            (\\<lambda>k.\n                                adjoint (M k) * wlp (S ! k) P * M k)\n                            (Suc k) *\n                           \\<rho>) =\n                         trace\n                          (P *\n                           matrix_sum d\n                            (\\<lambda>k.\n                                denote (S ! k)\n                                 (M k * \\<rho> * adjoint (M k)))\n                            (Suc k)) +\n                         (trace\n                           (matrix_sum d\n                             (\\<lambda>k. M k * \\<rho> * adjoint (M k))\n                             (Suc k)) -\n                          trace\n                           (matrix_sum d\n                             (\\<lambda>k.\n                                 denote (S ! k)\n                                  (M k * \\<rho> * adjoint (M k)))\n                             (Suc k)))", "case 0"], ["proof (state)\nthis:\n  0 \\<le> n\n\ngoal (2 subgoals):\n 1. 0 \\<le> n \\<Longrightarrow>\n    trace\n     (matrix_sum d (\\<lambda>k. adjoint (M k) * wlp (S ! k) P * M k) 0 *\n      \\<rho>) =\n    trace\n     (P *\n      matrix_sum d\n       (\\<lambda>k. denote (S ! k) (M k * \\<rho> * adjoint (M k))) 0) +\n    (trace (matrix_sum d (\\<lambda>k. M k * \\<rho> * adjoint (M k)) 0) -\n     trace\n      (matrix_sum d\n        (\\<lambda>k. denote (S ! k) (M k * \\<rho> * adjoint (M k))) 0))\n 2. \\<And>k.\n       \\<lbrakk>k \\<le> n \\<Longrightarrow>\n                trace\n                 (matrix_sum d\n                   (\\<lambda>k. adjoint (M k) * wlp (S ! k) P * M k) k *\n                  \\<rho>) =\n                trace\n                 (P *\n                  matrix_sum d\n                   (\\<lambda>k.\n                       denote (S ! k) (M k * \\<rho> * adjoint (M k)))\n                   k) +\n                (trace\n                  (matrix_sum d (\\<lambda>k. M k * \\<rho> * adjoint (M k))\n                    k) -\n                 trace\n                  (matrix_sum d\n                    (\\<lambda>k.\n                        denote (S ! k) (M k * \\<rho> * adjoint (M k)))\n                    k));\n        Suc k \\<le> n\\<rbrakk>\n       \\<Longrightarrow> trace\n                          (matrix_sum d\n                            (\\<lambda>k.\n                                adjoint (M k) * wlp (S ! k) P * M k)\n                            (Suc k) *\n                           \\<rho>) =\n                         trace\n                          (P *\n                           matrix_sum d\n                            (\\<lambda>k.\n                                denote (S ! k)\n                                 (M k * \\<rho> * adjoint (M k)))\n                            (Suc k)) +\n                         (trace\n                           (matrix_sum d\n                             (\\<lambda>k. M k * \\<rho> * adjoint (M k))\n                             (Suc k)) -\n                          trace\n                           (matrix_sum d\n                             (\\<lambda>k.\n                                 denote (S ! k)\n                                  (M k * \\<rho> * adjoint (M k)))\n                             (Suc k)))", "then"], ["proof (chain)\npicking this:\n  0 \\<le> n", "show ?case"], ["proof (prove)\nusing this:\n  0 \\<le> n\n\ngoal (1 subgoal):\n 1. trace\n     (matrix_sum d (\\<lambda>k. adjoint (M k) * wlp (S ! k) P * M k) 0 *\n      \\<rho>) =\n    trace\n     (P *\n      matrix_sum d\n       (\\<lambda>k. denote (S ! k) (M k * \\<rho> * adjoint (M k))) 0) +\n    (trace (matrix_sum d (\\<lambda>k. M k * \\<rho> * adjoint (M k)) 0) -\n     trace\n      (matrix_sum d\n        (\\<lambda>k. denote (S ! k) (M k * \\<rho> * adjoint (M k))) 0))", "unfolding matrix_sum.simps"], ["proof (prove)\nusing this:\n  0 \\<le> n\n\ngoal (1 subgoal):\n 1. trace (0\\<^sub>m d d * \\<rho>) =\n    trace (P * 0\\<^sub>m d d) +\n    (trace (0\\<^sub>m d d) - trace (0\\<^sub>m d d))", "using dP dr"], ["proof (prove)\nusing this:\n  0 \\<le> n\n  P \\<in> carrier_mat d d\n  \\<rho> \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. trace (0\\<^sub>m d d * \\<rho>) =\n    trace (P * 0\\<^sub>m d d) +\n    (trace (0\\<^sub>m d d) - trace (0\\<^sub>m d d))", "by auto"], ["proof (state)\nthis:\n  trace\n   (matrix_sum d (\\<lambda>k. adjoint (M k) * wlp (S ! k) P * M k) 0 *\n    \\<rho>) =\n  trace\n   (P *\n    matrix_sum d (\\<lambda>k. denote (S ! k) (M k * \\<rho> * adjoint (M k)))\n     0) +\n  (trace (matrix_sum d (\\<lambda>k. M k * \\<rho> * adjoint (M k)) 0) -\n   trace\n    (matrix_sum d\n      (\\<lambda>k. denote (S ! k) (M k * \\<rho> * adjoint (M k))) 0))\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k \\<le> n \\<Longrightarrow>\n                trace\n                 (matrix_sum d\n                   (\\<lambda>k. adjoint (M k) * wlp (S ! k) P * M k) k *\n                  \\<rho>) =\n                trace\n                 (P *\n                  matrix_sum d\n                   (\\<lambda>k.\n                       denote (S ! k) (M k * \\<rho> * adjoint (M k)))\n                   k) +\n                (trace\n                  (matrix_sum d (\\<lambda>k. M k * \\<rho> * adjoint (M k))\n                    k) -\n                 trace\n                  (matrix_sum d\n                    (\\<lambda>k.\n                        denote (S ! k) (M k * \\<rho> * adjoint (M k)))\n                    k));\n        Suc k \\<le> n\\<rbrakk>\n       \\<Longrightarrow> trace\n                          (matrix_sum d\n                            (\\<lambda>k.\n                                adjoint (M k) * wlp (S ! k) P * M k)\n                            (Suc k) *\n                           \\<rho>) =\n                         trace\n                          (P *\n                           matrix_sum d\n                            (\\<lambda>k.\n                                denote (S ! k)\n                                 (M k * \\<rho> * adjoint (M k)))\n                            (Suc k)) +\n                         (trace\n                           (matrix_sum d\n                             (\\<lambda>k. M k * \\<rho> * adjoint (M k))\n                             (Suc k)) -\n                          trace\n                           (matrix_sum d\n                             (\\<lambda>k.\n                                 denote (S ! k)\n                                  (M k * \\<rho> * adjoint (M k)))\n                             (Suc k)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k \\<le> n \\<Longrightarrow>\n                trace\n                 (matrix_sum d\n                   (\\<lambda>k. adjoint (M k) * wlp (S ! k) P * M k) k *\n                  \\<rho>) =\n                trace\n                 (P *\n                  matrix_sum d\n                   (\\<lambda>k.\n                       denote (S ! k) (M k * \\<rho> * adjoint (M k)))\n                   k) +\n                (trace\n                  (matrix_sum d (\\<lambda>k. M k * \\<rho> * adjoint (M k))\n                    k) -\n                 trace\n                  (matrix_sum d\n                    (\\<lambda>k.\n                        denote (S ! k) (M k * \\<rho> * adjoint (M k)))\n                    k));\n        Suc k \\<le> n\\<rbrakk>\n       \\<Longrightarrow> trace\n                          (matrix_sum d\n                            (\\<lambda>k.\n                                adjoint (M k) * wlp (S ! k) P * M k)\n                            (Suc k) *\n                           \\<rho>) =\n                         trace\n                          (P *\n                           matrix_sum d\n                            (\\<lambda>k.\n                                denote (S ! k)\n                                 (M k * \\<rho> * adjoint (M k)))\n                            (Suc k)) +\n                         (trace\n                           (matrix_sum d\n                             (\\<lambda>k. M k * \\<rho> * adjoint (M k))\n                             (Suc k)) -\n                          trace\n                           (matrix_sum d\n                             (\\<lambda>k.\n                                 denote (S ! k)\n                                  (M k * \\<rho> * adjoint (M k)))\n                             (Suc k)))", "case (Suc k)"], ["proof (state)\nthis:\n  k \\<le> n \\<Longrightarrow>\n  trace\n   (matrix_sum d (\\<lambda>k. adjoint (M k) * wlp (S ! k) P * M k) k *\n    \\<rho>) =\n  trace\n   (P *\n    matrix_sum d (\\<lambda>k. denote (S ! k) (M k * \\<rho> * adjoint (M k)))\n     k) +\n  (trace (matrix_sum d (\\<lambda>k. M k * \\<rho> * adjoint (M k)) k) -\n   trace\n    (matrix_sum d\n      (\\<lambda>k. denote (S ! k) (M k * \\<rho> * adjoint (M k))) k))\n  Suc k \\<le> n\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k \\<le> n \\<Longrightarrow>\n                trace\n                 (matrix_sum d\n                   (\\<lambda>k. adjoint (M k) * wlp (S ! k) P * M k) k *\n                  \\<rho>) =\n                trace\n                 (P *\n                  matrix_sum d\n                   (\\<lambda>k.\n                       denote (S ! k) (M k * \\<rho> * adjoint (M k)))\n                   k) +\n                (trace\n                  (matrix_sum d (\\<lambda>k. M k * \\<rho> * adjoint (M k))\n                    k) -\n                 trace\n                  (matrix_sum d\n                    (\\<lambda>k.\n                        denote (S ! k) (M k * \\<rho> * adjoint (M k)))\n                    k));\n        Suc k \\<le> n\\<rbrakk>\n       \\<Longrightarrow> trace\n                          (matrix_sum d\n                            (\\<lambda>k.\n                                adjoint (M k) * wlp (S ! k) P * M k)\n                            (Suc k) *\n                           \\<rho>) =\n                         trace\n                          (P *\n                           matrix_sum d\n                            (\\<lambda>k.\n                                denote (S ! k)\n                                 (M k * \\<rho> * adjoint (M k)))\n                            (Suc k)) +\n                         (trace\n                           (matrix_sum d\n                             (\\<lambda>k. M k * \\<rho> * adjoint (M k))\n                             (Suc k)) -\n                          trace\n                           (matrix_sum d\n                             (\\<lambda>k.\n                                 denote (S ! k)\n                                  (M k * \\<rho> * adjoint (M k)))\n                             (Suc k)))", "then"], ["proof (chain)\npicking this:\n  k \\<le> n \\<Longrightarrow>\n  trace\n   (matrix_sum d (\\<lambda>k. adjoint (M k) * wlp (S ! k) P * M k) k *\n    \\<rho>) =\n  trace\n   (P *\n    matrix_sum d (\\<lambda>k. denote (S ! k) (M k * \\<rho> * adjoint (M k)))\n     k) +\n  (trace (matrix_sum d (\\<lambda>k. M k * \\<rho> * adjoint (M k)) k) -\n   trace\n    (matrix_sum d\n      (\\<lambda>k. denote (S ! k) (M k * \\<rho> * adjoint (M k))) k))\n  Suc k \\<le> n", "have k: \"k < n\""], ["proof (prove)\nusing this:\n  k \\<le> n \\<Longrightarrow>\n  trace\n   (matrix_sum d (\\<lambda>k. adjoint (M k) * wlp (S ! k) P * M k) k *\n    \\<rho>) =\n  trace\n   (P *\n    matrix_sum d (\\<lambda>k. denote (S ! k) (M k * \\<rho> * adjoint (M k)))\n     k) +\n  (trace (matrix_sum d (\\<lambda>k. M k * \\<rho> * adjoint (M k)) k) -\n   trace\n    (matrix_sum d\n      (\\<lambda>k. denote (S ! k) (M k * \\<rho> * adjoint (M k))) k))\n  Suc k \\<le> n\n\ngoal (1 subgoal):\n 1. k < n", "by auto"], ["proof (state)\nthis:\n  k < n\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k \\<le> n \\<Longrightarrow>\n                trace\n                 (matrix_sum d\n                   (\\<lambda>k. adjoint (M k) * wlp (S ! k) P * M k) k *\n                  \\<rho>) =\n                trace\n                 (P *\n                  matrix_sum d\n                   (\\<lambda>k.\n                       denote (S ! k) (M k * \\<rho> * adjoint (M k)))\n                   k) +\n                (trace\n                  (matrix_sum d (\\<lambda>k. M k * \\<rho> * adjoint (M k))\n                    k) -\n                 trace\n                  (matrix_sum d\n                    (\\<lambda>k.\n                        denote (S ! k) (M k * \\<rho> * adjoint (M k)))\n                    k));\n        Suc k \\<le> n\\<rbrakk>\n       \\<Longrightarrow> trace\n                          (matrix_sum d\n                            (\\<lambda>k.\n                                adjoint (M k) * wlp (S ! k) P * M k)\n                            (Suc k) *\n                           \\<rho>) =\n                         trace\n                          (P *\n                           matrix_sum d\n                            (\\<lambda>k.\n                                denote (S ! k)\n                                 (M k * \\<rho> * adjoint (M k)))\n                            (Suc k)) +\n                         (trace\n                           (matrix_sum d\n                             (\\<lambda>k. M k * \\<rho> * adjoint (M k))\n                             (Suc k)) -\n                          trace\n                           (matrix_sum d\n                             (\\<lambda>k.\n                                 denote (S ! k)\n                                  (M k * \\<rho> * adjoint (M k)))\n                             (Suc k)))", "have eq1: \"trace (matrix_sum d (\\<lambda>k. adjoint (M k) * (wlp (S!k) P) * M k) (Suc k) * \\<rho>) \n        = trace (adjoint (M k) * (wlp (S!k) P) * M k * \\<rho>) + trace (matrix_sum d (\\<lambda>k. adjoint (M k) * (wlp (S!k) P) * M k) k * \\<rho>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace\n     (matrix_sum d (\\<lambda>k. adjoint (M k) * wlp (S ! k) P * M k)\n       (Suc k) *\n      \\<rho>) =\n    trace (adjoint (M k) * wlp (S ! k) P * M k * \\<rho>) +\n    trace\n     (matrix_sum d (\\<lambda>k. adjoint (M k) * wlp (S ! k) P * M k) k *\n      \\<rho>)", "unfolding matrix_sum.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. trace\n     ((adjoint (M k) * wlp (S ! k) P * M k +\n       matrix_sum d (\\<lambda>k. adjoint (M k) * wlp (S ! k) P * M k) k) *\n      \\<rho>) =\n    trace (adjoint (M k) * wlp (S ! k) P * M k * \\<rho>) +\n    trace\n     (matrix_sum d (\\<lambda>k. adjoint (M k) * wlp (S ! k) P * M k) k *\n      \\<rho>)", "using dMk[OF k] dWk[OF k] dr dsMW[OF k]"], ["proof (prove)\nusing this:\n  M k \\<in> carrier_mat d d\n  wlp (S ! k) P \\<in> carrier_mat d d\n  \\<rho> \\<in> carrier_mat d d\n  matrix_sum d (\\<lambda>k. adjoint (M k) * wlp (S ! k) P * M k) k\n  \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. trace\n     ((adjoint (M k) * wlp (S ! k) P * M k +\n       matrix_sum d (\\<lambda>k. adjoint (M k) * wlp (S ! k) P * M k) k) *\n      \\<rho>) =\n    trace (adjoint (M k) * wlp (S ! k) P * M k * \\<rho>) +\n    trace\n     (matrix_sum d (\\<lambda>k. adjoint (M k) * wlp (S ! k) P * M k) k *\n      \\<rho>)", "by (mat_assoc d)"], ["proof (state)\nthis:\n  trace\n   (matrix_sum d (\\<lambda>k. adjoint (M k) * wlp (S ! k) P * M k) (Suc k) *\n    \\<rho>) =\n  trace (adjoint (M k) * wlp (S ! k) P * M k * \\<rho>) +\n  trace\n   (matrix_sum d (\\<lambda>k. adjoint (M k) * wlp (S ! k) P * M k) k *\n    \\<rho>)\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k \\<le> n \\<Longrightarrow>\n                trace\n                 (matrix_sum d\n                   (\\<lambda>k. adjoint (M k) * wlp (S ! k) P * M k) k *\n                  \\<rho>) =\n                trace\n                 (P *\n                  matrix_sum d\n                   (\\<lambda>k.\n                       denote (S ! k) (M k * \\<rho> * adjoint (M k)))\n                   k) +\n                (trace\n                  (matrix_sum d (\\<lambda>k. M k * \\<rho> * adjoint (M k))\n                    k) -\n                 trace\n                  (matrix_sum d\n                    (\\<lambda>k.\n                        denote (S ! k) (M k * \\<rho> * adjoint (M k)))\n                    k));\n        Suc k \\<le> n\\<rbrakk>\n       \\<Longrightarrow> trace\n                          (matrix_sum d\n                            (\\<lambda>k.\n                                adjoint (M k) * wlp (S ! k) P * M k)\n                            (Suc k) *\n                           \\<rho>) =\n                         trace\n                          (P *\n                           matrix_sum d\n                            (\\<lambda>k.\n                                denote (S ! k)\n                                 (M k * \\<rho> * adjoint (M k)))\n                            (Suc k)) +\n                         (trace\n                           (matrix_sum d\n                             (\\<lambda>k. M k * \\<rho> * adjoint (M k))\n                             (Suc k)) -\n                          trace\n                           (matrix_sum d\n                             (\\<lambda>k.\n                                 denote (S ! k)\n                                  (M k * \\<rho> * adjoint (M k)))\n                             (Suc k)))", "have \"trace (adjoint (M k) * (wlp (S!k) P) * M k * \\<rho>) = trace ((wlp (S!k) P) * (M k * \\<rho> * adjoint (M k)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace (adjoint (M k) * wlp (S ! k) P * M k * \\<rho>) =\n    trace (wlp (S ! k) P * (M k * \\<rho> * adjoint (M k)))", "using dMk[OF k] dWk[OF k] dr"], ["proof (prove)\nusing this:\n  M k \\<in> carrier_mat d d\n  wlp (S ! k) P \\<in> carrier_mat d d\n  \\<rho> \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. trace (adjoint (M k) * wlp (S ! k) P * M k * \\<rho>) =\n    trace (wlp (S ! k) P * (M k * \\<rho> * adjoint (M k)))", "by (mat_assoc d)"], ["proof (state)\nthis:\n  trace (adjoint (M k) * wlp (S ! k) P * M k * \\<rho>) =\n  trace (wlp (S ! k) P * (M k * \\<rho> * adjoint (M k)))\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k \\<le> n \\<Longrightarrow>\n                trace\n                 (matrix_sum d\n                   (\\<lambda>k. adjoint (M k) * wlp (S ! k) P * M k) k *\n                  \\<rho>) =\n                trace\n                 (P *\n                  matrix_sum d\n                   (\\<lambda>k.\n                       denote (S ! k) (M k * \\<rho> * adjoint (M k)))\n                   k) +\n                (trace\n                  (matrix_sum d (\\<lambda>k. M k * \\<rho> * adjoint (M k))\n                    k) -\n                 trace\n                  (matrix_sum d\n                    (\\<lambda>k.\n                        denote (S ! k) (M k * \\<rho> * adjoint (M k)))\n                    k));\n        Suc k \\<le> n\\<rbrakk>\n       \\<Longrightarrow> trace\n                          (matrix_sum d\n                            (\\<lambda>k.\n                                adjoint (M k) * wlp (S ! k) P * M k)\n                            (Suc k) *\n                           \\<rho>) =\n                         trace\n                          (P *\n                           matrix_sum d\n                            (\\<lambda>k.\n                                denote (S ! k)\n                                 (M k * \\<rho> * adjoint (M k)))\n                            (Suc k)) +\n                         (trace\n                           (matrix_sum d\n                             (\\<lambda>k. M k * \\<rho> * adjoint (M k))\n                             (Suc k)) -\n                          trace\n                           (matrix_sum d\n                             (\\<lambda>k.\n                                 denote (S ! k)\n                                  (M k * \\<rho> * adjoint (M k)))\n                             (Suc k)))", "also"], ["proof (state)\nthis:\n  trace (adjoint (M k) * wlp (S ! k) P * M k * \\<rho>) =\n  trace (wlp (S ! k) P * (M k * \\<rho> * adjoint (M k)))\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k \\<le> n \\<Longrightarrow>\n                trace\n                 (matrix_sum d\n                   (\\<lambda>k. adjoint (M k) * wlp (S ! k) P * M k) k *\n                  \\<rho>) =\n                trace\n                 (P *\n                  matrix_sum d\n                   (\\<lambda>k.\n                       denote (S ! k) (M k * \\<rho> * adjoint (M k)))\n                   k) +\n                (trace\n                  (matrix_sum d (\\<lambda>k. M k * \\<rho> * adjoint (M k))\n                    k) -\n                 trace\n                  (matrix_sum d\n                    (\\<lambda>k.\n                        denote (S ! k) (M k * \\<rho> * adjoint (M k)))\n                    k));\n        Suc k \\<le> n\\<rbrakk>\n       \\<Longrightarrow> trace\n                          (matrix_sum d\n                            (\\<lambda>k.\n                                adjoint (M k) * wlp (S ! k) P * M k)\n                            (Suc k) *\n                           \\<rho>) =\n                         trace\n                          (P *\n                           matrix_sum d\n                            (\\<lambda>k.\n                                denote (S ! k)\n                                 (M k * \\<rho> * adjoint (M k)))\n                            (Suc k)) +\n                         (trace\n                           (matrix_sum d\n                             (\\<lambda>k. M k * \\<rho> * adjoint (M k))\n                             (Suc k)) -\n                          trace\n                           (matrix_sum d\n                             (\\<lambda>k.\n                                 denote (S ! k)\n                                  (M k * \\<rho> * adjoint (M k)))\n                             (Suc k)))", "have \"\\<dots> = trace (P * (denote (S!k) ((M k) * \\<rho> * adjoint (M k)))) + \n        (trace ((M k) * \\<rho> * adjoint (M k)) - trace (denote (S ! k) ((M k) * \\<rho> * adjoint (M k))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace (wlp (S ! k) P * (M k * \\<rho> * adjoint (M k))) =\n    trace (P * denote (S ! k) (M k * \\<rho> * adjoint (M k))) +\n    (trace (M k * \\<rho> * adjoint (M k)) -\n     trace (denote (S ! k) (M k * \\<rho> * adjoint (M k))))", "using leqk k"], ["proof (prove)\nusing this:\n  ?k < n \\<Longrightarrow>\n  trace (wlp (S ! ?k) P * (M ?k * \\<rho> * adjoint (M ?k))) =\n  trace (P * denote (S ! ?k) (M ?k * \\<rho> * adjoint (M ?k))) +\n  (trace (M ?k * \\<rho> * adjoint (M ?k)) -\n   trace (denote (S ! ?k) (M ?k * \\<rho> * adjoint (M ?k))))\n  k < n\n\ngoal (1 subgoal):\n 1. trace (wlp (S ! k) P * (M k * \\<rho> * adjoint (M k))) =\n    trace (P * denote (S ! k) (M k * \\<rho> * adjoint (M k))) +\n    (trace (M k * \\<rho> * adjoint (M k)) -\n     trace (denote (S ! k) (M k * \\<rho> * adjoint (M k))))", "by auto"], ["proof (state)\nthis:\n  trace (wlp (S ! k) P * (M k * \\<rho> * adjoint (M k))) =\n  trace (P * denote (S ! k) (M k * \\<rho> * adjoint (M k))) +\n  (trace (M k * \\<rho> * adjoint (M k)) -\n   trace (denote (S ! k) (M k * \\<rho> * adjoint (M k))))\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k \\<le> n \\<Longrightarrow>\n                trace\n                 (matrix_sum d\n                   (\\<lambda>k. adjoint (M k) * wlp (S ! k) P * M k) k *\n                  \\<rho>) =\n                trace\n                 (P *\n                  matrix_sum d\n                   (\\<lambda>k.\n                       denote (S ! k) (M k * \\<rho> * adjoint (M k)))\n                   k) +\n                (trace\n                  (matrix_sum d (\\<lambda>k. M k * \\<rho> * adjoint (M k))\n                    k) -\n                 trace\n                  (matrix_sum d\n                    (\\<lambda>k.\n                        denote (S ! k) (M k * \\<rho> * adjoint (M k)))\n                    k));\n        Suc k \\<le> n\\<rbrakk>\n       \\<Longrightarrow> trace\n                          (matrix_sum d\n                            (\\<lambda>k.\n                                adjoint (M k) * wlp (S ! k) P * M k)\n                            (Suc k) *\n                           \\<rho>) =\n                         trace\n                          (P *\n                           matrix_sum d\n                            (\\<lambda>k.\n                                denote (S ! k)\n                                 (M k * \\<rho> * adjoint (M k)))\n                            (Suc k)) +\n                         (trace\n                           (matrix_sum d\n                             (\\<lambda>k. M k * \\<rho> * adjoint (M k))\n                             (Suc k)) -\n                          trace\n                           (matrix_sum d\n                             (\\<lambda>k.\n                                 denote (S ! k)\n                                  (M k * \\<rho> * adjoint (M k)))\n                             (Suc k)))", "finally"], ["proof (chain)\npicking this:\n  trace (adjoint (M k) * wlp (S ! k) P * M k * \\<rho>) =\n  trace (P * denote (S ! k) (M k * \\<rho> * adjoint (M k))) +\n  (trace (M k * \\<rho> * adjoint (M k)) -\n   trace (denote (S ! k) (M k * \\<rho> * adjoint (M k))))", "have eq2: \"trace (adjoint (M k) * (wlp (S!k) P) * M k * \\<rho>) = trace (P * (denote (S!k) ((M k) * \\<rho> * adjoint (M k)))) + \n        (trace ((M k) * \\<rho> * adjoint (M k)) - trace (denote (S ! k) ((M k) * \\<rho> * adjoint (M k))))\""], ["proof (prove)\nusing this:\n  trace (adjoint (M k) * wlp (S ! k) P * M k * \\<rho>) =\n  trace (P * denote (S ! k) (M k * \\<rho> * adjoint (M k))) +\n  (trace (M k * \\<rho> * adjoint (M k)) -\n   trace (denote (S ! k) (M k * \\<rho> * adjoint (M k))))\n\ngoal (1 subgoal):\n 1. trace (adjoint (M k) * wlp (S ! k) P * M k * \\<rho>) =\n    trace (P * denote (S ! k) (M k * \\<rho> * adjoint (M k))) +\n    (trace (M k * \\<rho> * adjoint (M k)) -\n     trace (denote (S ! k) (M k * \\<rho> * adjoint (M k))))", "."], ["proof (state)\nthis:\n  trace (adjoint (M k) * wlp (S ! k) P * M k * \\<rho>) =\n  trace (P * denote (S ! k) (M k * \\<rho> * adjoint (M k))) +\n  (trace (M k * \\<rho> * adjoint (M k)) -\n   trace (denote (S ! k) (M k * \\<rho> * adjoint (M k))))\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k \\<le> n \\<Longrightarrow>\n                trace\n                 (matrix_sum d\n                   (\\<lambda>k. adjoint (M k) * wlp (S ! k) P * M k) k *\n                  \\<rho>) =\n                trace\n                 (P *\n                  matrix_sum d\n                   (\\<lambda>k.\n                       denote (S ! k) (M k * \\<rho> * adjoint (M k)))\n                   k) +\n                (trace\n                  (matrix_sum d (\\<lambda>k. M k * \\<rho> * adjoint (M k))\n                    k) -\n                 trace\n                  (matrix_sum d\n                    (\\<lambda>k.\n                        denote (S ! k) (M k * \\<rho> * adjoint (M k)))\n                    k));\n        Suc k \\<le> n\\<rbrakk>\n       \\<Longrightarrow> trace\n                          (matrix_sum d\n                            (\\<lambda>k.\n                                adjoint (M k) * wlp (S ! k) P * M k)\n                            (Suc k) *\n                           \\<rho>) =\n                         trace\n                          (P *\n                           matrix_sum d\n                            (\\<lambda>k.\n                                denote (S ! k)\n                                 (M k * \\<rho> * adjoint (M k)))\n                            (Suc k)) +\n                         (trace\n                           (matrix_sum d\n                             (\\<lambda>k. M k * \\<rho> * adjoint (M k))\n                             (Suc k)) -\n                          trace\n                           (matrix_sum d\n                             (\\<lambda>k.\n                                 denote (S ! k)\n                                  (M k * \\<rho> * adjoint (M k)))\n                             (Suc k)))", "have eq3: \"trace (P * matrix_sum d (\\<lambda>k. denote (S!k) (M k * \\<rho> * adjoint (M k))) (Suc k)) \n        = trace (P * (denote (S!k) (M k * \\<rho> * adjoint (M k)))) + trace (P * matrix_sum d (\\<lambda>k. denote (S!k) (M k * \\<rho> * adjoint (M k))) k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace\n     (P *\n      matrix_sum d\n       (\\<lambda>k. denote (S ! k) (M k * \\<rho> * adjoint (M k)))\n       (Suc k)) =\n    trace (P * denote (S ! k) (M k * \\<rho> * adjoint (M k))) +\n    trace\n     (P *\n      matrix_sum d\n       (\\<lambda>k. denote (S ! k) (M k * \\<rho> * adjoint (M k))) k)", "unfolding matrix_sum.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. trace\n     (P *\n      (denote (S ! k) (M k * \\<rho> * adjoint (M k)) +\n       matrix_sum d\n        (\\<lambda>k. denote (S ! k) (M k * \\<rho> * adjoint (M k))) k)) =\n    trace (P * denote (S ! k) (M k * \\<rho> * adjoint (M k))) +\n    trace\n     (P *\n      matrix_sum d\n       (\\<lambda>k. denote (S ! k) (M k * \\<rho> * adjoint (M k))) k)", "using dP dSMrk[OF k] dsSMrk[OF k]"], ["proof (prove)\nusing this:\n  P \\<in> carrier_mat d d\n  denote (S ! k) (M k * \\<rho> * adjoint (M k)) \\<in> carrier_mat d d\n  matrix_sum d (\\<lambda>k. denote (S ! k) (M k * \\<rho> * adjoint (M k))) k\n  \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. trace\n     (P *\n      (denote (S ! k) (M k * \\<rho> * adjoint (M k)) +\n       matrix_sum d\n        (\\<lambda>k. denote (S ! k) (M k * \\<rho> * adjoint (M k))) k)) =\n    trace (P * denote (S ! k) (M k * \\<rho> * adjoint (M k))) +\n    trace\n     (P *\n      matrix_sum d\n       (\\<lambda>k. denote (S ! k) (M k * \\<rho> * adjoint (M k))) k)", "by (mat_assoc d)"], ["proof (state)\nthis:\n  trace\n   (P *\n    matrix_sum d (\\<lambda>k. denote (S ! k) (M k * \\<rho> * adjoint (M k)))\n     (Suc k)) =\n  trace (P * denote (S ! k) (M k * \\<rho> * adjoint (M k))) +\n  trace\n   (P *\n    matrix_sum d (\\<lambda>k. denote (S ! k) (M k * \\<rho> * adjoint (M k)))\n     k)\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k \\<le> n \\<Longrightarrow>\n                trace\n                 (matrix_sum d\n                   (\\<lambda>k. adjoint (M k) * wlp (S ! k) P * M k) k *\n                  \\<rho>) =\n                trace\n                 (P *\n                  matrix_sum d\n                   (\\<lambda>k.\n                       denote (S ! k) (M k * \\<rho> * adjoint (M k)))\n                   k) +\n                (trace\n                  (matrix_sum d (\\<lambda>k. M k * \\<rho> * adjoint (M k))\n                    k) -\n                 trace\n                  (matrix_sum d\n                    (\\<lambda>k.\n                        denote (S ! k) (M k * \\<rho> * adjoint (M k)))\n                    k));\n        Suc k \\<le> n\\<rbrakk>\n       \\<Longrightarrow> trace\n                          (matrix_sum d\n                            (\\<lambda>k.\n                                adjoint (M k) * wlp (S ! k) P * M k)\n                            (Suc k) *\n                           \\<rho>) =\n                         trace\n                          (P *\n                           matrix_sum d\n                            (\\<lambda>k.\n                                denote (S ! k)\n                                 (M k * \\<rho> * adjoint (M k)))\n                            (Suc k)) +\n                         (trace\n                           (matrix_sum d\n                             (\\<lambda>k. M k * \\<rho> * adjoint (M k))\n                             (Suc k)) -\n                          trace\n                           (matrix_sum d\n                             (\\<lambda>k.\n                                 denote (S ! k)\n                                  (M k * \\<rho> * adjoint (M k)))\n                             (Suc k)))", "have eq4: \"trace (denote (S ! k) (M k * \\<rho> * adjoint (M k)) + matrix_sum d (\\<lambda>k. denote (S!k) (M k * \\<rho> * adjoint (M k))) k)\n        = trace (denote (S ! k) (M k * \\<rho> * adjoint (M k))) + trace (matrix_sum d (\\<lambda>k. denote (S!k) (M k * \\<rho> * adjoint (M k))) k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace\n     (denote (S ! k) (M k * \\<rho> * adjoint (M k)) +\n      matrix_sum d\n       (\\<lambda>k. denote (S ! k) (M k * \\<rho> * adjoint (M k))) k) =\n    trace (denote (S ! k) (M k * \\<rho> * adjoint (M k))) +\n    trace\n     (matrix_sum d\n       (\\<lambda>k. denote (S ! k) (M k * \\<rho> * adjoint (M k))) k)", "using dSMrk[OF k] dsSMrk[OF k]"], ["proof (prove)\nusing this:\n  denote (S ! k) (M k * \\<rho> * adjoint (M k)) \\<in> carrier_mat d d\n  matrix_sum d (\\<lambda>k. denote (S ! k) (M k * \\<rho> * adjoint (M k))) k\n  \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. trace\n     (denote (S ! k) (M k * \\<rho> * adjoint (M k)) +\n      matrix_sum d\n       (\\<lambda>k. denote (S ! k) (M k * \\<rho> * adjoint (M k))) k) =\n    trace (denote (S ! k) (M k * \\<rho> * adjoint (M k))) +\n    trace\n     (matrix_sum d\n       (\\<lambda>k. denote (S ! k) (M k * \\<rho> * adjoint (M k))) k)", "by (mat_assoc d)"], ["proof (state)\nthis:\n  trace\n   (denote (S ! k) (M k * \\<rho> * adjoint (M k)) +\n    matrix_sum d (\\<lambda>k. denote (S ! k) (M k * \\<rho> * adjoint (M k)))\n     k) =\n  trace (denote (S ! k) (M k * \\<rho> * adjoint (M k))) +\n  trace\n   (matrix_sum d (\\<lambda>k. denote (S ! k) (M k * \\<rho> * adjoint (M k)))\n     k)\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k \\<le> n \\<Longrightarrow>\n                trace\n                 (matrix_sum d\n                   (\\<lambda>k. adjoint (M k) * wlp (S ! k) P * M k) k *\n                  \\<rho>) =\n                trace\n                 (P *\n                  matrix_sum d\n                   (\\<lambda>k.\n                       denote (S ! k) (M k * \\<rho> * adjoint (M k)))\n                   k) +\n                (trace\n                  (matrix_sum d (\\<lambda>k. M k * \\<rho> * adjoint (M k))\n                    k) -\n                 trace\n                  (matrix_sum d\n                    (\\<lambda>k.\n                        denote (S ! k) (M k * \\<rho> * adjoint (M k)))\n                    k));\n        Suc k \\<le> n\\<rbrakk>\n       \\<Longrightarrow> trace\n                          (matrix_sum d\n                            (\\<lambda>k.\n                                adjoint (M k) * wlp (S ! k) P * M k)\n                            (Suc k) *\n                           \\<rho>) =\n                         trace\n                          (P *\n                           matrix_sum d\n                            (\\<lambda>k.\n                                denote (S ! k)\n                                 (M k * \\<rho> * adjoint (M k)))\n                            (Suc k)) +\n                         (trace\n                           (matrix_sum d\n                             (\\<lambda>k. M k * \\<rho> * adjoint (M k))\n                             (Suc k)) -\n                          trace\n                           (matrix_sum d\n                             (\\<lambda>k.\n                                 denote (S ! k)\n                                  (M k * \\<rho> * adjoint (M k)))\n                             (Suc k)))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. trace\n     (matrix_sum d (\\<lambda>k. adjoint (M k) * wlp (S ! k) P * M k)\n       (Suc k) *\n      \\<rho>) =\n    trace\n     (P *\n      matrix_sum d\n       (\\<lambda>k. denote (S ! k) (M k * \\<rho> * adjoint (M k)))\n       (Suc k)) +\n    (trace\n      (matrix_sum d (\\<lambda>k. M k * \\<rho> * adjoint (M k)) (Suc k)) -\n     trace\n      (matrix_sum d\n        (\\<lambda>k. denote (S ! k) (M k * \\<rho> * adjoint (M k)))\n        (Suc k)))", "apply (subst eq1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. trace (adjoint (M k) * wlp (S ! k) P * M k * \\<rho>) +\n    trace\n     (matrix_sum d (\\<lambda>k. adjoint (M k) * wlp (S ! k) P * M k) k *\n      \\<rho>) =\n    trace\n     (P *\n      matrix_sum d\n       (\\<lambda>k. denote (S ! k) (M k * \\<rho> * adjoint (M k)))\n       (Suc k)) +\n    (trace\n      (matrix_sum d (\\<lambda>k. M k * \\<rho> * adjoint (M k)) (Suc k)) -\n     trace\n      (matrix_sum d\n        (\\<lambda>k. denote (S ! k) (M k * \\<rho> * adjoint (M k)))\n        (Suc k)))", "apply (subst eq3)"], ["proof (prove)\ngoal (1 subgoal):\n 1. trace (adjoint (M k) * wlp (S ! k) P * M k * \\<rho>) +\n    trace\n     (matrix_sum d (\\<lambda>k. adjoint (M k) * wlp (S ! k) P * M k) k *\n      \\<rho>) =\n    trace (P * denote (S ! k) (M k * \\<rho> * adjoint (M k))) +\n    trace\n     (P *\n      matrix_sum d\n       (\\<lambda>k. denote (S ! k) (M k * \\<rho> * adjoint (M k))) k) +\n    (trace\n      (matrix_sum d (\\<lambda>k. M k * \\<rho> * adjoint (M k)) (Suc k)) -\n     trace\n      (matrix_sum d\n        (\\<lambda>k. denote (S ! k) (M k * \\<rho> * adjoint (M k)))\n        (Suc k)))", "apply (simp del: less_eq_complex_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. trace (adjoint (M k) * wlp (S ! k) P * M k * \\<rho>) +\n    trace\n     (matrix_sum d (\\<lambda>k. adjoint (M k) * wlp (S ! k) P * M k) k *\n      \\<rho>) =\n    trace (P * denote (S ! k) (M k * \\<rho> * adjoint (M k))) +\n    trace\n     (P *\n      matrix_sum d\n       (\\<lambda>k. denote (S ! k) (M k * \\<rho> * adjoint (M k))) k) +\n    (trace\n      (M k * \\<rho> * adjoint (M k) +\n       matrix_sum d (\\<lambda>k. M k * \\<rho> * adjoint (M k)) k) -\n     trace\n      (denote (S ! k) (M k * \\<rho> * adjoint (M k)) +\n       matrix_sum d\n        (\\<lambda>k. denote (S ! k) (M k * \\<rho> * adjoint (M k))) k))", "apply (subst trace_add_linear[of \"M k * \\<rho> * adjoint (M k)\" d \"matrix_sum d (\\<lambda>k. M k * \\<rho> * adjoint (M k)) k\"])"], ["proof (prove)\ngoal (3 subgoals):\n 1. M k * \\<rho> * adjoint (M k) \\<in> carrier_mat d d\n 2. matrix_sum d (\\<lambda>k. M k * \\<rho> * adjoint (M k)) k\n    \\<in> carrier_mat d d\n 3. trace (adjoint (M k) * wlp (S ! k) P * M k * \\<rho>) +\n    trace\n     (matrix_sum d (\\<lambda>k. adjoint (M k) * wlp (S ! k) P * M k) k *\n      \\<rho>) =\n    trace (P * denote (S ! k) (M k * \\<rho> * adjoint (M k))) +\n    trace\n     (P *\n      matrix_sum d\n       (\\<lambda>k. denote (S ! k) (M k * \\<rho> * adjoint (M k))) k) +\n    (trace (M k * \\<rho> * adjoint (M k)) +\n     trace (matrix_sum d (\\<lambda>k. M k * \\<rho> * adjoint (M k)) k) -\n     trace\n      (denote (S ! k) (M k * \\<rho> * adjoint (M k)) +\n       matrix_sum d\n        (\\<lambda>k. denote (S ! k) (M k * \\<rho> * adjoint (M k))) k))", "apply (simp add: dMk adjoint_dim[OF dMk] dr mult_carrier_mat[of _ d d _ d] k)"], ["proof (prove)\ngoal (2 subgoals):\n 1. matrix_sum d (\\<lambda>k. M k * \\<rho> * adjoint (M k)) k\n    \\<in> carrier_mat d d\n 2. trace (adjoint (M k) * wlp (S ! k) P * M k * \\<rho>) +\n    trace\n     (matrix_sum d (\\<lambda>k. adjoint (M k) * wlp (S ! k) P * M k) k *\n      \\<rho>) =\n    trace (P * denote (S ! k) (M k * \\<rho> * adjoint (M k))) +\n    trace\n     (P *\n      matrix_sum d\n       (\\<lambda>k. denote (S ! k) (M k * \\<rho> * adjoint (M k))) k) +\n    (trace (M k * \\<rho> * adjoint (M k)) +\n     trace (matrix_sum d (\\<lambda>k. M k * \\<rho> * adjoint (M k)) k) -\n     trace\n      (denote (S ! k) (M k * \\<rho> * adjoint (M k)) +\n       matrix_sum d\n        (\\<lambda>k. denote (S ! k) (M k * \\<rho> * adjoint (M k))) k))", "apply (simp add: dsMrk k)"], ["proof (prove)\ngoal (1 subgoal):\n 1. trace (adjoint (M k) * wlp (S ! k) P * M k * \\<rho>) +\n    trace\n     (matrix_sum d (\\<lambda>k. adjoint (M k) * wlp (S ! k) P * M k) k *\n      \\<rho>) =\n    trace (P * denote (S ! k) (M k * \\<rho> * adjoint (M k))) +\n    trace\n     (P *\n      matrix_sum d\n       (\\<lambda>k. denote (S ! k) (M k * \\<rho> * adjoint (M k))) k) +\n    (trace (M k * \\<rho> * adjoint (M k)) +\n     trace (matrix_sum d (\\<lambda>k. M k * \\<rho> * adjoint (M k)) k) -\n     trace\n      (denote (S ! k) (M k * \\<rho> * adjoint (M k)) +\n       matrix_sum d\n        (\\<lambda>k. denote (S ! k) (M k * \\<rho> * adjoint (M k))) k))", "apply (subst eq4)"], ["proof (prove)\ngoal (1 subgoal):\n 1. trace (adjoint (M k) * wlp (S ! k) P * M k * \\<rho>) +\n    trace\n     (matrix_sum d (\\<lambda>k. adjoint (M k) * wlp (S ! k) P * M k) k *\n      \\<rho>) =\n    trace (P * denote (S ! k) (M k * \\<rho> * adjoint (M k))) +\n    trace\n     (P *\n      matrix_sum d\n       (\\<lambda>k. denote (S ! k) (M k * \\<rho> * adjoint (M k))) k) +\n    (trace (M k * \\<rho> * adjoint (M k)) +\n     trace (matrix_sum d (\\<lambda>k. M k * \\<rho> * adjoint (M k)) k) -\n     (trace (denote (S ! k) (M k * \\<rho> * adjoint (M k))) +\n      trace\n       (matrix_sum d\n         (\\<lambda>k. denote (S ! k) (M k * \\<rho> * adjoint (M k))) k)))", "apply (insert eq2 Suc(1) k, fastforce)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  trace\n   (matrix_sum d (\\<lambda>k. adjoint (M k) * wlp (S ! k) P * M k) (Suc k) *\n    \\<rho>) =\n  trace\n   (P *\n    matrix_sum d (\\<lambda>k. denote (S ! k) (M k * \\<rho> * adjoint (M k)))\n     (Suc k)) +\n  (trace (matrix_sum d (\\<lambda>k. M k * \\<rho> * adjoint (M k)) (Suc k)) -\n   trace\n    (matrix_sum d\n      (\\<lambda>k. denote (S ! k) (M k * \\<rho> * adjoint (M k))) (Suc k)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?k \\<le> n \\<Longrightarrow>\n  trace\n   (matrix_sum d (\\<lambda>k. adjoint (M k) * wlp (S ! k) P * M k) ?k *\n    \\<rho>) =\n  trace (P * denote (Measure ?k M S) \\<rho>) +\n  (trace (matrix_sum d (\\<lambda>k. M k * \\<rho> * adjoint (M k)) ?k) -\n   trace (denote (Measure ?k M S) \\<rho>))\n\ngoal (2 subgoals):\n 1. \\<And>x1 x2a x3 P.\n       \\<lbrakk>\\<And>x3a P.\n                   \\<lbrakk>x3a \\<in> set x3; well_com x3a;\n                    is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n  trace (wlp x3a P * \\<rho>) =\n  trace (P * denote x3a \\<rho>) + trace \\<rho> - trace (denote x3a \\<rho>);\n        well_com (Measure x1 x2a x3); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                            trace (wlp (Measure x1 x2a x3) P * \\<rho>) =\n                            trace (P * denote (Measure x1 x2a x3) \\<rho>) +\n                            trace \\<rho> -\n                            trace (denote (Measure x1 x2a x3) \\<rho>)\n 2. \\<And>x1 S P.\n       \\<lbrakk>\\<And>P.\n                   \\<lbrakk>well_com S; is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n  trace (wlp S P * \\<rho>) =\n  trace (P * denote S \\<rho>) + trace \\<rho> - trace (denote S \\<rho>);\n        well_com (While x1 S); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                            trace (wlp (While x1 S) P * \\<rho>) =\n                            trace (P * denote (While x1 S) \\<rho>) +\n                            trace \\<rho> -\n                            trace (denote (While x1 S) \\<rho>)", "then"], ["proof (chain)\npicking this:\n  ?k \\<le> n \\<Longrightarrow>\n  trace\n   (matrix_sum d (\\<lambda>k. adjoint (M k) * wlp (S ! k) P * M k) ?k *\n    \\<rho>) =\n  trace (P * denote (Measure ?k M S) \\<rho>) +\n  (trace (matrix_sum d (\\<lambda>k. M k * \\<rho> * adjoint (M k)) ?k) -\n   trace (denote (Measure ?k M S) \\<rho>))", "have leq: \"trace (matrix_sum d (\\<lambda>k. adjoint (M k) * (wlp (S!k) P) * M k) n * \\<rho>)\n       = trace (P * denote (Measure n M S) \\<rho>) + \n          (trace (matrix_sum d (\\<lambda>k. (M k) * \\<rho> * adjoint (M k)) n) - trace (denote (Measure n M S) \\<rho>))\""], ["proof (prove)\nusing this:\n  ?k \\<le> n \\<Longrightarrow>\n  trace\n   (matrix_sum d (\\<lambda>k. adjoint (M k) * wlp (S ! k) P * M k) ?k *\n    \\<rho>) =\n  trace (P * denote (Measure ?k M S) \\<rho>) +\n  (trace (matrix_sum d (\\<lambda>k. M k * \\<rho> * adjoint (M k)) ?k) -\n   trace (denote (Measure ?k M S) \\<rho>))\n\ngoal (1 subgoal):\n 1. trace\n     (matrix_sum d (\\<lambda>k. adjoint (M k) * wlp (S ! k) P * M k) n *\n      \\<rho>) =\n    trace (P * denote (Measure n M S) \\<rho>) +\n    (trace (matrix_sum d (\\<lambda>k. M k * \\<rho> * adjoint (M k)) n) -\n     trace (denote (Measure n M S) \\<rho>))", "by auto"], ["proof (state)\nthis:\n  trace\n   (matrix_sum d (\\<lambda>k. adjoint (M k) * wlp (S ! k) P * M k) n *\n    \\<rho>) =\n  trace (P * denote (Measure n M S) \\<rho>) +\n  (trace (matrix_sum d (\\<lambda>k. M k * \\<rho> * adjoint (M k)) n) -\n   trace (denote (Measure n M S) \\<rho>))\n\ngoal (2 subgoals):\n 1. \\<And>x1 x2a x3 P.\n       \\<lbrakk>\\<And>x3a P.\n                   \\<lbrakk>x3a \\<in> set x3; well_com x3a;\n                    is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n  trace (wlp x3a P * \\<rho>) =\n  trace (P * denote x3a \\<rho>) + trace \\<rho> - trace (denote x3a \\<rho>);\n        well_com (Measure x1 x2a x3); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                            trace (wlp (Measure x1 x2a x3) P * \\<rho>) =\n                            trace (P * denote (Measure x1 x2a x3) \\<rho>) +\n                            trace \\<rho> -\n                            trace (denote (Measure x1 x2a x3) \\<rho>)\n 2. \\<And>x1 S P.\n       \\<lbrakk>\\<And>P.\n                   \\<lbrakk>well_com S; is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n  trace (wlp S P * \\<rho>) =\n  trace (P * denote S \\<rho>) + trace \\<rho> - trace (denote S \\<rho>);\n        well_com (While x1 S); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                            trace (wlp (While x1 S) P * \\<rho>) =\n                            trace (P * denote (While x1 S) \\<rho>) +\n                            trace \\<rho> -\n                            trace (denote (While x1 S) \\<rho>)", "have \"trace (matrix_sum d (\\<lambda>k. (M k) * \\<rho> * adjoint (M k)) n) = trace \\<rho>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace (matrix_sum d (\\<lambda>k. M k * \\<rho> * adjoint (M k)) n) =\n    trace \\<rho>", "using trace_measurement m dr"], ["proof (prove)\nusing this:\n  \\<lbrakk>measurement ?d ?n ?M; ?A \\<in> carrier_mat ?d ?d\\<rbrakk>\n  \\<Longrightarrow> trace\n                     (matrix_sum ?d (\\<lambda>k. ?M k * ?A * adjoint (?M k))\n                       ?n) =\n                    trace ?A\n  measurement d n M\n  \\<rho> \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. trace (matrix_sum d (\\<lambda>k. M k * \\<rho> * adjoint (M k)) n) =\n    trace \\<rho>", "by auto"], ["proof (state)\nthis:\n  trace (matrix_sum d (\\<lambda>k. M k * \\<rho> * adjoint (M k)) n) =\n  trace \\<rho>\n\ngoal (2 subgoals):\n 1. \\<And>x1 x2a x3 P.\n       \\<lbrakk>\\<And>x3a P.\n                   \\<lbrakk>x3a \\<in> set x3; well_com x3a;\n                    is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n  trace (wlp x3a P * \\<rho>) =\n  trace (P * denote x3a \\<rho>) + trace \\<rho> - trace (denote x3a \\<rho>);\n        well_com (Measure x1 x2a x3); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                            trace (wlp (Measure x1 x2a x3) P * \\<rho>) =\n                            trace (P * denote (Measure x1 x2a x3) \\<rho>) +\n                            trace \\<rho> -\n                            trace (denote (Measure x1 x2a x3) \\<rho>)\n 2. \\<And>x1 S P.\n       \\<lbrakk>\\<And>P.\n                   \\<lbrakk>well_com S; is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n  trace (wlp S P * \\<rho>) =\n  trace (P * denote S \\<rho>) + trace \\<rho> - trace (denote S \\<rho>);\n        well_com (While x1 S); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                            trace (wlp (While x1 S) P * \\<rho>) =\n                            trace (P * denote (While x1 S) \\<rho>) +\n                            trace \\<rho> -\n                            trace (denote (While x1 S) \\<rho>)", "with leq"], ["proof (chain)\npicking this:\n  trace\n   (matrix_sum d (\\<lambda>k. adjoint (M k) * wlp (S ! k) P * M k) n *\n    \\<rho>) =\n  trace (P * denote (Measure n M S) \\<rho>) +\n  (trace (matrix_sum d (\\<lambda>k. M k * \\<rho> * adjoint (M k)) n) -\n   trace (denote (Measure n M S) \\<rho>))\n  trace (matrix_sum d (\\<lambda>k. M k * \\<rho> * adjoint (M k)) n) =\n  trace \\<rho>", "have \"trace (matrix_sum d (\\<lambda>k. adjoint (M k) * (wlp (S!k) P) * M k) n * \\<rho>)\n       = trace (P * denote (Measure n M S) \\<rho>) + (trace \\<rho> - trace (denote (Measure n M S) \\<rho>))\""], ["proof (prove)\nusing this:\n  trace\n   (matrix_sum d (\\<lambda>k. adjoint (M k) * wlp (S ! k) P * M k) n *\n    \\<rho>) =\n  trace (P * denote (Measure n M S) \\<rho>) +\n  (trace (matrix_sum d (\\<lambda>k. M k * \\<rho> * adjoint (M k)) n) -\n   trace (denote (Measure n M S) \\<rho>))\n  trace (matrix_sum d (\\<lambda>k. M k * \\<rho> * adjoint (M k)) n) =\n  trace \\<rho>\n\ngoal (1 subgoal):\n 1. trace\n     (matrix_sum d (\\<lambda>k. adjoint (M k) * wlp (S ! k) P * M k) n *\n      \\<rho>) =\n    trace (P * denote (Measure n M S) \\<rho>) +\n    (trace \\<rho> - trace (denote (Measure n M S) \\<rho>))", "unfolding denote_measure_def"], ["proof (prove)\nusing this:\n  trace\n   (matrix_sum d (\\<lambda>k. adjoint (M k) * wlp (S ! k) P * M k) n *\n    \\<rho>) =\n  trace (P * denote (Measure n M S) \\<rho>) +\n  (trace (matrix_sum d (\\<lambda>k. M k * \\<rho> * adjoint (M k)) n) -\n   trace (denote (Measure n M S) \\<rho>))\n  trace (matrix_sum d (\\<lambda>k. M k * \\<rho> * adjoint (M k)) n) =\n  trace \\<rho>\n\ngoal (1 subgoal):\n 1. trace\n     (matrix_sum d (\\<lambda>k. adjoint (M k) * wlp (S ! k) P * M k) n *\n      \\<rho>) =\n    trace (P * denote (Measure n M S) \\<rho>) +\n    (trace \\<rho> - trace (denote (Measure n M S) \\<rho>))", "by auto"], ["proof (state)\nthis:\n  trace\n   (matrix_sum d (\\<lambda>k. adjoint (M k) * wlp (S ! k) P * M k) n *\n    \\<rho>) =\n  trace (P * denote (Measure n M S) \\<rho>) +\n  (trace \\<rho> - trace (denote (Measure n M S) \\<rho>))\n\ngoal (2 subgoals):\n 1. \\<And>x1 x2a x3 P.\n       \\<lbrakk>\\<And>x3a P.\n                   \\<lbrakk>x3a \\<in> set x3; well_com x3a;\n                    is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n  trace (wlp x3a P * \\<rho>) =\n  trace (P * denote x3a \\<rho>) + trace \\<rho> - trace (denote x3a \\<rho>);\n        well_com (Measure x1 x2a x3); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                            trace (wlp (Measure x1 x2a x3) P * \\<rho>) =\n                            trace (P * denote (Measure x1 x2a x3) \\<rho>) +\n                            trace \\<rho> -\n                            trace (denote (Measure x1 x2a x3) \\<rho>)\n 2. \\<And>x1 S P.\n       \\<lbrakk>\\<And>P.\n                   \\<lbrakk>well_com S; is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n  trace (wlp S P * \\<rho>) =\n  trace (P * denote S \\<rho>) + trace \\<rho> - trace (denote S \\<rho>);\n        well_com (While x1 S); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                            trace (wlp (While x1 S) P * \\<rho>) =\n                            trace (P * denote (While x1 S) \\<rho>) +\n                            trace \\<rho> -\n                            trace (denote (While x1 S) \\<rho>)", "}"], ["proof (state)\nthis:\n  ?\\<rho>2 \\<in> density_states \\<Longrightarrow>\n  trace\n   (matrix_sum d (\\<lambda>k. adjoint (M k) * wlp (S ! k) P * M k) n *\n    ?\\<rho>2) =\n  trace (P * denote (Measure n M S) ?\\<rho>2) +\n  (trace ?\\<rho>2 - trace (denote (Measure n M S) ?\\<rho>2))\n\ngoal (2 subgoals):\n 1. \\<And>x1 x2a x3 P.\n       \\<lbrakk>\\<And>x3a P.\n                   \\<lbrakk>x3a \\<in> set x3; well_com x3a;\n                    is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n  trace (wlp x3a P * \\<rho>) =\n  trace (P * denote x3a \\<rho>) + trace \\<rho> - trace (denote x3a \\<rho>);\n        well_com (Measure x1 x2a x3); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                            trace (wlp (Measure x1 x2a x3) P * \\<rho>) =\n                            trace (P * denote (Measure x1 x2a x3) \\<rho>) +\n                            trace \\<rho> -\n                            trace (denote (Measure x1 x2a x3) \\<rho>)\n 2. \\<And>x1 S P.\n       \\<lbrakk>\\<And>P.\n                   \\<lbrakk>well_com S; is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n  trace (wlp S P * \\<rho>) =\n  trace (P * denote S \\<rho>) + trace \\<rho> - trace (denote S \\<rho>);\n        well_com (While x1 S); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                            trace (wlp (While x1 S) P * \\<rho>) =\n                            trace (P * denote (While x1 S) \\<rho>) +\n                            trace \\<rho> -\n                            trace (denote (While x1 S) \\<rho>)", "then"], ["proof (chain)\npicking this:\n  ?\\<rho>2 \\<in> density_states \\<Longrightarrow>\n  trace\n   (matrix_sum d (\\<lambda>k. adjoint (M k) * wlp (S ! k) P * M k) n *\n    ?\\<rho>2) =\n  trace (P * denote (Measure n M S) ?\\<rho>2) +\n  (trace ?\\<rho>2 - trace (denote (Measure n M S) ?\\<rho>2))", "show ?case"], ["proof (prove)\nusing this:\n  ?\\<rho>2 \\<in> density_states \\<Longrightarrow>\n  trace\n   (matrix_sum d (\\<lambda>k. adjoint (M k) * wlp (S ! k) P * M k) n *\n    ?\\<rho>2) =\n  trace (P * denote (Measure n M S) ?\\<rho>2) +\n  (trace ?\\<rho>2 - trace (denote (Measure n M S) ?\\<rho>2))\n\ngoal (1 subgoal):\n 1. \\<forall>\\<rho>\\<in>density_states.\n       trace (wlp (Measure n M S) P * \\<rho>) =\n       trace (P * denote (Measure n M S) \\<rho>) + trace \\<rho> -\n       trace (denote (Measure n M S) \\<rho>)", "unfolding wlp_measure_expand[OF wc]"], ["proof (prove)\nusing this:\n  ?\\<rho>2 \\<in> density_states \\<Longrightarrow>\n  trace\n   (matrix_sum d (\\<lambda>k. adjoint (M k) * wlp (S ! k) P * M k) n *\n    ?\\<rho>2) =\n  trace (P * denote (Measure n M S) ?\\<rho>2) +\n  (trace ?\\<rho>2 - trace (denote (Measure n M S) ?\\<rho>2))\n\ngoal (1 subgoal):\n 1. \\<forall>\\<rho>\\<in>density_states.\n       trace\n        (matrix_sum d (\\<lambda>k. adjoint (M k) * wlp (S ! k) P * M k) n *\n         \\<rho>) =\n       trace (P * denote (Measure n M S) \\<rho>) + trace \\<rho> -\n       trace (denote (Measure n M S) \\<rho>)", "by auto"], ["proof (state)\nthis:\n  \\<forall>\\<rho>\\<in>density_states.\n     trace (wlp (Measure n M S) P * \\<rho>) =\n     trace (P * denote (Measure n M S) \\<rho>) + trace \\<rho> -\n     trace (denote (Measure n M S) \\<rho>)\n\ngoal (1 subgoal):\n 1. \\<And>x1 S P.\n       \\<lbrakk>\\<And>P.\n                   \\<lbrakk>well_com S; is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n  trace (wlp S P * \\<rho>) =\n  trace (P * denote S \\<rho>) + trace \\<rho> - trace (denote S \\<rho>);\n        well_com (While x1 S); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                            trace (wlp (While x1 S) P * \\<rho>) =\n                            trace (P * denote (While x1 S) \\<rho>) +\n                            trace \\<rho> -\n                            trace (denote (While x1 S) \\<rho>)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1 S P.\n       \\<lbrakk>\\<And>P.\n                   \\<lbrakk>well_com S; is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n  trace (wlp S P * \\<rho>) =\n  trace (P * denote S \\<rho>) + trace \\<rho> - trace (denote S \\<rho>);\n        well_com (While x1 S); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                            trace (wlp (While x1 S) P * \\<rho>) =\n                            trace (P * denote (While x1 S) \\<rho>) +\n                            trace \\<rho> -\n                            trace (denote (While x1 S) \\<rho>)", "case (While M S)"], ["proof (state)\nthis:\n  \\<lbrakk>well_com S; is_quantum_predicate ?P\\<rbrakk>\n  \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                       trace (wlp S ?P * \\<rho>) =\n                       trace (?P * denote S \\<rho>) + trace \\<rho> -\n                       trace (denote S \\<rho>)\n  well_com (While M S)\n  is_quantum_predicate P\n\ngoal (1 subgoal):\n 1. \\<And>x1 S P.\n       \\<lbrakk>\\<And>P.\n                   \\<lbrakk>well_com S; is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n  trace (wlp S P * \\<rho>) =\n  trace (P * denote S \\<rho>) + trace \\<rho> - trace (denote S \\<rho>);\n        well_com (While x1 S); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                            trace (wlp (While x1 S) P * \\<rho>) =\n                            trace (P * denote (While x1 S) \\<rho>) +\n                            trace \\<rho> -\n                            trace (denote (While x1 S) \\<rho>)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>well_com S; is_quantum_predicate ?P\\<rbrakk>\n  \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                       trace (wlp S ?P * \\<rho>) =\n                       trace (?P * denote S \\<rho>) + trace \\<rho> -\n                       trace (denote S \\<rho>)\n  well_com (While M S)\n  is_quantum_predicate P", "have qpP: \"is_quantum_predicate P\" and dP: \"P \\<in> carrier_mat d d\" \n    and wcS: \"well_com S\" and m: \"measurement d 2 M\" and wc: \"well_com (While M S)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>well_com S; is_quantum_predicate ?P\\<rbrakk>\n  \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                       trace (wlp S ?P * \\<rho>) =\n                       trace (?P * denote S \\<rho>) + trace \\<rho> -\n                       trace (denote S \\<rho>)\n  well_com (While M S)\n  is_quantum_predicate P\n\ngoal (1 subgoal):\n 1. (is_quantum_predicate P &&& P \\<in> carrier_mat d d) &&&\n    well_com S &&& measurement d 2 M &&& well_com (While M S)", "using is_quantum_predicate_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>well_com S; is_quantum_predicate ?P\\<rbrakk>\n  \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                       trace (wlp S ?P * \\<rho>) =\n                       trace (?P * denote S \\<rho>) + trace \\<rho> -\n                       trace (denote S \\<rho>)\n  well_com (While M S)\n  is_quantum_predicate P\n  is_quantum_predicate ?P =\n  (?P \\<in> carrier_mat d d \\<and>\n   positive ?P \\<and> ?P \\<le>\\<^sub>L 1\\<^sub>m d)\n\ngoal (1 subgoal):\n 1. (is_quantum_predicate P &&& P \\<in> carrier_mat d d) &&&\n    well_com S &&& measurement d 2 M &&& well_com (While M S)", "by auto"], ["proof (state)\nthis:\n  is_quantum_predicate P\n  P \\<in> carrier_mat d d\n  well_com S\n  measurement d 2 M\n  well_com (While M S)\n\ngoal (1 subgoal):\n 1. \\<And>x1 S P.\n       \\<lbrakk>\\<And>P.\n                   \\<lbrakk>well_com S; is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n  trace (wlp S P * \\<rho>) =\n  trace (P * denote S \\<rho>) + trace \\<rho> - trace (denote S \\<rho>);\n        well_com (While x1 S); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                            trace (wlp (While x1 S) P * \\<rho>) =\n                            trace (P * denote (While x1 S) \\<rho>) +\n                            trace \\<rho> -\n                            trace (denote (While x1 S) \\<rho>)", "define M0 where \"M0 = M 0\""], ["proof (state)\nthis:\n  M0 = M 0\n\ngoal (1 subgoal):\n 1. \\<And>x1 S P.\n       \\<lbrakk>\\<And>P.\n                   \\<lbrakk>well_com S; is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n  trace (wlp S P * \\<rho>) =\n  trace (P * denote S \\<rho>) + trace \\<rho> - trace (denote S \\<rho>);\n        well_com (While x1 S); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                            trace (wlp (While x1 S) P * \\<rho>) =\n                            trace (P * denote (While x1 S) \\<rho>) +\n                            trace \\<rho> -\n                            trace (denote (While x1 S) \\<rho>)", "define M1 where \"M1 = M 1\""], ["proof (state)\nthis:\n  M1 = M 1\n\ngoal (1 subgoal):\n 1. \\<And>x1 S P.\n       \\<lbrakk>\\<And>P.\n                   \\<lbrakk>well_com S; is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n  trace (wlp S P * \\<rho>) =\n  trace (P * denote S \\<rho>) + trace \\<rho> - trace (denote S \\<rho>);\n        well_com (While x1 S); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                            trace (wlp (While x1 S) P * \\<rho>) =\n                            trace (P * denote (While x1 S) \\<rho>) +\n                            trace \\<rho> -\n                            trace (denote (While x1 S) \\<rho>)", "have dM0: \"M0 \\<in> carrier_mat d d\" and dM1: \"M1 \\<in> carrier_mat d d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M0 \\<in> carrier_mat d d &&& M1 \\<in> carrier_mat d d", "using m measurement_def M0_def M1_def"], ["proof (prove)\nusing this:\n  measurement d 2 M\n  measurement ?d ?n ?M =\n  ((\\<forall>j<?n. ?M j \\<in> carrier_mat ?d ?d) \\<and>\n   matrix_sum ?d (\\<lambda>j. adjoint (?M j) * ?M j) ?n = 1\\<^sub>m ?d)\n  M0 = M 0\n  M1 = M 1\n\ngoal (1 subgoal):\n 1. M0 \\<in> carrier_mat d d &&& M1 \\<in> carrier_mat d d", "by auto"], ["proof (state)\nthis:\n  M0 \\<in> carrier_mat d d\n  M1 \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. \\<And>x1 S P.\n       \\<lbrakk>\\<And>P.\n                   \\<lbrakk>well_com S; is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n  trace (wlp S P * \\<rho>) =\n  trace (P * denote S \\<rho>) + trace \\<rho> - trace (denote S \\<rho>);\n        well_com (While x1 S); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                            trace (wlp (While x1 S) P * \\<rho>) =\n                            trace (P * denote (While x1 S) \\<rho>) +\n                            trace \\<rho> -\n                            trace (denote (While x1 S) \\<rho>)", "have leM1: \"adjoint M1 * M1 \\<le>\\<^sub>L 1\\<^sub>m d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adjoint M1 * M1 \\<le>\\<^sub>L 1\\<^sub>m d", "using measurement_le_one_mat m M1_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>measurement ?d ?n ?f; ?j < ?n\\<rbrakk>\n  \\<Longrightarrow> adjoint (?f ?j) * ?f ?j \\<le>\\<^sub>L 1\\<^sub>m ?d\n  measurement d 2 M\n  M1 = M 1\n\ngoal (1 subgoal):\n 1. adjoint M1 * M1 \\<le>\\<^sub>L 1\\<^sub>m d", "by auto"], ["proof (state)\nthis:\n  adjoint M1 * M1 \\<le>\\<^sub>L 1\\<^sub>m d\n\ngoal (1 subgoal):\n 1. \\<And>x1 S P.\n       \\<lbrakk>\\<And>P.\n                   \\<lbrakk>well_com S; is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n  trace (wlp S P * \\<rho>) =\n  trace (P * denote S \\<rho>) + trace \\<rho> - trace (denote S \\<rho>);\n        well_com (While x1 S); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                            trace (wlp (While x1 S) P * \\<rho>) =\n                            trace (P * denote (While x1 S) \\<rho>) +\n                            trace \\<rho> -\n                            trace (denote (While x1 S) \\<rho>)", "define W where \"W k = wlp_while_n M0 M1 (wlp S) k P\" for k"], ["proof (state)\nthis:\n  W ?k = wlp_while_n M0 M1 (wlp S) ?k P\n\ngoal (1 subgoal):\n 1. \\<And>x1 S P.\n       \\<lbrakk>\\<And>P.\n                   \\<lbrakk>well_com S; is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n  trace (wlp S P * \\<rho>) =\n  trace (P * denote S \\<rho>) + trace \\<rho> - trace (denote S \\<rho>);\n        well_com (While x1 S); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                            trace (wlp (While x1 S) P * \\<rho>) =\n                            trace (P * denote (While x1 S) \\<rho>) +\n                            trace \\<rho> -\n                            trace (denote (While x1 S) \\<rho>)", "define DS where \"DS = denote S\""], ["proof (state)\nthis:\n  DS = denote S\n\ngoal (1 subgoal):\n 1. \\<And>x1 S P.\n       \\<lbrakk>\\<And>P.\n                   \\<lbrakk>well_com S; is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n  trace (wlp S P * \\<rho>) =\n  trace (P * denote S \\<rho>) + trace \\<rho> - trace (denote S \\<rho>);\n        well_com (While x1 S); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                            trace (wlp (While x1 S) P * \\<rho>) =\n                            trace (P * denote (While x1 S) \\<rho>) +\n                            trace \\<rho> -\n                            trace (denote (While x1 S) \\<rho>)", "define D0 where \"D0 = denote_while_n M0 M1 DS\""], ["proof (state)\nthis:\n  D0 = denote_while_n M0 M1 DS\n\ngoal (1 subgoal):\n 1. \\<And>x1 S P.\n       \\<lbrakk>\\<And>P.\n                   \\<lbrakk>well_com S; is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n  trace (wlp S P * \\<rho>) =\n  trace (P * denote S \\<rho>) + trace \\<rho> - trace (denote S \\<rho>);\n        well_com (While x1 S); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                            trace (wlp (While x1 S) P * \\<rho>) =\n                            trace (P * denote (While x1 S) \\<rho>) +\n                            trace \\<rho> -\n                            trace (denote (While x1 S) \\<rho>)", "define D1 where \"D1 = denote_while_n_comp M0 M1 DS\""], ["proof (state)\nthis:\n  D1 = denote_while_n_comp M0 M1 DS\n\ngoal (1 subgoal):\n 1. \\<And>x1 S P.\n       \\<lbrakk>\\<And>P.\n                   \\<lbrakk>well_com S; is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n  trace (wlp S P * \\<rho>) =\n  trace (P * denote S \\<rho>) + trace \\<rho> - trace (denote S \\<rho>);\n        well_com (While x1 S); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                            trace (wlp (While x1 S) P * \\<rho>) =\n                            trace (P * denote (While x1 S) \\<rho>) +\n                            trace \\<rho> -\n                            trace (denote (While x1 S) \\<rho>)", "define D where \"D = denote_while_n_iter M0 M1 DS\""], ["proof (state)\nthis:\n  D = denote_while_n_iter M0 M1 DS\n\ngoal (1 subgoal):\n 1. \\<And>x1 S P.\n       \\<lbrakk>\\<And>P.\n                   \\<lbrakk>well_com S; is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n  trace (wlp S P * \\<rho>) =\n  trace (P * denote S \\<rho>) + trace \\<rho> - trace (denote S \\<rho>);\n        well_com (While x1 S); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                            trace (wlp (While x1 S) P * \\<rho>) =\n                            trace (P * denote (While x1 S) \\<rho>) +\n                            trace \\<rho> -\n                            trace (denote (While x1 S) \\<rho>)", "have eqk: \"\\<rho> \\<in> density_states \\<Longrightarrow> trace ((W k) * \\<rho>) = (\\<Sum>k=0..<k. trace (P * (D0 k \\<rho>))) + trace \\<rho> - (\\<Sum>k=0..<k. trace (D0 k \\<rho>))\" for k \\<rho>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<rho> \\<in> density_states \\<Longrightarrow>\n    trace (W k * \\<rho>) =\n    (\\<Sum>k = 0..<k. trace (P * D0 k \\<rho>)) + trace \\<rho> -\n    (\\<Sum>k = 0..<k. trace (D0 k \\<rho>))", "proof (induct k arbitrary: \\<rho>)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>\\<rho>.\n       \\<rho> \\<in> density_states \\<Longrightarrow>\n       trace (W 0 * \\<rho>) =\n       (\\<Sum>k = 0..<0. trace (P * D0 k \\<rho>)) + trace \\<rho> -\n       (\\<Sum>k = 0..<0. trace (D0 k \\<rho>))\n 2. \\<And>k \\<rho>.\n       \\<lbrakk>\\<And>\\<rho>.\n                   \\<rho> \\<in> density_states \\<Longrightarrow>\n                   trace (W k * \\<rho>) =\n                   (\\<Sum>k = 0..<k. trace (P * D0 k \\<rho>)) +\n                   trace \\<rho> -\n                   (\\<Sum>k = 0..<k. trace (D0 k \\<rho>));\n        \\<rho> \\<in> density_states\\<rbrakk>\n       \\<Longrightarrow> trace (W (Suc k) * \\<rho>) =\n                         (\\<Sum>k = 0..<Suc k. trace (P * D0 k \\<rho>)) +\n                         trace \\<rho> -\n                         (\\<Sum>k = 0..<Suc k. trace (D0 k \\<rho>))", "case 0"], ["proof (state)\nthis:\n  \\<rho> \\<in> density_states\n\ngoal (2 subgoals):\n 1. \\<And>\\<rho>.\n       \\<rho> \\<in> density_states \\<Longrightarrow>\n       trace (W 0 * \\<rho>) =\n       (\\<Sum>k = 0..<0. trace (P * D0 k \\<rho>)) + trace \\<rho> -\n       (\\<Sum>k = 0..<0. trace (D0 k \\<rho>))\n 2. \\<And>k \\<rho>.\n       \\<lbrakk>\\<And>\\<rho>.\n                   \\<rho> \\<in> density_states \\<Longrightarrow>\n                   trace (W k * \\<rho>) =\n                   (\\<Sum>k = 0..<k. trace (P * D0 k \\<rho>)) +\n                   trace \\<rho> -\n                   (\\<Sum>k = 0..<k. trace (D0 k \\<rho>));\n        \\<rho> \\<in> density_states\\<rbrakk>\n       \\<Longrightarrow> trace (W (Suc k) * \\<rho>) =\n                         (\\<Sum>k = 0..<Suc k. trace (P * D0 k \\<rho>)) +\n                         trace \\<rho> -\n                         (\\<Sum>k = 0..<Suc k. trace (D0 k \\<rho>))", "then"], ["proof (chain)\npicking this:\n  \\<rho> \\<in> density_states", "have dsr: \"\\<rho> \\<in> density_states\""], ["proof (prove)\nusing this:\n  \\<rho> \\<in> density_states\n\ngoal (1 subgoal):\n 1. \\<rho> \\<in> density_states", "by auto"], ["proof (state)\nthis:\n  \\<rho> \\<in> density_states\n\ngoal (2 subgoals):\n 1. \\<And>\\<rho>.\n       \\<rho> \\<in> density_states \\<Longrightarrow>\n       trace (W 0 * \\<rho>) =\n       (\\<Sum>k = 0..<0. trace (P * D0 k \\<rho>)) + trace \\<rho> -\n       (\\<Sum>k = 0..<0. trace (D0 k \\<rho>))\n 2. \\<And>k \\<rho>.\n       \\<lbrakk>\\<And>\\<rho>.\n                   \\<rho> \\<in> density_states \\<Longrightarrow>\n                   trace (W k * \\<rho>) =\n                   (\\<Sum>k = 0..<k. trace (P * D0 k \\<rho>)) +\n                   trace \\<rho> -\n                   (\\<Sum>k = 0..<k. trace (D0 k \\<rho>));\n        \\<rho> \\<in> density_states\\<rbrakk>\n       \\<Longrightarrow> trace (W (Suc k) * \\<rho>) =\n                         (\\<Sum>k = 0..<Suc k. trace (P * D0 k \\<rho>)) +\n                         trace \\<rho> -\n                         (\\<Sum>k = 0..<Suc k. trace (D0 k \\<rho>))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. trace (W 0 * \\<rho>) =\n    (\\<Sum>k = 0..<0. trace (P * D0 k \\<rho>)) + trace \\<rho> -\n    (\\<Sum>k = 0..<0. trace (D0 k \\<rho>))", "unfolding W_def wlp_while_n.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. trace (1\\<^sub>m d * \\<rho>) =\n    (\\<Sum>k = 0..<0. trace (P * D0 k \\<rho>)) + trace \\<rho> -\n    (\\<Sum>k = 0..<0. trace (D0 k \\<rho>))", "using dsr density_states_def"], ["proof (prove)\nusing this:\n  \\<rho> \\<in> density_states\n  density_states =\n  {\\<rho> \\<in> carrier_mat d d. partial_density_operator \\<rho>}\n\ngoal (1 subgoal):\n 1. trace (1\\<^sub>m d * \\<rho>) =\n    (\\<Sum>k = 0..<0. trace (P * D0 k \\<rho>)) + trace \\<rho> -\n    (\\<Sum>k = 0..<0. trace (D0 k \\<rho>))", "by auto"], ["proof (state)\nthis:\n  trace (W 0 * \\<rho>) =\n  (\\<Sum>k = 0..<0. trace (P * D0 k \\<rho>)) + trace \\<rho> -\n  (\\<Sum>k = 0..<0. trace (D0 k \\<rho>))\n\ngoal (1 subgoal):\n 1. \\<And>k \\<rho>.\n       \\<lbrakk>\\<And>\\<rho>.\n                   \\<rho> \\<in> density_states \\<Longrightarrow>\n                   trace (W k * \\<rho>) =\n                   (\\<Sum>k = 0..<k. trace (P * D0 k \\<rho>)) +\n                   trace \\<rho> -\n                   (\\<Sum>k = 0..<k. trace (D0 k \\<rho>));\n        \\<rho> \\<in> density_states\\<rbrakk>\n       \\<Longrightarrow> trace (W (Suc k) * \\<rho>) =\n                         (\\<Sum>k = 0..<Suc k. trace (P * D0 k \\<rho>)) +\n                         trace \\<rho> -\n                         (\\<Sum>k = 0..<Suc k. trace (D0 k \\<rho>))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k \\<rho>.\n       \\<lbrakk>\\<And>\\<rho>.\n                   \\<rho> \\<in> density_states \\<Longrightarrow>\n                   trace (W k * \\<rho>) =\n                   (\\<Sum>k = 0..<k. trace (P * D0 k \\<rho>)) +\n                   trace \\<rho> -\n                   (\\<Sum>k = 0..<k. trace (D0 k \\<rho>));\n        \\<rho> \\<in> density_states\\<rbrakk>\n       \\<Longrightarrow> trace (W (Suc k) * \\<rho>) =\n                         (\\<Sum>k = 0..<Suc k. trace (P * D0 k \\<rho>)) +\n                         trace \\<rho> -\n                         (\\<Sum>k = 0..<Suc k. trace (D0 k \\<rho>))", "case (Suc k)"], ["proof (state)\nthis:\n  ?\\<rho> \\<in> density_states \\<Longrightarrow>\n  trace (W k * ?\\<rho>) =\n  (\\<Sum>k = 0..<k. trace (P * D0 k ?\\<rho>)) + trace ?\\<rho> -\n  (\\<Sum>k = 0..<k. trace (D0 k ?\\<rho>))\n  \\<rho> \\<in> density_states\n\ngoal (1 subgoal):\n 1. \\<And>k \\<rho>.\n       \\<lbrakk>\\<And>\\<rho>.\n                   \\<rho> \\<in> density_states \\<Longrightarrow>\n                   trace (W k * \\<rho>) =\n                   (\\<Sum>k = 0..<k. trace (P * D0 k \\<rho>)) +\n                   trace \\<rho> -\n                   (\\<Sum>k = 0..<k. trace (D0 k \\<rho>));\n        \\<rho> \\<in> density_states\\<rbrakk>\n       \\<Longrightarrow> trace (W (Suc k) * \\<rho>) =\n                         (\\<Sum>k = 0..<Suc k. trace (P * D0 k \\<rho>)) +\n                         trace \\<rho> -\n                         (\\<Sum>k = 0..<Suc k. trace (D0 k \\<rho>))", "then"], ["proof (chain)\npicking this:\n  ?\\<rho> \\<in> density_states \\<Longrightarrow>\n  trace (W k * ?\\<rho>) =\n  (\\<Sum>k = 0..<k. trace (P * D0 k ?\\<rho>)) + trace ?\\<rho> -\n  (\\<Sum>k = 0..<k. trace (D0 k ?\\<rho>))\n  \\<rho> \\<in> density_states", "have dsr: \"\\<rho> \\<in> density_states\" and dr: \"\\<rho> \\<in> carrier_mat d d\" and pdor: \"partial_density_operator \\<rho>\""], ["proof (prove)\nusing this:\n  ?\\<rho> \\<in> density_states \\<Longrightarrow>\n  trace (W k * ?\\<rho>) =\n  (\\<Sum>k = 0..<k. trace (P * D0 k ?\\<rho>)) + trace ?\\<rho> -\n  (\\<Sum>k = 0..<k. trace (D0 k ?\\<rho>))\n  \\<rho> \\<in> density_states\n\ngoal (1 subgoal):\n 1. \\<rho> \\<in> density_states &&&\n    \\<rho> \\<in> carrier_mat d d &&& partial_density_operator \\<rho>", "using density_states_def"], ["proof (prove)\nusing this:\n  ?\\<rho> \\<in> density_states \\<Longrightarrow>\n  trace (W k * ?\\<rho>) =\n  (\\<Sum>k = 0..<k. trace (P * D0 k ?\\<rho>)) + trace ?\\<rho> -\n  (\\<Sum>k = 0..<k. trace (D0 k ?\\<rho>))\n  \\<rho> \\<in> density_states\n  density_states =\n  {\\<rho> \\<in> carrier_mat d d. partial_density_operator \\<rho>}\n\ngoal (1 subgoal):\n 1. \\<rho> \\<in> density_states &&&\n    \\<rho> \\<in> carrier_mat d d &&& partial_density_operator \\<rho>", "by auto"], ["proof (state)\nthis:\n  \\<rho> \\<in> density_states\n  \\<rho> \\<in> carrier_mat d d\n  partial_density_operator \\<rho>\n\ngoal (1 subgoal):\n 1. \\<And>k \\<rho>.\n       \\<lbrakk>\\<And>\\<rho>.\n                   \\<rho> \\<in> density_states \\<Longrightarrow>\n                   trace (W k * \\<rho>) =\n                   (\\<Sum>k = 0..<k. trace (P * D0 k \\<rho>)) +\n                   trace \\<rho> -\n                   (\\<Sum>k = 0..<k. trace (D0 k \\<rho>));\n        \\<rho> \\<in> density_states\\<rbrakk>\n       \\<Longrightarrow> trace (W (Suc k) * \\<rho>) =\n                         (\\<Sum>k = 0..<Suc k. trace (P * D0 k \\<rho>)) +\n                         trace \\<rho> -\n                         (\\<Sum>k = 0..<Suc k. trace (D0 k \\<rho>))", "then"], ["proof (chain)\npicking this:\n  \\<rho> \\<in> density_states\n  \\<rho> \\<in> carrier_mat d d\n  partial_density_operator \\<rho>", "have dsM1r: \"M1 * \\<rho> * adjoint M1 \\<in> density_states\""], ["proof (prove)\nusing this:\n  \\<rho> \\<in> density_states\n  \\<rho> \\<in> carrier_mat d d\n  partial_density_operator \\<rho>\n\ngoal (1 subgoal):\n 1. M1 * \\<rho> * adjoint M1 \\<in> density_states", "unfolding density_states_def"], ["proof (prove)\nusing this:\n  \\<rho>\n  \\<in> {\\<rho> \\<in> carrier_mat d d. partial_density_operator \\<rho>}\n  \\<rho> \\<in> carrier_mat d d\n  partial_density_operator \\<rho>\n\ngoal (1 subgoal):\n 1. M1 * \\<rho> * adjoint M1\n    \\<in> {\\<rho> \\<in> carrier_mat d d. partial_density_operator \\<rho>}", "using pdo_close_under_measurement[OF dM1 dr pdor leM1] dr dM1"], ["proof (prove)\nusing this:\n  \\<rho>\n  \\<in> {\\<rho> \\<in> carrier_mat d d. partial_density_operator \\<rho>}\n  \\<rho> \\<in> carrier_mat d d\n  partial_density_operator \\<rho>\n  partial_density_operator (M1 * \\<rho> * adjoint M1)\n  \\<rho> \\<in> carrier_mat d d\n  M1 \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. M1 * \\<rho> * adjoint M1\n    \\<in> {\\<rho> \\<in> carrier_mat d d. partial_density_operator \\<rho>}", "by auto"], ["proof (state)\nthis:\n  M1 * \\<rho> * adjoint M1 \\<in> density_states\n\ngoal (1 subgoal):\n 1. \\<And>k \\<rho>.\n       \\<lbrakk>\\<And>\\<rho>.\n                   \\<rho> \\<in> density_states \\<Longrightarrow>\n                   trace (W k * \\<rho>) =\n                   (\\<Sum>k = 0..<k. trace (P * D0 k \\<rho>)) +\n                   trace \\<rho> -\n                   (\\<Sum>k = 0..<k. trace (D0 k \\<rho>));\n        \\<rho> \\<in> density_states\\<rbrakk>\n       \\<Longrightarrow> trace (W (Suc k) * \\<rho>) =\n                         (\\<Sum>k = 0..<Suc k. trace (P * D0 k \\<rho>)) +\n                         trace \\<rho> -\n                         (\\<Sum>k = 0..<Suc k. trace (D0 k \\<rho>))", "then"], ["proof (chain)\npicking this:\n  M1 * \\<rho> * adjoint M1 \\<in> density_states", "have dsDSM1r: \"(DS (M1 * \\<rho> * adjoint M1)) \\<in> density_states\""], ["proof (prove)\nusing this:\n  M1 * \\<rho> * adjoint M1 \\<in> density_states\n\ngoal (1 subgoal):\n 1. DS (M1 * \\<rho> * adjoint M1) \\<in> density_states", "unfolding density_states_def DS_def"], ["proof (prove)\nusing this:\n  M1 * \\<rho> * adjoint M1\n  \\<in> {\\<rho> \\<in> carrier_mat d d. partial_density_operator \\<rho>}\n\ngoal (1 subgoal):\n 1. denote S (M1 * \\<rho> * adjoint M1)\n    \\<in> {\\<rho> \\<in> carrier_mat d d. partial_density_operator \\<rho>}", "using denote_dim[OF wcS] denote_partial_density_operator[OF wcS] dsM1r"], ["proof (prove)\nusing this:\n  M1 * \\<rho> * adjoint M1\n  \\<in> {\\<rho> \\<in> carrier_mat d d. partial_density_operator \\<rho>}\n  \\<lbrakk>?\\<rho> \\<in> carrier_mat d d;\n   partial_density_operator ?\\<rho>\\<rbrakk>\n  \\<Longrightarrow> denote S ?\\<rho> \\<in> carrier_mat d d\n  \\<lbrakk>partial_density_operator ?\\<rho>;\n   ?\\<rho> \\<in> carrier_mat d d\\<rbrakk>\n  \\<Longrightarrow> partial_density_operator (denote S ?\\<rho>)\n  M1 * \\<rho> * adjoint M1 \\<in> density_states\n\ngoal (1 subgoal):\n 1. denote S (M1 * \\<rho> * adjoint M1)\n    \\<in> {\\<rho> \\<in> carrier_mat d d. partial_density_operator \\<rho>}", "by auto"], ["proof (state)\nthis:\n  DS (M1 * \\<rho> * adjoint M1) \\<in> density_states\n\ngoal (1 subgoal):\n 1. \\<And>k \\<rho>.\n       \\<lbrakk>\\<And>\\<rho>.\n                   \\<rho> \\<in> density_states \\<Longrightarrow>\n                   trace (W k * \\<rho>) =\n                   (\\<Sum>k = 0..<k. trace (P * D0 k \\<rho>)) +\n                   trace \\<rho> -\n                   (\\<Sum>k = 0..<k. trace (D0 k \\<rho>));\n        \\<rho> \\<in> density_states\\<rbrakk>\n       \\<Longrightarrow> trace (W (Suc k) * \\<rho>) =\n                         (\\<Sum>k = 0..<Suc k. trace (P * D0 k \\<rho>)) +\n                         trace \\<rho> -\n                         (\\<Sum>k = 0..<Suc k. trace (D0 k \\<rho>))", "have qpWk: \"is_quantum_predicate (W k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_quantum_predicate (W k)", "using wlp_while_n_close[OF _ m qpP, folded M0_def M1_def, of \"wlp S\", folded W_def] wlp_close[OF wcS]"], ["proof (prove)\nusing this:\n  (\\<And>P.\n      is_quantum_predicate P \\<Longrightarrow>\n      is_quantum_predicate (wlp S P)) \\<Longrightarrow>\n  is_quantum_predicate (W ?k)\n  is_quantum_predicate ?P \\<Longrightarrow> is_quantum_predicate (wlp S ?P)\n\ngoal (1 subgoal):\n 1. is_quantum_predicate (W k)", "by auto"], ["proof (state)\nthis:\n  is_quantum_predicate (W k)\n\ngoal (1 subgoal):\n 1. \\<And>k \\<rho>.\n       \\<lbrakk>\\<And>\\<rho>.\n                   \\<rho> \\<in> density_states \\<Longrightarrow>\n                   trace (W k * \\<rho>) =\n                   (\\<Sum>k = 0..<k. trace (P * D0 k \\<rho>)) +\n                   trace \\<rho> -\n                   (\\<Sum>k = 0..<k. trace (D0 k \\<rho>));\n        \\<rho> \\<in> density_states\\<rbrakk>\n       \\<Longrightarrow> trace (W (Suc k) * \\<rho>) =\n                         (\\<Sum>k = 0..<Suc k. trace (P * D0 k \\<rho>)) +\n                         trace \\<rho> -\n                         (\\<Sum>k = 0..<Suc k. trace (D0 k \\<rho>))", "then"], ["proof (chain)\npicking this:\n  is_quantum_predicate (W k)", "have \"is_quantum_predicate (wlp S (W k))\""], ["proof (prove)\nusing this:\n  is_quantum_predicate (W k)\n\ngoal (1 subgoal):\n 1. is_quantum_predicate (wlp S (W k))", "using wlp_close[OF wcS]"], ["proof (prove)\nusing this:\n  is_quantum_predicate (W k)\n  is_quantum_predicate ?P \\<Longrightarrow> is_quantum_predicate (wlp S ?P)\n\ngoal (1 subgoal):\n 1. is_quantum_predicate (wlp S (W k))", "by auto"], ["proof (state)\nthis:\n  is_quantum_predicate (wlp S (W k))\n\ngoal (1 subgoal):\n 1. \\<And>k \\<rho>.\n       \\<lbrakk>\\<And>\\<rho>.\n                   \\<rho> \\<in> density_states \\<Longrightarrow>\n                   trace (W k * \\<rho>) =\n                   (\\<Sum>k = 0..<k. trace (P * D0 k \\<rho>)) +\n                   trace \\<rho> -\n                   (\\<Sum>k = 0..<k. trace (D0 k \\<rho>));\n        \\<rho> \\<in> density_states\\<rbrakk>\n       \\<Longrightarrow> trace (W (Suc k) * \\<rho>) =\n                         (\\<Sum>k = 0..<Suc k. trace (P * D0 k \\<rho>)) +\n                         trace \\<rho> -\n                         (\\<Sum>k = 0..<Suc k. trace (D0 k \\<rho>))", "then"], ["proof (chain)\npicking this:\n  is_quantum_predicate (wlp S (W k))", "have dWWk: \"wlp S (W k) \\<in> carrier_mat d d\""], ["proof (prove)\nusing this:\n  is_quantum_predicate (wlp S (W k))\n\ngoal (1 subgoal):\n 1. wlp S (W k) \\<in> carrier_mat d d", "using is_quantum_predicate_def"], ["proof (prove)\nusing this:\n  is_quantum_predicate (wlp S (W k))\n  is_quantum_predicate ?P =\n  (?P \\<in> carrier_mat d d \\<and>\n   positive ?P \\<and> ?P \\<le>\\<^sub>L 1\\<^sub>m d)\n\ngoal (1 subgoal):\n 1. wlp S (W k) \\<in> carrier_mat d d", "by auto"], ["proof (state)\nthis:\n  wlp S (W k) \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. \\<And>k \\<rho>.\n       \\<lbrakk>\\<And>\\<rho>.\n                   \\<rho> \\<in> density_states \\<Longrightarrow>\n                   trace (W k * \\<rho>) =\n                   (\\<Sum>k = 0..<k. trace (P * D0 k \\<rho>)) +\n                   trace \\<rho> -\n                   (\\<Sum>k = 0..<k. trace (D0 k \\<rho>));\n        \\<rho> \\<in> density_states\\<rbrakk>\n       \\<Longrightarrow> trace (W (Suc k) * \\<rho>) =\n                         (\\<Sum>k = 0..<Suc k. trace (P * D0 k \\<rho>)) +\n                         trace \\<rho> -\n                         (\\<Sum>k = 0..<Suc k. trace (D0 k \\<rho>))", "have \"trace (P * (M0 * \\<rho> * adjoint M0)) + (\\<Sum>k=0..<k. trace (P * (D0 k (DS (M1 * \\<rho> * adjoint M1)))))\n      = trace (P * (D0 0 \\<rho>)) + (\\<Sum>k=0..<k. trace (P * (D0 (Suc k) \\<rho>)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace (P * (M0 * \\<rho> * adjoint M0)) +\n    (\\<Sum>k = 0..<k. trace (P * D0 k (DS (M1 * \\<rho> * adjoint M1)))) =\n    trace (P * D0 0 \\<rho>) +\n    (\\<Sum>k = 0..<k. trace (P * D0 (Suc k) \\<rho>))", "unfolding D0_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. trace (P * (M0 * \\<rho> * adjoint M0)) +\n    (\\<Sum>k = 0..<k.\n        trace\n         (P * denote_while_n M0 M1 DS k (DS (M1 * \\<rho> * adjoint M1)))) =\n    trace (P * denote_while_n M0 M1 DS 0 \\<rho>) +\n    (\\<Sum>k = 0..<k. trace (P * denote_while_n M0 M1 DS (Suc k) \\<rho>))", "by auto"], ["proof (state)\nthis:\n  trace (P * (M0 * \\<rho> * adjoint M0)) +\n  (\\<Sum>k = 0..<k. trace (P * D0 k (DS (M1 * \\<rho> * adjoint M1)))) =\n  trace (P * D0 0 \\<rho>) + (\\<Sum>k = 0..<k. trace (P * D0 (Suc k) \\<rho>))\n\ngoal (1 subgoal):\n 1. \\<And>k \\<rho>.\n       \\<lbrakk>\\<And>\\<rho>.\n                   \\<rho> \\<in> density_states \\<Longrightarrow>\n                   trace (W k * \\<rho>) =\n                   (\\<Sum>k = 0..<k. trace (P * D0 k \\<rho>)) +\n                   trace \\<rho> -\n                   (\\<Sum>k = 0..<k. trace (D0 k \\<rho>));\n        \\<rho> \\<in> density_states\\<rbrakk>\n       \\<Longrightarrow> trace (W (Suc k) * \\<rho>) =\n                         (\\<Sum>k = 0..<Suc k. trace (P * D0 k \\<rho>)) +\n                         trace \\<rho> -\n                         (\\<Sum>k = 0..<Suc k. trace (D0 k \\<rho>))", "also"], ["proof (state)\nthis:\n  trace (P * (M0 * \\<rho> * adjoint M0)) +\n  (\\<Sum>k = 0..<k. trace (P * D0 k (DS (M1 * \\<rho> * adjoint M1)))) =\n  trace (P * D0 0 \\<rho>) + (\\<Sum>k = 0..<k. trace (P * D0 (Suc k) \\<rho>))\n\ngoal (1 subgoal):\n 1. \\<And>k \\<rho>.\n       \\<lbrakk>\\<And>\\<rho>.\n                   \\<rho> \\<in> density_states \\<Longrightarrow>\n                   trace (W k * \\<rho>) =\n                   (\\<Sum>k = 0..<k. trace (P * D0 k \\<rho>)) +\n                   trace \\<rho> -\n                   (\\<Sum>k = 0..<k. trace (D0 k \\<rho>));\n        \\<rho> \\<in> density_states\\<rbrakk>\n       \\<Longrightarrow> trace (W (Suc k) * \\<rho>) =\n                         (\\<Sum>k = 0..<Suc k. trace (P * D0 k \\<rho>)) +\n                         trace \\<rho> -\n                         (\\<Sum>k = 0..<Suc k. trace (D0 k \\<rho>))", "have \"\\<dots> = trace (P * (D0 0 \\<rho>)) + (\\<Sum>k=1..<(Suc k). trace (P * (D0 k \\<rho>)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace (P * D0 0 \\<rho>) +\n    (\\<Sum>k = 0..<k. trace (P * D0 (Suc k) \\<rho>)) =\n    trace (P * D0 0 \\<rho>) + (\\<Sum>k = 1..<Suc k. trace (P * D0 k \\<rho>))", "using sum.shift_bounds_Suc_ivl[symmetric, of \"\\<lambda>k. trace (P * (D0 k \\<rho>))\"]"], ["proof (prove)\nusing this:\n  (\\<Sum>i = ?m..<?n. trace (P * D0 (Suc i) \\<rho>)) =\n  (\\<Sum>k = Suc ?m..<Suc ?n. trace (P * D0 k \\<rho>))\n\ngoal (1 subgoal):\n 1. trace (P * D0 0 \\<rho>) +\n    (\\<Sum>k = 0..<k. trace (P * D0 (Suc k) \\<rho>)) =\n    trace (P * D0 0 \\<rho>) + (\\<Sum>k = 1..<Suc k. trace (P * D0 k \\<rho>))", "by auto"], ["proof (state)\nthis:\n  trace (P * D0 0 \\<rho>) +\n  (\\<Sum>k = 0..<k. trace (P * D0 (Suc k) \\<rho>)) =\n  trace (P * D0 0 \\<rho>) + (\\<Sum>k = 1..<Suc k. trace (P * D0 k \\<rho>))\n\ngoal (1 subgoal):\n 1. \\<And>k \\<rho>.\n       \\<lbrakk>\\<And>\\<rho>.\n                   \\<rho> \\<in> density_states \\<Longrightarrow>\n                   trace (W k * \\<rho>) =\n                   (\\<Sum>k = 0..<k. trace (P * D0 k \\<rho>)) +\n                   trace \\<rho> -\n                   (\\<Sum>k = 0..<k. trace (D0 k \\<rho>));\n        \\<rho> \\<in> density_states\\<rbrakk>\n       \\<Longrightarrow> trace (W (Suc k) * \\<rho>) =\n                         (\\<Sum>k = 0..<Suc k. trace (P * D0 k \\<rho>)) +\n                         trace \\<rho> -\n                         (\\<Sum>k = 0..<Suc k. trace (D0 k \\<rho>))", "also"], ["proof (state)\nthis:\n  trace (P * D0 0 \\<rho>) +\n  (\\<Sum>k = 0..<k. trace (P * D0 (Suc k) \\<rho>)) =\n  trace (P * D0 0 \\<rho>) + (\\<Sum>k = 1..<Suc k. trace (P * D0 k \\<rho>))\n\ngoal (1 subgoal):\n 1. \\<And>k \\<rho>.\n       \\<lbrakk>\\<And>\\<rho>.\n                   \\<rho> \\<in> density_states \\<Longrightarrow>\n                   trace (W k * \\<rho>) =\n                   (\\<Sum>k = 0..<k. trace (P * D0 k \\<rho>)) +\n                   trace \\<rho> -\n                   (\\<Sum>k = 0..<k. trace (D0 k \\<rho>));\n        \\<rho> \\<in> density_states\\<rbrakk>\n       \\<Longrightarrow> trace (W (Suc k) * \\<rho>) =\n                         (\\<Sum>k = 0..<Suc k. trace (P * D0 k \\<rho>)) +\n                         trace \\<rho> -\n                         (\\<Sum>k = 0..<Suc k. trace (D0 k \\<rho>))", "have \"\\<dots> = (\\<Sum>k=0..<(Suc k). trace (P * (D0 k \\<rho>)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace (P * D0 0 \\<rho>) +\n    (\\<Sum>k = 1..<Suc k. trace (P * D0 k \\<rho>)) =\n    (\\<Sum>k = 0..<Suc k. trace (P * D0 k \\<rho>))", "using sum.atLeast_Suc_lessThan[of 0 \"Suc k\" \"\\<lambda>k. trace (P * (D0 k \\<rho>))\"]"], ["proof (prove)\nusing this:\n  0 < Suc k \\<Longrightarrow>\n  (\\<Sum>k = 0..<Suc k. trace (P * D0 k \\<rho>)) =\n  trace (P * D0 0 \\<rho>) +\n  (\\<Sum>k = Suc 0..<Suc k. trace (P * D0 k \\<rho>))\n\ngoal (1 subgoal):\n 1. trace (P * D0 0 \\<rho>) +\n    (\\<Sum>k = 1..<Suc k. trace (P * D0 k \\<rho>)) =\n    (\\<Sum>k = 0..<Suc k. trace (P * D0 k \\<rho>))", "by auto"], ["proof (state)\nthis:\n  trace (P * D0 0 \\<rho>) + (\\<Sum>k = 1..<Suc k. trace (P * D0 k \\<rho>)) =\n  (\\<Sum>k = 0..<Suc k. trace (P * D0 k \\<rho>))\n\ngoal (1 subgoal):\n 1. \\<And>k \\<rho>.\n       \\<lbrakk>\\<And>\\<rho>.\n                   \\<rho> \\<in> density_states \\<Longrightarrow>\n                   trace (W k * \\<rho>) =\n                   (\\<Sum>k = 0..<k. trace (P * D0 k \\<rho>)) +\n                   trace \\<rho> -\n                   (\\<Sum>k = 0..<k. trace (D0 k \\<rho>));\n        \\<rho> \\<in> density_states\\<rbrakk>\n       \\<Longrightarrow> trace (W (Suc k) * \\<rho>) =\n                         (\\<Sum>k = 0..<Suc k. trace (P * D0 k \\<rho>)) +\n                         trace \\<rho> -\n                         (\\<Sum>k = 0..<Suc k. trace (D0 k \\<rho>))", "finally"], ["proof (chain)\npicking this:\n  trace (P * (M0 * \\<rho> * adjoint M0)) +\n  (\\<Sum>k = 0..<k. trace (P * D0 k (DS (M1 * \\<rho> * adjoint M1)))) =\n  (\\<Sum>k = 0..<Suc k. trace (P * D0 k \\<rho>))", "have eq1: \"trace (P * (M0 * \\<rho> * adjoint M0)) + (\\<Sum>k=0..<k. trace (P * (D0 k (DS (M1 * \\<rho> * adjoint M1))))) \n      = (\\<Sum>k=0..<(Suc k). trace (P * (D0 k \\<rho>)))\""], ["proof (prove)\nusing this:\n  trace (P * (M0 * \\<rho> * adjoint M0)) +\n  (\\<Sum>k = 0..<k. trace (P * D0 k (DS (M1 * \\<rho> * adjoint M1)))) =\n  (\\<Sum>k = 0..<Suc k. trace (P * D0 k \\<rho>))\n\ngoal (1 subgoal):\n 1. trace (P * (M0 * \\<rho> * adjoint M0)) +\n    (\\<Sum>k = 0..<k. trace (P * D0 k (DS (M1 * \\<rho> * adjoint M1)))) =\n    (\\<Sum>k = 0..<Suc k. trace (P * D0 k \\<rho>))", "."], ["proof (state)\nthis:\n  trace (P * (M0 * \\<rho> * adjoint M0)) +\n  (\\<Sum>k = 0..<k. trace (P * D0 k (DS (M1 * \\<rho> * adjoint M1)))) =\n  (\\<Sum>k = 0..<Suc k. trace (P * D0 k \\<rho>))\n\ngoal (1 subgoal):\n 1. \\<And>k \\<rho>.\n       \\<lbrakk>\\<And>\\<rho>.\n                   \\<rho> \\<in> density_states \\<Longrightarrow>\n                   trace (W k * \\<rho>) =\n                   (\\<Sum>k = 0..<k. trace (P * D0 k \\<rho>)) +\n                   trace \\<rho> -\n                   (\\<Sum>k = 0..<k. trace (D0 k \\<rho>));\n        \\<rho> \\<in> density_states\\<rbrakk>\n       \\<Longrightarrow> trace (W (Suc k) * \\<rho>) =\n                         (\\<Sum>k = 0..<Suc k. trace (P * D0 k \\<rho>)) +\n                         trace \\<rho> -\n                         (\\<Sum>k = 0..<Suc k. trace (D0 k \\<rho>))", "have eq2: \"trace (M1 * \\<rho> * adjoint M1) = trace \\<rho> - trace (M0 * \\<rho> * adjoint M0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace (M1 * \\<rho> * adjoint M1) =\n    trace \\<rho> - trace (M0 * \\<rho> * adjoint M0)", "unfolding M0_def M1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. trace (M 1 * \\<rho> * adjoint (M 1)) =\n    trace \\<rho> - trace (M 0 * \\<rho> * adjoint (M 0))", "using m trace_measurement2[OF m dr] dr"], ["proof (prove)\nusing this:\n  measurement d 2 M\n  trace (M 0 * \\<rho> * adjoint (M 0)) +\n  trace (M 1 * \\<rho> * adjoint (M 1)) =\n  trace \\<rho>\n  \\<rho> \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. trace (M 1 * \\<rho> * adjoint (M 1)) =\n    trace \\<rho> - trace (M 0 * \\<rho> * adjoint (M 0))", "by (simp add: algebra_simps)"], ["proof (state)\nthis:\n  trace (M1 * \\<rho> * adjoint M1) =\n  trace \\<rho> - trace (M0 * \\<rho> * adjoint M0)\n\ngoal (1 subgoal):\n 1. \\<And>k \\<rho>.\n       \\<lbrakk>\\<And>\\<rho>.\n                   \\<rho> \\<in> density_states \\<Longrightarrow>\n                   trace (W k * \\<rho>) =\n                   (\\<Sum>k = 0..<k. trace (P * D0 k \\<rho>)) +\n                   trace \\<rho> -\n                   (\\<Sum>k = 0..<k. trace (D0 k \\<rho>));\n        \\<rho> \\<in> density_states\\<rbrakk>\n       \\<Longrightarrow> trace (W (Suc k) * \\<rho>) =\n                         (\\<Sum>k = 0..<Suc k. trace (P * D0 k \\<rho>)) +\n                         trace \\<rho> -\n                         (\\<Sum>k = 0..<Suc k. trace (D0 k \\<rho>))", "have \"trace (M0 * \\<rho> * adjoint M0) + (\\<Sum>k=0..<k. trace (D0 k (DS (M1 * \\<rho> * adjoint M1))))\n       = trace (D0 0 \\<rho>) + (\\<Sum>k=0..<k. trace (D0 (Suc k) \\<rho>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace (M0 * \\<rho> * adjoint M0) +\n    (\\<Sum>k = 0..<k. trace (D0 k (DS (M1 * \\<rho> * adjoint M1)))) =\n    trace (D0 0 \\<rho>) + (\\<Sum>k = 0..<k. trace (D0 (Suc k) \\<rho>))", "unfolding D0_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. trace (M0 * \\<rho> * adjoint M0) +\n    (\\<Sum>k = 0..<k.\n        trace (denote_while_n M0 M1 DS k (DS (M1 * \\<rho> * adjoint M1)))) =\n    trace (denote_while_n M0 M1 DS 0 \\<rho>) +\n    (\\<Sum>k = 0..<k. trace (denote_while_n M0 M1 DS (Suc k) \\<rho>))", "by auto"], ["proof (state)\nthis:\n  trace (M0 * \\<rho> * adjoint M0) +\n  (\\<Sum>k = 0..<k. trace (D0 k (DS (M1 * \\<rho> * adjoint M1)))) =\n  trace (D0 0 \\<rho>) + (\\<Sum>k = 0..<k. trace (D0 (Suc k) \\<rho>))\n\ngoal (1 subgoal):\n 1. \\<And>k \\<rho>.\n       \\<lbrakk>\\<And>\\<rho>.\n                   \\<rho> \\<in> density_states \\<Longrightarrow>\n                   trace (W k * \\<rho>) =\n                   (\\<Sum>k = 0..<k. trace (P * D0 k \\<rho>)) +\n                   trace \\<rho> -\n                   (\\<Sum>k = 0..<k. trace (D0 k \\<rho>));\n        \\<rho> \\<in> density_states\\<rbrakk>\n       \\<Longrightarrow> trace (W (Suc k) * \\<rho>) =\n                         (\\<Sum>k = 0..<Suc k. trace (P * D0 k \\<rho>)) +\n                         trace \\<rho> -\n                         (\\<Sum>k = 0..<Suc k. trace (D0 k \\<rho>))", "also"], ["proof (state)\nthis:\n  trace (M0 * \\<rho> * adjoint M0) +\n  (\\<Sum>k = 0..<k. trace (D0 k (DS (M1 * \\<rho> * adjoint M1)))) =\n  trace (D0 0 \\<rho>) + (\\<Sum>k = 0..<k. trace (D0 (Suc k) \\<rho>))\n\ngoal (1 subgoal):\n 1. \\<And>k \\<rho>.\n       \\<lbrakk>\\<And>\\<rho>.\n                   \\<rho> \\<in> density_states \\<Longrightarrow>\n                   trace (W k * \\<rho>) =\n                   (\\<Sum>k = 0..<k. trace (P * D0 k \\<rho>)) +\n                   trace \\<rho> -\n                   (\\<Sum>k = 0..<k. trace (D0 k \\<rho>));\n        \\<rho> \\<in> density_states\\<rbrakk>\n       \\<Longrightarrow> trace (W (Suc k) * \\<rho>) =\n                         (\\<Sum>k = 0..<Suc k. trace (P * D0 k \\<rho>)) +\n                         trace \\<rho> -\n                         (\\<Sum>k = 0..<Suc k. trace (D0 k \\<rho>))", "have \"\\<dots> = trace (D0 0 \\<rho>) + (\\<Sum>k=1..<(Suc k). trace (D0 k \\<rho>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace (D0 0 \\<rho>) + (\\<Sum>k = 0..<k. trace (D0 (Suc k) \\<rho>)) =\n    trace (D0 0 \\<rho>) + (\\<Sum>k = 1..<Suc k. trace (D0 k \\<rho>))", "using sum.shift_bounds_Suc_ivl[symmetric, of \"\\<lambda>k. trace (D0 k \\<rho>)\"]"], ["proof (prove)\nusing this:\n  (\\<Sum>i = ?m..<?n. trace (D0 (Suc i) \\<rho>)) =\n  (\\<Sum>k = Suc ?m..<Suc ?n. trace (D0 k \\<rho>))\n\ngoal (1 subgoal):\n 1. trace (D0 0 \\<rho>) + (\\<Sum>k = 0..<k. trace (D0 (Suc k) \\<rho>)) =\n    trace (D0 0 \\<rho>) + (\\<Sum>k = 1..<Suc k. trace (D0 k \\<rho>))", "by auto"], ["proof (state)\nthis:\n  trace (D0 0 \\<rho>) + (\\<Sum>k = 0..<k. trace (D0 (Suc k) \\<rho>)) =\n  trace (D0 0 \\<rho>) + (\\<Sum>k = 1..<Suc k. trace (D0 k \\<rho>))\n\ngoal (1 subgoal):\n 1. \\<And>k \\<rho>.\n       \\<lbrakk>\\<And>\\<rho>.\n                   \\<rho> \\<in> density_states \\<Longrightarrow>\n                   trace (W k * \\<rho>) =\n                   (\\<Sum>k = 0..<k. trace (P * D0 k \\<rho>)) +\n                   trace \\<rho> -\n                   (\\<Sum>k = 0..<k. trace (D0 k \\<rho>));\n        \\<rho> \\<in> density_states\\<rbrakk>\n       \\<Longrightarrow> trace (W (Suc k) * \\<rho>) =\n                         (\\<Sum>k = 0..<Suc k. trace (P * D0 k \\<rho>)) +\n                         trace \\<rho> -\n                         (\\<Sum>k = 0..<Suc k. trace (D0 k \\<rho>))", "also"], ["proof (state)\nthis:\n  trace (D0 0 \\<rho>) + (\\<Sum>k = 0..<k. trace (D0 (Suc k) \\<rho>)) =\n  trace (D0 0 \\<rho>) + (\\<Sum>k = 1..<Suc k. trace (D0 k \\<rho>))\n\ngoal (1 subgoal):\n 1. \\<And>k \\<rho>.\n       \\<lbrakk>\\<And>\\<rho>.\n                   \\<rho> \\<in> density_states \\<Longrightarrow>\n                   trace (W k * \\<rho>) =\n                   (\\<Sum>k = 0..<k. trace (P * D0 k \\<rho>)) +\n                   trace \\<rho> -\n                   (\\<Sum>k = 0..<k. trace (D0 k \\<rho>));\n        \\<rho> \\<in> density_states\\<rbrakk>\n       \\<Longrightarrow> trace (W (Suc k) * \\<rho>) =\n                         (\\<Sum>k = 0..<Suc k. trace (P * D0 k \\<rho>)) +\n                         trace \\<rho> -\n                         (\\<Sum>k = 0..<Suc k. trace (D0 k \\<rho>))", "have \"\\<dots> = (\\<Sum>k=0..<(Suc k). trace (D0 k \\<rho>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace (D0 0 \\<rho>) + (\\<Sum>k = 1..<Suc k. trace (D0 k \\<rho>)) =\n    (\\<Sum>k = 0..<Suc k. trace (D0 k \\<rho>))", "using sum.atLeast_Suc_lessThan[of 0 \"Suc k\" \"\\<lambda>k. trace (D0 k \\<rho>)\"]"], ["proof (prove)\nusing this:\n  0 < Suc k \\<Longrightarrow>\n  (\\<Sum>k = 0..<Suc k. trace (D0 k \\<rho>)) =\n  trace (D0 0 \\<rho>) + (\\<Sum>k = Suc 0..<Suc k. trace (D0 k \\<rho>))\n\ngoal (1 subgoal):\n 1. trace (D0 0 \\<rho>) + (\\<Sum>k = 1..<Suc k. trace (D0 k \\<rho>)) =\n    (\\<Sum>k = 0..<Suc k. trace (D0 k \\<rho>))", "by auto"], ["proof (state)\nthis:\n  trace (D0 0 \\<rho>) + (\\<Sum>k = 1..<Suc k. trace (D0 k \\<rho>)) =\n  (\\<Sum>k = 0..<Suc k. trace (D0 k \\<rho>))\n\ngoal (1 subgoal):\n 1. \\<And>k \\<rho>.\n       \\<lbrakk>\\<And>\\<rho>.\n                   \\<rho> \\<in> density_states \\<Longrightarrow>\n                   trace (W k * \\<rho>) =\n                   (\\<Sum>k = 0..<k. trace (P * D0 k \\<rho>)) +\n                   trace \\<rho> -\n                   (\\<Sum>k = 0..<k. trace (D0 k \\<rho>));\n        \\<rho> \\<in> density_states\\<rbrakk>\n       \\<Longrightarrow> trace (W (Suc k) * \\<rho>) =\n                         (\\<Sum>k = 0..<Suc k. trace (P * D0 k \\<rho>)) +\n                         trace \\<rho> -\n                         (\\<Sum>k = 0..<Suc k. trace (D0 k \\<rho>))", "finally"], ["proof (chain)\npicking this:\n  trace (M0 * \\<rho> * adjoint M0) +\n  (\\<Sum>k = 0..<k. trace (D0 k (DS (M1 * \\<rho> * adjoint M1)))) =\n  (\\<Sum>k = 0..<Suc k. trace (D0 k \\<rho>))", "have eq3: \"trace (M0 * \\<rho> * adjoint M0) + (\\<Sum>k=0..<k. trace (D0 k (DS (M1 * \\<rho> * adjoint M1)))) = (\\<Sum>k=0..<(Suc k). trace (D0 k \\<rho>))\""], ["proof (prove)\nusing this:\n  trace (M0 * \\<rho> * adjoint M0) +\n  (\\<Sum>k = 0..<k. trace (D0 k (DS (M1 * \\<rho> * adjoint M1)))) =\n  (\\<Sum>k = 0..<Suc k. trace (D0 k \\<rho>))\n\ngoal (1 subgoal):\n 1. trace (M0 * \\<rho> * adjoint M0) +\n    (\\<Sum>k = 0..<k. trace (D0 k (DS (M1 * \\<rho> * adjoint M1)))) =\n    (\\<Sum>k = 0..<Suc k. trace (D0 k \\<rho>))", "."], ["proof (state)\nthis:\n  trace (M0 * \\<rho> * adjoint M0) +\n  (\\<Sum>k = 0..<k. trace (D0 k (DS (M1 * \\<rho> * adjoint M1)))) =\n  (\\<Sum>k = 0..<Suc k. trace (D0 k \\<rho>))\n\ngoal (1 subgoal):\n 1. \\<And>k \\<rho>.\n       \\<lbrakk>\\<And>\\<rho>.\n                   \\<rho> \\<in> density_states \\<Longrightarrow>\n                   trace (W k * \\<rho>) =\n                   (\\<Sum>k = 0..<k. trace (P * D0 k \\<rho>)) +\n                   trace \\<rho> -\n                   (\\<Sum>k = 0..<k. trace (D0 k \\<rho>));\n        \\<rho> \\<in> density_states\\<rbrakk>\n       \\<Longrightarrow> trace (W (Suc k) * \\<rho>) =\n                         (\\<Sum>k = 0..<Suc k. trace (P * D0 k \\<rho>)) +\n                         trace \\<rho> -\n                         (\\<Sum>k = 0..<Suc k. trace (D0 k \\<rho>))", "then"], ["proof (chain)\npicking this:\n  trace (M0 * \\<rho> * adjoint M0) +\n  (\\<Sum>k = 0..<k. trace (D0 k (DS (M1 * \\<rho> * adjoint M1)))) =\n  (\\<Sum>k = 0..<Suc k. trace (D0 k \\<rho>))", "have \"trace (M1 * \\<rho> * adjoint M1) - (\\<Sum>k=0..<k. trace (D0 k (DS (M1 * \\<rho> * adjoint M1))))\n      = trace \\<rho> - (trace (M0 * \\<rho> * adjoint M0) + (\\<Sum>k=0..<k. trace (D0 k (DS (M1 * \\<rho> * adjoint M1)))))\""], ["proof (prove)\nusing this:\n  trace (M0 * \\<rho> * adjoint M0) +\n  (\\<Sum>k = 0..<k. trace (D0 k (DS (M1 * \\<rho> * adjoint M1)))) =\n  (\\<Sum>k = 0..<Suc k. trace (D0 k \\<rho>))\n\ngoal (1 subgoal):\n 1. trace (M1 * \\<rho> * adjoint M1) -\n    (\\<Sum>k = 0..<k. trace (D0 k (DS (M1 * \\<rho> * adjoint M1)))) =\n    trace \\<rho> -\n    (trace (M0 * \\<rho> * adjoint M0) +\n     (\\<Sum>k = 0..<k. trace (D0 k (DS (M1 * \\<rho> * adjoint M1)))))", "by (simp add: algebra_simps eq2)"], ["proof (state)\nthis:\n  trace (M1 * \\<rho> * adjoint M1) -\n  (\\<Sum>k = 0..<k. trace (D0 k (DS (M1 * \\<rho> * adjoint M1)))) =\n  trace \\<rho> -\n  (trace (M0 * \\<rho> * adjoint M0) +\n   (\\<Sum>k = 0..<k. trace (D0 k (DS (M1 * \\<rho> * adjoint M1)))))\n\ngoal (1 subgoal):\n 1. \\<And>k \\<rho>.\n       \\<lbrakk>\\<And>\\<rho>.\n                   \\<rho> \\<in> density_states \\<Longrightarrow>\n                   trace (W k * \\<rho>) =\n                   (\\<Sum>k = 0..<k. trace (P * D0 k \\<rho>)) +\n                   trace \\<rho> -\n                   (\\<Sum>k = 0..<k. trace (D0 k \\<rho>));\n        \\<rho> \\<in> density_states\\<rbrakk>\n       \\<Longrightarrow> trace (W (Suc k) * \\<rho>) =\n                         (\\<Sum>k = 0..<Suc k. trace (P * D0 k \\<rho>)) +\n                         trace \\<rho> -\n                         (\\<Sum>k = 0..<Suc k. trace (D0 k \\<rho>))", "then"], ["proof (chain)\npicking this:\n  trace (M1 * \\<rho> * adjoint M1) -\n  (\\<Sum>k = 0..<k. trace (D0 k (DS (M1 * \\<rho> * adjoint M1)))) =\n  trace \\<rho> -\n  (trace (M0 * \\<rho> * adjoint M0) +\n   (\\<Sum>k = 0..<k. trace (D0 k (DS (M1 * \\<rho> * adjoint M1)))))", "have eq4: \"trace (M1 * \\<rho> * adjoint M1) - (\\<Sum>k=0..<k. trace (D0 k (DS (M1 * \\<rho> * adjoint M1)))) = trace \\<rho> - (\\<Sum>k=0..<(Suc k). trace (D0 k \\<rho>))\""], ["proof (prove)\nusing this:\n  trace (M1 * \\<rho> * adjoint M1) -\n  (\\<Sum>k = 0..<k. trace (D0 k (DS (M1 * \\<rho> * adjoint M1)))) =\n  trace \\<rho> -\n  (trace (M0 * \\<rho> * adjoint M0) +\n   (\\<Sum>k = 0..<k. trace (D0 k (DS (M1 * \\<rho> * adjoint M1)))))\n\ngoal (1 subgoal):\n 1. trace (M1 * \\<rho> * adjoint M1) -\n    (\\<Sum>k = 0..<k. trace (D0 k (DS (M1 * \\<rho> * adjoint M1)))) =\n    trace \\<rho> - (\\<Sum>k = 0..<Suc k. trace (D0 k \\<rho>))", "by (simp add: eq3)"], ["proof (state)\nthis:\n  trace (M1 * \\<rho> * adjoint M1) -\n  (\\<Sum>k = 0..<k. trace (D0 k (DS (M1 * \\<rho> * adjoint M1)))) =\n  trace \\<rho> - (\\<Sum>k = 0..<Suc k. trace (D0 k \\<rho>))\n\ngoal (1 subgoal):\n 1. \\<And>k \\<rho>.\n       \\<lbrakk>\\<And>\\<rho>.\n                   \\<rho> \\<in> density_states \\<Longrightarrow>\n                   trace (W k * \\<rho>) =\n                   (\\<Sum>k = 0..<k. trace (P * D0 k \\<rho>)) +\n                   trace \\<rho> -\n                   (\\<Sum>k = 0..<k. trace (D0 k \\<rho>));\n        \\<rho> \\<in> density_states\\<rbrakk>\n       \\<Longrightarrow> trace (W (Suc k) * \\<rho>) =\n                         (\\<Sum>k = 0..<Suc k. trace (P * D0 k \\<rho>)) +\n                         trace \\<rho> -\n                         (\\<Sum>k = 0..<Suc k. trace (D0 k \\<rho>))", "have \"trace ((W (Suc k)) * \\<rho>) = trace (P * (M0 * \\<rho> * adjoint M0)) + trace ((wlp S (W k)) * (M1 * \\<rho> * adjoint M1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace (W (Suc k) * \\<rho>) =\n    trace (P * (M0 * \\<rho> * adjoint M0)) +\n    trace (wlp S (W k) * (M1 * \\<rho> * adjoint M1))", "unfolding W_def wlp_while_n.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. trace\n     ((adjoint M0 * P * M0 +\n       adjoint M1 * wlp S (wlp_while_n M0 M1 (wlp S) k P) * M1) *\n      \\<rho>) =\n    trace (P * (M0 * \\<rho> * adjoint M0)) +\n    trace\n     (wlp S (wlp_while_n M0 M1 (wlp S) k P) * (M1 * \\<rho> * adjoint M1))", "apply (fold W_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. trace ((adjoint M0 * P * M0 + adjoint M1 * wlp S (W k) * M1) * \\<rho>) =\n    trace (P * (M0 * \\<rho> * adjoint M0)) +\n    trace (wlp S (W k) * (M1 * \\<rho> * adjoint M1))", "using dM0 dP dM1 dWWk dr"], ["proof (prove)\nusing this:\n  M0 \\<in> carrier_mat d d\n  P \\<in> carrier_mat d d\n  M1 \\<in> carrier_mat d d\n  wlp S (W k) \\<in> carrier_mat d d\n  \\<rho> \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. trace ((adjoint M0 * P * M0 + adjoint M1 * wlp S (W k) * M1) * \\<rho>) =\n    trace (P * (M0 * \\<rho> * adjoint M0)) +\n    trace (wlp S (W k) * (M1 * \\<rho> * adjoint M1))", "by (mat_assoc d)"], ["proof (state)\nthis:\n  trace (W (Suc k) * \\<rho>) =\n  trace (P * (M0 * \\<rho> * adjoint M0)) +\n  trace (wlp S (W k) * (M1 * \\<rho> * adjoint M1))\n\ngoal (1 subgoal):\n 1. \\<And>k \\<rho>.\n       \\<lbrakk>\\<And>\\<rho>.\n                   \\<rho> \\<in> density_states \\<Longrightarrow>\n                   trace (W k * \\<rho>) =\n                   (\\<Sum>k = 0..<k. trace (P * D0 k \\<rho>)) +\n                   trace \\<rho> -\n                   (\\<Sum>k = 0..<k. trace (D0 k \\<rho>));\n        \\<rho> \\<in> density_states\\<rbrakk>\n       \\<Longrightarrow> trace (W (Suc k) * \\<rho>) =\n                         (\\<Sum>k = 0..<Suc k. trace (P * D0 k \\<rho>)) +\n                         trace \\<rho> -\n                         (\\<Sum>k = 0..<Suc k. trace (D0 k \\<rho>))", "also"], ["proof (state)\nthis:\n  trace (W (Suc k) * \\<rho>) =\n  trace (P * (M0 * \\<rho> * adjoint M0)) +\n  trace (wlp S (W k) * (M1 * \\<rho> * adjoint M1))\n\ngoal (1 subgoal):\n 1. \\<And>k \\<rho>.\n       \\<lbrakk>\\<And>\\<rho>.\n                   \\<rho> \\<in> density_states \\<Longrightarrow>\n                   trace (W k * \\<rho>) =\n                   (\\<Sum>k = 0..<k. trace (P * D0 k \\<rho>)) +\n                   trace \\<rho> -\n                   (\\<Sum>k = 0..<k. trace (D0 k \\<rho>));\n        \\<rho> \\<in> density_states\\<rbrakk>\n       \\<Longrightarrow> trace (W (Suc k) * \\<rho>) =\n                         (\\<Sum>k = 0..<Suc k. trace (P * D0 k \\<rho>)) +\n                         trace \\<rho> -\n                         (\\<Sum>k = 0..<Suc k. trace (D0 k \\<rho>))", "have \"\\<dots> = trace (P * (M0 * \\<rho> * adjoint M0)) + trace ((W k) * (DS (M1 * \\<rho> * adjoint M1))) + trace (M1 * \\<rho> * adjoint M1) - trace (DS (M1 * \\<rho> * adjoint M1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace (P * (M0 * \\<rho> * adjoint M0)) +\n    trace (wlp S (W k) * (M1 * \\<rho> * adjoint M1)) =\n    trace (P * (M0 * \\<rho> * adjoint M0)) +\n    trace (W k * DS (M1 * \\<rho> * adjoint M1)) +\n    trace (M1 * \\<rho> * adjoint M1) -\n    trace (DS (M1 * \\<rho> * adjoint M1))", "using While(1)[OF wcS, of \"W k\"] qpWk dsM1r DS_def"], ["proof (prove)\nusing this:\n  is_quantum_predicate (W k) \\<Longrightarrow>\n  \\<forall>\\<rho>\\<in>density_states.\n     trace (wlp S (W k) * \\<rho>) =\n     trace (W k * denote S \\<rho>) + trace \\<rho> - trace (denote S \\<rho>)\n  is_quantum_predicate (W k)\n  M1 * \\<rho> * adjoint M1 \\<in> density_states\n  DS = denote S\n\ngoal (1 subgoal):\n 1. trace (P * (M0 * \\<rho> * adjoint M0)) +\n    trace (wlp S (W k) * (M1 * \\<rho> * adjoint M1)) =\n    trace (P * (M0 * \\<rho> * adjoint M0)) +\n    trace (W k * DS (M1 * \\<rho> * adjoint M1)) +\n    trace (M1 * \\<rho> * adjoint M1) -\n    trace (DS (M1 * \\<rho> * adjoint M1))", "by auto"], ["proof (state)\nthis:\n  trace (P * (M0 * \\<rho> * adjoint M0)) +\n  trace (wlp S (W k) * (M1 * \\<rho> * adjoint M1)) =\n  trace (P * (M0 * \\<rho> * adjoint M0)) +\n  trace (W k * DS (M1 * \\<rho> * adjoint M1)) +\n  trace (M1 * \\<rho> * adjoint M1) -\n  trace (DS (M1 * \\<rho> * adjoint M1))\n\ngoal (1 subgoal):\n 1. \\<And>k \\<rho>.\n       \\<lbrakk>\\<And>\\<rho>.\n                   \\<rho> \\<in> density_states \\<Longrightarrow>\n                   trace (W k * \\<rho>) =\n                   (\\<Sum>k = 0..<k. trace (P * D0 k \\<rho>)) +\n                   trace \\<rho> -\n                   (\\<Sum>k = 0..<k. trace (D0 k \\<rho>));\n        \\<rho> \\<in> density_states\\<rbrakk>\n       \\<Longrightarrow> trace (W (Suc k) * \\<rho>) =\n                         (\\<Sum>k = 0..<Suc k. trace (P * D0 k \\<rho>)) +\n                         trace \\<rho> -\n                         (\\<Sum>k = 0..<Suc k. trace (D0 k \\<rho>))", "also"], ["proof (state)\nthis:\n  trace (P * (M0 * \\<rho> * adjoint M0)) +\n  trace (wlp S (W k) * (M1 * \\<rho> * adjoint M1)) =\n  trace (P * (M0 * \\<rho> * adjoint M0)) +\n  trace (W k * DS (M1 * \\<rho> * adjoint M1)) +\n  trace (M1 * \\<rho> * adjoint M1) -\n  trace (DS (M1 * \\<rho> * adjoint M1))\n\ngoal (1 subgoal):\n 1. \\<And>k \\<rho>.\n       \\<lbrakk>\\<And>\\<rho>.\n                   \\<rho> \\<in> density_states \\<Longrightarrow>\n                   trace (W k * \\<rho>) =\n                   (\\<Sum>k = 0..<k. trace (P * D0 k \\<rho>)) +\n                   trace \\<rho> -\n                   (\\<Sum>k = 0..<k. trace (D0 k \\<rho>));\n        \\<rho> \\<in> density_states\\<rbrakk>\n       \\<Longrightarrow> trace (W (Suc k) * \\<rho>) =\n                         (\\<Sum>k = 0..<Suc k. trace (P * D0 k \\<rho>)) +\n                         trace \\<rho> -\n                         (\\<Sum>k = 0..<Suc k. trace (D0 k \\<rho>))", "have \"\\<dots> = trace (P * (M0 * \\<rho> * adjoint M0))\n      + (\\<Sum>k=0..<k. trace (P * (D0 k (DS (M1 * \\<rho> * adjoint M1))))) + trace (DS (M1 * \\<rho> * adjoint M1)) - (\\<Sum>k=0..<k. trace (D0 k (DS (M1 * \\<rho> * adjoint M1))))\n      + trace (M1 * \\<rho> * adjoint M1) - trace (DS (M1 * \\<rho> * adjoint M1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace (P * (M0 * \\<rho> * adjoint M0)) +\n    trace (W k * DS (M1 * \\<rho> * adjoint M1)) +\n    trace (M1 * \\<rho> * adjoint M1) -\n    trace (DS (M1 * \\<rho> * adjoint M1)) =\n    trace (P * (M0 * \\<rho> * adjoint M0)) +\n    (\\<Sum>k = 0..<k. trace (P * D0 k (DS (M1 * \\<rho> * adjoint M1)))) +\n    trace (DS (M1 * \\<rho> * adjoint M1)) -\n    (\\<Sum>k = 0..<k. trace (D0 k (DS (M1 * \\<rho> * adjoint M1)))) +\n    trace (M1 * \\<rho> * adjoint M1) -\n    trace (DS (M1 * \\<rho> * adjoint M1))", "using Suc(1)[OF dsDSM1r]"], ["proof (prove)\nusing this:\n  trace (W k * DS (M1 * \\<rho> * adjoint M1)) =\n  (\\<Sum>k = 0..<k. trace (P * D0 k (DS (M1 * \\<rho> * adjoint M1)))) +\n  trace (DS (M1 * \\<rho> * adjoint M1)) -\n  (\\<Sum>k = 0..<k. trace (D0 k (DS (M1 * \\<rho> * adjoint M1))))\n\ngoal (1 subgoal):\n 1. trace (P * (M0 * \\<rho> * adjoint M0)) +\n    trace (W k * DS (M1 * \\<rho> * adjoint M1)) +\n    trace (M1 * \\<rho> * adjoint M1) -\n    trace (DS (M1 * \\<rho> * adjoint M1)) =\n    trace (P * (M0 * \\<rho> * adjoint M0)) +\n    (\\<Sum>k = 0..<k. trace (P * D0 k (DS (M1 * \\<rho> * adjoint M1)))) +\n    trace (DS (M1 * \\<rho> * adjoint M1)) -\n    (\\<Sum>k = 0..<k. trace (D0 k (DS (M1 * \\<rho> * adjoint M1)))) +\n    trace (M1 * \\<rho> * adjoint M1) -\n    trace (DS (M1 * \\<rho> * adjoint M1))", "by auto"], ["proof (state)\nthis:\n  trace (P * (M0 * \\<rho> * adjoint M0)) +\n  trace (W k * DS (M1 * \\<rho> * adjoint M1)) +\n  trace (M1 * \\<rho> * adjoint M1) -\n  trace (DS (M1 * \\<rho> * adjoint M1)) =\n  trace (P * (M0 * \\<rho> * adjoint M0)) +\n  (\\<Sum>k = 0..<k. trace (P * D0 k (DS (M1 * \\<rho> * adjoint M1)))) +\n  trace (DS (M1 * \\<rho> * adjoint M1)) -\n  (\\<Sum>k = 0..<k. trace (D0 k (DS (M1 * \\<rho> * adjoint M1)))) +\n  trace (M1 * \\<rho> * adjoint M1) -\n  trace (DS (M1 * \\<rho> * adjoint M1))\n\ngoal (1 subgoal):\n 1. \\<And>k \\<rho>.\n       \\<lbrakk>\\<And>\\<rho>.\n                   \\<rho> \\<in> density_states \\<Longrightarrow>\n                   trace (W k * \\<rho>) =\n                   (\\<Sum>k = 0..<k. trace (P * D0 k \\<rho>)) +\n                   trace \\<rho> -\n                   (\\<Sum>k = 0..<k. trace (D0 k \\<rho>));\n        \\<rho> \\<in> density_states\\<rbrakk>\n       \\<Longrightarrow> trace (W (Suc k) * \\<rho>) =\n                         (\\<Sum>k = 0..<Suc k. trace (P * D0 k \\<rho>)) +\n                         trace \\<rho> -\n                         (\\<Sum>k = 0..<Suc k. trace (D0 k \\<rho>))", "also"], ["proof (state)\nthis:\n  trace (P * (M0 * \\<rho> * adjoint M0)) +\n  trace (W k * DS (M1 * \\<rho> * adjoint M1)) +\n  trace (M1 * \\<rho> * adjoint M1) -\n  trace (DS (M1 * \\<rho> * adjoint M1)) =\n  trace (P * (M0 * \\<rho> * adjoint M0)) +\n  (\\<Sum>k = 0..<k. trace (P * D0 k (DS (M1 * \\<rho> * adjoint M1)))) +\n  trace (DS (M1 * \\<rho> * adjoint M1)) -\n  (\\<Sum>k = 0..<k. trace (D0 k (DS (M1 * \\<rho> * adjoint M1)))) +\n  trace (M1 * \\<rho> * adjoint M1) -\n  trace (DS (M1 * \\<rho> * adjoint M1))\n\ngoal (1 subgoal):\n 1. \\<And>k \\<rho>.\n       \\<lbrakk>\\<And>\\<rho>.\n                   \\<rho> \\<in> density_states \\<Longrightarrow>\n                   trace (W k * \\<rho>) =\n                   (\\<Sum>k = 0..<k. trace (P * D0 k \\<rho>)) +\n                   trace \\<rho> -\n                   (\\<Sum>k = 0..<k. trace (D0 k \\<rho>));\n        \\<rho> \\<in> density_states\\<rbrakk>\n       \\<Longrightarrow> trace (W (Suc k) * \\<rho>) =\n                         (\\<Sum>k = 0..<Suc k. trace (P * D0 k \\<rho>)) +\n                         trace \\<rho> -\n                         (\\<Sum>k = 0..<Suc k. trace (D0 k \\<rho>))", "have \"\\<dots> = trace (P * (M0 * \\<rho> * adjoint M0)) + (\\<Sum>k=0..<k. trace (P * (D0 k (DS (M1 * \\<rho> * adjoint M1))))) \n      + trace (M1 * \\<rho> * adjoint M1) - (\\<Sum>k=0..<k. trace (D0 k (DS (M1 * \\<rho> * adjoint M1))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace (P * (M0 * \\<rho> * adjoint M0)) +\n    (\\<Sum>k = 0..<k. trace (P * D0 k (DS (M1 * \\<rho> * adjoint M1)))) +\n    trace (DS (M1 * \\<rho> * adjoint M1)) -\n    (\\<Sum>k = 0..<k. trace (D0 k (DS (M1 * \\<rho> * adjoint M1)))) +\n    trace (M1 * \\<rho> * adjoint M1) -\n    trace (DS (M1 * \\<rho> * adjoint M1)) =\n    trace (P * (M0 * \\<rho> * adjoint M0)) +\n    (\\<Sum>k = 0..<k. trace (P * D0 k (DS (M1 * \\<rho> * adjoint M1)))) +\n    trace (M1 * \\<rho> * adjoint M1) -\n    (\\<Sum>k = 0..<k. trace (D0 k (DS (M1 * \\<rho> * adjoint M1))))", "by auto"], ["proof (state)\nthis:\n  trace (P * (M0 * \\<rho> * adjoint M0)) +\n  (\\<Sum>k = 0..<k. trace (P * D0 k (DS (M1 * \\<rho> * adjoint M1)))) +\n  trace (DS (M1 * \\<rho> * adjoint M1)) -\n  (\\<Sum>k = 0..<k. trace (D0 k (DS (M1 * \\<rho> * adjoint M1)))) +\n  trace (M1 * \\<rho> * adjoint M1) -\n  trace (DS (M1 * \\<rho> * adjoint M1)) =\n  trace (P * (M0 * \\<rho> * adjoint M0)) +\n  (\\<Sum>k = 0..<k. trace (P * D0 k (DS (M1 * \\<rho> * adjoint M1)))) +\n  trace (M1 * \\<rho> * adjoint M1) -\n  (\\<Sum>k = 0..<k. trace (D0 k (DS (M1 * \\<rho> * adjoint M1))))\n\ngoal (1 subgoal):\n 1. \\<And>k \\<rho>.\n       \\<lbrakk>\\<And>\\<rho>.\n                   \\<rho> \\<in> density_states \\<Longrightarrow>\n                   trace (W k * \\<rho>) =\n                   (\\<Sum>k = 0..<k. trace (P * D0 k \\<rho>)) +\n                   trace \\<rho> -\n                   (\\<Sum>k = 0..<k. trace (D0 k \\<rho>));\n        \\<rho> \\<in> density_states\\<rbrakk>\n       \\<Longrightarrow> trace (W (Suc k) * \\<rho>) =\n                         (\\<Sum>k = 0..<Suc k. trace (P * D0 k \\<rho>)) +\n                         trace \\<rho> -\n                         (\\<Sum>k = 0..<Suc k. trace (D0 k \\<rho>))", "also"], ["proof (state)\nthis:\n  trace (P * (M0 * \\<rho> * adjoint M0)) +\n  (\\<Sum>k = 0..<k. trace (P * D0 k (DS (M1 * \\<rho> * adjoint M1)))) +\n  trace (DS (M1 * \\<rho> * adjoint M1)) -\n  (\\<Sum>k = 0..<k. trace (D0 k (DS (M1 * \\<rho> * adjoint M1)))) +\n  trace (M1 * \\<rho> * adjoint M1) -\n  trace (DS (M1 * \\<rho> * adjoint M1)) =\n  trace (P * (M0 * \\<rho> * adjoint M0)) +\n  (\\<Sum>k = 0..<k. trace (P * D0 k (DS (M1 * \\<rho> * adjoint M1)))) +\n  trace (M1 * \\<rho> * adjoint M1) -\n  (\\<Sum>k = 0..<k. trace (D0 k (DS (M1 * \\<rho> * adjoint M1))))\n\ngoal (1 subgoal):\n 1. \\<And>k \\<rho>.\n       \\<lbrakk>\\<And>\\<rho>.\n                   \\<rho> \\<in> density_states \\<Longrightarrow>\n                   trace (W k * \\<rho>) =\n                   (\\<Sum>k = 0..<k. trace (P * D0 k \\<rho>)) +\n                   trace \\<rho> -\n                   (\\<Sum>k = 0..<k. trace (D0 k \\<rho>));\n        \\<rho> \\<in> density_states\\<rbrakk>\n       \\<Longrightarrow> trace (W (Suc k) * \\<rho>) =\n                         (\\<Sum>k = 0..<Suc k. trace (P * D0 k \\<rho>)) +\n                         trace \\<rho> -\n                         (\\<Sum>k = 0..<Suc k. trace (D0 k \\<rho>))", "have \"\\<dots> = (\\<Sum>k=0..<(Suc k). trace (P * (D0 k \\<rho>))) + trace \\<rho> - (\\<Sum>k=0..<(Suc k). trace (D0 k \\<rho>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace (P * (M0 * \\<rho> * adjoint M0)) +\n    (\\<Sum>k = 0..<k. trace (P * D0 k (DS (M1 * \\<rho> * adjoint M1)))) +\n    trace (M1 * \\<rho> * adjoint M1) -\n    (\\<Sum>k = 0..<k. trace (D0 k (DS (M1 * \\<rho> * adjoint M1)))) =\n    (\\<Sum>k = 0..<Suc k. trace (P * D0 k \\<rho>)) + trace \\<rho> -\n    (\\<Sum>k = 0..<Suc k. trace (D0 k \\<rho>))", "by (simp add: eq1 eq4)"], ["proof (state)\nthis:\n  trace (P * (M0 * \\<rho> * adjoint M0)) +\n  (\\<Sum>k = 0..<k. trace (P * D0 k (DS (M1 * \\<rho> * adjoint M1)))) +\n  trace (M1 * \\<rho> * adjoint M1) -\n  (\\<Sum>k = 0..<k. trace (D0 k (DS (M1 * \\<rho> * adjoint M1)))) =\n  (\\<Sum>k = 0..<Suc k. trace (P * D0 k \\<rho>)) + trace \\<rho> -\n  (\\<Sum>k = 0..<Suc k. trace (D0 k \\<rho>))\n\ngoal (1 subgoal):\n 1. \\<And>k \\<rho>.\n       \\<lbrakk>\\<And>\\<rho>.\n                   \\<rho> \\<in> density_states \\<Longrightarrow>\n                   trace (W k * \\<rho>) =\n                   (\\<Sum>k = 0..<k. trace (P * D0 k \\<rho>)) +\n                   trace \\<rho> -\n                   (\\<Sum>k = 0..<k. trace (D0 k \\<rho>));\n        \\<rho> \\<in> density_states\\<rbrakk>\n       \\<Longrightarrow> trace (W (Suc k) * \\<rho>) =\n                         (\\<Sum>k = 0..<Suc k. trace (P * D0 k \\<rho>)) +\n                         trace \\<rho> -\n                         (\\<Sum>k = 0..<Suc k. trace (D0 k \\<rho>))", "finally"], ["proof (chain)\npicking this:\n  trace (W (Suc k) * \\<rho>) =\n  (\\<Sum>k = 0..<Suc k. trace (P * D0 k \\<rho>)) + trace \\<rho> -\n  (\\<Sum>k = 0..<Suc k. trace (D0 k \\<rho>))", "show ?case"], ["proof (prove)\nusing this:\n  trace (W (Suc k) * \\<rho>) =\n  (\\<Sum>k = 0..<Suc k. trace (P * D0 k \\<rho>)) + trace \\<rho> -\n  (\\<Sum>k = 0..<Suc k. trace (D0 k \\<rho>))\n\ngoal (1 subgoal):\n 1. trace (W (Suc k) * \\<rho>) =\n    (\\<Sum>k = 0..<Suc k. trace (P * D0 k \\<rho>)) + trace \\<rho> -\n    (\\<Sum>k = 0..<Suc k. trace (D0 k \\<rho>))", "."], ["proof (state)\nthis:\n  trace (W (Suc k) * \\<rho>) =\n  (\\<Sum>k = 0..<Suc k. trace (P * D0 k \\<rho>)) + trace \\<rho> -\n  (\\<Sum>k = 0..<Suc k. trace (D0 k \\<rho>))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?\\<rho> \\<in> density_states \\<Longrightarrow>\n  trace (W ?k * ?\\<rho>) =\n  (\\<Sum>k = 0..<?k. trace (P * D0 k ?\\<rho>)) + trace ?\\<rho> -\n  (\\<Sum>k = 0..<?k. trace (D0 k ?\\<rho>))\n\ngoal (1 subgoal):\n 1. \\<And>x1 S P.\n       \\<lbrakk>\\<And>P.\n                   \\<lbrakk>well_com S; is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n  trace (wlp S P * \\<rho>) =\n  trace (P * denote S \\<rho>) + trace \\<rho> - trace (denote S \\<rho>);\n        well_com (While x1 S); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                            trace (wlp (While x1 S) P * \\<rho>) =\n                            trace (P * denote (While x1 S) \\<rho>) +\n                            trace \\<rho> -\n                            trace (denote (While x1 S) \\<rho>)", "{"], ["proof (state)\nthis:\n  ?\\<rho> \\<in> density_states \\<Longrightarrow>\n  trace (W ?k * ?\\<rho>) =\n  (\\<Sum>k = 0..<?k. trace (P * D0 k ?\\<rho>)) + trace ?\\<rho> -\n  (\\<Sum>k = 0..<?k. trace (D0 k ?\\<rho>))\n\ngoal (1 subgoal):\n 1. \\<And>x1 S P.\n       \\<lbrakk>\\<And>P.\n                   \\<lbrakk>well_com S; is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n  trace (wlp S P * \\<rho>) =\n  trace (P * denote S \\<rho>) + trace \\<rho> - trace (denote S \\<rho>);\n        well_com (While x1 S); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                            trace (wlp (While x1 S) P * \\<rho>) =\n                            trace (P * denote (While x1 S) \\<rho>) +\n                            trace \\<rho> -\n                            trace (denote (While x1 S) \\<rho>)", "fix \\<rho>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1 S P.\n       \\<lbrakk>\\<And>P.\n                   \\<lbrakk>well_com S; is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n  trace (wlp S P * \\<rho>) =\n  trace (P * denote S \\<rho>) + trace \\<rho> - trace (denote S \\<rho>);\n        well_com (While x1 S); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                            trace (wlp (While x1 S) P * \\<rho>) =\n                            trace (P * denote (While x1 S) \\<rho>) +\n                            trace \\<rho> -\n                            trace (denote (While x1 S) \\<rho>)", "assume dsr: \"\\<rho> \\<in> density_states\""], ["proof (state)\nthis:\n  \\<rho> \\<in> density_states\n\ngoal (1 subgoal):\n 1. \\<And>x1 S P.\n       \\<lbrakk>\\<And>P.\n                   \\<lbrakk>well_com S; is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n  trace (wlp S P * \\<rho>) =\n  trace (P * denote S \\<rho>) + trace \\<rho> - trace (denote S \\<rho>);\n        well_com (While x1 S); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                            trace (wlp (While x1 S) P * \\<rho>) =\n                            trace (P * denote (While x1 S) \\<rho>) +\n                            trace \\<rho> -\n                            trace (denote (While x1 S) \\<rho>)", "then"], ["proof (chain)\npicking this:\n  \\<rho> \\<in> density_states", "have dr: \"\\<rho> \\<in> carrier_mat d d\" and pdor: \"partial_density_operator \\<rho>\""], ["proof (prove)\nusing this:\n  \\<rho> \\<in> density_states\n\ngoal (1 subgoal):\n 1. \\<rho> \\<in> carrier_mat d d &&& partial_density_operator \\<rho>", "using density_states_def"], ["proof (prove)\nusing this:\n  \\<rho> \\<in> density_states\n  density_states =\n  {\\<rho> \\<in> carrier_mat d d. partial_density_operator \\<rho>}\n\ngoal (1 subgoal):\n 1. \\<rho> \\<in> carrier_mat d d &&& partial_density_operator \\<rho>", "by auto"], ["proof (state)\nthis:\n  \\<rho> \\<in> carrier_mat d d\n  partial_density_operator \\<rho>\n\ngoal (1 subgoal):\n 1. \\<And>x1 S P.\n       \\<lbrakk>\\<And>P.\n                   \\<lbrakk>well_com S; is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n  trace (wlp S P * \\<rho>) =\n  trace (P * denote S \\<rho>) + trace \\<rho> - trace (denote S \\<rho>);\n        well_com (While x1 S); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                            trace (wlp (While x1 S) P * \\<rho>) =\n                            trace (P * denote (While x1 S) \\<rho>) +\n                            trace \\<rho> -\n                            trace (denote (While x1 S) \\<rho>)", "have limDW: \"limit_mat (\\<lambda>n. matrix_sum d (\\<lambda>k. D0 k \\<rho>) (n)) (denote (While M S) \\<rho>) d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. limit_mat (matrix_sum d (\\<lambda>k. D0 k \\<rho>))\n     (denote (While M S) \\<rho>) d", "using limit_mat_denote_while_n[OF wc dr pdor]"], ["proof (prove)\nusing this:\n  limit_mat\n   (matrix_sum d\n     (\\<lambda>k. denote_while_n (M 0) (M 1) (denote S) k \\<rho>))\n   (denote (While M S) \\<rho>) d\n\ngoal (1 subgoal):\n 1. limit_mat (matrix_sum d (\\<lambda>k. D0 k \\<rho>))\n     (denote (While M S) \\<rho>) d", "unfolding D0_def M0_def M1_def DS_def"], ["proof (prove)\nusing this:\n  limit_mat\n   (matrix_sum d\n     (\\<lambda>k. denote_while_n (M 0) (M 1) (denote S) k \\<rho>))\n   (denote (While M S) \\<rho>) d\n\ngoal (1 subgoal):\n 1. limit_mat\n     (matrix_sum d\n       (\\<lambda>k. denote_while_n (M 0) (M 1) (denote S) k \\<rho>))\n     (denote (While M S) \\<rho>) d", "by auto"], ["proof (state)\nthis:\n  limit_mat (matrix_sum d (\\<lambda>k. D0 k \\<rho>))\n   (denote (While M S) \\<rho>) d\n\ngoal (1 subgoal):\n 1. \\<And>x1 S P.\n       \\<lbrakk>\\<And>P.\n                   \\<lbrakk>well_com S; is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n  trace (wlp S P * \\<rho>) =\n  trace (P * denote S \\<rho>) + trace \\<rho> - trace (denote S \\<rho>);\n        well_com (While x1 S); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                            trace (wlp (While x1 S) P * \\<rho>) =\n                            trace (P * denote (While x1 S) \\<rho>) +\n                            trace \\<rho> -\n                            trace (denote (While x1 S) \\<rho>)", "then"], ["proof (chain)\npicking this:\n  limit_mat (matrix_sum d (\\<lambda>k. D0 k \\<rho>))\n   (denote (While M S) \\<rho>) d", "have \"limit_mat (\\<lambda>n. (P * (matrix_sum d (\\<lambda>k. D0 k \\<rho>) (n)))) (P * (denote (While M S) \\<rho>)) d\""], ["proof (prove)\nusing this:\n  limit_mat (matrix_sum d (\\<lambda>k. D0 k \\<rho>))\n   (denote (While M S) \\<rho>) d\n\ngoal (1 subgoal):\n 1. limit_mat (\\<lambda>n. P * matrix_sum d (\\<lambda>k. D0 k \\<rho>) n)\n     (P * denote (While M S) \\<rho>) d", "using mat_mult_limit[OF dP]"], ["proof (prove)\nusing this:\n  limit_mat (matrix_sum d (\\<lambda>k. D0 k \\<rho>))\n   (denote (While M S) \\<rho>) d\n  limit_mat ?X ?A d \\<Longrightarrow>\n  limit_mat (mat_mult_seq P ?X) (P * ?A) d\n\ngoal (1 subgoal):\n 1. limit_mat (\\<lambda>n. P * matrix_sum d (\\<lambda>k. D0 k \\<rho>) n)\n     (P * denote (While M S) \\<rho>) d", "unfolding mat_mult_seq_def"], ["proof (prove)\nusing this:\n  limit_mat (matrix_sum d (\\<lambda>k. D0 k \\<rho>))\n   (denote (While M S) \\<rho>) d\n  limit_mat ?X ?A d \\<Longrightarrow>\n  limit_mat (\\<lambda>n. P * ?X n) (P * ?A) d\n\ngoal (1 subgoal):\n 1. limit_mat (\\<lambda>n. P * matrix_sum d (\\<lambda>k. D0 k \\<rho>) n)\n     (P * denote (While M S) \\<rho>) d", "by auto"], ["proof (state)\nthis:\n  limit_mat (\\<lambda>n. P * matrix_sum d (\\<lambda>k. D0 k \\<rho>) n)\n   (P * denote (While M S) \\<rho>) d\n\ngoal (1 subgoal):\n 1. \\<And>x1 S P.\n       \\<lbrakk>\\<And>P.\n                   \\<lbrakk>well_com S; is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n  trace (wlp S P * \\<rho>) =\n  trace (P * denote S \\<rho>) + trace \\<rho> - trace (denote S \\<rho>);\n        well_com (While x1 S); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                            trace (wlp (While x1 S) P * \\<rho>) =\n                            trace (P * denote (While x1 S) \\<rho>) +\n                            trace \\<rho> -\n                            trace (denote (While x1 S) \\<rho>)", "then"], ["proof (chain)\npicking this:\n  limit_mat (\\<lambda>n. P * matrix_sum d (\\<lambda>k. D0 k \\<rho>) n)\n   (P * denote (While M S) \\<rho>) d", "have limtrPm: \"(\\<lambda>n. trace (P * (matrix_sum d (\\<lambda>k. D0 k \\<rho>) (n)))) \\<longlonglongrightarrow> trace (P * (denote (While M S) \\<rho>))\""], ["proof (prove)\nusing this:\n  limit_mat (\\<lambda>n. P * matrix_sum d (\\<lambda>k. D0 k \\<rho>) n)\n   (P * denote (While M S) \\<rho>) d\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. trace (P * matrix_sum d (\\<lambda>k. D0 k \\<rho>) n))\n    \\<longlonglongrightarrow> trace (P * denote (While M S) \\<rho>)", "using mat_trace_limit"], ["proof (prove)\nusing this:\n  limit_mat (\\<lambda>n. P * matrix_sum d (\\<lambda>k. D0 k \\<rho>) n)\n   (P * denote (While M S) \\<rho>) d\n  limit_mat ?g ?A ?d \\<Longrightarrow>\n  (\\<lambda>n. trace (?g n)) \\<longlonglongrightarrow> trace ?A\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. trace (P * matrix_sum d (\\<lambda>k. D0 k \\<rho>) n))\n    \\<longlonglongrightarrow> trace (P * denote (While M S) \\<rho>)", "by auto"], ["proof (state)\nthis:\n  (\\<lambda>n. trace (P * matrix_sum d (\\<lambda>k. D0 k \\<rho>) n))\n  \\<longlonglongrightarrow> trace (P * denote (While M S) \\<rho>)\n\ngoal (1 subgoal):\n 1. \\<And>x1 S P.\n       \\<lbrakk>\\<And>P.\n                   \\<lbrakk>well_com S; is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n  trace (wlp S P * \\<rho>) =\n  trace (P * denote S \\<rho>) + trace \\<rho> - trace (denote S \\<rho>);\n        well_com (While x1 S); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                            trace (wlp (While x1 S) P * \\<rho>) =\n                            trace (P * denote (While x1 S) \\<rho>) +\n                            trace \\<rho> -\n                            trace (denote (While x1 S) \\<rho>)", "with limDW"], ["proof (chain)\npicking this:\n  limit_mat (matrix_sum d (\\<lambda>k. D0 k \\<rho>))\n   (denote (While M S) \\<rho>) d\n  (\\<lambda>n. trace (P * matrix_sum d (\\<lambda>k. D0 k \\<rho>) n))\n  \\<longlonglongrightarrow> trace (P * denote (While M S) \\<rho>)", "have limtrDW:\"(\\<lambda>n. trace (matrix_sum d (\\<lambda>k. D0 k \\<rho>) (n))) \\<longlonglongrightarrow> trace (denote (While M S) \\<rho>)\""], ["proof (prove)\nusing this:\n  limit_mat (matrix_sum d (\\<lambda>k. D0 k \\<rho>))\n   (denote (While M S) \\<rho>) d\n  (\\<lambda>n. trace (P * matrix_sum d (\\<lambda>k. D0 k \\<rho>) n))\n  \\<longlonglongrightarrow> trace (P * denote (While M S) \\<rho>)\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. trace (matrix_sum d (\\<lambda>k. D0 k \\<rho>) n))\n    \\<longlonglongrightarrow> trace (denote (While M S) \\<rho>)", "using mat_trace_limit"], ["proof (prove)\nusing this:\n  limit_mat (matrix_sum d (\\<lambda>k. D0 k \\<rho>))\n   (denote (While M S) \\<rho>) d\n  (\\<lambda>n. trace (P * matrix_sum d (\\<lambda>k. D0 k \\<rho>) n))\n  \\<longlonglongrightarrow> trace (P * denote (While M S) \\<rho>)\n  limit_mat ?g ?A ?d \\<Longrightarrow>\n  (\\<lambda>n. trace (?g n)) \\<longlonglongrightarrow> trace ?A\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. trace (matrix_sum d (\\<lambda>k. D0 k \\<rho>) n))\n    \\<longlonglongrightarrow> trace (denote (While M S) \\<rho>)", "by auto"], ["proof (state)\nthis:\n  (\\<lambda>n. trace (matrix_sum d (\\<lambda>k. D0 k \\<rho>) n))\n  \\<longlonglongrightarrow> trace (denote (While M S) \\<rho>)\n\ngoal (1 subgoal):\n 1. \\<And>x1 S P.\n       \\<lbrakk>\\<And>P.\n                   \\<lbrakk>well_com S; is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n  trace (wlp S P * \\<rho>) =\n  trace (P * denote S \\<rho>) + trace \\<rho> - trace (denote S \\<rho>);\n        well_com (While x1 S); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                            trace (wlp (While x1 S) P * \\<rho>) =\n                            trace (P * denote (While x1 S) \\<rho>) +\n                            trace \\<rho> -\n                            trace (denote (While x1 S) \\<rho>)", "have limm: \"(\\<lambda>n. trace (matrix_sum d (\\<lambda>k. D0 k \\<rho>) (n))) \\<longlonglongrightarrow> trace (denote (While M S) \\<rho>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n. trace (matrix_sum d (\\<lambda>k. D0 k \\<rho>) n))\n    \\<longlonglongrightarrow> trace (denote (While M S) \\<rho>)", "using mat_trace_limit limDW"], ["proof (prove)\nusing this:\n  limit_mat ?g ?A ?d \\<Longrightarrow>\n  (\\<lambda>n. trace (?g n)) \\<longlonglongrightarrow> trace ?A\n  limit_mat (matrix_sum d (\\<lambda>k. D0 k \\<rho>))\n   (denote (While M S) \\<rho>) d\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. trace (matrix_sum d (\\<lambda>k. D0 k \\<rho>) n))\n    \\<longlonglongrightarrow> trace (denote (While M S) \\<rho>)", "by auto"], ["proof (state)\nthis:\n  (\\<lambda>n. trace (matrix_sum d (\\<lambda>k. D0 k \\<rho>) n))\n  \\<longlonglongrightarrow> trace (denote (While M S) \\<rho>)\n\ngoal (1 subgoal):\n 1. \\<And>x1 S P.\n       \\<lbrakk>\\<And>P.\n                   \\<lbrakk>well_com S; is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n  trace (wlp S P * \\<rho>) =\n  trace (P * denote S \\<rho>) + trace \\<rho> - trace (denote S \\<rho>);\n        well_com (While x1 S); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                            trace (wlp (While x1 S) P * \\<rho>) =\n                            trace (P * denote (While x1 S) \\<rho>) +\n                            trace \\<rho> -\n                            trace (denote (While x1 S) \\<rho>)", "have closeWS: \"is_quantum_predicate P \\<Longrightarrow> is_quantum_predicate (wlp S P)\" for P"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_quantum_predicate P \\<Longrightarrow> is_quantum_predicate (wlp S P)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. is_quantum_predicate P \\<Longrightarrow> is_quantum_predicate (wlp S P)", "assume asm: \"is_quantum_predicate P\""], ["proof (state)\nthis:\n  is_quantum_predicate P\n\ngoal (1 subgoal):\n 1. is_quantum_predicate P \\<Longrightarrow> is_quantum_predicate (wlp S P)", "then"], ["proof (chain)\npicking this:\n  is_quantum_predicate P", "have dP: \"P \\<in> carrier_mat d d\""], ["proof (prove)\nusing this:\n  is_quantum_predicate P\n\ngoal (1 subgoal):\n 1. P \\<in> carrier_mat d d", "using is_quantum_predicate_def"], ["proof (prove)\nusing this:\n  is_quantum_predicate P\n  is_quantum_predicate ?P =\n  (?P \\<in> carrier_mat d d \\<and>\n   positive ?P \\<and> ?P \\<le>\\<^sub>L 1\\<^sub>m d)\n\ngoal (1 subgoal):\n 1. P \\<in> carrier_mat d d", "by auto"], ["proof (state)\nthis:\n  P \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. is_quantum_predicate P \\<Longrightarrow> is_quantum_predicate (wlp S P)", "then"], ["proof (chain)\npicking this:\n  P \\<in> carrier_mat d d", "show \"is_quantum_predicate (wlp S P)\""], ["proof (prove)\nusing this:\n  P \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. is_quantum_predicate (wlp S P)", "using wlp_mono_and_close[OF wcS asm asm] lowner_le_refl"], ["proof (prove)\nusing this:\n  P \\<in> carrier_mat d d\n  P \\<le>\\<^sub>L P \\<Longrightarrow>\n  is_quantum_predicate (wlp S P) \\<and> wlp S P \\<le>\\<^sub>L wlp S P\n  ?A \\<in> carrier_mat ?n ?n \\<Longrightarrow> ?A \\<le>\\<^sub>L ?A\n\ngoal (1 subgoal):\n 1. is_quantum_predicate (wlp S P)", "by auto"], ["proof (state)\nthis:\n  is_quantum_predicate (wlp S P)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  is_quantum_predicate ?P \\<Longrightarrow> is_quantum_predicate (wlp S ?P)\n\ngoal (1 subgoal):\n 1. \\<And>x1 S P.\n       \\<lbrakk>\\<And>P.\n                   \\<lbrakk>well_com S; is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n  trace (wlp S P * \\<rho>) =\n  trace (P * denote S \\<rho>) + trace \\<rho> - trace (denote S \\<rho>);\n        well_com (While x1 S); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                            trace (wlp (While x1 S) P * \\<rho>) =\n                            trace (P * denote (While x1 S) \\<rho>) +\n                            trace \\<rho> -\n                            trace (denote (While x1 S) \\<rho>)", "have monoWS: \"is_quantum_predicate P \\<Longrightarrow> is_quantum_predicate Q \\<Longrightarrow> P \\<le>\\<^sub>L Q \\<Longrightarrow> wlp S P \\<le>\\<^sub>L wlp S Q\" for P Q"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_quantum_predicate P; is_quantum_predicate Q;\n     P \\<le>\\<^sub>L Q\\<rbrakk>\n    \\<Longrightarrow> wlp S P \\<le>\\<^sub>L wlp S Q", "using wlp_mono_and_close[OF wcS]"], ["proof (prove)\nusing this:\n  \\<lbrakk>is_quantum_predicate ?P; is_quantum_predicate ?Q;\n   ?P \\<le>\\<^sub>L ?Q\\<rbrakk>\n  \\<Longrightarrow> is_quantum_predicate (wlp S ?P) \\<and>\n                    wlp S ?P \\<le>\\<^sub>L wlp S ?Q\n\ngoal (1 subgoal):\n 1. \\<lbrakk>is_quantum_predicate P; is_quantum_predicate Q;\n     P \\<le>\\<^sub>L Q\\<rbrakk>\n    \\<Longrightarrow> wlp S P \\<le>\\<^sub>L wlp S Q", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>is_quantum_predicate ?P; is_quantum_predicate ?Q;\n   ?P \\<le>\\<^sub>L ?Q\\<rbrakk>\n  \\<Longrightarrow> wlp S ?P \\<le>\\<^sub>L wlp S ?Q\n\ngoal (1 subgoal):\n 1. \\<And>x1 S P.\n       \\<lbrakk>\\<And>P.\n                   \\<lbrakk>well_com S; is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n  trace (wlp S P * \\<rho>) =\n  trace (P * denote S \\<rho>) + trace \\<rho> - trace (denote S \\<rho>);\n        well_com (While x1 S); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                            trace (wlp (While x1 S) P * \\<rho>) =\n                            trace (P * denote (While x1 S) \\<rho>) +\n                            trace \\<rho> -\n                            trace (denote (While x1 S) \\<rho>)", "have \"is_quantum_predicate (wlp (While M S) P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_quantum_predicate (wlp (While M S) P)", "using wlp_while_exists[of \"wlp S\" M P] closeWS monoWS m qpP"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>P.\n              is_quantum_predicate P \\<Longrightarrow>\n              is_quantum_predicate (wlp S P);\n   \\<And>P Q.\n      \\<lbrakk>is_quantum_predicate P; is_quantum_predicate Q;\n       P \\<le>\\<^sub>L Q\\<rbrakk>\n      \\<Longrightarrow> wlp S P \\<le>\\<^sub>L wlp S Q;\n   measurement d 2 M; is_quantum_predicate P\\<rbrakk>\n  \\<Longrightarrow> is_quantum_predicate\n                     (wlp_while (M 0) (M 1) (wlp S) P) \\<and>\n                    (\\<forall>n.\n                        wlp_while (M 0) (M 1) (wlp S) P \\<le>\\<^sub>L\n                        wlp_while_n (M 0) (M 1) (wlp S) n P) \\<and>\n                    (\\<forall>W'.\n                        (\\<forall>n.\n                            W' \\<le>\\<^sub>L\n                            wlp_while_n (M 0) (M 1) (wlp S) n\n                             P) \\<longrightarrow>\n                        W' \\<le>\\<^sub>L\n                        wlp_while (M 0) (M 1) (wlp S) P) \\<and>\n                    limit_mat\n                     (\\<lambda>n. wlp_while_n (M 0) (M 1) (wlp S) n P)\n                     (wlp_while (M 0) (M 1) (wlp S) P) d\n  is_quantum_predicate ?P \\<Longrightarrow> is_quantum_predicate (wlp S ?P)\n  \\<lbrakk>is_quantum_predicate ?P; is_quantum_predicate ?Q;\n   ?P \\<le>\\<^sub>L ?Q\\<rbrakk>\n  \\<Longrightarrow> wlp S ?P \\<le>\\<^sub>L wlp S ?Q\n  measurement d 2 M\n  is_quantum_predicate P\n\ngoal (1 subgoal):\n 1. is_quantum_predicate (wlp (While M S) P)", "by auto"], ["proof (state)\nthis:\n  is_quantum_predicate (wlp (While M S) P)\n\ngoal (1 subgoal):\n 1. \\<And>x1 S P.\n       \\<lbrakk>\\<And>P.\n                   \\<lbrakk>well_com S; is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n  trace (wlp S P * \\<rho>) =\n  trace (P * denote S \\<rho>) + trace \\<rho> - trace (denote S \\<rho>);\n        well_com (While x1 S); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                            trace (wlp (While x1 S) P * \\<rho>) =\n                            trace (P * denote (While x1 S) \\<rho>) +\n                            trace \\<rho> -\n                            trace (denote (While x1 S) \\<rho>)", "have \"limit_mat W (wlp_while M0 M1 (wlp S) P) d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. limit_mat W (wlp_while M0 M1 (wlp S) P) d", "unfolding W_def M0_def M1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. limit_mat (\\<lambda>k. wlp_while_n (M 0) (M 1) (wlp S) k P)\n     (wlp_while (M 0) (M 1) (wlp S) P) d", "using wlp_while_exists[of \"wlp S\" M P] closeWS monoWS m qpP"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>P.\n              is_quantum_predicate P \\<Longrightarrow>\n              is_quantum_predicate (wlp S P);\n   \\<And>P Q.\n      \\<lbrakk>is_quantum_predicate P; is_quantum_predicate Q;\n       P \\<le>\\<^sub>L Q\\<rbrakk>\n      \\<Longrightarrow> wlp S P \\<le>\\<^sub>L wlp S Q;\n   measurement d 2 M; is_quantum_predicate P\\<rbrakk>\n  \\<Longrightarrow> is_quantum_predicate\n                     (wlp_while (M 0) (M 1) (wlp S) P) \\<and>\n                    (\\<forall>n.\n                        wlp_while (M 0) (M 1) (wlp S) P \\<le>\\<^sub>L\n                        wlp_while_n (M 0) (M 1) (wlp S) n P) \\<and>\n                    (\\<forall>W'.\n                        (\\<forall>n.\n                            W' \\<le>\\<^sub>L\n                            wlp_while_n (M 0) (M 1) (wlp S) n\n                             P) \\<longrightarrow>\n                        W' \\<le>\\<^sub>L\n                        wlp_while (M 0) (M 1) (wlp S) P) \\<and>\n                    limit_mat\n                     (\\<lambda>n. wlp_while_n (M 0) (M 1) (wlp S) n P)\n                     (wlp_while (M 0) (M 1) (wlp S) P) d\n  is_quantum_predicate ?P \\<Longrightarrow> is_quantum_predicate (wlp S ?P)\n  \\<lbrakk>is_quantum_predicate ?P; is_quantum_predicate ?Q;\n   ?P \\<le>\\<^sub>L ?Q\\<rbrakk>\n  \\<Longrightarrow> wlp S ?P \\<le>\\<^sub>L wlp S ?Q\n  measurement d 2 M\n  is_quantum_predicate P\n\ngoal (1 subgoal):\n 1. limit_mat (\\<lambda>k. wlp_while_n (M 0) (M 1) (wlp S) k P)\n     (wlp_while (M 0) (M 1) (wlp S) P) d", "by auto"], ["proof (state)\nthis:\n  limit_mat W (wlp_while M0 M1 (wlp S) P) d\n\ngoal (1 subgoal):\n 1. \\<And>x1 S P.\n       \\<lbrakk>\\<And>P.\n                   \\<lbrakk>well_com S; is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n  trace (wlp S P * \\<rho>) =\n  trace (P * denote S \\<rho>) + trace \\<rho> - trace (denote S \\<rho>);\n        well_com (While x1 S); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                            trace (wlp (While x1 S) P * \\<rho>) =\n                            trace (P * denote (While x1 S) \\<rho>) +\n                            trace \\<rho> -\n                            trace (denote (While x1 S) \\<rho>)", "then"], ["proof (chain)\npicking this:\n  limit_mat W (wlp_while M0 M1 (wlp S) P) d", "have \"limit_mat (\\<lambda>k. (W k) * \\<rho>) ((wlp_while M0 M1 (wlp S) P) * \\<rho>) d\""], ["proof (prove)\nusing this:\n  limit_mat W (wlp_while M0 M1 (wlp S) P) d\n\ngoal (1 subgoal):\n 1. limit_mat (\\<lambda>k. W k * \\<rho>)\n     (wlp_while M0 M1 (wlp S) P * \\<rho>) d", "using mult_mat_limit dr"], ["proof (prove)\nusing this:\n  limit_mat W (wlp_while M0 M1 (wlp S) P) d\n  \\<lbrakk>?B \\<in> carrier_mat ?m ?m; limit_mat ?X ?A ?m\\<rbrakk>\n  \\<Longrightarrow> limit_mat (\\<lambda>k. ?X k * ?B) (?A * ?B) ?m\n  \\<rho> \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. limit_mat (\\<lambda>k. W k * \\<rho>)\n     (wlp_while M0 M1 (wlp S) P * \\<rho>) d", "by auto"], ["proof (state)\nthis:\n  limit_mat (\\<lambda>k. W k * \\<rho>) (wlp_while M0 M1 (wlp S) P * \\<rho>)\n   d\n\ngoal (1 subgoal):\n 1. \\<And>x1 S P.\n       \\<lbrakk>\\<And>P.\n                   \\<lbrakk>well_com S; is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n  trace (wlp S P * \\<rho>) =\n  trace (P * denote S \\<rho>) + trace \\<rho> - trace (denote S \\<rho>);\n        well_com (While x1 S); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                            trace (wlp (While x1 S) P * \\<rho>) =\n                            trace (P * denote (While x1 S) \\<rho>) +\n                            trace \\<rho> -\n                            trace (denote (While x1 S) \\<rho>)", "then"], ["proof (chain)\npicking this:\n  limit_mat (\\<lambda>k. W k * \\<rho>) (wlp_while M0 M1 (wlp S) P * \\<rho>)\n   d", "have lim1: \"(\\<lambda>k. trace ((W k) * \\<rho>)) \\<longlonglongrightarrow> trace ((wlp_while M0 M1 (wlp S) P) * \\<rho>)\""], ["proof (prove)\nusing this:\n  limit_mat (\\<lambda>k. W k * \\<rho>) (wlp_while M0 M1 (wlp S) P * \\<rho>)\n   d\n\ngoal (1 subgoal):\n 1. (\\<lambda>k. trace (W k * \\<rho>))\n    \\<longlonglongrightarrow> trace (wlp_while M0 M1 (wlp S) P * \\<rho>)", "using mat_trace_limit"], ["proof (prove)\nusing this:\n  limit_mat (\\<lambda>k. W k * \\<rho>) (wlp_while M0 M1 (wlp S) P * \\<rho>)\n   d\n  limit_mat ?g ?A ?d \\<Longrightarrow>\n  (\\<lambda>n. trace (?g n)) \\<longlonglongrightarrow> trace ?A\n\ngoal (1 subgoal):\n 1. (\\<lambda>k. trace (W k * \\<rho>))\n    \\<longlonglongrightarrow> trace (wlp_while M0 M1 (wlp S) P * \\<rho>)", "by auto"], ["proof (state)\nthis:\n  (\\<lambda>k. trace (W k * \\<rho>))\n  \\<longlonglongrightarrow> trace (wlp_while M0 M1 (wlp S) P * \\<rho>)\n\ngoal (1 subgoal):\n 1. \\<And>x1 S P.\n       \\<lbrakk>\\<And>P.\n                   \\<lbrakk>well_com S; is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n  trace (wlp S P * \\<rho>) =\n  trace (P * denote S \\<rho>) + trace \\<rho> - trace (denote S \\<rho>);\n        well_com (While x1 S); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                            trace (wlp (While x1 S) P * \\<rho>) =\n                            trace (P * denote (While x1 S) \\<rho>) +\n                            trace \\<rho> -\n                            trace (denote (While x1 S) \\<rho>)", "have dD0kr: \"D0 k \\<rho> \\<in> carrier_mat d d\" for k"], ["proof (prove)\ngoal (1 subgoal):\n 1. D0 k \\<rho> \\<in> carrier_mat d d", "unfolding D0_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. denote_while_n M0 M1 DS k \\<rho> \\<in> carrier_mat d d", "using denote_while_n_dim[OF dr dM0 dM1 pdor] denote_positive_trace_dim[OF wcS, folded DS_def]"], ["proof (prove)\nusing this:\n  (\\<And>\\<rho>'.\n      \\<lbrakk>\\<rho>' \\<in> carrier_mat d d;\n       partial_density_operator \\<rho>'\\<rbrakk>\n      \\<Longrightarrow> positive (?DS \\<rho>') \\<and>\n                        trace (?DS \\<rho>') \\<le> trace \\<rho>' \\<and>\n                        ?DS \\<rho>' \\<in> carrier_mat d d) \\<Longrightarrow>\n  denote_while_n M0 M1 ?DS ?n \\<rho> \\<in> carrier_mat d d\n  \\<lbrakk>?\\<rho> \\<in> carrier_mat d d;\n   partial_density_operator ?\\<rho>\\<rbrakk>\n  \\<Longrightarrow> positive (DS ?\\<rho>) \\<and>\n                    trace (DS ?\\<rho>) \\<le> trace ?\\<rho> \\<and>\n                    DS ?\\<rho> \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. denote_while_n M0 M1 DS k \\<rho> \\<in> carrier_mat d d", "by auto"], ["proof (state)\nthis:\n  D0 ?k \\<rho> \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. \\<And>x1 S P.\n       \\<lbrakk>\\<And>P.\n                   \\<lbrakk>well_com S; is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n  trace (wlp S P * \\<rho>) =\n  trace (P * denote S \\<rho>) + trace \\<rho> - trace (denote S \\<rho>);\n        well_com (While x1 S); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                            trace (wlp (While x1 S) P * \\<rho>) =\n                            trace (P * denote (While x1 S) \\<rho>) +\n                            trace \\<rho> -\n                            trace (denote (While x1 S) \\<rho>)", "then"], ["proof (chain)\npicking this:\n  D0 ?k \\<rho> \\<in> carrier_mat d d", "have \"(P * (matrix_sum d (\\<lambda>k. D0 k \\<rho>) (n))) = matrix_sum d (\\<lambda>k. P * (D0 k \\<rho>)) n\" for n"], ["proof (prove)\nusing this:\n  D0 ?k \\<rho> \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. P * matrix_sum d (\\<lambda>k. D0 k \\<rho>) n =\n    matrix_sum d (\\<lambda>k. P * D0 k \\<rho>) n", "using matrix_sum_distrib_left[OF dP]"], ["proof (prove)\nusing this:\n  D0 ?k \\<rho> \\<in> carrier_mat d d\n  (\\<And>k.\n      k < ?n \\<Longrightarrow> ?f k \\<in> carrier_mat d d) \\<Longrightarrow>\n  matrix_sum d (\\<lambda>k. P * ?f k) ?n = P * matrix_sum d ?f ?n\n\ngoal (1 subgoal):\n 1. P * matrix_sum d (\\<lambda>k. D0 k \\<rho>) n =\n    matrix_sum d (\\<lambda>k. P * D0 k \\<rho>) n", "by auto"], ["proof (state)\nthis:\n  P * matrix_sum d (\\<lambda>k. D0 k \\<rho>) ?n =\n  matrix_sum d (\\<lambda>k. P * D0 k \\<rho>) ?n\n\ngoal (1 subgoal):\n 1. \\<And>x1 S P.\n       \\<lbrakk>\\<And>P.\n                   \\<lbrakk>well_com S; is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n  trace (wlp S P * \\<rho>) =\n  trace (P * denote S \\<rho>) + trace \\<rho> - trace (denote S \\<rho>);\n        well_com (While x1 S); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                            trace (wlp (While x1 S) P * \\<rho>) =\n                            trace (P * denote (While x1 S) \\<rho>) +\n                            trace \\<rho> -\n                            trace (denote (While x1 S) \\<rho>)", "moreover"], ["proof (state)\nthis:\n  P * matrix_sum d (\\<lambda>k. D0 k \\<rho>) ?n =\n  matrix_sum d (\\<lambda>k. P * D0 k \\<rho>) ?n\n\ngoal (1 subgoal):\n 1. \\<And>x1 S P.\n       \\<lbrakk>\\<And>P.\n                   \\<lbrakk>well_com S; is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n  trace (wlp S P * \\<rho>) =\n  trace (P * denote S \\<rho>) + trace \\<rho> - trace (denote S \\<rho>);\n        well_com (While x1 S); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                            trace (wlp (While x1 S) P * \\<rho>) =\n                            trace (P * denote (While x1 S) \\<rho>) +\n                            trace \\<rho> -\n                            trace (denote (While x1 S) \\<rho>)", "have \"trace (matrix_sum d (\\<lambda>k. P * (D0 k \\<rho>)) n) = (\\<Sum>k=0..<n. trace (P * (D0 k \\<rho>)))\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. trace (matrix_sum d (\\<lambda>k. P * D0 k \\<rho>) n) =\n    (\\<Sum>k = 0..<n. trace (P * D0 k \\<rho>))", "using trace_matrix_sum_linear dD0kr dP"], ["proof (prove)\nusing this:\n  (\\<And>k.\n      k < ?n \\<Longrightarrow>\n      ?f k \\<in> carrier_mat ?d ?d) \\<Longrightarrow>\n  trace (matrix_sum ?d ?f ?n) = (\\<Sum>k = 0..<?n. trace (?f k))\n  D0 ?k \\<rho> \\<in> carrier_mat d d\n  P \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. trace (matrix_sum d (\\<lambda>k. P * D0 k \\<rho>) n) =\n    (\\<Sum>k = 0..<n. trace (P * D0 k \\<rho>))", "by auto"], ["proof (state)\nthis:\n  trace (matrix_sum d (\\<lambda>k. P * D0 k \\<rho>) ?n) =\n  (\\<Sum>k = 0..<?n. trace (P * D0 k \\<rho>))\n\ngoal (1 subgoal):\n 1. \\<And>x1 S P.\n       \\<lbrakk>\\<And>P.\n                   \\<lbrakk>well_com S; is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n  trace (wlp S P * \\<rho>) =\n  trace (P * denote S \\<rho>) + trace \\<rho> - trace (denote S \\<rho>);\n        well_com (While x1 S); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                            trace (wlp (While x1 S) P * \\<rho>) =\n                            trace (P * denote (While x1 S) \\<rho>) +\n                            trace \\<rho> -\n                            trace (denote (While x1 S) \\<rho>)", "ultimately"], ["proof (chain)\npicking this:\n  P * matrix_sum d (\\<lambda>k. D0 k \\<rho>) ?n =\n  matrix_sum d (\\<lambda>k. P * D0 k \\<rho>) ?n\n  trace (matrix_sum d (\\<lambda>k. P * D0 k \\<rho>) ?n) =\n  (\\<Sum>k = 0..<?n. trace (P * D0 k \\<rho>))", "have eqPsD0kr: \"trace (P * (matrix_sum d (\\<lambda>k. D0 k \\<rho>) (n))) = (\\<Sum>k=0..<n. trace (P * (D0 k \\<rho>)))\" for n"], ["proof (prove)\nusing this:\n  P * matrix_sum d (\\<lambda>k. D0 k \\<rho>) ?n =\n  matrix_sum d (\\<lambda>k. P * D0 k \\<rho>) ?n\n  trace (matrix_sum d (\\<lambda>k. P * D0 k \\<rho>) ?n) =\n  (\\<Sum>k = 0..<?n. trace (P * D0 k \\<rho>))\n\ngoal (1 subgoal):\n 1. trace (P * matrix_sum d (\\<lambda>k. D0 k \\<rho>) n) =\n    (\\<Sum>k = 0..<n. trace (P * D0 k \\<rho>))", "by auto"], ["proof (state)\nthis:\n  trace (P * matrix_sum d (\\<lambda>k. D0 k \\<rho>) ?n) =\n  (\\<Sum>k = 0..<?n. trace (P * D0 k \\<rho>))\n\ngoal (1 subgoal):\n 1. \\<And>x1 S P.\n       \\<lbrakk>\\<And>P.\n                   \\<lbrakk>well_com S; is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n  trace (wlp S P * \\<rho>) =\n  trace (P * denote S \\<rho>) + trace \\<rho> - trace (denote S \\<rho>);\n        well_com (While x1 S); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                            trace (wlp (While x1 S) P * \\<rho>) =\n                            trace (P * denote (While x1 S) \\<rho>) +\n                            trace \\<rho> -\n                            trace (denote (While x1 S) \\<rho>)", "with limtrPm"], ["proof (chain)\npicking this:\n  (\\<lambda>n. trace (P * matrix_sum d (\\<lambda>k. D0 k \\<rho>) n))\n  \\<longlonglongrightarrow> trace (P * denote (While M S) \\<rho>)\n  trace (P * matrix_sum d (\\<lambda>k. D0 k \\<rho>) ?n) =\n  (\\<Sum>k = 0..<?n. trace (P * D0 k \\<rho>))", "have lim2: \"(\\<lambda>k. (\\<Sum>k=0..<k. trace (P * (D0 k \\<rho>)))) \\<longlonglongrightarrow> trace (P * (denote (While M S) \\<rho>))\""], ["proof (prove)\nusing this:\n  (\\<lambda>n. trace (P * matrix_sum d (\\<lambda>k. D0 k \\<rho>) n))\n  \\<longlonglongrightarrow> trace (P * denote (While M S) \\<rho>)\n  trace (P * matrix_sum d (\\<lambda>k. D0 k \\<rho>) ?n) =\n  (\\<Sum>k = 0..<?n. trace (P * D0 k \\<rho>))\n\ngoal (1 subgoal):\n 1. (\\<lambda>k. \\<Sum>k = 0..<k. trace (P * D0 k \\<rho>))\n    \\<longlonglongrightarrow> trace (P * denote (While M S) \\<rho>)", "by auto"], ["proof (state)\nthis:\n  (\\<lambda>k. \\<Sum>k = 0..<k. trace (P * D0 k \\<rho>))\n  \\<longlonglongrightarrow> trace (P * denote (While M S) \\<rho>)\n\ngoal (1 subgoal):\n 1. \\<And>x1 S P.\n       \\<lbrakk>\\<And>P.\n                   \\<lbrakk>well_com S; is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n  trace (wlp S P * \\<rho>) =\n  trace (P * denote S \\<rho>) + trace \\<rho> - trace (denote S \\<rho>);\n        well_com (While x1 S); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                            trace (wlp (While x1 S) P * \\<rho>) =\n                            trace (P * denote (While x1 S) \\<rho>) +\n                            trace \\<rho> -\n                            trace (denote (While x1 S) \\<rho>)", "have \"trace (matrix_sum d (\\<lambda>k. D0 k \\<rho>) (n)) = (\\<Sum>k=0..<n. trace (D0 k \\<rho>))\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. trace (matrix_sum d (\\<lambda>k. D0 k \\<rho>) n) =\n    (\\<Sum>k = 0..<n. trace (D0 k \\<rho>))", "using trace_matrix_sum_linear dD0kr"], ["proof (prove)\nusing this:\n  (\\<And>k.\n      k < ?n \\<Longrightarrow>\n      ?f k \\<in> carrier_mat ?d ?d) \\<Longrightarrow>\n  trace (matrix_sum ?d ?f ?n) = (\\<Sum>k = 0..<?n. trace (?f k))\n  D0 ?k \\<rho> \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. trace (matrix_sum d (\\<lambda>k. D0 k \\<rho>) n) =\n    (\\<Sum>k = 0..<n. trace (D0 k \\<rho>))", "by auto"], ["proof (state)\nthis:\n  trace (matrix_sum d (\\<lambda>k. D0 k \\<rho>) ?n) =\n  (\\<Sum>k = 0..<?n. trace (D0 k \\<rho>))\n\ngoal (1 subgoal):\n 1. \\<And>x1 S P.\n       \\<lbrakk>\\<And>P.\n                   \\<lbrakk>well_com S; is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n  trace (wlp S P * \\<rho>) =\n  trace (P * denote S \\<rho>) + trace \\<rho> - trace (denote S \\<rho>);\n        well_com (While x1 S); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                            trace (wlp (While x1 S) P * \\<rho>) =\n                            trace (P * denote (While x1 S) \\<rho>) +\n                            trace \\<rho> -\n                            trace (denote (While x1 S) \\<rho>)", "with limtrDW"], ["proof (chain)\npicking this:\n  (\\<lambda>n. trace (matrix_sum d (\\<lambda>k. D0 k \\<rho>) n))\n  \\<longlonglongrightarrow> trace (denote (While M S) \\<rho>)\n  trace (matrix_sum d (\\<lambda>k. D0 k \\<rho>) ?n) =\n  (\\<Sum>k = 0..<?n. trace (D0 k \\<rho>))", "have lim3: \"(\\<lambda>k. (\\<Sum>k=0..<k. trace (D0 k \\<rho>))) \\<longlonglongrightarrow> trace (denote (While M S) \\<rho>)\""], ["proof (prove)\nusing this:\n  (\\<lambda>n. trace (matrix_sum d (\\<lambda>k. D0 k \\<rho>) n))\n  \\<longlonglongrightarrow> trace (denote (While M S) \\<rho>)\n  trace (matrix_sum d (\\<lambda>k. D0 k \\<rho>) ?n) =\n  (\\<Sum>k = 0..<?n. trace (D0 k \\<rho>))\n\ngoal (1 subgoal):\n 1. (\\<lambda>k. \\<Sum>k = 0..<k. trace (D0 k \\<rho>))\n    \\<longlonglongrightarrow> trace (denote (While M S) \\<rho>)", "by auto"], ["proof (state)\nthis:\n  (\\<lambda>k. \\<Sum>k = 0..<k. trace (D0 k \\<rho>))\n  \\<longlonglongrightarrow> trace (denote (While M S) \\<rho>)\n\ngoal (1 subgoal):\n 1. \\<And>x1 S P.\n       \\<lbrakk>\\<And>P.\n                   \\<lbrakk>well_com S; is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n  trace (wlp S P * \\<rho>) =\n  trace (P * denote S \\<rho>) + trace \\<rho> - trace (denote S \\<rho>);\n        well_com (While x1 S); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                            trace (wlp (While x1 S) P * \\<rho>) =\n                            trace (P * denote (While x1 S) \\<rho>) +\n                            trace \\<rho> -\n                            trace (denote (While x1 S) \\<rho>)", "have \"(\\<lambda>k. (\\<Sum>k=0..<k. trace (P * (D0 k \\<rho>))) + trace \\<rho>) \\<longlonglongrightarrow> trace (P * (denote (While M S) \\<rho>)) + trace \\<rho>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>k. (\\<Sum>k = 0..<k. trace (P * D0 k \\<rho>)) + trace \\<rho>)\n    \\<longlonglongrightarrow> trace (P * denote (While M S) \\<rho>) +\n                              trace \\<rho>", "using tendsto_add[of \"\\<lambda>k. (\\<Sum>k=0..<k. trace (P * (D0 k \\<rho>)))\"] lim2"], ["proof (prove)\nusing this:\n  \\<lbrakk>((\\<lambda>k.\n                \\<Sum>k = 0..<k.\n                   trace (P * D0 k \\<rho>)) \\<longlongrightarrow>\n            ?a)\n            ?F;\n   (?g \\<longlongrightarrow> ?b) ?F\\<rbrakk>\n  \\<Longrightarrow> ((\\<lambda>x.\n                         (\\<Sum>k = 0..<x. trace (P * D0 k \\<rho>)) +\n                         ?g x) \\<longlongrightarrow>\n                     ?a + ?b)\n                     ?F\n  (\\<lambda>k. \\<Sum>k = 0..<k. trace (P * D0 k \\<rho>))\n  \\<longlonglongrightarrow> trace (P * denote (While M S) \\<rho>)\n\ngoal (1 subgoal):\n 1. (\\<lambda>k. (\\<Sum>k = 0..<k. trace (P * D0 k \\<rho>)) + trace \\<rho>)\n    \\<longlonglongrightarrow> trace (P * denote (While M S) \\<rho>) +\n                              trace \\<rho>", "by auto"], ["proof (state)\nthis:\n  (\\<lambda>k. (\\<Sum>k = 0..<k. trace (P * D0 k \\<rho>)) + trace \\<rho>)\n  \\<longlonglongrightarrow> trace (P * denote (While M S) \\<rho>) +\n                            trace \\<rho>\n\ngoal (1 subgoal):\n 1. \\<And>x1 S P.\n       \\<lbrakk>\\<And>P.\n                   \\<lbrakk>well_com S; is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n  trace (wlp S P * \\<rho>) =\n  trace (P * denote S \\<rho>) + trace \\<rho> - trace (denote S \\<rho>);\n        well_com (While x1 S); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                            trace (wlp (While x1 S) P * \\<rho>) =\n                            trace (P * denote (While x1 S) \\<rho>) +\n                            trace \\<rho> -\n                            trace (denote (While x1 S) \\<rho>)", "then"], ["proof (chain)\npicking this:\n  (\\<lambda>k. (\\<Sum>k = 0..<k. trace (P * D0 k \\<rho>)) + trace \\<rho>)\n  \\<longlonglongrightarrow> trace (P * denote (While M S) \\<rho>) +\n                            trace \\<rho>", "have \"(\\<lambda>k. (\\<Sum>k=0..<k. trace (P * (D0 k \\<rho>))) + trace \\<rho> - (\\<Sum>k=0..<k. trace (D0 k \\<rho>)))\n       \\<longlonglongrightarrow> trace (P * (denote (While M S) \\<rho>)) + trace \\<rho> -  trace (denote (While M S) \\<rho>)\""], ["proof (prove)\nusing this:\n  (\\<lambda>k. (\\<Sum>k = 0..<k. trace (P * D0 k \\<rho>)) + trace \\<rho>)\n  \\<longlonglongrightarrow> trace (P * denote (While M S) \\<rho>) +\n                            trace \\<rho>\n\ngoal (1 subgoal):\n 1. (\\<lambda>k.\n        (\\<Sum>k = 0..<k. trace (P * D0 k \\<rho>)) + trace \\<rho> -\n        (\\<Sum>k = 0..<k. trace (D0 k \\<rho>)))\n    \\<longlonglongrightarrow> trace (P * denote (While M S) \\<rho>) +\n                              trace \\<rho> -\n                              trace (denote (While M S) \\<rho>)", "using tendsto_diff[of _ _ _ \"\\<lambda>k. (\\<Sum>k=0..<k. trace (D0 k \\<rho>))\"] lim3"], ["proof (prove)\nusing this:\n  (\\<lambda>k. (\\<Sum>k = 0..<k. trace (P * D0 k \\<rho>)) + trace \\<rho>)\n  \\<longlonglongrightarrow> trace (P * denote (While M S) \\<rho>) +\n                            trace \\<rho>\n  \\<lbrakk>(?f \\<longlongrightarrow> ?a) ?F;\n   ((\\<lambda>k. \\<Sum>k = 0..<k. trace (D0 k \\<rho>)) \\<longlongrightarrow>\n    ?b)\n    ?F\\<rbrakk>\n  \\<Longrightarrow> ((\\<lambda>x.\n                         ?f x -\n                         (\\<Sum>k = 0..<x.\n                             trace (D0 k \\<rho>))) \\<longlongrightarrow>\n                     ?a - ?b)\n                     ?F\n  (\\<lambda>k. \\<Sum>k = 0..<k. trace (D0 k \\<rho>))\n  \\<longlonglongrightarrow> trace (denote (While M S) \\<rho>)\n\ngoal (1 subgoal):\n 1. (\\<lambda>k.\n        (\\<Sum>k = 0..<k. trace (P * D0 k \\<rho>)) + trace \\<rho> -\n        (\\<Sum>k = 0..<k. trace (D0 k \\<rho>)))\n    \\<longlonglongrightarrow> trace (P * denote (While M S) \\<rho>) +\n                              trace \\<rho> -\n                              trace (denote (While M S) \\<rho>)", "by auto"], ["proof (state)\nthis:\n  (\\<lambda>k.\n      (\\<Sum>k = 0..<k. trace (P * D0 k \\<rho>)) + trace \\<rho> -\n      (\\<Sum>k = 0..<k. trace (D0 k \\<rho>)))\n  \\<longlonglongrightarrow> trace (P * denote (While M S) \\<rho>) +\n                            trace \\<rho> -\n                            trace (denote (While M S) \\<rho>)\n\ngoal (1 subgoal):\n 1. \\<And>x1 S P.\n       \\<lbrakk>\\<And>P.\n                   \\<lbrakk>well_com S; is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n  trace (wlp S P * \\<rho>) =\n  trace (P * denote S \\<rho>) + trace \\<rho> - trace (denote S \\<rho>);\n        well_com (While x1 S); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                            trace (wlp (While x1 S) P * \\<rho>) =\n                            trace (P * denote (While x1 S) \\<rho>) +\n                            trace \\<rho> -\n                            trace (denote (While x1 S) \\<rho>)", "then"], ["proof (chain)\npicking this:\n  (\\<lambda>k.\n      (\\<Sum>k = 0..<k. trace (P * D0 k \\<rho>)) + trace \\<rho> -\n      (\\<Sum>k = 0..<k. trace (D0 k \\<rho>)))\n  \\<longlonglongrightarrow> trace (P * denote (While M S) \\<rho>) +\n                            trace \\<rho> -\n                            trace (denote (While M S) \\<rho>)", "have lim4: \"(\\<lambda>k. trace ((W k) * \\<rho>)) \\<longlonglongrightarrow> trace (P * (denote (While M S) \\<rho>)) + trace \\<rho> -  trace (denote (While M S) \\<rho>)\""], ["proof (prove)\nusing this:\n  (\\<lambda>k.\n      (\\<Sum>k = 0..<k. trace (P * D0 k \\<rho>)) + trace \\<rho> -\n      (\\<Sum>k = 0..<k. trace (D0 k \\<rho>)))\n  \\<longlonglongrightarrow> trace (P * denote (While M S) \\<rho>) +\n                            trace \\<rho> -\n                            trace (denote (While M S) \\<rho>)\n\ngoal (1 subgoal):\n 1. (\\<lambda>k. trace (W k * \\<rho>))\n    \\<longlonglongrightarrow> trace (P * denote (While M S) \\<rho>) +\n                              trace \\<rho> -\n                              trace (denote (While M S) \\<rho>)", "using eqk[OF dsr]"], ["proof (prove)\nusing this:\n  (\\<lambda>k.\n      (\\<Sum>k = 0..<k. trace (P * D0 k \\<rho>)) + trace \\<rho> -\n      (\\<Sum>k = 0..<k. trace (D0 k \\<rho>)))\n  \\<longlonglongrightarrow> trace (P * denote (While M S) \\<rho>) +\n                            trace \\<rho> -\n                            trace (denote (While M S) \\<rho>)\n  trace (W ?k * \\<rho>) =\n  (\\<Sum>k = 0..<?k. trace (P * D0 k \\<rho>)) + trace \\<rho> -\n  (\\<Sum>k = 0..<?k. trace (D0 k \\<rho>))\n\ngoal (1 subgoal):\n 1. (\\<lambda>k. trace (W k * \\<rho>))\n    \\<longlonglongrightarrow> trace (P * denote (While M S) \\<rho>) +\n                              trace \\<rho> -\n                              trace (denote (While M S) \\<rho>)", "by auto"], ["proof (state)\nthis:\n  (\\<lambda>k. trace (W k * \\<rho>))\n  \\<longlonglongrightarrow> trace (P * denote (While M S) \\<rho>) +\n                            trace \\<rho> -\n                            trace (denote (While M S) \\<rho>)\n\ngoal (1 subgoal):\n 1. \\<And>x1 S P.\n       \\<lbrakk>\\<And>P.\n                   \\<lbrakk>well_com S; is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n  trace (wlp S P * \\<rho>) =\n  trace (P * denote S \\<rho>) + trace \\<rho> - trace (denote S \\<rho>);\n        well_com (While x1 S); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                            trace (wlp (While x1 S) P * \\<rho>) =\n                            trace (P * denote (While x1 S) \\<rho>) +\n                            trace \\<rho> -\n                            trace (denote (While x1 S) \\<rho>)", "then"], ["proof (chain)\npicking this:\n  (\\<lambda>k. trace (W k * \\<rho>))\n  \\<longlonglongrightarrow> trace (P * denote (While M S) \\<rho>) +\n                            trace \\<rho> -\n                            trace (denote (While M S) \\<rho>)", "have \"trace ((wlp_while M0 M1 (wlp S) P) * \\<rho>) = trace (P * (denote (While M S) \\<rho>)) + trace \\<rho> -  trace (denote (While M S) \\<rho>)\""], ["proof (prove)\nusing this:\n  (\\<lambda>k. trace (W k * \\<rho>))\n  \\<longlonglongrightarrow> trace (P * denote (While M S) \\<rho>) +\n                            trace \\<rho> -\n                            trace (denote (While M S) \\<rho>)\n\ngoal (1 subgoal):\n 1. trace (wlp_while M0 M1 (wlp S) P * \\<rho>) =\n    trace (P * denote (While M S) \\<rho>) + trace \\<rho> -\n    trace (denote (While M S) \\<rho>)", "using eqk[OF dsr] tendsto_unique[OF _ lim1 lim4]"], ["proof (prove)\nusing this:\n  (\\<lambda>k. trace (W k * \\<rho>))\n  \\<longlonglongrightarrow> trace (P * denote (While M S) \\<rho>) +\n                            trace \\<rho> -\n                            trace (denote (While M S) \\<rho>)\n  trace (W ?k * \\<rho>) =\n  (\\<Sum>k = 0..<?k. trace (P * D0 k \\<rho>)) + trace \\<rho> -\n  (\\<Sum>k = 0..<?k. trace (D0 k \\<rho>))\n  sequentially \\<noteq> bot \\<Longrightarrow>\n  trace (wlp_while M0 M1 (wlp S) P * \\<rho>) =\n  trace (P * denote (While M S) \\<rho>) + trace \\<rho> -\n  trace (denote (While M S) \\<rho>)\n\ngoal (1 subgoal):\n 1. trace (wlp_while M0 M1 (wlp S) P * \\<rho>) =\n    trace (P * denote (While M S) \\<rho>) + trace \\<rho> -\n    trace (denote (While M S) \\<rho>)", "by auto"], ["proof (state)\nthis:\n  trace (wlp_while M0 M1 (wlp S) P * \\<rho>) =\n  trace (P * denote (While M S) \\<rho>) + trace \\<rho> -\n  trace (denote (While M S) \\<rho>)\n\ngoal (1 subgoal):\n 1. \\<And>x1 S P.\n       \\<lbrakk>\\<And>P.\n                   \\<lbrakk>well_com S; is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n  trace (wlp S P * \\<rho>) =\n  trace (P * denote S \\<rho>) + trace \\<rho> - trace (denote S \\<rho>);\n        well_com (While x1 S); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                            trace (wlp (While x1 S) P * \\<rho>) =\n                            trace (P * denote (While x1 S) \\<rho>) +\n                            trace \\<rho> -\n                            trace (denote (While x1 S) \\<rho>)", "}"], ["proof (state)\nthis:\n  ?\\<rho>2 \\<in> density_states \\<Longrightarrow>\n  trace (wlp_while M0 M1 (wlp S) P * ?\\<rho>2) =\n  trace (P * denote (While M S) ?\\<rho>2) + trace ?\\<rho>2 -\n  trace (denote (While M S) ?\\<rho>2)\n\ngoal (1 subgoal):\n 1. \\<And>x1 S P.\n       \\<lbrakk>\\<And>P.\n                   \\<lbrakk>well_com S; is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n  trace (wlp S P * \\<rho>) =\n  trace (P * denote S \\<rho>) + trace \\<rho> - trace (denote S \\<rho>);\n        well_com (While x1 S); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                            trace (wlp (While x1 S) P * \\<rho>) =\n                            trace (P * denote (While x1 S) \\<rho>) +\n                            trace \\<rho> -\n                            trace (denote (While x1 S) \\<rho>)", "then"], ["proof (chain)\npicking this:\n  ?\\<rho>2 \\<in> density_states \\<Longrightarrow>\n  trace (wlp_while M0 M1 (wlp S) P * ?\\<rho>2) =\n  trace (P * denote (While M S) ?\\<rho>2) + trace ?\\<rho>2 -\n  trace (denote (While M S) ?\\<rho>2)", "show ?case"], ["proof (prove)\nusing this:\n  ?\\<rho>2 \\<in> density_states \\<Longrightarrow>\n  trace (wlp_while M0 M1 (wlp S) P * ?\\<rho>2) =\n  trace (P * denote (While M S) ?\\<rho>2) + trace ?\\<rho>2 -\n  trace (denote (While M S) ?\\<rho>2)\n\ngoal (1 subgoal):\n 1. \\<forall>\\<rho>\\<in>density_states.\n       trace (wlp (While M S) P * \\<rho>) =\n       trace (P * denote (While M S) \\<rho>) + trace \\<rho> -\n       trace (denote (While M S) \\<rho>)", "unfolding M0_def M1_def DS_def wlp.simps"], ["proof (prove)\nusing this:\n  ?\\<rho>2 \\<in> density_states \\<Longrightarrow>\n  trace (wlp_while (M 0) (M 1) (wlp S) P * ?\\<rho>2) =\n  trace (P * denote (While M S) ?\\<rho>2) + trace ?\\<rho>2 -\n  trace (denote (While M S) ?\\<rho>2)\n\ngoal (1 subgoal):\n 1. \\<forall>\\<rho>\\<in>density_states.\n       trace (wlp_while (M 0) (M 1) (wlp S) P * \\<rho>) =\n       trace (P * denote (While M S) \\<rho>) + trace \\<rho> -\n       trace (denote (While M S) \\<rho>)", "by auto"], ["proof (state)\nthis:\n  \\<forall>\\<rho>\\<in>density_states.\n     trace (wlp (While M S) P * \\<rho>) =\n     trace (P * denote (While M S) \\<rho>) + trace \\<rho> -\n     trace (denote (While M S) \\<rho>)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma denote_while_split:\n  assumes wc: \"well_com (While M S)\" and dsr: \"\\<rho> \\<in> density_states\"\n  shows \"denote (While M S) \\<rho> = (M 0) * \\<rho> * adjoint (M 0) + denote (While M S) (denote S (M 1 * \\<rho> * adjoint (M 1)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. denote (While M S) \\<rho> =\n    M 0 * \\<rho> * adjoint (M 0) +\n    denote (While M S) (denote S (M 1 * \\<rho> * adjoint (M 1)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. denote (While M S) \\<rho> =\n    M 0 * \\<rho> * adjoint (M 0) +\n    denote (While M S) (denote S (M 1 * \\<rho> * adjoint (M 1)))", "have m: \"measurement d 2 M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. measurement d 2 M", "using wc"], ["proof (prove)\nusing this:\n  well_com (While M S)\n\ngoal (1 subgoal):\n 1. measurement d 2 M", "by auto"], ["proof (state)\nthis:\n  measurement d 2 M\n\ngoal (1 subgoal):\n 1. denote (While M S) \\<rho> =\n    M 0 * \\<rho> * adjoint (M 0) +\n    denote (While M S) (denote S (M 1 * \\<rho> * adjoint (M 1)))", "have wcs: \"well_com S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. well_com S", "using wc"], ["proof (prove)\nusing this:\n  well_com (While M S)\n\ngoal (1 subgoal):\n 1. well_com S", "by auto"], ["proof (state)\nthis:\n  well_com S\n\ngoal (1 subgoal):\n 1. denote (While M S) \\<rho> =\n    M 0 * \\<rho> * adjoint (M 0) +\n    denote (While M S) (denote S (M 1 * \\<rho> * adjoint (M 1)))", "define M0 where \"M0 = M 0\""], ["proof (state)\nthis:\n  M0 = M 0\n\ngoal (1 subgoal):\n 1. denote (While M S) \\<rho> =\n    M 0 * \\<rho> * adjoint (M 0) +\n    denote (While M S) (denote S (M 1 * \\<rho> * adjoint (M 1)))", "define M1 where \"M1 = M 1\""], ["proof (state)\nthis:\n  M1 = M 1\n\ngoal (1 subgoal):\n 1. denote (While M S) \\<rho> =\n    M 0 * \\<rho> * adjoint (M 0) +\n    denote (While M S) (denote S (M 1 * \\<rho> * adjoint (M 1)))", "have dM0: \"M0 \\<in> carrier_mat d d\" and dM1: \"M1 \\<in> carrier_mat d d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M0 \\<in> carrier_mat d d &&& M1 \\<in> carrier_mat d d", "using m measurement_def M0_def M1_def"], ["proof (prove)\nusing this:\n  measurement d 2 M\n  measurement ?d ?n ?M =\n  ((\\<forall>j<?n. ?M j \\<in> carrier_mat ?d ?d) \\<and>\n   matrix_sum ?d (\\<lambda>j. adjoint (?M j) * ?M j) ?n = 1\\<^sub>m ?d)\n  M0 = M 0\n  M1 = M 1\n\ngoal (1 subgoal):\n 1. M0 \\<in> carrier_mat d d &&& M1 \\<in> carrier_mat d d", "by auto"], ["proof (state)\nthis:\n  M0 \\<in> carrier_mat d d\n  M1 \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. denote (While M S) \\<rho> =\n    M 0 * \\<rho> * adjoint (M 0) +\n    denote (While M S) (denote S (M 1 * \\<rho> * adjoint (M 1)))", "have M1leq: \"adjoint M1 * M1 \\<le>\\<^sub>L 1\\<^sub>m d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adjoint M1 * M1 \\<le>\\<^sub>L 1\\<^sub>m d", "using measurement_le_one_mat m M1_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>measurement ?d ?n ?f; ?j < ?n\\<rbrakk>\n  \\<Longrightarrow> adjoint (?f ?j) * ?f ?j \\<le>\\<^sub>L 1\\<^sub>m ?d\n  measurement d 2 M\n  M1 = M 1\n\ngoal (1 subgoal):\n 1. adjoint M1 * M1 \\<le>\\<^sub>L 1\\<^sub>m d", "by auto"], ["proof (state)\nthis:\n  adjoint M1 * M1 \\<le>\\<^sub>L 1\\<^sub>m d\n\ngoal (1 subgoal):\n 1. denote (While M S) \\<rho> =\n    M 0 * \\<rho> * adjoint (M 0) +\n    denote (While M S) (denote S (M 1 * \\<rho> * adjoint (M 1)))", "define DS where \"DS = denote S\""], ["proof (state)\nthis:\n  DS = denote S\n\ngoal (1 subgoal):\n 1. denote (While M S) \\<rho> =\n    M 0 * \\<rho> * adjoint (M 0) +\n    denote (While M S) (denote S (M 1 * \\<rho> * adjoint (M 1)))", "define D0 where \"D0 = denote_while_n M0 M1 DS\""], ["proof (state)\nthis:\n  D0 = denote_while_n M0 M1 DS\n\ngoal (1 subgoal):\n 1. denote (While M S) \\<rho> =\n    M 0 * \\<rho> * adjoint (M 0) +\n    denote (While M S) (denote S (M 1 * \\<rho> * adjoint (M 1)))", "define D1 where \"D1 = denote_while_n_comp M0 M1 DS\""], ["proof (state)\nthis:\n  D1 = denote_while_n_comp M0 M1 DS\n\ngoal (1 subgoal):\n 1. denote (While M S) \\<rho> =\n    M 0 * \\<rho> * adjoint (M 0) +\n    denote (While M S) (denote S (M 1 * \\<rho> * adjoint (M 1)))", "define D where \"D = denote_while_n_iter M0 M1 DS\""], ["proof (state)\nthis:\n  D = denote_while_n_iter M0 M1 DS\n\ngoal (1 subgoal):\n 1. denote (While M S) \\<rho> =\n    M 0 * \\<rho> * adjoint (M 0) +\n    denote (While M S) (denote S (M 1 * \\<rho> * adjoint (M 1)))", "define DW where \"DW \\<rho> = denote (While M S) \\<rho>\" for \\<rho>"], ["proof (state)\nthis:\n  DW ?\\<rho> = denote (While M S) ?\\<rho>\n\ngoal (1 subgoal):\n 1. denote (While M S) \\<rho> =\n    M 0 * \\<rho> * adjoint (M 0) +\n    denote (While M S) (denote S (M 1 * \\<rho> * adjoint (M 1)))", "{"], ["proof (state)\nthis:\n  DW ?\\<rho> = denote (While M S) ?\\<rho>\n\ngoal (1 subgoal):\n 1. denote (While M S) \\<rho> =\n    M 0 * \\<rho> * adjoint (M 0) +\n    denote (While M S) (denote S (M 1 * \\<rho> * adjoint (M 1)))", "fix \\<rho>"], ["proof (state)\ngoal (1 subgoal):\n 1. denote (While M S) \\<rho> =\n    M 0 * \\<rho> * adjoint (M 0) +\n    denote (While M S) (denote S (M 1 * \\<rho> * adjoint (M 1)))", "assume dsr: \"\\<rho> \\<in> density_states\""], ["proof (state)\nthis:\n  \\<rho> \\<in> density_states\n\ngoal (1 subgoal):\n 1. denote (While M S) \\<rho> =\n    M 0 * \\<rho> * adjoint (M 0) +\n    denote (While M S) (denote S (M 1 * \\<rho> * adjoint (M 1)))", "then"], ["proof (chain)\npicking this:\n  \\<rho> \\<in> density_states", "have dr: \"\\<rho> \\<in> carrier_mat d d\" and pdor: \"partial_density_operator \\<rho>\""], ["proof (prove)\nusing this:\n  \\<rho> \\<in> density_states\n\ngoal (1 subgoal):\n 1. \\<rho> \\<in> carrier_mat d d &&& partial_density_operator \\<rho>", "using density_states_def"], ["proof (prove)\nusing this:\n  \\<rho> \\<in> density_states\n  density_states =\n  {\\<rho> \\<in> carrier_mat d d. partial_density_operator \\<rho>}\n\ngoal (1 subgoal):\n 1. \\<rho> \\<in> carrier_mat d d &&& partial_density_operator \\<rho>", "by auto"], ["proof (state)\nthis:\n  \\<rho> \\<in> carrier_mat d d\n  partial_density_operator \\<rho>\n\ngoal (1 subgoal):\n 1. denote (While M S) \\<rho> =\n    M 0 * \\<rho> * adjoint (M 0) +\n    denote (While M S) (denote S (M 1 * \\<rho> * adjoint (M 1)))", "have pdoDkr: \"\\<And>k. partial_density_operator (D k \\<rho>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>k. partial_density_operator (D k \\<rho>)", "unfolding D_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>k.\n       partial_density_operator (denote_while_n_iter M0 M1 DS k \\<rho>)", "using pdo_denote_while_n_iter[OF dr pdor dM1 M1leq]\n      denote_partial_density_operator[OF wcs] denote_dim[OF wcs, folded DS_def]"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>\\<rho>.\n              \\<rho> \\<in> carrier_mat d d \\<and>\n              partial_density_operator \\<rho> \\<Longrightarrow>\n              partial_density_operator (?DS \\<rho>);\n   \\<And>\\<rho>.\n      \\<rho> \\<in> carrier_mat d d \\<and>\n      partial_density_operator \\<rho> \\<Longrightarrow>\n      ?DS \\<rho> \\<in> carrier_mat d d\\<rbrakk>\n  \\<Longrightarrow> partial_density_operator\n                     (denote_while_n_iter ?M0.0 M1 ?DS ?n \\<rho>)\n  \\<lbrakk>partial_density_operator ?\\<rho>;\n   ?\\<rho> \\<in> carrier_mat d d\\<rbrakk>\n  \\<Longrightarrow> partial_density_operator (denote S ?\\<rho>)\n  \\<lbrakk>?\\<rho> \\<in> carrier_mat d d;\n   partial_density_operator ?\\<rho>\\<rbrakk>\n  \\<Longrightarrow> DS ?\\<rho> \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       partial_density_operator (denote_while_n_iter M0 M1 DS k \\<rho>)", "apply (fold DS_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>\\<And>DS M0 n.\n                   \\<lbrakk>\\<And>\\<rho>.\n                               \\<rho> \\<in> carrier_mat d d \\<and>\n                               partial_density_operator\n                                \\<rho> \\<Longrightarrow>\n                               partial_density_operator (DS \\<rho>);\n                    \\<And>\\<rho>.\n                       \\<rho> \\<in> carrier_mat d d \\<and>\n                       partial_density_operator \\<rho> \\<Longrightarrow>\n                       DS \\<rho> \\<in> carrier_mat d d\\<rbrakk>\n                   \\<Longrightarrow> partial_density_operator\n(denote_while_n_iter M0 M1 DS n \\<rho>);\n        \\<And>\\<rho>.\n           \\<lbrakk>partial_density_operator \\<rho>;\n            \\<rho> \\<in> carrier_mat d d\\<rbrakk>\n           \\<Longrightarrow> partial_density_operator (DS \\<rho>);\n        \\<And>\\<rho>.\n           \\<lbrakk>\\<rho> \\<in> carrier_mat d d;\n            partial_density_operator \\<rho>\\<rbrakk>\n           \\<Longrightarrow> DS \\<rho> \\<in> carrier_mat d d\\<rbrakk>\n       \\<Longrightarrow> partial_density_operator\n                          (denote_while_n_iter M0 M1 DS k \\<rho>)", "by auto"], ["proof (state)\nthis:\n  partial_density_operator (D ?k \\<rho>)\n\ngoal (1 subgoal):\n 1. denote (While M S) \\<rho> =\n    M 0 * \\<rho> * adjoint (M 0) +\n    denote (While M S) (denote S (M 1 * \\<rho> * adjoint (M 1)))", "then"], ["proof (chain)\npicking this:\n  partial_density_operator (D ?k \\<rho>)", "have pDkr: \"\\<And>k. positive (D k \\<rho>)\""], ["proof (prove)\nusing this:\n  partial_density_operator (D ?k \\<rho>)\n\ngoal (1 subgoal):\n 1. \\<And>k. positive (D k \\<rho>)", "unfolding partial_density_operator_def"], ["proof (prove)\nusing this:\n  positive (D ?k \\<rho>) \\<and> trace (D ?k \\<rho>) \\<le> 1\n\ngoal (1 subgoal):\n 1. \\<And>k. positive (D k \\<rho>)", "by auto"], ["proof (state)\nthis:\n  positive (D ?k \\<rho>)\n\ngoal (1 subgoal):\n 1. denote (While M S) \\<rho> =\n    M 0 * \\<rho> * adjoint (M 0) +\n    denote (While M S) (denote S (M 1 * \\<rho> * adjoint (M 1)))", "have dDkr: \"\\<And>k. D k \\<rho> \\<in> carrier_mat d d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>k. D k \\<rho> \\<in> carrier_mat d d", "using denote_while_n_iter_dim[OF dr pdor dM1 M1leq denote_dim_pdo[OF wcs, folded DS_def], of id M0, simplified, folded D_def]"], ["proof (prove)\nusing this:\n  D ?n \\<rho> \\<in> carrier_mat d d \\<and>\n  partial_density_operator (D ?n \\<rho>)\n\ngoal (1 subgoal):\n 1. \\<And>k. D k \\<rho> \\<in> carrier_mat d d", "by auto"], ["proof (state)\nthis:\n  D ?k \\<rho> \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. denote (While M S) \\<rho> =\n    M 0 * \\<rho> * adjoint (M 0) +\n    denote (While M S) (denote S (M 1 * \\<rho> * adjoint (M 1)))", "then"], ["proof (chain)\npicking this:\n  D ?k \\<rho> \\<in> carrier_mat d d", "have dD0kr: \"\\<And>k. D0 k \\<rho> \\<in> carrier_mat d d\""], ["proof (prove)\nusing this:\n  D ?k \\<rho> \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. \\<And>k. D0 k \\<rho> \\<in> carrier_mat d d", "unfolding D0_def denote_while_n.simps"], ["proof (prove)\nusing this:\n  D ?k \\<rho> \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       M0 * denote_while_n_iter M0 M1 DS k \\<rho> * adjoint M0\n       \\<in> carrier_mat d d", "apply (fold D_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>k.\n       (\\<And>k. D k \\<rho> \\<in> carrier_mat d d) \\<Longrightarrow>\n       M0 * D k \\<rho> * adjoint M0 \\<in> carrier_mat d d", "using dM0"], ["proof (prove)\nusing this:\n  M0 \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       (\\<And>k. D k \\<rho> \\<in> carrier_mat d d) \\<Longrightarrow>\n       M0 * D k \\<rho> * adjoint M0 \\<in> carrier_mat d d", "by auto"], ["proof (state)\nthis:\n  D0 ?k \\<rho> \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. denote (While M S) \\<rho> =\n    M 0 * \\<rho> * adjoint (M 0) +\n    denote (While M S) (denote S (M 1 * \\<rho> * adjoint (M 1)))", "}"], ["proof (state)\nthis:\n  ?\\<rho>'3 \\<in> density_states \\<Longrightarrow>\n  D0 ?k ?\\<rho>'3 \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. denote (While M S) \\<rho> =\n    M 0 * \\<rho> * adjoint (M 0) +\n    denote (While M S) (denote S (M 1 * \\<rho> * adjoint (M 1)))", "note dD0k = this"], ["proof (state)\nthis:\n  ?\\<rho>'3 \\<in> density_states \\<Longrightarrow>\n  D0 ?k ?\\<rho>'3 \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. denote (While M S) \\<rho> =\n    M 0 * \\<rho> * adjoint (M 0) +\n    denote (While M S) (denote S (M 1 * \\<rho> * adjoint (M 1)))", "have \"matrix_sum d (\\<lambda>k. D0 k \\<rho>) k \\<in> carrier_mat d d\" if dsr: \"\\<rho> \\<in> density_states\" for \\<rho> k"], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_sum d (\\<lambda>k. D0 k \\<rho>) k \\<in> carrier_mat d d", "using matrix_sum_dim[OF dD0k, of _ \"\\<lambda>k. \\<rho>\" id, OF dsr] dsr"], ["proof (prove)\nusing this:\n  matrix_sum d (\\<lambda>k. D0 (id k) \\<rho>) ?n \\<in> carrier_mat d d\n  \\<rho> \\<in> density_states\n\ngoal (1 subgoal):\n 1. matrix_sum d (\\<lambda>k. D0 k \\<rho>) k \\<in> carrier_mat d d", "by auto"], ["proof (state)\nthis:\n  ?\\<rho> \\<in> density_states \\<Longrightarrow>\n  matrix_sum d (\\<lambda>k. D0 k ?\\<rho>) ?k \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. denote (While M S) \\<rho> =\n    M 0 * \\<rho> * adjoint (M 0) +\n    denote (While M S) (denote S (M 1 * \\<rho> * adjoint (M 1)))", "{"], ["proof (state)\nthis:\n  ?\\<rho> \\<in> density_states \\<Longrightarrow>\n  matrix_sum d (\\<lambda>k. D0 k ?\\<rho>) ?k \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. denote (While M S) \\<rho> =\n    M 0 * \\<rho> * adjoint (M 0) +\n    denote (While M S) (denote S (M 1 * \\<rho> * adjoint (M 1)))", "fix k"], ["proof (state)\ngoal (1 subgoal):\n 1. denote (While M S) \\<rho> =\n    M 0 * \\<rho> * adjoint (M 0) +\n    denote (While M S) (denote S (M 1 * \\<rho> * adjoint (M 1)))", "have \"matrix_sum d (\\<lambda>k. D0 k \\<rho>) (Suc k) = (D0 0 \\<rho>) + matrix_sum d (\\<lambda>k. D0 (Suc k) \\<rho>) k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_sum d (\\<lambda>k. D0 k \\<rho>) (Suc k) =\n    D0 0 \\<rho> + matrix_sum d (\\<lambda>k. D0 (Suc k) \\<rho>) k", "using matrix_sum_shift_Suc[of _ \"\\<lambda>k. D0 k \\<rho>\"] dD0k[OF dsr]"], ["proof (prove)\nusing this:\n  (\\<And>k.\n      k < Suc ?n \\<Longrightarrow>\n      D0 k \\<rho> \\<in> carrier_mat ?d ?d) \\<Longrightarrow>\n  matrix_sum ?d (\\<lambda>k. D0 k \\<rho>) (Suc ?n) =\n  D0 0 \\<rho> + matrix_sum ?d (\\<lambda>k. D0 (Suc k) \\<rho>) ?n\n  D0 ?k \\<rho> \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. matrix_sum d (\\<lambda>k. D0 k \\<rho>) (Suc k) =\n    D0 0 \\<rho> + matrix_sum d (\\<lambda>k. D0 (Suc k) \\<rho>) k", "by fastforce"], ["proof (state)\nthis:\n  matrix_sum d (\\<lambda>k. D0 k \\<rho>) (Suc k) =\n  D0 0 \\<rho> + matrix_sum d (\\<lambda>k. D0 (Suc k) \\<rho>) k\n\ngoal (1 subgoal):\n 1. denote (While M S) \\<rho> =\n    M 0 * \\<rho> * adjoint (M 0) +\n    denote (While M S) (denote S (M 1 * \\<rho> * adjoint (M 1)))", "also"], ["proof (state)\nthis:\n  matrix_sum d (\\<lambda>k. D0 k \\<rho>) (Suc k) =\n  D0 0 \\<rho> + matrix_sum d (\\<lambda>k. D0 (Suc k) \\<rho>) k\n\ngoal (1 subgoal):\n 1. denote (While M S) \\<rho> =\n    M 0 * \\<rho> * adjoint (M 0) +\n    denote (While M S) (denote S (M 1 * \\<rho> * adjoint (M 1)))", "have \"\\<dots> = M0 * \\<rho> * adjoint M0 + matrix_sum d (\\<lambda>k. D0 k (DS (M1 * \\<rho> * adjoint M1))) k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. D0 0 \\<rho> + matrix_sum d (\\<lambda>k. D0 (Suc k) \\<rho>) k =\n    M0 * \\<rho> * adjoint M0 +\n    matrix_sum d (\\<lambda>k. D0 k (DS (M1 * \\<rho> * adjoint M1))) k", "unfolding D0_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. denote_while_n M0 M1 DS 0 \\<rho> +\n    matrix_sum d (\\<lambda>k. denote_while_n M0 M1 DS (Suc k) \\<rho>) k =\n    M0 * \\<rho> * adjoint M0 +\n    matrix_sum d\n     (\\<lambda>k. denote_while_n M0 M1 DS k (DS (M1 * \\<rho> * adjoint M1)))\n     k", "by auto"], ["proof (state)\nthis:\n  D0 0 \\<rho> + matrix_sum d (\\<lambda>k. D0 (Suc k) \\<rho>) k =\n  M0 * \\<rho> * adjoint M0 +\n  matrix_sum d (\\<lambda>k. D0 k (DS (M1 * \\<rho> * adjoint M1))) k\n\ngoal (1 subgoal):\n 1. denote (While M S) \\<rho> =\n    M 0 * \\<rho> * adjoint (M 0) +\n    denote (While M S) (denote S (M 1 * \\<rho> * adjoint (M 1)))", "finally"], ["proof (chain)\npicking this:\n  matrix_sum d (\\<lambda>k. D0 k \\<rho>) (Suc k) =\n  M0 * \\<rho> * adjoint M0 +\n  matrix_sum d (\\<lambda>k. D0 k (DS (M1 * \\<rho> * adjoint M1))) k", "have \"matrix_sum d (\\<lambda>k. D0 k \\<rho>) (Suc k) = M0 * \\<rho> * adjoint M0 + matrix_sum d (\\<lambda>k. D0 k (DS (M1 * \\<rho> * adjoint M1))) k\""], ["proof (prove)\nusing this:\n  matrix_sum d (\\<lambda>k. D0 k \\<rho>) (Suc k) =\n  M0 * \\<rho> * adjoint M0 +\n  matrix_sum d (\\<lambda>k. D0 k (DS (M1 * \\<rho> * adjoint M1))) k\n\ngoal (1 subgoal):\n 1. matrix_sum d (\\<lambda>k. D0 k \\<rho>) (Suc k) =\n    M0 * \\<rho> * adjoint M0 +\n    matrix_sum d (\\<lambda>k. D0 k (DS (M1 * \\<rho> * adjoint M1))) k", "."], ["proof (state)\nthis:\n  matrix_sum d (\\<lambda>k. D0 k \\<rho>) (Suc k) =\n  M0 * \\<rho> * adjoint M0 +\n  matrix_sum d (\\<lambda>k. D0 k (DS (M1 * \\<rho> * adjoint M1))) k\n\ngoal (1 subgoal):\n 1. denote (While M S) \\<rho> =\n    M 0 * \\<rho> * adjoint (M 0) +\n    denote (While M S) (denote S (M 1 * \\<rho> * adjoint (M 1)))", "}"], ["proof (state)\nthis:\n  matrix_sum d (\\<lambda>k. D0 k \\<rho>) (Suc ?k2) =\n  M0 * \\<rho> * adjoint M0 +\n  matrix_sum d (\\<lambda>k. D0 k (DS (M1 * \\<rho> * adjoint M1))) ?k2\n\ngoal (1 subgoal):\n 1. denote (While M S) \\<rho> =\n    M 0 * \\<rho> * adjoint (M 0) +\n    denote (While M S) (denote S (M 1 * \\<rho> * adjoint (M 1)))", "note eqk = this"], ["proof (state)\nthis:\n  matrix_sum d (\\<lambda>k. D0 k \\<rho>) (Suc ?k2) =\n  M0 * \\<rho> * adjoint M0 +\n  matrix_sum d (\\<lambda>k. D0 k (DS (M1 * \\<rho> * adjoint M1))) ?k2\n\ngoal (1 subgoal):\n 1. denote (While M S) \\<rho> =\n    M 0 * \\<rho> * adjoint (M 0) +\n    denote (While M S) (denote S (M 1 * \\<rho> * adjoint (M 1)))", "have dr: \"\\<rho> \\<in> carrier_mat d d\" and pdor: \"partial_density_operator \\<rho>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<rho> \\<in> carrier_mat d d &&& partial_density_operator \\<rho>", "using density_states_def dsr"], ["proof (prove)\nusing this:\n  density_states =\n  {\\<rho> \\<in> carrier_mat d d. partial_density_operator \\<rho>}\n  \\<rho> \\<in> density_states\n\ngoal (1 subgoal):\n 1. \\<rho> \\<in> carrier_mat d d &&& partial_density_operator \\<rho>", "by auto"], ["proof (state)\nthis:\n  \\<rho> \\<in> carrier_mat d d\n  partial_density_operator \\<rho>\n\ngoal (1 subgoal):\n 1. denote (While M S) \\<rho> =\n    M 0 * \\<rho> * adjoint (M 0) +\n    denote (While M S) (denote S (M 1 * \\<rho> * adjoint (M 1)))", "then"], ["proof (chain)\npicking this:\n  \\<rho> \\<in> carrier_mat d d\n  partial_density_operator \\<rho>", "have \"M1 * \\<rho> * adjoint M1 \\<in> carrier_mat d d\" and \"partial_density_operator (M1 * \\<rho> * adjoint M1)\""], ["proof (prove)\nusing this:\n  \\<rho> \\<in> carrier_mat d d\n  partial_density_operator \\<rho>\n\ngoal (1 subgoal):\n 1. M1 * \\<rho> * adjoint M1 \\<in> carrier_mat d d &&&\n    partial_density_operator (M1 * \\<rho> * adjoint M1)", "using dM1 dr pdo_close_under_measurement[OF dM1 dr pdor M1leq]"], ["proof (prove)\nusing this:\n  \\<rho> \\<in> carrier_mat d d\n  partial_density_operator \\<rho>\n  M1 \\<in> carrier_mat d d\n  \\<rho> \\<in> carrier_mat d d\n  partial_density_operator (M1 * \\<rho> * adjoint M1)\n\ngoal (1 subgoal):\n 1. M1 * \\<rho> * adjoint M1 \\<in> carrier_mat d d &&&\n    partial_density_operator (M1 * \\<rho> * adjoint M1)", "by auto"], ["proof (state)\nthis:\n  M1 * \\<rho> * adjoint M1 \\<in> carrier_mat d d\n  partial_density_operator (M1 * \\<rho> * adjoint M1)\n\ngoal (1 subgoal):\n 1. denote (While M S) \\<rho> =\n    M 0 * \\<rho> * adjoint (M 0) +\n    denote (While M S) (denote S (M 1 * \\<rho> * adjoint (M 1)))", "then"], ["proof (chain)\npicking this:\n  M1 * \\<rho> * adjoint M1 \\<in> carrier_mat d d\n  partial_density_operator (M1 * \\<rho> * adjoint M1)", "have dSM1r: \"(DS (M1 * \\<rho> * adjoint M1)) \\<in> carrier_mat d d\" and pdoSM1r: \"partial_density_operator (DS (M1 * \\<rho> * adjoint M1))\""], ["proof (prove)\nusing this:\n  M1 * \\<rho> * adjoint M1 \\<in> carrier_mat d d\n  partial_density_operator (M1 * \\<rho> * adjoint M1)\n\ngoal (1 subgoal):\n 1. DS (M1 * \\<rho> * adjoint M1) \\<in> carrier_mat d d &&&\n    partial_density_operator (DS (M1 * \\<rho> * adjoint M1))", "unfolding DS_def"], ["proof (prove)\nusing this:\n  M1 * \\<rho> * adjoint M1 \\<in> carrier_mat d d\n  partial_density_operator (M1 * \\<rho> * adjoint M1)\n\ngoal (1 subgoal):\n 1. denote S (M1 * \\<rho> * adjoint M1) \\<in> carrier_mat d d &&&\n    partial_density_operator (denote S (M1 * \\<rho> * adjoint M1))", "using denote_dim_pdo[OF wcs]"], ["proof (prove)\nusing this:\n  M1 * \\<rho> * adjoint M1 \\<in> carrier_mat d d\n  partial_density_operator (M1 * \\<rho> * adjoint M1)\n  \\<lbrakk>?\\<rho> \\<in> carrier_mat d d;\n   partial_density_operator ?\\<rho>\\<rbrakk>\n  \\<Longrightarrow> denote S ?\\<rho> \\<in> carrier_mat d d \\<and>\n                    partial_density_operator (denote S ?\\<rho>)\n\ngoal (1 subgoal):\n 1. denote S (M1 * \\<rho> * adjoint M1) \\<in> carrier_mat d d &&&\n    partial_density_operator (denote S (M1 * \\<rho> * adjoint M1))", "by auto"], ["proof (state)\nthis:\n  DS (M1 * \\<rho> * adjoint M1) \\<in> carrier_mat d d\n  partial_density_operator (DS (M1 * \\<rho> * adjoint M1))\n\ngoal (1 subgoal):\n 1. denote (While M S) \\<rho> =\n    M 0 * \\<rho> * adjoint (M 0) +\n    denote (While M S) (denote S (M 1 * \\<rho> * adjoint (M 1)))", "have \"limit_mat (matrix_sum d (\\<lambda>k. D0 k \\<rho>)) (DW \\<rho>) d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. limit_mat (matrix_sum d (\\<lambda>k. D0 k \\<rho>)) (DW \\<rho>) d", "unfolding M0_def M1_def D0_def DS_def DW_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. limit_mat\n     (matrix_sum d\n       (\\<lambda>k. denote_while_n (M 0) (M 1) (denote S) k \\<rho>))\n     (denote (While M S) \\<rho>) d", "using limit_mat_denote_while_n[OF wc dr pdor]"], ["proof (prove)\nusing this:\n  limit_mat\n   (matrix_sum d\n     (\\<lambda>k. denote_while_n (M 0) (M 1) (denote S) k \\<rho>))\n   (denote (While M S) \\<rho>) d\n\ngoal (1 subgoal):\n 1. limit_mat\n     (matrix_sum d\n       (\\<lambda>k. denote_while_n (M 0) (M 1) (denote S) k \\<rho>))\n     (denote (While M S) \\<rho>) d", "by auto"], ["proof (state)\nthis:\n  limit_mat (matrix_sum d (\\<lambda>k. D0 k \\<rho>)) (DW \\<rho>) d\n\ngoal (1 subgoal):\n 1. denote (While M S) \\<rho> =\n    M 0 * \\<rho> * adjoint (M 0) +\n    denote (While M S) (denote S (M 1 * \\<rho> * adjoint (M 1)))", "then"], ["proof (chain)\npicking this:\n  limit_mat (matrix_sum d (\\<lambda>k. D0 k \\<rho>)) (DW \\<rho>) d", "have liml: \"limit_mat (\\<lambda>k. matrix_sum d (\\<lambda>k. D0 k \\<rho>) (Suc k)) (DW \\<rho>) d\""], ["proof (prove)\nusing this:\n  limit_mat (matrix_sum d (\\<lambda>k. D0 k \\<rho>)) (DW \\<rho>) d\n\ngoal (1 subgoal):\n 1. limit_mat (\\<lambda>k. matrix_sum d (\\<lambda>k. D0 k \\<rho>) (Suc k))\n     (DW \\<rho>) d", "using limit_mat_ignore_initial_segment[of \"matrix_sum d (\\<lambda>k. D0 k \\<rho>)\" \"DW \\<rho>\" d 1]"], ["proof (prove)\nusing this:\n  limit_mat (matrix_sum d (\\<lambda>k. D0 k \\<rho>)) (DW \\<rho>) d\n  limit_mat (matrix_sum d (\\<lambda>k. D0 k \\<rho>)) (DW \\<rho>)\n   d \\<Longrightarrow>\n  limit_mat (\\<lambda>n. matrix_sum d (\\<lambda>k. D0 k \\<rho>) (n + 1))\n   (DW \\<rho>) d\n\ngoal (1 subgoal):\n 1. limit_mat (\\<lambda>k. matrix_sum d (\\<lambda>k. D0 k \\<rho>) (Suc k))\n     (DW \\<rho>) d", "by auto"], ["proof (state)\nthis:\n  limit_mat (\\<lambda>k. matrix_sum d (\\<lambda>k. D0 k \\<rho>) (Suc k))\n   (DW \\<rho>) d\n\ngoal (1 subgoal):\n 1. denote (While M S) \\<rho> =\n    M 0 * \\<rho> * adjoint (M 0) +\n    denote (While M S) (denote S (M 1 * \\<rho> * adjoint (M 1)))", "have dM0r: \"M0 * \\<rho> * adjoint M0 \\<in> carrier_mat d d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M0 * \\<rho> * adjoint M0 \\<in> carrier_mat d d", "using dM0 dr"], ["proof (prove)\nusing this:\n  M0 \\<in> carrier_mat d d\n  \\<rho> \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. M0 * \\<rho> * adjoint M0 \\<in> carrier_mat d d", "by fastforce"], ["proof (state)\nthis:\n  M0 * \\<rho> * adjoint M0 \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. denote (While M S) \\<rho> =\n    M 0 * \\<rho> * adjoint (M 0) +\n    denote (While M S) (denote S (M 1 * \\<rho> * adjoint (M 1)))", "have \"limit_mat (matrix_sum d (\\<lambda>k. D0 k (DS (M1 * \\<rho> * adjoint M1)))) (DW (DS (M1 * \\<rho> * adjoint M1))) d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. limit_mat\n     (matrix_sum d (\\<lambda>k. D0 k (DS (M1 * \\<rho> * adjoint M1))))\n     (DW (DS (M1 * \\<rho> * adjoint M1))) d", "using limit_mat_denote_while_n[OF wc dSM1r pdoSM1r]"], ["proof (prove)\nusing this:\n  limit_mat\n   (matrix_sum d\n     (\\<lambda>k.\n         denote_while_n (M 0) (M 1) (denote S) k\n          (DS (M1 * \\<rho> * adjoint M1))))\n   (denote (While M S) (DS (M1 * \\<rho> * adjoint M1))) d\n\ngoal (1 subgoal):\n 1. limit_mat\n     (matrix_sum d (\\<lambda>k. D0 k (DS (M1 * \\<rho> * adjoint M1))))\n     (DW (DS (M1 * \\<rho> * adjoint M1))) d", "unfolding M0_def M1_def D0_def DS_def DW_def"], ["proof (prove)\nusing this:\n  limit_mat\n   (matrix_sum d\n     (\\<lambda>k.\n         denote_while_n (M 0) (M 1) (denote S) k\n          (denote S (M 1 * \\<rho> * adjoint (M 1)))))\n   (denote (While M S) (denote S (M 1 * \\<rho> * adjoint (M 1)))) d\n\ngoal (1 subgoal):\n 1. limit_mat\n     (matrix_sum d\n       (\\<lambda>k.\n           denote_while_n (M 0) (M 1) (denote S) k\n            (denote S (M 1 * \\<rho> * adjoint (M 1)))))\n     (denote (While M S) (denote S (M 1 * \\<rho> * adjoint (M 1)))) d", "by auto"], ["proof (state)\nthis:\n  limit_mat\n   (matrix_sum d (\\<lambda>k. D0 k (DS (M1 * \\<rho> * adjoint M1))))\n   (DW (DS (M1 * \\<rho> * adjoint M1))) d\n\ngoal (1 subgoal):\n 1. denote (While M S) \\<rho> =\n    M 0 * \\<rho> * adjoint (M 0) +\n    denote (While M S) (denote S (M 1 * \\<rho> * adjoint (M 1)))", "then"], ["proof (chain)\npicking this:\n  limit_mat\n   (matrix_sum d (\\<lambda>k. D0 k (DS (M1 * \\<rho> * adjoint M1))))\n   (DW (DS (M1 * \\<rho> * adjoint M1))) d", "have \n    limr: \"limit_mat \n      (mat_add_seq (M0 * \\<rho> * adjoint M0) (matrix_sum d (\\<lambda>k. D0 k (DS (M1 * \\<rho> * adjoint M1)))))\n      (M0 * \\<rho> * adjoint M0 + (DW (DS (M1 * \\<rho> * adjoint M1))))\n      d\""], ["proof (prove)\nusing this:\n  limit_mat\n   (matrix_sum d (\\<lambda>k. D0 k (DS (M1 * \\<rho> * adjoint M1))))\n   (DW (DS (M1 * \\<rho> * adjoint M1))) d\n\ngoal (1 subgoal):\n 1. limit_mat\n     (mat_add_seq (M0 * \\<rho> * adjoint M0)\n       (matrix_sum d (\\<lambda>k. D0 k (DS (M1 * \\<rho> * adjoint M1)))))\n     (M0 * \\<rho> * adjoint M0 + DW (DS (M1 * \\<rho> * adjoint M1))) d", "using mat_add_limit[OF dM0r]"], ["proof (prove)\nusing this:\n  limit_mat\n   (matrix_sum d (\\<lambda>k. D0 k (DS (M1 * \\<rho> * adjoint M1))))\n   (DW (DS (M1 * \\<rho> * adjoint M1))) d\n  limit_mat ?X ?A d \\<Longrightarrow>\n  limit_mat (mat_add_seq (M0 * \\<rho> * adjoint M0) ?X)\n   (M0 * \\<rho> * adjoint M0 + ?A) d\n\ngoal (1 subgoal):\n 1. limit_mat\n     (mat_add_seq (M0 * \\<rho> * adjoint M0)\n       (matrix_sum d (\\<lambda>k. D0 k (DS (M1 * \\<rho> * adjoint M1)))))\n     (M0 * \\<rho> * adjoint M0 + DW (DS (M1 * \\<rho> * adjoint M1))) d", "by auto"], ["proof (state)\nthis:\n  limit_mat\n   (mat_add_seq (M0 * \\<rho> * adjoint M0)\n     (matrix_sum d (\\<lambda>k. D0 k (DS (M1 * \\<rho> * adjoint M1)))))\n   (M0 * \\<rho> * adjoint M0 + DW (DS (M1 * \\<rho> * adjoint M1))) d\n\ngoal (1 subgoal):\n 1. denote (While M S) \\<rho> =\n    M 0 * \\<rho> * adjoint (M 0) +\n    denote (While M S) (denote S (M 1 * \\<rho> * adjoint (M 1)))", "moreover"], ["proof (state)\nthis:\n  limit_mat\n   (mat_add_seq (M0 * \\<rho> * adjoint M0)\n     (matrix_sum d (\\<lambda>k. D0 k (DS (M1 * \\<rho> * adjoint M1)))))\n   (M0 * \\<rho> * adjoint M0 + DW (DS (M1 * \\<rho> * adjoint M1))) d\n\ngoal (1 subgoal):\n 1. denote (While M S) \\<rho> =\n    M 0 * \\<rho> * adjoint (M 0) +\n    denote (While M S) (denote S (M 1 * \\<rho> * adjoint (M 1)))", "have \n    \"(\\<lambda>k. matrix_sum d (\\<lambda>k. D0 k \\<rho>) (Suc k))\n     = (mat_add_seq (M0 * \\<rho> * adjoint M0) (matrix_sum d (\\<lambda>k. D0 k (DS (M1 * \\<rho> * adjoint M1)))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>k. matrix_sum d (\\<lambda>k. D0 k \\<rho>) (Suc k)) =\n    mat_add_seq (M0 * \\<rho> * adjoint M0)\n     (matrix_sum d (\\<lambda>k. D0 k (DS (M1 * \\<rho> * adjoint M1))))", "using eqk mat_add_seq_def"], ["proof (prove)\nusing this:\n  matrix_sum d (\\<lambda>k. D0 k \\<rho>) (Suc ?k2) =\n  M0 * \\<rho> * adjoint M0 +\n  matrix_sum d (\\<lambda>k. D0 k (DS (M1 * \\<rho> * adjoint M1))) ?k2\n  mat_add_seq ?A ?X = (\\<lambda>n. ?A + ?X n)\n\ngoal (1 subgoal):\n 1. (\\<lambda>k. matrix_sum d (\\<lambda>k. D0 k \\<rho>) (Suc k)) =\n    mat_add_seq (M0 * \\<rho> * adjoint M0)\n     (matrix_sum d (\\<lambda>k. D0 k (DS (M1 * \\<rho> * adjoint M1))))", "by auto"], ["proof (state)\nthis:\n  (\\<lambda>k. matrix_sum d (\\<lambda>k. D0 k \\<rho>) (Suc k)) =\n  mat_add_seq (M0 * \\<rho> * adjoint M0)\n   (matrix_sum d (\\<lambda>k. D0 k (DS (M1 * \\<rho> * adjoint M1))))\n\ngoal (1 subgoal):\n 1. denote (While M S) \\<rho> =\n    M 0 * \\<rho> * adjoint (M 0) +\n    denote (While M S) (denote S (M 1 * \\<rho> * adjoint (M 1)))", "ultimately"], ["proof (chain)\npicking this:\n  limit_mat\n   (mat_add_seq (M0 * \\<rho> * adjoint M0)\n     (matrix_sum d (\\<lambda>k. D0 k (DS (M1 * \\<rho> * adjoint M1)))))\n   (M0 * \\<rho> * adjoint M0 + DW (DS (M1 * \\<rho> * adjoint M1))) d\n  (\\<lambda>k. matrix_sum d (\\<lambda>k. D0 k \\<rho>) (Suc k)) =\n  mat_add_seq (M0 * \\<rho> * adjoint M0)\n   (matrix_sum d (\\<lambda>k. D0 k (DS (M1 * \\<rho> * adjoint M1))))", "have \n    \"limit_mat\n      (\\<lambda>k. matrix_sum d (\\<lambda>k. D0 k \\<rho>) (Suc k))\n      (M0 * \\<rho> * adjoint M0 + (DW (DS (M1 * \\<rho> * adjoint M1))))\n      d\""], ["proof (prove)\nusing this:\n  limit_mat\n   (mat_add_seq (M0 * \\<rho> * adjoint M0)\n     (matrix_sum d (\\<lambda>k. D0 k (DS (M1 * \\<rho> * adjoint M1)))))\n   (M0 * \\<rho> * adjoint M0 + DW (DS (M1 * \\<rho> * adjoint M1))) d\n  (\\<lambda>k. matrix_sum d (\\<lambda>k. D0 k \\<rho>) (Suc k)) =\n  mat_add_seq (M0 * \\<rho> * adjoint M0)\n   (matrix_sum d (\\<lambda>k. D0 k (DS (M1 * \\<rho> * adjoint M1))))\n\ngoal (1 subgoal):\n 1. limit_mat (\\<lambda>k. matrix_sum d (\\<lambda>k. D0 k \\<rho>) (Suc k))\n     (M0 * \\<rho> * adjoint M0 + DW (DS (M1 * \\<rho> * adjoint M1))) d", "by auto"], ["proof (state)\nthis:\n  limit_mat (\\<lambda>k. matrix_sum d (\\<lambda>k. D0 k \\<rho>) (Suc k))\n   (M0 * \\<rho> * adjoint M0 + DW (DS (M1 * \\<rho> * adjoint M1))) d\n\ngoal (1 subgoal):\n 1. denote (While M S) \\<rho> =\n    M 0 * \\<rho> * adjoint (M 0) +\n    denote (While M S) (denote S (M 1 * \\<rho> * adjoint (M 1)))", "with liml limit_mat_unique"], ["proof (chain)\npicking this:\n  limit_mat (\\<lambda>k. matrix_sum d (\\<lambda>k. D0 k \\<rho>) (Suc k))\n   (DW \\<rho>) d\n  \\<lbrakk>limit_mat ?X ?A ?m; limit_mat ?X ?B ?m\\<rbrakk>\n  \\<Longrightarrow> ?A = ?B\n  limit_mat (\\<lambda>k. matrix_sum d (\\<lambda>k. D0 k \\<rho>) (Suc k))\n   (M0 * \\<rho> * adjoint M0 + DW (DS (M1 * \\<rho> * adjoint M1))) d", "have \n    \"DW \\<rho> = (M0 * \\<rho> * adjoint M0 + (DW (DS (M1 * \\<rho> * adjoint M1))))\""], ["proof (prove)\nusing this:\n  limit_mat (\\<lambda>k. matrix_sum d (\\<lambda>k. D0 k \\<rho>) (Suc k))\n   (DW \\<rho>) d\n  \\<lbrakk>limit_mat ?X ?A ?m; limit_mat ?X ?B ?m\\<rbrakk>\n  \\<Longrightarrow> ?A = ?B\n  limit_mat (\\<lambda>k. matrix_sum d (\\<lambda>k. D0 k \\<rho>) (Suc k))\n   (M0 * \\<rho> * adjoint M0 + DW (DS (M1 * \\<rho> * adjoint M1))) d\n\ngoal (1 subgoal):\n 1. DW \\<rho> =\n    M0 * \\<rho> * adjoint M0 + DW (DS (M1 * \\<rho> * adjoint M1))", "by auto"], ["proof (state)\nthis:\n  DW \\<rho> = M0 * \\<rho> * adjoint M0 + DW (DS (M1 * \\<rho> * adjoint M1))\n\ngoal (1 subgoal):\n 1. denote (While M S) \\<rho> =\n    M 0 * \\<rho> * adjoint (M 0) +\n    denote (While M S) (denote S (M 1 * \\<rho> * adjoint (M 1)))", "then"], ["proof (chain)\npicking this:\n  DW \\<rho> = M0 * \\<rho> * adjoint M0 + DW (DS (M1 * \\<rho> * adjoint M1))", "show ?thesis"], ["proof (prove)\nusing this:\n  DW \\<rho> = M0 * \\<rho> * adjoint M0 + DW (DS (M1 * \\<rho> * adjoint M1))\n\ngoal (1 subgoal):\n 1. denote (While M S) \\<rho> =\n    M 0 * \\<rho> * adjoint (M 0) +\n    denote (While M S) (denote S (M 1 * \\<rho> * adjoint (M 1)))", "unfolding DW_def M0_def M1_def DS_def"], ["proof (prove)\nusing this:\n  denote (While M S) \\<rho> =\n  M 0 * \\<rho> * adjoint (M 0) +\n  denote (While M S) (denote S (M 1 * \\<rho> * adjoint (M 1)))\n\ngoal (1 subgoal):\n 1. denote (While M S) \\<rho> =\n    M 0 * \\<rho> * adjoint (M 0) +\n    denote (While M S) (denote S (M 1 * \\<rho> * adjoint (M 1)))", "by auto"], ["proof (state)\nthis:\n  denote (While M S) \\<rho> =\n  M 0 * \\<rho> * adjoint (M 0) +\n  denote (While M S) (denote S (M 1 * \\<rho> * adjoint (M 1)))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma wlp_while_split:\n  assumes wc: \"well_com (While M S)\" and qpP: \"is_quantum_predicate P\"\n  shows \"wlp (While M S) P = adjoint (M 0) * P * (M 0) + adjoint (M 1) * (wlp S (wlp (While M S) P)) * (M 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wlp (While M S) P =\n    adjoint (M 0) * P * M 0 +\n    adjoint (M 1) * wlp S (wlp (While M S) P) * M 1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. wlp (While M S) P =\n    adjoint (M 0) * P * M 0 +\n    adjoint (M 1) * wlp S (wlp (While M S) P) * M 1", "have m: \"measurement d 2 M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. measurement d 2 M", "using wc"], ["proof (prove)\nusing this:\n  well_com (While M S)\n\ngoal (1 subgoal):\n 1. measurement d 2 M", "by auto"], ["proof (state)\nthis:\n  measurement d 2 M\n\ngoal (1 subgoal):\n 1. wlp (While M S) P =\n    adjoint (M 0) * P * M 0 +\n    adjoint (M 1) * wlp S (wlp (While M S) P) * M 1", "have wcs: \"well_com S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. well_com S", "using wc"], ["proof (prove)\nusing this:\n  well_com (While M S)\n\ngoal (1 subgoal):\n 1. well_com S", "by auto"], ["proof (state)\nthis:\n  well_com S\n\ngoal (1 subgoal):\n 1. wlp (While M S) P =\n    adjoint (M 0) * P * M 0 +\n    adjoint (M 1) * wlp S (wlp (While M S) P) * M 1", "define M0 where \"M0 = M 0\""], ["proof (state)\nthis:\n  M0 = M 0\n\ngoal (1 subgoal):\n 1. wlp (While M S) P =\n    adjoint (M 0) * P * M 0 +\n    adjoint (M 1) * wlp S (wlp (While M S) P) * M 1", "define M1 where \"M1 = M 1\""], ["proof (state)\nthis:\n  M1 = M 1\n\ngoal (1 subgoal):\n 1. wlp (While M S) P =\n    adjoint (M 0) * P * M 0 +\n    adjoint (M 1) * wlp S (wlp (While M S) P) * M 1", "have dM0: \"M0 \\<in> carrier_mat d d\" and dM1: \"M1 \\<in> carrier_mat d d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M0 \\<in> carrier_mat d d &&& M1 \\<in> carrier_mat d d", "using m measurement_def M0_def M1_def"], ["proof (prove)\nusing this:\n  measurement d 2 M\n  measurement ?d ?n ?M =\n  ((\\<forall>j<?n. ?M j \\<in> carrier_mat ?d ?d) \\<and>\n   matrix_sum ?d (\\<lambda>j. adjoint (?M j) * ?M j) ?n = 1\\<^sub>m ?d)\n  M0 = M 0\n  M1 = M 1\n\ngoal (1 subgoal):\n 1. M0 \\<in> carrier_mat d d &&& M1 \\<in> carrier_mat d d", "by auto"], ["proof (state)\nthis:\n  M0 \\<in> carrier_mat d d\n  M1 \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. wlp (While M S) P =\n    adjoint (M 0) * P * M 0 +\n    adjoint (M 1) * wlp S (wlp (While M S) P) * M 1", "have M1leq: \"adjoint M1 * M1 \\<le>\\<^sub>L 1\\<^sub>m d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adjoint M1 * M1 \\<le>\\<^sub>L 1\\<^sub>m d", "using measurement_le_one_mat m M1_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>measurement ?d ?n ?f; ?j < ?n\\<rbrakk>\n  \\<Longrightarrow> adjoint (?f ?j) * ?f ?j \\<le>\\<^sub>L 1\\<^sub>m ?d\n  measurement d 2 M\n  M1 = M 1\n\ngoal (1 subgoal):\n 1. adjoint M1 * M1 \\<le>\\<^sub>L 1\\<^sub>m d", "by auto"], ["proof (state)\nthis:\n  adjoint M1 * M1 \\<le>\\<^sub>L 1\\<^sub>m d\n\ngoal (1 subgoal):\n 1. wlp (While M S) P =\n    adjoint (M 0) * P * M 0 +\n    adjoint (M 1) * wlp S (wlp (While M S) P) * M 1", "define DS where \"DS = denote S\""], ["proof (state)\nthis:\n  DS = denote S\n\ngoal (1 subgoal):\n 1. wlp (While M S) P =\n    adjoint (M 0) * P * M 0 +\n    adjoint (M 1) * wlp S (wlp (While M S) P) * M 1", "define D0 where \"D0 = denote_while_n M0 M1 DS\""], ["proof (state)\nthis:\n  D0 = denote_while_n M0 M1 DS\n\ngoal (1 subgoal):\n 1. wlp (While M S) P =\n    adjoint (M 0) * P * M 0 +\n    adjoint (M 1) * wlp S (wlp (While M S) P) * M 1", "define D1 where \"D1 = denote_while_n_comp M0 M1 DS\""], ["proof (state)\nthis:\n  D1 = denote_while_n_comp M0 M1 DS\n\ngoal (1 subgoal):\n 1. wlp (While M S) P =\n    adjoint (M 0) * P * M 0 +\n    adjoint (M 1) * wlp S (wlp (While M S) P) * M 1", "define D where \"D = denote_while_n_iter M0 M1 DS\""], ["proof (state)\nthis:\n  D = denote_while_n_iter M0 M1 DS\n\ngoal (1 subgoal):\n 1. wlp (While M S) P =\n    adjoint (M 0) * P * M 0 +\n    adjoint (M 1) * wlp S (wlp (While M S) P) * M 1", "define DW where \"DW \\<rho> = denote (While M S) \\<rho>\" for \\<rho>"], ["proof (state)\nthis:\n  DW ?\\<rho> = denote (While M S) ?\\<rho>\n\ngoal (1 subgoal):\n 1. wlp (While M S) P =\n    adjoint (M 0) * P * M 0 +\n    adjoint (M 1) * wlp S (wlp (While M S) P) * M 1", "have dP: \"P \\<in> carrier_mat d d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<in> carrier_mat d d", "using qpP is_quantum_predicate_def"], ["proof (prove)\nusing this:\n  is_quantum_predicate P\n  is_quantum_predicate ?P =\n  (?P \\<in> carrier_mat d d \\<and>\n   positive ?P \\<and> ?P \\<le>\\<^sub>L 1\\<^sub>m d)\n\ngoal (1 subgoal):\n 1. P \\<in> carrier_mat d d", "by auto"], ["proof (state)\nthis:\n  P \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. wlp (While M S) P =\n    adjoint (M 0) * P * M 0 +\n    adjoint (M 1) * wlp S (wlp (While M S) P) * M 1", "have qpWP: \"is_quantum_predicate (wlp (While M S) P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_quantum_predicate (wlp (While M S) P)", "using qpP wc wlp_close[OF wc qpP]"], ["proof (prove)\nusing this:\n  is_quantum_predicate P\n  well_com (While M S)\n  is_quantum_predicate (wlp (While M S) P)\n\ngoal (1 subgoal):\n 1. is_quantum_predicate (wlp (While M S) P)", "by auto"], ["proof (state)\nthis:\n  is_quantum_predicate (wlp (While M S) P)\n\ngoal (1 subgoal):\n 1. wlp (While M S) P =\n    adjoint (M 0) * P * M 0 +\n    adjoint (M 1) * wlp S (wlp (While M S) P) * M 1", "then"], ["proof (chain)\npicking this:\n  is_quantum_predicate (wlp (While M S) P)", "have \"is_quantum_predicate (wlp S (wlp (While M S) P))\""], ["proof (prove)\nusing this:\n  is_quantum_predicate (wlp (While M S) P)\n\ngoal (1 subgoal):\n 1. is_quantum_predicate (wlp S (wlp (While M S) P))", "using wc wlp_close[OF wcs]"], ["proof (prove)\nusing this:\n  is_quantum_predicate (wlp (While M S) P)\n  well_com (While M S)\n  is_quantum_predicate ?P \\<Longrightarrow> is_quantum_predicate (wlp S ?P)\n\ngoal (1 subgoal):\n 1. is_quantum_predicate (wlp S (wlp (While M S) P))", "by auto"], ["proof (state)\nthis:\n  is_quantum_predicate (wlp S (wlp (While M S) P))\n\ngoal (1 subgoal):\n 1. wlp (While M S) P =\n    adjoint (M 0) * P * M 0 +\n    adjoint (M 1) * wlp S (wlp (While M S) P) * M 1", "then"], ["proof (chain)\npicking this:\n  is_quantum_predicate (wlp S (wlp (While M S) P))", "have dWWP: \"(wlp S (wlp (While M S) P)) \\<in> carrier_mat d d\""], ["proof (prove)\nusing this:\n  is_quantum_predicate (wlp S (wlp (While M S) P))\n\ngoal (1 subgoal):\n 1. wlp S (wlp (While M S) P) \\<in> carrier_mat d d", "using is_quantum_predicate_def"], ["proof (prove)\nusing this:\n  is_quantum_predicate (wlp S (wlp (While M S) P))\n  is_quantum_predicate ?P =\n  (?P \\<in> carrier_mat d d \\<and>\n   positive ?P \\<and> ?P \\<le>\\<^sub>L 1\\<^sub>m d)\n\ngoal (1 subgoal):\n 1. wlp S (wlp (While M S) P) \\<in> carrier_mat d d", "by auto"], ["proof (state)\nthis:\n  wlp S (wlp (While M S) P) \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. wlp (While M S) P =\n    adjoint (M 0) * P * M 0 +\n    adjoint (M 1) * wlp S (wlp (While M S) P) * M 1", "have dWP: \"(wlp (While M S) P) \\<in> carrier_mat d d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wlp (While M S) P \\<in> carrier_mat d d", "using qpWP is_quantum_predicate_def"], ["proof (prove)\nusing this:\n  is_quantum_predicate (wlp (While M S) P)\n  is_quantum_predicate ?P =\n  (?P \\<in> carrier_mat d d \\<and>\n   positive ?P \\<and> ?P \\<le>\\<^sub>L 1\\<^sub>m d)\n\ngoal (1 subgoal):\n 1. wlp (While M S) P \\<in> carrier_mat d d", "by auto"], ["proof (state)\nthis:\n  wlp (While M S) P \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. wlp (While M S) P =\n    adjoint (M 0) * P * M 0 +\n    adjoint (M 1) * wlp S (wlp (While M S) P) * M 1", "{"], ["proof (state)\nthis:\n  wlp (While M S) P \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. wlp (While M S) P =\n    adjoint (M 0) * P * M 0 +\n    adjoint (M 1) * wlp S (wlp (While M S) P) * M 1", "fix \\<rho>"], ["proof (state)\ngoal (1 subgoal):\n 1. wlp (While M S) P =\n    adjoint (M 0) * P * M 0 +\n    adjoint (M 1) * wlp S (wlp (While M S) P) * M 1", "assume dsr: \"\\<rho> \\<in> density_states\""], ["proof (state)\nthis:\n  \\<rho> \\<in> density_states\n\ngoal (1 subgoal):\n 1. wlp (While M S) P =\n    adjoint (M 0) * P * M 0 +\n    adjoint (M 1) * wlp S (wlp (While M S) P) * M 1", "then"], ["proof (chain)\npicking this:\n  \\<rho> \\<in> density_states", "have dr: \"\\<rho> \\<in> carrier_mat d d\" and pdor: \"partial_density_operator \\<rho>\""], ["proof (prove)\nusing this:\n  \\<rho> \\<in> density_states\n\ngoal (1 subgoal):\n 1. \\<rho> \\<in> carrier_mat d d &&& partial_density_operator \\<rho>", "using density_states_def"], ["proof (prove)\nusing this:\n  \\<rho> \\<in> density_states\n  density_states =\n  {\\<rho> \\<in> carrier_mat d d. partial_density_operator \\<rho>}\n\ngoal (1 subgoal):\n 1. \\<rho> \\<in> carrier_mat d d &&& partial_density_operator \\<rho>", "by auto"], ["proof (state)\nthis:\n  \\<rho> \\<in> carrier_mat d d\n  partial_density_operator \\<rho>\n\ngoal (1 subgoal):\n 1. wlp (While M S) P =\n    adjoint (M 0) * P * M 0 +\n    adjoint (M 1) * wlp S (wlp (While M S) P) * M 1", "have dsM1r: \"M1 * \\<rho> * adjoint M1 \\<in> density_states\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M1 * \\<rho> * adjoint M1 \\<in> density_states", "unfolding density_states_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. M1 * \\<rho> * adjoint M1\n    \\<in> {\\<rho> \\<in> carrier_mat d d. partial_density_operator \\<rho>}", "using pdo_close_under_measurement[OF dM1 dr pdor] M1leq dM1 dr"], ["proof (prove)\nusing this:\n  adjoint M1 * M1 \\<le>\\<^sub>L 1\\<^sub>m d \\<Longrightarrow>\n  partial_density_operator (M1 * \\<rho> * adjoint M1)\n  adjoint M1 * M1 \\<le>\\<^sub>L 1\\<^sub>m d\n  M1 \\<in> carrier_mat d d\n  \\<rho> \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. M1 * \\<rho> * adjoint M1\n    \\<in> {\\<rho> \\<in> carrier_mat d d. partial_density_operator \\<rho>}", "by fastforce"], ["proof (state)\nthis:\n  M1 * \\<rho> * adjoint M1 \\<in> density_states\n\ngoal (1 subgoal):\n 1. wlp (While M S) P =\n    adjoint (M 0) * P * M 0 +\n    adjoint (M 1) * wlp S (wlp (While M S) P) * M 1", "then"], ["proof (chain)\npicking this:\n  M1 * \\<rho> * adjoint M1 \\<in> density_states", "have dsDSM1r: \"DS (M1 * \\<rho> * adjoint M1) \\<in> density_states\""], ["proof (prove)\nusing this:\n  M1 * \\<rho> * adjoint M1 \\<in> density_states\n\ngoal (1 subgoal):\n 1. DS (M1 * \\<rho> * adjoint M1) \\<in> density_states", "unfolding density_states_def DS_def"], ["proof (prove)\nusing this:\n  M1 * \\<rho> * adjoint M1\n  \\<in> {\\<rho> \\<in> carrier_mat d d. partial_density_operator \\<rho>}\n\ngoal (1 subgoal):\n 1. denote S (M1 * \\<rho> * adjoint M1)\n    \\<in> {\\<rho> \\<in> carrier_mat d d. partial_density_operator \\<rho>}", "using denote_dim_pdo[OF wcs]"], ["proof (prove)\nusing this:\n  M1 * \\<rho> * adjoint M1\n  \\<in> {\\<rho> \\<in> carrier_mat d d. partial_density_operator \\<rho>}\n  \\<lbrakk>?\\<rho> \\<in> carrier_mat d d;\n   partial_density_operator ?\\<rho>\\<rbrakk>\n  \\<Longrightarrow> denote S ?\\<rho> \\<in> carrier_mat d d \\<and>\n                    partial_density_operator (denote S ?\\<rho>)\n\ngoal (1 subgoal):\n 1. denote S (M1 * \\<rho> * adjoint M1)\n    \\<in> {\\<rho> \\<in> carrier_mat d d. partial_density_operator \\<rho>}", "by auto"], ["proof (state)\nthis:\n  DS (M1 * \\<rho> * adjoint M1) \\<in> density_states\n\ngoal (1 subgoal):\n 1. wlp (While M S) P =\n    adjoint (M 0) * P * M 0 +\n    adjoint (M 1) * wlp S (wlp (While M S) P) * M 1", "have dM0r: \"M0 * \\<rho> * adjoint M0 \\<in> carrier_mat d d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M0 * \\<rho> * adjoint M0 \\<in> carrier_mat d d", "using dM0 dr"], ["proof (prove)\nusing this:\n  M0 \\<in> carrier_mat d d\n  \\<rho> \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. M0 * \\<rho> * adjoint M0 \\<in> carrier_mat d d", "by fastforce"], ["proof (state)\nthis:\n  M0 * \\<rho> * adjoint M0 \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. wlp (While M S) P =\n    adjoint (M 0) * P * M 0 +\n    adjoint (M 1) * wlp S (wlp (While M S) P) * M 1", "have dDWDSM1r: \"DW (DS (M1 * \\<rho> * adjoint M1)) \\<in> carrier_mat d d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DW (DS (M1 * \\<rho> * adjoint M1)) \\<in> carrier_mat d d", "unfolding DW_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. denote (While M S) (DS (M1 * \\<rho> * adjoint M1)) \\<in> carrier_mat d d", "using denote_dim[OF wc] dsDSM1r density_states_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>?\\<rho> \\<in> carrier_mat d d;\n   partial_density_operator ?\\<rho>\\<rbrakk>\n  \\<Longrightarrow> denote (While M S) ?\\<rho> \\<in> carrier_mat d d\n  DS (M1 * \\<rho> * adjoint M1) \\<in> density_states\n  density_states =\n  {\\<rho> \\<in> carrier_mat d d. partial_density_operator \\<rho>}\n\ngoal (1 subgoal):\n 1. denote (While M S) (DS (M1 * \\<rho> * adjoint M1)) \\<in> carrier_mat d d", "by auto"], ["proof (state)\nthis:\n  DW (DS (M1 * \\<rho> * adjoint M1)) \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. wlp (While M S) P =\n    adjoint (M 0) * P * M 0 +\n    adjoint (M 1) * wlp S (wlp (While M S) P) * M 1", "have eq2: \"trace ((wlp (While M S) P) * DS (M1 * \\<rho> * adjoint M1))\n          = trace (P * (DW (DS (M1 * \\<rho> * adjoint M1)))) + trace (DS (M1 * \\<rho> * adjoint M1)) - trace (DW (DS (M1 * \\<rho> * adjoint M1)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace (wlp (While M S) P * DS (M1 * \\<rho> * adjoint M1)) =\n    trace (P * DW (DS (M1 * \\<rho> * adjoint M1))) +\n    trace (DS (M1 * \\<rho> * adjoint M1)) -\n    trace (DW (DS (M1 * \\<rho> * adjoint M1)))", "unfolding DW_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. trace (wlp (While M S) P * DS (M1 * \\<rho> * adjoint M1)) =\n    trace (P * denote (While M S) (DS (M1 * \\<rho> * adjoint M1))) +\n    trace (DS (M1 * \\<rho> * adjoint M1)) -\n    trace (denote (While M S) (DS (M1 * \\<rho> * adjoint M1)))", "using wlp_soundness[OF wc qpP] dsDSM1r"], ["proof (prove)\nusing this:\n  \\<forall>\\<rho>\\<in>density_states.\n     trace (wlp (While M S) P * \\<rho>) =\n     trace (P * denote (While M S) \\<rho>) + trace \\<rho> -\n     trace (denote (While M S) \\<rho>)\n  DS (M1 * \\<rho> * adjoint M1) \\<in> density_states\n\ngoal (1 subgoal):\n 1. trace (wlp (While M S) P * DS (M1 * \\<rho> * adjoint M1)) =\n    trace (P * denote (While M S) (DS (M1 * \\<rho> * adjoint M1))) +\n    trace (DS (M1 * \\<rho> * adjoint M1)) -\n    trace (denote (While M S) (DS (M1 * \\<rho> * adjoint M1)))", "by auto"], ["proof (state)\nthis:\n  trace (wlp (While M S) P * DS (M1 * \\<rho> * adjoint M1)) =\n  trace (P * DW (DS (M1 * \\<rho> * adjoint M1))) +\n  trace (DS (M1 * \\<rho> * adjoint M1)) -\n  trace (DW (DS (M1 * \\<rho> * adjoint M1)))\n\ngoal (1 subgoal):\n 1. wlp (While M S) P =\n    adjoint (M 0) * P * M 0 +\n    adjoint (M 1) * wlp S (wlp (While M S) P) * M 1", "have eq3: \"trace (M1 * \\<rho> * adjoint M1) = trace \\<rho> - trace (M0 * \\<rho> * adjoint M0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace (M1 * \\<rho> * adjoint M1) =\n    trace \\<rho> - trace (M0 * \\<rho> * adjoint M0)", "unfolding M0_def M1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. trace (M 1 * \\<rho> * adjoint (M 1)) =\n    trace \\<rho> - trace (M 0 * \\<rho> * adjoint (M 0))", "using m trace_measurement2[OF m dr] dr"], ["proof (prove)\nusing this:\n  measurement d 2 M\n  trace (M 0 * \\<rho> * adjoint (M 0)) +\n  trace (M 1 * \\<rho> * adjoint (M 1)) =\n  trace \\<rho>\n  \\<rho> \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. trace (M 1 * \\<rho> * adjoint (M 1)) =\n    trace \\<rho> - trace (M 0 * \\<rho> * adjoint (M 0))", "by (simp add: algebra_simps)"], ["proof (state)\nthis:\n  trace (M1 * \\<rho> * adjoint M1) =\n  trace \\<rho> - trace (M0 * \\<rho> * adjoint M0)\n\ngoal (1 subgoal):\n 1. wlp (While M S) P =\n    adjoint (M 0) * P * M 0 +\n    adjoint (M 1) * wlp S (wlp (While M S) P) * M 1", "have \"trace (adjoint M1 * (wlp S (wlp (While M S) P)) * M1 * \\<rho>)\n          = trace ((wlp S (wlp (While M S) P)) * (M1 * \\<rho> * adjoint M1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace (adjoint M1 * wlp S (wlp (While M S) P) * M1 * \\<rho>) =\n    trace (wlp S (wlp (While M S) P) * (M1 * \\<rho> * adjoint M1))", "using dWWP dM1 dr"], ["proof (prove)\nusing this:\n  wlp S (wlp (While M S) P) \\<in> carrier_mat d d\n  M1 \\<in> carrier_mat d d\n  \\<rho> \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. trace (adjoint M1 * wlp S (wlp (While M S) P) * M1 * \\<rho>) =\n    trace (wlp S (wlp (While M S) P) * (M1 * \\<rho> * adjoint M1))", "by (mat_assoc d)"], ["proof (state)\nthis:\n  trace (adjoint M1 * wlp S (wlp (While M S) P) * M1 * \\<rho>) =\n  trace (wlp S (wlp (While M S) P) * (M1 * \\<rho> * adjoint M1))\n\ngoal (1 subgoal):\n 1. wlp (While M S) P =\n    adjoint (M 0) * P * M 0 +\n    adjoint (M 1) * wlp S (wlp (While M S) P) * M 1", "also"], ["proof (state)\nthis:\n  trace (adjoint M1 * wlp S (wlp (While M S) P) * M1 * \\<rho>) =\n  trace (wlp S (wlp (While M S) P) * (M1 * \\<rho> * adjoint M1))\n\ngoal (1 subgoal):\n 1. wlp (While M S) P =\n    adjoint (M 0) * P * M 0 +\n    adjoint (M 1) * wlp S (wlp (While M S) P) * M 1", "have \"\\<dots> = trace ((wlp (While M S) P) * DS (M1 * \\<rho> * adjoint M1)) \n                  + trace (M1 * \\<rho> * adjoint M1) - trace (DS (M1 * \\<rho> * adjoint M1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace (wlp S (wlp (While M S) P) * (M1 * \\<rho> * adjoint M1)) =\n    trace (wlp (While M S) P * DS (M1 * \\<rho> * adjoint M1)) +\n    trace (M1 * \\<rho> * adjoint M1) -\n    trace (DS (M1 * \\<rho> * adjoint M1))", "unfolding DS_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. trace (wlp S (wlp (While M S) P) * (M1 * \\<rho> * adjoint M1)) =\n    trace (wlp (While M S) P * denote S (M1 * \\<rho> * adjoint M1)) +\n    trace (M1 * \\<rho> * adjoint M1) -\n    trace (denote S (M1 * \\<rho> * adjoint M1))", "using wlp_soundness[OF wcs qpWP] dsM1r"], ["proof (prove)\nusing this:\n  \\<forall>\\<rho>\\<in>density_states.\n     trace (wlp S (wlp (While M S) P) * \\<rho>) =\n     trace (wlp (While M S) P * denote S \\<rho>) + trace \\<rho> -\n     trace (denote S \\<rho>)\n  M1 * \\<rho> * adjoint M1 \\<in> density_states\n\ngoal (1 subgoal):\n 1. trace (wlp S (wlp (While M S) P) * (M1 * \\<rho> * adjoint M1)) =\n    trace (wlp (While M S) P * denote S (M1 * \\<rho> * adjoint M1)) +\n    trace (M1 * \\<rho> * adjoint M1) -\n    trace (denote S (M1 * \\<rho> * adjoint M1))", "by auto"], ["proof (state)\nthis:\n  trace (wlp S (wlp (While M S) P) * (M1 * \\<rho> * adjoint M1)) =\n  trace (wlp (While M S) P * DS (M1 * \\<rho> * adjoint M1)) +\n  trace (M1 * \\<rho> * adjoint M1) -\n  trace (DS (M1 * \\<rho> * adjoint M1))\n\ngoal (1 subgoal):\n 1. wlp (While M S) P =\n    adjoint (M 0) * P * M 0 +\n    adjoint (M 1) * wlp S (wlp (While M S) P) * M 1", "also"], ["proof (state)\nthis:\n  trace (wlp S (wlp (While M S) P) * (M1 * \\<rho> * adjoint M1)) =\n  trace (wlp (While M S) P * DS (M1 * \\<rho> * adjoint M1)) +\n  trace (M1 * \\<rho> * adjoint M1) -\n  trace (DS (M1 * \\<rho> * adjoint M1))\n\ngoal (1 subgoal):\n 1. wlp (While M S) P =\n    adjoint (M 0) * P * M 0 +\n    adjoint (M 1) * wlp S (wlp (While M S) P) * M 1", "have \"\\<dots> = trace (P * (DW (DS (M1 * \\<rho> * adjoint M1)))) \n                  + trace (M1 * \\<rho> * adjoint M1)  - trace (DW (DS (M1 * \\<rho> * adjoint M1)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace (wlp (While M S) P * DS (M1 * \\<rho> * adjoint M1)) +\n    trace (M1 * \\<rho> * adjoint M1) -\n    trace (DS (M1 * \\<rho> * adjoint M1)) =\n    trace (P * DW (DS (M1 * \\<rho> * adjoint M1))) +\n    trace (M1 * \\<rho> * adjoint M1) -\n    trace (DW (DS (M1 * \\<rho> * adjoint M1)))", "using eq2"], ["proof (prove)\nusing this:\n  trace (wlp (While M S) P * DS (M1 * \\<rho> * adjoint M1)) =\n  trace (P * DW (DS (M1 * \\<rho> * adjoint M1))) +\n  trace (DS (M1 * \\<rho> * adjoint M1)) -\n  trace (DW (DS (M1 * \\<rho> * adjoint M1)))\n\ngoal (1 subgoal):\n 1. trace (wlp (While M S) P * DS (M1 * \\<rho> * adjoint M1)) +\n    trace (M1 * \\<rho> * adjoint M1) -\n    trace (DS (M1 * \\<rho> * adjoint M1)) =\n    trace (P * DW (DS (M1 * \\<rho> * adjoint M1))) +\n    trace (M1 * \\<rho> * adjoint M1) -\n    trace (DW (DS (M1 * \\<rho> * adjoint M1)))", "by auto"], ["proof (state)\nthis:\n  trace (wlp (While M S) P * DS (M1 * \\<rho> * adjoint M1)) +\n  trace (M1 * \\<rho> * adjoint M1) -\n  trace (DS (M1 * \\<rho> * adjoint M1)) =\n  trace (P * DW (DS (M1 * \\<rho> * adjoint M1))) +\n  trace (M1 * \\<rho> * adjoint M1) -\n  trace (DW (DS (M1 * \\<rho> * adjoint M1)))\n\ngoal (1 subgoal):\n 1. wlp (While M S) P =\n    adjoint (M 0) * P * M 0 +\n    adjoint (M 1) * wlp S (wlp (While M S) P) * M 1", "also"], ["proof (state)\nthis:\n  trace (wlp (While M S) P * DS (M1 * \\<rho> * adjoint M1)) +\n  trace (M1 * \\<rho> * adjoint M1) -\n  trace (DS (M1 * \\<rho> * adjoint M1)) =\n  trace (P * DW (DS (M1 * \\<rho> * adjoint M1))) +\n  trace (M1 * \\<rho> * adjoint M1) -\n  trace (DW (DS (M1 * \\<rho> * adjoint M1)))\n\ngoal (1 subgoal):\n 1. wlp (While M S) P =\n    adjoint (M 0) * P * M 0 +\n    adjoint (M 1) * wlp S (wlp (While M S) P) * M 1", "have \"\\<dots> = trace (P * (DW (DS (M1 * \\<rho> * adjoint M1)))) + trace \\<rho> - (trace (M0 * \\<rho> * adjoint M0) + trace (DW (DS (M1 * \\<rho> * adjoint M1))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace (P * DW (DS (M1 * \\<rho> * adjoint M1))) +\n    trace (M1 * \\<rho> * adjoint M1) -\n    trace (DW (DS (M1 * \\<rho> * adjoint M1))) =\n    trace (P * DW (DS (M1 * \\<rho> * adjoint M1))) + trace \\<rho> -\n    (trace (M0 * \\<rho> * adjoint M0) +\n     trace (DW (DS (M1 * \\<rho> * adjoint M1))))", "using eq3"], ["proof (prove)\nusing this:\n  trace (M1 * \\<rho> * adjoint M1) =\n  trace \\<rho> - trace (M0 * \\<rho> * adjoint M0)\n\ngoal (1 subgoal):\n 1. trace (P * DW (DS (M1 * \\<rho> * adjoint M1))) +\n    trace (M1 * \\<rho> * adjoint M1) -\n    trace (DW (DS (M1 * \\<rho> * adjoint M1))) =\n    trace (P * DW (DS (M1 * \\<rho> * adjoint M1))) + trace \\<rho> -\n    (trace (M0 * \\<rho> * adjoint M0) +\n     trace (DW (DS (M1 * \\<rho> * adjoint M1))))", "by auto"], ["proof (state)\nthis:\n  trace (P * DW (DS (M1 * \\<rho> * adjoint M1))) +\n  trace (M1 * \\<rho> * adjoint M1) -\n  trace (DW (DS (M1 * \\<rho> * adjoint M1))) =\n  trace (P * DW (DS (M1 * \\<rho> * adjoint M1))) + trace \\<rho> -\n  (trace (M0 * \\<rho> * adjoint M0) +\n   trace (DW (DS (M1 * \\<rho> * adjoint M1))))\n\ngoal (1 subgoal):\n 1. wlp (While M S) P =\n    adjoint (M 0) * P * M 0 +\n    adjoint (M 1) * wlp S (wlp (While M S) P) * M 1", "finally"], ["proof (chain)\npicking this:\n  trace (adjoint M1 * wlp S (wlp (While M S) P) * M1 * \\<rho>) =\n  trace (P * DW (DS (M1 * \\<rho> * adjoint M1))) + trace \\<rho> -\n  (trace (M0 * \\<rho> * adjoint M0) +\n   trace (DW (DS (M1 * \\<rho> * adjoint M1))))", "have eq4: \"trace (adjoint M1 * (wlp S (wlp (While M S) P)) * M1 * \\<rho>) \n      = trace (P * (DW (DS (M1 * \\<rho> * adjoint M1)))) + trace \\<rho> - (trace (M0 * \\<rho> * adjoint M0) + trace (DW (DS (M1 * \\<rho> * adjoint M1))))\""], ["proof (prove)\nusing this:\n  trace (adjoint M1 * wlp S (wlp (While M S) P) * M1 * \\<rho>) =\n  trace (P * DW (DS (M1 * \\<rho> * adjoint M1))) + trace \\<rho> -\n  (trace (M0 * \\<rho> * adjoint M0) +\n   trace (DW (DS (M1 * \\<rho> * adjoint M1))))\n\ngoal (1 subgoal):\n 1. trace (adjoint M1 * wlp S (wlp (While M S) P) * M1 * \\<rho>) =\n    trace (P * DW (DS (M1 * \\<rho> * adjoint M1))) + trace \\<rho> -\n    (trace (M0 * \\<rho> * adjoint M0) +\n     trace (DW (DS (M1 * \\<rho> * adjoint M1))))", "."], ["proof (state)\nthis:\n  trace (adjoint M1 * wlp S (wlp (While M S) P) * M1 * \\<rho>) =\n  trace (P * DW (DS (M1 * \\<rho> * adjoint M1))) + trace \\<rho> -\n  (trace (M0 * \\<rho> * adjoint M0) +\n   trace (DW (DS (M1 * \\<rho> * adjoint M1))))\n\ngoal (1 subgoal):\n 1. wlp (While M S) P =\n    adjoint (M 0) * P * M 0 +\n    adjoint (M 1) * wlp S (wlp (While M S) P) * M 1", "have \"trace (adjoint M0 * P * M0 * \\<rho>) + trace (P * (DW (DS (M1 * \\<rho> * adjoint M1))))\n      = trace (P * ((M0 * \\<rho> * adjoint M0) + (DW (DS (M1 * \\<rho> * adjoint M1)))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace (adjoint M0 * P * M0 * \\<rho>) +\n    trace (P * DW (DS (M1 * \\<rho> * adjoint M1))) =\n    trace\n     (P * (M0 * \\<rho> * adjoint M0 + DW (DS (M1 * \\<rho> * adjoint M1))))", "using dP dr dM0 dDWDSM1r"], ["proof (prove)\nusing this:\n  P \\<in> carrier_mat d d\n  \\<rho> \\<in> carrier_mat d d\n  M0 \\<in> carrier_mat d d\n  DW (DS (M1 * \\<rho> * adjoint M1)) \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. trace (adjoint M0 * P * M0 * \\<rho>) +\n    trace (P * DW (DS (M1 * \\<rho> * adjoint M1))) =\n    trace\n     (P * (M0 * \\<rho> * adjoint M0 + DW (DS (M1 * \\<rho> * adjoint M1))))", "by (mat_assoc d)"], ["proof (state)\nthis:\n  trace (adjoint M0 * P * M0 * \\<rho>) +\n  trace (P * DW (DS (M1 * \\<rho> * adjoint M1))) =\n  trace\n   (P * (M0 * \\<rho> * adjoint M0 + DW (DS (M1 * \\<rho> * adjoint M1))))\n\ngoal (1 subgoal):\n 1. wlp (While M S) P =\n    adjoint (M 0) * P * M 0 +\n    adjoint (M 1) * wlp S (wlp (While M S) P) * M 1", "also"], ["proof (state)\nthis:\n  trace (adjoint M0 * P * M0 * \\<rho>) +\n  trace (P * DW (DS (M1 * \\<rho> * adjoint M1))) =\n  trace\n   (P * (M0 * \\<rho> * adjoint M0 + DW (DS (M1 * \\<rho> * adjoint M1))))\n\ngoal (1 subgoal):\n 1. wlp (While M S) P =\n    adjoint (M 0) * P * M 0 +\n    adjoint (M 1) * wlp S (wlp (While M S) P) * M 1", "have \"\\<dots> = trace (P * (DW \\<rho>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace\n     (P * (M0 * \\<rho> * adjoint M0 + DW (DS (M1 * \\<rho> * adjoint M1)))) =\n    trace (P * DW \\<rho>)", "unfolding DW_def M0_def M1_def DS_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. trace\n     (P *\n      (M 0 * \\<rho> * adjoint (M 0) +\n       denote (While M S) (denote S (M 1 * \\<rho> * adjoint (M 1))))) =\n    trace (P * denote (While M S) \\<rho>)", "using denote_while_split[OF wc dsr]"], ["proof (prove)\nusing this:\n  denote (While M S) \\<rho> =\n  M 0 * \\<rho> * adjoint (M 0) +\n  denote (While M S) (denote S (M 1 * \\<rho> * adjoint (M 1)))\n\ngoal (1 subgoal):\n 1. trace\n     (P *\n      (M 0 * \\<rho> * adjoint (M 0) +\n       denote (While M S) (denote S (M 1 * \\<rho> * adjoint (M 1))))) =\n    trace (P * denote (While M S) \\<rho>)", "by auto"], ["proof (state)\nthis:\n  trace\n   (P * (M0 * \\<rho> * adjoint M0 + DW (DS (M1 * \\<rho> * adjoint M1)))) =\n  trace (P * DW \\<rho>)\n\ngoal (1 subgoal):\n 1. wlp (While M S) P =\n    adjoint (M 0) * P * M 0 +\n    adjoint (M 1) * wlp S (wlp (While M S) P) * M 1", "finally"], ["proof (chain)\npicking this:\n  trace (adjoint M0 * P * M0 * \\<rho>) +\n  trace (P * DW (DS (M1 * \\<rho> * adjoint M1))) =\n  trace (P * DW \\<rho>)", "have eq5: \"trace (adjoint M0 * P * M0 * \\<rho>) + trace (P * (DW (DS (M1 * \\<rho> * adjoint M1)))) = trace (P * (DW \\<rho>))\""], ["proof (prove)\nusing this:\n  trace (adjoint M0 * P * M0 * \\<rho>) +\n  trace (P * DW (DS (M1 * \\<rho> * adjoint M1))) =\n  trace (P * DW \\<rho>)\n\ngoal (1 subgoal):\n 1. trace (adjoint M0 * P * M0 * \\<rho>) +\n    trace (P * DW (DS (M1 * \\<rho> * adjoint M1))) =\n    trace (P * DW \\<rho>)", "."], ["proof (state)\nthis:\n  trace (adjoint M0 * P * M0 * \\<rho>) +\n  trace (P * DW (DS (M1 * \\<rho> * adjoint M1))) =\n  trace (P * DW \\<rho>)\n\ngoal (1 subgoal):\n 1. wlp (While M S) P =\n    adjoint (M 0) * P * M 0 +\n    adjoint (M 1) * wlp S (wlp (While M S) P) * M 1", "have \"trace (M0 * \\<rho> * adjoint M0) + trace (DW (DS (M1 * \\<rho> * adjoint M1)))\n      = trace (M0 * \\<rho> * adjoint M0 + (DW (DS (M1 * \\<rho> * adjoint M1))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace (M0 * \\<rho> * adjoint M0) +\n    trace (DW (DS (M1 * \\<rho> * adjoint M1))) =\n    trace (M0 * \\<rho> * adjoint M0 + DW (DS (M1 * \\<rho> * adjoint M1)))", "using dr dM0 dDWDSM1r"], ["proof (prove)\nusing this:\n  \\<rho> \\<in> carrier_mat d d\n  M0 \\<in> carrier_mat d d\n  DW (DS (M1 * \\<rho> * adjoint M1)) \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. trace (M0 * \\<rho> * adjoint M0) +\n    trace (DW (DS (M1 * \\<rho> * adjoint M1))) =\n    trace (M0 * \\<rho> * adjoint M0 + DW (DS (M1 * \\<rho> * adjoint M1)))", "by (mat_assoc d)"], ["proof (state)\nthis:\n  trace (M0 * \\<rho> * adjoint M0) +\n  trace (DW (DS (M1 * \\<rho> * adjoint M1))) =\n  trace (M0 * \\<rho> * adjoint M0 + DW (DS (M1 * \\<rho> * adjoint M1)))\n\ngoal (1 subgoal):\n 1. wlp (While M S) P =\n    adjoint (M 0) * P * M 0 +\n    adjoint (M 1) * wlp S (wlp (While M S) P) * M 1", "also"], ["proof (state)\nthis:\n  trace (M0 * \\<rho> * adjoint M0) +\n  trace (DW (DS (M1 * \\<rho> * adjoint M1))) =\n  trace (M0 * \\<rho> * adjoint M0 + DW (DS (M1 * \\<rho> * adjoint M1)))\n\ngoal (1 subgoal):\n 1. wlp (While M S) P =\n    adjoint (M 0) * P * M 0 +\n    adjoint (M 1) * wlp S (wlp (While M S) P) * M 1", "have \"\\<dots> = trace (DW \\<rho>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace (M0 * \\<rho> * adjoint M0 + DW (DS (M1 * \\<rho> * adjoint M1))) =\n    trace (DW \\<rho>)", "unfolding DW_def DS_def M0_def M1_def denote_while_split[OF wc dsr]"], ["proof (prove)\ngoal (1 subgoal):\n 1. trace\n     (M 0 * \\<rho> * adjoint (M 0) +\n      denote (While M S) (denote S (M 1 * \\<rho> * adjoint (M 1)))) =\n    trace\n     (M 0 * \\<rho> * adjoint (M 0) +\n      denote (While M S) (denote S (M 1 * \\<rho> * adjoint (M 1))))", "by auto"], ["proof (state)\nthis:\n  trace (M0 * \\<rho> * adjoint M0 + DW (DS (M1 * \\<rho> * adjoint M1))) =\n  trace (DW \\<rho>)\n\ngoal (1 subgoal):\n 1. wlp (While M S) P =\n    adjoint (M 0) * P * M 0 +\n    adjoint (M 1) * wlp S (wlp (While M S) P) * M 1", "finally"], ["proof (chain)\npicking this:\n  trace (M0 * \\<rho> * adjoint M0) +\n  trace (DW (DS (M1 * \\<rho> * adjoint M1))) =\n  trace (DW \\<rho>)", "have eq6: \"trace (M0 * \\<rho> * adjoint M0) + trace (DW (DS (M1 * \\<rho> * adjoint M1))) = trace (DW \\<rho>)\""], ["proof (prove)\nusing this:\n  trace (M0 * \\<rho> * adjoint M0) +\n  trace (DW (DS (M1 * \\<rho> * adjoint M1))) =\n  trace (DW \\<rho>)\n\ngoal (1 subgoal):\n 1. trace (M0 * \\<rho> * adjoint M0) +\n    trace (DW (DS (M1 * \\<rho> * adjoint M1))) =\n    trace (DW \\<rho>)", "."], ["proof (state)\nthis:\n  trace (M0 * \\<rho> * adjoint M0) +\n  trace (DW (DS (M1 * \\<rho> * adjoint M1))) =\n  trace (DW \\<rho>)\n\ngoal (1 subgoal):\n 1. wlp (While M S) P =\n    adjoint (M 0) * P * M 0 +\n    adjoint (M 1) * wlp S (wlp (While M S) P) * M 1", "from eq5 eq4 eq6"], ["proof (chain)\npicking this:\n  trace (adjoint M0 * P * M0 * \\<rho>) +\n  trace (P * DW (DS (M1 * \\<rho> * adjoint M1))) =\n  trace (P * DW \\<rho>)\n  trace (adjoint M1 * wlp S (wlp (While M S) P) * M1 * \\<rho>) =\n  trace (P * DW (DS (M1 * \\<rho> * adjoint M1))) + trace \\<rho> -\n  (trace (M0 * \\<rho> * adjoint M0) +\n   trace (DW (DS (M1 * \\<rho> * adjoint M1))))\n  trace (M0 * \\<rho> * adjoint M0) +\n  trace (DW (DS (M1 * \\<rho> * adjoint M1))) =\n  trace (DW \\<rho>)", "have\n      eq7: \"trace (adjoint M0 * P * M0 * \\<rho>) + trace (adjoint M1 * wlp S (wlp (While M S) P) * M1 * \\<rho>)\n      = trace (P * DW \\<rho>) + trace \\<rho> - trace (DW \\<rho>)\""], ["proof (prove)\nusing this:\n  trace (adjoint M0 * P * M0 * \\<rho>) +\n  trace (P * DW (DS (M1 * \\<rho> * adjoint M1))) =\n  trace (P * DW \\<rho>)\n  trace (adjoint M1 * wlp S (wlp (While M S) P) * M1 * \\<rho>) =\n  trace (P * DW (DS (M1 * \\<rho> * adjoint M1))) + trace \\<rho> -\n  (trace (M0 * \\<rho> * adjoint M0) +\n   trace (DW (DS (M1 * \\<rho> * adjoint M1))))\n  trace (M0 * \\<rho> * adjoint M0) +\n  trace (DW (DS (M1 * \\<rho> * adjoint M1))) =\n  trace (DW \\<rho>)\n\ngoal (1 subgoal):\n 1. trace (adjoint M0 * P * M0 * \\<rho>) +\n    trace (adjoint M1 * wlp S (wlp (While M S) P) * M1 * \\<rho>) =\n    trace (P * DW \\<rho>) + trace \\<rho> - trace (DW \\<rho>)", "by auto"], ["proof (state)\nthis:\n  trace (adjoint M0 * P * M0 * \\<rho>) +\n  trace (adjoint M1 * wlp S (wlp (While M S) P) * M1 * \\<rho>) =\n  trace (P * DW \\<rho>) + trace \\<rho> - trace (DW \\<rho>)\n\ngoal (1 subgoal):\n 1. wlp (While M S) P =\n    adjoint (M 0) * P * M 0 +\n    adjoint (M 1) * wlp S (wlp (While M S) P) * M 1", "have eq8: \"trace (adjoint M0 * P * M0 * \\<rho>) + trace (adjoint M1 * wlp S (wlp (While M S) P) * M1 * \\<rho>)\n      = trace ((adjoint M0 * P * M0 + adjoint M1 * wlp S (wlp (While M S) P) * M1) * \\<rho>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace (adjoint M0 * P * M0 * \\<rho>) +\n    trace (adjoint M1 * wlp S (wlp (While M S) P) * M1 * \\<rho>) =\n    trace\n     ((adjoint M0 * P * M0 + adjoint M1 * wlp S (wlp (While M S) P) * M1) *\n      \\<rho>)", "using dM0 dM1 dr dP dWWP"], ["proof (prove)\nusing this:\n  M0 \\<in> carrier_mat d d\n  M1 \\<in> carrier_mat d d\n  \\<rho> \\<in> carrier_mat d d\n  P \\<in> carrier_mat d d\n  wlp S (wlp (While M S) P) \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. trace (adjoint M0 * P * M0 * \\<rho>) +\n    trace (adjoint M1 * wlp S (wlp (While M S) P) * M1 * \\<rho>) =\n    trace\n     ((adjoint M0 * P * M0 + adjoint M1 * wlp S (wlp (While M S) P) * M1) *\n      \\<rho>)", "by (mat_assoc d)"], ["proof (state)\nthis:\n  trace (adjoint M0 * P * M0 * \\<rho>) +\n  trace (adjoint M1 * wlp S (wlp (While M S) P) * M1 * \\<rho>) =\n  trace\n   ((adjoint M0 * P * M0 + adjoint M1 * wlp S (wlp (While M S) P) * M1) *\n    \\<rho>)\n\ngoal (1 subgoal):\n 1. wlp (While M S) P =\n    adjoint (M 0) * P * M 0 +\n    adjoint (M 1) * wlp S (wlp (While M S) P) * M 1", "from eq7 eq8"], ["proof (chain)\npicking this:\n  trace (adjoint M0 * P * M0 * \\<rho>) +\n  trace (adjoint M1 * wlp S (wlp (While M S) P) * M1 * \\<rho>) =\n  trace (P * DW \\<rho>) + trace \\<rho> - trace (DW \\<rho>)\n  trace (adjoint M0 * P * M0 * \\<rho>) +\n  trace (adjoint M1 * wlp S (wlp (While M S) P) * M1 * \\<rho>) =\n  trace\n   ((adjoint M0 * P * M0 + adjoint M1 * wlp S (wlp (While M S) P) * M1) *\n    \\<rho>)", "have \n      eq9: \"trace ((adjoint M0 * P * M0 + adjoint M1 * wlp S (wlp (While M S) P) * M1) * \\<rho>) = trace (P * DW \\<rho>) + trace \\<rho> - trace (DW \\<rho>)\""], ["proof (prove)\nusing this:\n  trace (adjoint M0 * P * M0 * \\<rho>) +\n  trace (adjoint M1 * wlp S (wlp (While M S) P) * M1 * \\<rho>) =\n  trace (P * DW \\<rho>) + trace \\<rho> - trace (DW \\<rho>)\n  trace (adjoint M0 * P * M0 * \\<rho>) +\n  trace (adjoint M1 * wlp S (wlp (While M S) P) * M1 * \\<rho>) =\n  trace\n   ((adjoint M0 * P * M0 + adjoint M1 * wlp S (wlp (While M S) P) * M1) *\n    \\<rho>)\n\ngoal (1 subgoal):\n 1. trace\n     ((adjoint M0 * P * M0 + adjoint M1 * wlp S (wlp (While M S) P) * M1) *\n      \\<rho>) =\n    trace (P * DW \\<rho>) + trace \\<rho> - trace (DW \\<rho>)", "by auto"], ["proof (state)\nthis:\n  trace\n   ((adjoint M0 * P * M0 + adjoint M1 * wlp S (wlp (While M S) P) * M1) *\n    \\<rho>) =\n  trace (P * DW \\<rho>) + trace \\<rho> - trace (DW \\<rho>)\n\ngoal (1 subgoal):\n 1. wlp (While M S) P =\n    adjoint (M 0) * P * M 0 +\n    adjoint (M 1) * wlp S (wlp (While M S) P) * M 1", "have eq10: \"trace ((wlp (While M S) P) * \\<rho>) = trace (P * DW \\<rho>) + trace \\<rho> - trace (DW \\<rho>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace (wlp (While M S) P * \\<rho>) =\n    trace (P * DW \\<rho>) + trace \\<rho> - trace (DW \\<rho>)", "unfolding DW_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. trace (wlp (While M S) P * \\<rho>) =\n    trace (P * denote (While M S) \\<rho>) + trace \\<rho> -\n    trace (denote (While M S) \\<rho>)", "using wlp_soundness[OF wc qpP] dsr"], ["proof (prove)\nusing this:\n  \\<forall>\\<rho>\\<in>density_states.\n     trace (wlp (While M S) P * \\<rho>) =\n     trace (P * denote (While M S) \\<rho>) + trace \\<rho> -\n     trace (denote (While M S) \\<rho>)\n  \\<rho> \\<in> density_states\n\ngoal (1 subgoal):\n 1. trace (wlp (While M S) P * \\<rho>) =\n    trace (P * denote (While M S) \\<rho>) + trace \\<rho> -\n    trace (denote (While M S) \\<rho>)", "by auto"], ["proof (state)\nthis:\n  trace (wlp (While M S) P * \\<rho>) =\n  trace (P * DW \\<rho>) + trace \\<rho> - trace (DW \\<rho>)\n\ngoal (1 subgoal):\n 1. wlp (While M S) P =\n    adjoint (M 0) * P * M 0 +\n    adjoint (M 1) * wlp S (wlp (While M S) P) * M 1", "with eq9"], ["proof (chain)\npicking this:\n  trace\n   ((adjoint M0 * P * M0 + adjoint M1 * wlp S (wlp (While M S) P) * M1) *\n    \\<rho>) =\n  trace (P * DW \\<rho>) + trace \\<rho> - trace (DW \\<rho>)\n  trace (wlp (While M S) P * \\<rho>) =\n  trace (P * DW \\<rho>) + trace \\<rho> - trace (DW \\<rho>)", "have \"trace ((wlp (While M S) P) * \\<rho>) = trace ((adjoint M0 * P * M0 + adjoint M1 * wlp S (wlp (While M S) P) * M1) * \\<rho>)\""], ["proof (prove)\nusing this:\n  trace\n   ((adjoint M0 * P * M0 + adjoint M1 * wlp S (wlp (While M S) P) * M1) *\n    \\<rho>) =\n  trace (P * DW \\<rho>) + trace \\<rho> - trace (DW \\<rho>)\n  trace (wlp (While M S) P * \\<rho>) =\n  trace (P * DW \\<rho>) + trace \\<rho> - trace (DW \\<rho>)\n\ngoal (1 subgoal):\n 1. trace (wlp (While M S) P * \\<rho>) =\n    trace\n     ((adjoint M0 * P * M0 + adjoint M1 * wlp S (wlp (While M S) P) * M1) *\n      \\<rho>)", "by auto"], ["proof (state)\nthis:\n  trace (wlp (While M S) P * \\<rho>) =\n  trace\n   ((adjoint M0 * P * M0 + adjoint M1 * wlp S (wlp (While M S) P) * M1) *\n    \\<rho>)\n\ngoal (1 subgoal):\n 1. wlp (While M S) P =\n    adjoint (M 0) * P * M 0 +\n    adjoint (M 1) * wlp S (wlp (While M S) P) * M 1", "}"], ["proof (state)\nthis:\n  ?\\<rho>2 \\<in> density_states \\<Longrightarrow>\n  trace (wlp (While M S) P * ?\\<rho>2) =\n  trace\n   ((adjoint M0 * P * M0 + adjoint M1 * wlp S (wlp (While M S) P) * M1) *\n    ?\\<rho>2)\n\ngoal (1 subgoal):\n 1. wlp (While M S) P =\n    adjoint (M 0) * P * M 0 +\n    adjoint (M 1) * wlp S (wlp (While M S) P) * M 1", "then"], ["proof (chain)\npicking this:\n  ?\\<rho>2 \\<in> density_states \\<Longrightarrow>\n  trace (wlp (While M S) P * ?\\<rho>2) =\n  trace\n   ((adjoint M0 * P * M0 + adjoint M1 * wlp S (wlp (While M S) P) * M1) *\n    ?\\<rho>2)", "have \"(wlp (While M S) P) = (adjoint M0 * P * M0 + adjoint M1 * wlp S (wlp (While M S) P) * M1)\""], ["proof (prove)\nusing this:\n  ?\\<rho>2 \\<in> density_states \\<Longrightarrow>\n  trace (wlp (While M S) P * ?\\<rho>2) =\n  trace\n   ((adjoint M0 * P * M0 + adjoint M1 * wlp S (wlp (While M S) P) * M1) *\n    ?\\<rho>2)\n\ngoal (1 subgoal):\n 1. wlp (While M S) P =\n    adjoint M0 * P * M0 + adjoint M1 * wlp S (wlp (While M S) P) * M1", "using trace_pdo_eq_imp_eq[OF dWP, of \"adjoint M0 * P * M0 + adjoint M1 * wlp S (wlp (While M S) P) * M1\"] \n      dM0 dP dM1 dWWP density_states_def"], ["proof (prove)\nusing this:\n  ?\\<rho>2 \\<in> density_states \\<Longrightarrow>\n  trace (wlp (While M S) P * ?\\<rho>2) =\n  trace\n   ((adjoint M0 * P * M0 + adjoint M1 * wlp S (wlp (While M S) P) * M1) *\n    ?\\<rho>2)\n  \\<lbrakk>adjoint M0 * P * M0 + adjoint M1 * wlp S (wlp (While M S) P) * M1\n           \\<in> carrier_mat d d;\n   \\<And>\\<rho>.\n      \\<lbrakk>\\<rho> \\<in> carrier_mat d d;\n       partial_density_operator \\<rho>\\<rbrakk>\n      \\<Longrightarrow> trace (wlp (While M S) P * \\<rho>) =\n                        trace\n                         ((adjoint M0 * P * M0 +\n                           adjoint M1 * wlp S (wlp (While M S) P) * M1) *\n                          \\<rho>)\\<rbrakk>\n  \\<Longrightarrow> wlp (While M S) P =\n                    adjoint M0 * P * M0 +\n                    adjoint M1 * wlp S (wlp (While M S) P) * M1\n  M0 \\<in> carrier_mat d d\n  P \\<in> carrier_mat d d\n  M1 \\<in> carrier_mat d d\n  wlp S (wlp (While M S) P) \\<in> carrier_mat d d\n  density_states =\n  {\\<rho> \\<in> carrier_mat d d. partial_density_operator \\<rho>}\n\ngoal (1 subgoal):\n 1. wlp (While M S) P =\n    adjoint M0 * P * M0 + adjoint M1 * wlp S (wlp (While M S) P) * M1", "by fastforce"], ["proof (state)\nthis:\n  wlp (While M S) P =\n  adjoint M0 * P * M0 + adjoint M1 * wlp S (wlp (While M S) P) * M1\n\ngoal (1 subgoal):\n 1. wlp (While M S) P =\n    adjoint (M 0) * P * M 0 +\n    adjoint (M 1) * wlp S (wlp (While M S) P) * M 1", "then"], ["proof (chain)\npicking this:\n  wlp (While M S) P =\n  adjoint M0 * P * M0 + adjoint M1 * wlp S (wlp (While M S) P) * M1", "show ?thesis"], ["proof (prove)\nusing this:\n  wlp (While M S) P =\n  adjoint M0 * P * M0 + adjoint M1 * wlp S (wlp (While M S) P) * M1\n\ngoal (1 subgoal):\n 1. wlp (While M S) P =\n    adjoint (M 0) * P * M 0 +\n    adjoint (M 1) * wlp S (wlp (While M S) P) * M 1", "using M0_def M1_def"], ["proof (prove)\nusing this:\n  wlp (While M S) P =\n  adjoint M0 * P * M0 + adjoint M1 * wlp S (wlp (While M S) P) * M1\n  M0 = M 0\n  M1 = M 1\n\ngoal (1 subgoal):\n 1. wlp (While M S) P =\n    adjoint (M 0) * P * M 0 +\n    adjoint (M 1) * wlp S (wlp (While M S) P) * M 1", "by auto"], ["proof (state)\nthis:\n  wlp (While M S) P =\n  adjoint (M 0) * P * M 0 + adjoint (M 1) * wlp S (wlp (While M S) P) * M 1\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma wlp_is_weakest_liberal_precondition:\n  assumes \"well_com S\" and \"is_quantum_predicate P\"\n  shows \"is_weakest_liberal_precondition (wlp S P) S P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_weakest_liberal_precondition (wlp S P) S P", "unfolding is_weakest_liberal_precondition_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_quantum_predicate (wlp S P) \\<and>\n    \\<Turnstile>\\<^sub>p {wlp S P} S {P} \\<and>\n    (\\<forall>Q.\n        is_quantum_predicate Q \\<longrightarrow>\n        \\<Turnstile>\\<^sub>p {Q} S {P} \\<longrightarrow>\n        Q \\<le>\\<^sub>L wlp S P)", "proof (auto)"], ["proof (state)\ngoal (3 subgoals):\n 1. is_quantum_predicate (wlp S P)\n 2. \\<Turnstile>\\<^sub>p {wlp S P} S {P}\n 3. \\<And>Q.\n       \\<lbrakk>is_quantum_predicate Q;\n        \\<Turnstile>\\<^sub>p {Q} S {P}\\<rbrakk>\n       \\<Longrightarrow> Q \\<le>\\<^sub>L wlp S P", "show qpWP: \"is_quantum_predicate (wlp S P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_quantum_predicate (wlp S P)", "using wlp_close assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>well_com ?S; is_quantum_predicate ?P\\<rbrakk>\n  \\<Longrightarrow> is_quantum_predicate (wlp ?S ?P)\n  well_com S\n  is_quantum_predicate P\n\ngoal (1 subgoal):\n 1. is_quantum_predicate (wlp S P)", "by auto"], ["proof (state)\nthis:\n  is_quantum_predicate (wlp S P)\n\ngoal (2 subgoals):\n 1. \\<Turnstile>\\<^sub>p {wlp S P} S {P}\n 2. \\<And>Q.\n       \\<lbrakk>is_quantum_predicate Q;\n        \\<Turnstile>\\<^sub>p {Q} S {P}\\<rbrakk>\n       \\<Longrightarrow> Q \\<le>\\<^sub>L wlp S P", "have eq: \"trace (wlp S P * \\<rho>) = trace (P * (denote S \\<rho>)) + trace \\<rho> - trace (denote S \\<rho>)\" if dsr: \"\\<rho> \\<in> density_states\" for \\<rho>"], ["proof (prove)\ngoal (1 subgoal):\n 1. trace (wlp S P * \\<rho>) =\n    trace (P * denote S \\<rho>) + trace \\<rho> - trace (denote S \\<rho>)", "using wlp_soundness assms dsr"], ["proof (prove)\nusing this:\n  \\<lbrakk>well_com ?S; is_quantum_predicate ?P\\<rbrakk>\n  \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                       trace (wlp ?S ?P * \\<rho>) =\n                       trace (?P * denote ?S \\<rho>) + trace \\<rho> -\n                       trace (denote ?S \\<rho>)\n  well_com S\n  is_quantum_predicate P\n  \\<rho> \\<in> density_states\n\ngoal (1 subgoal):\n 1. trace (wlp S P * \\<rho>) =\n    trace (P * denote S \\<rho>) + trace \\<rho> - trace (denote S \\<rho>)", "by auto"], ["proof (state)\nthis:\n  ?\\<rho> \\<in> density_states \\<Longrightarrow>\n  trace (wlp S P * ?\\<rho>) =\n  trace (P * denote S ?\\<rho>) + trace ?\\<rho> - trace (denote S ?\\<rho>)\n\ngoal (2 subgoals):\n 1. \\<Turnstile>\\<^sub>p {wlp S P} S {P}\n 2. \\<And>Q.\n       \\<lbrakk>is_quantum_predicate Q;\n        \\<Turnstile>\\<^sub>p {Q} S {P}\\<rbrakk>\n       \\<Longrightarrow> Q \\<le>\\<^sub>L wlp S P", "then"], ["proof (chain)\npicking this:\n  ?\\<rho> \\<in> density_states \\<Longrightarrow>\n  trace (wlp S P * ?\\<rho>) =\n  trace (P * denote S ?\\<rho>) + trace ?\\<rho> - trace (denote S ?\\<rho>)", "show \"\\<Turnstile>\\<^sub>p {wlp S P} S {P}\""], ["proof (prove)\nusing this:\n  ?\\<rho> \\<in> density_states \\<Longrightarrow>\n  trace (wlp S P * ?\\<rho>) =\n  trace (P * denote S ?\\<rho>) + trace ?\\<rho> - trace (denote S ?\\<rho>)\n\ngoal (1 subgoal):\n 1. \\<Turnstile>\\<^sub>p {wlp S P} S {P}", "unfolding hoare_partial_correct_def"], ["proof (prove)\nusing this:\n  ?\\<rho> \\<in> density_states \\<Longrightarrow>\n  trace (wlp S P * ?\\<rho>) =\n  trace (P * denote S ?\\<rho>) + trace ?\\<rho> - trace (denote S ?\\<rho>)\n\ngoal (1 subgoal):\n 1. \\<forall>\\<rho>\\<in>density_states.\n       trace (wlp S P * \\<rho>)\n       \\<le> trace (P * denote S \\<rho>) +\n             (trace \\<rho> - trace (denote S \\<rho>))", "by auto"], ["proof (state)\nthis:\n  \\<Turnstile>\\<^sub>p {wlp S P} S {P}\n\ngoal (1 subgoal):\n 1. \\<And>Q.\n       \\<lbrakk>is_quantum_predicate Q;\n        \\<Turnstile>\\<^sub>p {Q} S {P}\\<rbrakk>\n       \\<Longrightarrow> Q \\<le>\\<^sub>L wlp S P", "fix Q"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Q.\n       \\<lbrakk>is_quantum_predicate Q;\n        \\<Turnstile>\\<^sub>p {Q} S {P}\\<rbrakk>\n       \\<Longrightarrow> Q \\<le>\\<^sub>L wlp S P", "assume qpQ: \"is_quantum_predicate Q\" and p: \"\\<Turnstile>\\<^sub>p {Q} S {P}\""], ["proof (state)\nthis:\n  is_quantum_predicate Q\n  \\<Turnstile>\\<^sub>p {Q} S {P}\n\ngoal (1 subgoal):\n 1. \\<And>Q.\n       \\<lbrakk>is_quantum_predicate Q;\n        \\<Turnstile>\\<^sub>p {Q} S {P}\\<rbrakk>\n       \\<Longrightarrow> Q \\<le>\\<^sub>L wlp S P", "{"], ["proof (state)\nthis:\n  is_quantum_predicate Q\n  \\<Turnstile>\\<^sub>p {Q} S {P}\n\ngoal (1 subgoal):\n 1. \\<And>Q.\n       \\<lbrakk>is_quantum_predicate Q;\n        \\<Turnstile>\\<^sub>p {Q} S {P}\\<rbrakk>\n       \\<Longrightarrow> Q \\<le>\\<^sub>L wlp S P", "fix \\<rho>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Q.\n       \\<lbrakk>is_quantum_predicate Q;\n        \\<Turnstile>\\<^sub>p {Q} S {P}\\<rbrakk>\n       \\<Longrightarrow> Q \\<le>\\<^sub>L wlp S P", "assume dsr: \"\\<rho> \\<in> density_states\""], ["proof (state)\nthis:\n  \\<rho> \\<in> density_states\n\ngoal (1 subgoal):\n 1. \\<And>Q.\n       \\<lbrakk>is_quantum_predicate Q;\n        \\<Turnstile>\\<^sub>p {Q} S {P}\\<rbrakk>\n       \\<Longrightarrow> Q \\<le>\\<^sub>L wlp S P", "then"], ["proof (chain)\npicking this:\n  \\<rho> \\<in> density_states", "have \"trace (Q * \\<rho>) \\<le> trace (P * (denote S \\<rho>)) + trace \\<rho> - trace (denote S \\<rho>)\""], ["proof (prove)\nusing this:\n  \\<rho> \\<in> density_states\n\ngoal (1 subgoal):\n 1. trace (Q * \\<rho>)\n    \\<le> trace (P * denote S \\<rho>) + trace \\<rho> -\n          trace (denote S \\<rho>)", "using hoare_partial_correct_def p"], ["proof (prove)\nusing this:\n  \\<rho> \\<in> density_states\n  (\\<Turnstile>\\<^sub>p {?P} ?S {?Q}) =\n  (\\<forall>\\<rho>\\<in>density_states.\n      trace (?P * \\<rho>)\n      \\<le> trace (?Q * denote ?S \\<rho>) +\n            (trace \\<rho> - trace (denote ?S \\<rho>)))\n  \\<Turnstile>\\<^sub>p {Q} S {P}\n\ngoal (1 subgoal):\n 1. trace (Q * \\<rho>)\n    \\<le> trace (P * denote S \\<rho>) + trace \\<rho> -\n          trace (denote S \\<rho>)", "by auto"], ["proof (state)\nthis:\n  trace (Q * \\<rho>)\n  \\<le> trace (P * denote S \\<rho>) + trace \\<rho> - trace (denote S \\<rho>)\n\ngoal (1 subgoal):\n 1. \\<And>Q.\n       \\<lbrakk>is_quantum_predicate Q;\n        \\<Turnstile>\\<^sub>p {Q} S {P}\\<rbrakk>\n       \\<Longrightarrow> Q \\<le>\\<^sub>L wlp S P", "then"], ["proof (chain)\npicking this:\n  trace (Q * \\<rho>)\n  \\<le> trace (P * denote S \\<rho>) + trace \\<rho> - trace (denote S \\<rho>)", "have \"trace (Q * \\<rho>) \\<le> trace (wlp S P * \\<rho>)\""], ["proof (prove)\nusing this:\n  trace (Q * \\<rho>)\n  \\<le> trace (P * denote S \\<rho>) + trace \\<rho> - trace (denote S \\<rho>)\n\ngoal (1 subgoal):\n 1. trace (Q * \\<rho>) \\<le> trace (wlp S P * \\<rho>)", "using eq[symmetric] dsr"], ["proof (prove)\nusing this:\n  trace (Q * \\<rho>)\n  \\<le> trace (P * denote S \\<rho>) + trace \\<rho> - trace (denote S \\<rho>)\n  ?\\<rho> \\<in> density_states \\<Longrightarrow>\n  trace (P * denote S ?\\<rho>) + trace ?\\<rho> - trace (denote S ?\\<rho>) =\n  trace (wlp S P * ?\\<rho>)\n  \\<rho> \\<in> density_states\n\ngoal (1 subgoal):\n 1. trace (Q * \\<rho>) \\<le> trace (wlp S P * \\<rho>)", "by auto"], ["proof (state)\nthis:\n  trace (Q * \\<rho>) \\<le> trace (wlp S P * \\<rho>)\n\ngoal (1 subgoal):\n 1. \\<And>Q.\n       \\<lbrakk>is_quantum_predicate Q;\n        \\<Turnstile>\\<^sub>p {Q} S {P}\\<rbrakk>\n       \\<Longrightarrow> Q \\<le>\\<^sub>L wlp S P", "}"], ["proof (state)\nthis:\n  ?\\<rho>2 \\<in> density_states \\<Longrightarrow>\n  trace (Q * ?\\<rho>2) \\<le> trace (wlp S P * ?\\<rho>2)\n\ngoal (1 subgoal):\n 1. \\<And>Q.\n       \\<lbrakk>is_quantum_predicate Q;\n        \\<Turnstile>\\<^sub>p {Q} S {P}\\<rbrakk>\n       \\<Longrightarrow> Q \\<le>\\<^sub>L wlp S P", "then"], ["proof (chain)\npicking this:\n  ?\\<rho>2 \\<in> density_states \\<Longrightarrow>\n  trace (Q * ?\\<rho>2) \\<le> trace (wlp S P * ?\\<rho>2)", "show \"Q \\<le>\\<^sub>L wlp S P\""], ["proof (prove)\nusing this:\n  ?\\<rho>2 \\<in> density_states \\<Longrightarrow>\n  trace (Q * ?\\<rho>2) \\<le> trace (wlp S P * ?\\<rho>2)\n\ngoal (1 subgoal):\n 1. Q \\<le>\\<^sub>L wlp S P", "using lowner_le_trace density_states_def qpQ qpWP is_quantum_predicate_def"], ["proof (prove)\nusing this:\n  ?\\<rho>2 \\<in> density_states \\<Longrightarrow>\n  trace (Q * ?\\<rho>2) \\<le> trace (wlp S P * ?\\<rho>2)\n  \\<lbrakk>?A \\<in> carrier_mat ?n ?n; ?B \\<in> carrier_mat ?n ?n\\<rbrakk>\n  \\<Longrightarrow> (?A \\<le>\\<^sub>L ?B) =\n                    (\\<forall>\\<rho>\\<in>carrier_mat ?n ?n.\n                        partial_density_operator \\<rho> \\<longrightarrow>\n                        trace (?A * \\<rho>) \\<le> trace (?B * \\<rho>))\n  density_states =\n  {\\<rho> \\<in> carrier_mat d d. partial_density_operator \\<rho>}\n  is_quantum_predicate Q\n  is_quantum_predicate (wlp S P)\n  is_quantum_predicate ?P =\n  (?P \\<in> carrier_mat d d \\<and>\n   positive ?P \\<and> ?P \\<le>\\<^sub>L 1\\<^sub>m d)\n\ngoal (1 subgoal):\n 1. Q \\<le>\\<^sub>L wlp S P", "by auto"], ["proof (state)\nthis:\n  Q \\<le>\\<^sub>L wlp S P\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Hoare triples for partial correctness\\<close>"], ["", "inductive hoare_partial :: \"complex mat \\<Rightarrow> com \\<Rightarrow> complex mat \\<Rightarrow> bool\" (\"\\<turnstile>\\<^sub>p ({(1_)}/ (_)/ {(1_)})\" 50) where\n  \"is_quantum_predicate P \\<Longrightarrow> \\<turnstile>\\<^sub>p {P} SKIP {P}\"\n| \"is_quantum_predicate P \\<Longrightarrow> \\<turnstile>\\<^sub>p {adjoint U * P * U} Utrans U {P}\"\n| \"is_quantum_predicate P \\<Longrightarrow> is_quantum_predicate Q \\<Longrightarrow> is_quantum_predicate R \\<Longrightarrow>\n   \\<turnstile>\\<^sub>p {P} S1 {Q} \\<Longrightarrow> \\<turnstile>\\<^sub>p {Q} S2 {R} \\<Longrightarrow>\n   \\<turnstile>\\<^sub>p {P} Seq S1 S2 {R}\"\n| \"(\\<And>k. k < n \\<Longrightarrow> is_quantum_predicate (P k)) \\<Longrightarrow> is_quantum_predicate Q \\<Longrightarrow>\n   (\\<And>k. k < n \\<Longrightarrow> \\<turnstile>\\<^sub>p {P k} S ! k {Q}) \\<Longrightarrow>\n   \\<turnstile>\\<^sub>p {matrix_sum d (\\<lambda>k. adjoint (M k) * P k  * M k) n} Measure n M S {Q}\"\n| \"is_quantum_predicate P \\<Longrightarrow> is_quantum_predicate Q \\<Longrightarrow>\n   \\<turnstile>\\<^sub>p {Q} S {adjoint (M 0) * P * M 0 + adjoint (M 1) * Q * M 1} \\<Longrightarrow>\n   \\<turnstile>\\<^sub>p {adjoint (M 0) * P * M 0 + adjoint (M 1) * Q * M 1} While M S {P}\"\n| \"is_quantum_predicate P \\<Longrightarrow> is_quantum_predicate Q \\<Longrightarrow> is_quantum_predicate P' \\<Longrightarrow> is_quantum_predicate Q' \\<Longrightarrow>\n   P \\<le>\\<^sub>L P' \\<Longrightarrow> \\<turnstile>\\<^sub>p {P'} S {Q'} \\<Longrightarrow> Q' \\<le>\\<^sub>L Q \\<Longrightarrow> \\<turnstile>\\<^sub>p {P} S {Q}\""], ["", "theorem hoare_partial_sound:\n  \"\\<turnstile>\\<^sub>p {P} S {Q} \\<Longrightarrow> well_com S \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P} S {Q}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<turnstile>\\<^sub>p {P} S {Q}; well_com S\\<rbrakk>\n    \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P} S {Q}", "proof (induction rule: hoare_partial.induct)"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>P.\n       \\<lbrakk>is_quantum_predicate P; well_com SKIP\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P} SKIP {P}\n 2. \\<And>P U.\n       \\<lbrakk>is_quantum_predicate P; well_com (Utrans U)\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {adjoint U * P * U} Utrans U\n                         {P}\n 3. \\<And>P Q R S1 S2.\n       \\<lbrakk>is_quantum_predicate P; is_quantum_predicate Q;\n        is_quantum_predicate R; \\<turnstile>\\<^sub>p {P} S1 {Q};\n        well_com S1 \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P} S1 {Q};\n        \\<turnstile>\\<^sub>p {Q} S2 {R};\n        well_com S2 \\<Longrightarrow> \\<Turnstile>\\<^sub>p {Q} S2 {R};\n        well_com (S1;; S2)\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P} S1;; S2 {R}\n 4. \\<And>n P Q S M.\n       \\<lbrakk>\\<And>k. k < n \\<Longrightarrow> is_quantum_predicate (P k);\n        is_quantum_predicate Q;\n        \\<And>k.\n           k < n \\<Longrightarrow> \\<turnstile>\\<^sub>p {P k} S ! k {Q};\n        \\<And>k.\n           \\<lbrakk>k < n; well_com (S ! k)\\<rbrakk>\n           \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P k} S ! k {Q};\n        well_com (Measure n M S)\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {matrix_sum d\n          (\\<lambda>k. adjoint (M k) * P k * M k) n}\n                         Measure n M S {Q}\n 5. \\<And>P Q S M.\n       \\<lbrakk>is_quantum_predicate P; is_quantum_predicate Q;\n        \\<turnstile>\\<^sub>p {Q} S\n                             {adjoint (M 0) * P * M 0 +\n                              adjoint (M 1) * Q * M 1};\n        well_com S \\<Longrightarrow>\n        \\<Turnstile>\\<^sub>p {Q} S\n        {adjoint (M 0) * P * M 0 + adjoint (M 1) * Q * M 1};\n        well_com (While M S)\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {adjoint (M 0) * P * M 0 +\n         adjoint (M 1) * Q * M 1}\n                         While M S {P}\n 6. \\<And>P Q P' Q' S.\n       \\<lbrakk>is_quantum_predicate P; is_quantum_predicate Q;\n        is_quantum_predicate P'; is_quantum_predicate Q';\n        P \\<le>\\<^sub>L P'; \\<turnstile>\\<^sub>p {P'} S {Q'};\n        well_com S \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P'} S {Q'};\n        Q' \\<le>\\<^sub>L Q; well_com S\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P} S {Q}", "case (1 P)"], ["proof (state)\nthis:\n  is_quantum_predicate P\n  well_com SKIP\n\ngoal (6 subgoals):\n 1. \\<And>P.\n       \\<lbrakk>is_quantum_predicate P; well_com SKIP\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P} SKIP {P}\n 2. \\<And>P U.\n       \\<lbrakk>is_quantum_predicate P; well_com (Utrans U)\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {adjoint U * P * U} Utrans U\n                         {P}\n 3. \\<And>P Q R S1 S2.\n       \\<lbrakk>is_quantum_predicate P; is_quantum_predicate Q;\n        is_quantum_predicate R; \\<turnstile>\\<^sub>p {P} S1 {Q};\n        well_com S1 \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P} S1 {Q};\n        \\<turnstile>\\<^sub>p {Q} S2 {R};\n        well_com S2 \\<Longrightarrow> \\<Turnstile>\\<^sub>p {Q} S2 {R};\n        well_com (S1;; S2)\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P} S1;; S2 {R}\n 4. \\<And>n P Q S M.\n       \\<lbrakk>\\<And>k. k < n \\<Longrightarrow> is_quantum_predicate (P k);\n        is_quantum_predicate Q;\n        \\<And>k.\n           k < n \\<Longrightarrow> \\<turnstile>\\<^sub>p {P k} S ! k {Q};\n        \\<And>k.\n           \\<lbrakk>k < n; well_com (S ! k)\\<rbrakk>\n           \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P k} S ! k {Q};\n        well_com (Measure n M S)\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {matrix_sum d\n          (\\<lambda>k. adjoint (M k) * P k * M k) n}\n                         Measure n M S {Q}\n 5. \\<And>P Q S M.\n       \\<lbrakk>is_quantum_predicate P; is_quantum_predicate Q;\n        \\<turnstile>\\<^sub>p {Q} S\n                             {adjoint (M 0) * P * M 0 +\n                              adjoint (M 1) * Q * M 1};\n        well_com S \\<Longrightarrow>\n        \\<Turnstile>\\<^sub>p {Q} S\n        {adjoint (M 0) * P * M 0 + adjoint (M 1) * Q * M 1};\n        well_com (While M S)\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {adjoint (M 0) * P * M 0 +\n         adjoint (M 1) * Q * M 1}\n                         While M S {P}\n 6. \\<And>P Q P' Q' S.\n       \\<lbrakk>is_quantum_predicate P; is_quantum_predicate Q;\n        is_quantum_predicate P'; is_quantum_predicate Q';\n        P \\<le>\\<^sub>L P'; \\<turnstile>\\<^sub>p {P'} S {Q'};\n        well_com S \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P'} S {Q'};\n        Q' \\<le>\\<^sub>L Q; well_com S\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P} S {Q}", "then"], ["proof (chain)\npicking this:\n  is_quantum_predicate P\n  well_com SKIP", "show ?case"], ["proof (prove)\nusing this:\n  is_quantum_predicate P\n  well_com SKIP\n\ngoal (1 subgoal):\n 1. \\<Turnstile>\\<^sub>p {P} SKIP {P}", "unfolding hoare_partial_correct_def"], ["proof (prove)\nusing this:\n  is_quantum_predicate P\n  well_com SKIP\n\ngoal (1 subgoal):\n 1. \\<forall>\\<rho>\\<in>density_states.\n       trace (P * \\<rho>)\n       \\<le> trace (P * denote SKIP \\<rho>) +\n             (trace \\<rho> - trace (denote SKIP \\<rho>))", "by auto"], ["proof (state)\nthis:\n  \\<Turnstile>\\<^sub>p {P} SKIP {P}\n\ngoal (5 subgoals):\n 1. \\<And>P U.\n       \\<lbrakk>is_quantum_predicate P; well_com (Utrans U)\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {adjoint U * P * U} Utrans U\n                         {P}\n 2. \\<And>P Q R S1 S2.\n       \\<lbrakk>is_quantum_predicate P; is_quantum_predicate Q;\n        is_quantum_predicate R; \\<turnstile>\\<^sub>p {P} S1 {Q};\n        well_com S1 \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P} S1 {Q};\n        \\<turnstile>\\<^sub>p {Q} S2 {R};\n        well_com S2 \\<Longrightarrow> \\<Turnstile>\\<^sub>p {Q} S2 {R};\n        well_com (S1;; S2)\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P} S1;; S2 {R}\n 3. \\<And>n P Q S M.\n       \\<lbrakk>\\<And>k. k < n \\<Longrightarrow> is_quantum_predicate (P k);\n        is_quantum_predicate Q;\n        \\<And>k.\n           k < n \\<Longrightarrow> \\<turnstile>\\<^sub>p {P k} S ! k {Q};\n        \\<And>k.\n           \\<lbrakk>k < n; well_com (S ! k)\\<rbrakk>\n           \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P k} S ! k {Q};\n        well_com (Measure n M S)\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {matrix_sum d\n          (\\<lambda>k. adjoint (M k) * P k * M k) n}\n                         Measure n M S {Q}\n 4. \\<And>P Q S M.\n       \\<lbrakk>is_quantum_predicate P; is_quantum_predicate Q;\n        \\<turnstile>\\<^sub>p {Q} S\n                             {adjoint (M 0) * P * M 0 +\n                              adjoint (M 1) * Q * M 1};\n        well_com S \\<Longrightarrow>\n        \\<Turnstile>\\<^sub>p {Q} S\n        {adjoint (M 0) * P * M 0 + adjoint (M 1) * Q * M 1};\n        well_com (While M S)\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {adjoint (M 0) * P * M 0 +\n         adjoint (M 1) * Q * M 1}\n                         While M S {P}\n 5. \\<And>P Q P' Q' S.\n       \\<lbrakk>is_quantum_predicate P; is_quantum_predicate Q;\n        is_quantum_predicate P'; is_quantum_predicate Q';\n        P \\<le>\\<^sub>L P'; \\<turnstile>\\<^sub>p {P'} S {Q'};\n        well_com S \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P'} S {Q'};\n        Q' \\<le>\\<^sub>L Q; well_com S\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P} S {Q}", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>P U.\n       \\<lbrakk>is_quantum_predicate P; well_com (Utrans U)\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {adjoint U * P * U} Utrans U\n                         {P}\n 2. \\<And>P Q R S1 S2.\n       \\<lbrakk>is_quantum_predicate P; is_quantum_predicate Q;\n        is_quantum_predicate R; \\<turnstile>\\<^sub>p {P} S1 {Q};\n        well_com S1 \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P} S1 {Q};\n        \\<turnstile>\\<^sub>p {Q} S2 {R};\n        well_com S2 \\<Longrightarrow> \\<Turnstile>\\<^sub>p {Q} S2 {R};\n        well_com (S1;; S2)\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P} S1;; S2 {R}\n 3. \\<And>n P Q S M.\n       \\<lbrakk>\\<And>k. k < n \\<Longrightarrow> is_quantum_predicate (P k);\n        is_quantum_predicate Q;\n        \\<And>k.\n           k < n \\<Longrightarrow> \\<turnstile>\\<^sub>p {P k} S ! k {Q};\n        \\<And>k.\n           \\<lbrakk>k < n; well_com (S ! k)\\<rbrakk>\n           \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P k} S ! k {Q};\n        well_com (Measure n M S)\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {matrix_sum d\n          (\\<lambda>k. adjoint (M k) * P k * M k) n}\n                         Measure n M S {Q}\n 4. \\<And>P Q S M.\n       \\<lbrakk>is_quantum_predicate P; is_quantum_predicate Q;\n        \\<turnstile>\\<^sub>p {Q} S\n                             {adjoint (M 0) * P * M 0 +\n                              adjoint (M 1) * Q * M 1};\n        well_com S \\<Longrightarrow>\n        \\<Turnstile>\\<^sub>p {Q} S\n        {adjoint (M 0) * P * M 0 + adjoint (M 1) * Q * M 1};\n        well_com (While M S)\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {adjoint (M 0) * P * M 0 +\n         adjoint (M 1) * Q * M 1}\n                         While M S {P}\n 5. \\<And>P Q P' Q' S.\n       \\<lbrakk>is_quantum_predicate P; is_quantum_predicate Q;\n        is_quantum_predicate P'; is_quantum_predicate Q';\n        P \\<le>\\<^sub>L P'; \\<turnstile>\\<^sub>p {P'} S {Q'};\n        well_com S \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P'} S {Q'};\n        Q' \\<le>\\<^sub>L Q; well_com S\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P} S {Q}", "case (2 P U)"], ["proof (state)\nthis:\n  is_quantum_predicate P\n  well_com (Utrans U)\n\ngoal (5 subgoals):\n 1. \\<And>P U.\n       \\<lbrakk>is_quantum_predicate P; well_com (Utrans U)\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {adjoint U * P * U} Utrans U\n                         {P}\n 2. \\<And>P Q R S1 S2.\n       \\<lbrakk>is_quantum_predicate P; is_quantum_predicate Q;\n        is_quantum_predicate R; \\<turnstile>\\<^sub>p {P} S1 {Q};\n        well_com S1 \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P} S1 {Q};\n        \\<turnstile>\\<^sub>p {Q} S2 {R};\n        well_com S2 \\<Longrightarrow> \\<Turnstile>\\<^sub>p {Q} S2 {R};\n        well_com (S1;; S2)\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P} S1;; S2 {R}\n 3. \\<And>n P Q S M.\n       \\<lbrakk>\\<And>k. k < n \\<Longrightarrow> is_quantum_predicate (P k);\n        is_quantum_predicate Q;\n        \\<And>k.\n           k < n \\<Longrightarrow> \\<turnstile>\\<^sub>p {P k} S ! k {Q};\n        \\<And>k.\n           \\<lbrakk>k < n; well_com (S ! k)\\<rbrakk>\n           \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P k} S ! k {Q};\n        well_com (Measure n M S)\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {matrix_sum d\n          (\\<lambda>k. adjoint (M k) * P k * M k) n}\n                         Measure n M S {Q}\n 4. \\<And>P Q S M.\n       \\<lbrakk>is_quantum_predicate P; is_quantum_predicate Q;\n        \\<turnstile>\\<^sub>p {Q} S\n                             {adjoint (M 0) * P * M 0 +\n                              adjoint (M 1) * Q * M 1};\n        well_com S \\<Longrightarrow>\n        \\<Turnstile>\\<^sub>p {Q} S\n        {adjoint (M 0) * P * M 0 + adjoint (M 1) * Q * M 1};\n        well_com (While M S)\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {adjoint (M 0) * P * M 0 +\n         adjoint (M 1) * Q * M 1}\n                         While M S {P}\n 5. \\<And>P Q P' Q' S.\n       \\<lbrakk>is_quantum_predicate P; is_quantum_predicate Q;\n        is_quantum_predicate P'; is_quantum_predicate Q';\n        P \\<le>\\<^sub>L P'; \\<turnstile>\\<^sub>p {P'} S {Q'};\n        well_com S \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P'} S {Q'};\n        Q' \\<le>\\<^sub>L Q; well_com S\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P} S {Q}", "(*utrans*)"], ["proof (state)\nthis:\n  is_quantum_predicate P\n  well_com (Utrans U)\n\ngoal (5 subgoals):\n 1. \\<And>P U.\n       \\<lbrakk>is_quantum_predicate P; well_com (Utrans U)\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {adjoint U * P * U} Utrans U\n                         {P}\n 2. \\<And>P Q R S1 S2.\n       \\<lbrakk>is_quantum_predicate P; is_quantum_predicate Q;\n        is_quantum_predicate R; \\<turnstile>\\<^sub>p {P} S1 {Q};\n        well_com S1 \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P} S1 {Q};\n        \\<turnstile>\\<^sub>p {Q} S2 {R};\n        well_com S2 \\<Longrightarrow> \\<Turnstile>\\<^sub>p {Q} S2 {R};\n        well_com (S1;; S2)\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P} S1;; S2 {R}\n 3. \\<And>n P Q S M.\n       \\<lbrakk>\\<And>k. k < n \\<Longrightarrow> is_quantum_predicate (P k);\n        is_quantum_predicate Q;\n        \\<And>k.\n           k < n \\<Longrightarrow> \\<turnstile>\\<^sub>p {P k} S ! k {Q};\n        \\<And>k.\n           \\<lbrakk>k < n; well_com (S ! k)\\<rbrakk>\n           \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P k} S ! k {Q};\n        well_com (Measure n M S)\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {matrix_sum d\n          (\\<lambda>k. adjoint (M k) * P k * M k) n}\n                         Measure n M S {Q}\n 4. \\<And>P Q S M.\n       \\<lbrakk>is_quantum_predicate P; is_quantum_predicate Q;\n        \\<turnstile>\\<^sub>p {Q} S\n                             {adjoint (M 0) * P * M 0 +\n                              adjoint (M 1) * Q * M 1};\n        well_com S \\<Longrightarrow>\n        \\<Turnstile>\\<^sub>p {Q} S\n        {adjoint (M 0) * P * M 0 + adjoint (M 1) * Q * M 1};\n        well_com (While M S)\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {adjoint (M 0) * P * M 0 +\n         adjoint (M 1) * Q * M 1}\n                         While M S {P}\n 5. \\<And>P Q P' Q' S.\n       \\<lbrakk>is_quantum_predicate P; is_quantum_predicate Q;\n        is_quantum_predicate P'; is_quantum_predicate Q';\n        P \\<le>\\<^sub>L P'; \\<turnstile>\\<^sub>p {P'} S {Q'};\n        well_com S \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P'} S {Q'};\n        Q' \\<le>\\<^sub>L Q; well_com S\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P} S {Q}", "then"], ["proof (chain)\npicking this:\n  is_quantum_predicate P\n  well_com (Utrans U)", "have dU: \"U \\<in> carrier_mat d d\" and \"unitary U\" and dP: \"P \\<in> carrier_mat d d\""], ["proof (prove)\nusing this:\n  is_quantum_predicate P\n  well_com (Utrans U)\n\ngoal (1 subgoal):\n 1. U \\<in> carrier_mat d d &&& unitary U &&& P \\<in> carrier_mat d d", "using is_quantum_predicate_def"], ["proof (prove)\nusing this:\n  is_quantum_predicate P\n  well_com (Utrans U)\n  is_quantum_predicate ?P =\n  (?P \\<in> carrier_mat d d \\<and>\n   positive ?P \\<and> ?P \\<le>\\<^sub>L 1\\<^sub>m d)\n\ngoal (1 subgoal):\n 1. U \\<in> carrier_mat d d &&& unitary U &&& P \\<in> carrier_mat d d", "by auto"], ["proof (state)\nthis:\n  U \\<in> carrier_mat d d\n  unitary U\n  P \\<in> carrier_mat d d\n\ngoal (5 subgoals):\n 1. \\<And>P U.\n       \\<lbrakk>is_quantum_predicate P; well_com (Utrans U)\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {adjoint U * P * U} Utrans U\n                         {P}\n 2. \\<And>P Q R S1 S2.\n       \\<lbrakk>is_quantum_predicate P; is_quantum_predicate Q;\n        is_quantum_predicate R; \\<turnstile>\\<^sub>p {P} S1 {Q};\n        well_com S1 \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P} S1 {Q};\n        \\<turnstile>\\<^sub>p {Q} S2 {R};\n        well_com S2 \\<Longrightarrow> \\<Turnstile>\\<^sub>p {Q} S2 {R};\n        well_com (S1;; S2)\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P} S1;; S2 {R}\n 3. \\<And>n P Q S M.\n       \\<lbrakk>\\<And>k. k < n \\<Longrightarrow> is_quantum_predicate (P k);\n        is_quantum_predicate Q;\n        \\<And>k.\n           k < n \\<Longrightarrow> \\<turnstile>\\<^sub>p {P k} S ! k {Q};\n        \\<And>k.\n           \\<lbrakk>k < n; well_com (S ! k)\\<rbrakk>\n           \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P k} S ! k {Q};\n        well_com (Measure n M S)\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {matrix_sum d\n          (\\<lambda>k. adjoint (M k) * P k * M k) n}\n                         Measure n M S {Q}\n 4. \\<And>P Q S M.\n       \\<lbrakk>is_quantum_predicate P; is_quantum_predicate Q;\n        \\<turnstile>\\<^sub>p {Q} S\n                             {adjoint (M 0) * P * M 0 +\n                              adjoint (M 1) * Q * M 1};\n        well_com S \\<Longrightarrow>\n        \\<Turnstile>\\<^sub>p {Q} S\n        {adjoint (M 0) * P * M 0 + adjoint (M 1) * Q * M 1};\n        well_com (While M S)\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {adjoint (M 0) * P * M 0 +\n         adjoint (M 1) * Q * M 1}\n                         While M S {P}\n 5. \\<And>P Q P' Q' S.\n       \\<lbrakk>is_quantum_predicate P; is_quantum_predicate Q;\n        is_quantum_predicate P'; is_quantum_predicate Q';\n        P \\<le>\\<^sub>L P'; \\<turnstile>\\<^sub>p {P'} S {Q'};\n        well_com S \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P'} S {Q'};\n        Q' \\<le>\\<^sub>L Q; well_com S\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P} S {Q}", "then"], ["proof (chain)\npicking this:\n  U \\<in> carrier_mat d d\n  unitary U\n  P \\<in> carrier_mat d d", "have uU: \"adjoint U * U = 1\\<^sub>m d\""], ["proof (prove)\nusing this:\n  U \\<in> carrier_mat d d\n  unitary U\n  P \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. adjoint U * U = 1\\<^sub>m d", "using unitary_def"], ["proof (prove)\nusing this:\n  U \\<in> carrier_mat d d\n  unitary U\n  P \\<in> carrier_mat d d\n  unitary ?A =\n  (?A \\<in> carrier_mat (dim_row ?A) (dim_row ?A) \\<and>\n   inverts_mat ?A (adjoint ?A))\n\ngoal (1 subgoal):\n 1. adjoint U * U = 1\\<^sub>m d", "by auto"], ["proof (state)\nthis:\n  adjoint U * U = 1\\<^sub>m d\n\ngoal (5 subgoals):\n 1. \\<And>P U.\n       \\<lbrakk>is_quantum_predicate P; well_com (Utrans U)\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {adjoint U * P * U} Utrans U\n                         {P}\n 2. \\<And>P Q R S1 S2.\n       \\<lbrakk>is_quantum_predicate P; is_quantum_predicate Q;\n        is_quantum_predicate R; \\<turnstile>\\<^sub>p {P} S1 {Q};\n        well_com S1 \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P} S1 {Q};\n        \\<turnstile>\\<^sub>p {Q} S2 {R};\n        well_com S2 \\<Longrightarrow> \\<Turnstile>\\<^sub>p {Q} S2 {R};\n        well_com (S1;; S2)\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P} S1;; S2 {R}\n 3. \\<And>n P Q S M.\n       \\<lbrakk>\\<And>k. k < n \\<Longrightarrow> is_quantum_predicate (P k);\n        is_quantum_predicate Q;\n        \\<And>k.\n           k < n \\<Longrightarrow> \\<turnstile>\\<^sub>p {P k} S ! k {Q};\n        \\<And>k.\n           \\<lbrakk>k < n; well_com (S ! k)\\<rbrakk>\n           \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P k} S ! k {Q};\n        well_com (Measure n M S)\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {matrix_sum d\n          (\\<lambda>k. adjoint (M k) * P k * M k) n}\n                         Measure n M S {Q}\n 4. \\<And>P Q S M.\n       \\<lbrakk>is_quantum_predicate P; is_quantum_predicate Q;\n        \\<turnstile>\\<^sub>p {Q} S\n                             {adjoint (M 0) * P * M 0 +\n                              adjoint (M 1) * Q * M 1};\n        well_com S \\<Longrightarrow>\n        \\<Turnstile>\\<^sub>p {Q} S\n        {adjoint (M 0) * P * M 0 + adjoint (M 1) * Q * M 1};\n        well_com (While M S)\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {adjoint (M 0) * P * M 0 +\n         adjoint (M 1) * Q * M 1}\n                         While M S {P}\n 5. \\<And>P Q P' Q' S.\n       \\<lbrakk>is_quantum_predicate P; is_quantum_predicate Q;\n        is_quantum_predicate P'; is_quantum_predicate Q';\n        P \\<le>\\<^sub>L P'; \\<turnstile>\\<^sub>p {P'} S {Q'};\n        well_com S \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P'} S {Q'};\n        Q' \\<le>\\<^sub>L Q; well_com S\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P} S {Q}", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Turnstile>\\<^sub>p {adjoint U * P * U} Utrans U {P}", "unfolding hoare_partial_correct_def denote.simps(2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<rho>\\<in>density_states.\n       trace (adjoint U * P * U * \\<rho>)\n       \\<le> trace (P * (U * \\<rho> * adjoint U)) +\n             (trace \\<rho> - trace (U * \\<rho> * adjoint U))", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<rho>.\n       \\<rho> \\<in> density_states \\<Longrightarrow>\n       trace (adjoint U * P * U * \\<rho>)\n       \\<le> trace (P * (U * \\<rho> * adjoint U)) +\n             (trace \\<rho> - trace (U * \\<rho> * adjoint U))", "fix \\<rho>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<rho>.\n       \\<rho> \\<in> density_states \\<Longrightarrow>\n       trace (adjoint U * P * U * \\<rho>)\n       \\<le> trace (P * (U * \\<rho> * adjoint U)) +\n             (trace \\<rho> - trace (U * \\<rho> * adjoint U))", "assume \"\\<rho> \\<in> density_states\""], ["proof (state)\nthis:\n  \\<rho> \\<in> density_states\n\ngoal (1 subgoal):\n 1. \\<And>\\<rho>.\n       \\<rho> \\<in> density_states \\<Longrightarrow>\n       trace (adjoint U * P * U * \\<rho>)\n       \\<le> trace (P * (U * \\<rho> * adjoint U)) +\n             (trace \\<rho> - trace (U * \\<rho> * adjoint U))", "then"], ["proof (chain)\npicking this:\n  \\<rho> \\<in> density_states", "have dr: \"\\<rho> \\<in> carrier_mat d d\""], ["proof (prove)\nusing this:\n  \\<rho> \\<in> density_states\n\ngoal (1 subgoal):\n 1. \\<rho> \\<in> carrier_mat d d", "using density_states_def"], ["proof (prove)\nusing this:\n  \\<rho> \\<in> density_states\n  density_states =\n  {\\<rho> \\<in> carrier_mat d d. partial_density_operator \\<rho>}\n\ngoal (1 subgoal):\n 1. \\<rho> \\<in> carrier_mat d d", "by auto"], ["proof (state)\nthis:\n  \\<rho> \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. \\<And>\\<rho>.\n       \\<rho> \\<in> density_states \\<Longrightarrow>\n       trace (adjoint U * P * U * \\<rho>)\n       \\<le> trace (P * (U * \\<rho> * adjoint U)) +\n             (trace \\<rho> - trace (U * \\<rho> * adjoint U))", "have e1: \"trace (U * \\<rho> * adjoint U) = trace ((adjoint U * U) * \\<rho>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace (U * \\<rho> * adjoint U) = trace (adjoint U * U * \\<rho>)", "using dr dU"], ["proof (prove)\nusing this:\n  \\<rho> \\<in> carrier_mat d d\n  U \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. trace (U * \\<rho> * adjoint U) = trace (adjoint U * U * \\<rho>)", "by (mat_assoc d)"], ["proof (state)\nthis:\n  trace (U * \\<rho> * adjoint U) = trace (adjoint U * U * \\<rho>)\n\ngoal (1 subgoal):\n 1. \\<And>\\<rho>.\n       \\<rho> \\<in> density_states \\<Longrightarrow>\n       trace (adjoint U * P * U * \\<rho>)\n       \\<le> trace (P * (U * \\<rho> * adjoint U)) +\n             (trace \\<rho> - trace (U * \\<rho> * adjoint U))", "also"], ["proof (state)\nthis:\n  trace (U * \\<rho> * adjoint U) = trace (adjoint U * U * \\<rho>)\n\ngoal (1 subgoal):\n 1. \\<And>\\<rho>.\n       \\<rho> \\<in> density_states \\<Longrightarrow>\n       trace (adjoint U * P * U * \\<rho>)\n       \\<le> trace (P * (U * \\<rho> * adjoint U)) +\n             (trace \\<rho> - trace (U * \\<rho> * adjoint U))", "have \"\\<dots> = trace \\<rho>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace (adjoint U * U * \\<rho>) = trace \\<rho>", "using uU dr"], ["proof (prove)\nusing this:\n  adjoint U * U = 1\\<^sub>m d\n  \\<rho> \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. trace (adjoint U * U * \\<rho>) = trace \\<rho>", "by auto"], ["proof (state)\nthis:\n  trace (adjoint U * U * \\<rho>) = trace \\<rho>\n\ngoal (1 subgoal):\n 1. \\<And>\\<rho>.\n       \\<rho> \\<in> density_states \\<Longrightarrow>\n       trace (adjoint U * P * U * \\<rho>)\n       \\<le> trace (P * (U * \\<rho> * adjoint U)) +\n             (trace \\<rho> - trace (U * \\<rho> * adjoint U))", "finally"], ["proof (chain)\npicking this:\n  trace (U * \\<rho> * adjoint U) = trace \\<rho>", "have e1: \"trace (U * \\<rho> * adjoint U) = trace \\<rho>\""], ["proof (prove)\nusing this:\n  trace (U * \\<rho> * adjoint U) = trace \\<rho>\n\ngoal (1 subgoal):\n 1. trace (U * \\<rho> * adjoint U) = trace \\<rho>", "."], ["proof (state)\nthis:\n  trace (U * \\<rho> * adjoint U) = trace \\<rho>\n\ngoal (1 subgoal):\n 1. \\<And>\\<rho>.\n       \\<rho> \\<in> density_states \\<Longrightarrow>\n       trace (adjoint U * P * U * \\<rho>)\n       \\<le> trace (P * (U * \\<rho> * adjoint U)) +\n             (trace \\<rho> - trace (U * \\<rho> * adjoint U))", "have e2: \"trace (P * (U * \\<rho> * adjoint U)) = trace (adjoint U * P * U * \\<rho>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace (P * (U * \\<rho> * adjoint U)) =\n    trace (adjoint U * P * U * \\<rho>)", "using dU dP dr"], ["proof (prove)\nusing this:\n  U \\<in> carrier_mat d d\n  P \\<in> carrier_mat d d\n  \\<rho> \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. trace (P * (U * \\<rho> * adjoint U)) =\n    trace (adjoint U * P * U * \\<rho>)", "by (mat_assoc d)"], ["proof (state)\nthis:\n  trace (P * (U * \\<rho> * adjoint U)) = trace (adjoint U * P * U * \\<rho>)\n\ngoal (1 subgoal):\n 1. \\<And>\\<rho>.\n       \\<rho> \\<in> density_states \\<Longrightarrow>\n       trace (adjoint U * P * U * \\<rho>)\n       \\<le> trace (P * (U * \\<rho> * adjoint U)) +\n             (trace \\<rho> - trace (U * \\<rho> * adjoint U))", "with e1"], ["proof (chain)\npicking this:\n  trace (U * \\<rho> * adjoint U) = trace \\<rho>\n  trace (P * (U * \\<rho> * adjoint U)) = trace (adjoint U * P * U * \\<rho>)", "have \"trace (P * (U * \\<rho> * adjoint U)) + (trace \\<rho> - trace (U * \\<rho> * adjoint U)) = trace (adjoint U * P * U * \\<rho>)\""], ["proof (prove)\nusing this:\n  trace (U * \\<rho> * adjoint U) = trace \\<rho>\n  trace (P * (U * \\<rho> * adjoint U)) = trace (adjoint U * P * U * \\<rho>)\n\ngoal (1 subgoal):\n 1. trace (P * (U * \\<rho> * adjoint U)) +\n    (trace \\<rho> - trace (U * \\<rho> * adjoint U)) =\n    trace (adjoint U * P * U * \\<rho>)", "using e1"], ["proof (prove)\nusing this:\n  trace (U * \\<rho> * adjoint U) = trace \\<rho>\n  trace (P * (U * \\<rho> * adjoint U)) = trace (adjoint U * P * U * \\<rho>)\n  trace (U * \\<rho> * adjoint U) = trace \\<rho>\n\ngoal (1 subgoal):\n 1. trace (P * (U * \\<rho> * adjoint U)) +\n    (trace \\<rho> - trace (U * \\<rho> * adjoint U)) =\n    trace (adjoint U * P * U * \\<rho>)", "by auto"], ["proof (state)\nthis:\n  trace (P * (U * \\<rho> * adjoint U)) +\n  (trace \\<rho> - trace (U * \\<rho> * adjoint U)) =\n  trace (adjoint U * P * U * \\<rho>)\n\ngoal (1 subgoal):\n 1. \\<And>\\<rho>.\n       \\<rho> \\<in> density_states \\<Longrightarrow>\n       trace (adjoint U * P * U * \\<rho>)\n       \\<le> trace (P * (U * \\<rho> * adjoint U)) +\n             (trace \\<rho> - trace (U * \\<rho> * adjoint U))", "then"], ["proof (chain)\npicking this:\n  trace (P * (U * \\<rho> * adjoint U)) +\n  (trace \\<rho> - trace (U * \\<rho> * adjoint U)) =\n  trace (adjoint U * P * U * \\<rho>)", "show \"trace (adjoint U * P * U * \\<rho>) \\<le> trace (P * (U * \\<rho> * adjoint U)) + (trace \\<rho> - trace (U * \\<rho> * adjoint U))\""], ["proof (prove)\nusing this:\n  trace (P * (U * \\<rho> * adjoint U)) +\n  (trace \\<rho> - trace (U * \\<rho> * adjoint U)) =\n  trace (adjoint U * P * U * \\<rho>)\n\ngoal (1 subgoal):\n 1. trace (adjoint U * P * U * \\<rho>)\n    \\<le> trace (P * (U * \\<rho> * adjoint U)) +\n          (trace \\<rho> - trace (U * \\<rho> * adjoint U))", "by auto"], ["proof (state)\nthis:\n  trace (adjoint U * P * U * \\<rho>)\n  \\<le> trace (P * (U * \\<rho> * adjoint U)) +\n        (trace \\<rho> - trace (U * \\<rho> * adjoint U))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<Turnstile>\\<^sub>p {adjoint U * P * U} Utrans U {P}\n\ngoal (4 subgoals):\n 1. \\<And>P Q R S1 S2.\n       \\<lbrakk>is_quantum_predicate P; is_quantum_predicate Q;\n        is_quantum_predicate R; \\<turnstile>\\<^sub>p {P} S1 {Q};\n        well_com S1 \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P} S1 {Q};\n        \\<turnstile>\\<^sub>p {Q} S2 {R};\n        well_com S2 \\<Longrightarrow> \\<Turnstile>\\<^sub>p {Q} S2 {R};\n        well_com (S1;; S2)\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P} S1;; S2 {R}\n 2. \\<And>n P Q S M.\n       \\<lbrakk>\\<And>k. k < n \\<Longrightarrow> is_quantum_predicate (P k);\n        is_quantum_predicate Q;\n        \\<And>k.\n           k < n \\<Longrightarrow> \\<turnstile>\\<^sub>p {P k} S ! k {Q};\n        \\<And>k.\n           \\<lbrakk>k < n; well_com (S ! k)\\<rbrakk>\n           \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P k} S ! k {Q};\n        well_com (Measure n M S)\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {matrix_sum d\n          (\\<lambda>k. adjoint (M k) * P k * M k) n}\n                         Measure n M S {Q}\n 3. \\<And>P Q S M.\n       \\<lbrakk>is_quantum_predicate P; is_quantum_predicate Q;\n        \\<turnstile>\\<^sub>p {Q} S\n                             {adjoint (M 0) * P * M 0 +\n                              adjoint (M 1) * Q * M 1};\n        well_com S \\<Longrightarrow>\n        \\<Turnstile>\\<^sub>p {Q} S\n        {adjoint (M 0) * P * M 0 + adjoint (M 1) * Q * M 1};\n        well_com (While M S)\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {adjoint (M 0) * P * M 0 +\n         adjoint (M 1) * Q * M 1}\n                         While M S {P}\n 4. \\<And>P Q P' Q' S.\n       \\<lbrakk>is_quantum_predicate P; is_quantum_predicate Q;\n        is_quantum_predicate P'; is_quantum_predicate Q';\n        P \\<le>\\<^sub>L P'; \\<turnstile>\\<^sub>p {P'} S {Q'};\n        well_com S \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P'} S {Q'};\n        Q' \\<le>\\<^sub>L Q; well_com S\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P} S {Q}", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>P Q R S1 S2.\n       \\<lbrakk>is_quantum_predicate P; is_quantum_predicate Q;\n        is_quantum_predicate R; \\<turnstile>\\<^sub>p {P} S1 {Q};\n        well_com S1 \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P} S1 {Q};\n        \\<turnstile>\\<^sub>p {Q} S2 {R};\n        well_com S2 \\<Longrightarrow> \\<Turnstile>\\<^sub>p {Q} S2 {R};\n        well_com (S1;; S2)\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P} S1;; S2 {R}\n 2. \\<And>n P Q S M.\n       \\<lbrakk>\\<And>k. k < n \\<Longrightarrow> is_quantum_predicate (P k);\n        is_quantum_predicate Q;\n        \\<And>k.\n           k < n \\<Longrightarrow> \\<turnstile>\\<^sub>p {P k} S ! k {Q};\n        \\<And>k.\n           \\<lbrakk>k < n; well_com (S ! k)\\<rbrakk>\n           \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P k} S ! k {Q};\n        well_com (Measure n M S)\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {matrix_sum d\n          (\\<lambda>k. adjoint (M k) * P k * M k) n}\n                         Measure n M S {Q}\n 3. \\<And>P Q S M.\n       \\<lbrakk>is_quantum_predicate P; is_quantum_predicate Q;\n        \\<turnstile>\\<^sub>p {Q} S\n                             {adjoint (M 0) * P * M 0 +\n                              adjoint (M 1) * Q * M 1};\n        well_com S \\<Longrightarrow>\n        \\<Turnstile>\\<^sub>p {Q} S\n        {adjoint (M 0) * P * M 0 + adjoint (M 1) * Q * M 1};\n        well_com (While M S)\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {adjoint (M 0) * P * M 0 +\n         adjoint (M 1) * Q * M 1}\n                         While M S {P}\n 4. \\<And>P Q P' Q' S.\n       \\<lbrakk>is_quantum_predicate P; is_quantum_predicate Q;\n        is_quantum_predicate P'; is_quantum_predicate Q';\n        P \\<le>\\<^sub>L P'; \\<turnstile>\\<^sub>p {P'} S {Q'};\n        well_com S \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P'} S {Q'};\n        Q' \\<le>\\<^sub>L Q; well_com S\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P} S {Q}", "case (3 P Q R S1 S2)"], ["proof (state)\nthis:\n  is_quantum_predicate P\n  is_quantum_predicate Q\n  is_quantum_predicate R\n  \\<turnstile>\\<^sub>p {P} S1 {Q}\n  \\<turnstile>\\<^sub>p {Q} S2 {R}\n  well_com S1 \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P} S1 {Q}\n  well_com S2 \\<Longrightarrow> \\<Turnstile>\\<^sub>p {Q} S2 {R}\n  well_com (S1;; S2)\n\ngoal (4 subgoals):\n 1. \\<And>P Q R S1 S2.\n       \\<lbrakk>is_quantum_predicate P; is_quantum_predicate Q;\n        is_quantum_predicate R; \\<turnstile>\\<^sub>p {P} S1 {Q};\n        well_com S1 \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P} S1 {Q};\n        \\<turnstile>\\<^sub>p {Q} S2 {R};\n        well_com S2 \\<Longrightarrow> \\<Turnstile>\\<^sub>p {Q} S2 {R};\n        well_com (S1;; S2)\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P} S1;; S2 {R}\n 2. \\<And>n P Q S M.\n       \\<lbrakk>\\<And>k. k < n \\<Longrightarrow> is_quantum_predicate (P k);\n        is_quantum_predicate Q;\n        \\<And>k.\n           k < n \\<Longrightarrow> \\<turnstile>\\<^sub>p {P k} S ! k {Q};\n        \\<And>k.\n           \\<lbrakk>k < n; well_com (S ! k)\\<rbrakk>\n           \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P k} S ! k {Q};\n        well_com (Measure n M S)\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {matrix_sum d\n          (\\<lambda>k. adjoint (M k) * P k * M k) n}\n                         Measure n M S {Q}\n 3. \\<And>P Q S M.\n       \\<lbrakk>is_quantum_predicate P; is_quantum_predicate Q;\n        \\<turnstile>\\<^sub>p {Q} S\n                             {adjoint (M 0) * P * M 0 +\n                              adjoint (M 1) * Q * M 1};\n        well_com S \\<Longrightarrow>\n        \\<Turnstile>\\<^sub>p {Q} S\n        {adjoint (M 0) * P * M 0 + adjoint (M 1) * Q * M 1};\n        well_com (While M S)\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {adjoint (M 0) * P * M 0 +\n         adjoint (M 1) * Q * M 1}\n                         While M S {P}\n 4. \\<And>P Q P' Q' S.\n       \\<lbrakk>is_quantum_predicate P; is_quantum_predicate Q;\n        is_quantum_predicate P'; is_quantum_predicate Q';\n        P \\<le>\\<^sub>L P'; \\<turnstile>\\<^sub>p {P'} S {Q'};\n        well_com S \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P'} S {Q'};\n        Q' \\<le>\\<^sub>L Q; well_com S\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P} S {Q}", "(*seq*)"], ["proof (state)\nthis:\n  is_quantum_predicate P\n  is_quantum_predicate Q\n  is_quantum_predicate R\n  \\<turnstile>\\<^sub>p {P} S1 {Q}\n  \\<turnstile>\\<^sub>p {Q} S2 {R}\n  well_com S1 \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P} S1 {Q}\n  well_com S2 \\<Longrightarrow> \\<Turnstile>\\<^sub>p {Q} S2 {R}\n  well_com (S1;; S2)\n\ngoal (4 subgoals):\n 1. \\<And>P Q R S1 S2.\n       \\<lbrakk>is_quantum_predicate P; is_quantum_predicate Q;\n        is_quantum_predicate R; \\<turnstile>\\<^sub>p {P} S1 {Q};\n        well_com S1 \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P} S1 {Q};\n        \\<turnstile>\\<^sub>p {Q} S2 {R};\n        well_com S2 \\<Longrightarrow> \\<Turnstile>\\<^sub>p {Q} S2 {R};\n        well_com (S1;; S2)\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P} S1;; S2 {R}\n 2. \\<And>n P Q S M.\n       \\<lbrakk>\\<And>k. k < n \\<Longrightarrow> is_quantum_predicate (P k);\n        is_quantum_predicate Q;\n        \\<And>k.\n           k < n \\<Longrightarrow> \\<turnstile>\\<^sub>p {P k} S ! k {Q};\n        \\<And>k.\n           \\<lbrakk>k < n; well_com (S ! k)\\<rbrakk>\n           \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P k} S ! k {Q};\n        well_com (Measure n M S)\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {matrix_sum d\n          (\\<lambda>k. adjoint (M k) * P k * M k) n}\n                         Measure n M S {Q}\n 3. \\<And>P Q S M.\n       \\<lbrakk>is_quantum_predicate P; is_quantum_predicate Q;\n        \\<turnstile>\\<^sub>p {Q} S\n                             {adjoint (M 0) * P * M 0 +\n                              adjoint (M 1) * Q * M 1};\n        well_com S \\<Longrightarrow>\n        \\<Turnstile>\\<^sub>p {Q} S\n        {adjoint (M 0) * P * M 0 + adjoint (M 1) * Q * M 1};\n        well_com (While M S)\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {adjoint (M 0) * P * M 0 +\n         adjoint (M 1) * Q * M 1}\n                         While M S {P}\n 4. \\<And>P Q P' Q' S.\n       \\<lbrakk>is_quantum_predicate P; is_quantum_predicate Q;\n        is_quantum_predicate P'; is_quantum_predicate Q';\n        P \\<le>\\<^sub>L P'; \\<turnstile>\\<^sub>p {P'} S {Q'};\n        well_com S \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P'} S {Q'};\n        Q' \\<le>\\<^sub>L Q; well_com S\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P} S {Q}", "then"], ["proof (chain)\npicking this:\n  is_quantum_predicate P\n  is_quantum_predicate Q\n  is_quantum_predicate R\n  \\<turnstile>\\<^sub>p {P} S1 {Q}\n  \\<turnstile>\\<^sub>p {Q} S2 {R}\n  well_com S1 \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P} S1 {Q}\n  well_com S2 \\<Longrightarrow> \\<Turnstile>\\<^sub>p {Q} S2 {R}\n  well_com (S1;; S2)", "have wc1: \"\\<Turnstile>\\<^sub>p {P} S1 {Q}\" and wc2: \"\\<Turnstile>\\<^sub>p {Q} S2 {R}\""], ["proof (prove)\nusing this:\n  is_quantum_predicate P\n  is_quantum_predicate Q\n  is_quantum_predicate R\n  \\<turnstile>\\<^sub>p {P} S1 {Q}\n  \\<turnstile>\\<^sub>p {Q} S2 {R}\n  well_com S1 \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P} S1 {Q}\n  well_com S2 \\<Longrightarrow> \\<Turnstile>\\<^sub>p {Q} S2 {R}\n  well_com (S1;; S2)\n\ngoal (1 subgoal):\n 1. \\<Turnstile>\\<^sub>p {P} S1 {Q} &&& \\<Turnstile>\\<^sub>p {Q} S2 {R}", "by auto"], ["proof (state)\nthis:\n  \\<Turnstile>\\<^sub>p {P} S1 {Q}\n  \\<Turnstile>\\<^sub>p {Q} S2 {R}\n\ngoal (4 subgoals):\n 1. \\<And>P Q R S1 S2.\n       \\<lbrakk>is_quantum_predicate P; is_quantum_predicate Q;\n        is_quantum_predicate R; \\<turnstile>\\<^sub>p {P} S1 {Q};\n        well_com S1 \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P} S1 {Q};\n        \\<turnstile>\\<^sub>p {Q} S2 {R};\n        well_com S2 \\<Longrightarrow> \\<Turnstile>\\<^sub>p {Q} S2 {R};\n        well_com (S1;; S2)\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P} S1;; S2 {R}\n 2. \\<And>n P Q S M.\n       \\<lbrakk>\\<And>k. k < n \\<Longrightarrow> is_quantum_predicate (P k);\n        is_quantum_predicate Q;\n        \\<And>k.\n           k < n \\<Longrightarrow> \\<turnstile>\\<^sub>p {P k} S ! k {Q};\n        \\<And>k.\n           \\<lbrakk>k < n; well_com (S ! k)\\<rbrakk>\n           \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P k} S ! k {Q};\n        well_com (Measure n M S)\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {matrix_sum d\n          (\\<lambda>k. adjoint (M k) * P k * M k) n}\n                         Measure n M S {Q}\n 3. \\<And>P Q S M.\n       \\<lbrakk>is_quantum_predicate P; is_quantum_predicate Q;\n        \\<turnstile>\\<^sub>p {Q} S\n                             {adjoint (M 0) * P * M 0 +\n                              adjoint (M 1) * Q * M 1};\n        well_com S \\<Longrightarrow>\n        \\<Turnstile>\\<^sub>p {Q} S\n        {adjoint (M 0) * P * M 0 + adjoint (M 1) * Q * M 1};\n        well_com (While M S)\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {adjoint (M 0) * P * M 0 +\n         adjoint (M 1) * Q * M 1}\n                         While M S {P}\n 4. \\<And>P Q P' Q' S.\n       \\<lbrakk>is_quantum_predicate P; is_quantum_predicate Q;\n        is_quantum_predicate P'; is_quantum_predicate Q';\n        P \\<le>\\<^sub>L P'; \\<turnstile>\\<^sub>p {P'} S {Q'};\n        well_com S \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P'} S {Q'};\n        Q' \\<le>\\<^sub>L Q; well_com S\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P} S {Q}", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Turnstile>\\<^sub>p {P} S1;; S2 {R}", "unfolding hoare_partial_correct_def denote.simps(3)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<rho>\\<in>density_states.\n       trace (P * \\<rho>)\n       \\<le> trace (R * denote S2 (denote S1 \\<rho>)) +\n             (trace \\<rho> - trace (denote S2 (denote S1 \\<rho>)))", "proof clarify"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<rho>.\n       \\<rho> \\<in> density_states \\<Longrightarrow>\n       trace (P * \\<rho>)\n       \\<le> trace (R * denote S2 (denote S1 \\<rho>)) +\n             (trace \\<rho> - trace (denote S2 (denote S1 \\<rho>)))", "fix \\<rho>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<rho>.\n       \\<rho> \\<in> density_states \\<Longrightarrow>\n       trace (P * \\<rho>)\n       \\<le> trace (R * denote S2 (denote S1 \\<rho>)) +\n             (trace \\<rho> - trace (denote S2 (denote S1 \\<rho>)))", "assume \\<rho>: \"\\<rho> \\<in> density_states\""], ["proof (state)\nthis:\n  \\<rho> \\<in> density_states\n\ngoal (1 subgoal):\n 1. \\<And>\\<rho>.\n       \\<rho> \\<in> density_states \\<Longrightarrow>\n       trace (P * \\<rho>)\n       \\<le> trace (R * denote S2 (denote S1 \\<rho>)) +\n             (trace \\<rho> - trace (denote S2 (denote S1 \\<rho>)))", "have 1: \"trace (P * \\<rho>) \\<le> trace (Q * denote S1 \\<rho>) + (trace \\<rho> - trace (denote S1 \\<rho>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace (P * \\<rho>)\n    \\<le> trace (Q * denote S1 \\<rho>) +\n          (trace \\<rho> - trace (denote S1 \\<rho>))", "using wc1 hoare_partial_correct_def \\<rho>"], ["proof (prove)\nusing this:\n  \\<Turnstile>\\<^sub>p {P} S1 {Q}\n  (\\<Turnstile>\\<^sub>p {?P} ?S {?Q}) =\n  (\\<forall>\\<rho>\\<in>density_states.\n      trace (?P * \\<rho>)\n      \\<le> trace (?Q * denote ?S \\<rho>) +\n            (trace \\<rho> - trace (denote ?S \\<rho>)))\n  \\<rho> \\<in> density_states\n\ngoal (1 subgoal):\n 1. trace (P * \\<rho>)\n    \\<le> trace (Q * denote S1 \\<rho>) +\n          (trace \\<rho> - trace (denote S1 \\<rho>))", "by auto"], ["proof (state)\nthis:\n  trace (P * \\<rho>)\n  \\<le> trace (Q * denote S1 \\<rho>) +\n        (trace \\<rho> - trace (denote S1 \\<rho>))\n\ngoal (1 subgoal):\n 1. \\<And>\\<rho>.\n       \\<rho> \\<in> density_states \\<Longrightarrow>\n       trace (P * \\<rho>)\n       \\<le> trace (R * denote S2 (denote S1 \\<rho>)) +\n             (trace \\<rho> - trace (denote S2 (denote S1 \\<rho>)))", "have \\<rho>': \"denote S1 \\<rho> \\<in> density_states\""], ["proof (prove)\ngoal (1 subgoal):\n 1. denote S1 \\<rho> \\<in> density_states", "using 3(8) denote_density_states \\<rho>"], ["proof (prove)\nusing this:\n  well_com (S1;; S2)\n  \\<lbrakk>?\\<rho> \\<in> density_states; well_com ?S\\<rbrakk>\n  \\<Longrightarrow> denote ?S ?\\<rho> \\<in> density_states\n  \\<rho> \\<in> density_states\n\ngoal (1 subgoal):\n 1. denote S1 \\<rho> \\<in> density_states", "by auto"], ["proof (state)\nthis:\n  denote S1 \\<rho> \\<in> density_states\n\ngoal (1 subgoal):\n 1. \\<And>\\<rho>.\n       \\<rho> \\<in> density_states \\<Longrightarrow>\n       trace (P * \\<rho>)\n       \\<le> trace (R * denote S2 (denote S1 \\<rho>)) +\n             (trace \\<rho> - trace (denote S2 (denote S1 \\<rho>)))", "have 2: \"trace (Q * denote S1 \\<rho>) \\<le> trace (R * denote S2 (denote S1 \\<rho>)) + (trace (denote S1 \\<rho>) - trace (denote S2 (denote S1 \\<rho>)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace (Q * denote S1 \\<rho>)\n    \\<le> trace (R * denote S2 (denote S1 \\<rho>)) +\n          (trace (denote S1 \\<rho>) - trace (denote S2 (denote S1 \\<rho>)))", "using wc2 hoare_partial_correct_def \\<rho>'"], ["proof (prove)\nusing this:\n  \\<Turnstile>\\<^sub>p {Q} S2 {R}\n  (\\<Turnstile>\\<^sub>p {?P} ?S {?Q}) =\n  (\\<forall>\\<rho>\\<in>density_states.\n      trace (?P * \\<rho>)\n      \\<le> trace (?Q * denote ?S \\<rho>) +\n            (trace \\<rho> - trace (denote ?S \\<rho>)))\n  denote S1 \\<rho> \\<in> density_states\n\ngoal (1 subgoal):\n 1. trace (Q * denote S1 \\<rho>)\n    \\<le> trace (R * denote S2 (denote S1 \\<rho>)) +\n          (trace (denote S1 \\<rho>) - trace (denote S2 (denote S1 \\<rho>)))", "by auto"], ["proof (state)\nthis:\n  trace (Q * denote S1 \\<rho>)\n  \\<le> trace (R * denote S2 (denote S1 \\<rho>)) +\n        (trace (denote S1 \\<rho>) - trace (denote S2 (denote S1 \\<rho>)))\n\ngoal (1 subgoal):\n 1. \\<And>\\<rho>.\n       \\<rho> \\<in> density_states \\<Longrightarrow>\n       trace (P * \\<rho>)\n       \\<le> trace (R * denote S2 (denote S1 \\<rho>)) +\n             (trace \\<rho> - trace (denote S2 (denote S1 \\<rho>)))", "show \"trace (P * \\<rho>) \\<le> trace (R * denote S2 (denote S1 \\<rho>)) + (trace \\<rho> - trace (denote S2 (denote S1 \\<rho>)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace (P * \\<rho>)\n    \\<le> trace (R * denote S2 (denote S1 \\<rho>)) +\n          (trace \\<rho> - trace (denote S2 (denote S1 \\<rho>)))", "using 1 2"], ["proof (prove)\nusing this:\n  trace (P * \\<rho>)\n  \\<le> trace (Q * denote S1 \\<rho>) +\n        (trace \\<rho> - trace (denote S1 \\<rho>))\n  trace (Q * denote S1 \\<rho>)\n  \\<le> trace (R * denote S2 (denote S1 \\<rho>)) +\n        (trace (denote S1 \\<rho>) - trace (denote S2 (denote S1 \\<rho>)))\n\ngoal (1 subgoal):\n 1. trace (P * \\<rho>)\n    \\<le> trace (R * denote S2 (denote S1 \\<rho>)) +\n          (trace \\<rho> - trace (denote S2 (denote S1 \\<rho>)))", "by auto"], ["proof (state)\nthis:\n  trace (P * \\<rho>)\n  \\<le> trace (R * denote S2 (denote S1 \\<rho>)) +\n        (trace \\<rho> - trace (denote S2 (denote S1 \\<rho>)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<Turnstile>\\<^sub>p {P} S1;; S2 {R}\n\ngoal (3 subgoals):\n 1. \\<And>n P Q S M.\n       \\<lbrakk>\\<And>k. k < n \\<Longrightarrow> is_quantum_predicate (P k);\n        is_quantum_predicate Q;\n        \\<And>k.\n           k < n \\<Longrightarrow> \\<turnstile>\\<^sub>p {P k} S ! k {Q};\n        \\<And>k.\n           \\<lbrakk>k < n; well_com (S ! k)\\<rbrakk>\n           \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P k} S ! k {Q};\n        well_com (Measure n M S)\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {matrix_sum d\n          (\\<lambda>k. adjoint (M k) * P k * M k) n}\n                         Measure n M S {Q}\n 2. \\<And>P Q S M.\n       \\<lbrakk>is_quantum_predicate P; is_quantum_predicate Q;\n        \\<turnstile>\\<^sub>p {Q} S\n                             {adjoint (M 0) * P * M 0 +\n                              adjoint (M 1) * Q * M 1};\n        well_com S \\<Longrightarrow>\n        \\<Turnstile>\\<^sub>p {Q} S\n        {adjoint (M 0) * P * M 0 + adjoint (M 1) * Q * M 1};\n        well_com (While M S)\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {adjoint (M 0) * P * M 0 +\n         adjoint (M 1) * Q * M 1}\n                         While M S {P}\n 3. \\<And>P Q P' Q' S.\n       \\<lbrakk>is_quantum_predicate P; is_quantum_predicate Q;\n        is_quantum_predicate P'; is_quantum_predicate Q';\n        P \\<le>\\<^sub>L P'; \\<turnstile>\\<^sub>p {P'} S {Q'};\n        well_com S \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P'} S {Q'};\n        Q' \\<le>\\<^sub>L Q; well_com S\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P} S {Q}", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>n P Q S M.\n       \\<lbrakk>\\<And>k. k < n \\<Longrightarrow> is_quantum_predicate (P k);\n        is_quantum_predicate Q;\n        \\<And>k.\n           k < n \\<Longrightarrow> \\<turnstile>\\<^sub>p {P k} S ! k {Q};\n        \\<And>k.\n           \\<lbrakk>k < n; well_com (S ! k)\\<rbrakk>\n           \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P k} S ! k {Q};\n        well_com (Measure n M S)\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {matrix_sum d\n          (\\<lambda>k. adjoint (M k) * P k * M k) n}\n                         Measure n M S {Q}\n 2. \\<And>P Q S M.\n       \\<lbrakk>is_quantum_predicate P; is_quantum_predicate Q;\n        \\<turnstile>\\<^sub>p {Q} S\n                             {adjoint (M 0) * P * M 0 +\n                              adjoint (M 1) * Q * M 1};\n        well_com S \\<Longrightarrow>\n        \\<Turnstile>\\<^sub>p {Q} S\n        {adjoint (M 0) * P * M 0 + adjoint (M 1) * Q * M 1};\n        well_com (While M S)\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {adjoint (M 0) * P * M 0 +\n         adjoint (M 1) * Q * M 1}\n                         While M S {P}\n 3. \\<And>P Q P' Q' S.\n       \\<lbrakk>is_quantum_predicate P; is_quantum_predicate Q;\n        is_quantum_predicate P'; is_quantum_predicate Q';\n        P \\<le>\\<^sub>L P'; \\<turnstile>\\<^sub>p {P'} S {Q'};\n        well_com S \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P'} S {Q'};\n        Q' \\<le>\\<^sub>L Q; well_com S\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P} S {Q}", "case (4 n P Q S M)"], ["proof (state)\nthis:\n  ?k < n \\<Longrightarrow> is_quantum_predicate (P ?k)\n  is_quantum_predicate Q\n  ?k < n \\<Longrightarrow> \\<turnstile>\\<^sub>p {P ?k} S ! ?k {Q}\n  \\<lbrakk>?k < n; well_com (S ! ?k)\\<rbrakk>\n  \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P ?k} S ! ?k {Q}\n  well_com (Measure n M S)\n\ngoal (3 subgoals):\n 1. \\<And>n P Q S M.\n       \\<lbrakk>\\<And>k. k < n \\<Longrightarrow> is_quantum_predicate (P k);\n        is_quantum_predicate Q;\n        \\<And>k.\n           k < n \\<Longrightarrow> \\<turnstile>\\<^sub>p {P k} S ! k {Q};\n        \\<And>k.\n           \\<lbrakk>k < n; well_com (S ! k)\\<rbrakk>\n           \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P k} S ! k {Q};\n        well_com (Measure n M S)\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {matrix_sum d\n          (\\<lambda>k. adjoint (M k) * P k * M k) n}\n                         Measure n M S {Q}\n 2. \\<And>P Q S M.\n       \\<lbrakk>is_quantum_predicate P; is_quantum_predicate Q;\n        \\<turnstile>\\<^sub>p {Q} S\n                             {adjoint (M 0) * P * M 0 +\n                              adjoint (M 1) * Q * M 1};\n        well_com S \\<Longrightarrow>\n        \\<Turnstile>\\<^sub>p {Q} S\n        {adjoint (M 0) * P * M 0 + adjoint (M 1) * Q * M 1};\n        well_com (While M S)\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {adjoint (M 0) * P * M 0 +\n         adjoint (M 1) * Q * M 1}\n                         While M S {P}\n 3. \\<And>P Q P' Q' S.\n       \\<lbrakk>is_quantum_predicate P; is_quantum_predicate Q;\n        is_quantum_predicate P'; is_quantum_predicate Q';\n        P \\<le>\\<^sub>L P'; \\<turnstile>\\<^sub>p {P'} S {Q'};\n        well_com S \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P'} S {Q'};\n        Q' \\<le>\\<^sub>L Q; well_com S\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P} S {Q}", "(*if*)"], ["proof (state)\nthis:\n  ?k < n \\<Longrightarrow> is_quantum_predicate (P ?k)\n  is_quantum_predicate Q\n  ?k < n \\<Longrightarrow> \\<turnstile>\\<^sub>p {P ?k} S ! ?k {Q}\n  \\<lbrakk>?k < n; well_com (S ! ?k)\\<rbrakk>\n  \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P ?k} S ! ?k {Q}\n  well_com (Measure n M S)\n\ngoal (3 subgoals):\n 1. \\<And>n P Q S M.\n       \\<lbrakk>\\<And>k. k < n \\<Longrightarrow> is_quantum_predicate (P k);\n        is_quantum_predicate Q;\n        \\<And>k.\n           k < n \\<Longrightarrow> \\<turnstile>\\<^sub>p {P k} S ! k {Q};\n        \\<And>k.\n           \\<lbrakk>k < n; well_com (S ! k)\\<rbrakk>\n           \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P k} S ! k {Q};\n        well_com (Measure n M S)\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {matrix_sum d\n          (\\<lambda>k. adjoint (M k) * P k * M k) n}\n                         Measure n M S {Q}\n 2. \\<And>P Q S M.\n       \\<lbrakk>is_quantum_predicate P; is_quantum_predicate Q;\n        \\<turnstile>\\<^sub>p {Q} S\n                             {adjoint (M 0) * P * M 0 +\n                              adjoint (M 1) * Q * M 1};\n        well_com S \\<Longrightarrow>\n        \\<Turnstile>\\<^sub>p {Q} S\n        {adjoint (M 0) * P * M 0 + adjoint (M 1) * Q * M 1};\n        well_com (While M S)\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {adjoint (M 0) * P * M 0 +\n         adjoint (M 1) * Q * M 1}\n                         While M S {P}\n 3. \\<And>P Q P' Q' S.\n       \\<lbrakk>is_quantum_predicate P; is_quantum_predicate Q;\n        is_quantum_predicate P'; is_quantum_predicate Q';\n        P \\<le>\\<^sub>L P'; \\<turnstile>\\<^sub>p {P'} S {Q'};\n        well_com S \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P'} S {Q'};\n        Q' \\<le>\\<^sub>L Q; well_com S\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P} S {Q}", "then"], ["proof (chain)\npicking this:\n  ?k < n \\<Longrightarrow> is_quantum_predicate (P ?k)\n  is_quantum_predicate Q\n  ?k < n \\<Longrightarrow> \\<turnstile>\\<^sub>p {P ?k} S ! ?k {Q}\n  \\<lbrakk>?k < n; well_com (S ! ?k)\\<rbrakk>\n  \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P ?k} S ! ?k {Q}\n  well_com (Measure n M S)", "have wc: \"k < n \\<Longrightarrow> well_com (S!k)\"\n    and c: \"k < n \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P k} (S!k) {Q}\" and m: \"measurement d n M\"\n    and dMk: \"k < n \\<Longrightarrow> M k \\<in> carrier_mat d d\"\n    and aMMkleq: \"k < n \\<Longrightarrow> adjoint (M k) * M k \\<le>\\<^sub>L 1\\<^sub>m d\"\n    and dPk: \"k < n \\<Longrightarrow> P k \\<in> carrier_mat d d\"\n    and dQ: \"Q \\<in> carrier_mat d d\"\n    for k"], ["proof (prove)\nusing this:\n  ?k < n \\<Longrightarrow> is_quantum_predicate (P ?k)\n  is_quantum_predicate Q\n  ?k < n \\<Longrightarrow> \\<turnstile>\\<^sub>p {P ?k} S ! ?k {Q}\n  \\<lbrakk>?k < n; well_com (S ! ?k)\\<rbrakk>\n  \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P ?k} S ! ?k {Q}\n  well_com (Measure n M S)\n\ngoal (1 subgoal):\n 1. ((k < n \\<Longrightarrow> well_com (S ! k)) &&&\n     (k < n \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P k} S ! k {Q}) &&&\n     measurement d n M) &&&\n    ((k < n \\<Longrightarrow> M k \\<in> carrier_mat d d) &&&\n     (k < n \\<Longrightarrow>\n      adjoint (M k) * M k \\<le>\\<^sub>L 1\\<^sub>m d)) &&&\n    (k < n \\<Longrightarrow> P k \\<in> carrier_mat d d) &&&\n    Q \\<in> carrier_mat d d", "using is_quantum_predicate_def measurement_def measure_well_com measurement_le_one_mat"], ["proof (prove)\nusing this:\n  ?k < n \\<Longrightarrow> is_quantum_predicate (P ?k)\n  is_quantum_predicate Q\n  ?k < n \\<Longrightarrow> \\<turnstile>\\<^sub>p {P ?k} S ! ?k {Q}\n  \\<lbrakk>?k < n; well_com (S ! ?k)\\<rbrakk>\n  \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P ?k} S ! ?k {Q}\n  well_com (Measure n M S)\n  is_quantum_predicate ?P =\n  (?P \\<in> carrier_mat d d \\<and>\n   positive ?P \\<and> ?P \\<le>\\<^sub>L 1\\<^sub>m d)\n  measurement ?d ?n ?M =\n  ((\\<forall>j<?n. ?M j \\<in> carrier_mat ?d ?d) \\<and>\n   matrix_sum ?d (\\<lambda>j. adjoint (?M j) * ?M j) ?n = 1\\<^sub>m ?d)\n  \\<lbrakk>well_com (Measure ?n ?M ?S); ?k < ?n\\<rbrakk>\n  \\<Longrightarrow> well_com (?S ! ?k)\n  \\<lbrakk>measurement ?d ?n ?f; ?j < ?n\\<rbrakk>\n  \\<Longrightarrow> adjoint (?f ?j) * ?f ?j \\<le>\\<^sub>L 1\\<^sub>m ?d\n\ngoal (1 subgoal):\n 1. ((k < n \\<Longrightarrow> well_com (S ! k)) &&&\n     (k < n \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P k} S ! k {Q}) &&&\n     measurement d n M) &&&\n    ((k < n \\<Longrightarrow> M k \\<in> carrier_mat d d) &&&\n     (k < n \\<Longrightarrow>\n      adjoint (M k) * M k \\<le>\\<^sub>L 1\\<^sub>m d)) &&&\n    (k < n \\<Longrightarrow> P k \\<in> carrier_mat d d) &&&\n    Q \\<in> carrier_mat d d", "by auto"], ["proof (state)\nthis:\n  ?k < n \\<Longrightarrow> well_com (S ! ?k)\n  ?k < n \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P ?k} S ! ?k {Q}\n  measurement d n M\n  ?k < n \\<Longrightarrow> M ?k \\<in> carrier_mat d d\n  ?k < n \\<Longrightarrow> adjoint (M ?k) * M ?k \\<le>\\<^sub>L 1\\<^sub>m d\n  ?k < n \\<Longrightarrow> P ?k \\<in> carrier_mat d d\n  Q \\<in> carrier_mat d d\n\ngoal (3 subgoals):\n 1. \\<And>n P Q S M.\n       \\<lbrakk>\\<And>k. k < n \\<Longrightarrow> is_quantum_predicate (P k);\n        is_quantum_predicate Q;\n        \\<And>k.\n           k < n \\<Longrightarrow> \\<turnstile>\\<^sub>p {P k} S ! k {Q};\n        \\<And>k.\n           \\<lbrakk>k < n; well_com (S ! k)\\<rbrakk>\n           \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P k} S ! k {Q};\n        well_com (Measure n M S)\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {matrix_sum d\n          (\\<lambda>k. adjoint (M k) * P k * M k) n}\n                         Measure n M S {Q}\n 2. \\<And>P Q S M.\n       \\<lbrakk>is_quantum_predicate P; is_quantum_predicate Q;\n        \\<turnstile>\\<^sub>p {Q} S\n                             {adjoint (M 0) * P * M 0 +\n                              adjoint (M 1) * Q * M 1};\n        well_com S \\<Longrightarrow>\n        \\<Turnstile>\\<^sub>p {Q} S\n        {adjoint (M 0) * P * M 0 + adjoint (M 1) * Q * M 1};\n        well_com (While M S)\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {adjoint (M 0) * P * M 0 +\n         adjoint (M 1) * Q * M 1}\n                         While M S {P}\n 3. \\<And>P Q P' Q' S.\n       \\<lbrakk>is_quantum_predicate P; is_quantum_predicate Q;\n        is_quantum_predicate P'; is_quantum_predicate Q';\n        P \\<le>\\<^sub>L P'; \\<turnstile>\\<^sub>p {P'} S {Q'};\n        well_com S \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P'} S {Q'};\n        Q' \\<le>\\<^sub>L Q; well_com S\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P} S {Q}", "{"], ["proof (state)\nthis:\n  ?k < n \\<Longrightarrow> well_com (S ! ?k)\n  ?k < n \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P ?k} S ! ?k {Q}\n  measurement d n M\n  ?k < n \\<Longrightarrow> M ?k \\<in> carrier_mat d d\n  ?k < n \\<Longrightarrow> adjoint (M ?k) * M ?k \\<le>\\<^sub>L 1\\<^sub>m d\n  ?k < n \\<Longrightarrow> P ?k \\<in> carrier_mat d d\n  Q \\<in> carrier_mat d d\n\ngoal (3 subgoals):\n 1. \\<And>n P Q S M.\n       \\<lbrakk>\\<And>k. k < n \\<Longrightarrow> is_quantum_predicate (P k);\n        is_quantum_predicate Q;\n        \\<And>k.\n           k < n \\<Longrightarrow> \\<turnstile>\\<^sub>p {P k} S ! k {Q};\n        \\<And>k.\n           \\<lbrakk>k < n; well_com (S ! k)\\<rbrakk>\n           \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P k} S ! k {Q};\n        well_com (Measure n M S)\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {matrix_sum d\n          (\\<lambda>k. adjoint (M k) * P k * M k) n}\n                         Measure n M S {Q}\n 2. \\<And>P Q S M.\n       \\<lbrakk>is_quantum_predicate P; is_quantum_predicate Q;\n        \\<turnstile>\\<^sub>p {Q} S\n                             {adjoint (M 0) * P * M 0 +\n                              adjoint (M 1) * Q * M 1};\n        well_com S \\<Longrightarrow>\n        \\<Turnstile>\\<^sub>p {Q} S\n        {adjoint (M 0) * P * M 0 + adjoint (M 1) * Q * M 1};\n        well_com (While M S)\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {adjoint (M 0) * P * M 0 +\n         adjoint (M 1) * Q * M 1}\n                         While M S {P}\n 3. \\<And>P Q P' Q' S.\n       \\<lbrakk>is_quantum_predicate P; is_quantum_predicate Q;\n        is_quantum_predicate P'; is_quantum_predicate Q';\n        P \\<le>\\<^sub>L P'; \\<turnstile>\\<^sub>p {P'} S {Q'};\n        well_com S \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P'} S {Q'};\n        Q' \\<le>\\<^sub>L Q; well_com S\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P} S {Q}", "fix \\<rho>"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>n P Q S M.\n       \\<lbrakk>\\<And>k. k < n \\<Longrightarrow> is_quantum_predicate (P k);\n        is_quantum_predicate Q;\n        \\<And>k.\n           k < n \\<Longrightarrow> \\<turnstile>\\<^sub>p {P k} S ! k {Q};\n        \\<And>k.\n           \\<lbrakk>k < n; well_com (S ! k)\\<rbrakk>\n           \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P k} S ! k {Q};\n        well_com (Measure n M S)\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {matrix_sum d\n          (\\<lambda>k. adjoint (M k) * P k * M k) n}\n                         Measure n M S {Q}\n 2. \\<And>P Q S M.\n       \\<lbrakk>is_quantum_predicate P; is_quantum_predicate Q;\n        \\<turnstile>\\<^sub>p {Q} S\n                             {adjoint (M 0) * P * M 0 +\n                              adjoint (M 1) * Q * M 1};\n        well_com S \\<Longrightarrow>\n        \\<Turnstile>\\<^sub>p {Q} S\n        {adjoint (M 0) * P * M 0 + adjoint (M 1) * Q * M 1};\n        well_com (While M S)\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {adjoint (M 0) * P * M 0 +\n         adjoint (M 1) * Q * M 1}\n                         While M S {P}\n 3. \\<And>P Q P' Q' S.\n       \\<lbrakk>is_quantum_predicate P; is_quantum_predicate Q;\n        is_quantum_predicate P'; is_quantum_predicate Q';\n        P \\<le>\\<^sub>L P'; \\<turnstile>\\<^sub>p {P'} S {Q'};\n        well_com S \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P'} S {Q'};\n        Q' \\<le>\\<^sub>L Q; well_com S\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P} S {Q}", "assume \\<rho>: \"\\<rho> \\<in> density_states\""], ["proof (state)\nthis:\n  \\<rho> \\<in> density_states\n\ngoal (3 subgoals):\n 1. \\<And>n P Q S M.\n       \\<lbrakk>\\<And>k. k < n \\<Longrightarrow> is_quantum_predicate (P k);\n        is_quantum_predicate Q;\n        \\<And>k.\n           k < n \\<Longrightarrow> \\<turnstile>\\<^sub>p {P k} S ! k {Q};\n        \\<And>k.\n           \\<lbrakk>k < n; well_com (S ! k)\\<rbrakk>\n           \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P k} S ! k {Q};\n        well_com (Measure n M S)\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {matrix_sum d\n          (\\<lambda>k. adjoint (M k) * P k * M k) n}\n                         Measure n M S {Q}\n 2. \\<And>P Q S M.\n       \\<lbrakk>is_quantum_predicate P; is_quantum_predicate Q;\n        \\<turnstile>\\<^sub>p {Q} S\n                             {adjoint (M 0) * P * M 0 +\n                              adjoint (M 1) * Q * M 1};\n        well_com S \\<Longrightarrow>\n        \\<Turnstile>\\<^sub>p {Q} S\n        {adjoint (M 0) * P * M 0 + adjoint (M 1) * Q * M 1};\n        well_com (While M S)\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {adjoint (M 0) * P * M 0 +\n         adjoint (M 1) * Q * M 1}\n                         While M S {P}\n 3. \\<And>P Q P' Q' S.\n       \\<lbrakk>is_quantum_predicate P; is_quantum_predicate Q;\n        is_quantum_predicate P'; is_quantum_predicate Q';\n        P \\<le>\\<^sub>L P'; \\<turnstile>\\<^sub>p {P'} S {Q'};\n        well_com S \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P'} S {Q'};\n        Q' \\<le>\\<^sub>L Q; well_com S\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P} S {Q}", "then"], ["proof (chain)\npicking this:\n  \\<rho> \\<in> density_states", "have dr: \"\\<rho> \\<in> carrier_mat d d\" and pdor: \"partial_density_operator \\<rho>\""], ["proof (prove)\nusing this:\n  \\<rho> \\<in> density_states\n\ngoal (1 subgoal):\n 1. \\<rho> \\<in> carrier_mat d d &&& partial_density_operator \\<rho>", "using density_states_def"], ["proof (prove)\nusing this:\n  \\<rho> \\<in> density_states\n  density_states =\n  {\\<rho> \\<in> carrier_mat d d. partial_density_operator \\<rho>}\n\ngoal (1 subgoal):\n 1. \\<rho> \\<in> carrier_mat d d &&& partial_density_operator \\<rho>", "by auto"], ["proof (state)\nthis:\n  \\<rho> \\<in> carrier_mat d d\n  partial_density_operator \\<rho>\n\ngoal (3 subgoals):\n 1. \\<And>n P Q S M.\n       \\<lbrakk>\\<And>k. k < n \\<Longrightarrow> is_quantum_predicate (P k);\n        is_quantum_predicate Q;\n        \\<And>k.\n           k < n \\<Longrightarrow> \\<turnstile>\\<^sub>p {P k} S ! k {Q};\n        \\<And>k.\n           \\<lbrakk>k < n; well_com (S ! k)\\<rbrakk>\n           \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P k} S ! k {Q};\n        well_com (Measure n M S)\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {matrix_sum d\n          (\\<lambda>k. adjoint (M k) * P k * M k) n}\n                         Measure n M S {Q}\n 2. \\<And>P Q S M.\n       \\<lbrakk>is_quantum_predicate P; is_quantum_predicate Q;\n        \\<turnstile>\\<^sub>p {Q} S\n                             {adjoint (M 0) * P * M 0 +\n                              adjoint (M 1) * Q * M 1};\n        well_com S \\<Longrightarrow>\n        \\<Turnstile>\\<^sub>p {Q} S\n        {adjoint (M 0) * P * M 0 + adjoint (M 1) * Q * M 1};\n        well_com (While M S)\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {adjoint (M 0) * P * M 0 +\n         adjoint (M 1) * Q * M 1}\n                         While M S {P}\n 3. \\<And>P Q P' Q' S.\n       \\<lbrakk>is_quantum_predicate P; is_quantum_predicate Q;\n        is_quantum_predicate P'; is_quantum_predicate Q';\n        P \\<le>\\<^sub>L P'; \\<turnstile>\\<^sub>p {P'} S {Q'};\n        well_com S \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P'} S {Q'};\n        Q' \\<le>\\<^sub>L Q; well_com S\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P} S {Q}", "have dsr: \"k < n \\<Longrightarrow> (M k) * \\<rho> * adjoint (M k) \\<in> density_states\" for k"], ["proof (prove)\ngoal (1 subgoal):\n 1. k < n \\<Longrightarrow>\n    M k * \\<rho> * adjoint (M k) \\<in> density_states", "unfolding density_states_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. k < n \\<Longrightarrow>\n    M k * \\<rho> * adjoint (M k)\n    \\<in> {\\<rho> \\<in> carrier_mat d d. partial_density_operator \\<rho>}", "using dMk pdo_close_under_measurement[OF dMk dr pdor aMMkleq] dr"], ["proof (prove)\nusing this:\n  ?k < n \\<Longrightarrow> M ?k \\<in> carrier_mat d d\n  \\<lbrakk>?k1 < n; ?k1 < n\\<rbrakk>\n  \\<Longrightarrow> partial_density_operator\n                     (M ?k1 * \\<rho> * adjoint (M ?k1))\n  \\<rho> \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. k < n \\<Longrightarrow>\n    M k * \\<rho> * adjoint (M k)\n    \\<in> {\\<rho> \\<in> carrier_mat d d. partial_density_operator \\<rho>}", "by fastforce"], ["proof (state)\nthis:\n  ?k < n \\<Longrightarrow>\n  M ?k * \\<rho> * adjoint (M ?k) \\<in> density_states\n\ngoal (3 subgoals):\n 1. \\<And>n P Q S M.\n       \\<lbrakk>\\<And>k. k < n \\<Longrightarrow> is_quantum_predicate (P k);\n        is_quantum_predicate Q;\n        \\<And>k.\n           k < n \\<Longrightarrow> \\<turnstile>\\<^sub>p {P k} S ! k {Q};\n        \\<And>k.\n           \\<lbrakk>k < n; well_com (S ! k)\\<rbrakk>\n           \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P k} S ! k {Q};\n        well_com (Measure n M S)\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {matrix_sum d\n          (\\<lambda>k. adjoint (M k) * P k * M k) n}\n                         Measure n M S {Q}\n 2. \\<And>P Q S M.\n       \\<lbrakk>is_quantum_predicate P; is_quantum_predicate Q;\n        \\<turnstile>\\<^sub>p {Q} S\n                             {adjoint (M 0) * P * M 0 +\n                              adjoint (M 1) * Q * M 1};\n        well_com S \\<Longrightarrow>\n        \\<Turnstile>\\<^sub>p {Q} S\n        {adjoint (M 0) * P * M 0 + adjoint (M 1) * Q * M 1};\n        well_com (While M S)\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {adjoint (M 0) * P * M 0 +\n         adjoint (M 1) * Q * M 1}\n                         While M S {P}\n 3. \\<And>P Q P' Q' S.\n       \\<lbrakk>is_quantum_predicate P; is_quantum_predicate Q;\n        is_quantum_predicate P'; is_quantum_predicate Q';\n        P \\<le>\\<^sub>L P'; \\<turnstile>\\<^sub>p {P'} S {Q'};\n        well_com S \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P'} S {Q'};\n        Q' \\<le>\\<^sub>L Q; well_com S\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P} S {Q}", "then"], ["proof (chain)\npicking this:\n  ?k < n \\<Longrightarrow>\n  M ?k * \\<rho> * adjoint (M ?k) \\<in> density_states", "have leqk: \"k < n \\<Longrightarrow> trace ((P k) * ((M k) * \\<rho> * adjoint (M k))) \\<le> \n        trace (Q * (denote (S!k) ((M k) * \\<rho> * adjoint (M k)))) + \n        (trace ((M k) * \\<rho> * adjoint (M k)) - trace (denote (S ! k) ((M k) * \\<rho> * adjoint (M k))))\" for k"], ["proof (prove)\nusing this:\n  ?k < n \\<Longrightarrow>\n  M ?k * \\<rho> * adjoint (M ?k) \\<in> density_states\n\ngoal (1 subgoal):\n 1. k < n \\<Longrightarrow>\n    trace (P k * (M k * \\<rho> * adjoint (M k)))\n    \\<le> trace (Q * denote (S ! k) (M k * \\<rho> * adjoint (M k))) +\n          (trace (M k * \\<rho> * adjoint (M k)) -\n           trace (denote (S ! k) (M k * \\<rho> * adjoint (M k))))", "using c"], ["proof (prove)\nusing this:\n  ?k < n \\<Longrightarrow>\n  M ?k * \\<rho> * adjoint (M ?k) \\<in> density_states\n  ?k < n \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P ?k} S ! ?k {Q}\n\ngoal (1 subgoal):\n 1. k < n \\<Longrightarrow>\n    trace (P k * (M k * \\<rho> * adjoint (M k)))\n    \\<le> trace (Q * denote (S ! k) (M k * \\<rho> * adjoint (M k))) +\n          (trace (M k * \\<rho> * adjoint (M k)) -\n           trace (denote (S ! k) (M k * \\<rho> * adjoint (M k))))", "unfolding hoare_partial_correct_def"], ["proof (prove)\nusing this:\n  ?k < n \\<Longrightarrow>\n  M ?k * \\<rho> * adjoint (M ?k) \\<in> density_states\n  ?k < n \\<Longrightarrow>\n  \\<forall>\\<rho>\\<in>density_states.\n     trace (P ?k * \\<rho>)\n     \\<le> trace (Q * denote (S ! ?k) \\<rho>) +\n           (trace \\<rho> - trace (denote (S ! ?k) \\<rho>))\n\ngoal (1 subgoal):\n 1. k < n \\<Longrightarrow>\n    trace (P k * (M k * \\<rho> * adjoint (M k)))\n    \\<le> trace (Q * denote (S ! k) (M k * \\<rho> * adjoint (M k))) +\n          (trace (M k * \\<rho> * adjoint (M k)) -\n           trace (denote (S ! k) (M k * \\<rho> * adjoint (M k))))", "by auto"], ["proof (state)\nthis:\n  ?k < n \\<Longrightarrow>\n  trace (P ?k * (M ?k * \\<rho> * adjoint (M ?k)))\n  \\<le> trace (Q * denote (S ! ?k) (M ?k * \\<rho> * adjoint (M ?k))) +\n        (trace (M ?k * \\<rho> * adjoint (M ?k)) -\n         trace (denote (S ! ?k) (M ?k * \\<rho> * adjoint (M ?k))))\n\ngoal (3 subgoals):\n 1. \\<And>n P Q S M.\n       \\<lbrakk>\\<And>k. k < n \\<Longrightarrow> is_quantum_predicate (P k);\n        is_quantum_predicate Q;\n        \\<And>k.\n           k < n \\<Longrightarrow> \\<turnstile>\\<^sub>p {P k} S ! k {Q};\n        \\<And>k.\n           \\<lbrakk>k < n; well_com (S ! k)\\<rbrakk>\n           \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P k} S ! k {Q};\n        well_com (Measure n M S)\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {matrix_sum d\n          (\\<lambda>k. adjoint (M k) * P k * M k) n}\n                         Measure n M S {Q}\n 2. \\<And>P Q S M.\n       \\<lbrakk>is_quantum_predicate P; is_quantum_predicate Q;\n        \\<turnstile>\\<^sub>p {Q} S\n                             {adjoint (M 0) * P * M 0 +\n                              adjoint (M 1) * Q * M 1};\n        well_com S \\<Longrightarrow>\n        \\<Turnstile>\\<^sub>p {Q} S\n        {adjoint (M 0) * P * M 0 + adjoint (M 1) * Q * M 1};\n        well_com (While M S)\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {adjoint (M 0) * P * M 0 +\n         adjoint (M 1) * Q * M 1}\n                         While M S {P}\n 3. \\<And>P Q P' Q' S.\n       \\<lbrakk>is_quantum_predicate P; is_quantum_predicate Q;\n        is_quantum_predicate P'; is_quantum_predicate Q';\n        P \\<le>\\<^sub>L P'; \\<turnstile>\\<^sub>p {P'} S {Q'};\n        well_com S \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P'} S {Q'};\n        Q' \\<le>\\<^sub>L Q; well_com S\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P} S {Q}", "have \"k < n \\<Longrightarrow> M k * \\<rho> * adjoint (M k) \\<in> carrier_mat d d\" for k"], ["proof (prove)\ngoal (1 subgoal):\n 1. k < n \\<Longrightarrow>\n    M k * \\<rho> * adjoint (M k) \\<in> carrier_mat d d", "using dMk dr"], ["proof (prove)\nusing this:\n  ?k < n \\<Longrightarrow> M ?k \\<in> carrier_mat d d\n  \\<rho> \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. k < n \\<Longrightarrow>\n    M k * \\<rho> * adjoint (M k) \\<in> carrier_mat d d", "by fastforce"], ["proof (state)\nthis:\n  ?k < n \\<Longrightarrow>\n  M ?k * \\<rho> * adjoint (M ?k) \\<in> carrier_mat d d\n\ngoal (3 subgoals):\n 1. \\<And>n P Q S M.\n       \\<lbrakk>\\<And>k. k < n \\<Longrightarrow> is_quantum_predicate (P k);\n        is_quantum_predicate Q;\n        \\<And>k.\n           k < n \\<Longrightarrow> \\<turnstile>\\<^sub>p {P k} S ! k {Q};\n        \\<And>k.\n           \\<lbrakk>k < n; well_com (S ! k)\\<rbrakk>\n           \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P k} S ! k {Q};\n        well_com (Measure n M S)\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {matrix_sum d\n          (\\<lambda>k. adjoint (M k) * P k * M k) n}\n                         Measure n M S {Q}\n 2. \\<And>P Q S M.\n       \\<lbrakk>is_quantum_predicate P; is_quantum_predicate Q;\n        \\<turnstile>\\<^sub>p {Q} S\n                             {adjoint (M 0) * P * M 0 +\n                              adjoint (M 1) * Q * M 1};\n        well_com S \\<Longrightarrow>\n        \\<Turnstile>\\<^sub>p {Q} S\n        {adjoint (M 0) * P * M 0 + adjoint (M 1) * Q * M 1};\n        well_com (While M S)\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {adjoint (M 0) * P * M 0 +\n         adjoint (M 1) * Q * M 1}\n                         While M S {P}\n 3. \\<And>P Q P' Q' S.\n       \\<lbrakk>is_quantum_predicate P; is_quantum_predicate Q;\n        is_quantum_predicate P'; is_quantum_predicate Q';\n        P \\<le>\\<^sub>L P'; \\<turnstile>\\<^sub>p {P'} S {Q'};\n        well_com S \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P'} S {Q'};\n        Q' \\<le>\\<^sub>L Q; well_com S\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P} S {Q}", "then"], ["proof (chain)\npicking this:\n  ?k < n \\<Longrightarrow>\n  M ?k * \\<rho> * adjoint (M ?k) \\<in> carrier_mat d d", "have dsMrk: \"k < n \\<Longrightarrow> matrix_sum d (\\<lambda>k. (M k * \\<rho> * adjoint (M k))) k \\<in> carrier_mat d d\" for k"], ["proof (prove)\nusing this:\n  ?k < n \\<Longrightarrow>\n  M ?k * \\<rho> * adjoint (M ?k) \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. k < n \\<Longrightarrow>\n    matrix_sum d (\\<lambda>k. M k * \\<rho> * adjoint (M k)) k\n    \\<in> carrier_mat d d", "using matrix_sum_dim[of k \"\\<lambda>k. (M k * \\<rho> * adjoint (M k))\" d]"], ["proof (prove)\nusing this:\n  ?k < n \\<Longrightarrow>\n  M ?k * \\<rho> * adjoint (M ?k) \\<in> carrier_mat d d\n  (\\<And>ka.\n      ka < k \\<Longrightarrow>\n      M ka * \\<rho> * adjoint (M ka)\n      \\<in> carrier_mat d d) \\<Longrightarrow>\n  matrix_sum d (\\<lambda>k. M k * \\<rho> * adjoint (M k)) k\n  \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. k < n \\<Longrightarrow>\n    matrix_sum d (\\<lambda>k. M k * \\<rho> * adjoint (M k)) k\n    \\<in> carrier_mat d d", "by fastforce"], ["proof (state)\nthis:\n  ?k < n \\<Longrightarrow>\n  matrix_sum d (\\<lambda>k. M k * \\<rho> * adjoint (M k)) ?k\n  \\<in> carrier_mat d d\n\ngoal (3 subgoals):\n 1. \\<And>n P Q S M.\n       \\<lbrakk>\\<And>k. k < n \\<Longrightarrow> is_quantum_predicate (P k);\n        is_quantum_predicate Q;\n        \\<And>k.\n           k < n \\<Longrightarrow> \\<turnstile>\\<^sub>p {P k} S ! k {Q};\n        \\<And>k.\n           \\<lbrakk>k < n; well_com (S ! k)\\<rbrakk>\n           \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P k} S ! k {Q};\n        well_com (Measure n M S)\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {matrix_sum d\n          (\\<lambda>k. adjoint (M k) * P k * M k) n}\n                         Measure n M S {Q}\n 2. \\<And>P Q S M.\n       \\<lbrakk>is_quantum_predicate P; is_quantum_predicate Q;\n        \\<turnstile>\\<^sub>p {Q} S\n                             {adjoint (M 0) * P * M 0 +\n                              adjoint (M 1) * Q * M 1};\n        well_com S \\<Longrightarrow>\n        \\<Turnstile>\\<^sub>p {Q} S\n        {adjoint (M 0) * P * M 0 + adjoint (M 1) * Q * M 1};\n        well_com (While M S)\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {adjoint (M 0) * P * M 0 +\n         adjoint (M 1) * Q * M 1}\n                         While M S {P}\n 3. \\<And>P Q P' Q' S.\n       \\<lbrakk>is_quantum_predicate P; is_quantum_predicate Q;\n        is_quantum_predicate P'; is_quantum_predicate Q';\n        P \\<le>\\<^sub>L P'; \\<turnstile>\\<^sub>p {P'} S {Q'};\n        well_com S \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P'} S {Q'};\n        Q' \\<le>\\<^sub>L Q; well_com S\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P} S {Q}", "have \"k < n \\<Longrightarrow> adjoint (M k) * P k * M k \\<in> carrier_mat d d\" for k"], ["proof (prove)\ngoal (1 subgoal):\n 1. k < n \\<Longrightarrow> adjoint (M k) * P k * M k \\<in> carrier_mat d d", "using dMk dPk"], ["proof (prove)\nusing this:\n  ?k < n \\<Longrightarrow> M ?k \\<in> carrier_mat d d\n  ?k < n \\<Longrightarrow> P ?k \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. k < n \\<Longrightarrow> adjoint (M k) * P k * M k \\<in> carrier_mat d d", "by fastforce"], ["proof (state)\nthis:\n  ?k < n \\<Longrightarrow>\n  adjoint (M ?k) * P ?k * M ?k \\<in> carrier_mat d d\n\ngoal (3 subgoals):\n 1. \\<And>n P Q S M.\n       \\<lbrakk>\\<And>k. k < n \\<Longrightarrow> is_quantum_predicate (P k);\n        is_quantum_predicate Q;\n        \\<And>k.\n           k < n \\<Longrightarrow> \\<turnstile>\\<^sub>p {P k} S ! k {Q};\n        \\<And>k.\n           \\<lbrakk>k < n; well_com (S ! k)\\<rbrakk>\n           \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P k} S ! k {Q};\n        well_com (Measure n M S)\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {matrix_sum d\n          (\\<lambda>k. adjoint (M k) * P k * M k) n}\n                         Measure n M S {Q}\n 2. \\<And>P Q S M.\n       \\<lbrakk>is_quantum_predicate P; is_quantum_predicate Q;\n        \\<turnstile>\\<^sub>p {Q} S\n                             {adjoint (M 0) * P * M 0 +\n                              adjoint (M 1) * Q * M 1};\n        well_com S \\<Longrightarrow>\n        \\<Turnstile>\\<^sub>p {Q} S\n        {adjoint (M 0) * P * M 0 + adjoint (M 1) * Q * M 1};\n        well_com (While M S)\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {adjoint (M 0) * P * M 0 +\n         adjoint (M 1) * Q * M 1}\n                         While M S {P}\n 3. \\<And>P Q P' Q' S.\n       \\<lbrakk>is_quantum_predicate P; is_quantum_predicate Q;\n        is_quantum_predicate P'; is_quantum_predicate Q';\n        P \\<le>\\<^sub>L P'; \\<turnstile>\\<^sub>p {P'} S {Q'};\n        well_com S \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P'} S {Q'};\n        Q' \\<le>\\<^sub>L Q; well_com S\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P} S {Q}", "then"], ["proof (chain)\npicking this:\n  ?k < n \\<Longrightarrow>\n  adjoint (M ?k) * P ?k * M ?k \\<in> carrier_mat d d", "have dsMP: \"k < n \\<Longrightarrow> matrix_sum d (\\<lambda>k. adjoint (M k) * P k * M k) k \\<in> carrier_mat d d\" for k"], ["proof (prove)\nusing this:\n  ?k < n \\<Longrightarrow>\n  adjoint (M ?k) * P ?k * M ?k \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. k < n \\<Longrightarrow>\n    matrix_sum d (\\<lambda>k. adjoint (M k) * P k * M k) k\n    \\<in> carrier_mat d d", "using matrix_sum_dim[of k \"\\<lambda>k. adjoint (M k) * P k * M k\" d]"], ["proof (prove)\nusing this:\n  ?k < n \\<Longrightarrow>\n  adjoint (M ?k) * P ?k * M ?k \\<in> carrier_mat d d\n  (\\<And>ka.\n      ka < k \\<Longrightarrow>\n      adjoint (M ka) * P ka * M ka \\<in> carrier_mat d d) \\<Longrightarrow>\n  matrix_sum d (\\<lambda>k. adjoint (M k) * P k * M k) k\n  \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. k < n \\<Longrightarrow>\n    matrix_sum d (\\<lambda>k. adjoint (M k) * P k * M k) k\n    \\<in> carrier_mat d d", "by fastforce"], ["proof (state)\nthis:\n  ?k < n \\<Longrightarrow>\n  matrix_sum d (\\<lambda>k. adjoint (M k) * P k * M k) ?k\n  \\<in> carrier_mat d d\n\ngoal (3 subgoals):\n 1. \\<And>n P Q S M.\n       \\<lbrakk>\\<And>k. k < n \\<Longrightarrow> is_quantum_predicate (P k);\n        is_quantum_predicate Q;\n        \\<And>k.\n           k < n \\<Longrightarrow> \\<turnstile>\\<^sub>p {P k} S ! k {Q};\n        \\<And>k.\n           \\<lbrakk>k < n; well_com (S ! k)\\<rbrakk>\n           \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P k} S ! k {Q};\n        well_com (Measure n M S)\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {matrix_sum d\n          (\\<lambda>k. adjoint (M k) * P k * M k) n}\n                         Measure n M S {Q}\n 2. \\<And>P Q S M.\n       \\<lbrakk>is_quantum_predicate P; is_quantum_predicate Q;\n        \\<turnstile>\\<^sub>p {Q} S\n                             {adjoint (M 0) * P * M 0 +\n                              adjoint (M 1) * Q * M 1};\n        well_com S \\<Longrightarrow>\n        \\<Turnstile>\\<^sub>p {Q} S\n        {adjoint (M 0) * P * M 0 + adjoint (M 1) * Q * M 1};\n        well_com (While M S)\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {adjoint (M 0) * P * M 0 +\n         adjoint (M 1) * Q * M 1}\n                         While M S {P}\n 3. \\<And>P Q P' Q' S.\n       \\<lbrakk>is_quantum_predicate P; is_quantum_predicate Q;\n        is_quantum_predicate P'; is_quantum_predicate Q';\n        P \\<le>\\<^sub>L P'; \\<turnstile>\\<^sub>p {P'} S {Q'};\n        well_com S \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P'} S {Q'};\n        Q' \\<le>\\<^sub>L Q; well_com S\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P} S {Q}", "have dSMrk: \"k < n \\<Longrightarrow> denote (S ! k) (M k * \\<rho> * adjoint (M k)) \\<in> carrier_mat d d\" for k"], ["proof (prove)\ngoal (1 subgoal):\n 1. k < n \\<Longrightarrow>\n    denote (S ! k) (M k * \\<rho> * adjoint (M k)) \\<in> carrier_mat d d", "using denote_dim[OF wc, of k \"M k * \\<rho> * adjoint (M k)\"] dsr density_states_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>k < n; M k * \\<rho> * adjoint (M k) \\<in> carrier_mat d d;\n   partial_density_operator (M k * \\<rho> * adjoint (M k))\\<rbrakk>\n  \\<Longrightarrow> denote (S ! k) (M k * \\<rho> * adjoint (M k))\n                    \\<in> carrier_mat d d\n  ?k < n \\<Longrightarrow>\n  M ?k * \\<rho> * adjoint (M ?k) \\<in> density_states\n  density_states =\n  {\\<rho> \\<in> carrier_mat d d. partial_density_operator \\<rho>}\n\ngoal (1 subgoal):\n 1. k < n \\<Longrightarrow>\n    denote (S ! k) (M k * \\<rho> * adjoint (M k)) \\<in> carrier_mat d d", "by fastforce"], ["proof (state)\nthis:\n  ?k < n \\<Longrightarrow>\n  denote (S ! ?k) (M ?k * \\<rho> * adjoint (M ?k)) \\<in> carrier_mat d d\n\ngoal (3 subgoals):\n 1. \\<And>n P Q S M.\n       \\<lbrakk>\\<And>k. k < n \\<Longrightarrow> is_quantum_predicate (P k);\n        is_quantum_predicate Q;\n        \\<And>k.\n           k < n \\<Longrightarrow> \\<turnstile>\\<^sub>p {P k} S ! k {Q};\n        \\<And>k.\n           \\<lbrakk>k < n; well_com (S ! k)\\<rbrakk>\n           \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P k} S ! k {Q};\n        well_com (Measure n M S)\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {matrix_sum d\n          (\\<lambda>k. adjoint (M k) * P k * M k) n}\n                         Measure n M S {Q}\n 2. \\<And>P Q S M.\n       \\<lbrakk>is_quantum_predicate P; is_quantum_predicate Q;\n        \\<turnstile>\\<^sub>p {Q} S\n                             {adjoint (M 0) * P * M 0 +\n                              adjoint (M 1) * Q * M 1};\n        well_com S \\<Longrightarrow>\n        \\<Turnstile>\\<^sub>p {Q} S\n        {adjoint (M 0) * P * M 0 + adjoint (M 1) * Q * M 1};\n        well_com (While M S)\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {adjoint (M 0) * P * M 0 +\n         adjoint (M 1) * Q * M 1}\n                         While M S {P}\n 3. \\<And>P Q P' Q' S.\n       \\<lbrakk>is_quantum_predicate P; is_quantum_predicate Q;\n        is_quantum_predicate P'; is_quantum_predicate Q';\n        P \\<le>\\<^sub>L P'; \\<turnstile>\\<^sub>p {P'} S {Q'};\n        well_com S \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P'} S {Q'};\n        Q' \\<le>\\<^sub>L Q; well_com S\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P} S {Q}", "have dsSMrk: \"k < n \\<Longrightarrow> matrix_sum d (\\<lambda>k. denote (S!k) (M k * \\<rho> * adjoint (M k))) k \\<in> carrier_mat d d\" for k"], ["proof (prove)\ngoal (1 subgoal):\n 1. k < n \\<Longrightarrow>\n    matrix_sum d (\\<lambda>k. denote (S ! k) (M k * \\<rho> * adjoint (M k)))\n     k\n    \\<in> carrier_mat d d", "using matrix_sum_dim[of k \"\\<lambda>k. denote (S ! k) (M k * \\<rho> * adjoint (M k))\" d, OF dSMrk]"], ["proof (prove)\nusing this:\n  (\\<And>ka. ka < k \\<Longrightarrow> ka < n) \\<Longrightarrow>\n  matrix_sum d (\\<lambda>k. denote (S ! k) (M k * \\<rho> * adjoint (M k))) k\n  \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. k < n \\<Longrightarrow>\n    matrix_sum d (\\<lambda>k. denote (S ! k) (M k * \\<rho> * adjoint (M k)))\n     k\n    \\<in> carrier_mat d d", "by fastforce"], ["proof (state)\nthis:\n  ?k < n \\<Longrightarrow>\n  matrix_sum d (\\<lambda>k. denote (S ! k) (M k * \\<rho> * adjoint (M k)))\n   ?k\n  \\<in> carrier_mat d d\n\ngoal (3 subgoals):\n 1. \\<And>n P Q S M.\n       \\<lbrakk>\\<And>k. k < n \\<Longrightarrow> is_quantum_predicate (P k);\n        is_quantum_predicate Q;\n        \\<And>k.\n           k < n \\<Longrightarrow> \\<turnstile>\\<^sub>p {P k} S ! k {Q};\n        \\<And>k.\n           \\<lbrakk>k < n; well_com (S ! k)\\<rbrakk>\n           \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P k} S ! k {Q};\n        well_com (Measure n M S)\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {matrix_sum d\n          (\\<lambda>k. adjoint (M k) * P k * M k) n}\n                         Measure n M S {Q}\n 2. \\<And>P Q S M.\n       \\<lbrakk>is_quantum_predicate P; is_quantum_predicate Q;\n        \\<turnstile>\\<^sub>p {Q} S\n                             {adjoint (M 0) * P * M 0 +\n                              adjoint (M 1) * Q * M 1};\n        well_com S \\<Longrightarrow>\n        \\<Turnstile>\\<^sub>p {Q} S\n        {adjoint (M 0) * P * M 0 + adjoint (M 1) * Q * M 1};\n        well_com (While M S)\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {adjoint (M 0) * P * M 0 +\n         adjoint (M 1) * Q * M 1}\n                         While M S {P}\n 3. \\<And>P Q P' Q' S.\n       \\<lbrakk>is_quantum_predicate P; is_quantum_predicate Q;\n        is_quantum_predicate P'; is_quantum_predicate Q';\n        P \\<le>\\<^sub>L P'; \\<turnstile>\\<^sub>p {P'} S {Q'};\n        well_com S \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P'} S {Q'};\n        Q' \\<le>\\<^sub>L Q; well_com S\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P} S {Q}", "have \"k \\<le> n \\<Longrightarrow> \n          trace (matrix_sum d (\\<lambda>k. adjoint (M k) * P k * M k) k * \\<rho>)\n         \\<le> trace (Q * (denote (Measure k M S) \\<rho>)) + (trace (matrix_sum d (\\<lambda>k. (M k) * \\<rho> * adjoint (M k)) k) - trace (denote (Measure k M S) \\<rho>))\" for k"], ["proof (prove)\ngoal (1 subgoal):\n 1. k \\<le> n \\<Longrightarrow>\n    trace (matrix_sum d (\\<lambda>k. adjoint (M k) * P k * M k) k * \\<rho>)\n    \\<le> trace (Q * denote (Measure k M S) \\<rho>) +\n          (trace\n            (matrix_sum d (\\<lambda>k. M k * \\<rho> * adjoint (M k)) k) -\n           trace (denote (Measure k M S) \\<rho>))", "unfolding denote_measure_expand[OF _ 4(5)]"], ["proof (prove)\ngoal (1 subgoal):\n 1. k \\<le> n \\<Longrightarrow>\n    trace (matrix_sum d (\\<lambda>k. adjoint (M k) * P k * M k) k * \\<rho>)\n    \\<le> trace\n           (Q *\n            matrix_sum d\n             (\\<lambda>k. denote (S ! k) (M k * \\<rho> * adjoint (M k)))\n             k) +\n          (trace\n            (matrix_sum d (\\<lambda>k. M k * \\<rho> * adjoint (M k)) k) -\n           trace\n            (matrix_sum d\n              (\\<lambda>k. denote (S ! k) (M k * \\<rho> * adjoint (M k)))\n              k))", "proof (induct k)"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 \\<le> n \\<Longrightarrow>\n    trace (matrix_sum d (\\<lambda>k. adjoint (M k) * P k * M k) 0 * \\<rho>)\n    \\<le> trace\n           (Q *\n            matrix_sum d\n             (\\<lambda>k. denote (S ! k) (M k * \\<rho> * adjoint (M k)))\n             0) +\n          (trace\n            (matrix_sum d (\\<lambda>k. M k * \\<rho> * adjoint (M k)) 0) -\n           trace\n            (matrix_sum d\n              (\\<lambda>k. denote (S ! k) (M k * \\<rho> * adjoint (M k)))\n              0))\n 2. \\<And>k.\n       \\<lbrakk>k \\<le> n \\<Longrightarrow>\n                trace\n                 (matrix_sum d (\\<lambda>k. adjoint (M k) * P k * M k) k *\n                  \\<rho>)\n                \\<le> trace\n                       (Q *\n                        matrix_sum d\n                         (\\<lambda>k.\n                             denote (S ! k) (M k * \\<rho> * adjoint (M k)))\n                         k) +\n                      (trace\n                        (matrix_sum d\n                          (\\<lambda>k. M k * \\<rho> * adjoint (M k)) k) -\n                       trace\n                        (matrix_sum d\n                          (\\<lambda>k.\n                              denote (S ! k) (M k * \\<rho> * adjoint (M k)))\n                          k));\n        Suc k \\<le> n\\<rbrakk>\n       \\<Longrightarrow> trace\n                          (matrix_sum d\n                            (\\<lambda>k. adjoint (M k) * P k * M k)\n                            (Suc k) *\n                           \\<rho>)\n                         \\<le> trace\n                                (Q *\n                                 matrix_sum d\n                                  (\\<lambda>k.\ndenote (S ! k) (M k * \\<rho> * adjoint (M k)))\n                                  (Suc k)) +\n                               (trace\n                                 (matrix_sum d\n                                   (\\<lambda>k.\n M k * \\<rho> * adjoint (M k))\n                                   (Suc k)) -\n                                trace\n                                 (matrix_sum d\n                                   (\\<lambda>k.\n denote (S ! k) (M k * \\<rho> * adjoint (M k)))\n                                   (Suc k)))", "case 0"], ["proof (state)\nthis:\n  0 \\<le> n\n\ngoal (2 subgoals):\n 1. 0 \\<le> n \\<Longrightarrow>\n    trace (matrix_sum d (\\<lambda>k. adjoint (M k) * P k * M k) 0 * \\<rho>)\n    \\<le> trace\n           (Q *\n            matrix_sum d\n             (\\<lambda>k. denote (S ! k) (M k * \\<rho> * adjoint (M k)))\n             0) +\n          (trace\n            (matrix_sum d (\\<lambda>k. M k * \\<rho> * adjoint (M k)) 0) -\n           trace\n            (matrix_sum d\n              (\\<lambda>k. denote (S ! k) (M k * \\<rho> * adjoint (M k)))\n              0))\n 2. \\<And>k.\n       \\<lbrakk>k \\<le> n \\<Longrightarrow>\n                trace\n                 (matrix_sum d (\\<lambda>k. adjoint (M k) * P k * M k) k *\n                  \\<rho>)\n                \\<le> trace\n                       (Q *\n                        matrix_sum d\n                         (\\<lambda>k.\n                             denote (S ! k) (M k * \\<rho> * adjoint (M k)))\n                         k) +\n                      (trace\n                        (matrix_sum d\n                          (\\<lambda>k. M k * \\<rho> * adjoint (M k)) k) -\n                       trace\n                        (matrix_sum d\n                          (\\<lambda>k.\n                              denote (S ! k) (M k * \\<rho> * adjoint (M k)))\n                          k));\n        Suc k \\<le> n\\<rbrakk>\n       \\<Longrightarrow> trace\n                          (matrix_sum d\n                            (\\<lambda>k. adjoint (M k) * P k * M k)\n                            (Suc k) *\n                           \\<rho>)\n                         \\<le> trace\n                                (Q *\n                                 matrix_sum d\n                                  (\\<lambda>k.\ndenote (S ! k) (M k * \\<rho> * adjoint (M k)))\n                                  (Suc k)) +\n                               (trace\n                                 (matrix_sum d\n                                   (\\<lambda>k.\n M k * \\<rho> * adjoint (M k))\n                                   (Suc k)) -\n                                trace\n                                 (matrix_sum d\n                                   (\\<lambda>k.\n denote (S ! k) (M k * \\<rho> * adjoint (M k)))\n                                   (Suc k)))", "then"], ["proof (chain)\npicking this:\n  0 \\<le> n", "show ?case"], ["proof (prove)\nusing this:\n  0 \\<le> n\n\ngoal (1 subgoal):\n 1. trace (matrix_sum d (\\<lambda>k. adjoint (M k) * P k * M k) 0 * \\<rho>)\n    \\<le> trace\n           (Q *\n            matrix_sum d\n             (\\<lambda>k. denote (S ! k) (M k * \\<rho> * adjoint (M k)))\n             0) +\n          (trace\n            (matrix_sum d (\\<lambda>k. M k * \\<rho> * adjoint (M k)) 0) -\n           trace\n            (matrix_sum d\n              (\\<lambda>k. denote (S ! k) (M k * \\<rho> * adjoint (M k)))\n              0))", "using dQ dr pdor partial_density_operator_def positive_trace"], ["proof (prove)\nusing this:\n  0 \\<le> n\n  Q \\<in> carrier_mat d d\n  \\<rho> \\<in> carrier_mat d d\n  partial_density_operator \\<rho>\n  partial_density_operator ?A = (positive ?A \\<and> trace ?A \\<le> 1)\n  \\<lbrakk>?A \\<in> carrier_mat ?n ?n; positive ?A\\<rbrakk>\n  \\<Longrightarrow> 0 \\<le> trace ?A\n\ngoal (1 subgoal):\n 1. trace (matrix_sum d (\\<lambda>k. adjoint (M k) * P k * M k) 0 * \\<rho>)\n    \\<le> trace\n           (Q *\n            matrix_sum d\n             (\\<lambda>k. denote (S ! k) (M k * \\<rho> * adjoint (M k)))\n             0) +\n          (trace\n            (matrix_sum d (\\<lambda>k. M k * \\<rho> * adjoint (M k)) 0) -\n           trace\n            (matrix_sum d\n              (\\<lambda>k. denote (S ! k) (M k * \\<rho> * adjoint (M k)))\n              0))", "by auto"], ["proof (state)\nthis:\n  trace (matrix_sum d (\\<lambda>k. adjoint (M k) * P k * M k) 0 * \\<rho>)\n  \\<le> trace\n         (Q *\n          matrix_sum d\n           (\\<lambda>k. denote (S ! k) (M k * \\<rho> * adjoint (M k))) 0) +\n        (trace (matrix_sum d (\\<lambda>k. M k * \\<rho> * adjoint (M k)) 0) -\n         trace\n          (matrix_sum d\n            (\\<lambda>k. denote (S ! k) (M k * \\<rho> * adjoint (M k))) 0))\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k \\<le> n \\<Longrightarrow>\n                trace\n                 (matrix_sum d (\\<lambda>k. adjoint (M k) * P k * M k) k *\n                  \\<rho>)\n                \\<le> trace\n                       (Q *\n                        matrix_sum d\n                         (\\<lambda>k.\n                             denote (S ! k) (M k * \\<rho> * adjoint (M k)))\n                         k) +\n                      (trace\n                        (matrix_sum d\n                          (\\<lambda>k. M k * \\<rho> * adjoint (M k)) k) -\n                       trace\n                        (matrix_sum d\n                          (\\<lambda>k.\n                              denote (S ! k) (M k * \\<rho> * adjoint (M k)))\n                          k));\n        Suc k \\<le> n\\<rbrakk>\n       \\<Longrightarrow> trace\n                          (matrix_sum d\n                            (\\<lambda>k. adjoint (M k) * P k * M k)\n                            (Suc k) *\n                           \\<rho>)\n                         \\<le> trace\n                                (Q *\n                                 matrix_sum d\n                                  (\\<lambda>k.\ndenote (S ! k) (M k * \\<rho> * adjoint (M k)))\n                                  (Suc k)) +\n                               (trace\n                                 (matrix_sum d\n                                   (\\<lambda>k.\n M k * \\<rho> * adjoint (M k))\n                                   (Suc k)) -\n                                trace\n                                 (matrix_sum d\n                                   (\\<lambda>k.\n denote (S ! k) (M k * \\<rho> * adjoint (M k)))\n                                   (Suc k)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k \\<le> n \\<Longrightarrow>\n                trace\n                 (matrix_sum d (\\<lambda>k. adjoint (M k) * P k * M k) k *\n                  \\<rho>)\n                \\<le> trace\n                       (Q *\n                        matrix_sum d\n                         (\\<lambda>k.\n                             denote (S ! k) (M k * \\<rho> * adjoint (M k)))\n                         k) +\n                      (trace\n                        (matrix_sum d\n                          (\\<lambda>k. M k * \\<rho> * adjoint (M k)) k) -\n                       trace\n                        (matrix_sum d\n                          (\\<lambda>k.\n                              denote (S ! k) (M k * \\<rho> * adjoint (M k)))\n                          k));\n        Suc k \\<le> n\\<rbrakk>\n       \\<Longrightarrow> trace\n                          (matrix_sum d\n                            (\\<lambda>k. adjoint (M k) * P k * M k)\n                            (Suc k) *\n                           \\<rho>)\n                         \\<le> trace\n                                (Q *\n                                 matrix_sum d\n                                  (\\<lambda>k.\ndenote (S ! k) (M k * \\<rho> * adjoint (M k)))\n                                  (Suc k)) +\n                               (trace\n                                 (matrix_sum d\n                                   (\\<lambda>k.\n M k * \\<rho> * adjoint (M k))\n                                   (Suc k)) -\n                                trace\n                                 (matrix_sum d\n                                   (\\<lambda>k.\n denote (S ! k) (M k * \\<rho> * adjoint (M k)))\n                                   (Suc k)))", "case (Suc k)"], ["proof (state)\nthis:\n  k \\<le> n \\<Longrightarrow>\n  trace (matrix_sum d (\\<lambda>k. adjoint (M k) * P k * M k) k * \\<rho>)\n  \\<le> trace\n         (Q *\n          matrix_sum d\n           (\\<lambda>k. denote (S ! k) (M k * \\<rho> * adjoint (M k))) k) +\n        (trace (matrix_sum d (\\<lambda>k. M k * \\<rho> * adjoint (M k)) k) -\n         trace\n          (matrix_sum d\n            (\\<lambda>k. denote (S ! k) (M k * \\<rho> * adjoint (M k))) k))\n  Suc k \\<le> n\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k \\<le> n \\<Longrightarrow>\n                trace\n                 (matrix_sum d (\\<lambda>k. adjoint (M k) * P k * M k) k *\n                  \\<rho>)\n                \\<le> trace\n                       (Q *\n                        matrix_sum d\n                         (\\<lambda>k.\n                             denote (S ! k) (M k * \\<rho> * adjoint (M k)))\n                         k) +\n                      (trace\n                        (matrix_sum d\n                          (\\<lambda>k. M k * \\<rho> * adjoint (M k)) k) -\n                       trace\n                        (matrix_sum d\n                          (\\<lambda>k.\n                              denote (S ! k) (M k * \\<rho> * adjoint (M k)))\n                          k));\n        Suc k \\<le> n\\<rbrakk>\n       \\<Longrightarrow> trace\n                          (matrix_sum d\n                            (\\<lambda>k. adjoint (M k) * P k * M k)\n                            (Suc k) *\n                           \\<rho>)\n                         \\<le> trace\n                                (Q *\n                                 matrix_sum d\n                                  (\\<lambda>k.\ndenote (S ! k) (M k * \\<rho> * adjoint (M k)))\n                                  (Suc k)) +\n                               (trace\n                                 (matrix_sum d\n                                   (\\<lambda>k.\n M k * \\<rho> * adjoint (M k))\n                                   (Suc k)) -\n                                trace\n                                 (matrix_sum d\n                                   (\\<lambda>k.\n denote (S ! k) (M k * \\<rho> * adjoint (M k)))\n                                   (Suc k)))", "then"], ["proof (chain)\npicking this:\n  k \\<le> n \\<Longrightarrow>\n  trace (matrix_sum d (\\<lambda>k. adjoint (M k) * P k * M k) k * \\<rho>)\n  \\<le> trace\n         (Q *\n          matrix_sum d\n           (\\<lambda>k. denote (S ! k) (M k * \\<rho> * adjoint (M k))) k) +\n        (trace (matrix_sum d (\\<lambda>k. M k * \\<rho> * adjoint (M k)) k) -\n         trace\n          (matrix_sum d\n            (\\<lambda>k. denote (S ! k) (M k * \\<rho> * adjoint (M k))) k))\n  Suc k \\<le> n", "have k: \"k < n\""], ["proof (prove)\nusing this:\n  k \\<le> n \\<Longrightarrow>\n  trace (matrix_sum d (\\<lambda>k. adjoint (M k) * P k * M k) k * \\<rho>)\n  \\<le> trace\n         (Q *\n          matrix_sum d\n           (\\<lambda>k. denote (S ! k) (M k * \\<rho> * adjoint (M k))) k) +\n        (trace (matrix_sum d (\\<lambda>k. M k * \\<rho> * adjoint (M k)) k) -\n         trace\n          (matrix_sum d\n            (\\<lambda>k. denote (S ! k) (M k * \\<rho> * adjoint (M k))) k))\n  Suc k \\<le> n\n\ngoal (1 subgoal):\n 1. k < n", "by auto"], ["proof (state)\nthis:\n  k < n\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k \\<le> n \\<Longrightarrow>\n                trace\n                 (matrix_sum d (\\<lambda>k. adjoint (M k) * P k * M k) k *\n                  \\<rho>)\n                \\<le> trace\n                       (Q *\n                        matrix_sum d\n                         (\\<lambda>k.\n                             denote (S ! k) (M k * \\<rho> * adjoint (M k)))\n                         k) +\n                      (trace\n                        (matrix_sum d\n                          (\\<lambda>k. M k * \\<rho> * adjoint (M k)) k) -\n                       trace\n                        (matrix_sum d\n                          (\\<lambda>k.\n                              denote (S ! k) (M k * \\<rho> * adjoint (M k)))\n                          k));\n        Suc k \\<le> n\\<rbrakk>\n       \\<Longrightarrow> trace\n                          (matrix_sum d\n                            (\\<lambda>k. adjoint (M k) * P k * M k)\n                            (Suc k) *\n                           \\<rho>)\n                         \\<le> trace\n                                (Q *\n                                 matrix_sum d\n                                  (\\<lambda>k.\ndenote (S ! k) (M k * \\<rho> * adjoint (M k)))\n                                  (Suc k)) +\n                               (trace\n                                 (matrix_sum d\n                                   (\\<lambda>k.\n M k * \\<rho> * adjoint (M k))\n                                   (Suc k)) -\n                                trace\n                                 (matrix_sum d\n                                   (\\<lambda>k.\n denote (S ! k) (M k * \\<rho> * adjoint (M k)))\n                                   (Suc k)))", "have eq1: \"trace (matrix_sum d (\\<lambda>k. adjoint (M k) * P k * M k) (Suc k) * \\<rho>) \n          = trace (adjoint (M k) * P k * M k * \\<rho>) + trace (matrix_sum d (\\<lambda>k. adjoint (M k) * P k * M k) k * \\<rho>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace\n     (matrix_sum d (\\<lambda>k. adjoint (M k) * P k * M k) (Suc k) *\n      \\<rho>) =\n    trace (adjoint (M k) * P k * M k * \\<rho>) +\n    trace (matrix_sum d (\\<lambda>k. adjoint (M k) * P k * M k) k * \\<rho>)", "unfolding matrix_sum.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. trace\n     ((adjoint (M k) * P k * M k +\n       matrix_sum d (\\<lambda>k. adjoint (M k) * P k * M k) k) *\n      \\<rho>) =\n    trace (adjoint (M k) * P k * M k * \\<rho>) +\n    trace (matrix_sum d (\\<lambda>k. adjoint (M k) * P k * M k) k * \\<rho>)", "using dMk[OF k] dPk[OF k] dr dsMP[OF k]"], ["proof (prove)\nusing this:\n  M k \\<in> carrier_mat d d\n  P k \\<in> carrier_mat d d\n  \\<rho> \\<in> carrier_mat d d\n  matrix_sum d (\\<lambda>k. adjoint (M k) * P k * M k) k\n  \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. trace\n     ((adjoint (M k) * P k * M k +\n       matrix_sum d (\\<lambda>k. adjoint (M k) * P k * M k) k) *\n      \\<rho>) =\n    trace (adjoint (M k) * P k * M k * \\<rho>) +\n    trace (matrix_sum d (\\<lambda>k. adjoint (M k) * P k * M k) k * \\<rho>)", "by (mat_assoc d)"], ["proof (state)\nthis:\n  trace\n   (matrix_sum d (\\<lambda>k. adjoint (M k) * P k * M k) (Suc k) * \\<rho>) =\n  trace (adjoint (M k) * P k * M k * \\<rho>) +\n  trace (matrix_sum d (\\<lambda>k. adjoint (M k) * P k * M k) k * \\<rho>)\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k \\<le> n \\<Longrightarrow>\n                trace\n                 (matrix_sum d (\\<lambda>k. adjoint (M k) * P k * M k) k *\n                  \\<rho>)\n                \\<le> trace\n                       (Q *\n                        matrix_sum d\n                         (\\<lambda>k.\n                             denote (S ! k) (M k * \\<rho> * adjoint (M k)))\n                         k) +\n                      (trace\n                        (matrix_sum d\n                          (\\<lambda>k. M k * \\<rho> * adjoint (M k)) k) -\n                       trace\n                        (matrix_sum d\n                          (\\<lambda>k.\n                              denote (S ! k) (M k * \\<rho> * adjoint (M k)))\n                          k));\n        Suc k \\<le> n\\<rbrakk>\n       \\<Longrightarrow> trace\n                          (matrix_sum d\n                            (\\<lambda>k. adjoint (M k) * P k * M k)\n                            (Suc k) *\n                           \\<rho>)\n                         \\<le> trace\n                                (Q *\n                                 matrix_sum d\n                                  (\\<lambda>k.\ndenote (S ! k) (M k * \\<rho> * adjoint (M k)))\n                                  (Suc k)) +\n                               (trace\n                                 (matrix_sum d\n                                   (\\<lambda>k.\n M k * \\<rho> * adjoint (M k))\n                                   (Suc k)) -\n                                trace\n                                 (matrix_sum d\n                                   (\\<lambda>k.\n denote (S ! k) (M k * \\<rho> * adjoint (M k)))\n                                   (Suc k)))", "have \"trace (adjoint (M k) * P k * M k * \\<rho>) = trace (P k * (M k * \\<rho> * adjoint (M k)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace (adjoint (M k) * P k * M k * \\<rho>) =\n    trace (P k * (M k * \\<rho> * adjoint (M k)))", "using dMk[OF k] dPk[OF k] dr"], ["proof (prove)\nusing this:\n  M k \\<in> carrier_mat d d\n  P k \\<in> carrier_mat d d\n  \\<rho> \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. trace (adjoint (M k) * P k * M k * \\<rho>) =\n    trace (P k * (M k * \\<rho> * adjoint (M k)))", "by (mat_assoc d)"], ["proof (state)\nthis:\n  trace (adjoint (M k) * P k * M k * \\<rho>) =\n  trace (P k * (M k * \\<rho> * adjoint (M k)))\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k \\<le> n \\<Longrightarrow>\n                trace\n                 (matrix_sum d (\\<lambda>k. adjoint (M k) * P k * M k) k *\n                  \\<rho>)\n                \\<le> trace\n                       (Q *\n                        matrix_sum d\n                         (\\<lambda>k.\n                             denote (S ! k) (M k * \\<rho> * adjoint (M k)))\n                         k) +\n                      (trace\n                        (matrix_sum d\n                          (\\<lambda>k. M k * \\<rho> * adjoint (M k)) k) -\n                       trace\n                        (matrix_sum d\n                          (\\<lambda>k.\n                              denote (S ! k) (M k * \\<rho> * adjoint (M k)))\n                          k));\n        Suc k \\<le> n\\<rbrakk>\n       \\<Longrightarrow> trace\n                          (matrix_sum d\n                            (\\<lambda>k. adjoint (M k) * P k * M k)\n                            (Suc k) *\n                           \\<rho>)\n                         \\<le> trace\n                                (Q *\n                                 matrix_sum d\n                                  (\\<lambda>k.\ndenote (S ! k) (M k * \\<rho> * adjoint (M k)))\n                                  (Suc k)) +\n                               (trace\n                                 (matrix_sum d\n                                   (\\<lambda>k.\n M k * \\<rho> * adjoint (M k))\n                                   (Suc k)) -\n                                trace\n                                 (matrix_sum d\n                                   (\\<lambda>k.\n denote (S ! k) (M k * \\<rho> * adjoint (M k)))\n                                   (Suc k)))", "also"], ["proof (state)\nthis:\n  trace (adjoint (M k) * P k * M k * \\<rho>) =\n  trace (P k * (M k * \\<rho> * adjoint (M k)))\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k \\<le> n \\<Longrightarrow>\n                trace\n                 (matrix_sum d (\\<lambda>k. adjoint (M k) * P k * M k) k *\n                  \\<rho>)\n                \\<le> trace\n                       (Q *\n                        matrix_sum d\n                         (\\<lambda>k.\n                             denote (S ! k) (M k * \\<rho> * adjoint (M k)))\n                         k) +\n                      (trace\n                        (matrix_sum d\n                          (\\<lambda>k. M k * \\<rho> * adjoint (M k)) k) -\n                       trace\n                        (matrix_sum d\n                          (\\<lambda>k.\n                              denote (S ! k) (M k * \\<rho> * adjoint (M k)))\n                          k));\n        Suc k \\<le> n\\<rbrakk>\n       \\<Longrightarrow> trace\n                          (matrix_sum d\n                            (\\<lambda>k. adjoint (M k) * P k * M k)\n                            (Suc k) *\n                           \\<rho>)\n                         \\<le> trace\n                                (Q *\n                                 matrix_sum d\n                                  (\\<lambda>k.\ndenote (S ! k) (M k * \\<rho> * adjoint (M k)))\n                                  (Suc k)) +\n                               (trace\n                                 (matrix_sum d\n                                   (\\<lambda>k.\n M k * \\<rho> * adjoint (M k))\n                                   (Suc k)) -\n                                trace\n                                 (matrix_sum d\n                                   (\\<lambda>k.\n denote (S ! k) (M k * \\<rho> * adjoint (M k)))\n                                   (Suc k)))", "have \"\\<dots> \\<le> trace (Q * (denote (S!k) ((M k) * \\<rho> * adjoint (M k)))) + \n          (trace ((M k) * \\<rho> * adjoint (M k)) - trace (denote (S ! k) ((M k) * \\<rho> * adjoint (M k))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace (P k * (M k * \\<rho> * adjoint (M k)))\n    \\<le> trace (Q * denote (S ! k) (M k * \\<rho> * adjoint (M k))) +\n          (trace (M k * \\<rho> * adjoint (M k)) -\n           trace (denote (S ! k) (M k * \\<rho> * adjoint (M k))))", "using leqk k"], ["proof (prove)\nusing this:\n  ?k < n \\<Longrightarrow>\n  trace (P ?k * (M ?k * \\<rho> * adjoint (M ?k)))\n  \\<le> trace (Q * denote (S ! ?k) (M ?k * \\<rho> * adjoint (M ?k))) +\n        (trace (M ?k * \\<rho> * adjoint (M ?k)) -\n         trace (denote (S ! ?k) (M ?k * \\<rho> * adjoint (M ?k))))\n  k < n\n\ngoal (1 subgoal):\n 1. trace (P k * (M k * \\<rho> * adjoint (M k)))\n    \\<le> trace (Q * denote (S ! k) (M k * \\<rho> * adjoint (M k))) +\n          (trace (M k * \\<rho> * adjoint (M k)) -\n           trace (denote (S ! k) (M k * \\<rho> * adjoint (M k))))", "by auto"], ["proof (state)\nthis:\n  trace (P k * (M k * \\<rho> * adjoint (M k)))\n  \\<le> trace (Q * denote (S ! k) (M k * \\<rho> * adjoint (M k))) +\n        (trace (M k * \\<rho> * adjoint (M k)) -\n         trace (denote (S ! k) (M k * \\<rho> * adjoint (M k))))\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k \\<le> n \\<Longrightarrow>\n                trace\n                 (matrix_sum d (\\<lambda>k. adjoint (M k) * P k * M k) k *\n                  \\<rho>)\n                \\<le> trace\n                       (Q *\n                        matrix_sum d\n                         (\\<lambda>k.\n                             denote (S ! k) (M k * \\<rho> * adjoint (M k)))\n                         k) +\n                      (trace\n                        (matrix_sum d\n                          (\\<lambda>k. M k * \\<rho> * adjoint (M k)) k) -\n                       trace\n                        (matrix_sum d\n                          (\\<lambda>k.\n                              denote (S ! k) (M k * \\<rho> * adjoint (M k)))\n                          k));\n        Suc k \\<le> n\\<rbrakk>\n       \\<Longrightarrow> trace\n                          (matrix_sum d\n                            (\\<lambda>k. adjoint (M k) * P k * M k)\n                            (Suc k) *\n                           \\<rho>)\n                         \\<le> trace\n                                (Q *\n                                 matrix_sum d\n                                  (\\<lambda>k.\ndenote (S ! k) (M k * \\<rho> * adjoint (M k)))\n                                  (Suc k)) +\n                               (trace\n                                 (matrix_sum d\n                                   (\\<lambda>k.\n M k * \\<rho> * adjoint (M k))\n                                   (Suc k)) -\n                                trace\n                                 (matrix_sum d\n                                   (\\<lambda>k.\n denote (S ! k) (M k * \\<rho> * adjoint (M k)))\n                                   (Suc k)))", "finally"], ["proof (chain)\npicking this:\n  trace (adjoint (M k) * P k * M k * \\<rho>)\n  \\<le> trace (Q * denote (S ! k) (M k * \\<rho> * adjoint (M k))) +\n        (trace (M k * \\<rho> * adjoint (M k)) -\n         trace (denote (S ! k) (M k * \\<rho> * adjoint (M k))))", "have eq2: \"trace (adjoint (M k) * P k * M k * \\<rho>) \\<le> trace (Q * (denote (S!k) ((M k) * \\<rho> * adjoint (M k)))) + \n          (trace ((M k) * \\<rho> * adjoint (M k)) - trace (denote (S ! k) ((M k) * \\<rho> * adjoint (M k))))\""], ["proof (prove)\nusing this:\n  trace (adjoint (M k) * P k * M k * \\<rho>)\n  \\<le> trace (Q * denote (S ! k) (M k * \\<rho> * adjoint (M k))) +\n        (trace (M k * \\<rho> * adjoint (M k)) -\n         trace (denote (S ! k) (M k * \\<rho> * adjoint (M k))))\n\ngoal (1 subgoal):\n 1. trace (adjoint (M k) * P k * M k * \\<rho>)\n    \\<le> trace (Q * denote (S ! k) (M k * \\<rho> * adjoint (M k))) +\n          (trace (M k * \\<rho> * adjoint (M k)) -\n           trace (denote (S ! k) (M k * \\<rho> * adjoint (M k))))", "."], ["proof (state)\nthis:\n  trace (adjoint (M k) * P k * M k * \\<rho>)\n  \\<le> trace (Q * denote (S ! k) (M k * \\<rho> * adjoint (M k))) +\n        (trace (M k * \\<rho> * adjoint (M k)) -\n         trace (denote (S ! k) (M k * \\<rho> * adjoint (M k))))\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k \\<le> n \\<Longrightarrow>\n                trace\n                 (matrix_sum d (\\<lambda>k. adjoint (M k) * P k * M k) k *\n                  \\<rho>)\n                \\<le> trace\n                       (Q *\n                        matrix_sum d\n                         (\\<lambda>k.\n                             denote (S ! k) (M k * \\<rho> * adjoint (M k)))\n                         k) +\n                      (trace\n                        (matrix_sum d\n                          (\\<lambda>k. M k * \\<rho> * adjoint (M k)) k) -\n                       trace\n                        (matrix_sum d\n                          (\\<lambda>k.\n                              denote (S ! k) (M k * \\<rho> * adjoint (M k)))\n                          k));\n        Suc k \\<le> n\\<rbrakk>\n       \\<Longrightarrow> trace\n                          (matrix_sum d\n                            (\\<lambda>k. adjoint (M k) * P k * M k)\n                            (Suc k) *\n                           \\<rho>)\n                         \\<le> trace\n                                (Q *\n                                 matrix_sum d\n                                  (\\<lambda>k.\ndenote (S ! k) (M k * \\<rho> * adjoint (M k)))\n                                  (Suc k)) +\n                               (trace\n                                 (matrix_sum d\n                                   (\\<lambda>k.\n M k * \\<rho> * adjoint (M k))\n                                   (Suc k)) -\n                                trace\n                                 (matrix_sum d\n                                   (\\<lambda>k.\n denote (S ! k) (M k * \\<rho> * adjoint (M k)))\n                                   (Suc k)))", "have eq3: \"trace (Q * matrix_sum d (\\<lambda>k. denote (S!k) (M k * \\<rho> * adjoint (M k))) (Suc k)) \n          = trace (Q * (denote (S!k) (M k * \\<rho> * adjoint (M k)))) + trace (Q * matrix_sum d (\\<lambda>k. denote (S!k) (M k * \\<rho> * adjoint (M k))) k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace\n     (Q *\n      matrix_sum d\n       (\\<lambda>k. denote (S ! k) (M k * \\<rho> * adjoint (M k)))\n       (Suc k)) =\n    trace (Q * denote (S ! k) (M k * \\<rho> * adjoint (M k))) +\n    trace\n     (Q *\n      matrix_sum d\n       (\\<lambda>k. denote (S ! k) (M k * \\<rho> * adjoint (M k))) k)", "unfolding matrix_sum.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. trace\n     (Q *\n      (denote (S ! k) (M k * \\<rho> * adjoint (M k)) +\n       matrix_sum d\n        (\\<lambda>k. denote (S ! k) (M k * \\<rho> * adjoint (M k))) k)) =\n    trace (Q * denote (S ! k) (M k * \\<rho> * adjoint (M k))) +\n    trace\n     (Q *\n      matrix_sum d\n       (\\<lambda>k. denote (S ! k) (M k * \\<rho> * adjoint (M k))) k)", "using dQ dSMrk[OF k] dsSMrk[OF k]"], ["proof (prove)\nusing this:\n  Q \\<in> carrier_mat d d\n  denote (S ! k) (M k * \\<rho> * adjoint (M k)) \\<in> carrier_mat d d\n  matrix_sum d (\\<lambda>k. denote (S ! k) (M k * \\<rho> * adjoint (M k))) k\n  \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. trace\n     (Q *\n      (denote (S ! k) (M k * \\<rho> * adjoint (M k)) +\n       matrix_sum d\n        (\\<lambda>k. denote (S ! k) (M k * \\<rho> * adjoint (M k))) k)) =\n    trace (Q * denote (S ! k) (M k * \\<rho> * adjoint (M k))) +\n    trace\n     (Q *\n      matrix_sum d\n       (\\<lambda>k. denote (S ! k) (M k * \\<rho> * adjoint (M k))) k)", "by (mat_assoc d)"], ["proof (state)\nthis:\n  trace\n   (Q *\n    matrix_sum d (\\<lambda>k. denote (S ! k) (M k * \\<rho> * adjoint (M k)))\n     (Suc k)) =\n  trace (Q * denote (S ! k) (M k * \\<rho> * adjoint (M k))) +\n  trace\n   (Q *\n    matrix_sum d (\\<lambda>k. denote (S ! k) (M k * \\<rho> * adjoint (M k)))\n     k)\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k \\<le> n \\<Longrightarrow>\n                trace\n                 (matrix_sum d (\\<lambda>k. adjoint (M k) * P k * M k) k *\n                  \\<rho>)\n                \\<le> trace\n                       (Q *\n                        matrix_sum d\n                         (\\<lambda>k.\n                             denote (S ! k) (M k * \\<rho> * adjoint (M k)))\n                         k) +\n                      (trace\n                        (matrix_sum d\n                          (\\<lambda>k. M k * \\<rho> * adjoint (M k)) k) -\n                       trace\n                        (matrix_sum d\n                          (\\<lambda>k.\n                              denote (S ! k) (M k * \\<rho> * adjoint (M k)))\n                          k));\n        Suc k \\<le> n\\<rbrakk>\n       \\<Longrightarrow> trace\n                          (matrix_sum d\n                            (\\<lambda>k. adjoint (M k) * P k * M k)\n                            (Suc k) *\n                           \\<rho>)\n                         \\<le> trace\n                                (Q *\n                                 matrix_sum d\n                                  (\\<lambda>k.\ndenote (S ! k) (M k * \\<rho> * adjoint (M k)))\n                                  (Suc k)) +\n                               (trace\n                                 (matrix_sum d\n                                   (\\<lambda>k.\n M k * \\<rho> * adjoint (M k))\n                                   (Suc k)) -\n                                trace\n                                 (matrix_sum d\n                                   (\\<lambda>k.\n denote (S ! k) (M k * \\<rho> * adjoint (M k)))\n                                   (Suc k)))", "have eq4: \"trace (denote (S ! k) (M k * \\<rho> * adjoint (M k)) + matrix_sum d (\\<lambda>k. denote (S!k) (M k * \\<rho> * adjoint (M k))) k)\n          = trace (denote (S ! k) (M k * \\<rho> * adjoint (M k))) + trace (matrix_sum d (\\<lambda>k. denote (S!k) (M k * \\<rho> * adjoint (M k))) k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace\n     (denote (S ! k) (M k * \\<rho> * adjoint (M k)) +\n      matrix_sum d\n       (\\<lambda>k. denote (S ! k) (M k * \\<rho> * adjoint (M k))) k) =\n    trace (denote (S ! k) (M k * \\<rho> * adjoint (M k))) +\n    trace\n     (matrix_sum d\n       (\\<lambda>k. denote (S ! k) (M k * \\<rho> * adjoint (M k))) k)", "using dSMrk[OF k] dsSMrk[OF k]"], ["proof (prove)\nusing this:\n  denote (S ! k) (M k * \\<rho> * adjoint (M k)) \\<in> carrier_mat d d\n  matrix_sum d (\\<lambda>k. denote (S ! k) (M k * \\<rho> * adjoint (M k))) k\n  \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. trace\n     (denote (S ! k) (M k * \\<rho> * adjoint (M k)) +\n      matrix_sum d\n       (\\<lambda>k. denote (S ! k) (M k * \\<rho> * adjoint (M k))) k) =\n    trace (denote (S ! k) (M k * \\<rho> * adjoint (M k))) +\n    trace\n     (matrix_sum d\n       (\\<lambda>k. denote (S ! k) (M k * \\<rho> * adjoint (M k))) k)", "by (mat_assoc d)"], ["proof (state)\nthis:\n  trace\n   (denote (S ! k) (M k * \\<rho> * adjoint (M k)) +\n    matrix_sum d (\\<lambda>k. denote (S ! k) (M k * \\<rho> * adjoint (M k)))\n     k) =\n  trace (denote (S ! k) (M k * \\<rho> * adjoint (M k))) +\n  trace\n   (matrix_sum d (\\<lambda>k. denote (S ! k) (M k * \\<rho> * adjoint (M k)))\n     k)\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k \\<le> n \\<Longrightarrow>\n                trace\n                 (matrix_sum d (\\<lambda>k. adjoint (M k) * P k * M k) k *\n                  \\<rho>)\n                \\<le> trace\n                       (Q *\n                        matrix_sum d\n                         (\\<lambda>k.\n                             denote (S ! k) (M k * \\<rho> * adjoint (M k)))\n                         k) +\n                      (trace\n                        (matrix_sum d\n                          (\\<lambda>k. M k * \\<rho> * adjoint (M k)) k) -\n                       trace\n                        (matrix_sum d\n                          (\\<lambda>k.\n                              denote (S ! k) (M k * \\<rho> * adjoint (M k)))\n                          k));\n        Suc k \\<le> n\\<rbrakk>\n       \\<Longrightarrow> trace\n                          (matrix_sum d\n                            (\\<lambda>k. adjoint (M k) * P k * M k)\n                            (Suc k) *\n                           \\<rho>)\n                         \\<le> trace\n                                (Q *\n                                 matrix_sum d\n                                  (\\<lambda>k.\ndenote (S ! k) (M k * \\<rho> * adjoint (M k)))\n                                  (Suc k)) +\n                               (trace\n                                 (matrix_sum d\n                                   (\\<lambda>k.\n M k * \\<rho> * adjoint (M k))\n                                   (Suc k)) -\n                                trace\n                                 (matrix_sum d\n                                   (\\<lambda>k.\n denote (S ! k) (M k * \\<rho> * adjoint (M k)))\n                                   (Suc k)))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. trace\n     (matrix_sum d (\\<lambda>k. adjoint (M k) * P k * M k) (Suc k) * \\<rho>)\n    \\<le> trace\n           (Q *\n            matrix_sum d\n             (\\<lambda>k. denote (S ! k) (M k * \\<rho> * adjoint (M k)))\n             (Suc k)) +\n          (trace\n            (matrix_sum d (\\<lambda>k. M k * \\<rho> * adjoint (M k))\n              (Suc k)) -\n           trace\n            (matrix_sum d\n              (\\<lambda>k. denote (S ! k) (M k * \\<rho> * adjoint (M k)))\n              (Suc k)))", "apply (subst eq1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. trace (adjoint (M k) * P k * M k * \\<rho>) +\n    trace (matrix_sum d (\\<lambda>k. adjoint (M k) * P k * M k) k * \\<rho>)\n    \\<le> trace\n           (Q *\n            matrix_sum d\n             (\\<lambda>k. denote (S ! k) (M k * \\<rho> * adjoint (M k)))\n             (Suc k)) +\n          (trace\n            (matrix_sum d (\\<lambda>k. M k * \\<rho> * adjoint (M k))\n              (Suc k)) -\n           trace\n            (matrix_sum d\n              (\\<lambda>k. denote (S ! k) (M k * \\<rho> * adjoint (M k)))\n              (Suc k)))", "apply (subst eq3)"], ["proof (prove)\ngoal (1 subgoal):\n 1. trace (adjoint (M k) * P k * M k * \\<rho>) +\n    trace (matrix_sum d (\\<lambda>k. adjoint (M k) * P k * M k) k * \\<rho>)\n    \\<le> trace (Q * denote (S ! k) (M k * \\<rho> * adjoint (M k))) +\n          trace\n           (Q *\n            matrix_sum d\n             (\\<lambda>k. denote (S ! k) (M k * \\<rho> * adjoint (M k)))\n             k) +\n          (trace\n            (matrix_sum d (\\<lambda>k. M k * \\<rho> * adjoint (M k))\n              (Suc k)) -\n           trace\n            (matrix_sum d\n              (\\<lambda>k. denote (S ! k) (M k * \\<rho> * adjoint (M k)))\n              (Suc k)))", "apply (simp del: less_eq_complex_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. trace (adjoint (M k) * P k * M k * \\<rho>) +\n    trace (matrix_sum d (\\<lambda>k. adjoint (M k) * P k * M k) k * \\<rho>)\n    \\<le> trace (Q * denote (S ! k) (M k * \\<rho> * adjoint (M k))) +\n          trace\n           (Q *\n            matrix_sum d\n             (\\<lambda>k. denote (S ! k) (M k * \\<rho> * adjoint (M k)))\n             k) +\n          (trace\n            (M k * \\<rho> * adjoint (M k) +\n             matrix_sum d (\\<lambda>k. M k * \\<rho> * adjoint (M k)) k) -\n           trace\n            (denote (S ! k) (M k * \\<rho> * adjoint (M k)) +\n             matrix_sum d\n              (\\<lambda>k. denote (S ! k) (M k * \\<rho> * adjoint (M k)))\n              k))", "apply (subst trace_add_linear[of \"M k * \\<rho> * adjoint (M k)\" d \"matrix_sum d (\\<lambda>k. M k * \\<rho> * adjoint (M k)) k\"])"], ["proof (prove)\ngoal (3 subgoals):\n 1. M k * \\<rho> * adjoint (M k) \\<in> carrier_mat d d\n 2. matrix_sum d (\\<lambda>k. M k * \\<rho> * adjoint (M k)) k\n    \\<in> carrier_mat d d\n 3. trace (adjoint (M k) * P k * M k * \\<rho>) +\n    trace (matrix_sum d (\\<lambda>k. adjoint (M k) * P k * M k) k * \\<rho>)\n    \\<le> trace (Q * denote (S ! k) (M k * \\<rho> * adjoint (M k))) +\n          trace\n           (Q *\n            matrix_sum d\n             (\\<lambda>k. denote (S ! k) (M k * \\<rho> * adjoint (M k)))\n             k) +\n          (trace (M k * \\<rho> * adjoint (M k)) +\n           trace\n            (matrix_sum d (\\<lambda>k. M k * \\<rho> * adjoint (M k)) k) -\n           trace\n            (denote (S ! k) (M k * \\<rho> * adjoint (M k)) +\n             matrix_sum d\n              (\\<lambda>k. denote (S ! k) (M k * \\<rho> * adjoint (M k)))\n              k))", "apply (simp add: dMk adjoint_dim[OF dMk] dr mult_carrier_mat[of _ d d _ d] k)"], ["proof (prove)\ngoal (2 subgoals):\n 1. matrix_sum d (\\<lambda>k. M k * \\<rho> * adjoint (M k)) k\n    \\<in> carrier_mat d d\n 2. trace (adjoint (M k) * P k * M k * \\<rho>) +\n    trace (matrix_sum d (\\<lambda>k. adjoint (M k) * P k * M k) k * \\<rho>)\n    \\<le> trace (Q * denote (S ! k) (M k * \\<rho> * adjoint (M k))) +\n          trace\n           (Q *\n            matrix_sum d\n             (\\<lambda>k. denote (S ! k) (M k * \\<rho> * adjoint (M k)))\n             k) +\n          (trace (M k * \\<rho> * adjoint (M k)) +\n           trace\n            (matrix_sum d (\\<lambda>k. M k * \\<rho> * adjoint (M k)) k) -\n           trace\n            (denote (S ! k) (M k * \\<rho> * adjoint (M k)) +\n             matrix_sum d\n              (\\<lambda>k. denote (S ! k) (M k * \\<rho> * adjoint (M k)))\n              k))", "apply (simp add: dsMrk k)"], ["proof (prove)\ngoal (1 subgoal):\n 1. trace (adjoint (M k) * P k * M k * \\<rho>) +\n    trace (matrix_sum d (\\<lambda>k. adjoint (M k) * P k * M k) k * \\<rho>)\n    \\<le> trace (Q * denote (S ! k) (M k * \\<rho> * adjoint (M k))) +\n          trace\n           (Q *\n            matrix_sum d\n             (\\<lambda>k. denote (S ! k) (M k * \\<rho> * adjoint (M k)))\n             k) +\n          (trace (M k * \\<rho> * adjoint (M k)) +\n           trace\n            (matrix_sum d (\\<lambda>k. M k * \\<rho> * adjoint (M k)) k) -\n           trace\n            (denote (S ! k) (M k * \\<rho> * adjoint (M k)) +\n             matrix_sum d\n              (\\<lambda>k. denote (S ! k) (M k * \\<rho> * adjoint (M k)))\n              k))", "apply (subst eq4)"], ["proof (prove)\ngoal (1 subgoal):\n 1. trace (adjoint (M k) * P k * M k * \\<rho>) +\n    trace (matrix_sum d (\\<lambda>k. adjoint (M k) * P k * M k) k * \\<rho>)\n    \\<le> trace (Q * denote (S ! k) (M k * \\<rho> * adjoint (M k))) +\n          trace\n           (Q *\n            matrix_sum d\n             (\\<lambda>k. denote (S ! k) (M k * \\<rho> * adjoint (M k)))\n             k) +\n          (trace (M k * \\<rho> * adjoint (M k)) +\n           trace\n            (matrix_sum d (\\<lambda>k. M k * \\<rho> * adjoint (M k)) k) -\n           (trace (denote (S ! k) (M k * \\<rho> * adjoint (M k))) +\n            trace\n             (matrix_sum d\n               (\\<lambda>k. denote (S ! k) (M k * \\<rho> * adjoint (M k)))\n               k)))", "apply (insert eq2 Suc(1) k, fastforce)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  trace\n   (matrix_sum d (\\<lambda>k. adjoint (M k) * P k * M k) (Suc k) * \\<rho>)\n  \\<le> trace\n         (Q *\n          matrix_sum d\n           (\\<lambda>k. denote (S ! k) (M k * \\<rho> * adjoint (M k)))\n           (Suc k)) +\n        (trace\n          (matrix_sum d (\\<lambda>k. M k * \\<rho> * adjoint (M k))\n            (Suc k)) -\n         trace\n          (matrix_sum d\n            (\\<lambda>k. denote (S ! k) (M k * \\<rho> * adjoint (M k)))\n            (Suc k)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?k \\<le> n \\<Longrightarrow>\n  trace (matrix_sum d (\\<lambda>k. adjoint (M k) * P k * M k) ?k * \\<rho>)\n  \\<le> trace (Q * denote (Measure ?k M S) \\<rho>) +\n        (trace\n          (matrix_sum d (\\<lambda>k. M k * \\<rho> * adjoint (M k)) ?k) -\n         trace (denote (Measure ?k M S) \\<rho>))\n\ngoal (3 subgoals):\n 1. \\<And>n P Q S M.\n       \\<lbrakk>\\<And>k. k < n \\<Longrightarrow> is_quantum_predicate (P k);\n        is_quantum_predicate Q;\n        \\<And>k.\n           k < n \\<Longrightarrow> \\<turnstile>\\<^sub>p {P k} S ! k {Q};\n        \\<And>k.\n           \\<lbrakk>k < n; well_com (S ! k)\\<rbrakk>\n           \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P k} S ! k {Q};\n        well_com (Measure n M S)\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {matrix_sum d\n          (\\<lambda>k. adjoint (M k) * P k * M k) n}\n                         Measure n M S {Q}\n 2. \\<And>P Q S M.\n       \\<lbrakk>is_quantum_predicate P; is_quantum_predicate Q;\n        \\<turnstile>\\<^sub>p {Q} S\n                             {adjoint (M 0) * P * M 0 +\n                              adjoint (M 1) * Q * M 1};\n        well_com S \\<Longrightarrow>\n        \\<Turnstile>\\<^sub>p {Q} S\n        {adjoint (M 0) * P * M 0 + adjoint (M 1) * Q * M 1};\n        well_com (While M S)\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {adjoint (M 0) * P * M 0 +\n         adjoint (M 1) * Q * M 1}\n                         While M S {P}\n 3. \\<And>P Q P' Q' S.\n       \\<lbrakk>is_quantum_predicate P; is_quantum_predicate Q;\n        is_quantum_predicate P'; is_quantum_predicate Q';\n        P \\<le>\\<^sub>L P'; \\<turnstile>\\<^sub>p {P'} S {Q'};\n        well_com S \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P'} S {Q'};\n        Q' \\<le>\\<^sub>L Q; well_com S\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P} S {Q}", "then"], ["proof (chain)\npicking this:\n  ?k \\<le> n \\<Longrightarrow>\n  trace (matrix_sum d (\\<lambda>k. adjoint (M k) * P k * M k) ?k * \\<rho>)\n  \\<le> trace (Q * denote (Measure ?k M S) \\<rho>) +\n        (trace\n          (matrix_sum d (\\<lambda>k. M k * \\<rho> * adjoint (M k)) ?k) -\n         trace (denote (Measure ?k M S) \\<rho>))", "have leq: \"trace (matrix_sum d (\\<lambda>k. adjoint (M k) * P k * M k) n * \\<rho>)\n         \\<le> trace (Q * denote (Measure n M S) \\<rho>) + \n            (trace (matrix_sum d (\\<lambda>k. (M k) * \\<rho> * adjoint (M k)) n) - trace (denote (Measure n M S) \\<rho>))\""], ["proof (prove)\nusing this:\n  ?k \\<le> n \\<Longrightarrow>\n  trace (matrix_sum d (\\<lambda>k. adjoint (M k) * P k * M k) ?k * \\<rho>)\n  \\<le> trace (Q * denote (Measure ?k M S) \\<rho>) +\n        (trace\n          (matrix_sum d (\\<lambda>k. M k * \\<rho> * adjoint (M k)) ?k) -\n         trace (denote (Measure ?k M S) \\<rho>))\n\ngoal (1 subgoal):\n 1. trace (matrix_sum d (\\<lambda>k. adjoint (M k) * P k * M k) n * \\<rho>)\n    \\<le> trace (Q * denote (Measure n M S) \\<rho>) +\n          (trace\n            (matrix_sum d (\\<lambda>k. M k * \\<rho> * adjoint (M k)) n) -\n           trace (denote (Measure n M S) \\<rho>))", "by auto"], ["proof (state)\nthis:\n  trace (matrix_sum d (\\<lambda>k. adjoint (M k) * P k * M k) n * \\<rho>)\n  \\<le> trace (Q * denote (Measure n M S) \\<rho>) +\n        (trace (matrix_sum d (\\<lambda>k. M k * \\<rho> * adjoint (M k)) n) -\n         trace (denote (Measure n M S) \\<rho>))\n\ngoal (3 subgoals):\n 1. \\<And>n P Q S M.\n       \\<lbrakk>\\<And>k. k < n \\<Longrightarrow> is_quantum_predicate (P k);\n        is_quantum_predicate Q;\n        \\<And>k.\n           k < n \\<Longrightarrow> \\<turnstile>\\<^sub>p {P k} S ! k {Q};\n        \\<And>k.\n           \\<lbrakk>k < n; well_com (S ! k)\\<rbrakk>\n           \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P k} S ! k {Q};\n        well_com (Measure n M S)\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {matrix_sum d\n          (\\<lambda>k. adjoint (M k) * P k * M k) n}\n                         Measure n M S {Q}\n 2. \\<And>P Q S M.\n       \\<lbrakk>is_quantum_predicate P; is_quantum_predicate Q;\n        \\<turnstile>\\<^sub>p {Q} S\n                             {adjoint (M 0) * P * M 0 +\n                              adjoint (M 1) * Q * M 1};\n        well_com S \\<Longrightarrow>\n        \\<Turnstile>\\<^sub>p {Q} S\n        {adjoint (M 0) * P * M 0 + adjoint (M 1) * Q * M 1};\n        well_com (While M S)\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {adjoint (M 0) * P * M 0 +\n         adjoint (M 1) * Q * M 1}\n                         While M S {P}\n 3. \\<And>P Q P' Q' S.\n       \\<lbrakk>is_quantum_predicate P; is_quantum_predicate Q;\n        is_quantum_predicate P'; is_quantum_predicate Q';\n        P \\<le>\\<^sub>L P'; \\<turnstile>\\<^sub>p {P'} S {Q'};\n        well_com S \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P'} S {Q'};\n        Q' \\<le>\\<^sub>L Q; well_com S\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P} S {Q}", "have \"trace (matrix_sum d (\\<lambda>k. (M k) * \\<rho> * adjoint (M k)) n) = trace \\<rho>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace (matrix_sum d (\\<lambda>k. M k * \\<rho> * adjoint (M k)) n) =\n    trace \\<rho>", "using trace_measurement m dr"], ["proof (prove)\nusing this:\n  \\<lbrakk>measurement ?d ?n ?M; ?A \\<in> carrier_mat ?d ?d\\<rbrakk>\n  \\<Longrightarrow> trace\n                     (matrix_sum ?d (\\<lambda>k. ?M k * ?A * adjoint (?M k))\n                       ?n) =\n                    trace ?A\n  measurement d n M\n  \\<rho> \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. trace (matrix_sum d (\\<lambda>k. M k * \\<rho> * adjoint (M k)) n) =\n    trace \\<rho>", "by auto"], ["proof (state)\nthis:\n  trace (matrix_sum d (\\<lambda>k. M k * \\<rho> * adjoint (M k)) n) =\n  trace \\<rho>\n\ngoal (3 subgoals):\n 1. \\<And>n P Q S M.\n       \\<lbrakk>\\<And>k. k < n \\<Longrightarrow> is_quantum_predicate (P k);\n        is_quantum_predicate Q;\n        \\<And>k.\n           k < n \\<Longrightarrow> \\<turnstile>\\<^sub>p {P k} S ! k {Q};\n        \\<And>k.\n           \\<lbrakk>k < n; well_com (S ! k)\\<rbrakk>\n           \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P k} S ! k {Q};\n        well_com (Measure n M S)\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {matrix_sum d\n          (\\<lambda>k. adjoint (M k) * P k * M k) n}\n                         Measure n M S {Q}\n 2. \\<And>P Q S M.\n       \\<lbrakk>is_quantum_predicate P; is_quantum_predicate Q;\n        \\<turnstile>\\<^sub>p {Q} S\n                             {adjoint (M 0) * P * M 0 +\n                              adjoint (M 1) * Q * M 1};\n        well_com S \\<Longrightarrow>\n        \\<Turnstile>\\<^sub>p {Q} S\n        {adjoint (M 0) * P * M 0 + adjoint (M 1) * Q * M 1};\n        well_com (While M S)\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {adjoint (M 0) * P * M 0 +\n         adjoint (M 1) * Q * M 1}\n                         While M S {P}\n 3. \\<And>P Q P' Q' S.\n       \\<lbrakk>is_quantum_predicate P; is_quantum_predicate Q;\n        is_quantum_predicate P'; is_quantum_predicate Q';\n        P \\<le>\\<^sub>L P'; \\<turnstile>\\<^sub>p {P'} S {Q'};\n        well_com S \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P'} S {Q'};\n        Q' \\<le>\\<^sub>L Q; well_com S\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P} S {Q}", "with leq"], ["proof (chain)\npicking this:\n  trace (matrix_sum d (\\<lambda>k. adjoint (M k) * P k * M k) n * \\<rho>)\n  \\<le> trace (Q * denote (Measure n M S) \\<rho>) +\n        (trace (matrix_sum d (\\<lambda>k. M k * \\<rho> * adjoint (M k)) n) -\n         trace (denote (Measure n M S) \\<rho>))\n  trace (matrix_sum d (\\<lambda>k. M k * \\<rho> * adjoint (M k)) n) =\n  trace \\<rho>", "have \"trace (matrix_sum d (\\<lambda>k. adjoint (M k) * P k * M k) n * \\<rho>)\n         \\<le> trace (Q * denote (Measure n M S) \\<rho>) + (trace \\<rho> - trace (denote (Measure n M S) \\<rho>))\""], ["proof (prove)\nusing this:\n  trace (matrix_sum d (\\<lambda>k. adjoint (M k) * P k * M k) n * \\<rho>)\n  \\<le> trace (Q * denote (Measure n M S) \\<rho>) +\n        (trace (matrix_sum d (\\<lambda>k. M k * \\<rho> * adjoint (M k)) n) -\n         trace (denote (Measure n M S) \\<rho>))\n  trace (matrix_sum d (\\<lambda>k. M k * \\<rho> * adjoint (M k)) n) =\n  trace \\<rho>\n\ngoal (1 subgoal):\n 1. trace (matrix_sum d (\\<lambda>k. adjoint (M k) * P k * M k) n * \\<rho>)\n    \\<le> trace (Q * denote (Measure n M S) \\<rho>) +\n          (trace \\<rho> - trace (denote (Measure n M S) \\<rho>))", "unfolding denote_measure_def"], ["proof (prove)\nusing this:\n  trace (matrix_sum d (\\<lambda>k. adjoint (M k) * P k * M k) n * \\<rho>)\n  \\<le> trace (Q * denote (Measure n M S) \\<rho>) +\n        (trace (matrix_sum d (\\<lambda>k. M k * \\<rho> * adjoint (M k)) n) -\n         trace (denote (Measure n M S) \\<rho>))\n  trace (matrix_sum d (\\<lambda>k. M k * \\<rho> * adjoint (M k)) n) =\n  trace \\<rho>\n\ngoal (1 subgoal):\n 1. trace (matrix_sum d (\\<lambda>k. adjoint (M k) * P k * M k) n * \\<rho>)\n    \\<le> trace (Q * denote (Measure n M S) \\<rho>) +\n          (trace \\<rho> - trace (denote (Measure n M S) \\<rho>))", "by auto"], ["proof (state)\nthis:\n  trace (matrix_sum d (\\<lambda>k. adjoint (M k) * P k * M k) n * \\<rho>)\n  \\<le> trace (Q * denote (Measure n M S) \\<rho>) +\n        (trace \\<rho> - trace (denote (Measure n M S) \\<rho>))\n\ngoal (3 subgoals):\n 1. \\<And>n P Q S M.\n       \\<lbrakk>\\<And>k. k < n \\<Longrightarrow> is_quantum_predicate (P k);\n        is_quantum_predicate Q;\n        \\<And>k.\n           k < n \\<Longrightarrow> \\<turnstile>\\<^sub>p {P k} S ! k {Q};\n        \\<And>k.\n           \\<lbrakk>k < n; well_com (S ! k)\\<rbrakk>\n           \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P k} S ! k {Q};\n        well_com (Measure n M S)\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {matrix_sum d\n          (\\<lambda>k. adjoint (M k) * P k * M k) n}\n                         Measure n M S {Q}\n 2. \\<And>P Q S M.\n       \\<lbrakk>is_quantum_predicate P; is_quantum_predicate Q;\n        \\<turnstile>\\<^sub>p {Q} S\n                             {adjoint (M 0) * P * M 0 +\n                              adjoint (M 1) * Q * M 1};\n        well_com S \\<Longrightarrow>\n        \\<Turnstile>\\<^sub>p {Q} S\n        {adjoint (M 0) * P * M 0 + adjoint (M 1) * Q * M 1};\n        well_com (While M S)\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {adjoint (M 0) * P * M 0 +\n         adjoint (M 1) * Q * M 1}\n                         While M S {P}\n 3. \\<And>P Q P' Q' S.\n       \\<lbrakk>is_quantum_predicate P; is_quantum_predicate Q;\n        is_quantum_predicate P'; is_quantum_predicate Q';\n        P \\<le>\\<^sub>L P'; \\<turnstile>\\<^sub>p {P'} S {Q'};\n        well_com S \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P'} S {Q'};\n        Q' \\<le>\\<^sub>L Q; well_com S\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P} S {Q}", "}"], ["proof (state)\nthis:\n  ?\\<rho>2 \\<in> density_states \\<Longrightarrow>\n  trace (matrix_sum d (\\<lambda>k. adjoint (M k) * P k * M k) n * ?\\<rho>2)\n  \\<le> trace (Q * denote (Measure n M S) ?\\<rho>2) +\n        (trace ?\\<rho>2 - trace (denote (Measure n M S) ?\\<rho>2))\n\ngoal (3 subgoals):\n 1. \\<And>n P Q S M.\n       \\<lbrakk>\\<And>k. k < n \\<Longrightarrow> is_quantum_predicate (P k);\n        is_quantum_predicate Q;\n        \\<And>k.\n           k < n \\<Longrightarrow> \\<turnstile>\\<^sub>p {P k} S ! k {Q};\n        \\<And>k.\n           \\<lbrakk>k < n; well_com (S ! k)\\<rbrakk>\n           \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P k} S ! k {Q};\n        well_com (Measure n M S)\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {matrix_sum d\n          (\\<lambda>k. adjoint (M k) * P k * M k) n}\n                         Measure n M S {Q}\n 2. \\<And>P Q S M.\n       \\<lbrakk>is_quantum_predicate P; is_quantum_predicate Q;\n        \\<turnstile>\\<^sub>p {Q} S\n                             {adjoint (M 0) * P * M 0 +\n                              adjoint (M 1) * Q * M 1};\n        well_com S \\<Longrightarrow>\n        \\<Turnstile>\\<^sub>p {Q} S\n        {adjoint (M 0) * P * M 0 + adjoint (M 1) * Q * M 1};\n        well_com (While M S)\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {adjoint (M 0) * P * M 0 +\n         adjoint (M 1) * Q * M 1}\n                         While M S {P}\n 3. \\<And>P Q P' Q' S.\n       \\<lbrakk>is_quantum_predicate P; is_quantum_predicate Q;\n        is_quantum_predicate P'; is_quantum_predicate Q';\n        P \\<le>\\<^sub>L P'; \\<turnstile>\\<^sub>p {P'} S {Q'};\n        well_com S \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P'} S {Q'};\n        Q' \\<le>\\<^sub>L Q; well_com S\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P} S {Q}", "then"], ["proof (chain)\npicking this:\n  ?\\<rho>2 \\<in> density_states \\<Longrightarrow>\n  trace (matrix_sum d (\\<lambda>k. adjoint (M k) * P k * M k) n * ?\\<rho>2)\n  \\<le> trace (Q * denote (Measure n M S) ?\\<rho>2) +\n        (trace ?\\<rho>2 - trace (denote (Measure n M S) ?\\<rho>2))", "show ?case"], ["proof (prove)\nusing this:\n  ?\\<rho>2 \\<in> density_states \\<Longrightarrow>\n  trace (matrix_sum d (\\<lambda>k. adjoint (M k) * P k * M k) n * ?\\<rho>2)\n  \\<le> trace (Q * denote (Measure n M S) ?\\<rho>2) +\n        (trace ?\\<rho>2 - trace (denote (Measure n M S) ?\\<rho>2))\n\ngoal (1 subgoal):\n 1. \\<Turnstile>\\<^sub>p {matrix_sum d\n                           (\\<lambda>k. adjoint (M k) * P k * M k) n}\n    Measure n M S {Q}", "unfolding hoare_partial_correct_def"], ["proof (prove)\nusing this:\n  ?\\<rho>2 \\<in> density_states \\<Longrightarrow>\n  trace (matrix_sum d (\\<lambda>k. adjoint (M k) * P k * M k) n * ?\\<rho>2)\n  \\<le> trace (Q * denote (Measure n M S) ?\\<rho>2) +\n        (trace ?\\<rho>2 - trace (denote (Measure n M S) ?\\<rho>2))\n\ngoal (1 subgoal):\n 1. \\<forall>\\<rho>\\<in>density_states.\n       trace\n        (matrix_sum d (\\<lambda>k. adjoint (M k) * P k * M k) n * \\<rho>)\n       \\<le> trace (Q * denote (Measure n M S) \\<rho>) +\n             (trace \\<rho> - trace (denote (Measure n M S) \\<rho>))", "by auto"], ["proof (state)\nthis:\n  \\<Turnstile>\\<^sub>p {matrix_sum d (\\<lambda>k. adjoint (M k) * P k * M k)\n                         n}\n  Measure n M S {Q}\n\ngoal (2 subgoals):\n 1. \\<And>P Q S M.\n       \\<lbrakk>is_quantum_predicate P; is_quantum_predicate Q;\n        \\<turnstile>\\<^sub>p {Q} S\n                             {adjoint (M 0) * P * M 0 +\n                              adjoint (M 1) * Q * M 1};\n        well_com S \\<Longrightarrow>\n        \\<Turnstile>\\<^sub>p {Q} S\n        {adjoint (M 0) * P * M 0 + adjoint (M 1) * Q * M 1};\n        well_com (While M S)\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {adjoint (M 0) * P * M 0 +\n         adjoint (M 1) * Q * M 1}\n                         While M S {P}\n 2. \\<And>P Q P' Q' S.\n       \\<lbrakk>is_quantum_predicate P; is_quantum_predicate Q;\n        is_quantum_predicate P'; is_quantum_predicate Q';\n        P \\<le>\\<^sub>L P'; \\<turnstile>\\<^sub>p {P'} S {Q'};\n        well_com S \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P'} S {Q'};\n        Q' \\<le>\\<^sub>L Q; well_com S\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P} S {Q}", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>P Q S M.\n       \\<lbrakk>is_quantum_predicate P; is_quantum_predicate Q;\n        \\<turnstile>\\<^sub>p {Q} S\n                             {adjoint (M 0) * P * M 0 +\n                              adjoint (M 1) * Q * M 1};\n        well_com S \\<Longrightarrow>\n        \\<Turnstile>\\<^sub>p {Q} S\n        {adjoint (M 0) * P * M 0 + adjoint (M 1) * Q * M 1};\n        well_com (While M S)\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {adjoint (M 0) * P * M 0 +\n         adjoint (M 1) * Q * M 1}\n                         While M S {P}\n 2. \\<And>P Q P' Q' S.\n       \\<lbrakk>is_quantum_predicate P; is_quantum_predicate Q;\n        is_quantum_predicate P'; is_quantum_predicate Q';\n        P \\<le>\\<^sub>L P'; \\<turnstile>\\<^sub>p {P'} S {Q'};\n        well_com S \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P'} S {Q'};\n        Q' \\<le>\\<^sub>L Q; well_com S\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P} S {Q}", "case (5 P Q S M)"], ["proof (state)\nthis:\n  is_quantum_predicate P\n  is_quantum_predicate Q\n  \\<turnstile>\\<^sub>p {Q} S\n                       {adjoint (M 0) * P * M 0 + adjoint (M 1) * Q * M 1}\n  well_com S \\<Longrightarrow>\n  \\<Turnstile>\\<^sub>p {Q} S\n  {adjoint (M 0) * P * M 0 + adjoint (M 1) * Q * M 1}\n  well_com (While M S)\n\ngoal (2 subgoals):\n 1. \\<And>P Q S M.\n       \\<lbrakk>is_quantum_predicate P; is_quantum_predicate Q;\n        \\<turnstile>\\<^sub>p {Q} S\n                             {adjoint (M 0) * P * M 0 +\n                              adjoint (M 1) * Q * M 1};\n        well_com S \\<Longrightarrow>\n        \\<Turnstile>\\<^sub>p {Q} S\n        {adjoint (M 0) * P * M 0 + adjoint (M 1) * Q * M 1};\n        well_com (While M S)\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {adjoint (M 0) * P * M 0 +\n         adjoint (M 1) * Q * M 1}\n                         While M S {P}\n 2. \\<And>P Q P' Q' S.\n       \\<lbrakk>is_quantum_predicate P; is_quantum_predicate Q;\n        is_quantum_predicate P'; is_quantum_predicate Q';\n        P \\<le>\\<^sub>L P'; \\<turnstile>\\<^sub>p {P'} S {Q'};\n        well_com S \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P'} S {Q'};\n        Q' \\<le>\\<^sub>L Q; well_com S\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P} S {Q}", "(*while*)"], ["proof (state)\nthis:\n  is_quantum_predicate P\n  is_quantum_predicate Q\n  \\<turnstile>\\<^sub>p {Q} S\n                       {adjoint (M 0) * P * M 0 + adjoint (M 1) * Q * M 1}\n  well_com S \\<Longrightarrow>\n  \\<Turnstile>\\<^sub>p {Q} S\n  {adjoint (M 0) * P * M 0 + adjoint (M 1) * Q * M 1}\n  well_com (While M S)\n\ngoal (2 subgoals):\n 1. \\<And>P Q S M.\n       \\<lbrakk>is_quantum_predicate P; is_quantum_predicate Q;\n        \\<turnstile>\\<^sub>p {Q} S\n                             {adjoint (M 0) * P * M 0 +\n                              adjoint (M 1) * Q * M 1};\n        well_com S \\<Longrightarrow>\n        \\<Turnstile>\\<^sub>p {Q} S\n        {adjoint (M 0) * P * M 0 + adjoint (M 1) * Q * M 1};\n        well_com (While M S)\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {adjoint (M 0) * P * M 0 +\n         adjoint (M 1) * Q * M 1}\n                         While M S {P}\n 2. \\<And>P Q P' Q' S.\n       \\<lbrakk>is_quantum_predicate P; is_quantum_predicate Q;\n        is_quantum_predicate P'; is_quantum_predicate Q';\n        P \\<le>\\<^sub>L P'; \\<turnstile>\\<^sub>p {P'} S {Q'};\n        well_com S \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P'} S {Q'};\n        Q' \\<le>\\<^sub>L Q; well_com S\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P} S {Q}", "define M0 where \"M0 = M 0\""], ["proof (state)\nthis:\n  M0 = M 0\n\ngoal (2 subgoals):\n 1. \\<And>P Q S M.\n       \\<lbrakk>is_quantum_predicate P; is_quantum_predicate Q;\n        \\<turnstile>\\<^sub>p {Q} S\n                             {adjoint (M 0) * P * M 0 +\n                              adjoint (M 1) * Q * M 1};\n        well_com S \\<Longrightarrow>\n        \\<Turnstile>\\<^sub>p {Q} S\n        {adjoint (M 0) * P * M 0 + adjoint (M 1) * Q * M 1};\n        well_com (While M S)\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {adjoint (M 0) * P * M 0 +\n         adjoint (M 1) * Q * M 1}\n                         While M S {P}\n 2. \\<And>P Q P' Q' S.\n       \\<lbrakk>is_quantum_predicate P; is_quantum_predicate Q;\n        is_quantum_predicate P'; is_quantum_predicate Q';\n        P \\<le>\\<^sub>L P'; \\<turnstile>\\<^sub>p {P'} S {Q'};\n        well_com S \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P'} S {Q'};\n        Q' \\<le>\\<^sub>L Q; well_com S\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P} S {Q}", "define M1 where \"M1 = M 1\""], ["proof (state)\nthis:\n  M1 = M 1\n\ngoal (2 subgoals):\n 1. \\<And>P Q S M.\n       \\<lbrakk>is_quantum_predicate P; is_quantum_predicate Q;\n        \\<turnstile>\\<^sub>p {Q} S\n                             {adjoint (M 0) * P * M 0 +\n                              adjoint (M 1) * Q * M 1};\n        well_com S \\<Longrightarrow>\n        \\<Turnstile>\\<^sub>p {Q} S\n        {adjoint (M 0) * P * M 0 + adjoint (M 1) * Q * M 1};\n        well_com (While M S)\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {adjoint (M 0) * P * M 0 +\n         adjoint (M 1) * Q * M 1}\n                         While M S {P}\n 2. \\<And>P Q P' Q' S.\n       \\<lbrakk>is_quantum_predicate P; is_quantum_predicate Q;\n        is_quantum_predicate P'; is_quantum_predicate Q';\n        P \\<le>\\<^sub>L P'; \\<turnstile>\\<^sub>p {P'} S {Q'};\n        well_com S \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P'} S {Q'};\n        Q' \\<le>\\<^sub>L Q; well_com S\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P} S {Q}", "from 5"], ["proof (chain)\npicking this:\n  is_quantum_predicate P\n  is_quantum_predicate Q\n  \\<turnstile>\\<^sub>p {Q} S\n                       {adjoint (M 0) * P * M 0 + adjoint (M 1) * Q * M 1}\n  well_com S \\<Longrightarrow>\n  \\<Turnstile>\\<^sub>p {Q} S\n  {adjoint (M 0) * P * M 0 + adjoint (M 1) * Q * M 1}\n  well_com (While M S)", "have wcs: \"well_com S\" and c: \"\\<Turnstile>\\<^sub>p {Q} S {adjoint M0 * P * M0 + adjoint M1 * Q * M1}\" \n    and m: \"measurement d 2 M\"\n    and dM0: \"M0 \\<in> carrier_mat d d\" and dM1: \"M1 \\<in> carrier_mat d d\" \n    and dP: \"P \\<in> carrier_mat d d\" and dQ: \"Q \\<in> carrier_mat d d\" \n    and qpQ: \"is_quantum_predicate Q\"\n    and wc: \"well_com (While M S)\""], ["proof (prove)\nusing this:\n  is_quantum_predicate P\n  is_quantum_predicate Q\n  \\<turnstile>\\<^sub>p {Q} S\n                       {adjoint (M 0) * P * M 0 + adjoint (M 1) * Q * M 1}\n  well_com S \\<Longrightarrow>\n  \\<Turnstile>\\<^sub>p {Q} S\n  {adjoint (M 0) * P * M 0 + adjoint (M 1) * Q * M 1}\n  well_com (While M S)\n\ngoal (1 subgoal):\n 1. ((well_com S &&&\n      \\<Turnstile>\\<^sub>p {Q} S\n      {adjoint M0 * P * M0 + adjoint M1 * Q * M1}) &&&\n     measurement d 2 M &&& M0 \\<in> carrier_mat d d) &&&\n    (M1 \\<in> carrier_mat d d &&& P \\<in> carrier_mat d d) &&&\n    Q \\<in> carrier_mat d d &&&\n    is_quantum_predicate Q &&& well_com (While M S)", "using measurement_def is_quantum_predicate_def M0_def M1_def"], ["proof (prove)\nusing this:\n  is_quantum_predicate P\n  is_quantum_predicate Q\n  \\<turnstile>\\<^sub>p {Q} S\n                       {adjoint (M 0) * P * M 0 + adjoint (M 1) * Q * M 1}\n  well_com S \\<Longrightarrow>\n  \\<Turnstile>\\<^sub>p {Q} S\n  {adjoint (M 0) * P * M 0 + adjoint (M 1) * Q * M 1}\n  well_com (While M S)\n  measurement ?d ?n ?M =\n  ((\\<forall>j<?n. ?M j \\<in> carrier_mat ?d ?d) \\<and>\n   matrix_sum ?d (\\<lambda>j. adjoint (?M j) * ?M j) ?n = 1\\<^sub>m ?d)\n  is_quantum_predicate ?P =\n  (?P \\<in> carrier_mat d d \\<and>\n   positive ?P \\<and> ?P \\<le>\\<^sub>L 1\\<^sub>m d)\n  M0 = M 0\n  M1 = M 1\n\ngoal (1 subgoal):\n 1. ((well_com S &&&\n      \\<Turnstile>\\<^sub>p {Q} S\n      {adjoint M0 * P * M0 + adjoint M1 * Q * M1}) &&&\n     measurement d 2 M &&& M0 \\<in> carrier_mat d d) &&&\n    (M1 \\<in> carrier_mat d d &&& P \\<in> carrier_mat d d) &&&\n    Q \\<in> carrier_mat d d &&&\n    is_quantum_predicate Q &&& well_com (While M S)", "by auto"], ["proof (state)\nthis:\n  well_com S\n  \\<Turnstile>\\<^sub>p {Q} S {adjoint M0 * P * M0 + adjoint M1 * Q * M1}\n  measurement d 2 M\n  M0 \\<in> carrier_mat d d\n  M1 \\<in> carrier_mat d d\n  P \\<in> carrier_mat d d\n  Q \\<in> carrier_mat d d\n  is_quantum_predicate Q\n  well_com (While M S)\n\ngoal (2 subgoals):\n 1. \\<And>P Q S M.\n       \\<lbrakk>is_quantum_predicate P; is_quantum_predicate Q;\n        \\<turnstile>\\<^sub>p {Q} S\n                             {adjoint (M 0) * P * M 0 +\n                              adjoint (M 1) * Q * M 1};\n        well_com S \\<Longrightarrow>\n        \\<Turnstile>\\<^sub>p {Q} S\n        {adjoint (M 0) * P * M 0 + adjoint (M 1) * Q * M 1};\n        well_com (While M S)\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {adjoint (M 0) * P * M 0 +\n         adjoint (M 1) * Q * M 1}\n                         While M S {P}\n 2. \\<And>P Q P' Q' S.\n       \\<lbrakk>is_quantum_predicate P; is_quantum_predicate Q;\n        is_quantum_predicate P'; is_quantum_predicate Q';\n        P \\<le>\\<^sub>L P'; \\<turnstile>\\<^sub>p {P'} S {Q'};\n        well_com S \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P'} S {Q'};\n        Q' \\<le>\\<^sub>L Q; well_com S\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P} S {Q}", "then"], ["proof (chain)\npicking this:\n  well_com S\n  \\<Turnstile>\\<^sub>p {Q} S {adjoint M0 * P * M0 + adjoint M1 * Q * M1}\n  measurement d 2 M\n  M0 \\<in> carrier_mat d d\n  M1 \\<in> carrier_mat d d\n  P \\<in> carrier_mat d d\n  Q \\<in> carrier_mat d d\n  is_quantum_predicate Q\n  well_com (While M S)", "have M0leq: \"adjoint M0 * M0 \\<le>\\<^sub>L 1\\<^sub>m d\" and M1leq: \"adjoint M1 * M1 \\<le>\\<^sub>L 1\\<^sub>m d\""], ["proof (prove)\nusing this:\n  well_com S\n  \\<Turnstile>\\<^sub>p {Q} S {adjoint M0 * P * M0 + adjoint M1 * Q * M1}\n  measurement d 2 M\n  M0 \\<in> carrier_mat d d\n  M1 \\<in> carrier_mat d d\n  P \\<in> carrier_mat d d\n  Q \\<in> carrier_mat d d\n  is_quantum_predicate Q\n  well_com (While M S)\n\ngoal (1 subgoal):\n 1. adjoint M0 * M0 \\<le>\\<^sub>L 1\\<^sub>m d &&&\n    adjoint M1 * M1 \\<le>\\<^sub>L 1\\<^sub>m d", "using measurement_le_one_mat[OF m] M0_def M1_def"], ["proof (prove)\nusing this:\n  well_com S\n  \\<Turnstile>\\<^sub>p {Q} S {adjoint M0 * P * M0 + adjoint M1 * Q * M1}\n  measurement d 2 M\n  M0 \\<in> carrier_mat d d\n  M1 \\<in> carrier_mat d d\n  P \\<in> carrier_mat d d\n  Q \\<in> carrier_mat d d\n  is_quantum_predicate Q\n  well_com (While M S)\n  ?j < 2 \\<Longrightarrow> adjoint (M ?j) * M ?j \\<le>\\<^sub>L 1\\<^sub>m d\n  M0 = M 0\n  M1 = M 1\n\ngoal (1 subgoal):\n 1. adjoint M0 * M0 \\<le>\\<^sub>L 1\\<^sub>m d &&&\n    adjoint M1 * M1 \\<le>\\<^sub>L 1\\<^sub>m d", "by auto"], ["proof (state)\nthis:\n  adjoint M0 * M0 \\<le>\\<^sub>L 1\\<^sub>m d\n  adjoint M1 * M1 \\<le>\\<^sub>L 1\\<^sub>m d\n\ngoal (2 subgoals):\n 1. \\<And>P Q S M.\n       \\<lbrakk>is_quantum_predicate P; is_quantum_predicate Q;\n        \\<turnstile>\\<^sub>p {Q} S\n                             {adjoint (M 0) * P * M 0 +\n                              adjoint (M 1) * Q * M 1};\n        well_com S \\<Longrightarrow>\n        \\<Turnstile>\\<^sub>p {Q} S\n        {adjoint (M 0) * P * M 0 + adjoint (M 1) * Q * M 1};\n        well_com (While M S)\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {adjoint (M 0) * P * M 0 +\n         adjoint (M 1) * Q * M 1}\n                         While M S {P}\n 2. \\<And>P Q P' Q' S.\n       \\<lbrakk>is_quantum_predicate P; is_quantum_predicate Q;\n        is_quantum_predicate P'; is_quantum_predicate Q';\n        P \\<le>\\<^sub>L P'; \\<turnstile>\\<^sub>p {P'} S {Q'};\n        well_com S \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P'} S {Q'};\n        Q' \\<le>\\<^sub>L Q; well_com S\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P} S {Q}", "define DS where \"DS = denote S\""], ["proof (state)\nthis:\n  DS = denote S\n\ngoal (2 subgoals):\n 1. \\<And>P Q S M.\n       \\<lbrakk>is_quantum_predicate P; is_quantum_predicate Q;\n        \\<turnstile>\\<^sub>p {Q} S\n                             {adjoint (M 0) * P * M 0 +\n                              adjoint (M 1) * Q * M 1};\n        well_com S \\<Longrightarrow>\n        \\<Turnstile>\\<^sub>p {Q} S\n        {adjoint (M 0) * P * M 0 + adjoint (M 1) * Q * M 1};\n        well_com (While M S)\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {adjoint (M 0) * P * M 0 +\n         adjoint (M 1) * Q * M 1}\n                         While M S {P}\n 2. \\<And>P Q P' Q' S.\n       \\<lbrakk>is_quantum_predicate P; is_quantum_predicate Q;\n        is_quantum_predicate P'; is_quantum_predicate Q';\n        P \\<le>\\<^sub>L P'; \\<turnstile>\\<^sub>p {P'} S {Q'};\n        well_com S \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P'} S {Q'};\n        Q' \\<le>\\<^sub>L Q; well_com S\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P} S {Q}", "have \"\\<forall>\\<rho> \\<in> density_states. trace (Q * \\<rho>) \\<le> trace ((adjoint M0 * P * M0 + adjoint M1 * Q * M1) * DS \\<rho>) + trace \\<rho> - trace (DS \\<rho>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<rho>\\<in>density_states.\n       trace (Q * \\<rho>)\n       \\<le> trace\n              ((adjoint M0 * P * M0 + adjoint M1 * Q * M1) * DS \\<rho>) +\n             trace \\<rho> -\n             trace (DS \\<rho>)", "using hoare_partial_correct_def[of Q S \"adjoint M0 * P * M0 + adjoint M1 * Q * M1\"] c DS_def"], ["proof (prove)\nusing this:\n  (\\<Turnstile>\\<^sub>p {Q} S {adjoint M0 * P * M0 + adjoint M1 * Q * M1}) =\n  (\\<forall>\\<rho>\\<in>density_states.\n      trace (Q * \\<rho>)\n      \\<le> trace\n             ((adjoint M0 * P * M0 + adjoint M1 * Q * M1) *\n              denote S \\<rho>) +\n            (trace \\<rho> - trace (denote S \\<rho>)))\n  \\<Turnstile>\\<^sub>p {Q} S {adjoint M0 * P * M0 + adjoint M1 * Q * M1}\n  DS = denote S\n\ngoal (1 subgoal):\n 1. \\<forall>\\<rho>\\<in>density_states.\n       trace (Q * \\<rho>)\n       \\<le> trace\n              ((adjoint M0 * P * M0 + adjoint M1 * Q * M1) * DS \\<rho>) +\n             trace \\<rho> -\n             trace (DS \\<rho>)", "by auto"], ["proof (state)\nthis:\n  \\<forall>\\<rho>\\<in>density_states.\n     trace (Q * \\<rho>)\n     \\<le> trace ((adjoint M0 * P * M0 + adjoint M1 * Q * M1) * DS \\<rho>) +\n           trace \\<rho> -\n           trace (DS \\<rho>)\n\ngoal (2 subgoals):\n 1. \\<And>P Q S M.\n       \\<lbrakk>is_quantum_predicate P; is_quantum_predicate Q;\n        \\<turnstile>\\<^sub>p {Q} S\n                             {adjoint (M 0) * P * M 0 +\n                              adjoint (M 1) * Q * M 1};\n        well_com S \\<Longrightarrow>\n        \\<Turnstile>\\<^sub>p {Q} S\n        {adjoint (M 0) * P * M 0 + adjoint (M 1) * Q * M 1};\n        well_com (While M S)\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {adjoint (M 0) * P * M 0 +\n         adjoint (M 1) * Q * M 1}\n                         While M S {P}\n 2. \\<And>P Q P' Q' S.\n       \\<lbrakk>is_quantum_predicate P; is_quantum_predicate Q;\n        is_quantum_predicate P'; is_quantum_predicate Q';\n        P \\<le>\\<^sub>L P'; \\<turnstile>\\<^sub>p {P'} S {Q'};\n        well_com S \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P'} S {Q'};\n        Q' \\<le>\\<^sub>L Q; well_com S\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P} S {Q}", "define D0 where \"D0 = denote_while_n M0 M1 DS\""], ["proof (state)\nthis:\n  D0 = denote_while_n M0 M1 DS\n\ngoal (2 subgoals):\n 1. \\<And>P Q S M.\n       \\<lbrakk>is_quantum_predicate P; is_quantum_predicate Q;\n        \\<turnstile>\\<^sub>p {Q} S\n                             {adjoint (M 0) * P * M 0 +\n                              adjoint (M 1) * Q * M 1};\n        well_com S \\<Longrightarrow>\n        \\<Turnstile>\\<^sub>p {Q} S\n        {adjoint (M 0) * P * M 0 + adjoint (M 1) * Q * M 1};\n        well_com (While M S)\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {adjoint (M 0) * P * M 0 +\n         adjoint (M 1) * Q * M 1}\n                         While M S {P}\n 2. \\<And>P Q P' Q' S.\n       \\<lbrakk>is_quantum_predicate P; is_quantum_predicate Q;\n        is_quantum_predicate P'; is_quantum_predicate Q';\n        P \\<le>\\<^sub>L P'; \\<turnstile>\\<^sub>p {P'} S {Q'};\n        well_com S \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P'} S {Q'};\n        Q' \\<le>\\<^sub>L Q; well_com S\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P} S {Q}", "define D1 where \"D1 = denote_while_n_comp M0 M1 DS\""], ["proof (state)\nthis:\n  D1 = denote_while_n_comp M0 M1 DS\n\ngoal (2 subgoals):\n 1. \\<And>P Q S M.\n       \\<lbrakk>is_quantum_predicate P; is_quantum_predicate Q;\n        \\<turnstile>\\<^sub>p {Q} S\n                             {adjoint (M 0) * P * M 0 +\n                              adjoint (M 1) * Q * M 1};\n        well_com S \\<Longrightarrow>\n        \\<Turnstile>\\<^sub>p {Q} S\n        {adjoint (M 0) * P * M 0 + adjoint (M 1) * Q * M 1};\n        well_com (While M S)\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {adjoint (M 0) * P * M 0 +\n         adjoint (M 1) * Q * M 1}\n                         While M S {P}\n 2. \\<And>P Q P' Q' S.\n       \\<lbrakk>is_quantum_predicate P; is_quantum_predicate Q;\n        is_quantum_predicate P'; is_quantum_predicate Q';\n        P \\<le>\\<^sub>L P'; \\<turnstile>\\<^sub>p {P'} S {Q'};\n        well_com S \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P'} S {Q'};\n        Q' \\<le>\\<^sub>L Q; well_com S\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P} S {Q}", "define D where \"D = denote_while_n_iter M0 M1 DS\""], ["proof (state)\nthis:\n  D = denote_while_n_iter M0 M1 DS\n\ngoal (2 subgoals):\n 1. \\<And>P Q S M.\n       \\<lbrakk>is_quantum_predicate P; is_quantum_predicate Q;\n        \\<turnstile>\\<^sub>p {Q} S\n                             {adjoint (M 0) * P * M 0 +\n                              adjoint (M 1) * Q * M 1};\n        well_com S \\<Longrightarrow>\n        \\<Turnstile>\\<^sub>p {Q} S\n        {adjoint (M 0) * P * M 0 + adjoint (M 1) * Q * M 1};\n        well_com (While M S)\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {adjoint (M 0) * P * M 0 +\n         adjoint (M 1) * Q * M 1}\n                         While M S {P}\n 2. \\<And>P Q P' Q' S.\n       \\<lbrakk>is_quantum_predicate P; is_quantum_predicate Q;\n        is_quantum_predicate P'; is_quantum_predicate Q';\n        P \\<le>\\<^sub>L P'; \\<turnstile>\\<^sub>p {P'} S {Q'};\n        well_com S \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P'} S {Q'};\n        Q' \\<le>\\<^sub>L Q; well_com S\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P} S {Q}", "{"], ["proof (state)\nthis:\n  D = denote_while_n_iter M0 M1 DS\n\ngoal (2 subgoals):\n 1. \\<And>P Q S M.\n       \\<lbrakk>is_quantum_predicate P; is_quantum_predicate Q;\n        \\<turnstile>\\<^sub>p {Q} S\n                             {adjoint (M 0) * P * M 0 +\n                              adjoint (M 1) * Q * M 1};\n        well_com S \\<Longrightarrow>\n        \\<Turnstile>\\<^sub>p {Q} S\n        {adjoint (M 0) * P * M 0 + adjoint (M 1) * Q * M 1};\n        well_com (While M S)\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {adjoint (M 0) * P * M 0 +\n         adjoint (M 1) * Q * M 1}\n                         While M S {P}\n 2. \\<And>P Q P' Q' S.\n       \\<lbrakk>is_quantum_predicate P; is_quantum_predicate Q;\n        is_quantum_predicate P'; is_quantum_predicate Q';\n        P \\<le>\\<^sub>L P'; \\<turnstile>\\<^sub>p {P'} S {Q'};\n        well_com S \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P'} S {Q'};\n        Q' \\<le>\\<^sub>L Q; well_com S\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P} S {Q}", "fix \\<rho>"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>P Q S M.\n       \\<lbrakk>is_quantum_predicate P; is_quantum_predicate Q;\n        \\<turnstile>\\<^sub>p {Q} S\n                             {adjoint (M 0) * P * M 0 +\n                              adjoint (M 1) * Q * M 1};\n        well_com S \\<Longrightarrow>\n        \\<Turnstile>\\<^sub>p {Q} S\n        {adjoint (M 0) * P * M 0 + adjoint (M 1) * Q * M 1};\n        well_com (While M S)\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {adjoint (M 0) * P * M 0 +\n         adjoint (M 1) * Q * M 1}\n                         While M S {P}\n 2. \\<And>P Q P' Q' S.\n       \\<lbrakk>is_quantum_predicate P; is_quantum_predicate Q;\n        is_quantum_predicate P'; is_quantum_predicate Q';\n        P \\<le>\\<^sub>L P'; \\<turnstile>\\<^sub>p {P'} S {Q'};\n        well_com S \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P'} S {Q'};\n        Q' \\<le>\\<^sub>L Q; well_com S\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P} S {Q}", "assume dsr: \"\\<rho> \\<in> density_states\""], ["proof (state)\nthis:\n  \\<rho> \\<in> density_states\n\ngoal (2 subgoals):\n 1. \\<And>P Q S M.\n       \\<lbrakk>is_quantum_predicate P; is_quantum_predicate Q;\n        \\<turnstile>\\<^sub>p {Q} S\n                             {adjoint (M 0) * P * M 0 +\n                              adjoint (M 1) * Q * M 1};\n        well_com S \\<Longrightarrow>\n        \\<Turnstile>\\<^sub>p {Q} S\n        {adjoint (M 0) * P * M 0 + adjoint (M 1) * Q * M 1};\n        well_com (While M S)\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {adjoint (M 0) * P * M 0 +\n         adjoint (M 1) * Q * M 1}\n                         While M S {P}\n 2. \\<And>P Q P' Q' S.\n       \\<lbrakk>is_quantum_predicate P; is_quantum_predicate Q;\n        is_quantum_predicate P'; is_quantum_predicate Q';\n        P \\<le>\\<^sub>L P'; \\<turnstile>\\<^sub>p {P'} S {Q'};\n        well_com S \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P'} S {Q'};\n        Q' \\<le>\\<^sub>L Q; well_com S\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P} S {Q}", "then"], ["proof (chain)\npicking this:\n  \\<rho> \\<in> density_states", "have dr: \"\\<rho> \\<in> carrier_mat d d\" and pr: \"positive \\<rho>\" and pdor: \"partial_density_operator \\<rho>\""], ["proof (prove)\nusing this:\n  \\<rho> \\<in> density_states\n\ngoal (1 subgoal):\n 1. \\<rho> \\<in> carrier_mat d d &&&\n    positive \\<rho> &&& partial_density_operator \\<rho>", "using density_states_def partial_density_operator_def"], ["proof (prove)\nusing this:\n  \\<rho> \\<in> density_states\n  density_states =\n  {\\<rho> \\<in> carrier_mat d d. partial_density_operator \\<rho>}\n  partial_density_operator ?A = (positive ?A \\<and> trace ?A \\<le> 1)\n\ngoal (1 subgoal):\n 1. \\<rho> \\<in> carrier_mat d d &&&\n    positive \\<rho> &&& partial_density_operator \\<rho>", "by auto"], ["proof (state)\nthis:\n  \\<rho> \\<in> carrier_mat d d\n  positive \\<rho>\n  partial_density_operator \\<rho>\n\ngoal (2 subgoals):\n 1. \\<And>P Q S M.\n       \\<lbrakk>is_quantum_predicate P; is_quantum_predicate Q;\n        \\<turnstile>\\<^sub>p {Q} S\n                             {adjoint (M 0) * P * M 0 +\n                              adjoint (M 1) * Q * M 1};\n        well_com S \\<Longrightarrow>\n        \\<Turnstile>\\<^sub>p {Q} S\n        {adjoint (M 0) * P * M 0 + adjoint (M 1) * Q * M 1};\n        well_com (While M S)\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {adjoint (M 0) * P * M 0 +\n         adjoint (M 1) * Q * M 1}\n                         While M S {P}\n 2. \\<And>P Q P' Q' S.\n       \\<lbrakk>is_quantum_predicate P; is_quantum_predicate Q;\n        is_quantum_predicate P'; is_quantum_predicate Q';\n        P \\<le>\\<^sub>L P'; \\<turnstile>\\<^sub>p {P'} S {Q'};\n        well_com S \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P'} S {Q'};\n        Q' \\<le>\\<^sub>L Q; well_com S\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P} S {Q}", "have pdoDkr: \"\\<And>k. partial_density_operator (D k \\<rho>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>k. partial_density_operator (D k \\<rho>)", "unfolding D_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>k.\n       partial_density_operator (denote_while_n_iter M0 M1 DS k \\<rho>)", "using pdo_denote_while_n_iter[OF dr pdor dM1 M1leq]\n        denote_partial_density_operator[OF wcs] denote_dim[OF wcs, folded DS_def]"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>\\<rho>.\n              \\<rho> \\<in> carrier_mat d d \\<and>\n              partial_density_operator \\<rho> \\<Longrightarrow>\n              partial_density_operator (?DS \\<rho>);\n   \\<And>\\<rho>.\n      \\<rho> \\<in> carrier_mat d d \\<and>\n      partial_density_operator \\<rho> \\<Longrightarrow>\n      ?DS \\<rho> \\<in> carrier_mat d d\\<rbrakk>\n  \\<Longrightarrow> partial_density_operator\n                     (denote_while_n_iter ?M0.0 M1 ?DS ?n \\<rho>)\n  \\<lbrakk>partial_density_operator ?\\<rho>;\n   ?\\<rho> \\<in> carrier_mat d d\\<rbrakk>\n  \\<Longrightarrow> partial_density_operator (denote S ?\\<rho>)\n  \\<lbrakk>?\\<rho> \\<in> carrier_mat d d;\n   partial_density_operator ?\\<rho>\\<rbrakk>\n  \\<Longrightarrow> DS ?\\<rho> \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       partial_density_operator (denote_while_n_iter M0 M1 DS k \\<rho>)", "apply (fold DS_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>\\<And>DS M0 n.\n                   \\<lbrakk>\\<And>\\<rho>.\n                               \\<rho> \\<in> carrier_mat d d \\<and>\n                               partial_density_operator\n                                \\<rho> \\<Longrightarrow>\n                               partial_density_operator (DS \\<rho>);\n                    \\<And>\\<rho>.\n                       \\<rho> \\<in> carrier_mat d d \\<and>\n                       partial_density_operator \\<rho> \\<Longrightarrow>\n                       DS \\<rho> \\<in> carrier_mat d d\\<rbrakk>\n                   \\<Longrightarrow> partial_density_operator\n(denote_while_n_iter M0 M1 DS n \\<rho>);\n        \\<And>\\<rho>.\n           \\<lbrakk>partial_density_operator \\<rho>;\n            \\<rho> \\<in> carrier_mat d d\\<rbrakk>\n           \\<Longrightarrow> partial_density_operator (DS \\<rho>);\n        \\<And>\\<rho>.\n           \\<lbrakk>\\<rho> \\<in> carrier_mat d d;\n            partial_density_operator \\<rho>\\<rbrakk>\n           \\<Longrightarrow> DS \\<rho> \\<in> carrier_mat d d\\<rbrakk>\n       \\<Longrightarrow> partial_density_operator\n                          (denote_while_n_iter M0 M1 DS k \\<rho>)", "by auto"], ["proof (state)\nthis:\n  partial_density_operator (D ?k \\<rho>)\n\ngoal (2 subgoals):\n 1. \\<And>P Q S M.\n       \\<lbrakk>is_quantum_predicate P; is_quantum_predicate Q;\n        \\<turnstile>\\<^sub>p {Q} S\n                             {adjoint (M 0) * P * M 0 +\n                              adjoint (M 1) * Q * M 1};\n        well_com S \\<Longrightarrow>\n        \\<Turnstile>\\<^sub>p {Q} S\n        {adjoint (M 0) * P * M 0 + adjoint (M 1) * Q * M 1};\n        well_com (While M S)\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {adjoint (M 0) * P * M 0 +\n         adjoint (M 1) * Q * M 1}\n                         While M S {P}\n 2. \\<And>P Q P' Q' S.\n       \\<lbrakk>is_quantum_predicate P; is_quantum_predicate Q;\n        is_quantum_predicate P'; is_quantum_predicate Q';\n        P \\<le>\\<^sub>L P'; \\<turnstile>\\<^sub>p {P'} S {Q'};\n        well_com S \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P'} S {Q'};\n        Q' \\<le>\\<^sub>L Q; well_com S\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P} S {Q}", "then"], ["proof (chain)\npicking this:\n  partial_density_operator (D ?k \\<rho>)", "have pDkr: \"\\<And>k. positive (D k \\<rho>)\""], ["proof (prove)\nusing this:\n  partial_density_operator (D ?k \\<rho>)\n\ngoal (1 subgoal):\n 1. \\<And>k. positive (D k \\<rho>)", "unfolding partial_density_operator_def"], ["proof (prove)\nusing this:\n  positive (D ?k \\<rho>) \\<and> trace (D ?k \\<rho>) \\<le> 1\n\ngoal (1 subgoal):\n 1. \\<And>k. positive (D k \\<rho>)", "by auto"], ["proof (state)\nthis:\n  positive (D ?k \\<rho>)\n\ngoal (2 subgoals):\n 1. \\<And>P Q S M.\n       \\<lbrakk>is_quantum_predicate P; is_quantum_predicate Q;\n        \\<turnstile>\\<^sub>p {Q} S\n                             {adjoint (M 0) * P * M 0 +\n                              adjoint (M 1) * Q * M 1};\n        well_com S \\<Longrightarrow>\n        \\<Turnstile>\\<^sub>p {Q} S\n        {adjoint (M 0) * P * M 0 + adjoint (M 1) * Q * M 1};\n        well_com (While M S)\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {adjoint (M 0) * P * M 0 +\n         adjoint (M 1) * Q * M 1}\n                         While M S {P}\n 2. \\<And>P Q P' Q' S.\n       \\<lbrakk>is_quantum_predicate P; is_quantum_predicate Q;\n        is_quantum_predicate P'; is_quantum_predicate Q';\n        P \\<le>\\<^sub>L P'; \\<turnstile>\\<^sub>p {P'} S {Q'};\n        well_com S \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P'} S {Q'};\n        Q' \\<le>\\<^sub>L Q; well_com S\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P} S {Q}", "have dDkr: \"\\<And>k. D k \\<rho> \\<in> carrier_mat d d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>k. D k \\<rho> \\<in> carrier_mat d d", "using denote_while_n_iter_dim[OF dr pdor dM1 M1leq denote_dim_pdo[OF wcs, folded DS_def], of id M0, simplified, folded D_def]"], ["proof (prove)\nusing this:\n  D ?n \\<rho> \\<in> carrier_mat d d \\<and>\n  partial_density_operator (D ?n \\<rho>)\n\ngoal (1 subgoal):\n 1. \\<And>k. D k \\<rho> \\<in> carrier_mat d d", "by auto"], ["proof (state)\nthis:\n  D ?k \\<rho> \\<in> carrier_mat d d\n\ngoal (2 subgoals):\n 1. \\<And>P Q S M.\n       \\<lbrakk>is_quantum_predicate P; is_quantum_predicate Q;\n        \\<turnstile>\\<^sub>p {Q} S\n                             {adjoint (M 0) * P * M 0 +\n                              adjoint (M 1) * Q * M 1};\n        well_com S \\<Longrightarrow>\n        \\<Turnstile>\\<^sub>p {Q} S\n        {adjoint (M 0) * P * M 0 + adjoint (M 1) * Q * M 1};\n        well_com (While M S)\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {adjoint (M 0) * P * M 0 +\n         adjoint (M 1) * Q * M 1}\n                         While M S {P}\n 2. \\<And>P Q P' Q' S.\n       \\<lbrakk>is_quantum_predicate P; is_quantum_predicate Q;\n        is_quantum_predicate P'; is_quantum_predicate Q';\n        P \\<le>\\<^sub>L P'; \\<turnstile>\\<^sub>p {P'} S {Q'};\n        well_com S \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P'} S {Q'};\n        Q' \\<le>\\<^sub>L Q; well_com S\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P} S {Q}", "then"], ["proof (chain)\npicking this:\n  D ?k \\<rho> \\<in> carrier_mat d d", "have dD0kr: \"\\<And>k. D0 k \\<rho> \\<in> carrier_mat d d\""], ["proof (prove)\nusing this:\n  D ?k \\<rho> \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. \\<And>k. D0 k \\<rho> \\<in> carrier_mat d d", "unfolding D0_def denote_while_n.simps"], ["proof (prove)\nusing this:\n  D ?k \\<rho> \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       M0 * denote_while_n_iter M0 M1 DS k \\<rho> * adjoint M0\n       \\<in> carrier_mat d d", "apply (fold D_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>k.\n       (\\<And>k. D k \\<rho> \\<in> carrier_mat d d) \\<Longrightarrow>\n       M0 * D k \\<rho> * adjoint M0 \\<in> carrier_mat d d", "using dM0"], ["proof (prove)\nusing this:\n  M0 \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       (\\<And>k. D k \\<rho> \\<in> carrier_mat d d) \\<Longrightarrow>\n       M0 * D k \\<rho> * adjoint M0 \\<in> carrier_mat d d", "by auto"], ["proof (state)\nthis:\n  D0 ?k \\<rho> \\<in> carrier_mat d d\n\ngoal (2 subgoals):\n 1. \\<And>P Q S M.\n       \\<lbrakk>is_quantum_predicate P; is_quantum_predicate Q;\n        \\<turnstile>\\<^sub>p {Q} S\n                             {adjoint (M 0) * P * M 0 +\n                              adjoint (M 1) * Q * M 1};\n        well_com S \\<Longrightarrow>\n        \\<Turnstile>\\<^sub>p {Q} S\n        {adjoint (M 0) * P * M 0 + adjoint (M 1) * Q * M 1};\n        well_com (While M S)\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {adjoint (M 0) * P * M 0 +\n         adjoint (M 1) * Q * M 1}\n                         While M S {P}\n 2. \\<And>P Q P' Q' S.\n       \\<lbrakk>is_quantum_predicate P; is_quantum_predicate Q;\n        is_quantum_predicate P'; is_quantum_predicate Q';\n        P \\<le>\\<^sub>L P'; \\<turnstile>\\<^sub>p {P'} S {Q'};\n        well_com S \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P'} S {Q'};\n        Q' \\<le>\\<^sub>L Q; well_com S\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P} S {Q}", "then"], ["proof (chain)\npicking this:\n  D0 ?k \\<rho> \\<in> carrier_mat d d", "have dPD0kr: \"\\<And>k. P * (D0 k \\<rho>) \\<in> carrier_mat d d\""], ["proof (prove)\nusing this:\n  D0 ?k \\<rho> \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. \\<And>k. P * D0 k \\<rho> \\<in> carrier_mat d d", "using dP"], ["proof (prove)\nusing this:\n  D0 ?k \\<rho> \\<in> carrier_mat d d\n  P \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. \\<And>k. P * D0 k \\<rho> \\<in> carrier_mat d d", "by auto"], ["proof (state)\nthis:\n  P * D0 ?k \\<rho> \\<in> carrier_mat d d\n\ngoal (2 subgoals):\n 1. \\<And>P Q S M.\n       \\<lbrakk>is_quantum_predicate P; is_quantum_predicate Q;\n        \\<turnstile>\\<^sub>p {Q} S\n                             {adjoint (M 0) * P * M 0 +\n                              adjoint (M 1) * Q * M 1};\n        well_com S \\<Longrightarrow>\n        \\<Turnstile>\\<^sub>p {Q} S\n        {adjoint (M 0) * P * M 0 + adjoint (M 1) * Q * M 1};\n        well_com (While M S)\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {adjoint (M 0) * P * M 0 +\n         adjoint (M 1) * Q * M 1}\n                         While M S {P}\n 2. \\<And>P Q P' Q' S.\n       \\<lbrakk>is_quantum_predicate P; is_quantum_predicate Q;\n        is_quantum_predicate P'; is_quantum_predicate Q';\n        P \\<le>\\<^sub>L P'; \\<turnstile>\\<^sub>p {P'} S {Q'};\n        well_com S \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P'} S {Q'};\n        Q' \\<le>\\<^sub>L Q; well_com S\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P} S {Q}", "have \"\\<And>k. positive (D0 k \\<rho>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>k. positive (D0 k \\<rho>)", "unfolding D0_def denote_while_n.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>k.\n       positive (M0 * denote_while_n_iter M0 M1 DS k \\<rho> * adjoint M0)", "by (fold D_def, rule positive_close_under_left_right_mult_adjoint[OF dM0 dDkr pDkr])"], ["proof (state)\nthis:\n  positive (D0 ?k \\<rho>)\n\ngoal (2 subgoals):\n 1. \\<And>P Q S M.\n       \\<lbrakk>is_quantum_predicate P; is_quantum_predicate Q;\n        \\<turnstile>\\<^sub>p {Q} S\n                             {adjoint (M 0) * P * M 0 +\n                              adjoint (M 1) * Q * M 1};\n        well_com S \\<Longrightarrow>\n        \\<Turnstile>\\<^sub>p {Q} S\n        {adjoint (M 0) * P * M 0 + adjoint (M 1) * Q * M 1};\n        well_com (While M S)\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {adjoint (M 0) * P * M 0 +\n         adjoint (M 1) * Q * M 1}\n                         While M S {P}\n 2. \\<And>P Q P' Q' S.\n       \\<lbrakk>is_quantum_predicate P; is_quantum_predicate Q;\n        is_quantum_predicate P'; is_quantum_predicate Q';\n        P \\<le>\\<^sub>L P'; \\<turnstile>\\<^sub>p {P'} S {Q'};\n        well_com S \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P'} S {Q'};\n        Q' \\<le>\\<^sub>L Q; well_com S\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P} S {Q}", "then"], ["proof (chain)\npicking this:\n  positive (D0 ?k \\<rho>)", "have trge0: \"\\<And>k. trace (D0 k \\<rho>) \\<ge> 0\""], ["proof (prove)\nusing this:\n  positive (D0 ?k \\<rho>)\n\ngoal (1 subgoal):\n 1. \\<And>k. 0 \\<le> trace (D0 k \\<rho>)", "using positive_trace dD0kr"], ["proof (prove)\nusing this:\n  positive (D0 ?k \\<rho>)\n  \\<lbrakk>?A \\<in> carrier_mat ?n ?n; positive ?A\\<rbrakk>\n  \\<Longrightarrow> 0 \\<le> trace ?A\n  D0 ?k \\<rho> \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. \\<And>k. 0 \\<le> trace (D0 k \\<rho>)", "by blast"], ["proof (state)\nthis:\n  0 \\<le> trace (D0 ?k \\<rho>)\n\ngoal (2 subgoals):\n 1. \\<And>P Q S M.\n       \\<lbrakk>is_quantum_predicate P; is_quantum_predicate Q;\n        \\<turnstile>\\<^sub>p {Q} S\n                             {adjoint (M 0) * P * M 0 +\n                              adjoint (M 1) * Q * M 1};\n        well_com S \\<Longrightarrow>\n        \\<Turnstile>\\<^sub>p {Q} S\n        {adjoint (M 0) * P * M 0 + adjoint (M 1) * Q * M 1};\n        well_com (While M S)\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {adjoint (M 0) * P * M 0 +\n         adjoint (M 1) * Q * M 1}\n                         While M S {P}\n 2. \\<And>P Q P' Q' S.\n       \\<lbrakk>is_quantum_predicate P; is_quantum_predicate Q;\n        is_quantum_predicate P'; is_quantum_predicate Q';\n        P \\<le>\\<^sub>L P'; \\<turnstile>\\<^sub>p {P'} S {Q'};\n        well_com S \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P'} S {Q'};\n        Q' \\<le>\\<^sub>L Q; well_com S\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P} S {Q}", "have DSr: \"\\<rho> \\<in> density_states \\<Longrightarrow> DS \\<rho> \\<in> density_states\" for \"\\<rho>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<rho> \\<in> density_states \\<Longrightarrow>\n    DS \\<rho> \\<in> density_states", "unfolding DS_def density_states_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<rho>\n    \\<in> {\\<rho> \\<in> carrier_mat d d.\n           partial_density_operator \\<rho>} \\<Longrightarrow>\n    denote S \\<rho>\n    \\<in> {\\<rho> \\<in> carrier_mat d d. partial_density_operator \\<rho>}", "using denote_partial_density_operator denote_dim wcs"], ["proof (prove)\nusing this:\n  \\<lbrakk>well_com ?S; partial_density_operator ?\\<rho>;\n   ?\\<rho> \\<in> carrier_mat d d\\<rbrakk>\n  \\<Longrightarrow> partial_density_operator (denote ?S ?\\<rho>)\n  \\<lbrakk>well_com ?S; ?\\<rho> \\<in> carrier_mat d d;\n   partial_density_operator ?\\<rho>\\<rbrakk>\n  \\<Longrightarrow> denote ?S ?\\<rho> \\<in> carrier_mat d d\n  well_com S\n\ngoal (1 subgoal):\n 1. \\<rho>\n    \\<in> {\\<rho> \\<in> carrier_mat d d.\n           partial_density_operator \\<rho>} \\<Longrightarrow>\n    denote S \\<rho>\n    \\<in> {\\<rho> \\<in> carrier_mat d d. partial_density_operator \\<rho>}", "by auto"], ["proof (state)\nthis:\n  ?\\<rho> \\<in> density_states \\<Longrightarrow>\n  DS ?\\<rho> \\<in> density_states\n\ngoal (2 subgoals):\n 1. \\<And>P Q S M.\n       \\<lbrakk>is_quantum_predicate P; is_quantum_predicate Q;\n        \\<turnstile>\\<^sub>p {Q} S\n                             {adjoint (M 0) * P * M 0 +\n                              adjoint (M 1) * Q * M 1};\n        well_com S \\<Longrightarrow>\n        \\<Turnstile>\\<^sub>p {Q} S\n        {adjoint (M 0) * P * M 0 + adjoint (M 1) * Q * M 1};\n        well_com (While M S)\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {adjoint (M 0) * P * M 0 +\n         adjoint (M 1) * Q * M 1}\n                         While M S {P}\n 2. \\<And>P Q P' Q' S.\n       \\<lbrakk>is_quantum_predicate P; is_quantum_predicate Q;\n        is_quantum_predicate P'; is_quantum_predicate Q';\n        P \\<le>\\<^sub>L P'; \\<turnstile>\\<^sub>p {P'} S {Q'};\n        well_com S \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P'} S {Q'};\n        Q' \\<le>\\<^sub>L Q; well_com S\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P} S {Q}", "have dsD1nr: \"D1 n \\<rho> \\<in> density_states\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. D1 n \\<rho> \\<in> density_states", "unfolding D1_def denote_while_n_comp.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. M1 * denote_while_n_iter M0 M1 DS n \\<rho> * adjoint M1\n    \\<in> density_states", "apply (fold D_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. M1 * D n \\<rho> * adjoint M1 \\<in> density_states", "unfolding density_states_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. M1 * D n \\<rho> * adjoint M1\n    \\<in> {\\<rho> \\<in> carrier_mat d d. partial_density_operator \\<rho>}", "apply (auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. M1 * D n \\<rho> * adjoint M1 \\<in> carrier_mat d d\n 2. partial_density_operator (M1 * D n \\<rho> * adjoint M1)", "apply (insert dDkr dM1 adjoint_dim[OF dM1], auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>k. D k \\<rho> \\<in> carrier_mat d d;\n     M1 \\<in> carrier_mat d d; adjoint M1 \\<in> carrier_mat d d\\<rbrakk>\n    \\<Longrightarrow> partial_density_operator\n                       (M1 * D n \\<rho> * adjoint M1)", "apply (rule pdo_close_under_measurement[OF dM1 spec[OF allI[OF dDkr], of \"\\<lambda>x. n\"] spec[OF allI[OF pdoDkr], of \"\\<lambda>x. n\"] M1leq])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  D1 ?n \\<rho> \\<in> density_states\n\ngoal (2 subgoals):\n 1. \\<And>P Q S M.\n       \\<lbrakk>is_quantum_predicate P; is_quantum_predicate Q;\n        \\<turnstile>\\<^sub>p {Q} S\n                             {adjoint (M 0) * P * M 0 +\n                              adjoint (M 1) * Q * M 1};\n        well_com S \\<Longrightarrow>\n        \\<Turnstile>\\<^sub>p {Q} S\n        {adjoint (M 0) * P * M 0 + adjoint (M 1) * Q * M 1};\n        well_com (While M S)\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {adjoint (M 0) * P * M 0 +\n         adjoint (M 1) * Q * M 1}\n                         While M S {P}\n 2. \\<And>P Q P' Q' S.\n       \\<lbrakk>is_quantum_predicate P; is_quantum_predicate Q;\n        is_quantum_predicate P'; is_quantum_predicate Q';\n        P \\<le>\\<^sub>L P'; \\<turnstile>\\<^sub>p {P'} S {Q'};\n        well_com S \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P'} S {Q'};\n        Q' \\<le>\\<^sub>L Q; well_com S\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P} S {Q}", "have leQn: \"trace (Q * D1 n \\<rho>) \n          \\<le> trace (P * D0 (Suc n) \\<rho>) + trace (Q * D1 (Suc n) \\<rho>)\n          + trace (D1 n \\<rho>) - trace (D (Suc n) \\<rho>)\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. trace (Q * D1 n \\<rho>)\n    \\<le> trace (P * D0 (Suc n) \\<rho>) + trace (Q * D1 (Suc n) \\<rho>) +\n          trace (D1 n \\<rho>) -\n          trace (D (Suc n) \\<rho>)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. trace (Q * D1 n \\<rho>)\n    \\<le> trace (P * D0 (Suc n) \\<rho>) + trace (Q * D1 (Suc n) \\<rho>) +\n          trace (D1 n \\<rho>) -\n          trace (D (Suc n) \\<rho>)", "have \"(\\<forall>\\<rho>\\<in>density_states. trace (Q * \\<rho>) \\<le> trace ((adjoint M0 * P * M0 + adjoint M1 * Q * M1) * denote S \\<rho>) + (trace \\<rho> - trace (denote S \\<rho>)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<rho>\\<in>density_states.\n       trace (Q * \\<rho>)\n       \\<le> trace\n              ((adjoint M0 * P * M0 + adjoint M1 * Q * M1) *\n               denote S \\<rho>) +\n             (trace \\<rho> - trace (denote S \\<rho>))", "using c hoare_partial_correct_def"], ["proof (prove)\nusing this:\n  \\<Turnstile>\\<^sub>p {Q} S {adjoint M0 * P * M0 + adjoint M1 * Q * M1}\n  (\\<Turnstile>\\<^sub>p {?P} ?S {?Q}) =\n  (\\<forall>\\<rho>\\<in>density_states.\n      trace (?P * \\<rho>)\n      \\<le> trace (?Q * denote ?S \\<rho>) +\n            (trace \\<rho> - trace (denote ?S \\<rho>)))\n\ngoal (1 subgoal):\n 1. \\<forall>\\<rho>\\<in>density_states.\n       trace (Q * \\<rho>)\n       \\<le> trace\n              ((adjoint M0 * P * M0 + adjoint M1 * Q * M1) *\n               denote S \\<rho>) +\n             (trace \\<rho> - trace (denote S \\<rho>))", "by auto"], ["proof (state)\nthis:\n  \\<forall>\\<rho>\\<in>density_states.\n     trace (Q * \\<rho>)\n     \\<le> trace\n            ((adjoint M0 * P * M0 + adjoint M1 * Q * M1) *\n             denote S \\<rho>) +\n           (trace \\<rho> - trace (denote S \\<rho>))\n\ngoal (1 subgoal):\n 1. trace (Q * D1 n \\<rho>)\n    \\<le> trace (P * D0 (Suc n) \\<rho>) + trace (Q * D1 (Suc n) \\<rho>) +\n          trace (D1 n \\<rho>) -\n          trace (D (Suc n) \\<rho>)", "then"], ["proof (chain)\npicking this:\n  \\<forall>\\<rho>\\<in>density_states.\n     trace (Q * \\<rho>)\n     \\<le> trace\n            ((adjoint M0 * P * M0 + adjoint M1 * Q * M1) *\n             denote S \\<rho>) +\n           (trace \\<rho> - trace (denote S \\<rho>))", "have leQn': \"trace (Q * (D1 n \\<rho>)) \n          \\<le> trace ((adjoint M0 * P * M0 + adjoint M1 * Q * M1) * (DS (D1 n \\<rho>))) \n          + (trace (D1 n \\<rho>) - trace (DS (D1 n \\<rho>)))\""], ["proof (prove)\nusing this:\n  \\<forall>\\<rho>\\<in>density_states.\n     trace (Q * \\<rho>)\n     \\<le> trace\n            ((adjoint M0 * P * M0 + adjoint M1 * Q * M1) *\n             denote S \\<rho>) +\n           (trace \\<rho> - trace (denote S \\<rho>))\n\ngoal (1 subgoal):\n 1. trace (Q * D1 n \\<rho>)\n    \\<le> trace\n           ((adjoint M0 * P * M0 + adjoint M1 * Q * M1) *\n            DS (D1 n \\<rho>)) +\n          (trace (D1 n \\<rho>) - trace (DS (D1 n \\<rho>)))", "using dsD1nr[of n] DS_def"], ["proof (prove)\nusing this:\n  \\<forall>\\<rho>\\<in>density_states.\n     trace (Q * \\<rho>)\n     \\<le> trace\n            ((adjoint M0 * P * M0 + adjoint M1 * Q * M1) *\n             denote S \\<rho>) +\n           (trace \\<rho> - trace (denote S \\<rho>))\n  D1 n \\<rho> \\<in> density_states\n  DS = denote S\n\ngoal (1 subgoal):\n 1. trace (Q * D1 n \\<rho>)\n    \\<le> trace\n           ((adjoint M0 * P * M0 + adjoint M1 * Q * M1) *\n            DS (D1 n \\<rho>)) +\n          (trace (D1 n \\<rho>) - trace (DS (D1 n \\<rho>)))", "by auto"], ["proof (state)\nthis:\n  trace (Q * D1 n \\<rho>)\n  \\<le> trace\n         ((adjoint M0 * P * M0 + adjoint M1 * Q * M1) * DS (D1 n \\<rho>)) +\n        (trace (D1 n \\<rho>) - trace (DS (D1 n \\<rho>)))\n\ngoal (1 subgoal):\n 1. trace (Q * D1 n \\<rho>)\n    \\<le> trace (P * D0 (Suc n) \\<rho>) + trace (Q * D1 (Suc n) \\<rho>) +\n          trace (D1 n \\<rho>) -\n          trace (D (Suc n) \\<rho>)", "have \"(DS (D1 n \\<rho>)) \\<in> carrier_mat d d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DS (D1 n \\<rho>) \\<in> carrier_mat d d", "unfolding DS_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. denote S (D1 n \\<rho>) \\<in> carrier_mat d d", "using denote_dim[OF wcs] dsD1nr density_states_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>?\\<rho> \\<in> carrier_mat d d;\n   partial_density_operator ?\\<rho>\\<rbrakk>\n  \\<Longrightarrow> denote S ?\\<rho> \\<in> carrier_mat d d\n  D1 ?n \\<rho> \\<in> density_states\n  density_states =\n  {\\<rho> \\<in> carrier_mat d d. partial_density_operator \\<rho>}\n\ngoal (1 subgoal):\n 1. denote S (D1 n \\<rho>) \\<in> carrier_mat d d", "by auto"], ["proof (state)\nthis:\n  DS (D1 n \\<rho>) \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. trace (Q * D1 n \\<rho>)\n    \\<le> trace (P * D0 (Suc n) \\<rho>) + trace (Q * D1 (Suc n) \\<rho>) +\n          trace (D1 n \\<rho>) -\n          trace (D (Suc n) \\<rho>)", "then"], ["proof (chain)\npicking this:\n  DS (D1 n \\<rho>) \\<in> carrier_mat d d", "have \"trace ((adjoint M0 * P * M0 + adjoint M1 * Q * M1) * (DS (D1 n \\<rho>)))\n        = trace (P * (M0 * (DS (D1 n \\<rho>)) * adjoint M0))\n        + trace (Q * (M1 * (DS (D1 n \\<rho>)) * adjoint M1))\""], ["proof (prove)\nusing this:\n  DS (D1 n \\<rho>) \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. trace ((adjoint M0 * P * M0 + adjoint M1 * Q * M1) * DS (D1 n \\<rho>)) =\n    trace (P * (M0 * DS (D1 n \\<rho>) * adjoint M0)) +\n    trace (Q * (M1 * DS (D1 n \\<rho>) * adjoint M1))", "using dP dQ dM0 dM1"], ["proof (prove)\nusing this:\n  DS (D1 n \\<rho>) \\<in> carrier_mat d d\n  P \\<in> carrier_mat d d\n  Q \\<in> carrier_mat d d\n  M0 \\<in> carrier_mat d d\n  M1 \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. trace ((adjoint M0 * P * M0 + adjoint M1 * Q * M1) * DS (D1 n \\<rho>)) =\n    trace (P * (M0 * DS (D1 n \\<rho>) * adjoint M0)) +\n    trace (Q * (M1 * DS (D1 n \\<rho>) * adjoint M1))", "by (mat_assoc d)"], ["proof (state)\nthis:\n  trace ((adjoint M0 * P * M0 + adjoint M1 * Q * M1) * DS (D1 n \\<rho>)) =\n  trace (P * (M0 * DS (D1 n \\<rho>) * adjoint M0)) +\n  trace (Q * (M1 * DS (D1 n \\<rho>) * adjoint M1))\n\ngoal (1 subgoal):\n 1. trace (Q * D1 n \\<rho>)\n    \\<le> trace (P * D0 (Suc n) \\<rho>) + trace (Q * D1 (Suc n) \\<rho>) +\n          trace (D1 n \\<rho>) -\n          trace (D (Suc n) \\<rho>)", "moreover"], ["proof (state)\nthis:\n  trace ((adjoint M0 * P * M0 + adjoint M1 * Q * M1) * DS (D1 n \\<rho>)) =\n  trace (P * (M0 * DS (D1 n \\<rho>) * adjoint M0)) +\n  trace (Q * (M1 * DS (D1 n \\<rho>) * adjoint M1))\n\ngoal (1 subgoal):\n 1. trace (Q * D1 n \\<rho>)\n    \\<le> trace (P * D0 (Suc n) \\<rho>) + trace (Q * D1 (Suc n) \\<rho>) +\n          trace (D1 n \\<rho>) -\n          trace (D (Suc n) \\<rho>)", "have \"trace (P * (M0 * (DS (D1 n \\<rho>)) * adjoint M0)) = trace (P * D0 (Suc n) \\<rho>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace (P * (M0 * DS (D1 n \\<rho>) * adjoint M0)) =\n    trace (P * D0 (Suc n) \\<rho>)", "unfolding D0_def denote_while_n.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. trace (P * (M0 * DS (D1 n \\<rho>) * adjoint M0)) =\n    trace\n     (P * (M0 * denote_while_n_iter M0 M1 DS (Suc n) \\<rho> * adjoint M0))", "apply (subst denote_while_n_iter_assoc)"], ["proof (prove)\ngoal (1 subgoal):\n 1. trace (P * (M0 * DS (D1 n \\<rho>) * adjoint M0)) =\n    trace\n     (P *\n      (M0 * DS (M1 * denote_while_n_iter M0 M1 DS n \\<rho> * adjoint M1) *\n       adjoint M0))", "by (fold denote_while_n_comp.simps D1_def, auto)"], ["proof (state)\nthis:\n  trace (P * (M0 * DS (D1 n \\<rho>) * adjoint M0)) =\n  trace (P * D0 (Suc n) \\<rho>)\n\ngoal (1 subgoal):\n 1. trace (Q * D1 n \\<rho>)\n    \\<le> trace (P * D0 (Suc n) \\<rho>) + trace (Q * D1 (Suc n) \\<rho>) +\n          trace (D1 n \\<rho>) -\n          trace (D (Suc n) \\<rho>)", "moreover"], ["proof (state)\nthis:\n  trace (P * (M0 * DS (D1 n \\<rho>) * adjoint M0)) =\n  trace (P * D0 (Suc n) \\<rho>)\n\ngoal (1 subgoal):\n 1. trace (Q * D1 n \\<rho>)\n    \\<le> trace (P * D0 (Suc n) \\<rho>) + trace (Q * D1 (Suc n) \\<rho>) +\n          trace (D1 n \\<rho>) -\n          trace (D (Suc n) \\<rho>)", "have \"trace (Q * (M1 * (DS (D1 n \\<rho>)) * adjoint M1)) = trace (Q * D1 (Suc n) \\<rho>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace (Q * (M1 * DS (D1 n \\<rho>) * adjoint M1)) =\n    trace (Q * D1 (Suc n) \\<rho>)", "apply (subst (2) D1_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. trace (Q * (M1 * DS (D1 n \\<rho>) * adjoint M1)) =\n    trace (Q * denote_while_n_comp M0 M1 DS (Suc n) \\<rho>)", "unfolding denote_while_n_comp.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. trace (Q * (M1 * DS (D1 n \\<rho>) * adjoint M1)) =\n    trace\n     (Q * (M1 * denote_while_n_iter M0 M1 DS (Suc n) \\<rho> * adjoint M1))", "apply (subst denote_while_n_iter_assoc)"], ["proof (prove)\ngoal (1 subgoal):\n 1. trace (Q * (M1 * DS (D1 n \\<rho>) * adjoint M1)) =\n    trace\n     (Q *\n      (M1 * DS (M1 * denote_while_n_iter M0 M1 DS n \\<rho> * adjoint M1) *\n       adjoint M1))", "by (fold denote_while_n_comp.simps D1_def, auto)"], ["proof (state)\nthis:\n  trace (Q * (M1 * DS (D1 n \\<rho>) * adjoint M1)) =\n  trace (Q * D1 (Suc n) \\<rho>)\n\ngoal (1 subgoal):\n 1. trace (Q * D1 n \\<rho>)\n    \\<le> trace (P * D0 (Suc n) \\<rho>) + trace (Q * D1 (Suc n) \\<rho>) +\n          trace (D1 n \\<rho>) -\n          trace (D (Suc n) \\<rho>)", "ultimately"], ["proof (chain)\npicking this:\n  trace ((adjoint M0 * P * M0 + adjoint M1 * Q * M1) * DS (D1 n \\<rho>)) =\n  trace (P * (M0 * DS (D1 n \\<rho>) * adjoint M0)) +\n  trace (Q * (M1 * DS (D1 n \\<rho>) * adjoint M1))\n  trace (P * (M0 * DS (D1 n \\<rho>) * adjoint M0)) =\n  trace (P * D0 (Suc n) \\<rho>)\n  trace (Q * (M1 * DS (D1 n \\<rho>) * adjoint M1)) =\n  trace (Q * D1 (Suc n) \\<rho>)", "have \"trace ((adjoint M0 * P * M0 + adjoint M1 * Q * M1) * (DS (D1 n \\<rho>))) \n        = trace (P * D0 (Suc n) \\<rho>) + trace (Q * D1 (Suc n) \\<rho>)\""], ["proof (prove)\nusing this:\n  trace ((adjoint M0 * P * M0 + adjoint M1 * Q * M1) * DS (D1 n \\<rho>)) =\n  trace (P * (M0 * DS (D1 n \\<rho>) * adjoint M0)) +\n  trace (Q * (M1 * DS (D1 n \\<rho>) * adjoint M1))\n  trace (P * (M0 * DS (D1 n \\<rho>) * adjoint M0)) =\n  trace (P * D0 (Suc n) \\<rho>)\n  trace (Q * (M1 * DS (D1 n \\<rho>) * adjoint M1)) =\n  trace (Q * D1 (Suc n) \\<rho>)\n\ngoal (1 subgoal):\n 1. trace ((adjoint M0 * P * M0 + adjoint M1 * Q * M1) * DS (D1 n \\<rho>)) =\n    trace (P * D0 (Suc n) \\<rho>) + trace (Q * D1 (Suc n) \\<rho>)", "by auto"], ["proof (state)\nthis:\n  trace ((adjoint M0 * P * M0 + adjoint M1 * Q * M1) * DS (D1 n \\<rho>)) =\n  trace (P * D0 (Suc n) \\<rho>) + trace (Q * D1 (Suc n) \\<rho>)\n\ngoal (1 subgoal):\n 1. trace (Q * D1 n \\<rho>)\n    \\<le> trace (P * D0 (Suc n) \\<rho>) + trace (Q * D1 (Suc n) \\<rho>) +\n          trace (D1 n \\<rho>) -\n          trace (D (Suc n) \\<rho>)", "moreover"], ["proof (state)\nthis:\n  trace ((adjoint M0 * P * M0 + adjoint M1 * Q * M1) * DS (D1 n \\<rho>)) =\n  trace (P * D0 (Suc n) \\<rho>) + trace (Q * D1 (Suc n) \\<rho>)\n\ngoal (1 subgoal):\n 1. trace (Q * D1 n \\<rho>)\n    \\<le> trace (P * D0 (Suc n) \\<rho>) + trace (Q * D1 (Suc n) \\<rho>) +\n          trace (D1 n \\<rho>) -\n          trace (D (Suc n) \\<rho>)", "have \"trace (DS (D1 n \\<rho>)) = trace (D (Suc n) \\<rho>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace (DS (D1 n \\<rho>)) = trace (D (Suc n) \\<rho>)", "unfolding D_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. trace (DS (D1 n \\<rho>)) =\n    trace (denote_while_n_iter M0 M1 DS (Suc n) \\<rho>)", "apply (subst denote_while_n_iter_assoc)"], ["proof (prove)\ngoal (1 subgoal):\n 1. trace (DS (D1 n \\<rho>)) =\n    trace (DS (M1 * denote_while_n_iter M0 M1 DS n \\<rho> * adjoint M1))", "by (fold denote_while_n_comp.simps D1_def, auto)"], ["proof (state)\nthis:\n  trace (DS (D1 n \\<rho>)) = trace (D (Suc n) \\<rho>)\n\ngoal (1 subgoal):\n 1. trace (Q * D1 n \\<rho>)\n    \\<le> trace (P * D0 (Suc n) \\<rho>) + trace (Q * D1 (Suc n) \\<rho>) +\n          trace (D1 n \\<rho>) -\n          trace (D (Suc n) \\<rho>)", "ultimately"], ["proof (chain)\npicking this:\n  trace ((adjoint M0 * P * M0 + adjoint M1 * Q * M1) * DS (D1 n \\<rho>)) =\n  trace (P * D0 (Suc n) \\<rho>) + trace (Q * D1 (Suc n) \\<rho>)\n  trace (DS (D1 n \\<rho>)) = trace (D (Suc n) \\<rho>)", "show ?thesis"], ["proof (prove)\nusing this:\n  trace ((adjoint M0 * P * M0 + adjoint M1 * Q * M1) * DS (D1 n \\<rho>)) =\n  trace (P * D0 (Suc n) \\<rho>) + trace (Q * D1 (Suc n) \\<rho>)\n  trace (DS (D1 n \\<rho>)) = trace (D (Suc n) \\<rho>)\n\ngoal (1 subgoal):\n 1. trace (Q * D1 n \\<rho>)\n    \\<le> trace (P * D0 (Suc n) \\<rho>) + trace (Q * D1 (Suc n) \\<rho>) +\n          trace (D1 n \\<rho>) -\n          trace (D (Suc n) \\<rho>)", "using leQn'"], ["proof (prove)\nusing this:\n  trace ((adjoint M0 * P * M0 + adjoint M1 * Q * M1) * DS (D1 n \\<rho>)) =\n  trace (P * D0 (Suc n) \\<rho>) + trace (Q * D1 (Suc n) \\<rho>)\n  trace (DS (D1 n \\<rho>)) = trace (D (Suc n) \\<rho>)\n  trace (Q * D1 n \\<rho>)\n  \\<le> trace\n         ((adjoint M0 * P * M0 + adjoint M1 * Q * M1) * DS (D1 n \\<rho>)) +\n        (trace (D1 n \\<rho>) - trace (DS (D1 n \\<rho>)))\n\ngoal (1 subgoal):\n 1. trace (Q * D1 n \\<rho>)\n    \\<le> trace (P * D0 (Suc n) \\<rho>) + trace (Q * D1 (Suc n) \\<rho>) +\n          trace (D1 n \\<rho>) -\n          trace (D (Suc n) \\<rho>)", "by auto"], ["proof (state)\nthis:\n  trace (Q * D1 n \\<rho>)\n  \\<le> trace (P * D0 (Suc n) \\<rho>) + trace (Q * D1 (Suc n) \\<rho>) +\n        trace (D1 n \\<rho>) -\n        trace (D (Suc n) \\<rho>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  trace (Q * D1 ?n \\<rho>)\n  \\<le> trace (P * D0 (Suc ?n) \\<rho>) + trace (Q * D1 (Suc ?n) \\<rho>) +\n        trace (D1 ?n \\<rho>) -\n        trace (D (Suc ?n) \\<rho>)\n\ngoal (2 subgoals):\n 1. \\<And>P Q S M.\n       \\<lbrakk>is_quantum_predicate P; is_quantum_predicate Q;\n        \\<turnstile>\\<^sub>p {Q} S\n                             {adjoint (M 0) * P * M 0 +\n                              adjoint (M 1) * Q * M 1};\n        well_com S \\<Longrightarrow>\n        \\<Turnstile>\\<^sub>p {Q} S\n        {adjoint (M 0) * P * M 0 + adjoint (M 1) * Q * M 1};\n        well_com (While M S)\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {adjoint (M 0) * P * M 0 +\n         adjoint (M 1) * Q * M 1}\n                         While M S {P}\n 2. \\<And>P Q P' Q' S.\n       \\<lbrakk>is_quantum_predicate P; is_quantum_predicate Q;\n        is_quantum_predicate P'; is_quantum_predicate Q';\n        P \\<le>\\<^sub>L P'; \\<turnstile>\\<^sub>p {P'} S {Q'};\n        well_com S \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P'} S {Q'};\n        Q' \\<le>\\<^sub>L Q; well_com S\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P} S {Q}", "have 12: \"trace (P * (M0 * \\<rho> * adjoint M0)) + trace (Q * (M1 * \\<rho> * adjoint M1))\n    \\<le> (\\<Sum>k=0..<(n+2). trace (P * (D0 k \\<rho>))) + trace (Q * (D1 (n+1) \\<rho>))\n      + (\\<Sum>k=0..<(n+1). trace (D1 k \\<rho>) - trace (D (k+1) \\<rho>))\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. trace (P * (M0 * \\<rho> * adjoint M0)) +\n    trace (Q * (M1 * \\<rho> * adjoint M1))\n    \\<le> (\\<Sum>k = 0..<n + 2. trace (P * D0 k \\<rho>)) +\n          trace (Q * D1 (n + 1) \\<rho>) +\n          (\\<Sum>k = 0..<n + 1.\n              trace (D1 k \\<rho>) - trace (D (k + 1) \\<rho>))", "proof (induct n)"], ["proof (state)\ngoal (2 subgoals):\n 1. trace (P * (M0 * \\<rho> * adjoint M0)) +\n    trace (Q * (M1 * \\<rho> * adjoint M1))\n    \\<le> (\\<Sum>k = 0..<0 + 2. trace (P * D0 k \\<rho>)) +\n          trace (Q * D1 (0 + 1) \\<rho>) +\n          (\\<Sum>k = 0..<0 + 1.\n              trace (D1 k \\<rho>) - trace (D (k + 1) \\<rho>))\n 2. \\<And>n.\n       trace (P * (M0 * \\<rho> * adjoint M0)) +\n       trace (Q * (M1 * \\<rho> * adjoint M1))\n       \\<le> (\\<Sum>k = 0..<n + 2. trace (P * D0 k \\<rho>)) +\n             trace (Q * D1 (n + 1) \\<rho>) +\n             (\\<Sum>k = 0..<n + 1.\n                 trace (D1 k \\<rho>) -\n                 trace (D (k + 1) \\<rho>)) \\<Longrightarrow>\n       trace (P * (M0 * \\<rho> * adjoint M0)) +\n       trace (Q * (M1 * \\<rho> * adjoint M1))\n       \\<le> (\\<Sum>k = 0..<Suc n + 2. trace (P * D0 k \\<rho>)) +\n             trace (Q * D1 (Suc n + 1) \\<rho>) +\n             (\\<Sum>k = 0..<Suc n + 1.\n                 trace (D1 k \\<rho>) - trace (D (k + 1) \\<rho>))", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. trace (P * (M0 * \\<rho> * adjoint M0)) +\n    trace (Q * (M1 * \\<rho> * adjoint M1))\n    \\<le> (\\<Sum>k = 0..<0 + 2. trace (P * D0 k \\<rho>)) +\n          trace (Q * D1 (0 + 1) \\<rho>) +\n          (\\<Sum>k = 0..<0 + 1.\n              trace (D1 k \\<rho>) - trace (D (k + 1) \\<rho>))\n 2. \\<And>n.\n       trace (P * (M0 * \\<rho> * adjoint M0)) +\n       trace (Q * (M1 * \\<rho> * adjoint M1))\n       \\<le> (\\<Sum>k = 0..<n + 2. trace (P * D0 k \\<rho>)) +\n             trace (Q * D1 (n + 1) \\<rho>) +\n             (\\<Sum>k = 0..<n + 1.\n                 trace (D1 k \\<rho>) -\n                 trace (D (k + 1) \\<rho>)) \\<Longrightarrow>\n       trace (P * (M0 * \\<rho> * adjoint M0)) +\n       trace (Q * (M1 * \\<rho> * adjoint M1))\n       \\<le> (\\<Sum>k = 0..<Suc n + 2. trace (P * D0 k \\<rho>)) +\n             trace (Q * D1 (Suc n + 1) \\<rho>) +\n             (\\<Sum>k = 0..<Suc n + 1.\n                 trace (D1 k \\<rho>) - trace (D (k + 1) \\<rho>))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. trace (P * (M0 * \\<rho> * adjoint M0)) +\n    trace (Q * (M1 * \\<rho> * adjoint M1))\n    \\<le> (\\<Sum>k = 0..<0 + 2. trace (P * D0 k \\<rho>)) +\n          trace (Q * D1 (0 + 1) \\<rho>) +\n          (\\<Sum>k = 0..<0 + 1.\n              trace (D1 k \\<rho>) - trace (D (k + 1) \\<rho>))", "apply (simp del: less_eq_complex_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. trace (P * (M0 * \\<rho> * adjoint M0)) +\n    trace (Q * (M1 * \\<rho> * adjoint M1))\n    \\<le> trace (P * D0 0 \\<rho>) + trace (P * D0 (Suc 0) \\<rho>) +\n          trace (Q * D1 (Suc 0) \\<rho>) +\n          (trace (D1 0 \\<rho>) - trace (D (Suc 0) \\<rho>))", "unfolding D0_def D1_def D_def  denote_while_n_comp.simps denote_while_n.simps denote_while_n_iter.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. trace (P * (M0 * \\<rho> * adjoint M0)) +\n    trace (Q * (M1 * \\<rho> * adjoint M1))\n    \\<le> trace (P * (M0 * \\<rho> * adjoint M0)) +\n          trace (P * (M0 * DS (M1 * \\<rho> * adjoint M1) * adjoint M0)) +\n          trace (Q * (M1 * DS (M1 * \\<rho> * adjoint M1) * adjoint M1)) +\n          (trace (M1 * \\<rho> * adjoint M1) -\n           trace (DS (M1 * \\<rho> * adjoint M1)))", "using leQn[of 0]"], ["proof (prove)\nusing this:\n  trace (Q * D1 0 \\<rho>)\n  \\<le> trace (P * D0 (Suc 0) \\<rho>) + trace (Q * D1 (Suc 0) \\<rho>) +\n        trace (D1 0 \\<rho>) -\n        trace (D (Suc 0) \\<rho>)\n\ngoal (1 subgoal):\n 1. trace (P * (M0 * \\<rho> * adjoint M0)) +\n    trace (Q * (M1 * \\<rho> * adjoint M1))\n    \\<le> trace (P * (M0 * \\<rho> * adjoint M0)) +\n          trace (P * (M0 * DS (M1 * \\<rho> * adjoint M1) * adjoint M0)) +\n          trace (Q * (M1 * DS (M1 * \\<rho> * adjoint M1) * adjoint M1)) +\n          (trace (M1 * \\<rho> * adjoint M1) -\n           trace (DS (M1 * \\<rho> * adjoint M1)))", "unfolding D1_def D0_def D_def denote_while_n.simps denote_while_n_comp.simps denote_while_n_iter.simps"], ["proof (prove)\nusing this:\n  trace (Q * (M1 * \\<rho> * adjoint M1))\n  \\<le> trace (P * (M0 * DS (M1 * \\<rho> * adjoint M1) * adjoint M0)) +\n        trace (Q * (M1 * DS (M1 * \\<rho> * adjoint M1) * adjoint M1)) +\n        trace (M1 * \\<rho> * adjoint M1) -\n        trace (DS (M1 * \\<rho> * adjoint M1))\n\ngoal (1 subgoal):\n 1. trace (P * (M0 * \\<rho> * adjoint M0)) +\n    trace (Q * (M1 * \\<rho> * adjoint M1))\n    \\<le> trace (P * (M0 * \\<rho> * adjoint M0)) +\n          trace (P * (M0 * DS (M1 * \\<rho> * adjoint M1) * adjoint M0)) +\n          trace (Q * (M1 * DS (M1 * \\<rho> * adjoint M1) * adjoint M1)) +\n          (trace (M1 * \\<rho> * adjoint M1) -\n           trace (DS (M1 * \\<rho> * adjoint M1)))", "by auto"], ["proof (state)\nthis:\n  trace (P * (M0 * \\<rho> * adjoint M0)) +\n  trace (Q * (M1 * \\<rho> * adjoint M1))\n  \\<le> (\\<Sum>k = 0..<0 + 2. trace (P * D0 k \\<rho>)) +\n        trace (Q * D1 (0 + 1) \\<rho>) +\n        (\\<Sum>k = 0..<0 + 1.\n            trace (D1 k \\<rho>) - trace (D (k + 1) \\<rho>))\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       trace (P * (M0 * \\<rho> * adjoint M0)) +\n       trace (Q * (M1 * \\<rho> * adjoint M1))\n       \\<le> (\\<Sum>k = 0..<n + 2. trace (P * D0 k \\<rho>)) +\n             trace (Q * D1 (n + 1) \\<rho>) +\n             (\\<Sum>k = 0..<n + 1.\n                 trace (D1 k \\<rho>) -\n                 trace (D (k + 1) \\<rho>)) \\<Longrightarrow>\n       trace (P * (M0 * \\<rho> * adjoint M0)) +\n       trace (Q * (M1 * \\<rho> * adjoint M1))\n       \\<le> (\\<Sum>k = 0..<Suc n + 2. trace (P * D0 k \\<rho>)) +\n             trace (Q * D1 (Suc n + 1) \\<rho>) +\n             (\\<Sum>k = 0..<Suc n + 1.\n                 trace (D1 k \\<rho>) - trace (D (k + 1) \\<rho>))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       trace (P * (M0 * \\<rho> * adjoint M0)) +\n       trace (Q * (M1 * \\<rho> * adjoint M1))\n       \\<le> (\\<Sum>k = 0..<n + 2. trace (P * D0 k \\<rho>)) +\n             trace (Q * D1 (n + 1) \\<rho>) +\n             (\\<Sum>k = 0..<n + 1.\n                 trace (D1 k \\<rho>) -\n                 trace (D (k + 1) \\<rho>)) \\<Longrightarrow>\n       trace (P * (M0 * \\<rho> * adjoint M0)) +\n       trace (Q * (M1 * \\<rho> * adjoint M1))\n       \\<le> (\\<Sum>k = 0..<Suc n + 2. trace (P * D0 k \\<rho>)) +\n             trace (Q * D1 (Suc n + 1) \\<rho>) +\n             (\\<Sum>k = 0..<Suc n + 1.\n                 trace (D1 k \\<rho>) - trace (D (k + 1) \\<rho>))", "case (Suc n)"], ["proof (state)\nthis:\n  trace (P * (M0 * \\<rho> * adjoint M0)) +\n  trace (Q * (M1 * \\<rho> * adjoint M1))\n  \\<le> (\\<Sum>k = 0..<n + 2. trace (P * D0 k \\<rho>)) +\n        trace (Q * D1 (n + 1) \\<rho>) +\n        (\\<Sum>k = 0..<n + 1.\n            trace (D1 k \\<rho>) - trace (D (k + 1) \\<rho>))\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       trace (P * (M0 * \\<rho> * adjoint M0)) +\n       trace (Q * (M1 * \\<rho> * adjoint M1))\n       \\<le> (\\<Sum>k = 0..<n + 2. trace (P * D0 k \\<rho>)) +\n             trace (Q * D1 (n + 1) \\<rho>) +\n             (\\<Sum>k = 0..<n + 1.\n                 trace (D1 k \\<rho>) -\n                 trace (D (k + 1) \\<rho>)) \\<Longrightarrow>\n       trace (P * (M0 * \\<rho> * adjoint M0)) +\n       trace (Q * (M1 * \\<rho> * adjoint M1))\n       \\<le> (\\<Sum>k = 0..<Suc n + 2. trace (P * D0 k \\<rho>)) +\n             trace (Q * D1 (Suc n + 1) \\<rho>) +\n             (\\<Sum>k = 0..<Suc n + 1.\n                 trace (D1 k \\<rho>) - trace (D (k + 1) \\<rho>))", "have \"trace (Q * D1 (n + 1) \\<rho>) \n          \\<le> trace (P * D0 (Suc (Suc n)) \\<rho>) + trace (Q * D1 (Suc (Suc n)) \\<rho>)\n          + trace (D1 (Suc n) \\<rho>) - trace (D (Suc (Suc n)) \\<rho>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace (Q * D1 (n + 1) \\<rho>)\n    \\<le> trace (P * D0 (Suc (Suc n)) \\<rho>) +\n          trace (Q * D1 (Suc (Suc n)) \\<rho>) +\n          trace (D1 (Suc n) \\<rho>) -\n          trace (D (Suc (Suc n)) \\<rho>)", "using leQn[of \"n + 1\"]"], ["proof (prove)\nusing this:\n  trace (Q * D1 (n + 1) \\<rho>)\n  \\<le> trace (P * D0 (Suc (n + 1)) \\<rho>) +\n        trace (Q * D1 (Suc (n + 1)) \\<rho>) +\n        trace (D1 (n + 1) \\<rho>) -\n        trace (D (Suc (n + 1)) \\<rho>)\n\ngoal (1 subgoal):\n 1. trace (Q * D1 (n + 1) \\<rho>)\n    \\<le> trace (P * D0 (Suc (Suc n)) \\<rho>) +\n          trace (Q * D1 (Suc (Suc n)) \\<rho>) +\n          trace (D1 (Suc n) \\<rho>) -\n          trace (D (Suc (Suc n)) \\<rho>)", "by auto"], ["proof (state)\nthis:\n  trace (Q * D1 (n + 1) \\<rho>)\n  \\<le> trace (P * D0 (Suc (Suc n)) \\<rho>) +\n        trace (Q * D1 (Suc (Suc n)) \\<rho>) +\n        trace (D1 (Suc n) \\<rho>) -\n        trace (D (Suc (Suc n)) \\<rho>)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       trace (P * (M0 * \\<rho> * adjoint M0)) +\n       trace (Q * (M1 * \\<rho> * adjoint M1))\n       \\<le> (\\<Sum>k = 0..<n + 2. trace (P * D0 k \\<rho>)) +\n             trace (Q * D1 (n + 1) \\<rho>) +\n             (\\<Sum>k = 0..<n + 1.\n                 trace (D1 k \\<rho>) -\n                 trace (D (k + 1) \\<rho>)) \\<Longrightarrow>\n       trace (P * (M0 * \\<rho> * adjoint M0)) +\n       trace (Q * (M1 * \\<rho> * adjoint M1))\n       \\<le> (\\<Sum>k = 0..<Suc n + 2. trace (P * D0 k \\<rho>)) +\n             trace (Q * D1 (Suc n + 1) \\<rho>) +\n             (\\<Sum>k = 0..<Suc n + 1.\n                 trace (D1 k \\<rho>) - trace (D (k + 1) \\<rho>))", "with Suc"], ["proof (chain)\npicking this:\n  trace (P * (M0 * \\<rho> * adjoint M0)) +\n  trace (Q * (M1 * \\<rho> * adjoint M1))\n  \\<le> (\\<Sum>k = 0..<n + 2. trace (P * D0 k \\<rho>)) +\n        trace (Q * D1 (n + 1) \\<rho>) +\n        (\\<Sum>k = 0..<n + 1.\n            trace (D1 k \\<rho>) - trace (D (k + 1) \\<rho>))\n  trace (Q * D1 (n + 1) \\<rho>)\n  \\<le> trace (P * D0 (Suc (Suc n)) \\<rho>) +\n        trace (Q * D1 (Suc (Suc n)) \\<rho>) +\n        trace (D1 (Suc n) \\<rho>) -\n        trace (D (Suc (Suc n)) \\<rho>)", "show ?case"], ["proof (prove)\nusing this:\n  trace (P * (M0 * \\<rho> * adjoint M0)) +\n  trace (Q * (M1 * \\<rho> * adjoint M1))\n  \\<le> (\\<Sum>k = 0..<n + 2. trace (P * D0 k \\<rho>)) +\n        trace (Q * D1 (n + 1) \\<rho>) +\n        (\\<Sum>k = 0..<n + 1.\n            trace (D1 k \\<rho>) - trace (D (k + 1) \\<rho>))\n  trace (Q * D1 (n + 1) \\<rho>)\n  \\<le> trace (P * D0 (Suc (Suc n)) \\<rho>) +\n        trace (Q * D1 (Suc (Suc n)) \\<rho>) +\n        trace (D1 (Suc n) \\<rho>) -\n        trace (D (Suc (Suc n)) \\<rho>)\n\ngoal (1 subgoal):\n 1. trace (P * (M0 * \\<rho> * adjoint M0)) +\n    trace (Q * (M1 * \\<rho> * adjoint M1))\n    \\<le> (\\<Sum>k = 0..<Suc n + 2. trace (P * D0 k \\<rho>)) +\n          trace (Q * D1 (Suc n + 1) \\<rho>) +\n          (\\<Sum>k = 0..<Suc n + 1.\n              trace (D1 k \\<rho>) - trace (D (k + 1) \\<rho>))", "apply (simp del: less_eq_complex_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>trace (P * (M0 * \\<rho> * adjoint M0)) +\n             trace (Q * (M1 * \\<rho> * adjoint M1))\n             \\<le> (\\<Sum>k = 0..<n. trace (P * D0 k \\<rho>)) +\n                   trace (P * D0 n \\<rho>) +\n                   trace (P * D0 (Suc n) \\<rho>) +\n                   trace (Q * D1 (Suc n) \\<rho>) +\n                   ((\\<Sum>k = 0..<n.\n                        trace (D1 k \\<rho>) - trace (D (Suc k) \\<rho>)) +\n                    (trace (D1 n \\<rho>) - trace (D (Suc n) \\<rho>)));\n     trace (Q * D1 (Suc n) \\<rho>)\n     \\<le> trace (P * D0 (Suc (Suc n)) \\<rho>) +\n           trace (Q * D1 (Suc (Suc n)) \\<rho>) +\n           trace (D1 (Suc n) \\<rho>) -\n           trace (D (Suc (Suc n)) \\<rho>)\\<rbrakk>\n    \\<Longrightarrow> trace (P * (M0 * \\<rho> * adjoint M0)) +\n                      trace (Q * (M1 * \\<rho> * adjoint M1))\n                      \\<le> (\\<Sum>k = 0..<n. trace (P * D0 k \\<rho>)) +\n                            trace (P * D0 n \\<rho>) +\n                            trace (P * D0 (Suc n) \\<rho>) +\n                            trace (P * D0 (Suc (Suc n)) \\<rho>) +\n                            trace (Q * D1 (Suc (Suc n)) \\<rho>) +\n                            ((\\<Sum>k = 0..<n.\n                                 trace (D1 k \\<rho>) -\n                                 trace (D (Suc k) \\<rho>)) +\n                             (trace (D1 n \\<rho>) -\n                              trace (D (Suc n) \\<rho>)) +\n                             (trace (D1 (Suc n) \\<rho>) -\n                              trace (D (Suc (Suc n)) \\<rho>)))", "by auto"], ["proof (state)\nthis:\n  trace (P * (M0 * \\<rho> * adjoint M0)) +\n  trace (Q * (M1 * \\<rho> * adjoint M1))\n  \\<le> (\\<Sum>k = 0..<Suc n + 2. trace (P * D0 k \\<rho>)) +\n        trace (Q * D1 (Suc n + 1) \\<rho>) +\n        (\\<Sum>k = 0..<Suc n + 1.\n            trace (D1 k \\<rho>) - trace (D (k + 1) \\<rho>))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  trace (P * (M0 * \\<rho> * adjoint M0)) +\n  trace (Q * (M1 * \\<rho> * adjoint M1))\n  \\<le> (\\<Sum>k = 0..<?n + 2. trace (P * D0 k \\<rho>)) +\n        trace (Q * D1 (?n + 1) \\<rho>) +\n        (\\<Sum>k = 0..<?n + 1.\n            trace (D1 k \\<rho>) - trace (D (k + 1) \\<rho>))\n\ngoal (2 subgoals):\n 1. \\<And>P Q S M.\n       \\<lbrakk>is_quantum_predicate P; is_quantum_predicate Q;\n        \\<turnstile>\\<^sub>p {Q} S\n                             {adjoint (M 0) * P * M 0 +\n                              adjoint (M 1) * Q * M 1};\n        well_com S \\<Longrightarrow>\n        \\<Turnstile>\\<^sub>p {Q} S\n        {adjoint (M 0) * P * M 0 + adjoint (M 1) * Q * M 1};\n        well_com (While M S)\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {adjoint (M 0) * P * M 0 +\n         adjoint (M 1) * Q * M 1}\n                         While M S {P}\n 2. \\<And>P Q P' Q' S.\n       \\<lbrakk>is_quantum_predicate P; is_quantum_predicate Q;\n        is_quantum_predicate P'; is_quantum_predicate Q';\n        P \\<le>\\<^sub>L P'; \\<turnstile>\\<^sub>p {P'} S {Q'};\n        well_com S \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P'} S {Q'};\n        Q' \\<le>\\<^sub>L Q; well_com S\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P} S {Q}", "have tr_measurement: \"\\<rho> \\<in> carrier_mat d d\n      \\<Longrightarrow> trace (M0 * \\<rho> * adjoint M0) + trace (M1 * \\<rho> * adjoint M1) = trace \\<rho>\" for \\<rho>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<rho> \\<in> carrier_mat d d \\<Longrightarrow>\n    trace (M0 * \\<rho> * adjoint M0) + trace (M1 * \\<rho> * adjoint M1) =\n    trace \\<rho>", "using trace_measurement2[OF m, folded M0_def M1_def]"], ["proof (prove)\nusing this:\n  ?A \\<in> carrier_mat d d \\<Longrightarrow>\n  trace (M0 * ?A * adjoint M0) + trace (M1 * ?A * adjoint M1) = trace ?A\n\ngoal (1 subgoal):\n 1. \\<rho> \\<in> carrier_mat d d \\<Longrightarrow>\n    trace (M0 * \\<rho> * adjoint M0) + trace (M1 * \\<rho> * adjoint M1) =\n    trace \\<rho>", "by auto"], ["proof (state)\nthis:\n  ?\\<rho> \\<in> carrier_mat d d \\<Longrightarrow>\n  trace (M0 * ?\\<rho> * adjoint M0) + trace (M1 * ?\\<rho> * adjoint M1) =\n  trace ?\\<rho>\n\ngoal (2 subgoals):\n 1. \\<And>P Q S M.\n       \\<lbrakk>is_quantum_predicate P; is_quantum_predicate Q;\n        \\<turnstile>\\<^sub>p {Q} S\n                             {adjoint (M 0) * P * M 0 +\n                              adjoint (M 1) * Q * M 1};\n        well_com S \\<Longrightarrow>\n        \\<Turnstile>\\<^sub>p {Q} S\n        {adjoint (M 0) * P * M 0 + adjoint (M 1) * Q * M 1};\n        well_com (While M S)\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {adjoint (M 0) * P * M 0 +\n         adjoint (M 1) * Q * M 1}\n                         While M S {P}\n 2. \\<And>P Q P' Q' S.\n       \\<lbrakk>is_quantum_predicate P; is_quantum_predicate Q;\n        is_quantum_predicate P'; is_quantum_predicate Q';\n        P \\<le>\\<^sub>L P'; \\<turnstile>\\<^sub>p {P'} S {Q'};\n        well_com S \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P'} S {Q'};\n        Q' \\<le>\\<^sub>L Q; well_com S\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P} S {Q}", "have 14: \"(\\<Sum>k=0..<(n+1). trace (D1 k \\<rho>) - trace (D (k+1) \\<rho>)) = trace \\<rho> - trace (D (n+1) \\<rho>) - (\\<Sum>k=0..<(n+1). trace (D0 k \\<rho>))\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k = 0..<n + 1. trace (D1 k \\<rho>) - trace (D (k + 1) \\<rho>)) =\n    trace \\<rho> - trace (D (n + 1) \\<rho>) -\n    (\\<Sum>k = 0..<n + 1. trace (D0 k \\<rho>))", "proof (induct n)"], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<Sum>k = 0..<0 + 1. trace (D1 k \\<rho>) - trace (D (k + 1) \\<rho>)) =\n    trace \\<rho> - trace (D (0 + 1) \\<rho>) -\n    (\\<Sum>k = 0..<0 + 1. trace (D0 k \\<rho>))\n 2. \\<And>n.\n       (\\<Sum>k = 0..<n + 1.\n           trace (D1 k \\<rho>) - trace (D (k + 1) \\<rho>)) =\n       trace \\<rho> - trace (D (n + 1) \\<rho>) -\n       (\\<Sum>k = 0..<n + 1. trace (D0 k \\<rho>)) \\<Longrightarrow>\n       (\\<Sum>k = 0..<Suc n + 1.\n           trace (D1 k \\<rho>) - trace (D (k + 1) \\<rho>)) =\n       trace \\<rho> - trace (D (Suc n + 1) \\<rho>) -\n       (\\<Sum>k = 0..<Suc n + 1. trace (D0 k \\<rho>))", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. (\\<Sum>k = 0..<0 + 1. trace (D1 k \\<rho>) - trace (D (k + 1) \\<rho>)) =\n    trace \\<rho> - trace (D (0 + 1) \\<rho>) -\n    (\\<Sum>k = 0..<0 + 1. trace (D0 k \\<rho>))\n 2. \\<And>n.\n       (\\<Sum>k = 0..<n + 1.\n           trace (D1 k \\<rho>) - trace (D (k + 1) \\<rho>)) =\n       trace \\<rho> - trace (D (n + 1) \\<rho>) -\n       (\\<Sum>k = 0..<n + 1. trace (D0 k \\<rho>)) \\<Longrightarrow>\n       (\\<Sum>k = 0..<Suc n + 1.\n           trace (D1 k \\<rho>) - trace (D (k + 1) \\<rho>)) =\n       trace \\<rho> - trace (D (Suc n + 1) \\<rho>) -\n       (\\<Sum>k = 0..<Suc n + 1. trace (D0 k \\<rho>))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k = 0..<0 + 1. trace (D1 k \\<rho>) - trace (D (k + 1) \\<rho>)) =\n    trace \\<rho> - trace (D (0 + 1) \\<rho>) -\n    (\\<Sum>k = 0..<0 + 1. trace (D0 k \\<rho>))", "apply (simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. trace (D1 0 \\<rho>) = trace \\<rho> - trace (D0 0 \\<rho>)", "unfolding D1_def D0_def denote_while_n_comp.simps denote_while_n.simps denote_while_n_iter.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. trace (M1 * \\<rho> * adjoint M1) =\n    trace \\<rho> - trace (M0 * \\<rho> * adjoint M0)", "using tr_measurement[OF dr]"], ["proof (prove)\nusing this:\n  trace (M0 * \\<rho> * adjoint M0) + trace (M1 * \\<rho> * adjoint M1) =\n  trace \\<rho>\n\ngoal (1 subgoal):\n 1. trace (M1 * \\<rho> * adjoint M1) =\n    trace \\<rho> - trace (M0 * \\<rho> * adjoint M0)", "by (auto simp add: algebra_simps)"], ["proof (state)\nthis:\n  (\\<Sum>k = 0..<0 + 1. trace (D1 k \\<rho>) - trace (D (k + 1) \\<rho>)) =\n  trace \\<rho> - trace (D (0 + 1) \\<rho>) -\n  (\\<Sum>k = 0..<0 + 1. trace (D0 k \\<rho>))\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       (\\<Sum>k = 0..<n + 1.\n           trace (D1 k \\<rho>) - trace (D (k + 1) \\<rho>)) =\n       trace \\<rho> - trace (D (n + 1) \\<rho>) -\n       (\\<Sum>k = 0..<n + 1. trace (D0 k \\<rho>)) \\<Longrightarrow>\n       (\\<Sum>k = 0..<Suc n + 1.\n           trace (D1 k \\<rho>) - trace (D (k + 1) \\<rho>)) =\n       trace \\<rho> - trace (D (Suc n + 1) \\<rho>) -\n       (\\<Sum>k = 0..<Suc n + 1. trace (D0 k \\<rho>))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       (\\<Sum>k = 0..<n + 1.\n           trace (D1 k \\<rho>) - trace (D (k + 1) \\<rho>)) =\n       trace \\<rho> - trace (D (n + 1) \\<rho>) -\n       (\\<Sum>k = 0..<n + 1. trace (D0 k \\<rho>)) \\<Longrightarrow>\n       (\\<Sum>k = 0..<Suc n + 1.\n           trace (D1 k \\<rho>) - trace (D (k + 1) \\<rho>)) =\n       trace \\<rho> - trace (D (Suc n + 1) \\<rho>) -\n       (\\<Sum>k = 0..<Suc n + 1. trace (D0 k \\<rho>))", "case (Suc n)"], ["proof (state)\nthis:\n  (\\<Sum>k = 0..<n + 1. trace (D1 k \\<rho>) - trace (D (k + 1) \\<rho>)) =\n  trace \\<rho> - trace (D (n + 1) \\<rho>) -\n  (\\<Sum>k = 0..<n + 1. trace (D0 k \\<rho>))\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       (\\<Sum>k = 0..<n + 1.\n           trace (D1 k \\<rho>) - trace (D (k + 1) \\<rho>)) =\n       trace \\<rho> - trace (D (n + 1) \\<rho>) -\n       (\\<Sum>k = 0..<n + 1. trace (D0 k \\<rho>)) \\<Longrightarrow>\n       (\\<Sum>k = 0..<Suc n + 1.\n           trace (D1 k \\<rho>) - trace (D (k + 1) \\<rho>)) =\n       trace \\<rho> - trace (D (Suc n + 1) \\<rho>) -\n       (\\<Sum>k = 0..<Suc n + 1. trace (D0 k \\<rho>))", "have \"trace (D0 (Suc n) \\<rho>) + trace (D1 (Suc n) \\<rho>) = trace (D (Suc n) \\<rho>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace (D0 (Suc n) \\<rho>) + trace (D1 (Suc n) \\<rho>) =\n    trace (D (Suc n) \\<rho>)", "unfolding D0_def D1_def denote_while_n.simps denote_while_n_comp.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. trace (M0 * denote_while_n_iter M0 M1 DS (Suc n) \\<rho> * adjoint M0) +\n    trace (M1 * denote_while_n_iter M0 M1 DS (Suc n) \\<rho> * adjoint M1) =\n    trace (D (Suc n) \\<rho>)", "apply (fold D_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. trace (M0 * D (Suc n) \\<rho> * adjoint M0) +\n    trace (M1 * D (Suc n) \\<rho> * adjoint M1) =\n    trace (D (Suc n) \\<rho>)", "using tr_measurement dDkr"], ["proof (prove)\nusing this:\n  ?\\<rho> \\<in> carrier_mat d d \\<Longrightarrow>\n  trace (M0 * ?\\<rho> * adjoint M0) + trace (M1 * ?\\<rho> * adjoint M1) =\n  trace ?\\<rho>\n  D ?k \\<rho> \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. trace (M0 * D (Suc n) \\<rho> * adjoint M0) +\n    trace (M1 * D (Suc n) \\<rho> * adjoint M1) =\n    trace (D (Suc n) \\<rho>)", "by auto"], ["proof (state)\nthis:\n  trace (D0 (Suc n) \\<rho>) + trace (D1 (Suc n) \\<rho>) =\n  trace (D (Suc n) \\<rho>)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       (\\<Sum>k = 0..<n + 1.\n           trace (D1 k \\<rho>) - trace (D (k + 1) \\<rho>)) =\n       trace \\<rho> - trace (D (n + 1) \\<rho>) -\n       (\\<Sum>k = 0..<n + 1. trace (D0 k \\<rho>)) \\<Longrightarrow>\n       (\\<Sum>k = 0..<Suc n + 1.\n           trace (D1 k \\<rho>) - trace (D (k + 1) \\<rho>)) =\n       trace \\<rho> - trace (D (Suc n + 1) \\<rho>) -\n       (\\<Sum>k = 0..<Suc n + 1. trace (D0 k \\<rho>))", "then"], ["proof (chain)\npicking this:\n  trace (D0 (Suc n) \\<rho>) + trace (D1 (Suc n) \\<rho>) =\n  trace (D (Suc n) \\<rho>)", "have \"trace (D1 (Suc n) \\<rho>) = trace (D (Suc n) \\<rho>) - trace (D0 (Suc n) \\<rho>)\""], ["proof (prove)\nusing this:\n  trace (D0 (Suc n) \\<rho>) + trace (D1 (Suc n) \\<rho>) =\n  trace (D (Suc n) \\<rho>)\n\ngoal (1 subgoal):\n 1. trace (D1 (Suc n) \\<rho>) =\n    trace (D (Suc n) \\<rho>) - trace (D0 (Suc n) \\<rho>)", "by (auto simp add: algebra_simps)"], ["proof (state)\nthis:\n  trace (D1 (Suc n) \\<rho>) =\n  trace (D (Suc n) \\<rho>) - trace (D0 (Suc n) \\<rho>)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       (\\<Sum>k = 0..<n + 1.\n           trace (D1 k \\<rho>) - trace (D (k + 1) \\<rho>)) =\n       trace \\<rho> - trace (D (n + 1) \\<rho>) -\n       (\\<Sum>k = 0..<n + 1. trace (D0 k \\<rho>)) \\<Longrightarrow>\n       (\\<Sum>k = 0..<Suc n + 1.\n           trace (D1 k \\<rho>) - trace (D (k + 1) \\<rho>)) =\n       trace \\<rho> - trace (D (Suc n + 1) \\<rho>) -\n       (\\<Sum>k = 0..<Suc n + 1. trace (D0 k \\<rho>))", "then"], ["proof (chain)\npicking this:\n  trace (D1 (Suc n) \\<rho>) =\n  trace (D (Suc n) \\<rho>) - trace (D0 (Suc n) \\<rho>)", "show ?case"], ["proof (prove)\nusing this:\n  trace (D1 (Suc n) \\<rho>) =\n  trace (D (Suc n) \\<rho>) - trace (D0 (Suc n) \\<rho>)\n\ngoal (1 subgoal):\n 1. (\\<Sum>k = 0..<Suc n + 1.\n        trace (D1 k \\<rho>) - trace (D (k + 1) \\<rho>)) =\n    trace \\<rho> - trace (D (Suc n + 1) \\<rho>) -\n    (\\<Sum>k = 0..<Suc n + 1. trace (D0 k \\<rho>))", "using Suc"], ["proof (prove)\nusing this:\n  trace (D1 (Suc n) \\<rho>) =\n  trace (D (Suc n) \\<rho>) - trace (D0 (Suc n) \\<rho>)\n  (\\<Sum>k = 0..<n + 1. trace (D1 k \\<rho>) - trace (D (k + 1) \\<rho>)) =\n  trace \\<rho> - trace (D (n + 1) \\<rho>) -\n  (\\<Sum>k = 0..<n + 1. trace (D0 k \\<rho>))\n\ngoal (1 subgoal):\n 1. (\\<Sum>k = 0..<Suc n + 1.\n        trace (D1 k \\<rho>) - trace (D (k + 1) \\<rho>)) =\n    trace \\<rho> - trace (D (Suc n + 1) \\<rho>) -\n    (\\<Sum>k = 0..<Suc n + 1. trace (D0 k \\<rho>))", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>k = 0..<Suc n + 1.\n      trace (D1 k \\<rho>) - trace (D (k + 1) \\<rho>)) =\n  trace \\<rho> - trace (D (Suc n + 1) \\<rho>) -\n  (\\<Sum>k = 0..<Suc n + 1. trace (D0 k \\<rho>))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>k = 0..<?n + 1. trace (D1 k \\<rho>) - trace (D (k + 1) \\<rho>)) =\n  trace \\<rho> - trace (D (?n + 1) \\<rho>) -\n  (\\<Sum>k = 0..<?n + 1. trace (D0 k \\<rho>))\n\ngoal (2 subgoals):\n 1. \\<And>P Q S M.\n       \\<lbrakk>is_quantum_predicate P; is_quantum_predicate Q;\n        \\<turnstile>\\<^sub>p {Q} S\n                             {adjoint (M 0) * P * M 0 +\n                              adjoint (M 1) * Q * M 1};\n        well_com S \\<Longrightarrow>\n        \\<Turnstile>\\<^sub>p {Q} S\n        {adjoint (M 0) * P * M 0 + adjoint (M 1) * Q * M 1};\n        well_com (While M S)\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {adjoint (M 0) * P * M 0 +\n         adjoint (M 1) * Q * M 1}\n                         While M S {P}\n 2. \\<And>P Q P' Q' S.\n       \\<lbrakk>is_quantum_predicate P; is_quantum_predicate Q;\n        is_quantum_predicate P'; is_quantum_predicate Q';\n        P \\<le>\\<^sub>L P'; \\<turnstile>\\<^sub>p {P'} S {Q'};\n        well_com S \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P'} S {Q'};\n        Q' \\<le>\\<^sub>L Q; well_com S\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P} S {Q}", "have 15: \"trace (Q * (D1 n \\<rho>)) \\<le> trace (D n \\<rho>) - trace (D0 n \\<rho>)\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. trace (Q * D1 n \\<rho>) \\<le> trace (D n \\<rho>) - trace (D0 n \\<rho>)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. trace (Q * D1 n \\<rho>) \\<le> trace (D n \\<rho>) - trace (D0 n \\<rho>)", "have QleId: \"Q \\<le>\\<^sub>L 1\\<^sub>m d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Q \\<le>\\<^sub>L 1\\<^sub>m d", "using is_quantum_predicate_def qpQ"], ["proof (prove)\nusing this:\n  is_quantum_predicate ?P =\n  (?P \\<in> carrier_mat d d \\<and>\n   positive ?P \\<and> ?P \\<le>\\<^sub>L 1\\<^sub>m d)\n  is_quantum_predicate Q\n\ngoal (1 subgoal):\n 1. Q \\<le>\\<^sub>L 1\\<^sub>m d", "by auto"], ["proof (state)\nthis:\n  Q \\<le>\\<^sub>L 1\\<^sub>m d\n\ngoal (1 subgoal):\n 1. trace (Q * D1 n \\<rho>) \\<le> trace (D n \\<rho>) - trace (D0 n \\<rho>)", "then"], ["proof (chain)\npicking this:\n  Q \\<le>\\<^sub>L 1\\<^sub>m d", "have \"trace (Q * (D1 n \\<rho>)) \\<le> trace (1\\<^sub>m d * (D1 n \\<rho>))\""], ["proof (prove)\nusing this:\n  Q \\<le>\\<^sub>L 1\\<^sub>m d\n\ngoal (1 subgoal):\n 1. trace (Q * D1 n \\<rho>) \\<le> trace (1\\<^sub>m d * D1 n \\<rho>)", "using \n          dsD1nr[of n]"], ["proof (prove)\nusing this:\n  Q \\<le>\\<^sub>L 1\\<^sub>m d\n  D1 n \\<rho> \\<in> density_states\n\ngoal (1 subgoal):\n 1. trace (Q * D1 n \\<rho>) \\<le> trace (1\\<^sub>m d * D1 n \\<rho>)", "unfolding density_states_def lowner_le_trace[OF dQ one_carrier_mat]"], ["proof (prove)\nusing this:\n  \\<forall>\\<rho>\\<in>carrier_mat d d.\n     partial_density_operator \\<rho> \\<longrightarrow>\n     trace (Q * \\<rho>) \\<le> trace (1\\<^sub>m d * \\<rho>)\n  D1 n \\<rho>\n  \\<in> {\\<rho> \\<in> carrier_mat d d. partial_density_operator \\<rho>}\n\ngoal (1 subgoal):\n 1. trace (Q * D1 n \\<rho>) \\<le> trace (1\\<^sub>m d * D1 n \\<rho>)", "by auto"], ["proof (state)\nthis:\n  trace (Q * D1 n \\<rho>) \\<le> trace (1\\<^sub>m d * D1 n \\<rho>)\n\ngoal (1 subgoal):\n 1. trace (Q * D1 n \\<rho>) \\<le> trace (D n \\<rho>) - trace (D0 n \\<rho>)", "also"], ["proof (state)\nthis:\n  trace (Q * D1 n \\<rho>) \\<le> trace (1\\<^sub>m d * D1 n \\<rho>)\n\ngoal (1 subgoal):\n 1. trace (Q * D1 n \\<rho>) \\<le> trace (D n \\<rho>) - trace (D0 n \\<rho>)", "have \"\\<dots> = trace (D1 n \\<rho>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace (1\\<^sub>m d * D1 n \\<rho>) = trace (D1 n \\<rho>)", "using dsD1nr[of n]"], ["proof (prove)\nusing this:\n  D1 n \\<rho> \\<in> density_states\n\ngoal (1 subgoal):\n 1. trace (1\\<^sub>m d * D1 n \\<rho>) = trace (D1 n \\<rho>)", "unfolding density_states_def"], ["proof (prove)\nusing this:\n  D1 n \\<rho>\n  \\<in> {\\<rho> \\<in> carrier_mat d d. partial_density_operator \\<rho>}\n\ngoal (1 subgoal):\n 1. trace (1\\<^sub>m d * D1 n \\<rho>) = trace (D1 n \\<rho>)", "by auto"], ["proof (state)\nthis:\n  trace (1\\<^sub>m d * D1 n \\<rho>) = trace (D1 n \\<rho>)\n\ngoal (1 subgoal):\n 1. trace (Q * D1 n \\<rho>) \\<le> trace (D n \\<rho>) - trace (D0 n \\<rho>)", "also"], ["proof (state)\nthis:\n  trace (1\\<^sub>m d * D1 n \\<rho>) = trace (D1 n \\<rho>)\n\ngoal (1 subgoal):\n 1. trace (Q * D1 n \\<rho>) \\<le> trace (D n \\<rho>) - trace (D0 n \\<rho>)", "have \"\\<dots> = trace (M1 * (D n \\<rho>) * adjoint M1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace (D1 n \\<rho>) = trace (M1 * D n \\<rho> * adjoint M1)", "unfolding D1_def denote_while_n_comp.simps D_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. trace (M1 * denote_while_n_iter M0 M1 DS n \\<rho> * adjoint M1) =\n    trace (M1 * denote_while_n_iter M0 M1 DS n \\<rho> * adjoint M1)", "by auto"], ["proof (state)\nthis:\n  trace (D1 n \\<rho>) = trace (M1 * D n \\<rho> * adjoint M1)\n\ngoal (1 subgoal):\n 1. trace (Q * D1 n \\<rho>) \\<le> trace (D n \\<rho>) - trace (D0 n \\<rho>)", "also"], ["proof (state)\nthis:\n  trace (D1 n \\<rho>) = trace (M1 * D n \\<rho> * adjoint M1)\n\ngoal (1 subgoal):\n 1. trace (Q * D1 n \\<rho>) \\<le> trace (D n \\<rho>) - trace (D0 n \\<rho>)", "have \"\\<dots> = trace (D n \\<rho>) - trace (M0 * (D n \\<rho>) * adjoint M0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace (M1 * D n \\<rho> * adjoint M1) =\n    trace (D n \\<rho>) - trace (M0 * D n \\<rho> * adjoint M0)", "using tr_measurement[OF dDkr[of n]]"], ["proof (prove)\nusing this:\n  trace (M0 * D n \\<rho> * adjoint M0) +\n  trace (M1 * D n \\<rho> * adjoint M1) =\n  trace (D n \\<rho>)\n\ngoal (1 subgoal):\n 1. trace (M1 * D n \\<rho> * adjoint M1) =\n    trace (D n \\<rho>) - trace (M0 * D n \\<rho> * adjoint M0)", "by (simp add: algebra_simps)"], ["proof (state)\nthis:\n  trace (M1 * D n \\<rho> * adjoint M1) =\n  trace (D n \\<rho>) - trace (M0 * D n \\<rho> * adjoint M0)\n\ngoal (1 subgoal):\n 1. trace (Q * D1 n \\<rho>) \\<le> trace (D n \\<rho>) - trace (D0 n \\<rho>)", "also"], ["proof (state)\nthis:\n  trace (M1 * D n \\<rho> * adjoint M1) =\n  trace (D n \\<rho>) - trace (M0 * D n \\<rho> * adjoint M0)\n\ngoal (1 subgoal):\n 1. trace (Q * D1 n \\<rho>) \\<le> trace (D n \\<rho>) - trace (D0 n \\<rho>)", "have \"\\<dots> = trace (D n \\<rho>) - trace (D0 n \\<rho>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace (D n \\<rho>) - trace (M0 * D n \\<rho> * adjoint M0) =\n    trace (D n \\<rho>) - trace (D0 n \\<rho>)", "unfolding D0_def denote_while_n.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. trace (D n \\<rho>) - trace (M0 * D n \\<rho> * adjoint M0) =\n    trace (D n \\<rho>) -\n    trace (M0 * denote_while_n_iter M0 M1 DS n \\<rho> * adjoint M0)", "by (fold D_def, auto)"], ["proof (state)\nthis:\n  trace (D n \\<rho>) - trace (M0 * D n \\<rho> * adjoint M0) =\n  trace (D n \\<rho>) - trace (D0 n \\<rho>)\n\ngoal (1 subgoal):\n 1. trace (Q * D1 n \\<rho>) \\<le> trace (D n \\<rho>) - trace (D0 n \\<rho>)", "finally"], ["proof (chain)\npicking this:\n  trace (Q * D1 n \\<rho>) \\<le> trace (D n \\<rho>) - trace (D0 n \\<rho>)", "show ?thesis"], ["proof (prove)\nusing this:\n  trace (Q * D1 n \\<rho>) \\<le> trace (D n \\<rho>) - trace (D0 n \\<rho>)\n\ngoal (1 subgoal):\n 1. trace (Q * D1 n \\<rho>) \\<le> trace (D n \\<rho>) - trace (D0 n \\<rho>)", "."], ["proof (state)\nthis:\n  trace (Q * D1 n \\<rho>) \\<le> trace (D n \\<rho>) - trace (D0 n \\<rho>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  trace (Q * D1 ?n \\<rho>) \\<le> trace (D ?n \\<rho>) - trace (D0 ?n \\<rho>)\n\ngoal (2 subgoals):\n 1. \\<And>P Q S M.\n       \\<lbrakk>is_quantum_predicate P; is_quantum_predicate Q;\n        \\<turnstile>\\<^sub>p {Q} S\n                             {adjoint (M 0) * P * M 0 +\n                              adjoint (M 1) * Q * M 1};\n        well_com S \\<Longrightarrow>\n        \\<Turnstile>\\<^sub>p {Q} S\n        {adjoint (M 0) * P * M 0 + adjoint (M 1) * Q * M 1};\n        well_com (While M S)\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {adjoint (M 0) * P * M 0 +\n         adjoint (M 1) * Q * M 1}\n                         While M S {P}\n 2. \\<And>P Q P' Q' S.\n       \\<lbrakk>is_quantum_predicate P; is_quantum_predicate Q;\n        is_quantum_predicate P'; is_quantum_predicate Q';\n        P \\<le>\\<^sub>L P'; \\<turnstile>\\<^sub>p {P'} S {Q'};\n        well_com S \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P'} S {Q'};\n        Q' \\<le>\\<^sub>L Q; well_com S\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P} S {Q}", "have tmp: \"\\<And>a b c. 0 \\<le> a \\<Longrightarrow> b \\<le> c - a \\<Longrightarrow> b \\<le> (c::complex)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>0 \\<le> a; b \\<le> c - a\\<rbrakk>\n       \\<Longrightarrow> b \\<le> c", "by simp"], ["proof (state)\nthis:\n  \\<lbrakk>0 \\<le> ?a; ?b \\<le> ?c - ?a\\<rbrakk>\n  \\<Longrightarrow> ?b \\<le> ?c\n\ngoal (2 subgoals):\n 1. \\<And>P Q S M.\n       \\<lbrakk>is_quantum_predicate P; is_quantum_predicate Q;\n        \\<turnstile>\\<^sub>p {Q} S\n                             {adjoint (M 0) * P * M 0 +\n                              adjoint (M 1) * Q * M 1};\n        well_com S \\<Longrightarrow>\n        \\<Turnstile>\\<^sub>p {Q} S\n        {adjoint (M 0) * P * M 0 + adjoint (M 1) * Q * M 1};\n        well_com (While M S)\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {adjoint (M 0) * P * M 0 +\n         adjoint (M 1) * Q * M 1}\n                         While M S {P}\n 2. \\<And>P Q P' Q' S.\n       \\<lbrakk>is_quantum_predicate P; is_quantum_predicate Q;\n        is_quantum_predicate P'; is_quantum_predicate Q';\n        P \\<le>\\<^sub>L P'; \\<turnstile>\\<^sub>p {P'} S {Q'};\n        well_com S \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P'} S {Q'};\n        Q' \\<le>\\<^sub>L Q; well_com S\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P} S {Q}", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>0 \\<le> ?a; ?b \\<le> ?c - ?a\\<rbrakk>\n  \\<Longrightarrow> ?b \\<le> ?c", "have 151: \"\\<And>n. trace (Q * (D1 n \\<rho>)) \\<le> trace (D n \\<rho>)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>0 \\<le> ?a; ?b \\<le> ?c - ?a\\<rbrakk>\n  \\<Longrightarrow> ?b \\<le> ?c\n\ngoal (1 subgoal):\n 1. \\<And>n. trace (Q * D1 n \\<rho>) \\<le> trace (D n \\<rho>)", "by (auto simp add: tmp[OF trge0 15] simp del: less_eq_complex_def)"], ["proof (state)\nthis:\n  trace (Q * D1 ?n \\<rho>) \\<le> trace (D ?n \\<rho>)\n\ngoal (2 subgoals):\n 1. \\<And>P Q S M.\n       \\<lbrakk>is_quantum_predicate P; is_quantum_predicate Q;\n        \\<turnstile>\\<^sub>p {Q} S\n                             {adjoint (M 0) * P * M 0 +\n                              adjoint (M 1) * Q * M 1};\n        well_com S \\<Longrightarrow>\n        \\<Turnstile>\\<^sub>p {Q} S\n        {adjoint (M 0) * P * M 0 + adjoint (M 1) * Q * M 1};\n        well_com (While M S)\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {adjoint (M 0) * P * M 0 +\n         adjoint (M 1) * Q * M 1}\n                         While M S {P}\n 2. \\<And>P Q P' Q' S.\n       \\<lbrakk>is_quantum_predicate P; is_quantum_predicate Q;\n        is_quantum_predicate P'; is_quantum_predicate Q';\n        P \\<le>\\<^sub>L P'; \\<turnstile>\\<^sub>p {P'} S {Q'};\n        well_com S \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P'} S {Q'};\n        Q' \\<le>\\<^sub>L Q; well_com S\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P} S {Q}", "have main_leq: \"\\<And>n. trace (P * (M0 * \\<rho> * adjoint M0)) + trace (Q * (M1 * \\<rho> * adjoint M1))\n          \\<le> trace (P * (matrix_sum d (\\<lambda>k. D0 k \\<rho>) (n+2))) + trace \\<rho> - trace (matrix_sum d (\\<lambda>k. D0 k \\<rho>) (n+2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       trace (P * (M0 * \\<rho> * adjoint M0)) +\n       trace (Q * (M1 * \\<rho> * adjoint M1))\n       \\<le> trace (P * matrix_sum d (\\<lambda>k. D0 k \\<rho>) (n + 2)) +\n             trace \\<rho> -\n             trace (matrix_sum d (\\<lambda>k. D0 k \\<rho>) (n + 2))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       trace (P * (M0 * \\<rho> * adjoint M0)) +\n       trace (Q * (M1 * \\<rho> * adjoint M1))\n       \\<le> trace (P * matrix_sum d (\\<lambda>k. D0 k \\<rho>) (n + 2)) +\n             trace \\<rho> -\n             trace (matrix_sum d (\\<lambda>k. D0 k \\<rho>) (n + 2))", "fix n"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       trace (P * (M0 * \\<rho> * adjoint M0)) +\n       trace (Q * (M1 * \\<rho> * adjoint M1))\n       \\<le> trace (P * matrix_sum d (\\<lambda>k. D0 k \\<rho>) (n + 2)) +\n             trace \\<rho> -\n             trace (matrix_sum d (\\<lambda>k. D0 k \\<rho>) (n + 2))", "have \"(\\<Sum>k=0..<(n+2). trace (P * (D0 k \\<rho>))) + trace (Q * (D1 (n+1) \\<rho>))\n            + (\\<Sum>k=0..<(n+1). trace (D1 k \\<rho>) - trace (D (k+1) \\<rho>))\n            \\<le> (\\<Sum>k=0..<(n+2). trace (P * (D0 k \\<rho>))) + trace (Q * (D1 (n+1) \\<rho>))\n            + trace \\<rho> - trace (D (n+1) \\<rho>) - (\\<Sum>k=0..<(n+1). trace (D0 k \\<rho>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k = 0..<n + 2. trace (P * D0 k \\<rho>)) +\n    trace (Q * D1 (n + 1) \\<rho>) +\n    (\\<Sum>k = 0..<n + 1. trace (D1 k \\<rho>) - trace (D (k + 1) \\<rho>))\n    \\<le> (\\<Sum>k = 0..<n + 2. trace (P * D0 k \\<rho>)) +\n          trace (Q * D1 (n + 1) \\<rho>) +\n          trace \\<rho> -\n          trace (D (n + 1) \\<rho>) -\n          (\\<Sum>k = 0..<n + 1. trace (D0 k \\<rho>))", "by (subst 14, auto)"], ["proof (state)\nthis:\n  (\\<Sum>k = 0..<n + 2. trace (P * D0 k \\<rho>)) +\n  trace (Q * D1 (n + 1) \\<rho>) +\n  (\\<Sum>k = 0..<n + 1. trace (D1 k \\<rho>) - trace (D (k + 1) \\<rho>))\n  \\<le> (\\<Sum>k = 0..<n + 2. trace (P * D0 k \\<rho>)) +\n        trace (Q * D1 (n + 1) \\<rho>) +\n        trace \\<rho> -\n        trace (D (n + 1) \\<rho>) -\n        (\\<Sum>k = 0..<n + 1. trace (D0 k \\<rho>))\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       trace (P * (M0 * \\<rho> * adjoint M0)) +\n       trace (Q * (M1 * \\<rho> * adjoint M1))\n       \\<le> trace (P * matrix_sum d (\\<lambda>k. D0 k \\<rho>) (n + 2)) +\n             trace \\<rho> -\n             trace (matrix_sum d (\\<lambda>k. D0 k \\<rho>) (n + 2))", "also"], ["proof (state)\nthis:\n  (\\<Sum>k = 0..<n + 2. trace (P * D0 k \\<rho>)) +\n  trace (Q * D1 (n + 1) \\<rho>) +\n  (\\<Sum>k = 0..<n + 1. trace (D1 k \\<rho>) - trace (D (k + 1) \\<rho>))\n  \\<le> (\\<Sum>k = 0..<n + 2. trace (P * D0 k \\<rho>)) +\n        trace (Q * D1 (n + 1) \\<rho>) +\n        trace \\<rho> -\n        trace (D (n + 1) \\<rho>) -\n        (\\<Sum>k = 0..<n + 1. trace (D0 k \\<rho>))\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       trace (P * (M0 * \\<rho> * adjoint M0)) +\n       trace (Q * (M1 * \\<rho> * adjoint M1))\n       \\<le> trace (P * matrix_sum d (\\<lambda>k. D0 k \\<rho>) (n + 2)) +\n             trace \\<rho> -\n             trace (matrix_sum d (\\<lambda>k. D0 k \\<rho>) (n + 2))", "have \n        \"\\<dots> \\<le> (\\<Sum>k=0..<(n+2). trace (P * (D0 k \\<rho>))) + trace (D (n+1) \\<rho>) - trace (D0 (n+1) \\<rho>)\n            + trace \\<rho> - trace (D (n+1) \\<rho>) - (\\<Sum>k=0..<(n+1). trace (D0 k \\<rho>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k = 0..<n + 2. trace (P * D0 k \\<rho>)) +\n    trace (Q * D1 (n + 1) \\<rho>) +\n    trace \\<rho> -\n    trace (D (n + 1) \\<rho>) -\n    (\\<Sum>k = 0..<n + 1. trace (D0 k \\<rho>))\n    \\<le> (\\<Sum>k = 0..<n + 2. trace (P * D0 k \\<rho>)) +\n          trace (D (n + 1) \\<rho>) -\n          trace (D0 (n + 1) \\<rho>) +\n          trace \\<rho> -\n          trace (D (n + 1) \\<rho>) -\n          (\\<Sum>k = 0..<n + 1. trace (D0 k \\<rho>))", "using 15[of \"n+1\"]"], ["proof (prove)\nusing this:\n  trace (Q * D1 (n + 1) \\<rho>)\n  \\<le> trace (D (n + 1) \\<rho>) - trace (D0 (n + 1) \\<rho>)\n\ngoal (1 subgoal):\n 1. (\\<Sum>k = 0..<n + 2. trace (P * D0 k \\<rho>)) +\n    trace (Q * D1 (n + 1) \\<rho>) +\n    trace \\<rho> -\n    trace (D (n + 1) \\<rho>) -\n    (\\<Sum>k = 0..<n + 1. trace (D0 k \\<rho>))\n    \\<le> (\\<Sum>k = 0..<n + 2. trace (P * D0 k \\<rho>)) +\n          trace (D (n + 1) \\<rho>) -\n          trace (D0 (n + 1) \\<rho>) +\n          trace \\<rho> -\n          trace (D (n + 1) \\<rho>) -\n          (\\<Sum>k = 0..<n + 1. trace (D0 k \\<rho>))", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>k = 0..<n + 2. trace (P * D0 k \\<rho>)) +\n  trace (Q * D1 (n + 1) \\<rho>) +\n  trace \\<rho> -\n  trace (D (n + 1) \\<rho>) -\n  (\\<Sum>k = 0..<n + 1. trace (D0 k \\<rho>))\n  \\<le> (\\<Sum>k = 0..<n + 2. trace (P * D0 k \\<rho>)) +\n        trace (D (n + 1) \\<rho>) -\n        trace (D0 (n + 1) \\<rho>) +\n        trace \\<rho> -\n        trace (D (n + 1) \\<rho>) -\n        (\\<Sum>k = 0..<n + 1. trace (D0 k \\<rho>))\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       trace (P * (M0 * \\<rho> * adjoint M0)) +\n       trace (Q * (M1 * \\<rho> * adjoint M1))\n       \\<le> trace (P * matrix_sum d (\\<lambda>k. D0 k \\<rho>) (n + 2)) +\n             trace \\<rho> -\n             trace (matrix_sum d (\\<lambda>k. D0 k \\<rho>) (n + 2))", "also"], ["proof (state)\nthis:\n  (\\<Sum>k = 0..<n + 2. trace (P * D0 k \\<rho>)) +\n  trace (Q * D1 (n + 1) \\<rho>) +\n  trace \\<rho> -\n  trace (D (n + 1) \\<rho>) -\n  (\\<Sum>k = 0..<n + 1. trace (D0 k \\<rho>))\n  \\<le> (\\<Sum>k = 0..<n + 2. trace (P * D0 k \\<rho>)) +\n        trace (D (n + 1) \\<rho>) -\n        trace (D0 (n + 1) \\<rho>) +\n        trace \\<rho> -\n        trace (D (n + 1) \\<rho>) -\n        (\\<Sum>k = 0..<n + 1. trace (D0 k \\<rho>))\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       trace (P * (M0 * \\<rho> * adjoint M0)) +\n       trace (Q * (M1 * \\<rho> * adjoint M1))\n       \\<le> trace (P * matrix_sum d (\\<lambda>k. D0 k \\<rho>) (n + 2)) +\n             trace \\<rho> -\n             trace (matrix_sum d (\\<lambda>k. D0 k \\<rho>) (n + 2))", "have \"\\<dots> = (\\<Sum>k=0..<(n+2). trace (P * (D0 k \\<rho>))) + trace \\<rho> - (\\<Sum>k=0..<(n+2). trace (D0 k \\<rho>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k = 0..<n + 2. trace (P * D0 k \\<rho>)) +\n    trace (D (n + 1) \\<rho>) -\n    trace (D0 (n + 1) \\<rho>) +\n    trace \\<rho> -\n    trace (D (n + 1) \\<rho>) -\n    (\\<Sum>k = 0..<n + 1. trace (D0 k \\<rho>)) =\n    (\\<Sum>k = 0..<n + 2. trace (P * D0 k \\<rho>)) + trace \\<rho> -\n    (\\<Sum>k = 0..<n + 2. trace (D0 k \\<rho>))", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>k = 0..<n + 2. trace (P * D0 k \\<rho>)) +\n  trace (D (n + 1) \\<rho>) -\n  trace (D0 (n + 1) \\<rho>) +\n  trace \\<rho> -\n  trace (D (n + 1) \\<rho>) -\n  (\\<Sum>k = 0..<n + 1. trace (D0 k \\<rho>)) =\n  (\\<Sum>k = 0..<n + 2. trace (P * D0 k \\<rho>)) + trace \\<rho> -\n  (\\<Sum>k = 0..<n + 2. trace (D0 k \\<rho>))\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       trace (P * (M0 * \\<rho> * adjoint M0)) +\n       trace (Q * (M1 * \\<rho> * adjoint M1))\n       \\<le> trace (P * matrix_sum d (\\<lambda>k. D0 k \\<rho>) (n + 2)) +\n             trace \\<rho> -\n             trace (matrix_sum d (\\<lambda>k. D0 k \\<rho>) (n + 2))", "also"], ["proof (state)\nthis:\n  (\\<Sum>k = 0..<n + 2. trace (P * D0 k \\<rho>)) +\n  trace (D (n + 1) \\<rho>) -\n  trace (D0 (n + 1) \\<rho>) +\n  trace \\<rho> -\n  trace (D (n + 1) \\<rho>) -\n  (\\<Sum>k = 0..<n + 1. trace (D0 k \\<rho>)) =\n  (\\<Sum>k = 0..<n + 2. trace (P * D0 k \\<rho>)) + trace \\<rho> -\n  (\\<Sum>k = 0..<n + 2. trace (D0 k \\<rho>))\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       trace (P * (M0 * \\<rho> * adjoint M0)) +\n       trace (Q * (M1 * \\<rho> * adjoint M1))\n       \\<le> trace (P * matrix_sum d (\\<lambda>k. D0 k \\<rho>) (n + 2)) +\n             trace \\<rho> -\n             trace (matrix_sum d (\\<lambda>k. D0 k \\<rho>) (n + 2))", "have \"\\<dots> = trace (matrix_sum d (\\<lambda>k. (P * (D0 k \\<rho>))) (n+2)) + trace \\<rho> - (\\<Sum>k=0..<(n+2). trace (D0 k \\<rho>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k = 0..<n + 2. trace (P * D0 k \\<rho>)) + trace \\<rho> -\n    (\\<Sum>k = 0..<n + 2. trace (D0 k \\<rho>)) =\n    trace (matrix_sum d (\\<lambda>k. P * D0 k \\<rho>) (n + 2)) +\n    trace \\<rho> -\n    (\\<Sum>k = 0..<n + 2. trace (D0 k \\<rho>))", "using trace_matrix_sum_linear[of \"n+2\" \"\\<lambda>k. (P * (D0 k \\<rho>))\" d, symmetric] dPD0kr"], ["proof (prove)\nusing this:\n  (\\<And>k.\n      k < n + 2 \\<Longrightarrow>\n      P * D0 k \\<rho> \\<in> carrier_mat d d) \\<Longrightarrow>\n  (\\<Sum>k = 0..<n + 2. trace (P * D0 k \\<rho>)) =\n  trace (matrix_sum d (\\<lambda>k. P * D0 k \\<rho>) (n + 2))\n  P * D0 ?k \\<rho> \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. (\\<Sum>k = 0..<n + 2. trace (P * D0 k \\<rho>)) + trace \\<rho> -\n    (\\<Sum>k = 0..<n + 2. trace (D0 k \\<rho>)) =\n    trace (matrix_sum d (\\<lambda>k. P * D0 k \\<rho>) (n + 2)) +\n    trace \\<rho> -\n    (\\<Sum>k = 0..<n + 2. trace (D0 k \\<rho>))", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>k = 0..<n + 2. trace (P * D0 k \\<rho>)) + trace \\<rho> -\n  (\\<Sum>k = 0..<n + 2. trace (D0 k \\<rho>)) =\n  trace (matrix_sum d (\\<lambda>k. P * D0 k \\<rho>) (n + 2)) +\n  trace \\<rho> -\n  (\\<Sum>k = 0..<n + 2. trace (D0 k \\<rho>))\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       trace (P * (M0 * \\<rho> * adjoint M0)) +\n       trace (Q * (M1 * \\<rho> * adjoint M1))\n       \\<le> trace (P * matrix_sum d (\\<lambda>k. D0 k \\<rho>) (n + 2)) +\n             trace \\<rho> -\n             trace (matrix_sum d (\\<lambda>k. D0 k \\<rho>) (n + 2))", "also"], ["proof (state)\nthis:\n  (\\<Sum>k = 0..<n + 2. trace (P * D0 k \\<rho>)) + trace \\<rho> -\n  (\\<Sum>k = 0..<n + 2. trace (D0 k \\<rho>)) =\n  trace (matrix_sum d (\\<lambda>k. P * D0 k \\<rho>) (n + 2)) +\n  trace \\<rho> -\n  (\\<Sum>k = 0..<n + 2. trace (D0 k \\<rho>))\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       trace (P * (M0 * \\<rho> * adjoint M0)) +\n       trace (Q * (M1 * \\<rho> * adjoint M1))\n       \\<le> trace (P * matrix_sum d (\\<lambda>k. D0 k \\<rho>) (n + 2)) +\n             trace \\<rho> -\n             trace (matrix_sum d (\\<lambda>k. D0 k \\<rho>) (n + 2))", "have \"\\<dots> = trace (matrix_sum d (\\<lambda>k. (P * (D0 k \\<rho>))) (n+2)) + trace \\<rho> - trace (matrix_sum d (\\<lambda>k. D0 k \\<rho>) (n+2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace (matrix_sum d (\\<lambda>k. P * D0 k \\<rho>) (n + 2)) +\n    trace \\<rho> -\n    (\\<Sum>k = 0..<n + 2. trace (D0 k \\<rho>)) =\n    trace (matrix_sum d (\\<lambda>k. P * D0 k \\<rho>) (n + 2)) +\n    trace \\<rho> -\n    trace (matrix_sum d (\\<lambda>k. D0 k \\<rho>) (n + 2))", "using trace_matrix_sum_linear[of \"n+2\" \"\\<lambda>k. D0 k \\<rho>\" d, symmetric] dD0kr"], ["proof (prove)\nusing this:\n  (\\<And>k.\n      k < n + 2 \\<Longrightarrow>\n      D0 k \\<rho> \\<in> carrier_mat d d) \\<Longrightarrow>\n  (\\<Sum>k = 0..<n + 2. trace (D0 k \\<rho>)) =\n  trace (matrix_sum d (\\<lambda>k. D0 k \\<rho>) (n + 2))\n  D0 ?k \\<rho> \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. trace (matrix_sum d (\\<lambda>k. P * D0 k \\<rho>) (n + 2)) +\n    trace \\<rho> -\n    (\\<Sum>k = 0..<n + 2. trace (D0 k \\<rho>)) =\n    trace (matrix_sum d (\\<lambda>k. P * D0 k \\<rho>) (n + 2)) +\n    trace \\<rho> -\n    trace (matrix_sum d (\\<lambda>k. D0 k \\<rho>) (n + 2))", "by auto"], ["proof (state)\nthis:\n  trace (matrix_sum d (\\<lambda>k. P * D0 k \\<rho>) (n + 2)) +\n  trace \\<rho> -\n  (\\<Sum>k = 0..<n + 2. trace (D0 k \\<rho>)) =\n  trace (matrix_sum d (\\<lambda>k. P * D0 k \\<rho>) (n + 2)) +\n  trace \\<rho> -\n  trace (matrix_sum d (\\<lambda>k. D0 k \\<rho>) (n + 2))\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       trace (P * (M0 * \\<rho> * adjoint M0)) +\n       trace (Q * (M1 * \\<rho> * adjoint M1))\n       \\<le> trace (P * matrix_sum d (\\<lambda>k. D0 k \\<rho>) (n + 2)) +\n             trace \\<rho> -\n             trace (matrix_sum d (\\<lambda>k. D0 k \\<rho>) (n + 2))", "also"], ["proof (state)\nthis:\n  trace (matrix_sum d (\\<lambda>k. P * D0 k \\<rho>) (n + 2)) +\n  trace \\<rho> -\n  (\\<Sum>k = 0..<n + 2. trace (D0 k \\<rho>)) =\n  trace (matrix_sum d (\\<lambda>k. P * D0 k \\<rho>) (n + 2)) +\n  trace \\<rho> -\n  trace (matrix_sum d (\\<lambda>k. D0 k \\<rho>) (n + 2))\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       trace (P * (M0 * \\<rho> * adjoint M0)) +\n       trace (Q * (M1 * \\<rho> * adjoint M1))\n       \\<le> trace (P * matrix_sum d (\\<lambda>k. D0 k \\<rho>) (n + 2)) +\n             trace \\<rho> -\n             trace (matrix_sum d (\\<lambda>k. D0 k \\<rho>) (n + 2))", "have \"\\<dots> = trace (P * (matrix_sum d (\\<lambda>k. D0 k \\<rho>) (n+2))) + trace \\<rho> - trace (matrix_sum d (\\<lambda>k. D0 k \\<rho>) (n+2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace (matrix_sum d (\\<lambda>k. P * D0 k \\<rho>) (n + 2)) +\n    trace \\<rho> -\n    trace (matrix_sum d (\\<lambda>k. D0 k \\<rho>) (n + 2)) =\n    trace (P * matrix_sum d (\\<lambda>k. D0 k \\<rho>) (n + 2)) +\n    trace \\<rho> -\n    trace (matrix_sum d (\\<lambda>k. D0 k \\<rho>) (n + 2))", "using matrix_sum_distrib_left[OF dP dD0kr, of id \"n+2\"]"], ["proof (prove)\nusing this:\n  matrix_sum d (\\<lambda>k. P * D0 (id k) \\<rho>) (n + 2) =\n  P * matrix_sum d (\\<lambda>k. D0 (id k) \\<rho>) (n + 2)\n\ngoal (1 subgoal):\n 1. trace (matrix_sum d (\\<lambda>k. P * D0 k \\<rho>) (n + 2)) +\n    trace \\<rho> -\n    trace (matrix_sum d (\\<lambda>k. D0 k \\<rho>) (n + 2)) =\n    trace (P * matrix_sum d (\\<lambda>k. D0 k \\<rho>) (n + 2)) +\n    trace \\<rho> -\n    trace (matrix_sum d (\\<lambda>k. D0 k \\<rho>) (n + 2))", "by auto"], ["proof (state)\nthis:\n  trace (matrix_sum d (\\<lambda>k. P * D0 k \\<rho>) (n + 2)) +\n  trace \\<rho> -\n  trace (matrix_sum d (\\<lambda>k. D0 k \\<rho>) (n + 2)) =\n  trace (P * matrix_sum d (\\<lambda>k. D0 k \\<rho>) (n + 2)) +\n  trace \\<rho> -\n  trace (matrix_sum d (\\<lambda>k. D0 k \\<rho>) (n + 2))\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       trace (P * (M0 * \\<rho> * adjoint M0)) +\n       trace (Q * (M1 * \\<rho> * adjoint M1))\n       \\<le> trace (P * matrix_sum d (\\<lambda>k. D0 k \\<rho>) (n + 2)) +\n             trace \\<rho> -\n             trace (matrix_sum d (\\<lambda>k. D0 k \\<rho>) (n + 2))", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>k = 0..<n + 2. trace (P * D0 k \\<rho>)) +\n  trace (Q * D1 (n + 1) \\<rho>) +\n  (\\<Sum>k = 0..<n + 1. trace (D1 k \\<rho>) - trace (D (k + 1) \\<rho>))\n  \\<le> trace (P * matrix_sum d (\\<lambda>k. D0 k \\<rho>) (n + 2)) +\n        trace \\<rho> -\n        trace (matrix_sum d (\\<lambda>k. D0 k \\<rho>) (n + 2))", "have \n        \"(\\<Sum>k=0..<(n+2). trace (P * (D0 k \\<rho>))) + trace (Q * (D1 (n+1) \\<rho>))\n         + (\\<Sum>k=0..<(n+1). trace (D1 k \\<rho>) - trace (D (k+1) \\<rho>))\n        \\<le> trace (P * (matrix_sum d (\\<lambda>k. D0 k \\<rho>) (n+2))) + trace \\<rho> - trace (matrix_sum d (\\<lambda>k. D0 k \\<rho>) (n+2))\""], ["proof (prove)\nusing this:\n  (\\<Sum>k = 0..<n + 2. trace (P * D0 k \\<rho>)) +\n  trace (Q * D1 (n + 1) \\<rho>) +\n  (\\<Sum>k = 0..<n + 1. trace (D1 k \\<rho>) - trace (D (k + 1) \\<rho>))\n  \\<le> trace (P * matrix_sum d (\\<lambda>k. D0 k \\<rho>) (n + 2)) +\n        trace \\<rho> -\n        trace (matrix_sum d (\\<lambda>k. D0 k \\<rho>) (n + 2))\n\ngoal (1 subgoal):\n 1. (\\<Sum>k = 0..<n + 2. trace (P * D0 k \\<rho>)) +\n    trace (Q * D1 (n + 1) \\<rho>) +\n    (\\<Sum>k = 0..<n + 1. trace (D1 k \\<rho>) - trace (D (k + 1) \\<rho>))\n    \\<le> trace (P * matrix_sum d (\\<lambda>k. D0 k \\<rho>) (n + 2)) +\n          trace \\<rho> -\n          trace (matrix_sum d (\\<lambda>k. D0 k \\<rho>) (n + 2))", "."], ["proof (state)\nthis:\n  (\\<Sum>k = 0..<n + 2. trace (P * D0 k \\<rho>)) +\n  trace (Q * D1 (n + 1) \\<rho>) +\n  (\\<Sum>k = 0..<n + 1. trace (D1 k \\<rho>) - trace (D (k + 1) \\<rho>))\n  \\<le> trace (P * matrix_sum d (\\<lambda>k. D0 k \\<rho>) (n + 2)) +\n        trace \\<rho> -\n        trace (matrix_sum d (\\<lambda>k. D0 k \\<rho>) (n + 2))\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       trace (P * (M0 * \\<rho> * adjoint M0)) +\n       trace (Q * (M1 * \\<rho> * adjoint M1))\n       \\<le> trace (P * matrix_sum d (\\<lambda>k. D0 k \\<rho>) (n + 2)) +\n             trace \\<rho> -\n             trace (matrix_sum d (\\<lambda>k. D0 k \\<rho>) (n + 2))", "then"], ["proof (chain)\npicking this:\n  (\\<Sum>k = 0..<n + 2. trace (P * D0 k \\<rho>)) +\n  trace (Q * D1 (n + 1) \\<rho>) +\n  (\\<Sum>k = 0..<n + 1. trace (D1 k \\<rho>) - trace (D (k + 1) \\<rho>))\n  \\<le> trace (P * matrix_sum d (\\<lambda>k. D0 k \\<rho>) (n + 2)) +\n        trace \\<rho> -\n        trace (matrix_sum d (\\<lambda>k. D0 k \\<rho>) (n + 2))", "show \"trace (P * (M0 * \\<rho> * adjoint M0)) + trace (Q * (M1 * \\<rho> * adjoint M1))\n          \\<le> trace (P * (matrix_sum d (\\<lambda>k. D0 k \\<rho>) (n+2))) + trace \\<rho> - trace (matrix_sum d (\\<lambda>k. D0 k \\<rho>) (n+2))\""], ["proof (prove)\nusing this:\n  (\\<Sum>k = 0..<n + 2. trace (P * D0 k \\<rho>)) +\n  trace (Q * D1 (n + 1) \\<rho>) +\n  (\\<Sum>k = 0..<n + 1. trace (D1 k \\<rho>) - trace (D (k + 1) \\<rho>))\n  \\<le> trace (P * matrix_sum d (\\<lambda>k. D0 k \\<rho>) (n + 2)) +\n        trace \\<rho> -\n        trace (matrix_sum d (\\<lambda>k. D0 k \\<rho>) (n + 2))\n\ngoal (1 subgoal):\n 1. trace (P * (M0 * \\<rho> * adjoint M0)) +\n    trace (Q * (M1 * \\<rho> * adjoint M1))\n    \\<le> trace (P * matrix_sum d (\\<lambda>k. D0 k \\<rho>) (n + 2)) +\n          trace \\<rho> -\n          trace (matrix_sum d (\\<lambda>k. D0 k \\<rho>) (n + 2))", "using 12[of n]"], ["proof (prove)\nusing this:\n  (\\<Sum>k = 0..<n + 2. trace (P * D0 k \\<rho>)) +\n  trace (Q * D1 (n + 1) \\<rho>) +\n  (\\<Sum>k = 0..<n + 1. trace (D1 k \\<rho>) - trace (D (k + 1) \\<rho>))\n  \\<le> trace (P * matrix_sum d (\\<lambda>k. D0 k \\<rho>) (n + 2)) +\n        trace \\<rho> -\n        trace (matrix_sum d (\\<lambda>k. D0 k \\<rho>) (n + 2))\n  trace (P * (M0 * \\<rho> * adjoint M0)) +\n  trace (Q * (M1 * \\<rho> * adjoint M1))\n  \\<le> (\\<Sum>k = 0..<n + 2. trace (P * D0 k \\<rho>)) +\n        trace (Q * D1 (n + 1) \\<rho>) +\n        (\\<Sum>k = 0..<n + 1.\n            trace (D1 k \\<rho>) - trace (D (k + 1) \\<rho>))\n\ngoal (1 subgoal):\n 1. trace (P * (M0 * \\<rho> * adjoint M0)) +\n    trace (Q * (M1 * \\<rho> * adjoint M1))\n    \\<le> trace (P * matrix_sum d (\\<lambda>k. D0 k \\<rho>) (n + 2)) +\n          trace \\<rho> -\n          trace (matrix_sum d (\\<lambda>k. D0 k \\<rho>) (n + 2))", "by auto"], ["proof (state)\nthis:\n  trace (P * (M0 * \\<rho> * adjoint M0)) +\n  trace (Q * (M1 * \\<rho> * adjoint M1))\n  \\<le> trace (P * matrix_sum d (\\<lambda>k. D0 k \\<rho>) (n + 2)) +\n        trace \\<rho> -\n        trace (matrix_sum d (\\<lambda>k. D0 k \\<rho>) (n + 2))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  trace (P * (M0 * \\<rho> * adjoint M0)) +\n  trace (Q * (M1 * \\<rho> * adjoint M1))\n  \\<le> trace (P * matrix_sum d (\\<lambda>k. D0 k \\<rho>) (?n + 2)) +\n        trace \\<rho> -\n        trace (matrix_sum d (\\<lambda>k. D0 k \\<rho>) (?n + 2))\n\ngoal (2 subgoals):\n 1. \\<And>P Q S M.\n       \\<lbrakk>is_quantum_predicate P; is_quantum_predicate Q;\n        \\<turnstile>\\<^sub>p {Q} S\n                             {adjoint (M 0) * P * M 0 +\n                              adjoint (M 1) * Q * M 1};\n        well_com S \\<Longrightarrow>\n        \\<Turnstile>\\<^sub>p {Q} S\n        {adjoint (M 0) * P * M 0 + adjoint (M 1) * Q * M 1};\n        well_com (While M S)\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {adjoint (M 0) * P * M 0 +\n         adjoint (M 1) * Q * M 1}\n                         While M S {P}\n 2. \\<And>P Q P' Q' S.\n       \\<lbrakk>is_quantum_predicate P; is_quantum_predicate Q;\n        is_quantum_predicate P'; is_quantum_predicate Q';\n        P \\<le>\\<^sub>L P'; \\<turnstile>\\<^sub>p {P'} S {Q'};\n        well_com S \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P'} S {Q'};\n        Q' \\<le>\\<^sub>L Q; well_com S\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P} S {Q}", "have \"limit_mat (\\<lambda>n. matrix_sum d (\\<lambda>k. D0 k \\<rho>) (n)) (denote (While M S) \\<rho>) d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. limit_mat (matrix_sum d (\\<lambda>k. D0 k \\<rho>))\n     (denote (While M S) \\<rho>) d", "using limit_mat_denote_while_n[OF wc dr pdor]"], ["proof (prove)\nusing this:\n  limit_mat\n   (matrix_sum d\n     (\\<lambda>k. denote_while_n (M 0) (M 1) (denote S) k \\<rho>))\n   (denote (While M S) \\<rho>) d\n\ngoal (1 subgoal):\n 1. limit_mat (matrix_sum d (\\<lambda>k. D0 k \\<rho>))\n     (denote (While M S) \\<rho>) d", "unfolding D0_def M0_def M1_def DS_def"], ["proof (prove)\nusing this:\n  limit_mat\n   (matrix_sum d\n     (\\<lambda>k. denote_while_n (M 0) (M 1) (denote S) k \\<rho>))\n   (denote (While M S) \\<rho>) d\n\ngoal (1 subgoal):\n 1. limit_mat\n     (matrix_sum d\n       (\\<lambda>k. denote_while_n (M 0) (M 1) (denote S) k \\<rho>))\n     (denote (While M S) \\<rho>) d", "by auto"], ["proof (state)\nthis:\n  limit_mat (matrix_sum d (\\<lambda>k. D0 k \\<rho>))\n   (denote (While M S) \\<rho>) d\n\ngoal (2 subgoals):\n 1. \\<And>P Q S M.\n       \\<lbrakk>is_quantum_predicate P; is_quantum_predicate Q;\n        \\<turnstile>\\<^sub>p {Q} S\n                             {adjoint (M 0) * P * M 0 +\n                              adjoint (M 1) * Q * M 1};\n        well_com S \\<Longrightarrow>\n        \\<Turnstile>\\<^sub>p {Q} S\n        {adjoint (M 0) * P * M 0 + adjoint (M 1) * Q * M 1};\n        well_com (While M S)\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {adjoint (M 0) * P * M 0 +\n         adjoint (M 1) * Q * M 1}\n                         While M S {P}\n 2. \\<And>P Q P' Q' S.\n       \\<lbrakk>is_quantum_predicate P; is_quantum_predicate Q;\n        is_quantum_predicate P'; is_quantum_predicate Q';\n        P \\<le>\\<^sub>L P'; \\<turnstile>\\<^sub>p {P'} S {Q'};\n        well_com S \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P'} S {Q'};\n        Q' \\<le>\\<^sub>L Q; well_com S\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P} S {Q}", "then"], ["proof (chain)\npicking this:\n  limit_mat (matrix_sum d (\\<lambda>k. D0 k \\<rho>))\n   (denote (While M S) \\<rho>) d", "have limp2: \"limit_mat (\\<lambda>n. matrix_sum d (\\<lambda>k. D0 k \\<rho>) (n + 2)) (denote (While M S) \\<rho>) d\""], ["proof (prove)\nusing this:\n  limit_mat (matrix_sum d (\\<lambda>k. D0 k \\<rho>))\n   (denote (While M S) \\<rho>) d\n\ngoal (1 subgoal):\n 1. limit_mat (\\<lambda>n. matrix_sum d (\\<lambda>k. D0 k \\<rho>) (n + 2))\n     (denote (While M S) \\<rho>) d", "using limit_mat_ignore_initial_segment[of \"\\<lambda>n. matrix_sum d (\\<lambda>k. D0 k \\<rho>) (n)\" \"(denote (While M S) \\<rho>)\" d 2]"], ["proof (prove)\nusing this:\n  limit_mat (matrix_sum d (\\<lambda>k. D0 k \\<rho>))\n   (denote (While M S) \\<rho>) d\n  limit_mat (matrix_sum d (\\<lambda>k. D0 k \\<rho>))\n   (denote (While M S) \\<rho>) d \\<Longrightarrow>\n  limit_mat (\\<lambda>n. matrix_sum d (\\<lambda>k. D0 k \\<rho>) (n + 2))\n   (denote (While M S) \\<rho>) d\n\ngoal (1 subgoal):\n 1. limit_mat (\\<lambda>n. matrix_sum d (\\<lambda>k. D0 k \\<rho>) (n + 2))\n     (denote (While M S) \\<rho>) d", "by auto"], ["proof (state)\nthis:\n  limit_mat (\\<lambda>n. matrix_sum d (\\<lambda>k. D0 k \\<rho>) (n + 2))\n   (denote (While M S) \\<rho>) d\n\ngoal (2 subgoals):\n 1. \\<And>P Q S M.\n       \\<lbrakk>is_quantum_predicate P; is_quantum_predicate Q;\n        \\<turnstile>\\<^sub>p {Q} S\n                             {adjoint (M 0) * P * M 0 +\n                              adjoint (M 1) * Q * M 1};\n        well_com S \\<Longrightarrow>\n        \\<Turnstile>\\<^sub>p {Q} S\n        {adjoint (M 0) * P * M 0 + adjoint (M 1) * Q * M 1};\n        well_com (While M S)\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {adjoint (M 0) * P * M 0 +\n         adjoint (M 1) * Q * M 1}\n                         While M S {P}\n 2. \\<And>P Q P' Q' S.\n       \\<lbrakk>is_quantum_predicate P; is_quantum_predicate Q;\n        is_quantum_predicate P'; is_quantum_predicate Q';\n        P \\<le>\\<^sub>L P'; \\<turnstile>\\<^sub>p {P'} S {Q'};\n        well_com S \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P'} S {Q'};\n        Q' \\<le>\\<^sub>L Q; well_com S\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P} S {Q}", "then"], ["proof (chain)\npicking this:\n  limit_mat (\\<lambda>n. matrix_sum d (\\<lambda>k. D0 k \\<rho>) (n + 2))\n   (denote (While M S) \\<rho>) d", "have \"limit_mat (\\<lambda>n. (P * (matrix_sum d (\\<lambda>k. D0 k \\<rho>) (n+2)))) (P * (denote (While M S) \\<rho>)) d\""], ["proof (prove)\nusing this:\n  limit_mat (\\<lambda>n. matrix_sum d (\\<lambda>k. D0 k \\<rho>) (n + 2))\n   (denote (While M S) \\<rho>) d\n\ngoal (1 subgoal):\n 1. limit_mat\n     (\\<lambda>n. P * matrix_sum d (\\<lambda>k. D0 k \\<rho>) (n + 2))\n     (P * denote (While M S) \\<rho>) d", "using mat_mult_limit[OF dP]"], ["proof (prove)\nusing this:\n  limit_mat (\\<lambda>n. matrix_sum d (\\<lambda>k. D0 k \\<rho>) (n + 2))\n   (denote (While M S) \\<rho>) d\n  limit_mat ?X ?A d \\<Longrightarrow>\n  limit_mat (mat_mult_seq P ?X) (P * ?A) d\n\ngoal (1 subgoal):\n 1. limit_mat\n     (\\<lambda>n. P * matrix_sum d (\\<lambda>k. D0 k \\<rho>) (n + 2))\n     (P * denote (While M S) \\<rho>) d", "unfolding mat_mult_seq_def"], ["proof (prove)\nusing this:\n  limit_mat (\\<lambda>n. matrix_sum d (\\<lambda>k. D0 k \\<rho>) (n + 2))\n   (denote (While M S) \\<rho>) d\n  limit_mat ?X ?A d \\<Longrightarrow>\n  limit_mat (\\<lambda>n. P * ?X n) (P * ?A) d\n\ngoal (1 subgoal):\n 1. limit_mat\n     (\\<lambda>n. P * matrix_sum d (\\<lambda>k. D0 k \\<rho>) (n + 2))\n     (P * denote (While M S) \\<rho>) d", "by auto"], ["proof (state)\nthis:\n  limit_mat (\\<lambda>n. P * matrix_sum d (\\<lambda>k. D0 k \\<rho>) (n + 2))\n   (P * denote (While M S) \\<rho>) d\n\ngoal (2 subgoals):\n 1. \\<And>P Q S M.\n       \\<lbrakk>is_quantum_predicate P; is_quantum_predicate Q;\n        \\<turnstile>\\<^sub>p {Q} S\n                             {adjoint (M 0) * P * M 0 +\n                              adjoint (M 1) * Q * M 1};\n        well_com S \\<Longrightarrow>\n        \\<Turnstile>\\<^sub>p {Q} S\n        {adjoint (M 0) * P * M 0 + adjoint (M 1) * Q * M 1};\n        well_com (While M S)\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {adjoint (M 0) * P * M 0 +\n         adjoint (M 1) * Q * M 1}\n                         While M S {P}\n 2. \\<And>P Q P' Q' S.\n       \\<lbrakk>is_quantum_predicate P; is_quantum_predicate Q;\n        is_quantum_predicate P'; is_quantum_predicate Q';\n        P \\<le>\\<^sub>L P'; \\<turnstile>\\<^sub>p {P'} S {Q'};\n        well_com S \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P'} S {Q'};\n        Q' \\<le>\\<^sub>L Q; well_com S\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P} S {Q}", "then"], ["proof (chain)\npicking this:\n  limit_mat (\\<lambda>n. P * matrix_sum d (\\<lambda>k. D0 k \\<rho>) (n + 2))\n   (P * denote (While M S) \\<rho>) d", "have limPm: \"(\\<lambda>n. trace (P * (matrix_sum d (\\<lambda>k. D0 k \\<rho>) (n+2)))) \\<longlonglongrightarrow> trace (P * (denote (While M S) \\<rho>))\""], ["proof (prove)\nusing this:\n  limit_mat (\\<lambda>n. P * matrix_sum d (\\<lambda>k. D0 k \\<rho>) (n + 2))\n   (P * denote (While M S) \\<rho>) d\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. trace (P * matrix_sum d (\\<lambda>k. D0 k \\<rho>) (n + 2)))\n    \\<longlonglongrightarrow> trace (P * denote (While M S) \\<rho>)", "using mat_trace_limit"], ["proof (prove)\nusing this:\n  limit_mat (\\<lambda>n. P * matrix_sum d (\\<lambda>k. D0 k \\<rho>) (n + 2))\n   (P * denote (While M S) \\<rho>) d\n  limit_mat ?g ?A ?d \\<Longrightarrow>\n  (\\<lambda>n. trace (?g n)) \\<longlonglongrightarrow> trace ?A\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. trace (P * matrix_sum d (\\<lambda>k. D0 k \\<rho>) (n + 2)))\n    \\<longlonglongrightarrow> trace (P * denote (While M S) \\<rho>)", "by auto"], ["proof (state)\nthis:\n  (\\<lambda>n. trace (P * matrix_sum d (\\<lambda>k. D0 k \\<rho>) (n + 2)))\n  \\<longlonglongrightarrow> trace (P * denote (While M S) \\<rho>)\n\ngoal (2 subgoals):\n 1. \\<And>P Q S M.\n       \\<lbrakk>is_quantum_predicate P; is_quantum_predicate Q;\n        \\<turnstile>\\<^sub>p {Q} S\n                             {adjoint (M 0) * P * M 0 +\n                              adjoint (M 1) * Q * M 1};\n        well_com S \\<Longrightarrow>\n        \\<Turnstile>\\<^sub>p {Q} S\n        {adjoint (M 0) * P * M 0 + adjoint (M 1) * Q * M 1};\n        well_com (While M S)\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {adjoint (M 0) * P * M 0 +\n         adjoint (M 1) * Q * M 1}\n                         While M S {P}\n 2. \\<And>P Q P' Q' S.\n       \\<lbrakk>is_quantum_predicate P; is_quantum_predicate Q;\n        is_quantum_predicate P'; is_quantum_predicate Q';\n        P \\<le>\\<^sub>L P'; \\<turnstile>\\<^sub>p {P'} S {Q'};\n        well_com S \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P'} S {Q'};\n        Q' \\<le>\\<^sub>L Q; well_com S\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P} S {Q}", "have limm: \"(\\<lambda>n. trace (matrix_sum d (\\<lambda>k. D0 k \\<rho>) (n+2))) \\<longlonglongrightarrow> trace (denote (While M S) \\<rho>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n. trace (matrix_sum d (\\<lambda>k. D0 k \\<rho>) (n + 2)))\n    \\<longlonglongrightarrow> trace (denote (While M S) \\<rho>)", "using mat_trace_limit limp2"], ["proof (prove)\nusing this:\n  limit_mat ?g ?A ?d \\<Longrightarrow>\n  (\\<lambda>n. trace (?g n)) \\<longlonglongrightarrow> trace ?A\n  limit_mat (\\<lambda>n. matrix_sum d (\\<lambda>k. D0 k \\<rho>) (n + 2))\n   (denote (While M S) \\<rho>) d\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. trace (matrix_sum d (\\<lambda>k. D0 k \\<rho>) (n + 2)))\n    \\<longlonglongrightarrow> trace (denote (While M S) \\<rho>)", "by auto"], ["proof (state)\nthis:\n  (\\<lambda>n. trace (matrix_sum d (\\<lambda>k. D0 k \\<rho>) (n + 2)))\n  \\<longlonglongrightarrow> trace (denote (While M S) \\<rho>)\n\ngoal (2 subgoals):\n 1. \\<And>P Q S M.\n       \\<lbrakk>is_quantum_predicate P; is_quantum_predicate Q;\n        \\<turnstile>\\<^sub>p {Q} S\n                             {adjoint (M 0) * P * M 0 +\n                              adjoint (M 1) * Q * M 1};\n        well_com S \\<Longrightarrow>\n        \\<Turnstile>\\<^sub>p {Q} S\n        {adjoint (M 0) * P * M 0 + adjoint (M 1) * Q * M 1};\n        well_com (While M S)\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {adjoint (M 0) * P * M 0 +\n         adjoint (M 1) * Q * M 1}\n                         While M S {P}\n 2. \\<And>P Q P' Q' S.\n       \\<lbrakk>is_quantum_predicate P; is_quantum_predicate Q;\n        is_quantum_predicate P'; is_quantum_predicate Q';\n        P \\<le>\\<^sub>L P'; \\<turnstile>\\<^sub>p {P'} S {Q'};\n        well_com S \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P'} S {Q'};\n        Q' \\<le>\\<^sub>L Q; well_com S\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P} S {Q}", "have leq_lim: \"trace (P * (M0 * \\<rho> * adjoint M0)) + trace (Q * (M1 * \\<rho> * adjoint M1)) \n      \\<le> trace (P * (denote (While M S) \\<rho>)) + trace \\<rho> - trace (denote (While M S) \\<rho>)\" (is \"?lhs \\<le> ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. trace (P * (M0 * \\<rho> * adjoint M0)) +\n    trace (Q * (M1 * \\<rho> * adjoint M1))\n    \\<le> trace (P * denote (While M S) \\<rho>) + trace \\<rho> -\n          trace (denote (While M S) \\<rho>)", "using main_leq"], ["proof (prove)\nusing this:\n  trace (P * (M0 * \\<rho> * adjoint M0)) +\n  trace (Q * (M1 * \\<rho> * adjoint M1))\n  \\<le> trace (P * matrix_sum d (\\<lambda>k. D0 k \\<rho>) (?n + 2)) +\n        trace \\<rho> -\n        trace (matrix_sum d (\\<lambda>k. D0 k \\<rho>) (?n + 2))\n\ngoal (1 subgoal):\n 1. trace (P * (M0 * \\<rho> * adjoint M0)) +\n    trace (Q * (M1 * \\<rho> * adjoint M1))\n    \\<le> trace (P * denote (While M S) \\<rho>) + trace \\<rho> -\n          trace (denote (While M S) \\<rho>)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>n.\n        trace (P * (M0 * \\<rho> * adjoint M0)) +\n        trace (Q * (M1 * \\<rho> * adjoint M1))\n        \\<le> trace (P * matrix_sum d (\\<lambda>k. D0 k \\<rho>) (n + 2)) +\n              trace \\<rho> -\n              trace\n               (matrix_sum d (\\<lambda>k. D0 k \\<rho>)\n                 (n + 2))) \\<Longrightarrow>\n    trace (P * (M0 * \\<rho> * adjoint M0)) +\n    trace (Q * (M1 * \\<rho> * adjoint M1))\n    \\<le> trace (P * denote (While M S) \\<rho>) + trace \\<rho> -\n          trace (denote (While M S) \\<rho>)", "define seq where \"seq n = trace (P * matrix_sum d (\\<lambda>k. D0 k \\<rho>) (n + 2)) - trace (matrix_sum d (\\<lambda>k. D0 k \\<rho>) (n + 2)) \" for n"], ["proof (state)\nthis:\n  seq ?n =\n  trace (P * matrix_sum d (\\<lambda>k. D0 k \\<rho>) (?n + 2)) -\n  trace (matrix_sum d (\\<lambda>k. D0 k \\<rho>) (?n + 2))\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        trace (P * (M0 * \\<rho> * adjoint M0)) +\n        trace (Q * (M1 * \\<rho> * adjoint M1))\n        \\<le> trace (P * matrix_sum d (\\<lambda>k. D0 k \\<rho>) (n + 2)) +\n              trace \\<rho> -\n              trace\n               (matrix_sum d (\\<lambda>k. D0 k \\<rho>)\n                 (n + 2))) \\<Longrightarrow>\n    trace (P * (M0 * \\<rho> * adjoint M0)) +\n    trace (Q * (M1 * \\<rho> * adjoint M1))\n    \\<le> trace (P * denote (While M S) \\<rho>) + trace \\<rho> -\n          trace (denote (While M S) \\<rho>)", "define seqlim where \"seqlim = trace (P * (denote (While M S) \\<rho>)) - trace (denote (While M S) \\<rho>)\""], ["proof (state)\nthis:\n  seqlim =\n  trace (P * denote (While M S) \\<rho>) - trace (denote (While M S) \\<rho>)\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        trace (P * (M0 * \\<rho> * adjoint M0)) +\n        trace (Q * (M1 * \\<rho> * adjoint M1))\n        \\<le> trace (P * matrix_sum d (\\<lambda>k. D0 k \\<rho>) (n + 2)) +\n              trace \\<rho> -\n              trace\n               (matrix_sum d (\\<lambda>k. D0 k \\<rho>)\n                 (n + 2))) \\<Longrightarrow>\n    trace (P * (M0 * \\<rho> * adjoint M0)) +\n    trace (Q * (M1 * \\<rho> * adjoint M1))\n    \\<le> trace (P * denote (While M S) \\<rho>) + trace \\<rho> -\n          trace (denote (While M S) \\<rho>)", "have main_leq': \"?lhs \\<le> trace \\<rho> + seq n\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. trace (P * (M0 * \\<rho> * adjoint M0)) +\n    trace (Q * (M1 * \\<rho> * adjoint M1))\n    \\<le> trace \\<rho> + seq n", "unfolding seq_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. trace (P * (M0 * \\<rho> * adjoint M0)) +\n    trace (Q * (M1 * \\<rho> * adjoint M1))\n    \\<le> trace \\<rho> +\n          (trace (P * matrix_sum d (\\<lambda>k. D0 k \\<rho>) (n + 2)) -\n           trace (matrix_sum d (\\<lambda>k. D0 k \\<rho>) (n + 2)))", "using main_leq"], ["proof (prove)\nusing this:\n  trace (P * (M0 * \\<rho> * adjoint M0)) +\n  trace (Q * (M1 * \\<rho> * adjoint M1))\n  \\<le> trace (P * matrix_sum d (\\<lambda>k. D0 k \\<rho>) (?n + 2)) +\n        trace \\<rho> -\n        trace (matrix_sum d (\\<lambda>k. D0 k \\<rho>) (?n + 2))\n\ngoal (1 subgoal):\n 1. trace (P * (M0 * \\<rho> * adjoint M0)) +\n    trace (Q * (M1 * \\<rho> * adjoint M1))\n    \\<le> trace \\<rho> +\n          (trace (P * matrix_sum d (\\<lambda>k. D0 k \\<rho>) (n + 2)) -\n           trace (matrix_sum d (\\<lambda>k. D0 k \\<rho>) (n + 2)))", "by (simp add: algebra_simps)"], ["proof (state)\nthis:\n  trace (P * (M0 * \\<rho> * adjoint M0)) +\n  trace (Q * (M1 * \\<rho> * adjoint M1))\n  \\<le> trace \\<rho> + seq ?n\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        trace (P * (M0 * \\<rho> * adjoint M0)) +\n        trace (Q * (M1 * \\<rho> * adjoint M1))\n        \\<le> trace (P * matrix_sum d (\\<lambda>k. D0 k \\<rho>) (n + 2)) +\n              trace \\<rho> -\n              trace\n               (matrix_sum d (\\<lambda>k. D0 k \\<rho>)\n                 (n + 2))) \\<Longrightarrow>\n    trace (P * (M0 * \\<rho> * adjoint M0)) +\n    trace (Q * (M1 * \\<rho> * adjoint M1))\n    \\<le> trace (P * denote (While M S) \\<rho>) + trace \\<rho> -\n          trace (denote (While M S) \\<rho>)", "have limseq: \"seq \\<longlonglongrightarrow> seqlim\""], ["proof (prove)\ngoal (1 subgoal):\n 1. seq \\<longlonglongrightarrow> seqlim", "unfolding seq_def seqlim_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n.\n        trace (P * matrix_sum d (\\<lambda>k. D0 k \\<rho>) (n + 2)) -\n        trace (matrix_sum d (\\<lambda>k. D0 k \\<rho>) (n + 2)))\n    \\<longlonglongrightarrow> trace (P * denote (While M S) \\<rho>) -\n                              trace (denote (While M S) \\<rho>)", "using tendsto_diff[OF limPm limm]"], ["proof (prove)\nusing this:\n  (\\<lambda>x.\n      trace (P * matrix_sum d (\\<lambda>k. D0 k \\<rho>) (x + 2)) -\n      trace (matrix_sum d (\\<lambda>k. D0 k \\<rho>) (x + 2)))\n  \\<longlonglongrightarrow> trace (P * denote (While M S) \\<rho>) -\n                            trace (denote (While M S) \\<rho>)\n\ngoal (1 subgoal):\n 1. (\\<lambda>n.\n        trace (P * matrix_sum d (\\<lambda>k. D0 k \\<rho>) (n + 2)) -\n        trace (matrix_sum d (\\<lambda>k. D0 k \\<rho>) (n + 2)))\n    \\<longlonglongrightarrow> trace (P * denote (While M S) \\<rho>) -\n                              trace (denote (While M S) \\<rho>)", "by auto"], ["proof (state)\nthis:\n  seq \\<longlonglongrightarrow> seqlim\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        trace (P * (M0 * \\<rho> * adjoint M0)) +\n        trace (Q * (M1 * \\<rho> * adjoint M1))\n        \\<le> trace (P * matrix_sum d (\\<lambda>k. D0 k \\<rho>) (n + 2)) +\n              trace \\<rho> -\n              trace\n               (matrix_sum d (\\<lambda>k. D0 k \\<rho>)\n                 (n + 2))) \\<Longrightarrow>\n    trace (P * (M0 * \\<rho> * adjoint M0)) +\n    trace (Q * (M1 * \\<rho> * adjoint M1))\n    \\<le> trace (P * denote (While M S) \\<rho>) + trace \\<rho> -\n          trace (denote (While M S) \\<rho>)", "have limrs: \"(\\<lambda>n. trace \\<rho> + seq n) \\<longlonglongrightarrow> (trace \\<rho> + seqlim)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n. trace \\<rho> + seq n)\n    \\<longlonglongrightarrow> trace \\<rho> + seqlim", "using tendsto_add[OF _ limseq]"], ["proof (prove)\nusing this:\n  ?f \\<longlonglongrightarrow> ?a \\<Longrightarrow>\n  (\\<lambda>x. ?f x + seq x) \\<longlonglongrightarrow> ?a + seqlim\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. trace \\<rho> + seq n)\n    \\<longlonglongrightarrow> trace \\<rho> + seqlim", "by auto"], ["proof (state)\nthis:\n  (\\<lambda>n. trace \\<rho> + seq n)\n  \\<longlonglongrightarrow> trace \\<rho> + seqlim\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        trace (P * (M0 * \\<rho> * adjoint M0)) +\n        trace (Q * (M1 * \\<rho> * adjoint M1))\n        \\<le> trace (P * matrix_sum d (\\<lambda>k. D0 k \\<rho>) (n + 2)) +\n              trace \\<rho> -\n              trace\n               (matrix_sum d (\\<lambda>k. D0 k \\<rho>)\n                 (n + 2))) \\<Longrightarrow>\n    trace (P * (M0 * \\<rho> * adjoint M0)) +\n    trace (Q * (M1 * \\<rho> * adjoint M1))\n    \\<le> trace (P * denote (While M S) \\<rho>) + trace \\<rho> -\n          trace (denote (While M S) \\<rho>)", "have limrsRe: \"(\\<lambda>n. Re (trace \\<rho> + seq n)) \\<longlonglongrightarrow> Re (trace \\<rho> + seqlim)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n. Re (trace \\<rho> + seq n))\n    \\<longlonglongrightarrow> Re (trace \\<rho> + seqlim)", "using tendsto_Re[OF limrs]"], ["proof (prove)\nusing this:\n  (\\<lambda>x. Re (trace \\<rho> + seq x))\n  \\<longlonglongrightarrow> Re (trace \\<rho> + seqlim)\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. Re (trace \\<rho> + seq n))\n    \\<longlonglongrightarrow> Re (trace \\<rho> + seqlim)", "by auto"], ["proof (state)\nthis:\n  (\\<lambda>n. Re (trace \\<rho> + seq n))\n  \\<longlonglongrightarrow> Re (trace \\<rho> + seqlim)\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        trace (P * (M0 * \\<rho> * adjoint M0)) +\n        trace (Q * (M1 * \\<rho> * adjoint M1))\n        \\<le> trace (P * matrix_sum d (\\<lambda>k. D0 k \\<rho>) (n + 2)) +\n              trace \\<rho> -\n              trace\n               (matrix_sum d (\\<lambda>k. D0 k \\<rho>)\n                 (n + 2))) \\<Longrightarrow>\n    trace (P * (M0 * \\<rho> * adjoint M0)) +\n    trace (Q * (M1 * \\<rho> * adjoint M1))\n    \\<le> trace (P * denote (While M S) \\<rho>) + trace \\<rho> -\n          trace (denote (While M S) \\<rho>)", "have main_leq_Re: \"Re ?lhs \\<le> Re (trace \\<rho> + seq n)\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. Re (trace (P * (M0 * \\<rho> * adjoint M0)) +\n        trace (Q * (M1 * \\<rho> * adjoint M1)))\n    \\<le> Re (trace \\<rho> + seq n)", "using main_leq'"], ["proof (prove)\nusing this:\n  trace (P * (M0 * \\<rho> * adjoint M0)) +\n  trace (Q * (M1 * \\<rho> * adjoint M1))\n  \\<le> trace \\<rho> + seq ?n\n\ngoal (1 subgoal):\n 1. Re (trace (P * (M0 * \\<rho> * adjoint M0)) +\n        trace (Q * (M1 * \\<rho> * adjoint M1)))\n    \\<le> Re (trace \\<rho> + seq n)", "by auto"], ["proof (state)\nthis:\n  Re (trace (P * (M0 * \\<rho> * adjoint M0)) +\n      trace (Q * (M1 * \\<rho> * adjoint M1)))\n  \\<le> Re (trace \\<rho> + seq ?n)\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        trace (P * (M0 * \\<rho> * adjoint M0)) +\n        trace (Q * (M1 * \\<rho> * adjoint M1))\n        \\<le> trace (P * matrix_sum d (\\<lambda>k. D0 k \\<rho>) (n + 2)) +\n              trace \\<rho> -\n              trace\n               (matrix_sum d (\\<lambda>k. D0 k \\<rho>)\n                 (n + 2))) \\<Longrightarrow>\n    trace (P * (M0 * \\<rho> * adjoint M0)) +\n    trace (Q * (M1 * \\<rho> * adjoint M1))\n    \\<le> trace (P * denote (While M S) \\<rho>) + trace \\<rho> -\n          trace (denote (While M S) \\<rho>)", "have Re: \"Re ?lhs \\<le> Re (trace \\<rho> + seqlim)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Re (trace (P * (M0 * \\<rho> * adjoint M0)) +\n        trace (Q * (M1 * \\<rho> * adjoint M1)))\n    \\<le> Re (trace \\<rho> + seqlim)", "using Lim_bounded2[OF limrsRe ]  main_leq_Re"], ["proof (prove)\nusing this:\n  \\<forall>n\\<ge>?N. ?C \\<le> Re (trace \\<rho> + seq n) \\<Longrightarrow>\n  ?C \\<le> Re (trace \\<rho> + seqlim)\n  Re (trace (P * (M0 * \\<rho> * adjoint M0)) +\n      trace (Q * (M1 * \\<rho> * adjoint M1)))\n  \\<le> Re (trace \\<rho> + seq ?n)\n\ngoal (1 subgoal):\n 1. Re (trace (P * (M0 * \\<rho> * adjoint M0)) +\n        trace (Q * (M1 * \\<rho> * adjoint M1)))\n    \\<le> Re (trace \\<rho> + seqlim)", "by auto"], ["proof (state)\nthis:\n  Re (trace (P * (M0 * \\<rho> * adjoint M0)) +\n      trace (Q * (M1 * \\<rho> * adjoint M1)))\n  \\<le> Re (trace \\<rho> + seqlim)\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        trace (P * (M0 * \\<rho> * adjoint M0)) +\n        trace (Q * (M1 * \\<rho> * adjoint M1))\n        \\<le> trace (P * matrix_sum d (\\<lambda>k. D0 k \\<rho>) (n + 2)) +\n              trace \\<rho> -\n              trace\n               (matrix_sum d (\\<lambda>k. D0 k \\<rho>)\n                 (n + 2))) \\<Longrightarrow>\n    trace (P * (M0 * \\<rho> * adjoint M0)) +\n    trace (Q * (M1 * \\<rho> * adjoint M1))\n    \\<le> trace (P * denote (While M S) \\<rho>) + trace \\<rho> -\n          trace (denote (While M S) \\<rho>)", "have limrsIm: \"(\\<lambda>n. Im (trace \\<rho> + seq n)) \\<longlonglongrightarrow> Im (trace \\<rho> + seqlim)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n. Im (trace \\<rho> + seq n))\n    \\<longlonglongrightarrow> Im (trace \\<rho> + seqlim)", "using tendsto_Im[OF limrs]"], ["proof (prove)\nusing this:\n  (\\<lambda>x. Im (trace \\<rho> + seq x))\n  \\<longlonglongrightarrow> Im (trace \\<rho> + seqlim)\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. Im (trace \\<rho> + seq n))\n    \\<longlonglongrightarrow> Im (trace \\<rho> + seqlim)", "by auto"], ["proof (state)\nthis:\n  (\\<lambda>n. Im (trace \\<rho> + seq n))\n  \\<longlonglongrightarrow> Im (trace \\<rho> + seqlim)\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        trace (P * (M0 * \\<rho> * adjoint M0)) +\n        trace (Q * (M1 * \\<rho> * adjoint M1))\n        \\<le> trace (P * matrix_sum d (\\<lambda>k. D0 k \\<rho>) (n + 2)) +\n              trace \\<rho> -\n              trace\n               (matrix_sum d (\\<lambda>k. D0 k \\<rho>)\n                 (n + 2))) \\<Longrightarrow>\n    trace (P * (M0 * \\<rho> * adjoint M0)) +\n    trace (Q * (M1 * \\<rho> * adjoint M1))\n    \\<le> trace (P * denote (While M S) \\<rho>) + trace \\<rho> -\n          trace (denote (While M S) \\<rho>)", "have main_leq_Im: \"Im ?lhs = Im (trace \\<rho> + seq n)\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. Im (trace (P * (M0 * \\<rho> * adjoint M0)) +\n        trace (Q * (M1 * \\<rho> * adjoint M1))) =\n    Im (trace \\<rho> + seq n)", "using main_leq'"], ["proof (prove)\nusing this:\n  trace (P * (M0 * \\<rho> * adjoint M0)) +\n  trace (Q * (M1 * \\<rho> * adjoint M1))\n  \\<le> trace \\<rho> + seq ?n\n\ngoal (1 subgoal):\n 1. Im (trace (P * (M0 * \\<rho> * adjoint M0)) +\n        trace (Q * (M1 * \\<rho> * adjoint M1))) =\n    Im (trace \\<rho> + seq n)", "unfolding less_eq_complex_def"], ["proof (prove)\nusing this:\n  Im (trace (P * (M0 * \\<rho> * adjoint M0)) +\n      trace (Q * (M1 * \\<rho> * adjoint M1))) =\n  Im (trace \\<rho> + seq ?n) \\<and>\n  Re (trace (P * (M0 * \\<rho> * adjoint M0)) +\n      trace (Q * (M1 * \\<rho> * adjoint M1)))\n  \\<le> Re (trace \\<rho> + seq ?n)\n\ngoal (1 subgoal):\n 1. Im (trace (P * (M0 * \\<rho> * adjoint M0)) +\n        trace (Q * (M1 * \\<rho> * adjoint M1))) =\n    Im (trace \\<rho> + seq n)", "by auto"], ["proof (state)\nthis:\n  Im (trace (P * (M0 * \\<rho> * adjoint M0)) +\n      trace (Q * (M1 * \\<rho> * adjoint M1))) =\n  Im (trace \\<rho> + seq ?n)\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        trace (P * (M0 * \\<rho> * adjoint M0)) +\n        trace (Q * (M1 * \\<rho> * adjoint M1))\n        \\<le> trace (P * matrix_sum d (\\<lambda>k. D0 k \\<rho>) (n + 2)) +\n              trace \\<rho> -\n              trace\n               (matrix_sum d (\\<lambda>k. D0 k \\<rho>)\n                 (n + 2))) \\<Longrightarrow>\n    trace (P * (M0 * \\<rho> * adjoint M0)) +\n    trace (Q * (M1 * \\<rho> * adjoint M1))\n    \\<le> trace (P * denote (While M S) \\<rho>) + trace \\<rho> -\n          trace (denote (While M S) \\<rho>)", "then"], ["proof (chain)\npicking this:\n  Im (trace (P * (M0 * \\<rho> * adjoint M0)) +\n      trace (Q * (M1 * \\<rho> * adjoint M1))) =\n  Im (trace \\<rho> + seq ?n)", "have limIm: \"(\\<lambda>n. Im (trace \\<rho> + seq n)) \\<longlonglongrightarrow> Im ?lhs\""], ["proof (prove)\nusing this:\n  Im (trace (P * (M0 * \\<rho> * adjoint M0)) +\n      trace (Q * (M1 * \\<rho> * adjoint M1))) =\n  Im (trace \\<rho> + seq ?n)\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. Im (trace \\<rho> + seq n))\n    \\<longlonglongrightarrow> Im (trace (P * (M0 * \\<rho> * adjoint M0)) +\n                                  trace (Q * (M1 * \\<rho> * adjoint M1)))", "using tendsto_intros(1)"], ["proof (prove)\nusing this:\n  Im (trace (P * (M0 * \\<rho> * adjoint M0)) +\n      trace (Q * (M1 * \\<rho> * adjoint M1))) =\n  Im (trace \\<rho> + seq ?n)\n  ((\\<lambda>x. x) \\<longlongrightarrow> ?a) (at ?a within ?s)\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. Im (trace \\<rho> + seq n))\n    \\<longlonglongrightarrow> Im (trace (P * (M0 * \\<rho> * adjoint M0)) +\n                                  trace (Q * (M1 * \\<rho> * adjoint M1)))", "by auto"], ["proof (state)\nthis:\n  (\\<lambda>n. Im (trace \\<rho> + seq n))\n  \\<longlonglongrightarrow> Im (trace (P * (M0 * \\<rho> * adjoint M0)) +\n                                trace (Q * (M1 * \\<rho> * adjoint M1)))\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        trace (P * (M0 * \\<rho> * adjoint M0)) +\n        trace (Q * (M1 * \\<rho> * adjoint M1))\n        \\<le> trace (P * matrix_sum d (\\<lambda>k. D0 k \\<rho>) (n + 2)) +\n              trace \\<rho> -\n              trace\n               (matrix_sum d (\\<lambda>k. D0 k \\<rho>)\n                 (n + 2))) \\<Longrightarrow>\n    trace (P * (M0 * \\<rho> * adjoint M0)) +\n    trace (Q * (M1 * \\<rho> * adjoint M1))\n    \\<le> trace (P * denote (While M S) \\<rho>) + trace \\<rho> -\n          trace (denote (While M S) \\<rho>)", "have Im: \"Im ?lhs = Im (trace \\<rho> + seqlim)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Im (trace (P * (M0 * \\<rho> * adjoint M0)) +\n        trace (Q * (M1 * \\<rho> * adjoint M1))) =\n    Im (trace \\<rho> + seqlim)", "using tendsto_unique[OF _ limIm limrsIm]"], ["proof (prove)\nusing this:\n  sequentially \\<noteq> bot \\<Longrightarrow>\n  Im (trace (P * (M0 * \\<rho> * adjoint M0)) +\n      trace (Q * (M1 * \\<rho> * adjoint M1))) =\n  Im (trace \\<rho> + seqlim)\n\ngoal (1 subgoal):\n 1. Im (trace (P * (M0 * \\<rho> * adjoint M0)) +\n        trace (Q * (M1 * \\<rho> * adjoint M1))) =\n    Im (trace \\<rho> + seqlim)", "by auto"], ["proof (state)\nthis:\n  Im (trace (P * (M0 * \\<rho> * adjoint M0)) +\n      trace (Q * (M1 * \\<rho> * adjoint M1))) =\n  Im (trace \\<rho> + seqlim)\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        trace (P * (M0 * \\<rho> * adjoint M0)) +\n        trace (Q * (M1 * \\<rho> * adjoint M1))\n        \\<le> trace (P * matrix_sum d (\\<lambda>k. D0 k \\<rho>) (n + 2)) +\n              trace \\<rho> -\n              trace\n               (matrix_sum d (\\<lambda>k. D0 k \\<rho>)\n                 (n + 2))) \\<Longrightarrow>\n    trace (P * (M0 * \\<rho> * adjoint M0)) +\n    trace (Q * (M1 * \\<rho> * adjoint M1))\n    \\<le> trace (P * denote (While M S) \\<rho>) + trace \\<rho> -\n          trace (denote (While M S) \\<rho>)", "have \"?lhs \\<le> trace \\<rho> + seqlim\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace (P * (M0 * \\<rho> * adjoint M0)) +\n    trace (Q * (M1 * \\<rho> * adjoint M1))\n    \\<le> trace \\<rho> + seqlim", "using Re Im"], ["proof (prove)\nusing this:\n  Re (trace (P * (M0 * \\<rho> * adjoint M0)) +\n      trace (Q * (M1 * \\<rho> * adjoint M1)))\n  \\<le> Re (trace \\<rho> + seqlim)\n  Im (trace (P * (M0 * \\<rho> * adjoint M0)) +\n      trace (Q * (M1 * \\<rho> * adjoint M1))) =\n  Im (trace \\<rho> + seqlim)\n\ngoal (1 subgoal):\n 1. trace (P * (M0 * \\<rho> * adjoint M0)) +\n    trace (Q * (M1 * \\<rho> * adjoint M1))\n    \\<le> trace \\<rho> + seqlim", "by auto"], ["proof (state)\nthis:\n  trace (P * (M0 * \\<rho> * adjoint M0)) +\n  trace (Q * (M1 * \\<rho> * adjoint M1))\n  \\<le> trace \\<rho> + seqlim\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        trace (P * (M0 * \\<rho> * adjoint M0)) +\n        trace (Q * (M1 * \\<rho> * adjoint M1))\n        \\<le> trace (P * matrix_sum d (\\<lambda>k. D0 k \\<rho>) (n + 2)) +\n              trace \\<rho> -\n              trace\n               (matrix_sum d (\\<lambda>k. D0 k \\<rho>)\n                 (n + 2))) \\<Longrightarrow>\n    trace (P * (M0 * \\<rho> * adjoint M0)) +\n    trace (Q * (M1 * \\<rho> * adjoint M1))\n    \\<le> trace (P * denote (While M S) \\<rho>) + trace \\<rho> -\n          trace (denote (While M S) \\<rho>)", "then"], ["proof (chain)\npicking this:\n  trace (P * (M0 * \\<rho> * adjoint M0)) +\n  trace (Q * (M1 * \\<rho> * adjoint M1))\n  \\<le> trace \\<rho> + seqlim", "show \"?lhs \\<le> ?rhs\""], ["proof (prove)\nusing this:\n  trace (P * (M0 * \\<rho> * adjoint M0)) +\n  trace (Q * (M1 * \\<rho> * adjoint M1))\n  \\<le> trace \\<rho> + seqlim\n\ngoal (1 subgoal):\n 1. trace (P * (M0 * \\<rho> * adjoint M0)) +\n    trace (Q * (M1 * \\<rho> * adjoint M1))\n    \\<le> trace (P * denote (While M S) \\<rho>) + trace \\<rho> -\n          trace (denote (While M S) \\<rho>)", "unfolding seqlim_def"], ["proof (prove)\nusing this:\n  trace (P * (M0 * \\<rho> * adjoint M0)) +\n  trace (Q * (M1 * \\<rho> * adjoint M1))\n  \\<le> trace \\<rho> +\n        (trace (P * denote (While M S) \\<rho>) -\n         trace (denote (While M S) \\<rho>))\n\ngoal (1 subgoal):\n 1. trace (P * (M0 * \\<rho> * adjoint M0)) +\n    trace (Q * (M1 * \\<rho> * adjoint M1))\n    \\<le> trace (P * denote (While M S) \\<rho>) + trace \\<rho> -\n          trace (denote (While M S) \\<rho>)", "by auto"], ["proof (state)\nthis:\n  trace (P * (M0 * \\<rho> * adjoint M0)) +\n  trace (Q * (M1 * \\<rho> * adjoint M1))\n  \\<le> trace (P * denote (While M S) \\<rho>) + trace \\<rho> -\n        trace (denote (While M S) \\<rho>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  trace (P * (M0 * \\<rho> * adjoint M0)) +\n  trace (Q * (M1 * \\<rho> * adjoint M1))\n  \\<le> trace (P * denote (While M S) \\<rho>) + trace \\<rho> -\n        trace (denote (While M S) \\<rho>)\n\ngoal (2 subgoals):\n 1. \\<And>P Q S M.\n       \\<lbrakk>is_quantum_predicate P; is_quantum_predicate Q;\n        \\<turnstile>\\<^sub>p {Q} S\n                             {adjoint (M 0) * P * M 0 +\n                              adjoint (M 1) * Q * M 1};\n        well_com S \\<Longrightarrow>\n        \\<Turnstile>\\<^sub>p {Q} S\n        {adjoint (M 0) * P * M 0 + adjoint (M 1) * Q * M 1};\n        well_com (While M S)\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {adjoint (M 0) * P * M 0 +\n         adjoint (M 1) * Q * M 1}\n                         While M S {P}\n 2. \\<And>P Q P' Q' S.\n       \\<lbrakk>is_quantum_predicate P; is_quantum_predicate Q;\n        is_quantum_predicate P'; is_quantum_predicate Q';\n        P \\<le>\\<^sub>L P'; \\<turnstile>\\<^sub>p {P'} S {Q'};\n        well_com S \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P'} S {Q'};\n        Q' \\<le>\\<^sub>L Q; well_com S\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P} S {Q}", "have \"trace ((adjoint M0 * P * M0 + adjoint M1 * Q * M1) * \\<rho>) =\n      trace (P * (M0 * \\<rho> * adjoint M0)) + trace (Q * (M1 * \\<rho> * adjoint M1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace ((adjoint M0 * P * M0 + adjoint M1 * Q * M1) * \\<rho>) =\n    trace (P * (M0 * \\<rho> * adjoint M0)) +\n    trace (Q * (M1 * \\<rho> * adjoint M1))", "using dr dM0 dM1 dP dQ"], ["proof (prove)\nusing this:\n  \\<rho> \\<in> carrier_mat d d\n  M0 \\<in> carrier_mat d d\n  M1 \\<in> carrier_mat d d\n  P \\<in> carrier_mat d d\n  Q \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. trace ((adjoint M0 * P * M0 + adjoint M1 * Q * M1) * \\<rho>) =\n    trace (P * (M0 * \\<rho> * adjoint M0)) +\n    trace (Q * (M1 * \\<rho> * adjoint M1))", "by (mat_assoc d)"], ["proof (state)\nthis:\n  trace ((adjoint M0 * P * M0 + adjoint M1 * Q * M1) * \\<rho>) =\n  trace (P * (M0 * \\<rho> * adjoint M0)) +\n  trace (Q * (M1 * \\<rho> * adjoint M1))\n\ngoal (2 subgoals):\n 1. \\<And>P Q S M.\n       \\<lbrakk>is_quantum_predicate P; is_quantum_predicate Q;\n        \\<turnstile>\\<^sub>p {Q} S\n                             {adjoint (M 0) * P * M 0 +\n                              adjoint (M 1) * Q * M 1};\n        well_com S \\<Longrightarrow>\n        \\<Turnstile>\\<^sub>p {Q} S\n        {adjoint (M 0) * P * M 0 + adjoint (M 1) * Q * M 1};\n        well_com (While M S)\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {adjoint (M 0) * P * M 0 +\n         adjoint (M 1) * Q * M 1}\n                         While M S {P}\n 2. \\<And>P Q P' Q' S.\n       \\<lbrakk>is_quantum_predicate P; is_quantum_predicate Q;\n        is_quantum_predicate P'; is_quantum_predicate Q';\n        P \\<le>\\<^sub>L P'; \\<turnstile>\\<^sub>p {P'} S {Q'};\n        well_com S \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P'} S {Q'};\n        Q' \\<le>\\<^sub>L Q; well_com S\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P} S {Q}", "then"], ["proof (chain)\npicking this:\n  trace ((adjoint M0 * P * M0 + adjoint M1 * Q * M1) * \\<rho>) =\n  trace (P * (M0 * \\<rho> * adjoint M0)) +\n  trace (Q * (M1 * \\<rho> * adjoint M1))", "have \"trace ((adjoint M0 * P * M0 + adjoint M1 * Q * M1) * \\<rho>) \\<le> \n      trace (P * (denote (While M S) \\<rho>)) + (trace \\<rho> - trace (denote (While M S) \\<rho>))\""], ["proof (prove)\nusing this:\n  trace ((adjoint M0 * P * M0 + adjoint M1 * Q * M1) * \\<rho>) =\n  trace (P * (M0 * \\<rho> * adjoint M0)) +\n  trace (Q * (M1 * \\<rho> * adjoint M1))\n\ngoal (1 subgoal):\n 1. trace ((adjoint M0 * P * M0 + adjoint M1 * Q * M1) * \\<rho>)\n    \\<le> trace (P * denote (While M S) \\<rho>) +\n          (trace \\<rho> - trace (denote (While M S) \\<rho>))", "using leq_lim"], ["proof (prove)\nusing this:\n  trace ((adjoint M0 * P * M0 + adjoint M1 * Q * M1) * \\<rho>) =\n  trace (P * (M0 * \\<rho> * adjoint M0)) +\n  trace (Q * (M1 * \\<rho> * adjoint M1))\n  trace (P * (M0 * \\<rho> * adjoint M0)) +\n  trace (Q * (M1 * \\<rho> * adjoint M1))\n  \\<le> trace (P * denote (While M S) \\<rho>) + trace \\<rho> -\n        trace (denote (While M S) \\<rho>)\n\ngoal (1 subgoal):\n 1. trace ((adjoint M0 * P * M0 + adjoint M1 * Q * M1) * \\<rho>)\n    \\<le> trace (P * denote (While M S) \\<rho>) +\n          (trace \\<rho> - trace (denote (While M S) \\<rho>))", "by auto"], ["proof (state)\nthis:\n  trace ((adjoint M0 * P * M0 + adjoint M1 * Q * M1) * \\<rho>)\n  \\<le> trace (P * denote (While M S) \\<rho>) +\n        (trace \\<rho> - trace (denote (While M S) \\<rho>))\n\ngoal (2 subgoals):\n 1. \\<And>P Q S M.\n       \\<lbrakk>is_quantum_predicate P; is_quantum_predicate Q;\n        \\<turnstile>\\<^sub>p {Q} S\n                             {adjoint (M 0) * P * M 0 +\n                              adjoint (M 1) * Q * M 1};\n        well_com S \\<Longrightarrow>\n        \\<Turnstile>\\<^sub>p {Q} S\n        {adjoint (M 0) * P * M 0 + adjoint (M 1) * Q * M 1};\n        well_com (While M S)\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {adjoint (M 0) * P * M 0 +\n         adjoint (M 1) * Q * M 1}\n                         While M S {P}\n 2. \\<And>P Q P' Q' S.\n       \\<lbrakk>is_quantum_predicate P; is_quantum_predicate Q;\n        is_quantum_predicate P'; is_quantum_predicate Q';\n        P \\<le>\\<^sub>L P'; \\<turnstile>\\<^sub>p {P'} S {Q'};\n        well_com S \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P'} S {Q'};\n        Q' \\<le>\\<^sub>L Q; well_com S\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P} S {Q}", "}"], ["proof (state)\nthis:\n  ?\\<rho>2 \\<in> density_states \\<Longrightarrow>\n  trace ((adjoint M0 * P * M0 + adjoint M1 * Q * M1) * ?\\<rho>2)\n  \\<le> trace (P * denote (While M S) ?\\<rho>2) +\n        (trace ?\\<rho>2 - trace (denote (While M S) ?\\<rho>2))\n\ngoal (2 subgoals):\n 1. \\<And>P Q S M.\n       \\<lbrakk>is_quantum_predicate P; is_quantum_predicate Q;\n        \\<turnstile>\\<^sub>p {Q} S\n                             {adjoint (M 0) * P * M 0 +\n                              adjoint (M 1) * Q * M 1};\n        well_com S \\<Longrightarrow>\n        \\<Turnstile>\\<^sub>p {Q} S\n        {adjoint (M 0) * P * M 0 + adjoint (M 1) * Q * M 1};\n        well_com (While M S)\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {adjoint (M 0) * P * M 0 +\n         adjoint (M 1) * Q * M 1}\n                         While M S {P}\n 2. \\<And>P Q P' Q' S.\n       \\<lbrakk>is_quantum_predicate P; is_quantum_predicate Q;\n        is_quantum_predicate P'; is_quantum_predicate Q';\n        P \\<le>\\<^sub>L P'; \\<turnstile>\\<^sub>p {P'} S {Q'};\n        well_com S \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P'} S {Q'};\n        Q' \\<le>\\<^sub>L Q; well_com S\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P} S {Q}", "then"], ["proof (chain)\npicking this:\n  ?\\<rho>2 \\<in> density_states \\<Longrightarrow>\n  trace ((adjoint M0 * P * M0 + adjoint M1 * Q * M1) * ?\\<rho>2)\n  \\<le> trace (P * denote (While M S) ?\\<rho>2) +\n        (trace ?\\<rho>2 - trace (denote (While M S) ?\\<rho>2))", "show ?case"], ["proof (prove)\nusing this:\n  ?\\<rho>2 \\<in> density_states \\<Longrightarrow>\n  trace ((adjoint M0 * P * M0 + adjoint M1 * Q * M1) * ?\\<rho>2)\n  \\<le> trace (P * denote (While M S) ?\\<rho>2) +\n        (trace ?\\<rho>2 - trace (denote (While M S) ?\\<rho>2))\n\ngoal (1 subgoal):\n 1. \\<Turnstile>\\<^sub>p {adjoint (M 0) * P * M 0 + adjoint (M 1) * Q * M 1}\n    While M S {P}", "unfolding hoare_partial_correct_def denote.simps(5)"], ["proof (prove)\nusing this:\n  ?\\<rho>2 \\<in> density_states \\<Longrightarrow>\n  trace ((adjoint M0 * P * M0 + adjoint M1 * Q * M1) * ?\\<rho>2)\n  \\<le> trace (P * denote_while (M 0) (M 1) (denote S) ?\\<rho>2) +\n        (trace ?\\<rho>2 -\n         trace (denote_while (M 0) (M 1) (denote S) ?\\<rho>2))\n\ngoal (1 subgoal):\n 1. \\<forall>\\<rho>\\<in>density_states.\n       trace ((adjoint (M 0) * P * M 0 + adjoint (M 1) * Q * M 1) * \\<rho>)\n       \\<le> trace (P * denote_while (M 0) (M 1) (denote S) \\<rho>) +\n             (trace \\<rho> -\n              trace (denote_while (M 0) (M 1) (denote S) \\<rho>))", "apply (fold M0_def M1_def DS_def D0_def D1_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>\\<rho>.\n        \\<rho> \\<in> density_states \\<Longrightarrow>\n        trace ((adjoint M0 * P * M0 + adjoint M1 * Q * M1) * \\<rho>)\n        \\<le> trace (P * denote_while M0 M1 DS \\<rho>) +\n              (trace \\<rho> -\n               trace (denote_while M0 M1 DS \\<rho>))) \\<Longrightarrow>\n    \\<forall>\\<rho>\\<in>density_states.\n       trace ((adjoint M0 * P * M0 + adjoint M1 * Q * M1) * \\<rho>)\n       \\<le> trace (P * denote_while M0 M1 DS \\<rho>) +\n             (trace \\<rho> - trace (denote_while M0 M1 DS \\<rho>))", "by auto"], ["proof (state)\nthis:\n  \\<Turnstile>\\<^sub>p {adjoint (M 0) * P * M 0 + adjoint (M 1) * Q * M 1}\n  While M S {P}\n\ngoal (1 subgoal):\n 1. \\<And>P Q P' Q' S.\n       \\<lbrakk>is_quantum_predicate P; is_quantum_predicate Q;\n        is_quantum_predicate P'; is_quantum_predicate Q';\n        P \\<le>\\<^sub>L P'; \\<turnstile>\\<^sub>p {P'} S {Q'};\n        well_com S \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P'} S {Q'};\n        Q' \\<le>\\<^sub>L Q; well_com S\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P} S {Q}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>P Q P' Q' S.\n       \\<lbrakk>is_quantum_predicate P; is_quantum_predicate Q;\n        is_quantum_predicate P'; is_quantum_predicate Q';\n        P \\<le>\\<^sub>L P'; \\<turnstile>\\<^sub>p {P'} S {Q'};\n        well_com S \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P'} S {Q'};\n        Q' \\<le>\\<^sub>L Q; well_com S\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P} S {Q}", "case (6 P Q P' Q' S)"], ["proof (state)\nthis:\n  is_quantum_predicate P\n  is_quantum_predicate Q\n  is_quantum_predicate P'\n  is_quantum_predicate Q'\n  P \\<le>\\<^sub>L P'\n  \\<turnstile>\\<^sub>p {P'} S {Q'}\n  Q' \\<le>\\<^sub>L Q\n  well_com S \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P'} S {Q'}\n  well_com S\n\ngoal (1 subgoal):\n 1. \\<And>P Q P' Q' S.\n       \\<lbrakk>is_quantum_predicate P; is_quantum_predicate Q;\n        is_quantum_predicate P'; is_quantum_predicate Q';\n        P \\<le>\\<^sub>L P'; \\<turnstile>\\<^sub>p {P'} S {Q'};\n        well_com S \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P'} S {Q'};\n        Q' \\<le>\\<^sub>L Q; well_com S\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P} S {Q}", "then"], ["proof (chain)\npicking this:\n  is_quantum_predicate P\n  is_quantum_predicate Q\n  is_quantum_predicate P'\n  is_quantum_predicate Q'\n  P \\<le>\\<^sub>L P'\n  \\<turnstile>\\<^sub>p {P'} S {Q'}\n  Q' \\<le>\\<^sub>L Q\n  well_com S \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P'} S {Q'}\n  well_com S", "have wcs: \"well_com S\" and c: \"\\<Turnstile>\\<^sub>p {P'} S {Q'}\" \n    and dP: \"P \\<in> carrier_mat d d\" and dQ: \"Q \\<in> carrier_mat d d\"\n    and dP': \"P' \\<in> carrier_mat d d\" and dQ': \"Q' \\<in> carrier_mat d d\""], ["proof (prove)\nusing this:\n  is_quantum_predicate P\n  is_quantum_predicate Q\n  is_quantum_predicate P'\n  is_quantum_predicate Q'\n  P \\<le>\\<^sub>L P'\n  \\<turnstile>\\<^sub>p {P'} S {Q'}\n  Q' \\<le>\\<^sub>L Q\n  well_com S \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P'} S {Q'}\n  well_com S\n\ngoal (1 subgoal):\n 1. (well_com S &&&\n     \\<Turnstile>\\<^sub>p {P'} S {Q'} &&& P \\<in> carrier_mat d d) &&&\n    Q \\<in> carrier_mat d d &&&\n    P' \\<in> carrier_mat d d &&& Q' \\<in> carrier_mat d d", "using is_quantum_predicate_def"], ["proof (prove)\nusing this:\n  is_quantum_predicate P\n  is_quantum_predicate Q\n  is_quantum_predicate P'\n  is_quantum_predicate Q'\n  P \\<le>\\<^sub>L P'\n  \\<turnstile>\\<^sub>p {P'} S {Q'}\n  Q' \\<le>\\<^sub>L Q\n  well_com S \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P'} S {Q'}\n  well_com S\n  is_quantum_predicate ?P =\n  (?P \\<in> carrier_mat d d \\<and>\n   positive ?P \\<and> ?P \\<le>\\<^sub>L 1\\<^sub>m d)\n\ngoal (1 subgoal):\n 1. (well_com S &&&\n     \\<Turnstile>\\<^sub>p {P'} S {Q'} &&& P \\<in> carrier_mat d d) &&&\n    Q \\<in> carrier_mat d d &&&\n    P' \\<in> carrier_mat d d &&& Q' \\<in> carrier_mat d d", "by auto"], ["proof (state)\nthis:\n  well_com S\n  \\<Turnstile>\\<^sub>p {P'} S {Q'}\n  P \\<in> carrier_mat d d\n  Q \\<in> carrier_mat d d\n  P' \\<in> carrier_mat d d\n  Q' \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. \\<And>P Q P' Q' S.\n       \\<lbrakk>is_quantum_predicate P; is_quantum_predicate Q;\n        is_quantum_predicate P'; is_quantum_predicate Q';\n        P \\<le>\\<^sub>L P'; \\<turnstile>\\<^sub>p {P'} S {Q'};\n        well_com S \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P'} S {Q'};\n        Q' \\<le>\\<^sub>L Q; well_com S\\<rbrakk>\n       \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P} S {Q}", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Turnstile>\\<^sub>p {P} S {Q}", "unfolding hoare_partial_correct_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<rho>\\<in>density_states.\n       trace (P * \\<rho>)\n       \\<le> trace (Q * denote S \\<rho>) +\n             (trace \\<rho> - trace (denote S \\<rho>))", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<rho>.\n       \\<rho> \\<in> density_states \\<Longrightarrow>\n       trace (P * \\<rho>)\n       \\<le> trace (Q * denote S \\<rho>) +\n             (trace \\<rho> - trace (denote S \\<rho>))", "fix \\<rho>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<rho>.\n       \\<rho> \\<in> density_states \\<Longrightarrow>\n       trace (P * \\<rho>)\n       \\<le> trace (Q * denote S \\<rho>) +\n             (trace \\<rho> - trace (denote S \\<rho>))", "assume pds: \"\\<rho> \\<in> density_states\""], ["proof (state)\nthis:\n  \\<rho> \\<in> density_states\n\ngoal (1 subgoal):\n 1. \\<And>\\<rho>.\n       \\<rho> \\<in> density_states \\<Longrightarrow>\n       trace (P * \\<rho>)\n       \\<le> trace (Q * denote S \\<rho>) +\n             (trace \\<rho> - trace (denote S \\<rho>))", "then"], ["proof (chain)\npicking this:\n  \\<rho> \\<in> density_states", "have pdor: \"partial_density_operator \\<rho>\" and dr: \"\\<rho> \\<in> carrier_mat d d\""], ["proof (prove)\nusing this:\n  \\<rho> \\<in> density_states\n\ngoal (1 subgoal):\n 1. partial_density_operator \\<rho> &&& \\<rho> \\<in> carrier_mat d d", "using density_states_def"], ["proof (prove)\nusing this:\n  \\<rho> \\<in> density_states\n  density_states =\n  {\\<rho> \\<in> carrier_mat d d. partial_density_operator \\<rho>}\n\ngoal (1 subgoal):\n 1. partial_density_operator \\<rho> &&& \\<rho> \\<in> carrier_mat d d", "by auto"], ["proof (state)\nthis:\n  partial_density_operator \\<rho>\n  \\<rho> \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. \\<And>\\<rho>.\n       \\<rho> \\<in> density_states \\<Longrightarrow>\n       trace (P * \\<rho>)\n       \\<le> trace (Q * denote S \\<rho>) +\n             (trace \\<rho> - trace (denote S \\<rho>))", "have pdoSr: \"partial_density_operator (denote S \\<rho>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. partial_density_operator (denote S \\<rho>)", "using denote_partial_density_operator pdor dr wcs"], ["proof (prove)\nusing this:\n  \\<lbrakk>well_com ?S; partial_density_operator ?\\<rho>;\n   ?\\<rho> \\<in> carrier_mat d d\\<rbrakk>\n  \\<Longrightarrow> partial_density_operator (denote ?S ?\\<rho>)\n  partial_density_operator \\<rho>\n  \\<rho> \\<in> carrier_mat d d\n  well_com S\n\ngoal (1 subgoal):\n 1. partial_density_operator (denote S \\<rho>)", "by auto"], ["proof (state)\nthis:\n  partial_density_operator (denote S \\<rho>)\n\ngoal (1 subgoal):\n 1. \\<And>\\<rho>.\n       \\<rho> \\<in> density_states \\<Longrightarrow>\n       trace (P * \\<rho>)\n       \\<le> trace (Q * denote S \\<rho>) +\n             (trace \\<rho> - trace (denote S \\<rho>))", "have dSr: \"denote S \\<rho> \\<in> carrier_mat d d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. denote S \\<rho> \\<in> carrier_mat d d", "using denote_dim pdor dr wcs"], ["proof (prove)\nusing this:\n  \\<lbrakk>well_com ?S; ?\\<rho> \\<in> carrier_mat d d;\n   partial_density_operator ?\\<rho>\\<rbrakk>\n  \\<Longrightarrow> denote ?S ?\\<rho> \\<in> carrier_mat d d\n  partial_density_operator \\<rho>\n  \\<rho> \\<in> carrier_mat d d\n  well_com S\n\ngoal (1 subgoal):\n 1. denote S \\<rho> \\<in> carrier_mat d d", "by auto"], ["proof (state)\nthis:\n  denote S \\<rho> \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. \\<And>\\<rho>.\n       \\<rho> \\<in> density_states \\<Longrightarrow>\n       trace (P * \\<rho>)\n       \\<le> trace (Q * denote S \\<rho>) +\n             (trace \\<rho> - trace (denote S \\<rho>))", "have \"trace (P * \\<rho>) \\<le> trace (P' * \\<rho>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace (P * \\<rho>) \\<le> trace (P' * \\<rho>)", "using lowner_le_trace[OF dP dP'] 6 dr pdor"], ["proof (prove)\nusing this:\n  (P \\<le>\\<^sub>L P') =\n  (\\<forall>\\<rho>\\<in>carrier_mat d d.\n      partial_density_operator \\<rho> \\<longrightarrow>\n      trace (P * \\<rho>) \\<le> trace (P' * \\<rho>))\n  is_quantum_predicate P\n  is_quantum_predicate Q\n  is_quantum_predicate P'\n  is_quantum_predicate Q'\n  P \\<le>\\<^sub>L P'\n  \\<turnstile>\\<^sub>p {P'} S {Q'}\n  Q' \\<le>\\<^sub>L Q\n  well_com S \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P'} S {Q'}\n  well_com S\n  \\<rho> \\<in> carrier_mat d d\n  partial_density_operator \\<rho>\n\ngoal (1 subgoal):\n 1. trace (P * \\<rho>) \\<le> trace (P' * \\<rho>)", "by auto"], ["proof (state)\nthis:\n  trace (P * \\<rho>) \\<le> trace (P' * \\<rho>)\n\ngoal (1 subgoal):\n 1. \\<And>\\<rho>.\n       \\<rho> \\<in> density_states \\<Longrightarrow>\n       trace (P * \\<rho>)\n       \\<le> trace (Q * denote S \\<rho>) +\n             (trace \\<rho> - trace (denote S \\<rho>))", "also"], ["proof (state)\nthis:\n  trace (P * \\<rho>) \\<le> trace (P' * \\<rho>)\n\ngoal (1 subgoal):\n 1. \\<And>\\<rho>.\n       \\<rho> \\<in> density_states \\<Longrightarrow>\n       trace (P * \\<rho>)\n       \\<le> trace (Q * denote S \\<rho>) +\n             (trace \\<rho> - trace (denote S \\<rho>))", "have \"\\<dots> \\<le> trace (Q' * denote S \\<rho>) + (trace \\<rho> - trace (denote S \\<rho>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace (P' * \\<rho>)\n    \\<le> trace (Q' * denote S \\<rho>) +\n          (trace \\<rho> - trace (denote S \\<rho>))", "using c"], ["proof (prove)\nusing this:\n  \\<Turnstile>\\<^sub>p {P'} S {Q'}\n\ngoal (1 subgoal):\n 1. trace (P' * \\<rho>)\n    \\<le> trace (Q' * denote S \\<rho>) +\n          (trace \\<rho> - trace (denote S \\<rho>))", "unfolding hoare_partial_correct_def"], ["proof (prove)\nusing this:\n  \\<forall>\\<rho>\\<in>density_states.\n     trace (P' * \\<rho>)\n     \\<le> trace (Q' * denote S \\<rho>) +\n           (trace \\<rho> - trace (denote S \\<rho>))\n\ngoal (1 subgoal):\n 1. trace (P' * \\<rho>)\n    \\<le> trace (Q' * denote S \\<rho>) +\n          (trace \\<rho> - trace (denote S \\<rho>))", "using pds"], ["proof (prove)\nusing this:\n  \\<forall>\\<rho>\\<in>density_states.\n     trace (P' * \\<rho>)\n     \\<le> trace (Q' * denote S \\<rho>) +\n           (trace \\<rho> - trace (denote S \\<rho>))\n  \\<rho> \\<in> density_states\n\ngoal (1 subgoal):\n 1. trace (P' * \\<rho>)\n    \\<le> trace (Q' * denote S \\<rho>) +\n          (trace \\<rho> - trace (denote S \\<rho>))", "by auto"], ["proof (state)\nthis:\n  trace (P' * \\<rho>)\n  \\<le> trace (Q' * denote S \\<rho>) +\n        (trace \\<rho> - trace (denote S \\<rho>))\n\ngoal (1 subgoal):\n 1. \\<And>\\<rho>.\n       \\<rho> \\<in> density_states \\<Longrightarrow>\n       trace (P * \\<rho>)\n       \\<le> trace (Q * denote S \\<rho>) +\n             (trace \\<rho> - trace (denote S \\<rho>))", "also"], ["proof (state)\nthis:\n  trace (P' * \\<rho>)\n  \\<le> trace (Q' * denote S \\<rho>) +\n        (trace \\<rho> - trace (denote S \\<rho>))\n\ngoal (1 subgoal):\n 1. \\<And>\\<rho>.\n       \\<rho> \\<in> density_states \\<Longrightarrow>\n       trace (P * \\<rho>)\n       \\<le> trace (Q * denote S \\<rho>) +\n             (trace \\<rho> - trace (denote S \\<rho>))", "have \"\\<dots> \\<le> trace (Q * denote S \\<rho>) + (trace \\<rho> - trace (denote S \\<rho>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace (Q' * denote S \\<rho>) + (trace \\<rho> - trace (denote S \\<rho>))\n    \\<le> trace (Q * denote S \\<rho>) +\n          (trace \\<rho> - trace (denote S \\<rho>))", "using lowner_le_trace[OF dQ' dQ] 6 dSr pdoSr"], ["proof (prove)\nusing this:\n  (Q' \\<le>\\<^sub>L Q) =\n  (\\<forall>\\<rho>\\<in>carrier_mat d d.\n      partial_density_operator \\<rho> \\<longrightarrow>\n      trace (Q' * \\<rho>) \\<le> trace (Q * \\<rho>))\n  is_quantum_predicate P\n  is_quantum_predicate Q\n  is_quantum_predicate P'\n  is_quantum_predicate Q'\n  P \\<le>\\<^sub>L P'\n  \\<turnstile>\\<^sub>p {P'} S {Q'}\n  Q' \\<le>\\<^sub>L Q\n  well_com S \\<Longrightarrow> \\<Turnstile>\\<^sub>p {P'} S {Q'}\n  well_com S\n  denote S \\<rho> \\<in> carrier_mat d d\n  partial_density_operator (denote S \\<rho>)\n\ngoal (1 subgoal):\n 1. trace (Q' * denote S \\<rho>) + (trace \\<rho> - trace (denote S \\<rho>))\n    \\<le> trace (Q * denote S \\<rho>) +\n          (trace \\<rho> - trace (denote S \\<rho>))", "by auto"], ["proof (state)\nthis:\n  trace (Q' * denote S \\<rho>) + (trace \\<rho> - trace (denote S \\<rho>))\n  \\<le> trace (Q * denote S \\<rho>) +\n        (trace \\<rho> - trace (denote S \\<rho>))\n\ngoal (1 subgoal):\n 1. \\<And>\\<rho>.\n       \\<rho> \\<in> density_states \\<Longrightarrow>\n       trace (P * \\<rho>)\n       \\<le> trace (Q * denote S \\<rho>) +\n             (trace \\<rho> - trace (denote S \\<rho>))", "finally"], ["proof (chain)\npicking this:\n  trace (P * \\<rho>)\n  \\<le> trace (Q * denote S \\<rho>) +\n        (trace \\<rho> - trace (denote S \\<rho>))", "show \"trace (P * \\<rho>) \\<le> trace (Q * denote S \\<rho>) + (trace \\<rho> - trace (denote S \\<rho>)) \""], ["proof (prove)\nusing this:\n  trace (P * \\<rho>)\n  \\<le> trace (Q * denote S \\<rho>) +\n        (trace \\<rho> - trace (denote S \\<rho>))\n\ngoal (1 subgoal):\n 1. trace (P * \\<rho>)\n    \\<le> trace (Q * denote S \\<rho>) +\n          (trace \\<rho> - trace (denote S \\<rho>))", "."], ["proof (state)\nthis:\n  trace (P * \\<rho>)\n  \\<le> trace (Q * denote S \\<rho>) +\n        (trace \\<rho> - trace (denote S \\<rho>))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<Turnstile>\\<^sub>p {P} S {Q}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma wlp_complete:\n  \"well_com S \\<Longrightarrow> is_quantum_predicate P \\<Longrightarrow> \\<turnstile>\\<^sub>p {wlp S P} S {P}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>well_com S; is_quantum_predicate P\\<rbrakk>\n    \\<Longrightarrow> \\<turnstile>\\<^sub>p {wlp S P} S {P}", "proof (induct S arbitrary: P)"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>P.\n       \\<lbrakk>well_com SKIP; is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>p {wlp SKIP P} SKIP {P}\n 2. \\<And>x P.\n       \\<lbrakk>well_com (Utrans x); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>p {wlp (Utrans x) P} Utrans x\n        {P}\n 3. \\<And>S1 S2 P.\n       \\<lbrakk>\\<And>P.\n                   \\<lbrakk>well_com S1; is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>p {wlp S1 P} S1 {P};\n        \\<And>P.\n           \\<lbrakk>well_com S2; is_quantum_predicate P\\<rbrakk>\n           \\<Longrightarrow> \\<turnstile>\\<^sub>p {wlp S2 P} S2 {P};\n        well_com (S1;; S2); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>p {wlp (S1;; S2) P} S1;; S2 {P}\n 4. \\<And>x1 x2a x3 P.\n       \\<lbrakk>\\<And>x3a P.\n                   \\<lbrakk>x3a \\<in> set x3; well_com x3a;\n                    is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>p {wlp x3a P} x3a\n                    {P};\n        well_com (Measure x1 x2a x3); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>p {wlp (Measure x1 x2a x3) P}\n        Measure x1 x2a x3 {P}\n 5. \\<And>x1 S P.\n       \\<lbrakk>\\<And>P.\n                   \\<lbrakk>well_com S; is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>p {wlp S P} S {P};\n        well_com (While x1 S); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>p {wlp (While x1 S) P}\n        While x1 S {P}", "case SKIP"], ["proof (state)\nthis:\n  well_com SKIP\n  is_quantum_predicate P\n\ngoal (5 subgoals):\n 1. \\<And>P.\n       \\<lbrakk>well_com SKIP; is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>p {wlp SKIP P} SKIP {P}\n 2. \\<And>x P.\n       \\<lbrakk>well_com (Utrans x); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>p {wlp (Utrans x) P} Utrans x\n        {P}\n 3. \\<And>S1 S2 P.\n       \\<lbrakk>\\<And>P.\n                   \\<lbrakk>well_com S1; is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>p {wlp S1 P} S1 {P};\n        \\<And>P.\n           \\<lbrakk>well_com S2; is_quantum_predicate P\\<rbrakk>\n           \\<Longrightarrow> \\<turnstile>\\<^sub>p {wlp S2 P} S2 {P};\n        well_com (S1;; S2); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>p {wlp (S1;; S2) P} S1;; S2 {P}\n 4. \\<And>x1 x2a x3 P.\n       \\<lbrakk>\\<And>x3a P.\n                   \\<lbrakk>x3a \\<in> set x3; well_com x3a;\n                    is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>p {wlp x3a P} x3a\n                    {P};\n        well_com (Measure x1 x2a x3); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>p {wlp (Measure x1 x2a x3) P}\n        Measure x1 x2a x3 {P}\n 5. \\<And>x1 S P.\n       \\<lbrakk>\\<And>P.\n                   \\<lbrakk>well_com S; is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>p {wlp S P} S {P};\n        well_com (While x1 S); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>p {wlp (While x1 S) P}\n        While x1 S {P}", "then"], ["proof (chain)\npicking this:\n  well_com SKIP\n  is_quantum_predicate P", "show ?case"], ["proof (prove)\nusing this:\n  well_com SKIP\n  is_quantum_predicate P\n\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>p {wlp SKIP P} SKIP {P}", "unfolding wlp.simps"], ["proof (prove)\nusing this:\n  well_com SKIP\n  is_quantum_predicate P\n\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>p {P} SKIP {P}", "using hoare_partial.intros"], ["proof (prove)\nusing this:\n  well_com SKIP\n  is_quantum_predicate P\n  is_quantum_predicate ?P \\<Longrightarrow>\n  \\<turnstile>\\<^sub>p {?P} SKIP {?P}\n  is_quantum_predicate ?P \\<Longrightarrow>\n  \\<turnstile>\\<^sub>p {adjoint ?U * ?P * ?U} Utrans ?U {?P}\n  \\<lbrakk>is_quantum_predicate ?P; is_quantum_predicate ?Q;\n   is_quantum_predicate ?R; \\<turnstile>\\<^sub>p {?P} ?S1.0 {?Q};\n   \\<turnstile>\\<^sub>p {?Q} ?S2.0 {?R}\\<rbrakk>\n  \\<Longrightarrow> \\<turnstile>\\<^sub>p {?P} ?S1.0;; ?S2.0 {?R}\n  \\<lbrakk>\\<And>k. k < ?n \\<Longrightarrow> is_quantum_predicate (?P k);\n   is_quantum_predicate ?Q;\n   \\<And>k.\n      k < ?n \\<Longrightarrow>\n      \\<turnstile>\\<^sub>p {?P k} ?S ! k {?Q}\\<rbrakk>\n  \\<Longrightarrow> \\<turnstile>\\<^sub>p {matrix_sum d\n     (\\<lambda>k. adjoint (?M k) * ?P k * ?M k) ?n}\n   Measure ?n ?M ?S {?Q}\n  \\<lbrakk>is_quantum_predicate ?P; is_quantum_predicate ?Q;\n   \\<turnstile>\\<^sub>p {?Q} ?S\n                        {adjoint (?M 0) * ?P * ?M 0 +\n                         adjoint (?M 1) * ?Q * ?M 1}\\<rbrakk>\n  \\<Longrightarrow> \\<turnstile>\\<^sub>p {adjoint (?M 0) * ?P * ?M 0 +\n    adjoint (?M 1) * ?Q * ?M 1}\n   While ?M ?S {?P}\n  \\<lbrakk>is_quantum_predicate ?P; is_quantum_predicate ?Q;\n   is_quantum_predicate ?P'; is_quantum_predicate ?Q'; ?P \\<le>\\<^sub>L ?P';\n   \\<turnstile>\\<^sub>p {?P'} ?S {?Q'}; ?Q' \\<le>\\<^sub>L ?Q\\<rbrakk>\n  \\<Longrightarrow> \\<turnstile>\\<^sub>p {?P} ?S {?Q}\n\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>p {P} SKIP {P}", "by auto"], ["proof (state)\nthis:\n  \\<turnstile>\\<^sub>p {wlp SKIP P} SKIP {P}\n\ngoal (4 subgoals):\n 1. \\<And>x P.\n       \\<lbrakk>well_com (Utrans x); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>p {wlp (Utrans x) P} Utrans x\n        {P}\n 2. \\<And>S1 S2 P.\n       \\<lbrakk>\\<And>P.\n                   \\<lbrakk>well_com S1; is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>p {wlp S1 P} S1 {P};\n        \\<And>P.\n           \\<lbrakk>well_com S2; is_quantum_predicate P\\<rbrakk>\n           \\<Longrightarrow> \\<turnstile>\\<^sub>p {wlp S2 P} S2 {P};\n        well_com (S1;; S2); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>p {wlp (S1;; S2) P} S1;; S2 {P}\n 3. \\<And>x1 x2a x3 P.\n       \\<lbrakk>\\<And>x3a P.\n                   \\<lbrakk>x3a \\<in> set x3; well_com x3a;\n                    is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>p {wlp x3a P} x3a\n                    {P};\n        well_com (Measure x1 x2a x3); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>p {wlp (Measure x1 x2a x3) P}\n        Measure x1 x2a x3 {P}\n 4. \\<And>x1 S P.\n       \\<lbrakk>\\<And>P.\n                   \\<lbrakk>well_com S; is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>p {wlp S P} S {P};\n        well_com (While x1 S); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>p {wlp (While x1 S) P}\n        While x1 S {P}", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x P.\n       \\<lbrakk>well_com (Utrans x); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>p {wlp (Utrans x) P} Utrans x\n        {P}\n 2. \\<And>S1 S2 P.\n       \\<lbrakk>\\<And>P.\n                   \\<lbrakk>well_com S1; is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>p {wlp S1 P} S1 {P};\n        \\<And>P.\n           \\<lbrakk>well_com S2; is_quantum_predicate P\\<rbrakk>\n           \\<Longrightarrow> \\<turnstile>\\<^sub>p {wlp S2 P} S2 {P};\n        well_com (S1;; S2); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>p {wlp (S1;; S2) P} S1;; S2 {P}\n 3. \\<And>x1 x2a x3 P.\n       \\<lbrakk>\\<And>x3a P.\n                   \\<lbrakk>x3a \\<in> set x3; well_com x3a;\n                    is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>p {wlp x3a P} x3a\n                    {P};\n        well_com (Measure x1 x2a x3); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>p {wlp (Measure x1 x2a x3) P}\n        Measure x1 x2a x3 {P}\n 4. \\<And>x1 S P.\n       \\<lbrakk>\\<And>P.\n                   \\<lbrakk>well_com S; is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>p {wlp S P} S {P};\n        well_com (While x1 S); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>p {wlp (While x1 S) P}\n        While x1 S {P}", "case (Utrans U)"], ["proof (state)\nthis:\n  well_com (Utrans U)\n  is_quantum_predicate P\n\ngoal (4 subgoals):\n 1. \\<And>x P.\n       \\<lbrakk>well_com (Utrans x); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>p {wlp (Utrans x) P} Utrans x\n        {P}\n 2. \\<And>S1 S2 P.\n       \\<lbrakk>\\<And>P.\n                   \\<lbrakk>well_com S1; is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>p {wlp S1 P} S1 {P};\n        \\<And>P.\n           \\<lbrakk>well_com S2; is_quantum_predicate P\\<rbrakk>\n           \\<Longrightarrow> \\<turnstile>\\<^sub>p {wlp S2 P} S2 {P};\n        well_com (S1;; S2); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>p {wlp (S1;; S2) P} S1;; S2 {P}\n 3. \\<And>x1 x2a x3 P.\n       \\<lbrakk>\\<And>x3a P.\n                   \\<lbrakk>x3a \\<in> set x3; well_com x3a;\n                    is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>p {wlp x3a P} x3a\n                    {P};\n        well_com (Measure x1 x2a x3); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>p {wlp (Measure x1 x2a x3) P}\n        Measure x1 x2a x3 {P}\n 4. \\<And>x1 S P.\n       \\<lbrakk>\\<And>P.\n                   \\<lbrakk>well_com S; is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>p {wlp S P} S {P};\n        well_com (While x1 S); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>p {wlp (While x1 S) P}\n        While x1 S {P}", "then"], ["proof (chain)\npicking this:\n  well_com (Utrans U)\n  is_quantum_predicate P", "show ?case"], ["proof (prove)\nusing this:\n  well_com (Utrans U)\n  is_quantum_predicate P\n\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>p {wlp (Utrans U) P} Utrans U {P}", "unfolding wlp.simps"], ["proof (prove)\nusing this:\n  well_com (Utrans U)\n  is_quantum_predicate P\n\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>p {adjoint U * P * U} Utrans U {P}", "using hoare_partial.intros"], ["proof (prove)\nusing this:\n  well_com (Utrans U)\n  is_quantum_predicate P\n  is_quantum_predicate ?P \\<Longrightarrow>\n  \\<turnstile>\\<^sub>p {?P} SKIP {?P}\n  is_quantum_predicate ?P \\<Longrightarrow>\n  \\<turnstile>\\<^sub>p {adjoint ?U * ?P * ?U} Utrans ?U {?P}\n  \\<lbrakk>is_quantum_predicate ?P; is_quantum_predicate ?Q;\n   is_quantum_predicate ?R; \\<turnstile>\\<^sub>p {?P} ?S1.0 {?Q};\n   \\<turnstile>\\<^sub>p {?Q} ?S2.0 {?R}\\<rbrakk>\n  \\<Longrightarrow> \\<turnstile>\\<^sub>p {?P} ?S1.0;; ?S2.0 {?R}\n  \\<lbrakk>\\<And>k. k < ?n \\<Longrightarrow> is_quantum_predicate (?P k);\n   is_quantum_predicate ?Q;\n   \\<And>k.\n      k < ?n \\<Longrightarrow>\n      \\<turnstile>\\<^sub>p {?P k} ?S ! k {?Q}\\<rbrakk>\n  \\<Longrightarrow> \\<turnstile>\\<^sub>p {matrix_sum d\n     (\\<lambda>k. adjoint (?M k) * ?P k * ?M k) ?n}\n   Measure ?n ?M ?S {?Q}\n  \\<lbrakk>is_quantum_predicate ?P; is_quantum_predicate ?Q;\n   \\<turnstile>\\<^sub>p {?Q} ?S\n                        {adjoint (?M 0) * ?P * ?M 0 +\n                         adjoint (?M 1) * ?Q * ?M 1}\\<rbrakk>\n  \\<Longrightarrow> \\<turnstile>\\<^sub>p {adjoint (?M 0) * ?P * ?M 0 +\n    adjoint (?M 1) * ?Q * ?M 1}\n   While ?M ?S {?P}\n  \\<lbrakk>is_quantum_predicate ?P; is_quantum_predicate ?Q;\n   is_quantum_predicate ?P'; is_quantum_predicate ?Q'; ?P \\<le>\\<^sub>L ?P';\n   \\<turnstile>\\<^sub>p {?P'} ?S {?Q'}; ?Q' \\<le>\\<^sub>L ?Q\\<rbrakk>\n  \\<Longrightarrow> \\<turnstile>\\<^sub>p {?P} ?S {?Q}\n\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>p {adjoint U * P * U} Utrans U {P}", "by auto"], ["proof (state)\nthis:\n  \\<turnstile>\\<^sub>p {wlp (Utrans U) P} Utrans U {P}\n\ngoal (3 subgoals):\n 1. \\<And>S1 S2 P.\n       \\<lbrakk>\\<And>P.\n                   \\<lbrakk>well_com S1; is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>p {wlp S1 P} S1 {P};\n        \\<And>P.\n           \\<lbrakk>well_com S2; is_quantum_predicate P\\<rbrakk>\n           \\<Longrightarrow> \\<turnstile>\\<^sub>p {wlp S2 P} S2 {P};\n        well_com (S1;; S2); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>p {wlp (S1;; S2) P} S1;; S2 {P}\n 2. \\<And>x1 x2a x3 P.\n       \\<lbrakk>\\<And>x3a P.\n                   \\<lbrakk>x3a \\<in> set x3; well_com x3a;\n                    is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>p {wlp x3a P} x3a\n                    {P};\n        well_com (Measure x1 x2a x3); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>p {wlp (Measure x1 x2a x3) P}\n        Measure x1 x2a x3 {P}\n 3. \\<And>x1 S P.\n       \\<lbrakk>\\<And>P.\n                   \\<lbrakk>well_com S; is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>p {wlp S P} S {P};\n        well_com (While x1 S); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>p {wlp (While x1 S) P}\n        While x1 S {P}", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>S1 S2 P.\n       \\<lbrakk>\\<And>P.\n                   \\<lbrakk>well_com S1; is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>p {wlp S1 P} S1 {P};\n        \\<And>P.\n           \\<lbrakk>well_com S2; is_quantum_predicate P\\<rbrakk>\n           \\<Longrightarrow> \\<turnstile>\\<^sub>p {wlp S2 P} S2 {P};\n        well_com (S1;; S2); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>p {wlp (S1;; S2) P} S1;; S2 {P}\n 2. \\<And>x1 x2a x3 P.\n       \\<lbrakk>\\<And>x3a P.\n                   \\<lbrakk>x3a \\<in> set x3; well_com x3a;\n                    is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>p {wlp x3a P} x3a\n                    {P};\n        well_com (Measure x1 x2a x3); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>p {wlp (Measure x1 x2a x3) P}\n        Measure x1 x2a x3 {P}\n 3. \\<And>x1 S P.\n       \\<lbrakk>\\<And>P.\n                   \\<lbrakk>well_com S; is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>p {wlp S P} S {P};\n        well_com (While x1 S); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>p {wlp (While x1 S) P}\n        While x1 S {P}", "case (Seq S1 S2)"], ["proof (state)\nthis:\n  \\<lbrakk>well_com S1; is_quantum_predicate ?P\\<rbrakk>\n  \\<Longrightarrow> \\<turnstile>\\<^sub>p {wlp S1 ?P} S1 {?P}\n  \\<lbrakk>well_com S2; is_quantum_predicate ?P\\<rbrakk>\n  \\<Longrightarrow> \\<turnstile>\\<^sub>p {wlp S2 ?P} S2 {?P}\n  well_com (S1;; S2)\n  is_quantum_predicate P\n\ngoal (3 subgoals):\n 1. \\<And>S1 S2 P.\n       \\<lbrakk>\\<And>P.\n                   \\<lbrakk>well_com S1; is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>p {wlp S1 P} S1 {P};\n        \\<And>P.\n           \\<lbrakk>well_com S2; is_quantum_predicate P\\<rbrakk>\n           \\<Longrightarrow> \\<turnstile>\\<^sub>p {wlp S2 P} S2 {P};\n        well_com (S1;; S2); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>p {wlp (S1;; S2) P} S1;; S2 {P}\n 2. \\<And>x1 x2a x3 P.\n       \\<lbrakk>\\<And>x3a P.\n                   \\<lbrakk>x3a \\<in> set x3; well_com x3a;\n                    is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>p {wlp x3a P} x3a\n                    {P};\n        well_com (Measure x1 x2a x3); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>p {wlp (Measure x1 x2a x3) P}\n        Measure x1 x2a x3 {P}\n 3. \\<And>x1 S P.\n       \\<lbrakk>\\<And>P.\n                   \\<lbrakk>well_com S; is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>p {wlp S P} S {P};\n        well_com (While x1 S); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>p {wlp (While x1 S) P}\n        While x1 S {P}", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>well_com S1; is_quantum_predicate ?P\\<rbrakk>\n  \\<Longrightarrow> \\<turnstile>\\<^sub>p {wlp S1 ?P} S1 {?P}\n  \\<lbrakk>well_com S2; is_quantum_predicate ?P\\<rbrakk>\n  \\<Longrightarrow> \\<turnstile>\\<^sub>p {wlp S2 ?P} S2 {?P}\n  well_com (S1;; S2)\n  is_quantum_predicate P", "have wc1: \"well_com S1\" and wc2: \"well_com S2\" and qpP: \"is_quantum_predicate P\" \n    and p2: \"\\<turnstile>\\<^sub>p {wlp S2 P} S2 {P}\""], ["proof (prove)\nusing this:\n  \\<lbrakk>well_com S1; is_quantum_predicate ?P\\<rbrakk>\n  \\<Longrightarrow> \\<turnstile>\\<^sub>p {wlp S1 ?P} S1 {?P}\n  \\<lbrakk>well_com S2; is_quantum_predicate ?P\\<rbrakk>\n  \\<Longrightarrow> \\<turnstile>\\<^sub>p {wlp S2 ?P} S2 {?P}\n  well_com (S1;; S2)\n  is_quantum_predicate P\n\ngoal (1 subgoal):\n 1. (well_com S1 &&& well_com S2) &&&\n    is_quantum_predicate P &&& \\<turnstile>\\<^sub>p {wlp S2 P} S2 {P}", "by auto"], ["proof (state)\nthis:\n  well_com S1\n  well_com S2\n  is_quantum_predicate P\n  \\<turnstile>\\<^sub>p {wlp S2 P} S2 {P}\n\ngoal (3 subgoals):\n 1. \\<And>S1 S2 P.\n       \\<lbrakk>\\<And>P.\n                   \\<lbrakk>well_com S1; is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>p {wlp S1 P} S1 {P};\n        \\<And>P.\n           \\<lbrakk>well_com S2; is_quantum_predicate P\\<rbrakk>\n           \\<Longrightarrow> \\<turnstile>\\<^sub>p {wlp S2 P} S2 {P};\n        well_com (S1;; S2); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>p {wlp (S1;; S2) P} S1;; S2 {P}\n 2. \\<And>x1 x2a x3 P.\n       \\<lbrakk>\\<And>x3a P.\n                   \\<lbrakk>x3a \\<in> set x3; well_com x3a;\n                    is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>p {wlp x3a P} x3a\n                    {P};\n        well_com (Measure x1 x2a x3); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>p {wlp (Measure x1 x2a x3) P}\n        Measure x1 x2a x3 {P}\n 3. \\<And>x1 S P.\n       \\<lbrakk>\\<And>P.\n                   \\<lbrakk>well_com S; is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>p {wlp S P} S {P};\n        well_com (While x1 S); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>p {wlp (While x1 S) P}\n        While x1 S {P}", "have qpW2P: \"is_quantum_predicate (wlp S2 P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_quantum_predicate (wlp S2 P)", "using wlp_close[OF wc2 qpP]"], ["proof (prove)\nusing this:\n  is_quantum_predicate (wlp S2 P)\n\ngoal (1 subgoal):\n 1. is_quantum_predicate (wlp S2 P)", "by auto"], ["proof (state)\nthis:\n  is_quantum_predicate (wlp S2 P)\n\ngoal (3 subgoals):\n 1. \\<And>S1 S2 P.\n       \\<lbrakk>\\<And>P.\n                   \\<lbrakk>well_com S1; is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>p {wlp S1 P} S1 {P};\n        \\<And>P.\n           \\<lbrakk>well_com S2; is_quantum_predicate P\\<rbrakk>\n           \\<Longrightarrow> \\<turnstile>\\<^sub>p {wlp S2 P} S2 {P};\n        well_com (S1;; S2); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>p {wlp (S1;; S2) P} S1;; S2 {P}\n 2. \\<And>x1 x2a x3 P.\n       \\<lbrakk>\\<And>x3a P.\n                   \\<lbrakk>x3a \\<in> set x3; well_com x3a;\n                    is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>p {wlp x3a P} x3a\n                    {P};\n        well_com (Measure x1 x2a x3); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>p {wlp (Measure x1 x2a x3) P}\n        Measure x1 x2a x3 {P}\n 3. \\<And>x1 S P.\n       \\<lbrakk>\\<And>P.\n                   \\<lbrakk>well_com S; is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>p {wlp S P} S {P};\n        well_com (While x1 S); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>p {wlp (While x1 S) P}\n        While x1 S {P}", "then"], ["proof (chain)\npicking this:\n  is_quantum_predicate (wlp S2 P)", "have p1: \"\\<turnstile>\\<^sub>p {wlp S1 (wlp S2 P)} S1 {wlp S2 P}\""], ["proof (prove)\nusing this:\n  is_quantum_predicate (wlp S2 P)\n\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>p {wlp S1 (wlp S2 P)} S1 {wlp S2 P}", "using Seq"], ["proof (prove)\nusing this:\n  is_quantum_predicate (wlp S2 P)\n  \\<lbrakk>well_com S1; is_quantum_predicate ?P\\<rbrakk>\n  \\<Longrightarrow> \\<turnstile>\\<^sub>p {wlp S1 ?P} S1 {?P}\n  \\<lbrakk>well_com S2; is_quantum_predicate ?P\\<rbrakk>\n  \\<Longrightarrow> \\<turnstile>\\<^sub>p {wlp S2 ?P} S2 {?P}\n  well_com (S1;; S2)\n  is_quantum_predicate P\n\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>p {wlp S1 (wlp S2 P)} S1 {wlp S2 P}", "by auto"], ["proof (state)\nthis:\n  \\<turnstile>\\<^sub>p {wlp S1 (wlp S2 P)} S1 {wlp S2 P}\n\ngoal (3 subgoals):\n 1. \\<And>S1 S2 P.\n       \\<lbrakk>\\<And>P.\n                   \\<lbrakk>well_com S1; is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>p {wlp S1 P} S1 {P};\n        \\<And>P.\n           \\<lbrakk>well_com S2; is_quantum_predicate P\\<rbrakk>\n           \\<Longrightarrow> \\<turnstile>\\<^sub>p {wlp S2 P} S2 {P};\n        well_com (S1;; S2); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>p {wlp (S1;; S2) P} S1;; S2 {P}\n 2. \\<And>x1 x2a x3 P.\n       \\<lbrakk>\\<And>x3a P.\n                   \\<lbrakk>x3a \\<in> set x3; well_com x3a;\n                    is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>p {wlp x3a P} x3a\n                    {P};\n        well_com (Measure x1 x2a x3); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>p {wlp (Measure x1 x2a x3) P}\n        Measure x1 x2a x3 {P}\n 3. \\<And>x1 S P.\n       \\<lbrakk>\\<And>P.\n                   \\<lbrakk>well_com S; is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>p {wlp S P} S {P};\n        well_com (While x1 S); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>p {wlp (While x1 S) P}\n        While x1 S {P}", "have qpW1W2P: \"is_quantum_predicate (wlp S1 (wlp S2 P))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_quantum_predicate (wlp S1 (wlp S2 P))", "using wlp_close[OF wc1 qpW2P]"], ["proof (prove)\nusing this:\n  is_quantum_predicate (wlp S1 (wlp S2 P))\n\ngoal (1 subgoal):\n 1. is_quantum_predicate (wlp S1 (wlp S2 P))", "by auto"], ["proof (state)\nthis:\n  is_quantum_predicate (wlp S1 (wlp S2 P))\n\ngoal (3 subgoals):\n 1. \\<And>S1 S2 P.\n       \\<lbrakk>\\<And>P.\n                   \\<lbrakk>well_com S1; is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>p {wlp S1 P} S1 {P};\n        \\<And>P.\n           \\<lbrakk>well_com S2; is_quantum_predicate P\\<rbrakk>\n           \\<Longrightarrow> \\<turnstile>\\<^sub>p {wlp S2 P} S2 {P};\n        well_com (S1;; S2); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>p {wlp (S1;; S2) P} S1;; S2 {P}\n 2. \\<And>x1 x2a x3 P.\n       \\<lbrakk>\\<And>x3a P.\n                   \\<lbrakk>x3a \\<in> set x3; well_com x3a;\n                    is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>p {wlp x3a P} x3a\n                    {P};\n        well_com (Measure x1 x2a x3); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>p {wlp (Measure x1 x2a x3) P}\n        Measure x1 x2a x3 {P}\n 3. \\<And>x1 S P.\n       \\<lbrakk>\\<And>P.\n                   \\<lbrakk>well_com S; is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>p {wlp S P} S {P};\n        well_com (While x1 S); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>p {wlp (While x1 S) P}\n        While x1 S {P}", "then"], ["proof (chain)\npicking this:\n  is_quantum_predicate (wlp S1 (wlp S2 P))", "show ?case"], ["proof (prove)\nusing this:\n  is_quantum_predicate (wlp S1 (wlp S2 P))\n\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>p {wlp (S1;; S2) P} S1;; S2 {P}", "unfolding wlp.simps"], ["proof (prove)\nusing this:\n  is_quantum_predicate (wlp S1 (wlp S2 P))\n\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>p {wlp S1 (wlp S2 P)} S1;; S2 {P}", "using hoare_partial.intros qpW1W2P qpW2P qpP p1 p2"], ["proof (prove)\nusing this:\n  is_quantum_predicate (wlp S1 (wlp S2 P))\n  is_quantum_predicate ?P \\<Longrightarrow>\n  \\<turnstile>\\<^sub>p {?P} SKIP {?P}\n  is_quantum_predicate ?P \\<Longrightarrow>\n  \\<turnstile>\\<^sub>p {adjoint ?U * ?P * ?U} Utrans ?U {?P}\n  \\<lbrakk>is_quantum_predicate ?P; is_quantum_predicate ?Q;\n   is_quantum_predicate ?R; \\<turnstile>\\<^sub>p {?P} ?S1.0 {?Q};\n   \\<turnstile>\\<^sub>p {?Q} ?S2.0 {?R}\\<rbrakk>\n  \\<Longrightarrow> \\<turnstile>\\<^sub>p {?P} ?S1.0;; ?S2.0 {?R}\n  \\<lbrakk>\\<And>k. k < ?n \\<Longrightarrow> is_quantum_predicate (?P k);\n   is_quantum_predicate ?Q;\n   \\<And>k.\n      k < ?n \\<Longrightarrow>\n      \\<turnstile>\\<^sub>p {?P k} ?S ! k {?Q}\\<rbrakk>\n  \\<Longrightarrow> \\<turnstile>\\<^sub>p {matrix_sum d\n     (\\<lambda>k. adjoint (?M k) * ?P k * ?M k) ?n}\n   Measure ?n ?M ?S {?Q}\n  \\<lbrakk>is_quantum_predicate ?P; is_quantum_predicate ?Q;\n   \\<turnstile>\\<^sub>p {?Q} ?S\n                        {adjoint (?M 0) * ?P * ?M 0 +\n                         adjoint (?M 1) * ?Q * ?M 1}\\<rbrakk>\n  \\<Longrightarrow> \\<turnstile>\\<^sub>p {adjoint (?M 0) * ?P * ?M 0 +\n    adjoint (?M 1) * ?Q * ?M 1}\n   While ?M ?S {?P}\n  \\<lbrakk>is_quantum_predicate ?P; is_quantum_predicate ?Q;\n   is_quantum_predicate ?P'; is_quantum_predicate ?Q'; ?P \\<le>\\<^sub>L ?P';\n   \\<turnstile>\\<^sub>p {?P'} ?S {?Q'}; ?Q' \\<le>\\<^sub>L ?Q\\<rbrakk>\n  \\<Longrightarrow> \\<turnstile>\\<^sub>p {?P} ?S {?Q}\n  is_quantum_predicate (wlp S1 (wlp S2 P))\n  is_quantum_predicate (wlp S2 P)\n  is_quantum_predicate P\n  \\<turnstile>\\<^sub>p {wlp S1 (wlp S2 P)} S1 {wlp S2 P}\n  \\<turnstile>\\<^sub>p {wlp S2 P} S2 {P}\n\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>p {wlp S1 (wlp S2 P)} S1;; S2 {P}", "by auto"], ["proof (state)\nthis:\n  \\<turnstile>\\<^sub>p {wlp (S1;; S2) P} S1;; S2 {P}\n\ngoal (2 subgoals):\n 1. \\<And>x1 x2a x3 P.\n       \\<lbrakk>\\<And>x3a P.\n                   \\<lbrakk>x3a \\<in> set x3; well_com x3a;\n                    is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>p {wlp x3a P} x3a\n                    {P};\n        well_com (Measure x1 x2a x3); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>p {wlp (Measure x1 x2a x3) P}\n        Measure x1 x2a x3 {P}\n 2. \\<And>x1 S P.\n       \\<lbrakk>\\<And>P.\n                   \\<lbrakk>well_com S; is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>p {wlp S P} S {P};\n        well_com (While x1 S); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>p {wlp (While x1 S) P}\n        While x1 S {P}", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1 x2a x3 P.\n       \\<lbrakk>\\<And>x3a P.\n                   \\<lbrakk>x3a \\<in> set x3; well_com x3a;\n                    is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>p {wlp x3a P} x3a\n                    {P};\n        well_com (Measure x1 x2a x3); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>p {wlp (Measure x1 x2a x3) P}\n        Measure x1 x2a x3 {P}\n 2. \\<And>x1 S P.\n       \\<lbrakk>\\<And>P.\n                   \\<lbrakk>well_com S; is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>p {wlp S P} S {P};\n        well_com (While x1 S); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>p {wlp (While x1 S) P}\n        While x1 S {P}", "case (Measure n M S)"], ["proof (state)\nthis:\n  \\<lbrakk>?x3a \\<in> set S; well_com ?x3a; is_quantum_predicate ?P\\<rbrakk>\n  \\<Longrightarrow> \\<turnstile>\\<^sub>p {wlp ?x3a ?P} ?x3a {?P}\n  well_com (Measure n M S)\n  is_quantum_predicate P\n\ngoal (2 subgoals):\n 1. \\<And>x1 x2a x3 P.\n       \\<lbrakk>\\<And>x3a P.\n                   \\<lbrakk>x3a \\<in> set x3; well_com x3a;\n                    is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>p {wlp x3a P} x3a\n                    {P};\n        well_com (Measure x1 x2a x3); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>p {wlp (Measure x1 x2a x3) P}\n        Measure x1 x2a x3 {P}\n 2. \\<And>x1 S P.\n       \\<lbrakk>\\<And>P.\n                   \\<lbrakk>well_com S; is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>p {wlp S P} S {P};\n        well_com (While x1 S); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>p {wlp (While x1 S) P}\n        While x1 S {P}", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>?x3a \\<in> set S; well_com ?x3a; is_quantum_predicate ?P\\<rbrakk>\n  \\<Longrightarrow> \\<turnstile>\\<^sub>p {wlp ?x3a ?P} ?x3a {?P}\n  well_com (Measure n M S)\n  is_quantum_predicate P", "have wc: \"well_com (Measure n M S)\" and qpP: \"is_quantum_predicate P\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?x3a \\<in> set S; well_com ?x3a; is_quantum_predicate ?P\\<rbrakk>\n  \\<Longrightarrow> \\<turnstile>\\<^sub>p {wlp ?x3a ?P} ?x3a {?P}\n  well_com (Measure n M S)\n  is_quantum_predicate P\n\ngoal (1 subgoal):\n 1. well_com (Measure n M S) &&& is_quantum_predicate P", "by auto"], ["proof (state)\nthis:\n  well_com (Measure n M S)\n  is_quantum_predicate P\n\ngoal (2 subgoals):\n 1. \\<And>x1 x2a x3 P.\n       \\<lbrakk>\\<And>x3a P.\n                   \\<lbrakk>x3a \\<in> set x3; well_com x3a;\n                    is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>p {wlp x3a P} x3a\n                    {P};\n        well_com (Measure x1 x2a x3); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>p {wlp (Measure x1 x2a x3) P}\n        Measure x1 x2a x3 {P}\n 2. \\<And>x1 S P.\n       \\<lbrakk>\\<And>P.\n                   \\<lbrakk>well_com S; is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>p {wlp S P} S {P};\n        well_com (While x1 S); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>p {wlp (While x1 S) P}\n        While x1 S {P}", "have set: \"k < n \\<Longrightarrow> (S!k) \\<in> set S\" for k"], ["proof (prove)\ngoal (1 subgoal):\n 1. k < n \\<Longrightarrow> S ! k \\<in> set S", "using wc"], ["proof (prove)\nusing this:\n  well_com (Measure n M S)\n\ngoal (1 subgoal):\n 1. k < n \\<Longrightarrow> S ! k \\<in> set S", "by auto"], ["proof (state)\nthis:\n  ?k < n \\<Longrightarrow> S ! ?k \\<in> set S\n\ngoal (2 subgoals):\n 1. \\<And>x1 x2a x3 P.\n       \\<lbrakk>\\<And>x3a P.\n                   \\<lbrakk>x3a \\<in> set x3; well_com x3a;\n                    is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>p {wlp x3a P} x3a\n                    {P};\n        well_com (Measure x1 x2a x3); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>p {wlp (Measure x1 x2a x3) P}\n        Measure x1 x2a x3 {P}\n 2. \\<And>x1 S P.\n       \\<lbrakk>\\<And>P.\n                   \\<lbrakk>well_com S; is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>p {wlp S P} S {P};\n        well_com (While x1 S); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>p {wlp (While x1 S) P}\n        While x1 S {P}", "have wck: \"k < n \\<Longrightarrow> well_com (S!k)\" for k"], ["proof (prove)\ngoal (1 subgoal):\n 1. k < n \\<Longrightarrow> well_com (S ! k)", "using wc measure_well_com"], ["proof (prove)\nusing this:\n  well_com (Measure n M S)\n  \\<lbrakk>well_com (Measure ?n ?M ?S); ?k < ?n\\<rbrakk>\n  \\<Longrightarrow> well_com (?S ! ?k)\n\ngoal (1 subgoal):\n 1. k < n \\<Longrightarrow> well_com (S ! k)", "by auto"], ["proof (state)\nthis:\n  ?k < n \\<Longrightarrow> well_com (S ! ?k)\n\ngoal (2 subgoals):\n 1. \\<And>x1 x2a x3 P.\n       \\<lbrakk>\\<And>x3a P.\n                   \\<lbrakk>x3a \\<in> set x3; well_com x3a;\n                    is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>p {wlp x3a P} x3a\n                    {P};\n        well_com (Measure x1 x2a x3); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>p {wlp (Measure x1 x2a x3) P}\n        Measure x1 x2a x3 {P}\n 2. \\<And>x1 S P.\n       \\<lbrakk>\\<And>P.\n                   \\<lbrakk>well_com S; is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>p {wlp S P} S {P};\n        well_com (While x1 S); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>p {wlp (While x1 S) P}\n        While x1 S {P}", "then"], ["proof (chain)\npicking this:\n  ?k < n \\<Longrightarrow> well_com (S ! ?k)", "have qpWkP: \"k < n \\<Longrightarrow> is_quantum_predicate (wlp (S!k) P)\" for k"], ["proof (prove)\nusing this:\n  ?k < n \\<Longrightarrow> well_com (S ! ?k)\n\ngoal (1 subgoal):\n 1. k < n \\<Longrightarrow> is_quantum_predicate (wlp (S ! k) P)", "using wlp_close qpP"], ["proof (prove)\nusing this:\n  ?k < n \\<Longrightarrow> well_com (S ! ?k)\n  \\<lbrakk>well_com ?S; is_quantum_predicate ?P\\<rbrakk>\n  \\<Longrightarrow> is_quantum_predicate (wlp ?S ?P)\n  is_quantum_predicate P\n\ngoal (1 subgoal):\n 1. k < n \\<Longrightarrow> is_quantum_predicate (wlp (S ! k) P)", "by auto"], ["proof (state)\nthis:\n  ?k < n \\<Longrightarrow> is_quantum_predicate (wlp (S ! ?k) P)\n\ngoal (2 subgoals):\n 1. \\<And>x1 x2a x3 P.\n       \\<lbrakk>\\<And>x3a P.\n                   \\<lbrakk>x3a \\<in> set x3; well_com x3a;\n                    is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>p {wlp x3a P} x3a\n                    {P};\n        well_com (Measure x1 x2a x3); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>p {wlp (Measure x1 x2a x3) P}\n        Measure x1 x2a x3 {P}\n 2. \\<And>x1 S P.\n       \\<lbrakk>\\<And>P.\n                   \\<lbrakk>well_com S; is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>p {wlp S P} S {P};\n        well_com (While x1 S); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>p {wlp (While x1 S) P}\n        While x1 S {P}", "have pk: \"k < n \\<Longrightarrow> \\<turnstile>\\<^sub>p {(wlp (S!k) P)} (S!k) {P}\" for k"], ["proof (prove)\ngoal (1 subgoal):\n 1. k < n \\<Longrightarrow> \\<turnstile>\\<^sub>p {wlp (S ! k) P} S ! k {P}", "using Measure(1) set wck qpP"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x3a \\<in> set S; well_com ?x3a; is_quantum_predicate ?P\\<rbrakk>\n  \\<Longrightarrow> \\<turnstile>\\<^sub>p {wlp ?x3a ?P} ?x3a {?P}\n  ?k < n \\<Longrightarrow> S ! ?k \\<in> set S\n  ?k < n \\<Longrightarrow> well_com (S ! ?k)\n  is_quantum_predicate P\n\ngoal (1 subgoal):\n 1. k < n \\<Longrightarrow> \\<turnstile>\\<^sub>p {wlp (S ! k) P} S ! k {P}", "by auto"], ["proof (state)\nthis:\n  ?k < n \\<Longrightarrow> \\<turnstile>\\<^sub>p {wlp (S ! ?k) P} S ! ?k {P}\n\ngoal (2 subgoals):\n 1. \\<And>x1 x2a x3 P.\n       \\<lbrakk>\\<And>x3a P.\n                   \\<lbrakk>x3a \\<in> set x3; well_com x3a;\n                    is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>p {wlp x3a P} x3a\n                    {P};\n        well_com (Measure x1 x2a x3); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>p {wlp (Measure x1 x2a x3) P}\n        Measure x1 x2a x3 {P}\n 2. \\<And>x1 S P.\n       \\<lbrakk>\\<And>P.\n                   \\<lbrakk>well_com S; is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>p {wlp S P} S {P};\n        well_com (While x1 S); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>p {wlp (While x1 S) P}\n        While x1 S {P}", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>p {wlp (Measure n M S) P} Measure n M S {P}", "unfolding wlp_measure_expand[OF wc]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>p {matrix_sum d\n                           (\\<lambda>k. adjoint (M k) * wlp (S ! k) P * M k)\n                           n}\n                         Measure n M S {P}", "using hoare_partial.intros qpWkP qpP pk"], ["proof (prove)\nusing this:\n  is_quantum_predicate ?P \\<Longrightarrow>\n  \\<turnstile>\\<^sub>p {?P} SKIP {?P}\n  is_quantum_predicate ?P \\<Longrightarrow>\n  \\<turnstile>\\<^sub>p {adjoint ?U * ?P * ?U} Utrans ?U {?P}\n  \\<lbrakk>is_quantum_predicate ?P; is_quantum_predicate ?Q;\n   is_quantum_predicate ?R; \\<turnstile>\\<^sub>p {?P} ?S1.0 {?Q};\n   \\<turnstile>\\<^sub>p {?Q} ?S2.0 {?R}\\<rbrakk>\n  \\<Longrightarrow> \\<turnstile>\\<^sub>p {?P} ?S1.0;; ?S2.0 {?R}\n  \\<lbrakk>\\<And>k. k < ?n \\<Longrightarrow> is_quantum_predicate (?P k);\n   is_quantum_predicate ?Q;\n   \\<And>k.\n      k < ?n \\<Longrightarrow>\n      \\<turnstile>\\<^sub>p {?P k} ?S ! k {?Q}\\<rbrakk>\n  \\<Longrightarrow> \\<turnstile>\\<^sub>p {matrix_sum d\n     (\\<lambda>k. adjoint (?M k) * ?P k * ?M k) ?n}\n   Measure ?n ?M ?S {?Q}\n  \\<lbrakk>is_quantum_predicate ?P; is_quantum_predicate ?Q;\n   \\<turnstile>\\<^sub>p {?Q} ?S\n                        {adjoint (?M 0) * ?P * ?M 0 +\n                         adjoint (?M 1) * ?Q * ?M 1}\\<rbrakk>\n  \\<Longrightarrow> \\<turnstile>\\<^sub>p {adjoint (?M 0) * ?P * ?M 0 +\n    adjoint (?M 1) * ?Q * ?M 1}\n   While ?M ?S {?P}\n  \\<lbrakk>is_quantum_predicate ?P; is_quantum_predicate ?Q;\n   is_quantum_predicate ?P'; is_quantum_predicate ?Q'; ?P \\<le>\\<^sub>L ?P';\n   \\<turnstile>\\<^sub>p {?P'} ?S {?Q'}; ?Q' \\<le>\\<^sub>L ?Q\\<rbrakk>\n  \\<Longrightarrow> \\<turnstile>\\<^sub>p {?P} ?S {?Q}\n  ?k < n \\<Longrightarrow> is_quantum_predicate (wlp (S ! ?k) P)\n  is_quantum_predicate P\n  ?k < n \\<Longrightarrow> \\<turnstile>\\<^sub>p {wlp (S ! ?k) P} S ! ?k {P}\n\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>p {matrix_sum d\n                           (\\<lambda>k. adjoint (M k) * wlp (S ! k) P * M k)\n                           n}\n                         Measure n M S {P}", "by auto"], ["proof (state)\nthis:\n  \\<turnstile>\\<^sub>p {wlp (Measure n M S) P} Measure n M S {P}\n\ngoal (1 subgoal):\n 1. \\<And>x1 S P.\n       \\<lbrakk>\\<And>P.\n                   \\<lbrakk>well_com S; is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>p {wlp S P} S {P};\n        well_com (While x1 S); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>p {wlp (While x1 S) P}\n        While x1 S {P}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1 S P.\n       \\<lbrakk>\\<And>P.\n                   \\<lbrakk>well_com S; is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>p {wlp S P} S {P};\n        well_com (While x1 S); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>p {wlp (While x1 S) P}\n        While x1 S {P}", "case (While M S)"], ["proof (state)\nthis:\n  \\<lbrakk>well_com S; is_quantum_predicate ?P\\<rbrakk>\n  \\<Longrightarrow> \\<turnstile>\\<^sub>p {wlp S ?P} S {?P}\n  well_com (While M S)\n  is_quantum_predicate P\n\ngoal (1 subgoal):\n 1. \\<And>x1 S P.\n       \\<lbrakk>\\<And>P.\n                   \\<lbrakk>well_com S; is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>p {wlp S P} S {P};\n        well_com (While x1 S); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>p {wlp (While x1 S) P}\n        While x1 S {P}", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>well_com S; is_quantum_predicate ?P\\<rbrakk>\n  \\<Longrightarrow> \\<turnstile>\\<^sub>p {wlp S ?P} S {?P}\n  well_com (While M S)\n  is_quantum_predicate P", "have wc: \"well_com (While M S)\" and wcS: \"well_com S\" and qpP: \"is_quantum_predicate P \""], ["proof (prove)\nusing this:\n  \\<lbrakk>well_com S; is_quantum_predicate ?P\\<rbrakk>\n  \\<Longrightarrow> \\<turnstile>\\<^sub>p {wlp S ?P} S {?P}\n  well_com (While M S)\n  is_quantum_predicate P\n\ngoal (1 subgoal):\n 1. well_com (While M S) &&& well_com S &&& is_quantum_predicate P", "by auto"], ["proof (state)\nthis:\n  well_com (While M S)\n  well_com S\n  is_quantum_predicate P\n\ngoal (1 subgoal):\n 1. \\<And>x1 S P.\n       \\<lbrakk>\\<And>P.\n                   \\<lbrakk>well_com S; is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>p {wlp S P} S {P};\n        well_com (While x1 S); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>p {wlp (While x1 S) P}\n        While x1 S {P}", "have qpWP: \"is_quantum_predicate (wlp (While M S) P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_quantum_predicate (wlp (While M S) P)", "using wlp_close[OF wc qpP]"], ["proof (prove)\nusing this:\n  is_quantum_predicate (wlp (While M S) P)\n\ngoal (1 subgoal):\n 1. is_quantum_predicate (wlp (While M S) P)", "by auto"], ["proof (state)\nthis:\n  is_quantum_predicate (wlp (While M S) P)\n\ngoal (1 subgoal):\n 1. \\<And>x1 S P.\n       \\<lbrakk>\\<And>P.\n                   \\<lbrakk>well_com S; is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>p {wlp S P} S {P};\n        well_com (While x1 S); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>p {wlp (While x1 S) P}\n        While x1 S {P}", "then"], ["proof (chain)\npicking this:\n  is_quantum_predicate (wlp (While M S) P)", "have qpWWP: \"is_quantum_predicate (wlp S (wlp (While M S) P))\""], ["proof (prove)\nusing this:\n  is_quantum_predicate (wlp (While M S) P)\n\ngoal (1 subgoal):\n 1. is_quantum_predicate (wlp S (wlp (While M S) P))", "using wlp_close wcS"], ["proof (prove)\nusing this:\n  is_quantum_predicate (wlp (While M S) P)\n  \\<lbrakk>well_com ?S; is_quantum_predicate ?P\\<rbrakk>\n  \\<Longrightarrow> is_quantum_predicate (wlp ?S ?P)\n  well_com S\n\ngoal (1 subgoal):\n 1. is_quantum_predicate (wlp S (wlp (While M S) P))", "by auto"], ["proof (state)\nthis:\n  is_quantum_predicate (wlp S (wlp (While M S) P))\n\ngoal (1 subgoal):\n 1. \\<And>x1 S P.\n       \\<lbrakk>\\<And>P.\n                   \\<lbrakk>well_com S; is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>p {wlp S P} S {P};\n        well_com (While x1 S); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>p {wlp (While x1 S) P}\n        While x1 S {P}", "have \"\\<turnstile>\\<^sub>p {wlp S (wlp (While M S) P)} S {wlp (While M S) P}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>p {wlp S (wlp (While M S) P)} S {wlp (While M S) P}", "using While(1) wcS qpWP"], ["proof (prove)\nusing this:\n  \\<lbrakk>well_com S; is_quantum_predicate ?P\\<rbrakk>\n  \\<Longrightarrow> \\<turnstile>\\<^sub>p {wlp S ?P} S {?P}\n  well_com S\n  is_quantum_predicate (wlp (While M S) P)\n\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>p {wlp S (wlp (While M S) P)} S {wlp (While M S) P}", "by auto"], ["proof (state)\nthis:\n  \\<turnstile>\\<^sub>p {wlp S (wlp (While M S) P)} S {wlp (While M S) P}\n\ngoal (1 subgoal):\n 1. \\<And>x1 S P.\n       \\<lbrakk>\\<And>P.\n                   \\<lbrakk>well_com S; is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>p {wlp S P} S {P};\n        well_com (While x1 S); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>p {wlp (While x1 S) P}\n        While x1 S {P}", "moreover"], ["proof (state)\nthis:\n  \\<turnstile>\\<^sub>p {wlp S (wlp (While M S) P)} S {wlp (While M S) P}\n\ngoal (1 subgoal):\n 1. \\<And>x1 S P.\n       \\<lbrakk>\\<And>P.\n                   \\<lbrakk>well_com S; is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>p {wlp S P} S {P};\n        well_com (While x1 S); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>p {wlp (While x1 S) P}\n        While x1 S {P}", "have eq: \"wlp (While M S) P = adjoint (M 0) * P * M 0 + adjoint (M 1) * wlp S (wlp (While M S) P) * M 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wlp (While M S) P =\n    adjoint (M 0) * P * M 0 +\n    adjoint (M 1) * wlp S (wlp (While M S) P) * M 1", "using wlp_while_split wc qpP"], ["proof (prove)\nusing this:\n  \\<lbrakk>well_com (While ?M ?S); is_quantum_predicate ?P\\<rbrakk>\n  \\<Longrightarrow> wlp (While ?M ?S) ?P =\n                    adjoint (?M 0) * ?P * ?M 0 +\n                    adjoint (?M 1) * wlp ?S (wlp (While ?M ?S) ?P) * ?M 1\n  well_com (While M S)\n  is_quantum_predicate P\n\ngoal (1 subgoal):\n 1. wlp (While M S) P =\n    adjoint (M 0) * P * M 0 +\n    adjoint (M 1) * wlp S (wlp (While M S) P) * M 1", "by auto"], ["proof (state)\nthis:\n  wlp (While M S) P =\n  adjoint (M 0) * P * M 0 + adjoint (M 1) * wlp S (wlp (While M S) P) * M 1\n\ngoal (1 subgoal):\n 1. \\<And>x1 S P.\n       \\<lbrakk>\\<And>P.\n                   \\<lbrakk>well_com S; is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>p {wlp S P} S {P};\n        well_com (While x1 S); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>p {wlp (While x1 S) P}\n        While x1 S {P}", "ultimately"], ["proof (chain)\npicking this:\n  \\<turnstile>\\<^sub>p {wlp S (wlp (While M S) P)} S {wlp (While M S) P}\n  wlp (While M S) P =\n  adjoint (M 0) * P * M 0 + adjoint (M 1) * wlp S (wlp (While M S) P) * M 1", "have p: \"\\<turnstile>\\<^sub>p {wlp S (wlp (While M S) P)} S {adjoint (M 0) * P * M 0 + adjoint (M 1) * wlp S (wlp (While M S) P) * M 1}\""], ["proof (prove)\nusing this:\n  \\<turnstile>\\<^sub>p {wlp S (wlp (While M S) P)} S {wlp (While M S) P}\n  wlp (While M S) P =\n  adjoint (M 0) * P * M 0 + adjoint (M 1) * wlp S (wlp (While M S) P) * M 1\n\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>p {wlp S (wlp (While M S) P)} S\n                         {adjoint (M 0) * P * M 0 +\n                          adjoint (M 1) * wlp S (wlp (While M S) P) * M 1}", "by auto"], ["proof (state)\nthis:\n  \\<turnstile>\\<^sub>p {wlp S (wlp (While M S) P)} S\n                       {adjoint (M 0) * P * M 0 +\n                        adjoint (M 1) * wlp S (wlp (While M S) P) * M 1}\n\ngoal (1 subgoal):\n 1. \\<And>x1 S P.\n       \\<lbrakk>\\<And>P.\n                   \\<lbrakk>well_com S; is_quantum_predicate P\\<rbrakk>\n                   \\<Longrightarrow> \\<turnstile>\\<^sub>p {wlp S P} S {P};\n        well_com (While x1 S); is_quantum_predicate P\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>p {wlp (While x1 S) P}\n        While x1 S {P}", "then"], ["proof (chain)\npicking this:\n  \\<turnstile>\\<^sub>p {wlp S (wlp (While M S) P)} S\n                       {adjoint (M 0) * P * M 0 +\n                        adjoint (M 1) * wlp S (wlp (While M S) P) * M 1}", "show ?case"], ["proof (prove)\nusing this:\n  \\<turnstile>\\<^sub>p {wlp S (wlp (While M S) P)} S\n                       {adjoint (M 0) * P * M 0 +\n                        adjoint (M 1) * wlp S (wlp (While M S) P) * M 1}\n\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>p {wlp (While M S) P} While M S {P}", "using hoare_partial.intros(5)[OF qpP qpWWP p] eq"], ["proof (prove)\nusing this:\n  \\<turnstile>\\<^sub>p {wlp S (wlp (While M S) P)} S\n                       {adjoint (M 0) * P * M 0 +\n                        adjoint (M 1) * wlp S (wlp (While M S) P) * M 1}\n  \\<turnstile>\\<^sub>p {adjoint (M 0) * P * M 0 +\n                        adjoint (M 1) * wlp S (wlp (While M S) P) * M 1}\n                       While M S {P}\n  wlp (While M S) P =\n  adjoint (M 0) * P * M 0 + adjoint (M 1) * wlp S (wlp (While M S) P) * M 1\n\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>p {wlp (While M S) P} While M S {P}", "by auto"], ["proof (state)\nthis:\n  \\<turnstile>\\<^sub>p {wlp (While M S) P} While M S {P}\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem hoare_partial_complete:\n  \"\\<Turnstile>\\<^sub>p {P} S {Q} \\<Longrightarrow> well_com S \\<Longrightarrow> is_quantum_predicate P \\<Longrightarrow> is_quantum_predicate Q \\<Longrightarrow> \\<turnstile>\\<^sub>p {P} S {Q}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<Turnstile>\\<^sub>p {P} S {Q}; well_com S;\n     is_quantum_predicate P; is_quantum_predicate Q\\<rbrakk>\n    \\<Longrightarrow> \\<turnstile>\\<^sub>p {P} S {Q}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<Turnstile>\\<^sub>p {P} S {Q}; well_com S;\n     is_quantum_predicate P; is_quantum_predicate Q\\<rbrakk>\n    \\<Longrightarrow> \\<turnstile>\\<^sub>p {P} S {Q}", "assume p: \"\\<Turnstile>\\<^sub>p {P} S {Q}\" and wc: \"well_com S\" and qpP: \"is_quantum_predicate P\" and qpQ: \"is_quantum_predicate Q\""], ["proof (state)\nthis:\n  \\<Turnstile>\\<^sub>p {P} S {Q}\n  well_com S\n  is_quantum_predicate P\n  is_quantum_predicate Q\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<Turnstile>\\<^sub>p {P} S {Q}; well_com S;\n     is_quantum_predicate P; is_quantum_predicate Q\\<rbrakk>\n    \\<Longrightarrow> \\<turnstile>\\<^sub>p {P} S {Q}", "then"], ["proof (chain)\npicking this:\n  \\<Turnstile>\\<^sub>p {P} S {Q}\n  well_com S\n  is_quantum_predicate P\n  is_quantum_predicate Q", "have dQ: \"Q \\<in> carrier_mat d d\""], ["proof (prove)\nusing this:\n  \\<Turnstile>\\<^sub>p {P} S {Q}\n  well_com S\n  is_quantum_predicate P\n  is_quantum_predicate Q\n\ngoal (1 subgoal):\n 1. Q \\<in> carrier_mat d d", "using is_quantum_predicate_def"], ["proof (prove)\nusing this:\n  \\<Turnstile>\\<^sub>p {P} S {Q}\n  well_com S\n  is_quantum_predicate P\n  is_quantum_predicate Q\n  is_quantum_predicate ?P =\n  (?P \\<in> carrier_mat d d \\<and>\n   positive ?P \\<and> ?P \\<le>\\<^sub>L 1\\<^sub>m d)\n\ngoal (1 subgoal):\n 1. Q \\<in> carrier_mat d d", "by auto"], ["proof (state)\nthis:\n  Q \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<Turnstile>\\<^sub>p {P} S {Q}; well_com S;\n     is_quantum_predicate P; is_quantum_predicate Q\\<rbrakk>\n    \\<Longrightarrow> \\<turnstile>\\<^sub>p {P} S {Q}", "have qpWP: \"is_quantum_predicate (wlp S Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_quantum_predicate (wlp S Q)", "using wlp_close wc qpQ"], ["proof (prove)\nusing this:\n  \\<lbrakk>well_com ?S; is_quantum_predicate ?P\\<rbrakk>\n  \\<Longrightarrow> is_quantum_predicate (wlp ?S ?P)\n  well_com S\n  is_quantum_predicate Q\n\ngoal (1 subgoal):\n 1. is_quantum_predicate (wlp S Q)", "by auto"], ["proof (state)\nthis:\n  is_quantum_predicate (wlp S Q)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<Turnstile>\\<^sub>p {P} S {Q}; well_com S;\n     is_quantum_predicate P; is_quantum_predicate Q\\<rbrakk>\n    \\<Longrightarrow> \\<turnstile>\\<^sub>p {P} S {Q}", "then"], ["proof (chain)\npicking this:\n  is_quantum_predicate (wlp S Q)", "have dWP: \"wlp S Q \\<in> carrier_mat d d\""], ["proof (prove)\nusing this:\n  is_quantum_predicate (wlp S Q)\n\ngoal (1 subgoal):\n 1. wlp S Q \\<in> carrier_mat d d", "using is_quantum_predicate_def"], ["proof (prove)\nusing this:\n  is_quantum_predicate (wlp S Q)\n  is_quantum_predicate ?P =\n  (?P \\<in> carrier_mat d d \\<and>\n   positive ?P \\<and> ?P \\<le>\\<^sub>L 1\\<^sub>m d)\n\ngoal (1 subgoal):\n 1. wlp S Q \\<in> carrier_mat d d", "by auto"], ["proof (state)\nthis:\n  wlp S Q \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<Turnstile>\\<^sub>p {P} S {Q}; well_com S;\n     is_quantum_predicate P; is_quantum_predicate Q\\<rbrakk>\n    \\<Longrightarrow> \\<turnstile>\\<^sub>p {P} S {Q}", "have eq: \"trace (wlp S Q * \\<rho>) = trace (Q * (denote S \\<rho>)) + trace \\<rho> - trace (denote S \\<rho>)\" if dsr: \"\\<rho> \\<in> density_states\" for \\<rho>"], ["proof (prove)\ngoal (1 subgoal):\n 1. trace (wlp S Q * \\<rho>) =\n    trace (Q * denote S \\<rho>) + trace \\<rho> - trace (denote S \\<rho>)", "using wlp_soundness wc qpQ dsr"], ["proof (prove)\nusing this:\n  \\<lbrakk>well_com ?S; is_quantum_predicate ?P\\<rbrakk>\n  \\<Longrightarrow> \\<forall>\\<rho>\\<in>density_states.\n                       trace (wlp ?S ?P * \\<rho>) =\n                       trace (?P * denote ?S \\<rho>) + trace \\<rho> -\n                       trace (denote ?S \\<rho>)\n  well_com S\n  is_quantum_predicate Q\n  \\<rho> \\<in> density_states\n\ngoal (1 subgoal):\n 1. trace (wlp S Q * \\<rho>) =\n    trace (Q * denote S \\<rho>) + trace \\<rho> - trace (denote S \\<rho>)", "by auto"], ["proof (state)\nthis:\n  ?\\<rho> \\<in> density_states \\<Longrightarrow>\n  trace (wlp S Q * ?\\<rho>) =\n  trace (Q * denote S ?\\<rho>) + trace ?\\<rho> - trace (denote S ?\\<rho>)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<Turnstile>\\<^sub>p {P} S {Q}; well_com S;\n     is_quantum_predicate P; is_quantum_predicate Q\\<rbrakk>\n    \\<Longrightarrow> \\<turnstile>\\<^sub>p {P} S {Q}", "then"], ["proof (chain)\npicking this:\n  ?\\<rho> \\<in> density_states \\<Longrightarrow>\n  trace (wlp S Q * ?\\<rho>) =\n  trace (Q * denote S ?\\<rho>) + trace ?\\<rho> - trace (denote S ?\\<rho>)", "have \"\\<Turnstile>\\<^sub>p {wlp S Q} S {Q}\""], ["proof (prove)\nusing this:\n  ?\\<rho> \\<in> density_states \\<Longrightarrow>\n  trace (wlp S Q * ?\\<rho>) =\n  trace (Q * denote S ?\\<rho>) + trace ?\\<rho> - trace (denote S ?\\<rho>)\n\ngoal (1 subgoal):\n 1. \\<Turnstile>\\<^sub>p {wlp S Q} S {Q}", "unfolding hoare_partial_correct_def"], ["proof (prove)\nusing this:\n  ?\\<rho> \\<in> density_states \\<Longrightarrow>\n  trace (wlp S Q * ?\\<rho>) =\n  trace (Q * denote S ?\\<rho>) + trace ?\\<rho> - trace (denote S ?\\<rho>)\n\ngoal (1 subgoal):\n 1. \\<forall>\\<rho>\\<in>density_states.\n       trace (wlp S Q * \\<rho>)\n       \\<le> trace (Q * denote S \\<rho>) +\n             (trace \\<rho> - trace (denote S \\<rho>))", "by auto"], ["proof (state)\nthis:\n  \\<Turnstile>\\<^sub>p {wlp S Q} S {Q}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<Turnstile>\\<^sub>p {P} S {Q}; well_com S;\n     is_quantum_predicate P; is_quantum_predicate Q\\<rbrakk>\n    \\<Longrightarrow> \\<turnstile>\\<^sub>p {P} S {Q}", "{"], ["proof (state)\nthis:\n  \\<Turnstile>\\<^sub>p {wlp S Q} S {Q}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<Turnstile>\\<^sub>p {P} S {Q}; well_com S;\n     is_quantum_predicate P; is_quantum_predicate Q\\<rbrakk>\n    \\<Longrightarrow> \\<turnstile>\\<^sub>p {P} S {Q}", "fix \\<rho>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<Turnstile>\\<^sub>p {P} S {Q}; well_com S;\n     is_quantum_predicate P; is_quantum_predicate Q\\<rbrakk>\n    \\<Longrightarrow> \\<turnstile>\\<^sub>p {P} S {Q}", "assume dsr: \"\\<rho> \\<in> density_states\""], ["proof (state)\nthis:\n  \\<rho> \\<in> density_states\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<Turnstile>\\<^sub>p {P} S {Q}; well_com S;\n     is_quantum_predicate P; is_quantum_predicate Q\\<rbrakk>\n    \\<Longrightarrow> \\<turnstile>\\<^sub>p {P} S {Q}", "then"], ["proof (chain)\npicking this:\n  \\<rho> \\<in> density_states", "have \"trace (P * \\<rho>) \\<le> trace (Q * (denote S \\<rho>)) + trace \\<rho> - trace (denote S \\<rho>)\""], ["proof (prove)\nusing this:\n  \\<rho> \\<in> density_states\n\ngoal (1 subgoal):\n 1. trace (P * \\<rho>)\n    \\<le> trace (Q * denote S \\<rho>) + trace \\<rho> -\n          trace (denote S \\<rho>)", "using hoare_partial_correct_def p"], ["proof (prove)\nusing this:\n  \\<rho> \\<in> density_states\n  (\\<Turnstile>\\<^sub>p {?P} ?S {?Q}) =\n  (\\<forall>\\<rho>\\<in>density_states.\n      trace (?P * \\<rho>)\n      \\<le> trace (?Q * denote ?S \\<rho>) +\n            (trace \\<rho> - trace (denote ?S \\<rho>)))\n  \\<Turnstile>\\<^sub>p {P} S {Q}\n\ngoal (1 subgoal):\n 1. trace (P * \\<rho>)\n    \\<le> trace (Q * denote S \\<rho>) + trace \\<rho> -\n          trace (denote S \\<rho>)", "by auto"], ["proof (state)\nthis:\n  trace (P * \\<rho>)\n  \\<le> trace (Q * denote S \\<rho>) + trace \\<rho> - trace (denote S \\<rho>)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<Turnstile>\\<^sub>p {P} S {Q}; well_com S;\n     is_quantum_predicate P; is_quantum_predicate Q\\<rbrakk>\n    \\<Longrightarrow> \\<turnstile>\\<^sub>p {P} S {Q}", "then"], ["proof (chain)\npicking this:\n  trace (P * \\<rho>)\n  \\<le> trace (Q * denote S \\<rho>) + trace \\<rho> - trace (denote S \\<rho>)", "have \"trace (P * \\<rho>) \\<le> trace (wlp S Q * \\<rho>)\""], ["proof (prove)\nusing this:\n  trace (P * \\<rho>)\n  \\<le> trace (Q * denote S \\<rho>) + trace \\<rho> - trace (denote S \\<rho>)\n\ngoal (1 subgoal):\n 1. trace (P * \\<rho>) \\<le> trace (wlp S Q * \\<rho>)", "using eq[symmetric] dsr"], ["proof (prove)\nusing this:\n  trace (P * \\<rho>)\n  \\<le> trace (Q * denote S \\<rho>) + trace \\<rho> - trace (denote S \\<rho>)\n  ?\\<rho> \\<in> density_states \\<Longrightarrow>\n  trace (Q * denote S ?\\<rho>) + trace ?\\<rho> - trace (denote S ?\\<rho>) =\n  trace (wlp S Q * ?\\<rho>)\n  \\<rho> \\<in> density_states\n\ngoal (1 subgoal):\n 1. trace (P * \\<rho>) \\<le> trace (wlp S Q * \\<rho>)", "by auto"], ["proof (state)\nthis:\n  trace (P * \\<rho>) \\<le> trace (wlp S Q * \\<rho>)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<Turnstile>\\<^sub>p {P} S {Q}; well_com S;\n     is_quantum_predicate P; is_quantum_predicate Q\\<rbrakk>\n    \\<Longrightarrow> \\<turnstile>\\<^sub>p {P} S {Q}", "}"], ["proof (state)\nthis:\n  ?\\<rho>2 \\<in> density_states \\<Longrightarrow>\n  trace (P * ?\\<rho>2) \\<le> trace (wlp S Q * ?\\<rho>2)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<Turnstile>\\<^sub>p {P} S {Q}; well_com S;\n     is_quantum_predicate P; is_quantum_predicate Q\\<rbrakk>\n    \\<Longrightarrow> \\<turnstile>\\<^sub>p {P} S {Q}", "then"], ["proof (chain)\npicking this:\n  ?\\<rho>2 \\<in> density_states \\<Longrightarrow>\n  trace (P * ?\\<rho>2) \\<le> trace (wlp S Q * ?\\<rho>2)", "have le: \"P \\<le>\\<^sub>L wlp S Q\""], ["proof (prove)\nusing this:\n  ?\\<rho>2 \\<in> density_states \\<Longrightarrow>\n  trace (P * ?\\<rho>2) \\<le> trace (wlp S Q * ?\\<rho>2)\n\ngoal (1 subgoal):\n 1. P \\<le>\\<^sub>L wlp S Q", "using lowner_le_trace density_states_def qpP qpWP is_quantum_predicate_def"], ["proof (prove)\nusing this:\n  ?\\<rho>2 \\<in> density_states \\<Longrightarrow>\n  trace (P * ?\\<rho>2) \\<le> trace (wlp S Q * ?\\<rho>2)\n  \\<lbrakk>?A \\<in> carrier_mat ?n ?n; ?B \\<in> carrier_mat ?n ?n\\<rbrakk>\n  \\<Longrightarrow> (?A \\<le>\\<^sub>L ?B) =\n                    (\\<forall>\\<rho>\\<in>carrier_mat ?n ?n.\n                        partial_density_operator \\<rho> \\<longrightarrow>\n                        trace (?A * \\<rho>) \\<le> trace (?B * \\<rho>))\n  density_states =\n  {\\<rho> \\<in> carrier_mat d d. partial_density_operator \\<rho>}\n  is_quantum_predicate P\n  is_quantum_predicate (wlp S Q)\n  is_quantum_predicate ?P =\n  (?P \\<in> carrier_mat d d \\<and>\n   positive ?P \\<and> ?P \\<le>\\<^sub>L 1\\<^sub>m d)\n\ngoal (1 subgoal):\n 1. P \\<le>\\<^sub>L wlp S Q", "by auto"], ["proof (state)\nthis:\n  P \\<le>\\<^sub>L wlp S Q\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<Turnstile>\\<^sub>p {P} S {Q}; well_com S;\n     is_quantum_predicate P; is_quantum_predicate Q\\<rbrakk>\n    \\<Longrightarrow> \\<turnstile>\\<^sub>p {P} S {Q}", "moreover"], ["proof (state)\nthis:\n  P \\<le>\\<^sub>L wlp S Q\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<Turnstile>\\<^sub>p {P} S {Q}; well_com S;\n     is_quantum_predicate P; is_quantum_predicate Q\\<rbrakk>\n    \\<Longrightarrow> \\<turnstile>\\<^sub>p {P} S {Q}", "have wlp: \"\\<turnstile>\\<^sub>p {wlp S Q} S {Q}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>p {wlp S Q} S {Q}", "using wlp_complete wc qpQ"], ["proof (prove)\nusing this:\n  \\<lbrakk>well_com ?S; is_quantum_predicate ?P\\<rbrakk>\n  \\<Longrightarrow> \\<turnstile>\\<^sub>p {wlp ?S ?P} ?S {?P}\n  well_com S\n  is_quantum_predicate Q\n\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>p {wlp S Q} S {Q}", "by auto"], ["proof (state)\nthis:\n  \\<turnstile>\\<^sub>p {wlp S Q} S {Q}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<Turnstile>\\<^sub>p {P} S {Q}; well_com S;\n     is_quantum_predicate P; is_quantum_predicate Q\\<rbrakk>\n    \\<Longrightarrow> \\<turnstile>\\<^sub>p {P} S {Q}", "ultimately"], ["proof (chain)\npicking this:\n  P \\<le>\\<^sub>L wlp S Q\n  \\<turnstile>\\<^sub>p {wlp S Q} S {Q}", "show \"\\<turnstile>\\<^sub>p {P} S {Q}\""], ["proof (prove)\nusing this:\n  P \\<le>\\<^sub>L wlp S Q\n  \\<turnstile>\\<^sub>p {wlp S Q} S {Q}\n\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>p {P} S {Q}", "using hoare_partial.intros(6)[OF qpP qpQ qpWP qpQ] lowner_le_refl[OF dQ]"], ["proof (prove)\nusing this:\n  P \\<le>\\<^sub>L wlp S Q\n  \\<turnstile>\\<^sub>p {wlp S Q} S {Q}\n  \\<lbrakk>P \\<le>\\<^sub>L wlp S Q; \\<turnstile>\\<^sub>p {wlp S Q} ?S {Q};\n   Q \\<le>\\<^sub>L Q\\<rbrakk>\n  \\<Longrightarrow> \\<turnstile>\\<^sub>p {P} ?S {Q}\n  Q \\<le>\\<^sub>L Q\n\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>p {P} S {Q}", "by auto"], ["proof (state)\nthis:\n  \\<turnstile>\\<^sub>p {P} S {Q}\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Consequences of completeness\\<close>"], ["", "lemma hoare_patial_seq_assoc_sem:\n  shows \"\\<Turnstile>\\<^sub>p {A} (S1 ;; S2) ;; S3 {B} \\<longleftrightarrow> \\<Turnstile>\\<^sub>p {A} S1 ;; (S2 ;; S3) {B}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Turnstile>\\<^sub>p {A} S1;; S2;; S3 {B}) =\n    (\\<Turnstile>\\<^sub>p {A} S1;; (S2;; S3) {B})", "unfolding hoare_partial_correct_def denote.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>\\<rho>\\<in>density_states.\n        trace (A * \\<rho>)\n        \\<le> trace (B * denote S3 (denote S2 (denote S1 \\<rho>))) +\n              (trace \\<rho> -\n               trace (denote S3 (denote S2 (denote S1 \\<rho>))))) =\n    (\\<forall>\\<rho>\\<in>density_states.\n        trace (A * \\<rho>)\n        \\<le> trace (B * denote S3 (denote S2 (denote S1 \\<rho>))) +\n              (trace \\<rho> -\n               trace (denote S3 (denote S2 (denote S1 \\<rho>)))))", "by auto"], ["", "lemma hoare_patial_seq_assoc:\n  assumes \"well_com S1\" and \"well_com S2\" and \"well_com S3\"\n    and \"is_quantum_predicate A\" and \"is_quantum_predicate B\"\n  shows \"\\<turnstile>\\<^sub>p {A} (S1 ;; S2) ;; S3 {B} \\<longleftrightarrow> \\<turnstile>\\<^sub>p {A} S1 ;; (S2 ;; S3) {B}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<turnstile>\\<^sub>p {A} S1;; S2;; S3 {B}) =\n    (\\<turnstile>\\<^sub>p {A} S1;; (S2;; S3) {B})", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<turnstile>\\<^sub>p {A} S1;; S2;; S3 {B} \\<Longrightarrow>\n    \\<turnstile>\\<^sub>p {A} S1;; (S2;; S3) {B}\n 2. \\<turnstile>\\<^sub>p {A} S1;; (S2;; S3) {B} \\<Longrightarrow>\n    \\<turnstile>\\<^sub>p {A} S1;; S2;; S3 {B}", "assume \"\\<turnstile>\\<^sub>p {A} S1;; S2;; S3 {B}\""], ["proof (state)\nthis:\n  \\<turnstile>\\<^sub>p {A} S1;; S2;; S3 {B}\n\ngoal (2 subgoals):\n 1. \\<turnstile>\\<^sub>p {A} S1;; S2;; S3 {B} \\<Longrightarrow>\n    \\<turnstile>\\<^sub>p {A} S1;; (S2;; S3) {B}\n 2. \\<turnstile>\\<^sub>p {A} S1;; (S2;; S3) {B} \\<Longrightarrow>\n    \\<turnstile>\\<^sub>p {A} S1;; S2;; S3 {B}", "then"], ["proof (chain)\npicking this:\n  \\<turnstile>\\<^sub>p {A} S1;; S2;; S3 {B}", "have \"\\<Turnstile>\\<^sub>p {A} (S1 ;; S2) ;; S3 {B}\""], ["proof (prove)\nusing this:\n  \\<turnstile>\\<^sub>p {A} S1;; S2;; S3 {B}\n\ngoal (1 subgoal):\n 1. \\<Turnstile>\\<^sub>p {A} S1;; S2;; S3 {B}", "using hoare_partial_sound assms"], ["proof (prove)\nusing this:\n  \\<turnstile>\\<^sub>p {A} S1;; S2;; S3 {B}\n  \\<lbrakk>\\<turnstile>\\<^sub>p {?P} ?S {?Q}; well_com ?S\\<rbrakk>\n  \\<Longrightarrow> \\<Turnstile>\\<^sub>p {?P} ?S {?Q}\n  well_com S1\n  well_com S2\n  well_com S3\n  is_quantum_predicate A\n  is_quantum_predicate B\n\ngoal (1 subgoal):\n 1. \\<Turnstile>\\<^sub>p {A} S1;; S2;; S3 {B}", "by auto"], ["proof (state)\nthis:\n  \\<Turnstile>\\<^sub>p {A} S1;; S2;; S3 {B}\n\ngoal (2 subgoals):\n 1. \\<turnstile>\\<^sub>p {A} S1;; S2;; S3 {B} \\<Longrightarrow>\n    \\<turnstile>\\<^sub>p {A} S1;; (S2;; S3) {B}\n 2. \\<turnstile>\\<^sub>p {A} S1;; (S2;; S3) {B} \\<Longrightarrow>\n    \\<turnstile>\\<^sub>p {A} S1;; S2;; S3 {B}", "then"], ["proof (chain)\npicking this:\n  \\<Turnstile>\\<^sub>p {A} S1;; S2;; S3 {B}", "have \"\\<Turnstile>\\<^sub>p {A} S1 ;; (S2 ;; S3) {B}\""], ["proof (prove)\nusing this:\n  \\<Turnstile>\\<^sub>p {A} S1;; S2;; S3 {B}\n\ngoal (1 subgoal):\n 1. \\<Turnstile>\\<^sub>p {A} S1;; (S2;; S3) {B}", "using hoare_patial_seq_assoc_sem"], ["proof (prove)\nusing this:\n  \\<Turnstile>\\<^sub>p {A} S1;; S2;; S3 {B}\n  (\\<Turnstile>\\<^sub>p {?A} ?S1.0;; ?S2.0;; ?S3.0 {?B}) =\n  (\\<Turnstile>\\<^sub>p {?A} ?S1.0;; (?S2.0;; ?S3.0) {?B})\n\ngoal (1 subgoal):\n 1. \\<Turnstile>\\<^sub>p {A} S1;; (S2;; S3) {B}", "by auto"], ["proof (state)\nthis:\n  \\<Turnstile>\\<^sub>p {A} S1;; (S2;; S3) {B}\n\ngoal (2 subgoals):\n 1. \\<turnstile>\\<^sub>p {A} S1;; S2;; S3 {B} \\<Longrightarrow>\n    \\<turnstile>\\<^sub>p {A} S1;; (S2;; S3) {B}\n 2. \\<turnstile>\\<^sub>p {A} S1;; (S2;; S3) {B} \\<Longrightarrow>\n    \\<turnstile>\\<^sub>p {A} S1;; S2;; S3 {B}", "then"], ["proof (chain)\npicking this:\n  \\<Turnstile>\\<^sub>p {A} S1;; (S2;; S3) {B}", "show \"\\<turnstile>\\<^sub>p {A} S1 ;; (S2 ;; S3) {B}\""], ["proof (prove)\nusing this:\n  \\<Turnstile>\\<^sub>p {A} S1;; (S2;; S3) {B}\n\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>p {A} S1;; (S2;; S3) {B}", "using hoare_partial_complete assms"], ["proof (prove)\nusing this:\n  \\<Turnstile>\\<^sub>p {A} S1;; (S2;; S3) {B}\n  \\<lbrakk>\\<Turnstile>\\<^sub>p {?P} ?S {?Q}; well_com ?S;\n   is_quantum_predicate ?P; is_quantum_predicate ?Q\\<rbrakk>\n  \\<Longrightarrow> \\<turnstile>\\<^sub>p {?P} ?S {?Q}\n  well_com S1\n  well_com S2\n  well_com S3\n  is_quantum_predicate A\n  is_quantum_predicate B\n\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>p {A} S1;; (S2;; S3) {B}", "by auto"], ["proof (state)\nthis:\n  \\<turnstile>\\<^sub>p {A} S1;; (S2;; S3) {B}\n\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>p {A} S1;; (S2;; S3) {B} \\<Longrightarrow>\n    \\<turnstile>\\<^sub>p {A} S1;; S2;; S3 {B}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>p {A} S1;; (S2;; S3) {B} \\<Longrightarrow>\n    \\<turnstile>\\<^sub>p {A} S1;; S2;; S3 {B}", "assume \"\\<turnstile>\\<^sub>p {A} S1;; (S2;; S3) {B}\""], ["proof (state)\nthis:\n  \\<turnstile>\\<^sub>p {A} S1;; (S2;; S3) {B}\n\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>p {A} S1;; (S2;; S3) {B} \\<Longrightarrow>\n    \\<turnstile>\\<^sub>p {A} S1;; S2;; S3 {B}", "then"], ["proof (chain)\npicking this:\n  \\<turnstile>\\<^sub>p {A} S1;; (S2;; S3) {B}", "have \"\\<Turnstile>\\<^sub>p {A} S1;; (S2;; S3) {B}\""], ["proof (prove)\nusing this:\n  \\<turnstile>\\<^sub>p {A} S1;; (S2;; S3) {B}\n\ngoal (1 subgoal):\n 1. \\<Turnstile>\\<^sub>p {A} S1;; (S2;; S3) {B}", "using hoare_partial_sound assms"], ["proof (prove)\nusing this:\n  \\<turnstile>\\<^sub>p {A} S1;; (S2;; S3) {B}\n  \\<lbrakk>\\<turnstile>\\<^sub>p {?P} ?S {?Q}; well_com ?S\\<rbrakk>\n  \\<Longrightarrow> \\<Turnstile>\\<^sub>p {?P} ?S {?Q}\n  well_com S1\n  well_com S2\n  well_com S3\n  is_quantum_predicate A\n  is_quantum_predicate B\n\ngoal (1 subgoal):\n 1. \\<Turnstile>\\<^sub>p {A} S1;; (S2;; S3) {B}", "by auto"], ["proof (state)\nthis:\n  \\<Turnstile>\\<^sub>p {A} S1;; (S2;; S3) {B}\n\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>p {A} S1;; (S2;; S3) {B} \\<Longrightarrow>\n    \\<turnstile>\\<^sub>p {A} S1;; S2;; S3 {B}", "then"], ["proof (chain)\npicking this:\n  \\<Turnstile>\\<^sub>p {A} S1;; (S2;; S3) {B}", "have \"\\<Turnstile>\\<^sub>p {A} S1;; S2;; S3 {B}\""], ["proof (prove)\nusing this:\n  \\<Turnstile>\\<^sub>p {A} S1;; (S2;; S3) {B}\n\ngoal (1 subgoal):\n 1. \\<Turnstile>\\<^sub>p {A} S1;; S2;; S3 {B}", "using hoare_patial_seq_assoc_sem"], ["proof (prove)\nusing this:\n  \\<Turnstile>\\<^sub>p {A} S1;; (S2;; S3) {B}\n  (\\<Turnstile>\\<^sub>p {?A} ?S1.0;; ?S2.0;; ?S3.0 {?B}) =\n  (\\<Turnstile>\\<^sub>p {?A} ?S1.0;; (?S2.0;; ?S3.0) {?B})\n\ngoal (1 subgoal):\n 1. \\<Turnstile>\\<^sub>p {A} S1;; S2;; S3 {B}", "by auto"], ["proof (state)\nthis:\n  \\<Turnstile>\\<^sub>p {A} S1;; S2;; S3 {B}\n\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>p {A} S1;; (S2;; S3) {B} \\<Longrightarrow>\n    \\<turnstile>\\<^sub>p {A} S1;; S2;; S3 {B}", "then"], ["proof (chain)\npicking this:\n  \\<Turnstile>\\<^sub>p {A} S1;; S2;; S3 {B}", "show \"\\<turnstile>\\<^sub>p {A} S1;; S2;; S3 {B}\""], ["proof (prove)\nusing this:\n  \\<Turnstile>\\<^sub>p {A} S1;; S2;; S3 {B}\n\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>p {A} S1;; S2;; S3 {B}", "using hoare_partial_complete assms"], ["proof (prove)\nusing this:\n  \\<Turnstile>\\<^sub>p {A} S1;; S2;; S3 {B}\n  \\<lbrakk>\\<Turnstile>\\<^sub>p {?P} ?S {?Q}; well_com ?S;\n   is_quantum_predicate ?P; is_quantum_predicate ?Q\\<rbrakk>\n  \\<Longrightarrow> \\<turnstile>\\<^sub>p {?P} ?S {?Q}\n  well_com S1\n  well_com S2\n  well_com S3\n  is_quantum_predicate A\n  is_quantum_predicate B\n\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>p {A} S1;; S2;; S3 {B}", "by auto"], ["proof (state)\nthis:\n  \\<turnstile>\\<^sub>p {A} S1;; S2;; S3 {B}\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "end"]]}